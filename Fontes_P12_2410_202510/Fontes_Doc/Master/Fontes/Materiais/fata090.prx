#include "Protheus.ch"
#include "FATA090.CH"
#DEFINE MAXGETDAD 4096
#DEFINE MAXSAVERESULT 4096
Static cTesBonus

/*/


Ŀ
Funo     FATA090   Autor Eduardo Riera           Data 09.05.2001  
Ĵ
Descrio  Rotina de Manutencao das Regras de Bonificacao               
Ĵ
Sintaxe    FATA090                                                      
Ĵ
Parametros                                                              
Ĵ
Uso        Materiais/Distribuicao/Logistica                             
Ĵ
 AtualizACQes sofridas desde a Construcao Inicial.                       
Ĵ
 Programador   Data    BOPS   Motivo da Alteracao                     
Ĵ
                                                                      
ٱ


/*/

Function FATA090(xAutoCab,xAutoItens,nOpcAuto)

Private lFt180Auto 	:= Valtype(xAutoCab) == "A"
PRIVATE aAutoCab  	:= {}
PRIVATE aAutoItens	:= {}

Private aRotina   := MenuDef()
Private cCadastro := OemToAnsi(STR0007)	//"Manutencao das Regras de Bonificacao"

//Ŀ
// Define Array contendo as Rotinas a executar do programa      
// ----------- Elementos contidos por dimensao ------------     
// 1. Nome a aparecer no cabecalho                              
// 2. Nome da Rotina associada                                  
// 3. Usado pela rotina                                         
// 4. Tipo de Transao a ser efetuada                          
//    1 - Pesquisa e Posiciona em um Banco de Dados             
//    2 - Simplesmente Mostra os Campos                         
//    3 - Inclui registros no Bancos de Dados                   
//    4 - Altera o registro corrente                            
//    5 - Remove o registro corrente do Banco de Dados          
//

                      
//Ŀ
//Endereca para a funcao MBrowse                                          
//
dbSelectArea("ACQ")
dbSetOrder(1)
MsSeek(xFilial("ACQ"))

If xAutoCab == Nil .And. !lFt180Auto
	mBrowse(06,01,22,75,"ACQ")
Else
	aAutoCab   := xAutoCab
	aAutoItens := xAutoItens
	MBrowseAuto(nOpcAuto,aClone(aAutoCab),"ACQ")	
Endif

//Ŀ
//Restaura a Integridade da Rotina                                        
//
dbSelectArea("ACQ")
dbSetOrder(1)
dbClearFilter()
Return
/*/


Ŀ
Funo    Ft090RDes  Autor Eduardo Riera           Data 09.05.2001  
Ĵ
Descrio Rotina de Manutencao da Regra de Bonificacao                  
Ĵ
Sintaxe   Ft090RDes                                                     
Ĵ
ParametrosExpC1: Alias do Arquivo                                       
          ExpN2: Numero do Registro                                     
          ExpN3: Opcao do aRotina                                       
                                                                        
Ĵ
Uso        Materiais/Distribuicao/Logistica                             
Ĵ
 AtualizACQes sofridas desde a Construcao Inicial.                       
Ĵ
 Programador   Data    BOPS   Motivo da Alteracao                     
Ĵ
 Fernando     15/02/07119218Alterao feita para usar a FilgetDados   
                            na montagem do Aheader e Acols            
ٱ


/*/
Function Ft090RDes(cAlias,nReg,nOpc,xPar,lCopia)

Local aArea     := GetArea()
Local aPosObj   := {}
Local aObjects  := {}
Local aSize     := {}
Local aInfo     := {}
Local nUsado    := 0
Local nX        := 0
Local nOpcA     := 0      
Local nSaveSx8  := GetSx8Len()
Local lContinua := .T.
Local lGrade 	:= MaGrade()

Local oDlg
Local oGetD
Local cSeek  := Nil
Local cWhile :=	Nil

Private oGrade := MsMatGrade():New("oGrade",,"ACR_LOTE",,".T.",,{{"ACR_LOTE",.T. ,,.T. }}) 

Private aHeader := {}
Private aCols   := {}     
Private aTELA[0][0],aGETS[0]

DEFAULT INCLUI := .F.
DEFAULT lCopia := .F.

nOper := aRotina[ nOpc, 4 ]

INCLUI := ( nOper == 3 .And. !lCopia )

//Ŀ
//Inicializa as variaveis da Enchoice                                     
//
If INCLUI
	RegToMemory( "ACQ", .T., .F. )
EndIf

If !INCLUI
	If SoftLock("ACQ")
		RegToMemory( "ACQ", .F., .F. )
	Else
		lContinua := .F.
	EndIf
EndIf

If lContinua

	cSeek  := xFilial("ACR")+M->ACQ_CODREG
	cWhile := "ACR->ACR_FILIAL + ACR->ACR_CODREG"          
	
	FillGetDados(	nOpc , "ACR", 1, cSeek ,; 
						{||&(cWhile)}, {|| Iif (ACR->ACR_FILIAL + ACR->ACR_CODREG==xFilial("ACR")+M->ACQ_CODREG,.T.,.F.) }, /*aNoFields*/,; 
				   		/*aYesFields*/, /*lOnlyYes*/,/* cQuery*/, /*bMontAcols*/, IIf(nOpc<>3,.F.,.T.),; 
						/*aHeaderAux*/, /*aColsAux*/,{||Fat090Item()} , /*bBeforeCols*/,;
						/*bAfterHeader*/, /*cAliasQry*/)
	
	If lGrade					
		aCols := aColsGrade(oGrade,aCols,aHeader,"ACR_CODPRO","ACR_ITEM","ACR_ITEMGR",aScan(aHeader,{|x| AllTrim(x[2]) == "ACR_DESPRO"}))
	EndIf
						
	dbSelectArea( "ACQ" ) 	
	If lCopia
		M->ACQ_CODREG := CriaVar("ACQ_CODREG",.T.)
	EndIf
   
	dbSelectArea("ACR")
	
	//Ŀ
	// Faz o calculo automatico de dimensoes de objetos     
	//
	If (Type("lFt180Auto") == "U" .Or. ! lFt180Auto)
		aSize := MsAdvSize()
		AAdd( aObjects, { 100, 100, .T., .T. } )
		AAdd( aObjects, { 200, 200, .T., .T. } )
		aInfo := { aSize[ 1 ], aSize[ 2 ], aSize[ 3 ], aSize[ 4 ], 5, 5 }
		aPosObj := MsObjSize( aInfo, aObjects,.T.)
		
		DEFINE MSDIALOG oDlg TITLE cCadastro From aSize[7],0 To aSize[6],aSize[5] of oMainWnd PIXEL
		EnChoice( "ACQ", nReg, nOpc,,,,,aPosObj[1], , 3, , , , , ,.F. )
		oGetD := MsGetDados():New(aPosObj[2,1],aPosObj[2,2],aPosObj[2,3],aPosObj[2,4],nOpc,"Ft090LOk()","Ft090TOk()","+ACR_ITEM",(nOper==4 .Or. nOper==3),,1,,MAXGETDAD)
		ACTIVATE MSDIALOG oDlg ON INIT EnchoiceBar(oDlg,{||nOpcA := 1,If(oGetd:TudoOk(),If(!Obrigatorio(aGets,aTela),nOpcA := 0,oDlg:End()),nOpcA := 0)},{||oDlg:End()})
		FATPDLogUser("FT090RDES")
	Else
		If EnchAuto(cAlias,aAutoCab,{|| Obrigatorio(aGets,aTela)},aRotina[nOpc][4]) .And. MsGetDAuto(aAutoItens,"Ft090LOk",{|| Ft090TOk()},aAutoCab, aRotina[nOpc][4])
			nOpcA := 1
		EndIf	
	Endif
	//Ŀ
	//Rotina de Gravacao da Tabela de preco                         
	//
	If nOpcA == 1 .And. nOpc > 2
		Begin Transaction
			If lGrade
				aCols := aGradeCols(oGrade,aCols,aHeader,"ACR_CODPRO","ACR_ITEMGR","ACR_LOTE","ACR_ITEM")
			EndIf
			Ft090Grv(nOpc-2,lCopia)
			While (Getsx8Len() > nSaveSx8)
				ConfirmSx8()
			EndDo
			EvalTrigger()
		End Transaction
	EndIf
EndIf
//Ŀ
//Restaura a entrada da Rotina                                  
//
While (GetSx8Len() > nSaveSx8)
	RollBackSxE()
EndDo
MsUnLockAll()
FreeUsedCode()
RestArea(aArea)
Return(nOpcA)

/*


ͻ
Funcao    |Fat090ITem  Autor Fernando Amorim       Data  14/02/07  
͹
Descricao Inclui na primeira linha do acols o numero do item 		  
͹
Parametros												              
͹
Uso        Regras de descontos                                   	  
ͼ


*/

Static Function Fat090Item()
Local nX := 0
If Len(aCols) == 1
	For nX := 1 To Len(aHeader)
			If AllTrim(aHeader[nX,2]) == "ACR_ITEM"
				Acols[Len(Acols)][nX] := StrZero(1,Len(ACR->ACR_ITEM))
			
			EndIf    
	Next nX
EndIf  
Return(.T.)

/*/


Ŀ
Funo    Ft090Grv   Autor Eduardo Riera           Data  08/05/2001 
Ĵ
Descrio Rotina de Gravacao                                            
Ĵ
Sintaxe   Ft090Grv                                                      
Ĵ
ParametrosExpN1: Opcao da Gravacao sendo:                               
                 [1] Inclusao                                           
                 [2] Alteracao                                          
                 [3] Exclusao                                           
Ĵ
Uso        Materiais/Distribuicao/Logistica                             
Ĵ
 AtualizACQes sofridas desde a Construcao Inicial.                       
Ĵ
 Programador   Data    BOPS   Motivo da Alteracao                     
Ĵ
                                                                      
ٱ


/*/
Static Function Ft090Grv(nOpcao,lCopia)

Local aArea     := GetArea()
Local lGravou   := .F.
Local aRegNo    := {}
Local nPProd    := aScan(aHeader,{|x| AllTrim(x[2])=="ACR_CODPRO"})
Local nPLote    := aScan(aHeader,{|x| AllTrim(x[2])=="ACR_LOTE"})
Local nX        := 0
Local nY        := 0
Local nUsado    := Len(aHeader)
Local bCampo 	:= {|nCPO| Field(nCPO) }
Local cItem     := Repl("0",Len(ACR->ACR_ITEM))
Local cProcesCab := "023"												//Codigo do processo que sera utilizado para enviar a tabela ACQ
Local cProcesIte := "024"												//Codigo do processo que sera utilizado para enviar a tabela ACR
Local cChaveCab	 :=	""								   					//Chave utilizada na busca
Local cChaveIte	 := ""													//Chave utilizada na busca
Local cTabelaCab := "ACQ"												//Tabela enviada no processo Off-line
Local cTabelaIte := "ACR"												//Tabela enviada no processo Off-line

If nPProd > 0 .And. nPLote  > 0
	aCols := aSort(aCols,,,{|x,y| x[nPProd]+StrZero(x[nPLote ],18,2) < y[nPProd]+StrZero(y[nPLote ],18,2)})
EndIf

Do Case
Case nOpcao <> 3
	//Ŀ
	//Grava o Cabecalho                                             
	//
	dbSelectArea("ACQ")
	dbSetOrder(1)
	If MsSeek(xFilial("ACQ")+M->ACQ_CODREG)
		RecLock("ACQ",.F.)
	Else
		RecLock("ACQ",.T.)
	EndIf
	For nX := 1 TO FCount()
		FieldPut(nX,M->&(EVAL(bCampo,nX)))
	Next nX
	ACQ->ACQ_FILIAL := xFilial("ACQ")
	MsUnLock()

	//Insere o registro na integracao		
	cChaveCab:= xFilial("ACQ") + ACQ->ACQ_CODREG
	Om010CabOk(cProcesCab, cChaveCab, cTabelaCab)

	//Ŀ
	//Guarda os registro para reaproveita-los                       
	//
	dbSelectArea("ACR")
	dbSetOrder(1)
	MsSeek(xFilial("ACR")+M->ACQ_CODREG)
	While ( !Eof() .And. xFilial("ACR") == ACR->ACR_FILIAL .And. M->ACQ_CODREG == ACR->ACR_CODREG ) //No est entrando aqui
		aAdd(aRegNo,RecNo())
		dbSelectArea("ACR")
		dbSkip()
	EndDo

	//Ŀ
	//Grava os itens                                                
	//
	For nX := 1 To Len(aCols)
		If !lCopia .And. !Empty(aCols[nX,nUsado])
			dbSelectArea("ACR")
			dbGoto(aCols[nX,nUsado])
			RecLock("ACR")
			nY := aScan(aRegNo,{|x| x == aCols[nX,nUsado]})
			aDel(aRegNo,nY)
			aSize(aRegNo,Len(aRegNo)-1)
		ElseIf !aCols[nX][nUsado+1]
			RecLock("ACR",.T.)	
		EndIf
		If (!aCols[nX][nUsado+1])
			For nY := 1 to Len(aHeader)
				If aHeader[nY][10] <> "V"
					ACR->(FieldPut(FieldPos(aHeader[nY][2]),aCols[nX][nY]))
				EndIf
			Next nY
			ACR->ACR_FILIAL := xFilial("ACR")
			ACR->ACR_CODREG := M->ACQ_CODREG
			lGravou := .T.
		ElseIf !lCopia .And. !Empty(aCols[nX][nUsado])
			ACR->(dbDelete())
		EndIf
		MsUnLock()

		//Insere o registro na integracao	
		cChaveIte:= xFilial("ACR") + ACR->ACR_CODREG + ACR->ACR_ITEM
		Om010IteOk(cProcesIte, cChaveIte, cTabelaIte, aCols[nX][nUsado+1], aCols[nX,nUsado] == 0)
		
	Next nX
	dbSelectArea("ACR")
	//Deleta registros alterados por outro produto
	For nX := 1 To Len(aRegNo)
		dbGoto(aRegNo[nX])
		RecLock("ACR",.F.)
		dbDelete()
		MsUnLock()
	Next nX
Case nOpcao == 3
	dbSelectArea("ACR")
	dbSetOrder(1)
	MsSeek(xFilial("ACR")+M->ACQ_CODREG)
	nX := 1
	While ( !Eof() .And. xFilial("ACR") == ACR->ACR_FILIAL .And. M->ACQ_CODREG == ACR->ACR_CODREG )
		RecLock("ACR")
		dbDelete()
		
		//Insere o registro na integracao		
		cChaveIte:= xFilial("ACR") + ACR->ACR_CODREG + ACR->ACR_ITEM
		Om010IteOk(cProcesIte, cChaveIte, cTabelaIte, aCols[nX][nUsado+1], aCols[nX,nUsado] == 0)
		
		MsUnLock()
		dbSelectArea("ACR")
		dbSkip()
		
		nX++
		
	EndDo
	dbSelectArea("ACQ")
	dbSetOrder(1)
	If MsSeek(xFilial("ACQ")+M->ACQ_CODREG)
		RecLock("ACQ")
		dbDelete()
		
		//Insere o registro na integracao		
		cChaveCab:= xFilial("ACQ") + ACQ->ACQ_CODREG
		Om010CabOk(cProcesCab, cChaveCab, cTabelaCab)
	
		MsUnLock()
	EndIf
EndCase
If ExistBlock("FT090GrU")
	ExecBlock("FT090GrU",.F.,.F.,{nOpcao})
EndIf
Return(lGravou)
/*/


Ŀ
Funo    Ft090LOk   Autor Eduardo Riera           Data  09/05/2001 
Ĵ
Descrio Rotina de Validacao da linha Ok                               
Ĵ
Sintaxe   Ft090Lok()                                                    
Ĵ
ParametrosNenhum                                                        
                                                                        
Ĵ
Uso        Materiais/Distribuicao/Logistica                             
Ĵ
 AtualizACQes sofridas desde a Construcao Inicial.                       
Ĵ
 Programador   Data    BOPS   Motivo da Alteracao                     
Ĵ
                                                                      
ٱ


/*/
Function Ft090Lok()

Local aArea     := GetArea()
Local lRetorno  := .T.
Local nPProd    := aScan(aHeader,{|x| AllTrim(x[2])=="ACR_CODPRO"})
Local nPLote    := aScan(aHeader,{|x| AllTrim(x[2])=="ACR_LOTE"})
Local nPGrupo   := aScan(aHeader,{|x| AllTrim(x[2])=="ACR_GRUPO"})
Local nUsado    := Len(aHeader)
Local nX        := 0

//Ŀ
//Verifica os campos obrigatorios                                         
//
If !aCols[n][nUsado+1]
	Do Case
	Case nPProd == 0 .Or. nPLote  == 0 .Or. nPGrupo == 0
		lRetorno := .F.
		Help(" ",1,"OBRIGAT",,RetTitle("ACR_CODPRO")+","+RetTitle("ACR_GRUPO")+","+RetTitle("ACR_LOTE"),4)
	Case Empty(aCols[n][nPProd]) .And. Empty(aCols[n][nPGrupo])
		lRetorno := .F.
		Help(" ",1,"OBRIGAT",,RetTitle("ACR_CODPRO"),4)
	Case Empty(aCols[n][nPLote ])
		lRetorno := .F.
		Help(" ",1,"OBRIGAT",,RetTitle("ACR_LOTE"),4)
	EndCase
	//Ŀ
	//Verifica se nao ha valores duplicados                                   
	//
	If lRetorno
		If nPProd <> 0
			For nX := 1 To Len(aCols)
				If nX <> N .And. !aCols[nX][nUsado+1]
					If ( aCols[nX][nPProd]+aCols[nX][nPGrupo]==aCols[N][nPProd]+aCols[N][nPGrupo] )
						lRetorno := .F.
						Help(" ",1,"JAGRAVADO")
					EndIf
				EndIf
			Next nX
		EndIf
	EndIf
	
EndIf


If lRetorno
	If ExistBlock("FT090LOK")
		lRetorno := ExecBlock("FT090LOK",.F.,.F.)
	EndIf
EndIf

RestArea(aArea)

Return(lRetorno)

/*/


Ŀ
Funo    Ft090TOk   Autor Eduardo Riera           Data  10/05/2001 
Ĵ
Descrio Rotina de Validacao da TudoOk                                 
Ĵ
Sintaxe   Ft090Tok()                                                    
Ĵ
ParametrosNenhum                                                        
                                                                        
Ĵ
Uso        Materiais/Distribuicao/Logistica                             
Ĵ
 AtualizACQes sofridas desde a Construcao Inicial.                       
Ĵ
 Programador   Data    BOPS   Motivo da Alteracao                     
Ĵ
                                                                      
ٱ


/*/
Function Ft090Tok()

	Local lRetorno 	:= .T.
	Local nX		:= 0
	Local nUsado    := Len(aHeader)
	
	For nX := 1 to Len(aCols)
		If !aCols[nX][nUsado+1]
			lRetorno := .T.
			Exit
		Else
			lRetorno := .F.
		EndIf	
	Next nX

	If lRetorno == .F.
		Help("",1,"OBRIGAT")
	EndIf
	
	If lRetorno .AND. ExistBlock("FT090TDOK")
		lRetorno := ExecBlock("FT090TDOK",.F.,.F.)
	EndIf

Return(lRetorno)

/*/


Ŀ
Funcao    FtRgrBonus Autor Eduardo Riera           Data 15.05.2001
Ĵ
Descrio Rotina de avaliacao da regra de bonificacao                 
                                                                      
Ĵ
ParametrosExpA1: aCols da GetDados ou Alias da GetDb                  
          ExpA2: Quando acols informar:                               
                 [1] Posicao do codigo do produto                     
                 [2] Posicao da Quantidade                            
                 [3] Posicao da TES                                   
                 Quando GetDb informar:                               
                 [1] Nome do campo do codigo do produto               
                 [2] Nome do campo da quantidade                      
                 [3] Nome do campo da TES                             
          ExpC3: Cliente                                              
          ExpC4: Loja                                                 
          ExpC5: Tabela                                               
          ExpC6: Condicao de Pagamento                                
          ExpC7: Forma de Pagamento                                   
          ExpA8: Array com os registros do ACQ que devem ser usados   
                 EXCLUSIVAMENTE.                                      
Ĵ
Retorno   ExpA1: Array com a seguinte estrutura:                      
                 [1] Codigo do Produto                                
                 [2] Quantidade                                       
                 [3] TES                                              
                 [4] Regra aplicada                                   
                                                                      
Ĵ
Descrio Esta rotina tem como objetivo avaliar a regra de bonificacao
          conforme os parametros da rotina                            
                                                                      
Ĵ
Observacao                                                            
                                                                      
Ĵ
Uso        Materiais/Distribuicao/Logistica                           
ٱ


/*/
Function FtRgrBonus(xPar1,xPar2,cCliente,cLoja,cTabPreco,cCondPg,cFormPg,aRecACQ)

Local aArea    := GetArea()
Local aAreaSF4 := SF4->(GetArea())
Local aArea2   := {}
Local aRetorno := {}
Local aPos     := {1,2,3}
Local aCopia   := {}
Local aGrupos  := {}
Local aRemove  := {}
Local aLote    := {}
Local aSoma    := {}
Local aStruACQ := ACQ->(dbStruct())
Local aStruACR := ACR->(dbStruct())
Local aGrpAcr  := {}
Local aBkCopia := {}

Local cQuery   := ""
Local cCursor  := "ACQ"
Local cCursor2 := "ACR"
Local cProduto := ""
Local cGrupo   := ""
Local cCnt	   :=	""



Local nX       := 0
Local nY       := 0
Local nZ       := 0
Local nMult    := 0
Local nCabLote := 0
Local nSoma    := 0
Local nQuant   :=	0

Local nRecs
Local nCnt     := 1

Local lQuery   := .F.
Local lValido  := .F.
Local lBonific := .F.
Local lContinua:= .T.
Local lGrpAcul := .T.
Local lAcumula := SuperGetMv("MV_TPBONUS",.F.,.T.)
Local lBonusTd := (SuperGetMv("MV_BONUSTD",.F.,"2") == "1")
Local cAnTES   := SuperGetMv("MV_TESBONS",.F.,"")

DEFAULT cProduto  := Space(Len(SB1->B1_COD))
DEFAULT cCliente  := Space(Len(SA1->A1_COD))
DEFAULT cLoja     := Space(Len(SA1->A1_LOJA))
DEFAULT cTabPreco := Space(Len(DA0->DA0_CODTAB))
DEFAULT cCondPg   := Space(Len(DA0->DA0_CONDPG))
DEFAULT cFormPg   := Space(Len(ACO->ACO_FORMPG))
DEFAULT aRecACQ	:=	{}

nRecs	:=	Len(aRecACQ)
//Ŀ
//Verifica se a tes eh valida                                             
//
If cTesBonus == Nil
	DEFAULT cTesBonus := &(GetMv("MV_BONUSTS"))
	If Empty(cTesBonus)
		lContinua := .F.
	Else
		//Trata se parmetro for numrico
		If ValType(cTesBonus) == "N"
			cTesBonus := cValToChar(cTesBonus)
		EndIf
		
		dbSelectArea("SF4")
		dbSetOrder(1)
		If SubStr(cTesBonus,1,3)<="500" .Or. !MsSeek(xFilial("SF4")+cTesBonus)
			lContinua := .F.	
		EndIf
	EndIf
	If !lContinua
		cTesBonus := Nil
	EndIf
EndIf

If cPaisLoc <> "BRA" .And. IsInCallStack("A468REMFUT")
	lContinua := .F.
EndIf

If lContinua
	If ValType(xPar1)=="C"
		dbSelectArea(xpar1)
		aArea2 := GetArea()
		dbGotop()
		While ( !Eof())
			If (FieldGet(FieldPos(xPar2[3])) <> cTesBonus) .And. ( Empty(cAnTES) .Or. !(FieldGet(FieldPos(xPar2[3])) $ cAnTES)) 
				nPosProd	:=	Ascan(aCopia,{|x| x[1] == FieldGet(FieldPos(xPar2[1])) })
				If nPosProd	>	0
					aCopia[nPosProd][2]	+=	FieldGet(FieldPos(xPar2[2]))
				Else
					aadd(aCopia,{ FieldGet(FieldPos(xPar2[1])) , FieldGet(FieldPos(xPar2[2])),FieldGet(FieldPos(xPar2[3])) })
				Endif
			Endif
			dbSelectArea(xpar1)	
			dbSkip()
		EndDo
		RestArea(aArea2)
	Else
		For nX	:=	1	To Len(xPar1)
			If Valtype(xPar1[nX][Len(xPar1[nX])]) =='L' .And. !xPar1[nX][Len(xPar1[nX])] .And. xPar1[nX][xPar2[3]] <> cTesBonus ;
			    .And. ( Empty(cAnTES) .Or. !(xPar1[nX][xPar2[3]] $ cAnTES) ) 
				nPosProd	:=	Ascan(aCopia,{|x| x[1] == xPar1[nX][xPar2[1]]})
				If nPosProd	> 0
					aCopia[nPosProd][2]	+=	xPar1[nX][xPar2[2]]
				Else
					AAdd(aCopia,{xPar1[nX][xPar2[1]],xPar1[nX][xPar2[2]],xPar1[nX][xPar2[3]]})
				Endif
			Endif
		Next
	EndIf

	//Ŀ
	//Guarda o array aCopia original para bonificar regras identicas caso o   
	//parametro esteja ativo                                                  	
	//

	If lBonusTd
		aCopiaBk := aClone(aCopia)
	Endif	
	
	dbSelectArea("ACQ")
	dbSetOrder(1)
	#IFDEF TOP
		lQuery := .T.
		cCursor:= "FTRGRBONUS"
		cQuery := "SELECT * "
		cQuery += "FROM "+RetSqlName("ACQ")+" ACQ "
		cQuery += "WHERE ACQ.ACQ_FILIAL='"+xFilial("ACQ")+"' AND "
		If nRecs > 0
			cQuery	+=	"R_E_C_N_O_ IN ("
			For nX:=	1 To nRecs
				cQuery	+=	Alltrim(Str(aRecACQ[nX]))+','
			Next	
			cQuery	+=	"0) AND "
		Endif
		cQuery += "(ACQ.ACQ_CODCLI = '"+cCliente+"' OR ACQ.ACQ_CODCLI='"+Space(Len(ACQ->ACQ_CODCLI))+"') AND "
		cQuery += "(ACQ.ACQ_LOJA = '"+cLoja+"' OR ACQ.ACQ_LOJA='"+Space(Len(ACQ->ACQ_LOJA))+"') AND "
		cQuery += "(ACQ.ACQ_CODTAB = '"+cTabPreco+"' OR ACQ.ACQ_CODTAB='"+Space(Len(ACQ->ACQ_CODTAB))+"') AND "
		cQuery += "(ACQ.ACQ_CONDPG = '"+cCondPg+"' OR ACQ.ACQ_CONDPG='"+Space(Len(ACQ->ACQ_CONDPG))+"') AND "
		cQuery += "(ACQ.ACQ_FORMPG = '"+cFormPg+"' OR ACQ.ACQ_FORMPG='"+Space(Len(ACQ->ACQ_FORMPG))+"') AND "
		cQuery += "ACQ.D_E_L_E_T_=' ' "
		cQuery += "ORDER BY "+SqlOrder(ACQ->(IndexKey()))
		
		cQuery := ChangeQuery(cQuery)
		
		dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cCursor,.T.,.T.)
		For nX := 1 To Len(aStruACQ)
			If aStruACQ[nX][2] <> "C"
				TcSetField(cCursor,aStruACQ[nX][1],aStruACQ[nX][2],aStruACQ[nX][3],aStruACQ[nX][4])
			EndIf
		Next nX
	#ELSE
		dbSeek(xFilial("ACQ"))
	#ENDIF
	While If(nRecs=0.Or.lQuery,!Eof(),nCnt	<=	nRecs)
		lValido:= .F.
		If !lQuery
			If nRecs	>	0
				ACQ->(DbGoTo(aRecACQ[nCnt]))
				nCnt++
			Endif	
			If ((ACQ->ACQ_CODCLI == cCliente .Or. Empty(ACQ->ACQ_CODCLI) ).And.;
					(ACQ->ACQ_LOJA == cLoja .Or. Empty(ACQ->ACQ_LOJA) ) .And.;
					(ACQ->ACQ_CODTAB == cTabPreco .Or. Empty(ACQ->ACQ_CODTAB) ) .And.;
					(ACQ->ACQ_CONDPG == cCondPg .Or. Empty(ACQ->ACQ_CONDPG) ) .And.;
					(ACQ->ACQ_FORMPG == cFormPg .Or. Empty(ACQ->ACQ_FORMPG) ) )
				lValido := .T.
			EndIf
		Else
			lValido := .T.
		EndIf	
		If FtIsDataOk("ACQ",cCursor) .And. !Empty(FtIsGrpOk((cCursor)->ACQ_GRPVEN,SA1->A1_GRPVEN))
			If lValido
				lBonific := .T.
				aGrpAcr  := {}
				If (cCursor)->(FieldPos("ACQ_LOTE"))>0
					nCabLote := Max((cCursor)->ACQ_LOTE,0)
				Endif
				dbSelectArea("ACR")
				dbSetOrder(1)
				#IFDEF TOP
					lQuery := .T.
					cCursor2 := cCursor+"A"
					cQuery := "SELECT * "
					cQuery += "FROM "+RetSqlName("ACR")+" ACR "
					cQuery += "WHERE ACR.ACR_FILIAL='"+xFilial("ACR")+"' AND "
					cQuery += "ACR.ACR_CODREG='"+(cCursor)->ACQ_CODREG+"' AND "
					cQuery += "ACR.D_E_L_E_T_=' ' "
					cQuery += "ORDER BY "+SqlOrder(ACR->(IndexKey()))
					
					cQuery := ChangeQuery(cQuery)
					
					dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cCursor2,.T.,.T.)
					For nX := 1 To Len(aStruACR)
						If aStruACR[nX][2] <> "C"
							TcSetField(cCursor2,aStruACR[nX][1],aStruACR[nX][2],aStruACR[nX][3],aStruACR[nX][4])
						EndIf
					Next nX			
				#ELSE
					MsSeek(xFilial("ACR")+(cCursor)	->ACQ_CODREG)
				#ENDIF
				aRemove := {}    
				aLote   := {}
				While ( !Eof() .And. (cCursor)->ACQ_CODREG == (cCursor2)->ACR_CODREG )
					
					If nCabLote == 0
						//Ŀ
						//Busca por Produto                                                       
						//
						nY := aScan(aCopia,{|x| x[aPos[1]]==(cCursor2)->ACR_CODPRO .And. x[aPos[2]]>=IIf(nCabLote>0,nCabLote,(cCursor2)->ACR_LOTE) .And. x[aPos[3]]<>cTesBonus })
						//Ŀ
						//Busca por Grupo                                                         
						//
						If nY == 0 .And. Empty((cCursor2)->ACR_CODPRO)
						
							//Ŀ
							//Cria um array dos grupos para analise acumulada                         
							//
							Aadd(aGrpAcr,{(cCursor2)->ACR_CODPRO,.F.}) 
						
							For nX := 1 To Len(aCopia)
								cProduto := aCopia[nX][aPos[1]]
								nY := aScan(aGrupos,{|x| x[1] == cProduto})
								If nY == 0
									dbSelectArea("SB1")
									dbSetOrder(1)
									MsSeek(xFilial("SB1")+cProduto)
									cGrupo := SB1->B1_GRUPO
									aadd(aGrupos,{cProduto,cGrupo})
								Else
									cGrupo := aGrupos[nY][2]
								EndIf
								
								nY := 0
								
								If cGrupo == (cCursor2)->ACR_GRUPO .And. aCopia[nX][aPos[2]]>=IIf(nCabLote>0,nCabLote,(cCursor2)->ACR_LOTE)
									nY := nX
									
									//Ŀ
									//Analisa caso seja bonificacao acumulada                                 
									//
									If lAcumula                    
										//Ŀ
										//Se for somente um ja adiciona a bonificacao do produto do grupo         
										//
										If (cCursor)->ACQ_TPRGBN == "2"	
											If nY <> 0
												Aadd(aRemove,{nY,Int(aCopia[nY][aPos[2]]/(cCursor2)->ACR_LOTE),(cCursor2)->ACR_LOTE,aCopia[nY][aPos[2]]})									
											Endif	
										Else        
											//Ŀ
											//Se for somente todos marca o grupo da bonificacao como .T.              
											//
											If nY <> 0 
												Aadd(aRemove,{nY,Int(aCopia[nY][aPos[2]]/(cCursor2)->ACR_LOTE),(cCursor2)->ACR_LOTE,aCopia[nY][aPos[2]]})																				
												aGrpAcr[Len(aGrpAcr)][2] := .T.
											Endif								
										Endif	
									Else
										Exit
									Endif	
								EndIf
							Next nX

						Else
							If lAcumula
								//Ŀ
								//Se acumula e encontrou o produto e bonificado                           
								//
								If ( nY <> 0 )
									Aadd(aRemove,{nY,Int(aCopia[nY][aPos[2]]/(cCursor2)->ACR_LOTE),(cCursor2)->ACR_LOTE,aCopia[nY][aPos[2]]})
								//Ŀ
								//Se for todos e nao encontrou o produto nao bonifica                     
								//
								ElseIf (cCursor)->ACQ_TPRGBN <> "2"
									aRemove	:=	{}
								EndIf
							Endif
						EndIf
						//Ŀ
						//Avalia o tipo de Bonificacao                                            
						//
						//Se o tipo de bonificacao for "TODOS" e nao achei algum produto, zerar o aRemove e sair
						If !lAcumula
							If ( nY <> 0 )
								Aadd(aRemove,{nY,Int(aCopia[nY][aPos[2]]/(cCursor2)->ACR_LOTE),(cCursor2)->ACR_LOTE,aCopia[nY][aPos[2]]})
							ElseIf (cCursor)->ACQ_TPRGBN <> "2"
								aRemove	:=	{}
								Exit
							EndIf
						Else
							//Ŀ
							//Se acumula e bonifica todos analisa se algum grupo nao foi encontrado   
							//
							If (cCursor)->ACQ_TPRGBN == "1"
								If Ascan(aGrpAcr,{|x| x[2] == .F.}) > 0
									aRemove := {}
								Endif	
							Endif								
						Endif
							
					Else
						Aadd(aLote,{(cCursor2)->ACR_CODPRO,(cCursor2)->ACR_GRUPO})
					EndIf
					dbSelectArea(cCursor2)
					dbSkip()
				EndDo
				If lQuery
					dbSelectArea(cCursor2)
					dbCloseArea()
					dbSelectArea(cCursor)
				EndIf
				//Ŀ
				//Avalia as bonificacoes por lote de produto                              
				//
				nQuant	:=	(cCursor)->ACQ_QUANT
				If nCabLote > 0
					nSoma	:=	0
					aSoma := {}
					For nZ := 1 To Len(aCopia)
						If !Empty(aCopia[nZ,aPos[1]])
							If aScan(aLote,{|x| aCopia[nZ,aPos[1]]==x[1] }) > 0
								aadd(aSoma,nZ)
								nSoma += aCopia[nZ,aPos[2]]
							EndIf
						Else
							cProduto := aCopia[nZ][aPos[1]]
							nY := aScan(aGrupos,{|x| x[1] == cProduto})
							If nY == 0
								dbSelectArea("SB1")
								dbSetOrder(1)
								MsSeek(xFilial("SB1")+cProduto)
								cGrupo := SB1->B1_GRUPO
								aadd(aGrupos,{cProduto,cGrupo})
							Else
								cGrupo := aGrupos[nY][2]
							EndIf
							If aScan(aLote,{|x| cGrupo==x[2] }) > 0
								aadd(aSoma,nZ)
								nSoma += aCopia[nZ,aPos[2]]
							EndIf
						EndIf
					Next nZ
					Ft090ChkLote(@nQuant,@aRemove,@nSoma,aSoma,aCopia,aPos,cCursor,nCabLote,@nMult)
				Else
					//Ŀ
					//Definir o multiplicador dependendo do tipo de bonificacao, se for tipo "TODOS",
					//pego o mnimo multiplo, se for "SOMENTE UM" pego o maximo multiplo.            
					//
					For nX:=	1	To	Len(aRemove)
						If (cCursor)->ACQ_TPRGBN=="1"
							nMult	:=	If(nX==1,aRemove[1][2],Min(aRemove[nX][2],nMult))
						Else 
							nMult	:=	If(nX==1,aRemove[1][2],Max(aRemove[nX][2],nMult))
						Endif
					Next							                                         
				Endif

				//Ŀ
				//Avalia o tipo de Bonificacao                                            
				//
				If lBonific .And. Len(aRemove)>0
					While nQuant > 0
						For nX := 1 To Len(aRemove)   
							//Ŀ
							//Anular los items que foram usados em uma Regra de bonificacao 
							//por lotes.                                                    
							//
							If nCabLote > 0
								aCopia[aRemove[nX][1]][aPos[2]]	:=	0
								nMult	:=	aRemove[nX][2]
							Else
								//Ŀ
								//Se o tipo de bonificacao for por "SOMENTE UM", vou dar bonificacao         
								//de acordo com o item que atingiu a maior bonificacao                       
								//
								If (cCursor)->ACQ_TPRGBN=="2" 
								
									If aRemove[nX][2] >= nMult
										aCopia[aRemove[nX][1]][aPos[2]] -= aRemove[nX][3] * nMult
										If !lAcumula
											Exit                                                       
										Endif	
									Endif
	
								//Ŀ
								//Se o tipo de bonificacao for por "TODOS", vou dar bonificacao de acordo com
								//o item que limitou a bonificacao (nMult)                                   
								//
								Else
									aCopia[aRemove[nX][1]][aPos[2]] -= aRemove[nX][3] * nMult
								Endif
							Endif               
							
							If lAcumula //.And. (cCursor)->ACQ_TPRGBN=="2" 
								nPosRet := Ascan(aRetorno,{|x| Alltrim(x[1]) == Alltrim((cCursor)->ACQ_CODPRO) })
								If nPosRet == 0
									Aadd(aRetorno,{(cCursor)->ACQ_CODPRO,aRemove[nX][2]*nQuant,cTesBonus,(cCursor)->ACQ_CODREG})							
								Else
									aRetorno[nPosRet][2]+= aRemove[nX][2]*nQuant
								Endif		
							Endif	 
							
						Next nX
						
						If !lAcumula 
							Aadd(aRetorno,{(cCursor)->ACQ_CODPRO,nMult*nQuant,cTesBonus,(cCursor)->ACQ_CODREG})
						Endif
							
						nQuant	:=	0
						//Ŀ
						//Se o tipo de bonificacao for escalavel (por lotes) avaliar se o saldo do lote usado
						//ainda se ancaixa em alguma faixa menor.                                            
						//
						If nCabLote	>	0
							Ft090ChkLote(@nQuant,@aRemove,@nSoma,aSoma,aCopia,aPos,cCursor,nCabLote,@nMult)
						Endif
					Enddo
				EndIf
			Endif
		EndIf
		//Ŀ
		//Verifica se deve continuar                                              
		//
		If !lBonusTd		
			nY := aScan(aCopia,{|x| x[aPos[2]]>0 })
			If nY == 0
				Exit
			EndIf
		Else                         
			//Ŀ
			//Restaura o array aCopia para buscar novas regras de bonificacao         
			//
			aCopia := aClone(aCopiaBk)	
		Endif
			
		dbSelectArea(cCursor)
		dbSkip()
	EndDo
	If lQuery
		dbSelectArea(cCursor)
		dbCloseArea()
		dbSelectArea("ACQ")
	EndIf
EndIf
RestArea(aAreaSF4)
RestArea(aArea)
Return(aRetorno)

/*/


Ŀ
Funcao    FtIsBonus  Autor Eduardo Riera           Data 15.05.2001
Ĵ
Descrio Verifica se o item refere-se a um Bonus                     
                                                                      
Ĵ
ParametrosExpA1: Array com a seguinte estrutura                       
                 [1] Codigo do Produto                                
                 [2] Quantidade                                       
                 [3] TES                                              
Ĵ
Retorno   ExpL1: Indica que o item refere-se a um bonus               
                                                                      
Ĵ
Descrio Esta rotina tem como objetivo avaliar a regra de bonificacao
          conforme os parametros da rotina                            
                                                                      
Ĵ
Observacao                                                            
                                                                      
Ĵ
Uso        Materiais/Distribuicao/Logistica                           
ٱ


/*/
Function FtIsBonus(aParam)

Local aArea  := GetArea()
Local lBonus := .T.
//Ŀ
//Verifica se a tes eh valida                                             
//
If cTesBonus == Nil
	DEFAULT cTesBonus := &(GetMv("MV_BONUSTS"))
	If Empty(cTesBonus)
		lBonus := .F.
	Else
		//Trata se parmetro for numrico
		If ValType(cTesBonus) == "N"
			cTesBonus := cValToChar(cTesBonus)
		EndIf
		
		dbSelectArea("SF4")
		dbSetOrder(1)
		If SubStr(cTesBonus,1,3)<="500" .Or. !MsSeek(xFilial("SF4")+cTesBonus)
			lBonus := .F.
		EndIf
	EndIf
	If !lBonus
		cTesBonus := Nil
	EndIf
EndIf
If aParam[3] <> cTesBonus
	lBonus := .F.
EndIf
RestArea(aArea)
Return(lBonus)

/*/


Ŀ
Funcao    FtDelBonus Autor Eduardo Riera           Data 15.05.2001
Ĵ
Descrio Efetua a delecao das regras de bonificacao                  
                                                                      
Ĵ
ParametrosExpA1: aCols da GetDados ou Alias da GetDb                  
          ExpA2: Quando acols informar:                               
                 [1] Posicao do codigo do produto                     
                 [2] Posicao da Quantidade                            
                 [3] Posicao da TES                                   
                 [4] Controle de delecao                              
                 Quando GetDb informar:                               
                 [1] Nome do campo do codigo do produto               
                 [2] Nome do campo da quantidade                      
                 [3] Nome do campo da TES                             
                 [4] Nome do campo do controle de delecao             
Ĵ
Retorno   Nenhum                                                      
                                                                      
Ĵ
Descrio Esta rotina tem como objetivo deletar os bonus para reavali-
          acao.                                                       
                                                                      
Ĵ
Observacao                                                            
                                                                      
Ĵ
Uso        Materiais/Distribuicao/Logistica                           
ٱ


/*/
Function FtDelBonus(xPar1,xPar2)

Local aArea   := GetArea()
Local aArea2  := {}
Local nX      := 0

If ValType(xPar1)=="C"
	dbSelectArea(xPar1)
	aArea2 := GetArea()
	dbGotop()
	While !Eof()
		If !FieldGet(FieldPos(xPar2[4]))
			If FtIsBonus({FieldGet(FieldPos(xPar2[1])),FieldGet(FieldPos(xPar2[2])),FieldGet(FieldPos(xPar2[3]))})
				FieldPut(FieldPos(xPar2[4]),.T.)
			EndIf
		EndIf
		dbSkip()
	EndDo
	RestArea(aArea2)
Else
	For nX := 1 To Len(xPar1)
		If !xPar1[nX,xPar2[4]]
			If FtIsBonus({ xPar1[nX,xPar2[1]],xPar1[nX,xPar2[2]],xPar1[nX,xPar2[3]] })
				xPar1[nX,xPar2[4]] := .T.
			EndIf
		EndIf
	Next Nx
EndIf
RestArea(aArea)
Return(xPar1)

/*/


Ŀ
Funcao    FtRecBonus Autor Eduardo Riera           Data 15.05.2001
Ĵ
Descrio Efetua a delecao das regras de bonificacao                  
                                                                      
Ĵ
ParametrosExpA1: aCols da GetDados ou Alias da GetDb                  
          ExpA2: Quando acols informar:                               
                 [1] Posicao do codigo do produto                     
                 [2] Posicao da Quantidade                            
                 [3] Posicao da TES                                   
                 [4] Controle de delecao                              
                 Quando GetDb informar:                               
                 [1] Nome do campo do codigo do produto               
                 [2] Nome do campo da quantidade                      
                 [3] Nome do campo da TES                             
                 [4] Nome do campo do controle de delecao             
          ExpA3: Array com a seguinte estrutura:                      
                 [1] Codigo do Produto                                
                 [2] Quantidade                                       
                 [3] TES                                              
Ĵ
Retorno   Nenhum                                                      
                                                                      
Ĵ
Descrio Esta rotina tem como objetivo deletar os bonus para reavali-
          acao.                                                       
                                                                      
Ĵ
Observacao                                                            
                                                                      
Ĵ
Uso        Materiais/Distribuicao/Logistica                           
ٱ


/*/
Function FtRecBonus(xPar1,xPar2,aBonus)

Local aArea   := GetArea()
Local aArea2  := {}
Local nX      := 0
Local nScan   := 0

If ValType(xPar1)=="C"
	dbSelectArea(xPar1)
	aArea2 := GetArea()
	dbGotop()
	While !Eof()
		If FieldGet(FieldPos(xPar2[4]))
			If FtIsBonus({FieldGet(FieldPos(xPar2[1])),FieldGet(FieldPos(xPar2[2])),FieldGet(FieldPos(xPar2[3]))})
				nScan := aScan(aBonus,{|x| x[1] == FieldGet(FieldPos(xPar2[1])) .And.;
					x[2] == FieldGet(FieldPos(xPar2[2])) .And.;
					x[3] == FieldGet(FieldPos(xPar2[3]))} )
				If nScan <> 0
					FieldPut(FieldPos(xPar2[4]),.F.)
					aDel(aBonus,nScan)
					aSize(aBonus,Len(aBonus)-1)
				EndIf
			EndIf
		EndIf
		dbSkip()
	EndDo
	RestArea(aArea2)
Else
	For nX := 1 To Len(xPar1)
		If xPar1[nX,xPar2[4]]
			If FtIsBonus({ xPar1[nX,xPar2[1]],xPar1[nX,xPar2[2]],xPar1[nX,xPar2[3]] })
				nScan := aScan(aBonus,{|x| x[1] == xPar1[nX,xPar2[1]] .And.;
					x[2] == xPar1[nX,xPar2[2]] .And.;
					x[3] == xPar1[nX,xPar2[3]]} )
				If nScan <> 0
					xPar1[nX,xPar2[4]] := .F.
					aDel(aBonus,nScan)
					aSize(aBonus,Len(aBonus)-1)
				EndIf
			EndIf
		EndIf
	Next nX
EndIf
RestArea(aArea)
Return(aBonus)

/*


Ŀ
Funo    Ft090Copia Autor Sergio Silveira         Data 20/09/2001  
Ĵ
Descrio Rotina de Copia da Regra de Descontos                         
Ĵ
Sintaxe   ExpX1 := Ft090Copia( ExcC1, ExpN1, ExpN2 )                    
Ĵ
ParametrosExpC1: Alias do Arquivo                                       
          ExpN1: Numero do Registro                                     
          ExpN2: Opcao do aRotina                                       
Ĵ
Retorno   ExpX1 -> Retorno da FT090RDES                                 
Ĵ
Uso        Materiais/Distribuicao/Logistica                             
Ĵ
 AtualizACOes sofridas desde a Construcao Inicial.                       
Ĵ
 Programador   Data    BOPS   Motivo da Alteracao                     
Ĵ
                                                                      
ٱ


*/

Function Ft090Copia( cAlias, nRecno, nOpcao )

Local xRet

//Ŀ
// Faz a chamada passando o parametro de copia                  
//
xRet := Ft090RDes( cAlias, nRecno, nOpcao, , .T. )

Return( xRet )
/*/


Ŀ
Programa  FT090ChkLoteAutor  Bruno Sobieski         Fecha   01/28/02
Ĵ
Descrio Rotina para avaliar a bonificao por lotes (escalavel).        
Ĵ
Sintaxe   FT090ChkLote                                                  
Ĵ
ParametrosnQuant  :Quantidade do bonus (pasada por referencia)          
          aRemove :Acumulado de produtos Utilizados em bonificacoes     
                     (pasada por referencia)                            
          nSoma   :Quantidade total de produtos (pasada por referencia) 
          aSoma   :Array com o detalhe de PRODUTOxQuantidade            
          aCopia  :Saldo de produtos                                    
          aPos    :Posicoes do array aCopia                             
          cCursor :Alias em uso                                         
          nCabLote:1ro lote da escalabilidade                           
          nMult   :Multiplicador que determina "quantas vezes" deve ser 
                    otorgada a bonificacao. (pasada por referencia)     
Ĵ
Uso        Materiais/Distribuicao/Logistica                             
Ĵ
Retorno    Ver parametros recebidos por referencia.                     
Ĵ
 Atualizaces sofridas desde a Construcao Inicial.                        
Ĵ
 Programador   Data    BOPS   Motivo da Alteracao                     
Ĵ
                                                                      
ٱ


/*/

Static Function Ft090ChkLote(nQuant,aRemove,nSoma,aSoma,aCopia,aPos,cCursor,nCabLote,nMult)
Local cCnt		:=	"2"
Local nLote :=	0
Local nZ
If nSoma >= nCabLote               
	nQuant	:=	(cCursor)->ACQ_QUANT       
	nLote		:=	nCabLote
	While (cCursor)->(FieldPos('ACQ_LOTE'+cCnt)) > 0  .And. ;
			nSoma >= (cCursor)->(FieldGet(FieldPos('ACQ_LOTE'+cCnt))) .And. ;
			(cCursor)->(FieldGet(FieldPos('ACQ_LOTE'+cCnt)))  > 0
		nQuant:=	(cCursor)->(FieldGet(FieldPos('ACQ_QUANT'+cCnt)))
		nLote	:=	(cCursor)->(FieldGet(FieldPos('ACQ_LOTE'+cCnt)))
		cCnt	:=	SOMA1(cCnt)
	Enddo
	If Len(aSoma) == 0
		aRemove	:=	{}
	Else
		For nZ := 1 To Len(aSoma)
			Aadd(aRemove,{aSoma[nZ],Int(nSoma/nLote),Min(aCopia[nZ,aPos[2]],nLote)})
		Next nZ                                                                           
	Endif
	nMult	:=	Int(nSoma/nLote)
	aSoma	:=	{}
	If nLote > 0
		nSoma	-=	(Int(nSoma/nLote) * nLote)
	Endif
Else
	nQuant	:=	0
EndIf
Return

/*/


Ŀ
Programa  MenuDef    Autor  Marco Bianchi          Data 01/09/2006
Ĵ
Descrio  Utilizacao de menu Funcional                               
                                                                      
                                                                      
Ĵ
Retorno   Array com opcoes da rotina.                                 
Ĵ
ParametrosParametros do array a Rotina:                               
          1. Nome a aparecer no cabecalho                             
          2. Nome da Rotina associada                                 
          3. Reservado                                                
          4. Tipo de Transao a ser efetuada:                        
          		1 - Pesquisa e Posiciona em um Banco de Dados         
              2 - Simplesmente Mostra os Campos                       
              3 - Inclui registros no Bancos de Dados                 
              4 - Altera o registro corrente                          
              5 - Remove o registro corrente do Banco de Dados        
          5. Nivel de acesso                                          
          6. Habilita Menu Funcional                                  
Ĵ
   DATA    Programador   Manutencao efetuada                         
Ĵ
                                                                     
ٱ


/*/

Static Function MenuDef()
     
Private aRotina := {	{ OemToAnsi(STR0001),"AxPesqui"	,0,1,0,.F.},;	  		//"Pesquisar"
							{ OemToAnsi(STR0002),"Ft090RDes" ,0,2,0,NIL},;		//"Visualizar"
							{ OemToAnsi(STR0003),"Ft090RDes" ,0,3,0,NIL},;		//"Incluir"
							{ OemToAnsi(STR0004),"Ft090RDes" ,0,4,0,NIL},;		//"Alterar"
							{ OemToAnsi(STR0005),"Ft090RDes" ,0,5,0,NIL},;		//"Excluir"
							{ OemToAnsi(STR0006),"Ft090Copia",0,3,0,NIL}}		//"Copiar"

If ExistBlock("FT090MNU")
	ExecBlock("FT090MNU",.F.,.F.)
EndIf

Return(aRotina)

/*


ͻ
Programa  Ft090Prod Autor  Andre Anjos	      Data   11/11/09   
͹
Descricao  Funcao de validacao do produto digitado.                   
͹
Uso        FATA090                                                    
ͼ


*/
Function Ft090Prod()
Local lRet        := .T.
Local nITEMGR     := aScan(aHeader,{|x| AllTrim(x[2]) == "ACR_ITEMGR"})
Local nDESPRO     := aScan(aHeader,{|x| AllTrim(x[2]) == "ACR_DESPRO"})
Local nLOTE       := aScan(aHeader,{|x| AllTrim(x[2]) == "ACR_LOTE"})
Local lGrade      := !Empty(nITEMGR) .And. MaGrade()
Local cProduto	  := M->ACR_CODPRO
Local lReferencia := MatGrdPrrf(@cProduto)

If lGrade
	oGrade:MontaGrade(n,cProduto,.T.,,lReferencia)
EndIf

If lReferencia
	aCols[n,nITEMGR] := "01"
	aCols[n,nDESPRO] := oGrade:GetDescProd(M->ACR_CODPRO)
	aCols[n,nLOTE]   := 0
ElseIf (lRet := ExistCpo("SB1",M->ACR_CODPRO))
	aCols[n,nDESPRO] := Posicione("SB1",1,xFilial("SB1")+M->ACR_CODPRO,"B1_DESC")
	If !Empty(nITEMGR)
		aCols[n,nITEMGR] := CriaVar("ACR_ITEMGR")
	EndIf
EndIf

Return lRet

/*


ͻ
Programa  Ft090GrQtdAutor  Andre Anjos		  Data   10/11/09   
͹
Descricao  Funcao para exibicao da grade na digitacao do lote.		  
͹
Uso        FATA090                                                    
ͼ


*/
Function Ft090GrQtd()
Local nCODPRO  := aScan(aHeader,{|x| AllTrim(x[2]) == "ACR_CODPRO"})
Local nITEM    := aScan(aHeader,{|x| AllTrim(x[2]) == "ACR_ITEM"})
Local lGrade   := MaGrade()
Local cProduto := aCols[n,nCODPRO]
If lGrade .And. MatGrdPrrf(@cProduto)
	oGrade:cProdRef := aCols[n,nCODPRO]
	oGrade:lShowGrd := .T.
	oGrade:nPosLinO := n	
	oGrade:Show("ACR_LOTE")	
	&(ReadVar()) := oGrade:SomaGrade("ACR_LOTE",oGrade:nPosLinO)
EndIf
Return .T.

//-----------------------------------------------------------------------------
/*/{Protheus.doc} FATPDLogUser
    @description
    Realiza o log dos dados acessados, de acordo com as informaes enviadas, 
    quando a regra de auditoria de rotinas com campos sensveis ou pessoais estiver habilitada
	Remover essa funo quando no houver releases menor que 12.1.27

   @type  Function
    @sample FATPDLogUser(cFunction, nOpc)
    @author Squad CRM & Faturamento
    @since 06/01/2020
    @version P12
    @param cFunction, Caracter, Rotina que ser utilizada no log das tabelas
    @param nOpc, Numerico, Opo atribuda a funo em execuo - Default=0

    @return lRet, Logico, Retorna se o log dos dados foi executado. 
    Caso o log esteja desligado ou a melhoria no esteja aplicada, tambm retorna falso.

/*/
//-----------------------------------------------------------------------------
Static Function FATPDLogUser(cFunction, nOpc)

	Local lRet := .F.

	If FATPDActive()
		lRet := FTPDLogUser(cFunction, nOpc)
	EndIf 

Return lRet  

//-----------------------------------------------------------------------------
/*/{Protheus.doc} FATPDActive
    @description
    Funo que verifica se a melhoria de Dados Protegidos existe.

    @type  Function
    @sample FATPDActive()
    @author Squad CRM & Faturamento
    @since 17/12/2019
    @version P12    
    @return lRet, Logico, Indica se o sistema trabalha com Dados Protegidos
/*/
//-----------------------------------------------------------------------------
Static Function FATPDActive()

    Static _lFTPDActive := Nil
  
    If _lFTPDActive == Nil
        _lFTPDActive := ( GetRpoRelease() >= "12.1.027" .Or. !Empty(GetApoInfo("FATCRMPD.PRW")) )  
    Endif

Return _lFTPDActive  
