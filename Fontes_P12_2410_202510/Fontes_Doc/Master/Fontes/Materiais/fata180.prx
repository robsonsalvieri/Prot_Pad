#include "Protheus.ch" 
#include "FATA180.CH"
#DEFINE MAXGETDAD 4096
#DEFINE MAXSAVERESULT 4096 

/*


Ŀ
Funo     FATA180   Autor Sergio Silveira         Data  17/04/2002 
Ĵ
Descrio  Rotina de Manutencao das Regras de bonificacao financeira    
Ĵ
Sintaxe    FATA180                                                      
Ĵ
Parametros                                                              
Ĵ
Uso        Materiais/Distribuicao/Logistica                             
Ĵ
 AtualizACOes sofridas desde a Construcao Inicial.                       
Ĵ
 Programador   Data    BOPS   Motivo da Alteracao                     
Ĵ
                                                                      
ٱ


*/
Function FATA180(xAutoCab,xAutoItens,nOpcAuto)

Private lFt180Auto 	:= Valtype(xAutoCab) == "A"
PRIVATE aAutoCab  	:= {}
PRIVATE aAutoItens	:= {}

Private aRotina := MenuDef()

cCadastro := OemToAnsi(STR0007)	//"Manutencao das Regras de Negocio"
//Ŀ
//Endereca para a funcao MBrowse                                          
//
dbSelectArea("AI1")
dbSetOrder(1)
MsSeek(xFilial("AI1"))

If xAutoCab == Nil .And. !lFt180Auto 
	mBrowse(06,01,22,75,"AI1")
Else
	aAutoCab   := xAutoCab
	aAutoItens := xAutoItens
	MBrowseAuto(nOpcAuto,aClone(aAutoCab),"AI1")	
Endif
//Ŀ
//Restaura a Integridade da Rotina                                        
//
dbSelectArea("AI1")
dbSetOrder(1)
dbClearFilter()
Return
/*


Ŀ
Funo    Ft180RBnF  Autor Sergio Silveira         Data  17/04/2002 
Ĵ
Descrio Rotina de Manutencao da Regras de bonificacao financeira      
Ĵ
Sintaxe   Ft180RBnF                                                     
Ĵ
ParametrosExpC1: Alias do Arquivo                                       
          ExpN2: Numero do Registro                                     
          ExpN3: Opcao do aRotina                                       
                                                                        
Ĵ
Uso        Materiais/Distribuicao/Logistica                             
Ĵ
 AtualizACOes sofridas desde a Construcao Inicial.                       
Ĵ
 Programador   Data    BOPS   Motivo da Alteracao                     
Ĵ
 Fernando     15/02/07119221Alterao feita para usar a FilgetDados   
                            na montagem do Aheader e Acols            
ٱ


*/
Function Ft180RBnF( cAlias,nReg,nOpc, xParam, lCopia )

Local aArea     := GetArea()
Local aPosObj   := {}
Local aObjects  := {}
Local aSize     := {}
Local aInfo     := {}  
Local cQuery    := ""
Local lContinua := .T.
Local lQuery    := .F.
Local nUsado    := 0
Local nX        := 0
Local nOpcA     := 0
Local nOper     := 0
Local nSaveSx8  := GetSx8Len()
Local cSeek  	:= Nil
Local cWhile 	:= Nil
Local oDlg
Local oGetD  
Local lGrade    := MaGrade()
Local nCntFor 	:= 0 

DEFAULT lCopia  := .F.

Private aHeader := {}
Private Acols   := {}
Private aTELA[0,0],aGETS[0]

Private oGrade := MsMatGrade():New("oGrade",,"AI2_VALORC",,"Ft180VlCGr()",,{{"AI2_VALORC",.T.,,.T.},;
{"AI2_QUANTC",.T.,,.T.},;
{"AI2_PERCB" ,.T.,,.T.},;
{"AI2_VALORB",.T.,,.T.}}) 
Private lCopiaGRD := .F. 																			

nOper := aRotina[ nOpc, 4 ]
INCLUI := (nOper == 3 .And. !lCopia )
lCopiaGRD := (nOper == 3 .And. lCopia)
//Ŀ
//Inicializa as variaveis da Enchoice                                     
//
If INCLUI
	RegToMemory( "AI1", .T., .F. )
EndIf

If !INCLUI
	If SoftLock("AI1")
		RegToMemory( "AI1", .F., .F. )
	Else
		lContinua := .F.
	EndIf
EndIf
If lContinua
	//Ŀ
	// Monta o Array aHeader.                                       
	// 

	DBSelectArea("AI2")
	DBSetorder(1)

	If Empty( AScan(aHeader,{|x| x[8] == "M"} ) ) 
		aStruAI2 := AI2->( dbStruct() )
		cArqQry  := "AI2"
		lQuery   := .T.
		cQuery   := "SELECT * "
		cQuery   += "FROM "+RetSqlName("AI2")+" AI2 "
		cQuery   += "WHERE AI2.AI2_FILIAL='"+xFilial("AI2")+"' AND "
		cQuery   += "AI2.AI2_CODBNF='"+AI1->AI1_CODBNF+"' AND "
		cQuery   += "AI2.D_E_L_E_T_=' ' "
		cQuery   += "ORDER BY "+SqlOrder(AI2->(IndexKey()))

		cQuery := ChangeQuery(cQuery)	
	Else
		cArqQry := "AI2"
		MsSeek(xFilial("AI2")+AI1->AI1_CODBNF)
	EndIf

	cSeek  := 	xFilial("AI2")+AI1->AI1_CODBNF
	cWhile :=	("AI2->AI2_FILIAL + AI2->AI2_CODBNF") 


	FillGetDados(	nOpc 		, "AI2", 1	, cSeek,; 
	{||&(cWhile)}, {|| Iif(xFilial("AI2")+AI1->AI1_CODBNF==AI2->AI2_FILIAL + AI2->AI2_CODBNF,.T.,.F.)}, /*aNoFields*/,; 
	/*aYesFields*/, /*lOnlyYes*/, cQuery, /*bMontAcols*/, IIf(nOpc<>3,.F.,.T.),; 
	/*aHeaderAux*/, /*aColsAux*/,{||Fat180Item()} , /*bBeforeCols*/,;
	/*bAfterHeader*/, /*cAliasQry*/) 

	If lGrade
		aCols := aColsGrade(oGrade,aCols,aHeader,"AI2_CODPRO","AI2_ITEM","AI2_ITEMGR",aScan(aHeader,{|x| AllTrim(x[2]) == "AI2_DESPRO"}))	
	EndIf

	If ( lQuery )
		(cArqQry)->( DBCloseArea() )
		ChkFile("AI2",.F.)
		DBSelectArea("AI2")
	EndIf

	If lCopia
		M->AI1_CODBNF := CriaVar("AI1_CODBNF",.T.)
	EndIf 

	dbSelectArea("AI2")                          
	AI2->( dbGoto( 0 ) ) 

	If (Type("lFt180Auto") == "U" .Or. ! lFt180Auto)

		//Ŀ
		// Faz o calculo automatico de dimensoes de objetos     
		//
		aSize := MsAdvSize()
		AAdd( aObjects, { 100, 100, .T., .T. } )
		AAdd( aObjects, { 200, 200, .T., .T. } )
		aInfo := { aSize[ 1 ], aSize[ 2 ], aSize[ 3 ], aSize[ 4 ], 3, 3 }
		aPosObj := MsObjSize( aInfo, aObjects,.T.)

		DEFINE MSDIALOG oDlg TITLE cCadastro From aSize[7],0 To aSize[6],aSize[5] of oMainWnd PIXEL
		EnChoice( "AI1", nReg, nOpc,,,,,aPosObj[1], , 3, , , , , ,.F. )
		oGetD := MsGetDados():New(aPosObj[2,1],aPosObj[2,2],aPosObj[2,3],aPosObj[2,4],nOpc,"Ft180LOk()","Ft180TOk()","+AI2_ITEM",(nOper==3 .Or. nOper==4),,1,,MAXGETDAD)
		ACTIVATE MSDIALOG oDlg ON INIT EnchoiceBar(oDlg,{||nOpcA := 1,If(oGetd:TudoOk(),If(!Obrigatorio(aGets,aTela),nOpcA := 0,oDlg:End()),nOpcA := 0)},{||oDlg:End()})
		FATPDLogUser("FT180RBNF")
	Else
		If EnchAuto(cAlias,aAutoCab,{|| Obrigatorio(aGets,aTela)},aRotina[nOpc][4]) .And. MsGetDAuto(aAutoItens,"Ft180LOk",{|| Ft180TOk()},aAutoCab, aRotina[nOpc][4])
			nOpcA := 1
		EndIf		
	Endif
	//Ŀ
	//Rotina de Gravacao das regras de bonificacao                  
	//?
	If nOpcA == 1 .And. nOpc > 2
		Begin Transaction
			If lGrade
				aCols := aGradeCols(oGrade,aCols,aHeader,"AI2_CODPRO","AI2_ITEMGR",{"AI2_VALORC","AI2_QUANTC"},"AI2_ITEM")
			EndIf
			Ft180Grv(nOpc-2,lCopia)
			While (GetSx8Len() > nSaveSx8)
				ConfirmSx8()
			EndDo
			EvalTrigger()
		End Transaction
	EndIf
EndIf
//Ŀ
//Restaura a entrada da Rotina                                  
//
While (GetSx8Len() > nSaveSx8)
	RollBackSxE()
EndDo
MsUnLockAll()
FreeUsedCode()
RestArea(aArea)
Return(nOpcA)

/*


ͻ
Funcao    |Fat180ITem  Autor Fernando Amorim       Data  15/02/07  
͹
Descricao Inclui na primeira linha do acols o numero do item 		  
͹
Parametros												              
͹
Uso        Bonificao financeira                                  	  
ͼ


*/

Static Function Fat180Item()
Local nX := 0
If Len(aCols) == 1
	For nX := 1 To Len(aHeader)
		If AllTrim(aHeader[nX,2]) == "AI2_ITEM"
			Acols[Len(Acols),nX] := StrZero(1,Len(AI2->AI2_ITEM))

		EndIf    
	Next nX
EndIf  
Return(.T.)


/*


Ŀ
Funo    Ft180Grv   Autor Sergio Silveira         Data  17/04/2002 
Ĵ
Descrio Rotina de Gravacao                                            
Ĵ
Sintaxe   Ft180Grv                                                      
Ĵ
ParametrosExpN1: Opcao da Gravacao sendo:                               
                 [1] Inclusao                                           
                 [2] Alteracao                                          
                 [3] Exclusao                                           
          ExpL1: Indica se esta sendo realizada uma copia               
Ĵ
Uso        Materiais/Distribuicao/Logistica                             
Ĵ
 AtualizACOes sofridas desde a Construcao Inicial.                       
Ĵ
 Programador   Data    BOPS   Motivo da Alteracao                     
Ĵ
                                                                      
ٱ


*/
Static Function Ft180Grv(nOpcao,lCopia)

Local aArea     := GetArea()
Local aRegNo    := {}          
Local bCampo 	:= {|nCPO| Field(nCPO) }
Local cItem     := Repl("0",Len(AI2->AI2_ITEM))
Local lGravou   := .F.
Local nPProd    := GDFieldPos( "AI2_CODPRO" ) 
Local nX        := 0
Local nY        := 0
Local nUsado    := Len(aHeader)

//Ŀ
// Limpa buffer                                                 
//
aUltResult := Nil

Do Case
	Case nOpcao <> 3
		//Ŀ
		//Grava o Cabecalho                                             
		//
		dbSelectArea("AI1")
		dbSetOrder(1)
		If MsSeek(xFilial("AI1")+M->AI1_CODBNF)
			RecLock("AI1",.F.)
		Else
			RecLock("AI1",.T.)
		EndIf
		For nX := 1 TO FCount()
			FieldPut(nX,M->&(EVAL(bCampo,nX)))
		Next nX
		AI1->AI1_FILIAL := xFilial("AI1")
		MsUnLock()
		//Ŀ
		//Guarda os registro para reaproveita-los                       
		//
		dbSelectArea("AI2")
		dbSetOrder(1)
		MsSeek(xFilial("AI2")+M->AI1_CODBNF)
		While ( !Eof() .And. xFilial("AI2") == AI2->AI2_FILIAL .And. AllTrim(M->AI1_CODBNF) == AllTrim(AI2->AI2_CODBNF) )
			aadd(aRegNo,RecNo())
			dbSelectArea("AI2")
			dbSkip()
		EndDo
		
		//Ŀ
		//Grava os itens                                                
		//
		If (Type("lFt180Auto") == "U" .Or. !lFt180Auto) //Manual
			For nX := 1 To Len(aCols)
				If !Empty(aCols[nX,GDFieldPos("AI2_VALORC")]+aCols[nX,GDFieldPos("AI2_QUANTC")]) .And.;
							!Empty(aCols[nX,GDFieldPos("AI2_PERCB")]+aCols[nX,GDFieldPos("AI2_VALORB")])				
					If !lCopia .And. !Empty(aCols[nX,nUsado])
						dbSelectArea("AI2")
						dbGoto(aCols[nX,nUsado])
						RecLock("AI2")
						nY := aScan(aRegNo,{|x| x == aCols[nX,nUsado]})
						aDel(aRegNo,nY)
						aSize(aRegNo,Len(aRegNo)-1)
					ElseIf !aCols[nX][nUsado+1]
						RecLock("AI2",.T.)
					EndIf
					
					If ( !Acols[nX][nUsado+1] )
						For nY := 1 to Len(aHeader)
							If aHeader[nY][10] <> "V"
								AI2->(FieldPut(FieldPos(aHeader[nY][2]),Acols[nX][nY]))
							EndIf
						Next nY
						AI2->AI2_FILIAL := xFilial("AI2")
						AI2->AI2_CODBNF := M->AI1_CODBNF
						lGravou := .T.
					ElseIf !lCopia .And. !Empty(aCols[nX][nUsado])
						AI2->(dbDelete())
					EndIf
					
					MsUnLock()
				EndIf
			Next nX
			
			//Deleta registros nao encontrados
			dbSelectArea("AI2")
			For nX := 1 To Len(aRegNo)
				dbGoTo(aRegNo[nX])
				RecLock("AI2",.F.)
				dbDelete()
				MsUnLock()
			Next nX
								
		Else //Automtico
			nUsado := Len(aAutoItens)
			For nX := 1 To nUsado 
				If !Empty(aCols[nX,GDFieldPos("AI2_VALORB")]+aCols[nX,GDFieldPos("AI2_QUANTC")])

					AI2 -> (DbSetOrder(2))
					
					If DbSeek(xFilial("AI1")+M->AI1_CODBNF+aAutoItens[nX][nX][2])
						RecLock("AI2",.F.)
					Else					
						RecLock("AI2",.T.)		
					Endif
					
					If !Empty(Acols[nX][nUsado+1]) //erro
						AI2->AI2_FILIAL := xFilial("AI1")
						AI2->AI2_CODBNF := M->AI1_CODBNF
			
						For nY := 1 to Len(aHeader)
							If aHeader[nY][10] <> "V"
								AI2->(FieldPut(FieldPos(aHeader[nY][2]),aCols[1][nY]))
							EndIf
						Next nY
						
						lGravou := .T.
					ElseIf !lCopia .And. !Empty(aCols[nX][nUsado])
						AI2->(dbDelete())
					EndIf
					
					AI2->(MsUnLock())
					
				EndIf
			Next nX
		Endif
	Case nOpcao == 3
		dbSelectArea("AI2")
		dbSetOrder(1)
		MsSeek(xFilial("AI2")+M->AI1_CODBNF)
		
		While ( !Eof() .And. xFilial("AI2") == AI2->AI2_FILIAL .And. M->AI1_CODBNF == AI2->AI2_CODBNF )
			RecLock("AI2")
			dbDelete()
			MsUnLock()
			dbSelectArea("AI2")
			dbSkip()
		EndDo
		
		dbSelectArea("AI1")
		dbSetOrder(1)
		If MsSeek(xFilial("AI1")+M->AI1_CODBNF)
			RecLock("AI1")
			dbDelete()
			MsUnLock()
		EndIf
EndCase
Return(lGravou)
/*


Ŀ
Funo    Ft180LOk   Autor Sergio Silveira         Data  17/04/2002 
Ĵ
Descrio Rotina de Validacao da linha Ok                               
Ĵ
Sintaxe   Ft180Lok()                                                    
Ĵ
ParametrosNenhum                                                        
                                                                        
Ĵ
Uso        Materiais/Distribuicao/Logistica                             
Ĵ
 AtualizACOes sofridas desde a Construcao Inicial.                       
Ĵ
 Programador   Data    BOPS   Motivo da Alteracao                     
Ĵ
                                                                      
ٱ


*/
Function Ft180Lok()

Local aArea     := GetArea() 
Local lRetorno  := .T.
Local nPProd    := GDFieldPos( "AI2_CODPRO" )
Local nPGrupo   := GDFieldPos( "AI2_GRUPO"  )                     
Local nPValorC  := GDFieldPos( "AI2_VALORC" )
Local nPQuantC  := GDFieldPos( "AI2_QUANTC" )
Local nPValorB  := GDFieldPos( "AI2_VALORB" )
Local nPPercB   := GDFieldPos( "AI2_PERCB"  )

//Ŀ
//Verifica os campos obrigatorios                                         
//
If !GDDeleted() 
	Do Case
		Case nPProd == 0 .Or. nPGrupo == 0
		lRetorno := .F.
		Help(" ",1,"OBRIGAT",,RetTitle("AI2_CODPRO")+","+RetTitle("AI2_GRUPO"),4)
		Case (Empty(Acols[n,nPProd]) .And. Empty(Acols[n,nPGrupo])) .Or. ( Empty( ACols[n,nPValorC] ) .And. ;
		Empty( ACols[n,nPQuantC] )	) .Or. ( Empty( ACols[n,nPValorB] ) .And. ;
		Empty( ACols[n,nPPercB] ) ) 
		lRetorno := .F.
		Help(" ",1,"OBRIGAT")
	EndCase

	//Ŀ
	//Verifica se ha valores duplicados                                       
	//
	If lRetorno   
		lRetorno := GDCheckKey( { "AI2_CODPRO", "AI2_GRUPO", "AI2_VALORC", "AI2_QUANTC", "AI2_VALORB", "AI2_PERCB", "AI2_REGRAB" }, 4 ) 
	EndIf                                       

EndIf
RestArea(aArea)
Return(lRetorno)

/*


Ŀ
Funo    Ft180TOk   Autor Sergio Silveira         Data  17/04/2002 
Ĵ
Descrio Rotina de Validacao da TudoOk                                 
Ĵ
Sintaxe   Ft180Tok()                                                    
Ĵ
ParametrosNenhum                                                        
                                                                        
Ĵ
Uso        Materiais/Distribuicao/Logistica                             
Ĵ
 Atualizacoes sofridas desde a Construcao Inicial.                       
Ĵ
 Programador   Data    BOPS   Motivo da Alteracao                     
Ĵ
                                                                      
ٱ


*/

Function Ft180Tok()

Local aArea    := GetArea()
Local lRetorno := .T.

//Ŀ
// Verifica se os campos obrigatorios foram preenchidos                   
//

If Empty( M->AI1_CODCLI ) .And. Empty( M->AI1_GRPVEN ) 
	lRetorno := .F. 
	Help( "", 1, "CLIGRPVE1" ) 
EndIf

RestArea(aArea)
Return(lRetorno)

/*


Ŀ
Funo    Ft180Copia Autor Sergio Silveira         Data 17/04/2002  
Ĵ
Descrio Rotina de Copia da Regra de bonificacao financeira            
Ĵ
Sintaxe   ExpX1 := Ft180Copia( ExcC1, ExpN1, ExpN2 )                    
Ĵ
ParametrosExpC1: Alias do Arquivo                                       
          ExpN1: Numero do Registro                                     
          ExpN2: Opcao do aRotina                                       
Ĵ
Retorno   ExpX1 -> Retorno da FT180RDES                                 
Ĵ
Uso        Materiais/Distribuicao/Logistica                             
Ĵ
 AtualizACOes sofridas desde a Construcao Inicial.                       
Ĵ
 Programador   Data    BOPS   Motivo da Alteracao                     
Ĵ
                                                                      
ٱ


*/

Function Ft180Copia( cAlias, nRecno, nOpcao )

Local xRet

//Ŀ
// Faz a chamada passando o parametro de copia                  
//
xRet := Ft180RBnF( cAlias, nRecno, nOpcao, , .T. )

Return( xRet )

/*


Ŀ
Funo    Ft180PrReg Autor Sergio Silveira         Data 17/04/2002  
Ĵ
Descrio  Chamada do processamento das Regras de bonificacao financeira
Ĵ
Sintaxe    Ft180PrReg( ExpC1, ExpN1, ExpN2 )                            
Ĵ
Parametros ExpC1 -> Alias / ExpN1 -> Registro atual / ExpN2 -> Opcao    
Ĵ
Retorno    Nil                                                          
Ĵ
Uso        Materiais/Distribuicao/Logistica                             
Ĵ
 AtualizACOes sofridas desde a Construcao Inicial.                       
Ĵ
 Programador   Data    BOPS   Motivo da Alteracao                     
Ĵ
                                                                      
ٱ


*/

Function Ft180PrReg( cAlias, nRecno, nOpcao )

Local nOpcA := 0

Pergunte("FTA180",.F.)

FormBatch(OemToAnsi( STR0010 ),; //"Processar"
{	OemToAnsi( STR0011 ),; //"Esta rotina efetua o processamento das regras de bonificacao financeira "
OemToAnsi( STR0012 ),; //"usando como base as Notas Fiscais emitidas, conforme os parametros selecionados."
OemToAnsi( "" )},;
{  {5,.T.,{|o| Pergunte("FTA180",.T.)}},;
{1,.T.,{|o| nOpcA:=1,o:oWnd:End()}},;
{2,.T.,{|o| o:oWnd:End()}}})

If ( nOpcA == 1 )

	Processa({||Ft180Estor( .T.,MV_PAR01,MV_PAR02,MV_PAR03,MV_PAR05,MV_PAR04,MV_PAR06,.F.),Ft180Regra( .T. )})

EndIf

Return(.T.)

/*


Ŀ
Funo    Ft180Regra Autor Sergio Silveira         Data 17/04/2002
Ĵ
Descrio  Chamada do Processamento das Regras de bonificacao financ. 
Ĵ
Retorno    Nenhum                                                     
Ĵ
Parametros ExpL1 -> Exibe resumo                                      
Ĵ
   DATA    Programador   Manutencao Efetuada                         
Ĵ
                                                                     
ٱ


*/

Static Function Ft180Regra( lResumo )

Local aStruSD2    := {}                 

Local cQuery      := ""        
Local cCond       := ""        
Local cIndTrab    := ""        
Local cPrefixo    := GetMV( "MV_BNFPREF" ) 
Local cNumero     := GetMV( "MV_BNFNUM" ) 

Local nTitGer     := 0 
Local nVlrBnfTot  := 0        
Local nLoop       := 0                  

Local oDlg
Local oBitMap
Local oBold
Local oSay1
Local oSay2
Local oSay3
Local oBut1 

Local cCliente 	:= ""
Local cLoja	 	:= ""
Local cNome		:= ""
Local cNReduz	:= ""
Local nTotCli	:= 0		

lResumo := If( ValType( lResumo ) == "L", lResumo, .F. )

If !Empty( cPrefixo ) 

	If Empty( cNumero ) 
		cNumero := StrZero(TAMSX3("F2_DOC")[1])
	EndIf	

	//Ŀ
	// Aglutina valor / quantidade por cliente / grupo / produto    
	//

	//Ŀ
	// Logica para SQL / TOP                                        
	//

	cArqTrbSD2 := GetNextAlias() 

	cQuery := ""
	cQuery += "SELECT D2_CLIENTE TRB_CLIENTE, D2_LOJA TRB_LOJA, D2_GRUPO TRB_GRUPO, D2_COD TRB_CODPRO, "
	cQuery += "SUM( D2_QUANT ) TRB_QUANT, SUM( D2_TOTAL ) TRB_VALOR, A1_NOME TRB_NOME, A1_NREDUZ TRB_NREDUZ FROM "
	cQuery += RetSqlName( "SD2" ) + " SD2," 

	If MV_PAR09==1
		cQuery += RetSqlName( "SF4" ) + " SF4,"
	EndIf

	cQuery += RetSqlName( "SA1" ) + " SA1 "
	cQuery += "WHERE " 
	cQuery += "D2_FILIAL='"   + xFilial( "SD2" ) + "' AND " 
	cQuery += "D2_EMISSAO>='" + DToS( MV_PAR01 ) + "' AND " 	
	cQuery += "D2_EMISSAO<='" + DToS( MV_PAR02 ) + "' AND " 		
	cQuery += "D2_CLIENTE>='" + MV_PAR03  + "' AND " 	
	cQuery += "D2_CLIENTE<='" + MV_PAR05  + "' AND " 		
	cQuery += "D2_LOJA>='"    + MV_PAR04  + "' AND " 	
	cQuery += "D2_LOJA<='"    + MV_PAR06  + "' AND " 		
	cQuery += "D2_TIPO='N' AND "

	If cPaisLoc <> "BRA"
		cQuery += "D2_ESPECIE='NF ' AND " 
	EndIf

	cQuery += "SD2.D_E_L_E_T_=' ' AND "

	If MV_PAR09==1
		cQuery += "SF4.F4_FILIAL='"   + xFilial( "SF4" ) + "' AND "
		cQuery += "SF4.F4_CODIGO=SD2.D2_TES AND "
		cQuery += "SF4.F4_DUPLIC='S' AND "
		cQuery += "SF4.D_E_L_E_T_=' ' AND "
	EndIf

	cQuery += "A1_FILIAL='"   + xFilial( "SA1" ) + "' AND " 			
	cQuery += "D2_CLIENTE=A1_COD AND D2_LOJA=A1_LOJA AND "   		
	cQuery += "SA1.D_E_L_E_T_=' ' "

	cQuery += "GROUP BY D2_CLIENTE, D2_LOJA, A1_NOME, A1_NREDUZ, D2_GRUPO, D2_COD ORDER BY D2_CLIENTE, D2_LOJA, A1_NOME, A1_NREDUZ, D2_GRUPO, D2_COD"

	cQuery := ChangeQuery( cQuery ) 

	dbUseArea( .T., "	TOPCONN", cArqTrbSD2, TcGenQry( ,,cQuery ), .F., .T. )

	TcSetField( cArqTrbSD2, "TRB_VALOR", "N", 16, 2 )  
	TcSetField( cArqTrbSD2, "TRB_QUANT", "N", 13, 2 )  	

	//Ŀ
	// Aglutina por Cliente                                         
	//
	If mv_par10 == 1

		While !( cArqTrbSD2 )->( Eof() )

			cCliente := ( cArqTrbSD2 )->TRB_CLIENT
			cLoja	 := ( cArqTrbSD2 )->TRB_LOJA
			cNome	 := ( cArqTrbSD2 )->TRB_NOME
			cNReduz	 := ( cArqTrbSD2 )->TRB_NREDUZ
			nTotCli	 := 0		
			While !( cArqTrbSD2 )->( Eof() ) .And. cCliente == ( cArqTrbSD2 )->TRB_CLIENT .And. cLoja == ( cArqTrbSD2 )->TRB_LOJA
				//Ŀ
				// Processa as regras por cliente / grupo / produto             
				//
				aBonusFin := MaAvalRBnf( ( cArqTrbSD2 )->TRB_CLIENT, ( cArqTrbSD2 )->TRB_LOJA, ( cArqTrbSD2 )->TRB_CODPRO,;
				( cArqTrbSD2 )->TRB_GRUPO, ( cArqTrbSD2 )->TRB_QUANT, ( cArqTrbSD2 )->TRB_VALOR, MV_PAR07, MV_PAR08 )

				For nLoop := 1 To Len( aBonusFin )
					nTotCli +=	aBonusFin[ nLoop, 4 ]
				Next

				( cArqTrbSD2 )->( dbSkip() )
			EndDo

			If nTotCli > 0
				Begin Transaction
					//Ŀ
					// Incrementa a numeracao do titulo                             
					//
					cNumero := Soma1( cNumero )

					If Empty( nTitGer )
						cFirstTit := cNumero
					EndIf

					nTitGer++
					nVlrBnfTot += nTotCli

					//Ŀ
					// Cria o titulo NCC                                            
					//
					GravaTit(nTotCli,cCliente,cLoja,cNome,cNReduz,cPrefixo,cNumero)
				End Transaction
			EndIf

		EndDo

		//Ŀ
		// Aglutina por Cliente/Loja/Produto                            
		//
	Else

		While !( cArqTrbSD2 )->( Eof() )

			//Ŀ
			// Processa as regras por cliente / grupo / produto             
			//
			aBonusFin := MaAvalRBnf( ( cArqTrbSD2 )->TRB_CLIENT, ( cArqTrbSD2 )->TRB_LOJA, ( cArqTrbSD2 )->TRB_CODPRO,;
			( cArqTrbSD2 )->TRB_GRUPO, ( cArqTrbSD2 )->TRB_QUANT, ( cArqTrbSD2 )->TRB_VALOR, MV_PAR07, MV_PAR08 )

			For nLoop := 1 To Len( aBonusFin )

				Begin Transaction

					//Ŀ
					// Incrementa a numeracao do titulo                             
					//
					cNumero := Soma1( cNumero )

					If Empty( nTitGer )
						cFirstTit := cNumero
					EndIf

					nTitGer++
					nVlrBnfTot += aBonusFin[ nLoop, 4 ]

					//Ŀ
					// Cria o titulo NCC                                            
					//
					GravaTit(aBonusFin[ nLoop, 4 ],( cArqTrbSD2 )->TRB_CLIENTE,( cArqTrbSD2 )->TRB_LOJA,( cArqTrbSD2 )->TRB_NOME,( cArqTrbSD2 )->TRB_NREDUZ,cPrefixo,cNumero)

				End Transaction

			Next nLoop

			( cArqTrbSD2 )->( dbSkip() )

		EndDo

	EndIf

	If lResumo 

		//Ŀ
		// Exibe o resumo                                               
		//

		DEFINE MSDIALOG oDlg TITLE STR0013  FROM 9,0 TO 25,50 OF oMainWnd //"Resumo"

		@   0, 0 BITMAP oBmp RESNAME "LOGIN" oF oDlg SIZE 30, 120 NOBORDER WHEN .F. PIXEL

		DEFINE FONT oBold NAME "Arial" SIZE 0, -12 BOLD

		@ 03, 38 SAY STR0014 FONT oBold PIXEL  //"Resumo do processamento das regras de "
		@ 13, 38 SAY STR0015 FONT oBold PIXEL  //"bonificacao financeira"

		@ 24, 30 TO 26 ,400 LABEL '' OF oDlg   PIXEL  

		@ 35, 38 SAY STR0016 PIXEL     //"Titulos gerados"
		@ 45, 38 SAY STR0017 PIXEL  //"Valor total de bonificacao"
		@ 55, 38 SAY oSay1 PROMPT STR0018 PIXEL  //"Prefixo dos titulos"
		@ 65, 38 SAY oSay2 PROMPT STR0019 PIXEL  //"Primeiro titulo gerado"
		@ 75, 38 SAY oSay3 PROMPT STR0020 PIXEL  //"Ultimo titulo gerado"

		@ 35,110 SAY nTitGer    SIZE 80, 10 PIXEL   RIGHT
		@ 45,110 SAY Transform( nVlrBnfTot, "@e 999,999,999.99" ) SIZE 80, 10 PIXEL   RIGHT

		If Empty( nTitGer ) 
			oSay1:Disable()
			oSay2:Disable()
			oSay3:Disable()	
		Else 
			@ 55,110 SAY cPrefixo   SIZE 80, 10 PIXEL   RIGHT
			@ 65,110 SAY cFirstTit  SIZE 80, 10 PIXEL   RIGHT 
			@ 75,110 SAY cNumero    SIZE 80, 10 PIXEL   RIGHT
		EndIf

		@ 90, 30 TO 92 ,400 LABEL '' OF oDlg   PIXEL  	 

		DEFINE SBUTTON oBut1 FROM 98, 162  TYPE 1 ACTION ( oDlg:End() ) ENABLE of oDlg

		ACTIVATE MSDIALOG oDlg CENTERED 

	EndIf 

Else

	Help( " ", 1, "FT180BNFPR" ) // Nao foi definido prefixo para os titulos de bonificacao financeira 

EndIf 	

Return( .T. )                                                                 

/*


Ŀ
Funo    MaAvalRBnf Autor Sergio Silveira         Data 14/05/2002
Ĵ
Descrio  Processamento das Regras de bonificacao financeira         
Ĵ
Sintaxe    ExpA1 := MaAvalRBnf( ExpC1, ExpC2, ExpC3, ExpC4, ExpN1,    
            ExpN2, [ ExpC5 ], [ ExpC6 ] )                             
Ĵ
Retorno    ExpA1 -> Array contendo a seguinte estrutura:              
               1 -> Codigo da regra                                   
               2 -> Item da regra                                     
               3 -> Tipo de bonificacao ( maior / menor )             
               4 -> Valor da bonificacao                              
Ĵ
Parametros ExpC1 -> Codigo do cliente                                 
           ExpC2 -> Loja do cliente                                   
           ExpC3 -> Codigo do produto                                 
           ExpC4 -> Grupo do produto                                  
           ExpN1 -> Quantidade da condicao                            
           ExpN2 -> Valor da condicao                                 
           ExpC5 -> Codigo da regra de                                
           ExpC6 -> Codigo da regra ate                               
           OBS : Caso seja passada regra "de" e nao seja passada regra
           "ate", apenas a regra "de" sera processada                 
Ĵ
   DATA    Programador   Manutencao Efetuada                         
Ĵ
                                                                     
ٱ


*/

Function MaAvalRBnf( cCodCli, cLojaCli, cCodPro, cGrupo, nQuantC, nValorC, cCodBNFDe, cCodBNFAte ) 

Local aStructAI2  := {} 
Local aBonusFin   := {}   
Local aCliStru    := {}   
Local bWhile      := { || .T. } 
Local cQuery      := ""
Local cArqRegras  := ""
Local cArqTrab    := ""
Local cGrpVen     := ""
Local cGrpVenQueb := "" 
Local cGrpVenCli  := ""
Local lFiltraBNF  := .F. 
Local lContinua   := .F. 
Local lGrpVen     := .F. 
Local nDecValC    := 0 
Local nDecQtdC    := 0            
Local nValRet     := 0            

If ValType( cCodBNFDe ) == "C" 

	lFiltraBNF := .t. 

	If ValType( cCodBNFAte ) <> "C"
		cCodBNFAte := cCodBNFDe 
	EndIf	

Else 
	lFiltraBNF := .F. 
EndIf 

aStructAI2 := AI2->( dbStruct() ) 

nDecValC   := aStructAI2[ AScan( aStructAI2, { |x| AllTrim( x[1] ) == "AI2_VALORC" } ), 4 ]
nDecQtdC   := aStructAI2[ AScan( aStructAI2, { |x| AllTrim( x[1] ) == "AI2_QUANTC" } ), 4 ]

SA1->( dbSetOrder( 1 ) ) 
If SA1->( MsSeek( xFilial( "SA1" ) + cCodCli + cLojaCli ) ) 
	cGrpVenCli := SA1->A1_GRPVEN 
EndIf 

lGrpVen := !Empty( cGrpVenCli ) 

//Ŀ
// LOGICA PARA SQL / TOP                                        
//

cArqTrab := "QRYREGRAS" 

cQuery := ""                     

cQuery += "SELECT AI1_CODBNF, AI1_GRPVEN, AI1_RECGRP,AI2.* FROM " + RetSqlName( "AI1" ) + " AI1, " + RetSqlName( "AI2" ) + " AI2 "
cQuery += "WHERE "                

If lGrpVen
	cQuery += "( ( AI1_CODCLI='"  + cCodCli  + "' AND "
	cQuery += "AI1_LOJA='"    + cLojaCli + "' ) OR ( AI1_CODCLI='" + Space( Len( AI1->AI1_CODCLI ) ) + "' AND "
	cQuery += "AI1_LOJA='"    + Space( Len( AI1->AI1_CODCLI ) ) + "' ) ) AND "
Else
	cQuery += "AI1_CODCLI='"  + cCodCli + "' AND AI1_LOJA='" + cLojaCli + "' AND "	
EndIf 		

If lFiltraBNF
	cQuery += "AI1_CODBNF>='" + cCodBNFDe  + "' AND "
	cQuery += "AI1_CODBNF<='" + cCodBNFAte + "' AND "
EndIf 	

cQuery += "AI1_CODBNF=AI2_CODBNF AND " 
cQuery += "AI1.D_E_L_E_T_=' ' AND " 		
cQuery += "( ( AI2_CODPRO='" + cCodPro + "' AND AI2_GRUPO='"  + Space( Len( AI2->AI2_GRUPO  ) ) + "' ) OR "
cQuery += "( AI2_GRUPO='"  + cGrupo  + "' AND AI2_CODPRO='" + Space( Len( AI2->AI2_CODPRO ) ) + "' ) ) AND "	
cQuery += "( ( AI2_QUANTC=0 AND " + AllTrim( Str( nValorC, , nDecValC ) ) + ">=AI2_VALORC ) OR "
cQuery += "( AI2_VALORC=0 AND "   + AllTrim( Str( nQuantC, , nDecQtdC ) ) + ">=AI2_QUANTC ) ) AND "
cQuery += "AI2.D_E_L_E_T_=' ' ORDER BY AI1_GRPVEN"		

dbUseArea( .T., "TOPCONN", TcGenQry( ,, cQuery ), cArqTrab, .F., .T. ) 

While !( cArqTrab )->( Eof() ) 

	lContinua := .T. 

	If lGrpVen

		If !Empty( ( cArqTrab )->AI1_GRPVEN )    

			If ( cArqTrab )->AI1_RECGRP == "1"

				//Ŀ
				// Utiliza recursividade do grupo                               
				//

				//Ŀ
				// Cria o array de grupos que estao abaixo deste Grupo          
				//
				aCliStru := { { ( cArqTrab )->AI1_GRPVEN, 0 } } 
				MaCliStru( ( cArqTrab )->AI1_GRPVEN, @aCliStru ) 

				lContinua := !Empty( AScan( aCliStru, { |x| x[1] == cGrpVenCli } ) ) 

				aCliStru := {} 

			Else
				//Ŀ
				// Nao utiliza recursividade do grupo                           
				//
				lContinua := ( cGrpVenCli == ( cArqTrab )->AI1_GRPVEN ) 
			EndIf 					

		EndIf 

	EndIf 

	cGrpVenQueb := ( cArqTrab )->AI1_GRPVEN

	While !( cArqTrab )->( Eof() ) .And. cGrpVenQueb == ( cArqTrab )->AI1_GRPVEN

		If lContinua 					                      

			nValRet := MaCalcBNF( ( cArqTrab )->AI2_VALORC, ( cArqTrab )->AI2_QUANTC, ( cArqTrab )->AI2_VALORB,;
			( cArqTrab )->AI2_PERCB, ( cArqTrab )->AI2_PROPVB, ( cArqTrab )->AI2_REGRAB, nValorC, nQuantC )

			AAdd( aBonusFin, { ( cArqTrab )->AI2_CODBNF, ( cArqTrab )->AI2_ITEM, ( cArqTrab )->AI2_REGRAB, nValRet } ) 				  

		EndIf 

		( cArqTrab )->( dbSkip() ) 	

	EndDo 	

EndDo 

( cArqTrab )->( dbCloseArea()) 

dbSelectArea( "AI1" ) 

Return( aBonusFin )         

/*


Ŀ
Funo    MaCalcBNF  Autor Sergio Silveira         Data 16/05/2002
Ĵ
Descrio  Efetua o calculo do valor de bonus para a regra de bonific 
           Financeira                                                 
Ĵ
Sintaxe    ExpN7 :=  MaCalcBNF(ExpN1,ExpN2,ExpN3,ExpN4,ExpC1,ExpC2,   
           ExpN5,ExpN6)                                               
Ĵ
Retorno    ExpN7 -> Valor de bonificacao                              
Ĵ
Parametros Descricao:                                                  
           ExpN1 -> Valor da condicao ( AI2 )                         
           ExpN2 -> Quantidade da condicao ( AI2 )                    
           ExpN3 -> Valor do bonus ( AI2 )                            
           ExpN4 -> Percentual do bonus ( AI2 )                       
           ExpC1 -> Regra para bonus ( AI2 )                          
           ExpC2 -> Proporcionaliza valor do bonus                    
           ExpN5 -> Valor apurado condicao                            
           ExpN6 -> Quantidade apurada condicao                       
Ĵ
   DATA    Programador   Manutencao Efetuada                         
Ĵ
                                                                     
ٱ


*/

Function MaCalcBNF( nAI2ValorC, nAI2QuantC, nAI2ValorB, nAI2PercB, cAI2PropVb, cAI2RegraB, nValorC, nQuantC )

Local nFator    := 1 			        
Local nValRet   := 0 
Local nValPerc  := 0 
Local nValor    := 0 

If cAI2PropVB == "1" 
	//Ŀ
	// Proporcionaliza o valor do bonus                             
	//
	If Empty( nAI2QuantC ) 
		nFator := Int( nValorC / nAI2ValorC ) 
	Else
		nFator := Int( nQuantC / nAI2QuantC )
	EndIf 			                            

EndIf	

//Ŀ
// Calcula o bonus de valor e por percentual                    
//
nValPerc := ( nAI2PercB * nValorC ) / 100
nValor   := nAI2ValorB * nFator 

//Ŀ
// Identifica qual deve ser utilizado                           
//
Do Case 	                                                                             
	Case cAI2RegraB == "1" // Percentual ou valor 
	If Empty( nAI2ValorB ) 
		nValRet := nValPerc 
	Else	
		nValRet := nValor
	EndIf 	 			
	Case cAI2RegraB == "2" // O que for maior 
	nValRet := If( nValPerc > nValor, nValPerc, nValor ) 
	Case cAI2RegraB == "3" // O que for maior 	 
	nValRet := If( nValPerc < nValor, nValPerc, nValor ) 	
EndCase

Return( nValRet ) 

/*


Ŀ
Funo    Ft180PrEst Autor Sergio Silveira         Data 29/04/2002  
Ĵ
Descrio  Chamada do processamento do estorno dos titulos              
Ĵ
Sintaxe    Ft180PrEst( ExpC1, ExpN1, ExpN2 )                            
Ĵ
Parametros ExpC1 -> Alias / ExpN1 -> Registro atual / ExpN2 -> Opcao    
Ĵ
Retorno    Nil                                                          
Ĵ
Uso        Materiais/Distribuicao/Logistica                             
Ĵ
 AtualizACOes sofridas desde a Construcao Inicial.                       
Ĵ
 Programador   Data    BOPS   Motivo da Alteracao                     
Ĵ
                                                                      
ٱ


*/

Function Ft180PrEst( cAlias, nRecno, nOpcao )

Local nOpcA := 0

Pergunte("FTA181",.F.)

FormBatch(OemToAnsi( STR0026 ),;  //"Exclusao"
{	OemToAnsi( STR0027 ),; // //"Esta rotina efetua o estorno dos titulos de bonificacao financeira "
OemToAnsi( STR0028 ),; //"conforme os parametros selecionados."
OemToAnsi( "" )},;
{  {5,.T.,{|o| Pergunte("FTA181",.T.)}},;
{1,.T.,{|o| nOpcA:=1,o:oWnd:End()}},;
{2,.T.,{|o| o:oWnd:End()}}})

If ( nOpcA == 1 )

	Processa({|| Ft180Estor( .T. ,MV_PAR01,MV_PAR02,MV_PAR03,MV_PAR05,MV_PAR04,MV_PAR06,MV_PAR07==1)})

EndIf

Return(.T.)


/*


Ŀ
Funo    Ft180Estor Autor Sergio Silveira         Data 29/04/2002  
Ĵ
Descrio  Processamento do estorno dos titulos de BNF                  
Ĵ
Sintaxe    Ft180Estor( ExpL1 )                                          
Ĵ
Parametros ExpL1 -> Exibe resumo                                        
Ĵ
Retorno    Nil                                                          
Ĵ
Uso        Materiais/Distribuicao/Logistica                             
Ĵ
 AtualizACOes sofridas desde a Construcao Inicial.                       
Ĵ
 Programador   Data    BOPS   Motivo da Alteracao                     
Ĵ
                                                                      
ٱ


*/

Function Ft180Estor( lResumo,dEmisIni,dEmisFim,cCliIni,cCliFim,cLojaIni,cLojaFim,lHelp)

Local aArea      := GetArea() 

Local cAliasTrab := ""
Local cQuery     := ""
Local cPrefixo   := GetMV( "MV_BNFPREF" ) 
Local cOrigem    := PadR( "FATA180", Len( SE1->E1_ORIGEM ) )

Local lQuery     := .F. 

Local nTitEst    := 0 
Local nTitNotEst := 0 
Local nVlrEstTot := 0 

Local oDlg
Local oBold
Local oBmp  

lResumo := If( ValType( lResumo ) == "L", lResumo, .F. )

cAliasTrab := "ESTORBFN" 

cQuery := ""

cQuery += "SELECT R_E_C_N_O_ SE1RECNO FROM " + RetSqlName("SE1") + " " 
cQuery += "WHERE E1_FILIAL='"+ xFilial( "SE1" ) + "' AND " 
cQuery += "E1_EMISSAO>='"    + DToS( dEmisIni ) + "' AND " 
cQuery += "E1_EMISSAO<='"    + DToS( dEmisFim ) + "' AND " 	
cQuery += "E1_ORIGEM='"      + cOrigem          + "' AND " 
cQuery += "E1_CLIENTE>='"    + cCliIni + "' AND " 
cQuery += "E1_CLIENTE<='"    + cCliFim + "' AND " 	
cQuery += "E1_LOJA>='"       + cLojaIni + "' AND " 
cQuery += "E1_LOJA<='"       + cLojaFim + "' AND " 	
cQuery += "D_E_L_E_T_=' ' "

cQuery := ChangeQuery( cQuery )

dbUseArea( .T., "TOPCONN", TcGenQry( ,, cQuery ), cAliasTrab, .F., .T. ) 

TcSetField( cAliasTrab, "SE1RECNO", "N", 10, 0 ) 

While !( cAliasTrab )->( Eof() )

	SE1->( DBGoto( ( cAliasTrab )->SE1RECNO ) ) 

	//Ŀ
	// Verifica se pode excluir o titulo                            
	//
	If FaCanDelCR( "SE1", "FATA180", lHelp ) 

		nVlrEstTot += xMoeda( SE1->E1_VALOR, SE1->E1_MOEDA, 1, dDataBase ) 

		Begin Transaction 

			RecLock( "SE1", .F. ) 
			SE1->( dbDelete() ) 
			SE1->( MsUnlock() ) 

			//Ŀ
			// Atualiza acumulados                                          
			//
			FaAvalSE1( 2, "FATA180" ) 					

		End Transaction 

		nTitEst++
	Else
		nTitNotEst++	
	EndIf 

	( cAliasTrab )->( dbSkip() ) 

EndDo

( cAliasTrab )->( dbCloseArea() ) 
dbSelectArea( "SE1" ) 

RestArea( aArea ) 

If lResumo 

	//Ŀ
	// Exibe o resumo                                               
	//

	DEFINE MSDIALOG oDlg TITLE STR0013  FROM 9,0 TO 25,50 OF oMainWnd //"Resumo"

	@   0, 0 BITMAP oBmp RESNAME "LOGIN" oF oDlg SIZE 30, 120 NOBORDER WHEN .F. PIXEL

	DEFINE FONT oBold NAME "Arial" SIZE 0, -12 BOLD

	@ 03, 38 SAY STR0021 FONT oBold PIXEL   //"Resumo do estorno das regras de "
	@ 13, 38 SAY STR0015 FONT oBold PIXEL  //"bonificacao financeira"

	@ 24, 30 TO 26 ,400 LABEL '' OF oDlg   PIXEL  

	@ 45, 38 SAY STR0022 PIXEL    //"Titulos estornados"
	@ 55, 38 SAY STR0023 PIXEL //"Valor total de estorno"
	@ 65, 38 SAY STR0024 PIXEL //"Titulos nao estornados ( Validacao )"

	@ 45,110 SAY nTitEst	    SIZE 80, 10 PIXEL   RIGHT
	@ 55,110 SAY Transform( nVlrEstTot, "@e 999,999,999.99" ) SIZE 80, 10 PIXEL   RIGHT
	@ 65,110 SAY nTitNotEst SIZE 80, 10 PIXEL   RIGHT              

	@ 90, 30 TO 92 ,400 LABEL '' OF oDlg   PIXEL  	 

	DEFINE SBUTTON oBut1 FROM 98, 162  TYPE 1 ACTION ( oDlg:End() ) ENABLE of oDlg

	ACTIVATE MSDIALOG oDlg CENTERED 

EndIf 

RestArea( aArea )  

Return() 

/*/


Ŀ
Programa  MenuDef    Autor  Marco Bianchi          Data 01/09/2006
Ĵ
Descrio  Utilizacao de menu Funcional                               
                                                                      
                                                                      
Ĵ
Retorno   Array com opcoes da rotina.                                 
Ĵ
ParametrosParametros do array a Rotina:                               
          1. Nome a aparecer no cabecalho                             
          2. Nome da Rotina associada                                 
          3. Reservado                                                
          4. Tipo de Transao a ser efetuada:                        
          		1 - Pesquisa e Posiciona em um Banco de Dados           
              2 - Simplesmente Mostra os Campos                       
              3 - Inclui registros no Bancos de Dados                 
              4 - Altera o registro corrente                          
              5 - Remove o registro corrente do Banco de Dados        
          5. Nivel de acesso                                          
          6. Habilita Menu Funcional                                  
Ĵ
   DATA    Programador   Manutencao efetuada                         
Ĵ
                                                                     
ٱ


/*/

Static Function MenuDef()

Local lPyme := If( Type( "__lPyme" ) <> "U", __lPyme, .F. ) 

Private aRotina := {	{ OemToAnsi(STR0001),"AxPesqui"		,0,1,0,.F.},;	// "Pesquisar"
{ OemToAnsi(STR0002),"Ft180RBnF"		,0,2,0,NIL},;	// "Visualizar"
{ OemToAnsi(STR0003),"Ft180RBnF"		,0,3,0,NIL},;	// "Incluir"
{ OemToAnsi(STR0004),"Ft180RBnF"		,0,4,0,NIL},;	// "Alterar"
{ OemToAnsi(STR0005),"Ft180RBnF"		,0,5,0,NIL},;	// "Excluir"
{ OemToAnsi(STR0009),"Ft180PrReg"	,0,4,0,NIL},; // "P&rocessa"
{ OemToAnsi(STR0025),"Ft180PrEst"	,0,4,0,NIL},; // "Estornar"	
{ OemToAnsi(STR0006),"Ft180Copia"	,0,3,0,NIL}}	// "Copiar"

If !lPyme
	AAdd(aRotina,{STR0008,"MsDocument", 0 , 4,0,NIL}) //"Conhecimento"
EndIf

If ExistBlock("FT180MNU")
	ExecBlock("FT180MNU",.F.,.F.)
EndIf

Return(aRotina)

/*/


Ŀ
Programa  GravaTit   Autor  Marco Bianchi          Data 25/09/2006
Ĵ
Descrio  Cria o titulo NCC                                          
                                                                      
                                                                      
Ĵ
Retorno   Array com opcoes da rotina.                                 
Ĵ
Parametros 1. Valor do Titulo                                         
           2. Codigo do Cliente                                       
           3. Loja do Cliente                                         
           4. Nome do Cliente                                         
           5. Nome reduzido do Cliente                                
Ĵ
   DATA    Programador   Manutencao efetuada                         
Ĵ
                                                                     
ٱ


/*/

Static Function GravaTit(nValTit,cCliente,cLoja,cNome,cNReduz,cPrefixo,cNumero)

RecLock( "SE1", .T. )

SE1->E1_FILIAL  := xFilial( "SE1" )
SE1->E1_CLIENTE := cCliente
SE1->E1_LOJA    := cLoja
SE1->E1_NOMCLI  := If(Empty( cNReduz ), cNome, cNReduz )
SE1->E1_VALOR   := nValTit
SE1->E1_SALDO   := SE1->E1_VALOR
SE1->E1_EMISSAO := dDataBase
SE1->E1_VENCTO  := dDataBase
SE1->E1_VENCREA := DataValida(SE1->E1_VENCTO,.T.)
SE1->E1_PARCELA := "A"
SE1->E1_TIPO    := "NCC"
SE1->E1_SERIE   := cPrefixo
SE1->E1_PREFIXO := cPrefixo
SE1->E1_NUM     := cNumero
SE1->E1_VLCRUZ  := SE1->E1_VALOR // VERIFICAR
SE1->E1_LA      := "S"
SE1->E1_SITUACA := "0"
SE1->E1_MOEDA   := 1
SE1->E1_EMIS1   := dDataBase
SE1->E1_STATUS  := "A"

SE1->( MsUnlock() )

//Ŀ
// Atualiza acumulados                                          
//
FaAvalSE1( 1, "FATA180" )

//Ŀ
// Atualiza o ultimo titulo gerado                              
//
PutMV( "MV_BNFNUM", cNumero )

Return

/*


ͻ
Programa  Ft180Prod Autor  Andre Anjos	      Data   13/11/09   
͹
Descricao  Funcao de validacao do produto digitado.                   
͹
Uso        FATA180                                                    
ͼ


*/
Function Ft180Prod()
Local aArea 	  := GetArea()
Local lRet  	  := .T.
Local nITEMGR     := aScan(aHeader,{|x| AllTrim(x[2]) == "AI2_ITEMGR"})
Local nDESPRO     := aScan(aHeader,{|x| AllTrim(x[2]) == "AI2_DESPRO"})
Local nVALORC     := aScan(aHeader,{|x| AllTrim(x[2]) == "AI2_VALORC"})
Local nQUANTC     := aScan(aHeader,{|x| AllTrim(x[2]) == "AI2_QUANTC"})
Local nPERCB      := aScan(aHeader,{|x| AllTrim(x[2]) == "AI2_PERCB"})
Local nVALORB     := aScan(aHeader,{|x| AllTrim(x[2]) == "AI2_VALORB"})
Local lGrade      := !Empty(nITEMGR) .And. MaGrade()
Local cProduto	  := M->AI2_CODPRO                  
Local lReferencia := MatGrdPrrf(@cProduto)

If lGrade
	oGrade:MontaGrade(n,cProduto,.T.,,lReferencia)
EndIf

If lReferencia
	aCols[n,nITEMGR] := "01"
	aCols[n,nDESPRO] := oGrade:GetDescProd(cProduto)
	aCols[n,nVALORC] := 0
	aCols[n,nQUANTC] := 0
	aCols[n,nPERCB]  := 0
	aCols[n,nVALORB] := 0
ElseIf (lRet := ExistCpo("SB1",M->AI2_CODPRO))
	aCols[n,nDESPRO] := Posicione("SB1",1,xFilial("SB1")+M->AI2_CODPRO,"B1_DESC")
	If !Empty(nITEMGR)
		aCols[n,nITEMGR] := CriaVar("AI2_ITEMGR")
	EndIf
EndIf

RestArea(aArea)
Return lRet      

/*


ͻ
Programa  Ft180GrQtdAutor  Andre Anjos		  Data   10/11/09   
͹
Descricao  Funcao para exibicao da grade na digitacao dos campos.	  
͹
Uso        FATA180                                                    
ͼ


*/
Function Ft180GrQtd()
Local aArea   	:= GetArea()
Local lRet    	:= .T.
Local lGrade  	:= MaGrade()
Local nCODPRO 	:= aScan(aHeader,{|x| AllTrim(x[2]) == "AI2_CODPRO"})
Local nVALORC 	:= aScan(aHeader,{|x| AllTrim(x[2]) == "AI2_VALORC"})
Local nQUANTC 	:= aScan(aHeader,{|x| AllTrim(x[2]) == "AI2_QUANTC"})
Local nPERCB  	:= aScan(aHeader,{|x| AllTrim(x[2]) == "AI2_PERCB"})
Local nVALORB 	:= aScan(aHeader,{|x| AllTrim(x[2]) == "AI2_VALORB"})
Local cCampo  	:= ReadVar()
Local nValDig 	:= &(cCampo)
Local cProduto 	:= aCols[n,nCODPRO]                          

If lGrade .And. MatGrdPrrf(@cProduto)
	oGrade:cProdRef := cProduto
	oGrade:lShowGrd := .T.
	oGrade:nPosLinO := n
	INCLUI := IIF(lCopiaGRD,.T.,INCLUI)
	Do Case
		Case "AI2_VALORC" $ cCampo 
		oGrade:Show("AI2_VALORC")
		oGrade:ZeraGrade("AI2_QUANTC")
		&(ReadVar()) := oGrade:SomaGrade("AI2_VALORC",n)
		IF &(ReadVar()) == 0
			aCols[n,nVALORC] :=	 0
		EndIf
		Case "AI2_QUANTC" $ cCampo 
		oGrade:Show("AI2_QUANTC")
		oGrade:ZeraGrade("AI2_VALORC")
		&(ReadVar()) := oGrade:SomaGrade("AI2_QUANTC",n)
		IF &(ReadVar()) == 0
			aCols[n,nQUANTC] :=	 0			  	
		EndIf
		Case "AI2_PERCB" $ cCampo 
		oGrade:Show("AI2_PERCB")
		oGrade:ZeraGrade("AI2_VALORB")
		&(ReadVar()) := oGrade:SomaGrade("AI2_PERCB",n)
		IF &(ReadVar()) == 0
			aCols[n,nPERCB] :=	 0			  	
		EndIf
		Case "AI2_VALORB" $ cCampo 
		oGrade:Show("AI2_VALORB")
		oGrade:ZeraGrade("AI2_PERCB")
		&(ReadVar()) := oGrade:SomaGrade("AI2_VALORB",n)
		IF &(ReadVar()) == 0
			aCols[n,nVALORB] :=	 0			  	
		EndIf
	EndCase		
	INCLUI := IIF(lCopiaGRD,.F.,INCLUI)
	oGrade:lShowMsgDiff := .F.
	aCols[n,nVALORC] := oGrade:SomaGrade("AI2_VALORC",oGrade:nPosLinO)
	aCols[n,nQUANTC] := oGrade:SomaGrade("AI2_QUANTC",oGrade:nPosLinO)
	aCols[n,nPERCB]  := oGrade:SomaGrade("AI2_PERCB",oGrade:nPosLinO)
	aCols[n,nVALORB] := oGrade:SomaGrade("AI2_VALORB",oGrade:nPosLinO) 
	oGrade:lShowMsgDiff := .T.
EndIf
RestArea(aArea)
Return lRet

/*


ͻ
Programa  Ft180VlCGrAutor  Andre Anjos          Data   13/11/09   
͹
Descricao  Valida campos da tela da grade.                            
͹
Uso        FATA180                                                    
ͼ


*/
Function Ft180VlCGr()
Local lRet    := .T.
Local nColuna := aScan(aHeader,{|x| AllTrim(x[2]) == AllTrim(Substr(Readvar(),4))})

//Ŀ
// Para os campos AI2_PERCB e AI2_VALORB 	 |
//| valida se AI2_VALORC ou AI2_QUANTC estao |
//| preenchidos                              |
//	
If oGrade:cCpo $ "AI2_PERCB*AI2_VALORB"
	If !Empty(&(ReadVar())) .And. Empty(oGrade:aColsFieldByName("AI2_VALORC",oGrade:nPosLinO,n,nColuna) + ;
	oGrade:aColsFieldByName("AI2_QUANTC",oGrade:nPosLinO,n,nColuna))
		Aviso(STR0029,STR0030 +RetTitle("AI2_VALORC") +STR0031 +RetTitle("AI2_QUANTC") +STR0032,{"Ok"})//Ateno, Este item no possui ### ou ### preenchido.
		lRet := .F.
	EndIf
EndIf

If lRet
	Do Case
		Case oGrade:cCpo == "AI2_VALORC" .And. Empty(&(ReadVar()))
		oGrade:aColsGrade[oGrade:nPosLinO,n,nColuna,oGrade:GetFieldGrdPos("AI2_PERCB")] := 0
		oGrade:aColsGrade[oGrade:nPosLinO,n,nColuna,oGrade:GetFieldGrdPos("AI2_VALORB")] := 0
		Case oGrade:cCpo == "AI2_QUANTC" .And. Empty(&(ReadVar()))
		oGrade:aColsGrade[oGrade:nPosLinO,n,nColuna,oGrade:GetFieldGrdPos("AI2_PERCB")] := 0
		oGrade:aColsGrade[oGrade:nPosLinO,n,nColuna,oGrade:GetFieldGrdPos("AI2_VALORB")] := 0
		Case oGrade:cCpo == "AI2_PERCB" .And. Empty(&(ReadVar()))
		oGrade:aColsGrade[oGrade:nPosLinO,n,nColuna,oGrade:GetFieldGrdPos("AI2_VALORC")] := 0
		oGrade:aColsGrade[oGrade:nPosLinO,n,nColuna,oGrade:GetFieldGrdPos("AI2_QUANTC")] := 0
		Case oGrade:cCpo == "AI2_VALORB" .And. Empty(&(ReadVar()))
		oGrade:aColsGrade[oGrade:nPosLinO,n,nColuna,oGrade:GetFieldGrdPos("AI2_VALORC")] := 0
		oGrade:aColsGrade[oGrade:nPosLinO,n,nColuna,oGrade:GetFieldGrdPos("AI2_QUANTC")] := 0
	EndCase
EndIf
Return lRet


//-----------------------------------------------------------------------------
/*/{Protheus.doc} FATPDLogUser
    @description
    Realiza o log dos dados acessados, de acordo com as informaes enviadas, 
    quando a regra de auditoria de rotinas com campos sensveis ou pessoais estiver habilitada
	Remover essa funo quando no houver releases menor que 12.1.27

   @type  Function
    @sample FATPDLogUser(cFunction, nOpc)
    @author Squad CRM & Faturamento
    @since 06/01/2020
    @version P12
    @param cFunction, Caracter, Rotina que ser utilizada no log das tabelas
    @param nOpc, Numerico, Opo atribuda a funo em execuo - Default=0

    @return lRet, Logico, Retorna se o log dos dados foi executado. 
    Caso o log esteja desligado ou a melhoria no esteja aplicada, tambm retorna falso.

/*/
//-----------------------------------------------------------------------------
Static Function FATPDLogUser(cFunction, nOpc)

	Local lRet := .F.

	If FATPDActive()
		lRet := FTPDLogUser(cFunction, nOpc)
	EndIf 

Return lRet  

//-----------------------------------------------------------------------------
/*/{Protheus.doc} FATPDActive
    @description
    Funo que verifica se a melhoria de Dados Protegidos existe.

    @type  Function
    @sample FATPDActive()
    @author Squad CRM & Faturamento
    @since 17/12/2019
    @version P12    
    @return lRet, Logico, Indica se o sistema trabalha com Dados Protegidos
/*/
//-----------------------------------------------------------------------------
Static Function FATPDActive()

    Static _lFTPDActive := Nil
  
    If _lFTPDActive == Nil
        _lFTPDActive := ( GetRpoRelease() >= "12.1.027" .Or. !Empty(GetApoInfo("FATCRMPD.PRW")) )  
    Endif

Return _lFTPDActive    
