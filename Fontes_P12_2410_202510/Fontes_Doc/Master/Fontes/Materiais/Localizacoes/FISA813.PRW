#INCLUDE 'PROTHEUS.CH'
#INCLUDE 'FISA813.CH'

#define Confirma 1
#define Redigita 2
#define Abandona 3

/* 


Ŀ
Funo     FISA813   Autor  Luis Samaniego         Data  12/05/17 
Ĵ
Descrio  Mantenimiento de Catalogos                                 
Ĵ
Sintaxe    FISA813()                                                  
Ĵ
 Uso       Generico ( DOS e Windows )                                 
Ĵ
         ATUALIZACOES SOFRIDAS DESDE A CONSTRUAO INICIAL.             
Ĵ
Programador  Data      BOPS       Motivo da Alteracao               
Ĵ
Alf. Medrano04/12/2019DMINA-5912Se agrega fun fis813CBol se ejecuta 
                                en Menudef para obt. Cat.SIN  (BOL) 
ARodriguez  19/08/2021DMINA-    f813Alt() checa primer registro del 
                           12690catlogo para determinar contenido  
                                en vez de leer todo el catlogo.    
ٱ


*/
Function FISA813()
Local aArea     := GetArea()
Local aAreaF3H  := F3H->(GetArea())
Local aAreaF3I  := F3I->(GetArea())

Private cCodigo    := CriaVar("F3H_CODIGO")
Private cDescri    := CriaVar("F3H_DESC")
Private aIndexF3H  := {} //Variavel Para Filtro
Private oBar, oBtOk, oBtCan
Private oBtnCop, oBtnPas, oBtnCalc, oBtnHlp, oBtnPrn, oBtnAplica, oBtnDupl, oBtnReaj, oBtnAg, oBtnPesq, oBtOrder, oBtnImp
Private nP := 0
Private aButtons   := {}
Private lF813Inc   := .F.
Private cAuxSeq    := ""
Private aRotina    := MenuDef() // ajuste para versao 9.12 - chamada da funcao MenuDef() que contem aRotina
Private cCadastro  := OemToAnsi(STR0001) //'Cadastro de Tabelas'
Private bFiltraBrw := {|| Nil}		//Variavel para Filtro

	If F812ModComp("F3H")

		FISA814()

		dbSelectArea("F3H")
		dbGotop()
		cFiltraF3H	:=	'F3H_ORDEM == "01"'

		bFiltraBrw 	:= {|| FilBrowse("F3H",@aIndexF3H,@cFiltraF3H) }
		Eval(bFiltraBrw)

		mBrowse(06,01,22,75,'F3H',, , , , , fUseCor(), , , ,)

		EndFilBrw("F3H",aIndexF3H)
	Endif
	/*
	Ŀ
	Restaura Area e Ordem de Entrada                              
	*/
	RestArea( aArea )
	RestArea( aAreaF3I)
	RestArea( aAreaF3H)

Return Nil

/*/


Ŀ
Funo     f813Alt   Autor  R.H - Natie            Data  13/06/02 
Ĵ
Descrio  Alteracao de Estrutura do Parametro                        
Ĵ
Sintaxe    ExpN1 := AxAltera(ExpC1,ExpN2,ExpN3,ExpA1,ExpA2)           
Ĵ
Parametros ExpN1 = Opcao devolvida pela funcao                        
           ExpC1 = Alias do arquivo                                   
           ExpN2 = Numero do registro                                 
           ExpN3 = Numero da opcao selecionada                        
           ExpA1 = Array contendo campos a serem mostrados            
           ExpA2 = Array limitando campos a serem aceitos com Get     
Ĵ
 Uso       Generico                                                   
ٱ

*/
Function f813Alt(cAlias,nReg,nOpcx)
Local aArea         := GetArea()
Local aKeys         := GetKeys()
Local nOpca         := 0
Local nCnt          := 0
Local aAreaF3I      := F3I->( GetArea() )
Local aAreaF3H      := F3H->( GetArea() )
Local a813nField	  := {}
Local aColsRec	  := {}
Local aColsAnt	  := {}
Local cCond		  := "", cChave:= ""
Local oFont
Local oDlgMain
//-- Variaveis dimensoes do objeto tela
Local aAdvSize     := {}
Local aInfoAdvSize := {}
Local aObjSize     := {}
Local aObjCoords   := {}
Local bSet15       := {|| NIL}
Local bSet24       := {|| NIL}

Private nOpcao     := nOpcx
Private oGeT
Private oCodigo, oDescri, oFil, oChave
Private oGroup1, oGroup2
Private oFont1, oFont2
Private aVisual
Private aAntes
Private aColsBkp
Private nBkp

	nBkp     := 0
	aHeader  := {}
	aColsBkp := {}
	aVisual  := {}
	aAntes   := {}
	aColsBkp := {}
	/*
	Ŀ
	 Monta as Dimensoes dos Objetos         					   
	*/
	aAdvSize		:= MsAdvSize()
	aInfoAdvSize	:= { aAdvSize[1] , aAdvSize[2] , aAdvSize[3] , aAdvSize[4] , 3 , 3 }
	aAdd( aObjCoords , { 000 , 020 , .T. , .F. } )
	aAdd( aObjCoords , { 000 , 000 , .T. , .T. } )
	aObjSize		:= MsObjSize( aInfoAdvSize , aObjCoords )
	cCodigo		:= F3H->F3H_CODIGO
	cDescri		:= F3H->F3H_DESC

	//-- Verifica a existencia da estrutura do parametro
	DbSelectArea(cAlias)
	dbSeek( xFilial(cAlias) )
	If (eof() .and. bof())
		Help(" ",1,"A320SPAR")
		Return
	Endif

	//Ŀ
	// Deleta o filtro utilizando a funcao FilBrowse                          
	//
	EndFilBrw("F3H",aIndexF3H)
	aIndexF3H := {}
	cAlias := "F3I"
	cFilF3I := xFilial(cAlias)

	Do while .T.
		//Ŀ
		// Campos Nao editaveis no aCols                                          
		//
		a813nField	:= {"F3I_FILIAL","F3I_CODIGO","F3I_CONTEU"}

		//Ŀ
		// Verifica existencia de registro qdo for alteracao            
		//
		dbSelectArea(cAlias)
		dbSetOrder(1)
		dbSeek( cFilF3I + cCodigo )
		If !eof() .and. cFilF3I + cCodigo = F3I->F3I_FILIAL+F3I->F3I_CODIGO
			nCnt++
		EndIf

	    If nCnt > 0 .And. nOpcx == 3 //--Quando Inclusao e existir Registro
	    	If lF813Inc
				lF813Inc := .F.
				Exit
			EndIf
			Help(" ",1,"A310REG")
			Exit
		ElseIf nCnt == 0 .And. nOpcx # 3 //--Quando Nao for Inclusao e nao existir Registro
			Aviso(STR0014,STR0026,{'OK'}) //"Atencao"###"Nao existem registros cadastrados para esta tabela. Utilize a opcao 'Incluir'."
			Exit
		Endif

		//Ŀ
		// Monta a entrada de dados do arquivo                          
		//
		cCond	:= "F3I_FILIAL + F3I_CODIGO"
		cChave	:= cFilF3I + cCodigo

		aHeader	:= f813aHead(a813nField,cAlias) // Array contendo header
		If Empty(aHeader)
			Exit
		EndIf
		aCols	:= f813aCols(a813nField,cAlias,cCond,cChave,nOpcx,@aColsRec,@aColsAnt) // Array contendo aCols

		IF nOpcx==3 .and. (Type("N") != "U")
			n := 1
		EndIF

		DEFINE FONT oFont  NAME "Arial" SIZE 0,-11 BOLD
		SetaPilha()

		DEFINE MSDIALOG oDlgMain TITLE OemToAnsi( cCadastro ) FROM aAdvSize[7],0 TO aAdvSize[6],aAdvSize[5] OF oMainWnd PIXEL

			@ aObjSize[1,1] , aObjSize[1,2] GROUP oGroup1 TO aObjSize[1,3] ,aObjSize[1,4]*0.20 LABEL OemToAnsi(STR0011) OF oDlgMain PIXEL // "Codigo da Tabela:"
			oGroup1:oFont:= oFont
			@ aObjSize[1,1] , aObjSize[1,4]*0.21 GROUP oGroup2 TO aObjSize[1,3] ,aObjSize[1,4] LABEL OemToAnsi(STR0012) OF oDlgMain PIXEL // "Descricao"
			oGroup2:oFont:= oFont
			@ aObjSize[1,1]+10 , aObjSize[1,2]+10 SAY cCodigo SIZE 050,10 OF oDlgMain PIXEL FONT oFont
		 	@ aObjSize[1,1]+10 , aObjSize[1,4]*0.21+10 SAY cDescri SIZE 120,10 OF oDlgMain PIXEL FONT oFont
			oGet := MSGetDados():New(aObjSize[2,1],aObjSize[2,2],aObjSize[2,3],aObjSize[2,4], nOpcx,"f813LinOk","f813tudOk",,If(nOpcx=2 .Or. nOpcx=5,Nil,.T.),,,,999999)
			oGet:lf3Header := .T. //Habilita o uso da Consulta F3 na GetDados
		 	bSet15 := { || nOpca := 1, If(f813tudOk(oGet),oDlgMain:End(),nOpca:=0)}
			bSet24 := { || 	RestKeys(aKeys,.T.), oDlgMain:End()}
			FchoBar813(oDlgMain,,,nOpcx)

		ACTIVATE MSDIALOG oDlgMain ON INIT EnchoiceBar(oDlgMain, bSet15, bSet24, NIL, aButtons) CENTERED
		SetaPilha()

		IF nOpcA == Redigita
			Return
		ELSEIF nOpcA == Confirma .And. nOpcx # 2
			Begin Transaction
				//--Gravacao
				f813Grava(cAlias,nOpcx,if(nOpcx = 4,aColsRec,""),if(nOpcx = 4,aColsAnt,""))
				//--Processa Gatilhos
				EvalTrigger()
			End Transaction
		Endif
		Exit
	Enddo

//Ŀ
// Restaura o filtro F3H utilizando a funcao FilBrowse                    
//
Eval(bFiltraBrw)
/*
Ŀ
Restaura Area e Ordem de Entrada                              
*/
RestArea( aArea )
RestArea( aAreaF3I)
RestArea( aAreaF3H)
RestKeys(aKeys,.T.)

Return(Nil)

/*

Ŀ
Funo    f813Exc    Autor  R.H. -  Natie          Data  23/05/02 
Ĵ
Descrio  Exclusao                                                   
Ĵ
Sintaxe    f813Exc(cAlias,nReg,nOpca)                                 
Ĵ
Parametros cAlias= Alias do arquivo                                   
           nREg  = Numero do registro                                 
           nOpca = Numero da opcao selecionada                        
Ĵ
Uso        Genrico                                                   
ٱ

*/
Function f813Exc(cAlias,nReg,nOpcx,aAcho,aCpos,nColMens,cMensagem,cTudoOk)
//-- Cria variaveis
Local aKeys       := GetKeys()
Local nOpca       := 0
Local aArea       := GetArea()
Local aAreaF3I    := F3I->( GetArea() )
Local aAreaF3H    := F3H->( GetArea() )
Local a813nField	:= {}
Local aColsRec	:= {} //--Array que contem o Recno() dos registros da aCols
Local aColsAnt	:= {}
Local cCond		:= "", cChave:= ""
Local oFont
Local oDlgMain
//-- Variaveis dimensoes do objeto tela
Local aAdvSize      := {}
Local aInfoAdvSize  := {}
Local aObjSize      := {}
Local aObjCoords    := {}

Private cCodigo     := CriaVar("F3H_CODIGO")
Private cDescri     := CriaVar("F3H_DESC")
Private nOpcao      := nOpcx
Private oGet
Private oCodigo
Private oDescri
Private oFil
Private oChave
Private oGroup1
Private oGroup2

	/*
	Ŀ
	 Monta as Dimensoes dos Objetos         					   
	*/
	aAdvSize		:= MsAdvSize()
	aInfoAdvSize	:= { aAdvSize[1] , aAdvSize[2] , aAdvSize[3] , aAdvSize[4] , 3 , 3 }
	aAdd( aObjCoords , { 000 , 020 , .T. , .F. } )
	aAdd( aObjCoords , { 000 , 000 , .T. , .T. } )
	aObjSize		:= MsObjSize( aInfoAdvSize , aObjCoords )

	//Ŀ
	// Campos Nao editaveis                                                   
	//
	a813nField := {"F3I_FILIAL","F3I_CODIGO","F3I_CONTEU"}
	cFilF3H    := F3H->F3H_FILIAL
	cCodigo    := F3H->F3H_CODIGO
	cDescri    := F3H->F3H_DESC

	//Ŀ
	// Nao permite exclusao de Parametro  padrao do Sistema                   
	//
	If !fChkUser()
		/*
		Ŀ
		 Se for um Parametro Definido Pela Microsiga Altera a Opcao 
		 para Visualizacao											 
		*/
		MsgInfo( oEmToAnsi(STR0015) + CRLF + oEmToAnsi(STR0014) )
		nOpcx := 2
		Return
	Endif

	cAlias		:= "F3I"
	DbSelectArea(cAlias)
	dbSetOrder(1)
	dbSeek( xFilial(cAlias)+ cCodigo )
	If F3I->( eof() )
		Help(" ",1,"A320NPAR") //Nao existe tabela para o parametro solicitado
		Return
	Endif

	//Ŀ
	// Deleta o filtro utilizando a funcao FilBrowse                     	 
	//
	EndFilBrw("F3H",aIndexF3H)
	aIndexF3H := {}

	//Ŀ
	// Monta a entrada de dados do arquivo                          
	//
	cCond	:= "F3I_FILIAL+ F3I_CODIGO"
	cChave	:= xFilial("F3I")+ cCodigo
	aHeader := {}
	aHeader := f813aHead(a813nField,cAlias) // Array contendo cabecalho
	If Empty(aHeader)
		Return
	EndIf
	aCols	:= f813aCols(a813nField,cAlias,cCond,cChave,nOpcx,@aColsRec,@aColsAnt) // Array contendo aCols

	DEFINE FONT oFont  NAME "Arial" SIZE 0,-11 BOLD
	SetaPilha()

		DEFINE MSDIALOG oDlgMain TITLE OemToAnsi( cCadastro ) FROM aAdvSize[7],0 TO aAdvSize[6],aAdvSize[5] OF oMainWnd PIXEL

			@ aObjSize[1,1] , aObjSize[1,2] GROUP oGroup1 TO aObjSize[1,3] ,aObjSize[1,4]*0.20 LABEL OemToAnsi(STR0011) OF oDlgMain PIXEL // "Codigo da Tabela:"
			oGroup1:oFont:= oFont
			@ aObjSize[1,1] , aObjSize[1,4]*0.21 GROUP oGroup2 TO aObjSize[1,3],aObjSize[1,4] LABEL OemToAnsi(STR0012) OF oDlgMain PIXEL // "Descricao"
			oGroup2:oFont:= oFont
			@ aObjSize[1,1]+10 , aObjSize[1,2]+10 SAY cCodigo SIZE 050,10 OF oDlgMain PIXEL FONT oFont
		 	@ aObjSize[1,1]+10 , aObjSize[1,4]*0.21+10 SAY cDescri SIZE 120,10 OF oDlgMain PIXEL FONT oFont
			oGet := MSGetDados():New(aObjSize[2,1],aObjSize[2,2],aObjSize[2,3],aObjSize[2,4],nOpcx,"",,,,,,,999999)
			bSet15 := { || nOpca := 1,RestKeys(aKeys,.T.),oDlgMain:End(),.F.}
			bSet24 := { || RestKeys(aKeys,.T.), oDlgMain:End()}
			FchoBar813(oDlgMain,,,nOpcx)

		ACTIVATE MSDIALOG oDlgMain ON INIT EnchoiceBar(oDlgMain, bSet15, bSet24, NIL, aButtons) CENTERED
		SetaPilha()

	If nOpcA == Confirma  .and. nOpcx = 5 //-- Confirma Exclusao
		Begin Transaction
		// Exclusao na F3I
			dbSelectArea( "F3H" )
			dbSetOrder(1)
			If dbSeek( cFilF3H + cCodigo )
				While cFilF3H + cCodigo == F3H->F3H_FILIAL+F3H->F3H_CODIGO .And. !Eof()
					RecLock("F3H",.F.,.T.)
					F3H->(dbDelete())
					MsUnlock()
					F3H->(DbSkip())
				EndDo
			EndIf
		// Exclusao na F3I
			dbSelectArea( "F3I" )
			dbSetOrder(1)
			If dbSeek( cFilF3H + cCodigo )
				While cFilF3H + cCodigo == F3I->F3I_FILIAL+F3I->F3I_CODIGO .And. !Eof()
					RecLock("F3I",.F.,.T.)
					F3I->(dbDelete())
					MsUnlock()
					F3I->(DbSkip())
				EndDo
			EndIf
		End Transaction
	Endif

//Ŀ
// Restaura o filtro F3H utilizando a funcao FilBrowse                    
//
Eval(bFiltraBrw)
/*
Ŀ
Restaura Area e Ordem de Entrada                              
*/
RestArea( aArea )
RestArea( aAreaF3I)
RestArea( aAreaF3H)

Return(Nil)


/*

Ŀ
Funo    f813Grava  Autor  Natie                  Data  27/06/02 
Ĵ
Descrio  Grava no arquivo de Parametros                             
Ĵ
 Uso       f813Grava                                                  
ٱ

/*/
Function f813Grava(cAlias,nOpcx,aColsRec,aColsAnt)
Local nPosSeq   := GdFieldPos("F3I_SEQUEN")
Local nMaxArray := Len(aHeader)
Local nTamSeq   := TamSX3( "F3I_SEQUEN")[1]
Local nSeq      := 0
Local xConteudo := ""
Local nX 		  := 0
Local nY 		  := 0
Local nTamAnt	  := Len(aColsAnt)
Local nCntDel   := 0
Local lTudoIgual

	nUsado := Len(aHeader)

	dbSelectArea(cAlias)
	If len(aColsRec) <> 0
		For nX	:=	1 to Len(aCols)
			lTudoIgual := .T.
			If nX <= nTamAnt
				For nY := 1 To Len(aHeader)
					If aCols[nX,nY] # aColsAnt[nX,nY]
						lTudoIgual := .F.
						Exit
					Endif
				Next nY
			Else
				lTudoIgual := .F.
			EndIf
			If lTudoIgual .And. aCols[nX,nUsado+1] = .F.
				Loop
			Endif
			If aScanX( aColsRec, { |X,Y|  y == nX}) != 0
				dbgoto(aColsRec[nX])
				RecLock(cAlias,.F.)
			Else
				RecLock(cAlias,.T.)
			Endif
			If aCols[nX,nUsado+1] = .T.
				nCntDel ++
				dbDelete( )
			Else
				F3I->F3I_FILIAL   := xFilial(cAlias)
				F3I->F3I_CODIGO   := cCodigo
				F3I->F3I_SEQUEN   := aCols[nX,nPosSeq]
				//-- Grava  os Campos definidos no F3H no campo F3I_CONTEU
				For ny := 2 To nMaxArray
					cCampo    := Trim(aHeader[nY][2])
					If a813Transf(aCols[nX,nY],aHeader[nY][8],aHeader[nY][4],aHeader[nY][5]) == "  /  /    "
						xConteudo += Space(8)
					Else
						xConteudo += a813Transf(aCols[nX,nY],aHeader[nY][8],aHeader[nY][4],aHeader[nY][5])
					EndIf
				Next ny
				//-Nao permite alterar a Descricao dos Fornecedores 001 a 004, da tabela S018
				F3I->F3I_CONTEU := xConteudo
				//-- Reinicia variavel
				xConteudo	:= ""
				F3I->(MsUnlock())
			EndIf
		Next nX
	Else
		f813Grinc( cAlias ,1 )
	Endif

	If nCntDel > 0
		//Reordena sequencia da tabela atualizada.
		Begin Transaction
			dbSelectArea( cAlias )
			dbSetOrder(1)
			If dbSeek( xFilial(cAlias) + cCodigo )
				While xFilial(cAlias) + cCodigo == F3I->F3I_FILIAL+F3I->F3I_CODIGO .And. !Eof()
		 		    RecLock(cAlias,.F.)
				    nSeq ++
				    Replace F3I->F3I_SEQUEN With StrZero(nSeq,nTamSeq)
					MsUnlock()
					DbSkip()
				EndDo
			EndIf
		End Transaction
	Endif

Return

/*

Ŀ
Funo    a813Transf Autor  Natie                  Data  27/06/02 
Ĵ
Descrio                                                             
Ĵ
 Uso       a813Transf                                                 
ٱ

/*/
Static Function a813Transf(xCampo,cTipo,nTam,nDecima)

	If cTipo = "C"
		cCampo := Upper(xCampo)
	ElseIf cTipo = "N"
		cCampo := Str(xCampo,nTam,nDecima)
	ElseIf cTipo = "D"
		cCampo := If( empty(xcampo) , DTOC(xCampo), DTOS(xCampo) )
	Endif

Return (cCampo)

/*


ͻ
Programa  f813aHead Autor  Ricardo              Data   17/05/01   
͹
Desc.      Funcao f813aHead() - Monta o array de header - SRB         
                                                                      
͹
Uso        AP6                                                        
ͼ


*/
Static Function f813aHead(aFields,cAlias)
Local aArea     := GetArea()
Local aExclF3I  := {'F3I_FILIAL','F3I_CODIGO','F3I_CONTEU'}
Local aSX3      :={}
Local _i        := 0
Local cX3_NIVEL 
Local cX3_USADO

Private aHeader := {}, nUsado := 0

	//Ŀ
	// Monta array dos campos do arquivo de pesquisa.							
	//

	aSX3 := FWSX3Util():GetAllFields(cAlias , .T.)
	for _i := 1 to len(aSX3)
		If !(aSX3[_i] $ "F3I_CHAVE|F3I_FIL") .and. ASCAN(aExclF3I,{ |x| x == Trim(aSX3[_i]) } ) == 0
			cX3_NIVEL := GetSx3Cache(aSX3[_i], "X3_NIVEL")
			cX3_USADO := GetSx3Cache(aSX3[_i], "X3_USADO")
			if cNivel >= cX3_NIVEL .And. X3Uso(cX3_USADO)
				nUsado ++
				Aadd(aHeader,{TRIM(fwx3Titulo(aSX3[_i])),;
  							 aSX3[_i],;
							 GetSx3Cache(aSX3[_i], "X3_PICTURE"),;
							 GetSx3Cache(aSX3[_i], "X3_TAMANHO"),;
							 GetSx3Cache(aSX3[_i], "X3_DECIMAL"),;
							 GetSx3Cache(aSX3[_i], "X3_VALID"),;
							 cX3_USADO,;
							 GetSx3Cache(aSX3[_i], "X3_TIPO"),;
							 GetSx3Cache(aSX3[_i], "X3_F3"),;
							 GetSx3Cache(aSX3[_i], "X3_CONTEXT"),;
						 	})

			EndIf
		EndIf
	next _i 

	dbSelectArea("F3H")
	dbSetOrder(1)
	If !dbSeek(xFilial(cAlias) + cCodigo,.F.)
		MsgAlert(OemToAnsi(STR0089), OemToAnsi(STR0083)) //-"Nao existe esta tabela para a Empresa/Un.Negocio/Filial selecionada !"###"Ateno"
		aHeader := {}
	EndIf
	Do While !Eof() .and. xFilial("F3H")+ cCodigo  = (F3H->F3H_FILIAL + F3H->F3H_CODIGO)
			nUsado ++
			Aadd(aHeader,{  Trim(F3H_DESCPO),F3H_CAMPOS ,F3H_PICTUR,;
								F3H_TAMAN, F3H_DECIMA, F3H_VALID,;
								'X', F3H_TIPO, F3H_PADRAO, ' '} )
		dbSkip()
	EndDo
/*
Ŀ
Restaura Area e Ordem de Entrada                              
*/
RestArea( aArea )

Return aHeader

/*


Ŀ
Funo    f813aCols  Autor  Natie                  Data  21/06/02 
Ĵ
Descrio Criar os Arrays do aCols dos arquivos                       
Ĵ
 Uso      FISA813                                                     
ٱ

*/
Static Function f813aCols(aFields,cAlias,cCond,cChave,nOpcx,aColsRec,aColsAnt)
Local nCntFor  := 0
Local nAcols   := 0
Local nTamCpo  := 0
Local nPosicao := 0
Local aArea    := GetArea()
Local aConteu  := {"F3I_FILIAL","F3I_CODIGO","F3I_SEQUEN"} //--Array com  os cpos q estao fora do Conteudo
Local nTamSeq   := TamSX3( "F3I_SEQUEN")[1]

Local aSX3      :={}
Local _i        := 0
Local cX3_NIVEL 
Local cX3_USADO
Local cX3_TIPO
Local cX3_TAMANHO

Private nUsado := Len(aheader)
Private aCols  :={}

	//--Quando for Inclusao criar com 1 elemento
	If nOpcx = 3 //Inclusao
		nCnt := 1
		aCols := Array( nCnt , nUsado+1 )
	Endif

	dbSelectArea(cAlias)

	If dbSeek(cCHAVE) .and. nOpcx # 3
		While !Eof() .And. &cCond == cChave
			aadd(aCols,Array(nUsado+If(nOpcx#1,1,0)))
			nAcols 		:= Len(aCols)
			nPosicao	:= 1
			cConteu	:= FieldGet(FieldPos( "F3I_CONTEU" ) )
			For nCntFor := 1 To Len(aHeader)
				nTamCpo	:= aHeader[nCntFor][4] //-- Tamanho do Campo
				cCampo  := Trim(aHeader[nCntFor][2])
				If	ASCAN(aConteu,{ |x| x == cCampo } ) > 0
					aCols[nAcols][nCntFor] := FieldGet(FieldPos(aHeader[nCntFor][2]))
				Else
					//-- Carrega o conteudo do F3I_CONTEU na aCols
					If aHeader[nCntFor,8] = "C" // tipo Caracter
						aCols[nAcols][nCntFor] := Substr(cConteu,nPosicao,nTamCpo)
					ElseIf  aHeader[nCntFor,8] = "N" // tipo Numerico
						aCols[nAcols][nCntFor] := VAL( Substr(cConteu,nPosicao,nTamCpo) )
					ElseIf aHeader[nCntFor,8] = "D" // tipo Data
						aCols[nAcols][nCntFor] := Stod(Substr(cConteu,nPosicao,nTamCpo) )
					Endif
					nPosicao += nTamCpo
				Endif
			Next nCntFor
			If nOpcx # 1
				aCols[nAcols][nUsado+1] := .F.
			EndIf
			dbSelectArea(cAlias)
			Aadd(aColsRec,Recno())
			dbSkip()
		EndDo

	ElseIf nOpcx = 3
		//Ŀ
		// Posiciona ponteiro do arquivo cabeca e inicializa variaveis  
		//
		nUsado:=0
		
		aSX3 := FWSX3Util():GetAllFields(cAlias , .T.)
		for _i := 1 to len(aSX3)
			If ASCAN(aFields,{ |x| x == Trim(aSX3[_i]) } ) == 0
				cX3_NIVEL := GetSx3Cache(aSX3[_i], "X3_NIVEL")
				cX3_USADO := GetSx3Cache(aSX3[_i], "X3_USADO")
				if cNivel >= cX3_NIVEL .And. X3Uso(cX3_USADO)
					cX3_TIPO := GetSx3Cache(aSX3[_i], "X3_TIPO")
					cX3_TAMANHO := GetSx3Cache(aSX3[_i], "X3_TAMANHO")
					nUsado ++
					IF cX3_TIPO == "C"
						aCOLS[1][nUsado] := SPACE(cX3_TAMANHO)
					ELSEIF cX3_TIPO == "N"
						aCOLS[1][nUsado] := 0
					ELSEIF cX3_TIPO == "D"
						aCOLS[1][nUsado] := CTOD("  /  /  ")
					Endif
				EndIf
			EndIf
		next _i 

		dbSelectArea("F3H")
		dbSetOrder(1)
		dbSeek( cChave)
		While !EOF() .and.  cChave = xFilial("F3H") + F3H->F3H_CODIGO
		    nUsado ++
			//Ŀ
			// Monta Array do 1 Elemento Vazio utilizando F3H              
			//
			If F3H_TIPO = "C"
				aCOLS[1][nUsado] := SPACE(F3H_TAMAN)
			ElseIf F3H_TIPO = "N"
				aCOLS[1][nUsado] := 0
			ElseIf F3H_TIPO = "D"
				aCOLS[1][nUsado] := CTOD("  /  /  ")
			ELSE
				aCOLS[1][nUsado] := .F.
			Endif
			F3H->( dbSkip() )
		Enddo
		aCOLS[1,nUsado+1] := .F.
	Endif

	aCols[1][GdFieldPos("F3I_SEQUEN")] := Strzero(Val('01'), nTamSeq) //-- Inicia Ordem com 1

	// Copia o vetor aCols
	If nOpcx == 4
		aColsAnt := Aclone(aCols)
	EndIf

	aColsBkp := Aclone(aCols)
	nBkp     := Len(aColsBkp)
	/*Ŀ
	  Restaura Area e Ordem de Entrada                              
	  */
	RestArea(aArea)

Return aCols

/*/


Ŀ
Funo    f813LinOk Autor   Natie                  Data  01/07/02 
Ĵ
Descrio Critica linha digitada                                      
Ĵ
 Uso       Generico                                                   
ٱ

/*/
Function f813LinOk(o)
Local lTudoOk   := .T.
Local nX        := 0
Local nPosSeq   := GdFieldPos("F3I_SEQUEN")
Local nUsado    := Len(aHeader)
Local nUsaCols  := 0
Local cChaveGet := ""
Local aCopyCols := aClone(aCols)
Local lEmpty    := .T.

	nUsaCols  := Len(aCols)
	//-- Salva Chave atual
	cChaveGet	:= cFilF3I+ cCodigo + aCopyCols[n,nPosSeq]
	If !Empty(aCopyCols[n,nPosSeq])
		cAuxSeq := aCopyCols[n,nPosSeq]
	EndIf
	//--Verifica se tem alguma coluna preenchida alem da chave
	For nX := 1 to len(aCopyCols[n])
	    If nX == nPosSeq .or. (nX ==(nUsado+1) .and. aCopyCols[n,nX]==.F.)
	    	Loop
	    EndIf
	    lEmpty := Empty(aCopyCols[n,nX])
	    If !lEmpty
	    	exit
	    EndIf
	Next

	If lEmpty
		Aviso(STR0014,STR0027,{'OK'}) //"Atencao" ##"Preencha os dados da tabela."
		lTudoOk := .F.
	Else
		If aCopyCols[n,nUsado+1]  = .F.
			//Ŀ
			// Muda a Sequencia da Tabela de acordo com  a chave            
			//
			fPlusSeq813(@aCopyCols,cChaveGet,nUsado)
			F3H->(DbSetOrder(1))
			F3H->(DbSeek(xFilial("F3H")+cCodigo))
			While F3H->F3H_CODIGO == cCodigo .and. lTudoOk
				If !aCopyCols[n,Len(aCopyCols[n])]       //nao  deletado
					If "NAOVAZIO" $ F3H->F3H_VALID
						If Empty(aCopyCols[n,Val(F3H->F3H_ORDEM)+1])
							lTudoOk := .F.
							Aviso(STR0014,STR0087+ Alltrim(F3H->F3H_DESCPO) +STR0088,{"OK"})
						EndIf
					EndIf
				EndIf
				F3H->(DbSkip())
			EndDo
			If Empty(AcopyCols)
				aCols := {}
				Eval(oGet:oBrowse:badd)
			Else
				aCols	:= aClone(aCopyCols)
			Endif
			oGet:oBrowse:nAt 	:= n
			oGet:oBrowse:Refresh(.T.)
		Else
	   	  	fPlusSeq813(@aCopyCols,cChaveGet,nUsado)
			If Empty(AcopyCols)
				aCols := {}
				Eval(oGet:oBrowse:badd)
			Else
				aCols	:= aClone(aCopyCols)
			Endif
			oGet:oBrowse:nAt 	:= n
			oGet:oBrowse:Refresh(.T.)
			fAtualizaBkp2()
		Endif
		oGet:oBrowse:nAt 	:= n
		oGet:oBrowse:Refresh(.T.)
	EndIf

	If lTudoOk == .T.
		lF813Inc := .T.
	Endif

Return lTudoOk

/*


Ŀ
Funcao    f813tudOk   Autor  Natie                 Data  25/06/02 
Ĵ
Descrio  Monta as getdados dos arquivos                             
Ĵ
Parametros ExpC1 : Alias                                              
           ExpN1 : Registro                                           
           ExpN2 : Opcao                                              
Ĵ
 Uso      f813Alt                                                     
ٱ

*/
Function f813tudOk(o)
Local lTudoOk  := .T.

	lTudoOk := f813LinOk()

Return lTudoOk



/*/

Ŀ
Funo    FchoBar813 Autor R.H.-Natie              Data           
Ĵ
Descrio  carrega abuttons, para enchoicebar						    
Ĵ
 Uso       Generico                                                   
ٱ


*/
Function FchoBar813(oDlg,cGrupos,lEnable,nOpcx)
Local bCopy      := { || NIL } //-- Botao Copiar
Local bPaste     := { || NIL } //-- Botao Colar
Local bReOrder   := { || NIL }
Local bDuplic813 := { || Duplic813() }
Local bReaj      := { || Rejusta813() }
Local bAplicar   := { || Aplicar(aCols) }
Local aCopyTab   := {}

DEFAULT lEnable		:= .T.

	aButtons	:= {}
	If nOpcx == 4 .or. nOpcx == 3
		bReOrder := { || fReorder813() }
		aAdd(aButtons, { NIL, { || Eval( bReOrder )  } ,  OemToAnsi(STR0068) } ) // Atualizar
		SetKey( VK_F8 , bReOrder )
	Endif

	IF nOpcx == 4
		aAdd(aButtons, { NIL, { || Eval( bDuplic813 )  } ,  OemToAnsi(STR0034)  } ) //"Duplic813"
		aAdd(aButtons, { NIL, { || Eval( bReaj )  } ,  OemToAnsi(STR0041) } ) //"Rejusta813"
	Endif

	IF ( lEnable ) .AND. (nOpcx == 3 .OR. nOpcx == 4)
		bCopy		:= { || aCopyTab := fCopia813(oGet:oBrowse:nAt) }
		bPaste		:= { || fColar813( aCopyTab , .T.,oGet:oBrowse:nAt,.f.) }
		aAdd(aButtons, { NIL, { || Eval( bCopy )  } ,  OemToAnsi(STR0016)} ) //"Copiar"
		SetKey( VK_F4 , bCopy )
		If Empty(aCopyTab)
			aAdd(aButtons, { NIL, { || Eval( bPaste )  } ,  OemToAnsi(STR0017) } )//"Colar"
			SetKey( VK_F5 , bPaste )
		EndIf
	EndIf

	IF nOpcx == 3
		aAdd(aButtons, { NIL, { || Eval( bAplicar )  } ,  OemToAnsi(STR0044) } ) //"Aplicar"
	Endif

Return Nil

/*/

Ŀ
Funo     fUseCor  | Autor                         Data           
Ĵ
Descrio                                                             
Ĵ
 Uso       FISA813                                                    
ٱ
*/

Static Function fUsecor()
Local aMarks := {}

	aMarks := { { "Substr(F3H->F3H_CODIGO,1,1)=='U'" , "BR_VERDE" } ,;
	            { "Substr(F3H->F3H_CODIGO,1,1)$'S*G'", "BR_AZUL"  } }

Return( aClone( aMarks ) )

/*/

Ŀ
Funo     f813Leg  | Autor                         Data           
Ĵ
Descrio  Legenda de Cores                                           
Ĵ
 Uso                                                                  
ٱ
*/
Function f813Leg()
Local aLegenda	:= {}

	aLegenda := { { "BR_AZUL", OemToAnsi(STR0008) } ,; //"Tabela Definida Pela Microsiga"
	              { "BR_VERDE" , OemToAnsi(STR0009) } } //"Tabela Definida Pelo Usuario"

	BrwLegenda( cCadastro, oEmToAnsi(STR0010), aLegenda ) //Legenda do Cadastro de Paramentros

Return( NIL )

/*/

Ŀ
Funo    fCopia813 | Autor                         Data           
Ĵ
Descrio efetua copia do registro atual                              
Ĵ
 Uso       FISA813                                                    
ٱ
*/
Function fCopia813(nLin)
Local aCopyTab	:= {}

	If Empty(nLin)
	   nLin := n
	EndIf
	// O tratamento do MsNewGetDados e diferente do MSGetDados
	//Copia Linha inteira
	If AllTrim(Upper(oGet:cClassName)) == "MSGETDADOS"
	   aCopyTab := ( aClone ( aCols[nLin] ) )
	Else
	   aCopyTab := ( aClone ( oGet:aCols[ nLin ] ) )
	EndIf

Return aCopyTab

/*/

Ŀ
Funo    fColar813 | Autor Mohanad Odeh            Data 12/12/2011
Ĵ
Descrio Cola registro na posicao atual                              
Ĵ
 Uso       FISA813                                                    
ٱ
*/
Function fColar813(aCopyTab,lLinha,nLin, lMsNewGetDados)
Local cSeq      := ""
Local aAux      := aClone(aCols)
Local nPosSeq
Local cChaveGet := ""
Local nTamAux
Local aString   := {}
Local nX := 0
Local aCampos   := {"F3I_SEQUEN"}
Local lF3I      := .F.
Local nPos1     := aScan(aHeader,{|x| AllTrim(x[2]) == aCampos[1]})

DEFAULT lLinha         := .T.
DEFAULT lMsNewGetDados := .F.

	If(nPos1 <> 0, lF3I := .T., lF3I)

	If Empty(nLin)
		nLin := n
	ENDIF

	If (lF3I)
		nPosSeq	:= GdFieldPos("F3I_SEQUEN")
		nTamAux	:= Len(cFilF3I + cCodigo)
		If !Empty(aCopyTab)
			// Chave da sequncia
			cChaveGet	:= cFilF3I+ cCodigo + aCopyTab[nPosSeq]// aCopyTab[nPosFil]+ aCopyTab[nPosCha]+
			// Cria array(aString) com registros que tenham a mesma chave para obter a sequncia
			For nx := 1 To Len(aAux)
				cString := cFilF3I+ cCodigo//+ aAux[nx,nPosFil]+ aAux[nx,nPosCha]
				If Len(cString) > 0 .And. !Empty(aAux[nx,nPosSeq]) .And. ;
					Substr(cChaveGet,01,(nTamAux)) == cString
					Aadd(aString,{cString,aAux[nx,nPosSeq]})
				Endif
			Next
			If !Empty(aString)
				cSeq:= f813SeqAlfa(aString[Len(aString)][2])
			EndIf
			aCopyTab[nPosSeq] := cSeq
		EndIf
	EndIf

	If !Empty(aCopyTab)
		If  lLinha
			// O tratamento do MsNewGetDados e diferente do MSGetDados
			IF lMsNewGetDados
				oGet:aCols[nLin] := aClone( aCopyTab )
			ELSE
				For nX := 1 To Len( aHeader )
					aCols[nLin, nX] := aCopyTab[nX]
				Next nX
			ENDIF
		Else
			For nX := 1 To Len( aHeader )
				aCols[nLin, nX] := aCopyTab[nX]
			Next nX
	    Endif
	    n := nLin
	    oGet:lNewLine := .F.
	    oGet:lEditLine := .T.
	    oGet:oBrowse:Refresh(.T.)
	EndIF

Return (nil)
/*/

Ŀ
Funo    fReorder813| Autor Mauricio Takakura      Data 29/08/2005
Ĵ
Descrio Reordenar os Registros da Tabela                            
Ĵ
 Uso       FISA813                                                    
ٱ
*/
Function fReorder813()
Local nPosSeq	:= GdFieldPos("F3I_SEQUEN") //-- Posicao Campo Sequencia no aCols

	aSort( aCols,,,{ |x,y,z| x[nPosSeq] < y[nPosSeq]} ) //-- Ordena para acertar a sequencia
	oGet:oBrowse:nAt := n
	oGet:oBrowse:Refresh(.T.)

Return (nil)

/*/

Ŀ
Funo    fPlusSeq813| Autor Natie                  Data  30/08/02 
Ĵ
Descrio Controla a Sequencia de acordo com  a Chave digitada        
Ĵ
 Uso       FISA813                                                    
ٱ

*/
Function  fPlusSeq813(aAux,cChaveAux,nUsado)
Local cSeq      := "" //-- Variavel sequencia
Local nLin      := 0
Local nPosSeq   := GdFieldPos("F3I_SEQUEN") //-- Posicao Campo Sequencia no aCols
Local nIniChave := 0
Local nFimChave := 0

	nIniChave := GetSx3Cache("F3I_FILIAL", "X3_TAMANHO") + GetSx3Cache("F3I_CODIGO", "X3_TAMANHO") + 1
	nFimChave := GetSx3Cache("F3I_FILIAL", "X3_TAMANHO") + GetSx3Cache("F3I_CODIGO", "X3_TAMANHO")
	If (nPos:=(Ascan(aAux,{|x| x[1]= substr(cChaveAux,nIniChave,nFimChave)}))) >0
		//-- procura a ultima sequencia da chave
		If nPos > 1
			nPos -= 1
		EndIf
		For nLin := nPos to len(aAux)
			If aAux[nLin,nUsado+1] == .F. .And. !Empty( aAux[nLin][nPosSeq] )
				cSeq := aAux[nLin][nPosSeq]
			ElseIf aAux[nLin,nUsado+1] == .F. .And. Empty( aAux[nLin][nPosSeq] )
				If Empty(cSeq)
					aAux[nLin][nPosSeq] := Soma1(cAuxSeq)
				Else
					aAux[nLin][nPosSeq] := Soma1(cSeq)
				EndIf
			Endif
		Next nLin
	EndIF

	oGet:oBrowse:nAt := n
	oGet:oBrowse:Refresh(.T.)

Return


/*/


Ŀ
Funo    f813Grinc  Autor  Andreia dos Santos     Data  11.11.02 
Ĵ
Descrio  Grava os registros Incluidos na GetDados                   
Ĵ
 Uso       f813Grava                                                  
ٱ

*/
Static Function f813Grinc( cAlias , nIniciar )
Local nX        := 1
Local nY
Local nPosSeq   := GdFieldPos("F3I_SEQUEN")
Local nMaxArray := Len(aHeader)
Local cCampo
Local xConteudo := ""

	For nX	:=	nIniciar TO Len(aCols)
		If aCols[nX,nUsado+1]  = .F.
			F3I->( RecLock(cAlias,.T.,.T.) ) //Inclusao
			F3I->F3I_FILIAL 	:= xFilial(cAlias)
			F3I->F3I_CODIGO 	:= cCodigo
			F3I->F3I_SEQUEN		:= aCols[nX,nPosSeq]
			For nY := 2 To nMaxArray
				cCampo    := Trim(aHeader[nY][2])
				xConteudo += a813Transf(aCols[nX,nY],aHeader[nY][8],aHeader[nY][4],aHeader[nY][5])
			Next nY
			F3I->F3I_CONTEU := xConteudo
			xConteudo	:= ""
			F3I->( MsUnlock() )
		EndIf
	Next nX

Return Nil

/*


ͻ
Funcao    FISA813MovAutor  Andreia dos Santos   Data   13/11/02   
͹
Desc.     Movimenta o cursor para nao parar na coluna sequencia       
                                                                      
͹
Uso        AP7                                                        
ͼ


*/
Function f813Mov( lMov )
Local ni        := 0.00
Local nPosicao  := 0.00
Local nPosTip   := 0.00
Local nStep     := 0.00
Local nPulos    := 0.00

DEFAULT lMov    := .F.

	If !lMov
		Return( .T. )
	Endif

	nPosicao  := GdFieldPos( "F3I_SEQUEN" )
	nPosicao ++
	nStep  := IF(nPosTip > nPosicao , -1 , 1)
	nPulos := Abs( nPosicao - nPosTip )

	If nStep > 0
		nPulos --
	Else
		If nPostip != Len(aHeader)
			nPulos ++
		Endif
	Endif

	For ni := 1 to nPulos
		If nStep > 0
			oGet:oBrowse:GoRight()
		Else
			oGet:oBrowse:GoLeft()
		Endif
	Next
	IF nPulos <= 0
		oGet:oBrowse:bEditCol:= { || Alwaystrue() }
	EndIF

Return( .T. )

/*


ͻ
Funcao    Duplic813 Kelly                       Data   20/10/05   
͹
Desc.     Duplicar uma tabela ja existente                            
͹
Uso       FISA813                                                     
ͼ


*/

Function Duplic813()
Local aKeys        := GetKeys()
Local oDlg
Local oFont1
// variaveis para controle de coordenadas da janela //
Local aAdvSize     := {}
Local aInfoAdvSize := {}
Local aObjSize     := {}
Local aObjCoords   := {}
Local bSet15       := { || NIL } // Bloco com as validacoes do botao OK
Local bSet24       := { || NIL } // Bloco com as validacoes do botao Cancelar
Local cConsPad     := "XM0" // Consulta padrao do campo F3I_FILIAL

Private lChkBox1   := .F.
Private oChkBox1, oNovaFilOrig, oNovoMesAnoOrig, oFilDest, oMesAnoDest
Private cNovaFilOrig
Private cNovoMesAnoOrig
Private cFilOrig    := CriaVar("F3I_FILIAL")
Private cFilDest    := CriaVar("F3I_FILIAL")

	cFilOrig 		:= aCols[n][1]
	cMesAnoOrig 	:= aCols[n][2]
	cNovaFilOrig 	:= cFilOrig
	cNovoMesAnoOrig := cMesAnoOrig

	FilDato813(cFilOrig,cMesAnoOrig)

	oGet:Goto(1)
	oGet:oBrowse:Refresh(.T.)

		DEFINE FONT oFont1  NAME "Arial" SIZE 0,-13
		DEFINE FONT oFont2  NAME "Arial" SIZE 0,-13 BOLD
		DEFINE FONT oFont3  NAME "Arial" SIZE 0,-11

		/*Ŀ
		 Monta as Dimensoes dos Objetos         					   
		*/
		aAdvSize		:= MsAdvSize()
		aAdvSize[5]		:=	460 //horizontal
		aAdvSize[3]		:=	230 // LARGURA
		aAdvSize[4]		:=	130 // ALTURA
		aAdvSize[6]		:=  250 //Vertical
		aInfoAdvSize	:= { aAdvSize[1] , aAdvSize[2] , aAdvSize[3] , aAdvSize[4] , 3 , 3 }
		aAdd( aObjCoords , { 000 , 070 , .T. , .F. } )
		aAdd( aObjCoords , { 000 , 030 , .T. , .F. } )
		aObjSize		:= MsObjSize( aInfoAdvSize , aObjCoords )

	    DEFINE MSDIALOG oDlg FROM aAdvSize[7],0 TO aAdvSize[6],aAdvSize[5] TITLE OemToAnsi(STR0035) OF GetWndDefault() STYLE DS_MODALFRAME PIXEL //"Manutencao de Tabelas"

	   		@aObjSize[1,1],aObjSize[1,2] TO aObjSize[1,3],aObjSize[1,4] LABEL OemToAnsi(STR0039) OF oDlg PIXEL //"Origem"
			@aObjSize[1,1]+10,aObjSize[1,2]+5 SAY OemToAnsi(STR0037) SIZE 030,007 OF oDlg PIXEL FONT oFont1 COLOR CLR_BLUE //"Filial:"
			@aObjSize[1,1]+10,aObjSize[1,2]+50 SAY cFilOrig SIZE 030,007 OF oDlg  PIXEL FONT oFont2 COLOR CLR_BLUE
			@aObjSize[1,1]+10,aObjSize[1,2]+100  SAY OemToAnsi(STR0038) SIZE 033,007 OF oDlg PIXEL FONT oFont1 COLOR CLR_BLUE //"Mes/Ano:"
			@aObjSize[1,1]+10,aObjSize[1,2]+150  SAY SubStr(cMesAnoOrig,1,2) + " / " + SubStr(cMesAnoOrig,3,4) SIZE 030,007 OF oDlg PIXEL FONT oFont2 COLOR CLR_BLUE
			@aObjSize[1,1]+25,aObjSize[1,2]+5 TO aObjSize[1,3]-5,aObjSize[1,4]-5 OF oDlg PIXEL //"Alterar Origem"
			@aObjSize[1,1]+30,aObjSize[1,2]+10 CHECKBOX oChkBox1 VAR lChkBox1 PROMPT STR0043 PIXEL SIZE 70,7 OF oDlg ON CHANGE ( fChkBox() )
			@aObjSize[1,1]+50,aObjSize[1,2]+10 SAY OemToAnsi(STR0037) SIZE 030,007	OF oDlg PIXEL FONT oFont1 //"Filial:"
			@aObjSize[1,1]+50,aObjSize[1,2]+50 MSGET oNovaFilOrig VAR cNovaFilOrig SIZE 015,007 OF oDlg PIXEL FONT oFont3	F3 cConsPad
			@aObjSize[1,1]+50,aObjSize[1,2]+100 SAY OemToAnsi(STR0038) SIZE 033,007	OF oDlg PIXEL  FONT oFont1 //"Mes/Ano:"
			@aObjSize[1,1]+50,aObjSize[1,2]+150 MSGET oNovoMesAnoOrig VAR cNovoMesAnoOrig	SIZE 030,007	OF oDlg PIXEL  FONT oFont3
			@aObjSize[2,1], aObjSize[2,2] TO aObjSize[2,3],aObjSize[2,4] LABEL OemToAnsi(STR0040)						OF oDlg PIXEL //"Destino"
	       @aObjSize[2,1]+10, aObjSize[2,2]+10 SAY OemToAnsi(STR0037) SIZE 030,007 OF oDlg PIXEL  FONT oFont1 //"Filial:"
			@aObjSize[2,1]+10, aObjSize[2,2]+50 MSGET oFilDest VAR cFilDest SIZE 015,007 OF oDlg PIXEL  FONT oFont3  F3 cConsPad
			@aObjSize[2,1]+10, aObjSize[2,2]+100 SAY OemToAnsi(STR0038) SIZE 033,007 OF oDlg PIXEL FONT oFont1 //"Mes/Ano:"
			@aObjSize[2,1]+10, aObjSize[2,2]+150 MSGET oMesAnoDest VAR cMesAnoDest SIZE 030,007 OF oDlg PIXEL FONT oFont3

			If lChkbox1
				oNovaFilOrig:Enable()
				oNovoMesAnoOrig:Enable()
			Else
				oNovaFilOrig:Disable()
				oNovoMesAnoOrig:Disable()
			Endif

			bSet15 := { || nOpcA := 1 , If(!fExiste813(cFilOrig,cMesAnoOrig,cNovaFilOrig,cNovoMesAnoOrig,cFilDest,cMesAnoDest,lChkBox1),   oDlg:End(),)}
			bSet24 := { || nOpcA := 2 , Aplicar(aVisual) , fReorder813() , RestKeys(aKeys,.T.), oDlg:End()}

			oDlg:lEscClose := .F. //Nao permite sair ao se pressionar a tecla ESC.

		ACTIVATE MSDIALOG oDlg CENTERED ON INIT EnchoiceBar( oDlg , bSet15 , bSet24 )

Return

/*


Ŀ
Funo     fChkBox   Autor  Kelly                  Data  24/10/05 
Ĵ
Descrio  Habilita/Desabilita os campos de origem, de acordo com a   
|          | marcacao do CheckBox                                       |
Ĵ
 Uso       Duplicar                                                   
ٱ

*/
Static Function fChkBox()

	If lChkBox1
		oNovaFilOrig:Enable()
		oNovoMesAnoOrig:Enable()
		oNovaFilOrig:SetFocus()
	Else
		oNovaFilOrig:Disable()
		oNovoMesAnoOrig:Disable()
	EndIf
	oNovaFilOrig:Refresh()
	oNovoMesAnoOrig:Refresh()

Return .T.

/*


ͻ
Funcao    GerRegs813      Kelly  |                     Data   20/10/05   
͹
Desc.     Gera os novos registros a partir da tabela origem indicada        
͹
Uso       fExiste813                                                        
ͼ


*/

Function GerRegs813(cFil, cChav)
Local aTabela := {}
Local nReg    := len(aCols)
Local nCols   := len(aHeader)
Local nX      := 0
Local nY      := 0
Local nCont   := 1

	/*
	Ŀ
	Alimenta a array temporaria com os registros que deverao ser duplicados.  
	*/
	FOR nX := 1 to nReg
		if (aCols[nX][1] == cFil .and. aCols[nX][2] == cChav) .and. (aCols[nX,nCols+1] == .F.)
			aAdd(aTabela,Array(nCols+1))
			for nY := 1 to nCols+1
				if nY == nCols+1
					aTabela[nCont][nY] := .F.
				else
					aTabela[nCont][nY] := aCols[nX][nY]
				endif
			next nY
			nCont++
		endif
	Next nX

	/*
	Ŀ
	Atualiza aCols com os novos registros.                                    
	*/
	If (len(aTabela)>0)
		nCont := nReg + 1

		FOR nX := 1 to len(aTabela)
			aAdd(aCols,Array(nCols+1))
			aCols[nCont][1] := cFilDest
			aCols[nCont][2] := cMesAnoDest
			FOR nY := 3 to nCols+1
				aCols[nCont][nY] := aTabela[nX][nY]
			NEXT nY
			nCont++
		NEXT nX

		/*
		Ŀ
		Atualiza os registros de origem caso o usuario tenha marcado a opcao ALTERAR ORIGEM.  
		*/
		If lChkBox1
			FOR nX := 1 to nReg
				if (aCols[nX][1] = cFil .and. aCols[nX][2] = cChav) .and. (aCols[nX,nCols+1] = .F.)
					aCols[nX][1] := cNovaFilOrig
					aCols[nX][2] := cNovoMesAnoOrig
				endif
			Next nX
		Endif
		Aplicar(aCols)
	Endif

Return


/*


ͻ
Funcao    Aplicar   Kelly  |                     Data   25/10/05   
͹
Desc.     Aplicar as alteracoes efetuadas, atualizando o aCols        
                                                                      
͹
Uso       FISA813                                                     
ͼ


*/

Static Function Aplicar(aArray)
Local nRegAntes	:= len(aAntes)
Local nRegACols := len(aArray)
Local nCont
Local nX, nY

Private nCols := len(aHeader)

	nCont := nRegAntes + 1

	// Adiciona os novos registros na matriz dos dados mantidos
	FOR nX := 1 to nRegACols
		aAdd(aAntes,Array(nCols+1))
		FOR nY := 1 to nCols+1
			aAntes[nCont][nY] := aArray[nX][nY]
		NEXT nY
		nCont++
		nRegAntes++
	NEXT nX

	// Limpa o aCols
	aCols := {}
	aCols := Array (0,0)

	// Atualiza o aCols de acordo com a matriz anterior
	FOR nX := 1 To nRegAntes
		aAdd(aCols,Array(nCols+1))
		FOR nY := 1 to nCols+1
			aCols[nX][nY] := aAntes[nX][nY]
		NEXT nY
	NEXT nX

	fReorder813()

Return


/*


ͻ
Funcao    Rejusta813Kelly  |                     Data   25/10/05   
͹
Desc.     Aplicar um percetual ou somar um valor nos dados da tabela  
                                                                      
͹
Uso       FISA813                                                     
ͼ


*/

Function Rejusta813()
Local aKeys		  := GetKeys()
Local nX
Local oDlg
Local oFont1
Local oRadio
Local bBlock        := { || NIL }
Local cFilOrig      := CriaVar("F3I_FILIAL")
// variaveis para controle de coordenadas da janela //
Local aAdvSize      := {}
Local aInfoAdvSize  := {}
Local aObjSize      := {}
Local aObj2Size     := {}
Local aObjCoords    := {}
Local aObj2Coords   := {}
Local bSet15        := { || NIL }
Local bSet24        := { || NIL }

Private lChkPerc    := .F.
Private lChkSomar   := .F.
Private nPerc       := 0
Private nSomar      := 0
Private oPerc, oSomar
Private nItem       := 1
Private oLbx,cLbx
Private aLbx	      := {}
Private cFilial1    := aCols[n][1]
Private cChave1     := aCols[n][2]
Private oOk         := LoadBitmap( GetResources(), "LBOK" )
Private oNo         := LoadBitmap( GetResources(), "LBNO" )
Private nCampos     := 0
Private nRadio      := 0

	cFilOrig	:= aCols[n][1]
	cMesAnoOrig	:= aCols[n][2]
	FilDato813(cFilOrig,cMesAnoOrig)
	oGet:Goto(1)
	oGet:oBrowse:Refresh(.T.)

	dbSelectArea( "F3H" )
	dbSetOrder(1)
	dbSeek(xFilial("F3H") + cCodigo)
	nX := 1
	While !eof() .and. F3H->F3H_CODIGO == cCodigo
		If F3H->F3H_TIPO == "N"
			aAdd(aLbx, { .F. , F3H->F3H_DESCPO , nX })
		Endif
		nX++
		nCampos++
		dbSkip()
	Enddo

	// Se nao existir campo numerico nem apresenta a tela de reajuste
	If len(aLbx) == 0
		oGet:oBrowse:Refresh(.T.)
		AVISO(OemToAnsi(STR0014),OemToAnsi(STR0074),{'OK'},,STR0014) //"Atencao" ### "Nao ha campos a serem reajustados."
	Else

		/*Ŀ
		 Monta as Dimensoes dos Objetos         					   
		*/
		aAdvSize    := MsAdvSize()
		aAdvSize[5] :=	543 //horizontal
		aAdvSize[3] :=	270 // LARGURA
		aAdvSize[4] :=	140  // ALTURA
		aAdvSize[6] :=  375 //Vertical
		aInfoAdvSize := { aAdvSize[1] , aAdvSize[2] , aAdvSize[3] , aAdvSize[4] , 3 , 3 }
		aAdd( aObjCoords , { 000 , 025 , .T. , .F. } )
		aAdd( aObjCoords , { 000 , 090 , .T. , .F. } )
		aAdd( aObjCoords , { 000 , 045 , .T. , .F. } )
		aObjSize		:= MsObjSize( aInfoAdvSize , aObjCoords )

		aAdd( aObj2Coords , { 000 , 025 , .T. , .F. } )
		aAdd( aObj2Coords , { 000 , 090 , .T. , .F. , .T. } )
		aAdd( aObj2Coords , { 000 , 050 , .T. , .F. } )
		aObj2Size		:= MsObjSize( aInfoAdvSize , aObj2Coords )

	    DEFINE FONT oFont1  NAME "Arial" SIZE 0,-13
		DEFINE FONT oFont2  NAME "Arial" SIZE 0,-13 BOLD
		DEFINE FONT oFont3  NAME "Arial" SIZE 0,-11

		DEFINE MSDIALOG oDlg FROM aAdvSize[7],0 TO aAdvSize[6],aAdvSize[5] TITLE OemToAnsi(STR0042) OF GetWndDefault() STYLE DS_MODALFRAME PIXEL //"Manutencao de Tabelas"

			@aObjSize[1,1],aObjSize[1,2] TO aObjSize[1,3],aObjSize[1,4] LABEL "" OF oDlg PIXEL
			@aObjSize[1,1]+10,aObjSize[1,2]+5 SAY OemToAnsi(STR0037) SIZE 030,007 OF oDlg PIXEL FONT oFont1 COLOR CLR_BLUE //"Filial:"
			@aObjSize[1,1]+10,aObjSize[1,2]+50 SAY cFilial1			 SIZE 030,007 OF oDlg PIXEL FONT oFont2 COLOR CLR_BLUE
			@aObjSize[1,1]+10,aObjSize[1,2]+100 SAY OemToAnsi(STR0038)	SIZE 033,007 OF oDlg PIXEL FONT oFont1 COLOR CLR_BLUE //"Mes/Ano:"
			@aObjSize[1,1]+10,aObjSize[1,2]+150 SAY SubStr(cChave1,1,2) + " / " + SubStr(cChave1,3,4) SIZE 030,007 OF oDlg PIXEL FONT oFont2 COLOR CLR_BLUE
			@aObjSize[2,1],aObjSize[2,2] TO aObjSize[2,3],aObjSize[2,4] LABEL "" OF oDlg PIXEL
			@aObjSize[2,1]+10,aObjSize[2,2]+10 TO aObjSize[2,3]*0.65,aObjSize[2,4]*0.50 LABEL "" OF oDlg PIXEL
		  	@aObjSize[2,1]+20,aObjSize[2,2]+20 CHECKBOX oChkPerc VAR lChkPerc PROMPT "" PIXEL SIZE 7,7 OF oDlg ON CHANGE ( fChkPerc() ) //"Aplicar Percentual:"
			@aObjSize[2,1]+20,aObjSize[2,2]+30 SAY OemToAnsi(STR0046) SIZE 030,009 OF oDlg FONT oFont1 PIXEL
			@aObjSize[2,1]+20,aObjSize[2,2]+70 MSGET oPerc VAR nPerc SIZE 030,007 OF oDlg PICTURE "@E 999.99" FONT oFont3 PIXEL HASBUTTON
			@aObjSize[2,3]*0.66,aObjSize[2,2]+10 TO aObjSize[2,3]-10, aObjSize[2,4]*0.50 LABEL "" OF oDlg PIXEL
			@(aObjSize[2,3]*0.66)+10,aObjSize[2,2]+20 CHECKBOX oChkSomar VAR lChkSomar PROMPT "" PIXEL SIZE 7,7 OF oDlg ON CHANGE ( fChkSomar() ) //"Somar:"
			@aObjSize[2,3]*0.66+10,aObjSize[2,2]+30 SAY OemToAnsi(STR0047) SIZE 030,007 OF oDlg  FONT oFont1 PIXEL
			@aObjSize[2,3]*0.66+10,aObjSize[2,2]+70 MSGET oSomar VAR nSomar SIZE 030,007 OF oDlg PIXEL	PICTURE "@E 9,999.99" FONT oFont3 HASBUTTON

		   	If lChkPerc
				oPerc:Enable()
			Else
				oPerc:Disable()
			Endif
			If lChkSomar
				oSomar:Enable()
			Else
				oSomar:Disable()
			Endif

			@aObj2Size[2][1]+10, aObj2Size[2][2]+132 LISTBOX oLbx VAR cLbx FIELDS HEADER  "", OemtoAnsi(STR0048) SIZE aObj2Size[2][3]/2.2 ,aObj2Size[2][4]-20 ON DBLCLICK (aLbx:=fSelLbx(oLbx:nAt,aLbx),oLbx:Refresh()) PIXEL //"Colunas"
			oLbx:SetArray(aLbx)
			oLbx:LHSCROLL := .F.
			oLbx:LVSCROLL := .T.
			oLbx:nFreeze  := 1
			oLbx:bLine    := { || {If(aLbx[oLbx:nAt,1],oOk,oNo),aLbx[oLbx:nAt,2]}}
		   	oLbx:nAt      := Max(nItem,1)
			oLbx:nRowPos  := 1
			@aObjSize[3,1],aObjSize[3,2] GROUP oGroup TO aObjSize[3,3],aObjSize[3,4] PROMPT OemtoAnsi(STR0078) OF oDlg PIXEL COLOR CLR_BLUE //"Arredondamento"
			oGroup:SetFont(oFont1)
			bBlock	:= { |x| If(ValType(x)=='U', nRadio , nRadio := x ) }
			oRadio	:= TRadMenu():New( aObjSize[3,1]+10,aObjSize[3,2]+10, {oEmToAnsi(STR0079), oEmToAnsi(STR0080), oEmToAnsi(STR0081)},bBlock,oDlg,,,,,,,,80,10)	//"Nenhum"###"Padrao"###"Acima"
			nRadio	:= oRadio:nOption
			bSet15 := { || nOpcA := 1 , If(fValido813(),  oDlg:End() , )}
			bSet24 := { || nOpcA := 2 , Aplicar(aVisual) , fReorder813() , 	RestKeys(aKeys,.T.), oDlg:End() }
			oDlg:lEscClose := .F. //Nao permite sair ao se pressionar a tecla ESC.

		ACTIVATE MSDIALOG oDlg ON INIT EnchoiceBar( oDlg , bSet15 , bSet24 ) CENTERED

	Endif

Return

/*


Ŀ
Funo     fChkPerc  Autor  Kelly                  Data  26/10/05 
Ĵ
Descrio  Habilita/Desabilita os campos de "Aplicar Percentual"      
Ĵ
 Uso       Rejusta813                                                 
ٱ

*/
Static Function fChkPerc()

	If lChkPerc
		oPerc:Enable()
		oPerc:Setfocus()
	Else
		oPerc:Disable()
	EndIf
	oPerc:Refresh()

Return .T.

/*


Ŀ
Funo     fChkSomar Autor  Kelly                  Data  26/10/05 
Ĵ
Descrio  Habilita/Desabilita os campos de "Somar"                   
Ĵ
 Uso       Rejusta813                                                 
ٱ

*/
Static Function fChkSomar()

	If lChkSomar
		oSomar:Enable()
		oSomar:Setfocus()
	Else
		oSomar:Disable()
	EndIf
	oSomar:Refresh()

Return .T.


/*

Ŀ
Funo     fSelLbx   Autor  Kelly                  Data  26.10.05 
Ĵ
Descrio  Marca e desmarca itens da ListBox                          
Ĵ
 Uso       Rejusta813                                                 
ٱ

*/
Static Function fSelLbx(nAt,aArray)

	aArray[nAt,1] := If(aArray[nAt,1], .F., .T.)

Return aArray


/*

Ŀ
Funo     FilDato813   Autor  Kelly                  Data  26.10.05 
Ĵ
Descrio  Filtra a grade apresentando apenas os dados da tabela         
          | selecionada                                                   
Ĵ
 Uso       FISA813                                                       
ٱ

*/
Function FilDato813(cFilDe, cMesAnoDe)
Local nX, nY
Local nCont  := 1
Local nCont2 := 1
Local nCols  := len(aHeader)
Local nReg   := len(aCols)
Local nRegVis

	aVisual := {}
	aAntes  := {}
	// Alimenta a array de visualizacao apenas com os registros da tab. selecionada.
	FOR nX := 1 to nReg
		If (aCols[nX][1] = cFilDe .and. aCols[nX][2] = cMesAnoDe) .and. (aCols[nX][nCols+1] = .F.)
			aAdd(aVisual,Array(nCols+1))
			for nY := 1 to nCols+1
				aVisual[nCont][nY]	:= aCols[nX][nY]
			next nY
			nCont++
		Else
			aAdd(aAntes,Array(nCols+1))
			for nY := 1 to nCols+1
				aAntes[nCont2][nY]	:= aCols[nX][nY]
			next nY
			nCont2++
		Endif
	Next nX

	nRegVis := len(aVisual)
	// Limpa o aCols
	aCols := {}
	aCols := Array( 0 , 0 )
	// Alimenta o aCols com os dados da array de visualizacao.
	FOR nX := 1 to nRegVis
		aAdd(aCols,Array(nCols+1))
		for nY := 1 to nCols+1
			aCols[nX][nY] := aVisual[nX][nY]
		next nY
	Next nX

Return


/*

Ŀ
Funo     fValido813      Autor  Kelly                  Data  26.10.05 
Ĵ
Descrio  Valida as opcoes e os campos e faz o reajuste                    
Ĵ
 Uso       Rejusta813                                                       
ٱ

*/
Function fValido813()
Local lOk         := .T.
Local nP, nX, nY
Local nReg        := len(aCols)
Local nCols       := len(aHeader)
Local nRSoma, nRPerc
Local nAux
Local nEstouro    := 0

	// Verifica se alguma opcao foi marcada e se o valor ou o % foi informado
	If !lChkPerc .and. !lChkSomar
		lOk := .F.
		AVISO(OemToAnsi(STR0014),OemToAnsi(STR0049),{'OK'},,STR0053) //"Atencao" ### "Selecione pelo menos uma opcao de reajuste"
	Elseif (lChkPerc .and. nPerc == 0)
		lOk := .F.
		AVISO(OemToAnsi(STR0014),OemToAnsi(STR0051),{'OK'},,STR0053) //"Atencao" ### "Informe o percentual de reajuste."
	Elseif (lChkSomar .and. nSomar == 0)
		lOk := .F.
		AVISO(OemToAnsi(STR0014),OemToAnsi(STR0052),{'OK'},,STR0053) //"Atencao" ### "Informe o valor do reajuste"
	Endif

	nP := Ascan( aLbx, { |x| x[1] == .T. } )
	If (nP = 0) .and. (lOk)
		lOk := .F.
		AVISO(OemToAnsi(STR0014),OemToAnsi(STR0050),{'OK'},,STR0053) //"Atencao" ### "Selecione pelo menos uma coluna a ser reajustada"
	Endif

	// Estando tudo ok, aplica o reajuste
	If lOk
		For nY := 1 to nCols
			If aScan(aLbx,{ |x| (Upper(AllTrim(x[2])) == Upper(AllTrim(aHeader[nY][1])) .and. (x[1] == .T.)) } ) > 0
				For nX := 1 to nReg
					nRSoma := aCols[nX][nY] + nSomar
					If nRadio == 1
						nRPerc := NoRound(aCols[nX][nY] * (nPerc/100))
					Elseif nRadio == 2
						nRPerc := Round(aCols[nX][nY] * (nPerc/100),MsDecimais(1))
					Else
						nAux := aCols[nX][nY] * (nPerc/100)
						If nAux - Round(nAux,MsDecimais(1)) > 0.00
							nAux := NoRound((nAux + .01),MsDecimais(1))
						Else
							nAux := Round(nAux,MsDecimais(1))
						Endif
						nRPerc := nAux
					Endif
					If 	Len(Transform((nRSoma + nRPerc),aHeader[nY][3])) > aHeader[nY][4]
						nEstouro := nEstouro + 1
						aCols[nX][nY] := Val(aHeader[nY][3])
					Else
						aCols[nX][nY] := nRSoma + nRPerc
					EndIf
				Next nX
			Endif
		Next nY
		If nEstouro > 0
			MsgAlert(OemToAnsi(STR0091) + AllTrim(STR(nEstouro)) + OemToAnsi(STR0092), OemToAnsi(STR0083)) // "O Valor do reajuste excedeu em " ### " campo(s)" ### "Ateno"
		EndIf
	Endif

	oGet:oBrowse:Refresh(.T.)
	If lOk
		Aplicar(Acols)
	Endif

Return lOk


/*

Ŀ
Funo     fExiste813      Autor  Kelly                  Data  28.10.05 
Ĵ
Descrio  Verifica no aCols e no aAntes a existencia de registros com      
           a filial e o mes/ano indicados.                                  
Ĵ
Parametros cFil01 = Filial Origem                                           
           cChave01 = Mes/Ano Origem                                        
           cFil02 = Nova Filial Origem                                      
           cChave02 = Novo Mes/Ano Origem                                   
           cFil03 = Filial Destino                                          
           cChave03 = Mes/Ano Destino                                       
           lAltOrig = CheckBox "ALTERA ORIGEM"                              
Ĵ
 Uso       Duplicar                                                         
ٱ

*/

Function fExiste813(cFil01,cChave01,cFil02,cChave02,cFil03,cChave03,lAltOrig)
Local nA      := 0
Local nB      := 0
Local nC      := 0
Local nD      := 0
Local lExiste := .F.
local cOk     := fCposOk813(cFil02,cChave02,cFil03,cChave03,lAltOrig)

	If cOk <> ""
		lExiste := .T.
		AVISO(OemToAnsi(STR0014),OemToAnsi(cOk),{'OK'},,STR0014)
	Else
		If lAltOrig
			nA := ( Ascan( aCols, { |x| x[1] == cFil02 .and. x[2] == cChave02 } ) )
			nB := ( Ascan( aAntes,{ |x| x[1] == cFil02 .and. x[2] == cChave02 } ) )
		Else
			nC := ( Ascan( aCols, { |x| x[1] == cFil03 .and. x[2] == cChave03 } ) )
			nD := ( Ascan( aAntes,{ |x| x[1] == cFil03 .and. x[2] == cChave03 } ) )
		Endif
		If (nA > 0) .or. (nB > 0) .or. (nC > 0) .or. (nD > 0)
			lExiste := .T.
			AVISO(OemToAnsi(STR0014),OemToAnsi(STR0054),{'OK'},,STR0014) //"Atencao" ### "J existe(m) registro(s) com Filial e Ms/Ano indicados."
		Endif
		If !lExiste
			GerRegs813(cFil01,cChave01)
		Endif
	Endif

Return lExiste


/*

Ŀ
Funo     fCposOk813      Autor  Kelly                  Data  31.10.05 
Ĵ
Descrio  Valida os campos digitados                                       
Ĵ
Parametros cFilOk1 = Filial Origem                                          
           cChaveOk1 = Mes/Ano Orige                                        
           cFilOk2 = Nova Filial Origem                                     
           cChaveOk2 = Novo Mes/Ano Origem                                  
           lOrigem = CheckBox "ALTERA ORIGEM"                               
Ĵ
 Uso       fExiste813                                                       
ٱ

*/

Function fCposOk813(cFilOk1,cChaveOk1,cFilOk2,cChaveOk2,lOrigem)
Local aArea		:= GetArea()
Local aAreaSM0	:= SM0->(GetArea())
Local cExibeAviso := ""

	dbSelectArea("SM0")
	dbSetOrder(1)

	If lOrigem
		If (AllTrim(cFilOk1) <> "") .and. (!dbSeek(cEmpAnt + AllTrim(cFilOk1)))
			cExibeAviso := STR0055 // Filial Origem Invalida
		ElseIf (AllTrim(cChaveOk1) <> "") .and. (Len(AllTrim(cChaveOk1)) < 6)
			cExibeAviso := STR0057 // Mes/Ano Origem Invalido
		Elseif (AllTrim(cChaveOk1) <> "") .and. ((VAL(SubStr(cChaveOk1,1,2)) < 1) .or. (VAL(SubStr(cChaveOk1,1,2)) > 12))
			cExibeAviso := STR0059 // Mes Origem Invalido
		Elseif (AllTrim(cChaveOk1) <> "") .and. (VAL(SubStr(cChaveOk1,3,4)) < 1900)
			cExibeAviso := STR0060 // Ano Origem Invalido
		Endif
	Endif
	If (AllTrim(cFilOk2) <> "") .and. (!dbSeek(cEmpAnt + AllTrim(cFilOk2)))
		cExibeAviso := STR0056 // Filial Destino Invalida
	ElseIf (AllTrim(cChaveOk2) <> "") .and. (Len(AllTrim(cChaveOk2)) < 6)
		cExibeAviso := STR0058 // Mes/Ano Destino Invalido
	Elseif (AllTrim(cChaveOk2) <> "") .and. ((VAL(SubStr(cChaveOk2,1,2)) < 1) .or. (VAL(SubStr(cChaveOk2,1,2)) > 12))
		cExibeAviso := STR0061 // Mes Destino Invalido
	Elseif (AllTrim(cChaveOk2) <> "") .and. (VAL(SubStr(cChaveOk2,3,4)) < 1900)
		cExibeAviso := STR0062 // Ano Destino Invalido
	Endif

	RestArea(aArea)
	RestArea(aAreaSM0)

Return cExibeAviso

/*

Ŀ
Funo     Pesq813         Autor  Kelly                  Data  31.10.05 
Ĵ
Descrio  Pesquisa um registro                                             
Ĵ
Parametros cFilOk1 = Filial Origem                                          
Ĵ
 Uso       FISA813                                                          
ٱ

*/

/*Function Pesq813()
Local aKeys          := GetKeys()
Local oDlg
Local oFont1, oFont2
//-- Variaveis dimensoes do objeto tela
Local aAdvSize       := {}
Local aInfoAdvSize	:= {}
Local aObjSize		:= {}
Local aObjCoords     := {}
Local bSet15         := {|| NIL}
Local bSet24         := {|| NIL}

Private oPesqFilial, oPesqChave, oChkFilial, oChkChave


	aAdvSize       := MsAdvSize()
	aAdvSize[5]    :=	460 //horizontal
	aAdvSize[3]    :=	230 // LARGURA
	aAdvSize[4]    :=	50  // ALTURA
	aAdvSize[6]    :=  110 //Vertical
	aInfoAdvSize   := { aAdvSize[1] , aAdvSize[2] , aAdvSize[3] , aAdvSize[4] , 0 , 0 }
	aAdd( aObjCoords , { 000 , 000 , .T. , .T. } )
	aObjSize		:= MsObjSize( aInfoAdvSize , aObjCoords )

	DEFINE FONT oFont1  NAME "Arial" SIZE 0,-13
	DEFINE FONT oFont2  NAME "Arial" SIZE 0,-11

	DEFINE MSDIALOG oDlg FROM aAdvSize[7],0 TO aAdvSize[6],aAdvSize[5] TITLE OemToAnsi(STR0065) OF GetWndDefault() STYLE DS_MODALFRAME PIXEL //"Pesquisar Registro"

		@aObjSize[1,1]+10, aObjSize[1,2]+10 SAY OemToAnsi(STR0037) SIZE 040,007 OF oDlg PIXEL FONT oFont1 //"Filial:"
		@aObjSize[1,1]+10, aObjSize[1,2]+50 MSGET oPesqFilial VAR cPesqFilial	SIZE 050,007	OF oDlg PIXEL FONT oFont2
		@aObjSize[1,1]+25, aObjSize[1,2]+10 SAY OemToAnsi(STR0038) SIZE 043,007 OF oDlg PIXEL FONT oFont1	//"Mes/Ano:"
		@aObjSize[1,1]+25, aObjSize[1,2]+50 MSGET oPesqChave  VAR cPesqChave SIZE 050,007	OF oDlg PIXEL FONT oFont2

		bSet15 := { || nOpcA := 1 , fFind813(cPesqFilial,cPesqChave) ,  oDlg:End()}
		bSet24 := { || nOpcA := 2 , RestKeys(aKeys,.T.), oDlg:End() }
		oDlg:lEscClose := .F. //Nao permite sair ao se pressionar a tecla ESC.

	ACTIVATE MSDIALOG oDlg ON INIT EnchoiceBar(oDlg, bSet15 , bSet24 ) CENTERED

Return

Return*/

/*

Ŀ
Funo     fFind813        Autor  Kelly                  Data  31.10.05 
Ĵ
Descrio  Pesquisa um registro com a filial e a chave indicadas            
Ĵ
Parametros cPFil = Filial Origem                                            
           cPChave = Mes/Ano Orige                                          
Ĵ
 Uso       Pesq813                                                          
ٱ

*/

/*Function fFind813(cPFil,cPChave)

	nP := ( Ascan( aCols, { |x| x[1]+Right(x[2],4)+Left(x[2],2) >= cPFil+Right(cPChave,4)+Left(cPChave,2) } ) )
	If nP = 0
	   nP := 1
	Endif
	oGet:Goto( nP )
	oGet:oBrowse:Refresh(.T.)

Return*/






/*


Ŀ
Funo     fExcluirOk2  Autor: Kelly Soares         Data  30.11.05 
Ĵ
Descrio  Verifica integridade dos dados da Tabela com o Lancto Fixo.
Ĵ
 Uso       Generico                                                   
ٱ

*/

/*Static Function fExcluirOk2()
Local lOk  := .T.

	lOk := !fTemLanctoFixo( cCodigo , Val(aColsBkp[Len(aColsBkp),3]) , 0 , "2" )

Return lOk*/


/*


Ŀ
Funo     fAtualizaBkp2   Autor: Kelly Soares      Data  30.11.05 
Ĵ
Descrio  Atualiza a array de bkp dp aCols.                          
Ĵ
 Uso       Generico                                                   
ٱ

*/

Static Function fAtualizaBkp2()
Local nX

	If nBkp < Len(aCols)
		aAdd(aColsBkp , Array(len(aCols[n])))
		For nX := 1 to len(aCols[n])
			aColsBkp[Len(aColsBkp),nX] := aCols[n,nX]
		Next nX
		nBkp ++
	Endif

Return

/*
Ŀ
Funo     MenuDef        Autor  Luiz Gustavo      Data 04/01/2007
Ĵ
Descrio Isola opcoes de menu para que as opcoes da rotina possam    
          ser lidas pelas bibliotecas Framework da Versao 9.12 .      
Ĵ
Sintaxe   < Vide Parametros Formais >                                 
Ĵ
 Uso      FISA813                                                     
Ĵ
 Retorno  aRotina                                                     
Ĵ
Parametros< Vide Parametros Formais >                                 
*/

Static Function MenuDef()

Local aRotina := { { STR0002   , 'PesqBrw'   , 0 , 1,,.F.},; //'Pesquisar'
                   { STR0003   , 'f813Alt'   , 0 , 2},; //'Visualizar'
                   { STR0004   , 'f813Alt'   , 0 , 3},; //'Incluir'
                   { STR0005   , 'f813Alt'   , 0 , 4},; //'Alterar'
                   { STR0006   , 'f813Exc'   , 0 , 5},; //'Excluir'
                   { STR0007   , 'f813Leg'   , 0 , 7,,.F.} } //'Legenda'
 If cPaisLoc == "BOL"
 	AADD(aRotina,{ STR0093 , 'fis813CBol'   , 0 , 6}) //'Obtener Catlogos del SIN '
 EndIf

Return aRotina

/*
Ŀ
Funo     f813SeqAlfa()  Autor  Mohanad Odeh      Data 12/12/2011
Ĵ
Descrio Gera sequncia de valores alfanumricos                     
Ĵ
Sintaxe   < Vide Parametros Formais >                                 
Ĵ
 Uso      FISA813                                                     
Ĵ
 Retorno  cRet                                                        
Ĵ
Parametros< Vide Parametros Formais >                                 
*/
Static Function f813SeqAlfa(cSeq)
Local nConta  := 3
Local cLetra  := ""
Local cRet    := ""
Local nAux    := 0
Local blMuda  := .F.

	If Val(cSeq) >= 000 .AND. Val(cSeq) <= 998
		cRet := Soma1(cSeq)
	ElseIf Val(cSeq) == 999
		cRet := "AA1"
	Else
		For nConta:= 3 To 1 step - 1
			cLetra := SubStr(cSeq, nConta, 1)
			If nConta == 3 .Or. blMuda
				IF (Asc(cLetra) >= 48 .and. Asc(cLetra) <= 56)
					cLetra := AllTrim(Str(val(cLetra) + 1))
					blMuda := .F.
				ElseIf Asc(cLetra) == 57
					cLetra := "A"
					blMuda := .F.
				ElseIf (Asc(cLetra) >= 65 .and. Asc(cLetra) <= 89)
					nAux := Asc(cLetra) + 1
					cLetra := CHR(nAux)
					blMuda := .F.
				ElseIf Asc(cLetra) == 90
					cLetra := "1"
					blMuda := .T.
				Endif
			Endif
			cRet := cLetra + cRet
		Next
	EndIf

Return cRet

/*


Ŀ
Funo     fis813CBol  Autor  Alf. Medrano         Data  14/10/19 
Ĵ
Descrio  Ejecuta la funcin de descarga de catalogos del SIN        
Ĵ
Parametros                                                            
Ĵ
Retorno    N/A                                                        
Ĵ
Uso        MenuDef                                                    
ٱ


*/
Function fis813CBol()
	Local cPerg := "FISA813C"
	Local cMsg  := ""
	Local aDatosSM0 := {}
	Private cMVCFDIAMB := SuperGetMV("MV_CFDIAMB",,"")//Cod. Ambiente
	Private cMVSISTEMA := SuperGetMV("MV_SINSIS",,"") //Cod. Sistema
	Private cMVNUMSUC  := alltrim(STR(SuperGetMV("MV_NUMSUC",,0)))  //Cod. Sucursal
	Private cMVCUIS    := SuperGetMV("MV_CUIS",,"")	  //CUIS
	Private cMVNIT     := ""                          //NIT
	Private cMV814PATH := SuperGetMV("MV_PATH814 ",,"") //Direccion donde se guardaran los archivos csv
	Private cRutaSMR   := &(SuperGetMV("MV_CFDSMAR",,""))//ruta donde reside el cliente de WS
	Private cMVMODAL   := SuperGetMV("MV_SINMOD",,"") //Modalidad 1=Electrnica, 2=Computarizada, 3=Manual, 4=Prevalorada Electrnica, 5=Prevalorada Computarizada

	aDatosSM0 := FWSM0Util():GetSM0Data( cEmpAnt, cFilAnt , {"M0_CGC"} )
	cMVNIT := aDatosSM0[1][2]

	If F813VldPar()
		If Pergunte(cPerg,.T.)
			If mv_par01 == 1
				cMsg += STR0094 + chr(13)+ Chr(10)//"Sincronizacin diaria."
				cMsg += STR0095 + chr(13)+ Chr(10)//"Este proceso sincroniza de manera total el catlogo "
				cMsg += STR0096 + chr(13)+ Chr(10)//"cuando se ejecuta la primera vez, para la siguiente  "
				cMsg += STR0097 + chr(13)+ Chr(10)//"ejecucin solo se actualizarn los nuevos cdigos  "
				cMsg += STR0098 + chr(13)+ Chr(10)//"obtenidos del proceso de sincronizacin con el SIAT."
			ElseIf mv_par01 == 2
				cMsg += STR0099 + chr(13)+ Chr(10)//"Sincronizacin por solicitud. "
				cMsg += STR0100 + chr(13)+ Chr(10) //"Esta forma reemplaza en su totalidad los catlogos "
				cMsg += STR0101 + chr(13)+ Chr(10) //"existentes en el sistema por los catlogos obtenidos "
				cMsg += STR0102 + chr(13)+ Chr(10) //"por medio del proceso de sincronizacin SIAT."
			EndIf
			cMsg += STR0103 //"Desea continuar?"
			If MsgYESNO(cMsg)
				processa({|| fis813Cat()}, STR0104, STR0105,.f.) //'Aguarde...', 'Obteniendo catlogos del SIN'
			EndIf
		EndIf
	EndIf
Return Nil

/*


Ŀ
Funo     fis813Cat  Autor  Alf. Medrano          Data  14/10/19 
Ĵ
Descrio  Comunicacin con el WS para la obtencion de catalogos SIN  
Ĵ
Parametros                                                            
Ĵ
Retorno    N/A                                                        
Ĵ
Uso        fis813CBol                                                 
ٱ


*/
Static Function fis813Cat()
	Local cParams    := ""
	Local cMVCFDIPA  := SuperGetMV("MV_CFDI_PA",,"")   //Nombre del ejecutable del servicio web a utiliza.
	Local cPath 	 := &(SuperGetMV("MV_CFDDOCS",,""))
	Local cMsg 		 := ""
	Local cCodigo 	 := ""
	Local cDescrip 	 := ""
	Local cError 	 := ""
	Local cCatOk 	 := ""
	Local cWarning 	 := ""
	Local lHasError  := .F.
	Local cCodTab 	 := ""
	Local nX		 := 0
	Local nOpc 		 := 0
	Local nHandle 	 := 0
	Local nRet		 := 0
	Local nTipoDesc  := MV_PAR01
	Local cCodAut	 := "1"
	Local oDlg       := Nil
	Local oMemo      := Nil
	Local oButton    := Nil

	Private cFilF3I  := xFilial("F3I")

	If nTipoDesc == 2 // Descarga Completa
		If !Empty(MV_PAR02)
			cCodAut := alltrim(MV_PAR02)
		EndIf
	EndIf

	cParams := "L "//Opcin para carga de catlogos
	cParams += cMVCFDIAMB + " "
	cParams += cMVSISTEMA + " "
	cParams += cMVNUMSUC + " "
	cParams += cMVCUIS + " "
	cParams += cMVNIT + " "
	cParams += cMV814PATH + " "
	cParams += cRutaSMR	 + " "
	cParams += cMVMODAL + " "
	cParams += "X "
	cParams += "X "
	cParams += "X "
	cParams += "X "
	cParams += "1 "
	cParams += "1 "
	cParams += cCodAut + " "
	cParams += "X "
	cParams += "0 "

	CursorWait()
	nOpc := WAITRUN( cRutaSMR + cMVCFDIPA + ".exe " + cParams, 0 )	// Se ejecuta exe
	If nOpc == 0
		If File(cRutaSMR  + "catalogos.xml.out")
			CpyT2S(cRutaSMR  + "catalogos.xml.out" , cPath)
			// Procesar archivo out
			oXMLResp := XmlParserFile(EncodeUtf8(cPath + "catalogos.xml.out"), "_", @cError, @cWarning )
			If oXMLResp <> Nil
				If ValType( oXMLResp:_RESPONSES:_RESPONSE) == "A"
					ProcRegua((Len(oXMLResp:_RESPONSES:_RESPONSE)))
					For nX := 1 To Len(oXMLResp:_RESPONSES:_RESPONSE)
						lHasError := "True" $ oXMLResp:_RESPONSES:_RESPONSE[nX]:_HASERROR:TEXT
						If lHasError // Si el .out report error
							cCodigo := oXMLResp:_RESPONSES:_RESPONSE[nX]:_EXCEPTION:_CODE:TEXT
							cDescrip:= oXMLResp:_RESPONSES:_RESPONSE[nX]:_EXCEPTION:_MESSAGE:TEXT
							cError 	+=  STR0113 + " - " + cDescrip + STR0108  + chr(13)+ Chr(10)// "Catlogo", " no se cargo."
							cError  +=  STR0106 + cCodigo + " " + ObtColSAT('S012',cCodigo,1,4,5,120) +  chr(13)+ Chr(10) //"Codigo Respuesta: "
							IncProc(STR0107+cDescrip)//"No se cargo el catlogo : "
						Else
							cCodigo	:= oXMLResp:_RESPONSES:_RESPONSE[nX]:_MESSAGE:_CODE:TEXT
							cDescrip:= oXMLResp:_RESPONSES:_RESPONSE[nX]:_MESSAGE:_DESCRIPTION:TEXT
							cDataTim:= StrTran(ALLTRIM(oXMLResp:_RESPONSES:_RESPONSE[nX]:_MESSAGE:_DATE:TEXT),"-","")
							cCodTab	:= StrTran(ALLTRIM(oXMLResp:_RESPONSES:_RESPONSE[nX]:_MESSAGE:_CODTAB:TEXT),"-","")
							IncProc(STR0109+cDescrip) //"Cargando catlogo : "
							nHandle := fopen(cMV814PATH + cDescrip +".csv")
							If FRead( nHandle, "", 1) > 0 // Lee el primer byte
								F813LisCat(cCodTab) // borra de F3I
								cCatOk	+=  STR0113 + " - " + cDataTim +  " " + cDescrip +  " " + cCodTab +  STR0110 + chr(13)+ Chr(10)// "Catlogo", " se ha cargado en csv "
								nRet++
							EndIf
						EndIf
					Next
				EndIf
			EndIf

			IIf(nRet>0,FISA814(),) // vuelve a generar el contenido de los catalogos

			cMsg := cCatOk + cError
			DEFINE MSDIALOG oDlg FROM 0,0 TO 375,440 PIXEL TITLE STR0111 //'Observaciones'
			oMemo:= tMultiget():New(10,10,{|u|if(Pcount()>0,cMsg:=u,cMsg)} ,oDlg,200,150,,.T.,,,,.T.,,,,,,.T.,,,,,.T.)
			oButton  := TButton():New(165, 160,STR0112,oDlg,{||oDlg:End()},30,11,,,,.T.) //	"Salir"
			ACTIVATE MSDIALOG oDlg CENTERED

			//borrar archivo de la carpeta del smarth
			Ferase( cRutaSMR + "catalogos.xml.out" )
		EndIf
		CursorArrow()
	Else
		MsgAlert(STR0114 + cRutaSMR + cMVCFDIPA + ".exe ", STR0014) //"Ha ocurrido un error al ejecutar: " //"Atencin!"
	EndIf
Return
/*


Ŀ
Funo     F813LisCat  Autor  Alf. Medrano        Data  14/10/19 
Ĵ
Descrio  Comunicacin con el WS para la obtencion de catalogos SIN  
Ĵ
Parametros                                                            
Ĵ
Retorno    N/A                                                        
Ĵ
Uso        fis813Cat                                                  
ٱ


*/
Function F813LisCat(cCodTab)
	Local lRet   := .T.
	Local cQuery := ""
	Default cCodTab := ""

	If cCodTab != ""
		If MV_PAR01 == 1 // carga los registros nuevos (actualizacin de catalogos)
			fs814UpBol( cCodTab, MV_PAR01)
		ElseIf MV_PAR01 == 2 // carga de manera total los catalogos
			cCodTab := Alltrim(cCodTab)
			If F3I->(dbSeek(cFilF3I + cCodTab))
				cQuery := "DELETE FROM " + RetSqlName("F3I") + " WHERE F3I_CODIGO ='" + cCodTab +"'"
				If TcSqlExec(cQuery) <> 0
					lRet := .F.
				EndIf
			EndIf
		EndIf
	EndIf
Return lRet

/*/{Protheus.doc} F813VldPar
Valida confoguracin de parmetros necesarios para factura electrncia.
@type function
@author luis.enrquez
@since 13/12/2019
@version 1.0
@return lRet, Valor lgico .T. sin errores, .F. falt configuracin de parmetros.
/*/
Static Function F813VldPar()
	Local lRet := .T.
	Local cMsg := STR0115 + Chr(10) + Chr(13) //"Falta configuracin de los siguientes parmetros: "

	If Empty(cMVCFDIAMB)
		cMsg += " - MV_CFDIAMB - " + STR0116 + Chr(10) + Chr(13) //"Ambiente de trabajo; 1=Produccin, 2=Pruebas."
		lRet := .F.
	EndIf

	If Empty(cMVSISTEMA)
		cMsg += " - MV_SINSIS - " + STR0117 + Chr(10) + Chr(13) //"Cdigo de Sistema (Solicitud de Certificacin de Sistemas)."
		lRet := .F.
	EndIf
	If Empty(cMVNUMSUC)
		cMsg += " - MV_NUMSUC - " + STR0118 + Chr(10) + Chr(13) //"Nmero de sucursal. Mximo hasta la 9999, tambin puede ser 0 (casa matriz)."
		lRet := .F.
	EndIf
	If Empty(cMVCUIS)
		cMsg += " - MV_CUIS - " + STR0119 + Chr(10) + Chr(13) //"Cdigo nico de Inicio de Sistemas (Solicitud de Certificacin de Sistemas)."
		lRet := .F.
	EndIf
	If Empty(cMV814PATH)
		cMsg += " - MV_PATH814 - " + STR0120 + Chr(10) + Chr(13) //"Ruta para tomar los archivos csv y generar los catlogos."
		lRet := .F.
	EndIf
	If Empty(cRutaSMR)
		cMsg += " - MV_CFDSMAR - " + STR0121 + Chr(10) + Chr(13) //"Carpeta local en donde se procesaran las facturas para generar el timbres fiscales."
		lRet := .F.
	EndIf
	If Empty(cMVMODAL)
		cMsg += " - MV_SINMOD - " + STR0121 + Chr(10) + Chr(13) //"Modalidad factura electrnica Bolivia; 1=Electrnica/2=Computarizada/3=Manual/4=Prevalorada Electrnica/5=Prevalorada Computarizada."
		lRet := .F.
	EndIf

	If !lRet
		MsgAlert(cMsg, STR0014) //"Atencin!"
	EndIf
Return lRet
