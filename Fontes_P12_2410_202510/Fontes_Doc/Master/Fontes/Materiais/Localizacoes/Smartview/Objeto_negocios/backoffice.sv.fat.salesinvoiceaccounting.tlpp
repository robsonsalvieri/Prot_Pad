#INCLUDE 'msobject.ch'
#INCLUDE 'totvs.framework.treports.integratedprovider.th'
#INCLUDE 'backoffice.sv.fat.salesinvoice.accounting.ch'

namespace custom.faturamento.salesinvoiceaccounting.integratedprovider

//-------------------------------------------------------------------------------
/*{Protheus.doc} backoffice.sv.fat.salesinvoice.accounting
@description Classe para creación del Objeto de Negocio de Facturas de venta conciliadas para TReports
@author Marcelo Hruschka
@since 24/10/2024
@version 1.1
*/
//-------------------------------------------------------------------------------
@totvsFrameworkTReportsIntegratedProvider( active=.T., team='SIGAFAT', tables='SF2,CT2,CV3,SE4,SA1', name='Facturas de Venta Conciliada', country='ALL', initialRelease='12.1.2410', customTables='SF2,CT2,SE4' )
class salesinvoiceaccountingTReportsBusinessObject from totvs.framework.treports.integratedprovider.IntegratedProvider

	public Method new() as object
	public Method getData() as object
	public Method getSchema() as object

	protected data aFields as array
	protected data aStruct as array
	protected data nRecnoSF2 as numeric
	protected data jItems as json

endclass

//-------------------------------------------------------------------
/*{Protheus.doc} new
Método de instância da classe 
@Return object: self
@author Marcelo Hruschka
@since 24/05/2024
@version 1.0
*/
//-------------------------------------------------------------------
Method new() class salesinvoiceaccountingTReportsBusinessObject

	Local aCpos := {} as array

	_Super:new()

	//Define o nome do Objeto de Negócio
	self:setDisplayName( STR0001 )  // 'Facturas de Venta Conciliada'

	//Define a descrição do Objeto de Negócio
	self:setDescription( STR0001 )  // 'Facturas de Venta Conciliada'

	// Define a Área
	self:appendArea( STR0002 ) // 'Facturación'

	// Define se as perguntas terao lookup
	self:setIsLookUp( .T. )

	// Indica o pergunte que será utilizado no relatório
	If !self:setPergunte( 'FATSV100' )
		IIf(!self:setErrorStatus( 400, STR0003, STR0004 ),FwLogMsg( 'WARN',, 'Smart View',,,, STR0005,,, ),'') // 'Sin Preguntas' // '¡Verifique el grupo de preguntas dado!' // 'Código de error no válido, solo acepte códigos de error 4xx'
		FwLogMsg( 'WARN',, 'Smart View',,,, STR0006,,, ) // 'Grupo de preguntas no encontrado!'
	EndIf

	// campos que no existen en SX3
	aAdd( aCpos, { 'M0_CGC'	    , STR0007 , 'string'	, STR0007 } ) // 'RFC Emisor'
	aAdd( aCpos, { 'M0_NOMECOM'	, STR0008 , 'string'	, STR0008 } ) // 'Nombre Emisor'
	aAdd( aCpos, { 'F2_VALFATP' , STR0009 , 'number'	, STR0009 } ) // 'Val Fac Peso'
	aAdd( aCpos, { 'F2_DESCONP' , STR0010 , 'number'	, STR0010 } ) // 'Desc Pesos'
	aAdd( aCpos, { 'F2_VALMERP' , STR0011 , 'number'	, STR0011 } ) // 'Val Merc Peso'
	aAdd( aCpos, { 'F2_BASIM1P' , STR0012 , 'number'	, STR0012 } ) // 'Base Imp Peso'
	aAdd( aCpos, { 'F2_VALIM1P' , STR0013 , 'number'	, STR0013 } ) // 'Val Imp Peso'
	aAdd( aCpos, { 'CT2_DOCLSL' , STR0014 , 'string'	, STR0014 } ) // 'Doc/Lote/Sublote'
	aAdd( aCpos, { 'CT2_DTACTB' , STR0015 , 'date'		, STR0015 } ) // 'Fecha de Asiento'
	aAdd( aCpos, { 'CT2_TPSLD'  , STR0016 , 'string'	, STR0016 } ) // 'Tipo Saldo'
	aAdd( aCpos, { 'CT2_HISTO'  , STR0017 , 'string'	, STR0017 } ) // 'Historial'

	// demais campos
	self:aFields := { 'M0_CGC','M0_NOMECOM','A1_CGC','A1_NOME','F2_EMISSAO','F2_VALFAT','F2_VALFATP','F2_DESCONP','F2_VALMERP','F2_BASIM1P','F2_VALIM1P','F2_MOEDA','F2_TXMOEDA','F2_FLFTEX','F2_DOC','F2_SERIE','A1_COD','A1_LOJA','F2_TIPO','F2_TIPODOC','F2_FILIAL','F2_ESPECIE','CT2_DOCLSL','CT2_DTACTB','CT2_TPSLD','CT2_HISTO'}

	self:aStruct := getStrutObj( self:aFields, aCpos )

Return( self )

//-------------------------------------------------------------------
/*{Protheus.doc} getData
Retorna los datos del objeto de negócio
@param nPage, numérico, indica la pagina actual del relatório
@param oFilter, objeto, contiene el filtro del TReports
@return object: self:oData
@author Marcelo Hruschka
@since 24/05/2024
@version 1.0
*/
//------------------------------------------------------------------- 
Method getData( nPage as numeric, oFilter as object) as object class salesinvoiceaccountingTReportsBusinessObject

	// Declaracao de variaveis
	Local cQuery		as character
	Local cFiltro 		as character
	Local cExp 			as character

	Local nX			as numeric
	Local n1			as numeric
	Local nPosMon		as numeric
	Local nPosExp		as numeric
	Local nDecs 		as numeric

	Local jParams 		as json

	Local aPDFields		as array
	Local aFiltro		as array
	Local aCustomFields as array

	Local lObfuscated	as logical

	Local oExecA		as object
	Local oExecB        as object
	Local cAliasA       as character
	Local cAliasB       as character
	Local cChaveCTL     as character
	Local cFilialCTL    as character
	Local nSeq          as numeric

	cFilialCTL := xFilial("CTL")
	cFilialCV3 := xFilial("CV3")

	cChaveCTL := AllTrim(POSICIONE("CTL",1,xFilial("CTL")+"620","CTL_KEY"))

	cFiltro 			:= ''
	cExp 				:= ''
	cAliasA			    := ''
	cAliasB			    := ''

	nPosMon   		:= 0
	nPosExp 		:= 0
	nDecs 			:= 0
	nX 				:= 0
	n1				:= 0

	aPDFields		:= { }
	aFiltro			:= { }
	aCustomFields	:= { }

	// Verifica se existem campos sensiveis na lista de campos a serem retornados
	aPDFields := FwProtectedDataUtil():UsrAccessPDField( __cUserID, self:aFields )
	lObfuscated := Len( aPDFields ) != Len( self:aFields )

	// Coleta os dados dos parametros
	jParams := oFilter:getParameters( )

	// Coleta os campos personalizados pelo usuário
	aCustomFields := self:getCustomFields( )
	cCpoSF2 := getCpoUser( aCustomFields, 'SF2', 'F2', ',' )
	cCpoSE4 := getCpoUser( aCustomFields, 'SE4', 'E4', ',' )
	cCpoCT2 := getCpoUser( aCustomFields, 'CT2', 'CT2', ',' )

	// Adiciona campo customizado na estrutura de campos
	For n1 := 1 To Len( aCustomFields )
		aAdd( self:aStruct, { aCustomFields[n1, 1], aCustomFields[n1, 4], aCustomFields[n1, 3], aCustomFields[n1, 2], aCustomFields[n1, 1] } )
		aAdd( self:aFields, aCustomFields[n1, 1] )
	Next

	If oFilter:hasFilter( )
		// Tratamento para conversão para moeda selecionada
		cFiltro := oFilter:getSQLExpression( )
		aFiltro := getParamToArr( cFiltro )
		// Ordena os parametros
		aSort( aFiltro,,, { |x, y| x[1] + x[3] < y[1] + y[3] } )
	EndIf

	// Realiza a montagem da QUERY que será enviada para o banco de dados
	cQuery := "SELECT "
	cQuery += " SM0.M0_CGC,SM0.M0_NOMECOM,SA1.A1_CGC,SA1.A1_NOME,SF2.F2_EMISSAO, ? " 
	cQuery += " SF2.F2_VALFAT, CAST( COALESCE(SF2.F2_VALFAT * SF2.F2_TXMOEDA,0) AS DECIMAL(14,2)) F2_VALFATP, "
	cQuery += " CAST( COALESCE(SF2.F2_DESCONT * SF2.F2_TXMOEDA,0) AS DECIMAL(14,2)) F2_DESCONP, "
	cQuery += " CAST( COALESCE(SF2.F2_VALMERC * SF2.F2_TXMOEDA,0) AS DECIMAL(14,2)) F2_VALMERP, "
	cQuery += " CAST( COALESCE(SF2.F2_BASIMP1 * SF2.F2_TXMOEDA,0) AS DECIMAL(14,2)) F2_BASIM1P, "
	cQuery += " CAST( COALESCE(SF2.F2_VALIMP1 * SF2.F2_TXMOEDA,0) AS DECIMAL(14,2)) F2_VALIM1P, "
	cQuery += " SF2.F2_MOEDA, SF2.F2_TXMOEDA, SF2.F2_FLFTEX, SF2.F2_DOC, SF2.F2_SERIE, ?"   
	cQuery += " SA1.A1_COD, SA1.A1_LOJA, SF2.F2_TIPO, SF2.F2_TIPODOC, SF2.F2_FILIAL, SF2.F2_ESPECIE, SF2.R_E_C_N_O_ AS REGSF2,"
	cQuery += " ?  AS CLAVE"
	cQuery += " FROM " + RetSqlName("SF2") + " SF2 "
	cQuery += " INNER JOIN " + RetSqlName("SA1") + " SA1 ON SA1.A1_FILIAL = ? AND SA1.A1_COD = SF2.F2_CLIENTE AND SA1.A1_LOJA = SF2.F2_LOJA AND SA1.D_E_L_E_T_ = ?"
	cQuery += " LEFT JOIN  " + RetSqlName("SE4") + " SE4 ON SE4.E4_FILIAL = ? AND SE4.E4_CODIGO = SF2.F2_COND AND SE4.D_E_L_E_T_ = ?"
	cQuery += " INNER JOIN SYS_COMPANY SM0 ON SM0.M0_CODIGO = ? AND SM0.M0_CODFIL = ? AND SM0.D_E_L_E_T_ = ?"
	cQuery += " WHERE SF2.F2_FILIAL= ?"
	cQuery += "   AND SF2.F2_EMISSAO BETWEEN ? AND ?"
	cQuery += "   AND SF2.F2_CLIENTE BETWEEN ? AND ?"
	cQuery += "   AND SF2.F2_TIPODOC BETWEEN ? AND ?"
	cQuery += "   AND SF2.D_E_L_E_T_ = ?"

	// Agrega os filtros na QUERY
	For nX := 1 To Len( aFiltro )
		cQuery += " AND ? " + ' ' + " ? ? "
	Next

	cQuery := ChangeQuery(cQuery)
	oExecA := FwExecStatement():New( cQuery )
	
	oExecA:SetUnSafe( 01, cCpoSF2 )
	oExecA:SetUnSafe( 02, cCpoSE4 )
	oExecA:SetString( 03, StrTran(cChaveCTL,"+","||") )
	oExecA:SetString( 04, xFilial("SA1") ) 
	oExecA:SetString( 05, ' ' )
	oExecA:SetString( 06, xFilial("SE4") )
	oExecA:SetString( 07, ' ' )
	oExecA:SetString( 08, cEmpAnt )
	oExecA:SetString( 09, cFilAnt )
	oExecA:SetString( 10, ' ' )
	oExecA:SetString( 11, xFilial("SF2") )
	oExecA:SetString( 12, DtoS( FwDateTimeToLocal( jParams['MV_PAR01'][1] )[1] ) )
	oExecA:SetString( 13, DtoS( FwDateTimeToLocal( jParams['MV_PAR02'][1] )[1] ) )
	oExecA:SetString( 14, jParams['MV_PAR03'][1] )
	oExecA:SetString( 15, jParams['MV_PAR04'][1] )
	oExecA:SetString( 16, jParams['MV_PAR05'][1] )
	oExecA:SetString( 17, jParams['MV_PAR06'][1] )
	oExecA:SetString( 18, ' ' )
	nSeq := 18
	For nX := 1 To Len( aFiltro )
		oExecA:SetUnSafe ( nSeq += 1, aFiltro[nX, 1] )
		oExecA:SetUnSafe ( nSeq += 1, aFiltro[nX, 2] )
		oExecA:SetUnSafe ( nSeq += 1, aFiltro[nX, 3] )
	Next


	// Executa a QUERY e cria uma tabela temporaria com os dados retornados
	cAliasA := oExecA:OpenAlias( )

	// Alimenta o objeto de dados da classe para retornar ao SmartView
	While !( cAliasA )->( EOF( ) )


		self:jItems := JsonObject():new( )
		self:nRecnoSF2 := ( cAliasA )->REGSF2

		For nX := 1 To Len( self:aStruct )
			If lObfuscated .And. ( aScan( aPDFields, self:aStruct[nX][5] ) == 0 )
				self:jItems[self:aStruct[nX][1]] := FwProtectedDataUtil():ValueAsteriskToAnonymize( ( cAliasA )->&( self:aStruct[nX][5] ) )
			ElseIf LEFT(self:aStruct[nx][5],4) = "CT2_"

				cQuery := "SELECT CT2_LOTE+'/'+CT2_SBLOTE+ '/' + CT2_DOC AS CT2_DOCLSL, CT2_DATA AS CT2_DTACTB, ?"
				cQuery += " CT2_TPSALD AS CT2_TPSLD, CT2_HIST CT2_HISTO"
				cQuery += " FROM " + RetSqlName("CT2") + " CT2"
				cQuery += " INNER JOIN " + RetSqlName("CTL") + " CTL ON CTL_FILIAL = ? AND CTL_LP = ? AND CTL.D_E_L_E_T_ = ?"
				cQuery += " INNER JOIN " + RetSqlName("CV3") + " CV3 ON CV3_FILIAL = ? AND CV3_KEY = ? AND CV3.D_E_L_E_T_ = ? "
				cQuery += " WHERE CT2.R_E_C_N_O_ = CV3.CV3_RECDES"
				cQuery += "   AND CT2.D_E_L_E_T_ = ?"
				cQuery := ChangeQuery(cQuery)
				oExecB := FwExecStatement():New( cQuery )

				oExecB:SetUnSafe( 01, cCpoCT2 )
				oExecB:SetString( 02, cFilialCTL )
				oExecB:SetString( 03, "620" )
				oExecB:SetString( 04, ' ' )
				oExecB:SetString( 05, cFilialCV3 )
				oExecB:SetString( 06, ( cAliasA )->CLAVE )
				oExecB:SetString( 07, ' ' )
				oExecB:SetString( 08, ' ' )

				// Executa a QUERY e cria uma tabela temporaria com os dados retornados
				cAliasB := oExecB:OpenAlias( )
				If ( self:aStruct[nX][3] == 'date' )
					self:jItems[self:aStruct[nX][1]] := totvs.framework.treports.date.dateToTimeStamp( StoD( ( cAliasB )->&( self:aStruct[nX][5] ) ) )
				Else
					self:jItems[self:aStruct[nX][1]] := ( cAliasB )->&( self:aStruct[nX][5] )
				Endif

				// fecha tabela 
				( cAliasB )->( DbCloseArea( ) )
				oExecB:Destroy( )
				oExecB := Nil

			ElseIf ( self:aStruct[nX][3] == 'date' )
				self:jItems[self:aStruct[nX][1]] := totvs.framework.treports.date.dateToTimeStamp( StoD( ( cAliasA )->&( self:aStruct[nX][5] ) ) )
			Else
				self:jItems[self:aStruct[nX][1]] := ( cAliasA )->&( self:aStruct[nX][5] )
			Endif
		Next

		// Inclui os dados no objeto paea retorno ao SmartView
		self:processData()
		self:oData:appendData( self:jItems )

		( cAliasA )->( DbSkip( ) )

	End
	( cAliasA )->( DbCloseArea( ) )

	oExecA:Destroy( )
	oExecA := Nil

Return( self:oData )

//-------------------------------------------------------------------
/*{Protheus.doc} getSchema
@description Retorna la estructura de los campos
@return object: self:oSchema
@author Marcelo Hruschka
@since 24/05/2024
@version 1.0
*/
//------------------------------------------------------------------- 
Method getSchema() as object class salesinvoiceaccountingTReportsBusinessObject

	Local nX as numeric

	// Adiciona as propriedades dos campos que serão retornados para o SMARTView
	For nX := 1 To Len( self:aStruct )
		self:addProperty( self:aStruct[nX][1], self:aStruct[nX][2], self:aStruct[nX][3], self:aStruct[nX][4], self:aStruct[nX][5] )
	Next

Return( self:oSchema )
