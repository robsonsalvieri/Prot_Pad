#INCLUDE 'msobject.ch'
#INCLUDE 'totvs.framework.treports.integratedprovider.th'
#INCLUDE 'tlpp-core.th'
#INCLUDE 'tlpp-rest.th'
#INCLUDE 'backoffice.sv.com.purchaseslist.ch'

namespace custom.compras.purchaseslist.integratedprovider

//-------------------------------------------------------------------------------
/*{Protheus.doc} purchaseslistTReportsBusinessObject
Classe para creación del Objeto de Negocio de compras para TReports 
@author Laura Medina
@since 15/04/2023
@version 1.0
*/
//-------------------------------------------------------------------------------
@totvsFrameworkTReportsIntegratedProvider(active=.T., team="SIGACOM", tables="SF1,SD1,SF2,SD2,SA2", name="Lista detallada de compras por proveedor", country="ALL", initialRelease="12.1.2310", customTables='SF1,SD1,SF2,SD2')
class purchaseslistTReportsBusinessObject from totvs.framework.treports.integratedprovider.IntegratedProvider

	public method new() as object
	public method getData() as object
	public method getSchema() as object

	protected data aFields as array
	protected data aStruct as array
	protected data aCoins as array
	protected data jItems as json
	protected data cAliasSD as character
	protected data cDoc as character
	protected data cSerie as character
	protected data cProv as character
	protected data cLojaP as character
	protected data cItemD as character
	protected data cFilSD as character
endclass

//-------------------------------------------------------------------
/*{Protheus.doc} new
Método de instância da classe
@return object: self
@author Laura Medina
@since 15/04/2023
@version 1.0
*/
//------------------------------------------------------------------- 
method new() class purchaseslistTReportsBusinessObject

	_Super:new()

	// Define o nome do Objeto de Negócio
	self:setDisplayName( STR0005 ) // Lista de compras (proveedor)

	// Define a descrição do Objeto de Negócio
	self:setDescription( STR0005 ) // Lista de compras (proveedor)

	// Define a Área
	self:appendArea( STR0012 ) // Compras

	// Define se as perguntas terao lookup
	self:setIsLookUp( .T. )

	// Indica o pergunte que será utilizado no relatório
	If !self:setPergunte( 'MATSV091' ) // Indica o pergunte que será utilizado
		IIf(!self:setErrorStatus( 400, STR0001, STR0002 ),FwLogMsg( 'WARN',, 'Smart View',,,, STR0003,,, ),'') //'Sin Preguntas' //'¡Verifique el grupo de preguntas dado!' //'Código de error no válido, solo acepte códigos de error 4xx'
		FwLogMsg( 'WARN',, 'Smart View',,,, STR0004,,, ) /*'Grupo de preguntas no encontrado!'*/
	EndIf

	self:aFields := { "F1_DOC","F1_SERIE","F1_FORNECE","F1_LOJA","A2_NOME","A2_NREDUZ","F1_EMISSAO", "F1_DTDIGIT","F1_TXMOEDA","F1_MOEDA", "F1_ESPECIE", "D1_COD","B1_DESC","B1_UM","D1_QUANT","D1_GRUPO","D1_TIPO","D1_TES","D1_TP", "D1_CUSTO", "D1_CUSTO2", "D1_CUSTO3", "D1_CUSTO4", "D1_CUSTO5" }
	self:aCoins	 := getCoins()
	self:aStruct := getStruct1( self:aFields, self:aCoins )

Return( self )

//-------------------------------------------------------------------
/*{Protheus.doc} getData
Retorna los datos del objeto de negócio
@param oFilter, objeto, contiene el filtro del TReports
@return object: self:oData
@author Laura Medina
@since 15/04/2023
@version 1.0
*/
//------------------------------------------------------------------- 

method getData( nPage as numeric, oFilter as object ) as object class purchaseslistTReportsBusinessObject

	Local cQuery 	as character
	Local oQuery	as object
	Local cAlias 	:= GetNextAlias() as character
	Local nSkip 	as numeric
	Local nX 		as numeric
	Local aPDFields as array
	Local aImpostos	as array
	Local cCampImp	as character
	Local nDecs		as numeric
	Local nY		as numeric
	Local cFilSA2 	as character
	Local cFilSB1 	as character
	Local nImpTot 	as numeric
	Local aImposto 	as array
	Local aVlrUnit 	as array
	Local aTotal 	as array
	Local cPrefSD 	as character
	Local cNroImp	as character
	Local cEspecieF1	as character
	Local cEspecieF2	as character
	Local cFilSD1	as character
	Local cFilSD2	as character
	Local aCustomFields as array
	Local n1 as numeric
	Local jParams as json

	Local cCpoSF1 as character
	Local cCpoSD1 as character
	Local cCpoSF2 as character
	Local cCpoSD2 as character

	// Coleta os dados dos parametros
	jParams := oFilter:getParameters( )

	// Coleta os campos personalizados pelo usuário
	aCustomFields := self:getCustomFields( )

	// Coleta os campos personalizados pra agregar na query
	cCpoSF1 := getCpoUser( aCustomFields, 'SF1', 'F1', ',' )
	cCpoSD1 := getCpoUser( aCustomFields, 'SD1', 'D1', ',' )
	cCpoSF2 := getCpoUser( aCustomFields, 'SF2', 'F2', ',' )
	cCpoSD2 := getCpoUser( aCustomFields, 'SD2', 'D2', ',' )

	cEspecieF1	:= "NF"
	cEspecieF2	:= "NCP"
	nDecs			:= Msdecimais(IIF(Len(self:aCoins)>0, val(self:aCoins[1]) ,1))
	cFilSD1     := FWxFilial("SD1")
	cFilSD2     := FWxFilial("SD2")
	cFilSB1     := FWxFilial("SB1")
	cFilSA2     := FWxFilial("SA2")

	cQuery  := "SELECT SD1.D1_COD, SD1.D1_QUANT, SD1.D1_VUNIT D1_VUNIT, SD1.D1_TOTAL, SD1.D1_GRUPO, SD1.D1_TIPO, SD1.D1_TES, "
	cQuery  += 	"SD1.D1_TP, SD1.D1_CUSTO, SD1.D1_CUSTO2, SD1.D1_CUSTO3, SD1.D1_CUSTO4, SD1.D1_CUSTO5, SD1.D1_ITEM, "
	cQuery  += 	"SF1.F1_EMISSAO, SF1.F1_DTDIGIT, SF1.F1_TXMOEDA, SF1.F1_MOEDA, SF1.F1_FORNECE, SF1.F1_LOJA, SF1.F1_DOC, SF1.F1_SERIE, SF1.F1_ESPECIE, "
	cQuery  += 	"SA2.A2_COD, SA2.A2_LOJA, SA2.A2_NOME, SA2.A2_NREDUZ, "
	cQuery  += 	"SB1.B1_DESC, SB1.B1_UM, 'SD1' TABLA "
	cQuery  += "FROM " + RetSqlName( "SA2" ) + " SA2 "
	cQuery  += "INNER JOIN " + RetSqlName( "SF1" ) + " SF1 "
	cQuery  += "   ON SF1.F1_FILIAL = ? "
	cQuery  += "		AND SF1.F1_FORNECE = SA2.A2_COD "
	cQuery  += "      AND SF1.F1_LOJA = SA2.A2_LOJA "
	cQuery  += "		AND SF1.F1_ESPECIE = ? "
	cQuery  += "		AND SF1.F1_EMISSAO BETWEEN ? AND ? "
	cQuery  += " 		AND SF1.D_E_L_E_T_ = ? "
	cQuery  += "INNER JOIN " + RetSqlName( "SD1" ) + " SD1 "
	cQuery  += "	ON SD1.D1_FILIAL = ? "
	cQuery  += "		AND SD1.D1_DOC = SF1.F1_DOC "
	cQuery  += "		AND SD1.D1_SERIE = SF1.F1_SERIE "
	cQuery  += "		AND SD1.D1_FORNECE = SF1.F1_FORNECE "
	cQuery  += "		AND SD1.D1_LOJA = SF1.F1_LOJA "
	cQuery  += " 		AND SD1.D_E_L_E_T_ = ? "
	cQuery  += "INNER JOIN " + RetSqlName( "SB1" ) + " SB1 "
	cQuery  += "	ON SB1.B1_FILIAL = ? "
	cQuery  += "		AND SB1.B1_COD = SD1.D1_COD "
	cQuery  += " 	   AND SB1.B1_COD BETWEEN ? AND ? "
	cQuery  += "		AND SB1.D_E_L_E_T_ = ? "
	cQuery  += "WHERE	SA2.A2_FILIAL = ? "
	cQuery  += "   AND SA2.A2_COD BETWEEN ? AND ? "
	cQuery  += "	AND SA2.D_E_L_E_T_ = ? "
	
	cQuery  += " UNION "

	cQuery  += "SELECT SD2.D2_COD D1_COD, SD2.D2_QUANT D1_QUANT, SD2.D2_PRCVEN D1_VUNIT, SD2.D2_TOTAL D1_TOTAL, SD2.D2_GRUPO D1_GRUPO, SD2.D2_TIPO D1_TIPO, SD2.D2_TES D1_TES, "
	cQuery  += "SD2.D2_TP D1_TP, SD2.D2_CUSTO1 D1_CUSTO, SD2.D2_CUSTO2 D1_CUSTO2, SD2.D2_CUSTO3 D1_CUSTO3, SD2.D2_CUSTO4 D1_CUSTO4, SD2.D2_CUSTO5 D1_CUSTO5, SD2.D2_ITEM D1_ITEM, "
	cQuery  += "SF2.F2_EMISSAO F1_EMISSAO, SF2.F2_DTDIGIT F1_DTDIGIT, SF2.F2_TXMOEDA F1_TXMOEDA, SF2.F2_MOEDA F1_MOEDA, SF2.F2_CLIENTE F1_FORNECE, SF2.F2_LOJA F1_LOJA, SF2.F2_DOC F1_DOC, SF2.F2_SERIE F1_SERIE, SF2.F2_ESPECIE F1_ESPECIE, "
	cQuery  += "SA2.A2_COD A2_COD, SA2.A2_LOJA A2_LOJA, SA2.A2_NOME A2_NOME, SA2.A2_NREDUZ A2_NREDUZ, "
	cQuery  += "SB1.B1_DESC, SB1.B1_UM, 'SD2' TABLA  "
	cQuery  += "FROM " + RetSqlName( "SA2" ) + " SA2 "
	cQuery  += "INNER JOIN " + RetSqlName( "SF2" ) + " SF2 "
	cQuery  += "	ON SF2.F2_FILIAL = ? "
	cQuery  += "		AND SF2.F2_CLIENTE = SA2.A2_COD "
	cQuery  += "		AND SF2.F2_LOJA = SA2.A2_LOJA "
	cQuery  += "		AND SF2.F2_ESPECIE = ? "
	cQuery  += "		AND SF2.F2_EMISSAO BETWEEN ? AND ? "
	cQuery  += " 		AND SF2.D_E_L_E_T_ = ? "
	cQuery  += "INNER JOIN " + RetSqlName( "SD2" ) + " SD2 "
	cQuery  += "	ON SD2.D2_FILIAL = ? "
	cQuery  += "		AND SD2.D2_DOC = SF2.F2_DOC "
	cQuery  += "		AND SD2.D2_SERIE = SF2.F2_SERIE "
	cQuery  += "		AND SD2.D2_CLIENTE = SF2.F2_CLIENTE "
	cQuery  += "		AND SD2.D2_LOJA = SF2.F2_LOJA "
	cQuery  += " 		AND SD2.D_E_L_E_T_ = ? "
	cQuery  += "INNER JOIN " + RetSqlName( "SB1" ) + " SB1 "
	cQuery  += "	ON SB1.B1_FILIAL = ? "
	cQuery  += "		AND SB1.B1_COD = SD2.D2_COD "
	cQuery  += " 	   AND SB1.B1_COD BETWEEN ? AND ? "
	cQuery  += "		AND SB1.D_E_L_E_T_ = ? "
	cQuery  += "WHERE	SA2.A2_FILIAL = ? "
	cQuery  += "	AND SA2.A2_COD BETWEEN ? AND ? "
	cQuery  += " 	AND SA2.D_E_L_E_T_ = ? "
	
	// Executa a QUERY e cria uma tabela temporaria com os dados retornados
	cQuery := ChangeQuery( cQuery )
	
	oQuery := FwExecStatement():New()

	//Define a consulta e os parâmetros
	oQuery:SetQuery( cQuery )

	oQuery:SetString( 1, FWxFilial( 'SF1' ) )
	oQuery:SetString( 2, cEspecieF1 )
	oQuery:SetString( 3, DtoS( FwDateTimeToLocal( jParams['MV_PAR05'][1] )[1] ) )
	oQuery:SetString( 4, DtoS( FwDateTimeToLocal( jParams['MV_PAR06'][1] )[1] ) )
	oQuery:SetString( 5, ' ' )
	oQuery:SetString( 6, FWxFilial( 'SD1' ) )
	oQuery:SetString( 7, ' ' )
	oQuery:SetString( 8, cFilSB1 )
	oQuery:SetString( 9, jParams['MV_PAR03'][1] )
	oQuery:SetString( 10, jParams['MV_PAR04'][1] )
	oQuery:SetString( 11, ' ' )
	oQuery:SetString( 12, cFilSA2 )
	oQuery:SetString( 13, jParams['MV_PAR01'][1] )
	oQuery:SetString( 14, jParams['MV_PAR02'][1] )
	oQuery:SetString( 15, ' ' )

	oQuery:SetString( 16, FWxFilial( 'SF2' ) )
	oQuery:SetString( 17, cEspecieF2 )
	oQuery:SetString( 18, DtoS( FwDateTimeToLocal( jParams['MV_PAR05'][1] )[1] ) )
	oQuery:SetString( 19, DtoS( FwDateTimeToLocal( jParams['MV_PAR06'][1] )[1] ) )
	oQuery:SetString( 20, ' ' )
	oQuery:SetString( 21, FWxFilial( 'SD2' ) )
	oQuery:SetString( 22, ' ' )
	oQuery:SetString( 23, cFilSB1 )
	oQuery:SetString( 24, jParams['MV_PAR03'][1] )
	oQuery:SetString( 25, jParams['MV_PAR04'][1] )
	oQuery:SetString( 26, ' ' )
	oQuery:SetString( 27, cFilSA2 )
	oQuery:SetString( 28, jParams['MV_PAR01'][1] )
	oQuery:SetString( 29, jParams['MV_PAR02'][1] )
	oQuery:SetString( 30, ' ' )

	cQuery := oQuery:getFixQuery( )

	// cria alias
	oQuery:OpenAlias( cAlias )

	While !( cAlias )->( EOF( ) )
		// Verifica se precisa fazer o tratamento para LGPD
		aPDFields := FwProtectedDataUtil():UsrAccessPDField(__cUserID, self:aFields)
		lObfuscated := len( aPDFields ) != Len(self:aFields)
		self:jItems	:= JsonObject():new()

		DbSelectArea( ( cAlias )->TABLA )
		If ( cAlias )->TABLA == "SD2"
			DbSetOrder( 3 ) // D2_FILIAL+D2_DOC+D2_SERIE+D2_CLIENTE+D2_LOJA+D2_COD+D2_ITEM
		Else
			DbSetOrder( 1 ) // D1_FILIAL+D1_DOC+D1_SERIE+D1_FORNECE+D1_LOJA+D1_COD+D1_ITEM
		EndIf

		cPrefSD	:= Right( ( cAlias )->TABLA, 2 )

		self:cAliasSD := IIf( ( cAlias )->TABLA == "SD2", "SD2","SD1" )
		self:cFilSD   := IIf( ( cAlias )->TABLA == "SD2", cFilSD2, cFilSD1 )
		self:cDoc     := ( cAlias )->F1_DOC
		self:cSerie   := ( cAlias)->F1_SERIE
		self:cProv    := ( cAlias )->F1_FORNECE
		self:cLojaP   := ( cAlias )->F1_LOJA
		self:cItemD   := ( cAlias )->D1_ITEM

		//Obtener sumatoria de impuestos por ítem del docto fiscal.
		MsSeek(xFilial("SD1")+(cAlias)->F1_DOC+(cAlias)->F1_SERIE+(cAlias)->F1_FORNECE+(cAlias)->F1_LOJA+(cAlias)->D1_COD+Alltrim((cAlias)->D1_ITEM))
		While !((cAlias)->TABLA)->(Eof()) .And. &(cPrefSD+"_FILIAL")+&(cPrefSD+"_DOC")+&(cPrefSD+"_SERIE")+IIF((cAlias)->TABLA == "SD2",&(cPrefSD+"_CLIENTE"),&(cPrefSD+"_FORNECE"))+&(cPrefSD+"_LOJA")+&(cPrefSD+"_COD")+Alltrim(&(cPrefSD+"_ITEM"))==(xFilial("SD1")+(cAlias)->F1_DOC+(cAlias)->F1_SERIE+(cAlias)->F1_FORNECE+(cAlias)->F1_LOJA+(cAlias)->D1_COD+Alltrim((cAlias)->D1_ITEM))
			nImpTot := 0
			aVlrUnit := {}
			aImposto := {}
			aTotal	 := {}

			// Trae todos los impuestos configurados en la TES del ítem del documento que se está procesando.
			aImpostos := TesImpInf( ( cAlias )->D1_TES )

			// Sumariza los impuestos del ítem del documento que se está procesando.
			For nY:=1 to Len( aImpostos )
				cCampImp:= (cAlias)->TABLA + "->" + (aImpostos[nY][2])
				//Sumatoria de impuestos
				nImpTot	+= &cCampImp
			Next

			//Realiza la conversión de Vlr. Unit, Imposto y total a las diferentes monedas de aCoins
			For nY := 1 to Len(self:aCoins)
				//Valor unitario
				aAdd(aVlrUnit,xMoeda((cAlias)->D1_VUNIT,(cAlias)->F1_MOEDA,nY,(cAlias)->F1_EMISSAO,nDecs+1,(cAlias)->F1_TXMOEDA))
				//Impuestos
				aAdd(aImposto,xMoeda(nImpTot,(cAlias)->F1_MOEDA,nY,(cAlias)->F1_EMISSAO,nDecs+1,(cAlias)->F1_TXMOEDA))
				//Total
				aAdd(aTotal,xMoeda( &(cPrefSD+"_TOTAL"),(cAlias)->F1_MOEDA,nY,(cAlias)->F1_EMISSAO,nDecs+1,(cAlias)->F1_TXMOEDA))
			Next
			((cAlias)->TABLA)->(DBSkip())
		End

		For nX := 1 To Len(self:aStruct)
			if lObfuscated .and. aScan(aPDFields, self:aStruct[nX][5]) == 0
				cContVar := ""
				If 	"D1_VUNIT" $ self:aStruct[nx][5]  //Valor unitario
					cContVar := Iif(Len(aVlrUnit)>0,  aVlrUnit[VAL(Substr(self:aStruct[nx][5],Len(self:aStruct[nx][5]),1))] , 0)
				ElseIf 	"D1_IMPOSTO" $ self:aStruct[nx][5]  //Sumatorio de impuestos
					cContVar :=  Iif(Len(aImposto)>0, aImposto[VAL(Substr(self:aStruct[nx][5],Len(self:aStruct[nx][5]),1))], 0)
				ElseIf 	"D1_TOTAL" $ self:aStruct[nx][5]   //Total
					cContVar := Iif(Len(aTotal)>0, aTotal[VAL(Substr(self:aStruct[nx][5],Len(self:aStruct[nx][5]),1))], 0)
				Else
					cContVar:= (cAlias)->&(self:aStruct[nX][5])
				Endif
				self:jItems[self:aStruct[nX][1]] := FwProtectedDataUtil():ValueAsteriskToAnonymize(cContVar)
			else
				If self:aStruct[nx][3] == 'date'
					self:jItems[self:aStruct[nX][1]] := totvs.framework.treports.date.dateToTimeStamp( StoD( ( cAlias )->&( self:aStruct[nX][5] ) ) )
				ElseIf 	"D1_VUNIT" $ self:aStruct[nx][5]  //Valor unitario
					self:jItems[self:aStruct[nX][1]] := Iif(Len(aVlrUnit)>0,  aVlrUnit[VAL(Substr(self:aStruct[nx][5],Len(self:aStruct[nx][5]),1))] , 0)
				ElseIf 	"D1_IMPOSTO" $ self:aStruct[nx][5]  //Sumatorio de impuestos
					self:jItems[self:aStruct[nX][1]] :=  Iif(Len(aImposto)>0, aImposto[VAL(Substr(self:aStruct[nx][5],Len(self:aStruct[nx][5]),1))], 0)
				ElseIf 	"D1_TOTAL" $ self:aStruct[nx][5]   //Total
					self:jItems[self:aStruct[nX][1]] := Iif(Len(aTotal)>0, aTotal[1], 0)
				Else
					self:jItems[self:aStruct[nX][1]] := (cAlias)->&(self:aStruct[nX][5])
				Endif
			endif
		next

		self:processData()
		self:oData:appendData(self:jItems)

		(cAlias)->(DBSkip())
	End

	(cAlias)->(DBCloseArea())

	// fecha objeto
	If oQuery <> Nil
		oQuery:Destroy()
		oQuery := NIL
		FwFreeObj(oQuery)
	EndIf

return self:oData


//-------------------------------------------------------------------
/*{Protheus.doc} getSchema
Retorna la estructura de los campos
 
@return object: self:oSchema
 
@author Laura Medina
@since 20/04/2023
@version 1.0
*/
//-------------------------------------------------------------------     
method getSchema() as object class purchaseslistTReportsBusinessObject
	Local nX as numeric

//Estructura con los campos para el objeto de negocios.
	For nX:=1 To Len(self:aStruct)
		self:addProperty(self:aStruct[nX][1],self:aStruct[nX][2],self:aStruct[nX][3],self:aStruct[nX][4],self:aStruct[nX][5])
	Next nX

return self:oSchema


//-------------------------------------------------------------------
/*{Protheus.doc} getStruct1
Prepara a estrutura de los campos
 
@param aCpos array: Array com os campos del relatorio.
@param aCoins array: Array com las monedas
@return aCpoTmp array: Array com a estrutura dos campos
 
@author Laura Medina
@since 15/04/2023
@version 1.0
*/
//-------------------------------------------------------------------
function getStruct1(aCpos, aCoins)

	Local aDeParaCpo as array
	Local aCpoTmp    as array
	Local cCampo     as character
	Local cTipR      as character
	Local nPos       as numeric
	Local nC         as numeric
	Local cNroImp	 as character

	aDeParaCpo := {{"C", "string"}, {"D", "date"}, {"N", "number"}, {"L", "boolean"}, {"M", "string"}}
	aCpoTmp    := {}

	for nC := 1 to Len(aCpos)
		cCampo := aCpos[nC]
		cTipo := GetSx3Cache(cCampo, "X3_TIPO")

		If (nPos := aScan(aDeParaCpo, {|c| c[01] = cTipo})) > 0
			cTipR := aDeParaCpo[nPos, 02]
		Endif

		Aadd(aCpoTmp, {strTran(cCampo, "_", ""), FWSX3Util():GetDescription(cCampo), cTipR, GetSx3Cache(cCampo, 'X3_TITSPA'), cCampo})

	next nC

	//Campos que son calculados y no existen fisicamente en las tablas (SD1/SD2).
	If Len(aCpos) > 0
		For nC:=1 To Len(aCoins)
			cNroImp := Alltrim(Str(nC))
			Aadd(aCpoTmp, {strTran("D1_VUNIT"+cNroImp, "_", ""), STR0006,"number",STR0007+cNroImp, "D1_VUNIT"+cNroImp}) // "Valor Unitario",  "Valor Unit"
			Aadd(aCpoTmp, {strTran("D1_IMPOSTO"+cNroImp, "_", ""), STR0008,"number",STR0009+cNroImp, "D1_IMPOSTO"+cNroImp}) // "Impuesto" , "Impuesto Mon. "
			Aadd(aCpoTmp, {strTran("D1_TOTAL"+cNroImp, "_", ""), STR0010,"number",STR0011+cNroImp, "D1_TOTAL"+cNroImp}) // "Valor", "Valor Mon. "
		Next
	Endif

return (aCpoTmp)

//-------------------------------------------------------------------
/*{Protheus.doc} getCoins
Prepara a estrutura de las monedas
 
@param nCoins numeric: Monedas usadas (5)
@return array: Array con la estructura de las monedas
 
@author Laura Medina
@since 19/04/2023
@version 1.0
*/
//-------------------------------------------------------------------
Function getCoins()

	Local aCoins as array
	Local nX as numeric
	Local nCoins as numeric
	aCoins	:= {}
	nCoins	:= 5 //Moedfin() //Trae las monedas

	For nX:= 1 to nCoins
		Aadd(aCoins,Alltrim(Str(nX)) )
	Next nX

Return (aCoins)
