#INCLUDE 'msobject.ch'
#INCLUDE 'tlpp-core.th'
#INCLUDE 'tlpp-rest.th'
#INCLUDE 'totvs.framework.treports.integratedprovider.th'
#INCLUDE 'backoffice.sv.fat.FinancialMovements.ch'
//-------------------------------------------------------------------------------
/*{Protheus.doc} MovsEntradaSalidaTReportsBusinessObject
Classe para criação do Objeto de Negocio de faturamento para SmartView
@author Leonardo Pereira
@since 24/08/2023
@version 1.0
*/
//-------------------------------------------------------------------------------
namespace custom.faturamento.MovsEntradaSalida.integratedprovider

// Annotation
@totvsFrameworkTReportsIntegratedProvider( active=.T., team='SIGAFAT', tables='SA1,SA2,SB1,SD1,SD2,SF1,SF2', name='Notas de crédito - Cte o Prov', country='ALL', initialRelease='12.1.2310', customTables='SB1,SD1,SF1' )
class MovsEntradaSalidaTReportsBusinessObject from totvs.framework.treports.integratedprovider.IntegratedProvider

	public Method new() as object
	public Method getData() as object
	public Method getSchema() as object

	protected data aFields as array
	protected data aStruct as array

endclass

//-------------------------------------------------------------------
/*{Protheus.doc} NEW
Método de instância da classe: Define a lista de importações que serão acessados no objeto de negocios
@return object: self
@author Leonardo Pereira
@since 24/08/2023
@version 1.0
*/
//------------------------------------------------------------------- 
Method new() class MovsEntradaSalidaTReportsBusinessObject

	Local aCpos as array
	Local cOpTemp as character

	aCpos := { }

	_Super:new()

	// Define a Área
	self:appendArea( STR0018 ) //'Faturamento'

	//Define o nome do Objeto de Negócio
	self:setDisplayName( STR0014 ) // 'Notas de crédito - Cte o Prov'

	//Define a descrição do Objeto de Negócio
	self:setDescription( STR0014 ) // 'Notas de crédito - Cte o Prov'

	// Define se as perguntas terao lookup
	self:setIsLookUp( .T. )

	// Indica o pergunte que será utilizado no relatório
	If !self:setPergunte( 'MATSV465B' ) // Indica o pergunte que será utilizado
		IIf(!self:setErrorStatus( 400, STR0001, STR0002 ),FwLogMsg( 'WARN',, 'Smart View',,,, STR0003,,, ),'') //'Sin Preguntas' //'¡Verifique el grupo de preguntas dado!' //'Código de error no válido, solo acepte códigos de error 4xx'
		FwLogMsg( 'WARN',, 'Smart View',,,, STR0004 ,,, ) // 'Grupo de preguntas no encontrado!'
	EndIf

	// Adiciona os campos virtuais/calculados
	aAdd( aCpos, { 'F1_DESMOE' , STR0005, 'string', STR0006 } ) // 'Descripción de la moneda'## 'Desc. Moneda'
	aAdd( aCpos, { 'F1_IMP01'  , STR0007, 'number', STR0008 } ) // 'Impuesto No Incluso' ## 'Imp. N Incluso'
	aAdd( aCpos, { 'F1_IMP02'  , STR0009, 'number', STR0010 } ) // 'Impuesto Incluso' ## 'Imp. Incluso'
	aAdd( aCpos, { 'F1_FORNECE', STR0011, 'string', STR0011 } ) // 'Proveedor/Cliente'
	aAdd( aCpos, { 'D1_TES'    , STR0012, 'string', STR0013   } ) // 'Tipo de Entrada/Saida' ## 'TES'

	// Define os campos que serão retornados no objeto de negocios
	self:aFields := { "F1_FILIAL", "F1_DOC", "F1_SERIE", "F1_EMISSAO", "F1_DTDIGIT", "F1_FORNECE", "F1_LOJA", "A2_NOME", "F1_ESPECIE", "F1_COND", "F1_MOEDA", "F1_TXMOEDA", "F1_DESMOE", "F1_VALBRUT", "D1_COD", "B1_DESC", "D1_TES", "F1_IMP01", "F1_IMP02", "D1_LOCAL", "D1_QUANT", "D1_VUNIT", "D1_TOTAL" }

	self:aStruct := getStrutObj( self:aFields, aCpos )
	cOpTemp := getCpoText( "F1_GERAPED", "1" )

Return( self )

//-------------------------------------------------------------------
/*{Protheus.doc} getSchema
Retorna a estrutura de campos 
@return object: self:oSchema 
@author Laura Medina
@since 20/04/2023
@version 1.0
*/
//------------------------------------------------------------------- 
Method getSchema( ) as object class MovsEntradaSalidaTReportsBusinessObject

	Local n1 as numeric

	// Adiciona as propriedades dos campos que serão retornados para o SMARTVIEW
	For n1 := 1 To Len( self:aStruct )
		self:addProperty( self:aStruct[n1][1], self:aStruct[n1][2], self:aStruct[n1][3], self:aStruct[n1][4], self:aStruct[n1][5] )
	Next

Return( self:oSchema )


//-------------------------------------------------------------------
/*{Protheus.doc} getData
Retorna os datos do objeto de negócios
@param oFilter, objeto, contém o filtro do SmartView
@return object: self:oData
@author Leonardo Pereira
@since 24/08/2023
@version 1.0
*/
//------------------------------------------------------------------- 
Method getData( nPage as numeric, oFilter as object ) as object class MovsEntradaSalidaTReportsBusinessObject

	// Declaracao de variaveis
	Local jParams 		as json
	Local jItems 		as json

	Local cQuery 		as character
	Local cAliasA := GetNextAlias() as character
	Local cFiltro 		as character
	Local cDescMon 		as character
	Local cCposSD1		as character
	Local cCposSF1		as character
	Local cCposSD2		as character
	Local cCposSF2		as character
	Local cNomCliFor	as character
	Local cFilialSA1	as character
	Local cFilialSA2	as character
	Local cCpoSB1 		as character
	Local cCpoSD1 		as character
	Local cCpoSF1 		as character

	Local nPos 			as numeric
	Local nPosMon 		as numeric
	Local nPosExp 		as numeric
	Local nCount 		as numeric
	Local n1 			as numeric
	Local nX 			as numeric
	Local nQtMoedas 	as numeric
	Local nDecs 		as numeric
	Local nTxMoeCor 	as numeric
	Local nImpDis 		as numeric
	Local nImpInc 		as numeric
	Local nPosField 	as numeric
	Local nMVPAR09 		as numeric

	Local aPDFields 	as array
	Local aNomeMoed 	as array
	Local aFiltro 		as array
	Local aParam 		as array
	Local aImpInf 		as array
	Local aStruSD1 		as array
	Local aStruSF1 		as array
	Local aStruSD2 		as array
	Local aStruSF2 		as array
	Local aCustomFields as array

	Local lObfuscated 	as logical

	Local oQueryA as object

	cDescMon 			:= ''
	cCposSD1 			:= ''
	cCposSF1 			:= ''
	cCposSD2 			:= ''
	cCposSF2 			:= ''
	cNomCliFor 			:= ''
	cFilialSA1 			:= ''
	cFilialSA2 			:= ''
	cCpoSB1 			:= ''
	cCpoSD1 			:= ''
	cCpoSF1 			:= ''

	n1 					:= 0
	nX 					:= 0
	nPos 				:= 0
	nPosMon 			:= 0
	nCount 				:= 0
	nPosExp 			:= 0
	nMVPAR09 			:= 1
	nTxMoeda 			:= 0
	nTxMoeCor 			:= 0
	nQtMoedas 			:= Moedfin()
	nImpDis 			:= 0
	nTotImpDis 			:= 0
	nImpInc 			:= 0
	nTotImpInc 			:= 0
	nPosField 			:= 0

	aPDFields 			:= { }
	aNomeMoed 			:= { }
	aFiltro 			:= { }
	aParam 				:= { }
	aImpInf 			:= { }
	aStruSD1 			:= { }
	aStruSF1 			:= { }
	aStruSD2 			:= { }
	aStruSF2 			:= { }
	aCustomFields		:= { }

	lObfuscated := .F.

	// Verifica se existem campos sensiveis na lista de campos a serem retornados
	aPDFields := FwProtectedDataUtil():UsrAccessPDField( __cUserID, self:aFields )
	lObfuscated := Len( aPDFields ) != Len( self:aFields )

	// Lista as moedas e suas descrições
	For nX := 1 To nQtMoedas
		aAdd( aNomeMoed, { AllTrim( Str( nX ) ), SuperGetMv( 'MV_MOEDA' + AllTrim( Str( nX ) ) ) } )
	Next

	// Coleta os dados dos parametros
	jParams := oFilter:getParameters( )

	nMVPAR09 := IIf( ValType( ( jParams['MV_PAR09'][1] ) ) == 'C', Val( jParams['MV_PAR09'][1] ), jParams['MV_PAR09'][1] )

	// Coleta os campos personalizados pelo usuário
	aCustomFields := self:getCustomFields( )

	// Adiciona campo customizado na estrutura de campos
	For n1 := 1 To Len( aCustomFields )
		aAdd( self:aStruct, { aCustomFields[n1, 1], aCustomFields[n1, 4], aCustomFields[n1, 3], aCustomFields[n1, 2], aCustomFields[n1, 1] } )
		aAdd( self:aFields, aCustomFields[n1, 1] )
	Next

	// Coleta os campos personalizados pra agregar na query
	cCpoSB1 := getCpoUser( aCustomFields, 'SB1', 'B1', ',' )
	cCpoSD1 := getCpoUser( aCustomFields, 'SD1', 'D1', ',' )
	cCpoSF1 := getCpoUser( aCustomFields, 'SF1', 'F1', ',' )

	// Define os dados para conversão de moedas
	nDecs := MsDecimais( nMVPAR09 )

	// Pesquisa a taxa do dia
	DbSelectArea( 'SM2' )
	SM2->( DbSetOrder( 1 ) )
	If SM2->( MsSeek( DtoS( dDataBase ) ) ) // M2_DATA
		nTxMoeCor := SM2->&( ( 'M2_MOEDA' + StrZero( nMVPAR09, 1 ) ) )
	EndIf

	// Agrega os filtros na QUERY
	If oFilter:hasFilter( )
		// Tratamento para conversão para moeda selecionada
		cFiltro := oFilter:getSQLExpression( )

		aFiltro := getParamToArr( cFiltro )

		// Ordena os parametros
		aSort( aFiltro,,, { |x, y| x[1] + x[3] < y[1] + y[3] } )

		cQuery += "AND " + getArrToParam( aFiltro ) + " "
	EndIf

	// SF1 - Campos de impostos
	aStruSF1 := SF1->( DbStruct( ) )
	While .T.
		nPos := aScan( aStruSF1, { | x | SubStr( x[1], 1, 9) == "F1_BASIMP" .Or. SubStr( x[1], 1, 9 ) == "F1_VALIMP" }, ( nPos + 1 ) )
		If ( nPos == 0 )
			Exit
		Else
			cCposSF1 += ", " + AllTrim( aStruSF1[nPos][1] )
		EndIf
	End

	// SD1 - Campos de impostos
	aStruSD1 := SD1->( DbStruct( ) )
	While .T.
		nPos := aScan( aStruSD1, { | x | SubStr( x[1], 1, 9 ) == "D1_BASIMP" .Or. SubStr( x[1], 1, 9 ) == "D1_VALIMP" }, ( nPos + 1 ) )
		If ( nPos == 0 )
			Exit
		Else
			cCposSD1 += ", " + AllTrim( aStruSD1[nPos][1] )
		EndIf
	End

	// Realiza a montagem da QUERY que será enviada para o banco de dados
	cQuery := "SELECT SF1.F1_FILIAL, SF1.F1_DOC, SF1.F1_SERIE, SF1.F1_FORNECE, SF1.F1_LOJA, SF1.F1_ESPECIE, SF1.F1_EMISSAO, SF1.F1_DTDIGIT, SF1.F1_MOEDA, SF1.F1_TXMOEDA, '' F1_DESMOE, SF1.F1_VALBRUT, SF1.F1_COND, SF1.F1_TIPO, F1_TIPODOC" + cCposSF1 + ", "
	cQuery += " SB1.B1_DESC, " + cCpoSB1
	cQuery += " SD1.D1_ITEM, SD1.D1_COD, SD1.D1_GRUPO, SD1.D1_LOCAL, SD1.D1_TES, SD1.D1_VUNIT, SD1.D1_TOTAL, SD1.D1_VALDESC, SD1.D1_QUANT" + cCposSD1 + " "
	cQuery += "FROM " + RetSQLName( 'SB1' ) + " SB1 " 
	cQuery += "INNER JOIN " + RetSQLName( 'SF1' ) + " SF1 "
	cQuery += "   ON F1_FILIAL = ? "
	cQuery += "      AND SF1.F1_EMISSAO BETWEEN ? AND ? "
	cQuery += "      AND SF1.F1_DTDIGIT BETWEEN ? AND ? "
	cQuery += "      AND SF1.F1_FORNECE BETWEEN ? AND ? "
	cQuery += "      AND SF1.F1_ESPECIE IN(?) "
	cQuery += "      AND SF1.D_E_L_E_T_ = ? "
	cQuery += "INNER JOIN " + RetSQLName( 'SD1' ) + " SD1 "
	cQuery += "   ON SD1.D1_FILIAL = ? "
	cQuery += "      AND SD1.D1_COD = SB1.B1_COD "
	cQuery += "      AND SD1.D1_DOC = SF1.F1_DOC "
	cQuery += "      AND SD1.D1_SERIE = SF1.F1_SERIE "
	cQuery += "      AND SD1.D1_TIPO = SF1.F1_TIPO "
	cQuery += "      AND SD1.D1_TIPODOC = SF1.F1_TIPODOC "
	cQuery += "      AND SD1.D1_FORNECE = SF1.F1_FORNECE "
	cQuery += "      AND SD1.D1_LOJA = SF1.F1_LOJA "
	cQuery += "      AND SD1.D1_COD BETWEEN ? AND ? "
	cQuery += "      AND SD1.D_E_L_E_T_ = ? "
	cQuery += "WHERE SB1.B1_FILIAL = ? "
	cQuery += "      AND SB1.D_E_L_E_T_ = ? "
	
	// SF2 - Campos de impostos
	aStruSF2 := SF2->( DbStruct( ) )
	While .T.
		nPos := aScan( aStruSF2, { | x | SubStr( x[1], 1, 9) == "F2_BASIMP" .Or. SubStr( x[1], 1, 9 ) == "F2_VALIMP" }, ( nPos + 1 ) )
		If ( nPos == 0 )
			Exit
		Else
			cCposSF2 += ", " + AllTrim( aStruSF2[nPos][1] ) + ' ' + StrTran( AllTrim( aStruSF2[nPos][1] ), 'F2', 'F1' )
		EndIf
	End

	// SD2 - Campos de impostos
	aStruSD2 := SD2->( DbStruct( ) )
	While .T.
		nPos := aScan( aStruSD2, { | x | SubStr( x[1], 1, 9 ) == "D2_BASIMP" .Or. SubStr( x[1], 1, 9 ) == "D2_VALIMP" }, ( nPos + 1 ) )
		If ( nPos == 0 )
			Exit
		Else
			cCposSD2 += ", " + AllTrim( aStruSD2[nPos][1] ) + ' ' + StrTran( AllTrim( aStruSD2[nPos][1] ), 'D2', 'D1' )
		EndIf
	End

	// Realiza a montagem da QUERY que será enviada para o banco de dados
	cQuery += "UNION "
	cQuery += "SELECT SF2.F2_FILIAL F1_FILIAL, SF2.F2_DOC F1_DOC, SF2.F2_SERIE F1_SERIE, SF2.F2_CLIENTE F1_FORNECE, SF2.F2_LOJA F1_LOJA, SF2.F2_ESPECIE F1_ESPECIE, SF2.F2_EMISSAO F1_EMISSAO, SF2.F2_DTDIGIT F1_DTDIGIT, SF2.F2_MOEDA F1_MOEDA, SF2.F2_TXMOEDA F1_TXMOEDA, '' F1_DESMOE, SF2.F2_VALBRUT F1_VALBRUT, SF2.F2_COND F1_COND, SF2.F2_TIPO F1_TIPO, SF2.F2_TIPODOC F1_TIPODOC" + cCposSF2 + ", "
	cQuery += " SB1.B1_DESC, " + cCpoSB1
	cQuery += " SD2.D2_ITEM D1_ITEM, SD2.D2_COD D1_COD, SD2.D2_GRUPO D1_GRUPO, SD2.D2_LOCAL D1_LOCAL, SD2.D2_TES D1_TES, SD2.D2_PRCVEN D1_VUNIT, SD2.D2_TOTAL D1_TOTAL, SD2.D2_DESCON D1_VALDESC, SD2.D2_QUANT D1_QUANT" + cCposSD2 + " "
	cQuery += "FROM " + RetSQLName( 'SB1' ) + " SB1 "
	cQuery += "INNER JOIN " + RetSQLName( 'SF2' ) + " SF2 "
	cQuery += "   ON SF2.F2_FILIAL = ? "
	cQuery += "      AND SF2.F2_EMISSAO BETWEEN ? AND ? "
	cQuery += "      AND SF2.F2_DTDIGIT BETWEEN ? AND ? "
	cQuery += "      AND SF2.F2_CLIENTE BETWEEN ? AND ? "
	cQuery += "      AND SF2.F2_ESPECIE IN(?) "
	cQuery += "      AND SF2.D_E_L_E_T_ = ? "
	cQuery += "INNER JOIN " + RetSQLName( 'SD2' ) + " SD2 "
	cQuery += "   ON D2_FILIAL = ? "
	cQuery += "      AND SD2.D2_DOC = SF2.F2_DOC "
	cQuery += "      AND SD2.D2_SERIE = SF2.F2_SERIE "
	cQuery += "      AND SD2.D2_TIPO = SF2.F2_TIPO "
	cQuery += "      AND SD2.D2_TIPODOC = SF2.F2_TIPODOC "
	cQuery += "      AND SD2.D2_CLIENTE = SF2.F2_CLIENTE "
	cQuery += "      AND SD2.D2_LOJA = SF2.F2_LOJA "
	cQuery += "      AND SD2.D2_COD BETWEEN ? AND ? "
	cQuery += "      AND SD2.D_E_L_E_T_ = ? "
	cQuery += "WHERE B1_FILIAL = ? "
	cQuery += "      AND SB1.B1_COD = SD2.D2_COD "
	cQuery += "      AND SB1.D_E_L_E_T_ = ? "
	
	cQuery := ChangeQuery( cQuery )

	// Executa a QUERY e cria uma tabela temporaria com os dados retornados
	oQueryA := FwExecStatement():New()

	//Define a consulta e os parâmetros
	oQueryA:SetQuery( cQuery )
	
	oQueryA:SetString( 1, FWxFilial( 'SF1' ) )
	oQueryA:SetString( 2, DtoS( FwDateTimeToLocal( jParams['MV_PAR03'][1] )[1] ) )
	oQueryA:SetString( 3, DtoS( FwDateTimeToLocal( jParams['MV_PAR04'][1] )[1] ) )
	oQueryA:SetString( 4, DtoS( FwDateTimeToLocal( jParams['MV_PAR07'][1] )[1] ) )
	oQueryA:SetString( 5, DtoS( FwDateTimeToLocal( jParams['MV_PAR08'][1] )[1] ) )
	oQueryA:SetString( 6, jParams['MV_PAR05'][1] )
	oQueryA:SetString( 7, jParams['MV_PAR06'][1] )
	oQueryA:SetIn( 8, { 'NCC', 'NCI'} )
	oQueryA:SetString( 9, ' ' )
	oQueryA:SetString( 10, FWxFilial( 'SD1' ) )
	oQueryA:SetString( 11, jParams['MV_PAR01'][1] )
	oQueryA:SetString( 12, jParams['MV_PAR02'][1] )
	oQueryA:SetString( 13, ' ' )
	oQueryA:SetString( 14, FWxFilial( 'SB1' ) )
	oQueryA:SetString( 15, ' ' )
	
	oQueryA:SetString( 16, FWxFilial( 'SF2') )
	oQueryA:SetString( 17, DtoS( FwDateTimeToLocal( jParams['MV_PAR03'][1] )[1] ) )
	oQueryA:SetString( 18, DtoS( FwDateTimeToLocal( jParams['MV_PAR04'][1] )[1] ) )
	oQueryA:SetString( 19, DtoS( FwDateTimeToLocal( jParams['MV_PAR07'][1] )[1] ) )
	oQueryA:SetString( 20, DtoS( FwDateTimeToLocal( jParams['MV_PAR08'][1] )[1] ) )
	oQueryA:SetString( 21, jParams['MV_PAR05'][1] )
	oQueryA:SetString( 22, jParams['MV_PAR06'][1] )
	oQueryA:SetIn( 23, { 'NCP', 'NCE'} )
	oQueryA:SetString( 24, ' ' )
	oQueryA:SetString( 25, FWxFilial( 'SD2' ) )
	oQueryA:SetString( 26, jParams['MV_PAR01'][1] )
	oQueryA:SetString( 27, jParams['MV_PAR02'][1] )
	oQueryA:SetString( 28, ' ' )
	oQueryA:SetString( 29, FWxFilial( 'SB1' ) )
	oQueryA:SetString( 30, ' ' )

	// cria alias
	oQueryA:OpenAlias( cAliasA )

	// Alimenta o objeto de dados da classe para retornar ao SmartView
	cFilialSA1 := FWxFilial( 'SA1' )
	cFilialSA2 := FWxFilial( 'SA2' )

	nPosField := 0
	While !( cAliasA )->( EOF( ) )
		nPosField++
		jItems := JsonObject():new()

		aImpInf := TESImpInf( ( cAliasA )->D1_TES )

		nImpDis := 0
		nImpInc := 0
		For nX := 1 To Len( aImpInf )
			If ( aImpInf[nX][3] != '3' )
				aImpInf[nX][02] := StrTran( aImpInf[nX][02], 'D2', 'D1' )
				nImpDis += ( cAliasA )->&( aImpInf[nX][02] )
			Else
				aImpInf[nX][02] := StrTran( aImpInf[nX][02], 'D2', 'D1' )
				nImpInc += ( cAliasA )->&( aImpInf[nX][02] )
			EndIf
		Next

		If ( Alltrim(( cAliasA )->F1_ESPECIE) $ 'NCC|NCE' )
			SA1->( DbSetOrder( 1 ) ) // A1_FILIAL+A1_COD+A1_LOJA
			SA1->( MsSeek( cFilialSA1 + ( cAliasA )->F1_FORNECE + ( cAliasA )->F1_LOJA ) )
			cNomCliFor := SA1->A1_NOME
		ElseIf ( Alltrim(( cAliasA )->F1_ESPECIE) $ 'NCP|NCI' )
			SA2->( DbSetOrder( 1 ) ) // A2_FILIAL+A2_COD+A2_LOJA
			SA2->( MsSeek( cFilialSA2 + ( cAliasA )->F1_FORNECE + ( cAliasA )->F1_LOJA ) )
			cNomCliFor := SA2->A2_NOME
		EndIf

		For nX := 1 To Len( self:aStruct )
			If lObfuscated .And. ( aScan( aPDFields, self:aStruct[nX][5] ) == 0 )
				jItems[self:aStruct[nX][1]] := FwProtectedDataUtil():ValueAsteriskToAnonymize( ( cAliasA )->&( self:aStruct[nX][5] ) )
			ElseIf ( self:aStruct[nX][3] == 'date' )
				jItems[self:aStruct[nX][1]] := totvs.framework.treports.date.dateToTimeStamp( StoD( ( cAliasA )->&( self:aStruct[nX][5] ) ) )
			Else
				If ( self:aStruct[nx][5] == 'F1_DESMOE' )
					// Moneda
					nPosMon := aScan( aNomeMoed, { | x, y | AllTrim( x[1] ) == AllTrim( Str( ( cAliasA )->F1_MOEDA ) ) } )
					cDescMon := IIf( ( nPosMon > 0 ), aNomeMoed[nPosMon][2], '' )

					jItems[self:aStruct[nX][1]] := cDescMon
				ElseIf ( self:aStruct[nx][5] == 'A2_NOME' )
					jItems[self:aStruct[nX][1]] := cNomCliFor
				ElseIf ( self:aStruct[nx][5] == 'F1_IMP01' )
					If ( ( cAliasA )->F1_MOEDA != nMVPAR09 ) .And. ( nMVPAR09 == 1 )
						jItems[self:aStruct[nX][1]] := Round( xMoeda( nImpDis, ( cAliasA )->F1_MOEDA, nMVPAR09, ( cAliasA )->F1_EMISSAO, ( nDecs + 1 ),( cAliasA )->F1_TXMOEDA ), nDecs )
					Else
						jItems[self:aStruct[nX][1]] := Round( nImpDis, nDecs )
					EndIf
				ElseIf ( self:aStruct[nx][5] == 'F1_IMP02' )
					If ( ( cAliasA )->F1_MOEDA != nMVPAR09 ) .And. ( nMVPAR09 == 1 )
						jItems[self:aStruct[nX][1]] := Round( xMoeda( nImpInc, ( cAliasA )->F1_MOEDA, nMVPAR09, ( cAliasA )->F1_EMISSAO, ( nDecs + 1 ),( cAliasA )->F1_TXMOEDA ), nDecs )
					Else
						jItems[self:aStruct[nX][1]] := Round( nImpInc, nDecs )
					EndIf
				ElseIf ( self:aStruct[nx][5] == 'F1_VALBRUT' ) .Or. ( self:aStruct[nx][5] == 'D1_VUNIT' ) .Or. ( self:aStruct[nx][5] == 'D1_TOTAL' )
					If ( ( cAliasA )->F1_MOEDA != nMVPAR09 ) .And. ( nMVPAR09 == 1 )
						jItems[self:aStruct[nX][1]] := Round( xMoeda( ( cAliasA )->&( self:aStruct[nX][5] ), ( cAliasA )->F1_MOEDA, nMVPAR09, ( cAliasA )->F1_EMISSAO, ( nDecs + 1 ), ( cAliasA )->F1_TXMOEDA ), nDecs )
					Else
						jItems[self:aStruct[nX][1]] := Round( ( cAliasA )->&( self:aStruct[nX][5] ), nDecs )
					EndIf
				Else
					jItems[self:aStruct[nX][1]] := ( cAliasA )->&( self:aStruct[nX][5] )
				EndIf
			EndIf
		Next

		// Inclui os dados no objeto paea retorno ao SmartView
		self:oData:appendData( jItems )

		( cAliasA )->( DbSkip( ) )
		nCount++
	End

	( cAliasA )->( DbCloseArea( ) )

	// fecha objeto
	oQueryA:Destroy()
	oQueryA := Nil
	FwFreeObj(oQueryA)

Return( self:oData )
