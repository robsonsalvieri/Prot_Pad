#INCLUDE 'msobject.ch'
#INCLUDE 'totvs.framework.treports.integratedprovider.th'
#INCLUDE 'backoffice.sv.com.importlist.ch'

namespace custom.compras.importlist.integratedprovider

//-------------------------------------------------------------------------------
/*{Protheus.doc} backoffice.sv.com.importlist
@description Classe para creación del Objeto de Negocio de Listado de importaciones para TReports
@author Marcelo Hruschka
@since 11/11/2024
@version 1.1
*/
//-------------------------------------------------------------------------------
@totvsFrameworkTReportsIntegratedProvider( active=.T., team='SIGACOM', tables='DBA,DBB,DBC,SB1,SC7', name='Listado de importaciones', country='ALL', initialRelease='12.1.2410', customTables='DBA,DBB,DBC,SB1,SC7' )
class importlistTReportsBusinessObject from totvs.framework.treports.integratedprovider.IntegratedProvider

	public Method new() as object
	public Method getData() as object
	public Method getSchema() as object

	protected data aFields as array
	protected data aStruct as array
	protected data nRecnoDBC as numeric
	protected data jItems as json

endclass

//-------------------------------------------------------------------
/*{Protheus.doc} new
Método de instância da classe 
@Return object: self
@author Marcelo Hruschka
@since 11/11/2024
@version 1.0
*/
//-------------------------------------------------------------------
Method new() class importlistTReportsBusinessObject

	Local aCpos := {} as array

	_Super:new()

	//Define o nome do Objeto de Negócio
	self:setDisplayName( STR0001 )  // 'Listado de importaciones'

	//Define a descrição do Objeto de Negócio
	self:setDescription( STR0001 )  // 'Listado de importaciones'

	// Define a Área
	self:appendArea( STR0002 ) // 'Compras'

	// Define se as perguntas terao lookup
	self:setIsLookUp( .T. )

	// Indica o pergunte que será utilizado no relatório
	If !self:setPergunte( 'MATSV142' )
		IIf(!self:setErrorStatus( 400, STR0003, STR0004 ),FwLogMsg( 'WARN',, 'Smart View',,,, STR0005,,, ),'') // 'Sin Preguntas' // '¡Verifique el grupo de preguntas dado!' // 'Código de error no válido, solo acepte códigos de error 4xx'
		FwLogMsg( 'WARN',, 'Smart View',,,, STR0006,,, ) // 'Grupo de preguntas no encontrado!'
	EndIf

	// campos que no existen en SX3
	aAdd( aCpos, { 'SALDO_POS'	    , STR0007 , 'number'	, STR0007 } ) // 'Saldo PO'

	// demais campos
	self:aFields := { 'DBB_HAWB','DBA_DTHAWB','DBA_DT_DTA','DBA_DT_ENC','DBA_OK','DBB_DOC','DBB_EMISSA','DBB_TIPONF','DBB_MOEDA','DBB_TXMOED','DBC_ITEM','DBC_CODPRO','DBC_DESCRI','B1_GRUPO','DBC_LOCAL','DBC_UM','DBC_QUANT','DBC_PRECO','DBC_TOTAL','DBC_PEDIDO','DBC_DATPRF','DBC_ITEMPC','C7_QUANT','C7_QUJE','SALDO_POS','DBA_AGENTE'}

	self:aStruct := getStrutObj( self:aFields, aCpos )

Return( self )

//-------------------------------------------------------------------
/*{Protheus.doc} getData
Retorna los datos del objeto de negócio
@param nPage, numérico, indica la pagina actual del relatório
@param oFilter, objeto, contiene el filtro del TReports
@return object: self:oData
@author Marcelo Hruschka
@since 11/11/2024
@version 1.0
*/
//------------------------------------------------------------------- 
Method getData( nPage as numeric, oFilter as object) as object class importlistTReportsBusinessObject

	// Declaracao de variaveis
	Local cQuery		as character
	Local cFiltro 		as character

	Local nX			as numeric
	Local n1			as numeric
	Local nPosMon		as numeric
	Local nPosExp		as numeric
	Local nDecs 		as numeric
	Local nPosVis       as numeric
	Local cVisao        as character

	Local jParams 		as json

	Local aPDFields		as array
	Local aFiltro		as array
	Local aCustomFields as array

	Local dDateConv     as date

	Local lObfuscated	as logical

	Local oExecA		as object
	Local cAliasA       as character

	cFiltro 			:= ''
	cVisao 				:= ''
	cAliasA			    := ''

	nPosMon   		:= 0
	nPosExp 		:= 0
	nDecs 			:= 0
	nX 				:= 0
	n1				:= 0

	aPDFields		:= { }
	aFiltro			:= { }
	aCustomFields	:= { }

	// Verifica se existem campos sensiveis na lista de campos a serem retornados
	aPDFields := FwProtectedDataUtil():UsrAccessPDField( __cUserID, self:aFields )
	lObfuscated := Len( aPDFields ) != Len( self:aFields )

	// Coleta os dados dos parametros
	jParams := oFilter:getParameters( )

	// Coleta os campos personalizados pelo usuário
	aCustomFields := self:getCustomFields( )
	cCpoDBA := getCpoUser( aCustomFields, 'DBA', 'DBA', ',' )
	cCpoDBB := getCpoUser( aCustomFields, 'DBB', 'DBB', ',' )
	cCpoDBC := getCpoUser( aCustomFields, 'DBC', 'DBC', ',' )
	cCpoSB1 := getCpoUser( aCustomFields, 'SB1', 'B1' , ',' )
	cCpoSC7 := getCpoUser( aCustomFields, 'SC7', 'C7' , ',' )

	// Adiciona campo customizado na estrutura de campos
	For n1 := 1 To Len( aCustomFields )
		aAdd( self:aStruct, { aCustomFields[n1, 1], aCustomFields[n1, 4], aCustomFields[n1, 3], aCustomFields[n1, 2], aCustomFields[n1, 1] } )
		aAdd( self:aFields, aCustomFields[n1, 1] )
	Next

	If oFilter:hasFilter( )
		// Tratamento para conversão para moeda selecionada
		cFiltro := oFilter:getSQLExpression( )
		aFiltro := getParamToArr( cFiltro )
		// Ordena os parametros
		aSort( aFiltro,,, { |x, y| x[1] + x[3] < y[1] + y[3] } )

		// Define os dados para conversão de moedas
		nPosVis := aScan( aFiltro, { | x | AllTrim( x[1] ) == 'DBA_AGENTE' } )
		If ( nPosVis > 0 )
			cVisao := aFiltro[nPosVis, 3]
			// Exclui o elemento do Array
			aDel( aFiltro, nPosVis )
			// Redimensiona o Array
			aSize( aFiltro, ( Len( aFiltro ) - 1 ) )
		EndIf

	EndIf

	// Realiza a montagem da QUERY que será enviada para o banco de dados
	If !"MATR145" $ cVisao 
		cQuery := "SELECT DBB.DBB_HAWB,DBA.DBA_DTHAWB,DBA.DBA_DT_DTA,DBA.DBA_DT_ENC,DBA.DBA_OK,DBB.DBB_DOC,DBB.DBB_EMISSA,DBB.DBB_TIPONF, "
		cQuery += " DBB.DBB_MOEDA,DBB.DBB_TXMOED,DBC.DBC_ITEM,DBC.DBC_CODPRO,DBC.DBC_DESCRI,SB1.B1_GRUPO,DBC.DBC_LOCAL, ' ' DBA_AGENTE,"
		cQuery += " DBC.DBC_UM,DBC.DBC_QUANT,DBC.DBC_PRECO,DBC.DBC_TOTAL,DBC.DBC_PEDIDO,DBC.DBC_DATPRF,DBC.DBC_ITEMPC,SC7.C7_QUANT,SC7.C7_QUJE, "
		cQuery += " ? "
		cQuery += " ? "
		cQuery += " ? "
		cQuery += " ? "
		cQuery += " ? "
		cQuery += "(SC7.C7_QUANT - SC7.C7_QUJE) SALDO_POS, ' ' VISAO, DBC.R_E_C_N_O_  REGDBC"
		cQuery += " FROM "+RetSqlName("DBB")+" DBB "
		cQuery += " INNER JOIN "+RetSqlName("DBA")+" DBA ON DBA.DBA_FILIAL = ? AND DBA.DBA_HAWB = DBB.DBB_HAWB AND DBA.DBA_DTHAWB BETWEEN ? AND ? AND DBA.D_E_L_E_T_ = ?"
		cQuery += " INNER JOIN "+RetSqlName("DBC")+" DBC ON DBC.DBC_FILIAL = ? AND DBC.DBC_HAWB = DBB.DBB_HAWB AND DBC.DBC_ITDOC = DBB.DBB_ITEM AND DBC.DBC_CODPRO BETWEEN ? AND ? AND DBC.D_E_L_E_T_ = ?"
		cQuery += " INNER JOIN "+RetSqlName("SB1")+" SB1 ON SB1.B1_FILIAL  = ? AND SB1.B1_COD = DBC.DBC_CODPRO AND SB1.D_E_L_E_T_ = ? "
		cQuery += " LEFT  JOIN "+RetSqlName("SC7")+" SC7 ON SC7.C7_FILIAL  = ? AND SC7.C7_NUM = DBC.DBC_PEDIDO AND SC7.C7_ITEM = DBC.DBC_ITEMPC AND SC7.D_E_L_E_T_ = ?"
		cQuery += " WHERE "
		cQuery += " DBB.DBB_FILIAL = ?"
		cQuery += " AND DBA.DBA_DT_DTA BETWEEN ? AND ?"
		If jParams['MV_PAR07'][1] == 1
			cQuery += " AND (SC7.C7_QUANT - SC7.C7_QUJE) > 0"
		Endif
		cQuery += " AND DBB.D_E_L_E_T_ = ? "
		// Agrega os filtros na QUERY
		For nX := 1 To Len( aFiltro )
			cQuery += " AND " + aFiltro[nX, 1] + ' ' + aFiltro[nX, 2] + " " + aFiltro[nX, 3] + " "
		Next
	Else
		cQuery := "SELECT DBB.DBB_HAWB,DBA.DBA_DTHAWB,DBA.DBA_DT_DTA,DBA.DBA_DT_ENC,DBA.DBA_OK,'' DBB_DOC,'' DBB_EMISSA,DBB.DBB_TIPONF, "
		cQuery += " DBB.DBB_MOEDA,DBB.DBB_TXMOED,'' DBC_ITEM,'' DBC_CODPRO,'' DBC_DESCRI,'' B1_GRUPO,'' DBC_LOCAL, ' ' DBA_AGENTE,"
		cQuery += " '' DBC_UM,0 DBC_QUANT,0 DBC_PRECO,SUM(DBC.DBC_TOTAL) DBC_TOTAL,'' DBC_PEDIDO,'' DBC_DATPRF,'' DBC_ITEMPC,0 C7_QUANT,0 C7_QUJE, "
		cQuery += " ? "
		cQuery += " ? "
		cQuery += " ? "
		cQuery += " ? "
		cQuery += " ? "
		cQuery += " 0 SALDO_POS, ' ' VISAO, 0 REGDBC"
		cQuery += " FROM "+RetSqlName("DBB")+" DBB "
		cQuery += " INNER JOIN "+RetSqlName("DBA")+" DBA ON DBA.DBA_FILIAL = ? AND DBA.DBA_HAWB = DBB.DBB_HAWB AND DBA.DBA_DTHAWB BETWEEN ? AND ? AND DBA.D_E_L_E_T_ = ?"
		cQuery += " INNER JOIN "+RetSqlName("DBC")+" DBC ON DBC.DBC_FILIAL = ? AND DBC.DBC_HAWB = DBB.DBB_HAWB AND DBC.DBC_ITDOC = DBB.DBB_ITEM AND DBC.DBC_CODPRO BETWEEN ? AND ? AND DBC.D_E_L_E_T_ = ?"
		cQuery += " INNER JOIN "+RetSqlName("SB1")+" SB1 ON SB1.B1_FILIAL  = ? AND SB1.B1_COD = DBC.DBC_CODPRO AND SB1.D_E_L_E_T_ = ? "
		cQuery += " LEFT  JOIN "+RetSqlName("SC7")+" SC7 ON SC7.C7_FILIAL  = ? AND SC7.C7_NUM = DBC.DBC_PEDIDO AND SC7.C7_ITEM = DBC.DBC_ITEMPC AND SC7.D_E_L_E_T_ = ?"
		cQuery += " WHERE "
		cQuery += " DBB.DBB_FILIAL = ?"
		cQuery += " AND DBA.DBA_DT_DTA BETWEEN ? AND ?"
		If jParams['MV_PAR07'][1] == 1
			cQuery += " AND (SC7.C7_QUANT - SC7.C7_QUJE) > 0"
		Endif
		cQuery += " AND DBB.D_E_L_E_T_ = ? "
		cQuery += " GROUP BY DBB.DBB_HAWB,DBA.DBA_DTHAWB,DBA.DBA_DT_DTA,DBA.DBA_DT_ENC,DBA.DBA_OK,DBB.DBB_TIPONF,DBB.DBB_MOEDA,DBB.DBB_TXMOED"
	Endif

	cQuery := ChangeQuery(cQuery)
	oExecA := FwExecStatement():New( cQuery )

	oExecA:SetUnSafe( 01, cCpoDBA )
	oExecA:SetUnSafe( 02, cCpoDBB )
	oExecA:SetUnSafe( 03, cCpoDBC )
	oExecA:SetUnSafe( 04, cCpoSB1 ) 
	oExecA:SetUnSafe( 05, cCpoSC7 )
	oExecA:SetString( 06, xFilial("DBA") )			// DBA_FILIAL
	oExecA:SetString( 07, DtoS( FwDateTimeToLocal( jParams['MV_PAR03'][1] )[1] ) )	// DBA_DTHAWB
	oExecA:SetString( 08, DtoS( FwDateTimeToLocal( jParams['MV_PAR04'][1] )[1] ) )	// DBA_DTHAWB
	oExecA:SetString( 09, ' ' )						// DBA.D_E_L_E_T_
	oExecA:SetString( 10, xFilial("DBC") )			// DBC_FILIAL
	oExecA:SetString( 11, jParams['MV_PAR05'][1] )	// DBC_CODPRO
	oExecA:SetString( 12, jParams['MV_PAR06'][1] )	// DBC_CODPRO
	oExecA:SetString( 13, ' ' )						// DBC.D_E_L_E_T_
	oExecA:SetString( 14, xFilial("SB1") ) 			// B1_FILIAL
	oExecA:SetString( 15, ' ' )						// SB1.D_E_L_E_T
	oExecA:SetString( 16, xFilial("SC7") ) 			// C7_FILIAL
	oExecA:SetString( 17, ' ' )						// SC7.D_E_L_E_T_
	oExecA:SetString( 18, xFilial("DBB") )			// DBB_FILIAL
	oExecA:SetString( 19, jParams['MV_PAR01'][1] )	// DBB_HAWB
	oExecA:SetString( 20, jParams['MV_PAR02'][1] )	// DBB_HAWB
	oExecA:SetString( 21, ' ' )						// DBB.D_E_L_E_T_

	// Executa a QUERY e cria uma tabela temporaria com os dados retornados
	//ConOut(oExecA:getFixQuery( ))
	cAliasA := oExecA:OpenAlias( )

	// Alimenta o objeto de dados da classe para retornar ao SmartView
	While !( cAliasA )->( EOF( ) )


		self:jItems := JsonObject():new( )
		self:nRecnoDBC := ( cAliasA )->REGDBC

		// define o dia da taxa
		If jParams['MV_PAR09'][1] == 1 // 1- Movimiento 2- Dia
			dDateConv := STOD(( cAliasA )->DBB_EMISSA)
		Else
			dDateConv := dDataBase
		Endif

		For nX := 1 To Len( self:aStruct )
			If lObfuscated .And. ( aScan( aPDFields, self:aStruct[nX][5] ) == 0 )
				self:jItems[self:aStruct[nX][1]] := FwProtectedDataUtil():ValueAsteriskToAnonymize( ( cAliasA )->&( self:aStruct[nX][5] ) )
			ElseIf ( self:aStruct[nX][3] == 'date' )
				self:jItems[self:aStruct[nX][1]] := totvs.framework.treports.date.dateToTimeStamp( StoD( ( cAliasA )->&( self:aStruct[nX][5] ) ) )
			ElseIf ( self:aStruct[nX][5] == "DBC_PRECO" )
				self:jItems[self:aStruct[nX][1]] := xMoeda(( cAliasA )->DBC_PRECO,( cAliasA )->DBB_MOEDA,jParams['MV_PAR08'][1],dDateConv)
			ElseIf ( self:aStruct[nX][5] == "DBC_TOTAL" )
				self:jItems[self:aStruct[nX][1]] := xMoeda(( cAliasA )->DBC_TOTAL,( cAliasA )->DBB_MOEDA,jParams['MV_PAR08'][1],dDateConv)
			ElseIf ( self:aStruct[nX][5] == "DBB_TIPONF" )
				self:jItems[self:aStruct[nX][1]] := ( cAliasA )->&( self:aStruct[nX][5] )
				If ( cAliasA )->&( self:aStruct[nX][5] ) == '5'
					self:jItems[self:aStruct[nX][1]] := STR0012 // 'FOB'
				ElseIf ( cAliasA )->&( self:aStruct[nX][5] ) == '6'
					self:jItems[self:aStruct[nX][1]] := STR0013 // 'FLETE'
				ElseIf ( cAliasA )->&( self:aStruct[nX][5] ) == '7'
					self:jItems[self:aStruct[nX][1]] := STR0014 // 'SEGURO'
				ElseIf ( cAliasA )->&( self:aStruct[nX][5] ) == '8'
					self:jItems[self:aStruct[nX][1]] := STR0015 // 'CIF'
				ElseIf ( cAliasA )->&( self:aStruct[nX][5] ) == 'A'
					self:jItems[self:aStruct[nX][1]] := STR0016 // 'GASTOS'
				Endif
			ElseIf ( self:aStruct[nX][5] == "DBA_OK" )
				self:jItems[self:aStruct[nX][1]] := ( cAliasA )->&( self:aStruct[nX][5] )
				If ( cAliasA )->&( self:aStruct[nX][5] ) == '1' .Or. Empty(( cAliasA )->&( self:aStruct[nX][5] ))
					self:jItems[self:aStruct[nX][1]] := STR0008
				ElseIF ( cAliasA )->&( self:aStruct[nX][5] ) == '2'
					self:jItems[self:aStruct[nX][1]] := STR0009
				ElseIF ( cAliasA )->&( self:aStruct[nX][5] ) == '3' .And. EMPTY(( cAliasA )->DBA_DT_ENC)
					self:jItems[self:aStruct[nX][1]] := STR0010
				ElseIF !EMPTY(( cAliasA )->DBA_DT_ENC)
					self:jItems[self:aStruct[nX][1]] := STR0011
				Endif
			Else
				self:jItems[self:aStruct[nX][1]] := ( cAliasA )->&( self:aStruct[nX][5] )
			Endif
		Next

		// Inclui os dados no objeto paea retorno ao SmartView
		//self:processData()
		self:oData:appendData( self:jItems )

		( cAliasA )->( DbSkip( ) )

	End
	( cAliasA )->( DbCloseArea( ) )

	oExecA:Destroy( )
	oExecA := Nil

Return( self:oData )

//-------------------------------------------------------------------
/*{Protheus.doc} getSchema
@description Retorna la estructura de los campos
@return object: self:oSchema
@author Marcelo Hruschka
@since 11/11/2024
@version 1.0
*/
//------------------------------------------------------------------- 
Method getSchema() as object class importlistTReportsBusinessObject

	Local nX as numeric

	// Adiciona as propriedades dos campos que serão retornados para o SMARTView
	For nX := 1 To Len( self:aStruct )
		self:addProperty( self:aStruct[nX][1], self:aStruct[nX][2], self:aStruct[nX][3], self:aStruct[nX][4], self:aStruct[nX][5] )
	Next

Return( self:oSchema )
