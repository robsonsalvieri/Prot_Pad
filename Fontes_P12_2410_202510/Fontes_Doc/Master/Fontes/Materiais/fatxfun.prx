Static __cSx3Casas
Static __cEmpLog  := ""
Static __cFilLog  := ""
Static __lArrefat := Nil

#INCLUDE "PROTHEUS.CH"
#INCLUDE "FATXFUN.CH"
#INCLUDE "FWLIBVERSION.CH"

Static lMaAvCred	:= NIL
Static lMaAvCrPr	:= NIL
Static __oTmpTrbFat	:= NIL
Static __oTmpCG1	:= NIL
Static aLogMsg      := NIL
Static __aPrepared  := {}
Static lMTValAvC    := Nil
Static lMTVALEMP    := Nil
Static lRskIsAct    := Nil
Static __lMetric	:= Nil
Static lFATTRVSA1   := ExistBlock("FATTRVSA1")
Static _lMetricsSC5 := .T.
Static cTxtLogC 	:= ""
Static cTxtLogE 	:= ""
Static cBlCreAux	:= ""
Static __oEstLibP	:= Nil
Static __RpoRelease	:= GetRPORelease()

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³FATXFUN   ³ Autor ³ Eduardo Riera         ³ Data ³ 31.08.2001³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Biblioteca de funcoes das rotinas de vendas                  ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³Materiais                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Descri‡…o ³ PLANO DE MELHORIA CONTINUA                                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ITEM PMC  ³Responsavel               ³Data          |BOPS:             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³      01  ³                          ³              |                  ³±±
±±³      02  ³Flavio Luiz Vicco         ³13/04/2006    |00000096972       ³±±
±±³      03  ³                          ³              |                  ³±±
±±³      04  ³                          ³              |                  ³±±
±±³      05  ³                          ³              |                  ³±±
±±³      06  ³                          ³              |                  ³±±
±±³      07  ³                          ³              |                  ³±±
±±³      08  ³                          ³              |                  ³±±
±±³      09  ³                          ³              |                  ³±±
±±³      10  ³Flavio Luiz Vicco         ³13/04/2006    |00000096762       ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³A440Grava ³ Rev.  ³ Eduardo Riera         ³ Data ³ 10.03.99 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Gravacao da Liberacao do Pedido via Mata440                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpL1: lGravou                                              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpL1: Liberacao Parcial                                    ³±±
±±³          ³ExpL2: Transfere Locais                                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Observacao³Deve estar numa transacao                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³   DATA   ³ Programador   ³Manutencao Efetuada                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³20/07/2006³Erike Yuri     ³Alteracao das ref. de grade para objeto     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/

Function A440Grava(lLiber,lTransf)

Local lGrade   := MaGrade() .And. MaReadGrd()<>NIL
Local bCampo   := {|n| FieldName(n) }
Local nCntFor  := 0
Local nCntFor2 := 0
Local nMaxFor  := Len(aCols)
Local nQtdLib  := 0
Local nQtdLib2 := 0
Local lLiberOk := .T.
Local lCredito := .F.
Local lEstoque := .F.
Local lItLib   := .F.
Local nPosItem := GDFieldPos("C6_ITEM")
Local nPosProd := GDFieldPos("C6_PRODUTO")
Local lIntegDef		:= ExistFunc("GETROTINTEG") .And. ExistFunc("FWHASEAI") .And. FWHasEAI("MATA410B",.T.,,.T.)//Integracao e rastreabilidade de pedidos ativa 
Local lUseGRR  := FindFunction( "GRRIsActive" ) .And. GRRIsActive()

Private lbloqDCF := !Empty(SC9->C9_BLCRED+SC9->C9_BLEST)
Private nValItPed := 0

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Se Grade estiver ativa, grava Acols conforme AcolsGrade      ³
//³ para depois continuar a gravar como um pedido comum          ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If ( lGrade )
	If "MATA410" $ SuperGetMV("MV_GRDMULT",.F.,"")
		aCols := aGradeCols(oGrade,aCols,aHeader,"C6_PRODUTO","C6_ITEMGRD","C6_QTDVEN","C6_ITEM")
	Else
		Ma410GraGr()
	EndIf
	nMaxFor := Len(aCols)
EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Grava arquivo SC5                                       ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Begin Transaction
dbSelectArea("SC5")
RecLock("SC5")
For nCntFor := 1 To FCount()
	If ( "FILIAL" $ FieldName(nCntFor) )
		SC5->(FieldPut(nCntFor,xFilial("SC5")))
	Else
		SC5->(FieldPut(nCntFor,M->&(EVAL(bCampo,nCntFor))))
	EndIf
Next nCntFor
End Transaction
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Grava arquivo SC6                                                      ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
dbSelectArea("SC6")
dbSetOrder(1)
MsSeek(xFilial("SC6")+M->C5_NUM)
For nCntFor := 1 To nMaxFor
	//Esta alteração foi necessária devido ao ponto de entrada "MA440SC6" permitir que itens sejam exibidos
	//ou não no momento da liberação do pedido e com isso o aCols vem com uma quantidade menor de itens.
	If SC6->C6_ITEM+SC6->C6_PRODUTO <> aCols[nCntFor][nPosItem]+aCols[nCntFor][nPosProd]
		MsSeek(xFilial("SC6")+M->C5_NUM+aCols[nCntFor][nPosItem]+aCols[nCntFor][nPosProd])
	EndIf
	Begin Transaction
	RecLock("SC6")
	For nCntFor2 := 1 To Len(aHeader)
		If ( aHeader[nCntFor2][10] <> "V" )
			SC6->(FieldPut(FieldPos(aHeader[nCntFor2][2]),aCols[nCntFor][nCntFor2]))
		EndIf
	Next nCntFor2
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Efetua a Liberacao do Pedido por Item de Pedido                         ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If SC6->C6_QTDLIB <> 0 .Or. (MaTesSel(SC6->C6_TES) .And. MaTesLZero()) .Or. Ma440Compl()
		lItLib := .T.
		If ( SC5->C5_TIPLIB<>"2" )
			nQtdLib := SC6->C6_QTDLIB
			nQtdLib2:= If( Empty( SC6->C6_QTDLIB2 ), NIL, SC6->C6_QTDLIB2 )
			nQtdLib := MaLibDoFat(SC6->(RecNo()),nQtdLib,@lCredito,@lEstoque,.T.,.T.,lLiber,lTransf,NIL,NIL,NIL,NIL,NIL,NIL,nQtdLib2)
		EndIf
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Verifica se Todos os Itens foram Liberados                              ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If ( SC6->C6_QTDVEN > SC6->C6_QTDEMP + SC6->C6_QTDENT .And. lLiberOk .And. AllTrim(SC6->C6_BLQ)<>"R")
		lLiberOk := .F.
	EndIf
	If lLiberOk
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ PCO - Grava o lancamentos de liberacao do item do pedido de venda ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		PcoDetLan("000103","01","MATA440")
	EndIf
	End Transaction
	dbSelectArea("SC6")
	dbSkip()
Next nCntFor
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Liberacao por Pedido                                                    ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Begin Transaction
If ( SC5->C5_TIPLIB=="2" .And. lItLib )
	MaAvLibPed(SC5->C5_NUM,lLiber,lTransf,@lLiberOk)
EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Atualiza do C5_LIBEROK                                                  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If ( lLiberOk )
	dbSelectArea("SC5")
	RecLock("SC5")
	SC5->C5_LIBEROK := "S"
	MsUnlock()
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ PCO - Grava o lancamento de liberacao de pedido de venda ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	PcoDetLan("000103","02","MATA440")
					
	If lIntegDef                
		FwIntegDef("MATA410B")
	EndIf
	
EndIf

// ======================================================================
// Integração GRR - Gestão de Receita Recorrente 
// Envia o pedido de venda para a plataforma GRR
// ======================================================================
If lUseGRR .And. lLiberOk .And. FindFunction( "IsGRRPayment" ) .And. IsGRRPayment( SC5->C5_CONDPAG )
	// pedido de venda gerado direto pelo faturamento
	IF FindFunction( "GRRI050" ) .And. Empty( alltrim( SC5->C5_MDCONTR ) )	
		GRRI050( { SC5->C5_FILIAL, SC5->C5_NUM } )
	// pedido de venda gerado a partir de um contrato
	ElseIf !Empty( alltrim( SC5->C5_MDCONTR ) ) .And. FindFunction( "GRRI050A" ) 
		GRRI050A( { SC5->C5_FILIAL, SC5->C5_MDCONTR, '', SC5->C5_MDPLANI, SC5->C5_MDNUMED, SC5->C5_NUM  } )
	EndIf
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Ponto de entrada para todos os itens do pedido.     ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If ( ExistTemplate("MTA410T") )
	ExecTemplate("MTA410T",.f.,.f.)
EndIf

If ( ExistBlock("MTA410T") )
	ExecBlock("MTA410T",.f.,.f.)
EndIf

If ExistBlock("MAAVSC5")
	ExecBlock("MAAVSC5",.F.,.F.,{3})
EndIf

End Transaction
Return(.T.)

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³A440VerSb2³ Rev.  ³ Eduardo Riera         ³ Data ³15.03.99  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Verifica o Estoque quanto a quantidade liberada             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpL1: Indica se o estoque foi liberado                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpN1: Quantidade a ser liberada                            ³±±
±±³          ³ExpL2: Permite Liberacao Parcial                            ³±±
±±³          ³ExpL3: Permite transferencia de Locais automaticamente      ³±±
±±³          ³ExpA4: Array com os locais de transferencia                 ³±±
±±³          ³ExpA5: Empenhos ( Caso seja informado nao efetua a gravacao ³±±
±±³          ³       apenas avalia ).                                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Observacao³O SC6 deve estar posicionado                                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³   DATA   ³ Programador   ³Manutencao Efetuada                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³               ³                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function A440VerSB2(nQtdLib,lLiber,lTransf,aLocal,aEmpenho,lVerPar,nSldProd)

Local cFiltro  := ""
Local cLocCq   := SuperGetMV('MV_CQ', .F., '98')
Local lRetorno := .F.
Local nSaldo   := 0
Local nDecimal := TamSx3("B2_QATU")[2]
Local nRegEmp  := 0
Local nSldSB2  := 0
Local nQtdJaEmp:= 0
Local cLocCQOri:= ''
Local aSaldoCQ := {}
Local nSaldoCQ := 0
Local nQtd440L := 0
Local nQtdEmp  := 0
Local aEmpBN   := If(FindFunction("A410CarBen"),A410CarBen(SC6->C6_NUM,SC6->C6_ITEM),{})
Local nX		 := 0
Local lConsTerc:= .F.
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Parametros default                                                      ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
DEFAULT lLiber   := .F.
DEFAULT lTransf  := .F.
DEFAULT aLocal   := {}
DEFAULT lVerPar  := .T.
DEFAULT nSldProd := 0

cLocCQOri := cLocCq //-- Inicializa variavel somente com o Armazem de CQ

If ( ExistBlock("MTA440A") )
	cFiltro := ExecBlock("MTA440A")
	If !Empty(cFiltro) .And. (ValType(cFiltro) == "C")
		cLocCQ += "/"+cFiltro
	EndIf
EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Verifica a movimentacao de Estoque.                                     ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
dbSelectArea("SF4")
dbSetOrder(1)
If ( MsSeek(xFilial("SF4")+SC6->C6_TES) )
	If ( SF4->F4_ESTOQUE == "S" )
		If !Empty(aEmpBN)
			//-- Chama funcao para baixar empenho caso haja remessa para terceiros
			For nX := 1 To Len(aEmpBN)
				nQtdEmp += A410LibBen(1,aEmpBN[nX,1],aEmpBN[nX,2],SC6->C6_QTDVEN,SC6->C6_UNSVEN)
			Next nX
		EndIf
		dbSelectArea("SB1")
		dbSetOrder(1)
		MsSeek(xFilial("SB1")+SC6->C6_PRODUTO)
		dbSelectArea("SB2")
		dbSetOrder(1)
		If ( MsSeek(xFilial("SB2")+SC6->C6_PRODUTO+SC6->C6_LOCAL) )
			If ( aEmpenho <> Nil )
				nQtdJaEmp := 0
				For nRegEmp := 1 To Len(aEmpenho[2])
					If aEmpenho[2][nRegEmp][1] == SB2->(RecNo())
						If Empty(SC6->C6_LOCALIZ+SC6->C6_NUMSERI+SC6->C6_NUMLOTE+SC6->C6_LOTECTL) .Or.;
								aEmpenho[2][nRegEmp][3] == SC6->C6_LOCALIZ+SC6->C6_NUMSERI+SC6->C6_NUMLOTE+SC6->C6_LOTECTL
							nSaldo -= aEmpenho[2][nRegEmp][2] //B2_RESERVA
							nQtdJaEmp += aEmpenho[2][nRegEmp][2] //B2_RESERVA
						EndIf
					EndIf
				Next nRegEmp
			EndIf
			nQtd440L  := If(ExistBlock("MTA440L"),ExecBlock("MTA440L",.F.,.F.),0)
			nSaldo    -= nQtd440L

			lConsTerc := (SF4->F4_PODER3<>"N" .Or. !Empty(SF4->F4_TESP3))

			If lVerPar
				nSaldo   += SldAtuEst(SC6->C6_PRODUTO,SC6->C6_LOCAL,nQtdLib+nQtdJaEmp+IIf(nQtd440L>0,nQtd440L,0),SC6->C6_LOTECTL,SC6->C6_NUMLOTE,SC6->C6_LOCALIZ,SC6->C6_NUMSERI,SC6->C6_RESERVA,lConsTerc,SF4->F4_SLDNPT=="1",SC6->C6_PROJPMS,SC6->C6_TASKPMS,SC6->C6_SERVIC,!Empty(aEmpBN))
			Else
				nSaldo   += SldAtuEst(SC6->C6_PRODUTO,SC6->C6_LOCAL,nQtdLib+nQtdJaEmp+IIf(nQtd440L>0,nQtd440L,0),,,,SC6->C6_NUMSERI,SC6->C6_RESERVA,lConsTerc,SF4->F4_SLDNPT=="1",SC6->C6_PROJPMS,SC6->C6_TASKPMS,SC6->C6_SERVIC,!Empty(aEmpBN))
			EndIf
			nSaldo   += SC6->C6_QTDRESE
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Para Devolucoes subtrai o saldo do CQ (ainda Nao Liberado e Nao Rejeitado) ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If SC5->C5_TIPO == 'D' .And. !Empty(SC6->C6_NFORI+SC6->C6_SERIORI) .And. SC6->C6_LOCAL == cLocCQOri
				aSaldoCQ := SaldoRjCQ(SC6->C6_PRODUTO,SC6->C6_NFORI,SC6->C6_SERIORI,SC6->C6_CLI,SC6->C6_LOJA,SC6->C6_NUMLOTE,SC6->C6_ITEMORI,/*dDataAtu*/,SC6->C6_LOCAL)
				nSaldoCQ := aSaldoCQ[1] - aSaldoCQ[8]
				nSaldo   := Min( nSaldoCQ, nSaldo )
			EndIf
			If ( NoRound(nQtdLib,nDecimal) <= NoRound(nSaldo,nDecimal) )
				lTransf  := .F.
				lRetorno := .T.
			Else
				If ( lLiber .And. nSaldo > 0)
					nQtdLib  := nSaldo
					lTransf  := .F.
					lRetorno := .T.
				EndIf
			EndIf
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Verifica os demais almoxarifados                                        ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If ( lTransf .And. !Rastro(SC6->C6_PRODUTO) .And. !Localiza(SC6->C6_PRODUTO, .T.) )
				dbSelectArea("SB2")
				dbSetOrder(1)
				MsSeek(xFilial("SB2")+SC6->C6_PRODUTO) //posiciona no primeiro local
				While ( !Eof() .And. xFilial("SB2") == SB2->B2_FILIAL .And.;
						SC6->C6_PRODUTO== SB2->B2_COD )
					If ( !SB2->B2_LOCAL $ cLocCq .And.;
					      SB2->B2_LOCAL <> SC6->C6_LOCAL .And.;
					      !BlqInvent(SB2->B2_COD,SB2->B2_LOCAL,,If(!__lPyme, SB2->B2_LOCALIZ, '' )) .And.;
					      !(FindFunction('AvalBlqLoc') .And. AvalBlqLoc(SB2->B2_COD,SB2->B2_LOCAL,Nil,.F.)) )
						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³Trava o SB2 dos Locais a serem Transferidos                             ³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						If RecLock("SB2")
							nSldSb2 := SaldoSb2(,Empty(aEmpBN) .And. GetMv("MV_QEMPV"),,SF4->F4_PODER3<>"N" .Or. (!Empty(SF4->F4_TESP3)))
							If ( aEmpenho <> Nil )
								For nRegEmp := 1 To Len(aEmpenho[2])
									If aEmpenho[2][nRegEmp][1] == SB2->(RecNo())
										If Empty(SC6->C6_LOCALIZ+SC6->C6_NUMSERI+SC6->C6_NUMLOTE+SC6->C6_LOTECTL) .Or.;
												aEmpenho[2][nRegEmp][3] == SC6->C6_LOCALIZ+SC6->C6_NUMSERI+SC6->C6_NUMLOTE+SC6->C6_LOTECTL
											nSldSB2 -= aEmpenho[2][nRegEmp][2] //B2_RESERVA
										EndIf
									EndIf
								Next nRegEmp
							EndIf
							If ( nSldSb2<>0 )
								AAdd(aLocal, { SB2->B2_LOCAL , Min(nSldSb2,nQtdLib-nSaldo) } )
								nSaldo += Min(nSldSb2,aLocal[Len(aLocal),2])
								If ( nQtdLib <= nSaldo .Or. (lliber .And. nSaldo > 0))
									nQtdLib  := nSaldo
									lRetorno := .T.
									Exit
								EndIf
							EndIf
						EndIf
					EndIf
					dbSelectArea("SB2")
					dbSkip()
				EndDo
			EndIf
		Else
			lRetorno := .F.
		EndIf

		If !Empty(aEmpBN) .And. (!(aEmpenho==Nil) .or. nSaldo < If(nQtdEmp < SC6->C6_QTDVEN,nQtdEmp,SC6->C6_QTDVEN))
			For nX := 1 To Len(aEmpBN)
				A410LibBen(2,aEmpBN[nX,1],aEmpBN[nX,2],If(nQtdEmp < SC6->C6_QTDVEN,nQtdEmp,SC6->C6_QTDVEN) - If(lLiber,nSaldo,0))
			Next nX
		EndIf
	Else
		lRetorno := .T.
	EndIf
EndIf

nSldProd := nSaldo  //Variável para consulta do valor de Saldo do Produto para o Log do Pedido de Venda

Return(lRetorno)

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ A440Qtdl ³ Autor ³ Claudinei M. Benzi    ³ Data ³ 22.01.92 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Consiste qtde liberada se maior que qtde vendida           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Mata440                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function A440Qtdl(nQuant)

Local aTam      := TamSX3("C6_QTDVEN")

Local cLote     := ""
Local cProduto  := ""
Local cLocal    := ""
Local cItem     := ""
Local cAlias    := Alias()
Local cGrade    := ""
Local cReserv   := ""
Local cLoteCtl  := ""
Local cLocaliza := ""
Local cNumSerie := ""
Local cProjeto  := ""
Local cTarefa   := ""
Local cServico  := ""
Local cTipProd  := ""

Local nSaldo    := 0
Local nQtdRese  := 0
Local nQtdEnt   := 0
Local nx        := 0
Local nQtdLib   := 0
Local nQtdVen   := 0

Local lRsDoFAt  := IIF(SuperGetMv("MV_RSDOFAT") == "S",.F.,.T.)
Local lBloq     := .F.
Local lGrade    := MaGrade()
Local lMata410  := AtIsRotina("MATA410")

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Integracao SIGAFAT e SIGADPR                                 ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Local lIFatDpr := SuperGetMV("MV_IFATDPR",.F.,.F.)


nQtdLib := IF(nQuant == NIL .Or. ValType(nQuant) # "N",&(ReadVar()),nQuant)

For nx=1 to Len(aHeader)
	If Trim(aHeader[nX][2]) == "C6_ITEM"
		cItem := aCols[n][nx]
	ElseIf Trim(aHeader[nx][2]) == "C6_BLQ"
		If ( AllTrim(acols[n][nx]) $ "RS" )
			lBloq := .T.
		Endif
	ElseIf Trim(aHeader[nX][2]) == "C6_PRODUTO"
		cProduto := aCols[n][nx]
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Verifica se a grade esta ativa, e se o produto digitado e'   ³
		//³ uma referencia                                               ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If lGrade
			MatGrdPrrf(@cProduto)
		Endif
	ElseIf Trim(aHeader[nX][2]) == "C6_LOCAL"
		cLocal := aCols[n][nx]
	ElseIf Trim(aHeader[nX][2]) == "C6_NUMLOTE"
		cLote := aCols[n][nx]
	ElseIf Trim(aHeader[nX][2]) == "C6_LOTECTL"
		cLoteCtl := aCols[n][nx]
	ElseIf Trim(aHeader[nX][2]) == "C6_LOCALIZ"
		cLocaliza := aCols[n][nx]
	ElseIf Trim(aHeader[nX][2]) == "C6_NUMSERI"
		cNumSerie := aCols[n][nx]
	ElseIf Trim(aHeader[nX][2]) == "C6_QTDVEN"
		nQtdVen := aCols[n][nx]
	ElseIf Trim(aHeader[nX][2]) == "C6_QTDENT"
		nQtdEnt := aCols[n][nx]
	ElseIf Trim(aHeader[nX][2]) == "C6_GRADE"
		cGrade := aCols[n][nx]
	ElseIf Trim(aHeader[nX][2]) == "C6_TES"
		cTes := aCols[n][nx]
	ElseIf Trim(aHeader[nX][2]) == "C6_RESERVA"
		cReserv := aCols[n][nx]
	ElseIf Trim(aHeader[nX][2]) == "C6_PROJPMS"
		cProjeto := aCols[n][nx]
	ElseIf Trim(aHeader[nX][2]) == "C6_TASKPMS"
		cTarefa := aCols[n][nx]
	ElseIf Trim(aHeader[nX][2]) == "C6_SERVIC"
		cServico:= aCols[n][nx]
	ElseIf Trim(aHeader[nX][2]) == "C6_TPPROD"
		cTipProd:= aCols[n][nx]
	EndIf
Next nX

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ M_SER004_CRM019_Integraçao_Faturamento_DPR                           ³
//³ Se o item eh do tipo "Desenvolvimento" nao libera para faturamento   ³
//³ Autor: Alexandre Felicio													   ³
//³ Data: 12/05/2014														   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If ( (lIFatDpr) )
	If cTipProd == "2" .AND. nQtdLib > 0
		MsgAlert(STR0019) //"Item do tipo Desenvolvimento não podem ter sua quantidade liberada para Faturamento."
		Return .F.
	EndIf
EndIf


If ( lBloq .And. lRsDoFat .and. nQtdLib > 0  )
	Help(" ",1,"A410ELIM")
	Return .F.
Endif

If SuperGetMv("MV_LIBACIM") .And. nQtdLib > 0
	If ( INCLUI )
		If Round(nQtdLib,aTam[2]) > Round(nQtdVen,aTam[2])
			HELP(" ",1,"A440QTDL")
			Return .F.
		EndIf
	Else
		If !lGrade  .Or. cGrade <> "S"
			dbSelectArea("SC6")
			dbSetOrder(1)
			MsSeek(xFilial("SC6")+M->C5_NUM+cItem)
			//CHAMADA DE FUNCAO AGROINDUSTRIA
			If FindFunction("OGX225C") .AND. (SuperGetMV("MV_AGRUBS",.F.,.F.))
				If !(OGX225C(nQtdVen, nQtdLib))
					Return .F.
				EndIf 
			EndIf
			
			If !lMata410
				If Found() .And. Round(nQtdLib,aTam[2]) > Round(C6_QTDVEN - (C6_QTDEMP+C6_QTDENT),aTam[2])
					HELP(" ",1,"A440QTDL")
					Return .F.
				Endif
			Else
				If Found() .And. Round(nQtdLib,aTam[2]) > Round(nQtdVen - C6_QTDENT,aTam[2])
					HELP(" ",1,"A440QTDL")
					Return .F.
				Endif
			Endif
		Endif
	EndIf
Endif
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Caso movimente Estoque em Quantidade                                    ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
dbSelectArea("SF4")
dbSetOrder(1)
MsSeek(xFilial("SF4")+cTes)
If ( SF4->F4_ESTOQUE == "S" .And. !(M->C5_TIPO$"CIP") .And. !Empty(cReserv) )
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Validacao para Reserva                                   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If ( INCLUI )
		dbSelectArea("SC0")
		dbSetOrder(1)
		If ( MsSeek(xFilial("SC0")+cReserv+cProduto+cLocal) )
			nQtdRese := Min(SC0->C0_QUANT,nQtdVen)
		EndIf
	Else
		dbSelectArea("SC6")
		dbSetOrder(1)
		If ( MsSeek(xFilial("SC6")+M->C5_NUM+cItem+cProduto,.F.) )
			If ( cReserv == SC6->C6_RESERVA )
				nQtdRese := Min(SC6->C6_QTDRESE,nQtdLib)
			Else
				dbSelectArea("SC0")
				dbSetOrder(1)
				If ( MsSeek(xFilial("SC0")+cReserv+cProduto+cLocal) )
					nQtdRese := Min(SC0->C0_QUANT,nQtdVen)
				EndIf
			EndIf
		EndIf
	EndIf
	If ( NoRound(nQtdLib,aTam[2]) > NoRound(nQtdRese,aTam[2]) )
		Help(" ",1,"A440RESE01",,Str(nQtdRese),03,20)
		Return(.F.)
	EndIf
Else
	If ((Rastro(cProduto) .Or. Localiza(cProduto,.T.)) .And. !(M->C5_TIPO $ "CIP") .And. SF4->F4_ESTOQUE == "S" ) .And. SuperGetMv("MV_GERABLQ")=="N"
		nSaldo := SldAtuEst(cProduto,cLocal,nQtdLib,cLoteCtl,cLote,cLocaliza,cNumSerie,cReserv,SF4->F4_PODER3<>"N" .Or. (!Empty(SF4->F4_TESP3)),NIL,cProjeto,cTarefa,cServico)
		dbSelectArea("SC6")
		dbSetOrder(1)
		If ( MsSeek(xFilial("SC6")+M->C5_NUM+cItem+cProduto,.F.) )
			nSaldo += SC6->C6_QTDEMP
		EndIf
		If ( nSaldo < nQtdLib )
			If ( Localiza(cProduto,.T.) )
				Help(" ",1,"SALDOLOCLZ")
				Return(.F.)
			EndIf
			If ( Rastro(cProduto) )
				Help(" ",1,"A440ACILOT")
				Return(.F.)
			EndIf
		EndIf
	EndIf
EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ S¢ permitir alterar a quantidade quando esta for maior que a ³
//³ quantidade entregue, somente para outros paises...           ³
//ÀÄLucasÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If cPaisLoc <> "BRA"
	If nQtdLib < nQtdEnt
		Help(" ",1,"CANTRESERV")
		Return(.F.)
	EndIf
EndIf
dbSelectArea(cAlias)
Return( .T. )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³ A460Especie³ Autor ³ Juan Jose Pereira   ³ Data ³ 14/10/96 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Busca tipo de documento fiscal utilizado para gerar nota   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA460                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function A460Especie(cSerie)
Local cSvAlias:=Alias(), cTiposDoc:=MaSerEspNF(),;
	cEspecie:=Space(5),nLinhas:=0,nL:=0,nPosSign:=0
Local lNewInvoic 	:= Iif(__RpoRelease >= '12.1.2410',;
						 tlpp.ffunc("backoffice.fat.documento.UsaNewInvoice") .And.;
						 tlpp.call('backoffice.fat.documento.UsaNewInvoice()'),.F.)

If lNewInvoic
	DbSelectArea("AZZ")
	AZZ->(DbSetOrder(3)) //AZZ_FILIAL+AZZ_DEFAUL+AZZ_SERIE+AZZ_PDV
	If AZZ->(DbSeek(FwXFilial("AZZ")+"1"+cSerie))
		cEspecie := AZZ->AZZ_ESPECI //Retorna a especie definida para a s?rie (valido apenas at? a mudan?a da chave unica)
	EndIf
Else
	If cTiposDoc<>NIL
		cTiposDoc:=StrTran(cTiposDoc,";",chr(13)+chr(10))
		nLinhas:=MLCount(cTiposDoc)
		For nL:=1 to nLinhas
			cEspecie:=Alltrim(StrTran(MemoLine(cTiposDoc,,nL),Chr(13),Chr(10)))
			nPosSign:=Rat("=",cEspecie)
			If nPosSign>0 .and. Alltrim(cSerie)==Alltrim(Substr(cEspecie,1,nPosSign-1)) // Heverson
				cEspecie:=Substr(cEspecie,nPosSign+1)
				SX5->(MsSeek(xFilial("SX5")+"42"+cEspecie))
				If SX5->(!Found())
					cEspecie:=Space(5)
				Endif
				Exit
			Else
				cEspecie:=Space(5)
			Endif
		Next
	Endif
EndIf
dbSelectArea(cSvAlias)
Return(cEspecie)

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³a460Estorn³ Autor ³Eduardo Riera          ³ Data ³31.03.99  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Efetua o estorno da liberacao do pedido de venda            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpL1: Indica se houve o estorno                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpL1: Indica se o programa chamador eh o MATA410           ³±±
±±³			 ³ExpL2: Indica se Atualizará Empenhos				          ³±±
±±³          ³ExpN3: Valor a ser adicionado ao limite de credito          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Observacao³Deve estar numa transacao                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³   DATA   ³ Programador   ³Manutencao Efetuada                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³16/05/2007³Norbert Waage  ³Bops 125161 - Atualizacao do status do orca-³±±
±±³          ³               ³mento no Televendas (SIGATMK) apos estorno. ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function A460Estorna(lMata410, lAtuEmp, nVlrCred, cTipLib, nRecSC9)

Local aArea       := GetArea()
Local aAux        := {}
Local lContinua   := .T.
Local lDeletaDCF  := .F.
Local lIntACD 	  := SuperGetMV("MV_INTACD",.F.,"0") == "1"
Local aEmpBN	  := {}
Local nX		  := 0
Local cBlq		  := ""
Local cItemBlq	  := ""
Local lLibMan	  := .F.
Local lAGRUBS	  := SuperGetMV("MV_AGRUBS",.F.,.F.)
Local cSeq        := ""
Local lResAut	  := SuperGetMv("MV_RESAUT",.F.,.F.)
Local lDelRes	  := SuperGetMv("MV_DELRES",.F.,.F.)
Local lDelRes2	  := SuperGetMV("MV_DELRES2",.F.,.F.)
Local lResEst     := SuperGetMv("MV_RESEST",.F.,.F.)
Local lTipRes     := SuperGetMv("MV_TIPRES",.F.,.F.)
Local cGeraBlq    := SuperGetMv("MV_GERABLQ",.F.,"N")
Local lGrvBlq2    := SuperGetMv("MV_GRVBLQ2",.F.,.F.)
Local l456LibMan  := IsInCallStack("a456LibMan")
Local l456LibAut  := IsInCallStack("a456LibAut")
Local lHabGrvLog  := SuperGetMV("MV_FTLOGPV",,.F.) .And. FindFunction('FATA410') .And. AliasInDic("AQ1") //Habilita a gravação do log de liberação de Pedidos de Venda
Local aLogLibPV	  := {}
Local nPProduto	  := 0 
Local nPItem      := 0 
Local nQQtdLib	  := 0 
Local lEstCarga	  := SUPERGETMV("MV_ACDELCG",.F.,.T.)
Local lWmsSaas    := FindFunction("WMSSaasHas") .And. WMSSaasHas()

/* 
	lEstSeqAtu = No estorno do item do pedido de vendas (SC6), estorna so a sequencia atual

	Tratamento para Liberacao Manual ou Automatica de itens do pedido de venda
	quando e gerada Reserva Automatica nos casos em que ocorre o bloqueio de estoque (MV_RESEST = T)
	e a delecao das reservas nos casos de estorno da liberacao ocorram (MV_DELRES = T).
	Todos os parametros considerados para esta tratativa:
		MV_RESEST = T
		MV_DELRES = T
		MV_RESAUT = F
		MV_TIPRES = F
		MV_GERABLQ = N
		MV_GRVBLQ2 = F
*/
Local lEstSeqAtu :=	(l456LibMan .Or. l456LibAut) ;	// Tela de Liberacao automatica ou manual
						.And. ;
					(lResEst                  .And. ;	// MV_RESEST = T
					 lDelRes                  .And. ;	// MV_DELRES = T
					 !lResAut                 .And. ;	// MV_RESAUT = F
					 !lTipRes                 .And. ;	// MV_TIPRES = F
					 AllTrim(cGeraBlq) == "N" .And. ;	// MV_GERABLQ = N
					 !lGrvBlq2)							// MV_GRVBLQ2 = F

Default cTipLib		:= ""
Default lMata410	:= .F.
Default lAtuEmp		:= .T.
Default nVlrCred	:= 0
Default nRecSC9		:= 0

//- Status dos Bloqueios do pedido de venda. Se .T. DCF gerado, tem que estornar.
If Type("lbloqDCF") <> "L"
	lbloqDCF := .F.
EndIf

If Type("lVerCarg461") <> "L"
	lVerCarg461 := .F.
EndIf

//CHAMADA DE FUNCAO AGROINDUSTRIA
If FindFunction("OGX225A") .AND. lAGRUBS
   lContinua := OGX225A()
End

If nRecSC9 > 0
	SC9->(dbGoto(nRecSC9))
EndIf

aEmpBN := If(FindFunction("A410CarBen"),A410CarBen(SC9->C9_PEDIDO,SC9->C9_ITEM),{})

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Verifica os parametros defaults                                         ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
lMata410 := If(lMata410==Nil,.F.,lMata410)
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Integracao com o  ACD - Faz validacao do estorno da liberacao dos PV's  	  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lContinua .And. lIntACD .And. FindFunction("CBMT460EST")
	lContinua := CBMT460EST()
	If ValType(lContinua) # "L"
		lContinua:=.T.
	EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Pontos de Entrada                                                       ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
ElseIf lContinua .And. (ExistTemplate("MT460EST",.F.,.F.))
	lContinua := ExecTemplate("MT460EST",.F.,.F.)
	If ValType(lContinua) # "L"
		lContinua:=.T.
	EndIf
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Pontos de Entrada                                                       ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lContinua .And. ( ExistBlock("MT460EST",.F.,.F.) )
	lContinua := ExecBlock("MT460EST",.F.,.F.)
	If ValType(lContinua) # "L"
		lContinua:=.T.
	EndIf
EndIf

//Validações referentes à integração do OMS com o TPR - TOTVS Planejamento de Rotas Neolog
If SuperGetMV("MV_ROTAINT",.F.,.F.) .And. FindFunction("OMSTPR410P")
	lContinua := OMSTPR410P(6,,,SC9->C9_PEDIDO,SC9->C9_ITEM,SC9->C9_SEQUEN,SC9->C9_PRODUTO)
EndIf

If lContinua .And. lWmsSaas .And. FindFunction("WMSSVlEPdV") 
	lContinua := WMSSVlEPdV(SC9->(Recno()))
EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Atualiza o orcamento do Televendas, se foi originado a partir³
//³dele no modulo Call Center (SIGATMK)                         ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lContinua
	TkAtuTlv(SC9->C9_PEDIDO,1,,,,.T.)
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Posiciona Registros e trava registros                                   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
dbSelectArea("SC9")

If lVerCarg461
	//--> Verifica algum dos pedidos selecionados tem carga montada
	If OmsHasCg(SC9->C9_PEDIDO,SC9->C9_ITEM)
		Help(" ",1,"MATA46101")
		RestArea(aArea)
		Return (.F.)
	EndIf
EndIf

If ( lContinua )
	lDeletaDCF := .T.
	If lbloqDCF
		lDeletaDCF := .F.
	EndIf

	//Se for a liberação de crédito de pedido manual, guarda o status do pedido e item.
	If lMata410 .And. IsInCallStack("A450LibMan") .And.;
		!Empty(cTipLib) .And. cTipLib == "2"
		cBlq 	 := SC5->C5_BLQ
		cItemBlq := SC6->C6_BLOQUEI
		lLibMan	 := .T.
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Restaura empenhos relacionados a remessa para beneficiamento ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If !Empty(aEmpBN) .And. Empty(SC9->C9_BLEST)
		For nX := 1 To Len(aEmpBN)
			A410LibBen(2,aEmpBN[nX,1],aEmpBN[nX,2],SC9->C9_QTDLIB,SC9->C9_QTDLIB2)
		Next nX
	EndIf

	FatAtuEmpN("-",,,.T.)
	// --- 2.Estorno do SC9 / Estorno da Liberacao de 6.Estoque/4.Credito do SC9 / WMS
	MaAvalSC9("SC9",2,,,,,lAtuEmp,,@nVlrCred,,lDeletaDCF)
	
	If lEstCarga
		MaAvalSC9("SC9",8) // --- 8.Estorno Mont.Carga
	EndIf
	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Deleta o Registro no SC9                                                ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	dbSelectArea("SC9")
	RecLock("SC9")
	SC9->C9_BLCRED := If(SC9->C9_BLCRED=="05","",SC9->C9_BLCRED)

	//WMS SaaS - Exclui registro da tabela de convergência
	If lContinua .And. lWmsSaas .And. FindFunction("WMSSExItPV")
		WMSSExItPV(SC9->(Recno()))
	EndIf

	If lContinua
	   dbDelete()
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Executa o ExecBlock                                                     ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	dbSelectArea("SC9")
	
	//CHAMADA DE FUNCAO AGROINDUSTRIA
	If FindFunction("OGX225D") .AND. lAGRUBS
		OGX225D("SC9")
	End
	
	If ( !lMata410 )
		If (ExistBlock("M460DEL"))
			ExecBlock("M460DEL",.f.,.f.)
		EndIf
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ O SC6 eh posicionado na funcao maavalsc9                               ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If !Empty(SC6->C6_RESERVA) .And. (SC6->C6_QTDEMP == 0 .Or. lEstSeqAtu)
		dbSelectArea("SC0")
		dbSetOrder(1)
		If ( MsSeek(xFilial("SC0")+SC6->C6_RESERVA+SC6->C6_PRODUTO+SC6->C6_LOCAL,.F.) ) .Or. lResAut
			
			If lEstSeqAtu
				//Estornar somente a sequencia atual (SC9) de liberação do item do pedido de venda
				MaAvalSC6("SC6",2,"SC5", , , , , , , , , , , , , .F.)
			Else
				MaAvalSC6("SC6",2,"SC5")
			EndIf

			aAux := {SC6->C6_NUMLOTE,SC6->C6_LOTECTL,SC6->C6_LOCALIZ,SC6->C6_NUMSERI}
			If lDelRes .And. lDelRes2
				RecLock("SC6")
				SC6->C6_NUMLOTE := ""
				SC6->C6_LOTECTL := ""
				SC6->C6_LOCALIZ := ""
				SC6->C6_NUMSERI := ""
			EndIf

			MaAvalSC6("SC6",1,"SC5")

			//Se for a liberação de crédito de pedido manual, volta o status anterior de bloqueio,
			//pois a função da regra de negócio é processada na liberação manual.
			If lLibMan
				If !Empty(SC5->C5_BLQ)
					RecLock("SC5", .F.)
					SC5->C5_BLQ := cBlq
				EndIf
				If !Empty(SC6->C6_BLOQUEI)
					RecLock("SC6", .F.)
					SC6->C6_BLOQUEI := cItemBlq
				EndIf
			EndIf

			If lDelRes .And. lDelRes2
				RecLock("SC6")
				SC6->C6_NUMLOTE := aAux[1]
				SC6->C6_LOTECTL := aAux[2]
				SC6->C6_LOCALIZ := aAux[3]
				SC6->C6_NUMSERI := aAux[4]
			EndIf

		Else
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Caso a Reserva foi depurada       ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			dbSelectArea("SB2")
			RecLock("SB2")
			If !(lResAut .And. lDelRes)
				SB2->B2_RESERVA -= SC6->C6_QTDRESE
				SB2->B2_RESERV2 -= ConvUM(SB2->B2_COD, SC6->C6_QTDRESE, 0, 2)
			EndIf
			SB2->B2_QPEDVEN += SC6->C6_QTDRESE
			SB2->B2_QPEDVE2 += ConvUM(SB2->B2_COD, SC6->C6_QTDRESE, 0, 2)
			dbSelectArea("SC6")
			RecLock("SC6")
			SC6->C6_QTDRESE := 0
			SC6->C6_RESERVA := ""
		EndIf
	ElseIf !lMata410
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Se nao existir controle de reserva e o estorno da liberacao estiver sendo ³
		//³ feito pela rotina MATA461, verifica se houve transferencia entre almoxari-³
		//³ fados e executa o estorno da transferencia.    							  ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	 	MaTrfLocal(SC6->C6_PRODUTO, , , ,SC6->C6_NUM,.T.,@cSeq)
	EndIf
	FatAtuEmpN("+")
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Gravação do Log de Liberação do Pedido de Venda                             ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lHabGrvLog .And. lContinua //Habilita a função para gravação do log de liberação do pedido de venda

	If lMata410 .And. !Type("aHeader")=="U"
		nPProduto	:= aScan(aHeader,{|x| AllTrim(x[2]) =="C6_PRODUTO"})
		nPItem		:= aScan(aHeader,{|x| AllTrim(x[2]) == "C6_ITEM"})
		nQQtdLib	:= aScan(aHeader,{|x| AllTrim(x[2]) == "C6_QTDLIB"})
	EndIf

	Aadd(aLogLibPV,{SC9->C9_FILIAL,SC9->C9_PEDIDO,IIF(nPItem>0,Acols[1][nPItem],SC9->C9_ITEM),;
		IIF(nPProduto>0,Acols[1][nPProduto],SC9->C9_PRODUTO),IIF(nQQtdLib>0,Acols[1][nQQtdLib],SC9->C9_QTDLIB),;
		SC5->C5_ORIGEM,SC9->C9_BLCRED,SC9->C9_BLEST,dDatabase,Time(),3,.F.,"A460ESTORNA"})
	
	If !Empty(aLogLibPV	)
		FATA410(aLogLibPV)
	EndIf
EndIf

RestArea(aArea)
Return(lContinua)

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³AtTrfEqpto³ Autor ³ Eduardo Riera         ³ Data ³05.01.98  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Transferencia de Cliente x Equipamento                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ Nenhum                                                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ cCodFab: Codigo do Fabricante                              ³±±
±±³          ³ cLojaFa: Loja do Fabricante                                ³±±
±±³          ³ cCodPro: Codigo do Produto                                 ³±±
±±³          ³ cNumSer: Numero de Serie                                   ³±±
±±³          ³ cCodCli: Codigo do Cliente                                 ³±±
±±³          ³ cLoja  : Loja do Cliente                                   ³±±
±±³          ³ aHeadA4: aHeader do AA4 (Somente Inclusao)                 ³±±
±±³          ³ aColsA4: aCols do AA4 ( Somente Inclusao )                 ³±±
±±³          ³ aEnchoi: Vetor com os campos a serem atualizados           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³   DATA   ³ Programador   ³Manutencao Efetuada                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³               ³                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/

Function AtTrfEqpto(cCodFab,cLojaFa,cCodPro,cNumSer,cCodCli,cLoja,aHeadAA4,aColsAA4,aEnchoice)

Local aArea       := GetArea()
Local nOpcao      := 0
Local aSavaHead   := If(Type("aHeader")=="U",{},aHeader)
Local aSavaCols   := If(Type("aCols")=="U",{},aCols)
Local aSavN       := If(Type("N")=="U",1,N)
Local nCntFor     := 0
Private aHeader   := {}
Private aCols     := {}
Private uCampo    := ""

aEnchoice := If(aEnchoice==Nil,{},aEnchoice)

dbSelectArea("AA3")
dbSetOrder(4)
If ( MsSeek(xFilial("AA3")+cCodFab+cLojaFa+cCodPro+cNumSer) )
	nOpcao := 4
	dbSelectArea("SX3")
	dbSetOrder(1)
	MsSeek("AA3")
	While ( !Eof() .And. (SX3->X3_ARQUIVO == "AA3") )
		uCampo := SX3->X3_CAMPO
		If ( SX3->X3_CONTEXT=="V" )
			M->&(uCampo) := CriaVar(SX3->X3_CAMPO,.F.)
		Else
			M->&(uCampo) := AA3->(FieldGet(FieldPos(SX3->X3_CAMPO)))
		EndIf
		dbSelectArea("SX3")
		dbSkip()
	EndDo
	For nCntFor := 1 To Len(aEnchoice)
		uCampo := aEnchoice[nCntFor][1]
		M->&(uCampo) := aEnchoice[nCntFor][2]
	Next nCntFor
	At040Grava(nOpcao,cCodCli,cLoja)
Else
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Verifica se ha componentes a serem considerados                         ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If ( aColsAA4 <> Nil .And. aHeadAA4 <> Nil )
		aCols   := aClone(aColsAA4)
		aHeader := aClone(aHeadAA4)
	EndIf
	nOpcao := 1
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Inicializa as Variaveis necessarias a gravacao                          ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	dbSelectArea("SX3")
	dbSetOrder(1)
	MsSeek("AA3")
	While ( !Eof() .And. (SX3->X3_ARQUIVO == "AA3") )
		uCampo := SX3->X3_CAMPO
		M->&(uCampo) := CriaVar(SX3->X3_CAMPO,If(SX3->X3_CONTEXT=="V",.F.,.T.))
		dbSelectArea("SX3")
		dbSkip()
	EndDo
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Preenche as Variaveis Necessarias                                       ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	M->AA3_CODCLI  := cCodCli
	M->AA3_LOJA    := cLoja
	M->AA3_CODPRO  := cCodPro
	M->AA3_NUMSER  := cNumSer
	M->AA3_DTVEND  := SD2->D2_EMISSAO
	M->AA3_CODFAB  := cCodFab
	M->AA3_LOJAFA  := cLojaFa
	M->AA3_NFVEND  := SD2->D2_DOC
	M->AA3_CONTRT  := ""
	M->AA3_DTGAR   := &(SuperGetMv("MV_FORMGAR"))
	For nCntFor := 1 To Len(aEnchoice)
		uCampo := aEnchoice[nCntFor][1]
		M->&(uCampo) := aEnchoice[nCntFor][2]
	Next nCntFor
	At040Grava(nOpcao,cCodCli,cLoja)
EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Retorna as condicoes de entrada                                         ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
aCols   := aSavACols
aHeader := aSavAhead
N       := aSavN
RestArea(aArea)
Return(.T.)

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³At040Grava³ Autor ³ Eduardo Riera         ³ Data ³ 16/09/98 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Programa de Gravacao  amarra‡„o Cliente x Equipamento      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ Void At040Grava()                                          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpN1 = 1 - Inclui, 2 - Altera , 3 - Exclui                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ TECA040                                                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³   DATA   ³ Programador   ³Manutencao Efetuada                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³25/08/05  ³Henry F        ³Bops 85869 - Tratamento da gravacao do      ³±±
±±³          ³               ³cliente anterior no campo AAF_LOGINI        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³02/10/0600³Conrado Q.     ³Bops 107368 - Localizacao dos acessorios do ³±±
±±³          ³               ³produto quando AA4 trabalha em modo exclu.  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function At040Grava(nOpcao,cCodCli,cLoja)

Local nCntFor		:= 0                      							//Variavel para For - Next
Local nCntFor2		:= 0												//Variavel para For - Next
Local nUsado		:= Len(aHeader)										//Tamanho do aHeader
Local aRecAA4		:= {}												//Array de registros da tabela AA4
Local nPosProd		:= Ascan(aHeader,{|x| Trim(x[2])=="AA4_PRODAC" })	//Posicao do campo Produro no aHeader
Local bCampo		:= {|x| FieldName(x) }								//Bloco de codigo para pegar o nome do campo na gravacao
Local nRegAA3		:= AA3->(RecNo())									//Array de registros da tabela AA3
Local cPlano		:= ""												//Armazena codigo do plano de manutencao do parametr MV_ATPLANO
Local cCodCliAnt	:= ""												//Codigo do cliente anterior a alteracao do historico
Local cLojaCliAnt	:= ""												//Loja do cliente anterior a alteracao do historico

Local lGravou   := .T.
Local lAA3NF	 :=  SuperGetMV('MV_GSAA3NF',,.F.)

dbSelectArea("AA4")
dbSetOrder(1)
MsSeek(xFilial("AA4")+M->AA3_CODCLI+M->AA3_LOJA+M->AA3_CODPRO+M->AA3_NUMSER)

While ( !Eof() .And. AA4->AA4_FILIAL==xFilial("AA4") .And.;
		AA4->AA4_CODCLI==M->AA3_CODCLI .And.;
		AA4->AA4_LOJA  ==M->AA3_LOJA   .And.;
		AA4->AA4_CODPRO==M->AA3_CODPRO .And.;
		AA4->AA4_NUMSER==M->AA3_NUMSER )
	AAdd(aRecAA4,RecNo())
	dbSelectArea("AA4")
	dbSkip()
EndDo
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Bloco de Inclusao / Alteracao                                           ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Do Case
Case ( nOpcao < 3 )
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Grava arquivo AA3 (Cabecalho da Amarracao             ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	dbSelectArea("AA3")
	dbSetOrder(1)
	MsSeek(xFilial("AA3")+M->AA3_CODCLI+M->AA3_LOJA+M->AA3_CODPRO+M->AA3_NUMSER+M->AA3_FILORI)
	RecLock("AA3",!Found())
	For nCntFor := 1 To FCount()
		If ( "FILIAL"$Field(nCntFor) )
			FieldPut(nCntFor,xFilial("AA3"))
		Else
			FieldPut(nCntFor,M->&(EVAL(bCampo,nCntFor)))
		EndIf
	Next nCntFor
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Grava os campos memos                                                   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	MSMM(M->AA3_CODMEM,,,M->AA3_OBS,1,,,"AA3","AA3_CODMEM")
	AA3->( MsUnlock() )
	AA3->(FKCommit())
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Grava Historico de Equipamento                      ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	dbSelectarea("AAF")
	dbSetOrder(1)
	If !MsSeek(xFilial("AAF")+M->AA3_CODCLI+M->AA3_LOJA+M->AA3_CODPRO+M->AA3_NUMSER+M->AA3_CODPRO+M->AA3_NUMSER)
		Reclock("AAF",.T.)
		AAF->AAF_FILIAL := xFilial("AAF")
		AAF->AAF_CODCLI := M->AA3_CODCLI
		AAF->AAF_LOJA   := M->AA3_LOJA
		AAF->AAF_CODPRO := M->AA3_CODPRO
		AAF->AAF_NUMSER := M->AA3_NUMSER
		AAF->AAF_PRODAC := M->AA3_CODPRO
		AAF->AAF_NSERAC := M->AA3_NUMSER
		AAF->AAF_CODFAB := M->AA3_CODFAB
		AAF->AAF_LOJAFA := M->AA3_LOJAFA
		AAF->AAF_DTINI  := dDataBase
		AAF->AAF_LOGINI := STR0001 // # "CADASTRO AMARRACAO CLIENTE X EQPTO"
		MsUnlock()
		AAF->(FKCommit())
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Grava arquivo AA4 (itens da amarracao)              ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	dbSelectArea("AA4")
	For nCntFor := 1 To Len(aCols)
		If ( !aCols[nCntFor][nUsado+1] .And. !Empty(aCols[nCntFor][nPosProd]) )
			If ( nCntFor > Len(aRecAA4) )
				RecLock("AA4",.T.)
			Else
				AA4->(MsGoto(aRecAA4[nCntFor]))
				RecLock("AA4",.F.)
			EndIf
			For nCntFor2 := 1 To nUsado
				If ( aHeader[nCntFor2][10] <> "V" )
					FieldPut(FieldPos(aHeader[nCntFor2][2]),aCols[nCntFor][nCntFor2])
				EndIf
			Next nCntFor2
			AA4->AA4_FILIAL:= xFilial("AA4")
			AA4->AA4_CODCLI:= M->AA3_CODCLI
			AA4->AA4_LOJA  := M->AA3_LOJA
			AA4->AA4_CODPRO:= M->AA3_CODPRO
			AA4->AA4_NUMSER:= M->AA3_NUMSER
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Atualiza historico dos acessorios                                   ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			dbSelectArea("AAF")
			dbSetOrder(1)
			If ( !MsSeek(xFilial("AAF")+M->AA3_CODCLI+M->AA3_LOJA+M->AA3_CODPRO+M->AA3_NUMSER+AA4->AA4_PRODAC+AA4->AA4_NSERAC) )
				Reclock("AAF",.T.)
				AAF->AAF_FILIAL := xFilial("AAF")
				AAF->AAF_CODCLI := M->AA3_CODCLI
				AAF->AAF_LOJA   := M->AA3_LOJA
				AAF->AAF_CODPRO := M->AA3_CODPRO
				AAF->AAF_NUMSER := M->AA3_NUMSER
				AAF->AAF_PRODAC := AA4->AA4_PRODAC
				AAF->AAF_NSERAC := AA4->AA4_NSERAC
				AAF->AAF_DTINI  := dDataBase
				AAF->AAF_CODFAB := M->AA3_CODFAB
				AAF->AAF_LOJAFA := M->AA3_LOJAFA
				AAF->AAF_LOGINI := STR0001 // # "CADASTRO AMARRACAO CLIENTE X EQPTO"
				MsUnlock()
			EndIf
		Else
			If ( nCntFor <= Len(aRecAA4) )
				AA4->(MsGoto(aRecAA4[nCntFor]))
				RecLock("AA4",.F.)
				dbDelete()
				dbSelectArea("AAF")
				dbSetOrder(1)
				If ( MsSeek(xFilial("AAF")+M->AA3_CODCLI+M->AA3_LOJA+M->AA3_CODPRO+M->AA3_NUMSER+AA4->AA4_PRODAC+AA4->AA4_NSERAC) )
					Reclock("AAF",.F.)
					AAF->AAF_DTFIM  := dDataBase
					AAF->AAF_LOGFIM := STR0002 // # "EXCLUIDO PELA AMARRACAO"
				EndIf
			EndIf
		EndIf
	Next nCntFor
	AA4->(FKCommit())
	AAF->(FKCommit())

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Altera o Status da equipamento                                          ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	AtEqStatus(FunName())
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Expande o Plano de Manutencao quando for inclusao                       ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If ( nOpcao == 1 )
		cPlano := &(SuperGetMv("MV_ATPLANO"))
		If ( !Empty(cPlano) )
			AtExpPlano( cPlano )
		EndIf
	EndIf

Case nOpcao == 3
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Bloco de Exclusao                                                       ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	For nCntFor := 1 To Len(aRecAA4)
		dbSelectArea("AA4")
		MsGoto(aRecAA4[nCntFor])
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Atualiza historico dos acessorios                                  ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		dbSelectarea("AAF")
		dbSetOrder(1)
		If ( MsSeek(xFilial("AAF")+M->AA3_CODCLI+M->AA3_LOJA+M->AA3_CODPRO+M->AA3_NUMSER+AA4->AA4_PRODAC+AA4->AA4_NSERAC) )
			Reclock("AAF",.F.)
			AAF->AAF_DTFIM  := dDataBase
			AAF->AAF_LOGFIM := STR0002 // # "EXCLUIDO PELA AMARRACAO"
		EndIf
		dbSelectArea("AA4")
		RecLock("AA4")
		dbDelete()
	Next nCntFor
	AAF->(FKCommit())
	AA4->(FKCommit())
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Deleta o cabecalho do contrato (amarracao).                  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	dbSelectarea("AAF")
	dbSetOrder(1)
	If ( MsSeek(xFilial("AAF")+M->AA3_CODCLI+M->AA3_LOJA+M->AA3_CODPRO+M->AA3_NUMSER) )
		Reclock("AAF",.F.)
		AAF->AAF_DTFIM  := dDataBase
		AAF->AAF_LOGFIM := STR0002 // # "EXCLUIDO PELA AMARRACAO"
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Deleta localizacao fisica ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If AliasInDic("AGW")
		AGW->(dbSetOrder(3))
		If AGW->(dbSeek(xFilial("AGW")+M->AA3_CODCLI+M->AA3_LOJA+M->AA3_CODPRO+M->AA3_NUMSER))
			RecLock("AGW",.F.)
			AGW->(dbDelete())
			AGW->(MsUnLock())
		EndIf
	EndIf
	MSMM(M->AA3_CODMEM,,,,2)
	dbSelectArea("AA3")
	RecLock("AA3",.F.,.T.)
	dbDelete()
	AA3->(FKCommit())

Case ( nOpcao == 4 )
	lGravou := .F.

	dbSelectArea("SA1")
	dbSetOrder(1)
	If ( MsSeek(xFilial("SA1")+cCodCli+cLoja) )
		dbSelectArea("AA3")
		dbSetOrder(1)
		If ( !MsSeek(xFilial("AA3")+cCodCli+cLoja+AA3->AA3_CODPRO+AA3->AA3_NUMSER+AA3->AA3_FILORI) )
			MsGoto(nRegAA3)

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Armazena codigo do cliente e loja antes de gravar o AA3³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			cCodCliAnt	:= AA3->AA3_CODCLI
			cLojaCliAnt	:= AA3->AA3_LOJA

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Atualiza a base instalada                                         ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			dbSelectArea("AA3")
			RecLock("AA3",.F.)
			AA3->AA3_CODCLI := cCodCli
			AA3->AA3_LOJA   := cLoja
			AA3->AA3_CONTRT := ""
			AA3->AA3_CTAPRE := ""
			AA3->AA3_DTCTAM := Ctod("")
			
			If lAA3NF
				If IsIncallstack('MaDelNFS')  
					//-- Exclusão da NF
					AA3->AA3_NFVEND := ""
				ElseIf IsIncallstack('Ma410PvNfs') .And. Empty(AA3->AA3_NFVEND)
					//-- Inclusão de pedido com base de atendimento sem NF preenchida (reemissão do pedido) 
					AA3->AA3_NFVEND := SD2->D2_DOC
				EndIf
			EndIf			

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Bloco de Transferencia                                                  ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			For nCntFor := 1 To Len(aRecAA4)
				dbSelectArea("AA4")
				MsGoto(aRecAA4[nCntFor])
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Atualiza historico dos acessorios                                  ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				dbSelectArea("AA4")
				RecLock("AA4")
				AA4->AA4_CODCLI := cCodCli
				AA4->AA4_LOJA   := cLoja
			Next nCntFor

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Atualiza o historico do equipamento                               ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			Reclock("AAF",.T.)
			AAF->AAF_FILIAL := xFilial("AAF")
			AAF->AAF_CODCLI := cCodCli
			AAF->AAF_LOJA   := cLoja
			AAF->AAF_CODPRO := AA3->AA3_CODPRO
			AAF->AAF_NUMSER := AA3->AA3_NUMSER
			AAF->AAF_PRODAC := AA3->AA3_CODPRO
			AAF->AAF_NSERAC := AA3->AA3_NUMSER
			AAF->AAF_DTINI  := dDataBase
			AAF->AAF_CODFAB := AA3->AA3_CODFAB
			AAF->AAF_LOJAFA := AA3->AA3_LOJAFA
			AAF->AAF_LOGINI := Left( STR0003 + cCodCliAnt + "/" + ;
								cLojaCliAnt + STR0004 + cCodCli + "/" + cLoja, Len( AAF->AAF_LOGINI ) ) // # "TRANSFERENCIA DE CLIENTE/LOJA " ## " PARA "
			AAF->( MsUnlock() )

			lGravou := .T.

		Else
			If ( nModulo == 28 ) // Variavel Public
				Help(" ",1,"AT040INC01")
			EndIf
			lGravou := .F.
		EndIf
	Else
		If ( nModulo == 28 ) // Variavel Public
			Help(" ",1,"RECNOIS")
		EndIf
		lGravou := .F.
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Altera o Status do equipamento                                          ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	AtEqStatus(FunName())
EndCase
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Limpa variaveis de campos virtuais                  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
M->AA3_DESPRO := ""
M->AA3_NOMCLI := ""
M->AA3_NOMTEC := ""

AA3->( MsUnlock() )

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Executa o ponto de entrada                          ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lGravou
	If ExistBlock( "AT040GRV" )
		ExecBlock( "AT040GRV", .F., .F., { nOpcao } )
	EndIf
EndIf

Return .T.

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³SldAtuEst ³ Autor ³ Eduardo Riera         ³ Data ³ 01.02.99 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Avalia os saldo por Almoxarifado, Lote e Localizacao,       ³±±
±±³          ³ate a quantidade informada no parametro (3).                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpN1: Quantidade em estoque disponivel                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpC1: Codigo do Produto         - Obrigatorio              ³±±
±±³          ³ExpC2: Local                     - Obrigatorio              ³±±
±±³          ³ExpC3: Quantidade                - Obrigatorio              ³±±
±±³          ³ExpC4: Lote de Controle          - Obrig. se Inf. Sub-Lote  ³±±
±±³          ³ExpC5: Sub-Lote                                             ³±±
±±³          ³ExpC6: Localizacao               - Obrig. se inf. Nr.Serie  ³±±
±±³          ³ExpC7: Numero de Serie                                      ³±±
±±³          ³ExpC8: Reserva                                              ³±±
±±³          ³ExpL9: Indica se considera poder de terceiro                ³±±
±±³          ³ExpLA: Indica se considera poder em terceiro                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³   DATA   ³ Programador   ³Manutencao Efetuada                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³               ³                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function SldAtuEst(cCodPro,cLocal,nQtd,cLoteCtl,cNumLote,cLocaliz,cNumSer,cReserva,lConsTerc,lConsQNPt,cProjeto,cTarefa,cServico,lPrdBn)

Local cLoteSb8     := ""
Local cNumLSb8     := ""

Local cAliasSB8    := "SB8"
Local cAliasSBF    := "SBF"
Local cFilialSB8   :=  xFilial("SB8")
Local cFilialSBF   :=  xFilial("SBF")

Local nSaldo       := 0
Local nEmpenho     := 0

Local nQtdSB8      := 0
Local nReserva     := 0
Local nReservaSB8  := 0
Local nBFSaldo     := 0
Local lContSB8     := .T.
Local lContSBF     := .T.
Local lUsaVenc     := .F.
Local lQuery       := .F.
Local lLocaliza    := Localiza(cCodPro,.T.)
Local nRecSB8      := 0
Local lEmpPrev     := If(SuperGetMV("MV_QTDPREV")== "S",.T.,.F.)
Local lQEmpNF	   := GetNewPar("MV_QEMPNF",.F.)	//Considera o campo B2_QEMPN no calculo do Saldo
Local lAtuSGJ      := SuperGetMV("MV_PVCOMOP",.F.,.F.) .And. FindFunction("ALIASINDIC") .And. AliasIndic("SGJ")
Local lWmsNew      := SuperGetMV("MV_WMSNEW",.F.,.F.)
Local l455LibAlt   := IsInCallStack("A455LibAlt") .And. SuperGetMv("MV_GRVBLQ2",.F.,.F.)
Local aStruSB8     := {}
Local aStruSBF     := {}
Local cQuery       := ""
Local nX           := 0
Local aInsert 	   := {}
Local nIniLoopPS   := 1
Local nLen 		   := 0 
Local nPosPrepared := 0 
Local cMD5 		   := "" 
Local lVerLib	   := FatxVerLib()


DEFAULT lConsQNPT := .F.
DEFAULT cProjeto	:= ""
DEFAULT cTarefa		:= ""
DEFAULT cServico    := ""
DEFAULT lPrdBn		:= .F.

If lAtuSGJ
	lQEmpNF	:= .F.
Endif

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Analisa os dados de entrada da funcao                                   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
cLoteCtl  := If(cLoteCtl == NIL .Or. Empty(cLoteCtl),"",cLoteCtl)
cNumLote  := If(cNumLote == NIL .Or. Empty(cNumLote) .Or. Rastro(cCodPro,"L"),"",cNumLote)
cLocaliz  := If(cLocaliz == NIL .Or. Empty(cLocaliz),If(!Empty(cNumSer),Space(Len(SBF->BF_LOCALIZ)),""),cLocaliz)
cNumSer   := If(cNumSer  == NIL .Or. Empty(cNumSer) ,"",cNumSer)
lUsaVenc  := If(!Empty(cLoteCtl+cNumLote),.T.,(SuperGetMv('MV_LOTVENC')=='S'))
cReserva  := If("C6_RESERVA"$ ReadVar(),&(ReadVar()),cReserva)

If !BlqInvent(cCodPro,cLocal,,If(!__lPyme, cLocaliz, '')) .And. !(FindFunction('AvalBlqLoc') .And. AvalBlqLoc(cCodPro,cLocal,Nil,.F.))
	If ( Empty(cReserva) .OR. Iif(ExistFunc("LjxValEst"), LjxValEst(SC5->C5_ORCRES), .F. ))
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Verifica os Saldos por Lote / Sub-Lote / Localizacao                    ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If ( Rastro(cCodPro) ) .And. Empty(cServico)
			dbSelectArea("SB8")
			dbSetOrder(3)
			SB8->(dbCommit())

			lQuery    := .T.
			cAliasSB8 := "SLDATUEST"
			aStruSB8  := SB8->(dbStruct())

			For nX := 1 To Len(aStruSB8)
				cQuery += ",SB8."+aStruSB8[nX][1]
			Next nX
			If lLocaliza .And. !(lWmsNew .And. IntWms(cCodPro))
				SBF->(dbCommit())
				cAliasSBF := "SLDATUEST"
				aStruSBF  := SBF->(dbStruct())
				For nX := 1 To Len(aStruSBF)
					cQuery += ",SBF."+aStruSBF[nX][1]
				Next nX
			EndIf

			cQuery    := "SELECT "+SubStr(cQuery,2)+" "
			cQuery    += ",SB8.R_E_C_N_O_ SB8RECNO "

			Aadd(aInsert,RetSqlName("SB8"))
			nIniLoopPS++
			cQuery    += "FROM ? SB8 "
			
			If lLocaliza .And. !(lWmsNew .And. IntWms(cCodPro))
				Aadd(aInsert,RetSqlName("SBF"))
				cQuery += ", ? SBF "
				nIniLoopPS++
			EndIf
			Aadd(aInsert,cFilialSB8)
			cQuery    += "WHERE SB8.B8_FILIAL= ? AND "
			
			Aadd(aInsert,cCodPro)
			cQuery    += "SB8.B8_PRODUTO= ? AND "
			
			Aadd(aInsert,cLocal)
			cQuery    += "SB8.B8_LOCAL= ? AND "

			If !Empty(cLoteCtl)
				Aadd(aInsert,cLoteCtl)
				cQuery    += "SB8.B8_LOTECTL= ? AND "
			EndIf
			If !Empty(cNumLote)
				Aadd(aInsert,cNumLote)
				cQuery    += "SB8.B8_NUMLOTE= ? AND "
			EndIf

			cQuery    += "SB8.B8_SALDO > 0 AND SB8.D_E_L_E_T_ = ' ' "
			If lLocaliza .And. !(lWmsNew .And. IntWms(cCodPro))
				Aadd(aInsert,cFilialSBF)
				cQuery    += " AND SBF.BF_FILIAL= ? AND "
				
				Aadd(aInsert,cCodPro)
				cQuery    += "SBF.BF_PRODUTO= ? AND "
				
				Aadd(aInsert,cLocal)
				cQuery    += "SBF.BF_LOCAL= ? AND "
				cQuery    += "SBF.BF_LOTECTL=SB8.B8_LOTECTL AND "
				If !Empty(cNumLote)
					cQuery    += "SBF.BF_NUMLOTE=SB8.B8_NUMLOTE AND "
				EndIf
				cQuery    += "SBF.D_E_L_E_T_=' ' "
				cQuery    += "ORDER BY "+SqlOrder(SB8->(IndexKey()))+","+SqlOrder(SBF->(IndexKey()))
			Else
				cQuery    += "ORDER BY "+SqlOrder(SB8->(IndexKey()))
			EndIf

			nLen := Len(aInsert)
			cMD5 := MD5(cQuery) 
			If (nPosPrepared := Ascan(__aPrepared,{|x| x[2] == cMD5})) == 0 
				cQuery := ChangeQuery(cQuery)
				Aadd(__aPrepared,{IIf(lVerLib,FwExecStatement():New(cQuery),FWPreparedStatement():New(cQuery)),cMD5})
				nPosPrepared := Len(__aPrepared)
			Endif 
			__aPrepared[nPosPrepared][1]:SetUnsafe(1,aInsert[1])

			If nIniLoopPS > 2
				__aPrepared[nPosPrepared][1]:SetUnsafe(2,aInsert[2])
			EndIf

			For nX := nIniLoopPS to nLen
				__aPrepared[nPosPrepared][1]:SetString(nX,aInsert[nX])
			Next 

			If lVerLib
				__aPrepared[nPosPrepared][1]:OpenAlias(cAliasSB8)
				dbselectarea(cAliasSB8)
			Else
				cQuery := __aPrepared[nPosPrepared][1]:getFixQuery()
				dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasSB8,.T.,.T.)
			EndIf
			aInsert := aSize(aInsert,0)
			
			For nX := 1 To Len(aStruSB8)
				If aStruSB8[nX][2]<>"C"
					TcSetField(cAliasSB8,aStruSB8[nX][1],aStruSB8[nX][2],aStruSB8[nX][3],aStruSB8[nX][4])
				EndIf
			Next nX
			If lLocaliza .And. !(lWmsNew .And. IntWms(cCodPro))
				For nX := 1 To Len(aStruSBF)
					If aStruSBF[nX][2]<>"C"
						TcSetField(cAliasSBF,aStruSBF[nX][1],aStruSBF[nX][2],aStruSBF[nX][3],aStruSBF[nX][4])
					EndIf
				Next nX
			EndIf
			
			While ( !Eof() .And. cFilialSB8 == (cAliasSB8)->B8_FILIAL .And.;
					cCodPro        == (cAliasSB8)->B8_PRODUTO .And.;
					cLocal         == (cAliasSB8)->B8_LOCAL   .And.;
					(cLoteCtl      == (cAliasSB8)->B8_LOTECTL.Or.Empty(cLoteCtl)).And.;
					(cNumLote      == (cAliasSB8)->B8_NUMLOTE.Or.Empty(cNumLote)).And.;
					lContSB8 )
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Avalia os Saldos por Lote e Sub-Lote                                    ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				nReservaSB8:=0
				lContSBF := .T.
				If lQuery
					nRecSB8:=(cAliasSB8)->SB8RECNO
				EndIf
				nQtdSB8:=Min(nQtd-nReserva,SB8Saldo(NIL,lUsaVenc,NIL,NIL,cAliasSB8,lEmpPrev,NIL,dDataBase))
				If nQtdSB8 > 0 .And. If(lUsaVenc, .T., ((cAliasSB8)->B8_DTVALID >= dDataBase .Or.Empty((cAliasSB8)->B8_DTVALID)))
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³Avalia os saldos por Localizacao e Nr.Serie                             ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If lLocaliza  .And. !(lWmsNew .And. IntWms(cCodPro))
						cNumLSb8 := If(Rastro(cCodPro,"S"),(cAliasSB8)->B8_NUMLOTE,Space(Len(SB8->B8_NUMLOTE)))
						cLoteSb8 := (cAliasSB8)->B8_LOTECTL
						If !lQuery
							dbSelectArea("SBF")
							dbSetOrder(2)
							MsSeek(cFilialSBF+cCodPro+cLocal+cLoteSb8+cNumLSb8)
						EndIf
						While ( !Eof() .And. cFilialSBF == (cAliasSBF)->BF_FILIAL .And.;
								cCodPro        == (cAliasSBF)->BF_PRODUTO .And.;
								cLocal         == (cAliasSBF)->BF_LOCAL  .And.;
								cLoteSb8       == (cAliasSBF)->BF_LOTECTL .And.;
								lContSBF)
							If ( ((cAliasSBF)->BF_LOCALIZ == cLocaliz .Or.;
									Empty(cLocaliz) ) .And.;
									((cAliasSBF)->BF_NUMSERI == cNumSer  .Or.;
									Empty(cNumSer)) .And.;
									(cNumLSb8 == (cAliasSBF)->BF_NUMLOTE .Or.;
									Empty(cNumLSb8)) )
									nBFSaldo := SBFSaldo(,cAliasSBF)
								If ( nBFSaldo > 0 )
									nEmpenho := nQtdSB8 - nReservaSB8
									nEmpenho := Min(nBFSaldo,nEmpenho)
									nSaldo   += nEmpenho
									nReserva += nEmpenho
									nReservaSB8 += nEmpenho
								EndIf
							EndIf
							If (nReservaSB8 >= nQtdSB8)
								lContSBF := .F.
							EndIf
							dbSelectArea(cAliasSBF)
							dbSkip()
						EndDo
					Else
						nEmpenho := nQtdSB8 - nReservaSB8
						nEmpenho := Min(SB8Saldo(NIL,lUsaVenc,NIL,NIL,cAliasSB8,lEmpPrev,NIL,dDataBase),nEmpenho)
						nSaldo   += nEmpenho
						nReserva += nEmpenho
						nReservaSB8 += nEmpenho
					EndIf
				EndIf
				If (nReserva >= nQtd)
					lContSB8 := .F.
				EndIf
				dbSelectArea(cAliasSB8)
				If lQuery
					While !Eof() .And. (cAliasSB8)->SB8RECNO == nRecSB8
						dbSkip()
					End
				Else
					dbSkip()
				EndIf
			EndDo
			If lQuery
				dbSelectArea(cAliasSB8)
				dbCloseArea()
				dbSelectArea("SB8")
			EndIf
			dbSelectArea("SB2")
			dbSetOrder(1)
			DbSeek(xFilial("SB2")+cCodPro+cLocal)
			nSaldo := Min(nSaldo,SaldoSb2(,If(!Empty(cServico),.T.,!lPrdBn .And. GetNewPar("MV_QEMPV",.F.)),,lConsTerc,lConsQNPT))
		EndIf
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Verifica os saldo por Localizacao quando nao ha rastro                  ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If ( !Rastro(cCodPro) .And. lLocaliza .And. nSaldo == 0 ) .And. Empty(cServico) .And. !(lWmsNew .And. IntWms(cCodPro))
			dbSelectArea("SBF")
			dbSetOrder(2)
			SBF->(dbCommit())
			lQuery := .T.
			aStruSBF  := SBF->(dbStruct())
			cAliasSBF := "SLDATUESTSBF"

			cQuery    := "SELECT * "

			Aadd(aInsert, RetSqlName("SBF"))
			cQuery    += "FROM ? SBF "

			Aadd(aInsert, cFilialSBF)
			cQuery    += "WHERE SBF.BF_FILIAL= ? AND "

			Aadd(aInsert, cCodPro)
			cQuery    += "SBF.BF_PRODUTO= ? AND "
			
			Aadd(aInsert, cLocal)
			cQuery    += "SBF.BF_LOCAL= ? AND "

			If !Empty(cLocaliz)
				Aadd(aInsert, cLocaliz)
				cQuery    += "SBF.BF_LOCALIZ = ? AND "
			EndIf
			If !Empty(cNumSer)
				Aadd(aInsert, cNumSer)
				cQuery    += "SBF.BF_NUMSERI = ? AND "
			EndIf
			cQuery    += "SBF.D_E_L_E_T_=' ' "
			cQuery    += "ORDER BY "+SqlOrder(SBF->(IndexKey()))

			nLen := Len(aInsert)
			cMD5 := MD5(cQuery) 
			If (nPosPrepared := Ascan(__aPrepared,{|x| x[2] == cMD5})) == 0 
				cQuery := ChangeQuery(cQuery)
				Aadd(__aPrepared,{IIf(lVerLib,FwExecStatement():New(cQuery),FWPreparedStatement():New(cQuery)),cMD5})
				nPosPrepared := Len(__aPrepared)				
			Endif 

			__aPrepared[nPosPrepared][1]:SetUnsafe(1,aInsert[1])
			
			For nX := 2 to nLen
				__aPrepared[nPosPrepared][1]:SetString(nX,aInsert[nX])
			Next 
			
			If lVerLib
				__aPrepared[nPosPrepared][1]:OpenAlias(cAliasSBF)
			Else
				cQuery := __aPrepared[nPosPrepared][1]:getFixQuery()
				dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasSBF,.T.,.T.)
			EndIF

			aInsert := aSize(aInsert,0)
			
			For nX := 1 To Len(aStruSBF)
				If aStruSBF[nX][2]<>"C"
					TcSetField(cAliasSBF,aStruSBF[nX][1],aStruSBF[nX][2],aStruSBF[nX][3],aStruSBF[nX][4])
				EndIf
			Next nX
			While ( (cAliasSBF)->(!Eof()) .And. cFilialSBF == (cAliasSBF)->BF_FILIAL .And.;
					cCodPro        == (cAliasSBF)->BF_PRODUTO .And.;
					cLocal         == (cAliasSBF)->BF_LOCAL .And.;
					lContSBF)
				If ( ((cAliasSBF)->BF_LOCALIZ == cLocaliz .Or.;
						Empty(cLocaliz) ) .And.;
						((cAliasSBF)->BF_NUMSERI == cNumSer  .Or.;
						Empty(cNumSer)) )
						nBFSaldo := SBFSaldo(,cAliasSBF)
					If ( nBFSaldo > 0 )
						nEmpenho := nQtd - nReserva
						nEmpenho := Min(nBFSaldo,nEmpenho)
						nReserva += nEmpenho
						nSaldo   += nEmpenho
					EndIf
				EndIf
				dbSelectArea(cAliasSBF)
				dbSkip()
				If ( nReserva >= nQtd )
					lContSBF:= .F.
				EndIf
			EndDo
			If lQuery
				dbSelectArea(cAliasSBF)
				dbCloseArea()
				dbSelectArea("SBF")
			EndIf
			dbSelectArea("SB2")
			dbSetOrder(1)
			DbSeek(xFilial("SB2")+cCodPro+cLocal)
			nSaldo := Min(nSaldo,SaldoSb2(,If(!Empty(cServico),.T.,!lPrdBn .And. GetNewPar("MV_QEMPV",.F.)),,lConsTerc,lConsQNPT))
		EndIf
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Verifica SB2 quando nao ha rastro nem localizacao ou qdo se usa o WMS   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If (!Rastro(cCodPro) .And. !Localiza(cCodPro,.T.)) .Or. !Empty(cServico)
			dbSelectArea("SB2")
			dbSetOrder(1)
			dbSeek(xFilial("SB2")+cCodPro+cLocal)
			nSaldo	:= SaldoSb2(,If(!Empty(cServico),.T.,!lPrdBn .And. GetNewPar("MV_QEMPV",.F.)),,lConsTerc,lConsQNPT)
			If !Empty(cProjeto) .And. !Empty(cTarefa)
				nSaldo := MAX(nSaldo,0)
				dbSelectArea("AFJ")
				dbSetOrder(1)
				MsSeek(xFilial("AFJ")+cProjeto+cTarefa)
				While !Eof() .And.xFilial("AFJ")+cProjeto+cTarefa == AFJ->AFJ_FILIAL + AFJ->AFJ_PROJET + AFJ->AFJ_TAREFA
					nSaldo += Max(AFJ->AFJ_QEMP - AFJ->AFJ_QATU,0)
					dbSkip()
				End
			EndIf
			nSaldo := Min(nQtd,nSaldo)
		Else
			If lConsQNPT
				dbSelectArea("SB2")
				dbSetOrder(1)
				MsSeek(xFilial("SB2")+cCodPro+cLocal)
				nSaldo += SB2->B2_QNPT
			EndIf
		EndIf
	Else
		dbSelectArea("SC0")
		dbSetOrder(1)
		MsSeek(xFilial("SC0")+cReserva+cCodPro+cLocal)
		nSaldo := Min(SC0->C0_QUANT,nQtd)
	EndIf
EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Soma ao Saldo o Valor Empenhado na B2_QEMPN para este Pedido            ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lQEmpNF
	If !l455LibAlt .And. (!Empty(SC6->C6_NUMOP) .Or. !Empty(SC6->C6_NUMSC) .Or. SC6->C6_OP = "05")
		nSaldo += SC6->C6_QTDVEN - If(FindFunction("A650QLibPV"),A650QLibPV(),0)
	EndIf
Endif
Return(nSaldo)

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³AtIsRotina³ Autor ³ Eduardo Riera         ³ Data ³ 29.01.99 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Verifica qual eh a rotina chamadora.                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpL1: Logico                                               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpC1: Descricao da Rotina Chamadora para Teste.            ³±±
±±³          ³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³   DATA   ³ Programador   ³Manutencao Efetuada                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³               ³                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function AtIsRotina(cRotina)

Local lRetorno := .F.
Local nContador:= 1
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Verifica qual a rotina chamadora                                        ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
While ( !lRetorno .And. !Empty(ProcName(nContador)) )
	If ( Upper(ProcName(nContador))==cRotina )
		lRetorno := .T.
	EndIf
	nContador++
EndDo
Return(lRetorno)

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³MaAvalCred³ Autor ³ Eduardo Riera         ³ Data ³ 10.03.99 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Funcao Generica de Avaliacao de Credito de Clientes         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpL1: Credito (Sim/Nao)                                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpC1: Codigo do Cliente                                    ³±±
±±³          ³ExpC2: Loja do Cliente                                      ³±±
±±³          ³ExpN3: Valor a ser avaliado                                 ³±±
±±³          ³ExpN4: Moeda do valor a ser avaliado                        ³±±
±±³          ³ExpL5: Considera acumulados de Pedido de Venda do SA1       ³±±
±±³          ³ExpC6: Codigo do Bloqueio.                                  ³±±
±±³          ³ExpC7: aEmpenho                                             ³±±
±±³          ³ExpN8: Valor a ser adicionado ao limite de credito          ³±±
±±³          ³ExpN9: Valor adicional de credito 					           ³±±
±±³          ³ExpN10: Array de referencia tipo de bloqueio de credito     ³±±
±±³          ³ExpL11: Indica se realizará o Save/Rest das áreas (.T./.F.) ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³   DATA   ³ Programador   ³Manutencao Efetuada                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³               ³                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function MaAvalCred(cCodCli, cLoja, nValor, nMoeda, lPedido, cCodigo, aEmpenho, nVlrCred, nVlAdicCre, aValdet, lSaveArea,cComplTur,cSegTur,cArqAC)
Local aArea			:= {}
Local aAreaSA1		:= {}
Local aAreaSE1		:= {}
Local aStruSA1		:= {}
Local cTipoLim		:= SuperGetMv("MV_CREDCLI")
Local cQuery			:= ""
Local cAliasSE1		:= "SE1"
Local cAliasSA1		:= "SA1"
Local cAliasQry		:= ""
Local nLimCred		:= 0
Local nLimCredFin		:= 0
Local nVlrReal		:= xMoeda(nValor,nMoeda,1,dDataBase,2)
Local nVlrFin			:= 0
Local nVlrPed			:= nVlrReal
Local nLiminCr		:= SuperGetMv("MV_LIMINCR")  //Limite Minimo de Credito
Local nPerMax			:= SuperGetMv("MV_PERMAX")   //Percentual Maximo comprometido com o Limite de Credito
Local nFaixaA			:= SuperGetMv("MV_PEDIDOA")  //Limite de Credito para a Faixa A
Local nFaixaB			:= SuperGetMv("MV_PEDIDOB")  //Limite de Credito para a Faixa B
Local nFaixaC			:= SuperGetMv("MV_PEDIDOC")  //Limite de Credito para a Faixa C
Local nNumDias		:= 0
Local nRegEmp			:= 0
Local nMCusto			:= 0
Local nX				:= 0
Local lQuery			:= .F.
Local lRetorno		:= .T.
Local lCredito		:= .F.
Local lTitVenc		:= .F.
Local xRetorno		:= ""
Local cRiscoAC 		:= ""
Local nLimiteAC		:= 0
Local nMoedaAC 		:= 0
Local dVencAC  		:= StoD("")
Local cSepNeg			:= If("|"$MV_CRNEG,"|",",")
Local cSepProv		:= If("|"$MVPROVIS,"|",",")
Local cSepRec			:= If("|"$MVRECANT,"|",",")
Local lIntGC	 		:= IIf((SuperGetMV("MV_VEICULO",,"N")) == "S"   ,.T.,.F.)
Local lIntTUR	 		:= .F.
Local lMaAvCrFin		:= ExistBlock("MAAVCRFIN")
Local cSeqTxtLog	:= ""
Local lLogPedTxt	:= FindFunction("LogPedTxt") .And. SuperGetMV("MV_FTLOGPV",,.F.)
Local lAvalCrd		:= SuperGetMV("MV_AVALCRD",,.F.) 

Default nVlrCred		:= 0
Default nVlAdicCre	:= 0
Default aValdet		:= {} // [cCodigo[lCredito,lTitVenc]] Detalha o tipo de bloqueio por credito (Credito,Título)
Default lSaveArea		:= .T.	// .T.=Executa o Save/Rest das áreas / .F. = Nâo executa o Save/Rest das áreas
DEFAULT cComplTur  	:= "" //Complemento do módulo de turismo
DEFAULT cSegTur    	:= "" //Complemento do módulo de turismo
DEFAULT cArqAC     	:= ""

lIntTUR	 := IIf( !Empty(cComplTur) .And. !Empty(cSegTur) ,.T.,.F.)
cArqAC   := "SA1"

If	lMaAvCred == NIL
	lMaAvCred			:= ExistBlock("MAAVCRED")
EndIf
If	lMaAvCrPr == NIL
	lMaAvCrPr			:= ExistBlock("MAAVCRPR")
EndIf

If	lSaveArea
	aArea				:= GetArea()
	aAreaSA1			:= SA1->(GetArea())
	aAreaSE1			:= SE1->(GetArea())
EndIf

dbSelectArea("SA1")
dbSetOrder(1)
If ( (SuperGetMv("MV_BLOQUEI" ) .or. lIntTUR ) .And. !lMaAvCred )
	Do Case
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Aqui e Verificado o Cliente Por Codigo + Loja                           ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	Case ( cTipoLim=="L" )
		If ( MsSeek(xFilial("SA1")+cCodCli+cLoja) )
			
			If lIntTUR
				If G8T->(dbSeek(xFilial("G8T")+cComplTur+cSegTur))
					cRiscoAC := G8T->G8T_RISCO
					dVencAC  := G8T->G8T_VENCTO
					nLimiteAC:= G8T->G8T_LIMITE
					nMoedaAC := Posicione("G5T",1,xFilial("G5T") + G8T->G8T_MOEDA,"G5T_MOEDAF") //G8T->G8T_MOEDA
					cArqAC   := "G8T"
				Else
					cRiscoAC := SA1->A1_RISCO
					dVencAC  := SA1->A1_VENCLC
					nLimiteAC:= SA1->A1_LC
					nMoedaAC := SA1->A1_MOEDALC
				EndIf
			Else
				cRiscoAC := SA1->A1_RISCO
				dVencAC  := SA1->A1_VENCLC
				nLimiteAC:= SA1->A1_LC
				nMoedaAC := SA1->A1_MOEDALC				
			EndIf
			
			If ( cRiscoAC == "A" )
				lRetorno := .T.
			EndIf
			If ( cRiscoAC == "E" .And. nVlrCred<=0)
				lRetorno := .F.
				cCodigo  := "01" // Limite de Credito
				lCredito := .T.
				cSeqTxtLog := "01"
			EndIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Aqui e avaliado o Vencimento do Limite de Credito do Cliente            ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If ( !Empty(dVencAC) .And. dVencAC < dDataBase ) .And. nVlrCred <= 0
				cCodigo  := "04" //Vencimento do Limite de Credito
				lRetorno := .F.
				lCredito := .T.
				cSeqTxtLog := "02"
			EndIf
			If ( cRiscoAC <> "A" .And. !(cRiscoAC $ "E,Z" .And. nVlrCred<=0) .And. lRetorno)
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Aqui e verificado o Limite de Credito do Cliente + Loja                 ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³O Limite de Credito sempre esta na Moeda MV_MCUSTO, mas os calculos sao ³
				//³em na moeda corrente.                                                   ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				nMCusto	 := IIf( nMoedaAC > 0 , nMoedaAC , Val(SuperGetMv("MV_MCUSTO")) )
				nVlrCred := xMoeda(nVlrCred,nMoeda,1,dDataBase,2)
				If cRiscoAC $ "E,Z"
					nLimCred := 0
				Else
					nLimCred := xMoeda(nLimiteAC,nMCusto,1,dDataBase,2)
				EndIf
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Adicional de Crédito quando utilizado o 9o Parâmetro							³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If nVlAdicCre > 0 .and. lIntGC // Modulo de Concessionárias
					nLimCred += nVlAdicCre
				Endif
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Verifica se o Valor nao eh maior que o Limite de Credito                ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If ( lPedido )
					If nVlrCred < nVlrReal
						nVlrReal += SA1->A1_SALDUP + xMoeda(SA1->A1_SALPEDL,nMCusto,1,dDatabase,2)
					Else
						nVlrReal += SA1->A1_SALDUP + xMoeda(SA1->A1_SALPEDL,nMCusto,1,dDatabase,2)
						nLimCred += nVlrCred
						//Caso utilize o MV_AVALCRD, deverá somar o SA1->A1_SALDUP para comparar com o nVlrReal
						If lAvalCrd .And. ALTERA .And. IsInCallStack("a410Altera") .And. M->C5_LIBEROK == "S" 
							nLimCred += SA1->A1_SALDUP + xMoeda(SA1->A1_SALPEDL,nMCusto,1,dDatabase,2)
						EndIf
					EndIf
					If ( aEmpenho <> Nil ) .And. ( !Empty(aEmpenho) )
						nRegEmp  := aScan(aEmpenho[1],{|x| x[1]==SA1->(RecNo())})
						If ( nRegEmp <> 0 )
							nVlrReal += xMoeda(aEmpenho[1][nRegEmp][2],nMCusto,1,dDatabase,2)
						EndIf
					EndIf
				EndIf
				If( lIntTUR )
					If nVlrCred < nVlrReal
						nVlrReal += SA1->A1_SALDUP
					EndIf
				EndIf
				If ( nVlrReal > nLimCred .And. nVlrReal > 0)
					cCodigo  := "01" // Limite de Credito
					lRetorno := .F.
					lCredito := .T.
					cSeqTxtLog := "03"
				EndIf
				
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Controle de limite de credito secundario                                ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If cRiscoAC $ "E,Z" .Or. (cPaisLoc == "PAR" .And. SA1->A1_LCFIN > 0 .And. cRiscoAC $ "B,C,D")
					nLimCredFin	:= xMoeda(SA1->A1_LCFIN,nMCusto,1,dDataBase,MsDecimais(1))
				Else
					nLimCredFin := 0
				EndIf
				If ( aEmpenho <> Nil ) .And. ( !Empty(aEmpenho) )
					nRegEmp  := aScan(aEmpenho[1],{|x| x[1]==SA1->(RecNo())})
					If ( nRegEmp <> 0 )
						nLimCredFin -= aEmpenho[1][nRegEmp][3]
					EndIf
				EndIf				
				If SA1->A1_SALFIN > nLimCredFin .And. SA1->A1_LCFIN > 0
					cCodigo 	:= "01" // Limite de Credito
					lRetorno := .F.
					lCredito := .T.
				EndIf
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Verifica as Classes de Cliente                                          ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If nVlrReal > 0
					Do Case
						Case ( nVlrReal <= nLiMinCr )
							lRetorno := .T.
							cCodigo  := ""
							lCredito := .T.
						Case ( nVlrReal > ((nPerMax * nLimCred) / 100) )
							lRetorno := .F.
							cCodigo  := "01" // Limite de Credito
							lCredito := .T.
							cSeqTxtLog := "05"
						Case ( SA1->A1_CLASSE == "A" .And. nVlrPed > nfaixaA .And. nFaixaA <> 0 )
							lRetorno := .F.
							cCodigo  := "01" // Limite de Credito
							lCredito := .T.
							cSeqTxtLog := "06"
						Case ( SA1->A1_CLASSE == "B" .And. nVlrPed > nfaixaB .And. nFaixaB <> 0 )
							lRetorno := .F.
							cCodigo  := "01" // Limite de Credito
							lCredito := .T.
							cSeqTxtLog := "07"
						Case ( SA1->A1_CLASSE == "C" .And. nVlrPed > nfaixaC .And. nFaixaC <> 0 )
							lRetorno := .F.
							cCodigo  := "01" // Limite de Credito
							lCredito := .T.
							cSeqTxtLog := "08"
					EndCase
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³Aqui e verificado o Grau de Risco do Cliente + Loja                     ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If ( lRetorno .And. !Empty(cRiscoAC) .And. !cRiscoAC $"E,Z")
						
						If lIntTUR
							nNumDias := SuperGetMv("MV_RISCO"+cRiscoAC+ Iif(cSegTur=="1","C",Iif(cSegTur=="2","E","L")))
						Else
							nNumDias := SuperGetMv("MV_RISCO"+cRiscoAC)
						EndIf
						
						dbSelectArea("SE1")
						dbSetOrder(8)
						lQuery    := .T.
						cAliasSE1 := "MAAVALCRED"

						cQuery    := "SELECT MIN(E1_VENCREA) VENCREAL "
						cQuery    += "FROM "+RetSqlName("SE1")+" SE1 "
						cQuery    += "WHERE SE1.E1_FILIAL='"+xFilial("SE1")+"' AND "
						cQuery    += "SE1.E1_CLIENTE='"+cCodCli+"' AND "
						cQuery    += "SE1.E1_LOJA='"+cLoja+"' AND "
						cQuery    += "SE1.E1_STATUS='A' AND "
						cQuery    += "SE1.E1_TIPO NOT IN " + FormatIn(MVABATIM,"|") + " AND "
						cQuery    += "SE1.E1_TIPO NOT IN " + FormatIn(MV_CRNEG,cSepNeg)  + " AND "
						cQuery    += "SE1.E1_TIPO NOT IN " + FormatIn(MVPROVIS,cSepProv) + " AND "
						cQuery    += "SE1.E1_TIPO NOT IN " + FormatIn(MVRECANT,cSepRec)  + " AND "
						cQuery    += "SE1.D_E_L_E_T_=' ' "

						If lMaAvCrFin
							cQuery:= ExecBlock("MAAVCRFIN", .F., .F., {cQuery, cCodCli, cLoja})
						EndIf
						cQuery := ChangeQuery(cQuery)
						
						dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasSE1,.T.,.T.)

						TcSetField(cAliasSE1,"VENCREAL","D",8,0)

						If (cAliasSE1)->(!Eof()) .And. !Empty((cAliasSE1)->VENCREAL) .And. (dDataBase - (cAliasSE1)->VENCREAL) > nNumDias
							lRetorno := .F.
							cCodigo  := "01" // Limite de Credito
							lTitVenc := .T.
							cSeqTxtLog := "09"
						EndIf

						dbSelectArea(cAliasSE1)
						dbCloseArea()
						dbSelectArea("SE1")

					EndIf
				EndIf
			EndIf
		EndIf
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Aqui e verificado apenas o Codigo ( Matriz )                            ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	Case ( cTipoLim == "C" )
		If ( MsSeek(xFilial("SA1")+cCodCli) )
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ O Grau de Risco deve ser Avaliado da Matriz                   ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

			If lIntTUR
				If G8T->(dbSeek(xFilial("G8T")+cComplTur+cSegTur))
					cRiscoAC := G8T->G8T_RISCO
					dVencAC  := G8T->G8T_VENCTO
					nLimiteAC:= G8T->G8T_LIMITE
					nMoedaAC := Posicione("G5T",1,xFilial("G5T") + G8T->G8T_MOEDA,"G5T_MOEDAF") // G8T->G8T_MOEDA
					cArqAC   := "G8T"
				Else
					cRiscoAC := SA1->A1_RISCO
					dVencAC  := SA1->A1_VENCLC
					nLimiteAC:= SA1->A1_LC
					nMoedaAC := SA1->A1_MOEDALC
				EndIf
			Else
				cRiscoAC := SA1->A1_RISCO
				dVencAC  := SA1->A1_VENCLC
				nLimiteAC:= SA1->A1_LC
				nMoedaAC := SA1->A1_MOEDALC
			EndIf

			If ( cRiscoAC == "A" )
				lRetorno := .T.
				cCodigo  := ""
			EndIf
			If ( cRiscoAC == "E"  .And. nVlrCred<=0)
				lRetorno := .F.
				cCodigo  := "01" // Limite de Credito
				lCredito := .T.
				cSeqTxtLog := "01"
			EndIf
			
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Aqui e avaliado o Vencimento do Limite de Credito do Cliente            ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If ( !Empty(dVencAC) .And. dVencAC < dDataBase )
				lRetorno := .F.
				cCodigo  := "04" // Vencimento do Limite de Credito
				cSeqTxtLog := "02"
			EndIf
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Aqui e verificado o Limite de Credito do Cliente                        ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³O Limite de Credito sempre esta na Moeda MV_MCUSTO, mas os calculos sao ³
			//³em na moeda corrente.                                                   ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If ( cRiscoAC <> "A" .And. !(cRiscoAC $ "E,Z" .And. nVlrCred<=0) .And. lRetorno )
	
				nLimCred := 0
				nLimCredFin	:= 0
				dbSelectArea("SA1")
				dbSetOrder(1)
				cAliasSA1 := "QRYSA1"
				lQuery    := .T.

				aStruSa1  := SA1->(dbStruct())

				cQuery := "SELECT A1_FILIAL,A1_COD,A1_MOEDALC,A1_LC,A1_LCFIN,A1_SALFIN,A1_SALDUP,A1_SALPEDL,A1_VENCLC,A1_RISCO,R_E_C_N_O_ RECSA1 "
				cQuery += " FROM "+RetSqlName("SA1")+" SA1 "
				cQuery += "WHERE "
				cQuery += "A1_FILIAL = '"+xFilial("SA1")+"' AND "
				cQuery += "A1_COD = '"+cCodCli+"' AND "
				cQuery += "SA1.D_E_L_E_T_ = ' ' "
				cQuery += "ORDER BY "+SqlOrder(SA1->(IndexKey()))

				cQuery := ChangeQuery(cQuery)

				dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasSA1,.T.,.T.)

				For nX := 1 To Len(aStruSA1)
					If aStruSA1[nX,1]$"A1_FILIAL,A1_COD,A1_MOEDALC,A1_LC,A1_LCFIN,A1_SALFIN,A1_SALDUP,A1_SALPEDL,A1_VENCLC"
						If aStruSA1[nX,2] <> "C" 
							TcSetField(cAliasSA1,aStruSA1[nX,1],aStruSA1[nX,2],aStruSA1[nX,3],aStruSA1[nX,4])
						EndIf
					EndIf
				Next nX

				If lIntTUR
					If G8T->(dbSeek(xFilial("G8T")+cComplTur+cSegTur))
						nMoedaAC := Posicione("G5T",1,xFilial("G5T") + G8T->G8T_MOEDA,"G5T_MOEDAF")//G8T->G8T_MOEDA
						cArqAC   := "G8T"
					Else
						nMoedaAC := (cAliasSA1)->A1_MOEDALC
					EndIf
				Else
					nMoedaAC := (cAliasSA1)->A1_MOEDALC				
				EndIf
				
				nMCusto	:= IIf( nMoedaAC > 0,nMoedaAC,Val(SuperGetMv("MV_MCUSTO")))
				nVlrCred := xMoeda(nVlrCred,nMoeda,1,dDataBase,2)
				nLimCred := 0
				While lRetorno .AND. (cAliasSA1)->(! Eof()) .And. xFilial("SA1") == (cAliasSA1)->A1_FILIAL .And. cCodCli == (cAliasSA1)->A1_COD
					If lIntTUR
						If G8T->(dbSeek(xFilial("G8T")+cComplTur+cSegTur))
							cRiscoAC := G8T->G8T_RISCO
							dVencAC  := G8T->G8T_VENCTO
							nLimiteAC:= G8T->G8T_LIMITE
							nMoedaAC := Posicione("G5T",1,xFilial("G5T") + G8T->G8T_MOEDA,"G5T_MOEDAF")//G8T->G8T_MOEDA
							cArqAC   := "G8T"
						Else
							cRiscoAC := (cAliasSA1)->A1_RISCO
							dVencAC  := (cAliasSA1)->A1_VENCLC
							nLimiteAC:= (cAliasSA1)->A1_LC
							nMoedaAC := (cAliasSA1)->A1_MOEDALC
						EndIf
					Else
						cRiscoAC := (cAliasSA1)->A1_RISCO
						dVencAC  := (cAliasSA1)->A1_VENCLC
						nLimiteAC:= (cAliasSA1)->A1_LC
						nMoedaAC := (cAliasSA1)->A1_MOEDALC
					EndIf

					If !cRiscoAC $ "E,Z"
						nLimCred += xMoeda(nLimiteAC,nMCusto,1,dDataBase,2)
					Else
						nLimCred := 0
					EndIf
					If (cAliasSA1)->A1_LCFIN >= 0
						nLimCredFin	+= xMoeda((cAliasSA1)->A1_LCFIN,nMCusto,1,dDataBase,MsDecimais(1))
						nVlrFin 	+= (cAliasSA1)->A1_SALFIN
					EndIf
					If ( lPedido )
						nVlrReal += (cAliasSA1)->A1_SALDUP + xMoeda((cAliasSA1)->A1_SALPEDL,nMCusto,1,dDatabase,2)
						If nVlrCred >= nVlrReal
							nLimCred += nVlrCred
						EndIf
						If ( aEmpenho <> Nil ) .And. ( !Empty(aEmpenho) )
							nRegEmp  := aScan(aEmpenho[1],{|x| x[1]==(cAliasSA1)->RECSA1 })
							If ( nRegEmp <> 0 )
								nVlrReal += xMoeda(aEmpenho[1][nRegEmp][2],nMCusto,1,dDatabase,2)
							EndIf
							If ( nRegEmp <> 0 )
								nVlrFin += aEmpenho[1][nRegEmp][3]
							EndIf
						EndIf
					EndIf
				   	If( lIntTUR )
						If nVlrCred < nVlrReal
							nVlrReal += (cAliasSA1)->A1_SALDUP
						EndIf
					EndIf
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³Aqui e avaliado o Vencimento do Limite de Credito do Cliente            ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If ( !Empty(dVencAC) .And. dVencAC < dDataBase ) .And. nVlrCred <= 0
						lRetorno := .F.
						cCodigo  := "04" // Vencimento do Limite de Credito
					EndIf
					dbSelectArea(cAliasSA1)
					dbSkip()
				EndDo
				If lQuery
					dbSelectArea(cAliasSA1)
					dbCloseArea()
					dbSelectArea("SA1")
				EndIf
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Adicional de Crédito quando utilizado o 9o Parâmetro							³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If nVlAdicCre > 0 .and. lIntGC // Modulo de Concessionárias
					nLimCred += nVlAdicCre
				EndIf
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Verifica se o Valor nao eh maior que o Limite de Credito                ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If ( lRetorno .And. nVlrReal > nLimCred .And. nVlrReal > 0)
					lRetorno := .F.
					cCodigo  := "01" // Limite de Credito
					lCredito := .T.
					cSeqTxtLog := "03"
				EndIf
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Controle de limite de credito secundario                                ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If lRetorno .And. nVlrFin > nLimCredFin .And. nLimCredFin > 0
					cCodigo 	:= "01" // Limite de Credito
					lRetorno := .F.
					lCredito := .T.
				EndIf
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Verifica as Classes de Cliente                                          ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If nVlrReal > 0
					dbSelectArea("SA1")
					dbSetOrder(1)
					MsSeek(xFilial("SA1")+cCodCli)
					
					If lIntTUR
						If G8T->(dbSeek(xFilial("G8T")+cComplTur+cSegTur))
							cRiscoAC := G8T->G8T_RISCO
							cArqAC   := "G8T"
						Else
							cRiscoAC := SA1->A1_RISCO
						EndIf
					Else
						cRiscoAC := SA1->A1_RISCO
					EndIf
					
					Do Case
						Case ( lRetorno .And. nVlrReal <= nLiMinCr )
							lRetorno := .T.
							cCodigo  := ""
						Case ( lRetorno .And. nVlrReal > ((nPerMax * nLimCred) / 100) )
							lRetorno := .F.
							cCodigo  := "01" // Limite de Credito.
							lCredito := .T.
							cSeqTxtLog := "05"
						Case ( lRetorno .And. SA1->A1_CLASSE == "A" .And. nVlrPed > nfaixaA .And. nFaixaA <> 0 )
							lRetorno := .F.
							cCodigo  := "01" // Limite de Credito
							lCredito := .T.
							cSeqTxtLog := "06"
						Case ( lRetorno .And. SA1->A1_CLASSE == "B" .And. nVlrPed > nfaixaB .And. nFaixaB <> 0 )
							lRetorno := .F.
							cCodigo  := "01" // Limite de Credito
							lCredito := .T.
							cSeqTxtLog := "07"
						Case ( lRetorno .And. SA1->A1_CLASSE == "C" .And. nVlrPed > nfaixaC .And. nFaixaC <> 0 )
							lRetorno := .F.
							cCodigo  := "01" // Limite de Credito
							lCredito := .T.
							cSeqTxtLog := "08"
					EndCase
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Aqui e avaliado o risco do Cliente - ( Matriz + Filiais )   ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If ( lRetorno .And. !Empty(cRiscoAC) .And. !cRiscoAC$"E,Z" )
			
						dbSelectArea("SE1")
						dbSetOrder(8)

						cAliasQry  := "QRYAVALCRD"
						lQuery     := .T.

						cQuery := "SELECT A1_FILIAL,A1_COD,A1_LOJA,A1_RISCO,E1_FILIAL,E1_CLIENTE,E1_LOJA,E1_TIPO,E1_VENCREA"
						cQuery += " FROM "+RetSqlName("SA1")+" SA1, "
						cQuery += RetSqlName("SE1")+" SE1 "
						cQuery += "WHERE "
						cQuery += "A1_FILIAL ='"+xFilial("SA1")+"' AND "
						cQuery += "A1_COD = '"+cCodCli+"' AND "
						cQuery += "SA1.D_E_L_E_T_ = ' ' AND "
						cQuery += "E1_FILIAL = '"+xFilial("SE1")+"' AND "
						cQuery += "E1_CLIENTE = A1_COD AND "
						cQuery += "E1_LOJA = A1_LOJA AND "
						cQuery += "E1_STATUS = 'A' AND "
						cQuery += "SE1.D_E_L_E_T_ = ' ' "
						cQuery += "ORDER BY "+SqlOrder(StrTran(SE1->(IndexKey()),"E1_LOJA+",""))

						cQuery := ChangeQuery(cQuery)

						dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasQry,.T.,.T.)

						TcSetField(cAliasQry,"E1_VENCREA","D",8,0)

						While (cAliasQry)->(!Eof()) .And. lRetorno
								
							If lIntTUR
								If G8T->(dbSeek(xFilial("G8T")+cComplTur+cSegTur))
									cRiscoAC := G8T->G8T_RISCO
									cArqAC   := "G8T"
								Else
									cRiscoAC := (cAliasQry)->A1_RISCO
								EndIf
							Else
								cRiscoAC := (cAliasQry)->A1_RISCO
							EndIf

							nNumDias	:= 0
							If !Empty(cRiscoAC)
								If	cRiscoAC <> "A"
									If lIntTUR
										nNumDias := SuperGetMv("MV_RISCO" + cRiscoAC + Iif(cSegTur=="1","C",Iif(cSegTur=="2","E","L")))
									Else
										nNumDias := SuperGetMv("MV_RISCO" + cRiscoAC)
									EndIf
								EndIf
							Else
								If (cAliasQry)->A1_LOJA <> "01"
									Aviso(STR0011,STR0012,{STR0013},2)//"Atenção"#"É necessario que o cliente e loja estejam com configurações de risco conforme outras lojas"
									lRetorno := .F.
									cCodigo  := "01" // Limite de Credito
									cSeqTxtLog := "10"
									Exit
								EndIf
							EndIf
							If cRiscoAC <> "A" .AND. ( !(cAliasQry)->E1_TIPO $ MVRECANT+"/"+MVPROVIS+"/"+MV_CRNEG .And. !(cAliasQry)->E1_TIPO $ MVABATIM )
								If ( ( dDataBase - (cAliasQry)->E1_VENCREA ) > nNumDias )
									lRetorno := .F.
									cCodigo  := "01" // Limite de Credito
									lTitVenc := .T.
									cSeqTxtLog := "09"
								EndIf
								Exit
							EndIf

							dbSelectArea(cAliasQry)
							dbSkip()
						EndDo
						If lQuery
							dbSelectArea(cAliasQry)
							dbCloseArea()
							dbSelectArea("SA1")
						EndIf
					EndIf
				EndIf
			EndIf
		EndIf
	EndCase

	If ( lMaAvCrPr )
		lRetorno := ExecBlock("MAAVCRPR",.F.,.F.,{cCodCli,cLoja,nValor,nMoeda,lPedido,cTipoLim,lRetorno,cCodigo,cComplTur,cSegTur})
		If !lRetorno .And. Empty(cCodigo)
			cCodigo := "01"
		EndIf
		If lRetorno .And. !Empty(cCodigo)
			cCodigo := ""
		EndIf
	Endif

Else
	If ( lMaAvCred )
		xRetorno := ExecBlock("MAAVCRED",.F.,.F.,{cCodCli,cLoja,nValor,nMoeda,lPedido,cComplTur,cSegTur})
		If ValType(xRetorno)=="C"
			lRetorno := Empty(xRetorno)
			cCodigo  := xRetorno
		Else
			If !xRetorno
				cCodigo := "01"
				lRetorno := .F.
			Else
				lRetorno := .T.
			EndIf
		Endif
	EndIf
EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Carrega o Array de detalhes da avaliação de credito                     ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If !Empty( cCodigo )
	Do Case
		Case cCodigo == "01"
			aAdd( aValDet, {cCodigo,{ lCredito, lTitVenc } } ) //Código do bloqueio [Bloqueio Credito][Bloqueio por título atrasado]
		Case cCodigo == "04"
			aAdd( aValDet, {cCodigo, {} } )
	EndCase
EndIf

If !lRetorno .And. lLogPedTxt
	cTxtLogC := LogPedTxt("C",cSeqTxtLog,dVencAC,nVlrReal,nLimCred,SA1->A1_SALFIN,nLimCredFin,nPerMax,nVlrPed,nfaixaA,nfaixaB,nfaixaC,nNumDias)
EndIf

If	lSaveArea
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Restaura a Entrada da Rotina                                            ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	RestArea(aAreaSA1)
	RestArea(aAreaSE1)
	RestArea(aArea)
EndIf
Return( lRetorno )

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³MaIniLiber³ Autor ³Eduardo Riera          ³ Data ³22.02.99  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Inicializa a Quantidade Liberada.                           ³±±
±±³          ³Esta funcao necessita do acols, aheader do SC6 e Enchoice   ³±±
±±³          ³do SC5 preenchidos.                                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Sempre .T.                                                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpN1: Numero do Pedido.                                    ³±±
±±³          ³ExpN2: Quantidade Vendida.                                  ³±±
±±³          ³ExpN3: Linha da GetDados.                                   ³±±
±±³          ³ExpL4: Codigo de Barras.                                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³   DATA   ³ Programador   ³Manutencao Efetuada                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³               ³                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function MaIniLiber(cPedido,nQtdaLib,nLinha,lCb)

Local aArea       := GetArea()
Local aAreaSC6    := SC6->(GetArea())
Local nCntFor     := 0
Local cItem       := ""
Local cProduto    := ""
Local cLocal      := ""
Local cNumLote    := ""
Local cLoteCtl    := ""
Local cLocaliz    := ""
Local cNumSer     := ""
Local cTes        := ""
Local cBlq        := ""
Local cBloquei    := ""
Local nQtdLib     := 0
Local nPQtdLib    := 0
Local cReserva    := ""
Local nColGr      := 0
Local nLinGr      := 0
Local cProdRef    := ""
Local nQtdLibGr   := 0
Local nQtdVen     := 0
Local nPosQtdVen  := 0
Local nPosQtdLib  := 0
Local nPosQtdEnt  := 0
Local lMata410 := AtIsRotina("MATA410")

DEFAULT lCb       := .F.

If ( lCB )
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Cria variaveis ja existentes na validacao do Produto na      ³
	//³ GetDados para compatibilizar as duas validacoes.             ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	nLinha := Len(aCols)
EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Caso o item do pedido tenha sido bloqueado pelo usuario      ³
//³ nao deve sugerir a quantidade liberada                       ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
For nCntFor := 1 To Len(aHeader)
	Do Case
	Case ( AllTrim(aHeader[nCntFor][2]) == "C6_ITEM" )
		cItem    := aCols[nLinha][nCntFor]
	Case ( AllTrim(aHeader[nCntFor][2]) == "C6_PRODUTO" )
		cProduto := aCols[nLinha][nCntFor]
	Case ( AllTrim(aHeader[nCntFor][2]) == "C6_LOCAL" )
		cLocal   := aCols[nLinha][nCntFor]
	Case ( AllTrim(aHeader[nCntFor][2]) == "C6_TES" )
		cTes     := aCols[nLinha][nCntFor]
	Case ( AllTrim(aHeader[nCntFor][2]) == "C6_QTDLIB" )
		nPQtdLib := nCntFor
	Case ( AllTrim(aHeader[nCntFor][2]) == "C6_BLQ" )
		cBlq     := AllTrim(aCols[nLinha][nCntFor])
	Case ( AllTrim(aHeader[nCntFor][2]) == "C6_BLOQUEI" )
		cBloquei := AllTrim(aCols[nLinha][nCntFor])
	Case ( AllTrim(aHeader[nCntFor][2]) == "C6_NUMLOTE" )
		cNumLote := aCols[nLinha][nCntFor]
	Case ( AllTrim(aHeader[nCntFor][2]) == "C6_LOTECTL")
		cLoteCtl := aCols[nLinha][nCntFor]
	Case ( AllTrim(aHeader[nCntFor][2]) == "C6_LOCALIZ" )
		cLocaliz := aCols[nLinha][nCntFor]
	Case ( AllTrim(aHeader[nCntFor][2]) == "C6_NUMSER")
		cNumSer  := aCols[nLinha][nCntFor]
	Case ( AllTrim(aHeader[nCntFor][2]) == "C6_RESERVA")
		cReserva := aCols[nLinha][nCntFor]
	Case ( AllTrim(aHeader[nCntFor][2]) == "C6_QTDVEN")
		nQtdVen  := aCols[nLinha][nCntFor]
		If ( M->(Type("C6_QTDVEN"))=="N" )
			nQtdVen := M->C6_QTDVEN
		EndIf
	EndCase
Next nCntFor

If !(xFilial("SC6") == SC6->C6_FILIAL .And. cPedido == SC6->C6_NUM .And. cItem == SC6->C6_ITEM)
	dbSelectArea("SC6")
	dbSetOrder(1)
	MsSeek(xFilial("SC6")+cPedido+cItem)
EndIf
If ( xFilial("SC6") == SC6->C6_FILIAL .And. cPedido == SC6->C6_NUM .And. cItem == SC6->C6_ITEM .And. !Empty(cReserva) )
	nQtdLib := Min(SC6->C6_QTDRESE,nQtdVen - If(ALTERA.And.lMata410,0,SC6->C6_QTDEMP) - SC6->C6_QTDENT)
Else
	If ( nQtdALib > ( nQtdVen - If(ALTERA.And.lMata410,0,SC6->C6_QTDEMP) - SC6->C6_QTDENT ) .And. xFilial("SC6") == SC6->C6_FILIAL .And. cPedido == SC6->C6_NUM .And. cItem == SC6->C6_ITEM )
		nQtdALib := nQtdVen - If(ALTERA.And.lMata410,0,SC6->C6_QTDEMP) - SC6->C6_QTDENT
	  	nQtdALib := Iif(nQtdALib<0.And.INCLUI.And.lMata410,nQtdVen,nQtdALib)
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Calcula o Saldo que pode ser liberado                                   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If ( !cBlq $ "SR" .And. (!(M->C5_TIPO$"CIP") .Or. ( cPaisLoc == "BRA" .And. AllTrim(M->C5_TIPO) == "C" .And. M->C5_TPCOMPL == "2" )) .And. Empty(cBloquei))
		cProdRef := cProduto
		If ( MatGrdPrrf(@cProdRef) )
			nPosQtdVen := &(MaReadGrd()):GetFieldGrdPos("C6_QTDVEN")
			nPosQtdLib := &(MaReadGrd()):GetFieldGrdPos("C6_QTDLIB")
			nPosQtdEnt := &(MaReadGrd()):GetFieldGrdPos("C6_QTDENT")
			For nLinGr := 1 To Len(&(MaReadGrd()):aColsGrade[nLinha])
				For nColGr := 2 To Len(&(MaReadGrd()):aHeadGrade[nLinha])
					nQtdALib  := &(MaReadGrd()):aColsGrade[nLinha][nLinGr][nColGr][nPosQtdVen]-&(MaReadGrd()):aColsGrade[nLinha][nLinGr][nColGr][nPosQtdEnt]
					nQtdLibGr := nQtdALib
					&(MaReadGrd()):aColsGrade[nLinha][nLinGr][nColGr][nPosQtdLib] := nQtdLibGr
					nQtdLib += nQtdLibGr
				Next nColGr
			Next nLinGr
		Else
			nQtdLib := nQtdALib
		EndIf
	EndIf
EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Atualiza o Acols                                                        ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
aCols[nLinha][nPQtdLib] := nQtdLib
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Retorna o Estado de Entrada da Rotina                                   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
RestArea(aAreaSC6)
RestArea(aArea)

Return( .T. )

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³MaLibDoFat³ Autor ³Eduardo Riera          ³ Data ³09.03.99  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Liberacao dos Itens de Pedido de Venda                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpN1: Quantidade Liberada                                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Transacao ³Nao possui controle de Transacao a rotina chamadora deve    ³±±
±±³          ³controlar a Transacao e os Locks                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpN1: Registro do SC6                                      ³±±
±±³          ³ExpN2: Quantidade a Liberar                                 ³±±
±±³          ³ExpL3: Bloqueio de Credito                                  ³±±
±±³          ³ExpL4: Bloqueio de Estoque                                  ³±±
±±³          ³ExpL5: Avaliacao de Credito                                 ³±±
±±³          ³ExpL6: Avaliacao de Estoque                                 ³±±
±±³          ³ExpL7: Permite Liberacao Parcial                            ³±±
±±³          ³ExpL8: Tranfere Locais automaticamente                      ³±±
±±³          ³ExpA9: Empenhos ( Caso seja informado nao efetua a gravacao ³±±
±±³          ³       apenas avalia ).                                     ³±±
±±³          ³ExpbA: CodBlock a ser avaliado na gravacao do SC9           ³±±
±±³          ³ExpAB: Array com Empenhos previamente escolhidos            ³±±
±±³          ³       (impede selecao dos empenhos pelas rotinas)          ³±±
±±³          ³ExpLC: Indica se apenas esta trocando lotes do SC9          ³±±
±±³          ³ExpND: Valor a ser adicionado ao limite de credito          ³±±
±±³          ³ExpNE: Quantidade a Liberar - segunda UM                    ³±±
±±³          ³ExpLF: Indica se a funcao deve armazenar as mensagens de    ³±±
±±³          ³       inconsistencias e alertas no processo de liberacao   ³±±
±±³          ³ExpLG: Indica se existe ordem de separacao em aberto para o ³±±
±±³          ³       item que estah sendo avaliado pela funcao            ³±±
±±³          ³ExpLH: Item de Divergência                                  ³±±
±±³          ³ExpLI: Ordem de separação                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Observacao³Deve estar numa transacao                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³   DATA   ³ Programador   ³Manutencao Efetuada                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³               ³                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/

Function MaLibDoFat( nRegSC6   , nQtdaLib  , lCredito  , lEstoque  , ;
					 lAvCred   , lAvEst    , lLibPar   , lTrfLocal , ;
					 aEmpenho  , bBlock    , aEmpPronto, lTrocaLot , ;
					 lGeraDCF  , nVlrCred  , nQtdalib2 , lLogMsg   , ;
					 lOrdSepLib, lItemDv   , cOrdSep)

Local aArea    	    := GetArea("SC6")
Local aAreaSA1 	    := SA1->(GetArea())
Local aAreaSF4 	    := SF4->(GetArea())
Local aAreaSC5 	    := {}
Local aAreaSC6 	    := {}
Local nQtdLib  	    := nQtdALib
Local nQtdLib2 	    := nQtdALib2
Local lContinua	    := .T.
Local lLibItPrev    := SuperGetMV( 'MV_FATLBPR', .F., .T. )	//Indica se permite a liberação de Itens previstos do Pedido de Venda
Local lBlqAlc		:= .F. //Indica se possui bloqueio de alçada

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Integracao SIGAFAT e SIGADPR                                 ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Local lIFatDpr	 := SuperGetMV("MV_IFATDPR",.F.,.F.)

nQtdLib := nQtdALib
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Seta os parametros defaults                                             ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
DEFAULT nQtdALib   := SC6->C6_QTDLIB
DEFAULT nQtdALib2  := SC6->C6_QTDLIB2
DEFAULT lCredito   := .T.
DEFAULT lEstoque   := .T.
DEFAULT lAvCred    := .T.
DEFAULT lAvEst     := .T.
DEFAULT lGeraDCF   := .T.
DEFAULT lLogMsg    := .F.
DEFAULT lOrdSepLib := .F.
DEFAULT lItemDv	   := .F.
DEFAULT cOrdsep    := ""

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Verifica se possui bloqueio de alçada                                   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If SC5->(ColumnPos("C5_CONAPRO")) > 0
	lBlqAlc := (SC5->C5_CONAPRO $ "B|R")
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Posiciona Pedido                                                        ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If !lBlqAlc .And. (Empty(SC6->C6_BLOQUEI) .And. !(lOrdSepLib))

	dbSelectArea("SC6")
	If nRegSC6<>0
		aAreaSC6 := GetArea()
		MsGoto(nRegSC6)
	Else
		aAreaSC6 := GetArea("SC6")
	EndIf

	If SB1->B1_FILIAL+SB1->B1_COD <> xFilial('SB1')+SC6->C6_PRODUTO
		SB1->(DbSetOrder(1))
		SB1->(MsSeek(xFilial('SB1')+SC6->C6_PRODUTO))
	Endif
	dbSelectArea("SC5")
	dbSetOrder(1)
	If ( xFilial("SC5")==SC5->C5_FILIAL .And. SC5->C5_NUM==SC6->C6_NUM )
		aAreaSC5 := GetArea("SC5")
	Else
		MsSeek(xFilial("SC5")+SC6->C6_NUM)
		aAreaSC5 := GetArea()
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Integracao com EEC													   ³
	//³Funcao: AvChkStDesp()												   ³
	//³Parametros: Nro do pedido de venda. 									   ³
	//³Retorno: True  - O pedido de venda podera ser liberado visto que as 	   ³
	//³					despesas ja foram integradas.						   ³
	//³         False - O pedido de venda não poderá ser liberado visto que    ³
	//³					existem pendencias para as despesas.				   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If !Empty(SC5->C5_PEDEXP)
		If FindFunction("AvChkStDesp")
			If !AvChkStDesp(SC5->C5_NUM)
				lContinua := .F.
			EndIf
		EndIf
	EndIf

	//------------------------------------------------------------------------------
	// Verifica o tipo de operação (C6_TPOP) antes de liberar. Itens previstos não
	// podem ser liberados a menos que o parâmetro MV_FATLBPR esteja como .T.
	// Alteração realizada para atender o requisito de Programação de Entrega.
	//------------------------------------------------------------------------------
	If ( SC6->C6_TPOP == "P" ) .And. ( !lLibItPrev )
		lContinua := .F.
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ M_SER004_CRM019_Integraçao_Faturamento_DPR                           ³
	//³ Se o item eh do tipo "Desenvolvimento" nao libera para faturamento   ³
	//³ Autor: Thiago Tavares													   ³
	//³ Data: 25/10/2013															   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lIFatDpr
		If SC6->C6_TPPROD == "2"
			lContinua := .F.
		EndIf
	EndIf

	If lContinua
		If nRegSC6 == 0 .Or. ( RecLock("SC5") .And. RecLock("SC6") )
			If Empty(SC5->C5_BLQ)
				If nQtdALib2 == 0 .And. SC6->C6_UNSVEN <> 0
					nQtdALib2 := SB1->(ConvUm(SC6->C6_PRODUTO,nQtdALib,Nil,2))
					If nQtdALib2 == 0
						If SC6->C6_QTDVEN-SC6->C6_QTDEMP-SC6->C6_QTDENT-nQtdALib==0
							nQtdALib2 := SC6->C6_UNSVEN-SC6->C6_QTDEMP2-SC6->C6_QTDENT2
						Else
							nQtdALib2 := nQtdALib*SC6->C6_UNSVEN/SC6->C6_QTDVEN
						EndIf
					EndIf
					SC6->C6_QTDLIB2:= nQtdALib2
					nQtdALib2 := SC6->C6_QTDLIB2
				EndIf
				SC6->C6_QTDLIB := nQtdALib
				SC6->C6_QTDLIB2:= nQtdALib2
				FatAtuEmpN("-")
				nQtdLib := a440GeraC9(@nQtdLib,@lCredito,@lEstoque,lAvCred,lAvEst,lLibPar,lTrfLocal,@aEmpenho,bBlock,aEmpPronto,lTrocaLot,lGeraDCF,@nVlrCred,@nQtdlib2,lItemDv,cOrdSep)
				FatAtuEmpN("+")
			EndIf
		EndIf
	Else
		nQtdLib := 0
	EndIf
	RestArea(aAreaSC5)
	RestArea(aAreaSC6)

Else
	nQtdLib := 0
Endif

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Restaura a Entrada                                                      ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
RestArea(aAreaSA1)
RestArea(aAreaSF4)
RestArea(aArea)
Return(nQtdLib)

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³MaLiberOk ³ Autor ³Eduardo Riera          ³ Data ³10.03.99  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Atualizacao do Campo C5_LiberOk                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nenhum                                                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpA1: Array com os Pedidos de Venda                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³   DATA   ³ Programador   ³Manutencao Efetuada                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ 07/05/99 ³ Aline C. Vale ³ Controle de Eliminacao de Residuos Mata500 ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function MaLiberOk(aPedidos,lResiduo)

Local aArea    := GetArea()
Local nCntFor  := 0
Local lLiberOk := .T.
Local lTotal   := .T.
Local cQuery   := ""
Local cQry     := ""
Local lIntegDef		:= ExistFunc("GETROTINTEG") .And. ExistFunc("FWHASEAI") .And. FWHasEAI("MATA410B",.T.,,.T.)//Integracao e rastreabilidade de pedidos ativa
Local cFilSD0  := xFilial("SD0") 

lResiduo    := If(ValType(lResiduo)=='U',.F.,lResiduo)

For nCntFor := 1 To Len(aPedidos)
	dbSelectArea("SC5")
	dbSetOrder(1)
	If MsSeek(xFilial("SC5")+aPedidos[nCntFor])

		SC6->(dbCommit())
		cQry   := "MALIBEROK1"

		cQuery := "SELECT COUNT(R_E_C_N_O_) QTDVEN FROM "+RetSqlName("SC6")  
		cQuery += " WHERE C6_FILIAL = '"+xFilial("SC6")+"' AND"
		cQuery += " C6_NUM = '"+aPedidos[nCntFor]+"' AND"
		cQuery += " C6_QTDVEN>(C6_QTDEMP+C6_QTDENT) AND"
		cQuery += " C6_BLQ <> 'R ' AND "
		cQuery += " D_E_L_E_T_ = ' ' "
		cQuery := ChangeQuery(cQuery)
		dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cQry,.T.,.T.)
		If ( QTDVEN > 0 )
			lLiberOk := .F.
		EndIf
		dbCloseArea()
		dbSelectArea("SC6")
		If ( lResiduo )
			SC6->(dbCommit())

			cQuery := "SELECT COUNT(R_E_C_N_O_) RESIDUO FROM "+RetSqlName("SC6") 
			cQuery += " WHERE C6_FILIAL = '"+xFilial("SC6")+"' AND"
			cQuery += " C6_NUM = '"+aPedidos[nCntFor]+"' AND"
			cQuery += " C6_QTDVEN>C6_QTDENT AND"
			cQuery += " C6_BLQ<>'R ' AND "
			cQuery += " D_E_L_E_T_ = ' ' "
			cQuery := ChangeQuery(cQuery)
			dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cQry,.T.,.T.)
			If ( RESIDUO > 0 )
				lTotal := .F.
			EndIf
			dbCloseArea()
		EndIf
		dbSelectArea("SC6")
		dbSetOrder(1)
		MsSeek(xFilial("SC6")+aPedidos[nCntFor])
		While ( !Eof() .And. xFilial("SC6")       == SC6->C6_FILIAL .And.;
				aPedidos[nCntFor] == SC6->C6_NUM )
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Verifica se Todos os Itens foram Liberados                              ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If ( Alltrim(SC6->C6_BLQ) <> "R" )
				If ( SC6->C6_QTDVEN > SC6->C6_QTDEMP + SC6->C6_QTDENT .And. lLiberOk )
					lLiberOk := .F.
				EndIf
				If ( lResiduo .And. SC6->C6_QTDVEN > SC6->C6_QTDENT )
					lTotal := .F.
				EndIf
				If !lLiberOk
					Exit
				EndIf
			EndIf
			dbSelectArea("SC6")
			dbSkip()
		EndDo

		dbSelectArea("SC5")
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Atualiza do C5_LIBEROK                                                  ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If lLiberOk
			RecLock("SC5")
			SC5->C5_LIBEROK := "S"
			If lResiduo .And. lTotal .And. Empty(SC5->C5_NOTA)
				SC5->C5_NOTA := Repl("X",Len(SC5->C5_NOTA))
				SC5->C5_BLQ  := Space(Len(SC5->C5_BLQ))
				SD0->(DbSetOrder(3))	//D0_FILIAL + D0_PEDIDO + D0_CLIENTE + D0_LOJA
				If ( SD0->(MsSeek(cFilSD0 + SC5->C5_NUM) ) )	
					RecLock( "SD0", .F. )
					SD0->D0_STATUS := "03" //Atualiza Status da Programação de entrega
					SD0->(MsUnlock())
				EndIf
			EndIf
			MsUnLock()

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Elimina o saldo do relacionamento de pedidos finalizados.³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If lResiduo                    .AND.;
			   lTotal                      .AND.;
			   A410UsaAdi(SC5->C5_CONDPAG)
				FPedAdtRsd("R", {SC5->C5_NUM})
			EndIf
						
			If lIntegDef                
				FwIntegDef("MATA410B")
			EndIf
			
		EndIf
	Endif
Next nCntFor
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Restaura o Area  de Entrada                                             ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
RestArea(aArea)
Return(.T.)

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³A440GeraC9³ Rev.  ³Eduardo Riera          ³ Data ³22.03.99  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Gravacao do item liberado do pedido de Venda                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ ExpN1: Quantidade realmente liberada                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpN1: Quantidade a Liberar                                ³±±
±±³          ³ ExpL2: Indica se o Credito foi Liberado                    ³±±
±±³          ³ ExpL3: Indica se o Estoque foi Liberado                    ³±±
±±³          ³ ExpL4: Avalia Credito                                      ³±±
±±³          ³ ExpL5: Avalia Estoque                                      ³±±
±±³          ³ ExpL6: Permite Liberacao Parcial                           ³±±
±±³          ³ ExpL7: Tranfere Locais automaticamente                     ³±±
±±³          ³ ExpA8: Empenhos ( Caso seja informado nao efetua a gravacao³±±
±±³          ³       apenas avalia ).                                     ³±±
±±³          ³ Expb9: CodBlock a ser avaliado na gravacao do SC9          ³±±
±±³          ³ ExpAB: Array com Empenhos previamente escolhidos           ³±±
±±³          ³       (impede selecao dos empenhos pelas rotinas)          ³±±
±±³          ³ExpL8: Indica se apenas esta trocando lotes do SC9          ³±±
±±³          ³ExpN9: Valor a ser adicionado ao limite de credito          ³±±
±±³          ³ExpNA: Quantidade a Liberar na segunda UM                   ³±±
±±³          ³ExpNB: Item de Divergência                                  ³±±
±±³          ³ExpNC: Ordem de separação                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Observacao³ O registro do SC5/SC6 deve estar posicionado               ³±±
±±³          ³ Deve estar numa transacao                                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³   DATA   ³ Programador   ³Manutencao Efetuada                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³               ³                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/

Static Function a440GeraC9(nQtdLib,lCredito,lEstoque,lAvCred,lAvEst,lLiber,lTransf,aEmpenho,;
							bBlock,aEmpPronto,lTrocaLot,lGeraDCF,nVlrCred,nQtdLib2,lItemDv,cOrdSep)

Local aArea     := GetArea(Alias())
Local aAreaSA1  := SA1->(GetArea())
Local aAreaSB2  := SB2->(GetArea())
Local aAreaSF4  := SF4->(GetArea())
Local aSaldos   := {}
Local aLocal    := {}

Local nSldSB6   := 0
Local cBlCred   := ""
Local cBlEst    := ""
Local cAliasSB6 := "SB6"
Local cAliasSF1 := "SF1"
Local lQuery    := .F.

Local cGeraBlq	     := SuperGetMv("MV_GERABLQ")
Local lGrvBlq2	     := SuperGetMv("MV_GRVBLQ2")

Local lBlqCrd        := GetMv("MV_BLQCRED")
Local lTravas        := .T.

Local nQtdJaLib      := 0
Local nQtdPoder3     := 0
Local nQtdNPT        := 0
Local nQtdNosso      := 0
Local nValAv	     := 0
Local aEmpBN	     := {}
Local nX             := 0
Local nMvTipCrd 	 := SuperGetMV("MV_TIPACRD", .F., 1)
Local cMvLibNodp	 := GetMv("MV_LIBNODP")
Local nVlrTitAbe	 := 0
Local nVlrTitAtr	 := 0
Local nSldProd		 := 0     //Variável para consulta do valor de Saldo do Produto para o Log do Pedido de Venda
Local cQuery         := ""
Local lUseOffBalance := .F.
Local lRiskCred		 := .F.
Local lRskTermB		 := .T.
Local lLibPed  		 := .F.
Local lTrvSA1        := .T.
Local lLibTRF		 := SuperGetMV("MV_LIBTRF", .F.,.F.)
Local lLogPedTxt	 := FindFunction("LogPedTxt") .And. SuperGetMV("MV_FTLOGPV",,.F.)
Local lRastro   	 := .F.
Local lLocaliza		 := .F.
Local lUseGRR		 := .F.
Local cInvGenerator  := '0'
Local lContCred		 := .T.

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Ajusta a Entrada da Rotina                                              ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
DEFAULT lAvCred    := .T.
DEFAULT lAvEst     := .T.
DEFAULT lLiber     := .F.
DEFAULT lTransf    := .F.
DEFAULT lGeraDCF   := .T.
DEFAULT lItemDv	   := .F.
DEFAULT cOrdsep    := ""

If lMTValAvC == Nil 
	lMTValAvC := ExistBlock("MTVALAVC")
EndIf

If lRskIsAct == Nil
	lRskIsAct := FindFunction( "RskIsActive" )
EndIf

lUseOffBalance := lRskIsAct .And. RskIsActive()

// ======================================================================
// Integração GRR - Gestão de Receita Recorrente 
// Avalia se a integração com o GRR está ativa
// ======================================================================
lUseGRR := FindFunction( "GRRIsActive" ) .And. GRRIsActive()

If ( At(SC5->C5_TIPO,"CIP") > 0 )
	lLiber := .F.
EndIf
dbSelectArea("SF4")
dbSetOrder(1)
MsSeek(xFilial("SF4")+SC6->C6_TES)

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Posiciona Registros                                                     ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If ( At(SC5->C5_TIPO,"DB") == 0 .And. (SF4->F4_DUPLIC=='S' .Or. cMvLibNodp == "S"))
	dbSelectArea("SA1")
	dbSetOrder(1)
	MsSeek(xFilial("SA1")+SC6->C6_CLI+SC6->C6_LOJA)
	lTrvSA1 := IIf(cPaisLoc == "BRA" .And. lFATTRVSA1, ExecBlock("FATTRVSA1", .F., .F., {xFilial("SA1"), SA1->A1_COD, SA1->A1_LOJA}), .T.)
	If lTrvSA1
		lTravas := RecLock("SA1")
	EndIf
EndIf

dbSelectArea("SB2")
dbSetOrder(1)
If ( MsSeek(xFilial("SB2")+SC6->C6_PRODUTO+SC6->C6_LOCAL) .And. lTravas .AND. SF4->F4_ESTOQUE = 'S')
	lTravas := RecLock("SB2")
EndIf

/* Integração RISK - TOTVS Mais Negócios
Avalia as condições do uso no TOTVS Mais Negócios */
lLibPed := IIf(lUseOffBalance, SuperGetMV("MV_RSKNTKT",,.F.), .F.)
If lUseOffBalance .and. lLibPed
	lRiskCred := RskEvlCredit( 2, SC5->C5_CONDPAG )
	lRskTermB := RskTermB(SA1->A1_COD+SA1->A1_LOJA,SC5->C5_CONDPAG)
EndIf

// ======================================================================
// Integração GRR - Gestão de Receita Recorrente 
// Avalia se está usando uma condição de pagamento do GRR e retorna o 
// tipo de fluxo definido para geração da NF.
// ======================================================================
If lUseGRR .And. FindFunction( "GRRInvGenerate" )
	cInvGenerator := GRRInvGenerate( SC5->C5_CONDPAG ) 
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Verifica se o SB2 e o SA1 estao Travados                                ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If ( lTravas )
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Complementos nao devem ter o Credito ou Estoque Avaliado.               ³
	//³Devolucao de Poder de Terceiro nao deve ter o Credito avaliado.         ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If ( (AT(SC5->C5_TIPO,"CIP") > 0 .AND. ( IIf(cPaisLoc == "BRA" , SC5->C5_TPCOMPL != "2" ,.T.))) .Or. ( SF4->F4_PODER3 == "D" .And. SF4->F4_ESTOQUE=="N") .Or. MaTesSel(SF4->F4_CODIGO) );
	.or. (lLibTRF .and.  IsInCallStack ('A310PROC'))
		lEstoque := .T.
		lCredito := .T.
	Else
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Avaliacao de Estoque                                                    ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If ( lAvEst )
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Somente avalia-se estoque quando ha movimentacao e nao ha reserva       ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If ( SF4->F4_ESTOQUE == "S" .And. (Empty(SC6->C6_RESERVA) .OR. (Iif(ExistFunc("LjxValEst"), LjxValEst(SC5->C5_ORCRES), .F. ) .AND. !AtIsRotina("MATA455"))))
				If SuperGetMV("MV_AVALEST")==3 .And. !AtIsRotina("MATA455")
					lRastro   := Rastro(SC6->C6_PRODUTO)
					lLocaliza := Localiza(SC6->C6_PRODUTO,.T.)
					If !((lRastro .Or. lLocaliza) .And. cGeraBlq =="N")
						lEstoque := .F.
						If lLogPedTxt
							If ((lRastro .Or. lLocaliza) .And. cGeraBlq =="S")
								cTxtLogE := LogPedTxt("E","02",,,,,,,,,,,)
							Else
								cTxtLogE := LogPedTxt("E","01",,,,,,,,,,,)
							EndIf
						EndIf
						aEmpBN	:= If(FindFunction("A410CarBen"),A410CarBen(SC6->C6_NUM,SC6->C6_ITEM),{})
						For nX := 1 To Len( aEmpBN )
							A410LibBen(1,aEmpBN[nX,1],aEmpBN[nX,2],SC6->C6_QTDVEN,SC6->C6_UNSVEN)
						Next
					Else
						lEstoque := A440VerSB2(@nQtdLib,lLiber,lTransf,@aLocal,@aEmpenho)
					EndIf
				Else
					lEstoque := A440VerSB2(@nQtdLib,lLiber,lTransf,@aLocal,@aEmpenho,,@nSldProd)
					If lLogPedTxt .And. !lEstoque
						cTxtLogE := LogPedTxt("E","03",,,,,,,,,,,,nSldProd)
					EndIf
					nSldProd := 0
				EndIf
			Else
				If ( !Empty(SC6->C6_RESERVA) )
					lEstoque := .T.

					If (cPaisLoc<>"BRA" .AND. SC6->C6_QTDRESE == 0) .Or. (cPaisLoc == "BRA" .And. !Rastro(SC6->C6_PRODUTO) .And. ;
						!Localiza(SC6->C6_PRODUTO,.T.) .And. !Empty(SC6->C6_NUMSERI) .And. cGeraBlq == "S" .And. !lGrvBlq2 .And. !lBlqCrd )
						nQtdLib := Min(SC6->C6_QTDVEN,nQtdLib)
					Else
						nQtdLib := Min(SC6->C6_QTDRESE,nQtdLib)
					EndIf
				Else
					lEstoque := .T.
				EndIf
			EndIf
		EndIf
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Avaliacao de Credito                                                    ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If ( lAvCred )
			If ( !SC5->C5_TIPO $ "DB" )
				If ( SF4->F4_DUPLIC == "S" .Or. cMvLibNodp == "S" )
					If ( lBlqCrd .And. !lEstoque )
						lCredito := .F.
						cBlCred  := "02"
						If lLogPedTxt
							cTxtLogC := LogPedTxt("C","11",,,,,,,,,,,)
						EndIf
					Else
						If lMTValAvC
							nValAv	:=	ExecBLock("MTValAvC",.F.,.F.,{'A440GERAC9',SC6->C6_PRCVEN*nQtdLib,Nil})
						Else
							nValAv	:=	SC6->C6_PRCVEN*nQtdLib
						Endif
						//A variavel nValItPed (Private) he criada nas funcoes:(A440Grava, A410Grava e a440Proces)
						If nMvTipCrd == 2 .AND. FindFunction("FatCredTools") .AND. Type("nValItPed") <> "U"

							If nValItPed == 0
								//Consulta os titulos em aberto
								nVlrTitAbe := SldCliente(SC9->C9_CLIENTE + SC9->C9_LOJA, Nil, Nil, .F.)
								//Consulta os titulos em atraso
								nVlrTitAtr := CrdXTitAtr(SC9->C9_CLIENTE + SC9->C9_LOJA, Nil, Nil, .F.)
							EndIf

							nValItPed += nValAv

							LJMsgRun(STR0010,,{|| lCredito := FatCredTools(SA1->A1_COD,SA1->A1_LOJA, nValItPed, nVlrTitAbe, nVlrTitAtr)})//"Aguarde... Efetuando Analise de Crédito."
							//lCredito := FatCredTools(SA1->A1_COD,SA1->A1_LOJA, nValItPed, nVlrTitAbe, nVlrTitAtr)
						Else
							/* Integração RISK - TOTVS Mais Negócios
							Se o tipo for full ou off-balance com condicao mais negocio ativada não avalia o crédito. */
							
							// ======================================================================
							// Integração GRR - Gestão de Receita Recorrente 
							// Nos registros do GRR do tipo B2C não há avaliação de crédito, pois 
							// este controle deve ser feito pela plataforma.
							// ======================================================================
							If ( !lRiskCred .and. lRskTermB ) .And. ( cInvGenerator != '1' ) 
								lCredito := MaAvalCred(SA1->A1_COD,SA1->A1_LOJA,nValAV,SC5->C5_MOEDA,.T.,@cBlCred,@aEmpenho,@nVlrCred)
								cBlCreAux := cBlCred
							EndIf
						EndIf
					EndIf
				Else
					lCredito := .T.
				EndIf
			Else
				lCredito := .T.
			EndIf
		EndIf
	EndIf
EndIf

/* Integração RISK - TOTVS Mais Negócios				
Se o tipo for full ou off-balance com condicao mais negocio 
ativada gera ticket.*/
If lUseOffBalance .And. aEmpenho == Nil .And. !FwIsInCallStack( "RskUpdLibPed" ) .And. !FwIsInCallStack( "MaDelNfs" ) .and. !lCredito
	If lRiskCred
		cBlCred		:= "80"
		lCredito 	:= .F.
	elseif !lRskTermB
		cBlCred		:= "91"  
		lCredito 	:= .F.
	EndIf 
EndIf 

// ======================================================================
// Integração GRR - Gestão de Receita Recorrente 
// Altera o código de bloqueio para um código específico do GRR
// ======================================================================
If lUseGRR .And. aEmpenho == Nil .And. !lCredito
	If cInvGenerator == '1'
		cBlCred		:= "70"	
		lCredito 	:= .F.
	EndIf 
EndIf 

//Para Orcamento com origem do SigaLoja verifica regra de bloqueio de crédito especifica
If (! Empty(SC5->C5_ORCRES) .Or. ! Empty(SC5->C5_PEDECOM)) 
	If ExistFunc("LjxjPedBlq")
		LjxjPedBlq( SC5->C5_ORCRES , @cBlCred , @lCredito)
	ElseIf SuperGetMV("MV_LJECOMM",,.F.) .And. SuperGetMV("MV_LJECOMO",,.F.) .And. Val(SC5->C5_PEDECOM) > 0
		cBlCred  := "02"
		lCredito := .F.
	EndIf	
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Neste momento eh gerado os empenhos e o SC9 dependendo do caso          ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If ( lTravas .And. (SC5->C5_TIPO$"CIP" .Or. nQtdLib > 0 .Or. MaTesSel(SF4->F4_CODIGO)) )
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Busca dados ref. ao Beneficiamento no SB6 para gerar Registros no SC9 ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If ( SF4->F4_PODER3=='D' .And. !(SC5->C5_TIPO$"CIP") )
		nQtdPoder3 := nQtdLib
	Else
		If lCredito .And. lEstoque
			aSaldos := MaNeedP3(nQtdLib)
			nQtdNosso := aSaldos[1]
			nQtdPoder3:= aSaldos[2]
			nQtdNPT   := aSaldos[3]
		Else
			nQtdNosso := nQtdLib
		EndIf
	EndIf
	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Validação PE MaAvCred e C5_TIPLIB == '2'                                ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If ValType(lMaAvCred) <> "U" .And. lMaAvCred .And. SC5->C5_TIPLIB == '2' .And. Empty(cBlCred) .And. !Empty(cBlCreAux) 
		cBlCred := cBlCreAux
		lContCred := .F.
	EndIf
	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Verifica os codigos de bloqueio                                         ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If ( Empty(cBlCred) ) .And. lContCred
		If ( !lCredito )
			If At(SC5->C5_TIPO,"DB") == 0 .And. SF4->F4_DUPLIC == 'S' .And. SC5->C5_TIPLIB == "2" .And.;
				( !Empty(SA1->A1_VENCLC) .And. SA1->A1_VENCLC < dDataBase ) .And. nVlrCred <= 0
				cBlCred := "04"		//Vencimento do Limite de Credito
				If lLogPedTxt
					cTxtLogC := LogPedTxt("C","02",SA1->A1_VENCLC,,,,,,,,,,)
				EndIf
			Else
				cBlCred := "01"
				If lLogPedTxt
					cTxtLogC := LogPedTxt("C","04",,,,,,,,,,,)
				EndIf
			EndIf
		EndIf
	EndIf
	If ( Empty(cBlEst) )
		If ( !lEstoque )
			cBlEst := "02"
		EndIf
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Tratamento da quantidade a ser liberada do poder de terceiros           ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If nQtdPoder3 > 0
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Posiciona Registros                                              ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		dbSelectArea("SB6")
		If Empty(SC6->C6_IDENTB6)
			dbSetOrder(1)
		Else
			dbSetOrder(3)
		EndIf
		cAliasSB6 := "A440GERAC9"
		cAliasSF1 := "A440GERAC9"
		lQuery    := .T.
		aStruSB6  := SB6->(dbStruct())
		SB6->(dbCommit())

		cQuery := "SELECT B6_FILIAL,B6_CLIFOR,B6_LOJA,B6_IDENT,B6_PRODUTO,"
		cQuery += "B6_QULIB,B6_SALDO,F1_TPCOMPL "
		cQuery += "FROM "+RetSqlName("SB6")+" SB6 "
		cQuery += "INNER JOIN " + RetSqlName("SF1")+" SF1 ON SF1.F1_FILIAL = '"+FwxFilial("SF1")+"' "
		cQuery += " AND SF1.F1_DOC = SB6.B6_DOC "
		cQuery += " AND SF1.F1_SERIE = SB6.B6_SERIE "
		cQuery += " AND SF1.F1_LOJA = SB6.B6_LOJA "
		cQuery += " AND SF1.F1_FORNECE = SB6.B6_CLIFOR "
		cQuery += " AND SF1.D_E_L_E_T_= ' ' "
		cQuery += "WHERE SB6.B6_FILIAL='"+xFilial("SB6")+"' "
		cQuery += "AND SB6.B6_PRODUTO='"+SC6->C6_PRODUTO+"' "
		If !Empty(SC6->C6_IDENTB6) 
			cQuery += "AND SB6.B6_IDENT='"+SC6->C6_IDENTB6+"' "
			cQuery += "OR SB6.B6_IDENTB6 ='"+SC6->C6_IDENTB6+" '
		EndIf
		cQuery += "AND (SB6.B6_SALDO-SB6.B6_QULIB)>0 "
		cQuery += "AND SB6.D_E_L_E_T_=' ' "
		cQuery += "ORDER BY "+SqlOrder(SB6->(IndexKey()))

		cQuery := ChangeQuery(cQuery)

		dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasSB6,.T.,.T.)
		For nX := 1 To Len(aStruSB6)
			If aStruSB6[nX][2] <> "C" 
				TcSetField(cAliasSB6,aStruSB6[nX][1],aStruSB6[nX][2],aStruSB6[nX][3],aStruSB6[nX][4])
			EndIf
		Next nX
		
		While (!Eof() .And.  (xFilial("SB6") == (cAliasSB6)->B6_FILIAL .And.;
				IIf(Empty(SC6->C6_IDENTB6),.T.,;
				SC6->C6_IDENTB6==(cAliasSB6)->B6_IDENT) .And.;
				SC6->C6_PRODUTO==(cAliasSB6)->B6_PRODUTO .OR. (cAliasSF1)->F1_TPCOMPL == "2") .And.;
				nQtdPoder3 > 0 )
			nSldSB6 := ( (cAliasSB6)->B6_SALDO - (cAliasSB6)->B6_QULIB )
			If ( nSldSB6 > 0 )
				nSldSb6 := Min(nSldSB6,nQtdPoder3)
				If !( ( Rastro(SC6->C6_PRODUTO).Or.Localiza(SC6->C6_PRODUTO,.T.) ) .And.;
						cGeraBlq =="N" .And. !lEstoque )
					MaGravaSc9(nSldSb6,cBlCred,cBlEst,@aLocal,@aEmpenho,(cAliasSB6)->B6_IDENT,bBlock,aEmpPronto,nQtdLib2,@nVlrCred,,,lItemDv,cOrdSep)
					nQtdJaLib += nSldSb6
				EndIf
				nQtdPoder3 -= nSldSB6
			EndIf
			dbSelectArea(cAliasSB6)
			dbSkip()
		EndDo
		If lQuery
			dbSelectArea(cAliasSB6)
			dbCloseArea()
			dbSelectArea("SB6")
		EndIf
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Tratamento da quantidade a ser liberada - Nossa em Terceiros            ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If nQtdNPT > 0
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Verificacao do Parametro MV_GERABLQ                                     ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If !( (Rastro(SC6->C6_PRODUTO) .Or. Localiza(SC6->C6_PRODUTO,.T.)) .And.;
				cGeraBlq =="N" .And. !lEstoque )
			MaGravaSc9(nQtdNPT,cBlCred,cBlEst,@aLocal,@aEmpenho,,bBlock,aEmpPronto,,@nVlrCred,,,lItemDv,cOrdSep)
			nQtdJaLib += nQtdNPT
		EndIf
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Tratamento da quantidade a ser liberada - Nosso Poder                   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

	If nQtdNosso > 0 .Or. MaTesSel(SF4->F4_CODIGO)	.Or. Ma440Compl()
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Verificacao do Parametro MV_GERABLQ                                     ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If !( (Rastro(SC6->C6_PRODUTO) .Or. Localiza(SC6->C6_PRODUTO,.T.)) .And.;
				cGeraBlq =="N" .And. !lEstoque )
			MaGravaSc9(nQtdNosso,cBlCred,cBlEst,@aLocal,@aEmpenho,,bBlock,aEmpPronto,nQtdLib2,@nVlrCred,,lGeraDCF,lItemDv,cOrdSep)
			nQtdJaLib += nQtdNosso
		EndIf
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Verificacao do Parametro MV_GRVBLQ2                                     ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If ( lGrvBlq2 .And. aEmpenho == Nil ) .And. cGeraBlq =="S"
			If ( nQtdLib <> SC6->C6_QTDLIB ) .Or. ( SC6->C6_QTDLIB <> 0 )
				nQtdLib := SC6->C6_QTDLIB
				If ( nQtdLib <> 0 )
					If !lCredito
						lAvEst := .F.
						lEstoque := .F.
					Else
						lAvEst := .T.
					EndIf
					nQtdJaLib += a440GeraC9(nQtdLib,lCredito,lEstoque,lAvCred,lAvEst,lLiber,lTransf,@aEmpenho,bBlock,aEmpPronto,lTrocaLot,lGeraDCF,@nVlrCred,,lItemDv,cOrdSep)
				EndIf
			EndIf
		EndIf
	EndIf
EndIf
If ( lTravas )
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Atualiza a quantidade liberada para zero                                ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If ( aEmpenho == Nil )
		SC6->C6_QTDLIB  := 0
		SC6->C6_QTDLIB2 := 0
	EndIf
EndIf
If ( !lTravas )
	lCredito := .F.
	lEstoque := .F.
	nQtdLib  := 0
EndIf
RestArea(aAreaSA1)
RestArea(aAreaSB2)
RestArea(aAreaSF4)
RestArea(aArea)
Return(nQtdJaLib)

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³MaGravaSC9³ Autor ³Eduardo Riera          ³ Data ³19.03.99  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Gravacao da Liberacao do pedido de Venda                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nenhum                                                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpN1: Quantidade a Ser Liberada                            ³±±
±±³          ³ExpC2: Codigo do Bloqueio de Credito                        ³±±
±±³          ³       "01" - Bloqueio de Credito por valor                 ³±±
±±³          ³       "04" - Bloqueio por Vencimento do Limite de Credito  ³±±
±±³          ³ExpC3: Codigo do Bloqueio de Estoque                        ³±±
±±³          ³       "02" - Bloqueio de Estoque                           ³±±
±±³          ³ExpA4: Array com os locais a serem transferidos             ³±±
±±³          ³ExpA5: Empenhos ( Caso seja informado nao efetua a gravacao ³±±
±±³          ³       apenas avalia ).                                     ³±±
±±³          ³ExpC6: Identificador do SB6                                 ³±±
±±³          ³Expb7: CodBlock a ser avaliado na gravacao do SC9           ³±±
±±³          ³ExpA8: Array com Empenhos previamente escolhidos            ³±±
±±³          ³       (impede selecao dos empenhos pelas rotinas)          ³±±
±±³          ³ExpN9: Quantidade a ser liberada na segunda UM              ³±±
±±³          ³ExpNA: Valor a ser adicionado ao limite de credito          ³±±
±±³          ³ExpCB: Codigo de bloqueio do WMS                            ³±±
±±³          ³           01 - Bloqueio de Enderecamento do WMS/Somente SB2³±±
±±³          ³           02 - Bloqueio de Enderecamento do WMS            ³±±
±±³          ³           03 - Bloqueio de WMS - Externo                   ³±±
±±³          ³ExpCC: Item de Divergência                                  ³±±
±±³          ³ExpCD: ordem de separação                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Observacao³1) Esta funcao deve gerar os empenhos de Lote e Localizacao ³±±
±±³          ³2) Quando ha Reserva no SC6 os empenhos ja foram efetuados  ³±±
±±³          ³   mas devem ser trocados.                                  ³±±
±±³          ³3) deve estar numa transacao                                ³±±
±±³          ³4) SC5/SC6 devem estar posicionados e travados              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³   DATA   ³ Programador   ³Manutencao Efetuada                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³16/05/2007³Norbert Waage  ³Bops 125161 - Atualizacao do status do orca-³±±
±±³          ³               ³mento no Televendas (SIGATMK) apos liberacao³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function MaGravaSC9(nQtdLib,cBlqCred,cBlqEst,aLocal,aEmpenho,cIdentB6,bBlock,aEmpPronto,nQtdLib2,nVlrCred,cBlqWMS,lGeraDCF,lItemDv,cOrdSep)

Static lMA440GrLt
Static cTiposLC

Local aArea    	     := GetArea(Alias())
Local aAreaSA1 	     := SA1->(GetArea())
Local aAreaSB2 	     := SB2->(GetArea())
Local aAreaSF4 	     := SF4->(GetArea())
Local aAreaSB1 	     := SB1->(GetArea())
Local aAuxiliar      := {}
Local aLocaliz       := {}
Local aSaldos        := {}
Local nX             := 0
Local nY             := 0
Local nAuxiliar      := 0
Local nQtdRese       := 0
Local nMCusto        := 0
Local nSaveSX8       := GetSX8Len()
Local nRegEmp        := 0
Local cQuery         := ""
Local cNameQry       := ""
Local cSeqSC9        := "00"
Local cReserva       := ""
Local lAtualiza      := If(aEmpenho==Nil,.T.,.F.)
Local lEstoque       := .F.
Local lCredito       := .F.
Local lHasWMS        := IntWms(SC6->C6_PRODUTO) .And. !Empty(SC6->C6_SERVIC) //-- Soh considera o uso do WMS se houver Servico Preenchido para o Item do SC6
Local lUsaVenc       := .F.
Local lReserva       := .F.
Local lEmpenha       := .F.
Local lContercOk     := .F.
Local lInfLote       := .F.
Local lResEst        := SuperGetMv("MV_RESEST")
Local lIntACD	     := SuperGetMV("MV_INTACD",.F.,"0") == "1"
Local lACDSer        := SuperGetMV("MV_SUBNSER",.F.,'1') $ '2|3'
Local dValidLote     := Ctod( "" )
Local cLoteCtl 		 := ""
Local cNumlote 		 := ""
Local nRecSC9        := 0
Local aInsert 	     := {}
Local nLen 		     := 0 
Local nPosPrepared   := 0 
Local cMD5 		     := "" 
Local lVerLib		 := FatxVerLib()
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Tratamento para e-Commerce      ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Local lECommerce     := SuperGetMV("MV_LJECOMM",,.F.)
Local lRetWmsPE      := lHasWMS
Local lWmsNew        := SuperGetMV("MV_WMSNEW",.F.,.F.)
Local lDclNew		 := SuperGetMv("MV_DCLNEW",.F.,.F.)	
Local cSeq           := ""
Local lUseOffBalance := .F.
Local lLibPed  		 := .F.
Local lNSer0End      := .F.
Local lTrvSA1        := .T.
Local lHabGrvLog 	 := SuperGetMV("MV_FTLOGPV",,.F.) .And. FindFunction('FATA410') .And. AliasInDic("AQ1") //Habilita a gravação do log de liberação de Pedidos de Venda
Local aLogLibPV		 := {}
Local lAutoMt521	 := IIF(lHabGrvLog, IsBlind() .And. FunName() == "MATA521A", .F.)

   //Este ponto de entrada é utilizado pelo Nestlé para simular uma integração com o WMS
   //Deve obrigatoriamente ficar neste ponto antes do DEAFAULT para forçar um bloqueio de WMS no pedido
   If ExistBlock("MA440WMS")
      lRetWmsPE := ExecBlock("MA440WMS",.F.,.F.,{lHasWMS})
      lHasWMS   := Iif(ValType(lRetWmsPE)=="L",lRetWmsPE,lHasWMS)
	  cBlqWms   := Iif(lHasWMS,"01","") 
   EndIf

DEFAULT cBlqWms    := Iif(lHasWMS,Iif(IsInCallStack("MaDelNFS"),"05","01"),"")
DEFAULT cIdentB6   := ""
DEFAULT lMA440GrLt := ExistBlock("MA440GRLT")
DEFAULT aEmpPronto := {}
DEFAULT cTiposLC   := GetSESTipos({ || ES_SALDUP == "2"},"1")
DEFAULT lGeraDCF   := .T.
DEFAULT lItemDv	   := .F.
DEFAULT cOrdsep    := ""

If lRskIsAct == Nil
	lRskIsAct := FindFunction( "RskIsActive" )
EndIf

If lDclNew .And. Findfunction("DCLMSGINT") 
	DCLMSGINT()
EndIF

lUseOffBalance := lRskIsAct .And. RskIsActive()

If cPaisLoc == "PAR" .And. SC5->C5_TIPLIB=="2" .And. ValType(aEmpenho) == "A" .And. Len(aEmpenho[1]) == 0
	lAtualiza := .T.
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Configura a reserva de estoque quando for e-Commerce                   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If  lECommerce .AND. !( Empty(SC5->C5_ORCRES) ) .AND. (Posicione("SL1",1,xFilial("SL1")+SC5->C5_ORCRES,"L1_ECFLAG")=="1")
	lResEst := .T.
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Baixa as qtdes transferidas para o local do pedido  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If ( lAtualiza )
	For nX :=1 To Len(aLocal)
		MaTrfLocal(SC6->C6_PRODUTO,aLocal[nX][1],SC6->C6_LOCAL,aLocal[nX][2],SC6->C6_NUM,.F.,@cSeq)
	Next nX
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Posiciona Registros                                                     ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
dbSelectArea("SF4")
dbSetOrder(1)
MsSeek(xFilial("SF4")+SC6->C6_TES)
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Verifica a Sequencia de Liberacao do SC9                                ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

SC9->(dbCommit())
cNameQry := "MAGRAVASC9"

cQuery := "SELECT MAX(C9_SEQUEN) SEQUEN "

Aadd(aInsert, RetSqlName("SC9"))
cQuery +=   "FROM ? SC9 "

Aadd(aInsert, xFilial("SC9"))
cQuery +=   "WHERE C9_FILIAL= ? AND "

Aadd(aInsert, SC6->C6_NUM)
cQuery +=         "C9_PEDIDO= ? AND "

Aadd(aInsert, SC6->C6_ITEM)
cQuery +=         "C9_ITEM= ? AND "

cQuery +=         "SC9.D_E_L_E_T_ = ' '"

nLen := Len(aInsert)
cMD5 := MD5(cQuery) 
If (nPosPrepared := Ascan(__aPrepared,{|x| x[2] == cMD5})) == 0 
	cQuery := ChangeQuery(cQuery)
	Aadd(__aPrepared,{IIf(lVerLib,FwExecStatement():New(cQuery),FWPreparedStatement():New(cQuery)),cMD5})
	nPosPrepared := Len(__aPrepared)
Endif 

__aPrepared[nPosPrepared][1]:SetUnsafe(1,aInsert[1])

For nX := 2 to nLen
	__aPrepared[nPosPrepared][1]:SetString(nX,aInsert[nX])
Next 

If lVerLib
	cNameQry := __aPrepared[nPosPrepared][1]:OpenAlias(cNameQry)
	If !Empty((cNameQry)->SEQUEN)
		cSeqSC9 := AllTrim((cNameQry)->SEQUEN)
	EndIf
Else
	cQuery := __aPrepared[nPosPrepared][1]:getFixQuery()
	dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cNameQry,.T.,.T.)
	If !Empty(SEQUEN)
		cSeqSC9 := AllTrim(SEQUEN)
	EndIF
	
EndIf

aInsert := aSize(aInsert,0)

If Select(cNameQry) > 0
	(cNameQry)->(dbCloseArea())
EndIf

dbSelectArea("SC9")

cSeqSC9 := Soma1(cSeqSC9, Len(SC9->C9_SEQUEN), .T.)

// Tratamento referente ao controle de armazem de terceiros para gravar o lote informado no pedido mesmo com TES que nao atualiza estoque
If FindFunction("EstArmTerc")
	lContercOk := EstArmTerc()	// Verifica se o controle de armazem de terceiros esta habilitado
	If lContercOk .And. SF4->F4_ESTOQUE == "N" .And. SF4->F4_CONTERC == "1"
		lInfLote := .T.
	EndIf
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Inicializa as variaveis                                                 ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
nQtdLib2  := If(nQtdLib2==Nil,SB1->(ConvUm(SC6->C6_PRODUTO,nQtdLib,0,2)),nQtdLib2)
If nQtdLib2 == 0 .And. SC6->C6_UNSVEN <> 0
	If Empty( SC6->C6_QTDVEN-SC6->C6_QTDEMP-SC6->C6_QTDENT-nQtdLib )
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Se baixou toda a quantidade na primeira UM, baixa totalmente a segunda UM ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		nQtdLib2 := SC6->C6_UNSVEN-SC6->C6_QTDEMP2-SC6->C6_QTDENT2
	Else
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Se nao, baixa proporcionamenre a quantidade baixada na primeira UM     ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		nQtdLib2 := nQtdLib*SC6->C6_UNSVEN/SC6->C6_QTDVEN
	EndIf
	SC6->C6_QTDLIB2:= nQtdLib2
	nQtdLib2 := SC6->C6_QTDLIB2
EndIf
lReserva  := !Empty(SC6->C6_RESERVA)
lEstoque  := Empty(AllTrim(cBlqEst))
lCredito  := Empty(AllTrim(cBlqCred))

If ( (SF4->F4_ESTOQUE=="S" .Or. lInfLote) .And. nQtdLib > 0 .And. lEstoque .And. (lCredito .Or. lResEst) .And. lAtualiza)
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Verifica os novos lotes.                                                ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If !Rastro(SC6->C6_PRODUTO) .And. !Localiza(SC6->C6_PRODUTO,.T.)
		If Len(aEmpPronto) > 0
			aSaldos := ACLONE(aEmpPronto)
			lEmpenha := .T.
		Else
			aSaldos := {{ "","","","",nQtdLib,nQtdLib2,Ctod(""),"","","",SC6->C6_LOCAL,0}}
		EndIf
		aLocaliz := { aSaldos }
	Else
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Ponto de Entrada p/ movimentar estoque antes da selecao Lote X Localiz.³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If lMA440GrLt
			ExecBlock("MA440GRLT",.F.,.F.,{SC6->C6_PRODUTO,SC6->C6_LOCAL,nQtdLib,SC6->C6_LOTECTL,SC6->C6_NUMLOTE,SC6->C6_LOCALIZ,SC6->C6_NUMSERI})
		EndIf
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Verifica se devem ser escolhidos Lotes/Sub-Lotes/Localizacao ou nao    ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If Len(aEmpPronto) > 0
			aSaldos := ACLONE(aEmpPronto)
			lEmpenha := .T.
		Else
			lUsaVenc:= If(!Empty(SC6->C6_LOTECTL+SC6->C6_NUMLOTE),.T.,(SuperGetMv('MV_LOTVENC')=='S'))
			If ( !lHasWMS .Or. !Empty(SC6->C6_LOCALIZ+SC6->C6_NUMSERI) ) .And.;
				(!lReserva .Or. (lReserva .And. Rastro(SC6->C6_PRODUTO) .And.;
				(xFilial("SC0")+SC6->C6_RESERVA+SC6->C6_PRODUTO+SC6->C6_LOCAL==SC0->C0_FILIAL+SC0->C0_NUM+SC0->C0_PRODUTO+SC0->C0_LOCAL) .And.;
				Empty(SC0->C0_LOTECTL+SC0->C0_NUMLOTE))) .And.;
				!((IsInCallStack('MATA521A') .Or. lWmsNew) .And. IntWms(SC6->C6_PRODUTO)) 
				If lIntACD .And. lACDSer .And. IsInCallStack("MaDelNFS")
					aSaldos:= ACDCB9Ser(SC6->C6_PRODUTO,SC6->C6_LOCAL,nQtdLib,nQtdLib2,SC6->C6_LOTECTL,SC6->C6_NUMLOTE,SC6->C6_LOCALIZ,SC6->C6_NUMSERI,lUsaVenc,dDataBase,SC9->C9_ORDSEP,SC9->C9_PEDIDO)
				Else
					aSaldos := SldPorLote(SC6->C6_PRODUTO,SC6->C6_LOCAL,nQtdLib,nQtdLib2,SC6->C6_LOTECTL,SC6->C6_NUMLOTE,SC6->C6_LOCALIZ,SC6->C6_NUMSERI,NIL,NIL,NIL,lUsaVenc,nil,nil,dDataBase)
				EndIf
				lEmpenha := .T.
			Else
				SC0->( dbSetOrder(1) )
				If !Empty(SC6->C6_RESERVA) .And.;
					(xFilial("SC0")+SC6->C6_RESERVA+SC6->C6_PRODUTO+SC6->C6_LOCAL==SC0->C0_FILIAL+SC0->C0_NUM+SC0->C0_PRODUTO+SC0->C0_LOCAL .Or. ;
					SC0->( dbSeek( xFilial("SC0")+SC6->C6_RESERVA+SC6->C6_PRODUTO+SC6->C6_LOCAL ) ) )

					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Pesquisa a data de validade dos lotes                                  ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If Rastro(SC6->C6_PRODUTO,"L")
						SB8->( dbSetOrder( 3 ) )
						SB8->( MsSeek( xFilial( "SB8" ) + SC0->C0_PRODUTO + SC0->C0_LOCAL + SC0->C0_LOTECTL ) )
						dValidLote := SB8->B8_DTVALID
					ElseIf Rastro(SC6->C6_PRODUTO,"S")
						SB8->( dbSetOrder( 3 ) )
						SB8->( MsSeek( xFilial( "SB8" ) + SC0->C0_PRODUTO + SC0->C0_LOCAL + SC0->C0_LOTECTL + SC0->C0_NUMLOTE ) )
						dValidLote := SB8->B8_DTVALID
					Else
						dValidLote := Ctod( "" )
					EndIf

					aSaldos := {{ SC0->C0_LOTECTL,SC0->C0_NUMLOTE,SC0->C0_LOCALIZ,SC0->C0_NUMSERI,nQtdLib,nQtdLib2,dValidLote,"","","",SC0->C0_LOCAL,0}}
				Else
					If lHasWMS .And. !lReserva
						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³ Pesquisa a data de validade dos lotes                                  ³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						If Rastro(SC6->C6_PRODUTO,"L")
							SB8->( dbSetOrder( 3 ) )
							If SB8->( MsSeek( xFilial( "SB8" ) + SC6->C6_PRODUTO + SC6->C6_LOCAL + SC6->C6_LOTECTL + SC6->C6_NUMLOTE ))
								cLoteCtl 	:= SC6->C6_LOTECTL
								cNumlote 	:= SC6->C6_NUMLOTE
								dValidLote 	:= SB8->B8_DTVALID
							EndIf
						ElseIf Rastro(SC6->C6_PRODUTO,"S")
							SB8->( dbSetOrder( 3 ) )
							If SB8->( MsSeek( xFilial( "SB8" ) + SC6->C6_PRODUTO + SC6->C6_LOCAL + SC6->C6_LOTECTL + SC6->C6_NUMLOTE ))
								cLoteCtl 	:= SC6->C6_LOTECTL
								cNumlote 	:= SC6->C6_NUMLOTE
								dValidLote 	:= SB8->B8_DTVALID
							EndIf
						Else
							dValidLote 	:= Ctod( "" )
						EndIf
					Else
				
						cLoteCtl 	:= SC6->C6_LOTECTL
						cNumlote 	:= SC6->C6_NUMLOTE
						dValidLote 	:= Ctod( "" )

						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³ Pesquisa a data de validade dos lotes                                  ³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						If Rastro(SC6->C6_PRODUTO)
							SB8->( dbSetOrder( 3 ) )//B8_FILIAL, B8_PRODUTO, B8_LOCAL, B8_LOTECTL, B8_NUMLOTE, B8_DTVALID
							If SB8->( MsSeek( xFilial( "SB8" ) + SC6->C6_PRODUTO + SC6->C6_LOCAL + SC6->C6_LOTECTL + SC6->C6_NUMLOTE ) )
								dValidLote := SB8->B8_DTVALID
							EndIf
						EndIf
						
					EndIf

					cReserva := ""
					lReserva := .F.
					If Empty(aSaldos)
						aSaldos  := {{ cLoteCtl,cNumlote,SC6->C6_LOCALIZ,SC6->C6_NUMSERI,nQtdLib,nQtdLib2,dValidLote,"","","",SC6->C6_LOCAL,0}}
					EndIf
				EndIf
			EndIf
		EndIf
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Aglutina os lotes/sub-lotes iguais                                      ³
		//³Quando ha criacao de reservas na liberacao nao se deve aglutinar as     ³
		//³localizacoes fisicas.                                                   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If ( lCredito .Or. lResEst)
			aAuxiliar := aClone(aSaldos)
			aSaldos   := {}
			For nX := 1 To Len(aAuxiliar)
				
				// Verificar se o usuario preencheu o endereco ou numero de serie
				lNSer0End := IIf(!Empty(SC6->C6_LOCALIZ) .Or.; //Endereço
				                 !Empty(SC6->C6_NUMSERI), ;    //Número de Série)
								 .T., .F.)

				// Caso nao tenha preenchido no pedido de venda o Endereco ou numero de serie para 
				// o produto em questao, vamos verificar se temos algum item nas linhas dos itens 
				// do pedido com o mesmo codigo, lote, sub-lote e armazem
				nAuxiliar := IIf(lNSer0End, 0, aScan(aSaldos,{|x|x[1]==aAuxiliar[nX,1] .And.; // Lote
					                                             x[2]==aAuxiliar[nX,2] .And.; // Sublote
					                                             x[11]==aAuxiliar[nX,11] }))  // Armazem
				
				If ( nAuxiliar == 0 )
					// Foi preenchido Endereco ou Numero de Serie, ou nao foi encontrado
					// um produto com o mesmo preenchimento de lote, sublote e armazem.
					// Entao vamos incluir um novo item no aSaldos para o processamento do SC9.
					AAdd(aSaldos,Array(Len(aAuxiliar[nX])))
					For nY := 1 To Len(aAuxiliar[nX])
						aSaldos[Len(aSaldos)][nY] := aAuxiliar[nX,nY]
					Next nY
					// Limpar os dados de Endereco e numero de serie para realizar a aglutinacao,
					// caso o usuario nao tenha informado Endereco ou Numero de Serie
					If !lNSer0End
						aSaldos[Len(aSaldos)][3] := Space(TamSX3("C6_LOCALIZ")[1])
						aSaldos[Len(aSaldos)][4] := Space(TamSX3("C6_NUMSERI")[1])
					EndIf
					AAdd(aLocaliz,{ aAuxiliar[nX] })
				Else
					// Nao foi preenchido Endereco e Numero de Serie e foi encontrado
					// um produto com o mesmo preenchimento de lote, sublote e armazem no pedido.
					// Entao vamos aglutinar este item que esta sendo processado ao(s) item(ns) 
					// ja existente(s)/aglutinados no aSaldos com mesmo preenchimento de 
					// codigo de produto, lote e sub-lote.
					aSaldos[nAuxiliar][5] += aAuxiliar[nX,5]
					aSaldos[nAuxiliar][6] += aAuxiliar[nX,6]
					AAdd(aLocaliz[nAuxiliar],aAuxiliar[nX])
				EndIf

			Next nX
		Else
			aLocaliz:= { aSaldos }
		EndIf
	EndIf
Else
	If Len(aEmpPronto) > 0
		aSaldos := ACLONE(aEmpPronto)
		lEmpenha := .T.
	Else
		aSaldos := {{ "","","","",nQtdLib,nQtdLib2,Ctod(""),"","","",SC6->C6_LOCAL,0}}
	EndIf
	aLocaliz:= { aSaldos }
EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Verifica se o Bloqueio de Enderecamento do WMS deve ser efetuado       ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
For nX := 1 To Len(aSaldos)
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Efetua a Gravacao do SC9                                               ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lAtualiza
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Garante o estoque caso haja bloqueio de credito atraves de uma reserva  ³
		//³de material.                                                            ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If !lCredito .And. lResEst .And. SF4->F4_ESTOQUE=="S" .And. !lReserva .And. lEstoque
			cReserva := CriaVar("C0_NUM")
			nQtdRese := aSaldos[nX,5]
			If Empty(cReserva)
				cReserva := NextNumero("SC0",1,"C0_NUM",.T.)
			Else
				While ( GetSX8Len() > nSaveSX8 )
					ConfirmSx8()
				EndDo
			EndIf
			//Não efetua reserva para produto com controle de WMS e rastreabilidade, sem o lote preenchido.
			If lWmsNew .And. IntWMS(SC6->C6_PRODUTO) .And. Rastro(SC6->C6_PRODUTO) .And. Empty(aSaldos[nX,1]) .And. Empty(aSaldos[nX,2])
				cReserva := ""
				nQtdRese := 0
			ElseIf !a430Reserva({1,"PD",SC5->C5_NUM,"",cFilAnt},@cReserva,;
					SC6->C6_PRODUTO,aSaldos[nX,11],nQtdRese,;
					{aSaldos[nX,2],aSaldos[nX,1],aSaldos[nX,3],aSaldos[nX,4]})
				cReserva := ""
			Else
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Atualiza a qtde em aberto do pedido de venda                 ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				dbSelectArea("SB2")
				dbSetOrder(1)
				If ( !MsSeek(xFilial("SB2")+SC6->C6_PRODUTO+aSaldos[nX,11]) )
					CriaSB2( SC6->C6_PRODUTO,aSaldos[nX,11] )
				EndIf
				RecLock("SB2")
				SB2->B2_QPEDVEN -= nQtdRese
				SB2->B2_QPEDVE2 -= ConvUM(SB2->B2_COD, nQtdRese, 0, 2)
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Atualiza o saldo da reserva                                  ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				dbSelectArea("SC0")
				dbSetOrder(1)
				If (xFilial("SC0")+cReserva+SC6->C6_PRODUTO+aSaldos[nX,11]==SC0->C0_FILIAL+SC0->C0_NUM+SC0->C0_PRODUTO+SC0->C0_LOCAL .Or. ;
						MsSeek(xFilial("SC0")+cReserva+SC6->C6_PRODUTO+aSaldos[nX,11]) )
					RecLock("SC0")
					SC0->C0_QUANT -= nQtdRese
					SC0->C0_TIPO  := "PD"
					SC0->C0_QTDPED += nQtdRese
				EndIf
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Atualiza o item do pedidod de venda                          ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				RecLock("SC6")
				SC6->C6_QTDRESE += nQtdRese
				SC6->C6_RESERVA := cReserva
			EndIf
		Else
			cReserva := SC6->C6_RESERVA
			nQtdRese := SC6->C6_QTDRESE
		EndIf

		// Caso, tenha integração com o ACD a quantidade tem que ser maior que zero para liberar
		// exceto quando o item do pedido não possuir quantidade
		If !lIntACD .Or. (lIntACD .And. ( aSaldos[nX,5] > 0 .Or. SC6->C6_QTDVEN == 0 ) ) 
			RecLock("SC9",.T.)
			SC9->C9_FILIAL := xFilial("SC9")
			SC9->C9_PEDIDO := SC6->C6_NUM
			SC9->C9_ITEM    := SC6->C6_ITEM
			SC9->C9_SEQUEN  := cSeqSC9
			SC9->C9_PRODUTO := SC6->C6_PRODUTO
			SC9->C9_CLIENTE := SC6->C6_CLI
			SC9->C9_LOJA    := SC6->C6_LOJA
			SC9->C9_PRCVEN  := SC6->C6_PRCVEN
			SC9->C9_DATALIB := dDataBase
			SC9->C9_LOTECTL := aSaldos[nX,1]
			SC9->C9_NUMLOTE := aSaldos[nX,2]
			SC9->C9_QTDLIB  := aSaldos[nX,5]
			SC9->C9_QTDLIB2 := aSaldos[nX,6]
			SC9->C9_DTVALID := aSaldos[nX,7]
			SC9->C9_POTENCI := aSaldos[nX,12]
			SC9->C9_BLCRED  := cBlqCred
			SC9->C9_BLEST   := cBlqEst
			SC9->C9_BLWMS   := Iif((SF4->F4_ESTOQUE == "S" .AND. SC6->C6_QTDVEN > 0) ,cBlqWMS,"")
			SC9->C9_QTDRESE := Min(nQtdRese,SC9->C9_QTDLIB)
			SC9->C9_RESERVA := cReserva
			SC9->C9_AGREG  := &(SuperGetMv("MV_AGREG"))
			SC9->C9_GRUPO  := &(SuperGetMv("MV_GRUPFAT"))
			SC9->C9_IDENTB6:= cIdentB6
			SC9->C9_LOCAL  := aSaldos[nX,11]
			SC9->C9_SERVIC := SC6->C6_SERVIC
			SC9->C9_PROJPMS:= SC6->C6_PROJPMS
			SC9->C9_TASKPMS:= SC6->C6_TASKPMS
			SC9->C9_TRT  	 := SC6->C6_TRT
			SC9->C9_LICITA := SC6->C6_LICITA
			SC9->C9_TPCARGA:= SC5->C5_TPCARGA
			SC9->C9_ENDPAD := SC6->C6_ENDPAD
			SC9->C9_EDTPMS := SC6->C6_EDTPMS
			SC9->C9_DATENT := SC6->C6_ENTREG
			If lItemDv
				SC9->C9_ORDSEP := cOrdsep
			EndIf
			//Grava tipo da Ordem de Produção na liberação
			If ( SC6->C6_TPOP == ' ' ) .Or. ( SC6->C6_TPOP == 'F' )
				SC9->C9_TPOP := '1'
			Else
				SC9->C9_TPOP := '2'
			EndIf
			If !Empty(cSeq)
				SC9->C9_SD3SEQ := cSeq
			Endif

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Regra do WMS, onde: 1=Apanhe por Lote/2=Apanhe por Numero de Serie/3=Apanhe por Data ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			SC9->C9_REGWMS := SC6->C6_REGWMS
			If cPaisLoc == "COL" //Tratamento de Terceros em Vendas
				SC9->C9_NIT := SC6->C6_NIT
			Endif
			If cPaisLoc == "BRA"
				SC9->C9_CODISS := SC6->C6_CODISS
			EndIf	

			SB1->(dbSetOrder(1))
			SB1->(dbSeek(xFilial("SB1")+SC6->C6_PRODUTO))
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³O campo C9_RETOPER é considerado na quebra de Nota Fiscal.(BRASIL)      |
			//³Alguns Clientes que migraram da versao 8 para 10 estao tendo problemas  |
			//³com esta quebra pois na versao 8 esse campo nao possuia um inicializador|
			//³padrao e muitos produtos estao com esse campo em branco.                |
			//³Os campos em branco "" devem ser considerados como "2"=Nao. Assim qdo   |
			//|houver dois produtos ou mais onde alguns estao com os campos em branco e|
			//|e outros com "2" todos devem sair na mesma Nota Fiscal                  |
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If cPaisLoc == "BRA"
				If !Empty(SB1->B1_RETOPER)
					SC9->C9_RETOPER := SB1->B1_RETOPER
				Else
					SC9->C9_RETOPER := "2"
				Endif
			EndIf
		
				//Verifica se o novo DCL está configurado
				If lDclNew 				 									
					DCLMTA440C()//'A Estrutura Organizacional não possui nenhum elemento de nível '					
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Ponto de entrada para todos os itens do pedido.     ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				ElseIf ( ExistTemplate("MTA440C9") )
					ExecTemplate("MTA440C9",.F.,.F.)
				EndIf

			//-- Executa bloco de comandos para montagem de cargas (Oms521Car)
			If ( bBlock <> Nil )
				nRecSC9 := SC9->(Recno())
				Eval(bBlock)
				SC9->(dbGoto(nRecSC9))
				If SoftLock("SC9")
					RecLock("SC9",.F.)
				EndIf
			EndIf

			If ExistBlock("M440SC9I")
				ExecBlock("M440SC9I",.F.,.F.)
			EndIf
			MaAvalSC9("SC9",1,aLocaliz[nX],Nil,Nil,Nil,Nil,Nil,@nVlrCred,,,,lGeraDCF,,lItemDv,cOrdsep)
		
			/* Integração RISK - TOTVS Mais Negócios
			Preenche a liberação do pedido conforme as regras do risk. */
			lLibPed := IIf(lUseOffBalance, SuperGetMV("MV_RSKNTKT",,.F.), .F.)
			If lUseOffBalance .And. RskEvlCredit( 2, SC5->C5_CONDPAG ) .and. lLibPed
				RskFillSC9() 
			EndIf
		
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Atualiza o orcamento do Televendas, se foi originado a partir³
			//³dele no modulo Call Center (SIGATMK)                         ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			TkAtuTlv(SC9->C9_PEDIDO,2)

			If lHabGrvLog //Habilita a função para gravação do log de liberação do pedido de venda
				Aadd(aLogLibPV,{SC9->C9_FILIAL,SC9->C9_PEDIDO,SC9->C9_ITEM,SC9->C9_PRODUTO,SC9->C9_QTDLIB,;
				SC5->C5_ORIGEM,SC9->C9_BLCRED,SC9->C9_BLEST,dDatabase,Time(),IIF(lAutoMt521,2,IIF(INCLUI,1,2)),.F.,"MAGRAVASC9",cTxtLogC, cTxtLogE})

				cTxtLogC := ""
				cTxtLogE := ""
			EndIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Ponto de entrada para todos os itens do pedido.     ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If ( ExistBlock("MTA440C9") )
				ExecBlock("MTA440C9",.F.,.F.)
			EndIf
		EndIf
	Else
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Acumula os dados na variavel aEmpenho                                   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If ( SF4->F4_ESTOQUE == "S" .And. aSaldos[nX,5] > 0 )
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Atualiza qtde a ser reservada no pedido informado            ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			dbSelectArea("SB2")
			dbSetOrder(1)
			MsSeek(xFilial("SB2")+SC6->C6_PRODUTO+aSaldos[nX,11])
			RecLock("SB2")
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Verifica se ha bloqueio de estoque                                      ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If ( lCredito .And. lEstoque )
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Atualiza os empenhos quando ha localizacao                              ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				nRegEmp := aScan(aEmpenho[2],{|x| x[1]==SB2->(RecNo()) .And.;
					x[3] == SC6->C6_LOCALIZ+SC6->C6_NUMSERI+SC6->C6_NUMLOTE+SC6->C6_LOTECTL })
				If ( nRegEmp == 0 )
					AAdd(aEmpenho[2],{ SB2->(RecNo()),aSaldos[nX,5],SC6->C6_LOCALIZ+SC6->C6_NUMSERI+SC6->C6_NUMLOTE+SC6->C6_LOTECTL,aSaldos[nX,6]})
				Else
					aEmpenho[2][nRegEmp][2] += aSaldos[nX,5]
					aEmpenho[2][nRegEmp][4] += aSaldos[nX,6]
				EndIf
			EndIf
		EndIf
		If ( SF4->F4_DUPLIC=="S" .And. !SC5->C5_TIPO$"DB" )
			dbSelectArea("SA1")
			dbSetOrder(1)
			MsSeek(xFilial("SA1")+SC6->C6_CLI+SC6->C6_LOJA)
			lTrvSA1 := IIf(cPaisLoc == "BRA" .And. lFATTRVSA1, ExecBlock("FATTRVSA1", .F., .F., {xFilial("SA1"), SA1->A1_COD, SA1->A1_LOJA}), .T.)
			If lTrvSA1
				RecLock("SA1")
			EndIf
			nMCusto :=  If(SA1->A1_MOEDALC > 0,SA1->A1_MOEDALC,Val(SuperGetMv("MV_MCUSTO")))
			If ( Empty(cBlqCred) )
				nRegEmp := aScan(aEmpenho[1],{|x| x[1]==SA1->(RecNo())})
				If ( nRegEmp == 0 )
					AAdd(aEmpenho[1],{ SA1->(RecNo()),0,0})
					nRegEmp := Len(aEmpenho[1])
				EndIf
				aEmpenho[1][nRegEmp][2] += xMoeda( aSaldos[nX,5] * SC6->C6_PRCVEN , SC5->C5_MOEDA , nMCusto , dDataBase )
				aEmpenho[1][nRegEmp][3] += xMoeda( aSaldos[nX,5] * SC6->C6_PRCVEN , SC5->C5_MOEDA , nMCusto , dDataBase )
			EndIf
		EndIf
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Incrementa o SC9                                                        ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	cSeqSC9 := Soma1(cSeqSC9, Len(SC9->C9_SEQUEN), .T.)

Next nX

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Grava o Log de Liberação do Pedido de Venda                             ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
//Valida as condições para certificar que está apto a gravar o log
If lHabGrvLog .And. !Empty(aLogLibPV)
	FATA410(aLogLibPV)
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Restaura a entrada da rotina                                            ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
RestArea(aAreaSA1)
RestArea(aAreaSB2)
RestArea(aAreaSF4)
RestArea(aAreaSB1)
RestArea(aArea)
Return(.T.)
/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³MaTrfLocal³ Autor ³Eduardo Riera          ³ Data ³19.03.99  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Efetua a transferencia de Locais                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nenhum                                                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpC1: Produto                                              ³±±
±±³          ³ExpC2: Local de Origem                                      ³±±
±±³          ³ExpC3: Local de Destino                                     ³±±
±±³          ³ExpN4: Quantidade                                           ³±±
±±³          ³ExpC5: Documento                                            ³±±
±±³          ³ExpL6: Indica se eh um estorno                              ³±±
±±³          ³ExpL7: D3_NUMSEQ para manter a integridade com a SC9        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³   DATA   ³ Programador   ³Manutencao Efetuada                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³               ³                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function MaTrfLocal(cCodPro,cOrigem,cDestino,nQuant,cDocumento,lEstorno,cSeq,cSD3SEQ)

Local aArea    := GetArea()
Local aAreaSB1 := SB1->(GetArea())
Local aAreaSB2 := SB2->(GetArea())
Local aAreaSD3 := SD3->(GetArea())
Local cNumSeq  := ""
Local aCm      := {}
Local aSd3     := {}
Local lSD3Seq := SC9->(FieldPos("C9_SD3SEQ") > 0)
Local nCntFor  := 0
Local nCntFor2 := 0

Local cArmazDest := ""
Local cArmazOrig := ""
Local aLinLogMsg := {}
Local lIsTrfExc  := Type("aColTrfExc") == "A"
Local cC9SD3SEQ := ""

Default cCodPro		= ""
Default cDestino	= ""
Default cDocumento	= ""
Default cOrigem		= ""
Default cSD3SEQ		= ""
Default cSeq		= ""
Default lEstorno	= .F.
Default nQuant		= 0

dbSelectArea("SB1")
dbSetOrder(1)
MsSeek(xFilial("SB1")+cCodPro)

If !lEstorno
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Requisicao do produto e local de origem                                 ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	dbSelectArea("SB2")
	dbSetOrder(1)
	If ( !MsSeek(xFilial("SB2")+SB1->B1_COD+cOrigem) )
		CriaSB2( SB1->B1_COD,cOrigem )
	EndIf
	RecLock("SB2",.F.)

	cNumSeq  := ProxNum()
	aCM := PegaCMAtu(SB1->B1_COD,cOrigem)
	RecLock("SD3",.T.)
	SD3->D3_FILIAL  := xFilial("SD3")
	SD3->D3_COD     := SB1->B1_COD
	SD3->D3_QUANT   := nQuant
	SD3->D3_CF      := "RE4"
	SD3->D3_CHAVE   := "E0"
	SD3->D3_LOCAL   := cOrigem
	SD3->D3_DOC     := cDocumento
	SD3->D3_EMISSAO := dDatabase
	SD3->D3_UM      := SB1->B1_UM
	SD3->D3_GRUPO   := SB1->B1_GRUPO
	SD3->D3_TIPO    := SB1->B1_TIPO
	SD3->D3_NUMSEQ  := cNumSeq
	SD3->D3_QTSEGUM := ConvUm(SB1->B1_COD,nQuant,0,2)
	SD3->D3_SEGUM   := SB1->B1_SEGUM
	SD3->D3_PARCTOT := "V"
	SD3->D3_TM      := "999"
	aCusto := GravaCusD3(aCM)
	B2AtuComD3(aCusto)

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Cria almoxarifado de destino                                            ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	dbSelectArea("SB2")
	dbSetOrder(1)
	If ( !MsSeek(xFilial("SB2")+SB1->B1_COD+cDestino) )
		CriaSB2( SB1->B1_COD,cDestino )
	EndIf
	RecLock("SB2",.F.)

	RecLock("SD3",.T.)
	SD3->D3_FILIAL  := xFilial("SD3")
	SD3->D3_COD     := SB1->B1_COD
	SD3->D3_QUANT   := nQuant
	SD3->D3_CF      := "DE4"
	SD3->D3_CHAVE   := "E9"
	SD3->D3_LOCAL   := cDestino
	SD3->D3_DOC     := cDocumento
	SD3->D3_EMISSAO := dDatabase
	SD3->D3_UM      := SB1->B1_UM
	SD3->D3_GRUPO   := SB1->B1_GRUPO
	SD3->D3_TIPO    := SB1->B1_TIPO
	SD3->D3_NUMSEQ  := cNumSeq
	SD3->D3_QTSEGUM := ConvUm(SB1->B1_COD,nQuant,0,2)
	SD3->D3_SEGUM   := SB1->B1_SEGUM
	SD3->D3_PARCTOT := "V"
	SD3->D3_TM      := "499"

	aCusto := GravaCusD3(aCM)
	B2AtuComD3(aCusto)

	If lSD3Seq
		cSeq := SD3->D3_NUMSEQ
	EndIf
Else
	If lSD3Seq
		If FwIsInCallStack('MaAvalSC6')
			cC9SD3SEQ := cSD3SEQ
		Else
			cC9SD3SEQ := SC9->C9_SD3SEQ
		EndIf
	EndIf

	cDocumento := cDocumento + Space(Len(SD3->D3_DOC) - Len(AllTrim(cDocumento)))
	dbSelectArea("SD3")
	dbSetOrder(2)
	MsSeek(xFilial("SD3")+cDocumento+SB1->B1_COD)
	While ( SD3->(!Eof()) .And. cDocumento== SD3->D3_DOC .And.;
			cCodPro   == SD3->D3_COD )
		If ( SD3->D3_PARCTOT=="V" ) .And. (IIF(lSD3Seq, SD3->D3_NUMSEQ == cC9SD3SEQ, .T.))
			If (SD3->D3_EMISSAO > MvUlMes())
				AAdd(aSd3,{})
				For nCntFor := 1 To SD3->(FCount())
					If !("MSUID" $ SD3->(Field(nCntFor)))
						AAdd(aSD3[Len(aSD3)],SD3->(FieldGet(nCntFor)))
					EndIf
				Next nCntFor
				RecLock("SD3",.F.)
				SD3->D3_ESTORNO := "S"
			ElseIf lIsTrfExc

				If (SD3->D3_CF == "DE4")
					cArmazDest := SD3->D3_LOCAL
				ElseIf (SD3->D3_CF == "RE4")
					cArmazOrig := SD3->D3_LOCAL
				EndIf

				// Guardar os dados no array para informar ao usuario apos o final do processamento
				If !Empty(cArmazDest) .And. !Empty(cArmazOrig)
					aLinLogMsg := { SC6->C6_ITEM,                                         ; // 01 - Item do Pedido de Venda
									SC6->C6_PRODUTO,                                      ; // 02 - Codigo do Produto
									cArmazOrig,              		                      ; // 03 - Armazém Origem
									cArmazDest,       		                              ; // 04 - Armazém Destino
									SD3->D3_NUMSEQ,                            	          ; // 05 - Sequencia do movimento
									SD3->D3_QUANT,                            	          ; // 06 - Quantidade movimentada
									SD3->D3_EMISSAO,                           	          ; // 07 - Data Transf.
									.F.                                                   ; // 08 - Indica se a linha foi deletada ou nao (.T.=Deletado, .F.=Nao Deletado)
								}
					AAdd(aColTrfExc, aLinLogMsg)
					FreeObj(aLinLogMsg)
					cArmazOrig := ""
					cArmazDest := ""
				EndIf
			EndIf
		EndIf
		dbSelectArea("SD3")
		SD3->(dbSkip())
	EndDo
	For nCntFor := 1 To Len(aSd3)
		RecLock("SD3",.T.)
		For nCntFor2 := 1 To Len(aSd3[nCntFor])
			SD3->(FieldPut(nCntFor2,aSd3[nCntFor][nCntFor2]))
		Next nCntFor2
		aCm   := PegaCMAtu(SD3->D3_COD,SD3->D3_LOCAL)
		If ( SD3->D3_CF == "DE4" )
			SD3->D3_CF     := "RE4"
			SD3->D3_CHAVE  := "E0"
			SD3->D3_TM     := "999"
			SD3->D3_ESTORNO:= "S"
			SD3->D3_EMISSAO:= dDataBase
		Else
			SD3->D3_CF     := "DE4"
			SD3->D3_CHAVE  := "E9"
			SD3->D3_TM     := "499"
			SD3->D3_ESTORNO:= "S"
			SD3->D3_EMISSAO:= dDataBase
		EndIf
		aCusto := GravaCusD3(aCm)
		B2AtuComD3(aCusto)

	Next nCntFor
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Restaura a entrada da rotina                                            ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
FwFreeArray(aSD3)
RestArea(aAreaSB1)
RestArea(aAreaSB2)
RestArea(aAreaSD3)
RestArea(aArea)

Return(.T.)

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³MaAvLibPed³ Autor ³Eduardo Riera          ³ Data ³23.03.99  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Verifica se um pedido pode ser totalmente liberado          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpL1: Pedido pode ser totalmente liberado                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpC1: Numero do Pedido                                     ³±±
±±³          ³ExpL2: Liberacao Parcial                                    ³±±
±±³          ³ExpL3: Transfere Locais                                     ³±±
±±³          ³ExpL4: lLiberOk                                             ³±±
±±³          ³ExpA5: Registros a serem processados ( Default Todos )      ³±±
±±³          ³Expb6: Code Block a ser avaliado na gravacao do SC9         ³±±
±±³          ³ExpL7: Indica se ha estorno de liberacao                    ³±±
±±³          ³ExpL8: Indica se ha avaliacao de credito                    ³±±
±±³          ³ExpL9: Indica se ha avaliacao de estoque                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Observacao³Deve estar numa transacao                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³   DATA   ³ Programador   ³Manutencao Efetuada                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³               ³                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function MaAvLibPed(cNumPed,lLiber,lTransf,lLiberOk,aRegistros,bBlock,lEstLib,lAvCred,lAvEst,nVlrCred)

Local aArea    := GetArea()
Local aAreaSA1 := SA1->(GetArea())
Local aAreaSF4 := SF4->(GetArea())
Local aAreaSC5 := SC5->(GetArea())
Local aAreaSC6 := SC6->(GetArea())
Local aAreaSC9 := SC9->(GetArea())
Local aEmpenho := {{},{}}
Local lRetorno := .F.
Local lBloqueio:= .F.
Local lLibEst  := .F.
Local lLibCred := .F.
Local lCredito := .F.
Local lEstoque := .F.
Local lFind	   := .F.
Local nX       := 0
Local nQtdLib  := 0
Local nCredito := nVlrCred
Local nSldOrdSep := 0

lLiberOk := .T.
DEFAULT nVlrCred   := 0
DEFAULT aRegistros := {}
DEFAULT lAvCred    := .T.
DEFAULT lAvEst     := .T.
DEFAULT lEstLib    := .F.
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³MEMORIA DE CALCULO DO ARRAY aEmpenho                                    ³
//³                                                                        ³
//³[1] - SA1                                                               ³
//³[1][1] - Registro                                                       ³
//³[1][2] - A1_SALPEDL                                                     ³
//³[2] - SB2                                                               ³
//³[2][1] - Registro                                                       ³
//³[2][2] - B2_RESERVA                                                     ³
//³                                                                        ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Posiciona Registros                                                     ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
dbSelectArea("SC5")
dbSetOrder(1)
lFind := MsSeek(xFilial("SC5")+cNumPed)

If lFind
	lRetorno := RecLock("SC5")
	If !( SC5->C5_TIPO$"BD" )
		dbSelectArea("SA1")
		dbSetOrder(1)
		MsSeek(xFilial("SA1")+SC5->C5_CLIENTE+SC5->C5_LOJACLI)
		lTrvSA1 := IIf(cPaisLoc == "BRA" .And. lFATTRVSA1, ExecBlock("FATTRVSA1", .F., .F., {xFilial("SA1"), SA1->A1_COD, SA1->A1_LOJA}), .T.)
		If lTrvSA1
			lRetorno := RecLock("SA1")
		EndIf
	Else
		dbSelectArea("SA2")
		dbSetOrder(1)
		MsSeek(xFilial("SA2")+SC5->C5_CLIENTE+SC5->C5_LOJACLI)
		lRetorno := RecLock("SA2")
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Verifica o tipo de processamento                                        ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If Len(aRegistros) > 0
		lLibEst  := .T.
		lLibCred := .T.
		For nX := 1 To Len(aRegistros)
			nSldOrdSep := 0
			SC6->(MsGoto(aRegistros[nX]))
			lRetorno := RecLock("SC6")
			If ( lRetorno )
				If lEstLib
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³Verifica a necessidade de estorno da liberacao                          ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					nSldOrdSep := FtGtSldOS()
					nQtdLib := SC6->C6_QTDEMP - nSldOrdSep
					If nQtdLib > 0
						MaAvalSC6("SC6",4,"SC5",Nil,Nil,Nil,Nil,Nil,Nil,@nCredito)
						RecLock("SC6")
						SC6->C6_QTDLIB := nQtdLib
					Else
						nQtdLib := SC6->C6_QTDLIB
					EndIf
				Else
					nQtdLib := SC6->C6_QTDLIB
				EndIf
				lCredito := .F. .Or. !lAvCred
				lEstoque := .F.
				MaLibDoFat(SC6->(RecNo()),nQtdLib,@lCredito,@lEstoque,lAvCred,lAvEst,lLiber,lTransf,@aEmpenho,bBlock,Nil,Nil,Nil,@nCredito)
			Else
				lCredito := .F.
				lEstoque := .F.
			EndIf
			lLibCred := lCredito .And. lLibCred
			lLibEst  := lEstoque .And. lLibEst
			If ( !lLibEst .And. !lLibCred )
				nX := Len(aRegistros)+1
			EndIf
		Next nX
	Else
		lLibEst  := .T.
		lLibCred := .T.
		lBloqueio:= .F.
		dbSelectArea("SC6")
		dbSetOrder(1)
		MsSeek(xFilial("SC6")+SC5->C5_NUM,.F.)
		While ( !Eof() .And. xFilial("SC6") == SC6->C6_FILIAL .And.;
				SC5->C5_NUM    == SC6->C6_NUM )
			lRetorno := RecLock("SC6")
			If ( lRetorno )
				AAdd(aRegistros,SC6->(RecNo()))
				If !lBloqueio
					lCredito := .F. .Or. !lAvCred
					lEstoque := .F.
					MaLibDoFat(SC6->(RecNo()),SC6->C6_QTDLIB,@lCredito,@lEstoque,lAvCred,lAvEst,lLiber,lTransf,@aEmpenho,bBlock,Nil,Nil,Nil,@nCredito)
				EndIf
			Else
				lCredito := .F.
				lEstoque := .F.
			EndIf
			lLibCred := lCredito .And. lLibCred
			lLibEst  := lEstoque .And. lLibEst
			If ( !lLibEst .And. !lLibCred )
				lBloqueio := .T.
			EndIf
			dbSelectArea("SC6")
			dbSkip()
		EndDo
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Atualiza os dados com base no processamento anterior                    ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	lEstoque := .T.
	For nX := 1 To Len(aRegistros)
		nSldOrdSep := 0
		SC6->(MsGoto(aRegistros[nX]))
		RecLock("SC6")
		If ( !lLibEst .Or. !lLibCred )
			lRetorno := .F.
			If lEstLib
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Verifica a necessidade de estorno da liberacao                          ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				nSldOrdSep := FtGtSldOS()
				nQtdLib := SC6->C6_QTDEMP - nSldOrdSep
				If nQtdLib > 0
					MaAvalSC6("SC6",4,"SC5",Nil,Nil,Nil,Nil,Nil,Nil,@nVlrCred)
				Else
					nQtdLib := SC6->C6_QTDLIB
				EndIf
			Else
				nQtdLib := SC6->C6_QTDLIB
			EndIf
			lCredito := lLibCred
			lEstoque := (lLibCred .And. lLibEst) .Or. (lLibEst .And. lEstoque .And. SuperGetMv("MV_RESEST"))
			MaLibDoFat(SC6->(RecNo()),nQtdLib,@lCredito,@lEstoque,lCredito .And. lAvCred,lEstoque,lLiber,lTransf,,bBlock,Nil,Nil,Nil,@nVlrCred)
			Do Case
			Case lLibCred <> lCredito .And. lLibCred
				lLibCred := .F.
			Case lLibEst <> lEstoque .And. lLibEst
				lLibEst := .F.
			EndCase
		Else
			MaLibDoFat(SC6->(RecNo()),SC6->C6_QTDLIB,@lCredito,@lEstoque,lAvCred,.T.,lLiber,lTransf,,bBlock,Nil,Nil,Nil,@nVlrCred)
		EndIf
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Verifica se Todos os Itens foram Liberados                              ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If ( SC6->C6_QTDVEN > SC6->C6_QTDEMP + SC6->C6_QTDENT .And. lLiberOk .And. AllTrim(SC6->C6_BLQ)<>"R" )
			lLiberOk := .F.
		EndIf
	Next nX
EndIf

RestArea(aAreaSC9)
RestArea(aAreaSA1)
RestArea(aAreaSF4)
RestArea(aAreaSC5)
RestArea(aAreaSC6)
RestArea(aArea)
Return(lRetorno)

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³a410Grade ³ Autor ³ Eduardo Riera         ³ Data ³ 03.12.98 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Montagem do aHeader, aCols , aColsGrade e aHeaderGrade.     ³±±
±±³          ³para os itens que possuem grade.                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nenhum                                                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpL1: Se True e adionado o controle de Deletados           ³±±
±±³          ³ExpL2: Indica se a chamada eh feita pela Liberacao          ³±±
±±³          ³ExpC3: Alias de referencia ao SC6 ( Query )                 ³±±
±±³          ³ExpL4: Indica se os registros bloqueado devem ser considera-³±±
±±³          ³       dos.                                                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³   DATA   ³ Programador   ³Manutencao Efetuada                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³               ³                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function a410Grade(lDelAcols,lMata440,cAlias,lBloqueados,lCriaCols)

Local nTamaCols:=Len(aCols)
Local nPosItem :=aScan(aHeader,{|x| AllTrim(x[2])=="C6_ITEM"})
Local nPosQtd  :=aScan(aHeader,{|x| AllTrim(x[2])=="C6_QTDVEN"})
Local nPosQtd2 :=aScan(aHeader,{|x| AllTrim(x[2])=="C6_UNSVEN"})
Local nPosVlr  :=aScan(aHeader,{|x| AllTrim(x[2])=="C6_VALOR"})
Local nPosSld  :=aScan(aHeader,{|x| AllTrim(x[2])=="C6_SLDALIB"})
Local nPosDesc :=aScan(aHeader,{|x| AllTrim(x[2])=="C6_VALDESC"})
Local nCntFor  :=0
Local nItGrade := 1
Local cProdRef := ""
Local cLinha   := ""
Local cColuna  := ""
Local nLinha   := 0
Local nColuna  := 0
DEFAULT lBloqueados := .F.
DEFAULT lCriaCols   := .T.
lMata440 := If(lMata440==Nil,.F.,lMata440)
cAlias   := If(cAlias==Nil,"SC6",cAlias)

If ( nTamAcols <> 0 )
	nItGrade := nTamAcols
	If ( aCols[nTamaCols][nPosItem] <> (cAlias)->C6_ITEM )
		nItGrade ++
	EndIf
EndIf

cProdRef := (cAlias)->C6_PRODUTO

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Inicializa o aHeadGrade e o AcolsGrade                                  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
&(MaReadGrd()):MontaGrade(nItGrade,@cProdRef,,lBloqueados)

cLinha   := AllTrim(Substr((cAlias)->C6_PRODUTO,&(MaReadGrd()):TamRef()+1,&(MaReadGrd()):TamLin()))
cColuna  := AllTrim(Substr((cAlias)->C6_PRODUTO,(&(MaReadGrd()):TamRef()+&(MaReadGrd()):TamLin()+1),&(MaReadGrd()):TamCol()))

nColuna := &(MaReadGrd()):RetPosCol(nItGrade,cColuna)
nLinha  := &(MaReadGrd()):RetPosLin(nItGrade,cLinha)
If ( nColuna<>0 .And. nLinha <> 0 )
	nColuna++
	&(MaReadGrd()):aColsGrade[nItGrade][nLinha][nColuna][&(MaReadGrd()):GetFieldGrdPos("C6_QTDVEN")] 	+= (cAlias)->C6_QTDVEN
	&(MaReadGrd()):aColsGrade[nItGrade][nLinha][nColuna][&(MaReadGrd()):GetFieldGrdPos("C6_QTDLIB")] 	:= 0
	&(MaReadGrd()):aColsGrade[nItGrade][nLinha][nColuna][&(MaReadGrd()):GetFieldGrdPos("C6_QTDENT")] 	:= If(lMata440,(cAlias)->C6_QTDENT+(cAlias)->C6_QTDEMP,(cAlias)->C6_QTDENT)
	&(MaReadGrd()):aColsGrade[nItGrade][nLinha][nColuna][&(MaReadGrd()):GetFieldGrdPos("C6_ITEM")]	:= (cAlias)->C6_ITEM
	&(MaReadGrd()):aColsGrade[nItGrade][nLinha][nColuna][&(MaReadGrd()):GetFieldGrdPos("C6_UNSVEN")] 	:= (cAlias)->C6_UNSVEN
	&(MaReadGrd()):aColsGrade[nItGrade][nLinha][nColuna][&(MaReadGrd()):GetFieldGrdPos("C6_BLQ")] 	:= (cAlias)->C6_BLQ
	&(MaReadGrd()):aColsGrade[nItGrade][nLinha][nColuna][&(MaReadGrd()):GetFieldGrdPos("C6_OPC")] 	:= (cAlias)->C6_OPC
EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Monta o Acols                                                                        ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
// -- Nao monta aCols se for chamada pelo bloco de codigo da FillGetDados
If lCriaCols
	If ( nTamAcols==0 .Or. aCols[nTamAcols][nPosItem] <> (cAlias)->C6_ITEM )
		AAdd(aCols,Array(Len(aHeader)+If(lDelaCols,1,0)))
		nTamAcols++
		For nCntFor := 1 To Len(aHeader)
			If ( aHeader[nCntFor][10] == "V" )
				aCols[nTamAcols][nCntFor] := CriaVar(aHeader[nCntFor][2])
			Else
				aCols[nTamAcols][nCntFor] := (cAlias)->(FieldGet(FieldPos(aHeader[nCntFor][2])))
			EndIf
			If ( AllTrim(aHeader[nCntFor][2]) == "C6_PRODUTO" )
				aCols[nTamAcols][nCntFor] := PadR(cProdRef,Len(SB1->B1_COD))
			EndIf
		Next nCntFor
		If ( lDelaCols )
			aCols[nTamAcols][Len(aHeader)+1] := .F.
		EndIf
	Else
		aCols[nTamAcols][nPosQtd]  += (cAlias)->C6_QTDVEN
		If nPosQtd2 <> 0
			aCols[nTamAcols][nPosQtd2] += (cAlias)->C6_UNSVEN
		EndIf
		If ( nPosDesc > 0 )
			aCols[nTamAcols][nPosDesc] += (cAlias)->C6_VALDESC
		Endif
		If ( nPosSld > 0 )
			aCols[nTamAcols][nPosSld] += Ma440SaLib()
		EndIf
		aCols[nTamAcols][nPosVlr] += (cAlias)->C6_VALOR
	EndIf
EndIf
Return(.T.)

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³a410Arred ³ Autor ³ Eduardo Riera         ³ Data ³ 19.02.99 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Retorna o valor com o padrao de arredondamento MV_ARREFAT. ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ ExpN1: Novo Valor conforme parametro MV_ARREFAT            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpN1: Valor                                               ³±±
±±³          ³ ExpC2: Nome do Campo                                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³   DATA   ³ Programador   ³Manutencao Efetuada                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³               ³                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function A410Arred(nVArred,cCampo,nMoeda)

Local aArea    := GetArea()
Local aAreaSX3 := {}
Local nPosDec  := 0
Local nCasas   := 2

DEFAULT cCampo := "C6_PRCVEN"
DEFAULT __cSX3Casas  := ""

cCampo := Upper(Alltrim(cCampo))

//Se a empresa for trocada via SIGAADV, o cache é zerado.
If cEmpAnt <> __cEmpLog
	__cSX3Casas := ""
	__cEmpLog	:= cEmpAnt
	__cFilLog   := cFilAnt
	__lArrefat 	:= Nil
ElseIf cFilAnt <> __cFilLog
	__cFilLog   := cFilAnt
	__lArrefat 	:= Nil
EndIf

If __lArrefat == Nil
	__lArrefat := ( SuperGetMv("MV_ARREFAT") == "S" )
EndIf

If cPaisLoc <> "BRA" .And. nMoeda <> NIL
	nCasas := MsDecimais(nMoeda)
Else
	nPosDec := AT(cCampo+"/",__cSX3Casas)
	IF nPosDec <> 0
		nCasas  := Val(Subs(__cSX3Casas,nPosDec+Len(cCampo)+1,2))
	Else
		aAreaSX3 := SX3->(GetArea())

		nCasas := TamSX3(cCampo)[2]
		__cSX3Casas += cCampo+"/"+StrZero(nCasas,2,0)+"//"

		RestArea(aAreaSX3)
	EndIf
EndIf
IF cPaisLoc=="BOL"  .AND. FindFunction("DECIMICEEX")
	nCasas := DECIMICEEX(funname(),nMoeda,nCasas)
ENDIF
If __lArrefat
	nVArred := Round(nVarred,nCasas)
Else
	nVArred := NoRound(nVarred,nCasas)
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Retorna o estado de entrada                                             ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
RestArea(aArea)
Return(nVArred)

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³Ma440SaLib³ Autor ³Eduardo Riera          ³ Data ³ 08.03.99 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Calculo do Saldo da Quantidade a Liberar.                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpN1: Saldo da Quantidade Liberada.                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³Nenhum                                                      ³±±
±±³          ³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³   DATA   ³ Programador   ³Manutencao Efetuada                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³               ³                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function Ma440SaLib()

Local nSaldo := 0

nSaldo := Max(SC6->C6_QTDVEN - SC6->C6_QTDEMP - SC6->C6_QTDENT,0)

Return(nSaldo)

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³IncNota   ³ Autor ³Claudia Cabral         ³ Data ³ 08.08.00 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Inclusao Automatica de Nota Fiscal para a Exportacao(SIGAEEC) |±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nenhum                                                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³Numero do Pedido de Venda                                   ³±±
±±³          ³Serie da Nota Fiscal                                        ³±±
±±³          ³Numero do Embarque de Exportacao                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³   DATA   ³ Programador   ³Manutencao Efetuada                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³24/10/2006³Ronald Piscion.³BOPS 108518: o array aPvlNfs era enviado co-³±±
±±³          ³               ³mo parametro para a funcao MaPvlNfs zerado, ³±±
±±³          ³               ³quando o nro. de itens era igual ao parame- ³±±
±±³          ³               ³tro MV_NUMITEN (var. nItemNF)               ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/

Function IncNota(cC5Num,cSerie,cEmbExp,aNotas)
Local aPvlNfs := {}
Local nPrcVen := 0
Local nItemNf := a460NumIt(cSerie)

Default aNotas := {}

SC5->(DbSetOrder(1))
SC5->(MsSeek(xFilial("SC5")+cC5Num))

SC6->(dbSetOrder(1))
SC6->(MsSeek(xFilial("SC6")+SC5->C5_NUM))

While SC6->(!Eof() .And. C6_FILIAL == xFilial("SC6")) .And.;
		SC6->C6_NUM == SC5->C5_NUM

	SC9->(DbSetOrder(1))
	SC9->(MsSeek(xFilial("SC9")+SC6->(C6_NUM+C6_ITEM))) //FILIAL+NUMERO+ITEM

	SE4->(DbSetOrder(1))
	SE4->(MsSeek(xFilial("SE4")+SC5->C5_CONDPAG) )  //FILIAL+CONDICAO PAGTO

	SB1->(DbSetOrder(1))
	SB1->(MsSeek(xFilial("SB1")+SC6->C6_PRODUTO))    //FILIAL+PRODUTO

	SB2->(DbSetOrder(1))
	SB2->(MsSeek(xFilial("SB2")+SC6->(C6_PRODUTO+C6_LOCAL))) //FILIAL+PRODUTO+LOCAL

	SF4->(DbSetOrder(1))
	SF4->(MsSeek(xFilial("SF4")+SC6->C6_TES))   //FILIAL+TES

	nPrcVen := SC9->C9_PRCVEN
	If ( SC5->C5_MOEDA <> 1 )
		nPrcVen := xMoeda(nPrcVen,SC5->C5_MOEDA,1,dDataBase)
	EndIf

	AAdd(aPvlNfs,{ SC9->C9_PEDIDO,;
		SC9->C9_ITEM,;
		SC9->C9_SEQUEN,;
		SC9->C9_QTDLIB,;
		nPrcVen,;
		SC9->C9_PRODUTO,;
		.f.,;
		SC9->(RecNo()),;
		SC5->(RecNo()),;
		SC6->(RecNo()),;
		SE4->(RecNo()),;
		SB1->(RecNo()),;
		SB2->(RecNo()),;
		SF4->(RecNo())})


	If ( Len(aPvlNfs) >= nItemNf )
		cNota := MaPvlNfs(aPvlNfs,cserie , .F.    , .F.    , .F.     , .T.    , .F.    , 0      , 0          , .T.  ,.F.,cEmbExp)
		//cNota := MaPvlNfs(aPvlNfs,cSerie,lMostraCtb,lAglutCtb,lCtbOnLine,lCtbCusto,lReajusta,nCalAcrs,nArredPrcLis,lAtuSA7,lECF,cembexp)
		aPvlNfs := {}
		AAdd( aNotas, { cSerie, cNota } )
	EndIf
	SC6->(DbSkip())
EndDo
If Len(aPvlNfs) > 0
    cNota := MaPvlNfs(aPvlNfs,cserie, .F.    , .F.    , .F.     , .T.    , .F.    , 0      , 0          , .T.  ,.F.,cEmbExp)
    AAdd( aNotas, { cSerie, cNota } )
EndIf

Return

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³Estorna_PV³ Autor ³Claudia Cabral         ³ Data ³ 08.08.00 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Estorno e Exclusao do Pedido de Venda para a Exportacao (SigaEEC)|±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nenhum                                                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³Numero do Pedido de Venda                                   ³±±
±±³          ³Matriz de Cabecalho                                         ³±±
±±³          ³Matriz de Itens                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³   DATA   ³ Programador   ³Manutencao Efetuada                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³               ³                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/

Function Estorna_PV(cSC5Num,aMata410Cab,aMata410Itens)

dbSelectArea("SC6")
dbSetOrder(1)    //C6_FILIAL+C6_NUM+C6_ITEM+C6_PRODUTO
If MsSeek(xFilial("SC6")+cSC5Num)
	While !Eof() .and. cSC5Num == SC6->C6_NUM .and. xFilial("SC6") == SC6->C6_FILIAL
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Eliminacao de residuo por item de pedido              ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If SC6->C6_QTDEMP > 0
			dbSelectArea("SC9")
			dbSetOrder(1)
			If MsSeek(xFilial("SC9")+SC6->C6_NUM+SC6->C6_ITEM)
				SC9->(a460Estorna())
			Endif
		Endif

		dbSelectArea("SC6")

		dbSkip()
	EndDo
Endif

MATA410( aMata410Cab ,aMata410Itens , 5 )

Return

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³MaAvalSC5 ³ Autor ³Eduardo Riera          ³ Data ³13.02.2000³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Rotina de avaliacao dos eventos do Cabecalho do Pedido de   ³±±
±±³          ³Venda.                                                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpC1: Alias da tabela de Cabecalho do Pedido de Venda      ³±±
±±³          ³ExpN2: Codigo do Evento                                     ³±±
±±³          ³       [1] Implantacao do Pedido de Venda                   ³±±
±±³          ³       [2] Estorno do Pedido de Venda                       ³±±
±±³          ³       [3] Liberacao do Pedido de Venda                     ³±±
±±³          ³       [4] Estorno da Liberacao do Pedido de Venda          ³±±
±±³          ³       [5] Preparacao da Nota Fiscal de Saida               ³±±
±±³          ³       [6] Exclusao da Nota Fiscal de Saida                 ³±±
±±³          ³       [7] Reavaliacao de Credito (Por Pedido)              ³±±
±±³          ³       [8] Estorno da Reavalizacao de Credito ( Por Pedido )³±±
±±³          ³ExpL3: Liberacao Parcial                                    ³±±
±±³          ³ExpL4: Transfere Locais                                     ³±±
±±³          ³ExpL5: Verifica se todos os itens foram liberados           ³±±
±±³          ³ExpL6: Verifica os residuos do pedido de venda              ³±±
±±³          ³ExpL7: Verifica se todos os itens foram faturados           ³±±
±±³          ³ExpL8: Atualiza somente os acumulados          (DEFA: .F.)  ³±±
±±³          ³ExpL9: Indica que todos os itens foram gravado (DEFA: .T.)  ³±±
±±³          ³ExpCA: Numero do Pedido de Venda                      (OPC) ³±±
±±³          ³ExpAB: Array com os recnos do SC6                     (OPC) ³±±
±±³          ³ExpLC: Estorna liberacoes anteriores                  (OPC) ³±±
±±³          ³ExpLD: Avalia Credito                                 (OPC) ³±±
±±³          ³ExpNE: Valor a ser adicionado ao limite de credito    (OPC) ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nenhum                                                      ³±±
±±³          ³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Esta rotina tem como objetivo atualizar os eventos vinculado³±±
±±³          ³ao cabecalho do pedido de venda                             ³±±
±±³          ³A) Atualizacao das tabelas complementares.                  ³±±
±±³          ³B) Atualizacao das informacoes complementares do PV         ³±±
±±³          ³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Materiais                                                  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function MaAvalSC5(cAliasSC5,nEvento,lLiber,lTransf,lLiberOk,lResidOk,lFaturOk,lAcumulado,lFinal,cPedido,aRegSC6,lEstLib,lAvCred,nVlrCred)

Local aArea     := GetArea(cAliasSC5)
Local lAtuSC5   := .F.
Local cQuery    := ""
Local lResAut   := SuperGetMv("MV_RESAUT")
Local lNoRunFlCx:= ExistBlock("FtNRunFlCx")
Local LExecFlCx	:= .T.

DEFAULT lAcumulado:= .F.
DEFAULT lFinal    := .T.
DEFAULT cPedido   := (cAliasSC5)->C5_NUM
DEFAULT nVlrCred  := 0

RecLock("SC5")
Do Case
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Implantacao de um do pedido de venda                                    ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	Case nEvento == 1
		//Valida a data da LIB para utilização na Telemetria
		If FatLibMetric() .and. _lMetricsSC5
			//Telemetria - MV_RESTAUT - Geração de Reserva Automática de Estoque pelo Pedido de Venda
			FwCustomMetrics():setUniqueMetric("FATXFUN","faturamento-protheus_reserva-automatica-estoque-pedido-venda_total", IIf(lResAut,".T.",".F."), /*dDateSend*/, /*nLapTime*/,"FATXFUN")
		EndIf
		Do Case
			Case lLiberOk
				(cAliasSC5)->C5_LIBEROK := "S"
			Case lResidOk
				(cAliasSC5)->C5_LIBEROK := "E"
			OtherWise
				(cAliasSC5)->C5_LIBEROK := ""
		EndCase
		If ( lFaturOk )
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Release 11.5 Localização Chile/Colombia                                  		    ³
			//³Para esses paises será informada a serie da tela de controle de formularios 			³
			//³por tanto não zera o campo C5_SERIE que sera alimentada pelo parametro MV_LOJAPED	³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If cPaisloc$"COL|CHI" .AND. nModulo == 12 .AND. !Empty(SC5->C5_ORCRES)
				(cAliasSC5)->C5_NOTA  := ""
			Else
				(cAliasSC5)->C5_NOTA  := ""
				(cAliasSC5)->C5_SERIE := ""
			EndIf
		Else
			If Empty((cAliasSC5)->C5_NOTA) .AND. !((cAliasSC5)->C5_TIPO $ "CIP")
				(cAliasSC5)->C5_NOTA  := "XXXXXX"
				(cAliasSC5)->C5_SERIE := "XXX"
			EndIf
		EndIf
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Integracao com o SIGAEEC                                                ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If GetMv("MV_EECFAT")
			If FindFunction("AE100STATUS")
				AE100STATUS(SC5->C5_PEDEXP)
			EndIf
		EndIf

		If lNoRunFlCx
			LExecFlCx := ExecBlock("FtNRunFlCx",.F.,.F.)
			If Valtype(LExecFlCx) <> "L"
				LExecFlCx := .T.
			EndIf
		EndIf
		
		//Rotina de fluxo de caixa descontinuada pelo Financeiro FINC010 https://tdn.totvs.com/pages/viewpage.action?pageId=666465458
		If GetRpoRelease() <= "12.1.033" .And. Date() <= STOD('20220822')
			If !lAcumulado .And. LExecFlCx
				StartJob("FtJobPvCF",GetEnvServer(),.F.,cEmpAnt,cFilAnt,(cAliasSC5)->C5_NUM)
			EndIf
		EndIf	
		
		If !lAcumulado
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Grava os lancamentos nas contas orcamentarias SIGAPCO    ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			PcoDetLan("000100","03","MATA410")
		EndIf
		// Elimina o saldo do relacionamento do Pedido de Venda que foi finalizado
		If (cAliasSC5)->C5_LIBEROK == "S"                                   .AND.;
		   (cAliasSC5)->C5_NOTA == PadR("XXXXXX",Len((cAliasSC5)->C5_NOTA)) .AND.;
		   (cAliasSC5)->C5_SERIE == "XXX"                                   .AND.;
		   A410UsaAdi(SC5->C5_CONDPAG)
			FPedAdtRsd("R", {SC5->C5_NUM})
		EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Estorno de um pedido de venda                                           ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	Case nEvento == 2
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Atualiza a tabela de fluxo de caixa do PV        ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		cQuery := "DELETE FROM "+RetSqlName("AID")+" WHERE AID_FILIAL='"+xFilial("AID")+"' AND AID_NUMPV='"+cPedido+"' "
		TcSqlExec(cQuery)
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Libera bloqueio de regra ou de verba                                    ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If !__lPyme
			(cAliasSC5)->C5_BLQ := Space(Len(SC5->C5_BLQ))
		EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Liberacao de um pedido de venda                                         ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	Case nEvento == 3
		lLiberOk := .F.
		If !lAcumulado .And. lFinal
			MaAvLibPed((cAliasSC5)->C5_NUM,lLiber,lTransf,@lLiberOk,aRegSC6,,lEstLib,lAvCred,Nil,@nVlrCred)
		EndIf
		If ( lLiberOk )
			(cAliasSC5)->C5_LIBEROK := "S"
		EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Estorno da liberacao do pedido de venda                                 ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	Case nEvento == 4
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ PCO - Estorna os lancamentos de liberacao das contas orcamentarias ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If !Empty((cAliasSC5)->C5_LIBEROK)
			PcoDetLan("000103","02","MATA440",.T.)
		EndIf
		(cAliasSC5)->C5_LIBEROK := ""
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Preparacao da Nota Fiscal de Saida                                      ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	Case nEvento == 5
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Atualiza o Pedido de Venda                                              ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		lAtuSC5 := .T.

		SC6->(dbCommit())
		cQuery  := ""
		cQuery  += "SELECT COUNT(*) NUMERO FROM "+RetSqlName("SC6")+" "
		cQuery  += "WHERE C6_FILIAL='"+xFilial("SC6")+"' AND "
		cQuery  +=     "C6_NUM='"+cPedido+"' AND "
		cQuery  +=     "C6_BLQ<>'R ' AND "
		cQuery  +=     "C6_QTDVEN > C6_QTDENT AND "
		cQuery  +=     "D_E_L_E_T_=' '"
		cQuery := ChangeQuery(cQuery)

		dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),"MAAVALSC5",.F.,.T.)

		If ( NUMERO == 0 )
			lAtuSC5 := .F.
		EndIf
		dbCloseArea()
		dbSelectArea("SC5")
		dbSetOrder(1)
		If ( !lAtuSC5 )
			If ( MsSeek(xFilial("SC5")+cPedido) )
				RecLock("SC5",.F.)
				If cPaisLoc == "BRA"
					SC5->C5_NOTA  := SF2->F2_DOC
					SC5->C5_SERIE := SF2->F2_SERIE
				Else
					If IsRemito(1,"SF2->F2_TIPODOC")
						SC5->C5_NOTA  := "REMITO"
						SC5->C5_SERIE := "RXX"
					Else
						SC5->C5_NOTA  := SF2->F2_DOC
						If SC5->C5_SERIE <> "RXX"
							SC5->C5_SERIE := SF2->F2_SERIE
						Endif
					Endif
				Endif
				MsUnlock()
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Elimina o saldo do relacionamento de pedidos finalizados.³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If 	A410UsaAdi( SC5->C5_CONDPAG )
					FPedAdtRsd( "R", { SC5->C5_NUM } )
				EndIf
			EndIf
		EndIf
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Atualiza a tabela de fluxo de caixa do PV        ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		dbSelectArea("AID")
		cQuery := "DELETE FROM "+RetSqlName("AID")+" WHERE AID_FILIAL='"+xFilial("AID")+"' AND AID_NUMPV='"+cPedido+"' "
		TcSqlExec(cQuery)
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Estorno da Nota fiscal de Saida                                         ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	Case nEvento == 6
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Atualiza a tabela de fluxo de caixa do PV        ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		dbSelectArea("AID")
		cQuery := "DELETE FROM "+RetSqlName("AID")+" WHERE AID_FILIAL='"+xFilial("AID")+"' AND AID_NUMPV='"+cPedido+"' "
		TcSqlExec(cQuery)

		If cPaisLoc=="BRA"
			(cAliasSC5)->C5_LIBEROK := ""
			(cAliasSC5)->C5_SERIE   := ""
			(cAliasSC5)->C5_NOTA    := ""
		Else
			If Empty(SD2->D2_REMITO)
				(cAliasSC5)->C5_LIBEROK := ""
				(cAliasSC5)->C5_SERIE   := ""
				(cAliasSC5)->C5_NOTA    := ""
			Else
				If (cAliasSC5)->C5_SERIE == "RXX"
					(cAliasSC5)->C5_NOTA := "REMITO"
				Else
					(cAliasSC5)->C5_NOTA  := ""
					(cAliasSC5)->C5_SERIE := ""
				Endif
			Endif
		Endif
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Liberacao de regras ou verbas                                           ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	Case nEvento == 9

		dbSelectArea("SC6")
		dbSetOrder(1)
		cAliasSC6 := "QRYSC6"

		dbSelectArea('SC6')
		dbCommit() //-- Atualiza as gravacoes pendentes na tabela

		cQuery := "UPDATE "+RetSqlName("SC6")
		cQuery += " SET C6_BLOQUEI = '  ' "
		cQuery += " WHERE C6_FILIAL='"+xFilial('SC6')+"' AND "
		cQuery += " C6_NUM='"+SC5->C5_NUM+"' AND "
		cQuery += "(C6_BLOQUEI = '01' OR C6_BLOQUEI = '02') AND "
		cQuery += " D_E_L_E_T_ = ' '"

		TcSqlExec(cQuery)
		dbGoto(Recno()) //-- Reposiciona na tabela/registro atual somente para atualizar gravacoes pendentes

		Reclock("SC5",.F.)
		SC5->C5_BLQ :=Space(Len(SC5->C5_BLQ))
		MsUnlock()

		If ExistBlock("MALIBREG")
			ExecBlock("MALIBREG",.F.,.F.,{SC5->C5_NUM})
		EndIf

EndCase
RestArea(aArea)

//-- Ponto de entrada apos avaliacao dos eventos do cabecalho do Pedido de Vendas.
If ExistBlock("MAAVSC5")
	ExecBlock("MAAVSC5",.F.,.F.,{nEvento})
EndIf
Return(.T.)

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³MaAvalSC6 ³ Autor ³Eduardo Riera          ³ Data ³13.02.2000³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Rotina de avaliacao dos eventos do item do Pedido de Venda  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpC1: Alias da tabela dos itens do Pedido de Venda         ³±±
±±³          ³ExpN2: Codigo do Evento                                     ³±±
±±³          ³       [1] Implantacao do Pedido de Venda                   ³±±
±±³          ³       [2] Estorno  do Pedido de Venda                      ³±±
±±³          ³       [3] Liberacao do Pedido de Venda                     ³±±
±±³          ³       [4] Estorno da Liberacao do Pedido de Venda          ³±±
±±³          ³       [5] Preparacao da Nota Fiscal de Saida               ³±±
±±³          ³       [6] Estorno da Nota Fiscal de Saida                  ³±±
±±³          ³ExpC3: Alias do pedido de venda                             ³±±
±±³          ³ExpL4: Liberacao Parcial                                    ³±±
±±³          ³ExpL5: Transfere Locais                                     ³±±
±±³          ³ExpL6: Verifica se todos os itens foram liberados           ³±±
±±³          ³ExpL7: Verifica os residuos do pedido de venda              ³±±
±±³          ³ExpL8: Verifica se todos os itens foram faturados           ³±±
±±³          ³ExpL9: Atualiza somente os acumulados                       ³±±
±±³          ³ExpNA: Valor a ser adicionado ao limite de credito          ³±±
±±³          ³ExpCB: Alias do SD2 ( Uso Interno para otimizacao )         ³±±
±±³          ³ExpLC: Indica se esta o SC6 esta sendo baixado por un REMITO³±±
±±³          ³ExpCD: Moeda do pedido de venda ( opcional )                ³±±
±±³          ³ExpLE: Validacao regra de negocios pelo Televendas          ³±±
±±³          ³ExpLF: Validacao analise de credito para o pedido.          ³±±
±±³          ³ExpLG: Valida se considera estorno de todas lib. - Evento=2 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nenhum                                                      ³±±
±±³          ³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Esta rotina tem como objetivo atualizar os eventos vinculado³±±
±±³          ³ao item do pedido de venda.                                 ³±±
±±³          ³A) Atualizacao das tabelas complementares.                  ³±±
±±³          ³B) Atualizacao das informacoes complementares do PV         ³±±
±±³          ³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Materiais                                                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Michel M. ³29/03/07³8.11  ³Bops: 119212 - Corrigido nao-conformidade   ³±±
±±³          ³        ³      ³ao tentar Travar registro com o SA1 em EOF. ³±±
±±³          ³        ³      ³                                        	  ³±±
±±³Norbert W.³12/04/07³9.12  ³Bops: 122632 - Removido o codigo onde o cam-³±±
±±³          ³        ³      ³po C5_BLQ era limpo a cada validacao do SC6,³±±
±±³          ³        ³      ³eliminando o bloqueio de um item anterior.  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function MaAvalSC6(cAliasSC6,;
					nEvento,;
					cAliasSC5,;
					lLiber,;
					lTransf,;
					lLiberOk,;
					lResidOk,;
					lFaturOk,;
					lAcumulado,;
					nVlrCred,;
					cAliasSD2,;
					lRemito,;
					nMoeda,;
					lTLVReg,;
					lAvCred,;
					lTdsSqLb,;
					lBlqRegVer)

Local aArea    := GetArea(cAliasSC6)
Local aAreaSA1 := SA1->(GetArea())
Local aAreaSB2 := SB2->(GetArea())
Local aAreaSF4 := SF4->(GetArea())
Local aProdDesc:= {}
Local nQtdRese := 0
Local nQtdLib  := 0
Local nQtdLib2 := 0
Local nSldPed  := 0
Local nSldPed2 := 0
Local nMCusto  := 0

Local nSaveSX8 := GetSX8Len()
Local cReserva := ""
Local cPedido  := ""
Local cItemPV  := ""
Local cProduto := ""
Local cTipoPV  := ""
Local cTipLib  := ""
Local cEstado  := ""
Local cFunName := ""
Local cRet     := ""
Local cFilAB8  := ""
Local cFilSC9  := ""
Local dEmissao := Ctod("")
Local lContinua:= .T.
Local lCredito := .F.
Local lEstoque := .F.
Local lTipoAB7 := .F.
Local lResAut  := SuperGetMv("MV_RESAUT")
Local lTipRes  := SuperGetMv("MV_TIPRES")
Local lECommerce := SuperGetMV("MV_LJECOMM",,.F.)
Local lECCia 	:= lECommerce .AND. SuperGetMV("MV_LJECOMO",,.F.) .AND. (SC5->(ColumnPos("C5_PEDECOM")> 0 )) //E-commerce CiaShop Implantado?
Local lECCiaRes := lECCia .AND. !SuperGetMv("MV_RESAUT") .AND. SuperGetMv("MV_LJECOM0",.F., .F.) //Realiza reserva de estoque e-commerce CiaShop?

Local lBlqReg  := .F.
Local lProgEnt := .F.	//Indica se o Pedido de Venda foi gerado por uma Programação de Entrega

Local lExtB2DMOV   := (SB2->(ColumnPos("B2_DMOV")) > 0)
Local lExtB2HMOV   := (SB2->(ColumnPos("B2_HMOV")) > 0)

Local cSeq     := ""
Local lTrvSA1  := .T.
Local cQuery	:= ""
Local cAliasSC9 := ""

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Inicializa variaveis                                                    ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
DEFAULT cAliasSC5 := "SC5"
DEFAULT cAliasSC6 := "SC6"
DEFAULT cAliasSD2 := "SD2"
DEFAULT lLiber    := .F.
DEFAULT lTransf   := .F.
DEFAULT lAcumulado:= .F.
DEFAULT lRemito   := .F.
DEFAULT lTLVReg   := .F.
DEFAULT lAvCred   := .T.  // Variavel que controla analise de credito para o pedido.
DEFAULT lTdsSqLb  := .T.  // Considerar todas as sequencias de liberacao
DEFAULT lBlqRegVer:= .F.  // Se o pedido foi bloqueado por de Regra ou Verba, não libera nenhum item referente a este pedido.

If !xFilial("SC5")+(cAliasSC6)->C6_NUM==(cAliasSC5)->C5_FILIAL+(cAliasSC5)->C5_NUM .And.;
		!Empty((cAliasSC6)->C6_NUM)
	SC5->( DBSetOrder( 1 ) )
	SC5->( MsSeek(xFilial("SC5")+(cAliasSC6)->C6_NUM) )
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Inicializa a moeda do pedido                                           ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
DEFAULT nMoeda    := (cAliasSC5)->C5_MOEDA

cPedido  := (cAliasSC5)->C5_NUM
cItemPV  := (cAliasSC6)->C6_ITEM
cProduto := (cAliasSC6)->C6_PRODUTO
cTipoPV  := (cAliasSC5)->C5_TIPO
cTipLib  := (cAliasSC5)->C5_TIPLIB
dEmissao := (cAliasSC5)->C5_EMISSAO

Do Case
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Implantacao de um item do pedido de venda                               ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Case nEvento == 1

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Posiciona registros                                                     ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If !cTipoPV$'DB'
		SA1->( DBSetOrder( 1 ) )
		SA1->( MsSeek(xFilial("SA1")+(cAliasSC5)->C5_CLIENTE+(cAliasSC5)->C5_LOJACLI,.F.) )
	EndIf
	SF4->( DBSetOrder( 1 ) )
	SF4->( MsSeek(xFilial("SF4")+(cAliasSC6)->C6_TES) )
	
	SB2->( DBSetOrder( 1 ) )
	
	If SB2->( !MsSeek(xFilial("SB2")+(cAliasSC6)->C6_PRODUTO+(cAliasSC6)->C6_LOCAL) )
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Sempre criar o SB2 para otimizacao da Query do MATA461                  ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		CriaSB2((cAliasSC6)->C6_PRODUTO,(cAliasSC6)->C6_LOCAL)
	EndIf
	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Efetua travamento dos registros                                         ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lContinua .And. SF4->F4_DUPLIC=="S" .And. !cTipoPV$'DB'
		SA1->( DBSetOrder(1) )
		If ( lContinua := SA1->( MsSeek(xFilial("SA1")+(cAliasSC5)->C5_CLIENTE+(cAliasSC5)->C5_LOJACLI,.F.) ) )
			lTrvSA1 := IIf(cPaisLoc == "BRA" .And. lFATTRVSA1, ExecBlock("FATTRVSA1", .F., .F., {xFilial("SA1"), SA1->A1_COD, SA1->A1_LOJA}), .T.)
			If lTrvSA1
				lContinua := RecLock("SA1")
			EndIf
		EndIf
	EndIf
	
	If lContinua .And. SF4->F4_ESTOQUE=="S"
		lContinua := RecLock("SB2")
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Avalia se existe regra de negocio ou bloqueio para verificar verba      ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

	If !__lPyme
		
		cEstado := AllTrim(SuperGetMv("MV_ESTADO"))
		
		If !(FwIsInCallStack('A310Proc')) .And. (cAliasSC5)->C5_TIPO == 'N' .And. (ACN->(dbSeek(xFilial("ACN"))) .Or. cEstado == "AL")
			
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Verifica verba de venda caso nao houve bloqueio de regra de negocio     ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If !lAcumulado .Or. cEstado == "AL"
				nDescon   := (100 - ((cAliasSC6)->C6_PRCVEN / (cAliasSC6)->C6_PRUNIT) * 100 )  
				aProdDesc := {{(cAliasSC6)->C6_PRODUTO,(cAliasSC6)->C6_ITEM,(cAliasSC6)->C6_PRCVEN,(cAliasSC6)->C6_PRUNIT,nDescon,0,"",0,Empty((cAliasSC6)->C6_NFORI)}}

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Avalia se Existe Bloqueio de Regra                                      ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				
				cFunName := Upper(FunName())
				
				If	cFunName<>"TMKA271" .And.;	//SIGATMK
					cFunName<>"TMSA200"			//SIGATMS
					If cEstado == "AL" //Legislação somente para alagoas
						lBlqReg := BlPVLFat((cAliasSC5)->C5_CLIENTE,(cAliasSC5)->C5_LOJACLI,(cAliasSC5)->C5_BLQ=="1")
					EndIf
					If !lBlqReg
						lBlqReg := !ACN->(FtRegraNeg((cAliasSC5)->C5_CLIENTE,(cAliasSC5)->C5_LOJACLI,(cAliasSC5)->C5_TABELA,(cAliasSC5)->C5_CONDPAG,,@aProdDesc, .F., nil, .F. ))
					EndIf
				EndIf
				If lBlqReg .Or. lTLVReg
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³Avalia se existe Bloqueio de Venda                                      ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If aProdDesc[1,7] == "02"
						cRet := ACN->(FtVerbaVen(cAliasSC5,cAliasSC6,(cAliasSC5)->C5_CLIENTE,(cAliasSC5)->C5_LOJACLI,(cAliasSC5)->C5_VEND1,(cAliasSC6)->C6_PRODUTO, @aProdDesc[1],.T. ))
						If cRet <> "1"
							cRet := If(cRet == "3","1","2")
						Else
							cRet := "3"
						EndIf
					Else
						cRet := "1"
					EndIf
				Else
					cRet := "3"
				EndIf
				Do Case
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³Grava SC5 / SC6 bloqueados por Verba                                    ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					Case cRet == "2"
						RecLock("SC5", .F.)
						(cAliasSC5)->C5_BLQ := StrZero(2, Len(SC5->C5_BLQ))

						RecLock("SC6", .F.)
						(cAliasSC6)->C6_BLOQUEI :=  StrZero(2, Len(SC6->C6_BLOQUEI))
						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³Grava SC5 / SC6 bloqueado por Regra                                     ³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					Case cRet == "1"
						RecLock("SC5", .F.)
						(cAliasSC5)->C5_BLQ := StrZero(1, Len(SC5->C5_BLQ))

						RecLock("SC6", .F.)
						(cAliasSC6)->C6_BLOQUEI := StrZero(1, Len(SC6->C6_BLOQUEI))
					OtherWise
						RecLock("SC6", .F.)
						(cAliasSC6)->C6_BLOQUEI := Space(Len(SC6->C6_BLOQUEI))
				EndCase
			EndIf
		EndIf
	EndIf

	If lContinua
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Complemento da atualizacao no item do pedido de venda                  ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If !lAcumulado

			(cAliasSC6)->C6_FILIAL	:= xFilial("SC6")
			(cAliasSC6)->C6_NUM		:= (cAliasSC5)->C5_NUM
			(cAliasSC6)->C6_CLI		:= (cAliasSC5)->C5_CLIENTE
			(cAliasSC6)->C6_LOJA 	:= (cAliasSC5)->C5_LOJACLI
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Não grava C6_GERANF para pedido de vendas.³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If cPaisLoc <> "BRA".And. Empty((cAliasSC6)->C6_GERANF)
				(cAliasSC6)->C6_GERANF := If((cAliasSC5)->C5_TIPOREM$"01A","S","N")
			EndIf
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Atualiza as Tabela Auxiliares                                          ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Efetua amarracao com o projeto - SIGATEC                         ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			SC5->(FkCommit())
			SC6->(FkCommit())

			ABI->( dbSetOrder( 1 ) )
			If ABI->( MsSeek( xFilial( "ABI" ) + (cAliasSC6)->C6_PROJET + (cAliasSC6)->C6_ITPROJ ) )
				Reclock( "ABI", .F. )
				ABI->ABI_NUMPV  := (cAliasSC6)->C6_NUM
				ABI->ABI_ITEMPV := (cAliasSC6)->C6_ITEM
				ABI->( MsUnlock() )
			EndIf

			AB8->( DBSetOrder( 1 ) )
			If !Empty((cAliasSC6)->C6_NUMOS)
				If AB8->( MsSeek(xFilial("AB8")+(cAliasSC6)->C6_NUMOS) )
					RecLock("AB8")
					AB8->AB8_NUMPV := (cAliasSC5)->C5_NUM+SC6->C6_ITEM
					
					AB7->( DBSetOrder(1) )
					If AB7->( MsSeek(xFilial("AB7")+SubStr(SC6->C6_NUMOS,1,8)) )
						RecLock("AB7")
						AB7->AB7_TIPO := AtTipoAB7()
					EndIf
				EndIf
			EndIf
			If !Empty((cAliasSC6)->C6_NUMOSFA)
				If AB8->( MsSeek(xFilial("AB8")+(cAliasSC6)->C6_NUMOSFA ) )
					RecLock("AB8")
					AB8->AB8_NUMPVF := (cAliasSC5)->C5_NUM+SC6->C6_ITEM
					
					AB7->( DBSetOrder(1) )
					If AB7->( MsSeek(xFilial("AB7")+SubStr(SC6->C6_NUMOSFA,1,8)) )
						RecLock("AB7")
						AB7->AB7_TIPO := AtTipoAB7()
					EndIf
				EndIf
			EndIf
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Atualiza o status da OS ( AB6 )                                  ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If !Empty((cAliasSC6)->C6_NUMOS) .OR. !Empty((cAliasSC6)->C6_NUMOSFA)
				AB6->( DBSetOrder(1) )
				If AB6->( MsSeek(xFilial("AB6") + If( Empty( SubStr(SC6->C6_NUMOS,1,6) ),;
					SubStr(SC6->C6_NUMOSFA,1,6), SubStr(SC6->C6_NUMOS,1,6) ) ) )
					RecLock("AB6")
					AB6->AB6_STATUS := AtOsStatus( AB6->AB6_NUMOS )
				EndIf
			EndIf
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Atualiza Contratos de Parceria                                         ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If !Empty(SC6->C6_CONTRAT) .And. !Empty(SC6->C6_ITEMCON)
		
				ADB->( DBSetOrder(1) )
				If ADB->( MsSeek(xFilial("ADB")+SC6->C6_CONTRAT+SC6->C6_ITEMCON) )

					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³Tratamento especifico - SIGAAGR(UBS)               	³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If AliasInDic("NPN")
						NPN->(dbSetOrder(3))
						lContinua := !IsIncallStack("AGRA900") .And. !NPN->(dbSeek(xFilial("NPN")+SC6->(C6_NUM+C6_ITEM)))
					EndIf

					If lContinua
						RecLock("ADB")
						If Empty(ADB->ADB_PEDCOB) .And. SC6->C6_TES==ADB->ADB_TESCOB
							ADB->ADB_PEDCOB := SC6->C6_NUM
						Else
							ADB->ADB_QTDEMP += SC6->C6_QTDVEN
							If ADB->ADB_QTDEMP > ADB->ADB_QUANT
								ADB->ADB_QTDEMP -= SC6->C6_QTDVEN
								(cAliasSC6)->C6_CONTRAT := ""
								(cAliasSC6)->C6_ITEMCON := ""
							EndIf
						EndIf
						MsUnLock()
						
						ADA->( DBSetOrder(1) )
						If ADA->( MsSeek(xFilial("ADA")+SC6->C6_CONTRAT) )
							Ft400StatCt()
						EndIf
					Else
						lContinua := .T.
					EndIf
				EndIf
			EndIf
		EndIf
		
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Atualiza os Saldos Fisicos e Financeiros - SB2                         ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If !("S" $ (cAliasSC6)->C6_BLQ .Or. "R" $ (cAliasSC6)->C6_BLQ) //Se nao Bloqueado
			If SF4->F4_ESTOQUE == "S"
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Verificar se o material com lote deve ser reservado mesmo que nao haja  ³
				//³liberacao de pedido, a fim de garantir o lote na data do faturamento    ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If !lAcumulado

					If !Empty((cAliasSC6)->C6_RESERVA)
						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³Se a reserva estiver preenchida, verificar se e valida                  ³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						SC0->( dbSetOrder( 1 ) )
						If !SC0->( MsSeek( xFilial( "SC0" ) + (cAliasSC6)->C6_RESERVA + (cAliasSC6)->C6_PRODUTO) )
							(cAliasSC6)->C6_RESERVA := ""
							(cAliasSC6)->C6_QTDRESE := 0
						EndIf
					EndIf

					If lResAut .And. Empty((cAliasSC6)->C6_RESERVA) .And. Rastro((cAliasSC6)->C6_PRODUTO) .And. ;
						( (cAliasSC6)->C6_QTDVEN - (cAliasSC6)->C6_QTDEMP - (cAliasSC6)->C6_QTDENT > 0 )

						If !Empty((cAliasSC6)->C6_NUMLOTE) .Or. !Empty((cAliasSC6)->C6_LOTECTL)
							cReserva := CriaVar("C0_NUM")

							//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
							//³Verifica se a reserva sera feita pelo total da quantidade vendida³
							//³ou pelo saldo do lote.                                           ³
							//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
							If lTipRes
								nSaldo := ((cAliasSC6)->C6_QTDVEN  - (cAliasSC6)->C6_QTDENT)
							Else
								nSaldo   := SldAtuEst((cAliasSC6)->C6_PRODUTO,;
									(cAliasSC6)->C6_LOCAL,;
									(cAliasSC6)->C6_QTDVEN,;
									(cAliasSC6)->C6_LOTECTL,;
									(cAliasSC6)->C6_NUMLOTE,;
									(cAliasSC6)->C6_LOCALIZ,;
									(cAliasSC6)->C6_NUMSERI,;
									(cAliasSC6)->C6_RESERVA,;
									SF4->F4_PODER3<>"N" .Or. !Empty(SF4->F4_TESP3),;
									,;
									(cAliasSC6)->C6_PROJPMS,;
									(cAliasSC6)->C6_TASKPMS,;
									(cAliasSC6)->C6_SERVIC)
							Endif

							If Empty(cReserva)
								cReserva := NextNumero("SC0",1,"C0_NUM",.T.)
							Else
								While ( GetSX8Len() > nSaveSX8 )
									ConfirmSx8()
								EndDo
							EndIf
							If a430Reserva({1,"VD",(cAliasSC6)->C6_NUM,"",cFilAnt},cReserva,;
									(cAliasSC6)->C6_PRODUTO,;
									(cAliasSC6)->C6_LOCAL,;
									nSaldo,;
									{(cAliasSC6)->C6_NUMLOTE,(cAliasSC6)->C6_LOTECTL,(cAliasSC6)->C6_LOCALIZ,(cAliasSC6)->C6_NUMSERI})

								(cAliasSC6)->C6_RESERVA := cReserva

							EndIf
						EndIf
					EndIf
				EndIf
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Atualiza previsoes de saida de material                                 ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				nSldPed := Max((cAliasSC6)->C6_QTDVEN-(cAliasSC6)->C6_QTDENT-(cAliasSC6)->C6_QTDEMP,0)
				nSldPed2:= SB1->(ConvUm(SB2->B2_COD,nSldPed,nSldPed2,2))
				FatAtuEmpN("+")


				RecLock("SB2")
				SB2->B2_QPEDVEN += nSldPed
				SB2->B2_QPEDVE2 += nSldPed2
				
				//atualização de campos usados na mensagem de atualização de estoque
				If lExtB2DMOV
					SB2->B2_DMOV := dDataBase
				EndIf
			
				If lExtB2HMOV
					SB2->B2_HMOV := Time() 
				EndIf					
				
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Tratamento para Reserva de material                  ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If !lAcumulado
					If !Empty((cAliasSC6)->C6_RESERVA)
						If !cTipoPV$"CIP"
						
							SC0->( DBSetOrder(1) )
							If SC0->( MsSeek(xFilial("SC0")+(cAliasSC6)->C6_RESERVA+(cAliasSC6)->C6_PRODUTO+(cAliasSC6)->C6_LOCAL) )
								If !((cAliasSC6)->C6_NUMLOTE<>SC0->C0_NUMLOTE   .Or.;
									(cAliasSC6)->C6_LOTECTL<>SC0->C0_LOTECTL  .Or.;
									(cAliasSC6)->C6_LOCALIZ<>SC0->C0_LOCALIZ  .Or.;
									(cAliasSC6)->C6_NUMSERI<>SC0->C0_NUMSERI )
									RecLock("SC0")
									nQtdRese := Min(SC0->C0_QUANT,((cAliasSC6)->C6_QTDVEN - (cAliasSC6)->C6_QTDENT))
									SC0->C0_QUANT  -= nQtdRese
									SC0->C0_TIPO   := "PD"
									SC0->C0_QTDPED += nQtdRese
								EndIf
							Endif
							//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
							//³ Atualiza o campo de qtd.reservada do Pedido de Venda ³
							//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
							(cAliasSC6)->C6_QTDRESE += nQtdRese
							//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
							//³Nao deve atualizar a Quantidade em Pedido de Venda quando houver Reserva³
							//³pois neste caso o estoque ja esta liberado.                             ³
							//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
							SB2->B2_QPEDVEN -= nQtdRese
							SB2->B2_QPEDVE2 -= ConvUM(SB2->B2_COD,nQtdRese,0,2)
							
							//atualização de campos usados na mensagem de atualização de estoque
							If lExtB2DMOV
								SB2->B2_DMOV := dDataBase
							EndIf
						
							If lExtB2HMOV
								SB2->B2_HMOV := Time() 
							EndIf							
							
						Else
							(cAliasSC6)->C6_RESERVA := ""
						EndIf
					Else
						(cAliasSC6)->C6_RESERVA := ""
					EndIf
				Else
				
					SB2->B2_QPEDVEN -= (cAliasSC6)->C6_QTDRESE
					SB2->B2_QPEDVE2 -= ConvUM(SB2->B2_COD,(cAliasSC6)->C6_QTDRESE,0,2)
					
					//atualização de campos usados na mensagem de atualização de estoque
					If lExtB2DMOV
						SB2->B2_DMOV := dDataBase
					EndIf
				
					If lExtB2HMOV
						SB2->B2_HMOV := Time() 
					EndIf								
				EndIf
			EndIf
		EndIf
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Atualiza o Saldo de Pedidos - SA1                                       ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If SF4->F4_DUPLIC == "S" .And. !cTipoPV$"DB"
			nSldPed := Max((cAliasSC6)->C6_QTDVEN-(cAliasSC6)->C6_QTDENT-(cAliasSC6)->C6_QTDEMP,0)
			If nSldPed > 0 .And. !AllTrim((cAliasSC6)->C6_BLQ)$"RS"
				nMCusto :=  If(SA1->A1_MOEDALC > 0,SA1->A1_MOEDALC, Val(SuperGetMv("MV_MCUSTO")))
				If lTrvSA1
					SA1->A1_SALPED += xMoeda(nSldPed*(cAliasSC6)->C6_PRCVEN,nMoeda,nMCusto,dEmissao)
				EndIf
			EndIf
		EndIf
		If !lAcumulado .And. !("S" $ (cAliasSC6)->C6_BLQ .Or. "R" $ (cAliasSC6)->C6_BLQ)
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Verifica a necessidade de Liberacao do Item                             ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			SC5->(FkCommit())
			SC6->(FkCommit())
			MaAvalSC6(cAliasSC6,3,cAliasSC5,lLiber,lTransf,Nil,Nil,Nil,Nil,@nVlrCred,,,,,lAvCred,Nil,lBlqRegVer)
		EndIf
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Verificacao dos acumulados do SC5                                       ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If ( SC6->C6_QTDVEN > (SC6->C6_QTDEMP+SC6->C6_QTDENT) .And. AllTrim(SC6->C6_BLQ)<>"R")
		lLiberOk := .F.
	EndIf
	If (! "R" $ SC6->C6_BLQ )
		lResidOk := .F.
	EndIf
	If ( SC6->C6_QTDVEN > SC6->C6_QTDENT .And. AllTrim(SC6->C6_BLQ)<>"R" ) .Or. ( SF4->F4_QTDZERO=="1" .And. !lAcumulado )
		lFaturOk := .T.
	EndIf
	If !lAcumulado
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Grava os lancamentos nas contas orcamentarias SIGAPCO    ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		PcoDetLan("000100","01","MATA410")
	EndIf
	SC5->(FkCommit())
	SC6->(FkCommit())
	SC9->(FkCommit())
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Estorno de um item do pedido de venda                                   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Case nEvento == 2

	If !__lPyme

		If !Empty(ACM->(LastRec()))

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Busca movimentacao das verbas                                           ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			cQuery := "SELECT ACM_OPERA, ACM.R_E_C_N_O_ RECACM, ACL.R_E_C_N_O_ RECACL FROM "
			cQuery += RetSqlName("ACM")+ " ACM, "
			cQuery += RetSqlName("ACL")+ " ACL  "
			cQuery += " WHERE "
			cQuery += "ACM_FILIAL = '"+xFilial("ACM")+"' AND "
			cQuery += "ACM_NUMPED = '"+(cAliasSC6)->C6_NUM+"' AND "
			cQuery += "ACM_ITEPED = '"+(cAliasSC6)->C6_ITEM+"' AND "
			cQuery += "ACM.D_E_L_E_T_ = ' ' AND "
			cQuery += "ACL_FILIAL = '"+xFilial("ACL")+"' AND "
			cQuery += "((ACL_CODPRO = '"+cProduto+"' AND ACL_CODVER = ACM_CODVER ) OR "
			cQuery += "(ACL_CODPRO = '"+Space(Len(SB1->B1_COD))+"' AND ACL_CODVER = ACM_CODVER )) AND "
			cQuery += "ACL.D_E_L_E_T_ = ' ' "

			cQuery := ChangeQuery(cQuery)

			dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),"QRYACL",.T.,.T.)

			While QRYACL->(!Eof())

				ACL->(MsGoto(QRYACL->RECACL))
				ACM->(MsGoto(QRYACL->RECACM))

				Do Case

					Case QRYACL->ACM_OPERA == "D"
						RecLock("ACL",.F.)
							ACL->ACL_SALDO += ACM->ACM_VALOR
						MsUnlock()
					Case QRYACL->ACM_OPERA == "C"
						RecLock("ACL",.F.)
							ACL->ACL_SALDO -= ACM->ACM_VALOR
						MsUnlock()
				EndCase

				RecLock("ACM",.F.)
					dbDelete()
				MsUnlock()

				QRYACL->(dbSkip())

			EndDo

			(cAliasSC6)->C6_BLOQUEI := Space(Len(SC6->C6_BLOQUEI))

			QRYACL->( DbCloseArea() )
			DbSelectArea("SC6")

		EndIf
	Endif


	If !cTipoPV$'DB'
		SA1->( DBSetOrder(1) )
		SA1->( MsSeek(xFilial("SA1")+(cAliasSC6)->C6_CLI+(cAliasSC6)->C6_LOJA,.F.) )
	EndIf
	
	SF4->( DBSetOrder(1) )
	SF4->( MsSeek(xFilial("SF4")+(cAliasSC6)->C6_TES) )

	SB2->( DBSetOrder(1) )
	If SB2->( !MsSeek(xFilial("SB2")+(cAliasSC6)->C6_PRODUTO+(cAliasSC6)->C6_LOCAL) )
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Sempre criar o SB2 para otimizacao da Query do MATA461                  ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		CriaSB2((cAliasSC6)->C6_PRODUTO,(cAliasSC6)->C6_LOCAL )
	EndIf
	If lTdsSqLb
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Verifica a necessidade de estorno da liberacao                          ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		MaAvalSC6(cAliasSC6,4,cAliasSC5,lLiber,Nil,Nil,Nil,Nil,Nil,@nVlrCred)
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Efetua travamento dos registros                                         ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lContinua .And. SF4->F4_DUPLIC=="S" .And. !cTipoPV$'DB'
		lTrvSA1 := IIf(cPaisLoc == "BRA" .And. lFATTRVSA1, ExecBlock("FATTRVSA1", .F., .F., {xFilial("SA1"), SA1->A1_COD, SA1->A1_LOJA}), .T.)
		If lTrvSA1
			lContinua := RecLock("SA1")
		EndIf
	EndIf
	
	If lContinua .And. SF4->F4_ESTOQUE=="S"
		lContinua := RecLock("SB2")
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Estorna as Tabela Auxiliares                                           ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lContinua
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Estorna o Saldo de Pedidos - SA1                                        ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If ( SF4->F4_DUPLIC=="S" .And. !cTipoPV$"DB" )
			SA1->( DBSetOrder(1) )
			If SA1->( MsSeek(xFilial("SA1")+(cAliasSC6)->C6_CLI+(cAliasSC6)->C6_LOJA,.F.) )
				nSldPed := Max((cAliasSC6)->C6_QTDVEN-(cAliasSC6)->C6_QTDENT-(cAliasSC6)->C6_QTDEMP,0)
				If ( nSldPed > 0 .And. !AllTrim((cAliasSC6)->C6_BLQ)$"RS" )
					nMCusto :=  If(SA1->A1_MOEDALC > 0,SA1->A1_MOEDALC, Val(SuperGetMv("MV_MCUSTO")))
					If lTrvSA1
						SA1->A1_SALPED -= xMoeda(nSldPed*(cAliasSC6)->C6_PRCVEN,nMoeda,nMCusto,dEmissao)
					EndIf
				EndIf
			EndIf
		EndIf
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Atualiza os Saldos Fisicos e Financeiros - SB2                         ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If !("S"$(cAliasSC6)->C6_BLQ .Or. "R"$(cAliasSC6)->C6_BLQ)
			If SF4->F4_ESTOQUE == "S"
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Tratamento para Reserva de material                  ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If !Empty((cAliasSC6)->C6_RESERVA)

					SC0->( dbSetOrder(1) )
					If SC0->( MsSeek(xFilial("SC0")+(cAliasSC6)->C6_RESERVA+(cAliasSC6)->C6_PRODUTO+(cAliasSC6)->C6_LOCAL) )
						RecLock("SC0")
						SC0->C0_TIPO   := If(SC0->C0_QTDPED==0,"VD","PD")
						SC0->C0_QUANT  += SC6->C6_QTDRESE
						SC0->C0_QTDPED -= SC6->C6_QTDRESE
					EndIf

					SB2->B2_QPEDVEN += (cAliasSC6)->C6_QTDRESE
					SB2->B2_QPEDVE2 += ConvUM(SB2->B2_COD,(cAliasSC6)->C6_QTDRESE,0,2)
					
					//atualização de campos usados na mensagem de atualização de estoque
					If lExtB2DMOV
						SB2->B2_DMOV := dDataBase
					EndIf
				
					If lExtB2HMOV
						SB2->B2_HMOV := Time() 
					EndIf							

					(cAliasSC6)->C6_QTDRESE := 0
					If SuperGetMv("MV_DELRES")
						(cAliasSC6)->C6_RESERVA := ""
						a430Reserva({3,SC0->C0_TIPO,SC0->C0_DOCRES,SC0->C0_SOLICIT,SC0->C0_FILRES},;
							SC0->C0_NUM,;
							SC0->C0_PRODUTO,;
							SC0->C0_LOCAL,;
							SC0->C0_QUANT,;
							{SC0->C0_NUMLOTE,;
							SC0->C0_LOTECTL,;
							SC0->C0_LOCALIZ,;
							SC0->C0_NUMSERI})
					EndIf
				EndIf

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Atualiza previsoes de saida de material                                 ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				nSldPed := Max((cAliasSC6)->C6_QTDVEN-(cAliasSC6)->C6_QTDENT-(cAliasSC6)->C6_QTDEMP,0)
				nSldPed2:= SB1->(ConvUm(SB2->B2_COD,nSldPed,nSldPed2,2))

				FatAtuEmpN("-")	 
				RecLock("SB2")
				SB2->B2_QPEDVEN -= nSldPed
				SB2->B2_QPEDVE2 -= nSldPed2
			EndIf
		EndIf
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Atualiza Contratos de Parceria                                         ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If !Empty(SC6->C6_CONTRAT) .And. !Empty(SC6->C6_ITEMCON)
		ADB->( DBSetOrder(1) )
		If ADB->( MsSeek(xFilial("ADB")+SC6->C6_CONTRAT+SC6->C6_ITEMCON) )
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Tratamento especifico - SIGAAGR(UBS)               	³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If AliasInDic("NPN")
				NPN->(dbSetOrder(3))
				lContinua := !IsIncallStack("AGRA900") .And. !NPN->(dbSeek(xFilial("NPN")+SC6->(C6_NUM+C6_ITEM)))
			EndIf

			If lContinua
				RecLock("ADB")
				If !Empty(ADB->ADB_PEDCOB) .And. SC6->C6_NUM==ADB->ADB_PEDCOB
					ADB->ADB_PEDCOB := ""
				Else
					ADB->ADB_QTDEMP -= SC6->C6_QTDVEN
				EndIf
				MsUnLock()
			
				ADA->( dbSetOrder(1) )
				If ADA->( MsSeek(xFilial("ADA")+SC6->C6_CONTRAT) )
					Ft400StatCt()
				EndIf
			EndIf
		EndIf
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Estorna amarracao com a Ordem de Servico - SIGATEC               ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If ( !Empty((cAliasSC6)->C6_NUMOS) .Or. !Empty((cAliasSC6)->C6_NUMOSFA) )
		lTipoAb7 := .T.
		
		cFilAB8 := xFilial("AB8")
		
		AB8->( DBSetOrder(1) )
		If ( AB8->( MsSeek(cFilAB8+SC6->C6_NUMOSFA) ) .And. !Empty(SC6->C6_NUMOSFA))
			RecLock("AB8")
			AB8->AB8_NUMPVF := ""
		EndIf
		If ( AB8->( MsSeek(cFilAB8+SC6->C6_NUMOS) ) .And. !Empty(SC6->C6_NUMOS))
			RecLock("AB8")
			AB8->AB8_NUMPV := ""
		EndIf
		If AB8->( MsSeek(cFilAB8+SubStr(SC6->C6_NUMOS,1,8)) )
			While ( AB8->( !Eof() ) .And. cFilAB8 == AB8->AB8_FILIAL .And.;
					AB8->AB8_NUMOS+AB8->AB8_ITEM == SubStr(SC6->C6_NUMOS,1,8) )
				If ( !Empty(AB8->AB8_NUMPV) .Or. !Empty(AB8->AB8_NUMPVF) )
					lTipoAb7 := .F.
				EndIf
				AB8->( DBSkip() )
			EndDo
		EndIf
		If ( lTipoAb7 )
			
			AB7->( DBSetOrder(1) )

			If !Empty( SubStr(SC6->C6_NUMOS,1,8))
				If AB7->( MsSeek(xFilial("AB7")+SubStr(SC6->C6_NUMOS,1,8)) )
					RecLock("AB7")
					AB7->AB7_TIPO := AtTipoAB7()
				EndIf
			EndIf

			If !Empty( SubStr(SC6->C6_NUMOSFA,1,8))
				If AB7->( MsSeek(xFilial("AB7")+SubStr(SC6->C6_NUMOSFA,1,8)) )
					RecLock("AB7")
					AB7->AB7_TIPO := AtTipoAB7()
				EndIf
			EndIf
			If !Empty((cAliasSC6)->C6_NUMOS) .OR. !Empty((cAliasSC6)->C6_NUMOSFA)
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Atualiza o status da OS ( AB6 )                                  ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				AB6->( DBSetOrder(1) )
				If AB6-> ( MsSeek(xFilial("AB6") + If( Empty( SubStr(SC6->C6_NUMOS,1,6) ),;
						SubStr(SC6->C6_NUMOSFA,1,6), SubStr(SC6->C6_NUMOS,1,6) ) ) )
					RecLock("AB6")
					AB6->AB6_STATUS := AtOsStatus( AB6->AB6_NUMOS )
				EndIf
			EndIf
		EndIf
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Estorna amarracao com o projeto - SIGATEC                        ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	ABI->( dbSetOrder( 3 ) )
	If ABI->( MsSeek( xFilial( "ABI" ) + (cAliasSC6)->C6_NUM + (cAliasSC6)->C6_ITEM ) )
		Reclock( "ABI", .F. )
		ABI->ABI_NUMPV  := Space( Len( ABI->ABI_NUMPV ) )
		ABI->ABI_ITEMPV := Space( Len( ABI->ABI_ITEMPV ) )
		ABI->( MsUnlock() )
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Liberacao de um item do pedido de venda                                 ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Case nEvento == 3
	nQtdLib  := (cAliasSC6)->C6_QTDLIB
	nQtdLib2 := If( Empty( (cAliasSC6)->C6_QTDLIB2 ), Nil, (cAliasSC6)->C6_QTDLIB2 )
	If nQtdLib > 0 .Or. IIf(cPaisLoc == "BRA",; 
		(cTipoPV$"IP" .Or. (cTipoPV$"C" .And. (cAliasSC5)->C5_TPCOMPL == "1")),;
		 cTipoPV$"CIP") .Or.  MaTesSel((cAliasSC6)->C6_TES)
		//Libera os itens do pedido, somente se não existir nenhum item bloqueado por Regra ou Verba
		If cTipLib<>"2" .And. !lBlqRegVer
			MaLibDoFat(0,@nQtdLib,@lCredito,@lEstoque,lAvCred,.T.,lLiber,lTransf,Nil,Nil,Nil,Nil,Nil,@nVlrCred,@nQtdLib2)
		EndIf
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Estorno de um item do pedido de venda                                   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Case nEvento == 4
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Estornar as liberacoes efetuadas desde que nao possuam NFS              ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	cFilSC9 := xFilial("SC9")
	
	//Verifica se os registros na SC9 existem, caso a liberação por total do pedido
	SC9->( DBSetOrder(1) )
	SC9->( MsSeek(cFilSC9+cPedido+cItemPV) ) 

	If __oEstLibP == Nil
		cQuery := " SELECT SC9.R_E_C_N_O_ RECSC9, C9_SD3SEQ"
		cQuery += " FROM " + RetSqlName("SC9") + " SC9 "
		cQuery += " WHERE C9_FILIAL = ? "
		cQuery += " AND C9_PEDIDO = ? "
		cQuery += " AND C9_ITEM = ? "
		cQuery += " AND C9_PRODUTO = ? "
		cQuery += " AND C9_BLCRED NOT IN ('10','ZZ') " 
		cQuery += " AND C9_BLEST NOT IN ('10','ZZ') " 
		cQuery += " AND C9_REMITO = ' ' "
		cQuery += " AND SC9.D_E_L_E_T_ = ' ' "

		cQuery	:= ChangeQuery(cQuery)
		__oEstLibP := FwExecStatement():New(cQuery)
	EndIf

	__oEstLibP:SetString(1, cFilSC9)
	__oEstLibP:SetString(2, cPedido)
	__oEstLibP:SetString(3, cItemPv)
	__oEstLibP:SetString(4, cProduto)

	cAliasSC9 := __oEstLibP:OpenAlias()

	While (cAliasSC9)->(!Eof())
		//Efetua o estorno das movimentacoes internas
		MaTrfLocal((cAliasSC6)->C6_PRODUTO, , , , (cAliasSC6)->C6_NUM, .T., @CSeq, (cAliasSC9)->C9_SD3SEQ)

		//Efetua o estorno do itens de pedido de venda liberados
		a460Estorna(.T., , @nVlrCred, cTipLib, (cAliasSC9)->RECSC9)

		//PCO - Estorna os lancamentos de liberacao das contas orcamentarias
		PcoDetLan("000103","01","MATA440",.T.)

		(cAliasSC9)->(DBSkip())
	EndDo

	(cAliasSC9)->(DBCloseArea())

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Preparacao da Nota Fiscal de Saida                                      ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Case nEvento == 5
	If lAcumulado
		RecLock("SC6",.F.)
	EndIf
	If lRemito .Or. Empty( (cAliasSD2)->D2_REMITO )
		(cAliasSC6)->C6_QTDENT  += (cAliasSD2)->D2_QUANT
		(cAliasSC6)->C6_QTDENT2 += (cAliasSD2)->D2_QTSEGUM
		If !lAcumulado
			(cAliasSC6)->C6_QTDEMP  -= (cAliasSD2)->D2_QUANT
			(cAliasSC6)->C6_QTDEMP2 := Max( (cAliasSC6)->C6_QTDEMP2 - (cAliasSD2)->D2_QTSEGUM, 0 )
		EndIf
	Endif
	If !lRemito
		(cAliasSC6)->C6_NOTA   := (cAliasSD2)->D2_DOC
		(cAliasSC6)->C6_SERIE  := (cAliasSD2)->D2_SERIE
		(cAliasSC6)->C6_DATFAT := (cAliasSD2)->D2_EMISSAO
		If (cAliasSC6)->C6_QTDRESE == 0
			(cAliasSC6)->C6_RESERVA := ""
		EndIf

		//------------------------------------------------------------------------------
		// Se o Pedido de Venda foi gerado por uma Programação de Entrega (MATA412),
		// grava o número do Documento de Saída no item da Programação
		//------------------------------------------------------------------------------
		
		
		SD0->(DbSetOrder(3))	//D0_FILIAL + D0_PEDIDO + D0_CLIENTE + D0_LOJA
		If ( SD0->( MsSeek( xFilial("SD0") + (cAliasSC6)->C6_NUM ) ) )

			lProgEnt := .T.

			SDX->(DbSetOrder(1))	//DX_FILIAL + DX_NUMENT + DX_ITEM + DX_PRODUTO
			If ( SDX->( MsSeek( xFilial("SDX") + SD0->D0_NUMENT + AllTrim((cAliasSC6)->C6_ITEM) + (cAliasSC6)->C6_PRODUTO ) ) )
				RecLock( "SDX", .F. )
				SDX->DX_NOTA := (cAliasSD2)->D2_DOC
			EndIf

		EndIf
		
	Else
		(cAliasSC6)->C6_NOTA   := "REMITO"
		(cAliasSC6)->C6_SERIE  := (cAliasSD2)->D2_SERIE
	Endif
	If lAcumulado
		MsUnLock()
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Estorno da Nota fiscal de Saida                                         ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Case nEvento == 6
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Posiciona registros                                                     ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If !cTipoPV $ 'DB'
		If !xFilial("SA1")+(cAliasSC6)->C6_CLI+(cAliasSC6)->C6_LOJA ==;
				SA1->A1_FILIAL+SA1->A1_COD+SA1->A1_LOJA
			
			SA1->( DBSetOrder(1) )
			SA1->( MsSeek(xFilial("SA1")+(cAliasSC6)->C6_CLI+(cAliasSC6)->C6_LOJA) )
		EndIf
		lTrvSA1 := IIf(cPaisLoc == "BRA" .And. lFATTRVSA1, ExecBlock("FATTRVSA1", .F., .F., {xFilial("SA1"), SA1->A1_COD, SA1->A1_LOJA}), .T.)
		If lTrvSA1
			lContinua := RecLock("SA1")
		EndIf
	EndIf
	If !(xFilial("SC5")==SC5->C5_FILIAL .And.;
			SC5->C5_NUM==(cAliasSC6)->C6_NUM)
		
		SC5->( DBSetOrder(1) )
		SC5->( MsSeek(xFilial("SC5")+(cAliasSC6)->C6_NUM) )
	EndIf
	If !xFilial("SF4")+SC6->C6_TES == SF4->F4_FILIAL+SF4->F4_CODIGO
		SF4->( dbSetOrder(1) )
		SF4->( MsSeek(xFilial("SF4")+SC6->C6_TES) )
	EndIf
	
	SB2->( dbSetOrder(1) )
	If SB2->( !MsSeek(xFilial("SB2")+(cAliasSC6)->C6_PRODUTO+(cAliasSC6)->C6_LOCAL) )
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Sempre criar o SB2 para otimizacao da Query do MATA461                  ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		CriaSB2((cAliasSC6)->C6_PRODUTO,(cAliasSC6)->C6_LOCAL )
	EndIf
	If lContinua
		(cAliasSC6)->C6_NOTA  := ""
		(cAliasSC6)->C6_SERIE := ""
		If "R" $ (cAliasSC6)->C6_BLQ
			MaAvalSC6(cAliasSC6,2,cAliasSC5,lLiber,lTransf,lLiberOk,lResidOk,lFaturOk,lAcumulado,@nVlrCred,cAliasSD2,lRemito,nMoeda)
			(cAliasSC6)->C6_BLQ := ""
			MaAvalSC6(cAliasSC6,1,cAliasSC5,lLiber,lTransf,lLiberOk,lResidOk,lFaturOk,lAcumulado,@nVlrCred,cAliasSD2,lRemito,nMoeda)
		EndIf
		If lRemito .Or. Empty( SD2->D2_REMITO )
			(cAliasSC6)->C6_QTDENT  -= SD2->D2_QUANT
			(cAliasSC6)->C6_QTDENT2 := Max( (cAliasSC6)->C6_QTDENT2 - SD2->D2_QTSEGUM, 0 )
		Else
			If !Empty(SD2->D2_REMITO)
				(cAliasSC6)->C6_NOTA  := "REMITO"
				(cAliasSC6)->C6_SERIE := SD2->D2_SERIREM
			Endif
		EndIf
		If (cAliasSC6)->C6_QTDENT == 0 .Or. !lRemito
			(cAliasSC6)->C6_DATFAT := Ctod("")
		EndIf
		If ( SF4->F4_DUPLIC == "S" .And. !SC5->C5_TIPO$"DB" .And. !AllTrim((cAliasSC6)->C6_BLQ)$"RS" ) .And. (!lRemito .And. Empty(SD2->D2_REMITO))
			nMCusto :=  If(SA1->A1_MOEDALC > 0,SA1->A1_MOEDALC, Val(SuperGetMv("MV_MCUSTO")))
			nSldPed := SD2->D2_QUANT
			nSldPed := If(nSldPed>(SC6->C6_QTDVEN-SC6->C6_QTDEMP+nSldPed-SC6->C6_QTDENT),SC6->C6_QTDVEN-SC6->C6_QTDEMP+nSldPed-SC6->C6_QTDENT,nSldPed)
			If lTrvSA1
				SA1->A1_SALPED += xMoeda(nSldPed*(cAliasSC6)->C6_PRCVEN,SC5->C5_MOEDA,nMCusto,SC5->C5_EMISSAO)
			EndIf
		EndIf
		If ( SF4->F4_ESTOQUE == "S" ) .And. ( lRemito .Or. Empty( SD2->D2_REMITO ) ) .And. !AllTrim((cAliasSC6)->C6_BLQ)$"RS"

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Atualiza previsoes de saida de material                                 ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			nSldPed := Max((cAliasSC6)->C6_QTDVEN-((cAliasSC6)->C6_QTDENT+SD2->D2_QUANT)-(cAliasSC6)->C6_QTDEMP,0)
			nSldPed := Max((cAliasSC6)->C6_QTDVEN-(cAliasSC6)->C6_QTDENT-(cAliasSC6)->C6_QTDEMP,0)-nSldPed

			nSldPed2:= SB1->(ConvUm(SB2->B2_COD,nSldPed,nSldPed2,2))

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³                Notas sobre o campo C6_OP                               ³
			//³ 01 - OP Gerada pelo MATA650                                            ³
			//³ 02 - Liberacao de PV bloqueada ( Sem OP )                              ³
			//³ 03 - Liberacao de PV bloqueada ( Item 01 )                             ³
			//³ 04 - Bloqueio de credito pelo MATA650                                  ³
			//³ 05 - OP nao gerada pois ha qtde em Estoque                             ³
			//³ 06 - Liberacao de PV liberada  ( Item 05 )                             ³
			//³ 07 - Liberacao de credito efetuada / Estoque pendente/bloqueada        ³
			//³ 08 - Liberacao de estoque efetuada ( item 01 )                         ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If SC6->C6_QTDVEN-SC6->C6_QTDEMP-SC6->C6_QTDENT > 0
				Do Case
					Case SC6->C6_OP == "02"
						SC6->C6_OP     := ""
					Case SC6->C6_OP == "08"
						SC6->C6_OP     := "01"
					Case SC6->C6_OP == "06"
						SC6->C6_OP     := "05"
				EndCase
			EndIf

			//Se não for ecommerce ciaShop ou ecommerce sem reserva, volta saldo para quantidade de pedido
			If  (!SC5->(ColumnPos("C5_PEDECOM")) > 0 .OR. Empty(SC5->C5_PEDECOM))  .OR. !lECCiaRes
				RecLock("SB2")
				SB2->B2_QPEDVEN += nSldPed
				SB2->B2_QPEDVE2 += nSldPed2
				
				//atualização de campos usados na mensagem de atualização de estoque
				If lExtB2DMOV
					SB2->B2_DMOV := dDataBase
				EndIf
			
				If lExtB2HMOV
					SB2->B2_HMOV := Time() 
				EndIf							
			EndIf

		EndIf
	EndIf

	//------------------------------------------------------------------------
	// Tratativa para reconhecer se o pedido gerado foi criado pela rotina de 
	// Programação de Entrega (MATA412) para realizar o estorno corretamente
	// dos itens do pedido e atualizar o campo D0_STATUS.
	//------------------------------------------------------------------------
	If !lRemito
		SD0->(DbSetOrder(3))//D0_FILIAL + D0_PEDIDO + D0_CLIENTE + D0_LOJA
		If ( SD0->( MsSeek( xFilial("SD0") + (cAliasSC6)->C6_NUM ) ) ) //Busca movimentacao na tabela de Programacao de Entrega (Cabecalho).
		
			If (cAliasSC6)->C6_QTDENT == 0 //Caso houver o estorno total dos itens do pedido de venda, realiza a tratativa abaixo.

				SDX->(DbSetOrder(1))//DX_FILIAL + DX_NUMENT + DX_ITEM + DX_PRODUTO
				If ( SDX->( MsSeek( xFilial("SDX") + SD0->D0_NUMENT + AllTrim((cAliasSC6)->C6_ITEM) + (cAliasSC6)->C6_PRODUTO) ) ) //Busca movimentacao na tabela de itens Programacao de Entrega.

					//Limpa o campo Nota Fiscal do item do pedido na Programacao de Entrega, pois ja foi realizado o estorno total dos itens do pedido de venda.
					RecLock( "SDX", .F. )
						SDX->DX_NOTA := ""
					SDX->(MsUnlock())

					If ( SDX->( MsSeek( xFilial("SDX") + SD0->D0_NUMENT ) ) ) //Busca todas as movimentacoes da tabela de itens da Programacao de Entrega atraves do numero do Pedido

						While SDX->( !Eof() ) .AND. SD0->D0_FILIAL + SD0->D0_NUMENT == xFilial() + SDX->DX_NUMENT 

							If !Empty(SDX->DX_NOTA)//Caso ainda houver pedido de venda com o campo Nota Fiscal preenchido, atualiza o status da Programacao de entrega através da função Ma412Stat().
								lProgEnt := .T.
							EndIf

							SDX->( DBSkip() )

						EndDo
					EndIf
				EndIf

				If !lProgEnt //Atualiza o status da Programacao de Entrega para Pedido Gerado, caso nao houver mais pedido faturado.
					
					RecLock( "SD0", .F. )
						SD0->D0_STATUS := "01" 
					SD0->(MsUnlock())

				EndIf
			Else
				lProgEnt := .T.
			EndIf
		EndIf
	EndIf

EndCase

//--------------------------------------------------------------------------
// Se for Programação de entrega
//--------------------------------------------------------------------------
If ( lProgEnt )
	//Atualiza Status da Programação de entrega
	Ma412Stat( SC6->C6_NUM )
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Restaura a entrada da rotina                                            ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
RestArea(aAreaSF4)
RestArea(aAreaSA1)
RestArea(aAreaSB2)
RestArea(aArea)
					
Return(.T.)
/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³MaAvalSC9 ³ Autor ³Eduardo Riera          ³ Data ³20.02.2000³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Rotina de avaliacao dos eventos dos itens liberados do pedi-³±±
±±³          ³do de Venda ( SC9 )                                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpC1: Alias da tabela dos itens liberados do Pedido de Ven-³±±
±±³          ³       da                                                   ³±±
±±³          ³ExpN2: Codigo do Evento                                     ³±±
±±³          ³       [1] Implantacao do SC9                               ³±±
±±³          ³       [2] Estorno do SC9                                   ³±±
±±³          ³       [3] Liberacao de Credito do SC9                      ³±±
±±³          ³       [4] Estorno da Liberacao de Credito do SC9           ³±±
±±³          ³       [5] Liberacao de Estoque do SC9                      ³±±
±±³          ³       [6] Estorno da Liberacao de Estoque do SC9           ³±±
±±³          ³       [7] Montagem de Carga do SC9                         ³±±
±±³          ³       [8] Estorno da Montagem de Carga do SC9              ³±±
±±³          ³       [9] Liberacao WMS do SC9                             ³±±
±±³          ³       [10]Estorno WMS do SC9                               ³±±
±±³          ³       [11]Geracao do Documento de Saida                    ³±±
±±³          ³       [12]Estorno do Documento de Saida                    ³±±
±±³          ³ExpL3: Array da SldPorLote somente da Localizacao Fisica    ³±±
±±³          ³ExpL4: Array da SldPorLote (Somente para WMS)               ³±±
±±³          ³ExpL5: Atualiza somente os acumulados (OPC)                 ³±±
±±³          ³       DEFAULT .F.                                          ³±±
±±³          ³ExpL6: Indica se o estorno sera precedido de uma exclusao   ³±±
±±³          ³       DEFAULT .T. (OPC)                                    ³±±
±±³			 ³ExpL7: Indica se Atualizará Empenhos				          ³±±
±±³			 ³ExpL8: Array com os dados da roteirizacao (OPC)             ³±±
±±³			 ³       [1] Codigo da Rota             			          ³±±
±±³			 ³       [2] Codigo da Zona             			          ³±±
±±³			 ³       [3] Codigo do Setor             			          ³±±
±±³			 ³       [4] Motorista                  			          ³±±
±±³			 ³       [5] Caminhao                    			          ³±±
±±³			 ³       [6] Ajudante 1                 			          ³±±
±±³			 ³       [7] Ajudante 2                  			          ³±±
±±³			 ³       [8] Ajudante 3                  			          ³±±
±±³			 ³       [9] Hora chegada                			          ³±±
±±³			 ³       [10] Time Service                			          ³±±
±±³			 ³       [11] Data chegada                			          ³±±
±±³			 ³       [12] Data saida                			          ³±±
±±³			 ³       [13] Hora de inicio de entrega    			          ³±±
±±³          ³ExpN9: Valor a ser adicionado ao limite de credito          ³±±
±±³          ³ExpLA: Indica se esta o SC9 esta sendo baixado por un REMITO³±±
±±³          ³ExpLB: Item de Divergencia								  ³±±
±±³          ³ExpLC: Ordem de Separacao									  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nenhum                                                      ³±±
±±³          ³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Esta rotina tem como objetivo atualizar os eventos vinculado³±±
±±³          ³ao item do pedido de venda.                                 ³±±
±±³          ³A) Atualizacao das tabelas complementares.                  ³±±
±±³          ³B) Atualizacao das informacoes complementares do PV         ³±±
±±³          ³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Observacao³Bloqueios do SC9                                            ³±±
±±³          ³                                                            ³±±
±±³          ³C9_BLCRED: 01 - Bloqueio de Credito por Valor               ³±±
±±³          ³           04 - Vencto do Limite de Credito                 ³±±
±±³          ³           05 - Bloqueio de Credito por Estorno             ³±±
±±³          ³           06 - Bloqueio de Credito por Risco               ³±±
±±³          ³           09 - Rejeicao de Credito                         ³±±
±±³          ³                                                            ³±±
±±³          ³C9_BLEST:  02 - Bloqueio de Estoque                         ³±±
±±³          ³           03 - Bloqueio Manual de Estoque                  ³±±
±±³          ³                                                            ³±±
±±³          ³C9_BLWMS:  01 - Bloqueio de Enderecamento do WMS/Somente SB2³±±
±±³          ³           02 - Bloqueio de Enderecamento do WMS            ³±±
±±³          ³           03 - Bloqueio de WMS - Externo                   ³±±
±±³          ³           05 - Liberacao para Bloqueio 01                  ³±±
±±³          ³           06 - Liberacao para Bloqueio 02                  ³±±
±±³          ³           07 - Liberacao para Bloqueio 03                  ³±±
±±³          ³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Materiais                                                  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function MaAvalSC9(cAliasSC9,nEvento,aLocaliz,aSaldos,lAcumulado,lDeleta,lAtuEmp,aRotas,nVlrCred,lRemito,lDeletaDCF,cIdDCF,lGeraDCF,cFilCar,lItemDv,cOrdSep)

Local aArea     := GetArea(cAliasSC9)
Local aAreaSF4  := SF4->(GetArea())
Local aAreaDAI  := {}
Local nSldPed   := 0
Local nSldPed2  := 0
Local nX        := 0
Local lContinua := .T.
Local lBlqCred  := !Empty((cAliasSC9)->C9_BLCRED)
Local lBlqEst   := !(Empty((cAliasSC9)->C9_BLCRED) .And. Empty((cAliasSC9)->C9_BLEST))
Local lFaturado := ((cAliasSC9)->C9_BLCRED=="10" .And. (cAliasSC9)->C9_BLEST=="10") .Or. ((cAliasSC9)->C9_BLCRED=="ZZ" .And. (cAliasSC9)->C9_BLEST=="ZZ")
Local lDelRes   := .F.
Local lFreteEmb := .F.
Local nMCusto   := 0
Local nValAv    := 0
//-- Variaveis utilizadas pela funcao wmsexedcf
Local lRetEmpPE := lAtuEmp
Local lWmsNew   := SuperGetMV("MV_WMSNEW",.F.,.F.)
Local lWmsSaas  := FindFunction("WMSSaasHas") .And. WMSSaasHas()
Local lAtuSA1	:= Nil
Local cFilSC5	:= ""
Local cFilSC6	:= ""
Local cFilSA1	:= ""
Local cFilSF4	:= ""
Local lTrvSA1   := .T.
Local lRskSalPed:= .F.

lAtuEmp:=If(lAtuEmp==NIL,.T.,lAtuEmp)

DEFAULT lAcumulado := .F.
DEFAULT lDeleta    := .T.
DEFAULT aRotas     := Array(15)
DEFAULT nVlrCred   := 0
DEFAULT lRemito    := .F.
DEFAULT lDeletaDCF := .T.
DEFAULT cIdDCF     := ''
DEFAULT lGeraDCF   := .T.
DEFAULT cFilCar    := xFilial("DAI")
DEFAULT lItemDv	   := .F.
DEFAULT cOrdSep	   := ""

If lMTValAvC == Nil 
	lMTValAvC := ExistBlock("MTVALAVC")
EndIf

If lMTVALEMP == Nil
	lMTVALEMP := ExistBlock("MTVALEMP")
EndIf

lAtuSA1	:= IIF(lMTValAvC .Or. !(IsInCallStack("MaPvlNfs2")), .T., .F.)

//Este ponto de entrada é utilizado pelo Nestlé para não gerar empenho para os pedidos, mesmo liberando
//o estoque. Antes era utilizado o serviço WMS para não gerar empenho, sem usar o WMS para fazer a separação,
//porém devido a evolução do WMS este conceito foi alterado, pois quantdo é integrado ao WMS o empenho é gerado na separação WMS
If lMTVALEMP
   lRetEmpPE := ExecBlock("MTVALEMP",.F.,.F.,{nEvento,cAliasSC9,lAtuEmp})
   lAtuEmp   := Iif(ValType(lRetEmpPE)=="L",lRetEmpPE,lAtuEmp)
EndIf

If lBlqCred .and. cPaisLoc <> 'BRA' .and. IsInCallStack('mata215') .and. (cAliasSC9)->C9_REMITO <> ' '
   lBlqCred := .F.
EndIf

lRskIsAct  := IIf(lRskIsAct == Nil, FindFunction( "RskIsActive" ), lRskIsAct)
lRskSalPed := lRskIsAct .And. RskIsActive() .And. RskCdPgPay((cAliasSC9)->C9_PEDIDO)
Do Case
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Implantacao de um item liberado do pedido de venda                      ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Case nEvento == 1
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Posiciona registros                                                     ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	cFilSC5 := xFilial("SC5")
	If !(cFilSC5==SC5->C5_FILIAL .And. SC5->C5_NUM==(cAliasSC9)->C9_PEDIDO)
		SC5->(dbSetOrder(1))
		SC5->(MsSeek(cFilSC5+(cAliasSC9)->C9_PEDIDO))
	EndIf
	cFilSC6 := xFilial("SC6")
	If !(cFilSC6==SC6->C6_FILIAL .And.;
			SC6->C6_NUM==(cAliasSC9)->C9_PEDIDO .And.;
			SC6->C6_ITEM==(cAliasSC9)->C9_ITEM .And.;
			SC6->C6_PRODUTO==(cAliasSC9)->C9_PRODUTO)
		SC6->(dbSetOrder(1))
		SC6->(MsSeek(cFilSC6+(cAliasSC9)->C9_PEDIDO+(cAliasSC9)->C9_ITEM+(cAliasSC9)->C9_PRODUTO))
	EndIf
	SF4->(dbSetOrder(1))
	SF4->(MsSeek(xFilial("SF4")+SC6->C6_TES))
	If lContinua .And. SF4->F4_DUPLIC=="S" .And. !SC5->C5_TIPO$'DB'
		SA1->(dbSetOrder(1))
		SA1->(MsSeek(xFilial("SA1")+(cAliasSC9)->C9_CLIENTE+(cAliasSC9)->C9_LOJA))
		lTrvSA1 := IIf(cPaisLoc == "BRA" .And. lFATTRVSA1, ExecBlock("FATTRVSA1", .F., .F., {xFilial("SA1"), SA1->A1_COD, SA1->A1_LOJA}), .T.)
		If lTrvSA1
			lContinua := RecLock("SA1")
		EndIf
	EndIf
	If lContinua .And. SF4->F4_ESTOQUE=="S"
		SB2->(dbSetOrder(1))
		If SB2->(MsSeek(xFilial("SB2")+SC6->C6_PRODUTO+(cAliasSC9)->C9_LOCAL))
	   		lContinua := RecLock("SB2")
		Else
	   		HELP(" ",1,"NOFOUNDSB2")
	   		lContinua := .F.
	 	EndIf
	EndIf
	If lContinua .And. !lAcumulado
		lContinua := RecLock("SC5")
	EndIf
	If lAcumulado
		lContinua := RecLock("SC6")
	EndIf
	If lContinua .And. (SF4->F4_PODER3=='D' .Or. !Empty((cAliasSC9)->C9_IDENTB6)) .And. !lAcumulado
		SB6->(dbSetOrder(3))
		If SB6->(MsSeek(xFilial("SB6")+(cAliasSC9)->C9_IDENTB6+SC6->C6_PRODUTO+"R",.F.))
			lContinua := RecLock("SB6")
		Else
			lContinua := .F.
		EndIf
	EndIf
	If lContinua
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Atualiza os dados do item do pedido de venda                            ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		RecLock("SC6")
		SC6->C6_QTDEMP  += (cAliasSC9)->C9_QTDLIB
		SC6->C6_QTDEMP2 += (cAliasSC9)->C9_QTDLIB2
		If IsInCallStack('ACDA100') .and. len(aLocaliz) > 0
			SC6->C6_LOCALIZ := 	aLocaliz [1,3]
			SC6->C6_NUMSERI	:=  aLocaliz [1,4]
		EndIf
		If !lAcumulado
			If IsInCallStack('WMSA332') 
				SC6->C6_QTDLIB := Max(SC6->C6_QTDLIB - (cAliasSC9)->C9_QTDLIB, 0)
			Else
				IF !lItemDv
					SC6->C6_QTDLIB -= (cAliasSC9)->C9_QTDLIB			
				EndIf
			EndIf
			SC6->C6_QTDLIB2 := Max( SC6->C6_QTDLIB2 - (cAliasSC9)->C9_QTDLIB2, 0 )
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Libera o arquivo Poder de Terceiros                     ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If ( SF4->F4_PODER3=="D" .Or. !Empty((cAliasSC9)->C9_IDENTB6) )
				SB6->B6_QULIB += (cAliasSC9)->C9_QTDLIB
			EndIf
		EndIf
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Atualiza a Liberacao de Credito                                         ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		MaAvalSC9(cAliasSC9,3,,,lAcumulado,Nil,Nil,Nil,@nVlrCred,,,,lGeraDCF)
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Atualiza a Liberacao de Estoque                                         ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		MaAvalSC9(cAliasSC9,5,aLocaliz,,lAcumulado,Nil,Nil,Nil,@nVlrCred,,,,lGeraDCF,,lItemDv,cOrdSep)
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Estorno de um item liberado do pedido de venda                          ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Case nEvento == 2
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Posiciona registros                                                     ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	cFilSC5 := xFilial("SC5")
	If !(cFilSC5==SC5->C5_FILIAL .And. SC5->C5_NUM==(cAliasSC9)->C9_PEDIDO)
		SC5->(dbSetOrder(1))
		SC5->(MsSeek(cFilSC5+(cAliasSC9)->C9_PEDIDO))
	EndIf
	cFilSC6 := xFilial("SC6")
	If !(xFilial("SC6")==SC6->C6_FILIAL .And.;
			SC6->C6_NUM==(cAliasSC9)->C9_PEDIDO .And.;
			SC6->C6_ITEM==(cAliasSC9)->C9_ITEM .And.;
			SC6->C6_PRODUTO==(cAliasSC9)->C9_PRODUTO)
		SC6->(dbSetOrder(1))
		SC6->(MsSeek(cFilSC6+(cAliasSC9)->C9_PEDIDO+(cAliasSC9)->C9_ITEM+(cAliasSC9)->C9_PRODUTO))
	EndIf
	SF4->(dbSetOrder(1))
	SF4->(MsSeek(xFilial("SF4")+SC6->C6_TES))
	If lContinua .And. SF4->F4_DUPLIC=="S" .And. !SC5->C5_TIPO$'DB'
		SA1->(dbSetOrder(1))
		SA1->(MsSeek(xFilial("SA1")+(cAliasSC9)->C9_CLIENTE+(cAliasSC9)->C9_LOJA))
		lTrvSA1 := IIf(cPaisLoc == "BRA" .And. lFATTRVSA1, ExecBlock("FATTRVSA1", .F., .F., {xFilial("SA1"), SA1->A1_COD, SA1->A1_LOJA}), .T.)
		If lTrvSA1
			lContinua := RecLock("SA1")
		EndIf
	EndIf
	If lContinua .And. SF4->F4_ESTOQUE=="S"
		SB2->(dbSetOrder(1))
		SB2->(MsSeek(xFilial("SB2")+SC6->C6_PRODUTO+(cAliasSC9)->C9_LOCAL))
		lContinua := RecLock("SB2")
	EndIf
	If lContinua .And. !lAcumulado
		lContinua := RecLock("SC5")
	EndIf
	If lContinua .And. !lAcumulado
		lContinua := RecLock("SC6")
	EndIf
	If lContinua .And. !lAcumulado
		lContinua := RecLock(cAliasSC9)
	EndIf
	If lContinua .And. ( SF4->F4_PODER3=='D' .Or. !Empty((cAliasSC9)->C9_IDENTB6)) .And. !lAcumulado
		SB6->(dbSetOrder(3))
		If SB6->(MsSeek(xFilial("SB6")+(cAliasSC9)->C9_IDENTB6+SC6->C6_PRODUTO+"R",.F.))
			lContinua := RecLock("SB6")
		Else
			lContinua := .F.
		EndIf
	EndIf
	If lContinua
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Verifica se eh um item de liberacao ou um item faturado      ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If !lFaturado
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Apaga marca de Pedido totalmente liberado (SC5->C5_LIBEROK) ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If lDeleta .And. !lAcumulado
				MaAvalSC5("SC5",4)
			EndIf
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Efetua o Estorno de Estoque                             ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			MaAvalSC9(cAliasSC9,6,,,lAcumulado,,lAtuEmp,Nil,@nVlrCred,,,,lGeraDCF)
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Efetua o estorno de credito                                  ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			MaAvalSC9(cAliasSC9,4,,,lAcumulado,,lAtuEmp,Nil,@nVlrCred,,,,lGeraDCF)
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Estorna valor no arquivo Poder de Terceiros             ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If !lAcumulado
				If ( SF4->F4_PODER3=="D" .Or. !Empty((cAliasSC9)->C9_IDENTB6) )
					SB6->B6_QULIB -= (cAliasSC9)->C9_QTDLIB
				EndIf
			EndIf
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Estorna qtde empenhada e nao faturada                   ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			SC6->C6_QTDEMP  -= (cAliasSC9)->C9_QTDLIB
			SC6->C6_QTDEMP2 := Max( SC6->C6_QTDEMP2 - (cAliasSC9)->C9_QTDLIB2, 0 )
			If lDeletaDCF .And. IntWms((cAliasSC9)->C9_PRODUTO) .And. !Empty((cAliasSC9)->C9_SERVIC) .And. SC6->C6_QTDVEN > 0
				lContinua := WmsUndoPed((cAliasSC9)->(Recno()))
			EndIf
		EndIf
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Liberacao de Credito de um item liberado do pedido de venda             ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Case nEvento == 3
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Posiciona registros                                                     ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	cFilSC5 := xFilial("SC5")
	If !(cFilSC5==SC5->C5_FILIAL .And. SC5->C5_NUM==(cAliasSC9)->C9_PEDIDO)
		SC5->(dbSetOrder(1))
		SC5->(MsSeek(cFilSC5+(cAliasSC9)->C9_PEDIDO))
	EndIf
	cFilSC6 := xFilial("SC6")
	If !(cFilSC6==SC6->C6_FILIAL .And.;
			SC6->C6_NUM==(cAliasSC9)->C9_PEDIDO .And.;
			SC6->C6_ITEM==(cAliasSC9)->C9_ITEM .And.;
			SC6->C6_PRODUTO==(cAliasSC9)->C9_PRODUTO )
		SC6->(dbSetOrder(1))
		SC6->(MsSeek(cFilSC6+(cAliasSC9)->C9_PEDIDO+(cAliasSC9)->C9_ITEM+(cAliasSC9)->C9_PRODUTO))
	EndIf
	SF4->(dbSetOrder(1))
	SF4->(MsSeek(xFilial("SF4")+SC6->C6_TES))
	If lContinua .And. SF4->F4_DUPLIC=="S" .And. !SC5->C5_TIPO$'DB'
		SA1->(dbSetOrder(1))
		SA1->(MsSeek(xFilial("SA1")+(cAliasSC9)->C9_CLIENTE+(cAliasSC9)->C9_LOJA))
		lTrvSA1 := IIf(cPaisLoc == "BRA" .And. lFATTRVSA1, ExecBlock("FATTRVSA1", .F., .F., {xFilial("SA1"), SA1->A1_COD, SA1->A1_LOJA}), .T.)
		If lTrvSA1
			lContinua := RecLock("SA1")
		EndIf
	EndIf
	If lAcumulado
		lContinua := RecLock("SC6")
	EndIf
	If lContinua .And. !lAcumulado
		lContinua := RecLock(cAliasSC9)
	EndIf
	If lContinua
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Marca os pedidos liberados por credito para filtro na geracao da OP    ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If !lBlqCred .And. !lAcumulado
			If ( Empty( SC6->C6_OP ) .Or. SC6->C6_OP == "02" .Or. SC6->C6_OP == "04") .And. SF4->F4_ESTOQUE=="S"
				SC6->C6_OP := "07"
			EndIf
			If SC6->C6_OP == "04"
				SC6->C6_OP := ""
			EndIf
		EndIf
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Atualiza a Liberacao de Credito                                         ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If SF4->F4_DUPLIC=="S" .And. !SC5->C5_TIPO$"DB" .And. !AllTrim(SC6->C6_BLQ)$"RS"
			nMCusto  :=  If(SA1->A1_MOEDALC > 0,SA1->A1_MOEDALC, Val(SuperGetMv("MV_MCUSTO")))
			If lMTValAvC
				nValAv	:=	ExecBLock("MTValAvC",.F.,.F.,{'MAAVALSC9',(cAliasSC9)->C9_QTDLIB*(cAliasSC9)->C9_PRCVEN,nEvento})
			Else
				nValAv	:=	(cAliasSC9)->C9_QTDLIB*(cAliasSC9)->C9_PRCVEN
			Endif

			nSldLib  := xMoeda(nValAV,SC5->C5_MOEDA,nMCusto,(cAliasSC9)->C9_DATALIB)

			If !lRskSalPed
				If !lBlqCred
					If lTrvSA1
						SA1->A1_SALPEDL += nSldLib
					EndIf
					nVlrCred -= nValAV
				Else
					If lTrvSA1
						SA1->A1_SALPEDB += nSldLib
					EndIf
				EndIf
			EndIf
			nSldPed := (cAliasSC9)->C9_QTDLIB
			nSldPed := If(nSldPed>(SC6->C6_QTDVEN-SC6->C6_QTDEMP+nSldPed-SC6->C6_QTDENT),SC6->C6_QTDVEN-SC6->C6_QTDEMP+nSldPed-SC6->C6_QTDENT,nSldPed)
			If lTrvSA1
				SA1->A1_SALPED -= xMoeda(nSldPed*(cAliasSC9)->C9_PRCVEN,SC5->C5_MOEDA,nMCusto,SC5->C5_EMISSAO)
			EndIf
		EndIf
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Estorno da Liberacao de Credito de um item liberado do pedido de venda  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Case nEvento == 4
	If !lFaturado
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Posiciona registros                                                     ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		cFilSC5 := xFilial("SC5")
		If !(cFilSC5==SC5->C5_FILIAL .And. SC5->C5_NUM==(cAliasSC9)->C9_PEDIDO)
			SC5->(dbSetOrder(1))
			SC5->(MsSeek(cFilSC5+(cAliasSC9)->C9_PEDIDO))
		EndIf
		cFilSC6 := xFilial("SC6")
		If !(cFilSC6==SC6->C6_FILIAL .And.;
				SC6->C6_NUM==(cAliasSC9)->C9_PEDIDO .And.;
				SC6->C6_ITEM==(cAliasSC9)->C9_ITEM .And.;
				SC6->C6_PRODUTO==(cAliasSC9)->C9_PRODUTO)
			SC6->(dbSetOrder(1))
			SC6->(MsSeek(cFilSC6+(cAliasSC9)->C9_PEDIDO+(cAliasSC9)->C9_ITEM+(cAliasSC9)->C9_PRODUTO))
		EndIf
		SF4->(dbSetOrder(1))
		SF4->(MsSeek(xFilial("SF4")+SC6->C6_TES))
		If lContinua .And. SF4->F4_DUPLIC=="S" .And. !SC5->C5_TIPO$'DB' .And. (lBlqEst.Or.SF4->F4_ESTOQUE=='N')
			SA1->(dbSetOrder(1))
			SA1->(MsSeek(xFilial("SA1")+(cAliasSC9)->C9_CLIENTE+(cAliasSC9)->C9_LOJA))
			lTrvSA1 := IIf(cPaisLoc == "BRA" .And. lFATTRVSA1, ExecBlock("FATTRVSA1", .F., .F., {xFilial("SA1"), SA1->A1_COD, SA1->A1_LOJA}), .T.)
			If lTrvSA1
				lContinua := RecLock("SA1")
			EndIf
		EndIf
		If lContinua .And. !lAcumulado
			lContinua := RecLock("SC5")
		EndIf
		If lContinua .And. !lAcumulado
			lContinua := RecLock("SC6")
		EndIf
		If lContinua .And. !lAcumulado
			lContinua := RecLock(cAliasSC9)
		EndIf
		If lContinua

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Desmarca os pedidos liberados por credito para filtro na geracao da OP ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If !lAcumulado
				If SC6->C6_OP == "07"
					SC6->C6_OP := ""
				EndIf
			EndIf
			If !SC5->C5_TIPO$"DB" .And. SF4->F4_DUPLIC == "S"  .And. !AllTrim(SC6->C6_BLQ)$"RS"
				nMCusto  :=  If(SA1->A1_MOEDALC > 0,SA1->A1_MOEDALC, Val(SuperGetMv("MV_MCUSTO")))
				If lMTValAvC
					nValAv	:=	ExecBLock("MTValAvC",.F.,.F.,{'MAAVALSC9',(cAliasSC9)->C9_QTDLIB*(cAliasSC9)->C9_PRCVEN,nEvento})
				Else
					nValAv	:=	(cAliasSC9)->C9_QTDLIB*(cAliasSC9)->C9_PRCVEN
				Endif

				nSldLib  := xMoeda(nValAV,SC5->C5_MOEDA,nMCusto,(cAliasSC9)->C9_DATALIB)

				If !lRskSalPed
					If !lBlqCred
						If lTrvSA1
							SA1->A1_SALPEDL -= nSldLib
						EndIf
						nVlrCred += nValAV
					Else
						If lTrvSA1
							SA1->A1_SALPEDB -= nSldLib
						EndIf
					EndIf
				EndIf
				nSldPed := (cAliasSC9)->C9_QTDLIB
				nSldPed := If(nSldPed>(SC6->C6_QTDVEN-SC6->C6_QTDEMP+nSldPed-SC6->C6_QTDENT),SC6->C6_QTDVEN-SC6->C6_QTDEMP+nSldPed-SC6->C6_QTDENT,nSldPed)
				If lTrvSA1
					SA1->A1_SALPED += xMoeda(nSldPed*(cAliasSC9)->C9_PRCVEN,SC5->C5_MOEDA,nMCusto,SC5->C5_EMISSAO)
				EndIf
				(cAliasSC9)->C9_BLCRED := "05" //Bloqueado Manualmente de Credito"
			EndIf
		EndIf
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Liberacao de estoque de um item liberado do pedido de venda             ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Case nEvento == 5
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Posiciona registros                                                     ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	cFilSC5 := xFilial("SC5")
	If !(cFilSC5==SC5->C5_FILIAL .And. SC5->C5_NUM==(cAliasSC9)->C9_PEDIDO)
		SC5->(dbSetOrder(1))
		SC5->(MsSeek(cFilSC5+(cAliasSC9)->C9_PEDIDO))
	EndIf
	cFilSC6 := xFilial("SC6")
	If !(cFilSC6==SC6->C6_FILIAL .And.;
			SC6->C6_NUM==(cAliasSC9)->C9_PEDIDO .And.;
			SC6->C6_ITEM==(cAliasSC9)->C9_ITEM .And.;
			SC6->C6_PRODUTO==(cAliasSC9)->C9_PRODUTO)
		SC6->(dbSetOrder(1))
		SC6->(MsSeek(cFilSC6+(cAliasSC9)->C9_PEDIDO+(cAliasSC9)->C9_ITEM+(cAliasSC9)->C9_PRODUTO))
	EndIf
	SF4->(dbSetOrder(1))
	SF4->(MsSeek(xFilial("SF4")+SC6->C6_TES))
	If lContinua .And. SF4->F4_ESTOQUE=="S"
		SB2->(dbSetOrder(1))
		SB2->(MsSeek(xFilial("SB2")+(cAliasSC9)->C9_PRODUTO+SC6->C6_LOCAL))
		lContinua := RecLock("SB2")
	EndIf
	If lContinua .And. !lAcumulado
		lContinua := RecLock("SC5")
	EndIf
	If lAcumulado
		lContinua := RecLock("SC6")
	EndIf
	If lContinua .And. !lAcumulado
		lContinua := RecLock(cAliasSC9)
	EndIf
	If lContinua
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Atualiza a Liberacao de Estoque                                         ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If ( SF4->F4_ESTOQUE == "S" )
			If ( !lBlqCred .And. !lBlqEst )
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Gera o registro do WMS no DCF com base no pedido de Vendas              ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If IntWms((cAliasSC9)->C9_PRODUTO) .And. !Empty((cAliasSC9)->C9_SERVIC)
					If !lAcumulado
						// Atualiza empenho sempre que for novo WMS ou quando não gerar DCF, que é o caso em que
						// se está estornando o faturamento para manter o pedido com status "Apto a faturar".
						// Nessa situação, o saldo deverá retornar para doca empenhado. Assim, ao realizar um
						// novo faturamento, a baixa de estoque acontecerá a partir do endereço correto.
						lAtuEmp := lWmsNew .Or. (cAliasSC9)->C9_BLWMS != "01" //!lGeraDCF
						If lGeraDCF
							//-- 1=no Pedido;2=na Montagem da Carga;3=na Unitizacao da Carga
							If SC5->C5_GERAWMS == '1' .And. !((cAliasSC9)->C9_BLWMS == '05') .And. SC6->C6_QTDVEN > 0
							   WmsIntPed((cAliasSC9)->(Recno()))
							EndIf
						EndIf
					Else
						lAtuEmp := lWmsNew .Or. (cAliasSC9)->C9_BLWMS == '05'
					EndIf
				EndIf
				// Quando controla WMS Saas o valor do lGeraDCF corresponde ao controle da convergencia
				If lWmsSaas .And. FindFunction("WMSSIntPdv") .And. lGeraDCF
					WMSSIntPdv(SC9->C9_PEDIDO,SC5->C5_CLIENT,SC5->C5_LOJAENT,dDatabase,SC5->C5_EMISSAO,SC5->C5_TRANSP, SC9->C9_CARGA, SC9->(Recno()))
				EndIf
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Atualiza as reservas para faturamento                                   ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If !Empty((cAliasSC9)->C9_RESERVA)
					If !lAcumulado
						SC0->(dbSetOrder(1))
						If SC0->(MsSeek(xFilial("SC0")+(cAliasSC9)->C9_RESERVA+(cAliasSC9)->C9_PRODUTO+SC6->C6_LOCAL))
							//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
							//³Tratamento dos Lotes da Reserva                                         ³
							//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
							GravaEmp(SC0->C0_PRODUTO,;    //1
								SC6->C6_LOCAL,;      //2
								(cAliasSC9)->C9_QTDLIB,;   //3
								Nil,  ;        //4
								SC0->C0_LOTECTL,; //5
								SC0->C0_NUMLOTE,; //6
								SC0->C0_LOCALIZ,; //7
								SC0->C0_NUMSERI,; //8
								Nil,;          //9
								Nil,;          //10
								SC6->C6_RESERVA,; //11
								Nil,;          //12
								"SC0",;           //13
								Nil,;          //14
								Nil,;          //15
								Nil,;          //16
								.T.,;          //17
								.F.,;          //18
								.T.,;          //19
								.F.,;          //20
								Nil,;           //21
								IIf(!IntWms(SC0->C0_PRODUTO),!Empty(SC0->C0_LOTECTL+SC0->C0_NUMLOTE).Or.Localiza( SC0->C0_PRODUTO ,.T.),!Empty(SC0->C0_LOTECTL+SC0->C0_NUMLOTE+SC0->C0_LOCALIZ+SC0->C0_NUMSERI))) //22
							RecLock("SB2")
						EndIf
					Else
						RecLock("SB2")
						SB2->B2_QPEDVEN -= (cAliasSC9)->C9_QTDRESE
						SB2->B2_QPEDVE2 -= ConvUM(SB2->B2_COD,(cAliasSC9)->C9_QTDRESE,0,2)
					EndIf
				EndIf
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Reserva o saldo em Estoque                                              ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				
				// Realiza a gravação de empenho quando não existir divergência por item
				If !lItemDv 
					For nX := 1 To Len(aLocaliz)
						GravaEmp((cAliasSC9)->C9_PRODUTO,;     //01
							(cAliasSC9)->C9_LOCAL,;       	//02
							aLocaliz[nX,5],;     			//03
							aLocaliz[nX,6],;     			//04
							(cAliasSC9)->C9_LOTECTL,;     	//05
							(cAliasSC9)->C9_NUMLOTE,;     	//06
							aLocaliz[nX,3],;     			//07
							aLocaliz[nX,4],;     			//08
							Nil,;             				//09
							(cAliasSC9)->C9_SEQUEN,;    	//10
							(cAliasSC9)->C9_PEDIDO,;       //11
							(cAliasSC9)->C9_ITEM,;         //12
							"SC6",;              			//13
							Nil,;             				//14
							Nil,;             				//15
							Nil,;             				//16
							.F.,;             				//17
							.F.,;             				//18
							.T.,;             				//19
							.F.,;             				//20
							!Empty((cAliasSC9)->C9_LOTECTL+(cAliasSC9)->C9_NUMLOTE),;//21
							lAtuEmp,; //22
							(lAtuEmp .And. !lAcumulado)) //23
						RecLock("SB2")
					Next nX
				EndIf
				nSldPed  := Max(Min(SC6->C6_QTDVEN-SC6->C6_QTDENT-SC6->C6_QTDEMP+(cAliasSC9)->C9_QTDLIB,(cAliasSC9)->C9_QTDLIB),0)
				nSldPed2 := SB1->(ConvUm(SB2->B2_COD,nSldPed,nSldPed2,2))

				If (Empty((cAliasSC9)->C9_RESERVA)) .And. !("S" $ SC6->C6_BLQ .Or. "R" $ SC6->C6_BLQ) //Se nao Bloqueado
						RecLock("SB2",.F.)
						SB2->B2_QPEDVEN -= nSldPed
						SB2->B2_QPEDVE2 -= nSldPed2
				Else
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Atualiza o saldo da reserva                                  ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If !lAcumulado
						SC0->(dbSetOrder(1))
						If SC0->(MsSeek(xFilial("SC0")+(cAliasSC9)->C9_RESERVA+(cAliasSC9)->C9_PRODUTO+SC6->C6_LOCAL))
							RecLock("SC0")
							SC6->C6_QTDRESE -= (cAliasSC9)->C9_QTDRESE
							SC0->C0_QTDPED -= (cAliasSC9)->C9_QTDRESE
							SC0->C0_TIPO   := If(SC0->C0_QTDPED==0,"LB","PD")
						EndIf
					EndIf
				EndIf
			Else
				If !lAcumulado
					If (cAliasSC9)->C9_RESERVA==SC6->C6_RESERVA .And. !Empty((cAliasSC9)->C9_RESERVA)
						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³Atualiza os dados do SC6                                                ³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						SC6->C6_QTDRESE -= (cAliasSC9)->C9_QTDRESE
					EndIf
				Else
					RecLock("SB2")
					SB2->B2_QPEDVEN -= (cAliasSC9)->C9_QTDRESE
					SB2->B2_QPEDVE2 -= ConvUM(SB2->B2_COD,(cAliasSC9)->C9_QTDRESE,0,2)
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³Atualiza as reservas para faturamento                                   ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If !Empty((cAliasSC9)->C9_RESERVA)
						SC0->(dbSetOrder(1))
						If SC0->(MsSeek(xFilial("SC0")+(cAliasSC9)->C9_RESERVA+(cAliasSC9)->C9_PRODUTO+SC6->C6_LOCAL))
							//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
							//³Tratamento dos Lotes da Reserva                                         ³
							//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
							GravaEmp(SC0->C0_PRODUTO,;    //1
								SC6->C6_LOCAL,;            //2
								(cAliasSC9)->C9_QTDRESE+SC6->C6_QTDRESE,;   //3
								NIL,;                //4
								SC0->C0_LOTECTL,;       //5
								SC0->C0_NUMLOTE,;       //6
								SC0->C0_LOCALIZ,;       //7
								SC0->C0_NUMSERI,;       //8
								Nil,;                //9
								Nil,;                //10
								(cAliasSC9)->C9_RESERVA,;        //11
								Nil,;                //12
								"SC0",;                 //13
								Nil,;                //14
								Nil,;                //15
								Nil,;                //16
								.F.,;                //17
								.F.,;                //18
								.T.,;                //19
								.F.,;                //20
								Nil,;                //21
								IIf(!IntWms(SC0->C0_PRODUTO),!Empty(SC0->C0_LOTECTL+SC0->C0_NUMLOTE).Or.Localiza( SC0->C0_PRODUTO ,.T. ),!Empty(SC0->C0_LOTECTL+SC0->C0_NUMLOTE+SC0->C0_LOCALIZ+SC0->C0_NUMSERI)),; //22
								(lAtuEmp .And. !lAcumulado)) //23
							RecLock("SB2")
						EndIf
					EndIf
				EndIf
			EndIf
			
			If !lBlqEst 
				PmsBxEmp(SC9->C9_PROJPMS, SC9->C9_TASKPMS, SC9->C9_PRODUTO, SC9->C9_LOCAL, SC9->C9_QTDLIB, "-", SC9->C9_QTDLIB2,SC9->C9_TRT)
			EndIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³                Notas sobre o campo C6_OP                               ³
			//³ 01 - OP Gerada pelo MATA650                                            ³
			//³ 02 - Liberacao de PV bloqueada ( Sem OP )                              ³
			//³ 03 - Liberacao de PV bloqueada ( Item 01 )                             ³
			//³ 04 - Bloqueio de credito pelo MATA650                                  ³
			//³ 05 - OP nao gerada pois ha qtde em Estoque                             ³
			//³ 06 - Liberacao de PV liberada  ( Item 05 )                             ³
			//³ 07 - Liberacao de credito efetuada / Estoque pendente/bloqueada        ³
			//³ 08 - Liberacao de estoque efetuada ( item 01 )                         ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If !lAcumulado
				Do Case
				Case Empty(SC6->C6_OP)
					If !lBlqEst .Or. SF4->F4_ESTOQUE=="N"
						SC6->C6_OP     := ""
					Else
						SC6->C6_OP     := "02"
					EndIf
				Case SC6->C6_OP == "07"
					If !lBlqEst .Or. SF4->F4_ESTOQUE=="N"
						SC6->C6_OP     := ""
					EndIf
				Case SC6->C6_OP == "01"
					If !lBlqEst .Or. SF4->F4_ESTOQUE=="N"
						SC6->C6_OP     := "08"
					Else
						SC6->C6_OP     := "03"
					EndIf
				Case SC6->C6_OP == "05"
					If !lBlqEst .Or. SF4->F4_ESTOQUE=="N"
						SC6->C6_OP     := "06"
					EndIf
				EndCase
			EndIf
		EndIf
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Estorno da Liberacao de estoque de um item liberado do pedido de venda  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Case nEvento == 6
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Posiciona registros                                                     ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	cFilSC6 := xFilial("SC6")
	If !(cFilSC6==SC6->C6_FILIAL .And.;
			SC6->C6_NUM==(cAliasSC9)->C9_PEDIDO .And.;
			SC6->C6_ITEM==(cAliasSC9)->C9_ITEM .And.;
			SC6->C6_PRODUTO==(cAliasSC9)->C9_PRODUTO )
		SC6->(dbSetOrder(1))
		SC6->(MsSeek(cFilSC6+(cAliasSC9)->C9_PEDIDO+(cAliasSC9)->C9_ITEM+(cAliasSC9)->C9_PRODUTO))
	EndIf
	SF4->(dbSetOrder(1))
	SF4->(MsSeek(xFilial("SF4")+SC6->C6_TES))
	If lContinua .And. SF4->F4_ESTOQUE=="S"
		SB2->(dbSetOrder(1))
		SB2->(MsSeek(xFilial("SB2")+(cAliasSC9)->C9_PRODUTO+(cAliasSC9)->C9_LOCAL))
		lContinua := RecLock("SB2")
		nRecnoB2 := SB2->(Recno())
	EndIf
	
	cFilSC5 := xFilial("SC5")
	If lContinua .And. !(cFilSC5==SC5->C5_FILIAL .And. SC5->C5_NUM==(cAliasSC9)->C9_PEDIDO)
		SC5->(dbSetOrder(1))
		SC5->(MsSeek(cFilSC5+(cAliasSC9)->C9_PEDIDO))
	EndIf

	If lContinua .And. !lAcumulado
		lContinua := RecLock("SC5")
	EndIf
	If lContinua
		lContinua := RecLock("SC6")
	EndIf
	If lContinua .And. !lAcumulado
		lContinua := RecLock(cAliasSC9)
	EndIf
	If lContinua
		If SF4->F4_ESTOQUE == "S" .And. !lFaturado
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³                Notas sobre o campo C6_OP                               ³
			//³ 01 - OP Gerada pelo MATA650                                            ³
			//³ 02 - Liberacao de PV bloqueada ( Sem OP )                              ³
			//³ 03 - Liberacao de PV bloqueada ( Item 01 )                             ³
			//³ 04 - Bloqueio de credito pelo MATA650                                  ³
			//³ 05 - OP nao gerada pois ha qtde em Estoque                             ³
			//³ 06 - Liberacao de PV liberada  ( Item 05 )                             ³
			//³ 07 - Liberacao de credito efetuada / Estoque pendente/bloqueada        ³
			//³ 08 - Liberacao de estoque efetuada ( item 01 )                         ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If !lAcumulado
				Do Case
				Case SC6->C6_OP == "02"
					SC6->C6_OP := "07"
				Case SC6->C6_OP=="08"
					SC6->C6_OP  := "03"
				Case SC6->C6_OP == "06"
					SC6->C6_OP  := "05"
				Case SC6->C6_OP == "03"
					SC6->C6_OP  := "01"
				EndCase

			EndIf
			If !lBlqEst .And. !lBlqCred
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Atualiza os dados da Reserva                                            ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				nSldPed  := Max(Min(SC6->C6_QTDVEN-SC6->C6_QTDENT-SC6->C6_QTDEMP+(cAliasSC9)->C9_QTDLIB,(cAliasSC9)->C9_QTDLIB),0)
				nSldPed2 := SB1->(ConvUm(SB2->B2_COD,nSldPed,nSldPed2,2))

				If ( !Empty((cAliasSC9)->C9_RESERVA) )
					SC0->(dbSetOrder(1))
					If SC0->(MsSeek(xFilial("SC0")+(cAliasSC9)->C9_RESERVA+SC6->C6_PRODUTO+SC6->C6_LOCAL))
						RecLock("SC0")
						If SC6->C6_QTDRESE==0
							SC6->C6_QTDRESE += (cAliasSC9)->C9_QTDRESE
							SC6->C6_RESERVA := (cAliasSC9)->C9_RESERVA
							SC0->C0_QTDPED  += (cAliasSC9)->C9_QTDRESE
							SC0->C0_TIPO    := "PD"
						Else
							lDelRes       := SuperGetMv("MV_DELRES")
							If SuperGetMv("MV_RESAUT") .AND. lDelRes
								SC0->C0_QUANT += (cAliasSC9)->C9_QTDRESE + SC0->C0_QTDPED
							Else
								SC0->C0_QUANT += (cAliasSC9)->C9_QTDRESE
							EndIf
							SC0->C0_TIPO  := If(SC0->C0_QTDPED==0.And.SC0->C0_TIPO=="PD","VD",SC0->C0_TIPO)
							If !("S" $ SC6->C6_BLQ .Or. "R" $ SC6->C6_BLQ) //Se nao Bloqueado
								SB2->B2_QPEDVEN += (cAliasSC9)->C9_QTDRESE
							EndIf
						EndIf
					EndIf
				ElseIf !("S" $ SC6->C6_BLQ .Or. "R" $ SC6->C6_BLQ) //Se nao Bloqueado
						RecLock("SB2",.F.)
						SB2->B2_QPEDVEN += nSldPed
						SB2->B2_QPEDVE2 += nSldPed2
					EndIf
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Estorna o saldo Reservado                                               ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				GravaEmp((cAliasSC9)->C9_PRODUTO,;  //1
					(cAliasSC9)->C9_LOCAL,;       //2
					(cAliasSC9)->C9_QTDLIB,;      //3
					If( Empty( (cAliasSC9)->C9_QTDLIB2 ), NIL, (cAliasSC9)->C9_QTDLIB2 ),;  //4
					(cAliasSC9)->C9_LOTECTL,;     //5
					(cAliasSC9)->C9_NUMLOTE,;     //6
					Nil,;             //7
					Nil,;             //8
					Nil,;             //9
					(cAliasSC9)->C9_SEQUEN,;      //10
					(cAliasSC9)->C9_PEDIDO,;      //11
					(cAliasSC9)->C9_ITEM,;        //12
					"SC6",;              //13
					Nil,;             //14
					Nil,;             //15
					Nil,;             //16
					.T.,;             //17
					.F.,;             //18
					.T.,;             //19
					.F.,;             //20
					Nil,;             //21
					lAtuEmp) //22
				RecLock("SB2")
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Atualiza a Reserva de Material                                          ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If ( !Empty((cAliasSC9)->C9_RESERVA) )
					SC0->(dbSetOrder(1))
					If SC0->(MsSeek(xFilial("SC0")+(cAliasSC9)->C9_RESERVA+(cAliasSC9)->C9_PRODUTO+SC6->C6_LOCAL))
						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³Tratamento dos Lotes da Reserva                                         ³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						GravaEmp(SC0->C0_PRODUTO,;    //1
							SC6->C6_LOCAL,;            //2
							(cAliasSC9)->C9_QTDLIB,;   //3
							NIL,;                //4
							SC0->C0_LOTECTL,;       //5
							SC0->C0_NUMLOTE,;       //6
							SC0->C0_LOCALIZ,;       //7
							SC0->C0_NUMSERI,;       //8
							Nil,;                //9
							Nil,;                //10
							(cAliasSC9)->C9_RESERVA,;        //11
							Nil,;                //12
							"SC0",;                 //13
							Nil,;                //14
							Nil,;                //15
							Nil,;                //16
							.F.,;                //17
							.F.,;                //18
							.T.,;                //19
							.F.,;                //20
							Nil,;                 //21
							IIf(!IntWms(SC0->C0_PRODUTO),!Empty(SC0->C0_LOTECTL+SC0->C0_NUMLOTE).Or.Localiza( SC0->C0_PRODUTO ,.T.),!Empty(SC0->C0_LOTECTL+SC0->C0_NUMLOTE+SC0->C0_LOCALIZ+SC0->C0_NUMSERI))) //22

						If lDelRes
							a430Reserva({3,SC0->C0_TIPO,SC0->C0_DOCRES,SC0->C0_SOLICIT,SC0->C0_FILRES},;
								SC0->C0_NUM,;
								SC0->C0_PRODUTO,;
								SC0->C0_LOCAL,;
								SC0->C0_QUANT,;
								{SC0->C0_NUMLOTE,;
								SC0->C0_LOTECTL,;
								SC0->C0_LOCALIZ,;
								SC0->C0_NUMSERI})
						EndIf

						RecLock("SB2")
					Else
						If !("S" $ SC6->C6_BLQ .Or. "R" $ SC6->C6_BLQ) //Se nao Bloqueado
							SB2->B2_QPEDVEN += nSldPed
							SB2->B2_QPEDVE2 += nSldPed2
						EndIf
					EndIf
				EndIf
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Atualiza o Bloqueio de Estoque                                          ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				(cAliasSC9)->C9_BLEST := "03" //"Bloqueio Manual de Estoque"
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Cria o Log de movimento do estoque                                      ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

				PmsBxEmp(SC9->C9_PROJPMS, SC9->C9_TASKPMS, SC9->C9_PRODUTO, SC9->C9_LOCAL,SC9->C9_QTDLIB, "+", SC9->C9_QTDLIB2,SC9->C9_TRT)

			Else
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Atualiza dados do SC6                                                   ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				nSldPed  := Max(Min(SC6->C6_QTDVEN-SC6->C6_QTDENT-SC6->C6_QTDEMP+(cAliasSC9)->C9_QTDLIB,(cAliasSC9)->C9_QTDLIB),0)
				nSldPed2 := SB1->(ConvUm(SB2->B2_COD,nSldPed,nSldPed2,2))
				If ( !Empty((cAliasSC9)->C9_RESERVA) )
					If ( SC6->C6_RESERVA==(cAliasSC9)->C9_RESERVA .Or. SC6->C6_QTDRESE==0 )
						SC6->C6_QTDRESE += (cAliasSC9)->C9_QTDRESE
						SC6->C6_RESERVA := (cAliasSC9)->C9_RESERVA
					Else
						SC0->(dbSetOrder(1))
						If SC0->(MsSeek(xFilial("SC0")+(cAliasSC9)->C9_RESERVA+(cAliasSC9)->C9_PRODUTO+SC6->C6_LOCAL))
							RecLock("SC0")
							SC0->C0_QUANT += (cAliasSC9)->C9_QTDRESE
							SC0->C0_TIPO  := If (SC0->C0_QTDPED==0,"VD",SC0->C0_TIPO)
							If !("S" $ SC6->C6_BLQ .Or. "R" $ SC6->C6_BLQ) //Se nao Bloqueado
								SB2->B2_QPEDVEN += (cAliasSC9)->C9_QTDRESE
							EndIf
							If SuperGetMv("MV_DELRES")
								a430Reserva({3,SC0->C0_TIPO,SC0->C0_DOCRES,SC0->C0_SOLICIT,SC0->C0_FILRES},;
									SC0->C0_NUM,;
									SC0->C0_PRODUTO,;
									SC0->C0_LOCAL,;
									SC0->C0_QUANT,;
									{SC0->C0_NUMLOTE,;
									SC0->C0_LOTECTL,;
									SC0->C0_LOCALIZ,;
									SC0->C0_NUMSERI})
							EndIf
						EndIf
					EndIf
				EndIf
			EndIf
		EndIf
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Montagem de Carga                                                       ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Case nEvento == 7
	If lContinua
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Verifica-se a existencia do item da carga                               ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		DAI->(dbSetOrder(1)) //DAI_FILIAL+DAI_COD+DAI_SEQCAR+DAI_SEQUEN+DAI_PEDIDO
		If !DAI->(MsSeek(OsFilial("DAI",cFilCar)+(cAliasSC9)->C9_CARGA+(cAliasSC9)->C9_SEQCAR+(cAliasSC9)->C9_SEQENT+(cAliasSC9)->C9_PEDIDO))
			RecLock("DAI",.T.)
			DAI->DAI_FILIAL  := OsFilial("DAI",cFilCar)
			DAI->DAI_COD     := (cAliasSC9)->C9_CARGA
			DAI->DAI_SEQCAR  := (cAliasSC9)->C9_SEQCAR
			DAI->DAI_SEQUEN  := (cAliasSC9)->C9_SEQENT
			DAI->DAI_PEDIDO  := (cAliasSC9)->C9_PEDIDO
			If DAI->(FieldPos("DAI_FILPV")) > 0
				DAI->DAI_FILPV := (cAliasSC9)->C9_FILIAL
			EndIf
			DAI->DAI_CLIENT  := (cAliasSC9)->C9_CLIENTE
			DAI->DAI_LOJA    := (cAliasSC9)->C9_LOJA
			DAI->DAI_ROTEIR  := aRotas[1]
			DAI->DAI_PERCUR  := aRotas[2]
			DAI->DAI_ROTA    := aRotas[3]
			DAI->DAI_SEQROT  := Space(6)
			DAI->DAI_DATA    := dDataBase
			DAI->DAI_HORA    := Time()
			DAI->DAI_CARORI  := Iif(Len(aRotas) > 15, aRotas[16], "CARGA")
			DAI->DAI_PESO   := 0
			DAI->DAI_CAPVOL := 0
			DAI->DAI_CHEGAD := aRotas[9]
			DAI->DAI_TMSERV := aRotas[10]
			DAI->DAI_DTCHEG := aRotas[11]
			DAI->DAI_DTSAID := aRotas[12]
			If lFreteEmb
				DAI->DAI_VALFRE := aRotas[14]
				DAI->DAI_FREAUT := aRotas[15]
			EndIf
		Else
			RecLock("DAI",.F.)
		EndIf
		Msunlock()
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Atualiza os acumulados do DAI                                       ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		OsAvalDAI("DAI",1,aRotas,,,cFilCar)
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Estorno da Montagem de Carga                                            ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Case nEvento == 8
	aAreaDAI := DAI->(GetArea())
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Verifica-se a filial da liberacao do pedido de venda                    ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	cFilCar := (cAliasSC9)->(OsFilOpe(C9_CARGA,C9_SEQCAR,C9_SEQENT,C9_CLIENTE,C9_LOJA,C9_PEDIDO))
	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Atualiza os acumulados do DAI                                       ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	DAI->(dbSetOrder(1))
	If	DAI->(MsSeek(OsFilial("DAI",cFilCar)+(cAliasSC9)->C9_CARGA+(cAliasSC9)->C9_SEQCAR+(cAliasSC9)->C9_SEQENT+(cAliasSC9)->C9_PEDIDO))
		OsAvalDAI("DAI",2,aRotas,,,cFilCar)
	EndIf
	RestArea(aAreaDAI)
Case nEvento == 11
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Posiciona registros                                                     ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	cFilSC5 := xFilial("SC5")
	If !(cFilSC5==SC5->C5_FILIAL .And.;
			SC5->C5_NUM==(cAliasSC9)->C9_PEDIDO)
		SC5->(dbSetOrder(1))
		SC5->(MsSeek(cFilSC5+(cAliasSC9)->C9_PEDIDO))
	EndIf
	If !SC5->C5_TIPO$'DB'
		cFilSA1 := xFilial("SA1")
		If !cFilSA1+(cAliasSC9)->C9_CLIENTE+(cAliasSC9)->C9_LOJA ==;
				SA1->A1_FILIAL+SA1->A1_COD+SA1->A1_LOJA
			SA1->(dbSetOrder(1))
			SA1->(MsSeek(cFilSA1+(cAliasSC9)->C9_CLIENTE+(cAliasSC9)->C9_LOJA))
		EndIf
		lTrvSA1 := IIf(cPaisLoc == "BRA" .And. lFATTRVSA1, ExecBlock("FATTRVSA1", .F., .F., {xFilial("SA1"), SA1->A1_COD, SA1->A1_LOJA}), .T.)
		lContinua := IIf(lAtuSA1 .And. lTrvSA1, RecLock("SA1"), .T.)
	EndIf
	cFilSC6 := xFilial("SC6")
	If !(cFilSC6==SC6->C6_FILIAL .And.;
			SC6->C6_NUM==(cAliasSC9)->C9_PEDIDO .And.;
			SC6->C6_ITEM==(cAliasSC9)->C9_ITEM .And.;
			SC6->C6_PRODUTO==(cAliasSC9)->C9_PRODUTO)
		SC6->(dbSetOrder(1))
		SC6->(MsSeek(cFilSC6+(cAliasSC9)->C9_PEDIDO+(cAliasSC9)->C9_ITEM+(cAliasSC9)->C9_PRODUTO))
	EndIf
	cFilSF4 := xFilial("SF4")
	If !cFilSF4+SC6->C6_TES == SF4->F4_FILIAL+SF4->F4_CODIGO
		SF4->(dbSetOrder(1))
		SF4->(MsSeek(cFilSF4+SC6->C6_TES))
	EndIf
	If lContinua
		If !lRemito
			(cAliasSC9)->C9_BLCRED  := "10"
			(cAliasSC9)->C9_BLEST   := "10"
			(cAliasSC9)->C9_NFISCAL := SD2->D2_DOC
			(cAliasSC9)->C9_SERIENF := SD2->D2_SERIE
			(cAliasSC9)->C9_NUMSEQ := SD2->D2_NUMSEQ
			If GetNewPar("MV_NFS_JOB",.F.)
				(cAliasSC9)->C9_BLCRED  := "ZZ"
				(cAliasSC9)->C9_BLEST   := "ZZ"
			EndIf
			If ( SF4->F4_DUPLIC == "S" .And. !SC5->C5_TIPO$"DB" .And. !AllTrim(SC6->C6_BLQ)$"RS" ) .And. !lRskSalPed
				nMCusto :=  Iif(SA1->A1_MOEDALC > 0,SA1->A1_MOEDALC,Val(SuperGetMv("MV_MCUSTO")))
				If lMTValAvC
					nValAv	:=	ExecBLock("MTValAvC",.F.,.F.,{'MAAVALSC9',(cAliasSC9)->C9_QTDLIB*(cAliasSC9)->C9_PRCVEN,nEvento})
				Else
					nValAv	:=	(cAliasSC9)->C9_QTDLIB*(cAliasSC9)->C9_PRCVEN
				EndIf
				nSldLib := xMoeda(nValAV,SC5->C5_MOEDA,nMCusto,(cAliasSC9)->C9_DATALIB)
				lTrvSA1 := IIf(cPaisLoc == "BRA" .And. lFATTRVSA1, ExecBlock("FATTRVSA1", .F., .F., {xFilial("SA1"), SA1->A1_COD, SA1->A1_LOJA}), .T.)
				If lAtuSA1 .And. lTrvSA1
					Reclock("SA1",.F.)
					SA1->A1_SALPEDL -= nSldLib
					MsUnLock()
				EndIf
			EndIf
			
			If lWmsSaas .And. FindFunction("WMSSGrFtRm")
				WMSSGrFtRm((cAliasSC9)->(Recno()),SF2->(Recno())) 
			EndIf

		Else
			(cAliasSC9)->C9_REMITO  := SD2->D2_DOC
			(cAliasSC9)->C9_SERIREM := SD2->D2_SERIE
			(cAliasSC9)->C9_ITEMREM := SD2->D2_ITEM
			(cAliasSC9)->C9_DTREMIT := SD2->D2_EMISSAO
		EndIf
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Estorno do Documento de Saida                                           ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Case nEvento == 12
	If lRemito .And. !lRskSalPed
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Atualiza a Liberacao de Credito                                         ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If !SC5->C5_TIPO$"DB" .And. SF4->F4_DUPLIC == "S"  .And. !AllTrim(SC6->C6_BLQ)$"RS"
			nMCusto  :=  If(SA1->A1_MOEDALC > 0,SA1->A1_MOEDALC, Val(SuperGetMv("MV_MCUSTO")))
			If lMTValAvC
				nValAv	:=	ExecBLock("MTValAvC",.F.,.F.,{'MAAVALSC9',(cAliasSC9)->C9_QTDLIB*(cAliasSC9)->C9_PRCVEN,nEvento})
			Else
				nValAv	:=	(cAliasSC9)->C9_QTDLIB*(cAliasSC9)->C9_PRCVEN
			Endif

			nSldLib  := xMoeda(nValAv,SC5->C5_MOEDA,nMCusto,(cAliasSC9)->C9_DATALIB)

			If !lBlqCred
				SA1->A1_SALPEDL -= nSldLib
				nVlrCred 		 += nValAV
			Else
				SA1->A1_SALPEDB -= nSldLib
			EndIf
		EndIf
	Endif

	If SF4->F4_MOVPRJ $ "25" .and. SF4->F4_ESTOQUE == "S"
		PmsBxEmp(SC9->C9_PROJPMS, SC9->C9_TASKPMS, SC9->C9_PRODUTO, SC9->C9_LOCAL,SC9->C9_QTDLIB, "+", SC9->C9_QTDLIB2,SC9->C9_TRT)
	EndIf
		
	// Com controle WMS SaaS efetua a exclusão da convergência de faturamento antecipado
	If lWmsSaas .And. FindFunction("WMSSExFtRm")
		WMSSExFtRm((cAliasSC9)->(Recno())) 
	EndIf
EndCase
RestArea(aAreaSF4)
RestArea(aArea)
Return(.T.)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³MatGrdSoma³ Autor ³Eduardo Riera          ³ Data ³ 26.02.99 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Atualizar a Quantidade Vendida com as Quantidades da Grade  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpN1: Quantidade digitada na Grade                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpN1: Linha do aCols Principal                             ³±±
±±³          ³ExpN2: Quantidade digitada na Acols Principal               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³   DATA   ³ Programador   ³Manutencao Efetuada                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Erike Yuri     ³ Esta funcao esta fora de uso.              ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function MatGrdSoma(nLinAcols,nQtdInf,nColQtd)

Local nColunas	:= 0
Local nLinhas	:= 0
Local nSoma		:= 0

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Soma a Quantidade digitada na grade                                     ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
For nColunas:=2 to Len(aHeadGrade[nLinAcols])
	For nLinhas:=1 to Len(aColsGrade[nLinAcols])
		nSoma+=aColsGrade[nLinAcols][nLinhas][nColunas][nColQtd]
	Next nLinhas
Next nColunas
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Verifica se ha divergencias                                             ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If ( nSoma <> nQtdInf .And. nQtdInf <> 0 )
	Help(" ",1,"A410QTDDIF")
EndIf
Return(nSoma)


/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³MatGrdMont³ Autor ³Eduardo Riera          ³ Data ³ 23.02.99 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Montagem do aHeadGrade e do aColsGrade                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpL1: Logico                                               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpN1: Numero da Linha da GetDados Principal                ³±±
±±³          ³ExpC2: Produto da Grade                                     ³±±
±±³          ³ExpL3: Indica se deve ser reinicializada a Grade            ³±±
±±³          ³ExpL4: Indica se os registros bloqueado devem ser considera-³±±
±±³          ³       dos.                                                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Observacao³Estrutura dos Array's de Grade                              ³±±
±±³          ³- aHeadGrade                                                ³±±
±±³          ³  [xx]             Referencia a Linha do Acols Principal    ³±±
±±³          ³  [xx][01]         Indica se eh uma (R)Referencia ou (N)Nao ³±±
±±³          ³  [xx][yy]         Colunas da Grade                         ³±±
±±³          ³- aColsGrade                                                ³±±
±±³          ³  [xx]             Referencia a Linha do Acols Principal    ³±±
±±³          ³  [xx][yy]         Referencia a Linha da Grade              ³±±
±±³          ³  [xx][yy][01]     Codigo da Linha da Grade                 ³±±
±±³          ³  [xx][yy][zz]     Referencia a Coluna da Grade             ³±±
±±³          ³  [xx][yy][zz][01] Quantidade Vendida                       ³±±
±±³          ³  [xx][yy][zz][02] Quantidade Liberada                      ³±±
±±³          ³  [xx][yy][zz][03] Quantidade ja Liberada                   ³±±
±±³          ³  [xx][yy][zz][04] Item do SC6                              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³   DATA   ³ Programador   ³Manutencao Efetuada                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Erike Yuri     ³ Esta funcao esta fora de uso               ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function MatGrdMont(nCnt,cProdGrd,lAlterou,lBloqueados)

Local aArea       := GetArea()
Local aAreaSB1    := SB1->(GetArea())
Local aTam        := {}
Local aColuna     := {}
Local aLinha      := {}

Local lRefer      := .F.

Local cProdRef    := ""
Local cMascara    := SuperGetMv("MV_MASCGRD")

Local nCntFor     := 0
Local nCntFor2    := 0
Local nTamRef     := Val(Substr(cMascara,1,2))
Local nTamLin     := Val(Substr(cMascara,4,2))
Local nTamCol     := Val(Substr(cMascara,7,2))
Local nLinhas     := 0

cProdGrd    := If(cProdGrd==Nil,"",cProdGrd)
cProdRef    := cProdGrd
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Verifica se o Produto e uma referencia                                  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
lReFer := MatGrdPrrf(@cProdRef)
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Inicializa os Parametros com seus valores default                       ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
lAlterou := If(lAlterou==Nil,.F.,lAlterou)
DEFAULT lBloqueados := .F.

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Tratamento da Grade de Produtos                                         ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If ( !lRefer )
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Produto que nao possuem controle de grade.                              ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If ( Len(aHeadGrade) >= nCnt )
		aHeadGrade[nCnt]  := {}
		AAdd(aHeadGrade[nCnt],"N")
		aColsGrade[nCnt] := {}
	Else
		While Len(aHeadGrade) < nCnt
			AAdd(aHeadGrade,{})
			AAdd(aHeadGrade[Len(aHeadGrade)],"N")
			AAdd(aColsGrade,{})
		EndDo
	EndIf
Else
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Produto que possue controle por grade                                   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	dbSelectArea("SB4")
	dbSetOrder(1)
	MsSeek(xFilial("SB4")+cProdRef)
	If ( Len(aHeadGrade) >= nCnt )
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Quando existe, verifica se o array era de um produto     ³
		//³ referencia, se ja era ok, se nao deve criar o array de   ³
		//³ novo                                                     ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If ( aHeadGrade[nCnt][1] == "N" .Or. lAlterou )
			aHeadGrade[nCnt]  := {}
			AAdd(aHeadGrade[nCnt],{})
			aHeadGrade[nCnt][1] := "R"
			aTam:=TamSX3("C6_QTDVEN")
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Verifica as Linhas e Colunas da Grade pelo produto                      ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If ExistBlock("PVORDGRL") .And. ExistBlock("PVORDGRC")
				aLinha  := ExecBlock("PVORDGRL",.F.,.F.,{cProdRef})
				aColuna := ExecBlock("PVORDGRC",.F.,.F.,{cProdRef})
			Else
				dbSelectArea("SB1")
				dbSetOrder(1)
				MsSeek(xFilial("SB1")+cProdRef)
				While ( !Eof() .And. SB1->B1_FILIAL == xFilial("SB1") .And.;
						SubStr(SB1->B1_COD,1,nTamRef) == cProdRef )
					If SB1->B1_GRADE # "S" .And. ( !RegistroOk("SB1",.F.) .Or. lbloqueados )
						dbSkip()
						Loop
					EndIf
					If ( aScan(aColuna,SubStr(SB1->B1_COD,nTamRef+nTamLin+1,nTamCol))==0 )
						AAdd(aColuna,SubStr(SB1->B1_COD,nTamRef+nTamLin+1,nTamCol))
					EndIf
					If ( aScan(aLinha,SubStr(SB1->B1_COD,nTamRef+1,nTamLin))==0 )
						AAdd(aLinha,SubStr(SB1->B1_COD,nTamRef+1,nTamLin))
					EndIf
					dbSelectArea("SB1")
					dbSkip()
				EndDo
			EndIf
			If GetNewPar("MV_ORDGRDP",.T.)
				aColuna  := aSort(aColuna)
				aLinha   := aSort(aLinha)
			EndIf
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Verifica a Coluna da Grade                                              ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			For nCntFor := 1 To Len(aColuna)
				AAdd(aHeadGrade[nCnt],{  aColuna[nCntFor],;
					"_"+A550RemoveSinal(aColuna[nCntFor]),;
					PesqPictQt("C6_QTDVEN",14),;
					aTam[1],;
					aTam[2],;
					"A410GValid()",;
					"û",;
					"C",;
					" ",;
					" " })
			Next nCntFor
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Verifica a Linha da Grade                                               ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			aColsGrade[nCnt]  := {}
			For nCntFor := 1 To Len(aLinha)
				nLinhas++
				For nCntFor2 := 1 To Len(aHeadGrade[nCnt])
					If ( nCntFor2 == 1 )
						AAdd(aColsGrade[nCnt],{})
						AAdd(aColsGrade[nCnt][nLinhas],aLinha[nCntFor])
					Else
						AAdd(aColsGrade[nCnt][nLinhas],{0,0,0,"",0})
					EndIf
				Next nCntFor2
				AAdd(aColsGrade[nCnt][nLinhas],.F.)
			Next nCntFor
		EndIf
	Else
		aTam:=TamSX3("C6_QTDVEN")
		AAdd(aHeadGrade,{})
		AAdd(aHeadGrade[nCnt],"R")
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Verifica as Linhas e Colunas da Grade pelo produto                      ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If ExistBlock("PVORDGRL") .And. ExistBlock("PVORDGRC")
			aLinha  := ExecBlock("PVORDGRL",.F.,.F.,{cProdRef})
			aColuna := ExecBlock("PVORDGRC",.F.,.F.,{cProdRef})
		Else
			dbSelectArea("SB1")
			dbSetOrder(1)
			MsSeek(xFilial("SB1")+cProdRef)
			While ( !Eof() .And. SB1->B1_FILIAL == xFilial("SB1") .And.;
					SubStr(SB1->B1_COD,1,nTamRef) == cProdRef )
				If RegistroOk("SB1",.F.) .Or. lBloqueados
					If ( aScan(aColuna,SubStr(SB1->B1_COD,nTamRef+nTamLin+1,nTamCol))==0 )
						AAdd(aColuna,SubStr(SB1->B1_COD,nTamRef+nTamLin+1,nTamCol))
					EndIf
					If ( aScan(aLinha,SubStr(SB1->B1_COD,nTamRef+1,nTamLin))==0 )
						AAdd(aLinha,SubStr(SB1->B1_COD,nTamRef+1,nTamLin))
					EndIf
				EndIf
				dbSelectArea("SB1")
				dbSkip()
			EndDo
		EndIf
		If GetNewPar("MV_ORDGRDP",.T.)
			aColuna  := aSort(aColuna)
			aLinha   := aSort(aLinha)
		EndIf
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Verifica a Colunas                                                      ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		For nCntFor := 1 To Len(aColuna)
			AAdd(aHeadGrade[nCnt],{  aColuna[nCntFor],;
				"_"+A550RemoveSinal(aColuna[nCntFor]),;
				PesqPictQt("C6_QTDVEN",14),;
				aTam[1],;
				aTam[2],;
				"A410GValid()",;
				"û",;
				"C",;
				" ",;
				" " })
		Next nCntFor
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Verifica as Linhas                                                      ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		AAdd(aColsGrade,{})
		For nCntFor := 1 To Len(aLinha)
			nLinhas++
			For nCntFor2 := 1 To Len(aHeadGrade[nCnt])
				If ( nCntFor2 == 1 )
					AAdd(aColsGrade[nCnt],{})
					AAdd(aColsGrade[nCnt][nLinhas],aLinha[nCntFor])
				Else
					AAdd(aColsGrade[nCnt][nLinhas],{0,0,0,"",0})
				EndIf
			Next nCntFor2
		Next nCntFor
	EndIf
EndIf
RestArea(aAreaSB1)
RestArea(aArea)
Return(lRefer)

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³FTReprEst ³ Autor ³ Sergio Silveira       ³ Data ³20/02/2001³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Retorna os grupos abaixo de um representante ( vendedor )  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ ExpA1 := FTReprEst( ExpC1 )                                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ ExpA1 -> Array com os grupos do representante.             ³±±
±±³          ³     1 - Grupo / 2 - String com acessos da workare          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 -> Representante.                                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³   DATA   ³ Programador   ³Manutencao Efetuada                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³               ³                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/

Function FTReprEst( cRepres )

Local aArea		 := GetArea()
Local aGruposEst := {}

SA3->( dbSetOrder( 1 ) )
If SA3->( DbSeek( xFilial( "SA3" ) + cRepres ) )
	FTGrupRepr( SA3->A3_GRPREP, @aGruposEst )
EndIf

RestArea(aArea)

Return( aGruposEst )

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³FTGrupRepr³ Autor ³ Sergio Silveira       ³ Data ³20/02/2001³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Faz a inclusao dos grupos ( funcao recursiva )             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ FTGrpRepr( ExpC1, @ExpA1 )                                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ .T.                                                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 -> Grupo incluido / ExpA1 -> Array de grupos.        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³   DATA   ³ Programador   ³Manutencao Efetuada                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³               ³                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/

Function FTGrupRepr( cGrupoInc, aGruposEst )

Local aRecnoACA  := {}
Local nLoop      := 0
Local lExistADK  := ChkFile("ADK")
Local cQuery     := ""
Local cAliasQry  := ""

ACA->( dbSetOrder( 1 ) )
If ACA->( DbSeek( xFilial( "ACA" ) + cGrupoInc ) )

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Inclui os grupos que tem este grupo como superior            ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	aRecnoACA := {}

	cAliasQry := GetNextAlias()
	cQuery    := ""

	cQuery += "SELECT R_E_C_N_O_ ACARECNO FROM " + RetSqlName( "ACA" ) + " "
	cQuery += "WHERE "
	cQuery += "ACA_FILIAL='" + xFilial( "ACA" ) + "' AND "
	cQuery += "ACA_GRPSUP='" + cGrupoInc        + "' AND "
	cQuery += "ACA_TIPSUP = '2GR' AND "
	cQuery += "D_E_L_E_T_ = ' '"

	cQuery := ChangeQuery(cQuery)

	dbUseArea( .T., "TOPCONN", TcGenQry( , , cQuery ), cAliasQry, .F., .T. )
	dbGoTop()
	While !Eof()
		AAdd( aRecnoACA, ACARECNO )
		dbSkip()
	EndDo
	(cAliasQry)->(dbCloseArea())

	If lExistADK
		cAliasQry2 := GetNextAlias()
		cQuery    := ""

		cQuery += "SELECT ACA.R_E_C_N_O_ ACARECNO FROM " + RetSqlName( "ADK" ) + " ADK "
		cQuery += "INNER JOIN " + RetSqlName( "ACA" ) + " ACA ON ADK.ADK_COD = ACA.ACA_GRPSUP AND ACA.D_E_L_E_T_ = ' ' "
		cQuery += "WHERE "
		cQuery += "ADK_FILIAL='" + xFilial( "ADK" ) + "' AND "
		cQuery += "ADK_GRUNVE='" + cGrupoInc        + "' AND "
		cQuery += "ADK.D_E_L_E_T_ = ' ' "

		cQuery := ChangeQuery(cQuery)

		dbUseArea( .T., "TOPCONN", TcGenQry( , , cQuery ), cAliasQry2, .F., .T. )
		dbGoTop()
		While !Eof()
			AAdd( aRecnoACA, ACARECNO )
			dbSkip()
		EndDo
		(cAliasQry2)->(dbCloseArea())
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Processa a lista de recnos                                   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	For nLoop := 1 To Len( aRecnoACA )
		ACA->( MsGoto( aRecnoACA[ nLoop ] ) )
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Inclui este grupo                                            ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		AAdd( aGruposEst, { ACA->ACA_GRPREP, ACA->ACA_ACCLIE + ACA->ACA_ACPROS + ;
			ACA->ACA_ACPIPE + ACA->ACA_ACAPON + ACA->ACA_ACOPOR + ACA->ACA_ACESTR + ACA->ACA_MODCLI + ;
			ACA->ACA_MODPRO + "11" + ACA->ACA_MODOPO + ACA->ACA_MODEST } )

			FTGrupRepr( ACA->ACA_GRPREP, @aGruposEst )

	Next nLoop
EndIf
Return(.T.)
/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³MaNeedP3  ³ Autor ³ Eduardo Riera         ³ Data ³02/04/2002³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Funcao de analise da Necessidade do Saldo do Poder de 3     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ExpN1 := MaNeedP3()                                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpA1: [1] Saldo proprio necessario                         ³±±
±±³          ³       [2] Saldo do Poder de Terceiro Necessario            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpN1: Quantidade Necessaria                                ³±±
±±³          ³ExpN2: Quantidade ja reservada                         (OPC)³±±
±±³          ³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Observacao³A Tes e o item do pedido de venda devem estar posicionados  ³±±
±±³          ³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³   DATA   ³ Programador   ³Manutencao Efetuada                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³               ³                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function MaNeedP3(nQtdLib,nQtdReserva)

Local aArea      := GetArea()
Local aAreaSC9   := SC9->(GetArea())
Local aSaldos    := {0,0,0}
Local nSldFisico := 0
Local nSldPoder3 := 0
Local nSldNosso  := 0
Local nSldNPT    := 0
Local nQtdJaReser:= 0
Local nQtdJaLib  := 0
Local cQuery     := ""

DEFAULT nQtdReserva := 0
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Verifica se eh necessario o saldo de poder de terceiro                 ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If !Empty(SF4->F4_TESP3) .And. nQtdLib > 0 .And. SF4->F4_ESTOQUE=="S" .And.;
		SF4->F4_PODER3=="N" .And. Empty(SC6->C6_RESERVA)
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Calcula o disponivel considerando o poder de teceiro                   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	nSldFisico := SldAtuEst(SC6->C6_PRODUTO,SC6->C6_LOCAL,999999999999,NIL,NIL,NIL,NIL,NIL,NIL,NIL,NIL,NIL,SC6->C6_SERVIC)
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Calcula o disponivel nao considerando o poder de teceiro               ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	nSldNosso  := Max(SldAtuEst(SC6->C6_PRODUTO,SC6->C6_LOCAL,999999999999,Nil,Nil,Nil,Nil,Nil,.F.,NIL,NIL,NIL,SC6->C6_SERVIC),0)
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica o saldo em poder de terceiro ja liberado                      ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	cQuery := "SELECT SUM(C9_QTDLIB) QTDLIB "
	cQuery += "FROM "+RetSqlName("SC9")+" SC9 "
	cQuery += "WHERE SC9.C9_FILIAL='"+xFilial("SC9")+"' AND "
	cQuery += "SC9.C9_PRODUTO='"+SC6->C6_PRODUTO+"' AND "
	cQuery += "SC9.C9_LOCAL='"+SC6->C6_LOCAL+"' AND "
	cQuery += "SC9.C9_BLEST='"+Space(Len(SC9->C9_BLEST))+"' AND "
	cQuery += "SC9.C9_BLCRED='"+Space(Len(SC9->C9_BLCRED))+"' AND "
	cQuery += "SC9.C9_IDENTB6<>'"+Space(Len(SC9->C9_IDENTB6))+"' AND "
	cQuery += "SC9.D_E_L_E_T_=' ' "

	cQuery := ChangeQuery(cQuery)

	dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),"MANEEDP3",.T.,.T.)
	nSldFisico += QTDLIB
	nQtdJaLib := QTDLIB
	dbCloseArea()
	dbSelectArea("SC9")
	nSldPoder3 := nSldFisico-nQtdJaLib
	If nQtdLib > nSldNosso
		aSaldos[1] := Min(nQtdLib,nSldNosso)
		aSaldos[2] := Min(nQtdLib-nSldNosso,nSldPoder3)
	Else
		aSaldos[1] := Min(nQtdLib,nSldNosso)
	EndIf
Else
	aSaldos[1] := nQtdLib
EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Verifica se eh necessario o saldo de poder em terceiro                 ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If aSaldos[2]==0 .And. nQtdLib > 0 .And. SF4->F4_ESTOQUE=="S" .And.;
		SF4->F4_PODER3=="N" .And. Empty(SC6->C6_RESERVA) .And.;
		SF4->F4_SLDNPT=="1"
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Calcula o disponivel considerando o poder de teceiro                   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	nSldFisico := SldAtuEst(SC6->C6_PRODUTO,SC6->C6_LOCAL,nQtdLib,Nil,Nil,Nil,Nil,Nil,Nil,.F.,NIL,NIL,SC6->C6_SERVIC)
	nSldFisico += nQtdReserva
	If nSldFisico < 0
		nQtdJaReser := Abs(nSldFisico)
		nSldFisico  := 0
	EndIf
	If nSldFisico < nQtdLib
		nSldNPT := SldAtuEst(SC6->C6_PRODUTO,SC6->C6_LOCAL,nQtdLib+nQtdJaReser,Nil,Nil,Nil,Nil,Nil,Nil,.T.,NIL,NIL,SC6->C6_SERVIC)-nSldFisico
		If nSldNPT > 0 .And. nSldNPT >= nQtdJaReser+nQtdLib
			aSaldos[1] := Min(nQtdLib,nSldFisico)
			aSaldos[3] := Min(nQtdLib-aSaldos[1],nSldNPT)
		EndIf
	EndIf
EndIf
RestArea(aAreaSC9)
RestArea(aArea)
Return(aSaldos)


/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³FaAvRestri³ Autor ³ Sergio Silveira       ³ Data ³19/07/2002³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Funcao de avaliacao das restricoes de visita                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ExpA1 := FaAvRestri(ExpC1,ExpC2,ExpN1,[ExpC3],ExpD1,[ExpC4],³±±
±±³          ³   [ExpC5],[ExpC6] )                                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpA1: Array contendo a seguintes elementos : { 1, 2, 3, 4 }³±±
±±³          ³ 1 - Tipo L - Indica se existe restricao                    ³±±
±±³          ³ 2 - Tipo L - Indica se conseguiu sugerir um novo horario   ³±±
±±³          ³   apos a restricao ( apenas quando elem. 1 igual a .f. )   ³±±
±±³          ³ 3 - Tipo C - Novo horario de inicio - Valido apenas quando ³±±
±±³          ³         elem. 2 = .T.                                      ³±±
±±³          ³ 4 - Tipo C - Novo horario de fim    - Valido apenas quando ³±±
±±³          ³         elem. 2 = .T.                                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpC1: Codigo do Cliente                                    ³±±
±±³          ³ExpC2: Loja do cliente                                      ³±±
±±³          ³ExpN1: Tipo de restricao: 1-Visita / 2-Entrega / 3-Ambos    ³±±
±±³          ³ExpC3: Contato                                              ³±±
±±³          ³ExpD1: Data de referencia                                   ³±±
±±³          ³ExpC4: Hora inicial ou hora de referencia                   ³±±
±±³          ³ExpC5: Hora final                                           ³±±
±±³          ³ExpC6: Hora limite                                          ³±±
±±³          ³                                                            ³±±
±±³          ³O parametros de horario nao sao obrigatorios. E permitido   ³±±
±±³          ³passar apenas o horario inicial e nesta situacao apenas     ³±±
±±³          ³este sera verificado. O parametro hora limite e utilizado   ³±±
±±³          ³para limitar o horario maximo permitido quando o sistema    ³±±
±±³          ³sugerir um novo horario imediatamente apos uma restricao    ³±±
±±³          ³existente.                                                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³   DATA   ³ Programador   ³Manutencao Efetuada                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³               ³                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/

Function FaAvRestri( cCodCli, cLoja, nAbrang, cContato, dDataAval, cHoraIni, cHoraFim, cHrLimite )

Local aGrupos   := {}
Local aArea     := GetArea()

Local bAbrang   := { || .T. }
Local bContato  := { || .T. }

Local cSeekACW  := ""
Local cQuery    := ""
Local cAliasQry := ""
Local cHrIniNew := ""
Local cHrFimNew := ""
Local cContNull := Space( Len( ACW->ACW_CODCON ) )

Local lRet      := .T.
Local lContinua := .T.
Local lHora     := ( ValType( cHoraIni ) == "C" )
Local lContato  := ( ValType( cContato ) == "C" )
Local lHoraNew  := .F.

Local nLoop     := 0
Local nRecnoACW := 0
Local nMinuto   := 1 / 60
Local nTempo    := 0

If lHora
	cHoraFim := If( ValType( cHoraFim ) == "C", cHoraFim, cHoraIni )
EndIf

bContato := If( lContato, { || ACW->ACW_CODCON == cContato .Or. ACW->ACW_CODCON == cContNull }, { || .T. } )

If nAbrang == 1
	bAbrang := { || ACW->ACW_ABRANG $ "13" }
ElseIf nAbrang == 2
	bAbrang := { || ACW->ACW_ABRANG $ "23" }
EndIf

SA1->( dbSetOrder( 1 ) )
If SA1->( MsSeek( xFilial( "SA1" ) + cCodCli + cLoja ) )

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Pesquisa uma restricao para o cliente                                   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	cSeekACW := xFilial( "ACW" ) + SA1->A1_COD + SA1->A1_LOJA + DTOS( dDataAval )
	ACW->( dbSetOrder( 3 ) )
	If ACW->( MsSeek( cSeekACW ) )
		If lHora

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Pesquisa o horario da restricao                                         ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			cAliasQry := "FAAVRESTRI"

			cQuery := ""
			cQuery += "SELECT ACW.*, R_E_C_N_O_ ACWRECNO FROM " + RetSqlName( "ACW" ) + " ACW "
			cQuery += "WHERE "
			cQuery += "ACW_FILIAL='"   + xFilial( "ACW" ) + "' AND "
			cQuery += "ACW_CODCLI='"   + SA1->A1_COD      + "' AND "
			cQuery += "ACW_LOJA='"     + SA1->A1_LOJA     + "' AND "
			cQuery += "ACW_DATA='"     + DTOS( dDataAval )+ "' AND "

			If nAbrang == 1
				cQuery += "ACW_ABRANG IN ( '1', '3' ) AND "
			ElseIf nAbrang == 2
				cQuery += "ACW_ABRANG IN ( '2', '3' ) AND "
			EndIf

			If lContato
				cQuery += " ( ACW_CODCON='" + cContato + "' OR ACW_CODCON='" + cContNull + "' ) AND "
			EndIf

			cQuery += "( ( ACW_HORA1>='" + cHoraIni     + "' AND "
			cQuery += "ACW_HORA1<='"     + cHoraFim         + "' ) OR "

			cQuery += "( ACW_HORA2>='"   + cHoraIni     + "' AND "
			cQuery += "ACW_HORA2<='"     + cHoraFim     + "' ) OR "

			cQuery += "( '" + cHoraIni + "'>=ACW_HORA1 AND "
			cQuery += "'"   + cHoraIni + "'<=ACW_HORA2 ) OR "
			cQuery += "( '" + cHoraFim + "'>=ACW_HORA1 AND "
			cQuery += "'"   + cHoraFim + "'<=ACW_HORA2 ) ) AND "

			cQuery += "D_E_L_E_T_ = ' ' "
			cQuery += "ORDER BY " + SqlOrder( ACW->( IndexKey() ) )

			cQuery := ChangeQuery( cQuery )

			dbUseArea( .T., "TOPCONN", TcGenQry( ,, cQuery ), cAliasQry, .F., .T. )

			TcSetField( cAliasQry, "ACWRECNO", "N", 10, 0 )

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Verifica o primeiro que atende a situacao                               ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If !( cAliasQry )->( Eof() )
				lRet      := ( ( cAliasQry )->ACW_TIPO == "2" )
				lContinua := .F.
				nRecnoACW := ( cAliasQry )->ACWRECNO
			EndIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Fecha a area de trabalho da query                                       ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			( cAliasQry )->( dbCloseArea() )
			dbSelectArea( "ACW" )
		Else
			lRet      := ( ACW->ACW_TIPO == "2" )
			lContinua := .F.
		EndIf
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Se nao encontrou regra para o cliente, pesquisa uma regra para o grupo  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lContinua

		If !Empty( SA1->A1_GRPVEN )

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Obtem todos os grupos acima na estrutura                                ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			aGrupos := {}
			MaCliStrUp( SA1->A1_GRPVEN, @aGrupos )

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ ordena os grupos por nivel                                              ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			ASort( aGrupos, , , { |x,y| y[2] > x[2] } )

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Percorre todos os grupos de baixo para cima                             ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			For nLoop := 1 To Len( aGrupos )

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Persquisa uma restricao para o grupo atual                              ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				cSeekACW := xFilial( "ACY" ) + aGrupos[ nLoop, 1 ] + DTOS( dDataAval )

				ACW->( dbSetOrder( 2 ) )
				If ACW->( MsSeek( cSeekACW ) )
					If lHora
						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³ Verifica se a restricao encontra-se no horario                          ³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						cAliasQry := "FAAVRESTR2"

						cQuery := ""
						cQuery += "SELECT ACW.*, R_E_C_N_O_ ACWRECNO FROM " + RetSqlName( "ACW" ) + " ACW "
						cQuery += "WHERE "
						cQuery += "ACW_FILIAL='"   + xFilial( "ACW" )    + "' AND "
						cQuery += "ACW_GRPVEN='"   + aGrupos[ nLoop, 1 ] + "' AND "
						cQuery += "ACW_DATA='"     + DTOS( dDataAval )   + "' AND "

						If nAbrang == 1
							cQuery += "ACW_ABRANG IN ( '1', '3' ) AND "
						ElseIf nAbrang == 2
							cQuery += "ACW_ABRANG IN ( '2', '3' ) AND "
						EndIf

						If lContato
							cQuery += " ( ACW_CODCON='" + cContato + "' OR ACW_CODCON='" + cContNull + "' ) AND "
						EndIf

						cQuery += "( ( ACW_HORA1>='" + cHoraIni     + "' AND "
						cQuery += "ACW_HORA1<='"     + cHoraFim     + "' ) OR "

						cQuery += "( ACW_HORA2>='"   + cHoraIni     + "' AND "
						cQuery += "ACW_HORA2<='"     + cHoraFim     + "' ) OR "

						cQuery += "( '" + cHoraIni + "'>=ACW_HORA1 AND "
						cQuery += "'"   + cHoraIni + "'<=ACW_HORA2 ) OR "
						cQuery += "( '" + cHoraFim + "'>=ACW_HORA1 AND "
						cQuery += "'"   + cHoraFim + "'<=ACW_HORA2 ) ) AND  "

						cQuery += "D_E_L_E_T_ = ' ' "
						cQuery += "ORDER BY " + SqlOrder( ACW->( IndexKey() ) )

						cQuery := ChangeQuery( cQuery )

						dbUseArea( .T., "TOPCONN", TcGenQry( ,, cQuery ), cAliasQry, .F., .T. )

						TcSetField( cAliasQry, "ACWRECNO", "N", 10, 0 )

						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³ Verifica o primeiro que atende a situacao                               ³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						If !( cAliasQry )->( Eof() )
							lRet      := ( ( cAliasQry )->ACW_TIPO == "2" )
							lContinua := .F.
							nRecnoACW := ( cAliasQry )->ACWRECNO
						EndIf

						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³ Fecha a area de trabalho da query                                       ³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						( cAliasQry )->( dbCloseArea() )

						dbSelectArea( "ACW" )

					Else
						lRet      := ( ACW->ACW_TIPO == "2" )
						lContinua := .F.
					EndIf

				EndIf

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Se ja encontrou uma restricao, abandona                                 ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If !lContinua
					Exit
				EndIf

			Next nLoop

		EndIf

	EndIf

EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Se possui restricao e considera hora, tenta obter um novo horario sem restricao ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If !lRet .And. lHora

	If !Empty( nRecnoACW )

		ACW->( MsGoto( nRecnoACW ) )

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Caso nao seja passado horario limite, o limite e' 23:59                         ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		cHrLimite := If( ValType( cHrLimite ) == "C", cHrLimite, "23:59" )
		lHoraNew  := .T.

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Calcula o tempo de alocacao                                                     ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		nTempo := SubtHoras( dDataAval, cHoraIni, dDataAval, cHoraFim )

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Soma um minuto ao horario final da restricao para encontrar o novo horario ini  ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		cHrIniNew := AtSomaHora( ACW->ACW_HORA2, nMinuto )
		cHrFimNew := AtSomaHora( cHrIniNew, nTempo )

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Verifica se e possivel alocar para o dia                                        ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If cHrIniNew > cHrLimite .Or. cHrFimNew > cHrLimite
			lHoraNew := .F.
		EndIf

		If !lHoraNew
			cHrIniNew := cHoraIni
			cHrFimNew := cHoraFim
		EndIf

	EndIf

EndIf

RestArea( aArea )

Return( { lRet, lHoraNew, cHrIniNew, cHrFimNew } )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³MaCliStru ³ Autor ³Sergio Silveira        ³ Data ³16/05/2002³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Traz todos os grupos abaixo de um grupo de clientes        ³±±
±±³          ³ ( recursiva )                                              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ MaCliStru( ExpC1, @ExpA1, [ ExpN1 ] )                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ Nenhum                                                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 -> Grupo a pesquisar                                 ³±±
±±³          ³ ExpA1 -> Array contendo os grupos. Deve ser passado por    ³±±
±±³          ³    referencia e alimentado pela funcao                     ³±±
±±³          ³       Estrutura : 1 - Grupo ( C )                          ³±±
±±³          ³                   2 - Nivel do grupo ( N )                 ³±±
±±³          ³ ExpN1 -> Nivel atual. Este parametro nao deve ser passado  ³±±
±±³          ³ na chamada inicial, pois e passado quando a funcao chama   ³±±
±±³          ³ ela mesma ( recursividade )                                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³   DATA   ³ Programador   ³Manutencao Efetuada                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³               ³                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/

Function MaCliStru( cGrpSup, aGrupos, nLevel )

Local cAliasQry := ""
Local cQuery    := ""

If ValType( nLevel ) <> "N"
	nLevel := 0
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Incrementa o contador de niveis                              ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

nLevel++

cAliasQry := GetNextAlias()

cQuery := ""
cQuery += "SELECT ACY_GRPVEN, ACY_GRPSUP FROM " + RetSqlName( "ACY" ) + " "
cQuery += "WHERE "
cQuery += "ACY_FILIAL='" + xFilial( "ACY" ) + "' AND "
cQuery += "ACY_GRPSUP='" + cGrpSup          + "' AND "
cQuery += "D_E_L_E_T_ = ' '"

cQuery := ChangeQuery( cQuery )

dbUseArea( .T., "TOPCONN", TcGenQry( , , cQuery ), cAliasQry, .F., .T. )

If Alias() == cAliasQry
	While !( cAliasQry )->( Eof() )
		AAdd( aGrupos, { ( cAliasQry )->ACY_GRPVEN, nLevel } )
		MaCliStru( ( cAliasQry )->ACY_GRPVEN, @aGrupos, @nLevel )
		( cAliasQry )->( dbSkip() )
	EndDo
	dbCloseArea()
	dbSelectArea( "ACY" )
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Decrementa o contador de niveis                              ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
nLevel--

Return()

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³MaCliStrUp³ Autor ³Sergio Silveira        ³ Data ³19/07/2002³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Traz todos os grupos acima de um grupo de clientes         ³±±
±±³          ³ Funcao de chamada                                          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ MaCliStrUp( ExpC1, @ExpA1, [ ExpL1 ] )                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ Nenhum                                                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 -> Grupo a pesquisar                                 ³±±
±±³          ³ ExpA1 -> Array contendo os grupos. Deve ser passado por    ³±±
±±³          ³    referencia e alimentado pela funcao                     ³±±
±±³          ³       Estrutura : 1 - Grupo ( C )                          ³±±
±±³          ³                   2 - Nivel do grupo ( N )                 ³±±
±±³          ³ ExpL1 -> Inverte a contagem de niveis no array. Quando     ³±±
±±³          ³ .T., a ordem passa a ser de cima para baixo                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³   DATA   ³ Programador   ³Manutencao Efetuada                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³               ³                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/

Function MaCliStrUp( cGrpAtu, aGrupos, lInverte )

Local aArea    := GetArea()
Local aAreaACY := ACY->( GetArea() )

lInverte := If( ValType( lInverte ) == "L", lInverte, .F. )

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Chama a funcao de processamento                              ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
MaPrcStrUp( cGrpAtu, @aGrupos )

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Inverte a ordem de niveis                                    ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lInverte
	ASort( aGrupos, , , { |x,y| x[ 2 ] > y[ 2 ] } )
	AEval( aGrupos, { |x,y| x[ 2 ] := y } )
EndIf

RestArea( aAreaACY )
RestArea( aArea )

Return( .T. )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³MaPrcStrUp³ Autor ³Sergio Silveira        ³ Data ³19/07/2002³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Traz todos os grupos acima de um grupo de clientes         ³±±
±±³          ³ ( processamento )                                          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ MaPrcStrUp( ExpC1, @ExpA1, [ ExpN1 ] )                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ Nenhum                                                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 -> Grupo a pesquisar                                 ³±±
±±³          ³ ExpA1 -> Array contendo os grupos. Deve ser passado por    ³±±
±±³          ³    referencia e alimentado pela funcao                     ³±±
±±³          ³       Estrutura : 1 - Grupo ( C )                          ³±±
±±³          ³                   2 - Nivel do grupo ( N )                 ³±±
±±³          ³ ExpN1 -> Nivel atual. Este parametro nao deve ser passado  ³±±
±±³          ³ na chamada inicial, pois e passado quando a funcao chama   ³±±
±±³          ³ ela mesma ( recursividade )                                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³   DATA   ³ Programador   ³Manutencao Efetuada                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³               ³                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/

Function MaPrcStrUp( cGrpAtu, aGrupos, nLevel )

Local cSeekACY  := ""

If ValType( nLevel ) <> "N"
	nLevel := 0
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Incrementa o contador de niveis                              ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

nLevel++

ACY->( dbSetOrder( 1 ) )
cSeekACY := xFilial( "ACY" ) + cGrpAtu
If ACY->( MsSeek( cSeekACY ) )
	AAdd( aGrupos, { ACY->ACY_GRPVEN, nLevel } )
	MaPrcStrUp( ACY->ACY_GRPSUP, @aGrupos, @nLevel )
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Decrementa o contador de niveis                              ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
nLevel--

Return()

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³FaIsOnStru³ Autor ³Sergio Silveira        ³ Data ³30/07/2002  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Verifica se um grupo de clientes esta contido na estrutura de ³±±
±±³          ³outro grupo de clientes                                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ExpL1 := FaIsOnStru( ExpC1, ExpC2 )                           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpC1: Grupo pai                                              ³±±
±±³          ³ExpC2: Grupo filho                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpL1: Validacao : .T. contido, .F. nao contido               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Materiais/Distribuicao/Logistica                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ AtualizACQes sofridas desde a Construcao Inicial.                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Programador  ³ Data   ³ BOPS ³  Motivo da Alteracao                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³              ³        ³      ³                                          ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/

Function FaIsOnStru( cGrpPai, cGrpFilho )

Local aStruUp  := {}
Local lRetorno := .F.

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Carrega a estrutura que esta acima do filho                  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
MaCliStrUp( cGrpFilho, @aStruUp )

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Verifica se o pai esta acima ou e igual ao filho             ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
lRetorno := !Empty( AScan( aStruUp, { |x| x[1] == cGrpPai } ) )

Return( lRetorno )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³FtVldQtVen³ Autor ³Henry Fila             ³ Data ³17/01/2003  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Verifica se uma quantidade de venda de um produto esta sendo  ³±±
±±³          ³vendida com seu lote minimo                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ExpL1 := FtVldQtVen( ExpC1, ExpC2,ExpL1 )                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpC1: Produto                                                ³±±
±±³          ³ExpC2: Quantidade                                             ³±±
±±³          ³ExpL3: Mostra help ou nao                                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpL1: Validacao : .T. valido , .F. nao valido                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Materiais/Distribuicao/Logistica                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ AtualizACQes sofridas desde a Construcao Inicial.                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Programador  ³ Data   ³ BOPS ³  Motivo da Alteracao                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³              ³        ³      ³                                          ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function FtVldQtVen(cProduto,nQtde,lHelp,cTipo)

Local lRet     := .T.
Local aArea    := GetArea()
Local aAreaSB1 := SB1->(GetArea())

DEFAULT lHelp := .T.
DEFAULT cTipo := "N"

SB1->(dbSetOrder(1))
If SB1->(MsSeek(xFilial("SB1")+cProduto))
	If cTipo == "N" .And. SB1->B1_LOTVEN <> 0 .And. SB1->B1_LOTVEN > nQtde
		If lHelp
			Help(" ",1,"FTQTDMIN")
		Endif
		lRet := .F.
		If ExistBlock( "FTQTDMIN" )
			lRet := ExecBlock( "FTQTDMIN", .F., .F. )
		EndIf
	Endif
Endif

RestArea(aAreaSB1)
Restarea(aArea)

Return(lRet)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³MaVenStrUp³ Autor ³Sergio Silveira        ³ Data ³19/07/2002³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Traz todos os grupos acima de um grupo de vendedores       ³±±
±±³          ³ Funcao de chamada                                          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ MaVenStrUp( ExpC1, @ExpA1, [ ExpL1 ] )                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ Nenhum                                                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 -> Grupo a pesquisar                                 ³±±
±±³          ³ ExpA1 -> Array contendo os grupos. Deve ser passado por    ³±±
±±³          ³    referencia e alimentado pela funcao                     ³±±
±±³          ³       Estrutura : 1 - Grupo ( C )                          ³±±
±±³          ³                   2 - Nivel do grupo ( N )                 ³±±
±±³          ³ ExpL1 -> Inverte a contagem de niveis no array. Quando     ³±±
±±³          ³ .T., a ordem passa a ser de cima para baixo                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³   DATA   ³ Programador   ³Manutencao Efetuada                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³               ³                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/

Function MaVenStrUp( cGrpAtu, aGrupos, lInverte )

Local aArea    := GetArea()
Local aAreaACA := ACA->( GetArea() )

lInverte := If( ValType( lInverte ) == "L", lInverte, .F. )

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Chama a funcao de processamento                              ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
MaPrcRepUp( cGrpAtu, @aGrupos )

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Inverte a ordem de niveis                                    ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lInverte
	ASort( aGrupos, , , { |x,y| x[ 2 ] > y[ 2 ] } )
	AEval( aGrupos, { |x,y| x[ 2 ] := y } )
EndIf

RestArea( aAreaACA )
RestArea( aArea )

Return( .T. )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³MaPrcRepUp³ Autor ³Sergio Silveira        ³ Data ³19/07/2002³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Traz todos os grupos acima de um grupo de vendedores       ³±±
±±³          ³ ( processamento )                                          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ MaPrcRepUp( ExpC1, @ExpA1, [ ExpN1 ] )                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ Nenhum                                                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 -> Grupo a pesquisar                                 ³±±
±±³          ³ ExpA1 -> Array contendo os grupos. Deve ser passado por    ³±±
±±³          ³    referencia e alimentado pela funcao                     ³±±
±±³          ³       Estrutura : 1 - Grupo ( C )                          ³±±
±±³          ³                   2 - Nivel do grupo ( N )                 ³±±
±±³          ³ ExpN1 -> Nivel atual. Este parametro nao deve ser passado  ³±±
±±³          ³ na chamada inicial, pois e passado quando a funcao chama   ³±±
±±³          ³ ela mesma ( recursividade )                                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³   DATA   ³ Programador   ³Manutencao Efetuada                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³               ³                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/

Function MaPrcRepUp( cGrpAtu, aGrupos, nLevel )

Local cSeekACA  := ""

If ValType( nLevel ) <> "N"
	nLevel := 0
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Incrementa o contador de niveis                              ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

nLevel++

ACA->( dbSetOrder( 1 ) )
cSeekACA := xFilial( "ACA" ) + cGrpAtu
If ACA->( dbSeek( cSeekACA ) )
	AAdd( aGrupos, { ACA->ACA_GRPREP, nLevel } )
	MaPrcRepUp( ACA->ACA_GRPSUP, @aGrupos, @nLevel )
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Decrementa o contador de niveis                              ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
nLevel--

Return()

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³Ma440Compl³ Autor ³Henry Fila             ³ Data ³24/11/2003³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Verifica se eh complemento de precos e possui item liberado³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ Ma440Compl()                                               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ Nenhum                                                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ Nenhum                                                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³   DATA   ³ Programador   ³Manutencao Efetuada                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³               ³                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function Ma440Compl()

Local lRet  := .T.
Local aArea := GetArea()
Local aAreaSC9 := SC9->(GetArea())
Local lCompl   := IIf(cPaisLoc == "BRA",;
					 (SC5->C5_TIPO $ "IP" .Or. (SC5->C5_TIPO $ "C" .And. SC5->C5_TPCOMPL == "1")),; //Compl. Preçco
					  SC5->C5_TIPO $ "CIP")     

If lCompl
	SC9->(dbSetOrder(2))
	If SC9->(MsSeek(xFilial("SC9")+SC5->C5_CLIENTE+SC5->C5_LOJACLI+SC5->C5_NUM+SC6->C6_ITEM))
		lRet := .F.
	Endif

	If lRet
		If !Empty(SC6->C6_NOTA)
			lRet := .F.
		Endif
	Endif
Else
	lRet := .F.
Endif

RestArea(aAreaSC9)
RestArea(aArea)

Return(lRet)


/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³MaTesLZero³ Autor ³Henry Fila             ³ Data ³24/11/2003³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Verifica se eh quantidade zerada e possui item liberado    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ Ma440Compl()                                               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ Nenhum                                                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ Nenhum                                                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³   DATA   ³ Programador   ³Manutencao Efetuada                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³               ³                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function MaTesLZero()

Local lRet  := .T.
Local aArea := GetArea()
Local aAreaSC9 := SC9->(GetArea())

SC9->(dbSetOrder(2))
If SC9->(MsSeek(xFilial("SC9")+SC5->C5_CLIENTE+SC5->C5_LOJACLI+SC5->C5_NUM+SC6->C6_ITEM))
	lRet := .F.
Endif

RestArea(aAreaSC9)
RestArea(aArea)

Return(lRet)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ FatLoad  ³ Autor ³Marco Bianchi          ³ Data ³18/10/2007³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Funcoes a serem executadas na entrada do modulo Faturamento³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ FatLoad()                                                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ Nenhum                                                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ Nenhum                                                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³   DATA   ³ Programador   ³Manutencao Efetuada                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³               ³                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function FatLoad()

If FindFunction("fFilDocFis")
	fFilDocFis()
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Depuracao de reservas                                   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
a430Auto()

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Criacao de um template de proposta comercial ³
//³para integracao,com Microsoft Word.          ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If FindFunction("R600TWrd")
	R600TWrd()
End

If cPaisLoc $ "COL"
	CIIUCOL()
EndIf

//--------------------------------------------------------------
// Cria o cadastro de integração da Neogrid S&OP
//--------------------------------------------------------------
FT801Carga()

//--------------------------------------------------------------
// Avaliação do agendamento de Jobs do Protheus Insights 
//--------------------------------------------------------------
If FindFunction("totvs.protheus.backoffice.ba.insights.util.validateUseOfInsights",.T.)
	totvs.protheus.backoffice.ba.insights.util.validateUseOfInsights(1) // 1 - Execução da activeJobs
Endif


Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³A410LibBen ºAutor  ³Andre Anjos         º Data ³  05/12/08   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDescricao ³ Libera o saldo empenhado para o item de PV referente a      º±±
±±º			 ³ remessa de beneficiamento quando ha lote e;ou localizacao.  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametro ³ nEvento: Evento que esta sendo processado.				   º±±
±±º			 ³ 	1- Analise de saldo disponivel.							   º±±
±±º			 ³ 	2- Estorno de liberacao.								   º±±
±±º			 ³ cAlias: Alias onde se encontra o empenho.				   º±±
±±º			 ³ nRecno: Recno do registro de empenho.					   º±±
±±º			 ³ nQtd1: Quantidade a ser restaurada 1UM.					   º±±
±±º			 ³ nQtd2: Quantidade a ser restaurada 2UM.					   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºRetorno	 ³ nRet: Quantidade do empenho baixado.						   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ FATXFUN                                   				   º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function A410LibBen(nEvento,cAlias,nRecno,nQtd1,nQtd2)
Local aArea 	:= GetArea()
Local nRet 		:= 0
Local cCpo1 	:= Substr(cAlias,2,2) + "_QUANT"
Local cCpo2 	:= Substr(cAlias,2,2) + "_QTSEGUM"
Local cCpoOrig := Substr(cAlias,2,2) + If(cAlias == "SDC","_QTDORIG","_QTDEORI")
Local cCpoProd := Substr(cAlias,2,2) + If(cAlias == "SDC","_PRODUTO","_COD")
Local nOperac	:= If(nEvento == 1,-1,1)
Local lProcess := .T.

dbSelectArea(cAlias)
dbGoTo(nRecno)

Default nQtd2 := If(&(cCpo2)>0,nQtd1/(&(cCpo1)/&(cCpo2)),0)
If cAlias == "SD4"
	nRet := &(cCpo1)
EndIf

//Prepara seek nas tabelas de saldos
SB2->(dbSetOrder(1))
SB8->(dbSetOrder(3))
SBF->(dbSetOrder(1))

If nEvento == 1 .And. nQtd1 > &(cCpo1)
	nQtd1 := &(cCpo1)
	nQtd2 := &(cCpo2)
ElseIf nEvento == 2
	If (nQtd1 > &(cCpoOrig)) .Or. ((nQtd1 + &(cCpo1)) > &(cCpoOrig))
		nQtd1 := &(cCpoOrig)
		nQtd2 := ConvUM(&(cCpoProd),nQtd1,0,2)
	ElseIf &(cCpo1) == &(cCpoOrig)
		lProcess := .F.
    EndIf
EndIf

If lProcess
	Begin Transaction
		If cAlias == "SDC"
			SBF->(dbSeek(xFilial("SB2")+(SDC->DC_LOCAL+SDC->DC_LOCALIZ+SDC->DC_PRODUTO+SDC->DC_NUMSERI+SDC->DC_LOTECTL+SDC->DC_NUMLOTE)))
			GravaBFEmp("+",(nQtd1*nOperac),"F",.F.,(nQtd2*nOperac))
		Else
			SB2->(dbSeek(xFilial("SB2")+SD4->(D4_COD+D4_LOCAL)))
			GravaB2Emp("+",(nQtd1*nOperac),"F",.F.,(nQtd2*nOperac))

			If !Empty(SD4->(D4_LOTECTL+D4_NUMLOTE))
				SB8->(dbSeek(xFilial("SB8")+SD4->(D4_COD+D4_LOCAL+D4_LOTECTL+If(Rastro(D4_COD,"S"),D4_NUMLOTE,""))))
				GravaB8Emp("+",(nQtd1*nOperac),"F",.F.,(nQtd2*nOperac))
			EndIf
		EndIf

		dbSelectArea(cAlias)
		RecLock(cAlias,.F.)
		Replace &(cCpo1) With &(cCpo1) + (nQtd1 * nOperac)
		Replace &(cCpo2) With &(cCpo2) + (nQtd2 * nOperac)
		MsUnLock()
	End Transaction
EndIf

RestArea(aArea)
Return nRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³FatAtuEmpNºAutor  ³Andre Anjos         º Data ³  28/05/09   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDescricao ³ Funcao utilizada para fazer o controle de preenchimento do º±±
±±º          ³ campo B2_QEMPN nas atualizacoes de itens de pedido de vendaº±±
±±º          ³ (SC6 posicionado no item desejado).						  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³ cSinal: sinal da operacao								  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ FATXFUN, MATA450 E MATA521								  º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function FatAtuEmpN(cSinal,lEstorn,cAliasSC9,lSeekSC6)
Local aArea       := GetArea()
Local aAreaSB2    := SB2->(GetArea())
Local lA650QLibPV := FindFunction("A650QLibPV")
Local lAtuSGJ     := .F.
Local nQtdAtEmpN  := 0
Local nQtdDif	  := 0
DEFAULT lEstorn   := .F.
DEFAULT cAliasSC9 := "SC9"
DEFAULT lSeekSC6  := .F.

//Posiciona SC6 caso necessario
If lSeekSC6 .And. !(xFilial("SC6")==SC6->C6_FILIAL .And.;
		SC6->C6_NUM==(cAliasSC9)->C9_PEDIDO .And.;
		SC6->C6_ITEM==(cAliasSC9)->C9_ITEM .And.;
		SC6->C6_PRODUTO==(cAliasSC9)->C9_PRODUTO)
	dbSelectArea("SC6")
	dbSetOrder(1)
	MsSeek(xFilial("SC6")+(cAliasSC9)->C9_PEDIDO+(cAliasSC9)->C9_ITEM+(cAliasSC9)->C9_PRODUTO)
EndIf

SB2->(dbSetOrder(1))

If !Empty(SC6->(C6_NUMOP+C6_ITEMOP))
	SC2->(dbSetOrder(1))
	SC2->(dbSeek(xFilial("SC2")+SC6->(C6_NUMOP+C6_ITEMOP)))
	If !SB2->(dbSeek(xFilial("SB2")+SC2->(C2_PRODUTO+C2_LOCAL)))
		CriaSB2(SC2->C2_PRODUTO,SC2->C2_LOCAL)
	EndIf
	If !lEstorn
		A650AtEmpN(SC6->(C6_QTDVEN-C6_QTDENT-C6_QTDRESE) - If(lA650QLibPV,A650QLibPV(),0),cSinal,SC2->C2_TPOP)
	Else
		A650AtEmpN(If(lA650QLibPV,A650QLibPV(lEstorn,cAliasSC9),0),cSinal,SC2->C2_TPOP)
	EndIf
ElseIf !Empty(SC6->(C6_NUMSC+C6_ITEMSC))
	SC1->(dbSetOrder(1))
	SC1->(dbSeek(xFilial("SC1")+SC6->(C6_NUMSC+C6_ITEMSC)))
	If !SB2->(dbSeek(xFilial("SB2")+SC1->(C1_PRODUTO+C1_LOCAL)))
		CriaSB2(SC1->C1_PRODUTO,SC1->C1_LOCAL)
	EndIf
	If !lEstorn
		A650AtEmpN(SC6->(C6_QTDVEN-C6_QTDENT-C6_QTDRESE) - If(lA650QLibPV,A650QLibPV(),0),cSinal,SC1->C1_TPOP)
	Else
		A650AtEmpN(If(lA650QLibPV,A650QLibPV(lEstorn),0),cSinal,SC1->C1_TPOP)
	EndIf
ElseIf SC6->C6_OP $ "03/05/06"
	SB2->(dbSeek(xFilial("SB2")+SC6->(C6_PRODUTO+C6_LOCAL)))
	If !lEstorn
		nQtdAtEmpN := A650QLibPV()
		lAtuSGJ	:= SuperGetMV("MV_PVCOMOP",.F.,.F.) .And. FindFunction("ALIASINDIC") .And. AliasIndic("SGJ")
		If !SuperGetMv("MV_LIBACIM") .And. !lAtuSGJ .And. Localiza(SC6->C6_PRODUTO, .T.) .And. cSinal=="+"
			nQtdDif := ( SC6->(C6_QTDVEN-C6_QTDENT) - nQtdAtEmpN )
			// Indica liberacao acima do saldo do pedido e nao grava o excesso liberado em B2_QEMPN
			If QtdComp(nQtdDif) < QtdComp(0)
				nQtdAtEmpN += nQtdDif
			EndIf
      	EndIf
		A650AtEmpN(SC6->(C6_QTDVEN-C6_QTDENT-C6_QTDRESE) - If(lA650QLibPV,nQtdAtEmpN,0),cSinal,SC6->C6_TPOP)
	Else
		If lA650QLibPV
			nQtdAtEmpN := A650QLibPV(lEstorn)
			lAtuSGJ	:= SuperGetMV("MV_PVCOMOP",.F.,.F.) .And. FindFunction("ALIASINDIC") .And. AliasIndic("SGJ")
			If !SuperGetMv("MV_LIBACIM") .And. !lAtuSGJ
				nQtdDif := ( SC6->(C6_QTDVEN-C6_QTDENT) - nQtdAtEmpN )
				// Indica liberacao acima do saldo do pedido e nao grava o excesso liberado em B2_QEMPN
				If QtdComp(nQtdDif) < QtdComp(0)
					nQtdAtEmpN += nQtdDif
				EndIf
			EndIf
		EndIf
		A650AtEmpN(If(lA650QLibPV,nQtdAtEmpN,0),cSinal,SC6->C6_TPOP)
	EndIf
EndIf
RestArea(aAreaSB2)
RestArea(aArea)
Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³FatCredToolsºAutor  ³Faturamento         º Data ³  28/05/09 º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDescricao ³ Funcao utilizada para fazer o analise de credito via 	  º±±
±±º          ³ intellector da tools										  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³ nValor: Valor acumulado de cada item do pedido de venda	  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ FATXFUN e MATA450										  º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function FatCredTools(cCodCli, cLojaCli, nVlItAcum, nVlTitAbe, nVlTitAtras)

Local cMvTolPoVe	:= ALLTRIM(SuperGetMv("MV_TOLPOVE", .F.,""))   //Politica de venda para integracao com Intellector
Local cMvTolTiVe	:= ALLTRIM(SuperGetMv("MV_TOLTIVE", .F.,""))   //Tipo de politica de venda para integracao com Intellector
Local cMvTolLayo	:= ALLTRIM(SuperGetMv("MV_TOLLAYO", .F.,""))   //Layout da politica para integracao com Intellector

Local nMvCrdTole	:= SuperGetMV("MV_CRDTOLE", .F., 1)			//Valor de tolerancia para liberacao de limite de credito
Local oRetYMF		:= NIL											//Objeto do tipo LJCDadosRetYMF
Local lRetorno		:= .F.											//Retorno da funcao

//Faz a analise de credito via Tools
oRetYMF	:= CrdXExecYMF(cMvTolPoVe  , cMvTolTiVe ,cMvTolLayo  ,cCodCli ,;
 						  cLojaCli, nVlTitAbe ,nMvCrdTole 	,nVlItAcum	  ,;
 						  nVlTitAtras)

//Limite de credito aprovado
lRetorno :=  (ValType(oRetYMF) == "O" .AND. oRetYMF:lAprovado)

Return lRetorno

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³BlPVLFat  ºAutor  ³Microsiga           º Data ³  04/18/11   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³FATXFUN - So para atender legislação de Alagoas             º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function BlPVLFat(cCli,cLoja,lPvBloq)
Local lBlqPv     := .F. // Pedido não bloqueado
Local lLibPv   := ( IsInCallStack("FT210PROC") .Or. IsInCallStack("MA215PROC") .Or. IsInCallStack("LJ7GERAENT") .Or. IsInCallStack("MADELNFS") )
Local lContrICM:= .F.
Local aSvAreaA1:= SA1->(GetArea())    
Local aSvAreaC6:= {}
Local cQueryD2 := ""
Local cQueryC9 := ""
Local cAliasD2 := GetNextAlias()
Local cAliasC9 := GetNextAlias()
Local nValLim := SuperGetMv("MV_LIMFTAL",,0)
Local cDtIni := StrZero(Year(dDataBase),4) + StrZero(Month(dDataBase),2) +  "01" // primeiro dia do mes database
Local cDtFim := DtoS(CtoD("01" + "/" + StrZero(IIF(Month(dDataBase)==12,1,Month(dDataBase) + 1),2) + "/" + StrZero(Year(dDataBase),4)) - 1) // ultimo dia do mes database
Local nTotFat := 0
Local nValPed := 0
Local InX     := 0
Local nPosVlr := IIf(!lLibPv .And. Type("aHeader")=="A",aScan(aHeader,{|x| Alltrim(Upper(x[2])) == "C6_VALOR"}),0)
Local nPosTES := IIf(!lLibPv .And. Type("aHeader")=="A",aScan(aHeader,{|x| Alltrim(Upper(x[2])) == "C6_TES"}),0)

Default lPvBloq := .F.

lPvBloq := IIf(lLibPv,.F.,lPvBloq) // Pela rotina(FATA210) de liberaçcao sempre considera como não bloqueado

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Verifica se o cliente é contribuinte de ICMS. Mesmo tratamento feito no MATXFIS ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
SA1->(dbSetOrder(1))
If SA1->(MsSeek(xFilial("SA1")+cCli+cLoja))
	If AllTrim(SuperGetMv("MV_ESTADO")) == AllTrim(SA1->A1_EST)
		lContrICM := IIf(Empty(SA1->A1_INSCR).Or."ISENT"$SA1->A1_INSCR.Or."RG"$SA1->A1_INSCR.Or. SA1->A1_CONTRIB == "2",.F.,.T.)
		//Tratamento para considerar como contribuinte do ICMS Produtor Rural com inscrição Rural
		If !Empty(SA1->A1_INSCRUR) .And. "L" $ SA1->A1_TIPO .And. SA1->A1_CONTRIB <> "1"
			lContrICM := .F.
		EndIf
		If !lContrICM .And. nValLim > 0 .And. !lPvBloq
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Totaliza os pedidos liberados para faturameto dentro do mes corrente, conforme o cliente solicitado.³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			cQueryC9 := " SELECT SUM((C9_QTDLIB * C9_PRCVEN)) TOTAL "
			cQueryC9 += "   FROM " + RetSqlName("SC9")
			cQueryC9 += " WHERE D_E_L_E_T_ = ' ' "
			cQueryC9 += "   AND C9_FILIAL = '" + xFilial("SC9") + "' "
			cQueryC9 += "   AND C9_NFISCAL = '' "
			cQueryC9 += "   AND C9_DATALIB BETWEEN '" + cDtIni + "' AND '" + cDtFim + "' "
			cQueryC9 += "   AND C9_CLIENTE = '" + cCli + "' "
			cQueryC9 += "   AND C9_LOJA = '" + cLoja + "' "

			If Select(cAliasC9) > 0
				dbSelectArea(cAliasC9)
			   dbCloseArea()
			EndIf

			cQueryC9 := ChangeQuery( cQueryC9 )
			dbUseArea( .T., "TOPCONN", TcGenQry(,,cQueryC9), cAliasC9, .T., .T. )

			(cAliasC9)->TOTAL

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Totaliza as notas fiscais emitida dentro do mes corrente, conforme o cliente solicitado.³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			cQueryD2 := " SELECT SUM(D2_TOTAL) TOTAL "
			cQueryD2 += "   FROM " + RetSqlName("SD2")
			cQueryD2 += "  WHERE D_E_L_E_T_ = ' ' "
			cQueryD2 += "     AND D2_FILIAL = '" + xFilial("SD2") + "' "
			cQueryD2 += "     AND D2_EMISSAO BETWEEN '" + cDtIni + "' AND '" + cDtFim + "' "
			cQueryD2 += "     AND D2_CLIENTE = '" + cCli + "' "
			cQueryD2 += "     AND D2_LOJA = '" + cLoja + "' "

			If Select(cAliasD2) > 0
				dbSelectArea(cAliasD2)
			   dbCloseArea()
			EndIf

			cQueryD2 := ChangeQuery( cQueryD2 )
			dbUseArea( .T., "TOPCONN", TcGenQry(,,cQueryD2), cAliasD2, .T., .T. )

			nTotFat := (cAliasC9)->TOTAL + (cAliasD2)->TOTAL

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Fecha as duas tabelas³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			(cAliasC9)->(dbCloseArea())
			(cAliasD2)->(dbCloseArea())

			If nTotFat > nValLim
				lBlqPv := .T.
			ElseIf (!lLibPv .And. nPosVlr > 0 .And. nPosTES > 0) .Or. lLibPv
				If lLibPv // Liberação, verifica direto na tabela SC6
					aSvAreaC6:= SC6->(GetArea())
					SC6->(dbSetOrder(1))
					SC6->(dbSeek(xFilial("SC6")+SC5->C5_NUM))
					While SC6->(!Eof()) .And. SC5->C5_NUM == SC6->C6_NUM
						If Posicione("SF4",1,xFilial("SF4")+SC6->C6_TES,"F4_DUPLIC") == "S"
							nValPed += SC6->C6_VALOR
						EndIf
						SC6->(dbSkip())
					EndDo
					RestArea(aSvAreaC6)
				Else
					For InX := 1 To Len(aCols)
						If !(aCols[InX,Len(aHeader)+1]) .And. (Posicione("SF4",1,xFilial("SF4")+aCols[InX][nPosTES],"F4_DUPLIC") == "S")
							nValPed += aCols[InX][nPosVlr]
						EndIf
					Next InX
				EndIf
				If (nTotFat + nValPed) > nValLim
					lBlqPv := .T.
				EndIf
			EndIf

			If lBlqPv .And.  !(IsInCallStack("MA215PROC"))
				 VerBlqReg("BLQAL", 0, "", "", "")
			EndIf
		Else
			lBlqPv := lPvBloq
		EndIf
	EndIf
EndIf

RestArea(aSvAreaA1)

Return lBlqPv
/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³RhInssPat ºAutor  ³Vendas CRM          º Data ³  12/01/12   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Rotina para calculo do INSS Patronal chamada pelo módulo de º±±
±±º          ³RH                                                          º±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Observacao³cPeriodo -> Mês e Ano recebido do parâmetro				  ³±±
±±³          ³cFilProc-> Filial de processamento da rotina				  ³±±
±±³			 ³l13Sal  -> Indica se é cálculo de 13º salario               ³±±
±±³          ³cPeriodo13-> Periodo inicial e final para calculo do 13ºsal ³±± 
±±³          ³												  	 	      ³±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ Vendas CRM                                                 º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/ 
Function RhInssPat(cPeriodo,cFilProc,l13Sal,cPeriodo13,lAgrCtaCtb)

Local cQuery 		:= ""
Local cQueryD1 		:= ""
Local cQueryCG1		:= ""                                                               	
Local cAliasQry 	:= GetNextAlias()
Local cAliasSD1		:= GetNextAlias() 
Local cQryCG1		:= GetNextAlias()
Local cTmpCG1		:= ""
Local nPerIni13		:= IiF (ValType(cPeriodo13)=="C" .And. !Empty(cPeriodo13), AT("/",cPeriodo13),0)
Local cPerIni13		:= IiF (ValType(cPeriodo13)=="C" .And. nPerIni13 > 0, AllTrim(SubStr(cPeriodo13,1,nPerIni13-1)),"")
Local cPerFim13		:= IiF (ValType(cPeriodo13)=="C" .And. nPerIni13 > 0, AllTrim(SubStr(cPeriodo13,nPerIni13+1,(Len(cPeriodo13)))),"") 
Local dPerFim13		:= IiF (!Empty(cPerFim13),CTOD("01"+"/"+SUBSTR(cPerFim13,1,2)+"/"+SUBSTR(cPerFim13,5,6)),CTOD(""))
Local dPerIni		:= IiF (!l13Sal,CTOD("01"+"/"+SUBSTR(cPeriodo,1,2)+"/"+SUBSTR(cPeriodo,5,6)), CTOD("01"+"/"+SUBSTR(cPerIni13,1,2)+"/"+SUBSTR(cPerIni13,5,6)))
Local dPerFim		:= IiF (!l13Sal,CTOD(StrZero(F_ULTDIA(dPerIni),2)+"/"+SUBSTR(cPeriodo,1,2)+"/"+SUBSTR(cPeriodo,5,6)),CTOD(StrZero(F_ULTDIA(dPerFim13),2)+"/"+SUBSTR(cPerFim13,1,2)+"/"+SUBSTR(cPerFim13,5,6)))
Local aArea			:= GetArea()
Local aCFOPs		:= XFUNCFRec()  
Local cIniDes		:= SuperGetMv("MV_DESFOL",,"201208") //Periodo de inicio do cliente na desoneração Mês+Ano   se for fazer colocar o param no updfat23
Local cCFIND		:= SuperGetMv("MV_CFIND",,"") //CFOP´s das vendas dos produtos industrializados pela empresa
Local cNFOrig 		:= ""
Local cSerOrig		:= ""
Local nFatBrut		:= 0 
Local nFatLiq		:= 0 
Local nFatExp		:= 0
Local nPosFis		:= 0
Local nPosDev		:= 0
Local nPosExp       := 0  
Local nTotLiqDev    := 0  
Local nFatLiqExp    := 0  
Local nX            := 0
Local nTotDev       := 0
Local nTot	        := 0
Local nImpostos     := 0
Local aTotFis		:= {}
Local aTotFisDev	:= {} 
Local aCampos		:= {}
Local aFatDes		:= {} 
Local lComplD1 		:= .F.
Local lDtIniCG1		:= .F. 
Local lCodAtiVld 	:= .F. 
Local lTmpCG1		:= .F.
Local lAgreg		:= .F. 
Local lDedICM		:= .F. 
Local nVlrLiqExp	:= 0
Local lDevolLj		:= .F.
Local lRet			:= .T.
Local lQryDeson		:= ExistBlock("QryDeson")
Local cEspecie		:= ""
Local nTotDevBrt	:= 0
Local nDescon		:= 0
Local cRealAlias	:= ""
Local cInsert		:= ""
Local nRetInsert	:= 0
Local aIdxCG1		:= {}
Local lD2CtaRec	  	:= SD2->(ColumnPos("D2_CTAREC")) > 0 //Valida se o campo D2_CTAREC existe para gravar a Conta de Receita - EFD Contribuições
Local cRealName	  	:= ""
Local cExpCfop		:= SuperGetMv("MV_EXPCFOP",.T.,"") //CFOP´s considerados para Exportações diretas e indiretas
Local cFilSf1		:= FwxFilial("SF1")
Local cFilSf2		:= FwxFilial("SF2")
Local cFilCg1		:= FwxFilial("CG1")
Local cFilSb5		:= FwxFilial("SB5")
Local cFilSf4		:= FwxFilial("SF4")
Local cFilSd2		:= FwxFilial("SD2")
Local cFilSd1		:= FwxFilial("SD1")
Local lNfsDeson		:= ExistBlock("NFSDESON")

Default cPeriodo 	:= ""
Default cPeriodo13	:= ""
Default cFilProc	:= cFilAnt
Default l13Sal		:= .F. 
Default lAgrCtaCtb	:= .F.

lDtIniCG1 := Iif(AliasInDic("CG1"),.T.,.F.) //Verifica se existe Data inicial do código de atividade contido na tabela CG1

If cPaisLoc == "BRA"

	cQuery += " SELECT D2_ITEM, D2_DOC, D2_SERIE, D2_COD, D2_TIPO, D2_ESPECIE, D2_TOTAL, D2_VALIPI, D2_ICMSRET, D2_CF, D2_EMISSAO, D2_NFORI, D2_SERIORI, " 
	cQuery += " D2_VALFRE, D2_SEGURO, D2_DESPESA, D2_VALBRUT, D2_VALICM, D2_DESCON, D2_CONTA, F4_AGREG, B5_CODATIV, B5_INSPAT, B5_VERIND "
	If lD2CtaRec
		cQuery += ", D2_CTAREC "
	EndIf
	cQuery += " FROM " + RetSqlName( "SD2" ) + " SD2 "
	cQuery += " LEFT JOIN " + RetSQLName("SB5") +" SB5 ON "			
	cQuery += " SB5.B5_FILIAL = '" + cFilSb5 + "' AND "
	cQuery += " SB5.B5_COD = SD2.D2_COD AND " 
	cQuery += " SB5.D_E_L_E_T_ = ' ' "
	cQuery += " INNER JOIN " + RetSQLName("SF4") +" SF4 ON "			
	cQuery += " SF4.F4_FILIAL = '" + cFilSF4 + "' AND "
	cQuery += " SF4.F4_CODIGO = SD2.D2_TES AND "
	cQuery += " SF4.D_E_L_E_T_ = ' ' "
	cQuery += " WHERE "
	cQuery += " SD2.D2_FILIAL = '" + cFilSd2 + "' AND "  
	cQuery += " SD2.D2_CF IN ( '"+  StrTran(alltrim(aCFOPs[1]), ",", "', '") + "') AND " 		
	If !Empty(aCFOPs[2])
		cQuery += "  SD2.D2_CF NOT IN ( '"+  StrTran(alltrim(SubStr(aCFOPs[2],2)), ",", "', '") + "') AND "  
	EndIF
	cQuery += " SD2.D2_TIPO IN ('N','C','P')  AND "
	cQuery += " SD2.D2_EMISSAO BETWEEN '"+DTOS(dPerIni)+"' AND '"+DTOS(dPerFim)+"' AND " 
	cQuery += " SD2.D_E_L_E_T_ = ' ' "
	If lQryDeson
		cQuery += ExecBlock("QryDeson",.F.,.F.,{cQuery})
	EndIf
	cQuery += " ORDER BY SD2.D2_FILIAL, SD2.D2_COD "
			
	cQuery := ChangeQuery(cQuery)
	dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasQry,.T.,.T.)

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Verifico os códigos de atividade que possuem data de validade maior do que³
	//³o período de processamneto.                                               ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lDtIniCG1
		
		cQueryCG1 := " SELECT CG1_FILIAL, CG1_CODIGO, CG1_DTFIM, CG1_DTINI, CG1_ALIQ "
		cQueryCG1 += " FROM " + RetSqlName( "CG1" ) + " "
		cQueryCG1 += " WHERE "
   		cQueryCG1 += " ( CG1_FILIAL = '" + cFilCg1 + "' "
		cQueryCG1 += " AND (CG1_DTFIM >= '" + DTOS(dPerFim) +"' OR CG1_DTFIM='' ) AND CG1_DTINI <= '" + DTOS(dPerIni) + "' "
		cQueryCG1 += " AND CG1_DTINI <> ' ' OR CG1_CODIGO = '99999999' ) "
		cQueryCG1 += " AND D_E_L_E_T_ = ' ' "
		cQueryCG1 += "ORDER BY "+SqlOrder(CG1->(IndexKey())) 
		
		cQueryCG1 := ChangeQuery(cQueryCG1)
		
   		dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQueryCG1),cQryCG1,.T.,.T.)

		If !(cQryCG1)->(Eof())

			If __oTmpCG1 <> NIL
				cTmpCG1 := __oTmpCG1:GetAlias()
				//Se o alias não existir mais, exclui a tabela temporária para ser criada uma nova.
				If Select(cTmpCG1) == 0
					__oTmpCG1:Delete()
					FreeObj(__oTmpCG1)
				EndIf
			EndIf

			If __oTmpCG1 == NIL
				cTmpCG1 := GetNextAlias()

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Cria arquivo de dados temporário ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				aCampos := {}
				aAdd(aCampos,{"CG1_FILIAL"	,"C",TAMSX3("CG1_FILIAL")[1],2})
				aAdd(aCampos,{"CG1_CODIGO"	,"C",TAMSX3("CG1_CODIGO")[1],2})
				aAdd(aCampos,{"CG1_DTFIM"	,"D",TAMSX3("CG1_DTFIM")[1],2})
				aAdd(aCampos,{"CG1_DTINI"	,"D",TAMSX3("CG1_DTINI")[1],2})
				aAdd(aCampos,{"CG1_ALIQ "	,"N",TAMSX3("CG1_ALIQ")[1],2})

				__oTmpCG1 := FWTemporaryTable():New(cTmpCG1)
				__oTmpCG1:SetFields(aCampos)
				aIdxCG1 := {"CG1_FILIAL","CG1_CODIGO","CG1_DTFIM"}
				__oTmpCG1:AddIndex("1",aIdxCG1)
				__oTmpCG1:Create()
				cRealAlias := __oTmpCG1:GetRealName()
			Else
				cRealAlias := __oTmpCG1:GetRealName()
				TcSqlExec("TRUNCATE TABLE " + cRealAlias)
			EndIf
			
			//Carrega a Estrutura da query(cQryCG1), para o arquivo Temporário via Insert
			//e assim utilizar o indice que é criado na tabela temporária.
			cInsert := " INSERT INTO " + cRealAlias 
			cInsert += " ( CG1_FILIAL, CG1_CODIGO, CG1_DTFIM, CG1_DTINI, CG1_ALIQ ) "
			cInsert += cQueryCG1
			
			nRetInsert = TCSqlExec( cInsert )
			
			If nRetInsert < 0
				Conout( TCSQLError() )
			Else
				lTmpCG1 := .T.
			EndIf
			
		EndIf
		(cQryCG1)->(dbCloseArea())

	EndIf

	While !(cAliasQry)->( Eof() )
		lAgreg := .F.
		lDedICM := .F.
		cEspecie:= ""
		If SF2->(MsSeek(cFilSf2 + (cAliasQry)->D2_DOC + (cAliasQry)->D2_SERIE))
			cEspecie := SF2->F2_ESPECIE
		EndIf
		If lNfsDeson
			lRet := ExecBlock("NFSDESON",.F.,.F.,{(cAliasQry)->D2_DOC, (cAliasQry)->D2_SERIE, (cAliasQry)->D2_COD})
			If ValType(lRet) <> "L"
				lRet := .T.
			EndIf
		EndIf
		If lRet
			nDescon += (cAliasQry)->D2_DESCON
			lAgreg := (cAliasQry)->F4_AGREG $"I|D" //Se for ICMS+Mer, subtrai o valor do ICMS do D2_VALBRUT
			//If !(Alltrim((cAliasQry)->D2_TIPO)== "I") .Or. (Alltrim((cAliasQry)->D2_TIPO)== "I" .And.(cAliasQry)->D2_ICMSRET > 0)
				If lAgreg  
					If (cAliasQry)->D2_ICMSRET > 0  // deduzir o valor do icms só quando for ST 
						lDedICM := .T.
						nFatBrut += (cAliasQry)->D2_VALBRUT + (cAliasQry)->D2_DESCON //Variavel que retornar o valor bruto das notas(considera frete seguro e despesa) 
						nFatLiq +=(cAliasQry)->D2_TOTAL + (cAliasQry)->D2_VALFRE + (cAliasQry)->D2_SEGURO + (cAliasQry)->D2_DESPESA + (cAliasQry)->D2_VALICM  //Variavel que retornar o valor liquido das notas 
						If SubStr((cAliasQry)->D2_CF,1,1) == "7" 
							nFatExp += (cAliasQry)->D2_VALBRUT
							nFatLiqExp += (cAliasQry)->D2_TOTAL + (cAliasQry)->D2_VALFRE + (cAliasQry)->D2_SEGURO + (cAliasQry)->D2_DESPESA -(cAliasQry)->D2_ICMSRET 
						EndIf	
						aAdd(aFatDes,{(cAliasQry)->D2_DOC,(cAliasQry)->D2_SERIE,(cAliasQry)->D2_TIPO,(cAliasQry)->D2_EMISSAO,(cAliasQry)->D2_TOTAL +; 
								(cAliasQry)->D2_VALFRE + (cAliasQry)->D2_SEGURO + (cAliasQry)->D2_DESPESA , (cAliasQry)->D2_NFORI,(cAliasQry)->D2_SERIORI, (cAliasQry)->D2_CF,(cAliasQry)->D2_ITEM,cEspecie,(cAliasQry)->D2_VALBRUT,"","", iIF(lD2CtaRec .And. !Empty((cAliasQry)->D2_CTAREC),(cAliasQry)->D2_CTAREC,(cAliasQry)->D2_CONTA)})
					Else
						//Quando for ICMS normal e agrega valor I|D o valor do ICMS é incorporado ao preço de venda.
						lDedICM := .F.
						nFatBrut += (cAliasQry)->D2_VALBRUT + (cAliasQry)->D2_DESCON
						nFatLiq +=(cAliasQry)->D2_VALBRUT - (cAliasQry)->D2_VALIPI //Variavel que retornar o valor liquido das notas 
						If SubStr((cAliasQry)->D2_CF,1,1) == "7" 
							nFatExp += (cAliasQry)->D2_VALBRUT
							nFatLiqExp += (cAliasQry)->D2_VALBRUT - (cAliasQry)->D2_VALIPI
						EndIf	
						aAdd(aFatDes,{(cAliasQry)->D2_DOC,(cAliasQry)->D2_SERIE,(cAliasQry)->D2_TIPO,(cAliasQry)->D2_EMISSAO,(cAliasQry)->D2_VALBRUT - (cAliasQry)->D2_VALIPI,; 
								(cAliasQry)->D2_NFORI,(cAliasQry)->D2_SERIORI, (cAliasQry)->D2_CF,(cAliasQry)->D2_ITEM,cEspecie,(cAliasQry)->D2_VALBRUT,"","", iIF(lD2CtaRec .And. !Empty((cAliasQry)->D2_CTAREC),(cAliasQry)->D2_CTAREC,(cAliasQry)->D2_CONTA)})
					EndIf			
				Else
					nFatBrut += (cAliasQry)->D2_VALBRUT + (cAliasQry)->D2_DESCON //Variavel que retornar o valor bruto das notas(considera frete seguro e despesa) 
					nFatLiq +=(cAliasQry)->D2_TOTAL + (cAliasQry)->D2_VALFRE + (cAliasQry)->D2_SEGURO + (cAliasQry)->D2_DESPESA    //Variavel que retornar o valor liquido das notas 
					If SubStr((cAliasQry)->D2_CF,1,1) == "7" .Or. Alltrim((cAliasQry)->D2_CF) $ cExpCfop
						nFatExp += (cAliasQry)->D2_VALBRUT
						nFatLiqExp += (cAliasQry)->D2_TOTAL + (cAliasQry)->D2_VALFRE + (cAliasQry)->D2_SEGURO + (cAliasQry)->D2_DESPESA
					EndIf	
					aAdd(aFatDes,{(cAliasQry)->D2_DOC,(cAliasQry)->D2_SERIE,(cAliasQry)->D2_TIPO,(cAliasQry)->D2_EMISSAO,(cAliasQry)->D2_TOTAL +; 
							(cAliasQry)->D2_VALFRE + (cAliasQry)->D2_SEGURO + (cAliasQry)->D2_DESPESA, (cAliasQry)->D2_NFORI,(cAliasQry)->D2_SERIORI, (cAliasQry)->D2_CF,(cAliasQry)->D2_ITEM,cEspecie,(cAliasQry)->D2_VALBRUT,"","", iIF(lD2CtaRec .And. !Empty((cAliasQry)->D2_CTAREC),(cAliasQry)->D2_CTAREC,(cAliasQry)->D2_CONTA)})
				EndIf			
			//	EndIf 
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄp¿
			//³Verifico se a data da emissão do item, está entre algum código de atividade valido,        |
			//|pois se não estiver, não será validado com cod de atividade. 		  					  ³
			//³Poderá existir mais de um código de atividade com datas de validade distintas              ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄpÙ
			lCodAtiVld := .F. 
			If !Empty((cAliasQry)->B5_CODATIV) .And. lDtIniCG1 .And. lTmpCG1
				If (cTmpCG1)->(MsSeek(cFilCg1+(cAliasQry)->B5_CODATIV))
					While !(cTmpCG1)->(Eof()) .And. (cTmpCG1)->CG1_CODIGO == (cAliasQry)->B5_CODATIV
						If (cTmpCG1)->CG1_DTINI <= Stod((cAliasQry)->D2_EMISSAO) .AND. ((cTmpCG1)->(CG1_DTFIM) >= Stod((cAliasQry)->D2_EMISSAO) .OR. EMPTY((cTmpCG1)->(CG1_DTFIM)) .OR. (cAliasQry)->B5_CODATIV == '99999999')
								lCodAtiVld := .T. 
								Exit 
						EndIf 
						(cTmpCG1)->(dbSkip())
					EndDo
				EndIf
			Else
				lDtIniCG1 := .F.
			EndIf
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Tratamento para complemento de IPI                                                                                 		³
			//³Somo o valor do imposto no valor bruto pois é um complemento da NF Original, que na geração nã teve este imposto.	        ³
			//³Somando esse valor no valbrut para calculo da deson, ele considera esse valor apenas como exclusão e não como b. de calculo  ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			nVlrLiqExp := (cAliasQry)->D2_TOTAL + (cAliasQry)->D2_VALFRE + (cAliasQry)->D2_SEGURO + (cAliasQry)->D2_DESPESA
			aFatDes[Len(aFatDes)][12]:= (cAliasQry)->B5_CODATIV
			If !Empty((cAliasQry)->B5_CODATIV) .And. lDtIniCG1
				If Alltrim((cAliasQry)->D2_TIPO)== "P" .And. lCodAtiVld  
					If (cAliasQry)->B5_INSPAT == "1"
						If lAgrCtaCtb 
							nPosFis := aScan(aTotFis,{|x| Alltrim(x[1]) == Alltrim((cAliasQry)->B5_CODATIV) .And. x[9] == iIF(lD2CtaRec .And. !Empty((cAliasQry)->D2_CTAREC),(cAliasQry)->D2_CTAREC,(cAliasQry)->D2_CONTA)})
						Else	
							nPosFis := aScan(aTotFis,{|x| Alltrim(x[1]) == Alltrim((cAliasQry)->B5_CODATIV)})
						EndIf	
						If STOD((cAliasQry)->D2_EMISSAO) >= CTOD("01"+"/"+SUBSTR(cIniDes,5,6)+"/"+SUBSTR(cIniDes,1,4))
							If nPosFis == 0
								aAdd(aTotFis,{(cAliasQry)->B5_CODATIV,(cAliasQry)->D2_TOTAL,0,0,Iif(lAgreg .And. lDedICM,(cAliasQry)->D2_ICMSRET,0),0,0,0,iIF(lD2CtaRec .And. !Empty((cAliasQry)->D2_CTAREC),(cAliasQry)->D2_CTAREC,(cAliasQry)->D2_CONTA) })
							Else
								aTotFis[nPosFis][2]+=(cAliasQry)->D2_TOTAL 
							EndIf
						EndIf	
					EndIf                                                                         			   	
				ElseIf lCodAtiVld  
					If SubStr((cAliasQry)->D2_CF,1,1) <> "7" .And. !(Alltrim((cAliasQry)->D2_CF) $ cExpCfop) .AND. ((cAliasQry)->B5_INSPAT == "1")
						If (((cAliasQry)->B5_VERIND == "1" .And. AllTrim((cAliasQry)->D2_CF) $ cCFIND) .OR. (cAliasQry)->B5_VERIND <> "1")
						
							//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
							//³Soma os valores por codigo de atividade no array aTotFis³
							//³[1] Código de atividade                                 ³
							//³[2] Valor Bruto por código atividade                    ³
							//³[3] Valor Bruto Exportação por código de atividade      ³
							//³[4] Valor liq + frete + seguro + despesa                ³
							//³[5] F4_AGREG =I/D o valor do ICMS é somado ao vlr bruto.³
							//³[6] IPI das EXPORT deduz impost pois TCATVEXP ja tem IPI³
							//³[7] Valor Liquido Exportação por código de atividade    ³
							//³[8] Valor de Desconto										   ³
							//³[9] Conta Contábil de Receita							   ³
							//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
							If lAgrCtaCtb 
								nPosFis := aScan(aTotFis,{|x| Alltrim(x[1]) == Alltrim((cAliasQry)->B5_CODATIV) .And. x[9] == iIF(lD2CtaRec .And. !Empty((cAliasQry)->D2_CTAREC),(cAliasQry)->D2_CTAREC,(cAliasQry)->D2_CONTA)})
							Else
								nPosFis := aScan(aTotFis,{|x| Alltrim(x[1]) == Alltrim((cAliasQry)->B5_CODATIV)})
							EndIf	
							If nPosFis == 0
								aAdd(aTotFis,{(cAliasQry)->B5_CODATIV,(cAliasQry)->D2_VALBRUT + (cAliasQry)->D2_DESCON, 0,(cAliasQry)->D2_TOTAL + (cAliasQry)->D2_VALFRE + (cAliasQry)->D2_SEGURO + (cAliasQry)->D2_DESPESA, Iif(lAgreg .And. lDedICM,(cAliasQry)->D2_ICMSRET,0),;
										(cAliasQry)->D2_VALIPI,0,(cAliasQry)->D2_DESCON, iIF(lD2CtaRec .And. !Empty((cAliasQry)->D2_CTAREC),(cAliasQry)->D2_CTAREC,(cAliasQry)->D2_CONTA)})
							Else
								aTotFis[nPosFis][2]+= (cAliasQry)->D2_VALBRUT + (cAliasQry)->D2_DESCON
								aTotFis[nPosFis][4]+= (cAliasQry)->D2_TOTAL + (cAliasQry)->D2_VALFRE + (cAliasQry)->D2_SEGURO + (cAliasQry)->D2_DESPESA
								aTotFis[nPosFis][5]+= Iif(lAgreg .And. lDedICM,(cAliasQry)->D2_ICMSRET,0)
								aTotFis[nPosFis][6]+= (cAliasQry)->D2_VALIPI
								aTotFis[nPosFis][8]+= (cAliasQry)->D2_DESCON
							EndIf
						Else 
							If lAgrCtaCtb 
								nPosFis := aScan(aTotFis,{|x| Alltrim(x[1]) == Alltrim((cAliasQry)->B5_CODATIV) .And. x[9] == iIF(lD2CtaRec .And. !Empty((cAliasQry)->D2_CTAREC),(cAliasQry)->D2_CTAREC,(cAliasQry)->D2_CONTA)})
							Else
								nPosFis := aScan(aTotFis,{|x| Alltrim(x[1]) == Alltrim((cAliasQry)->B5_CODATIV)})
							EndIf
							If nPosFis == 0
								aAdd(aTotFis,{(cAliasQry)->B5_CODATIV,(cAliasQry)->D2_VALBRUT + (cAliasQry)->D2_DESCON, 0,(cAliasQry)->D2_TOTAL + (cAliasQry)->D2_VALFRE + (cAliasQry)->D2_SEGURO + (cAliasQry)->D2_DESPESA, Iif(lAgreg .And. lDedICM,(cAliasQry)->D2_ICMSRET,0),;
										(cAliasQry)->D2_VALIPI,0,(cAliasQry)->D2_DESCON, iIF(lD2CtaRec .And. !Empty((cAliasQry)->D2_CTAREC),(cAliasQry)->D2_CTAREC,(cAliasQry)->D2_CONTA)})
							Else
								aTotFis[nPosFis][2]+= (cAliasQry)->D2_VALBRUT + (cAliasQry)->D2_DESCON
								aTotFis[nPosFis][4]+= (cAliasQry)->D2_TOTAL + (cAliasQry)->D2_VALFRE + (cAliasQry)->D2_SEGURO + (cAliasQry)->D2_DESPESA
								aTotFis[nPosFis][5]+= Iif(lAgreg .And. lDedICM,(cAliasQry)->D2_ICMSRET,0)
								aTotFis[nPosFis][6]+= (cAliasQry)->D2_VALIPI
								aTotFis[nPosFis][8]+= (cAliasQry)->D2_DESCON
							EndIf
						EndIf	 		
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³Verifico a exportações que possuem codigo de atividade e³
					//³Atribuo a posição 3 do array                            ³ 
					//³Atribui valor do IPI as EXPORT posição 6 do array       ³ 
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					ElseIf SubStr((cAliasQry)->D2_CF,1,1) == "7" .Or. Alltrim((cAliasQry)->D2_CF) $ cExpCfop
						If (cAliasQry)->B5_INSPAT == "1"
							If (((cAliasQry)->B5_VERIND == "1" .And. AllTrim((cAliasQry)->D2_CF) $cCFIND) .OR. (cAliasQry)->B5_VERIND <> "1")
													
								If lAgrCtaCtb 
									nPosExp := aScan(aTotFis,{|x| Alltrim(x[1]) == Alltrim((cAliasQry)->B5_CODATIV) .And. x[9] == iIF(lD2CtaRec .And. !Empty((cAliasQry)->D2_CTAREC),(cAliasQry)->D2_CTAREC,(cAliasQry)->D2_CONTA)})
								Else
									nPosExp := aScan(aTotFis,{|x| Alltrim(x[1]) == Alltrim((cAliasQry)->B5_CODATIV)})
								EndIf

								If nPosExp == 0
									aAdd(aTotFis,{(cAliasQry)->B5_CODATIV,(cAliasQry)->D2_VALBRUT,(cAliasQry)->D2_VALBRUT,(cAliasQry)->D2_TOTAL + (cAliasQry)->D2_VALFRE + (cAliasQry)->D2_SEGURO + (cAliasQry)->D2_DESPESA, Iif(lAgreg .And. lDedICM,(cAliasQry)->D2_ICMSRET,0),;
												(cAliasQry)->D2_VALIPI,nVlrLiqExp,(cAliasQry)->D2_DESCON, iIF(lD2CtaRec .And. !Empty((cAliasQry)->D2_CTAREC),(cAliasQry)->D2_CTAREC,(cAliasQry)->D2_CONTA)})
								Else
									aTotFis[nPosExp][2]+= (cAliasQry)->D2_VALBRUT
									aTotFis[nPosExp][3]+= (cAliasQry)->D2_VALBRUT
									aTotFis[nPosExp][4]+= (cAliasQry)->D2_TOTAL + (cAliasQry)->D2_VALFRE + (cAliasQry)->D2_SEGURO + (cAliasQry)->D2_DESPESA
									aTotFis[nPosExp][5]+= Iif(lAgreg .And. lDedICM,(cAliasQry)->D2_ICMSRET,0)
									aTotFis[nPosExp][6]+= (cAliasQry)->D2_VALIPI
									aTotFis[nPosExp][7]+= nVlrLiqExp
									aTotFis[nPosExp][8]+= (cAliasQry)->D2_DESCON
								EndIf
							Else
								If lAgrCtaCtb 
									nPosExp := aScan(aTotFis,{|x| Alltrim(x[1]) == Alltrim((cAliasQry)->B5_CODATIV) .And. x[9] == iIF(lD2CtaRec .And. !Empty((cAliasQry)->D2_CTAREC),(cAliasQry)->D2_CTAREC,(cAliasQry)->D2_CONTA)})
								Else
									nPosExp := aScan(aTotFis,{|x| Alltrim(x[1]) == Alltrim((cAliasQry)->B5_CODATIV)})
								EndIf
								If nPosExp == 0
									aAdd(aTotFis,{(cAliasQry)->B5_CODATIV,(cAliasQry)->D2_VALBRUT,(cAliasQry)->D2_VALBRUT,(cAliasQry)->D2_TOTAL + (cAliasQry)->D2_VALFRE + (cAliasQry)->D2_SEGURO + (cAliasQry)->D2_DESPESA, Iif(lAgreg .And. lDedICM,(cAliasQry)->D2_ICMSRET,0),;
												(cAliasQry)->D2_VALIPI,nVlrLiqExp,(cAliasQry)->D2_DESCON, iIF(lD2CtaRec .And. !Empty((cAliasQry)->D2_CTAREC),(cAliasQry)->D2_CTAREC,(cAliasQry)->D2_CONTA)})
								Else
									aTotFis[nPosExp][2]+= (cAliasQry)->D2_VALBRUT
									aTotFis[nPosExp][3]+= (cAliasQry)->D2_VALBRUT
									aTotFis[nPosExp][4]+= (cAliasQry)->D2_TOTAL + (cAliasQry)->D2_VALFRE + (cAliasQry)->D2_SEGURO + (cAliasQry)->D2_DESPESA
									aTotFis[nPosExp][5]+= Iif(lAgreg .And. lDedICM,(cAliasQry)->D2_ICMSRET,0)
									aTotFis[nPosExp][6]+= (cAliasQry)->D2_VALIPI
									aTotFis[nPosExp][7]+= nVlrLiqExp
									aTotFis[nPosExp][8]+= (cAliasQry)->D2_DESCON
								EndIf
							EndIf	
						EndIf	
					EndIf
				EndIf
			Else
				If !Empty((cAliasQry)->B5_CODATIV) .And. Alltrim((cAliasQry)->D2_TIPO)== "P"   
					If (cAliasQry)->B5_INSPAT == "1"
						If lAgrCtaCtb 
							nPosFis := aScan(aTotFis,{|x| Alltrim(x[1]) == Alltrim((cAliasQry)->B5_CODATIV) .And. x[9] == iIF(lD2CtaRec .And. !Empty((cAliasQry)->D2_CTAREC),(cAliasQry)->D2_CTAREC,(cAliasQry)->D2_CONTA)})
						Else
							nPosFis := aScan(aTotFis,{|x| Alltrim(x[1]) == Alltrim((cAliasQry)->B5_CODATIV)})
						EndIf
						If STOD((cAliasQry)->D2_EMISSAO) >= CTOD("01"+"/"+SUBSTR(cIniDes,5,6)+"/"+SUBSTR(cIniDes,1,4))
							If nPosFis == 0
								aAdd(aTotFis,{(cAliasQry)->B5_CODATIV,(cAliasQry)->D2_TOTAL,0,0,Iif(lAgreg .And. lDedICM,(cAliasQry)->D2_ICMSRET,0),(cAliasQry)->D2_VALIPI, 0, 0 ,iIF(lD2CtaRec .And. !Empty((cAliasQry)->D2_CTAREC),(cAliasQry)->D2_CTAREC,(cAliasQry)->D2_CONTA)})
							Else
								aTotFis[nPosFis][2]+=(cAliasQry)->D2_TOTAL 
							EndIf
						EndIf	
					EndIf                                                                         			   	
				ElseIf !Empty((cAliasQry)->B5_CODATIV)
					If SubStr((cAliasQry)->D2_CF,1,1) <> "7" .And. !(Alltrim((cAliasQry)->D2_CF) $ cExpCfop) .AND. (cAliasQry)->B5_INSPAT == "1"
						If (((cAliasQry)->B5_VERIND == "1" .And. AllTrim((cAliasQry)->D2_CF) $cCFIND) .OR. (cAliasQry)->B5_VERIND <> "1")
							//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
							//³Soma os valores por codigo de atividade no array aTotFis³
							//³[1] Código de atividade                                 ³
							//³[2] Valor Bruto por código atividade                    ³
							//³[3] Valor Bruto Exportação por código de atividade      ³
							//³[4] Valor liq + frete + seguro + despesa                ³
							//³[5] F4_AGREG =I/D o valor do ICMS é somado ao vlr bruto.³
							//³[6] IPI das EXPORT deduz impost pois TCATVEXP ja tem IPI³
							//³[7] Valor Liquido Exportação por código de atividade    ³
							//³[8] Valor de Desconto										   ³
							//³[9] Conta Contábil de Receita							   ³
							//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
							If lAgrCtaCtb 
								nPosFis := aScan(aTotFis,{|x| Alltrim(x[1]) == Alltrim((cAliasQry)->B5_CODATIV) .And. x[9] == iIF(lD2CtaRec .And. !Empty((cAliasQry)->D2_CTAREC),(cAliasQry)->D2_CTAREC,(cAliasQry)->D2_CONTA)})
							Else
								nPosFis := aScan(aTotFis,{|x| Alltrim(x[1]) == Alltrim((cAliasQry)->B5_CODATIV)})
							EndIf
							If nPosFis == 0
								aAdd(aTotFis,{(cAliasQry)->B5_CODATIV,(cAliasQry)->D2_VALBRUT + (cAliasQry)->D2_DESCON, 0,(cAliasQry)->D2_TOTAL + (cAliasQry)->D2_VALFRE + (cAliasQry)->D2_SEGURO + (cAliasQry)->D2_DESPESA, Iif(lAgreg .And. lDedICM,(cAliasQry)->D2_ICMSRET,0),;
											(cAliasQry)->D2_VALIPI,0,(cAliasQry)->D2_DESCON, iIF(lD2CtaRec .And. !Empty((cAliasQry)->D2_CTAREC),(cAliasQry)->D2_CTAREC,(cAliasQry)->D2_CONTA)})
							Else
								aTotFis[nPosFis][2]+=(cAliasQry)->D2_VALBRUT + (cAliasQry)->D2_DESCON
								aTotFis[nPosFis][4]+=(cAliasQry)->D2_TOTAL + (cAliasQry)->D2_VALFRE + (cAliasQry)->D2_SEGURO + (cAliasQry)->D2_DESPESA
								aTotFis[nPosFis][5]+= Iif(lAgreg .And. lDedICM,(cAliasQry)->D2_ICMSRET,0)
								aTotFis[nPosFis][6]+= (cAliasQry)->D2_VALIPI
								aTotFis[nPosFis][8]+= (cAliasQry)->D2_DESCON
							EndIf
						Else 
							If lAgrCtaCtb 
								nPosFis := aScan(aTotFis,{|x| Alltrim(x[1]) == Alltrim((cAliasQry)->B5_CODATIV) .And. x[9] == iIF(lD2CtaRec .And. !Empty((cAliasQry)->D2_CTAREC),(cAliasQry)->D2_CTAREC,(cAliasQry)->D2_CONTA)})
							Else
								nPosFis := aScan(aTotFis,{|x| Alltrim(x[1]) == Alltrim((cAliasQry)->B5_CODATIV)})
							EndIf
							If nPosFis == 0
								aAdd(aTotFis,{(cAliasQry)->B5_CODATIV,(cAliasQry)->D2_VALBRUT, 0,(cAliasQry)->D2_TOTAL + (cAliasQry)->D2_VALFRE + (cAliasQry)->D2_SEGURO + (cAliasQry)->D2_DESPESA, Iif(lAgreg .And. lDedICM,(cAliasQry)->D2_ICMSRET,0),;
											(cAliasQry)->D2_VALIPI,0,(cAliasQry)->D2_DESCON, iIF(lD2CtaRec .And. !Empty((cAliasQry)->D2_CTAREC),(cAliasQry)->D2_CTAREC,(cAliasQry)->D2_CONTA)})
							Else
								aTotFis[nPosFis][2]+= (cAliasQry)->D2_VALBRUT + (cAliasQry)->D2_DESCON
								aTotFis[nPosFis][4]+= (cAliasQry)->D2_TOTAL + (cAliasQry)->D2_VALFRE + (cAliasQry)->D2_SEGURO + (cAliasQry)->D2_DESPESA
								aTotFis[nPosFis][5]+= Iif(lAgreg .And. lDedICM,(cAliasQry)->D2_ICMSRET,0)
								aTotFis[nPosFis][6]+= (cAliasQry)->D2_VALIPI
								aTotFis[nPosFis][8]+= (cAliasQry)->D2_DESCON
							EndIf
						EndIf	 		
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³Verifico a exportações que possuem codigo de atividade e³
					//³atribuo a posição 3 do array                            ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					ElseIf SubStr((cAliasQry)->D2_CF,1,1) == "7" .Or. Alltrim((cAliasQry)->D2_CF) $ cExpCfop
						If (cAliasQry)->B5_INSPAT == "1"
							If (((cAliasQry)->B5_VERIND == "1" .And. AllTrim((cAliasQry)->D2_CF) $cCFIND) .OR. (cAliasQry)->B5_VERIND <> "1")
								If lAgrCtaCtb 
									nPosExp := aScan(aTotFis,{|x| Alltrim(x[1]) == Alltrim((cAliasQry)->B5_CODATIV) .And. x[9] == iIF(lD2CtaRec .And. !Empty((cAliasQry)->D2_CTAREC),(cAliasQry)->D2_CTAREC,(cAliasQry)->D2_CONTA)})
								Else
									nPosExp := aScan(aTotFis,{|x| Alltrim(x[1]) == Alltrim((cAliasQry)->B5_CODATIV)})
								EndIf
								If nPosExp == 0
									aAdd(aTotFis,{(cAliasQry)->B5_CODATIV,(cAliasQry)->D2_VALBRUT,(cAliasQry)->D2_VALBRUT,(cAliasQry)->D2_TOTAL + (cAliasQry)->D2_VALFRE + (cAliasQry)->D2_SEGURO + (cAliasQry)->D2_DESPESA, Iif(lAgreg .And. lDedICM,(cAliasQry)->D2_ICMSRET,0),;
											(cAliasQry)->D2_VALIPI,nVlrLiqExp,(cAliasQry)->D2_DESCON, iIF(lD2CtaRec .And. !Empty((cAliasQry)->D2_CTAREC),(cAliasQry)->D2_CTAREC,(cAliasQry)->D2_CONTA)})
								Else
									aTotFis[nPosExp][2]+= (cAliasQry)->D2_VALBRUT
									aTotFis[nPosExp][3]+= (cAliasQry)->D2_VALBRUT
									aTotFis[nPosExp][4]+= (cAliasQry)->D2_TOTAL + (cAliasQry)->D2_VALFRE + (cAliasQry)->D2_SEGURO + (cAliasQry)->D2_DESPESA
									aTotFis[nPosExp][5]+= Iif(lAgreg .And. lDedICM,(cAliasQry)->D2_ICMSRET,0)
									aTotFis[nPosExp][6]+= (cAliasQry)->D2_VALIPI
									aTotFis[nPosExp][7]+= nVlrLiqExp
									aTotFis[nPosExp][8]+= (cAliasQry)->D2_DESCON
								EndIf
							Else
								If lAgrCtaCtb 
									nPosExp := aScan(aTotFis,{|x| Alltrim(x[1]) == Alltrim((cAliasQry)->B5_CODATIV) .And. x[9] == iIF(lD2CtaRec .And. !Empty((cAliasQry)->D2_CTAREC),(cAliasQry)->D2_CTAREC,(cAliasQry)->D2_CONTA)})
								Else
									nPosExp := aScan(aTotFis,{|x| Alltrim(x[1]) == Alltrim((cAliasQry)->B5_CODATIV)})
								EndIf
								If nPosExp == 0
									aAdd(aTotFis,{(cAliasQry)->B5_CODATIV,(cAliasQry)->D2_VALBRUT,(cAliasQry)->D2_VALBRUT,(cAliasQry)->D2_TOTAL + (cAliasQry)->D2_VALFRE + (cAliasQry)->D2_SEGURO + (cAliasQry)->D2_DESPESA, Iif(lAgreg .And. lDedICM,(cAliasQry)->D2_ICMSRET,0),;
											(cAliasQry)->D2_VALIPI,nVlrLiqExp,(cAliasQry)->D2_DESCON, iIF(lD2CtaRec .And. !Empty((cAliasQry)->D2_CTAREC),(cAliasQry)->D2_CTAREC,(cAliasQry)->D2_CONTA)})
								Else
									aTotFis[nPosExp][2]+= (cAliasQry)->D2_VALBRUT
									aTotFis[nPosExp][3]+= (cAliasQry)->D2_VALBRUT
									aTotFis[nPosExp][4]+= (cAliasQry)->D2_TOTAL + (cAliasQry)->D2_VALFRE + (cAliasQry)->D2_SEGURO + (cAliasQry)->D2_DESPESA
									aTotFis[nPosExp][5]+= Iif(lAgreg .And. lDedICM,(cAliasQry)->D2_ICMSRET,0)
									aTotFis[nPosExp][6]+= (cAliasQry)->D2_VALIPI
									aTotFis[nPosExp][7]+= nVlrLiqExp
									aTotFis[nPosExp][8]+= (cAliasQry)->D2_DESCON
								EndIf
							EndIf	
						EndIf	
					EndIf
				EndIf	 
			EndIf							 	 
		EndIf
		(cAliasQry)->(dbSkip())	
	EndDo 
	(cAliasQry)->(dbCloseArea())
   
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Processamento das notas de devolução³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
   	
	cQueryD1 := " SELECT D1_ITEM, D1_DOC, D1_SERIE, D1_COD, D1_TIPO, D1_TOTAL, D1_VALDESC, D1_CF, D1_EMISSAO,D1_DTDIGIT, D1_NFORI, D1_SERIORI, D1_FORNECE, D1_LOJA, D1_ITEMORI, "
	cQueryD1 += " D1_VALDESC, D1_VALFRE, D1_SEGURO, D1_DESPESA, D1_VALIPI, D1_ICMSRET, D1_ORIGLAN, B5_CODATIV, B5_INSPAT, B5_VERIND " 
	cQueryD1 += " FROM " + RetSqlName( "SD1" ) + " SD1 "
	cQueryD1 += " LEFT JOIN " + RetSQLName("SB5") +" SB5 ON "			
	cQueryD1 += " SB5.B5_FILIAL = '" + cFilSb5 + "' AND "
	cQueryD1 += " SB5.B5_COD = SD1.D1_COD AND "
	cQueryD1 += " SB5.D_E_L_E_T_ = ' ' "
	cQueryD1 += " WHERE "
	cQueryD1 += " SD1.D1_FILIAL = '"  + cFilSd1 + "' AND "
	cQueryD1 += " SD1.D1_TIPO IN ('D','C','P') AND "
    cQueryD1 += " SD1.D1_DTDIGIT BETWEEN '"+DTOS(dPerIni)+"' AND '"+DTOS(dPerFim)+"' AND " 
	cQueryD1 += " SD1.D1_TES <> ' ' AND "  		    
	cQueryD1 += " SD1.D_E_L_E_T_ = ' ' "
	cQueryD1 += " ORDER BY SD1.D1_FILIAL, SD1.D1_COD, SD1.D1_DOC, SD1.D1_SERIE "	
	
	cQueryD1 := ChangeQuery( cQueryD1 )
	dbUseArea( .T., "TOPCONN", TcGenQry( ,,cQueryD1 ), cAliasSD1, .F., .T. )		

	While !(cAliasSD1)->(Eof())
		lComplD1 := .F.
		lDevolLj := .F.
		cEspecie := ""
		If SF1->(MsSeek(cFilSf1 + (cAliasSD1)->D1_DOC + (cAliasSD1)->D1_SERIE))
			cEspecie := SF1->F1_ESPECIE
		EndIf
		If !(cAliasSD1)->D1_TIPO $ "D|N"
			If SD1->(MsSeek(cFilSd1+ (cAliasSD1)->D1_NFORI + (cAliasSD1)->D1_SERIORI))
				cNFOrig  := SD1->D1_NFORI
				cSerOrig := SD1->D1_SERIORI
				lComplD1 := .T.
			EndIf
		EndIf	
		//Se a devolução for feita pelo SIGALOJA não utiliza D1_FORNECE/D1_LOJA, pois a devolução pode ser feita com códigos diferentes.
		If !lComplD1 .And. (cAliasSD1)->D1_ORIGLAN == "LO"
			lComplD1 := .T.
			lDevolLj := .T.
		EndIf
		SD2->(dbSetOrder(3))//D2_FILIAL+D2_DOC+D2_SERIE+D2_CLIENTE+D2_LOJA+D2_COD+D2_ITEM 
		If Iif(!lComplD1, SD2->(MsSeek(cFilSd2+(cAliasSD1)->D1_NFORI + (cAliasSD1)->D1_SERIORI+ (cAliasSD1)->D1_FORNECE + (cAliasSD1)->D1_LOJA + (cAliasSD1)->D1_COD + (cAliasSD1)->D1_ITEMORI)),;
			IIf(!lDevolLj, SD2->(MsSeek(cFilSd2+cNFOrig+cSerOrig+(cAliasSD1)->D1_FORNECE+(cAliasSD1)->D1_LOJA)), SD2->(MsSeek(cFilSd2+(cAliasSD1)->D1_NFORI+(cAliasSD1)->D1_SERIORI))))
			If (Alltrim(SD2->D2_CF)$ aCFOPs[1] .And. !Alltrim(SD2->D2_CF)$ aCFOPs[2]) .And. SD2->D2_EMISSAO >= CTOD("01"+"/"+SUBSTR(cIniDes,5,6)+"/"+SUBSTR(cIniDes,1,4))
				nTotDevBrt	:= (cAliasSD1)->D1_TOTAL + (cAliasSD1)->D1_VALIPI + (cAliasSD1)->D1_ICMSRET //variavel que ira acumular o valo total de Notas de devolução (considera frete seguro e despesa)
			   	If SubStr(SD2->D2_CF,1,1) <> "7" .And. !(Alltrim(SD2->D2_CF) $ cExpCfop)
			    	nTotDev	+= ((cAliasSD1)->D1_TOTAL - (cAliasSD1)->D1_VALDESC) + (cAliasSD1)->D1_VALFRE + (cAliasSD1)->D1_SEGURO + (cAliasSD1)->D1_DESPESA +; 
			    				(cAliasSD1)->D1_VALIPI + (cAliasSD1)->D1_ICMSRET //variavel que ira acumular o valo total de Notas de devolução (considera frete seguro e despesa)
				    nTotLiqDev += ((cAliasSD1)->D1_TOTAL - (cAliasSD1)->D1_VALDESC) + (cAliasSD1)->D1_VALFRE + (cAliasSD1)->D1_SEGURO + (cAliasSD1)->D1_DESPESA
				EndIf    
		    	aAdd(aFatDes,{(cAliasSD1)->D1_DOC,(cAliasSD1)->D1_SERIE,(cAliasSD1)->D1_TIPO,(cAliasSD1)->D1_DTDIGIT,((cAliasSD1)->D1_TOTAL - (cAliasSD1)->D1_VALDESC) + (cAliasSD1)->D1_VALFRE + (cAliasSD1)->D1_SEGURO + (cAliasSD1)->D1_DESPESA,;
		  					(cAliasSD1)->D1_NFORI,(cAliasSD1)->D1_SERIORI, (cAliasSD1)->D1_CF,(cAliasSD1)->D1_ITEM,cEspecie,nTotDevBrt,"",(cAliasSD1)->D1_ITEMORI, iIF(lD2CtaRec .And. !Empty(SD2->D2_CTAREC),SD2->D2_CTAREC,SD2->D2_CONTA)})			  			
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄp¿
				//³Verifico se a data da emissão do item, está entre algum código de atividade valido,        |
				//|pois se não estiver, não será validado com cod de atividade. 		  					  ³
				//³Poderá existir mais de um código de atividade com datas de validade distintas              ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄpÙ
			  	lCodAtiVld := .F.
			   	If !Empty((cAliasSD1)->B5_CODATIV) .And. lDtIniCG1
			   		If (cTmpCG1)->(MsSeek(cFilCg1+(cAliasSD1)->B5_CODATIV))
						While !(cTmpCG1)->(Eof()) .And. (cTmpCG1)->CG1_CODIGO == (cAliasSD1)->B5_CODATIV
							If ((cTmpCG1)->CG1_DTINI <= Stod((cAliasSD1)->D1_DTDIGIT) .AND. ((cTmpCG1)->CG1_DTFIM >= Stod((cAliasSD1)->D1_DTDIGIT) .OR. EMPTY((cTmpCG1)->CG1_DTFIM)))
								 lCodAtiVld := .T. 
								 Exit 
					   		EndIf 
							(cTmpCG1)->(dbSkip())
						EndDo
					EndIf
                Else
                	lDtIniCG1 := .F.
				EndIf
			 	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄd¿
				//³Se for complemento de ICMS ST ou complemento de IPI na devolução, adiciono o valor somente no valor bruto do ATOTFIS, ³
				//³ pois como impostos nao vão para desoneração, subtraio apenas no valor bruto do cod de atividade.			       	 ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄdÙ
				aFatDes[Len(aFatDes)][12]:= (cAliasSD1)->B5_CODATIV
				If !Empty((cAliasSD1)->B5_CODATIV) .And. lDtIniCG1
					If Alltrim((cAliasSD1)->D1_TIPO)== "P" .And. lCodAtiVld
					   If (cAliasSD1)->B5_INSPAT == "1"
					   		If lAgrCtaCtb 
								nPosFis := aScan(aTotFis,{|x| Alltrim(x[1]) == Alltrim((cAliasSD1)->B5_CODATIV) .And. x[9] == iIF(lD2CtaRec .And. !Empty(SD2->D2_CTAREC),SD2->D2_CTAREC,SD2->D2_CONTA)})
							Else
								nPosFis := aScan(aTotFis,{|x| Alltrim(x[1]) == Alltrim((cAliasSD1)->B5_CODATIV)})
							EndIf
					   		If STOD((cAliasSD1)->D1_DTDIGIT) >= CTOD("01"+"/"+SUBSTR(cIniDes,5,6)+"/"+SUBSTR(cIniDes,1,4))
						   		If nPosFis == 0
									aAdd(aTotFis,{(cAliasSD1)->B5_CODATIV,-(cAliasSD1)->D1_TOTAL,0,0, nVlrLiqExp,,,,iIF(lD2CtaRec .And. !Empty(SD2->D2_CTAREC),SD2->D2_CTAREC,SD2->D2_CONTA)})
								Else
									aTotFis[nPosFis][2]-=(cAliasSD1)->D1_TOTAL
								EndIf
							EndIf	
					  	EndIf
					ElseIf lCodAtiVld
						
						If SubStr(SD2->D2_CF,1,1) <> "7" .And. !(Alltrim(SD2->D2_CF) $ cExpCfop) .AND. (cAliasSD1)->B5_INSPAT == "1"					
					 	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³Soma os valores por codigo de atividade no array aTotFisDev ³
						//³[1] Código de atividade                                 	   ³
						//³[2] Valor Bruto devolução por código atividade              ³
						//³[3] Valor Bruto devolução de Exportação por cód de atividade³
						//³[4] Valor devolução liq + frete + seguro + despesa     	   ³
						//³[5] Valor Liqdo devolução de Exportação por cód de atividade³
						//³[6] Conta Contábil de receita									³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
							If (((cAliasSD1)->B5_VERIND == "1" .And. AllTrim(SD2->D2_CF) $cCFIND) .OR. (cAliasSD1)->B5_VERIND <> "1")						 	
								If lAgrCtaCtb 
									nPosFis := aScan(aTotFisDev,{|x| Alltrim(x[1]) == Alltrim((cAliasSD1)->B5_CODATIV) .And. x[6] == iIF(lD2CtaRec .And. !Empty(SD2->D2_CTAREC),SD2->D2_CTAREC,SD2->D2_CONTA)})
								Else
									nPosFis := aScan(aTotFisDev,{|x| Alltrim(x[1]) == Alltrim((cAliasSD1)->B5_CODATIV)})
								EndIf
								If nPosFis == 0
									aAdd(aTotFisDev,{(cAliasSD1)->B5_CODATIV,((cAliasSD1)->D1_TOTAL - (cAliasSD1)->D1_VALDESC + (cAliasSD1)->D1_VALFRE +; 
																(cAliasSD1)->D1_SEGURO + (cAliasSD1)->D1_DESPESA+ (cAliasSD1)->D1_VALIPI +; 
																(cAliasSD1)->D1_ICMSRET),0,(cAliasSD1)->D1_TOTAL - (cAliasSD1)->D1_VALDESC +; 
																(cAliasSD1)->D1_VALFRE + (cAliasSD1)->D1_SEGURO + (cAliasSD1)->D1_DESPESA , 0,iIF(lD2CtaRec .And. !Empty(SD2->D2_CTAREC),SD2->D2_CTAREC,SD2->D2_CONTA)})
								Else
									aTotFisDev[nPosFis][2]+=((cAliasSD1)->D1_TOTAL - (cAliasSD1)->D1_VALDESC + (cAliasSD1)->D1_VALFRE +; 
																(cAliasSD1)->D1_SEGURO + (cAliasSD1)->D1_DESPESA + (cAliasSD1)->D1_VALIPI + (cAliasSD1)->D1_ICMSRET)
									aTotFisDev[nPosFis][4]+=((cAliasSD1)->D1_TOTAL - (cAliasSD1)->D1_VALDESC + (cAliasSD1)->D1_VALFRE +; 
																(cAliasSD1)->D1_SEGURO + (cAliasSD1)->D1_DESPESA)						 
								EndIf
							Else 
								If lAgrCtaCtb 
									nPosFis := aScan(aTotFisDev,{|x| Alltrim(x[1]) == Alltrim((cAliasSD1)->B5_CODATIV) .And. x[6] == iIF(lD2CtaRec .And. !Empty(SD2->D2_CTAREC),SD2->D2_CTAREC,SD2->D2_CONTA)})
								Else
									nPosFis := aScan(aTotFisDev,{|x| Alltrim(x[1]) == Alltrim((cAliasSD1)->B5_CODATIV)})
								EndIf

								If nPosFis == 0
									aAdd(aTotFisDev,{(cAliasSD1)->B5_CODATIV,((cAliasSD1)->D1_TOTAL - (cAliasSD1)->D1_VALDESC + (cAliasSD1)->D1_VALFRE +; 
																(cAliasSD1)->D1_SEGURO + (cAliasSD1)->D1_DESPESA+ (cAliasSD1)->D1_VALIPI +; 
																(cAliasSD1)->D1_ICMSRET),0,(cAliasSD1)->D1_TOTAL - (cAliasSD1)->D1_VALDESC +; 
																(cAliasSD1)->D1_VALFRE + (cAliasSD1)->D1_SEGURO + (cAliasSD1)->D1_DESPESA , 0, iIF(lD2CtaRec .And. !Empty(SD2->D2_CTAREC),SD2->D2_CTAREC,SD2->D2_CONTA)})
								Else
									aTotFisDev[nPosFis][2]+=((cAliasSD1)->D1_TOTAL - (cAliasSD1)->D1_VALDESC + (cAliasSD1)->D1_VALFRE +; 
																(cAliasSD1)->D1_SEGURO + (cAliasSD1)->D1_DESPESA + (cAliasSD1)->D1_VALIPI + (cAliasSD1)->D1_ICMSRET)
									aTotFisDev[nPosFis][4]+=((cAliasSD1)->D1_TOTAL - (cAliasSD1)->D1_VALDESC + (cAliasSD1)->D1_VALFRE +; 
																(cAliasSD1)->D1_SEGURO + (cAliasSD1)->D1_DESPESA)						 
								EndIf
							EndIf
						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³Verifico as devoluções de exportações que possuem codigo de atividade e 	  ³
						//³atribuo a posição 3 do array aTotFisDev. Também será tratado itens de      |
						//| export por cod de ativ na posição 2 do aTotFisDev(Soma tot por cod ativ)  ³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						ElseIf SubStr(SD2->D2_CF,1,1) == "7" .Or. Alltrim(SD2->D2_CF) $ cExpCfop
							If (cAliasSD1)->B5_INSPAT == "1" 
								If (((cAliasSD1)->B5_VERIND == "1" .And. AllTrim(SD2->D2_CF) $cCFIND) .OR. (cAliasSD1)->B5_VERIND <> "1")						 	
									If lAgrCtaCtb 
										nPosFis := aScan(aTotFisDev,{|x| Alltrim(x[1]) == Alltrim((cAliasSD1)->B5_CODATIV) .And. x[6] == iIF(lD2CtaRec .And. !Empty(SD2->D2_CTAREC),SD2->D2_CTAREC,SD2->D2_CONTA)})
									Else
										nPosFis := aScan(aTotFisDev,{|x| Alltrim(x[1]) == Alltrim((cAliasSD1)->B5_CODATIV)})
									EndIf

									If nPosFis == 0
										aAdd(aTotFisDev,{(cAliasSD1)->B5_CODATIV,((cAliasSD1)->D1_TOTAL - (cAliasSD1)->D1_VALDESC + (cAliasSD1)->D1_VALFRE +;
										 				(cAliasSD1)->D1_SEGURO + (cAliasSD1)->D1_DESPESA + (cAliasSD1)->D1_VALIPI + (cAliasSD1)->D1_ICMSRET),;
										 				((cAliasSD1)->D1_TOTAL - (cAliasSD1)->D1_VALDESC + (cAliasSD1)->D1_VALFRE + (cAliasSD1)->D1_SEGURO +; 
										 				(cAliasSD1)->D1_DESPESA + (cAliasSD1)->D1_VALIPI + (cAliasSD1)->D1_ICMSRET),;
										 				0, (cAliasSD1)->D1_TOTAL - (cAliasSD1)->D1_VALDESC + (cAliasSD1)->D1_VALFRE +; 
																(cAliasSD1)->D1_SEGURO + (cAliasSD1)->D1_DESPESA,iIF(lD2CtaRec .And. !Empty(SD2->D2_CTAREC),SD2->D2_CTAREC,SD2->D2_CONTA) })									
									Else
										aTotFisDev[nPosFis][2]+=((cAliasSD1)->D1_TOTAL - (cAliasSD1)->D1_VALDESC + (cAliasSD1)->D1_VALFRE +; 
																(cAliasSD1)->D1_SEGURO + (cAliasSD1)->D1_DESPESA + (cAliasSD1)->D1_VALIPI + (cAliasSD1)->D1_ICMSRET)
										aTotFisDev[nPosFis][3]+=((cAliasSD1)->D1_TOTAL - (cAliasSD1)->D1_VALDESC + (cAliasSD1)->D1_VALFRE +; 
																(cAliasSD1)->D1_SEGURO + (cAliasSD1)->D1_DESPESA + (cAliasSD1)->D1_VALIPI + (cAliasSD1)->D1_ICMSRET)
										aTotFisDev[nPosFis][5]+=((cAliasSD1)->D1_TOTAL - (cAliasSD1)->D1_VALDESC + (cAliasSD1)->D1_VALFRE +; 
																(cAliasSD1)->D1_SEGURO + (cAliasSD1)->D1_DESPESA )
															
									EndIf
								Else
									If lAgrCtaCtb 
										nPosFis := aScan(aTotFisDev,{|x| Alltrim(x[1]) == Alltrim((cAliasSD1)->B5_CODATIV) .And. x[6] == iIF(lD2CtaRec .And. !Empty(SD2->D2_CTAREC),SD2->D2_CTAREC,SD2->D2_CONTA)})
									Else
										nPosFis := aScan(aTotFisDev,{|x| Alltrim(x[1]) == Alltrim((cAliasSD1)->B5_CODATIV)})
									EndIf
									
									If nPosFis == 0
										aAdd(aTotFisDev,{(cAliasSD1)->B5_CODATIV,((cAliasSD1)->D1_TOTAL - (cAliasSD1)->D1_VALDESC + (cAliasSD1)->D1_VALFRE +;
										 				(cAliasSD1)->D1_SEGURO + (cAliasSD1)->D1_DESPESA + (cAliasSD1)->D1_VALIPI + (cAliasSD1)->D1_ICMSRET),;
										 				((cAliasSD1)->D1_TOTAL - (cAliasSD1)->D1_VALDESC + (cAliasSD1)->D1_VALFRE + (cAliasSD1)->D1_SEGURO +; 
										 				(cAliasSD1)->D1_DESPESA + (cAliasSD1)->D1_VALIPI + (cAliasSD1)->D1_ICMSRET),;
										 				0,(cAliasSD1)->D1_TOTAL - (cAliasSD1)->D1_VALDESC + (cAliasSD1)->D1_VALFRE + (cAliasSD1)->D1_SEGURO + (cAliasSD1)->D1_DESPESA, iIF(lD2CtaRec .And. !Empty(SD2->D2_CTAREC),SD2->D2_CTAREC,SD2->D2_CONTA)})	
										 			   
									Else
										aTotFisDev[nPosFis][2]+=((cAliasSD1)->D1_TOTAL - (cAliasSD1)->D1_VALDESC + (cAliasSD1)->D1_VALFRE +; 
																(cAliasSD1)->D1_SEGURO + (cAliasSD1)->D1_DESPESA + (cAliasSD1)->D1_VALIPI + (cAliasSD1)->D1_ICMSRET)
										aTotFisDev[nPosFis][3]+=(cAliasSD1)->D1_TOTAL - (cAliasSD1)->D1_VALDESC + (cAliasSD1)->D1_VALFRE +; 
																(cAliasSD1)->D1_SEGURO + (cAliasSD1)->D1_DESPESA + (cAliasSD1)->D1_VALIPI + (cAliasSD1)->D1_ICMSRET
										aTotFisDev[nPosFis][5]+=((cAliasSD1)->D1_TOTAL - (cAliasSD1)->D1_VALDESC + (cAliasSD1)->D1_VALFRE +; 
																	(cAliasSD1)->D1_SEGURO + (cAliasSD1)->D1_DESPESA )
															
									EndIf
								EndIf			
							EndIf
						EndIf  
					EndIf
				Else
					If !Empty((cAliasSD1)->B5_CODATIV) .And. Alltrim((cAliasSD1)->D1_TIPO)== "P" 
					   If (cAliasSD1)->B5_INSPAT == "1"
					   		If lAgrCtaCtb 
								nPosFis := aScan(aTotFis,{|x| Alltrim(x[1]) == Alltrim((cAliasSD1)->B5_CODATIV) .And. x[9] == iIF(lD2CtaRec .And. !Empty(SD2->D2_CTAREC),SD2->D2_CTAREC,SD2->D2_CONTA)})
							Else
								nPosFis := aScan(aTotFis,{|x| Alltrim(x[1]) == Alltrim((cAliasSD1)->B5_CODATIV)})
							EndIf
							
					   		If STOD((cAliasSD1)->D1_DTDIGIT) >= CTOD("01"+"/"+SUBSTR(cIniDes,5,6)+"/"+SUBSTR(cIniDes,1,4))
						   		If nPosFis == 0
									aAdd(aTotFis,{(cAliasSD1)->B5_CODATIV,-(cAliasSD1)->D1_TOTAL,0,0})
								Else
									aTotFis[nPosFis][2]-=(cAliasSD1)->D1_TOTAL 
								EndIf
							EndIf	
					  	EndIf
					ElseIf !Empty((cAliasSD1)->B5_CODATIV)
						If SubStr(SD2->D2_CF,1,1) <> "7" .And. !(Alltrim(SD2->D2_CF) $ cExpCfop) .AND. (cAliasSD1)->B5_INSPAT == "1"					
					 	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³Soma os valores por codigo de atividade no array aTotFisDev ³
						//³[1] Código de atividade                                 	   ³
						//³[2] Valor Bruto devolução por código atividade              ³
						//³[3] Valor Bruto devolução de Exportação por cód de atividade³
						//³[4] Valor devolução liq + frete + seguro + despesa     	   ³
						//³[5] Valor Liqdo devolução de Exportação por cód de atividade³
						//³[6] Conta Contábil de receita									³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
							If (((cAliasSD1)->B5_VERIND == "1" .And. AllTrim(SD2->D2_CF) $cCFIND) .OR. (cAliasSD1)->B5_VERIND <> "1")						 	
								If lAgrCtaCtb 
									nPosFis := aScan(aTotFisDev,{|x| Alltrim(x[1]) == Alltrim((cAliasSD1)->B5_CODATIV) .And. x[6] == iIF(lD2CtaRec .And. !Empty(SD2->D2_CTAREC),SD2->D2_CTAREC,SD2->D2_CONTA)})
								Else
									nPosFis := aScan(aTotFisDev,{|x| Alltrim(x[1]) == Alltrim((cAliasSD1)->B5_CODATIV)})
								EndIf

								If nPosFis == 0
									aAdd(aTotFisDev,{(cAliasSD1)->B5_CODATIV,((cAliasSD1)->D1_TOTAL - (cAliasSD1)->D1_VALDESC + (cAliasSD1)->D1_VALFRE +; 
																(cAliasSD1)->D1_SEGURO + (cAliasSD1)->D1_DESPESA+ (cAliasSD1)->D1_VALIPI +; 
																(cAliasSD1)->D1_ICMSRET),0,(cAliasSD1)->D1_TOTAL - (cAliasSD1)->D1_VALDESC +; 
																(cAliasSD1)->D1_VALFRE + (cAliasSD1)->D1_SEGURO + (cAliasSD1)->D1_DESPESA , 0,iIF(lD2CtaRec .And. !Empty(SD2->D2_CTAREC),SD2->D2_CTAREC,SD2->D2_CONTA)})
								Else
									aTotFisDev[nPosFis][2]+=((cAliasSD1)->D1_TOTAL - (cAliasSD1)->D1_VALDESC + (cAliasSD1)->D1_VALFRE +; 
																(cAliasSD1)->D1_SEGURO + (cAliasSD1)->D1_DESPESA + (cAliasSD1)->D1_VALIPI + (cAliasSD1)->D1_ICMSRET)
									aTotFisDev[nPosFis][4]+=((cAliasSD1)->D1_TOTAL - (cAliasSD1)->D1_VALDESC + (cAliasSD1)->D1_VALFRE +; 
																(cAliasSD1)->D1_SEGURO + (cAliasSD1)->D1_DESPESA)						 
								EndIf
							Else 
								If lAgrCtaCtb 
									nPosFis := aScan(aTotFisDev,{|x| Alltrim(x[1]) == Alltrim((cAliasSD1)->B5_CODATIV) .And. x[6] == iIF(lD2CtaRec .And. !Empty(SD2->D2_CTAREC),SD2->D2_CTAREC,SD2->D2_CONTA)})
								Else
									nPosFis := aScan(aTotFisDev,{|x| Alltrim(x[1]) == Alltrim((cAliasSD1)->B5_CODATIV)})
								EndIf
								If nPosFis == 0
									aAdd(aTotFisDev,{(cAliasSD1)->B5_CODATIV,((cAliasSD1)->D1_TOTAL - (cAliasSD1)->D1_VALDESC + (cAliasSD1)->D1_VALFRE +; 
																(cAliasSD1)->D1_SEGURO + (cAliasSD1)->D1_DESPESA+ (cAliasSD1)->D1_VALIPI +; 
																(cAliasSD1)->D1_ICMSRET),0,(cAliasSD1)->D1_TOTAL - (cAliasSD1)->D1_VALDESC +; 
																(cAliasSD1)->D1_VALFRE + (cAliasSD1)->D1_SEGURO + (cAliasSD1)->D1_DESPESA , 0,iIF(lD2CtaRec .And. !Empty(SD2->D2_CTAREC),SD2->D2_CTAREC,SD2->D2_CONTA)})
								Else
									aTotFisDev[nPosFis][2]+=((cAliasSD1)->D1_TOTAL - (cAliasSD1)->D1_VALDESC + (cAliasSD1)->D1_VALFRE +; 
																(cAliasSD1)->D1_SEGURO + (cAliasSD1)->D1_DESPESA + (cAliasSD1)->D1_VALIPI + (cAliasSD1)->D1_ICMSRET)
									aTotFisDev[nPosFis][4]+=((cAliasSD1)->D1_TOTAL - (cAliasSD1)->D1_VALDESC + (cAliasSD1)->D1_VALFRE +; 
																(cAliasSD1)->D1_SEGURO + (cAliasSD1)->D1_DESPESA)						 
								EndIf
							EndIf
						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³Verifico as devoluções de exportações que possuem codigo de atividade e 	  ³
						//³atribuo a posição 3 do array aTotFisDev. Também será tratado itens de      |
						//| export por cod de ativ na posição 2 do aTotFisDev(Soma tot por cod ativ)  ³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						ElseIf SubStr(SD2->D2_CF,1,1) == "7" .Or. Alltrim(SD2->D2_CF) $ cExpCfop
							If (cAliasSD1)->B5_INSPAT == "1" 
								If (((cAliasSD1)->B5_VERIND == "1" .And. AllTrim(SD2->D2_CF) $cCFIND) .OR. (cAliasSD1)->B5_VERIND <> "1")						 	
									If lAgrCtaCtb 
										nPosFis := aScan(aTotFisDev,{|x| Alltrim(x[1]) == Alltrim((cAliasSD1)->B5_CODATIV) .And. x[6] == iIF(lD2CtaRec .And. !Empty(SD2->D2_CTAREC),SD2->D2_CTAREC,SD2->D2_CONTA)})
									Else
										nPosFis := aScan(aTotFisDev,{|x| Alltrim(x[1]) == Alltrim((cAliasSD1)->B5_CODATIV)})
									EndIf
									
									If nPosFis == 0
										
										aAdd(aTotFisDev,{(cAliasSD1)->B5_CODATIV,((cAliasSD1)->D1_TOTAL - (cAliasSD1)->D1_VALDESC + (cAliasSD1)->D1_VALFRE +;
										 				(cAliasSD1)->D1_SEGURO + (cAliasSD1)->D1_DESPESA + (cAliasSD1)->D1_VALIPI + (cAliasSD1)->D1_ICMSRET),;
										 				((cAliasSD1)->D1_TOTAL - (cAliasSD1)->D1_VALDESC + (cAliasSD1)->D1_VALFRE + (cAliasSD1)->D1_SEGURO +; 
										 				(cAliasSD1)->D1_DESPESA + (cAliasSD1)->D1_VALIPI + (cAliasSD1)->D1_ICMSRET),;
										 				0,(cAliasSD1)->D1_TOTAL - (cAliasSD1)->D1_VALDESC + (cAliasSD1)->D1_VALFRE +; 
														(cAliasSD1)->D1_SEGURO + (cAliasSD1)->D1_DESPESA, iIF(lD2CtaRec .And. !Empty(SD2->D2_CTAREC),SD2->D2_CTAREC,SD2->D2_CONTA)})
									Else
										aTotFisDev[nPosFis][2]+=((cAliasSD1)->D1_TOTAL - (cAliasSD1)->D1_VALDESC + (cAliasSD1)->D1_VALFRE +; 
																(cAliasSD1)->D1_SEGURO + (cAliasSD1)->D1_DESPESA + (cAliasSD1)->D1_VALIPI + (cAliasSD1)->D1_ICMSRET)
										aTotFisDev[nPosFis][3]+=((cAliasSD1)->D1_TOTAL - (cAliasSD1)->D1_VALDESC + (cAliasSD1)->D1_VALFRE +; 
																(cAliasSD1)->D1_SEGURO + (cAliasSD1)->D1_DESPESA + (cAliasSD1)->D1_VALIPI + (cAliasSD1)->D1_ICMSRET)						
										aTotFisDev[nPosFis][5]+=((cAliasSD1)->D1_TOTAL - (cAliasSD1)->D1_VALDESC + (cAliasSD1)->D1_VALFRE +; 
																(cAliasSD1)->D1_SEGURO + (cAliasSD1)->D1_DESPESA )					
									EndIf
								Else
									If lAgrCtaCtb 
										nPosFis := aScan(aTotFisDev,{|x| Alltrim(x[1]) == Alltrim((cAliasSD1)->B5_CODATIV) .And. x[6] == iIF(lD2CtaRec .And. !Empty(SD2->D2_CTAREC),SD2->D2_CTAREC,SD2->D2_CONTA)})
									Else
										nPosFis := aScan(aTotFisDev,{|x| Alltrim(x[1]) == Alltrim((cAliasSD1)->B5_CODATIV)})
									EndIf
									
									If nPosFis == 0
										aAdd(aTotFisDev,{(cAliasSD1)->B5_CODATIV,((cAliasSD1)->D1_TOTAL - (cAliasSD1)->D1_VALDESC + (cAliasSD1)->D1_VALFRE +;
											 				(cAliasSD1)->D1_SEGURO + (cAliasSD1)->D1_DESPESA + (cAliasSD1)->D1_VALIPI + (cAliasSD1)->D1_ICMSRET),;
											 				((cAliasSD1)->D1_TOTAL - (cAliasSD1)->D1_VALDESC + (cAliasSD1)->D1_VALFRE + (cAliasSD1)->D1_SEGURO +; 
											 				(cAliasSD1)->D1_DESPESA + (cAliasSD1)->D1_VALIPI + (cAliasSD1)->D1_ICMSRET),;
											 				0,(cAliasSD1)->D1_TOTAL - (cAliasSD1)->D1_VALDESC + (cAliasSD1)->D1_VALFRE +; 
															(cAliasSD1)->D1_SEGURO + (cAliasSD1)->D1_DESPESA, iIF(lD2CtaRec .And. !Empty(SD2->D2_CTAREC),SD2->D2_CTAREC,SD2->D2_CONTA)})
									Else
										aTotFisDev[nPosFis][2]+=((cAliasSD1)->D1_TOTAL - (cAliasSD1)->D1_VALDESC + (cAliasSD1)->D1_VALFRE +; 
																(cAliasSD1)->D1_SEGURO + (cAliasSD1)->D1_DESPESA + (cAliasSD1)->D1_VALIPI + (cAliasSD1)->D1_ICMSRET)
										aTotFisDev[nPosFis][3]+=((cAliasSD1)->D1_TOTAL - (cAliasSD1)->D1_VALDESC + (cAliasSD1)->D1_VALFRE +; 
																(cAliasSD1)->D1_SEGURO + (cAliasSD1)->D1_DESPESA + (cAliasSD1)->D1_VALIPI + (cAliasSD1)->D1_ICMSRET)						
									  	aTotFisDev[nPosFis][5]+=((cAliasSD1)->D1_TOTAL - (cAliasSD1)->D1_VALDESC + (cAliasSD1)->D1_VALFRE +; 
																	(cAliasSD1)->D1_SEGURO + (cAliasSD1)->D1_DESPESA )				
									EndIf
								EndIf
							EndIf
						EndIf  
					EndIf	
				EndIf		
			EndIf		
		EndIf					
        (cAliasSD1)->(dbSkip())
	EndDo
	(cAliasSD1)->(dbCloseArea())

	RhInssLog(aFatDes, cPeriodo, cFilProc, l13Sal)

	If __oTmpTrbFat <> NIL
		//Se o alias não existir mais, exclui a tabela temporária para ser criada uma nova.
		If Select("TRBFAT") == 0
			__oTmpTrbFat:Delete()
			FreeObj(__oTmpTrbFat)
		EndIf
	EndIf

	If __oTmpTrbFat == NIL		   
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³A estrutura da tabela temporária foi criada de acordo com Registro P100 (Contribuição Previdenciária sobre a Receita Bruta) ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ-ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Cria a estrutura do arquivo de trabalho ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		aCampos := {}
		aAdd(aCampos,{"TOTALLIQ"	,"N",TAMSX3("D2_TOTAL")[1],2})		// TOTAL LIQUIDO
		aAdd(aCampos,{"TOTAL"		,"N",TAMSX3("D2_TOTAL")[1],2})		// TOTAL BRUTO
		aAdd(aCampos,{"TOTLIQDEV"	,"N",TAMSX3("D2_TOTAL")[1],2})	    // TOTAL DEVOLUÇÃO
		aAdd(aCampos,{"TOTALDEV"	,"N",TAMSX3("D2_TOTAL")[1],2})	    // TOTAL DEVOLUÇÃO
		aAdd(aCampos,{"TOTLIQEXP"	,"N",TAMSX3("D2_TOTAL")[1],2})	    // TOTAL EXPORTAÇÃO
		aAdd(aCampos,{"TOTALEXP"	,"N",TAMSX3("D2_TOTAL")[1],2})	    // TOTAL EXPORTAÇÃO
		aAdd(aCampos,{"TOTADESC"	,"N",TAMSX3("D2_TOTAL")[1],2})	    // TOTAL DESCONTOS GERAL
		//CODIGO ATIVIDADE
		aAdd(aCampos,{"CODATV"		,"C",TAMSX3("B5_CODATIV")[1],2}) 	// CODIGO ATIVIDADE
		aAdd(aCampos,{"TOTCODAT"	,"N",TAMSX3("D2_TOTAL")[1],2})     // TOTAL CODIGO ATIVIDADE BRUTO
		aAdd(aCampos,{"TCODATLQ"	,"N",TAMSX3("D2_TOTAL")[1],2})     // TOTAL CODIGO ATIVIDADE LIQUIDO
		aAdd(aCampos,{"TCATVDEV"	,"N",TAMSX3("D2_TOTAL")[1],2})     // TOTAL DEV CODIGO ATIVIDADE
		aAdd(aCampos,{"TCATVEXP" 	,"N",TAMSX3("D2_TOTAL")[1],2})     // TOTAL EXPORTAÇÕES POR CODIGO DE ATIVIDADE
		aAdd(aCampos,{"TLQCATVEXP" 	,"N",TAMSX3("D2_TOTAL")[1],2}) 		// TOTAL LIQUIDO EXPORTAÇÕES POR CODIGO DE ATIVIDADE
		aAdd(aCampos,{"TCATVDVEX" 	,"N",TAMSX3("D2_TOTAL")[1],2})     // TOTAL DE DEVOLUÇÕES DE EXPORTAÇÕES POR CODIGO DE ATIVIDADE
		aAdd(aCampos,{"TLQCATDVEX" 	,"N",TAMSX3("D2_TOTAL")[1],2})     // TOTAL LIQUIDO DE DEVOLUÇÕES DE EXPORTAÇÕES POR CODIGO DE ATIVIDADE
		aAdd(aCampos,{"TCDESCON"	,"N",TAMSX3("D2_TOTAL")[1],2})     // TOTAL COD ATIV - DESCONTOS
		aAdd(aCampos,{"TCDEVEXP"	,"N",TAMSX3("D2_TOTAL")[1],2})     // TOTAL COD ATIV - DEVOLUÇÃO - EXPÓRTAÇÃO
		aAdd(aCampos,{"CONTARECE"	,"C",TAMSX3("D2_CONTA")[1],2})     // CONTA DE RECEITA - PEGA DO CAMPO D2_CTAREC OU DO D2_CONTA
				
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Cria o arquivo de trabalho³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ	
		__oTmpTrbFat := FWTemporaryTable():New("TRBFAT")
		__oTmpTrbFat:SetFields(aCampos)
		aIdxTrbFat := {"CODATV"}
		__oTmpTrbFat:AddIndex("1",aIdxTrbFat)
		__oTmpTrbFat:Create()
	Else
		cRealName := __oTmpTrbFat:GetRealName()
		TcSqlExec("TRUNCATE TABLE " + cRealName)
	EndIf

	If Len(aTotFis)== 0	.And. Len(aTotFisDev)== 0	 
		If (nFatBrut + nTotDev + nFatExp) > 0
			RecLock("TRBFAT", .T.)	
			TRBFAT->TOTALLIQ		:= nFatLiq    			// valor total Liquido geral das notas
			TRBFAT->TOTAL			:= nFatBrut    			// valor total BRUTO geral das notas
			
		    TRBFAT->TOTLIQDEV 	:= nTotLiqDev 			// Valor total Liquido de devoluções
		    TRBFAT->TOTALDEV 	:= nTotDev 				// Valor total de devoluções

		    TRBFAT->TOTLIQEXP 	:= nFatLiqExp 			// Valor total Liquido de exportações 
		    TRBFAT->TOTALEXP 	:= nFatExp 				// Valor total de exportações
		    TRBFAT->TOTADESC 	:= nDescon					// Valor total de descontos  
		    TRBFAT->(MsUnlock())
		EndIf    
    ElseIf Len(aTotFis)> 0	
		For nx:= 1 to Len(aTotFis)
			nImpostos := 0
			RecLock("TRBFAT", .T.)
			TRBFAT->TOTALLIQ		:= nFatLiq    			// valor total Liquido geral das notas
			TRBFAT->TOTAL			:= nFatBrut    			// valor total BRUTO geral das notas
			
		    TRBFAT->TOTLIQDEV 	:= nTotLiqDev 			// Valor total Liquido de devoluções
		    TRBFAT->TOTALDEV 	:= nTotDev 				// Valor total de devoluções

		    TRBFAT->TOTLIQEXP 	:= nFatLiqExp 			// Valor total Liquido de exportações 
		    TRBFAT->TOTALEXP 	:= nFatExp 				// Valor total de exportações
		    TRBFAT->TOTADESC 	:= nDescon					// Valor total de descontos   
			// Totais por código de atividade
			TRBFAT->CODATV		:= aTotFis[nx][1] 		// Código de atividade
			TRBFAT->TOTCODAT		:= aTotFis[nx][2] 		// Valor total BRUTO do código de atividade
		   	If lAgreg
				TRBFAT->TCODATLQ	:= aTotFis[nx][2] - aTotFis[nX][5] - aTotFis[nX][6]	// Valor total LIQ do código de atividade - ICMS que ja esta imbutido no valor.
			Else
				TRBFAT->TCODATLQ	:= aTotFis[nx][4] //Valor total LIQ do código de atividade
			EndIf		
			// Verifica se existe alguma nota de devolução para o código de atividade posicionado.
			If lAgrCtaCtb 
				nPosFis := aScan(aTotFisDev,{|x| Alltrim(x[1]) == Alltrim(aTotFis[nX][1]) .And. x[6] == aTotFis[nX][9]})
			Else
				nPosFis := aScan(aTotFisDev,{|x| Alltrim(x[1]) == Alltrim(aTotFis[nX][1])})
			EndIf

			If nPosFis > 0
				TRBFAT->TCATVDEV	:= aTotFisDev[nPosFis][4]// Nota de devolução (tem que ser o valor liq, pois para desoner não inclui impostos quando tem cod atividade)
		    Else
		       TRBFAT->TCATVDEV	:= 0
		    EndIf
		    TRBFAT->TCATVEXP		:= aTotFis[nx][3] // Total Bruto Exportação por Código de atividade(Saida) 
		    TRBFAT->TLQCATVEXP	:= aTotFis[nx][7] // Total Liquido Exportação        por Código de atividade(Saida) 
		   
		    // Verifica se existe alguma nota de devolução de exportação para o código de atividade posicionado.
			If lAgrCtaCtb 		   
		    	nPosDev := aScan(aTotFisDev,{|x| Alltrim(x[1]) == Alltrim(aTotFis[nx][1]) .And. x[6]== aTotFis[nx][9]})
		    Else
		    	nPosDev := aScan(aTotFisDev,{|x| Alltrim(x[1]) == Alltrim(aTotFis[nx][1])})
		    EndIf
			If nPosDev > 0
		    	TRBFAT->TCATVDVEX		:= aTotFisDev[nPosDev][3]// Nota de devolução de exportação 
		    	TRBFAT->TLQCATDVEX 	:= aTotFisDev[nPosDev][5]// Nota de devolução de exportação 
		    Else 
			   	TRBFAT->TCATVDVEX	:= 0
		    EndIf
		    TRBFAT->TCDESCON 	:= aTotFis[nx][8]// DESCONTOS INCONDICIONAIS
		    
		    //aTotFis[nX][5] - ICMS - Soma os valores do ICMS ao valor líquido, pois se a TES estiver configurada F4_AGREG=I/D o valor do ICMS é asomado ao valor bruto.
			nTot := (TRBFAT->TCODATLQ - (TRBFAT->TCATVDEV + TRBFAT->TLQCATVEXP))	// Total por Código de atividade - devolução - exportação
			TRBFAT->TCDEVEXP := nTot
			If lAgrCtaCtb
				TRBFAT->CONTARECE := aTotFis[nx][9]
			Else
				TRBFAT->CONTARECE := Space(TAMSX3("D2_CONTA")[1])
			EndIf	
						
			TRBFAT->(MsUnlock())
		Next(nX)
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Verifico se houve alguma devolução que não foi processada no array atotfis(saída)³
		//³Este caso aconteçe se existe apenas devolução com cod de atividade para o período³
		//³pois a NF original já foi processada em mês anterior.                            ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If Len(aTotFisDev)> 0	
			For nX:= 1 to Len(aTotFisDev)

				If lAgrCtaCtb 
					nPosFisDev := aScan(aTotFis,{|x| Alltrim(x[1]) == Alltrim(aTotFisDev[nx][1]) .And. x[9] == aTotFisDev[nx][6]})
				Else
					nPosFisDev := aScan(aTotFis,{|x| Alltrim(x[1]) == Alltrim(aTotFisDev[nx][1])})
				EndIf				
				 
				// Se o codigo de atividade não foi encontrado no atotfis e possui no atotfisdev
				// Inclui uma linha com a devolução com cod atividade
				If nPosFisDev == 0
					nImpostos := 0
					RecLock("TRBFAT", .T.)
					TRBFAT->TOTALLIQ		:= nFatLiq    			// valor total Liquido geral das notas
					TRBFAT->TOTAL			:= nFatBrut    			// valor total BRUTO geral das notas
					
				    TRBFAT->TOTLIQDEV 	:= nTotLiqDev 			// Valor total Liquido de devoluções
				    TRBFAT->TOTALDEV 	:= nTotDev 				// Valor total de devoluções
		
				    TRBFAT->TOTLIQEXP 	:= nFatLiqExp 			// Valor total Liquido de exportações 
				    TRBFAT->TOTALEXP 	:= nFatExp 				// Valor total de exportações 
				    TRBFAT->TOTADESC 	:= nDescon					// Valor total de descontos  
					// Totais por código de atividade
					TRBFAT->CODATV		:= aTotFisDev[nx][1] 	// Código de atividade
					TRBFAT->TOTCODAT		:= 0						// Valor total do código de atividade
					TRBFAT->TCODATLQ		:= 0				 		// Valor total LIQ do código de atividade
					// Verifica se existe alguma nota de devolução para o código de atividade posicionado.
					nPosDev := aScan(aTotFisDev,{|x| Alltrim(x[1]) == Alltrim(aTotFisDev[nx][1])})
					If nPosDev > 0
						TRBFAT->TCATVDEV	:= aTotFisDev[nPosDev][4]// Nota de devolução (tem que ser o valor liq, pois para desoner não inclui impostos quando tem cod atividade)
				    Else
				        TRBFAT->TCATVDEV	:= 0
				    EndIf
				    TRBFAT->TCATVEXP		:= aTotFisDev[nx][3] // Total Exportação por Código de atividade(Saida) 
				    // Verifica se existe alguma nota de devolução de exportação para o código de atividade posicionado.
				    nPosDev := aScan(aTotFisDev,{|x| Alltrim(x[1]) == Alltrim(aTotFisDev[nx][1])})
					If nPosDev > 0
				    	TRBFAT->TCATVDVEX	:= aTotFisDev[nPosDev][3]// Nota de devolução de exportação 
				    Else 
					   TRBFAT->TCATVDVEX	:= 0
				    EndIf
				    nImpostos := TRBFAT->TOTCODAT - TRBFAT->TCODATLQ
				    
					nTot := TRBFAT->TOTCODAT - TRBFAT->TCATVDEV - TRBFAT->TCATVEXP - nImpostos  // Total por Código de atividade - devolução - exportação 
			 
				    If nTot > 0
				    	TRBFAT->TCDEVEXP := nTot
				    Else 
				    	TRBFAT->TCDEVEXP := 0
				    EndIf		   		
					 
					If lAgrCtaCtb
						TRBFAT->CONTARECE := aTotFisDev[nx][6]
					Else
						TRBFAT->CONTARECE := Space(TAMSX3("D2_CONTA")[1])
					EndIf	
					TRBFAT->(MsUnlock())
					
		    	EndIf
			Next nX
		EndIf	
	ElseIf Len(aTotFisDev)> 0 
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Tratamento para caso haja apenas devolução no periodo.³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		For nx:= 1 to Len(aTotFisDev) 
			nImpostos := 0
			RecLock("TRBFAT", .T.)
			TRBFAT->TOTALLIQ		:= nFatLiq    			// valor total Liquido geral das notas
			TRBFAT->TOTAL			:= nFatBrut    			// valor total BRUTO geral das notas
			
		   	TRBFAT->TOTLIQDEV 	:= nTotLiqDev 			// Valor total Liquido de devoluções
		   	TRBFAT->TOTALDEV 	:= nTotDev 					// Valor total de devoluções

		   	TRBFAT->TOTLIQEXP 	:= nFatLiqExp 			// Valor total Liquido de exportações 
		   	TRBFAT->TOTALEXP 	:= nFatExp 					// Valor total de exportações 
			// Totais por código de atividade
			TRBFAT->CODATV		:= aTotFisDev[nx][1] 	// Código de atividade
			TRBFAT->TOTCODAT		:= 0	   					// Valor total do código de atividade
			TRBFAT->TCODATLQ		:= 0 	   					// Valor total LIQ DEVOLUCAO do código de atividade
			// Verifica se existe alguma nota de devolução para o código de atividade posicionado.
			
			nPosFis := aScan(aTotFisDev,{|x| Alltrim(x[1]) == Alltrim(aTotFisDev[nx][1])})
			If nPosFis > 0
				TRBFAT->TCATVDEV	:= aTotFisDev[nPosFis][4]// Nota de devolução (tem que ser o valor liq, pois para desoner não inclui impostos quando tem cod atividade)
		    Else
		        TRBFAT->TCATVDEV	:= 0
		    EndIf
		    TRBFAT->TCATVEXP		:= aTotFisDev[nx][3] // Total Exportação por Código de atividade(Saida) 
		    // Verifica se existe alguma nota de devolução de exportação para o código de atividade posicionado.
		    nPosDev := aScan(aTotFisDev,{|x| Alltrim(x[1]) == Alltrim(aTotFisDev[nx][1])})
			If nPosDev > 0
		    	TRBFAT->TCATVDVEX	:= aTotFisDev[nPosDev][3]// Nota de devolução de exportação 
		   	Else 
			   TRBFAT->TCATVDVEX	:= 0
		  	EndIf
		   	nImpostos := TRBFAT->TOTCODAT - TRBFAT->TCODATLQ	
			nTot := TRBFAT->TOTCODAT - TRBFAT->TCATVDEV - TRBFAT->TCATVEXP - nImpostos  // Total por Código de atividade - devolução - exportação - impostos
					
		   	If nTot > 0
		   		TRBFAT->TCDEVEXP := nTot
		    Else 
		    	TRBFAT->TCDEVEXP := 0
		    EndIf		   		
			If lAgrCtaCtb
				TRBFAT->CONTARECE := aTotFisDev[nx][6]
			Else
				TRBFAT->CONTARECE := Space(TAMSX3("D2_CONTA")[1])
			EndIf	
			TRBFAT->(MsUnlock())
		Next(nX)
	EndIf	
EndIf
aSize(aTotFis,0)
aSize(aTotFisDev,0)
aSize(aFatDes,0)
aSize(aCampos,0)
RestArea(aArea)
Return("TRBFAT")//Retorna o arquivo de trabalho
                                               
/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³RhInssLog ºAutor  ³Microsiga           º Data ³  09/05/12   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Gera o arquivo de Log do periodo informado com o total das º±±
±±º          ³ de saida e devolução                                       º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³aFatDes - Array contendo os itens para alimentar o arq de   º±±
±±³          ³			 trabalho									      ³±±
±±³          ³cPeriodo - Periodo de apuração das Notas					  ³±±
±±³          ³cFilProc - Filial de Processamento						  ³±±
±±³          ³l13Sal   - Geração de arquivo de 13 salario      	          ³±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/

Static Function RhInssLog(aFatDes, cPeriodo, cFilProc, l13Sal)

Local nx			:= 0
Local cRotina		:= ""
Local cQuery		:= ""
Local lV5CtaRec  	:= SV5->(ColumnPos("V5_CTAREC")) > 0 //Valida se o campo V5_CTAREC existe

If IsInCallStack("GPEM013")
	cRotina := "GPEM013"
ElseIf IsInCallStack("GPEM070")
	cRotina := "GPEM070"
Else
	cRotina := "P100"
EndIf

If ChkFile("SV5")
	dbSelectArea("SV5")
	dbSetOrder(1)
	If SV5->(dbSeek(cFilProc+cPeriodo+cRotina))
		cQuery := "DELETE FROM "+RetSqlName("SV5")+" WHERE V5_FILIAL='"+cFilProc+"' AND V5_ROTINA='"+cRotina+"' AND V5_PERIODO='"+cPeriodo+"' "
		TcSqlExec(cQuery)
	EndIf

	For nx:= 1 to Len(aFatDes)
		Reclock("SV5", .T.)
		Replace V5_FILIAL		WITH cFilProc
		Replace V5_NUMNF		WITH aFatDes[nX][1]
		Replace V5_SERIE 		WITH aFatDes[nX][2]
		Replace V5_TIPO  		WITH aFatDes[nX][3]
		Replace V5_ITEMNF		WITH aFatDes[nX][9]
		Replace V5_ESPECNF	WITH aFatDes[nX][10]
		Replace V5_DATANF		WITH Stod(aFatDes[nX][4])
		Replace V5_CFOP		WITH aFatDes[nX][8]
		Replace V5_TOTAL		WITH aFatDes[nX][5]
		Replace V5_TOTBRUT	WITH aFatDes[nX][11]
		Replace V5_NFORI		WITH aFatDes[nX][6]
		Replace V5_SERIORI 	WITH aFatDes[nX][7]
		Replace V5_ITEMORI 	WITH aFatDes[nX][13]
		Replace V5_CODATIV	WITH aFatDes[nX][12]
		Replace V5_PERIODO	WITH cPeriodo
		Replace V5_ROTINA		WITH cRotina
		//Grava a Conta de Receita retornado pelo LP610(CT5_CTAREC)- EFD Contribuições
		//contido no campo D2_CTAREC, senão pega do D2_CONTA.
		If lV5CtaRec
			Replace V5_CTAREC	WITH aFatDes[nX][14]
		EndIf
		SV5->(MsUnLock())
	Next nX
EndIf

Return

//------------------------------------------------------------------------------
/*/{Protheus.doc} NewDesFol
Esta função é chamada pelo Fiscal e RH via findfunction, pois se este fonte 
estiver desatualizado, essa função não irá existir e já interpretarão que estão
utilizando o modelo antigo de desoneração via LOG em DBF

@sample 	NewDesFol()
@return		Nil
@author		Serviços - Vendas/CRM
@since		01/12/17
@version	P12.1.17
/*/
//------------------------------------------------------------------------------
Function NewDesFol()

Return Nil

//------------------------------------------------------------------------------
/*/{Protheus.doc} CloseTRBDF
Esta função é chamada pelo Fiscal e RH para fechar o arquivo Temporário
oTmpTrbFat

@sample 	CloseTRBDF()
@return		Nil
@author		Serviços - Vendas/CRM
@since		01/12/17
@version	P12.1.17
/*/
//------------------------------------------------------------------------------
Function CloseTRBDF()

If Select("TRBFAT") > 0 .And. __oTmpTrbFat <> NIL
	__oTmpTrbFat:Delete()
	FreeObj(__oTmpTrbFat)
EndIf

Return Nil
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
/*/{Protheus.doc} MaSerEspNF
Retorna a série/espécie da nota fiscal de saída.

@sample 	MaSerEspNF()

@return		ExpC 	Retorna uma string com a série/espécie da nota fiscal de
					saída que estão configurados na tabela "SN" (SX5) ou no
					parâmetro MV_ESPECIE.

@author		Serviços - Vendas/CRM
@since		04/04/2016
@version	P12.1.11
/*/
//------------------------------------------------------------------------------
Function MaSerEspNF()

Local aArea		:= GetArea()
Local aAreaSX5	:= SX5->(GetArea())
Local cTpDocPar	:= AllTrim(SuperGetMv('MV_ESPECIE'))
Local lEspNfX5 	:= SuperGetMV("MV_ESPNFX5",.F.,.F.)
Local cTiposDoc 	:= ""

If lEspNfX5
	dbSelectArea("SX5")
	SX5->(dbSetOrder(1))
	If SX5->(dbSeek(xFilial("SX5")+"SN"))
		While SX5->(!Eof()) .And. SX5->X5_FILIAL == xFilial("SX5") .And. SX5->X5_TABELA == "SN"
			If !Empty(SX5->X5_DESCRI)
				cTiposDoc += AllTrim(SX5->X5_DESCRI) + ";"
			EndIf
		SX5->(dbSkip())
		EndDo
		cTiposDoc += cTpDocPar
	Else
		cTiposDoc := cTpDocPar
	EndIf
Else
	cTiposDoc := cTpDocPar
EndIf

RestArea(aAreaSX5)
RestArea(aArea)

Return (cTiposDoc)
// -----------------------------------------------------------
/*/{Protheus.doc} FatVldStr

@author Serviços
@since 22/04/2016
@version 1.0
@return  Possui (T) ou não (F) caracter especial
/*/
// -----------------------------------------------------------
Function FatVldStr(cCampo)
Local lRet		:= .T.
Local cCampoPos	:= ""
Local cConteudo := ""
Local cCaracPip	:= "|'"
Local nX		:= 0
Local lUsaVld	:= .F.
Local lNumPV	:= .F.

Default cCampo := ""

If !Empty(cCampo)
	cConteudo := cCampo
	lNumPV := .T.
Else
	cCampoPos	:= ReadVar()
	cConteudo := Alltrim(&(cCampoPos))
	lUsaVld	:= IIF("A1_NOME" $ cCampoPos,cPaisLoc == "BRA",.T.)
EndIf

If lUsaVld .Or. lNumPV
	For nX:= 1 To Len(cConteudo)
		If SubStr(cConteudo,nX,1) $ cCaracPip
			lRet:= .F.
			Exit
		EndIf
	Next(nX)

	If !lRet .And. !(lNumPV)
		Help("",1,"Help",,STR0020,1,0)
	ElseIf !lRet
		Help("",1,"A410CARESP",,STR0026,1,0,,,,,,{STR0027}) //"Não é permitido o uso de caracteres especiais no número do pedido de venda." "Defina um número para o pedido de venda sem caracteres especiais."
	EndIf
EndIf 

Return lRet


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} MaSetFaLog
Preenchimento do array com log de processamento  
@author Servicos - CRM/Faturamento 
@version P12.1.17  
@since 26/12/2018
@return .T.  
/*/
//-----------------------------------------------------------------------------------------------------
Function MaSetFaLog(aLinha)
	If (ValType(aLogMsg) == "U")
		aLogMsg := {}
	EndIf
	AAdd(aLogMsg, aLinha)
Return .T.

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} MaGetFaLog
Retornar o array com log de processamento  
@author Servicos - CRM/Faturamento 
@version P12.1.17  
@since 26/12/2018
@return aLogMsg - Array - Log do processamento  
/*/
//-----------------------------------------------------------------------------------------------------
Function MaGetFaLog()
Return aLogMsg

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} MaCleFaLog
Esvaziar o array com log de processamento  
@author Servicos - CRM/Faturamento 
@version P12.1.17  
@since 26/12/2018
@return .T.  
/*/
//-----------------------------------------------------------------------------------------------------
Function MaCleFaLog()
	FreeObj(aLogMsg)
Return .T.
/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ FatGetPicN ³ Autor ³ Crm/Faturamento    ³ Data ³ 30.01.19  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Retornar picture adicionando casas decimais                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ 					                                          ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function FatGetPicN(cCampo,nTampict,lMilhar)
	Local 	nDec 		:= TamSX3(cCampo)[2]
	Local 	nX			:= 1
	Local 	nY			:= 1
	Local 	cMaskI		:= ""
	Local 	cMaskF		:= ""
	Local 	cRet 		:= ""
	Default nTamPict	:= 16
	Default lMilhar		:= .T.
	
	If !Empty(cCampo)
		nTamPict := Iif(nTamPict > 16, 16, nTamPict)
		cMaskI := Iif(nDec > 0, Replicate("9",nTamPict - nDec - 1),Replicate("9",nTamPict))
		cMaskF := cMaskI
		nTamPict := Len(cMaskF)
		If lMilhar
			For nY := 0 to nTamPict
  				If nX >= 3 .And. (nTamPict - nY > 1)
					cMaskF := Stuff(cMaskF, nTamPict - nY, 0, ",")
					nX := 0
				EndIf
 				nX ++
			Next
		EndIF
		cRet := "@E " + cMaskF + Iif(nDec == 0, "", "." + Replicate("9",nDec))
	EndIf
Return(cRet)

/*/{Protheus.doc} FatGetHelp
Retorna a mensagem de texto do último Help/solução executado e limpa o buffer.
@type       Function
@author     CRM/Faturamento
@since      Nov/2020
@version    12.1.27
@return     array, 1º Elemento: Mensagem do último help executado
                   2º Elemento: Solução do último help executado
****************************************************************************************************************************************************
***  Observações:                                                                                                                                ***
***  1) NÃO APAGAR essa função. Ela é utilizada em Casos de Testes Automatizados, e pode também ser utilizada por programas do módulo.           ***
***  2) ESSA FUNÇÃO NÃO DEVE SER REPASSADA PARA QUE CLIENTES A UTILIZEM EM SUAS CUSTOMIZAÇÕES. ESTA FUNÇÃO SE LIMITA APENAS A USO INTERNO TOTVS. ***
****************************************************************************************************************************************************
/*/
Function FatGetHelp()

Local cMsgHlp		:= ''
Local cSolHlp		:= ''
Local nQtdElem		:= 0
Local nX			:= 1
Local lPadrao		:= !( FWIsInCallStack("EXECBLOCK") .OR. FWIsInCallStack("EXECTEMPLATE") )	//Verifica se a função está sendo chamada por funções do Padrão ou por Customizações e/ou Templates
Local aRet			:= {'',''}
Local aHelp

If	lPadrao
	//Só executa a função se for chamada por funções do padrão, e não possuir funções CUSTOMIZADAS ou de TEMPLATE na pilha de chamadas...
	aHelp	:= FwGetUltHlp()
	If ValType(aHelp) == 'A' .AND. Len(aHelp) == 3
		//Mensagem
		nQtdElem := Len(aHelp[2])
		For nX := 1 to nQtdElem
			cMsgHlp += If(Empty(cMsgHlp), '', ' ') + AllTrim(aHelp[2][nX])
		Next nX

		//Solução
		nQtdElem := Len(aHelp[3])
		For nX := 1 to nQtdElem
			cSolHlp += If(Empty(cSolHlp), '', ' ') + AllTrim(aHelp[3][nX])
		Next nX
		aRet	:= {cMsgHlp, cSolHlp}
	EndIf

	FwClearHlp()	//Limpa último help executado
	FreeObj(aHelp)
EndIf
Return aRet


/*/{Protheus.doc} FtGtSldOS
Retorna o saldo das liberações dos pedidos de venda com ordem de separação vinculada e não faturada.
@type       Function
@author     CRM/Faturamento
@since      Fev/2021
@version    12.1.27
@return     nSldOrdSep, numérico, saldo das liberações dos pedidos de venda com ordem de separação vinculada e não faturada
/*/
Function FtGtSldOS()

Local lIntACD  	    := SuperGetMV("MV_INTACD",.F.,"0") == "1"
Local cAliasOSep    := ""
Local nSldOrdSep	:= 0
Local cRemito		:= ""

If lIntACD .And. IsInCallStack("MATA455")
	cAliasOSep := GetNextAlias()
	
	If cPaisLoc <> "BRA"
		cRemito := "% C9_REMITO = '" + Space(Len(SC9->C9_REMITO)) + "' AND %"
	Else
		cRemito := "% %"
	EndIf

	BeginSQL Alias cAliasOSep
		SELECT 
			SUM(C9_QTDLIB) SALDO_LIBERADO,
			C9_FILIAL,
			C9_PEDIDO,
			C9_ITEM
		FROM
			%table:SC9%
		WHERE
			C9_FILIAL  =  %xFilial:SC9%                     AND
			C9_PEDIDO  =  %Exp:SC6->C6_NUM%              AND
			C9_ITEM    =  %Exp:SC6->C6_ITEM%                AND
			C9_ORDSEP  <> %Exp:Space(Len(SC9->C9_ORDSEP))%  AND
			C9_NFISCAL =  %Exp:Space(Len(SC9->C9_NFISCAL))% AND
			%exp:cRemito%
			%notDel%
		GROUP BY
			C9_FILIAL,
			C9_PEDIDO,
			C9_ITEM
	EndSQL
	
	If (!(cAliasOSep)->(EOF()))
		nSldOrdSep := (cAliasOSep)->SALDO_LIBERADO
	EndIf
	
	(cAliasOSep)->(DbCloseArea())
EndIf

Return nSldOrdSep

/*/{Protheus.doc} FatLibMetric
Função utilizada para validar a data da LIB para ser utilizada na Telemetria
@type       Function
@author     CRM/Faturamento
@since      Maio/2021
@version    12.1.27
@return     __lMetric, lógico, se a LIB pode ser utilizada para Telemetria
/*/
Static Function FatLibMetric()

If __lMetric == Nil 
	__lMetric := FWLibVersion() >= "20210517"
EndIf

Return __lMetric

/*/{Protheus.doc} FatxVerLib
Função utilizada para validar a data da LIB para utilização da classe FWExecStatement

@type       Function
@author     CRM/Faturamento
@since      Mar/2022
@version    12.1.33
@return     __lFatxlib retorna lógico quando a data da lib for superior a 16/11/2021
/*/
Static Function FatxVerLib()

Static __lFatxlib := Nil

If __lFatxlib == Nil 
	__lFatxlib := FWLibVersion() >= "20211116"
EndIf

Return __lFatxlib
/*/{Protheus.doc} SetAvalSc5
altera o valor da variavel  lSetMetrics gravação das Metricas

@param		Logico altera o valor da variavel estatica 
            _lMetricsSC5 (.T.) verdairo ou (.F.) Flaso
@type       Function
@author     CRM/Faturamento
@since      24/05/2022
@version    12.1.33
@return     
/*/
Function SetAvalSc5(lSetMetrics)

If !(lSetMetrics == nil)
	_lMetricsSC5 := lSetMetrics
EndIf 
	
Return _lMetricsSC5

//-------------------------------------------------------------------------------
/*/{Protheus.doc} IntAddField()
Adiciona a seção AddFields para envio da mensagem EAI e efetua a leitura da seção 
AddFields no recebimento da mensagem EAI com os campos que não possuem tag e/ou 
customizados, desde que estejam preenchidos.

@param		oAddFields  , Object    , Objeto com a mensagem de envio ou recebimento 
@param		cTypeTrans  , Character , Tipo de mensagem, se envio ou recebimento 
@param      aFieldAux  	, Array     , Estrutura da tabela na mensagem de envio e 
										Relação dos campos com seus conteúdos na mensagem de recebimento
@param      cCpoTag     , Character , Campos com tag para serem desconsiderados
@param      cAlias      , Character , Alias da tabela processada no envio e
										Prefixo da tabela no recebimento

@type       Function
@author     CRM/Faturamento
@since      Março/2025
@version    12.1.2410
@return 	.T., Logical, O retorno da função sempre é verdadeiro.
/*/
//-------------------------------------------------------------------------------
Function IntAddField(oAddFields As Object, cTypeTrans As Character, aFieldAux As Array, cCpoTag As Character, cAlias As Character) As Logical

    Local nX	As Numeric
    Local nZ    As Numeric

    Default oAddFields := Nil
    Default cTypeTrans := ""
    Default aFieldAux := {}
	Default cCpoTag    := ""
    Default cAlias     := ""

    nX	:= 0
    nZ  := 0

    If cTypeTrans == "0" //Recebimento
        If oAddFields[1]:getPropValue("Field") != nil .And. oAddFields[1]:getPropValue("Content") != nil

            For nX := 1 To Len(oAddFields)

				If Len(cAlias) == 2
					cAlias += "_"
				EndIf
				// Desconsidero os campos enviados na AddFields que possuem tag ou
				// considero todos os campos da AddFields se o cCpoTag estiver em branco com cAlias preenchido
                If (!Empty(cCpoTag) .And. !(oAddFields[nX]:getPropValue("Field")) $ cCpoTag .And. SubStr(oAddFields[nX]:getPropValue("Field"), 1, 3) == cAlias) .Or.;
					(Empty(cCpoTag) .And. SubStr(oAddFields[nX]:getPropValue("Field"), 1, 3) == cAlias)
                    If	FWSX3Util():GetFieldType(oAddFields[nX]:getPropValue("Field")) == "D" 
						aAdd(aFieldAux, {oAddFields[nX]:getPropValue("Field"), FwDateTimeToLocal(oAddFields[nX]:getPropValue("Content"))[1], Nil})
					Else
                    	aAdd(aFieldAux, {oAddFields[nX]:getPropValue("Field"), oAddFields[nX]:getPropValue("Content"), Nil})
					EndIf
                EndIf
            Next nX
        EndIf
    ElseIf cTypeTrans == "1" //Envio

        If oAddFields:getPropValue("AddFields") <> Nil
            nZ := Len(oAddFields:getPropValue("AddFields"))
        EndIf

        For nX := 1 To Len(aFieldAux)
			// Considero todos os campos de usuário ou se o cCpoTag estiver em branco com cAlias preenchido ou
			// desconsidero os campos enviados na AddFields que possuem tag, caso estejam preenchidoss
            If (GetSX3Cache(aFieldAux[nX], "X3_PROPRI") == "U" .Or. (Empty(cCpoTag) .And. !Empty(cAlias)) .Or. !(aFieldAux[nX] $ cCpoTag));
                .And. !Empty((cAlias)->&(aFieldAux[nX]))

                nZ++
                oAddFields:setprop('AddFields',{},'Add',,.T.)
                oAddFields:get("AddFields")[nZ]:setprop("Field", aFieldAux[nX], ,.T.)
                oAddFields:get("AddFields")[nZ]:setprop("Content", (cAlias)->&(aFieldAux[nX]),,.T.)
            EndIf
        Next nX
    EndIf

Return .T.

/*/{Protheus.doc} AlcFat
Função de tratamento de alçadas para o Faturamento
@type       Function
@author     CRM/Faturamento
@since      Outubro/2023
@version    12.1.2310
@return    
/*/
Function AlcFat(nOpcao as numeric) as logical

	Local aArea 	as Array
	Local cGrpAprov as character
	Local nTpAlcFat	as numeric
	Local cTpAlc	as character
	Local nTotalPed as numeric
	Local nTotalDes as numeric
	Local nContI   	as numeric	
	Local nTotItens as numeric
	Local nDeleted	as numeric
	Local nPosVal 	as numeric
	Local nPosVlDes as numeric
	Local nPosPrUnt as numeric
	Local nPosQdVen as numeric
	Local nPosPcVen	as numeric

	DEFAULT nOpcao    := 0

	aArea 		:= GetArea()
	cGrpAprov 	:= SuperGetMV("MV_PVAPROV",.F.,"")	//Grupo de Aprovação default
	nTpAlcFat	:= SuperGetMV("MV_TALCFAT",.F.,1)	//Define o tipo de Alçadas 1-Pedido de Venda ou 2-Desconto de Venda
	cTpAlc		:= ""
	nTotalPed 	:= 0
	nTotalDes 	:= 0
	nContI   	:= 0	
	nTotItens 	:= Len(aCols)
	nDeleted	:= Len(aHeader)+1
	nPosVal 	:= aScan(aHeader,{|x| Alltrim(x[2])== "C6_VALOR"}) 
	nPosVlDes 	:= aScan(aHeader,{|x| Alltrim(x[2])== "C6_VALDESC"}) 
	nPosPrUnt 	:= aScan(aHeader,{|x| Alltrim(x[2])== "C6_PRUNIT"}) 
	nPosQdVen 	:= aScan(aHeader,{|x| Alltrim(x[2])== "C6_QTDVEN"}) 
	nPosPcVen	:= aScan(aHeader,{|x| Alltrim(x[2])== "C6_PRCVEN"})

	//A geração da alçada somente é acionada quando 
	//o parâmetro MV_PVAPROV estiver preenchido.
	If !Empty(cGrpAprov)

		M->C5_APROV := cGrpAprov

		// Alteração excluirá os lançamentos na SCR (Alçadas) e incluirá novamente.
		// Exclusão somente excluirá os lançamentos na SCR (Alçadas).
		If nOpcao == 2 .Or. nOpcao == 3 
			SCR->(dbSetOrder(1))
			If SCR->(dbSeek(FwxFilial("SCR") + "DV" + M->C5_NUM))
				cTpAlc 		:= "DV"
			else
				cTpAlc 		:= "PV"
			EndIf

			MaAlcDoc({M->C5_NUM,cTpAlc,0,,,cGrpAprov,,M->C5_MOEDA,M->C5_TXMOEDA,M->C5_EMISSAO},M->C5_EMISSAO,3)
		EndIf

		//Quando não for exclusão do pedido, incluirá os registros de validação na SCR (Alçadas) 
		If nOpcao <> 3
			For nContI := 1 To nTotItens

				If !aCols[nContI][nDeleted]
					nTotalPed += aCols[nContI][nPosVal]
					If ( aCols[nContI][nPosPrUnt] == 0 )
						nTotalDes += aCols[nContI][nPosVlDes]
					Else
						If !Empty(M->C5_MDCONTR) .Or. !Empty(M->C5_MDNUMED)
							nTotalDes += aCols[nContI][nPosVlDes]
						Else
							nTotalDes += A410Arred((aCols[nContI][nPosPrUnt]*aCols[nContI][nPosQdVen]),"C6_VALOR")-A410Arred((aCols[nContI][nPosPcVen]*aCols[nContI][nPosQdVen]),"C6_VALOR")
						EndIf
					EndIf
				EndIf

			Next nContI

			nTotalDes  += A410Arred(nTotalPed*M->C5_PDESCAB/100,"C6_VALOR")
			nTotalPed  -= A410Arred(nTotalPed*M->C5_PDESCAB/100,"C6_VALOR")
			nTotalPed  -= M->C5_DESCONT
			nTotalDes  += M->C5_DESCONT

			//Função MaAlcDoc que executa a gravação de alçadas pelo compras
			//Caso tenha o parâmetro MV_TALCFAT = 2 e tenha desconto,  
			//envia o tipo "DV" e o total de desconto do Pedido
			If nTpAlcFat == 2 .And. nTotalDes > 0 
				
				MaAlcDoc({M->C5_NUM,"DV",nTotalDes,,,cGrpAprov,,M->C5_MOEDA,M->C5_TXMOEDA,M->C5_EMISSAO},,1)
				
				//Verifica se o registro de bloqueio de alçadas (SCR) foi criado,
				//se existir, haverá bloqueio
				SCR->(dbSetOrder(1))
				If SCR->(dbSeek(FwxFilial("SCR") + "DV" + M->C5_NUM))
					M->C5_CONAPRO := "B"
				Else
					M->C5_CONAPRO := "L"
				EndIf

			//Caso tenha o parâmetro MV_TALCFAT = 1 , envia o tipo "PV"  e o total do pedido
			ElseIf nTpAlcFat == 1

				MaAlcDoc({M->C5_NUM,"PV",nTotalPed,,,cGrpAprov,,M->C5_MOEDA,M->C5_TXMOEDA,M->C5_EMISSAO},,1)	

				//Verifica se o registro de bloqueio de alçadas (SCR) foi criado,
				//se existir, haverá bloqueio
				SCR->(dbSetOrder(1))
				If SCR->(dbSeek(FwxFilial("SCR") + "PV" + M->C5_NUM))
					M->C5_CONAPRO := "B"
				Else
					M->C5_CONAPRO := "L"
				EndIf

			//Caso tenha o parâmetro MV_TALCFAT = 2 e não tenha desconto, não haverá bloqueio 	
			Else
				M->C5_CONAPRO := "L"
			EndIF
		EndIf	

	EndIf

	RestArea(aArea)

Return .T.

/*/{Protheus.doc} OpAlcFat

Função que especifica qual tipo de ação de alçadas será tomada para o Faturamento
nTpOper -> Tipo da Operação a ser executada
cScrNum	-> Código do registro posicionado na SCR - Alçadas
cChaveSCR -> Chave referente ao registro da SCR a ser rejeitado.

@type       Function
@author     CRM/Faturamento
@since      Outubro/2023
@version    12.1.2310
@return    
/*/
Function OpAlcFat(nTpOper as Numeric,cScrNum as character,cChaveSCR as character) as Logical

	Local aArea 		as Array
	Local lRet			as Logical
	Local cNumero		as character
	Local aAreaSCR		as Array

	Default nTpOper 	:= 0 	//Tipo da Operação a ser executada
	Default cScrNum		:= "" 	//Código do registro posicionado na SCR - Alçadas
	Default cChaveSCR   := ""  // Chave referente ao registro da SCR a ser rejeitado.

	aArea 		:= GetArea()
	lRet		:= .F.
	cNumero		:= ""
	aAreaSCR	:= {}

	If nTpOper == 1 // Visualiza Pedido de Venda na consulta de alçadas
		aAreaSCR := SCR->(GetArea())
		DbSelectArea("SC5")
		DbSetOrder(1)
		If MsSeek(FwxFilial("SC5")+Substr(cScrNum,1,len(SC5->C5_NUM)))
			A410Visual("SC5",SC5->(Recno()),2)
		EndIf
		RestArea(aAreaSCR)

	ElseIf nTpOper == 2 //Liberação da alçada para o Pedido de venda
		DbSelectArea("SC5")
		DbSetOrder(1)
		If SC5->(MsSeek(FwxFilial("SC5") + Padr(cScrNum,len(SC5->C5_NUM))))				
			Reclock("SC5",.F.)
			SC5->C5_CONAPRO := "L"
			MsUnlock()	
		EndIf

	ElseIf nTpOper == 3 //Valida se permite executar o estorno de liberação do Pedido de vendas
		DbSelectArea("SC9")
		DbSetOrder(1)
		If MsSeek(FwxFilial("SC9")+Substr(cScrNum,1,len(SC9->C9_PEDIDO))) // Caso exista qualquer liberção que criou SC9, não permite o estorno	
			Help(" ", 1, "ALCESTORNO", Nil, STR0024, 2, 0, Nil, Nil, Nil, Nil, Nil,{ STR0025 } )
			lRet := .F.
		else
			lRet := .T.
		EndIf

	ElseIf nTpOper == 4 // Verifica se o pedido de Venda não esta com lock  
		cNumero := Substr(cScrNum,1,len(SC5->C5_NUM))
		DbSelectArea("SC5")
		DbSetOrder(1)
		If SC5->(MsSeek(FwxFilial("SC5") + cNumero))
			While SC5->(!Eof()) .And. SC5->C5_FILIAL + SC5->C5_NUM == FwxFilial("SC5") + cNumero
				If RecLock("SC5")
					lRet := .T.
				Endif
				SC5->(dbSkip())
			EndDo
		EndIf

	ElseIf nTpOper == 5 //Bloqueia após a confirmação de estorno
		DbSelectArea("SC5")
		DbSetOrder(1)
		If SC5->(MsSeek(FwxFilial("SC5") + Padr(cScrNum,len(SC5->C5_NUM))))				
			Reclock("SC5",.F.)
			SC5->C5_CONAPRO := "B"
			MsUnlock()	
		EndIf

	ElseIf nTpOper == 6 //Rejeição
		DbSelectArea("SC5")
		SC5->(dbSetOrder(1))
		If SC5->(MsSeek(cChaveSCR))
			RecLock("SC5",.F.)
			SC5->C5_CONAPRO := 'R'
			SC5->(MsUnlock())
		EndIf
	EndIf

	RestArea(aArea)

Return (lRet)

/*/{Protheus.doc} FatItGrid

Realiza a carga do grid de Alçadas de Aprovação para itens do Pedido de Venda (SC6)
@Param oModelGrid -> Recebe o modelo de grid com os itens da sc6 na aprovação 
alçadas

@author CRM/Faturamento
@since 01/2025
@return aLoad --> Dados da carga
/*/
Function FatItGrid(oModelGrid as Object) as array

	Local aLoad 		as Array
	Local aFields		as Array
	Local aItens 		as Array
	Local nX			as Numeric
	Local nZ 			as Numeric
	Local aStrField 	as Array
	Local cQrySC6		as Character
	Local cAliasSC6		as Character

	Default oModelGrid	:= Nil

	aLoad 		:= {}
	aFields		:= oModelGrid:GetStruct():aFields
	aItens 		:= {}
	nX			:= 1
	nZ 			:= 0
	aStrField 	:= {}
	cQrySC6		:= ""
	cAliasSC6	:= ""

	For nX := 1 To len(aFields)
		aAdd(aStrField,aFields[nX][3])
	Next nX

	cQrySC6 := "SELECT SC6.C6_ITEM, SC6.C6_PRODUTO, SC6.C6_DESCRI, SC6.C6_UM, SC6.C6_SEGUM, SC6.C6_QTDVEN, "
	cQrySC6 += "SC6.C6_UNSVEN, SC6.C6_PRCVEN, SC6.C6_VALOR, SC6.C6_DESCONT, SC6.C6_VALDESC "
	cQrySC6 += "FROM "+RetSqlName("SC6")+" SC6 "
	cQrySC6 += "WHERE SC6.C6_FILIAL='"+FWxFilial("SC6")+"'AND " 
	cQrySC6 += "SC6.C6_NUM='"+Substr(SCR->CR_NUM,1,len(SC6->C6_NUM))+"' AND " 
	cQrySC6 += "SC6.D_E_L_E_T_ = ' ' "
	cQrySC6 += "ORDER BY C6_FILIAL, C6_NUM, C6_ITEM, C6_PRODUTO "

	cQrySC6 	:= ChangeQuery(cQrySC6)
	cAliasSC6 	:= MPSysOpenQuery(cQrySC6)

	While !(cAliasSC6)->(EOF()) 
		
		aItens := {}
		nZ++
		For nX := 1 To len(aStrField)
			If aStrField[nX] == "C6_ITEM"
				aAdd(aItens,(cAliasSC6)->C6_ITEM)					
			ElseIf aStrField[nX] == "C6_PRODUTO"
				aAdd(aItens,(cAliasSC6)->C6_PRODUTO)
			ElseIf aStrField[nX] == "C6_DESCRI"
				aAdd(aItens,(cAliasSC6)->C6_DESCRI)
			ElseIf aStrField[nX] == "C6_UM"
				aAdd(aItens,(cAliasSC6)->C6_UM)
			ElseIf aStrField[nX] == "C6_SEGUM"
				aAdd(aItens,(cAliasSC6)->C6_SEGUM)
			ElseIf aStrField[nX] == "C6_QTDVEN"
				aAdd(aItens,(cAliasSC6)->C6_QTDVEN)
			ElseIf aStrField[nX] == "C6_UNSVEN"
				aAdd(aItens,(cAliasSC6)->C6_UNSVEN)
			ElseIf aStrField[nX] == "C6_PRCVEN"
				aAdd(aItens,(cAliasSC6)->C6_PRCVEN)
			ElseIf aStrField[nX] == "C6_VALOR"
				aAdd(aItens,(cAliasSC6)->C6_VALOR)	
			ElseIf aStrField[nX] == "C6_DESCONT"
				aAdd(aItens,(cAliasSC6)->C6_DESCONT)	
			ElseIf aStrField[nX] == "C6_VALDESC"
				aAdd(aItens,(cAliasSC6)->C6_VALDESC)	
			EndIf
		Next nX

		aAdd(aLoad,{nZ,aItens})

		(cAliasSC6)->(dbSkip())

	EndDo

	(cAliasSC6)->(DbCloseArea())

Return aLoad
