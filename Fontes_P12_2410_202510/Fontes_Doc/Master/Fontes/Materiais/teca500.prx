#INCLUDE "TOTVS.CH"
#INCLUDE "VKEY.CH"
#INCLUDE "COLORS.CH"
#INCLUDE "TBICONN.CH"
#INCLUDE "TECA500.CH"      
#INCLUDE "FWEVENTVIEWCONSTS.CH"
#INCLUDE "FWMVCDEF.CH"

/*/


Ŀ
Program   TECA500    Autor  Eduardo Riera          Data  20.10.98 
Ĵ
Descrio  Manutencao da Agenda dos Tecnicos                          
Ĵ
Retorno    Nenhum                                                     
Ĵ
Parametros Nenhum                                                     
                                                                      
Ĵ
   DATA    Programador   Manutencao Efetuada                         
Ĵ
                                                                     
ٱ


/*/
Function TECA500(xAutoTec,xAutoAge)

Private aRotina := MenuDef()
Private aParam	:= {}

//Ŀ
// Define o cabecalho da tela de atualizacoes                   
//
Private cCadastro := STR0004	//"Agenda dos Atendentes"

If	xAutoTec <> Nil .And. xAutoAge <> Nil
	Private lAt500Auto := .T.
	Private aAutoAge
	Private dAutoDia

	aAutoAge := xAutoAge
	
	dAutoDia := aAutoAge[1,Ascan(aAutoAge[1],{|x|Upper(Alltrim(x[1]))=="ABB_DTINI"}),2]
	
	MBrowseAuto(4,xAutoTec,"AA1")

Else
	mBrowse( 6, 1,22,75,"AA1")
EndIf
Return(.T.)

/*/

Ŀ
Funo    MenuDef    Autor  Conrado Q. Gomes       Data  08.12.06 
Ĵ
Descrio  Definio do aRotina (Menu funcional)                      
Ĵ
Sintaxe    MenuDef()                                                  
Ĵ
Parametros                                                            
Ĵ
 Uso       TECA500                                                    
ٱ


/*/
Static Function MenuDef()
//Ŀ
// Define Array contendo as Rotinas a executar do programa      
// ----------- Elementos contidos por dimensao ------------     
// 1. Nome a aparecer no cabecalho                              
// 2. Nome da Rotina associada                                  
// 3. Usado pela rotina                                         
// 4. Tipo de Transao a ser efetuada                          
//    1 - Pesquisa e Posiciona em um Banco de Dados             
//    2 - Simplesmente Mostra os Campos                         
//    3 - Inclui registros no Bancos de Dados                   
//    4 - Altera o registro corrente                            
//    5 - Remove o registro corrente do Banco de Dados          
//
Local aRotina := {	{STR0001, "AxPesqui",   0, 1, 0, .F.}	,;	//"Pesquisar"
						{STR0002, "AxVisual",   0, 2, 0, .T.}	,;	//"Visualizar"
						{STR0003, "AT500Age",   0, 4, 0, .T.}	,;	//"Agenda"
						{STR0028, "AT500Param", 0, 4, 0, .T.}	,;	//"Gantt"                     
						{STR0010, "At500Aloc",  0, 4, 0, .T.}	}	//"Schedule"
Return(aRotina)

/*/


Ŀ
Funcao    AT500AGE   Autor Eduardo Riera           Data  20.10.98 
Ĵ
Descrio  Agenda dos Tecnicos                                        
Ĵ
Retorno    Nenhum                                                     
Ĵ
Parametros ExpC1 : Alias                                              
           ExpN1 : Numero do Registro                                 
           ExpN2 : Opcao Selecionada                                  
Ĵ
   DATA    Programador   Manutencao Efetuada                         
Ĵ
                                                                     
ٱ


/*/

Function AT500AGE(cAlias,nReg,nOpcx)

Local aSize     := {}
Local aObjects  := {} 
Local aObjects2 := {}
Local aInfo     := {} 
Local aDiasAloc := {} 

Local oDlg
Local oBar
Local oBrowse
Local oColuna1
Local oColuna2
Local oCalend
Local oFont
Local oMenu 

Local aGet 		:= {{ 0 , 0 },{ 0 , 0 },{0 ,0 }}
Local aButtons := {}
Local aAgenda  := {}
Local oPanel
Local nForeCor := 0
Local nBackCor := 0
Local nCol     := 0 
Local nLin     := 0 
Local oColuna


If Type("lAt500Auto")=="U" .Or. !lAt500Auto
	//Ŀ
	// Divide a tela lateralmente e resolve as dimensoes de cada parte     
	//
	
	aSize    := MsAdvSize( .F. ) 
	
	aObjects := {}           
	
	aAdd( aObjects, { 100, 100, .t., .t., .t. } )
	aAdd( aObjects, { 140,  66, .F., .T. } )
	
	aInfo    := { aSize[ 1 ], aSize[ 2 ], aSize[ 3 ], aSize[ 4 ], 3, 3 } 
	aPosObj1 := MsObjSize( aInfo, aObjects,  , .T. ) 
	
	//Ŀ
	// Resolve as dimensoes dos objetos da parte direita da tela           
	//
	aObjects := {} 
	aAdd( aObjects, { 140,  66, .T., .F. } ) 
	aAdd( aObjects, { 100, 100, .T., .T. } )
	
	aSize2 := aClone( aPosObj1[2] )
	
	aInfo    := { aSize2[ 2 ], aSize2[ 1 ], aSize2[ 4 ], aSize2[ 3 ], 3, 3, 0, 0 } 
	aPosObj2 := MsObjSize( aInfo, aObjects )
	
	DEFINE MSDIALOG oDlg TITLE STR0005 + Capital( AA1->AA1_NOMTEC ) FROM aSize[7],0 TO aSize[6],aSize[5] OF oMainWnd PIXEL //"Agenda do Tecnico: "
	
	nLin := aPosObj2[2,1]
	nCol := aPosObj2[2,2]
	
	@ nLin,nCol TO aPosObj2[2,3],aPosObj2[2,4] PIXEL
	
	@ nLin +  8,nCol + 09 SAY STR0007 SIZE 075,008 OF oDlg PIXEL //"Horas Alocadas no Mes"
	@ nLin + 18,nCol + 09 SAY STR0012 SIZE 075,008 OF oDlg PIXEL //"Dias  Alocados no Mes" //"Numero de alocacoes / Mes"
	@ nLin + 28,nCol + 09 SAY STR0013      SIZE 075,008 OF oDlg PIXEL  //"Datas alocadas / Mes"
	
	@ nLin +  8,nCol + 84 MSGET aGet[1][1] VAR aGet[1][2] SIZE 050,008 OF oDlg PIXEL WHEN .F.
	@ nLin + 18,nCol + 84 MSGET aGet[2][1] VAR aGet[2][2] SIZE 050,008 OF oDlg PIXEL WHEN .F. PICTURE "999999"
	@ nLin + 28,nCol + 84 MSGET aGet[3][1] VAR aGet[3][2] SIZE 050,008 OF oDlg PIXEL WHEN .F. PICTURE "999999"
	
	DEFINE SBUTTON FROM aPosObj2[2,3]-18,nCol+5   TYPE 11 	ACTION Eval(oCalend:bLDblClick) ENABLE OF oDlg 
	
	DEFINE SBUTTON FROM aPosObj2[2,3]-18,nCol+40  TYPE 15 	ACTION ( At500ViOs( @oBrowse ) ) ENABLE OF oDlg ONSTOP STR0011 // "Ordem de Servico"
	
	DEFINE SBUTTON FROM aPosObj2[2,3]-18,nCol+107 TYPE 1 	ACTION oDlg:End() ENABLE OF oDlg  
	
	@ aPosObj1[1,1],aPosObj1[1,2] MSPANEL oPanel  PROMPT "" SIZE aPosObj1[1,3],11 OF oDlg CENTERED LOWERED
	oBrowse := TSBrowse():New(aPosObj1[1,1] + 11,aPosObj1[1,2],aPosObj1[1,3],aPosObj1[1,4]-11,oDlg,,35,oFont,5 )
	
	oBrowse:SetArray(aAgenda)
	
	nForeCor := CLR_BLACK
	nBackCor := CLR_HGRAY
	
	
	oColuna:= TcColumn():New("",,,{|| nForeCor },{|| nBackCor })
	oColuna:lNoLite := .F.
	oColuna:nWidth := 55
	oBrowse:AddColumn(oColuna)
	oBrowse:lJustific := .F.
	
	oColuna1 := TcColumn():New("",,,{|| nForeCor },{|| nBackCor })
	oColuna1:lNoLite := .T.
	oColuna1:nWidth := 60
	oBrowse:AddColumn(oColuna1)
	oBrowse:lJustific := .F.
	
	oColuna2 := TcColumn():New(STR0009,,,{|| CLR_BLUE },{|| CLR_WHITE})	//"Informaes"
	oColuna2:lNoLite := .T.
	oColuna2:nWidth := 120
	oBrowse:AddColumn(oColuna2)
	
	oCalend:=MsCalend():New( aPosObj2[1,1],aPosObj2[1,2],oDlg,.F.)
	oCalend:bChange := {|| At500ChgDia(@oBrowse,@oCalend,@oPanel,aDiasAloc) }
	
	oCalend:bChangeMes := {|| At500ChgMes(@oCalend,aGet,@aDiasAloc) }
	
	oCalend:bLDblClick := {|| At500Alter(oCalend:dDiaAtu,@aDiasAloc),;
						At500ChgMes(@oCalend,@aGet,@aDiasAloc),At500ChgDia(@oBrowse,@oCalend,@oPanel,aDiasAloc),;
						oDlg:Refresh() }             
											
	oBrowse:bLdblClick := oCalend:bLDblClick
	
	MENU oMenu POPUP                                                  
		MENUITEM STR0014  Action Eval( oCalend:bLdblClick )       //"Alocacao"
		MENUITEM STR0015  Action At500ViOs( @oBrowse )            //"Ordem de Servico"
		MENUITEM STR0016  Action At500Goto(oCalend,aDiasAloc,1)   //"Posiciona no inicio"
		MENUITEM STR0017  Action At500Goto(oCalend,aDiasAloc,2)   //"Posiciona no final"
		MENUITEM STR0018  Action ( oCalend:dDiaAtu := dDataBase, Eval( oCalend:bChange ) ) // "Hoje"
	ENDMENU
	
	oCalend:bRClicked  := { |oObject,nx,ny| oMenu:Activate( nX, nY, oObject ) }
											
	ACTIVATE DIALOG oDlg ON INIT (At500ChgMes(@oCalend,@aGet,@aDiasAloc),At500ChgDia(@oBrowse,@oCalend,@oPanel,aDiasAloc))
Else
	At500ChgMes(,,@aDiasAloc)
	At500Alter(dAutoDia,aDiasAloc)
EndIf	
Return(.T.)
/*/


Ŀ
Funcao    At500Alter Autor  Eduardo Riera          Data  27.10.98 
Ĵ
Descrio  Cadastro da Agenda dos Tecnicos                            
Ĵ
Retorno    Nenhum                                                     
Ĵ
Parametros ExpD1 : Data de Inicio da Alocacao.                        
                                                                      
ٱ


/*/

Function At500Alter(dDataIni,aDiasAloc)

Local lGravou		:= .F.											// Se houve ou no a gravao do agendamento do tcnico
Local nOpcA			:= 0											// Opo selecionada no dilogo
Local oDlg			:= Nil											// Objeto do dilogo principal
Local oGetD			:= Nil											// Getdados utilizada com os agendamentos
Local nOpcx			:= 2 											// Varivel de verificao de disponibilidade de alocao
Local lNot500Auto	:= Type("lAt500Auto")=="U" .Or. !lAt500Auto	// Vrivel com informao se  ou no rotina automtica
Local aNoFields		:= ""											// Campos que no sero adicionados ao aHeader
Local aTravas		:= {}											// Campos que foram travados
Local lTravas		:= .T.											// Se todos os campos foram travados com sucesso
Local lAT500OK	:= ExistBlock("AT500OK")						// Ponto de entrada no final da gravao do agendamento
Local aAreaABB	:= {}
Local aAreaAA1	:= {}
Local oModel
Local cTipo		:= AA1->AA1_TIPO
Local cAloca	:= AA1->AA1_ALOCA
Local cTecnico	:= AA1->AA1_CODTEC

Private aCols		:= {}
Private aHeader		:= {}
Private aRegistros	:= {}
Private dData		:= dDataIni 									//Utilizado no inicializador padrao.

//Ŀ
// Verifica, baseado no tipo de tecnico e disponibilidade, se permite      
// a alteracao                                                            
//
RegToMemory("ABB")
nOpcx := If( cTipo $ "13" .And. cAloca == "1", 3, 2 )  

If nOpcx == 2 
	If lNot500Auto
		Help( " ", 1, "AT500VISU" ) // 	Nao e permitida a alteracao deste tecnico
		Return .F.
	EndIf
EndIf 

//Posiciona novamente na tabela AA1
DbSelectArea("AA1")
AA1->(DbSetOrder(1))
AA1->(MsSeek(xFilial("AA1") + cTecnico))

//Verifica se o tcnico est bloqueado
If !RegistroOk("AA1")
	Return .F.
EndIf

//Ŀ
//Montagem aHeader, aCols
//
aNoFields := {	"ABB_CODTEC"	,"ABB_NOMTEC"	}

If Len(aHeader) == 0 .AND. Len(aCols) == 0
	If !FillGetDados(	nOpcx				,"ABB"			,1													,/*cSeek*/			,;
		  				/*{|| &cWhile }*/	,{|| .T. }		,aNoFields											,/*aYesFields*/		,; 
						/*lOnlyYes*/		,/*cQuery*/		,{ || At500MontCols(dDataIni, aDiasAloc, aTravas) }	,/*lEmpty*/			,;
						/*aHeaderAux*/		,/*aColsAux*/	,/*bAfterCols*/										,/*bBeforeCols*/	)
		lTravas := .F.
	Endif
Endif

If ( lTravas )
	If lNot500Auto
		aAreaABB := ABB->(GetArea())
		aAreaAA1 := AA1->(GetArea())
		DbSelectArea("ABB")
		DbSetOrder(1)
		Private n := 1 
		If DbSeek(XFilial("ABB")+AA1->AA1_CODTEC)							
			FWExecView(,'TECA520', MODEL_OPERATION_UPDATE,, { || .T. },,25 )
		Else		
			INCLUI := .T.		
			FWExecView(,'TECA520', MODEL_OPERATION_INSERT,, { || .T. },,25 )
			INCLUI := .F.			
		EndIf
		RestArea(aAreaABB)
		RestArea(aAreaAA1)
	Else
		If MsGetDAuto(aAutoAge,"AT500LINOK",{|| AT500TUDOK()},{{"","",Nil}},4,.F.)
			nOpcA := 1
		EndIf
	EndIf
	If ( nOpcA == 1 )
	    If lAT500OK
	    	ExecBlock("AT500OK", .F., .F.)
	    EndIf
		
		Begin Transaction
			lGravou := aT500Grava()
			If ( lGravou )
				EvalTrigger()
				While ( __lSx8 )
					ConfirmSx8()
				EndDo
			EndIf
		End Transaction
	EndIf
EndIf
While ( __lSx8 )
	RollBackSx8()
EndDo

//Ŀ
//Efetua o destravamento dos registros travados.
//
AtDestravaReg( aTravas )

Return(lGravou)

/*/


Ŀ
Funcao    AT500Grava Autor  Eduardo Riera          Data  27.10.98 
Ĵ
Descrio  Efetua a Gravacao da Agenda do Tecnico                     
Ĵ
Retorno    ExpL1 : Indica se efetuou a Gravacao                       
Ĵ
Parametros Nenhum                                                     
                                                                      
Ĵ
   DATA    Programador   Manutencao Efetuada                         
Ĵ
                                                                     
ٱ


/*/

Function At500Grava()

Local nCntFor := 0
Local nCntFor2:= 0
Local nUsado  := Len(aHeader)
Local lGravou := .F.
Local dDataIni:= Ctod("")
Local dDataFim:= Ctod("")
Local cHoraIni:= ""
Local cHoraFim:= ""                                      
Local cCrLf   := Chr(13) + Chr(10) 
Local cCorpo  := "" 
Local nPosDIni:= aScan(aHeader,{|x| AllTrim(x[2])=="ABB_DTINI"})
Local nPosDFim:= aScan(aHeader,{|x| AllTrim(x[2])=="ABB_DTFIM"})
Local nPosHIni:= aScan(aHeader,{|x| AllTrim(x[2])=="ABB_HRINI"})
Local nPosHFim:= aScan(aHeader,{|x| AllTrim(x[2])=="ABB_HRFIM"})
Local lAT500Alt:= ExistBlock("AT500ALT")
Local lAT500Grv:= ExistBlock("AT500GRV")
Local lAT500Del:= ExistBlock("AT500DEL")
Local cEventID      := ""                              // Id do Evento a ser disparado pelo Event Viewer
Local cMensagem     := ""                              // Mensagem que sera enviada por e-mail ou RSS pelo Event Viewer
Local cTecnico      := ""                              // Nome do Tecnico alocado


For nCntFor := 1 To Len(aCols)
	dDataIni := aCols[nCntFor][nPosDIni]
	dDataFim := aCols[nCntFor][nPosDFim]
	cHoraIni := aCols[nCntFor][nPosHIni]
	cHoraFim := aCols[nCntFor][nPosHFim]
	dbSelectArea("ABB")
	dbSetOrder(1)
	If ( nCntFor > Len(aRegistros) )
		If ( !aCols[nCntFor][nUsado+1] )
			RecLock("ABB",.T.) 
		EndIf
	Else
		dbGoto(aRegistros[nCntFor])
		RecLock("ABB")
	EndIf

	AB6->( dbSetOrder( 1 ) ) 		
	AB6->( DbSeek( xFilial( "AB6" ) + GDFieldGet( "ABB_NUMOS", nCntFor ) ) ) 
	
	SA1->( dbSetOrder( 1 ) ) 
	SA1->( DbSeek( xFilial( "SA1" ) + AB6->AB6_CODCLI + AB6->AB6_LOJA ) ) 	

	// "Cliente: ", "Endereco: ", "Municipio: ", "UF: ", "Telefone: " 
	cCorpo 	:=	AllTrim(RetTitle( "A1_COD" ))+ ": " + SA1->A1_COD + " - " + SA1->A1_NOME + cCrLf +;
				AllTrim(RetTitle( "A1_END" ))+ ": " + SA1->A1_END + cCrLf +;
				AllTrim(RetTitle( "A1_MUN" ))+ ": " + SA1->A1_MUN + cCrLf +;
				AllTrim(RetTitle( "A1_EST" ))+ ": " + SA1->A1_EST + cCrLf +;
				AllTrim(RetTitle( "A1_TEL" )) +": " + SA1->A1_TEL 
	
	If ( !aCols[nCntFor][nUsado+1] .And. !Empty(cHoraIni) )			
		//Ŀ
		// Envia o e-Mail caso um campo importante tenha sido alterado            
		//		
		If ABB->ABB_DTINI <> dDataIni .Or. ABB->ABB_HRINI <> cHoraIni .Or. ;
				ABB->ABB_DTFIM <> dDataFim .Or. ABB->ABB_HRFIM <> cHoraFim .Or. ;
				ABB->ABB_NUMOS <> GDFieldGet( "ABB_NUMOS", nCntFor ) 		      
				
			If lAT500Alt
				ExecBlock( "AT500ALT", .F., .F.) 
			EndIf
			
			//Ŀ
			// Event Viewer - Envia e-mail ou RSS para    
			//| Alocacao de Tecnicos - Field Service.      
			//

			cEventID  := "009"
			cMensagem := STR0035 + " - " + GDFieldGet( "ABB_NUMOS" )+ " " + cCorpo
			cTecnico  := STR0034 + " - " + AllTrim( AA1->AA1_NOMTEC )
			EventInsert(FW_EV_CHANEL_ENVIRONMENT, FW_EV_CATEGORY_MODULES, cEventID, FW_EV_LEVEL_INFO,""/*cCargo*/,cTecnico,cMensagem)

		EndIf
		
		For nCntFor2 := 1 To nUsado
			If aHeader[nCntFor2][10] <> "V"
				ABB->(FieldPut(FieldPos(aHeader[nCntFor2][2]),aCols[nCntFor][nCntFor2]))
			EndIf	
		Next nCntFor2
		ABB->ABB_FILIAL 	:= xFilial("ABB")
		ABB->ABB_CODTEC 	:= AA1->AA1_CODTEC
		lGravou := .T.          
		
		If lAT500Grv
			ExecBlock( "AT500GRV", .F., .F.) 
		EndIf
	Else
		If ( nCntFor <= Len(aRegistros) )
			If lAT500Del
				ExecBlock( "AT500DEL", .F., .F.) 
			EndIf
			
			//Ŀ
			// Event Viewer - Envia e-mail ou RSS para    
			//| Alocacao de Tecnicos - Field Service.      
			//

			cEventID  := "009"
			cMensagem := STR0035 + " - " + GDFieldGet( "ABB_NUMOS" )+ " " + cCorpo
			cTecnico  := STR0034 + " - " + AllTrim( AA1->AA1_NOMTEC )
			EventInsert(FW_EV_CHANEL_ENVIRONMENT, FW_EV_CATEGORY_MODULES, cEventID, FW_EV_LEVEL_INFO,""/*cCargo*/,cTecnico,cMensagem) 

			ABB->(dbDelete())
		EndIf
	EndIf
Next nCntFor
Return(lGravou)

/*/


Ŀ
Funcao    At500LinOk Autor  Eduardo Riera          Data  27.10.98 
Ĵ
Descrio  Tratamento da Linha Ok da GetDados                         
Ĵ
Retorno    ExpL1: Indica se a Linha e valida                          
Ĵ
Parametros Nenhum                                                     
                                                                      
ٱ


/*/
Function At500LinOk()

Local lRetorno := .T.													//Retorno da funcao
Local nPosDtIni:= aScan(aHeader,{|x| AllTrim(x[2])=="ABB_DTINI"})		//Posicao do campo ABB_DTINI
Local nPosDtFim:= aScan(aHeader,{|x| AllTrim(x[2])=="ABB_DTFIM"})		//Posicao do campo ABB_DTFIM
Local nPosHrIni:= aScan(aHeader,{|x| AllTrim(x[2])=="ABB_HRINI"})		//Posicao do campo ABB_HRINI
Local nPosHrFim:= aScan(aHeader,{|x| AllTrim(x[2])=="ABB_HRFIM"})		//Posicao do campo ABB_HRFIM
Local nUsado   := Len(aHeader)											//Nr. de campo no aHeader
Local nCntFor  := 0														//Usado em lacos For...Next

If ( !aCols[n][nUsado+1] )
	If ( 	!Empty(aCols[n][nPosDtIni]) .And.;
			!Empty(aCols[n][nPosDtFim]) .And.;
			!Empty(aCols[n][nPosHrIni]) .And.;
			!Empty(aCols[n][nPosHrFim]) )
		If ( Empty(AtTotHora(aCols[n][nPosDtIni],aCols[n][nPosHrIni],aCols[n][nPosDtFim],aCols[n][nPosHrFim])) )
			Help(" ",1,"AT500DATA3")
			lRetorno := .F.
		EndIf
	Else
		Help(" ",1,"AT500DATA3")
		lRetorno := .F.
	EndIf
	//Ŀ
	//Verifica se o horario nao esta alocado na Base                          
	//
	dbSelectArea("ABB")
	dbSetOrder(2) //ABB_FILIAL+ABB_CODTEC+DTOS(ABB_DTFIM)+ABB_HRFIM                                                                                                                 
	dbSeek(xFilial("ABB")+AA1->AA1_CODTEC+DTOS(aCols[n][nPosDtFim])+aCols[n][nPosHrFim],.T.)
	If (ABB->ABB_CODTEC == AA1->AA1_CODTEC)
		If((aCols[n][nPosDtFim] <= ABB->ABB_DTFIM .And.;
				aCols[n][nPosHrFim] <= ABB->ABB_HRFIM .And.;
				aCols[n][nPosDtFim] >= ABB->ABB_DTINI .And.;
				aCols[n][nPosHrFim] >= ABB->ABB_HRINI ) .Or.;
				(aCols[n][nPosDtIni] <= ABB->ABB_DTFIM .And.;
				aCols[n][nPosHrIni] <= ABB->ABB_HRFIM .And.;
				aCols[n][nPosDtIni] >= ABB->ABB_DTINI .And.;
				aCols[n][nPosHrIni] >= ABB->ABB_HRINI))
		    If ( aScan(aRegistros,ABB->(RecNo()))==0 )
				Help(" ",1,"AT500LIN01")
				lRetorno := .F.
	        EndIf 
	    EndIf    
	EndIf
	//Ŀ
	//Verifica se o horario nao esta alocado no Acols                         
	//
	For nCntFor := 1 To Len(aCols)
		If ( !aCols[nCntFor][nUsado+1] )
			If (( aCols[n][nPosDtFim] <= aCols[nCntFor][nPosDtFim] .And.;
					aCols[n][nPosHrFim] <= aCols[nCntFor][nPosHrFim] .And.;
					aCols[n][nPosDtFim] >= aCols[nCntFor][nPosDtIni] .And.;
					aCols[n][nPosHrFim] > aCols[nCntFor][nPosHrIni] ) .Or.;
				 (	aCols[n][nPosDtIni] <= aCols[nCntFor][nPosDtFim] .And.;
					aCols[n][nPosHrIni] < aCols[nCntFor][nPosHrFim] .And.;
					aCols[n][nPosDtIni] >= aCols[nCntFor][nPosDtIni] .And.;
					aCols[n][nPosHrIni] >= aCols[nCntFor][nPosHrIni]))
            	If ( nCntFor <> n )
					Help(" ",1,"AT500LIN02")
					lRetorno := .F.
				EndIf
			EndIf
		EndIf
	Next nCntFor
EndIf
Return(lRetorno)

/*/


Ŀ
Funcao    At500TudOk Autor  Eduardo Riera          Data  27.10.98 
Ĵ
Descrio  Tratamento da TudoOk   da GetDados                         
Ĵ
Retorno    ExpL1: Indica se TudoOk e valida                           
Ĵ
Parametros Nenhum                                                     
                                                                      
Ĵ
   DATA    Programador   Manutencao Efetuada                         
Ĵ
                                                                     
ٱ


/*/

Function At500TudOk()

Local lRetorno := .T.

Return(lRetorno)

/*/


Ŀ
Funcao    At500Data  Autor  Eduardo Riera          Data  27.10.98 
Ĵ
Descrio  Valida a Data Inicial e Final do Agendamento               
Ĵ
Retorno    ExpL1 : Indica se a data e Valida                          
Ĵ
Parametros Nenhum                                                     
                                                                      
Ĵ
   DATA    Programador   Manutencao Efetuada                         
Ĵ
                                                                     
ٱ


/*/

Function At500Data()

Local cReadVar := ""

Local lRetorno := .T.

Local dDtIni 
Local dDtFim
Local cHrIni
Local cHrFim
Local oModel := FwModelActive()

If(!IsInCallStack("AXINCLUI") .AND. !IsInCallStack("AXALTERA") .AND. !IsInCallStack("AXDELETA"))

	cReadVar := AllTrim( ReadVar() ) 
	
	If oModel != Nil .AND. (oModel:GetId() $ "TECA521|TECA520" )
		dDtIni := FwFldGet( "ABB_DTINI" )
		dDtFim := FwFldGet( "ABB_DTFIM" )
		cHrIni := FwFldGet( "ABB_HRINI" )
		cHrFim := FwFldGet( "ABB_HRFIM" )
	Else
		dDtIni := GDFieldGet( "ABB_DTINI" )
		dDtFim := GDFieldGet( "ABB_DTFIM" )
		cHrIni := GDFieldGet( "ABB_HRINI" )
		cHrFim := GDFieldGet( "ABB_HRFIM" )
	EndIf
	
	

	Do Case 
	Case "ABB_DTINI" $ cReadVar
		dDtIni := M->ABB_DTINI                               
	Case "ABB_DTFIM" $ cReadVar
		dDtFim := M->ABB_DTFIM
	Case "ABB_HRINI" $ cReadVar
		cHrIni := M->ABB_HRINI
	Case "ABB_HRFIM" $ cReadVar 
		cHrFim := M->ABB_HRFIM
	EndCase

	lRetorno := AtVldDiaHr( dDtIni, dDtFim, cHrIni, cHrFim )                            
	
	If !lRetorno 
		Do Case
			Case ( "ABB_DTINI"$cReadVar )
				Help(" ",1,"AT500DATA1")
			Case ( "ABB_DTFIM"$cReadVar )
				Help(" ",1,"AT500DATA2")
		EndCase  
	EndIf 	

Else

	dDtIni := M->ABB_DTINI                               
	dDtFim := M->ABB_DTFIM
	cHrIni := M->ABB_HRINI
	cHrFim := M->ABB_HRFIM

	lRetorno := AtVldDiaHr( dDtIni, dDtFim, cHrIni, cHrFim )                            

	If !lRetorno 
		Do Case
			Case ( "ABB_DTINI"$cReadVar )
				Help(" ",1,"AT500DATA1")
			Case ( "ABB_DTFIM"$cReadVar )
				Help(" ",1,"AT500DATA2")
		EndCase  
	EndIf 	
EndIf
	
Return(lRetorno)

/*/


Ŀ
Funcao    At500ChgDi Autor  Eduardo Riera          Data  27.10.98 
Ĵ
Descrio  Atualiza o browse quando o dia eh alterado.                
Ĵ
Retorno    Nenhum                                                     
Ĵ
Parametros ExpO1: Objeto do Browse                                    
           ExpO2: Objeto do Calendario                                
           ExpO3: Objeto                                              
           ExpA1: Array de dias alocados                              
ٱ


/*/

Static Function At500ChgDia(oBrowse,oCalend,oPanel,aDiasAloc)

Local aAgenda := {}
Local aHorario:= {}
Local aDia    := {} 
Local dData   := oCalend:dDiaAtu
Local aInfo1  := {}
Local aInfo2  := {}
Local cString1:= ""
Local cString2:= ""
Local cString := ""
Local nAux    := 0  
Local nLoop   := 0 
Local nScan   := 0 
Local nDia    := 0 
Local aCargo  := {}
Local lVis	  := .F. //Indica se os dados apresentados so de O.S.
Local aPadrao := {}
Local nX                           
Local cMV_AGEINF1 := SuperGetMV("MV_AGEINF1")
Local cMV_AGEINF2 := SuperGetMV("MV_AGEINF2")

// Ordena por Horario 

nDia := Day( dData )               

If !Empty( nScan := AScan( aDiasAloc, { |x| x[1] == nDia } ) )   

	aDia := aDiasAloc[ nScan, 2 ]

	//Ŀ
	// Ordena as alocacoes do dia por horario de chegada                      
	//
	ASort( aDia, , , { |x,y| y[2] > x[2] } ) 
	
	For nLoop := 1 to Len( aDia ) 
	
		ABB->( dbGoto( aDia[ nLoop, 1 ] ) )  
	
		//Ŀ
		//Posiciona Registros                                                     
		//
		If !Empty(ABB->ABB_NUMOS)	
			dbSelectArea("AB6")
			dbSetOrder(1)
			dbSeek(xFilial("AB6")+ABB->ABB_NUMOS)
	
			dbSelectArea("SA1")
			dbSetOrder(1)
			dbSeek(xFilial("SA1")+AB6->AB6_CODCLI+AB6->AB6_LOJA)
			
			aPadrao := {"AB6_NUMOS","AB6_CODCLI","AB6_LOJA","A1_NOME","A1_TEL","A1_END","A1_MUN","A1_EST","AB6_ATEND","ABB_OBSERV"}

		ElseIf !Empty(ABB->ABB_CHAVE)
			dbSelectArea("AAT")
			dbSetOrder(1)
			If dbSeek(XFilial("AAT")+ABB->ABB_CHAVE)

				If AAT->AAT_ENTIDA == "1"
					dbSelectArea("SA1")
					dbSetOrder(1)
					dbSeek(xFilial("SA1")+AAT->AAT_CODENT+AAT->AAT_LOJENT)
					aPadrao := {"AAT_CODVIS","A1_COD","A1_LOJA","A1_NOME","A1_TEL","A1_END","A1_MUN","A1_EST","ABB_OBSERV"}					
				Else
					dbSelectArea("SUS")
					dbSetOrder(1)
					dbSeek(xFilial("SUS")+AAT->AAT_CODENT+AAT->AAT_LOJENT)
					aPadrao := {"AAT_CODVIS","US_COD","US_LOJA","US_NOME","US_TEL","US_END","US_MUN","US_EST","ABB_OBSERV"}				
				EndIf	
				
				lVis := .T.	
												
			EndIf
		ElseIf !Empty(ABB->ABB_LOCAL)
			dbSelectArea("ABS")
			dbSetOrder(1)
			If dbSeek(xFilial("ABS")+ABB->ABB_LOCAL) 
				If  ABS->ABS_ENTIDA == '1'
					dbSelectArea("SA1")
					dbSetOrder(1)
					If dbSeek(xFilial("SA1")+ABS->ABS_CODIGO+ABS->ABS_LOJA)
						aPadrao := {"ABB_CODIGO","A1_COD","A1_LOJA","A1_NOME","A1_TEL","A1_END","A1_MUN","A1_EST","ABB_OBSERV"}
					EndIf
				Else
					dbSelectArea("SUS")
					dbSetOrder(1)
					If dbSeek(xFilial("SUS")+ABS->ABS_CODIGO+ABS->ABS_LOJA)
						aPadrao := {"ABB_CODIGO","US_COD","US_LOJA","US_NOME","US_TEL","US_END","US_MUN","US_EST","ABB_OBSERV"}
					EndIf	
				EndIf
			EndIf
		EndIf
	
		If 	!Empty(aPadrao)
		
			//Ŀ
			//Recupera as informacoes a serem apresentadas na agenda                  
			//
			aInfo1 := {}
			aInfo2 := {}
			cString1 := &(cMV_AGEINF1)
			If ( Empty(cString1) )
				For nX := 1 To Len(aPadrao)
					aAdd(aInfo1,RetTitle(aPadrao[nX]))
				Next nX
		   Else
				//Ŀ
				//Monta a agenda baseada no parametro os dados devem ser separados por ","
				//
				While Len(cString1)<>0
					nAux := If(At(",",cString1)==0,Len(cString1),At(",",cString1))
					aAdd(aInfo1,SubStr(cString1,1,nAux-If(At(",",cString1)==0,0,1)))
					cString1 := SubStr(cString1,nAux+1)
				EndDo
		   EndIf
			cString2 := &(cMV_AGEINF2)
			
			If ( Empty(cString2) )
				If Len(aPadrao) > 0	
					For nX := 1 To Len(aPadrao)
						If Empty(ABB->ABB_NUMOS) .And. aPadrao[nX] == "ABB_OBSERV"
							aAdd(aInfo2,ABB->ABB_OBSERV)
						Else
							aAdd(aInfo2,&(TxPrefix(aPadrao[nX])+"->"+aPadrao[nX]))
						EndIf					 
					Next nX				
				    
					aAdd( aCargo, {TxPrefix(aPadrao[1]),&(TxPrefix(aPadrao[1])+"->"+aPadrao[1])} )
				EndIf	
					
		   Else
				While Len(cString2)<>0
					nAux := If(At(",",cString2)==0,Len(cString2),At(",",cString2))
					aAdd(aInfo2,SubStr(cString2,1,nAux-If(At(",",cString2)==0,0,1)))
					cString2 := SubStr(cString2,nAux+1)
				EndDo
			EndIf
			cString  := If( ABB->ABB_DTINI == dData, ABB->ABB_HRINI, "..." ) + " / "
			cString1 := ""
			cString2	:= ""
			aEval(aInfo1,{|x| cString1 += AllTrim(x)+CRLF})
			aEval(aInfo2,{|x| cString2 += AllTrim(x)+CRLF})
			
			cString  += If(ABB->ABB_DTFIM == dData, ABB->ABB_HRFIM, "..." )
			
			cString1 := SubStr(cString1,1,Len(cString1)-2)
			cString2 := SubStr(cString2,1,Len(cString2)-2)
			
			aAdd(aAgenda, { cString , cString1 , cString2 })
		EndIf
	
	Next nLoop 

EndIf 

//Ŀ
//Verificao necessria para garantir que todas as linhas
//sero exibidas.                                         
//
If Max(Len(aInfo1),Len(aInfo2)) <= 7
	oBrowse:nLinhas   := Max(Min(Len(aInfo1),Len(aInfo2)),1)
Else
	oBrowse:nLinhas   := Max(Min(Len(aInfo1),Len(aInfo2))-1,1)	
Endif

oBrowse:Cargo := AClone( aCargo )   
oBrowse:SetArray(aAgenda)
oBrowse:Refresh()

oPanel:SetText(DiaExtenso(oCalend:dDiaAtu)+" - "+Dtoc(oCalend:dDiaAtu))


Return(.T.)


/*


Ŀ
Funcao    At500ChgMe Autor  Eduardo Riera          Data  28.10.98 
Ĵ
Descrio  Atualiza o array com os dias alocados.                     
Ĵ
Sintaxe    At500ChgMes( ExpO1, ExpA1, @ExpA2 )                        
Ĵ
Retorno    Nenhum                                                     
Ĵ
Parametros ExpO1: Objeto do Calendario                                
           ExpA1: Array com os Gets                                   
           ExpA2: Array com os dias alocados no mes:                  
                   1 - Dia alocado                                    
                   2 - Recno do ABB                                   
ٱ


*/

Static Function At500ChgMes(oCalend,aGet,aDiasAloc)

Local bWhile		:= { || .T. } 														// While da query
                                 
Local cQuery		:= ""																// Query para selecionar os dias com agendamento
Local cAliasABB		:= ""																// Alias da tabela ABB
Local cIndTrab		:= ""																// Arquivo de trabalho para a tabela temporria
Local cHoraIni		:= ""																// Hora inicial
Local cHrCalcIni	:= ""																// Hora inicial (Calculada)
Local cHrCalcFim	:= ""																// Hora final (Calculada)

Local dData		 	:= Ctod("")															// Temporrio utilizado para anlise de data
Local dRestri    	:= Ctod("") 														// Data da restrio
Local lNot500Auto	:= Type("lAt500Auto")=="U" .Or. !lAt500Auto						// Se a rotina est ou no sendo executado de forma automtica
Local dDataIni   	:= If(lNot500Auto, FirstDay(oCalend:dDiaAtu), FirstDay(dAutoDia))	// Data inicial do processamento
Local dDataFim   	:= If(lNot500Auto, LastDay(oCalend:dDiaAtu), LastDay(dAutoDia))	// Data final do processamento
Local dCalcIni   	:= Ctod("")															// Data inicial do processamento (Calculada)
Local dCalcFim   	:= Ctod("")															// Data final do processamento (Calculada)

Local nRecnoABB  	:= 0 																// Nmero do registro atual
Local nDiasAloc  	:= 0																// Quantidade de dias alocados
Local nHoraAloc  	:= 0 																// Quantidade de horas alocadas
Local nDias      	:= 0																// Quantidade de dias alocado (Calculado)
Local nHoras     	:= 0																// Quantidade de horas alocadas (Calculado)
Local nLoop      	:= 0 																// Temporrio para laos
Local nDiaIni    	:= 0 																// Dia inicial
Local nDiaFim    	:= 0 																// Dia final
Local nIndex     	:= 0            													// ndice do ABB
Local nScan      	:= 0 																// Temporrio para localizao de registro em uma array

Local aDiasFeriado 	:= {}																// Array com os dias que so feriados e se j foi ou no marcado no calendrio

If lNot500Auto
	oCalend:Hide()               
	oCalend:DelAllRestri()	    
EndIf

aDiasAloc := {}

//Ŀ
//Analiza os dias que so feriados.
//
dbSelectArea("SP3")
SP3->( dbSetOrder(01) )
SP3->( dbSeek( xFilial("SP3") + Dtos(dDataIni),.T.) )

While SP3->( !Eof() ) .AND. SP3->P3_FILIAL == xFilial("SP3") .AND. ;
						  ( Month(dDataIni) == Month( SP3->P3_DATA ) ) .AND. ;
						  ( Year(dDataIni) == Year( SP3->P3_DATA ) )
		aAdd( aDiasFeriado, { Day(SP3->P3_DATA), .F. } )
      SP3->( dbSkip() )
EndDo
DbSelectArea("ABB")

//Ŀ
// Analiza os dias alocados para troca de cor      
//
dData := dDataIni
While ( (dData)<=dDataFim )
	dData++
	dRestri	:= dData
	dData := DataValida(dData,.T.)
	While ( Dow(dRestri)==1 .Or. Dow(dRestri)==7 )
		dRestri++                             
	EndDo
	If ( dData <> dRestri )
		If lNot500Auto
			oCalend:addRestri(Day(dRestri),CLR_HRED,CLR_WHITE)
		EndIf
	EndIf
	dData := dRestri
EndDo
                   
dData := CToD( "" ) 

#IFDEF TOP 
             
	cAliasABB := "AT500CHGMES" 
	
	cQuery := ""
	
	cQuery += "SELECT ABB.*,R_E_C_N_O_ ABBRECNO FROM " + RetSqlName( "ABB" ) + " ABB "
	cQuery += "WHERE "
	cQuery += "ABB_FILIAL='" + xFilial( "ABB" ) + "' AND "
	cQuery += "ABB_CODTEC='" + AA1->AA1_CODTEC  + "' AND "
	cQuery += "( ( ABB_DTINI>='" + DToS( dDataIni ) + "' AND "
	cQuery += "ABB_DTINI<='" + DToS( dDataFim ) + "' ) OR ( "
	cQuery += "ABB_DTFIM>='" + DToS( dDataIni ) + "' AND " 
	cQuery += "ABB_DTFIM<='" + DToS( dDataFim ) + "' ) OR ( "	
	cQuery += "ABB_DTINI<'"  + DToS( dDataIni ) + "' AND " 
	cQuery += "ABB_DTFIM>'"  + DToS( dDataFim ) + "' ) ) AND "
	cQuery += "D_E_L_E_T_=' '"
	
	cQuery := ChangeQuery( cQuery )
	
	dbUseArea( .T., "TOPCONN", TcGenQry( , , cQuery ), cAliasABB, .F., .T. ) 
	
	TcSetField( cAliasABB, "ABB_DTINI", "D", 8, 0 ) 
	TcSetField( cAliasABB, "ABB_DTFIM", "D", 8, 0 ) 
	
	bWhile := { || !( cAliasABB )->( Eof() ) } 	

#ELSE 

	cAliasABB := "ABB"
	                   
	dbSelectArea("ABB")
	dbSetOrder(1)

	cQuery := ""
	cQuery += "ABB_FILIAL=='" + xFilial( "ABB" ) + "'.AND."
	cQuery += "ABB_CODTEC=='" + AA1->AA1_CODTEC  + "'.AND."
	cQuery += "((DTOS(ABB_DTINI)>='" + DToS( dDataIni ) + "'.AND."
	cQuery += "DTOS(ABB_DTINI)<='" + DToS( dDataFim ) + "').OR.("
	cQuery += "DTOS(ABB_DTFIM)>='" + DToS( dDataIni ) + "'.AND." 
	cQuery += "DTOS(ABB_DTFIM)<='" + DToS( dDataFim ) + "').OR.("	
	cQuery += "DTOS(ABB_DTINI)<'"  + DToS( dDataIni ) + "'.AND." 
	cQuery += "DTOS(ABB_DTFIM)>'"  + DToS( dDataFim ) + "'))" 
	                
	cIndTrab := CriaTrab( , .F. ) 	                
	                 
	IndRegua('ABB', cIndTrab,ABB->( IndexKey() ),,cQuery )   
	
	nIndex := RetIndex("ABB")

	ABB->( dbSetIndex(cIndTrab+OrdBagExt()) ) 

	ABB->( dbSetOrder(nIndex+1) ) 
	ABB->( dbGotop() ) 
	
	bWhile := { || !ABB->( Eof() ) } 

#ENDIF 

While Eval( bWhile ) 

	#IFDEF TOP
		nRecnoABB := ( cAliasABB )->ABBRECNO		 	 
	#ELSE
		nRecnoABB := ABB->( Recno() ) 
	#ENDIF		
							
	If ( ( dDataIni <= ( cAliasABB )->ABB_DTINI  .And.;
			 dDataFim >= ( cAliasABB )->ABB_DTINI ) .Or.;
		 	( ( cAliasABB )->ABB_DTFIM >= dDataIni .And. ; 
		 	 ( cAliasABB )->ABB_DTFIM <= dDataFim ) )    
	   		
  		//Ŀ
		// Verifica se o inicio do agendamento ocorreu neste mes                   
		//
		If Left( DToS( ( cAliasABB )->ABB_DTINI ), 6 ) == Left( DToS( dDataIni ), 6 )
			nDiaIni    := Day( ( cAliasABB )->ABB_DTINI )
			cHrCalcIni := ( cAliasABB )->ABB_HRINI       
			dCalcIni   := ( cAliasABB )->ABB_DTINI
		Else
			nDiaIni    := Day( dDataIni )             
			cHrCalcIni := "00:00"                
			dCalcIni   := dDataIni 
		EndIf          

  		//Ŀ
		// Verifica se o final do agendamento ocorreu neste mes                    
		//
		If Left( DToS( ( cAliasABB )->ABB_DTFIM ), 6 ) == Left( DToS( dDataFim ), 6 )
			nDiaFim    := Day( ( cAliasABB )->ABB_DTFIM )
			cHrCalcFim := ( cAliasABB )->ABB_HRFIM 
			dCalcFim   := ( cAliasABB )->ABB_DTFIM
		Else
			nDiaFim    := Day( dDataFim )            
			cHrCalcFim := "23:59"                 
			dCalcFim   := dDataFim
		EndIf          
		
  		//Ŀ
		// Coloca restricoes em todos os dias do intervalo  
		//
		For nLoop := nDiaIni To nDiaFim
			
			If lNot500Auto
				
				//Ŀ
				//Se for um feriado mantm a cor do texto vermelho.
				//
	 			If ( nScan := aScan( aDiasFeriado, { |x| x[1] == nLoop } ) ) > 0
	 				aDiasFeriado[nScan][2] := .T.
					oCalend:addRestri( nLoop,CLR_HRED,CLR_BLUE)
				Else
					oCalend:addRestri( nLoop,CLR_BLUE,CLR_BLUE)				
				EndIf				
			EndIf
            
	  		//Ŀ
			// Coloca no array os recnos que originaram a alocacao 
			//
			
			If nLoop == Day( ( cAliasABB )->ABB_DTINI )
				cHoraIni := ( cAliasABB )->ABB_HRINI
			Else
				cHoraIni := "....."
			EndIf				
			
			If Empty( nScan := AScan( aDiasAloc, { |x| x[1] == nLoop } ) ) 
				aAdd( aDiasAloc, { nLoop,{ { nRecnoABB, cHoraIni } } } ) 
			Else	
				If Empty( AScan( aDiasAloc[ nScan, 2 ], { |x| x[1] == nRecnoABB } ) )
					aAdd( aDiasAloc[ nScan, 2 ], { nRecnoABB, cHoraIni } ) 
				EndIf 					
			EndIf 				
				
  		Next nLoop 
		
		nDiasAloc++
		
		nHoraAloc += SubtHoras( dCalcIni, cHrCalcIni, dCalcFim, cHrCalcFim ) 
		
	EndIf 	
	
	//Ŀ
	// Se tanto o inicio quanto o final estao fora deste mes, Marca todo o mes  
	//
	If ( cAliasABB )->ABB_DTINI < dDataIni .And. ( cAliasABB )->ABB_DTFIM > dDataFim 
	
		For nLoop := Day( dDataIni ) To Day( dDataFim ) 
			If lNot500Auto
				oCalend:addRestri( nLoop,CLR_BLUE,CLR_BLUE)
			EndIf
			
			cHoraIni := "....." 
			
	  		//Ŀ
			// Coloca no array os recnos que originaram a alocacao 
			//
			If Empty( nScan := AScan( aDiasAloc, { |x| x[1] == nLoop } ) ) 
				aAdd( aDiasAloc, { nLoop, { { nRecnoABB, cHoraIni } } } ) 
			Else	
				If Empty( AScan( aDiasAloc[ nScan, 2 ], { |x| x[1] == ( cAliasABB )->( Recno() ) } ) )
					aAdd( aDiasAloc[ nScan, 2 ], { nRecnoABB, cHoraIni } ) 
				EndIf 					
			EndIf 				
			
  		Next nLoop                       
  		
		nHoraAloc += SubtHoras( dDataIni, "00:00", dDataFim, "23:59" )   		
  		
	EndIf 	
	
	( cAliasABB )->( dbSkip() ) 
	
EndDo                               

//Ŀ
//Modifica a cor dos feriados que ainda no foram modificados.
//
If lNot500Auto
	For nLoop := 1 To Len( aDiasFeriado )
		If !aDiasFeriado[nLoop][2]
			oCalend:addRestri( aDiasFeriado[nLoop][1] ,CLR_HRED,CLR_WHITE)
		EndIf
	Next nLoop
EndIf	

//Ŀ
// Exclui a area de trabalho da query              
//
#IFDEF TOP
	dbSelectArea( cAliasABB ) 
	dbCloseArea()
	dbSelectArea( "ABB" )  
#ELSE
	RetIndex( "ABB" )
	Ferase(cIndTrab+OrdBagExt())
#ENDIF 	

nDias  := Int(nHoraAloc/24)
nHoras := nHoraAloc-(nDias*24)

If lNot500Auto
	oCalend:Show()

	aGet[2][2] := nDiasAloc
	aGet[1][2] := Str(nDias,4)+"D "+IntToHora(nHoras)
	aGet[3][2] := Len( aDiasAloc ) 
                    
	aGet[3][1]:Refresh()
	aGet[2][1]:Refresh()
	aGet[1][1]:Refresh()

	//Ŀ
	// Analisa as restricoes ao calendario             
	//
	oCalend:Refresh()
EndIf

Return(.T.)

/*/


Ŀ
Funcao    At500Aloc  Autor  Eduardo Riera          Data  15.01.99 
Ĵ
Descrio  Schedule automatico dos Tecnicos.                          
Ĵ
Retorno                                                               
Ĵ
Parametros                                                            
                                                                      
Ĵ
   DATA    Programador   Manutencao Efetuada                         
Ĵ
                                                                     
ٱ


/*/

Function At500Aloc()

Local aArea := GetArea()

//Ŀ
// Parametros                                                             
//                                                                        
// MV_PAR01: Cliente de ?                                                 
// MV_PAR02: Cliente Ate?                                                 
// MV_PAR03: Os      de ?                                                 
// MV_PAR04: Os      Ate?                                                 
// MV_PAR05: Emissao de ?                                                 
// MV_PAR06: Emissao Ate?                                                 
// MV_PAR07: Regiao  de ?                                                 
// MV_PAR08: Regiao  Ate?                                                 
//

If ( Pergunte("ATA500",.T.) )
	Processa({|| At500Proc()})
EndIf

RestArea( aArea ) 

Return

/*/


Ŀ
Funcao    At500Proc  Autor  Eduardo Riera          Data 18.01.98  
Ĵ
Descrio Processamento da Alocacao semi-automatica.                  
Ĵ
Retorno   Nenhum                                                      
Ĵ
Parametros                                                            
                                                                      
Ĵ
   DATA    Programador   Manutencao Efetuada                         
Ĵ
                                                                     
ٱ


/*/

Static ;
Function At500Proc()

Local cQuery	:= ""
Local cArqInd  := CriaTrab(,.F.)
Local nIndex	:= 0
//Ŀ
// Parametros                                                             
//                                                                        
// MV_PAR01: Cliente de ?                                                 
// MV_PAR02: Cliente Ate?                                                 
// MV_PAR03: Os      de ?                                                 
// MV_PAR04: Os      Ate?                                                 
// MV_PAR05: Emissao de ?                                                 
// MV_PAR06: Emissao Ate?                                                 
// MV_PAR07: Regiao  de ?                                                 
// MV_PAR08: Regiao  Ate?                                                 
//

//Ŀ
//Monta a Query                                                           
//
cQuery := "AB6_FILIAL=='"+xFilial("AB6")+"'.And."
cQuery += "AB6_CODCLI>='"+MV_PAR01+"'.And."
cQuery += "AB6_CODCLI<='"+MV_PAR02+"'.And."
cQuery += "AB6_NUMOS>='"+MV_PAR03+"'.And."
cQuery += "AB6_NUMOS<='"+MV_PAR04+"'.And."
cQuery += "Dtos(AB6_EMISSA)>='"+Dtos(MV_PAR05)+"'.And."
cQuery += "Dtos(AB6_EMISSA)<='"+Dtos(MV_PAR06)+"'.And."
cQuery += "AB6_REGIAO>='"+MV_PAR07+"'.And."
cQuery += "AB6_REGIAO<='"+MV_PAR08+"'.And."
cQuery += "AB6_STATUS=='A'"

dbSelectArea("AB6")
ProcRegua(LastRec())
IndRegua("AB6",cArqInd,"AB6_FILIAL+AB6_REGIAO+AB6_NUMOS",,cQuery)
nIndex := RetIndex("AB6")
#IFNDEF TOP
	dbSetIndex(cArqInd+OrdBagExt())
#ENDIF
dbSelectArea("AB6")
dbSetOrder(nIndex+1)
dbGotop()
While ( !Eof() )

	AtAlocTec(AB6->AB6_NUMOS)

	dbSelectArea("AB6")
	dbSetOrder(nIndex+1)

	dbSkip()
	IncProc()
EndDo
//Ŀ
//Restaura a Tabela AB6                                                   
//
dbSelectArea("AB6")
RetIndex("AB6")
dbClearFilter()
Ferase(cArqInd+OrdBagExt())

Return(Nil)

/*


Ŀ
Funcao    At500ViOs  Autor  Sergio Silveira        Data 14/12/1999
Ĵ
Descrio  Visualizacao da ordem de servico corrente                  
Ĵ
Sintaxe    At500ViOs( ExpO1 )                                         
Ĵ
Parametros ExpO1 -> Objeto Browse                                     
Ĵ
Retorno    Nenhum                                                     
Ĵ
   DATA    Programador   Manutencao Efetuada                         
Ĵ
                                                                     
ٱ


*/

Static Function At500ViOs( oBrowse )

Local aNumOS	:= AClone( oBrowse:Cargo )
Local aArea	:= GetArea()
Local cNumOS	:= ""
Local nAt		:= oBrowse:nAt
Local lRet		:= .T.

//Ŀ
// Se o array nao estiver vazio existe agendamento 
//
If !Empty( aNumOS )
	If aNumOS[ nAt ][1] == "AAT"
		If	Len(AllTrim(aNumOS[ nAt ][2])) == Len(AAT->AAT_CODVIS)
			DbSelectArea("AAT")
			DbSetOrder(1)
			If DbSeek(XFilial("AAT")+aNumOS[ nAt ][2])
				FWExecView(STR0002,'TECA270', MODEL_OPERATION_VIEW,, { || .T. }) //"Visualizar"
			Else
				Help( ' ', 1, 'At500ViOs', , STR0039, 1, 0 )	//"Vistoria tcnica no encontrada."
				lRet	:= .F.
			EndIf
		Else
			Help( ' ', 1, 'At500ViOs', , STR0040, 1, 0 )	//"Vistoria tcnica invlida."
			lRet	:= .F.
		EndIf
	ElseIf aNumOS[ nAt ][1] $ "AB6|AB7"
		If	Len(AllTrim(aNumOS[ nAt ][2])) == Len(AB6->AB6_NUMOS)
			cNumOS  := aNumOS[ nAt ][2]
			AB6->( dbSetOrder( 1 ) )
			If AB6->( dbSeek( xFilial( "AB6" ) + cNumOS ) )
				At450Visua( "AB6", AB6->( RecNo() ), 2 )
			Else
				Help( ' ', 1, 'At500ViOs', , STR0041, 1, 0 )	//"Ordem de servio no encontrada."
				lRet	:= .F.
			EndIf
		Else
			Help( ' ', 1, 'At500ViOs', , STR0042, 1, 0 )	//"Ordem de servio invlida."
			lRet	:= .F.
		EndIf
	Else
		Help( ' ', 1, 'At500ViOs', , STR0043, 1, 0 )	//"No existe uma Ordem de servio vinculada a esta agenda."
		lRet	:= .F.
	EndIf
EndIf

RestArea(aArea)
Return (lRet)

/*


Ŀ
Funcao    At500Goto  Autor  Sergio Silveira        Data 07/11/2001
Ĵ
Descrio  Localiza o inicio / final da alocacao                      
Ĵ
Sintaxe    At500Goto( ExpO1, ExpA1, ExpN1 )                           
Ĵ
Parametros ExpO1 -> Objeto Calendario                                 
           ExpA1 -> Array contendo as alocacoes                       
           ExpN1 -> Tipo - 1 - Inicio                                 
                           2 - Final                                  
Ĵ
Retorno    Nenhum                                                     
Ĵ
   DATA    Programador   Manutencao Efetuada                         
Ĵ
                                                                     
ٱ


*/

Function At500Goto(oCalend,aDiasAloc,nTipo)

LOCAL aDia := {}
LOCAL nDia := Day( oCalend:dDiaAtu )

If !Empty( nScan := AScan( aDiasAloc, { |x| x[1] == nDia } ) )   

	aDia := aDiasAloc[ nScan, 2 ]

	//Ŀ
	// Ordena as alocacoes do dia por horario de chegada                      
	//
	ASort( aDia, , , { |x,y| y[2] > x[2] } ) 
	
	ABB->( dbGoto( If( nTipo == 1, aDia[ 1, 1 ], aDia[ Len( aDia ), 1 ] ) ) )  
	
	oCalend:dDiaAtu := If( nTipo == 1, ABB->ABB_DTINI, ABB->ABB_DTFIM ) 

	Eval( oCalend:bChange ) 	
	
EndIf 	

Return( .t. ) 

/*/

Ŀ
Funo    At500Gnt   Autor  Henry Fila             Data 11.08.2003 
Ĵ
          Exibe grafico de gantt das alocacoes dos tecnicos            
                                                                       
Ĵ
ParametrosExpA1 : Array com os parametros de filtro                    
Ĵ
Retorno   ExpL1 - .T.                                                  
Ĵ
Descrio Esta rotina tem como gerar o grafico de gantt das alocacoes  
          dos tecnicos de acordo com o parametro                       
Ĵ
Uso        FieldService                                                
ٱ


/*/

Function At500Gnt(aParam)

Local aTecnicos := {}
Local aGant     := {}
Local aGantIt   := {}
Local aCores    := {CLR_HBLUE, CLR_HRED,CLR_BROWN, CLR_BLACK, CLR_GREEN, CLR_GRAY}
Local aConfig   := {}
Local aAuxCfg   := {}

Local nTop      := oMainWnd:nTop+50
Local nLeft     := oMainWnd:nLeft+10
Local nBottom   := oMainWnd:nBottom-70
Local nRight    := oMainWnd:nRight-36	
Local nCor      := 0

Local oFont
Local oDlgCar
Local oBmp
Local oBtn
Local oBtnSair
Local oBtn1
Local oBtn2                  
Local cDesc:= ""
Local lRet := .T.
Local nTsk
Local dIni := dDataBase
Local nY   := 0
Local nX   := 0
Local oPnGantt

Private oMnuGantt
Private cCodTec		:= ""
Private cNumGantt 	:= "" 
Private cNVTGantt	:= ""

DEFINE FONT oBold NAME "Arial" SIZE 0, -13 BOLD

// Define o PopUp que deve ser acionado ao clicar simples no item alocado
MENU oMnuGantt POPUP                                                  
	MENUITEM STR0036 Action AT500View( cNumGantt,cNVTGantt )			//"Visualizar"
	MENUITEM STR0037 Action AT500Sch( 4, cCodTec )			//"Alterar Agendamento"
ENDMENU


aConfig := {6,.T.,.T.,.T.,.T.,.T.,.T.,.T.}

aTecnicos  :=AtSchedTec(aParam)

aGant := {}
For nX := 1 to Len(aTecnicos)

	nCor := If(nX > 6,1,nX)

	aAdd(aGant,{{aTecnicos[nX][1]+"-"+aTecnicos[nX][2],""},,CLR_GRAY,oBold})
	
	aGantIt := {}
	For nY := 1 to Len(aTecnicos[nX][3])
		If Len(aTecnicos[nx][3][nY])>=6
			aAdd(aGantIt,{aTecnicos[nX][3][nY][2],aTecnicos[nX][3][nY][3],aTecnicos[nX][3][nY][4],aTecnicos[nX][3][nY][5],,aCores[nCor],"cNVTGantt := '"+aTecnicos[nx][3][nY][6]+"', cNumGantt := '" + aTecnicos[nX][3][nY][1] + "', cCodTec := '" + aTecnicos[nX][1] + "', oMnuGantt:Activate(x,y,oBar)",1,})
		Else
			aAdd(aGantIt,{aTecnicos[nX][3][nY][2],aTecnicos[nX][3][nY][3],aTecnicos[nX][3][nY][4],aTecnicos[nX][3][nY][5],,aCores[nCor],"cNumGantt := '" + aTecnicos[nX][3][nY][1] + "', cCodTec := '" + aTecnicos[nX][1] + "', oMnuGantt:Activate(x,y,oBar)",1,})
		EndIf
	Next nY
	
	aGant[nX][2] := aClone(aGantIt)
	
Next nX

While lRet

	DEFINE FONT oFont NAME "Arial" SIZE 0, -10
	DEFINE MSDIALOG oDlgCar TITLE STR0004 OF oMainWnd PIXEL FROM nTop,nLeft TO nBottom,nRight STYLE nOR(WS_VISIBLE,WS_POPUP) //"Agenda dos tecnicos"
		@ 00,00 BITMAP oBmp RESNAME "FAIXASUPERIOR" SIZE 1200,50 NOBORDER PIXEL

		oBmp:Align:= CONTROL_ALIGN_TOP                
		
		@ 39,01 BUTTON 	STR0038 SIZE 35,12 ACTION ( lRet := .F., oDlgCar:End(), AT500Inc() ) OF oDlgCar PIXEL //"Incluir"
		@ 39,38 BUTTON 	STR0019 SIZE 35,12 ACTION If(At500Cfg("Teste",@oDlgCar,aConfig,@dIni,aGant),(oDlgCar:End(),lRet := .T.),Nil) OF oDlgCar PIXEL //"Opcoes"
		@ 39,75 BUTTON 	STR0020 SIZE 35,12 ACTION (lRet := .F.,oDlgCar:End()) OF oDlgCar PIXEL  //"Sair"				


		@ 38,(nRight/2)-58 MSGET dIni VALID If(!Empty(dIni),(oDlgCar:End(),lRet := .T.),Nil )  SIZE 40,9 OF oDlgCar PIXEL CENTERED
		@ 78,nRight - 140 BTNBMP oBtn1 RESOURCE "PREV" SIZE 20,20 ACTION (PmsPrvGnt(cVersao,@oDlgCar,aConfig,@dIni,aGant,@nTsk),oDlgCar:End(),lRet := .T.) MESSAGE "Retroceder Calendario..."
		@ 78,nRight - 37 BTNBMP oBtn2 RESOURCE "NEXT" SIZE 20,20 ACTION (PmsNxtGnt(cVersao,@oDlgCar,aConfig,@dIni,aGant,@nTsk),oDlgCar:End(),lRet := .T.) MESSAGE "Avancar Calendario..."
 	
		aAuxCfg := {aConfig[1],aConfig[3],aConfig[4],aConfig[5],aConfig[6],aConfig[7]}		
		// @ 39,100 BUTTON "Imprimir" SIZE 35,12 ACTION (PmsImpGantt( STR0004,aGant ,aAuxCfg ,dIni , ,{{STR0029,30}} ,)) OF oDlgCar PIXEL  //"Sair"

		oPnGantt  := PmsGantt(aGant,aAuxCfg,@dIni,,oDlgCar,{50,1,((nBottom-nTop))-45,((nRight-nLeft)/2)-10},{{STR0029,30}},@nTsk,,STR0028) 
		aConfig[1] := aAuxCfg[1]
		
	ACTIVATE MSDIALOG oDlgCar

EndDo  

Return lRet

/*/

Ŀ
Funo    At500Cfg   Autor  Henry Fila             Data 11.08.2003 
Ĵ
          Exibe configurador do gantt                                  
                                                                       
Ĵ
ParametrosExpC1 : Versao do Gantt                                      
          ExpO2 : Objeto da janela                                     
          ExpA3 : Array com os parametros da configuracao              
          ExpD4 : Data inicial                                         
          ExpA5 : Array com os dados do gantt                          
Ĵ
Retorno   ExpL1 - .T.                                                  
Ĵ
Descrio Esta rotina tem como gerar o grafico de gantt das alocacoes  
          dos tecnicos de acordo com o parametro                       
Ĵ
Uso        FieldService                                                
ٱ


/*/
Function At500Cfg(cVersao,oDlg,aConfig,dIni,aGantt)
Local lRet		:= .F.  
Local aConfigBk := aClone(aConfig)

lRet := ParamBox({	{3,STR0021,aConfig[1],{STR0021,STR0022,STR0023,STR0024,STR0025,STR0026},60,,.F.}},; //###"Diario"###"Semanal"###"Mensal"###"Mensal (Zoom 30%)"###"Bimestral"
				STR0027,aConfig,,,.F.,120,3) //"Configuracoes do Gantt" //"Mostrar Recursos"

aConfigBk[1] := aConfig[1]
aConfig := aClone(aConfigBk)


Return lRet

/*/

Ŀ
Funo    At500Param Autor  Henry Fila             Data 12.04.2002 
Ĵ
          Parametros do Gantt                                          
                                                                       
Ĵ
ParametrosNenhum                                                       
Ĵ
Retorno   ExpL1 - .T.                                                  
Ĵ
Descrio Esta rotina tem como objetivo ober os parametros do gantt    
Ĵ
Uso        Field Service                                               
ٱ


/*/

Function At500Param( lSit )

If Pergunte("TEC500",.T.)   
	aParam:= {}
	aAdd(aParam, {"TECN_FROM", MV_PAR01 })
	aAdd(aParam, {"TECN_TO"  , MV_PAR02 })
	aAdd(aParam, {"DATA_FROM", MV_PAR03 })
	aAdd(aParam, {"DATA_TO"  , MV_PAR04 })
	aAdd(aParam, {"CLIE_DE"  , MV_PAR05 })
	aAdd(aParam, {"CLIE_ATE" , MV_PAR06 })
	aAdd(aParam, {"CONTR_DE" , MV_PAR07 })
	aAdd(aParam, {"CONTR_ATE", MV_PAR08 })
	aAdd(aParam, {"NUM_DE"   , MV_PAR09 })
	aAdd(aParam, {"NUM_ATE"  , MV_PAR10 })
	
	If Type(MV_PAR11) <> "U"
		aAdd(aParam, {"VT_DE"	 , MV_PAR11 }) 
		aAdd(aParam, {"VT_ATE"	 , MV_PAR12 })
		aAdd(aParam, {"TP_ENT"   , MV_PAR13 })
	EndIf	
	
	At500Gnt(aParam)

Endif



 /*


Ŀ
Funcao    At500View  Autor  Sergio Silveira        Data 07/05/2004
Ĵ
Descrio  Visualizacao da ordem de servico                           
Ĵ
Sintaxe    At500View( ExpC1,ExpC2 )                                   
Ĵ
Parametros ExpC1 -> Numero da OS / ExpC2 -> Numero da Vistoria Tecnica
Ĵ
Retorno    .T.                                                        
Ĵ
   DATA    Programador   Manutencao Efetuada                         
Ĵ
                                                                     
ٱ


*/

Function At500View( cNumOs,cNumVt )

Default cNumVt := ""
    
AB6->( dbSetOrder( 1 ) ) 
If AB6->( DbSeek( xFilial( "AB6" ) + cNumOs ) ) 
	MaMakeView( "AB6" )
EndIf

DbSelectArea("AAT")
AAT->(DbSetOrder(1))
If AAT->(DbSeek(XFilial("AAT")+cNumVt))
	FWExecView(STR0002,'TECA270', MODEL_OPERATION_VIEW,, { || .T. }) //"Visualizar"
EndIf   

Return( .T. ) 
/*/


Ŀ
Funo    At500MontCols Autor  Conrado Quilles     Data 03/01/2006 
Ĵ
          Rotina de montagem do aCols atravs da funo FillGetDados   
                                                                       
Ĵ
ParametrosdDataini: Data inicial                                       
          aDiasAloc: Dias alocados                                     
          aTravas: Array com as travas ocorridas                       
Ĵ
Retorno    .T. ou .F.: Se todas as travas foram conseguidas            
                                                                       
Ĵ
Uso        Materiais                                                   
ٱ


/*/
Static Function At500MontCols(dDataIni, aDiasAloc, aTravas)
Local nDia		:= 0			// Dia processado
Local nScan		:= 0			// Utilizado na procura do campo
Local nLoop		:= 0			// Varivel utilizada em loop  
Local nCntFor	:= 0			// Varivel utilizada em loop
Local nUsado	:= Len(aHeader)	// Tamanho do aHeader
Local lTravas	:= .T.			// Se todos os campos foram travados com sucesso

//Ŀ
//Montagem do aCols                                                       
//

nDia := Day( dDataIni )

If !Empty( nScan := AScan( aDiasAloc, { |x| x[1] == nDia } ) )   

	aDia := aDiasAloc[ nScan, 2 ]

	//Ŀ
	// Ordena as alocacoes do dia por horario de chegada                      
	//
	ASort( aDia, , , { |x,y| y[2] > x[2] } ) 
	
	For nLoop := 1 to Len( aDia ) 
	
		ABB->( MsGoto( aDia[ nLoop, 1 ] ) )  
		
		If AtTravaReg( "ABB" , aTravas)
			Aadd(aRegistros, ABB->(RecNo()) )
			Aadd(aCols,Array(nUsado+1))
			For nCntFor := 1 To nUsado
				If aHeader[nCntFor,2] == "ABB_ALI_WT"
					aCols[Len(aCols)][nCntFor] := "ABB"
				ElseIf aHeader[nCntFor,2] == "ABB_REC_WT"
					aCols[Len(aCols)][nCntFor] := ABB->( Recno() )
				ElseIf ( aHeader[nCntFor][10] <> "V" )
					aCols[Len(aCols)][nCntFor] := ABB->(FieldGet(FieldPos(aHeader[nCntFor][2])))
				Else
					aCols[Len(aCols)][nCntFor] := CriaVar(aHeader[nCntFor,2])
				EndIf
			Next
			aCols[Len(aCols)][nUsado+1] := .F.
		Else
			lTravas := .F.
		EndIf
	Next nLoop
	   
EndIf 

Return( lTravas )


/*/


Ŀ
Funo     AT500Sch     Autor  Totvs               Data 19/04/2011 
Ĵ
Descricao  Visualiza a agenda do tecnico a partir do gantt             
Ĵ
ParametrosnOpc   : operacao a ser executada (inclusao/alteracao/etc)   
          cCodTec: codigo do tecnico                                   
ٱ


/*/
Static Function AT500Sch( nOpc, cCodTec )
Local aArea		:= GetArea()
Local aAreaAA1	:= AA1->( GetArea() )

Default cCodTec := ""

DbSelectArea( "AA1" )
AA1->( DbSetOrder( 1 ) )
AA1->( DbSeek( xFilial( "AA1" ) + cCodTec ) )
AT500AGE( "AA1", AA1->( RecNo() ), nOpc )

RestArea( aAreaAA1 )
RestArea( aArea )
Return 

/*/


Ŀ
Funo     AT500Inc     Autor  Totvs               Data 19/04/2011 
Ĵ
Descricao  Permite inclusao de agenda de um tecnico a partir do gantt  
ٱ


/*/
Static Function AT500Inc()
Local aArea		:= GetArea()
Local aAreaAA1	:= AA1->( GetArea() )

Private aParamInc	:= {}

DbSelectArea( "AA1" )
AA1->( DbSetOrder( 1 ) )
If ParamBox( { { 1, "Tcnico", Space( TamSX3( "AA1_CODTEC" )[1] ),"","DbSeek(xFilial('AA1')+AllTrim(MV_PAR01))","AA1","", 85 ,.F.}}, "Tcnico", @aParamInc )
	AA1->( DbSeek( xFilial( "AA1" ) + aParamInc[1] ) )
	AT500AGE( "AA1", AA1->( RecNo() ), 3 )
EndIf

// Recria o gantt com as alteracoes
At500Gnt( aParam )

RestArea( aAreaAA1 )
RestArea( aArea )
Return
