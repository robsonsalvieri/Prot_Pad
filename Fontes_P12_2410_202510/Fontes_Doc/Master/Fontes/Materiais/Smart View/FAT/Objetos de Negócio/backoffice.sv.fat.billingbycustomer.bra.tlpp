#include "protheus.ch"
#include "fwlibversion.ch"
#include "totvs.ch"
#include "msobject.ch"
#include "totvs.framework.treports.integratedprovider.th"
#include "tlpp-rest.th"
#include "tlpp-core.th"

namespace totvs.protheus.backoffice.sv.fat.billingbycustomer.treportsintegratedprovider
using namespace totvs.framework.treports.integratedprovider

@totvsFrameworkTReportsIntegratedProvider(active=.F., team="SIGAFAT", tables="SF2", name="Faturamento por Cliente", country="BRA")

//-------------------------------------------------------------------
/*/{Protheus.doc} billingbycustomerSmartViewBusinessObjectBRA
Classe para criação do Objeto de Negócio para Notas Fiscais localização Brasil.

@author FAT/CRM
@since 14/06/2023
@version 1.0
*/
//-------------------------------------------------------------------  
Class billingbycustomerSmartViewBusinessObjectBRA From totvs.protheus.backoffice.sv.fat.billingbycustomer.treportsintegratedprovider.billingbycustomerSmartViewBusinessObject

    public method new()         as object
    public method preData()     as object
    public method processData() as object
    public method preSchema()   as object

    protected data aFields as array
    protected data aStruct as array

EndClass
 
//-------------------------------------------------------------------
/*{Protheus.doc} new
Método de instância da classe
 
@return object: self
 
@author FAT/CRM
@since 14/06/2023
@version 1.0
*/
//-------------------------------------------------------------------
Method new() Class billingbycustomerSmartViewBusinessObjectBRA 

    _Super:new()

Return self

//-------------------------------------------------------------------
/*{Protheus.doc} preData
Método chamado antes do getData do objeto principal
 
@return object: self:oData
 
@author FAT/CRM
@since 14/06/2023
@version 1.0
*/
//-------------------------------------------------------------------   
Method preData() As object Class billingbycustomerSmartViewBusinessObjectBRA 

    //Aqui é adicionada uma condição no where que será utilizado na query do objeto padrão

Return self:oData

//-------------------------------------------------------------------
/*{Protheus.doc} processData
Deverá ser chamado no momento do processamento da query
 
@return object: self:oData
 
@author FAT/CRM
@since 14/06/2023
@version 1.0
*/
//-------------------------------------------------------------------    
Method processData(nOperLoc as numeric) As object Class billingbycustomerSmartViewBusinessObjectBRA

    Local cAliasQry := Self:cAlias as character
    Local nValSImp  := 0 as numeric
    Local dDtMoeDev := CTOD("//") as date

    Do Case 
        //---------------------------------------------------
        //Operação 1:
        //Utilizado somente para commit dos 
        //campos antes do appendData - Case (nOperLoc == 1)
        //---------------------------------------------------
                
        //---------------------------------------------------
        //Operação 2:
        //Validar se esse registro da SF2 pode ser considerada
        //na listagem, retorno lógico na propriedade self:lValidSF2Loc
        //---------------------------------------------------
        Case (nOperLoc == 2)

            If ((cAliasQry)->F2_TIPO == "I" .And. (cAliasQry)->F2_ICMSRET == 0)
                self:lValidSF2Loc := .F.
            Endif

        //-----------------------------------------------------
        //Operação 3:
        //Realiza tratamento do valor total adicional(self:nVlSF2AdiLoc),
        //no objeto localizado caso tenha.
        //Seta propriedade do objeto informardo se a nota tem
        //complemento de IPI ou não.(self:lComplIpiSF2Loc)
        //-----------------------------------------------------
        Case (nOperLoc == 3)

            self:lComplIpiSF2Loc := (cAliasQry)->F2_TIPO == "P"

        //------------------------------------------------
        //Operação 4:
        //Realiza tratamento dos valores dos itens com
        //cáculos localizados.
        //------------------------------------------------
        Case (nOperLoc == 4) 

            If SF4->F4_AGREG <> "N"
                self:nVlSD2TotLoc       := xMoeda(SD2->D2_TOTAL,1,nMoeda,(cAliasQry)->F2_EMISSAO,nDecs+1)
                self:nVlSD2AdiLoc       := xMoeda(SD2->D2_SEGURO+SD2->D2_VALFRE+SD2->D2_DESPESA,(cAliasQry)->F2_MOEDA,nMoeda,(cAliasQry)->F2_EMISSAO)
            Else
                self:nVlSD2TotLoc       := xMoeda(SD2->D2_SEGURO+SD2->D2_VALFRE+SD2->D2_DESPESA,1,nMoeda,(cAliasQry)->F2_EMISSAO,nDecs+1)
                self:nVlSD2TotDespLoc   := xMoeda(SD2->D2_SEGURO+SD2->D2_VALFRE+SD2->D2_DESPESA,1,nMoeda,(cAliasQry)->F2_EMISSAO,nDecs+1)
                self:nVlSD2AdiLoc       := xMoeda(SD2->D2_SEGURO+SD2->D2_VALFRE+SD2->D2_DESPESA,(cAliasQry)->F2_MOEDA,nMoeda,(cAliasQry)->F2_EMISSAO)
            EndIf

            If nDeduzImp == 1  .And. SF4->F4_AGREG <> "N"
                nValSImp                := TotSImp("SF2","SD2",SD2->D2_TES)
                self:nVlSD2TotLiqLoc    := xMoeda(nValSImp,1,nMoeda,(cAliasQry)->F2_EMISSAO,nDecs+1)
            EndIf

            If self:lComplIpiSF2Loc
                self:nVlSD2ComplIpiLoc  := SD2->D2_TOTAL
            Else
                self:nVlSD2IcmLoc := xMoeda(SD2->D2_VALICM,1,nMoeda,(cAliasQry)->F2_EMISSAO)
                self:nVlSD2IpiLoc := xMoeda(SD2->D2_VALIPI,1,nMoeda,(cAliasQry)->F2_EMISSAO)
            EndIf

        //------------------------------------------------
        //Operação 5:
        //Validar se esse registro da SF1 pode ser considerada
        //na listagem, retorno lógico na propriedade self:lValidSF1Loc
        //Não utilizado para localização Brasil
        //------------------------------------------------

        //------------------------------------------------
        //Operação 6:
        //Localização com valores de ICMS e IPI 
        //------------------------------------------------
        Case (nOperLoc == 6)

            dDtMoeDev := IIF(nMoeDev == 1,SF1->F1_DTDIGIT,StoD((cAliasQry)->F2_EMISSAO))

            self:nVlSD1IcmLoc := xMoeda(SD1->D1_VALICM,1,nMoeda,dDtMoeDev)
            self:nVlSD1IpiLoc := xMoeda(SD1->D1_VALIPI,1,nMoeda,dDtMoeDev)

        //--------------------------------------------------
        //Operação 7:
        //Validar se esse registro da SF1 desconta valor de devloção
        //no calculo ou não, retorno lógico na propriedade self:lIncDevSF1Loc
        //Não utilizado para localização Brasil
        //--------------------------------------------------

        //------------------------------------------------
        //Operação 8:
        //Validar se esse registro da SF1 pode ser considerada
        //na listagem, retorno lógico na propriedade self:lValidSF1Loc
        //Não utilizado para localização Brasil
        //------------------------------------------------

        //------------------------------------------------
        //Operação 9:
        //Localização com valores de Total Liquido, ICMS e IPI 
        //------------------------------------------------
        Case (nOperLoc == 9)

            //Verifica se existe a N.F original de Saida , se existir usa a data de emissao da NF de saida
            //conforme o parametro MV_PAR13 se não encontrar usa o campo F1_DTDIGIT para converter a moeda da devolucao
            dDtMoeDev := IIf( nMoeDev == 2, IIf(SF2->(MsSeek(cFilSF2+SD1->D1_NFORI+SD1->D1_SERIORI+SD1->D1_FORNECE+SD1->D1_LOJA)), SF2->F2_EMISSAO, SF1->F1_DTDIGIT), SF1->F1_DTDIGIT )

            If nDeduzImp == 1
                nValSImp                := TotSImp("SF1","SD1",SD1->D1_TES)
                self:nVlSD1TotLiqLoc    := xMoeda(nValSImp,SF1->F1_MOEDA,nMoeda,dDtMoeDev,nDecs+1,SF1->F1_TXMOEDA)
            EndIf
            self:nVlSD1IcmLoc           := xMoeda(SD1->D1_VALICM,1,nMoeda,dDtMoeDev)
            self:nVlSD1IpiLoc           := xMoeda(SD1->D1_VALIPI,1,nMoeda,dDtMoeDev)

    EndCase

Return

//-------------------------------------------------------------------
/*{Protheus.doc} preSchema
Método chamada antes do getSchema do objeto principal
 
@return object: self:oSchema
 
@author FAT/CRM
@since 14/06/2023
@version 1.0
*/
//-------------------------------------------------------------------
Method preSchema() As object Class billingbycustomerSmartViewBusinessObjectBRA

    //Adição de novos campos personalizados (não existem na tabela)

Return self:oSchema

//-------------------------------------------------------------------
/*{Protheus.doc} TotSImp
Calcula valor total do item sem impostos.

@return nIT_TOTAL

@author FAT/CRM
@since 26/04/2023
@version 1.0
*/
//-------------------------------------------------------------------
Static Function TotSImp(cAlias1,cAlias2,cTes)

    //Variaveis Array
	Local aRef1 		:= {} as array
	Local aRef2 		:= {} as array
    Local aArea         := GetArea() as array

    //Variaveis Caracter
	Local cIT_TIPONF    := "" as character
	Local cNF_RECISS    := "" as character
	Local cNF_OPERNF    := "" as character

    //Variaveis Numericas
	Local nValImp       := 0 as numeric
	Local nAgrPisPas    := 0 as numeric
	Local nFretAut      := 0 as numeric
	Local nPisCofST     := 0 as numeric
	Local nIT_VALPS2    := 0 as numeric
	Local nIT_VALCF2    := 0 as numeric
	Local nIT_VALICA    := 0 as numeric
	Local nIT_VALPS3    := 0 as numeric
	Local nIT_VALCF3    := 0 as numeric
	Local nIT_TOTAL     := 0 as numeric
	Local nIT_VALIPI    := 0 as numeric
	Local nIT_VALSOL    := 0 as numeric
	Local nIT_VALEMB    := 0 as numeric
	Local nIT_VNAGREG   := 0 as numeric
	Local nIT_VALMERC   := 0 as numeric
	Local nIT_DESCONTO  := 0 as numeric
	Local nIT_VALICM    := 0 as numeric
	Local nIT_DEDICM    := 0 as numeric
	Local nIT_BASEDUP   := 0 as numeric
	Local nIT_ICMSDIF   := 0 as numeric
	Local nIT_VALISS    := 0 as numeric
	Local nIT_VALIMP    := 0 as numeric

    //Salva Area e preenche array com referencias fiscais
	aRef1 := MaFisSXRef(cAlias1)
	aRef2 := MaFisSXRef(cAlias2)

    //Carrega referencias do cabecalho
	dbSelectArea(cAlias1)
	If cAlias1 == "SF2"
		cNF_RECISS := &(aRef1[(aScan(aRef1,{|x| x[2] == "NF_RECISS"}))][1])
		cNF_OPERNF := "S"
	Else
		cNF_OPERNF := "N"
		If !Empty(SA1->A1_RECISS)
			cNF_RECISS := SA1->A1_RECISS
		Else
			cNF_RECISS := "2"
		EndIf
	EndIF

    //Carrega referencias dos itens
	dbSelectArea(cAlias2)
	nIT_VALPS2 := &(aRef2[(aScan(aRef2,{|x| x[2] == "IT_VALPS2"}))][1])
	nIT_VALCF2 := &(aRef2[(aScan(aRef2,{|x| x[2] == "IT_VALCF2"}))][1])
	nIT_VALICA := 0
	nIT_VALPS3 := &(aRef2[(aScan(aRef2,{|x| x[2] == "IT_VALPS3"}))][1])
	nIT_VALCF3 := &(aRef2[(aScan(aRef2,{|x| x[2] == "IT_VALCF3"}))][1])
	cIT_TIPONF := SD2->D2_TIPO

	If cAlias2 == "SD2"
		nIT_TOTAL    := &(aRef2[(aScan(aRef2,{|x| x[2] == "IT_TOTAL"}))][1])
		nIT_DEDICM   := &(aRef2[(aScan(aRef2,{|x| x[2] == "IT_DEDICM"}))][1])
		nIT_DESCONTO := 0
	Else
		nIT_TOTAL    := &(aRef2[(aScan(aRef2,{|x| x[2] == "IT_VALMERC"}))][1])
		nIT_DEDICM   := 0
		nIT_DESCONTO := &(aRef2[(aScan(aRef2,{|x| x[2] == "IT_DESCONTO"}))][1])
	EndIf

	nIT_VALIPI  := &(aRef2[(aScan(aRef2,{|x| x[2] == "IT_VALIPI"}))][1])
	nIT_VALSOL  := &(aRef2[(aScan(aRef2,{|x| x[2] == "IT_VALSOL"}))][1])
	nIT_VALEMB  := 0
	nIT_VNAGREG := 0
	nIT_VALMERC := &(aRef2[(aScan(aRef2,{|x| x[2] == "IT_VALMERC"}))][1])
	nIT_VALICM  := &(aRef2[(aScan(aRef2,{|x| x[2] == "IT_VALICM"}))][1])
	nIT_BASEDUP := 0
	nIT_ICMSDIF := 0
	nIT_VALISS  := &(aRef2[(aScan(aRef2,{|x| x[2] == "IT_VALISS"}))][1])
	nIT_VALIMP  := 0

	nAgrPisPas :=	If( SF4->F4_AGRPIS=="1" .AND. SF4->F4_PSCFST <> "1",nIT_VALPS2,0) + If( SF4->F4_AGRCOF=="1" .AND. SF4->F4_PSCFST <> "1",nIT_VALCF2,0)
	nFretAut   := nIT_VALICA

	If !SuperGetMV("MV_FRETAUT")
		nFretAut := 0
	EndIf

    //Calcula valor sem impostos
    //Pis/Cofins Substituicao Tributaria - sera somado ao total do documento
	nPisCofST := IIf( SF4->F4_PSCFST == "1" .And. SF4->F4_APSCFST == "1", nIT_VALPS3 + nIT_VALCF3, 0 )

	Do Case
	Case cIT_TIPONF == "P"
		nIT_TOTAL := nIT_VALIPI+IIf(SF4->F4_INCSOL$"A,N,D",0,nIT_VALSOL) + nIT_VALEMB + nFretAut + nAgrPisPas + nPisCofST
	OtherWise
        nIT_TOTAL := IIf(SF4->F4_AGREG == "N", IIf(SF4->F4_IPI == 'R',0,nIT_VALIPI) + IIf(SF4->F4_INCSOL$"A,N,D",0,nIT_VALSOL)+nIT_VALEMB+nAgrPisPas+nPisCofST,;
                        IIf(SF4->F4_AGREG == "I" .OR. SF4->F4_AGREG == "B", nIT_VALMERC - IIf(SF4->F4_IPI == 'R',0,nIT_VALIPI) - IIf(SF4->F4_INCSOL$"A,N,D".AND.SF4->F4_ICM<>"N",0,nIT_VALSOL) - nIT_DESCONTO - IIf(cIT_TIPONF <>"I",nIT_VALICM,0) - nIT_VALEMB-nFretAut-nAgrPisPas-nPisCofST,;
                            nIT_VALMERC - IIf(SF4->F4_INCSOL$"A,N,D",0,nIT_VALSOL) - nIT_DESCONTO - nIT_VALEMB+nFretAut - nAgrPisPas - nPisCofST - IIf(SF4->F4_AGREG$"DR",nIT_DEDICM,0)))

        nIT_VNAGREG := IIf(SF4->F4_AGREG == "N", nIT_VALMERC - nIT_DESCONTO, 0)
	EndCase

    // ICMS Diferido Incentivo abate de gado - o valor diferido sera somado ao total da NF e a duplicata
    nIT_TOTAL += IIf( SF4->F4_PICMDIF <> 0 .AND. SF4->F4_ICMSDIF == "4", nIT_ICMSDIF, 0 )

    nIT_BASEDUP := 0
    If SF4->F4_DUPLIC <> "N"
        nIT_BASEDUP := IIf( SuperGetMV("MV_DPAGREG") .AND. SF4->F4_AGREG == "N", nIT_TOTAL + nIT_VALMERC,;
                        IIf( SF4->F4_AGREG == "F", nIT_TOTAL - nIT_VALMERC,;
                            IIf( cIT_TIPONF == "I", nIT_TOTAL - nIT_VALICM,;
                                IIf( SF4->F4_PICMDIF <> 0 .AND. SF4->F4_ICMSDIF $ " ,1,2", nIT_TOTAL - nIT_ICMSDIF,;
                                    IIf( cNF_RECISS == "1".AND. SuperGetMV("MV_DESCISS") .AND. cNF_OPERNF == "S".AND. SuperGetMV("MV_TPABISS")== "1", nIT_TOTAL - nIT_VALISS,;
                                        IIf( SF4->F4_INCSOL == "D", nIT_TOTAL - nIT_VALSOL,;
                                            IIf( SF4->F4_AGREG == "E", nIT_TOTAL - nIT_DEDICM, nIT_TOTAL ) ) ) ) ) ) )
    EndIf

    //Verifica se a TES possui tratamento para Impostos Variaveis
    If SFC->(MsSeek(FWxFilial("SFC")+SF4->F4_CODIGO))
        While !SFC->(Eof()) .And. SFC->FC_TES == SF4->F4_CODIGO
            If SF4->F4_DUPLIC <> "N" .AND. cIT_TIPONF <> 'B'
                nValImp := IIf( SFC->FC_INCDUPL == "1", nIT_VALIMP,;
                            IIf( SFC->FC_INCDUPL == "2", - nIT_VALIMP,;
                                IIf( SFC->FC_INCDUPL == "3", 0, nValImp ) ) )
                nIT_BASEDUP += nValImp
            EndIf

            nValImp := IIf( SFC->FC_INCNOTA == "1", nIT_VALIMP,;
                        IIf( SFC->FC_INCNOTA == "2", - nIT_VALIMP,;
                            IIf( SFC->FC_INCNOTA == "3", 0, nValImp ) ) )
            nIT_TOTAL -= nValImp
            SFC->(dbSkip())
        Enddo
    EndIf

    RestArea(aArea)

    aRef1 := {}
    aRef2 := {}
    aArea := {}

    ASIZE(aRef1,0)
    ASIZE(aRef2,0)
    ASIZE(aArea,0)

Return(nIT_TOTAL)
