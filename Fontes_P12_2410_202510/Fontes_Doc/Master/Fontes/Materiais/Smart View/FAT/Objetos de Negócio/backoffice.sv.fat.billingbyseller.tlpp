#include "protheus.ch"
#include "fwlibversion.ch"
#include "totvs.ch"
#include "msobject.ch"
#include "totvs.framework.treports.integratedprovider.th"
#include "tlpp-rest.th"
#include "tlpp-core.th"
#include "backoffice.sv.fat.billingbyseller.ch"

Static __lLookUp := FwLibVersion() >= "20231121"

namespace totvs.protheus.backoffice.sv.fat.billingbyseller.treportsintegratedprovider
using namespace totvs.framework.treports.integratedprovider

@totvsFrameworkTReportsIntegratedProvider(active=.T., team="SIGAFAT", tables="SF2,SD2,SF1,SD1,SF4,SA3", name="Faturamento por Vendedor", country="ALL", customTables="SA3")

//-------------------------------------------------------------------
/*/{Protheus.doc} billingbysellerSmartViewBusinessObject
Classe para criação do Objeto de Negócio para listagem de Faturamento por Vendedor

@author FAT/CRM
@since 18/05/2023
@version 1.0
*/
//-------------------------------------------------------------------  
Class billingbysellerSmartViewBusinessObject From IntegratedProvider

    public method new() 		as object
    public method getData() 	as object
    public method getSchema() 	as object

	public method FatSv016CreateSQL()

    protected data aFields 			 as array
	protected data aVdCposF2		 as array
	protected data aStruct 			 as array
	protected data aFieldsValue		 as array
	protected data jItems  			 as json
	protected data cAliasSD1		 as character
	protected data cAliasSD2		 as character
    protected data cSelectSD2Loc 	 as character
    protected data cSelectSD1Loc 	 as character
    protected data cWhereSD2Loc 	 as character
    protected data cWhereSD1Loc 	 as character
    protected data nVlSD2IcmLoc 	 as numeric
    protected data nVlSD2IpiLoc 	 as numeric
    protected data nVlSD2StLoc 		 as numeric
    protected data nVlSD2ImpIncLoc 	 as numeric
    protected data nVlSD2ImpNoIncLoc as numeric
	protected data nQtdVends 	 	 as numeric
    protected data nVlSD1TotLoc 	 as numeric
    protected data nVlSD1IcmLoc 	 as numeric
    protected data nVlSD1IpiLoc 	 as numeric
    protected data nVlSF1AdicLoc 	 as numeric
    protected data nVlSD1ImpIncLoc 	 as numeric
    protected data nVlSD1ImpNoIncLoc as numeric
	protected data nDecs 			 as numeric

EndClass
 
//-------------------------------------------------------------------
/*{Protheus.doc} new
Método de instância da classe
 
@return object: self
 
@author FAT/CRM
@since 18/05/2023
@version 1.0
*/
//-------------------------------------------------------------------
Method new() Class billingbysellerSmartViewBusinessObject

	_Super:new()
    self:appendArea(STR0001) 		// Faturamento
    self:setDisplayName(STR0002) 	// Faturamento por Vendedor
    self:setDescription(STR0003) 	// Listagem de Faturamento por Vendedor
    self:setIsLookUp(.T.)  

	self:aVdCposF2			:= {}
    self:cAliasSD1			:= ""
	self:cAliasSD2			:= ""
    self:cSelectSD1Loc		:= ""
	self:cSelectSD2Loc		:= ""
    self:cWhereSD1Loc		:= ""
	self:cWhereSD2Loc		:= ""
	self:nVlSD2IcmLoc		:= 0
	self:nVlSD2IpiLoc		:= 0
	self:nVlSD2StLoc		:= 0
	self:nVlSD2ImpIncLoc	:= 0
	self:nVlSD2ImpNoIncLoc	:= 0
	self:nQtdVends			:= 0
	self:nVlSD1TotLoc		:= 0
	self:nVlSD1IcmLoc		:= 0
	self:nVlSD1IpiLoc		:= 0
	self:nVlSF1AdicLoc		:= 0
	self:nVlSD1ImpIncLoc	:= 0
	self:nVlSD1ImpNoIncLoc	:= 0

Return self
 
//-------------------------------------------------------------------
/*{Protheus.doc} getData
Retorna os dados do objeto de negócio
 
@param nPage, numérico, indica a página atual do relatório
@param oFilter, objeto, contém o filtro do TReports
 
@return object: self:oData
 
@author FAT/CRM
@since 18/05/2023
@version 1.0
*/
//-------------------------------------------------------------------   
Method getData(nPage as numeric, oFilter as object) as object Class billingbysellerSmartViewBusinessObject

    Local cEstoq		:= ""		as character
  	Local cDupli		:= ""		as character
	Local cSD2Old		:= ""		as character
	Local cSD1Old		:= ""		as character
	Local cVend			:= ""		as character
	Local cFilSD1		:= ""		as character
	Local cFilSD2		:= ""		as character
	Local nContador		:= 0		as numeric
	Local nTOTAL		:= 0		as numeric
	Local nVALICM		:= 0		as numeric
	Local nVALIPI		:= 0		as numeric
	Local nVALST		:= 0		as numeric
	Local nImpInc		:= 0		as numeric
	Local nImpNoInc		:= 0		as numeric
	Local nAdic			:= 0		as numeric
	Local nVALOR3		:= 0		as numeric
	Local nI			:= 0		as numeric
	Local nZ			:= 0		as numeric
	Local nLenVend		:= 0		as numeric
	Local nScan			:= 0		as numeric
	Local nTaxa			:= 0		as numeric
	Local nMoedNF		:= 1		as numeric
	Local nPosVend		:= 0		as numeric
	Local dtMoedaDev	:= CtoD("")	as date
	Local aFatVend		:= {}		as array
	Local aVend			:= {}		as array
	Local aVdDevs		:= {}		as array
	Local aPDFields		:= {}		as array
	Local lObfuscated	:= .F.		as logical
	Local lColumTxMoeda	:= .T.		as logical
	Local lColumMoeda	:= .T.		as logical
	Local lNotVend		:= .F.		as logical

	MV_FIL := ""

    //Metodo para retorno do json dos parametros
    FatSetValueMVPAR(oFilter:GetParameters(), "MTR580")

    //Tratamento para permitir apenas o número de moedas utilizadas.
    MV_PAR06 := IIf(MV_PAR06 <= 0 .Or. MV_PAR06 > ContaMoeda(), 1, MV_PAR06)

	self:nDecs 	:= msdecimais(MV_PAR06)

	//Propriedade para informativo da quantidade de vendedores
	self:nQtdVends := Fa440CntVen()

	cEstoq 	:= IIf((MV_PAR09 == 1),"S",IIf( (MV_PAR09 == 2),"N","SN" ))
	cDupli 	:= IIf((MV_PAR08 == 1),"S",IIf( (MV_PAR08 == 2),"N","SN" ))

    //Array para processamento
    self:aFieldsValue := { 	{"D1_FILIAL"	, {"D1_FILIAL"	, "", 'aFatVend[nI][7]'}},;
							{"A3_COD"		, {"A3_COD"		, "", 'aFatVend[nI][1]'}},;
                         	{"A3_NOME"		, {"A3_NOME"	, "", 'aFatVend[nI][2]'}},;
						 	{"TB_VLSIMP"	, {"TB_VLSIMP"	, "", 'aFatVend[nI][3]'}},;
                         	{"TB_VLMERC"	, {"TB_VLMERC"  , "", 'aFatVend[nI][4]'}},;
                         	{"TB_VTOTAL"	, {"TB_VTOTAL"	, "", 'aFatVend[nI][5]'}},;
						 	{"TB_RANK"		, {"TB_RANK"	, "", 'aFatVend[nI][6]'}} }

    //Verifica se precisa fazer o tratamento para LGPD
    aPDFields   := FatGetfieldsLGPD(self:aFields, self:getCustomFields())
    lObfuscated := Len(aPDFields) > 0

	// Chama o método que monta as queries SQL
    self:FatSV016CreateSQL()

	SA3->(dbSetOrder(1)) //A3_FILIAL, A3_COD

	//Posiciona no registro inicial
	DbSelectArea(self:cAliasSD2)
	(self:cAliasSD2)->(dbGoTop())

	lColumTxMoeda	:= (self:cAliasSD2)->(ColumnPos("F2_TXMOEDA"))>0
	lColumMoeda		:= (self:cAliasSD2)->(ColumnPos("F2_MOEDA"))>0

	//Processa Faturamento
	While (self:cAliasSD2)->(!Eof())

		nTOTAL		:= 0
		nVALICM		:= 0
		nVALIPI		:= 0
		nVALST		:= 0
		nImpInc		:= 0
		nImpNoInc	:= 0

		self:nVlSD2IcmLoc		:= 0
		self:nVlSD2IpiLoc		:= 0
		self:nVlSD2StLoc		:= 0
		self:nVlSD2ImpIncLoc	:= 0
		self:nVlSD2ImpNoIncLoc	:= 0

		nTaxa	:= IIf(lColumTxMoeda,(self:cAliasSD2)->F2_TXMOEDA,0)
		nMoedNF	:= IIf(lColumMoeda,(self:cAliasSD2)->F2_MOEDA,0)
		cFilSD2	:= (self:cAliasSD2)->D2_FILIAL

		If AvalTes((self:cAliasSD2)->D2_TES,cEstoq,cDupli)

			//Tipo 2 realiza tratamento dos valores dos itens com cáculos localizados
			self:processData(2)
			nVALICM		+= self:nVlSD2IcmLoc
			nVALIPI		+= self:nVlSD2IpiLoc
			nVALST		+= self:nVlSD2StLoc
			nImpInc		+= self:nVlSD2ImpIncLoc
			nImpNoInc	+= self:nVlSD2ImpNoIncLoc

			If !((self:cAliasSD2)->F2_TIPO == "I" .AND. (self:cAliasSD2)->F2_ICMSRET > 0)
				nTOTAL += xMoeda((self:cAliasSD2)->D2_TOTAL,nMoedNF,MV_PAR06,(self:cAliasSD2)->D2_EMISSAO,self:nDecs+1,nTaxa)
			EndIf

			If nTOTAL <> 0 .OR. (self:cAliasSD2)->F2_TIPO == "I" .AND. (self:cAliasSD2)->F2_ICMSRET > 0
				For nContador := 1 To Len(self:aVdCposF2)
					cVend := (self:cAliasSD2)->(&(self:aVdCposF2[nContador]))

					If cVend >= MV_PAR03 .And. cVend <= MV_PAR04

						//Se vendedor em branco, considera apenas 1 vez
						If !(Empty(cVend) .and. nContador > 1)

							If ( aScan(aVend,cVend)==0 )
								aAdd(aVend,cVend)
							EndIf

							//Soma individual os valores por Vendedor
							nPosVend := aScan(aFatVend,{|x| x[1] == cVend})
							If nPosVend == 0
								aAdd(aFatVend, {cVend,;
												"",;
												(nTOTAL-nVALICM),;
												IIf((self:cAliasSD2)->F2_TIPO == "P",0,nTOTAL),;
												IIf((self:cAliasSD2)->F2_TIPO == "P",0,nTOTAL)+nVALIPI,;
												"",;
												cFilSD2})

								nPosVend := Len(aFatVend)
							Else
								aFatVend[nPosVend][3] := aFatVend[nPosVend][3]+(nTOTAL-nVALICM)
								aFatVend[nPosVend][4] := aFatVend[nPosVend][4]+IIf((self:cAliasSD2)->F2_TIPO == "P",0,nTOTAL)
								aFatVend[nPosVend][5] := aFatVend[nPosVend][5]+IIf((self:cAliasSD2)->F2_TIPO == "P",0,nTOTAL)+nVALIPI
							Endif

							aFatVend[nPosVend][5] := IIf(nImpInc <> 0 .Or. nImpNoInc <> 0, aFatVend[nPosVend][5] + nImpInc, aFatVend[nPosVend][5])
							aFatVend[nPosVend][3] := IIf(nImpInc <> 0 .Or. nImpNoInc <> 0, aFatVend[nPosVend][3] - nImpNoInc, aFatVend[nPosVend][3])

						Endif
					Endif
				Next nContador
			EndIf
		EndIf

		dbSelectArea(self:cAliasSD2)
		cSD2Old	:= (self:cAliasSD2)->D2_DOC+(self:cAliasSD2)->D2_SERIE+(self:cAliasSD2)->D2_CLIENTE+(self:cAliasSD2)->D2_LOJA

		//Considera Adicionais
		nAdic := 0
		If MV_PAR11 == 2
			nAdic := xMoeda((self:cAliasSD2)->F2_FRETE+(self:cAliasSD2)->F2_SEGURO+(self:cAliasSD2)->F2_DESPESA,nMoedNF,MV_PAR06,(self:cAliasSD2)->F2_EMISSAO,self:nDecs+1,nTaxa)
		EndIf
		nVALOR3  := xMoeda((self:cAliasSD2)->F2_FRETAUT+(self:cAliasSD2)->F2_ICMSRET,nMoedNF,MV_PAR06,(self:cAliasSD2)->F2_EMISSAO,self:nDecs+1,nTaxa)

		(self:cAliasSD2)->(dbSkip())

		If (self:cAliasSD2)->(Eof()) .Or. ( (self:cAliasSD2)->D2_DOC+(self:cAliasSD2)->D2_SERIE+(self:cAliasSD2)->D2_CLIENTE+(self:cAliasSD2)->D2_LOJA!= cSD2Old )
			For nContador := 1 To Len(aVend)
				//Soma individual os valores por Vendedor
				nPosVend := aScan(aFatVend,{|x| x[1] == aVend[nContador]})
				If nPosVend > 0
					aFatVend[nPosVend,5] := aFatVend[nPosVend,5]+nVALOR3+nAdic
				Endif
			Next nContador
			aSize(aVend,0)
		EndIf

	EndDo

	(self:cAliasSD2)->(dbCloseArea())

	//Processa Devolucao
	If (MV_PAR07 == 2) .And. !Empty(aFatVend)

		//Posiciona no registro inicial
		DbSelectArea(self:cAliasSD1)
		(self:cAliasSD1)->(dbGoTop())

		//Processa Devolucoes
		While (self:cAliasSD1)->(!Eof()) .And. !(((self:cAliasSD1)->D1_ORIGLAN <> "LO") .And. ((self:cAliasSD1)->F2_CLIENTE <> (self:cAliasSD1)->D1_FORNECE .And. (self:cAliasSD1)->F2_LOJA <> (self:cAliasSD1)->D1_LOJA))

			nTOTAL		:= 0
			nVALICM		:= 0
			nVALIPI		:= 0
			nVALADC		:= 0
			nLenVend	:= Len(self:aVdCposF2)
			aVdDevs		:= self:aVdCposF2

			self:nVlSD1TotLoc		:= 0
			self:nVlSD1IcmLoc		:= 0
			self:nVlSD1IpiLoc		:= 0
			self:nVlSF1AdicLoc		:= 0
			self:nVlSD1ImpIncLoc	:= 0
			self:nVlSD1ImpNoIncLoc	:= 0

			If AvalTes((self:cAliasSD1)->D1_TES,cEstoq,cDupli)

				DtMoedaDev := IIf(MV_PAR10 == 1 .Or. Empty((self:cAliasSD1)->F2_EMISSAO), (self:cAliasSD1)->F1_DTDIGIT, (self:cAliasSD1)->F2_EMISSAO)

				//Tipo 3 realiza tratamento dos valores dos itens de devolução com cáculos localizados
				self:processData(3)

				nTOTAL 		:= IIf(self:nVlSD1TotLoc == 0, xMoeda(((self:cAliasSD1)->D1_TOTAL - (self:cAliasSD1)->D1_VALDESC),(self:cAliasSD1)->F1_MOEDA,MV_PAR06,DtMoedaDev,self:nDecs+1,(self:cAliasSD1)->F1_TXMOEDA), self:nVlSD1TotLoc)
				nVALICM		:= self:nVlSD1IcmLoc
				nVALIPI		:= self:nVlSD1IpiLoc
				nVALADC		:= self:nVlSF1AdicLoc
				nImpInc		:= self:nVlSD1ImpIncLoc
				nImpNoInc	:= self:nVlSD1ImpNoIncLoc
				cFilSD1		:= (self:cAliasSD1)->D1_FILIAL

				For nContador := 1 To nLenVend
					cVend := (self:cAliasSD1)->(&(aVdDevs[nContador]))
					If cVend >= MV_PAR03 .And. cVend <= MV_PAR04
						If Empty(cVend) .and. nContador > 1
							Loop
						EndIf

						If ( aScan(aVend,cVend) == 0 )
							aAdd(aVend,cVend)
						EndIf

						If nTOTAL > 0
							//Soma individual os valores de Devolucao por Vendedor
							nPosVend := aScan(aFatVend,{|x| x[1] == cVend})

							&(IIf(nPosVend == 0,"aAdd(aFatVend,{cVend,'',aFatVend[nPosVend][3]-(nTOTAL-nVALICM),aFatVend[nPosVend][4]-nTOTAL,aFatVend[nPosVend][5]-nTOTAL-nVALIPI,'',cFilSD1})",".T."))
							nPosVend := IIf(nPosVend == 0, Len(aFatVend), nPosVend)

							If nPosVend > 0
								aFatVend[nPosVend][3] := aFatVend[nPosVend][3]-(nTOTAL-nVALICM)
								aFatVend[nPosVend][4] := aFatVend[nPosVend][4]-nTOTAL
								aFatVend[nPosVend][5] := aFatVend[nPosVend][5]-nTOTAL-nVALIPI
							EndIf
							
							aFatVend[nPosVend][5] := IIf(nImpInc <> 0 .Or. nImpNoInc <> 0, aFatVend[nPosVend][5] - nImpNoInc, aFatVend[nPosVend][5])
							aFatVend[nPosVend][3] := IIf(nImpInc <> 0 .Or. nImpNoInc <> 0, aFatVend[nPosVend][3] + nImpInc, aFatVend[nPosVend][3])

						EndIf
					Endif
				Next nContador
			EndIf

			dbSelectArea(self:cAliasSD1)
			cSD1Old := (self:cAliasSD1)->D1_DOC+(self:cAliasSD1)->D1_SERIE+(self:cAliasSD1)->D1_FORNECE+(self:cAliasSD1)->D1_LOJA

			nVALOR3	:= nVALADC

			(self:cAliasSD1)->(dbSkip())

			If (self:cAliasSD1)->(Eof()) .Or. ( (self:cAliasSD1)->D1_DOC+(self:cAliasSD1)->D1_SERIE+(self:cAliasSD1)->D1_FORNECE+(self:cAliasSD1)->D1_LOJA != cSD1Old)
				For nContador := 1 To Len(aVend)
					//Soma individual os valores por Vendedor
					nPosVend := aScan(aFatVend,{|x| x[1] == aVend[nContador]})
					If nPosVend > 0
						aFatVend[nPosVend,5] := aFatVend[nPosVend,5]-nVALOR3
						nVALOR3	:= 0
					Endif
				Next nContador

				aSize(aVend,0)
			EndIf
		EndDo

		(self:cAliasSD1)->(dbCloseArea())

	EndIf

	//Impressao do Relatorio
	If !Empty(aFatVend)
		//Ordenacao - Vendedor ou Ranking
		ASORT(aFatVend, , , { | x,y | x[5] > y[5] } )

		For nZ := 1 To Len(aFatVend)
			aFatVend[nZ][6] := Alltrim(Str(nZ))
		Next

		If MV_PAR05 == 1
			ASORT(aFatVend, , , { | x,y | x[1] < y[1] } )
		EndIf

		For nI := 1 To Len(aFatVend)
			//Verifica se possui venda sem vendedor
			If !Empty( aFatVend[nI][1] )
				SA3->(MsSeek(FatSVFilial("SA3","A3_FILIAL",aFatVend[nI][7])+aFatVend[nI][1]))
				aFatVend[nI][2] := SA3->A3_NOME
				lNotVend		:= .T.
			Else
				aFatVend[nI][1] := "-"
				aFatVend[nI][2] := STR0004 //"Vendas sem Vendedor"
				lNotVend		:= .F.
			EndIf

			self:jItems := JsonObject():new()

			For nZ := 1 To Len(self:aStruct)

				xValue := IIf((nScan := aScan(self:aFieldsValue,  {|x| x[1] == self:aStruct[nZ][5] } )) > 0,;
							FatGetValueFields(self:aFieldsValue[nScan][1], "SA3", self:aFieldsValue[nScan][2]),;
							IIf( SubStr(AllTrim(Upper(self:aStruct[nZ][5])), 1, 3) == "A3_" .And. !lNotVend .And. nZ > 2, "Nil", "SA3->"+self:aStruct[nZ][5]))
		
				self:jItems[self:aStruct[nZ][1]] := IIf(lObfuscated .and. ( nScan := aScan(aPDFields,  {|x| x[1] == self:aStruct[nZ][5] } ) )  > 0,;
														aPDFields[nScan][2],;
														IIf(Alltrim(self:aStruct[nZ][3]) == "date",;
															IIf( ValType(&(xValue)) == "C", totvs.framework.treports.date.stringToTimeStamp( &(xValue) ), totvs.framework.treports.date.dateToTimeStamp( &(xValue) )),;
															&(xValue)))
			Next

			self:processData(1)
			self:oData:appendData(self:jItems)

		Next

	EndIf

	FwFreeArray(aFatVend)
	FwFreeArray(aVend)
	FwFreeArray(aVdDevs)
	FwFreeArray(aPDFields)
	FwFreeArray(self:aFieldsValue)
	FwFreeArray(self:aVdCposF2)

Return self:oData

//-------------------------------------------------------------------
/*{Protheus.doc} getSchema
Retorna a estrutura dos campos

@return object: self:oSchema

@author FAT/CRM
@since 26/04/2023
@version 1.0
*/
//-------------------------------------------------------------------
Method getSchema() as object Class billingbysellerSmartViewBusinessObject

	Local nX 			:= 0  as numeric
	Local aCposFake		:= {} as array
	Local aParameters	:= {} as array

	self:aFields := {'D1_FILIAL','A3_COD','A3_NOME','TB_VLSIMP','TB_VLMERC','TB_VTOTAL','TB_RANK'}

	aCposFake := {{"TB_VLSIMP"	, STR0007, "number", STR0007, "TB_VLSIMP"},;	//"Faturamento S/ ICM/IPI"
				  {"TB_VLMERC"	, STR0008, "number", STR0008, "TB_VLMERC"},;	//"Valor da Mercadoria"
				  {"TB_VTOTAL"	, STR0009, "number", STR0009, "TB_VTOTAL"},;	//"Valor Total"
				  {"TB_RANK"	, STR0010, "string", STR0010, "TB_RANK"	 } }	//"Ranking"

	self:aStruct := FatTrGetStruct(self:aFields, aCposFake)

    For nX := 1 To Len(self:aStruct)
        self:addProperty(self:aStruct[nX][1], self:aStruct[nX][2], self:aStruct[nX][3], self:aStruct[nX][4], self:aStruct[nX][5])
    Next

	//Busca no SX1 os parâmetros que serão utilizados e remove os que estão no array
	aParameters := FtSVSetParam("MTR580")

	self:oSchema:addParameter("MV_FIL",	STR0011, "string", .T.,,,,,, FTSVHelp(,,, .T.))	// Filial ?

	For nX := 1 To Len(aParameters)
		self:oSchema:addParameter(aParameters[nX][1], aParameters[nX][2], aParameters[nX][3], aParameters[nX][4],,,,,, aParameters[nX][5])
	Next nX

	//Validação para versão da Lib
	If __lLookUp
		self:setCustomURL("MV_FIL",   "api/framework/v1/genericLookupService/smartview/SM0", 2)						// Filial 
		self:setCustomURL("MV_PAR03", "api/framework/v1/genericLookupService/smartview/SA3", 2)						// Do Vendedor
		self:setCustomURL("MV_PAR04", "api/framework/v1/genericLookupService/smartview/SA3", 2)						// Ate o Vendedor
		self:setCustomURL("MV_PAR05", "api/framework/treports/integratedprovider/v1/options/MTR580/MV_PAR05", 1)	// Qual a Moeda
		self:setCustomURL("MV_PAR07", "api/framework/treports/integratedprovider/v1/options/MTR580/MV_PAR07", 1)	// Desconsidera Devolução
		self:setCustomURL("MV_PAR08", "api/framework/treports/integratedprovider/v1/options/MTR580/MV_PAR08", 1)	// TES Qto Faturamento
		self:setCustomURL("MV_PAR09", "api/framework/treports/integratedprovider/v1/options/MTR580/MV_PAR09", 1)	// TES Qto Estoque
		self:setCustomURL("MV_PAR10", "api/framework/treports/integratedprovider/v1/options/MTR580/MV_PAR10", 1)	// Converte Moeda da Devolucão
		self:setCustomURL("MV_PAR11", "api/framework/treports/integratedprovider/v1/options/MTR580/MV_PAR11", 1)	// Desconsidera Adicionais
	EndIf

	FwFreeArray(aCposFake)
	FwFreeArray(aParameters)

Return self:oSchema

//-------------------------------------------------------------------
/*{Protheus.doc} FatSv016CreateSQL
Retorna todas as querys montadas

@return Nil

@author FAT/CRM
@since 27/01/2025
@version 1.0
*/
//-------------------------------------------------------------------
Method FatSv016CreateSQL() Class billingbysellerSmartViewBusinessObject

	Local nParamSD1	 		:= 1   as numeric
	Local nParamSD2	 		:= 1   as numeric
	Local nCampo			:= 0   as numeric
    Local cQuerySD1  	 	:= ""  as character
	Local cQuerySD2  	 	:= ""  as character
	Local cFldsQrySD1 		:= ""  as character
	Local cFldsQrySD2 		:= ""  as character
	Local cNameTmp			:= ""  as character
	Local cAddField 		:= ""  as character
	Local cVendedor 		:= "1" as character
	Local cCampo			:= ""  as character
	Local cWhereD1Remi		:= IsRemito(2,"D1_TIPODOC")	as character
	Local cWhereD2Remi		:= IsRemito(2,"D2_TIPODOC")	as character
    Local oQuerySD1 	 	:= Nil as object
	Local oQuerySD2 	 	:= Nil as object
	Local oTempTableBranch	:= Nil as object
	Local aFiliais	 		:= {}  as array

	// Função que verifica se há filiais informadas no parâmetro
    aFiliais := FatGetMVFiliais(MV_FIL)

	// Função que irá criar a tabela temporaria para fazer o Join de filiais
	oTempTableBranch := FatSVTableTempBranch(aFiliais, "SC9", "C9_FILIAL")
	cNameTmp := oTempTableBranch:GetTableNameForQuery()

	For nCampo := 1 To self:nQtdVends
		cCampo := "F2_VEND" + cVendedor
		If SF2->(FieldPos(cCampo)) > 0
			cAddField += ", "  + cCampo
			aAdd(self:aVdCposF2, cCampo)
		EndIf
		cVendedor := Soma1(cVendedor,1)
	Next nCampo

	// Monta campos do Select da SD2
    cFldsQrySD2 := "SD2.D2_FILIAL,SD2.D2_TES,SD2.D2_EMISSAO,SD2.D2_VALICM,SD2.D2_VALIPI,SD2.D2_TOTAL,SD2.D2_DOC,SD2.D2_SERIE,SD2.D2_CLIENTE,SD2.D2_LOJA,"
	cFldsQrySD2 += "SF2.F2_EMISSAO,SF2.F2_TIPO,SF2.F2_DOC,SF2.F2_FRETE,SF2.F2_SEGURO,SF2.F2_DESPESA,SF2.F2_FRETAUT,SF2.F2_ICMSRET,SF2.F2_TXMOEDA,SF2.F2_MOEDA"
	cFldsQrySD2 += cAddField
	cFldsQrySD2 += self:cSelectSD2Loc

	// Adiciona campos customizados (no array da estrutura)
	FatInjCposPerson(@self:aFieldsValue, @self:aStruct, @cFldsQrySD2, self:getCustomFields(), .F., .F., .T.)

	// Verifica se considera devolução (2 = Sim)
	If MV_PAR07 == 2

		// Monta campos do Select da SD1
		cFldsQrySD1 := "SD1.D1_FILIAL,SD1.D1_ORIGLAN,SD1.D1_FORNECE,SD1.D1_LOJA,SD1.D1_TES,SD1.D1_VALICM,SD1.D1_VALIPI,SD1.D1_TOTAL,SD1.D1_VALDESC,SD1.D1_DOC,SD1.D1_SERIE,"
		cFldsQrySD1 += "SF1.F1_EMISSAO,SF1.F1_DOC,SF1.F1_SERIE,SF1.F1_FORNECE,SF1.F1_LOJA,SF1.F1_FRETE,SF1.F1_DESPESA,SF1.F1_SEGURO,"
		cFldsQrySD1 += "SF1.F1_ICMSRET,SF1.F1_DTDIGIT,SF1.F1_TXMOEDA,SF1.F1_MOEDA,SF2.F2_EMISSAO,SF2.F2_CLIENTE,SF2.F2_LOJA"
		cFldsQrySD1 += cAddField
		cFldsQrySD1 += self:cSelectSD1Loc

		// Monta a query da SD1
		cQuerySD1 := "SELECT ? "
		cQuerySD1 += " FROM "		+ RetSqlName("SD1") + " SD1 "
		cQuerySD1 += "INNER JOIN ? TMPFIL "
		cQuerySD1 += " ON TMPFIL.TMP_FILIAL = SD1.D1_FILIAL "
		cQuerySD1 += "INNER JOIN " 	+ RetSqlName("SF1") + " SF1 "
		cQuerySD1 += " ON  SF1.F1_FILIAL 	= SD1.D1_FILIAL "
		cQuerySD1 += " AND SF1.F1_DOC 		= SD1.D1_DOC "
		cQuerySD1 += " AND SF1.F1_SERIE 	= SD1.D1_SERIE "
		cQuerySD1 += " AND SF1.F1_FORNECE 	= SD1.D1_FORNECE "
		cQuerySD1 += " AND SF1.F1_LOJA 		= SD1.D1_LOJA "
		cQuerySD1 += " AND SF1.D_E_L_E_T_ 	= ? "
		cQuerySD1 += "INNER JOIN " 	+ RetSqlName("SF2") + " SF2 "
		cQuerySD1 += " ON  SF2.F2_FILIAL 	= SD1.D1_FILIAL "
		cQuerySD1 += " AND SF2.F2_DOC 		= SD1.D1_NFORI "
		cQuerySD1 += " AND SF2.F2_SERIE 	= SD1.D1_SERIORI "
		cQuerySD1 += " AND SF2.F2_CLIENTE	= SD1.D1_FORNECE "
		cQuerySD1 += " AND SF2.F2_LOJA 		= SD1.D1_LOJA "
		cQuerySD1 += " AND ( "

		// Where para filtro de acordo com a quantidade de vendedores
		For nCampo := 1 To Len(self:aVdCposF2)
			If nCampo < Len(self:aVdCposF2)
				cQuerySD1 += " ( ? BETWEEN ? AND ?) OR "
			Else
				cQuerySD1 += " ( ? BETWEEN ? AND ?) "
			EndIf
		Next nCampo

		cQuerySD1 += " ) "
		cQuerySD1 += " AND SF2.D_E_L_E_T_ 	= ? "
		cQuerySD1 += "INNER JOIN " 	+ RetSqlName("SF4") + " SF4 "
		cQuerySD1 += " ON  ? "
		cQuerySD1 += " AND SF4.F4_CODIGO 	= SD1.D1_TES "
		cQuerySD1 += " AND SF4.D_E_L_E_T_ 	= ? "
		cQuerySD1 += "WHERE SD1.D1_FILIAL 	= TMPFIL.TMP_FILIAL "
		cQuerySD1 += " AND SD1.D1_DTDIGIT BETWEEN ? AND ? "
		cQuerySD1 += " AND SD1.D1_TIPO 		= ? "
		cQuerySD1 += " AND NOT ( ? ) "
		cQuerySD1 += " ? " 	// Where para query de devoluções que foi populado no objeto localizado
		cQuerySD1 += " AND SD1.D_E_L_E_T_ 	= ? "
		cQuerySD1 += "ORDER BY SD1.D1_FILIAL, SD1.D1_DTDIGIT, SD1.D1_NUMSEQ "

		// Monta o objeto da query da SD1
		oQuerySD1 := FwExecStatement():New(ChangeQuery(cQuerySD1))
		oQuerySD1:SetUnsafe(nParamSD1++, cFldsQrySD1)
		oQuerySD1:SetUnsafe(nParamSD1++, cNameTmp)
		oQuerySD1:SetString(nParamSD1++, ' ')

		For nCampo := 1 To Len(self:aVdCposF2)
			oQuerySD1:SetUnsafe(nParamSD1++, self:aVdCposF2[nCampo])
			oQuerySD1:SetString(nParamSD1++, MV_PAR03)
			oQuerySD1:SetString(nParamSD1++, MV_PAR04)
		Next nCampo

		oQuerySD1:SetString(nParamSD1++, ' ')
		oQuerySD1:SetUnsafe(nParamSD1++, FwJoinFilial("SF4", "SD1"))
		oQuerySD1:SetString(nParamSD1++, ' ')
		oQuerySD1:SetString(nParamSD1++, DTOS(MV_PAR01))
		oQuerySD1:SetString(nParamSD1++, DTOS(MV_PAR02))
		oQuerySD1:SetString(nParamSD1++, 'D')
		oQuerySD1:SetUnsafe(nParamSD1++, cWhereD1Remi)
		oQuerySD1:SetUnsafe(nParamSD1++, self:cWhereSD1Loc)
		oQuerySD1:SetString(nParamSD1++, ' ')

		self:cAliasSD1 := oQuerySD1:OpenAlias()

	EndIf

	// Monta a query da SD2
	cQuerySD2 := "SELECT ? "
	cQuerySD2 += " FROM "		+ RetSqlName("SD2") + " SD2 "
	cQuerySD2 += "INNER JOIN ? TMPFIL "
	cQuerySD2 += " ON TMPFIL.TMP_FILIAL = SD2.D2_FILIAL "
	cQuerySD2 += "INNER JOIN " 	+ RetSqlName("SF2") + " SF2 "
	cQuerySD2 += " ON  SF2.F2_FILIAL 	= SD2.D2_FILIAL " 
	cQuerySD2 += " AND SF2.F2_DOC 		= SD2.D2_DOC "
	cQuerySD2 += " AND SF2.F2_SERIE 	= SD2.D2_SERIE "
	cQuerySD2 += " AND SF2.F2_CLIENTE 	= SD2.D2_CLIENTE "
	cQuerySD2 += " AND SF2.F2_LOJA 		= SD2.D2_LOJA "
	cQuerySD2 += " AND ( "

	// Where para filtro de acordo com a quantidade de vendedores
	For nCampo := 1 To Len(self:aVdCposF2)
		If nCampo < Len(self:aVdCposF2)
			cQuerySD2 += " ( ? BETWEEN ? AND ?) OR "
		Else
			cQuerySD2 += " ( ? BETWEEN ? AND ?) "
		EndIf
	Next nCampo

	cQuerySD2 += " ) "
	cQuerySD2 += " AND SF2.D_E_L_E_T_ 	= ? "
	cQuerySD2 += "INNER JOIN " 	+ RetSqlName("SF4") + " SF4 "
	cQuerySD2 += " ON  ? "
	cQuerySD2 += " AND SF4.F4_CODIGO 	= SD2.D2_TES "
	cQuerySD2 += " AND SF4.D_E_L_E_T_ 	= ? "
	cQuerySD2 += "WHERE D2_FILIAL 		= TMPFIL.TMP_FILIAL "
	cQuerySD2 += " AND D2_EMISSAO BETWEEN ? AND ? "
	cQuerySD2 += " AND D2_TIPO NOT IN  	 (?) "
	cQuerySD2 += " AND NOT (?) "
	cQuerySD2 += " ? " 		// Where para query principal que foi populado no objeto localizado
	cQuerySD2 += " AND SD2.D_E_L_E_T_ 	= ? "
	cQuerySD2 += "ORDER BY SD2.D2_FILIAL, SD2.D2_EMISSAO, SD2.D2_DOC, SD2.D2_NUMSEQ "

	// Monta o objeto da query da SD2
    oQuerySD2 := FwExecStatement():New(ChangeQuery(cQuerySD2))
    oQuerySD2:SetUnsafe(nParamSD2++, cFldsQrySD2)
	oQuerySD2:SetUnsafe(nParamSD2++, cNameTmp)

	For nCampo := 1 To Len(self:aVdCposF2)
		oQuerySD2:SetUnsafe(nParamSD2++, self:aVdCposF2[nCampo])
		oQuerySD2:SetString(nParamSD2++, MV_PAR03)
		oQuerySD2:SetString(nParamSD2++, MV_PAR04)
	Next nCampo

	oQuerySD2:SetString(nParamSD2++, ' ')
	oQuerySD2:SetUnsafe(nParamSD2++, FwJoinFilial("SF4", "SD2"))
    oQuerySD2:SetString(nParamSD2++, ' ')
	oQuerySD2:SetString(nParamSD2++, DTOS(MV_PAR01))
    oQuerySD2:SetString(nParamSD2++, DTOS(MV_PAR02))
	oQuerySD2:SetIn(nParamSD2++, {'D','B'})
	oQuerySD2:SetUnsafe(nParamSD2++, cWhereD2Remi)
	oQuerySD2:SetUnsafe(nParamSD2++, self:cWhereSD2Loc)
	oQuerySD2:SetString(nParamSD2++, ' ')

	self:cAliasSD2 := oQuerySD2:OpenAlias()

	oTempTableBranch:Delete()

	FreeObj(oQuerySD1)
	FreeObj(oQuerySD2)
	FreeObj(oTempTableBranch)

	FwFreeArray(aFiliais)

Return
