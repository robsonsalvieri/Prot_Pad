#INCLUDE "TBICONN.CH"
#INCLUDE "MATA461.CH"
#INCLUDE "PROTHEUS.CH"
#INCLUDE "FWMVCDEF.CH"
#INCLUDE "FWADAPTEREAI.CH"
#INCLUDE "FWLIBVERSION.CH"


PUBLISH MODEL REST NAME MATA461 SOURCE MATA461

//aTitulo
#DEFINE _VLRTIT_		01
#DEFINE _VLRIRRF_		02
#DEFINE _VLRINSS_		03
#DEFINE _VLRISS_		04
#DEFINE _VLRPIS_		05
#DEFINE _VLRCSLL_		06
#DEFINE _VLRCOFI_		07
#DEFINE _VLRIPI_   		08
#DEFINE _VLRSOL_   		09
#DEFINE _VLRMOE_   		10
#DEFINE _VLRREA_   		11
#DEFINE _VLRACR_   		12
#DEFINE _VLRDSPMOE_		13 //Valor despesas acessorias na moeda
#DEFINE _VLRDSPREA_    14 //Valor despesas acessorias em real
#DEFINE _VLRTITDIF_    15 //Diferenca no valor do titulo na moeda do titulo
#DEFINE _TAXANDF_      16 //Taxa da NDF
#DEFINE _MOEDANDF_     17 //Moeda da NDF
#DEFINE _VLRFET_       18 //Valor do FETHAB
#DEFINE _VLRDESPAC2_   19 //Diferença no rateio das despesas acessorias em dolar
#DEFINE _VLRFAB_       20 //Valor do FABOV
#DEFINE _VLRFAC_       21 //Valor do FACS
#DEFINE _VLRTPDP_      22 //Valor do FACS
#DEFINE _VLRFMP_       23 //Valor do FUMIPEQ
#DEFINE _VLRIMA_       24 //Valor do IMA
#DEFINE _VLBTISS_      25 //Valor do ISS Bi Tributado
#DEFINE _VLRFMD_       26 //Valor do FAMAD

//aImposto
#DEFINE _IMPFET_		08 //Valor do FETHAB
#DEFINE _IMPFAB_		09 //Valor do FABOV
#DEFINE _IMPFAC_		10 //Valor do FACS

//GetMv
#DEFINE  __ULMES    	01
#DEFINE  __LIBGRUPO 	02
#DEFINE  __FRETMOE  	03
#DEFINE  __CONTSOC	 	04
#DEFINE  __MCUSTO	 	05
#DEFINE  __MOEDTIT	 	06
#DEFINE  __TXPER	 	07
#DEFINE  __TPCOMIS	 	08
#DEFINE  __1DUP	 		09
#DEFINE  __1DUPREF	 	10
#DEFINE  __1DUPNAT	 	11
#DEFINE  __RATDESP  	12
#DEFINE  __SERCUP   	13
#DEFINE  __TPNRNFS  	14
#DEFINE  __EECFAT   	15
#DEFINE  __RTIPFIN  	16

//Entry Point - Pontos de Entrada
#DEFINE EP_M460MKB		01
#DEFINE EP_M461IMPF		02
#DEFINE EP_SF2460I		03
#DEFINE EP_M460IPI		04
#DEFINE EP_M460ICM		05
#DEFINE EP_M460SOLI		06
#DEFINE EP_MSD2UM2		07
#DEFINE EP_MSD2460		08
#DEFINE EP_MTASF2		09
#DEFINE EP_F440COM		10
#DEFINE EP_M460IREN		11
#DEFINE EP_M460ISS 		12
#DEFINE EP_M460VISS		13
#DEFINE EP_M460ATEC		14
#DEFINE EP_M460NITE		15
#DEFINE EP_M460PROC		16
#DEFINE EP_M460QRY	 	17
#DEFINE EP_M460FIL	 	18
#DEFINE EP_M460RTPD		19
#DEFINE EP_M460FIM	 	20
#DEFINE EP_M460COND		21
#DEFINE EP_M460INSS		22
#DEFINE EP_M460ITPD		23
#DEFINE EP_M460ORD		24
#DEFINE EP_M460MOED		25
#DEFINE EP_M460FIT		26
#DEFINE EP_M460IPT		27
#DEFINE EP_M460QRT	 	28
#DEFINE EP_M460SOT	 	29
#DEFINE EP_MSD246T		30
#DEFINE EP_MSD2UMT		31
#DEFINE EP_SF2460T		32
#DEFINE EP_M460RAT	  	33
#DEFINE EP_M461ACRE	 	34
#DEFINE EP_M460NOTA		35
#DEFINE EP_M460ICMT		36
#DEFINE EP_M460QUEB		37
#DEFINE EP_M461VTOT		38
#DEFINE EP_M461DINF		39
#DEFINE EP_M460MARKT	40
#DEFINE EP_M460MARK		41
#DEFINE EP_M461ADT		42
#DEFINE EP_M461SLD		43
#DEFINE EP_M461SER		44
#DEFINE EP_M461TRV		45
#DEFINE EP_M461COR		46
#DEFINE EP_M461LSF2		47
#DEFINE EP_M461GRVTAB	48
#DEFINE EP_M460PRC		49
#DEFINE EP_M460FIMT		50
#DEFINE EP_M461SB3		51
#DEFINE EP_M460CUST		52
#DEFINE EP_M460CUSTT	53
#DEFINE EP_M460GCUS		54
#DEFINE EP_FATDOCSA		55

//aSavRat
#DEFINE SV_PEDIDO   	01
#DEFINE SV_FRETE    	02
#DEFINE SV_FRETAUT  	03
#DEFINE SV_SEGURO   	04
#DEFINE SV_DESPESA  	05
#DEFINE SV_DESCONT  	06
#DEFINE SV_DESPAC2  	07
#DEFINE SV_VLR_FRT  	08
#DEFINE SV_DATA			09
#DEFINE SV_HORA			10
#DEFINE SV_C5_FRETE		11
#DEFINE SV_C5_FRETAUT	12
#DEFINE SV_C5_SEGURO	13
#DEFINE SV_C5_DESPESA	14
#DEFINE SV_C5_DESCONT	15
#DEFINE SV_C5_VLR_FRT	16

//aRateio
#DEFINE RT_PEDIDO   	01
#DEFINE RT_ITEM     	02
#DEFINE RT_SEQUEN   	03
#DEFINE RT_FRETE    	04
#DEFINE RT_SEGURO   	05
#DEFINE RT_DESPESA  	06
#DEFINE RT_FRETAUT  	07
#DEFINE RT_DESCONT  	08
#DEFINE RT_PRECOIT  	09
#DEFINE RT_PDESCON  	10
#DEFINE RT_DESPAC2  	11
#DEFINE RT_DESPMOE  	12
#DEFINE RT_VLR_FRT  	13

#DEFINE __UFORI  		01
#DEFINE __ALQORI 		02
#DEFINE __PROPOR 		03

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Variaveis Staticas do Programa                                          ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Static aEntry     := {}
Static aFisGet    := Nil
Static aFisGetSC5 := Nil
Static aRelImp    := Nil
Static aSavRat    := {}
Static cOriPed    := "" //Origem do Pedido
Static cTimeInitR := ""

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Variaveis Staticas para utilizacao do arquivo SD9 na numeracao de DOC   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Static cMin460D
Static dDatabOri 	:= Ctod("")
Static aSerieSD9 	:= {}                    // Series utilizadas no controle pelo SD9
Static cFilOri  	:= ""                    //filial  para controle de numeracao SD9
Static lIsNItem		:= FindFunction("a410IsNItem")

Static _aDPrv461	:= {}
Static lIsRussia	:= cPaisloc == "RUS"
// Variáveis Staticas de funções, Templates e Pontos de entrada
Static _lEECF2FrEmb		:= FindFunction("EECFat2FreteEmb")
Static _lEECF2AtRat		:= FindFunction("EECFat2AtuRat")
Static _lEECAtPesNF		:= FindFunction("EECAtuPesNF")
Static _lFisTitCDA		:= FindFunction("FisTitCDA")
Static _lMaEnvEAI		:= FindFunction("MaEnvEAI")
Static _lLjUP104OK		:= FindFunction("LjUP104OK")
Static _lXFciGOrigem	:= FindFunction("XFciGetOrigem")
Static _lFisGrvCFF		:= FindFunction("FisGrvCFF")
Static _lM461PRCV		:= ExistBlock("PM461PRCV")	//Project Function para alterar preço de venda
Static _lM461UNIT		:= ExistBlock("PM461UNIT")	//Project Function para alterar preço unitário
Static _lOGX155			:= FindFunction("OGX155")
Static _lOGX225J		:= FindFunction('OGX225J')
Static _lOGXUtOrig		:= FindFunction("OGXUtlOrig")
Static _lAGDI010		:= FindFunction("AGDI010")
Static _lChkTrbGen      := FindFunction("ChkTrbGen")
Static _lFINCalImp      := FindFunction("FINCalImp")
Static _lFGrvImpFi      := FindFunction("FGrvImpFi")
Static _lFINGRVFK7      := FindFunction("FINGRVFK7")
Static _lFinParcFKK     := FindFunction("FinParcFKK")
Static _lOrigemLote		:= FindFunction("OrigemLote")
Static _lAcdFatOsep		:= FindFunction("AcdFatOsep")
Static _lTmGuiaGRNE     := FindFunction("TmGuiaGRNE") 
Static _lComplTrib		:= FindFunction("FSA303ALT")
Static _xFisF_LT		:= FindFunction("xFisF_LT")
Static lFATTRVSA1       := ExistBlock("FATTRVSA1")
Static lRiskIsAtv       := FindFunction("RskIsActive")
Static __lMetric 		:= Nil
Static aFiltro			:= Nil
Static lMa460Nota		:= .F.
Static lAIS             
Static _nMovWMS := 0 //Variavel para controle de metrica WMS
Static _lGtpRecD2		:= FindFunction("gtpRecnoSD2")
Static oQrySD9		 	:= Nil
Static __RpoRelease		:= GetRPORelease()

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Program   ³MATA460   ³ Autor ³Eduardo Riera          ³ Data ³27.08.1999	³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Rotina de Geracao das Notas Fiscais de Saida.              	³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpL1: Processamento Ok.                                    	³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³Nenhum                                                      	³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ ATUALIZACOES SOFRIDAS DESDE A CONSTRUCAO INICIAL.                     	³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ PROGRAMADOR  ³ DATA   ³ BOPS ³  MOTIVO DA ALTERACAO                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³              ³        ³      ³                                          ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function Mata460a()

Local lContinua	:= .T.
Local lIntACD	:= SuperGetMV("MV_INTACD",.F.,"0") == "1"
Local lFilBrow	:= SuperGetMV("MV_FTFB461",.F.,.F.)
Local cFilSC9	:= ""
Local cQrySC9	:= ""
Local aIndexSC9	:= {}
Local aCores	:= {}
Local lFatPrev	:= SuperGetMV( 'MV_FATFTPR', .F., .T. )	//Indica se permite faturar itens previstos (C9_TPOP = P)
Local cMarca    := ""
Local cMarcaAgr := ""
Local cQryUpd   := ""
Local lAgrupad  := .F.
Local lInvMarc  := .F. //Inverte a Marcacao - Opcao de trazer itens selecionados habilitada
Local cM460FC9	:= ""	// Usado no PE M460FILC9
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Tratamento para e-Commerce      ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Local lECommerce := SuperGetMV("MV_LJECOMM",,.F.)

PRIVATE bFiltraBrw         // Expressao de Filtro
PRIVATE nOrdNFS   := 1     // Ordem de Geracao da Nota Fiscal
PRIVATE aRotina   := FwLoadMenuDef("MATA460A")
PRIVATE cCadastro := OemToAnsi(STR0005)                  //"Prepara‡„o dos Documentos de Sa¡da"
Private c460Cond  := ""

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Carga das Variaveis Staticas do Programa                                ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
DbSelectArea('SC9')	//Liberação de Pedidos
SC9->(DbSetOrder(1))	//C9_FILIAL + C9_PEDIDO + C9_ITEM + C9_SEQUEN + C9_PRODUTO
dbSelectArea("SFC")
dbSelectArea("AF8")
dbSelectArea("AFS")
dbSelectArea("SES")
MaNfsInit()

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Avalia Ponto de Entrada                                                 ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

If ( aEntry[EP_M460MKB] )
	c460Cond := ExecBlock("M460MKB", .F., .F.)
EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Verifica o direito de acesso por parte do usuario                       ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If ( Substr(cAcesso,51,1) <> "S" )
	dbSelectArea("SF2")
	dbSetOrder(3)
	MsSeek(xFilial("SF2")+Space(Len(SF2->F2_ECF))+"z",.T.)
	dbSkip(-1)
	If ( dDataBase < SF2->F2_EMISSAO )
		Help(" ",1,"DATNF")
		lContinua := .F.
	EndIf
	If lContinua
		MsSeek(xFilial("SF2")+"S"+"z",.T.)
		dbSkip(-1)
		If ( dDataBase < SF2->F2_EMISSAO )
			Help(" ",1,"DATNF")
			lContinua := .F.
		EndIf
	EndIf
EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Verifica o Ambiente de Processamento.                                   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If ( AMIIn(5,12,39,45,69) .And. lContinua )			// SigaFat - SigaLoja - SigaCda
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Verifica o Fechamento do Estoque                                        ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If ( MVUlmes() >= dDataBase )
		Help ( " ", 1, "FECHTO" )
		lContinua := .F.
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Verifica o Fechamento do Fiscal                                         ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If ( !FisChkDt(dDataBase) )
		lContinua := .F.
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica as perguntas MT461A                                 ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Variaveis utilizadas para parametros                         ³
	//³ mv_par01     // Filtra j  emitidas     - Sim/Nao             ³
	//³ mv_par02     // Estorno da Liberacao   - Posic./Marcados     ³
	//³ mv_par03     // Cons. Param. Abaixo    - Sim/Nao             ³
	//³ mv_par04     // Trazer Ped. Marc       - Sim/Nao             ³
	//³ mv_par05     // De  Pedido                                   ³
	//³ mv_par06     // Ate Pedido                                   ³
	//³ mv_par07     // De  Cliente                                  ³
	//³ mv_par08     // Ate Cliente                                  ³
	//³ mv_par09     // De  Loja                                     ³
	//³ mv_par10     // Ate Loja                                     ³
	//³ mv_par11     // De  Liberacao                                ³
	//³ mv_par12     // Ate Liberacao                                ³
	//³ mv_par13     // Mostra Itens Previstos - Sim/Não             ³
	//³ mv_par14     // De  Entrega                                  ³
	//³ mv_par15     // Ate Entrega                                  ³
	//³ mv_par16     // Agrupadores                                  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If ( Pergunte("MT461A",.T.) .And. lContinua )

		cFilSC9 := ""
		cQrySC9 := ""

		cMarca	  := GetMark(,"SC9","C9_OK")
		cMarcaAgr := RetCodUsr()
		lAgrupad  := .F.

		//Se tem agrupador marcado, executa o filtro dos agrupadores
		FwMsgRun(,{|| lAgrupad := MT461AGR(cMarcaAgr)},STR0076,STR0089) // "Aguarde..."#"Selecionando Registros do Agrupador"

		If	lAgrupad //Tem agrupador marcado
			cFilSC9 += "C9_FILAGRU='"+cMarcaAgr+"' .AND. "
			cQrySC9 += "SC9.C9_FILAGRU='"+cMarcaAgr+"' AND "
		EndIf

		cFilSC9 += "C9_FILIAL='"+xFilial("SC9")+"'"
		cQrySC9 += "SC9.C9_FILIAL='"+xFilial("SC9")+"'"

		If ( MV_PAR01 == 1 )
			cFilSC9 += ".And.C9_BLEST<>'10'"
			cFilSC9 += ".And.C9_BLEST<>'ZZ'"
		EndIf

		If ( !lFatPrev )	//Indica se permite faturar itens Previstos (Campo C6_TPOP)

			//Filtra apenas itens com Tipo de Ordem de Produção Firmes (C6_TPOP = 'F' | C9_TPOP = '1')
			cFilSC9 += ".And. C9_TPOP != '2'"
			cQrySC9 += " AND  SC9.C9_TPOP <> '2'"

		EndIf
		//--Pedidos com Carga devem ser faturados pela rotina MATA460B
		cFilSC9 += ".And. C9_CARGA = ' '"
		
		If ( MV_PAR03 == 1 )

			cFilSC9 += ".And.C9_PEDIDO>='"+MV_PAR05+"'"
			cFilSC9 += ".And.C9_PEDIDO<='"+MV_PAR06+"'"
			cFilSC9 += ".And.C9_CLIENTE>='"+MV_PAR07+"'"
			cFilSC9 += ".And.C9_CLIENTE<='"+MV_PAR08+"'"
			cFilSC9 += ".And.C9_LOJA>='"+MV_PAR09+"'"
			cFilSC9 += ".And.C9_LOJA<='"+MV_PAR10+"'"
			cFilSC9 += ".And.Dtos(C9_DATALIB)>='"+Dtos(MV_PAR11)+"'"
			cFilSC9 += ".And.Dtos(C9_DATALIB)<='"+Dtos(MV_PAR12)+"'"

			//Mostra itens previstos?
			If ( !Empty( MV_PAR13 ) ) .And. ( ValType(MV_PAR13) == 'N' ) .AND. ( MV_PAR13 == 2 ) .And. ( lFatPrev )
				cFilSC9 += ".And. C9_TPOP != '2'"
			EndIf

			//Filtra por data de entrega
			If ( !Empty( MV_PAR14 ) ) .And. ( ValType(MV_PAR14) == 'D' )
				cFilSC9 += ".And. DToS(C9_DATENT) >= '" + DToS(MV_PAR14) + "'"
			EndIf
			If ( !Empty( MV_PAR15 ) ) .And. ( ValType(MV_PAR15) == 'D' )
				cFilSC9 += ".And. DToS(C9_DATENT) <= '" + DToS(MV_PAR15) + "'"
			EndIf

			cQrySC9 += " AND SC9.C9_PEDIDO>='"+MV_PAR05+"'"
			cQrySC9 += " AND SC9.C9_PEDIDO<='"+MV_PAR06+"'"
			cQrySC9 += " AND SC9.C9_CLIENTE>='"+MV_PAR07+"'"
			cQrySC9 += " AND SC9.C9_CLIENTE<='"+MV_PAR08+"'"
			cQrySC9 += " AND SC9.C9_LOJA>='"+MV_PAR09+"'"
			cQrySC9 += " AND SC9.C9_LOJA<='"+MV_PAR10+"'"
			cQrySC9 += " AND SC9.C9_DATALIB>='"+Dtos(MV_PAR11)+"'"
			cQrySC9 += " AND SC9.C9_DATALIB<='"+Dtos(MV_PAR12)+"'"

			//Mostra itens previstos?
			If ( !Empty( MV_PAR13 ) ) .And. ( ValType(MV_PAR13) == 'N' ) .AND. ( MV_PAR13 == 2 ) .And. ( lFatPrev )
				cQrySC9 += " AND SC9.C9_TPOP <> '2'"
			EndIf

			If ( !Empty( MV_PAR14 ) ) .And. ( ValType(MV_PAR14) == 'D' )
				cQrySC9 += " AND SC9.C9_DATENT >= '" + DToS(MV_PAR14) + "'"
			EndIf

			If ( !Empty( MV_PAR15 ) ) .And. ( ValType(MV_PAR15) == 'D' )
				cQrySC9 += " AND SC9.C9_DATENT <= '" + DToS(MV_PAR15) + "'"
			EndIf

			If IntWms() .And. SuperGetMV("MV_WMSNEW",.F.,.F.)
				cFilSC9 += ".AND. C9_ROMEMB >='"+MV_PAR17+"' .AND. C9_ROMEMB <='"+MV_PAR18+"'"
				cQrySC9 += " AND SC9.C9_ROMEMB >='"+MV_PAR17+"' AND SC9.C9_ROMEMB <='"+MV_PAR18+"'"
			EndIf

		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Pontos de Entrada					                                   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If ( aEntry[EP_M460QRT] )
			cQrySC9 := ExecTemplate("M460QRY",.F.,.F.,{ cQrySC9 , 1 })
		EndIf

		If ( aEntry[EP_M460QRY] )
			cQrySC9 := ExecBlock("M460QRY",.F.,.F.,{ cQrySC9 , 1 })
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Chamada para integracao com o modulo ACD - Faz filtro do PV na geracao da nota. ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If lIntACD
			cFilSC9 += ".And."+CBM460FIL()
		EndIf
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Pontos de Entrada					                                   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If ( aEntry[EP_M460FIT] )
			cFilSC9 += ".And."+ExecTemplate("M460FIL",.F.,.F.)
		EndIf

		If ( aEntry[EP_M460FIL] )
			cFilSC9 += ".And."+ExecBlock("M460FIL",.F.,.F.)
		EndIf
		
		If ExistBlock("M460FILC9")
			cM460FC9 := ExecBlock( "M460FILC9", .F., .F., { cFilSC9 } )
			cFilSC9 := If( ValType(cM460FC9) == 'C' .AND. !Empty(cM460FC9), cM460FC9, cFilSC9 )
		EndIf
		
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Array com as cores que definem cada status no markbrowser³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		aCores := {	{'Empty(SC9->C9_BLEST)   .And. Empty(SC9->C9_BLCRED) .And. SC9->C9_BLWMS$"05,06,07,  "','ENABLE' },;	//Pedido de Venda liberado
					{'SC9->C9_BLEST=="10"    .And. SC9->C9_BLCRED=="10"  .And. SC9->C9_BLWMS$"05,06,07,  "','DISABLE'},;	//Pedido de Venda Faturado
					{'!(Empty(SC9->C9_BLEST) .And. Empty(SC9->C9_BLCRED) .And. SC9->C9_BLWMS$"05,06,07,  ")','BR_AZUL'}}	//Pedido de Venda com bloqueio
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Ponto de Entrada para alterar cores do Browse do Cadastro    ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If aEntry[EP_M461COR]
			aCores := ExecBlock("M461COR",.F.,.F.,aCores) 
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Realiza a Filtragem                                                     ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If lFilBrow
			bFiltraBrw := {|x| If(x==Nil, .T. ,{cFilSC9,cQrySC9,"","",aIndexSC9}) }
			bParBloco := {|x| AplicaFiltro() }
		Else
			bFiltraBrw := {|x| If(x==Nil,FilBrowse("SC9",@aIndexSC9,@cFilSC9),{cFilSC9,cQrySC9,"","",aIndexSC9}) }
			bParBloco := {|x| .T. }
		EndIf
		
		aFiltro := Eval(bFiltraBrw,1)

		SC9->(MsSeek(xFilial()))

		lInvMarc := MV_PAR04==1.And.MV_PAR03==1 //Opcao de trazer itens selecionados habilitada
		cMarca	:= GetMark(,"SC9","C9_OK")

        If lECommerce
        	MarkBrow("SC9","C9_OK","A460Avalia()",,lInvMarc,cMarca,,,,,"A460VERPRS('1','"+cMarca+"', "+ cValTochar(lInvMarc) + " )",bParBloco,,,aCores,,,cFilSC9)
        Else
	        MarkBrow("SC9","C9_OK","A460Avalia()",,lInvMarc,cMarca,,,,,,bParBloco,,,aCores,,,cFilSC9)
        EndIf

		dbSelectArea("SC9")
		RetIndex("SC9")
		dbClearFilter()
		aEval(aIndexSC9,{|x| Ferase(x[1]+OrdBagExt())})

		//Limpa o filtro dos agrupadores na saída da rotina
		If lAgrupad
			cQryUpd := "UPDATE "+RetSqlName("SC9")+" SET C9_FILAGRU = ' ' WHERE C9_FILAGRU = '"+cMarcaAgr+"'"
			TcSqlExec(cQryUpd)
		EndIf
	Else
		lContinua := .F.
	EndIf

	SetKey(VK_F12,Nil)
Else
	lContinua := .F.
EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Anula as variaveis staticas criadas pela funcao manfsinit               ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
MaNfsEnd()

Return( lContinua )

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³Ma460Pesq ³ Autor ³Eduardo Riera          ³ Data ³27.08.1999³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Tratamento do Filtro na Pesquisa da MarkBrowse              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nenhum                                                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³Nenhum                                                      ³±±
±±³          ³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³   DATA   ³ Programador   ³Manutencao Efetuada                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³               ³                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function Ma460Pesq()

AxPesqui()

Eval(bFiltraBrw)

Return( .T. )

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³Ma460Ordem³ Autor ³Eduardo Riera          ³ Data ³27.08.1999³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Permite alterar a Ordem de Geracao da Nota Fiscal de Saida  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³                                                            ³±±
±±³          ³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³   DATA   ³ Programador   ³Manutencao Efetuada                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³               ³                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/

Function Ma460Ordem()

Local aArea      := GetArea()
Local aAreaSC9   := SC9->(GetArea())
Local aAreaSIX   := SIX->(GetArea())
Local aOrdem     := {}
Local nOrdem     := 1
Local cResultado := ""

Local oDlg
Local oListBox
Local oBut1
Local oBut2
Local oBold

dbSelectArea("SIX")
dbSetOrder(1)
MsSeek("SC9")

dbEval({||aadd(aOrdem,Capital( SixDescricao() ) ) },;
	{|| !Empty(SixDescricao()) },;
	{|| SIX->INDICE=="SC9" },,,.T.)

DEFINE MSDIALOG oDlg TITLE cCadastro FROM 0,0 TO 264,478 OF oMainWnd	PIXEL

DEFINE FONT oBold NAME "Arial" SIZE 0, -13 BOLD

@  0, -25 BITMAP oBmp RESNAME "PROJETOAP" oF oDlg SIZE 55, 1000 NOBORDER WHEN .F. PIXEL

@ 03, 40 SAY STR0002 FONT oBold PIXEL  //"Ordem"

@ 14, 30 TO 16 ,400 LABEL '' OF oDlg PIXEL

@ 25, 40 LISTBOX oListBox VAR cResultado ITEMS aOrdem PIXEL SIZE 190, 80 OF oDlg MULTI

DEFINE SBUTTON oBut1 FROM 113, 169 TYPE 1 ACTION ( nOrdem := oListBox:nAt, oDlg:End() )  ENABLE of oDlg
DEFINE SBUTTON oBut2 FROM 113, 202 TYPE 2 ACTION ( oDlg:End() )  ENABLE of oDlg

ACTIVATE MSDIALOG oDlg CENTERED

If ( nOrdem <> 0 )
	nOrdNFS := nOrdem
EndIf

RestArea(aAreaSC9)
RestArea(aAreaSIX)
RestArea(aArea)

Return

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³Ma460Nota ³ Autor ³Eduardo Riera          ³ Data ³27.08.1999³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Rotina de Montagem das Notas Fiscais de Saida               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³                                                            ³±±
±±³          ³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³   DATA   ³ Programador   ³Manutencao Efetuada                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³               ³                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/

Function Ma460Nota(cAlias)

Local aArea    := GetArea()
Local lContinua := .T.
Local nOpcA    := 0
Local cSerie   := ""
Local nX		:= 0
Local aMsgHlp	:= {}
Local cHlp		:= ""
Local dDataMoe  := dDataBase
Local lUsaNewKey:= GetSX3Cache("F2_SERIE","X3_TAMANHO") == 14 // Verifica se o novo formato de gravacao do Id nos campos _SERIE esta em uso
Local cSerieId  := IIf( lUsaNewKey , SerieNfId("SF2",4,"F2_SERIE",dDataBase,A460Especie(cSerie),cSerie) , cSerie )
Local lFatByDAK := (FunName() == "MATA460B")
Local cTypeDoc	:= ""
Local lNewInvoic 	:= Iif(__RpoRelease >= '12.1.2410',;
						 tlpp.ffunc("backoffice.fat.documento.UsaNewInvoice") .And.;
						 tlpp.call('backoffice.fat.documento.UsaNewInvoice()'),.F.)


// Verifica se usuario alterou numero da nota fiscal quando MV_TPNRNFS == "3" (apenas para MV_ESTADO = "SC").
Private lMudouNum := .F.
Private cNumero   := ""
Private aPedDecret:= {}		//Decreto Nº 54.869, de 2 de outubro de 2009 do Estado de São Paulo

lMa460Nota := .T.

If !ctbValiDt( Nil, dDataBase, .T., Nil, Nil, { "FAT003" }, Nil )
	Return .F.
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Define variaveis de parametrizacao de lancamentos             ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ mv_par01 Mostra Lan‡.Contab     ?  Sim/Nao                         ³
//³ mv_par02 Aglut. Lan‡amentos     ?  Sim/Nao                         ³
//³ mv_par03 Lan‡.Contab.On-Line    ?  Sim/Nao                         ³
//³ mv_par04 Contb.Custo On-Line    ?  Sim/Nao                         ³
//³ mv_par05 Reaj. na mesma N.F.    ?  Sim/Nao                         ³
//³ mv_par06 Taxa deflacao ICMS     ?  Numerico                        ³
//³ mv_par07 Metodo calc.acr.fin    ?  Taxa defl/Dif.lista/% Acrs.ped  ³
//³ mv_par08 Arred.prc unit vist    ?  Sempre/Nunca/Consumid.final     ³
//³ mv_par09 Agreg. liberac. de     ?  Caracter                        ³
//³ mv_par10 Agreg. liberac. ate    ?  Caracter                        ³
//³ mv_par11 Aglut.Ped. Iguais      ?  Sim/Nao                         ³
//³ mv_par12 Valor Minimo p/fatu    ?                                  ³
//³ mv_par13 Transportadora de      ?                                  ³
//³ mv_par14 Transportadora ate     ?                                  ³
//³ mv_par15 Atualiza Cli.X Prod    ?                                  ³
//³ mv_par16 Emitir                 ?  Nota / Cupom Fiscal / DAV       ³
//³ mv_par17 Gera Titulo            ?  Sim/Nao                         ³
//³ mv_par18 Gera guia recolhimento ?  Sim/Nao                         ³
//³ mv_par19 Gera Titulo ICMS Próprio ?  Sim/Nao                       ³
//³ mv_par20 Gera Guia ICMS Próprio ?  Sim/Nao                         ³
//³ mv_par22 Gera Titulo por Pruduto?  Sim/Nao                         ³
//³ mv_par23 Gera Guia por Produto?  Sim/Nao                           ³
//³ mv_par24 Gera Guia ICM Compl. UF Dest.?		Sim/Nao 			³
//³ mv_par25 Gera Guia FECP da UF Destino?		Sim/Nao 			³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

If cPaisLoc == "BRA" .And. IsInCallStack("Ma460Nota")
	//Deixa o parâmetro com data base, para não gerar nota fiscal com cotação errada.
	SetMVValue("MT460A","MV_PAR21",cTod("//"))
EndIf

// Quando chamado do faturamento por carga para multiplas filiais, só pergunta na primeira vez
If lFatByDAK .And. FindFunction("Os460IsPgt") .And. !Os460IsPgt()
	Pergunte("MT460A", .F.)
	lContinua := .T.
Else
	lContinua := Pergunte("MT460A", .T.)
EndIf
If lContinua
	If mv_par16 == 2 .and. !aEntry[EP_M461IMPF]
		Help(NIL, NIL, "CUPOM", NIL, STR0121, 1, 0, NIL, NIL, NIL, NIL, NIL, {STR0122}) //"A geração de Cupom Fiscal foi descontinuada."##"Verifique os parâmetros para emissão de documento de saída."
		lContinua := .F.
	ElseIf mv_par16 == 3 .and. LjNfPafEcf(SM0->M0_CGC)
		//Para ambientes do tipo PAF-ECF, nao emite nota - apenas gera orcamento no loja (DAV)
		lContinua := MA461OrcLj()
	Else
		If lFatByDAK .And. FindFunction("OsNumNota")
			lContinua := OsNumNota(@cSerie,@cSerieId,dDataBase)
		Else
			If lNewInvoic
				lContinua := backoffice.fat.documento.TypeSerInvoice(@cSerie,@cTypeDoc)
			Else
				lContinua := Sx5NumNota(@cSerie,SuperGetMV("MV_TPNRNFS"),,,,@cSerieId,dDataBase, ,@cTypeDoc) // O parametro cSerieId deve ser passado para funcao Sx5NumNota afim de tratar a existencia ou nao do mesmo numero na funcao VldSx5Num do MATXFUNA.PRX
			EndIf
		EndIf
		If ( lContinua )
			If !lFatByDAK
				FormBatch(OemToAnsi(STR0005),;
					{OemToAnsi(STR0006),OemToAnsi(STR0007),OemToAnsi(STR0008)},;
					{  {5,.F.,{|o| o:oWnd:End()}           },;
					{1,.T.,{|o| nOpcA:=2,o:oWnd:End()}  },;
					{2,.T.,{|o| o:oWnd:End() }}         })
			Else
				nOpcA := 2
			EndIf
			If ( nOpcA == 2 )

				If ( AENTRY[EP_M460PROC] )
					ExecBlock("M460PROC",.F.,.F.,{ SC9->(IndexOrd())})
				EndIf
				If cPaisLoc == "BRA"
					dDataMoe := MV_PAR21
				Endif
				Processa({|lEnd| Ma460Proc(cAlias,;
					cSerie,;
					MV_PAR01==1,;
					MV_PAR02==1,;
					MV_PAR03==1,;
					MV_PAR04==1,;
					MV_PAR05==1,;
					MV_PAR07,;
					MV_PAR08,;
					MV_PAR09,;
					MV_PAR10,;
					MV_PAR11==1,;
					MV_PAR12,;
					MV_PAR13,;
					MV_PAR14,;
					MV_PAR15==1,;
					MV_PAR16==2,;
					c460Cond,@lEnd,dDataMoe,cTypeDoc)},,OemToAnsi(STR0009),.T.)     //"Prepara??o dos Doc's de Sa?da/Expedi??o "
				If ( AENTRY[EP_M460NOTA] )
					ExecBlock("M460NOTA",.F.,.F.,{cAlias})
				EndIf
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Exibe a uma mensagem para o usuário, informando os pedidos que não	³
					//³ foram faturados.													³
					//³ Decreto Nº 54.869, de 2 de outubro de 2009 do Estado de São Paulo	³
					//³ Atingido o valor máximo do cupom fiscal: 10.000,00.					³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If MV_PAR16==2 .And. Len(aPedDecret) > 0
						aMsgHlp := LjAnalisaLeg(51)
						cHlp := aMsgHlp[5] + CHR(10)
						cHlp += STR0082		//"Pedido(s): "
						For nX := 1 To Len(aPedDecret)
							If nX == 1
								cHlp += aPedDecret[nX]
							Else
								cHlp += ", " + aPedDecret[nX]
							EndIf
						Next nX
						aMsgHlp[5] := cHlp
						LjMsgLeg(aMsgHlp)
					EndIf
			EndIf
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Destrava o controle de numeracao                                        ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			SX5->(MsRUnLock())
		EndIf
	EndIf
Else
	lContinua := .F.
EndIf

RestArea(aArea)

Return( lContinua )

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³Ma460Proc ³ Autor ³Eduardo Riera          ³ Data ³28.08.1999³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Gauge de Processamento da Geracao da Nota Fiscal            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nenhum                                                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpC1: Alias da MarkBrowse                                  ³±±
±±³          ³ExpC2: Serie da Nota Fiscal a ser considerada               ³±±
±±³          ³ExpL3: Mostra Lanc.Ctb.                                     ³±±
±±³          ³ExpL4: Aglut.Lancamentos                                    ³±±
±±³          ³ExpL5: Lct.Ctb.On-Line                                      ³±±
±±³          ³ExpL6: Lct.Ctb.Custo On-Line                                ³±±
±±³          ³ExpL7: Reajusta na mesma nota                               ³±±
±±³          ³ExpN8: Calc.Acr.Fin                                         ³±±
±±³          ³ExpN9: Arred.Prc.Unit                                       ³±±
±±³          ³ExpCA: Agregador de Liberacao Inicial                       ³±±
±±³          ³ExpCB: Agregador de Liberacao Final                         ³±±
±±³          ³ExpLC: Aglutina Pedido Iguais                               ³±±
±±³          ³ExpND: Valor Minimo para faturamento                        ³±±
±±³          ³ExpNE: Transportadora Inicial                               ³±±
±±³          ³ExpNF: Transportadora Final                                 ³±±
±±³          ³ExpNG: Atualiza Amarracao Cliente x Produto                 ³±±
±±³          ³ExpNH: Cupom Fiscal                                         ³±±
±±³          ³ExpNI: Condicao a Ser Avaliada                              ³±±
±±³          ³ExpLJ: Flag de cancelamento do usuario                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³   DATA   ³ Programador   ³Manutencao Efetuada                          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³               ³                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß

/*/
Static Function Ma460Proc(cTabela,cSerie,lMostraCtb,lAglutCtb,lCtbOnLine,lCtbCusto,lReajusta,nCalAcrs,nArredPrcLis,cAgregI,cAgregF,lJunta,nFatMin,cTranspI,cTranspF,lAtuSA7,lECF,cCondicao,lEnd,dDataMoe,cTypeDoc)

Local aArea     := GetArea()
Local aAreaSC9  := SC9->(GetArea())
Local nItemNf   := a460NumIt(cSerie)
Local nPosKey   := 0
Local nCntFor   := 0
Local nTotal    := 0
Local nNrVend   := Fa440CntVen()
Local nPrcVen   := 0
Local cQrySC9   := ""
Local cKeySC9   := "C9_FILIAL+"
Local cAuxKey   := ""
Local cMarca    := ThisMark()
Local cCursor3  := "MA460PROC"
Local cVendedor := ""
Local cNota	    := ""
Local cTipo9    := ""
Local cPedido   := ""
Local cString   := ""
Local lInverte  := ThisInv()
Local lLibGrupo := SuperGetMv("MV_LIBGRUPO")=="S"
Local lFilBrow	:= SuperGetMV("MV_FTFB461",.F.,.F.)
Local lAtuEst   := .F.
Local lQuebra   := .F.
Local lConfirma := .T.
Local lExecuta  := .T.
Local lTxMoeda  := .F.
Local lAcima    := .F.
Local lTotZero  := .F.
Local lSemSaldo := .F.
Local lGeraVTot := .T.
Local aSemSaldo := {}
Local aTravas   := {}
Local aPvlNfs   := {}
Local aQuebra   := {}
Local aQuebra2  := {}
Local aQuebra3  := {}
Local aNfCodISS := {}
Local lCond9    := SuperGetMV("MV_DATAINF",.F.,.F.)
Local lDCLNew   := SuperGetMV("MV_DCLNEW",.F.,.F.)
Local lPedSemAd := .F.
Local aPedSemAd := {}
Local aPedAdt   := {}
Local lValidouAdt := .T.
Local nCnt      := 0
Local nAcresTot := 0
Local nPosAcres := 0
Local aAcresTot := {}
Local aAreaSC9Adt	:= {}
Local aAreaSC5Adt	:= {}
Local aAreaSC6Adt	:= {}
Local nPosAdt   := 0
Local lLeiSP    := .F.
Local lDataFin  := .F.
Local lNFZero   := .F.
Local lAGRUBS   := SuperGetMV("MV_AGRUBS",.F.,.F.)
Local lTrcNum   := IIf(lAGRUBS,SC5->(ColumnPos("C5_TRCNUM"))>0,.F.) //Campo da Agroindustria
Local lAgrMoeda := .F.
Local nM2MoeDec := 0
Local nAuxMoe   := 0
Local oFiltro	:= Nil
Local cAliasSC9  := "SC9"
Local lFatByDAK := (FunName() == "MATA460B")
Local nTotaPvlNfs := 0
Local lDtMovFin	:= .F.
Local lC5CodA1U	:= (SC5->(ColumnPos("C5_CODA1U")) > 0)	//Existe o campo do Código do Intermediador no Pedido de Venda (Campo inserido durante a Versão 12.1.27)
Local lRetornoDCL := .T.
Local lVldCompl	:= .F.
Local aFltrUsr	:= {} //Filtro de usuario na rotina
Local aTempStru	:= {}
Local aStruSC9	:= {}
Local nCposC9	:= 0

Default dDataMoe := dDataBase
Default cTypeDoc	 := ""


If lDCLNew .And. Findfunction("DCLMSGINT") 
	DCLMSGINT()
EndIF

If Valtype(aFiltro) == 'U' .Or. lFatByDAK
	aFiltro   := Eval(bFiltraBrw,1)
Endif
cQrySC9   := aFiltro[2]

If lFilBrow
	oFiltro:=GetMarkBrow()
	If !Empty(oFiltro)
		aFltrUsr := oFiltro:FWFilter():GetFilter(.F.)
		aFltrUsr := TrataFil(oFiltro) 
		cQrySC9 += aFltrUsr[2]
	EndIF
EndIf

If Empty(dDataMoe)
	dDataMoe := dDatabase
Endif

lCond9   := IIf(ValType(lCond9)<>"L",.F.,lCond9)

//Pontos de Entrada
If lDCLNew
	lExecuta := DCLM460MAR(ThisMark(),ThisInv())
Else
	If ( aEntry[EP_M460MARKT] )
		lExecuta := ExecTemplate("M460MARK",.F.,.F.,{ThisMark(),ThisInv()})
	EndIf
EndIf

If ( aEntry[EP_M460MARK] )
	lExecuta := ExecBlock("M460MARK",.F.,.F.,{ThisMark(),ThisInv(),cSerie,cQrySC9})
EndIf

If ( aEntry[EP_FATDOCSA] )
    lRetornoDCL := ExecTemplate("FATDOCSA",.F.,.F.,{ThisMark(),Nil})
    If !lRetornoDCL
        Return Nil
    EndIf
EndIf

If ( lExecuta )
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Verifica a data de execucao                                             ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If SuperGetMV("MV_NFCHGDT",,.F.)
		If MsDate()==dDataBase+1
			If Aviso( STR0034, STR0038, {STR0039,STR0040}, 2 )==1 //"O sistema identificou a troca da data do sistema operacional, deseja atualizar a data base do sistema?"###"Sim","Nao"
				dDataBase := MsDate()
			EndIf
		EndIf
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Inicializa a filtragem da MarkBrowse                                    ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If ( lInverte )
		cQrySC9    += " AND SC9.C9_OK<>'"+cMarca+"'"
	Else
		cQrySC9    += " AND SC9.C9_OK='"+cMarca+"'"
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Verifica qual a Ordem em que a NFS deve ser gerada                      ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	cKeySC9 += "C9_CARGA+C9_SEQCAR+"
	cKeySC9 += "C9_FILIAL+C9_AGREG+"
	If lJunta
		cKeySC9 += "C9_CLIENTE+C9_LOJA+"
	EndIf

	//Ao aglutinar pedidos iguais, é necessário que o ordem by respeite os itens que são verificados na aglutinação
	If lJunta
		cKeySC9   += "C5_TIPO+C5_CLIENTE+C5_LOJACLI+C5_TIPOCLI+C5_CLIENT+C5_LOJAENT+C5_REAJUST+C5_CONDPAG+C5_INCISS+C5_TRANSP+C5_TPFRETE+C5_FORNISS+C5_RECISS+C5_INDPRES+"
		cVendedor := "1"

		For nCntfor := 1 To nNrVend
			cKeySC9 += "C5_VEND" + cVendedor + "+"
			If SC5->( FieldPos( "C5_CODRL" + cVendedor ) ) > 0
				cKeySC9 += "C5_CODRL" + cVendedor + "+"
			EndIf
			cVendedor := Soma1( cVendedor , 1 )
		Next nCntFor

		If lC5CodA1U
			cKeySC9 += "C5_CODA1U+"
		EndIf
	EndIf

	If SuperGetMV("MV_NFEQUEB",,.F.)
		cKeySC9 += "C9_CODISS+"
	EndIf

	cKeySC9 += "C9_PEDIDO+"
	If ( lLibGrupo )
		cKeySC9 += "C9_GRUPO+"
	EndIf

	cKeySC9 += "C9_RETOPER+"

	dbSelectArea("SC9")
	dbSetOrder(nOrdNFS)
	cKeySC9 += IndexKey()
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Retira os itens duplicados da ordem de Geracao da NFS                   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	cAuxKey := cKeySC9
	cKeySC9 := ""
	While ( (nPosKey:=At("+",cAuxKey))<>0 )
		If ( !SubStr(cAuxKey,1,nPosKey-1)$cKeySC9 )
			cKeySC9 += "+"+SubStr(cAuxKey,1,nPosKey-1)
		EndIf
		cAuxKey := SubStr(cAuxKey,nPosKey+1)
	EndDo
	If ( !cAuxKey$cKeySC9 )
		cKeySC9 += "+"+cAuxKey
	EndIf
	cKeySC9 := SubStr(cKeySC9,2)
	If aEntry[EP_M460ORD]
		cKeySC9 := ExecBlock("M460ORD",.F.,.F.,cKeySC9)
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Realiza a Selecao do SC9 e da Tabela da Markbrowse se esta existir      ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

	cAuxKey := " AND " + cQrySC9
	cQrySC9 := ""
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Montagem dos campos do SC9                                              ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	dbSelectArea("SC9")
	For nCntFor := 1 To FCount()
		cQrySC9 += ","+FieldName(nCntFor)
	Next nCntFor
	Do Case
		Case "ORACLE"==Upper(TcGetDb())
			cQrySC9 := "SELECT DISTINCT /*+FIRST_ROWS*/ "+SubStr(cQrySC9,2)
		Case "CACHE"==Upper(TcGetDb())
			cQrySC9 := "SELECT "+SubStr(cQrySC9,2)
		OtherWise
			cQrySC9 := "SELECT DISTINCT "+SubStr(cQrySC9,2)
	EndCase
	cQrySC9 += ",SC9.R_E_C_N_O_ C9RECNO "
	cQrySC9 += ",SC5.R_E_C_N_O_ C5RECNO "
	cQrySC9 += ",SC6.R_E_C_N_O_ C6RECNO, SC6.C6_QTDENT, SC6.C6_QTDVEN "
	cQrySC9 += ",SE4.R_E_C_N_O_ E4RECNO "
	cQrySC9 += ",SB1.R_E_C_N_O_ B1RECNO "
	cQrySC9 += ",SB2.R_E_C_N_O_ B2RECNO "
	cQrySC9 += ",SF4.R_E_C_N_O_ F4RECNO "
	cQrySC9 += ",SF4.F4_ISS F4ISS, SF4.F4_QTDZERO, SF4.F4_ESTOQUE, SF4.F4_DUPLIC "
	If cPaisLoc == "BRA"
		cQrySC9 += ",SF4.F4_VLRZERO "
	EndIf
	cQrySC9 += ",SC5.C5_MOEDA "
	cQrySC9 += ",SC5.C5_DATA1 "
	If lTrcNum
		cQrySC9 += ",SC5.C5_TRCNUM "
	EndIf
	If cPaisLoc == "BRA"
		cQrySC9 += ",SC5.C5_TPCOMPL "
	EndIf
	If ( lJunta )
		cVendedor := "1"
		For nCntfor := 1 To nNrVend
			cQrySC9 += ",SC5.C5_VEND"+cVendedor
			If SC5->(FieldPos("C5_CODRL"+cVendedor)) > 0
				cQrySC9 += ",SC5.C5_CODRL"+cVendedor
			EndIf
			cVendedor := Soma1(cVendedor,1)
		Next nCntFor
		cQrySC9 += ",SC5.C5_TIPO,SC5.C5_CLIENTE,SC5.C5_LOJACLI,SC5.C5_TIPOCLI,SC5.C5_LOJAENT,SC5.C5_REAJUST,SC5.C5_CONDPAG,SC5.C5_INCISS,SC5.C5_TRANSP,SC5.C5_TPFRETE,SC5.C5_INDPRES,"
		cQrySC9 += "SC5.C5_CLIENT,"
		cQrySC9 += "SC5.C5_FORNISS,"
		cQrySC9 += "SC5.C5_RECISS,"
		cQrySC9 += "SE4.E4_TIPO,SB2.B2_LOCAL"
		If lC5CodA1U
			cQrySC9 += ",SC5.C5_CODA1U"
		EndIf
	Else
		cQrySC9 += ",SC5.C5_TIPO,SB2.B2_LOCAL"
	EndIf
	cQrySC9 += " FROM "
	If lFilBrow .And. Len(aFltrUsr) > 0 .And. !Empty(aFltrUsr[1])
		cQrySC9 += aFltrUsr[1]
	EndIf
	cQrySC9 += RetSqlName("SC9")+" SC9 ,"
	cQrySC9 += RetSqlName("SC5")+" SC5 ,"
	cQrySC9 += RetSqlName("SC6")+" SC6 ,"
	cQrySC9 += RetSqlName("SE4")+" SE4 ,"
	cQrySC9 += RetSqlName("SB1")+" SB1 ,"
	cQrySC9 += RetSqlName("SB2")+" SB2 ,"
	cQrySC9 += RetSqlName("SF4")+" SF4  "
	cQrySC9 += "WHERE "
	cQrySC9 += " SC9.C9_BLCRED='"+Space(Len(SC9->C9_BLCRED))+"'"
	cQrySC9 += cAuxKey + " "
	cQrySC9 += " AND SC9.C9_BLEST='"+Space(Len(SC9->C9_BLEST))+"'"
	cQrySC9 += " AND SC9.C9_BLWMS IN ('  ','05','06','07')"

	cQrySC9 += " AND SC9.C9_AGREG>='"+cAgregI+"'"
	cQrySC9 += " AND SC9.C9_AGREG<='"+cAgregF+"'"
	cQrySC9 += " AND SC9.D_E_L_E_T_=' ' "
	cQrySC9 += " AND SC5.C5_FILIAL='"+xFilial("SC5")+"'"
	cQrySC9 += " AND SC5.C5_NUM=SC9.C9_PEDIDO"
	cQrySC9 += " AND SC5.C5_TRANSP>='"+cTranspI+"'"
	cQrySC9 += " AND SC5.C5_TRANSP<='"+cTranspF+"'"
	cQrySC9 += " AND SC5.D_E_L_E_T_=' '"
	cQrySC9 += " AND SC6.C6_FILIAL='"+xFilial("SC6")+"'"
	cQrySC9 += " AND SC6.C6_NUM=SC9.C9_PEDIDO"
	cQrySC9 += " AND SC6.C6_ITEM=SC9.C9_ITEM"
	cQrySC9 += " AND SC6.C6_PRODUTO=SC9.C9_PRODUTO"
	cQrySC9 += " AND SC6.D_E_L_E_T_=' '"
	cQrySC9 += " AND SE4.E4_FILIAL='"+xFilial("SE4")+"'"
	cQrySC9 += " AND SE4.E4_CODIGO=SC5.C5_CONDPAG "
	cQrySC9 += " AND SE4.D_E_L_E_T_=' '"
	cQrySC9 += " AND SB1.B1_FILIAL='"+xFilial("SB1")+"'"
	cQrySC9 += " AND SB1.B1_COD=SC9.C9_PRODUTO"
	cQrySC9 += " AND SB1.D_E_L_E_T_=' '"
	cQrySC9 += " AND SB2.B2_FILIAL='"+xFilial("SB2")+"'"
	cQrySC9 += " AND SB2.B2_COD=SC9.C9_PRODUTO"
	cQrySC9 += " AND SB2.B2_LOCAL=SC9.C9_LOCAL"
	cQrySC9 += " AND SB2.D_E_L_E_T_=' '"
	cQrySC9 += " AND SF4.F4_FILIAL='"+xFilial("SF4")+"'"
	cQrySC9 += " AND SF4.F4_CODIGO=SC6.C6_TES"
	cQrySC9 += " AND SF4.D_E_L_E_T_=' '"
	cQrySC9 += " ORDER BY "+SqlOrder(cKeySC9)

	cQrySC9 := ChangeQuery(cQrySC9)

	dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQrySC9),cCursor3,.F.,.T.)
	
	aAdd(aStruSC9,SC9->(dbStruct()))
	For nCposC9 := 1 To Len(aStruSC9[1])
		If aStruSC9[1][nCposC9][2] <> "C"
			aAdd(aTempStru,aStruSC9[1][nCposC9])
		EndIf
	Next nCposC9
	aAdd(aTempStru,{FWSX3Util():GetFieldStruct( 'C6_QTDENT' )[1],;
					FWSX3Util():GetFieldStruct( 'C6_QTDENT' )[2],;
					FWSX3Util():GetFieldStruct( 'C6_QTDENT' )[3],;
					FWSX3Util():GetFieldStruct( 'C6_QTDENT' )[4]})
	aAdd(aTempStru,{FWSX3Util():GetFieldStruct( 'C6_QTDVEN' )[1],;
					FWSX3Util():GetFieldStruct( 'C6_QTDVEN' )[2],;
					FWSX3Util():GetFieldStruct( 'C6_QTDVEN' )[3],;
					FWSX3Util():GetFieldStruct( 'C6_QTDVEN' )[4]})
	
	aEval(aTempStru, {|x|, TcSetField(cCursor3,x[1],x[2],x[3],x[4])})

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Seta a regua de processamento das notas fiscais                         ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	ProcRegua((cTabela)->(LastRec()))
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Verifica as condicoes de quebra de nota fiscal                          ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	aadd(aQuebra,{"SC9->C9_CARGA",})
	aadd(aQuebra,{"SC9->C9_SEQCAR",})
	aadd(aQuebra,{"SC9->C9_AGREG",})
	If ( lJunta )
		aadd(aQuebra,{"SC5->C5_TIPO",})
		aadd(aQuebra,{"SC5->C5_CLIENTE",})
		aadd(aQuebra,{"SC5->C5_LOJACLI",})
		aadd(aQuebra,{"SC5->C5_TIPOCLI",})
		aadd(aQuebra,{"SC5->C5_CLIENT",})
		aadd(aQuebra,{"SC5->C5_LOJAENT",})
		aadd(aQuebra,{"SC5->C5_REAJUST",})
		aadd(aQuebra,{"SC5->C5_CONDPAG",})
		aadd(aQuebra,{"SC5->C5_INCISS",})
		aadd(aQuebra,{"SC5->C5_TRANSP",})
		aadd(aQuebra,{"SC5->C5_TPFRETE",})
		aadd(aQuebra,{"SC5->C5_FORNISS",})
		aadd(aQuebra,{"SC5->C5_INDPRES",})
		If lIsRussia
			aadd(aQuebra,{"SC5->C5_F5QCODE",})
		EndIf
		cVendedor := "1"
		For nCntfor := 1 To nNrVend
			aadd(aQuebra,{"SC5->C5_VEND"+cVendedor,})
			If SC5->(FieldPos("C5_CODRL"+cVendedor))>0
				aadd(aQuebra,{"SC5->C5_CODRL"+cVendedor,})
			EndIf
			cVendedor := Soma1(cVendedor,1)
		Next nCntFor
		aadd(aQuebra,{"SC5->C5_RECISS",})
		If lC5CodA1U
			aadd(aQuebra,{"SC5->C5_CODA1U",})
		EndIf
	Else
		aadd(aQuebra,{"SC9->C9_PEDIDO",})
	EndIf
	If SuperGetMV("MV_NFEQUEB",,.F.)
		aadd(aQuebra3,{"SC9->C9_CODISS",})
	Endif
	dbSelectArea("SA1")
	dbSetOrder(1)

	MsSeek(xFilial("SA1")+(cCursor3)->(C9_CLIENTE+C9_LOJA))

	aEval(aQuebra ,{|x| x[1]:= SubStr(x[1],6)})
	aEval(aQuebra2,{|x| x[1]:= SubStr(x[1],6)})
	aEval(aQuebra3,{|x| x[1]:= SubStr(x[1],6)})

	// Processa os itens do pedido
	dbSelectArea(cCursor3)
	If (cCursor3)->(!Eof())
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Atualiza os itens de Quebra                                             ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		aEval(aQuebra, {|x| x[2] := &(x[1])})
		aEval(aQuebra2,{|x| x[2] := &(x[1])})
		aEval(aQuebra3,{|x| x[2] := &(x[1])})
		lDtMovFin := !DtMovFin(,.F.)
		Do While (cCursor3)->(!Eof())
			lConfirma := .T.
			If !Empty(aQuebra3)
				If !Empty((cCursor3)->C9_CODISS)
					aAdd(aNfCodISS,(cCursor3)->C9_CODISS)
				EndIf
			EndIf
	
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Inicializa as variaveis de quebra do SC9                                ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			cPedido := (cCursor3)->C9_PEDIDO
			If lJunta
				cTipo9  := (cCursor3)->E4_TIPO
			Else
				SE4->( dbGoTo( (cCursor3)->E4RECNO ) )
				cTipo9 := SE4->E4_TIPO
			EndIf
	
			//PONTO PARA VERIFICAÇÃO DA AGROINDUSTRIA.
			//VERIFICA SE O PEDIDO VEM DE UMA TROCA PARA QUE A MOEDA DO DIA SEJA DESCONSIDERADA.
			If lAGRUBS .And. lTrcNum
				lAgrMoeda := !Empty((cCursor3)->C5_TRCNUM)
			EndIf
	
			// Verifica se bloqueia faturamento quando o 1o vencto < emissao da NF
			// na cond.pgto tipo 9. MV_DATAINF(T = Bloqueia , F = Fatura)
			// Bloqueia faturamento se a moeda nao estiver cadastrada
			nM2MoeDec := GetSX3Cache("M2_MOEDA" + AllTrim(Str((cCursor3)->C5_MOEDA)), "X3_DECIMAL")
			nAuxMoe   := xMoeda(1, (cCursor3)->C5_MOEDA, 1, dDataMoe, nM2MoeDec)
			If	( lCond9 .And. (cCursor3)->C5_DATA1 < (dtos(dDataBase)) .And. !Empty((cCursor3)->C5_DATA1) .And. cTipo9 == "9" ) .Or. (nAuxMoe == 0 .And. !lAgrMoeda)
				lConfirma:= .F.
				If	nAuxMoe == 0
					lTxMoeda := .T.
				EndIf
			EndIf
	
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ--¿
			//³ Verifica se data do movimento não é menor que data limite de   ³
			//³ movimentacao no financeiro configurada no parametro MV_DATAFIN ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ--Ù
			If (cCursor3)->F4_DUPLIC == "S" .And. lDtMovFin
				lDataFin := .T.
				lConfirma:= .F.
			EndIf
	
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³P.E . para exibir mensagem com motivo de não faturar de acordo com parametro MV_DATAINF³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If !(lConfirma) .And. lCond9 .And. aEntry[EP_M461DINF]
				ExecBlock( "M461DINF", .f., .f. )
			EndIf
	
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Avalia a Expressao cCondicao                                            ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If ( !Empty(cCondicao) )
				If ( !(&cCondicao) )
					lConfirma := .F.
				EndIf
			EndIf
	
			If ( lConfirma )
				lAtuEst   := (cCursor3)->F4_ESTOQUE=="S"
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Verifica se o produto está sendo inventariado  ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If lAtuEst .And. BlqInvent((cCursor3)->C9_PRODUTO,(cCursor3)->C9_LOCAL,,,(cCursor3)->C9RECNO)
					Help(" ",1,"BLQINVENT",,(cCursor3)->C9_PRODUTO+" Almox: "+(cCursor3)->C9_LOCAL,1,11)
					lConfirma := .F.
				EndIf
			EndIf
	
			If lConfirma .And. _lAcdFatOsep
				If !( AcdFatOsep( cAliasSC9,C5RECNO,(cCursor3)->C9_PEDIDO,(cCursor3)->C9_ITEM,(cCursor3)->C9_SEQUEN ) )
					lConfirma := .F.
				EndIf
			Endif
	
			If ( lConfirma )
				nPrcVen   := (cCursor3)->C9_PRCVEN
				aTravas   := {}
				lSemSaldo := .F.
				If ( C5_MOEDA <> 1 ) .And. !lAgrMoeda
					nPrcVen := xMoeda(nPrcVen,C5_MOEDA,1,dDataMoe,8)
				EndIf
				If nPrcVen <> 0 .Or. (cPaisLoc == "BRA" .And. nPrcVen == 0 .And. (cCursor3)->F4_VLRZERO == "1")
					If Ma461QIsOk(aPvlNfs,cCursor3,cCursor3) .And. A461Saldo(C9_PEDIDO,C9_ITEM,C9_PRODUTO,C9_LOCAL,C9_QTDLIB,C9_QTDLIB2,C9_LOTECTL,C9_NUMLOTE,@aTravas,@lSemSaldo,lAtuEst)
	
						// Nao permite D2_TOTAL zerado (quando utilziado D2_PRCVEN muito baixo, sistema estava
						// gravando D2_TOTAL zerado.
						lTotZero := .F.

						//Validação para verificar se o pedido de complemento de quantidade está utlizando a TES de valor zerado.
						lVldCompl := IIf( cPaisLoc<>"BRA", !((cCursor3)->C5_TIPO $ "CIP"), IIf((cCursor3)->C5_TIPO $ "IP" .Or.;
										 ((cCursor3)->C5_TIPO $ "C" .And. (cCursor3)->C5_TPCOMPL == "1"),.F.,.T.) )

						If lVldCompl .And. (cCursor3)->F4_QTDZERO <> "1" .And. a410Arred((cCursor3)->C9_QTDLIB*nPrcVen, "D2_TOTAL") == 0
							//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
							//Tratamento para quando for valor do item igual a zero permitido quando F4_VLRZERO = SIM³
							//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
							If cPaisLoc == "BRA" .And. !(cCursor3)->F4_VLRZERO == "1"
								lTotZero := .T.
							EndIf
							If !lTotZero
								lNFZero:= .T.
							EndIF
						EndIf
							
						If	!lTotZero
							aadd(aPvlNfs,{ C9_PEDIDO,;							//01
												C9_ITEM,;								//02
												C9_SEQUEN,;							//03
												C9_QTDLIB,;							//04
												nPrcVen,;								//05
												C9_PRODUTO,;							//06
												F4ISS=="S",;							//07
												C9RECNO,;								//08
												C5RECNO,;								//09
												C6RECNO,;								//10
												E4RECNO,;								//11
												B1RECNO,;								//12
												B2RECNO,;								//13
												F4RECNO,;								//14
												B2_LOCAL,;							//15
												0,;									//16 - Compatibilidade (Não Usado)
												C9_QTDLIB2})							//17
	
						Endif
					Else
						If lSemSaldo
							aAdd(aSemSaldo,{C9_PEDIDO,C9_ITEM,C9_SEQUEN})
						Else
							lAcima := .T.
						EndIf
					EndIf
				Else
					lTxMoeda := .T.
				EndIf
			EndIf
	
			(cCursor3)->( DBSkip() )
			IncProc(OemToAnsi(STR0010)+": "+cSerie+"/"+cNota) //"Preparados os Doc's: "
	
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Verifica a quebra                                                       ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			lQuebra := .F.
			If ( aScan(aQuebra,{|x| If(x[2] <> Nil,&(x[1])<>x[2],.F.) }) <> 0 )
				lQuebra := .T.
				// Quando faturamento por carga avalia se a carga possui a transportadora informada
				// para permitir juntar os pedidos mesmo que no pedido as transportadoras forem 
				// diferentes
				If lFatByDAK .And. OMSValQbrE(aQuebra,(cCursor3)->C9_CARGA)
					lQuebra := .F.
				EndIf
			ElseIf ( aScan(aQuebra2,{|x| If(x[2] <> Nil,&(x[1])<>x[2],.F.) }) <> 0 )
				lQuebra := .T.
			ElseIf ( aScan(aQuebra3,{|x| If(x[2] <> Nil,&(x[1])<>x[2].And.!Empty(&(x[1])).And.!Empty(x[2]),.F.) }) <> 0 ) .Or.;
						( If(!Empty(aNfCodISS).And.!Empty((cCursor3)->C9_CODISS),aScan(aNfCodISS,(cCursor3)->C9_CODISS) == 0,.F.) )
				//Quando nao for NF Conjugada faz a quebra pelo codigo do ISS
				aNfCodISS:= {}
				lQuebra  := .T.
			EndIf
	
			If ( lJunta )
				If ( (cCursor3)->E4_TIPO=="9" .Or. cTipo9=="9" )
					If cPedido <> (cCursor3)->C9_PEDIDO
						lQuebra := .T.
					EndIf
				EndIf
			EndIf
	
			If ( aEntry[EP_M460NITE] )
				nItemNf := ExecBlock("M460NITE",.F.,.F.,{Len(aPvlNfs),aPvlNfs})
			EndIf
	
			If ( Len(aPvlNfs) >= nItemNf )
				lQuebra := .T.
			EndIf
			
			If !lQuebra .And. ( aEntry[EP_M460QUEB] )
				lQuebra := ExecBlock("M460QUEB",.F.,.F.,{cCursor3,aPvlNfs})
			EndIf
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Atualiza os itens de Quebra                                             ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			aEval(aQuebra, {|x| x[2] := &(x[1])})
			aEval(aQuebra2,{|x| x[2] := &(x[1])})
			aEval(aQuebra3,{|x| x[2] := &(x[1])})
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Efetua a Geracao da Nfs                                                 ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			dbSelectArea(cCursor3)
			If lQuebra
				If Len(aTravas) > 0 
					MaDesTrava(aTravas)
					dbSelectArea(cCursor3)
				EndIf
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Verifica a quebra por numero de itens de nota fiscal                    ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				aEval(aPvlNfs,{|x| nTotal += a410Arred(If(x[4]<>0,x[4],1)*x[5],"D2_TOTAL")})
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Ponto de entrada para verificar o valor total da nota                   ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If aEntry[EP_M461VTOT]
					lGeraVTot := ExecBlock("M461VTOT",.F.,.F.,{nTotal,IIf(Len(aPvlNfs)>0,aPvlNfs[Len(aPvlNfs),11],0)})
					If ValType(lGeraVTot) <> "L"
						lGeraVTot := .T.
					Endif
				Endif
	
				If cPaisLoc $ "BRA|MEX" .And. Len(aPvlNfs) > 0 .And. (FunName()=="MATA460A" .Or. FunName()=="MATA460B")
					aAreaSC5Adt := SC5->(GetArea())
					SC5->(MsGoto(aPvlNfs[1][9]))	//Posiciona no recno da SC5 para validar condição de pagamento
					If A410UsaAdi(SC5->C5_CONDPAG)
						RestArea(aAreaSC5Adt)
						aAreaSC9Adt := SC9->(GetArea())
						aAreaSC5Adt := SC5->(GetArea())
						SC5->(MsGoto(aPvlNfs[1][9]))	//Posiciona no recno da SC5 para validar condição de pagamento
						aAreaSC6Adt := SC6->(GetArea())
						aPedAdt := {}
						/*
						Estrutura Array aPedAdt
							1 - C9_PEDIDO
							2 - C5_CONDPAG
							3 - C9_CLIENTE
							4 - C9_LOJA
							5 - TES do pedido gera duplicata
							6 - Moeda do Pedido
						*/
						nAcresTot := 0
						aAcresTot := {}
						nTotaPvlNfs := Len(aPvlNfs)
						For nCnt:=1 To nTotaPvlNfs
							SC9->(MsGoto(aPvlNfs[nCnt][8]))
							SC5->(MsGoto(aPvlNfs[nCnt][9]))
							SC6->(MsGoto(aPvlNfs[nCnt][10]))
							nPosAdt := aScan(aPedAdt,{|x| x[1]+x[2]+x[3]+x[4] = SC9->C9_PEDIDO+SC5->C5_CONDPAG+SC9->C9_CLIENTE+SC9->C9_LOJA})
							If nPosAdt = 0
								aAdd(aPedAdt,{SC9->C9_PEDIDO,SC5->C5_CONDPAG,SC9->C9_CLIENTE,SC9->C9_LOJA,AvalTes(SC6->C6_TES,,"S"),SC5->C5_MOEDA})
							Else
								If !aPedAdt[nPosAdt][5]
									aPedAdt[nPosAdt][5] := AvalTes(SC6->C6_TES,,"S")
								Endif
							Endif
							// calcula o acrescimo financeiro para os itens liberados deste pedido
							nAcresTot := MaAcreFinAdt(aPvlNfs,nCnt,MV_PAR05==1,dDataMoe)
							// gera array com valores de acrescimo para cada pedido
							nPosAcres := aScan(aAcresTot,{|x| x[1] = aPvlNfs[nCnt][1]})
							If nPosAcres = 0
								aAdd(aAcresTot,{aPvlNfs[nCnt][1],nAcresTot})
							Else
								aAcresTot[nPosAcres][2] += nAcresTot
							Endif
						Next nCnt
						RestArea(aAreaSC5Adt)
						RestArea(aAreaSC6Adt)
						RestArea(aAreaSC9Adt)
						// avalia cada pedido em separado, para checar se hah algum adiantamento relacionado ao pedido
						For nCnt:=1 To Len(aPedAdt)
							If aScan(aPedSemAd,aPedAdt[nCnt][1]) <= 0
								If aPedAdt[nCnt][5] // somente valida valor do adiantamento se algum item liberado neste pedido tem TES que gera duplicata
									nAcresTot := aAcresTot[aScan(aAcresTot,{|x| x[1] = aPedAdt[nCnt][1]})][2]
									lPedSemAd := A461NAdian( aPedAdt[nCnt][1], aPedAdt[nCnt][2], aPvlNfs, .F., .F., aPedAdt[nCnt][3], aPedAdt[nCnt][4], {}, nAcresTot, aPedAdt[nCnt][6])
									If !lPedSemAd
										aAdd(aPedSemAd,aPedAdt[nCnt][1])
										lValidouAdt := .F.
										//Exit
									Else
										lValidouAdt := .T.
										Exit // se validou um pedido nao precisa validar o restante.
									Endif
								Endif
							Endif
						Next nCnt
					EndIf
				Endif
	
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Decreto Nº 54.869, de 2 de outubro de 2009 do Estado de São Paulo	   ³
				//³ Atingido o valor máximo do cupom fiscal: 10.000,00.					   ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				lLeiSP := .F.
				If lECF .And. nTotal > 10000 .And. LjAnalisaLeg(51)[1]
						aAdd(aPedDecret,cPedido)
						lLeiSP := .T.
				EndIf
				If ( (nTotal > nFatMin .Or. lNFZero).And. !Empty(aPvlNfs) .And. lGeraVTot .and. lValidouAdt .And. !lLeiSP )
					dbSelectArea("SC9")
					cNota := MaPvlNfs(aPvlNfs,cSerie,lMostraCtb,lAglutCtb,lCtbOnLine,lCtbCusto,lReajusta,nCalAcrs,nArredPrcLis,lAtuSA7,lECF,,,,,,dDataMoe,lJunta,cTypeDoc)
				EndIf
				nTotal  := 0
				aPvlNfs := {}
				aNfCodISS := {}
				lValidouAdt := .T.
	
			EndIf
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Remove travas dos registros utilizados                  ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			MaDesTrava(aTravas)
			dbSelectArea(cCursor3)
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Controle de cancelamento do usuario                                     ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If lEnd
				Exit
			EndIf
		EndDo
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Restaura a entrada da rotina                                            ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	(cCursor3)->( DBCloseArea() )
	DBSelectArea("SC9")
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Tratamento de mensagens                                                 ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lTxMoeda
	Aviso(STR0018,STR0019,{STR0021}) //"Mensagens"###"Alguns pedidos nao foram gerados pois nao existe taxa para a moeda"
EndIf
If lAcima
	Aviso(STR0018,STR0031,{STR0021}) //"Mensagens" //"Alguns itens dos pedidos nao foram gerados pois a Qtd.Vendida e menor que a liberada!"
EndIf
If lTotZero
	Aviso(STR0018,STR0049,{STR0021}) //"Mensagens" //"Alguns itens dos pedidos nao foram gerados pois o valor total do item esta igual a zero"
EndIf
If lSemSaldo
	cString += STR0053+Chr(13)+Chr(10)+Chr(13)+Chr(10) //"Os itens abaixo não foram gerados devido a falta de quantidade disponivel do produto em estoque. Verificar o saldo disponivel em estoque para os itens abaixo: "
	For nCntFor := 1 To Len(aSemSaldo)
		cString += STR0054 + aSemSaldo[nCntFor,1] + " / " + STR0055 + aSemSaldo[nCntFor,2] + " / " + STR0056 + aSemSaldo[nCntFor,3] + Chr(13)+Chr(10) //"Nro.Pedido: " ###### "Item : " ### "Sequencia: " ###
	Next nCntFor
	Aviso(STR0018,cString,{STR0021}) //"Mensagens"
EndIf
If lDataFin
	Aviso(STR0018,STR0086,{STR0021})	//"Alguns itens não foram gerados, pois não são permitidas movimentações financeiras com datas menores que a data limite de movimentações no Financeiro. Verificar o parâmetro MV_DATAFIN."
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Restaura a entrada da rotina                                            ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
RestArea(aAreaSC9)
RestArea(aArea)

If oQrySD9 != Nil
	oQrySD9:Destroy()
	oQrySD9 := Nil 
EndIf

Return( Nil )


/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³MaPvlNfs  ³ Autor ³Eduardo Riera          ³ Data ³28.08.1999³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Inclusao de Nota fiscal de Saida atraves do PV liberado     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpA1: Array com os itens a serem gerados                   ³±±
±±³          ³ExpC2: Serie da Nota Fiscal                                 ³±±
±±³          ³ExpL3: Mostra Lct.Contabil                                  ³±±
±±³          ³ExpL4: Aglutina Lct.Contabil                                ³±±
±±³          ³ExpL5: Contabiliza On-Line                                  ³±±
±±³          ³ExpL6: Contabiliza Custo On-Line                            ³±±
±±³          ³ExpL7: Reajuste de preco na nota fiscal                     ³±±
±±³          ³ExpN8: Tipo de Acrescimo Financeiro                         ³±±
±±³          ³ExpN9: Tipo de Arredondamento                               ³±±
±±³          ³ExpLA: Atualiza Amarracao Cliente x Produto                 ³±±
±±³          ³ExplB: Cupom Fiscal                                         ³±±
±±³          ³ExpCC: Numero do Embarque de Exportacao                     ³±±
±±³          ³ExpBD: Code block para complemento de atualizacao dos titu- ³±±
±±³          ³       los financeiros.                                     ³±±
±±³          ³ExpBE: Code block para complemento de atualizacao dos dados ³±±
±±³          ³       apos a geracao da nota fiscal.                       ³±±
±±³          ³ExpBF: Code Block de atualizacao do pedido de venda antes   ³±±
±±³                  da geracao da nota fiscal                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³   DATA   ³ Programador   ³Manutencao Efetuada                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³16/05/07  |Norbert Waage  ³Bops 125161:Altera status do orcamento do   ³±±
±±³          ³               ³Televendas (SIGATMK) apos a geracao da NF.  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function MaPvlNfs(aPvlNfs,cSerieNFS,lMostraCtb,lAglutCtb,lCtbOnLine,lCtbCusto,lReajuste,nCalAcrs,nArredPrcLis,lAtuSA7,lECF,cEmbExp,bAtuFin,bAtuPGerNF,bAtuPvl,bFatSE1,dDataMoe,lJunta,cTypeDoc)

Static lM460Num
Local aMults    := {}
Local aCopia    := {}
Local aPedido   := {}
Local cNumNFS   := ""
Local cArquivo  := ""
Local nHdlPrv   := 0
Local nLctTotal := 0
Local nX        := 0
Local nY        := 0
Local nOpcA     := 0
Local nPvlNFs   := Len(aPvlNfs[1])
Local lContinua := .T.
Local lLct610   := .F.
Local lLct611   := .F.
Local lLct613   := .F.
Local lLct620   := .F.
Local lIntACD	:= SuperGetMV("MV_INTACD",.F.,"0") == "1"
Local oList
Local oDlg
Local cTpNrNfs  := SuperGetMV("MV_TPNRNFS")
Local lErroGFE 	:= .F.
Local cFatGFE 	:= SuperGetMv("MV_FATGFE",.F.,"2")
Local lTrava	:= .T.
Local lTravaSB2	:= .T.
Local nNFS36	:= SuperGetMV("MV_NFS36", .F.,3)
Local lUsaNewKey:= GetSX3Cache("F2_SERIE","X3_TAMANHO") == 14 // Verifica se o novo formato de gravacao do Id nos campos _SERIE esta em uso
Local cSerieId  := IIf( lUsaNewKey , SerieNfId("SF2",4,"F2_SERIE",dDataBase,A460Especie(cSerieNFS),cSerieNFS) , cSerieNFS )
Local cFunName  := FunName()
Local cM461TRV 	:= SupergetMv("MV_FATTRAV",.F.,"") // Desabilita o MultLock dos registros 1= SA1 2= SA2 3= SB2 4= Todos para NF utilizado apenas 3 ou 4
Local nMVDelPVL	:= SuperGetMV("MV_DEL_PVL")
Local cQuery := ""
Local aFlagCTB := {}
Local lUseRISK := lRiskIsAtv .And. RskIsActive()
Local lNFS_JOB := SuperGetMV("MV_NFS_JOB",,.F.)
Local lNewInvoic	:= Iif(__RpoRelease >= '12.1.2410',;
						 tlpp.ffunc("backoffice.fat.documento.UsaNewInvoice") .And.;
						 tlpp.call('backoffice.fat.documento.UsaNewInvoice()'),.F.)

Private aNatRend   := Array(4) //Variavel da Natureza de Rendimento - REINF
Private lUsaFKW    := (cPaisLoc == "BRA" .And. ChkFile("FKW") .And. FindFunction("A461FKW"))//Validacoes para gravacao na FKW - REINF

Default bAtuPGerNF := {||}
Default bAtuPvl    := {||}
Default bFatSE1    := {|| .T. }
DEFAULT lM460Num   := ExistBlock("M460NUM",.F.,.F.)
Default dDataMoe   := dDatabase
Default lJunta	   := .F. 
Default lECF	   := .F.
Default cTypeDoc	   := ""

If lECF .And. !IsInCallStack('GerDocNf') //Sempre será falso com exceção das chamadas do GTPJBPE e GTPJBPR # Se ja for falso não ha necessidade de executar a pilha para fins de performance
	lECF := .F. 
EndIf

//Valida a data da LIB para utilização na Telemetria
If FatLibMetric()
	//Telemetria - MV_NFS_JOB - Atualização tardia de Estoque
	FwCustomMetrics():setUniqueMetric("MATA461","faturamento-protheus_utilizacao-tardia-estoque_total",IIf(lNFS_JOB,".T.",".F."),/*dDateSend*/,/*nLapTime*/,"FATXJOB")
EndIf

If Empty(dDataMoe)
	dDataMoe := dDatabase
Endif

// atualiza a variavel database do smartclient baseado na data do servidor
// Sendo:
//		1 - Atualiza somente os usuarios que tiverem o acesso 36-Alterar a Database DESABILITADO
//		2 - Sempre atualiza
//		3 - Mantem a database, isto é, não atualiza.
//
If nNFS36 == 1
	FwDateUpd(.T.,.T.)
ElseIf nNFS36 == 2
	FwDateUpd(.F.,.T.)
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Carga das Variaveis Staticas do Programa                                ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If Len(aEntry) == 0
	MaNfsInit()
Else
	MaFisEnd()
EndIf

If !lMa460Nota //Se for chamada do Ma460Nota o help já foi apresentado
	Pergunte("MT460A",.F.)
	If mv_par16 == 2 .and. !aEntry[EP_M461IMPF]
		Help(NIL, NIL, "CUPOM", NIL, STR0121, 1, 0, NIL, NIL, NIL, NIL, NIL, {STR0122}) //"A geração de Cupom Fiscal foi descontinuada."##"Verifique os parâmetros para emissão de documento de saída."
		lContinua := .F.
	EndIf
EndIf	
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Compatibilizacao do Array aPvlNFS                                       ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lContinua .And. nPvlNFs < 17
	For nX := 1 To Len(aPvlNfs)
		aadd(aCopia,{})
		For nY := 1 To Len(aPvlNfs[nX])
			aadd(aCopia[nX],aPvlNfs[nX][nY])
		Next nY
		nY := Len(aCopia[nX])
		If nY < 17
			For nY := nY  To 17
				Do Case
				Case nY == 14
					aadd(aCopia[nX],"")
				OtherWise
					aadd(aCopia[nX],0)
				EndCase
			Next nY
		EndIf
	Next nX
	aPvlNfs := aClone(aCopia)
	aCopia  := {}
EndIf
If lContinua
	//³Tratamento de DEAD-LOCK
	If !lNFS_JOB
		For nX := 1 to Len(aPvlNfs)
			If aScan(aMults,aPvlNfs[nX,6]+aPvlNfs[nX,15])==0
				AADD(aMults,aPvlNfs[nX,6]+aPvlNfs[nX,15])
			EndIf
		Next nX

		If aEntry[EP_M461TRV]
			lTravaSB2 := ExecBlock("M461TRV",.F.,.F.)
		Else
			//Na NF valida apenas o destravamento da tabela SB2
			If (cM461TRV == "3" .Or. cM461TRV == "4")
				lTravaSB2 := .F.
			EndIf
		EndIf

		If lTravaSB2
			lTrava := MultLock("SB2",aMults,1)
		EndIf

		While !lTrava
			If !InTransact()
				SB2->(MsRUnLock())
				If Empty(aPedido)
					For nX := 1 To Len(aPvlNfs)
						If aScan(aPvlNfs,aPvlNfs[nX,1])==0
							aadd(aPedido,{aPvlNfs[nX,1],aPvlNfs[nX,2],aPvlNfs[nX,3]})
						EndIf
					Next nX
				EndIf
				DEFINE MSDIALOG oDlg TITLE OemToAnsi( STR0005 ) From 0,0 To 295,460 OF oMainWnd PIXEL
				@ 000,000 BITMAP oBmp RESNAME "LOGIN" oF oDlg SIZE 45,155 NOBORDER WHEN .F. PIXEL
				@ 010,050 SAY OemToAnsi(STR0012) PIXEL SIZE 200,009
				@ 020,050 SAY OemToAnsi(STR0013) PIXEL SIZE 200,009
				@ 035,050 LISTBOX oList FIELDS HEADER RetTitle("C9_PEDIDO"),RetTitle("C9_ITEM"),RetTitle("C9_SEQUEN") SIZE 145,110 Of oDlg PIXEL
				oList:SetArray( aPedido )
				oList:bLine := {|| {aPedido[oList:nAt,1],aPedido[oList:nAt,2],aPedido[oList:nAt,3]} }
				DEFINE SBUTTON FROM 035,200 TYPE 1 ACTION (oDlg:End()) ENABLE OF oDlg
				DEFINE SBUTTON FROM 050,200 TYPE 2 ACTION (nOpcA:=1,oDlg:End()) ENABLE OF oDlg
				ACTIVATE MSDIALOG oDlg CENTERED
				If nOpcA == 1
					lContinua := .F.
					Exit
				EndIf
			Else
				ConOut("WARNING: DEADLOCK CONTROL IS ON")
			EndIf
		EndDo
	Else
		lContinua := .T.
	EndIf
EndIf	
If lContinua
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Verifica o Fechamento do Estoque                                        ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If ( MVUlmes() >= dDataBase )
		Help ( " ", 1, "FECHTO" )
		lContinua := .F.
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Verifica o Fechamento do Fiscal                                         ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If ( !FisChkDt(dDataBase) )
		lContinua := .F.
	EndIf
EndIf

If lContinua
	// Se lMudouNum for .T. significa que o usuario alterou o numero da nota em MV_TPNRNFS == "3"
	// e o sistema deve respeitar o novo numero contido em cNumero (apenas para MV_ESTADO = "SC").
	If Type("lMudouNum") == "U"
		Private lMudouNum := .F.
	EndIf
	If lMudouNum .And. (cTpNrNfs == "3" .Or. cTpNrNfs == "2")
		cNumNFS  := cNumero
		// Se alterou o numero, sistema ir arespeitar novo numero informado para primeira nota, porem,
		// a partir da segunda nota o sistema buscara a numeracao normal a partir do SXE/SXF
		If cTpNrNfs == "2"
			lMudouNum := .F.
		EndIf
	ElseIf !aEntry[EP_M461SER] .And. cTpNrNfs <> "3" 	//Se utilizar o PE não executa a função, pois estava alterando a numeração da série posicionada na geração da nota.
		cNumNFS  := IIf(!lECF,NxtSX5Nota( cSerieNFS,.T.,cTpNrNfs,,,, cSerieId,,cTypeDoc),"") // O parametro cSerieId deve ser passado para funcao NxtSx5Nota afim de tratar a existencia ou nao do mesmo numero na funcao VldSx5Num do MATXFUNA.PRX
	EndIf

	If lM460Num .Or. aEntry[EP_M461SER]
		cNumero := cNumNFS

		PRIVATE cSerie  := cSerieNFS

	   If lM460Num
		  ExecBlock("M460NUM",.F.,.F.,aPvlNfs)
	   Elseif aEntry[EP_M461SER]
		  ExecBlock("M461SER",.F.,.F.,aPvlNfs) // PE criado para que o usuário controle a alteração da numeração, mas não troque o numero das série que não foi utilizada. O PE original foi mantido por legado
	   Endif
		cNumNFS   := cNumero
		cSerieNFS := cSerie
		cSerieId  := IIf( lUsaNewKey , SerieNfId("SF2",4,"F2_SERIE",dDataBase,A460Especie(cSerieNFS),cSerieNFS) , cSerieNFS )
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Verifica os Lancamentos contabeis                                       ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	_aDPrv461	:= {}
	If ( lCtbOnLine )
		lLct610 := VerPadrao("610")
		lLct611 := VerPadrao("611")
		lLct613 := VerPadrao("613")
		lLct620 := VerPadrao("620")
	EndIf
	If ( lLct610 .Or. lLct620 .Or. lLct611 .Or. lLct613)
		PRIVATE cLote
		LoteCont("FAT")
		If IsInCallStack("Ma410PvNfs")
			SetFunName("MATA410")
			nHdlPrv := HeadProva(cLote /*cLote*/,;
			                     "MATA460" /*cPrograma*/,;
			                     cUserName /*cOperador*/,;
			                     @cArquivo /*cArquivo*/,;
			                     /*lCria*/,;
			                     @_aDPrv461 /*aDadosProva*/)
			SetFunName(cFunName)
		Else
			nHdlPrv := HeadProva(cLote /*cLote*/,;
			                     "MATA460" /*cPrograma*/,;
			                     cUserName /*cOperador*/,;
			                     @cArquivo /*cArquivo*/,;
			                     /*lCria*/,;
			                     @_aDPrv461 /*aDadosProva*/)
		EndIf
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Inicializa a gravacao dos lancamentos do SIGAPCO          ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	PcoIniLan("000101")

	Begin Transaction
		// Obtem numero do documento dentro da transacao
		If cTpNrNfs == "3"
			If (!lM460Num .Or. Empty(cNumNFS))
				// Se cNumNFS estiver preenchido significa que o usuario alterou o numero da nota em MV_TPNRNFS == "3"
				// e o sistema deve respeitar o novo numero
				cNumNFS:=MA461NumNf(.T.,cSerieNFS,cNumNFS,lECF,cSerieId,cTypeDoc)
				// Se alterou o numero, sistema irá respeitar novo numero informado para primeira nota, porem,
				// a partir da segunda nota o sistema buscara a numeracao normal a partir do SD9
				lMudouNum := .F.
			EndIf
		EndIf
		MaPvlNfs2(aPvlNfs,cSerieNFS,cNumNFS,lLct610,lLct611,lLct620,@nLctTotal,@nHdlPrv,lReajuste,nCalAcrs,nArredPrcLis,lAtuSA7,lECF,cEmbExp,bAtuFin,bAtuPvl,bFatSE1,dDataMoe,lLct613,@aFlagCTB,lJunta)
		Eval( bAtuPGerNF ) //-- Atualiza dados apos a geracao da nota fiscal

		//
		// Template GEM - Gestao de empreendimentos imobiliarios
		// Grava os contratos de empreendimentos
		//
		If ExistTemplate("GEMXGRCON",,.T.)
			ExecTemplate("GEMXGRCON",.F.,.F.,{aPvlNfs,cNumNFS,cSerieNFS})
		EndIf

		//-- Integração Protheus x GFE (INCLUSAO)
		If !MATA461IPG(cNumNFS,cSerieNFS)
			//Indica se a geração de Nota Fiscal é interrompida quando
			//ocorre erro de validação na integração com o GFE.

			If cFatGFE $ "1S"
				DisarmTransaction()
				lErroGFE := .T.
			EndIf
		EndIf

		/* Integração RISK - TOTVS Mais Negócios
		Se a integração com o RISK estiver habilitada, grava as informações da nota nas tabelas do RISK*/
		If !lErroGFE .And. lUseRISK
			lContinua := RskNFSInsert( SF2->F2_FILIAL + SF2->F2_DOC + SF2->F2_SERIE + SF2->F2_CLIENTE + SF2->F2_LOJA )

			If lContinua 
				lContinua := RskNFSTicket( SF2->F2_FILIAL, SF2->F2_DOC, SF2->F2_SERIE )  
			EndIf

			If !lContinua
				DisarmTransaction()    
			EndIf
		EndIf

		// ======================================================================
		// Integração GRR - Gestão de Receita Recorrente 
		// Gera os títulos financeiros relacionados ao processo do GRR quando o 
		// pedido não for do tipo B2B.
		// ======================================================================
		If FindFunction( "GRRIsActive" ) .And. FindFunction( "GRRProcNFS" ) .And. FindFunction( "GRRInvGenerate" ) ;
			.And. GRRIsActive() .And. GRRInvGenerate( SC5->C5_CONDPAG ) != '2'
				lContinua := GRRProcNFS( SF2->F2_FILIAL + SF2->F2_DOC + SF2->F2_SERIE + SF2->F2_CLIENTE + SF2->F2_LOJA )
				If !lContinua  
					DisarmTransaction()         
				EndIf  
		EndIf 
	End Transaction

	If !lErroGFE
		While __lSx8
			ConfirmSx8()
		EndDo
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Contabiliza os Lancamentos Contabeis                                    ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If ( nLctTotal <> 0 )
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Retirado controle de transação deste ponto , este controle
			//  é já está dentro da função cA100Incl.
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			RodaProva(nHdlPrv,nLctTotal)
			//Variável aFlagCTB contém os dados dos lctos (SD2/SF2) que serão
			//gravados dentro da função CA100Incl sem precisar dar ReckLock
			Aadd(aFlagCTB,{"F2_DTLANC",dDataBase,"SF2",SF2->(Recno()),0,0,0})
			cA100Incl(cArquivo,nHdlPrv,3,cLote,lMostraCtb,lAglutCtb,,,,aFlagCTB)
		EndIf
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Finaliza a gravacao dos lancamentos do SIGAPCO            ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		PcoFinLan("000101")

		aPedido := {}
		For nX := 1 To Len(aPvlNfs)
			If aScan(aPedido,aPvlNfs[nX,1])==0
				aAdd(aPedido,aPvlNfs[nX,1])
			EndIf
		Next nX
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Atualiza o orcamento do Televendas, se foi originado a partir³
		//³dele no modulo Call Center (SIGATMK)                         ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		For nX := 1 To Len(aPedido)
			TkAtuTlv(aPedido[nX],3,cNumNFS,cSerieId,dDataBase)
		Next nX

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Integracao com o modulo ACD - Analisa a rotina e o tipo da NF para verificar se faz o ³
		//³	acerto das tabelas para devolucao ou para NF normal		  							  ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If lIntACD
			CBM460FIM()
		EndIf

		If aEntry[EP_M460FIMT]
			ExecTemplate("M460FIM",.F.,.F.)
		EndIf

        //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
        //³ Agroindustria                                                                                                                                                           ³
        //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
        If _lOGXUtOrig //Encontra a função
        	If OGXUtlOrig() //Verifica se existe
        		If _lOGX155
        			OGX155()
        		EndIf
        	EndIf
        EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
        //³ AGRODISTRIBUIDOR                                                                                                                                                           ³
        //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If _lAGDI010 //Encontra a função
        	AGDI010()
        EndIf
		
		
	 	If AllTrim(Upper(SF2->F2_ESPECIE)) == "CTEOS" .And. FindFunction("G001INIGZH")
	 	    G001INIGZH(SF2->F2_DOC,SF2->F2_SERIE,SF2->F2_CLIENTE,SF2->F2_LOJA)
		EndIf
		
		If aEntry[EP_M460FIM]
			ExecBlock("M460FIM",.F.,.F.,{SF2->F2_DOC,SF2->F2_SERIE,SF2->F2_CLIENTE,SF2->F2_LOJA})
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Exclusao fisica dos itens de pedido de venda liberados                  ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		aPedido := {}
		For nX := 1 To Len(aPvlNfs)
			If aScan(aPedido,aPvlNfs[nX,1])==0
				aadd(aPedido,aPvlNfs[nX,1])
			EndIf
		Next nX

		If nMVDelPVL <> 3
			For nX := 1 To Len(aPedido)
				cQuery := "DELETE FROM "+RetSqlName("SC9")+" "
				cQuery += "WHERE C9_FILIAL='"+xFilial("SC9")+"' AND "
				cQuery += "C9_PEDIDO='"+aPedido[nX]+"' AND "
				If nMVDelPVL == 1
					cQuery += "((C9_BLCRED = '10' AND C9_BLEST='10') OR D_E_L_E_T_='*' )"
				Else
					cQuery += "D_E_L_E_T_='*' "
				EndIf
				TcSqlExec(cQuery)

				cQuery := "DELETE FROM "+RetSqlName("SDC")+" "
				cQuery += "WHERE DC_FILIAL='"+xFilial("SDC")+"' AND "
				cQuery += "DC_ORIGEM='SC6' AND "
				cQuery += "DC_PEDIDO='"+aPedido[nX]+"' AND "
				cQuery += "D_E_L_E_T_='*' "
				TcSqlExec(cQuery)
			Next nX
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Template GEM - Gestao de empreendimentos imobiliarios                   ³
		//³Tela de complemento de contrato permite visualizar os dados do contrato ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If ExistTemplate("GEMDlgCon",,.T.)
			ExecTemplate("GEMDlgCon",.F.,.F.,{aPvlNfs,cNumNFS,cSerieNFS})
		EndIf
		MaFisEnd()
	EndIf
	If lNewInvoic
		//Atualiza o status no controle de numeração 
		backoffice.fat.documento.UnLockInvoice()
	EndIf
EndIf

Return( cNumNFS )

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³MaPvlNfs2 ³ Autor ³Eduardo Riera          ³ Data ³28.08.1999³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Inclusao de Nota fiscal de Saida atraves do PV liberado     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpA1: Array com os itens a serem gerados                   ³±±
±±³          ³ExpC2: Serie da Nota Fiscal                                 ³±±
±±³          ³ExpC3: Numero da Nota Fiscal                                ³±±
±±³          ³ExpL4: Lancamento 610                                       ³±±
±±³          ³ExpL5: Lancamento 611                                       ³±±
±±³          ³ExpL6: Lancamento 620                                       ³±±
±±³          ³ExpN7: Controle de contabilizacao                           ³±±
±±³          ³ExpN8: Handle do arquivo de contabilizacao                  ³±±
±±³          ³ExpL9: Reajuste de preco na nota fiscal                     ³±±
±±³          ³ExpNA: Tipo de Acrescimo Financeiro                         ³±±
±±³          ³ExpNB: Tipo de Arredondamento                               ³±±
±±³          ³ExpLC: Atualiza Amarracao Cliente x Produto                 ³±±
±±³          ³ExplD: Cupom Fiscal                                         ³±±
±±³          ³ExpCE: Numero do Embarque de Exportacao                     ³±±
±±³          ³ExpBF: Code block para complemento de atualizacao dos titu- ³±±
±±³          ³       los financeiros.                                     ³±±
±±³          ³ExpBG: Code Block de atualizacao do pedido de venda antes   ³±±
±±³          ³       da geracao da nota fiscal                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³   DATA   ³ Programador   ³Manutencao Efetuada                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³               ³                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function MaPvlNfs2(aPvlNfs,cSerie,cNumero,lLct610,lLct611,lLct620,nLctTotal,nHdlPrv,lReajuste,nCalAcrs,nArredPrcLis,lAtuSA7,lECF,cEmbExp,bAtuFin,bAtuPvl,bFatSE1,dDataMoe,lLct613,aFlagCTB,lJunta,cTypeDoc)

Local aArea      := GetArea()
Local aAreaSC9   := SC9->(GetArea())
Local aPedido    := {}
Local aRateio    := {}
Local aRetImpFi  := {}
Local aTitulo    := { 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0, 0, 0, 0, 0, 0 ,0, 0, 0}
Local aCarga     := {}
Local aNfOriLot  := {}
Local aGNRE      := {}
Local aRecTit    := {}
Local aDatas     := {}
Local aDSF2      := {}
LOcal aGnreProd  := {}
Local aGnreDifal := {}
Local aGnreFecp  := {}
Local aGnreConv	 := {}
Local aGnreFpSt	 := {}
Local dDtIni     := Ctod("//")
Local dDtFim     := Ctod("//")
Local dDtVenc    := Ctod("//")
Local nValNeg    := 0
Local nItValNeg  := 0
Local nAcValNeg  := 0
Local nCntFor    := 0
Local nX         := 0
Local nTotal     := 0
Local nScan      := 0
Local nMoeda     := 0
Local nRatDesp   := 0
Local nRatFrete  := 0
Local nRatSeg    := 0
Local nRateio    := 0
Local nFrete     := 0
Local nVlr_Frt   := 0
Local nFretAut   := 0
Local nSeguro    := 0
Local nDespesa   := 0
Local nDesconto  := 0
Local nFrete2    := 0
Local nVlr_Frt2  := 0
Local nFretAut2  := 0
Local nSeguro2   := 0
Local nDespesa2  := 0
Local nDesconto2 := 0
Local nMes       := 0
Local nAno       := 0
Local nVlrIcm    := 0
Local nVlrIcmST  := 0
Local nVFecpST   := 0
Local nValFcpSt	 := 0
Local nVDifal	 :=0
Local nVFCDif	 :=0
Local cItemNf    := "01"
Local cBanco     := ""
Local cPdv	     := Space(10)
Local cLcPadTit  := ""
Local lLancCont  := .F.
Local lConfTit   := .F.
Local lTit       := .F.
Local lTitICMS   := .F.
Local lGDifal	 := .F.
Local lGFcpDif	 := .F.
Local lGRec    	 := .F.
Local lGRecICMS  := .F.
Local lCupFis    := .F.
Local lMoedaFre  := .F.
Local lContinua  := .T.
Local lIVAAju    := .F.  //Tratamento do calculo do IVA Ajustado
Local lGRecProd  := .F.
Local lTitProd   := .F.
Local cCgc	     := ""
Local cEstSum	 := ""
Local nPosItem 	 := 0
Local cAliq 	 := ""
Local nPos	     := 0
Local aSxFci	 := A461RetCFci(,1)
Local cMvFisCTrb := SuperGetMv("MV_FISCTRB",.F.,"1")    // método de consulta do percentual de carga tributária.Informe 1 para tratamento legado ou 2 alíquotas da Nota Fiscal e CGA/CGB - #conteudo gravado no campo D2_TIPIMP - Lei da transparência

Local nFretAux	:= 0
Local nSeguAux	:= 0
Local nDespAux	:= 0
Local nDifFre	:= 0
Local nDifSeg	:= 0
Local nDifDes	:= 0
Local lDespUtil	:= .F.
Local nPosPed 	:= 0
Local nTotItens := 0

Local cMV_B1M996	:=	SuperGetMV("MV_B1M996", , "")
Local cB1M996		:=	""
Local cB1FRETISS := ""

Local aAreaSED   := {}
Local aAreaSA2   := {}
Local aDadosAut  := {}
Local cNatureza  := ""
Local cCodForTit := ""
Local dVenFun    := ""
Local nTamData   := 0
Local cTamNatur  := GetSx3Cache("ED_CODIGO","X3_TAMANHO")
Local lIcmsSt  := .F.
Local lFecopSt := .F.
Local lFcopDif := .F.

//Gestao de contratos - SIGAGCT
Local aContrato  := {}
Local aMedicao   := {}

//Tratamento diferenciado na geracao do SE1 (MV_TMSMFAT)
Local lFatSE1    := .T.
Local cTMSMFat	:= SuperGetMv("MV_TMSMFAT")
Local cTMSERP	:= SuperGetMv("MV_TMSERP",,"0")

Local cAlias   := ""
Local cQuery   := ""

Local cTpNrNfs	 := SuperGetMV("MV_TPNRNFS")
Local lMvAtuComp := SuperGetMV("MV_ATUCOMP",,.F.)

//Tratamento para geracao da guia de recolhimento ICMS-ST
Local nValICMSST := 0
Local aAtuSC5 := Array(0)
Local aRecSE1Adt := Array(0)
Local aAcresTot := {}
Local nCnt := 0
Local nAcresTot := 0
//Tratamento para geracao da guia de recolhimento ICMS Proprio
Local nValICM := 0
Local nDedICM := 0
//Verifica se a funcionalidade Lista de Presente esta ativa e aplicada
Local lUsaLstPre	:= SuperGetMV("MV_LJLSPRE",,.F.) .And. LjUpd78Ok()

// Integração GFE
Local aStruModel  := {}
Local lIntGFE     := SuperGetMv("MV_INTGFE",,.F.)
Local nTotAcre	  := 0

Local aSL1		  := {}			// Array que contera dados para gravacao SL1 (Cabecalho do Orcamento)

Local lUsaNewKey:= GetSx3Cache("F2_SERIE","X3_TAMANHO") == 14 // Verifica se o novo formato de gravacao do Id nos campos _SERIE esta em uso
Local cSerieId  := IIf( lUsaNewKey , SerieNfId("SF2",4,"F2_SERIE",dDataBase,A460Especie(cSerie),cSerie) , cSerie )
Local nValProt 	:= 0
Local aTitCDA 	:= {}
Local cFilSL1		:= xFilial("SL1")
Local cFilSUA		:= xFilial("SUA")
Local cFilSU4		:= xFilial("SU4")
Local cFilSC5		:= xFilial("SC5")
Local cFilSC6		:= xFilial("SC6")
Local cFilSF4		:= xFilial("SF4")
Local cFilSB1		:= xFilial("SB1")
Local cFilSC9		:= xFilial("SC9")
Local cFilSD2		:= xFilial("SD2")
Local cFilSF2		:= xFilial("SF2")
Local cFilCFC		:= If(cPaisLoc == "BRA", xFilial("CFC"), "")
Local cQrySC9		:= ""
Local cTempSC9	:= ""
Local cTypeDB	:= Upper( TcGetDb() )
Local cConcat	:= IIf(cTypeDB $ "ORACLE,POSTGRES,DB2,INFORMIX","||","+")
Local lD2CtaRec := SD2->(ColumnPos("D2_CTAREC")) > 0 //Valida se o campo D2_CTAREC existe para gravar a Conta de Receita - EFD Contribuições
Local cCtaRec	:= "" //Conta de Receita do Item - EFD Contribuições
Local lNoCtaRef := Empty(MaFisScan("IT_CTAREC",.F.))

Local nAuxCalc	:= 0
Local nDSFrete	:= 0	//Sobras/Diferenças a partir da 3a. casa decimal no valor do Frete
Local nDSSeguro	:= 0	//Sobras/Diferenças a partir da 3a. casa decimal no valor do Seguro
Local nDSDespesa:= 0	//Sobras/Diferenças a partir da 3a. casa decimal no valor da Despesa
Local nDSDescont:= 0	//Sobras/Diferenças a partir da 3a. casa decimal no valor do Desconto
Local nDAFrete	:= 0	//Sobras/Diferenças Acumuladas a partir da 3a. casa decimal no valor do Frete
Local nDASeguro	:= 0	//Sobras/Diferenças Acumuladas a partir da 3a. casa decimal no valor do Seguro
Local nDADespesa:= 0	//Sobras/Diferenças Acumuladas a partir da 3a. casa decimal no valor do Despesa
Local nDADescont:= 0	//Sobras/Diferenças Acumuladas a partir da 3a. casa decimal no valor do Desconto
Local nValAv	:= 0
Local nSldLib 	:= 0
Local nMCusto 	:= 0
Local nMvMCusto	:=  Val(SuperGetMv("MV_MCUSTO"))

Local nISSNDesc := 0
Local nValISS   := 0
Local lDescISS	:= SuperGetMV("MV_DESCISS",,.F.)
Local lTpAbISS	:= SuperGetMV("MV_TPABISS",,"") == "1"
Local nVRetISS	:= SuperGetMV("MV_VRETISS",,0)
Local cTpRtDsp	:= SuperGetMV("MV_TPRTDSP",,"1")
Local lTpDpInd	:= SuperGetMV("MV_TPDPIND",,"1") == "2"
Local lTpLibPed	:= (cTpRtDsp == "1")
Local lMoedTit  := SuperGetMv("MV_MOEDTIT",,"N") == "S"
Local cMvEstado	:= SuperGetMV("MV_ESTADO")
Local lMTValAvC := ExistBlock("MTVALAVC")
Local lMazvstdf := ExistBlock("MAZVSTDF")
Local lTrbGen   := IIf(_lChkTrbGen, ChkTrbGen("SD2","D2_IDTRIB"), .F.)
Local aTGCalc	:= {}
Local aTGRet	:= {}
Local aTGCalcRet:= {}
Local aTGCalcRec:= {}
Local aRatFin   := {}

Local lTrvSA1   := .T.

// Integração EEC
Local lEECFat		:= SuperGetMV("MV_EECFAT")
Local lEEC0038		:= SuperGetMv("MV_EEC0038",,.F.)

Local cMVTmsGnre, cUFOrigem //--variáveis TMS - nModulo 43
Local nThreads   	:= SuperGetMv("MV_TMSTHRC", , 0) // Numero de threads para processamento simultaneos
Local nVlCRDTran    := 0

Local lRskSalPed	:= lRiskIsAtv .And. RskIsActive()
Local lMvLocBac		:= SuperGetMv("MV_LOCBAC",.F.,.F.) .And. FindFunction("LOCM003") //Integração com Módulo de Locações SIGALOC

Private lMsErroAuto := .F.

//Tratamento diferenciado na geracao do SE1 (MV_TMSMFAT)
Default bFatSE1		:= {|| .T. }
Default dDataMoe		:= dDataBase
Default lLct613		:= .F.
Default lJunta		:= .F.
Default cTypeDoc	:= ""

Default lECF		:= .F.

Default aNatRend	:= Array(4)

_nMovWMS := 0 //Variavel para controle de metrica WMS
//Arrays da Natureza de Rendimento - REINF
aNatRend[2] := {}
aNatRend[4] := {}

If Empty(dDataMoe)
	dDataMoe := dDatabase
Endif

lMoedaFre	:= SuperGetMv("MV_FRETMOE") == "S"
lCupFis	:= Alltrim(cSerie) == Alltrim(SuperGetMv("MV_SERCUP")) .And. aEntry[EP_M461IMPF] .And. lECF
nRatDesp	:= Val(SubStr(SuperGetMv("MV_RATDESP"),AT("DESP=",SuperGetMv("MV_RATDESP"))+5,1))
nRatFrete	:= Val(SubStr(SuperGetMv("MV_RATDESP"),AT("FR=",SuperGetMv("MV_RATDESP"))+3,1))
nRatSeg	:= Val(SubStr(SuperGetMv("MV_RATDESP"),AT("SEG=",SuperGetMv("MV_RATDESP"))+4,1))

//Valida a data da LIB para utilização na Telemetria
If FatLibMetric()
	//Telemetria - MV_RATDESP - Tipo de Rateio do Pedido de Venda
	FwCustomMetrics():setUniqueMetric("MATA461","faturamento-protheus_tipo-rateio-pedido-venda_total",A461VldRateio(nRatFrete,nRatSeg,nRatDesp),/*dDateSend*/,/*nLapTime*/,"MATA461")
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Calculo das despesas acessorias - Frete/Seguro/Despesas Acessorias      ³
//³                                                                        ³
//³- O Frete eh gravado no pedido de Venda, assim ele pode ser estar rela- ³
//³  cionado ao itens do pedido de venda ou aos itens liberados do pedido  ³
//³  de venda. O default eh para os itens liberados do pedido de venda.    ³
//³                                                                        ³
//³- O parametro responsavel por esta configuracao eh o MV_TPRTDSP que caso³
//³  seja configurado como 1, refere-se aos itens liberados e 2 aos itens  ³
//³  do pedido de venda.                                                   ³
//³                                                                        ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
For nCntFor := 1 To Len(aPvlNfs)
	If ( aScan(aPedido,{|y| y[1]==aPvlNfs[nCntFor,1]}) == 0 )
		aadd(aPedido,{aPvlNfs[nCntFor,1],"00","000",0,0,0,0,0,0,0,0,0,0,0,0,0,{0,0,0,0},0,0,0,0,0,0,0,0,0,0,0,0,0,.F.})
	EndIf
	nScan := Len(aPedido)
	If ( aPvlNfs[nCntFor][2] > aPedido[nScan][2] )
		aPedido[nScan][2] := aPvlNfs[nCntFor][2]
		aPedido[nScan][3] := aPvlNfs[nCntFor][3]
	EndIf
	If ( aPedido[nScan][2] == aPvlNfs[nCntFor][2] )
		aPedido[nScan][3] := If(aPvlNfs[nCntFor][3]>aPedido[nScan][3],aPvlNfs[nCntFor][3],aPedido[nScan][3])
	EndIf
Next nCntFor

If !lTpLibPed
	aSavRat := {}
EndIf

For nCntFor := 1 To Len(aPedido)

	dbSelectArea("SC5")
	dbSetOrder(1)
	MsSeek(cFilSC5+aPedido[nCntFor][1])
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Calculo das despesas acessorias - Frete/Seguro/Despesas Acessorias      ³
	//³                                                                        ³
	//³Verifica quanto das despesas já foi utilizado. Isto é necessário para o ³
	//³ajuste de centavos que deve ocorrer na ultima nota do pedido de venda.  ³
	//³                                                                        ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If ( lContinua )
		lContinua := SoftLock("SC5")
	EndIf
	If cTpRtDsp == "2"
		nScan := aScan(aSavRat,{|x| x[SV_PEDIDO]==aPedido[nCntFor][1]})
		If nScan == 0

			cAlias := GetNextAlias()

			cQuery := "SELECT DISTINCT D2_FILIAL,D2_DOC,D2_SERIE,D2_PEDIDO,F2_FRETE,F2_FRETAUT,F2_SEGURO,F2_DESPESA,F2_DESCCAB,F2_VLR_FRT "
			cQuery += "FROM "+RetSqlName("SF2")+" SF2,"
			cQuery += RetSqlName("SD2")+" SD2 "
			cQuery += "WHERE SD2.D2_FILIAL='"+cFilSD2+"' AND "
			cQuery += "SD2.D2_PEDIDO = '"+aPedido[nCntFor][1]+"' AND "
			cQuery += "SD2.D_E_L_E_T_=' ' AND "
			cQuery += "SF2.F2_FILIAL='"+cFilSF2+"' AND "
			cQuery += "SF2.F2_DOC = SD2.D2_DOC AND "
			cQuery += "SF2.F2_SERIE = SD2.D2_SERIE AND "
			cQuery += "SF2.F2_CLIENTE = SD2.D2_CLIENTE AND "
			cQuery += "SF2.F2_LOJA = SF2.F2_LOJA AND "
			cQuery += "SF2.D_E_L_E_T_= ' ' "

			cQuery := ChangeQuery(cQuery)
			dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAlias,.F.,.T.)

			While !Eof()
				nScan := aScan(aSavRat,{|x| x[SV_PEDIDO]==aPedido[nCntFor][1]})
				If nScan == 0
					aadd(aSavRat,{aPedido[nCntFor][1],;
					              0,;
					              0,;
					              0,;
					              0,;
					              0,;
					              0,;
					              0,;
					              dDataBase,;
					              SubStr(Time(),1,5)})
					nScan := Len(aSavRat)
				EndIf
				dbSelectArea(cAlias)
				aSavRat[nScan][SV_FRETE  ] += (cAlias)->F2_FRETE
				aSavRat[nScan][SV_FRETAUT] += (cAlias)->F2_FRETAUT
				aSavRat[nScan][SV_SEGURO ] += (cAlias)->F2_SEGURO
				aSavRat[nScan][SV_DESPESA] += (cAlias)->F2_DESPESA
				aSavRat[nScan][SV_DESCONT] += (cAlias)->F2_DESCCAB
				aSavRat[nScan][SV_DESPAC2] += 0
				aSavRat[nScan][SV_VLR_FRT] += (cAlias)->F2_VLR_FRT

				If SC5->C5_FRETE <=0
					aSavRat[nScan][SV_FRETE  ] := 0
				EndIf

				(cAlias)->( DBSkip() )
			EndDo

          	(cAlias)->( DBCloseArea() )
           DBSelectArea("SD2")

		EndIf
    EndIf
	cBanco := SC5->C5_BANCO
	nMoeda := SC5->C5_MOEDA

	If !Empty(SC5->C5_PEDEXP) .And. lEECFat .And. _lEECF2FrEmb .And. lEEC0038
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Trata o frete de exportação (embarque) ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		EECFat2FreteEmb(SC5->C5_NUM, SC5->C5_PEDEXP, aPvlNfs, aPedido, aSavRat, @cEmbExp, dDataMoe, @lTpLibPed)
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Converte da moeda do pedido para corrente  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	nFrete    := NoRound(xMoeda(SC5->C5_FRETE,   If(lMoedaFre, SC5->C5_MOEDA, 1), 1, dDataMoe,8), 8)
	nFretAut  := NoRound(xMoeda(SC5->C5_FRETAUT, If(lMoedaFre, SC5->C5_MOEDA, 1), 1, dDataMoe,8), 8)
	nSeguro   := NoRound(xMoeda(SC5->C5_SEGURO,  If(lMoedaFre, SC5->C5_MOEDA, 1), 1, dDataMoe,8), 8)
	nDespesa  := NoRound(xMoeda(SC5->C5_DESPESA, If(lMoedaFre, SC5->C5_MOEDA, 1), 1, dDataMoe,8), 8)
	nDesconto := NoRound(xMoeda(SC5->C5_DESCONT, If(lMoedaFre, SC5->C5_MOEDA, 1), 1, dDataMoe,8), 8)
	nVlr_Frt  := NoRound(xMoeda(SC5->C5_VLR_FRT, If(lMoedaFre, SC5->C5_MOEDA, 1), 1, dDataMoe,8), 8)

	aPedido[nCntFor][19] := SC5->C5_PDESCAB/100

	//Guarda os valores originais das despesas acessórias
	If lTpLibPed
		aPedido[nCntFor][25] := nFrete
		aPedido[nCntFor][26] := nFretAut
		aPedido[nCntFor][27] := nSeguro
		aPedido[nCntFor][28] := nDespesa
		aPedido[nCntFor][29] := nDesconto
		aPedido[nCntFor][30] := nVlr_Frt
	EndIf

	aPedido[nCntFor][31] := .F.

	nScan := aScan(aSavRat,{|x| x[SV_PEDIDO] == aPedido[nCntFor][1]})

	/*
		Verifica se houve notas deletadas por outra thread para o pedido a ser faturado.
		Caso sejam encontradas as informações do rateio do pedido que está sendo faturado
		o array de rateio será reinicializado para que ocorra um novo calculo desde que
		a data e hora das exclusões sejam posteriores a data e hora do processamento do
		pedido. Ex: Numa thread o usuario poderá gerar novas notas e na outra exclui-las.
	*/
	If ( lTpLibPed .And. nScan > 0 )

		cTempSC9	:= GetNextAlias()

		cQrySC9 	:= " SELECT DISTINCT "

		If cTypeDB == "MSSQL"
			cQrySC9 += " TOP 1 "
		EndIf

		cQrySC9	+= " SC9.C9_NFISCAL" + cConcat + "SC9.C9_SERIENF DOCSER "
		cQrySC9 	+= " FROM " + RetSqlName("SC9") + " SC9 "
		cQrySC9 	+= " LEFT JOIN  " + RetSqlName("SF2") +" SF2 "
		cQrySC9 	+= " ON SC9.C9_NFISCAL = SF2.F2_DOC AND SC9.C9_SERIENF = SF2.F2_SERIE "
		cQrySC9 	+= " WHERE SC9.C9_FILIAL = '" + cFilSC9 + "' AND "
		cQrySC9 	+= " SF2.F2_FILIAL = '" + cFilSF2 + "' AND "
		cQrySC9 	+= " SC9.C9_PEDIDO = '" + aPedido[nCntFor][1] + "' AND "
		cQrySC9 	+= " ( SF2.F2_EMISSAO > '" + dTos(aSavRat[nScan][SV_DATA]) + "' OR "
		cQrySC9 	+= " ( SF2.F2_EMISSAO = '" + dTos(aSavRat[nScan][SV_DATA]) + "'  AND "
		cQrySC9 	+= "   SF2.F2_HORA >= '" + aSavRat[nScan][SV_HORA] + "' ) ) AND  "
		cQrySC9 	+= " SC9.D_E_L_E_T_ = '*' AND "
		cQrySC9 	+= " SF2.D_E_L_E_T_ = '*' "

		//Limit Oracle
		If cTypeDB == "ORACLE"
			cQrySC9 += " AND ROWNUM = 1 "
		EndIf  

		cQrySC9 += " ORDER BY DOCSER DESC "

		//Limit MSSQL ou PostGreSQL
		If cTypeDB $ "POSTGRES|MYSQL"  
			cQrySC9 += " LIMIT 1 " 
		EndIf

		cQrySC9 := ChangeQuery( cQrySC9 )

		DBUseArea(.T.,"TOPCONN",TcGenQry(,,cQrySC9),cTempSC9,.F.,.T.)

		If (cTempSC9)->( !Eof() )
			ADel(aSavRat,nScan)
			ASize(aSavRat,Len(aSavRat)-1)
			nScan := 0
		EndIf

		(cTempSC9)->(DBCloseArea())
		DBSelectArea("SC5")

	EndIf

	If nScan > 0
		If lTpLibPed
			lDespUtil := .T.
			If (nFrete > aSavRat[nScan,SV_C5_FRETE]) .Or. ((nFrete - aSavRat[nScan,SV_FRETE]) <= 0)
				aSavRat[nScan,SV_FRETE] := 0
			EndIf
			nFrete    -= aSavRat[nScan,SV_FRETE]
			If (nFretAut > aSavRat[nScan,SV_C5_FRETAUT]) .Or. ((nFretAut - aSavRat[nScan,SV_FRETAUT]) <= 0)
				aSavRat[nScan,SV_FRETAUT] := 0
			EndIf
			nFretAut  -= aSavRat[nScan,SV_FRETAUT]
			If (nSeguro > aSavRat[nScan,SV_C5_SEGURO]) .Or. ((nSeguro - aSavRat[nScan,SV_SEGURO]) <= 0)
				aSavRat[nScan,SV_SEGURO] := 0
			EndIf
			nSeguro   -= aSavRat[nScan,SV_SEGURO]
			If (nDespesa > aSavRat[nScan,SV_C5_DESPESA]) .Or. ((nDespesa - aSavRat[nScan,SV_DESPESA]) <= 0)
				aSavRat[nScan,SV_DESPESA] := 0
			EndIf
			nDespesa  -= aSavRat[nScan,SV_DESPESA]
			If (nDesconto > aSavRat[nScan,SV_C5_DESCONT]) .Or. ((nDesconto - aSavRat[nScan,SV_DESCONT]) <= 0)
				aSavRat[nScan,SV_DESCONT] := 0
			EndIf
			nDesconto -= aSavRat[nScan,SV_DESCONT]
			If (nVlr_Frt > aSavRat[nScan,SV_C5_VLR_FRT]) .Or. ((nVlr_Frt - aSavRat[nScan,SV_VLR_FRT]) <= 0)
				aSavRat[nScan,SV_VLR_FRT] := 0
			EndIf
			nVlr_Frt  -= aSavRat[nScan,SV_VLR_FRT]
		Else
			lDespUtil := .T.
		EndIf

		//Atualiza a data e hora da ultima verificação.
		aSavRat[nScan][SV_DATA] := dDataBase
		aSavRat[nScan][SV_HORA] := SubStr(Time(),1,5)

	Else
		If lTpLibPed .And. Len(aPedido) > 1
			lDespUtil := .T.
		EndIf
	EndIf

	If (  nFrete  <> 0 .Or. ;
			nSeguro <> 0 .Or. ;
			nDespesa<> 0 .Or. ;
			nFretAut<> 0 .Or. ;
			nDesconto<> 0.Or. ;
			nVlr_Frt<> 0)

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Converte frete para moeda do pedido³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If lMoedaFre .And. !lDespUtil
			nFrete2    := SC5->C5_FRETE   - IIf(nScan<>0, NoRound(xMoeda(aSavRat[nScan][SV_FRETE],   1, SC5->C5_MOEDA, dDataMoe, 8), 8), 0)
			nFretAut2  := SC5->C5_FRETAUT - IIf(nScan<>0, NoRound(xMoeda(aSavRat[nScan][SV_FRETAUT], 1, SC5->C5_MOEDA, dDataMoe, 8), 8), 0)
			nSeguro2   := SC5->C5_SEGURO  - IIf(nScan<>0, NoRound(xMoeda(aSavRat[nScan][SV_SEGURO],  1, SC5->C5_MOEDA, dDataMoe, 8), 8), 0)
			nDespesa2  := SC5->C5_DESPESA - IIf(nScan<>0, NoRound(xMoeda(aSavRat[nScan][SV_DESPESA], 1, SC5->C5_MOEDA, dDataMoe, 8), 8), 0)
			nDesconto2 := SC5->C5_DESCONT - IIf(nScan<>0, NoRound(xMoeda(aSavRat[nScan][SV_DESCONT], 1, SC5->C5_MOEDA, dDataMoe, 8), 8), 0)
			nVlr_Frt2  := SC5->C5_VLR_FRT - IIf(nScan<>0, NoRound(xMoeda(aSavRat[nScan][SV_VLR_FRT], 1, SC5->C5_MOEDA, dDataMoe, 8), 8), 0)
		Else
			nFrete2    := NoRound(xMoeda(nFrete,    1, SC5->C5_MOEDA, dDataMoe, 8), 8)
			nFretAut2  := NoRound(xMoeda(nFretAut,  1, SC5->C5_MOEDA, dDataMoe, 8), 8)
			nSeguro2   := NoRound(xMoeda(nSeguro,   1, SC5->C5_MOEDA, dDataMoe, 8), 8)
			nDespesa2  := NoRound(xMoeda(nDespesa,  1, SC5->C5_MOEDA, dDataMoe, 8), 8)
			nDesconto2 := NoRound(xMoeda(nDesconto, 1, SC5->C5_MOEDA, dDataMoe, 8), 8)
			nVlr_Frt2  := NoRound(xMoeda(nVlr_Frt,  1, SC5->C5_MOEDA, dDataMoe, 8), 8)
		EndIf
		 
		aPedido[nCntFor][20] := nFrete2 + nFretAut2 + nSeguro2 + nDespesa2 - nDesconto2 - IIf(nScan <> 0 .And. !lMoedTit .And. SC5->C5_MOEDA == 1, aSavRat[nScan][SV_DESPAC2], 0) //Arredondamento em dolar
		aPedido[nCntFor][21] := SC5->C5_MOEDA

		If ( nRatDesp == 2 .Or. nRatFrete == 2 .Or. nRatSeg == 2 )
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Calcula o Valor Total do Pedido                                         ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			cAlias := GetNextAlias()
			If cTpRtDsp == "2"
				If !lDespUtil
					cQuery := "SELECT SUM(SB1.B1_PESO*(SC6.C6_QTDVEN-SC6.C6_QTDENT)) TOTALPED FROM "
				Else
					cQuery := "SELECT SUM(SB1.B1_PESO*SC6.C6_QTDVEN) TOTALPED FROM "
				EndIf
				cQuery += RetSqlName("SB1")+" SB1 ,"
				cQuery += RetSqlName("SC6")+" SC6 ,"
				cQuery += RetSqlName("SF4")+" SF4  "
				cQuery += " WHERE "
				cQuery += " SC6.C6_FILIAL='"+cFilSC6+"' AND "
				cQuery += " SC6.C6_NUM='"+aPedido[nCntFor][1]+"' AND "
				cQuery += " SC6.C6_PRCVEN>0 AND "
				cQuery += " SC6.D_E_L_E_T_=' ' AND "
				cQuery += " SF4.F4_FILIAL='"+cFilSF4+"' AND "
				cQuery += " SF4.F4_CODIGO=SC6.C6_TES AND "
				cQuery += " SF4.D_E_L_E_T_=' ' AND "
				cQuery += " SF4.F4_ISS<>'S' AND "
				cQuery += " SB1.B1_FILIAL='"+cFilSB1+"' AND "
				cQuery += " SB1.B1_COD=SC6.C6_PRODUTO AND "
				cQuery += " SB1.D_E_L_E_T_=' ' "
			Else
				cQuery := "SELECT SUM(SB1.B1_PESO*SC9.C9_QTDLIB) TOTALPED FROM "
				cQuery += RetSqlName("SC9")+" SC9 ,"
				cQuery += RetSqlName("SB1")+" SB1 ,"
				cQuery += RetSqlName("SC6")+" SC6 ,"
				cQuery += RetSqlName("SF4")+" SF4  "
				cQuery += " WHERE SC9.C9_FILIAL='"+cFilSC9+"' AND"
				cQuery +=      " SC9.C9_PEDIDO='"+aPedido[nCntFor][1]+"' AND"
				cQuery +=      " SC9.C9_NFISCAL='"+Space(Len(SC9->C9_NFISCAL))+"' AND"
				cQuery +=      " SC9.C9_PRCVEN>0 AND"
				cQuery +=      " SC9.D_E_L_E_T_=' ' AND"
				cQuery +=      " SC6.C6_FILIAL='"+cFilSC6+"' AND"
				cQuery +=      " SC6.C6_NUM=SC9.C9_PEDIDO AND"
				cQuery +=      " SC6.C6_ITEM=SC9.C9_ITEM AND"
				cQuery +=      " SC6.C6_PRODUTO=SC9.C9_PRODUTO AND"
				cQuery +=      " SC6.D_E_L_E_T_=' ' AND"
				cQuery +=      " SF4.F4_FILIAL='"+cFilSF4+"' AND"
				cQuery +=      " SF4.F4_CODIGO=SC6.C6_TES AND"
				cQuery +=      " SF4.D_E_L_E_T_=' ' AND"
				cQuery +=      " SF4.F4_ISS<>'S' AND"
				cQuery +=      " SB1.B1_FILIAL='"+cFilSB1+"' AND"
				cQuery +=      " SB1.B1_COD=SC9.C9_PRODUTO AND"
				cQuery +=      " SB1.D_E_L_E_T_=' '"
			EndIf
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Pontos de Entrada 			                                           ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If ( aEntry[EP_M460QRT] )
				cQuery := ExecTemplate("M460QRY",.F.,.F.,{ cQuery , 2})
			EndIf

			If ( aEntry[EP_M460QRY] )
				cQuery := ExecBlock("M460QRY",.F.,.F.,{ cQuery , 2})
			EndIf

			cQuery := ChangeQuery(cQuery)

			dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAlias,.F.,.T.)

			aPedido[nCntFor][16] := IIf(NoRound(TOTALPED,8) > 0.0001, NoRound(TOTALPED,8), 0.0001)
			aPedido[nCntFor][31] := IIf(TOTALPED == 0.0000, .T., .F.)

			(cAlias)->( DBCloseArea() )
			DBSelectArea("SC5")

			If aPedido[nCntFor][16]>0
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Rateio das despesas acessorias                                          ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If cTpRtDsp == "2"
					cQuery := "SELECT SUM(B1_PESO*(SC6.C6_QTDVEN-SC6.C6_QTDENT)*"+StrZero(nFrete2,16,2)+"/"+StrZero(aPedido[nCntFor][16],16,4)+") FRETE, "
					cQuery +=        "SUM(B1_PESO*(SC6.C6_QTDVEN-SC6.C6_QTDENT)*"+StrZero(nSeguro2,16,2)+"/"+StrZero(aPedido[nCntFor][16],16,4) +") SEGURO, "
					cQuery +=        "SUM(B1_PESO*(SC6.C6_QTDVEN-SC6.C6_QTDENT)*"+StrZero(nDespesa2,16,2)+"/"+StrZero(aPedido[nCntFor][16],16,4)+") DESPESA, "
					cQuery +=        "SUM(B1_PESO*(SC6.C6_QTDVEN-SC6.C6_QTDENT)*"+StrZero(nFretAut2,16,2)+"/"+StrZero(aPedido[nCntFor][16],16,4)+") FRETAUT, "
					cQuery +=        "SUM(B1_PESO*(SC6.C6_QTDVEN-SC6.C6_QTDENT)*"+StrZero(nVlr_Frt2,16,2)+"/"+StrZero(aPedido[nCntFor][16],16,4)+") VLR_FRT "
					cQuery += "FROM "+RetSqlName("SC5")+" SC5 ,"
					cQuery +=         RetSqlName("SC6")+" SC6 ,"
					cQuery +=         RetSqlName("SB1")+" SB1 ,"
					cQuery +=         RetSqlName("SF4")+" SF4 "
					cQuery += "WHERE SC5.C5_FILIAL='"+cFilSC5+"' AND"
					cQuery +=      " SC5.C5_NUM='"+aPedido[nCntFor][1]+"' AND"
					cQuery +=      " SC5.D_E_L_E_T_=' ' AND"
					cQuery +=      " SC6.C6_FILIAL='"+cFilSC6+"' AND"
					cQuery +=      " SC6.C6_NUM=SC5.C5_NUM AND"
					cQuery +=      " SC6.D_E_L_E_T_=' ' AND"
					cQuery +=      " SF4.F4_FILIAL='"+cFilSF4+"' AND"
					cQuery +=      " SF4.F4_CODIGO=SC6.C6_TES AND"
					cQuery +=      " SF4.D_E_L_E_T_=' ' AND"
					cQuery +=      " SF4.F4_ISS<>'S' AND"
					cQuery +=      " SB1.B1_FILIAL='"+cFilSB1+"' AND"
					cQuery +=      " SB1.B1_COD=SC6.C6_PRODUTO AND"
					cQuery +=      " SB1.D_E_L_E_T_=' '"
				Else
					cQuery := "SELECT SUM(B1_PESO*C9_QTDLIB*"+StrZero(nFrete2,16,2)+"/"+StrZero(aPedido[nCntFor][16],16,4)+") FRETE, "
					cQuery +=        "SUM(B1_PESO*C9_QTDLIB*"+StrZero(nSeguro2,16,2)+"/"+StrZero(aPedido[nCntFor][16],16,4) +") SEGURO, "
					cQuery +=        "SUM(B1_PESO*C9_QTDLIB*"+StrZero(nDespesa2,16,2)+"/"+StrZero(aPedido[nCntFor][16],16,4)+") DESPESA, "
					cQuery +=        "SUM(B1_PESO*C9_QTDLIB*"+StrZero(nFretAut2,16,2)+"/"+StrZero(aPedido[nCntFor][16],16,4)+") FRETAUT, "
					cQuery +=        "SUM(B1_PESO*C9_QTDLIB*"+StrZero(nVlr_Frt2,16,2)+"/"+StrZero(aPedido[nCntFor][16],16,4)+") VLR_FRT "
					cQuery += "FROM "+RetSqlName("SC5")+" SC5 ,"
					cQuery +=         RetSqlName("SC6")+" SC6 ,"
					cQuery +=         RetSqlName("SB1")+" SB1 ,"
					cQuery +=         RetSqlName("SF4")+" SF4 ,"
					cQuery +=         RetSqlName("SC9")+" SC9  "
					cQuery += "WHERE SC5.C5_FILIAL='"+cFilSC5+"' AND"
					cQuery +=      " SC5.C5_NUM='"+aPedido[nCntFor][1]+"' AND"
					cQuery +=      " SC5.D_E_L_E_T_=' ' AND"
					cQuery +=      " SC9.C9_FILIAL='"+cFilSC9+"' AND"
					cQuery +=      " SC9.C9_PEDIDO=SC5.C5_NUM AND"
					cQuery +=      " SC9.C9_NFISCAL='"+Space(Len(SC9->C9_NFISCAL))+"' AND"
					cQuery +=      " SC9.C9_PRCVEN>0 AND"
					cQuery +=      " SC9.D_E_L_E_T_=' ' AND"
					cQuery +=      " SC6.C6_FILIAL='"+cFilSC6+"' AND"
					cQuery +=      " SC6.C6_NUM=SC9.C9_PEDIDO AND"
					cQuery +=      " SC6.C6_ITEM=SC9.C9_ITEM AND"
					cQuery +=      " SC6.C6_PRODUTO=SC9.C9_PRODUTO AND"
					cQuery +=      " SC6.D_E_L_E_T_=' ' AND"
					cQuery +=      " SF4.F4_FILIAL='"+cFilSF4+"' AND"
					cQuery +=      " SF4.F4_CODIGO=SC6.C6_TES AND"
					cQuery +=      " SF4.D_E_L_E_T_=' ' AND"
					cQuery +=      " SF4.F4_ISS<>'S' AND"
					cQuery +=      " SB1.B1_FILIAL='"+cFilSB1+"' AND"
					cQuery +=      " SB1.B1_COD=SC9.C9_PRODUTO AND"
					cQuery +=      " SB1.D_E_L_E_T_=' '"
				EndIf
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Pontos de Entrada 													   ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If ( aEntry[EP_M460QRT] )
					cQuery := ExecTemplate("M460QRY",.F.,.F.,{ cQuery , 3})
				EndIf

				If ( aEntry[EP_M460QRY] )
					cQuery := ExecBlock("M460QRY",.F.,.F.,{ cQuery , 3})
				EndIf

				cQuery := ChangeQuery(cQuery)

				dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAlias,.F.,.T.)

				aPedido[nCntFor][06] := nFrete2
				aPedido[nCntFor][07] := nSeguro2
				aPedido[nCntFor][08] := nDespesa2
				aPedido[nCntFor][09] := nFretAut2
				aPedido[nCntFor][23] := nVlr_Frt2


				If !aPedido[nCntFor][31]
					aPedido[nCntFor][11] := aPedido[nCntFor][06]
					aPedido[nCntFor][12] := aPedido[nCntFor][07]
					aPedido[nCntFor][13] := aPedido[nCntFor][08]
					aPedido[nCntFor][14] := aPedido[nCntFor][09]
					aPedido[nCntFor][24] := aPedido[nCntFor][23]

					aPedido[nCntFor][11] -= FRETE
					aPedido[nCntFor][12] -= SEGURO
					aPedido[nCntFor][13] -= DESPESA
					aPedido[nCntFor][14] -= FRETAUT
					aPedido[nCntFor][24] -= VLR_FRT
				EndIf

				If ( nRatFrete == 2 )
					aPedido[nCntFor][17][1] := 2
				EndIf
				If ( nRatDesp == 2 )
					aPedido[nCntFor][17][2] := 2
				EndIf
				If ( nRatSeg == 2 )
					aPedido[nCntFor][17][3] := 2
				EndIf

				(cAlias)->( DBCloseArea() )
				DBSelectArea("SC5")

			EndIf
		EndIf
		If ( nRatDesp == 1 .Or. nRatFrete == 1 .Or. nRatSeg == 1 .Or. aPedido[nCntFor][16]==0 )
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Calcula o Valor Total do Pedido                                         ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			cAlias := GetNextAlias()
			If cTpRtDsp == "2"
				If !lDespUtil
					cQuery := "SELECT SUM(SC6.C6_PRCVEN*(SC6.C6_QTDVEN-SC6.C6_QTDENT)) TOTALPED FROM "
				Else
					cQuery := "SELECT SUM(SC6.C6_PRCVEN*SC6.C6_QTDVEN) TOTALPED FROM "
				EndIf
				cQuery += RetSqlName("SC6")+" SC6 ,"
				cQuery += RetSqlName("SF4")+" SF4  "
				cQuery += " WHERE "
				cQuery += " SC6.C6_FILIAL='"+cFilSC6+"' AND"
				cQuery += " SC6.C6_NUM='"+aPedido[nCntFor][1]+"' AND"
				cQuery += " SC6.C6_PRCVEN>0 AND"
				cQuery += " SC6.D_E_L_E_T_=' ' AND"
				cQuery += " SF4.F4_FILIAL='"+cFilSF4+"' AND"
				cQuery += " SF4.F4_CODIGO=SC6.C6_TES AND"
				cQuery += " SF4.D_E_L_E_T_=' ' AND "
				cQuery += " SF4.F4_ISS<>'S' "

				If cTypeDB $ "INFORMIX|ORACLE"
					cQuery += "UNION SELECT NVL(SUM(SC6.C6_PRCVEN),0) TOTALPED FROM "
				ElseIf cTypeDB $ "DB2|POSTGRES"
					cQuery += "UNION SELECT COALESCE(SUM(SC6.C6_PRCVEN),0) TOTALPED FROM "
				Else
					cQuery += "UNION SELECT ISNULL(SUM(SC6.C6_PRCVEN),0) TOTALPED FROM "
				EndIf

				cQuery += RetSqlName("SC6")+" SC6 ,"
				cQuery += RetSqlName("SF4")+" SF4  "
				cQuery += " WHERE "
				cQuery += " SC6.C6_FILIAL='"+cFilSC6+"' AND"
				cQuery += " SC6.C6_NUM='"+aPedido[nCntFor][1]+"' AND"
				cQuery += " SC6.C6_PRCVEN>0 AND"
				cQuery += " SC6.C6_QTDVEN=0 AND"
				cQuery += " SC6.D_E_L_E_T_=' ' AND"
				cQuery += " SF4.F4_FILIAL='"+cFilSF4+"' AND"
				cQuery += " SF4.F4_CODIGO=SC6.C6_TES AND"
				cQuery += " SF4.D_E_L_E_T_=' ' AND "
				cQuery += " SF4.F4_ISS<>'S' "
			Else
				cQuery := "SELECT SUM(SC9.C9_PRCVEN*SC9.C9_QTDLIB) TOTALPED FROM "
				cQuery += RetSqlName("SC9")+" SC9 ,"
				cQuery += RetSqlName("SC6")+" SC6 ,"
				cQuery += RetSqlName("SF4")+" SF4  "
				cQuery += " WHERE SC9.C9_FILIAL='"+cFilSC9+"' AND"
				cQuery +=      " SC9.C9_PEDIDO='"+aPedido[nCntFor][1]+"' AND"
				cQuery +=      " SC9.C9_NFISCAL='"+Space(Len(SC9->C9_NFISCAL))+"' AND"
				cQuery +=      " SC9.C9_PRCVEN>0 AND"
				cQuery +=      " SC9.D_E_L_E_T_=' ' AND"
				cQuery +=      " SC6.C6_FILIAL='"+cFilSC6+"' AND"
				cQuery +=      " SC6.C6_NUM=SC9.C9_PEDIDO AND"
				cQuery +=      " SC6.C6_ITEM=SC9.C9_ITEM AND"
				cQuery +=      " SC6.C6_PRODUTO=SC9.C9_PRODUTO AND"
				cQuery +=      " SC6.D_E_L_E_T_=' ' AND"
				cQuery +=      " SF4.F4_FILIAL='"+cFilSF4+"' AND"
				cQuery +=      " SF4.F4_CODIGO=SC6.C6_TES AND"
				cQuery +=      " SF4.D_E_L_E_T_=' ' AND "
				cQuery +=      " SF4.F4_ISS<>'S' "

				If cTypeDB $ "INFORMIX|ORACLE"
					cQuery += "UNION SELECT NVL(SUM(SC6.C6_PRCVEN),0) TOTALPED FROM "
				ElseIf cTypeDB $ "DB2|POSTGRES"
					cQuery += "UNION SELECT COALESCE(SUM(SC6.C6_PRCVEN),0) TOTALPED FROM "
				Else
					cQuery += "UNION SELECT ISNULL(SUM(SC6.C6_PRCVEN),0) TOTALPED FROM "
				EndIf

				cQuery += RetSqlName("SC9")+" SC9 ,"
				cQuery += RetSqlName("SC6")+" SC6 ,"
				cQuery += RetSqlName("SF4")+" SF4  "
				cQuery += " WHERE SC9.C9_FILIAL='"+cFilSC9+"' AND"
				cQuery +=      " SC9.C9_PEDIDO='"+aPedido[nCntFor][1]+"' AND"
				cQuery +=      " SC9.C9_NFISCAL='"+Space(Len(SC9->C9_NFISCAL))+"' AND"
				cQuery +=      " SC9.C9_PRCVEN>0 AND"
				cQuery +=      " SC9.C9_QTDLIB=0 AND"
				cQuery +=      " SC9.D_E_L_E_T_=' ' AND"
				cQuery +=      " SC6.C6_FILIAL='"+cFilSC6+"' AND"
				cQuery +=      " SC6.C6_NUM=SC9.C9_PEDIDO AND"
				cQuery +=      " SC6.C6_ITEM=SC9.C9_ITEM AND"
				cQuery +=      " SC6.C6_PRODUTO=SC9.C9_PRODUTO AND"
				cQuery +=      " SC6.D_E_L_E_T_=' ' AND"
				cQuery +=      " SF4.F4_FILIAL='"+cFilSF4+"' AND"
				cQuery +=      " SF4.F4_CODIGO=SC6.C6_TES AND"
				cQuery +=      " SF4.D_E_L_E_T_=' ' AND "
				cQuery +=      " SF4.F4_ISS<>'S' "
			EndIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Pontos de Entrada 		                                               ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If ( aEntry[EP_M460QRT] )
				cQuery := ExecTemplate("M460QRY",.F.,.F.,{ cQuery , 2})
			EndIf

			If ( aEntry[EP_M460QRY] )
				cQuery := ExecBlock("M460QRY",.F.,.F.,{ cQuery , 2})
			EndIf

			cQuery := ChangeQuery(cQuery)

			dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAlias,.F.,.T.)

			dbSelectArea(cAlias)
			While (cAlias)->(!Eof())
				aPedido[nCntFor][05] += NoRound((cAlias)->TOTALPED,2)
				(cAlias)->( dbSkip() )
			EndDo

			(cAlias)->( DBCloseArea() )

			DBSelectArea("SC5")

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Rateio das despesas acessorias                                          ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If cTpRtDsp == "2"
				cQuery := "SELECT SUM(C6_PRCVEN*(SC6.C6_QTDVEN-SC6.C6_QTDENT)*"+StrZero(nFrete2,16,2)+"/"+StrZero(aPedido[nCntFor][05],16,2)+") FRETE, "
				cQuery +=        "SUM(C6_PRCVEN*(SC6.C6_QTDVEN-SC6.C6_QTDENT)*"+StrZero(nSeguro2,16,2)+"/"+StrZero(aPedido[nCntFor][05],16,2) +") SEGURO, "
				cQuery +=        "SUM(C6_PRCVEN*(SC6.C6_QTDVEN-SC6.C6_QTDENT)*"+StrZero(nDespesa2,16,2)+"/"+StrZero(aPedido[nCntFor][05],16,2)+") DESPESA, "
				cQuery +=        "SUM(C6_PRCVEN*(SC6.C6_QTDVEN-SC6.C6_QTDENT)*"+StrZero(nFretAut2,16,2)+"/"+StrZero(aPedido[nCntFor][05],16,2)+") FRETAUT, "
				cQuery +=        "SUM(C6_PRCVEN*(SC6.C6_QTDVEN-SC6.C6_QTDENT)*"+StrZero(nVlr_Frt2,16,2)+"/"+StrZero(aPedido[nCntFor][05],16,2)+") VLR_FRT "
				cQuery += "FROM "+RetSqlName("SC5")+" SC5 ,"
				cQuery +=         RetSqlName("SC6")+" SC6 ,"
				cQuery +=         RetSqlName("SF4")+" SF4 "
				cQuery += "WHERE SC5.C5_FILIAL='"+cFilSC5+"' AND"
				cQuery +=      " SC5.C5_NUM='"+aPedido[nCntFor][1]+"' AND"
				cQuery +=      " SC5.D_E_L_E_T_=' ' AND"
				cQuery +=      " SC6.C6_FILIAL='"+cFilSC6+"' AND"
				cQuery +=      " SC6.C6_NUM=SC5.C5_NUM AND"
				cQuery +=      " SC6.D_E_L_E_T_=' ' AND"
				cQuery +=      " SF4.F4_FILIAL='"+cFilSF4+"' AND"
				cQuery +=      " SF4.F4_CODIGO=SC6.C6_TES AND"
				cQuery +=      " SF4.D_E_L_E_T_=' ' AND "
				cQuery +=      " SF4.F4_ISS<>'S'"
			Else
				cQuery := "SELECT SUM(C9_PRCVEN*C9_QTDLIB*"+StrZero(nFrete2,16,2)+"/"+StrZero(aPedido[nCntFor][05],16,2)+") FRETE, "
				cQuery +=        "SUM(C9_PRCVEN*C9_QTDLIB*"+StrZero(nSeguro2,16,2)+"/"+StrZero(aPedido[nCntFor][05],16,2) +") SEGURO, "
				cQuery +=        "SUM(C9_PRCVEN*C9_QTDLIB*"+StrZero(nDespesa2,16,2)+"/"+StrZero(aPedido[nCntFor][05],16,2)+") DESPESA, "
				cQuery +=        "SUM(C9_PRCVEN*C9_QTDLIB*"+StrZero(nFretAut2,16,2)+"/"+StrZero(aPedido[nCntFor][05],16,2)+") FRETAUT, "
				cQuery +=        "SUM(C9_PRCVEN*C9_QTDLIB*"+StrZero(nVlr_Frt2,16,2)+"/"+StrZero(aPedido[nCntFor][05],16,2)+") VLR_FRT "
				cQuery += "FROM "+RetSqlName("SC5")+" SC5 ,"
				cQuery +=         RetSqlName("SC6")+" SC6 ,"
				cQuery +=         RetSqlName("SF4")+" SF4 ,"
				cQuery +=         RetSqlName("SC9")+" SC9  "
				cQuery += "WHERE SC5.C5_FILIAL='"+cFilSC5+"' AND"
				cQuery +=      " SC5.C5_NUM='"+aPedido[nCntFor][1]+"' AND"
				cQuery +=      " SC5.D_E_L_E_T_=' ' AND"
				cQuery +=      " SC9.C9_FILIAL='"+cFilSC9+"' AND"
				cQuery +=      " SC9.C9_PEDIDO=SC5.C5_NUM AND"
				cQuery +=      " SC9.C9_NFISCAL='"+Space(Len(SC9->C9_NFISCAL))+"' AND"
				cQuery +=      " SC9.C9_PRCVEN>0 AND"
				cQuery +=      " SC9.C9_QTDLIB>0 AND"
				cQuery +=      " SC9.D_E_L_E_T_=' ' AND"
				cQuery +=      " SC6.C6_FILIAL='"+cFilSC6+"' AND"
				cQuery +=      " SC6.C6_NUM=SC9.C9_PEDIDO AND"
				cQuery +=      " SC6.C6_ITEM=SC9.C9_ITEM AND"
				cQuery +=      " SC6.C6_PRODUTO=SC9.C9_PRODUTO AND"
				cQuery +=      " SC6.D_E_L_E_T_=' ' AND"
				cQuery +=      " SF4.F4_FILIAL='"+cFilSF4+"' AND"
				cQuery +=      " SF4.F4_CODIGO=SC6.C6_TES AND"
				cQuery +=      " SF4.D_E_L_E_T_=' ' AND "
				cQuery +=      " SF4.F4_ISS<>'S'"
			EndIf
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Pontos de Entrada													   ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If ( aEntry[EP_M460QRT] )
				cQuery := ExecTemplate("M460QRY",.F.,.F.,{ cQuery , 3})
			EndIf

			If ( aEntry[EP_M460QRY] )
				cQuery := ExecBlock("M460QRY",.F.,.F.,{ cQuery , 3})
			EndIf

			cQuery += " UNION "

			If cTpRtDsp == "2"
				cQuery += "SELECT SUM(C6_PRCVEN*"+StrZero(nFrete2,16,2)+"/"+StrZero(aPedido[nCntFor][05],16,2)+") FRETE, "
				cQuery +=        "SUM(C6_PRCVEN*"+StrZero(nSeguro2,16,2)+"/"+StrZero(aPedido[nCntFor][05],16,2) +") SEGURO, "
				cQuery +=        "SUM(C6_PRCVEN*"+StrZero(nDespesa2,16,2)+"/"+StrZero(aPedido[nCntFor][05],16,2)+") DESPESA, "
				cQuery +=        "SUM(C6_PRCVEN*"+StrZero(nFretAut2,16,2)+"/"+StrZero(aPedido[nCntFor][05],16,2)+") FRETAUT, "
				cQuery +=        "SUM(C6_PRCVEN*"+StrZero(nVlr_Frt2,16,2)+"/"+StrZero(aPedido[nCntFor][05],16,2)+") VLR_FRT "
				cQuery += "FROM "+RetSqlName("SC5")+" SC5 ,"
				cQuery +=         RetSqlName("SC6")+" SC6 ,"
				cQuery +=         RetSqlName("SF4")+" SF4 "
				cQuery += "WHERE SC5.C5_FILIAL='"+cFilSC5+"' AND"
				cQuery +=      " SC5.C5_NUM='"+aPedido[nCntFor][1]+"' AND"
				cQuery +=      " SC5.D_E_L_E_T_=' ' AND"
				cQuery +=      " SC6.C6_FILIAL='"+cFilSC6+"' AND"
				cQuery +=      " SC6.C6_NUM=SC5.C5_NUM AND"
				cQuery +=      " SC6.C6_QTDVEN=0 AND"
				cQuery +=      " SC6.D_E_L_E_T_=' ' AND"
				cQuery +=      " SF4.F4_FILIAL='"+cFilSF4+"' AND"
				cQuery +=      " SF4.F4_CODIGO=SC6.C6_TES AND"
				cQuery +=      " SF4.D_E_L_E_T_=' ' AND "
				cQuery +=      " SF4.F4_ISS<>'S'"
			Else
				cQuery += "SELECT SUM(C9_PRCVEN*"+StrZero(nFrete2,16,2)+"/"+StrZero(aPedido[nCntFor][05],16,2)+") FRETE, "
				cQuery +=        "SUM(C9_PRCVEN*"+StrZero(nSeguro2,16,2)+"/"+StrZero(aPedido[nCntFor][05],16,2) +") SEGURO, "
				cQuery +=        "SUM(C9_PRCVEN*"+StrZero(nDespesa2,16,2)+"/"+StrZero(aPedido[nCntFor][05],16,2)+") DESPESA, "
				cQuery +=        "SUM(C9_PRCVEN*"+StrZero(nFretAut2,16,2)+"/"+StrZero(aPedido[nCntFor][05],16,2)+") FRETAUT, "
				cQuery +=        "SUM(C9_PRCVEN*"+StrZero(nVlr_Frt2,16,2)+"/"+StrZero(aPedido[nCntFor][05],16,2)+") VLR_FRT "
				cQuery += "FROM "+RetSqlName("SC5")+" SC5 ,"
				cQuery +=         RetSqlName("SC6")+" SC6 ,"
				cQuery +=         RetSqlName("SF4")+" SF4 ,"
				cQuery +=         RetSqlName("SC9")+" SC9  "
				cQuery += "WHERE SC5.C5_FILIAL='"+cFilSC5+"' AND"
				cQuery +=      " SC5.C5_NUM='"+aPedido[nCntFor][1]+"' AND"
				cQuery +=      " SC5.D_E_L_E_T_=' ' AND"
				cQuery +=      " SC9.C9_FILIAL='"+cFilSC9+"' AND"
				cQuery +=      " SC9.C9_PEDIDO=SC5.C5_NUM AND"
				cQuery +=      " SC9.C9_NFISCAL='"+Space(Len(SC9->C9_NFISCAL))+"' AND"
				cQuery +=      " SC9.C9_PRCVEN>0 AND"
				cQuery +=      " SC9.C9_QTDLIB=0 AND"
				cQuery +=      " SC9.D_E_L_E_T_=' ' AND"
				cQuery +=      " SC6.C6_FILIAL='"+cFilSC6+"' AND"
				cQuery +=      " SC6.C6_NUM=SC9.C9_PEDIDO AND"
				cQuery +=      " SC6.C6_ITEM=SC9.C9_ITEM AND"
				cQuery +=      " SC6.C6_PRODUTO=SC9.C9_PRODUTO AND"
				cQuery +=      " SC6.D_E_L_E_T_=' ' AND"
				cQuery +=      " SF4.F4_FILIAL='"+cFilSF4+"' AND"
				cQuery +=      " SF4.F4_CODIGO=SC6.C6_TES AND"
				cQuery +=      " SF4.D_E_L_E_T_=' ' AND "
				cQuery +=      " SF4.F4_ISS<>'S'"
			EndIf

			cQuery := ChangeQuery(cQuery)

			dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAlias,.F.,.T.)

			If nRatFrete == 1 .Or. aPedido[nCntFor][16]==0
				aPedido[nCntFor][06] := nFrete2
				aPedido[nCntFor][09] := nFretAut2
				aPedido[nCntFor][23] := nVlr_Frt2
				aPedido[nCntFor][17][1] := 1
				aPedido[nCntFor][11] := aPedido[nCntFor][06]
				aPedido[nCntFor][14] := aPedido[nCntFor][09]
				aPedido[nCntFor][24] := aPedido[nCntFor][23]
			EndIf
			If nRatSeg == 1 .Or. aPedido[nCntFor][16]==0
				aPedido[nCntFor][07] := nSeguro2
				aPedido[nCntFor][17][3] := 1
				aPedido[nCntFor][12] := aPedido[nCntFor][07]
			EndIf
			If nRatDesp == 1 .Or. aPedido[nCntFor][16]==0
				aPedido[nCntFor][08] := nDespesa2
				aPedido[nCntFor][17][2] := 1
				aPedido[nCntFor][13] := aPedido[nCntFor][08]
			EndIf

			While !( cAlias )->( Eof() )

				If nRatFrete == 1 .Or. aPedido[nCntFor][16]==0
					aPedido[nCntFor][11] -= ( cAlias )->FRETE
					aPedido[nCntFor][14] -= ( cAlias )->FRETAUT
					aPedido[nCntFor][24] -= ( cAlias )->VLR_FRT
				EndIf
				If nRatSeg == 1 .Or. aPedido[nCntFor][16]==0
					aPedido[nCntFor][12] -= ( cAlias )->SEGURO
				EndIf
				If nRatDesp == 1 .Or. aPedido[nCntFor][16]==0
					aPedido[nCntFor][13] -= ( cAlias )->DESPESA
				EndIf

				( cAlias )->( dbSkip() )

			EndDo
			( cAlias )->( dbCloseArea() )
		EndIf

		If nDesconto <> 0
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Calcula o Valor Total do Pedido para ratear o desconto considerando itens³
			//³com ISS                                                                  ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			cAlias := GetNextAlias()
			If cTpRtDsp == "2"
				If !lDespUtil
					cQuery := "SELECT SUM(SC6.C6_PRCVEN*(SC6.C6_QTDVEN-SC6.C6_QTDENT)) TOTALPED FROM "
				Else
					cQuery := "SELECT SUM(SC6.C6_PRCVEN*SC6.C6_QTDVEN) TOTALPED FROM "
				EndIf
				cQuery += RetSqlName("SC6")+" SC6 ,"
				cQuery += RetSqlName("SF4")+" SF4  "
				cQuery += " WHERE "
				cQuery += " SC6.C6_FILIAL='"+cFilSC6+"' AND"
				cQuery += " SC6.C6_NUM='"+aPedido[nCntFor][1]+"' AND"
				cQuery += " SC6.C6_PRCVEN>0 AND"
				cQuery += " SC6.D_E_L_E_T_=' ' AND"
				cQuery += " SF4.F4_FILIAL='"+cFilSF4+"' AND"
				cQuery += " SF4.F4_CODIGO=SC6.C6_TES AND"
				cQuery += " SF4.D_E_L_E_T_=' ' "
				If lTpDpInd
					cQuery += " AND SF4.F4_DUPLIC='S' "
				EndIf
			Else
				cQuery := "SELECT SUM(SC9.C9_PRCVEN*SC9.C9_QTDLIB) TOTALPED FROM "
				cQuery += RetSqlName("SC9")+" SC9 ,"
				cQuery += RetSqlName("SC6")+" SC6 ,"
				cQuery += RetSqlName("SF4")+" SF4  "
				cQuery += " WHERE SC9.C9_FILIAL='"+cFilSC9+"' AND"
				cQuery +=      " SC9.C9_PEDIDO='"+aPedido[nCntFor][1]+"' AND"
				cQuery +=      " SC9.C9_NFISCAL='"+Space(Len(SC9->C9_NFISCAL))+"' AND"
				cQuery +=      " SC9.C9_PRCVEN>0 AND"
				cQuery +=      " SC9.C9_QTDLIB>0 AND"
				cQuery +=      " SC9.D_E_L_E_T_=' ' AND"
				cQuery +=      " SC6.C6_FILIAL='"+cFilSC6+"' AND"
				cQuery +=      " SC6.C6_NUM=SC9.C9_PEDIDO AND"
				cQuery +=      " SC6.C6_ITEM=SC9.C9_ITEM AND"
				cQuery +=      " SC6.C6_PRODUTO=SC9.C9_PRODUTO AND"
				cQuery +=      " SC6.D_E_L_E_T_=' ' AND"
				cQuery +=      " SF4.F4_FILIAL='"+cFilSF4+"' AND"
				cQuery +=      " SF4.F4_CODIGO=SC6.C6_TES AND"
				cQuery +=      " SF4.D_E_L_E_T_=' ' "
				If lTpDpInd
					cQuery += " AND SF4.F4_DUPLIC='S' "
				EndIf
			EndIf
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Apura valor para quantidade zerada ( notas de complemento )            ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			cQuery += "UNION SELECT SUM(SC9.C9_PRCVEN) TOTALPED FROM "
			cQuery += RetSqlName("SC9")+" SC9 ,"
			cQuery += RetSqlName("SC6")+" SC6 ,"
			cQuery += RetSqlName("SF4")+" SF4  "
			cQuery += " WHERE SC9.C9_FILIAL='"+cFilSC9+"' AND"
			cQuery +=      " SC9.C9_PEDIDO='"+aPedido[nCntFor][1]+"' AND"
			cQuery +=      " SC9.C9_NFISCAL='"+Space(Len(SC9->C9_NFISCAL))+"' AND"
			cQuery +=      " SC9.C9_PRCVEN>0 AND"
			cQuery +=      " SC9.C9_QTDLIB=0 AND"
			cQuery +=      " SC9.D_E_L_E_T_=' ' AND"
			cQuery +=      " SC6.C6_FILIAL='"+cFilSC6+"' AND"
			cQuery +=      " SC6.C6_NUM=SC9.C9_PEDIDO AND"
			cQuery +=      " SC6.C6_ITEM=SC9.C9_ITEM AND"
			cQuery +=      " SC6.C6_PRODUTO=SC9.C9_PRODUTO AND"
			cQuery +=      " SC6.D_E_L_E_T_=' ' AND"
			cQuery +=      " SF4.F4_FILIAL='"+cFilSF4+"' AND"
			cQuery +=      " SF4.F4_CODIGO=SC6.C6_TES AND"
			cQuery +=      " SF4.D_E_L_E_T_=' ' "
			If lTpDpInd
				cQuery += " AND SF4.F4_DUPLIC='S' "
			EndIf
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Pontos de Entrada 				                                       ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If ( aEntry[EP_M460QRT] )
				cQuery := ExecTemplate("M460QRY",.F.,.F.,{ cQuery , 2})
			EndIf

			If ( aEntry[EP_M460QRY] )
				cQuery := ExecBlock("M460QRY",.F.,.F.,{ cQuery , 2})
			EndIf

			cQuery := ChangeQuery(cQuery)

			dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAlias,.F.,.T.)

			dbSelectArea(cAlias)
			While (cAlias)->(!Eof())
				aPedido[nCntFor][22] += NoRound((cAlias)->TOTALPED,2)
				(cAlias)->(dbSkip())
			EndDo

			(cAlias)->( DBCloseArea() )

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Rateio do desconto considerando itens com ISS                           ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If cTpRtDsp == "2"
				cQuery := "SELECT SUM(C6_PRCVEN*(SC6.C6_QTDVEN-SC6.C6_QTDENT)*"+StrZero(nDesconto2,16,2)+"/"+StrZero(aPedido[nCntFor, 22],16,2)+") DESCONT "
				cQuery += "FROM "+RetSqlName("SC6")+" SC6 ,"
				cQuery += 		  RetSqlName("SF4")+" SF4  "
				cQuery += " WHERE "
				cQuery += " SC6.C6_FILIAL='"+cFilSC6+"' AND"
				cQuery += " SC6.C6_NUM='"+aPedido[nCntFor][1]+"' AND"
				cQuery += " SC6.C6_PRCVEN>0 AND"
				cQuery += " SC6.D_E_L_E_T_=' ' AND"
				cQuery += " SF4.F4_FILIAL='"+cFilSF4+"' AND"
				cQuery += " SF4.F4_CODIGO=SC6.C6_TES AND"
				cQuery += " SF4.D_E_L_E_T_=' ' "
				If lTpDpInd
					cQuery += " AND SF4.F4_DUPLIC='S' "
				EndIf
			Else
				cQuery := "SELECT SUM(C9_PRCVEN*C9_QTDLIB*"+StrZero(nDesconto2,16,2)+"/"+StrZero(aPedido[nCntFor][22],16,2)+") DESCONT "
				cQuery += "FROM "+RetSqlName("SC5")+" SC5 ,"
				cQuery +=         RetSqlName("SC6")+" SC6 ,"
				cQuery +=         RetSqlName("SF4")+" SF4 ,"
				cQuery +=         RetSqlName("SC9")+" SC9  "
				cQuery += "WHERE SC5.C5_FILIAL='"+cFilSC5+"' AND"
				cQuery +=      " SC5.C5_NUM='"+aPedido[nCntFor][1]+"' AND"
				cQuery +=      " SC5.D_E_L_E_T_=' ' AND"
				cQuery +=      " SC9.C9_FILIAL='"+cFilSC9+"' AND"
				cQuery +=      " SC9.C9_PEDIDO=SC5.C5_NUM AND"
				cQuery +=      " SC9.C9_NFISCAL='"+Space(Len(SC9->C9_NFISCAL))+"' AND"
				cQuery +=      " SC9.C9_PRCVEN>0 AND"
				cQuery +=      " SC9.C9_QTDLIB>0 AND"
				cQuery +=      " SC9.D_E_L_E_T_=' ' AND"
				cQuery +=      " SC6.C6_FILIAL='"+cFilSC6+"' AND"
				cQuery +=      " SC6.C6_NUM=SC9.C9_PEDIDO AND"
				cQuery +=      " SC6.C6_ITEM=SC9.C9_ITEM AND"
				cQuery +=      " SC6.C6_PRODUTO=SC9.C9_PRODUTO AND"
				cQuery +=      " SC6.D_E_L_E_T_=' ' AND"
				cQuery +=      " SF4.F4_FILIAL='"+cFilSF4+"' AND"
				cQuery +=      " SF4.F4_CODIGO=SC6.C6_TES AND"
				cQuery +=      " SF4.D_E_L_E_T_=' ' "
				If lTpDpInd
					cQuery += " AND SF4.F4_DUPLIC='S' "
				EndIf
			EndIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Pontos de Entrada 				                                       ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If ( aEntry[EP_M460QRT] )
				cQuery := ExecTemplate("M460QRY",.F.,.F.,{ cQuery , 3})
			EndIf

			If ( aEntry[EP_M460QRY] )
				cQuery := ExecBlock("M460QRY",.F.,.F.,{ cQuery , 3})
			EndIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Apura valor para quantidade zerada ( notas de complemento )            ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

			cQuery += " UNION "

			cQuery += "SELECT SUM(C9_PRCVEN*"+StrZero(nDesconto2,16,2)+"/"+StrZero(aPedido[nCntFor][22],16,2)+") DESCONT "
			cQuery += "FROM "+RetSqlName("SC5")+" SC5 ,"
			cQuery +=         RetSqlName("SC6")+" SC6 ,"
			cQuery +=         RetSqlName("SF4")+" SF4 ,"
			cQuery +=         RetSqlName("SC9")+" SC9  "
			cQuery += "WHERE SC5.C5_FILIAL='"+cFilSC5+"' AND"
			cQuery +=      " SC5.C5_NUM='"+aPedido[nCntFor][1]+"' AND"
			cQuery +=      " SC5.D_E_L_E_T_=' ' AND"
			cQuery +=      " SC9.C9_FILIAL='"+cFilSC9+"' AND"
			cQuery +=      " SC9.C9_PEDIDO=SC5.C5_NUM AND"
			cQuery +=      " SC9.C9_NFISCAL='"+Space(Len(SC9->C9_NFISCAL))+"' AND"
			cQuery +=      " SC9.C9_PRCVEN>0 AND"
			cQuery +=      " SC9.C9_QTDLIB=0 AND"
			cQuery +=      " SC9.D_E_L_E_T_=' ' AND"
			cQuery +=      " SC6.C6_FILIAL='"+cFilSC6+"' AND"
			cQuery +=      " SC6.C6_NUM=SC9.C9_PEDIDO AND"
			cQuery +=      " SC6.C6_ITEM=SC9.C9_ITEM AND"
			cQuery +=      " SC6.C6_PRODUTO=SC9.C9_PRODUTO AND"
			cQuery +=      " SC6.D_E_L_E_T_=' ' AND"
			cQuery +=      " SF4.F4_FILIAL='"+cFilSF4+"' AND"
			cQuery +=      " SF4.F4_CODIGO=SC6.C6_TES AND"
			cQuery +=      " SF4.D_E_L_E_T_=' ' "

			cQuery := ChangeQuery(cQuery)

			dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAlias,.F.,.T.)

			aPedido[nCntFor][10] := nDesconto2
			aPedido[nCntFor][15] := aPedido[nCntFor][10]

			While !( cAlias )->( Eof() )
				aPedido[nCntFor][15] -= ( cAlias )->DESCONT
				( cAlias )->( dbSkip() )
			EndDo

			( cAlias )->( DBCloseArea() )
			DBSelectArea("SC5")
		EndIf

		aPedido[nCntFor][05] := NoRound(xMoeda(aPedido[nCntFor][05],SC5->C5_MOEDA,1,dDataMoe,8),8)
		aPedido[nCntFor][06] := NoRound(xMoeda(aPedido[nCntFor][06],SC5->C5_MOEDA,1,dDataMoe,8),8)
		aPedido[nCntFor][07] := NoRound(xMoeda(aPedido[nCntFor][07],SC5->C5_MOEDA,1,dDataMoe,8),8)
		aPedido[nCntFor][08] := NoRound(xMoeda(aPedido[nCntFor][08],SC5->C5_MOEDA,1,dDataMoe,8),8)
		aPedido[nCntFor][09] := NoRound(xMoeda(aPedido[nCntFor][09],SC5->C5_MOEDA,1,dDataMoe,8),8)
		aPedido[nCntFor][10] := NoRound(xMoeda(aPedido[nCntFor][10],SC5->C5_MOEDA,1,dDataMoe,8),8)
		aPedido[nCntFor][23] := NoRound(xMoeda(aPedido[nCntFor][23],SC5->C5_MOEDA,1,dDataMoe,8),8)

		If aPedido[nCntFor, 11] < 0
			aPedido[nCntFor, 11] := 0
		EndIf
		If aPedido[nCntFor, 12] < 0
			aPedido[nCntFor, 12] := 0
		EndIf
		If aPedido[nCntFor, 13] < 0
			aPedido[nCntFor, 13] := 0
		EndIf

		aPedido[nCntFor][14] := NoRound(xMoeda(aPedido[nCntFor][14],SC5->C5_MOEDA,1,dDataMoe,8),8)
		aPedido[nCntFor][15] := NoRound(xMoeda(aPedido[nCntFor][15],SC5->C5_MOEDA,1,dDataMoe,8),8)
		aPedido[nCntFor][22] := NoRound(xMoeda(aPedido[nCntFor][22],SC5->C5_MOEDA,1,dDataMoe,8),8)
		aPedido[nCntFor][24] := NoRound(xMoeda(aPedido[nCntFor][24],SC5->C5_MOEDA,1,dDataMoe,8),8)

		aPedido[nCntFor][11] += nFrete   -  ( NoRound(xMoeda(nFrete2   ,SC5->C5_MOEDA,1,dDataMoe,8),8) )
		aPedido[nCntFor][12] += nSeguro  -  ( NoRound(xMoeda(nSeguro2  ,SC5->C5_MOEDA,1,dDataMoe,8),8) )
		aPedido[nCntFor][13] += nDespesa -  ( NoRound(xMoeda(nDespesa2 ,SC5->C5_MOEDA,1,dDataMoe,8),8) )
		aPedido[nCntFor][14] += nFretAut -  ( NoRound(xMoeda(nFretAut2 ,SC5->C5_MOEDA,1,dDataMoe,8),8) )
		aPedido[nCntFor][15] += nDesconto - ( NoRound(xMoeda(nDesconto2,SC5->C5_MOEDA,1,dDataMoe,8),8) )
		aPedido[nCntFor][24] += nVlr_Frt  - ( NoRound(xMoeda(nVlr_Frt2 ,SC5->C5_MOEDA,1,dDataMoe,8),8) )
		
		If !Empty(SC5->C5_PEDEXP) .And. lEECFat .And. _lEECF2AtRat .And. lEEC0038
			EECFat2AtuRat(aPedido[nCntFor], aPvlNfs, cEmbExp)
		EndIf

	Else
		aPedido[nCntFor][17][1] := 1
		aPedido[nCntFor][17][2] := 1
		aPedido[nCntFor][17][3] := 1
	EndIf
Next nCntFor
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Ponto de Entrada para Impressora Fiscal           ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If (lCupFis .And. lContinua)
	lFiscal		:= LJProFile(11) //Recupera usuario
	aRetImpFi   := ExecBlock("M461IMPF",.F.,.F.,(aPvlNfs))
	cNumero     := aRetImpFi[1]
	lContinua   := aRetImpFi[2]
	cPdv		:= aRetImpFi[3]
    cSerie      := If(Len(aRetImpFi) > 3 .AND. !Empty(aRetImpFi[4]),aRetImpFi[4],cSerie)
    cCgc		:= aRetImpFi[5]
	cSerieId    := IIf( lUsaNewKey , SerieNfId("SF2",4,"F2_SERIE",dDataBase,A460Especie(cSerie),cSerie) , cSerie )

	If Empty(cNumero) .Or. Empty(cPdv)
		lContinua := .F.
		UserException("Exception in M461IMPF")
	EndIf
EndIf
If ( lContinua )
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Rateio das despesas                                                     ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If ( aEntry[EP_M460RTPD] )
		aPedido := ExecBlock("M460RTPD",.F.,.F.,aPedido)
	EndIf
	If ( aEntry[EP_M460ITPD] )
		aPvlNfs := ExecBlock("M460ITPD",.F.,.F.,aPvlNfs)
	EndIf
	nTotal := 0
	For nCntFor := 1 To Len(aPvlNfs)
		nScan := aScan(aPedido,{|x| x[1] == aPvlNfs[nCntFor][1]})
		aAdd(aRateio,{aPvlNfs[nCntFor][1],;	//01
		              aPvlNfs[nCntFor][2],;	//02
		              aPvlNfs[nCntFor][3],;	//03
		              0,;							//04
		              0,;							//05
		              0,;							//06
		              0,;							//07
		              0,;							//08
		              {},;						//09
		              0,;							//10
		              0,;							//11
		              0,;							//12
		              0})							//13
		nAuxCalc	:= If(aPvlNfs[nCntFor][4]==0, 1, aPvlNfs[nCntFor][4])
		If ( aPvlNfs[nCntFor][5] > 0 )
			nRateio := Len(aRateio)
			If ( aPvlNfs[nCntFor][7] )
				aRateio[nRateio][RT_FRETE  ] := 0
				aRateio[nRateio][RT_SEGURO ] := 0
				aRateio[nRateio][RT_DESPESA] := 0
				aRateio[nRateio][RT_FRETAUT] := 0
				aRateio[nRateio][RT_VLR_FRT] := 0
			Else
				If aPedido[nScan][17][01] == 1
					aRateio[nRateio][RT_FRETE  ] := nAuxCalc * aPvlNfs[nCntFor][5] * aPedido[nScan][06] / aPedido[nScan][05]
					aRateio[nRateio][RT_FRETAUT] := nAuxCalc * aPvlNfs[nCntFor][5] * aPedido[nScan][09] / aPedido[nScan][05]
					aRateio[nRateio][RT_VLR_FRT] := nAuxCalc * aPvlNfs[nCntFor][5] * aPedido[nScan][23] / aPedido[nScan][05]
				Else
					SB1->(dbSetOrder(1))
					SB1->(MsGoto(aPvlNfs[nCntFor][12]))
					aRateio[nRateio][RT_FRETE  ]  := nAuxCalc * SB1->B1_PESO * aPedido[nScan][06] / aPedido[nScan][16]
					aRateio[nRateio][RT_FRETAUT]  := nAuxCalc * SB1->B1_PESO * aPedido[nScan][09] / aPedido[nScan][16]
					aRateio[nRateio][RT_VLR_FRT ] := nAuxCalc * SB1->B1_PESO * aPedido[nScan][23] / aPedido[nScan][16]
				EndIf
				If aPedido[nScan][17][02] == 1
					aRateio[nRateio][RT_DESPESA]  := nAuxCalc * aPvlNfs[nCntFor][5] * aPedido[nScan][08] / aPedido[nScan][05]
				Else
					SB1->(dbSetOrder(1))
					SB1->(MsGoto(aPvlnfs[nCntFor][12]))
					aRateio[nRateio][RT_DESPESA] := nAuxCalc * SB1->B1_PESO * aPedido[nScan][08] / aPedido[nScan][16]
				EndIf
				If aPedido[nScan][17][03] == 1
					aRateio[nRateio][RT_SEGURO] := nAuxCalc * aPvlNfs[nCntFor][5] * aPedido[nScan][07] / aPedido[nScan][05]
				Else
					SB1->(dbSetOrder(1))
					SB1->(MsGoto(aPvlnfs[nCntFor][12]))
					aRateio[nRateio][RT_SEGURO] := nAuxCalc * SB1->B1_PESO * aPedido[nScan][07] / aPedido[nScan][16]
				EndIf
			EndIf
			If lTpDpInd
				SF4->(DbSetOrder(1))
				SF4->(MsGoto(aPvlnfs[nCntFor][14]))
				If SF4->F4_DUPLIC == "S"
					aRateio[nRateio][RT_DESCONT] := nAuxCalc * aPvlNfs[nCntFor][5] * aPedido[nScan][10] / aPedido[nScan][22]
				EndIf
			Else
				aRateio[nRateio][RT_DESCONT] := nAuxCalc * aPvlNfs[nCntFor][5] * aPedido[nScan][10] / aPedido[nScan][22]
			EndIf
			aRateio[nRateio][RT_PDESCON] := nAuxCalc * aPvlNfs[nCntFor][5] * aPedido[nScan][19]
			nTotal                       += nAuxCalc * aPvlNfs[nCntFor][5]
		Else
			nValNeg += Abs(a410Arred(nAuxCalc * aPvlNfs[nCntFor][5], "D2_TOTAL"))
		EndIf
	Next nCntFor

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Verifica se o ultimo item sera faturado para adicionar a diferenca de   ³
	//³arredondamento                                                          ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	For nCntFor := 1 To Len(aPedido)
		If !lDespUtil .Or. aPedido[nCntFor][21] > 1
			If ( nScan := aScan(aRateio,{|x|   x[1] == aPedido[nCntFor][1] .And. x[2] == aPedido[nCntFor][2] .And. x[3] == aPedido[nCntFor][3]}) ) > 0
				If aPedido[nCntFor][31]
					If ( aPedido[nCntFor][17][1] == 2 )
						aRateio[nScan][RT_FRETE  ] := NoRound(xMoeda(aPedido[nCntFor][6], If(lMoedaFre, SC5->C5_MOEDA, 1), 1, dDataMoe,8), 8)
					EndIf
					If ( aPedido[nCntFor][17][2] == 2 )
						aRateio[nScan][RT_DESPESA] := NoRound(xMoeda(aPedido[nCntFor][8], If(lMoedaFre, SC5->C5_MOEDA, 1), 1, dDataMoe,8), 8)
					EndIf
					If ( aPedido[nCntFor][17][3] == 2 )
						aRateio[nScan][RT_SEGURO ] := NoRound(xMoeda(aPedido[nCntFor][7], If(lMoedaFre, SC5->C5_MOEDA, 1), 1, dDataMoe,8), 8)
					EndIf
				EndIf
				If lMoedaFre .And. !lDespUtil
					aRateio[nScan][RT_FRETE  ] += aPedido[nCntFor][11]
					aRateio[nScan][RT_SEGURO ] += aPedido[nCntFor][12]
					aRateio[nScan][RT_DESPESA] += aPedido[nCntFor][13]
					aRateio[nScan][RT_FRETAUT] += aPedido[nCntFor][14]
					aRateio[nScan][RT_DESCONT] += aPedido[nCntFor][15]
					aRateio[nScan][RT_DESPMOE] += aPedido[nCntFor][20]
					aRateio[nScan][RT_VLR_FRT] += aPedido[nCntFor][24]
				EndIf	
				//Tratamento para arredondamento dos valores das despesas acessórias
				nFretAux := 0; nSeguAux := 0; nDespAux := 0
				nDifFre  := 0; nDifSeg  := 0; nDifDes  := 0
				For nX := 1 To Len(aRateio)
					If aRateio[nX, 1] == aPedido[nCntFor, 1]
						If lJunta .Or. aEntry[EP_M460RTPD]
							nFrete := aPedido[nCntFor][6]
							nSeguro := aPedido[nCntFor][7]
							nDespesa := aPedido[nCntFor][8]
						EndIf
						If nX <= Len(aRateio)
							nFretAux += aRateio[nX, RT_FRETE  ]
							nSeguAux += aRateio[nX, RT_SEGURO ]
							nDespAux += aRateio[nX, RT_DESPESA]
						EndIf
					EndIf
				Next nX
				nDifFre := (nFrete - nFretAux)
				nDifSeg := (nSeguro - nSeguAux)
				nDifDes := (nDespesa - nDespAux)
				If nDifFre < 0.05
					aRateio[nScan][RT_FRETE  ] += nDifFre
				EndIf
				If nDifSeg < 0.05
					aRateio[nScan][RT_SEGURO ] += nDifSeg
				EndIf
				If nDifDes < 0.05
					aRateio[nScan][RT_DESPESA] += nDifDes
				EndIf
				If lMoedTit .And. aPedido[nCntFor][21] > 1 .And. !lDespUtil
					aRateio[nScan, RT_DESPAC2] += (aPedido[nCntFor,11] + aPedido[nCntFor,12] + aPedido[nCntFor,13])
				EndIf
			EndIf
		EndIf
	Next nCntFor

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Verifica se ha valores negativos no rateio                              ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	For nScan := Len(aRateio) To 2 STEP -1
		If aRateio[nScan][RT_FRETE   ] < 0
			aRateio[nScan-1][RT_FRETE  ] += aRateio[nScan][RT_FRETE]
			aRateio[nScan  ][RT_FRETE  ] := 0
		EndIf
		If aRateio[nScan][RT_SEGURO  ] < 0
			aRateio[nScan-1][RT_SEGURO ] += aRateio[nScan][RT_SEGURO]
			aRateio[nScan  ][RT_SEGURO ] := 0
		EndIf
		If aRateio[nScan][RT_DESPESA ] < 0
			aRateio[nScan-1][RT_DESPESA] += aRateio[nScan][RT_DESPESA]
			aRateio[nScan  ][RT_DESPESA] := 0
		EndIf
		If aRateio[nScan][RT_FRETAUT ] < 0
			aRateio[nScan-1][RT_FRETAUT] += aRateio[nScan][RT_FRETAUT]
			aRateio[nScan  ][RT_FRETAUT] := 0
		EndIf
		If aRateio[nScan][RT_DESCONT] < 0
			aRateio[nScan-1][RT_DESCONT] += aRateio[nScan][RT_DESCONT]
			aRateio[nScan][RT_DESCONT  ] := 0
		EndIf
		If aRateio[nScan][RT_PDESCON] < 0
			aRateio[nScan-1][RT_PDESCON] += aRateio[nScan][RT_PDESCON]
			aRateio[nScan][RT_PDESCON  ] := 0
		EndIf
		If aRateio[nScan][RT_VLR_FRT  ] < 0
			aRateio[nScan-1][RT_VLR_FRT ] += aRateio[nScan][RT_VLR_FRT]
			aRateio[nScan  ][RT_VLR_FRT ] := 0
		EndIf
	Next nScan

	For nCntFor := 1 To Len(aPedido)
		If ( nScan := aScan(aRateio,{|x| x[1] == aPedido[nCntFor][1] .And. x[2] == aPedido[nCntFor][2] .And. x[3] == aPedido[nCntFor][3]}) ) > 0
			nDSFrete	:= 0
			nDSSeguro	:= 0
			nDSDespesa	:= 0
			nDSDescont	:= 0
			nDAFrete	:= 0
			nDASeguro	:= 0
			nDADespesa	:= 0
			nDADescont	:= 0
			//Reforça o arredondamento das despesas acessórias c/2 decimais, pois a MatXFis não trabalha c/mais casas decimais para estes tipos despesas
			For nX := 1 to Len(aRateio)
				// Frete
				nAuxCalc					:= NoRound(aRateio[nX,RT_FRETE], 2)
				nDSFrete					:= ( aRateio[nX,RT_FRETE] - nAuxCalc )
				nDAFrete					+= nDSFrete
				aRateio[nX,RT_FRETE]		:= NoRound(aRateio[nX,RT_FRETE], 2)
				If	Round(nDAFrete,2)		>= 0.01
					aRateio[nX,RT_FRETE]	+= 0.01
					nDAFrete				-= 0.01
				EndIf
				// Seguro
				nAuxCalc					:= NoRound(aRateio[nX,RT_SEGURO], 2)
				nDSSeguro					:= ( aRateio[nX][RT_SEGURO] - nAuxCalc )
				nDASeguro					+= nDSSeguro
				aRateio[nX,RT_SEGURO]		:= NoRound(aRateio[nX,RT_SEGURO], 2)
				If	Round(nDASeguro,2)		>= 0.01
					aRateio[nX,RT_SEGURO]	+= 0.01
					nDASeguro				-= 0.01
				EndIf
				// Despesa
				nAuxCalc					:= NoRound(aRateio[nX,RT_DESPESA], 2)
				nDSDespesa					:= ( aRateio[nX][RT_DESPESA] - nAuxCalc )
				nDADespesa					+= nDSDespesa
				aRateio[nX,RT_DESPESA]		:= NoRound(aRateio[nX,RT_DESPESA], 2)
				If	Round(nDADespesa,2)		>= 0.01
					aRateio[nX,RT_DESPESA]	+= 0.01
					nDADespesa				-= 0.01
				EndIf
				// Desconto
				nAuxCalc					:= NoRound(aRateio[nX,RT_DESCONT], 2)
				nDSDescont					:= ( aRateio[nX][RT_DESCONT] - nAuxCalc )
				nDADescont					+= nDSDescont
				aRateio[nX,RT_DESCONT]		:= NoRound(aRateio[nX,RT_DESCONT], 2)
				If	Round(nDADescont,2)		>= 0.01
					aRateio[nX,RT_DESCONT]	+= 0.01
					nDADescont				-= 0.01
				EndIf
			Next nX
		EndIf
	Next nCntFor

	If ( aEntry[EP_M460RAT] )
		aRateio := ExecBlock("M460RAT",.F.,.F.,aRateio)
	EndIf

   	If ( !(IsInCallStack("Ma410PvNfs")) .Or. ( lIsNItem .And. a410IsNItem() ) )
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Guarda os rateios efetuados para tratamento de quebra de nota fiscal    ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		For nX := 1 To Len(aRateio)
			nScan := aScan(aSavRat,{|x| x[SV_PEDIDO]==aRateio[nX][RT_PEDIDO]})
			If nScan == 0
				If lTpLibPed
					nPosPed := aScan(aPedido,{|x| x[1]==aRateio[nX][RT_PEDIDO]})
				Else
					nPosPed := 0
				EndIf
				aadd(aSavRat,{aRateio[nX][RT_PEDIDO],;
				              0,;
				              0,;
				              0,;
				              0,;
				              0,;
				              0,;
				              0,;
				              dDataBase,;
					          SubStr(Time(),1,5),;
				              IIf(nPosPed>0,aPedido[nPosPed][25],0),;
							  IIf(nPosPed>0,aPedido[nPosPed][26],0),;
							  IIf(nPosPed>0,aPedido[nPosPed][27],0),;
							  IIf(nPosPed>0,aPedido[nPosPed][28],0),;
							  IIf(nPosPed>0,aPedido[nPosPed][29],0),;
							  IIf(nPosPed>0,aPedido[nPosPed][30],0)})
				nScan := Len(aSavRat)
			EndIf
			aSavRat[nScan][SV_FRETE  ] += aRateio[nX][RT_FRETE  ]
			aSavRat[nScan][SV_FRETAUT] += aRateio[nX][RT_FRETAUT]
			aSavRat[nScan][SV_SEGURO ] += aRateio[nX][RT_SEGURO ]
			aSavRat[nScan][SV_DESPESA] += aRateio[nX][RT_DESPESA]
			aSavRat[nScan][SV_DESCONT] += aRateio[nX][RT_DESCONT]
			aSavRat[nScan][SV_DESPAC2] += aRateio[nX][RT_DESPAC2]
			aSavRat[nScan][SV_VLR_FRT] += aRateio[nX][RT_VLR_FRT]

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Acerta as decimais do % de desconto para a maior diferenca da nota ser  ³
			//³de 0,01 centavos.                                                       ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If nX + 1 <= Len(aRateio)
				aRateio[nX+1][RT_PDESCON] += aRateio[nX][RT_PDESCON]-NoRound(aRateio[nX][RT_PDESCON],8)
				aRateio[nX][RT_PDESCON]   := NoRound(aRateio[nX][RT_PDESCON],8)
			Else
				aRateio[nX][RT_PDESCON]   := NoRound(aRateio[nX][RT_PDESCON],8)
			EndIf
		Next nX
	EndIf

	// Tratamento para passar a MATXFIS o total do pedido
	aEval(aRateio,{|x| nTotAcre += x[RT_FRETE]+x[RT_SEGURO]+x[RT_DESPESA]})
	nTotAcre := a410Arred(nTotAcre, "D2_TOTAL")

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Verifica se o pedido ja nao foi processado por outra estacao            ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	dbSelectArea("SC9")
	dbSetOrder(1)
	DbGoto(aPvlNfs[1][8])
	If Empty(SC9->C9_NFISCAL) .And. !SC9->(Deleted()) .And. !SC9->(Eof())
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Gravacao da Nota Fiscal de Saida                                        ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		MaPvl2SF2(cSerie,cNumero,aPedido,lReajuste,lMoedaFre,lLct610.Or.lLct620,nValNeg,cPdv,cCgc,dDataMoe,cTypeDoc)

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Se o Parametro MV_VALDESP = .T. deve utilizar o rateio de despesas     ³
		//³ acessorias FRETE/SEGURO/DESPESA realizado pela MATXFIS sobrepondo o ra ³
		//³ teio realizado pelo MATA461 do array aRateio[RT_FRETE],[RT_SEGURO] e   ³
		//³ [RT_DESPESA] pela função MaRatDesp.                                    ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If SuperGetMV("MV_VALDESP",,.F.)
			MaRatDesp(aPvlNfs,@aRateio,lReajuste,dDataMoe)
		EndIf

		lRskSalPed := IIf(lRskSalPed, IIf(SC9->(ColumnPos("C9_TICKETC")) > 0, !Empty(SC9->C9_TICKETC), .F.), lRskSalPed)

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Gravacao do Item da Nota Fiscal de Saida                                ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		aGnreProd:= {}
		nTotItens := Len(aPvlNfs)
		For nCntFor := 1 To nTotItens
			dbSelectArea("SC9")
			MsGoto(aPvlNfs[nCntFor][8])
			If Empty(SC9->C9_NFISCAL) .And. !SC9->(Deleted()) .And. !SC9->(Eof())
		
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Rateio do Desconto negativo do item do pedido de venda              ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If aPvlNfs[nCntFor][5] > 0
					nItValNeg := SF4->(NoRound(nValNeg*a410Arred(If(aPvlNfs[nCntFor][4]==0,1,aPvlNfs[nCntFor][4])*aPvlNfs[nCntFor][5]/nTotal,"D2_TOTAL"),2))
				Else
					nItValNeg := 0
				EndIf
				nAcValNeg += nItValNeg
				If ( nCntFor == Len(aPvlNfs) .Or. (aPvlNfs[nCntFor+1][5]<0 .And. nCntFor+1==Len(aPvlNfs)))
					nItValNeg += nValNeg - nAcValNeg
				EndIf
				nItValNeg := Max(0,nItValNeg)
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Tratamento do calculo do IVA Ajustado³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				SB1->(dbSetOrder(1))
				If SB1->(MsSeek(cFilSB1+SC9->C9_PRODUTO))
				   lIVAAju := IIF(!lIsRussia .AND. SB1->B1_IVAAJU == '1',.T.,.F.)
				EndIf
				If	lIVAAju
					aNfOriLot := Ma460InfOr(SC9->C9_PEDIDO,SC9->C9_ITEM,SC9->C9_PRODUTO,SC9->C9_LOCAL,SC9->C9_QTDLIB,SC9->C9_QTDLIB2,SC9->C9_DATALIB,SC9->C9_LOTECTL,SC9->C9_NUMLOTE)
				EndIf
				If lCupFis .And. Len(aRetImpFi) > 5
					nPosItem 	:= ascan(aRetImpFi[6], { |x| x[1] == cItemNf } )
					If nPosItem > 0
						cAliq 		:= aRetImpFi[6][nPosItem][2]
					EndIf
				EndIf
				If lCupFis .And. Len(aRetImpFi) > 5
					nPosItem 	:= ascan(aRetImpFi[6], { |x| x[1] == cItemNf } )
					If nPosItem > 0
						cAliq 		:= aRetImpFi[6][nPosItem][2]
					EndIf
				EndIf
				
				MaPvl2Sd2(cItemNf,aPvlNfs,aRateio[nCntFor],@aTitulo,lAtuSa7,lReajuste,nItValNeg,nCntFor,cEmbExp,aCarga,bAtuPvl,aContrato,aMedicao,aNfOriLot,cAliq,dDataMoe,nTotAcre,aSxFci,aRatFin)
				
				If !lMTValAvC .And. ( SF4->F4_DUPLIC == "S" .And. !SC5->C5_TIPO$"DB" .And. !AllTrim(SC6->C6_BLQ)$"RS" )
					nMCusto := Iif(SA1->A1_MOEDALC > 0, SA1->A1_MOEDALC, nMvMCusto)
					nValAv	:=	SC9->C9_QTDLIB * SC9->C9_PRCVEN
					nSldLib += xMoeda(nValAV,SC5->C5_MOEDA,nMCusto,SC9->C9_DATALIB)
				EndIf	

				If (SB1->(FieldPos(cMV_B1M996))>0) .And. cB1M996 <> "1"
					cB1M996	:=	SB1->(FieldGet(FieldPos (cMV_B1M996)))
				EndIf
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Atendimento ao DECRETO 5.052, DE 08/01/2004 para o municipio de ARARAS. ³
				//³Mais especificamente o paragrafo unico do Art 2.                        ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If cB1FRETISS <> "2"
					cB1FRETISS	:=	SB1->B1_FRETISS
				EndIf
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Contabilizacao                                                          ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If ( lLct610 )
					cCtaRec := "" //Limpa a variavel devido processamento em laço

					nLctTotal += DetProva(nHdlPrv /*nHdlPrv*/, "610" /*cPadrao*/, "MATA460" /*cPrograma*/, cLote /*cLote*/,            /*nLinha*/,;
					                      /*lExecuta*/,        /*cCriterio*/,     /*lRateio*/,             /*cChaveBusca*/,            /*aCT5*/,;
					                      /*lPosiciona*/,      /*aFlagCTB*/,      /*aTabRecOri*/,          @_aDPrv461 /*aDadosProva*/, /*lSimula*/,;
					                      /*cTabCTK*/,         /*cTabCT2*/,       /*cTabCV3*/,             @cCtaRec /*cCtaRec*/)
					//-----------------------------------------------------------------------------------------
					// Adequacao para Gravar a Conta de Receita do Item da Nota, para uso no EFD-Contribuições
					//-----------------------------------------------------------------------------------------
					If lD2CtaRec .And. !Empty(cCtaRec)
						Aadd(aFlagCTB,{"D2_CTAREC",cCtaRec,"SD2",SD2->(Recno()),0,0,0})

						If !lNoCtaRef
							Mafisload("IT_CTAREC",cCtaRec,nCntFor)
						EndIf
					EndIf

					If ( lLct611 .And. xFilial("SD1") == SD1->D1_FILIAL .And. SD2->D2_NFORI == SD1->D1_DOC .And. SD2->D2_SERIORI == SD1->D1_SERIE .And. SD2->D2_ITEMORI == SD1->D1_ITEM	)
						dbSelectArea("SDE")
						dbSetOrder(1)
						MsSeek(xFilial("SDE")+SD1->D1_DOC+SD1->D1_SERIE+SD1->D1_FORNECE+SD1->D1_LOJA+SD1->D1_ITEM)
						While ( !Eof() .And. ;
							xFilial("SDE") == SDE->DE_FILIAL .And.;
							SD1->D1_DOC == SDE->DE_DOC .And.;
							SD1->D1_SERIE == SDE->DE_SERIE .And.;
							SD1->D1_FORNECE == SDE->DE_FORNECE .And.;
							SD1->D1_LOJA == SDE->DE_LOJA .And.;
							SD1->D1_ITEM == SDE->DE_ITEMNF)

							nLctTotal += DetProva(nHdlPrv /*nHdlPrv*/, "611" /*cPadrao*/, "MATA461" /*cPrograma*/, cLote /*cLote*/,            /*nLinha*/,;
							                      /*lExecuta*/,        /*cCriterio*/,     /*lRateio*/,             /*cChaveBusca*/,            /*aCT5*/,;
							                      /*lPosiciona*/,      /*aFlagCTB*/,      /*aTabRecOri*/,          @_aDPrv461 /*aDadosProva*/, /*lSimula*/,;
							                      /*cTabCTK*/,         /*cTabCT2*/,       /*cTabCV3*/,             /*cCtaRec*/)
							SDE->( DBSkip() )
						EndDo
					EndIf
				EndIf
				If ( lLct613 )
					dbSelectArea("AGH")
					AGH->(dbSetOrder(2)) //AGH->AGH_FILIAL + AGH->AGH_NUM + AGH->AGH_ITEMPD + AGH->AGH_ITEM
					If dbSeek(xFilial("AGH")+SD2->D2_DOC+SD2->D2_SERIE+SD2->D2_ITEM )
						While (!AGH->(EOF()) .And. ;
							xFilial("AGH") == AGH->AGH_FILIAL .And.;
							SD2->D2_DOC == AGH->AGH_NUM .And.;
							SD2->D2_SERIE == AGH->AGH_SERIE .And.;
							SD2->D2_ITEM == AGH->AGH_ITEMPD)

							nLctTotal += DetProva(nHdlPrv /*nHdlPrv*/, "613" /*cPadrao*/, "MATA460" /*cPrograma*/, cLote /*cLote*/,            /*nLinha*/,;
							                      /*lExecuta*/,        /*cCriterio*/,     /*lRateio*/,             /*cChaveBusca*/,            /*aCT5*/,;
							                      /*lPosiciona*/,      /*aFlagCTB*/,      /*aTabRecOri*/,          @_aDPrv461 /*aDadosProva*/, /*lSimula*/,;
							                      /*cTabCTK*/,         /*cTabCT2*/,       /*cTabCV3*/,             /*cCtaRec*/)
							AGH->(dbSkip())
						EndDo
					EndIf
				EndIf
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Grava os lancamentos nas contas orcamentarias SIGAPCO    ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				PcoDetLan("000101","01","MATA461")

				//Tratamento para geracao da guia de recolhimento ICMS-ST
				//Se F4_CREDST for = 4 o valor de ST nao eh exibido em nenhum lugar, entao
				//tambem nao posso gerar a GNRE para que nao fique inconsistente na apuracao.
				If SF4->F4_CREDST <> "4"
					nValICMSST += MaFisRet(nCntFor,'IT_VALSOL')
				EndIf

				//Acumula ISS abaixo do minimo portanto nao descontou do total do titulo.
				If (MaFisRet(,"NF_RECISS")=="1" .And. lDescISS .And. lTpAbISS) .And.;
					!(SF4->F4_FRETISS == "2" .And. SA1->A1_FRETISS == "2")
					nValISS := MaFisRet(nCntFor,'IT_VALISS')
					If nValISS <= nVRetISS
						nISSNDesc += nValISS
					EndIf
				EndIf

	   			//Tratamento para geracao da guia de recolhimento ICMS Próprio
				nValICM += MaFisRet(nCntFor,'IT_VALICM')
				//Ec 87/2015 - Difal ICMS
				nVDifal	  += MaFisRet(nCntFor, 'IT_DIFAL')
				nVFCDif	  += MaFisRet(nCntFor, 'IT_VFCPDIF')
				nVFECPST  += MaFisRet(nCntFor, 'IT_VFECPST')
                nVlCRDTran+= MaFisRet(nCntFor, 'LF_CRDTRAN')  //Geração de GNRE com redução do ICMS em 20% Conforme Convênio ICMS 106/96 somente para os Estado.
				//Tratamento para guia de recolhimento ICMS-ST por Produto
  				nPos := aScan(aGnreProd, {|x| x[1]==aPvlNfs[nCntFor][6]})
   				If nPos == 0
					aadd(aGnreProd,{aPvlNfs[nCntFor][6],MaFisRet(nCntFor,'IT_VALSOL'), IIF(Type("MV_PAR23") == "N" .And. MV_PAR23 == 1,cItemNf,"")})
					aadd(aGnreFpSt,{aPvlNfs[nCntFor][6],MaFisRet(nCntFor,'IT_VFECPST'),IIF(Type("MV_PAR23") == "N" .And. MV_PAR23 == 1,cItemNf,"")})
					aadd(aGnreDifal,{aPvlNfs[nCntFor][6],MaFisRet(nCntFor,'IT_DIFAL'), IIF(Type("MV_PAR23") == "N" .And. MV_PAR23 == 1,cItemNf,"")})
					aadd(aGnreFecp,{aPvlNfs[nCntFor][6],MaFisRet(nCntFor,'IT_VFCPDIF'),IIF(Type("MV_PAR23") == "N" .And. MV_PAR23 == 1,cItemNf,"")})
				Else
  			   		aGnreProd[nPos][2] += MaFisRet(nCntFor,'IT_VALSOL')
					aGnreFpSt[nPos][2] += MaFisRet(nCntFor,'IT_VFECPST')
					aGnreDifal[nPos][2] += MaFisRet(nCntFor,'IT_DIFAL')
					aGnreFecp[nPos][2] += MaFisRet(nCntFor,'IT_VFCPDIF')
  			   	Endif
  			   	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Desconta o Valor do ICMS DESONERADO do valor do Item D2_PRCVEN         ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If SF4->F4_AGREG$"R"
					nDedICM += MaFisRet(nCntFor,'IT_DEDICM')
    			EndIf

    			// Soh acumulo o PROTEGE-GO do documento se for configurada a apuracao por
    			// documento - MV_GERPROT = .T.
    			If SuperGetMV("MV_GERPROT",,.F.)
    				nValProt += MaFisRet(nCntFor, "IT_VALPRO")
    			EndIf

				cItemNf := Soma1(cItemNf,2)

			EndIf
		Next nCntFor
		If !InTransact()
			RecLock("SF2")
		EndIf

		MaFisWrite()
		MaAvalSF2()

		If !lMTValAvC .And. !lRskSalPed
			If SA1->(DbSeek(xFilial("SA1") + SC5->C5_CLIENTE + SC5->C5_LOJACLI))
				lTrvSA1 := IIf(cPaisLoc == "BRA" .And. lFATTRVSA1, ExecBlock("FATTRVSA1", .F., .F., {xFilial("SA1"), SA1->A1_COD, SA1->A1_LOJA}), .T.)
				If lTrvSA1
					Reclock("SA1",.F.)
					SA1->A1_SALPEDL -= nSldLib 
					SA1->(MsUnLock())
				EndIf
			EndIf
		EndIf
		
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Tratamento para Legislação de Carga Tributária - Lei nº 12.741/2012 (Lei da Transparência)        ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If !lIsRussia
			SF2->F2_TIPIMP := cMvFisCTrb
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Desconta o Valor do ICMS DESONERADO do valor do Item D2_PRCVEN         ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If nDedICM > 0
			SF2->F2_VALMERC -= nDedICM
		EndIf

		MAFISCDA(,2)	//Gravacao dos lancamentos fiscais

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//Atualiza dados dos complementos SPED automaticamente
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		If lMvAtuComp
			AtuComp(SF2->F2_DOC,SF2->F2_SERIE,SF2->F2_ESPECIE,SF2->F2_CLIENTE,SF2->F2_LOJA,"S",SF2->F2_TIPO)
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Gravacao do Fiscal                                                      ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		MaFisAtuSF3(1,"S",SF2->(RecNo()),,cPdv)

		// Tratativa criada devido PE MAZVSTDF
		If lMazvstdf
			
			lIcmsSt  := nValICMSST > 0 .And. nValICMSST < 1
			lFecopSt := nVFecpST > 0 .And. nVFecpST < 1
			lFcopDif := nVFCDif > 0 .And. nVFCDif < 1

			If lIcmsSt .Or. lFecopST .Or. lFcopDif

				If lIcmsSt 
					nValICMSST := 0
				EndIf

				If lFecopSt
					nVFecpST := 0
				EndIf

				If lFcopDif
					nVFCDif  := 0
				EndIf

				For nX := 1 To nTotItens
					If lIcmsSt .And. SF4->F4_CREDST <> "4"
						nValICMSST += MaFisRet(nX, 'IT_VALSOL') // Recuperar o valor da referencia, para caso não tenha passado pelo pto de entrada ou não.
					EndIf

					If lFecopSt
						nVFecpST += MaFisRet(nX, 'IT_VFECPST') // Recuperar o valor da referencia, para caso não tenha passado pelo pto de entrada ou não.
					EndIf

					If lFcopDif
						nVFCDif	+= MafisRet(nX,'IT_VFCPDIF') // Recuperar o valor da referencia, para caso não tenha passado pelo pto de entrada ou não.
					EndIf
				Next nX	
			EndIf
		
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Tratamento do artigo 65 do RICMS PR³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
 		If SF2->F2_TIPO == "N"
			A461ART65(SF2->F2_CLIENTE, SF2->F2_LOJA, SF2->F2_EMISSAO, SF2->F2_DOC, SF2->F2_SERIE, cNumero, aGnre, aRecTit, lConfTit,SF2->F2_EST)
		EndIf

		// Nova funcao de geracao de titulos/guias a partir da CDA.
		If cPaisLoc == "BRA" .And. _lFisTitCDA

			aTitCDA := FisTitCDA("MATA460A", "S", SF2->(RecNo()))

			// Conforme os titulos gerados pela FisTitCDA
			// zero o valor correspondente para anular a geracao
			// "legada" dos titulos.

			// aTitCDA[1]: Foi gerado titulo/GNRE de ICMS Proprio.
			If aTitCDA[1]
				nValICM := 0
			EndIf

			// aTitCDA[2]: Foi gerado titulo/GNRE de ICMS-ST.
			If aTitCDA[2]
				nValICMSST := 0
			EndIf

			// aTitCDA[3]: Foi gerado titulo/GNRE de DIFAL.
			If aTitCDA[3]
				nVDifal := 0
			EndIf

			// aTitCDA[4]: Foi gerado titulo/GNRE de FECP-DIFAL.
			If aTitCDA[4]
				nVFCDif := 0
			EndIf

		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Gravacao do ICMS ST - Imposto Retido(ICR)                               ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If nValICMSST > 0 .And. cPaisLoc=="BRA" .And. cModulo $ "FAT.OMS.EST" .And. SF2->F2_TIPO <>"D"
			lGRec     := Iif(ValType(MV_PAR18)<>"N",.F.,(mv_par18==1))
			lTit      := Iif(ValType(MV_PAR17)<>"N",.F.,(mv_par17==1))
			lGRecProd := Iif(ValType(MV_PAR23)<>"N",.F.,(mv_par23==1))
			lTitProd  := Iif(ValType(MV_PAR22)<>"N",.F.,(mv_par22==1))
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Gera Guia de Recolhimento ou Titulo ICMS no Contas a pagar quando nao for do mesmo Estado ³
			//³e que o Estado Destino nao pos.suir IE no parametro da substituicao tributaria             ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If (SuperGetMV("MV_ESTADO")<>SF2->F2_EST .And. Empty(IESubTrib(SF2->F2_EST)))
				If (lGRecProd .Or. lTitProd)
		   			nMes      := Month(SF2->F2_EMISSAO)
					nAno      := Year(SF2->F2_EMISSAO)
					aDatas    := DetDatas(nMes,nAno,3,1)
					dDtIni	  := aDatas[1]
					dDtFim	  := aDatas[2]
					dDtVenc	  := DataValida(aDatas[2]+1,.t.)
					lLancCont := (MV_PAR03==1)
					//Armazenamento dos dados para ser utilizado na Guia de Recolhimento e no COntas a Pagar
					aadd(aDSF2,{SF2->F2_DOC,SF2->F2_SERIE,SF2->F2_CLIENTE,SF2->F2_LOJA,SF2->F2_TIPO,"2",SF2->F2_EST,SF2->F2_ESPECIE})
					//Armazenamento dos dados para ser utilizado na Guia de Recolhimento por Produto
					For nX := 1 To Len(aGnreProd)
						If !CFC->(MsSeek(cFilCFC+cMvEstado+SF2->F2_EST+aGnreProd[nX,1]))
							GravaTit(lTitProd,aGnreProd[nX, 2],"ICMS","IC",cLcPadTit,dDtIni,dDtFim,dDtVenc,1,lGRecProd,nMes,nAno,nVlrIcm,aGnreProd[nX, 2],"MATA460A",lLancCont,@cNumero,@aGNRE,,,SF2->F2_EST,,,,,@aRecTit,@lConfTit,0,aDSF2,,,,aGnreProd[nX, 1],,,,,,,,,,,,,,,,,,,aGnreProd[nX, 3],aGnreFpSt[nX, 2])
						Else
			                //Tratamento para guia de recolhimento ICMS-ST por Numero de Convênio
							If CFC->(ColumnPos("CFC_NUMCON")) > 0 .And. CFC->(!Empty(CFC_NUMCON))
				  				nPosGnrP:= aScan(aGnreConv, {|x| x[1]==CFC->CFC_NUMCONV})
								If nPosGnrP == 0
									aadd(aGnreConv,{CFC->CFC_NUMCONV,aGnreProd[nX,2],aGnreProd[nX,3],aGnreFpSt[nX,2]})
								Else
				  			   		aGnreConv[nPosGnrP,2] += aGnreProd[nX,2]
									aGnreConv[nPosGnrP,4] += aGnreFpSt[nX,2]
			  				   	Endif
			  				Else
			  					GravaTit(lTitProd,aGnreProd[nX, 2],"ICMS","IC",cLcPadTit,dDtIni,dDtFim,dDtVenc,1,lGRecProd,nMes,nAno,nVlrIcm,aGnreProd[nX, 2],"MATA460A",lLancCont,@cNumero,@aGNRE,,,SF2->F2_EST,,,,,@aRecTit,@lConfTit,0,aDSF2,,,,aGnreProd[nX, 1],,,,,,,,,,,,,,,,,,,aGnreProd[nX, 3],aGnreFpSt[nX, 2])
							Endif
				  		Endif
				   	Next nX
				   	// Gera Guias de Recolhimento Agrupadas por numero de convênio.
				   	If !Empty(aGnreConv)
					   	For nX := 1 To Len(aGnreConv)
						   	GravaTit(lTitProd,aGnreConv[nX,2],"ICMS","IC",cLcPadTit,dDtIni,dDtFim,dDtVenc,1,lGRecProd,nMes,nAno,nVlrIcm,aGnreConv[nX,2],"MATA460A",lLancCont,@cNumero,@aGNRE,,,SF2->F2_EST,,,,,@aRecTit,@lConfTit,0,aDSF2,,,,aGnreConv[nX,1],,,,,,,,,,,,aGnreConv[nX, 1],,,,,,,,,,,,,,,,,,,aGnreConv[nX, 3],aGnreConv[nX, 4])
						Next nX
					Endif
		    	ElseIf (lTit .Or. lGRec)
					//Unificação GNRE RS https://tdn.totvs.com.br/display/public/ConSeg/RS+-+GNRE+-+VALORES+AGLUTINADOS
					If _lComplTrib .And. SF2->F2_TIPO == "I" .And. SF2->F2_EST $ "RJ|RS" 
						nVlrIcmST := nValICMSST + nVFECPST
					Else
						nVlrIcmST := nValICMSST
					EndIf
					If SF2->F2_EST $ "RJ|RS"
						nValFcpSt := nVFECPST // Pego o valor do FECP ST quando o estado for RJ para levar no ultimo parametro do gravatit
						nVFecpST := 0
					Else
						nValFcpSt := 0
					EndIf
					nMes      := Month(SF2->F2_EMISSAO)
					nAno      := Year(SF2->F2_EMISSAO)
					aDatas    := DetDatas(nMes,nAno,3,1)
					dDtIni	  := aDatas[1]
					dDtFim	  := aDatas[2]
					dDtVenc	  := DataValida(aDatas[2]+1,.t.)
					lLancCont := (MV_PAR03==1)

					//Armazenamento dos dados para ser utilizado na Guia de Recolhimento e no COntas a Pagar
					aadd(aDSF2,{SF2->F2_DOC,SF2->F2_SERIE,SF2->F2_CLIENTE,SF2->F2_LOJA,SF2->F2_TIPO,"2",SF2->F2_EST,SF2->F2_ESPECIE})
			    	GravaTit(lTit,nVlrIcmST-nVFecpST ,"ICMS","IC",cLcPadTit,dDtIni,dDtFim,dDtVenc,1,lGRec,nMes,nAno,nVlrIcm,nVlrIcmST-nVFecpST,"MATA460A",lLancCont,@cNumero,@aGNRE,,,SF2->F2_EST,,,,,@aRecTit,@lConfTit,0,aDSF2,,,,aGnreProd[1,1],,,,,,,,,,,,,,,,,,,,nValFcpSt)
					If nVFecpST > 0
						GravaTit(lTit,nVFecpST,"ICMS","IC",cLcPadTit,dDtIni,dDtFim,dDtVenc,1,lGRec,nMes,nAno,nVlrIcm,nVFecpST,"MATA460A",lLancCont,@cNumero,@aGNRE,,,SF2->F2_EST,,.T.,,,@aRecTit,@lConfTit,0,aDSF2,,,,aGnreProd[1,1])
					Endif
				Endif
			Endif

		Endif
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Gravacao do ICMS Proprio    ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If nValICM > 0 .And. cPaisLoc == "BRA"
			lGRecICMS := Iif(ValType(MV_PAR20)<>"N",.F.,(mv_par20==1))
			lTitICMS  := Iif(ValType(MV_PAR19)<>"N",.F.,(mv_par19==1))

			If nModulo == 43
				If _lTmGuiaGRNE
					TmGuiaGRNE(nValICMSST, nValICM, nVDifal, , nVFCDif, nVlCRDTran)
				Else
					cMVTmsGnre:= SuperGetMV("MV_TMSGNRE",,"")
					Pergunte("TMB200",.F.)
					lLancCont := Iif(ValType(MV_PAR04)<>"N",.F.,(MV_PAR04==1)) //-- Lanc.Contab.On-Line ?
					lTitICMS  := Iif(ValType(MV_PAR05)<>"N",.F.,(MV_PAR05==1)) //-- Gera Titulo ICMS Proprio ?
					lGRecICMS := Iif(ValType(MV_PAR06)<>"N",.F.,(MV_PAR06==1)) //-- Gera Guia ICMS Proprio ?
					Pergunte("MT460A",.F.)
					cUFOrigem := MaFisRet(,"NF_UFORIGEM")
					If (GetMV("MV_ESTADO")<>cUFOrigem .And. (lTitICMS .Or. lGRecICMS)) .And. Empty(IESubTrib(SF2->F2_EST))
						nVlrIcm   := SF2->F2_VALICM
						nMes      := Month(SF2->F2_EMISSAO)
						nAno      := Year(SF2->F2_EMISSAO)
						aDatas    := DetDatas(nMes,nAno,3,1)
						dDtIni    := aDatas[1]
						dDtFim    := aDatas[2]
						dDtVenc   := DataValida(aDatas[2]+1,.T.)
						aadd(aDSF2,{SF2->F2_DOC,SF2->F2_SERIE,SF2->F2_CLIENTE,SF2->F2_LOJA,SF2->F2_TIPO,"2",SF2->F2_EST,SF2->F2_ESPECIE})
						GravaTit(lTitICMS,nVlrIcm,"ICMS","IC",cLcPadTit,dDtIni,dDtFim,dDtVenc,1,lGRecICMS,nMes,nAno,nVlrIcm,0,"MATA460A",;
								lLancCont,@cNumero,@aGNRE,,,,,,,,@aRecTit,@lConfTit,0,aDSF2,,,,,,,,,,,,,,,,,(nThreads > 0))
					Else
						If !Empty(cMVTmsGnre)
							If (cMVTmsGnre $ cUFOrigem .And. (lTitICMS .Or. lGRecICMS))
								nVlrIcm   := SF2->F2_VALICM
								nMes      := Month(SF2->F2_EMISSAO)
								nAno      := Year(SF2->F2_EMISSAO)
								aDatas    := DetDatas(nMes,nAno,3,1)
								dDtIni    := aDatas[1]
								dDtFim    := aDatas[2]
								dDtVenc   := DataValida(aDatas[2]+1,.T.)
								aadd(aDSF2,{SF2->F2_DOC,SF2->F2_SERIE,SF2->F2_CLIENTE,SF2->F2_LOJA,SF2->F2_TIPO,"2",SF2->F2_EST,SF2->F2_ESPECIE})
								GravaTit(lTitICMS,nVlrIcm,"ICMS","IC",cLcPadTit,dDtIni,dDtFim,dDtVenc,1,lGRecICMS,nMes,nAno,nVlrIcm,0,"MATA460A",;
										lLancCont,@cNumero,@aGNRE,,,,,,,,@aRecTit,@lConfTit,0,aDSF2,,,,,,,,,,,,,,,,,(nThreads > 0))
							EndIf
						EndIf
					EndIf
				EndIf
			ElseIf (SuperGetMV("MV_ESTADO")<>SF2->F2_EST .And. (lTitICMS  .Or. lGRecICMS));
			.or. ((SM0->M0_PRODRUR == '1' .AND. SM0->M0_TPINSC == 3) .AND. SuperGetMV("MV_ESTADO")==SF2->F2_EST .And. (lTitICMS .Or. lGRecICMS)) //Tratamento para geração de ICMS próprio quando o Emitente é Pessoa Fisica e Produtor Rural para Venda dentro do mesmo Estado
				nVlrIcm	 := SF2->F2_VALICM
				nMes      := Month(SF2->F2_EMISSAO)
				nAno      := Year(SF2->F2_EMISSAO)
				aDatas    := DetDatas(nMes,nAno,3,1)
				dDtIni	  := aDatas[1]
				dDtFim	  := aDatas[2]
				dDtVenc	  := DataValida(aDatas[2]+1,.t.)
				lLancCont := Iif(ValType(MV_PAR03)<>"N",.F.,(mv_par03==1))
				aadd(aDSF2,{SF2->F2_DOC,SF2->F2_SERIE,SF2->F2_CLIENTE,SF2->F2_LOJA,SF2->F2_TIPO,"2",SF2->F2_EST,SF2->F2_ESPECIE})
				GravaTit(lTitICMS,nVlrIcm,"ICMS","IC",cLcPadTit,dDtIni,dDtFim,dDtVenc,1,lGRecICMS,nMes,nAno,nVlrIcm,0,"MATA460A",lLancCont,@cNumero,@aGNRE,,,,,,,,@aRecTit,@lConfTit,0,aDSF2)
			Endif
			//Gnre EC87/2015
			//nVDifal esta variavel é preenchida pela função MaPvlNfs2, para casos que escrituraçao das notas teve alteração
			//apos processamento dos itens deve ser considerado conteudo Atualizado do livro (SF3).
			If ((nVDifal > 0 .And. MaFisRet(nCntFor,'NF_DIFAL') > 0) .Or. (nVFCDif > 0 .And. MaFisRet(nCntFor,'NF_VFCPDIF') > 0)) .And. !nModulo == 43
				/*/ 
				    Tratamento para gravação do Cod Prod quando selecionado a geração da Guia DIFAL por Produto
				/*/
				lGRecProd := Iif(ValType(MV_PAR23)<>"N",.F.,(mv_par23==1))
				lTitProd  := Iif(ValType(MV_PAR22)<>"N",.F.,(mv_par22==1))
				IF (lGRecProd .Or. lTitProd)
					lGDifal	:= Iif(ValType(MV_PAR24)<>"N",.F.,(mv_par24==1))
					lGFcpDif:= Iif(ValType(MV_PAR25)<>"N",.F.,(mv_par25==1))
					cEstSum := SuperGetMV("MV_SOMAGNR",,"")
					If Empty(IESubTrib(SF2->F2_EST,.T.)) .And. SF2->F2_TIPOCLI=="F"	.And. GetMV("MV_ESTADO")<>SF2->F2_EST .and. lGDifal
						For nX :=  1 To Len(aGnreDifal)							
							nVlrdifal := nVDifal
							nDifFecp  := nVFCDif
							nMes      := Month(SF2->F2_EMISSAO)
							nAno      := Year(SF2->F2_EMISSAO)
							aDatas    := DetDatas(nMes,nAno,3,1)
							dDtIni	  := aDatas[1]
							dDtFim	  := aDatas[2]
							dDtVenc	  := DataValida(aDatas[2]+1,.t.)
							lLancCont := Iif(ValType(MV_PAR03)<>"N",.F.,(mv_par03==1))
							aadd(aDSF2,{SF2->F2_DOC,SF2->F2_SERIE,SF2->F2_CLIENTE,SF2->F2_LOJA,SF2->F2_TIPO,"2",SF2->F2_EST,SF2->F2_ESPECIE})
							If SF2->F2_EST $ cEstSum
								GravaTit(lTitProd,aGnreDifal[nX,2]+aGnreFecp[nX,2],"ICMS","IC",cLcPadTit,dDtIni,dDtFim,dDtVenc,1,lGDifal,nMes,nAno,0,aGnreDifal[nX,2]+aGnreFecp[nX,2],"MATA460A",lLancCont,@cNumero,@aGNRE,,,SF2->F2_EST,,,.T.,,@aRecTit,@lConfTit,0,aDSF2,,,,aGnreDifal[nX, 1],,,,,,,,,,.T.,,,,,,,,,aGnreDifal[nX, 3],aGnreFecp[nX,2])
							Else
								GravaTit(lTitProd,aGnreDifal[nX,2],"ICMS","IC",cLcPadTit,dDtIni,dDtFim,dDtVenc,1,lGDifal,nMes,nAno,0,aGnreDifal[nX,2],"MATA460A",lLancCont,@cNumero,@aGNRE,,,SF2->F2_EST,,,.T.,,@aRecTit,@lConfTit,0,aDSF2,,,,aGnreDifal[nX, 1],,,,,,,,,,.T.,,,,,,,,,aGnreDifal[nX, 3])
								If  nVFCDif	 > 0 .And. lGFcpDif
									GravaTit(lTitProd,aGnreFecp[nX,2],"ICMS","IC",cLcPadTit,dDtIni,dDtFim,dDtVenc,1,lGFcpDif,nMes,nAno,0,aGnreFecp[nX,2],"MATA460A",lLancCont,@cNumero,@aGNRE,,,SF2->F2_EST,,.T.,,,@aRecTit,@lConfTit,0,aDSF2,,,,aGnreDifal[nX, 1],,,,,,,,,,.T.,,,,,,,,,aGnreDifal[nX, 3])
								EndIf
							EndIf
						Next nX
					EndIf
				ElseIf Empty(IESubTrib(SF2->F2_EST,.T.)) .And. SF2->F2_TIPOCLI=="F"	.And. GetMV("MV_ESTADO")<>SF2->F2_EST
					lGDifal	:= Iif(ValType(MV_PAR24)<>"N",.F.,(mv_par24==1))
					lGFcpDif	:= Iif(ValType(MV_PAR25)<>"N",.F.,(mv_par25==1))
					If lGDifal
						nVlrdifal := nVDifal
						nDifFecp  := nVFCDif
						nMes      := Month(SF2->F2_EMISSAO)
						nAno      := Year(SF2->F2_EMISSAO)
						aDatas    := DetDatas(nMes,nAno,3,1)
						dDtIni	  := aDatas[1]
						dDtFim	  := aDatas[2]
						dDtVenc	  := DataValida(aDatas[2]+1,.t.)
						lLancCont := Iif(ValType(MV_PAR03)<>"N",.F.,(mv_par03==1))
						aadd(aDSF2,{SF2->F2_DOC,SF2->F2_SERIE,SF2->F2_CLIENTE,SF2->F2_LOJA,SF2->F2_TIPO,"2",SF2->F2_EST,SF2->F2_ESPECIE})
						If SF2->F2_EST $ SuperGetMV("MV_SOMAGNR",,"")
							GravaTit(Iif(ValType(MV_PAR17)<>"N",.F.,(mv_par17==1)),nVlrdifal+nDifFecp,"ICMS","IC",cLcPadTit,dDtIni,dDtFim,dDtVenc,1,lGDifal,nMes,nAno,0,nVlrdifal+nDifFecp,"MATA460A",lLancCont,@cNumero,@aGNRE,,,SF2->F2_EST,,,.T.,,@aRecTit,@lConfTit,0,aDSF2,,,,aGnreDifal[1, 1],,,,,,,,,,.T.,,,,,,,,,,nDifFecp)
						Else
							GravaTit(Iif(ValType(MV_PAR17)<>"N",.F.,(mv_par17==1)),nVlrdifal,"ICMS","IC",cLcPadTit,dDtIni,dDtFim,dDtVenc,1,lGDifal,nMes,nAno,0,nVlrdifal,"MATA460A",lLancCont,@cNumero,@aGNRE,,,SF2->F2_EST,,,.T.,,@aRecTit,@lConfTit,0,aDSF2,,,,aGnreDifal[1, 1],,,,,,,,,,.T.)
							If  nVFCDif	 > 0 .And. lGFcpDif
								GravaTit(Iif(ValType(MV_PAR17)<>"N",.F.,(mv_par17==1)),nDifFecp,"ICMS","IC",cLcPadTit,dDtIni,dDtFim,dDtVenc,1,lGFcpDif,nMes,nAno,0,nDifFecp,"MATA460A",lLancCont,@cNumero,@aGNRE,,,SF2->F2_EST,,.T.,,,@aRecTit,@lConfTit,0,aDSF2,,,,aGnreDifal[1, 1],,,,,,,,,,.T.)
							EndIf
						EndIf
					Endif
				EndIf
			EndIf
		Endif

		If cPaisLoc == "BRA" .And. nValProt > 0
			// Gera GNRE do PROTEGE-GO.
			If Iif(ValType(MV_PAR26)<>"N",.F.,(mv_par26==1))
				If SuperGetMV("MV_ESTADO") <> SF2->F2_EST
					nMes      := Month(SF2->F2_EMISSAO)
					nAno      := Year(SF2->F2_EMISSAO)
					aDatas    := DetDatas(nMes,nAno,3,1)
					dDtIni	  := aDatas[1]
					dDtFim	  := aDatas[2]
					dDtVenc	  := DataValida(aDatas[2]+1,.t.)
					lLancCont := Iif(ValType(MV_PAR03)<>"N",.F.,(mv_par03==1))
			    	aadd(aDSF2,{SF2->F2_DOC,SF2->F2_SERIE,SF2->F2_CLIENTE,SF2->F2_LOJA,SF2->F2_TIPO,"2",SF2->F2_EST,SF2->F2_ESPECIE})
			    	GravaTit(.T.,nValProt,"ICMS","PR",cLcPadTit,dDtIni,dDtFim,dDtVenc,1,.T.,nMes,nAno,nValProt,0,"MATA460A",lLancCont,@cNumero,@aGNRE,,,,,,,,@aRecTit,@lConfTit,0,aDSF2)
				EndIf
			EndIf
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Gravacao do Financeiro                                                  ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If ( aTitulo[_VLRTIT_] > 0 )
			lFatSE1 := Eval(bFatSE1)
			If nModulo == 43 .And. (cTMSMFat == "2" .Or. (cTMSMFat == "1" .And. cTMSERP == "1")) .And. !lFatSE1
				SF2->F2_VALFAT := aTitulo[_VLRTIT_]
			Else
				MaNfs2Fin(aTitulo,nMoeda,cBanco,SC5->C5_NUM,bAtuFin,(lLct610.Or.lLct620),Iif(!lIsRussia,SC5->C5_FORNISS,""), MaFisRet(,"NF_RECISS"), cB1M996,cB1FRETISS,aContrato,aMedicao,@aRecSE1Adt,dDataMoe,nHdlPrv,nISSNDesc,aRatFin,aNatRend)
			EndIf
		Else
			//Geracao de Titulos a Pagar no Financeiro para FUNRURAL (RAT/SENAR/INSS) quando o TES da NF nao gerar duplicata
			If cPaisLoc == "BRA" .And. Iif(ValType(MV_PAR27) <> "N",.F.,(MV_PAR27 == 1)) .And. (SF2->F2_CONTSOC > 0 .Or. SF2->F2_VLSENAR > 0 .Or. SF2->F2_VALINSS > 0)
				aAreaSED := SED->(GetArea())
				aAreaSA2 := SA2->(GetArea())

				cCodForTit := SuperGetMV("MV_FORINSS",,"")
				cCodForTit := Iif(!Empty(cCodForTit),Padr(cCodForTit,GetSX3Cache("A2_COD","X3_TAMANHO")),Padr("INPS",GetSX3Cache("A2_COD","X3_TAMANHO")))+"00"
				SA2->(DbSetOrder(1))
				If SA2->(DbSeek(xFilial("SA2")+cCodForTit))
					dVenFun  := SF2->F2_EMISSAO+28
					If Month(dVenFun) == Month(SF2->F2_EMISSAO)
						dVenFun := dVenFun+28
					EndIf
					nTamData := If(Len(Dtoc(dVenFun))==10,7,5)
					dVenFun  := Ctod(StrZero(SuperGetMV("MV_DIAFUN"),2)+"/"+Subs(Dtoc(dVenFun),4,nTamData))

					aDadosAut:={{"E2_PREFIXO",Padr(&(SuperGetMV("MV_1DUPREF")),GetSX3Cache("E2_PREFIXO","X3_TAMANHO")),NIL},;
								{"E2_NUM"    ,SF2->F2_DOC                                             ,NIL},;
								{"E2_PARCELA","  "                                                    ,NIL},;
								{"E2_NATUREZ",""                                                      ,NIL},;
								{"E2_TIPO"   ,""                                                      ,NIL},;
								{"E2_EMISSAO",SF2->F2_EMISSAO                                         ,NIL},;
								{"E2_VALOR"  ,0                                                       ,NIL},;
								{"E2_VENCTO" ,DataValida(dVenFun,.F.)                                 ,NIL},;
								{"E2_SALDO"  ,0                                                       ,NIL},;
								{"E2_VENCREA",DataValida(dVenFun,.F.)                                 ,NIL},;
								{"E2_VENCORI",dVenFun                                                 ,NIL},;
								{"E2_EMIS1"  ,dDataBase                                               ,NIL},;
								{"E2_FORNECE",SA2->A2_COD                                             ,NIL},;
								{"E2_LOJA"   ,SA2->A2_LOJA                                            ,NIL},;
								{"E2_NOMFOR" ,SA2->A2_NOME                                            ,NIL},;
								{"E2_MOEDA"  ,1                                                       ,NIL},;
								{"E2_VLCRUZ" ,0                                                       ,NIL},;
								{"E2_ORIGEM" ,"MATA460"                                               ,NIL},;
								{"E2_LA"     ,"S"                                                     ,NIL},;
								{"E2_FILORIG",cFilAnt                                                 ,NIL}}

					//Gera título FUNRURAL/GILRAT
					If SF2->F2_CONTSOC > 0
						cNatureza := SuperGetMV("MV_CSS",,"")
						cNatureza := Iif(!Empty(cNatureza),Padr(cNatureza,cTamNatur),Padr("CSS",cTamNatur))
						SED->(DbSetOrder(1))
						If SED->(DbSeek(xFilial("SED")+cNatureza))
							aDadosAut[4][2] := cNatureza
							aDadosAut[5][2] := "FUN"
							aDadosAut[7][2] := SF2->F2_CONTSOC
							aDadosAut[9][2] := SF2->F2_CONTSOC
							aDadosAut[17][2]:= SF2->F2_CONTSOC
							MsExecAuto({|x,y,z| FINA050(x,y,z)},aDadosAut,,3)
						EndIf
					EndIf

					//Gera título SENAR
					If SF2->F2_VLSENAR > 0
						cNatureza := SuperGetMV("MV_APSENAR",,"")
						cNatureza := Iif(!Empty(cNatureza),Padr(cNatureza,cTamNatur),Padr("SENAR",cTamNatur))
						SED->(DbSetOrder(1))
						If SED->(DbSeek(xFilial("SED")+cNatureza))
							aDadosAut[4][2] := cNatureza
							aDadosAut[5][2] := "SEN"
							aDadosAut[7][2] := SF2->F2_VLSENAR
							aDadosAut[9][2] := SF2->F2_VLSENAR
							aDadosAut[17][2]:= SF2->F2_VLSENAR
							MsExecAuto({|x,y,z| FINA050(x,y,z)},aDadosAut,,3)
						EndIf
					EndIf

					//Gera título INSS
					If SF2->F2_VALINSS > 0
						cNatureza := &(SuperGetMV("MV_INSS",,""))
						cNatureza := Iif(!Empty(cNatureza),Padr(cNatureza,cTamNatur),Padr("INSS",cTamNatur))
						SED->(DbSetOrder(1))
						If SED->(DbSeek(xFilial("SED")+cNatureza))
							aDadosAut[4][2] := cNatureza
							aDadosAut[5][2] := MVINSS
							aDadosAut[7][2] := SF2->F2_VALINSS
							aDadosAut[9][2] := SF2->F2_VALINSS
							aDadosAut[17][2]:= SF2->F2_VALINSS
							MsExecAuto({|x,y,z| FINA050(x,y,z)},aDadosAut,,3)
						EndIf
					EndIf
				EndIf
				SED->(RestArea(aAreaSED))
				SA2->(RestArea(aAreaSA2))
			EndIf

			//Geracao de Titulos a Pagar no Financeiro quando o TES da NF nao gerar duplicata
			If cPaisLoc == "BRA" .And. Iif(ValType(MV_PAR27) <> "N",.F.,(MV_PAR27 == 1)) .And. lTrbGen .And.;
			   !Empty(MaFisScan("NF_TRIBGEN",.F.)) .And. _lFGrvImpFi .And. SF2->(ColumnPos("F2_IDNF")) > 0

				aTGCalc		:= {}
				aTGRet		:= {}
				aTGCalcRet	:= {}
				aTGCalcRec  := {}

				//Verifico se a nova função existe caso não executa o legado
				If FindFunction("FisRetGen")
			 		//Obtém todos os tributos genéricos calculados pelo motor Fiscal
					//Obtém todos os tributos genéricos passíveis de retenção
					//Percorre todos tributos genéricos verificando se ele é passível de retenção
					//Populo os arrays aTGCalcRet quando retenção e o aTGCalc para taxas
					FisRetGen(@aTGCalc,@aTGRet,_lFinParcFKK,@aTGCalcRet,@aTGCalcRec,SF2->F2_EMISSAO)

					// Faz a chamda da FGrvImpFi para gerar os recolhimentos no financeiro e da xFisF2F p/
					// gravar a tabela Título x NF do Fiscal (F2F).
					If Len(aTGCalcRec) > 0
						FGrvImpFi(@aTGCalcRec, "MATA460", dDatabase)
						xFisF2F("I", SF2->F2_IDNF, "SF2", aTGCalcRec)
					EndIf
				EndIf

				//Aqui chamo a função para fazer tratamento da geração das Guias.				
				If cPaisLoc == "BRA" .AND. FindFunction("xFisAddGNRE").And. AliasIndic("CIN")
					xFisAddGNRE(SF2->(RECNO()), "SF2",aTGCalcRec)
				EndIF

			EndIf
		EndIf

		If cPaisLoc $ "BRA|MEX" .and. (FunName() == "MATA460A" .or. FunName() == "MATA460B" .or. FunName() == "MATA460N" .or. FunName() == "MATA461")
			If ( aTitulo[_VLRTIT_] > 0 ) // somente se o documento gerou contas a receber
				If A410UsaAdi(SF2->F2_COND)
					For nCnt := 1 To Len(aPvlNfs)
						If aScan(aAtuSC5,aPvlNfs[nCnt,1])==0
							aadd(aAtuSC5,aPvlNfs[nCnt,1])
						EndIf
						// calcula o acrescimo financeiro para os itens liberados deste pedido
						nAcresTot := MaAcreFinAdt(aPvlNfs,nCnt,MV_PAR05==1,dDataMoe)
						// gera array com valores de acrescimo para cada pedido
						nPosAcres := aScan(aAcresTot,{|x| x[1] = aPvlNfs[nCnt][1]})
						If nPosAcres = 0
							aAdd(aAcresTot,{aPvlNfs[nCnt][1],nAcresTot})
						Else
							aAcresTot[nPosAcres][2] += nAcresTot
						Endif
					Next nCnt
					// Importante: chamar a rotina de compensacao de adiantamento antes da rotina MaAvalSC5, pois esta elimina os itens restantes da tabela FIE, quando for o faturamento do ultimo item do pedido
					// Faz a compensacao do titulo no Financeiro
					A461NCompAd(aAtuSC5,aRecSE1Adt,,aPvlNfs,.T.,SF2->F2_DOC,SF2->F2_SERIE,{},aAcresTot,aTitulo,nHdlPrv)
				EndIf
			Endif
		Endif

		If ( llCt620 )
			nLctTotal += DetProva(nHdlPrv /*nHdlPrv*/, "620" /*cPadrao*/, "MATA460" /*cPrograma*/, cLote /*cLote*/,            /*nLinha*/,;
			                      /*lExecuta*/,        /*cCriterio*/,     /*lRateio*/,             /*cChaveBusca*/,            /*aCT5*/,;
			                      /*lPosiciona*/,      /*aFlagCTB*/,      /*aTabRecOri*/,          @_aDPrv461 /*aDadosProva*/, /*lSimula*/,;
			                      /*cTabCTK*/,         /*cTabCT2*/,       /*cTabCV3*/,             /*cCtaRec*/)
		EndIf
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Grava os lancamentos nas contas orcamentarias SIGAPCO    ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		PcoDetLan("000101","02","MATA461")

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Atualiza o Pedido de Venda                                              ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		For nCntFor := 1 To Len(aPedido)
			MaAvalSC5("SC5",5,,,,,,,,aPedido[nCntFor][1])
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Integracao com SIGAEEC                                                  ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			dbSelectArea("SC5")
			dbSetOrder(1)
			MsSeek(cFilSC5+aPedido[nCntFor][1])
			If ( !Empty(SC5->C5_PEDEXP) .And. lEECFat )

				AE100STATUS(SC5->C5_PEDEXP,SC5->C5_NUM)

			EndIf
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³EXECUTAR CHAMADA DE FUNCAO p/ integracao com sistema de Distribuicao - NAO REMOVER ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Atualizacao da Legenda da tabela SL1     |
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			aAdd(aSL1,{"L1_DOC"		, SF2->F2_DOC	})
			aAdd(aSL1,{"L1_SERIE" 	, SF2->F2_SERIE	})

			// Posiciona no registro SL1
			dbSelectArea("SL1")
			dbSetOrder(1)
			If DbSeek(cFilSL1 + SC5->C5_ORCRES)
	    		// Atualiza SL1
		        Lj7GeraSL( "SL1", aSL1, .F., .T. )

				//Atualiza os campos de garantia 
				If ExistFunc("LjGarantia")
					LjGarantia()
				EndIf
			
		        If !Empty(SL1->L1_NUMATEN)
		           	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³Tendo Integracao com o TMK atualiza os campos da tabela SUA³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					DbSelectArea("SUA")
					DbSetOrder(1)
					If DbSeek(cFilSUA+SL1->L1_NUMATEN)
						RecLock("SUA",.F.)
						REPLACE UA_OPER 	WITH "1"
						REPLACE UA_DOC  	WITH SL1->L1_DOC
						REPLACE UA_STATUS   WITH "NF."
						REPLACE UA_SERIE  	WITH SL1->L1_SERIE
						REPLACE UA_EMISNF 	WITH dDatabase
						REPLACE UA_VEND		WITH SL1->L1_VEND
						MsUnlock()
					EndIf
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³Encerra o atendimento na lista de contatos.³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					dbSelectArea("SU4")
					dbSetOrder(4)	//U4_FILIAL+U4_CODLIG
					If dbSeek(cFilSU4+SL1->L1_NUMATEN) .And. SU4->U4_STATUS <> "2"
						RecLock("SU4",.F.)
						REPLACE SU4->U4_STATUS WITH "2"	//Status de encerrado
						MsUnlock()
					EndIf
			    EndIf
		    Endif

		Next nCntFor
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Atualiza as cargas de transporte                                        ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		For nCntFor := 1 To Len(aCarga)
			If ( aCarga[nCntFor]<> 0 )
				DAK->(dbSetOrder(1))
				DAK->(MsGoto(aCarga[nCntFor]))
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Atualiza Flag de Faturamento da Carga                              ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				OsAvalDAK("SC9",7)
			EndIf
		Next nCntFor

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Verificacao da Lista de Presentes - Vendas CRM³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If lUsaLstPre
			//Verifica se o Pedido que esta sendo faturado é de lista de presentes e se conseguiu emitir a nota fiscal de remessa
			a461LstPre(aPvlnfs,cTypeDoc)
		EndIf
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Para a localizacao Mexico, sera processada a funcao do ponto de entrada SF2460I no padrao.³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If cPaisLoc == "MEX"
			RcFatMex()
		Endif
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Pontos de Entrada 											      ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If ( aEntry[EP_SF2460T] )
			ExecTemplate("SF2460I",.F.,.F.)
		EndIf

		If ( aEntry[EP_SF2460I] )
			Execblock("SF2460I",.F.,.F.)
		EndIf

		//Integração com Módulo de Locações SIGALOC
		If lMvLocBac
			LOCM003()
		EndIf
		
	Else
		// Libera numero da nota no SD9 caso nao consiga gerar a nota
		If cTpNrNfs == "3"
			Ma461LibD9(cSerie,cNumero,cSerieId)
		EndIf
	EndIf

	//---------------------------------------------------------------
	//  Atualiza os movimentos de locação com os dados da NF gerada
	// considera os dados posicionados na SF2/SD2 - Gestão de Serviços
	At800AtNFSai()

	//-- aStruModel
	//-- [1] - Alias
	//-- [2] - Model da Estrutura
	//-- [3] - bSeek
	//-- [4] - nOrdem
	//-- [5] - bWhile
	//-- [6] - aFieldValue
	//-- [6,1] Nome do Campo
	//-- [6,2] Bloco de execucao para o valor
	//--       a ser atribuido ao campo
	If _lMaEnvEAI
		If lIntGFE
			MaEnvEAI(,,4,"MATA461")
		Else
			Aadd(aStruModel, { "SF2", "MATA461_SF2"     , NIL, NIL, NIL, NIL } )
			Aadd(aStruModel, { "SD2", "MATA461_SD2"     , {|| SF2->(F2_FILIAL+F2_DOC+F2_SERIE+F2_CLIENTE+F2_LOJA) }, 3, {|| SD2->(D2_FILIAL+D2_DOC+D2_SERIE+D2_CLIENTE+D2_LOJA) == SF2->(F2_FILIAL+F2_DOC+F2_SERIE+F2_CLIENTE+F2_LOJA) }, NIL } )
			MaEnvEAI(,,3,"MATA461",aStruModel)
		EndIf
	EndIf

	//Efetua atualizações no pedido gerado pelo loja, quando C5_ORCRES\C5_PEDECOM preenchido
	If ExistFunc("LjxjAtLoja")
		LjxjAtLoja(aPedido)
	EndIf
Else
	// Libera numero da nota no SD9 caso nao consiga gerar a nota
	If cTpNrNfs == "3"
		Ma461LibD9(cSerie,cNumero,cSerieId)
	EndIf
	Aviso(STR0018,STR0020,{STR0021}) //"Mensagem"###"Problemas com o Travamento dos Registros"###"OK"
EndIf

//Valida a data da LIB para utilização na Telemetria
If FatLibMetric()
	//Telemetria - Itens contidos nas Notas Fiscais de Saída
	FwCustomMetrics():setAverageMetric("MATA461", "faturamento-protheus_media-itens-nota-saida_average", nTotItens, /*dDateSend*/, /*nLapTime*/,"MATA461")
EndIf

//funcao wms que fará envio da metrica
If Findfunction("WmsEnvMetr") 
   	WmsEnvMetr(_nMovWMS,"MATA461_Fat_Pedido",2)
EndIF
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Restaura a entrada da rotina                                            ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
RestArea(aAreaSC9)
RestArea(aArea)

Return( cNumero )

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³MaPvl2SD2 ³ Autor ³Eduardo Riera          ³ Data ³29.08.1999³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Gravacao do Item da Nota Fiscal de Saida                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpL1: .T.                                                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpC1: Item da Nota Fiscal                                  ³±±
±±³          ³ExpA2: Array com o item do SC9 a ser Gerado                 ³±±
±±³          ³ExpA3: Array com o rateio das despesas acessorias           ³±±
±±³          ³ExpA4: Array aTitulo p/  controle do Financeiro             ³±±
±±³          ³ExpL5: Atualiza Amarracao Cliente x Produto                 ³±±
±±³          ³ExpL6: Reajuste de Preco.                                   ³±±
±±³          ³ExpN7: Valor do Desconto ( Produto Negativo )               ³±±
±±³          ³ExpC8: Numero do Embarque de Exportacao                     ³±±
±±³          ³ExpC9: Array com as cargas a serem atualizadas              ³±±
±±³          ³ExpB1: Code Block de atualizacao do pedido de venda antes   ³±±
±±³          ³       da geracao da nota fiscal                            ³±±
±±³          ³ExpAA: Array contendo o contrato (GCT) relacionado ao       ³±±
±±³          ³       pedido                                               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³   DATA   ³ Programador   ³Manutencao Efetuada                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³               ³                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function MaPvl2Sd2(cItemNf,aPvlNfs,aRateio,aTitulo,lAtuSa7,lReajuste,nValNeg,nItem,cEmbExp,aCarga,bAtuPvl,aContrato,aMedicao,aNfOriLot,cAliq,dDataMoe, nTotAcre,aSxFci,aRatFin)

Local aPvlSD2	:= aPvlNfs[nItem]
Local aSolid    := {}
Local aSolidTmp        //Inicial este array com nil para validar somente apos utilização do ponto de entrada.
Local aPesoEmb  := {}
Local nMaxVend  := Fa440CntVen()
Local nCntFor   := 0
Local nComis    := 0
Local nPrcVen   := 0
Local nPrUnit   := 0
Local nAcresFin := 0
Local nTotal    := 0
Local ny        := 0
Local nDesconto := 0
Local nRecOri   := 0
Local nPosAIss  := 0
Local nAliqIss  := 0
Local cCliEnt   := ""
Local cLojaEnt	:= ""
Local cVendedor := ""
Local cSeriOri  := ""
Local cNfOri    := ""
Local cNumSeq   := SF4->(ProxNum())
Local cItemOri  := ""
Local cIdentB6  := ""
Local cGrpCliTrb := NIL
Local cMoedaTit := SuperGetMv("MV_MOEDTIT")
Local nMoeda    := 0
Local nMoedaNDF := 1
Local nTaxaNDF  := 0
Local aTransp	:= {"",""}
Local lCfo      := .F.
Local nX        := 0
Local lCAT83	:= .F.
Local cCmpD2Re	:= SuperGetMv("MV_RE",,"") 	 // Campo D2 - Exportacao (Sem Integracao EIC)
Local cCmpC6Re	:= SuperGetMv("MV_RESC6",,"")  // Campo C6 - Exportacao (Sem Integracao EIC)

Local cEstado	  := SuperGetMv("MV_ESTADO")
Local cTesVend    := SuperGetMv("MV_TESVEND",,"")
Local nTotPed	  := 0
Local nVlImp	  := 0
Local cFciCod	  := ""
Local cNwFciCod	  := ""
Local nNwVlImp	  := 0
Local cCodOrig	  := ""
Local lFISAUCF	  := SuperGetMv("MV_FISAUCF",,.F.)

//Verifica se a funcionalidade Lista de Presente esta ativa e aplicada
Local lUsaLstPre := SuperGetMV("MV_LJLSPRE",,.F.) // .And. IIf(FindFunction("LjUpd78Ok"),LjUpd78Ok(),.F.)
Local lRastro		:= .F.

Local aEntidades	:= {}
Local nEnt			:= 0
Local nDeb			:= 0
Local cMvCfLTran	:= SuperGetMv("MV_CFLTRAN",.F.,"")
Local cMvCfLTra1	:= SuperGetMv("MV_CFLTRA1",.F.,"")
Local cMvCfLTra2	:= SuperGetMv("MV_CFLTRA2",.F.,"")
Local cMvCfLTra3	:= SuperGetMv("MV_CFLTRA3",.F.,"")
Local xAlqLeiTr		:= 0											// valor da  aliquota retornado pela função fiscal (Lei transparência)
Local aAlqLeiTr		:= {}  		       							   // array com valores da  aliquota retornado pela função fiscal (Lei transparência) 1-Aliq Total|2-Aliq Federal|3-Aliq Estadual|4-Aliq Municipal
Local nTotAlq		:= 0                                            // valor total da  aliquota a ser gravada no campo D2_TOTIMP
Local nAlqFed			:= 0                                            // valor total da  aliquota Fedral
Local nAlqEst			:= 0                                            // valor total da  aliquota Estadual
Local nAlqMun			:= 0                                            // valor total da  aliquota Municipal
Local nDescCond		:= 0											// Valor do desconto (Desconto Condicional - Lei transparência)
Local cMvFisCTrb 	:= SuperGetMv("MV_FISCTRB",.F.,"1")             // método de consulta do percentual de carga tributária.Informe 1 para tratamento legado ou 2 alíquotas da Nota Fiscal e CGA/CGB - #conteudo gravado no campo D2_TIPIMP
Local cMvFisAlCT   	:= SuperGetMv("MV_FISALCT",.F.,"3")            // Informar qual o método de composição da carga tributária quando MV_FISCTRB = 2.
Local lMvFisFRas    := SuperGetMv("MV_FISFRAS",.F.,.F.)            // Indica se utilizara a rastreabilidade no faturamento para preenchimento dos campos que necessitam desta funcionalidade
Local lCCusto		:= SC6->(ColumnPos("C6_CC")) > 0
Local lConta		:= SC6->(ColumnPos("C6_CONTA")) > 0
Local lItConta	:= SC6->(ColumnPos("C6_ITEMCTA")) > 0
Local lCValor		:= SC6->(ColumnPos("C6_CLVL")) > 0
Local nValRetIss := 0
Local lPRetIss := SuperGetMv("MV_PRETISS",.T.,.F.)
Local lCalcPCC  := .F. //Indica se Calcula (PIS,COFINS,CSLL), independete da TES estar configurada para Gerar Duplicata (F4_DUPLIC)
Local lCalcINSS := .F. //Indica se Calcula (INSS), independete da TES estar configurada para Gerar Duplicata (F4_DUPLIC)
Local lCalcIRRF := .F. //Indica se Calcula (IRRF), independete da TES estar configurada para Gerar Duplicata (F4_DUPLIC)
Local lWmsNew	:= SuperGetMv("MV_WMSNEW",.F.,.F.)
Local nI := 0
Local nParEEC52 := SuperGetMV("MV_EEC0052",,1)
Local nQuantFAT := 0

Local lFCIAtuC := SuperGetMv("MV_FCIATUC",.F.,.F.)
Local aFCIxOri := {"",""}
Local lRefSECP15 := .F.

Local lC6Ent05		:= SC6->(ColumnPos("C6_EC05DB")) > 0
Local lC6Ent06		:= SC6->(ColumnPos("C6_EC06DB")) > 0
Local lC6Ent07		:= SC6->(ColumnPos("C6_EC07DB")) > 0
Local lC6Ent08		:= SC6->(ColumnPos("C6_EC08DB")) > 0
Local lC6Ent09		:= SC6->(ColumnPos("C6_EC09DB")) > 0
Local lC6NatRen     := SC6->(ColumnPos("C6_NATREN")) > 0
//Local lC6IndSus     := SC6->(ColumnPos("C6_INDSUS")) > 0 // RETIRADA TEMPORARIA DEVIDO ANALISE DA REGRA DE NEGOCIO - REINF
Local lFmpeq		:= (SE1->(ColumnPos("E1_FMPEQ")) > 0) .And. (SF3->(ColumnPos("F3_VALFMP")) > 0)
Local lIma			:= (SE1->(ColumnPos("E1_IMA")) > 0) .And. (SF3->(ColumnPos("F3_VALIMA")) > 0) .And. !Empty(MaFisScan("IT_VALIMA",.F.))
Local lFamad   		:= (SE1->(FieldPos("E1_FAMAD")) > 0) .And. (SF3->(FieldPos("F3_VALFMD")) > 0) 
Local lTrbGen       := IIf(_lChkTrbGen, ChkTrbGen("SD2","D2_IDTRIB"), .F.)
Local cFilSB6		:= ""
Local cFilSF4		:= ""
Local cFilAGG		:= xFilial("AGG")
Local cFilAGH		:= xFilial("AGH")
Local lIntegNG 		:= (SuperGetMV("MV_NGMNTCM",.F.,"N") == "S")
Local cOrigem		:= ""
Local lAtuClas		:= .F.
Local lOrigLote		:= SuperGetMV("MV_ORILOTE",.F.,.F.) .And. _lOrigemLote
Local lFisNewLT		:= .F.
Local nFisGetSC5	:= 0
Local nAbat         := 0
Local lContercOk    := .F.
Local lInfEnder     := .F.
Local nAGHTot		:= 0
Local nAGHRecn      := 0
Local aRatEnt       := {}
Local lAGHTotal     := AGH->(ColumnPos("AGH_TOTAL")) > 0
Local lRTCFin		:= SuperGetMv("MV_RTCCFIN", .F., .F.)
Local lTFrete       := SuperGetMv("MV_T_FRETE", .F., .F.)
Local lHabGrvLog 	:= SuperGetMV("MV_FTLOGPV",,.F.) .And. FindFunction('FATA410') .And. AliasInDic("AQ1") //Habilita a gravação do log de liberação de Pedidos de Venda
Local aLogLibPV		:= {}
Local nPosNatRen	:= 0
Local lEstTerc		:= !(SuperGetMV("MV_NFS_JOB",,.F.) )
Local lCtrAtu       := .F.
Local lTrfICMS		:= (cPaisLoc == "BRA" .And. SuperGetMV("MV_TRFICMS",,.F.))

Default bAtuPvl  := {||.T.}
Default dDataMoe := dDataBase

//Gestao de Contratos
Default aContrato := {}
Default aMedicao  := {}
Default aNfOriLot := {}
Default cAliq	  := ""
Default nTotAcre  := 0
Default aSxFci    := A461RetCFci(,1)
Default aRatFin	  := {}
Default lAIS      := ChkFile("AIS")

If (Type("lUsaFKW") == "U")
	Private lUsaFKW := (cPaisLoc == "BRA" .And. ChkFile("FKW") .And. FindFunction("A461FKW"))//Validacoes para gravacao na FKW - REINF
EndIf

//Tratamento para saber o total antes de chamar a MATXFIS
aEval(aPvlNfs,{|x| nTotPed += a410Arred( x[5],"D2_TOTAL")})
nTotPed += nTotAcre

If Empty(dDataMoe)
	dDataMoe := dDatabase
Endif

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Posiciona Registros                                                     ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
dbSelectArea("SC9")
dbSetOrder(1)
MsGoto(aPvlSd2[8])

dbSelectArea("SC5")
dbSetOrder(1)
MsGoto(aPvlSD2[9])

dbSelectArea("SC6")
dbSetOrder(1)
MsGoto(aPvlSD2[10])

dbSelectArea("SE4")
dbSetOrder(1)
MsGoto(aPvlSd2[11])

dbSelectArea("SB1")
dbSetOrder(1)
MsGoto(aPvlSd2[12])

dbSelectArea("SB2")
dbSetOrder(1)
MsGoto(aPvlSd2[13])

dbSelectArea("SF4")
dbSetOrder(1)
MsGoto(aPvlSd2[14])

dbSelectArea("SA4")
dbSetOrder(1)
If ( aEntry[EP_M460MOED] )
	cMoedaTit := ExecBlock("M460MOED", .F., .F.,cMoedaTit)
EndIf

If aSxFci[3]
	DbSelectArea("CFD")
	DbSetOrder(2)
Endif

nAbat  := (SC6->C6_QTDVEN * SC6->C6_ABATMAT) / SC6->C6_QTDVEN
nMoeda := SC5->C5_MOEDA
nMoeda := If(cMoedaTit=="S",nMoeda,1)

lCAT83   := SuperGetMV("MV_CAT8309",,.T.)
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Carrega a relacao de impostos contidos no SF2 e SD2                 ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If nItem == 1

	cCliEnt := SC5->C5_CLIENT
	cLojaEnt := SC5->C5_LOJAENT

	If Empty(cCliEnt)
		cCliEnt := SC5->C5_CLIENTE
	EndIf

	If Empty(cLojaEnt)
		cLojaEnt := SC5->C5_LOJACLI
	Endif

	If ExistBlock( "M461GRP" )
		cGrpCliTrb := ExecBlock( "M461GRP", .f., .f. )
	EndIf

	If SA4->(dbSeek(xFilial("SA4")+SC5->C5_TRANSP))
		aTransp[01] := SA4->A4_EST
		aTransp[02] := SA4->A4_TPTRANS
	Endif

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³A Consultoria Tributária, por meio da Resposta à Consulta nº 268/2004, determinou a aplicação das seguintes alíquotas nas Notas Fiscais de venda emitidas pelo vendedor remetente:                                                                         ³
	//³1) no caso previsto na letra "a" (venda para SP e entrega no PR) - aplicação da alíquota interna do Estado de São Paulo, visto que a operação entre o vendedor remetente e o adquirente originário é interna;                                              ³
	//³2) no caso previsto na letra "b" (venda para o DF e entrega no PR) - aplicação da alíquota interestadual prevista para as operações com o Paraná, ou seja, 12%, visto que a circulação da mercadoria se dá entre os Estado de São Paulo e do Paraná.       ³
	//³3) no caso previsto na letra "c" (venda para o RS e entrega no SP) - aplicação da alíquota interna do Estado de São Paulo, uma vez que se considera interna a operação, quando não se comprovar a saída da mercadoria do território do Estado de São Paulo,³
	//³ conforme previsto no art. 36, § 4º do RICMS/SP                                                                                                                                                                                                            ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If cEstado == 'SP'
		If !Empty(SC5->C5_CLIENT) .And. SC5->C5_CLIENT <> SC5->C5_CLIENTE
			For nX := 1 To Len(aPvlNfs)
				dbSelectArea("SC6")
				dbSetOrder(1)
				MsGoto(aPvlNfs[nX][10])
				If Alltrim(SC6->C6_TES)$ Alltrim(cTesVend)
					lCfo:= 	.T.
				EndIf
   			Next

   			//Restauro a area anterior
   			dbSelectArea("SC6")
			dbSetOrder(1)
			MsGoto(aPvlSD2[10])

	   		If lCfo
				dbSelectArea(IIF(SC5->C5_TIPO$"DB","SA2","SA1"))
				dbSetOrder(1)
				MsSeek(xFilial()+SC5->C5_CLIENTE+cLojaEnt)
				If Iif(SC5->C5_TIPO$"DB", SA2->A2_EST,SA1->A1_EST) <> 'SP'
					 cCliEnt := SC5->C5_CLIENT
				Else
					cCliEnt := SC5->C5_CLIENTE
				EndIf
			EndIf
		EndIf
	EndIF
	A461ImpFin(@lCalcPCC,@lCalcINSS,@lCalcIRRF)
	dbSelectArea("SC5")
	MaFisIni(cCliEnt,cLojaEnt,If(SC5->C5_TIPO$'DB',"F","C"),SC5->C5_TIPO,SC5->C5_TIPOCLI,aRelImp,,,,'MATA461',,,,cGrpCliTrb,,,,;
				aTransp,,,SC6->C6_NUM,SC5->C5_CLIENTE,SC5->C5_LOJACLI,nTotPed,,SC5->C5_TPFRETE,lCalcPCC,lCalcINSS,lCalcIRRF,SC5->C5_TPCOMPL,,,lTrbGen,Len(aPvlNfs))
	MaFisLoad("NF_ESPECIE",SF2->F2_ESPECIE)
	If !(SC5->C5_TIPO$'DB')
		If "CTR"$AllTrim(SF2->F2_ESPECIE) .OR. "NFST"$AllTrim(SF2->F2_ESPECIE)
			MaFisLoad("NF_PNF_COD",SC5->C5_CLIENTE)
			MaFisLoad("NF_PNF_LOJ",SC5->C5_LOJACLI)
			MaFisLoad("NF_PNF_UF" ,SA1->A1_EST)
			MaFisLoad("NF_PNF_TPCLIFOR",SA1->A1_TIPO)
		EndIf
		If SC5->(FieldPos("C5_NATUREZ"))>0 .And. !Empty(SC5->C5_NATUREZ)
			MaFisLoad("NF_NATUREZA",SC5->C5_NATUREZ)
		Else
			MaFisLoad("NF_NATUREZA",Iif( Empty(SA1->A1_NATUREZ), &(SuperGetMv("MV_1DUPNAT")) , SA1->A1_NATUREZ ))
		EndIf
	EndIf
	If !lIsRussia
		If !Empty(SC5->C5_MUNPRES)
			MaFisLoad("NF_CODMUN",AllTrim(SC5->C5_MUNPRES))
		EndIf
		
		If !Empty(SC5->C5_ESTPRES)
			MaFisLoad("NF_UFPREISS",AllTrim(SC5->C5_ESTPRES))
		EndIf
	EndIf
	If !Empty(SF2->F2_CLIENT) .And. !Empty(SF2->F2_LOJENT)
		MaFisLoad("NF_CLIENT",SF2->F2_CLIENT)
		MaFisLoad("NF_LOJENT",SF2->F2_LOJENT)
	EndIf
	nFisGetSC5 := Len(aFisGetSC5)
	For nY := 1 to nFisGetSC5
		If !Empty( SC5->(FieldGet(FieldPos(aFisGetSC5[nY][2]))) )
			If aFisGetSC5[ny][1] == "NF_SUFRAMA"
				MaFisLoad(aFisGetSC5[ny][1],Iif( SC5->(FieldGet(FieldPos(aFisGetSC5[nY][2]))) == "1",.T.,.F.))
			Else
				MaFisLoad(aFisGetSC5[ny][1], SC5->(FieldGet(FieldPos(aFisGetSC5[nY][2]))) )
			Endif
		EndIf
	Next nY
EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Tratamento para devolucao de Material                                   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If ( SC5->C5_TIPO=="D" )
	dbSelectArea("SD1")
	dbSetOrder(1)
	If ( MsSeek(xFilial()+SC6->C6_NFORI+SC6->C6_SERIORI+SC5->C5_CLIENTE+SC5->C5_LOJACLI+SC6->C6_PRODUTO+SC6->C6_ITEMORI,.F.) )
		nRecOri	:= SD1->(RecNo())
		dbSelectArea("SF1")
		dbSetOrder(1)
		If MsSeek(xFilial("SF1")+SD1->D1_DOC+SD1->D1_SERIE+SD1->D1_FORNECE+SD1->D1_LOJA+"N")
			nTaxaNDF := SF1->F1_TXMOEDA
			dbSelectArea("SE2")
			dbSetOrder(6)
			If MsSeek(xFilial("SE2")+SF1->F1_FORNECE+SF1->F1_LOJA+SF1->F1_PREFIXO+SF1->F1_DUPL)
				nMoedaNDF := SE2->E2_MOEDA
			EndIf
		EndIf
	EndIf
Else
	If ( SF4->F4_PODER3=="D" .And. SC5->C5_TIPO$"BN" )
		dbSelectArea("SD1")
		dbSetOrder(4)
		If ( MsSeek(xFilial("SD1")+SC9->C9_IDENTB6) )
			nRecOri	:= SD1->(RecNo())
		EndIf
		dbSetOrder(1)
	ElseIf nRecOri == 0 .And. SF4->(ColumnPos("F4_INDVF")) > 0 .And. !Empty(SC6->C6_NFORI) .And. !Empty(SC6->C6_SERIORI)
        SD2->(dbSetOrder(3))
        IF SD2->(MSSeek(xFilial("SD2")+SC6->C6_NFORI+SC6->C6_SERIORI+SC5->C5_CLIENTE+SC5->C5_LOJACLI+SC6->C6_PRODUTO+SC6->C6_ITEMORI))
           nRecOri := SD2->(Recno())
        Endif
	Endif
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Executa Code Block de atualizacao do pedido de venda                   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Eval(bAtuPvl)

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Inicializa as funcoes                                                   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
MaFisIniLoad(nItem,{	SC6->C6_PRODUTO,;	//IT_PRODUTO
						SC6->C6_TES,; 		//IT_TES
						"",; 	//IT_CODISS
						aPvlNfs[nItem][4],;	//IT_QUANT
						SC6->C6_NFORI,; 	//IT_NFORI
						SC6->C6_SERIORI,; 	//IT_SERIORI
						SB1->(RecNo()),;	//IT_RECNOSB1
						SF4->(RecNo()),;	//IT_RECNOSF4
						nRecOri ,; 			//IT_RECORI
						SC6->C6_LOTECTL,;	//IT_LOTECTL
						SC6->C6_NUMLOTE,;   //IT_NUMLOTE
						"",;                //IT_PRDFIS
						0,;                 //IT_RECPRDF
						IIf(type("SC6->C6_OPER") == "C",SC6->C6_OPER ,"")})	    //IT_TPOPER

//Carrega o valores dos IT_VALMERC/IT_PRCUNI e executa o MafisRecal somente 
//para carregar a Alíquota ISS do item quando utiliza Cfg de tributos
//utilizando o F4_ISS = S 
If SF4->F4_ISS == "S"
	MaFisLoad("IT_VALMERC",SC6->C6_VALOR ,nItem)
	MaFisLoad("IT_PRCUNI" ,SC6->C6_PRUNIT,nItem)
	MaFisRecal("",nItem)
EndIf

//Apesar da referencia já ser atualizada no momento da gravação no SD2, pelo MAFisRef, na MATXFIS precisaremos
// da classificação fiscal no cálculo dos impostos do item.
If Len(Alltrim(SC6->C6_CLASFIS))==3
	Mafisload("IT_CLASFIS",SC6->C6_CLASFIS,nItem)
EndIf

If !lIsRussia
	MaFisLoad("IT_ABVLISS",SC6->C6_ABATISS,nItem)	
	If SC6->C6_ABATMAT > 0
		MaFisLoad("IT_ABMATISS", nAbat, nItem)
	EndIf
EndIf
MaFisTes(SC6->C6_TES,SF4->(RecNo()),nItem)

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Para que a aliquota do ISS Progressivo seja enquadrada na tabela        ³
//³CALCPROG.ISS a MATXFIS necessita do valor de referencia do valor total  ³
//³do item do pedido de vendas para que aliquota seja gravada ao gerar NFs.³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If (SuperGetMV("MV_ISSPRG",,"N") == "S")
	MaFisLoad("IT_VALMERC",SC6->C6_VALOR,nItem)
EndIf

// Considerar o codigo do servico informado na SC6 quando houver alteracao.
// Feito com MaFisAlt pois a mudanca do codigo pode resultar em uma aliquota diferente (CE1)
// e nesta situacao eh necessario recalcular para que o trecho abaixo, que utiliza a MaAliqIss,
// retorne a aliquota atualizada.
If !Empty(SC6->C6_CODISS) .And. MaFisRet(nItem,"IT_CODISS") <> SC6->C6_CODISS
	MaFisAlt("IT_CODISS",SC6->C6_CODISS,nItem,.T.)
EndIf

// Soh obter a aliquota de ISS se o TES calcular o imposto.
If SF4->F4_ISS == "S"
	nPosAIss := Ascan(aFisGet, {|x| x[1] == "IT_ALIQISS" })
	If nPosAIss > 0
		dbSelectArea("SC6")
		nAliqIss := SC6->(FieldGet(FieldPos(aFisGet[nPosAIss][2])))
		If nAliqIss == 0
			nAliqIss :=	MaAliqISS(nItem)
		EndIf
	Else
		nAliqIss :=	MaAliqISS(nItem)
	Endif
EndIf

aRateio[RT_PRECOIT]	:= MaPvPrcIt(aPvlNfs,nItem,lReajuste,aRateio,nValNeg,nAliqIss,dDataMoe)

nValNeg		:= If(nValNeg>0,0,nValNeg)
MaFisLoad("IT_VALMERC",aRateio[RT_PRECOIT][3]+aRateio[RT_PRECOIT][4],nItem)
MaFisLoad("IT_PRCUNI",aRateio[RT_PRECOIT][1],nItem)
MaFisLoad("IT_VLR_FRT",aRateio[RT_VLR_FRT],nItem)
If !lIsRussia
	MaFisLoad("IT_PRCCF",((SC6->C6_IPITRF / SC6->C6_QTDVEN) * aPvlNfs[nItem][4]),nItem)
EndIf
If nAliqIss==0
	MaFisLoad("IT_FRETE",aRateio[RT_FRETE],nItem)
	MaFisLoad("IT_SEGURO",aRateio[RT_SEGURO],nItem)
	MaFisLoad("IT_DESPESA",aRateio[RT_DESPESA],nItem)
EndIf
MaFisLoad("IT_AUTONOMO",aRateio[RT_FRETAUT],nItem)
MaFisLoad("IT_DESCONTO",aRateio[RT_PRECOIT][4],nItem)
MaFisLoad("IT_PESO",SB1->B1_PESO,nItem)

If !Empty(aNfOriLot) .And. Len(aNfOriLot[01])>0 //Tratamento para IVA Ajustado - Esta chamada tem custo zero de performance para matxfis
	MaFisLoad("IT_ANFORI2", aNfOriLot, nItem)
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//Calculo de aposentadoria Especial REINF, não gravamos em nossas tabelas  ³
//SD2, apenas passamos valores para MATXFIS calcular e gerar no livro(SFT) ³
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿

If lAIS 
	//Verifica existncia das Referencias Fiscais de Ap. Especial
	lRefSECP15:= !Empty(MaFisScan("IT_SECP15",.F.))
	If lRefSECP15
		AIS->(dbSetOrder(1)) 
		If AIS->(DbSeek(xFilial("AIS")+SC5->C5_NUM+SC6->C6_ITEM))
			MaFisLoad("IT_SECP15", AIS->AIS_15ANOS, nItem)
			MaFisLoad("IT_SECP20", AIS->AIS_20ANOS, nItem)
			MaFisLoad("IT_SECP25", AIS->AIS_25ANOS, nItem)
			RecLock("AIS", .F.)
				AIS->AIS_NUMNF := SF2->F2_DOC
				AIS->AIS_SERIE := SF2->F2_SERIE
			AIS->(MsUnLock())
		Endif
	EndIf
EndIf

MaFisRecal("",nItem)
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Forca os valores de impostos que foram informados no SC6.              ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
dbSelectArea("SC6")
For nY := 1 to Len(aFisGet)
	If !Empty( SC6->(FieldGet(FieldPos(aFisGet[ny][2]))) )
		MaFisAlt(aFisGet[ny][1] , SC6->(FieldGet(FieldPos(aFisGet[ny][2]))) ,nItem,.T.)
	EndIf
Next nY

// Chamada da função para os complementos de tributos 
If _lComplTrib .AND. SC5->C5_TIPO $ "I" .AND. AliasInDic("CIP")
	FSA303ALT(SC5->C5_NUM,SC6->C6_ITEM,nItem)
EndIf 

cFciCod := Iif( !lIsRussia .AND. aSxFci[8] , SC6->C6_FCICOD , "" )
nVlImp	:= Iif( !lIsRussia .AND. aSxFci[6] , SC6->C6_VLIMPOR , 0 )

lRastro := Rastro( SC6->C6_PRODUTO )

If !lIsRussia
	If lFCIAtuC .And. lFISAUCF .And. _lXFciGOrigem
		// Função para retornar o codigo de origem e o codigo da fci conforme produto e periodo informado.
		aFCIxOri := XFciGetOrigem(SC6->C6_PRODUTO,dDataBase)
		// Se retornou o codigo de FCI
		If !Empty(aFCIxOri[2])
			cFciCod := aFCIxOri[2]
			MaFisAlt("IT_CLASFIS",aFCIxOri[1] + Substr(SC6->C6_CLASFIS,2),nItem, .T.)
		EndIf
	EndIf

	// Verificar parametro MV_FISFRAS (aSxFci[1]), que deve ser desabilitado caso nao queria
	// preencher o campo D2_VLIMPOR automaticamente
	If aSxFci[1] .And. lFISAUCF
		// **************************************************************************
		// OPCAO TRANSFERIDA PARA O PEDIDO DE VENDA (PREENCHIMENTO DO CODIGO DA FCI)
		// **************************************************************************
		If lRastro .And. (nVlImp == 0 .Or. Empty( cFciCod ))
			SpedRastro2( SC9->C9_NUMLOTE , SC9->C9_LOTECTL , SC6->C6_PRODUTO , @nNwVlImp , 0 , .T. , @cNwFciCod,,,,,@cCodOrig,,,,,,,,,,,SC9->C9_LOCAL )
			
			//Soh utilizo o retorno da SpedRastro() se nao tiver digitado no PV
			nVlImp	:=	Iif(nVlImp == 0, nNwVlImp, nVlImp)
			cFciCod	:=	Iif(Empty(cFciCod), cNwFciCod, cFciCod)
		Endif

		If !Empty( cCodOrig ) .And. Empty(Iif(aSxFci[8],SC6->C6_FCICOD,""))
			MaFisAlt("IT_CLASFIS",cCodOrig + Substr(SC6->C6_CLASFIS,2),nItem, .T.)
		EndIf
	Endif
	
EndIf

If lRastro .And. lOrigLote .And. Empty(cFciCod)
	cOrigem := OrigemLote(SC6->C6_PRODUTO, SC9->C9_LOTECTL, SC9->C9_NUMLOTE)
	If !Empty(cOrigem) .And. cOrigem <> cCodOrig
		MaFisAlt("IT_CLASFIS",cOrigem + Substr(SC6->C6_CLASFIS,2),nItem, .T.)
		lAtuClas := .T.
	EndIf
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Executa o calculo de todos os impostos.                                ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If aRateio[RT_PRECOIT][5] > 0 .And. aRateio[RT_PRECOIT][5] <> MaFisRet(nItem,'IT_ALIQISS')
	MaFisAlt("IT_ALIQISS",aRateio[RT_PRECOIT][5],nItem,.T.)
EndIF

If ( aEntry[EP_M460VISS] )
	MaFisLoad("IT_VALISS",ExecBlock("M460VISS",.F.,.F.,MaFisRet(nItem,"IT_VALISS")),nItem)
EndIf
MaFisAlt("IT_VALMERC",aRateio[RT_PRECOIT][3]+aRateio[RT_PRECOIT][4],nItem, .T.)
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Compatibilizacao com os pontos de entrada anteriores                   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If ( SF4->F4_IPI<>"N" )
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Pontos de Entrada 													  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If ( aEntry[EP_M460IPT] )
		VALORIPI    := MaFisRet(nItem,"IT_VALIPI")
		BASEIPI     := MaFisRet(nItem,"IT_BASEIPI")
		QUANTIDADE  := MaFisRet(nItem,"IT_QUANT")
		ALIQIPI     := MaFisRet(nItem,"IT_ALIQIPI")
		BASEIPIFRETE:= MaFisRet(nItem,"IT_FRETE")
		MaFisAlt("IT_VALIPI",ExecTemplate("M460IPI",.F.,.F.,{SC9->(RecNo()),nItem}),nItem,.T.)
		MaFisLoad("IT_BASEIPI",BASEIPI,nItem)
		MaFisLoad("IT_ALIQIPI",ALIQIPI,nItem)
		MaFisLoad("IT_FRETE",BASEIPIFRETE,nItem)
	EndIf
	If ( aEntry[EP_M460IPI] )
		VALORIPI    := MaFisRet(nItem,"IT_VALIPI")
		BASEIPI     := MaFisRet(nItem,"IT_BASEIPI")
		QUANTIDADE  := MaFisRet(nItem,"IT_QUANT")
		ALIQIPI     := MaFisRet(nItem,"IT_ALIQIPI")
		BASEIPIFRETE:= MaFisRet(nItem,"IT_FRETE")
		MaFisAlt("IT_VALIPI",ExecBlock("M460IPI",.F.,.F.,{SC9->(RecNo()),nItem}),nItem,.T.)
		MaFisLoad("IT_BASEIPI",BASEIPI,nItem)
		MaFisLoad("IT_ALIQIPI",ALIQIPI,nItem)
		MaFisLoad("IT_FRETE",BASEIPIFRETE,nItem)
	EndIf
EndIf
If ( SF4->F4_ICM=="S" )
	If ( aEntry[EP_M460ICM] )
		_BASEICM    := MaFisRet(nItem,"IT_BASEICM")
		_ALIQICM    := MaFisRet(nItem,"IT_ALIQICM")
		_QUANTIDADE := MaFisRet(nItem,"IT_QUANT")
		_VALICM     := MaFisRet(nItem,"IT_VALICM")
		_FRETE      := MaFisRet(nItem,"IT_FRETE")
		_VALICMFRETE:= MaFisRet(nItem,"IT_ICMFRETE")
		_DESCONTO   := MaFisRet(nItem,"IT_DESCONTO")
		ExecBlock("M460ICM",.F.,.F., { nItem } )
		MaFisLoad("IT_BASEICM",_BASEICM,nItem)
		MaFisLoad("IT_ALIQICM",_ALIQICM,nItem)
		MaFisLoad("IT_VALICM",_VALICM,nItem)
		MaFisLoad("IT_FRETE",_FRETE,nItem)
		MaFisLoad("IT_ICMFRETE",_VALICMFRETE,nItem)
		MaFisLoad("IT_DESCONTO",_DESCONTO,nItem)
	EndIf
	If ( aEntry[EP_M460ICMT] )
		_lPedDCL    := .F.
		_BASEICM    := MaFisRet(nItem,"IT_BASEICM")
		_ALIQICM    := MaFisRet(nItem,"IT_ALIQICM")
		_QUANTIDADE := MaFisRet(nItem,"IT_QUANT")
		_VALICM     := MaFisRet(nItem,"IT_VALICM")
		_FRETE      := MaFisRet(nItem,"IT_FRETE")
		_VALICMFRETE:= MaFisRet(nItem,"IT_ICMFRETE")
		_DESCONTO   := MaFisRet(nItem,"IT_DESCONTO")

		aIcmTmp := ExecTemplate("M460ICM",.F.,.F.,{nItem})
		If ValType(aIcmTmp) == "A"
			aIcms := aClone(aIcmTmp)
		EndIf
		If Len(aIcms) == 2
			MaFisLoad("IT_VALFECP",NoRound(aIcms[1],2),nItem)
			MaFisLoad("IT_ALIQFECP" ,NoRound(aIcms[2],2),nItem)
		EndIf

		MaFisLoad("IT_BASEICM",_BASEICM,nItem)
		MaFisLoad("IT_ALIQICM",_ALIQICM,nItem)
		MaFisLoad("IT_VALICM",_VALICM,nItem)
		MaFisLoad("IT_FRETE",_FRETE,nItem)
		MaFisLoad("IT_ICMFRETE",_VALICMFRETE,nItem)
		MaFisLoad("IT_DESCONTO",_DESCONTO,nItem)
	EndIf

EndIf
If ( SC5->C5_TIPOCLI == "S" .Or. SC5->C5_TIPOCLI == "F" .Or. SC5->C5_TIPOCLI $ SuperGetMV("MV_TPSOLCF")  )
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Pontos de Entrada 													  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If ( aEntry[EP_M460SOT])
		_lPedDCL    := .F.
		ICMSITEM    := MaFisRet(nItem,"IT_VALICM")		// variavel para ponto de entrada
		QUANTITEM   := MaFisRet(nItem,"IT_QUANT")		// variavel para ponto de entrada
		BASEICMRET  := MaFisRet(nItem,"IT_BASESOL")	// criado apenas para o ponto de entrada
		MARGEMLUCR  := MaFisRet(nItem,"IT_MARGEM")		// criado apenas para o ponto de entrada
        _BASEICM    := MaFisRet(nItem,"IT_BASEICM")
		If (ExistTemplate("M460SOLI"))
		 	aSolidTmp := ExecTemplate("M460SOLI",.F.,.F.,{nItem,SC6->C6_ITEM})
		 	If ValType(aSolidTmp) == "A"
		 		aSolid := aClone(aSolidTmp)
		 	EndIf
		EndIf
		If Len(aSolid) >= 3
			MaFisLoad("IT_BASESOL",aSolid[1],nItem)
			MaFisLoad("IT_VALSOL" ,aSolid[2],nItem)
			MaFisLoad("IT_ALIQSOL",aSolid[3],nItem)
			If Len(aSolid) >= 5
				MaFisLoad("IT_VFECPST",aSolid[4],nItem)
				MaFisLoad("IT_ALFCST" ,aSolid[5],nItem)
				IF Len(aSolid) >= 7
					MaFisLoad("IT_MARGEM",aSolid[6],nItem)
					MaFisLoad("IT_PAUTST",aSolid[7],nItem)
                    If Len(aSolid) >= 8
                        MaFisLoad("IT_BSFCPST" ,NoRound(aSolid[8],2),nItem)
				    EndIF
				EndIF
			EndIf
		EndIf
	EndIf

	If ( aEntry[EP_M460SOLI] )
		ICMSITEM    := MaFisRet(nItem,"IT_VALICM")		// variavel para ponto de entrada
		QUANTITEM   := MaFisRet(nItem,"IT_QUANT")		// variavel para ponto de entrada
		BASEICMRET  := MaFisRet(nItem,"IT_BASESOL")	// criado apenas para o ponto de entrada
		MARGEMLUCR  := MaFisRet(nItem,"IT_MARGEM")		// criado apenas para o ponto de entrada
		If ExistBlock("M460SOLI")
			aSolidTmp := ExecBlock("M460SOLI",.F.,.F.,{nItem,SC6->C6_ITEM})
		EndIf
	 	If ValType(aSolidTmp) == "A"
	 		aSolid := aClone(aSolidTmp)
	 	EndIf
		If Len(aSolid) == 2
			MaFisLoad("IT_BASESOL",NoRound(aSolid[1],2),nItem)
			MaFisLoad("IT_VALSOL" ,NoRound(aSolid[2],2),nItem)
		Elseif Len(aSolid) == 4
			MaFisLoad("IT_BASESOL",NoRound(aSolid[1],2),nItem)
			MaFisLoad("IT_VALSOL" ,NoRound(aSolid[2],2),nItem)
			MaFisLoad("IT_MARGEM" ,NoRound(aSolid[3],2),nItem)
			MaFisLoad("IT_ALIQSOL" ,NoRound(aSolid[4],2),nItem)
		ElseIf Len(aSolid) == 7
			MaFisLoad("IT_BASESOL",NoRound(aSolid[1],2),nItem)
			MaFisLoad("IT_VALSOL" ,NoRound(aSolid[2],2),nItem)
			MaFisLoad("IT_MARGEM" ,NoRound(aSolid[3],2),nItem)
			MaFisLoad("IT_ALIQSOL",NoRound(aSolid[4],2),nItem)
			MaFisLoad("IT_BSFCPST",NoRound(aSolid[5],2),nItem)
			MaFisLoad("IT_ALFCST" ,NoRound(aSolid[6],2),nItem)
			MaFisLoad("IT_VFECPST",NoRound(aSolid[7],2),nItem)    					
		EndIf
	EndIf
EndIf

//Ajuste de valor do IPI para vendas do Loja quando é e-commerce com IPI embutido. - Loja e-Commerce
If !Empty(SC5->C5_PEDECOM) .Or. !Empty(SC5->C5_ORCRES)
    If ExistFunc("LjxjPvlSd2")
        LjxjPvlSd2(nItem, @aRateio)
    EndIf
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Finaliza a carga do item.                                              ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
MaFisEndLoad(nItem,2)

nValRetIss := MaFisRet(,"NF_VALISS")
If lPRetIss  .AND. ( nValRetIss > 0 .And. UfCodIbge(MaFisRet(,"NF_UFDEST")) + MaFisRet(,"NF_CODMUN") == "4314902" ) //Tratamento para ISS de Porto Alegre
	If SA1->A1_FRETISS == '2' .OR. nValRetIss > SuperGetMv("MV_VRETISS")
		MaFisAlt("NF_RECISS", "1")
	Else
		MaFisAlt("NF_RECISS", "2")
	EndIf
EndIf

If ExistTemplate("M460PEFRE") // TEMPLATE DCL
	ExecTemplate("M460PEFRE",.F.,.F.)
EndIf

nPrcVen	 := aRateio[RT_PRECOIT][1]
nPrUnit	 := aRateio[RT_PRECOIT][2]
nTotal	 := aRateio[RT_PRECOIT][3]
nDesconto:= aRateio[RT_PRECOIT][4]
nAcresFin:= aRateio[RT_PRECOIT][6]
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Calculo dos Impostos Financeiros                                        ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If ( SF4->F4_DUPLIC=="S" )
	aTitulo[_VLRTIT_]  += MaFisRet(nItem,'IT_BASEDUP')
	aTitulo[_VLRIRRF_] += MaFisRet(nItem,'IT_VALIRR')
	aTitulo[_VLRINSS_] += MaFisRet(nItem,'IT_VALINS')
	aTitulo[_VLRINSS_] += MaFisRet(nItem,'IT_VALINA')
	aTitulo[_VLRISS_]  += MaFisRet(nItem,'IT_VALISS')
	aTitulo[_VLRPIS_]  += MaFisRet(nItem,'IT_VALPIS')
	aTitulo[_VLRCSLL_] += MaFisRet(nItem,'IT_VALCSL')
	aTitulo[_VLRCOFI_] += MaFisRet(nItem,'IT_VALCOF')
	aTitulo[_VLRIPI_ ] += MaFisRet(nItem,'IT_VALIPI')
	aTitulo[_VLRSOL_ ] += MaFisRet(nItem,'IT_VALSOL')
	aTitulo[_VLRFET_ ] += MaFisRet(nItem,'IT_VALFET')
	aTitulo[_VLRFAB_ ] += MaFisRet(nItem,'IT_VALFAB')
	aTitulo[_VLRFAC_ ] += MaFisRet(nItem,'IT_VALFAC')
	aTitulo[_VLRTPDP_] += MaFisRet(nItem,'IT_VALTPDP')

	If lFmpeq
		aTitulo[_VLRFMP_]  += MaFisRet(nItem,'IT_VALFMP')
	EndIf
	If lFamad  
		aTitulo[_VLRFMD_]  += MaFisRet(nItem,'IT_VALFMD')
	EndIf	


	If MaFisRet(nItem,'IT_BASEDUP') > 0
		aTitulo[_VLRMOE_]      += aRateio[RT_PRECOIT][7]
		aTitulo[_VLRREA_]      += aRateio[RT_PRECOIT][3]
		aTitulo[_VLRACR_]      += aRateio[RT_PRECOIT][6]
		aTitulo[_VLRDESPAC2_]  += aRateio[RT_DESPAC2]
		If nMoeda <> 1
			aTitulo[_VLRDSPREA_] += aRateio[RT_FRETE]+aRateio[RT_SEGURO]+aRateio[RT_DESPESA]+aRateio[RT_FRETAUT]-aRateio[RT_DESCONT]
			aTitulo[_VLRDSPMOE_] += aRateio[RT_DESPMOE]
			If aTitulo[_VLRDESPAC2_] < 0
				aTitulo[_VLRTITDIF_] := (aTitulo[_VLRMOE_]+aTitulo[_VLRDESPAC2_])-xMoeda(aTitulo[_VLRREA_],1,nMoeda,dDataMoe,8)
			Else
				aTitulo[_VLRTITDIF_] := aTitulo[_VLRMOE_]+aTitulo[_VLRDSPMOE_]-xMoeda(aTitulo[_VLRREA_]+aTitulo[_VLRDSPREA_],1,nMoeda,dDataMoe,8)
			EndIf
		EndIf
		If nMoedaNDF <> 1 .And. aTitulo[_MOEDANDF_] <> -1
			If aTitulo[_MOEDANDF_] == 0
				aTitulo[_MOEDANDF_]	:= 	nMoedaNDF
			Else
				If nMoedaNDF <> aTitulo[_MOEDANDF_]
					aTitulo[_MOEDANDF_] := -1
				EndIf
			EndIf
			If aTitulo[_MOEDANDF_] > 0
				If aTitulo[_TAXANDF_ ] == 0
					aTitulo[_TAXANDF_] := nTaxaNDF
				Else
					aTitulo[_TAXANDF_ ] := (aTitulo[_VLRTIT_]/(xMoeda(aTitulo[_VLRTIT_],1,nMoedaNDF,dDataMoe,,,nTaxaNDF)))
				EndIf
			EndIf
		EndIf
	EndIf
	If lIma
		aTitulo[_VLRIMA_]  += MaFisRet(nItem,'IT_VALIMA')
	EndIf
	aTitulo[_VLBTISS_]  += MaFisRet(nItem,'IT_VALCPM')
Else
	IF SF4->(FieldGet(FieldPos("F4_DUPLIST")) == "1" )
		aTitulo[_VLRTIT_]  += MaFisRet(nItem,'IT_VALSOL')
	EndIf
	If SF4->(ColumnPos("F4_DUPLIPI")) > 0 .And. (SF4->F4_DUPLIPI == "1")
		aTitulo[_VLRTIT_]  += MaFisRet(nItem,'IT_VALIPI')
	EndIf
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Poder de Terceiro                                                       ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Do Case
	Case ( SF4->F4_PODER3=="D" .And. Empty(SC6->C6_NFORI) )
		cFilSB6	:= xFilial("SB6")
		cFilSF4	:= xFilial("SF4")
		dbSelectArea("SB6")
		dbSetOrder(1)
		MsSeek(cFilSB6+SC6->C6_PRODUTO+SC5->C5_CLIENTE+SC5->C5_LOJACLI+SC9->C9_IDENTB6)
		While ( !Eof() .And. cFilSB6 == SB6->B6_FILIAL .And.;
				SC6->C6_PRODUTO== SB6->B6_PRODUTO.And.;
				SC5->C5_CLIENTE== SB6->B6_CLIFOR .And.;
				SC5->C5_LOJACLI== SB6->B6_LOJA   .And.;
				SB6->B6_IDENT  == SC9->C9_IDENTB6 )
			dbSelectArea("SF4")
			dbSetOrder(1)
			MsSeek(cFilSF4+SB6->B6_TES)
			If ( SF4->F4_PODER3=="R" )
				cNfOri   := SB6->B6_DOC
				cSeriOri := SB6->B6_SERIE
				cItemOri := ""
				cIdentB6 := SC9->C9_IDENTB6
				dbSelectArea("SF4")
				dbSetOrder(1)
				MsGoto(aPvlSd2[13])
				Exit
			EndIf
			SB6->( DBSkip() )
		EndDo
	Case ( SF4->F4_PODER3=="N" .And. !Empty(SC9->C9_IDENTB6) )
		dbSelectArea("SD1")
		dbSetOrder(4)
		MsSeek(xFilial("SD1")+SC9->C9_IDENTB6)
		cNfOri   := SD1->D1_DOC
		cSeriOri := SD1->D1_SERIE
		cItemOri := SD1->D1_ITEM
		cIdentB6 := SC9->C9_IDENTB6
	OtherWise
		cNfOri   := SC6->C6_NFORI
		cSeriOri := SC6->C6_SERIORI
		cItemOri := SC6->C6_ITEMORI
		cIdentB6 := SC9->C9_IDENTB6
EndCase

//Tratamento para ICMS-ST de transporte, quando a nota nao deve possuir valor
//contabil, apenas os valores do ICMS Solidario

If SF4->F4_OBSSOL=="5" .And. SF4->F4_QTDZERO=="1"
	nPrUnit	:=	0
	nPrcVen	:=	0
	nTotal	:=	0
Endif

// Tratamento referente ao controle de armazem de terceiros para gravar o endereco informado no pedido mesmo com TES que nao atualiza estoque
If FindFunction("EstArmTerc")
	lContercOk := EstArmTerc()	// Verifica se o controle de armazem de terceiros esta habilitado
	If lContercOk .And. SF4->F4_ESTOQUE == "N" .And. SF4->F4_CONTERC == "1"
		lInfEnder := .T.
	EndIf
EndIf

RecLock("SD2",.T.)
SD2->D2_FILIAL   := xFilial("SD2")

SerieNfId("SD2",1,"D2_SERIE",,,, SF2->F2_SERIE )

SD2->D2_DOC      := SF2->F2_DOC
SD2->D2_ITEM     := cItemNf
SD2->D2_EMISSAO  := SF2->F2_EMISSAO
SD2->D2_TIPO     := SF2->F2_TIPO
SD2->D2_CLIENTE  := SF2->F2_CLIENTE
SD2->D2_LOJA     := SF2->F2_LOJA
SD2->D2_COD      := SC6->C6_PRODUTO
SD2->D2_QUANT    := aPvlSD2[4]
SD2->D2_UM       := SC6->C6_UM
SD2->D2_ESTOQUE	 := SF4->F4_ESTOQUE

If SD2->(ColumnPos("D2_TPREPAS")) > 0
	SD2->D2_TPREPAS := SC6->C6_TPREPAS
Endif

If !Empty(cAliq)
	SD2->D2_SITTRIB  := cAliq
Endif

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Vendas Cliente - 22/02/11                                ³
//³Grava os campos de Codigo da Lista de Presentes e Item da³
//³Lista de Presentes                                       ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If 	lUsaLstPre
	SD2->D2_CODLPRE	:= SC6->C6_CODLPRE
	SD2->D2_ITLPRE	:= SC6->C6_ITLPRE
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Vendas Cliente - 10/12/13                                ³
//³Grava os campos de Garantia para rastreio na devolucao   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

SD2->D2_ITEMGAR	 := SC6->C6_ITEMGAR
SD2->D2_ORCGAR	 := SC6->C6_ORCGAR

If Empty( aPvlSD2[17] )
	If aPvlSD2[4] == SC6->C6_QTDVEN
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Se baixou totalmente a primeira unidade de medida, baixa a segunda     ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		SD2->D2_QTSEGUM  := SC6->C6_UNSVEN
	Else
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Faz a conversao de unidade                                             ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		SD2->D2_QTSEGUM  := SF4->(ConvUm(SC6->C6_PRODUTO,aPvlSD2[4],0,2))
	EndIf
Else
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Fatura a quantidade efetivamente liberada                              ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	SD2->D2_QTSEGUM := aPvlSD2[17]
EndIf

SD2->D2_SEGUM    := SC6->C6_SEGUM
SD2->D2_DESC     := SC6->C6_DESCONT
SD2->D2_DESCON   := nDesconto
SD2->D2_PEDIDO   := SC6->C6_NUM
SD2->D2_ITEMPV   := SC6->C6_ITEM
SD2->D2_LOCAL    := SC9->C9_LOCAL
SD2->D2_NUMSERI  := SC6->C6_NUMSERI
SD2->D2_CODFAB   := SC6->C6_CODFAB
SD2->D2_LOJAFA   := SC6->C6_LOJAFA
SD2->D2_ITEMORI  := cItemOri
SD2->D2_PESO     := SB1->B1_PESO
SD2->D2_GRUPO    := SB1->B1_GRUPO
SD2->D2_TP       := SB1->B1_TIPO
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Se existir ao menos um campo contabil preenchido na SC6, faz a gravação  		³
//³dos mesmos, mesmo que algum esteja vazio, pois a situação foi forçada na        	³
//³digitação do pedido de venda, caso contrario pega os dados do produto			³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lConta .And. lCCusto .And. lItConta .And. lCValor
	If !Empty(SC6->C6_CONTA) .Or. !Empty(SC6->C6_CC) .Or. !Empty(SC6->C6_ITEMCTA) .Or. !Empty(SC6->C6_CLVL)
		SD2->D2_CONTA    := SC6->C6_CONTA
		SD2->D2_CCUSTO   := SC6->C6_CC
		SD2->D2_ITEMCC   := SC6->C6_ITEMCTA
		SD2->D2_CLVL     := SC6->C6_CLVL
	Else
		SD2->D2_CONTA    := SB1->B1_CONTA
		SD2->D2_CCUSTO   := SB1->B1_CC
		SD2->D2_ITEMCC   := SB1->B1_ITEMCC
		SD2->D2_CLVL     := SB1->B1_CLVL
	EndIf
Else
	SD2->D2_CONTA    := SB1->B1_CONTA
	SD2->D2_CCUSTO   := SB1->B1_CC
	SD2->D2_ITEMCC   := SB1->B1_ITEMCC
	SD2->D2_CLVL     := SB1->B1_CLVL
EndIf
SD2->D2_EST      := SF2->F2_EST
SD2->D2_PRUNIT   := nPrUnit
SD2->D2_BASEORI  := 0
SD2->D2_NUMSEQ   := cNumSeq
SD2->D2_VALACRS  := nAcresFin
SD2->D2_IDENTB6  := cIdentB6
SD2->D2_GRADE    := SC6->C6_GRADE
SD2->D2_CODISS   := SF4->(If(SF4->F4_ISS=="S", SC6->C6_CODISS , " " ))
SD2->D2_NUMLOTE  := SC9->C9_NUMLOTE
SD2->D2_LOTECTL  := SC9->C9_LOTECTL
If lInfEnder
	SD2->D2_LOCALIZ := SC6->C6_LOCALIZ
Else
	SD2->D2_LOCALIZ := RetLocaliz(SC9->(C9_FILIAL + C9_PRODUTO + C9_LOCAL + "SC6"     + C9_PEDIDO + C9_ITEM + C9_SEQUEN + C9_LOTECTL + C9_NUMLOTE))
EndIf
SD2->D2_DTVALID  := SC9->C9_DTVALID
SD2->D2_POTENCI  := SC9->C9_POTENCI
SD2->D2_CLASFIS  := SC6->C6_CLASFIS
SD2->D2_PROJPMS  := SC9->C9_PROJPMS
SD2->D2_TASKPMS  := SC9->C9_TASKPMS
SD2->D2_TRT  := SC9->C9_TRT
SD2->D2_LICITA 	  := SC9->C9_LICITA
SD2->D2_SERVIC   := SC9->C9_SERVIC
SD2->D2_PDV      := SF2->F2_PDV
IIf( lIsRussia , RU09XFUN09() ,.F.) // Fill in Russian tax fields

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Não pode tirar validação pois esses campos  			   ³
//³são criados pelo UPDATE CTBWIZENT					   ³
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
If lC6Ent05 .And. (!Empty(SC6->C6_EC05DB) .Or. !Empty(SC6->C6_EC05CR))
	SD2->D2_EC05DB := SC6->C6_EC05DB
	SD2->D2_EC05CR := SC6->C6_EC05CR
Endif
If lC6Ent06 .And. (!Empty(SC6->C6_EC06DB) .Or. !Empty(SC6->C6_EC06CR))
	SD2->D2_EC06DB := SC6->C6_EC06DB
	SD2->D2_EC06CR := SC6->C6_EC06CR
Endif
If lC6Ent07 .And. (!Empty(SC6->C6_EC07DB) .Or. !Empty(SC6->C6_EC07CR))
	SD2->D2_EC07DB := SC6->C6_EC07DB
	SD2->D2_EC07CR := SC6->C6_EC07CR
Endif
If lC6Ent08 .And. (!Empty(SC6->C6_EC08DB) .Or. !Empty(SC6->C6_EC08CR))
	SD2->D2_EC08DB := SC6->C6_EC08DB
	SD2->D2_EC08CR := SC6->C6_EC08CR
Endif
If lC6Ent09 .And. (!Empty(SC6->C6_EC09DB) .Or. !Empty(SC6->C6_EC09CR))
	SD2->D2_EC09DB := SC6->C6_EC09DB
	SD2->D2_EC09CR := SC6->C6_EC09CR
Endif

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Efetua a gravacao dos Impostos                                          ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
SF4->(MaFisWrite(2,"SD2",nItem))
//Retirada gravação dos campos de D2_VALICM, D2_PICM e D2_BASEICM com os respectivos campos de ISS, pois na função MAFISWRITE,
//chamada anteriormente, os referidos campos são gravados corretamente.
SD2->D2_DESCZFR  := SF4->(MaFisRet(nItem,'IT_DESCZF'))
If nModulo <> 43
	SD2->D2_CF := SC6->C6_CF
EndIf

//------Numero da Receita Agronômica

If SD2->(FieldPos("D2_NRECAGR"))> 0 .And. SC6->(FieldPos("C6_NRECAGR"))> 0
	SD2->D2_NRECAGR := SC6->C6_NRECAGR
Endif

//-----------------------------------

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Efetua a gravacao dos valores unitarios qdo. nao utiliza desc. ZF       ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If SD2->D2_DESCZFR == 0
	SD2->D2_PRCVEN	:= nPrcVen
	SD2->D2_TOTAL	:= nTotal
ElseIf FindFunction("IDZFTRBGen") .and. IDZFTRBGen(nITem)
	SD2->D2_TOTAL := SD2->D2_TOTAL - SD2->D2_DESCZFR
Else
	SD2->D2_TOTAL := SD2->D2_TOTAL - nDesconto
EndIf 

If lTrfICMS .And. SF4->F4_TRANFIL = '1'
	SD2->D2_TOTAL 	+= SD2->D2_VALICM
	SD2->D2_PRCVEN 	:= A410Arred(SD2->D2_TOTAL/IIf(SD2->D2_QUANT==0,1,SD2->D2_QUANT),"D2_PRCVEN")
EndIf

SD2->D2_EDTPMS   := SC9->C9_EDTPMS

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Tratamento para o Reg. CR=31 da Nova GIA quando não tiver interação com SIGAEEC ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If SD2->(Fieldpos(cCmpD2Re)) > 0 .And. SC6->(Fieldpos(cCmpC6Re)) > 0
   SD2->&(cCmpD2Re) := SC6->&(cCmpC6Re)
Endif

/* ------------------------------------------------------------------
  Preenchimento dos campos D2_VLIMPOR

O array aSxFci eh carregado no cabecalho do documento
aSxFci ->	[1] - MV_FISFRAS
			[2] - MV_FCIMOD
			[3] - AliasInDic("CFD")
			[4] - FieldPos("D2_FCICOD")
			[5] - FieldPos("D2_VLIMPOR")
			[6] - FieldPos("C6_VLIMPOR")
			[7] - FieldPos("D1_FCICOD")
			[8] - FieldPos("C6_FCICOD")						*/

If !lIsRussia .And. aSxFci[4]
	SD2->D2_FCICOD	:=	cFciCod
	// Preenchimento do Clasfis do Fci de revenda ou parâmetro MV_FCIATUC estiver ativo e o XFciGetOrigem retornou o codigo de FCI
	If lFISAUCF .And. (!Empty( cCodOrig ) .And. Empty(Iif(aSxFci[8],SC6->C6_FCICOD,"")) .Or. (lFCIAtuC .And. Type("aFCIxOri[2]") == "C" .And. !Empty(aFCIxOri[2])))
		SD2->D2_CLASFIS := MaFisRet(nItem, "IT_CLASFIS")
	EndIf
Endif
If !lIsRussia .And. aSxFci[5]
	SD2->D2_VLIMPOR	:=	nVlImp
Endif

If Empty(cFciCod) .And. lAtuClas
	SD2->D2_CLASFIS := MaFisRet(nItem, "IT_CLASFIS")
EndIf
// ------------------------------------------------------------------

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Desconta o Valor do ICMS DESONERADO do valor do Item D2_PRCVEN         ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If SF4->F4_AGREG$"R"
	SD2->D2_TOTAL  -= MaFisRet(nItem,"IT_DEDICM")
	SD2->D2_PRCVEN := A410Arred(SD2->D2_TOTAL/IIf(SD2->D2_QUANT==0,1,SD2->D2_QUANT),"D2_PRCVEN")
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Atualiza CAT/83										    ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lCAT83
	SD2->D2_CODLAN := SC6->C6_CODLAN
EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Pontos de Entrada 											       	   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If ( aEntry[EP_MSD2UMT] )
	SD2->D2_QTSEGUM := ExecTemplate("MSD2UM2",.F.,.F.,SC9->(RecNo()))
EndIf
If ( aEntry[EP_MSD2UM2] )
	SD2->D2_QTSEGUM := ExecBlock("MSD2UM2",.F.,.F.,SC9->(RecNo()))
EndIf
IF cEmbExp <> Nil
	SD2->D2_PREEMB := cEmbExp
EndIf
// Não deve gravar PCC para pessoa física.
If SA1->A1_PESSOA == "F"
	SD2->D2_BASEPIS := 0
	SD2->D2_VALPIS  := 0
	SD2->D2_BASECOF := 0
	SD2->D2_VALCOF  := 0
	SD2->D2_BASECSL := 0
	SD2->D2_VALCSL  := 0
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Tratamento para Legislação de Carga Tributária - Lei nº 12.741/2012 (Lei da Transparência)        ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If !(AllTrim(SD2->D2_CF) $ cMvCfLTran +"/"+ cMvCfLTra1 +"/"+ cMvCfLTra2  +"/"+ cMvCfLTra3)
	If SF2->F2_TIPOCLI == "F"  // Legislação aplicada apenas para cliente consumidor final
	 	// Função Fiscal para retorno da carga trubutária
		xAlqLeiTr := AlqLei2741(SB1->B1_POSIPI,SB1->B1_EX_NCM,SB1->B1_CODISS,SF2->F2_EST,SA1->A1_COD_MUN,SC9->C9_PRODUTO,nItem,SC9->C9_NUMLOTE,SC9->C9_LOTECTL,cMvFisCTrb, cMvFisAlCT,lMvFisFRas,SF2->F2_TIPO)
		If ValType(xAlqLeiTr) == "N"
			aAlqLeiTr := {xAlqLeiTr,0,0,0}
		Else
			aAlqLeiTr := aClone(xAlqLeiTr)
		EndIf

		If SF4->F4_DESCOND == "1"	//Desconto Condicional
			nDescCond := SD2->D2_DESCON
		EndIf
		
		if _xFisF_LT
			lFisNewLT := cMvFisCTrb <> "2" 
		else
			lFisNewLT := !(cMvFisAlCT == "3" .AND. cMvFisCTrb == "2")
		endif
		
		If Len(aAlqLeiTr) == 4 .OR. lFisNewLT
			nTotAlq := (aAlqLeiTr[1] / 100) * (SD2->D2_VALBRUT + nDescCond)
			nAlqFed := (aAlqLeiTr[2] / 100) * (SD2->D2_VALBRUT + nDescCond)
			nAlqEst := (aAlqLeiTr[3] / 100) * (SD2->D2_VALBRUT + nDescCond)
			nAlqMun := (aAlqLeiTr[4] / 100) * (SD2->D2_VALBRUT + nDescCond)
			SD2->D2_TOTIMP := nTotAlq
			SD2->D2_TOTFED := nAlqFed
			SD2->D2_TOTEST := nAlqEst
			SD2->D2_TOTMUN := nAlqMun
		ElseIf Len(aAlqLeiTr) == 8
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//Novo tratamento da Lei da Transparência - Fisxfun Retorna Array de 8 posiçoes com as aliquotas e totais ¿
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
			nTotAlq := aAlqLeiTr[5]
			nAlqFed := aAlqLeiTr[6]
			nAlqEst := aAlqLeiTr[7]
			nAlqMun := aAlqLeiTr[8]
			SD2->D2_TOTIMP := nTotAlq
			SD2->D2_TOTFED := nAlqFed
			SD2->D2_TOTEST := nAlqEst
		 	SD2->D2_TOTMUN := nAlqMun
       EndIf
	EndIf
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Tratativa Natureza de Rendimento (com ou sem suspensao)  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lUsaFKW .And.lC6NatRen .And. !Empty(SC6->C6_NATREN)

	//Recolhimento do IRRF - Emitente
	If ( SED->ED_RECIRRF == "2" .OR. ( SA1->A1_RECIRRF == "2" .AND. (SED->ED_RECIRRF == "3" .OR. SED->ED_RECIRRF == " ") ) )

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		// CALCULO NATUREZA DE RENDIMENTO ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

		//Soma total dos valores de IRRF
		If Empty(aNatRend[1]) 
			aNatRend[1] := SD2->D2_VALIRRF
		Else
			aNatRend[1] += SD2->D2_VALIRRF
		EndIf

		//Soma individual os valores de IRRF por Naturezas de Rendimento 
		nPosNatRen := aScan(aNatRend[2],{|x| x[1] == SC6->C6_NATREN})
		If nPosNatRen == 0
			aAdd(aNatRend[2],{SC6->C6_NATREN,SD2->D2_VALIRRF,SD2->D2_BASEIRR})
		Else
			aNatRend[2][nPosNatRen,2] += SD2->D2_VALIRRF
			aNatRend[2][nPosNatRen,3] += SD2->D2_BASEIRR
		Endif

		// RETIRADA TEMPORARIA DEVIDO ANALISE DA REGRA DE NEGOCIO - REINF
		
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		// CALCULO NATUREZA DE RENDIMENTO - COM INDICATIVO DE SUSPENSAO DE ABATIMENTO DE IRRF ³ 
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

		//Verifica se foi informado codigo indicativo de suspensao
		/*
		If lC6IndSus .And. !Empty(SC6->C6_INDSUS)
		
			//Verifica se trata-se do primeiro regristro. Caso nao for, nao precisa ordenar o indice novamente
			If Empty(aNatRend[3])
				AQZ->(DbSetOrder(2))//AQZ_FILIAL, AQZ_CLIENT, AQZ_LOJA, AQZ_INDSUS
			EndIf

			//Guarda os dados da AQZ - Clientes x Processos Ref.     
			If AQZ->(DbSeek(xFilial("AQZ")+SC6->C6_CLI+SC6->C6_LOJA+SC6->C6_INDSUS))

				//Soma total dos valores de IRRF que possuem Indicativo de Suspensao
				If Empty(aNatRend[3]) 
					aNatRend[3] := (SD2->D2_VALIRRF * AQZ->AQZ_PERIRF)/100
				Else
					aNatRend[3] += (SD2->D2_VALIRRF * AQZ->AQZ_PERIRF)/100
				EndIf


				//Soma individual os valores de IRRF por Naturezas de Rendimento com Suspensão Judicial
				nPosNatRen := aScan(aNatRend[4],{|x| x[1] == SC6->C6_NATREN})
				If nPosNatRen == 0
					aAdd(aNatRend[4],{SC6->C6_NATREN,(SD2->D2_VALIRRF * AQZ->AQZ_PERIRF)/100,(SD2->D2_BASEIRR * AQZ->AQZ_PERIRF)/100, ;
						AQZ->AQZ_PERIRF, AQZ->AQZ_NUMPRO, AQZ->AQZ_TIPO, AQZ->AQZ_INDSUS})
				Else
					aNatRend[4][nPosNatRen,2] += (SD2->D2_VALIRRF * AQZ->AQZ_PERIRF)/100
					aNatRend[4][nPosNatRen,3] += (SD2->D2_VALIRRF * AQZ->AQZ_PERIRF)/100
				Endif

			EndIf
			
		EndIf
		*/

	EndIf

Endif

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Atualiza Percentuais de Comissao                                        ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
cVendedor := "1"
For nCntFor := 1 To nMaxVend
	nComis := SC6->(FieldGet(FieldPos("C6_COMIS"+cVendedor)))
	If ( nComis == 0 )
		nComis := SC5->(FieldGet(FieldPos("C5_COMIS"+cVendedor)))
	EndIf
	SD2->(FieldPut(FieldPos("D2_COMIS"+cVendedor),nComis))
	cVendedor := Soma1(cVendedor,1)
Next nCntFor

If lTrbGen
	SD2->D2_IDTRIB	:= MaFisTG(1,"SD2",nItem)
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Atualiza o Cabecalho da Nota                                            ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If !InTransact()
	RecLock("SF2")
EndIf

If !Empty(SC5->C5_PEDEXP) .And. SuperGetMV("MV_EECFAT") .And. _lEECAtPesNF .And. EECAtuPesNF(SC5->C5_PEDEXP)

	IF nParEEC52 == 1
		aPesoEmb := CalcPeso(SC5->C5_PEDEXP,SD2->D2_ITEMPV,SD2->D2_QUANT,SC5->C5_NUM,Nil)
	Elseif nParEEC52 == 2

       FOR nI:=1 TO LEN(APVLNFS)
           IF APVLNFS[nI][2] == SD2->D2_ITEMPV
              nQuantFAT += APVLNFS[nI][4]
           EndIF
       Next nI

		aPesoEmb := CalcPeso(SC5->C5_PEDEXP,SD2->D2_ITEMPV,SD2->D2_QUANT,SC5->C5_NUM,nQuantFAT)
	ElseIF nParEEC52 == 3
		aPesoEmb := CalcPeso(SC5->C5_PEDEXP,SD2->D2_ITEMPV,SD2->D2_QUANT,SC5->C5_NUM,Nil)
	EndIF

	SF2->F2_PLIQUI     += aPesoEmb[1]
	SF2->F2_PBRUTO     += aPesoEmb[2]

Else
	If ( SC5->C5_PESOL == 0 )
		SF2->F2_PLIQUI     += SD2->D2_PESO * SD2->D2_QUANT
	EndIf
	If ( SC5->C5_PBRUTO == 0 )
		SF2->F2_PBRUTO     += SB1->B1_PESBRU * SD2->D2_QUANT
	EndIf
EndIf

SF2->F2_CARGA  := SC9->C9_CARGA
SF2->F2_SEQCAR := SC9->C9_SEQCAR
SF2->F2_SEQENT := SC9->C9_SEQENT
SF2->F2_DESCCAB += aRateio[RT_DESCONT]+aRateio[RT_PDESCON]

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Tratamento para Legislação de Carga Tributária - Lei nº 12.741/2012 (Lei da Transparência)        ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If !lIsRussia
	SF2->F2_TOTIMP := SF2->F2_TOTIMP + SD2->D2_TOTIMP
	SF2->F2_TOTFED := SF2->F2_TOTFED + SD2->D2_TOTFED
	SF2->F2_TOTEST := SF2->F2_TOTEST + SD2->D2_TOTEST
	SF2->F2_TOTMUN := SF2->F2_TOTMUN + SD2->D2_TOTMUN
EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Atualiza itens do Pedido de Venda                                       ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
RecLock("SC6",.F.)
SF4->(MaAvalSC6("SC6",5))
MsUnlock()
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Atualiza Itens de Pedido Liberado                                       ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
RecLock("SC9")
SF4->(MaAvalSC9("SC9",11))
MsUnLock()

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Gravação do Log de Liberação do Pedido de Venda                             ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lHabGrvLog //Habilita a função para gravação do log de liberação do pedido de venda
	Aadd(aLogLibPV,{SC9->C9_FILIAL,SC9->C9_PEDIDO,SC9->C9_ITEM,SC9->C9_PRODUTO,SC9->C9_QTDLIB,;
	SC5->C5_ORIGEM,SC9->C9_BLCRED,SC9->C9_BLEST,dDatabase,Time(),2,.F.,ProcName()})
	If !Empty(aLogLibPV)
		FATA410(aLogLibPV)
	EndIf
EndIf

If !Empty(SC9->C9_CARGA)
	OMSAvalSF2(aCarga,aPvlSD2[16])
EndIf

//Verifica integração com o módulo de Manutenção de Ativos e atualiza os insumos.
If lIntegNG .And. !Empty(SD2->D2_NFORI) .And. FindFunction("NGD1D2STL")
	NGD1D2STL(SD2->D2_NFORI, SD2->D2_SERIORI, SD2->D2_ITEMORI, SD2->D2_CLIENTE, SD2->D2_LOJA,SD2->D2_COD)
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Atualiza saldo no armazem de poder de terceiros                         ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
lCtrAtu:= .F.
If lEstTerc //Não transfere armazem quando FATXJOB esta ativo, pois neste momento não atualiza estoque
	lCtrAtu := .T.
	TrfSldPoder3(SD2->D2_TES,"SD2",SD2->D2_COD,.F.)
EndIf


//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Atualiza saldo do contrato SIGAGCT                                      ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If !Empty(SC6->C6_ITEMED)
	CtaAvalGCT(1,aContrato,SC5->C5_MDCONTR,SC5->C5_MDPLANI,SC6->C6_ITEMED,SD2->D2_QUANT,aMedicao,SC5->C5_MDNUMED,SD2->D2_TOTAL)
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Atualiza os acumulados do SD2                                           ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If ( aEntry[EP_MSD2460] )
	_ATITNEW := aTitulo
EndIf
SF2->(FkCommit(.T.))
MaAvalSD2(,,lAtuSA7,nItem,,lCtrAtu)
If ( aEntry[EP_MSD2460] )
	aTitulo := _ATITNEW
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Rotina para tratar a gravacao do rateio por item nota fiscal de saida.       ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

aAreaRat := GetArea()
dbSelectArea("AGG")
dbSetOrder(1) // AGG_FILIAL+AGG_PEDIDO+AGG_FORNEC+AGG_LOJA+AGG_ITEMPD+AGG_ITEM
If dbSeek(cFilAGG + SD2->D2_PEDIDO + SD2->D2_CLIENTE + SD2->D2_LOJA + SD2->D2_ITEMPV)
	While AGG->(!EOF()) .AND. AGG->(AGG_FILIAL+AGG_PEDIDO+AGG_FORNEC+AGG_LOJA+AGG_ITEMPD) == cFilAGG + SD2->D2_PEDIDO + SD2->D2_CLIENTE + SD2->D2_LOJA + SD2->D2_ITEMPV
		
		RecLock("AGH",.T.)
		AGH->AGH_FILIAL		:= 	cFilAGH
		AGH->AGH_NUM  		:=  SF2->F2_DOC

		SerieNfId("AGH",1,"AGH_SERIE",,,, SF2->F2_SERIE )

		AGH->AGH_FORNEC		:=  SD2->D2_CLIENTE
		AGH->AGH_LOJA 		:=  SD2->D2_LOJA
		AGH->AGH_ITEMPD 	:=	SD2->D2_ITEM
		AGH->AGH_ITEM   	:=  AGG->AGG_ITEM
		AGH->AGH_PERC 		:=	AGG->AGG_PERC
		AGH->AGH_CC 		:=  AGG->AGG_CC
		AGH->AGH_CONTA 		:=  AGG->AGG_CONTA
		AGH->AGH_ITEMCT  	:=  AGG->AGG_ITEMCT
		AGH->AGH_CLVL    	:=  AGG->AGG_CLVL
		AGH->AGH_CUSTO1 	:=  SD2->D2_CUSTO1 * (AGG->AGG_PERC/100)
		AGH->AGH_CUSTO2     :=  SD2->D2_CUSTO2 * (AGG->AGG_PERC/100)
		AGH->AGH_CUSTO3     :=	SD2->D2_CUSTO3 * (AGG->AGG_PERC/100)
		AGH->AGH_CUSTO4     :=  SD2->D2_CUSTO4 * (AGG->AGG_PERC/100)
		AGH->AGH_CUSTO5     :=  SD2->D2_CUSTO5 * (AGG->AGG_PERC/100)

		If lAGHTotal
			AGH->AGH_TOTAL := A410Arred(SD2->D2_VALBRUT * (AGG->AGG_PERC/100), "AGH_TOTAL",nMoeda) 
			nAGHRecn       := AGH->(Recno())
			nAGHTot        += AGH->AGH_TOTAL
		EndIf

		aEntidades := CtbEntArr()
		For nEnt := 1 to Len(aEntidades)
			For nDeb := 1 to 2
				cCpo := "AGH_EC"+aEntidades[nEnt]
				cAGG := "AGG_EC"+aEntidades[nEnt]

				If nDeb == 1
					cCpo += "DB"
					cAGG += "DB"
				Else
					cCpo += "CR"
					cAGG += "CR"
				EndIf

				AGH->(&(cCpo)) := AGG->(&(cAGG))

				If lRTCFin .And. SF4->F4_DUPLIC == "S"
					aAdd(aRatEnt, AGG->(&(cAGG)) )
				EndIf
				
			Next nDeb
		Next nEnt

		MsUnLock()
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Grava os lancamentos de rateio de Item de NFs SIGAPCO    ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		PcoDetLan("000101","03","MATA461")

		If lRTCFin .And. lAGHTotal .And. SF4->F4_DUPLIC == "S"
			aAdd(aRatFin,{AGH->AGH_CC, AGH->AGH_ITEMCT, AGH->AGH_CLVL,0, AGH->AGH_TOTAL, AGH->AGH_CONTA}) 
			For nCntFor := 1 To Len(aRatEnt)
				aAdd(aRatFin[Len(aRatFin)], aRatEnt[nCntFor])
			Next	
		EndIf	
		aSize( aRatEnt, 0 )		
		AGG->(dbSkip())
	EndDo
	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Na Ultima acerta as diferenca de centavo                                ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lAGHTotal .And. !(nAGHTot == SD2->D2_VALBRUT)
		RecLock("AGH",.F.)
		AGG->(DbGoto(nAGHRecn))
		If (nAGHTot > SD2->D2_VALBRUT )
			AGH->AGH_TOTAL -= nAGHTot - SD2->D2_VALBRUT
		Else
			AGH->AGH_TOTAL += SD2->D2_VALBRUT - nAGHTot
		EndIf
		MsUnLock()		
		If lRTCFin .And. SF4->F4_DUPLIC == "S"
			aRatFin[Len(aRatFin)][5] := AGH->AGH_TOTAL
		EndIf	
	EndIf
	
	RecLock("SD2",.F.)
		SD2->D2_RATEIO := "1"
	MsUnLock()
EndIf
RestArea(aAreaRat)

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Complemento Credito Acumulado ICMS - CAT207 / Livros Fiscais           ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
//-- Gravar complemento (CFF) para operacao geradora de credito acumulado ICMS (1=Sim).
If !lIsRussia .And. SF4->F4_CRDACUM == "1" .And. _lFisGrvCFF
    FisGrvCFF(,xFilial("CFF")+SD2->(D2_DOC+D2_SERIE+D2_CLIENTE+D2_LOJA+D2_ITEM),SD2->D2_ITEM) //-- CAT207.PRW
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Efetua baixa das partes no wms                                          ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If SF4->F4_ESTOQUE == "S" .And. lWmsNew .And. IntWms(SC9->C9_PRODUTO)
	MtBaixaWMS()
Endif

Return( .T. )

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³MaPvl2SF2 ³ Autor ³Eduardo Riera          ³ Data ³29.08.1999³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Gravacao da Nota Fiscal de Saida                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpL1: .T.                                                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³                                                            ³±±
±±³          ³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³   DATA   ³ Programador   ³Manutencao Efetuada                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³               ³                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function MaPvl2SF2(cSerie,cNumero,aPedido,lReajuste,lMoedaFre,lCtbOnLine,nValNeg,cPdv,cCgc,dDataMoe,cTypeDoc)

Local aEspVol  := {}
Local nCntFor  := 1
Local nMaxVend := Fa440CntVen()
Local cScan    := ""
Local nScan    := ""
Local cEstado  := ""
Local cCliEnt  := IIf(!Empty(SC5->C5_CLIENT),SC5->C5_CLIENT,SC5->C5_CLIENTE)
Local cLojaEnt := IIf(!Empty(SC5->C5_LOJAENT),SC5->C5_LOJAENT,SC5->C5_LOJACLI)
Local cVendedor:= "1"
Local nTotPBrut:= 0
Local nTotPesoL:= 0
Local cEspecie := ""
Local lTMSUFPAG:= SuperGetMv("MV_TMSUFPG",.F.,.F.) //-- Define se grava o estado do pagador do frete.
Local cMv_Estado  := SuperGetMv("MV_ESTADO")
Local cTesVend    := SuperGetMv("MV_TESVEND",,"")
Local lCfo        := .F.
Local aTimeUf		:= {}
Local aArea2		:= {}
Local aAreaSM0	:= {}
Local cHoraRMT	:= ""
Local lEECFAT		:= SuperGetMV("MV_EECFAT")
Local cFilSA1		:= xFilial("SA1")
Local cFilSA2		:= xFilial("SA2")
Local cFilSC5		:= xFilial("SC5")
Local cFilSC6		:= xFilial("SC6")
Local lNewInvoic 	:= Iif(__RpoRelease >= '12.1.2410',;
						 tlpp.ffunc("backoffice.fat.documento.UsaNewInvoice") .And.;
						 tlpp.call('backoffice.fat.documento.UsaNewInvoice()'),.F.)

Default dDataMoe	:= dDataBase
Default cTypeDoc	:= ""

cHoraRMT := SuperGetMv("MV_HORARMT",.F.,"2")
If ValType(cHoraRMT) == "L"
	If cHoraRMT
		cHoraRMT := "1"
	Else
		cHoraRMT := "2"
	EndIf
Else
	If cHoraRMT == NIL
		cHoraRMT := "2"
	EndIf
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Posiciona Registros                                                     ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If  ( SC5->C5_TIPO $ "DB" )
	dbSelectArea("SA2")
	dbSetOrder(1)
	If ( SC5->C5_CLIENTE+SC5->C5_LOJACLI <> cCliEnt+cLojaEnt )
		MsSeek(cFilSA2+cCliEnt+cLojaEnt )
		cEstado := SA2->A2_EST

		MsSeek(cFilSA2+SC5->C5_CLIENTE+SC5->C5_LOJACLI)
		cEstado := IIf(Empty(cEstado),SA2->A2_EST,cEstado)
	Else
		MsSeek(cFilSA2+SC5->C5_CLIENTE+SC5->C5_LOJACLI)
		cEstado := SA2->A2_EST
	EndIf
Else
	If ( SC5->C5_CLIENTE+SC5->C5_LOJACLI <> cCliEnt+cLojaEnt )
		dbSelectArea("SA1")
		dbSetOrder(1)
		MsSeek(cFilSA1+cCliEnt+cLojaEnt )
		cEstado := SA1->A1_EST

		MsSeek(cFilSA1+SC5->C5_CLIENTE+SC5->C5_LOJACLI)

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³A Consultoria Tributária, por meio da Resposta à Consulta nº 268/2004, determinou a aplicação das seguintes alíquotas nas Notas Fiscais de venda emitidas pelo vendedor remetente:                                                                         ³
		//³1) no caso previsto na letra "a" (venda para SP e entrega no PR) - aplicação da alíquota interna do Estado de São Paulo, visto que a operação entre o vendedor remetente e o adquirente originário é interna;                                              ³
		//³2) no caso previsto na letra "b" (venda para o DF e entrega no PR) - aplicação da alíquota interestadual prevista para as operações com o Paraná, ou seja, 12%, visto que a circulação da mercadoria se dá entre os Estado de São Paulo e do Paraná.       ³
		//³3) no caso previsto na letra "c" (venda para o RS e entrega no SP) - aplicação da alíquota interna do Estado de São Paulo, uma vez que se considera interna a operação, quando não se comprovar a saída da mercadoria do território do Estado de São Paulo,³
		//³ conforme previsto no art. 36, § 4º do RICMS/SP                                                                                                                                                                                                            ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If cMv_Estado == 'SP'.And. SA1->A1_EST == 'SP'
			dbSelectArea("SC6")
	   		dbSetOrder(1)
	   		MsSeek(cFilSC6+aPedido[nCntFor][1])

			While !SC6->(Eof()) .And. cFilSC6 == SC6->C6_FILIAL .And. SC6->C6_NUM    == aPedido[nCntFor][1]
				If Alltrim(SC6->C6_TES)$ Alltrim(cTesVend)
					lCfo:= 	.T.
				EndIf
	   			SC6->( DBSkip() )
	   		End

	   		If lCfo
				cEstado := SA1->A1_EST
			EndIf
		EndIF

		//--Se a chamada e pelo modulo SIGATMS, para gravar o estado precisamos respeitar o parametro MV_TMSUFPG,
		//--responsavel por todas as gravacoes de estado, na parte fiscal, se o parametro estiver ativado, gravo
		//--o estado que pegamos atraves do C5_CLIENTE+C5_LOJACLI, que e o cliente devedor do frete,
		//--caso contrario utilizo o estado do destinatario que ja estava gravado em cEstado
		If "TMSA200" $ FunName() //--SIGATMS, Calculo do Frete
			If lTMSUFPAG
				cEstado := SA1->A1_EST
			EndIf
		EndIf

		cEstado := IIf(Empty(cEstado),SA1->A1_EST,cEstado)
	Else
		dbSelectArea("SA1")
		dbSetOrder(1)
		MsSeek(cFilSA1+SC5->C5_CLIENTE+SC5->C5_LOJACLI)

		cEstado := SA1->A1_EST
	EndIf
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Calculo do Volumes                                                      ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
For nCntFor := 1 To Len(aPedido)
	dbSelectArea("SC5")
	dbSetOrder(1)
	MsSeek(cFilSC5+aPedido[nCntFor][1])

	cScan := "1"
	While ( !Empty(cScan) )
		cEspecie := Upper(FieldGet(FieldPos("C5_ESPECI"+cScan)))
		If !Empty(cEspecie)
			nScan := aScan(aEspVol,{|x| x[1] == cEspecie})
			If ( nScan==0 )
				aadd(aEspVol,{ cEspecie, FieldGet(FieldPos("C5_VOLUME"+cScan)), cScan})
			Else
				aEspVol[nScan][2] += FieldGet(FieldPos("C5_VOLUME"+cScan))
			EndIf
		EndIf
		cScan := Soma1(cScan,1) 
		If ( FieldPos("C5_ESPECI"+cScan) == 0 )
			cScan := ""
		EndIf
	EndDo
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Calculo dos Peso Bruto                                                  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If Empty(SC5->C5_PEDEXP) .Or. !lEECFAT .Or. ( !Empty(SC5->C5_PEDEXP) .AND. !EECAtuPesNF(SC5->C5_PEDEXP))
		nTotPBrut	+= FieldGet(FieldPos("C5_PBRUTO"))
		nTotPesoL	+= FieldGet(FieldPos("C5_PESOL"))
	EndIf
Next nCntFor

RecLock("SF2",.T.)

SF2->F2_FILIAL     := xFilial("SF2")
SF2->F2_DOC        := cNumero
SF2->F2_PDV        := cPdv
SF2->F2_ECF        := IIf(!Empty(cPdv),"S","")
SF2->F2_ESPECIE    := Iif(lNewInvoic .And.!Empty(cTypeDoc),cTypeDoc,A460Especie(cSerie))
SF2->F2_CLIENTE    := SC5->C5_CLIENTE
SF2->F2_LOJA       := SC5->C5_LOJACLI
SF2->F2_TIPO       := SC5->C5_TIPO
SF2->F2_COND       := SC5->C5_CONDPAG
SF2->F2_TIPOCLI    := SC5->C5_TIPOCLI

If SF2->(ColumnPos("F2_FRTCFOP")) > 0 .And. SC5->(ColumnPos("C5_FRTCFOP")) > 0
	SF2->F2_FRTCFOP := SC5->C5_FRTCFOP
EndIf
If SF2->(ColumnPos("F2_ESTPRES")) > 0
	SF2->F2_ESTPRES := SC5->C5_ESTPRES
EndIf
If SF2->(ColumnPos("F2_MUNPRES")) > 0
	SF2->F2_MUNPRES := SC5->C5_MUNPRES
EndIf
If cPaisLoc == "BRA"
	SF2->F2_TPCOMPL := SC5->C5_TPCOMPL
EndIf

If SC5->(ColumnPos("C5_CODA1U")) > 0 .AND. SF2->(ColumnPos("F2_CODA1U")) > 0	//Existem os campos do Código do Intermediador no Pedido de Venda e na Nota Fiscal (Campos inseridos durante a Versão 12.1.27)
	SF2->F2_CODA1U	:= SC5->C5_CODA1U
EndIf

dbSelectArea("DAK")
DAK->(dbSetOrder(1)) //DAK_FILIAL+DAK_COD+DAK_SEQCAR
If DAK->(FieldPos("DAK_TRANSP")) > 0 .And. IsInCallStack('MATA460B');
	.And. DAK->(MsSeek(xFilial("DAK")+SC9->C9_CARGA+SC9->C9_SEQCAR))
	SF2->F2_TRANSP     := Iif(!Empty(DAK->DAK_TRANSP), DAK->DAK_TRANSP, SC5->C5_TRANSP)
Else
	SF2->F2_TRANSP     := SC5->C5_TRANSP
EndIf
SF2->F2_REDESP     := SC5->C5_REDESP
SF2->F2_REAJUST    := If(!lReajuste,SC5->C5_REAJUST,"")

//Parametro MV_HORARMT habilitado pega a hora do smartclient, do servidor ou do Estado da Filial
If cHoraRMT == "1"
	SF2->F2_EMISSAO    := dDataBase
	SF2->F2_HORA       := SubStr(GetRmtTime(),1,5)

ElseIf cHoraRMT == "3"
	If cPaisLoc == "BRA"
		aArea2	:= GetArea()
		dbSelectArea("SM0")
		aAreaSM0	:= GetArea()
		dbSetOrder(1)
		If dbSeek(cEmpAnt+cFilAnt)
			aTimeUf := A103HORA()
		EndIf
		RestArea(aAreaSM0)
		RestArea(aArea2)

		SF2->F2_EMISSAO := aTimeUf[1]
		SF2->F2_HORA := SubStr(aTimeUf[2],1,5)
	Else
		SF2->F2_EMISSAO := dDataBase
		SF2->F2_HORA := SubStr(GetRmtTime(),1,5)
	EndIf

Else // 2- Default (data do servidor)
	SF2->F2_EMISSAO    := dDataBase
	SF2->F2_HORA       := SubStr(Time(),1,5)
EndIf

SerieNfId("SF2",1,"F2_SERIE",SF2->F2_EMISSAO,Iif(lNewInvoic .And.!Empty(cTypeDoc),cTypeDoc,A460Especie(cSerie)),cSerie)

If SC5->C5_MOEDA <> 1
	SF2->F2_DTTXREF := dDataMoe
EndIf
SF2->F2_REGIAO  := SA1->A1_REGIAO
SF2->F2_EST     := cEstado
SF2->F2_PBRUTO  := nTotPBrut
SF2->F2_PLIQUI  := nTotPesoL
SF2->F2_CLIENT	:=	SC5->C5_CLIENT
SF2->F2_LOJENT	:=	SC5->C5_LOJAENT
SF2->F2_TPFRETE := SC5->C5_TPFRETE
If !lIsRussia
	SF2->F2_CGCCLI	:= AllTrim(cCgc)
	SF2->F2_VEICUL1 := SC5->C5_VEICULO
	SF2->F2_RECFAUT := SC5->C5_RECFAUT
	SF2->F2_NFSUBST	:= SC5->C5_NFSUBST
	SF2->F2_CNO		:= SC5->C5_CNO

	If  SF2->(ColumnPos("F2_CLIRET")) > 0 .And. SF2->(ColumnPos("F2_LOJARET")) > 0 .And. SC5->(ColumnPos("C5_CLIRET")) > 0 .And. SC5->(ColumnPos("C5_LOJARET")) > 0
		SF2->F2_CLIRET	:=	SC5->C5_CLIRET
		SF2->F2_LOJARET	:=	SC5->C5_LOJARET
	EndIf
	If SC5->(ColumnPos("C5_CLIREM")) > 0 .And. SC5->(ColumnPos("C5_LOJAREM")) > 0 .And. SF2->(ColumnPos("F2_CLIREM")) > 0 .And. SF2->(ColumnPos("F2_LOJAREM")) > 0
		SF2->F2_CLIREM		:= SC5->C5_CLIREM
		SF2->F2_LOJAREM		:= SC5->C5_LOJAREM	
	EndIf
EndIf
SerieNfId("SF2",1,"F2_SERSUBS",,,, SC5->C5_SERSUBS )

If SF2->(ColumnPos("F2_MENNOTA")) > 0
	SF2->F2_MENNOTA  := SC5->C5_MENNOTA
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Ponto de Entrada Padrao                                                 ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If aEntry[EP_M461LSF2]
	ExecBlock("M461LSF2",.F.,.F.)
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Gravacao dos vendedores                                                 ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
cVendedor := "1"
For nCntFor := 1 To nMaxVend
	SF2->(FieldPut(FieldPos("F2_VEND"+cVendedor),SC5->(FieldGet(FieldPos("C5_VEND"+cVendedor)))))
	If SC5->(FieldPos("C5_CODRL"+cVendedor))>0
		SF2->(FieldPut(FieldPos("F2_CODRL"+cVendedor),SC5->(FieldGet(FieldPos("C5_CODRL"+cVendedor)))))
	EndIf
	cVendedor := Soma1(cVendedor,1)
Next nCntFor

//Inicializa as variaveis publicas do grupo de pergunta MT460A, devido estar utilizando a variavel MV_PAR11 logo abaixo.
Pergunte("MT460A",.F.)

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Gravacao dos Volumes/Especie                                            ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
For nCntFor := 1 To Len(aEspVol)
	If MV_PAR11 == 1 //Aglut.Ped. Iguais ? 1=SIM/2=NAO (MT460A)
		SF2->(FieldPut(FieldPos("F2_ESPECI"+StrZero(nCntFor,1)),aEspVol[nCntFor,1]))
		SF2->(FieldPut(FieldPos("F2_VOLUME"+StrZero(nCntFor,1)),aEspVol[nCntFor,2]))
	Else
		SF2->(FieldPut(FieldPos("F2_ESPECI"+aEspVol[nCntFor,3]),aEspVol[nCntFor,1]))
		SF2->(FieldPut(FieldPos("F2_VOLUME"+aEspVol[nCntFor,3]),aEspVol[nCntFor,2]))
	EndIf
Next nCntFor

If SF2->(ColumnPos("F2_IDNF")) > 0
	SF2->F2_IDNF := FWUUID("SF2")
EndIf

Return( .T. )

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³MaNfs2Fin ³ Autor ³Eduardo Riera          ³ Data ³29.08.1999³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Gravacao dos Dados Financeiros                              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpL1: .T.                                                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpA1: Array aTitulo                                        ³±±
±±³          ³       [1] Valor do Titulo                                  ³±±
±±³          ³       [2] Valor do IRF                                     ³±±
±±³          ³       [3] Valor do INSS                                    ³±±
±±³          ³       [4] Valor do ISS                                     ³±±
±±³          ³       [5] Valor do PIS                                     ³±±
±±³          ³       [6] Valor do CSLL                                    ³±±
±±³          ³       [7] Valor do COFINS                                  ³±±
±±³          ³       [8] Valor do IPI                                     ³±±
±±³          ³       [9] Valor do Solidario                               ³±±
±±³          ³ExpN2: Moeda do Titulo                                      ³±±
±±³          ³ExpC3: Codigo do Banco                                      ³±±
±±³          ³ExpC4: Numero do Pedido                                     ³±±
±±³          ³ExpB5: Code block para complemento de atualizacao dos titu- ³±±
±±³          ³       los financeiros.                                     ³±±
±±³          ³ExpA6: Array contendo o contrato (GCT) relacionado pelo     ³±±
±±³          ³       pedido de contrato                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³   DATA   ³ Programador   ³Manutencao Efetuada                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³               ³                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function MaNfs2Fin(aTitulo,nMoeda,cBanco,cPedido,bAtuFin,lCtbOnLine,cFornISS,cRecISS, cB1M996,cB1FRETISS,aContrato,aMedicao,aRecSE1Adt,dDataMoe,nHdlPrv,nISSNDesc,aRatFin,aNatRend)

Local aVencto   := {}
Local aImposto  := {}
Local aImpOut   := {}
Local aProp     := {}
Local aRecSe1   := {}
Local aRecSe2   := {}
Local aRecNDF   := {}
Local aCtbRet   := {0,0,0}

Local dDataCnd  := SF2->F2_EMISSAO

Local cSerieId  := SF2->F2_SERIE
Local cMoedaTit := SuperGetMv("MV_MOEDTIT")
Local cVendedor := 0
Local cConteudo := ""
Local cParcela  := ""
Local cAliasSE2 := "SE2"
Local cPrefOri  := ""
Local cNumOri   := ""
Local cParcOri  := ""
Local cTipoOri  := ""
Local cCfOri    := ""
Local cLojaOri  := ""
Local cTipoData := SuperGetMV( "MV_TD10925",, "1" )
Local cAplVlMn	:= "1"
Local cAlIssB1  := SuperGetMV("MV_ALISSB1",,"")
Local cAliasSE1 := ""
Local cPrfx     := &(SuperGetMv("MV_1DUPREF"))
Local cE1Tipo	:= ""
Local cF2Num	:= ""
Local cFilSE1	:= xFilial("SE1")

Local lF440Com  := aEntry[EP_F440COM]
Local lM460IREN := aEntry[EP_M460IREN]
Local lAbate    := .F.
Local lComissao := SuperGetMv("MV_TPCOMIS")=="O"
Local lTemVend  := .F.
Local lCompensa := SuperGetMv("MV_CMPDEVC",.F.,.F.)	//Compensar automatica dev. Compras
Local lCMPDVNF  := SuperGetMv("MV_CMPDVNF",.F.,.F.)	//Compensar dev. Compras por Nota Fiscal
Local nY		:= 0
Local lUsaNewKey:= GetSx3Cache("F2_SERIE","X3_TAMANHO") == 14 // Verifica se o novo formato de gravacao do Id nos campos _SERIE esta em uso

Local nPerJur   := SuperGetMv("MV_TXPER")
Local nDecE1Vlr := GetSx3Cache("E1_VALOR","X3_DECIMAL")
Local nDecE1Vlc := GetSx3Cache("E1_VLCRUZ","X3_DECIMAL")
Local nVendedor := 0
Local nVlrParc  := 0
Local nVlrMoed1 := 0
Local nTotMoeda := 0
Local nTotMoed1 := 0
Local nVlrAcum1 := 0
Local nVlrAcum2 := 0
Local nTotalDev := 0
Local nCntFor   := 0
Local cImposto  := "0000000"
Local nImpISS   := 0
Local nImpIRRF  := 0
Local nImpINSS  := 0
Local nImpCSLL  := 0
Local nImpCOF   := 0
Local nImpPIS   := 0
Local nImpFet   := 0
Local nImpFab   := 0
Local nImpFac   := 0
Local nMaxVend  := Fa440CntVen()
Local nAbtISS   := 0
Local nFatorParc:= 0
Local nValTot   := 0
Local nBasePis  := MaFisRet(,"NF_BASEPIS")
Local nBaseCof  := MaFisRet(,"NF_BASECOF")
Local nBaseCsl  := MaFisRet(,"NF_BASECSL")
Local nBaseIns  := MaFisRet(,"NF_BASEINS")
Local nBaseIrf  := MaFisRet(,"NF_BASEIRR")
Local nSaldoPis := nBasePis
Local nSaldoCof := nBaseCof
Local nSaldoCsl := nBaseCsl
Local nSaldoIns := nBaseIns
Local nSaldoIrf := nBaseIrf
Local nSaldoProp:= 0
Local nProp     := 0
Local nRetParISS:= 0
Local lPsCodPerd:= (SED->(ColumnPos("ED_CODPERD")) > 0)
Local nValMinRet:= SuperGetMV( "MV_VL10925",, 0 )
Local cModRet   := SuperGetMV( "MV_AB10925",, "0" )
Local aAcumulMes:= {}
Local aRecnos   := {}
Local aDadosRet := {}

Local cAnoMes := ""

Local nVlRetPIS := 0
Local nVlRetCOF := 0
Local nVlRetCSLL:= 0
Local nTotARet  := 0
Local nSobra    := 0
Local nFatorRed := 0
Local nLoop     := 0
Local nScanMes  := 0
Local nX        := 0
Local lContrAbt := !Empty( SE1->( FieldPos( "E1_SABTPIS" ) ) ) .And. !Empty( SE1->( FieldPos( "E1_SABTCOF" ) ) ) .And. ;
				 !Empty( SE1->( FieldPos( "E1_SABTCSL" ) ) )
Local lGerAbtISS:= ( SuperGetMV("MV_TPABISS",,"1")=="2" )

Local cRetCli   := "1"
Local lCondVenda := .F.

Local cA1M996		:=	""
Local cMV_A1M996	:=	SuperGetMV("MV_A1M996",, "")
Local cTipoParc     := ""
Local cA1FRETISS	:=	""

Local aStruSE2  := {}
Local cQuery    := ""

Local lBaseImp  := ( SuperGetMv("MV_BS10925",.F.,"1") == "1")
Local nBasePCC	:=	Iif(nBasePis==0,Iif(nBaseCof==0,Iif(nBaseCsl==0,0,nBaseCsl),nBaseCof),nBasePis)
Local aTitCndVnd	:= {}
Local cNatureza := IIF (SC5->(FieldPos("C5_NATUREZ"))>0 .AND. !Empty(SC5->C5_NATUREZ), SC5->C5_NATUREZ, Nil)

Local lRotTMS		:= nModulo == 43	// Verifica se modulo utilizado eh TMS
Local cNatCli		:= ""
Local cChave		:= ""
Local lNewPCC		:= SF2->F2_EMISSAO >= STOD("20150622")
Local nVlrMin	    := SuperGetMv("MV_VL13137", .T., 10 ) // Parametro do minimo do novo PCC utilizado com a variável lNewPCC
Local nVencto 		:= SuperGetMv("MV_VCPCCR",.T.,1)
Local dRef			:= dDatabase
Local nValRefPCC 	:= 0
Local nDecTaxa  	:= GetSx3Cache("F1_TXMOEDA","X3_DECIMAL")
Local nTamPrefix 	:= GetSx3Cache("E1_PREFIXO","X3_TAMANHO")
Local cCodIRRF		:= ""
Local lMVCheckNF	:= SuperGetMv("MV_CHECKNF",.F.,.F.)
Local cMV1DupRef	:= SuperGetMv("MV_1DUPREF")
Local cMV1DupNat	:= SuperGetMv("MV_1DUPNAT")
Local lBaseIRTot	:= .F.
Local nVRetISS		:= SuperGetMV("MV_VRETISS",,0)
Local lFmpeq   		:= (SE1->(ColumnPos("E1_FMPEQ")) > 0) .And. (SF3->(ColumnPos("F3_VALFMP")) > 0)
Local lFamad   		:= (SE1->(FieldPos("E1_FAMAD")) > 0) .And. (SF3->(FieldPos("F3_VALFMD")) > 0) 
Local nImpFmp   	:= 0
Local nImpIma   	:= 0
Local nImpFam   	:= 0
Local lIma			:= (SE1->(ColumnPos("E1_IMA")) > 0) .And. (SF3->(ColumnPos("F3_VALIMA")) > 0) .And. !Empty(MaFisScan("IT_VALIMA",.F.))
Local lPosBTISS		:= SE1->(ColumnPos("E1_BTRISS")) > 0 .And. SE1->(ColumnPos("E1_VRETBIS")) > 0 .And. SE1->(ColumnPos("E1_CODSERV")) > 0
Local cCodISS		:= MafisRet(1,"IT_CODISS")
Local nContTg		:= 0
Local aTGCalc		:= {}
Local aTGRet		:= {}
Local aTGCalcRet	:= {}
Local aImpCalc		:= {}
Local aImpos		:= {}
Local lProcFin		:= .F.
Local lUltParc		:= .F.
Local aTGCalcRec    := {}
Local cNumTitTG     := ""
Local lTrbGen       := IIf(_lChkTrbGen, ChkTrbGen("SD2","D2_IDTRIB"), .F.)
Local lGEMTipTit	:= ExistTemplate("GEMTipTit")
Local lGEMLixParc	:= ExistTemplate("GEMLIXPARC")
Local lMoedaFre		:= SuperGetMv("MV_FRETMOE",.F.,"N") == "S"
Local nScan   		:= 0
Local nDifDsp 		:= 0
Local nDifMoePV     := 0
Local nInd 			:= 0
Local aSC5Area		:= {}
Local lUseRISK		:= lRiskIsAtv .And. RskIsActive()
Local lRetAuto		:= SuperGetMv("MV_RETAUTO",,.F.)
Local cRematri		:= SuperGetMv("MV_REMATRI", ,"")
Local lAprAuto		:= SuperGetMv("MV_APRAUTO",.F.,.T.)
Local aFinPCC		:= {0,0,0,0,0,0} // [1]Total Pis; [2]Soma Pis; [3]Total COFINS; [4]Soma Cofins; [5]Total CSLL; [6]Soma CSLL
Local aSE1NatRen	:= Array(2)
Local lUsaNatRen	:= (cPaisLoc == 'BRA' .And. ChkFile("FKW") .And. FindFunction("A461FKW") .And. !Empty(aNatRend[1]))
Local nDecRateio  	:= GetSx3Cache("EC_RATEIO","X3_DECIMAL")

//variaveis para retenção motor de tributos, Configurador de Tributos genéricos
Local lPccMR		:=.F.
Local lIrfMR		:=.F.
Local lInsMR		:=.F.
Local lIssMR		:=.F.
Local lCidMR		:=.F.
Local lSestMR		:=.F.
Local lFunMR        :=.F.
Local lFamadMR      :=.F.
Local lFethabMR     :=.F.
Local lFacsMR       :=.F.
Local lImaMR        :=.F.
Local lFabovMR      :=.F.
Private nValFun := SF2->F2_CONTSOC

//Gestao de Contratos
Default aContrato := {}
Default aMedicao  := {}

DEFAULT cPedido := ""
DEFAULT bAtuFin := {|| .T.}
DEFAULT cFornISS:= ""
DEFAULT cRecISS := SA1->A1_RECISS

Default cB1M996	:=	""
Default cB1FRETISS :=  ""

Default aRecSE1Adt := Array(0)
Default dDataMoe := dDataBase
Default nISSNDesc := 0
Default aRatFin   := {}
Default aNatRend  := Array(4)

aSE1NatRen[2] := {}

//Se módulo SIGATUR originou a chamada, existe um tratamento diferenciado para obter a natureza
If SC5->(FieldPos("C5_NATUREZ"))>0 .AND. !Empty(SC5->C5_NATUREZ)
	cNatureza := SC5->C5_NATUREZ
EndIf

If Empty(dDataMoe)
	dDataMoe := dDatabase
Endif

If (SA1->(FieldPos (cMV_A1M996))>0)		//Campo da tabela SE1 identifica fornecimento de (1) bens e Servicos contratados por pessoa juridica de direito publico ou (2 ou '') identifica que Nao.
	cA1M996	:=	SA1->(FieldGet (FieldPos (cMV_A1M996)))
EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Atendimento ao DECRETO 5.052, DE 08/01/2004 para o municipio de ARARAS. ³
//³Mais especificamente o paragrafo unico do Art 2.                        ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If !lIsRussia
	cA1FRETISS	:=	SA1->(FieldGet (FieldPos ("A1_FRETISS")))
EndIf
If lContrAbt
	cRetCli := Iif(Empty(SA1->A1_ABATIMP),"1",SA1->A1_ABATIMP)
Endif

//tratamento para empresa publica. deve ser feito a retencao sem verificar o valor minimo
If ("1"$cA1M996) .And. (SA1->A1_RECCSLL == "P" .Or. SA1->A1_RECCOFI == "P" .Or. SA1->A1_RECPIS == "P")
   nValMinRet := 0
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Indica se o tratamento de valor minimo para retencao (R$ 5.000,00) deve ser aplicado:³
//³Controle pela variavel cAplVlMn, onde :                                              ³
//³1 = Aplica o valor minimo                                                            ³
//³2 = Nao aplica o valor minimo                                                        ³
//³Quando o tratamento da retencao for pela emissao, sera forcada a retencao em cada    ³
//³movimento. Quando o tratamento da retencao for pela baixa, o financeiro ira usar o   ³
//³campo E1_APLVLMN para identificar se utilizara ou nao o valor minimo para retencao.  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If MaFisRet(,"NF_PIS252") > 0 .Or. MaFisRet(,"NF_COF252") > 0
	cModRet 	:= "1"
	cAplVlMn	:= "2"
	cRetCli		:= "2"
Endif
If ( aEntry[EP_M460MOED] )
	cMoedaTit := ExecBlock("M460MOED", .F., .F.,cMoedaTit)
EndIf

nMoeda := If(cMoedaTit=="S",nMoeda,1)

If ( aEntry[EP_M460COND] )
	dDataCnd := ExecBlock("M460COND", .F., .F.,{dDataCnd})
EndIf

If lGerAbtISS .And. cRecISS == "2"
	lGerAbtISS := .F.
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Projeto Chave Unica                                                                ³
//³Caso estiver sendo utilizado o recurso de gravar o ID de controle no campo F2_SERIE³
//³( lUsaNewKey := .T.),  os documentos poderão repetir o mesmo numero e serie, neste ³
//³caso a query abaixo consulta os titulos anteriores para evitar a duplicidade no SE1³
//³Caso encontre titulos anteriores com o mesmo numero ascrecenta soma1() ao prefixo. ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lUsaNewKey
	SE1->(dbSetOrder(1))
	cE1Tipo:=Left(MVNOTAFIS, GetSx3Cache("E1_TIPO","X3_TAMANHO"))
	cF2Num:=subStr(SF2->F2_DOC,1,GetSx3Cache("E1_NUM","X3_TAMANHO"))

	cAliasSE1 := "A461PRFX"
	cQuery += " SELECT MAX(E1_PREFIXO) E1PRFXMAX  FROM " + RetSqlName("SE1")
	cQuery += " WHERE E1_FILIAL = '" + cFilSE1 + "'"
	cQuery += " AND E1_NUM      = '" + SF2->F2_DOC + "'"
	cQuery += " AND D_E_L_E_T_  = ' ' "

	cQuery	  := ChangeQuery(cQuery)
	cAliasSE1 := GetNextAlias()
	dbUseArea( .T., "TOPCONN", TcGenQry( , , cQuery ), cAliasSE1, .T., .T. )

	dbSelectArea(cAliasSE1)
	If !Empty( (cAliasSE1)->E1PRFXMAX )
		cPrfx := Soma1( (cAliasSE1)->E1PRFXMAX , nTamPrefix )
		/*
		Devido ao projeto CHAVE ÚNICA, a consistência abaixo é necessária para
		garantir que o novo título a ser gerado não irá colidir com um título
		da base histórica do cliente criada antes do projeto chave única.
		*/
		While .T.
			If (SE1->(dbSeek(cFilSE1+cPrfx+cF2Num)))
				cPrfx:= Soma1(cPrfx, nTamPrefix)
			Else
				EXIT
			EndIf
		EndDo
	Else
		cPrfx:=subStr(&(cMV1DupRef),1,nTamPrefix)
	EndIf

	(cAliasSE1)->( DBCloseArea() )

	DBSelectArea("SF2")

EndIf
If ( SF2->F2_TIPO == "D" )
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Gera Titulo Credito ao Fornecedor                 ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	//ADupCred(aTitulo[_VLRTIT_],"501")
	If aTitulo[_MOEDANDF_]<=0
		Aadd(aRecNDF,ADupCred(aTitulo[_VLRTIT_],"501",nMoeda/*nMoeda*/,cNatureza,/*nTaxaNCC*/))
	Else
		Aadd(aRecNDF,ADupCred(xMoeda(aTitulo[_VLRTIT_],1,aTitulo[_MOEDANDF_],dDataMoe,nDecTaxa,,aTitulo[_TAXANDF_])+aTitulo[_VLRTITDIF_],"501",aTitulo[_MOEDANDF_]/*nMoeda*/,cNatureza,aTitulo[_TAXANDF_]/*nTaxaNCC*/))
	EndIf
	If lCompensa  //Compensacao automatica do titulo

		dbSelectArea("SE2")
		dbSetOrder(6)

		aStruSE2		:= SE2->(dbStruct())
		cAliasSE2	:= "A461DEV"
		cQuery		:= "SELECT SE2.E2_FILIAL, SE2.E2_SALDO ,SE2.E2_FORNECE, SE2.E2_LOJA, SE2.E2_NUMBOR ,"
		cQuery		+= " SE2.E2_PREFIXO, SE2.E2_NUM, SE2.E2_TIPO,SE2.E2_MOEDA, SE2.R_E_C_N_O_ SE2RECNO ,"
		cQuery		+= " SD2.D2_FILIAL,SD2.D2_DOC,SD2.D2_SERIE,SD2.D2_ITEM,SD2.D2_COD,SD2.D2_TOTAL,"
		cQuery		+= " SD2.D2_PEDIDO,SD2.D2_ITEMPV,SD2.D2_CLIENTE,SD2.D2_LOJA "
		cQuery		+= " FROM "+RetSqlName("SE2")+" SE2 "
		cQuery		+= " JOIN "+RetSqlName("SF1")+" SF1 ON SF1.F1_PREFIXO = SE2.E2_PREFIXO AND SE2.E2_NUM = SF1.F1_DOC AND SF1.D_E_L_E_T_ = ' ' "
		cQuery		+= " JOIN "+RetSqlName("SD2")+" SD2 ON SD2.D2_PEDIDO ='"+cPedido+"' AND SD2.D2_NFORI = SF1.F1_DOC AND SD2.D2_SERIORI = SF1.F1_SERIE AND SD2.D_E_L_E_T_ = ' ' "
		cQuery		+= " WHERE SE2.E2_FILIAL='"+xFilial("SE2")+"' AND "
		cQuery		+= " SE2.E2_TIPO='NF ' AND "
		cQuery		+=	" SE2.E2_FORNECE = '" + SF1->F1_FORNECE + "' AND "
		cQuery		+= " SE2.E2_LOJA = '" + SF1->F1_LOJA + "' AND "
		cQuery		+= " SE2.D_E_L_E_T_=' ' "
		cQuery		+= " ORDER BY "+SqlOrder(SE2->(IndexKey()))

		cQuery := ChangeQuery(cQuery)

		dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasSE2,.T.,.T.)
		For nX := 1 To Len(aStruSE2)
			If aStruSE2[nX][2]<>"C"
				TcSetField(cAliasSE2,aStruSE2[nX][1],aStruSE2[nX][2],aStruSE2[nX][3],aStruSE2[nX][4])
			EndIf
		Next nX

		While (cAliasSE2)->(!Eof())
			If Empty((cAliasSE2)->E2_NUMBOR)
				If !lMVCheckNF
					If !lCMPDVNF
						aAdd(aRecSE2,(cAliasSE2)->SE2RECNO)
					Else
						aAdd(aRecSE2,{(cAliasSE2)->SE2RECNO,(cAliasSE2)->D2_TOTAL})
					EndIf
					nTotalDev += xMoeda((cAliasSE2)->E2_SALDO,(cAliasSE2)->E2_MOEDA,1)
				EndIf
			EndIf
			(cAliasSE2)->( DBSkip() )
		EndDo
		//Compensacao automatica do titulo
		If !lCMPDVNF
			MaIntBxCP(2,aRecSe2,,aRecNDF,,{lCtbOnLine,.F.,.F.,.F.,.F.,.F.},,,,,,,nHdlPrv)
		Else
			//O valor será abatido do título da NF origem que foi informada no pedido de devolução.
			For nY := 1 to Len(aRecSE2)
				MaIntBxCP(2,{aRecSE2[nY][1]},,aRecNDF,,{lCtbOnLine,.F.,.F.,.F.,.F.,.F.},,,,aRecSE2[nY][2],,,nHdlPrv)
			Next nY
		EndIf

		(cAliasSE2)->( DBCloseArea() )
		DBSelectArea("SE2")

	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Atualiza o SF2                                                          ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If !InTransact()
		RecLock("SF2")
	EndIf
	SF2->F2_PREFIXO:= SE2->E2_PREFIXO
	SF2->F2_DUPL   := SF2->F2_DOC
Else
	If !(SF2->F2_TIPO$"B")

		//
		// Template GEM - Gestao de Empreendimentos Imobiliarios
		//
		// Verifica se a condicao de pagamento tem vinculacao com uma condicao de venda
		//
		If ExistTemplate("GMCondPagto") .And. HasTemplate("LOT")
			lCondVenda := ExecTemplate("GMCondPagto",.F.,.F.,{SF2->F2_COND,} )
			If ValType(lCondVenda) # "L"
				lCondVenda := .F.
			EndIf
		EndIf

		//Corrige desconto devido ISS do item ter ficado menor que limite mas total de ISS ficou maior.
		If nISSNDesc > 0 .And. aTitulo[_VLRISS_] > nVRetISS
			aTitulo[_VLRTIT_] -= nISSNDesc
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Verifica o numero de parcelas dos impostos                             ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		// Se for moeda 2 e MV_MOEDTIT = "S", passa valor convertido para que não ocorra problema de arredondamento nas duplicatas.
		If lRotTMS .And. IsInCallStack("MaNfs2Nfs") .And. nMoeda <> 1 .And. cMoedaTit == "S"		
			aVencto := Condicao(xMoeda(aTitulo[_VLRTIT_],1,nMoeda,dDataMoe),SF2->F2_COND,aTitulo[_VLRIPI_],dDataCnd,aTitulo[_VLRSOL_],,,aTitulo[_VLRACR_])
		ElseIf nMoeda <> 1 .And. cMoedaTit == "S"
			aVencto := Condicao(xMoeda(aTitulo[_VLRTIT_],1,nMoeda,dDataMoe),SF2->F2_COND,aTitulo[_VLRIPI_],dDataCnd,aTitulo[_VLRSOL_],,,aTitulo[_VLRACR_])
		Else
			aVencto := Condicao(aTitulo[_VLRTIT_],SF2->F2_COND,aTitulo[_VLRIPI_],dDataCnd,aTitulo[_VLRSOL_],,,aTitulo[_VLRACR_])
		EndIf
		
		//Se o campo EC_RATEIO tiver mais que 2 casas decimais e a condição for do tipo 'B',
		//arredonda os valores das duplicatas com as mesmas decimais do campo E1_VALOR
		If nDecRateio > 2 .And. SE4->E4_TIPO == "B"
			For nX := 1 To Len(aVencto)
				aVencto[nX][2] := Round(aVencto[nX][2],nDecE1Vlr)
			Next nX
		EndIf
		
		//
		// Template GEM - Gestao de Empreendimentos Imobiliarios
		//
		If ExistBlock("GMMA410Dupl")
			aVencto := ExecBlock("GMMA410Dupl",.F.,.F.,{cPedido ,SF2->F2_COND,dDataCnd,,aTitulo[_VLRTIT_],aVencto}, .F., .F.)
		Else
			If ExistTemplate("GMMA410Dupl")
				aVencto := ExecTemplate("GMMA410Dupl",.F.,.F.,{cPedido ,SF2->F2_COND,dDataCnd,,aTitulo[_VLRTIT_],aVencto})
			EndIf
		Endif

		cImposto := SuperGetMV("MV_RTIPESP",,cImposto)

		aTGCalc		:= {}
		aTGRet		:= {}
		aTGCalcRet	:= {}
		aTGCalcRec  := {}
		cNumTitTG   := ""

		//Chamo a função xFisRetTG() para obter os tributos passívels de tributação
		If lTrbGen .And. !Empty(MaFisScan("NF_TRIBGEN",.F.))

			//Obtém todos os tributos genéricos calculados pelo motor Fiscal
			//Obtém todos os tributos genéricos passíveis de retenção
			//Percorre todos tributos genéricos verificando se ele é passível de retenção
			//Populo os arrays aTGCalcRet quando retenção e o aTGCalc para taxas
			FisRetGen(@aTGCalc,@aTGRet,_lFinParcFKK,@aTGCalcRet,@aTGCalcRec,SF2->F2_EMISSAO,SF2->F2_DOC,SF2->F2_SERIE)

			// Se houver tributos genéricos altera as variáveis de geração de titulo para retenções.
			// A geração de titulos para tributos genéricos será tratada em outro momento.
			A460IdGen(aTGCalc, @lPccMR, @lIrfMR, @lInsMR, @lIssMR, @lCidMR, @lSestMR, @lFunMR, @lFamadMR, @lFethabMR, @lFacsMR, @lImaMR, @lFabovMR)
		EndIf

		If SuperGetMV("MV_RTIPFIN",,.F.)
			Vld1Parc(aVencto,aTitulo,cImposto,.T.,@nImpISS,@nImpIRRF,@nImpINSS,@nImpCSLL,@nImpCOF,@nImpPIS,@nImpFet,@nImpFab,@nImpFac,cRecISS == "1",@nImpIma, @aTGCalcRet, @nImpFam,aTGCalc)
		Else
			Vld1Parc(aVencto,aTitulo,cImposto,.F.,@nImpISS,@nImpIRRF,@nImpINSS,@nImpCSLL,@nImpCOF,@nImpPIS,@nImpFet,@nImpFab,@nImpFac,cRecISS == "1",@nImpIma, @aTGCalcRet, @nImpFam,aTGCalc)
		EndIf

		If nImpISS == 1 .And. !(SF2->F2_TIPO$"DB") .And. cRecISS =="1" .And. SuperGetMV("MV_DESCISS") .And. Len(aVencto) > 1 .And. !lGerAbtISS
			nAbtISS := aTitulo[_VLRISS_]
		EndIf
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Aplica a condicao de pagamento                                         ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If nAbtISS != 0
			aVencto := Condicao(aTitulo[_VLRTIT_]+nAbtISS,SF2->F2_COND,aTitulo[_VLRIPI_],dDataCnd,aTitulo[_VLRSOL_],,,aTitulo[_VLRACR_])
			//
			// Template GEM - Gestao de Empreendimentos Imobiliarios
			//
			If ExistBlock("GMMA410Dupl")
				aVencto := ExecBlock("GMMA410Dupl",.F.,.F.,{cPedido ,SF2->F2_COND,dDataCnd,,aTitulo[_VLRTIT_]+nAbtISS,aVencto}, .F., .F.)
			Else
				If ExistTemplate("GMMA410Dupl")
					aVencto := ExecTemplate("GMMA410Dupl",.F.,.F.,{cPedido ,SF2->F2_COND,dDataCnd,,aTitulo[_VLRTIT_]+nAbtISS,aVencto})
				EndIf
			Endif
		EndIf
		nTotMoed1  := aTitulo[_VLRTIT_]
      //-- CRT - Conhecimento Transporte Internacional - Valor está em dolar.
		If nModulo == 43 .And. nMoeda <> 1
			nTotMoed1:= Round(NoRound(xMoeda(aTitulo[_VLRTIT_],nMoeda,1,dDataMoe,3),3),2)
		EndIf

		aSC5Area := SC5->( GetArea() )
		If nMoeda <> 1
			If nModulo == 43
				nTotMoeda  := aTitulo[_VLRTIT_]
			Else
				Do Case	
				Case ( Len( aSavRat ) == 0 ) .Or. ( Len( aSavRat ) == 1 )
					nScan := Len( aSavRat )
				Case Len( aSavRat ) > 1
					For nInd := 1 To Len( aSavRat )
						If ( aSavRat[ nInd ][ SV_FRETE ] + aSavRat[ nInd ][ SV_SEGURO ] + aSavRat[ nInd ][ SV_DESPESA ] + aSavRat[ nInd ][ SV_DESCONT ]) > 0
							nScan := nInd
							Exit
						EndIf
					Next nInd
				EndCase
				
				nScan := IIf( nScan == 0, Ascan( aSavRat,{| x | x[SV_PEDIDO] == cPedido } ), nScan )
				If nScan > 0
					//Só ajusta a diferença do rateio se o pedido possuir despesas acessórias.
					If  ( aSavRat[ nScan ][ SV_FRETE ] + aSavRat[ nScan ][ SV_SEGURO ] + aSavRat[ nScan ][ SV_DESPESA ] + aSavRat[ nScan ][ SV_DESCONT ] ) > 0
						lExec := .F.
						SC5->( dbSetOrder( 1 ) )
						SC5->( dbSeek( FWxFilial( 'SC5' ) + aSavRat[ nScan ][ SV_PEDIDO ] ) )
						If (SC5->C5_FRETE<>0 .And. xMoeda(SC5->C5_FRETE,If(lMoedaFre,SC5->C5_MOEDA,1),1,dDataMoe) == aSavRat[nScan, SV_FRETE]) .Or.;
							(SC5->C5_SEGURO<>0 .And. xMoeda(SC5->C5_SEGURO,If(lMoedaFre,SC5->C5_MOEDA,1),1,dDataMoe) == aSavRat[nScan, SV_SEGURO]) .Or.;
							(SC5->C5_DESPESA<>0 .And. xMoeda(SC5->C5_DESPESA,If(lMoedaFre,SC5->C5_MOEDA,1),1,dDataMoe) == aSavRat[nScan, SV_DESPESA]) .Or.;
							(SC5->C5_DESCONT<>0 .And. xMoeda(SC5->C5_DESCONT,If(lMoedaFre,SC5->C5_MOEDA,1),1,dDataMoe) == aSavRat[nScan, SV_DESCONT])
							
							nDifDsp := aSavRat[nScan,SV_DESPAC2]

							If lMoedaFre
								nTotMoeda := Round(xMoeda(aTitulo[_VLRTIT_],1,nMoeda,dDataMoe,3)+nDifDsp,2)
							Else
								nTotMoeda := xMoeda(aTitulo[_VLRTIT_],1,nMoeda,dDataMoe)+nDifDsp
							EndIf
						Else
							nTotMoeda := xMoeda(aTitulo[_VLRTIT_],1,nMoeda,dDataMoe)
						EndIf
					Else
						// Obter a diferença entre 
						//        Somatório Item a Item dos Valores com as Despesas Acessórias da NF na Moeda do PV
						//            Menos
						//        Valor Total da NF com Valor Total das Despesas Acessorias na Moeda do PV
						nDifDsp   := aTitulo[_VLRMOE_]+aTitulo[_VLRDSPMOE_] - xMoeda(aTitulo[_VLRREA_]+aTitulo[_VLRDSPREA_],1,nMoeda,dDataMoe,8)
						// Converter a diferença para o valor do Titulo da moeda do PV para a moeda da NF
						nDifDsp   := xMoeda(nDifDsp,nMoeda,1,dDataMoe,8)
						nTotMoeda := a410Arred(xMoeda(aTitulo[_VLRTIT_]+nDifDsp,1,nMoeda,dDataMoe,8), "D2_TOTAL")

					EndIf
				Else
					// Obter a diferença entre 
					//        Somatório dos Itens da NF na Moeda do PV
					//            Menos
					//        Valor Total dos Itens da NF convertido para a Moeda do PV
					nDifMoePV := aTitulo[_VLRMOE_] - a410Arred(xMoeda(aTitulo[_VLRREA_],1,nMoeda,dDataMoe,8), "D2_TOTAL")
					// Converter a diferença para o valor do Titulo da moeda do PV para a moeda da NF
					nDifMoePV := xMoeda(nDifMoePV,nMoeda,1,dDataMoe,8)
					nTotMoeda := a410Arred(xMoeda(aTitulo[_VLRTIT_]+nDifMoePV,1,nMoeda,dDataMoe,8), "D2_TOTAL")
				EndIf
			EndIf
		Else
			nTotMoeda := xMoeda(aTitulo[_VLRTIT_],1,nMoeda,dDataMoe)
		EndIf
		RestArea( aSC5Area )

		If ExistBlock("ME4_COND")
			aVencto := Condicao(aTitulo[_VLRTIT_]+nAbtISS,SF2->F2_COND,SF2->F2_VALIPI,dDataCnd,SF2->F2_ICMSRET,,ExecBlock("ME4_COND",.F.,.F.),aTitulo[_VLRACR_])
			//
			// Template GEM - Gestao de Empreendimentos Imobiliarios
			//
			If ExistBlock("GMMA410Dupl")
				aVencto := ExecBlock("GMMA410Dupl",.F.,.F.,{cPedido ,SF2->F2_COND,dDataCnd,,aTitulo[_VLRTIT_]+nAbtISS,aVencto}, .F., .F.)
			Else
				If ExistTemplate("GMMA410Dupl")
					aVencto := ExecTemplate("GMMA410Dupl",.F.,.F.,{cPedido ,SF2->F2_COND,dDataCnd,,aTitulo[_VLRTIT_]+nAbtISS,aVencto})
				EndIf
			Endif
		EndIf
		If ExistBlock("MT461VCT")
			aVencto := ExecBlock("MT461VCT",.F.,.F.,{aVencto,aTitulo})
		EndIf
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Verifica a primeira parcela                                            ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If ( Len(aVencto) > 1 )
			cParcela := SuperGetMv("MV_1DUP")
		EndIf
		If ExistBlock("M4601DUP")
			cParcela := ExecBlock("M4601DUP",.F.,.F.,{cParcela})
		EndIf
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Verifica os impostos a serem gravados                                  ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		aImposto := {{0,0},;
		             {aTitulo[_VLRIRRF_],0},;
		             {aTitulo[_VLRINSS_],0},;
		             {aTitulo[_VLRISS_],0},;
		             {aTitulo[_VLRPIS_],0},;
		             {aTitulo[_VLRCSLL_],0},;
		             {aTitulo[_VLRCOFI_],0},;
		             {aTitulo[_VLRFET_],0},;
		             {aTitulo[_VLRFAB_],0},;
		             {aTitulo[_VLRFAC_],0},;
		             {0,0},{0,0},{0,0},{0,0},;
		             {0,0},{0,0},{0,0},{0,0},;
		             {0,0},{0,0},{0,0},;
		             {aTitulo[_VLRTPDP_],0},;
		             {aTitulo[_VLRFMP_],0},;
		             {aTitulo[_VLRIMA_],0},;
					 {aTitulo[_VLBTISS_],0},;
					 {aTitulo[_VLRFMD_],0}}
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Atualizacao das parcelas do contas a receber                           ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		dbSelectArea("SE1")
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Devido a nova lei PCC, as notas emitidas apartir do dia 22/06/2015 terá o processo       ³
		//³de não cumulativo, deixando de validar o parâmetro MV_AB10925 a partis desta data pois o ³
		//³PCC será gerado por documento fiscal ,que agora considera se o valor dos impostos PCC é 	³
		//³maior que R$10, o E1 terá os valores dos impostos gravados e	sera validado pela função 	³
		//³a040DUPREC se atinge os R$ 10 para calculo												³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		//nValMinRet é zerada para seja alimentado os campos do SE1(PCC), que será validado pela A040DupRec

		If lNewPCC
			If cModRet == "2"
				nValMinRet	:= 0
			ElseIf cModRet == "1"
				nValMinRet	:= nVlrMin
			EndIf
		EndIf

		If cModRet == "1" .And. lContrAbt

			nAbtISSAnt := nAbtISS

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//|FOR SOMENTE PARA DETERMINAR O VALOR A SER COMPARADO COM O MV_VL10925	   |
			//|                                                                        |
			//³ Obtem os totais por mes antes de processar                             ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			For nCntFor := 1 To Len(aVencto)
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Calculo valor acumulado do MES de acordo com a definicao do parametro ³
				//³  MV_RTIPFIN que determina em qual parcela deverah haver a retencao.  ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If !(nImpCSLL==nCntFor .And. nImpCOF==nCntFor .And. nImpPIS==nCntFor)
					Loop
				EndIf

				If lBaseImp .And. nBasePCC>0
					nVlrParc  := nVlrMoed1 := NoRound( xMoeda((nBasePCC/Len(aVencto)),1,nMoeda,dDataMoe), nDecE1Vlr )
				Else
					nVlrParc  := NoRound( xMoeda(aVencto[nCntFor][2]-nAbtISSAnt,1,nMoeda,dDataMoe), nDecE1Vlr )
					nVlrMoed1 := NoRound( aVencto[nCntFor][2]-nAbtISSAnt, nDecE1Vlc )
				EndIf

				If nCntFor == 1
					nAbtISSAnt := 0
				EndIf

				nVlrAcum1 += nVlrParc
				nVlrAcum2 += nVlrMoed1
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Na Ultima Parcela acerta as diferenca de centavo                        ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If ( Len(aVencto)==nCntFor ) .AND. ! lCondVenda
					If lBaseImp .And. nBasePCC>0
						nVlrParc += nBasePCC - nVlrAcum1
						nVlrMoed1+= nBasePCC  - nVlrAcum2
					Else
						nVlrParc += nTotMoeda - nVlrAcum1
						nVlrMoed1+= nTotMoed1  - nVlrAcum2
					EndIf
				EndIf

				cAnoMes := Left( DToS( DataValida( aVencto[nCntFor,1],.T.) ), 6 )

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Alimenta os acumulados por Ano / Mes                                                     ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If Empty( nScanMes := AScan( aAcumulMes, { |x| x[1] == cAnoMes } ) )
					AAdd( aAcumulMes, { cAnoMes, 0 } )
					nScanMes := Len( aAcumulMes )
				EndIf

				aAcumulMes[ nScanMes, 2 ] += nVlrParc

			Next nCntFor

		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Calcula a proporcao da parcelaa do PIS,COFINS e CSLL                   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		nValPis := 0
		nValCof := 0
		nValCsl := 0

		For nX := 1 to Len(aVencto)
			nValTot += aVencto[nX][2]
		Next

		aProp := {}

		nSaldoProp := 1

		For nX := 1 to Len(aVencto)
			If nX == Len(aVencto)
				nProp := nSaldoProp
			Else
				nProp := Round(aVencto[nX][2] / nValTot,7)
				nSaldoProp -= nProp
			EndIf
		   AAdd( aProp, nProp )
		Next nX

		//
		// Template GEM - Gestao de Empreendimentos Imobiliarios
		//
		// Verifica se a condicao de pagamento tem vinculacao com uma condicao de venda
		//
		If ExistTemplate("GEMMA461") .And. HasTemplate("LOT")
			aTitCndVnd := ExecTemplate("GEMMA461",.F.,.F.,{cPedido ,SF2->F2_COND ,dDataCnd ,aTitulo[_VLRTIT_]+nAbtISS })
		EndIf

		nVlrAcum1 := 0
		nVlrAcum2 := 0

		nVlrParc  := 0
		nVlrMoed1 := 0

		For nCntFor := 1 To Len(aVencto)

			//
			// Tipo de parcela = E1_TIPO
			//
			cTipoParc := MVNOTAFIS

			//
			// Template GEM - Gestao de empreendimentos imobiliarios
			// Condicao de pagto com condicao de venda
			//
			If lGEMTipTit
				cTipoParc := ExecTemplate("GEMTipTit",.F.,.F.,{cTipoParc,aVencto[nCntFor][1],SF2->F2_COND})
			EndIf

			//-- SIGATMS = Retorna Tipo do Titulo (E1_TIPO) com base no parametro MV_TMSTIPT
			If IntTms() .And. nModulo==43
				TmsTpTit(@cTipoParc)
			EndIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Calcula a proporcao da parcela em relacao ao total de duplicatas       ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			nFatorParc := ( aVencto[nCntFor][2]-nAbtISS ) / ( aTitulo[_VLRTIT_]+nAbtISS )

			// Se Cond.Pagto tipo 9, moeda 2 e MV_MOEDTIT = "S", array a Vencto ja esta em Moeda 2, e nao precisa converter.
			If (SE4->E4_TIPO == "9" .Or. nModulo == 43) .And. nMoeda <> 1 .And. cMoedaTit == "S"
				nVlrParc := NoRound( aVencto[nCntFor][2]-nAbtISS, nDecE1Vlr )
				// Valor em moeda 1 que devera ser gravado no campo E1_VLCRUZ
				nVlrMoed1:= NoRound( xMoeda(aVencto[nCntFor][2]-nAbtISS,nMoeda,1,dDataMoe), nDecE1Vlc )
			Else
				If nMoeda <> 1 .And. cMoedaTit == "S"		
					nVlrParc := NoRound( aVencto[nCntFor][2]-nAbtISS, nDecE1Vlr )
					nVlrMoed1:= NoRound( xMoeda(aVencto[nCntFor][2]-nAbtISS,nMoeda,1,dDataMoe), nDecE1Vlc )		
				Else
					nVlrParc := NoRound( xMoeda(aVencto[nCntFor][2]-nAbtISS,1,nMoeda,dDataMoe), nDecE1Vlr )
					nVlrMoed1:= NoRound( aVencto[nCntFor][2]-nAbtISS, nDecE1Vlc )
				EndIf
			EndIf

			If nCntFor == 1
				nAbtISS := 0
			EndIf

			nVlrAcum1 += nVlrParc
			nVlrAcum2 += nVlrMoed1

			If ! lCondVenda
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Na Ultima Parcela acerta as diferenca de centavo                        ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If ( Len(aVencto)==nCntFor )
					nVlrParc += nTotMoeda - nVlrAcum1
					nVlrMoed1+= nTotMoed1  - nVlrAcum2
				EndIf
			EndIf

			RecLock("SE1",.T.)

			If ("1"$cA1M996) .And. ("1"$cB1M996)
				SE1->E1_SCORGP	:=	"1"
			EndIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Atendimento ao DECRETO 5.052, DE 08/01/2004 para o municipio de ARARAS. ³
			//³Mais especificamente o paragrafo unico do Art 2.                        ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

			If ("2"$cA1FRETISS) .And. ("2"$cB1FRETISS)
				SE1->E1_FRETISS	:=	"2"
			Else
				SE1->E1_FRETISS	:=	"1"
			EndIf

			// Tratamento para a cidade de Cascavel-PR Decreto n.º 8.230
			SE1->E1_VLMINIS	:=	Iif(!lIsRussia,SF4->(FieldGet (FieldPos ("F4_FRETISS"))),"1")

			//
			SE1->E1_FILIAL := xFilial("SE1")

			If lUsaNewKey
				SE1->E1_PREFIXO:= cPrfx
			Else
				SE1->E1_PREFIXO:= &(cMV1DupRef)
			EndIf

			SE1->E1_NUM    := SF2->F2_DOC
			SE1->E1_PARCELA:= cParcela

			SE1->E1_TIPO   := cTipoParc

			SE1->E1_CLIENTE:= SF2->F2_CLIENTE
			SE1->E1_LOJA   := SF2->F2_LOJA

			SerieNfId("SE1",1,"E1_SERIE",,,, SF2->F2_SERIE )

			SE1->E1_PEDIDO 	:= cPedido
			SE1->E1_NOMCLI 	:= If(Empty(SA1->A1_NREDUZ),SA1->A1_NOME,SA1->A1_NREDUZ)
			SE1->E1_EMISSAO	:= SF2->F2_EMISSAO
			SE1->E1_VALOR  	:= nVlrParc
			SE1->E1_SALDO  	:= SE1->E1_VALOR
			SE1->E1_VLCRUZ 	:= nVlrMoed1
			SE1->E1_LA     	:= "S"
			SE1->E1_SITUACA	:= "0"
			SE1->E1_MOEDA  	:= nMoeda
			SE1->E1_EMIS1  	:= dDataBase
			SE1->E1_VENCTO 	:= aVencto[nCntFor][1]
			SE1->E1_VENCORI	:= SE1->E1_VENCTO
			SE1->E1_VENCREA	:= DataValida(SE1->E1_VENCTO,.T.)
			SE1->E1_STATUS 	:= "A"
			SE1->E1_PORCJUR	:= nPerJur
			SE1->E1_VALJUR 	:= Round(SE1->E1_VALOR * (SE1->E1_PORCJUR / 100),2)
			SE1->E1_OCORREN	:= CriaVar("E1_OCORREN")
			SE1->E1_DESCFIN	:= IIf(SC5->C5_DESCFI>0,SC5->C5_DESCFI,SE4->E4_DESCFIN)	//Assume o desconto financeiro preenchido no pedido, pois o cliente pode digitar um valor diferente do informado na condição de pagamento.
			SE1->E1_DIADESC	:= SE4->E4_DIADESC										
			If !lIsRussia
				SE1->E1_FORNISS	:= cFornISS
				SE1->E1_FLUXO := "S"
			EndIf
			If lRotTMS .And. ValType(DC5->DC5_NATURE) == "C" .And. !Empty(DC5->DC5_NATURE)
				SE1->E1_NATUREZ	:= DC5->DC5_NATURE
			Else
				SE1->E1_NATUREZ	:= &(cMV1DupNat)
			EndIf

			/* Integração RISK - TOTVS Mais Negócios
			Grava as informações do boleto retornado pela plataforma RISK*/
			If lUseRISK
				SE1->E1_BOLETO := RskBankSlip()
			EndIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Recalcula os impostos com base na natureza do parametro                 ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If SE1->E1_NATUREZ <> MaFisRet(,"NF_NATUREZA")
				MaFisAlt("NF_NATUREZA",SE1->E1_NATUREZ)
				aTitulo[_VLRIRRF_] := MaFisRet(,"NF_VALIRR")
				aTitulo[_VLRINSS_] := MaFisRet(,"NF_VALINS")
				aTitulo[_VLRINSS_] += MaFisRet(,"NF_VALINA")
				aTitulo[_VLRISS_]  := MaFisRet(,"NF_VALISS")
				aTitulo[_VLRPIS_]  := MaFisRet(,"NF_VALPIS")
				aTitulo[_VLRCSLL_] := MaFisRet(,"NF_VALCSL")
				aTitulo[_VLRCOFI_] := MaFisRet(,"NF_VALCOF")
				aTitulo[_VLRFET_]  := MaFisRet(,"NF_VALFET")
				aTitulo[_VLRFAB_]  := MaFisRet(,"NF_VALFAB")
				aTitulo[_VLRFAC_]  := MaFisRet(,"NF_VALFAC")
				//aTitulo[_VLRTPDP_] := MaFisRet(,"NF_VALTPDP")
				If lFmpeq
					aTitulo[_VLRFMP_]  := MaFisRet(,"NF_VALFMP")
				EndIf
				If lFamad
					aTitulo[_VLRFMD_]  := MaFisRet(,"NF_VALFMD")
				EndIf
				If lIma
					aTitulo[_VLRIMA_]  := MaFisRet(,"NF_VALIMA")
				EndIf
				aImposto := {{0,0},;
				             {aTitulo[_VLRIRRF_],0},;
				             {aTitulo[_VLRINSS_],0},;
				             {aTitulo[_VLRISS_],0},;
				             {aTitulo[_VLRPIS_],0},;
				             {aTitulo[_VLRCSLL_],0},;
				             {aTitulo[_VLRCOFI_],0},;
				             {aTitulo[_VLRFET_],0},;
				             {aTitulo[_VLRFAB_],0},;
				             {aTitulo[_VLRFAC_],0},;
				             {0,0},{0,0},{0,0},{0,0},;
				             {0,0},{0,0},{0,0},{0,0},;
				             {0,0},{0,0},{0,0},;
				             {aTitulo[_VLRTPDP_],0},;
				             {aTitulo[_VLRFMP_],0},;
		             		 {aTitulo[_VLRIMA_],0},;
							 {aTitulo[_VLBTISS_],0},;
							 {aTitulo[_VLRFMD_],0}}
			EndIf
			dbSelectArea("SED")
			dbSetOrder(1)
			MsSeek(xFilial("SED")+SE1->E1_NATUREZ)
			If lTrbGen .And. _lFINGRVFK7 .And. _lFINCalImp

				//--------------------------------------------------------------
				//Efetua o rateio das parcelas no array dos tributos genéricos
				//--------------------------------------------------------------

				//Array para integração do motor de retenção do financeiro.
				aImpCalc	:= {}
				aImpos		:= {}
				lUltParc	:= nCntFor == Len(aVencto)
				cChaveFK7	:= ""
				For nContTg	:= 1 to Len(aTGCalcRet)

					lProcFin	:= .F.
					nValorTG	:= 0
					nBaseTG		:= 0
					IF nCntFor == 1 .AND. aTGCalcRet[nContTg][5]
						//Se for primeira parcela e estiver configurado para reter integralmente, utilizará o valor integral do tributo para reter somente na primeira parcela
						lProcFin	:= .T.
						nBaseTG		:= aTGCalcRet[nContTg][2]
						nValorTG	:= aTGCalcRet[nContTg][3]
						//Zera o valor do saldo
						aTGCalcRet[nContTg][6]	:= 0
						aTGCalcRet[nContTg][7]	:= 0
					ElseIF lUltParc .AND. (aTGCalcRet[nContTg][6] > 0 .OR. aTGCalcRet[nContTg][7] > 0)
						//Se for última parcela, então as eventuais sobras serão consideradas na última parcela, por este motivo utilizares os saldos das posições 6 e 7.
						lProcFin	:= .T.
						nValorTG	:= aTGCalcRet[nContTg][6]
						nBaseTG		:= aTGCalcRet[nContTg][7]
						//Zera o valor do saldo
						aTGCalcRet[nContTg][6]	:= 0
						aTGCalcRet[nContTg][7]	:= 0
					ElseIf (aTGCalcRet[nContTg][6] > 0 .OR. aTGCalcRet[nContTg][7] > 0)
						//Aqui se houver saldo gera retenção, aplicará o rateio das parcelas para gerar título.
						lProcFin	:= .T.
						nBaseTG		:= NoRound(aTGCalcRet[nContTg][2] * nFatorParc, 2)
						nValorTG	:= NoRound(aTGCalcRet[nContTg][3] * nFatorParc, 2)
						//Atualiza o valor de saldo
						aTGCalcRet[nContTg][6]	-= nValorTG
						aTGCalcRet[nContTg][7]	-= nBaseTG
					EndIf

					If lProcFin
						//Busca o valor da chave FK7, para processar a FINCalImp().
						IF Empty(cChaveFK7)
							SE1->E1_FILORIG  := If(Empty(SE1->E1_FILORIG),cFilAnt,SE1->E1_FILORIG)
							cChaveFK7 := FINGRVFK7("SE1", xFilial("SE1")+"|"+SE1->E1_PREFIXO+"|"+SE1->E1_NUM+"|"+SE1->E1_PARCELA+"|"+SE1->E1_TIPO+"|"+SE1->E1_CLIENTE+"|"+SE1->E1_LOJA) 
						EndIF
						//Adiciona array com informações básicas, que será complementado posteriormente através da FINCalImp()
						aAdd(aImpCalc,{aTGCalcRet[nContTg][4],; //Cod. Regra Financeira FKK
									nBaseTG,;//base de cálculo
									nValorTG,;//valor calculado
									aTGCalcRet[nContTg][8],;//ID da regra fiscal F2B
									cChaveFK7,;//Chave da FK7
									,;
									,;
									,;
									,;
									aTGCalcRet[nContTg][9],;//Código da URF caso exista
									aTGCalcRet[nContTg][10]})//Percentual apliucável ao valor da URF
					EndIF
				Next nContTg

				//Chama a função FINCalImp() abaixo para que o array aImpCalc seja complementado, com informações do motor. A partir deste momento está apto ao enviar para A040DUPREC
				If Len(aImpCalc) > 0
					aImpos	:= FINCalImp("2" , SE1->E1_NATUREZ,  SE1->E1_CLIENTE, SE1->E1_LOJA , cFilAnt, Nil, Nil , Nil, Nil, SE1->E1_TIPO, Nil, Nil, aImpCalc)
				EndIF

			EndIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Os Impostos sao calculados apena na primeira parcela                    ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If SED->ED_CALCISS=="S"

				If nImpISS == 1
					SE1->E1_ISS := NoRound(aImposto[_VLRISS_][1],2)
				Else
					SE1->E1_ISS := NoRound(aImposto[_VLRISS_][1]*nFatorParc,2)
				EndIf

				aImposto[_VLRISS_][2] += SE1->E1_ISS
				If nCntFor == nImpISS
					SE1->E1_ISS += aImposto[_VLRISS_][1]-aImposto[_VLRISS_][2]
					//Tratamento para alíquotas parciais de retenção ISS -> Campo da tabela SB1 no parâmetro MV_ALISSB1
					If SB1->(FieldPos(cAlIssB1)) > 0
						If SB1->&(cAlIssB1) > 0
							nRetParISS  := SFT->FT_VALCONT * SB1->&(cAlIssB1) / 100
							SE1->E1_ISS := SE1->E1_ISS - nRetParISS
						Endif
					Endif
					//
					aImposto[_VLRISS_][1] := 0
					aImposto[_VLRISS_][2] := 0
				EndIf
			EndIf

			//ISS Bi Tributado pelo CEPOM
			If lPosBTISS

				// aqui estamos gravando o código do ISS pois o Financeiro necessita dele para buscar o fornecedor do ISS.
				// No Futuro devemos ter outra forma de configurar essa informação, por isso hoje só estamos preenchendo na sistuação da Bi Tributação
				// nas demais situações ele continua buscando do MV_MUNIC
				If aImposto[_VLBTISS_][1] > 0
					SE1->E1_CODSERV := cCodISS
				EndIf

				//Hoje atualizamos ambos os campos do financeiro pois não existe controle para calcular na Baixa
				//Quando o time do financeiro criar o controle teremos que atualizar este ponto e só gravar o campo E1_VRETBIS no calculo pela emissão.
				If nImpISS == 1
					SE1->E1_BTRISS :=  NoRound(aImposto[_VLBTISS_][1],2)
					SE1->E1_VRETBIS := NoRound(aImposto[_VLBTISS_][1],2)
				Else
					SE1->E1_BTRISS :=  NoRound(aImposto[_VLBTISS_][1]*nFatorParc,2)
					SE1->E1_VRETBIS := NoRound(aImposto[_VLBTISS_][1]*nFatorParc,2)
				EndIf
				aImposto[_VLBTISS_][2] += SE1->E1_BTRISS

				If nCntFor == nImpISS
					SE1->E1_BTRISS += aImposto[_VLBTISS_][1]-aImposto[_VLBTISS_][2]
					SE1->E1_VRETBIS += aImposto[_VLBTISS_][1]-aImposto[_VLBTISS_][2]
					aImposto[_VLBTISS_][1] := 0
					aImposto[_VLBTISS_][2] := 0
				EndIf

			EndIf

			cCodIRRF	:= ""
			If lPsCodPerd .And. !Empty(SED->ED_CODPERD)
				cCodIRRF		:= SED->ED_CODPERD
				SE1->E1_CODIRRF	:= cCodIRRF
			EndIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Efetua o calculo do IRRF                                                ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If nImpIRRF == 1
				SE1->E1_IRRF := NoRound(aImposto[_VLRIRRF_][1],2)
			Else
				SE1->E1_IRRF := NoRound(aImposto[_VLRIRRF_][1]*nFatorParc,2)
			EndIf

			If !lIsRussia .And. nCntFor == Len(aVencto) .Or. nImpIRRF == 1
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				//Se o IR for na primeira parcela(nImpIRRF == 1), a Base do mesmo deve ser  ³
				//o valor Total, senão o valor da base será rateado entre as parcelas		   ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If !lBaseIRTot
					SE1->E1_BASEIRF := nSaldoIrf
					If nImpIRRF == 1
						lBaseIRTot 	  := .T.
					EndIf
				EndIf
			ElseIf !lIsRussia .And. !lBaseIRTot
				SE1->E1_BASEIRF := nBaseIrf * aProp[nCntFor]
				nSaldoIrf -= SE1->E1_BASEIRF
			Endif

			aImposto[_VLRIRRF_][2] += SE1->E1_IRRF
			If nCntFor == nImpIRRF
				SE1->E1_IRRF += aImposto[_VLRIRRF_][1]-aImposto[_VLRIRRF_][2]
				aImposto[_VLRIRRF_][1] := 0
				aImposto[_VLRIRRF_][2] := 0
			EndIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Efetua o calculo do INSS                                                ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If nImpINSS == 1
				SE1->E1_INSS := NoRound(aImposto[_VLRINSS_][1],2)
			Else
				SE1->E1_INSS := NoRound(aImposto[_VLRINSS_][1]*nFatorParc,2)
			EndIf

			If !lIsRussia .And. nCntFor == Len(aVencto)
				SE1->E1_BASEINS := nSaldoIns
			ElseIf !lIsRussia
				SE1->E1_BASEINS := nBaseIns * aProp[nCntFor]
				nSaldoIns -= SE1->E1_BASEINS
			Endif

			aImposto[_VLRINSS_][2] += SE1->E1_INSS
			If nCntFor == nImpINSS
				SE1->E1_INSS += aImposto[_VLRINSS_][1]-aImposto[_VLRINSS_][2]
				aImposto[_VLRINSS_][1] := 0
				aImposto[_VLRINSS_][2] := 0
			EndIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Efetua o calculo do CSLL                                                ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If nImpCSLL == 1
				SE1->E1_CSLL	:= NoRound(aImposto[_VLRCSLL_][1],2)
				SE1->E1_BASECSL	:= nSaldoCsl
				nBaseCsl		:= 0
				nSaldoCsl		:= 0
			Else
				SE1->E1_CSLL	:= NoRound(aImposto[_VLRCSLL_][1]*nFatorParc,2)
				If nCntFor == Len(aVencto)
					SE1->E1_BASECSL	:= nSaldoCsl
				Else
					SE1->E1_BASECSL	:= nBaseCsl * aProp[nCntFor]
					nSaldoCsl		-= SE1->E1_BASECSL
				Endif
			EndIf

			aImposto[_VLRCSLL_][2] += SE1->E1_CSLL

			aFinPCC[5] := aImposto[_VLRCSLL_][1] // Valor total CSLL para o financeiro

			If nCntFor == nImpCSLL
				SE1->E1_CSLL += aImposto[_VLRCSLL_][1] - aImposto[_VLRCSLL_][2]
				aImposto[_VLRCSLL_][1] := 0
				aImposto[_VLRCSLL_][2] := 0
			EndIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Efetua o calculo do CoFins                                              ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If nImpCof == 1
				SE1->E1_COFINS	:= NoRound(aImposto[_VLRCOFI_][1],2)
				SE1->E1_BASECOF	:= nSaldoCof
				nBaseCof		:= 0
				nSaldoCof		:= 0
			Else
				SE1->E1_COFINS	:= NoRound(aImposto[_VLRCOFI_][1]*nFatorParc,2)
				If nCntFor == Len(aVencto)
					SE1->E1_BASECOF	:= nSaldoCof
				Else
					SE1->E1_BASECOF	:= nBaseCof * aProp[nCntFor]
					nSaldoCof		-= SE1->E1_BASECOF
				Endif
			EndIf

			aImposto[_VLRCOFI_][2] += SE1->E1_COFINS

			aFinPCC[3] := aImposto[_VLRCOFI_][1] // Valor total COFINS para o financeiro

			If nCntFor == nImpCOF
				SE1->E1_COFINS += aImposto[_VLRCOFI_][1] - aImposto[_VLRCOFI_][2]
				aImposto[_VLRCOFI_][1] := 0
				aImposto[_VLRCOFI_][2] := 0
			EndIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Efetua o calculo do PIS                                                 ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If nImpPIS == 1
				SE1->E1_PIS		:= NoRound(aImposto[_VLRPIS_][1]/nImpPIS,2)
				SE1->E1_BASEPIS	:= nSaldoPis
				nBasePis		:= 0
				nSaldoPis		:= 0
			Else
				SE1->E1_PIS		:= NoRound(aImposto[_VLRPIS_][1]*nFatorParc,2)
				If nCntFor == Len(aVencto)
					SE1->E1_BASEPIS	:= nSaldoPis
				Else
					SE1->E1_BASEPIS	:= nBasePis * aProp[nCntFor]
					nSaldoPis		-= SE1->E1_BASEPIS
				Endif
			EndIf

			aImposto[_VLRPIS_][2] += SE1->E1_PIS

			aFinPCC[1] := aImposto[_VLRPIS_][1] // Valor total PIS para o financeiro

			If nCntFor == nImpPIS
				SE1->E1_PIS += aImposto[_VLRPIS_][1] - aImposto[_VLRPIS_][2]
				aImposto[_VLRPIS_][1] := 0
				aImposto[_VLRPIS_][2] := 0
			EndIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Efetua o calculo do imposto Fethab                                      ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

			If nImpFet == 1
				SE1->E1_FETHAB := NoRound(aImposto[_IMPFET_][1],2)
			Else
				SE1->E1_FETHAB := NoRound(aImposto[_IMPFET_][1]*nFatorParc,2)
			EndIf

			aImposto[_IMPFET_][2] += SE1->E1_FETHAB
			If nCntFor == nImpFet
				SE1->E1_FETHAB += aImposto[_IMPFET_][1]-aImposto[_IMPFET_][2]
				aImposto[_IMPFET_][1] := 0
				aImposto[_IMPFET_][2] := 0
			EndIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Efetua o calculo do imposto Fabov                                       ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

			If nImpFab == 1
				SE1->E1_FABOV := NoRound(aImposto[_IMPFAB_][1],2)
			Else
				SE1->E1_FABOV := NoRound(aImposto[_IMPFAB_][1]*nFatorParc,2)
			EndIf

			aImposto[_IMPFAB_][2] += SE1->E1_FABOV
			If nCntFor == nImpFab
				SE1->E1_FABOV += aImposto[_IMPFAB_][1]-aImposto[_IMPFAB_][2]
				aImposto[_IMPFAB_][1] := 0
				aImposto[_IMPFAB_][2] := 0
			EndIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Efetua o calculo do imposto Facs                                        ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

			If nImpFac == 1
				SE1->E1_FACS := NoRound(aImposto[_IMPFAC_][1],2)
			Else
				SE1->E1_FACS := NoRound(aImposto[_IMPFAC_][1]*nFatorParc,2)
			EndIf

			aImposto[_IMPFAC_][2] += SE1->E1_FACS
			If nCntFor == nImpFac
				SE1->E1_FACS += aImposto[_IMPFAC_][1]-aImposto[_IMPFAC_][2]
				aImposto[_IMPFAC_][1] := 0
				aImposto[_IMPFAC_][2] := 0
			EndIf

			If lM460IREN
				SE1->E1_IRRF := ExecBlock("M460IREN",.F.,.F.,SE1->E1_IRRF)
			EndIf
			If ( aEntry[EP_M460INSS] )
				SE1->E1_INSS := ExecBlock("M460INSS", .F., .F.,SE1->E1_INSS)
			EndIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Efetua o calculo do imposto Fumipeq                                     ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If lFmpeq
				If nImpFmp == 1
					SE1->E1_FMPEQ := NoRound(aImposto[_VLRFMP_][1],2)
				Else
					SE1->E1_FMPEQ := NoRound(aImposto[_VLRFMP_][1]*nFatorParc,2)
				EndIf
				aImposto[_VLRFMP_][2] += SE1->E1_FMPEQ
				If nCntFor == nImpFmp
					SE1->E1_FMPEQ += aImposto[_VLRFMP_][1] - aImposto[_VLRFMP_][2]
					aImposto[_VLRFMP_][1] := 0
					aImposto[_VLRFMP_][2] := 0
				EndIf
			EndIf
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Efetua o calculo do imposto Famad                                       ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ  
			If lFamad
				If nImpFam == 1
					SE1->E1_FAMAD := NoRound(aImposto[_VLRFMD_][1],2)
				Else
					SE1->E1_FAMAD := NoRound(aImposto[_VLRFMD_][1]*nFatorParc,2)
				EndIf
				
				aImposto[_VLRFMD_][2] += SE1->E1_FAMAD
				If nCntFor == nImpFam
					SE1->E1_FAMAD += aImposto[_VLRFMD_][1]-aImposto[_VLRFMD_][2]
					aImposto[_VLRFMD_][1] := 0
					aImposto[_VLRFMD_][2] := 0
				EndIf
			Endif   

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Efetua o calculo do imposto IMA	                                       ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If lIma
				If nImpIma == 1
					SE1->E1_IMA := NoRound(aImposto[_VLRIMA_][1],2)
				Else
					SE1->E1_IMA := NoRound(aImposto[_VLRIMA_][1]*nFatorParc,2)
				EndIf
				aImposto[_VLRIMA_][2] += SE1->E1_IMA
				If nCntFor == nImpIma
					SE1->E1_IMA += aImposto[_VLRIMA_][1] - aImposto[_VLRIMA_][2]
					aImposto[_VLRIMA_][1] := 0
					aImposto[_VLRIMA_][2] := 0
				EndIf
			EndIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Efetua a Gravacao dos Vendedores                                        ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			dbSelectArea("SE1")
			cVendedor := "1"
			lTemVend := .F.
			For nVendedor := 1 To nMaxVend
				cConteudo := SF2->(FieldGet(FieldPos("F2_VEND"+cVendedor)))
				If (!Empty(cConteudo))
					lTemVend := .T.
				EndIf
				FieldPut(FieldPos("E1_VEND"+cVendedor),cConteudo)
				If SE1->(FieldPos("E1_ALEMIS"+cVendedor))<>0
					SA3->(dbSetOrder(1))
					SA3->(MsSeek(xFilial("SA3")+cConteudo))
					FieldPut(FieldPos("E1_ALEMIS"+cVendedor),SA3->A3_ALEMISS)
				EndIf
				If SE1->(FieldPos("E1_ALBAIX"+cVendedor))<>0
					SA3->(dbSetOrder(1))
					SA3->(MsSeek(xFilial("SA3")+cConteudo))
					FieldPut(FieldPos("E1_ALBAIX"+cVendedor),SA3->A3_ALBAIXA)
				EndIf

				If SF2->(FieldPos("F2_CODRL"+cVendedor))>0 .And. SE1->(FieldPos("E1_CODRL"+cVendedor))>0
					cConteudo := SF2->(FieldGet(FieldPos("F2_CODRL"+cVendedor)))
					FieldPut(FieldPos("E1_CODRL"+cVendedor),cConteudo)
				EndIf
				cVendedor := Soma1(cVendedor,1)
			Next nVendedor
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Integracao como Financeiro                         ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			aImpOut := {SE1->E1_INSS,SE1->E1_ISS,SE1->E1_PIS,SE1->E1_CSLL,SE1->E1_COFINS}

			cAnoMes := Left( DToS( SE1->E1_VENCREA ), 6 )

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Indica se o tratamento de valor minimo para retencao (R$ 5.000,00) deve ser aplicado:³
			//³ou apartir de 22/06/15 gravar o campo E1_APLVLMN como 1 cumulatividade que Aplica o  ³
			//³valor minimo, ou 2 nao cumulatividade Nao aplica o valor minimo, determinado pelo 	³
			//³parâmetro MV_AB10925			³
			//³1 = Aplica o valor minimo                                                            ³
			//³2 = Nao aplica o valor minimo                                                        ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If lNewPCC
				SE1->E1_APLVLMN := Iif (AllTrim(cModRet) == "2","1","2")
			Else
				SE1->E1_APLVLMN := cAplVlMn
			EndIf

			If lContrAbt

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Grava o saldo para abatimento                     ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				SE1->E1_SABTPIS := SE1->E1_PIS
				SE1->E1_SABTCOF := SE1->E1_COFINS
				SE1->E1_SABTCSL := SE1->E1_CSLL

				If cRetCli == "1"

					If cModRet == "1"
						If lNewPCC
							If SE1->E1_PIS + SE1->E1_COFINS + SE1->E1_CSLL >= nVlrMin
								lAbate := .T.
							EndIf
						Else
							//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
							//³ Pesquisa nos valores pagos para verificar se deve reter a parcela                        ³
							//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
							If !Empty( nScanMes := AScan( aAcumulMes, { |x| x[1] == cAnoMes } ) )
								lAbate := ( aAcumulMes[ nScanMes, 2 ] > nValMinRet )
							Else
							   lAbate := .T.
							EndIf
						EndIf

					ElseIf cModRet == "2"

						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄv¿
						//³A regra de cumulatividade do novo PCC é tratada pela função NewMinPCC        ³
						//³do financeiro, onde a cumulatividade é diaria, ou seja, serão verificados    ³
						//³os titulos do CLIENTE ref aquele DIA, somando os impostos PCC, e será gerado,³
						//³os título de retensão, caso o valor da soma do(s) mesmo(s) ultrapasse R$10.  ³
						//³Caso não atingir o valor, E1_(PIS/COF/CSLL) serão gravados zerados.			³
						//³Esses títulos de retensão, são gerados uma única vez ao dia.(por cliente)    ³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¼+Ù
						If lNewPCC
							// Estrutura de aDadosRet novo PCC
							// 1-Indica se foi recalculado.
							// 2-Valor do PIS
							// 3-Valor do COFINS
							// 4-Valor da CSLL
							//Se tiver uma User Function no MV_1DUPNAT, macro executa a função.
							//Se vier da função MaNfs2Nfs() que gera NF a partir de outro documento fiscal,
							//pega a natureza do cliente, pois não existe pedido neste tipo de operação.					
							If "U_" $ cMV1DupNat 
								cNatCli := &(cMV1DupNat)
							Else
								If lRotTMS .And. ValType(DC5->DC5_NATURE) == "C" .And. !Empty(DC5->DC5_NATURE)
									cNatCli := DC5->DC5_NATURE
								Else
									cNatCli := If (!Empty(SC5->C5_NATUREZ) .And. !IsInCallStack("MaNfs2Nfs"),SC5->C5_NATUREZ,SA1->A1_NATUREZ)
								EndIf
							EndIf

							cChave := SA1->A1_COD+SA1->A1_LOJA

							If nVencto == 2
								dRef := SE1->E1_VENCREA
							ElseIf nVencto == 1 .OR. EMPTY(nVencto)
								dRef := SE1->E1_EMISSAO
							ElseIf nVencto == 3
								dRef := SE1->E1_EMIS1
							Endif

							nValRefPCC 	:= 0

							//Se tiver configurador de tributos, já possui os valores carregados
							//de PCC para a SE1 e despreza o carregamento via NewMinPcc
							If !lPccMR
								If(SE1->E1_BASEPIS > 0)
									nValRefPCC := SE1->E1_BASEPIS
									aDadosRet := NewMinPcc(dRef,nValRefPCC,cNatCli,"R",cChave)
									If(SE1->E1_BASECOF > 0.And.(SE1->E1_BASEPIS <> SE1->E1_BASECOF))
										nValRefPCC := SE1->E1_BASECOF
										aDadosRetDif := NewMinPcc(dRef,nValRefPCC,cNatCli,"R",cChave)
										aDadosRet[3] := aDadosRetDif[3]
									Endif
									If(SE1->E1_BASECSL > 0.And.(SE1->E1_BASEPIS <> SE1->E1_BASECSL))
										nValRefPCC := SE1->E1_BASECSL
										aDadosRetDif := NewMinPcc(dRef,nValRefPCC,cNatCli,"R",cChave)
										aDadosRet[4] := aDadosRetDif[4]
									Endif
								ElseIf(SE1->E1_BASECOF > 0)
									nValRefPCC := SE1->E1_BASECOF
									aDadosRet := NewMinPcc(dRef,nValRefPCC,cNatCli,"R",cChave)
									If(SE1->E1_BASECSL > 0.And.(SE1->E1_BASECOF <> SE1->E1_BASECSL))
										nValRefPCC := SE1->E1_BASECSL
										aDadosRetDif := NewMinPcc(dRef,nValRefPCC,cNatCli,"R",cChave)
										aDadosRet[4] := aDadosRetDif[4]
									Endif
								ElseIf(SE1->E1_BASECSL > 0)
									nValRefPCC := SE1->E1_BASECSL
									aDadosRet := NewMinPcc(dRef,nValRefPCC,cNatCli,"R",cChave)
								ElseIf(SE1->E1_BASEPIS == 0 .And. SE1->E1_BASECOF == 0 .And. SE1->E1_BASECSL == 0)
									aDadosRet	:= NewMinPcc(dRef,nValRefPCC,cNatCli,"R",cChave)
								Endif

								nVlRetPIS  := aDadosRet[ 2 ]
								nVlRetCOF  := aDadosRet[ 3 ]
								nVlRetCSLL := aDadosRet[ 4 ]  

								SE1->E1_PIS    := IIf(SE1->E1_PIS > 0 , nVlRetPIS , SE1->E1_PIS )
								SE1->E1_COFINS := IIf(SE1->E1_COFINS > 0, nVlRetCOF , SE1->E1_COFINS )
								SE1->E1_CSLL   := IIf(SE1->E1_CSLL > 0, nVlRetCSLL , SE1->E1_CSLL )		
							EndIf

							aFinPCC[2] += SE1->E1_PIS
							aFinPCC[4] += SE1->E1_COFINS
							aFinPCC[6] += SE1->E1_CSLL

							If nCntFor > 1 .AND. nCntFor == Len(aVencto) // Jogar eventuais resíduos de impostos na última parcela
								If SE1->E1_PIS + SE1->E1_COFINS + SE1->E1_CSLL > 0
									If nImpPIS == nCntFor .AND. aFinPCC[2] < aFinPCC[1] // Ultima parcela e não chegou no valor total do imposto
										nVlRetPIS += aFinPCC[1] - aFinPCC[2]
										SE1->E1_PIS := nVlRetPIS
									EndIf
									If nImpCOF == nCntFor .AND. aFinPCC[4] < aFinPCC[3] // Ultima parcela e não chegou no valor total do imposto
										nVlRetCOF  += aFinPCC[3] - aFinPCC[4]
										SE1->E1_COFINS := nVlRetCOF
									EndIf
									If nImpCSLL == nCntFor .AND. aFinPCC[6] < aFinPCC[5] // Ultima parcela e não chegou no valor total do imposto
										nVlRetCSLL  += aFinPCC[5] - aFinPCC[6]
										SE1->E1_CSLL := nVlRetCSLL
									EndIf																		
								EndIf
							EndIf

							lAbate := .T.
							// Conforme orientação da equipe do Financeiro, não se grava mais a cumulatividade na tabela SFQ
						Else

							//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
							//³ Verifica os titulos para o mes de referencia, para verificar se atingiu a retencao       ³
							//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

							// Estrutura de aDadosRet antigo PCC
							// 1-Valor dos titulos
							// 2-Valor do PIS
							// 3-Valor do COFINS
							// 4-Valor da CSLL
							// 5-Array contendo os recnos dos titulos

							nVlRetPIS := 0
							nVlRetCOF := 0
							nVlRetCSLL:= 0

							aDadosRet := MaNfsCalRt( If( cTipoData == "2", SE1->E1_VENCTO, SE1->E1_VENCREA ) )

							lAbate := .F.

							If aDadosRet[ 6 ] > nValMinRet  // PIS
								lAbate := .T.
								nVlRetPIS  := aDadosRet[ 2 ]
							EndIf

							If aDadosRet[ 7 ] > nValMinRet  // COFINS
								lAbate := .T.
								nVlRetCOF  := aDadosRet[ 3 ]
							EndIf

							If aDadosRet[ 8 ] > nValMinRet  // CSLL
								lAbate := .T.
								nVlRetCSLL := aDadosRet[ 4 ]
							EndIf

							If lAbate

								nVlRetPIS  := aDadosRet[ 2 ]
								nVlRetCOF  := aDadosRet[ 3 ]
								nVlRetCSLL := aDadosRet[ 4 ]

								nTotARet := nVlRetPIS + nVlRetCOF + nVlRetCSLL

								nSobra := SE1->E1_VALOR - nTotARet

								If nSobra < 0

									nSavRec := SE1->( Recno() )

									nFatorRed := 1 - ( Abs( nSobra ) / nTotARet )

			 						nVlRetPIS  := NoRound( nVlRetPIS * nFatorRed, 2 )
			 						nVlRetCOF  := NoRound( nVlRetCOF * nFatorRed, 2 )

			 						nVlRetCSLL := SE1->E1_VALOR - ( nVlRetPIS + nVlRetCOF )


									//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
									//³ Grava o valor de NCC caso a retencao seja maior   ³
									//³ que o valor do titulo                             ³
									//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

									ADupCredRt(Abs(nSobra),"101",nMoeda)


									//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
									//³ Restaura o registro do titulo original            ³
									//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
									SE1->( MsGoto( nSavRec ) )

									Reclock( "SE1", .F. )

								EndIf

								//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
								//³ Grava os novos valores de retencao                ³
								//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
								If !Empty( nVlRetPIS )
									SE1->E1_PIS    := nVlRetPIS
								Endif
								If !Empty( nVlRetCOF )
									SE1->E1_COFINS := nVlRetCOF
								Endif
								If !Empty( nVlRetCSLL )
									SE1->E1_CSLL   := nVlRetCSLL
								Endif


								nSavRec := SE1->( Recno() )

								//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
								//³ Zera os saldos a abater dos demais movimentos     ³
								//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
								aRecnos := aClone( aDadosRet[ 5 ] )

								cPrefOri  := SE1->E1_PREFIXO
								cNumOri   := SE1->E1_NUM
								cParcOri  := SE1->E1_PARCELA
								cTipoOri  := SE1->E1_TIPO
								cCfOri    := SE1->E1_CLIENTE
								cLojaOri  := SE1->E1_LOJA

								//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
								//³Ponto de entrada - permite a alteracao do array aRecnos para atualizacao do SE1   ³
								//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
								If aEntry[EP_M461GRVTAB]
									aRecnos := ExecBlock("M461GRVTAB", .F., .F., {aRecnos})
								EndIf
								For nLoop := 1 to Len( aRecnos )

									SE1->( dbGoto( aRecnos[ nLoop ] ) )

									RecLock( "SE1", .F. )

									SE1->E1_SABTPIS := 0
									SE1->E1_SABTCOF := 0
									SE1->E1_SABTCSL := 0

									SE1->( MsUnlock() )


									If nSavRec <> aRecnos[ nLoop ]
										dbSelectArea("SFQ")
										RecLock("SFQ",.T.)
											SFQ->FQ_FILIAL  := xFilial("SFQ")
											SFQ->FQ_ENTORI  := "SE1"
											SFQ->FQ_PREFORI := cPrefOri
											SFQ->FQ_NUMORI  := cNumOri
											SFQ->FQ_PARCORI := cParcOri
											SFQ->FQ_TIPOORI := cTipoOri
											SFQ->FQ_CFORI   := cCfOri
											SFQ->FQ_LOJAORI := cLojaOri

											SFQ->FQ_ENTDES  := "SE1"
											SFQ->FQ_PREFDES := SE1->E1_PREFIXO
											SFQ->FQ_NUMDES  := SE1->E1_NUM
											SFQ->FQ_PARCDES := SE1->E1_PARCELA
											SFQ->FQ_TIPODES := SE1->E1_TIPO
											SFQ->FQ_CFDES   := SE1->E1_CLIENTE
											SFQ->FQ_LOJADES := SE1->E1_LOJA
										MsUnlock()
									Endif

								Next nLoop

								//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
								//³ Retorna do ponteiro do SE1 para a parcela         ³
								//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
								SE1->( MsGoto( nSavRec ) )
								Reclock( "SE1", .F. )
							Else
								lAbate := .F.
							EndIf
						EndIf
					EndIf
				ElseIf cRetCli == "2"
					lAbate := .T.
				ElseIf cRetCli == "3"
					lAbate := .F.
				EndIf

			EndIf

			If !lAbate .And. cModRet == "1"
				aImpOut[3]	:=	 aImpOut[4]	:=	aImpOut[5]	:=	0
				aImposto[_VLRPIS_ ][1]	:=	aImposto[_VLRPIS_ ][2]	:=	0
				If lContrAbt
					SE1->E1_SABTPIS	:=	0
				EndIf
				SE1->E1_BASEPIS	:=	0
				SE1->E1_PIS		:=	0
				aImposto[_VLRCOFI_ ][1]	:=	aImposto[_VLRCOFI_ ][2]	:=	0
				If lContrAbt
					SE1->E1_SABTCOF	:=	0
				EndIf
				SE1->E1_BASECOF	:=	0
				SE1->E1_COFINS	:=	0
				aImposto[_VLRCSLL_ ][1]	:=	aImposto[_VLRCSLL_ ][2]	:=	0
				If lContrAbt
					SE1->E1_SABTCSL	:=	0
				EndIf
				SE1->E1_BASECSL	:=	0
				SE1->E1_CSLL	:=	0
			EndIf

			If ValType(aImposto[_VLRTPDP_][1]) == "A" .And. aImposto[_VLRTPDP_][1][1] > 0
				SE1->E1_TPDP := aImposto[_VLRTPDP_][1][1] * nFatorParc
			ElseIf ValType(aImposto[_VLRTPDP_][1]) == "N" .And. aImposto[_VLRTPDP_][1] > 0
				SE1->E1_TPDP := aImposto[_VLRTPDP_][1] * nFatorParc
			EndIf

            A040DupRec( "MATA460",(nCntFor == 1),aTitulo[_VLRTIT_], lAbate, lGerAbtISS,, aTitulo[_VLRISS_], MaFisRet(,"NF_RECISS"), , aMedicao , aProp[nCntFor] , (nCntFor == Len(aVencto)),,cRetCli,,,cCodIRRF,aImpos, ;
			lPccMR, lIrfMR, lInsMR, lIssMR, lFunMR, lFethabMR, lFabovMR, lFacsMR, lImaMR, lFamadMR)
			
			If Len(aRatFin) > 0 
				SE1->E1_MULTNAT := '1'
				FinxRatNat(aRatFin, SE1->(Recno()), "SE1")
			EndIf
			AtuSldNat(SE1->E1_NATUREZ, SE1->E1_VENCREA, SE1->E1_MOEDA, If(SE1->E1_TIPO$MVRECANT+"/"+MV_CRNEG,"3","2"), "R", SE1->E1_VALOR, SE1->E1_VLCRUZ, If(SE1->E1_TIPO$MVABATIM,"-","+"),,FunName(),"SE1", SE1->(Recno()),0)

			//
			// Template GEM - Gestao de Empreendimentos Imobiliarios
			//
			// Verifica se a condicao de pagamento tem vinculacao com uma condicao de venda
			//
			If lGEMLixParc
				ExecTemplate("GEMLIXPARC",.F.,.F.,{SE1->E1_PREFIXO ,SE1->E1_NUM  ,SE1->E1_PARCELA ;
				                                  ,SE1->E1_TIPO    ,SF2->F2_COND ,SE1->E1_VALOR   ;
				                                  ,iIf(Len(aTitCndVnd)>=nCntFor,aTitCndVnd[nCntFor],{}) ; // Detalhes do Titulo a receber(amortizacao,juros,etc)
				                                  } )
			EndIf

			SE1->(MsUnLock())
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Rotina de Importacao automatica de Titulos entre        ³
			//³	Filial e Matriz (Fa620Auto).                            ³
			//³	Parametros:                                             ³
			//³ 1- Recno do Titulo principal.                           ³
			//³	2- Filial destino.                                      ³
			//³	3- Historico.                                           ³
			//³	4- Executa aprovacao automatica. (Logico)               ³
			//³	5- Apresenta mensagens de Erro. (Logico)				³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If lRetAuto
				If SF4->F4_TRAFILI == "1"
					Fa620Auto(SE1->(RECNO()),cRematri,"Transferência",lAprAuto,.T.)
				EndIf
	   		EndIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Atualiza o SF2                                                          ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If !Intransact()
				RecLock("SF2")
			EndIf
			SF2->F2_VALFAT  += SE1->E1_VALOR
			SF2->F2_PREFIXO := SE1->E1_PREFIXO
			SF2->F2_DUPL    := SE1->E1_NUM
			SF2->F2_VALIRRF += SE1->E1_IRRF
			SF2->F2_VALINSS += SE1->E1_INSS - aImpOut[1]
//			SF2->F2_VALISS  += SE1->E1_ISS  - aImpOut[2]

			If (!lContrAbt .Or. Len( aRecnos ) <= 1 ) .And. SA1->A1_PESSOA <> "F"
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Corrige apenas se nao aglutinadora  ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				SF2->F2_VALPIS  += SE1->E1_PIS  - aImpOut[3]
				SF2->F2_VALCSLL += SE1->E1_CSLL - aImpOut[4]
				SF2->F2_VALCOFI += SE1->E1_COFINS - aImpOut[5]
			ElseIf SA1->A1_PESSOA == "F"
				SF2->F2_VALPIS  := 0
				SF2->F2_VALCSLL := 0
				SF2->F2_VALCOFI := 0
			EndIf

			If SA1->A1_PESSOA <> "F"
				aCtbRet[1] += SE1->E1_PIS
				aCtbRet[2] += SE1->E1_COFINS
				aCtbRet[3] += SE1->E1_CSLL
			EndIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Calcula a Proxima Parcela                                               ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			cParcela := MaParcela(cParcela)
			nValFun 	:= 0
			Aadd(aRecSe1,SE1->(Recno()))
			Aadd(aRecSE1Adt,SE1->(Recno()))

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Soma os valores de IRRF dos titulos da Naturezas de Rendimento          ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If lUsaNatRen

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				// NATUREZA DE RENDIMENTO     ³ 
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If Empty(aSE1NatRen[1]) 
					aSE1NatRen[1] := SE1->E1_IRRF
				Else
					aSE1NatRen[1] += SE1->E1_IRRF
				EndIf

				Aadd(aSE1NatRen[2],{SE1->E1_PREFIXO,SE1->E1_NUM,SE1->E1_PARCELA,SE1->E1_TIPO,SE1->E1_CLIENTE,SE1->E1_LOJA,SE1->E1_IRRF,SE1->E1_BASEIRF})

			EndIf

		Next nCntFor
		
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Gravação dos lancamentos de Impostos x Natureza Rendimento (FKW)        ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If !Empty(aSE1NatRen[1]) .And. !Empty(aNatRend[1])
			A461FKW(3,aNatRend,aSE1NatRen)
		Endif

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Calcula a Comissao                                                      ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		For nCntFor:= 1 To Len(aRecSe1)
			If lTemVend
				If ( lComissao )
					dbSelectArea("SE1")
					MsGoto( aRecSe1[nCntFor] )
					Fa440CalcE("MATA460")
					If lF440Com
						ExecBlock("F440COM",.F.,.F., aRecSE1)
					EndIf
				Else
					Fa440Comis( aRecSe1[ nCntFor ], .T., .F. )
				EndIf
			EndIf
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³CodeBlock de integracao com outros modulos                              ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			Eval(bAtuFin,aRecSe1[nCntFor])
		Next nCntFor
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Grava o valor de retencao do PIS/COFINS/CSLL para contabilizacao  ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If SuperGetMV("MV_CTRETNF",,"1")=="2"
			RecLock("SF2")
			SF2->F2_VALPIS := aCtbRet[1]
			SF2->F2_VALCOFI := aCtbRet[2]
			SF2->F2_VALCSLL := aCtbRet[3]
		EndIf

		// Faz a chamda da FGrvImpFi para gerar os recolhimentos no financeiro e da xFisF2F p/
		// gravar a tabela Título x NF do Fiscal (F2F).
		If lTrbGen .And. _lFGrvImpFi .And. Len(aTGCalcRec) > 0 .And. SF2->(ColumnPos("F2_IDNF")) > 0
			FGrvImpFi(@aTGCalcRec, "MATA460", dDatabase)
			xFisF2F("I", SF2->F2_IDNF, "SF2", aTGCalcRec)
		EndIf

		//Aqui chamo a função para fazer tratamento da geração das Guias.
		If cPaisLoc == "BRA" .AND. FindFunction("xFisAddGNRE") .And. AliasIndic("CIN")
			xFisAddGNRE(SF2->(RECNO()), "SF2",aTGCalcRec)
		EndIF

	EndIf
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Atualiza caucao de contrato		      ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If len(aContrato) > 0
	CtaAbatCauc( 1, aContrato[1], aRecSe1, SF2->F2_CLIENTE, SF2->F2_LOJA, SF2->F2_DOC, SerieNfId("SF2",2,"F2_SERIE") , NIL, SF2->F2_VALBRUT , cSerieId )
EndIf

FwFreeArray(aFinPCC)

Return( .T. )

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³MaNfsInit ³ Autor ³Eduardo Riera          ³ Data ³28.08.1999³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Inicializa as variaveis Staticas utilizadas no Programa     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nenhum                                                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³Nenhum                                                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Observacao³Utiliza as variaveis aEntry                                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³   DATA   ³ Programador   ³Manutencao Efetuada                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³               ³                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function MaNfsInit()

Local cValid      := ""
Local cReferencia := ""
Local nPosIni     := 0
Local nLen        := 0

If ( Empty(aEntry) )
	aEntry					   := Array(55)
	aEntry[EP_M460MKB   ]   := ExistBlock("M460MKB")
	aEntry[EP_M461IMPF  ]   := ExistBlock("M461IMPF",,.T.)
	aEntry[EP_SF2460T   ]   := ExistTemplate("SF2460I",,.T.)
	aEntry[EP_SF2460I   ]   := ExistBlock("SF2460I",,.T.)
	aEntry[EP_M460IPT   ]   := ExistTemplate("M460IPI")
	aEntry[EP_M460IPI   ]   := ExistBlock("M460IPI")
	aEntry[EP_M460ICM   ]   := ExistBlock("M460ICM")
	aEntry[EP_M460SOT   ]   := ExistTemplate("M460SOLI")
	aEntry[EP_M460SOLI  ]   := ExistBlock("M460SOLI")
	aEntry[EP_MSD2UMT   ]   := ExistTemplate("MSD2UM2")
	aEntry[EP_MSD2UM2   ]   := ExistBlock("MSD2UM2")
	aEntry[EP_MSD246T   ]   := ExistTemplate("MSD2460")
	aEntry[EP_MSD2460   ]   := ExistBlock("MSD2460")
	aEntry[EP_MTASF2    ]   := ExistBlock("MTASF2")
	aEntry[EP_F440COM   ]   := ExistBlock("F440COM")
	aEntry[EP_M460IREN  ]   := ExistBlock("M460IREN")
	aEntry[EP_M460ISS   ]   := ExistBlock("M460ISS")
	aEntry[EP_M460VISS  ]   := ExistBlock("M460VISS")
	aEntry[EP_M460ATEC  ]   := ExistBlock("M460ATEC")
	aEntry[EP_M460NITE  ]   := ExistBlock("M460NITE")
	aEntry[EP_M460PROC  ]   := ExistBlock("M460PROC")
	aEntry[EP_M460QRT   ]   := ExistTemplate("M460QRY")
	aEntry[EP_M460QRY   ]   := ExistBlock("M460QRY")
	aEntry[EP_M460FIT   ]   := ExistTemplate("M460FIL")
	aEntry[EP_M460FIL   ]   := ExistBlock("M460FIL")
	aEntry[EP_M460RTPD  ]   := ExistBlock("M460RTPD")
	aEntry[EP_M460FIM   ]   := ExistBlock("M460FIM")
	aEntry[EP_M460COND  ]   := ExistBlock("M460COND")
	aEntry[EP_M460INSS  ]   := ExistBlock("M460INSS")
	aEntry[EP_M460ITPD  ]   := ExistBlock("M460ITPD")
	aEntry[EP_M460ORD   ]   := ExistBlock("M460ORD")
	aEntry[EP_M460MOED  ]   := ExistBlock("M460MOED")
	aEntry[EP_M460RAT   ]   := ExistBlock("M460RAT")
	aEntry[EP_M461ACRE  ]   := ExistBlock("M461ACRE")
	aEntry[EP_M460NOTA  ]   := ExistBlock("M460NOTA")
	aEntry[EP_M460ICMT  ]   := ExistTemplate("M460ICM")
	aEntry[EP_M460QUEB  ]   := ExistBlock("M460QUEB")
	aEntry[EP_M461VTOT  ]   := ExistBlock("M461VTOT")
	aEntry[EP_M461DINF  ]   := ExistBlock("M461DINF")
	aEntry[EP_M460MARKT ]   := ExistTemplate("M460MARK")
	aEntry[EP_M460MARK  ]   := ExistBlock("M460MARK")
	aEntry[EP_M461ADT   ]   := ExistBlock("M461ADT")
	aEntry[EP_M461SLD   ]   := ExistBlock("M461SLD")
	aEntry[EP_M461SER   ]   := ExistBlock("M461SER",.F.,.F.)
	aEntry[EP_M461TRV   ]   := ExistBlock("M461TRV",.F.,.F.)
	aEntry[EP_M461COR   ]   := Existblock("M461COR")
	aEntry[EP_M461LSF2  ]   := ExistBlock("M461LSF2")
	aEntry[EP_M461GRVTAB]   := ExistBlock("M461GRVTAB")
	aEntry[EP_M460PRC   ]   := ExistBlock("M460PRC")
	aEntry[EP_M460FIMT  ]   := ExistTemplate("M460FIM")
	aEntry[EP_M461SB3   ]   := ExistBlock("M461SB3")
	aEntry[EP_M460CUST  ]   := ExistBlock("M460CUST")
	aEntry[EP_M460CUSTT ]   := ExistTemplate("M460CUST")
	aEntry[EP_M460GCUS  ]   := ExistBlock("M460GCUS")
	aEntry[EP_FATDOCSA  ]   := ExistTemplate("FATDOCSA")
EndIf

If aFisGet == Nil
	aFisGet	:= {}
	dbSelectArea("SX3")
	dbSetOrder(1)
	MsSeek("SC6")
	While SX3->( !Eof() ) .And. SX3->X3_ARQUIVO=="SC6"
		cValid := UPPER(SX3->X3_VALID+SX3->X3_VLDUSER)
		If 'MAFISGET("'$cValid
			nPosIni 	:= AT('MAFISGET("',cValid)+10
			nLen		:= AT('")',Substr(cValid,nPosIni,Len(cValid)-nPosIni))-1
			cReferencia := Substr(cValid,nPosIni,nLen)
			aAdd(aFisGet,{cReferencia,SX3->X3_CAMPO,MaFisOrdem(cReferencia)})
		EndIf
		If 'MAFISREF("'$cValid
			nPosIni		:= AT('MAFISREF("',cValid) + 10
			cReferencia	:=Substr(cValid,nPosIni,AT('","MT410",',cValid)-nPosIni)
			aAdd(aFisGet,{cReferencia,SX3->X3_CAMPO,MaFisOrdem(cReferencia)})
		EndIf
		SX3->( DBSkip() )
	EndDo
	aSort(aFisGet,,,{|x,y| x[3]<y[3]})
EndIf

If aFisGetSC5 == Nil
	aFisGetSC5	:= {}
	dbSelectArea("SX3")
	dbSetOrder(1)
	MsSeek("SC5")
	While SX3->( !Eof() ) .And. SX3->X3_ARQUIVO=="SC5"
		cValid := UPPER(X3_VALID+X3_VLDUSER)
		If 'MAFISGET("'$cValid
			nPosIni 	:= AT('MAFISGET("',cValid)+10
			nLen		:= AT('")',Substr(cValid,nPosIni,Len(cValid)-nPosIni))-1
			cReferencia := Substr(cValid,nPosIni,nLen)
			aAdd(aFisGetSC5,{cReferencia,SX3->X3_CAMPO,MaFisOrdem(cReferencia)})
		EndIf
		If 'MAFISREF("'$cValid
			nPosIni		:= AT('MAFISREF("',cValid) + 10
			cReferencia	:=Substr(cValid,nPosIni,AT('","MT410",',cValid)-nPosIni)
			aAdd(aFisGetSC5,{cReferencia,SX3->X3_CAMPO,MaFisOrdem(cReferencia)})
		EndIf
		SX3->( DBSkip() )
	EndDo
	aSort(aFisGetSC5,,,{|x,y| x[3]<y[3]})
EndIf


If aRelImp == Nil
	aRelImp := MaFisRelImp("MT100",{"SF2","SD2"})
EndIf
MaFisEnd()

Return( .T. )

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³MaNfsEnd  ³ Autor ³Eduardo Riera          ³ Data ³28.08.1999³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Encerra as variaveis Staticas utilizadas no Programa        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nenhum                                                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³Nenhum                                                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Observacao³Utiliza a  variavel aEntry                                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³   DATA   ³ Programador   ³Manutencao Efetuada                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³               ³                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function MaNfsEnd(lOnlySavRat)

Default lOnlySavRat := .F.

If !lOnlySavRat
	aEntry		:= {}
	aFisGet		:= Nil
	aFisGetSC5	:= Nil
	aRelImp	  	:= Nil
	aSavRat   	:= {}
	MaFisEnd()
Else
	aSavRat   	:= {}
EndIf

Return( .T. )

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³MaBxCQ2SD2³ Autor ³Eduardo Riera          ³ Data ³07.10.1999³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Baixa do CQ pela movimentacao do SD2.                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nenhum                                                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpL1: Indica se eh um estorno da movimentacao         (OPC)³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Observacao³O SF2,SD2 e SD1 devem estar posicionados                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³   DATA   ³ Programador   ³Manutencao Efetuada                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³               ³                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function MaCQ2SD2(lEstorno)

Local aArea     := GetArea()
Local lRastroL	:= IIf(Rastro(SD2->D2_COD,'S'),.T.,Rastro(SD2->D2_COD, 'L'))
Local lRastroS	:= Rastro(SD2->D2_COD,'S')
Local aMovCQ	:= {}
Local aSD7		:= {}
Local nPos		:= 0
Local nSaldo	:= 0
Local nEstorno  := 0
Local nCntFor	:= 0

Local cSeqSD7	:= ""

DEFAULT lEstorno := .F.

If ( !Empty(SD1->D1_NUMCQ) )
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Tratamento para implantacao do item do documento de saida           ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If !lEstorno
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Verifica os Movimento Liberados e Rejeitados do CQ                   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If ( SF2->F2_TIPO $ "DB" )
			aMovCQ := fLibRejCQ(SD2->D2_COD,SD2->D2_NFORI,SD2->D2_SERIORI,SF2->F2_CLIENTE,SF2->F2_LOJA,,SD2->D2_ITEMORI)
		EndIf
		If (nPos := aScan(aMovCQ,{|x|x[1]>0.And.x[2]>=SD2->D2_QUANT.And.x[3]==SD2->D2_LOCAL})) > 0
			nTipoD7  := aMovCQ[nPos, 1]
			cLocalD7 := aMovCQ[nPos, 3]
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Calcula a Quantidade a ser estornada do CQ                           ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			dbSelectArea("SD7")
			dbSetOrder(1)
			If ( MsSeek(xFilial("SD7")+SD1->D1_NUMCQ+SD2->D2_COD+SD1->D1_LOCAL,.F.) )
				While ( !Eof() .And.xFilial("SD7")	== SD7->D7_FILIAL .And.;
						SD1->D1_NUMCQ	== SD7->D7_NUMERO .And.;
						SD2->D2_COD		== SD7->D7_PRODUTO.And.;
						SD1->D1_LOCAL	== SD7->D7_LOCAL )

					nSaldo := SD7->D7_SALDO //Sempre esta no Ultimo registro Valido
					cSeqSD7:= SD7->D7_SEQ
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³Efetua o Estorno do CQ                                               ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If ( SD7->D7_LOCDEST==cLocalD7	.And.;
							Empty(SD7->D7_ESTORNO) 	.And.;
							SD7->D7_TIPO == nTipoD7 .And.;
							IIf(lRastroL,SD7->D7_LOTECTL==SD2->D2_LOTECTL,.T.) .And.;
							IIf(lRastroS,SD7->D7_NUMLOTE==SD2->D2_NUMLOTE,.T.) .And.;
							SD2->D2_QUANT	> nEstorno )

						RecLock('SD7', .F.)
						SD7->D7_ESTORNO := 'S'
						MsUnlock()

						nEstorno += SD7->D7_QTDE

						If ( Empty(aSD7) )
							For nCntFor := 1 To FCount()
								aadd(aSD7,FieldGet(nCntFor))
							Next nCntFor
						EndIf
					EndIf

					SD7->( DBSkip() )
				EndDo
				If ( nEstorno > 0 )
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³Cria o Registro de Estorno do CQ                                     ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					cSeqSD7 := Soma1(cSeqSD7,Len(SD7->D7_SEQ))
					RecLock('SD7', .T.)
					For nCntFor := 1 To FCount()
						FieldPut(nCntFor,aSD7[nCntFor])
					Next nCntFor
					SD7->D7_QTDE    := nEstorno
					SD7->D7_TIPO    := nTipoD7 + 2
					SD7->D7_SEQ     := cSeqSD7
					SD7->D7_SALDO   := nSaldo
					MsUnlock()
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³Cria o Registro da Quantidade nao estornada                          ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					cSeqSD7 := Soma1(cSeqSD7,Len(SD7->D7_SEQ))
					If ((nEstorno - SD2->D2_QUANT) > 0)
						RecLock('SD7', .T.)
						For nCntFor := 1 To FCount()
							FieldPut(nCntFor,aSD7[nCntFor])
						Next nCntFor
						SD7->D7_QTDE	:= nEstorno - SD2->D2_QUANT
						SD7->D7_TIPO	:= nTipoD7
						SD7->D7_SEQ     := cSeqSD7
						SD7->D7_SALDO   := nSaldo
						SD7->D7_ESTORNO := ""
						MsUnlock()
					EndIf
				EndIf
			EndIf
		EndIf
	Else
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Tratamento para estorno do item do documento de saida               ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		nSaldo := SD2->D2_QUANT

		dbSelectArea("SD7")
		dbSetOrder(2)
		MsSeek(xFilial("SD7")+SD1->D1_NUMCQ+SD1->D1_COD+SD1->D1_LOCAL)
		While !Eof() .And. xFilial("SD7") == SD7->D7_FILIAL .And.;
				SD1->D1_NUMCQ == SD7->D7_NUMERO .And.;
				SD1->D1_COD == SD7->D7_PRODUTO .And.;
				SD1->D1_LOCAL == SD7->D7_LOCAL .And.;
				nSaldo > 0

			If SD7->D7_DOC == SD1->D1_DOC .And.;
					SD7->D7_SERIE == SD1->D1_SERIE .And.;
					SD7->D7_FORNECE == SD1->D1_FORNECE .And.;
					SD7->D7_LOJA == SD1->D1_LOJA .And.;
					SD7->D7_ESTORNO == "S" .And.;
					( SD7->D7_TIPO==3 .Or. SD7->D7_TIPO==4 )

				RecLock("SD7")
				SD7->D7_QTDE    := Min(SD7->D7_QTDE,nSaldo)
				SD7->D7_ESTORNO := ""
				SD7->D7_TIPO    -= 2
				MsUnLock()

				nSaldo   -= SD7->D7_QTDE

			EndIf
			SD7->( DBSkip() )
		EndDo
	EndIf
EndIf
RestArea(aArea)

Return( .T. )

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³MaPvPrcIt³ Autor ³Edson Maricate          ³ Data ³07.10.1999³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Retorna o preco unitario do item.                           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nenhum                                                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³Nenhum                                                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Observacao³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³   DATA   ³ Programador   ³Manutencao Efetuada                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³               ³                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function MaPvPrcIt(aPvlNfs,nx,lReajuste,aRateio,nValNeg,nPerISS,dDataMoe)

Local aVar      := {}
Local nPrTab	:= 0
Local nPrcVen	:= 0
Local nPrUnit	:= 0
Local nAcresFin := 0
Local nTotal	:= 0
Local nDesconto := 0
Local nTotMdPv  := 0
Local lAcresDup := ( SuperGetMv("MV_ACRSDUP",.F.,.F.) == .T.)
Local lRndIss := 	( SuperGetMv("MV_RNDISS") == .T. )
Local nRatValrnd:= 0
Local nCalcDes 	:= 0
Local cMvArrefat:= SuperGetMV("MV_ARREFAT",,"N")
Local nDecimal	:= GetSx3Cache("D2_PRCVEN","X3_DECIMAL")

Default dDataMoe := dDataBase

If Empty(dDataMoe)
	dDataMoe := dDatabase
Endif
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Posiciona Registros                                                     ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
dbSelectArea("SC9")
dbSetOrder(1)
MsGoto(aPvlNfs[nx][8])

dbSelectArea("SB1")
dbSetOrder(1)
MsGoto(aPvlNfs[nx][12])

dbSelectArea("SC5")
dbSetOrder(1)
MsGoto(aPvlNfs[nx][9])

dbSelectArea("SC6")
dbSetOrder(1)
MsGoto(aPvlNfs[nx][10])

dbSelectArea("SF4")
dbSetOrder(1)
MsGoto(aPvlNfs[nx][14])
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Inicializa Variaveis                                                    ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

If SF4->F4_ISS == "S"  // a funcao AliqICMs trata Excecao Fiscal de ISS tambem
	If ( aEntry[EP_M460ISS] )
		nPerIss := ExecBlock("M460ISS",.f.,.f.,{nX})
	Endif
EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Calculo do Preco de Venda                                               ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
nPrcVen := SC9->C9_PRCVEN
nPrUnit := If(SC6->C6_PRUNIT<>0,SC6->C6_PRUNIT,SC9->C9_PRCVEN)

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Chamada de funcoes (P_M461PRCV e P_M461UNIT) via Project Function, transformada em user function para atender os clientes   ³
//³que ainda as utilizam, para manipulacao das variaveis nPrcVen (Calculo do Preco de Venda ) e nPrUnit (Calculo do Preco      ³
//³do Preco Unitario)																										   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
//Calculo do Preco de Venda
If _lM461PRCV
	nPrcVen := ExecBlock("PM461PRCV",.F.,.F.,{nX,nPrcVen})
EndIf

//Calculo do Preco Unitario
If _lM461UNIT
	nPrUnit := ExecBlock("PM461UNIT",.F.,.F.,{nX,nPrUnit})
EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Calcula o reajuste de preco.                                            ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If ( !Empty(SC5->C5_REAJUST) .And. lReajuste )
	nPrcVen  := Formula(SC5->C5_REAJUST)
	nPrUnit := nPrcVen
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Converte os valores para a Moeda Corrente(1)                            ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If SC5->C5_MOEDA > 1
	nTotMdPv := nPrcVen
	If	aEntry[EP_M460PRC]
		aVar     := ExecBlock("M460PRC",.F.,.F.,{nPrcVen,nPrUnit})
		nPrcVen  := aVar[1]
		nPrUnit  := aVar[2]
	ElseIf SuperGetMV('MV_AGRUBS',.F.,.F.) .And. _lOGX225J .And. SC5->(ColumnPos("C5_TRCNUM")) > 0  .And. !Empty(SC5->C5_TRCNUM)
		aVar     := OGX225J({nPrcVen,nPrUnit,@aPvlNfs})
		nPrcVen  := aVar[1]
		nPrUnit  := aVar[2]
		aPvlNfs  := aVar[3]
	Else
	    nPrcVen := xMoeda(nPrcVen,SC5->C5_MOEDA,1,dDataMoe,8)
		nPrUnit := xMoeda(nPrUnit,SC5->C5_MOEDA,1,dDataMoe,8)
	Endif
EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Calculo do Acrescimo Financeiro                                         ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If ( SC5->C5_ACRSFIN <> 0 )
	If lAcresDup
		nAcresFin := a410Arred(nPrcVen*SC5->C5_ACRSFIN/100,"D2_PRCVEN")
		nTotMdPv += a410Arred(nTotMdPv*SC5->C5_ACRSFIN/100,"D2_PRCVEN")
	Else
		If SF4->F4_DUPLIC=="S"
			nAcresFin := a410Arred(nPrcVen*SC5->C5_ACRSFIN/100,"D2_PRCVEN")
			nTotMdPv  += a410Arred(nTotMdPv*SC5->C5_ACRSFIN/100,"D2_PRCVEN")
		Endif
	Endif
EndIf

If ( aEntry[EP_M461ACRE] )
	nAcresFin := Execblock("M461ACRE",.f.,.f.,{nPrcVen,nPrUnit,nAcresFin})
Endif

If SC5->C5_TIPO $ "CIP" .AND. !_lM461PRCV
	If ( SC5->C5_MOEDA == 1 )
		nPrcVen := SC6->C6_PRCVEN
	EndIf
ElseIf ( SC5->C5_MOEDA <> 1 )
	nPrcVen  := nPrcVen + nAcresFin
Else
	nPrcVen  := a410Arred(nPrcVen,"D2_PRCVEN")+nAcresFin
	nPrUnit  := a410Arred(nPrUnit,"D2_PRCVEN")
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Calculo do Preco com ISS                                                ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If ( SC5->C5_INCISS == "N" .And. SF4->F4_ISS=="S" .And. SC5->C5_TIPO == "N" )
	If lRndIss
		nPrcVen := a410Arred(nPrcVen/(1-(nPerISS/100)),"D2_PRCVEN")
	Else
		nPrcVen := nPrcVen/(1-(nPerISS/100))
	Endif
	nTotMdPv:= a410Arred(nTotMdPv/(1-(nPerISS/100)),"D2_PRCVEN")
EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Calcula o Valor Total do Item                                           ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If ( SC5->C5_TIPO$"CIP" .Or. MaTesSel(SC6->C6_TES) .Or.;
		( aPvlNfs[nx][4]==SC6->C6_QTDVEN .And. (SC5->C5_TIPO=="D" .Or. SF4->F4_PODER3=="D") ) )
	If ( SC5->C5_TIPO$"CIP" .Or. MaTesSel(SC6->C6_TES) ) .And. aEntry[EP_M460PRC]
		nTotal := nPrcVen
	Else
		If ( SC5->C5_MOEDA <> 1 )
			nTotMdPv := SC6->C6_VALOR
			nTotal   := xMoeda(SC6->C6_VALOR,SC5->C5_MOEDA,1,dDataMoe,GetSx3Cache("C6_PRCVEN","X3_DECIMAL"))
		Else
			nTotal   := SC6->C6_VALOR
		EndIf
	EndIf
Else
	If ( SC5->C5_INCISS == "N" .And. SF4->F4_ISS=="S" .And. SC5->C5_TIPO == "N" )
		If lRndIss
			nTotal   := nPrcVen * aPvlNfs[nx][4]
		Else
			nTotal   := a410Arred((nPrcVen * aPvlNfs[nx][4]),"D2_PRCVEN")
		EndIf
	ElseIf SC5->C5_MOEDA > 1 .And. cMvArrefat == "N"
		nTotal   := NoRound(nPrcVen,nDecimal) * aPvlNfs[nx][4]
	Else
		nTotal   := nPrcVen * aPvlNfs[nx][4]
	Endif
	nTotMdPv *= aPvlNfs[nx][4]
EndIf

If ( SC5->C5_MOEDA <> 1 )
	nPrcVen  := a410Arred(nPrcVen,"D2_PRCVEN")
	nPrUnit  := a410Arred(nPrUnit,"D2_PRCVEN")
EndIf

nTotal   := a410Arred(nTotal  ,"D2_TOTAL")
nTotMdPv := a410Arred(nTotMdPv,"D2_TOTAL")

If nPrcVen > 0
	aRateio[RT_PDESCON] := IIf(aRateio[RT_PDESCON]>nTotal,nTotal,aRateio[RT_PDESCON])
	If aRateio[RT_PDESCON]+aRateio[RT_DESCONT]>nTotal
		aRateio[RT_PDESCON] := 0
	EndIf
	//Por segurancao nao eh pertido desconto maior que o total do item
Else
	nValNeg := 0
EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Calculo do Desconto                                                     ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
nPrTab := nPrUnit
//Soma do Desconto Rateado já arredondado
nRatValrnd := Round(aRateio[RT_DESCONT] + aRateio[RT_PDESCON], GetSx3Cache("D2_DESCON","X3_DECIMAL"))

If SuperGetMV("MV_NDESCTP",,.F.) .And. SC6->C6_VALDESC == 0 .And. SC6->C6_DESCONT==0
	nPrUnit := nPrcVen
EndIf
If ( nPrUnit > nPrcVen .Or. nValNeg > 0 .Or. SC6->C6_VALDESC > 0 )

	nCalcDes := ((nPrUnit * aPvlNFs[nx][4]) - nTotal) + nValNeg
	
	nDesconto := a410Arred(nCalcDes, "D2_DESCON")
	
	If nDesconto <= 0
		If SC6->C6_QTDVEN == aPvlNFs[nx][4]
			nDesconto := SC6->C6_VALDESC
		Else
			nDesconto := A410Arred(SC6->C6_VALDESC/SC6->C6_QTDVEN*aPvlNFs[nx][4],"C6_VALDESC")
		EndIf
		nDesconto := xMoeda(nDesconto,SC5->C5_MOEDA,1,dDataMoe,GetSx3Cache("D2_DESCON","X3_DECIMAL"))
	EndIf
	nDesconto := nDesconto + nRatValrnd
	nDesconto := Max(0,nDesconto)
Else
	nDesconto := nRatValrnd
EndIf
nPrUnit := nPrTab
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Desconto de Cabecalho so calculado na geracao da NF                    ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
nPrcVen := nPrcVen - A410Arred(( nRatValrnd / aPvlNFs[nx][4]),"D2_PRCVEN")
nTotal  := nTotal  -  nRatValrnd

nPrcVen := Max(0,nPrcVen)
nTotal  := Max(0,nTotal)

//Se o valor do desconto for o mesmo do valor total, zera o preço de venda. 
//Quando o valor de desconto de indenização (C5_DESCONT) é o mesmo que o total do pedido,
//o preço de venda está ficando com valor de centavos (diferença de dízimas devido aos valores que foram truncados)
If nTotal == 0 .And. nPrcVen > 0 .And. aRateio[RT_DESCONT] > 0 .And. SC5->C5_TIPO == "N"
	nPrcVen := 0
EndIf

nTotMdPv -= xMoeda( nRatValrnd, 1, SC5->C5_MOEDA, dDataMoe, 2)

nAcresFin := nAcresFin * aPvlNfs[nx][4]

Return {nPrcVen,nPrUnit,nTotal,nDesconto,nPerISS,nAcresFin,nTotMdPv}

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Program   ³MATA460B  ³ Autor ³Eduardo Riera          ³ Data ³26.03.20001	³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Rotina de Geracao das Notas Fiscais de Saida por Carga     	³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpL1: Processamento Ok.                                    	³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³Nenhum                                                      	³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ ATUALIZACOES SOFRIDAS DESDE A CONSTRUCAO INICIAL.                     	³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ PROGRAMADOR  ³ DATA   ³ BOPS ³  MOTIVO DA ALTERACAO                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³              ³        ³      ³                                          ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function Mata460B()
Local lContinua := .T.

PRIVATE bFiltraBrw         // Expressao de Filtro
PRIVATE nOrdNFS   := 1     // Ordem de Geracao da Nota Fiscal
PRIVATE cCadastro := OemToAnsi(STR0005) // Preparação dos Documentos de Saída"
PRIVATE c460Cond  := ""
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Carga das Variaveis Staticas do Programa                                ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
MaNfsInit()
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Avalia Ponto de Entrada                                                 ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If ( aEntry[EP_M460MKB] )
	c460Cond := ExecBlock("M460MKB", .F., .F.)
EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Montagem das querys necessarias a fim de otimizar o programa            ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

TcSrvMap("SB2")
SB2->(MsGoto(RecNo()))
TcSrvMap("SB6")
SB6->(MsGoto(RecNo()))
TcSrvMap("SC9")
SC9->(MsGoto(RecNo()))
TcSrvMap("SF4")
SF4->(MsGoto(RecNo()))
TcSrvMap("SED")
SED->(MsGoto(RecNo()))
TCInternal(5,"*OFF")
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Verifica o direito de acesso por parte do usuario                       ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If ( Substr(cAcesso,51,1) <> "S" )
	SF2->(dbSetOrder(3))
	SF2->(MsSeek(xFilial("SF2")+Space(Len(SF2->F2_ECF))+"z",.T.))
	SF2->(dbSkip(-1))
	If ( dDataBase < SF2->F2_EMISSAO )
		Help(" ",1,"DATNF")
		lContinua := .F.
	EndIf
	If lContinua
		SF2->(MsSeek(xFilial("SF2")+"S"+"z",.T.))
		SF2->(dbSkip(-1))
		If ( dDataBase < SF2->F2_EMISSAO )
			Help(" ",1,"DATNF")
			lContinua := .F.
		EndIf
	EndIf
EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Verifica o Ambiente de Processamento.                                   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If ( lContinua .And. AMIIn(5,12,39,72) )
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Verifica o Fechamento do Estoque                                        ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If ( MVUlmes() >= dDataBase )
		Help ( " ", 1, "FECHTO" )
		lContinua := .F.
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Verifica o Fechamento do Fiscal                                         ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If ( !FisChkDt(dDataBase) )
		lContinua := .F.
	EndIf

	lContinua := OMSA460B()

	SetKey(VK_F12,Nil)
Else
	lContinua := .F.
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Anula as variaveis staticas criadas pela funcao manfsinit               ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
MaNfsEnd()

Return( lContinua )

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³Ma461Estor³ Autor ³Eduardo Riera          ³ Data ³29.08.1999³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Estorno da liberacao dos pedidos de venda                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpL1: Indica se o estorno foi efetuado com sucesso         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³Nenhum                                                      ³±±
±±³          ³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³   DATA   ³ Programador   ³Manutencao Efetuada                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³               ³                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function Ma461Estor()

Local aArea      := GetArea()
Local nTpEstorno := 0
Local lRetorno   := .T.
Local aSC5		 := {} //WorkArea SC5
Local lECCia	 := SuperGetMv("MV_LJECOMM",,.F.)  .AND. SuperGetMv("MV_LJECOMO",,.F.)
Local lWMSSaas   := FindFunction("WMSSaasHas") .And. WMSSaasHas()

Private lVerCarg461 := SuperGetMV("MV_VERC461",,.F.) //--> Verifica(.T.) se algum dos pedidos selecionados estão com carga montada OMS.
Private lWmsPergEP  := .T.

If !ctbValiDt( Nil, dDataBase, .T., Nil, Nil, { "FAT004" }, Nil )
	Return .F.
EndIf

Pergunte("MT461A",.F.)

nTpEstorno := MV_PAR02

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Valida o tipo de estorno de liberacao cujo SC9 esta posicionado        ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If nTpEstorno == 1
	If SC9->C9_FILIAL <> xFilial("SC9")
		Help(" ",1,"A000FI")
		lRetorno := .F.
	ElseIf (SC9->C9_BLEST == "10" .And. SC9->C9_BLCRED == "10") .OR. (SC9->C9_BLEST == "ZZ" .And. SC9->C9_BLCRED == "ZZ")
		Help(" ",1,"NFEMITIDA")
		lRetorno := .F.
	ElseIf IntWms(SC9->C9_PRODUTO) .And. !Empty(SC9->C9_SERVIC)
		// Validação WMS para permitir o estorno da liberação
		lRetorno := WmsAvalSC6("4")
	ElseIf lECCia
		aSC5 := SC5->(GetArea())
		SC5->(DbSetorder(1)) //C5_FILIAL + C5_NUM
		SC5->(DbSeek(xFilial("SC5")+ SC9->C9_PEDIDO))
		If SC5->(Found()) .AND. Val(SC5->C5_PEDECOM) > 0
			Help('',1,'PEDECOM',,STR0111 + " " + STR0112, 1,0) //"Não é possível realizar estorno de liberação de pedidos e-commerce."
			lRetorno := .F.
		EndIf
		RestArea(aSC5)
	ElseIf lWMSSaas .And. FindFunction("WMSSVlEPdV")
		lRetorno := WMSSVlEPdV(SC9->(Recno()), .T.)
	EndIf
	//Validações referentes à integração do OMS com o Cockpit Logístico Neolog
	If SuperGetMv("MV_CPLINT",.F.,"2") == "1" .And. FindFunction("OMSCPLVlPd")
		lRetorno := OMSCPLVlPd(6,SC9->C9_PEDIDO)
	EndIf
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Solicita confirmacao do estorno                                        ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lRetorno
	If nTpEstorno == 1
		If MsgYesNo(OemToAnsi(STR0023),OemToAnsi(STR0022))		//"Confirma o Estorno da Libera‡„o?"###"Aten‡„o"
			If Empty(c460Cond) .Or. &(c460Cond)
				Begin Transaction
				a460Estorna()
				End Transaction
			EndIf
		EndIf
	Else
		If MsgYesNo(OemToAnsi(STR0024),OemToAnsi(STR0022))		//"Confirma o Estorno da Libera‡„o para todos os itens selecionados ?"###"Aten‡„o"
			Processa({|lEnd| Ma461Est2(@lEnd)},,,.T.)
		EndIf
	EndIf
EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Restaura a integridade da rotina                                       ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
RestArea(aArea)

Return( lRetorno )
/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³Ma461Est2 ³ Autor ³Eduardo Riera          ³ Data ³29.08.1999³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Estorno da liberacao dos pedidos de venda - Processamento   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpL1: Indica se o estorno foi efetuado com sucesso         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³Nenhum                                                      ³±±
±±³          ³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³   DATA   ³ Programador   ³Manutencao Efetuada                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³               ³                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function Ma461Est2(lEnd)

Local aArea      := GetArea()

Local lRetorno   := .T.
Local lValido    := .F.
Local lInverte   := ThisInv()
Local cMarca     := ThisMark()

Local cAliasSC9  := "SC9"
Local cMensagem  := RetTitle("C6_NUM")

Local lPedCarga  := .F.
Local oFiltrPesq := GetMBrowse()
Local cFiltrPesq := oFiltrPesq:cEspFilter
Local aSC5		 := {} //WorkArea SC5
Local lECCia	 := SuperGetMv("MV_LJECOMM",,.F.)  .AND. SuperGetMv("MV_LJECOMO",,.F.) .AND. SC5->(FieldPos("C5_PEDECOM") > 0)
Local lMA461Est	 := ExistBlock("MA461EST")
Local lWMSSaas   := FindFunction("WMSSaasHas") .And. WMSSaasHas()

Local cQuery     := ""

Private lWmsPergEP := .T.

If Valtype(aFiltro) == 'U'
	aFiltro   := Eval(bFiltraBrw,1)
Endif

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Inicializa a regua                                                     ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
ProcRegua(SC9->(LastRec()))

cAliasSC9 := "MA461ESTOR"

cQuery := "SELECT R_E_C_N_O_ SC9RECNO,C9_PEDIDO,C9_ITEM "
cQuery += "FROM "+RetSqlName("SC9")+" SC9 "
cQuery += "WHERE SC9.C9_FILIAL='"+xFilial("SC9")+"' AND "
If ( lInverte )
	cQuery += "SC9.C9_OK<>'"+cMarca+"' AND "
Else
	cQuery += "SC9.C9_OK='"+cMarca+"' AND "
EndIf
cQuery += "SC9.C9_BLEST<>'10' AND "
cQuery += "SC9.C9_BLEST<>'ZZ' AND "
cQuery += "SC9.C9_BLCRED<>'10' AND "
cQuery += "SC9.C9_BLCRED<>'ZZ' AND "
cQuery += "SC9.D_E_L_E_T_=' ' "
cQuery += "AND "+aFiltro[2]
If cFiltrPesq <> ''
	cQuery	+= "AND (" +cFiltrPesq +")"
EndIf

cQuery := ChangeQuery(cQuery)

dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasSC9,.T.,.T.)

dbSelectArea(cAliasSC9)
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Verifica se os pedidos selecionados estão em Carga OMS.                ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lVerCarg461

	If (cAliasSC9)->(!Bof()) .And. (cAliasSC9)->(!Eof())
		lPedCarga := VERCARG461(cAliasSC9,.T.)
	EndIf

	If lPedCarga
		Help(" ",1,"MATA46101")
		(cAliasSC9)->( DBCloseArea() )
		DBSelectArea("SC9")
		//³ Restaura a integridade da rotina                                       ³
		RestArea(aArea)
		Return ( lRetorno )
	Else
		(cAliasSC9)->(dbGoTop())
	EndIf

EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Inicializa o processamento                                             ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
dbSelectArea(cAliasSC9)
While (cAliasSC9)->( !Eof() )
	lValido := .T.

	If lECCia
		aSC5 := SC5->(GetArea())
		SC5->(DbSetorder(1)) //C5_FILIAL + C5_NUM
		SC5->(DbSeek(xFilial("SC5")+ SC9->C9_PEDIDO))
		If SC5->(Found()) .AND. Val(SC5->C5_PEDECOM) > 0
			lValido := .F.
		EndIf
		RestArea(aSC5)
	EndIf

	If lValido

		dbSelectArea("SC9")
		MsGoto((cAliasSC9)->SC9RECNO)

		//Validações referentes à integração do OMS com o Cockpit Logístico Neolog
		If SuperGetMv("MV_CPLINT",.F.,"2") == "1" .And. FindFunction("OMSCPLVlPd")
			lValido := OMSCPLVlPd(6,SC9->C9_PEDIDO)
		EndIf

		If SuperGetMV("MV_ROTAINT",.F.,.F.) .And. FindFunction("OMSTPR410P")
			lValido := OMSTPR410P(6,,,SC9->C9_PEDIDO,SC9->C9_ITEM,SC9->C9_SEQUEN,SC9->C9_PRODUTO)
		EndIf

		dbSelectArea("SC9")
		If Empty(c460Cond) .Or. &(c460Cond)
			If IntWms(SC9->C9_PRODUTO) .And. !Empty(SC9->C9_SERVIC)
				// Validação WMS para permitir o estorno da liberação
				If !(lValido := WmsAvalSC6("4"))
					Exit
				EndIf
			EndIf

			If lValido .AND. lWMSSaas .And. FindFunction("WMSSVlEPdV")
				If !(lValido := WMSSVlEPdV(SC9->(Recno()),.T.))
					Exit
				EndIf
			EndIf
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Verifica ponto de entrada                                              ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If lMA461Est
				lValido := ExecBlock("MA461EST",.F.,.F.)
			EndIf
			If lValido
				Begin Transaction
					a460Estorna()
				End Transaction
			EndIf
		EndIf
	EndIf

	(cAliasSC9)->( DBSkip() )

	IncProc(cMensagem+"..:"+(cAliasSC9)->C9_PEDIDO+"/"+(cAliasSC9)->C9_ITEM)

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Controle de cancelamento do usuario                                    ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lEnd
		Exit
	EndIf
EndDo

(cAliasSC9)->( DBCloseArea() )
DBSelectArea("SC9")

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Restaura a integridade da rotina                                       ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
RestArea(aArea)

Return( lRetorno )

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³MaNfs2Nfs ³ Autor ³Eduardo Riera          ³ Data ³20.02.2002³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Rotina de preparacao do documento de saida atraves de outro ³±±
±±³          ³documento de saida.                                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpC1: Numero do documento preparado                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpC1: Serie do Documento de Origem                         ³±±
±±³          ³ExpC2: Numero do Documento de Origem                        ³±±
±±³          ³ExpC3: Cliente/Fornecedor do documento do origem            ³±±
±±³          ³ExpC4: Loja do Documento de origem                          ³±±
±±³          ³ExpC5: Serie do Documento a ser gerado                      ³±±
±±³          ³ExpL6: Mostra Lct.Contabil                             (OPC)³±±
±±³          ³ExpL7: Aglutina Lct.Contabil                           (OPC)³±±
±±³          ³ExpL8: Contabiliza On-Line                             (OPC)³±±
±±³          ³ExpL9: Contabiliza Custo On-Line                       (OPC)³±±
±±³          ³ExpLA: Reajuste de preco na nota fiscal                (OPC)³±±
±±³          ³ExpNB: Tipo de Acrescimo Financeiro                    (OPC)³±±
±±³          ³ExpNC: Tipo de Arredondamento                          (OPC)³±±
±±³          ³ExpLD: Atualiza Amarracao Cliente x Produto            (OPC)³±±
±±³          ³ExplE: Cupom Fiscal                                    (OPC)³±±
±±³          ³ExpBF: CodeBlock de Selecao do SD2                     (OPC)³±±
±±³          ³       Parametros do codeblock                              ³±±
±±³          ³       ExpC1: Alias do arquivo SD2                          ³±±
±±³          ³       ExpC2: Alias do arquivo SF4                          ³±±
±±³          ³ExpBG: CodeBlock a ser executado para o SD2            (OPC)³±±
±±³          ³       Parametros do codeblock                              ³±±
±±³          ³       ExpN1:[1] Apos a copia do item do documento de saida ³±±
±±³          ³             [2] Apos a checagem da atualizacoes anteriores ³±±
±±³          ³       ExpA2:Array com o conteudo dos campos do SD2         ³±±
±±³          ³       ExpC3:Alias do SD2                              (OPC)³±±
±±³          ³       ExpC4:Alias do SF4                              (OPC)³±±
±±³          ³       ExpC5:Alias do SB1                              (OPC)³±±
±±³          ³ExpBH: CodeBlock a ser executado para o SF2            (OPC)³±±
±±³          ³       ExpN1:[1] Apos a copia do item do documento de saida ³±±
±±³          ³             [2] Apos a checagem da atualizacoes anteriores ³±±
±±³          ³ExpBI: CodeBlock a ser executado no final da transacao (OPC)³±±
±±³          ³ExpAJ: Array com os Recnos do SF2                      (OPC)³±±
±±³          ³       Deve possuir o mesmo tamanho da ExpAl           (OPC)³±±
±±³          ³ExpAL: Array com os itens do SD2                       (OPC)³±±
±±³          ³       [1] Item do SD2                                 (OPC)³±±
±±³          ³       [2] Conteudo dos campos na ordem da estrutura   (OPC)³±±
±±³          ³ExpAM: Array com os dados do SF2                       (OPC)³±±
±±³          ³       [n] Conteudo posicional do campo                    )³±±
±±³          ³       Somente é necessario se não houver um documento de   ³±±
±±³          ³       origem.                                              ³±±
±±³          ³ExpAN: Calculo Fiscal                                  (OPC)³±±
±±³          ³       Desabilita o calculo fiscal pois as informacoes ja   ³±±
±±³          ³       foram passadas nos campos do SD2 e SF2.              ³±±
±±³          ³ExpAO: Codigo do cliente de Entrega para calculo dos impos- ³±±
±±³          ³       tos.                                                 ³±±
±±³          ³ExpAP: Codigo da loja de Entrega para calculo dos impostos  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³   DATA   ³ Programador   ³Manutencao Efetuada                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³               ³                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function MaNfs2Nfs(cSerOri,cNumORI,cClieFor,cLoja,cSerieNFS,lMostraCtb,lAglutCtb,lCtbOnLine,lCtbCusto,lReajusta,nCalAcrs,nArredPrcLis,lAtuSA7,lECF,bFilSD2,bSD2,bSF2,bTTS,aDocOri,aItemOri,aSF2,lNoFiscal,bFiscalSF2,bFiscalSD2,bFatSE1,cNumNFS,lVerSE1,lGTPSub,cTpOper,cTypeDoc)

Static lM460Num

Local aArea    := GetArea()
Local cArquivo := ""
Local nHdlPrv  := 0
Local nLctTotal:= 0
Local lLct610  := .F.
Local lLct620  := .F.
Local lIntACD  := SuperGetMV("MV_INTACD",.F.,"0") == "1"
Local cTpNrNfs := SuperGetMV("MV_TPNRNFS")
Local aLancCtb := {}
Local lUsaNewKey:= GetSx3Cache("F2_SERIE","X3_TAMANHO") == 14 // Verifica se o novo formato de gravacao do Id nos campos _SERIE esta em uso
Local cSerieId  := IIf( lUsaNewKey , SerieNfId("SF2",4,"F2_SERIE",dDataBase,A460Especie(cSerieNFS),cSerieNFS) , cSerieNFS )
Local lBilGTP	:= .F.	// Controle de numeração de documento executada pelo GTP
Local lContinua	:= .T.
Local lUnlockD9	:= .F.
Local lNewInvoic:= Iif(__RpoRelease >= '12.1.2410',;
						tlpp.ffunc("backoffice.fat.documento.UsaNewInvoice") .And.;
						tlpp.call('backoffice.fat.documento.UsaNewInvoice()'),.F.)


//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Inicializa os parametros DEFAULT                                       ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
DEFAULT lM460Num     := ExistBlock("M460NUM",.F.,.F.)
DEFAULT lMostraCtb   := .F.
DEFAULT lAglutCtb    := .F.
DEFAULT lCtbOnLine   := .F.
DEFAULT lCtbCusto    := .F.
DEFAULT lReajusta    := .F.
DEFAULT nCalAcrs     := 1
DEFAULT nArredPrcLis := 1
DEFAULT lAtuSA7      := .F.
DEFAULT lECF         := .F.
DEFAULT bSD2         := {|| .T.}
DEFAULT bFilSD2      := {|| .T.}
DEFAULT bSF2         := {|| .T.}
DEFAULT bTTS         := {|| .T.}
DEFAULT aDocOri      := {}
DEFAULT aItemOri     := {}
DEFAULT lNoFiscal    := .F.
DEFAULT bFatSE1      := {|| .T. }
DEFAULT cNumNFS		 := ""
DEFAULT lVerSE1		 := .T.
DEFAULT lGTPSub 	 := .F.
DEFAULT cTpOper		 := ""
DEFAULT cTypeDoc	 := ""

If lECF .And. !IsInCallStack('GerDocNf') //Sempre será falso com exceção das chamadas do GTPJBPE e GTPJBPR # Se ja for falso não ha necessidade de executar a pilha para fins de performance
	lECF := .F. 
EndIf
If Empty(cNumNFS)
	lUnlockD9 := .T.
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Carga das Variaveis Staticas do Programa                                ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If Len(aEntry) == 0
	MaNfsInit()
Else
	MaFisEnd()
EndIf

If !lMa460Nota //Se for chamada do Ma460Nota o help já foi apresentado
	Pergunte("MT460A",.F.)
	If mv_par16 == 2 .and. !aEntry[EP_M461IMPF]
		Help(NIL, NIL, "CUPOM", NIL, STR0121, 1, 0, NIL, NIL, NIL, NIL, NIL, {STR0122}) //"A geração de Cupom Fiscal foi descontinuada."##"Verifique os parâmetros para emissão de documento de saída."
		lContinua := .F.
	EndIf
EndIf	

If lContinua
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Verificacao do numero do Documento de Saida                             ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	// Se lMudouNum for .T. significa que o usuario alterou o numero da nota em MV_TPNRNFS == "3"
	// e o sistema deve respeitar o novo numero contido em cNumero
	If Type("lMudouNum") == "U"
		Private lMudouNum := .F.
	EndIf
	If lMudouNum .And. (cTpNrNfs == "3"  .Or. cTpNrNfs == "2")
		cNumNFS  := cNumero
		// Se alterou o numero, sistema ir arespeitar novo numero informado para primeira nota, porem,
		// a partir da segunda nota o sistema buscara a numeracao normal a partir do SXE/SXF
		If cTpNrNfs == "2"
			lMudouNum := .F.
		EndIf
	Elseif Empty(cNumNFS) .And. cTpNrNfs <> "3"
		cNumNFS  := IIf(!lECF, NxtSX5Nota( cSerieNFS, .T., cTpNrNfs, , , , cSerieId, lVerSE1,cTypeDoc ),"") // O parametro cSerieId deve ser passado para funcao NxtSx5Nota afim de tratar a existencia ou nao do mesmo numero na funcao VldSx5Num do MATXFUNA.PRX
	EndIf

	If lM460Num
		cNumero := cNumNFS
		PRIVATE cSerie  := cSerieNFS
		ExecBlock("M460NUM",.F.,.F.)
		cNumNFS   := cNumero
		cSerieNFS := cSerie
	EndIf

	If FWIsInCallStack("GTPJ001") .Or. FWIsInCallStack("GTPJBPE")
		If !Empty(cNumNFS)
			lBilGTP := .T.	// Controle de numeração de documento executada pelo GTP 
		EndIf
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Verifica os Lancamentos contabeis                                       ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	_aDPrv461	:= {}
	If ( lCtbOnLine )
		lLct610 := VerPadrao("610")
		lLct620 := VerPadrao("620")
	EndIf
	If ( lLct610 .Or. lLct620 )
		PRIVATE cLote
		LoteCont("FAT")
		nHdlPrv := HeadProva(cLote /*cLote*/,;
							"MATA460" /*cPrograma*/,;
							cUserName /*cOperador*/,;
							@cArquivo /*cArquivo*/,;
							/*lCria*/,;
							@_aDPrv461 /*aDadosProva*/)
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Inicializa a gravacao dos lancamentos do SIGAPCO          ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	PcoIniLan("000101")

	Begin Transaction
		// Obtem numero do documento dentro da transacao
		If cTpNrNfs == "3"
			If (!lM460Num .Or. Empty(cNumNFS))
				If !lBilGTP 	//Informa que a nota é um bilhete de transporte rodoviario e o controle de numeração é de resposanbilidade do GTP
					cNumNFS := MA461NumNf(.T.,cSerieNFS,cNumNFs,lECF,cSerieId,cTypeDoc)
				EndIf
			EndIf
		EndIf
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Inicio da Transacao                                                     ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If MaNfs2Nfs2(cSerOri,cNumOri,cClieFor,cLoja,cSerieNFS,cNumNFS,lLct610,lLct620,@nLctTotal,@nHdlPrv,lReajusta,nCalAcrs,nArredPrcLis,lAtuSA7,lECF,bFilSD2,bSD2,bSF2,aDocOri,aItemOri,aSF2,lNoFiscal,bFiscalSF2,bFiscalSD2,bFatSE1,@aLancCtb,lGTPSub,cTpOper,cTypeDoc)
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Termino da Transacao                                                    ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			Eval(bTTS)
		Else
			cNumNFS := ""
		EndIf
	End Transaction
	If lNewInvoic .And. lUnlockD9
		//Atualiza o status no controle de numeração 
		backoffice.fat.documento.UnLockInvoice()
	EndIf
	While __lSx8
		ConfirmSx8()
	EndDo
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Contabiliza os Lancamentos Contabeis                                    ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If ( nLctTotal <> 0 )
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Retirado controle de transação deste ponto , este controle
		//  é já está dentro da função cA100Incl.
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		RodaProva(nHdlPrv,nLctTotal)
		cA100Incl(cArquivo,nHdlPrv,3,cLote,lMostraCtb,lAglutCtb,,,,aLancCtb)
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Finaliza a gravacao dos lancamentos do SIGAPCO            ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	PcoFinLan("000101")

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Integracao com o modulo ACD - Analisa a rotina e o tipo da NF para verificar se faz o	³
	//³	acerto das tabelas para devolucao ou para NF normal		  								³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lIntACD
		CBM460FIM()
	EndIf

	If aEntry[EP_M460FIMT]
	ExecTemplate("M460FIM",.F.,.F.)
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Agroindustria                                                                                                                                                           ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If _lOGXUtOrig //Encontra a função
		If OGXUtlOrig() //Verifica se existe
			If _lOGX155
				OGX155()
			EndIf
		EndIf
	EndIf

	If AllTrim(Upper(SF2->F2_ESPECIE)) == "CTEOS" .And. FindFunction("G001INIGZH")
		G001INIGZH(SF2->F2_DOC,SF2->F2_SERIE,SF2->F2_CLIENTE,SF2->F2_LOJA)
	EndIf

	If aEntry[EP_M460FIM]
		ExecBlock("M460FIM",.F.,.F.,{cNumNFS,cSerieNFS,cClieFor,cLoja})
	EndIf
EndIf

RestArea(aArea)

Return( cNumNFS )
/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³MaNfs2Nfs2³ Autor ³Eduardo Riera          ³ Data ³28.08.1999³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Rotina de preparacao do documento de saida atraves de outro ³±±
±±³          ³documento de saida.                                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpC1: Serie do Documento de Origem                         ³±±
±±³          ³ExpC2: Numero do Documento de Origem                        ³±±
±±³          ³ExpC3: Cliente/Fornecedor do documento do origem            ³±±
±±³          ³ExpC4: Loja do Documento de origem                          ³±±
±±³          ³ExpC5: Serie do Documento a ser gerado                      ³±±
±±³          ³ExpC6: Numero do documento a ser gerado                     ³±±
±±³          ³ExpL7: Lancamento padrao 610                           (OPC)³±±
±±³          ³ExpL8: Lancamento padrao 620                           (OPC)³±±
±±³          ³ExpN9: Controle do Total Contabilizado                 (OPC)³±±
±±³          ³ExpNA: Handle do arquivo de contabilizacao             (OPC)³±±
±±³          ³ExpLB: Reajuste de preco na nota fiscal                (OPC)³±±
±±³          ³ExpNC: Tipo de Acrescimo Financeiro                    (OPC)³±±
±±³          ³ExpND: Tipo de Arredondamento                          (OPC)³±±
±±³          ³ExpLE: Atualiza Amarracao Cliente x Produto            (OPC)³±±
±±³          ³ExplF: Cupom Fiscal                                    (OPC)³±±
±±³          ³ExpBG: CodeBlock a ser executado para o SD2            (OPC)³±±
±±³          ³ExpBH: Filtragem do SD2                                (OPC)³±±
±±³          ³ExpBI: CodeBlock a ser executado para o SF2            (OPC)³±±
±±³          ³ExpAJ: Array com os Recnos do SF2                      (OPC)³±±
±±³          ³       Deve possuir o mesmo tamanho da ExpAl           (OPC)³±±
±±³          ³ExpAL: Array com os itens do SD2                       (OPC)³±±
±±³          ³       [1] Item do SD2                                 (OPC)³±±
±±³          ³       [2] Conteudo dos campos na ordem da estrutura   (OPC)³±±
±±³          ³ExpAN: Calculo Fiscal                                  (OPC)³±±
±±³          ³       Desabilita o calculo fiscal pois as informacoes ja   ³±±
±±³          ³       foram passadas nos campos do SD2 e SF2.              ³±±
±±³          ³ExpAO: Codigo do cliente de Entrega para calculo dos impos- ³±±
±±³          ³       tos.                                                 ³±±
±±³          ³ExpAP: Codigo da loja de Entrega para calculo dos impostos  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³   DATA   ³ Programador   ³Manutencao Efetuada                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³               ³                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function MaNfs2Nfs2(cSerOri,cNumero,cClieFor,cLoja,cSerieNFS,cNumNFS,lLct610,lLct620,nLctTotal,nHdlPrv,lReajusta,nCalAcrs,nArredPrcLis,lAtuSA7,lECF,bFilSD2,bSD2,bSF2,aDocOri,aItemOri,aSF2,lNoFiscal,bFiscalSF2,bFiscalSD2,bFatSE1,aLancCtb,lGTPSub,cTpOper,cTypeDoc)

Local aArea      := GetArea()
Local aAreaSF2   := SF2->(GetArea())
Local aAreaSD2   := SD2->(GetArea())
Local aStruSD2   := SD2->(dbStruct())
Local aStruSF2   := SF2->(dbStruct())
Local aSD2       := {}
Local aRegSD2    := {}
Local aTitulo    := { 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0, 0, 0, 0, 0, 0, 0, 0, 0}
Local aLockSF2   := {}
Local aLockSB2   := {}
Local aLockSA1   := {}
Local aLockSA2   := {}
Local aVldSF2    := {}
Local cBanco     := ""
Local nMoeda     := 1
Local cAliasSB1  := "SB1"
Local cAliasSD2  := "SD2"
Local cAliasSF4  := "SF4"
Local cAliasSE1  := "SE1"
Local cAliasSB6  := "SB6"
Local cItemSD2   := ""
Local cEstado    := ""
Local lFirst     := .F.
Local lRetorno   := .F.
Local lValido    := .F.
Local nItemNf    := IIf(FUNNAME() != "TMSA200", a460NumIt(cSerieNFS) , 99 )  //Caso venha da rotina de calculo de frete(TMS), pega valor DEFAULT do parametro (99)
Local nX         := 0
Local nY         := 0
Local nZ         := 0
Local nItensSD2  := 0
Local nSldSB6    := 0
Local nQtdSB6    := 0
//-- Tratamento para geracao da guia de recolhimento ICMS Proprio
Local nValICM    := 0
Local nMes       := 0
Local nAno       := 0
Local nVlrIcm    := 0
Local aGNRE      := {}
Local aRecTit    := {}
Local aDatas     := {}
Local aDSF2      := {}
Local dDtIni     := Ctod("//")
Local dDtFim     := Ctod("//")
Local dDtVenc    := Ctod("//")
Local lGRecICMS  := .F.
Local lLancCont  := .F.
Local lConfTit   := .F.
Local lTitICMS   := .F.
Local cUFOrigem  := ""
Local cLcPadTit  := ""
Local nThreads   := SuperGetMv("MV_TMSTHRC", , 0) // Numero de threads para processamento simultaneos
Local nDedICM    := 0
Local nPItem     := aScan(aStruSD2,{|x| AllTrim(x[1]) == "D2_ITEM"  })
Local nPDescon   := aScan(aStruSD2,{|x| AllTrim(x[1]) == "D2_DESCON"})
Local nPQuant    := aScan(aStruSD2,{|x| AllTrim(x[1]) == "D2_QUANT"})
Local nPPrcVen   := aScan(aStruSD2,{|x| AllTrim(x[1]) == "D2_PRCVEN"})
Local nPTotal    := aScan(aStruSD2,{|x| AllTrim(x[1]) == "D2_TOTAL"})
Local nPQtSegum  := aScan(aStruSD2,{|x| AllTrim(x[1]) == "D2_QTSEGUM"})
Local nPIdentB6  := aScan(aStruSD2,{|x| AllTrim(x[1]) == "D2_IDENTB6"})
Local nPLoteCtl  := aScan(aStruSD2,{|x| AllTrim(x[1]) == "D2_LOTECTL"})
Local nPNumLote  := aScan(aStruSD2,{|x| AllTrim(x[1]) == "D2_NUMLOTE"})
Local nPDtValid  := aScan(aStruSD2,{|x| AllTrim(x[1]) == "D2_DTVALID"})
Local nPPotenc   := aScan(aStruSD2,{|x| AllTrim(x[1]) == "D2_POTENCI"})
Local nPCliente  := aScan(aStruSD2,{|x| AllTrim(x[1]) == "D2_CLIENTE"})
Local nPLoja     := aScan(aStruSD2,{|x| AllTrim(x[1]) == "D2_LOJA"})
Local nPTipo     := aScan(aStruSD2,{|x| AllTrim(x[1]) == "D2_TIPO"})
Local nPDoc      := aScan(aStruSD2,{|x| AllTrim(x[1]) == "D2_DOC"})
Local nPSerie    := aScan(aStruSD2,{|x| AllTrim(x[1]) == "D2_SERIE"})
Local nPProduto  := aScan(aStruSD2,{|x| AllTrim(x[1]) == "D2_COD"})
Local nPNumSeq   := Ascan(aStruSD2,{|x| AllTrim(x[1]) == "D2_NUMSEQ"})
Local nPLocal    := aScan(aStruSD2,{|x| AllTrim(x[1]) == "D2_LOCAL"})
Local nPTES      := aScan(aStruSD2,{|x| AllTrim(x[1]) == "D2_TES"})
Local nPEstDest  := Ascan(aStruSD2,{|x| AllTrim(x[1]) == "D2_EST"})
Local nPEstado   := Ascan(aStruSF2,{|x| AllTrim(x[1]) == "F2_EST"})
Local nItemNF2   := 1
Local cMV_B1M996 := SuperGetMV ("MV_B1M996",, "")
Local cB1M996    := ""
Local cB1FRETISS := ""
Local cTpNrNfs   := SuperGetMV("MV_TPNRNFS")
Local aTransp    := {"",""}
Local lMvAtuComp := SuperGetMV("MV_ATUCOMP",,.F.)
Local lIntTms    := SuperGetMV("MV_INTTMS",,.F.)
Local cMvCfLTran := SuperGetMv("MV_CFLTRAN",.F.,"")
Local cMvCfLTra1	:= SuperGetMv("MV_CFLTRA1",.F.,"")
Local cMvCfLTra2	:= SuperGetMv("MV_CFLTRA2",.F.,"")
Local cMvCfLTra3	:= SuperGetMv("MV_CFLTRA3",.F.,"")
Local xAlqLeiTr  := 0                                            // valor da  aliquota retornado pela função fiscal (Lei transparência)
Local aAlqLeiTr  := {}												  // array com valores da  aliquota retornado pela função fiscal (Lei transparência) 1-Aliq Total|2-Aliq Federal|3-Aliq Estadual|4-Aliq Municipal
Local nTotAlq    := 0                                            // valor total da  aliquota a ser gravada no campo D2_TOTIMP
Local cMvFisCTrb := SuperGetMv("MV_FISCTRB",.F.,"1")            // método de consulta do percentual de carga tributária.Informe 1 para tratamento legado ou 2 alíquotas da Nota Fiscal e CGA/CGB - #conteudo gravado no campo D2_TIPIMP
Local cMvFisAlCT := SuperGetMv("MV_FISALCT",.F.,"3")            // Informar qual o método de composição da carga tributária quando MV_FISCTRB = 2.
Local lMvFisFRas := SuperGetMv("MV_FISFRAS",.F.,.F.)            // Indica se utilizara a rastreabilidade no faturamento para preenchimento dos campos que necessitam desta funcionalidade
Local nTotCargT  := 0
Local aTimeUf	 := {}
Local aAreaSM0	 := {}
Local aAreaTime	 := {}
Local cHoraRMT	 := SuperGetMv("MV_HORARMT",.F.)
Local lUsaNewKey := GetSx3Cache("F2_SERIE","X3_TAMANHO") == 14 // Verifica se o novo formato de gravacao do Id nos campos _SERIE esta em uso
Local cSerieId   := IIf( lUsaNewKey , SerieNfId("SF2",4,"F2_SERIE",dDataBase,A460Especie(cSerieNFS),cSerieNFS) , cSerieNFS )
Local nTotFed  	:= 0												  // valor total da  aliquota Fedral
Local nTotEst  	:= 0												  // valor total da  aliquota Estadual
Local nTotMun	  	:= 0												  // valor total da  aliquota Municipal
Local nAlqFed		:= 0                                            // valor total do item da  aliquota Fedral
Local nAlqEst		:= 0                                            // valor total do item da  aliquota Estadual
Local nAlqMun		:= 0 												  // valor total do item da  aliquota Municipal
Local nVDifal	   := 0
Local nVFCDif	   := 0
Local nValICMP   := 0
Local lGDifal    := .F.
Local lGFcpDif   := .F.
Local aStruSB6   := {}
Local aStruSE1   := {}
Local cQuery     := ""

Local cTMSMFat	:= SuperGetMv("MV_TMSMFAT")
Local lMVIntTur	:= SuperGetMV("MV_INTTUR",,.F.)
Local lCat8309	:= SuperGetMV("MV_CAT8309",,.T.)
Local lD2CtaRec := SD2->(ColumnPos("D2_CTAREC")) > 0 //Valida se o campo D2_CTAREC existe para gravar a Conta de Receita - EFD Contribuições
Local cCtaRec	:= "" //Conta de Receita do Item - EFD Contribuições
Local lFmpeq   	:= (SE1->(ColumnPos("E1_FMPEQ")) > 0) .And. (SF3->(ColumnPos("F3_VALFMP")) > 0)
Local lFamad   	:= (SE1->(FieldPos("E1_FAMAD")) > 0) .And. (SF3->(FieldPos("F3_VALFMD")) > 0) 
Local lIma		:= (SE1->(ColumnPos("E1_IMA")) > 0) .And. (SF3->(ColumnPos("F3_VALIMA")) > 0) .And. !Empty(MaFisScan("IT_VALIMA",.F.))
Local cMVTmsGnre:= SuperGetMV("MV_TMSGNRE",,"")
Local lTrbGen   := IIf(_lChkTrbGen, ChkTrbGen("SD2","D2_IDTRIB"), .F.)
Local nValICMSST:= 0
Local lFisNewLT	:= .F.
Local nVlCRDTran:= 0
Local cTMSERP   := SuperGetMv("MV_TMSERP",,"0")
Local nRecnoOri	:= 0
Local lCtrAtu   := !(SuperGetMV("MV_NFS_JOB",,.F.) )
Local lMat511b	:= IsInCallStack("Ma511RjPro")
Local cCposVal	:= "F2_USERLGI/F2_USERLGA"
Local lNewInvoic 	:= Iif(__RpoRelease >= '12.1.2410',;
						 tlpp.ffunc("backoffice.fat.documento.UsaNewInvoice") .And.;
						 tlpp.call('backoffice.fat.documento.UsaNewInvoice()'),.F.)

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Inicializa os parametros DEFAULT                                       ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
DEFAULT lLct610      := .F.
DEFAULT lLct620      := .F.
DEFAULT nLctTotal    := 0
DEFAULT lReajusta    := .F.
DEFAULT nCalAcrs     := 1
DEFAULT nArredPrcLis := 1
DEFAULT lAtuSA7      := .F.
DEFAULT lECF         := .F.
DEFAULT bSD2         := {|| .T.}
DEFAULT bFilSD2      := {|| .T.}
DEFAULT bSF2         := {|| .T.}
DEFAULT aDocOri      := {}
DEFAULT aItemOri     := {}
DEFAULT aSF2         := {}
DEFAULT lNoFiscal    := .F.
DEFAULT bFatSE1      := {|| .T. }
DEFAULT aLancCtb     := {}
DEFAULT lGTPSub		 := .F.
DEFAULT cTpOper		 := ""
DEFAULT cTypeDoc	 := ""

If ( Type("aNatRend") == "U" )
	aNatRend := Array(4)
EndIf

If ValType(cHoraRMT) == "L"
	If cHoraRMT
		cHoraRMT := "1"
	Else
		cHoraRMT := "2"
	EndIf
Else
	If cHoraRMT == NIL
		cHoraRMT := "2"
	EndIf
EndIf

//Limpa os impostos em caso de documentos do tipo de complemento do MATA511B
If lMat511b
	cCposVal +='/F2_VALBRUT/F2_VALFAT/F2_VALICM/F2_BASEICM/F2_VALIPI/F2_BASEIPI/F2_ICMSRET/F2_BASEISS/F2_VALISS'
	cCposVal +='/F2_BRICMS/F2_ICMAUTO/F2_VALINSS/F2_BASEINS/F2_VALIMP1/F2_VALIMP2/F2_VALIMP3/F2_VALIMP4/F2_VALIMP5
	cCposVal +='/F2_VALIMP6/F2_VALPIS/F2_VALIRRF/F2_BASIMP1/F2_BASIMP2/F2_BASIMP3/F2_BASIMP4/F2_BASIMP5/F2_BASIMP6'
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Analisa os itens do documento - Origem                                 ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If Empty(aItemOri)
	nY := 0
	dbSelectArea("SD2")
	dbSetOrder(3)

	cAliasSD2 := "MANFS2NFS"
	cQuery := ""
	For nX := 1 To Len(aStruSD2)
		cQuery += ","+aStruSD2[nX][1]
	Next nX
	cQuery := "SELECT SF2.R_E_C_N_O_ SF2RECNO,F2_REAJUST "+cQuery+" "
	cQuery += "FROM "+RetSqlName("SD2")+" SD2,"
	cQuery += RetSqlName("SF2")+" SF2 "
	cQuery += "WHERE SF2.F2_FILIAL='"+xFilial("SF2")+"' AND "
	cQuery += "SF2.F2_SERIE='"+cSerOri+"' AND "
	cQuery += "SF2.F2_DOC='"+cNumero+"' AND "
	cQuery += "SF2.F2_CLIENTE='"+cClieFor+"' AND "
	cQuery += "SF2.F2_LOJA='"+cLoja+"' AND "
	cQuery += "SF2.D_E_L_E_T_=' ' AND "
	cQuery += "SD2.D2_FILIAL='"+xFilial("SD2")+"' AND "
	cQuery += "SD2.D2_SERIE=SF2.F2_SERIE AND "
	cQuery += "SD2.D2_DOC=SF2.F2_DOC AND "
	cQuery += "SD2.D2_CLIENTE=SF2.F2_CLIENTE AND "
	cQuery += "SD2.D2_LOJA=SF2.F2_LOJA AND "
	cQuery += "SD2.D_E_L_E_T_=' ' "
	cQuery += "ORDER BY "+SqlOrder(SD2->(IndexKey()))
	cQuery := ChangeQuery(cQuery)
	dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasSD2,.T.,.T.)
	For nX := 1 To Len(aStruSD2)
		If aStruSD2[nX][2]<>"C"
			TcSetField(cAliasSD2,aStruSD2[nX][1],aStruSD2[nX][2],aStruSD2[nX][3],aStruSD2[nX][4])
		EndIf
	Next nX
	While !Eof() .And. xFilial("SD2") == (cAliasSD2)->D2_FILIAL .And.;
			cNumero == (cAliasSD2)->D2_DOC .And.;
			cSerOri == (cAliasSD2)->D2_SERIE .And.;
			cClieFor == (cAliasSD2)->D2_CLIENTE .And.;
			(cAliasSD2)->D2_LOJA == cLoja

		dbSelectArea("SF4")
		dbSetOrder(1)
		MsSeek(xFilial("SF4")+(cAliasSD2)->D2_TES)

		dbSelectArea("SB1")
		dbSetOrder(1)
		MsSeek(xFilial("SB1")+(cAliasSD2)->D2_COD)

		If Eval(bFilSD2,cAliasSD2,"SF4","SB1",(cAliasSD2)->F2_REAJUST)
			nY++
			aadd(aDocOri,(cAliasSD2)->SF2RECNO)
			aadd(aItemOri,{})
			For nX := 1 To Len(aStruSD2)
				aadd(aItemOri[nY],(cAliasSD2)->(FieldGet(FieldPos(aStruSD2[nX][1]))))
			Next nX
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Chamada do CodeBlock para alteracao do SD2                             ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			Eval(bSD2,1,@aItemOri[nY],cAliasSD2,cAliasSF4,cAliasSB1)
		EndIf
		(cAliasSD2)->( DBSkip() )
	EndDo

	(cAliasSD2)->( DBCloseArea() )
	DBSelectArea("SD2")

EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Ordena os Itens do documento por: Tipo+Cliente+Loja+Serie+Documento    ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
aItemOri := aSort(aItemOri,,,{|x,y| x[nPTipo]+x[nPCliente]+x[nPLoja]+x[nPSerie]+x[nPDoc]+x[nPItem] < ;
	y[nPTipo]+y[nPCliente]+y[nPLoja]+y[nPSerie]+y[nPDoc]+y[nPItem]})
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Tratamento para Dead-Lock                                              ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
For nX := 1 To Len(aItemOri)
	If aScan(aLockSB2,aItemOri[nX][nPProduto]+aItemOri[nX][nPLocal])==0
		If ( ( lIntTms .And. nModulo == 43 .And. nPTES > 0 ) .Or. nModulo == 89 )
			SF4->(DbSetOrder(1))
			If SF4->(DbSeek(xFilial("SF4")+aItemOri[nx][nPTES])) .And. SF4->F4_ESTOQUE == "S"
				aadd(aLockSB2,aItemOri[nX][nPProduto]+aItemOri[nX][nPLocal])
			EndIf
		Else
			aadd(aLockSB2,aItemOri[nX][nPProduto]+aItemOri[nX][nPLocal])
		EndIf
	EndIf
	If aScan(aLockSF2,aItemOri[nX][nPDoc]+aItemOri[nX][nPSerie]+aItemOri[nX][nPCliente]+aItemOri[nX][nPLoja])==0
		aadd(aLockSF2,aItemOri[nX][nPDoc]+aItemOri[nX][nPSerie]+aItemOri[nX][nPCliente]+aItemOri[nX][nPLoja])
	EndIf

	If aItemOri[nX][nPTipo]$"DB"
		If aScan(aLockSA2,aItemOri[nX][nPCliente]+aItemOri[nX][nPLoja])==0
			aadd(aLockSA2,aItemOri[nX][nPCliente]+aItemOri[nX][nPLoja])
		EndIf
	Else
		If aScan(aLockSA1,aItemOri[nX][nPCliente]+aItemOri[nX][nPLoja])==0
			aadd(aLockSA1,aItemOri[nX][nPCliente]+aItemOri[nX][nPLoja])
		EndIf
	EndIf
Next nX
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Tratamento para Dead-Lock                                              ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If Iif(!SuperGetMv("MV_NFS_JOB",,.F.),MultLock("SB2",aLockSB2,1), .T.) .And. If(Len(aLockSA1) > 1,MultLock("SA1",aLockSA1,1),.T.) .And. If(Len(aLockSA2) > 1,MultLock("SA2",aLockSA2,1),.T.) .And. If(Len(aLockSF2) > 1,MultLock("SF2",aLockSF2,3),.T.)

	For nItensSD2 := 1 To Len(aItemOri)
		aadd(aSD2,aClone(aItemOri[nItensSD2]))
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Verifica-se a Quebra do documento Fiscal                               ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		nX := nItensSD2+1
		nY := nItensSD2
		If nX > Len(aItemOri) .Or. aItemOri[nX][nPTipo]+;
				aItemOri[nX][nPCliente]+aItemOri[nX][nPLoja]+;
				aItemOri[nX][nPDoc]+aItemOri[nX][nPSerie]<>;
				aItemOri[nY][nPTipo]+;
				aItemOri[nY][nPCliente]+aItemOri[nY][nPLoja]+;
				aItemOri[nY][nPDoc]+aItemOri[nY][nPSerie]
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Posiciona no Documento de Origem                                       ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If (aDocOri[nItensSD2]) <> 0
				SF2->(MsGoto(aDocOri[nItensSD2]))
				If !Empty(SF2->F2_NEXTDOC)
					If aScan(aVldSF2,aDocOri[nItensSD2]) <> 0
						lValido := .T.
					Else
						lValido := .F.
					EndIf
				Else
					lValido := .T.
					aadd(aVldSF2,aDocOri[nItensSD2])
				EndIf
			Else
				lValido := .T.
			EndIf
			If lValido
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Atualiza o Documento com o Numero do Proximo Documento de Saida        ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If Empty(cNumNFS)
					// Obtem numero do documento dentro da transacao
					SX3->(dbSetOrder(1))
					If (SX3->(dbSeek("SD9"))) .And. cTpNrNfs == "3"
						cNumNFS := MA461NumNf(.T.,cSerieNFS,NIL,lECF,cSerieId,cTypeDoc)
					Else
						cNumNFS := NxtSX5Nota( cSerieNFS,.T.,cTpNrNfs,,,, cSerieId,,cTypeDoc) // O parametro cSerieId deve ser passado para funcao NxtSx5Nota afim de tratar a existencia ou nao do mesmo numero na funcao VldSx5Num do MATXFUNA.PRX
					EndIf
				EndIf
				If aDocOri[nItensSD2] <> 0
					RecLock("SF2")
					If Empty(SF2->F2_NEXTDOC)
						SF2->F2_NEXTDOC := cNumNFS
						SerieNfId("SF2",1,"F2_NEXTSER",dDataBase,Iif(lNewInvoic .And.!Empty(cTypeDoc),cTypeDoc,A460Especie(cSerieNFS)),cSerieNFS)
					Else
						SF2->F2_NEXTDOC := Repl("X",Len(cNumNFS))
						SF2->F2_NEXTSER := Repl("X",Len(SF2->F2_NEXTSER))
					EndIf
					MsUnLock()
				EndIf
			EndIf
		EndIf
		If lValido .And. (nX > Len(aItemOri) .Or. aItemOri[nX][nPTipo]+;
				aItemOri[nX][nPCliente]+aItemOri[nX][nPLoja]<>;
				aItemOri[nY][nPTipo]+;
				aItemOri[nY][nPCliente]+aItemOri[nY][nPLoja])
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Inicia a gravacao dos documentos de saida                              ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			cItemSD2 := StrZero(1,Len(SD2->D2_ITEM))
			nX       := 1
			nItemNF2 := 1
			While nX <= Len(aSD2)
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Analise do Documento de Origem                                         ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If Empty(cItemSD2) .Or. nItemNF2 == 1
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Inicializa a numeracao dos itens do documento de saida                 ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					cItemSD2 := StrZero(1,Len(SD2->D2_ITEM))
					If Empty(cNumNFS)
						// Obtem numero do documento dentro da transacao
						SX3->(dbSetOrder(1))
						If (SX3->(dbSeek("SD9"))) .And. cTpNrNfs == "3"
							cNumNFS := MA461NumNf(.T.,cSerieNFS,NIL,lECF,cSerieId,cTypeDoc)
						Else
							cNumNFS := NxtSX5Nota( cSerieNFS,.T.,cTpNrNfs,,,, cSerieId,,cTypeDoc) // O parametro cSerieId deve ser passado para funcao NxtSx5Nota afim de tratar a existencia ou nao do mesmo numero na funcao VldSx5Num do MATXFUNA.PRX
						EndIf
					EndIf
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Posiciona no Documento de Origem                                       ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If aDocOri[nItensSD2] <> 0
						SF2->(MsGoto(aDocOri[nItensSD2]))
						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³ Verificando os titulos a receber                                       ³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						If !Empty(SF2->F2_DUPL)
							dbSelectArea("SE1")
							dbSetOrder(2)

							aStruSE1 := SE1->(dbStruct())
							cAliasSE1:= "MANFS2NFS_SE1"
							cQuery := "SELECT SE1.*,SE1.R_E_C_N_O_ SE1RECNO "
							cQuery += "FROM "+RetSqlName("SE1")+" SE1 "
							cQuery += "WHERE SE1.E1_FILIAL='"+xFilial("SE1")+"' AND "
							cQuery += "SE1.E1_PREFIXO='"+SF2->F2_PREFIXO+"' AND "
							cQuery += "SE1.E1_NUM='"+SF2->F2_DUPL+"' AND "
							cQuery += "SE1.E1_CLIENTE='"+cClieFor+"' AND "
							cQuery += "SE1.E1_LOJA='"+cLoja+"' AND "
							cQuery += "SE1.D_E_L_E_T_=' ' "
							cQuery := ChangeQuery(cQuery)
							dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasSE1,.T.,.T.)
							For nY := 1 To Len(aStruSE1)
								If aStruSE1[nY][2] <> "C"
									TcSetField(cAliasSE1,aStruSE1[nY][1],aStruSE1[nY][2],aStruSE1[nY][3],aStruSE1[nY][4])
								EndIf
							Next nY

							dbSelectArea(cAliasSE1)
							While ( (cAliasSE1)->( !Eof() ) .And. xFilial("SE1") == (cAliasSE1)->E1_FILIAL .And.;
									cClieFor == (cAliasSE1)->E1_CLIENTE .And.;
									cLoja == (cAliasSE1)->E1_LOJA .And.;
									SF2->F2_PREFIXO == (cAliasSE1)->E1_PREFIXO .And.;
									SF2->F2_DUPL == (cAliasSE1)->E1_NUM )
								If (cAliasSE1)->E1_TIPO $ MVNOTAFIS
									cBanco := (cAliasSE1)->E1_PORTADO
									nMoeda := (cAliasSE1)->E1_MOEDA
									Exit
								EndIf
								(cAliasSE1)->( DBSkip() )
							EndDo

							(cAliasSE1)->( DBCloseArea() )
							DBSelectArea("SE1")

						EndIf
						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³ Inicia a Gravacao do Cabecalho - SF2                                   ³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						aSF2 := {}
						For nY := 1 To Len(aStruSF2)
							aadd(aSF2,SF2->(FieldGet(FieldPos(aStruSF2[nY][1]))))
						Next nY
						RecLock("SF2",.T.)
						For nY := 1 To Len(aStruSF2)
							If !(aStruSF2[nY][1] $ cCposVal)
								FieldPut(nY,aSF2[nY])
							EndIf
						Next nY
					Else
						RecLock("SF2",.T.)
						For nY := 1 To Len(aStruSF2)
							If !(aStruSF2[nY][1] $ cCposVal)
								FieldPut(nY,aSF2[nY])
							EndIf
						Next nY
						cEstado := aSF2[nPEstado]
					EndIf
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³Posiciona Registros                                                     ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If  ( SF2->F2_TIPO $ "DB" )
						dbSelectArea("SA2")
						dbSetOrder(1)
						MsSeek(xFilial("SA2")+SF2->F2_CLIENTE+SF2->F2_LOJA)
						If Empty(cEstado)
							If SF2->F2_CLIENTE+SF2->F2_LOJA == aSD2[nX][nPCliente]+aSD2[nX][nPLoja]
								cEstado := SA2->A2_EST
							Else
								cEstado := aSD2[nX][nPEstDest]
							EndIf
						EndIf
					Else
						dbSelectArea("SA1")
						dbSetOrder(1)
						MsSeek(xFilial("SA1")+SF2->F2_CLIENTE+SF2->F2_LOJA)
						If Empty(cEstado)
							If SF2->F2_CLIENTE+SF2->F2_LOJA == aSD2[nX][nPCliente]+aSD2[nX][nPLoja]
								cEstado := SA1->A1_EST
							Else
								cEstado := aSD2[nX][nPEstDest]
							EndIf
						EndIf
					EndIf
					dbSelectArea("SA4")
					dbSetOrder(1)
					If SA4->(dbSeek(xFilial("SA4")+SF2->F2_TRANSP))
						aTransp[01] := SA4->A4_EST
						aTransp[02] := SA4->A4_TPTRANS
					Endif
					SF2->F2_NFORI   := SF2->F2_DOC
					SF2->F2_DOC     := cNumNFS
					SF2->F2_CLIENTE := aSD2[nX][nPCliente]
					SF2->F2_LOJA    := aSD2[nX][nPLoja]
					SF2->F2_TIPO    := aSD2[nX][nPTipo]
					SF2->F2_CARGA   := ""
					SF2->F2_SEQCAR  := ""
					SF2->F2_EST     := cEstado

					//Parametro MV_HORARMT habilitado pega a hora do smartclient, do servidor ou do Estado da Filial
					If cHoraRMT == "1" .And. cPaisLoc == "BRA"
						SF2->F2_EMISSAO    := dDataBase
						SF2->F2_HORA       := SubStr(GetRmtTime(),1,5)

					ElseIf cHoraRMT == "3"
						If cPaisLoc == "BRA"
							aArea2	:= GetArea()
							dbSelectArea("SM0")
							aAreaSM0	:= GetArea()
							dbSetOrder(1)
							If dbSeek(cEmpAnt+cFilAnt)
								aTimeUf := A103HORA()
							EndIf
							RestArea(aAreaSM0)
							RestArea(aArea2)

							SF2->F2_EMISSAO := aTimeUf[1]
							SF2->F2_HORA:= SubStr(aTimeUf[2],1,5)
						Else
							SF2->F2_EMISSAO:= dDataBase
							SF2->F2_HORA:= SubStr(GetRmtTime(),1,5)
						EndIf

					Else // 2- Default (data do servidor)
						SF2->F2_EMISSAO := dDataBase
						SF2->F2_HORA := SubStr(Time(),1,5)
					EndIf

					SerieNfId("SF2",1,"F2_SERIORI",SF2->F2_EMISSAO,Iif(lNewInvoic .And.!Empty(cTypeDoc),cTypeDoc,A460Especie(Substr(SF2->F2_SERIE,1,3))),SF2->F2_SERIE)
					
					SerieNfId("SF2",1,"F2_SERIE",SF2->F2_EMISSAO,Iif(lNewInvoic .And.!Empty(cTypeDoc),cTypeDoc,A460Especie(cSerieNFS)),cSerieNFS)

					SF2->F2_ESPECIE := Iif(lNewInvoic .And.!Empty(cTypeDoc),cTypeDoc,A460Especie(cSerieNFS))
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Complemento da gravacao do SF2                                         ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					Eval(bSF2,1)
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³Inicializa cabecalho da funcao fiscal                                   ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					MaFisSave()
					MaFisEnd()
					MaFisIni(SF2->F2_CLIENTE,SF2->F2_LOJA,IIF(SF2->F2_TIPO$'DB',"F","C"),SF2->F2_TIPO,SF2->F2_TIPOCLI,aRelImp,,,,'MATA461',,,,,,SF2->F2_CLIENT,SF2->F2_LOJENT,aTransp,,,,,,,,SF2->F2_TPFRETE,,,,,,,lTrbGen,Len(aSD2))
					If !Empty(SF2->F2_EST)
						If SF2->F2_TIPO$"DB"
							MaFisAlt("NF_UFORIGEM",SF2->F2_EST)
						Else
							MaFisAlt("NF_UFDEST",SF2->F2_EST)
						EndIf
					EndIf

					If lMVIntTur .AND. ( IsIncallStack("TA042EfNFS") .OR. IsIncallStack("TA45GerNFS") )
						MaFisLoad("NF_CODMUN",AllTrim( SM0->M0_CODMUN ))
					EndIf
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Carrega os valores da funcao fiscal (Total)                            ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					dbSelectArea("SF2")
					If !IsIncallStack("MA511P3DEV")
						For nY := 1 To Len(aRelImp)
							If aRelImp[nY][1] == "SF2"
								MaFisLoad(aRelImp[nY][3],SF2->(FieldGet(FieldPos(aRelImp[nY][2]))))
							EndIf
						Next nY
					EndIf
				Else
					cItemSD2 := Soma1(cItemSD2)
				EndIf

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Executa code block para tratamento do fiscal.                          ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If bFiscalSF2 <> NIL
					Eval(bFiscalSF2)
				EndIf

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Inicia a Gravacao do Cabecalho - SD2                                   ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				aSD2[nX,nPNumSeq] := SF4->(ProxNum())
				aSD2[nX,nPDoc]    := cNumNFS
				aSD2[nX,nPSerie]  := cSerieNFS
				aSD2[nX,nPItem]   := cItemSD2
				RecLock("SD2",.T.)
				For nY := 1 To Len(aSD2[nX])
					FieldPut(nY,aSD2[nX][nY])
				Next nY
				SD2->D2_IDENTB6 := IIf(SD2->D2_TIPO$"CIP",SD2->D2_IDENTB6,aItemOri[nX][nPIdentB6])
				//-- Tratamento do parâmetro MV_HORARMT
				If cHoraRMT == "3" .And. cPaisLoc == "BRA"
					aAreaTime	:= GetArea()
					dbSelectArea("SM0")
					aAreaSM0	:= GetArea()
					dbSetOrder(1)

					If dbSeek(cEmpAnt+cFilAnt)
						aTimeUf := A103HORA()
					EndIf

					RestArea(aAreaSM0)
					RestArea(aAreaTime)

					SD2->D2_EMISSAO := aTimeUf[1]
				Else
					//-- cHoraRMT == "2" .Or. cHoraRMT == "1" .Or. cPaisLoc <> "BRA", todas essas condições gravam o dDataBase, pois a hora não recebe tratamento nos itens
					SD2->D2_EMISSAO := dDataBase
				EndIf

				SerieNfId("SD2",1,"D2_SERIE",SD2->D2_EMISSAO,Iif(lNewInvoic .And.!Empty(cTypeDoc),cTypeDoc,A460Especie(cSerieNFS)),cSerieNFS)

				//-- Tratamento para grava o percentual da comissão para TMS
				If nModulo == 43
					If !Empty(SA1->A1_VEND)
						If !Empty(SA1->A1_COMIS)
							SD2->D2_COMIS1 := SA1->A1_COMIS
						Else
							SD2->D2_COMIS1 := Posicione("SA3", 1, xFilial("SA3") + SA1->A1_VEND, "A3_COMIS")
						EndIf
					Endif
				EndIf

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Verifica o Poder de terceiros                                          ³
				//³                                                                        ³
				//³ Neste ponto sera realizado o FIFO do poder de terceiro caso nao seja   ³
				//³ informado a rotina qual identificador deve ser utilizado para o retorno³
				//³ do material                                                            ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If Empty(SD2->D2_IDENTB6)
					dbSelectArea("SF4")
					dbSetOrder(1)
					MsSeek(xFilial("SF4")+SD2->D2_TES)
					If SF4->F4_PODER3=="D"
						nSldSB6    := 0
						nQtdSB6    := SD2->D2_QUANT
						lFirst     := .T.

						dbSelectArea("SB6")
						dbSetOrder(2)

						cAliasSB6 := "MANFS2NFS_SB6"
						aStruSB6  := SB6->(dbStruct())
						cQuery := "SELECT * "
						cQuery += "FROM "+RetSqlName("SB6")+" SB6 "
						cQuery += "WHERE SB6.B6_FILIAL='"+xFilial("SB6")+"' AND "
						cQuery += "SB6.B6_PRODUTO='"+SD2->D2_COD+"' AND "
						cQuery += "SB6.B6_CLIFOR='"+SD2->D2_CLIENTE+"' AND "
						cQuery += "SB6.B6_LOJA='"+SD2->D2_LOJA+"' AND "
						cQuery += "SB6.B6_PODER3='R' AND "
						cQuery += "SB6.B6_TPCF='"+IIf(SD2->D2_TIPO$"DB","F","C")+"' AND "
						cQuery += "SB6.D_E_L_E_T_=' ' "
						cQuery += "ORDER BY "+SqlOrder(SB6->(IndexKey()))
						cQuery := ChangeQuery(cQuery)
						dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasSB6,.T.,.T.)
						For nZ := 1 To Len(aStruSB6)
							If aStruSB6[nZ][2]<>"C"
								TcSetField(cAliasSB6,aStruSB6[nZ][1],aStruSB6[nZ][2],aStruSB6[nZ][3],aStruSB6[nZ][4])
							EndIf
						Next nZ
						While (cAliasSB6)->( !Eof() ) .And. (cAliasSB6)->B6_FILIAL == xFilial("SB6") .And.;
								(cAliasSB6)->B6_PRODUTO == SD2->D2_COD .And.;
								(cAliasSB6)->B6_CLIFOR == SD2->D2_CLIENTE .And.;
								(cAliasSB6)->B6_LOJA == SD2->D2_LOJA .And.;
								(cAliasSB6)->B6_PODER3 == 'R' .And. nQtdSB6 > 0

							If (cAliasSB6)->B6_TPCF == IIf(SD2->D2_TIPO$"DB","F","C")

								//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
								//³ Verifica o saldo o poder de terceiro                                   ³
								//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
								nSldSB6 := Min((cAliasSB6)->B6_SALDO - (cAliasSB6)->B6_QULIB,nQtdSB6)

								If nSldSB6 > 0
									//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
									//³ Posiciona Registros                                                    ³
									//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
									dbSelectArea("SD1")
									dbSetOrder(4)
									MsSeek(xFilial("SD1")+(cAliasSB6)->B6_IDENT)
									//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
									//³ Ajusta o Documento de Saida para a quantidade em poder de terceiro     ³
									//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
									If lFirst
										SD2->D2_DESCON  := A410Arred(SD1->D1_VALDESC/SD1->D1_QUANT*nSldSB6,"D2_DESCON")
										SD2->D2_QUANT   := nSldSB6
										SD2->D2_PRCVEN  := A410Arred((SD1->D1_TOTAL-SD1->D1_VALDESC)/SD1->D1_QUANT,"D2_PRCVEN")
										SD2->D2_TOTAL   := A410Arred(SD2->D2_QUANT*SD2->D2_PRCVEN,"D2_TOTAL")
										SD2->D2_QTSEGUM := SF4->(ConvUm(SD2->D2_COD,SD2->D2_QUANT,0,2))
										SD2->D2_IDENTB6 := (cAliasSB6)->B6_IDENT
										SD2->D2_NFORI   := SD1->D1_DOC
										SerieNfId("SD2",1,"D2_SERIORI",,,, SD1->D1_SERIE)
										SD2->D2_ITEMORI := SD1->D1_ITEM
										SD2->D2_LOCAL   := (cAliasSB6)->B6_LOCAL
										SD2->D2_LOTECTL := SD1->D1_LOTECTL
										SD2->D2_NUMLOTE := SD1->D1_NUMLOTE
										SD2->D2_DTVALID := SD1->D1_DTVALID
										SD2->D2_POTENCI := SD1->D1_POTENCI

										nQtdSB6 -= SD2->D2_QUANT
										lFirst := .F.
									Else
										aadd(aSD2,aClone(aSD2[nX]))
										aSD2[Len(aSD2)][nPDescon ] := A410Arred(SD1->D1_VALDESC/SD1->D1_QUANT*nSldSB6,"D2_DESCON")
										aSD2[Len(aSD2)][nPQuant  ] := nSldSB6
										aSD2[Len(aSD2)][nPTotal  ] := A410Arred(aSD2[Len(aSD2)][nPQuant]*aSD2[Len(aSD2)][nPPrcVen],"D2_TOTAL")
										aSD2[Len(aSD2)][nPQtSegum] := SF4->(ConvUm(SD2->D2_COD,aSD2[Len(aSD2)][nPQuant],0,2))
										aSD2[Len(aSD2)][nPIdentB6] := (cAliasSB6)->B6_IDENT
										aSD2[Len(aSD2)][nPLoteCtl] := SD1->D1_LOTECTL
										aSD2[Len(aSD2)][nPNumLote] := SD1->D1_NUMLOTE
										aSD2[Len(aSD2)][nPDtValid] := SD1->D1_DTVALID
										aSD2[Len(aSD2)][nPPotenc]  := SD1->D1_POTENCI

										nQtdSB6 -= aSD2[Len(aSD2)][nPQuant]
									EndIf
								EndIf
							EndIf
							(cAliasSB6)->( DBSkip() )
						EndDo

						(cAliasSB6)->( DBCloseArea() )
 						DBSelectArea("SB6")

					EndIf
				EndIf
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Atualiza CAT/83                                         ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If lCat8309
					SD2->D2_CODLAN := IIF(SD2->D2_TES == SF4->F4_CODIGO,SF4->F4_CODLAN,Posicione("SF4",1,xFilial("SF4")+SD2->D2_TES,"F4_CODLAN"))
				EndIf

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Complemento da gravacao do SD2                                         ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				Eval(bSD2,2,aSD2)
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Carga do Funcao fiscal para o Item                                     ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If Alltrim(SD2->D2_TIPO) == "D"
					dbSelectArea("SD1")
					dbSetOrder(1)
					If ( MsSeek(xFilial()+SD2->D2_NFORI+SD2->D2_SERIORI+SD2->D2_CLIENTE+SD2->D2_LOJA+SD2->D2_COD) )
						MaFisIniLoad(nItemNf2,{Space(Len(SD2->D2_COD)), ,,0,,,0,0,SD1->(RecNo()),,},.T.)
					EndIf
				Else
					//Validar se for substituição do GTP, caso contrario segue o que já estava antes
					If lGTPSub
						MaFisIniLoad(nItemNf2,{Space(Len(SD2->D2_COD)),"","",0,,,0,0,0,"","","",0,cTpOper},.T.)
					Else
						MaFisIniLoad(nItemNf2,Nil,.T.)
					Endif
				EndIf
				For nZ := 1 To Len(aRelImp)
					If aRelImp[nZ][1] == "SD2"
						MaFisLoad(aRelImp[nZ][3],SD2->(FieldGet(FieldPos(aRelImp[nZ][2]))),nItemNF2)
					EndIf
				Next nZ
				MaFisEndLoad(nItemNf2,2)
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Tratamento para Legislação de Carga Tributária - Lei nº 12.741/2012 (Lei da Transparência)        ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If nModulo <> 43  .And. !(AllTrim(SD2->D2_CF) $ cMvCfLTran +"/"+ cMvCfLTra1 +"/"+ cMvCfLTra2  +"/"+ cMvCfLTra3)
					If SF2->F2_TIPOCLI == "F"  // Legislação aplicada apenas para cliente consumidor final
						// Função Fiscal para retorno da carga trubutária
						xAlqLeiTr := AlqLei2741(SB1->B1_POSIPI,SB1->B1_EX_NCM,SB1->B1_CODISS,SF2->F2_EST,SA1->A1_COD_MUN,SC9->C9_PRODUTO,nItemNF2,SC9->C9_NUMLOTE,SC9->C9_LOTECTL,cMvFisCTrb, cMvFisAlCT,lMvFisFRas,SF2->F2_TIPO)

						If ValType(xAlqLeiTr) == "N"
							aAlqLeiTr := {xAlqLeiTr,0,0,0}
						Else
							aAlqLeiTr := aClone(xAlqLeiTr)
						EndIf

						if _xFisF_LT
							lFisNewLT := cMvFisCTrb <> "2" 
						else
							lFisNewLT := !(cMvFisAlCT == "3" .AND. cMvFisCTrb == "2")
						endif

						If Len(aAlqLeiTr) == 4 .OR. lFisNewLT 
							nTotAlq := (aAlqLeiTr[1] / 100) * (SD2->D2_VALBRUT + SD2->D2_DESCON)
						   	nAlqFed := (aAlqLeiTr[2] / 100) * (SD2->D2_VALBRUT + SD2->D2_DESCON)
						   	nAlqEst := (aAlqLeiTr[3] / 100) * (SD2->D2_VALBRUT + SD2->D2_DESCON)
						   	nAlqMun := (aAlqLeiTr[4] / 100) * (SD2->D2_VALBRUT + SD2->D2_DESCON)
							SD2->D2_TOTIMP := nTotAlq
							SD2->D2_TOTFED := nAlqFed
							SD2->D2_TOTEST := nAlqEst
							SD2->D2_TOTMUN := nAlqMun
							nTotCargT += nTotAlq
							nTotFed += nAlqFed
							nTotEst += nAlqEst
							nTotMun += nAlqMun
						ElseIf Len(aAlqLeiTr) == 8
							//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
							//Novo tratamento da Lei da Transparência - Fisxfun Retorna Array de 8 posiçoes com as aliquotas e totais ¿
							//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
							nTotAlq := aAlqLeiTr[5]
							nAlqFed := aAlqLeiTr[6]
							nAlqEst := aAlqLeiTr[7]
							nAlqMun := aAlqLeiTr[8]
							SD2->D2_TOTIMP := nTotAlq
							SD2->D2_TOTFED := nAlqFed
							SD2->D2_TOTEST := nAlqEst
						 	SD2->D2_TOTMUN := nAlqMun

						 	nTotCargT	+= nTotAlq
							nTotFed 	+= nAlqFed
							nTotEst 	+= nAlqEst
							nTotMun 	+= nAlqMun
						EndIf

					EndIf
				EndIf
				aadd(aRegSD2,SD2->(RecNo()))
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Verifica a quebra de nota fiscal                                       ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If ( aEntry[EP_M460NITE] )
					nItemNf := ExecBlock("M460NITE",.F.,.F.,{Len(aSD2),aSD2})
				EndIf
				If nX == Len(aSD2) .Or. nItemNF2 >= nItemNF
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Complemento da gravacao do SF2                                         ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					Eval(bSF2,2)

					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Posiciona registros                                                    ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If SF2->F2_TIPO$"DB"
						dbSelectArea("SA2")
						dbSetOrder(1)
						MsSeek(xFilial("SA2")+SF2->F2_CLIENTE+SF2->F2_LOJA)
					Else
						dbSelectArea("SA1")
						dbSetOrder(1)
						MsSeek(xFilial("SA1")+SF2->F2_CLIENTE+SF2->F2_LOJA)
					EndIf
					dbSelectArea("SE4")
					dbSetOrder(1)
					MsSeek(xFilial("SE4")+SF2->F2_COND)

					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Regrava os itens da nota fiscal de saida apos alteracao                ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					For nY := 1 To Len(aRegSD2)
						SD2->(MsGoto(aRegSD2[nY]))
						RecLock("SD2",.F.)
						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³ Posiciona registros                                                    ³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						dbSelectArea("SB1")
						dbSetOrder(1)
						MsSeek(xFilial("SB1")+SD2->D2_COD)

						dbSelectArea("SB2")
						dbSetOrder(1)
						MsSeek(xFilial("SB2")+SD2->D2_COD+SD2->D2_LOCAL)

						dbSelectArea("SF4")
						dbSetOrder(1)
						MsSeek(xFilial("SF4")+SD2->D2_TES)

						If lGTPSub .And. _lGtpRecD2
							nRecnoOri := gtpRecnoSD2(SD2->D2_NFORI,SD2->D2_SERIORI,SD2->D2_CLIENTE,SD2->D2_LOJA,SD2->D2_ITEMORI)
							MaFisAlt("IT_RECORI",nRecnoOri,nY)
						EndIf

						//Atualiza o valor do frete nos valores de impostos de bases e item.
						If SF2->F2_FRETE > 0 .And. SD2->D2_VALFRE == 0
							MaFisLoad("IT_FRETE", SF2->F2_FRETE, nY)
						ElseIf SF2->F2_FRETE == 0 .And. SD2->D2_VALFRE > 0
							MaFisLoad("IT_FRETE", SD2->D2_VALFRE, nY)
						EndIf

						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³ Atualiza os dados fiscais                                              ³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						If MaFisRet(nY,"IT_TES")==SD2->D2_TES
							MaFisAlt("IT_TES","",nY)
						EndIf
						MaFisAlt("IT_TES",SD2->D2_TES,nY)

						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³ Executa code block para tratamento do fiscal.                          ³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						If bFiscalSD2 <> NIL
							Eval(bFiscalSD2)
						EndIf

						If lTrbGen .and. !lNoFiscal 
							MaFisRecal("IT_NORECAL",nY) // Chama uma pilha "vazia" (IT_NORECAL = Nao faz recalculo de legado), apenas para cair no CFGTRIB e aplicar alterarações feitas no Eval(bFiscalSD2). 
						EndIf

						SF4->(MaFisWrite(2,"SD2",nY))
						SD2->D2_VALICM  := SF4->(MaFisRet(nY,'IT_VALICM')+MaFisRet(nY,'IT_VALISS'))
						SD2->D2_BASEICM := SF4->(MaFisRet(ny,'IT_BASEICM')+MaFisRet(nY,'IT_BASEISS'))
						SD2->D2_PICM    := SF4->(If(SF4->F4_ISS=="S",MaFisRet(nY,'IT_ALIQISS'),MaFisRet(nY,'IT_ALIQICM')))
						SD2->D2_DESCZFR := SF4->(MaFisRet(nY,'IT_DESCZF'))
						SD2->D2_TOTAL	 := SD2->D2_TOTAL - SD2->D2_DESCON - IIf(SF4->F4_AGREG$"R", MaFisRet(nY,"IT_DEDICM") , 0)
						SD2->D2_PRCVEN  := A410Arred(SD2->D2_TOTAL/IIf(SD2->D2_QUANT==0,1,SD2->D2_QUANT),"D2_PRCVEN")

						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³ Desconta o Valor do ICMS DESONERADO do valor do Item D2_PRCVEN         ³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						If SF4->F4_AGREG$"R"
							nDedICM += MaFisRet(nY,'IT_DEDICM')
						EndIf

						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³ Pontos de Entrada                                                      ³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						If ( aEntry[EP_MSD2UMT] )
							SD2->D2_QTSEGUM := ExecTemplate("MSD2UM2",.F.,.F.,0)
						EndIf
						If ( aEntry[EP_MSD2UM2] )
							SD2->D2_QTSEGUM := ExecBlock("MSD2UM2",.F.,.F.,0)
						EndIf

						If lTrbGen
							SD2->D2_IDTRIB	:= MaFisTG(1,"SD2",nY)
						EndIf
						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³Calculo dos Impostos Financeiros                                        ³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						If ( SF4->F4_DUPLIC=="S" )
							aTitulo[_VLRTIT_]  += MaFisRet(nY,'IT_BASEDUP')
							aTitulo[_VLRIRRF_] += MaFisRet(nY,'IT_VALIRR')
							aTitulo[_VLRINSS_] += MaFisRet(nY,'IT_VALINS')
							aTitulo[_VLRINSS_] += MaFisRet(nY,'IT_VALINA')
							aTitulo[_VLRISS_]  += MaFisRet(nY,'IT_VALISS')
							aTitulo[_VLRPIS_]  += MaFisRet(nY,'IT_VALPIS')
							aTitulo[_VLRCSLL_] += MaFisRet(nY,'IT_VALCSL')
							aTitulo[_VLRCOFI_] += MaFisRet(nY,'IT_VALCOF')
							aTitulo[_VLRFET_]  += MaFisRet(nY,'IT_VALFET')
							aTitulo[_VLRFAB_]  += MaFisRet(nY,'IT_VALFAB')
							aTitulo[_VLRFAC_]  += MaFisRet(nY,'IT_VALFAC')
							aTitulo[_VLRTPDP_] += MaFisRet(nY,'IT_VALTPDP')
							If lFmpeq
								aTitulo[_VLRFMP_]  += MaFisRet(nY,"IT_VALFMP")
							EndIf
							If lIma
								aTitulo[_VLRIMA_]  += MaFisRet(nY,'IT_VALIMA')
							EndIf
							If lFamad
								aTitulo[_VLRFMD_]  += MaFisRet(nY,"NF_VALFMD") 				
							EndIf	

							aTitulo[_VLBTISS_]  += MaFisRet(nY,'IT_VALCPM')
						EndIf
						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³ Atualiza os acumulados do SD2                                          ³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						MaAvalSD2(,,lAtuSA7,nY,,lCtrAtu)
						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³ Contabilizacao dos itens                                               ³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						cCtaRec := "" //Limpa a variavel devido processamento em laço
						If ( lLct610 )
							nLctTotal += DetProva(nHdlPrv /*nHdlPrv*/, "610" /*cPadrao*/, "MATA460" /*cPrograma*/, cLote /*cLote*/,            /*nLinha*/,;
							                      /*lExecuta*/,        /*cCriterio*/,     /*lRateio*/,             /*cChaveBusca*/,            /*aCT5*/,;
							                      /*lPosiciona*/,      /*aFlagCTB*/,      /*aTabRecOri*/,          @_aDPrv461 /*aDadosProva*/, /*lSimula*/,;
							                      /*cTabCTK*/,         /*cTabCT2*/,       /*cTabCV3*/,             @cCtaRec /*cCtaRec*/)
							aLancCtb := {{"F2_DTLANC",dDataBase,"SF2",SF2->(Recno()),0,0,0}}
							//-----------------------------------------------------------------------------------------
							// Adequacao para Gravar a Conta de Receita do Item da Nota, para uso no EFD-Contribuições
							//-----------------------------------------------------------------------------------------
							If lD2CtaRec .And. !Empty(cCtaRec)
								Aadd(aLancCtb,{"D2_CTAREC",cCtaRec,"SD2",SD2->(Recno()),0,0,0})
							EndIf
						EndIf
						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³ Grava os lancamentos nas contas orcamentarias SIGAPCO    ³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						PcoDetLan("000101","01","MATA461")
						If (SB1->(FieldPos(cMV_B1M996))>0) .And. cB1M996 <> "1"
							cB1M996	:=	SB1->(FieldGet(FieldPos(cMV_B1M996)))
						EndIf
						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³Atendimento ao DECRETO 5.052, DE 08/01/2004 para o municipio de ARARAS. ³
						//³Mais especificamente o paragrafo unico do Art 2.                        ³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						If cB1FRETISS <> "2"
							cB1FRETISS	:=	SB1->B1_FRETISS
						EndIf
						//-- Tratamento para geracao da guia de recolhimento ICMS Proprio
						nValICM += MaFisRet(nY,'IT_VALICM')
						//Ec 87/2015 - Difal ICMS
						If nModulo == 43
							nVDifal   += MaFisRet(nY,'IT_DIFAL')
							nValICMP  += MaFisRet(nY,'IT_VALCMP')
							nVFCDif   += MaFisRet(nY,'IT_VFCPDIF')
							nVlCRDTran+= MaFisRet(nY, "LF_CRDTRAN")  //Geração de GNRE com redução do ICMS em 20% Conforme Convênio ICMS 106/96 somente para os Estado.
							//Tratamento para geracao da guia de recolhimento ICMS-ST
							//Se F4_CREDST for = 4 o valor de ST nao eh exibido em nenhum lugar, entao
							//tambem nao posso gerar a GNRE para que nao fique inconsistente na apuracao.
							If SF4->F4_CREDST <> "4"
								nValICMSST += MaFisRet(nY,'IT_VALSOL')
							EndIf
						EndIf

						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³Tratamento para Legislação de Carga Tributária - Lei nº 12.741/2012 (Lei da Transparência)- TMS   ³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						If nModulo == 43 .And. !(AllTrim(SD2->D2_CF) $ cMvCfLTran +"/"+ cMvCfLTra1 +"/"+ cMvCfLTra2  +"/"+ cMvCfLTra3)//SIGATMS
							If SF2->F2_TIPOCLI == "F"  // Legislação aplicada apenas para cliente consumidor final
								// Função Fiscal para retorno da carga trubutária
								xAlqLeiTr := AlqLei2741(SB1->B1_POSIPI,SB1->B1_EX_NCM,SB1->B1_CODISS,SF2->F2_EST,SA1->A1_COD_MUN,SD2->D2_COD,nItemNF2,SD2->D2_NUMLOTE,SD2->D2_LOTECTL,cMvFisCTrb, cMvFisAlCT,lMvFisFRas,SF2->F2_TIPO)
								If ValType(xAlqLeiTr) == "N"
									aAlqLeiTr := {xAlqLeiTr,0,0,0}
								Else
									aAlqLeiTr := aClone(xAlqLeiTr)
								EndIf
						
								if _xFisF_LT
									lFisNewLT := cMvFisCTrb <> "2" 
								else
									lFisNewLT := !(cMvFisAlCT == "3" .AND. cMvFisCTrb == "2")
								endif
								
								If Len(aAlqLeiTr) == 4 .OR. lFisNewLT
									nTotAlq := (aAlqLeiTr[1] / 100) * (SD2->D2_VALBRUT + SD2->D2_DESCON)
								   	nAlqFed := (aAlqLeiTr[2] / 100) * (SD2->D2_VALBRUT + SD2->D2_DESCON)
								   	nAlqEst := (aAlqLeiTr[3] / 100) * (SD2->D2_VALBRUT + SD2->D2_DESCON)
								   	nAlqMun := (aAlqLeiTr[4] / 100) * (SD2->D2_VALBRUT + SD2->D2_DESCON)
									SD2->D2_TOTIMP := nTotAlq
									SD2->D2_TOTFED := nAlqFed
									SD2->D2_TOTEST := nAlqEst
									SD2->D2_TOTMUN := nAlqMun
									nTotCargT	+= nTotAlq
									nTotFed 	+= nAlqFed
									nTotEst 	+= nAlqEst
									nTotMun 	+= nAlqMun
								ElseIf Len(aAlqLeiTr) == 8
									//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
									//Novo tratamento da Lei da Transparência - Fisxfun Retorna Array de 8 posiçoes com as aliquotas e totais ¿
									//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
									nTotAlq := aAlqLeiTr[5]
									nAlqFed := aAlqLeiTr[6]
									nAlqEst := aAlqLeiTr[7]
									nAlqMun := aAlqLeiTr[8]
									SD2->D2_TOTIMP := nTotAlq
									SD2->D2_TOTFED := nAlqFed
									SD2->D2_TOTEST := nAlqEst
								 	SD2->D2_TOTMUN := nAlqMun

								 	nTotCargT	+= nTotAlq
									nTotFed 	+= nAlqFed
									nTotEst 	+= nAlqEst
									nTotMun	+= nAlqMun
								EndIf
							EndIf
						EndIf
					Next nY
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Regrava o Cabecalho da Nota Fiscal de Saida                            ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					MaFisWrite(,"SF2")
					MaAvalSF2(lNoFiscal)

					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³Tratamento para Legislação de Carga Tributária - Lei nº 12.741/2012 (Lei da Transparência)        ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If !lIsRussia
						SF2->F2_TOTIMP := nTotCargT
						SF2->F2_TIPIMP := cMvFisCTrb
						SF2->F2_TOTFED := nTotFed
						SF2->F2_TOTEST := nTotEst
						SF2->F2_TOTMUN := nTotMun
					EndIf
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Desconta o Valor do ICMS DESONERADO do valor do Item D2_PRCVEN         ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If nDedICM > 0
						SF2->F2_VALMERC -= nDedICM
					EndIf

					If SF2->(ColumnPos("F2_IDNF")) > 0
						SF2->F2_IDNF := FWUUID("SF2")
					EndIf

					If nModulo == 43 .And. cPaisLoc=="BRA"  
						If _lTmGuiaGRNE
							TmGuiaGRNE(nValICMSST, nValICM, nVDifal, nValICMP, nVFCDif, nVlCRDTran)
						Else
							//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
							//³Gravacao do ICMS Proprio    ³
							//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
							If	nValICM > 0
								//-- Tratamento para geracao da guia de recolhimento ICMS Proprio
								Pergunte("TMB200",.F.)
								lLancCont := Iif(ValType(MV_PAR04)<>"N",.F.,(MV_PAR04==1)) //-- Lanc.Contab.On-Line ?
								lTitICMS  := Iif(ValType(MV_PAR05)<>"N",.F.,(MV_PAR05==1)) //-- Gera Titulo ICMS Proprio ?
								lGRecICMS := Iif(ValType(MV_PAR06)<>"N",.F.,(MV_PAR06==1)) //-- Gera Guia ICMS Proprio ?
								cUFOrigem := MaFisRet(,"NF_UFORIGEM")
								If (GetMV("MV_ESTADO")<>cUFOrigem .And. (lTitICMS .Or. lGRecICMS)) .And. Empty(IESubTrib(SF2->F2_EST))
									cNumero   := SF2->F2_DOC
									nVlrIcm   := SF2->F2_VALICM
									nMes      := Month(SF2->F2_EMISSAO)
									nAno      := Year(SF2->F2_EMISSAO)
									aDatas    := DetDatas(nMes,nAno,3,1)
									dDtIni    := aDatas[1]
									dDtFim    := aDatas[2]
									dDtVenc   := DataValida(aDatas[2]+1,.T.)
									aadd(aDSF2,{SF2->F2_DOC,SF2->F2_SERIE,SF2->F2_CLIENTE,SF2->F2_LOJA,SF2->F2_TIPO,"2",SF2->F2_EST,SF2->F2_ESPECIE})
									GravaTit(lTitICMS,nVlrIcm,"ICMS","IC",cLcPadTit,dDtIni,dDtFim,dDtVenc,1,lGRecICMS,nMes,nAno,nVlrIcm,0,"MATA460A",;
											lLancCont,@cNumero,@aGNRE,,,,,,,,@aRecTit,@lConfTit,0,aDSF2,,,,,,,,,,,,,,,,,(nThreads > 0))
								Else
									If !Empty(cMVTmsGnre)
										If (cMVTmsGnre $ cUFOrigem .And. (lTitICMS .Or. lGRecICMS))
											cNumero   := SF2->F2_DOC
											nVlrIcm   := SF2->F2_VALICM
											nMes      := Month(SF2->F2_EMISSAO)
											nAno      := Year(SF2->F2_EMISSAO)
											aDatas    := DetDatas(nMes,nAno,3,1)
											dDtIni    := aDatas[1]
											dDtFim    := aDatas[2]
											dDtVenc   := DataValida(aDatas[2]+1,.T.)
											aadd(aDSF2,{SF2->F2_DOC,SF2->F2_SERIE,SF2->F2_CLIENTE,SF2->F2_LOJA,SF2->F2_TIPO,"2",SF2->F2_EST,SF2->F2_ESPECIE})
											GravaTit(lTitICMS,nVlrIcm,"ICMS","IC",cLcPadTit,dDtIni,dDtFim,dDtVenc,1,lGRecICMS,nMes,nAno,nVlrIcm,0,"MATA460A",;
													lLancCont,@cNumero,@aGNRE,,,,,,,,@aRecTit,@lConfTit,0,aDSF2,,,,,,,,,,,,,,,,,(nThreads > 0))
										EndIf
									EndIf
								EndIf
								//Gnre EC87/2015
								//nVDifal esta variavel é preenchida pela função MaNFS2nfs, para casos que escrituraçao das notas teve alteração
								//apos processamento dos itens deve ser considerado conteudo Atualizado do livro (SF3).
								If nVDifal > 0
									If Empty(IESubTrib(SF2->F2_EST,.T.)) .And. SF2->F2_TIPOCLI=="F" .And. GetMV("MV_ESTADO")<>SF2->F2_EST
										lGDifal	:= Iif(ValType(MV_PAR08)<>"N",.F.,(mv_par08==1))
										lGFcpDif	:= Iif(ValType(MV_PAR09)<>"N",.F.,(mv_par09==1))
										If lGDifal
											nVlrdifal := nVDifal
											nDifFecp  := nVFCDif
											nMes      := Month(SF2->F2_EMISSAO)
											nAno      := Year(SF2->F2_EMISSAO)
											aDatas    := DetDatas(nMes,nAno,3,1)
											dDtIni	   := aDatas[1]
											dDtFim	   := aDatas[2]
											dDtVenc   := DataValida(aDatas[2]+1,.t.)
											lLancCont := Iif(ValType(MV_PAR04)<>"N",.F.,(mv_par04==1))
											aadd(aDSF2,{SF2->F2_DOC,SF2->F2_SERIE,SF2->F2_CLIENTE,SF2->F2_LOJA,SF2->F2_TIPO,"2",SF2->F2_EST,SF2->F2_ESPECIE})
											If SF2->F2_EST $ SuperGetMv("MV_SOMAGNR",,"")
												GravaTit((lGDifal .And. lGFcpDif),nVlrdifal+nDifFecp,"ICMS","IC",cLcPadTit,dDtIni,dDtFim,dDtVenc,1,lGDifal,nMes,nAno,0,nVlrdifal+nDifFecp,"MATA460A",;
														lLancCont,@cNumero,@aGNRE,,,SF2->F2_EST,,.T.,.T.,,@aRecTit,@lConfTit,0,aDSF2,,,,,,,,,,.T.,,,,.T.,,,(nThreads > 0),nDifFecp)
											Else
												GravaTit(lGDifal,nVlrdifal,"ICMS","IC",cLcPadTit,dDtIni,dDtFim,dDtVenc,1,lGDifal,nMes,nAno,0,nVlrdifal,"MATA460A",;
														lLancCont,@cNumero,@aGNRE,,,SF2->F2_EST,,,.T.,,@aRecTit,@lConfTit,0,aDSF2,,,,,,,,,,.T.,,,,.T.,,,(nThreads > 0))
												If  nVFCDif	 > 0 .And. lGFcpDif
													GravaTit(lGFcpDif,nDifFecp,"ICMS","IC",cLcPadTit,dDtIni,dDtFim,dDtVenc,1,lGFcpDif,nMes,nAno,0,nDifFecp,"MATA460A",;
														lLancCont,@cNumero,@aGNRE,,,SF2->F2_EST,,.T.,.T.,,@aRecTit,@lConfTit,0,aDSF2,,,,,,,,,,.T.,,,,.T.,,,(nThreads > 0))
												EndIf
											EndIf
										Endif
									EndIf
								EndIf

								If nValICMP > 0
									If Empty(IESubTrib(SF2->F2_EST,.T.)) .And. SF2->F2_TIPOCLI=="F" .And. GetMV("MV_ESTADO")<>cUFOrigem
										lGDifal	:= Iif(ValType(MV_PAR08)<>"N",.F.,(mv_par08==1))
										lGFcpDif	:= Iif(ValType(MV_PAR09)<>"N",.F.,(mv_par09==1))
										If lGDifal
											nVlrdifal := nValICMP
											nDifFecp  := nVFCDif
											nMes      := Month(SF2->F2_EMISSAO)
											nAno      := Year(SF2->F2_EMISSAO)
											aDatas    := DetDatas(nMes,nAno,3,1)
											dDtIni	   := aDatas[1]
											dDtFim	   := aDatas[2]
											dDtVenc   := DataValida(aDatas[2]+1,.t.)
											lLancCont := Iif(ValType(MV_PAR04)<>"N",.F.,(mv_par04==1))
											aadd(aDSF2,{SF2->F2_DOC,SF2->F2_SERIE,SF2->F2_CLIENTE,SF2->F2_LOJA,SF2->F2_TIPO,"2",cUFOrigem,SF2->F2_ESPECIE})
											If cUFOrigem $ SuperGetMv("MV_SOMAGNR",,"")
												GravaTit((lGDifal .And. lGFcpDif),nVlrdifal+nDifFecp,"ICMS","IC",cLcPadTit,dDtIni,dDtFim,dDtVenc,1,lGDifal,nMes,nAno,0,nVlrdifal+nDifFecp,"MATA460A",;
														lLancCont,@cNumero,@aGNRE,,,cUFOrigem,,,.T.,,@aRecTit,@lConfTit,0,aDSF2,,,,,,,,,,.T.,,,,.T.,,,(nThreads > 0),nDifFecp)
											Else
												GravaTit(lGDifal,nVlrdifal,"ICMS","IC",cLcPadTit,dDtIni,dDtFim,dDtVenc,1,lGDifal,nMes,nAno,nVlrdifal,0,"MATA460A",;
														lLancCont,@cNumero,@aGNRE,,,cUFOrigem,,,,,@aRecTit,@lConfTit,0,aDSF2,,,,,,,,,,,,,,,,,(nThreads > 0))
											EndIf
										EndIf
									EndIf
								EndIf
							EndIf
						EndIf
					EndIf

					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Gravacao do Financeiro                                                 ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If aTitulo[_VLRTIT_] > 0
						lFatSE1 := Eval(bFatSE1)
						If nModulo == 43 .And. (cTMSMFat == "2" .Or. (cTMSMFat == "1" .And. cTMSERP == "1")) .And. !lFatSE1
							SF2->F2_VALFAT := aTitulo[_VLRTIT_]
						Else
							If nModulo == 43 //-- CRT - Conhecimento Transporte Internacional
								nMoeda:= SF2->F2_MOEDA
							EndIf
							MaNfs2Fin(aTitulo,nMoeda,cBanco,,,,,  IIF(nModulo == 89, Nil, MaFisRet(,"NF_RECISS") ), cB1M996, cB1FRETISS,,,,,nHdlPrv,,,aNatRend )
						EndIf
					EndIf

					MAFISCDA(,2)	//Gravacao dos lancamentos fiscais

					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//Atualiza dados dos complementos SPED automaticamente
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					If lMvAtuComp
						AtuComp(SF2->F2_DOC,SF2->F2_SERIE,SF2->F2_ESPECIE,SF2->F2_CLIENTE,SF2->F2_LOJA,"S",SF2->F2_TIPO)
					EndIf

					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Gravacao do Fiscal                                                     ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					if !empty(SF2->F2_PDV)
						//Chama a "MaFisAtuSF3" de forma diferenciada para gravar tambem os campos F3_PDV e FT_PDV
						MaFisAtuSF3(1,"S",SF2->(Recno()),"SF2",NIL,NIL,"LOJA701")
					else
						MaFisAtuSF3(1,"S",SF2->(RecNo()))
					endif

					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Termino da Gravacao                                                    ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³Para a localizacao Mexico, sera processada a funcao do ponto de entrada SF2460I no padrao.³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If cPaisLoc == "MEX"
						RcFatMex()
					Endif
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Pontos de Entrada                                                      ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If aEntry[EP_SF2460T]
						ExecTemplate("SF2460I",.F.,.F.)
					EndIf

					If aEntry[EP_SF2460I]
						ExecBlock("SF2460I",.F.,.F.)
					EndIf

					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Contabilizacao do Cabecalho                                            ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If ( llCt620 )
						nLctTotal += DetProva(nHdlPrv /*nHdlPrv*/, "620" /*cPadrao*/, "MATA460" /*cPrograma*/, cLote /*cLote*/,            /*nLinha*/,;
						                      /*lExecuta*/,        /*cCriterio*/,     /*lRateio*/,             /*cChaveBusca*/,            /*aCT5*/,;
						                      /*lPosiciona*/,      /*aFlagCTB*/,      /*aTabRecOri*/,          @_aDPrv461 /*aDadosProva*/, /*lSimula*/,;
						                      /*cTabCTK*/,         /*cTabCT2*/,       /*cTabCV3*/,             /*cCtaRec*/)
						aLancCtb := {{"F2_DTLANC",dDataBase,"SF2",SF2->(Recno()),0,0,0}}
					EndIf
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Grava os lancamentos nas contas orcamentarias SIGAPCO    ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					PcoDetLan("000101","02","MATA461")

					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Restaura a pilha da funcao fiscal                                      ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					lRetorno := .T.
					cItemSD2 := ""
					cNumNFS  := ""
					MaFisEnd()
					MaFisRestore()
					nItemNF2 := 0
					aRegSD2  := {}
					aTitulo  := { 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0, 0, 0, 0, 0, 0, 0, 0, 0}
				EndIf
				//Atualiza saldo no armazem de poder de terceiros    
				TrfSldPoder3(SD2->D2_TES,"SD2",SD2->D2_COD,.F.)
				nX++
				nItemNF2++
			EndDo
			aSD2    := {}
			aRegSD2 := {}
		EndIf
	Next nItensSD2
Else
	ConOut("WARNING: DEADLOCK CONTROL IS ON")
EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Restaura a integridade da rotina                                       ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
RestArea(aAreaSD2)
RestArea(aAreaSF2)
RestArea(aArea)

Return( lRetorno )

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³MaAvalSF2 ³ Autor ³Eduardo Riera          ³ Data ³28.08.1999³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Rotina de atualizacao dos acumulados do SF2                 ³±±
±±³          ³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³                                                            ³±±
±±³          ³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³   DATA   ³ Programador   ³Manutencao Efetuada                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³               ³                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function MaAvalSF2(lNoFiscal)

Local cEstado     := SF2->F2_EST
Local lTMSUFPAG   := SuperGetMv("MV_TMSUFPG",.F.,.F.) //-- Define se grava o estado do pagador do frete.
Default lNoFiscal := .F.

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Efetua a gravacao dos Impostos  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If !lNoFiscal
	MaFisWrite(2,"SF2")
	SF2->F2_VALMERC    := MaFisRet(,"NF_VALMERC")-MaFisRet(,"NF_DESCONTO")
	If cOriPed != "LOJ"
		SF2->F2_VALIRRF    := 0
	Else
		cOriPed := ""
	EndIf
	If lTMSUFPAG .And. !Empty(MaFisRet(,"NF_PNF_UF")) .And. ("CTR"$SF2->F2_ESPECIE .Or. "NFST"$SF2->F2_ESPECIE .Or. "CTE"$SF2->F2_ESPECIE .Or. "RPS"$SF2->F2_ESPECIE)
		SF2->F2_EST	:= MaFisRet(,"NF_PNF_UF")
	Else
		SF2->F2_EST := Iif(Empty(cEstado),SF2->F2_EST,cEstado)
	EndIf
EndIf

If ( aEntry[EP_MTASF2] )
	Execblock("MTASF2",.F.,.F.)
EndIf

Return( .T. )

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³MaAvalSD2 ³ Autor ³Eduardo Riera          ³ Data ³28.08.1999³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Rotina de atualizacao dos acumulados do SD2                 ³±±
±±³          ³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpN1: Numero do evento                                (OPC)³±±
±±³          ³ExpC2: Ponteiro do SD2                                 (OPC)³±±
±±³          ³ExpL3: Atualiza amarracao ProdutoxCliente              (OPC)³±±
±±³          ³ExpN4: Item da funcao fiscal                                ³±±
±±³          ³ExpL5: Forca a atualizacao de estoque                  (OPC)³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³   DATA   ³ Programador   ³Manutencao Efetuada                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³               ³                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function MaAvalSD2(nEvento,cAliasSD2,lAtuSA7,nItem,lForceEst,lCtrAtu)

Local aArea     := GetArea("SD2")
Local aAreaSF4  := SF4->(GetArea("SF4"))
Local aAreaSD7  := SD7->(GetArea())
Local aEnvCus   := {}
Local aCusto    := {}
Local aMov      := {}
Local nCntFor   := 0
Local nPrecoSa7 := 0
Local cSeekD7   := ""
Local lSa7Lista := (SuperGetMv("MV_PRCAMAR",.F.,"1") == "1")
Local lIntePms  := (SuperGetMv("MV_INTPMS") = "S")
Local cNFNAmar  := SuperGetMv("MV_NFNAMAR",.F.,"DB") //Tipos de notas fiscais que NAO deverao atualizar amarracao
Local lTMSUFPAG := SuperGetMv("MV_TMSUFPG",.F.,.F.) //-- Define se grava o estado do pagador do frete.
Local cLocalCQ  := SuperGetMv("MV_CQ",.F.,"98")
Local lAtuSB3   := .T. // variavel utilizada no PE M461SB3
Local lIntACD	:= SuperGetMV("MV_INTACD",.F.,"0") == "1"
Local lTranCQ   := IsTranCQ()
Local aDadosCfo := {}
Local nQuantPed := 0
Local nSobraNF	:= 0
Local nQuantNF	:= 0
Local lPCDev	:= SuperGetMV("MV_COMPCDV",.F.,.T.) // Se altera o status do pedido de compra para em aberto após a devolução
Local lDCLNew	:= SuperGetMV("MV_DCLNEW",.F.,.F.)
Local aAreaSB2	:= SB2->(GetArea("SB2"))
Local cFilSF4		:= xFilial("SF4")
Local cFilSDB		:= xFilial("SDB")
Local cFilSB3		:= xFilial("SB3")
Local cFilSA7		:= xFilial("SA7")

Local aCompFutur As Array 
Local lDevEntF 	 As Logical

aCompFutur 	:= {}
lDevEntF 	:= SF4->(ColumnPos("F4_EFUTUR")) > 0 .And. ( FindFunction("A103FutRem") .And. GetAPOInfo("MATA103COM.prw")[4] >= Ctod("23/10/2024") )

DEFAULT nEvento   := 1
DEFAULT cAliasSD2 := "SD2"
DEFAULT lAtuSA7   := .F.
DEFAULT lForceEst := !(SuperGetMV("MV_NFS_JOB",,.F.) )
DEFAULT lCtrAtu	  := .F.

If lDCLNew .And. Findfunction("DCLMSGINT")
	DCLMSGINT()
EndIF

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Trava o SD2 corrente                                                    ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If cAliasSD2=="SD2"
	RecLock("SD2")
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Pesquisando o Pagador do Frete                                          ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If nItem > 0 .And. !IsInCallStack("NfeNfsCob") .And. !IsInCallStack("ATFA060")
	If lTMSUFPAG .And. ("CTR"$SF2->F2_ESPECIE.Or."NFST"$SF2->F2_ESPECIE .Or. "CTE"$SF2->F2_ESPECIE .Or. "RPS"$SF2->F2_ESPECIE) .And. !Empty(MaFisRet(,"NF_PNF_UF"))
	   SD2->D2_EST	:= MaFisRet(,"NF_PNF_UF")
	Else
		SD2->D2_EST	:= MaFisRet(,"NF_UFDEST")
	EndIf
	If SF2->F2_EST <> SD2->D2_EST
		SF2->F2_EST := SD2->D2_EST
	EndIf
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Posiciona Registros                                                     ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
dbSelectArea("SF4")
If cFilSF4+(cAliasSD2)->D2_TES<>SF4->F4_FILIAL+SF4->F4_CODIGO
	dbSelectArea("SF4")
	dbSetOrder(1)
	MsSeek(cFilSF4+(cAliasSD2)->D2_TES)
EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Verifica o Poder de Terceiro para analisar a necessidade de troca da TES³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If !Empty(SD2->D2_IDENTB6) .And. SF4->F4_PODER3=="N"
	SD2->D2_TES := SF4->F4_TESP3
	SF4->(MsSeek(cFilSF4+SF4->F4_TESP3))

 	Aadd(aDadosCfo,{"OPERNF"  ,"S"})
 	Aadd(aDadosCfo,{"TPCLIFOR",SF2->F2_TIPOCLI})
 	Aadd(aDadosCfo,{"UFDEST"  ,IIf(SF2->F2_TIPO$"DB",SA2->A2_EST,SA1->A1_EST)})
 	Aadd(aDadosCfo,{"INSCR"   ,IIf(SF2->F2_TIPO$"DB",SA2->A2_INSCR,SA1->A1_INSCR)})
	If !(SF2->F2_TIPO$"DB")
		Aadd(aDadosCfo,{"CONTR",SA1->A1_CONTRIB})
	EndIf
	SD2->D2_CF := MaFisCfo(,SF4->F4_CF,aDadosCfo)
	MaFisAlt("IT_CF",SD2->D2_CF,nItem)
EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Atualiza Estoque                                                        ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If ( SF4->F4_ESTOQUE == "S" )
	If nItem > 0
		If (cAliasSD2)->D2_TIPO == "D" .And. (cAliasSD2)->D2_QUANT == SD1->D1_QUANT //Devolucao Total
			aEnvCus	:= {MaFisRet(nItem,'IT_TOTAL')-MaFisRet(nItem,'IT_VALIPI'),;
			       	    SD1->D1_VALIPI,;
			       	    SD1->D1_VALICM-SD1->D1_ICMSCOM,;
			       	    SF4->F4_CREDIPI,;
			       	    SF4->F4_CREDICM,;
			       	    MaFisRet(nItem,'IT_NFORI'),;
			       	    MaFisRet(nItem,'IT_SERORI'),;
			       	    SD2->D2_COD,;
			       	    SD2->D2_LOCAL,;
			       	    SD2->D2_QUANT,;
			       	    If(SF4->F4_IPI=='R',SD1->D1_IPI,0),;
			       	    SF4->F4_CREDST,;
			       	    SD1->D1_ICMSRET,;
			       	    SF4->F4_PISCOF,;
			       	    SF4->F4_PISCRED,;
			       	    MaFisRet(nItem,"IT_VALPS2") }
		Else
			aEnvCus	:= {MaFisRet(nItem,'IT_TOTAL')-MaFisRet(nItem,'IT_VALIPI'),;
			       	    MaFisRet(nItem,'IT_VALIPI'),;
			       	    MaFisRet(nItem,'IT_VALICM'),;
			       	    SF4->F4_CREDIPI,;
			       	    SF4->F4_CREDICM,;
			       	    MaFisRet(nItem,'IT_NFORI'),;
			       	    MaFisRet(nItem,'IT_SERORI'),;
			       	    SD2->D2_COD,;
			       	    SD2->D2_LOCAL,;
			       	    SD2->D2_QUANT,;
			       	    If(SF4->F4_IPI=='R',MaFisRet(nItem,'IT_VALIPI'),0),;
			       	    SF4->F4_CREDST,;
			       	    MaFisRet(nItem,"IT_VALSOL"),;
			       	    SF4->F4_PISCOF,;
			       	    SF4->F4_PISCRED,;
			       	    MaFisRet(nItem,"IT_VALPS2") }
		EndIf
		SD2->(FkCommit(.T.))
		aCusto := PegaCMAtu((cAliasSD2)->D2_COD,(cAliasSD2)->D2_LOCAL,If(SF4->F4_PODER3=="D".Or.SF4->F4_QTDZERO=="1","D",(cAliasSD2)->D2_TIPO),aEnvCus, (If(SF4->F4_PODER3=="D","D",(cAliasSD2)->D2_TIPO)=="D" ) )
	
		If aEntry[EP_M460CUST]
			aCusto := ExecBlock("M460CUST",.F.,.F.,{aCusto})
		EndIf
	
		If lDCLNew 
			aCusto := DCLM460CUS(aCusto)
		Else
			If aEntry[EP_M460CUSTT]
				aCusto := ExecTemplate("M460CUST",.F.,.F.,{aCusto})
			EndIf
		EndIf
	
		aCusto := GravaCusD2(aCusto,If(SF4->F4_PODER3=="D".Or.SF4->F4_QTDZERO=="1","D",(cAliasSD2)->D2_TIPO))
	EndIf
	If nItem > 0
		If aEntry[EP_M460GCUS]
			aCusto := ExecBlock("M460GCUS",.F.,.F.,{aEnvCus})
		EndIf
	EndIf

	If lForceEst
		If nItem > 0
			If !Empty((cAliasSD2)->D2_PEDIDO)
				B2AtuComD2(aCusto,,{ {(cAliasSD2)->D2_PEDIDO,(cAliasSD2)->D2_ITEMPV,SC9->C9_SEQUEN,(cAliasSD2)->D2_QUANT,(cAliasSD2)->D2_QTSEGUM} },,,,,,,,,.T.)
			Else
				B2AtuComD2(aCusto,,,.F.,,,,,,,,.T.)
			EndIf
		Else
			B2AtuComD2({SD2->D2_CUSTO1,SD2->D2_CUSTO2,SD2->D2_CUSTO3,SD2->D2_CUSTO4,SD2->D2_CUSTO5},,{ {SD2->D2_PEDIDO,SD2->D2_ITEMPV,SC9->C9_SEQUEN,SD2->D2_QUANT,SD2->D2_QTSEGUM} },,,,,,,,,.T.)
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Efetua a Atualizacao da Assistencia Tecnica                             ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If ( SF4->F4_ATUTEC=="S" )
			If !( Localiza((cAliasSD2)->D2_COD) )
				If ( !Empty((cAliasSD2)->D2_NUMSERI) )
					AtTrfEqpto((cAliasSD2)->D2_CODFAB,(cAliasSD2)->D2_LOJAFA,(cAliasSD2)->D2_COD,(cAliasSD2)->D2_NUMSERI,(cAliasSD2)->D2_CLIENTE,(cAliasSD2)->D2_LOJA)
					If ( aEntry[EP_M460ATEC] )
						ExecBlock("M460ATEC",.F.,.F.)
					EndIf
				EndIf
			Else
				dbSelectArea("SDB")
				dbSetOrder(1)
				If ( MsSeek(cFilSDB+(cAliasSD2)->D2_COD+(cAliasSD2)->D2_LOCAL+(cAliasSD2)->D2_NUMSEQ+(cAliasSD2)->D2_DOC+(cAliasSD2)->D2_SERIE+(cAliasSD2)->D2_CLIENTE+(cAliasSD2)->D2_LOJA) )
					dbEval({||  AtTrfEqpto((cAliasSD2)->D2_CODFAB,(cAliasSD2)->D2_LOJAFA,(cAliasSD2)->D2_COD,SDB->DB_NUMSERI,(cAliasSD2)->D2_CLIENTE,(cAliasSD2)->D2_LOJA) ,;
						If(aEntry[EP_M460ATEC],ExecBlock("M460ATEC",.F.,.F.),Nil) },;
						{|| !Empty(SDB->DB_NUMSERI)},;
						{|| cFilSDB == SDB->DB_FILIAL .And.;
						(cAliasSD2)->D2_COD    == SDB->DB_PRODUTO .And.;
						(cAliasSD2)->D2_LOCAL  == SDB->DB_LOCAL .And.;
						(cAliasSD2)->D2_NUMSEQ == SDB->DB_NUMSEQ .And.;
						(cAliasSD2)->D2_DOC    == SDB->DB_DOC .And.;
						(cAliasSD2)->D2_SERIE  == SDB->DB_SERIE .And.;
						(cAliasSD2)->D2_CLIENTE== SDB->DB_CLIFOR .And.;
						(cAliasSD2)->D2_LOJA   == SDB->DB_LOJA },,,.T.)
				EndIf
			EndIf
		EndIf
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Atualiza Demandas                                                      ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Ponto de entrada - Verifica se deve ou nao atualizar o consumo mensal "SB3" ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If aEntry[EP_M461SB3]
			lAtuSB3 := ExecBlock("M461SB3", .F., .F. , {})
			If ValType(lAtuSB3) <> "L"
				lAtuSB3 := .T. // por padrao atualizara a "SB3"
			EndIf
		EndIf

		If (cAliasSD2)->D2_TIPO $ "NB" .And. SF4->F4_PODER3 $ " |R|N" .And. lAtuSB3
			dbSelectArea("SB3")
			dbSetOrder(1)
			If ( MsSeek(cFilSB3+(cAliasSD2)->D2_COD) )
				RecLock("SB3")
			Else
				RecLock("SB3",.T.)
				SB3->B3_FILIAL := cFilSB3
				SB3->B3_COD    := (cAliasSD2)->D2_COD
			EndIf
			FieldPut(FieldPos("B3_Q"+StrZero(Month((cAliasSD2)->D2_EMISSAO),2)),(cAliasSD2)->D2_QUANT+FieldGet(FieldPos("B3_Q"+StrZero(Month((cAliasSD2)->D2_EMISSAO),2))))
			SB3->B3_MES := (cAliasSD2)->D2_EMISSAO
			MsUnLock()
		EndIf
	EndIf
EndIf
If lForceEst
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Atualiza Poder de Terceiro                                              ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If SF4->F4_PODER3<>"N" .And. cAliasSD2=="SD2"
		If !lCtrAtu //Realiza a transferencia de armazem apenas quando chamada é feita pelo FATXJOB
			TrfSldPoder3((cAliasSD2)->D2_TES,"SD2",(cAliasSD2)->D2_COD,.F.)
		EndIF
		RecLock("SD2")
		MaAtuSB6("SD2",3)
	EndIf
EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Atualiza os arquivos de gerenciamento de Projetos                       ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lIntePms
	SF4->(PmsWriteD2(1,"SD2"))
Endif
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Atualizacao da amarracao cliente x Produto                             ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If ( lAtuSA7 ) .And. !((cAliasSD2)->D2_TIPO $ cNFNAmar)

	nPrecoSA7 := Iif(lSa7Lista,(cAliasSD2)->D2_PRUNIT,(cAliasSD2)->D2_PRCVEN)

	dbSelectArea("SA7")
	dbSetOrder(1)
	If !(MsSeek(cFilSA7+(cAliasSD2)->D2_CLIENTE+(cAliasSD2)->D2_LOJA+(cAliasSD2)->D2_COD))
		Reclock("SA7",.T.)
		SA7->A7_FILIAL := cFilSA7
		SA7->A7_PRODUTO:= (cAliasSD2)->D2_COD
		SA7->A7_CLIENTE:= (cAliasSD2)->D2_CLIENTE
		SA7->A7_LOJA   := (cAliasSD2)->D2_LOJA
		SA7->A7_PRECO01:= nPrecoSa7
		SA7->A7_DTREF01:= (cAliasSD2)->D2_EMISSAO
		MsUnlock()
	Else
		Reclock("SA7",.F.)
		For nCntFor := 1 To 12
			If ( FieldGet(FieldPos("A7_DTREF"+StrZero(nCntFor,2))) == (cAliasSD2)->D2_EMISSAO .And.;
					FieldGet(FieldPos("A7_PRECO"+StrZero(nCntFor,2))) == nPrecoSA7 )
				lAtuSA7 := .F.
				nCntFor := 13
			EndIf
		Next nCntFor
		If lAtuSA7
			If ( SA7->A7_PRECO12 <> 0 )
				For nCntFor := 2 To 12
					FieldPut(FieldPos("A7_PRECO"+StrZero(nCntFor-1,2)),FieldGet(FieldPos("A7_PRECO"+StrZero(nCntFor,2))))
					FieldPut(FieldPos("A7_DTREF"+StrZero(nCntFor-1,2)),FieldGet(FieldPos("A7_DTREF"+StrZero(nCntFor,2))))
				Next nCntFor
				SA7->A7_PRECO12 := 0
			EndIf
			For nCntFor := 1 To 12
				If ( FieldGet(FieldPos("A7_PRECO"+StrZero(nCntFor,2))) == 0 )
					FieldPut(FieldPos("A7_PRECO"+StrZero(nCntFor,2)),nPrecoSA7)
					FieldPut(FieldPos("A7_DTREF"+StrZero(nCntFor,2)),(cAliasSD2)->D2_EMISSAO)
					nCntFor := 13
				EndIf
			Next nCntFor
		EndIf
		MsUnLock()
	EndIf
EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Grava informacoes sobre devolucao de compra                             ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If ( SF2->F2_TIPO=="D" )
	dbSelectArea("SF1")
	dbSetOrder(1)
	MsSeek(xFilial("SF1")+(cAliasSD2)->D2_NFORI+(cAliasSD2)->D2_SERIORI+SF2->F2_CLIENTE+SF2->F2_LOJA)

	dbSelectArea("SD1")
	dbSetOrder(1)
	If ( MsSeek(xFilial("SD1")+(cAliasSD2)->D2_NFORI+(cAliasSD2)->D2_SERIORI+SF2->F2_CLIENTE+SF2->F2_LOJA+SC9->C9_PRODUTO+(cAliasSD2)->D2_ITEMORI) )
		nQuantNF := SD1->D1_QUANT - SD1->D1_QTDEDEV
		RecLock("SD1",.F.)
		SD1->D1_QTDEDEV += (cAliasSD2)->D2_QUANT
		SD1->D1_VALDEV  += (cAliasSD2)->D2_TOTAL

				// Altera o status do pedido de compra para em aberto após a devolução
		If lPCDev

			// Altera a quantidade atentida no item do pedido de compra e altera o saldo: Qtd. Entrada prevista
			aAreaSC7 := SC7->(GetArea())
			SC7->(DbSetOrder(14))
			If SC7->(DbSeek(xFilial("SC7")+SD1->D1_PEDIDO+SD1->D1_ITEMPC)) .And. AllTrim(SC7->C7_ORIGEM) <> "EICPO400" .And. SC7->C7_RESIDUO <> "S" //funcionalidade indisponível para o SIGAEIC
				If nQuantNF > SC7->C7_QUJE
					nSobraNF := nQuantNF - SC7->C7_QUJE
				EndIf
				nQuantPed	:= (cAliasSD2)->D2_QUANT - nSobraNF
				If nQuantPed > 0
					RecLock("SC7",.F.)
						Replace C7_QUJE With (C7_QUJE - nQuantPed)
						Replace C7_ENCER with IIF(C7_QUANT-C7_QUJE>0," ","E")
					MsUnlock()
					dbSelectArea("SB2")
					dbSetOrder(1)
					If SF4->F4_ESTOQUE == "S" .And. msSeek(xFilial("SB2")+SC7->C7_PRODUTO+SC7->C7_LOCAL)
						GravaB2Pre("+",nQuantPed,SC7->C7_TPOP)
					EndIf
				EndIf
			EndIf
			RestArea(aAreaSC7)
			RestArea(aAreaSB2)

			If lDevEntF .And. SF4->F4_EFUTUR == "3" .And. SF4->F4_ESTOQUE == "S"  
			
				Aadd(aCompFutur,(cAliasSD2)->D2_NFORI)
				Aadd(aCompFutur,(cAliasSD2)->D2_SERIORI)
				Aadd(aCompFutur,(cAliasSD2)->D2_ITEMORI)
				Aadd(aCompFutur,SF2->F2_CLIENTE)
				Aadd(aCompFutur,SF2->F2_LOJA)
				Aadd(aCompFutur,(cAliasSD2)->D2_COD)
				
				A103FutRem(.F., aCompFutur,"SD2")
				
				aCompFutur := {}
			EndIf
		EndIF

		MsUnLock()
	EndIf
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Chamada para integracao com o modulo ACD		  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lIntACD
	CBMSD2460()
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Chamada para atualizacao da movimentacao de CQ    ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lTranCQ .And. AllTrim((cAliasSD2)->D2_LOCAL)==AllTrim(cLocalCQ)
	If !Empty(SC6->C6_NRSEQCQ)
		dbSelectArea("SD7")
		dbsetorder(3)
		If MsSeek(cSeekD7:=xFilial("SD7")+SC6->C6_PRODUTO+SC6->C6_NRSEQCQ)
			Do While SD7->( !Eof() ) .And. cSeekD7==D7_FILIAL+D7_PRODUTO+D7_NUMSEQ
				If AllTrim(D7_LOCAL)==AllTrim(cLocalCQ) .And. D7_TIPO==0
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Realiza automaticamente a Transferencia do saldo para CQ               ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					aMov := {}
					aadd(aMov, {})
					aadd(aMov[Len(aMov)], 3)               //-- Tipo da Movimentação (1=Libera/2=Rejeita/3=Transferencia)
					aadd(aMov[Len(aMov)], SC6->C6_QTDVEN)  //-- Quantidade a ser Movimentada
					aadd(aMov[Len(aMov)], SC6->C6_LOCAL)   //-- Local de Destino da Movimentacao
					aadd(aMov[Len(aMov)], dDataBase)      	//-- Data da Movimentacao
					aadd(aMov[Len(aMov)], "")              //-- X=Estornado
					aadd(aMov[Len(aMov)], "")              //-- Motivo da Rejeicao
					aadd(aMov[Len(aMov)], "TRANSFERENCIA")	//-- Observacao
					aadd(aMov[Len(aMov)], SC6->C6_UNSVEN)  //-- Quantidade na 2a Unidade de Medida
                    // Atualiza movimentacao de CQ
					fGravaCQ(SD7->D7_PRODUTO, SD7->D7_NUMERO, .F.,aMov,,,,(cAliasSD2)->D2_NUMSEQ)
					Exit
				EndIf
				SD7->( DBSkip() )
			EndDo
		EndIf
	EndIf
EndIf

If ( aEntry[EP_MSD246T]  )
	ExecTemplate("MSD2460",.F.,.F.,{cAliasSD2,lForceEst})
EndIf

If ( aEntry[EP_MSD2460] )
	ExecBlock("MSD2460",.F.,.F.,{cAliasSD2,lForceEst})
EndIf

FwFreeArray(aCompFutur)

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Restaura a Integridade da Rotina                                       ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
RestArea(aAreaSD7)
RestArea(aAreaSF4)
RestArea(aArea)

Return( .T. )

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³Ma461QIsOk³ Autor ³Wilson Godoy           ³ Data ³21.06.2002³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Analisa da quantidade liberada                              ³±±
±±³          ³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpL1: Quantidade valida                                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpA1: Array aPlvNfs                                        ³±±
±±³          ³ExpC2: Alias do SC6                                         ³±±
±±³          ³ExpC3: Alias do SC9                                         ³±±
±±³          ³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³   DATA   ³ Programador   ³Manutencao Efetuada                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³               ³                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function Ma461QIsOk(aItens,cAliasSC6,cAliasSC9)

Static lLibAcim

Local nX        := 0
Local nSaldo    := 0
Local lRetorno  := .T.

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Inicializa variaveis                                                    ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
DEFAULT lLibAcim := SuperGetMv("MV_LIBACIM")
If lLibAcim
	nSaldo    := (cAliasSC6)->C6_QTDVEN-(cAliasSC6)->C6_QTDENT-C9_QTDLIB
	lRetorno  := nSaldo >= 0
	If lRetorno
		For nX := 1 to Len(aItens)
			If (cAliasSC9)->C9_PEDIDO == aItens[nX,1] .And. (cAliasSC9)->C9_ITEM == aItens[nX,2] .And. (cAliasSC9)->C9_PRODUTO == aItens[nX,6]
				nSaldo -= aItens[nX,4]
				If nSaldo < 0
					lRetorno := .F.
					Exit
				EndIf
			EndIf
		Next nX
	EndIf
EndIf
If lRetorno
	LogMov(cAliasSC9,.F.,.T.,(cAliasSC9)->C9_PRODUTO,(cAliasSC9)->C9_LOCAL,.T.)
EndIf

Return( lRetorno )

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³A461LckSC9³ Autor ³Bruno Sobieski         ³ Data ³02.08.2002³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Locka os registros do SC9 , separa em dois arrays os que de-³±±
±±³          ³vem gerar nota fiscal e os que devem gerar remitos.         ³±±
±±³          ³Tambem marca o SC9 e carrega em um array os pedidos envolvi-³±±
±±³          ³dos.                                                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpL1: Consegui LOCKAR.                                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpC1: Marca para o SC9                                     ³±±
±±³          ³ExpA2: Array com os RECNOS do SC9 que devem gerar NF        ³±±
±±³          ³ExpA3: Array com os RECNOS do SC9 que devem gerar REMITO    ³±±
±±³          ³ExpA4: Array com os PEDIDOS E RECNOS DO SC9 envolvidos      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³   DATA   ³ Programador   ³Manutencao Efetuada                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³               ³                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
FUNCTION A461LckSC9(cMarcaSC9,aNFs,aRems,aPedidos,lContinua)
Local nPosPed	:=	0
Local lIntWms  := IntWms(SC9->C9_PRODUTO)
DEFAULT aRems	:=	{}
DEFAULT aNFs 	:=	{}

// Aqui precisamos alterar para considerar o bloqueio WMS
If Empty(SC9->C9_BLEST+SC9->C9_BLCRED) .And. (!lIntWms .Or. (lIntWms .And. SC9->C9_BLWMS $ "05,06,07,  "))

	SC5->(MsSeek(xFilial("SC5")+SC9->C9_PEDIDO ))
	If (SC5->C5_DOCGER $ "13" )
		SC6->(MsSeek(xFilial("SC6")+SC9->C9_PEDIDO+SC9->C9_ITEM))
		If SC6->C6_GERANF $ "S " .And. Empty(SC9->C9_NFISCAL)
			If SC9->(MsRLock())
				AAdd(aNFs,SC9->(Recno()))
				SC9->C9_OK	:=	cMarcaSC9
				nPosPed	:=	Ascan(aPedidos,SC9->C9_PEDIDO)
				If nPosPed == 0
					AAdd(aPedidos,{SC9->C9_PEDIDO,{SC9->(Recno())}})
				Else
					AAdd(aPedidos[nPosPed][2],SC9->(Recno()))
				Endif
			Else
				lContinua := .F.
			Endif
		Endif
	ElseIf (SC5->C5_DOCGER $ "2 " ).And. Empty(SC9->C9_REMITO)
		If SC9->(MsRLock())
			AAdd(aRems,SC9->(Recno()))
			SC9->C9_OK := cMarcaSC9
			nPosPed	:=	Ascan(aPedidos,SC9->C9_PEDIDO)
			If nPosPed == 0
				AAdd(aPedidos,{SC9->C9_PEDIDO,{SC9->(Recno())}})
			Else
				AAdd(aPedidos[nPosPed][2],SC9->(Recno()))
			Endif
		Else
			lContinua := .F.
		Endif
	Endif
Endif

Return( lContinua )
/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³A461LckSC5³ Autor ³Bruno Sobieski         ³ Data ³02.08.2002³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Locka os registros do SC5 , e tira dos array dos RECNOS     ³±±
±±³          ³que devem gerar nota fiscal e os que devem gerar remitos os ³±±
±±³          ³pedidos que nao conseguiram ser lockados.                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpL1: Consegui LOCKAR.                                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpA1: Array com os PEDIDOS E RECNOS DO SC9 envolvidos      ³±±
±±³          ³ExpA2: Array com os RECNOS do SC9 que devem gerar NF        ³±±
±±³          ³ExpA3: Array com os RECNOS do SC9 que devem gerar REMITO    ³±±
±±³          ³ExpA5: Array com os RECNOS do SC5 LOCKADOS                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³   DATA   ³ Programador   ³Manutencao Efetuada                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³               ³                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function A461LckSC5(aPedidos,aNFs,aRems,aLockSC5,lContinua)
Local nX	    := 0
Local nY        := 0
Local nPosPed   := 0
DEFAULT aRems	:= {}
DEFAULT aNFs 	:= {}
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Tenta lockear o SC5, se nao consegue, tira o Lock dos registros do SC9³
//³que já tinham sido lockeados.                                         ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
For nX:=	1	To Len(aPedidos)
	If SC5->(MsSeek(xFilial()+aPedidos[nX][1]))
		If !SC5->(MsRLock())
			lContinua	:=	.F.
			For	nY	:=	1	To	Len(aPedidos[nX][nY])
				nPosPed	:=	AScan(aRems,{|x| x == aPedidos[nX][nY]})
				If nPosPed > 0
					aDel(aRems,nPosPed)
					aSize(aRems,Len(aRems)-1)
				Endif
				nPosPed	:=	AScan(aNFs,{|x| x == aPedidos[nX][nY]})
				If nPosPed > 0
					aDel(aNFs,nPosPed)
					aSize(aNFs,Len(aNFs)-1)
				Endif
			Next
		Else
			AAdd(aLockSC5,SC5->(Recno()))
		Endif
	Endif
Next

Return( lContinua )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³MA461View ³ Autor ³Sergio Silveira        ³ Data ³29/01/2003³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Chama a visualizacao do documento de saida a partir da      ³±±
±±³          ³liberacao                                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ExpL1:= MA461View( ExpC1, ExpN1, ExpN2 )                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpL1: .T.                                                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpC1: Alias                                                ³±±
±±³          ³ExpN1: Numero do registro                                   ³±±
±±³          ³ExpN2: Opcao                                                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³   DATA   ³ Programador   ³Manutencao Efetuada                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³               ³                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/

Function Ma461View( cAlias, nRecno, nOpcx )

Local aArea    := GetArea()
Local aAreaSC9 := SC9->( GetArea() )
Local aRotBack := AClone( aRotina )

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Verifica se este item de liberacao gerou documento de saida            ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If !Empty( SC9->C9_NFISCAL )
	SF2->( dbSetOrder( 1 ) )
 	If SF2->( MsSeek( xFilial( "SF2" ) + SC9->C9_NFISCAL + SC9->C9_SERIENF + SC9->C9_CLIENTE + SC9->C9_LOJA ))
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Cria um aRotina para compatibilizar com a visualizacao do documento     ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		aRotina := { { STR0033, "Mc090visual", 0, 2 } } //"Visualiza Doc."
		Mc090Visual( "SF2", SF2->( recno() ), 1 )
	EndIf
Else
	Aviso( STR0034, STR0035, {STR0036}, 2 )  //"Atencao !"###"Este item de liberacao nao gerou documento de saida. "###"Ok"
EndIf

RestArea( aAreaSC9 )
RestArea( aArea )

aRotina := AClone( aRotBack )

Return( .T. )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³A461Saldo ³ Autor ³Rodrigo de A Sartorio  ³ Data ³06/07/2004³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Avalia o saldo do item do pedido para nao permitir que seja ³±±
±±³          ³faturado um item indisponivel em estoque.                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Logico    - .T. item do pedido sera faturado, .F. nao sera  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³cPedido   - Numero do pedido analisado                      ³±±
±±³          ³cItem     - Item do pedido analisado                        ³±±
±±³          ³cProduto  - Produto do pedido analisado                     ³±±
±±³          ³cLocal    - Armazem do pedido analisado                     ³±±
±±³          ³nQuant    - Quantidade do pedido analisado                  ³±±
±±³          ³nQuant2UM - Quantidade do pedido analisado na segunda UM    ³±±
±±³          ³cLoteCtl  - Lote do pedido analisado                        ³±±
±±³          ³cNumLote  - Sub-Lote do pedido analisado                    ³±±
±±³          ³aTravas   - Array com os Recno travados                     ³±±
±±³          ³lSemSaldo - Indica que nao existe saldo para o produto      ³±±
±±³          ³lEstoque  - Indica se atualiza estoque                      ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function A461Saldo(cPedido,cItem,cProduto,cLocal,nQuant,nQuant2UM,cLoteCtl,cNumLote,aTravas,lSemSaldo,lAtuEst)
Local lRet     := .T.
Local aArray   := {}
Local aArea    := {}
Local nCnt     := 0
Local nCnt2    := 0
Local nSaldo   := 0
Local lEstNeg  := SuperGetMV("MV_ESTNEG",.F.,'N')=='S'
Local lRastro  := .F.
Local lLocaliza:= .F.
Local lM461SLD := aEntry[EP_M461SLD] .And. ExecBlock("M461SLD",.F.,.F.)

Default aTravas   := {}
Default lSemSaldo := .F.
Default lAtuEst   := .F.

If SB1->(DbSeek(xFilial("SB1") + cProduto))
	lRastro  := Rastro(cProduto)
	lLocaliza:= Localiza(cProduto)
EndIf
// Checa o saldo do lote/Endereco
If !lEstNeg .And. !lM461SLD .And. lAtuEst .And. ( lRastro .Or. lLocaliza )
	aArea :=GetArea()
    aArray:=SldPorLote(cProduto,cLocal,nQuant,nQuant2UM,cLoteCtl,cNumLote,NIL,NIL,@aTravas,NIL,NIL,NIL,NIL,NIL,dDatabase,,,.T.)
	If lRet .And. lRastro
		nSaldo := 0
		For nCnt:=1 to Len(aArray)
			For nCnt2:=1 to Len(aArray[nCnt,10])
				nSaldo+=aArray[nCnt,10,nCnt2,2]
			Next nCnt2
		Next nCnt
		lRet:=QtdComp(nSaldo) >= QtdComp(nQuant)
	EndIf
	If lRet .And. lLocaliza
		nSaldo := 0
		For nCnt:=1 to Len(aArray)
			nSaldo+=aArray[nCnt,5]
		Next nCnt
		lRet:=QtdComp(nSaldo) >= QtdComp(nQuant)
	EndIf
	RestArea(aArea)
	If !lRet
		lSemSaldo := .T.
	EndIf
EndIf

If lRet .AND. aEntry[EP_M461ADT]
	lRet := ExecBlock("M461ADT",.F.,.F.,{cPedido, cItem})
Endif
Return( lRet )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³MaNfsCalRt³ Autor ³Sergio Silveira        ³ Data ³05/08/2004³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Efetua o calculo do valor de titulos financeiros que        ³±±
±±³          ³calcularam a retencao do PIS / COFINS / CSLL e nao          ³±±
±±³          ³criaram os titulos de abatimento                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ExpA1 := MaNfsCalRt( ExpD1 )                                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpA1 -> Array com os seguintes elementos                   ³±±
±±³          ³       1 - Valor dos titulos                                ³±±
±±³          ³       2 - Valor do PIS                                     ³±±
±±³          ³       3 - Valor do COFINS                                  ³±±
±±³          ³       4 - Valor da CSLL                                    ³±±
±±³          ³       5 - Array contendo os recnos dos registos processados³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpD1 - Data de referencia                                  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function MaNfsCalRt( dReferencia )

Local aAreaSE1  := SE1->( GetArea() )
Local aAreaSA1  := {}
Local aDadosRef := Array( 8 )
Local aRecnos   := {}

Local cCliente  := SE1->E1_CLIENTE
Local cLoja     := SE1->E1_LOJA
Local cModTot   := SuperGetMV( "MV_MT10925",, "1" )
Local cTipoData := SuperGetMV( "MV_TD10925",, "1" )
Local cCNPJ     := ""

Local dIniMes   := FirstDay( dReferencia )
Local dFimMes   := LastDay( dReferencia )

Local cLojaAtu  := SuperGetMV( "MV_LJ10925",, "1" )
Local lM461RTFI := ExistBlock( "M461RTFI" )
Local lProcessa := .T.
Local lBaseImp  := ( SuperGetMv("MV_BS10925",.F.,"1") == "1")
Local lTodasFil	:= ExistBlock("F040FRT")
Local lM461RtQy	:= ExistBlock("M461RTQY")
Local lM461RecNo	:= ExistBlock("M461RECNO")
Local aFil10925	:= {}
Local cFilAtu	:= cFilAnt //Alterado, pois algumas integracoes podem alterar a var. cFilAnt ficando diferente do SM0->M0_CODFIL
Local nFil      := 0

Local nLoop     := 0
Local nVlDevolv := 0
Local nVlDevPro := 0
//--- Tratamento Gestao Corporativa
Local lGestao   := FWSizeFilial() > 2	// Indica se usa Gestao Corporativa
Local lSE1Comp  := FWModeAccess("SE1",3)== "C" // Verifica se SE1 é compartilhada
Local aFilAux	  := {}

Local aCampos   := {}
Local aStruct   := {}

Local cAliasQry := ""
Local cQuery    := ""
Local cSepNeg   := If("|"$MV_CRNEG,"|",",")
Local cSepProv  := If("|"$MVPROVIS,"|",",")
Local cSepRec   := If("|"$MVRECANT,"|",",")

If cLojaAtu == "3"
	SA1->( dbSetOrder( 1 ) )
	If SA1->( dbSeek( xFilial( "SA1" ) + cCliente + cLoja ) )
		cCNPJ := Left( SA1->A1_CGC, 8 )
    EndIf
EndIf

AFill( aDadosRef, 0 )

If lTodasFil
	aFil10925 := ExecBlock( "F040FRT", .F., .F. )
Else
	aFil10925 := { cFilAnt }
Endif

For nFil := 1 to Len(aFil10925)

	dbSelectArea("SE1")
	cFilAnt := aFil10925[nFil]

	//Se SE1 for compartilhada e ja passou pela mesma Empresa e Unidade, pula para a proxima filial
	If lGestao .and. lSE1Comp .and.  Ascan(aFilAux, {|x| x == xFilial("SE1")}) > 0
		Loop
	EndIf



	aCampos := { "E1_VALOR","E1_PIS","E1_COFINS","E1_CSLL","E1_SABTPIS","E1_SABTCOF","E1_SABTCSL","E1_MOEDA","E1_VENCREA"}
	aStruct := SE1->( dbStruct() )

	SE1->( dbCommit() )

	cAliasQry := GetNextAlias()

	cQuery := "SELECT E1_VALOR,E1_PIS,E1_COFINS,E1_CSLL,E1_SABTPIS,E1_SABTCOF,E1_SABTCSL, "
	cQuery += "E1_PREFIXO,E1_NUM,E1_PARCELA,E1_TIPO,E1_CLIENTE,E1_LOJA,E1_NATUREZ,E1_MOEDA,E1_VENCREA,SE1.R_E_C_N_O_ RECNO "
	cQuery += ",E1_MSFIL "

	cQuery += ",E1_BASEPIS,E1_BASECOF,E1_BASECSL "
	Aadd(aCampos,"E1_BASEPIS")
	Aadd(aCampos,"E1_BASECOF")
	Aadd(aCampos,"E1_BASECSL")

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Verifica o valor minimo para retencao. Se nao verificar, nao deve entrar       ³
	//³no montante dos R$ 5.000,00 para retencao - devera reter sempre (Lei 11.196/05)³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

	cQuery += ",E1_APLVLMN "
	aAdd(aCampos,"E1_APLVLMN")

	cQuery += "FROM "+RetSqlName( "SE1" ) + " SE1 "

	If clojaAtu == "3"
		cQuery	+= ", "+RetSqlName( "SA1" ) + " SA1 "
	EndIf

	cQuery += "WHERE "
	cQuery += "E1_FILIAL='"     + xFilial("SE1")       + "' AND "

	If clojaAtu <> "3"
		cQuery += "E1_CLIENTE='"    + cCliente             + "' AND "
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Filtra apenas a loja atual                                             ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If clojaAtu == "1"
		cQuery += "E1_LOJA='"       + cLoja                + "' AND "
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Filtra pela raiz do CNPJ                                               ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If clojaAtu == "3"
		cQuery += "SA1.A1_FILIAL='" + xFilial("SA1") + "' AND "
		cQuery += "SUBSTRING(SA1.A1_CGC,1,8)='"+ cCNPJ + "' AND "
		cQuery += "SA1.A1_COD=SE1.E1_CLIENTE AND "
		cQuery += "SA1.A1_LOJA=SE1.E1_LOJA AND "
		cQuery += "SA1.D_E_L_E_T_=' ' AND "
	EndIf

	If cTipoData == "1"
		cQuery += "E1_VENCREA>='"  + DToS( dIniMes )      + "' AND "
		cQuery += "E1_VENCREA<='"  + DToS( dFimMes )      + "' AND "
	Else
		cQuery += "E1_VENCTO>='"  + DToS( dIniMes )      + "' AND "
		cQuery += "E1_VENCTO<='"  + DToS( dFimMes )      + "' AND "
	EndIf

	cQuery += "E1_TIPO NOT IN " + FormatIn(MVABATIM,"|") + " AND "
	cQuery += "E1_TIPO NOT IN " + FormatIn(MV_CRNEG,cSepNeg)  + " AND "
	cQuery += "E1_TIPO NOT IN " + FormatIn(MVPROVIS,cSepProv) + " AND "
	cQuery += "E1_TIPO NOT IN " + FormatIn(MVRECANT,cSepRec)  + " AND "
	cQuery += "E1_APLVLMN <> '2' AND "
	cQuery += "SE1.D_E_L_E_T_=' '"

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Ponto de entrada - Permite alterar a query de selecao do titulos de retencao PIS/COFINS/CSL  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lM461RtQy
		cQuery := ExecBlock("M461RTQY",.F.,.F.,{cQuery})
	EndIf
	cQuery := ChangeQuery( cQuery )

	dbUseArea( .T., "TOPCONN", TcGenQry(,,cQuery), cAliasQry, .F., .T. )

	For nLoop := 1 To Len( aStruct )
		If !Empty( AScan( aCampos, AllTrim( aStruct[nLoop,1] ) ) ) .And. aStruct[nLoop][2]<>"C"
			TcSetField( cAliasQry, aStruct[nLoop,1], aStruct[nLoop,2],aStruct[nLoop,3],aStruct[nLoop,4])
		EndIf
	Next nLoop

	While !( cAliasQRY )->( Eof())

		If lM461RTFI
			lProcessa := ExecBlock( "M461RTFI", .F., .F.,{ ( cAliasQRY )->RECNO } )
		Else
			lProcessa := .T.
		EndIf

		If lProcessa

			If cModTot == "1"
				//Obtenho o valor das devolucoes efetuadas para o titulo dentro do periodo
				nVlDevolv := Baixas((cAliasQRY)->E1_NATUREZ,(cAliasQRY)->E1_PREFIXO,(cAliasQRY)->E1_NUM, ;
				(cAliasQRY)->E1_PARCELA,(cAliasQRY)->E1_TIPO,(cAliasQRY)->E1_MOEDA,"R",;
				(cAliasQRY)->E1_CLIENTE,(cAliasQRY)->E1_VENCREA,(cAliasQRY)->E1_LOJA,,  ;
				dIniMes,dFimMes)[13]

				aDadosRef[1] += ( cAliasQRY )->E1_VALOR - nVlDevolv

				If lBaseImp

					If ( cAliasQRY )->E1_BASEPIS  > 0 .Or. ( cAliasQRY )->E1_BASECOF > 0 .Or. ( cAliasQRY )->E1_BASECSL  > 0
						If ( cAliasQRY )->E1_BASEPIS == ( cAliasQRY )->E1_VALOR
							aDadosRef[6] += ( cAliasQRY )->E1_BASEPIS - nVlDevolv
						Else
							nVlDevPro := nVlDevolv * Round(( cAliasQRY )->E1_BASEPIS / ( cAliasQRY )->E1_VALOR,6)
							aDadosRef[6] += ( cAliasQRY )->E1_BASEPIS - nVlDevPro
						EndIf
						If ( cAliasQRY )->E1_BASECOF == ( cAliasQRY )->E1_VALOR
							aDadosRef[7] += ( cAliasQRY )->E1_BASECOF - nVlDevolv
						Else
							nVlDevPro := nVlDevolv * Round(( cAliasQRY )->E1_BASECOF / ( cAliasQRY )->E1_VALOR,6)
							aDadosRef[7] += ( cAliasQRY )->E1_BASECOF - nVlDevPro
						EndIf
						If ( cAliasQRY )->E1_BASECSL == ( cAliasQRY )->E1_VALOR
							aDadosRef[8] += ( cAliasQRY )->E1_BASECSL - nVlDevolv
						Else
							nVlDevPro := nVlDevolv * Round(( cAliasQRY )->E1_BASECSL / ( cAliasQRY )->E1_VALOR,6)
							aDadosRef[8] += ( cAliasQRY )->E1_BASECSL - nVlDevPro
						EndIf
					Else
						aDadosRef[6] += ( cAliasQRY )->E1_VALOR - nVlDevolv
						aDadosRef[7] += ( cAliasQRY )->E1_VALOR - nVlDevolv
						aDadosRef[8] += ( cAliasQRY )->E1_VALOR - nVlDevolv
					EndIf

				Else
					aDadosRef[6] += ( cAliasQRY )->E1_VALOR - nVlDevolv
					aDadosRef[7] += ( cAliasQRY )->E1_VALOR - nVlDevolv
					aDadosRef[8] += ( cAliasQRY )->E1_VALOR - nVlDevolv
				EndIf

			EndIf

			If ( !Empty( ( cAliasQRY )->E1_PIS ) .Or. !Empty( ( cAliasQRY )->E1_COFINS ) .Or. !Empty( ( cAliasQRY )->E1_CSLL ) )

				If cModTot == "2"
					//Obtenho o valor das devolucoes efetuadas para o titulo dentro do periodo
					nVlDevolv := Baixas((cAliasQRY)->E1_NATUREZ,(cAliasQRY)->E1_PREFIXO,(cAliasQRY)->E1_NUM, ;
					(cAliasQRY)->E1_PARCELA,(cAliasQRY)->E1_TIPO,(cAliasQRY)->E1_MOEDA,"R",;
					(cAliasQRY)->E1_CLIENTE,(cAliasQRY)->E1_VENCREA,(cAliasQRY)->E1_LOJA,,  ;
					dIniMes,dFimMes)[13]

					aDadosRef[1] += ( cAliasQRY )->E1_VALOR - nVlDevolv

					If lBaseImp

						If ( cAliasQRY )->E1_BASEPIS  > 0 .Or. ( cAliasQRY )->E1_BASECOF > 0 .Or. ( cAliasQRY )->E1_BASECSL  > 0
							If ( cAliasQRY )->E1_BASEPIS == ( cAliasQRY )->E1_VALOR
								aDadosRef[6] += ( cAliasQRY )->E1_BASEPIS - nVlDevolv
							Else
								nVlDevPro := nVlDevolv * Round(( cAliasQRY )->E1_BASEPIS / ( cAliasQRY )->E1_VALOR,6)
								aDadosRef[6] += ( cAliasQRY )->E1_BASEPIS - nVlDevPro
							EndIf
							If ( cAliasQRY )->E1_BASECOF == ( cAliasQRY )->E1_VALOR
								aDadosRef[7] += ( cAliasQRY )->E1_BASECOF - nVlDevolv
							Else
								nVlDevPro := nVlDevolv * Round(( cAliasQRY )->E1_BASECOF / ( cAliasQRY )->E1_VALOR,6)
								aDadosRef[7] += ( cAliasQRY )->E1_BASECOF - nVlDevPro
							EndIf
							If ( cAliasQRY )->E1_BASECSL == ( cAliasQRY )->E1_VALOR
								aDadosRef[8] += ( cAliasQRY )->E1_BASECSL - nVlDevolv
							Else
								nVlDevPro := nVlDevolv * Round(( cAliasQRY )->E1_BASECSL / ( cAliasQRY )->E1_VALOR,6)
								aDadosRef[8] += ( cAliasQRY )->E1_BASECSL - nVlDevPro
							EndIf
						Else
							aDadosRef[6] += ( cAliasQRY )->E1_VALOR - nVlDevolv
							aDadosRef[7] += ( cAliasQRY )->E1_VALOR - nVlDevolv
							aDadosRef[8] += ( cAliasQRY )->E1_VALOR - nVlDevolv
						EndIf

					Else
						aDadosRef[6] += ( cAliasQRY )->E1_VALOR - nVlDevolv
						aDadosRef[7] += ( cAliasQRY )->E1_VALOR - nVlDevolv
						aDadosRef[8] += ( cAliasQRY )->E1_VALOR - nVlDevolv
					EndIf

				EndIf

				If ( !Empty( ( cAliasQRY )->E1_SABTPIS ) .Or. !Empty( ( cAliasQry )->E1_SABTCOF ) .Or. !Empty( ( cAliasQry )->E1_SABTCSL ) )
					aDadosRef[2] += ( cAliasQRY )->E1_SABTPIS
					aDadosRef[3] += ( cAliasQRY )->E1_SABTCOF
					aDadosRef[4] += ( cAliasQRY )->E1_SABTCSL
					AAdd( aRecnos, ( cAliasQRY )->RECNO )
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³Ponto de Entrada - permite a alteracao do array aRecnos  ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If lM461RecNo
						aRecnos := ExecBlock("M461RECNO", .F., .F., {aRecnos, cAliasQRY})
					EndIf
				EndIf

			EndIf

		EndIf

		( cAliasQRY )->( dbSkip())

	EndDo

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Fecha a area de trabalho da query                                       ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	( cAliasQRY )->( DBCloseArea() )
	dbSelectArea( "SE1" )
	//Se Filial for totalmente compartilhada, faz somente 1 vez
	If Empty(xFilial("SE1"))
		Exit
	ElseIf lGestao .and. lSE1Comp
		AAdd(aFilAux, xFilial("SE1"))
	EndIf

Next nFil

cFilAnt := cFilAtu

aDadosRef[ 5 ] := AClone( aRecnos )

If !Empty( aAreaSA1 )
	SA1->( RestArea( aAreaSA1 ) )
EndIf

If ExistBlock("M461CRET")

	aDadosRef := ExecBlock("M461CRET",.F.,.F.,{dReferencia ,aDadosRef})

EndIf
SE1->( RestArea( aAreaSE1 ) )

Return( aDadosRef )

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³M461NumNF ³ Autor ³Rodrigo de A Sartorio  ³ Data ³21.01.2005 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Rotina de controle de numero de nota                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³lFirst - Indica se e' a primeira chamada                     ³±±
±±³          ³cSerie - Serie selecionada para obtencao do documento        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Numero da Nota                                               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Materiais                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function MA461NumNf(lFirst,cSerie,cNumNFs,lECF,cSerieId,cTypeDoc)

Local lUsaNewKey	:= GetSx3Cache("F2_SERIE","X3_TAMANHO") == 14 // Verifica se o novo formato de gravacao do Id nos campos _SERIE esta em uso
Local aArea     	:=GetArea()
Local cDocRet   	:=Space(Len(SD9->D9_DOC))
Local lTravou   	:= .F.
Local lLockOK   	:= .T.                    // Controla se o lock no SD9 foi feito com sucesso
Local cAliasNew 	:= ""
Local cQuery    	:= ""
Local nTentativas	:= 0
Local nX         	:= 0
Local nPosSerie  	:= 0                    // Posicao da serie no array aSerieSD9
Local dDtVazia   	:= CToD("")
Local cNumNSU    	:= Space(10)
Local lLockX5    	:= .F.
Local cFilSx5	 	:= xFilial("SX5")
Local aServico   	:= {"NFSC","NTSC","NTST","RMD","CF","RPS","SPED","NFCEE"}  //De acordo NSU - RICMS SC
Local lNewInvoic 	:= Iif(__RpoRelease >= '12.1.2410',;
						 tlpp.ffunc("backoffice.fat.documento.UsaNewInvoice") .And.;
						 tlpp.call('backoffice.fat.documento.UsaNewInvoice()'),.F.)
Local lServico   	:= Ascan( aServico, {|x| Alltrim(x)  == Iif(lNewInvoic .And.!Empty(cTypeDoc),cTypeDoc,a460Especie(cSerie)) }) > 0
Local lEstado    	:= SuperGetMV("MV_ESTADO") == "SC"
Local lChgX5FIL  	:= ExistBlock("CHGX5FIL")
Local lGrpCNPJ  	:= MaIsNumCgc()// Verifica a utilizacao da numeracao por Agrupamento por CNPJ
Local nLenSerie  	:= IIf(lUsaNewKey , Len(SD9->D9_SDOC) , Len(SD9->D9_SERIE) )
Local cCondWhere 	:= ""
Local lVldSX5Num 	:= .T.
Local lLockByFil	:= !Empty(xFilial("SD9"))
Local cLockByName	:= "A461NUMNF"
Local lMA461NNF		:= ExistBlock("MA461NNF")
Local lD9DocExcl	:= SD9->(ColumnPos("D9_DOCEXCL")) > 0
Local lNotaManOk	:= .F.
If Type("lMudouNum") == "U"
	Private lMudouNum := .F.
EndIf

Default lFirst   := .T.
Default cMin460D := Replicate("0",Len(SD9->D9_DOC))
Default cNumNFs  := ""
Default lECF     := .F.
Default cSerieId := cSerie
Default cTypeDoc := ""

If lNewInvoic
	cDocRet := tlpp.call("backoffice.fat.documento.NumberInvoice",cTypeDoc,cSerie)
Else
	If Len(cSerie) < nLenSerie
		cSerie := PadR(cSerie, nLenSerie)
	EndIf
	
	If Len(cSerieId) < nLenSerie
		cSerieId := PadR(cSerieId, nLenSerie)
	EndIf
	
	If lUsaNewKey
		cCondWhere := If(lGrpCNPJ,'D9_CNPJ == "'+SM0->M0_CGC +'" .And. D9_SDOC == "' + cSerie + '" ';
		,'D9_FILIAL == "'+xFilial("SD9")+'" .And. D9_SDOC == "' + cSerie + '" ' )
	Else
		cCondWhere := If(lGrpCNPJ,'D9_CNPJ == "'+SM0->M0_CGC +'" .And. D9_SERIE == "' + cSerie + '" ';
		,'D9_FILIAL == "'+xFilial("SD9")+'" .And. D9_SERIE == "' + cSerie + '" ' )
	EndIf
	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Busca o maior numero do documento da serie informada caso ja tenha sido utilizada no dia³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	nPosSerie := aScan(aSerieSD9, { |x| x[01] == Trim(Upper(cSerie)) })
	
	If nPosSerie == 0
	   AADD(aSerieSD9,{Trim(Upper(cSerie)),cDocRet})
	Else
	   cMin460D  := aSerieSD9[nPosSerie][02]
	Endif
	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Caso atenda a consistencia abaixo, numeracao da nota deve ser buscada do SD9 e nao a que consta na tabela "01"		   ³
	//³ Utilizado para estado de SC: caso seja alterdo o numero da nota e na incllusao da segunda, em sequencia,			   ³
	//³ o numero nao for alterado, buscar novo numero da tabela SD9 e nao a proxima da digitacao do usuario.				   ³
	//³ Ex. Ultima nota gerada foi 000030. A proxima nota o usuario altera o numero para 000035. Na sequencia, caso o usuario  ³
	//³ nao altere o numero, devera ser gerada a 000031 e nao 000036.														   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If !lMudouNum .And. SuperGetMv("MV_TPNRNFS") == "3" .And. cMin460D <> Replicate("0",Len(SD9->D9_DOC)) .And. SuperGetMv("MV_MUDANUM",,.F.)
		cMin460D := Replicate("0",Len(SD9->D9_DOC))
	EndIf
	
	dDatabOri:=dDataBase
	cFilOri  := xFilial("SD9")
	// Se cNumNFS estiver preenchido significa que o usuario alterou o numero da nota em MV_TPNRNFS == "3"
	// e o sistema deve respeitar o novo numero
	If !Empty(cNumNFs)
	
		cAliasNew := GetNextAlias()
		cQuery := "SELECT D9_DOC FROM " + RetSqlName( "SD9" )
	
		If lGrpCNPJ // Utilizando o conceito de Agrupamento por CNPJ
	
			cQuery += " WHERE D9_CNPJ   = '" + SM0->M0_CGC + "' AND "
	
		Else
	
			cQuery += " WHERE D9_FILIAL = '" + xFilial( "SD9" ) + "' AND "
	
		Endif
	
		If lUsaNewKey
			cQuery += " D9_SDOC        = '" + cSerie + "'" + CRLF
		Else
			cQuery += " D9_SERIE       = '" + cSerie + "'" + CRLF
		EndIf
	
		cQuery += " AND D9_DTUSO   = '" + Space(8) + "'" + CRLF
		cQuery += " AND D9_DOC    <> '" + cDocRet + "'" + CRLF
		cQuery += " AND D9_DOC     = '" + cNumNFS + "'" + CRLF
		cQuery += " AND D_E_L_E_T_ = ' '"
	
		cQuery := ChangeQuery(cQuery)
	
		dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasNew,.F.,.T.)
		dbSelectArea(cAliasNew)
		If !(Eof()) .And. !Empty((cAliasNew)->D9_DOC)
			lNotaManOk := .T. //Indica que a numeração informada manualmente foi localizada
			// Guarda ultimo documento do dia anterior
			cMin460D:=(cAliasNew)->D9_DOC
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Armazena o maior numero do documento da serie para ser recuperado nas proximas vendas ³
			//³desta serie                                                                           ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			nPosSerie := aScan(aSerieSD9, { |x| x[01] == Trim(Upper(cSerie)) })
			If nPosSerie > 0
			   aSerieSD9[nPosSerie][02] := cMin460D
			Endif
		EndIf
	
		(cAliasNew)->( DBCloseArea() )
		cQuery  := ""
	EndIf
	
	If !lNotaManOk //Caso não tenha sido informada a numeração ou a informada não foi localizada, segue o controle padrão.
		// Obtem o ultimo documento do dia anterior para garantir que ira gerar documento maior
	
		If oQrySD9 == Nil
			cQuery := "SELECT MAX(D9_DOC) D9_DOC FROM " + RetSqlName( "SD9" )
			If lGrpCNPJ // Utilizando o conceito de Agrupamento por CNPJ
				cQuery += " WHERE D9_CNPJ = ? AND "
			Else
				cQuery += " WHERE D9_FILIAL = ? AND "
			EndIf
	
			If lUsaNewKey
				cQuery += " D9_SDOC = ? AND "
			Else
				cQuery += " D9_SERIE = ? AND "
			EndIf
	
			If lD9DocExcl
				cQuery += " ((D9_DTUSO <> ? AND D9_DTUSO < ?) OR D9_DOCEXCL = ?) AND "
			Else
				cQuery += " D9_DTUSO <> ? AND D9_DTUSO < ? AND "
			EndIf
			
			cQuery += " D9_DOC <> ? AND D_E_L_E_T_ = ?"
	
			cQuery := ChangeQuery(cQuery)
	
			oQrySD9 := FwExecStatement():New(cQuery)
		EndIf
	
		If lGrpCNPJ 
			oQrySD9:SetString(1,SM0->M0_CGC)
		Else
			oQrySD9:SetString(1,xFilial( "SD9" ))
		EndIf
		oQrySD9:SetString(2,cSerie)
		oQrySD9:SetString(3,'        ')
		oQrySD9:SetString(4,DTOS(dDataBase))
		If lD9DocExcl
			oQrySD9:SetString(5,'S')
			oQrySD9:SetString(6,cDocRet)
			oQrySD9:SetString(7,' ')
		Else
			oQrySD9:SetString(5,cDocRet)
			oQrySD9:SetString(6,' ')
		EndIf
		
		cAliasNew := oQrySD9:OpenAlias()
	
		dbSelectArea(cAliasNew)
		If !(Eof()) .And. !Empty((cAliasNew)->D9_DOC)
			// Guarda ultimo documento do dia anterior
			cMin460D:=(cAliasNew)->D9_DOC
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Armazena o maior numero do documento da serie para ser recuperado nas proximas vendas ³
			//³desta serie                                                                           ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			nPosSerie := aScan(aSerieSD9, { |x| x[01] == Trim(Upper(cSerie)) })
			If nPosSerie > 0
			   aSerieSD9[nPosSerie][02] := cMin460D
			Endif
		EndIf
		(cAliasNew)->( DBCloseArea() )
		cQuery  := ""
	EndIf
	
	
	If lGrpCNPJ
		cLockByName := "A461NUMNF_" + SM0->M0_CGC
		//Não considera o modo de compartilhamento da SD9 pois podem existir casos que uma ou mais filiais possuem o mesmo CNPJ.
		//Possibilitando geração duplicada para filiais diferentes para o mesmo CNPJ.
		lLockByFil	:= .F.
	EndIf
	
	
	// Efetua laco na numeracao garantindo utilizar um numero nao travado por nenhum usuario
	While .T.
		// Trava chave para obter numero
		If lFirst
			While !LockByName(cLockByName,.T.,lLockByFil,.T.)
				Sleep(175)
			End
		EndIf
	
		If !lServico .And. lEstado .And. !lECF
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Busca o maior numero do NSU                                                             ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	
			cAliasNew := GetNextAlias()
			cQuery := " SELECT MAX(D9_NSU) D9_NSU FROM " + RetSqlName( "SD9" )
			cQuery += " WHERE D9_FILIAL = '" + xFilial( "SD9" ) + "' AND "
			cQuery += " D9_NSU <> '" + Space(Len(SD9->D9_NSU)) + "' AND D_E_L_E_T_ = ' '"
			cQuery := ChangeQuery(cQuery)
	
			dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasNew,.F.,.T.)
			dbSelectArea(cAliasNew)
			cNumNSU := IIf((!Eof() .And. !Empty((cAliasNew)->D9_NSU)),Soma1( D9_NSU, TamSX3("D9_NSU")[1]),"0000000001")
			(cAliasNew)->( DBCloseArea() )
			cQuery := ""
		EndIf
	
		// Trava documentos
		dbSelectArea("SD9")
		If lGrpCNPJ
	
			If lUsaNewKey
				SD9->(dbSetOrder(9)) // D9_FILIAL+D9_SDOC+DTOS(D9_DTUSO)+D9_DOC
			Else
				SD9->(dbSetOrder(4)) // D9_FILIAL+D9_SERIE+DTOS(D9_DTUSO)+D9_DOC
			EndIf
	
			SD9->(dbSeek(SM0->M0_CGC+cSerie+DToS(dDtVazia)+cMin460d,.T.))
	
		Else
	
			If lUsaNewKey
				SD9->(dbSetOrder(6)) // D9_FILIAL+D9_SDOC+DTOS(D9_DTUSO)+D9_DOC
			Else
				SD9->(dbSetOrder(1)) // D9_FILIAL+D9_SERIE+DTOS(D9_DTUSO)+D9_DOC
			EndIf
	
			SD9->(dbSeek(xFilial("SD9")+cSerie+DToS(dDtVazia)+cMin460d,.T.))
	
		Endif
	
		// Executa a Condicao conforme verificando se utiliza
		While SD9->(! Eof()) .And. &cCondWhere
		    lLockOK := .T.
			lTravou := MsRLock() .AND. RecLock("SD9")
			If lTravou
			   lTravou  := Empty(D9_DTUSO)
			Else
			   lLockOK  := .F.
			EndIf
			If !lTravou
				// Tenta os 50 primeiros registros, se todos estiverem com data de uso gravada
				// forca chamada da funcao para criar novos registros
				IF !Empty(D9_DTUSO)
					nX++
					IF nX > 50
						Exit
					Endif
				Endif
				If !InTransaction() .AND. lLockOK
				   MsRUnLock()
				EndIf
				If !lMudouNum
					SD9->( DBSkip() )
				EndIf
			Else
				If D9_DOC > cMin460d .Or. lMudouNum
					Exit
				Else
					lTravou:=.F.
					If !InTransaction() .AND.  lLockOK
					   MsRUnLock()
					EndIf
					SD9->( DBSkip() )
				EndIf
			EndIf
		End
		// Nao conseguiu achar nenhum numero. Deve criar numeros
		If !lTravou
			// Se nao conseguir numeracao pela segunda vez chama a Final
			IF !lFirst
				Final(STR0116) //"A461NUMNF - Falha na reverva do próximo número disponível da SD9."
			Endif
			// Chama Processamento para criar numero
			Processa({|lEnd| MA461MkNum(cSerie,cSerieId)},STR0117,STR0118,.F.) //"Numeracao de Documentos","Gerando Numeracao no arquivo SD9"
			// Apos criar numeros chama a funcao para obter numero
			cDocRet := MA461NumNf(.F.,cSerie,cNumNFs,lECF,cSerieId)
	
			// Retira trava
			If lFirst
				UnLockByName(cLockByName,.T.,lLockByFil,.T.)
			EndIf
			// Abandona laco
			Exit
		// Obtem numero e grava data
		Else
			cDocRet:=D9_DOC
			If !lServico  .And. lEstado .And. !lECF
				Replace D9_NSU     With cNumNSU
			EndIf
			If lGrpCNPJ
				Replace D9_FILIAL With FWxFilial()
				Replace D9_FILORI With SM0->M0_CODFIL
			Endif
			Replace D9_DTUSO   With dDataBase
			Replace D9_USUARIO With STR0119  //"Num.Ocupado"
			Replace D9_HORA    With StrTran(Left(Time(),5),':','')
		Endif
		If lMA461NNF
			ExecBlock("MA461NNF",.F.,.F.,{cDocRet,"1"})
		EndIf
		If lFirst
			UnLockByName(cLockByName,.T.,lLockByFil,.T.)
		EndIf
	
		If lUsaNewKey
			lVldSX5Num := VldSX5Num(SD9->D9_DOC,SD9->D9_SDOC,.F.,SD9->D9_SERIE)
		Else
			lVldSX5Num := VldSX5Num(SD9->D9_DOC,SD9->D9_SERIE,.F.,SD9->D9_SERIE)
	    EndIf
		// Valida a numeracao e termina a gravacao se o numero estiver OK
		If lTravou .And. lVldSX5Num
	
			SerieNfId("SD9",1,"D9_SERIE",,,, cSerieId )
	
			Replace D9_USUARIO With cUserName
			SD9->(dbCommit())
			Exit
		EndIf
		nTentativas++
		// Se apos 20 tentativas nao conseguir obter numero aborta sistema
		IF nTentativas > 20
			Final(STR0120) //"A461NUMNF - Falha na reverva do próximo número disponível da SD9."
		Endif
	End
	If ExistBlock("MA461NNF")
		ExecBlock("MA461NNF",.F.,.F.,{cDocRet,"2"})
	EndIf
	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Verifica o ponto de entrada para tratamento de filial do SX5            ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lChgX5FIL
		cFilSx5 := ExecBlock("CHGX5FIL",.f.,.f.)
	Endif
	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Pesquisa a serie da nota selecionada                                   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	DbSelectArea( "SX5" )
	dbSetOrder(1)
	If lUsaNewKey
		If MsSeek( cFilSx5 +"01"+SD9->D9_SDOC,.F. ) .And. SimpleLock("SX5") .And. lTravou
			lLockX5 := RecLock("SX5")
		EndIf
	Else
		If MsSeek( cFilSx5 +"01"+SD9->D9_SERIE,.F. ) .And. SimpleLock("SX5") .And. lTravou
			lLockX5 := RecLock("SX5")
		EndIf
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Pega o proximo numero de nota fiscal disponivel                        ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lLockX5
		If lGrpCNPJ .OR. (Val(SD9->D9_DOC) >= Val(X5Descri()))
			SX5->X5_DESCRI  := Somait(AllTrim(cDocRet))
			SX5->X5_DESCSPA := Somait(AllTrim(cDocRet))
			SX5->X5_DESCENG := Somait(AllTrim(cDocRet))
		EndIf
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Libera o SX5                                                           ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		SX5->(MsUnLock())
	EndIf
EndIf

RestArea(aArea)

Return( cDocRet )

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³M461MkNum ³ Autor ³Rodrigo de A Sartorio  ³ Rev. ³21.01.2005 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Rotina de criacao de numero de nota no arquivo SD9           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³cSerie - Serie selecionada para obtencao do documento        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nenhum                                                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Materiais                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function MA461MkNum( cSerie , cSerieId )

Local lUsaNewKey:= GetSx3Cache("F2_SERIE","X3_TAMANHO") == 14 // Verifica se o novo formato de gravacao do Id nos campos _SERIE esta em uso
Local cLastDoc := IIf((cPaisLoc == "BRA" .And. Type("cNumero") <> "U" .And. Len(AllTrim(cNumero)) < Len(SD9->D9_DOC)),Space(Len(cNumero)),Space(Len(SD9->D9_DOC)))
Local aAreaSD9 := SD9->(GetArea())
Local aAreaSF2 := {}
Local lGrpCNPJ := MaIsNumCgc() // Verifica a utilizacao da numeracao por Agrupamento por CNPJ
Local aFilCGC  := {"",""}
Local cIniDoc  := ""

Local cAliasNew  :=""
Local cQuery     :=""

Default cSerieId := cSerie

aAreaSF2   := SF2->(GetArea())

// Ao conseguir travar obtem o ultimo numero e inclui mais x numeros


If lGrpCNPJ

	aFilCGC := MatFilCgc(SM0->M0_CGC,"SF2") // Retorna o Compartilhamento conforme CNPJ
	dbSelectArea("SD9")
	If lUsaNewKey
		dbSetOrder(10) // D9_CNPJ+D9_SDOC+D9_DOC+DTOS(D9_DTUSO)
	Else
		dbSetOrder(5) // D9_CNPJ+D9_SERIE+D9_DOC+DTOS(D9_DTUSO)
    EndIf
Else


	dbSelectArea("SD9")
	If lUsaNewKey
		dbSetOrder(7) // D9_FILIAL+D9_SDOC+D9_DOC+DTOS(D9_DTUSO)
	Else
		dbSetOrder(2) // D9_FILIAL+D9_SERIE+D9_DOC+DTOS(D9_DTUSO)
	EndIf

Endif
// Obtem o ultimo numero da filial

cAliasNew := GetNextAlias()
cQuery := "SELECT MAX(D9_DOC) D9_DOC FROM " + RetSqlName( "SD9" )

If lGrpCNPJ // Utilizando o conceito de Agrupamento por CNPJ

	If lUsaNewKey
		cQuery += " WHERE D9_CNPJ = '" + SM0->M0_CGC + "' AND D9_SDOC = '"+cSerie+"' AND D9_DOC <> '"+cLastDoc+"'"
    Else
		cQuery += " WHERE D9_CNPJ = '" + SM0->M0_CGC + "' AND D9_SERIE = '"+cSerie+"' AND D9_DOC <> '"+cLastDoc+"'"
    EndIf

Else

	If lUsaNewKey
		cQuery += " WHERE D9_FILIAL = '" + xFilial( "SD9" ) + "' AND D9_SDOC = '"+cSerie+"' AND D9_DOC <> '"+cLastDoc+"'"
	Else
		cQuery += " WHERE D9_FILIAL = '" + xFilial( "SD9" ) + "' AND D9_SERIE = '"+cSerie+"' AND D9_DOC <> '"+cLastDoc+"'"
	EndIf

Endif

cQuery += " AND D_E_L_E_T_ = ' '"
cQuery := ChangeQuery(cQuery)

dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasNew,.F.,.T.)
dbSelectArea(cAliasNew)
If !(Eof()) .And. !Empty((cAliasNew)->D9_DOC)
	cLastDoc:=AllTrim((cAliasNew)->D9_DOC)
EndIf

(cAliasNew)->( DBCloseArea() )
cQuery := ""

// Se nao encontra nada no SD9 pesquisa no SF2
If Empty(cLastDoc)
	SF2->(dbSetOrder(1))

	cAliasNew := GetNextAlias()
	cQuery := "SELECT MAX(F2_DOC) F2_DOC FROM " + RetSqlName( "SF2" )

	If lGrpCNPJ // Utilizando o conceito de Agrupamento por CNPJ

		aFilCGC := MatFilCgc(SM0->M0_CGC,"SF2") // Retorna o Compartilhamento conforme CNPJ

		cQuery += " WHERE F2_FILIAL IN " + FormatIN(aFilCGC[1],aFilCGC[2]) + " AND "

	Else
		cQuery += " WHERE F2_FILIAL = '" + xFilial( "SF2" ) + "' AND "

	Endif
	If lUsaNewKey
		cQuery += "F2_SDOC = '"+cSerie+"' AND D_E_L_E_T_ = ' '"
	Else
		cQuery += "F2_SERIE = '"+cSerie+"' AND D_E_L_E_T_ = ' '"
	EndIf
	cQuery := ChangeQuery(cQuery)

	dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasNew,.F.,.T.)
	dbSelectArea(cAliasNew)
	If !(Eof()) .And. !Empty((cAliasNew)->F2_DOC)

		cIniDoc := Soma1( Replicate("0",Len(cLastDoc)) )

		If lUsaNewKey .And. Type("cNumero") <> "U" .And. cNumero == cIniDoc
			cLastDoc:=Replicate("0",Len(cLastDoc))
		Else
			cLastDoc:=AllTrim((cAliasNew)->F2_DOC)
		EndIf

	Else
		cLastDoc:=Replicate("0",Len(cLastDoc))
	EndIf
	(cAliasNew)->( DBCloseArea() )
	cQuery  := ""

EndIf
RestArea(aAreaSD9)

// Chama Job para criar documento em outra sessao
StartJob( "M461JBNUM", GetEnvServer(),.T., cEmpAnt, cFilAnt, cLastDoc, cSerie, lGrpCNPJ, cSerieId )

Return Nil

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³M461JBNum ³ Autor ³Rodrigo de A Sartorio  ³ Rev. ³27.01.2005 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Rotina de criacao de numero de nota no arquivo SD9 atraves de³±±
±±³          ³JOB.                                                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³cEmp     - Empresa                                           ³±±
±±³          ³cFil     - Filial                                            ³±±
±±³          ³cLastDoc - Ultimo documento existente                        ³±±
±±³          ³cSerie   - Serie utilizada no documento                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nenhum                                                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Materiais                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function M461JBNUM(cEmp,cFil,cLastDoc,cSerie,lGrpCNPJ,cSerieId )
Local nLacoSoma  := 0
Local nTotNum    := 5000
Local lUsaNewKey := .F.
Local cFilSD9	 := ""
Local lD9DocExcl := .T.
Local nX		 := 0
Local aStruct2   := {}
Local cSd9Cpos	 := "D9_FILIAL|D9_DOC|D9_SERIE|D9_DTUSO|D9_HORA|D9_USUARIO|D9_NSU|D9_MOTIVO|D9_CNPJ|D9_FILORI|D9_SDOC|D9_DOCEXCL"

Local oBulk as object
Local aStruct1 as array
Local lCanUseBulk as logical

Default lGrpCNPJ := .F.
Default cSerieId := cSerie

// Seta job para nao consumir licensas
RpcSetType(3)
// Seta job para empresa filial desejadas
RPCSetEnv(cEmp,cFil)
dbSelectArea("SD9")

lD9DocExcl	:= SD9->(ColumnPos("D9_DOCEXCL")) > 0

// Se numero da nota encontrada em MA461MkNum existir em SF3 (cancelada ou nao), busca proximo numero nao utilizada.
cLastDoc := Soma1(cLastDoc)
lUsaNewKey := GetSx3Cache("F2_SERIE","X3_TAMANHO") == 14 // Verifica se o novo formato de gravacao do Id nos campos _SERIE esta em uso

While Ma460ChkF3(cLastDoc,cSerie,lGrpCNPJ,cSerieId)
	cLastDoc := Soma1(cLastDoc)
EndDo

While DbSeek(xFilial( "SD9" ) + cSerie + cLastDoc)
	cLastDoc := Soma1(cLastDoc)
EndDo

cFilSD9 := xFilial("SD9")

DbSelectArea("SD9")
aStruct1 := dbStruct()

//Desconsidera campos novos ou criados por usuários
For nX := 1 to Len(aStruct1)
	If aStruct1[nX][1] $ cSd9Cpos .And. GetSX3Cache(aStruct1[nX][1],"X3_PROPRI") <> "U"
		aAdd(aStruct2,{aStruct1[nX][1],aStruct1[nX][2],aStruct1[nX][3],aStruct1[nX][4]})
	EndIf
Next nX

//Ordem alfabética crescente 
aSort(aStruct2, , , {|x, y| x[1] < y[1]})

oBulk := FwBulk():New(RetSqlName("SD9"))
lCanUseBulk := FwBulk():CanBulk()
If lCanUseBulk
	oBulk:SetFields(aStruct2)
endif

// Inicia transacao para as situacoes que utiliza Agrupamentos por CNPJ
For nLacoSoma := 1 to nTotNum

	If lCanUseBulk .And. lD9DocExcl  
		oBulk:AddData(;
			{Iif(lGrpCNPJ,SM0->M0_CGC,""),; //D9_CNPJ 
			cLastDoc,;       				//D9_DOC 
			,;                  			//D9_DOCEXCL 
			,;                  			//D9_DTUSO 
			Iif(lGrpCNPJ,"",cFilSD9),;      //D9_FILIAL 
			,;                  			//D9_FILORI 
			,;                  			//D9_HORA 
			,;                  			//D9_MOTIVO 
			,;                  			//D9_NSU 
			Iif(lUsaNewKey,"",cSerie),;     //D9_SDOC 
			Iif(lUsaNewKey,"",cSerie),;    	//D9_SERIE 
			})  							//D9_USUARIO

		cLastDoc := Soma1(cLastDoc)
    Else

		Begin Transaction

		RecLock("SD9",.T.)

		//Verifica a utilizacao do agrupamento por CNPJ
		If lGrpCNPJ
			SD9->D9_CNPJ   := SM0->M0_CGC
		Else
			SD9->D9_FILIAL := cFilSD9
		EndIf

		SD9->D9_DOC   := cLastDoc

		SerieNfId("SD9",1,"D9_SERIE",,,, cSerieId )

		If lUsaNewKey
			SD9->D9_SERIE := ""
		EndIf

		cLastDoc := Soma1(cLastDoc)

		SD9->(MsUnLock())

		End Transaction
	EndIf

Next nLacoSoma

If lCanUseBulk
	oBulk:Close()
	oBulk:Destroy()
	oBulk := nil
EndIf

RpcClearEnv()

Return Nil

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³MA461Conh ³ Autor ³Sergio Silveira        ³ Data ³29/01/2003³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Chama a visualizacao do documento de saida a partir da      ³±±
±±³          ³liberacao                                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ExpL1:= MA461Conh( ExpC1, ExpN1, ExpN2 )                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpL1: .T.                                                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpC1: Alias                                                ³±±
±±³          ³ExpN1: Numero do registro                                   ³±±
±±³          ³ExpN2: Opcao                                                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³   DATA   ³ Programador   ³Manutencao Efetuada                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³               ³                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/

Function Ma461Conh( cAlias, nRecno, nOpcx )

Local aArea    := GetArea()
Local aAreaSC9 := SC9->( GetArea() )

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Verifica se este item de liberacao gerou documento de saida            ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If !Empty( SC9->C9_NFISCAL ) .And. ((SC9->C9_BLCRED == "10" .And. SC9->C9_BLEST == "10").Or.(SC9->C9_BLCRED == "ZZ" .And. SC9->C9_BLEST == "ZZ"))
	SF2->( dbSetOrder( 1 ) )
 	If SF2->( MsSeek( xFilial( "SF2" ) + SC9->C9_NFISCAL + SC9->C9_SERIENF + SC9->C9_CLIENTE + SC9->C9_LOJA ))
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Cria um aRotina para compatibilizar com a visualizacao do documento     ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		MsDocument( "SF2", SF2->( recno() ), nOpcx )
	EndIf
Else
	Aviso( STR0034, STR0035, {STR0036}, 2 )  //"Atencao !"###"Este item de liberacao nao gerou documento de saida. "###"Ok"
EndIf

RestArea( aAreaSC9 )
RestArea( aArea )

Return( .T. )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFuncao    ³A461LegendºAutor  ³Rodrigo de A Godinhoº Data ³  18/11/05   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Legenda para os status dos pedidos de venda.                º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³MATA461                                                     º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function A461Legend()
Local aCores := {}
aCores := {	{"ENABLE",STR0043},;//Pedido  de Venda liberado
			{"DISABLE",STR0044},;//Pedido de Venda faturado
			{"BR_AZUL",STR0045}} //Pedido de Venda com bloqueio
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Ponto de Entrada para alterar cores da legenda    ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If ExistBlock("M461LEG")
	aCores := ExecBlock("M461LEG",.F.,.F.,aCores)
EndIf
BrwLegenda(STR0005,STR0042,aCores)//"Prepara‡„o dos Documentos de Sa¡da"/"Legenda"

Return( .T. )
/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³Ma460ChkF3³ Autor ³ Marco Bianchi         ³ Data ³27/12/2007³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Na geracao da tabela SD9 (MV_TPNRNFS=3), verifica se a nota ³±±
±±³          ³encontrada em MA461MkNum existe em SF3 (cancelada ou nao).  ³±±
±±³          ³Se existir nao permite utilizacao do numero.                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³Ma460ChkF3(cNumNF,cSerNF)                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Retorna .T. / .F.                                           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³M461JBNUM                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function Ma460ChkF3(cIniNUM,cSerie,lGrpCNPJ,cSerieId)

Local aArea   	:= GetArea()
Local aAreaSF3  := SF3->(GetArea())
Local lBack   	:= .F.
Local aFilCGC	:= {"",""}
Local cQuery  	:= ""

Default lGrpCNPJ := .F.
Default cSerieId := cSerie

If cPaisLoc == "BRA"

	SF3->(dbCommit())
	cQuery := "SELECT COUNT(*) SF3NOTA "
	cQuery += "FROM "+RetSqlName("SF3")+" SF3 "

	If lGrpCNPJ // Utilizando o conceito de Agrupamento por CNPJ

		aFilCGC := MatFilCgc(SM0->M0_CGC,"SF3") // Retorna o Compartilhamento conforme CNPJ

		cQuery += "WHERE SF3.F3_FILIAL IN " + FormatIN(aFilCGC[1],aFilCGC[2]) +" AND "

	Else

		cQuery += "WHERE SF3.F3_FILIAL='"+xFilial("SF3")+"' AND "

	EndIf

	cQuery += "SF3.F3_SERIE='"+cSerieId+"' AND "
	cQuery += "SF3.F3_NFISCAL='"+cIniNum+"' AND "
	cQuery += "(SF3.F3_CFO LIKE '5%' OR SF3.F3_CFO LIKE '6%' OR SF3.F3_CFO LIKE '7%' OR SF3.F3_FORMUL='S' ) AND "
	cQuery += "SF3.D_E_L_E_T_=' ' "

	cQuery := ChangeQuery(cQuery)
	dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),"CHKF3NOTA",.T.,.T.)

	If CHKF3NOTA->SF3NOTA > 0
		lBack := .T.
	EndIf

	CHKF3NOTA->( DBCloseArea() )
	DBSelectArea("SF3")

EndIf

RestArea(aAreaSF3)
RestArea(aArea)

Return( lBack )
/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³Ma461LibD9³ Autor ³ Marco Bianchi         ³ Data ³24/10/2008³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Libera numeracao da nota no SD9 dentro das seguintes situa- ³±±
±±³          ³coes:                                                       ³±±
±±³          ³                                                            ³±±
±±³          ³1. Caso 2 usuarios marquem o mesmo pedido e confirme a      ³±±
±±³          ³   gravacao da nota, o segundo usuario tera gravado o SD9,  ³±±
±±³          ³   porem, nao ira gerar a nota, pois foi gerada pelo pri-   ³±±
±±³          ³   meiro usuario. Desta forma, tornou-se necessario liberar ³±±
±±³          ³   o numero da nota no SD9 reservada pelo primeiro usuario. ³±±
±±³          ³                                                            ³±±
±±³          ³2. Caso um usuario marque e tente faturar um pedido que esta³±±
±±³          ³   sendo alterado por outro usuario.                        ³±±
±±³          ³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³Ma461LibD9(cSerie)                                 		  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Retorna .T. / .F.                                           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³MaPvlNfs2                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function Ma461LibD9(cSerie,cNumero,cSerieId)

Local nTentativas := 0
Local aRegSD9     := SD9->(GetArea("SD9"))
Local lTravou     := .F.
Local lGrpCNPJ    := MaIsNumCgc() // Verifica a utilizacao da numeracao por Agrupamento por CNPJ
Local lUsaNewKey  := GetSx3Cache("F2_SERIE","X3_TAMANHO") == 14 // Verifica se o novo formato de gravacao do Id nos campos _SERIE esta em uso

DEFAULT cSerieId := cSerie

dbSelectArea("SD9")

If lUsaNewKey
	dbSetOrder(7) // D9_FILIAL+D9_SDOC+D9_DOC+DTOS(D9_DTUSO)
Else
	dbSetOrder(2) // D9_FILIAL+D9_SERIE+D9_DOC+DTOS(D9_DTUSO)
EndIf

dbSeek(xFilial("SD9")+cSerie+cNumero)

While !Eof() .And. (D9_FILIAL+IIf(lUsaNewKey,D9_SDOC,D9_SERIE)+Alltrim(D9_DOC) == xFilial("SD9")+cSerie+Alltrim(cNumero)) .And. !lTravou
	lTravou := RecLock("SD9",.F.)
	If lTravou
		dbSelectArea("SD9")
		Replace D9_DTUSO   With CTOD("  /  /  ")
		Replace D9_USUARIO With ""
		Replace D9_HORA    With ""

		If lGrpCNPJ // Realiza a Liberacao conforme Agrupamento por CNPJ

			Replace D9_FILIAL    With ""
			Replace D9_FILORI    With ""

		Endif

		If lUsaNewKey
			Replace D9_SERIE With ""
		EndIf

		Msunlock()
	Else
		nTentativas+=1
		If nTentativas >= 50
			Exit
		EndIf
	EndIf
EndDo
RestArea(aRegSD9)

Return
/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³Ma460InfOr³ Autor ³ Marcelo Alexandre     ³ Data ³17/02/2009³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Funcao criada para retornar para matxfis a informacao da UF ³±±
±±³          ³e aliquota da nota original de entrada quando o produto pos-³±±
±±³          ³suir rastro por sublote.                                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³Ma460InfOr                                                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Retorna													  ³±±
±±³ 		 |UF Original da nota de entrada                              ³±±
±±³ 		 |Aliquota Original da nota de entrada                        ³±±
±±³ 		 |Quantidade proporcional da venda referente ao lote          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³                                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function Ma460InfOr(cPedido,cItem,cProduto,cLocal,nQuant,nQuant2UM,dDataLib,cLoteCtl,cNumLote)

Local nX	  := 0
Local nPropLot:= 0
Local lRastro	 := ExistBlock("MAFISRASTRO")
Local lRastroLot := .F.
Local aSaldos	 := {}
Local aInfLote	 := {}
Local aNfOri     := {}
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Tratamento do IVA Ajustado                   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
SB1->(dbSetOrder(1))
If SB1->(MsSeek(xFilial("SB1")+cProduto))
   lIVAAju := IIF(!lIsRussia .AND. SB1->B1_IVAAJU == '1' .And. (IIF(lRastro,lRastroLot := ExecBlock("MAFISRASTRO",.F.,.F.),Rastro(cProduto,"S"))),.T.,.F.)
EndIf
If lIVAAju
	dbSelectArea("SC6")
	dbSetOrder(1)
	MsSeek(xFilial("SC6")+cPedido)
	aSaldos := SldPorLote(cProduto,cLocal,nQuant,nQuant2UM,cLoteCtl,cNumLote,NIL,NIL,NIL,.T.,NIL,NIL,NIL,NIL,dDataBase)

	For nX := 1 to Len(aSaldos)
		nPropLot := Round((aSaldos[nX][5]/SC6->C6_QTDVEN)*100,2)
		If lRastroLot
			dbSelectArea("SB8")
			dbSetOrder(5)
			If MsSeek(xFilial("SB8")+cProduto+aSaldos[nX][01])
				aadd(aInfLote,{SB8->B8_DOC,SB8->B8_SERIE,SB8->B8_CLIFOR,SB8->B8_LOJA,nPropLot})
			EndIf
		Else
			dbSelectArea("SB8")
			dbSetOrder(2)
			If MsSeek(xFilial("SB8")+aSaldos[nX][02]+aSaldos[nX][01])
				aadd(aInfLote,{SB8->B8_DOC,SB8->B8_SERIE,SB8->B8_CLIFOR,SB8->B8_LOJA,nPropLot})
			EndIf
		EndIf
		dbSelectArea("SF3")
		dbSetOrder(4)
		If MsSeek(xFilial("SF3")+aInfLote[nX][03]+aInfLote[nX][04]+aInfLote[nX][01]+aInfLote[nX][02])
			aadd(aNfOri,{SF3->F3_ESTADO,SF3->F3_ALIQICM,aInfLote[nX][05],0})
		EndIf
	Next nX
EndIf

Return( aNfOri )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³TELANFPºAutor  ³  Luis Gustavo	     º Data ³  07/08/09   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Apresenta tela para digitar CGC do cliente                 º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametro ³ Nil                                                        º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºRetorno   ³ ExpC1 - CGC do cliente                                     º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ SIGAFAT	                                                  º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function TELANFP()
Local cCgc 	:= Space(18)				// CGC do cliente
Local lCont	:= .F.						// Continua apos digitar CGC
Local oDlg								// Objeto da Tela
Local oCgc								// Campo para digitar o CGC
Local oFontText							// Fonte do texto

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Abre tela para digitar³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
DEFINE FONT oFontText NAME "Courier New" SIZE 09,20
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³"INFORME O CPF / CNPJ PARA IMPRESSÃO"³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	DEFINE MSDIALOG oDlg TITLE STR0050 FROM 323,412 TO 420,738 PIXEL STYLE DS_MODALFRAME STATUS

	//"Digite abaixo:"
	@ 005, 004 TO 30, 160 LABEL STR0051 PIXEL OF oDlg
	@ 013,007 MSGET oCgc VAR cCgc SIZE 150,10 FONT oFontText OF oDlg PIXEL

	DEFINE SBUTTON FROM 35, 104 TYPE 1 ENABLE OF oDlg ACTION (lCont := .T. , IIF(ValidCGC(@cCgc),oDlg:End(),NIL))
	DEFINE SBUTTON FROM 35, 134 TYPE 2 ENABLE OF oDlg ACTION (lCont := .F. , oDlg:End())

ACTIVATE MSDIALOG oDlg CENTERED

If lCont
	cCgc := Alltrim(cCgc)
Else
	cCgc := ""
EndIf

Return( cCgc )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³ValidCGC	ºAutor  ³ Luis Gustavo 		 º Data ³  07/08/09   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Valida o CGC digitado se existe.                           º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametro ³ ExpC1 - CGC do cliente                                     º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºRetorno   ³ ExpL1 - Retorno da funcao T ou F                           º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ SIGAFAT                                                   º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function ValidCGC(cCgc)
Local lRet 		:= .F.									// Retorno da funcao
Local cVerCgc 	:= cCgc									// CGC do cliente
Local cNumCNPJ  := Space(TamSX3("A1_CGC")[1]) 			//varivel para armazenar o retorno da funcao CGC

DEFAULT cCgc := ""

If !Empty(cCgc)
	If Len( AllTrim( cCgc ) ) >= 11 .AND. Len( AllTrim( cCgc ) ) <= 14
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Retira caracteres que nao sao usados³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		cVerCgc := StrTran(cVerCgc,".","")
		cVerCgc := StrTran(cVerCgc,"-","")
		cVerCgc := StrTran(cVerCgc,"/","")
		cVerCgc := Alltrim(cVerCgc)

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Valida se o CGC digitado eh valido³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If CGC(cVerCgc, @cNumCNPJ)
			lRet := .T.
			cCgc := cVerCgc
		EndIf
	Else
		MsgStop( STR0052 ) 		// "CPF/CNPJ inválido!"
		cCgc := Space(18)
	EndIf
Else
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Se estiver em branco, valida a insercao³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	lRet := .T.
EndIf

Return lRet

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³MaAcreFinAdt³ Autor ³Totvs                ³ Data ³22.04.2010³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Retorna o valor do acrescimo financeiro do item, usado para ³±±
±±³          ³o processo de adiantamento.                                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpN1: Valor do acrescimo financeiro do item                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpA1: Array com os itens a serem gerados                   ³±±
±±³          ³ExpN2: Item do documento                                    ³±±
±±³          ³ExpL3: Reajuste                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Observacao³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³   DATA   ³ Programador   ³Manutencao Efetuada                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³               ³                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function MaAcreFinAdt(aPvlNfs,nx,lReajuste,dDataMoe)

Local aVar := {}
Local nPrcVen	:= 0
Local nPrUnit	:= 0
Local nAcresFin := 0
Local lAcresDup := ( SuperGetMv("MV_ACRSDUP",.F.,.F.) == .T.)
Local aArea := GetArea()
Local aAreaSC9 := SC9->(GetArea())
Local aAreaSB1 := SB1->(GetArea())
Local aAreaSC5 := SC5->(GetArea())
Local aAreaSC6 := SC6->(GetArea())
Local aAreaSF4 := SF4->(GetArea())

Default dDataMoe := dDataBase

If Empty(dDataMoe)
	dDataMoe := dDatabase
Endif

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Posiciona Registros                                                     ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
dbSelectArea("SC9")
dbSetOrder(1)
MsGoto(aPvlNfs[nx][8])

dbSelectArea("SB1")
dbSetOrder(1)
MsGoto(aPvlNfs[nx][12])

dbSelectArea("SC5")
dbSetOrder(1)
MsGoto(aPvlNfs[nx][9])

dbSelectArea("SC6")
dbSetOrder(1)
MsGoto(aPvlNfs[nx][10])

dbSelectArea("SF4")
dbSetOrder(1)
MsGoto(aPvlNfs[nx][14])
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Calculo do Preco de Venda                                               ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
nPrcVen := SC9->C9_PRCVEN
nPrUnit := If(SC6->C6_PRUNIT<>0,SC6->C6_PRUNIT,SC9->C9_PRCVEN)

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Calcula o reajuste de preco.                                            ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If ( !Empty(SC5->C5_REAJUST) .And. lReajuste )
	nPrcVen  := Formula(SC5->C5_REAJUST)
	nPrUnit := nPrcVen
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Converte os valores para a Moeda Corrente(1)                            ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If SC5->C5_MOEDA > 1
 	If	aEntry[EP_M460PRC]
		aVar     := ExecBlock("M460PRC",.F.,.F.,{nPrcVen,nPrUnit})
		nPrcVen  := aVar[1]
		nPrUnit  := aVar[2]
	ElseIf SuperGetMV('MV_AGRUBS',.F.,.F.) .And. _lOGX225J .And. SC5->(ColumnPos("C5_TRCNUM")) > 0 .And. !Empty(SC5->C5_TRCNUM)
		aVar     := OGX225J({nPrcVen,nPrUnit,@aPvlNfs})
		nPrcVen  := aVar[1]
		nPrUnit  := aVar[2]
		aPvlNfs  := aVar[3]
	Else
		nPrcVen  := xMoeda(nPrcVen,SC5->C5_MOEDA,1,dDataMoe,8)
		nPrUnit := xMoeda(nPrUnit,SC5->C5_MOEDA,1,dDataMoe,8)
	Endif
EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Calculo do Acrescimo Financeiro                                         ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If ( SC5->C5_ACRSFIN <> 0 )
	If lAcresDup
		nAcresFin := a410Arred(nPrcVen*SC5->C5_ACRSFIN/100,"D2_PRCVEN")
	Else
		If SF4->F4_DUPLIC=="S"
			nAcresFin := a410Arred(nPrcVen*SC5->C5_ACRSFIN/100,"D2_PRCVEN")
		Endif
	Endif
EndIf

If ( aEntry[EP_M461ACRE] )
	nAcresFin := Execblock("M461ACRE",.f.,.f.,{nPrcVen,nPrUnit,nAcresFin})
Endif

nAcresFin := nAcresFin * aPvlNfs[nx][4]

SC9->(RestArea(aAreaSC9))
SB1->(RestArea(aAreaSB1))
SC5->(RestArea(aAreaSC5))
SC6->(RestArea(aAreaSC6))
SF4->(RestArea(aAreaSF4))
RestArea(aArea)

Return(nAcresFin)


/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³A461NAdian  ³ Autor ³Totvs                ³ Data ³09.04.2010³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Valida a regra em relacao ao Pedido de Vendas quando utili- ³±±
±±³          ³za condicao de pagamento com Adiantamento.                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpL1: Indica se adiantamento foi associado ao documento    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpC1: Numero do Pedido de venda                            ³±±
±±³          ³ExpC2: Condicao de Pagamento deste documento de saida       ³±±
±±³          ³ExpA3: Array com os itens a serem gerados                   ³±±
±±³          ³ExpL4: Indica se pergunta para selecionar adiantamento jah  ³±±
±±³          ³foi respondida                                              ³±±
±±³          ³ExpL5: Indica se adiantamento jah foi associado ao documento³±±
±±³          ³ExpC6: Codigo do cliente                                    ³±±
±±³          ³ExpC7: Loja do cliente                                      ³±±
±±³          ³ExpA8: Array usado na condicao de pagamento                 ³±±
±±³          ³ExpN9: Valor do acrescimo financeiro                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Observacao³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³   DATA   ³ Programador   ³Manutencao Efetuada                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³               ³                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function A461NAdian(cNumPedido, cCondPagto, aPvlNfs, lRespVlrInf, lActVlrInf, cCliente, cLoja, aImpVarDup, nAcresTot, nMoedaPed)

Local lRet		:= .T.
Local aArea		:= GetArea()
Local aAreaSC9	:= SC9->(GetArea())
Local aAreaSC5	:= SC5->(GetArea())
Local aAreaSE1	:= SE1->(GetArea())
Local nValTot	:= 0 // Total do pedido (Liberado)
Local nValAdt	:= 0 // Valor total do Adiantamento
Local aVenc		:= {} // Array de parcelas
Local aPedidos	:= {}
Local nI		:= 0
Local cFilSC9	:= ""
Local cFilSC5	:= ""

Default nMoedaPed	:= 0
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³O processo de Recebimento Antecipado estará disponivel ³
//³apenas para TOP no Financeiro.                         ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

If A410UsaAdi( cCondPagto )
	lRet			:= .F.
	cFilSC5		:= xFilial("SC5")
	cFilSC9		:= xFilial("SC9")
	DbSelectArea("SC9")
	DbSetOrder(1) // C9_FILIAL+C9_PEDIDO+C9_ITEM+C9_SEQUEN+C9_PRODUTO
	If DbSeek( cFilSC9+cNumPedido )
		While SC9->(! Eof()) .AND. SC9->C9_FILIAL == cFilSC9 .AND. SC9->C9_PEDIDO == cNumPedido
			If aScan(aPvlNfs, {|x| x[8]==SC9->(RECNO())}) > 0
				nValTot += a410Arred(SC9->C9_QTDLIB * SC9->C9_PRCVEN, "D2_TOTAL")
			EndIf
			SC9->(DbSkip())
		End
		SC5->(DbSetOrder(1)) // C5_FILIAL+C5_NUM
		If SC5->(DbSeek(cFilSC5 + cNumPedido))
			nValTot += SC5->C5_FRETE + SC5->C5_SEGURO + SC5->C5_DESPESA
		EndIf
		aVenc := Condicao(nValTot, cCondPagto, 0.00, dDataBase, 0.00, aImpVarDup, , nAcresTot)
		If Len(aVenc) > 0
			// aVenc[1,2] - Valor da primeira parcela
			// Carrega array de Adiantamentos relacionados ao pedido
			aPedidos := FPedAdtPed( "R", {cNumPedido}, .F. )
			For nI := 1 To Len(aPedidos)
				// checa se o saldo atual do adiantamento eh igual ou maior que o valor relacionado no pedido
				SE1->(dbGoto(aPedidos[nI][2]))
				If SE1->(Recno()) = aPedidos[nI][2]
					If SE1->E1_SALDO >= SaldoTit(SE1->E1_PREFIXO,SE1->E1_NUM,SE1->E1_PARCELA,SE1->E1_TIPO,SE1->E1_NATUREZ,"R",SE1->E1_CLIENTE,1,dDataBase,,SE1->E1_LOJA,,0,1)
						nValAdt += aPedidos[nI][3]
					Endif
				Endif
			Next nI

			If Empty(nValAdt) // eh necessario existir ao menos um adiantamento para o documento de saida a ser gerado
				// Indica se o usuário ja respondeu ao questionamento nesta liberacao
				If !lRespVlrInf
					lRespVlrInf := .T.
					lActVlrInf	:= ApMsgYesNo(STR0057 + CRLF+ STR0058) // "Foram encontrado(s) pedido(s) usando condição de pagamento associado com 'Adiantamento', porém sem nenhum Adiantamento associado." + CRLF+ "Deseja selecionar agora o(s) Adiantamento(s)?"
				EndIf
				If lActVlrInf
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³Abre a tela do financeiro para inclusao³
					//³de Adiantamento                        ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If A461NPedido(cNumPedido, cCliente, cLoja, nValAdt, aVenc[1,2], cCondPagto, nMoedaPed)
						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³Chamada recursiva para saber se     ³
						//³foi atendida a regra do Adiantamento³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						lRet := A461NAdian(cNumPedido, cCondPagto, aPvlNfs, lRespVlrInf, lActVlrInf, cCliente, cLoja, aImpVarDup, nAcresTot, nMoedaPed)
					EndIf
				EndIf
			Else
				lRet := .T.
			EndIf
		EndIf
	EndIf
EndIf

RestArea(aAreaSC9)
RestArea(aAreaSC5)
RestArea(aAreaSE1)
RestArea(aArea)

Return lRet


/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³A461NCompAd ³ Autor ³Totvs                ³ Data ³09.04.2010³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Realiza a compensacao do Titulo a Receber quando trata-se   ³±±
±±³          ³da parcela a Vista e o pedido utilizou Adiantamento.        º±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nenhum                                                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpA1: Array com os Pedidos de Venda                        ³±±
±±³          ³ExpA2: Array com o Recno dos titulos gerados                ³±±
±±³          ³ExpA3: Array com os adiantamentos relacionados ao pedido    ³±±
±±³          ³ExpA4: Array com os itens a serem gerados                   ³±±
±±³          ³ExpL5: Indica se eh compensacao do contas a receber         ³±±
±±³          ³ExpC6: Numero do Documento de Saida                         ³±±
±±³          ³ExpC7: Serie do Documento de Saida                          ³±±
±±³          ³ExpA8: Array usado na condicao de pagamento                 ³±±
±±³          ³ExpN9: Valor do acrescimo financeiro                        ³±±
±±³          ³ExpA10: Array Títulos                                       ³±±
±±³          ³ExpN11: Numérico Handle HeadProva                           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Observacao³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³   DATA   ³ Programador   ³Manutencao Efetuada                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³               ³                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function A461NCompAd(aAtuSC5, aRegSE1, aRecnoAdt, aPvlNfs, lCmp, cDoc, cSerieId, aImpVarDup, aAcresTot, aTitulo, nHdlPrv)

Local aArea := GetArea()
Local aAreaSE1		:= SE1->(GetArea())
Local aAreaSC5		:= SC5->(GetArea())
Local aAreaSC9		:= SC9->(GetArea())
Local lContabiliza := .F.
Local lDigita 		:= .F.
Local lAglutina 	:= .F.
Local aCodPedidos	:= {} 	// Recebe o codigo dos Pedidos
Local aRecRet		:= {}	// Retorno da funcao que carrega os titulos de Adiantamento
Local nI				:= 0 	// Variavel utilizado em loop
Local nAux			:= 0 	// Variavel utilizado em loop
Local aRecNo		:= {}	// Recebe o Recno do Titulo de Adiantamento
Local aRecVlr		:= {}	// Recebe o valor limite para compensação do Titulo de Adiantamento
Local nVlrParc1	:= 0	// Valor da primeira parcela da Nota Fiscal
Local aPedidos		:= {}	// Array para ajuste do saldo no relacionamento do Financeiro
Local nAcresTot 	:= 0
Local lRet 			:= .F.
Local nVlrTot		:= 0
Local cFunName		:= FunName()
Local nBkpVlrRA		:= 0
Local nBkpParc		:= 0
Local lTP9IPI		:= .F.
Local lMV_CMP330    := SuperGetMV("MV_CMP330",.F.,.F.)

Default aRecnoAdt := NIL
Default lCmp := .F.
Default cDoc := ""
Default cSerieId := ""

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Verifica se há ao menos 1 parcela nesta venda³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If Len(aRegSE1) >= 1

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Carrega os titulos de Adiantamentos relacionados aos³
	//³Pedidos da Nota.                                    ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If ValType(aRecnoAdt) == "U"
		For nI := 1 To Len(aAtuSC5)
			nAcresTot := aAcresTot[aScan(aAcresTot,{|x| x[1] = aAtuSC5[nI]})][2]
			aPedidos := {}
			nVlrParc1 := A461NP1Vlr(aAtuSC5[nI], aPvlNfs, aImpVarDup, nAcresTot, aTitulo, @lTP9IPI, lMV_CMP330, aRegSE1)
			
			// RA's
			aRecRet := FPedAdtPed( "R", { aAtuSC5[nI] }, .F. )
			For nAux := 1 To Len(aRecRet)
				If !Empty(aRecRet[nAux, 3]) // soh trata registros com saldo diferente de 0
					nBkpVlrRA := aRecRet[nAux,3]
					nBkpParc  := nVlrParc1
					If lMV_CMP330 .And. Valtype("aTitulo") != "U"
						If !lTP9IPI .And. aTitulo[_VLRIPI_] > 0
							If (nBkpVlrRA + aTitulo[_VLRIPI_]) == nVlrParc1 - aTitulo[_VLRSOL_]
								aRecRet[nAux,3] += aTitulo[_VLRIPI_]
							EndIf
						EndIf
						If aTitulo[_VLRSOL_] > 0
							If (nBkpVlrRA + aTitulo[_VLRSOL_]) == nVlrParc1 - aTitulo[_VLRIPI_]
								aRecRet[nAux,3] += aTitulo[_VLRSOL_]
							EndIf
						EndIf
					EndIf 
	
					// checa se o saldo atual do adiantamento eh igual ou maior que o valor relacionado no pedido
					SE1->(dbGoto(aRecRet[nAux][2]))
					If SE1->(Recno()) = aRecRet[nAux][2]
						If SE1->E1_SALDO >= SaldoTit(SE1->E1_PREFIXO,SE1->E1_NUM,SE1->E1_PARCELA,SE1->E1_TIPO,SE1->E1_NATUREZ,"R",SE1->E1_CLIENTE,1,dDataBase,,SE1->E1_LOJA,,0,1)
							If nVlrParc1 >= aRecRet[nAux, 3]
								nVlrTot += aRecRet[nAux, 3]
								// checa se total de compensacoes nao ultrapassou o valor total do titulo
								If Valtype("aTitulo") != "U"
									If nVlrTot > aTitulo[_VLRTIT_]
										aRecRet[nAux, 3] := aRecRet[nAux, 3]-(nVlrTot-aTitulo[_VLRTIT_])
									Endif
								Endif
								aAdd(aRecVlr,  aRecRet[nAux, 3])
								aAdd(aRecNo, 	aRecRet[nAux, 2])
								nVlrParc1 -= aRecRet[nAux, 3]
								// Array para ajuste do saldo do relacionamento no Financeiro
								aAdd( aPedidos, {aRecRet[nAux, 1], aRecRet[nAux, 2], nBkpVlrRA} )
							ElseIf nVlrParc1 > 0
								nVlrTot += nVlrParc1
								// checa se total de compensacoes nao ultrapassou o valor total do titulo
								If Valtype("aTitulo") != "U"
									If nVlrTot > aTitulo[_VLRTIT_]
										nVlrParc1 := nVlrParc1-(nVlrTot-aTitulo[_VLRTIT_])
									Endif
								Endif
		              	 		aAdd(aRecVlr,	nVlrParc1)
								aAdd(aRecNo, 	aRecRet[nAux, 2])
		             			nVlrParc1 := 0
								// Array para ajuste do saldo do relacionamento no Financeiro
								aAdd( aPedidos, {aRecRet[nAux, 1], aRecRet[nAux, 2], nBkpParc} )
							Endif
						Endif
					Endif
				Endif
			Next nAux
			aAdd(aCodPedidos, {aAtuSC5[nI], aClone(aPedidos)} )
		Next nI
	Else
		aRecRet := aClone(aRecnoAdt)

		For nI := 1 To Len(aRecRet)
			aAdd(aRecNo, 	aRecRet[nI, 2])
			aAdd(aRecVlr,	aRecRet[nI, 3])
		Next nI
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Carrega o pergunte da rotina de compensação financeira³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	Pergunte("FIN330",.F.)

	lContabiliza 	:= (MV_PAR09 == 1) // Contabiliza On Line ?
	lDigita		:= (MV_PAR07 == 1) // Mostra Lanc Contab ?

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Compensa os valores no Financeiro³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	SE1->(MsGoTo(aRegSE1[1]))
	If SE1->(Recno()) = aRegSE1[1] .and. Len(aRecNo) > 0 .and. Len(aRecVlr)	> 0
		If IsInCallStack("Ma410PvNfs")
			SetFunName("MATA410")
			lRet := MaIntBxCR(3 /*nCaso*/, {aRegSE1[1]} /*aSE1*/, /*aBaixa*/, aRecNo /*aNCC_RA*/, /*aLiquidacao*/, {lContabiliza, lAglutina, lDigita, .F., .F., .T.} /*aParam*/,;
			                  /*bBlock*/, /*aEstorno*/, /*aSE1Dados*/, /*aNewSE1*/, SE1->E1_VALOR /*nSaldoComp*/, /*aCpoUser*/, aRecVlr /*aNCC_RAvlr*/,;
			                  /*nSomaCheq*/, /*nTaxaCM*/, /*aTxMoeda*/, /*lConsdAbat*/, /*lRetLoja*/, /*cProcComp*/)
			SetFunName(cFunName)
		Else
			lRet := MaIntBxCR(3 /*nCaso*/, {aRegSE1[1]} /*aSE1*/, /*aBaixa*/, aRecNo /*aNCC_RA*/, /*aLiquidacao*/, {lContabiliza, lAglutina, lDigita, .F., .F., .T.} /*aParam*/,;
			                  /*bBlock*/, /*aEstorno*/, /*aSE1Dados*/, /*aNewSE1*/, SE1->E1_VALOR /*nSaldoComp*/, /*aCpoUser*/, aRecVlr /*aNCC_RAvlr*/,;
			                  /*nSomaCheq*/, /*nTaxaCM*/, /*aTxMoeda*/, /*lConsdAbat*/, /*lRetLoja*/, /*cProcComp*/)
		EndIf
	Endif
	//Recupera o HeadProva da NFS, caso a compensação do adiantamento (RA) também tenha sido contabilizada em outro HeadProva pelo Financeiro...
	If	nHdlPrv == 65536 .AND. Len(_aDPrv461) > 0 .AND. CtbInUse()
		RodaProva(nHdlPrv /*nHdlPrv*/, 0 /*nTotal*/, _aDPrv461 /*aDadosProva*/)
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Retorna o pergunte da MATA461                         ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	Pergunte("MT460A",.F.)

	If lRet .and. Len(aCodPedidos) > 0
		SE1->(MsGoTo(aRegSE1[1]))
		If SE1->(Recno()) = aRegSE1[1]
			If SE1->E1_VALOR != SE1->E1_SALDO .and. !Empty(SE1->E1_BAIXA) // verifica se o titulo foi baixado
				For nI := 1 To Len(aCodPedidos)

					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³Ajuste do saldo do relacionamento no Financeiro³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				    FPedAdtGrv( "R", 4, aCodPedidos[nI, 1], aCodPedidos[nI, 2], lCmp, cDoc, cSerieId )
				Next nI

				// grava registro do titulo principal na tabela FR3
				SE1->(MsGoTo(aRegSE1[1]))
				If SE1->(Recno()) = aRegSE1[1]
					FaGrvFR3("R",SE1->E1_PEDIDO,SE1->E1_PREFIXO,SE1->E1_NUM,SE1->E1_PARCELA,SE1->E1_TIPO,SE1->E1_CLIENTE,SE1->E1_LOJA,SE1->E1_VALOR,cDoc,cSerieId)
				Endif
			Endif
		Endif
	Endif
EndIf

RestArea(aAreaSE1)
RestArea(aAreaSC5)
RestArea(aAreaSC9)
RestArea(aArea)

Return .T.


/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³A461NPedido ³ Autor ³Totvs                ³ Data ³09.04.2010³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Exibe tela para indicar ao usuario que Documento de Saida   ³±±
±±³          ³nao tem adiantamento relacionado.                           º±±
±±³          ³Permite relacionar adiantamentos ao Documento.              º±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpL1: Indica se relacionou adiantamento ao Pedido          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpC1: Numero do Pedido de Venda                            ³±±
±±³          ³ExpC2: Codigo de cliente                                    ³±±
±±³          ³ExpC3: Loja do cliente                                      ³±±
±±³          ³ExpN4: Valor do adiantamento relacionado ao Pedido          ³±±
±±³          ³ExpN5: Valor da primeira parcela do titulo a receber        ³±±
±±³          ³ExpC6: Condicao de Pagamento                                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Observacao³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³   DATA   ³ Programador   ³Manutencao Efetuada                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³               ³                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function A461NPedido(cNumPed, cCliente, cLoja, nValAdt, nValParc1, cCondPagto, nMoedaPed)

Local aArea			:= GetArea()
Local cGetNumero	:= cNumPed
Local cGetCliente	:= cCliente
Local cGetLoja	 	:= cLoja
Local cGetNome		:= Posicione("SA1", 1, xFilial("SA1")+cCliente+cLoja, "A1_NOME")
Local oGetNumero
Local oGetCliente
Local oGetLoja
Local oGetNome
Local aRecnoSE1 	:= FPedAdtPed( "R", {cNumPed}, .F. )
Local lRet			:= .T.
Local oDlg				// Dialog Principal

Default nMoedaPed		:= 0
DEFINE MSDIALOG oDlg TITLE STR0059 FROM A461PosTla(178),A461PosTla(181) TO A461PosTla(321),A461PosTla(597) PIXEL // "Valor do Adiantamento não informado"

	// Cria as Groups do Sistema
	@ A461PosTla(003),A461PosTla(002) TO A461PosTla(060),A461PosTla(155) LABEL STR0060 PIXEL OF oDlg // "Informações do Pedido"

	// Cria Componentes Padroes do Sistema
	@ A461PosTla(015),A461PosTla(009) Say STR0062 Size A461PosTla(018),A461PosTla(008) COLOR CLR_BLACK PIXEL OF oDlg // "Número"
	@ A461PosTla(015),A461PosTla(050) MsGet oGetNumero Var cGetNumero Size A461PosTla(060),A461PosTla(009) COLOR CLR_BLACK Picture "@!" PIXEL OF oDlg When .F.

	@ A461PosTla(030),A461PosTla(009) Say STR0063 Size A461PosTla(018),A461PosTla(008) COLOR CLR_BLACK PIXEL OF oDlg // "Cliente"
	@ A461PosTla(030),A461PosTla(050) MsGet oGetCliente Var cGetCliente Size A461PosTla(060),A461PosTla(009) COLOR CLR_BLACK Picture "@!" PIXEL OF oDlg When .F.
	@ A461PosTla(030),A461PosTla(120) MsGet oGetLoja Var cGetLoja Size A461PosTla(027),A461PosTla(009) COLOR CLR_BLACK Picture "@!" PIXEL OF oDlg When .F.

	@ A461PosTla(045),A461PosTla(009) Say STR0064 Size A461PosTla(018),A461PosTla(008) COLOR CLR_BLACK PIXEL OF oDlg // "Nome"
	@ A461PosTla(045),A461PosTla(050) MsGet oGetNome Var cGetNome Size A461PosTla(097),A461PosTla(009) COLOR CLR_BLACK Picture "@!" PIXEL OF oDlg When .F.

	// Botoes disponiveis na tela
	@ A461PosTla(007),A461PosTla(167) Button STR0065 Size A461PosTla(037),A461PosTla(012) PIXEL OF oDlg ACTION (lRet:= .F.,oDlg:End()) // "Ignora Pedido"
	@ A461PosTla(025),A461PosTla(167) Button STR0066 Size A461PosTla(037),A461PosTla(012) PIXEL OF oDlg ACTION (A410Adiant(cNumPed, cCondPagto, nValParc1, aRecnoSE1, .F., cCliente, cLoja, .T., Nil, Nil, Nil, Nil, Nil, Nil, nMoedaPed),oDlg:End())	 // "Adiantamentos"

	@ A461PosTla(062),A461PosTla(005) Say STR0067 Size A461PosTla(158),A461PosTla(008) COLOR CLR_BLACK PIXEL OF oDlg	 // "Para alterar o valor do Adiantamento, clique em Adiantamentos."
ACTIVATE MSDIALOG oDlg CENTERED

RestArea(aArea)

Return(lRet)


/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³A461PosTla  ³ Autor ³Totvs                ³ Data ³09.04.2010³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Funcao responsavel por manter o Layout independente da      ³±±
±±³          ³resolucao horizontal do Monitor do Usuario.                 º±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpN1: Numero da Coordenada                                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpN1: Numero da Coordenada                                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Observacao³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³   DATA   ³ Programador   ³Manutencao Efetuada                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³               ³                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function A461PosTla(nTam)

Local nHRes	:=	oMainWnd:nClientWidth	// Resolucao horizontal do monitor
	If nHRes == 640	// Resolucao 640x480 (soh o Ocean e o Classic aceitam 640)
		nTam *= 0.8
	ElseIf (nHRes == 798).Or.(nHRes == 800)	// Resolucao 800x600
		nTam *= 1
	Else	// Resolucao 1024x768 e acima
		nTam *= 1.28
	EndIf

Return Int(nTam)


/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³A461NP1Vlr  ³ Autor ³Totvs                ³ Data ³09.04.2010³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Retorna o valor da primeira parcela do pedido.              ³±±
±±³          ³Utiliza Qtde liberada * Preco de venda do item para o cal-  ³±±
±±³          ³culo.                                                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpN1: Valor da parcela                                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpC1: Numero do Pedido de Venda                            ³±±
±±³          ³ExpA2: Array com os itens a serem gerados                   ³±±
±±³          ³ExpA3: Array usado na condicao de pagamento                 ³±±
±±³          ³ExpN4: Valor do acrescimo financeiro                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Observacao³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³   DATA   ³ Programador   ³Manutencao Efetuada                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³               ³                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function A461NP1Vlr(cNumPedido, aPvlNfs, aImpVarDup, nAcresTot, aTitulo, lTP9IPI, lMV_CMP330, aRegSE1)

Local aArea	:= GetArea()
Local aAreaSC5 	:= SC5->(GetArea())
Local aAreaSE4	:= SE4->(GetArea())
Local nValor	:= 0
Local nValTot	:= 0
Local cCondPagto:= ""
Local cQ 		:= ""
Local lIPI      := SuperGetMv("MV_IPITP9",.F.,"N") == "S"
Local nQtdParc	:= 0
Local nQtdTit	:= 0

Default lMV_CMP330 := .F.
Default lTP9IPI := .F.
Default aRegSE1 := {}

cQ	:= "SELECT R_E_C_N_O_ AS SC9RECNO,C9_QTDLIB,C9_PRCVEN "
cQ += "FROM "+RetSqlName("SC9")+" "
cQ += "WHERE C9_FILIAL = '"+xFilial("SC9")+"' "
cQ += "AND C9_PEDIDO = '"+cNumPedido+"' "
cQ += "AND D_E_L_E_T_= ' ' "

cQ := ChangeQuery(cQ)

dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQ),"TRBSC9",.T.,.T.)

TcSetField("TRBSC9","C9_QTDLIB","N",GetSx3Cache("C9_QTDLIB","X3_TAMANHO"),GetSx3Cache("C9_QTDLIB","X3_DECIMAL"))
TcSetField("TRBSC9","C9_PRCVEN","N",GetSx3Cache("C9_PRCVEN","X3_TAMANHO"),GetSx3Cache("C9_PRCVEN","X3_DECIMAL"))

While TRBSC9->( !Eof() )
	If aScan(aPvlNfs, {|x| x[8]==TRBSC9->SC9RECNO}) > 0
		nValTot += a410Arred(TRBSC9->C9_QTDLIB * TRBSC9->C9_PRCVEN,"D2_TOTAL")
	EndIf
	TRBSC9->( DBSkip() )
Enddo
TRBSC9->(dbCloseArea())

SC5->(DbSetOrder(1)) // C5_FILIAL+C5_NUM
If SC5->(DbSeek( xFilial("SC5")+cNumPedido ))
	If aScan(aPvlNfs, {|x| x[7]==.F.}) > 0
		nValTot += SC5->C5_FRETE+SC5->C5_SEGURO+SC5->C5_DESPESA 
	EndIf
	cCondPagto	:= SC5->C5_CONDPAG
	//Soma o valor do IPI no total do pedido, caso a condição de pagamento seja tipo 9 por valor.
	If lIPI .And. Valtype("aTitulo") != "U" .And. aTitulo[_VLRIPI_] > 0
		If cCondPagto <> SE4->E4_CODIGO
			SE4->(dbGoto(aPvlNfs[aScan(aPvlNfs,{|x| x[1] == cNumPedido}),11]))
		EndIf
		If SE4->E4_TIPO == "9" .And. AllTrim(SE4->E4_COND) == "0"
			nValTot += aTitulo[_VLRIPI_]
			lTP9IPI := .T.
		EndIf
	EndIf
	
	If Valtype("aTitulo") != "U" .And. aTitulo[_VLRSOL_] > 0 .And. cCondPagto == SE4->E4_CODIGO .And. SE4->E4_TIPO == "9" .And. AllTrim(SE4->E4_COND) == "0"
		nValTot += aTitulo[_VLRSOL_]
	EndIf

	If lMV_CMP330 .And. !lTP9IPI
		If Valtype("aTitulo") != "U"
			nValTot += aTitulo[_VLRIPI_]
			nValTot += aTitulo[_VLRSOL_]
		EndIf
		aVenc := Condicao(nValTot,cCondPagto,aTitulo[_VLRIPI_],dDataBase,aTitulo[_VLRSOL_],aImpVarDup,,nAcresTot)
	Else
		aVenc := Condicao(nValTot,cCondPagto,0.00,dDataBase,0.00,aImpVarDup,,nAcresTot)
	EndIf

	nQtdParc := Len(aVenc)
	nQtdTit	 := Len(aRegSE1)

	//As quantidades de parcelas ou valores vão ser diferentes, quando for utilizado o PE: MT461VCT
	If nQtdParc > 0 .And. nQtdTit > 0
		//Posiciona no primeiro título ou parcela que já foi gerada
		SE1->(MsGoTo(aRegSE1[1]))
		//Se a quantidade de parcela ou valor for diferente dos títulos gerados na SE1,
		//pega o valor do SE1 em vez da que foi calculada pela função Condicao() acima. 
		If (nQtdParc <> nQtdTit) .Or. (SE1->E1_VALOR <> aVenc[1,2])
			nValor := SE1->E1_VALOR
		Else
			nValor := aVenc[1,2]
		EndIf
	EndIf
EndIf

RestArea(aAreaSE4)
RestArea(aAreaSC5)
RestArea(aArea)

Return(nValor)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³A461ART65 ºAutor  ³Juliana Taveira     º Data ³  25/06/10   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Tratamento artigo 65 do RICMS ST / PR, onde a venda diaria º±±
±±º          ³ de produtos que se enquadram no artigo, for superior a qtd º±±
±±º          ³ definida no parametro MV_QART65, o ICMS será recolhido     º±±
±±º          ³ antecipadamente(geracao de guia de recolhimento)			  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³ExpC1: Codigo do cliente			                          º±±
±±º          ³ExpC2: Loja do cliente					                  º±±
±±º          ³ExpD3: Data de Emissao					                  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º ±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function A461ART65(cCli,cLj,dDtEmis,cDoc,cSer,cNumero, aGnre, aRecTit, lConfTit, cUf)
Local cAliasSD2 := 	"TRBSD2"
Local cUnMed    := 	SuperGetMV("MV_UNAT65",,"")
Local cMvEstado :=	SuperGetMV("MV_ESTADO")
Local cLcPadTit := 	""
Local nMvqart65 :=  SuperGetMV("MV_QART65",,0)
Local nQtd      := 	0
Local nIcm      := 	0
Local nMes      :=	0
Local nAno		:=	0
Local aDatas    := {}
Local aDSF2     := {}

Local dDtIni	:= ctod("//")
Local dDtFim    := ctod("//")
Local dDtVenc   := ctod("//")
Local lLancCont := .F.
Local lCalc     :=  Iif(nMvqart65 > 0 .and. !Empty(cUnMed) .and. Alltrim(cMvEstado) == "PR",.T.,.F.)
Local lQuery 	:=  .F.
Local lGRec     :=  .F.
Local lTit      := 	.F.
Local lArt65    :=	.F.

Local cQrySelect := ""

Default  cCli 	 := ""
Default  cLj 	 := ""
Default  cDoc    := ""
Default  cSer    := ""
Default  cUf     := ""
Default  dDtEmis := dDatabase

If lCalc
	 #IFDEF TOP
		If (TcSrvType ()<>"AS/400")
			lQuery := .T.
		EndIf
	#ENDIF
	If lQuery
		cQrySelect := "%D2_UM, D2_QUANT, D2_SEGUM, D2_QTSEGUM, D2_VALICM%"
		cAliasSD2	:=	GetNextAlias()
		BeginSql Alias cAliasSD2
			SELECT %Exp:(cQrySelect)%
			FROM %Table:SD2% SD2
			JOIN %table:SB1% SB1 ON SB1.B1_FILIAL = %xFilial:SB1% AND SB1.B1_COD = SD2.D2_COD
			AND SB1.B1_RICM65 = "1" AND SB1.%NotDel%
			WHERE
			SD2.D2_FILIAL = %xFilial:SD2% AND
			SD2.D2_CLIENTE = %Exp:(cCli)% AND
			SD2.D2_LOJA = %Exp:(cLj)% AND
			SD2.D2_EMISSAO = %Exp:dTos(dDtEmis)% AND
			SD2.D2_TIPO = 'N' AND SD2.D2_VALICM > 0 AND
			SD2.%NotDel%
		EndSql

		DbSelectArea(cAliasSD2)
		(cAliasSD2)->(DbGoTop())
		While !(cAliasSD2)->(Eof())
			If Alltrim((cAliasSD2)->D2_UM) == Alltrim(cUnMed)
				nQtd := nQtd + (cAliasSD2)->D2_QUANT
				nIcm := nIcm + (cAliasSD2)->D2_VALICM
			ElseIf Alltrim((cAliasSD2)->D2_SEGUM) == Alltrim(cUnMed)
				nQtd := nQtd + (cAliasSD2)->D2_QTSEGUM
				nIcm := nIcm + (cAliasSD2)->D2_VALICM
			EndIf
			(cAliasSD2)->(DbSkip())
		EndDo
	Else
		DbSelectArea("SD2")
		SD2->(DbSetOrder(5))
		SD2->(DbSeek (xFilial("SD2") + Dtos(dDtEmis)))
		While !SD2->(Eof()) .and. SD2->D2_FILIAL == xFilial("SD2") .and. SD2->D2_EMISSAO == dDtEmis
			If SD2->D2_CLIENTE == cCli .and. SD2->D2_LOJA == cLj .and. SD2->D2_TIPO == "N" .and. SD2->D2_VALICM > 0
				DbSelectArea("SB1")
				SB1->(DbSetOrder(1))
				If SB1->(DbSeek(xFilial("SB1")+SD2->D2_COD))
					If SB1->B1_RICM65 == "1"
						If Alltrim(SD2->D2_UM) == Alltrim(cUnMed)
							nQtd := nQtd + SD2->D2_QUANT
							nIcm := nIcm + SD2->D2_VALICM
						ElseIf Alltrim(SD2->D2_SEGUM) == Alltrim(cUnMed)
							nQtd := nQtd + SD2->D2_QTSEGUM
							nIcm := nIcm + SD2->D2_VALICM
						EndIf
					EndIf
				EndIf
			EndIf
			SD2->(DbSkip())
		EndDo
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Verifica se a quantidade e maior que a quantidade maxima para³
	//³dispensa definido no parametro MV_QART65 e se o valor de ICMS³
	//³do periodo e maior que zero									³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If nQtd > nMvqart65
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Verifica se ja foi gerado guia de recolhimento para o destinatario ³
		//³no dia, caso ja tenha sido abater o valor da guia gerada           ³
		//³anteriormente.                                                     ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		DbSelectArea("SF6")
		SF6->(DbSetOrder(2))
		If SF6->(DbSeek(xFilial("SF6")+Alltrim(cMvEstado)+dtos(dDtEmis)))
			While !SF6->(Eof()) .and. SF6->F6_FILIAL == xFilial("SF6") .and. SF6->F6_DTARREC == dDtEmis
				If SF6->F6_CLIFOR == cCli .and. SF6->F6_LOJA == cLj .and. SF6->F6_TIPOIMP == "1" .and. SF6->F6_OPERNF == "2"
					nIcm := nIcm - SF6->F6_VALOR
				EndIf
				SF6->(DbSkip())
			EndDo
		EndIf
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Gera guia de recolhimento ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If nIcm >0
			nMes      := Month(dDtEmis)
			nAno      := Year(dDtEmis)
			aDatas    := DetDatas(nMes,nAno,3,1)
			dDtIni	  := aDatas[1]
			dDtFim	  := aDatas[2]
			dDtVenc	  := DataValida(aDatas[2]+1,.t.)
			lLancCont := (MV_PAR03==1)
			lGRec     := Iif(ValType(MV_PAR18)<>"N",.F.,(mv_par18==1))
			lTit      := Iif(ValType(MV_PAR17)<>"N",.F.,(mv_par17==1))
			lArt65 	  := .T.

			aadd(aDSF2,{cDoc,cSer,cCli,cLj,"N","2",Alltrim(cMvEstado)})
			If len(aDSF2)>0
				GravaTit(lTit,nIcm,"ICMS","IC",cLcPadTit,dDtIni,dDtFim,dDtVenc,1,lGRec,nMes,nAno,nIcm,0,"MATA460A",lLancCont,@cNumero,@aGNRE,,,cUf,,,,,@aRecTit,@lConfTit,0,aDSF2,lArt65)
			EndIf
		EndIf
	EndIf
EndIf
If lQuery
	dbSelectArea(cAliasSD2)
	dbCloseArea()
EndIf
Return()

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³a461LstPreºAutor  ³Vendas Cliente      º Data ³  02/17/11   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Cria a Nota Fiscal de Remessa e um novo registro na tabela  º±±
±±º          ³de conta corrente da lista de presentes					  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ LOJA846													  º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/

Static Function a461LstPre(aPvlnfs,cTypeDoc)

/*======================================\
|	Elementos do Array aPvlnfs			|
|---------------------------------------|
|aPvlnfs[01] - Numero do Pedido de Venda|
|aPvlnfs[02] - Item do Pedido de Venda	|
|aPvlnfs[03] - Sequencia de Liberacao	|
|aPvlnfs[04] - Quantidade Liberada		|
|aPvlnfs[05] - Preco de Venda			|
|aPvlnfs[06] - Codigo do Produto		|
|aPvlnfs[07] - TES com ISS				|
|aPvlnfs[08] - Recno do SC9				|
|aPvlnfs[09] - Recno do SC5				|
|aPvlnfs[10] - Recno do SC6				|
|aPvlnfs[11] - Recno do SE4				|
|aPvlnfs[12] - Recno do SB1				|
|aPvlnfs[13] - Recno do SB2				|
|aPvlnfs[14] - Recno do SF4				|
|aPvlnfs[15] - Deposito					|
|aPvlnfs[16] - Recno do DAK (Não usado)	|
|aPvlnfs[17] - Quantidade Liberada 2 UN	|
\======================================*/

Local aArea		:= GetArea()																		//Grava a area Atual
Local aAreaSF2	:= SF2->( GetArea() )																//Grava a area da tabela SF2
Local aAreaSD2	:= SD2->( GetArea() )																//Grava a area da tabela SD2
Local aAreaSA1	:= SA1->( GetArea() )																//Grava a area da tabela SA1
Local cChaveSF2	:= xFilial("SD2") + SF2->F2_DOC + SF2->F2_SERIE + SF2->F2_CLIENTE + SF2->F2_LOJA	//Chave de pesquisa para a tabela SD2
Local aCab		:= {}																				//Array de cabecalho do EXECAUTO
Local aItens	:= {}																				//Array dos itens do EXECAUTO
Local aItAux	:= {}																				//Array auxiliar para os itens do EXECAUTO
Local cLista	:= GetAdvFVal("SC6","C6_CODLPRE",xFilial("SC6") + aPvlnfs[1][1] + aPvlnfs[1][2] + aPvlnfs[1][6],1,"")	//Numero da Lista de Presente
Local lRet		:= .T.																				//Variavel de retorno da funcao
Local cTES		:= ""																				//TES usada no item da NF de Remessa
Local cTpOper	:= SuperGetMV("MV_LJLPTIR",,"")														//Tipo da Operacao para a NF de Remessa (TES Inteligente)
Local cTESPad	:= SuperGetMV("MV_LJLPTSR",,"")														//TES padrao para a NF de Remessa
Local cSerieNFR	:= SuperGetMV("MV_LJSENFR",,"")														//TES padrao para a NF de Remessa
Local cNumNFR	:= ""																				//Numero da Nota Fiscal de Saida
Local aRegCtaC	:= {}																				//Array para criar o registro de Debito na tabela de conta corrente
Local aArea2		:= {}
Local aAreaSM0	:= {}
Local aTimeUf		:= {}
Local cHoraRMT	:= ""

Default cTypeDoc := ""

Private lMsErroAuto := .F.																			//Variavel usada para o retorno da EXECAUTO
Private l920Inclui	:= .T.																			//Variavel usada para tratamento do execauto

cHoraRMT := SuperGetMv("MV_HORARMT",.F.)
If ValType(cHoraRMT) == "L"
	If cHoraRMT
		cHoraRMT := "1"
	Else
		cHoraRMT := "2"
	EndIf
Else
	If cHoraRMT == NIL
		cHoraRMT := "2"
	EndIf
EndIf

//Caso o parametro de Tipo de Operacao e TES estejam em branco, retorna como falso na funcao
If Empty(cTpOper) .And. Empty(cTESPad)
	lRet		:= .F.
ElseIf !Empty(cLista)	//Caso o codigo da lista de presentes esteja em branco, retorna para a funcionalidade normal
	//Verifico se a variavel esta em branco e nesse caso busco a serie padrao ja selecionada
	cSerieNFR	:= IIF(Empty(cSerieNFR),SerieNfId("SF2",2,"F2_SERIE"),cSerieNFR)

	//Verifico como esta parametrizado o sistema para busca do numero da Nota Fiscal
	cNumNFR := MA461NumNf(NIL,cSerieNFR,NIL,NIL, SerieNfId("SF2",4,"F2_SERIE",dDataBase,SF2->F2_ESPECIE,cSerieNFR),cTypeDoc )
	
	DbSelectArea("ME4")
	DbSetOrder(4)	//ME4_FILIAL+ME4_CODIGO+ME4_PEDIDO+ME4_ITPED+ME4_ITLST

	DbSelectArea("ME1")
	DbSetOrder(2)	//ME1_FILIAL+ME1_CODIGO+ME1_TIPO+ME1_CODCLI+ME1_LOJCLI
	If ME1->( DbSeek( xFilial("ME1") + cLista) )
		DbSelectArea("SA1")
		DbSetOrder(1)	//A1_FILIAL+A1_COD+A1_LOJA
		DbSeek( xFilial("SA1") + ME1->ME1_CODCLI + ME1->ME1_LOJCLI)

		aAdd(aCab,{"F2_TIPO"	,"N"							})
		aAdd(aCab,{"F2_FORMUL"	,"S"							})
		aAdd(aCab,{"F2_DOC"		,cNumNFR						})
		aAdd(aCab,{"F2_SERIE"	,cSerieNFR						})
		aAdd(aCab,{"F2_CLIENTE"	,ME1->ME1_CODCLI				})
		aAdd(aCab,{"F2_LOJA"	,ME1->ME1_LOJCLI				})
		aAdd(aCab,{"F2_TIPOCLI"	,SA1->A1_TIPO					})
		aAdd(aCab,{"F2_ESPECIE"	,SF2->F2_ESPECIE				})
		aAdd(aCab,{"F2_DESCONT"	,SF2->F2_DESCONT				})
		aAdd(aCab,{"F2_VALBRUT"	,SF2->F2_VALBRUT				})
		aAdd(aCab,{"F2_VALFAT"	,SF2->F2_VALFAT					})
		aAdd(aCab,{"F2_FRETE"	,SF2->F2_FRETE					})
		aAdd(aCab,{"F2_SEGURO"	,SF2->F2_SEGURO					})
		aAdd(aCab,{"F2_DESPESA"	,SF2->F2_DESPESA				})
		aAdd(aCab,{"F2_PREFIXO"	,Space(TamSX3("F2_PREFIXO")[1])	})

		//Parametro MV_HORARMT habilitado pega a hora do smartclient, do servidor ou do Estado da Filial
		If cHoraRMT == "1"
			SF2->F2_EMISSAO    := dDataBase
			SF2->F2_HORA       := SubStr(GetRmtTime(),1,5)

		ElseIf cHoraRMT == "3"
			If cPaisLoc == "BRA"
				aArea2	:= GetArea()
				dbSelectArea("SM0")
				aAreaSM0	:= GetArea()
				dbSetOrder(1)
				If dbSeek(cEmpAnt+cFilAnt)
					aTimeUf := A103HORA()
				EndIf
				RestArea(aAreaSM0)
				RestArea(aArea2)

				aAdd(aCab,{"F2_EMISSAO"	,aTimeUf[1]})
				aAdd(aCab,{"F2_HORA"	,SubStr(aTimeUf[2],1,5)})
			Else
				aAdd(aCab,{"F2_EMISSAO"	,dDataBase})
				aAdd(aCab,{"F2_HORA"	,SubStr(GetRmtTime(),1,5)})
			EndIf

		Else // 2- Default (data do servidor)
			aAdd(aCab,{"F2_EMISSAO"	,dDataBase})
			aAdd(aCab,{"F2_HORA"	,SubStr(Time(),1,5)})
		EndIf

		aAdd(aCab,{"F2_CLIENT"	,SF2->F2_CLIENT})
		aAdd(aCab,{"F2_LOJENT"	,SF2->F2_LOJENT})

		DbSelectArea("SD2")
		DbSetOrder(3)	//D2_FILIAL+D2_DOC+D2_SERIE+D2_CLIENTE+D2_LOJA+D2_COD+D2_ITEM
		While !SD2->( Eof() ) .And. cChaveSF2 == SD2->D2_FILIAL + SD2->D2_DOC + SD2->D2_SERIE + SD2->D2_CLIENTE + SD2->D2_LOJA
			aItAux := {}
			If !Empty(cTpOper)
				cTES := MaTESInt(2,cTpOper,ME1->ME1_CODCLI,ME1->ME1_LOJCLI,"C",SD2->D2_COD)
			Else
				cTES := cTESPad
			EndIf

			aAdd(aItAux,{"D2_ITEM"		,SD2->D2_ITEM	,Nil})
			aAdd(aItAux,{"D2_COD"		,SD2->D2_COD	,Nil})
			aAdd(aItAux,{"D2_QUANT"		,SD2->D2_QUANT	,Nil})
			aAdd(aItAux,{"D2_PRCVEN"	,SD2->D2_PRCVEN	,Nil})
			aAdd(aItAux,{"D2_TOTAL"		,SD2->D2_TOTAL	,Nil})
			aAdd(aItAux,{"D2_TES"		,cTES			,Nil})
			aAdd(aItAux,{"D2_CODLPRE"	,SD2->D2_CODLPRE,Nil})
			aAdd(aItAux,{"D2_ITLPRE"	,SD2->D2_ITLPRE	,Nil})
			aAdd(aItAux,{"D2_PEDIDO"	,SD2->D2_PEDIDO	,Nil})
			aAdd(aItAux,{"D2_ITEMPV"	,SD2->D2_ITEMPV	,Nil})
			aAdd(aItens,aItAux)

			//Posiciona na tabela de conta corrente para atualizar o status do credito
			If ME4->( DbSeek( xFilial("ME4") + SD2->D2_CODLPRE + SD2->D2_PEDIDO + SD2->D2_ITEMPV + SD2->D2_ITLPRE ) )
				While	ME4->(!EOF()) .And. ;
						AllTrim(ME4->ME4_CODIGO) == AllTrim(cLista) .And.;
						xFilial("ME4")	+	SD2->D2_CODLPRE	+	SD2->D2_PEDIDO	+	SD2->D2_ITEMPV	+	SD2->D2_ITLPRE == ;
						ME4->(ME4_FILIAL	+	ME4_CODIGO			+	ME4_PEDIDO			+	ME4_ITPED			+	ME4_ITLST)

					If RecLock("ME4",.F.)
						If ME4->ME4_TIPO == "1" //Credito
							ME4->ME4_TIPREG := "4"
						ElseIf ME4->ME4_TIPO == "4" //Debito
							ME4->(DBDelete())
						EndIf
						ME4->( MsUnLock() )
					EndIf
					ME4->(DBSkip())
				End

				//Alimenta o array com os itens que serao gravados na tabela de Conta Corrente da Lista de Presentes
				aRegCtaC	:= {}
				aAdd(aRegCtaC,SD2->D2_CODLPRE)		//01 - Codigo da Lista
				aAdd(aRegCtaC,SD2->D2_ITLPRE)		//02 - Item da Lista
				aAdd(aRegCtaC,SD2->D2_COD)			//03 - Codigo do Produto
				aAdd(aRegCtaC,SD2->D2_QUANT)		//04 - Quantidade
				aAdd(aRegCtaC,SD2->D2_TOTAL)		//05 - Valor
				aAdd(aRegCtaC,cEmpAnt)				//06 - Empresa Original
				aAdd(aRegCtaC,cFilAnt)				//07 - Filial Original
				aAdd(aRegCtaC,Nil)					//08 - Numero do Orcamento
				aAdd(aRegCtaC,Nil)					//09 - Item do Orcamento
				aAdd(aRegCtaC,SD2->D2_PEDIDO)		//10 - Numero do Pedido de Venda
				aAdd(aRegCtaC,SD2->D2_ITEMPV)		//11 - Item do Pedido de Venda
				aAdd(aRegCtaC,cNumNFR)				//12 - Numero do Documento
				aAdd(aRegCtaC,cSerieNFR)			//13 - Serie do Documento
				aAdd(aRegCtaC,dDataBase)			//14 - Emissao do documento/titulo
				aAdd(aRegCtaC,NIL)					//15 - Prefixo do Titulo
				aAdd(aRegCtaC,NIL)					//16 - Numero do Titulo
				aAdd(aRegCtaC,NIL)					//17 - Parcela do Titulo
				aAdd(aRegCtaC,NIL)					//18 - Tipo do Titulo
				aAdd(aRegCtaC,SD2->D2_CLIENTE)		//19 - Codigo do Cliente
				aAdd(aRegCtaC,SD2->D2_LOJA)			//20 - Loja do Cliente

				//Chama a rotina para gerar o Debito da conta corrente
				If !Lj8GeraCC(aRegCtaC,3)
					lRet := .F.
					RollBackSX8()
					Exit
				EndIf
			EndIf
			SD2->( dbSkip() )
		End

		If lRet
			MSExecAuto({|x,y,z| Mata920(x,y,z)},aCab,aItens,3) //Inclusao

			If lMsErroAuto
				MostraErro()
				lRet := .F.
			EndIf
		EndIf
	Else
		lRet := .F.
	EndIf
EndIf

RestArea(aArea)
RestArea(aAreaSF2)
RestArea(aAreaSD2)
RestArea(aAreaSA1)

Return lRet

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³MaRatDesp ³ Autor ³Alexandre Inacio Lemes ³ Data ³13/09/2011³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Funcao destinada a atender o parametro MV_VALDESP que se    ³±±
±±³          ³igual a .T. deve utilizar o rateio de despesas acessorias   ³±±
±±³          ³FRETE/SEGURO/DESPESA realizado pela MATXFIS sobrepondo o ra ³±±
±±³          ³teio realizado pelo MATA461 atraves da alteracao do array   ³±±
±±³          ³aRateio.Esta funcao altera o array aRateio nestas despesas  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ aPvlNfs : Array com os pedidos de vendas liberados para NFS³±±
±±³          ³ aRateio : Array contendo o Rateio de Despesas do MATA461   ³±±
±±³          ³ lReajuste: Variavel logica indicando Reajuste              ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/

Static Function MaRatDesp(aPvlNfs,aRateio,lReajuste,dDataMoe)

Local aArea		:= GetArea()
Local aPvlSD2	:= {}
Local nItem     := 0
Local lTrbGen   := IIf(_lChkTrbGen, ChkTrbGen("SD2","D2_IDTRIB"), .F.)

Default dDataMoe := dDataBase

If Empty(dDataMoe)
	dDataMoe := dDatabase
Endif

For nItem := 1 to Len(aPvlNfs)

	aPvlSD2	:= aPvlNfs[nItem]
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Posiciona Registros                                                     ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	dbSelectArea("SC9")
	dbSetOrder(1)
	MsGoto(aPvlSd2[8])

	dbSelectArea("SC5")
	dbSetOrder(1)
	MsGoto(aPvlSD2[9])

	dbSelectArea("SC6")
	dbSetOrder(1)
	MsGoto(aPvlSD2[10])

	dbSelectArea("SE4")
	dbSetOrder(1)
	MsGoto(aPvlSd2[11])

	dbSelectArea("SB1")
	dbSetOrder(1)
	MsGoto(aPvlSd2[12])

	dbSelectArea("SB2")
	dbSetOrder(1)
	MsGoto(aPvlSd2[13])

	dbSelectArea("SF4")
	dbSetOrder(1)
	MsGoto(aPvlSd2[14])

	If nItem == 1
		MaFisIni(SC5->C5_CLIENTE,SC5->C5_LOJACLI,If(SC5->C5_TIPO$'DB',"F","C"),SC5->C5_TIPO,SC5->C5_TIPOCLI,aRelImp,,,,'MATA461',,,,,,,,,,,SC6->C6_NUM,,,,,SC5->C5_TPFRETE,,,,,,,lTrbGen)
    EndIf

	MaFisIniLoad(nItem,{SC6->C6_PRODUTO,;	//IT_PRODUTO
	                    SC6->C6_TES,; 		//IT_TES
	                    "",;				//IT_CODISS
	                    aPvlNfs[nItem][4],;	//IT_QUANT
	                    SC6->C6_NFORI,; 	//IT_NFORI
	                    SC6->C6_SERIORI,; 	//IT_SERIORI
	                    SB1->(RecNo()),;	//IT_RECNOSB1
	                    SF4->(RecNo()),;    //IT_RECNOSF4
						0,;                 //IT_RECORI
						"",;                //IT_LOTECTL
						"",;         	    //IT_NUMLOTE
						"",;                //IT_PRDFIS
						0,;                 //IT_RECPRDF
						IIf(type("SC6->C6_OPER") == "C",SC6->C6_OPER ,"")})//IT_TPOPER

	MaFisTes(SC6->C6_TES,SF4->(RecNo()),nItem)

	// Considerar o codigo do servico informado na SC6 quando houver alteracao.
	// Feito com MaFisAlt pois a mudanca do codigo pode resultar em uma aliquota diferente (CE1)
	// e nesta situacao eh necessario recalcular para que o trecho abaixo, que utiliza a MaAliqIss,
	// retorne a aliquota atualizada.
	If MaFisRet(nItem,"IT_CODISS") <> SC6->C6_CODISS
		MaFisAlt("IT_CODISS",SC6->C6_CODISS,nItem,.T.)
	EndIf

	nPosAIss := Ascan(aFisGet, {|x| x[1] == "IT_ALIQISS" })
	If nPosAIss > 0
		dbSelectArea("SC6")
		nAliqIss := &(aFisGet[nPosAIss][2])
		If nAliqIss == 0
			nAliqIss :=	MaAliqISS(nItem)
		EndIf
	Else
		nAliqIss :=	MaAliqISS(nItem)
	Endif

	aRateio[nItem][RT_PRECOIT]	:= MaPvPrcIt(aPvlNfs,nItem,lReajuste,aRateio[nItem],0,nAliqIss,dDataMoe)

	MaFisLoad("IT_VALMERC",aRateio[nItem][RT_PRECOIT][3]+aRateio[nItem][RT_PRECOIT][4],nItem)
	MaFisLoad("IT_PRCUNI",aRateio[nItem][RT_PRECOIT][1],nItem)
	MaFisLoad("IT_VLR_FRT",aRateio[nItem][RT_VLR_FRT],nItem)
	MaFisLoad("IT_AUTONOMO",aRateio[nItem][RT_FRETAUT],nItem)
	MaFisLoad("IT_DESCONTO",aRateio[nItem][RT_PRECOIT][4],nItem)
	MaFisLoad("IT_PESO",SB1->B1_PESO,nItem)

	MaFisRecal("",nItem)

	MaFisEndLoad(nItem,2)

Next nItem

MaFisAlt("NF_FRETE"  , SC5->C5_FRETE  )
MaFisAlt("NF_SEGURO" , SC5->C5_SEGURO )
MaFisAlt("NF_DESPESA", SC5->C5_DESPESA)

For nItem := 1 to Len(aPvlNfs)
	aRateio[nItem][RT_FRETE]  := MaFisRet(nItem,"IT_FRETE")
	aRateio[nItem][RT_SEGURO] := MaFisRet(nItem,"IT_SEGURO")
	aRateio[nItem][RT_DESPESA]:= MaFisRet(nItem,"IT_DESPESA")
Next nItem

MaFisEnd()

RestArea(aArea)

Return

//-------------------------------------
/*	Modelo de Dados
@author  	Jefferson Tomaz
@version 	P10 R1.4
@build		7.00.101202A
@since 		06/04/2011
@return 		oModel Objeto do Modelo*/
//-------------------------------------
Static Function ModelDef()
Local oModel
Local oStruSF2  := FWFormStruct(1,"SF2")
Local oStruSD2  := FWFormStruct(1,"SD2")
Local oStruRSA1 := NIL
Local oStruCSA1 := NIL
Local oStruDSA1 := NIL
Local oStruRSA4 := NIL
Local aSM0		:= FWArrFilAtu()
Local lIntGFE   := SuperGetMv('MV_INTGFE',,.F.)
Local aAux      := {}
Local aRet      := {}
Local nI        := 0
Local cFieldRel := ''
Local aRelatUsr := {}

SM0->(DbGoto(aSM0[SM0_RECNO]))

If lIntGFE
	oStruSD2:aTriggers := {}

	oStruRSA1 := FWFormStruct(1,"SA1",{|cCampo| AllTrim(cCampo)+"|" $ "A1_COD|A1_LOJA|A1_NREDUZ|A1_CGC|A1_END|A1_BAIRRO|A1_MUN|A1_EST|A1_COD_MUN|A1_CEP|"})
	oStruCSA1 := FWFormStruct(1,"SA1",{|cCampo| AllTrim(cCampo)+"|" $ "A1_COD|A1_LOJA|A1_NREDUZ|A1_CGC|"})
	oStruRSA4 := FWFormStruct(1,"SA4",{|cCampo| AllTrim(cCampo)+"|" $ "A4_COD|A4_CGC|A4_EST|A4_COD_MUN|"})
	oStruDSA1 := FWFormStruct(1,"SA1",{|cCampo| AllTrim(cCampo)+"|" $ "A1_COD|A1_LOJA|A1_NREDUZ|A1_CGC|A1_END|A1_BAIRRO|A1_MUN|A1_EST|A1_COD_MUN|A1_CEP|A1_ENDENT|A1_BAIRROE|A1_CEPE|A1_MUNE|A1_ESTE|A1_CODMUNE"})
	oStruCSA2 := FWFormStruct(1,"SA2",{|cCampo| AllTrim(cCampo)+"|" $ "A2_COD|A2_LOJA|A2_NREDUZ|A2_CGC|"})
	oStruDSA2 := FWFormStruct(1,"SA2",{|cCampo| AllTrim(cCampo)+"|" $ "A2_COD|A2_LOJA|A2_NREDUZ|A2_CGC|A2_END|A2_BAIRRO|A2_MUN|A2_EST|A2_COD_MUN|A2_CEP|"})

// ------------- Campos Virtuais para Tabela SF2 ------------------

	oStruSF2:AddField( ;                      // Ord. Tipo Desc.
	"F2_CDTPDC"                      , ;      // [01]  C   Titulo do campo
	"Cod.Tp.Doc"                     , ;      // [02]  C   ToolTip do campo
	"F2_CDTPDC"                      , ;      // [03]  C   Id do Field
	'C'                              , ;      // [04]  C   Tipo do campo
	55                               , ;      // [05]  N   Tamanho do campo
	0                                , ;      // [06]  N   Decimal do campo
	NIL                              , ;      // [07]  B   Code-block de validação do campo
	NIL                              , ;      // [08]  B   Code-block de validação When do campo
	NIL                              , ;      // [09]  A   Lista de valores permitido do campo
	NIL                              , ;      // [10]  L   Indica se o campo tem preenchimento obrigatório
	FwBuildFeature( STRUCT_FEATURE_INIPAD,'Posicione("SX5",1,xFilial("SX5")+"MQ"+AllTrim(SF2->F2_TIPO)+"S","X5_DESCRI")'), ; //[11]  B   Code-block de inicializacao do campo
	NIL                              , ;      // [12]  L   Indica se trata-se de um campo chave
	NIL                              , ;      // [13]  L   Indica se o campo pode receber valor em uma operação de update.
	.T.                              )        // [14]  L   Indica se o campo é virtual

	aAux := FwStruTrigger(;
	"F2_TIPO", ;                                                      // [01] Id do campo de origem
	"F2_CDTPDC" , ;                                                   // [02] Id do campo de destino
	'Posicione("SX5",1,xFilial("SX5")+"MQ"+AllTrim(M->F2_TIPO)+"S","X5_DESCRI")')


	oStruSF2:AddTrigger( ;
	aAux[1], ;                                                      // [01] Id do campo de origem
	aAux[2], ;                                                      // [02] Id do campo de destino
	aAux[3], ;                                                      // [03] Bloco de codigo de validação da execução do gatilho
	aAux[4] )                                                       // [04] Bloco de codigo de execução do gatilho


	oStruSF2:AddField( ;                      // Ord. Tipo Desc.
	"F2_CDCLF"                       , ;      // [01]  C   Titulo do campo
	"Class.frete"                    , ;      // [02]  C   ToolTip do campo
	"F2_CDCLFR"                      , ;      // [03]  C   Id do Field
	'C'                              , ;      // [04]  C   Tipo do campo
	5                                , ;      // [05]  N   Tamanho do campo
	0                                , ;      // [06]  N   Decimal do campo
	NIL                              , ;      // [07]  B   Code-block de validação do campo
	NIL                              , ;      // [08]  B   Code-block de validação When do campo
	NIL                              , ;      // [09]  A   Lista de valores permitido do campo
	NIL                              , ;      // [10]  L   Indica se o campo tem preenchimento obrigatório
	NIL                              , ;      // [11]  B   Code-block de inicializacao do campo
	NIL                              , ;      // [12]  L   Indica se trata-se de um campo chave
	NIL                              , ;      // [13]  L   Indica se o campo pode receber valor em uma operação de update.
	NIL                              )        // [14]  L   Indica se o campo é virtual

	oStruSF2:AddField( ;                      // Ord. Tipo Desc.
	"CGC Transp"                     , ;      // [01]  C   Titulo do campo
	"CGC Transp"                     , ;      // [02]  C   ToolTip do campo
	"F2_CGCTRP"                      , ;      // [03]  C   Id do Field
	'C'                              , ;      // [04]  C   Tipo do campo
	14                               , ;      // [05]  N   Tamanho do campo
	0                                , ;      // [06]  N   Decimal do campo
	NIL                              , ;      // [07]  B   Code-block de validação do campo
	NIL                              , ;      // [08]  B   Code-block de validação When do campo
	NIL                              , ;      // [09]  A   Lista de valores permitido do campo
	NIL                              , ;      // [10]  L   Indica se o campo tem preenchimento obrigatório
	FwBuildFeature( STRUCT_FEATURE_INIPAD,'Posicione("SA4",1,xFilial("SA4")+SF2->F2_TRANSP,"A4_CGC")' ), ;      // [11]  B   Code-block de inicializacao do campo
	NIL                              , ;      // [12]  L   Indica se trata-se de um campo chave
	NIL                              , ;      // [13]  L   Indica se o campo pode receber valor em uma operação de update.
	.T.                              )        // [14]  L   Indica se o campo é virtual

	aAux := FwStruTrigger(;
	"F2_TRANSP", ;                                                      // [01] Id do campo de origem
	"F2_CCGCTRP" , ;                                                   // [02] Id do campo de destino
	'Posicione("SA4",1,xFilial("SA4")+M->F2_TRANSP,"A4_CGC")')

	oStruSF2:AddTrigger( ;
	aAux[1], ;                                                      // [01] Id do campo de origem
	aAux[2], ;                                                      // [02] Id do campo de destino
	aAux[3], ;                                                      // [03] Bloco de codigo de validação da execução do gatilho
	aAux[4] )                                                       // [04] Bloco de codigo de execução do gatilho

	oStruSF2:AddField( ;                      // Ord. Tipo Desc.
	"CGC Redesp"                     , ;      // [01]  C   Titulo do campo
	"CGC Redesp"                     , ;      // [02]  C   ToolTip do campo
	"F2_CGCRDP"                      , ;      // [03]  C   Id do Field
	'C'                              , ;      // [04]  C   Tipo do campo
	14                               , ;      // [05]  N   Tamanho do campo
	0                                , ;      // [06]  N   Decimal do campo
	NIL                              , ;      // [07]  B   Code-block de validação do campo
	NIL                              , ;      // [08]  B   Code-block de validação When do campo
	NIL                              , ;      // [09]  A   Lista de valores permitido do campo
	NIL                              , ;      // [10]  L   Indica se o campo tem preenchimento obrigatório
	FwBuildFeature( STRUCT_FEATURE_INIPAD,'Posicione("SA4",1,xFilial("SA4")+SF2->F2_REDESP,"A4_CGC")' ), ;      // [11]  B   Code-block de inicializacao do campo
	NIL                              , ;      // [12]  L   Indica se trata-se de um campo chave
	NIL                              , ;      // [13]  L   Indica se o campo pode receber valor em uma operação de update.
	.T.                              )        // [14]  L   Indica se o campo é virtual

	aAux := FwStruTrigger(;
	"F2_REDESP", ;                                                      // [01] Id do campo de origem
	"F2_CCGCRDP" , ;                                                   // [02] Id do campo de destino
	'Posicione("SA4",1,xFilial("SA4")+M->F2_REDESP,"A4_CGC")')

	oStruSF2:AddTrigger( ;
	aAux[1], ;                                                      // [01] Id do campo de origem
	aAux[2], ;                                                      // [02] Id do campo de destino
	aAux[3], ;                                                      // [03] Bloco de codigo de validação da execução do gatilho
	aAux[4] )                                                       // [04] Bloco de codigo de execução do gatilho

// ------------- Campos Virtuais para Tabela SD2 ------------------
	oStruSD2:AddField( ;                      // Ord. Tipo Desc.
	"Desc.Prod."                     , ;      // [01]  C   Titulo do campo
	"Desc.Prod."                     , ;      // [02]  C   ToolTip do campo
	"D2_DESCRI"                      , ;      // [03]  C   Id do Field
	'C'                              , ;      // [04]  C   Tipo do campo
	TamSx3("B1_DESC")[1]             , ;      // [05]  N   Tamanho do campo
	0                                , ;      // [06]  N   Decimal do campo
	NIL                              , ;      // [07]  B   Code-block de validação do campo
	NIL                              , ;      // [08]  B   Code-block de validação When do campo
	NIL                              , ;      // [09]  A   Lista de valores permitido do campo
	NIL                              , ;      // [10]  L   Indica se o campo tem preenchimento obrigatório
	FwBuildFeature( STRUCT_FEATURE_INIPAD,'SubStr(Posicione("SB1",1,xFilial("SB1")+SD2->D2_COD,"B1_DESC"),1,50)'), ;    // [11]  B   Code-block de inicializacao do campo
	NIL                              , ;      // [12]  L   Indica se trata-se de um campo chave
	NIL                              , ;      // [13]  L   Indica se o campo pode receber valor em uma operação de update.
	.T.                              )        // [14]  L   Indica se o campo é virtual


	aAux := FwStruTrigger(;
	"D2_COD", ;                                                      // [01] Id do campo de origem
	"D2_DESCRI" , ;                                                   // [02] Id do campo de destino
	'SubStr(Posicione("SB1",1,xFilial("SB1")+FwFldGet("D2_COD"),"B1_DESC"),1,50)' )

	oStruSD2:AddTrigger( ;
	aAux[1], ;                                                      // [01] Id do campo de origem
	aAux[2], ;                                                      // [02] Id do campo de destino
	aAux[3], ;                                                      // [03] Bloco de codigo de validação da execução do gatilho
	aAux[4] )                                                       // [04] Bloco de codigo de execução do gatilho

	oStruSD2:AddField( ;                      // Ord. Tipo Desc.
	"Peso Bruto"                     , ;      // [01]  C   Titulo do campo
	"Peso Bruto"                     , ;      // [02]  C   ToolTip do campo
	"D2_PBRUTO"                      , ;      // [03]  C   Id do Field
	'N'                              , ;      // [04]  C   Tipo do campo
	11                               , ;      // [05]  N   Tamanho do campo
	4                                , ;      // [06]  N   Decimal do campo
	NIL                              , ;      // [07]  B   Code-block de validação do campo
	NIL                              , ;      // [08]  B   Code-block de validação When do campo
	NIL                              , ;      // [09]  A   Lista de valores permitido do campo
	NIL                              , ;      // [10]  L   Indica se o campo tem preenchimento obrigatório
	FwBuildFeature( STRUCT_FEATURE_INIPAD,'OmRtPesoIt(SD2->D2_COD,SD2->D2_QUANT)'), ;      // [11]  B   Code-block de inicializacao do campo
	NIL                              , ;      // [12]  L   Indica se trata-se de um campo chave
	NIL                              , ;      // [13]  L   Indica se o campo pode receber valor em uma operação de update.
	.T.                              )        // [14]  L   Indica se o campo é virtual

 	aAux := FwStruTrigger(;
	"D2_QUANT", ;                                                      // [01] Id do campo de origem
	"D2_PBRUTO" , ;                                                   // [02] Id do campo de destino
	'OmRtPesoIt(FwFldGet("D2_COD"),SD2->D2_QUANT)' )

	oStruSD2:AddTrigger( ;
	aAux[1], ;                                                      // [01] Id do campo de origem
	aAux[2], ;                                                      // [02] Id do campo de destino
	aAux[3], ;                                                      // [03] Bloco de codigo de validação da execução do gatilho
	aAux[4] )                                                       // [04] Bloco de codigo de execução do gatilho

	oStruSD2:AddField( ;                      // Ord. Tipo Desc.
	"M3"                             , ;      // [01]  C   Titulo do campo
	"M3"                             , ;      // [02]  C   ToolTip do campo
	"D2_METRO3"                      , ;      // [03]  C   Id do Field
	'N'                              , ;      // [04]  C   Tipo do campo
	11                               , ;      // [05]  N   Tamanho do campo
	4                                , ;      // [06]  N   Decimal do campo
	NIL                              , ;      // [07]  B   Code-block de validação do campo
	NIL                              , ;      // [08]  B   Code-block de validação When do campo
	NIL                              , ;      // [09]  A   Lista de valores permitido do campo
	NIL                              , ;      // [10]  L   Indica se o campo tem preenchimento obrigatório
	FwBuildFeature( STRUCT_FEATURE_INIPAD,'(Posicione("SB5",1,xFilial("SB5")+ (SD2->D2_COD),"B5_ALTURA")* SB5->B5_LARG * SB5->B5_COMPR)* (SD2->D2_QUANT) '), ;    // [11]  B   Code-block de inicializacao do campo, ;*/
	NIL								 , ;		  // [12]  L   Indica se trata-se de um campo chave
	NIL                              , ;      // [13]  L   Indica se o campo pode receber valor em uma operação de update.
	.T.                              )        // [14]  L   Indica se o campo é virtual

	aAux := FwStruTrigger(;
	"D2_QUANT"  , ;                                                   // [01] Id do campo de origem
	"D2_METRO3" , ;                                                   // [02] Id do campo de destino
	"(SB5->(B5_ALTURA * B5_LARG * B5_COMPR)) * M->D2_QUANT",;
	.T.,;
	"SB5",;
	1,;
	"xFilial('SB5')+FwFldGet('D2_COD')",;
	"SB5->(FOUND())" )

	oStruSD2:AddTrigger( ;
	aAux[1], ;                                                      // [01] Id do campo de origem
	aAux[2], ;                                                      // [02] Id do campo de destino
	aAux[3], ;                                                      // [03] Bloco de codigo de validação da execução do gatilho
	aAux[4])                                                        // [04] Bloco de codigo de execução do gatilho

// ------------- Campos Virtuais para Tabela SA1 ------------------
	oStruRSA1:AddField( ;                    // Ord. Tipo Desc.
	"IBGE Compl"                     , ;      // [01]  C   Titulo do campo
	"Cod.IBGE Compl "                , ;      // [02]  C   ToolTip do campo
	"A1_CDIBGE"                      , ;      // [03]  C   Id do Field
	'C'                              , ;      // [04]  C   Tipo do campo
	7                                , ;      // [05]  N   Tamanho do campo
	0                                , ;      // [06]  N   Decimal do campo
	NIL                              , ;      // [07]  B   Code-block de validação do campo
	NIL                              , ;      // [08]  B   Code-block de validação When do campo
	NIL                              , ;      // [09]  A   Lista de valores permitido do campo
	NIL                              , ;      // [10]  L   Indica se o campo tem preenchimento obrigatório
	FwBuildFeature( STRUCT_FEATURE_INIPAD,'TMS120CdUf(SA1->A1_EST, "1") + SA1->A1_COD_MUN' ), ;   // [11]  B   Code-block de inicializacao do campo
	NIL                              , ;      // [12]  L   Indica se trata-se de um campo chave
	NIL                              , ;      // [13]  L   Indica se o campo pode receber valor em uma operação de update.
	.T.                              )        // [14]  L   Indica se o campo é virtual


	aAux := FwStruTrigger(;
	"A1_COD_MUN", ;                                                      // [01] Id do campo de origem
	"A1_CDIBGE" , ;                                                      // [02] Id do campo de destino
	'TMS120CdUf(M->A1_EST, "1") + M->A1_COD_MUN' )

	oStruRSA1:AddTrigger( ;
	aAux[1], ;                                                      // [01] Id do campo de origem
	aAux[2], ;                                                      // [02] Id do campo de destino
	aAux[3], ;                                                      // [03] Bloco de codigo de validação da execução do gatilho
	aAux[4] )                                                       // [04] Bloco de codigo de execução do gatilho

	oStruRSA1:AddField( ;                    // Ord. Tipo Desc.
	"IBGEE Compl"                    , ;      // [01]  C   Titulo do campo
	"Cod.IBGEE Compl "               , ;      // [02]  C   ToolTip do campo
	"A1_CDIBGEE"                     , ;      // [03]  C   Id do Field
	'C'                              , ;      // [04]  C   Tipo do campo
	7                                , ;      // [05]  N   Tamanho do campo
	0                                , ;      // [06]  N   Decimal do campo
	NIL                              , ;      // [07]  B   Code-block de validação do campo
	NIL                              , ;      // [08]  B   Code-block de validação When do campo
	NIL                              , ;      // [09]  A   Lista de valores permitido do campo
	NIL                              , ;      // [10]  L   Indica se o campo tem preenchimento obrigatório
	FwBuildFeature( STRUCT_FEATURE_INIPAD,'TMS120CdUf(SA1->A1_ESTE, "1") + SA1->A1_CODMUNE' ), ;   // [11]  B   Code-block de inicializacao do campo
	NIL                              , ;      // [12]  L   Indica se trata-se de um campo chave
	NIL                              , ;      // [13]  L   Indica se o campo pode receber valor em uma operação de update.
	.T.                              )        // [14]  L   Indica se o campo é virtual


	aAux := FwStruTrigger(;
	"A1_CODMUNE", ;                                                      // [01] Id do campo de origem
	"A1_CDIBGEE", ;                                                      // [02] Id do campo de destino
	'TMS120CdUf(M->A1_ESTE, "1") + M->A1_CODMUNE' )

	oStruRSA1:AddTrigger( ;
	aAux[1], ;                                                      // [01] Id do campo de origem
	aAux[2], ;                                                      // [02] Id do campo de destino
	aAux[3], ;                                                      // [03] Bloco de codigo de validação da execução do gatilho
	aAux[4] )                                                       // [04] Bloco de codigo de execução do gatilho



	oStruDSA1:AddField( ;                    // Ord. Tipo Desc.
	"IBGE Compl"                     , ;      // [01]  C   Titulo do campo
	"Cod.IBGE Compl "                , ;      // [02]  C   ToolTip do campo
	"A1_CDIBGE"                      , ;      // [03]  C   Id do Field
	'C'                              , ;      // [04]  C   Tipo do campo
	7                                , ;      // [05]  N   Tamanho do campo
	0                                , ;      // [06]  N   Decimal do campo
	NIL                              , ;      // [07]  B   Code-block de validação do campo
	NIL                              , ;      // [08]  B   Code-block de validação When do campo
	NIL                              , ;      // [09]  A   Lista de valores permitido do campo
	NIL                              , ;      // [10]  L   Indica se o campo tem preenchimento obrigatório
	FwBuildFeature( STRUCT_FEATURE_INIPAD,'TMS120CdUf(SA1->A1_EST, "1") + SA1->A1_COD_MUN' ), ;   // [11]  B   Code-block de inicializacao do campo
	NIL                              , ;      // [12]  L   Indica se trata-se de um campo chave
	NIL                              , ;      // [13]  L   Indica se o campo pode receber valor em uma operação de update.
	.T.                              )        // [14]  L   Indica se o campo é virtual

	aAux := FwStruTrigger(;
	"A1_COD_MUN", ;                                                      // [01] Id do campo de origem
	"A1_CDIBGE" , ;                                                      // [02] Id do campo de destino
	'TMS120CdUf(M->A1_EST, "1") + M->A1_COD_MUN' )

	oStruDSA1:AddTrigger( ;
	aAux[1], ;                                                      // [01] Id do campo de origem
	aAux[2], ;                                                      // [02] Id do campo de destino
	aAux[3], ;                                                      // [03] Bloco de codigo de validação da execução do gatilho
	aAux[4] )                                                       // [04] Bloco de codigo de execução do gatilho

	oStruDSA1:AddField( ;                    // Ord. Tipo Desc.
	"IBGEE Compl"                    , ;      // [01]  C   Titulo do campo
	"Cod.IBGEE Compl "               , ;      // [02]  C   ToolTip do campo
	"A1_CDIBGEE"                     , ;      // [03]  C   Id do Field
	'C'                              , ;      // [04]  C   Tipo do campo
	7                                , ;      // [05]  N   Tamanho do campo
	0                                , ;      // [06]  N   Decimal do campo
	NIL                              , ;      // [07]  B   Code-block de validação do campo
	NIL                              , ;      // [08]  B   Code-block de validação When do campo
	NIL                              , ;      // [09]  A   Lista de valores permitido do campo
	NIL                              , ;      // [10]  L   Indica se o campo tem preenchimento obrigatório
	FwBuildFeature( STRUCT_FEATURE_INIPAD,'TMS120CdUf(SA1->A1_ESTE, "1") + SA1->A1_CODMUNE' ), ;   // [11]  B   Code-block de inicializacao do campo
	NIL                              , ;      // [12]  L   Indica se trata-se de um campo chave
	NIL                              , ;      // [13]  L   Indica se o campo pode receber valor em uma operação de update.
	.T.                              )        // [14]  L   Indica se o campo é virtual

	aAux := FwStruTrigger(;
	"A1_CODMUNE", ;                                                     // [01] Id do campo de origem
	"A1_CDIBGEE" , ;                                                     // [02] Id do campo de destino
	'TMS120CdUf(M->A1_ESTE, "1") + M->A1_CODMUNE' )

	oStruDSA1:AddTrigger( ;
	aAux[1], ;                                                      // [01] Id do campo de origem
	aAux[2], ;                                                      // [02] Id do campo de destino
	aAux[3], ;                                                      // [03] Bloco de codigo de validação da execução do gatilho
	aAux[4] )                                                       // [04] Bloco de codigo de execução do gatilho

// ------------- Campos Virtuais para Tabela SA2 ------------------

	oStruDSA2:AddField( ;                    // Ord. Tipo Desc.
	"IBGE Compl"                     , ;      // [01]  C   Titulo do campo
	"Cod.IBGE Compl "                , ;      // [02]  C   ToolTip do campo
	"A2_CDIBGE"                      , ;      // [03]  C   Id do Field
	'C'                              , ;      // [04]  C   Tipo do campo
	7                                , ;      // [05]  N   Tamanho do campo
	0                                , ;      // [06]  N   Decimal do campo
	NIL                              , ;      // [07]  B   Code-block de validação do campo
	NIL                              , ;      // [08]  B   Code-block de validação When do campo
	NIL                              , ;      // [09]  A   Lista de valores permitido do campo
	NIL                              , ;      // [10]  L   Indica se o campo tem preenchimento obrigatório
	FwBuildFeature( STRUCT_FEATURE_INIPAD,'TMS120CdUf(SA2->A2_EST, "1") + SA2->A2_COD_MUN' ), ;   // [11]  B   Code-block de inicializacao do campo
	NIL                              , ;      // [12]  L   Indica se trata-se de um campo chave
	NIL                              , ;      // [13]  L   Indica se o campo pode receber valor em uma operação de update.
	.T.                              )        // [14]  L   Indica se o campo é virtual

	aAux := FwStruTrigger(;
	"A2_COD_MUN", ;                                                      // [01] Id do campo de origem
	"A2_CDIBGE" , ;                                                      // [02] Id do campo de destino
	'TMS120CdUf(M->A2_EST, "1") + M->A2_COD_MUN' )

	oStruDSA1:AddTrigger( ;
	aAux[1], ;                                                      // [01] Id do campo de origem
	aAux[2], ;                                                      // [02] Id do campo de destino
	aAux[3], ;                                                      // [03] Bloco de codigo de validação da execução do gatilho
	aAux[4] )

// ------------- Campos Virtuais para Tabela SA4 ------------------

	oStruRSA4:AddField( ;                    // Ord. Tipo Desc.
	"IBGE Compl"                     , ;      // [01]  C   Titulo do campo
	"Cod.IBGE Compl "                , ;      // [02]  C   ToolTip do campo
	"A4_CDIBGE"                      , ;      // [03]  C   Id do Field
	'C'                              , ;      // [04]  C   Tipo do campo
	7                                , ;      // [05]  N   Tamanho do campo
	0                                , ;      // [06]  N   Decimal do campo
	NIL                              , ;      // [07]  B   Code-block de validação do campo
	NIL                              , ;      // [08]  B   Code-block de validação When do campo
	NIL                              , ;      // [09]  A   Lista de valores permitido do campo
	NIL                              , ;      // [10]  L   Indica se o campo tem preenchimento obrigatório
	FwBuildFeature( STRUCT_FEATURE_INIPAD,'TMS120CdUf(SA4->A4_EST, "1") + SA4->A4_COD_MUN' ), ;   // [11]  B   Code-block de inicializacao do campo
	NIL                              , ;      // [12]  L   Indica se trata-se de um campo chave
	NIL                              , ;      // [13]  L   Indica se o campo pode receber valor em uma operação de update.
	.T.                              )        // [14]  L   Indica se o campo é virtual

	aAux := FwStruTrigger(;
	"A4_COD_MUN", ;                                                      // [01] Id do campo de origem
	"A4_CDIBGE" , ;                                                      // [02] Id do campo de destino
	'TMS120CdUf(M->A4_EST, "1") + M->A4_COD_MUN' )

	oStruRSA4:AddTrigger( ;
	aAux[1], ;                                                      // [01] Id do campo de origem
	aAux[2], ;                                                      // [02] Id do campo de destino
	aAux[3], ;                                                      // [03] Bloco de codigo de validação da execução do gatilho
	aAux[4] )                                                       // [04] Bloco de codigo de execução do gatilho

// ------------- Retira as validaçoes dos campos ------------------
	oStruSF2:SetProperty( '*', MODEL_FIELD_VALID, FWBuildFeature( STRUCT_FEATURE_VALID, '.T.' ) )
	oStruSF2:SetProperty( '*', MODEL_FIELD_WHEN,  NIL )

	oStruSD2:SetProperty( '*', MODEL_FIELD_VALID, FWBuildFeature( STRUCT_FEATURE_VALID, '.T.' ) )
	oStruSD2:SetProperty( '*', MODEL_FIELD_WHEN,  NIL )

	oStruRSA1:SetProperty( '*', MODEL_FIELD_VALID, FWBuildFeature( STRUCT_FEATURE_VALID, '.T.' ) )
	oStruRSA1:SetProperty( '*', MODEL_FIELD_WHEN,  NIL )

	oStruCSA1:SetProperty( '*', MODEL_FIELD_VALID, FWBuildFeature( STRUCT_FEATURE_VALID, '.T.' ) )
	oStruCSA1:SetProperty( '*', MODEL_FIELD_WHEN,  NIL )

	oStruDSA1:SetProperty( '*', MODEL_FIELD_VALID, FWBuildFeature( STRUCT_FEATURE_VALID, '.T.' ) )
	oStruDSA1:SetProperty( '*', MODEL_FIELD_WHEN,  NIL )

	oStruCSA2:SetProperty( '*', MODEL_FIELD_VALID, FWBuildFeature( STRUCT_FEATURE_VALID, '.T.' ) )
	oStruCSA2:SetProperty( '*', MODEL_FIELD_WHEN,  NIL )

	oStruDSA2:SetProperty( '*', MODEL_FIELD_VALID, FWBuildFeature( STRUCT_FEATURE_VALID, '.T.' ) )
	oStruDSA2:SetProperty( '*', MODEL_FIELD_WHEN,  NIL )

	oStruRSA4:SetProperty( '*', MODEL_FIELD_VALID, FWBuildFeature( STRUCT_FEATURE_VALID, '.T.' ) )
	oStruRSA4:SetProperty( '*', MODEL_FIELD_WHEN,  NIL )

Else

	oStruSD2:aTriggers := {}

	oStruRSA1 := FWFormStruct(1,"SA1",{|cCampo| AllTrim(cCampo)+"|" $ "A1_COD|A1_LOJA|A1_NREDUZ|A1_CGC|A1_END|A1_BAIRRO|A1_MUN|A1_EST|A1_COD_MUN|A1_CEP|"})
	oStruCSA1 := FWFormStruct(1,"SA1",{|cCampo| AllTrim(cCampo)+"|" $ "A1_COD|A1_LOJA|A1_NREDUZ|A1_CGC|"})
	oStruRSA4 := FWFormStruct(1,"SA4",{|cCampo| AllTrim(cCampo)+"|" $ "A4_COD|A4_CGC|A4_EST|A4_COD_MUN|"})
	oStruDSA1 := FWFormStruct(1,"SA1",{|cCampo| AllTrim(cCampo)+"|" $ "A1_COD|A1_LOJA|A1_NREDUZ|A1_CGC|A1_END|A1_BAIRRO|A1_MUN|A1_EST|A1_COD_MUN|A1_CEP|A1_ENDENT|A1_BAIRROE|A1_CEPE|A1_MUNE|A1_ESTE|A1_CODMUNE"})
	oStruCSA2 := FWFormStruct(1,"SA2",{|cCampo| AllTrim(cCampo)+"|" $ "A2_COD|A2_LOJA|A2_NREDUZ|A2_CGC|"})
	oStruDSA2 := FWFormStruct(1,"SA2",{|cCampo| AllTrim(cCampo)+"|" $ "A2_COD|A2_LOJA|A2_NREDUZ|A2_CGC|A2_END|A2_BAIRRO|A2_MUN|A2_EST|A2_COD_MUN|A2_CEP|"})

// ------------- Campos Virtuais para Tabela SF2 ------------------

	oStruSF2:AddField( ;                      // Ord. Tipo Desc.
	"F2_CDTPDC"                      , ;      // [01]  C   Titulo do campo
	"Cod.Tp.Doc"                     , ;      // [02]  C   ToolTip do campo
	"F2_CDTPDC"                      , ;      // [03]  C   Id do Field
	'C'                              , ;      // [04]  C   Tipo do campo
	55                               , ;      // [05]  N   Tamanho do campo
	0                                , ;      // [06]  N   Decimal do campo
	NIL                              , ;      // [07]  B   Code-block de validação do campo
	NIL                              , ;      // [08]  B   Code-block de validação When do campo
	NIL                              , ;      // [09]  A   Lista de valores permitido do campo
	NIL                              , ;      // [10]  L   Indica se o campo tem preenchimento obrigatório
	FwBuildFeature( STRUCT_FEATURE_INIPAD,'Posicione("SX5",1,xFilial("SX5")+"MQ"+AllTrim(SF2->F2_TIPO)+"S","X5_DESCRI")'), ; //[11]  B   Code-block de inicializacao do campo
	NIL                              , ;      // [12]  L   Indica se trata-se de um campo chave
	NIL                              , ;      // [13]  L   Indica se o campo pode receber valor em uma operação de update.
	.T.                              )        // [14]  L   Indica se o campo é virtual

	aAux := FwStruTrigger(;
	"F2_TIPO", ;                                                      // [01] Id do campo de origem
	"F2_CDTPDC" , ;                                                   // [02] Id do campo de destino
	'Posicione("SX5",1,xFilial("SX5")+"MQ"+AllTrim(M->F2_TIPO)+"S","X5_DESCRI")')


	oStruSF2:AddTrigger( ;
	aAux[1], ;                                                      // [01] Id do campo de origem
	aAux[2], ;                                                      // [02] Id do campo de destino
	aAux[3], ;                                                      // [03] Bloco de codigo de validação da execução do gatilho
	aAux[4] )                                                       // [04] Bloco de codigo de execução do gatilho


	oStruSF2:AddField( ;                      // Ord. Tipo Desc.
	"F2_CDCLF"                       , ;      // [01]  C   Titulo do campo
	"Class.frete"                    , ;      // [02]  C   ToolTip do campo
	"F2_CDCLFR"                      , ;      // [03]  C   Id do Field
	'C'                              , ;      // [04]  C   Tipo do campo
	5                                , ;      // [05]  N   Tamanho do campo
	0                                , ;      // [06]  N   Decimal do campo
	NIL                              , ;      // [07]  B   Code-block de validação do campo
	NIL                              , ;      // [08]  B   Code-block de validação When do campo
	NIL                              , ;      // [09]  A   Lista de valores permitido do campo
	NIL                              , ;      // [10]  L   Indica se o campo tem preenchimento obrigatório
	NIL                              , ;      // [11]  B   Code-block de inicializacao do campo
	NIL                              , ;      // [12]  L   Indica se trata-se de um campo chave
	NIL                              , ;      // [13]  L   Indica se o campo pode receber valor em uma operação de update.
	NIL                              )        // [14]  L   Indica se o campo é virtual

	oStruSF2:AddField( ;                      // Ord. Tipo Desc.
	"CGC Transp"                     , ;      // [01]  C   Titulo do campo
	"CGC Transp"                     , ;      // [02]  C   ToolTip do campo
	"F2_CGCTRP"                      , ;      // [03]  C   Id do Field
	'C'                              , ;      // [04]  C   Tipo do campo
	14                               , ;      // [05]  N   Tamanho do campo
	0                                , ;      // [06]  N   Decimal do campo
	NIL                              , ;      // [07]  B   Code-block de validação do campo
	NIL                              , ;      // [08]  B   Code-block de validação When do campo
	NIL                              , ;      // [09]  A   Lista de valores permitido do campo
	NIL                              , ;      // [10]  L   Indica se o campo tem preenchimento obrigatório
	FwBuildFeature( STRUCT_FEATURE_INIPAD,'Posicione("SA4",1,xFilial("SA4")+SF2->F2_TRANSP,"A4_CGC")' ), ;      // [11]  B   Code-block de inicializacao do campo
	NIL                              , ;      // [12]  L   Indica se trata-se de um campo chave
	NIL                              , ;      // [13]  L   Indica se o campo pode receber valor em uma operação de update.
	.T.                              )        // [14]  L   Indica se o campo é virtual

	aAux := FwStruTrigger(;
	"F2_TRANSP", ;                                                      // [01] Id do campo de origem
	"F2_CCGCTRP" , ;                                                   // [02] Id do campo de destino
	'Posicione("SA4",1,xFilial("SA4")+M->F2_TRANSP,"A4_CGC")')

	oStruSF2:AddTrigger( ;
	aAux[1], ;                                                      // [01] Id do campo de origem
	aAux[2], ;                                                      // [02] Id do campo de destino
	aAux[3], ;                                                      // [03] Bloco de codigo de validação da execução do gatilho
	aAux[4] )                                                       // [04] Bloco de codigo de execução do gatilho

	oStruSF2:AddField( ;                      // Ord. Tipo Desc.
	"CGC Redesp"                     , ;      // [01]  C   Titulo do campo
	"CGC Redesp"                     , ;      // [02]  C   ToolTip do campo
	"F2_CGCRDP"                      , ;      // [03]  C   Id do Field
	'C'                              , ;      // [04]  C   Tipo do campo
	14                               , ;      // [05]  N   Tamanho do campo
	0                                , ;      // [06]  N   Decimal do campo
	NIL                              , ;      // [07]  B   Code-block de validação do campo
	NIL                              , ;      // [08]  B   Code-block de validação When do campo
	NIL                              , ;      // [09]  A   Lista de valores permitido do campo
	NIL                              , ;      // [10]  L   Indica se o campo tem preenchimento obrigatório
	FwBuildFeature( STRUCT_FEATURE_INIPAD,'Posicione("SA4",1,xFilial("SA4")+SF2->F2_REDESP,"A4_CGC")' ), ;      // [11]  B   Code-block de inicializacao do campo
	NIL                              , ;      // [12]  L   Indica se trata-se de um campo chave
	NIL                              , ;      // [13]  L   Indica se o campo pode receber valor em uma operação de update.
	.T.                              )        // [14]  L   Indica se o campo é virtual

	aAux := FwStruTrigger(;
	"F2_REDESP", ;                                                      // [01] Id do campo de origem
	"F2_CCGCRDP" , ;                                                   // [02] Id do campo de destino
	'Posicione("SA4",1,xFilial("SA4")+M->F2_REDESP,"A4_CGC")')

	oStruSF2:AddTrigger( ;
	aAux[1], ;                                                      // [01] Id do campo de origem
	aAux[2], ;                                                      // [02] Id do campo de destino
	aAux[3], ;                                                      // [03] Bloco de codigo de validação da execução do gatilho
	aAux[4] )                                                       // [04] Bloco de codigo de execução do gatilho

// ------------- Campos Virtuais para Tabela SD2 ------------------
	oStruSD2:AddField( ;                      // Ord. Tipo Desc.
	"Desc.Prod."                     , ;      // [01]  C   Titulo do campo
	"Desc.Prod."                     , ;      // [02]  C   ToolTip do campo
	"D2_DESCRI"                      , ;      // [03]  C   Id do Field
	'C'                              , ;      // [04]  C   Tipo do campo
	TamSx3("B1_DESC")[1]             , ;      // [05]  N   Tamanho do campo
	0                                , ;      // [06]  N   Decimal do campo
	NIL                              , ;      // [07]  B   Code-block de validação do campo
	NIL                              , ;      // [08]  B   Code-block de validação When do campo
	NIL                              , ;      // [09]  A   Lista de valores permitido do campo
	NIL                              , ;      // [10]  L   Indica se o campo tem preenchimento obrigatório
	FwBuildFeature( STRUCT_FEATURE_INIPAD,'SubStr(Posicione("SB1",1,xFilial("SB1")+SD2->D2_COD,"B1_DESC"),1,50)'), ;    // [11]  B   Code-block de inicializacao do campo
	NIL                              , ;      // [12]  L   Indica se trata-se de um campo chave
	NIL                              , ;      // [13]  L   Indica se o campo pode receber valor em uma operação de update.
	.T.                              )        // [14]  L   Indica se o campo é virtual


	aAux := FwStruTrigger(;
	"D2_COD", ;                                                      // [01] Id do campo de origem
	"D2_DESCRI" , ;                                                   // [02] Id do campo de destino
	'SubStr(Posicione("SB1",1,xFilial("SB1")+FwFldGet("D2_COD"),"B1_DESC"),1,50)' )

	oStruSD2:AddTrigger( ;
	aAux[1], ;                                                      // [01] Id do campo de origem
	aAux[2], ;                                                      // [02] Id do campo de destino
	aAux[3], ;                                                      // [03] Bloco de codigo de validação da execução do gatilho
	aAux[4] )                                                       // [04] Bloco de codigo de execução do gatilho

	oStruSD2:AddField( ;                      // Ord. Tipo Desc.
	"Peso Bruto"                     , ;      // [01]  C   Titulo do campo
	"Peso Bruto"                     , ;      // [02]  C   ToolTip do campo
	"D2_PBRUTO"                      , ;      // [03]  C   Id do Field
	'N'                              , ;      // [04]  C   Tipo do campo
	11                               , ;      // [05]  N   Tamanho do campo
	4                                , ;      // [06]  N   Decimal do campo
	NIL                              , ;      // [07]  B   Code-block de validação do campo
	NIL                              , ;      // [08]  B   Code-block de validação When do campo
	NIL                              , ;      // [09]  A   Lista de valores permitido do campo
	NIL                              , ;      // [10]  L   Indica se o campo tem preenchimento obrigatório
	FwBuildFeature( STRUCT_FEATURE_INIPAD,'OmRtPesoIt(SD2->D2_COD,SD2->D2_QUANT)'), ;      // [11]  B   Code-block de inicializacao do campo
	NIL                              , ;      // [12]  L   Indica se trata-se de um campo chave
	NIL                              , ;      // [13]  L   Indica se o campo pode receber valor em uma operação de update.
	.T.                              )        // [14]  L   Indica se o campo é virtual

 	aAux := FwStruTrigger(;
	"D2_QUANT", ;                                                      // [01] Id do campo de origem
	"D2_PBRUTO" , ;                                                   // [02] Id do campo de destino
	'OmRtPesoIt(FwFldGet("D2_COD"),SD2->D2_QUANT)' )

	oStruSD2:AddTrigger( ;
	aAux[1], ;                                                      // [01] Id do campo de origem
	aAux[2], ;                                                      // [02] Id do campo de destino
	aAux[3], ;                                                      // [03] Bloco de codigo de validação da execução do gatilho
	aAux[4] )                                                       // [04] Bloco de codigo de execução do gatilho

	oStruSD2:AddField( ;                      // Ord. Tipo Desc.
	"M3"                             , ;      // [01]  C   Titulo do campo
	"M3"                             , ;      // [02]  C   ToolTip do campo
	"D2_METRO3"                      , ;      // [03]  C   Id do Field
	'N'                              , ;      // [04]  C   Tipo do campo
	11                               , ;      // [05]  N   Tamanho do campo
	4                                , ;      // [06]  N   Decimal do campo
	NIL                              , ;      // [07]  B   Code-block de validação do campo
	NIL                              , ;      // [08]  B   Code-block de validação When do campo
	NIL                              , ;      // [09]  A   Lista de valores permitido do campo
	NIL                              , ;      // [10]  L   Indica se o campo tem preenchimento obrigatório
	FwBuildFeature( STRUCT_FEATURE_INIPAD,'(Posicione("SB5",1,xFilial("SB5")+ (SD2->D2_COD),"B5_ALTURA")* SB5->B5_LARG * SB5->B5_COMPR)* (SD2->D2_QUANT) '), ;    // [11]  B   Code-block de inicializacao do campo, ;*/
	NIL								 , ;		  // [12]  L   Indica se trata-se de um campo chave
	NIL                              , ;      // [13]  L   Indica se o campo pode receber valor em uma operação de update.
	.T.                              )        // [14]  L   Indica se o campo é virtual

	aAux := FwStruTrigger(;
	"D2_QUANT"  , ;                                                   // [01] Id do campo de origem
	"D2_METRO3" , ;                                                   // [02] Id do campo de destino
	"(SB5->(B5_ALTURA * B5_LARG * B5_COMPR)) * M->D2_QUANT",;
	.T.,;
	"SB5",;
	1,;
	"xFilial('SB5')+FwFldGet('D2_COD')",;
	"SB5->(FOUND())" )

	oStruSD2:AddTrigger( ;
	aAux[1], ;                                                      // [01] Id do campo de origem
	aAux[2], ;                                                      // [02] Id do campo de destino
	aAux[3], ;                                                      // [03] Bloco de codigo de validação da execução do gatilho
	aAux[4])                                                        // [04] Bloco de codigo de execução do gatilho

// ------------- Campos Virtuais para Tabela SA1 ------------------
	oStruRSA1:AddField( ;                    // Ord. Tipo Desc.
	"IBGE Compl"                     , ;      // [01]  C   Titulo do campo
	"Cod.IBGE Compl "                , ;      // [02]  C   ToolTip do campo
	"A1_CDIBGE"                      , ;      // [03]  C   Id do Field
	'C'                              , ;      // [04]  C   Tipo do campo
	7                                , ;      // [05]  N   Tamanho do campo
	0                                , ;      // [06]  N   Decimal do campo
	NIL                              , ;      // [07]  B   Code-block de validação do campo
	NIL                              , ;      // [08]  B   Code-block de validação When do campo
	NIL                              , ;      // [09]  A   Lista de valores permitido do campo
	NIL                              , ;      // [10]  L   Indica se o campo tem preenchimento obrigatório
	FwBuildFeature( STRUCT_FEATURE_INIPAD,'TMS120CdUf(SA1->A1_EST, "1") + SA1->A1_COD_MUN' ), ;   // [11]  B   Code-block de inicializacao do campo
	NIL                              , ;      // [12]  L   Indica se trata-se de um campo chave
	NIL                              , ;      // [13]  L   Indica se o campo pode receber valor em uma operação de update.
	.T.                              )        // [14]  L   Indica se o campo é virtual


	aAux := FwStruTrigger(;
	"A1_COD_MUN", ;                                                      // [01] Id do campo de origem
	"A1_CDIBGE" , ;                                                      // [02] Id do campo de destino
	'TMS120CdUf(M->A1_EST, "1") + M->A1_COD_MUN' )

	oStruRSA1:AddTrigger( ;
	aAux[1], ;                                                      // [01] Id do campo de origem
	aAux[2], ;                                                      // [02] Id do campo de destino
	aAux[3], ;                                                      // [03] Bloco de codigo de validação da execução do gatilho
	aAux[4] )                                                       // [04] Bloco de codigo de execução do gatilho

	oStruRSA1:AddField( ;                    // Ord. Tipo Desc.
	"IBGEE Compl"                    , ;      // [01]  C   Titulo do campo
	"Cod.IBGEE Compl "               , ;      // [02]  C   ToolTip do campo
	"A1_CDIBGEE"                     , ;      // [03]  C   Id do Field
	'C'                              , ;      // [04]  C   Tipo do campo
	7                                , ;      // [05]  N   Tamanho do campo
	0                                , ;      // [06]  N   Decimal do campo
	NIL                              , ;      // [07]  B   Code-block de validação do campo
	NIL                              , ;      // [08]  B   Code-block de validação When do campo
	NIL                              , ;      // [09]  A   Lista de valores permitido do campo
	NIL                              , ;      // [10]  L   Indica se o campo tem preenchimento obrigatório
	FwBuildFeature( STRUCT_FEATURE_INIPAD,'TMS120CdUf(SA1->A1_ESTE, "1") + SA1->A1_CODMUNE' ), ;   // [11]  B   Code-block de inicializacao do campo
	NIL                              , ;      // [12]  L   Indica se trata-se de um campo chave
	NIL                              , ;      // [13]  L   Indica se o campo pode receber valor em uma operação de update.
	.T.                              )        // [14]  L   Indica se o campo é virtual


	aAux := FwStruTrigger(;
	"A1_CODMUNE", ;                                                      // [01] Id do campo de origem
	"A1_CDIBGEE", ;                                                      // [02] Id do campo de destino
	'TMS120CdUf(M->A1_ESTE, "1") + M->A1_CODMUNE' )

	oStruRSA1:AddTrigger( ;
	aAux[1], ;                                                      // [01] Id do campo de origem
	aAux[2], ;                                                      // [02] Id do campo de destino
	aAux[3], ;                                                      // [03] Bloco de codigo de validação da execução do gatilho
	aAux[4] )                                                       // [04] Bloco de codigo de execução do gatilho



	oStruDSA1:AddField( ;                    // Ord. Tipo Desc.
	"IBGE Compl"                     , ;      // [01]  C   Titulo do campo
	"Cod.IBGE Compl "                , ;      // [02]  C   ToolTip do campo
	"A1_CDIBGE"                      , ;      // [03]  C   Id do Field
	'C'                              , ;      // [04]  C   Tipo do campo
	7                                , ;      // [05]  N   Tamanho do campo
	0                                , ;      // [06]  N   Decimal do campo
	NIL                              , ;      // [07]  B   Code-block de validação do campo
	NIL                              , ;      // [08]  B   Code-block de validação When do campo
	NIL                              , ;      // [09]  A   Lista de valores permitido do campo
	NIL                              , ;      // [10]  L   Indica se o campo tem preenchimento obrigatório
	FwBuildFeature( STRUCT_FEATURE_INIPAD,'TMS120CdUf(SA1->A1_EST, "1") + SA1->A1_COD_MUN' ), ;   // [11]  B   Code-block de inicializacao do campo
	NIL                              , ;      // [12]  L   Indica se trata-se de um campo chave
	NIL                              , ;      // [13]  L   Indica se o campo pode receber valor em uma operação de update.
	.T.                              )        // [14]  L   Indica se o campo é virtual

	aAux := FwStruTrigger(;
	"A1_COD_MUN", ;                                                      // [01] Id do campo de origem
	"A1_CDIBGE" , ;                                                      // [02] Id do campo de destino
	'TMS120CdUf(M->A1_EST, "1") + M->A1_COD_MUN' )

	oStruDSA1:AddTrigger( ;
	aAux[1], ;                                                      // [01] Id do campo de origem
	aAux[2], ;                                                      // [02] Id do campo de destino
	aAux[3], ;                                                      // [03] Bloco de codigo de validação da execução do gatilho
	aAux[4] )                                                       // [04] Bloco de codigo de execução do gatilho

	oStruDSA1:AddField( ;                    // Ord. Tipo Desc.
	"IBGEE Compl"                    , ;      // [01]  C   Titulo do campo
	"Cod.IBGEE Compl "               , ;      // [02]  C   ToolTip do campo
	"A1_CDIBGEE"                     , ;      // [03]  C   Id do Field
	'C'                              , ;      // [04]  C   Tipo do campo
	7                                , ;      // [05]  N   Tamanho do campo
	0                                , ;      // [06]  N   Decimal do campo
	NIL                              , ;      // [07]  B   Code-block de validação do campo
	NIL                              , ;      // [08]  B   Code-block de validação When do campo
	NIL                              , ;      // [09]  A   Lista de valores permitido do campo
	NIL                              , ;      // [10]  L   Indica se o campo tem preenchimento obrigatório
	FwBuildFeature( STRUCT_FEATURE_INIPAD,'TMS120CdUf(SA1->A1_ESTE, "1") + SA1->A1_CODMUNE' ), ;   // [11]  B   Code-block de inicializacao do campo
	NIL                              , ;      // [12]  L   Indica se trata-se de um campo chave
	NIL                              , ;      // [13]  L   Indica se o campo pode receber valor em uma operação de update.
	.T.                              )        // [14]  L   Indica se o campo é virtual

	aAux := FwStruTrigger(;
	"A1_CODMUNE", ;                                                     // [01] Id do campo de origem
	"A1_CDIBGEE" , ;                                                     // [02] Id do campo de destino
	'TMS120CdUf(M->A1_ESTE, "1") + M->A1_CODMUNE' )

	oStruDSA1:AddTrigger( ;
	aAux[1], ;                                                      // [01] Id do campo de origem
	aAux[2], ;                                                      // [02] Id do campo de destino
	aAux[3], ;                                                      // [03] Bloco de codigo de validação da execução do gatilho
	aAux[4] )                                                       // [04] Bloco de codigo de execução do gatilho

// ------------- Campos Virtuais para Tabela SA2 ------------------

	oStruDSA2:AddField( ;                    // Ord. Tipo Desc.
	"IBGE Compl"                     , ;      // [01]  C   Titulo do campo
	"Cod.IBGE Compl "                , ;      // [02]  C   ToolTip do campo
	"A2_CDIBGE"                      , ;      // [03]  C   Id do Field
	'C'                              , ;      // [04]  C   Tipo do campo
	7                                , ;      // [05]  N   Tamanho do campo
	0                                , ;      // [06]  N   Decimal do campo
	NIL                              , ;      // [07]  B   Code-block de validação do campo
	NIL                              , ;      // [08]  B   Code-block de validação When do campo
	NIL                              , ;      // [09]  A   Lista de valores permitido do campo
	NIL                              , ;      // [10]  L   Indica se o campo tem preenchimento obrigatório
	FwBuildFeature( STRUCT_FEATURE_INIPAD,'TMS120CdUf(SA2->A2_EST, "1") + SA2->A2_COD_MUN' ), ;   // [11]  B   Code-block de inicializacao do campo
	NIL                              , ;      // [12]  L   Indica se trata-se de um campo chave
	NIL                              , ;      // [13]  L   Indica se o campo pode receber valor em uma operação de update.
	.T.                              )        // [14]  L   Indica se o campo é virtual

	aAux := FwStruTrigger(;
	"A2_COD_MUN", ;                                                      // [01] Id do campo de origem
	"A2_CDIBGE" , ;                                                      // [02] Id do campo de destino
	'TMS120CdUf(M->A2_EST, "1") + M->A2_COD_MUN' )

	oStruDSA1:AddTrigger( ;
	aAux[1], ;                                                      // [01] Id do campo de origem
	aAux[2], ;                                                      // [02] Id do campo de destino
	aAux[3], ;                                                      // [03] Bloco de codigo de validação da execução do gatilho
	aAux[4] )

// ------------- Campos Virtuais para Tabela SA4 ------------------

	oStruRSA4:AddField( ;                    // Ord. Tipo Desc.
	"IBGE Compl"                     , ;      // [01]  C   Titulo do campo
	"Cod.IBGE Compl "                , ;      // [02]  C   ToolTip do campo
	"A4_CDIBGE"                      , ;      // [03]  C   Id do Field
	'C'                              , ;      // [04]  C   Tipo do campo
	7                                , ;      // [05]  N   Tamanho do campo
	0                                , ;      // [06]  N   Decimal do campo
	NIL                              , ;      // [07]  B   Code-block de validação do campo
	NIL                              , ;      // [08]  B   Code-block de validação When do campo
	NIL                              , ;      // [09]  A   Lista de valores permitido do campo
	NIL                              , ;      // [10]  L   Indica se o campo tem preenchimento obrigatório
	FwBuildFeature( STRUCT_FEATURE_INIPAD,'TMS120CdUf(SA4->A4_EST, "1") + SA4->A4_COD_MUN' ), ;   // [11]  B   Code-block de inicializacao do campo
	NIL                              , ;      // [12]  L   Indica se trata-se de um campo chave
	NIL                              , ;      // [13]  L   Indica se o campo pode receber valor em uma operação de update.
	.T.                              )        // [14]  L   Indica se o campo é virtual

	aAux := FwStruTrigger(;
	"A4_COD_MUN", ;                                                      // [01] Id do campo de origem
	"A4_CDIBGE" , ;                                                      // [02] Id do campo de destino
	'TMS120CdUf(M->A4_EST, "1") + M->A4_COD_MUN' )

	oStruRSA4:AddTrigger( ;
	aAux[1], ;                                                      // [01] Id do campo de origem
	aAux[2], ;                                                      // [02] Id do campo de destino
	aAux[3], ;                                                      // [03] Bloco de codigo de validação da execução do gatilho
	aAux[4] )                                                       // [04] Bloco de codigo de execução do gatilho

// ------------- Retira as validaçoes dos campos ------------------
	oStruSF2:SetProperty( '*', MODEL_FIELD_VALID, FWBuildFeature( STRUCT_FEATURE_VALID, '.T.' ) )
	oStruSF2:SetProperty( '*', MODEL_FIELD_WHEN,  NIL )
	oStruSF2:SetProperty( '*', MODEL_FIELD_OBRIGAT, .F.)

	oStruSD2:SetProperty( '*', MODEL_FIELD_VALID, FWBuildFeature( STRUCT_FEATURE_VALID, '.T.' ) )
	oStruSD2:SetProperty( '*', MODEL_FIELD_WHEN,  NIL )
	oStruSD2:SetProperty( '*', MODEL_FIELD_OBRIGAT, .F.)

	oStruRSA1:SetProperty( '*', MODEL_FIELD_VALID, FWBuildFeature( STRUCT_FEATURE_VALID, '.T.' ) )
	oStruRSA1:SetProperty( '*', MODEL_FIELD_WHEN,  NIL )

	oStruCSA1:SetProperty( '*', MODEL_FIELD_VALID, FWBuildFeature( STRUCT_FEATURE_VALID, '.T.' ) )
	oStruCSA1:SetProperty( '*', MODEL_FIELD_WHEN,  NIL )

	oStruDSA1:SetProperty( '*', MODEL_FIELD_VALID, FWBuildFeature( STRUCT_FEATURE_VALID, '.T.' ) )
	oStruDSA1:SetProperty( '*', MODEL_FIELD_WHEN,  NIL )

	oStruCSA2:SetProperty( '*', MODEL_FIELD_VALID, FWBuildFeature( STRUCT_FEATURE_VALID, '.T.' ) )
	oStruCSA2:SetProperty( '*', MODEL_FIELD_WHEN,  NIL )

	oStruDSA2:SetProperty( '*', MODEL_FIELD_VALID, FWBuildFeature( STRUCT_FEATURE_VALID, '.T.' ) )
	oStruDSA2:SetProperty( '*', MODEL_FIELD_WHEN,  NIL )

	oStruRSA4:SetProperty( '*', MODEL_FIELD_VALID, FWBuildFeature( STRUCT_FEATURE_VALID, '.T.' ) )
	oStruRSA4:SetProperty( '*', MODEL_FIELD_WHEN,  NIL )

EndIf

oModel:= MPFormModel():New("MATA461",  /*bPre*/, /*bPost*/, Nil /*bCommit*/, /*bCancel*/)

oModel:AddFields("MATA461_SF2", ,oStruSF2,/*bPre*/,/*bPost*/,/*bLoad*/)
oModel:SetPrimaryKey({"F2_FILIAL", "F2_DOC", "F2_SERIE", "F2_CLIENTE", "F2_LOJA" })

oModel:AddGrid("MATA461_SD2","MATA461_SF2",oStruSD2,/*bLinePre*/, ,/*bPre*/,/*bPost*/,/*bLoad*/)
oModel:SetRelation("MATA461_SD2",{{"D2_FILIAL",'xFilial("SF2")'},{"D2_DOC","F2_DOC"},{"D2_SERIE","F2_SERIE"},;
                                  {"D2_CLIENTE","F2_CLIENTE"},{"D2_LOJA","F2_LOJA"}},"D2_FILIAL+D2_DOC+D2_SERIE+D2_CLIENTE+D2_LOJA")
oModel:GetModel("MATA461_SD2"):SetDelAllLine(.T.)

If lIntGFE
	oModel:AddFields("REMETENTE_SA1","MATA461_SF2",oStruRSA1,/*bPre*/,/*bPost*/,/*bLoad*/)
	oModel:SetRelation("REMETENTE_SA1",{{"A1_FILIAL",'xFilial("SA1")'},{"A1_CGC","SM0->M0_CGC"}},"A1_FILIAL+A1_CGC")

	oModel:AddFields("CLIENTE_SA1","MATA461_SF2",oStruCSA1,/*bPre*/,/*bPost*/,/*bLoad*/)
	oModel:SetRelation("CLIENTE_SA1",{{"A1_FILIAL",'xFilial("SA1")'},{"A1_COD","F2_CLIENTE"},{"A1_LOJA","F2_LOJA"}};
                                  ,"A1_FILIAL+A1_COD+A1_LOJA")

	oModel:AddFields("DESTINATARIO_SA1","MATA461_SF2",oStruDSA1,/*bPre*/,/*bPost*/,/*bLoad*/)
	oModel:SetRelation("DESTINATARIO_SA1",{{"A1_FILIAL",'xFilial("SA1")'},{"A1_COD","F2_CLIENT"},{"A1_LOJA","F2_LOJENT"}};
                                  ,"A1_FILIAL+A1_COD+A1_LOJA")

    oModel:AddFields("CLIENTE_SA2","MATA461_SF2",oStruCSA2,/*bPre*/,/*bPost*/,/*bLoad*/)
	oModel:SetRelation("CLIENTE_SA2",{{"A2_FILIAL",'xFilial("SA2")'},{"A2_COD","F2_CLIENTE"},{"A2_LOJA","F2_LOJA"}};
                                  ,"A2_FILIAL+A2_COD+A2_LOJA")
	oModel:AddFields("DESTINATARIO_SA2","MATA461_SF2",oStruDSA2,/*bPre*/,/*bPost*/,/*bLoad*/)
	oModel:SetRelation("DESTINATARIO_SA2",{{"A2_FILIAL",'xFilial("SA2")'},{"A2_COD","F2_CLIENT"},{"A2_LOJA","F2_LOJENT"}};
                                  ,"A2_FILIAL+A2_COD+A2_LOJA")

	oModel:AddFields("REDESPACHO_SA4","MATA461_SF2",oStruRSA4,/*bPre*/,/*bPost*/,/*bLoad*/)
	oModel:SetRelation("REDESPACHO_SA4",{{"A4_FILIAL",'xFilial("SA4")'},{"A4_COD","F2_REDESP"}},"A4_FILIAL+A4_COD")
EndIf

If ExistBlock('MA461Mdl')
	aRet := ExecBlock('MA461Mdl',.F.,.F.)
	If ValType(aRet) == 'A'
		aRelatUsr := AClone(aRet)
	EndIf
	If !Empty(aRelatUsr)
		For nI := 1 To Len(aRelatUsr)
			cFieldRel := 'FIELDREL_'+Alltrim(Str(nI+1))
			oModel:AddFields(cFieldRel,"MATA461_SF2",aRelatUsr[nI,1],/*bPre*/,/*bPost*/,/*bLoad*/)
			oModel:SetRelation(cFieldRel,AClone(aRelatUsr[nI,3]),aRelatUsr[nI,2])
		Next nI
	EndIf
EndIf
//oModel:SetDescription( OemToAnsi(STR0005))
oModel:SetDescription( 'NF SAIDA')

Return oModel

//-------------------------------------------------------------------
/*/{Protheus.doc} A461RetCFci

Retorna codigo FCI

@author SIGAFIS
/*/
//-------------------------------------------------------------------
Static Function A461RetCFci( cCodProd , nOpc , cFciCod )
Local	aRet	:=	Nil

//Retorno as validacoes de dicionarios para as funcionalidades da FCI
If nOpc == 1
	aRet := {	SuperGetMV( "MV_FISFRAS" ,, .F. )		,;
				SuperGetMV( "MV_FCIMOD" ,,"" ),;
				.T.,;
				.T.,;
				.T.,;
				.T.,;
				.T.,;
				.T.}
Endif

Return aRet

/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³MA461OrcLjºAutor  ³Cesar A. Bianchi    º Data ³  01/12/10   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Gera um item de orçamento do modulo SIGALOJA, alimentando asº±±
±±º          ³tabelas SL1, SL2 e SL4, para futura emissao do DAV.         º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³MATA460A                                                    º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function MA461OrcLj()
Local lRet 	:= .F.
Local aArea := getArea()
Local lOk	:= .T.

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Verifica se o ambiente é do tipo PAF-ECF³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lOk .and. !LjNfPafEcf(SM0->M0_CGC)
	Aviso(STR0071,STR0072,{'Ok'}) 	//Este não é um ambiente PAF-ECF válido. Impossível continuar.
	lOk := .F.
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Verifica se o pedido ja teve DAV emitido³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lOk .and. !Empty(SC9->C9_DAV)
	Aviso(STR0073,STR0074,{'Ok'}) 	//O DAV ja foi emitido para este pedido. Impossivel continuar
	lOk := .F.
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Se todas as validacoes forem OK, entao executa a importacao do orcamento³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lOk
    MsgRun(STR0075,STR0076,{|| lRet := Ma461LjDav() })
EndIf

RestArea(aArea)
Return lRet

/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³Ma461LjDavºAutor  ³Cesar A. Bianchi    º Data ³  01/12/10   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Gera um item de orçamento do modulo SIGALOJA, alimentando asº±±
±±º          ³tabelas SL1, SL2 e SL4, para futura emissao do DAV.         º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³MATA460A                                                    º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function Ma461LjDav()
Local aArea		:= getArea()
Local lRet 		:= .F.
Local nSaveSx8 	:= GetSx8Len()
Local aSL1		:= {}
Local aSL2		:= {}
Local aSL4		:= {}
Local cL1Num	:= GetSxeNum("SL1","L1_NUM")
Local nVlrPed	:= 0
Local cItem		:= "00"
Local cNumPed	:= SC9->C9_PEDIDO
Local cNumDAV	:= a461NexOrc()
Local cMarca 	:= ThisMark()
Local lInverte  := ThisInv()
Local lMata410	:= IsInCallStack("Ma410PvNfs")	//Se a geração do DAV vier da rotina de Pedidos de Venda
Local cVendPad	:= SuperGetMV("MV_VENDPAD",,"")

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Posiciona na SC5 do pedido³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
dbSelectArea('SC5')
SC5->(dbSetOrder(1))
If SC5->(dbSeek(xFilial('SC5')+SC9->C9_PEDIDO)) .and. !Empty(cNumDAV) .And. IIf(!lMata410,SC9->(IsMark("C9_OK",cMarca,lInverte)),.T.)
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Monta a SL1 - (Cabecalho Orcamento)³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	aAdd(aSL1,{"L1_FILIAL"	, xFilial("SL1") 				})
	aAdd(aSL1,{"L1_NUM"		, cL1Num						})
	aAdd(aSL1,{"L1_EMISSAO"	, SC5->C5_EMISSAO				})
	aAdd(aSL1,{"L1_DTLIM"	, dDataBase						})
	aAdd(aSL1,{"L1_DOC"		, SC5->C5_NOTA					})
	aAdd(aSL1,{"L1_SERIE"	, SC5->C5_SERIE					})
	aAdd(aSL1,{"L1_HORA"	, Time()						})
	aAdd(aSL1,{"L1_CLIENTE"	, SC5->C5_CLIENTE				})
	aAdd(aSL1,{"L1_LOJA"	, SC5->C5_LOJACLI				})
	aAdd(aSL1,{"L1_VEND"	, cVendPad						})
	AAdd(aSL1,{"L1_FRETE"  , SC5->C5_FRETE 					})
	AAdd(aSL1,{"L1_DESPESA", SC5->C5_DESPESA 				})
	AAdd(aSL1,{"L1_SEGURO" , SC5->C5_SEGURO					})
	AAdd(aSL1,{"L1_JUROS"  , 0								})
	AAdd(aSL1,{"L1_CONDPG" , "CN"							})
	AAdd(aSL1,{"L1_TPORC"  , "D"							})
	AAdd(aSL1,{"L1_NUMORC" , cNumDAV						})
	AAdd(aSL1,{"L1_DESCONT", SC5->C5_DESC1 + SC5->C5_DESC2 + SC5->C5_DESC3 + SC5->C5_DESC4 })
	AAdd(aSL1,{"L1_NUMMOV",AllTrim(LjNumMov())})
	If cPaisLoc <> "BRA"
		Aadd(aSL1,{"L1_MOEDA"  ,SC5->C5_MOEDA})
		Aadd(aSL1,{"L1_TXMOEDA",SC5->C5_TXMOEDA})
	EndIf
	While (GetSX8Len() > nSaveSx8)
		ConfirmSX8()
	End

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Monta a SL2 - (Itens Orcamento)³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	dbSelectArea('SC6')
	SC6->(dbSetOrder(1))
	dbSelectArea('SC9')
	SC9->(dbSetOrder(1))
	If SC9->(dbSeek(xFilial('SC9')+cNumPed))
		nVlrPed	:= 0
		cItem	:= "00"
		While SC9->C9_PEDIDO == cNumPed
			If SC6->(dbSeek(xFilial('SC6') + SC9->C9_PEDIDO + SC9->C9_ITEM ))
			    cItem := Soma1(cItem)
				aAdd(aSL2,{"L2_FILIAL"	,	xFilial("SL2")			})
				aAdd(aSL2,{"L2_NUM"		,	cL1Num					})
				aAdd(aSL2,{"L2_PRODUTO"	,	SC6->C6_PRODUTO			})
				aAdd(aSL2,{"L2_ITEM"	,	cItem		   			})	//Item da SL2 nao deve acompanhar o da SC6/SC9
				aAdd(aSL2,{"L2_DESCRI"	,	SC6->C6_DESCRI			})
				aAdd(aSL2,{"L2_QUANT"	,	SC6->C6_QTDVEN 			})
				aAdd(aSL2,{"L2_VRUNIT"	,	SC6->C6_PRCVEN 			})
				aAdd(aSL2,{"L2_VLRITEM"	,	SC6->C6_VALOR 			})
				aAdd(aSL2,{"L2_DESC"	,	SC6->C6_DESCONT			})
				aAdd(aSL2,{"L2_VALDESC"	,	SC6->C6_VALDESC			})
				aAdd(aSL2,{"L2_UM"		,	SC6->C6_UM  	   		})
				aAdd(aSL2,{"L2_LOCAL"	,	SC6->C6_LOCAL  			})
				aAdd(aSL2,{"L2_TES"		,	SC6->C6_TES    			})
				aAdd(aSL2,{"L2_CF"		,	SC6->C6_CF 				})
				aAdd(aSL2,{"L2_DOC"		,	SC6->C6_NOTA  	 		})
				aAdd(aSL2,{"L2_SERIE"	,	SC6->C6_SERIE			})
				aAdd(aSL2,{"L2_VEND"	,	cVendPad				})
				aAdd(aSL2,{"L2_TABELA"	,	SC5->C5_TABELA			})
				aAdd(aSL2,{"L2_EMISSAO"	,	SC5->C5_EMISSAO			})
				aAdd(aSL2,{"L2_GRADE"	,	SC6->C6_GRADE          	})
				aAdd(aSL2,{"L2_RESERVA"	,	""						})
				aAdd(aSL2,{"L2_LOJARES"	,	""						})
				aAdd(aSL2,{"L2_PEDSC5"	,	SC9->C9_PEDIDO			})
				aAdd(aSL2,{"L2_ITESC6"	,	SC6->C6_ITEM 			})
				aAdd(aSL2,{"L2_SEQUEN"	,	SC9->C9_SEQUEN			})
				aAdd(aSL2,{"L2_VDMOST"	,	"N"						})
				aAdd(aSL2,{"L2_FDTENTR", SC6->C6_ENTREG  })
				aAdd(aSL2,{"L2_PRCTAB"  ,   SC6->C6_PRCVEN          })

				//Contabiliza o valor do item
				nVlrPed	+= (SC6->C6_VALOR - SC6->C6_VALDESC)

				//ÚÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Grava a SL2³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÙ
				Lj7GeraSL( "SL2", aSL2, .T., .T. )
				aSL2 := {}
			EndIf
		    SC9->(dbSkip())
		EndDo

		//ÚÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Grava a SL1³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÙ
        Lj7GeraSL( "SL1", aSL1, .T., .T. )

		dbSelectArea('SCV')
		SCV->(dbSetOrder(1))
		SCV->(dbSeek(xFilial('SCV')+SC5->C5_NUM))

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Monta a SL4 - (Forma Pgto) ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		aAdd(aSL4,{"L4_FILIAL"	,	xFilial("SL4")		})
		aAdd(aSL4,{"L4_NUM"    	,	cL1Num				})
		aAdd(aSL4,{"L4_DATA"	,	dDataBase			})
		aAdd(aSL4,{"L4_VALOR"	,	nVlrPed				})
		aAdd(aSL4,{"L4_FORMA"	,	"R$"				})
		aAdd(aSL4,{"L4_TERCEIR"	,	.F.					})
		aAdd(aSL4,{"L4_ORIGEM"	,	"MATA460"			})

		//ÚÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Grava a SL4³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÙ
		Lj7GeraSL( "SL4", aSL4, .T., .T. )
		lRet := .T.

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Atualiza a SC9 como orcamento emitido³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		dbSelectArea('SC9')
		SC9->(dbSetOrder(1))
		If SC9->(dbSeek(xFilial('SC9')+SC5->C5_NUM))
			While SC9->C9_PEDIDO == SC5->C5_NUM
				If (!lMata410 .And. IsMark("C9_OK",cMarca,lInverte)) .Or. lMata410
					RecLock('SC9',.F.)
					SC9->C9_DAV := "S"
					SC9->(msUnlock())
				EndIf
				SC9->(dbSkip())
			EndDo
		EndIf
	EndIf
ElseIf Empty(cNumDAV)
	MsgInfo(STR0081) //'Geracao DAV abortada'
EndIf

RestArea(aArea)
Return lRet

/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³MT461PedUpºAutor  ³Cesar A. Bianchi    º Data ³  16/12/10   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Atualiza o pedido de venda, caso o mesmo tenha sido migrado º±±
±±º          ³para o sigaloja como orcamento e em seguida transformado em º±±
±±º          ³venda. (Somente ambientes do tipo PAF-ECF)				  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³MATA460A                                                    º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function Mt461PedUp(cSL1Num)
Local aArea 	:= getArea()
Local cNumPed	:= ""
Local lContinue	:= .T.

Default cSL1Num 	:= ""

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Verifica se ambiente igual PAF-ECF³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If !Empty(cSL1Num) .and. LjNfPafEcf(SM0->M0_CGC)

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Posiciona no primeiro item da SL2	³
	//³e verifica se e um orcamento nativo 	³
	//³do pedido de venda do SIGAFAT		³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	dbSelectArea('SL2')
	SL2->(dbSetOrder(1))
	If lContinue .and. SL2->(dbSeek(xFilial('SL2')+cSL1Num))

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Posiciona na SF2³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		dbSelectArea('SF2')
		SF2->(dbSetOrder(1))
		SF2->(dbSeek(xFilial('SF2')+SL2->L2_DOC+SL2->L2_SERIE))
		If !Empty(SL2->L2_PEDSC5) .and. !Empty(SL2->L2_ITESC6) .and. !Empty(SL2->L2_SEQUEN)

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Atualiza o SC6 correspondente³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			cNumPed := SL2->L2_PEDSC5
			dbSelectArea('SC6')
			SC6->(dbSetOrder(1))
			If lContinue
				While SL2->L2_FILIAL + SL2->L2_NUM == xFilial( "SL2" ) + cSL1Num

					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³Posiciona na SD2³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					dbSelectArea('SD2')
					SD2->(dbSetOrder(3))
					SD2->(dbSeek(xFilial('SD2') + SL2->L2_DOC + SL2->L2_SERIE + SL1->L1_CLIENTE + SL1->L1_LOJA + SL2->L2_PRODUTO + SL2->L2_ITEM ))

					If SC6->(dbSeek(xFilial('SC6')+SL2->L2_PEDSC5+SL2->L2_ITESC6))
						RecLock("SC6",.F.)
						SC6->C6_QTDENT := SC6->C6_QTDVEN
						MaAvalSC6("SC6",5,"SC5")

						SC6->(MsUnlock())
					Else
						lContinue := .F.
					EndIf
					SL2->(dbSkip())
				EndDo
			EndIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Atualiza o SC9 correspondente³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
      		dbSelectArea('SL2')
			SL2->(dbSetOrder(1))
			If lContinue .and. SL2->(dbSeek(xFilial('SL2')+cSL1Num))
				dbSelectArea('SC9')
				SC9->(dbSetOrder(1))
				While SL2->L2_FILIAL + SL2->L2_NUM == xFilial( "SL2" ) + cSL1Num
					If SC9->(dbSeek(xFilial('SC9')+SL2->L2_PEDSC5+SL2->L2_ITESC6+SL2->L2_SEQUEN))
						RecLock("SC9",.F.)
						MaAvalSC9("SC9",11)
						SC9->(MsUnlock())
					Else
						lContinue := .F.
					EndIf
					SL2->(dbSkip())
				EndDo
			EndIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Atualiza o SC5 correspondente³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			dbSelectArea('SC5')
			SC5->(dbSetOrder(1))
			If SC5->(dbSeek(xFilial('SC5')+cNumPed))
				RecLock('SC5',.F.)
				MaAvalSC5("SC5",5,,,,,,,,cNumPed)
				SC5->(msUnlock())
			Else
				Conout(STR0077) //"LjGrvBatch: Nao Localizou pedido de venda (SC5) para atualizacao"
				lContinue := .F.
			EndIf
		EndIf
	Else
		lContinue := .F.
		Conout(STR0079)	//"LjGrvBatch: Erro atualizando Pedido de Venda (SC5)"
	EndIf
EndIf

RestArea(aArea)
Return lContinue

/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³MT461DvCN ºAutor  ³Cesar A. Bianchi    º Data ³  16/12/10   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Realiza o cancelamento do DAV gerado a partir do Pedido de  º±±
±±º          ³Venda, eliminando o conteudo setado na SC9 quando o DAV foi º±±
±±º          ³gerado (Funcao executada quando o Ped de Venda eh alterado) º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³MATA460A                                                    º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function MT461DvCN(cNFNum, cNfSerieId, cSL1Num)
Local aArea			:= getArea()
Local cCodPed		:= ""
Local lRet 			:= .F.
Local aSC6Itens		:= {}
Local nI			:= 1
Default cNFNum		:= ""
Default cNFSerieId 	:= ""
Default cSL1Num		:= ""

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Coleta quais sao os itens da SC6 e SC9 que devem ser estornados³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If !Empty(cSL1Num)
	dbSelectArea('SL2')
	SL2->(dbSetOrder(1))
	if SL2->(dbSeek(xFilial('SL2')+cSL1Num))
		While SL2->L2_NUM == cSL1Num
			If !Empty(SL2->L2_PEDSC5) .and. !Empty(SL2->L2_ITESC6)
				aAdd(aSC6Itens,{SL2->L2_PEDSC5,SL2->L2_ITESC6,SL2->L2_SEQUEN})
			EndIf
			SL2->(dbSkip())
		EndDo
	EndIf
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Posiciona no SC9 correspondente a NF Cancelada³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If !Empty(cNFNum) .and. !Empty(cNFSerieId) .and. len(aSC6Itens) > 0
	dbSelectArea('SC9')
	SC9->(dbSetOrder(6))
	If SC9->(dbSeek(xFilial('SC9')+cNfSerieId+cNFNum))
		cCodPed := SC9->C9_PEDIDO

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Localiza o item na SC5 e limpa³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
        dbSelectArea('SC5')
        SC5->(dbSetOrder(1))
        If SC5->(dbSeek(xFilial('SC5')+cCodPed))
			RecLock('SC5',.F.)
			MaAvalSC5("SC5",6)
			SC5->(msUnlock())
			lRet := .T.
        Else
			lRet := .F.
        EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Localiza o item na SC6 e limpa³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		dbSelectArea('SC6')
		SC6->(dbSetOrder(1))
		If lRet
			For nI := 1 to len(aSC6Itens)
				if SC6->(dbSeek(xFilial('SC6')+aSC6Itens[nI,1]+aSC6Itens[nI,2]))
					RecLock('SC6',.F.)
					MaAvalSC6("SC6",6,"SC5")
					SC6->(MsUnlock())
					SC6->(dbSkip())
				EndIf
			Next nI
			lRet := .T.
		Else
			lRet := .F.
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Localiza o item na SC9 e limpa³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If lRet
			SC9->(dbSetOrder(1))
			For nI := 1 to len(aSC6Itens)
				If SC9->(dbSeek(xFilial('SC9')+aSC6Itens[nI,1]+aSC6Itens[nI,2]+aSC6Itens[nI,3]))
					RecLock('SC9',.F.)
					SC9->C9_BLCRED  := ""
					SC9->C9_BLEST 	:= ""
					SC9->C9_NFISCAL	:= ""
					SC9->C9_SERIENF	:= ""
					SC9->C9_DAV		:= ""
					MaAvalSC9("SC9",12)
					SC9->(MsUnlock())
					lRet := .T.
				EndIf
			Next nI
		EndIf
	Else
		conout(STR0080)	//"Lj140: Nao localizou item na SC9"
	EndIf
EndIF

RestArea(aArea)
Return lRet

/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³a461NexOrcºAutor  ³Cesar A. Bianchi    º Data ³  28/12/10   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Retorna o proximo codigo de DAV disponivel.                 º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function a461NexOrc()
Local aArea := getArea()
Local cRet  := ""
Local aSequencia := {}
Local nTamOrc := TamSX3("LQ_NUMORC")[1]

LjxDNota("DAV", 1 ,.T. , 1,@aSequencia,Space(nTamOrc),nil,1,999,.F.,"",Nil,nTamOrc,.T.)

If ValType(aSequencia) == "A" .and. len(aSequencia) > 0
	cRet := aSequencia[1,2]
EndIf

RestArea(aArea)
Return cRet


//-------------------------------------------------------------------
/*/{Protheus.doc} A460VERPRS
Verificação e marcação do registro no MarkBrow e Vincula NFs
@sample   A460VERPRS(cId, cMarca)
@param    cId     - Indica o cId da Acao.
@param    cMarca  - valor de marcacao da markbrow().
@param    lInvMarc - Marcacao Invertida
@return   lRet (Boolean) - sempre verdadeiro.

@author   Eduardo Vicente
@since    27.02.2013
@version  P11.5
/*/
//-------------------------------------------------------------------

Function A460VERPRS(cId, cMarca, lInvMarc)

Local aArea		:= GetArea()         //Salva a area atual

Local cPedido	:= ""                //Chave do pedido presente
Local oMark		:= GetMarkBrow()     //Objeto do Browser Markbrow()
Local cIndPed	:= SC9->C9_FILIAL+SC9->C9_PEDIDO  //Chave do pedido
Local lECCia	:= SuperGetMV("MV_LJECOMO",,.F.)// EC CiaShop
Local lSelPedEC := .F. //Seleciona Pedido e-commerce
Local cOrcamto := "" //Numero do Orçamento SL1 Rakuten
Local aAreaSL1 := {} //WorkArea SL1
Local nQtdAtu	:= 0 //Quantidade de Registros Atualizados
Local cOK		:= "" //Marca



Default lInvMarc := .F.

If  (cId == "1")



	If  A460CKPRES(@cPedido)
		Help( " ", 1, "MA461PVPai", , STR0084 + cPedido, 1 )  //"Pedido Presente, favor selecionar o Pedido Pai!"

	ElseIf A460Avalia()
		Help( " ", 1, "MA461PVBloq", , STR0085, 1 )   //"Pedido pode estar Bloqueado\Faturado!"
	Else
		If lInvMarc
			cOk := If(IsMark("C9_OK", cMarca),cMarca, " ")
		Else
			cOk := If(IsMark("C9_OK", cMarca)," ",cMarca)
		EndIf

		Reclock("SC9",.F.)
		SC9->C9_OK := cOK
		SC9->( MsUnlock() )
		nQtdAtu++ //Atualiza a quantidade de Registros atualizados

		If lECCia .AND. SC5->(FieldPos("C5_PEDECOM")) > 0 .AND. Val(SC5->C5_PEDECOM) > 0 //E-Commerce CiaShop
			lSelPedEC := .T.
		ElseIf !Empty(SC5->C5_ORCRES)
			aAreaSL1 := SL1->(GetArea())
			cOrcamto := Posicione("SL1",1,xFilial("SL1")+SC5->C5_ORCRES,"L1_ORCRES")
			lSelPedEC := SL1->(FieldPos("L1_ECFLAG")) > 0 .AND. !Empty(cOrcamto) .AND. !Empty(SL1->L1_ECFLAG)//E-commerce Rakuten
			RestArea(aAreaSL1)
		EndIf

		If lSelPedEC .AND. !( Empty(cPedido) ) .And. SC9->( dbSeek(cIndPed) )
			nQtdAtu-- //subtrai a quantidade atualizada anteriormente, porque o registro vai ser atualizado novamente
			While !( Eof() ) .And. ((C9_FILIAL+C9_PEDIDO == cPedido) .Or. (C9_FILIAL+C9_PEDIDO == cIndPed))

				Reclock("SC9",.F.)
				SC9->C9_OK := cOK
				SC9->( MsUnlock() )

				SC9->( dbSkip() )
				nQtdAtu++
			End
		EndIf
	EndIf
	RestArea(aArea)

	//Somente atualiza o browse se a quantidade de registros atualizados for maiou que 1, ou seja, atualizaou um registro além do corrente
	If nQtdAtu > 1
		oMark:Refresh()
		Eval(bFiltraBrw)
	EndIf

EndIf

Return .T.

//-------------------------------------------------------------------
/*/{Protheus.doc} A460CKPRES
Verifica se o pedido se trata como pedido de presente.
@sample   A460CKPRES(cPedido)
@param    cPedido  - Indica o numero do pedido.
@return   lRet (Boolean) - retorna verdadeiro caso seja um pedido presente.

@author   Eduardo Vicente
@since    27.02.2013
@version  P11.5
/*/
//-------------------------------------------------------------------

Function A460CKPRES(cPedido)

Local aArea	:= GetArea()
Local lRet	:= .F.

SC5->( DbSetOrder(1) )

If  (SC5->(DbSeek(SC9->(C9_FILIAL+C9_PEDIDO))) )
	If  (SC5->C5_ECPRESN == "1")
		lRet:=  .T.
	EndIf

	cPedido:= (SC5->C5_FILIAL + SC5->C5_ECVINCU)
EndIf

RestArea(aArea)

Return lRet

//-----------------------------------------------------
/*/	Integra a Nota Fiscal com o SIGAGFE
@author Felipe Machado de Oliveira
@param cNumNFS = número da NFS que será enviada como parametro chave da função GFEM011NFS
		cSerieNFS = serie da NFS que será enviada como parametro chave para função GFEM011NFS
@version P11
@since 18/04/2013
/*/
//------------------------------------------------------
Function MATA461IPG(cNumNFS,cSerieNFS)
Local lRet := .T.
Local lIntGFE := SuperGetMv("MV_INTGFE",.F.,.F.)
Local cIntGFE2 := SuperGetMv("MV_INTGFE2",.F.,"2")
Local cIntNFS := SuperGetMv("MV_GFEI11",.F.,"2")

Default cNumNFS := ""
Default cSerieNFS := ""

//Integração Protheus com SIGAGFE
If lIntGFE == .T. .And. cIntGFE2 $ "1S" .And. cIntNFS == "1"
	If FindFunction( "GFEM011NFS")
		If !GFEM011NFS("UNICO",cNumNFS,cSerieNFS)
			lRet := .F.
		EndIf
	EndIf	
EndIf

Return lRet
//-------------------------------------------------------------------
/*/{Protheus.doc} A461ImpFin
Verifica se deve gerar o cálculo dos impostos (PIS,COFINS,CSLL,INSS,IRRF), independete da TES estar configurada para Gerar Duplicata (F4_DUPLIC).
@sample   A461ImpFin()
@param    lCalcPCC - Indica se deve calcular os impostos PIS,COFINS,CSLL (parametro passado por referência).
@param    lCalcINSS - Indica se deve calcular o INSS (parametro passado por referência).
@param    lCalcIRRF - Indica se deve calcular o IRRF (parametro passado por referência).
@return   Nil

@author   Varejo
@since    14.05.2014
@version  P11
/*/
//-------------------------------------------------------------------
Static Function A461ImpFin(lCalcPCC,lCalcINSS,lCalcIRRF)
Local cFilReserv:= ""
Local cOrcReserv:= ""

lCalcPCC  := .F.
lCalcINSS := .F.
lCalcIRRF := .F.
cOriPed   := ""

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//| Verifica se o Pedido foi originado do SIGALOJA (Venda Assistida) ou SIGAFAT (Venda Direta)   |
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If SC5->(FieldPos("C5_ORCRES")) > 0 .AND. !Empty(SC5->C5_ORCRES)
	dbSelectArea("SL1")
	SL1->( dbSetOrder(1) )
	If SL1->( DbSeek(xFilial("SL1") + SC5->C5_ORCRES) ) //Posiciona no orcamento filho
		cFilReserv := SL1->L1_FILRES
		cOrcReserv := SL1->L1_ORCRES
		If SL1->( DbSeek(FWxFilial("SL1",cFilReserv) + cOrcReserv) ) //Posiciona no orcamento pai
			//Verifica se tem valor de PIS, COFINS ou CSLL gravados na SL1
			If SL1->L1_VALPIS > 0 .Or. SL1->L1_VALCOFI > 0 .Or. SL1->L1_VALCSLL > 0
				lCalcPCC := .T.
			EndIf

			//Verifica se tem valor de INSS gravado na SL1
			If SL1->(FieldPos("L1_VALINSS")) > 0 .And. SL1->L1_VALINSS > 0
				lCalcINSS := .T.
			EndIf

			//Verifica se tem valor de IRRF gravado na SL1
			If SL1->(FieldPos("L1_VALIRRF")) > 0 .And. SL1->L1_VALIRRF > 0
				lCalcIRRF := .T.
				cOriPed := "LOJ" //Pedido originado do modulo SIGALOJA
			EndIf
		EndIf
	EndIf
EndIf

Return Nil

//-----------------------------------------------------
/*/	Verifica se algum dos pedidos selecionados está com carga montada OMS.
@author Clovis Nunes do nascimento
@param cAlias  = Nome da Alias temporária
@version P11
@since 04/11/2014
/*/
//------------------------------------------------------
Static Function VERCARG461(_cAlias,lQry)

Local lRet     := .F.
Local cMarca   := ThisMark()
Local lInverte := .T.

dbSelectArea(_cAlias)

While (_cAlias)->(!Eof())
	If lQry
		//--> Verifica algum dos pedidos selecionados tem carga montada
		If OmsHasCg((_cAlias)->C9_PEDIDO,(_cAlias)->C9_ITEM)
			lRet := .T.
			Exit
		EndIf
	Else
		If  Empty((_cAlias)->C9_BLEST) .And. Empty((_cAlias)->C9_BLCRED)
			If (((_cAlias)->C9_FILIAL <> xFilial("SC9")) .And.;
					(((_cAlias)->C9_BLEST == "10" .And. (_cAlias)->C9_BLCRED == "10").Or.((_cAlias)->C9_BLEST == "ZZ" .And. (_cAlias)->C9_BLCRED == "ZZ"))) .Or.;
					!(((_cAlias)->C9_OK <> cMarca .And. lInverte) .Or.;
					((_cAlias)->C9_OK == cMarca .And. !lInverte))
				lValido := .F.
			EndIf
		Else
			lValido := .F.
		EndIf
		If lValido
			If OmsHasCg((_cAlias)->C9_PEDIDO,(_cAlias)->C9_ITEM)
				lRet := .T.
				Exit
			EndIf
		EndIf
	EndIf
	(_cAlias)->(dbSkip())
EndDo

Return lRet


/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³M461ENTG  ³ Autor ³Cleyton Ferreira       ³ Data ³31.03.2015³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Tratamento do Filtro na Pesquisa da MarkBrowse              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³                                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function M461ENTG()

//Executa a seleção dos agrupadores atraves
//do valid da SX1 (pergunte)
Local cReturn := CRMA630()

mv_par16 := cReturn

Return(cReturn)

//-----------------------------------------------------------------------------
/*/{Protheus.doc} MT461AGR
Tratamento do Filtro na Pesquisa da MarkBrowse

@sample	MT461AGR(cMarca)

@param		Nenhum
@return	ExpC - String dos Agrupadores Selecionados.

@author	Cleyton Ferreira
@since		31.03.2015
@version	12
/*/
//-----------------------------------------------------------------------------
Static Function MT461AGR(cMarca)

Local cUsuario  := RetCodUsr()
Local cParam16  := AllTrim(MV_PAR16)
Local nAtPerg   := At(";",cParam16)
Local aAgrups   := {}
Local lParents  := .T.
Local lMarkAll  := .T.
Local lExecView := .T.
Local lRet      := .F.
Local cQuery    := ""
Local cWhere    := ""
Local cSC9Alias := GetNextAlias()
Local aFrom     := {}
Local nX        := 0
Local aCondXml  := {}
Local aXmlAux   := {}
Local aExpres   := {}

//Adionar as tabelas nativas da query principal para
//não duplicar no carregamento da expressão dos agrupadores
aAdd(aFrom,"SA1")
aAdd(aFrom,"SB1")
aAdd(aFrom,"SC5")
aAdd(aFrom,"SC6")
aAdd(aFrom,"SC9")
aAdd(aFrom,"SF4")

//Monta array com base na string dos agrupadores
//do parametro MV_PAR16
While nAtPerg > 0
	aAdd(aAgrups,Left(cParam16,nAtPerg-1))
	cParam16 := SubStr(cParam16,nAtPerg+1,Len(cParam16))
	nAtPerg := At(";",cParam16)
EndDo

If !Empty(cParam16)
	aAdd(aAgrups,AllTrim(cParam16))
EndIf

//Executa a função que interpreta a regra dos agrupadores na AOL e AOM
If Len(aAgrups) > 0

	aCondXml := CRMA580E(aAgrups,lParents,lMarkAll,lExecView)

	// Agrupadores multiplos
	For nX := 1 To Len(aCondXml)

		aXmlAux   := aClone(aCondXml[nX,4])

		If Len(aXmlAux) > 0
			// Query principal
			If !lRet

				//Só faz uma vez
				lRet := .T.

				cQuery := "SELECT SC9.R_E_C_N_O_ AS RECNUM "
				cQuery += "FROM "
				cQuery += RetSqlName("SA1")+" SA1, "
				cQuery += RetSqlName("SB1")+" SB1, "
				cQuery += RetSqlName("SC5")+" SC5, "
				cQuery += RetSqlName("SC6")+" SC6, "
				cQuery += RetSqlName("SC9")+" SC9, "
				cQuery += RetSqlName("SF4")+" SF4  "

				cWhere += "WHERE "
				cWhere += "SA1.A1_FILIAL = '"+xFilial("SA1")+"' AND "
				cWhere += "SB1.B1_FILIAL = '"+xFilial("SB1")+"' AND "
				cWhere += "SC5.C5_FILIAL = '"+xFilial("SC5")+"' AND "
				cWhere += "SC6.C6_FILIAL = '"+xFilial("SC6")+"' AND "
				cWhere += "SC9.C9_FILIAL = '"+xFilial("SC9")+"' AND "
				cWhere += "SF4.F4_FILIAL = '"+xFilial("SF4")+"' AND "

				cWhere += "SC9.C9_CLIENTE = SA1.A1_COD     AND "
				cWhere += "SC9.C9_LOJA    = SA1.A1_LOJA    AND "
				cWhere += "SC9.C9_PRODUTO = SB1.B1_COD     AND "
				cWhere += "SC9.C9_PEDIDO  = SC5.C5_NUM     AND "
				cWhere += "SC9.C9_PEDIDO  = SC6.C6_NUM     AND "
				cWhere += "SC9.C9_ITEM    = SC6.C6_ITEM    AND "
				cWhere += "SC9.C9_PRODUTO = SC6.C6_PRODUTO AND "
				cWhere += "SC6.C6_TES     = SF4.F4_CODIGO  AND "

				cWhere += "SC9.C9_FILAGRU = '" + Space(GetSX3Cache("C9_FILAGRU","X3_TAMANHO")) + "' AND "

				cWhere += "SA1.D_E_L_E_T_ = ' ' AND "
				cWhere += "SB1.D_E_L_E_T_ = ' ' AND "
				cWhere += "SC5.D_E_L_E_T_ = ' ' AND "
				cWhere += "SC6.D_E_L_E_T_ = ' ' AND "
				cWhere += "SF4.D_E_L_E_T_ = ' ' AND "
			EndIf

			//Função que realiza a interpretação do array dos agrupadores
			//para uma expressão SQL valida
			aExpres := Mt461MtExp(aXmlAux,aCondXml[nX,3],@aFrom,aCondXml[nX,1])
			cQuery  += aExpres[1]
			cWhere  += aExpres[2]
		EndIf
	Next nX

	//lRet significa que haviam agrupadores
	//selecionados pelo usuário
	If lRet

		//Complementa a query. Assim não é preciso tratar o final
		//da query carregada pela função e que termina em AND
		cWhere += "SC9.D_E_L_E_T_ = ' ' "
		cQuery := cQuery+cWhere
		cQuery := ChangeQuery(cQuery)

		dbUseArea(.T.,"TOPCONN",TcGenQry(,,(cQuery)),cSC9Alias,.F.,.T.)

		//Filtra os pedidos atendidos pelos agrupadores
		(cSC9Alias)->(dbGoTop())
		While (cSC9Alias)->(!Eof())
			SC9->(dbGoTo((cSC9Alias)->RECNUM))
			RecLock("SC9",.F.)
			SC9->C9_FILAGRU := cUsuario
			MsUnLock()
			(cSC9Alias)->(dbSkip())
		EndDo

		(cSC9Alias)->( DBCloseArea() )

	EndIf
EndIf

Return(lRet)

//-----------------------------------------------------------------------------
/*/{Protheus.doc} Mt461MtExp
Tratamento do Filtro na Pesquisa da MarkBrowse

@sample	Mt461MtExp(aXmlAux,cAliasPrin,aFrom,cCodAgrup)

@param		Nenhum
@return	ExpC - String dos Agrupadores Selecionados.

@author	Cleyton F.Alveso
@since		31.03.2015
@version	12
/*/
//-----------------------------------------------------------------------------
Static Function Mt461MtExp(aXmlAux,cAliasPrin,aFrom,cCodAgrup)

Local nR         := 0
Local nS         := 0
Local nPos       := 0
Local aMatriz    := {}
Local aAreaAtu   := GetArea()
Local aAreaSX9   := SX9->(GetArea())
Local cFrom      := ""
Local cWhere     := ""
Local cWhFora    := ""
Local cVarExec   := ""
Local lNovoOk    := .T.
Local cOperador  := IIf(Trim(Upper(TcGetDb())) $ "ORACLE,POSTGRES,DB2,INFORMIX","||","+")

AON->(dbSetOrder(1))
SX9->(dbSetORder(2))

For nR := 1 To Len(aXmlAux)

	If Len(aXmlAux[nR,3]) == 0 //agrupador fixo
		//Monta a expressão do agrupador dinamico, levando em conta que a rotina
		//de agrupadores utiliza o indice 1 do alias principal para a busca
		If AON->(dbSeek(xFilial("AON")+cCodAgrup+aXmlAux[nR,1]))

			//Retorna primeiro indice da tabela
			cVarExec := AON->AON_ENTIDA+"->(IndexKey(1))"
			cVarExec := &(cVarExec)

			//Remove o campo filial do indice
			If at("_FILIAL",cVarExec) > 0
				cVarExec := SubStr(cVarExec,(at("_FILIAL",cVarExec)+8),Len(cVarExec))
			EndIf

			//Monta a expressao campo da chave do indice = chave do agrupador
			If !Empty(cVarExec)
				cWhere   := " ("
				While AON->( !Eof()) .And. AON->(AON_FILIAL+AON_CODAGR+AON_CODNIV) == xFilial("AON")+cCodAgrup+aXmlAux[nR,1]

					cWhere += cVarExec+" = '"+AON->AON_CHAVE+"' OR "

					AON->(dbSkip())
				EndDo

				cWhere := Left(cWhere,Len(cWhere)-3)+") "
				cWhere := StrTran(cWhere,"+",cOperador)

			EndIf

			nPos := aScan(aMatriz,{|x| x[1]== aXmlAux[nR,2] })

			If nPos == 0
				aAdd(aMatriz,{ aXmlAux[nR,2],"",{} })
				nPos := Len(aMatriz)
			EndIf

			If !Empty(cWhere)
				aAdd(aMatriz[nPos,3],{aXmlAux[nR,1],cWhere})
				cWhere := ""
			EndIf

		EndIf
	Else

		For nS := 1 To Len(aXmlAux[nR,3])

			lNovoOk := .T.
			//Se o alias da expressão do agrupador for diferente
			//do alias principal significa que o filtro está sobre
			//outra tabela. Então é preciso relacionar essa tabela para
			//o FROM da query principal, caso ela não esteja relacionada
			If aXmlAux[nR,3,nS,1] <> cAliasPrin

				If !Empty(aXmlAux[nR,3,nS,5]) .And. !Empty(aXmlAux[nR,3,nS,6])

					//Verifica se a tabela ja foi relacionada na query principal
					If aScan(aFrom,aXmlAux[nR,3,nS,1]) == 0
						aAdd(aFrom,aXmlAux[nR,3,nS,1])
						cFrom   += ", "+RetSqlName(aXmlAux[nR,3,nS,1])+" "+aXmlAux[nR,3,nS,1]+" " // ", SBM010 SBM "

						// Adiciona o campo FILIAL.
						If Left(aXmlAux[nR,3,nS,1],1) == "S"
							cWhFora += Substr(aXmlAux[nR,3,nS,1],2,2) + "_FILIAL = '" + xFilial(aXmlAux[nR,3,nS,1]) + "'"
							cWhFora += " AND "
						Else
							cWhFora += aXmlAux[nR,3,nS,1]             + "_FILIAL = '" + xFilial(aXmlAux[nR,3,nS,1]) + "'"
							cWhFora += " AND "
						EndIf

					EndIf

					//Monta o relacionamento com base no arquivo SX9.
					//Caso não exista o registro, a rotina não faz o relacionamento
					//e o resultado fica comprometido. Por isso a mensagem é importante.
					cWhFora += AllTrim(aXmlAux[nR,3,nS,5])
					cWhFora += " = "
					cWhFora += AllTrim(aXmlAux[nR,3,nS,6])
					cWhFora += " AND "
				Else
					Help( "  ",1,"MTA461AGRSX9" )//"Verifique o relacionamento das tabelas do agrupador"
					lNovoOk := .F.
				EndIf
			EndIf

			If lNovoOk

				//Reagrupa os sub-níveis do array de retorno para a montagem
				//das expressões WHERE respeitando os nós dos níveis pai e filho
				//em um novo array chamado aMatriz
				nPos := aScan(aMatriz,{|x| x[1]== aXmlAux[nR,2] })

				If nPos == 0
					aAdd(aMatriz,{ aXmlAux[nR,2],"",{} })
					nPos := Len(aMatriz)
				EndIf

				aAdd(aMatriz[nPos,3],{aXmlAux[nR,1],aXmlAux[nR,3,1,4]})

			EndIf
		Next nS
	EndIf
Next nR

//Monta a expressão WHERE que será incrementada
//na query principal
For nR := Len(aMatriz) to 1 Step -1

	For nS := Len(aMatriz[nR,3]) to 1 Step -1

		nPos := aScan(aMatriz,{|x| x[1] == aMatriz[nR,3,nS,1]})

		If nPos == 0
			aMatriz[nR,2] += aMatriz[nR,3,nS,2]
		Else
			aMatriz[nR,2] += " ("
			aMatriz[nR,2] += aMatriz[nR,3,nS,2]
			aMatriz[nR,2] += " AND ("
			aMatriz[nR,2] += aMatriz[nPos,2]
			aMatriz[nR,2] += ")) "

		EndIf

		If nS > 1
			aMatriz[nR,2] += " OR "
		EndIf

	Next
Next

//Agrupa na WHERE a expressão de relacionamento das tabelas
cWhere := cWhFora
If Len(aMatriz) > 0
   cWhere += "("+aMatriz[1,2]+") AND "
EndIf


RestArea(aAreaSX9)
RestArea(aAreaAtu)

Return({cFrom,cWhere})

//-------------------------------------------------------------------
/*/{Protheus.doc} IntegDef
Função para integração via Mensagem Única Totvs da Nota Fiscal de Saída.

@author  Alison Leite
@version P12.1.22
@since   07/02/2019
/*/
//-------------------------------------------------------------------
Static Function IntegDef( xEnt, nTypeTrans, cTypeMessage, cVersion, cTransaction, lJSon )

Local aRet 		:= {}

Default lJSon 	:= .F.

If lJSon .And. FindFunction("MATI461O")
	aRet:= MATI461O( xEnt, nTypeTrans, cTypeMessage )
Else
	aRet:= MATI461( xEnt, nTypeTrans, cTypeMessage, cVersion, cTransaction )
Endif

Return aRet

//-------------------------------------------------------------------
/*/{Protheus.doc} MtBaixaWMS
Executa o método do WMS para efetivar a baixa nos endereços.
@author   Flavio Lopes Rasta
@since    14.05.2014
@version  P11
/*/
//-------------------------------------------------------------------
Function MtBaixaWMS()
Local oEstEnder := WMSDTCEstoqueEndereco():New()

oEstEnder:MakeFatur( SC9->(Recno()) )
If MethisMemberOf(oEstEnder,"GetQtdFat",.T.) 
	_nMovWMS += oEstEnder:GetQtdFat() 
EndIf 

Return

//-----------------------------------------------------------------
/*/{Protheus.doc} Vld1Parc
Valida se o valor de títulos de impostos da primeira parcela é maior
que o valor da primeira parcela do titulo (MV_RTIPFIN / MV_RTIPESP) e
caso verdadeiro rateia os impostos para todas as parcelas.
@param aVencto,aTitulo,cImposto
@Return lRetorno
@author Squad CRM
@since 05/06/2017
@version 1.0
/*/
//-----------------------------------------------------------------
Function Vld1Parc(aVencto,aTitulo,cImposto,lMVRTIPFIN,nImpISS,nImpIRRF,nImpINSS,nImpCSLL,nImpCOF,nImpPIS,nImpFet,nImpFab,nImpFac,lRecISS,nImpIma,aTGCalcRet,nImpFam,aTGCalc)

	Local aImposto As Array
	Local nValImpos As Numeric
	Local nValTit As Numeric
	Local nContTg As Numeric

	//variaveis para o controle da retenção via Configurador de Tributos
	Local lPccMR As Logical
	Local lIrfMR As Logical
	Local lInsMR As Logical
	Local lIssMR As Logical
	Local lCidMR As Logical
	Local lSestMR As Logical
	Local lFunMR As Logical
	Local lFamadMR As Logical
	Local lFethabMR As Logical
	Local lFacsMR As Logical
	Local lImaMR As Logical
	Local lFabovMR As Logical

	Default aVencto := {}
	Default aTitulo := {}
	Default cImposto := SuperGetMV("MV_RTIPESP",,"0000000")
	Default lMVRTIPFIN := SuperGetMV("MV_RTIPFIN",,.F.)
	Default nImpISS := 0
	Default nImpIRRF := 0
	Default nImpINSS := 0
	Default nImpCSLL := 0
	Default nImpCOF := 0
	Default nImpPIS := 0
	Default nImpFet := 0
	Default nImpFab := 0
	Default nImpFac := 0
	Default lRecISS := .F.
	Default nImpIma := 0
	Default nImpFam := 0
	Default aTGCalc	:= {}
	Default aTGCalcRet := {}

	aImposto := {}
	nValImpos := 0
	nValTit := 0
	nContTg := 0
	lPccMR :=.F.
	lIrfMR :=.F.
	lInsMR :=.F.
	lIssMR :=.F.
	lCidMR :=.F.
	lSestMR :=.F.
	lFunMR :=.F.
	lFamadMR :=.F.
	lFethabMR :=.F.
	lFacsMR :=.F.
	lImaMR :=.F.
	lFabovMR :=.F.

	If lMVRTIPFIN .And. "2" $cImposto
		If(SubStr(cImposto,1,1)$"01",nImpISS:=Len(aVencto),nImpISS:=1)
		If(SubStr(cImposto,2,1)$"01",nImpIRRF:=Len(aVencto),nImpIRRF:=1)
		If(SubStr(cImposto,3,1)$"01",nImpINSS:=Len(aVencto),nImpINSS:=1)
		If(SubStr(cImposto,4,1)$"01",nImpCSLL:=Len(aVencto),nImpCSLL:=1)
		If(SubStr(cImposto,5,1)$"01",nImpCOF:=Len(aVencto),nImpCOF:=1)
		If(SubStr(cImposto,6,1)$"01",nImpPIS:=Len(aVencto),nImpPIS:=1)
		If(SubStr(cImposto,7,1)$"01",nImpFet:=Len(aVencto),nImpFet:=1)
		If(SubStr(cImposto,8,1)$"01",nImpFab:=Len(aVencto),nImpFab:=1)
		If(SubStr(cImposto,9,1)$"01",nImpFac:=Len(aVencto),nImpFac:=1)
		If(SubStr(cImposto,10,1)$"01",nImpIma:=Len(aVencto),nImpIma:=1)
		If(SubStr(cImposto,11,1)$"01",nImpFam:=Len(aVencto),nImpFam:=1)
	ElseIf	!lMVRTIPFIN .And. ("0" $cImposto .Or. "2" $cImposto)
		If(SubStr(cImposto,1,1)$"02",nImpISS:=1,nImpISS:=Len(aVencto))
		If(SubStr(cImposto,2,1)$"02",nImpIRRF:=1,nImpIRRF:=Len(aVencto))
		If(SubStr(cImposto,3,1)$"02",nImpINSS:=1,nImpINSS:=Len(aVencto))
		If(SubStr(cImposto,4,1)$"02",nImpCSLL:=1,nImpCSLL:=Len(aVencto))
		If(SubStr(cImposto,5,1)$"02",nImpCOF:=1,nImpCOF:=Len(aVencto))
		If(SubStr(cImposto,6,1)$"02",nImpPIS:=1,nImpPIS:=Len(aVencto))
		If(SubStr(cImposto,7,1)$"02",nImpFet:=1,nImpFet:=Len(aVencto))
		If(SubStr(cImposto,8,1)$"02",nImpFab:=1,nImpFab:=Len(aVencto))
		If(SubStr(cImposto,9,1)$"02",nImpFac:=1,nImpFac:=Len(aVencto))
		If(SubStr(cImposto,10,1)$"02",nImpIma:=1,nImpIma:=Len(aVencto))
		If(SubStr(cImposto,11,1)$"02",nImpFam:=1,nImpFam:=Len(aVencto))
	Else
		nImpISS := Len(aVencto)
		nImpIRRF:= Len(aVencto)
		nImpINSS:= Len(aVencto)
		nImpCSLL:= Len(aVencto)
		nImpCOF := Len(aVencto)
		nImpPIS := Len(aVencto)
		nImpFet := Len(aVencto)
		nImpFab := Len(aVencto)
		nImpFac := Len(aVencto)
		nImpIma	:= Len(aVencto)
		nImpFam := Len(aVencto)
		Return Nil
	EndIf

	If Len(aVencto) > 1
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Verifica os impostos a serem gravados                                  ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		aImposto := {{0,0},;
			{aTitulo[_VLRIRRF_],0},;
			{aTitulo[_VLRINSS_],0},;
			{aTitulo[_VLRISS_],0},;
			{aTitulo[_VLRPIS_],0},;
			{aTitulo[_VLRCSLL_],0},;
			{aTitulo[_VLRCOFI_],0},;
			{aTitulo[_VLRFET_],0},;
			{aTitulo[_VLRFAB_],0},;
			{aTitulo[_VLRFAC_],0},;
			{0,0},{0,0},{0,0},{0,0},;
			{0,0},{0,0},{0,0},{0,0},;
			{0,0},{0,0},{0,0},;
			{aTitulo[_VLRTPDP_],0},;
			{aTitulo[_VLRFMP_],0},;
			{aTitulo[_VLRIMA_],0},;
			{0,0},;
			{aTitulo[_VLRFMD_],0}}

		nValTit := aVencto[1][2]

		//Identifica os tributos calculados via Configurador de Tributos
		For nContTg	:= 1 to Len(aTGCalcRet)
			//Verifica os tributos do legado que foram calculados via Configurador de Tributos
			A460IdGen(aTGCalc, @lPccMR, @lIrfMR, @lInsMR, @lIssMR, @lCidMR, @lSestMR, @lFunMR, @lFamadMR, @lFethabMR, @lFacsMR, @lImaMR, @lFabovMR)

			//Soma as retenções configuradas para reter na primeira parcela
			IF aTGCalcRet[nContTg][5]
				//Acumula o valor da retenção
				nValImpos	 += aTGCalcRet[nContTg][3]
			EndIf
		Next nContTg

		//Soma os valores dos impostos do legado que serão calculados na primeira parcela
		If nImpISS == 1 .And. lRecISS .And. !lIssMR
			nValImpos += aImposto[_VLRISS_][1]
		EndIf
		If nImpIRRF == 1 .And. !lIrfMR
			nValImpos += aImposto[_VLRIRRF_][1]
		EndIf
		If nImpINSS == 1 .And. !lInsMR
			nValImpos += aImposto[_VLRINSS_][1]
		EndIf
		If nImpCSLL == 1 .And. !lPccMR
			nValImpos += aImposto[_VLRCSLL_][1]
		EndIf
		If nImpCOF == 1 .And. !lPccMR
			nValImpos += aImposto[_VLRCOFI_][1]
		EndIf
		If nImpPIS == 1 .And. !lPccMR
			nValImpos += aImposto[_VLRPIS_][1]
		EndIf
		If nImpFet == 1 .And. !lFethabMR
			nValImpos += aImposto[_VLRFET_][1]
		EndIf
		If nImpFab == 1 .And. !lFabovMR
			nValImpos += aImposto[_VLRFAB_][1]
		EndIf
		If nImpFac == 1 .And. !lFacsMR
			nValImpos += aImposto[_VLRFAC_][1]
		EndIf
		If nImpIma == 1 .And. !lImaMR
			nValImpos += aImposto[_VLRIMA_][1]
		EndIf
		If nImpFam == 1 .And. !lFamadMR
			nValImpos += aImposto[_VLRFMD_][1]
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Se o valor dos impostos forem maior que a primeira parcela DO TÍTULO, então	 ³
		//³ passará a ratear os impostos para todas parcelas retornando .F.		 		 ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If nValImpos > nValTit
			nImpISS := Len(aVencto)
			nImpIRRF:= Len(aVencto)
			nImpINSS:= Len(aVencto)
			nImpCSLL:= Len(aVencto)
			nImpCOF := Len(aVencto)
			nImpPIS := Len(aVencto)
			nImpFet := Len(aVencto)
			nImpFab := Len(aVencto)
			nImpFac := Len(aVencto)
			nImpIma := Len(aVencto)
			nImpFam := Len(aVencto)

			//Aqui atualiza o flag indicando que o retenção não poderá ocorrer na primeira parcela, atualizando todos os tributos.
			For nContTg	:= 1 to Len(aTGCalcRet)
				aTGCalcRet[nContTg][5]	:= .F.
			Next nContTg

		EndIf

	EndIf
	aSize(aImposto,0)
Return Nil

//-----------------------------------------------------------------
/*/{Protheus.doc} RetLocaliz
Retornar o endereço do produto faturado. Caso o produto possua mais de um lote,
o campo D2_LOCALIZ ficará em branco.
@param cChave	, Caracter, Chave do produto na tabela SC9:
C9_FILIAL + C9_PRODUTO + C9_LOCAL + "SC6"     + C9_PEDIDO + C9_ITEM + C9_SEQUEN + C9_LOTECTL + C9_NUMLOTE
@Return cRet	, Caracter, Retorna o Endereço do Material
@author Squad CRM
@since 17/09/2018
@version 1.0
/*/
//-----------------------------------------------------------------
Static Function RetLocaliz(cChave)
	Local aAreaSDC	:= SDC->(GetArea())
	Local cRet		:= ""
	Local nLoop		:= 0

	SDC->(DbSetOrder(1))

	If SDC->(DbSeek(cChave))
		While AllTrim(SDC->( DC_FILIAL + DC_PRODUTO + DC_LOCAL + DC_ORIGEM + DC_PEDIDO + DC_ITEM + DC_SEQ + DC_LOTECTL + DC_NUMLOTE)) == AllTrim(cChave)
			If nLoop > 0
				cRet := ""
				Exit
			EndIf
			cRet := SDC->DC_LOCALIZ
			nLoop++
			SDC->(DbSkip())
		EndDo
	EndIf

	RestArea(aAreaSDC)
Return cRet

//-----------------------------------------------------------------
/*/{Protheus.doc} TrataFil
Trata os filtros realizados na rotina de emissão de documento de saída

@param oFiltro	, Objeto, MarkBrowse da tela de seleção de documentos
@Return {cRelation, cFiltro, lEspec}	, Array, cRelation = Tabelas relacionadas, cFiltro = Filtro Final, lEspec = Possui filtro específico
@author Squad CRM
@since 08/02/2019
@version 1.0
/*/
//-----------------------------------------------------------------

Static Function TrataFil(oFiltro)

	Local aRelation	:= oFiltro:FWFilter():aRelation
	Local aFilter 	:= oFiltro:FWFilter():GetFilter(.F.)
	Local aFilRelat	:= oFiltro:FWFilter():GetFilterRelation()
	Local aJoinPai	:= {}
	Local aJoinFil	:= {}
	Local cFiltro	:= ""
	Local cRelation	:= ""
	Local cTabRel	:= "SC5|SC6|SE4|SB1|SB2|SF4"
	Local lEspec	:= .F.
	Local nX		:= 0
	Local nY		:= 0
	Local nZ		:= 0

	For nX := 1 To Len(aFilter)
		
		If "Programa" $ aFilter[nX][1] 
			Loop
		EndIf

		If lEspec
			Exit
		EndIf

		If !Empty(aFilter[nX][3]) .And. AllTrim(aFilter[nX][2]) != AllTrim(aFilter[nX][3])
			cFiltro	+= " AND " + aFilter[nX][3]
		Else
			cFiltro	+= " .AND. " + aFilter[nX][2]
		EndIf

		For nZ := 1 To Len(aFilter[nX][4])
			If aFilter[nX][4][nZ][2]  $ "FUNCTION|USEREXP"
				lEspec := .T.
				Exit
			EndIf
		Next
	Next

	If !lEspec
		For nX := 1 To Len(aFilRelat)
			cFiltro	+= " .AND. " + aFilRelat[nX][8] + "." + aFilRelat[nX][2]
			If !(aFilRelat[nX][8] $ cTabRel)
				cRelation += RetSqlName(aFilRelat[nX][8]) + " " + aFilRelat[nX][8] +" ,"

				nPos := aScan(aRelation,{|x| x[2] = aFilRelat[nX][8]})
				If nPos > 0 
					aJoinPai	:= StrTokArr2(aRelation[nPos][05],"+")
					aJoinFil	:= StrTokArr2(aRelation[nPos][04],"+")
					For nY := 1 To Len(aJoinPai)
						cFiltro += " .AND. " + aFilRelat[nX][8] + "." + aJoinPai[nY] + " == " + "SC9." + aJoinFil[nY]
					Next
					cFiltro += " .AND. " + aFilRelat[nX][8] + ".D_E_L_E_T_ = ' '  .AND. " + aFilRelat[nX][8] + "." + PrefixoCpo(aFilRelat[nX][8]) + "_Filial == '" + xFilial(aFilRelat[nX][8]) + " '"
				EndIf
				cTabRel += "|" + aFilRelat[nX][8]
			EndIf		
		Next
		
		If !Empty(cFiltro)
			cFiltro := AdvplToSql(cFiltro)
		EndIf
	EndIf

Return {cRelation, cFiltro, lEspec}

//-----------------------------------------------------------------
/*/{Protheus.doc} AdvplToSql
Converte a expressão ADVPL em expressão SQL

@param cFiltro	, Caracter, Filtro com expressões ADVPL
@Return cFiltro	, Caracter, Filtro com expressões SQL
@author Squad CRM
@since 08/02/2019
@version 1.0
/*/
//-----------------------------------------------------------------
Static Function AdvplToSql(cFiltro)

	Local lOracle	 	:= "ORACLE"   $ Upper(TCGetDB())
	Local lPostgres 	:= "POSTGRES" $ Upper(TCGetDB())
	Local lDB2		 	:= "DB2"      $ Upper(TCGetDB())

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Faz as conversoes das expresoes conhecidas de AdvPl para SQL. ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	cFiltro := Upper(cFiltro)
	cFiltro := StrTran(cFiltro,	".OR."	, " OR "	)
	cFiltro := StrTran(cFiltro,	".AND."	, " AND "	)
	cFiltro := StrTran(cFiltro,	".NOT."	, " NOT "	)
	cFiltro := StrTran(cFiltro,	"=="	, "="		)
	cFiltro	:= StrTran(cFiltro,	"->"	, "."		)
	cFiltro	:= StrTran(cFiltro,	"DTOS"	,""			)
	cFiltro	:= StrTran(cFiltro,	'"'		,"'"		)

	If lOracle .Or. lPostgres .Or. lDB2
		cFiltro	:=	StrTran( cFiltro,"SUBSTRING","SUBSTR")
	Else
		cFiltro	:=	StrTran( cFiltro,"SUBSTR","SUBSTRING")
	Endif		       
                                                              
Return cFiltro

//-----------------------------------------------------------------
/*/{Protheus.doc} AplicaFiltro
Aplica os filtros no MarkBrowse

@Return Sempre .T.
@author Squad CRM
@since 08/02/2019
@version 1.0
/*/
//-----------------------------------------------------------------

Static Function AplicaFiltro()
	Local lRet	:= .T.

	oMark := GetMarkBrow()

	oMark:FwFilter():LBTNEXPRESSION := .F.
	oMark:FwFilter():LBTNFUNCTION := .F.

	lRet := !(TrataFil(oMark)[3])

	oMark:FwFilter():OUIFilter:ListFilter()

	If !lRet
		oMark:FwFilter():CleanFilter()
	EndIF

	oMark:FwFilter():BVALIDEXECUTE := {|x| ValFil() }

Return .T.

//-----------------------------------------------------------------
/*/{Protheus.doc} ValFil
Valida se o filtro selecionado pode ser aplicado.

@Return lRet	, Boleano, Indica se o filtro pode ou não ser aplicado
@author Squad CRM
@since 08/02/2019
@version 1.0
/*/
//-----------------------------------------------------------------

Static Function ValFil()
	Local lRet := .T.

	oMark:=GetMarkBrow()

	lRet := !(TrataFil(oMark)[3])

	If !lRet
		oMark:FwFilter():CleanFilter()
	EndIf

return lRet

/*/{Protheus.doc} FatLibMetric
Função utilizada para validar a data da LIB para ser utilizada na Telemetria
@type       Function
@author     CRM/Faturamento
@since      Maio/2021
@version    12.1.27
@return     __lMetric, lógico, se a LIB pode ser utilizada para Telemetria
/*/
Static Function FatLibMetric()

If __lMetric == Nil 
	__lMetric := FWLibVersion() >= "20210517"
EndIf

Return __lMetric

/*/{Protheus.doc} A461VldRateio
Função utilizada para validar os tipos de rateios das despesas acessórias,
para serem utilizadas na Telemetria
@type       Function
@author     CRM/Faturamento
@since      Outubro/2021
@version    12.1.27
@param 		nRatFrete, Numerico, Tpo do Rateio do Frete
@param 		nRatSeg, Numerico, Tpo do Rateio do Seguro
@param 		nRatDesp, Numerico, Tpo do Rateio da Despesa
@return     cMetric, Caracter, Métrica para definir os tipos de rateio
/*/
Static Function A461VldRateio(nRatFrete,nRatSeg,nRatDesp)

Local cMetric := ""
/* 
	 Parâmetro MV_RATDESP
   FRE SEG DES       Métrica
    1	1	1           1
    1	1	2           2
    1	2	1           3
    1	2	2           4         
    2	2	2           5
    2	2	1           6
    2	1	1           7
    2	1	2           8
*/
If nRatFrete == 1  
    If nRatSeg == 1 .and. nRatDesp == 1
        cMetric := "1"    
    ElseIf nRatSeg == 1 .and. nRatDesp == 2
        cMetric := "2"  
    ElseIf nRatSeg == 2 .and. nRatDesp == 1
        cMetric := "3"  
    ElseIf nRatSeg == 2 .and. nRatDesp == 2
        cMetric := "4" 
    EndIf
Else
    If nRatSeg == 2 .and. nRatDesp == 2
        cMetric := "5"    
    ElseIf nRatSeg == 2 .and. nRatDesp == 1
        cMetric := "6"  
    ElseIf nRatSeg == 1 .and. nRatDesp == 1
        cMetric := "7"  
    ElseIf nRatSeg == 1 .and. nRatDesp == 2
        cMetric := "8" 
    EndIf        
EndIf

Return cMetric
/*/{Protheus.doc} A460IdGen
	Verifica se os impostos são calculados pelo configurador e atribue .T. as
	variáveis para não ser gerado os títulos pelo legado de maneira indevida.

	@type  Function
	@author anedino.santos - Fiscal/Escrita
	@since 17/03/2023
	@version version
	@param aTGCalc, Array, contém os dados dos tributos genéricos
	@param lPccMR, Logical, usada para definir a geração de titulo PIS/COFINS/CSLL
	@param lIrfMR, Logical, usada para definir a geração de titulo IRRF
	@param lInsMR, Logical, usada para definir a geração de titulo INSS
	@param lIssMR, Logical, usada para definir a geração de titulo ISS
	@param lCidMR, Logical, usada para definir a geração de titulo CIDE
	@param lSestMR, Logical, usada para definir a geração de titulo SEST
	@param lFunMR, Logical, usada para definir a geração de titulo GILRAT
	@param lFamadMR, Logical, usada para definir a geração de titulo FAMAD
	@param lFethabMR, Logical, usada para definir a geração de titulo FETHAB
	@param lFacsMR, Logical, usada para definir a geração de titulo FACS
	@param lImaMR, Logical, usada para definir a geração de titulo IMA
	@param lFabovMR, Logical, usada para definir a geração de titulo FABOV
	@return Nil, Nil, sem retorno
/*/
Function A460IdGen(aTGCalc, lPccMR, lIrfMR, lInsMR, lIssMR, lCidMR, lSestMR, lFunMR, lFamadMR, lFethabMR, lFacsMR, lImaMR, lFabovMR)
	Local nR as Numeric
	Local cIdsTrbGen as character
	Local nIdTributo := 11

	For nR := 1 to Len(aTGCalc)
		cIdsTrbGen := alltrim(aTGCalc[nR][nIdTributo])

		If !EMPTY( cIdsTrbGen )
			Do Case
				case cIdsTrbGen $ "000026#000043#000045"
					lPccMR := .T.

				case "000018" $ cIdsTrbGen
					lIrfMR := .T.

				case "000019" $ cIdsTrbGen
					lInsMR := .T.

				case "000020" $ cIdsTrbGen
					lIssMR := .T.

				case "000023" $ cIdsTrbGen
					lCidMR := .T.

				case "000013" $ cIdsTrbGen
					lSestMR := .T.

				case "000002" $ cIdsTrbGen
					lFunMR := .T.

				case "000036" $ cIdsTrbGen
					lInsPMR := .T.

				case "000007" $ cIdsTrbGen
					lFamadMR := .T.

				case "000009" $ cIdsTrbGen
					lFethabMR := .T.

				case "000006" $ cIdsTrbGen
					lFacsMR := .T.

				case "000012" $ cIdsTrbGen
					lImaMR := .T.

				case "000005" $ cIdsTrbGen
					lFabovMR := .T.
			Endcase
		EndIF
	Next
Return NIL
