#INCLUDE "FATA190.ch"
#INCLUDE "Protheus.ch"
#DEFINE MAXSAVERESULT 99999

Static aUltResult

/*/


Ŀ
Funo     FATA190   Autor  Henry Fila             Data  03.02.02   
Ĵ
Descrio  Atualizacao de Verbas de Vendas                              
Ĵ
 Uso       Materiais - OMS/FATURAMENTO                                  
Ĵ
                                                                         
Ĵ
 Programador   Data    BOPS   Motivo da Alteracao                     
Ĵ
                                                                      
ٱ


/*/
Function FATA190()

Local aCores := {	{ 'Dtos(ACK->ACK_DATFIM) >= Dtos(dDataBase)' , 'ENABLE' },; 	//Em Aberto
					{ 'Dtos(ACK->ACK_DATFIM) < Dtos(dDataBase)' , 'DISABLE'}}						//Encerrado

Private cCadastro	:= STR0001 //"Verbas de Vendas"
Private aRotina	:= MenuDef()

aUltResult := {}				
DbSelectArea("ACK")
DbSetOrder(1)

mBrowse(06,01,22,75,"ACK",,,,,,aCores)

Return Nil

/*/


Ŀ
Funo    Oms130Mnt  Autor Henry Fila              Data 02.03.2001  
Ĵ
Descrio Manutencao da administracao de entregas                       
Ĵ
Retorno   Nenhum                                                        
Ĵ
ParametrosExpC1: Alias do Arquivo                                       
          ExpN2: Numero do Registro                                     
          ExpN3: Opcao do aRotina                                       
                                                                        
Ĵ
Uso        Materiais/Distribuicao/Logistica                             
Ĵ
 Atualizacoes sofridas desde a Construcao Inicial.                       
Ĵ
 Programador   Data    BOPS   Motivo da Alteracao                     
Ĵ
 Fernando     14/02/07119222Alterao feita para usar a FilgetDados   
                            na montagem do Aheader e Acols            
 Conrado Q.   03/04/07122662Passa para o Tec190Item o aRecno para     
                            serem adicionados os recnos visual./alter.
ٱ


/*/

Function Fat190Mnt(cAlias, nReg, nOpc)

Local aArea     := GetArea()
Local aGet      := {}
Local aPosObj   := {} 
Local aObjects  := {}                        
Local aSize     := MsAdvSize( .T. )             
Local aTravas	:= {}
Local aRecno    := {}
Local aVisual   := {}

Local lTrava	:= .T.
Local lProcessa := .T.

Local nUsado	:= 0
Local nOpca	 	:= 0
Local nPosCod   := 0              
Local nSaveSx8  := 0
Local nCntFor   := 0 
Local cSeek  	:= Nil
Local cWhile 	:= Nil               
Local oDlg

Private aHeader := {}
Private aCols	:= {} 
PRIVATE aTELA[0][0],aGETS[0]

If nOpc == 5
	lProcessa := Ft190CanDel(ACK->ACK_CODVER)
Endif	

If lProcessa

	//Ŀ
	// Inicializa a Variaveis da Enchoice.                  
	//
	DbSelectArea("SX3")
	DbSetOrder(1)
	DbSeek("ACK")
	While ( !Eof() .And. (SX3->X3_ARQUIVO == "ACK") )
		cCampo := SX3->X3_CAMPO
		If SX3->(X3USO(X3_USADO) .And. cNivel >= X3_NIVEL)
			Aadd(aVisual,SX3->X3_CAMPO)
			If	( SX3->X3_CONTEXT == "V"  .Or. Inclui )
				M->&(cCampo) := CriaVar(SX3->X3_CAMPO)
			Else
				M->&(cCampo) := ACK->(FieldGet(FieldPos(SX3->X3_CAMPO)))
			EndIf
		EndIf
		DbSelectArea("SX3")
		DbSkip()
	End
	
	
	//Ŀ
	// Monta o Array aHeader.                                       
	//
	
	cSeek  := 	xFilial("ACL")+ACK->ACK_CODVER
 	cWhile :=	("ACL->ACL_FILIAL+ACL->ACL_CODVER") 
 

	FillGetDados(	nOpc 		 	,"ACL"						,1								,cSeek					,;
					{||&(cWhile)}	,/*{|| bCond,bAct1,bAct2}*/	,/*aNoFields*/					,/*aYesFields*/			,;
					/*lOnlyYes*/	,/* cQuery*/				,/*bMontAcols*/					,IIf(nOpc<>3,.F.,.T.)	,;
					/*aHeaderAux*/	,/*aColsAux*/				,{||Fat190Item( nOpc, aRecno )}	,/*bBeforeCols*/		,;
					/*bAfterHeader*/,/*cAliasQry*/				)
	
	AAdd( aObjects, { 100, 065, .t., .t. } )
	AAdd( aObjects, { 100, 100, .t., .t. } )
			
	aInfo   := { aSize[ 1 ], aSize[ 2 ], aSize[ 3 ], aSize[ 4 ], 3, 3 }
	aPosObj := MsObjSize( aInfo, aObjects, .T. )
	
	If ( lTrava )
	
		DEFINE MSDIALOG oDlg TITLE cCadastro From aSize[7],00 to aSize[6],aSize[5] Of oMainWnd PIXEL
	
			EnChoice( "ACK", nReg, nOpc, , , , , aPosObj[1],,3,,,.T.)
	
			DbSelectArea("ACL")		
			oGetD := MsGetDados():New(aPosObj[2,1],aPosObj[2,2],aPosObj[2,3],aPosObj[2,4],nOpc,"Fat190LOk()","AllWaysTrue()","+ACL_ITEM",.T.,,,,999)
		ACTIVATE MSDIALOG oDlg ON INIT EnchoiceBar(oDlg,{|| nOpcA := 1, If(Fat190TOk().And.oGetd:TudoOk(),If(!obrigatorio(aGets,aTela),nOpcA := 0,oDlg:End()),nOpcA := 0)},{||oDlg:End()})			
		
		If ( nOpcA == 1 ) .And. (nOpc == 3 .Or. nOpc == 4 .Or. nOpc == 5 )
			Begin Transaction
				lGravou := Fat190Grv(nOpc-2,aRecno)
				If ( lGravou )
					EvalTrigger()
					While (GetSx8Len() > nSaveSx8)
						ConfirmSx8()
					End
				EndIf
			End Transaction
		EndIf
		While (GetSx8Len() > nSaveSx8)
			RollBackSx8()
		End
	
	Endif
	
	MsUnlockAll()    
	
Endif	
		
DbSelectArea("ACK")
DbSetOrder(1)               

RestArea(aArea)

Return

/*


ͻ
Funcao    |Fat190ITem  Autor Fernando Amorim       Data  15/02/07  
͹
Descricao Inclui na primeira linha do acols o numero do item 		  
͹
ParametrosnPar1: Opo escolhida pelo usurio			              
          aPar2: Lista de registros (recnos) consultados/alterados    
͹
Uso        Regras de descontos                                   	  
ĺ
 Atualizacoes sofridas desde a Construcao Inicial.                     
ĺ
 Programador   Data    BOPS   Motivo da Alteracao                   
ĺ
 Conrado Q.   03/04/07122662 Adiciona ao array aRecnos os registros 
                             (recnos) consultados/alterados.        
ͼ


*/

Static Function Fat190Item(nOpc, aRecno)
	Local nX := 0

	If (nOpc == 3)
		If Len(aCols) == 1
			For nX := 1 To Len(aHeader)
					If AllTrim(aHeader[nX,2]) == "ACL_ITEM"
							aCOLS[Len(aCols)][nX] := StrZero(1,Len(ACL->ACL_ITEM))
					
					EndIf    
			Next nX
		EndIf  
	Else
		aAdd(aRecno, ACL->(Recno()) )
	EndIf
Return .T.


/*/


Ŀ
Funo    Fat190Grv  Autor Henry Fila              Data 02.03.2001  
Ĵ
Descrio Gravacao   da administracao de entregas                       
Ĵ
Retorno   Nenhum                                                        
Ĵ
ParametrosExpC1: nOpcao                                                 
          ExpC2: Codigo do Cliente                                      
          ExpC3: Codigo da Loja                                         
          ExpA4: Array com registros para utilizar na gravacao          
Ĵ
Uso        Materiais/Distribuicao/Logistica                             
Ĵ
 Atualizacoes sofridas desde a Construcao Inicial.                       
Ĵ
 Programador   Data    BOPS   Motivo da Alteracao                     
Ĵ
                                                                      
ٱ


/*/

Function Fat190Grv(nOpcao,aRecno)

Local bCampo 	:= {|nCPO| Field(nCPO) }

Local nCntFor  := 0
Local nCntFor2 := 0           
Local nUsado   := Len(aHeader)
Local lGravou  := .F.        
Local nY       := 0 

aUltResult := Nil

Do Case
	Case ( nOpcao <> 3 )

		//Ŀ
		//De acordo com a normalizacao inclui cabecalho depois os itens
		//
		RecLock("ACK",INCLUI)
		For nY := 1 TO FCount()
			If "FILIAL"$Field(nY)						
				ACK->ACK_FILIAL := xFilial("ACK")					
			Else						
				FieldPut(nY,M->&(EVAL(bCampo,nY)))
			Endif						
		Next nY

		ACK->(FkCommit())
		
		DbSelectArea("ACL")	
		For nCntFor := 1 To Len(aCols)
		
			If ( !aCols[nCntFor][nUsado+1] )

				If nCntFor > Len(aRecno)
					RecLock("ACL",.T.)					
				Else 
					dbGoto(aRecno[nCntFor])            
					RecLock("ACL",.F.)											
				Endif						
			
				For nCntFor2 := 1 To nUsado
					If ( aHeader[nCntFor2][10] <> "V" )
						ACL->(FieldPut(FieldPos(aHeader[nCntFor2][2]),aCols[nCntFor][nCntFor2]))
					EndIf
				Next nCntFor2

				ACL->ACL_FILIAL := xFilial("ACL")
				ACL->ACL_CODVER := M->ACK_CODVER
				
				MsUnlock()					
				
				lGravou := .T.
				
			Else
			
				If nCntFor <= Len(aRecno)
					dbGoto(aRecno[nCntFor])
					RecLock("ACL")
						dbDelete() 
					MsUnlock()
				Endif						
			EndIf
		Next nCntFor
		
	OtherWise
	
		//Ŀ
		//De acordo com a normalizacao exclui itens depois o cabecalho 
		//
		For nCntFor := 1 To Len(aCols)
			If nCntFor <= Len(aRecno)
				dbGoto(aRecno[nCntFor])
				RecLock("ACL")
					dbDelete() 
				MsUnlock()
			Endif						
		Next
		
		RecLock("ACK",.F.)
			dbDelete()
		MsUnlock()			
		
EndCase
Return(lGravou)

/*/


Ŀ
Funo    Fat190LOk  Autor  Henry Fila             Data 26.04.02    
Ĵ
Descrio  Grava a janela de entrega                                    
Ĵ
 Uso       Especifico (DISTRIBUIDORES)                                  
Ĵ
 Atualizacoes sofridas desde a Construcao Inicial.                       
Ĵ
 Programador   Data    BOPS   Motivo da Alteracao                     
Ĵ
                                                                      
ٱ


/*/
Function Fat190LOk()

Local lRet     := .T.
Local nPosProd := aScan(aHeader,{|x| Alltrim(x[2]) == "ACL_CODPRO"})
Local nX       := 0
Local nUsado   := Len(aHeader)

If !aCols[n][nUsado+1]
	
	//Ŀ
	//Verifica se existe chaves iguais no acols digitado
	//
	For nX := 1 to Len(aCols)            
		If !aCols[nX][nUsado+1]	 .And. nX <> n
			If aCols[nX][nPosProd] == aCols[n][nPosProd]
	    		Help(" ",1,"FAT190CHV") //O produto informado ja existe nesta verba de vendas PARA ATUSX X.11
				lRet := .F.
			Endif		
		Endif		
	Next
	
Endif
	
Return(lRet)

/*/


Ŀ
Funo    Fat190TOk  Autor  Henry Fila             Data 26.04.02    
Ĵ
Descrio  Valida a verba de venda                                      
Ĵ
 Uso       Especifico (DISTRIBUIDORES)                                  
Ĵ
 Atualizacoes sofridas desde a Construcao Inicial.                       
Ĵ
 Programador   Data    BOPS   Motivo da Alteracao                     
Ĵ
                                                                      
ٱ


/*/

Function Fat190TOk()

Local lRet     := .T.
Local aArea    := GetArea()
Local aAreaACK := ACK->(GetArea())

Local cGrpCli  := M->ACK_GRPCLI
Local cCodCli  := M->ACK_CODCLI
Local cLoja    := M->ACK_LOJA
Local cGrpVen  := M->ACK_GRPVEN
Local cCodVen  := M->ACK_CODVEN          

#IFDEF TOP 
	Local cAliasACK:= "" 
	Local cQuery   := ""	
#ELSE
	Local nRecno   := 0	
#ENDIF 	


//Ŀ
//Valida se todos esto em branco               
//

If INCLUI .Or. ALTERA

	If Empty(cGrpVen) .And. Empty(cCodVen) .And. Empty(cCodCli) .And. Empty(cLoja) .And. Empty(cGrpCli)
		lRet := .F.
		Help(" ",1,"FAT190001")  //
	Endif
	//Ŀ
	//Valida se grupo de clientes e clientes esto preenchidos e     
	//e grupo de vendedores e vendedor estao preenchidos             
	//
	If lRet
		If (!Empty(cGrpVen) .And. !Empty(cCodVen)) .Or. (!Empty(cCodCli) .And. !Empty(cGrpCli))
			lRet := .F.
			Help(" ",1,"FAT190002")  
		Endif	
	Endif

	If lRet
		If (!Empty(cCodCli) .And. Empty(cLoja)) .Or. (Empty(cCodCli) .And. !Empty(cLoja))
			lRet := .F.
			Help(" ",1,"FAT190004")  
		Endif
	Endif
		
	If lRet
	
		#IFDEF TOP
		
			cAliasACK := "QRYACK"
			
			cQuery    := "SELECT * FROM "
			cQuery    += RetSqlName("ACK") +" ACK "
			cQuery    += " WHERE "
			cQuery    += "ACK_FILIAL = '"+xFilial("ACK")+ "' AND "	  
			cQuery    += "ACK_GRPVEN = '"+M->ACK_GRPVEN+ "' AND "
			cQuery    += "ACK_CODVEN = '"+M->ACK_CODVEN+ "' AND "			
			cQuery    += "ACK_GRPCLI = '"+M->ACK_GRPCLI+ "' AND "						
			cQuery    += "ACK_CODCLI = '"+M->ACK_CODCLI+ "' AND "						
			cQuery    += "ACK_LOJA   = '"+M->ACK_LOJA+ "' AND "						
			cQuery    += "(ACK_DATFIM >= '"+Dtos(M->ACK_DATINI)+"' AND " 
			cQuery    += " ACK_DATINI <= '"+Dtos(M->ACK_DATFIM)+"')AND " 
			If ALTERA
				cQuery += "ACK.R_E_C_N_O_ <> "+Alltrim(Str(ACK->(Recno())))+" AND "
			Endif			
			cQuery    += "ACK.D_E_L_E_T_ = ' '"
				
			cQuery := ChangeQuery(cQuery)        
			dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasACK,.T.,.T.)
				
			If (cAliasACK)->(!Eof())
				Help(" ",1,"FAT190003")	
				lRet := .F.                 
			Endif	

			(cAliasACK)->(dbCloseArea())
			DbSelectArea("ACK")
        #ELSE

			nRecno := ACK->(Recno())
	
			ACK->(DbSetOrder(2))
			If ACK->(DbSeek(xFilial("ACK")+M->ACK_GRPVEN+M->ACK_CODVEN+M->ACK_GRPCLI+M->ACK_CODCLI+M->ACK_LOJA))
			
				While ACK->(!Eof()) .And. ACK->ACK_FILIAL == xFilial("ACK") .And. ;
											ACK->ACK_GRPVEN == M->ACK_GRPVEN .And. ;
											ACK->ACK_CODVEN == M->ACK_CODVEN .And. ;
											ACK->ACK_GRPCLI == M->ACK_GRPCLI .And. ;
											ACK->ACK_LOJA   == M->ACK_LOJA .And. lRet
	                	
					If (ACK->ACK_DATFIM >= M->ACK_DATINI .And. ACK->ACK_DATINI <= M->ACK_DATFIM .And. nRecno <> ACK->(Recno()))
						Help(" ",1,"FAT190003")
						lRet := .F.                 
					Endif	
	
					ACK->(DbSkip())				
				End
		
			Endif                                                             
			
		#ENDIF	
		
	Endif
	
Endif
	
RestArea(aAreaACK)
RestArea(aArea)

Return(lRet)

/*/

Ŀ
Funo    Fat190Leg Autor   Henry fila             Data 06.02.2003 
Ĵ
          Demonstra a legenda das cores da mbrowse                     
                                                                       
Ĵ
ParametrosNenhum                                                       
                                                                       
Ĵ
Retorno   Nenhum                                                       
                                                                       
Ĵ
Descrio Esta rotina monta uma dialog com a descricao das cores da    
          Mbrowse.                                                     
                                                                       
                                                                       
Ĵ
Uso        Materiais                                                   
ٱ


/*/
Function Fat190Leg()

BrwLegenda(cCadastro,STR0007,{{"ENABLE",STR0008},; //"Legenda"###"Verba ativa"
								{"DISABLE",STR0009}}) //"Verba vencida"
Return(.T.)

/*/


Ŀ
Funcao    FtVerbaVen Autor Henry Fila              Data 14.02.2003
Ĵ
Descrio Rotina de avaliacao da Verba de Vendas                      
                                                                      
Ĵ
ParametrosExpC1: Alias SC5                                            
          ExpC2: Alias SC6                                            
          ExpC3: Codigo do Cliente                                    
          ExpC4: Loja do Cliente                                      
          ExpC5: Vendedor                                             
          ExpC6: Produto                                              
          ExpL7: Indica se a baixa sera feita ou somente analise      
                 .T. - Analisa e baixa caso tenha saldo               
                 .F. - Somente analisa                                
          ExpL7: Indica se a a verba nao tem saldo zera a verba e libe
                 ra                                                   
          ExpL9: verba de venda que bloqueou o lancamento             
          ExpL10: item da verba de venda que bloqueou o lancamento    
Ĵ
Retorno   ExpC1: 1 - Possui Verba de Vendas com Item                  
                 2 - Possui Verba de Vendas sem Item                                                                       
                 3 - Nao Possui Verba de Vendas                                                                            
Ĵ
Descrio Esta rotina tem como objetivo avaliar a verba de vendas     
          conforme os parametros da rotina                            
                                                                      
Ĵ
Observacao                                                            
                                                                      
Ĵ
Uso        Materiais/Distribuicao/Logistica                           
Ĵ
 Programador   Data    BOPS   Motivo da Alteracao                   
Ĵ
Michel W.     15/03/079.12  Bops 121063 - Retirada a variavel       
                            CGRPVEN que nao era usada e nao era     
                            declarada, que causava error log.       
                                                                    
ٱ


/*/
Function FtVerbaVen(cAliasSC5,	cAliasSC6,	cCliente,	cLoja,;
					cCodVen,	cProduto, 	aProdDesc , lBaixa, cVerbaBlq, cItemBlq)

Local aArea      := GetArea()			//Armazena a area
Local aAreaACK   := ACK->(GetArea())	//Armazena a area do ACK
Local aGruposCli := {}					//Armazena o grupo de clientes
Local aGruposVen := {}					//Armazena o grupo de vendas
Local bCondic    := { || .T. } 			//Bloco de codigo executado na avaliacao dos items
Local cAliasACK  := ""					//Armazena o alias de ACK
Local cQuery     := ""					//Armazena a query
Local cDataBase  := Dtos(dDataBase)    	//Armazena a database                
Local cResult    := ""					//Armazena o resultado de algumas funcoes
Local cRet       := "3" 				//-- Nao possui Verba de Vendas
Local lContinua  := .T.					//Indica se continua verificando as verbas de vendas
Local lQuery     := .F.					//Indica se executou uma query
Local lGrupoVen  := .F.					//Indica se ha um grupo de vendas
Local lGrupoCli  := .F.					//Indica se ha um grupo de clientes
Local lUltResult := .F.					//Indica se encontou a verba de vendas
Local nX         := 0					//Variavel utilizada em Loops
Local nLoop      := 0					//Variavel utilizada em Loops 
Local nLoop2     := 0 					//Variavel utilizada em Loops

DEFAULT cCliente  := Space( Len( SA1->A1_COD    ) )
DEFAULT cLoja     := Space( Len( SA1->A1_LOJA   ) )
DEFAULT cCodVen   := Space( Len( SA3->A3_COD    ) )
DEFAULT cAliasSC5 := "SC5"
DEFAULT cAliasSC6 := "SC6"
DEFAULT lBaixa    := .F. 
DEFAULT aUltResult:= {}

//Ŀ
// Pesquisa a se existe verba para o cliente e para o vendedor            
//

nScan := aScan(aUltResult,{|x| x[1] == cCliente .And.;
								x[2] == cLoja    .And.;
								x[3] == cCodVen})


If nScan == 0

	#IFDEF TOP
		bCondic := { || .T. }
	#ELSE	
		bCondic := { ||  cDataBase >= DToS( ACK->ACK_DATINI ) .And. ;
					(  cDataBase <= DToS( ACK->ACK_DATFIM ) )  }  
	#ENDIF 					
	
	//Ŀ
	// Verifica se o vendedor e o cliente estao em estruturas                 
	//
	SA1->( DbSetOrder( 1 ) ) 
	If SA1->( DbSeek( xFilial( "SA1" ) + cCliente + cLoja ) ) 	
		lGrupoCli := !Empty(SA1->A1_GRPVEN)
		If lGrupoCli 
			MaCliStrUp( SA1->A1_GRPVEN, @aGruposCli )  
		Endif
	Endif	
	
	If !Empty(cCodVen)
		SA3->( DbSetOrder( 1 ) ) 
		If SA3->( DbSeek( xFilial( "SA3" ) + cCodVen ) ) 	
			lGrupoVen := !Empty(SA3->A3_GRPREP)
			If lGrupoVen 
				MaVenStrUp( SA3->A3_GRPREP, @aGruposVen )  
			Endif
		Endif	
	Endif	
	
	//Ŀ
	// Verifica se o existe verba para um vendedor e um cliente               
	//
	
	If !Empty(cCodVen)
	
		#IFDEF TOP 
	
			cAliasACK := "QUERYACK" 
		
			lQuery  := .T.
		
			cQuery := ""
			cQuery += "SELECT * FROM "  + RetSqlName( "ACK" ) + " ACK " 
			cQuery += "WHERE "	
			cQuery += "ACK_FILIAL='"    + xFilial( "ACK" )    + "' AND " 
			cQuery += "ACK_CODCLI='"    + cCliente            + "' AND " 
			cQuery += "ACK_LOJA='"      + cLoja               + "' AND "
			cQuery += "ACK_GRPCLI='"    + Space(Len(SA1->A1_GRPVEN)) + "' AND "	
			cQuery += "ACK_CODVEN='"    + cCodVen             + "' AND "
			cQuery += "ACK_GRPVEN='"    + Space(Len(SA3->A3_GRPREP)) + "' AND "
			cQuery += "ACK_DATINI <='"  + cDataBase           + "' AND "
			cQuery += "ACK_DATFIM >='"  + cDataBase           + "' AND "
			cQuery += "ACK.D_E_L_E_T_=' '"  
		
			cQuery := ChangeQuery( cQuery )        
		
			dbUseArea( .T., "TOPCONN", TcGenQry( , , cQuery ), cAliasACK, .F., .T. ) 
	       
		#ELSE           
		
			cAliasACK := "ACK" 
	
			ACK->( DbSetOrder( 5 ) ) 
			ACK->( DbSeek( xFilial("ACK") + cCliente + cLoja + Space(Len(SA1->A1_GRPVEN)) + Space(Len(SA3->A3_GRPREP)) + cCodVen ) ) 
		
		#ENDIF 
	
		While !( cAliasACK )->( Eof() ) .And. xFilial("ACK")              == ( cAliasACK )->ACK_FILIAL  .And.;
											( cAliasACK )->ACK_CODCLI  == cCliente                    .And.;
											( cAliasACK )->ACK_LOJA    == cLoja                       .And.;
											( cAliasACK )->ACK_GRPCLI  == Space(Len(SA1->A1_GRPVEN)) .And. ;
											( cAliasACK )->ACK_GRPVEN  == Space(Len(SA3->A3_GRPREP)) .And. ;
											( cAliasACK )->ACK_CODVEN  == cCodVen
									
			If Eval( bCondic ) 
				//Ŀ
				// Avalia a regra para o item                                             
				//                           
				lContinua  := .F.
				lUltResult := .T.
				cResult    := ( cAliasACK )->ACK_CODVER
				If FtVerbaIt( cAliasSC5,cAliasSC6,( cAliasACK )->ACK_CODVER, cProduto, aProdDesc,lBaixa, @cVerbaBlq, @cItemBlq)
					cRet := '1' //-- Possui Verba de Vendas com Itens 
				Else          
					cRet := '2' //-- Possui Verba de Vendas sem Itens 
				EndIf
			EndIf 	
			
			If !lContinua
				Exit 
			EndIf 								
						
			( cAliasACK )->( DbSkip() ) 			
		
		End
	
		//Ŀ
		// Fecha a area de trabalho da query                                      
		//
		#IFDEF TOP
			( cAliasACK )->( dbCloseArea() ) 
			DbSelectArea( "ACK" ) 
		#ENDIF 			
	
	Endif
		
	
	//Ŀ
	// Pesquisa a regra para o grupo de clientes para um vendedor             
	//
	If lContinua                                   
	
		//Ŀ
		// Verifica se o cliente esta inserido em um grupo de clientes e se o     
		// vendedor esta preenchido                                               	
		//
	
		If lGrupoCli .And. !Empty(cCodVen)
	
			//Ŀ
			// Percorre os grupos para combinacao com os vendedores                   
			//
	   		For nLoop := 1 To Len( aGruposCli )   
	
				#IFDEF TOP 
				
					cAliasACK := "QUERYACK" 
		
					lQuery  := .T.
		
					cQuery := ""
					cQuery += "SELECT * FROM "  + RetSqlName( "ACK" ) + " ACK " 
					cQuery += "WHERE "	
					cQuery += "ACK_FILIAL='"    + xFilial( "ACK" )    + "' AND " 
					cQuery += "ACK_CODCLI='"    + Space(Len(SA1->A1_COD))  + "' AND " 
					cQuery += "ACK_LOJA='"      + Space(Len(SA1->A1_LOJA)) + "' AND "
					cQuery += "ACK_GRPCLI='"    + aGruposCli[nLoop,1] + "' AND "	
					cQuery += "ACK_CODVEN='"    + cCodVen             + "' AND "
					cQuery += "ACK_GRPVEN='"    + Space(Len(SA3->A3_GRPREP)) + "' AND "
					cQuery += "ACK_DATINI <='"  + cDataBase           + "' AND "
					cQuery += "ACK_DATFIM >='"  + cDataBase           + "' AND "
					cQuery += "ACK.D_E_L_E_T_=' '"  
					
					cQuery := ChangeQuery( cQuery )        
					
					dbUseArea( .T., "TOPCONN", TcGenQry( , , cQuery ), cAliasACK, .F., .T. ) 
							       
				#ELSE           
								
					cAliasACK := "ACK" 
				
					ACK->( DbSetOrder( 5 ) ) 
					ACK->( DbSeek( xFilial("ACK") + Space(Len(SA1->A1_COD)) + Space(Len(SA1->A1_LOJA)) + aGruposCli[nLoop,1] + Space(Len(SA3->A3_GRPREP)) + cCodVen ) ) 
									
				#ENDIF 
	   	
				While !( cAliasACK )->( Eof() ) .And. xFilial("ACK") == ( cAliasACK )->ACK_FILIAL .And.;
							( cAliasACK )->ACK_CODCLI  == Space(Len(SA1->A1_COD))   .And.;
							( cAliasACK )->ACK_LOJA    == Space(Len(SA1->A1_LOJA))  .And.;
							( cAliasACK )->ACK_GRPCLI  == aGruposCli[nLoop,1]          .And. ;
							( cAliasACK )->ACK_GRPVEN  == Space(Len(SA3->A3_GRPREP))	.And. ;
							( cAliasACK )->ACK_CODVEN  == cCodVen
										
					If Eval( bCondic ) 							
						//Ŀ
						// Avalia a Verba para o item                                             
						//
						lContinua  := .F.					
						lUltResult := .T.						
						cResult    := ( cAliasACK )->ACK_CODVER						
						If FtVerbaIt( cAliasSC5,cAliasSC6,( cAliasACK )->ACK_CODVER, cProduto, aProdDesc, lBaixa, @cVerbaBlq, @cItemBlq)
							cRet := '1' //-- Possui Itens da Verba
						Else          
							cRet := '2' //-- Nao Possui Itens da Verba				
						EndIf						
					EndIf
						
					If !lContinua
						Exit 
					EndIf 								
	
					( cAliasACK )->( DbSkip() )	
				  
				End	         
	
				//Ŀ
				// Fecha a area de trabalho da query                                      
				//
				#IFDEF TOP
					( cAliasACK )->( dbCloseArea() ) 
					DbSelectArea( "ACK" ) 
				#ENDIF 			
				
				If !lContinua 
					Exit
				EndIf 	
	
			Next nLoop 
	
		EndIf 
		
	EndIf 
	
	//Ŀ
	// Pesquisa a verba para um cliente e um grupo de vendedores              
	//
	
	If lContinua                                   
	
		//Ŀ
		// Verifica se o cliente esta inserido em um grupo de clientes            
		//
		If lGrupoVen
	
	   		For nLoop := 1 To Len( aGruposVen )   
	
				#IFDEF TOP 
				
					cAliasACK := "QUERYACK" 
		
					lQuery  := .T.
		
					cQuery := ""
					cQuery += "SELECT * FROM "  + RetSqlName( "ACK" ) + " ACK " 
					cQuery += "WHERE "	
					cQuery += "ACK_FILIAL='"    + xFilial( "ACK" )    + "' AND " 
					cQuery += "ACK_CODCLI='"    + cCliente  + "' AND " 
					cQuery += "ACK_LOJA='"      + cLoja     + "' AND "
					cQuery += "ACK_GRPCLI='"    + Space(Len(SA1->A1_GRPVEN)) + "' AND "	
					cQuery += "ACK_CODVEN='"    + Space(Len(SA3->A3_COD))    + "' AND "
					cQuery += "ACK_GRPVEN='"    + aGruposVen[nLoop,1]    + "' AND "
					cQuery += "ACK_DATINI <='"  + cDataBase           + "' AND "
					cQuery += "ACK_DATFIM >='"  + cDataBase           + "' AND "
					cQuery += "ACK.D_E_L_E_T_=' '"  
					
					cQuery := ChangeQuery( cQuery )        
					
					dbUseArea( .T., "TOPCONN", TcGenQry( , , cQuery ), cAliasACK, .F., .T. ) 
							       
				#ELSE           
								
					cAliasACK := "ACK" 
				
					ACK->( DbSetOrder( 5 ) ) 
					ACK->( DbSeek( xFilial("ACK") + cCliente + cLoja + Space(Len(SA1->A1_GRPVEN)) + aGruposVen[nLoop,1]  + cCodVen ) ) 
									
				#ENDIF 
	   	
				While !( cAliasACK )->( Eof() ) .And. xFilial("ACK") == ( cAliasACK )->ACK_FILIAL .And.;
							( cAliasACK )->ACK_CODCLI  == cCliente                   .And.;
							( cAliasACK )->ACK_LOJA    == cLoja                      .And.;
							( cAliasACK )->ACK_GRPCLI  == Space(Len(SA1->A1_GRPVEN)) .And. ;
							( cAliasACK )->ACK_GRPVEN  == aGruposVen[nLoop,1]           .And. ;
							( cAliasACK )->ACK_CODVEN  == Space(Len(SA3->A3_COD))
										
					If Eval( bCondic ) 							
						//Ŀ
						// Avalia a Verba para o item                                             
						//
						lContinua  := .F.					
						lUltResult := .T.						
						cResult    := ( cAliasACK )->ACK_CODVER						
						If FtVerbaIt( cAliasSC5,cAliasSC6,( cAliasACK )->ACK_CODVER, cProduto, aProdDesc, lBaixa, @cVerbaBlq, @cItemBlq)
							cRet := '1' //-- Possui Itens da Verba
						Else          
							cRet := '2' //-- Nao Possui Itens da Verba				
			         EndIf
					EndIf
						
					If !lContinua
						Exit 
					EndIf 								
	
					( cAliasACK )->( DbSkip() )	
				  
				End	         
	
				//Ŀ
				// Fecha a area de trabalho da query                                      
				//
				#IFDEF TOP
					( cAliasACK )->( dbCloseArea() ) 
					DbSelectArea( "ACK" ) 
				#ENDIF 			
	
				If !lContinua 
					Exit
				EndIf 	
	
			Next nLoop 
	
		EndIf 
		
	EndIf 
	
	//Ŀ
	// Verifica se o grupos de vendedores com grupos de clientes              
	//
	If lContinua                                   
	
		//Ŀ
		// Verifica se o cliente esta inserido em um grupo de clientes            
		//
		If lGrupoVen .And. lGrupoCli
	
	   		For nLoop := 1 To Len( aGruposCli )   
	   		
	   			For nLoop2 := 1 to Len(aGruposVen)
	
					#IFDEF TOP 
				
						cAliasACK := "QUERYACK" 
		    	
						lQuery  := .T.
		
						cQuery := ""
						cQuery += "SELECT * FROM "  + RetSqlName( "ACK" ) + " ACK " 
						cQuery += "WHERE "	
						cQuery += "ACK_FILIAL='"    + xFilial( "ACK" )    + "' AND " 
						cQuery += "ACK_CODCLI='"    + Space(Len(SA1->A1_COD))+ "' AND " 
						cQuery += "ACK_LOJA='"      + Space(Len(SA1->A1_LOJA))  + "' AND "
						cQuery += "ACK_GRPCLI='"    + aGruposCli[nLoop,1]       + "' AND "	
						cQuery += "ACK_CODVEN='"    + Space(Len(SA3->A3_COD))    + "' AND "
						cQuery += "ACK_GRPVEN='"    + aGruposVen[nLoop2,1]    + "' AND "
						cQuery += "ACK_DATINI <='"  + cDataBase           + "' AND "
						cQuery += "ACK_DATFIM >='"  + cDataBase           + "' AND "
						cQuery += "ACK.D_E_L_E_T_=' '"  
					
						cQuery := ChangeQuery( cQuery )        
					
						dbUseArea( .T., "TOPCONN", TcGenQry( , , cQuery ), cAliasACK, .F., .T. ) 
								       
					#ELSE           
								
						cAliasACK := "ACK" 
				
						ACK->( DbSetOrder( 5 ) ) 
						ACK->( DbSeek( xFilial("ACK") + Space(Len(SA1->A1_COD)) + Space(Len(SA1->A1_LOJA)) + aGruposCli[nLoop,1] + aGruposVen[nLoop2,1]  + cCodVen ) ) 
									
					#ENDIF 
	   	
					While !( cAliasACK )->( Eof() ) .And. xFilial("ACK") == ( cAliasACK )->ACK_FILIAL .And.;
							( cAliasACK )->ACK_CODCLI  == Space(Len(SA1->A1_COD)) .And.;
							( cAliasACK )->ACK_LOJA    == Space(Len(SA1->A1_LOJA))   .And.;
							( cAliasACK )->ACK_GRPCLI  == aGruposCli[nLoop,1]         .And. ;
							( cAliasACK )->ACK_GRPVEN  == aGruposVen[nLoop2,1]        .And. ;
							( cAliasACK )->ACK_CODVEN  == Space(Len(SA3->A3_COD))
											
						If Eval( bCondic ) 							
							//Ŀ
							// Avalia a Verba para o item                                             
							//
							lContinua  := .F.						
							lUltResult := .T.							
							cResult    := ( cAliasACK )->ACK_CODVER							
							If FtVerbaIt( cAliasSC5,cAliasSC6,( cAliasACK )->ACK_CODVER, cProduto, aProdDesc, lBaixa, @cVerbaBlq, @cItemBlq)
								cRet := '1' //-- Possui Itens da Verba
							Else          
								cRet := '2' //-- Nao Possui Itens da Verba				
							EndIf											
						EndIf 
						
						If !lContinua
							Exit 
						EndIf 								
	
						( cAliasACK )->( DbSkip() )	
				  
					End	         
	
					//Ŀ
					// Fecha a area de trabalho da query                                      
					//
					#IFDEF TOP
						( cAliasACK )->( dbCloseArea() ) 
						DbSelectArea( "ACK" ) 
					#ENDIF 			
	
					If !lContinua 
						Exit
					EndIf 	
		
	            
				Next nLoop2
	
			Next nLoop 
	
		EndIf 
		
	EndIf 
	
	//Ŀ
	// Verifica se o existe verba para o cliente e todos os vendedores        
	//
	
	If lContinua
	
		#IFDEF TOP 
		
			cAliasACK := "QUERYACK" 
			
			lQuery  := .T.
			
			cQuery := ""
			cQuery += "SELECT * FROM "  + RetSqlName( "ACK" ) + " ACK " 
			cQuery += "WHERE "	
			cQuery += "ACK_FILIAL='"    + xFilial( "ACK" )    + "' AND " 
			cQuery += "ACK_CODCLI='"    + cCliente            + "' AND " 
			cQuery += "ACK_LOJA='"      + cLoja               + "' AND "
			cQuery += "ACK_GRPCLI='"    + Space(Len(SA1->A1_GRPVEN)) + "' AND "	
			cQuery += "ACK_CODVEN='"    + Space(Len(SA3->A3_COD))    + "' AND "
			cQuery += "ACK_GRPVEN='"    + Space(Len(SA3->A3_GRPREP)) + "' AND "
			cQuery += "ACK_DATINI <='"  + cDataBase           + "' AND "
			cQuery += "ACK_DATFIM >='"  + cDataBase           + "' AND "
			cQuery += "ACK.D_E_L_E_T_=' '"  
			
			cQuery := ChangeQuery( cQuery )        
			
			dbUseArea( .T., "TOPCONN", TcGenQry( , , cQuery ), cAliasACK, .F., .T. ) 
		       
		#ELSE           
			
			cAliasACK := "ACK" 
		
			ACK->( DbSetOrder( 5 ) ) 
			ACK->( DbSeek( xFilial("ACK") + cCliente + cLoja + Space(Len(SA1->A1_GRPVEN)) + Space(Len(SA3->A3_GRPREP)) + Space(Len(SA3->A3_COD)) ) ) 
			
		#ENDIF 
		
		While !( cAliasACK )->( Eof() ) .And. xFilial("ACK") == ( cAliasACK )->ACK_FILIAL .And.;
					( cAliasACK )->ACK_CODCLI  == cCliente .And.;
					( cAliasACK )->ACK_LOJA    == cLoja    .And.;
					( cAliasACK )->ACK_GRPCLI  == Space(Len(SA1->A1_GRPVEN))  .And. ;
					( cAliasACK )->ACK_GRPVEN  == Space(Len(SA3->A3_GRPREP)) .And. ;
					( cAliasACK )->ACK_CODVEN  == Space(Len(SA3->A3_COD))
			
			If Eval( bCondic ) 
				//Ŀ
				// Avalia a regra para o item                                             
				//                           
				lContinua  := .F.      
				lUltResult := .T.				
				cResult    := ( cAliasACK )->ACK_CODVER				
				If FtVerbaIt( cAliasSC5,cAliasSC6,( cAliasACK )->ACK_CODVER, cProduto, aProdDesc, lBaixa, @cVerbaBlq, @cItemBlq)
					cRet := '1' //-- Possui Itens da Verba
				Else          
					cRet := '2' //-- Nao Possui Itens da Verba				
				EndIf
			EndIf	
				
			If !lContinua
				Exit 
			EndIf 								
							
			( cAliasACK )->( DbSkip() ) 			
			
		End
		
		//Ŀ
		// Fecha a area de trabalho da query                                      
		//
		#IFDEF TOP
			( cAliasACK )->( dbCloseArea() ) 
			DbSelectArea( "ACK" ) 
		#ENDIF 			
		
	Endif
	                 	
	
	//Ŀ
	// Verifica se o existe verba para o grupo do cliente e todos os vendedores  
	//
	
	If lContinua
	
		If lGrupoCli
	
			For nLoop := 1 to Len(aGruposCli)
		
				#IFDEF TOP 
		
					cAliasACK := "QUERYACK" 
				
					lQuery  := .T.
			
					cQuery := ""
					cQuery += "SELECT * FROM "  + RetSqlName( "ACK" ) + " ACK " 
					cQuery += "WHERE "	
					cQuery += "ACK_FILIAL='"    + xFilial( "ACK" )    + "' AND " 
					cQuery += "ACK_CODCLI='"    + Space(Len(SA1->A1_COD))    + "' AND " 
					cQuery += "ACK_LOJA='"      + Space(Len(SA1->A1_LOJA))   + "' AND "
					cQuery += "ACK_GRPCLI='"    + aGruposCli[nLoop,1]         + "' AND "	
					cQuery += "ACK_CODVEN='"    + Space(Len(SA3->A3_COD))    + "' AND "
					cQuery += "ACK_GRPVEN='"    + Space(Len(SA3->A3_GRPREP)) + "' AND "
					cQuery += "ACK_DATINI <='"  + cDataBase                   + "' AND "
					cQuery += "ACK_DATFIM >='"  + cDataBase                   + "' AND "
					cQuery += "ACK.D_E_L_E_T_=' '"  
			
					cQuery := ChangeQuery( cQuery )        
			
					dbUseArea( .T., "TOPCONN", TcGenQry( , , cQuery ), cAliasACK, .F., .T. ) 
		       
				#ELSE           
			
					cAliasACK := "ACK" 
		    	
					ACK->( DbSetOrder( 5 ) ) 
					ACK->( DbSeek( xFilial("ACK") + Space(Len(SA1->A1_COD)) + Space(Len(SA1->A1_LOJA)) + aGruposCli[nLoop,1] + Space(Len(SA3->A3_GRPREP)) + Space(Len(SA3->A3_COD)) ) ) 
			
				#ENDIF 
		
				While !( cAliasACK )->( Eof() ) .And. xFilial("ACK") == ( cAliasACK )->ACK_FILIAL .And.;
					( cAliasACK )->ACK_CODCLI  == Space(Len(SA1->A1_COD))    .And.;
					( cAliasACK )->ACK_LOJA    == Space(Len(SA1->A1_LOJA))   .And.;
					( cAliasACK )->ACK_GRPCLI  == aGruposCli[nLoop,1]        .And. ;
					( cAliasACK )->ACK_GRPVEN  == Space(Len(SA3->A3_GRPREP)) .And. ;
					( cAliasACK )->ACK_CODVEN  == Space(Len(SA3->A3_COD))
			
					If Eval( bCondic ) 
						//Ŀ
						// Avalia a regra para o item                                             
						//                           
						lContinua  := .F.
						lUltResult := .T.			   
						cResult    := ( cAliasACK )->ACK_CODVER									
                  If FtVerbaIt( cAliasSC5,cAliasSC6,( cAliasACK )->ACK_CODVER, cProduto, aProdDesc, lBaixa, @cVerbaBlq, @cItemBlq)
        					cRet := '1' //-- Possui Itens da Verba
						Else          
							cRet := '2' //-- Nao Possui Itens da Verba				
						EndIf
				   EndIf   
				
					If !lContinua
						Exit 
					EndIf 								
							
					( cAliasACK )->( DbSkip() ) 			
			
				End
		
				//Ŀ
				// Fecha a area de trabalho da query                                      
				//
				#IFDEF TOP
					( cAliasACK )->( dbCloseArea() ) 
					DbSelectArea( "ACK" ) 
				#ENDIF 			
		    Next nLoop
		    
		Endif	    
		
	Endif
	
	
	//Ŀ
	// Verifica se o existe verba para o vendedor e todos os clientes         
	//
	
	If lContinua
	
		If !Empty(cCodVen)
	
			//Ŀ
			// Verifica se o existe verba para o vendedor e o cliente                 
			//
		
			#IFDEF TOP 
		
				cAliasACK := "QUERYACK" 
			
				lQuery  := .T.
			
				cQuery := ""
				cQuery += "SELECT * FROM "  + RetSqlName( "ACK" ) + " ACK " 
				cQuery += "WHERE "	
				cQuery += "ACK_FILIAL='"    + xFilial( "ACK" )    + "' AND " 
				cQuery += "ACK_CODCLI='"    + Space(Len(SA1->A1_COD))    + "' AND " 
				cQuery += "ACK_LOJA='"      + Space(Len(SA1->A1_LOJA))   + "' AND "
				cQuery += "ACK_GRPCLI='"    + Space(Len(SA1->A1_GRPVEN)) + "' AND "	
				cQuery += "ACK_CODVEN='"    + cCodVen                     + "' AND "
				cQuery += "ACK_GRPVEN='"    + Space(Len(SA3->A3_GRPREP)) + "' AND "
				cQuery += "ACK_DATINI <='"  + cDataBase           + "' AND "
				cQuery += "ACK_DATFIM >='"  + cDataBase           + "' AND "
				cQuery += "ACK.D_E_L_E_T_=' '"  
			
				cQuery := ChangeQuery( cQuery )        
			
				dbUseArea( .T., "TOPCONN", TcGenQry( , , cQuery ), cAliasACK, .F., .T. ) 
		       
			#ELSE           
			
				cAliasACK := "ACK" 
		
				ACK->( DbSetOrder( 5 ) ) 
				ACK->( DbSeek( xFilial("ACK") + Space(Len(SA1->A1_COD)) + Space(Len(SA1->A1_LOJA)) + Space(Len(SA1->A1_GRPVEN)) + Space(Len(SA3->A3_GRPREP)) + cCodVen ) ) 
			
			#ENDIF 
		
			While !( cAliasACK )->( Eof() ) .And. xFilial("ACK") == ( cAliasACK )->ACK_FILIAL .And.;
						( cAliasACK )->ACK_CODCLI  == Space(Len(SA1->A1_COD)) .And.;
						( cAliasACK )->ACK_LOJA    == Space(Len(SA1->A1_LOJA))    .And.;
						( cAliasACK )->ACK_GRPCLI  == Space(Len(SA1->A1_GRPVEN))  .And. ;
						( cAliasACK )->ACK_GRPVEN  == Space(Len(SA3->A3_GRPREP)) .And. ;
						( cAliasACK )->ACK_CODVEN  == cCodVen
			
				If Eval( bCondic ) 
					//Ŀ
					// Avalia a regra para o item                                             
					//                           
					lContinua  := .F.
					lUltResult := .T.
					cResult    := ( cAliasACK )->ACK_CODVER					
					If FtVerbaIt( cAliasSC5,cAliasSC6,( cAliasACK )->ACK_CODVER, cProduto, aProdDesc, lBaixa, @cVerbaBlq, @cItemBlq)
						cRet := '1' //-- Possui Itens da Verba
					Else          
						cRet := '2' //-- Nao Possui Itens da Verba				
					EndIf
				EndIf	
									
				If !lContinua
					Exit 
				EndIf 								
							
				( cAliasACK )->( DbSkip() ) 			
			
			End
		
			//Ŀ
			// Fecha a area de trabalho da query                                      
			//
			#IFDEF TOP
				( cAliasACK )->( dbCloseArea() ) 
				DbSelectArea( "ACK" ) 
			#ENDIF 			
			
		Endif	
		
	Endif
	
	//Ŀ
	// Verifica se o existe verba somente para o grupo de vendedores          
	//
	
	If lContinua
	
		If lGrupoVen
	
			For nLoop := 1 to Len(aGruposVen)
		
				#IFDEF TOP 
		
					cAliasACK := "QUERYACK" 
				
					lQuery  := .T.
			
					cQuery := ""
					cQuery += "SELECT * FROM "  + RetSqlName( "ACK" ) + " ACK " 
					cQuery += "WHERE "	
					cQuery += "ACK_FILIAL='"    + xFilial( "ACK" )    + "' AND " 
					cQuery += "ACK_CODCLI='"    + Space(Len(SA1->A1_COD))    + "' AND " 
					cQuery += "ACK_LOJA='"      + Space(Len(SA1->A1_LOJA))   + "' AND "
					cQuery += "ACK_GRPCLI='"    + Space(Len(SA1->A1_GRPVEN))         + "' AND "	
					cQuery += "ACK_CODVEN='"    + Space(Len(SA3->A3_COD))    + "' AND "
					cQuery += "ACK_GRPVEN='"    + aGruposVen[nLoop,1] + "' AND "
					cQuery += "ACK_DATINI <='"  + cDataBase                   + "' AND "
					cQuery += "ACK_DATFIM >='"  + cDataBase                   + "' AND "
					cQuery += "ACK.D_E_L_E_T_=' '"  
			
					cQuery := ChangeQuery( cQuery )        
			
					dbUseArea( .T., "TOPCONN", TcGenQry( , , cQuery ), cAliasACK, .F., .T. ) 
		       
				#ELSE           
			
					cAliasACK := "ACK" 
		    	
					ACK->( DbSetOrder( 5 ) ) 
					ACK->( DbSeek( xFilial("ACK") + Space(Len(SA1->A1_COD)) + Space(Len(SA1->A1_LOJA)) + Space(Len(SA1->A1_GRPVEN)) + aGruposVen[nLoop,1] + Space(Len(SA3->A3_COD)) ) ) 
			
				#ENDIF 
		
				While !( cAliasACK )->( Eof() ) .And. xFilial("ACK") == ( cAliasACK )->ACK_FILIAL .And.;
					( cAliasACK )->ACK_CODCLI  == Space(Len(SA1->A1_COD))    .And.;
					( cAliasACK )->ACK_LOJA    == Space(Len(SA1->A1_LOJA))   .And.;
					( cAliasACK )->ACK_GRPCLI  == Space(Len(SA1->A1_GRPVEN)) .And. ;
					( cAliasACK )->ACK_GRPVEN  == aGruposVen[nLoop,1] .And. ;
					( cAliasACK )->ACK_CODVEN  == Space(Len(SA3->A3_COD))
			
					If Eval( bCondic ) 
						//Ŀ
						// Avalia a regra para o item                                             
						//                           
						lContinua  := .F.
						lUltResult := .T.
						cResult    := ( cAliasACK )->ACK_CODVER						
						If FtVerbaIt( cAliasSC5,cAliasSC6,( cAliasACK )->ACK_CODVER, cProduto, aProdDesc, lBaixa, @cVerbaBlq, @cItemBlq)
							cRet := '1' //-- Possui Itens da Verba
						Else          
							cRet := '2' //-- Nao Possui Itens da Verba				
						EndIf
					EndIf	
									
					If !lContinua
						Exit 
					EndIf 								
							
					( cAliasACK )->( DbSkip() ) 			
			
				End
		
				//Ŀ
				// Fecha a area de trabalho da query                                      
				//
				#IFDEF TOP
					( cAliasACK )->( dbCloseArea() ) 
					DbSelectArea( "ACK" ) 
				#ENDIF 			
				
		    Next nLoop
		    
		Endif	    
		
	Endif

	//Ŀ
	//Guarda os ultimos resultados                                            
	//
	If lUltResult .And. cRet == "2"
		aadd(aUltResult,{cCliente,cLoja,cCodVen,cResult,cRet,cVerbaBlq,cItemBlq})
		If Len(aUltResult) > MAXSAVERESULT
			aUltResult := aDel(aUltResult,1)
			aUltResult := aSize(aUltResult,MAXSAVERESULT)
		EndIf
	EndIf
	
Else
	cVerbaBlq  := aUltResult[ nScan, 6 ]  //codigo da verba que fez o bloqueio
	cItemBlq   := aUltResult[ nScan, 7 ]  //item da verba que bloqueou o lancamento
	cRet       := aUltResult[ nScan, 5 ]
Endif	
	
RestArea(aAreaACK)
RestArea(aArea)

Return(cRet)                                                                   


/*/


Ŀ
Funcao    FtVerbaIt  Autor Henry Fila              Data 14.02.2003
Ĵ
Descrio Rotina de avaliacao dos itens da verba                      
                                                                      
Ĵ
ParametrosExpC1: Alias do SC5                                         
          ExpC2: Alias do SC6                                         
          ExpC3: Codigo da Verba                                      
          ExpC4: Codigo do produto                                    
          ExpA5: Array com os dados para a analise                    
          ExpL6: Indice se a baixa sera realizada                     
          ExpL7: Indice se zera caso saldo menor que desconto         
          ExpL7: Verba que bloqueou o lancamento                      
          ExpL8: Item que bloqueou o lancamento                       
Ĵ
Retorno   ExpL1: Verba de Vendas                                      
                                                                      
Ĵ
Descrio Esta rotina tem como objetivo avaliar a verba de vendas     
          conforme os parametros da rotina                            
                                                                      
Ĵ
Observacao                                                            
                                                                      
Ĵ
Uso        Materiais/Distribuicao/Logistica                           
ٱ


/*/
Static Function FtVerbaIt(	cAliasSC5,	cAliasSC6,	cCodVer,	cProduto,;
							aProdDesc, 	lBaixa, cVerbaBlq, cItemBlq)

Local nSaldo     := 0           
Local nVlrDesc   := 0
Local nVlrRegra  := 0
Local nSaldoCon  := 0
Local nDescPed   := aProdDesc[5]   //Desconto do pedido
Local nDescReg   := aProdDesc[6]   //Desconto permitido pela regra

Local lRet       := .F.
Local lSomaVer   := (SuperGetMv("MV_SOMAVER",.F.,"S") =="S")   
Local nFatorSoma := SuperGetMv("MV_FTRSOMA",.F.,100)



ACL->(DbSetOrder(2))
If !ACL->(DbSeek(xFilial("ACL")+cProduto+cCodVer))         
	ACL->(DbSeek(xFilial("ACL")+Space(Len(SB1->B1_COD))+cCodVer))	
Endif

//busca o item do pedido 
DbSelectArea(cAliasSC6)
(cAliasSC6)->(DbSetOrder(1))
(cAliasSC6)->(DbSeek(xFilial(cAliasSC6)+ (cAliasSC5)->C5_NUM + aProdDesc[2] + aProdDesc[1] ))


If ACL->(Found())

	nSaldo   := ACL->ACL_SALDO

	//Ŀ
	//Verifica se o ocorrido foi desconto                         
	//

	Do Case

	Case (aProdDesc[3] < aProdDesc[4]) .Or. !lSomaVer

		//Ŀ
		//Calcula o valor total do desconto do item no pedido de venda
		//
		nVlrDesc := ((cAliasSC6)->C6_QTDVEN * (cAliasSC6)->C6_PRUNIT) * (nDescPed /100)

		//Ŀ
		//Calcula o valor total do desconto do item no pedido de venda
		//com o % permitido pela regra                                	
		//
		If nDescReg > 0
			nVlrRegra := ((cAliasSC6)->C6_QTDVEN * (cAliasSC6)->C6_PRUNIT) * (nDescReg /100)
		Else
			nVlrRegra := nVlrDesc
		EndIf

		//Ŀ
		//Caso tenha vendido com preco maior verifica parametro se o  
		//valor ira somar na verba existente                          	
		//
		nSaldoCon := nVlrDesc - nVlrRegra
			
		//Ŀ
		//Verifica se o desconto concedido e maior que o saldo da     
		//verba de venda                                              	
		//
	
		lRet     := (ACL->ACL_SALDO >= nSaldoCon)
		If !lRet 
			nSaldoCon := ACL->ACL_SALDO
			cItemBlq  := ACL->ACL_ITEM //item que bloqueou o lancamento
		Endif	

		aProdDesc[8] := nSaldoCon		

		If lBaixa .And. ACL->ACL_SALDO > 0 .And. nSaldoCon	> 0
			RecLock("ACL",.F.)
				ACL->ACL_SALDO -= nSaldoCon
			MsUnlock()	                                                                                 
			
			//Ŀ
			//Grava tabela de movimentacoes com os dados da baixa         
			//
			DbSelectArea("ACM")
			RecLock("ACM",.T.)
				ACM->ACM_FILIAL := xFilial("ACM")
				ACM->ACM_CODVER := cCodVer
				ACM->ACM_NUMPED := (cAliasSC5)->C5_NUM
				ACM->ACM_ITEPED := (cAliasSC6)->C6_ITEM
				ACM->ACM_DATA   := dDataBase
				ACM->ACM_VALOR  := nSaldoCon
				ACM->ACM_OPERA  := "D"
			MsUnlock()			
			
		Endif	
		
	Case (aProdDesc[3] > aProdDesc[4]) .And. lSomaVer
		lRet      := .T.

		nSaldoCon := ((cAliasSC6)->C6_QTDVEN * (cAliasSC6)->C6_PRCVEN) - ((cAliasSC6)->C6_QTDVEN * (cAliasSC6)->C6_PRUNIT) 
		nSaldoCon := nSaldoCon * (nFatorSoma/100)

		aProdDesc[8] := nSaldoCon

		If lBaixa .And. nSaldoCon > 0 
			RecLock("ACL",.F.)
				ACL->ACL_SALDO += nSaldoCon
			MsUnlock()	

			//Ŀ
			//Grava tabela de movimentacoes com os dados da baixa         
			//
			RecLock("ACM",.T.)
				ACM->ACM_FILIAL := xFilial("ACM")
				ACM->ACM_CODVER := cCodVer
				ACM->ACM_NUMPED := (cAliasSC5)->C5_NUM
				ACM->ACM_ITEPED := (cAliasSC6)->C6_ITEM
				ACM->ACM_DATA   := dDataBase
				ACM->ACM_VALOR  := nSaldoCon
				ACM->ACM_OPERA  := "C"
			MsUnlock()			
			
		Endif	
		
	Case (aProdDesc[3] == aProdDesc[4]) 
		lRet := .T.
	EndCase
	
Endif	

//Ŀ
//Se bloquear por verba guarda qual verba foi                     
//
If !lRet
	cVerbaBlq := cCodVer
EndIf
	


Return(lRet)

/*/


Ŀ
Funcao    Ft190Candel Autor Henry Fila             Data 14.02.2003
Ĵ
Descrio Verifica se ja existe moviemtacao paraa a verba             
                                                                      
Ĵ
ParametrosExpC1: Codigo da verba                                      
Ĵ
Retorno   ExpL1: .T. ou .F.                                           
                                                                      
Ĵ
Descrio Esta rotina tem como objetivo verificar se ja houve movimen 
          tacao para a verba caso seja exclusao                       
                                                                      
Ĵ
Observacao                                                            
                                                                      
Ĵ
Uso        Materiais/Distribuicao/Logistica                           
ٱ


/*/
Static Function Ft190CanDel(cCodVerba)

Local lRet := .T.

DbSelectArea("ACM")
ACM->(DbSetOrder(1))
If ACM->(DbSeek(xFilial("ACM")+cCodVerba))
	Help(" ",1,"NODELETA")
	lRet := .F.
Endif		
     
Return(lRet)

/*/


Ŀ
Programa  MenuDef    Autor  Marco Bianchi          Data 01/09/2006
Ĵ
Descrio  Utilizacao de menu Funcional                               
                                                                      
                                                                      
Ĵ
Retorno   Array com opcoes da rotina.                                 
Ĵ
ParametrosParametros do array a Rotina:                               
          1. Nome a aparecer no cabecalho                             
          2. Nome da Rotina associada                                 
          3. Reservado                                                
          4. Tipo de Transao a ser efetuada:                        
          		1 - Pesquisa e Posiciona em um Banco de Dados           
              2 - Simplesmente Mostra os Campos                       
              3 - Inclui registros no Bancos de Dados                 
              4 - Altera o registro corrente                          
              5 - Remove o registro corrente do Banco de Dados        
          5. Nivel de acesso                                          
          6. Habilita Menu Funcional                                  
Ĵ
   DATA    Programador   Manutencao efetuada                         
Ĵ
                                                                     
ٱ


/*/

Static Function MenuDef()
     
aRotina		:= {	{ STR0002,"AxPesqui"	,0	,1	,0	,.F.	}	,;	//"Pesquisar" 
					{ STR0003,"Fat190Mnt"	,0	,2	,0	,NIL	}	,;	//"Visualizar"
					{ STR0004,"Fat190Mnt"	,0	,3	,0	,NIL	}	,;	//"Incluir" 
					{ STR0005,"Fat190Mnt"	,0	,4	,0	,NIL	}	,;	//"Alterar" 
					{ STR0006,"Fat190Mnt"	,0	,5	,0	,NIL	}	,;	//"Excluir"
					{ STR0007,"Fat190Leg"	,0	,4	,0	,.F.	}	}		//"Legenda"

If ExistBlock("FT190MNU")
	ExecBlock("FT190MNU",.F.,.F.)
EndIf

Return(aRotina)

/*/{Protheus.doc} FAT190DVerb

limpa o conteudo da variavel static aUltResult

@author Reynaldo Tetsu Miyashita

@since 28/04/2014

@version P11

@param nenhum 

@return Logico, Verdadeiro

/*/
Function FAT190DVerb()
	aUltResult := Nil
Return .T.
