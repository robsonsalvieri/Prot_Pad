#INCLUDE "PROTHEUS.CH"
#INCLUDE "FATA100.CH"
#INCLUDE "FWLIBVERSION.CH"

#DEFINE MAXGETDAD 8192

Static __aPrepared :={}

/*/


Ŀ
Funo     FATA100   Autor Vendas Clientes         Data 18.05.2001  
Ĵ
Descrio  Rotina de Manutencao das Regras de Negocio                   
Ĵ
Sintaxe    FATA100                                                      
Ĵ
Parametros                                                              
Ĵ
Uso        Materiais/Distribuicao/Logistica                             
Ĵ


/*/
Function FATA100(uAutoCab, uItensACT, uItensACX, uItensACN ,nOpcAuto)

Local oMBrowse	:= Nil 

Private lFT100Auto 	:= .F.
Private aAutoCab  	:= {}
Private aItensACT	:= {}
Private aItensACX	:= {}
Private aItensACN	:= {}

Private cCadastro	:= OemToAnsi(STR0007)//"Manutencao das Regras de Negocio"
Private aRotina		:= MenuDef()

Default uAutoCab	:= {}
Default uItensACT	:= {}
Default uItensACX	:= {}
Default uItensACN	:= {}

//Ŀ
//Endereca para a funcao MBrowse                                          
//
DbSelectArea("ACS")
DbSetOrder(1)

If Empty( uAutoCab )
	oMBrowse := FWMBrowse():New()
	oMBrowse:SetAlias("ACS")                                       
	oMBrowse:SetDescription(cCadastro)
	oMBrowse:Activate()
Else
	lFT100Auto	:= .T.
	aAutoCab	:= uAutoCab
	aItensACT	:= uItensACT
	aItensACX	:= uItensACX
	aItensACN	:= uItensACN
	MBrowseAuto(nOpcAuto,aClone(aAutoCab),"ACS")	
Endif

Return Nil

/*/


Ŀ
Funo    Ft100RDes  Autor Vendas Clientes         Data 18.05.2001  
Ĵ
Descrio Rotina de Manutencao da Regra de Negocio                      
Ĵ
Sintaxe   Ft100RNeg                                                     
Ĵ
ParametrosExpC1: Alias do Arquivo                                       
          ExpN2: Numero do Registro                                     
          ExpN3: Opcao do aRotina                                       
                                                                        
Ĵ
Uso        Materiais/Distribuicao/Logistica                             
Ĵ


/*/
Function Ft100RNeg(cAlias,nReg,nOpc)

Local aPosObj   	:= {}
Local aObjects  	:= {}
Local aSize     	:= {}
Local aInfo     	:= {}
Local aTitles   	:= {}
Local aHeadNeg  	:= {}
Local aHeadCom  	:= {}
Local aHeadDes  	:= {}
Local aColsNeg  	:= {}
Local aColsCom  	:= {}
Local aColsDes  	:= {}
Local aAux 			:= {}

Local nUsado    	:= 0
Local nY			:= 0
Local nX        	:= 0
Local nOpcA     	:= 0  
Local nSaveSx8  	:= GetSx8Len() 
Local cCodReg   	:= ""
Local lContinua 	:= .T.
Local lCopia    	:= nOpc==6
Local lVisualiza	:= nOpc==2
Local lRet			:= .T.

Local oDlg
Local oGetd1
Local oGetd2

Local oFolder
 
Local lFT100MRN := .F.
Local aButtons  :={}
Local lGrade    := MaGrade()

Local cCadAux := cCadastro //Guarda o texto da private

Private oGetd3
Private aTela[0][0],aGets[0]
Private oGrade := MsMatGrade():New("oGrade",,"ACN_DESCON",,"Positivo().And.Ft100VlGr()",,{{"ACN_DESCON",.T.,,.T.}}) 

DEFAULT INCLUI := .F.                 

cCadastro := OemToAnsi(STR0007) //Altera o texto da variavel Private

aTitles := {STR0008,STR0009,STR0010}

//Ŀ
//Inicializa as variaveis da Enchoice                                     
//
If INCLUI .AND. !lCopia
	RegToMemory( "ACS", .T., .F. )
EndIf
If !INCLUI .OR. lCopia
	If lCopia .OR. lVisualiza .OR. SoftLock("ACS")
		RegToMemory( "ACS", .F., .F. )
		If lCopia
			M->ACS_CODCLI := CriaVar("ACS_CODCLI",.F.)
			M->ACS_LOJA   := CriaVar("ACS_LOJA",.F.)       
			M->ACS_NOME   := CriaVar("ACS_NOME",.F.)					
			M->ACS_GRPVEN := CriaVar("ACS_GRPVEN",.F.)		
			M->ACS_DESGRP := CriaVar("ACS_DESGRP",.F.)					
		Endif	
	Else
		lContinua := .F.
	EndIf
EndIf

If lContinua

	cCodReg := Iif (lCopia, ACS->ACS_CODREG, M->ACS_CODREG)

	//Ŀ
	// Monta o Array aHeader do ACT                                 
	//
	cSeek	:= xFilial("ACT")+cCodReg
	cWhile 	:= "ACT->ACT_FILIAL + ACT->ACT_CODREG"   
	aHeader := {}
	aCols 	:= {}
	FillGetDados(	nOpc 		, "ACT", 1	, cSeek,; 
					{||&(cWhile)}, /*{|| bCond,bAct1,bAct2}*/, /*aNoFields*/,; 
			   		/*aYesFields*/, /*lOnlyYes*/,/* cQuery*/, /*bMontAcols*/, IIf(nOpc<>3,.F.,.T.),; 
					aHeadNeg/*aHeaderAux*/, aColsNeg/*aColsAux*/,{||Fat100Item("ACT")}, /*bBeforeCols*/,;
					/*bAfterHeader*/, /*cAliasQry*/)    


	//Ŀ
	// Monta o Array aHeader do ACX                                 
	//
	cSeek	:= xFilial("ACX")+cCodReg
	cWhile	:= "ACX->ACX_FILIAL + ACX->ACX_CODREG"     
	aHeader := {}
	aCols 	:= {} 
	FillGetDados(	nOpc 		, "ACX", 1	, cSeek,; 
					{||&(cWhile)}, /*{|| bCond,bAct1,bAct2}*/, /*aNoFields*/,; 
			   		/*aYesFields*/, /*lOnlyYes*/,/* cQuery*/, /*bMontAcols*/, IIf(nOpc<>3,.F.,.T.),; 
					aHeadCom/*aHeaderAux*/, aColsCom/*aColsAux*/,{||Fat100Item("ACX")}, /*bBeforeCols*/,;
					/*bAfterHeader*/, /*cAliasQry*/)    

	DbSelectArea("ACX")	
	
	If lCopia
		M->ACS_CODREG := CriaVar("ACS_CODREG",.T.) 
    EndIf                                                             
    
	//Ŀ
	// Monta o Array aHeader do ACN caso a tabela esteja criada     
	//
	cSeek	:= xFilial("ACN")+cCodReg
	cWhile	:= "ACN->ACN_FILIAL + ACN->ACN_CODREG"     
	aHeader := {}
	aCols 	:= {}
	FillGetDados(	nOpc 		, "ACN", 1	, cSeek,; 
					{||&(cWhile)}, /*{|| bCond,bAct1,bAct2}*/, /*aNoFields*/,; 
			   		/*aYesFields*/, /*lOnlyYes*/, /*cQuery*/, /*bMontAcols*/, IIf(nOpc<>3,.F.,.T.),; 
					aHeadDes/*aHeaderAux*/, aColsDes/*aColsAux*/,{||Fat100Item("ACN")}, /*bBeforeCols*/,;
					/*bAfterHeader*/, /*cAliasQry*/)  

	If lGrade
	 	aColsDes := aColsGrade(oGrade,aCols,aHeader,"ACN_CODPRO","ACN_ITEM","ACN_ITEMGR",aScan(aHeader,{|x| AllTrim(x[2]) == "ACN_DESPRO"}))
	EndIf
	
	If lCopia
		Inclui := .T.
	Endif	
		
	aHeader := {}   
	aCols 	:= {}

	//Ŀ
	// Faz o calculo automatico de dimensoes de objetos     
	//
	If ( Type("lFT100Auto") == "U" .Or. !lFT100Auto )	
		aSize := MsAdvSize()
		AAdd( aObjects, { 100, 100, .T., .T. } ) 
		AAdd( aObjects, { 200, 200, .T., .T. } )
		aInfo := { aSize[ 1 ], aSize[ 2 ], aSize[ 3 ], aSize[ 4 ], 5, 5 }
		aPosObj := MsObjSize( aInfo, aObjects,.T.)
		
		DEFINE MSDIALOG oDlg TITLE cCadastro From aSize[7],0 To aSize[6],aSize[5] of oMainWnd PIXEL
		EnChoice( "ACS", nReg, nOpc,,,,,aPosObj[1], , 3, , , , , ,.F. )
		oFolder := TFolder():New(aPosObj[2,1],aPosObj[2,2],aTitles,{"",""},oDlg,,,,.T.,.F.,aPosObj[2,4]-aPosObj[2,2],aPosObj[2,3]-aPosObj[2,1])
		oFolder:bSetOption:={|nAtu| Ft100Fld(nAtu,oFolder:nOption,oFolder,{oGetD1,oGetD2,oGetD3})}
	
		oGetD1 := MsNewGetDados():New(2,2,aPosObj[2,3]-aPosObj[2,1]-15,aPosObj[2,4]-aPosObj[2,2]-5,Iif(Altera .Or. Inclui, GD_INSERT+GD_DELETE+GD_UPDATE, 0),"Ft100LOk1()","Ft100TOk1()","+ACT_ITEM",,,MAXGETDAD,,,,oFolder:aDialogs[1],aHeadNeg,aColsNeg)
		oGetD2 := MsNewGetDados():New(2,2,aPosObj[2,3]-aPosObj[2,1]-15,aPosObj[2,4]-aPosObj[2,2]-5,Iif(Altera .Or. Inclui, GD_INSERT+GD_DELETE+GD_UPDATE, 0),"Ft100LOk2()","Ft100TOk2()","+ACX_ITEM",,,MAXGETDAD,,,,oFolder:aDialogs[2],aHeadCom,aColsCom)
		oGetD3 := MsNewGetDados():New(2,2,aPosObj[2,3]-aPosObj[2,1]-15,aPosObj[2,4]-aPosObj[2,2]-5,Iif(Altera .Or. Inclui,GD_INSERT+GD_DELETE+GD_UPDATE,0),"Ft100LOk3()","AllwaysTrue()","+ACN_ITEM",,,MAXGETDAD,,,,oFolder:aDialogs[3],aHeadDes,aColsDes)
		
		If ExistBlock( "FT100MRN" )
			aButtons := ExecBlock( "FT100MRN",.F.,.F.,{@aButtons, @oGetD1, @oGetD2, @oGetD3} )
			If ValType( aButtons ) = "A"
				lFT100MRN := .T.
			Endif  	
		Endif
		ACTIVATE MSDIALOG oDlg ON INIT EnchoiceBar(oDlg,{||nOpcA := 1,If(Ft100Ok(oGetD1,oGetD2,oGetD3,aColsNeg,aColsCom,aColsDes,oFolder, nOpc),If(!Obrigatorio(aGets,aTela),nOpcA := 0,oDlg:End()),nOpcA := 0)},{||oDlg:End()},,Iif(lFT100MRN, @aButtons,Nil))
		FATPDLogUser("FT100RNEG")	
	Else
		If EnchAuto(cAlias,aAutoCab,{|| Obrigatorio(aGets,aTela) .And. Ft100Ok(,,,,,,,nOpc)},aRotina[nOpc][4])

			If lCopia
				If Empty( aItensACT ) .And. !Empty( aColsNeg )
					For nX := 1 To Len( aColsNeg )
						For nY := 1 To Len( aHeadNeg ) 
							If ( aHeadNeg[nY][10] <> "V" .And. !Empty( aColsNeg[nX][nY] ) )
								aAdd( aAux ,{aHeadNeg[nY][2],aColsNeg[nX][nY], Nil})
							EndIf
						Next nY
						aAdd( aItensACT, aAux )
						aAux := {}
					Next nX
				EndIf
				If Empty( aItensACX ) .And. !Empty( aColsCom )
					aAux := {}
					For nX := 1 To Len( aColsCom )
						For nY := 1 To Len( aHeadCom ) 
							If ( aHeadCom[nY][10] <> "V" .And. !Empty( aColsCom[nX][nY] ) )
								aAdd( aAux ,{aHeadCom[nY][2],aColsCom[nX][nY], Nil})
							EndIf
						Next nY
						aAdd( aItensACX, aAux )  
						aAux := {}
					Next nX
				EndIf
				If Empty( aItensACN ) .And. !Empty( aColsDes )
					aAux := {}
					For nX := 1 To Len( aColsDes )
						For nY := 1 To Len( aHeadCom ) 
							If ( aHeadDes[nY][10] <> "V" .And. !Empty( aColsDes[nX][nY] ) )
								aAdd( aAux ,{aHeadDes[nY][2],aColsDes[nX][nY], Nil})
							EndIf
						Next nY
						aAdd( aItensACN, aAux )
						aAux := {}
					Next nX
				EndIf	 
			EndIf

			If !Empty( aItensACT )
				aHeader 	:= aClone( aHeadNeg )
				lRet 		:= MsGetDAuto(aItensACT,"Ft100LOk1",,aAutoCab, aRotina[nOpc][4])
				aColsNeg	:= aClone( aCols ) 
			EndIf

			If lRet 
				If !Empty( aItensACX ) 
					aCols   	:= {}
					aHeader		:= aClone( aHeadCom )
					lRet 		:= MsGetDAuto(aItensACX,"Ft100LOk2",,aAutoCab, aRotina[nOpc][4])
					aColsCom	:= aClone( aCols )
				EndIf
				If lRet 
					If !Empty( aItensACN )
						aCols 	 := {}
						aHeader	 := aClone( aHeadDes )
						lRet 	 := MsGetDAuto(aItensACN,"Ft100LOk3",,aAutoCab, aRotina[nOpc][4])
						aColsDes := aClone( aCols )
					EndIf 
				EndIf 
			EndIf
			
			If lRet
				nOpcA := 1
			EndIf

			aHeader := {}
			aCols 	:= {} 
		EndIf		
	Endif
	//Ŀ
	//Rotina de Gravacao da Tabela de preco                         
	//
	If nOpcA == 1 .And. nOpc >= 2
		Begin Transaction
		If lGrade
			aColsDes := aGradeCols(oGrade,aColsDes,aHeadDes,"ACN_CODPRO","ACN_ITEMGR","ACN_DESCON","ACN_ITEM")
		EndIf
		Ft100Grv(nOpc-2,aHeadCom,aColsCom,aHeadNeg,aColsNeg,aHeadDes,aColsDes,lCopia)
		While (GetSx8Len() > nSaveSx8)
			ConfirmSx8()
		End
		EvalTrigger()
		End Transaction
	EndIf
EndIf
//Ŀ
//Restaura a entrada da Rotina                                  
//
While (GetSx8Len() > nSaveSx8)
	RollBackSx8()
End

cCadastro := cCadAux

MsUnLockAll()
FreeUsedCode()
Return(nOpcA)

/*


ͻ
Funcao    |Ft100afcol  Autor Vendas Clientes       Data  22/02/07  
͹
Descricao Faz o tratamento do aCols                                   
͹
Parametros												              
͹
Uso        Regras de Negocio                                     	  
ͼ


*/

Static Function Fat100Item(cAlias) 

Local nX := 0
If Len(aCols) == 1
	For nX := 1 To Len(aHeader)
			If AllTrim(aHeader[nX,2]) == "ACT_ITEM" .Or. AllTrim(aHeader[nX,2])== "ACX_ITEM" .Or. AllTrim(aHeader[nX,2])== "ACN_ITEM"
				Acols[Len(Acols),nX] := "001"			
			EndIf    
 	Next nX 
EndIf 

Return(.T.)


/*/


Ŀ
Funo    Ft100Grv   Autor Vendas Clientes         Data  08/05/2001 
Ĵ
Descrio Rotina de Gravacao                                            
Ĵ
Sintaxe   Ft100Grv                                                      
Ĵ
ParametrosExpN1: Opcao da Gravacao sendo:                               
                 [1] Inclusao                                           
                 [2] Alteracao                                          
                 [3] Exclusao                                           
Ĵ
Uso        Materiais/Distribuicao/Logistica                             
Ĵ


/*/
Static Function Ft100Grv(nOpcao		,aHeadCom	,aColsCom	,aHeadNeg	,;
						 aColsNeg	,aHeadDes	,aColsDes, lCopia)

Local aArea     := GetArea()
Local aRegNo    := {}
Local lGravou   := .F.
Local lTravou   := .T.
Local nX        := 0
Local nY        := 0
Local nUsado1   := Len(aHeadNeg)
Local nUsado2   := Len(aHeadCom)
Local nUsado3   := Len(aHeadDes)
Local bCampo 	:= {|nCPO| Field(nCPO) }
Local cItem     := Repl("0",Len(ACT->ACT_ITEM))
Local cFilACS   := xFilial("ACS")
Local cFilACT   := xFilial("ACT")
Local cFilACX   := xFilial("ACX")
Local cFilACN   := xFilial("ACN")

Do Case
	Case nOpcao <> 3
		//Ŀ
		//Grava o Cabecalho                                             
		//
		DbSelectArea("ACS")
		DbSetOrder(1)
		If DbSeek(cFilACS+M->ACS_CODREG)
			RecLock("ACS",.F.)
		Else
			RecLock("ACS",.T.)
		EndIf
		For nX := 1 TO FCount()  			
			FieldPut(nX,M->&(EVAL(bCampo,nX)))
		Next nX
		ACS->ACS_FILIAL := cFilACS
		MsUnLock()
		//Ŀ
		//Guarda os registros para reaproveita-los                      
		//
		DbSelectArea("ACT")
		DbSetOrder(1)
		DbSeek(cFilACT+M->ACS_CODREG)
		While ( !Eof() .AND. cFilACT == ACT->ACT_FILIAL .AND. M->ACS_CODREG == ACT->ACT_CODREG )
			aadd(aRegNo,RecNo())
			DbSkip()
		End
		//Ŀ
		//Grava os itens                                                
		//

		cItem     := Repl("0",Len(ACT->ACT_ITEM))		
		
		For nX := 1 To Len(aColsNeg)
			lTravou := .F.
			If nX <= Len(aRegNo)
				DbSelectArea("ACT")
				DbGoto(aRegNo[nX])
				RecLock("ACT")
				lTravou := .T.
			EndIf
			If ( !aColsNeg[nX][nUsado1+1] )
				If !lTravou
					RecLock("ACT",.T.)
				EndIf
				For nY := 1 to Len(aHeadNeg)
					If aHeadNeg[nY][10] <> "V"
						ACT->(FieldPut(FieldPos(aHeadNeg[nY][2]),aColsNeg[nX][nY]))
					EndIf
				Next nY
				cItem := Soma1(cItem)
				ACT->ACT_FILIAL := cFilACT
				ACT->ACT_CODREG := M->ACS_CODREG
				ACT->ACT_ITEM   := cItem
				MsUnLock()
				lGravou := .T.
			Else
				If lTravou
					ACT->(DbDelete()) 
				EndIf
			EndIf
			MsUnLock()
		Next nX

		//Ŀ
		//Guarda os registro para reaproveita-los - ACX                 
		//
		aRegNo := {}
		cItem  := Repl("0",Len(ACX->ACX_ITEM))				
		
		DbSelectArea("ACX")
		DbSetOrder(1)
		DbSeek(cFilACX+M->ACS_CODREG)
		While ( !Eof() .AND. cFilACX == ACX->ACX_FILIAL .AND. M->ACS_CODREG == ACX->ACX_CODREG )
			aadd(aRegNo,RecNo())
			DbSkip()
		End
		//Ŀ
		//Grava os itens                                                
		//
		For nX := 1 To Len(aColsCom)
			lTravou := .F.
			If nX <= Len(aRegNo)
				DbSelectArea("ACX")
				DbGoto(aRegNo[nX])
				RecLock("ACX")
				lTravou := .T.
			EndIf
			If ( !aColsCom[nX][nUsado2+1] )
				If !lTravou
					RecLock("ACX",.T.)
				EndIf
				For nY := 1 to Len(aHeadCom)
					If aHeadCom[nY][10] <> "V"
						ACX->(FieldPut(FieldPos(aHeadCom[nY][2]),aColsCom[nX][nY]))
					EndIf
				Next nY
				cItem := Soma1(cItem)
				ACX->ACX_FILIAL := cFilACX
				ACX->ACX_CODREG := M->ACS_CODREG
				ACX->ACX_ITEM   := cItem
				MsUnLock()
				lGravou := .T.
			Else        
				If lTravou
					ACX->(DbDelete())
				EndIf
			EndIf
			MsUnLock() 
		Next nX

		//Ŀ
		//Guarda os registro para reaproveita-los - ACN                 
		//
		aRegNo := {}
		cItem  := Repl("0",Len(ACN->ACN_ITEM))				
		
		DbSelectArea("ACN")
		DbSetOrder(1)
		DbSeek(cFilACN+M->ACS_CODREG)
		While ( !Eof() .AND. cFilACN == ACN->ACN_FILIAL .AND. M->ACS_CODREG == ACN->ACN_CODREG )
			aadd(aRegNo,RecNo())
			DbSkip()
		End
		//Ŀ
		//Grava os itens                                                
		//
		For nX := 1 To Len(aColsDes)
			lTravou := .F. 
			If nX <= Len(aRegNo)
				DbSelectArea("ACN")
				DbGoto(aRegNo[nX])
				RecLock("ACN")
				lTravou := .T.
			EndIf
			If ( !aColsDes[nX][nUsado3+1] )
				If !lTravou
					RecLock("ACN",.T.)
				EndIf
				For nY := 1 to Len(aHeadDes)
					If aHeadDes[nY][10] <> "V"
						ACN->(FieldPut(FieldPos(aHeadDes[nY][2]),aColsDes[nX][nY]))
					EndIf 
				Next nY
				cItem := Soma1(cItem)
				ACN->ACN_FILIAL := cFilACN
				ACN->ACN_CODREG := M->ACS_CODREG
				ACN->ACN_ITEM   := cItem
				MsUnLock()
				lGravou := .T.
			Else        
				If lTravou
					ACN->(DbDelete())
				EndIf
			EndIf
			MsUnLock() 
		Next nX
      
	Case nOpcao == 3
		DbSelectArea("ACT")
		DbSetOrder(1)
		DbSeek(cFilACT+M->ACS_CODREG)
		While ( !Eof() .AND. cFilACT == ACT->ACT_FILIAL .AND. M->ACS_CODREG == ACT->ACT_CODREG )
			RecLock("ACT")
			DbDelete()
			MsUnLock()
			DbSkip()
		End

		DbSelectArea("ACX")
		DbSetOrder(1)
		DbSeek(cFilACX+M->ACS_CODREG)
		While ( !Eof() .AND. cFilACX == ACX->ACX_FILIAL .AND. M->ACS_CODREG == ACX->ACX_CODREG )
			RecLock("ACX")
			DbDelete()
			MsUnLock()
			DbSkip()
		End

		DbSelectArea("ACN")
		DbSetOrder(1)
		DbSeek(cFilACN+M->ACS_CODREG)
		While ( !Eof() .AND. cFilACN == ACN->ACN_FILIAL .AND. M->ACS_CODREG == ACN->ACN_CODREG )
			RecLock("ACN")
			DbDelete()
			MsUnLock()
			DbSkip()
		End
		
		DbSelectArea("ACS")
		DbSetOrder(1)
		If DbSeek(cFilACS+M->ACS_CODREG)
			RecLock("ACS")
			DbDelete()
			MsUnLock()
		EndIf
EndCase
Return(lGravou)
/*/


Ŀ
Funo    Ft100LOk1  Autor Vendas Clientes         Data  09/05/2001 
Ĵ
Descrio Rotina de Validacao da linha Ok                               
Ĵ
Sintaxe   Ft100Lok1()                                                   
Ĵ
ParametrosNenhum                                                        
                                                                        
Ĵ
Uso        Materiais/Distribuicao/Logistica                             
Ĵ


/*/
Function Ft100Lok1()

Local aArea     := GetArea()
Local lRetorno  := .T.
Local nPCodTab  := aScan(aHeader,{|x| AllTrim(x[2])=="ACT_CODTAB"})
Local nPCondPg  := aScan(aHeader,{|x| AllTrim(x[2])=="ACT_CONDPG"})
Local nPFormPg  := aScan(aHeader,{|x| AllTrim(x[2])=="ACT_FORMPG"})
Local nUsado    := Len(aHeader)
Local nX        := 0
//Ŀ
//Verifica os campos obrigatorios                                         
//
If !aCols[n][nUsado+1]
	Do Case
		Case nPCodTab == 0 .OR. nPCondPg  == 0 .OR. nPFormPg == 0
			lRetorno := .F.
			Help(" ",1,"OBRIGAT",,RetTitle("ACT_CODTAB")+","+RetTitle("ACT_CONDPG")+","+RetTitle("ACT_FORMPG"),4)
		Case Empty(aCols[n][nPCodTab]) .AND. Empty(aCols[n][nPCondPg]) .AND. Empty(aCols[n][nPCondPg]) .AND. n<>1
			lRetorno := .F.
			Help(" ",1,"OBRIGAT",,RetTitle("ACT_CODTAB")+","+RetTitle("ACT_CONDPG")+","+RetTitle("ACT_FORMPG"),4)
	EndCase
	//Ŀ
	//Verifica se nao ha valores duplicados                                   
	//
	If lRetorno
		For nX := 1 To Len(aCols)
			If nX <> N .AND. !aCols[nX][nUsado+1]
				If ( aCols[nX][nPCodTab]+aCols[nX][nPCondPg]+aCols[nX][nPFormPg] == aCols[N][nPCodTab]+aCols[N][nPCondPg]+aCols[N][nPFormPg] )
					lRetorno := .F.
					Help(" ",1,"JAGRAVADO")
				EndIf
			EndIf
		Next nX
	EndIf
EndIf
RestArea(aArea)
Return(lRetorno)

/*/


Ŀ
Funo    Ft100TOk1  Autor Vendas Clientes         Data  10/05/2001 
Ĵ
Descrio Rotina de Validacao da TudoOk                                 
Ĵ
Sintaxe   Ft100Tok1()                                                   
Ĵ
ParametrosNenhum                                                        
                                                                        
Ĵ
Uso        Materiais/Distribuicao/Logistica                             
Ĵ


/*/
Function Ft100Tok1()

Local lRetorno := .T.

Return(lRetorno)

/*/


Ŀ
Funo    Ft100LOk2  Autor Vendas Clientes         Data  09/05/2001 
Ĵ
Descrio Rotina de Validacao da linha Ok                               
Ĵ
Sintaxe   Ft100Lok2()                                                   
Ĵ
ParametrosNenhum                                                        
                                                                        
Ĵ
Uso        Materiais/Distribuicao/Logistica                             
Ĵ


/*/
Function Ft100Lok2()

Local aArea     := GetArea()
Local lRetorno  := .T.
Local nPCodPro  := aScan(aHeader,{|x| AllTrim(x[2])=="ACX_CODPRO"})
Local nPGrupo   := aScan(aHeader,{|x| AllTrim(x[2])=="ACX_GRUPO"})
Local nUsado    := Len(aHeader)
Local nX        := 0
//Ŀ
//Verifica os campos obrigatorios                                         
//
If !aCols[n][nUsado+1]
	Do Case
		Case nPCodPro == 0 .OR. nPGrupo  == 0
			lRetorno := .F.
			Help(" ",1,"OBRIGAT",,RetTitle("ACX_CODPRO")+","+RetTitle("ACT_GRUPO"),4)
		Case Empty(aCols[n][nPCodPro]) .AND. Empty(aCols[n][nPGrupo]) .AND. n<>1
			lRetorno := .F.
			Help(" ",1,"OBRIGAT",,RetTitle("ACX_CODPRO")+","+RetTitle("ACT_GRUPO"),4)
	EndCase
	//Ŀ
	//Verifica se nao ha valores duplicados                                   
	//
	If lRetorno
		For nX := 1 To Len(aCols)
			If nX <> N .AND. !aCols[nX][nUsado+1]
				If ( aCols[nX][nPCodPro]+aCols[nX][nPGrupo] == aCols[N,nPCodPro]+aCols[N][nPGrupo] )
					lRetorno := .F.
					Help(" ",1,"JAGRAVADO")
				EndIf
			EndIf
		Next nX
	EndIf
EndIf
RestArea(aArea)
Return(lRetorno)


/*/


Ŀ
Funo    Ft100LOk3  Autor Vendas Clientes         Data  09/05/2001 
Ĵ
Descrio Rotina de Validacao da linha Ok                               
Ĵ
Sintaxe   Ft100Lok2()                                                   
Ĵ
ParametrosNenhum                                                        
                                                                        
Ĵ
Uso        Materiais/Distribuicao/Logistica                             
Ĵ


/*/
Function Ft100Lok3()

Local aArea     := GetArea()
Local lRetorno  := .T.
Local nPCodPro  := aScan(aHeader,{|x| AllTrim(x[2])=="ACN_CODPRO"})
Local nPGrupo   := aScan(aHeader,{|x| AllTrim(x[2])=="ACN_GRPPRO"})
Local nUsado    := Len(aHeader)
Local nX        := 0
//Ŀ
//Verifica os campos obrigatorios                                         
//
If !aCols[n][nUsado+1]
	If !Empty(aCols[n][nPCodPro]) .AND. !Empty(aCols[n][nPGrupo]) 
		Help(" ",1,"FT100DESC")
		lRetorno := .F.
	Endif
Endif  
	
//Ŀ
//Verifica se nao ha valores duplicados                                   
//
If lRetorno
	For nX := 1 To Len(aCols)
		If nX <> N .AND. !aCols[nX][nUsado+1]
			If ( aCols[nX][nPCodPro]+aCols[nX][nPGrupo] == aCols[N,nPCodPro]+aCols[N][nPGrupo] )
				lRetorno := .F.
				Help(" ",1,"JAGRAVADO")
			EndIf
		EndIf
	Next nX
EndIf

RestArea(aArea)
Return(lRetorno)


/*/


Ŀ
Funo    Ft100TOk   Autor Vendas Clientes         Data  10/05/2001 
Ĵ
Descrio Rotina de Validacao da TudoOk                                 
Ĵ
Sintaxe   Ft100Tok2()                                                   
Ĵ
ParametrosNenhum                                                        
                                                                        
Ĵ
Uso        Materiais/Distribuicao/Logistica                             
Ĵ


/*/
Function Ft100Tok2()

Local lRetorno := .T.

Return(lRetorno)


/*/


Ŀ
Funcao    FtRegraNeg Autor Vendas Clientes         Data 15.05.2001
Ĵ
Descrio Rotina de avaliacao da regra de Negocio                     
                                                                      
Ĵ
ParametrosExpC1: Codigo do Cliente                                    
          ExpC2: Loja do Cliente                                      
          ExpC3: Tabela de Preco                                      
          ExpC4: Condicao de Pagamento                                
          ExpC5: Forma de Pagamento                                   
          ExpA6: Array unidimensional contendo os codigos de produtos 
                 [1]-Codigo do Produto                                
                 [2]-Item do pedido de venda                          
                 [3]-Desconto do pedido                               
                 [4]-Desconto permitido por regra                     
                 [5]-Status "01" Blq. Regra "02" Blq.Verba            
          ExpL7: Exibe Help                                           
          ExpC8: Codigo do Vendedor p/ avaliacao de blq por verba     
          ExpL9: Define se mostra o motivo de bloqueio por regra      
          ExpL10: Mostra bloqueio por faturamento - Alagoas           
Ĵ
Retorno   ExpL1: Negociacao valida                                    
                                                                      
Ĵ
Descrio Esta rotina tem como objetivo avaliar a regra de Negocio    
          conforme os parametros da rotina                            
                                                                      
Ĵ
Observacao                                                            
                                                                      
Ĵ
Uso        Materiais/Distribuicao/Logistica                           
ٱ


/*/
Function FtRegraNeg(cCliente, cLoja,     cTabPreco, cCondPg	,;
                    cFormPg,  aProdDesc, lHelp,     cCodVen, lVerBlqReg, lBlAlagoas)

Local aArea      := GetArea()
Local aAreaACS   := ACS->(GetArea())

Local aParam     := Nil
Local aGrupos    := {}    
Local aProdutos  := {}

Local cHoraAtual := Left( Time(), 5 )  
Local cDtHrAtual := DToS( dDataBase ) + cHoraAtual 
Local cDataAtual := DToS( dDataBase )

Local cDataVazia := Space( Len( DToS( ACS->ACS_DATATE ) ) ) 
Local cAliasACS  := ""
Local cGrpVen    := ""

Local dDataVazia := CToD( "" )    

Local lContinua  := .T.
Local lRetorno   := .T.
Local lContVerba := .T.  
Local lExecao	 := .T.
Local lVldProx	 := .F.

Local nX         := 0
Local nLoop      := 0 

Local cRegraBlq  := ""		//codigo da regra de negocio que bloqueou o lancamento
Local cItemRgBlq := ""		//item da regra de negocio que bloqueou o lancamento
Local nAbaRgBlq 			//aba da regra que gerou o bloqueio (negociacao, comercializacao, desconto)
Local cVerbaBlq  := ""		//codigo da verba de venda que causou o bloqueio de verba
Local cItemVbBlq := ""		//item da verba de venda que causou o bloqueio de verba

Local cFilSE4		:= xFilial("SE4")
Local cFilACS		:= xFilial("ACS")
Local cFilSA1		:= xFilial("SA1")

Local aInsert 	    := {}
Local nLenPrepStat  := 0 
Local nPosPrepared  := 0 
Local cMD5 		    := ""
Local lVerLib		:= A100FWExecStat()

Default cCliente  := Space( Len( SA1->A1_COD  ) )
Default cLoja     := Space( Len( SA1->A1_LOJA ) )
Default cTabPreco := Space( Len( DA0->DA0_CODTAB ) )
Default cCondPg   := Space( Len( DA0->DA0_CONDPG ) )
Default cFormPg   := Space( Len( ACO->ACO_FORMPG ) )
Default cCodVen   := Space( Len( SA3->A3_COD ) )
Default aProdutos := {} 
Default aProdDesc := {} 
Default lHelp     := .T.
Default lVerBlqReg := .F.  
Default lBlAlagoas := .F.

//Ŀ
//Se a forma de pagamnto estiver vazia pega a partir da condio.
//
If !Empty(cCondPg) .AND. Empty(cFormPg)
	cFormPg := Posicione( "SE4", 1, cFilSE4 + cCondPg, "E4_FORMA" ) 
EndIf

If Len(aProdDesc) > 0           
	Aeval(aProdDesc, {|x| If(x[9] .AND. Empty(Ascan(aProdutos, x[1]) ),Aadd(aProdutos,x[1]),)})
Endif	

//Ŀ
// Pesquisa a regra para o cliente                                        
//

cAliasACS := "QUERYACS"

cQuery := ""
cQuery += "SELECT * FROM ? "
cQuery += "WHERE "
cQuery += "ACS_FILIAL= ? AND "
cQuery += "ACS_CODCLI= ? AND "
cQuery += "ACS_LOJA= ? AND "

cQuery += "( ( ACS_TPHORA='1' AND ( ? >ACS_DATDE OR ( ? =ACS_DATDE AND  ? >=ACS_HORDE ) ) AND "
cQuery += " ( ACS_DATATE= ? OR ( ? <ACS_DATATE OR ( ? =ACS_DATATE AND  ? <=ACS_HORATE ) ) ) ) OR "
cQuery += "( ACS_TPHORA='2' AND ? >=ACS_DATDE AND ( ACS_DATATE= ? OR "
cQuery += " ? <=ACS_DATATE ) AND ? >=ACS_HORDE AND ? <=ACS_HORATE ) ) AND "

cQuery += "D_E_L_E_T_=' '"

Aadd(aInsert, RetSqlName( "ACS" ))
Aadd(aInsert, cFilACS)
Aadd(aInsert, cCliente)
Aadd(aInsert, cLoja)
Aadd(aInsert, cDataAtual)
Aadd(aInsert, cDataAtual)
Aadd(aInsert, cHoraAtual)
Aadd(aInsert, cDataVazia)
Aadd(aInsert, cDataAtual)
Aadd(aInsert, cDataAtual)
Aadd(aInsert, cHoraAtual)
Aadd(aInsert, DToS( dDatabase ))
Aadd(aInsert, cDataVazia)
Aadd(aInsert, DToS( dDataBase ))
Aadd(aInsert, cHoraAtual)
Aadd(aInsert, cHoraAtual)

nLenPrepStat := Len(aInsert)
cMD5         := MD5(cQuery) 
If (nPosPrepared := Ascan(__aPrepared,{|x| x[2] == cMD5})) == 0 
	cQuery := ChangeQuery(cQuery)
	Aadd(__aPrepared,{IIf(lVerLib,FwExecStatement():New(cQuery),FWPreparedStatement():New(cQuery)),cMD5})
	nPosPrepared := Len(__aPrepared)
Endif 
__aPrepared[nPosPrepared][1]:SetUnsafe(1, aInsert[1])
For nX := 2 to nLenPrepStat
	__aPrepared[nPosPrepared][1]:SetString(nX, aInsert[nX])
Next 

If lVerLib
	__aPrepared[nPosPrepared][1]:OpenAlias(cAliasACS)
Else	
	cQuery := __aPrepared[nPosPrepared][1]:getFixQuery()
	dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasACS,.T.,.T.)
EndIf

aInsert := aSize(aInsert,0)

While !( cAliasACS )->( Eof() ) .AND. cFilACS == ( cAliasACS )->ACS_FILIAL .AND.;
			cCliente == ( cAliasACS )->ACS_CODCLI .AND.;
			cLoja    == ( cAliasACS )->ACS_LOJA 

	//Ŀ
	// Avalia a regra para o item                                             
	//                           
	lRetorno   := .F. 		
	lExecao   := .T.
	FtRegNegIt(( cAliasACS )->ACS_CODREG, cTabPreco, cCondPg, cFormPg, aProdutos, ;
	           @aProdDesc, @lContinua, @lRetorno, @lContVerba, @lExecao, ;
	           @nAbaRgBlq, @cItemRgBlq, @cVerbaBlq, @cItemVbBlq, cCliente, cLoja, cCodVen)

	cRegraBlq := ( cAliasACS )->ACS_CODREG 	

	If  !lExecao
		If (!lContinua .and. !lRetorno)
			Exit 
		EndIf 		
	Else
		If (!lContinua .and. lRetorno)
			Exit 
		EndIf 								
    Endif

	( cAliasACS )->( DbSkip() ) 			

End

//Ŀ
// Fecha a area de trabalho da query                                      
//
( cAliasACS )->( DbCloseArea() ) 
DbSelectArea( "ACS" ) 


//Ŀ
// Pesquisa a regra para o grupo de clientes                              
//
If lContinua                                   

	SA1->( DbSetOrder( 1 ) ) 
	SA1->( DbSeek( cFilSA1 + cCliente + cLoja ) ) 	

	//Ŀ
	// Verifica se o cliente esta inserido em um grupo de clientes            
	//
	
	cGrpVen := SA1->A1_GRPVEN
	If !Empty( cGrpVen ) 
	
		//Ŀ
		// Obtem a estrutura acima do grupo do cliente                            
		//
		aGrupos := {} 
		MaCliStrUp( cGrpVen, @aGrupos )  
		
		//Ŀ
		// Percorre todos os grupos para localizar uma regra                      
		//

     	For nLoop := 1 To Len( aGrupos )   


			cAliasACS := "QUERYACS" 

			cQuery := ""
			cQuery += "SELECT * FROM "  + RetSqlName( "ACS" ) + " " 
			cQuery += "WHERE "					
			cQuery += "ACS_FILIAL='"    + cFilACS             + "' AND " 
			cQuery += "ACS_GRPVEN='"    + aGrupos[ nLoop, 1 ] + "' AND " 

			cQuery += "( ( ACS_TPHORA='1' AND ('" + cDataAtual + "'>ACS_DATDE OR ('" + cDataAtual + "'=ACS_DATDE AND '" + cHoraAtual + "'>=ACS_HORDE))  AND " 
			cQuery += " ( ACS_DATATE='" + cDataVazia +"' OR ('" + cDataAtual + "'<ACS_DATATE OR ('" + cDataAtual + "'=ACS_DATATE AND '" + cHoraAtual + "'<=ACS_HORATE ) ) ) ) OR " 

			cQuery += "( ACS_TPHORA='2' AND '" + DToS( dDatabase ) + "'>=ACS_DATDE AND ( ACS_DATATE='" + cDataVazia +"' OR "
			cQuery += "'" + DToS( dDataBase ) + "'<=ACS_DATATE ) AND '" + cHoraAtual + "'>=ACS_HORDE AND '" + cHoraAtual + "'<=ACS_HORATE ) ) AND "   

			cQuery += "D_E_L_E_T_=' '" 

			cQuery := ChangeQuery( cQuery ) 

			dbUseArea( .T., "TOPCONN", TcGenQry( , , cQuery ), cAliasACS, .F., .T. ) 


			While !( cAliasACS )->( Eof() ) .AND. cFilACS == ( cAliasACS )->ACS_FILIAL .AND.;
			       aGrupos[ nLoop, 1 ] == ( cAliasACS )->ACS_GRPVEN
						
				//Ŀ
				// Avalia a regra para o item                                             
				//
				lRetorno   := .F. 
				lExecao   := .T.
				FtRegNegIt(( cAliasACS )->ACS_CODREG, cTabPreco, cCondPg, cFormPg, aProdutos, ;
				           @aProdDesc, @lContinua, @lRetorno, @lContVerba, @lExecao, ;
				           @nAbaRgBlq, @cItemRgBlq, @cVerbaBlq, @cItemVbBlq, cCliente, cLoja, cCodVen)

				cRegraBlq := ( cAliasACS )->ACS_CODREG 	

				If  !lExecao
					If (!lContinua .and. !lRetorno)
						Exit 
					EndIf 		
				Else
					If (!lContinua .and. lRetorno)
						Exit 
					EndIf 								
		    	Endif

				( cAliasACS )->( DbSkip() )	

			End

			//Ŀ
			// Fecha a area de trabalho da query                                      
			//
			( cAliasACS )->( DbCloseArea() ) 
			DbSelectArea( "ACS" ) 

			If !lContinua 
				Exit
			EndIf 	

		Next nLoop 

	EndIf 

EndIf 


//Ŀ
// Pesquisa a regra para o codigo de clientes e grupo em branco           
//
If lContinua 

	cAliasACS := "QUERYACS" 

	cQuery := ""
	cQuery += "SELECT * FROM ? " 
	cQuery += "WHERE "			
	cQuery += "ACS_FILIAL= ? AND " 
	cQuery += "ACS_CODCLI= ? AND " 
	cQuery += "ACS_LOJA= ? AND "
	cQuery += "ACS_GRPVEN= ? AND "

	cQuery += "( ( ACS_TPHORA='1' AND ( ? >ACS_DATDE OR ( ? =ACS_DATDE AND ? >=ACS_HORDE ) ) AND " 
	cQuery += " ( ACS_DATATE= ? OR ( ? <ACS_DATATE OR ( ? =ACS_DATATE AND ? <=ACS_HORATE ) ) ) ) OR " 

	cQuery += "( ACS_TPHORA='2' AND ? >=ACS_DATDE AND ( ACS_DATATE= ? OR "
	cQuery += " ? <=ACS_DATATE ) AND ? >=ACS_HORDE AND ? <=ACS_HORATE ) ) AND "   

	cQuery += "D_E_L_E_T_=' '" 

	Aadd(aInsert, RetSqlName("ACS"))
	Aadd(aInsert, cFilACS)
	Aadd(aInsert, Space(Len(ACS->ACS_CODCLI)))
	Aadd(aInsert, Space(Len(ACS->ACS_LOJA)))
	Aadd(aInsert, Space(Len(ACS->ACS_GRPVEN)))
	Aadd(aInsert, cDataAtual)
	Aadd(aInsert, cDataAtual)
	Aadd(aInsert, cHoraAtual)
	Aadd(aInsert, cDataVazia)
	Aadd(aInsert, cDataAtual)
	Aadd(aInsert, cDataAtual)
	Aadd(aInsert, cHoraAtual)
	Aadd(aInsert, DToS(dDatabase))
	Aadd(aInsert, cDataVazia)
	Aadd(aInsert, DToS(dDatabase))
	Aadd(aInsert, cHoraAtual)
	Aadd(aInsert, cHoraAtual)

	nLenPrepStat := Len(aInsert)
	cMD5         := MD5(cQuery) 
	If (nPosPrepared := Ascan(__aPrepared,{|x| x[2] == cMD5})) == 0 
		cQuery := ChangeQuery(cQuery)
		Aadd(__aPrepared,{IIf(lVerLib,FwExecStatement():New(cQuery),FWPreparedStatement():New(cQuery)),cMD5})
		nPosPrepared := Len(__aPrepared)
	Endif 
	__aPrepared[nPosPrepared][1]:SetUnsafe(1, aInsert[1])
	For nX := 2 to nLenPrepStat
		__aPrepared[nPosPrepared][1]:SetString(nX, aInsert[nX])
	Next 
	
	If lVerLib
		__aPrepared[nPosPrepared][1]:OpenAlias(cAliasACS)
	Else
		cQuery := __aPrepared[nPosPrepared][1]:getFixQuery()
		dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasACS,.T.,.T.)
	EndIf

	aInsert := aSize(aInsert,0)

	While !( cAliasACS )->( Eof() ) 
	              
		//Ŀ
		// Avalia a regra para o item                                             
		//
		lRetorno   := .F. 
		lExecao   := .T.
		lVldProx  := .F.
		FtRegNegIt(( cAliasACS )->ACS_CODREG, cTabPreco, cCondPg, cFormPg, aProdutos, ;
		           @aProdDesc, @lContinua, @lRetorno, @lContVerba, @lExecao, ;
		           @nAbaRgBlq, @cItemRgBlq, @cVerbaBlq, @cItemVbBlq, cCliente, cLoja, ;
				   cCodVen, @lVldProx)

		cRegraBlq := ( cAliasACS )->ACS_CODREG
		
		( cAliasACS )->( DbSkip() )	

		//Caso ainda haja regra que possa bloquear a movimentao continua processando
		If lVldProx .And. Empty(cItemRgBlq) .And. !( cAliasACS )->( Eof() )
			lContinua := .T.
		EndIf
		
		If  !lExecao
			If (!lContinua .and. !lRetorno)
				Exit 
			EndIf 		
		Else
			If (!lContinua .and. lRetorno)
				Exit 
			EndIf 								
    	Endif

	End

	//Ŀ
	// Fecha a area de trabalho da query                                      
	//
	( cAliasACS )->( DbCloseArea() ) 
	DbSelectArea( "ACS" ) 

EndIf

If !(lRetorno .AND. lContVerba) .AND. lHelp 
	Help(" ",1,"FTREGRANEG")
EndIf

//Ŀ
// Caso achou bloqueio de regra marca todos os registros dos pedidos como 
// bloqueado                                                              
//
If !lRetorno .And. Upper(FunName())<>"TMKA271"//No TMK este cpo indica bloqueio do produto. 
	For nLoop := 1 to Len(aProdDesc)
		aProdDesc[nLoop,7] := "01"
	Next
Endif	


//Ŀ
// Verifica para nao mostrar a msg de bloqueio                            
//
If lVerBlqReg 

	//Ŀ
	// Caso achou bloqueio de regra ou verba mostra mensagem de bloqueio      
	// por regra/verba. Mostra somente se for a rotina liberacao de regra ou  
	// se estiver com parametro habilitado.                                   
	//
	If (!(lRetorno .AND. lContVerba)) 		
		//sempre mostra motivo do bloqueio na liberacao por regra, senao so mostra com parametro habilitado
		//No mostra o motivo de bloqueio se vier da rotina de Tranferncia de Filiais (MATA310)
		If (Upper(FunName()) <> "MATA310") .And. ( (Upper(FunName()) == "FATA210") .OR. (SuperGetMv("MV_VEBLQRG", .F., .F.)) )
			VerBlqReg(cRegraBlq, nAbaRgBlq, cItemRgBlq, cVerbaBlq, cItemVbBlq)
		EndIf
	Else
		//Ŀ
		//Se nao bloqueou por regra de negocio verifica regra especifica de alagoas 
		//Se nao for chamado pelo fata210 (liberacao regras precisa verificar se    
		//parametro MV_VERBLQRG == .T.                                              
		//
		If ((Upper(FunName())== "FATA210") .OR. (SuperGetMv("MV_VEBLQRG", .F., .F.))) .AND. ;
		((lBlAlagoas) .AND. (SC5->C5_BLQ == "1") .AND. (AllTrim(SuperGetMv("MV_ESTADO")) == "AL"))
			VerBlqReg("BLQAL", 0, "", "", "")
		EndIf
				
	EndIf

EndIf	

RestArea(aAreaACS)
RestArea(aArea)

Return(lRetorno .AND. lContVerba)

/*


Ŀ
Funcao    FtRegNegIt Autor  Vendas Clientes        Data 14/08/2002
Ĵ
Descrio  Avaliacao dos itens da regra de negocios                   
Ĵ
Sintaxe    FtRegNegIt(ExpC1,ExpC2,ExpC3,ExpC4,ExpC5,ExpL1,ExpL2)      
Ĵ
ParametrosExpC1: Codigo da regra                                      
          ExpC2: Tabela de Preco                                      
          ExpC3: Condicao de Pagamento                                
          ExpC4: Forma de Pagamento                                   
          ExpC5: Codigo do produto                                    
          ExpL1: Indica se continua pesquisa ( pass. por referencia ) 
          ExpL2: Indica se regra ou excessao ( pass. por referencia ) 
          ExpL3: Indica se continua verba    ( pass. por referencia ) 
          ExpL4: Indica se verifica verba                             
          ExpL5: Indica validacao de operacoes de excecao             
          ExpN11: Aba da regra de negocio que bloqueou o lancamento   
          ExpC12: Item da regra de negocio que bloqueou o lancamento  
          ExpC13: Verba de venda que bloqueou o lancamento            
          ExpC14: Item da verba de venda que bloqueou o lancamento    
          ExpC15: Cliente p/ analisar blqueio por verba               
          ExpC16: Loja p/ analisar blqueio por verba                  
          ExpC17: Vendedor p/ analisar blqueio por verba              
Ĵ
Retorno   Nenhum                                                      
Ĵ
Descrio Esta rotina tem como objetivo avaliar os itens da regra     
          de negocio especificada conforme os parametros              
Ĵ
Observacao                                                            
                                                                      
Ĵ
Uso        Materiais/Distribuicao/Logistica                           
Ĵ


*/
Function FtRegNegIt(cCodReg		,cTabPreco	,cCondPg	,cFormPg	,;
					aProdutos	,aProdDesc	,lContinua	,lRetorno	,;
					lContVerba  ,lExecao	,nAbaRgBlq	,cItemRgBlq	,;
					cVerbaBlq	,cItemVbBlq	,cCliente	,cLoja		,;
					cCodVen		,lVldProx )
                                                      
Local aSearch   := {} 											// Array com variantes de busca no DbSeek para caso utilizado um grupo de produtos na regra, ou somente um produto
Local cGrupo    := ""											// Grupo de produtos da regra
Local cCodPro   := ""											// Cdigo do produto da regra
Local lContItem := .T.											// Se encontrar algum grupo ou produto na regra sai do loop
Local nX        := 0											// Contador
Local nY		:= 0											// Contador
Local nLoop     := 0 											// Contador
Local nLoop2    := 0											// Contador
Local lSomaVer  := (SuperGetMv("MV_SOMAVER",.F.,"S") == "S")	// Indica se caso o vendedor realize uma venda com preco maior que o de tabela, a diferenca sera adicionada a verba correspondente.
Local aRegras	:= {}											// Regras e exceces encontradas para essa regra de negociao
Local lAchouACX := .T.
Local lProdACX  := .T.
Local lFT100RNI := ExistBlock('FT100RNI')
Local aRetREG   := {}
Local cFilACT   := xFilial("ACT")
Local cFilSB1   := xFilial("SB1")
Local cFilACX   := xFilial("ACX")
Local cFilACN   := xFilial("ACN")
Local cQuery    := ""	// Query utilizada no select
Local cAliasQry := ""	// Alias da query
Local lContDesc := .T.	// Utilizado para procurar algum bloqueio por regra
Local lDescAnt	:= .T.  // Utilizado para guardar o histrico da variavel lContDesc
Local nCntFor   := 0 	// Contador
Local aStruACN  := {}	// Estrutura utilizado no loop para correo dos campos retornados pelo TOP
Local nDcDescont:= GetSx3Cache("ACN_DESCON","X3_DECIMAL")
Local lLibACT	:= .F.
Local lBlqDesc	:= .F.
Local lTemDesc	:= .F.
Local lTCPG		:= SuperGetMV("MV_TMKTCPG",.F.,.F.)	// Parametro do SX6 que controla ou no a abertura da tela de condio de pagamento ao confirmar o atendimento.	
Local lTmka271	:= (Type("lTk271Auto") <> "U" .And. lTk271Auto) //Verifica se veio direto do execauto TMKA271
Local cNomeTmk	:= Upper(FunName())

Default lVldProx := .F.
//Ŀ
//Adiciona regras a uma array para posterior anlise.
//
ACT->( DbSetOrder( 1 ) )
If ACT->(DbSeek( cFilACT + cCodReg ))
	Do While (	ACT->ACT_FILIAL		== cFilACT .AND.	;
				ACT->ACT_CODREG		== cCodReg )
		aAdd( aRegras, { ACT->ACT_TPRGNG, ACT->ACT_CODTAB, ACT->ACT_CONDPG, ACT->ACT_FORMPG, ACT->ACT_ITEM  } )
		ACT->(DbSkip())	
	End
EndIf

If Len( aRegras ) > 0
	//Ŀ
	//Se s houver exceco, parte do princpio que est aprovado
	//at que alguma exceco bloqueie.                          
	//
	If aScan( aRegras, { |x| x[1] == "2" } ) > 0 .AND. aScan( aRegras, { |x| x[1] == "1" } ) == 0
		lRetorno := .T. 
		lExecao   := .F.
		For nX := 1 To Len( aRegras )
			If(	IF(Empty(aRegras[nX,2]), .T., AllTrim(aRegras[nX,2]) == Alltrim(cTabPreco) )	.AND.;
				IF(Empty(aRegras[nX,3]), .T., AllTrim(aRegras[nX,3]) == Alltrim(cCondPg) )	.AND.;
				IF(Empty(aRegras[nX,4]), .T., AllTrim(aRegras[nX,4]) == Alltrim(cFormPg) )	)
				lRetorno := .F.
				lContinua := .F.
				
				//Ŀ
				//Guarda motivo do bloqueio, para mostrar msg ao usuario         
				//
				cItemRgBlq := aRegras[nX,5] //item da regra que gerou bloqueio
				nAbaRgBlq := 1 //bloqueio por regra de negociacao (aba negociacao)
				
			EndIf
		Next		
	//Ŀ
	//Se no, Verifica a liberao item a item das regras e exceces.
	//
	Else
		For nX := 1 To Len( aRegras )
			If(	IF(Empty(aRegras[nX,2]), .T., AllTrim(aRegras[nX,2]) == Alltrim(cTabPreco) )	.AND.;
				IF(Empty(aRegras[nX,3]), .T., AllTrim(aRegras[nX,3]) == Alltrim(cCondPg) )	.AND.;
				IF(Empty(aRegras[nX,4]), .T., AllTrim(aRegras[nX,4]) == Alltrim(cFormPg) )	)
				lRetorno  := ( aRegras[nX,1] == "1" )
				lContinua := .F.
				lExecao   := ( aRegras[nX,1] == "1" )
				
				//Ŀ
				//Guarda motivo do bloqueio, para mostrar msg ao usuario         
				//
				If !lRetorno
					cItemRgBlq := aRegras[nX,5] //item da regra que gerou bloqueio 
					nAbaRgBlq := 1 //bloqueio por regra de negociacao (aba negociacao)
				Else
					lLibACT := .T.	
				EndIF
				
				Exit
			Else
				lRetorno  := .F. 
				lContinua := .F.	
				
				
				//Ŀ
				//Guarda motivo do bloqueio, para mostrar msg ao usuario.        
				//Bloqueado por nao achar nenhum item que atenda a regra         
				//
				If !lRetorno
					nAbaRgBlq := 1 //bloqueio por regra de negociacao (aba negociacao)

					//Caso haja bloqueio por regra, venha do TMKA271 (Televendas) e use
					//o parametro MV_TMKTCPG, adiciona o bloqueio a posio 7 da Estrutura 
					//do array "aProdDesc" (Array com os produtos e seus descontos. 
					//Utilizado na verificao da regra):
					//[7] - Indica se sera necessario verificar o saldo de verba            
					//    01 - Bloqueio de regra de negocio               
					//    02 - Bloqueio para verificacao de verba         
					If lTCPG .And. (cNomeTmk=="TMKA271" .Or. lTmka271)
						For nY := 1 To Len( aProdDesc )
							aProdDesc[nY,7] := "01"	 
						Next
					EndIf
				EndIF								
			EndIf
		Next
	EndIf
EndIf

//Ŀ
// Processa os itens de comercializacao, mesmo que tenha encontrado       
// um item negociacao valido, para localizar uma possivel excessao        
//
If lRetorno .OR. lContinua 

	//Ŀ
	// Percorre todos os produtos                                             
	//
	For nLoop2 := 1 To Len( aProdutos )  
	
		cCodPro := aProdutos[ nLoop2 ] 

		SB1->( DbSetOrder( 1 ) ) 
	   If SB1->( DbSeek( cFilSB1 + cCodPro ) ) 
	
			cGrupo := SB1->B1_GRUPO 
			lContItem := .T.
			//Ŀ
			// Alimenta as opcoes de pesquisa                                         
			//
			If Empty( cGrupo ) 
				aSearch := { { SB1->B1_COD, Space( Len( SB1->B1_GRUPO ) ) } }
			Else			
			   aSearch := { { SB1->B1_COD, Space( Len( SB1->B1_GRUPO ) ) },;
			   				{ Space( Len( SB1->B1_COD ) ), cGrupo } } 	
			EndIf 
	
			ACX->( DbSetOrder( 2 ) )
			If !ACX->( dbSeek( cFilACX + cCodReg ) ) 
				lAchouACX := .F. 
			Else
 				If Empty(ACX->ACX_CODPRO) .And. Empty(ACX->ACX_GRUPO) .And. !ACX->(EOF())			
					lRetorno  := ACX->ACX_TPRGNG == "1"
					lContinua := .F.
					
					//Ŀ
					//Guarda motivo do bloqueio, para mostrar msg ao usuario         
					//
					If !lRetorno
						cItemRgBlq:=ACX->ACX_ITEM //item da regra que gerou bloqueio 
						nAbaRgBlq := 2 //bloqueio por regra de comercializacao (aba Comercializacao)
					EndIf 
					
					Exit
				Endif
			EndIf
		
			For nLoop := 1 To Len( aSearch ) 
				If ACX->( DbSeek( cFilACX + cCodReg + aSearch[ nLoop, 1 ] + aSearch[ nLoop, 2 ] ) ) 
					lRetorno  := ACX->ACX_TPRGNG == "1"
					lContinua := .F.
					lContItem := .F.
					
					//Ŀ
					//Guarda motivo do bloqueio, para mostrar msg ao usuario         
					//
					If !lRetorno
						cItemRgBlq :=ACX->ACX_ITEM //item da regra que gerou bloqueio 
						nAbaRgBlq  := 2 //bloqueio por regra de comercializacao (aba Comercializacao)
					EndIf 
					
					Exit
		     	EndIf
			Next nLoop  
			
			If  lContItem .And. ACX->( dbSeek( cFilACX + cCodReg ) ) .And. ;
				(!Empty(ACX->ACX_CODPRO) .Or. !Empty(ACX->ACX_GRUPO)) .And. ACX->ACX_TPRGNG == "1"
		   		lProdACX := .F.
			EndIf
  			
			If Upper(FunName())=="TMKA271"
  				If lContItem .And. !lProdACX 
					aProdDesc[nLoop2,7] := "01"	 
				ElseIf !lContItem .And. lProdACX 
					aProdDesc[nLoop2,7] := ""
				EndIf
			EndIf
		Endif    
	Next nLoop2 	
	
EndIf 

// ACX contm pelo menos um registro cadastrado e algum produto do pedido nao foi encontrado -> REPROVAR.
// Se ACX vazia, APROVAR.  
If lAchouACX .And. !lProdACX
	lRetorno := .F. 
	
	//Ŀ
	//Guarda motivo do bloqueio, para mostrar msg ao usuario         
	//
	If (! lRetorno)
		nAbaRgBlq := 2 //bloqueio por regra de comercializacao (aba Comercializacao)
	EndIf
	
EndIf

//Ŀ
//Verifica se existe regras de desconto de verba.
//

If lRetorno .AND. lContVerba

	aStruACN:= ACN->(dbStruct())
       
	For nLoop := 1 to Len(aProdDesc)
		
		lContDesc := .T.

		//Ŀ
		//Verifica se o item deve ser analisado          
		//
	    
		If aProdDesc[ nLoop, 9 ]
	
			//Ŀ
			//Se o preco de lista for diferente do de venda  
			//
			
			Do Case
			
				Case aProdDesc[nLoop,3] < aProdDesc[nLoop,4]

					lTemDesc := .T.

					//Ŀ
					//Busca regra por Produto Preenchido + Grupo em branco      
					//

					cAliasQry := "QRYACN"

					cQuery := "SELECT ACN_DESCON , ACN_ITEM FROM "
					cQuery += RetSqlName("ACN")+ " ACN " 
					cQuery += " WHERE "
					cQuery += "ACN_FILIAL = '"+cFilACN+ "' AND "
					cQuery += "ACN_CODREG = '"+cCodReg+"' AND "
					cQuery += "ACN_CODPRO = '"+aProdDesc[nLoop,1]+"' AND "
					cQuery += "ACN_GRPPRO = '"+Space(Len(ACN->ACN_GRPPRO))+"' AND "
					cQuery += "ACN.D_E_L_E_T_ = ' '"

					cQuery := ChangeQuery( cQuery )        

					dbUseArea( .T., "TOPCONN", TcGenQry( , , cQuery ), cAliasQRY, .F., .T. ) 

					For nCntFor := 1 To Len(aStruACN)
						If ( aStruACN[nCntFor,2]<>"C" )
							TcSetField(cAliasQry,aStruACN[nCntFor,1],aStruACN[nCntFor,2],aStruACN[nCntFor,3],aStruACN[nCntFor,4])
						EndIf
					Next nCntFor

					//Ŀ
					//Marca flag para verificacao da verba           
					//

					If (cAliasQRY)->(!Eof())
						lContDesc := .F.
						If Round(aProdDesc[nLoop,5],nDcDescont) > (cAliasQry)->ACN_DESCON
							aProdDesc[nLoop,6] := (cAliasQry)->ACN_DESCON                  					
							aProdDesc[nLoop,7] := "02"                  
							lContVerba:= .F.
							//Ŀ
							//Guarda motivo do bloqueio, para mostrar msg ao usuario         
							//
							cItemRgBlq :=  (cAliasQry)->ACN_ITEM //item da regra que gerou bloqueio 
							lBlqDesc := .T.
						Endif
					Endif

					DbSelectArea(cAliasQry)
					DbCloseArea()

					//Ŀ
					//Se nao encontrou ,busca por Produto em Branco + Grupo Preenchido
					//					
					If lContDesc

						SB1->(DbSetOrder(1))
						If SB1->(DbSeek(cFilSB1+aProdDesc[nLoop,1]))
					
							//Ŀ
							//Se nao existe grupo cadastrado nao traz regra  
							//
							If !Empty(SB1->B1_GRUPO)
							
								cAliasQry := "QRYACN"
							
								cQuery := "SELECT ACN_DESCON , ACN_ITEM FROM "
								cQuery += RetSqlName("ACN")+ " ACN " 
								cQuery += " WHERE "
								cQuery += "ACN_FILIAL = '"+cFilACN+ "' AND "
								cQuery += "ACN_CODREG = '"+cCodReg+"' AND "
								cQuery += "ACN_CODPRO = '"+Space(Len(ACN->ACN_CODPRO))+"' AND "
								cQuery += "ACN_GRPPRO = '"+SB1->B1_GRUPO+"' AND "
								cQuery += "ACN.D_E_L_E_T_ = ' '"
						
								cQuery := ChangeQuery( cQuery )        
			
								dbUseArea( .T., "TOPCONN", TcGenQry( , , cQuery ), cAliasQry, .F., .T. ) 
		
								For nCntFor := 1 To Len(aStruACN)
									If ( aStruACN[nCntFor,2]<>"C" )
										TcSetField(cAliasQry,aStruACN[nCntFor,1],aStruACN[nCntFor,2],aStruACN[nCntFor,3],aStruACN[nCntFor,4])
									EndIf
								Next nCntFor
								//Ŀ
								//Marca flag para verificacao da verba           
								//
								If (cAliasQRY)->(!Eof())						
									lContDesc := .F.                           										         
									If Round(aProdDesc[nLoop,5],nDcDescont) > (cAliasQry)->ACN_DESCON                            
										aProdDesc[nLoop,6] := (cAliasQry)->ACN_DESCON                  													
										aProdDesc[nLoop,7] := "02"         
										lContVerba:= .F.	
										//Ŀ
										//Guarda motivo do bloqueio, para mostrar msg ao usuario         
										//
										cItemRgBlq :=  (cAliasQry)->ACN_ITEM //item da regra que gerou bloqueio
										lBlqDesc := .T.					
									Endif
								Endif
	
								DbSelectArea(cAliasQry)
								DbCloseArea()
							Endif		
							
						Endif	

						//Ŀ
						//Se nao encontrou ,busca por Produto em Branco + Grupo em Branco 
						//											
						If lContDesc

							cAliasQry := "QRYACN"

							cQuery := "SELECT ACN_DESCON , ACN_ITEM FROM "
							cQuery += RetSqlName("ACN")+ " ACN " 
							cQuery += " WHERE "
							cQuery += "ACN_FILIAL = '"+cFilACN+ "' AND "
							cQuery += "ACN_CODREG = '"+cCodReg+"' AND "
							cQuery += "ACN_CODPRO = '"+Space(Len(ACN->ACN_CODPRO))+"' AND "
							cQuery += "ACN_GRPPRO = '"+Space(Len(ACN->ACN_GRPPRO))+"' AND "
							cQuery += "ACN.D_E_L_E_T_ = ' '"

							cQuery := ChangeQuery( cQuery )        

							dbUseArea( .T., "TOPCONN", TcGenQry( , , cQuery ), cAliasQry, .F., .T. ) 

							For nCntFor := 1 To Len(aStruACN)
								If ( aStruACN[nCntFor,2]<>"C" )
									TcSetField(cAliasQry,aStruACN[nCntFor,1],aStruACN[nCntFor,2],aStruACN[nCntFor,3],aStruACN[nCntFor,4])
								EndIf
							Next nCntFor
							//Ŀ
							//Marca flag para verificacao da verba           
							//
							If (cAliasQRY)->(!Eof())						
								lContDesc := .F.
								If Round(aProdDesc[nLoop,5],nDcDescont) > (cAliasQry)->ACN_DESCON                            
									aProdDesc[nLoop,6] := (cAliasQry)->ACN_DESCON                  													
									aProdDesc[nLoop,7] := "02"         
									lContVerba:= .F.		
									//Ŀ
									//Guarda motivo do bloqueio, para mostrar msg ao usuario         
									//
									cItemRgBlq :=  (cAliasQry)->ACN_ITEM //item da regra que gerou bloqueio
									lBlqDesc := .T.
								Endif
							Endif						
							DbSelectArea(cAliasQry)
							DbCloseArea()							
						EndIf
					Endif

					//Ŀ
					//Caso exista algum item que teve desconto, deixar a lContDesc := .F.		 
					//Porm, caso tenha outros itens, ser utilizado a varivel lDescAnt := .F. 
					//para guardar o histrio e atribuir ao lContDesc em sua ltima validao.	 
					//Ŀ
					lDescAnt := lContDesc
				
				Case aProdDesc[nLoop,3] > aProdDesc[nLoop,4] .AND. lSomaVer .AND. aProdDesc[nLoop,4]>0
					aProdDesc[nLoop,6] := 0
					aProdDesc[nLoop,7] := "02"
					lContVerba:= .F.																		

			EndCase
			
			//Ŀ
			//Guarda motivo do bloqueio, para mostrar msg ao usuario         
			//
			If (!lContVerba)
				nAbaRgBlq := 3	  //bloqueio por regra de desconto (aba desconto)	
		
				If	FtVerbaVen("SC5",	"SC6",	cCliente,	cLoja,;
					           cCodVen, aProdDesc[nLoop][1], aProdDesc[nLoop], .F., @cVerbaBlq, @cItemVbBlq) == "1"
					
						nAbaRgBlq	:=0
						cItemRgBlq	:=""
						cVerbaBlq	:=""
						cItemVbBlq	:=""
												
				EndIf
		
			EndIf
			
			lContDesc := lDescAnt

			If !lContinua .And. lLibACT .And. lTemDesc .And. lContDesc .And. !lBlqDesc 
				lVldProx := .T.
			EndIf
		Endif
	Next
		
Endif

If lFT100RNI
	aRetREG := ExecBlock('FT100RNI',.F.,.F.,{cCodReg,cTabPreco,cCondPg,cFormPg,aProdutos,aProdDesc,lContinua,lRetorno,lContVerba,lExecao})
	If ValType(aRetREG) == "A" .And. Len(aRetREG) == 5 .And. ValType(aRetREG[1]) == "A" .And. ValType(aRetREG[2]) == "L" .And.;
	    ValType(aRetREG[3]) == "L" .And. ValType(aRetREG[4]) == "L" .And. ValType(aRetREG[5]) == "L"
		aProdDesc  := aRetREG[1]
		lContinua  := aRetREG[2]
		lRetorno   := aRetREG[3]
		lContVerba := aRetREG[4]
		lExecao    := aRetREG[5]
	EndIf
EndIf
Return( .T. ) 


/*/


Ŀ
Funcao    Ft100Fld   Autor Vendas Clientes         Data 13.01.2000
Ĵ
Descrio Funcao de Tratamento dos Folders                            
Ĵ
Retorno   Nenhum                                                      
Ĵ
ParametrosExpN1: Folder de Destino                                    
          ExpN2: Folder Atual                                         
          ExpO3: Objeto do Folder                                     
          ExpA4: Array com as getdados.                               
Ĵ


/*/
Static Function Ft100Fld(nFldDst,nFldAtu,oFolder,aGetDad)


Local lRetorno:= .F.
//Ŀ
//Efetua a Validacao da GetDados                        
//
If ( aGetDad[nFldAtu]:TudoOk() )

	lRetorno := .T.
	aGetDad[nFldAtu]:oBrowse:lDisablePaint := .T.
	N := Max(aGetDad[nFldDst]:oBrowse:nAt,1)
	
	aGetDad[nFldDst]:oBrowse:nColPos := 1
	aGetDad[nFldDst]:oBrowse:lDisablePaint := .F.
	aGetDad[nFldDst]:oBrowse:Refresh(.T.)
EndIf
Return(lRetorno)

/*/


Ŀ
Funcao    Ft100Ok    Autor Vendas Clientes         Data 09.11.2001
Ĵ
Descrio Funcao de validacao da Enchoicebar                          
Ĵ
Retorno   Nenhum                                                      
Ĵ
ParametrosExpO1: Getdados 1                                           
          ExpO2: GetDados 2                                           
Ĵ


/*/
Static Function Ft100Ok(oGetd1		,oGetd2		,oGetD3	,aColsNeg	,;
						aColsCom	,aColsDes	,oFolder, nOpc)

Local lRetorno	:= .T.                                                                 
Local lFT100TOK	:= .F.

If ( Type("lFT100Auto") == "U" .Or. !lFT100Auto ) 
	lRetorno := Eval(oFolder:bSetOption,1)

	If lRetorno 
		oFolder:nOption := 1
		If !oGetd1:TudoOk()
			lRetorno := .F.
		Endif
	Endif

	If lRetorno
		lRetorno := Eval(oFolder:bSetOption,2)
		If lRetorno
			oFolder:nOption := 1
			If !oGetd2:TudoOk()
				lRetorno := .F.
			EndIf
		EndIf
	EndIf

	If lRetorno
		lRetorno := Eval(oFolder:bSetOption,3)
		If lRetorno
			oFolder:nOption := 3
			If !oGetd3:TudoOk()
				lRetorno := .F.
			EndIf
		EndIf
	Endif	

	If lRetorno
		aColsNeg := aClone(oGetD1:aCols)
		aColsCom := aClone(oGetD2:aCols)
		aColsDes := aClone(oGetD3:aCols)
	Endif	

	If lRetorno .and. ExistBlock( "FT100TOK" )
		lFT100TOK := ExecBlock( "FT100TOK",.F.,.F.,{oGetD1, oGetD2, oGetD3} )
		If ValType( lFT100TOK ) = "L"
			lRetorno := lFT100TOK
		Endif  	
	Endif 
EndIf

If ValType(nOpc) == "N"

	//Validaes apenas para inserir, alterar e copiar
	If (nOpc == 3 .OR. nOpc == 4 .OR. nOpc == 6)
		
		//Ŀ
		//Validao para casos de cliente preenchido e loja em branco             
		//
		If (M->ACS_CODCLI != Nil .AND. !EMPTY(M->ACS_CODCLI)) .AND. (M->ACS_LOJA == Nil .OR. EMPTY(M->ACS_LOJA) )
			lRetorno := .F.
			Help(" ",1,"FT100SEMLOJA")
		EndIf
	
	EndIf
	
EndIf

Return(lRetorno)	

/*/


Ŀ
Programa  MenuDef    Autor  Vendas Clientes        Data 01/09/2006
Ĵ
Descrio  Utilizacao de menu Funcional                               
                                                                      
                                                                      
Ĵ
Retorno   Array com opcoes da rotina.                                 
Ĵ
ParametrosParametros do array a Rotina:                               
          1. Nome a aparecer no cabecalho                             
          2. Nome da Rotina associada                                 
          3. Reservado                                                
          4. Tipo de Transao a ser efetuada:                        
          	  1 - Pesquisa e Posiciona em um Banco de Dados           
              2 - Simplesmente Mostra os Campos                       
              3 - Inclui registros no Bancos de Dados                 
              4 - Altera o registro corrente                          
              5 - Remove o registro corrente do Banco de Dados        
          5. Nivel de acesso                                          
          6. Habilita Menu Funcional                                  
Ĵ


/*/

Static Function MenuDef()
     
Private aRotina := {	{ STR0001,"AxPesqui"	,0,1,0,.F.},;		// "Pesquisar"
						{ STR0002,"Ft100RNeg"	,0,2,0,NIL},;		// "Visualizar"
						{ STR0003,"Ft100RNeg"	,0,3,0,NIL},;		// "Incluir"
						{ STR0004,"Ft100RNeg"	,0,4,0,NIL},;		// "Alterar"
						{ STR0005,"Ft100RNeg"	,0,5,0,NIL},;		// "Excluir"
						{ STR0006,"Ft100RNeg"	,0,6,0,NIL}}		// "Copiar"

If ExistBlock("FT100MNU")
	ExecBlock("FT100MNU",.F.,.F.)
EndIf

Return(aRotina)


/*/


Ŀ
Funcao    VldCliente  Autor Vendas Clientes         Data 09.10.2009
Ĵ
Descrio Funcao de validacao do campo ACS_CODCLI                     
Ĵ
Retorno   logico, indicando se ja no esta cadastrado cliente/loja    
Ĵ
Parametros                                                            
                                                                      
Ĵ


/*/
Function VldCliente()
Local lReturn := .F.

lReturn := ExistCpo("SA1",M->ACS_CODCLI+RTRIM(M->ACS_LOJA),,,,!EMPTY(M->ACS_LOJA)).And.ExistChav("ACS",M->ACS_CODCLI+M->ACS_LOJA,2)
  
Return(lReturn)   


/*

Ŀ
Funo    Ft100GrPrdAutor  Rodrigo T. Silva 		 Data 11/11/2009 
Ĵ
Descricao Interface de Grade de Produtos - Regras de Negocio		   
Ĵ
Uso       FATA100													   
ٱ

*/
Function Ft100Prod() 

Local lRet 		  := .T.
Local nITEMGR 	  := aScan(aHeader,{|x| AllTrim(x[2]) == "ACN_ITEMGR"})
Local nDESPRO 	  := aScan(aHeader,{|x| AllTrim(x[2]) == "ACN_DESPRO"})
Local nDESCON 	  := aScan(aHeader,{|x| AllTrim(x[2]) == "ACN_DESCON"})
Local lGrade  	  := !Empty(nITEMGR) .And. MaGrade()
Local cProduto	  := M->ACN_CODPRO
Local lReferencia := MatGrdPrrf(@cProduto)

If lGrade                              
	oGrade:MontaGrade(n,cProduto,.T.,,lReferencia)
EndIf

If lReferencia
	aCols[n,nITEMGR] := "01"
	aCols[n,nDESPRO] := oGrade:GetDescProd(M->ACN_CODPRO)
ElseIf (lRet := ExistCpo("SB1",M->ACN_CODPRO))
	aCols[n,nDESPRO] := Posicione("SB1",1,xFilial("SB1")+M->ACN_CODPRO,"B1_DESC")
	If !Empty(nITEMGR)
		aCols[n,nITEMGR] := CriaVar("ACN_ITEMGR")
	EndIf
EndIf
aCols[n,nDESCON] := 0

Return lRet

/*

Ŀ
Funo    Ft100GrDesAutor  Rodrigo T. Silva 		 Data 11/11/2009 
Ĵ
Descrio Se a Grade estiver ativa, efetua a entrada de dados na colu- 
          na de descontos.                                             
Ĵ
Uso       FATA100													   
ٱ

*/

Function Ft100GrDes()
Local lRet        := .T.
Local nCODPRO     := aScan(aHeader,{|x| AllTrim(x[2]) == "ACN_CODPRO"})
Local lGrade  	  := MaGrade()
Local cProduto	  := aCols[n,nCODPRO]
Local lReferencia := MatGrdPrrf(@cProduto)
Local cCampo 	  := Substr(ReadVar(),4)

If cCampo == "ACN_DESCON" .And. lReferencia .And. ((M->ACN_DESCON < 0) .Or. (M->ACN_DESCON > 100))
	Aviso(STR0011,STR0012,{"Ok"}) // Ateno, Valor percentual deve estar entre 0 e 100.
	lRet := .F.
ElseIf lGrade .And. MatGrdPrrf(@cProduto)
	oGrade:cProdRef := cProduto
	oGrade:lShowGrd := .T.
	oGrade:nPosLinO := n	
	oGrade:Show("ACN_DESCON")	
	&(ReadVar()) := oGrade:SomaGrade("ACN_DESCON",n)
EndIf
Return lRet

/*


ͻ
Programa  Ft100VlGr Autor  Rodrigo T. Silva	  Data   14/05/10   
͹
Descricao  Valida valores de descontos digitados na grade.            
͹
Uso        FATA100                                                    
ͼ


*/
Function Ft100VlGr()
Local lRet := .T.
oGrade:lShowMsgDiff := .F.
If oGrade:cCpo == "ACN_DESCON" .And. &(ReadVar()) > 100
	Aviso(STR0011,STR0012,{"Ok"})// Ateno, Valor percentual deve estar entre 0 e 100.
	lRet := .F.
EndIf
oGrade:lShowMsgDiff := .T.
Return lRet



/*


ͻ
Programa  VerBlqReg Autor   Vendas & CRM        Data   15/12/11   
͹
Desc.     Mostra o motivo de um bloqueio por regra ou verba.          
͹
Sintaxe   VerBlqReg                                                   
͹
ParametrosExpC1: Codigo da regra que gerou o bloqueio                 
          ExpN2: Aba da regra que gerou o bloqueio                    
          ExpC3: Item da regra que gerou o bloqueio                   
          ExpC4: Codigo da verba de venda                             
          ExpC5: Item da verba de venda                               
͹
Uso                                                                   
͹


*/
Function VerBlqReg(cCodRegra, nAbaRegra, cItemRegra, cCodVerba, cItemVerba)


Local aArea 		:= GetArea()	     
Local aColsAnt 		:={} 			
Local aHeaderAnt 	:= {}		
Local nElemAnt
Local aAreaACS							//regra de negocio (cabecalho)	
Local aAreaACK 							//verba de venda (cabecalho)			
Local cMsgMotivo 	:= "" 				//mensagem com o motivo do bloqueio
Local cTipoBlq 		:= STR0013 			//tipo do bloqueio (regra ou verba)
Local nMsgOpc  							//opcao selecionada pelo usuario na mensagem (OK, VerRegra ou Verba)
Local aBotoes		:= {'Ok', STR0013}	//Lista de botoes que serao exibidos (regra e verba, ou somente regra)
Local lAntINCLUI := INCLUI

IF ((cCodRegra <> "") .AND. (nAbaRegra <> 0)) .OR. (AllTrim(cCodRegra) == "BLQAL")
	
	//Ŀ
	//Guarda o estado atual para restaurar no final. Em alguns pontos no existe as variaveis    
	//
	
	If Type("aCols") == "A"
		aColsAnt := aClone(Acols)
	EndIf
	
	If Type("aHeader") == "A"
		aHeaderAnt := aClone(aHeader)
	EndIf
	
	If Type("n") == "N"
		nElemAnt := n
	EndIf	
	
	
		//Ŀ
		//bloqueio de regra pela aba de negociacao                                       
		//
		If (nAbaRegra == 1)
			//Ŀ
			//quando nenhum item atende a regra                                              
			//
			If (AllTrim(cItemRegra) == '')
				cMsgMotivo:= STR0014 + Chr(13) + Chr(10) + Chr(13) + Chr(10)+ ;  //O lanamento no atende  nenhuma opo de negociao. 
				STR0013 + ": "+ cCodRegra + Chr(13) + Chr(10)+ ; // "Regra:"
				STR0015 + " "+ STR0008 //Tipo de bloqueio: Negociao
						
		
			//Ŀ
			//quando alguma excecao e encontrada                                             
			//
			Else
				cMsgMotivo:= STR0016 + ; //"O lanamento encontra-se em uma exceo s regras de negociao."
				Chr(13) + Chr(10) + Chr(13) + Chr(10)+ ;
				STR0013 + ": " +  cCodRegra + Chr(13) + Chr(10)+ ;// "Regra:"
				STR0015 + " "+ STR0008 + Chr(13) + Chr(10) + ;//Tipo de bloqueio: Negociao
				STR0017 +  cItemRegra //"item:"
				
			
			EndIf
		EndIf
		
		
		
		//Ŀ
		//bloqueio de regra pela aba comercializacao                                     
		//
		If (nAbaRegra == 2)
			
			//Ŀ
			//quando o pedido possui itens do tipo regra e itens                             
			//que nao estao definidos na regra                                               
			//
			If (AllTrim(cItemRegra) == '')
				cMsgMotivo:= STR0018; //"O pedido possui itens que no foram especificados na regra de comercializao."
				 + Chr(13) + Chr(10) + Chr(13) + Chr(10)+ ;
				STR0013 + ": " +  cCodRegra + Chr(13) + Chr(10)+ ; //Regra:
				STR0015 + " " + STR0009 //Tipo de bloqueio: Comercializacao
		
			//Ŀ
			//quando algum item que nao poderia ser vendido esta no pedido (excecao)         
			//
			Else
				cMsgMotivo:= STR0019; //"O lanamento possui um item que no pode ser comercializado, de acordo com a regra de comercializao."
				+ Chr(13) + Chr(10)  + Chr(13) + Chr(10)+ ;
				STR0013 + ": " + cCodRegra + Chr(13) + Chr(10)+ ; //Regra:
				STR0015 + " " + STR0009 + Chr(13) + Chr(10)+ ;//Tipo de bloqueio: Comercializacao
				STR0017 +   cItemRegra //Item
				
			
			EndIf
		EndIf
		
		
		
		//Ŀ
		//bloqueio de regra pela aba desconto                                            
		//
		If (nAbaRegra == 3)
				cMsgMotivo:= STR0020; //"O desconto aplicado  maior que o permitido."
				 + Chr(13) + Chr(10) + Chr(13) + Chr(10)+ ;
				 	STR0013 + ": " + cCodRegra + Chr(13) + Chr(10)+ ; //Regra
					STR0015 + " " + STR0010 //"Tipo de bloqueio: Desconto"
					
					
				If !(AllTrim(cItemRegra) == '') 
					cMsgMotivo += + Chr(13) + Chr(10)+ ;
					STR0017 + cItemRegra // "Item da regra que gerou o bloqueio:"
				EndIf
				
			
			//Ŀ
			//Verifica se esta bloqueado por verba                                            
			//
			If !(AllTrim(cCodVerba) == '')
				cMsgMotivo +=  + Chr(13) + Chr(10) + Chr(13) + Chr(10)+ ;
				STR0021 + Chr(13) + Chr(10)+; //"A verba de venda no foi suficiente para o desconto."
				STR0022 + ": " + cCodVerba + Chr(13) + Chr(10) //"Verba de Venda:"
				
				If !(AllTrim(cItemVerba) == '') 
					cMsgMotivo += 	STR0017 + cItemVerba
				EndIf
				
				cTipoBlq := STR0022  //para mostrar a mensagem certa (verba ou regra)
				Aadd(aBotoes,STR0022) //mostra o botao de visualizar o cadastro de verba
			
			EndIf
	
			
			
		EndIf
		
		//Ŀ
		//Bloqueio especifico para estado de alagoas (limite de faturamento)             
		//
		If (AllTrim(cCodRegra) == "BLQAL")
				cMsgMotivo := STR0023; //"O lanamento ultrapassa o limite de faturamento para o cliente."
				+ Chr(13) + Chr(10)+ Chr(13) + Chr(10)+ STR0024//"Regra especfica para Alagoas"
				cTipoBlq := STR0025 //"limite de faturamento"
				aBotoes := {'Ok'} //tira o botao de visualizar a regra
			
		EndIf
		
			
		
		//Ŀ
		//Mostra a mensagem                                                               
		//
		If !IsBlind()
			nMsgOpc := Aviso(STR0026 + " " + cTipoBlq ,cMsgMotivo,aBotoes,3) //'Bloqueio por '
		Else   
			ConOut("VerBlqReg - " + STR0026 + " " + cTipoBlq + Space(3) + cMsgMotivo)
			nMsgOpc := 1
		EndIf		
		
		
		//Ŀ
		//Abre a visualizacao da regra para consulta                                     
		//Quando o usuario clica em "regra" ou "verba"                               
		//
		Do Case
			Case (nMsgOpc == 2) 
				//Ŀ
				//busca pela regra que bloqueou o pedido para pegar o recno e passar na          
				//chamada a visualizacao da regra                                                
				//
				aAreaACS := ACS->(GetArea()) //regra de negocio (cabecalho)						
				dbSelectArea("ACS")
				DbSetOrder(1)
				
				if (MsSeek(xFilial("ACS")+cCodRegra))
						 
					INCLUI := .F. // A chamada em visualizacao do cadastro de regras precisa disso. Se tirar isso nao carrega os itens.
					Ft100RNeg("ACS", Recno() ,2) //abre o cadastro de regras em modo de visualizacao
					INCLUI := lAntINCLUI
					
				EndIf		
				
				dbCloseArea()
				
				ACS->(RestArea(aAreaACS))
			
			
			Case (nMsgOpc == 3)
			
				//Ŀ
				//busca pela verba que bloqueou o pedido para pegar o recno e passar na          
				//chamada a visualizacao da verba                                                
				//
				aAreaACK := ACK->(GetArea()) //verba de venda (cabecalho)						
				dbSelectArea("ACK")
				DbSetOrder(1)
				
				if (MsSeek(xFilial("ACK")+cCodVerba))
						 
					INCLUI := .F. // ???A chamada em visualizacao do cadastro de verbas precisa disso. Se tirar isso nao carrega os itens.
					n :=1 // se nao estiver posicionado no primeiro registro da error log
					Fat190Mnt("ACK", Recno() ,2) //abre o cadastro de regras em modo de visualizacao
					INCLUI := lAntINCLUI
				EndIf		
				
				dbCloseArea()
				
				ACK->(RestArea(aAreaACK))
		EndCase
	
	//Ŀ
	//Restaura a area                                                                
	//
	
	RestArea(aArea)
	
	If Type("aCols") == "A"
		aCols := aClone(aColsAnt)
	EndIf
	
	If Type("aHeader") == "A"
		aHeader := aClone(aHeaderAnt)
	EndIf
	
	If Type("n") == "N"
		n := nElemAnt
	EndIf	
		
EndIf

Return Nil


//-----------------------------------------------------------------------------
/*/{Protheus.doc} FATPDLogUser
    @description
    Realiza o log dos dados acessados, de acordo com as informaes enviadas, 
    quando a regra de auditoria de rotinas com campos sensveis ou pessoais estiver habilitada
	Remover essa funo quando no houver releases menor que 12.1.27

   @type  Function
    @sample FATPDLogUser(cFunction, nOpc)
    @author Squad CRM & Faturamento
    @since 06/01/2020
    @version P12
    @param cFunction, Caracter, Rotina que ser utilizada no log das tabelas
    @param nOpc, Numerico, Opo atribuda a funo em execuo - Default=0

    @return lRet, Logico, Retorna se o log dos dados foi executado. 
    Caso o log esteja desligado ou a melhoria no esteja aplicada, tambm retorna falso.

/*/
//-----------------------------------------------------------------------------
Static Function FATPDLogUser(cFunction, nOpc)

	Local lRet := .F.

	If FATPDActive()
		lRet := FTPDLogUser(cFunction, nOpc)
	EndIf 

Return lRet  

//-----------------------------------------------------------------------------
/*/{Protheus.doc} FATPDActive
    @description
    Funo que verifica se a melhoria de Dados Protegidos existe.

    @type  Function
    @sample FATPDActive()
    @author Squad CRM & Faturamento
    @since 17/12/2019
    @version P12    
    @return lRet, Logico, Indica se o sistema trabalha com Dados Protegidos
/*/
//-----------------------------------------------------------------------------
Static Function FATPDActive()

    Static _lFTPDActive := Nil
  
    If _lFTPDActive == Nil
        _lFTPDActive := ( GetRpoRelease() >= "12.1.027" .Or. !Empty(GetApoInfo("FATCRMPD.PRW")) )  
    Endif

Return _lFTPDActive  


/*
User Function MyFATA100()

Local aAutoCab	:= {}
Local aItensACT	:= {}
Local aItensACX	:= {}
Local aItensACN	:= {}

Private lMsErroAuto := .F.

RpcSetEnv("T1","D MG 01","Admin","",,,) 

//---------------------------------------
// Cabealho - Regras de Negocio. 
//---------------------------------------
aAdd(aAutoCab,{"ACS_DESCRI"	,"REGRA AUTOMATICA"	,Nil})
aAdd(aAutoCab,{"ACS_CODCLI"	,"FAT001"			,Nil})
aAdd(aAutoCab,{"ACS_LOJA"	,"01"				,Nil})


//---------------------------------------
// Itens - Negociao.  
//--------------------------------------- 
aAdd(aItensACT,{{"ACT_ITEM"  ,"001",Nil},; 
				{"ACT_CODTAB","001",Nil},;
				{"ACT_CONDPG","000",Nil}})

//---------------------------------------
// Itens - Comercializao. 
//---------------------------------------
aAdd(aItensACX,{{"ACX_ITEM"	 ,"001"							  ,Nil},;
				{"ACX_CODPRO","FAT000000000000000000000000102",Nil}})

//---------------------------------------
// Itens - Descontos. 
//---------------------------------------
aAdd(aItensACN,{{"ACN_ITEM"	 ,"001"	,Nil},;
				{"ACN_GRPPRO","0003",Nil}})

aAdd(aItensACN,{{"ACN_ITEM"	 ,"002"	,Nil},;
				{"ACN_GRPPRO","0004",Nil}})

FATA100(aAutoCab, aItensACT, aItensACX, aItensACN ,3)
 
If lMsErroAuto	 
	lRetorno := .F.
	MostraErro()
EndIf

RpcClearEnv()

Return Nil
*/

/*/{Protheus.doc} A100FWExecStat
Funo utilizada para validar a data da LIB para utilizao da classe FWExecStatement

@type       Function
@author     CRM/Faturamento
@since      Mar/2022
@version    12.1.33
@return     __Ft100VerLib retorna lgico quando a data da lib for superior a 16/11/2021
/*/
Static Function A100FWExecStat()

Static __Ft100VerLib := Nil

If __Ft100VerLib == Nil
	__Ft100VerLib := FWLibVersion() >= "20211116"
EndIf

Return __Ft100VerLib
