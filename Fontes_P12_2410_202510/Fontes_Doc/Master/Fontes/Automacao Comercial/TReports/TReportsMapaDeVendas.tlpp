#include "msobject.ch"
#include "protheus.ch"
#INCLUDE "LOJR075.CH"
#include "tlpp-rest.th"
#include "tlpp-core.th"
#INCLUDE "FWLIBVERSION.CH"
#include "totvs.ch"
#include "totvs.framework.treports.integratedprovider.th"

namespace totvs.protheus.retail.MapaDeVenda
using namespace totvs.framework.treports.integratedprovider

// Caso queira desativar a utilização da classe mudar para active=.F.
@totvsFrameworkTReportsIntegratedProvider(active=.T., team="SIGALOJA", tables="SL1", name="Vendas", country="ALL", initialRelease="12.1.2210")
 
/*{Protheus.doc} SL1L2TReportsBusinessObject
Classe para criação do Objeto de Negocio de Vendas Varejo para o SmartView 
@author joao.marcoss
@since 06/04/2023
@version 1.0
*/
class MapaVendasTReportsBusinessObject from integratedprovider

    public method new()             as object
    public method getDisplayName()  as character
    public method getDescription()  as character
    public method getData()         as object
    public method getSchema()       as object
    public method getAreas()        as array
    public method gravaRegristro() 
    public method appendRegristro() 
    public method processaQuery()
     
    protected data aFields    as array // protected
    protected data aStruct    as array //protected
    protected data aRegistros as array 
    protected data nCount     as numeric   
    protected data cCodFil    as character
    protected data cNumVenda  as character
    protected data cDescFil   as character
    protected data lExibeVen  as logical
    protected data lExibeCli  as logical
    protected data lExibeCxa  as logical
    protected data lExibeImp  as logical
    protected data nValMinIR  as numeric
    protected data nValMinPCC as numeric

endclass
 
/*{Protheus.doc} new
Método de instância da classe 
@return object: self 
@author joao.marcos
@since 06/04/2023
@version 1.0
*/
Method new() class MapaVendasTReportsBusinessObject
_Super:new() 
self:aFields := {   "L1_FILIAL" , "L1EMISSAO"   , "L1_EMISSAO_DATA" , "L1_NUM"      ,;
                    "L1_DOC"    , "L1_DOCPED,"  , "L1_SERPED"       , "L1_SITUA"    ,;
                    "L1_SERIE"  , "A1_NOME"     , "L1_CLIENTE"      , "L1_LOJA"     ,;
                    "L1_OPERADO", "L1_VEND"     , "L1_NUMMOV"       , "L1_VLRTOT"   ,;
                    "L1_VLRLIQ" , "ACRESSIMO"   , "DESCON"          , "L1_DINHEIR"  ,;
                    "L1_CHEQUES", "L1_CARTAO"   , "L1_VLRDEBI"      , "L1_FINANC"   ,;
                    "L1_CONVENI", "L1_VALES"    , "L1_DESCONT"      , "L1_ABTOPCC"  ,;
                    "L1_RECISS" , "L1_TROCO1"   , "L4_FORMA"        , "L4_VALOR"    ,;
                    "D1_DOC"    , "D1_SERIE"    , "D1_NFORI"        , "D1_SERIORI"  ,;
                    "D1_TOTAL"  , "D1_OPERADO"  , "FRSEGDES"        , "L1_VLRJUR"   ,;
                    "E5_VALOR"  , "RECPAG"      , "A3_NOME"         , "D1_DESCONTO" ,;
                    "D1_ABTOPCC", "A6_NOME"     , "ORDEM"           , "L1_CREDITO"  ,;
                    "DESCFILIAL"}

self:aStruct    := getStruct(self:aFields)
self:aRegistros := {}
 
Return self
 
/*{Protheus.doc} getDisplayName
Retorna o nome de exibição do objeto de negocio 
@return string 
@author joao.marcos
@since 06/04/2023
@version 1.0
*/ 
Method getDisplayName() as character class MapaVendasTReportsBusinessObject
Return STR0003 // "Mapa de Vendas"
 
/*{Protheus.doc} getDescription
Retorna a descrição do objeto de negocio 
@return string 
@author joao.marcos
@since 06/04/2023
@version 1.0
*/
Method getDescription() as character class MapaVendasTReportsBusinessObject
Return STR0003 // "Mapa de Vendas"

/*{Protheus.doc} getDescription
Retorna a descrição do objeto de negocio 
@return string 
@author joao.marcos
@since 06/04/2023
@version 1.0
*/
Method getAreas() as array class MapaVendasTReportsBusinessObject
return {"Varejo"}
 
/*{Protheus.doc} getData
Retorna os dados do objeto de negocio 
@param nPage, numérico, indica a página atual do relatorio
@param oFilter, objeto, contém o filtro do TReports 
@return object: self:oData 
@author joao.marcos
@since 06/04/2023
*/
Method getData(nPage as numeric, oFilter as object) as object class MapaVendasTReportsBusinessObject
Local jParams       := oFilter:getParameters() as Json
Local oQuery1       := Nil      as object
Local oQuery2       := Nil      as object
Local cQuery        := ""       as character
Local cWhere1       := ""       as character
Local cWhere2       := ""       as character
Local cWhereFiltro  := ""       as character
Local cFieldsQry    := ""       as character
Local cAliasQuery1  := ""       as character
Local cAliasQuery2  := ""       as character
Local cJoinFilSA1   := ""       as character
Local cJoinFilSA3   := ""       as character
Local cJoinFilSA6   := ""       as character
Local cWhereSupSangr:= ""       as character
Local cQueryVenda   := ""       as character
Local nParam        := 0        as numeric
Local cTpCompartSA1 := FWModeAccess( 'SA1', 1, FWGrpCompany() ) + FWModeAccess( 'SA1', 2, FWGrpCompany() ) + FWModeAccess( 'SA1', 3, FWGrpCompany() ) as Character
Local cTpCompartSA3 := FWModeAccess( 'SA3', 1, FWGrpCompany() ) + FWModeAccess( 'SA3', 2, FWGrpCompany() ) + FWModeAccess( 'SA3', 3, FWGrpCompany() ) as Character
Local cTpCompartSA6 := FWModeAccess( 'SA6', 1, FWGrpCompany() ) + FWModeAccess( 'SA6', 2, FWGrpCompany() ) + FWModeAccess( 'SA6', 3, FWGrpCompany() ) as Character
Local cTpCompartSL1 := FWModeAccess( 'SL1', 1, FWGrpCompany() ) + FWModeAccess( 'SL1', 2, FWGrpCompany() ) + FWModeAccess( 'SL1', 3, FWGrpCompany() ) as Character
Local cTpCompartSE5 := FWModeAccess( 'SE5', 1, FWGrpCompany() ) + FWModeAccess( 'SE5', 2, FWGrpCompany() ) + FWModeAccess( 'SE5', 3, FWGrpCompany() ) as Character
Local nTamFilSA1    := Len( AllTrim(FWxFilial("SA1")) ) as Numeric
Local nTamFilSA3    := Len( AllTrim(FWxFilial("SA3")) ) as Numeric
Local nTamFilSA6    := Len( AllTrim(FWxFilial("SA6")) ) as Numeric
Local lLGPD         := Iif(ExistFunc("FwPDCanUse"), FwPDCanUse(.T.), .F.) as logical // Verifica se a funcionalidade de Dados Protegidos está sendo utilizada no sistema.
Local aFiliais      := MultiSel(jParams['PAR_FILIAL'], "L1_FILIAL") as array
Local cDataIni      := SubStr(StrTran(jParams['PAR_DTINI'][1],"-",""), 1, 8) as Character
Local cDataFim      := SubStr(StrTran(jParams['PAR_DTFIM'][1],"-",""), 1, 8) as Character
Local aCaixas       := MultiSel(jParams['PAR_CAIXA'], "L1_OPERADO") as array
Local cNDocIni      := jParams['PAR_MOVINI'][1] as Character
Local cNDocFim      := jParams['PAR_MOVFIM'][1] as Character
Local lExibeVenda   := jParams['PAR_TPOPER'][1] == 1 .Or. jParams['PAR_TPOPER'][1] == 2 as logical // "1-Todos" ou "2-Vendas"
Local lExibeDevEst  := jParams['PAR_TPOPER'][1] == 1 .Or. jParams['PAR_TPOPER'][1] == 3 as logical // "1-Todos" ou "3-Devoluções/Estornos"
Local lExibeTrSan   := jParams['PAR_SUPSAN'][1] == 1 as logical // "1-Sim"
Local lFilFilial    := ValType(aFiliais) == "A" .And. !Empty(aFiliais[1]) as logical
Local lFilCaixa     := ValType(aCaixas) == "A" .And. !Empty(aCaixas[1]) as logical

LjGrvLog("Mapa de Venda", "Objeto de Negócio Mapa de vendas - getData - Inicio.", )

Self:nCount     := 0
Self:cCodFil    := ""
Self:cNumVenda  := ""
Self:cDescFil   := ""
Self:lExibeVen  := Iif(lLGPD .And. Len(FwProtectedDataUtil():UsrNoAccessFieldsInList({"A3_NOME"})) > 0, .F., .T.) // Indica se deve exibir o nome do vendedor conforme regras de dados protegidos
Self:lExibeCli  := Iif(lLGPD .And. Len(FwProtectedDataUtil():UsrNoAccessFieldsInList({"A1_NOME"})) > 0, .F., .T.) // Indica se deve exibir o nome do cliente conforme regras de dados protegidos
Self:lExibeCxa  := Iif(lLGPD .And. !FwProtectedDataUtil():UsrPersonAccessPD(), .F., .T.) // Indica se deve exibir o nome do caixa conforme regras de dados protegidos
Self:lExibeImp  := jParams['PAR_IMPOSTO'][1] == 1 // Indica se serão exibidos os dados de impostos
Self:nValMinIR  := SuperGetMV("MV_VLRETIR",,0) // Valor mínimo para retenção de IRRF
Self:nValMinPCC := SuperGetMV("MV_VL13137",,0) // Valor mínimo para retenção do Pis/Cofins/CSLL

/*
Filiais                        - PAR_FILIAL
Data De                        - PAR_DTINI
Data até                       - PAR_DTFIM
Caixas                         - PAR_CAIXA
Nr. Mov. de                    - PAR_MOVINI
Nr. Mov. ate                   - PAR_MOVFIM
Tipo de operação               - PAR_TPOPER
Considera Impostos?            - PAR_IMPOSTO
Considera Suprimento e Sangria - PAR_SUPSAN
*/

If Empty(cNDocFim)
    cNDocFim := Replicate("Z", TamSx3("L1_NUMMOV")[1])
EndIF

// Definicao Filial SA1
If cTpCompartSA1 == cTpCompartSL1
	cJoinFilSA1 := "SL1.L1_FILIAL"
ElseIf cTpCompartSA1 == "CCC"
	cJoinFilSA1 := "'" + xFilial("SA1") + "'"
ElseIf cTpCompartSL1 <> "CCC"
	cJoinFilSA1 := "SUBSTRING(SL1.L1_FILIAL,1," + AllTrim(Str(nTamFilSA1)) + ")"
EndIf

// Definicao Filial SA3
If cTpCompartSA3 == cTpCompartSL1
	cJoinFilSA3 := "SL1.L1_FILIAL"
ElseIf cTpCompartSA3 == "CCC"
	cJoinFilSA3 := "'" + xFilial("SA3") + "'"
ElseIf cTpCompartSL1 <> "CCC"
	cJoinFilSA3 := "SUBSTRING(SL1.L1_FILIAL,1," + AllTrim(Str(nTamFilSA3)) + ")"
EndIf

// Definicao Filial SA6
If cTpCompartSA6 == cTpCompartSL1
	cJoinFilSA6 := "SL1.L1_FILIAL"
ElseIf cTpCompartSA6 == "CCC"
	cJoinFilSA6 := "'" + xFilial("SA6") + "'"
ElseIf cTpCompartSL1 <> "CCC"
	cJoinFilSA6 := "SUBSTRING(SL1.L1_FILIAL,1," + AllTrim(Str(nTamFilSA6)) + ")"
EndIf

// Filtro - Parâmetros
cWhereFiltro +=   " WHERE SL1.L1_SITUA IN ('OK','FR') " // verificar pelo DOC ou DOCPED

If lFilFilial
	cWhereFiltro += " AND SL1.L1_FILIAL IN (?) " // #A
EndIf
cWhereFiltro +=     " AND SL1.L1_EMISSAO BETWEEN ? AND ? " // #B #C
If lFilCaixa
	cWhereFiltro += " AND SL1.L1_OPERADO IN (?) " // #D
EndIf
cWhereFiltro +=     " AND SL1.L1_NUMMOV BETWEEN ? AND ? " // #E #F

If lExibeVenda // Considera Vendas

    cWhere1 += " AND SL1.L1_ORCRES = ' ' "
    cWhere1 += " AND SL1.D_E_L_E_T_ = ' ' "
    cWhere1 += " AND SA1.D_E_L_E_T_ = ' ' "
    cWhere1 += " AND SA3.D_E_L_E_T_ = ' ' "
    //Os filtros serão setados na interface do novo TReports
    If oFilter:hasFilter()
        cWhere1 += " AND " + oFilter:getSQLExpression()
    Endif

    // Campos do Select de venda
    cFieldsQry += " SL1.L1_FILIAL, SL1.L1_NUM,"
    cFieldsQry += " SL1.L1_EMISSAO AS L1EMISSAO, SL1.L1_EMISSAO AS L1_EMISSAO_DATA, SL1.L1_EMISNF,"
    cFieldsQry += " SL1.L1_DOC, SL1.L1_SERIE, SL1.L1_DOCPED, SL1.L1_SERPED,"
    cFieldsQry += " SL1.L1_CLIENTE, SL1.L1_LOJA,"
    cFieldsQry += " SL1.L1_OPERADO,"
    cFieldsQry += " SL1.L1_VEND, SA3.A3_NOME,"
    cFieldsQry += " SL1.L1_DESCONT, SL1.L1_ABTOPCC, SL1.L1_VALIRRF, 0.00 D1_ABTOPCC, SL1.L1_RECISS,"
    cFieldsQry += " COALESCE(SUBSL2.DESCON, 0) DESCON,"
    cFieldsQry += " (SL1.L1_VALBRUT + COALESCE(SUBSL2.DESCON, 0) - SL1.L1_VALMERC) ACRESSIMO,"
    cFieldsQry += " 0.00 D1_DESCONTO, SL1.L1_TROCO1,"
    cFieldsQry += " SL1.L1_DINHEIR, SL1.L1_CHEQUES, SL1.L1_CARTAO,"
    cFieldsQry += " SL1.L1_VLRDEBI, SL1.L1_FINANC, SL1.L1_CONVENI, SL1.L1_VALES, 0 L1_CREDITO,"
    cFieldsQry += " SL1.L1_VLRTOT, SL1.L1_VLRLIQ,"
    cFieldsQry += " SL1.L1_NUMMOV,"
    cFieldsQry += " SL1.L1_SITUA,"
    cFieldsQry += " SA1.A1_NOME,"
    cFieldsQry += " SUBSL4.L4_FORMA L4_FORMA, SUBSL4.L4_VALOR L4_VALOR, 0 R_E_C_N_O_,"
    cFieldsQry += " '' D1_DOC, '' D1_SERIE, '' D1_NFORI, '' D1_SERIORI, 0.00 D1_TOTAL, '' D1_OPERADO,"
    cFieldsQry += " (SL1.L1_FRETE + SL1.L1_SEGURO + SL1.L1_DESPESA) AS FRSEGDES,"
    cFieldsQry += " SL1.L1_VLRJUR,"
    cFieldsQry += " 0.00 E5_VALOR,"
    cFieldsQry += " '' RECPAG,"
    cFieldsQry += " SA6.A6_NOME,"
    cFieldsQry += " 'A' ORDEM" // A - Venda / B - Devolução / C - Estorno / Z - Suprimento e Sangria

    // Vendas
    cQuery := " SELECT DISTINCT ? " // #1
    cQuery +=   " FROM " + RetSQLName("SL1") + " SL1"

    cQuery +=  " INNER JOIN ("
    cQuery +=                " SELECT L2_FILIAL, L2_NUM, SUM(L2_VALDESC + L2_DESCPRO) AS DESCON"
    cQuery +=                  " FROM " + RetSQLName("SL2")
    cQuery +=                 " WHERE D_E_L_E_T_ = ' '"
    cQuery +=                 " GROUP BY L2_FILIAL, L2_NUM"
    cQuery +=             " ) SUBSL2"
    cQuery +=     " ON SUBSL2.L2_FILIAL = SL1.L1_FILIAL"
    cQuery +=    " AND SUBSL2.L2_NUM = SL1.L1_NUM"
    cQuery +=  " INNER JOIN ("
    cQuery +=                " SELECT L4_FILIAL, L4_NUM, L4_FORMA, SUM(L4_VALOR) L4_VALOR"
    cQuery +=                  " FROM " + RetSQLName("SL4")
    cQuery +=                 " WHERE D_E_L_E_T_ = ' '"
    cQuery +=                 " GROUP BY L4_FILIAL, L4_NUM, L4_FORMA"
    cQuery +=             " ) SUBSL4"
    cQuery +=     " ON SUBSL4.L4_FILIAL = SL1.L1_FILIAL"
    cQuery +=    " AND SUBSL4.L4_NUM = SL1.L1_NUM"
    cQuery +=  " INNER JOIN " + RetSQLName("SA1") + " SA1 "
    cQuery +=     " ON SA1.A1_FILIAL = ?" // #2
    cQuery +=    " AND SA1.A1_COD = SL1.L1_CLIENTE"
    cQuery +=    " AND SA1.A1_LOJA = SL1.L1_LOJA"
    cQuery +=  " INNER JOIN " + RetSQLName("SA3") + " SA3 "
    cQuery +=     " ON SA3.A3_FILIAL = ?" // #3
    cQuery +=    " AND SA3.A3_COD = SL1.L1_VEND "
    cQuery +=  " INNER JOIN " + RetSQLName("SA6") + " SA6 "
    cQuery +=     " ON SA6.A6_FILIAL = ?" // #4
    cQuery +=    " AND SA6.A6_COD = SL1.L1_OPERADO "

    cQuery += cWhereFiltro + cWhere1

    oQuery1 := FwExecStatement():New(cQuery)
    nParam  := 1
    oQuery1:SetUnsafe(nParam++, cFieldsQry)         // #1
    oQuery1:SetUnsafe(nParam++, cJoinFilSA1)        // #2
    oQuery1:SetUnsafe(nParam++, cJoinFilSA3)        // #3
    oQuery1:SetUnsafe(nParam++, cJoinFilSA6)        // #4
    If lFilFilial
		oQuery1:SetIn(nParam++, aFiliais )          // #A
	EndIf
    oQuery1:SetString(nParam++, cDataIni )          // #B
    oQuery1:SetString(nParam++, cDataFim )          // #C
	If lFilCaixa
		oQuery1:SetIn(nParam++, aCaixas )           // #D
	EndIf
    oQuery1:SetString(nParam++, cNDocIni )          // #E
    oQuery1:SetString(nParam++, cNDocFim )          // #F

    cQuery := oQuery1:getFixQuery()
    cQuery := ChangeQuery(cQuery)

    cQueryVenda := cQuery + " UNION "
    oQuery1:Destroy()
    oQuery1 := Nil

    // ----------------------------
    // Vendas com crédito (NCC/RA)
    // ----------------------------

    cWhere1 := " AND SL1.L1_ORCRES = ' ' "
    cWhere1 += " AND SL1.L1_CREDITO > 0 "
    cWhere1 += " AND SL1.D_E_L_E_T_ = ' ' "
    cWhere1 += " AND SL2.D_E_L_E_T_ = ' ' "
    cWhere1 += " AND SA1.D_E_L_E_T_ = ' ' "
    cWhere1 += " AND SA3.D_E_L_E_T_ = ' ' "
    //Os filtros serão setados na interface do novo TReports
    If oFilter:hasFilter()
        cWhere1 += " AND " + oFilter:getSQLExpression()
    Endif

    // Campos do Select de venda com crédito (NCC e RA)
    cFieldsQry := " SL1.L1_FILIAL, SL1.L1_NUM,"
    cFieldsQry += " SL1.L1_EMISSAO AS L1EMISSAO, SL1.L1_EMISSAO AS L1_EMISSAO_DATA, SL1.L1_EMISNF,"
    cFieldsQry += " SL1.L1_DOC, SL1.L1_SERIE, SL1.L1_DOCPED, SL1.L1_SERPED,"
    cFieldsQry += " SL1.L1_CLIENTE, SL1.L1_LOJA,"
    cFieldsQry += " SL1.L1_OPERADO,"
    cFieldsQry += " SL1.L1_VEND, SA3.A3_NOME,"
    cFieldsQry += " SL1.L1_DESCONT, SL1.L1_ABTOPCC, SL1.L1_VALIRRF, 0.00 D1_ABTOPCC, SL1.L1_RECISS,"
    cFieldsQry += " (SUM(SL2.L2_VALDESC) + SUM(SL2.L2_DESCPRO)) DESCON,"
    cFieldsQry += " (SL1.L1_VALBRUT + (SUM(SL2.L2_VALDESC) + SUM(SL2.L2_DESCPRO)) - SL1.L1_VALMERC) ACRESSIMO,"
    cFieldsQry += " 0.00 D1_DESCONTO, SL1.L1_TROCO1,"
    cFieldsQry += " SL1.L1_DINHEIR, SL1.L1_CHEQUES, SL1.L1_CARTAO,"
    cFieldsQry += " SL1.L1_VLRDEBI, SL1.L1_FINANC, SL1.L1_CONVENI, SL1.L1_VALES, SL1.L1_CREDITO,"
    cFieldsQry += " SL1.L1_VLRTOT, SL1.L1_VLRLIQ,"
    cFieldsQry += " SL1.L1_NUMMOV,"
    cFieldsQry += " SL1.L1_SITUA,"
    cFieldsQry += " SA1.A1_NOME,"
    cFieldsQry += " 'NCC/RA' L4_FORMA, SL1.L1_CREDITO L4_VALOR, 0 R_E_C_N_O_,"
    cFieldsQry += " '' D1_DOC, '' D1_SERIE, '' D1_NFORI, '' D1_SERIORI, 0.00 D1_TOTAL, '' D1_OPERADO,"
    cFieldsQry += " (SL1.L1_FRETE + SL1.L1_SEGURO + SL1.L1_DESPESA) AS FRSEGDES,"
    cFieldsQry += " SL1.L1_VLRJUR,"
    cFieldsQry += " 0.00 E5_VALOR,"
    cFieldsQry += " '' RECPAG,"
    cFieldsQry += " SA6.A6_NOME,"
    cFieldsQry += " 'A' ORDEM" // A - Venda / B - Devolução / C - Estorno / Z - Suprimento e Sangria

    // Vendas com crédito (NCC e RA)
    cQuery := " SELECT DISTINCT ?" // #1
    cQuery +=   " FROM " + RetSQLName("SL1") + " SL1"
    cQuery +=  " INNER JOIN " + RetSQLName("SL2") + " SL2"
    cQuery +=     " ON SL2.L2_FILIAL = SL1.L1_FILIAL"
    cQuery +=    " AND SL2.L2_NUM = SL1.L1_NUM"
    cQuery +=  " INNER JOIN " + RetSQLName("SA1") + " SA1"
	cQuery +=     " ON SA1.A1_FILIAL = ?" // #2
    cQuery +=    " AND SA1.A1_COD = SL1.L1_CLIENTE"
    cQuery +=    " AND SA1.A1_LOJA = SL1.L1_LOJA"
    cQuery +=  " INNER JOIN " + RetSQLName("SA3") + " SA3"
    cQuery +=     " ON SA3.A3_FILIAL = ?" // #3
    cQuery +=    " AND SA3.A3_COD = SL1.L1_VEND"
    cQuery +=  " INNER JOIN " + RetSQLName("SA6") + " SA6"
    cQuery +=     " ON SA6.A6_FILIAL = ?" // #4
    cQuery +=    " AND SA6.A6_COD = SL1.L1_OPERADO"

    cQuery += cWhereFiltro + cWhere1

    cQuery +=  " GROUP BY SL1.L1_FILIAL,"
    cQuery +=           " SL1.L1_NUM, SL1.L1_EMISSAO, SL1.L1_EMISNF,"
    cQuery +=           " SL1.L1_DOC, SL1.L1_SERIE, SL1.L1_DOCPED, SL1.L1_SERPED,"
    cQuery +=           " SL1.L1_CLIENTE, SL1.L1_LOJA,"
    cQuery +=           " SL1.L1_OPERADO,"
    cQuery +=           " SL1.L1_VEND, SA3.A3_NOME,"
    cQuery +=           " SL1.L1_DESCONT, SL1.L1_ABTOPCC, SL1.L1_VALIRRF, SL1.L1_RECISS,"
    cQuery +=           " SL1.L1_TROCO1,"
    cQuery +=           " SL1.L1_DINHEIR, SL1.L1_CHEQUES, SL1.L1_CARTAO, SL1.L1_VLRDEBI,"
    cQuery +=           " SL1.L1_FINANC, SL1.L1_CONVENI, SL1.L1_VALES, SL1.L1_CREDITO,"
    cQuery +=           " SL1.L1_VLRTOT, SL1.L1_VLRLIQ, SL1.L1_NUMMOV, SL1.L1_SITUA,"
    cQuery +=           " SL1.L1_VALBRUT, SL1.L1_VALMERC,"
    cQuery +=           " SA1.A1_NOME,"
    cQuery +=           " SL1.L1_FRETE, SL1.L1_SEGURO, SL1.L1_DESPESA, SL1.L1_VLRJUR, SA6.A6_NOME"
    cQuery +=  " ORDER BY L1_FILIAL, L1EMISSAO, L1_OPERADO, L1_DOC, L1_SERIE"

    oQuery1 := FwExecStatement():New(cQuery)
    nParam  := 1
    oQuery1:SetUnsafe(nParam++, cFieldsQry)         // #1
	oQuery1:SetUnsafe(nParam++, cJoinFilSA1)        // #2
    oQuery1:SetUnsafe(nParam++, cJoinFilSA3)        // #3
    oQuery1:SetUnsafe(nParam++, cJoinFilSA6)        // #4
	If lFilFilial
		oQuery1:SetIn(nParam++, aFiliais )          // #A
	EndIf
    oQuery1:SetString(nParam++, cDataIni )          // #B
    oQuery1:SetString(nParam++, cDataFim )          // #C
	If lFilCaixa
		oQuery1:SetIn(nParam++, aCaixas )           // #D
	EndIf
    oQuery1:SetString(nParam++, cNDocIni )          // #E
    oQuery1:SetString(nParam++, cNDocFim )          // #F

    cQuery := oQuery1:getFixQuery()
    cQuery := cQueryVenda + ChangeQuery(cQuery)
    oQuery1:SetQuery(cQuery)

    cAliasQuery1 := oQuery1:OpenAlias()

    LjGrvLog("Mapa de Venda", "Objeto de Negócio Mapa de vendas - Query Vendas.",cQuery )

    Self:processaQuery(cAliasQuery1, 1, nPage)

EndIf

If lExibeDevEst // Considera devoluções / estornos

    cWhere2 += " AND SL1.D_E_L_E_T_ = ' ' "
    cWhere2 += " AND SD1.D_E_L_E_T_ = ' ' "
    cWhere2 += " AND SA1.D_E_L_E_T_ = ' ' "
    cWhere2 += " AND SA3.D_E_L_E_T_ = ' ' "
    cWhere2 += " AND SL1.L1_DOC <> ' ' "
    cWhere2 += " AND SL1.L1_SERIE <> ' ' "
    cWhere2 += " AND SD1.D1_TIPO = 'D' "
    //Os filtros serão setados na interface do novo TReports
    If oFilter:hasFilter()
        cWhere2 += " AND " + oFilter:getSQLExpression()
    Endif

    // Campos do Select de devoluçao/estorno
    cFieldsQry := "SL1.L1_FILIAL,"
    cFieldsQry += " '' L1_NUM,"
    cFieldsQry += " SL1.L1_EMISSAO AS L1EMISSAO,"
    cFieldsQry += " SL1.L1_EMISSAO AS L1_EMISSAO_DATA,"
    cFieldsQry += " '' L1_EMISNF,"
    cFieldsQry += " SD1.D1_DOC AS L1_DOC,"
    cFieldsQry += " SD1.D1_SERIE AS L1_SERIE,"
    cFieldsQry += " ''  L1_DOCPED, '' L1_SERPED,"
    cFieldsQry += " SL1.L1_CLIENTE,"
    cFieldsQry += " SL1.L1_LOJA,"
    cFieldsQry += " SL1.L1_OPERADO, '' L1_VEND, SA3.A3_NOME,"
    cFieldsQry += " 0.00 L1_DESCONT,  0.00 L1_ABTOPCC, 0 L1_VALIRRF, SL1.L1_ABTOPCC D1_ABTOPCC,"
    cFieldsQry += " '' L1_RECISS,"
    cFieldsQry += " 0.00 DESCON, 0.00 ACRESSIMO,"
    cFieldsQry += " SUM(SD1.D1_VALDESC) D1_DESCONTO,"
    cFieldsQry += " 0.00 L1_TROCO1,"
    cFieldsQry += " 0.00 L1_DINHEIR, 0.00 L1_CHEQUES,"
    cFieldsQry += " 0.00 L1_CARTAO, 0.00 L1_VLRDEBI,"
    cFieldsQry += " 0.00 L1_FINANC, 0.00 L1_CONVENI,"
    cFieldsQry += " 0.00 L1_VALES, 0.00 L1_CREDITO, 0.00 L1_VLRTOT, 0.00 L1_VLRLIQ,"
    cFieldsQry += " '' L1_NUMMOV, '' L1_SITUA,"
    cFieldsQry += " SA1.A1_NOME,"
    cFieldsQry += " '' L4_FORMA,"
    cFieldsQry += " 0.00 L4_VALOR, 0 R_E_C_N_O_,"
    cFieldsQry += " SD1.D1_DOC, SD1.D1_SERIE, SD1.D1_NFORI,"
    cFieldsQry += " SD1.D1_SERIORI,"
    cFieldsQry += " (SUM(SD1.D1_TOTAL) - (SUM(SD1.D1_VALDESC) + SUM(SL1.L1_ABTOPCC)) ) D1_TOTAL,"
    cFieldsQry += " SD1.D1_OPERADO,"
    cFieldsQry += " 0.00 AS FRSEGDES,"
    cFieldsQry += " 0.00 AS L1_VLRJUR,"
    cFieldsQry += " 0.00 E5_VALOR,"
    cFieldsQry += " '' RECPAG,"
    cFieldsQry += " SA6.A6_NOME,"
    cFieldsQry += " 'B' ORDEM" // A - Venda / B - Devolução / C - Estorno (Na query vem como B sempre, e no appendRegristro muda pra C quando necessário) / Z - Suprimento e Sangria

    cQuery := " SELECT DISTINCT ?" // #1
    cQuery +=   " FROM " + RetSQLName("SL1") + " SL1"
    cQuery +=  " INNER JOIN " + RetSQLName("SD1") + " SD1"
    cQuery +=     " ON SD1.D1_FILIAL = SL1.L1_FILIAL"
    cQuery +=    " AND SD1.D1_NFORI = SL1.L1_DOC"
    cQuery +=    " AND SD1.D1_SERIORI = SL1.L1_SERIE"
    cQuery +=    " AND SD1.D1_FORNECE = SL1.L1_CLIENTE"
    cQuery +=    " AND SD1.D1_LOJA = SL1.L1_LOJA"
    cQuery +=  " INNER JOIN " + RetSQLName("SA1") + " SA1"
	cQuery +=     " ON SA1.A1_FILIAL = ?" // #2
    cQuery +=    " AND SA1.A1_COD = SD1.D1_FORNECE"
    cQuery +=    " AND SA1.A1_LOJA = SD1.D1_LOJA"
    cQuery +=  " INNER JOIN " + RetSQLName("SA3") + " SA3"
    cQuery +=     " ON SA3.A3_FILIAL = ?" // #3
    cQuery +=    " AND SA3.A3_COD = SL1.L1_VEND"
    cQuery +=  " INNER JOIN " + RetSQLName("SA6") + " SA6"
	cQuery +=     " ON SA6.A6_FILIAL = ?" // #4
    cQuery +=    " AND SA6.A6_COD = SL1.L1_OPERADO"

    cQuery += cWhereFiltro + cWhere2

    cQuery +=  " GROUP BY SL1.L1_FILIAL,"
    cQuery +=           " SL1.L1_EMISSAO, SL1.L1_EMISNF,"
    cQuery +=           " SL1.L1_DOC, SL1.L1_SERIE,"
    cQuery +=           " SL1.L1_CLIENTE, SL1.L1_LOJA,"
    cQuery +=           " SL1.L1_OPERADO,"
    cQuery +=           " SL1.L1_VEND,  SA3.A3_NOME,"
    cQuery +=           " SA1.A1_NOME,"
    cQuery +=           " SL1.L1_DESCONT, SL1.L1_ABTOPCC,SL1.L1_RECISS,"
    cQuery +=           " SL1.L1_TROCO1,"
    cQuery +=           " SL1.L1_DINHEIR, SL1.L1_CHEQUES, SL1.L1_CARTAO,"
    cQuery +=           " SL1.L1_VLRDEBI, SL1.L1_FINANC, SL1.L1_CONVENI, SL1.L1_VALES, SL1.L1_CREDITO,"
    cQuery +=           " SL1.L1_VLRTOT, SL1.L1_VLRLIQ, SL1.L1_NUMMOV,"
    cQuery +=           " SL1.L1_VALBRUT, SL1.L1_VALMERC,"
    cQuery +=           " SD1.D1_DOC, SD1.D1_SERIE, SD1.D1_NFORI,"
    cQuery +=           " SD1.D1_SERIORI, SD1.D1_OPERADO,"
    cQuery +=           " SL1.L1_FRETE, SL1.L1_SEGURO, SL1.L1_DESPESA, SL1.L1_VLRJUR, SA6.A6_NOME"
    cQuery +=  " ORDER BY L1_FILIAL, L1EMISSAO, L1_OPERADO, D1_DOC, D1_SERIE"

    oQuery2 := FwExecStatement():New(cQuery)
    nParam  := 1
    oQuery2:SetUnsafe(nParam++, cFieldsQry)         // #1
	oQuery2:SetUnsafe(nParam++, cJoinFilSA1)        // #2
    oQuery2:SetUnsafe(nParam++, cJoinFilSA3)        // #3
    oQuery2:SetUnsafe(nParam++, cJoinFilSA6)        // #4
	If lFilFilial
		oQuery2:SetIn(nParam++, aFiliais )          // #A
	EndIf
    oQuery2:SetString(nParam++, cDataIni )          // #B
    oQuery2:SetString(nParam++, cDataFim )          // #C
	If lFilCaixa
		oQuery2:SetIn(nParam++, aCaixas )           // #D
	EndIf
    oQuery2:SetString(nParam++, cNDocIni )          // #E
    oQuery2:SetString(nParam++, cNDocFim )          // #F

    cQuery := oQuery2:getFixQuery()
    cQuery := ChangeQuery(cQuery)
    oQuery2:SetQuery(cQuery)

    cAliasQuery2 := oQuery2:OpenAlias()

    LjGrvLog("Mapa de Venda", "Objeto de Negócio Mapa de vendas - Query Devoluçao.",cQuery )

    Self:processaQuery(cAliasQuery2, 1, nPage)
EndIf

If lExibeTrSan // Considera Suprimento (troco) e Sangria

    // Definicao Filial SA6 - Suprimento e Sangria
    If cTpCompartSA6 == cTpCompartSE5
        cJoinFilSA6 := "E5.E5_FILIAL"
    ElseIf cTpCompartSA6 == "CCC"
        cJoinFilSA6 := "'" + xFilial("SA6") + "'"
    ElseIf cTpCompartSE5 <> "CCC"
        cJoinFilSA6 := "SUBSTRING(E5.E5_FILIAL,1," + AllTrim(Str(nTamFilSA6)) + ")"
    EndIf

    // Suprimento e Sangria
    cWhereSupSangr +=   " WHERE E5.E5_TIPODOC = 'TR'"
    If lFilFilial
        cWhereSupSangr += " AND E5.E5_FILORIG IN (?)" // #A
    EndIf
    cWhereSupSangr +=     " AND E5.E5_DATA BETWEEN ? AND ?" // #B #C
    If lFilCaixa
        cWhereSupSangr += " AND E5.E5_BANCO IN (?)" // #D
    EndIf
    cWhereSupSangr +=     " AND E5.E5_NUMMOV BETWEEN ? AND ?" // #E #F
    cWhereSupSangr +=     " AND (E5.E5_SITUACA <> 'C' OR E5.E5_MOEDA <> 'ES')"
    cWhereSupSangr +=     " AND E5.E5_AGENCIA = '.' AND E5.E5_CONTA = '.'"
    cWhereSupSangr +=     " AND E5.D_E_L_E_T_ = ' ' "

    // Campos do Select de Suprimento e Sangria

    cFieldsQry := " E5_FILORIG L1_FILIAL,"
    cFieldsQry += " '' L1_NUM,"
    cFieldsQry += " E5_DATA L1EMISSAO,"
    cFieldsQry += " E5_DATA L1_EMISSAO_DATA,"
    cFieldsQry += " '' L1_EMISNF,"
    cFieldsQry += " '' L1_DOC,"
    cFieldsQry += " '' L1_SERIE,"
    cFieldsQry += " '' L1_DOCPED,"
    cFieldsQry += " '' L1_SERPED,"
    cFieldsQry += " '' L1_CLIENTE,"
    cFieldsQry += " '' L1_LOJA,"
    cFieldsQry += " E5_BANCO L1_OPERADO,"
    cFieldsQry += " '' L1_VEND, '' A3_NOME,"
    cFieldsQry += " 0.00 L1_DESCONT, 0.00 L1_ABTOPCC, 0 L1_VALIRRF, 0.00 D1_ABTOPCC,"
    cFieldsQry += " '' L1_RECISS,"
    cFieldsQry += " 0.00 DESCON, 0.00 ACRESSIMO, 0.00 D1_DESCONTO,"
    cFieldsQry += " 0.00 L1_TROCO1,"
    cFieldsQry += " 0.00 L1_DINHEIR, 0.00 L1_CHEQUES,"
    cFieldsQry += " 0.00 L1_CARTAO, 0.00 L1_VLRDEBI,"
    cFieldsQry += " 0.00 L1_FINANC, 0.00 L1_CONVENI,"
    cFieldsQry += " 0.00 L1_VALES, 0.00 L1_CREDITO, 0.00 L1_VLRTOT, 0.00 L1_VLRLIQ,"
    cFieldsQry += " '' L1_NUMMOV, '' L1_SITUA,"
    cFieldsQry += " '' A1_NOME,"
    cFieldsQry += " E5_TIPODOC L4_FORMA,"
    cFieldsQry += " 0.00 L4_VALOR, 0 R_E_C_N_O_,"
    cFieldsQry += " '' D1_DOC, ''  D1_SERIE, '' D1_NFORI,"
    cFieldsQry += " '' D1_SERIORI, 0.00 D1_TOTAL, '' D1_OPERADO,"
    cFieldsQry += " 0.00 AS FRSEGDES,"
    cFieldsQry += " 0.00 AS L1_VLRJUR,"
    cFieldsQry += " E5.E5_VALOR E5_VALOR,"
    cFieldsQry += " E5.E5_RECPAG RECPAG,"
    cFieldsQry += " SA6.A6_NOME,"
    cFieldsQry += " 'Z' ORDEM" // A - Venda / B - Devolução / C - Estorno / Z - Suprimento e Sangria

    cQuery := " SELECT DISTINCT ? " // #1
    cQuery +=   " FROM " + RetSQLName("SE5") + " E5 "
    cQuery +=  " INNER JOIN " + RetSQLName("SA6") + " SA6 "
    cQuery +=     " ON SA6.A6_FILIAL = ?" // #2
    cQuery +=    " AND SA6.A6_COD = E5.E5_BANCO "

    cQuery += cWhereSupSangr

    cQuery +=  " GROUP BY E5.E5_FILORIG,"
    cQuery +=           " E5.E5_DATA,"
    cQuery +=           " E5.E5_BANCO,"
    cQuery +=           " E5.E5_TIPODOC,"
    cQuery +=           " E5.E5_VALOR,"
    cQuery +=           " E5.E5_RECPAG,"
    cQuery +=           " SA6.A6_NOME "
    cQuery +=  " ORDER BY E5_FILORIG, E5_DATA, E5_BANCO "

    oQuery2 := FwExecStatement():New(cQuery)
    nParam  := 1
    oQuery2:SetUnsafe(nParam++, cFieldsQry)         // #1
    oQuery2:SetUnsafe(nParam++, cJoinFilSA6)        // #2
    If lFilFilial
        oQuery2:SetIn(nParam++, aFiliais )          // #A
    EndIf
    oQuery2:SetString(nParam++, cDataIni )          // #B
    oQuery2:SetString(nParam++, cDataFim )          // #C
    If lFilCaixa
        oQuery2:SetIn(nParam++, aCaixas )           // #D
    EndIf
    oQuery2:SetString(nParam++, cNDocIni )          // #E
    oQuery2:SetString(nParam++, cNDocFim )          // #F

    cQuery := oQuery2:getFixQuery()
    cQuery := ChangeQuery(cQuery)
    oQuery2:SetQuery(cQuery)

    cAliasQuery2 := oQuery2:OpenAlias()

    LjGrvLog("Mapa de Venda", "Objeto de Negócio Mapa de vendas - Query Suprimento e Sangria.", cQuery)

    Self:processaQuery(cAliasQuery2, 1, nPage)
EndIf

//Limpeza dos objetos
If oQuery1 <> Nil
    oQuery1:Destroy()
    oQuery1:= nil
    FreeObj(oQuery1)
EndIf
If oQuery2 <> Nil
    oQuery2:Destroy()
    oQuery2:= nil
    FreeObj(oQuery2)
EndIf

LjGrvLog("Mapa de Venda", "Objeto de Negócio Mapa de vendas - getData - Fim.", )

Return self:oData
 
/*{Protheus.doc} getSchema
Retorna a estrutura dos campos 
@return object: self:oSchema 
@author joao.marcos
@since 06/04/2023
@version 1.0
*/ 
Method getSchema() as object class MapaVendasTReportsBusinessObject
Local nX as numeric
Local lLGPD       := Iif(ExistFunc("FwPDCanUse"), FwPDCanUse(.T.), .F.) as logical // Verifica se a funcionalidade de Dados Protegidos está sendo utilizada no sistema.
Local lExibeCaixa := Iif(lLGPD .And. !FwProtectedDataUtil():UsrPersonAccessPD(), .F., .T.) as logical // Indica se deve exibir o nome do caixa conforme regras de dados protegidos

Local nTamNDoc := TamSx3("L1_NUMMOV")[1]

    For nX := 1 To Len(self:aStruct)
        self:addProperty(self:aStruct[nX][1], self:aStruct[nX][2], self:aStruct[nX][3], self:aStruct[nX][4], self:aStruct[nX][5])
    Next nX

	self:oSchema:addParameter("PAR_FILIAL" , STR0066, "string", .T.,,,,,, STR0079,,, 300) // "Filiais" ## "Filtra as vendas das lojas/filiais selecionadas. Caso não seja selecionada nenhuma, serão exibidas as vendas de todas as lojas/filiais."
	self:oSchema:addParameter("PAR_DTINI"  , STR0067, "date"  , .F.,,,,,, STR0080, .F.) // "Data inicial" ## "Filtra as vendas com data igual ou superior a data informada. Esse filtro é utilizado em conjunto com a 'data final'."
	self:oSchema:addParameter("PAR_DTFIM"  , STR0068, "date"  , .F.,,,,,, STR0081, .F.) // "Data final" ## "Filtra as vendas com data igual ou inferior a data informada. Esse filtro é utilizado em conjunto com a 'data inicial'."
	self:oSchema:addParameter("PAR_CAIXA"  , STR0069, "string", .T.,,,,,, STR0082,,, 300) // "Caixas" ## "Filtra as vendas dos caixas/operadores selecionados. Caso não seja selecionado nenhum, serão exibidas as vendas de todos os caixas/operadores."
	self:oSchema:addParameter("PAR_MOVINI" , STR0070, "string", .F.,,,,,, STR0083,,, nTamNDoc) // "N. do Movimento Inicial" ## "Filtra as vendas com número do movimento igual ou superior ao informado. Esse filtro é utilizado em conjunto com o 'N. do Movimento Final'. Caso não seja informado o número do movimento nos filtros 'N. do Movimento Inicial' e 'N. do Movimento Final', serão exibidas as vendas de todos os movimentos."
	self:oSchema:addParameter("PAR_MOVFIM" , STR0071, "string", .F.,,,,,, STR0084,,, nTamNDoc) // "N. do Movimento Final" ## "Filtra as vendas com número do movimento igual ou inferior ao informado. Esse filtro é utilizado em conjunto com o 'N. do Movimento Inicial'. Caso não seja informado o número do movimento nos filtros 'N. do Movimento Inicial' e 'N. do Movimento Final', serão exibidas as vendas de todos os movimentos."
	self:oSchema:addParameter("PAR_TPOPER" , STR0072, "number", .F.,,,,,, STR0085, .F., {1}) // "Tipo de operação" ## "Indica quais as operações serão exibidas no relatório, conforme a seleção. A opção 'Todas' exibe vendas, devoluções e estornos efetuados. A opção 'Vendas' exibe somente vendas efetuadas. A opção 'Devoluções/Estornos' exibe somente devoluções e estornos efetuados."
	self:oSchema:addParameter("PAR_IMPOSTO", STR0073, "number", .F.,,,,,, STR0086, .F., {1}) // "Considera impostos" ## "Indica se os valores de impostos da venda serão exibidos no relatório."
	self:oSchema:addParameter("PAR_SUPSAN" , STR0088, "number", .F.,,,,,, STR0089, .F., {1}) // "Considera sangria/suprimento" ## "Indica se os valores de sangrias e suprimentos (entrada de troco) serão exibidos no relatório."

	// Seta consulta padrão
	self:setCustomURL("PAR_FILIAL", "api/framework/v1/genericLookupService/smartview/SM0", 2)
	If lExibeCaixa .And. ExistSXB("SLF2") // Se pode mostrar o nome do caixa usa consulta que tem o código e nome
		self:setCustomURL("PAR_CAIXA", "api/framework/v1/genericLookupService/smartview/SLF2", 2)
	Else // Se não pode mostrar o nome do caixa troca a consulta para uma que só tem o código
		self:setCustomURL("PAR_CAIXA", "api/framework/v1/genericLookupService/smartview/SLF", 2)
	EndIf

	// Seta opções de combo
	self:setCustomURL("PAR_TPOPER" , "/api/sigaloja/smartview/v1/options/loja/MapaDeVenda/MpVendaCb/1", 1)
	self:setCustomURL("PAR_IMPOSTO", "/api/sigaloja/smartview/v1/options/loja/MapaDeVenda/MpVendaCb/2", 1)
	self:setCustomURL("PAR_SUPSAN" , "/api/sigaloja/smartview/v1/options/loja/MapaDeVenda/MpVendaCb/2", 1)

Return self:oSchema

/*{Protheus.doc} gravaRegristro
Retorna a estrutura dos campos 
@return object: self:oSchema 
@author joao.marcos
@since 06/04/2023
@version 1.0
*/
Method gravaRegristro(cAlias as character) class MapaVendasTReportsBusinessObject
Local lGrvValLiq := .F. as logical
Local nValImp    := 0 as numeric

// Preenche variáveis de filial caso o registro seja de outra filial se comparado ao registro anterior
If Self:cCodFil <> (cAlias)->L1_FILIAL
    Self:cCodFil  := (cAlias)->L1_FILIAL
    Self:cDescFil := FWFilialName( , (cAlias)->L1_FILIAL )
EndIf

// Preenche variável de filial+num para avaliar se o registro da query é de uma venda diferente se comparado ao registro anterior
// Essa regra é necessária para que em registros da query que são da mesma venda (isso ocorre
// quando a venda tem mais de uma forma de pagamento) seja gravado o valor líquido da venda em um único registro,
// para que o valor não seja multiplicado pela quantidade de formas de pagamento.
If Self:cNumVenda <> (cAlias)->L1_FILIAL+(cAlias)->L1_NUM
    Self:cNumVenda := (cAlias)->L1_FILIAL+(cAlias)->L1_NUM
    lGrvValLiq := .T. // Indica se grava o valor líquido da venda
Else
    lGrvValLiq := .F.
EndIf

If Self:lExibeImp
    If (cAlias)->L1_ABTOPCC > Self:nValMinPCC
        nValImp += (cAlias)->L1_ABTOPCC
    EndIf
    If (cAlias)->L1_VALIRRF > Self:nValMinIR
        nValImp += (cAlias)->L1_VALIRRF
    EndIf
EndIf

Self:aRegistros := {    (cAlias)->L1_FILIAL,;   // 01
                        (cAlias)->L1_NUM,;      // 02
                        (cAlias)->L1_DOC,;      // 03
                        (cAlias)->L1_SERIE,;    // 04
                        (cAlias)->A1_NOME,;     // 05
                        (cAlias)->L1_CLIENTE,;  // 06
                        (cAlias)->L1_LOJA,;     // 07
                        totvs.framework.treports.date.dateToTimeStamp(STOD((cAlias)->L1_EMISSAO_DATA)),;   // 08
                        DtoC(StoD((cAlias)->L1EMISSAO)),;                   // 09
                        (cAlias)->L1_OPERADO,;  // 10
                        (cAlias)->L1_VEND,;     // 11
                        (cAlias)->L1_NUMMOV,;   // 12
                        (cAlias)->L1_VLRTOT,;   // 13
                        IIf(lGrvValLiq, (cAlias)->L1_VLRLIQ, 0),;   // 14
                        (cAlias)->ACRESSIMO,;   // 15
                        (cAlias)->DESCON,;      // 16
                        (cAlias)->L1_DINHEIR,;  // 17
                        (cAlias)->L1_CHEQUES,;  // 18
                        (cAlias)->L1_CARTAO,;   // 19
                        (cAlias)->L1_VLRDEBI,;  // 20
                        (cAlias)->L1_FINANC,;   // 21
                        (cAlias)->L1_CONVENI,;  // 22
                        (cAlias)->L1_VALES,;    // 23
                        (cAlias)->L1_DESCONT,;  // 24
                        nValImp             ,;  // 25
                        (cAlias)->L1_RECISS,;   // 26
                        (cAlias)->L1_TROCO1,;   // 27
                        AllTrim((cAlias)->L4_FORMA),;   // 28
                        (cAlias)->L4_VALOR,;    // 29
                        (cAlias)->D1_DOC,;      // 30
                        (cAlias)->D1_SERIE,;    // 31
                        (cAlias)->D1_NFORI,;    // 32
                        (cAlias)->D1_SERIORI,;  // 33
                        (cAlias)->D1_TOTAL,;    // 34
                        (cAlias)->D1_OPERADO,;  // 35
                        (cAlias)->L1_DOCPED,;   // 36
                        (cAlias)->L1_SERPED,;   // 37
                        (cAlias)->L1_SITUA,;    // 38
                        (cAlias)->FRSEGDES,;    // 39
                        (cAlias)->L1_VLRJUR,;   // 40
                        (cAlias)->E5_VALOR,;    // 41
                        (cAlias)->RECPAG  ,;    // 42
                        (cAlias)->A3_NOME ,;    // 43
                        (cAlias)->D1_DESCONTO,; // 44
                        (cAlias)->D1_ABTOPCC,;  // 45
                        (cAlias)->A6_NOME,;     // 46
                        (cAlias)->ORDEM,;       // 47
                        (cAlias)->L1_CREDITO,;  // 48
                        Self:cDescFil}          // 49
Return

/*{Protheus.doc} getSchema
Retorna a estrutura dos campos 
@return object: self:oSchema 
@author joao.marcos
@since 06/04/2023
@version 1.0
*/
Method appendRegristro(nL4Valor as numeric, nDescon as numeric, nL1VlrJur as numeric ) class MapaVendasTReportsBusinessObject

Local cDoc      := Iif(Empty(self:aRegistros[3]), self:aRegistros[36], self:aRegistros[3])
Local cSerie    := Iif(Empty(self:aRegistros[4]),self:aRegistros[37], self:aRegistros[4])
Local lEstorno  := !Empty(self:aRegistros[35])

self:oData:appendData({ "L1_FILIAL":        self:aRegistros[1],; // (cAlias)->L1_FILIAL
                        "L1_NUM":           self:aRegistros[2],; // (cAlias)->L1_NUM
                        "L1_DOC":           cDoc,; // (cAlias)->L1_DOC
                        "L1_SERIE":         cSerie,; // (cAlias)->L1_SERIE
                        "A1_NOME":          IIf(Self:lExibeCli, self:aRegistros[5], Replicate("*", 25)),; // (cAlias)->A1_NOME
                        "L1_CLIENTE":       self:aRegistros[6],; // (cAlias)->L1_CLIENTE
                        "L1_LOJA":          self:aRegistros[7],; // (cAlias)->L1_LOJA
                        "L1_EMISSAO_DATA":  self:aRegistros[8],; // FwTimeStamp(6, StoD((cAlias)->L1_EMISSAO_DATA))
                        "L1EMISSAO":        self:aRegistros[9],; // DtoC(StoD((cAlias)->L1EMISSAO))
                        "L1_OPERADO":       self:aRegistros[10],; // (cAlias)->L1_OPERADO
                        "L1_VEND":          self:aRegistros[11],; // (cAlias)->L1_VEND
                        "L1_NUMMOV":        self:aRegistros[12],; // (cAlias)->L1_NUMMOV
                        "L1_VLRTOT":        self:aRegistros[13],; // (cAlias)->L1_VLRTOT
                        "L1_VLRLIQ":        self:aRegistros[14],; // (cAlias)->L1_VLRLIQ
                        "ACRESSIMO":        self:aRegistros[15],; // (cAlias)->ACRESSIMO
                        "DESCON":           nDescon,;             // (cAlias)->DESCON
                        "L1_DINHEIR":       self:aRegistros[17],; // (cAlias)->L1_DINHEIR
                        "L1_CHEQUES":       self:aRegistros[18],; // (cAlias)->L1_CHEQUES
                        "L1_CARTAO":        self:aRegistros[19],; // (cAlias)->L1_CARTAO
                        "L1_VLRDEBI":       self:aRegistros[20],; // (cAlias)->L1_VLRDEBI
                        "L1_FINANC":        self:aRegistros[21],; // (cAlias)->L1_FINANC
                        "L1_CONVENI":       self:aRegistros[22],; // (cAlias)->L1_CONVENI
                        "L1_VALES":         self:aRegistros[23],; // (cAlias)->L1_VALES
                        "L1_DESCONT":       self:aRegistros[24],; // (cAlias)->L1_DESCONT
                        "L1_ABTOPCC":       self:aRegistros[25],; // (cAlias)->L1_ABTOPCC + (cAlias)->L1_VALIRRF
                        "L1_RECISS":        self:aRegistros[26],; // (cAlias)->L1_RECISS
                        "L1_TROCO1":        self:aRegistros[27],; // (cAlias)->L1_TROCO1
                        "L4_FORMA":         self:aRegistros[28],; // AllTrim((cAlias)->L4_FORMA)
                        "L4_VALOR":         nL4Valor           ,; // (cAlias)->L4_VALOR
                        "D1_DOC":           self:aRegistros[30],; // (cAlias)->D1_DOC
                        "D1_SERIE":         self:aRegistros[31],; // (cAlias)->D1_SERIE
                        "D1_NFORI":         self:aRegistros[32],; // (cAlias)->D1_NFORI
                        "D1_SERIORI":       self:aRegistros[33],; // (cAlias)->D1_SERIORI
                        "D1_TOTAL":         self:aRegistros[34],; // (cAlias)->D1_TOTAL
                        "D1_OPERADO":       Iif(lEstorno, 'EST', self:aRegistros[35]) ,; // (cAlias)->D1_OPERADO
                        "L1_DOCPED":        self:aRegistros[36],; // (cAlias)->L1_DOCPED
                        "L1_SERPED":        self:aRegistros[37],; // (cAlias)->L1_SERPED
                        "L1_SITUA":         self:aRegistros[38],; // (cAlias)->L1_SITUA
                        "FRSEGDES":         self:aRegistros[39],; // (cAlias)->FRSEGDES
                        "L1_VLRJUR":        nL1VlrJur          ,; // (cAlias)->L1_VLRJUR
                        "E5_VALOR":         self:aRegistros[41],; // (cAlias)->E5_VALOR
                        "RECPAG":           self:aRegistros[42],; // (cAlias)->RECPAG   
                        "A3_NOME":          IIf(Self:lExibeVen, self:aRegistros[43], Replicate("*", 10)),; // (cAlias)->A3_NOME
                        "D1_DESCONTO":      self:aRegistros[44],; // (cAlias)->D1_DESCONTO
                        "D1_ABTOPCC":       self:aRegistros[45],; // (cAlias)->D1_ABTOPCC
                        "A6_NOME":          IIf(Self:lExibeCxa, self:aRegistros[46], Replicate("*", 10)),; // (cAlias)->A6_NOME
                        "ORDEM":            Iif(lEstorno, 'C', self:aRegistros[47]),; // (cAlias)->ORDEM
                        "L1_CREDITO":       self:aRegistros[48],; // (cAlias)->L1_CREDITO
                        "DESCFILIAL":       self:aRegistros[49]}) // Descrição da Filial
Return

/*{Protheus.doc} processaQuery
Retorna a estrutura dos campos 
@return object: self:oSchema 
@author joao.marcos
@since 06/04/2023
@version 1.0
@param cQuery, caracter, Query
@param nOp, numerico, 1 - Venda | 2 - Devolucao
@param nPage, numeric, numero da pagina
*/
Method processaQuery(cAlias as character, nOp as numeric, nPage as numeric ) class MapaVendasTReportsBusinessObject

Local nL4Valor          := 0    as numeric      // Valor da Forma de Pagamento (Tratamento para parcelas)
Local nVlrDesconto      := 0    as numeric      // Valor do desconto na venda
Local nVlrJuros         := 0    as numeric
Local nContFormPgVenda  := 0    as Numeric      // Contador de Formas de Pagamento da Venda
Local cChaveFormaPg     := ""   as character    // Chave para saber se eh a mesma Forma de Pagamento
Local cChaveVenda       := ""   as character    // Chave para seber se ainda eh a mesma venda
//Local cAlias            := cAliasQuery1 as character
Local nSkip             := 0            as numeric

//Seta a quantidade de itens por página (Default 100)
self:setPageSize(15)  //Posiciona o conteúdo da query

If nPage == 1
    (cAlias)->(dbGoTop())
Else
    //Encontra a quantidade de itens que irá pular de acordo com a página atual
    nSkip := ((nPage - 1) * self:getPageSize())      
 
    (cAlias)->(dbSkip(nSkip))
Endif   

cChaveFormaPg := (cAlias)->L1_FILIAL+(cAlias)->L1EMISSAO+(cAlias)->L1_DOC+(cAlias)->L1_SERIE+(cAlias)->L1_CLIENTE+(cAlias)->L4_FORMA+(cAlias)->L1_DOCPED+(cAlias)->L1_SERPED
cChaveVenda := (cAlias)->L1_FILIAL+(cAlias)->L1EMISSAO+(cAlias)->L1_DOC+(cAlias)->L1_SERIE+(cAlias)->L1_CLIENTE

self:gravaRegristro(cAlias)

If !Empty(cChaveFormaPg)

    nL4Valor        := Iif(ValType((cAlias)->L4_VALOR) == "C", 0,(cAlias)->L4_VALOR)
    nVlrDesconto    := (cAlias)->DESCON
    nVlrJuros       := (cAlias)->L1_VLRJUR
    nContFormPgVenda++

    (cAlias)->(DBSkip())

    While !(cAlias)->(Eof())
        // Trata parcelas, para ficar em um valor unico por forma de pagamento
        If Empty((cAlias)->RECPAG) .AND. nOp == 1 .AND. cChaveFormaPg == (cAlias)->L1_FILIAL+(cAlias)->L1EMISSAO+(cAlias)->L1_DOC+(cAlias)->L1_SERIE+(cAlias)->L1_CLIENTE+(cAlias)->L4_FORMA+(cAlias)->L1_DOCPED+(cAlias)->L1_SERPED
            nL4Valor += Iif(ValType((cAlias)->L4_VALOR) == "C", 0,(cAlias)->L4_VALOR)

            If nContFormPgVenda == 1 //cChaveDesc == (cAlias)->L1_FILIAL+(cAlias)->L1EMISSAO+(cAlias)->L1_DOC+(cAlias)->L1_SERIE+(cAlias)->L1_CLIENTE
                nVlrDesconto    := (cAlias)->DESCON
                nVlrJuros       := (cAlias)->L1_VLRJUR
            EndIf

            self:gravaRegristro(cAlias)

        Else
            self:appendRegristro(nL4Valor, nVlrDesconto, nVlrJuros)
            
            If cChaveVenda == (cAlias)->L1_FILIAL+(cAlias)->L1EMISSAO+(cAlias)->L1_DOC+(cAlias)->L1_SERIE+(cAlias)->L1_CLIENTE
                 nContFormPgVenda++
                 nVlrDesconto   := 0
                 nVlrJuros      := 0
            Else
                cChaveVenda := (cAlias)->L1_FILIAL+(cAlias)->L1EMISSAO+(cAlias)->L1_DOC+(cAlias)->L1_SERIE+(cAlias)->L1_CLIENTE
                nContFormPgVenda := 1
            EndIf
            
            cChaveFormaPg := (cAlias)->L1_FILIAL+(cAlias)->L1EMISSAO+(cAlias)->L1_DOC+(cAlias)->L1_SERIE+(cAlias)->L1_CLIENTE+(cAlias)->L4_FORMA
            
            nL4Valor := Iif(ValType((cAlias)->L4_VALOR) == "C", 0,(cAlias)->L4_VALOR)

            If nContFormPgVenda == 1
                nVlrDesconto    := (cAlias)->DESCON
                nVlrJuros       := (cAlias)->L1_VLRJUR
            EndIf

            self:gravaRegristro(cAlias)
        EndIf    

        (cAlias)->(DBSkip())
        Self:nCount++
    
        //Sai do loop quando chegar no tamanho de itens da página
        If Self:nCount == self:getPageSize()
            Exit
        Endif
    EndDo

    If (cAlias)->(Eof())
        self:appendRegristro(nL4Valor, nVlrDesconto, nVlrJuros)    
    EndIf
    
    //Se não for o último registro indica que terá próxima página
    self:setHasNext(!(cAlias)->(Eof()))
EndIf

(cAlias)->(DBCloseArea())

Return

/*{Protheus.doc} getStruct
Prepara a estrutura dos campos
@author joao.marcos
@since 06/04/2023
@version 1.0
@param aCpos array: Array com os campos do relatorio 
@return array: Array com a estrutura dos campos
*/
Static Function getStruct(aCpos)
Local aDeParaCpo as array
Local aCpoTmp    as array
Local cCampo     as character
Local cCpoQry    as character
Local cTipR      as character
Local nPos       as numeric
Local nC         as numeric
 
aDeParaCpo := {{"C", "string"}, {"D", "date"}, {"N", "number"}, {"L", "boolean"}}
aCpoTmp    := {}
 
For nC := 1 to Len(aCpos)
    cCpoQry := aCpos[nC]
    nPos    := AT(".", aCpos[nC]) + 1
     
    If nPos > 0
        cCampo := Substr(cCpoQry, nPos)
    Else
        cCampo := cCpoQry
    Endif    
     
    cTipo := GetSx3Cache(cCampo, "X3_TIPO")
     
    If Upper(AllTrim(cCampo)) $ "L1_EMISSAO_DATA|L1EMISSAO"
        cTipR := "string"
    ElseIf Upper(AllTrim(cCampo)) $ "DESCON/FRSEGDES/ACRESSIMO/D1_DESCONTO/D1_ABTOPCC"
        cTipR := "number"     
    ElseIf(nPos := aScan(aDeParaCpo, {|c| c[01] = cTipo})) > 0
        cTipR := aDeParaCpo[nPos, 02]
    Else
        cTipR := "string"
    Endif
 
   AAdd(aCpoTmp, {cCampo, FWSX3Util():GetDescription(cCampo), cTipR, cCampo, cCampo})
Next nC
 
Return (aCpoTmp)

//-------------------------------------------------------------------
/*{Protheus.doc} MpVendaCb
Retorna as opções disponíveis para parâmetros do tipo combo.

@param cOpcao, Define qual combo será exibido
               1 - "Todas, Vendas e Devoluções/Estornos"
               2 - "Sim e Não"

@return aRet, Array com as opções do combo

@author Jorge Martins
@since  26/03/2025
@version 1.0
*/
//-------------------------------------------------------------------
Function MpVendaCb(cOpcao)
Local aRet := {} as array

	If cOpcao == "1" // Tipo de operação
		aRet := {STR0075, STR0076, STR0077} // "Todas", "Vendas", "Devoluções/Estornos"
	Else
		aRet := {STR0055, STR0078} // "Sim", "Não"
	Endif

Return aRet

//-------------------------------------------------------------------
/*{Protheus.doc} ExistSXB
Valida se a consulta padrão informada no parâmetro existe no dicionário

@param cF3, Consulta a ser validada

@return lRet, Se .T. indica que a consulta padrão existe

@author Jorge Martins
@since  26/03/2025
@version 1.0
*/
//-------------------------------------------------------------------
Static Function ExistSXB(cF3)
Local lRet     := .F. as logical
Local aAreaSXB := SXB->(GetArea()) as array

	SXB->(DbSetOrder(1)) // XB_ALIAS
	If SXB->(DbSeek(cF3)) // DBSeek usado em If para não travar DbAccess caso não encontre
		lRet := .T.
	EndIf
	RestArea(aAreaSXB)

Return lRet

//-------------------------------------------------------------------
/*{Protheus.doc} MultiSel
Faz o tratamento das consultas com multiseleção

@param aMultiSel, Registros selecionados
@param cCampo   , Campo referência para ajuste de tamanho do conteúdo

@return aDados, Dados tratados

@author Jorge Martins
@since  26/03/2025
@version 1.0
*/
//-------------------------------------------------------------------
Static Function MultiSel(aMultiSel, cCampo)
Local aDados := {} as array
Local nMulti := 0  as numeric

	If Len(aMultiSel) == 0 // Multiselect sem valor preenchido
		aAdd(aDados, "")
	Else // Multiselect com um ou mais valores preenchidos
		For nMulti := 1 To Len(aMultiSel)
			aAdd(aDados, AvKey(aMultiSel[nMulti], cCampo))
		Next
	EndIf

Return aDados
