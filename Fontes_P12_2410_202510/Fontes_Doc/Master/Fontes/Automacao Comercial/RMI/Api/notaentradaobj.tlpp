#INCLUDE "TOTVS.CH"
#INCLUDE "NOTAENTRADAOBJ.CH"

namespace totvs.protheus.retail.rmi.api.notaentradaobj

//-------------------------------------------------------------------
/*/{Protheus.doc} Classe NotaEntradaObj
    Classe para tratamento da API de Notas Fiscais de Saída do Varejo
/*/
//-------------------------------------------------------------------
Class NotaEntradaObj From LojRestObj20

	Public Method New()             as Object
    Public Method setFields()       as Variant

    Private Method setSelect()      as Variant

    Protected Method Validation()   as Variant
    Protected Method execAuto()     as Variant
    Protected Method loja720()      as Variant
    Protected Method execAddCli()   as Variant

    Private Data cIdRetaguardaNota  as Character
    Private Data lAcrescimo         as Logical      //Define se considera acrescimo na devolucao

EndClass

//-------------------------------------------------------------------
/*/{Protheus.doc} New
Método construtor da Classe

@param oWsRestObj - Objeto WSRESTFUL da API

@author  Rafael Tenorio da Costa
@since   16/07/2019
@version 12.1.33
/*/
//-------------------------------------------------------------------
Method New(oWsRestObj As Object, jParans as Json, cBody as Character) as Object Class NotaEntradaObj

    _Super:New(oWsRestObj, jParans, cBody)

    self:lAcrescimo := !( AllTrim( SuperGetMV("MV_LJDVACR", , "") ) == "1" )    //Define se considera acrescimo financeiro na devolucao, 1 o sistema deve desconsiderar o acréscimo e como 0 considerar o acréscimo.

Return self

//-------------------------------------------------------------------
/*/{Protheus.doc} setFields
Carrega os campos que serão retornados

@author  Rafael Tenorio da Costa
@since   16/07/2019
@version 12.1.33
/*/
//-------------------------------------------------------------------
Method setFields() as Variant Class NotaEntradaObj

                        //Tag - ID				Campo       Expressão que será executada para gerar o retorno   Tag que será utilizada para preencher o objeto de retorno   Tipo do Campo   Expressão de busca
    HmAdd(self:oFields, {"IDRETAGUARDANOTA"     , ""        , "F1_FILIAL+F1_DOC+F1_SERIE"                       , "idRetaguardaNota"    		                            , "C"           , ""}               , 1, 3)
    HmAdd(self:oFields, {"IDRETAGUARDACREDITO"	, ""	    , "E1_FILIAL+E1_NUM+E1_PREFIXO+E1_PARCELA+E1_TIPO"  , "idRetaguardaCredito"		                                , "C"           , ""}               , 1, 3)
    HmAdd(self:oFields, {"VALORCREDITO"         , "E1_VALOR", "E1_VALOR"  									    , "valorCredito"					                        , "N"           , ""}               , 1, 3)

Return Nil

//-------------------------------------------------------------------
/*/{Protheus.doc} setSelect
Carrega a query que será executada

@author  Rafael Tenorio da Costa
@since   23/07/2019
@version 12.1.33
/*/
//-------------------------------------------------------------------
Method setSelect(cTable as Character) as Variant Class NotaEntradaObj

    Local aParans   := self:jparans:GetNames()
    Local nX        := 0

    self:cTable := cTable

    self:cSelect := " SELECT"
    self:cSelect += 	" F1_FILIAL, F1_DOC, F1_SERIE,"
    self:cSelect += 	" E1_FILIAL, E1_NUM, E1_PREFIXO, E1_PARCELA, E1_TIPO,"
    self:cSelect += 	" ISNULL(E1_VALOR, 0) AS E1_VALOR"
    self:cSelect += " FROM " + RetSqlName("SF1") + " F1 LEFT JOIN " + RetSqlName("SE1") + " E1"
    self:cSelect += 	" ON E1.D_E_L_E_T_ = ' ' AND F1_FILIAL = E1_FILORIG AND F1_DOC = E1_NUM AND F1_PREFIXO = E1_PREFIXO

    self:cWhere  := " WHERE F1.D_E_L_E_T_ = ' '"
    self:cWhere  +=     " AND F1_TIPO = 'D'"
    self:cWhere  +=     " AND CONCAT(F1_FILIAL, F1_DOC, F1_SERIE) = '" + self:cIdRetaguardaNota + "'"

    self:cGroupBy:= " GROUP BY F1_FILIAL, F1_DOC, F1_SERIE, E1_FILIAL, E1_NUM, E1_PREFIXO, E1_PARCELA, E1_TIPO, E1_VALOR"

    self:cOrderBy:= ""

    //Retira para não utilizador no filtro
    For nX := 1 To Len(aParans)
        self:jParans:delName(aParans[nX])
    Next

Return Nil

//-------------------------------------------------------------------
/*/{Protheus.doc} Validation
Metodo para validações executado no momento do get

@author  Rafael Tenorio da Costa
@since   14/09/2022
@version 1.0
/*/
//-------------------------------------------------------------------
Method Validation(cOrigem as Character) as Variant Class NotaEntradaObj
    Local cTestroca := SuperGetMv("MV_TESTROC")
	
    _Super:Validation()

    If self:lSuccess

        If cOrigem == "POST"
            DbSelectArea("SF4")
	        SF4->( DbSetOrder(1) )
            Do Case

                Case !self:jParans:hasProperty("idRetaguardaLoja") .Or. Empty(self:jParans["idRetaguardaLoja"])
                    self:lSuccess   := .F.
                    self:cError     := I18n(STR0001, {"idRetaguardaLoja"})  //"Ops! #1 não enviado(s) ou inválido(s)."

                Case !self:jParans:hasProperty("cliente") .Or. !self:jParans["cliente"]:hasProperty("cpfCnpj") .Or. Empty(self:jParans["cliente"]["cpfCnpj"])
                    self:lSuccess   := .F.
                    self:cError     := I18n(STR0001, {"cliente"})           //"Ops! #1 não enviado(s) ou inválido(s)."

                Case !self:jParans:hasProperty("cliente") .Or. !self:jParans["cliente"]:hasProperty("nome") .Or. Empty(self:jParans["cliente"]["nome"])
                    self:lSuccess   := .F.
                    self:cError     := I18n(STR0001, {"cliente {nome}"})           //"Ops! #1 não enviado(s) ou inválido(s)."

                Case !self:jParans:hasProperty("cliente") .Or. !self:jParans["cliente"]:hasProperty("endereco") .Or. Empty(self:jParans["cliente"]["endereco"])
                    self:lSuccess   := .F.
                    self:cError     := I18n(STR0001, {"cliente {endereco}"})           //"Ops! #1 não enviado(s) ou inválido(s)."

                Case !self:jParans:hasProperty("cliente") .Or. !self:jParans["cliente"]:hasProperty("uf") .Or. Empty(self:jParans["cliente"]["uf"])
                    self:lSuccess   := .F.
                    self:cError     := I18n(STR0001, {"cliente {uf}"})           //"Ops! #1 não enviado(s) ou inválido(s)."
                
                Case !self:jParans:hasProperty("cliente") .Or. !self:jParans["cliente"]:hasProperty("municipio") .Or. Empty(self:jParans["cliente"]["municipio"])
                    self:lSuccess   := .F.
                    self:cError     := I18n(STR0001, {"cliente municipio"})           //"Ops! #1 não enviado(s) ou inválido(s)."

                Case !self:jParans:hasProperty("itens") .Or. ValType(self:jParans["itens"]) <> "A" .Or. Len(self:jParans["itens"]) == 0
                    self:lSuccess   := .F.
                    self:cError     := I18n(STR0001, {"itens"}  )           //"Ops! #1 não enviado(s) ou inválido(s)."
                
                Case SF4->(DbSeek( xFilial("SF4",PADR(self:jParans["idRetaguardaLoja"],TAMSX3("F4_FILIAL")[1])) + cTESTroca)) .AND. ALLTRIM(F4_DUPLIC) == "N"
                    self:lSuccess   := .F.
                    self:cError     := STR0008+cTestroca+STR0009+CRLF//"Ops! Verifique no Protheus a TES: "+cTestroca+" no parâmetro MV_TESTROC, sua configuração é inválida, o campo F4_DUPLIC não pode ser igual a 'N' "
                    self:cError     += STR0010+cTestroca+" " +CRLF//"Solicite a troca da TES no parâmetro ou ajuste a configuração da TES: "
                    self:cError     += STR0011//"Pois a configuração atual não permite a geração do financeiro para NCC."

                Case Empty( SuperGetMv("MV_LJNFTRO") )
                    self:lSuccess   := .F.
                    self:cError     := I18n(STR0012, {"MV_LJNFTRO"})        //"Ops! Conteúdo do parâmetro #1 inválido, seu preenchimento é obrigatório para efetuar a devolução."

            End Case

            If self:lSuccess
                self:cFil := self:jParans["idRetaguardaLoja"]
            EndIf
        Else

            self:setSelect("SF2")
        EndIf
    EndIf

Return Nil

//-------------------------------------------------------------------
/*/{Protheus.doc} ExecAuto


@author  Rafael Tenorio da Costa
@since   09/08/2019
@version 12.1.33
/*/
//-------------------------------------------------------------------
Method execAuto() as Variant Class NotaEntradaObj

    Local cSerie        as Character
    Local cNota         as Character
    Local cSql          as Character
    Local cTabela       as Character
    Local nItem         as Numeric
    Local aItem         as Array
    Local cTesDev       as Character
    Local nQtdDev       as Numeric
    Local nValDev       as Numeric
    Local nSaldoQtd     as Numeric
    Local nDespesa      as Numeric
    Local cBkpFunName   as Character

    SA1->( DbSetOrder(3) )  //A1_FILIAL, A1_CGC
    If self:lSuccess .And. !SA1->( DbSeek( xFilial("SA1") + self:jParans["cliente"]["cpfCnpj"] ) )
        self:execAddCli()            
    EndIf
    
    If self:lSuccess

        nDespesa:= 0
        cSerie  := PadR( SuperGetMv("MV_LJNFTRO"), 3)   //Serie padrao para troca/devolucao LOJA720
        cNota   := NxtSX5Nota(cSerie,,,,,,,,"SPED") //Gera a proxima nota fiscal de devolucao, com a serie padrao para troca/devolucao

        cTabela := GetNextAlias()
        
        aAdd(self:aExecAuto, {})
        aAdd(self:aExecAuto, {})

        //Adiciona Cabecalho da NF de Devolucao
        aAdd(self:aExecAuto[1], {"F1_TIPO"   	, "D"                       } )
        aAdd(self:aExecAuto[1], {"F1_FORMUL" 	, "S"                       } )
        aAdd(self:aExecAuto[1], {"F1_DOC"    	, cNota                     } )
        aAdd(self:aExecAuto[1], {"F1_SERIE"  	, cSerie                    } )
        aAdd(self:aExecAuto[1], {"F1_EMISSAO"	, dDataBase                 } )
        aAdd(self:aExecAuto[1], {"F1_FORNECE"	, SA1->A1_COD               } )
        aAdd(self:aExecAuto[1], {"F1_LOJA"   	, SA1->A1_LOJA              } )
        aAdd(self:aExecAuto[1], {"F1_ESPECIE"	, "SPED"                    } )
        aAdd(self:aExecAuto[1], {"F1_COND"		, SuperGetMv("MV_CONDPAD")  } )

        For nItem:=1 To Len(self:jParans["itens"])

            If !self:jParans["itens"][nItem]:hasProperty("idRetaguardaCupomItem") .Or. !self:jParans["itens"][nItem]:hasProperty("quantidade")
                self:lSuccess   := .F.
                self:cError     := I18n(STR0003, {cValToChar(nItem), "idRetaguardaCupomItem", "quantidade"})    //"Ops! Item #1 sem #2 ou #3."
                Exit
            EndIf

            If self:jParans["itens"][nItem]["quantidade"] <= 0
                self:lSuccess   := .F.
                self:cError     := I18n(STR0004, {cValToChar(nItem), "quantidade"})     //"Ops! Item #1 com #2 inválida."
                Exit
            EndIf

            cSql := " SELECT D2_FILIAL, D2_DOC, D2_SERIE, D2_ITEM, D2_COD, D2_QUANT, D2_PRCVEN, D2_TOTAL, D2_QTDEDEV, D2_VALDEV, D2_DESPESA,"
            cSql += " D2_LOTECTL, D2_NUMLOTE, D2_DTVALID, D2_POTENCI,"
            cSql += " F4_TESDV"
            cSql += " FROM " + RetSqlName("SD2") + " D2 LEFT JOIN " + RetSqlName("SF4") + " F4 "
            cSql +=     " ON F4.D_E_L_E_T_ = ' ' AND F4_FILIAL = '" + xFilial("SF4") + "' AND D2_TES = F4_CODIGO"
            cSql += " WHERE D2.D_E_L_E_T_ = ' ' AND CONCAT(D2_FILIAL, D2_DOC, D2_SERIE, D2_ITEM) = '" + self:jParans["itens"][nItem]["idRetaguardaCupomItem"] + "'"
        
            DbUseArea(.T., "TOPCONN", TcGenQry( , , cSql), cTabela, .T., .F.)

            tcSetField(cTabela, "D2_DTVALID", "D" , 8 , 0)

            If (cTabela)->( Eof() )

                self:lSuccess   := .F.
                self:cError     := I18n(STR0005, {cValToChar(nItem), "idRetaguardaCupomItem"})  //"Ops! Item #1 não foi localizado, verifique o #2."
                Exit
            Else

                //Valida quantidade e valor
                nQtdDev := self:jParans["itens"][nItem]["quantidade"]
                nValDev := 0

                Do Case
                    Case nQtdDev > ( nSaldoQtd := (cTabela)->D2_QUANT - (cTabela)->D2_QTDEDEV )
                        self:lSuccess   := .F.
                        self:cError     := I18n(STR0007, {cValToChar(nItem), cValToChar(nSaldoQtd)})    //"Ops! Quantidade devolvida no item #1 é maior que o saldo disponível(#2) para devolução."
                        Exit

                    Case (cTabela)->D2_QUANT == nQtdDev
                        nValDev := (cTabela)->D2_TOTAL

                    Case (cTabela)->D2_QUANT == (nQtdDev + (cTabela)->D2_QTDEDEV)
                        nValDev := (cTabela)->D2_TOTAL - (cTabela)->D2_VALDEV

                    OtherWise
                        nValDev := (cTabela)->D2_PRCVEN * nQtdDev
                End Case            

                //Valida TES
                cTesDev := SuperGetMv("MV_TESTROC", .F.)    //TES padrao para troca/devolucao

                If !Empty( (cTabela)->F4_TESDV )
                    cTesDev := (cTabela)->F4_TESDV
                EndIf

                SF4->( DbSetOrder(1) )  //F4_FILIAL, F4_CODIGO
                If !SF4->( DbSeek(xFilial("SF4") + cTesDev) )
                    self:lSuccess   := .F.
                    self:cError     := I18n(STR0006, {"Tes", cTesDev, cValToChar(nItem)})   //"Ops! #1 de devolução (#2) para o item #3, não foi localizada."
                    Exit
                Else

                    If SF4->F4_DUPLIC <> "S"
                        LjxjMsgErr( I18n("Nao sera gerado o titulo de NCC, a Tes #1 esta configurada para nao gerar financeiro. (#2)", {cTesDev, cNota+cSerie}), /*cSolucao*/, GetClassName(self) )
                    EndIf
                EndIf

                //Adiciona Itens da NF de Devolucao
                aItem := {}
                aAdd(aItem, {"D1_DOC"  		, cNota                 , Nil})
                aAdd(aItem, {"D1_SERIE"  	, cSerie                , Nil})
                aAdd(aItem, {"D1_COD"  		, (cTabela)->D2_COD		, Nil})
                aAdd(aItem, {"D1_QUANT"		, nQtdDev               , Nil})
                aAdd(aItem, {"D1_VUNIT"     , (cTabela)->D2_PRCVEN	, Nil})
                aAdd(aItem, {"D1_TOTAL"     , nValDev               , Nil})
                aAdd(aItem, {"D1_TES"		, cTesDev               , Nil})
                aAdd(aItem, {"D1_CF"		, SF4->F4_CF            , Nil})
                aAdd(aItem, {"D1_FILORI"	, (cTabela)->D2_FILIAL	, Nil})
                aAdd(aItem, {"D1_NFORI"		, (cTabela)->D2_DOC	    , Nil})
                aAdd(aItem, {"D1_SERIORI"	, (cTabela)->D2_SERIE	, Nil})
                aAdd(aItem, {"D1_ITEMORI"	, (cTabela)->D2_ITEM	, Nil})

                If self:lAcrescimo
                    aAdd(aItem, {"D1_DESPESA", ( (cTabela)->D2_DESPESA / (cTabela)->D2_QUANT ) * nQtdDev, Nil})
                    nDespesa += aItem[Len(aItem)][2]
                EndIf

                //Carrega campos de controle de lote
                if rastro( (cTabela)->D2_COD, /*cTipo*/ )

                    if empty( (cTabela)->D2_LOTECTL )

                        self:lSuccess   := .F.
                        self:cError     := I18n(STR0013, {cValToChar(nItem)})   //"Não será possível realizar a devolução do item #1, pois não foi informado lote no momento da venda, mas o produto possui controle de lote ativo, sendo obrigatório esta informação para o documento de entrada."
                        exit
                    else

                        aAdd(aItem, {"D1_LOTECTL"	, (cTabela)->D2_LOTECTL	, Nil})
                        aAdd(aItem, {"D1_NUMLOTE"	, (cTabela)->D2_NUMLOTE	, Nil})
                        aAdd(aItem, {"D1_DTVALID"	, (cTabela)->D2_DTVALID	, Nil})
                        aAdd(aItem, {"D1_POTENCI"	, (cTabela)->D2_POTENCI	, Nil})
                    endIf
                endIf

                aAdd(self:aExecAuto[2], aClone(aItem))
            EndIf
            (cTabela)->( DBCloseArea() )

        Next nItem

        If self:lSuccess

            If nDespesa > 0
                aAdd(self:aExecAuto[1], {"F1_DESPESA", nDespesa} )
            EndIf

            cBkpFunName := funName()
            setFunName("LOJA720")

            self:bMsExecAuto := { || MsExecAuto( {|a,b,c,d,e,f,g,h,i,j,k,l,m,n,o| MATA103(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o) }, self:aExecAuto[1], self:aExecAuto[2], 3, /*lWhenGet*/, /*xAutoImp*/, /*xAutoAFN*/, /*xParamAuto*/, /*xRateioCC*/, /*lGravaAuto*/, /*xCodRSef*/, /*xCodRet*/, /*xAposEsp*/, /*xNatRend*/, /*xAutoPFS*/, /*xCompDKD*/) }

            self:loja720()

            setFunName(cBkpFunName)

            If self:lSuccess
                //Carrega select para retorno
                self:cIdRetaguardaNota := xFilial("SF1") + PadR(cNota, TamSx3("F1_DOC")[1]) + PadR(cSerie, TamSx3("F1_SERIE")[1])
            EndIf
        EndIf
    EndIf

Return Nil
//-------------------------------------------------------------------
/*/{Protheus.doc} execAddCli
Metodo para incluir o cliente enviado na devolução,
caso nao exista na base de dados.

@author  Everson S P Junior
@since   07/08/2023
@version 12.1.33
/*/
//-------------------------------------------------------------------
Method execAddCli() as Variant Class NotaEntradaObj

    Local aCliente      := {}                                           //Dados do cliente
    Local aErroAuto     := {}                                           //Guarda no array o retorno do ExecAuto
    Local nX            := 0                                            //Variavel de loop
    Local cErro         := ""                                           //Guarda o erro do ExecAuto
    Local cNome         := AllTrim( self:jParans["cliente"]["nome"] )
    Local aErrPontos    := {"< -- Invalido"}
    Local cErroAuto     := ""

    Private lMsErroAuto     := .F. //Variavel que informa a ocorrência de erros no ExecAuto
    Private lAutoErrNoFile 	:= .T. //força a gravação das informações de erro em array para manipulação da gravação ao invés de gravar direto no arquivo temporário

    Aadd(aCliente,{"A1_COD"     , MATI030Num()                                          , Nil})
    Aadd(aCliente,{"A1_LOJA"    , "01"                                                  , Nil})
    Aadd(aCliente,{"A1_NOME"    , cNome                                                 , Nil})
    Aadd(aCliente,{"A1_NREDUZ"  , SubStr(cNome, 1, Tamsx3("A1_NREDUZ")[1])              , Nil})
    Aadd(aCliente,{"A1_CGC"     , self:jParans["cliente"]["cpfCnpj"]                    , Nil})
    Aadd(aCliente,{"A1_DDD"     , ""                                                    , Nil})
    Aadd(aCliente,{"A1_TEL"     , ""                                                    , Nil})
    Aadd(aCliente,{"A1_TIPO"    , "F"                                                   , Nil})
    Aadd(aCliente,{"A1_PESSOA"  , ""                                                    , Nil})
    Aadd(aCliente,{"A1_END"     , self:jParans["cliente"]["endereco"]                   , Nil})
    Aadd(aCliente,{"A1_COMPLEM" , ""                                                    , Nil})
    Aadd(aCliente,{"A1_MUN"     , NOACENTO(UPPER(self:jParans["cliente"]["municipio"])) , Nil})
    Aadd(aCliente,{"A1_BAIRRO"  , ""                                                    , Nil})
    Aadd(aCliente,{"A1_EST"     , self:jParans["cliente"]["uf"]                         , Nil})
    Aadd(aCliente,{"A1_CEP"     , ""                                                    , Nil})
    Aadd(aCliente,{"A1_COD_MUN" , ""                                                    , Nil})
    Aadd(aCliente,{"A1_INSCR"   , "ISENTO"                                              , Nil})

    ljGrvLog("NOTAENTRADAOBJ", "Chamando a execauto CRMA980 para a inclusão do cliente.", aCliente)

    MsExecAuto( {|a,b| CRMA980(a,b)}, aCliente, 3)

    If lMsErroAuto
        RollBackSX8()   
        aErroAuto := GetAutoGrLog()

        ljxjMsgErr("Execauto CRMA980 retornou erro na inclusão do cliente pela api de nota de entrada.", /*cSolucao*/, "NOTAENTRADAOBJ", {aCliente, aErroAuto})

        //Tratar para pegar apenas a Linha que apresenta o campo com "< -- Invalido"
        For nX := 1 TO Len(aErroAuto)
            If aScan( aErrPontos, {|cTexto| upper(cTexto) $ upper(aErroAuto[nX])} ) > 0
                cErro += aErroAuto[nX] + Chr(10)
            EndIf
            cErroAuto += aErroAuto[nX] + CRLF
        Next nX

        cErro := IIF( empty(cErro), cErroAuto, cErro)

        self:lSuccess   := .F.
        self:cError     := STR0001 + " " + cErro    //Não foi possível realizar o cadastro do cliente para a devolução. Verifique possíveis campos obrigatório(s) ou inválido(s).
    Else
        ConfirmSX8()
    EndIf

return nil

//-------------------------------------------------------------------
/*/{Protheus.doc} loja720
Metodo responsavel por emular a chamado do LOJA720, assim dentro do fonte
MATA103 vai passar nos mesmos desvios do IsInCallStack("LOJA720")

@author  Rafael Tenorio da Costa
@since   15/05/2024
@version 12.1.2410
/*/
//-------------------------------------------------------------------
Method loja720() as Variant Class NotaEntradaObj

    ljGrvLog("NOTAENTRADAOBJ", "Chamando a execauto MATA103 pelo metodo LOJA720, para simular o mesmo tratamento do fonte LOJA720.", self:aExecAuto)
    _Super:execAuto()

Return nil
