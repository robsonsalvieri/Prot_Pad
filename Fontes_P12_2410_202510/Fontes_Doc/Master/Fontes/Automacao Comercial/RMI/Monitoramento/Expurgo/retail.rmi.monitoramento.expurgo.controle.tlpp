#INCLUDE "TOTVS.CH"
#INCLUDE "FWMVCDEF.CH"

namespace totvs.protheus.retail.rmi.monitoramento.expurgo.controle

Static cStFonte     := procSource()
Static dStExpAte
Static cStCadMIH    := "PSH"

//-------------------------------------------------------------------
/*/{Protheus.doc} processa
Rotina centralizadora que controla a execução do expurgo

@author  Rafael Tenorio da Costa
@version 12.1.25
/*/
//-------------------------------------------------------------------
Function processa(cEmpAmb, cFilAmb)

    Local cSemaforo := "expurgo_" + cEmpAmb

    rpcSetType(3)
    rpcSetEnv(cEmpAmb, cFilAmb, /*cEnvUser*/, /*cEnvPass*/, "LOJA", cSemaforo)

    //Trava a execução para evitar que mais de uma sessão faça a execução.
    if !lockByName(cSemaforo, .T./*lEmpresa*/, .F./*lFilial*/)
        rpcClearEnv()
        Return nil
    endIf

    if valida()

        ljxjMsgErr("Limpa base" + " - " + cSemaforo + " - " + time() + " - " + cValTochar( ThreadId() ), /*cSolucao*/, /*cRotina*/, {cEmpAnt, cFilAnt})

        deleta()

        grava(MODEL_OPERATION_UPDATE, dDataBase, /*nDiasHis*/)
    endIf

    unLockByName(cSemaforo, .T./*lEmpresa*/, .F./*lFilial*/)
    rpcClearEnv()

Return nil

//-------------------------------------------------------------------
/*/{Protheus.doc} valida
Valida e prepara a execução dos deletes

@author  Rafael Tenorio da Costa
@version 12.1.25
/*/
//-------------------------------------------------------------------
Static Function valida()

    Local lRetorno  := .T.
    Local dUltExp   := cToD("")
    Local nDiasHis  := ""

    MIG->( dbSetOrder(1) )  //MIG_FILIAL, MIG_TIPCAD, R_E_C_N_O_, D_E_L_E_T_
    if !MIG->( dbSeek( xFilial("MIG") + cStCadMIH) )
        lRetorno := ljCadAuxVd()
    endIf

    if lRetorno

        MIH->( dbSetOrder(1) )  //MIH_FILIAL, MIH_TIPCAD, MIH_ID, R_E_C_N_O_, D_E_L_E_T_
        if !MIH->( dbSeek( xFilial("MIH") + cStCadMIH) )

            lRetorno := grava(MODEL_OPERATION_INSERT, dDataBase - 31, 90)

            if lRetorno
                MIH->( dbSeek( xFilial("MIH") + cStCadMIH) )
            endIf
        endIf

        if lRetorno
            dUltExp   := stoD( strTran( ljCAuxRet("ultimoExpurgoRealizado"), "/", "") )
            nDiasHis  := ljCAuxRet("diasHistoricoExpurgo")
            dStExpAte := dDataBase - nDiasHis

            //Verifica se esta no mesmo mês
            if month(dUltExp) == month(dDataBase)
                lRetorno := .F.
            endIf
        endIf
    endIf

Return lRetorno

//-------------------------------------------------------------------
/*/{Protheus.doc} deleta
Centraliza a execução dos deletes

@author  Rafael Tenorio da Costa
@version 12.1.25
/*/
//-------------------------------------------------------------------
Static Function deleta()

    Local cDtExpAte := dToS(dStExpAte)
    Local cDtVazio  := space( tamSx3("MHQ_DATGER")[1] )
    Local cDelete   := ""
    Local cVenda    := padR("VENDA", tamSx3("MIP_CPROCE")[1])

    executaDelete(retSqlName("MHQ")  + " WHERE D_E_L_E_T_ = '*'")

    executaDelete(retSqlName("MHR")  + " WHERE D_E_L_E_T_ = '*'")

    executaDelete(retSqlName("MIP")  + " WHERE D_E_L_E_T_ = '*'")

    executaDelete(retSqlName("MHL")  + " WHERE D_E_L_E_T_ = '*'")

    executaDelete(retSqlName("MIK")  + " WHERE D_E_L_E_T_ = '*'")

    executaDelete(retSqlName("MHM")  + " WHERE D_E_L_E_T_ = '*'")

    executaDelete(retSqlName("MIH")  + " WHERE D_E_L_E_T_ = '*'")

    cDelete := retSqlName("MHQ")  + " WHERE D_E_L_E_T_ = ' ' AND MHQ_DATGER <> '" + cDtVazio + "' AND MHQ_DATGER < '" + cDtExpAte + "'"
    cDelete += " AND MHQ_STATUS NOT IN ('0', '1')"                                                                                                                                              //Envio pendente não deve ser excluído
    cDelete += " AND NOT EXISTS ( SELECT '' FROM " + retSqlName("MHR")  + " MHR WHERE MHR.D_E_L_E_T_ = ' ' AND MHR_STATUS = '1' AND MHR_UIDMHQ = MHQ_UUID )"                                    //Envio pendente não deve ser excluído
    cDelete += " AND NOT EXISTS ( SELECT '' FROM " + retSqlName("MIP")  + " MIP WHERE MIP.D_E_L_E_T_ = ' ' AND MIP_STATUS = '2' AND MIP_CPROCE <> '" + cVenda + "' AND MIP_UUID = MHQ_UUID )"   //Último registro enviado corretamente não deve ser excluído
    executaDelete(cDelete)

    cDelete := retSqlName("MHR")  + " WHERE D_E_L_E_T_ = ' ' AND MHR_DATPRO <> '" + cDtVazio + "' AND MHR_DATPRO < '" + cDtExpAte + "'"
    cDelete += " AND MHR_STATUS <> '1'"                                                                                                                                                         //Envio pendente não deve ser excluído
    cDelete += " AND NOT EXISTS ( SELECT '' FROM " + retSqlName("MIP")  + " MIP WHERE MIP.D_E_L_E_T_ = ' ' AND MIP_STATUS = '2' AND MIP_CPROCE <> '" + cVenda + "' AND MIP_UUID = MHR_UIDMHQ )" //Último registro enviado corretamente não deve ser excluído
    executaDelete(cDelete)

    cDelete := retSqlName("MIP")  + " WHERE D_E_L_E_T_ = ' ' AND MIP_DATGER <> '" + cDtVazio + "' AND MIP_DATGER < '" + cDtExpAte + "'"
    cDelete += " AND MIP_STATUS <> '1'"                                     //Envio pendente não deve ser excluído
    cDelete += " AND ( MIP_STATUS <> '2' OR MIP_CPROCE = '" + cVenda + "')" //Último registro enviado corretamente não deve ser excluído
    executaDelete(cDelete)

    executaDelete(retSqlName("MHL")  + " WHERE D_E_L_E_T_ = ' ' AND MHL_DATA <> '"   + cDtVazio + "' AND MHL_DATA < '"   + cDtExpAte + "'")

    executaDelete(retSqlName("MIK")  + " WHERE D_E_L_E_T_ = ' ' AND MIK_DTFECH <> '" + cDtVazio + "' AND MIK_DTFECH < '" + cDtExpAte + "'")

Return nil

//-------------------------------------------------------------------
/*/{Protheus.doc} executaDelete
Executa os deletes

@author  Rafael Tenorio da Costa
@version 12.1.25
/*/
//-------------------------------------------------------------------
Static Function executaDelete(cSql)

    Local cDelete := ""

    cDelete := " WHILE 1=1"
    cDelete += " BEGIN"
    cDelete +=      " DELETE TOP (100000) " + cSql + ";"
    cDelete +=      " IF @@ROWCOUNT = 0 BREAK;"
    cDelete += " END;"

    ljGrvLog(cStFonte, "Executando expurgo:", cDelete)

    IIF( tcSqlExec(cDelete) < 0, ljxjMsgErr("Não foi possível executar DELETE: " + tcSqlError(), /*Solucao*/, cStFonte), nil )

Return nil

//-------------------------------------------------------------------
/*/{Protheus.doc} grava
Efetuar as atualizações dos dados

@author  Rafael Tenorio da Costa
@version 12.1.25
/*/
//-------------------------------------------------------------------
Static Function grava(nOperacao, dUltExp, nDiasHis)

    Local oModel    := nil
    Local lRetorno  := .F.
    Local cErro     := ""

    Default nDiasHis := 0

    pshSetTCad(cStCadMIH)

    oModel := FwLoadModel("LjCadAux")

    oModel:SetOperation(nOperacao)
    oModel:Activate()
    
    oModel:loadValue( "MIHMASTER", "MIH_DESC"                , "CONFIGURACAO")
    oModel:loadValue( "MIHDETAIL", "ultimoExpurgoRealizado"  , dUltExp       )
    if nDiasHis > 0
        oModel:loadValue( "MIHDETAIL", "diasHistoricoExpurgo", nDiasHis      )
    endIf        
    
    lRetorno := oModel:vldData() .And. oModel:commitData()
    cErro    := oModel:GetErrorMessage()[6]

    oModel:DeActivate()
    
    oModel:Destroy()

    fwFreeObj(oModel)

    ljGrvLog(cStFonte, "Resultado da atualização da MIH do tipo cadastro PSH:", {lRetorno, cErro})

Return lRetorno