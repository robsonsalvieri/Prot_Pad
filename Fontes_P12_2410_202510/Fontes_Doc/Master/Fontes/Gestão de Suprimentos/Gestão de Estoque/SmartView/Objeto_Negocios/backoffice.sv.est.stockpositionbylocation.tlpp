#include "msobject.ch"
#include "protheus.ch"
#include "backoffice.sv.est.stockpositionbylocation.ch"
#include "totvs.framework.treports.integratedprovider.th"
#define SX1GRUPO "ESTT007"
//Namespace
namespace totvs.protheus.backoffice.est.stockpositionbylocation.integratedprovider
using namespace totvs.protheus.backoffice.est.smartView.integratedProvider
//Annotation

@totvsFrameworkTReportsIntegratedProvider(active=.T., team="SIGAEST", tables="SB1,SB8,SBF",name="Posição de Estoque por Endereço", country="ALL")


//--------------------------------------------------------------------
/*{Protheus.doc} StockPositionByLocationTreportsBusinessObject
Classe para criação do Objeto de Negócio da Posição de Estoque por Endereço"

@author Squad Entradas
@since 06/2023
@version 1.0
*/
//--------------------------------------------------------------------  
Class StockPositionByLocationTreportsBusinessObject From totvs.protheus.backoffice.est.smartView.integratedProvider.EstIntegratedProvider

	Public Method new() as object
	Public Method getData() as object

	Protected Method oNGetSchema()
	Protected data aFields	as array
	Protected data cWhere	as character
	Protected data jItems	as json
	Protected data lExistPergunte	as logical

EndClass

//-------------------------------------------------------------------
/*{Protheus.doc} new
Método de instância da classe

@return object: self
 
@author Squad Entradas
@since 06/2023
@version 1.0
*/
//-------------------------------------------------------------------   
Method new() Class StockPositionByLocationTreportsBusinessObject

	_Super:new()

	//Define a Área
	self:appendArea( STR0001 ) //"Estoque/Custos"

	//Define o nome do Objeto de Negócio
	self:setDisplayName( STR0002 ) //"Posição de Estoque por Endereço"

	//Define a descrição do Objeto de Negócio
	self:setDescription( STR0003 ) //"Neste objeto de negocio é possivel obter uma posição de estoque por produto/lote/endereco/status, permitindo o mapeamento por endereço."

	//Define o conjunto de perguntas e faz o teste se existe
	self:lExistPergunte := self:setPergunte( SX1GRUPO )
	If !self:lExistPergunte
		self:setErrorStatus(400,STR0006,i18n(STR0007,{SX1GRUPO}))//O Grupo de perguntas #1 não existe		
		FWLogMsg('WARN', , 'SmartView', , , , i18n(STR0007,{SX1GRUPO}), , , )//O Grupo de perguntas #1 não existe
	EndIf

	//Indica que o LookUp será do tipo padrão LookUp
    self:setIsLookUp(.T.)

Return self

//-------------------------------------------------------------------
/*{Protheus.doc} getData
Retorna os dados do objeto de negócio
 
@param nPage, numérico, indica a página atual do relatório
@param oFilter, objeto, contém o filtro do SmartView
 
@return object: self:oData
 
@author Squad Entradas
@since 06/2023
@version 1.0
*/
//-------------------------------------------------------------------   
Method getData( nPage as Numeric, oFilter as object) as object Class StockPositionByLocationTreportsBusinessObject
	local aSbf  		as Array	
	Local jParams		as Json
	Local dDtValid		as Date
	Local nQtdEmpe		as Numeric
	Local nTotBlock		as Numeric
	Local lSalNeg		as Logical
	Local lImpBlock		as Logical
	Local cQuery		as Character
	Local cFields		as Character
	Local cAliasTmp		as Character
	Local cMotDe 		as Character
	Local cMotAte 		as Character
	Local cFiltro 		as Character	
	Local cBkpFil       as Character 
	local cMD5		    as Character
	Local nFil          as Numeric 
	Local nBind         as Numeric
	local nPosPrepared  as numeric
	local aPrepared     as array
	local nX            as Numeric

	//Valida o pergunte
	If !self:lExistPergunte
		return self:oData
	Endif
	
	aPrepared := {}
	jParams   := oFilter:getParameters() //metodo para retorno do json dos parâmetros

    //Retorno da tela de multi filiais com as filiais selecionadas ou somente a filial corrente 
    self:aFils := self:retFils(jParams['SV_MULTBRANCH'],oFilter)

	cMotDe    := jParams[ 'MV_PAR07' ][1]
	cMotAte   := jParams[ 'MV_PAR08' ][1]
	lImpBlock := jParams[ 'MV_PAR09' ][1] == 1
	cFiltro   := " AND "
	cFields   := ""
	cFields   := StrTran(ArrTokStr(self:aFields),"|",",")
	cBkpFil   := cFilant 

	//Colocar while ou for de filiais aqui 
	For nFil :=1 to len(self:aFils)

		cFilAnt  := self:aFils[nFil]
		cFilExec := AllTrim(FWFilialName())
		lSalNeg  := SuperGetMv( 'MV_MT300NG' , .F., .F.) // Indica se permite saldo negativo (DEFAULT = .F.)
		nBind    := 1

		cQuery := " SELECT ? "//1	
		cQuery += ", SUM(SBF.BF_QUANT) BF_QUANT "
		cQuery += ", SUM(SBF.BF_EMPENHO) BF_EMPENHO "
		cQuery += " FROM " + RetSQLName( 'SBF' ) + " SBF "
		cQuery += " JOIN " + RetSQLName( 'SB1' ) + " SB1 "
		cQuery += " ON	SB1.B1_FILIAL = ? "//2
		cQuery += " 	AND SB1.B1_COD = BF_PRODUTO " 
		cQuery += " 	AND SB1.D_E_L_E_T_ = ? "//3
		cQuery += " LEFT JOIN " + RetSQLName( 'SB8' ) + " SB8 "
		cQuery += " ON SB8.B8_FILIAL = ? "//4
		cQuery += " 	AND SB8.B8_PRODUTO = BF_PRODUTO "
		cQuery += " 	AND SB8.B8_LOCAL   = BF_LOCAL "
		cQuery += " 	AND SB8.B8_NUMLOTE = BF_NUMLOTE "
		cQuery += " 	AND SB8.B8_LOTECTL = BF_LOTECTL "
		cQuery += " 	AND SB8.B8_SALDO <> ? "//5
		cQuery += " 	AND SB8.D_E_L_E_T_ = ? "//6
		cQuery += " LEFT JOIN " + RetSQLName( 'SBM' ) + " SBM "
		cQuery += " ON SBM.BM_FILIAL = ? "//7
		cQuery += " 	AND SBM.BM_GRUPO = B1_GRUPO "
		cQuery += " 	AND SBM.D_E_L_E_T_ = ? "//8
		cQuery += " WHERE SBF.BF_FILIAL = ? "//9
		cQuery += " AND SBF.BF_PRODUTO >= ? "//10
		cQuery += " AND SBF.BF_PRODUTO <= ? "//11
		cQuery += " AND SBF.BF_LOCAL >= ? " //12
		cQuery += " AND SBF.BF_LOCAL <= ? "//13
		cQuery += " AND SBF.BF_LOCALIZ >= ? "//14
		cQuery += " AND SBF.BF_LOCALIZ <= ? "//15
		
		If lSalNeg //-- Considera registros no SBF com saldo negativo
			cQuery += " AND SBF.BF_QUANT <> ? "//16
		Else //-- Considera somente registros no SBF que possuirem quantidade maior que zero
			cQuery += " AND SBF.BF_QUANT > ? "//16
		EndIf
		
		cQuery += " AND SBF.D_E_L_E_T_ = ? "//17

		//Os filtros serão setados na interface do novo TReports
		If !(oFilter:hasFilter())
			cFiltro := " "  
		Endif 
		
		//Internacionalização
		cQuery += self:cWhere
		cQuery += self:cWhereFiltroSV
		cQuery += " ? "//18
		
		cQuery += " GROUP BY ? "//19
		cQuery += " ORDER BY SBF.BF_FILIAL, SBF.BF_PRODUTO, SBF.BF_LOCAL, SBF.BF_LOTECTL, SBF.BF_NUMLOTE "
		cQuery := ChangeQuery(cQuery)

		cMD5 := MD5(cQuery)
		If (nPosPrepared := Ascan(aPrepared,{|x| x[2] == cMD5})) == 0
			cQuery := ChangeQuery(cQuery)
			Aadd(aPrepared,{FwExecStatement():New(cQuery),cMD5})
			nPosPrepared := Len(aPrepared)
		Endif

		//Binding
		aPrepared[nPosPrepared][1]:setUnsafe(nBind++,cFields)
		aPrepared[nPosPrepared][1]:setString(nBind++,FWxFilial( "SB1" ))
		aPrepared[nPosPrepared][1]:setString(nBind++,' ')
		aPrepared[nPosPrepared][1]:setString(nBind++,FWxFilial( "SB8" ))
		aPrepared[nPosPrepared][1]:setNumeric(nBind++,0)
		aPrepared[nPosPrepared][1]:setString(nBind++,' ')
		aPrepared[nPosPrepared][1]:setString(nBind++,FWxFilial( "SBM" ))
		aPrepared[nPosPrepared][1]:setString(nBind++,' ')
		aPrepared[nPosPrepared][1]:setString(nBind++,FWxFilial( "SBF" ))
		aPrepared[nPosPrepared][1]:setString(nBind++,jParams['MV_PAR01'][1])
		aPrepared[nPosPrepared][1]:setString(nBind++,jParams['MV_PAR02'][1])
		aPrepared[nPosPrepared][1]:setString(nBind++,jParams['MV_PAR03'][1])
		aPrepared[nPosPrepared][1]:setString(nBind++,jParams['MV_PAR04'][1])
		aPrepared[nPosPrepared][1]:setString(nBind++,jParams['MV_PAR05'][1])
		aPrepared[nPosPrepared][1]:setString(nBind++,jParams['MV_PAR06'][1])
		aPrepared[nPosPrepared][1]:setNumeric(nBind++,0)
		aPrepared[nPosPrepared][1]:setString(nBind++,' ')
		aPrepared[nPosPrepared][1]:setUnsafe(nBind++,cFiltro + oFilter:getSQLExpression())
		aPrepared[nPosPrepared][1]:setUnsafe(nBind++,cFields)	

		cAliasTmp := aPrepared[nPosPrepared][1]:OpenAlias()
		
		While !(cAliasTmp)->(Eof())

			//Bloqueados
			If lImpBlock 
				aSbf := {(cAliasTmp)->BF_LOCALIZ,(cAliasTmp)->BF_LOCAL,(cAliasTmp)->BF_PRODUTO,(cAliasTmp)->BF_LOTECTL,(cAliasTmp)->BF_NUMLOTE,(cAliasTmp)->BF_NUMSERI}
				nTotBlock := getBloq("SUM(DC_QUANT) DC_QUANT","SDD.DD_PRODUTO, SDC.DC_LOCALIZ, SDD.DD_MOTIVO, SDC.DC_QUANT",aSbf,cMotDe,cMotAte)			
			Else
				nTotBlock := 0
			EndIf

			//Lote
			dDtValid := getValid((cAliasTmp)->BF_PRODUTO,(cAliasTmp)->BF_LOCAL,(cAliasTmp)->BF_LOTECTL,(cAliasTmp)->BF_NUMLOTE)
			nQtdEmpe := (cAliasTmp)->BF_EMPENHO - nTotBlock

			self:jItems := JsonObject():New()
			self:jItems[ "BF_FILIAL" ] := (cAliasTmp)->BF_FILIAL
			self:jItems[ "BF_LOCAL"	 ] := (cAliasTmp)->BF_LOCAL
			self:jItems[ "BF_PRODUTO"] := (cAliasTmp)->BF_PRODUTO
			self:jItems[ "BF_LOCALIZ"] := (cAliasTmp)->BF_LOCALIZ
			self:jItems[ "BF_NUMSERI"] := (cAliasTmp)->BF_NUMSERI
			self:jItems[ "BF_LOTECTL"] := (cAliasTmp)->BF_LOTECTL
			self:jItems[ "BF_NUMLOTE"] := (cAliasTmp)->BF_NUMLOTE
			self:jItems[ "BF_QUANT"  ] := (cAliasTmp)->BF_QUANT
			self:jItems[ "BF_EMPENHO"] := (cAliasTmp)->BF_EMPENHO
			self:jItems[ "B1_DESC"	 ] := (cAliasTmp)->B1_DESC
			self:jItems[ "B1_UM"     ] := (cAliasTmp)->B1_UM
			self:jItems[ "B1_GRUPO"  ] := (cAliasTmp)->B1_GRUPO
			self:jItems[ "BM_DESC"   ] := (cAliasTmp)->BM_DESC
			if (dDtvalid <> CTOD(""))
				self:jItems[ "B8_DTVALID"] := totvs.framework.treports.date.dateToTimeStamp(dDtValid)
			EndIf
			self:jItems[ "BF_EMPENHO"] := nQtdEmpe
			self:jItems[ "DC_QUANT"	 ] := nTotBlock
			self:jItems[ "QtdDispo"	 ] := (cAliasTmp)->BF_QUANT - nQtdEmpe - nTotBlock

			self:processData()
			self:oData:appendData( self:jItems )

			(cAliasTmp)->(DBSkip())

		EndDo

		(cAliasTmp)->( DBCloseArea() )

	Next 

	cFilAnt := cBkpFil
	For nX := 1 To Len(aPrepared)
		aPrepared[nX][1]:Destroy()
	Next
	FWFreeArray(aPrepared)


Return self:oData

//-------------------------------------------------------------------
/*{Protheus.doc} getSchema
Retorna a estrutura dos campos
 
@return object: self:oSchema
 
@author Squad Entradas
@since 06/2023
@version 1.0
*/
//-------------------------------------------------------------------   
Method oNGetSchema() Class StockPositionByLocationTreportsBusinessObject
	//Estrutura
	self:aFields := {"BF_FILIAL","BF_LOCAL","BF_PRODUTO","BF_LOCALIZ","BF_NUMSERI","BF_LOTECTL","BF_NUMLOTE","B1_DESC","B1_UM","B1_GRUPO","BM_DESC"}
	self:aliasToSchema("SBF", {"BF_FILIAL","BF_LOCAL","BF_PRODUTO","BF_LOCALIZ","BF_NUMSERI","BF_LOTECTL","BF_NUMLOTE","BF_QUANT","BF_EMPENHO"} )	
	self:aliasToSchema("SB1", {"B1_DESC","B1_UM","B1_GRUPO"})
	self:aliasToSchema("SBM", "BM_DESC" )
	self:aliasToSchema("SB8", "B8_DTVALID" )	
	self:aliasToSchema("SDC", "DC_QUANT" )
	
	self:setPropDisplayName("DC_QUANT", STR0004 )//Bloqueado
	self:addProperty( "QtdDispo"	, STR0005	, "number"	, STR0005	, "QtdDispo"	) //"Disponível"

Return self:oSchema

/*/{Protheus.doc} getBloq
	Realiza a consulta das quantidades bloqueadas
	@type  Function
	@author Squad Entradas
	@param cFields, caracter, string com os campos a serem utilizados no SELECT
	@param cGroupBy, caracter, string com os campos a serem utilizados no agrupamento do SELECT
	@param aBind, array, array com os parametros para binding na query
	@return nRetorno, numerico, quantidade bloqueada
/*/
Static Function getBloq(cFields, cGroupBy,aBind,cMotde,cMotAte)
	Local cQuery		as Character
	local nRetorno		as Numeric
	Local oQuery2 

	cQuery := ""
	cQuery += " SELECT ? "//1
	cQuery += " FROM "+RETSQLNAME("SDC")+" SDC "
	cQuery += " INNER JOIN "+RETSQLNAME("SDD")+" SDD "
	cQuery += " ON SDD.DD_FILIAL    = ? "//2
	cQuery += " AND SDD.DD_PRODUTO  = SDC.DC_PRODUTO "
	cQuery += " AND SDD.DD_LOCAL    = SDC.DC_LOCAL "
	cQuery += " AND SDD.DD_LOTECTL  = SDC.DC_LOTECTL "
	cQuery += " AND SDD.DD_NUMLOTE  = SDC.DC_NUMLOTE "
	cQuery += " AND SDD.DD_IDSDD    = SDC.DC_IDSDD "
	cQuery += " AND (SDD.DD_LOCALIZ = ? OR SDD.DD_LOCALIZ = ? ) "//3 //4
	cQuery += " AND SDD.DD_MOTIVO  >= ? "//5
	cQuery += " AND SDD.DD_MOTIVO  <= ? "//6
	cQuery += " AND SDD.D_E_L_E_T_  = ? "//7
	cQuery += " WHERE "
	cQuery += " SDC.DC_FILIAL = ? "//8
	cQuery += " AND SDC.DC_PRODUTO = ? "//9
	cQuery += " AND SDC.DC_LOCAL   = ? "//10
	cQuery += " AND SDC.DC_LOTECTL = ? "//11
	cQuery += " AND SDC.DC_NUMLOTE = ? "//12
	cQuery += " AND SDC.DC_ORIGEM  = ? "//13
	cQuery += " AND SDC.DC_LOCALIZ = ? "//14
	cQuery += " AND SDC.DC_NUMSERI = ? "//15
	cQuery += " AND SDC.D_E_L_E_T_ = ? "//16
	cQuery += " GROUP BY ? "//17

	cQuery := ChangeQuery(cQuery)
	oQuery2 := FwExecStatement():New(cQuery)

	oQuery2:setUnsafe(1,cFields)
	oQuery2:setString(2,FWxFilial( "SDD" ))
	oQuery2:setString(3,aBind[1])
	oQuery2:setString(4,' ')
	oQuery2:setString(5,cMotDe)
	oQuery2:setString(6,cMotAte)	
	oQuery2:setString(7,' ')	
	oQuery2:setString(8,FWxFilial( "SDC" ))
	oQuery2:setString(9,aBind[3])
	oQuery2:setString(10,aBind[2])
	oQuery2:setString(11,aBind[4])
	oQuery2:setString(12,aBind[5])
	oQuery2:setString(13,'SDD')
	oQuery2:setString(14,aBind[1])
	oQuery2:setString(15,aBind[6])	
	oQuery2:setString(16,' ')	
	oQuery2:setUnsafe(17,cGroupBy)

	nRetorno := oQuery2:ExecScalar("DC_QUANT")
	oQuery2:Destroy()

Return nRetorno

/*/{Protheus.doc} getValid
	Traz a data de validade do lote
	@type  Function
	@author Squad Entradas
	@param cProduto, caracter, codigo do produto
	@param cLocal, caracter, codigo do armazem
	@param cLote, caracter, codigo do lote
	@param cNumlote, caracter, Codigo do sublote
	@return dRetorno, data, traz a data da validade
/*/
Static Function getValid(cProduto,cLocal,cLote,cNumlote)
	Local cQuery		as Character
	local dRetorno		as Date
	Local oQuery3 

	cQuery := " "
	cQuery += " SELECT B8_FILIAL, B8_PRODUTO, B8_LOCAL, B8_LOTECTL, B8_NUMLOTE, B8_DTVALID VALIDADE"
	cQuery += " FROM "+RetSQLName("SB8")+" SB8 "
	cQuery += " WHERE SB8.B8_FILIAL = ? "//1
	cQuery += " AND SB8.B8_PRODUTO = ? "//2
	cQuery += " AND SB8.B8_LOCAL = ? "//3
	cQuery += " AND SB8.B8_LOTECTL = ? "//4
	cQuery += " AND SB8.B8_NUMLOTE >= ? "//5
	cQuery += " AND SB8.B8_NUMLOTE <= ? "//6
	cQuery += " AND SB8.D_E_L_E_T_ = ? "//7	

	cQuery := ChangeQuery(cQuery)
	oQuery3 := FwExecStatement():New(cQuery)
	oQuery3:setString(1,cFilAnt)
	oQuery3:setString(2,cProduto)
	oQuery3:setString(3,cLocal)
	oQuery3:setString(4,cLote)
	oQuery3:setString(5,cNumlote)
	oQuery3:setString(6,cNumlote)	
	oQuery3:setString(7,' ')	
	
	dRetorno := STOD(oQuery3:ExecScalar("VALIDADE"))
	oQuery3:Destroy()

Return dRetorno
