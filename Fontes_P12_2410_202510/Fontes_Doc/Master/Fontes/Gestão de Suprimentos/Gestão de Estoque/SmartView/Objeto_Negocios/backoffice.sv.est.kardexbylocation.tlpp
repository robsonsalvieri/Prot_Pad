#include "totvs.ch"
#include "backoffice.sv.est.kardexbylocation.ch"
#include "totvs.framework.treports.integratedprovider.th"

#DEFINE SX1GRUPO "ESTT005"

using namespace totvs.protheus.backoffice.est.smartView.integratedProvider
namespace totvs.protheus.backoffice.est.kardexbylocation.integratedprovider

@totvsFrameworkTReportsIntegratedProvider(active=.T.,team="SIGAEST",tables="SB1,SB2,SBZ,SDB",name="Kardex por Endereço",country="ALL")

class KardexByLocationTReportsBusinessObject from totvs.protheus.backoffice.est.smartView.integratedProvider.EstIntegratedProvider
	
	Public Method new() as object
	Public Method getData() as object

	Protected Method oNGetSchema()
	Protected data cAlias as character
	Protected data cWhere as character
	Protected data jItens as json
	Protected data aFieldsSB1 as array
	Protected data aFieldsSB2 as array
	Protected data aFieldsSDB as array
	Protected data lExistPergunte as logical

endclass

/*/{Protheus.doc} New
Metodo de instancia da classe.
@type  Metodo
@author Squad Entradas
@since  Junho 01,2023
/*/
method new() class KardexByLocationTReportsBusinessObject

	_Super:new()

	//Define a Área
	self:appendArea(STR0001) // Estoque/Custos

	//Define o nome do Objeto de Negócio
	self:setDisplayName(STR0002) // Kardex por Endereço

	//Define a descrição do Objeto de Negócio
	self:setDescription( STR0003 ) // Emite um Kardex com todas as movimentações do estoque por endereço e número de série, diariamente.

	//Indica o pergunte que será utilizado no relatório
	self:lExistPergunte := self:SetPergunte(SX1GRUPO)
	If !self:lExistPergunte
		cMsgSX1 := OemToAnsi(I18N(STR0009,{SX1GRUPO})) //#Grupo de perguntas #1[SX1GRUPO]# nao encontrado. Verifique na tabela SX1, o grupo de perguntas informado
		self:setErrorStatus(400,STR0010,cMsgSX1)   	  //#Sem Pergunte
		FwLogMsg("WARN",, "SmartView ESTSV010",,,,cMsgSX1,,,)
	EndIf

	//Carrega os campos da SDB que farão parte do ON
	self:aFieldsSDB := FWSX3Util():GetAllFields("SDB",.F.)

	//Indica que o LookUp será do tipo padrão LookUp
	self:setIsLookUp(.T.)

return self

/*/{Protheus.doc} getData
Metodo que retorna o Objeto de dados.
@type  Metodo
@author Squad Entradas
@since  Junho 01,2023
/*/
method getData(nPage as numeric, oFilter as object) as object class KardexByLocationTReportsBusinessObject

	local dDataDe as date
	local dDataAte as date
	local oQuery as object
	local cQuery as character
	local nBind as Numeric
	
	local cFilExec as character
	local cEmpExec as character
	local cProd as character
	local cDesc as character
	local cLocal as character
	local cLocaliz as character
	local cLoteCtl as character
	local cNumLote as character
	local cNumSerie as character
	local cSeqDoc as character
	local cDadosProd := Upper(SuperGetMV("MV_ARQPROD",.F.,"SB1")) as character
	local cFields as character
	local cFieldsSB1 as character
	local nX as numeric
	local nSaldoIni as numeric
	local nEntrada as numeric
	local nSaida as numeric
	local jParams as json
	local lPrint as logical
	Local cFiltro as character
	Local nFil    as Numeric 
	Local cBkpFil as Character 

	//Variáveis com o nome da Filial e Grupo de Empresa
	cFilExec := AllTrim(FWFilialName())
	cEmpExec := AllTrim(FWEmpName(cEmpAnt))

	If !self:SetPergunte('ESTT005')
		Return self:oData
	ENDIF

	//Metodo para retorno do json dos parâmetros
	jParams := oFilter:getParameters()

    //Retorno da tela de multi filiais com as filiais selecionadas ou somente a filial corrente
    self:aFils := self:retFils(jParams['SV_MULTBRANCH'])

	//Define a quantidade máxima por página (Default 100)
	self:setPageSize(500)

	//Retorna o próximo Alias disponível
	self:cAlias:= GetNextAlias()

	nBind      := 1
	dDataDe    := FwDateTimeToLocal( jParams['MV_PAR13'][1] )[1]
	dDataAte   := FwDateTimeToLocal( jParams['MV_PAR14'][1] )[1]
	cFiltro    := " AND "
	If jParams['MV_PAR17'][1] == 2
		cSeqDoc := "SDB.DB_DOC"
	Else
		cSeqDoc := "SDB.DB_NUMSEQ"
	EndIf

	cFields := ArrTokStr(self:aFieldsSB1,",")
	cFieldsSB1 := cFields
	cFields += "," + ArrTokStr(self:aFieldsSB2,",") + ","
	cFields += ArrTokStr(self:aFieldsSDB,",")

	//Retorna o tipo do campos da SB1, SB2 e SDB convertidos para o Smart View
	self:aFieldsSB1 := estGetCpo(self:aFieldsSB1)
	self:aFieldsSB2 := estGetCpo(self:aFieldsSB2)
	self:aFieldsSDB := estGetCpo(self:aFieldsSDB)

	cQuery := " SELECT DISTINCT ? "

	cQuery += " FROM " + RetSqlName("SB2") + " SB2 "
	cQuery += " INNER JOIN " + RetSqlName("SB1") + " SB1 ON "
	cQuery += " ( SB1.B1_FILIAL = ? "
	cQuery += " AND SB2.B2_FILIAL = ? "
	cQuery += " AND SB1.B1_COD = SB2.B2_COD ) "

	cQuery += " LEFT OUTER JOIN " + RetSqlName("SBZ") + " SBZ ON "
	cQuery += " ( SBZ.BZ_FILIAL = ? "
	cQuery += " AND SB1.B1_FILIAL = ? "
	cQuery += " AND SBZ.BZ_COD = SB1.B1_COD "
	cQuery += " AND SBZ.D_E_L_E_T_ = ? ) " 

	cQuery += " LEFT JOIN " + RetSqlName("SDB") + " SDB ON "
	cQuery += " (SDB.DB_FILIAL = ? "
	cQuery += " AND SB2.B2_FILIAL = ? "
	cQuery += " AND SDB.DB_PRODUTO = SB2.B2_COD "
	cQuery += " AND SDB.DB_LOCAL = SB2.B2_LOCAL "
	cQuery += " AND SDB.DB_LOCALIZ >= ? "
	cQuery += " AND SDB.DB_LOCALIZ <= ? "
	cQuery += " AND SDB.DB_NUMSERI >= ? "
	cQuery += " AND SDB.DB_NUMSERI <= ? "
	cQuery += " AND SDB.DB_LOTECTL >= ? "
	cQuery += " AND SDB.DB_LOTECTL <= ? "
	cQuery += " AND SDB.DB_NUMLOTE >= ? "
	cQuery += " AND SDB.DB_NUMLOTE <= ? "
	cQuery += " AND SDB.DB_DATA >= ? "
	cQuery += " AND SDB.DB_DATA <= ? "
	If jParams['MV_PAR16'][1] == 2
		cQuery += " AND SDB.DB_ESTORNO = ? " 
	EndIf
	cQuery += " AND SDB.DB_ATUEST = ? " 
	cQuery += " AND SDB.D_E_L_E_T_ = ? ) " 
	cQuery += " WHERE "
	If cDadosProd == 'SB1'
		cQuery += " SB1.B1_LOCALIZ = ? "
	Else
		cQuery += " ( CASE WHEN( SBZ.BZ_LOCALIZ IS NOT NULL ) THEN( SBZ.BZ_LOCALIZ ) ELSE( SB1.B1_LOCALIZ ) END ) = ? "
	EndIf
	cQuery += " AND SB2.B2_LOCAL >= ? "
	cQuery += " AND SB2.B2_LOCAL <= ? "
	cQuery += " AND ( CASE WHEN( SBZ.BZ_COD IS NOT NULL ) THEN( SBZ.BZ_COD ) ELSE( SB1.B1_COD ) END ) >= ? "
	cQuery += " AND ( CASE WHEN( SBZ.BZ_COD IS NOT NULL ) THEN( SBZ.BZ_COD ) ELSE( SB1.B1_COD ) END ) <= ? "
	cQuery += " AND SB1.D_E_L_E_T_ = ? " 
	cQuery += " AND SB2.D_E_L_E_T_ = ? " 

	
	//Os filtros serão setados na interface do Smart View
	If !(oFilter:hasFilter())
		cFiltro := ""  
	Endif
	cQuery += " ? "
	cQuery += self:cWhere
	cQuery += "ORDER BY SB1.B1_COD,SDB.DB_LOCAL,SDB.DB_LOCALIZ,SDB.DB_NUMSERI,SDB.DB_LOTECTL,"
	cQuery += "SDB.DB_NUMLOTE,SDB.DB_DATA,?,SDB.DB_SERIE"

	oQuery := FwExecStatement():New(cQuery)

	cBkpFil := cFilant 

	//Colocar while ou for de filiais aqui 
	For nFil :=1 to len(self:aFils)

		cFilAnt  := self:aFils[nFil]
		cFilExec := AllTrim(FWFilialName())
		nEntrada := 0
		nSaida   := 0
		nBind    := 1

		oQuery:SetUnsafe(nBind++, cFields)
		oQuery:SetString(nBind++, FWxFilial("SB1"))
		oQuery:SetString(nBind++, FWxFilial("SB2"))
		oQuery:SetString(nBind++, FWxFilial("SBZ"))
		oQuery:SetString(nBind++, FWxFilial("SB1"))
		oQuery:SetString(nBind++, ' ')
		oQuery:SetString(nBind++, FWxFilial("SDB"))
		oQuery:SetString(nBind++, FWxFilial("SB2"))
		oQuery:SetString(nBind++, jParams['MV_PAR05'][1])
		oQuery:SetString(nBind++, jParams['MV_PAR06'][1])
		oQuery:SetString(nBind++, jParams['MV_PAR07'][1])
		oQuery:SetString(nBind++, jParams['MV_PAR08'][1])
		oQuery:SetString(nBind++, jParams['MV_PAR09'][1])
		oQuery:SetString(nBind++, jParams['MV_PAR10'][1])
		oQuery:SetString(nBind++, jParams['MV_PAR11'][1])
		oQuery:SetString(nBind++, jParams['MV_PAR12'][1])
		oQuery:SetString(nBind++, dtos(dDataDe))
		oQuery:SetString(nBind++, dtos(dDataAte))
		If jParams['MV_PAR16'][1] == 2
			oQuery:SetString(nBind++, ' ')
		endIf
		oQuery:SetString(nBind++, 'S')
		oQuery:SetString(nBind++, ' ')
		oQuery:SetString(nBind++, 'S')
		oQuery:SetString(nBind++, jParams['MV_PAR03'][1])
		oQuery:SetString(nBind++, jParams['MV_PAR04'][1])
		oQuery:SetString(nBind++, jParams["MV_PAR01"][1])
		oQuery:SetString(nBind++, jParams["MV_PAR02"][1])
		oQuery:SetString(nBind++, ' ')
		oQuery:SetString(nBind++, ' ')
		oQuery:setUnsafe(nBind++,cFiltro + oFilter:getSQLExpression())
		oQuery:setUnsafe(nBind++,cSeqDoc)

		oQuery:OpenAlias(self:cAlias)

		Do While !(self:cAlias)->(Eof())

			nSaldoIni:=nEntrada:=nSaida:=0

			If !Empty((self:cAlias)->DB_LOCAL) // Se DB_LOCAL vazio nao houve movimentacao no armazem
				nSaldoIni := CalcEstL((self:cAlias)->B1_COD,(self:cAlias)->DB_LOCAL,dDataDe,(self:cAlias)->DB_LOTECTL,(self:cAlias)->DB_NUMLOTE,(self:cAlias)->DB_LOCALIZ,(self:cAlias)->DB_NUMSERI)[1]
			Else
				nSaldoIni := CalcEst((self:cAlias)->B1_COD,(self:cAlias)->B2_LOCAL,dDataDe,,,)[1]
			EndIf

			If jParams['MV_PAR15'][1] == 2 .And. Empty((self:cAlias)->DB_DATA) .And. nSaldoIni == 0
				(self:cAlias)->(dbSkip())
				Loop
			EndIf

			cProd   := (self:cAlias)->DB_PRODUTO
			cDesc   := (self:cAlias)->B1_DESC
			If Empty((self:cAlias)->DB_LOCAL)
				cLocal := (self:cAlias)->B2_LOCAL
			Else
				cLocal := (self:cAlias)->DB_LOCAL
			EndIf
			cLocaliz := (self:cAlias)->DB_LOCALIZ
			cLoteCtl := (self:cAlias)->DB_LOTECTL
			cNumLote := (self:cAlias)->DB_NUMLOTE
			cNumSerie:= (self:cAlias)->DB_NUMSERI

			Do While !(self:cAlias)->(Eof()) .And. cProd+cLocal+cLocaliz+cNumSerie+cLoteCtl+cNumLote ==(self:cAlias)->DB_PRODUTO+If(Empty((self:cAlias)->DB_LOCAL),(self:cAlias)->B2_LOCAL,(self:cAlias)->DB_LOCAL)+(self:cAlias)->DB_LOCALIZ+(self:cAlias)->DB_NUMSERI+(self:cAlias)->DB_LOTECTL+(self:cAlias)->DB_NUMLOTE

				self:jItens := JsonObject():New()
				lPrint      := .T.

				If jParams['MV_PAR15'][1] == 2 .And. Empty((self:cAlias)->DB_DATA)
					(self:cAlias)->(dbSkip())
					Loop
				EndIf

				// Tratamento para apresentar produtos sem movimento no periodo
				If jParams['MV_PAR15'][1] == 1 .And. !((self:cAlias)->DB_DATA >= dtos(dDataDe) .And. (self:cAlias)->DB_DATA <= dtos(dDataAte))
					lPrint := retSldIni((self:cAlias)->B1_COD,(self:cAlias)->B1_DESC,(self:cAlias)->B2_LOCAL,jParams,dDataDe,@self,cEmpExec,cFilExec,self:aFieldsSB1,cFieldsSB1)
				EndIf

				If lPrint
					If (self:cAlias)->DB_TM <= "500" .Or. Substr((self:cAlias)->DB_TM,1,1) $ "PD"
						nEntrada += (self:cAlias)->DB_QUANT
						self:jItens["NENTRADA"] := (self:cAlias)->DB_QUANT
					Else
						nSaida += (self:cAlias)->DB_QUANT
						self:jItens["NSAIDA"] := (self:cAlias)->DB_QUANT
					EndIf

					For nX := 1 To Len(self:aFieldsSB1)
						self:jItens[self:aFieldsSB1[nX][1]] := (self:cAlias)->&(self:aFieldsSB1[nX][1])
					Next nX

					For nX := 1 To Len(self:aFieldsSB2)
						self:jItens[self:aFieldsSB2[nX][1]] := (self:cAlias)->&(self:aFieldsSB2[nX][1])
					Next nX

					For nX := 1 To Len(self:aFieldsSDB)
						If self:aFieldsSDB[nX][2] == "date"
							If !Empty( (self:cAlias)->&(self:aFieldsSDB[nX][1]) )
								self:jItens[self:aFieldsSDB[nX][1]] := totvs.framework.treports.date.dateToTimeStamp(StoD((self:cAlias)->&(self:aFieldsSDB[nX][1])))
							EndIf
						Else
							self:jItens[self:aFieldsSDB[nX][1]] := (self:cAlias)->&(self:aFieldsSDB[nX][1])
						EndIf
					Next nX

					self:jItens["NSALDOINI"] := nSaldoIni
					self:jItens["EMPNOME"]   := cEmpExec
					self:jItens["FILNOME"]   := cFilExec

					self:processData()
					self:appendData(self:jItens)
				EndIf

				(self:cAlias)->(dbSkip())
			EndDo

		EndDo

		(self:cAlias)->( DBCloseArea() )

	Next 

	cFilAnt := cBkpFil
	oQuery:Destroy()

return self:oData

/*/{Protheus.doc} getSchema
Metodo que retorna a Estrutura de dados.
@type  Metodo
@author Squad Entradas
@since  Junho 01,2023
/*/
method oNGetSchema() class KardexByLocationTReportsBusinessObject

	self:aFieldsSB1 := {"B1_FILIAL","B1_COD","B1_DESC","B1_UM","B1_TIPO","B1_GRUPO"}
	self:aFieldsSB2 := {"B2_LOCAL"}

	self:AliasToSchema("SB1",self:aFieldsSB1)
	self:AliasToSchema("SB2",self:aFieldsSB2)
	self:AliasToSchema("SDB",self:aFieldsSDB)

	self:oSchema:addProperty("EMPNOME"  , STR0004, "string", STR0004, "EMPNOME")
	self:oSchema:addProperty("FILNOME"  , STR0005, "string", STR0005, "FILNOME")
	self:oSchema:addProperty("NSALDOINI", STR0006, "number", STR0006, "NSALDOINI")
	self:oSchema:addProperty("NENTRADA" , STR0007, "number", STR0007, "NENTRADA")
	self:oSchema:addProperty("NSAIDA"   , STR0008, "number", STR0008, "NSAIDA")

return

/*/{Protheus.doc} retSldIni
Grava o saldo inicial do armazem caso nao exista movimentos
@type  Função
@author Squad Entradas
@since  Junho 15,2023
/*/
Static Function retSldIni(cProduto as character,cDesc as character,cLocal as character,jParams as json,dDataDe as date,self as object,cEmpExec as character,cFilExec as character,aFieldsSB1 as array,cFieldsSB1 as character)
	local oQuery2 as object
	local nX as numeric
	local nSldIni as numeric
	local cQuery as character
	local lPrint := .T. as logical
	local cAliSld := GetNextAlias() as character
	local jItens as json

	cQuery := "SELECT DISTINCT SDB.DB_PRODUTO,SDB.DB_LOCAL,SDB.DB_LOCALIZ,SDB.DB_LOTECTL,SDB.DB_NUMLOTE, ? "
	cQuery += "FROM "+RetSqlName("SDB") +" SDB "
	cQuery += "INNER JOIN "+RetSqlName("SB1")+" SB1 ON "
	cQuery += "( SB1.B1_FILIAL = ? AND "
	cQuery += "SDB.DB_FILIAL = ? AND "
	cQuery += "SB1.B1_COD = SDB.DB_PRODUTO ) "
	cQuery += "WHERE SDB.DB_PRODUTO = ? "
	cQuery += "AND SDB.DB_LOCAL = ? "
	cQuery += "AND SDB.DB_ESTORNO = ? "
	cQuery += "AND SB1.D_E_L_E_T_ = ? " 
	cQuery += "AND SDB.D_E_L_E_T_ = ? " 
	cQuery += "ORDER BY 1,2,3,4"

	oQuery2 := FwExecStatement():New(cQuery)

	oQuery2:SetUnsafe(1,cFieldsSB1)
	oQuery2:SetString(2,FWxFilial('SB1'))
	oQuery2:SetString(3,FWxFilial('SDB'))
	oQuery2:SetString(4,cProduto)
	oQuery2:SetString(5,cLocal)
	oQuery2:SetString(6,' ')
	oQuery2:SetString(7,' ')
	oQuery2:SetString(8,' ')

	oQuery2:OpenAlias(cAliSld)

	While !(cAliSld)->(Eof())
		lPrint  := .F.
		nSldIni := CalcEstL(cProduto,cLocal,dDataDe,(cAliSld)->DB_LOTECTL,(cAliSld)->DB_NUMLOTE,(cAliSld)->DB_LOCALIZ)[1]

		If nSldIni > 0
			jItens := JsonObject():New()

			For nX := 1 To Len(aFieldsSB1)
				jItens[aFieldsSB1[nX][1]] := (cAliSld)->&(aFieldsSB1[nX][1])
			Next nX

			jItens["DB_LOCAL"  ] := cLocal
			jItens["DB_LOCALIZ"] := (cAliSld)->DB_LOCALIZ
			jItens["DB_LOTECTL"] := (cAliSld)->DB_LOTECTL
			jItens["DB_NUMLOTE"] := (cAliSld)->DB_NUMLOTE
			jItens["NSALDOINI" ] := nSldIni
			jItens["EMPNOME"]    := cEmpExec
			jItens["FILNOME"]    := cFilExec

			self:appendData(jItens)
		EndIf
		(cAliSld)->(dbSkip())
	EndDo
	(cAliSld)->(DbCloseArea())

	oQuery2:Destroy()

Return lPrint

/*/{Protheus.doc} estGetCpo
Prepara a estrutura dos campos
@type  Função
@author Squad Entradas
@since  Maio 16,2023
/*/
Static Function estGetCpo(aFields as array)
	local aDeParaCpo as array
	local aCpoTmp := {} as array
	local cTipR as character
	local cTipo as character
	local nPos as numeric
	local nX as numeric

	aDeParaCpo := {{"C", "string"}, {"D", "date"}, {"N", "number"}, {"L", "boolean"}}

	For nX := 1 To Len(aFields)
		cTipo := FWSX3Util():GetFieldType( aFields[nX] )

		If (nPos := aScan( aDeParaCpo, {|c| c[01] = cTipo } ) ) > 0
			cTipR := aDeParaCpo[nPos, 02]
		EndIf

		AAdd( aCpoTmp,;
			{aFields[nX],;
			cTipR})
	Next nX

Return (aCpoTmp)
