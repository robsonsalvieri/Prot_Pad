#include "msobject.ch"
#include "protheus.ch"
#include "backoffice.sv.est.MoveRecursion.ch"
#include "totvs.framework.treports.integratedprovider.th"

#DEFINE SX1GRUPO "ESTT030"

namespace totvs.protheus.backoffice.est.moverecursion.integratedprovider
using namespace totvs.protheus.backoffice.est.smartView.integratedProvider

@totvsFrameworkTReportsIntegratedProvider(active=.T., team="SIGAEST", tables="SB1,SD3",name="Recursividade Por Movimentação", country="ALL")

//--------------------------------------------------------------------
/*{Protheus.doc} MoveRecursionSmartViewBusinessObject
Classe para criação do Objeto de Negócio de Prodotos   
 
@author Michel Sander
@since 	11/2023
@version 1.0
*/
//--------------------------------------------------------------------  
Class MoveRecursionSmartViewBusinessObject From totvs.protheus.backoffice.est.smartView.integratedProvider.EstIntegratedProvider

	Public Method new() as object
	Public Method getData() as object

	Protected Method oNGetSchema()

	Protected data aFields as array
	Protected data jItems  as json
	Protected data cWhere  as character
	Protected data lExistPergunte as Logical
	Protected data cAlias  as character 
	Protected data cTabInsert  as character 
	Protected data aFieldsQry as array

EndClass

//-------------------------------------------------------------------
/*{Protheus.doc} new
Método de instância da classe
 
@return object: self
 
@author Michel Sander
@since  11/2023
@version 1.0
*/
//-------------------------------------------------------------------   
Method new() Class MoveRecursionSmartViewBusinessObject

	LOCAL cMsgSX1 := ""

	_Super:new()

	//Define a Área
	self:appendArea( STR0001 ) 					//#Estoque Custos

	//Define o nome do Objeto de Negócio
	self:setDisplayName( STR0002 )				//#Recursividade Por Movimentação

	//Define a descrição do Objeto de Negócio
	self:setDescription( STR0003 )				//#Visão de dados para demonstração da recursividade por movimentação de estoque

	//Grupo de Perguntas
	self:lExistPergunte := self:SetPergunte(SX1GRUPO)
	If !self:lExistPergunte
		cMsgSX1 := OemToAnsi(I18N(STR0004,{SX1GRUPO})) //#Grupo de perguntas #1[SX1GRUPO]# nao encontrado. Verifique na tabela SX1, o grupo de perguntas informado
		self:setErrorStatus(400,STR0005,cMsgSX1)		//#Sem Pergunte
		FwLogMsg("WARN",, "SmartView ESTSV030",,,,cMsgSX1,,,)
	EndIf

	self:aFields := {}

Return self

//-------------------------------------------------------------------
/*{Protheus.doc} getData
Retorna os dados do objeto de negócio
 
@param nPage, numérico, indica a página atual do relatório
@param oFilter, objeto, contém o filtro do TReports
 
@return object: self:oData
 
@author Michel Sander
@since 11/2023
@version 1.0
*/
//-------------------------------------------------------------------   
Method getData( nPage as Numeric, oFilter as object) as object Class MoveRecursionSmartViewBusinessObject

	Local oQuery     as Object
	Local cQuery	 as Character
	Local cBkpFil	 as Character
	Local nX		 as Numeric
	Local nFil		 as Numeric
	Local jParams	 as Json
	Local dDataIni   as Date
	Local dDataFin   as Date
	Local cAliasSD3  as Character
	Local cArqTemp	 as Character
	Local cOpVazia	 as Character
	Local cProdMNT   as Character
	Local aArqTemp	 as Array
	Local nRegSD3	 as Numeric
	Local aListaReg	 as Array
	Local lRet		 as Logical
	Local cFields    as character

	If !self:lExistPergunte
		Return self:oData
	EndIf

	cArqTemp  := ""
	cAliasSD3 := GetNextAlias()
	cOpVazia  := Criavar("D3_OP",.F.)
	aArqTemp  := {}
	nRegSD3   := 0
	aListaReg := {}
	lRet	  := .T.

	jParams   := oFilter:getParameters() //metodo para retorno do json dos parâmetros
	dDataIni  := FwDateTimeToLocal( jParams['MV_PAR01'][1] )[1]
	dDataFin  := FwDateTimeToLocal( jParams['MV_PAR02'][1] )[1]

    //Retorno da tela de multi filiais com as filiais selecionadas ou somente a filial corrente
    self:aFils := self:retFils(jParams['SV_MULTBRANCH'], oFilter)

	// Montagem do arquivo de trabalho
	Aadd(aArqTemp,{"CODIGO"		, TamSx3( 'B1_COD' )[ 03 ]		, TamSx3( 'B1_COD' )[ 01 ]		, TamSx3( 'B1_COD' )[ 02 ] } )
	Aadd(aArqTemp,{"COMPONENTE"	, TamSx3( 'B1_COD' )[ 03 ]		, TamSx3( 'B1_COD' )[ 01 ]		, TamSx3( 'B1_COD' )[ 02 ] } )
	Aadd(aArqTemp,{"OP"			, TamSx3( 'D3_OP' )[ 03 ]		, TamSx3( 'D3_OP' )[ 01 ] 		, TamSx3( 'D3_OP' )[ 02 ] } )
	Aadd(aArqTemp,{"ARMAZEM"	, TamSx3( 'D3_LOCAL' )[ 03 ]	, TamSx3( 'D3_LOCAL' )[ 01 ]	, TamSx3( 'D3_LOCAL' )[ 02 ] } )
	Aadd(aArqTemp,{"MOVIMENTO"	, TamSx3( 'D3_TM' )[ 03 ]		, TamSx3( 'D3_TM' )[ 01 ]		, TamSx3( 'D3_TM' )[ 02 ] } )
	Aadd(aArqTemp,{"EMISSAO"	, TamSx3( 'D3_EMISSAO' )[ 03 ]	, TamSx3( 'D3_EMISSAO' )[ 01 ]	, TamSx3( 'D3_EMISSAO' )[ 02 ] } )
	Aadd(aArqTemp,{"DOCUMENTO"	, TamSx3( 'D3_DOC' )[ 03 ]		, TamSx3( 'D3_DOC' )[ 01 ]		, TamSx3( 'D3_DOC' )[ 02 ] } )
	Aadd(aArqTemp,{"REGISTRO"	, "N", 20, 00 } )
	Aadd(aArqTemp,{"G1NIVEL"	, "C", 02, 00 } )
	Aadd(aArqTemp,{"G1NIVINV"	, "C", 02, 00 } )

	cArqTemp   := GetNextAlias()
	oTempTable := FWTemporaryTable():New( cArqTemp )
	oTempTable:SetFields( aArqTemp )
	oTempTable:AddIndex("indice1", {"CODIGO","COMPONENTE","OP"} )
	oTempTable:Create()
	Self:cTabInsert := oTempTable:GetRealName()

    //Emddebed SQL
	self:cAlias 	:= GetNextAlias()
	cFields		 	:= "D3_OP, C2_PRODUTO, D3_COD, D3_TM, D3_LOCAL, D3_EMISSAO,  MIN( D3_DOC ) DOC, MIN( SD3.R_E_C_N_O_ ) REG,  '01' G1NIVEL, '99' G1NIVINV "

	cQuery := " SELECT DISTINCT ? "
	cQuery += " FROM "+ RetSQLName( 'SD3' ) +" SD3 "
	cQuery += " 	INNER JOIN "+ RetSQLName( 'SC2' ) +" SC2 "
	cQuery += " 	 ON  C2_FILIAL = ? "
	cQuery += "      AND C2_NUM || C2_ITEM || C2_SEQUEN = D3_OP "
	cQuery += " 	 AND SC2.D_E_L_E_T_ = ? "
	cQuery += " WHERE       D3_FILIAL = ? "
	cQuery += "         AND D3_EMISSAO >= ? "
	cQuery += "         AND D3_EMISSAO <= ? "
	cQuery += " 		AND D3_OP <> ? "
	cQuery += " 		AND D3_COD <> ? "
	cQuery += " 		AND D3_CF NOT IN (?) "
	cQuery += " 		AND D3_ESTORNO <> ? "

	//Os filtros serão setados na interface do Smart View
	cQuery += self:cWhereFiltroSV

	//Internacionalização
	cQuery += self:cWhere

	cQuery += " 		AND SD3.D_E_L_E_T_ = ? "
	cQuery += " GROUP BY D3_OP, C2_PRODUTO, D3_COD, D3_TM, D3_LOCAL, D3_EMISSAO "
	cQuery := ChangeQuery( cQuery )

    oQuery := FwExecStatement():New(cQuery)
	
	cBkpFil := cFilAnt

	For nFil :=1 to len(self:aFils)
		cFilAnt := self:aFils[nFil]

		cProdMNT  := SuperGetMv("MV_PRODMNT",.F.,"MANUTENCAO")

		//Binding
		oQuery:SetUnsafe(1,  cFields)
		oQuery:SetString(2,  FWxFilial('SC2'))
		oQuery:SetString(3, ' ')
		oQuery:SetString(4,  FWxFilial('SD3'))
		oQuery:SetString(5,  Dtos(dDataIni))
		oQuery:SetString(6,  Dtos(dDataFin))
		oQuery:SetString(7,  cOpVazia)
		oQuery:SetString(8,  cProdMNT)
		oQuery:SetIn(9,	{'PR0','PR1'})
		oQuery:SetString(10, "S")
		oQuery:SetString(11, ' ')
		oQuery:OpenAlias(self:cAlias)

		//Popula tabela temporária
		cQuery 	 := " INSERT INTO " + Self:cTabInsert
		cQuery 	 +=  " ( OP, CODIGO, COMPONENTE, MOVIMENTO, ARMAZEM, EMISSAO, DOCUMENTO, REGISTRO, G1NIVEL, G1NIVINV ) "
		cQuery   += oQuery:GetFixQuery()
		cQuery   += " ORDER BY D3_OP, D3_COD, D3_EMISSAO "

		// Popula arquivo temporário
		nRet := TCSQLExec(cQuery)

		FwLogMsg("WARN",, "SmartView ESTSV030",,, , TcSQLError(), , ,)

		dbSelectArea(cArqTemp)
		(cArqTemp)->(dbGotop())
		While !(cArqTemp)->(Eof())

			// Checa recursividade
			IF G1NIVEL == "01"

				aListaReg := {}
				lRet      := FRecursiva( ( cArqTemp )->COMPONENTE, ( cArqTemp )->G1NIVEL, cArqTemp, aListaReg )

				IF !lRet

					nRegSD3 := ( cArqTemp )->( Recno() )
					For nX := 1 To Len( aListaReg )

						self:jItems := JsonObject():New()

						// Posiciona o registro
						( cArqTemp )->( dbGoto( aListaReg[ nX ] ) )
						SB1->(dbSeek(xFilial()+(cArqTemp)->COMPONENTE))
						self:jItems["FILIAL"]	  := cFilAnt
						self:jItems["D3_COD"]     := SB1->B1_COD
						self:jItems["B1_DESCCOM"] := SB1->B1_DESC
						self:jItems["D3_UM"]      := SB1->B1_UM
						self:jItems["D3_LOCAL"]   := ( cArqTemp )->ARMAZEM
						
						NNR->(dbSeek(xFilial()+( cArqTemp )->ARMAZEM))
						self:jItems["NNR_DESCRI"] := NNR->NNR_DESCRI
						
						self:jItems["D3_TM"]      := ( cArqTemp )->MOVIMENTO
						self:jItems["D3_DOC"]     := ( cArqTemp )->DOCUMENTO
						self:jItems["D3_EMISSAO"] := totvs.framework.treports.date.dateToTimeStamp((cArqTemp)->EMISSAO)	
						self:jItems["D3_OP"]      := ( cArqTemp )->OP

						SB1->(dbSeek(xFilial()+( cArqTemp )->CODIGO))
						self:jItems["C2_PRODUTO"] := SB1->B1_COD
						self:jItems["B1_DESCPAI"] := SB1->B1_DESC

						self:processData()
						self:oData:appendData(self:jItems)
					Next nX

					(cArqTemp)->(dbGoto( nRegSD3 ))
				Endif
			EndIf
			(cArqTemp)->(DBSkip())
		EndDo

		//Limpa tabela temporaria
		oTempTable:Zap()

		(self:cAlias)->(dbCloseArea())
	Next

	(cArqTemp)->(DBCloseArea())

	cFilAnt := cBkpFil

	oQuery:Destroy()
	oTempTable:Delete()
	
Return self:oData

//-------------------------------------------------------------------
/*{Protheus.doc} oNGetSchema
Retorna a estrutura dos campos
 
@return object: self:oSchema
 
@author Michel Sander
@since 11/2023
@version 1.0
*/
//-------------------------------------------------------------------   
Method oNGetSchema() Class MoveRecursionSmartViewBusinessObject

	Local aStrSD3    as Array
	Local aStrSB1    as Array
	Local aStrSC2    as Array
	Local nC         as Numeric
	Local nPosDescr  as Numeric
	Local aFieldsSD3 as Array
	Local aFieldsSC2 as Array
	Local aFieldsNNR as Array

	aStrSD3 := SD3->( DBStruct() )
	aStrSB1 := SB1->( DBStruct() )
	aStrSC2 := SC2->( DBStruct() )
	aStrNNR := NNR->( DBStruct() )

	
	For nC := 1 To Len( aStrSD3 )
		If aStrSD3[ nC , 02 ] != "M" .And. (Alltrim( aStrSD3[ nC , 01 ] ) $ "D3_COD|D3_LOCAL|D3_UM|D3_EMISSAO|D3_TM|D3_OP|D3_DOC")
			aAdd( self:aFields , { Alltrim( aStrSD3[ nC , 01 ] ) , aStrSD3[ nC , 02 ] } )
			If Alltrim( aStrSD3[ nC , 01 ]) == "D3_COD"
				nPosDescr := ASCAN(aStrSB1, { |x| AllTrim(x[1])=="B1_DESC"})
				If nPosDescr > 0
					aAdd( self:aFields , { "B1_DESCCOM", aStrSB1[ nPosDescr , 02 ] } )
				EndIf
			EndIf
		EndIf
	Next nC

	For nC := 1 To Len( aStrSC2 )
		If aStrSC2[ nC , 02 ] != "M" .And. (Alltrim( aStrSC2[ nC , 01 ] ) == "C2_PRODUTO")
			aAdd( self:aFields , { Alltrim( aStrSC2[ nC , 01 ] ) , aStrSC2[ nC , 02 ] } )
			nPosDescr := ASCAN(aStrSB1, { |x| AllTrim(x[1])=="B1_DESC"})
			If nPosDescr > 0
				aAdd( self:aFields , { "B1_DESCPAI", aStrSB1[ nPosDescr , 02 ] } )
			EndIf
		EndIf
	Next nC

	For nC := 1 To Len( aStrNNR )
		If aStrNNR[ nC , 02 ] != "M" .And. (Alltrim( aStrNNR[ nC , 01 ] ) == "NNR_DESCRI")
			aAdd( self:aFields , { Alltrim( aStrNNR[ nC , 01 ] ) , aStrNNR[ nC , 02 ] } )
		EndIf
	Next nC

	self:addProperty( "FILIAL" , STR0008 , "string" , STR0008 , "FILIAL"	) //"Filial"

	aFieldsSD3 := {"D3_OP", "D3_COD","D3_LOCAL", "D3_UM", "D3_EMISSAO", "D3_TM", "D3_DOC"}
	aFieldsSC2 := {"C2_PRODUTO"}
	aFieldsNNR := {"NNR_DESCRI"}

	self:AliasToSchema("SD3",aFieldsSD3)
	self:AliasToSchema("SC2",aFieldsSC2)
	self:AliasToSchema("NNR",aFieldsNNR)

	self:addProperty("B1_DESCPAI"    , STR0006, "string", STR0006, "B1_DESCPAI")
	self:addProperty("B1_DESCCOM"    , STR0007, "string", STR0007, "B1_DESCCOM")

Return

//-------------------------------------------------------------------
/*{Protheus.doc} FRecursiva
Retorna a recursividade do apontamento de produção
 
@return lRet
@author Michel Sander
@since 11/2023
@version 1.0
*/
//-------------------------------------------------------------------   
Static Function FRecursiva(cComp,cNivel,cAliasPr,aListaReg)

	Local nRec   := (cAliasPr)->(Recno())
	Local nSalRec:= 0
	Local lRet   := .T.
	Local lEof   := .F.
	Local nAcho  := 0
	Local cSeek  := ""

	dbSelectArea( cAliasPr )
	dbSetOrder( 1 )

	If (cAliasPR)->(dbSeek(cComp))

		While (cAliasPR)->(!Eof()) .and. cComp==(cAliasPr)->CODIGO

			nSalRec:=(cAliasPR)->(Recno())
			cSeek  := (cAliasPR)->COMPONENTE
			(cAliasPR)->(dbSeek(cSeek))
			lEof := (cAliasPR)->(Eof())
			(cAliasPR)->(dbGoto(nSalRec))

			IF Val(cNivel) >= 98  // Testa Erro de estrutura
				lRet := .F.
			Endif

			If Val(cNivel)+1 > Val((cAliasPr)->G1NIVEL) .and. lRet
				RecLock((cAliasPr),.F.)
				(cAliasPr)->G1NIVEL  := Strzero(Val(cNivel)+1,2)
				(cAliasPR)->G1NIVINV := Strzero(100-Val((cAliasPr)->G1NIVEL),2,0)
				(cAliasPR)->(MsUnLock())
				If !lEof
					lRet := FRecursiva((cAliasPR)->COMPONENTE,(cAliasPR)->G1NIVEL,cAliasPr,aListaReg)
				Endif
			Endif

			IF !lRet
				IF Val(cNivel) < 98  // Houve erro (no nivel posterior)
					nAcho  := ASCAN(aListaReg,nSalRec)
					// Adiciona, na lista, o registro que originou o erro
					If nAcho == 0
						AADD(aListaReg,nSalRec)
					EndIf
				EndIf
				Exit
			Endif

			(cAliasPR)->(dbSkip())

		End

	EndIf

	(cAliasPr)->(dbGoto(nRec))

Return ( lRet )
