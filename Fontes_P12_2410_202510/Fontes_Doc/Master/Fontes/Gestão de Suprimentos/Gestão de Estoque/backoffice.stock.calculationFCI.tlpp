#include "protheus.ch"
#include "backoffice.stock.calculationFCI.ch"

namespace backoffice.stock.calculationFCI

#define F_SD1  1
#define F_SD2  2
#define F_SD3  3
#define F_SA8  4
#define F_CFD  5
#define F_SF4  6
#define F_SB1  7
#define F_SWN  8

static __aSetFieldsQry := NIL

/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  |FciMedEnt  ºAutor  ³Anieli Rodrigues   º Data ³  03/09/13   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDescricao ³Grava a media do valor importado para os produtos comprados º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³ExpA1: cMes     - Mes a ser calculado                       º±±
±±º          ³ExpA2: cAno	  - Ano a ser calculado                        º±±
±±º          ³ExpA3: cProdDe  - Range de produtos                         º±±
±±º          ³ExpA4: cProdAte - Range de produtos                         º±±
±±º          ³ExpA5: nQtdMes  - Indica o quantidade de meses que deve ser º±±
±±º          ³                  subtraida do mes base para busca da nota  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       |FCIXFUN                                                     º±±
±±º          |FISA061 - Materiais                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function FciMedEnt(cMes,cAno,cProdDe,cProdAte, nQtdMes)

Local aAreaSA8   := SA8->(GetArea())
Local cQuery     := ""
Local cAliasQry1 as character
Local oTmpNFE
Local oTotNFEs
Local lNovoRegistro as logical
local aStruct as array

oTmpNFE := FWTemporaryTable():New()

FCIPurchasedProducts(oTmpNFE, cMes, cAno, cProdDe, cProdAte, cNomSD1)

cQuery := "SELECT D1_COD, "
cQuery += " SUM(QUANTIDADE) QUANTIDADE, sum(((D1_TOTAL+D1_VALFRE+D1_SEGURO)-VALICM-ICMSRET-II)*FST) VI,  MAX(PERCOM) PERIODO"
cQuery += " FROM "+oTmpNFE:GetRealName()+" ENTRADAS "
cQuery += " GROUP BY ENTRADAS.D1_COD "
cQuery += " ORDER BY ENTRADAS.D1_COD, PERIODO "
cQuery := ChangeQuery(cQuery)

oTotNFEs := FwExecStatement():New()
oTotNFEs:SetQuery(cQuery)
cAliasQry1 := oTotNFEs:OpenAlias()
aStruct := TamSX3("D1_QUANT")
TcSetField(cAliasQry1, "QUANTIDADE", aStruct[3], aStruct[1], aStruct[2])
aStruct := TamSX3("D1_TOTAL")
TcSetField(cAliasQry1, "VI", aStruct[3], aStruct[1], aStruct[2])
fwFreeArray(aStruct)
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Grava todos os VI's, encontrados para o periodo, na tabela SA8.               ³
//³ Formula do VI:  (D1_TOTAL+D1_VALFRE+D1_SEGURO)-(D1_VALICM+D1_VALIPI)/D1_QUANT ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
DbSelectArea('SA8')
While !(cAliasQry1)->(Eof())
	
	SA8->(DbSetOrder(1))
	lNovoRegistro := ! SA8->(DbSeek(aFiliais[F_SA8]+(cAliasQry1)->D1_COD+cMes+cAno))
	RecLock('SA8', lNovoRegistro)
	if lNovoRegistro
		SA8->A8_FILIAL := aFiliais[F_SA8]
		SA8->A8_COD    := (cAliasQry1)->D1_COD
		SA8->A8_PERIOD	:= cMes+cAno
		SA8->A8_PERCOM	:= (cAliasQry1)->PERIODO
	EndIf
	SA8->A8_VLRVI 	:= (cAliasQry1)->VI/(cAliasQry1)->QUANTIDADE
	SA8->A8_PROCOM	:= "C"
	SA8->(MsUnlock())

	(cAliasQry1)->(DbSkip())
EndDo

oTotNFEs:Destroy()

oTmpNFE:Delete()
FWFreeObj(oTmpNFE)

RestArea(aAreaSA8)

Return

/*/{Protheus.doc} createTableTempNFE
	atraves do objeto temporarytable define e cria a tabela temporaria que vai armazenas os documentos fiscais referente ao FCI
	@type  Static Function
	@author reynaldo
	@since 19/08/2025
	@version 1
	@param oTmpNFE, object, objeto criado pela funcao FWTemporaryTable
	@return .T., logico, sempre retorna verdadeiro
	@example
	(examples)
	@see (links_or_references)
	/*/
static Function createTableTempNFE(oTmpNFE as object)	
Local cNameField    as character
Local aStructFields as array
Local aDefField     as array

	cNameField    := ""
	aStructFields := {}

	cNameField := "D1_DOC"
	aDefField  := TamSX3(cNameField)
	aAdd(aStructFields, {cNameField, aDefField[3], aDefField[1], aDefField[2]})

	cNameField := "D1_SERIE"
	aDefField  := TamSX3(cNameField)
	aAdd(aStructFields, {cNameField, aDefField[3], aDefField[1], aDefField[2]})

	cNameField := "D1_FORNECE"
	aDefField  := TamSX3(cNameField)
	aAdd(aStructFields, {cNameField, aDefField[3], aDefField[1], aDefField[2]})

	cNameField := "D1_LOJA"
	aDefField  := TamSX3(cNameField)
	aAdd(aStructFields, {cNameField, aDefField[3], aDefField[1], aDefField[2]})

	cNameField := "D1_CLASFIS"
	aDefField  := TamSX3(cNameField)
	aAdd(aStructFields, {cNameField, aDefField[3], aDefField[1], aDefField[2]})

	cNameField := "D1_TIPO"
	aDefField  := TamSX3(cNameField)
	aAdd(aStructFields, {cNameField, aDefField[3], aDefField[1], aDefField[2]})

	cNameField := "D1_COD"
	aDefField  := TamSX3(cNameField)
	aAdd(aStructFields, {cNameField, aDefField[3], aDefField[1], aDefField[2]})

	cNameField := "PERCOM"
	aDefField  := TamSX3("A8_PERCOM")
	aAdd(aStructFields, {cNameField, aDefField[3], aDefField[1], aDefField[2]})

	cNameField := "D1_TOTAL"
	aDefField  := TamSX3("D1_CUSTO")
	aAdd(aStructFields, {cNameField, aDefField[3], aDefField[1], aDefField[2]})

	cNameField := "D1_VALFRE"
	aDefField  := TamSX3("D1_CUSTO")
	aAdd(aStructFields, {cNameField, aDefField[3], aDefField[1], aDefField[2]})

	cNameField := "D1_SEGURO"
	aDefField  := TamSX3("D1_CUSTO")
	aAdd(aStructFields, {cNameField, aDefField[3], aDefField[1], aDefField[2]})

	cNameField := "D1_VALICM"
	aDefField  := TamSX3(cNameField)
	aAdd(aStructFields, {"VALICM", aDefField[3], aDefField[1], aDefField[2]})

	cNameField := "D1_ICMSRET"
	aDefField  := TamSX3(cNameField)
	aAdd(aStructFields, {"ICMSRET", aDefField[3], aDefField[1], aDefField[2]})

	cNameField := "D1_II"
	aDefField  := TamSX3(cNameField)
	aAdd(aStructFields, {"II", aDefField[3], aDefField[1], aDefField[2]})

	cNameField := "D1_VALICM"
	aDefField  := TamSX3(cNameField)
	aAdd(aStructFields, {cNameField, aDefField[3], aDefField[1], aDefField[2]})

	cNameField := "D1_ICMSRET"
	aDefField  := TamSX3(cNameField)
	aAdd(aStructFields, {cNameField, aDefField[3], aDefField[1], aDefField[2]})

	cNameField := "D1_II"
	aDefField  := TamSX3(cNameField)
	aAdd(aStructFields, {cNameField, aDefField[3], aDefField[1], aDefField[2]})

	cNameField := "D1_VALIPI"
	aDefField  := TamSX3(cNameField)
	aAdd(aStructFields, {cNameField, aDefField[3], aDefField[1], aDefField[2]})

	cNameField := "FST"
	aDefField  := {10,2,"N"}
	aAdd(aStructFields, {cNameField, aDefField[3], aDefField[1], aDefField[2]})

	cNameField := "QUANTIDADE"
	aDefField  := TamSX3("D1_QUANT")
	aAdd(aStructFields, {cNameField, aDefField[3], aDefField[1], aDefField[2]})

	cNameField := "D1_DTDIGIT"
	aDefField  := TamSX3(cNameField)
	aAdd(aStructFields, {cNameField, aDefField[3], aDefField[1], aDefField[2]})

	oTmpNFE:SetFields( aStructFields )
	oTmpNFE:AddIndex("01",{"D1_COD","PERCOM"})

	fwFreeArray(aDefField)
	aDefField := NIL

	fwFreeArray(aStructFields)
	aStructFields := NIL

Return .T.

static __lTCIWritten := nil

/*/{Protheus.doc} FCICfgTrib
	busca os valores dos tributos, caso o motor de calculo foi feito pelo configurador de tributos
	@type  Static Function
	@author reynaldo
	@since 19/08/2025
	@version 1
	@param cIdTribCT, caracter, IDTrib do registro da SD1
	@return cRetJson, caracter, json em formato texto com os valores de cada tributo encontrado
	@example
	(examples)
	@see (links_or_references)
	/*/
static Function FCICfgTrib(cIdTribCT As Character) as character

Local oDados         as object
Local cJsonDoc       as character
Local oJson          as object
Local cRegra_trib    as character
Local cAcao_total_nf as character
Local cIDTributo     as character
Local nI             as numeric
Local aTributos      as array
Local oJsonRetorno   as object
Local cRetJson       as character
Local aDados         as array

Default cIdTribCT  := ""

if __lTCIWritten == nil
	__lTCIWritten := FindClass("totvs.protheus.backoffice.fiscal.tciclass.TCIWritten")
EndIf

// Verifica se a classe do Configurador de Tributos existe no repositório.
If __lTCIWritten

	aTributos := {	"000021",; // ICMS.
					  	"000017",; // Imposto de Importacao 
						"000056",; // ICMS ST.
					 }

	oJsonRetorno := JsonObject():New()

	oDados := totvs.protheus.backoffice.fiscal.tciclass.TCIWritten():New()
	oDados:SetId({cIdTribCT})
	oDados:setDataItems({"regras_escrituracao"})
	
	cJsonDoc := oDados:GetDataId()
	
	oJson := JsonObject():New()
	oJson:FromJson(cJsonDoc)

	If oJson:HasProperty("dados_Id")
		If oJson["dados_Id"]:HasProperty(cIdTribCT)

			aDados := oJson["dados_Id"][cIdTribCT]:GetNames()
			For nI:=1 To Len(aDados)

				cRegra_trib := aDados[nI]
				If oJson["dados_Id"][cIdTribCT]:HasProperty(cRegra_trib)
					if oJson["dados_Id"][cIdTribCT][cRegra_trib]:HasProperty("regras_escrituracao")
					
						cAcao_total_nf := oJson["dados_Id"][cIdTribCT][cRegra_trib]["regras_escrituracao"]["acao_total_nf"]
						if cAcao_total_nf $ "4;7;8"

							If oJson["dados_Id"][cIdTribCT][cRegra_trib]:HasProperty("codigo_tributo_relacionado")
								cIDTributo := oJson["dados_Id"][cIdTribCT][cRegra_trib]["codigo_tributo_relacionado"]

								if aScan(aTributos,{|x|x == cIDTributo })>0
									oJsonRetorno[cIDTributo] := oJson["dados_Id"][cIdTribCT][cRegra_trib]["valor_tributo"]
								EndIf
							EndIf
						EndIf
					EndIF
				EndIf
			Next nI
			aSize(aDados,0)
			aDados := NIL
		EndIf
	EndIf

	cRetJson := oJsonRetorno:ToJson()

	FWFreeObj(oJson)
	FWFreeObj(oDados)
	FWFreeObj(oJsonRetorno)

EndIf

Return cRetJson

/*/{Protheus.doc} fatorSitTrib
	busca os valores dos tributos, caso o motor de calculo foi feito pelo configurador de tributos
	@type  Static Function
	@author reynaldo
	@since 19/08/2025
	@version 1
	@param cOrigem, caracter, Origem do produto informado no item do documento de entrada
	@return nFator, numeric, fator para o calculo do valor de importacao
	@example
	(examples)
	@see (links_or_references)
	/*/
Static Function fatorSitTrib(cOrigem as Character)
	Local nFator as numeric // Fator Situacao Tributaria (FST)

	do CASE
		CASE cOrigem  == '3'
			nFator := 0.5
		CASE cOrigem  == '8'
			nFator := 1
		CASE cOrigem == '2'
			nFator := 1
		CASE cOrigem == '1'
			nFator := 1
		Otherwise 
			nFator := 0
	END Case
Return nFator


/*/{Protheus.doc} FCIPurchasedProducts
	atraves de uma tabela temporaria seleciona os documentos de entradas relativos ao FCI
	@type Function
	@author reynaldo
	@since 19/08/2025
	@version 1
	@param oTmpNFE,  object,   fwTemporaytable que ira conter as informaçoes dos documentos de entrada
	@param cMes,     character, Numero do mes a ser pesquisado
	@param cAno,     character, Ano a ser pesquisado
	@param cProdDe,  character, Codigo inicial do produto a ser pesquisado
	@param cProdAte, character, Codigo final do produto a ser pesquisado
	@param cNomSD1,  character, Nome da tabela de conversão do campo ITEM devido a funcao soma1()
	@return Nenhum
	@example
	(examples)
	@see (links_or_references)
	/*/
Function FCIPurchasedProducts(oTmpNFE as object, cMes as character, cAno as character, cProdDe as character, cProdAte as character, cNomSD1 as character)
Local cQuery as character
Local cAliasNFE as character
Local aQryValores as array
Local cFuncNull as character
Local cD1_DTDIGIT as character

Local cMV_FCIPERI as character

Local cSD1Table as character
Local cSD1Filial as character
Local cSF4Table as character
Local cSF4Filial as character
local cSWNTable as character
Local cStatusNF as character
Local cFCICF as character
local lSigaEIC as logical
local oNFEs as object
local nCnt as numeric
local cAliasQry as character
local cTmpTableNFE as character
local cDbType as character
local oBulk as object
local aRecord as array
local cJsonTributos as character
local jTributosFCI as json
local aIDTributos as array
local nTributos as numeric
local aAreaCurrent as array
local aFieldsQry as array
local cNameField as character

aAreaCurrent := GetArea()

cSD1Table   := RetSQLName("SD1")
cSD1Filial  := xFilial("SD1")
cSF4Table   := RetSQLName("SF4")
cSF4Filial  := xFilial("SF4")
cSWNTable   := RetSQLName("SWN")
cStatusNF   := "A"
cMV_FCIPERI := SuperGetMV("MV_FCIPERI",.F.,"U")
lFCIComp    := SuperGetMV("MV_FCICOMP",.F.,.F.)
cFCICF      := AllTrim(SuperGetMV("MV_FCICF",.F.,""))
lSigaEIC    := SuperGetMV("MV_EASY",.F.,"N")=="S"
cDbType     := TCGetDB()

createTableTempNFE(oTmpNFE)
oTmpNFE:Create()
cAliasNFE := oTmpNFE:GetAlias()	

/*	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Tabela A - Origem da Mercadoria ou Servico                                                                               ³
	³                                                                                                                          ³
	³0 - Nacional - exceto as indicadas nos códigos 3, 4, 5 e 8                                                                ³
	³1 - Estrangeira - Importação direta, exceto a indicada no código 6                                                        ³
	³2 - Estrangeira - Adquirida no mercado interno, exceto a indicada no código 7                                             ³
	³3 - Nacional - mercadoria ou bem com Conteúdo de Importação superior a 40% e inferior ou igual a 70%                      ³
	³4 - Nacional - cuja produção tenha sido feita em conformidade com os processos produtivos básicos de que tratam o         ³
	³    Decreto-Lei nº 288/67, e as Leis nº 8.248/91, 8.387/91, 10.176/01 e 11.484/07                                         ³
	³5 - Nacional - mercadoria ou bem com Conteúdo de Importação inferior ou igual a 40% (quarenta por cento)                  ³
	³6 - Estrangeira - Importação direta, sem similar nacional, constante em lista de Resolução CAMEX e gás natural            ³
	³7 - Estrangeira - Adquirida no mercado interno, sem similar nacional, constante em lista de Resolução CAMEX e gás natural ³
	³8 - Nacional - mercadoria ou bem com Conteúdo de Importação superior a 70% (setenta por cento)                            ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ ATENCAO: Ao realizar a manutencao do as Querys dessa funcao, obrigatoriamente deve-se ³
//³ revisar as querys do relatorio FCIR002.PRW. Ambos utilizam a mesma logica nas Querys. ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
aQryValores := {}
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Tratamento para ISNULL em diferentes BD's ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
cFuncNull := MATIsNull()

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Query para retornar todos as entradas de MP do periodo, agrupadas por Codigo de Produto ³
//³ --------------------------------------------------------------------------------------- ³
//³ ATENCAO: Caso seja necessario alterar esta QUERY, replicar as alteracoes para a QUERY   ³
//³ que realiza o tratamento para NF's de Complemento de Preco (MV_FCICOMP), na sequencia   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
cQuery := "SELECT "

cQuery += "SD1.D1_DOC, "
cQuery += "SD1.D1_SERIE, "
cQuery += "SD1.D1_FORNECE, "
cQuery += "SD1.D1_LOJA, "
cQuery += "SD1.D1_CLASFIS, "
cQuery += "SD1.D1_TIPO, "

cD1_DTDIGIT := "S.D1_DTDIGIT"
If cMV_FCIPERI == "U"
   cD1_DTDIGIT := "SD1.D1_DTDIGIT"
EndIf
cQuery += cD1_DTDIGIT +", "
cQuery += "SD1.D1_IDTRIB, "
cQuery += "SD1.D1_COD, "
cQuery += "SUBSTRING(" +cD1_DTDIGIT+", 1, 6) PERCOM, "
cQuery += "SF4.F4_AGREG, "
cQuery += "SUBSTRING(SD1.D1_CLASFIS,1,1) ORIGEM, "
cQuery += "SD1.D1_TOTAL, "
cQuery += "SD1.D1_VALFRE, "
cQuery += "SD1.D1_SEGURO, "
cQuery += "SD1.D1_VALICM, "
cQuery += "SD1.D1_ICMSRET, "
cQuery += "SD1.D1_VALIPI, "

cD1_II := "SD1.D1_II, "
If lSigaEIC
	cD1_II := " " + cFuncNull + " (SWN.WN_IIVAL+SWN.WN_DESPADU,SD1.D1_II) D1_II, "
EndIf
cQuery += cD1_II

cQuery += "CASE WHEN "
cQuery += " SUBSTRING(SD1.D1_DTDIGIT, 1, 6) = SUBSTRING(S.D1_DTDIGIT, 1, 6) "
cQuery += " THEN "
cQuery +=   " SD1.D1_QUANT "
cQuery += " ELSE "
cQuery +=   " 0 "
cQuery += "END QUANTIDADE, "

cQuery += " SUBSTRING(SD1.D1_DTDIGIT, 1, 6) ANOMES, "
cQuery += " SUBSTRING(S.D1_DTDIGIT, 1, 6) MAX_ANOMES "


// Fator Agrega Valor (VL)
// Fator Situacao Tributaria (FST)
// Fim (VL)+(FST)

cQuery += "FROM "+cSD1Table+" SD1 "

cQuery += " INNER JOIN ( select D1_COD, MAX(D1_DTDIGIT) D1_DTDIGIT "
cQuery +=         "FROM "+cSD1Table+" D1 "
cQuery += 		   "JOIN " + RetSqlName("SF1") + " F1 ON " 
cQuery +=		   "F1.F1_FILIAL = D1.D1_FILIAL "
cQuery += 		   "AND F1.F1_DOC = D1.D1_DOC "
cQuery +=		   "AND F1.F1_SERIE = D1.D1_SERIE "
cQuery +=         "AND F1.F1_FORNECE = D1.D1_FORNECE "
cQuery +=         "AND F1.F1_LOJA = D1.D1_LOJA "
cQuery +=         "AND F1.F1_TIPO = D1.D1_TIPO "
cQuery +=		   "AND F1.F1_STATUS = ? "    
aAdd(aQryValores, {'C', cStatusNF})
cQuery +=         "AND F1.D_E_L_E_T_ = ? "   
aAdd(aQryValores, {'C', ' '})
cQuery +=         "WHERE D1.D1_FILIAL = ? "// cSD1Filial
aAdd(aQryValores, {'C', cSD1Filial})
cQuery +=         "AND D1.D1_COD >= ? " // cProdDe
aAdd(aQryValores, {'C', cProdDe})
cQuery +=         "AND D1.D1_COD <= ? "// cProdAte
aAdd(aQryValores, {'C', cProdAte})
cQuery +=         "AND D1.D1_DTDIGIT <= ? " // cAno+cMes+'31'
aAdd(aQryValores, {'C', cAno+cMes+"31"})
cQuery +=         "AND D1.D1_TIPO = ? "// 'N'
aAdd(aQryValores, {'C', "N"})

If cMV_FCIPERI =="U"
	cQuery +=       " AND SUBSTRING(D1.D1_CLASFIS,1,1) IN (?) " //  
	aAdd(aQryValores, {'In', {'1','2','3','8'}})
EndIf
If !Empty(cFCICF)
	cQuery +=       " AND D1.D1_CF NOT IN (?) "// cFCICF
	aAdd(aQryValores, {'In', StrTokArr(cFCICF, ",")})
EndIf
cQuery +=         " AND D1.D_E_L_E_T_ = ? " // ' ' 
aAdd(aQryValores, {'C', ' '})
cQuery +=         " group by D1.D1_COD "
cQuery +=      " ) S on "
cQuery += "	S.D1_COD = SD1.D1_COD "

cQuery += "JOIN "+cSF4Table+" SF4 "
cQuery += "ON SF4.F4_FILIAL = ? "
aAdd(aQryValores, {'C', cSF4Filial})
cQuery += "AND SF4.F4_CODIGO = SD1.D1_TES "
cQuery += "AND SF4.D_E_L_E_T_ = ? " // ' ' 
aAdd(aQryValores, {'C', ' '})
If lSigaEIC
	cQuery += "LEFT JOIN " + cNomSD1 + " D1AUX ON D1AUX.D1_ITEMOLD = SD1.D1_ITEM "
	cQuery += "LEFT JOIN " + cSWNTable + " SWN ON SWN.WN_FILIAL = SD1.D1_FILIAL "
	cQuery += "AND SWN.WN_DOC = SD1.D1_DOC AND SWN.WN_SERIE = SD1.D1_SERIE AND (SWN.WN_TEC||SWN.WN_EX_NCM||SWN.WN_EX_NBM) = SD1.D1_TEC "
	cQuery += "AND SWN.WN_FORNECE = SD1.D1_FORNECE AND SWN.WN_LOJA = SD1.D1_LOJA AND SWN.WN_PRODUTO = SD1.D1_COD " 
	cQuery += "AND SWN.WN_LINHA = CAST(D1AUX.D1_ITEMNEW AS DECIMAL(20)) "
	cQuery += "AND SWN.D_E_L_E_T_ = ? " // ' ' 
   aAdd(aQryValores, {'C', ' '})
EndIf

cQuery += " WHERE SD1.D1_FILIAL = ? " // cSD1Filial
aAdd(aQryValores, {'C', cSD1Filial})
cQuery += " AND SD1.D1_DTDIGIT <= ? "// cAno+cMes+"31"
aAdd(aQryValores, {'C', cAno+cMes+"31"})
cQuery += " AND SD1.D1_COD >= ? " // cProdDe
aAdd(aQryValores, {'C', cProdDe})
cQuery += " AND SD1.D1_COD <= ? " // cProdAte
aAdd(aQryValores, {'C', cProdAte})
cQuery += " AND SD1.D1_TIPO = ? " // 'N' 
aAdd(aQryValores, {'C', 'N'})
If cMV_FCIPERI <>"U"
	cQuery += " AND SUBSTRING(SD1.D1_CLASFIS,1,1) IN (?)" // '1','2','3','8'
	aAdd(aQryValores, {'In', {'1','2','3','8'}})
EndIf
If !Empty(cFCICF)
	cQuery += "AND SD1.D1_CF NOT IN (?) "// cFCICF
	aAdd(aQryValores, {'In', StrTokArr(cFCICF, ",")})
EndIf
cQuery += " AND SD1.D_E_L_E_T_ = ?" // ' ' 
aAdd(aQryValores, {'C', ' '})

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Caso o cliente habilite o parametro MV_FCICOMP, sera realizado calculo e atualizacao da SA8 ³
//³ com base nos complementos de preco (Tipo C) existentes para as NF's do Tipo N do periodo    ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lFCIComp

	cQuery += " UNION ALL" // por causa dos campos do SELECT podem ter linhas repetidas, sim.
	cQuery += "SELECT "

	cQuery += "SD1.D1_DOC, "
	cQuery += "SD1.D1_SERIE, "
	cQuery += "SD1.D1_FORNECE, "
	cQuery += "SD1.D1_LOJA, "
	cQuery += "SD1.D1_CLASFIS, "
	cQuery += "SD1.D1_TIPO, "
	cQuery += "SD1.D1_DTDIGIT, "
	cQuery += "SD1.D1_IDTRIB, "
	cQuery += "SD1.D1_COD, "

	cQuery += "'      ' PERCOM, "

	cQuery += "SF4.F4_AGREG, "

	cQuery += "SUBSTRING(SD1.D1_CLASFIS,1,1) ORIGEM, "

	cQuery += "SD1.D1_TOTAL, "
	cQuery += "SD1.D1_VALFRE, "
	cQuery += "SD1.D1_SEGURO, "
	cQuery += "SD1.D1_VALICM, "
	cQuery += "SD1.D1_ICMSRET, "
	cQuery += "SD1.D1_VALIPI, "

	cD1_II := "SD1.D1_II, "
	If lSigaEIC
		cD1_II := " " + cFuncNull + " (SWN.WN_IIVAL+SWN.WN_DESPADU,SD1.D1_II) D1_II, "
	EndIf
	cQuery += cD1_II

	cQuery +=   " 0 QUANTIDADE, "

	cQuery += " SUBSTRING(SD1.D1_DTDIGIT, 1, 6) ANOMES, "
	cQuery += " SUBSTRING(S.D1_DTDIGIT, 1, 6) MAX_ANOMES "

	cQuery += "FROM "+cSD1Table+" SD1 "
	cQuery += "JOIN "+cSF4Table+" SF4 ON "
	cQuery += "SF4.F4_FILIAL = ? AND " // cSF4Filial
	aAdd(aQryValores, {'C', cSF4Filial})
	cQuery += "SF4.F4_CODIGO = SD1.D1_TES AND "
	cQuery += "SF4.D_E_L_E_T_ = ? "// ' ' 
	aAdd(aQryValores, {'C', ' '})

	cQuery += " INNER JOIN ( select D1_COD, MAX(D1_DTDIGIT) D1_DTDIGIT "
	cQuery +=          " from "+cSD1Table+" D1 "
	cQuery +=         "WHERE D1.D1_FILIAL = ? "// cSD1Filial
	aAdd(aQryValores, {'C', cSD1Filial})
	cQuery +=         "AND D1.D1_COD >= ? " // cProdDe
	aAdd(aQryValores, {'C', cProdDe})
	cQuery +=         "AND D1.D1_COD <= ? "// cProdAte
	aAdd(aQryValores, {'C', cProdAte})
	cQuery +=         "AND D1.D1_DTDIGIT <= ? " // cAno+cMes+'31'
	aAdd(aQryValores, {'C', cAno+cMes+"31"})
	cQuery +=         "AND D1.D1_TIPO = ? "// 'N'
	aAdd(aQryValores, {'C', "N"})

	If cMV_FCIPERI =="U"
		cQuery += " AND SUBSTRING(D1.D1_CLASFIS,1,1) IN (?)" // '1','2','3','8'
		aAdd(aQryValores, {'In', {'1','2','3','8'}})
	EndIf
	If !Empty(cFCICF)
		cQuery += "AND D1.D1_CF NOT IN (?) "// [20] cFCICF
		aAdd(aQryValores, {'In', StrTokArr(cFCICF, ",")})
	EndIf
	cQuery +=         " and D1.D_E_L_E_T_ = ? " // ' ' 
	aAdd(aQryValores, {'C', ' '})
	cQuery +=         " group by D1_COD "
	cQuery +=      " ) S on "
	cQuery += "	S.D1_COD = SD1.D1_COD "
	cQuery += "INNER JOIN "+cSD1Table+" SD1C ON "
	cQuery += "SD1.D1_DOC = SD1C.D1_NFORI AND "
	cQuery += "SD1.D1_ITEM = SD1C.D1_ITEMORI AND "
	cQuery += "SD1.D1_SERIE = SD1C.D1_SERIORI AND "
	cQuery += "SD1.D1_COD = SD1C.D1_COD AND "
	cQuery += "SD1.D1_FORNECE = SD1C.D1_FORNECE AND "
	cQuery += "SD1.D1_LOJA = SD1C.D1_LOJA "
	If !Empty(cFCICF)
		cQuery += "AND SD1C.D1_CF NOT IN (?) " // cFCICF
		aAdd(aQryValores, {'In', StrTokArr(cFCICF, ",")})
	EndIf
	cQuery += "AND SD1C.D_E_L_E_T_ = ? " // ' ' 
	aAdd(aQryValores, {'C', ' '})
	If lSigaEIC
		cQuery += "LEFT JOIN " + cNomSD1 + " D1AUX ON D1AUX.D1_ITEMOLD = SD1C.D1_ITEM "
		cQuery += "LEFT JOIN "+cSWNTable+" SWN ON SWN.WN_FILIAL = SD1C.D1_FILIAL "
		cQuery += "AND SWN.WN_DOC = SD1C.D1_DOC AND SWN.WN_SERIE = SD1C.D1_SERIE AND (SWN.WN_TEC||SWN.WN_EX_NCM||SWN.WN_EX_NBM) = SD1C.D1_TEC "
		cQuery += "AND SWN.WN_FORNECE = SD1C.D1_FORNECE AND SWN.WN_LOJA = SD1C.D1_LOJA AND SWN.WN_PRODUTO = SD1C.D1_COD " 
		cQuery += "AND SWN.WN_LINHA = CAST(D1AUX.D1_ITEMNEW AS DECIMAL(20)) "
		cQuery += "AND SWN.D_E_L_E_T_ = ? " // ' ' 
		aAdd(aQryValores, {'C', ' '})
	EndIf
	cQuery += "WHERE SD1.D1_FILIAL = '"+cSD1Filial+"' AND "
	cQuery += "SD1.D1_DTDIGIT <= ? AND " // cAno+cMes+'31'
	aAdd(aQryValores, {'C', cAno+cMes+"31"})
	cQuery += "SD1.D1_TIPO = ? AND " // 'N'
	aAdd(aQryValores, {'C', 'N'})
	
	cQuery += " SUBSTRING(SD1.D1_CLASFIS,1,1) IN (?) AND " // '1','2','3','8'
	aAdd(aQryValores, {'In', {'1','2','3','8'}})
	If !Empty(cFCICF)
		cQuery += "SD1.D1_CF NOT IN (?) AND " // cFCICF
		aAdd(aQryValores, {'In', StrTokArr(cFCICF, ",")})
	EndIf
	cQuery += "SD1.D_E_L_E_T_ = ? AND " // ' ' 
	aAdd(aQryValores, {'C', ' '})

	cQuery += " SD1C.D1_TIPO = ? " // 'C' 
	aAdd(aQryValores, {'C', 'C'})
	
ENDIF

cQuery := ChangeQuery(cQuery)

oNFEs := FwExecStatement():New()
oNFEs:SetQuery(cQuery)

For nCnt := 1 to len(aQryValores)
	Do Case
		case aQryValores[nCnt][1] == "C"
			oNFEs:SetString(nCnt, aQryValores[nCnt][2])
		case aQryValores[nCnt][1] == "In"
			oNFEs:setIn(nCnt, aQryValores[nCnt][2])
	EndCase
Next nCnt
fwFreeArray(aQryValores)

cAliasQry := oNFEs:OpenAlias()

aFieldsQry := {"D1_QUANT", "D1_TOTAL", "D1_VALFRE", "D1_SEGURO", "D1_VALICM", "D1_ICMSRET ", "D1_VALIPI", "D1_II"}
mountDefFieldQry(aFieldsQry)
fwFreeArray(aFieldsQry)

For nCnt := 1 To Len(__aSetFieldsQry)
		cNameField := __aSetFieldsQry[nCnt,1]
		if cNameField == "D1_QUANT"
			cNameField := "QUANTIDADE"
		EndIf
	TcSetField(cAliasQry, cNameField, __aSetFieldsQry[nCnt,2], __aSetFieldsQry[nCnt,3], __aSetFieldsQry[nCnt,4])
Next nCnt 


// FWBulk pode nao consegue identificar a tabela temporaria quando o servidor de banco de dados for MSSQL
cTmpTableNFE := oTmpNFE:GetRealName()
If 'MSSQL' $ cDbType
	cTmpTableNFE := oTmpNFE:cTableName
EndIf 

aRecord := {}
oBulk := FwBulk():New(cTmpTableNFE, 500)
oBulk:SetFields((cAliasNFE)->(dbStruct()))

While !(cAliasQry)->(Eof())

	aRecord := array(21) // {D1_DOC, D1_SERIE, D1_FORNECE, D1_LOJA, D1_CLASFIS, D1_TIPO, D1_COD, PERCOM, D1_TOTAL, 
	                     //  D1_VALFRE, D1_SEGURO, VALICM, ICMSRET, II, D1_VALICM, D1_ICMSRET, D1_II, D1_VALIPI, FST, QUANTIDADE,D1_DTDIGIT }

	aRecord[01] := (cAliasQry)->D1_DOC // D1_DOC
	aRecord[02] := (cAliasQry)->D1_SERIE
	aRecord[03] := (cAliasQry)->D1_FORNECE
	aRecord[04] := (cAliasQry)->D1_LOJA
	aRecord[05] := (cAliasQry)->D1_CLASFIS
	aRecord[06] := (cAliasQry)->D1_TIPO
	aRecord[07] := (cAliasQry)->D1_COD
	aRecord[08] := (cAliasQry)->PERCOM

	aRecord[09] := 0 //(cAliasQry)->D1_TOTAL
	aRecord[10] := 0 //(cAliasQry)->D1_VALFRE
	aRecord[11] := 0 //(cAliasQry)->D1_SEGURO
	aRecord[12] := 0 //(cAliasQry)->D1_VALICM
	aRecord[13] := 0 //(cAliasQry)->D1_ICMSRET
	aRecord[14] := 0 //(cAliasQry)->D1_II

	aRecord[15] := (cAliasQry)->D1_VALICM
	aRecord[16] := (cAliasQry)->D1_ICMSRET
	aRecord[17] := (cAliasQry)->D1_II
	aRecord[18] := (cAliasQry)->D1_VALIPI
	aRecord[19] := fatorSitTrib((cAliasQry)->ORIGEM) //(cAliasQry)->FST
	aRecord[20] := (cAliasQry)->QUANTIDADE
	aRecord[21] := (cAliasQry)->D1_DTDIGIT

	if (cAliasQry)->ANOMES == (cAliasQry)->MAX_ANOMES

		aRecord[09] := (cAliasQry)->D1_TOTAL
		aRecord[10] := (cAliasQry)->D1_VALFRE
		aRecord[11] := (cAliasQry)->D1_SEGURO

		if (cAliasQry)->ORIGEM $ "2;3;8"
			// WHEN SUBSTRING(SD1.D1_CLASFIS, 1, 1) IN ('2', '3', '8') THEN ((SD1.D1_TOTAL + SD1.D1_VALFRE + SD1.D1_SEGURO)-(SD1.D1_VALICM)) 
			aRecord[12] := (cAliasQry)->D1_VALICM
			aRecord[13] := 0
			aRecord[14] := 0

		Else

			if (cAliasQry)->F4_AGREG $ 'I;S'
				// CASE WHEN SF4.F4_AGREG IN ('I', 'S') AND SUBSTRING(SD1.D1_CLASFIS, 1, 1) NOT IN ('2', '3', '8') THEN ((SD1.D1_TOTAL + SD1.D1_VALFRE + SD1.D1_SEGURO)-(SD1.D1_II))
				aRecord[12] := 0
				aRecord[13] := 0
				aRecord[14] := (cAliasQry)->D1_II

				
			elseif (cAliasQry)->F4_AGREG $ 'C;B'
				// WHEN SF4.F4_AGREG IN ('C', 'B') AND SUBSTRING(SD1.D1_CLASFIS, 1, 1) NOT IN ('2', '3', '8') THEN ((SD1.D1_TOTAL + SD1.D1_VALFRE + SD1.D1_SEGURO)- ISNULL(SWN.WN_IIVAL + SWN.WN_DESPADU, SD1.D1_II)) 
				aRecord[12] := 0
				aRecord[13] := 0
				aRecord[14] := (cAliasQry)->D1_II


			elseif (cAliasQry)->F4_AGREG $ 'A;N;R'
				//WHEN SF4.F4_AGREG IN ('A', 'N', 'R') AND SUBSTRING(SD1.D1_CLASFIS, 1, 1) NOT IN ('2', '3', '8') THEN ((SD1.D1_TOTAL + SD1.D1_VALFRE + SD1.D1_SEGURO)) 
				aRecord[12] := 0
				aRecord[13] := 0
				aRecord[14] := 0

			elseif (cAliasQry)->F4_AGREG $ 'H'
				//WHEN SF4.F4_AGREG = 'H' AND SUBSTRING(SD1.D1_CLASFIS, 1, 1) NOT IN ('2', '3', '8') THEN ((SD1.D1_TOTAL + SD1.D1_VALFRE + SD1.D1_SEGURO)-(SD1.D1_ICMSRET)) 
				aRecord[12] := 0
				aRecord[13] := (cAliasQry)->D1_ICMSRET
				aRecord[14] := 0

			// *D - Deduz o valor do ICMS ou ISS, no caso de redução de base de cálculo, do valor contábil. Atenção! a dedução do Imposto será subtraida na base do PIS e COFINS. Deduzirá também no caso de Isenção por operação com cliente órgão público.
			// *E - Deduz o valor do ICMS embutido no valor da mercadoria. 
			// *F - Deduz o valor da mercadoria do valor da duplicata.
			// *G - O valor a ser lançado na duplicata deverá ser somente o valor de ICMS do documento fiscal.
			else
				aRecord[12] := (cAliasQry)->D1_VALICM
				aRecord[13] := 0
				aRecord[14] := (cAliasQry)->D1_II
			endIf

		EndIf

		If ! empty((cAliasQry)->D1_IDTRIB)
			cJsonTributos := FCICfgTrib((cAliasQry)->D1_IDTRIB)
			if !Empty(cJsonTributos)
				jTributosFCI := JsonObject():New()
				jTributosFCI:FromJson(cJsonTributos)
				
				aIDTributos := jTributosFCI:GetNames()
				for nTributos := 1 to len(aIDTributos)
					cIDTributo := aIDTributos[nTributos]

					IF cIDTributo == "000021" // ICMS
						aRecord[12] := jTributosFCI[cIDTributo]
					ElseIF cIDTributo == "000017" // ICMSST
						aRecord[13] := jTributosFCI[cIDTributo]
					ElseIF cIDTributo == "000056" // II
						aRecord[14] := jTributosFCI[cIDTributo]
					EndIf
				next nTributos
				fwFreeArray(aIDTributos)
				FWFreeObj(jTributosFCI)
			EndIf
		EndIf
	EndIf

	oBulk:AddData(aRecord)
	(cAliasQry)->(dbSkip())

End
aRecord := aSize(aRecord,0)
aRecord := NIL

If !oBulk:flush()
	UserException(I18N(STR0001, {oBulk:GetError()})) //"Erro no flush dos daods para tabela temporaria de documentos fiscais no FCI: #1[erro ao atualizar]"
EndIf
If !oBulk:Close()
	UserException(I18N(STR0002, {oBulk:GetError()})) // "Erro ao fechar a tabela temporaria de documentos fiscais no FCI: #1[erro ao atualizar]"
EndIf
oBulk:Destroy()
oBulk := nil

oNFEs:Destroy()

restarea(aAreaCurrent)
Return

/*/{Protheus.doc} mountDefFieldQry
	Atualizo o array estatico com as informações de definição dos campos informados
	@type Function
	@author reynaldo
	@since 19/08/2025
	@version 1
	@param aFieldsQry,  array,  Nome dos campos do dicionario de dados que foram considerados no SELECT
	@return .T., logico, 
	@example
	(examples)
	@see (links_or_references)
	/*/
static Function mountDefFieldQry(aFieldsQry as array)
Local nX as numeric
Local aStruct as array

if __aSetFieldsQry == NIL 
	__aSetFieldsQry := {}
	For nX := 1 To Len(aFieldsQry)
		aStruct := TamSX3(aFieldsQry[nX])
		aAdd( __aSetFieldsQry ,{aFieldsQry[nX],aStruct[3],aStruct[1],aStruct[2]})
	Next nX
	fwFreeArray(aStruct)
EndIf

Return .T.
