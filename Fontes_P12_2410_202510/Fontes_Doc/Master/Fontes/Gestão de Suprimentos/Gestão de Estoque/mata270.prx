#INCLUDE "MATA270.CH"
#INCLUDE "PROTHEUS.CH"
#INCLUDE 'FWADAPTEREAI.CH'

Static lMV_A270F4 := NIL

/*/


Ŀ
Funo     MATA270   Autor  Eveli Morasco          Data  10/03/92 
Ĵ
Descrio  Programa de digitacao do inventario                        
Ĵ
Parametros ExpL1 = .T. para Rot.Automatica     (OPC)                  
Ĵ
 Uso       Generico                                                   
Ĵ
*/
Function MATA270(xRotAuto,lEscolha,nOpcAuto)
Local lRet			:= .T.
Local aCores		:= { {"B7_ESCOLHA = 'S' ","BR_VERDE"},{"B7_ESCOLHA <> 'S'","BR_VERMELHO"} }
Local cFiltro     := ""   
Local nPosData    := 0
Local nPosCodPro  := 0
Local nPosLocal   := 0                
Local cContagem   := Replicate("0",(TamSx3("B7_CONTAGE")[1]))
Local cSeekSb7    := ""    
Local lIntegDef  := FWHasEAI("MATA270",, .T., .T.) .AND. IsInCallStack("MATI270") //Integracao via Mensagem Unica 

Default	lEscolha	:= .F.
Default	nOpcAuto	:= 3

//Ŀ
// Define Array contendo as Rotinas a executar do programa      
// ----------- Elementos contidos por dimensao ------------     
// 1. Nome a aparecer no cabecalho                              
// 2. Nome da Rotina associada                                  
// 3. Usado pela rotina                                         
// 4. Tipo de Transao a ser efetuada                          
//    1 - Pesquisa e Posiciona em um Banco de Dados             
//    2 - Simplesmente Mostra os Campos                         
//    3 - Inclui registros no Bancos de Dados                   
//    4 - Altera o registro corrente                            
//    5 - Remove o registro corrente do Banco de Dados          
//

PRIVATE aRotina := MenuDef()
PRIVATE l270Auto := ( xRotAuto <> NIL )
PRIVATE aRotAuto := NIL

If l270Auto 
	aRotAuto := xRotAuto
EndIf

//Ŀ
// Define o cabecalho da tela de atualizacoes                   
//
PRIVATE cCadastro := OemToAnsi(STR0006)   //"Digitao do Inventrio"

//Ŀ
// Verifica as perguntas selecionadas                           
//
//Ŀ
// Variaveis utilizadas para parametros                         
// mv_par01	     	// Valida Existencia                     
// mv_par02	     	// Sugere informacoes S/N/POR LOCALIZACAO
// mv_par03	     	// Data p/ opcao sel. autom.             
//

Pergunte("MTA270",!l270Auto)

If lIntegDef .And. l270Auto 
	mv_par01 := 0 //Nao valida existencia quando integracao 
EndIf

If l270Auto .And. lEscolha .And. nOpcAuto == 4 // Se for alteracao, desligo lEscolha
	lEscolha := .F.
Endif

If l270Auto
	Do Case
		Case nOpcAuto == 3
			INCLUI := .T.
			ALTERA := .F.
		Case nOpcAuto == 4
			INCLUI := .F.
			ALTERA := .T.
		OtherWise
			INCLUI := .F.
			ALTERA := .F.
	EndCase
EndIf

//VĿ
////Inclui registro como registro escolhido no (B7_ESCOLHA== S)
//
If l270Auto .And. lEscolha

	nPosData		:= Ascan(aRotAuto,{|x| x[1] == "B7_DATA" })
	nPosCodPro	:= Ascan(aRotAuto,{|x| x[1] == "B7_COD"	})
	nPosLocal	:= Ascan(aRotAuto,{|x| x[1] == "B7_LOCAL" })
	
	If UsaContage() .And. nPosData > 0 .And. nPosCodPro > 0 .And. nPosLocal > 0

		cAliasSB7 := GetNextAlias()
		cQuery := " SELECT R_E_C_N_O_ SB7_RECNO, B7_CONTAGE "
		cQuery += "		FROM " + RetSqlName("SB7") 
		cQuery += "		WHERE B7_FILIAL = '"	+ xFilial("SB7")					+ "' "
		cQuery += "		  AND B7_DATA   = '"	+ DTOS(aRotAuto[nPosData,2]) 	+ "' "
		cQuery += "		  AND B7_COD 	 = '"	+ aRotAuto[nPosCodPro,2]  		+ "' "
		cQuery += "		  AND B7_LOCAL  = '"	+ aRotAuto[nPosLocal,2]   		+ "' "				
		cQuery += " 	ORDER BY B7_CONTAGE	"
		cQuery := ChangeQuery(cQuery)
		dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasSB7)
   
		While (cAliasSB7)->(!Eof())
			SB7->(dbGoto((cAliasSB7)->SB7_RECNO))
			RecLock('SB7',.F.)
			SB7->B7_ESCOLHA := ""
			MsUnLock()
			cContagem := SB7->B7_CONTAGE
			(cAliasSB7)->(dbSkip())
		EndDo
		(cAliasSB7)->(DbCloseArea())
	
		cContagem:= Soma1(cContagem)
		
		Aadd(aRotAuto,{"B7_CONTAGE", cContagem	, Nil })
		Aadd(aRotAuto,{"B7_ESCOLHA", "S"			, Nil })
	EndIf
	If MsRotAuto(nOpcAuto,aRotAuto,"SB7")
		lRet := .F.
	EndIf
ElseIf l270Auto //.And. MsRotAuto(3,aRotAuto,"SB7")
	Do Case
		Case nOpcAuto == 3
			MsRotAuto(3,aRotAuto,"SB7")
		Case nOpcAuto == 4
			MsRotAuto(4,aRotAuto,"SB7")
		Case nOpcAuto == 5
			MsRotAuto(5,aRotAuto,"SB7")
		EndCase
	lRet := .F.
EndIf

If lRet
	//Ŀ
	// Ativa tecla F12 para acionar perguntas                         
	//
	If ! l270Auto
		Set Key VK_F12 To MTA270PERG()
	EndIf
	//Ŀ
	// Endereca a funcao de BROWSE                                  
	//

	//Ŀ
	// Ponto de entrada para verificacao de filtros na Mbrowse      
	//
	If  ExistBlock("M270FILB") 
		cFiltro := ExecBlock("M270FILB",.F.,.F.)
		If Valtype(cFiltro) <> "C"
			cFiltro := ""		
		EndIf
	EndIf

	If UsaContage()
		mBrowse( 6, 1,22,75,"SB7",,,,,,aCores,,,,,,,, IF(!Empty(cFiltro),cFiltro, NIL))
	Else
		mBrowse( 6, 1,22,75,"SB7",,,,,,,,,,,,,, IF(!Empty(cFiltro),cFiltro, NIL))
	EndIf
	//Ŀ
	// Desativa tecla que aciona perguntas                            
	//
	If ! l270Auto
		Set Key VK_F12 To
	EndIf
EndIf
Return Nil

/*

Ŀ
Funo    A270Altera Autor Rodrigo de A. Sartorio  Data  18/03/96 
Ĵ
Descrio  Programa para alteracao de Acerto do Inventario.           
Ĵ
Sintaxe    A270Altera(ExpC1,ExpN1,ExpN2)                              
Ĵ
Parametros ExpC1 = Alias do arquivo                                   
           ExpN1 = Numero do registro                                 
           ExpN2 = Numero da opcao selecionada                        
Ĵ
 Uso       MATA270                                                    
ٱ


*/
Function A270Altera(cAlias,nReg,nOpc)
Local nOpca	:=0
Local lRet	:= .T.

Static cLocAnt	:= ""
Static cEndeAnt	:= ""

//Ŀ
//Verifica se o usuario tem permissao de alteracao. 
//
If !(lRet := MaAvalPerm(1,{SB7->B7_COD,"MTA270",4}))
	Help(,,1,'SEMPERM')
EndIf

If lRet .And. AllTrim(SB7->(B7_ORIGEM)) == "LOGIX"
	Help(,,1,'PA270ORIGEM') //O inventrio no  pode ser alterado nem excludo, pois foi originado pelo LOGIX.
	lRet := .F.
EndIf

If lRet
	//Ŀ
	// Ativa tecla F4 para comunicacao com Saldos dos Lotes         
	//
	If ! l270Auto
		// habilita tecla <F4> na consulta de saldos existentes
		If lMV_A270F4 == NIL
			lMV_A270F4 := SuperGetMv('MV_A270F4',.F.,.T.)
		EndIf
		If lMV_A270F4 
			Set Key VK_F4 TO ShowF4()
		EndIf
	EndIf
	
	dbSelectArea("SB1")
	dbSetOrder(1)
	dbSeek(xFilial("SB1")+SB7->B7_COD)
	dbSelectArea(cAlias)
	
	//-- Variaveis que serao utilizadas na A270InTran
	cLocAnt := SB7->B7_LOCAL
	cEndeAnt := SB7->B7_LOCALIZ
	
	//Ŀ
	// Envia para rotina de Alteracao de Acerto do Inventario.      
	//
	nOpca := AxAltera(cAlias,nReg,nOpc,,,,,"A270TudoOk()","A270InTran()",,,,aRotAuto)
	
	If nOpca == 1
		A270ExePE(nOpc)
	EndIf
	
	//Ŀ
	// Desativa tecla F4 para comunicacao com Saldos dos Lotes      
	//
	If ! l270Auto
		Set Key VK_F4 To
	EndIf
EndIf

Return lRet

/*

Ŀ
Funo    A270Visual Autor Rodrigo de A. Sartorio  Data  18/03/96 
Ĵ
Descrio  Programa para visualizacao de Acerto do Inventario.        
Ĵ
Sintaxe    A270Visual(ExpC1,ExpN1,ExpN2)                              
Ĵ
Parametros ExpC1 = Alias do arquivo                                   
           ExpN1 = Numero do registro                                 
           ExpN2 = Numero da opcao selecionada                        
Ĵ
 Uso       MATA270                                                    
ٱ


*/
Function A270Visual(cAlias,nReg,nOpc)
Local nOpca:=0
dbSelectArea("SB1")
dbSetOrder(1)
dbSeek(xFilial("SB1")+SB7->B7_COD)
dbSelectArea(cAlias)
//Ŀ
// Envia para rotina de Alteracao de Acerto do Inventario.      
//
nOpca := AxVisual(cAlias,nReg,nOpc,,)
Return .T.

/*

Ŀ
Funo    A270Inclui Autor  Eveli Morasco          Data  11/03/92 
Ĵ
Descrio  Inclui digitacao do inventario                             
Ĵ
Sintaxe    A270Inclui(ExpC1,ExpN1,ExpN2)                              
Ĵ
Parametros ExpC1 = Alias do arquivo                                   
           ExpN1 = Numero do registro                                 
           ExpN2 = Numero da opcao selecionada                        
Ĵ
 Uso       Generico                                                   
ٱ


*/
Function A270Inclui(cAlias,nReg,nOpc)
Local cFilialSB5	:= xFilial("SB5")
Local cFilialSB2	:= xFilial("SB2")
Local cFilialSB1	:= xFilial("SB1")
Local nOpca			:=0	
Local dDataFec		:= MVUlmes()
Local lRet			:= .T.
Local lIntegraWMS	:= SuperGetMv('MV_WMSNEW',.F.,.F.) .AND. IntWms()
Local oProduto	:= Nil
//Ŀ
// Ativa tecla F4 para comunicacao com Saldos dos Lotes         
//
If ! l270Auto
	// habilita tecla <F4> na consulta de saldos existentes
	If lMV_A270F4 == NIL
		lMV_A270F4 := SuperGetMv('MV_A270F4',.F.,.T.)
	EndIf
	If lMV_A270F4 
		Set Key VK_F4 TO ShowF4()
	EndIf
EndIf
//Ŀ
// Verificar data do ultimo fechamento em SX6.                  
//
If dDataFec >= dDataBase
	Help ( " ", 1, "FECHTO" )
	lRet := .F.
EndIf                

If lRet
	dbSelectArea("SB2")
	dbSeek(xFilial("SB2"))
	If mv_par02 == 1 .and. Found() .And. !l270Auto //-- POR PRODUTO
		While !EOF() .And. B2_FILIAL == cFilialSB2
			dbSelectArea("SB1")
			dbSeek(cFilialSB1+SB2->B2_COD)	
			cProduto:= SB2->B2_COD				
			cLocal	 := SB2->B2_LOCAL
			If lIntegraWMS .And. IntWms(cProduto) .And. SB5->(dbSeek(cFilialSB5+cProduto))
				MTWmsPai(cProduto,@oProduto)				
				If	aScan(oProduto:aProduto,{|x| x[1] == (oProduto:GetProduto())}) = 0
					SB2->(dbSkip())
					Loop						
				EndIf			
			EndIf
			If B1_MSBLQL == "1"
				SB2->(DbSkip())
				Loop
			EndIf
			If SldBlqSB2(cProduto,cLocal)
				dbSelectArea(cAlias)
				nOpca := AxInclui(cAlias,nReg,nOpc, ,"A270Prox", ,"A270TudoOk()",,"A270InTran()")
				If nOpca == 1
					A270ExePE(nOpc)
				ElseIf nOpca == 3
					Exit
				EndIf
			Else
				dbSelectArea("SB2")
				dbSkip()
			EndIf
		EndDo
	ElseIf mv_par02 == 3 .and. Found() .And. !l270Auto //-- POR LOCALIZACAO
		dbSelectArea("SBF")
		dbSeek(xFilial("SBF"))
		While !EOF() .And. BF_FILIAL == xFilial("SBF")
			dbSelectArea("SB1")
			dbSeek(xFilial("SB1")+SBF->BF_PRODUTO)

			dbSelectArea("SB5")	
			cWMS := ""			
			If dbSeek(xFilial("SB5")+SBF->BF_PRODUTO)
				cWMS := B5_CTRWMS 
			EndIf
			If lIntegraWMS .And. cWMS == '1'
				cProduto:= SBF->BF_PRODUTO
				MTWmsPai(cProduto,@oProduto)
				If	aScan(oProduto:aProduto,{|x| x[1] == (oProduto:GetProduto())}) = 0
					dbSelectArea("SBF")
					dbSkip()
					Loop						
				EndIf
			EndIf

			cProduto:= SBF->BF_PRODUTO
			cLocal	:= SBF->BF_LOCAL
			If SldBlqSB2(cProduto,cLocal)
				dbSelectArea(cAlias)
				nOpca := AxInclui(cAlias,nReg,nOpc, ,"A270ProxSBF", ,"A270TudoOk()",,"A270InTran()")
				If nOpca == 1
					A270ExePE(nOpc)
				ElseIf nOpca == 3
					Exit
				EndIf
			Else
				dbSelectArea("SBF")
				dbSkip()
			EndIf
		EndDo
	Else
		dbSelectArea(cAlias)
		While .T.
			If ( l270Auto )
				nOpca := AxIncluiAuto(cAlias,"A270TudoOk()",,,,,,,"A270InTran()")
				If nOpca == 1
					A270ExePE(nOpc)
				EndIf
				Exit
			Else
				nOpca := AxInclui(cAlias,nReg,nOpc,,,,"A270TudoOk()",,"A270InTran()")
				If nOpca == 1
					A270ExePE(nOpc)
				ElseIf nOpca == 3
					Exit
				EndIf
			EndIf
		End
	EndIf
	//Ŀ
	// Desativa tecla F4 para comunicacao com Saldos dos Lotes      
	//
	If ! l270Auto
		Set Key VK_F4 To
	EndIf
EndIf
Return lRet

/*

Ŀ
Funo    A270Deleta Autor  Eveli Morasco          Data  11/03/92 
Ĵ
Descrio  Programa de exclusao de Inventario                         
Ĵ
Sintaxe    A270Deleta(ExpC1,ExpN1,ExpN2)                              
Ĵ
Parametros ExpC1 = Alias do arquivo                                   
           ExpN1 = Numero do registro                                 
           ExpN2 = Numero da opcao selecionada                        
Ĵ
 Uso       Generico                                                   
ٱ


*/
Function A270Deleta(cAlias,nReg,nOpc)
Local nOpcA		:= 0
Local dDataFec	:= MVUlmes(),cOldAlias:=Alias()
Local lRet		:= .T.
Local aParam 	:= {{|| .T.},{|| A270TDOK()}, {|| .T.}, {|| .T.}} 
Local aArea		:= GetArea()     
Local lWmsNew := SuperGetMv("MV_WMSNEW",.F.,.F.) 

//Ŀ
//Verifica se o usuario tem permissao de delecao. 
//

If !(lRet := MaAvalPerm(1,{SB7->B7_COD,"MTA270",5}))
	Help(,,1,'SEMPERM')
EndIf
//Ŀ
// Verificar data do ultimo fechamento em SX6.                  
//
If dDataFec >= dDataBase
	Help ( " ", 1, "FECHTO" )
	lRet := .F.
EndIf

If lRet .And. AllTrim(SB7->(B7_ORIGEM)) == "LOGIX"
	Help(,,1,'PA270ORIGEM') //O inventrio no  pode ser alterado nem excludo, pois foi originado pelo LOGIX.                                          
	lRet := .F.
EndIf

If lRet
	dbSelectArea("SB1")
	dbSeek(xFilial("SB1")+SB7->B7_COD)
	dbSelectArea(cOldAlias)
	     
	//Ŀ
	//Abre tela para confirmao da excluso 
	//
	nOpcA:= AxDeleta(cAlias,nReg,nOpc,"A270InTran()",,,aParam,aRotAuto)
	
	If nOpcA == 2
		A270ExePE(nOpc)
	EndIf
EndIf

DbSelectArea(cAlias)
RestArea(aArea)

Return lRet

/*

Ŀ
Funo     A270Prox  Autor  Eveli Morasco          Data  11/03/92 
Ĵ
Descrio  Apenas para inicializar algumas variaveis                  
Ĵ
 Uso       MATA270                                                    
ٱ


*/
Function A270Prox()
Local aArea:=GetArea()
M->B7_COD   := SB2->B2_COD
M->B7_LOCAL := SB2->B2_LOCAL
M->B7_TIPO  := SB1->B1_TIPO
dbSelectArea("SX3")
dbSetOrder(2)
If dbSeek("B7_DOC") .And. Empty(X3_RELACAO)
	M->B7_DOC := SB7->B7_DOC
EndIf
RestArea(aArea)
Return

/*

-Ŀ
Funo     A270ProxSBF  Autor  Fernando Gomes      Data  10/01/07 
-Ĵ
Descrio  Apenas para inicializar algumas variaveis                  
Ĵ
 Uso       MATA270                                                    
ٱ


*/
FUNCTION A270ProxSBF
Local aArea:=GetArea()
M->B7_COD     := SBF->BF_PRODUTO
M->B7_LOCAL   := SBF->BF_LOCAL
M->B7_LOCALIZ := SBF->BF_LOCALIZ
RestArea(aArea)
RETURN
/*

Ŀ
Funo    A270IniCpo Autor  Eveli Morasco          Data  11/03/92 
Ĵ
Descrio  Inicializa campos a partir do codigo do produto            
Ĵ
Retorno    .T. / .F.                                                  
Ĵ
 Uso       MATA270                                                    
ٱ


*/
Function A270IniCpo()
Local oProdComp
Local nEndereco,nEnd1,nEnd2,nLinha
Local lRet		:= .T.
Local aAreaSB2	:= SB2->(GetArea())
Local aAreaSB1	:= SB1->(GetArea())
Local lWmsNew	:= SuperGetMv("MV_WMSNEW",.F.,.F.)
Local cPrdOri	:= M->B7_COD

If lWmsNew
	oProdComp := WMSDTCProdutoComponente():New()
EndiF

If !ExistCpo("SB1")
	lRet := .F.
EndIf
//Ŀ
//Verifica se o usuario tem permissao de inclusao. 
//
If lRet 
	If !(MaAvalPerm(1,{M->B7_COD,"MTA270",3}))
		Help(,,1,'SEMPERM')
		lRet :=	.F.
	EndIf
EndIf
If lRet
	dbSelectArea("SB2")
	SB2->(dbSetOrder(1))
	If !dbSeek(xFilial("SB2")+M->B7_COD)
		If mv_par01 == 1
			If lWmsNew .And. IntDl(M->B7_COD)
				oProdComp:SetPrdCmp(M->B7_COD)
				If oProdComp:LoadData(2)
					cPrdOri := oProdComp:GetPrdOri()
				EndIf
				
				If !dbSeek(xFilial("SB2")+cPrdOri)
					Help(" ",1,"MA270NSB2")
					lRet := .F.
				EndIf
			Else
				Help(" ",1,"MA270NSB2")
				lRet := .F.
			EndIf
		EndIf
	Else
		M->B7_LOCAL := B2_LOCAL
		nEndereco := Ascan(aGets,{ |x| Subs(x,9,8) == "B7_LOCAL" } )
		If nEndereco > 0
			aTela[Val(Subs(aGets[nEndereco],1,2))][Val(Subs(aGets[nEndereco],3,1))*2] := B2_LOCAL
		EndIf
	EndIf
	
	If lRet
		dbSelectArea("SB1")
		dbSeek(xFilial("SB1")+M->B7_COD)
		M->B7_TIPO := B1_TIPO

		if !empty(SB1->B1_LOCPAD)
			M->B7_LOCAL := SB1->B1_LOCPAD
		endif

		nEndereco := Ascan(aGets,{ |x| Subs(x,9,7) == "B7_TIPO" } )
		If nEndereco > 0
			aTela[Val(Subs(aGets[nEndereco],1,2))][Val(Subs(aGets[nEndereco],3,1))*2] := B1_TIPO
		EndIf
		M->B7_QTSEGUM := ConvUm(SB1->B1_COD,M->B7_QUANT,M->B7_QTSEGUM,2)
		nEndereco := Ascan(aGets,{ |x| Subs(x,9,10) == "B7_QTSEGUM" } )
		If nEndereco > 0
			nEnd1 := Val(Subs(aGets[nEndereco],1,2))
			nEnd2 := Val(Subs(aGets[nEndereco],3,1))*2
			dbSelectArea("SX3")
			dbSetOrder(2)
			dbSeek("B2_QTSEGUM")
			dbSetOrder(1)
			aTela[nEnd1][nEnd2] := Trans(M->B7_QTSEGUM,Trim(SX3->X3_PICTURE))
		EndIf
		M->B7_NUMLOTE := CriaVar("B7_NUMLOTE")
		nEndereco := Ascan(aGets,{ |x| Subs(x,9,10) == "B7_NUMLOTE" } )
		If nEndereco > 0
			aTela[Val(Subs(aGets[nEndereco],1,2))][Val(Subs(aGets[nEndereco],3,1))*2] := M->B7_NUMLOTE
		EndIf
		M->B7_LOTECTL := CriaVar("B7_LOTECTL")
		nEndereco := Ascan(aGets,{ |x| Subs(x,9,10) == "B7_LOTECTL" } )
		If nEndereco > 0
			aTela[Val(Subs(aGets[nEndereco],1,2))][Val(Subs(aGets[nEndereco],3,1))*2] := M->B7_LOTECTL
		EndIf
		M->B7_DTVALID := CriaVar("B7_DTVALID")
		nEndereco := Ascan(aGets,{ |x| Subs(x,9,10) == "B7_DTVALID" } )
		If nEndereco > 0
			aTela[Val(Subs(aGets[nEndereco],1,2))][Val(Subs(aGets[nEndereco],3,1))*2] := DTOC(M->B7_DTVALID)
		EndIf		
		M->B7_LOCALIZ := CriaVar("B7_LOCALIZ")
		nEndereco := Ascan(aGets,{ |x| Subs(x,9,10) == "B7_LOCALIZ" } )
		If nEndereco > 0
			aTela[Val(Subs(aGets[nEndereco],1,2))][Val(Subs(aGets[nEndereco],3,1))*2] := M->B7_LOCALIZ
		EndIf
		M->B7_NUMSERI := CriaVar("B7_NUMSERI")
		nEndereco := Ascan(aGets,{ |x| Subs(x,9,10) == "B7_NUMSERI" } )
		If nEndereco > 0
			aTela[Val(Subs(aGets[nEndereco],1,2))][Val(Subs(aGets[nEndereco],3,1))*2] := M->B7_NUMSERI
		EndIf
	EndIf
EndIf
RestArea(aAreaSB2)
Return lRet

/*

Ŀ
Funo    A270Local  Autor Rodrigo de A Sartorio   Data  28/04/04 
Ĵ
Descrio  Valida campo de armazem                                    
Ĵ
Retorno    .T. / .F.                                                  
Ĵ
 Uso       MATA270                                                    
ٱ


*/
Function A270Local()
Local oProdComp 
Local lRet		:= .T.
Local lWmsNew	:= SuperGetMv("MV_WMSNEW",.F.,.F.)
Local cPrdOri	:= M->B7_COD

If lWmsNew
	oProdComp := WMSDTCProdutoComponente():New()
EndiF

If mv_par01 == 1
	dbSelectArea("SB2")
	If !dbSeek(xFilial("SB2")+M->B7_COD+M->B7_LOCAL)
		If lWmsNew .And. IntDl(M->B7_COD)
			oProdComp:SetPrdCmp(M->B7_COD)
			If oProdComp:LoadData(2)
				cPrdOri := oProdComp:GetPrdOri()
			EndIf
			
			If !dbSeek(xFilial("SB2")+cPrdOri+M->B7_LOCAL)
				Help(" ",1,"MA270NSB2")
				lRet := .F.
			EndIf
		Else
			Help(" ",1,"MA270NSB2")
			lRet := .F.
		EndIf
	EndIf
EndIf
Return(lRet)

/*

Ŀ
Funo    A270Conv   Autor  Eveli Morasco          Data  11/03/92 
Ĵ
Descrio  Calcula e inicializa a quantidade principal ou secundaria  
Ĵ
 Uso       MATA270                                                    
ٱ


*/
Function A270Conv()
Local nEndereco,nEnd1,nEnd2,nX
Local cQual,nQuant
cQual  := Subs(ReadVar(),4,Len(ReadVar()))
dbSelectArea("SB1")
dbSeek(xFilial("SB1")+M->B7_COD)
If cQual == "B7_QUANT"
	nQuant := M->B7_QTSEGUM := ConvUm(B1_COD,M->B7_QUANT,M->B7_QTSEGUM,2)
	cQual  := "B7_QTSEGUM"
Else
	nQuant := M->B7_QUANT   := ConvUm(B1_COD,M->B7_QUANT,M->B7_QTSEGUM,1)
	cQual  := "B7_QUANT"
EndIf
nEndereco := Ascan(aGets,{ |x| Subs(x,9,Len(cQual)) == cQual } )
If nEndereco > 0
	nEnd1 := Val(Subs(aGets[nEndereco],1,2))
	nEnd2 := Val(Subs(aGets[nEndereco],3,1))*2
	dbSelectArea("SX3")
	dbSetOrder(2)
	dbSeek(cQual)
	dbSetOrder(1)
	aTela[nEnd1][nEnd2] := Trans(nQuant,Trim(SX3->X3_PICTURE))
EndIf
Return .T.

/*

Ŀ
Funo    A270VldLot Autor  Rodrigo de A. Sartorio Data  16/04/96 
Ĵ
Descrio  Valida o numero do lote com o produto.                     
Ĵ
Retorno    .T. / .F.                                                  
Ĵ
 Uso       MATA270                                                    
ٱ


*/
Function A270VldLot()
Local oProdComp 
Local cLote    :=&(ReadVar()),nEndereco,lRet:=.T.
Local cOldAlias:=Alias(),nOldOrder,nOldRecno
Local cLocalCQ := GetMvNNR('MV_CQ','98')
Local lWmsNew := SuperGetMv("MV_WMSNEW",.F.,.F.)
Local lAchou := .F. 

If lWmsNew
	oProdComp := WMSDTCProdutoComponente():New()
EndiF

If Rastro(M->B7_COD)
	If "M->B7_NUMLOTE" $ ReadVar()
		If Rastro( M->B7_COD, "S" )
			dbSelectArea("SB8")
			nOldOrder:=IndexOrd()
			nOldRecno:=Recno()
			dbSetOrder(2)
			If dbSeek(xFilial("SB8")+cLote) .And. B8_PRODUTO + B8_LOCAL == ;
					M->B7_COD + M->B7_LOCAL
				If cLocalCQ == B8_LOCAL .And. B8_ORIGLAN != "CQ"
					Help (" ",1,"A270LOTCQ")
					lRet:=.F.
				EndIf
				If lRet
					nEndereco := Ascan(aGets,{ |x| Subs(x,9,10) == "B7_NUMLOTE" } )
					If nEndereco > 0
						aTela[Val(Subs(aGets[nEndereco],1,2))][Val(Subs(aGets[nEndereco],3,1))*2] := M->B7_NUMLOTE
					EndIf
					M->B7_LOTECTL:=SB8->B8_LOTECTL
					nEndereco := Ascan(aGets,{ |x| Subs(x,9,10) == "B7_LOTECTL" } )
					If nEndereco > 0
						aTela[Val(Subs(aGets[nEndereco],1,2))][Val(Subs(aGets[nEndereco],3,1))*2] := B8_LOTECTL
					EndIf
					M->B7_DTVALID:=SB8->B8_DTVALID
					nEndereco := Ascan(aGets,{ |x| Subs(x,9,10) == "B7_DTVALID" } )
					If nEndereco > 0
						aTela[Val(Subs(aGets[nEndereco],1,2))][Val(Subs(aGets[nEndereco],3,1))*2] := DTOC(B8_DTVALID)
					EndIf

					M->B7_NUMDOC:=SB8->B8_DOC
					nEndereco := Ascan(aGets,{ |x| Subs(x,9,10) == "B7_NUMDOC " } )
					If nEndereco > 0
						aTela[Val(Subs(aGets[nEndereco],1,2))][Val(Subs(aGets[nEndereco],3,1))*2] := B8_DOC
					EndIf

					M->B7_SERIE:=SB8->B8_SERIE
					nEndereco := Ascan(aGets,{ |x| Subs(x,9,10) == "B7_SERIE  " } )
					If nEndereco > 0
						aTela[Val(Subs(aGets[nEndereco],1,2))][Val(Subs(aGets[nEndereco],3,1))*2] := SerieNfId("SB8",2,"B8_SERIE")
					EndIf

					M->B7_FORNECE:=SB8->B8_CLIFOR
					nEndereco := Ascan(aGets,{ |x| Subs(x,9,10) == "B7_FORNECE" } )
					If nEndereco > 0
						aTela[Val(Subs(aGets[nEndereco],1,2))][Val(Subs(aGets[nEndereco],3,1))*2] := B8_CLIFOR
					EndIf

					M->B7_LOJA:=SB8->B8_LOJA
					nEndereco := Ascan(aGets,{ |x| Subs(x,9,10) == "B7_LOJA   " } )
					If nEndereco > 0
						aTela[Val(Subs(aGets[nEndereco],1,2))][Val(Subs(aGets[nEndereco],3,1))*2] := B8_LOJA
					EndIf

				EndIf
			Else
				If mv_par01 == 1
					Help (" ",1,"A270LOTERR")
					lRet:=.F.
				EndIf
				nEndereco := Ascan(aGets,{ |x| Subs(x,9,10) == "B7_NUMLOTE" } )
				If nEndereco > 0
					M->B7_NUMLOTE:=aTela[Val(Subs(aGets[nEndereco],1,2))][Val(Subs(aGets[nEndereco],3,1))*2]
				EndIf
				nEndereco := Ascan(aGets,{ |x| Subs(x,9,10) == "B7_LOTECTL" } )
				If nEndereco > 0
					M->B7_LOTECTL:=aTela[Val(Subs(aGets[nEndereco],1,2))][Val(Subs(aGets[nEndereco],3,1))*2]
				EndIf
			EndIf
			dbSetOrder(nOldOrder)
			dbGoto(nOldRecno)
		Else
			nEndereco := Ascan(aGets,{ |x| Subs(x,9,10) == "B7_NUMLOTE" } )
			If nEndereco > 0
				aTela[Val(Subs(aGets[nEndereco],1,2))][Val(Subs(aGets[nEndereco],3,1))*2] := CriaVar("B7_NUMLOTE")
			EndIf
			M->B7_NUMLOTE := CriaVar( "B7_NUMLOTE" )
		EndIf
	Else
		If Rastro( M->B7_COD, "S" )
			dbSelectArea( "SB8" )
			dbSetOrder( 3 )
			
			If Empty(M->B7_NUMLOTE)
				lAchou := dbSeek( xFilial( "SB8" ) + M->B7_COD + M->B7_LOCAL + cLote)
			Else
				lAchou := dbSeek( xFilial( "SB8" ) + M->B7_COD + M->B7_LOCAL + cLote + M->B7_NUMLOTE)
			EndIf	

			If lWmsNew .And. IntDl(M->B7_COD) .And. !lAchou
				oProdComp:SetPrdCmp(M->B7_COD)
				If oProdComp:LoadData(2)
					lAchou := dbSeek( xFilial( "SB8" ) + oProdComp:GetPrdOri() + M->B7_LOCAL + cLote )
				EndIf
			EndIf
						
			If lAchou 
				If !Empty(M->B7_NUMLOTE)
					nEndereco := Ascan(aGets,{ |x| Subs(x,9,10) == "B7_NUMLOTE" } )
					If nEndereco > 0
						aTela[Val(Subs(aGets[nEndereco],1,2))][Val(Subs(aGets[nEndereco],3,1))*2] := B8_NUMLOTE
					EndIf
					M->B7_NUMLOTE := SB8->B8_NUMLOTE
					nEndereco := Ascan(aGets,{ |x| Subs(x,9,10) == "B7_DTVALID" } )
					If nEndereco > 0
						aTela[Val(Subs(aGets[nEndereco],1,2))][Val(Subs(aGets[nEndereco],3,1))*2] := DTOC(B8_DTVALID)
					EndIf
					M->B7_DTVALID := SB8->B8_DTVALID
					M->B7_NUMDOC:=SB8->B8_DOC
					nEndereco := Ascan(aGets,{ |x| Subs(x,9,10) == "B7_NUMDOC " } )
					If nEndereco > 0
						aTela[Val(Subs(aGets[nEndereco],1,2))][Val(Subs(aGets[nEndereco],3,1))*2] := B8_DOC
					EndIf

					M->B7_SERIE:=SB8->B8_SERIE
					nEndereco := Ascan(aGets,{ |x| Subs(x,9,10) == "B7_SERIE  " } )
					If nEndereco > 0
						aTela[Val(Subs(aGets[nEndereco],1,2))][Val(Subs(aGets[nEndereco],3,1))*2] := SerieNfId("SB8",2,"B8_SERIE")
					EndIf

					M->B7_FORNECE:=SB8->B8_CLIFOR
					nEndereco := Ascan(aGets,{ |x| Subs(x,9,10) == "B7_FORNECE" } )
					If nEndereco > 0
						aTela[Val(Subs(aGets[nEndereco],1,2))][Val(Subs(aGets[nEndereco],3,1))*2] := B8_CLIFOR
					EndIf

					M->B7_LOJA:=SB8->B8_LOJA
					nEndereco := Ascan(aGets,{ |x| Subs(x,9,10) == "B7_LOJA   " } )
					If nEndereco > 0
						aTela[Val(Subs(aGets[nEndereco],1,2))][Val(Subs(aGets[nEndereco],3,1))*2] := B8_LOJA
					EndIf
				EndIf	
			Else
				If mv_par01 == 1
					Help (" ",1,"A270LOTERR")
					lRet := .F.
				EndIf
			EndIf
		Else
			dbSelectArea( "SB8" )
			dbSetOrder( 3 )
			lAchou := dbSeek( xFilial( "SB8" ) + M->B7_COD + M->B7_LOCAL + cLote )
			If !lAchou 					// Se o lote no existe no armazem, busca e assume a data de validade do lote em 
				dbSetOrder( 5 )			// qualquer armazem caso exista
				If dbSeek( xFilial( "SB8" ) + M->B7_COD + cLote + M->B7_NUMLOTE)
					M->B7_DTVALID := B8_DTVALID
					lAchou := .T.
				EndIf
			EndIf

			If lWmsNew .And. IntDl(M->B7_COD) .And. !lAchou
				oProdComp:SetPrdCmp(M->B7_COD)
				If oProdComp:LoadData(2)
					dbSetOrder( 3 )
					lAchou := dbSeek( xFilial( "SB8" ) + oProdComp:GetPrdOri() + M->B7_LOCAL + cLote )
					If !lAchou 		// Se o lote no existe no armazem, busca e assume a data de validade do lote em 
						dbSetOrder( 5 )	
						lAchou := dbSeek( xFilial( "SB8" ) + oProdComp:GetPrdOri() + cLote )
					EndIf 
				EndIf
			EndIf
			
			If lAchou
				nEndereco := Ascan(aGets,{ |x| Subs(x,9,10) == "B7_DTVALID" } )
				If nEndereco > 0
					aTela[Val(Subs(aGets[nEndereco],1,2))][Val(Subs(aGets[nEndereco],3,1))*2] := DTOC(B8_DTVALID)
				EndIf
				M->B7_DTVALID := SB8->B8_DTVALID

				M->B7_NUMDOC:=SB8->B8_DOC
				nEndereco := Ascan(aGets,{ |x| Subs(x,9,10) == "B7_NUMDOC " } )
				If nEndereco > 0
					aTela[Val(Subs(aGets[nEndereco],1,2))][Val(Subs(aGets[nEndereco],3,1))*2] := B8_DOC
				EndIf

				M->B7_SERIE:=SB8->B8_SERIE
				nEndereco := Ascan(aGets,{ |x| Subs(x,9,10) == "B7_SERIE  " } )
				If nEndereco > 0
					aTela[Val(Subs(aGets[nEndereco],1,2))][Val(Subs(aGets[nEndereco],3,1))*2] := SerieNfId("SB8",2,"B8_SERIE")
				EndIf

				M->B7_FORNECE:=SB8->B8_CLIFOR
				nEndereco := Ascan(aGets,{ |x| Subs(x,9,10) == "B7_FORNECE" } )
				If nEndereco > 0
					aTela[Val(Subs(aGets[nEndereco],1,2))][Val(Subs(aGets[nEndereco],3,1))*2] := B8_CLIFOR
				EndIf

				M->B7_LOJA:=SB8->B8_LOJA
				nEndereco := Ascan(aGets,{ |x| Subs(x,9,10) == "B7_LOJA   " } )
				If nEndereco > 0
					aTela[Val(Subs(aGets[nEndereco],1,2))][Val(Subs(aGets[nEndereco],3,1))*2] := B8_LOJA
				EndIf

			Else
				If mv_par01 == 1
					Help (" ",1,"A270LOTERR")
					lRet := .F.
				EndIf
			EndIf
		EndIf
	EndIf
Else
	//Ŀ
	// Se nao utiliza rastreabilidade 
	//
	Help (" ",1,"A270LOTEIG")
	M->B7_NUMLOTE:=CriaVar("B8_NUMLOTE")
	nEndereco := Ascan(aGets,{ |x| Subs(x,9,10) == "B7_NUMLOTE" } )
	If nEndereco > 0
		aTela[Val(Subs(aGets[nEndereco],1,2))][Val(Subs(aGets[nEndereco],3,1))*2] := M->B7_NUMLOTE
	EndIf
	M->B7_LOTECTL:=CriaVar("B8_LOTECTL")
	nEndereco := Ascan(aGets,{ |x| Subs(x,9,10) == "B7_LOTECTL" } )
	If nEndereco > 0
		aTela[Val(Subs(aGets[nEndereco],1,2))][Val(Subs(aGets[nEndereco],3,1))*2] := M->B7_LOTECTL
	EndIf
	M->B7_DTVALID:=CriaVar("B8_DTVALID")
	nEndereco := Ascan(aGets,{ |x| Subs(x,9,10) == "B7_DTVALID" } )
	If nEndereco > 0
		aTela[Val(Subs(aGets[nEndereco],1,2))][Val(Subs(aGets[nEndereco],3,1))*2] := DTOC(M->B7_DTVALID)
	EndIf
EndIf
dbSelectArea(cOldAlias)
Return lRet

/*

Ŀ
Funo    A270NumSer Autor Tatiane Marques Santos  Data  03/07/08 
Ĵ
Descrio  Verifica prenchimento do campo serie                       
Ĵ
Retorno    .T. / .F.                                                  
Ĵ
 Uso       MATA270                                                    
ٱ


*/
Function A270NumSer()
//Local cVar	:=ReadVar(),cConteudo:=&(ReadVar())
Local cAlias	:= Alias()
Local nRecno	:= Recno()
Local nOrdem	:= IndexOrd()
Local cCod		:= M->B7_COD
Local lRet		:= .T.
Local lWmsNew	:= SuperGetMv("MV_WMSNEW",.F.,.F.)

If !Localiza(cCod,IIF((lWmsNew .And. IntDl(cCod)),.T.,.F.),.F.)
	//Ŀ
	// Se nao controla endereco 
	//
	Help (" ",1,"A270LOCAIG")	
	M->B7_LOCALIZ := CriaVar("B7_LOCALIZ")
	nEndereco := Ascan(aGets,{ |x| Subs(x,9,10) == "B7_LOCALIZ" } )
	If nEndereco > 0
		aTela[Val(Subs(aGets[nEndereco],1,2))][Val(Subs(aGets[nEndereco],3,1))*2] := M->B7_LOCALIZ
	EndIf
	M->B7_NUMSERI := CriaVar("B7_NUMSERI")
	nEndereco := Ascan(aGets,{ |x| Subs(x,9,10) == "B7_NUMSERI" } )
	If nEndereco > 0
		aTela[Val(Subs(aGets[nEndereco],1,2))][Val(Subs(aGets[nEndereco],3,1))*2] := M->B7_NUMSERI
	EndIf
EndIf
dbSelectArea(cAlias)
dbSetOrder(nOrdem)
dbGoTo(nRecno)
Return lRet

/*

Ŀ
Funo    A270Locali Autor  Emerson Rony Oliveira  Data 29/10/2008
Ĵ
Descriao  Validacao do campo B7_LOCALIZ                              
Ĵ
Retorno    .T. / .F.                                                  
Ĵ
 Uso       MATA270                                                    
ٱ

*/
Function A270Locali()
Local cAlias := Alias()
Local nRecno := Recno()
Local nOrdem := IndexOrd()
Local lRet   := .T.
Local cCod    := M->B7_COD
Local lWmsNew := SuperGetMv("MV_WMSNEW",.F.,.F.)

//original : IF(Localiza(M->B7_COD),Vazio() .Or. ExistCpo("SBE",M->B7_LOCAL+M->B7_LOCALIZ),Vazio())
If Localiza(cCod,IIF((lWmsNew .And. IntDl(cCod)),.T.,.F.),.F.)//Alterado para WMS
	//Ŀ
	// Verifica a existencia do endereco informado. 	|
	//
	If !Empty(M->B7_LOCALIZ) .And. !ExistCpo("SBE",M->B7_LOCAL+M->B7_LOCALIZ,1)
		lRet:=.F.
	EndIf
Else
	//Ŀ
	// Se nao controla endereco 
	//
	Help (" ",1,"A270LOCAIG")	
	M->B7_LOCALIZ := CriaVar("B7_LOCALIZ")
	nEndereco := Ascan(aGets,{ |x| Subs(x,9,10) == "B7_LOCALIZ" } )
	If nEndereco > 0
		aTela[Val(Subs(aGets[nEndereco],1,2))][Val(Subs(aGets[nEndereco],3,1))*2] := M->B7_LOCALIZ
	EndIf
	M->B7_NUMSERI := CriaVar("B7_NUMSERI")
	nEndereco := Ascan(aGets,{ |x| Subs(x,9,10) == "B7_NUMSERI" } )
	If nEndereco > 0
		aTela[Val(Subs(aGets[nEndereco],1,2))][Val(Subs(aGets[nEndereco],3,1))*2] := M->B7_NUMSERI
	EndIf
EndIf

dbSelectArea(cAlias)
dbSetOrder(nOrdem)
dbGoTo(nRecno)

Return lRet

/*

Ŀ
Funo    A270TudoOk Autor     Marcos Simidu       Data  03/12/96 
Ĵ
Descrio  Valida se o produto ja esta cadastrado nesta data          
Ĵ
Retorno    .T. / .F.                                                  
Ĵ
 Uso       MATA270                                                    
ٱ


*/
Function A270TudoOk()
Local lRet      := .T.
Local aArea     := GetArea()
Local dDataFec  := MVUlmes()
Local nOldOrder
Local nOldRecno
Local lWmsNew	:= SuperGetMv("MV_WMSNEW",.F.,.F.)
Local oProdComp 
Local cPrdOri	:= ""
Local xRet	:= 0
Local xRet1	:= 1

If lWmsNew .And. IntDl(M->B7_COD)
	oProdComp := WMSDTCProdutoComponente():New()
EndiF

//Ŀ
//Verifica se tem permissao de armazem  |
//
lRet := MaAvalPerm(3,{M->B7_LOCAL,M->B7_COD})
//Ŀ
// Verificar data do ultimo fechamento em SX6.                  
//
If dDataFec >= M->B7_DATA
	Help ( " ", 1, "FECHTO" )
	lRet := .F.
EndIf

If lRet
	lRet := SldBlqSB2(M->B7_COD,M->B7_LOCAL)
EndIf

If lRet .And. Rastro(M->B7_COD)
	//Ŀ
	// Valida o conteudo dos campos B7_LOTECTL/B7_NUMLOTE	 |
	//
	If Empty(M->B7_LOTECTL)
		Help("",1,"A270LOTOBR")
		lRet:=.F.
	EndIf
	If lRet .And. Rastro(M->B7_COD,"S")
		If Empty(M->B7_NUMLOTE)		
			Help("",1, "A270SUBLOT", , STR0035, 1, 0, , , ,, , {STR0036})   
			lRet:=.F.
		EndIf
	ElseIf lRet .And. !Empty(M->B7_NUMLOTE)
		Help("",1,"A270NLOTE")
		M->B7_NUMLOTE := CriaVar("B7_NUMLOTE",.F.)
	EndIf

	If lRet
		dbSelectArea("SB8")
		nOldOrder:=IndexOrd()
		nOldRecno:=Recno()
		If Rastro(M->B7_COD,"S")
			dbSetOrder(2)
			If dbSeek(xFilial("SB8")+M->B7_NUMLOTE+M->B7_LOTECTL+M->B7_COD+M->B7_LOCAL)
				//Ŀ
				// Ajusta a data de validade para data original |
				//
				If !(M->B7_DTVALID == SB8->B8_DTVALID)
					If !l270Auto
						Help("",1,"A240DTVALI")
					EndIf
					M->B7_DTVALID := SB8->B8_DTVALID
				EndIf
			Else
				If lWmsNew .And. IntDl(M->B7_COD)
					oProdComp:SetPrdCmp(M->B7_COD)
					cPrdOri := M->B7_COD
					If oProdComp:LoadData(2)
						cPrdOri := oProdComp:GetPrdOri()
					EndIf
					If dbSeek(xFilial("SB8")+cPrdOri+M->B7_LOCAL+M->B7_LOTECTL)
						//Ŀ
						// Ajusta a data de validade para data original |
						//
						If !(M->B7_DTVALID == SB8->B8_DTVALID)
							If !l270Auto
								Help("",1,"A240DTVALI")
							EndIf
							M->B7_DTVALID := SB8->B8_DTVALID
						EndIf
					Else
						If mv_par01 == 1
							lRet:=.F.
						EndIf
					EndIf
				Else
					If mv_par01 == 1
						lRet:=.F.
					EndIf
				EndIf
			EndIf
		Else
			dbSetOrder(3)
			If dbSeek(xFilial("SB8")+M->B7_COD+M->B7_LOCAL+M->B7_LOTECTL)
				//Ŀ
				// Ajusta a data de validade para data original |
				//
				If !(M->B7_DTVALID == SB8->B8_DTVALID)
					If !l270Auto
						Help("",1,"A240DTVALI")
					EndIf
					M->B7_DTVALID := SB8->B8_DTVALID
				EndIf
			Else
				If lWmsNew .And. IntDl(M->B7_COD)
					oProdComp:SetPrdCmp(M->B7_COD)
					cPrdOri := M->B7_COD
					If oProdComp:LoadData(2)
						cPrdOri := oProdComp:GetPrdOri()
					EndIf
					If dbSeek(xFilial("SB8")+cPrdOri+M->B7_LOCAL+M->B7_LOTECTL)
						//Ŀ
						// Ajusta a data de validade para data original |
						//
						If !(M->B7_DTVALID == SB8->B8_DTVALID)
							If !l270Auto
								Help("",1,"A240DTVALI")
							EndIf
							M->B7_DTVALID := SB8->B8_DTVALID
						EndIf
					Else
						If mv_par01 == 1
							lRet:=.F.
						EndIf
					EndIf
				Else
					If mv_par01 == 1
						lRet:=.F.
					EndIf
			EndIf
		EndIf
		If !lRet
			Help("",1,"A270LOTERR")
		EndIf
		dbSetOrder(nOldOrder)
		dbGoTo(nOldRecno)
	EndIf
	Else
		lLote:=.T.
	EndIf
EndIf
If lRet .And. Localiza(M->B7_COD)
	If lRet .And. (Empty(M->B7_LOCALIZ) .And. Empty(M->B7_NUMSERI))
		Help(" ",1,"LOCALIZOBR")
		lRet:=.F.
	EndIf
	//Ŀ
	// Verifica a existencia do endereco informado. 	|
	//
	If lRet .And. !Empty(M->B7_LOCALIZ) .And. !ExistCpo("SBE",M->B7_LOCAL+M->B7_LOCALIZ,1)
		lRet:=.F.
	EndIf
	If lRet .And. IntDL(M->B7_COD) .And. !Empty(M->B7_TPESTR)
		SBE->(dbSetOrder(1))
		If SBE->(dbSeek(xFilial("SBE")+M->B7_LOCAL+M->B7_LOCALIZ) .And. BE_ESTFIS<>M->B7_TPESTR)
			Help( " ", 1, "REGNOIS",, RetTitle("B7_TPESTR"), 4, 1 )
			lRet:=.F.
		EndIf
	EndIf
	If lRet .And. !Empty(M->B7_NUMSERI)
		dbSelectArea("SB1")
		dbSetOrder(1)
		If dbSeek(xFilial("SB1")+M->B7_COD)
			If(ValType(SB1->B1_QTDSER)) == "C"
				xRet1:= AllTrim(Str(xRet1))
				xRet:= AllTrim(Str(xRet))
			EndIf
			If SB1->B1_QTDSER == xRet1 .Or. SB1->B1_QTDSER == xRet
				If M->B7_QUANT # 1 .And. M->B7_QUANT # 0
					Help(" ",1,"QUANTSERIE")
					lRet:=.F.
				EndIf
			Else
				If M->B7_QTSEGUM # 1 .And. M->B7_QTSEGUM # 0
					Help(" ",1,"QUANTSERIE")
					lRet:=.F.
				EndIf
			EndIf
		EndIf
		// Valida se existe uma digitacao para o mesmo numero de serie na mesma data
		If lRet .And. Inclui
			If FWIsInCallStack('AcdvGSB7')
				lRet := VldJaGrv(IIF(UsaContage(),M->B7_CONTAGE,Space(Len(M->B7_CONTAGE))))
			Else
				SB7->(dbSetOrder(1))
				If SB7->(dbSeek(xFilial("SB7")+DTOS(M->B7_DATA)+M->B7_COD+M->B7_LOCAL+M->B7_LOCALIZ+M->B7_NUMSERI+M->B7_LOTECTL+M->B7_NUMLOTE+IIF(UsaContage(),M->B7_CONTAGE,"")))
					Help(" ",1,"JAGRAVADO")
					lRet:=.F.
				EndIf
			EndIf
		EndIf
	EndIf
EndIf

// Valida contagem
If lRet .And. UsaContage()
	lRet := A270VlCont(M->B7_CONTAGE)
EndIf

If lRet .And. ExistBlock("MA270TOK")
	lRet := ExecBlock("MA270TOK",.F.,.F.)
	If ValType(lRet)#'L'
		lRet := .T.
	EndIf
EndIf

If lRet .And. ExistTemplate("MA270TOK")
	lRet := ExecTemplate("MA270TOK",.F.,.F.,{M->B7_COD})	
EndIf

If lRet
	If FindFunction("WmsVldAbas")
		lRet := WmsVldAbas(M->B7_LOCAL, M->B7_COD, M->B7_LOCALIZ)
	EndIf
EndIf

RestArea(aArea)
Return lRet

/*


Ŀ
Funo     SHOWF4    Autor  Rodrigo de A. Sartorio Data  29/11/95 
Ĵ
Descrio  Chamada da funcao F4LOTE                                   
Ĵ
 Uso       MATA270                                                    
ٱ


*/
Static Function ShowF4()

If AllTrim(Upper(ReadVar())) $ 'M->B7_NUMLOTEM->B7_LOTECTL'
	F4Lote(,,,"A270",M->B7_COD,M->B7_LOCAL,.F.)
ElseIf AllTrim(Upper(ReadVar())) $ 'M->B7_LOCALIZ'
	F4Localiz(,,,"A270",M->B7_COD,M->B7_LOCAL)
EndIf
Return NIL

/*


Ŀ
Funo    MTA270PERG Autor  Rodrigo de A. Sartorio Data  16/04/01 
Ĵ
Descrio  Chamada da funcao PERGUNTE                                 
Ĵ
 Uso       MATA270                                                    
ٱ


*/
Static Function MTA270PERG()
Pergunte("MTA270",.T.)
Return NIL

/*


Ŀ
Funo    A270TDOK   Autor  Rodrigo de A. Sartorio Data  21/05/04 
Ĵ
Descrio  Chamada da funcao para validar se exclui ou nao registro   
Ĵ
Retorno    .T. / .F.                                                  
Ĵ
 Uso       MATA270                                                    
ٱ


*/
Static Function A270TDOK()
Local lRet		:=.T.
Local aArea		:=GetArea()
Local lLocaliDt	:= .F.
Local lWmsNew	:= SuperGetMv("MV_WMSNEW",.F.,.F.)

dbSelectArea("SB2")
dbSetOrder(1)

//Ŀ
// PE para validar se exclui o Registro 			|
//
If ExistBlock("MT270TDK")
	lRet := ExecBlock("MT270TDK",.F.,.F.)
	If ValType(lRet)#'L'
		lRet := .F.
	EndIf
EndIf 

If lRet
	If !lWmsNew
		If Localiza(SB7->B7_COD)
			SBF->(dbSetOrder(1)) 
			If SBF->(dBSeek(xFilial("SBF")+SB7->B7_LOCAL+SB7->B7_LOCALIZ+SB7->B7_COD+SB7->B7_NUMSERI+SB7->B7_LOTECTL+SB7->B7_NUMLOTE)).And. (SBF->BF_DINVENT == SB7->B7_DATA)
				lLocaliDt := .T.
			EndIf
		Else
			If dbSeek(xFilial("SB2")+SB7->B7_COD+SB7->B7_LOCAL) .And. (SB2->B2_DINVENT == SB7->B7_DATA)
				lLocaliDt := .T.
			EndIf
		EndIf

		If lLocaliDt
			lRet:=(Aviso(OemToAnsi(STR0010),OemToAnsi(STR0011),{OemToAnsi(STR0008),OemToAnsi(STR0007)},1) == 1) //"Atencao"###"Ja foi processado inventario para este produto neste armazem e data , confirma a exclusao ?"
		EndIf
	EndIf
EndIf

RestArea(aArea)
Return lRet

/*

Ŀ
Funo    A270VlCont Autor Rodrigo de A Sartorio   Data  07/08/04 
Ĵ
Descrio  Valida a contagem digitada                                 
Ĵ
Retorno    .T. / .F.                                                  
Ĵ
 Uso       MATA270                                                    
ٱ


*/
Function A270VlCont(cContagem)
Local lRet 		:= .T. 			// variavel de retorno

Default cContagem	:= &(ReadVar())	// variavel que informa a contagem digitada

If UsaContage()

	If l270Auto .And. ALTERA
			Return(.T.)
	Endif
	
	If !Empty(cContagem)
		// Checa contagem repetida
		If FWIsInCallStack('AcdvGSB7')
			lRet := VldJaGrv(cContagem)
		Else
			lRet := ExistChav("SB7",DTOS(M->B7_DATA)+M->B7_COD+M->B7_LOCAL+M->B7_LOCALIZ+M->B7_NUMSERI+M->B7_LOTECTL+M->B7_NUMLOTE+cContagem)
		EndIf
	Else
		Help("", 1, "MT270CNTOBR") // A informao da contagem  obrigatria. -  obrigatrio informar a contagem quando o parmetro MV_CONTINV est ativo.
		lRet := .F.		
	EndIf
EndIf

Return lRet

/*/{Protheus.doc} VldJaGrv
	Verifica se j existe inventrio com os dados informados gravado.
	Desde que os demais estejam finalizados, permite a incluso.
	Somente quando a rotina  chamada pelo ACD
	@type  Static Function
	@author Gianluca Moreira
	@since 16/08/2022
/*/
Static Function VldJaGrv(cContagem)
	Local cQuery    := ""
	Local cAlSB7    := ""
	Local lRet      := .T.

	Default cContagem := M->B7_CONTAGE

	cQuery := " Select R_E_C_N_O_ REC From "+RetSqlName("SB7")+" "
	cQuery += "  Where B7_FILIAL  = '"+FWxFilial('SB7')+"' "
	cQuery += "    And B7_DATA    = '"+DTOS(M->B7_DATA)+"' "
	cQuery += "    And B7_COD     = '"+M->B7_COD+"' "
	cQuery += "    And B7_LOCAL   = '"+M->B7_LOCAL+"' "
	cQuery += "    And B7_LOCALIZ = '"+M->B7_LOCALIZ+"' "
	cQuery += "    And B7_NUMSERI = '"+M->B7_NUMSERI+"' "
	cQuery += "    And B7_LOTECTL = '"+M->B7_LOTECTL+"' "
	cQuery += "    And B7_NUMLOTE = '"+M->B7_NUMLOTE+"' "
	If UsaContage()
		cQuery += "    And B7_CONTAGE = '"+cContagem+"' "
	EndIf
	cQuery += "    And B7_STATUS  = '1' " //No Processado
	cQuery += "    And D_E_L_E_T_ = ' ' "
	cQuery := ChangeQuery(cQuery)

	cAlSB7 := MpSysOpenQuery(cQuery)

	While !(cAlSB7)->(EoF())
		lRet := .F.
		Help(,,"MT270NAOPR",,STR0037+' '+STR0038, 1, 0) //"J existe um inventrio no processado com essas informaes. Altere ou finalize o inventrio existente."
		Exit
	EndDo

	(cAlSB7)->(DbCloseArea())
Return lRet

/*

Ŀ
Funo    A270Contag Autor Rodrigo de A Sartorio   Data  09/08/04 
Ĵ
Descrio  Seleciona contagem do inventario                           
Ĵ
Sintaxe    A270Contag(ExpC1,ExpN1,ExpN2)                              
Ĵ
Parametros ExpC1 = Alias do arquivo                                   
           ExpN1 = Numero do registro                                 
           ExpN2 = Numero da opcao selecionada                        
Ĵ
 Uso       Generico                                                   
ٱ


*/
Function A270Contag(cAlias,nReg,nOpc)
Local aArea      := GetArea()
Local aContagens := {}
Local nAchou     := 0
Local aSavRotina := ACLONE(aRotina)
Local lContinua  := .F.
Local cArqInd    := ""
Local cChaveInd  := ""
Local cCondicao  := ""
Local nIndice    := 0
Local aChavB7    := {}
Local cFilSB7    := xFilial("SB7")
PRIVATE cChaveB7:=B7_FILIAL+DTOS(B7_DATA)+B7_COD+B7_LOCAL+B7_LOCALIZ+B7_NUMSERI+B7_LOTECTL+B7_NUMLOTE
PRIVATE cChvIni:=B7_FILIAL+DTOS(B7_DATA)+B7_COD+B7_LOCAL+B7_LOCALIZ+B7_NUMSERI+B7_LOTECTL+B7_NUMLOTE
PRIVATE cChvFim:=B7_FILIAL+DTOS(B7_DATA)+B7_COD+B7_LOCAL+B7_LOCALIZ+B7_NUMSERI+B7_LOTECTL+B7_NUMLOTE
PRIVATE cMarca:=GetMark(NIL,"SB7","B7_OK")

If mv_par04 == 1 // Por produto

	aRotina :={{STR0013,"A270SelCon",0,4}}	 	//"Seleciona"
	aChavB7 := {}	
	// Posiciona no primeiro registro dessa chave para verificar todos registros relacionados
	dbSelectArea("SB7")
	dbSetOrder(1)
	If dbSeek(cChaveB7)
		While !Eof() .And. cChaveB7 == B7_FILIAL+DTOS(B7_DATA)+B7_COD+B7_LOCAL+B7_LOCALIZ+B7_NUMSERI+B7_LOTECTL+B7_NUMLOTE
			nAchou:=aScan(aContagens,{|x| x[2]== B7_QUANT})
			If nAchou > 0
				aContagens[nAchou,4]:=aContagens[nAchou,4]+1
			Else
				AADD(aContagens,{B7_CONTAGE,B7_QUANT,Recno(),1})
			EndIf
			Aadd(aChavB7,B7_FILIAL+DTOS(B7_DATA)+B7_COD+B7_LOCAL+B7_LOCALIZ+B7_NUMSERI+B7_LOTECTL+B7_NUMLOTE)			
			SB7->(dbSkip())
		End
	
		// Ordena por numero de contagens iguais
		ASORT(aContagens,,,{|x,y| x[4] > y[4] })
	
		// Marca contagem com mais ocorrencias como contagem oficial
		If Len(aContagens) == 1 .Or. (aContagens[1,4]) > (aContagens[2,4])
			dbgoto(aContagens[1,3])
			Reclock("SB7",.F.)
			Replace B7_OK With cMarca
			MsUnlock()
		EndIf
		If 	Len(aChavB7)>0
			cChvIni:=aChavB7[1]
			cChvFim:=aChavB7[Len(aChavB7)]
		Endif
		//Ŀ
		// Endereca a funcao de BROWSE                                  
		//
		Set Key VK_F12 To
		MarkBrow("SB7","B7_OK",,,,cMarca,"A270TudMk()",,"A270Chave(cChvIni)","A270Chave(cChvFim)","A270Mark()")
		Set Key VK_F12 To MTA270PERG()

	EndIf

Else // Por Data/Contagem

	If A270VldPar() // Validar os parmetros informados

		aRotina :={{STR0013,"A270SelPrd",0,4}} //"Seleciona"
	
		// Posiciona no primeiro registro e varre toda a tabela para 
		// encontrar os itens da contagem e data especificadas
		dbSelectArea("SB7")
		dbSetOrder(1)
		SB7->(dbSeek(cFilSB7 + DtoS(mv_par05)))
		While !SB7->(Eof()) .And. SB7->B7_FILIAL == cFilSB7 .And. DtoS(SB7->B7_DATA) == DtoS(mv_par05)
			If SB7->B7_CONTAGE == mv_par06
				// Marca previamente o item
				Reclock("SB7",.F.)
				SB7->B7_OK := cMarca
				SB7->(MsUnlock())
				lContinua := .T.
			EndIf
			SB7->(dbSkip())
		EndDo
		
		//Ŀ
		// Endereca a funcao de BROWSE  
		//
		If lContinua
			Set Key VK_F12 To
			cArqInd   := CriaTrab(, .F.)
			cChaveInd := IndexKey()
			cCondicao := 'B7_CONTAGE == "'+mv_par06+'" .And. DTOS(B7_DATA) == "'+DTOS(mv_par05)+'" .And. B7_FILIAL == "'+cFilSB7+'"'
			IndRegua("SB7", cArqInd, cChaveInd,, cCondicao, STR0029 ) //"Criando indice de trabalho"
			nIndice := RetIndex("SB7") + 1
			dbSetOrder(nIndice)
			SB7->(MsSeek(xFilial("SB7")))
			MarkBrow("SB7","B7_OK",,,,cMarca,,,,,"A270Mark()")
			SB7->(DbClearFil())
			SB7->(dbSetOrder(1))
			RetIndex("SB7")
			Set Key VK_F12 To MTA270PERG()
		Else
			Aviso(STR0010,STR0030,{"Ok"}) //"No existem itens inventariados na contagem e data informadas."
		EndIf
	EndIf
EndIf

// Restaura ambiente original
RestArea(aArea)
aRotina:=ACLONE(aSavRotina)
Return

/*


Ŀ
Funo    A270VldPar   Autor  Emerson Rony Oliveira Data  03/03/09
Ĵ
Descrio  Validar os parametros (usando selecao por data/contagem)   
Ĵ
Sintaxe    A270VldPar()                                               
Ĵ
 Uso       MATA270                                                    
ٱ


*/
Function A270VldPar()
Local lRet := .T.

If lRet .And. Empty(DtoS(mv_par05))
	Help( ' ', 1, 'A270DTCONT' )
	lRet := .F.
EndIf

If lRet .And. Empty(mv_par06)
	Help( ' ', 1, 'A270CONTAG' )
	lRet := .F.
EndIf

Return lRet

/*

Ŀ
Funo    UsaContage Autor Rodrigo de A Sartorio   Data  09/08/04 
Ĵ
Descrio  Verifica a existencia de campos para controle de contagem  
Ĵ
Sintaxe    ExpL1:=UsaContage()                                        
Ĵ
Retorno    ExpL1 = Indica se utiliza controle de contagem ou nao      
Ĵ
 Uso       MATA270                                                    
ٱ


*/
Static Function UsaContage()
Return (SuperGetMv('MV_CONTINV',.F.,.F.))

/*


Ŀ
Funo     A270Mark   Autor  Rodrigo A Sartorio    Data 09.08.2004
Ĵ
Descrio  Controla marcacao para marcar somente um item por vez      
Ĵ
 Uso       MATA270                                                    
ٱ


*/
Function A270Mark()
Local aAreaAnt	:= GetArea()
Local cMarca    := ThisMark()
If !Empty(SB7->B7_CONTAGE)
	If IsMark("B7_OK",cMarca)
		Reclock("SB7",.F.)
		Replace B7_OK With Space(Len(B7_OK))
		MsUnlock()
	Else
		Reclock("SB7",.F.)
		Replace B7_OK With cMarca
		MsUnlock()
		If mv_par04 == 1
			MarcaSimil(cMarca)
		EndIf
	EndIf
EndIf
RestArea(aAreaAnt)
MarkBRefresh()
Return .T.

/*


ͻ
Programa  MarcaSimil Autor Rodrigo A Sartorio   Data   09/08/04   
͹
Desc.     Desmarca todos os itens diferentes do registro posicionado  
͹
Sintaxe    MarcaSimil(ExpC1)                                          
͹
Parametros ExpC1 = marca                                              
͹
Uso        MATA270                                                    
ͼ

*/
Function MarcaSimil(cMarca)
Local cSeek      := B7_FILIAL+DTOS(B7_DATA)+B7_COD+B7_LOCAL+B7_LOCALIZ+B7_NUMSERI+B7_LOTECTL+B7_NUMLOTE
Local nRecno     := Recno()
If dbSeek(cSeek,.F.)
	Do While !Eof() .And. cSeek == B7_FILIAL+DTOS(B7_DATA)+B7_COD+B7_LOCAL+B7_LOCALIZ+B7_NUMSERI+B7_LOTECTL+B7_NUMLOTE
		If nRecno <> Recno() 
			Reclock('SB7',.F.)
			Replace B7_OK With Space(Len(B7_OK))
			MsUnlock()
		EndIf
		dbSkip()
	Enddo
EndIf
Return Nil

/*

Ŀ
Funo    A270Chave  Autor Rodrigo de A Sartorio   Data  09/08/04 
Ĵ
Descrio  Retorna chave para filtragem da markbrowse                 
Ĵ
Sintaxe    A270Chave(ExpC1)                                           
Ĵ
Parametros ExpC1 = Chave para filtragem da markbrowse                 
Ĵ
 Uso       MATA270                                                    
ٱ


*/
Function A270Chave(cChaveB7)
Return cChaveB7

/*


Ŀ
Funo     A27TudMk   Autor  Rodrigo A Sartorio    Data 09.08.2004
Ĵ
Descrio  Nao permite marcar tudo                                    
Ĵ
 Uso       MATA270                                                    
ٱ


*/
Function A270TudMk()
Return

/*


Ŀ
Funo    A270SelCon   Autor  Rodrigo de A. SartorioData  09/08/04
Ĵ
Descrio  Marca contagem selecionada                                 
Ĵ
Sintaxe    A270SelCon(ExpC1,ExpN1,ExpN2,ExpC2,ExpL1)                  
Ĵ
Parametros ExpC1 = Alias do arquivo                                   
           ExpN1 = Numero do registro                                 
           ExpN2 = Numero da opcao selecionada                        
           ExpC2 = marca                                              
           ExpL1 = controle da marcacao (nao utiliz.)                 
Ĵ
 Uso       MATA270                                                    
ٱ


*/
Function A270SelCon(cAlias,cCampo,nOpcE,cMarca,lInverte)
Local cSeek:= B7_FILIAL+DTOS(B7_DATA)+B7_COD+B7_LOCAL+B7_LOCALIZ+B7_NUMSERI+B7_LOTECTL+B7_NUMLOTE
If dbSeek(cSeek,.F.)
	Do While !Eof() .And. cSeek == B7_FILIAL+DTOS(B7_DATA)+B7_COD+B7_LOCAL+B7_LOCALIZ+B7_NUMSERI+B7_LOTECTL+B7_NUMLOTE
		Reclock('SB7',.F.)
		Replace B7_ESCOLHA With If(!Empty(B7_OK),"S",Space(Len(B7_ESCOLHA)))
		MsUnlock()
		dbSkip()
	Enddo
EndIf
CloseBrowse()
Return Nil

/*


Ŀ
Funo    A270SelPrd   Autor  Emerson Rony Oliveira Data  03/03/09
Ĵ
Descrio  Marca contagem selecionada (usando selecao por data/cont.) 
Ĵ
Sintaxe    A270SelPrd(ExpC1,ExpN1,ExpN2,ExpC2,ExpL1)                  
Ĵ
Parametros ExpC1 = Alias do arquivo                                   
           ExpN1 = Numero do registro                                 
           ExpN2 = Numero da opcao selecionada                        
           ExpC2 = marca                				              
           ExpL1 = controle da marcacao		(nao utiliz.)             
Ĵ
 Uso       MATA270                                                    
ٱ


*/
Function A270SelPrd(cAlias,cCampo,nOpcE,cMarca,lInverte)

Local aArea    := GetArea()
Local cFilSB7  := xFilial("SB7")

// Grava o FLAG de selecao apenas nos registros selecionados na MarkBrowse
SB7->(dbSeek(cFilSB7 + DtoS(mv_par05)))
While !SB7->(Eof()) .And. SB7->B7_FILIAL == cFilSB7 .And. DtoS(SB7->B7_DATA) == DtoS(mv_par05)
	If SB7->B7_OK == cMarca .AND. !lInverte
		Reclock("SB7",.F.)
		SB7->B7_ESCOLHA := "S"
		SB7->(MsUnlock())
	Else
		Reclock("SB7",.F.)
		SB7->B7_OK      := Space(Len(B7_OK))
		SB7->B7_ESCOLHA := Space(Len(B7_ESCOLHA))
		SB7->(MsUnlock())
	EndIf
	SB7->(dbSkip())
EndDo

RestArea(aArea)

CloseBrowse()
Return Nil

/*


Ŀ
Funo    A270ExePE  Autor  Rodrigo de A. Sartorio Data  09/09/04 
Ĵ
Descrio  Chamada da funcao para executar PE                         
Ĵ
Sintaxe    A270ExePE(ExpN1)                                           
Ĵ
Parametros ExpN1 = Numero da opcao selecionada                        
Ĵ
 Uso       MATA270                                                    
ٱ


*/
Static Function A270ExePE(nOpc)
Local lExistePE:=ExistBlock("MTA270")
If lExistePE
	ExecBlock("MTA270",.F.,.F.,{nOpc})
EndIf
Return

/*

Ŀ
Funao    A270Legend  Autor  Marcos V. Ferreira    Data  03/08/06 
Ĵ
Descrio  Cria uma janela contendo a legenda da mBrowse              
Ĵ
 Uso       MATA270                                                    
ٱ


*/
Function A270Legend()
Local aLegenda := {}
aAdd(aLegenda,{"BR_VERDE"	 ,STR0017})
aAdd(aLegenda,{"BR_VERMELHO" ,STR0018})
BrwLegenda(cCadastro,STR0016,aLegenda) //"Legenda"
Return 

/*

Ŀ
Funo    A270Autom  Autor Ricardo Berti           Data  20/05/08 
Ĵ
Descrio  Selecao automatica para contagens do inventario            
Ĵ
Sintaxe    A270Autom(ExpC1)                                           
Ĵ
Parametros ExpC1 = Alias do arquivo                                   
Ĵ
Retorno    Nenhum                                                     
Ĵ
 Uso       Generico                                                   
ٱ


*/
Function A270Autom(cAlias)

Local bBlNewProc := {|oCenterPanel|a270ProSel(oCenterPanel)}
Local cCadastro  := OemtoAnsi(STR0019) //"Seleo Automtica do Inventrio"
Local cPerg	     := "MTA270"
Local nOpca  	 := 0
Local oDlg
Local lUsaNewPrc := UsaNewPrc()

If l270Auto
	a270ProSel()
ElseIf lUsaNewPrc
	tNewProcess():New("MATA270",cCadastro,bBlNewProc,OemtoAnsi(STR0020)+OemtoAnsi(STR0021)+OemtoAnsi(STR0022)+OemtoAnsi(STR0023),cPerg)
Else
	DEFINE MSDIALOG oDlg FROM  96,4 TO 355,625 TITLE cCadastro PIXEL
	@ 18, 9 TO 99, 300 LABEL "" OF oDlg  PIXEL
	@ 29, 15 Say OemToAnsi(STR0020) SIZE 275, 10 OF oDlg PIXEL	//"Este programa ir selecionar e gravar contagens como OK, quando houverem mltiplas contagens "
	@ 38, 15 Say OemToAnsi(STR0021) SIZE 275, 10 OF oDlg PIXEL	//"e dados de quantidade, lote e endereo estiverem iguais em contagens do mesmo produto na data. "
	@ 58, 15 Say OemToAnsi(STR0022) SIZE 255, 10 OF oDlg PIXEL	//"Nota: Ser considerado apenas o estoque inventariado na data p/ seleo automtica (parmetros). "
	@ 78, 35 Say OemToAnsi(STR0023) SIZE 275, 10 OF oDlg PIXEL	//"Verifique em parmetros a data p/ seleo automtica. "

	DEFINE SBUTTON FROM 108,209 TYPE 5 ACTION Pergunte(cPerg,.T.) ENABLE OF oDlg
	DEFINE SBUTTON FROM 108,238 TYPE 1 ACTION (nOpca:=1,oDlg:End()) ENABLE OF oDlg
	DEFINE SBUTTON FROM 108,267 TYPE 2 ACTION oDlg:End() ENABLE OF oDlg
	ACTIVATE MSDIALOG oDlg
EndIf

If nOpca == 1 .And. !lUsaNewPrc
	a270ProSel()
EndIf

Return Nil


/*

Ŀ
Funo    A270ProSel Autor Ricardo Berti           Data  24/05/08 
Ĵ
Descrio  Processamento da Selecao automat.p/ contagens do Inventario
Ĵ
Sintaxe    A270ProSel(ExpO1)                                          
Ĵ
Parametros ExpO1: nome do obj da regua de processamento               
Ĵ
Retorno    Nenhum                                                     
Ĵ
 Uso       MATA270                                                    
ٱ


*/
Function a270ProSel(oCenterPanel)

Local oObj 
TCInternal(5,"*OFF")   // Desliga Refresh no Lock do Top

If oCenterPanel <> NIL
	oObj := oCenterPanel
EndIf

If l270Auto
	A270ProAut()
Else
	If !(oObj <> NIL)
		oObj := MsNewProcess():New({|lEnd| A270ProAut(oObj)},"","",.F.)
		oObj :Activate()
	Else
		A270ProAut(oObj)
	EndIf
EndIf
Return Nil


/*

Ŀ
Funo    A270ProAut Autor Ricardo Berti           Data  24/05/08 
Ĵ
Descrio  Processamento da Selecao automat.p/ contagens do Inventario
Ĵ
Sintaxe    A270ProAut(ExpO1)                                          
Ĵ
Parametros ExpO1: nome do obj da regua de processamento               
Ĵ
Retorno    Nenhum                                                     
Ĵ
 Uso       MATA270                                                    
ٱ


*/
Static Function A270ProAut(oObj)

Local aArea 	:= GetArea()
Local aContagens:= {}
Local cChaveB7	
Local nX		:= 0                   
Local lUsaNewPrc := UsaNewPrc()

Local cContage := ""
Local nContValid := 0
Local nQtdAnt := 0

Local aStru		:= {}
Local cQuery	:= ""
Local oQuery 		 as object
Local nCont 	:= 1 as numeric
Local cAliasTmp	:= GetNextAlias()

dbSelectArea("SB7")
dbSetOrder(1)

aStru     := SB7->(dbStruct())

cQuery := "SELECT B7_FILIAL, B7_DATA, B7_COD, B7_LOCAL, B7_LOCALIZ, B7_NUMSERI, B7_LOTECTL, B7_NUMLOTE, "
cQuery += "MIN(B7_CONTAGE) B7_CONTAGE, B7_QUANT, COUNT(*) QTDCONT "
cQuery += "FROM " + RetSqlName("SB7") + " "
cQuery += "WHERE B7_FILIAL = ? "
cQuery += "AND B7_DATA = ? "
If !Empty(mv_par06)
	cQuery += "AND B7_CONTAGE = ? "
EndIf
cQuery += "AND D_E_L_E_T_ = ? "
cQuery += "GROUP BY B7_FILIAL, B7_DATA, B7_COD, B7_LOCAL, B7_LOCALIZ, B7_NUMSERI, B7_LOTECTL, B7_NUMLOTE, B7_QUANT "
cQuery += "ORDER BY B7_FILIAL, B7_DATA, B7_COD, B7_LOCAL, B7_LOCALIZ, B7_NUMSERI, B7_LOTECTL, B7_NUMLOTE, QTDCONT, B7_QUANT"

cQuery := ChangeQuery(cQuery)
oQuery := FwExecStatement():New(cQuery)

oQuery:SetString(nCont++,FWxFilial("SB7"))
oQuery:SetString(nCont++,DTOS(mv_par03))
If !Empty(mv_par06)
	oQuery:SetString(nCont++,mv_par06)
EndIf
oQuery:SetString(nCont++,' ')

cAliasTmp := oQuery:OpenAlias()
dbSelectArea(cAliasTmp)

For nX := 1 To Len(aStru)
	If ( aStru[nX][2] <> "C" )
		TcSetField(cAliasTmp,aStru[nX][1],aStru[nX][2],aStru[nX][3],aStru[nX][4])
	EndIf
Next

If !l270Auto
	oObj:SetRegua1(SB7->(LastRec()))
EndIf

If oObj <> NIL .And. lUsaNewPrc
	If !EOF()
		oObj:SaveLog(OemToAnsi(STR0026)) // Inicio do Processamento
	EndIf       
EndIf

While !EOF()

	If !l270Auto
		oObj:IncRegua1(STR0024)
	EndIf

	cChaveB7 := (cAliasTmp)->(B7_FILIAL+DTOS(B7_DATA)+B7_COD+B7_LOCAL+B7_LOCALIZ+B7_NUMSERI+B7_LOTECTL+B7_NUMLOTE)
	cContage := B7_CONTAGE
	
	nQtdAnt := 0
	nContValid := 0
	
	While !Eof() .And. cChaveB7 == (cAliasTmp)->(B7_FILIAL+DTOS(B7_DATA)+B7_COD+B7_LOCAL+B7_LOCALIZ+B7_NUMSERI+B7_LOTECTL+B7_NUMLOTE)

		If (cAliasTmp)->QTDCONT >= nQtdAnt

			nContValid := 1
			nQtdAnt := (cAliasTmp)->QTDCONT
			cContage := (cAliasTmp)->B7_CONTAGE

		EndIf	
		
		dbSkip()

	EndDo	

	If nContValid == 1  // Multiplas contagens / Considera a contagem dominante
		Aadd(aContagens,cChaveB7 + cContage)
	EndIf
EndDo	

If Len(aContagens) == 0
	If !l270Auto
		Help(" ",1,"MA270NSAUT") // No h contagens mltiplas que podem ser selecionadas automaticamente na data.
	EndIf
Else
	//Ŀ
	// Grava a 1a. contagem como selecionada (oficial), dentre as contagens c/qtdes. iguais    
	//
	dbSelectArea("SB7")
	dbSetOrder(1)
	If !l270Auto
		oObj:SetRegua2(Len(aContagens))
	EndIf

	For nX := 1 To Len(aContagens)
		If !l270Auto
			oObj:IncRegua2(STR0025)
		EndIf
		If SB7->(dbSeek(aContagens[nX]))
			Reclock('SB7',.F.)
			Replace B7_ESCOLHA With "S"
			MsUnlock()
		EndIf
	Next
	If oObj <> NIL .and. lUsaNewPrc
		oObj:SaveLog(OemToAnsi(STR0027)) // Fim do Processamento
	EndIf
EndIf	

(cAliasTmp)->(DbCloseArea())
oQuery:Destroy()
oQuery := nil 
RestArea(aArea)
Return Nil

/*/


Ŀ
Programa  MenuDef    Autor  Fabio Alves Silva      Data 04/10/2006
Ĵ
Descrio  Utilizacao de menu Funcional                               
                                                                      
                                                                      
Ĵ
Retorno   Array com opcoes da rotina.                                 
Ĵ
ParametrosParametros do array a Rotina:                               
          1. Nome a aparecer no cabecalho                             
          2. Nome da Rotina associada                                 
          3. Reservado                                                
          4. Tipo de Transao a ser efetuada:                        
              1 - Pesquisa e Posiciona em um Banco de Dados           
              2 - Simplesmente Mostra os Campos                       
              3 - Inclui registros no Bancos de Dados                 
              4 - Altera o registro corrente                          
              5 - Remove o registro corrente do Banco de Dados        
          5. Nivel de acesso                                          
          6. Habilita Menu Funcional                                  
Ĵ
   DATA    Programador   Manutencao efetuada                         
Ĵ
                                                                     
ٱ


/*/
Static Function MenuDef()

Local aRotinaNew := {}
Private aRotina	:= {	{STR0001,"AxPesqui"  , 0, 1,0, .F.},; //"Pesquisar"
						{STR0002,"A270Visual", 0, 2,0, nil},; //"Visualizar"
						{STR0003,"A270Inclui", 0, 3,17,nil},; //"Incluir"
						{STR0004,"A270Altera", 0, 4,17,nil},; //"Alterar"
						{STR0005,"A270Deleta", 0, 5,17,nil} } //"Excluir"
If UsaContage()
	aAdd(aRotina,{STR0012,"A270Contag"	, 0 , 3,17	}) //"Sel Contagem"
	aAdd(aRotina,{STR0028,"A270Autom"	, 0 , 3,17	}) //"Sel Autom"
	aAdd(aRotina,{STR0016,"A270Legend"	, 0 , 2		}) //"Legenda"
EndIf

If ExistBlock("MTA270MNU")
	aRotinaNew := ExecBlock("MTA270MNU",.F.,.F.,aRotina)
	If ( ValType(aRotinaNew) == "A" )
		aRotina := aClone(aRotinaNew)
	EndIf
EndIf

Return (aRotina)

/*


ͻ
Programa  IntegDef  Autor   Leandro Paulino   Data   01/02/12       
͹
Descricao  Mensagem nica																 
͹
Uso        Integraes                                               	 
ͼ


*/
Static Function IntegDef( cXML, nTypeTrans, cTypeMessage )

Local aRet := {}
//a funcao integdef original foi transferida para o fonte mati270, conforme novas regras de mensagem unica.
aRet:= MATI270( cXml, nTypeTrans, cTypeMessage )

Return aRet
/*------------------
 Bloqueio do endereo para status 6=Inventrio
-------------------*/
Static Function BlqEndInv()
	dbSelectArea("SBE")
	SBE->(dbSetOrder(1))
	If SBE->(dbSeek(xFilial("SBE")+SB7->(B7_LOCAL+B7_LOCALIZ)))
		RecLock("SBE",.F.)
		SBE->BE_STATUS := "6" // Bloqueio Inventrio
		SBE->(MsUnlock())
	EndIf
Return Nil
/*
 Atualiza o status do endereo verificando se est ocupado ou desocupado
*/
Static Function AtuStsEnd(cLocAnt,cEndeAnt)
Local oEstEnder := WMSDTCEstoqueEndereco():New()

	oEstEnder:oEndereco:SetArmazem(cLocAnt)
	oEstEnder:oEndereco:SetEnder(cEndeAnt)
	oEstEnder:UpdEnder()
	
	oEstEnder:Destroy()
Return Nil


//--------------------------------------------------------
/*/{Protheus.doc} A270InTran
Processa atualizacoes referentes a inclusao, alteracao e exclusao
dentro da transacao

@type function
@author  	rafael.pessoa
@since   	29/03/2018
@version 	P12
/*/
//--------------------------------------------------------
Function A270InTran()
Local lWmsNew 	:= SuperGetMv("MV_WMSNEW",.F.,.F.)
Local lIntegDef	:= FWHasEAI("MATA270",.T.,,.T.)
Local aRetInt 	:= {} 
Local cMsgRet		:= ""

If INCLUI
	// Bloqueia o endereo com status 6=Bloqueio Inventrio
	If lWmsNew .And. !Empty(SB7->B7_LOCALIZ)
		BlqEndInv()
	EndIf
	
	If !l270Auto
		If mv_par02 == 1
			dbSelectArea("SB2")
			If dbSeek(xFilial("SB2")+SB7->B7_COD+SB7->B7_LOCAL)
				dbSkip()
			Else 
				CriaSB2(SB7->B7_COD,SB7->B7_LOCAL)
				dbSkip()
			EndIf
		ElseIf mv_par02 == 3
			dbSelectArea("SBF")
			dbSeek(xFilial("SBF")+SB7->B7_LOCAL+SB7->B7_LOCALIZ+SB7->B7_COD)
			dbSkip()
		EndIf
	EndIf
ElseIf ALTERA
	If lWmsNew .And. (cEndeAnt # SB7->B7_LOCALIZ .Or. cLocAnt # SB7->B7_LOCAL)
		// Retorna status do antigo endereo
		AtuStsEnd(cLocAnt,cEndeAnt)
		// Atualiza status do novo endereo
		BlqEndInv()
	EndIf
Else//DELETA
	If lWmsNew
		AtuStsEnd(SB7->B7_LOCAL,SB7->B7_LOCALIZ)
	EndIf
EndIf

If lIntegDef 
	aRetInt := FwIntegDef("MATA270",,,, "MATA270")

	If Valtype(aRetInt) == "A" .And. Len(aRetInt) == 2 .And. !aRetInt[1]
		If !Empty(AllTrim(aRetInt[2]))
			cMsgRet := AllTrim(aRetInt[2]) +chr(13)+chr(13)
		EndIf
		cMsgRet += STR0034
		Aviso(STR0033,cMsgRet,{"Ok"},3)
		DisarmTransaction()
	EndIf
EndIf

Return
