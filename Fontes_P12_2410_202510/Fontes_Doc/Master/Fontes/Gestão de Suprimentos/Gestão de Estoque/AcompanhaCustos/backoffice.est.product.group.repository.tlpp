#include "tlpp-core.th"
#include "tlpp-rest.th"
#include 'protheus.ch'
#INCLUDE "FWMVCDEF.CH"

namespace totvs.protheus.backoffice.est.product.group.repository

/*/{Protheus.doc} GroupProductRepository()
    Classe responsavel pela execucao de consultas no banco de dados
    @type Class
    @author Adriano Vieira
    @since 24/02/2023
    @version 1.0
/*/
Class GroupProductRepository FROM FWAdapterBaseV2

    public method New()
    public method getGroupProduct()
    public method version()

EndClass

/*/{Protheus.doc} New()
    Metodo responsavel por instanciar a classe e iniciar variaveis
    @type Method
    @author Adriano Vieira
    @since 24/02/2023
    @version 1.0
/*/
Method New(cVerbo as Character, lList as Logical) Class GroupProductRepository
    Default cVerbo  := 'GET'
    Default lList   := .T.

	_Super:New(cVerbo, lList)
Return Self

/*/{Protheus.doc} getGroupProduct()
    Realiza a consulta no banco para retornar o GET da requisicao
    @type  Metodo
    @author Adriano Vieira
    @since  24/02/2023
    @version 1.0
/*/
Method getGroupProduct(nPage, nPageSize, aBranch, aCode) class GroupProductRepository
   	Local cQuery        as Character
    Local cWhere        as Character
    Local cBranchAux    as Character
    Local cBranchList   as Character
    Local cFilterQuery  as Character
    Local nPosit        as Numeric
    Local nX            as Numeric
    Local jsonResponse  as Object
    Local aFilial       := TamSx3('BM_FILIAL')
    Local aCodigo       := TamSx3('BM_GRUPO')
    Local aDescri       := TamSx3('BM_DESC')

    // Guarda uma string com a lista de filiais passadas no filtro, separando por | para facilitar a manipulação das informações
    cBranchList := ''
    // Variavel auxiliar para armazenar apenas a unidade da filial
    cBranchAux := ''
    // Variavel para armazenar a query de filtro que será passado no SetUrlFilter()
    cFilterQuery := ''
    // Variavel para indicar a posição de onde deve começar o SubStr utilizado no While()
    nPosit := 1
    // Variavel auxiliar para marcar a posição no SubStr do primeiro item do filtro
    nX := AT("eq '", aBranch[1][2], nPosit)

    If(!Empty(aBranch[1][2]))
        // Loop que recebe a lista de filtros (aBranch[1][2]) e manipula para deixar de acordo com o esperado em SetUrlFilter() 
        While (nPosit > 0)
            // Caso para tratar a primeira filial dentro do filtro
            If(nPosit == 1)
                cBranchAux := SubStr(aBranch[1][2], AT("'", aBranch[1][2])+1, Len(allTrim(xFilial("SBM")))) 
                cFilterQuery += "filial eq " + "'" + cBranchAux + "'" 
                cBranchList += cBranchAux + '|'
                nPosit := AT("eq '", aBranch[1][2], nX+1)
            Else
                // Caso seja a segunda filial em diante, é feito o tratamento do nome da filial e adicionado a clausula 'or' no filtro da query
                If !(SubStr(aBranch[1][2], AT("'",  aBranch[1][2], nPosit)+1, Len(allTrim(xFilial("SBM")))) $ cBranchList)
                    cBranchAux  := SubStr(aBranch[1][2], AT("'",  aBranch[1][2], nPosit)+1, Len(allTrim(xFilial("SBM"))))
                    cBranchList += cBranchAux + '|'
                    cFilterQuery += " or filial eq " + "'" + cBranchAux + "'" 
                EndIf
                nPosit := AT("eq '", aBranch[1][2], nPosit+1) 
            EndIf
        End
    EndIf

    If(!Empty(cFilterQuery)) .and. (!Empty(aCode[1][2]))
        aBranch[1][2] := '('+cFilterQuery+') and '+aCode[1][2] 
    elseIf  (!Empty(cFilterQuery)) .and. (Empty(aCode[1][2]))
        aBranch[1][2] := cFilterQuery 
    elseIf (Empty(cFilterQuery)) .and. (!Empty(aCode[1][2])) 
        aBranch[1][2] := aCode[1][2]      
    EndIF
    
    cQuery := " SELECT #QueryFields# "
	cQuery += " FROM " + RetSQLName("SBM") + " SBM  "
    cQuery += " WHERE #QueryWhere#  "
    cWhere := ""
    cWhere += " SBM.D_E_L_E_T_ = ' '"

    ::AddMapFields('filial', 'BM_FILIAL', .T., .T., { 'BM_FILIAL' , aFilial[3], aFilial[1], aFilial[2]})
    ::AddMapFields('descri', 'BM_DESC', .T., .T., { 'BM_DESC' , aDescri[3], aDescri[1], aDescri[2]})
    ::AddMapFields('codigo', 'BM_GRUPO', .T., .T., { 'BM_GRUPO' , aCodigo[3], aCodigo[1], aCodigo[2]})
    ::setPage(nPage)
    ::setPageSize(nPagesize)
    ::setQuery(cQuery)
    ::setWhere(cWhere)
    ::SetOrder("BM_GRUPO")
    ::SetUrlFilter(aBranch)

    If ::Execute()
        ::FillGetResponse()
        jsonResponse := ::GetJsonResponse()
    EndIf

Return jsonResponse

/*/{Protheus.doc} version
    Metodo responsavel por indicar a versao da classe
    @type  Method
    @author Adriano Vieira
    @since  15/02/2024
    @version 12.1.23.10
/*/
Method version() class GroupProductRepository
    Local nVersion := 200
Return nVersion
