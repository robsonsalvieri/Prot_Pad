#INCLUDE "MATA185.CH"
#INCLUDE "PROTHEUS.CH"
#DEFINE LINHAS 999

Static __lSaOrdSep := Nil

/*/


Ŀ
Funo     MATA185   Autor  Edson Maricate         Data 16.11.1998
Ĵ
Descrio  Baixa as Pre-requisicoes gerando as requisicoes.           
Ĵ
Sintaxe    Void mata185(ExpA1,ExpA2,ExpN1,ExpA3)                      
Ĵ
Parametros ExpA1 = Array com lista de campos (SCP)     	  (Rot.Aut)   
           ExpA2 = Array com lista de campos (SD3)     	  (Rot.Aut)   
           ExpN1 = numero da opcao selecionada 			  (Rot.Aut)   
           ExpA3 = Array contendo parametros p/ perguntas (Rot.Aut)OPC
Ĵ
Retorno    Nenhum                                                     
Ĵ
 Uso       Generico                                                   
Ĵ
 ATUALIZACOES SOFRIDAS DESDE A CONSTRUCAO INICIAL.                     
Ĵ
 PROGRAMADOR   DATA    BOPS   MOTIVO DA ALTERACAO                   
Ĵ
Cesar Valadao 15/02/002280   Exclusao de Pre-Requisicao             
ٱ




Ŀ
Descriao  PLANO DE MELHORIA CONTINUA        Programa: MATA185.PRX   
Ĵ
ITEM PMC   Responsavel               Data        Bops               
Ĵ
      01  Marcos V. Ferreira        13/01/2006                      
      02  Marcos V. Ferreira        11/01/2006                      
      03                                                            
      04                                                            
      05                                                            
      06  Marcos V. Ferreira        11/01/2006                      
      07  Marcos V. Ferreira        13/01/2006                      
      08  Marcos V. Ferreira        18/01/2006                      
      09  Marcos V. Ferreira        18/01/2006                      
      10  Ricardo Berti		        26/07/2006   00000103637        
ٱ


*/
Function MatA185(xAutoSCP,xAutoSD3,nOpcAuto,xPerg,xAutoAFH)

//Ŀ
// Define Variaveis                                             
//
Local aCor  := {}

Local aMT185COR  := {}   // Variavel utilizada no PE: MT185COR

Local cFiltraSCP := ""
Local cFiltro    := ""

PRIVATE l185Auto := (xAutoSCP <> Nil .And. xAutoSD3 <> Nil .And. nOpcAuto <> Nil)
PRIVATE aAutoSCP := xAutoSCP
PRIVATE aAutoSD3 := xAutoSD3
PRIVATE aAutoAFH := aClone(xAutoAFH)
PRIVATE aPerg	 := IIf((ValType(xPerg) == "A" .And. (Len(xPerg)>=3 .And. Len(xPerg)<=5)),xPerg,{1,1,2,1,1})  // xPerg[4] = Existe uma SC para Prquisio 1-Deleta 2-Mantem, xPerg[5] = dDataBase < SCP->CP_EMISSAO

PRIVATE aRotina	 := MenuDef()
//Variavel de integracao com o PMS sera utilizada para alimentar os campos D3_PROJPMS e D3_TSKPMS
PRIVATE lCallPrj := GetMV('MV_INTPMS')=="S"
PRIVATE _cProjCod:= SPACE(LEN(AFH->AFH_PROJET))	//variavel utilizada no x3_relacao funcao pmsCpoInic()
PRIVATE _cTarefa := SPACE(LEN(AFH->AFH_TAREFA))	//variavel utilizada no x3_relacao Funcao PmsCpoInic()
PRIVATE cRevisa  := SPACE(LEN(AFH->AFH_REVISA))	//variavel utilizada no x3_relacao Funcao PmsCpoInic()
PRIVATE cNuSATOP := ""
PRIVATE cITSATOP := ""
PRIVATE lPermBx  := GetNewPar("MV_BXPRERQ",.F.)
PRIVATE cMarca
PRIVATE cCadastro := OemToAnsi(STR0005) //"Geracao das Requisicoes"
PRIVATE aAcho:={}
PRIVATE cCusMed := GetMv("MV_CUSMED")

//Carrega varivel static '__lSaOrdSep'
FnVlSaOs()

If l185Auto
	aRotina := {{STR0003,"A185Baixar" 	, 0 , 1,0,nil},;	//"Baixar"
				{STR0054,"A185Estorn"	, 0 , 2,0,nil},;	//"Estorno"
				{STR0004,"A185Exclui" 	, 0 , 5,0,nil},;	//"Excluir"
				{STR0037,"A185Encer"  	, 0 , 6,0,nil}} 	//"Encerrar"
EndIf

If __lSaOrdSep
	aAdd(aCor, {"A185BtMa()", "BR_MARROM" })
EndIf
aAdd(aCor, {"A185BtVe()", "BR_VERMELHO" })
aAdd(aCor, {"A185BtAz()", "BR_AZUL" })
aAdd(aCor, {"A185BtVd()", "BR_VERDE" })
aAdd(aCor, {"A185BtAm()", "BR_AMARELO" })
aAdd(aCor, {"A185BtLa()", "BR_LARANJA" })

//Ŀ
// P.E. Utilizado para alterar as cores da legenda              
//
If ExistBlock("MT185COR")
	aMT185COR := ExecBlock("MT185COR",.F.,.F., {aCor})
	If ( Valtype(aMT185COR) == "A" )
		aCor := aClone( aMT185COR )
	EndIf
EndIf

//Ŀ
// Funcao que preenche o array AACHO                            
//
A240AAcho({"D3_COD","D3_QUANT","D3_QTSEGUM"})

//Ŀ
// Monta o cabecalho                                            
//
dbSelectArea("SX2")
dbSeek("SD3")
dbSelectArea("SX3")
dbSeek("SD3")
While !EOF() .And. (x3_arquivo == "SD3")
	If X3USO(x3_usado) .And. cNivel >= x3_nivel .And. (ASCAN(aAcho,Trim(x3_campo)) == 0) .And. X3_PROPRI == "U"
		AADD(aAcho,TRIM(x3_campo))
	Endif
	dbSkip()
End

//Ŀ
// Verifica as perguntas selecionadas                           
//
Pergunte("MTA185",.F.)

//Ŀ
// Variaveis utilizadas para parametros                                    
// mv_par01        // Qt. Processo Compras   Da Pre-Requisicao/Do Produto  
//

//Ŀ
// Verifica se o custo medio e' calculado On-Line               
//
Pergunte("MTA240",.F.)

If !l185Auto
	SetKey(VK_F12, {||MTA185PERG()})
Endif

dbSelectArea("SCQ")
dbSetOrder(1)

If BOF() .And. EOF() .And. !l185Auto
	HELP(" ",1,"RECNO")
Else
	If !l185Auto
		//Ŀ
		// Endereca a funcao de BROWSE                                  
		//
		If ExistBlock("MT185FIL")
		   cFiltraSCP := ExecBlock("MT185FIL",.F.,.F.)
		EndIf

		//Ŀ
		// Ponto de entrada para verificacao de filtros na Mbrowse      
		//
		If  ExistBlock("M185FILB")
			cFiltro := ExecBlock("M185FILB",.F.,.F.)
			If Valtype(cFiltro) <> "C"
				cFiltro := ""
			EndIf
		EndIf

 		mBrowse( 6, 1,22,75,"SCP",,,,,,aCor,,,,,,,, IF(!Empty(cFiltro),cFiltro, NIL),,,,cFiltraSCP)

	Else
		MsRotAuto(nOpcAuto,aAutoSCP,"SCP")
	Endif
EndIf

dbSelectArea("SCQ")
dbSetOrder(1)

//Ŀ
// Desativa tecla que aciona perguntas                            
//
If !l185Auto
	Set Key VK_F12 To
Endif

Return

/*

Ŀ
Funo    A185Baixar Autor  Larson Zordan 	     Data  22.07.02 
Ĵ
Descrio  Chamada da funcao para o tipo de baixa 					  
Ĵ
Parametros ExpC1 = Alias do arquivo                                   
           ExpN1 = Numero do registro                                 
           ExpN2 = Opcao selecionada                                  
Ĵ
Retorno    Nenhum					                                  
Ĵ
Uso        MatA185                                                    
ٱ


*/
Function A185Baixar(cAlias,nReg,nOpc)

Local lRet     	:= .T.
Local lRetPE     	:= .T.
Local lM185BAIX		:= ExistBlock('M185BAIX')
Local cNum		 	:= ''
Local cItem		:= ''
Local nX		 	:= 0
Local aAreaAFH   	:= AFH->(GetArea())
Local lPIMSInt
Local cValInt
Local cValExt
Local cSetBkp  

//Carrega varivel static '__lSaOrdSep'
FnVlSaOs()

AFH->(DbSetOrder(2))
If AFH->(DbSeek(xFilial("AFH")+SCP->CP_NUM+SCP->CP_ITEM))
	_cProjCod:= AFH->AFH_PROJET	//variavel utilizada no x3_relacao funcao pmsCpoInic()
	_cTarefa := AFH->AFH_TAREFA	//variavel utilizada no x3_relacao Funcao PmsCpoInic()
	cRevisa  := AFH->AFH_REVISA	//variavel utilizada no x3_relacao Funcao PmsCpoInic()
EndIf
AFH->(RestArea(aAreaAFH))

//Variavel utilizada no PMSXFUNB para validar se SA  originado pela integrao rm top x protheus
cNuSATOP := SCP->CP_NUM
cITSATOP := SCP->CP_ITEM

//Ŀ
// Inicializa perguntas deste programa                          
//
Pergunte("MTA185",.F.)

//Ŀ
// Tratamento para utilizacao da ROTINA AUTOMATICA					|
//
If l185Auto
	For nX:=1 to len(aAutoSCP)
		If Upper(AllTrim(aAutoSCP[nX,1])) == "CP_NUM"
			cNum := aAutoSCP[nX,2]
		ElseIf Upper(AllTrim(aAutoSCP[nX,1])) == "CP_ITEM"
			cItem := aAutoSCP[nX,2]
		EndIf
	Next
	If !SCP->(dbSeek(xFilial("SCP")+cNum+cItem))
		Help(" ",1,"REGNOIS")
		Return .F.
	EndIf
EndIf

//Verifica se existe vinculo com SIGAACD, para no permitir atualizao dentro da rotina
If !l185Auto .And. __lSaOrdSep .And. !Empty(SCP->CP_ORDSEP)
	Help(NIL, NIL, "SIGAACD", NIL, STR0108, 2, 0, NIL, NIL, NIL, NIL, NIL, {""})	//"Solicitacao ao Armazem vinculada uma 'Ordem de Separacao', nao e possivel realizar a baixa enquanto a SA estiver vinculada."
	lRet := .F.
EndIf

//Ŀ
// Ponto de Entrada que possibilita customizar a execucao da Baixa 
//
If lRet .And. lM185BAIX
	lRetPE 	:= ExecBlock('M185BAIX', .F., .F., {mv_par01})
	lRet 	:= If(!(ValType(lRetPE)=='L'), .T., lRetPE)
EndIf

//Ŀ
// Verifica calendrio contbil                
//
If lRet
	lRet := CtbValiDt(Nil,dDataBase,,Nil ,Nil ,{"EST001"})
EndIf

If lRet
	If dDataBase < SCP->CP_EMISSAO
		If l185Auto
			lRet:= aPerg[5] == 1
		Else
			lRet:=Aviso(OemToAnsi(STR0035),STR0063,{OemToAnsi(STR0040),OemToAnsi(STR0039)}) == 1
		EndIf
	EndIf
	If lRet

		If ! Empty(SCP->CP_NRBPIMS)
			// Tratamento para garantir que o campo acima foi preenchido via produto PIMS
			// Pois antes disso o campo D3_NRBPIMS indiferente do produto era atribuido valor
			cValInt := cEmpAnt + '|' + RTrim(xFilial('SCP')) + '|' + RTrim(SCP->CP_NUM) + "|" + RTrim(SCP->CP_ITEM) + "|" + cValToChar(SCP->CP_EMISSAO)
			cValExt := CFGA070Ext( "PIMS", "SCP", "CP_ITEM", cValInt)
			lPIMSInt := !Empty(cValExt)
			If !lPIMSInt
				cSetBkp := Set(_SET_DATEFORMAT, 'dd/mm/yyyy')
				cValInt := cEmpAnt + '|' + RTrim(xFilial('SCP')) + '|' + RTrim(SCP->CP_NUM) + "|" + RTrim(SCP->CP_ITEM) + "|" + cValToChar(SCP->CP_EMISSAO)
				cValExt := CFGA070Ext( "PIMS", "SCP", "CP_ITEM", cValInt)
				lPIMSInt := !Empty(cValExt)
				Set(_SET_DATEFORMAT, cSetBkp)
			EndIf 
		EndIf

		If (mv_par01 == 1 .Or. l185Auto) .AND. !lPIMSInt
			A185Manual(cAlias,nReg,nOpc)
		Else
			A185Automa(cAlias,nReg,nOpc)
		EndIf

	EndIf
EndIf
Return

/*

Ŀ
Funo    A185Gera   Autor  Edson Maricate         Data  25.11.98 
Ĵ
Descrio  Gera requisicoes                                      	  
Ĵ
Parametros Nenhum					                                  
Ĵ
Retorno    .T. / .F.				                                  
Ĵ
Uso        MatA185                                                    
ٱ


*/
Function A185Gera()
Local aRetSA	:={}
Local aNumScDhnA:= {}
Local aNumScDhnB:= {}
Local nQtRes	:= 0   // Saldo da quantidade reservada apos requisicao
Local nQtDisp	:= 0
Local lSCAglut	:=.F.
Local lRet		:=.F.
Local lWmsNew	:= SuperGetMv("MV_WMSNEW",.F.,.F.)
Local nAjustaSC1:= 3
Local nQuant	:= 0
Local cProjPMS	:=	""
Local cTaskPMS	:=	""
Local cNumSEq	:=	""
Local cSolic, cItSolic, nRecno, cSCNum
Local cItemPR, cNumAE
Local cDocSC	:= ""
Local cItSC		:= ""
Local cDocAE	:= ""
Local cItAE		:= ""
Local cAliasDHN	:= ""
Local aDocs		:= {}
Local aRetSX5   := {}

PRIVATE cXFunc	:= "A185AtuSD3"
//Ŀ
// Variavel utilizada na A240INCLUI() p/ atualizar o campo D3_DTLANC 
//
PRIVATE aAtuSD3	:= {}

//Ŀ
// Verifica se o custo medio e' calculado On-Line               
//
If cCusMed == "O"
	PRIVATE nHdlPrv				// Endereco do arquivo de contra prova dos lanctos cont.
	PRIVATE lCriaHeader := .T.	// Para criar o header do arquivo Contra Prova
	PRIVATE cLoteEst 			// Numero do lote para lancamentos do estoque
	//Ŀ
	// Posiciona numero do Lote para Lancamentos do Estoque         
	//
	aRetSX5 := FWGetSX5 ('09','EST')
	cLoteEst:=IIF(aRetSX5 == NIL,"EST ",Trim(aRetSX5[1,4]))
	PRIVATE nTotal := 0 	// Total dos lancamentos contabeis
	PRIVATE cArquivo		// Nome do arquivo contra prova
	PRIVATE aCtbDia := {}
EndIf

//Ŀ
// Estas variaveis indicam para as funcoes de validacao qual    
// programa as esta' chamando                                   
//
Private l240Auto := l185Auto, l250Auto := .F.
//Ŀ
// Estas variaveis indicam para as funcoes de validacao qual    
// programa as esta' chamando                                   
//
PRIVATE l240:=.T.,l250:=.F.,l241:=.F.,l242:=.F.,l261:=.F.,l185 :=.T.

aRetSA := ca100RetCQ(SCP->CP_NUM,SCP->CP_ITEM)
//Ŀ
// ca100RetCQ() ----------->                   
// [1] -  Saldo do Item                        
// [2] -  Quantidade diponivel ja reservada    
// [3] -  Quantidade em Processo de Compra     
// [4] -  Situacao Atual                       
// [5] -  Numero da Solicitacao de Compras     
// [6] -  Numero de Requisicao                 
// [7] -  Quantidade ja Entregue               
//

//Ŀ
// Atualiza Pergunta MTA240						
//
A185AtuPer(1)

dbSelectArea("SCQ")
dbSetOrder(1)
dbSeek(xFilial()+SCP->CP_NUM+SCP->CP_ITEM)

dbSelectArea("SD3")
dbSetOrder(1)

If If(l185Auto,A185RotAut(),A240Inclui("SD3",RecNo(),Nil))
	A240Comum()
	If !(lWmsNew .And. IntWMS(SCP->CP_PRODUTO))
		nQuant		:=	SD3->D3_QUANT
		cProjPMS	:=	SD3->D3_PROJPMS
		cTaskPMS	:=	SD3->D3_TASKPMS
		cNumSEq		:=	SD3->D3_NUMSEQ
	Else
		nQuant		:=	DH1->DH1_QUANT
		cProjPMS	:=	DH1->DH1_PROJPM
		cTaskPMS	:=	DH1->DH1_TASKPM
		cNumSEq		:=	DH1->DH1_NUMSEQ
	EndIf

	dbSelectArea("SB2")
	dbSetOrder(1)
	dbSeek(xFilial()+SCP->CP_PRODUTO+SCP->CP_LOCAL)
	Reclock("SB2",.F.)
	SB2->B2_QEMPSA := Max(0,B2_QEMPSA - If(nQuant < aRetSA[2], nQuant, aRetSA[2]))
	MsUnLock()
	dbSelectArea("SCP")
	Reclock("SCP",.F.)
	SCP->CP_QUJE := SCP->CP_QUJE + nQuant
	If SCP->CP_QUJE >= SCP->CP_QUANT
		SCP->CP_STATUS := "E"
		INCLUI := .F.
	EndIf
	MsUnLock()
	If IntePMS() .And. !Empty(cProjPMS).And.!Empty(cTaskPMS)
		DbSelectArea('AF8')
		DbSetOrder(1)
		MsSeek(xFilial()+cProjPMS)
		DbSelectArea('AFH')
		DbSetOrder(1)
		If MsSeek(xFilial()+cProjPMS+AF8->AF8_REVISA+cTaskPMS+SCP->CP_NUM+SCP->CP_ITEM)
			RecLock('AFH',.F.)
			AFH_QUJE	+=	nQuant
			MsUnLock()
		Endif
	Endif
	dbSelectArea("SCQ")
	While !Eof() .And. CQ_FILIAL+CQ_NUM+CQ_ITEM == xFilial()+SCP->CP_NUM+SCP->CP_ITEM
		//Recupera a SC gerada pela Central de Compras
		aNumScDhnA := COMPosDHN({2,{SCQ->CQ_FILIAL,SCQ->CQ_NUM,SCQ->CQ_ITEM}})
		If aNumSCDhnA[1]
			If (aNumScDhnA[2])->DHN_TIPO == "1" //Solicitao de Compra
				cDocSC	:= (aNumScDhnA[2])->DHN_DOCDES
				cItSC	:= (aNumScDhnA[2])->DHN_ITDES
			ElseIf (aNumScDhnA[2])->DHN_TIPO == "3" //Autorizao de Entrega
				cDocAE	:= (aNumScDhnA[2])->DHN_DOCDES
				cItAE	:= (aNumScDhnA[2])->DHN_ITDES
			EndIf
			(aNumScDhnA[2])->(DbCloseArea())
		EndIf
		If nQuant > 0 .And. Empty(SCQ->CQ_NUMREQ)
			If !Empty(cDocSC)
				If nQuant > aRetSA[2]	//If SCQ->CQ_QTDISP==0
					RecLock("SCQ",.F.)
					SCQ->CQ_QTDISP := SCQ->CQ_QTDISP + nQuant - aRetSA[2]
					MsUnlock()
					dbSelectArea("SC1")
					If SC1->(dbSeek(xFilial() + cDocSC + cItSC))
						If Empty(SC1->C1_PEDIDO) .And. Empty(SC1->C1_COTACAO)
							//Ŀ
							// Verifica se Gerou SC Aglutinada. 
							//
							nRecno := SCQ->(Recno())
							SCQ->(dbSeek(xFilial()+SC1->C1_NUM+SC1->C1_ITEM))
							lSCAglut := .F.
							cSCNum := SCQ->CQ_NUM
							aNumScDhnB := COMPosDHN({3,{'1',xFilial("DHN"),SC1->C1_NUM,SC1->C1_ITEM}})
							If aNumScDhnB[1]
								cAliasDHN := aNumScDhnB[2]
								If !Empty(cAliasDHN)
									While !((cAliasDHN)->(EOF())) .And. (cAliasDHN)->DHN_TIPO == "1" .And. (cAliasDHN)->(DHN_FILDES+DHN_DOCDES+DHN_ITDES) == xFilial("SC1")+SC1->C1_NUM+SC1->C1_ITEM
										If SCQ->(DbSeek((cAliasDHN)->(DHN_FILORI + DHN_DOCORI + AllTrim(DHN_ITORI))))
											While !(SCQ->(EoF())) .And. SCQ->(CQ_FILIAL + CQ_NUM + AllTrim(CQ_ITEM)) == (cAliasDHN)->(DHN_FILORI + DHN_DOCORI + AllTrim(DHN_ITORI))
												If cSCNum != SCQ->CQ_NUM
													lSCAglut := .T.
													Exit
												EndIf
												SCQ->(dbSkip())
											EndDo
										EndIf
										(cAliasDHN)->(dbSkip())
									EndDo
									(cAliasDHN)->(dbCloseArea())
								EndIf
							EndIf
							SCQ->(dbGoTo(nRecno))
							SCQ->(dbSetOrder(1))
							// Se Gerou SC Aglutinada, Nao Posso Deletar!!!
							If lSCAglut
								// "Existe uma SC Para Esta Pre-Requisicao." ### "Ajusta-la" ### "Mante-la"
								If l185Auto
									nAjustaSC1 := aPerg[1]
								Else
									nAjustaSC1 := Aviso("SIGAEST", STR0028, {STR0029, STR0031})
								EndIf
							Else
								// "Existe uma SC Para Esta Pre-Requisicao." ### "Ajusta-la" ### "Deleta-la" ### "Mante-la"
								If l185Auto
									nAjustaSC1 := aPerg[2]
								Else
									nAjustaSC1 := Aviso("SIGAEST", STR0028, {STR0029, STR0030, STR0031})
								EndIf
							EndIf
						Else
							// "Existe uma SC Em Processo de Compra. Nao Sera Alterada."
							If !l185Auto
								Aviso("SIGAEST", STR0032, {" Ok "})
							EndIf
						EndIf
					EndIf
					dbSelectArea("SCQ")
				EndIf
				cSolic  := cDocSC
				cItSolic:= cItSC
				nQtRes  += SCQ->CQ_QUANT - nQuant
			ElseIf !Empty(cDocAE)
				cNumAE  := cDocAE
				cItAE   := cItAE
				nQtRes  += SCQ->CQ_QUANT - nQuant
			Else
				nQtRes  += SCQ->CQ_QUANT - nQuant
			EndIf

			RecLock("SCQ",.F.)
			SCQ->CQ_NUMREQ := cNumSEq
			If nQuant - SCQ->CQ_QTDISP < 0
				nQtDisp+= SCQ->CQ_QTDISP - nQuant
			EndIf
			MsUnlock()
			cItemPR := SCQ->CQ_NUMSQ
			Exit
		EndIf
		dbSkip()
	EndDo
	If nQtRes > 0 .Or. nQtDisp > 0
		If nQtRes > 0
			a106AtuCQ(nQtRes,nQtDisp,cItemPR,.F.)
			RecLock("SCQ",.F.)
			MsUnlock()
		Else
			a106AtuCQ(nQtDisp,nQtDisp,cItemPR,.F.)
		EndIf
	EndIf
	If nAjustaSC1 == 1 .Or. (!lSCAglut .And. nAjustaSC1 == 2)
		dbSelectArea("SC1")
		If !(Empty(cDocSC)) .And. dbSeek(xFilial() + cDocSC + cItSC)
			If SC1->C1_QUANT - nQuant == 0
				nAjustaSC1 := 2	// Se a SC For Ficar Com Qtd Zero, Deleta-a.
			EndIf
			dbSelectArea("SB2")
			dbSetOrder(1)
			dbSeek(xFilial()+SCP->CP_PRODUTO+SCP->CP_LOCAL)
			If Reclock("SB2",.F.)
				SB2->B2_SALPEDI := B2_SALPEDI - If(nAjustaSC1==1, nQuant, SC1->C1_QUANT)
				MsUnLock()
			EndIf
			dbSelectArea("SC1")
			If nAjustaSC1 == 1
				RecLock("SC1",.F.)
				SC1->C1_QUANT := C1_QUANT - nQuant
				MsUnLock()
			Else
				// Desvincula da SC e Muda Status Para "D"eletado.

				aadd(aDocs,;
						{	Nil						;	//aPequena[x,1] : Produto
							,Nil					;	//aPequena[x,2] : Quantidade total
							,xFilial("SCP",cFilAnt) ;	//aPequena[x,3] : Filial que ser gerada o documento
							,Nil					;	//aPequena[x,4] : Filial que ser feita entrega do produto
							,NIL					;	//aPequena[x,5] : Documento que ser gerado sendo 1=Solicitao de Compras e 2=Pedido de Compra
							,NIL					;	//aPequena[x,6] : Fornecedor do produto
							,NIL					;	//aPequena[x,7] : Loja do fornecedor do produto
							,NIL					;	//aPequena[x,8] : Condio de pagamento
							,Nil					; 	//aPequena[x,9] : Preo do Produto
							,Nil					; 	//aPequena[x,10] : Array de Rateios
							,SCP->CP_NUM			; 	//aPequena[x,11] : Cdigo Documento
							,SCP->CP_ITEM			}) 	//aPequena[x,12] : Item do Documento

				ComGeraDoc(aDocs,,,,,,,,,5)

				dbSelectArea("SCQ")
				RecLock("SCQ",.F.)
				SCQ->CQ_STATUSC := "D"	// Deletada
				MsUnlock()
				//Ŀ
				// Se Foi Excluida a SC, Encerra a Pre-Requisicao. 
				//
				dbSelectArea("SCP")
				RecLock("SCP",.F.)
				SCP->CP_STATUS := "E"
				MsUnLock()
			EndIf
		EndIf
	EndIf

	//Integrao SIGAMDT
	MdtIntSCP( 1, SCP->CP_NUM, SCP->CP_ITEM, cNumSEq, SCP->CP_PRODUTO,;
			 SD3->D3_NUMSERI, SD3->D3_LOTECTL, SD3->D3_NUMLOTE, SD3->D3_LOCALIZ )

		//Integrao FSM
	IF (FWAliasInDic("JO3") .And. FindFunction('FSMintSCP')) .And. !Empty(SCP->CP_NUMOS) 
		FSMintSCP( 2 , SCP->CP_NUM , SCP->CP_ITEM , SCP->CP_PRODUTO, SCP->CP_LOCAL, SCP->CP_NUMOS, SCP->CP_CODSOLI,;
					SCP->CP_QUANT, SCP->CP_QUJE, SCP->CP_STATUS, SCP->CP_PREREQU)
	Endif		 

	If ExistBlock("M185GRV")
		ExecBlock("M185GRV",.F.,.F.,{.T.})
	EndIf
	lRet := .T.
EndIf
//Ŀ
// Atualiza Pergunta MTA185						
//
A185AtuPer(2)
Return lRet


/*/

Ŀ
Funo    A185Manual Autor  Edson Maricate         Data 02.12.1998
Ĵ
Descrio  Programa de Baixa das Pre-requisicoes.                     
Ĵ
Sintaxe    A185Manual(ExpC1,ExpN1,ExpN2)                              
Ĵ
Parametros ExpC1 = Alias do arquivo                                   
           ExpN1 = Numero do registro                                 
           ExpN2 = Opcao selecionada                                  
Ĵ
Retorno    .T. / .F.				                                  
Ĵ
 Uso       MATA185                                                    
ٱ


/*/
Function A185Manual(cAlias,nReg,nOpc)
LOCAL nOpcA     := 3
LOCAL aRetCQ    := {}
LOCAL nQAtu     := 0
LOCAL nQtSal    := 0
LOCAL nQtRes    := 0
LOCAL nQtdProc  := 0
LOCAL cPict     := PesqPictQt('D3_QUANT')
LOCAL lM185Mod1 := ExistBlock("M185MOD1")
LOCAL lMT185OK  := ExistBlock("MT185OK")
LOCAL nX		:= 0
LOCAL aButton	:= {}
LOCAL lRet		:= .T.
LOCAL lContinua	:= .T.
LOCAL oDlg
LOCAL aUsButtons := {}
Local lAuto		:= .F.

Local oSize 	:= {}
Local oSizeA 	:= {}
Local oSizeB 	:= {}
Local oSizeB1	:= {}
Local oSizeB2	:= {}
Local lMT185BUT := .F.

PRIVATE bPMSDlgSA	:= {|| PmsDlgSAB(SCP->CP_NUM,SCP->CP_ITEM,nQtRequ)}
PRIVATE aRatAFH		:= {}
PRIVATE nQtRequ 	:= CriaVar("D3_QUANT",.F.)
PRIVATE cNewDoc		:= ""  // Novo No.do Documento, atualizado na A240TudoOK
PRIVATE lChgNewDoc	:= .F. // Indica se No.do Documento foi alterado, atualizado na A240TudoOK
PRIVATE aDadosPRJ   := {}

//Ŀ
// Monta a entrada de dados do arquivo                          
//
PRIVATE aTELA[0][0]
PRIVATE aGETS[0]

cCadastro := OemToAnsi(STR0008) //"Baixa Pre-requisicao"

Pergunte("MTA185",.F.)

If Type("aAutoAFH") <> "U"
	lAuto:= aAutoAFH <> NIL .And. ValType(aAutoAFH) = 'A'
EndIf

If !SoftLock("SCP")
	lRet := .F.
EndIf

If l185Auto
	Altera := .T.
EndIf

If lRet .And. SCP->CP_STATUS == "E"
	If Altera  //IF utilizado para nao exibir mensagem quando baixada a pre-requisicao
		HELP("   ",1,"A185BX")
	EndIf
	lRet := .F.
EndIf

If lRet .And. Empty(SCP->CP_PREREQU)
	If Altera  //IF utilizado para nao exibir mensagem quando baixada a pre-requisicao
		HELP("   ",1,"A185PRE")
	EndIf
	lRet := .F.
EndIf

If lRet
	dbSelectArea("SB2")
	dbSetOrder(1)
	If dbSeek(xFilial("SB2")+SCP->CP_PRODUTO+SCP->CP_LOCAL)
		//Ŀ
		// ca100RetCQ() ----------->                   
		// [1] -  Saldo do Item                        
		// [2] -  Quantidade diponivel ja reservada    
		// [3] -  Quantidade em Processo de Compra     
		// [4] -  Situacao Atual                       
		// [5] -  Numero da Solicitacao de Compras     
		// [6] -  Numero de Requisicao                 
		// [7] -  Quantidade ja Entregue               
		//
		aRetCQ  := ca100RetCQ(SCP->CP_NUM,SCP->CP_ITEM)
		nQatu   := SB2->B2_QATU
		nQtRes  := SB2->B2_RESERVA+SB2->B2_QEMP+SB2->B2_QEMPSA+SB2->B2_QACLASS-If(mv_par03==1.And.!Empty(SCP->CP_OP),SCP->CP_QUANT,0)
		nQtSal  := nQAtu - nQtRes
		nQtRequ := aRetCQ[2]
	Else
		Help(" ",1,"REGNOIS")
		lRet := .F.
	EndIf

	If lRet
		If IntePms() // Se usa PMS integrado com o ERP
			If lAuto
				PmsDlgSAB(SCP->CP_NUM,SCP->CP_ITEM,,aAutoAFH)
			Else
				SetKey(VK_F10,bPMSDlgSA)
				aButton := { {'PROJETPMS',{||Eval(bPMSDlgSA)},STR0066,STR0065} } //"Gerenciamento de Projetos"##"Projetos"
			EndIf
		Endif
		nQtdProc:= If( (mv_par02==2), A185QtProc(SCP->CP_PRODUTO), aRetCQ[3] )

		lMT185BUT := ExistBlock( "MT185BUT" )
		While .T.

		    If lMT185BUT
		        If ValType( aUsButtons := ExecBlock( "MT185BUT", .F., .F. ) ) == "A"
				    AEval( aUsButtons, { |x| AAdd( aButton, x ) } )
		        EndIf
	        EndIf

			//Ŀ
			// Envia para processamento dos Gets          
			//
			nOpcA:=0
			dbSelectArea(cAlias)
			If !l185Auto
				DEFINE MSDIALOG oDlg FROM 000, 000 TO 320, 700 TITLE OemToAnsi(STR0008) OF oMainWnd PIXEL // Baixa Pre-Requisicao

				oSize := FwDefSize():New(.T.,,,oDlg)
				oSize:AddObject("FOLDERA", 20, 100, .T., .T.) 		// Totalmente dimensionavel
				oSize:AddObject("FOLDERB", 80, 100, .T., .T.) 		// Totalmente dimensionavel
				oSize:lProp 	 	:= .T. 								// Proporcional
				oSize:lLateral 	:= .T.            					// Diviso lateral
				oSize:aMargins 	:= {3, 3, 3, 3} 						// Espaco ao lado dos objetos 0, entre eles 3
				oSize:Process() 											// Dispara os calculos

				oSizeA := FwDefSize():New()
				oSizeA:aWorkArea 	:= oSize:GetNextCallArea("FOLDERA")
				oSizeA:AddObject("FOLDERA1", 100, 10, .T., .T.) 		// Totalmente dimensionavel
				oSizeA:AddObject("FOLDERA2", 100, 26, .T., .T.) 		// Totalmente dimensionavel
				oSizeA:AddObject("FOLDERA3", 100, 26, .T., .T.) 		// Totalmente dimensionavel
				oSizeA:AddObject("FOLDERA4", 100, 26, .T., .T.) 		// Totalmente dimensionavel
				oSizeA:lProp 	 	:= .T. 								// Proporcional
				oSizeA:aMargins 	:= {3, 3, 3, 3}						// Espaco ao lado dos objetos 0, entre eles 3
				oSizeA:Process() 											// Dispara os calculos

				oSizeB := FwDefSize():New()
				oSizeB:aWorkArea := oSize:GetNextCallArea("FOLDERB")
				oSizeB:AddObject("FOLDERB1", 100, 30, .T., .T.) 		// Totalmente dimensionavel
				oSizeB:AddObject("FOLDERB2", 100, 70, .T., .T.) 		// Totalmente dimensionavel
				oSizeB:lProp 	 	:= .T. 								// Proporcional
				oSizeB:aMargins 	:= {0, 0, 0, 0}						// Espaco ao lado dos objetos 0, entre eles 3
				oSizeB:Process() 											// Dispara os calculos

				oSizeB1 := FwDefSize():New()
				oSizeB1:aWorkArea 	:= oSizeB:GetNextCallArea("FOLDERB1")
				oSizeB1:AddObject("FOLDERB11", 100, 50, .T., .T.) 	// Totalmente dimensionavel
				oSizeB1:AddObject("FOLDERB12", 100, 50, .T., .T.) 	// Totalmente dimensionavel
				oSizeB1:lProp 	:= .T. 								// Proporcional
				oSizeB1:aMargins 	:= {3, 3, 3, 3}						// Espaco ao lado dos objetos 0, entre eles 3
				oSizeB1:Process() 										// Dispara os calculos

				oSizeB2 := FwDefSize():New()
				oSizeB2:aWorkArea 	:= oSizeB:GetNextCallArea("FOLDERB2")
				oSizeB2:AddObject("FOLDERB21", 72, 100, .T., .T.) 	// Totalmente dimensionavel
				oSizeB2:AddObject("FOLDERB22", 28, 100, .T., .T.) 	// Totalmente dimensionavel
				oSizeB2:lProp 	:= .T. 								// Proporcional
				oSizeB2:lLateral	:= .T.
				oSizeB2:aMargins	:= {3, 3, 3, 3}						// Espaco ao lado dos objetos 0, entre eles 3
				oSizeB2:Process() 										// Dispara os calculos

				@ oSize:GetDimension("FOLDERA","LININI"), oSize:GetDimension("FOLDERA","COLINI") TO oSize:GetDimension("FOLDERA","LINEND"), oSize:GetDimension("FOLDERA","COLEND") LABEL "" OF oDlg PIXEL

				@ oSizeB:GetDimension("FOLDERB1","LININI"), oSizeB:GetDimension("FOLDERB1","COLINI") TO oSizeB:GetDimension("FOLDERB1","LINEND"), oSizeB:GetDimension("FOLDERB1","COLEND") LABEL "" OF oDlg  PIXEL
				@ oSizeB:GetDimension("FOLDERB2","LININI")+3, oSizeB:GetDimension("FOLDERB2","COLINI") TO oSizeB:GetDimension("FOLDERB2","LINEND"), oSizeB:GetDimension("FOLDERB2","COLEND") LABEL "" OF oDlg  PIXEL

				@ oSizeA:GetDimension("FOLDERA1","LININI"), oSizeA:GetDimension("FOLDERA1","COLINI") Say OemToAnsi(STR0010) SIZE oSizeA:GetDimension("FOLDERA1","LINEND"), oSizeA:GetDimension("FOLDERA1","COLEND") OF oDlg PIXEL  //"Resumo do Estoque"
				@ oSizeA:GetDimension("FOLDERA2","LININI"), oSizeA:GetDimension("FOLDERA2","COLINI") Say OemToAnsi(STR0011) SIZE oSizeA:GetDimension("FOLDERA2","LINEND"), oSizeA:GetDimension("FOLDERA2","COLEND") OF oDlg PIXEL  //"Quantidade Atual"
				@ oSizeA:GetDimension("FOLDERA2","LININI")+10, oSizeA:GetDimension("FOLDERA2","COLINI") MSGET nQatu When .F. Picture cPict SIZE oSizeA:GetDimension("FOLDERA2","XSIZE"), 10 OF oDlg PIXEL
				@ oSizeA:GetDimension("FOLDERA3","LININI"), oSizeA:GetDimension("FOLDERA3","COLINI") Say OemToAnsi(STR0012) SIZE oSizeA:GetDimension("FOLDERA3","LINEND"), oSizeA:GetDimension("FOLDERA3","COLEND") OF oDlg PIXEL  //"- Reservas PV/OP"
				@ oSizeA:GetDimension("FOLDERA3","LININI")+10, oSizeA:GetDimension("FOLDERA3","COLINI") MSGET nQtRes When .F. Picture cPict SIZE oSizeA:GetDimension("FOLDERA3","XSIZE"), 10 OF oDlg PIXEL
				@ oSizeA:GetDimension("FOLDERA4","LININI"), oSizeA:GetDimension("FOLDERA4","COLINI") Say OemToAnsi(STR0013) SIZE oSizeA:GetDimension("FOLDERA4","LINEND"), oSizeA:GetDimension("FOLDERA4","COLEND") OF oDlg PIXEL  //"= Qtd. Disponivel"
				@ oSizeA:GetDimension("FOLDERA4","LININI")+10, oSizeA:GetDimension("FOLDERA4","COLINI") MSGET nQtSal When .F. Picture cPict SIZE oSizeA:GetDimension("FOLDERA4","XSIZE"), 10 OF oDlg PIXEL

				@ oSizeB1:GetDimension("FOLDERB11","LININI")+2, oSizeB1:GetDimension("FOLDERB11","COLINI") Say OemToAnsi(STR0014) SIZE oSizeB1:GetDimension("FOLDERB11","LINEND"), oSizeB1:GetDimension("FOLDERB11","COLEND") OF oDlg PIXEL //"Numero "
				@ oSizeB1:GetDimension("FOLDERB11","LININI"), oSizeB1:GetDimension("FOLDERB11","COLINI")+30 MSGET SCP->CP_NUM When .F. SIZE 30, 10 OF oDlg PIXEL
				@ oSizeB1:GetDimension("FOLDERB11","LININI")+2, oSizeB1:GetDimension("FOLDERB11","COLINI")+70 Say OemToAnsi(STR0015)SIZE oSizeB1:GetDimension("FOLDERB11","LINEND"), oSizeB1:GetDimension("FOLDERB11","COLEND") OF oDlg PIXEL  //"Produto "
				@ oSizeB1:GetDimension("FOLDERB11","LININI"), oSizeB1:GetDimension("FOLDERB11","COLINI")+100 MSGET SCP->CP_PRODUTO When .F. SIZE 169, 10 OF oDlg PIXEL
				@ oSizeB1:GetDimension("FOLDERB12","LININI")+2, oSizeB1:GetDimension("FOLDERB12","COLINI") Say OemToAnsi(STR0016) SIZE oSizeB1:GetDimension("FOLDERB12","LINEND"), oSizeB1:GetDimension("FOLDERB12","COLEND") OF oDlg PIXEL  //"Descricao "
				@ oSizeB1:GetDimension("FOLDERB12","LININI"), oSizeB1:GetDimension("FOLDERB12","COLINI")+30 MSGET SCP->CP_DESCRI When .F. SIZE 239, 10 OF oDlg PIXEL

				@ oSizeB2:GetDimension("FOLDERB21","LININI")+7, oSizeB2:GetDimension("FOLDERB21","COLINI") Say OemToAnsi(STR0017) SIZE oSizeB2:GetDimension("FOLDERB21","LINEND"), oSizeB2:GetDimension("FOLDERB21","COLEND") OF oDlg PIXEL //"Saldo da Pre-Requisicao "
				@ oSizeB2:GetDimension("FOLDERB22","LININI")+5,oSizeB2:GetDimension("FOLDERB22","COLINI") MSGET aRetCQ[1] Picture cPict When .F. SIZE 72, 10 OF oDlg PIXEL RIGHT
				@ oSizeB2:GetDimension("FOLDERB21","LININI")+27, oSizeB2:GetDimension("FOLDERB21","COLINI") Say OemToAnsi(STR0018) SIZE oSizeB2:GetDimension("FOLDERB21","LINEND"), oSizeB2:GetDimension("FOLDERB21","COLEND") OF oDlg PIXEL //"Quantidade disp. para entrega"
				@ oSizeB2:GetDimension("FOLDERB22","LININI")+25,oSizeB2:GetDimension("FOLDERB22","COLINI") MSGET aRetCQ[2] Picture cPict When .F. SIZE 72, 10 OF oDlg PIXEL RIGHT
				@ oSizeB2:GetDimension("FOLDERB21","LININI")+47, oSizeB2:GetDimension("FOLDERB21","COLINI") Say OemToAnsi(STR0019) SIZE oSizeB2:GetDimension("FOLDERB21","LINEND"), oSizeB2:GetDimension("FOLDERB21","COLEND") OF oDlg PIXEL //"Quantidade em processo de compra"
				@ oSizeB2:GetDimension("FOLDERB22","LININI")+45, oSizeB2:GetDimension("FOLDERB22","COLINI") MSGET nQtdProc  Picture cPict When .F. SIZE 72, 10 OF oDlg PIXEL RIGHT
				@ oSizeB2:GetDimension("FOLDERB21","LININI")+67, oSizeB2:GetDimension("FOLDERB21","COLINI") Say OemToAnsi(STR0020) SIZE oSizeB2:GetDimension("FOLDERB21","LINEND"), oSizeB2:GetDimension("FOLDERB21","COLEND") OF oDlg PIXEL  //"Quantidade a Requisitar"
				@ oSizeB2:GetDimension("FOLDERB22","LININI")+65, oSizeB2:GetDimension("FOLDERB22","COLINI") MSGET nQtRequ Picture cPict Valid a185QtRequ(nQtRequ,aRetCQ[2],aRetCQ[1],nQatu) SIZE 72, 10 OF oDlg PIXEL

				DEFINE SBUTTON FROM 300, 500 TYPE 1 ACTION (IIF(a185QtRequ(nQtRequ,aRetCQ[2],aRetCQ[1],nQatu),(nOpca := 1,oDlg:End()),)) ENABLE OF oDlg
				ACTIVATE MSDIALOG oDlg ON INIT EnChoiceBar(oDlg ,{||IIF(a185QtRequ(nQtRequ,aRetCQ[2],aRetCQ[1],nQatu,,.F.) .And. IIF(!lMT185OK,.T.,A185OK(lMT185OK)),(nOpca := 1,oDlg:End()),)},{||nOpca:=3,oDlg:End()},,aButton) CENTERED
			Else
				//Ŀ
				// Quantidade a ser baixada pela rotina automatica |
				//
				For nX:=1 to len(aAutoSCP)
					If Upper(AllTrim(aAutoSCP[nX,1])) == "CP_QUANT"
						nQtRequ := aAutoSCP[nX,2]
					EndIf
				Next
				//Ŀ
				// Valida a quantidade a ser baixada				|
				//
				If a185QtRequ(nQtRequ,aRetCQ[2],aRetCQ[1],nQatu)
					nOpcA := 1
				Else
					Exit
				EndIf
			EndIF

			dbSelectArea(cAlias)

			//Ŀ
			// P.E. Utilizado para validar a baixa da pre-requisicao  
			//
			If lM185Mod1 .And. nOpcA == 1
				If !ExecBlock("M185MOD1",.F.,.F.,{SCP->CP_FILIAL,SCP->CP_PRODUTO,SCP->CP_LOCAL,nQatu,nQtRes,nQtSal,SCP->CP_NUM,aRetCQ[1],aRetCQ[2],nQtdProc,nQtRequ})
					nOpca := 3
				Endif
			EndIf

			IF nOpcA == 1
				Begin Transaction

					If IntePMS().And. Len(aRatAFH) > 0
						aDadosPrjTmp	:=	PMSAFHDados(aRatAFH,SCP->CP_ITEM,nQtRequ)

						//
						// Gera um movimento interno para cada rateio
						// no PMS.
						//
						// A quantidade de cada movimento interno ser definida
						// pelo campo AFH_QBAIX.
						//
						For nX:=1 To Len(aDadosPrjTmp)
							aDadosPRJ	:=	aDadosPrjTmp[nX]
							AAdd(aDadosPRJ,(nX > 1))
							lContinua := A185Gera()
							If !lContinua
								Exit
							Endif
						Next nX
					Else

						// Verificar se existem amarraes de Solicitao ao Armazm
						// com o PMS
						If IntePms()
							lContinua := PmsAFHVal(SCP->CP_NUM, SCP->CP_ITEM, aRatAFH)

							If lContinua
								lContinua := A185Gera()
							EndIf
						Else
							lContinua := A185Gera()
						EndIf
					Endif
				End Transaction

				If lContinua .And. lChgNewDoc
					Help("",1,"A240DOC",,cNewDoc,4,30)
				EndIf

				Exit
			Else
				MsUnLock()
			EndIf
			If nOpcA == 3
				Exit
			EndIf
		EndDo
	EndIf
EndIf

//-- Libera os registros bloqueado pelo SoftLock
MsUnlockAll()

If IntePms()		// Se usa PMS integrado com o ERP
	SetKey(VK_F10,Nil)
EndIf

dbSelectArea(cAlias)
dbGoto(nReg)
Return lRet

/*

Ŀ
Funo    A185AtuSD3 Autor  Edson Maricate         Data  25.11.98 
Ĵ
Descrio  Atualiza as variaveis de memoria para Inclusao no SD3.     
Ĵ
Parametros Nenhum                                                     
Ĵ
Retorno    Nenhum                                                     
Ĵ
Uso        MatA185                                                    
ٱ


*/
Function A185AtuSD3()
Local cSavAlias:= Alias()
Local aCTBEnt  := CTBEntArr()
Local nA	   := 0
Local lWmsNew := SuperGetMv("MV_WMSNEW",.F.,.F.)
dbSelectArea("SB1")
dbSetOrder(1)
dbSeek(xFilial()+SCP->CP_PRODUTO)
If IntePMS() .And. Type("aDadosPrj") == 'A' .And. Len(aDadosPrj) > 0
	If aDadosPrj[4]
		M->D3_TM		:= SD3->D3_TM
	Endif
	M->D3_PROJPMS 	:= aDadosPrj[1]
	M->D3_TASKPMS 	:= aDadosPrj[2]
	M->D3_QUANT 	:= aDadosPrj[3]
Else
	M->D3_QUANT 	:= nQtRequ
Endif
M->D3_COD		:= SCP->CP_PRODUTO
M->D3_UM		:= SCP->CP_UM
M->D3_CONTA		:= SCP->CP_CONTA
M->D3_CLVL		:= SCP->CP_CLVL
M->D3_ITEMCTA	:= SCP->CP_ITEMCTA
M->D3_LOCAL		:= SCP->CP_LOCAL
M->D3_EMISSAO	:= DDATABASE
M->D3_GRUPO  	:= SB1->B1_GRUPO
M->D3_CC		:= SCP->CP_CC
M->D3_SEGUM		:= SCP->CP_SEGUM
M->D3_QTSEGUM	:= IIf(A185SegUm(M->D3_COD)==1,ConvUM(SCP->CP_PRODUTO,M->D3_QUANT,0,2),IIf(SCP->CP_QUANT == 0,0,(SCP->CP_QTSEGUM/SCP->CP_QUANT)*M->D3_QUANT))
M->D3_TIPO		:= SB1->B1_TIPO
M->D3_OP		:= SCP->CP_OP
M->D3_OSTEC		:= SCP->CP_NUMOS
M->D3_NUMSA := SCP->CP_NUM
M->D3_ITEMSA := SCP->CP_ITEM
If SCP->(ColumnPos("CP_TRT") > 0)
	M->D3_TRT := SCP->CP_TRT
EndIf

If AllTrim(GetNewPar("MV_NGMNTNO","N")) == "1" .And. SubStr(M->D3_OP,7,5) == "OS001"
	M->D3_ORDEM := SubStr(M->D3_OP,1,6)
EndIf

For nA := 1 To Len(aCTBEnt)
	M->&("D3_EC"+aCTBEnt[nA]+"CR") := SCP->&("CP_EC"+aCTBEnt[nA]+"CR")
	M->&("D3_EC"+aCTBEnt[nA]+"DB") := SCP->&("CP_EC"+aCTBEnt[nA]+"DB")
Next nA

If lWmsNew .And. IntWMS(M->D3_COD)
	M->D3_SERVIC := Posicione("SB5",1,xFilial("SB5")+M->D3_COD,"B5_SERVREQ")
EndIf

If ExistBlock('MT185SD3')
	ExecBlock('MT185SD3',.F.,.F.)
EndIf

dbSelectArea(cSavAlias)
Return

/*/

Ŀ
Funo    A185QtRequ Autor  Edson Maricate         Data 02.12.1998
Ĵ
Descrio  Valida a quantidade digitada.                              
Ĵ
Sintaxe    A185QtRequ(ExpN1,ExpN2,ExpN3,ExpN4,ExpN5,ExpL1,ExpC1,ExpC2)
Ĵ
Parametros ExpN1 = qtde.                                              
           ExpN2 = qtde.disponivel                                    
           ExpN3 = Saldo                                              
           ExpN4 = qtde.atual                                         
           ExpN5 = qtde.total                                         
           ExpL1 = indica Bx.Pre                                 	  
           ExpC1 = projeto (PMS)                                	  
           ExpC2 = tarefa (PMS)                                 	  
           ExpA1 = Acols das pre-requisicoes - baixa por pre-requisic.
Ĵ
Retorno    .T. / .F.             	                                  
Ĵ
 Uso       MATA185                                                    
ٱ


/*/
Function A185QtRequ(nQuant,nDisp,nQtSal,nQatu,nQtdTot,lBxPre,cProjeto,cTarefa,aCols)
Local lRet      := .T.
Local lEstNeg   := If(GetMV('MV_ESTNEG')=='N',.F.,.T.)
Local nPosRat	:=	0

//Qtd. Total selecionada
Default nQtdTot := 0
Default lBxPre	:= .T.
Default aCols   := {}

// Avalia se existe empenho para este item
If mv_par03 == 1
	If FindFunction("A106EmpSCP")
		If A106EmpSCP(SCP->CP_PRODUTO,SCP->CP_LOCAL,SCP->CP_OP,nQuant)
			Return lRet
		EndIf
	Else
		If AvalEmpSCP(SCP->CP_PRODUTO,SCP->CP_LOCAL,SCP->CP_OP,nQuant)
			Return lRet
		EndIf
	EndIf
EndIf

If lRet .And. ((nQatu-nQuant) < 0 .Or. ((nQtdTot+nQuant) > (SaldoSB2()+nDisp) .And. mv_par03 == 2 .And. !lPermBx)) .And. !lEstNeg
	Help(" ",1,"MA240NEGAT")
	lRet := .F.
EndIf
If lRet .And. nQuant > nQtSal
	Help ("    ",1,"QTDISP")  	// Exibe o Help
	lRet := .F.					// Nao Permite a baixa
EndIf
If lRet .And. nQuant > nDisp
	If !A185ValEmp(SCP->CP_PRODUTO,SCP->CP_LOCAL,nQuant,SCP->CP_NUM,SCP->CP_ITEM,aCols)
		lRet := .F.
	ElseIf nQuant <= nQtSal
		// "Qtde. Disp. Nao Solicitada Para Esta Requisicao. Deseja Utiliza-la Mesmo Assim?" ### "Sim" ### "Nao"
		If !lPermBx
			If lBxPre .And. If(l185Auto,aPerg[3] == 2,Aviso("SIGAEST", STR0021, {STR0022, STR0023}) == 2)
				lRet := .F.
			EndIf
		Endif
	Else
		Help ("    ",1,"QTDISP")  	// Exibe o Help
		lRet := .T.					// Permite a baixa
	EndIf
EndIf
If lRet .And. nQuant <= 0
	Help("    ",1,"VALZERADO")
	lRet := .F.
EndIf
If lRet .And. IntePMS() .And. (nPosRat := Ascan(aRatAFH,{|x| x[1]==SCP->CP_ITEM})) > 0
	lRet	:=	PMSAFHValid(nPosRat,nQuant,cProjeto,cTarefa)
Endif
Return lRet

/*


Ŀ
Funo    MTA185PERG Autor  Edson Maricate         Data  10/12/98 
Ĵ
Descrio  Chamada da funcao PERGUNTE                                 
Ĵ
Parametros Nenhum                                                     
Ĵ
Retorno    Nenhum                                                     
Ĵ
 Uso       MATA185                                                    
ٱ


*/
Static Function MTA185PERG()
//Ŀ
// Ativa tecla F12 para acionar perguntas                         
//
Pergunte("MTA185",.T.)
Pergunte("MTA240",.T.)

Return Nil

/*


Ŀ
Funo    A185Exclui Autor  Cesar Valadao          Data 07/02/2000
Ĵ
Descrio  Programa da Exclusao das Pre-Requisicoes.                  
Ĵ
Sintaxe    A185Exclui(ExpC1,ExpN1,ExpN2)                              
Ĵ
Parametros ExpC1 = Alias do arquivo                                   
           ExpN1 = Numero do registro                                 
           ExpN2 = Opcao selecionada                                  
Ĵ
Retorno    Nenhum                                                     
Ĵ
 Uso       MATA185                                                    
ٱ


/*/
Function A185Exclui(cAlias,nReg,nOpc)
Local oDlg			:= NIL

Local aObjects		:= {}
Local aSize			:= {}
Local aInfo    		:= {}
Local aDocs			:= {}

Local nOpcA			:= 0

Local lRet			:= .T.
Local lM185Excl		:= ExistBlock("M185EXCL")
Local lM185VldExc	:= ExistBlock("M185VLDEXC")
Local lPcoInt	  	:= SuperGetMV("MV_PCOINTE",.F.,"2")=="1"
Local lExcDocCom    := .T.	// Informa se permite excluir o documento de compra vinculado com a Pr-Req

Default nReg := Recno()
//Ŀ
// Monta a entrada de dados do arquivo                          
//
PRIVATE aTELA[0][0], aGETS[0]

//Carrega varivel static '__lSaOrdSep'
FnVlSaOs()

cCadastro := OemToAnsi(STR0006) //"Exclusao das Pre-requisicoes"

If Empty(SCP->CP_STATUS) .And. SCP->CP_PREREQU == "S" .And. QtdComp(SCP->CP_QUJE) > QtdComp(0)
	Help("",1,"HELP","A185PARCIAL",STR0081,1,,,,,,,{STR0082}) //"Pr-requisio possui baixa parcial!!"  |  "Primeiro exclua a baixa parcial"
	Return .F.
EndIf
If SCP->CP_STATUS == "E"
	HELP("   ",1,"A185EXCL")
	Return .F.
EndIf

If Empty(SCP->CP_PREREQU)
	HELP("   ",1,"A185EXCPRE")
	Return .F.
EndIf

//Verifica se existe vinculo com SIGAACD, para no permitir atualizao dentro da rotina
If !l185Auto .And. __lSaOrdSep .And. !Empty(SCP->CP_ORDSEP)
	Help(NIL, NIL, "SIGAACD", NIL, STR0109, 2, 0, NIL, NIL, NIL, NIL, NIL, {""})	//"Solicitacao ao Armazem vinculada uma 'Ordem de Separacao', nao e possivel realizar a exclusao enquanto a SA estiver vinculada."
	Return .F.
EndIf

//Ŀ
// Verifica calendrio contbil                
//
If lRet
	lRet := CtbValiDt(Nil,dDataBase,,Nil ,Nil ,{"EST001"})
EndIf

If !lRet
	Return .F.
EndIf

While .T.
	//Ŀ
	// Envia para processamento dos Gets          
	//
	nOpcA:=0
	dbSelectArea(cAlias)
	SoftLock(cAlias)

	If !l185Auto
		//Ŀ
		// Ajusta a largura para o tamanho padrao Protheus 
		//
		aSize := MsAdvSize()
		aObjects := {}
		AAdd( aObjects, { 100, 100, .T., .T. } )
		aInfo    := { aSize[1], aSize[2], aSize[3], aSize[4], 2, 2 }
		aPosObj := MsObjSize( aInfo, aObjects )

		DEFINE MSDIALOG oDlg TITLE cCadastro FROM aSize[7],0 TO aSize[6],aSize[5] OF oMainWnd PIXEL
		nOpcA:=EnChoice( cAlias, nReg, nOpc, ,"AC",OemToAnsi(STR0007),,aPosObj[1])  //"Quanto  excluso?"
		nOpca := 1
		ACTIVATE MSDIALOG oDlg ON INIT EnchoiceBar(oDlg,{|| IIF(A185VldExc(SCP->CP_NUM, SCP->CP_ITEM, @lExcDocCom), (nOpca := 2, oDlg:End()), nOpca := 1)},{|| nOpca := 1,oDlg:End()})

		dbSelectArea(cAlias)
	Else
		nOpcA := 2
	Endif

	IF nOpcA == 2
		If lM185VldExc
			lRet :=	ExecBlock("M185VldExc",.F.,.F.)
			lRet := If(ValType(lRet)#"L",.T.,lRet)
		EndIf
		If lRet
			//Ŀ
			// Apos passar por todas as verificacoes, deleta o registro     
			//
			Begin Transaction
				SCQ->(dbSeek(xFilial("SCQ")+SCP->CP_NUM+SCP->CP_ITEM))
				While !SCQ->(Eof()) .And. SCQ->(CQ_FILIAL+CQ_NUM+CQ_ITEM) == xFilial("SCQ")+SCP->CP_NUM+SCP->CP_ITEM

					If SCQ->CQ_QTDISP > 0
						dbSelectArea("SB2")
						dbSeek(xFilial()+SCQ->CQ_PRODUTO+SCQ->CQ_LOCAL)
						RecLock("SB2",.F.)
						Replace B2_QEMPSA With Max(0,B2_QEMPSA - SCQ->CQ_QTDISP)
						MsUnlock()
					EndIf

					If lM185Excl
						ExecBlock("M185EXCL",.F.,.F.)
					EndIf
					RecLock("SCQ",.F.,.T.)
					SCQ->(dbDelete())
					SCQ->(MsUnlock())
					SCQ->(dbSkip())
				EndDo
				aadd(aDocs,;
					{SCP->CP_PRODUTO			,;			//aPequena[x,1] : Produto
							 SCP->CP_QUANT	,;			//aPequena[x,2] : Quantidade total
							 xFilial("SCP",cFilAnt),;			//aPequena[x,3] : Filial que ser gerada o documento
							 cFilAnt 			,;			//aPequena[x,4] : Filial que ser feita entrega do produto
							      				,;			//aPequena[x,5] : Documento que ser gerado sendo 1=Solicitao de Compras e 2=Pedido de Compra
							      				,; 			//aPequena[x,6] : Fornecedor do produto
							      				,; 			//aPequena[x,7] : Loja do fornecedor do produto
							   					,;			//aPequena[x,8] : Condio de pagamento
							 SCP->CP_VUNIT	,;		 	//aPequena[x,9] : Preo do Produto
							 {}					,;		 	//aPequena[x,10] : Array de Rateios
							 SCP->CP_NUM		,;		 	//aPequena[x,11] : Cdigo Documento
							 SCP->CP_ITEM		})		 	//aPequena[x,12] : Item do Documento

				dbSelectArea("SCP")
				RecLock("SCP",.F.)
				SCP->CP_PREREQU := " "	// Permite Gerar Novas Pre-Requisicoes
				MsUnlock()

				If lPcoInt
					PcoDetLan("000051","01","MATA110",.T.)
				EndIf
				ComGeraDoc(aDocs,.T.,.F.,.F.,.T.,30,"MATA185",/*lEnviaEmail*/,/*Aglutina?*/,5,lExcDocCom)
			End Transaction
		EndIf
	Else
		MsUnLock()
	EndIf
	Exit
End

dbSelectArea(cAlias)
Return

/*


Ŀ
Funo    A185Estorn Autor  Larson Zordan          Data 07/02/2002
Ĵ
Descrio  Programa do Estorno  das Pre-Requisicoes.                  
Ĵ
Sintaxe    A185Estorn(ExpC1,ExpN1,ExpN2)                              
Ĵ
Parametros ExpC1 = Alias do arquivo                                   
           ExpN1 = Numero do registro                                 
           ExpN2 = Opcao selecionada                                  
Ĵ
Retorno    Nenhum                                                     
Ĵ
 Uso       MATA185                                                    
ٱ


/*/
Function A185Estorn(cAlias,nReg,nOpc)
Local oNo 	   	:= LoadBitmap( GetResources(), "LBNO"  )
Local oOk 	   	:= LoadBitmap( GetResources(), "LBTIK" )
Local nOpca    	:= 0
Local aAreaAnt 	:= GetArea()
Local aBaixas  	:= {}
Local aItSCQ   	:= {}
Local cItBx    	:= ''
Local dDataFec 	:= MVUlmes()
Local lDataFec 	:= .F.
Local oDlg
Local oDlgA
Local oLbxA
Local oSizeA	:= {}
Local lRet		:= .T.
Local aNumSCDhn	:= {}
Local cDocSC	:= ""
Local cItSC		:= ""
Local lWmsNew   := SuperGetMV("MV_WMSNEW",.F.,.F.)
Local cSeek		:= ""
Local aNoFields	:= { "CP_NUM" }
Local bSeekSCP  := {}
Local bSeekSCQ  := {}
Local aDados    := {}
Local aDadosSCQ := {}
Local oSize
Local oSize2
Local nX
Local lEstItem := IsBlind() .Or. (if (cPaisLoc $ ('EQUPORHAIANG'), MV_PAR05 == 2, MV_PAR04 == 2))
Local nRecSCP := SCP->(Recno())
//Ŀ
// Estas variaveis indicam para as funcoes de validacao qual    
// programa as esta' chamando                                   
//
Private l240:=.T.,l250:=.F.,l241:=.F.,l242:=.F.,l261:=.F.,l185 :=.T.
Private aHeader := {}
Private aCols   := {}
Private cSolic 		:= SCP->CP_SOLICIT
Private dA185Data	:= SCP->CP_EMISSAO
Private cA185Num 	:= SCP->CP_NUM
Private cA185Item   := SCP->CP_ITEM
Private cA185Filial	:= SCP->CP_FILIAL

//Carrega varivel static '__lSaOrdSep'
FnVlSaOs()

If SCP->CP_QUJE == 0
	If SCP->CP_STATUS == "E"
		If l185Auto
			AutoGrLog(OemToAnsi(STR0077))
		Else
			Aviso("A185ESTORNO",OemToAnsi(STR0077),{OemToAnsi(STR0039)})
		EndIf
   Else
		If l185Auto
			AutoGrLog(OemToAnsi(STR0056))
		Else
			Aviso("A185ESTORNO",OemToAnsi(STR0056),{OemToAnsi(STR0039)})
		EndIf
	EndIf
	Return .F.
EndIf

If Empty(SCP->CP_PREREQU)
	Help("   ",1,"A185PRE")
	Return .F.
EndIf

//Verifica se existe vinculo com SIGAACD, para no permitir atualizao dentro da rotina
If !l185Auto .And. __lSaOrdSep .And. !Empty(SCP->CP_ORDSEP)
	Help(NIL, NIL, "SIGAACD", NIL, STR0110, 2, 0, NIL, NIL, NIL, NIL, NIL, {""})	//"Solicitacao ao Armazem vinculada uma 'Ordem de Separacao', nao e possivel realizar o estorno enquanto a SA estiver vinculada."
	Return .F.
EndIf

//------------------------------------------------------
// Caso haja EPI entregue a algum funcionario, no
// poder realizar o estorno (SIGAMDT)
// MV_NGMDTES dever estar habilitado
//------------------------------------------------------
If FindFunction('MDTValEst') .And. !MDTValEst( SCP->CP_NUM + SCP->CP_ITEM , SCP->CP_FILIAL , 2 )
	Return .F.
Endif

//--------------------------------------------------------------
// Valida estorno de movimentao - SIGAMNT
//--------------------------------------------------------------
If FindFunction( 'MNTVLDEST' ) .And. !MNTVLDEST('MATA185')
	Return .F.
EndIf

//Ŀ
// Verifica calendrio contbil                
//
If lRet
	lRet := CtbValiDt(Nil,dDataBase,,Nil ,Nil ,{"EST001"})
EndIf

If lRet
	//Ŀ
	// Monta aHeader e aCols utilizando a funcao FillGetDados   
	//
	If !lEstItem // Estorno por Documento
		cSeek	 := cA185Filial + cA185Num
		bSeekSCP := { || SCP->CP_FILIAL + SCP->CP_NUM }
		bSeekSCQ := { || SCQ->CQ_FILIAL + SCQ->CQ_NUM }
	Else // Estorno por Item
		cSeek	 := cA185Filial + cA185Num + cA185Item
		bSeekSCP := { || SCP->CP_FILIAL + SCP->CP_NUM + SCP->CP_ITEM }
		bSeekSCQ := { || SCQ->CQ_FILIAL + SCQ->CQ_NUM + SCQ->CQ_ITEM }
	EndIf

	//Ŀ
	// Sintaxe da FillGetDados( nOpcx, cAlias, nOrder, cSeekKey, bSeekSCP, uSeekFor, aNoFields, aYesFields, lOnlyYes, cQuery, bMontCols, lEmpty, aHeaderAux, aColsAux, bAfterCols, bBeforeCols, bAfterHeader, cAliasQry ) |
	//
	FillGetDados(nOpc,cAlias,1,cSeek,bSeekSCP,{||.T.},aNoFields)

	A185GtCols()

	If !lEstItem // Estorno por Documento
		lEstItem := A185VldIt(lWmsNew)
	EndIf

	If !l185Auto
			//Ŀ
			// Calcula dimenses                                            
			//
			oSize := FwDefSize():New()
			oSize:AddObject( "CABECALHO",  100, 5, .T., .T. ) // Totalmente dimensionavel
			oSize:AddObject( "GETDADOS" ,  100, 85, .T., .T. ) // Totalmente dimensionavel

			oSize:lProp 	:= .T. // Proporcional
			oSize:aMargins 	:= { 3, 3, 3, 3 } // Espaco ao lado dos objetos 0, entre eles 3

			oSize:Process() // Dispara os calculos

			//Ŀ
			// Divide cabealho                                             
			//
			oSize2 := FwDefSize():New()

			oSize2:aWorkArea := oSize:GetNextCallArea( "CABECALHO" )

			oSize2:AddObject( "NUMERO"  ,  20, 100, .T., .T.) // Dimensionavel
			oSize2:AddObject( "SOLICIT" ,  20, 100, .T., .T.) // Dimensionavel
			oSize2:AddObject( "DATA"    ,  20, 100, .T., .T.) // Dimensionavel

			oSize2:lLateral := .T.            //Calculo em Lateral
			oSize2:lProp := .T.               // Proporcional
			oSize2:aMargins := { 3, 3, 0, 0 } // Espaco ao lado dos objetos 0, entre eles 3

			oSize2:Process() // Dispara os calculos

			DEFINE MSDIALOG oDlg TITLE OemToAnsi("Solicitao de Armazens") OF oMainWnd PIXEL; //"Solicitao de Armazens"
			FROM oSize:aWindSize[1],oSize:aWindSize[2] TO oSize:aWindSize[3],oSize:aWindSize[4] OF oMainWnd PIXEL

			@ oSize2:GetDimension("NUMERO","LININI")+2,oSize2:GetDimension("NUMERO","COLINI")    SAY OemToAnsi(STR0104)  Of oDlg PIXEL //"Nmero"
			@ oSize2:GetDimension("NUMERO","LININI")  ,oSize2:GetDimension("NUMERO","COLINI")+25 MSGET cA185Num 	When .f. Of oDlg PIXEL

			@ oSize2:GetDimension("SOLICIT","LININI")+2,oSize2:GetDimension("SOLICIT","COLINI")    SAY OemToAnsi(STR0105) 	 Of oDlg PIXEL //"Solicitante"
			@ oSize2:GetDimension("SOLICIT","LININI")  ,oSize2:GetDimension("SOLICIT","COLINI")+30 MSGET cSolic  Pict "@S10" 	When .f.  Of oDlg PIXEL

			@ oSize2:GetDimension("DATA","LININI")+2,oSize2:GetDimension("DATA","COLINI") SAY OemToAnsi(STR0106)	 Of oDlg PIXEL	//"Data de Emisso"
			@ oSize2:GetDimension("DATA","LININI")  ,oSize2:GetDimension("DATA","COLINI")+45 MSGET dA185Data When .F. Of oDlg PIXEL

			MSGetDados():New(oSize:GetDimension("GETDADOS","LININI"),oSize:GetDimension("GETDADOS","COLINI"),;
									oSize:GetDimension("GETDADOS","LINEND"),oSize:GetDimension("GETDADOS","COLEND"),;
									nOpc,/*cLinhaOk*/,/*cTudoOk*/,"",.F.,NIL,NIL,NIL,LINHAS,/*cFieldOk*/,,,/*cDelOk*/,oDlg)

			Activate MsDialog oDlg On Init EnchoiceBar(oDlg,{|| nOpca := 1,oDlg:End()},{|| nOpca := 2,oDlg:End()},,)
	Else
		nOpca := 1
	EndIf

	If nOpca == 1
		If !lEstItem // Estorno por Documento
			SCP->(dbSetOrder(1)) // CP_FILIAL+CP_NUM+CP_ITEM+DTOS(CP_EMISSAO)
			SCP->(dbSeek(xFilial()+cA185Num+Acols[1,aScan(aHeader,{|x| Trim(x[2])=="CP_ITEM"})]))
		Else // Estorno do Item de Documento
			SCP->(MSGoTo(nRecSCP))	
		EndIf

		dbSelectArea("SCQ")
		dbSetOrder(1) // CQ_FILIAL+CQ_NUM+CQ_ITEM+CQ_NUMSQ
		If SCQ->(dbSeek(xFilial()+SCP->CP_NUM+SCP->CP_ITEM))
			
			cChaveSCP := SCP->CP_FILIAL + SCP->CP_NUM
			cChaveSCQ := SCQ->CQ_FILIAL + SCQ->CQ_NUM
			If lEstItem // Estorno por Item
				cChaveSCP := cChaveSCP + SCP->CP_ITEM
				cChaveSCQ := cChaveSCQ + SCQ->CQ_ITEM
			EndIf
			
			While SCP->(!EoF()) .And. Eval(bSeekSCP) == cChaveSCP
				While SCQ->(!Eof()) .And. Eval(bSeekSCQ) == cChaveSCQ
					If !lEstItem // Estorno por Documento
						If SCP->CP_ITEM <> SCQ->CQ_ITEM
							Exit
						EndIf
					EndIf
					//Recupera a SC gerada pela Central de Compras
					aNumScDhn := COMPosDHN({2,{SCP->CP_FILIAL,SCP->CP_NUM,SCP->CP_ITEM,"1",'MATA106'}})
					If aNumSCDhn[1]
						cDocSC	:= (aNumScDhn[2])->DHN_DOCDES
						cItSC	:= (aNumScDhn[2])->DHN_ITDES
						(aNumSCDhn[2])->(DbCloseArea())
					EndIf
					aAdd(aItSCQ,{ SCQ->CQ_PRODUTO, SCQ->CQ_NUMREQ, SCQ->CQ_QTDISP, SCQ->CQ_QUANT, SCQ->(Recno()),cDocSC,cItSC})
					If !Empty(SCQ->CQ_NUMREQ)
						If (lWmsNew .And. IntWMS(SCP->CP_PRODUTO))
							If FindFunction("Wms185EstA")
								aBaixas := Wms185EstA(SCQ->CQ_PRODUTO, SCQ->CQ_NUMREQ, SCQ->(Recno()), dDataFec)
							EndIf
						Else
							SD3->(dbSetOrder(4))
							If SD3->(dbSeek(xFilial("SD3")+SCQ->CQ_NUMREQ+"E0"+SCQ->CQ_PRODUTO))
								If dDataFec < SD3->D3_EMISSAO
									aAdd(aBaixas,{.T.,SD3->D3_EMISSAO,Transform(SD3->D3_QUANT,PesqPict("SD3","D3_QUANT",14)),SD3->(Recno()),SCQ->(Recno()),SCP->(Recno()),SCP->CP_NUM,SCP->CP_ITEM,SCP->CP_PRODUTO})
								Else
									lDataFec := .T.
								EndIf
							EndIf
						EndIf
					EndIf
					SCQ->(dbSkip())
				EndDo
				aAdd(aDadosSCQ, {aItSCQ,SCP->(Recno())} )
				aItSCQ := {}
				SCP->(dbSkip())
			EndDo
			
			If lEstItem 
				SCP->(DbGoTo(nRecSCP))	
			EndIf
		EndIf

		If Len(aBaixas) > 1

			If !l185Auto
				Define MsDialog oDlgA Title OemToAnsi(STR0057) From 0, 0 To 20, 60 Of oMainWnd  //"Baixas Parciais"

				oSizeA := FwDefSize():New(.T.,,,oDlgA)
				oSizeA:AddObject("FOLDERA", 100, 100, .T., .T.) 		// Totalmente dimensionavel
				oSizeA:lProp 	 	:= .T. 								// Proporcional
				oSizeA:aMargins 	:= {3, 3, 3, 3} 						// Espaco ao lado dos objetos 3, entre eles 3
				oSizeA:Process() 											// Dispara os calculos
				If Len(aBaixas[1]) > 6 
					@ oSizeA:GetDimension("FOLDERA","LININI"),oSizeA:GetDimension("FOLDERA","COLINI");
						ListBox oLbxA Var cItBx Fields Header " ", STR0058, STR0059, STR0060, STR0104, STR0088, STR0107; //"Seq.","Data Baixa","Quant.","Nmero","Item","Produto"
						Size oSizeA:GetDimension("FOLDERA","XSIZE"),oSizeA:GetDimension("FOLDERA","YSIZE");
						On DBLCLICK (aBaixas:=a185Marca(oLbxA:nAt,aBaixas),oLbxA:Refresh()) PIXEL OF oDlgA
				Else
					@ oSizeA:GetDimension("FOLDERA","LININI"),oSizeA:GetDimension("FOLDERA","COLINI");
						ListBox oLbxA Var cItBx Fields Header " ", STR0058, STR0059, STR0060; 	//"Seq.","Data Baixa","Quant."
						Size oSizeA:GetDimension("FOLDERA","XSIZE"),oSizeA:GetDimension("FOLDERA","YSIZE");
						On DBLCLICK (aBaixas:=a185Marca(oLbxA:nAt,aBaixas),oLbxA:Refresh()) PIXEL OF oDlgA
				EndIf
				oLbxA:SetArray(aBaixas)
				If Len(aBaixas[1]) > 6
					oLbxA:bLine := { || {If(aBaixas[oLbxA:nAt,1],oOk,oNo),StrZero(oLbxA:nAt,2),aBaixas[oLbxA:nAt,2],aBaixas[oLbxA:nAt,3],aBaixas[oLbxA:nAt,7],aBaixas[oLbxA:nAt,8],aBaixas[oLbxA:nAt,9]}}
				Else
					oLbxA:bLine := { || {If(aBaixas[oLbxA:nAt,1],oOk,oNo),StrZero(oLbxA:nAt,2),aBaixas[oLbxA:nAt,2],aBaixas[oLbxA:nAt,3]}}
				EndIf
				Activate MsDialog oDlgA Center On Init EnchoiceBar(oDlgA,{|| nOpca := 1,oDlgA:End()},{|| nOpca := 2,oDlgA:End()},,)
			Else
				nOpca:=1
			EndIf

			If nOpca == 1
				For nX := 1 To Len(aBaixas)
					If aBaixas[nX,1]
						aDados := {}
						aAdd(aDados, aBaixas[nX])
						If lEstItem
							nPosSCQ := 1
						Else
							nPosSCQ := aScan(aDadosSCQ, {|x| x[2] == aBaixas[nX,6]})
						EndIf
						If nPosSCQ > 0
							aItSCQ := aDadosSCQ[nPosSCQ,1]
							If !lEstItem
								SCP->(dbGoTo(aBaixas[nX][6]))
							EndIf
							Processa({|lEnd| A185MovSD3(aDados,aItSCQ)},STR0061,STR0062,.F.)  //"Processando...","Estorno das Baixas"
						EndIf
					EndIf
				Next
			EndIf

		Else
			If Len(aBaixas) > 0
				For nX := 1 To Len(aBaixas)
					If aBaixas[nX,1]
						aDados := {}
						aAdd(aDados, aBaixas[nX])
						If lEstItem
							nPosSCQ := 1
						Else
							nPosSCQ := aScan(aDadosSCQ, {|x| x[2] == aBaixas[nX,6]})
						EndIf
						If nPosSCQ > 0
							aItSCQ := aDadosSCQ[nPosSCQ,1]
							If !lEstItem
								SCP->(dbGoTo(aBaixas[nX][6]))
							EndIf
							Processa({|lEnd| A185MovSD3(aDados,aItSCQ)},STR0061,STR0062,.F.)  //"Processando...","Estorno das Baixas"
						EndIf
					EndIf
				Next
			Else
				If lDataFec
					Help(" ",1,"FECHTO")
				EndIf
			EndIf
		EndIf
		//Integrao FSM
		IF (FWAliasInDic("JO3") .And. FindFunction('FSMintSCP')) .And. !Empty(SCP->CP_NUMOS) 
			FSMintSCP( 3 , SCP->CP_NUM , SCP->CP_ITEM , SCP->CP_PRODUTO, SCP->CP_LOCAL, SCP->CP_NUMOS, SCP->CP_CODSOLI,;
						SCP->CP_QUANT, SCP->CP_QUJE, SCP->CP_STATUS, SCP->CP_PREREQU)
		Endif	
	EndIf
EndIf

RestArea(aAreaAnt)
Return

/*


Ŀ
Funo    A185Marca  Autor  Larson Zordan          Data 10/02/2003
Ĵ
Descrio  Marca as requisicoes a serem estornadas.                   
Ĵ
Sintaxe    A185Marca(ExpA1)                                           
Ĵ
Parametros ExpN1 = Posicao do item dentro do Array                    
           ExpA1 = Array com os dados da listbox                      
Ĵ
Retorno    ExpA1 = Array com os dados da listbox                      
Ĵ
 Uso       MATA185                                                    
ٱ


*/
Static Function A185Marca(nIt,aArray)
aArray[nIt,1] := !aArray[nIt,1]
Return( aArray )

/*


Ŀ
Funo    A185MovSD3 Autor  Larson Zordan          Data 10/02/2003
Ĵ
Descrio  Atualiza os dados do estorno das pre-requisicoes           
Ĵ
Sintaxe    A185MovSD3(ExpA1,ExpA2)                                    
Ĵ
Parametros ExpA1 = Array com as requisicoes (SD3)                     
           ExpA2 = Array com as pre-requisicoes (SCQ)                 
Ĵ
Retorno    Nenhum                                                     
Ĵ
 Uso       MATA185                                                    
ٱ


*/
Static Function A185MovSD3(aDados,aItSCQ)

Local aRegSCQ    := {}
Local a241ISD3	 := {}
Local nX         := 0
Local nReg       := 0
Local nPos       := 0
Local nQtd       := 0
Local nQtDisp    := 0
Local lPrj		 :=	.F.
Local lRet       := .T.
Local aRetInt	 := {}
Local lMT185EST  := ExistBlock('MT185EST')
Local lWmsNew    := SuperGetMV("MV_WMSNEW",.F.,.F.)
Local lExit      := .F.
Local aWmsRet    := {}
Local cProjPMS   := ''
Local cTaskPMS   := ''
Local aRetSX5    := {}

//-- Variavel usada para verificar se o disparo da funcao IntegDef() pode ser feita manualmente
Local lIntegDef  :=  FWHasEAI("MATA241")

Private l240Auto := .T.
Private cCusMed  := GetMv("MV_CUSMED")
//Ŀ
// Verifica se o custo medio e' calculado On-Line               
//
If cCusMed == "O"
	Private nHdlPrv 			// Endereco do arquivo de contra prova dos lanctos cont.
	Private lCriaHeader := .T. 	// Para criar o header do arquivo Contra Prova
	Private cLoteEst 			// Numero do lote para lancamentos do estoque
	//Ŀ
	// Posiciona numero do Lote para Lancamentos do Estoque         
	//
	aRetSX5 := FWGetSX5 ('09','EST')
	cLoteEst:=IIF(aRetSX5 == NIL,"EST ",Trim(aRetSX5[1,4]))
	Private nTotal := 0 		// Total dos lancamentos contabeis
	Private cArquivo			// Nome do arquivo contra prova
EndIf

For nX := 1 To Len(aDados)
	If aDados[nX,1]
		nReg := aDados[nX,4]

		If (lWmsNew .And. IntWMS(SCP->CP_PRODUTO))
			If FindFunction('Wms185EstB')
				aWmsRet := Wms185EstB(nReg)
				nQtd     := aWmsRet[1]
				cProjPMS := aWmsRet[2]
				cTaskPMS := aWmsRet[3]
				aSize(aWmsRet, 0)
			EndIf
		Else
			dbSelectArea("SD3")
			dbGoTo(nReg)
			nQtd	 := SD3->D3_QUANT
			cProjPMS := SD3->D3_PROJPMS
			cTaskPMS := SD3->D3_TASKPMS
		EndIf

		lPrj	:=	!Empty(cProjPMS).And.!Empty(cTaskPMS)
		if lMT185EST
			lRet :=	ExecBlock('MT185EST',.F.,.F.,{aDados[nx],aItSCQ})
			If Valtype(lRet) == "L"  .And. !lRet
				Loop
			EndIf
		EndIf
		//Se for integrado ao WMS, no haver SD3 neste momento.
		If	lIntegDef .And. !(lWmsNew .And. IntWMS(SCP->CP_PRODUTO))
			AAdd(a241ISD3,nReg)
		EndIf

		Begin Transaction
			//Se for integrado ao WMS, no h necessidade em executar a240Estorn, j que o essa funo foi chamada no estorno do servio no WMS
			If (lWmsNew .And. IntWMS(SCP->CP_PRODUTO)) .Or. a240Estorn("SD3",nReg,4)

				nPos := aScan(aItSCQ,{ |x| x[5] == aDados[nX,5]})
				If nPos > 0

					//--> Deletar a pre-requisicao baixada
					SCQ->(dbGoTo(aItSCQ[nPos,5]))
					RecLock("SCQ",.F.)
					dbDelete()
					MsUnLock()
					dbGoto(Recno())

					//--> Atualizar o saldo da pre-requisicao
					SCQ->(dbGoTo(aItSCQ[Len(aItSCQ),5]))
					nQtDisp := SCQ->CQ_QTDISP
					If SCQ->(aItSCQ[Len(aItSCQ),5])<=SCQ->(LastRec()) .And. !(Eof().Or.Bof()) .And. Empty(SCQ->CQ_NUMREQ)
						RecLock("SCQ",.F.)
					Else
					//Ŀ
					// Criar uma pre-requisicao do saldo estornado     
					//
						//--> Montar a estrutura do registro
						aEval(dbStruct(), {|z, w| aAdd(aRegSCQ, FieldGet(w)) } )
						//--> Gravar registro da pre-requisicao
						RecLock("SCQ",.T.)
						aEval(aRegSCQ, {|z, w| FieldPut(w, aRegSCQ[w]) } )
						Replace SCQ->CQ_NUMREQ  With Space(Len(SCQ->CQ_NUMREQ)),;
						SCQ->CQ_QUANT   With 0	,;
						SCQ->CQ_QTDISP  With 0   ,;
						SCQ->CQ_QTSEGUM With 0
						aAdd(aItSCQ,{ SCQ->CQ_PRODUTO, SCQ->CQ_NUMREQ, (SCQ->CQ_QTDISP+nQtd), (SCQ->CQ_QUANT+nQtd), SCQ->(Recno())})
					EndIf
					Replace SCQ->CQ_QUANT   With SCQ->CQ_QUANT  + nQtd ,;
					SCQ->CQ_QTDISP  With SCQ->CQ_QTDISP + A185QtdNeg(nQtd,aItSCQ[nPos,6],aItSCQ[nPos,7]),;
					SCQ->CQ_QTSEGUM With IIf(A185SegUm(SCQ->CQ_PRODUTO)==1,ConvUM(SCQ->CQ_PRODUTO,SCQ->CQ_QUANT,0,2),IIf(SCP->CP_QUANT == 0,0,(SCP->CP_QTSEGUM/SCP->CP_QUANT)*SCQ->CQ_QUANT))
					MsUnLock()
					dbGoto(Recno())

					//--> Atualizar o Saldo das Solicitacoes ao Armazem
					If SB2->(dbSeek(xFilial("SB2")+SCP->CP_PRODUTO+SCP->CP_LOCAL))
						RecLock("SB2",.F.)
						Replace SB2->B2_QEMPSA With SB2->B2_QEMPSA + A185QtdNeg(nQtd,aItSCQ[nPos,6],aItSCQ[nPos,7])
						MsUnlock()
						dbGoto(Recno())
					EndIf

					//--> Atualizar o saldo da Qtde. Ja Entregue da Solic. Armaz.
					RecLock("SCP",.F.)
					Replace SCP->CP_QUJE With SCP->CP_QUJE - nQtd
					If SCP->CP_QUJE < SCP->CP_QUANT
						Replace SCP->CP_STATUS With " "
					EndIf
					MsUnLock()
					If IntePMS() .And. lPrj
						DbSelectArea('AF8')
						DbSetOrder(1)
					MsSeek(xFilial()+cProjPms)
					DbSelectArea('AFH')
					DbSetOrder(1)
					If MsSeek(xFilial()+cProjPms+AF8->AF8_REVISA+cTaskPms+SCP->CP_NUM+SCP->CP_ITEM)
						RecLock('AFH',.F.)
						AFH_QUJE	-=	nQtd
						MsUnLock()
					Endif
				Endif

				dbGoto(Recno())
				EndIf

				If (lWmsNew .And. IntWMS(SCP->CP_PRODUTO)) .And. FindFunction('Wms185EstC')
					If !Wms185EstC(DH1->DH1_IDDCF)
						lRet := .F.
						DisarmTransaction()
					EndIf
				EndIf

			Else
				lRet  := .F.
				lExit := .T.
			Endif
		End Transaction

		If lExit
			Exit
		EndIf
	EndIf
Next nX

//-- Estorno da baixa da pre-requisicao
If	lRet .And. lIntegDef
	//-- Atualiza array de recnos a serem processados na mensagem unica no MATA241
	MTA241SD3(a241ISD3)
	aRetInt := FwIntegDef( "MATA241",,,,"MATA241" )
	If Valtype(aRetInt) == "A"
		If Len(aRetInt) == 2
			If !aRetInt[ 01 ]
				IIf( InTransact(), disarmTransaction(), Nil )
				lRet := .F.
			Endif
		Endif
	EndIf
	MTA241SD3(a241ISD3,.T.)

EndIf

// Executa ponto de entrada apos o estorno
If ExistBlock('M185EST')
	ExecBlock('M185EST',.F.,.F.)
EndIf

Return lRet

/*


Ŀ
Funo     A185Bt??  Autor  Cesar Valadao          Data 23/02/2000
Ĵ
Descrio  Funcao Que Determina o Status das Pre-Requisicoes.         
           A185BtVd - Verde                                           
           A185BtAm - Amarelo                                         
           A185BtVe - Vermelho                                        
           A185BtAz - Azul                                            
           A185BtLa - Laranja                                         
Ĵ
Sintaxe    A185Bt??()                                                 
Ĵ
Retorno    .T. / Nenhum                                               
Ĵ
 Uso       MATA185                                                    
ٱ


/*/

Function A185BtVe()
Local lRet
If !Empty(SCP->CP_STATUS) .And. SCP->CP_PREREQU == "S" .And. (QtdComp(SCP->CP_QUANT) == QtdComp(SCP->CP_QUJE))
	lRet := .T.
EndIf
Return lRet

Function A185BtVd()
Local lRet
If Empty(SCP->CP_STATUS) .And. SCP->CP_PREREQU == "S" .And. QtdComp(SCP->CP_QUJE) == QtdComp(0)
	lRet := .T.
EndIf
Return lRet

Function A185BtAm()
Local lRet
If Empty(SCP->CP_STATUS) .And. Empty(SCP->CP_PREREQU)
	lRet := .T.
EndIf
Return lRet

Function A185BtAz()
Local lRet
If !Empty(SCP->CP_STATUS) .And. SCP->CP_PREREQU == "S" .And. (QtdComp(SCP->CP_QUANT) > QtdComp(SCP->CP_QUJE))
	lRet := .T.
EndIf
Return lRet

Function A185BtLa()
Local lRet
If Empty(SCP->CP_STATUS) .And. SCP->CP_PREREQU == "S" .And. QtdComp(SCP->CP_QUJE) > QtdComp(0)
	lRet := .T.
EndIf
Return lRet

Function A185BtMa()
Local lRet

//Carrega varivel static '__lSaOrdSep'
FnVlSaOs()

If __lSaOrdSep
	If Empty(SCP->CP_STATUS) .And. SCP->CP_PREREQU == "S" .And. QtdComp(SCP->CP_QUANT) > QtdComp(SCP->CP_QUJE) .And. !Empty(SCP->CP_ORDSEP)
		lRet := .T.
	EndIf
EndIf
Return lRet

/*

Ŀ
Funo    a106AtuCQ  Autor  Edson Maricate         Data  25.11.98 
Ĵ
Descrio  Atualiza o arquivo de Pre-requisicoes.                     
Ĵ
Sintaxe    A106AtuCQ(ExpN1,ExpN2,ExpC1,ExpL1)                         
Ĵ
Parametros ExpN1 = qtde.                                              
           ExpN2 = qtde.disponivel		                              
           ExpC1 = numero da pre-req.	                              
           ExpL1 = indica se atualiza SB2                             
Ĵ
Retorno    Nenhum                                                     
Ĵ
Uso        MATA106                                                    
ٱ


*/
Static Function a106AtuCQ(nQuant,nQtDisp,cItemPR,lAtuSB2)
Local lMta106   := ExistBlock("MT106CQ")
Local aDadosGer :={nil,nil,nil,nil}

If lAtuSB2==Nil
	lAtuSB2 := .T.
EndIf

RecLock("SCQ",.T.)
SCQ->CQ_FILIAL := xFilial("SCQ")
SCQ->CQ_NUM    := SCP->CP_NUM
SCQ->CQ_ITEM   := SCP->CP_ITEM
SCQ->CQ_PRODUTO:= SCP->CP_PRODUTO
SCQ->CQ_LOCAL  := SCP->CP_LOCAL
SCQ->CQ_UM     := SCP->CP_UM
SCQ->CQ_QUANT  := nQuant
SCQ->CQ_QTSEGUM:= IIf(A185SegUm(SCQ->CQ_PRODUTO)==1,ConvUM(SCP->CP_PRODUTO,nQuant,0,2),IIf(SCP->CP_QUANT == 0,0,(SCP->CP_QTSEGUM/SCP->CP_QUANT)*nQuant))
SCQ->CQ_SEGUM  := SCP->CP_SEGUM
SCQ->CQ_QTDISP := nQtDisp
SCQ->CQ_NUMSQ  := cItemPR
SCQ->CQ_DATPRF := SCP->CP_DATPRF
SCQ->CQ_DESCRI := SCP->CP_DESCRI
SCQ->CQ_CC     := SCP->CP_CC
SCQ->CQ_CONTA  := SCP->CP_CONTA
SCQ->CQ_ITEMCTA:= SCP->CP_ITEMCTA
MsUnlock()

If lMta106
	Execblock("MT106CQ",.F.,.F.,aDadosGer)	//-- Ponto de Entrada executado tambem na MaSAPreReq (Comxfun)
Endif

If lAtuSB2
	dbSelectArea("SB2")
	Reclock("SB2",.F.)
	If nQtDisp > 0
		SB2->B2_QEMPSA := B2_QEMPSA + nQtDisp
	EndIf
	MsUnlock()
EndIf
dbSelectArea("SCQ")
MsUnlock()
Return

/*

Ŀ
Funo    A185Legend Autor  Patricia A. Salomao    Data  18.09.00 
Ĵ
Descrio  Legenda                                                    
Ĵ
Parametos  Nenhum                                                     
Ĵ
Retorno    .T.		                                                  
Ĵ
Uso        Mata185                                                    
ٱ


*/
Function A185Legend()
Local aLegenda := {}     // Variavel para itens da Legenda
Local aMT185LEG := {}    // Variavel para o PE MT185LEG

//Carrega varivel static '__lSaOrdSep'
FnVlSaOs()

aAdd(aLegenda,{"DISABLE"		,STR0034})          //Pre-Requisicao Baixada
aAdd(aLegenda,{"ENABLE"		    ,STR0035})   		//Baixar Pre-Requisicao
aAdd(aLegenda,{"BR_AMARELO"	    ,STR0036})   		//Gerar Pre-Requisicao
aAdd(aLegenda,{"BR_AZUL"		,STR0064})   		//Pre-Requisicao Encerrada
aAdd(aLegenda,{"BR_LARANJA"	    ,STR0069})		    //Parcialmente Baixada

If __lSaOrdSep
	aAdd(aLegenda,{"BR_MARROM"	,STR0112})		//Ordem de Separao Gerada
EndIf


//Ŀ
// PE Utilizado para Manipular Legenda		   
//
If ExistBlock("MT185LEG")
	aMT185LEG := ExecBlock("MT185LEG",.F.,.F., {aLegenda} )
	If ( Valtype(aMT185LEG) == "A" )
		aLegenda := aClone( aMT185LEG )
	EndIf
EndIf

BrwLegenda(STR0005,STR0033,aLegenda) //Legenda

Return(.T.)


/*


Ŀ
Funo    A185Encer  Autor  Marcelo Iuspa          Data 01/02/2001
Ĵ
Descrio  Programa da Encerramento de Pre-Requisicoes.               
Ĵ
Sintaxe    A185Encer(ExpC1,ExpN1,ExpN2)                               
Ĵ
Parametros ExpC1 = Alias do arquivo                                   
           ExpN1 = Numero do registro                                 
           ExpN2 = Opcao selecionada                                  
Ĵ
Retorno    Nenhum                                                     
Ĵ
 Uso       MATA185                                                    
ٱ


/*/
Function A185Encer(cAlias,nReg,nOpc)
Local nQuantBaixa:= 0
Local nCQ_QUANT	 := 0
Local nQtdEnc    := 0
Local nEntregSC7 := 0
Local nOpca      := 1
Local nSC        := 2
Local nAE        := 2
Local aSC        := {}
Local aPed       := {}
Local aRecSCQ    := {}
Local oDlg
Local nX
Local oSize
Local oEnch
Local lRet 	   := .T.
Local cDocSC		:= ""
Local cDocAE		:= ""
Local cItAE		:= ""
Local aDocs		:= {}
Local cNumSA	:= ''
Local cItemSA	:= ''

PRIVATE aTELA[0][0], aGETS[0]

cCadastro := STR0038 //"Encerramento de Pre-requisicoes"

If SCP->CP_STATUS == "E"
	HELP("   ",1,"A185JAENCE")
	Return(.F.)
EndIf

//Carrega varivel static '__lSaOrdSep'
FnVlSaOs()

//Verifica se existe vinculo com SIGAACD, para no permitir atualizao dentro da rotina
If !l185Auto .And. __lSaOrdSep .And. !Empty(SCP->CP_ORDSEP)
	Help(NIL, NIL, "SIGAACD", NIL, STR0111, 2, 0, NIL, NIL, NIL, NIL, NIL, {""})	//"Solicitacao ao Armazem vinculada uma 'Ordem de Separacao', nao e possivel realizar o encerramento enquanto a SA estiver vinculada."
	Return .F.
EndIf

//Ŀ
// Verifica calendrio contbil                
//
If lRet
	lRet := CtbValiDt(Nil,dDataBase,,Nil ,Nil ,{"EST001"})
EndIf

If !lRet
	Return .F.
EndIf

dbSelectArea(cAlias)
SoftLock(cAlias)
PcoInilan("000057")
If !l185Auto
	//Ŀ
	// Calcula dimenses 
	//
	oSize := FwDefSize():New()
	oSize:AddObject( "TELA", 100, 100, .T., .T., .T. ) // Totalmente dimensionavel

	oSize:lProp := .T. // Proporcional
	oSize:aMargins := { 3, 3, 3, 3 } // Espaco ao lado dos objetos 0, entre eles 3

	oSize:Process() // Dispara os calculos

	DEFINE MSDIALOG oDlg TITLE cCadastro ;
	       				 FROM oSize:aWindSize[1],oSize:aWindSize[2] TO oSize:aWindSize[3],oSize:aWindSize[4] OF oMainWnd PIXEL

	oEnch:=MsMGet():New(cAlias, nReg, nOpc,,,,,oSize:aPosObj[1],,,,,,oDlg)
    oEnch:oBox:Align := CONTROL_ALIGN_ALLCLIENT

	ACTIVATE MSDIALOG oDlg ON INIT EnchoiceBar(oDlg,{|| nOpca := 2,oDlg:End()},{|| nOpca := 1,oDlg:End()})

	dbSelectArea(cAlias)
Else
	nOpcA:=2
Endif

If nOpca == 2
	Begin Transaction
		RecLock("SCP", .F.)
		SCP->CP_STATUS := "E"
		SCP->CP_PREREQU:= "S"
		MsUnlock()
		SC1->(dbSetOrder(1))
		SC7->(dbSetOrder(1))
		dbSelectArea("SCQ")
		dbSetOrder(1)
		dbSeek(xFilial()+SCP->CP_NUM+SCP->CP_ITEM)
		cNumSA	:= SCQ->CQ_NUM
		cItemSA	:= SCQ->CQ_ITEM

		While !Eof() .And. xFilial()+SCP->CP_NUM+SCP->CP_ITEM == CQ_FILIAL+CQ_NUM+CQ_ITEM
			If Empty(CQ_NUMREQ)
				If SCQ->CQ_QTDISP > 0
					nQuantBaixa:=SCQ->CQ_QTDISP
					PcoDetLan("000057","01","MATA185")
				EndIf
				nCQ_QUANT := SCQ->CQ_QUANT

				aAdd(aRecSCQ,SCQ->(Recno()))

				//Ŀ
				// Verifica se ha Solicitacao de Compras Pendente  
				//

				//Recupera a SC gerada pela Central de Compras
				aNumScDhn := COMPosDHN({2,{SCQ->CQ_FILIAL,SCQ->CQ_NUM,SCQ->CQ_ITEM,"1",'MATA106'}})
				If aNumSCDhn[1]
					If (aNumScDhn[2])->DHN_TIPO == "1" //Solicitao de Compra
						cDocSC	:= (aNumScDhn[2])->DHN_DOCDES
						cItSC	:= (aNumScDhn[2])->DHN_ITDES
					ElseIf (aNumScDhn[2])->DHN_TIPO == "3" //Autorizao de Entrega
						cDocAE	:= (aNumScDhn[2])->DHN_DOCDES
						cItAE	:= (aNumScDhn[2])->DHN_ITDES
					EndIf
					(aNumSCDhn[2])->(DbCloseArea())
				EndIf

				//If !Empty(SCQ->CQ_NUMSC)
				If !Empty(cDocSC)
					//If SC1->(dbSeek(xFilial("SC1")+SCQ->CQ_NUMSC+SCQ->CQ_ITSC))
					If SC1->(dbSeek(xFilial("SC1") + cDocSC + cItSC))
						//Ŀ
						// Para SC Pendente, Qtd Ja entregue igual a zero e  
						// nao podera ter cotacao amarrada.                  
						//
						If SC1->C1_QUJE==0 .And. Empty(SC1->C1_COTACAO)
							aAdd(aSC,{cDocSC,cItSC})
						EndIf
					EndIf
				//ElseIf !Empty(SCQ->CQ_NUMAE)
				ElseIf !Empty(cDocAE)
					If SC7->(dbSeek(xFilial("SC7") + cDocAE + cItAE))
						nEntregSC7:=SC7->C7_QUJE+SC7->C7_QTDACLA
						If nEntregSC7 <= 0
							aAdd(aPed,{cDocAE,cItAE,SC7->C7_NUMSC,SC7->C7_ITEMSC,nCQ_QUANT,nEntregSC7})
						EndIf
                    EndIf
				EndIF

			EndIf
			dbSkip()
		End

		If Len(aSC) > 0
			//"Existe uma SC Para Esta Pre-Requisicao." ### "Deleta-la" ### "Mante-la"
			If l185Auto
				nSC := aPerg[4]
			Else
				nSC := Aviso("SIGAEST", STR0028, {STR0030, STR0031})
			EndIf
			If nSC == 1
				SC1->(dbSetOrder(1))
				For nX := 1 To Len(aSC)
					If SC1->(dbSeek(xFilial("SC1")+aSC[nX,1]+aSC[nX,2]))
						nQtdEnc += SC1->C1_QUANT
						// Desvincula da SC e Muda Status Para "D"eletado.

						aadd(aDocs,;
								{	Nil						;	//aPequena[x,1] : Produto
									,Nil					;	//aPequena[x,2] : Quantidade total
									,xFilial("SCP",cFilAnt) ;	//aPequena[x,3] : Filial que ser gerada o documento
									,Nil					;	//aPequena[x,4] : Filial que ser feita entrega do produto
									,NIL					;	//aPequena[x,5] : Documento que ser gerado sendo 1=Solicitao de Compras e 2=Pedido de Compra
									,NIL					;	//aPequena[x,6] : Fornecedor do produto
									,NIL					;	//aPequena[x,7] : Loja do fornecedor do produto
									,NIL					;	//aPequena[x,8] : Condio de pagamento
									,Nil					; 	//aPequena[x,9] : Preo do Produto
									,Nil					; 	//aPequena[x,10] : Array de Rateios
									,SCP->CP_NUM			; 	//aPequena[x,11] : Cdigo Documento
									,SCP->CP_ITEM			}) 	//aPequena[x,12] : Item do Documento

						ComGeraDoc(aDocs,,,,,,,,,5)

						SCQ->( dbSetOrder(1) )
						SCQ->( dbSeek( FWxFilial( 'SCQ' ) + cNumSA + cItemSA ) )
						dbSelectArea("SCQ")
						RecLock("SCQ",.F.)
						SCQ->CQ_STATUSC := "D"	// Deletada
						MsUnlock()
					EndIf
				Next nX
			EndIf
		EndIf

		If Len(aPed) > 0
			//"Existe uma AE para esta Pre-Requisicao." ### "Deleta-la" ### "Mante-la"
			If l185Auto
				nAE := aPerg[4]
			Else
				nAE := Aviso("SIGAEST", STR0070, {STR0030, STR0031})
			EndIf
			If nAE == 1
				SC7->(dbSetOrder(1))
				For nX := 1 To Len(aPed)
					If SC7->(dbSeek(xFilial("SC7")+aPed[nX,1]+aPed[nX,2]))
						nQtdEnc += SC7->C7_QUANT

						// Desvincula do PC e Muda Status Para "D"eletado.

						aadd(aDocs,;
								{	Nil						;	//aPequena[x,1] : Produto
									,Nil					;	//aPequena[x,2] : Quantidade total
									,xFilial("SCP",cFilAnt) ;	//aPequena[x,3] : Filial que ser gerada o documento
									,Nil					;	//aPequena[x,4] : Filial que ser feita entrega do produto
									,NIL					;	//aPequena[x,5] : Documento que ser gerado sendo 1=Solicitao de Compras e 2=Pedido de Compra
									,NIL					;	//aPequena[x,6] : Fornecedor do produto
									,NIL					;	//aPequena[x,7] : Loja do fornecedor do produto
									,NIL					;	//aPequena[x,8] : Condio de pagamento
									,Nil					; 	//aPequena[x,9] : Preo do Produto
									,Nil					; 	//aPequena[x,10] : Array de Rateios
									,SCP->CP_NUM			; 	//aPequena[x,11] : Cdigo Documento
									,SCP->CP_ITEM			}) 	//aPequena[x,12] : Item do Documento

						ComGeraDoc(aDocs,,,,,,,,,5)

						SCQ->( dbSetOrder(1) )
						SCQ->( dbSeek( FWxFilial( 'SCQ' ) + cNumSA + cItemSA ) )
						dbSelectArea("SCQ")
						RecLock("SCQ",.F.)
						SCQ->CQ_STATUSC := "D"	// Deletada
						MsUnlock()

						// Volta saldo ate a autorizacao de entrega
						dbSelectArea("SC3")
						dbSetOrder(1)
						If dbSeek(xFilial("SC3")+aPed[nX,3]+aPed[nX,4])
							RecLock("SC3",.F.)
							Replace C3_QUJE With C3_QUJE - (aPed[nX,5]-aPed[nX,6])   // nCQ_Quant-nEntregSC7
							If C3_QUANT > C3_QUJE .And. C3_ENCER == "E"
								Replace C3_ENCER With " "
							Endif
							MsUnlock()
						EndIf
					EndIf
				Next nX
			EndIf
		EndIf

		For nX := 1 To Len(aRecSCQ)
			SCQ->(DbGoTo(aRecSCQ[nX]))
			RecLock("SCQ",.F.,.T.)
			dbDelete()
			MsUnlock()
		Next nX

		dbSelectArea("SB2")
		dbSetOrder(1)
		If dbSeek(xFilial("SB2") + SCP->CP_PRODUTO + SCP->CP_LOCAL)
			RecLock("SB2", .F.)
			SB2->B2_QEMPSA  -= Min(SB2->B2_QEMPSA,nQuantBaixa)
			MsUnlock()
		Endif
		If SuperGetMv('MV_GSAPMAT',.F.,.F.) .AND. FindFunction("AT890CANSA")
			AT890CANSA(SCP->CP_NUM,SCP->CP_QUANT,SCQ->CQ_QUANT) 
		Endif
	End Transaction

	dbSelectArea(cAlias)
	//Ŀ
	// Ponto de Entrada MA185ENC                       
	//
	If ExistBlock("MA185ENC")
		ExecBlock("MA185ENC",.F.,.F.)
	EndIf
EndIf
PcoFinLan("000057")
dbSelectArea(cAlias)
Return

/*

Ŀ
Funo     A185Tipo  Autor  Larson Zordan          Data  22.07.02 
Ĵ
Descrio  Seleciona o Tipo de Baixa das Pre-Requisicoes              
Ĵ
Sintaxe    A185Tipo(ExpC1,ExpN1,ExpN2)                                
Ĵ
Parametros ExpC1 = Alias do arquivo                                   
           ExpN1 = Numero do registro                                 
           ExpN2 = Opcao selecionada                                  
Ĵ
Retorno    .T. 						                                  
Ĵ
Uso        MatA185                                                    
ٱ


*/
Function A185Tipo(cAlias,nReg,nOpc)
Pergunte("MTA185",.T.)
Return .T.

/*/

Ŀ
Funo    A185Automa Autor  Larson Zordan          Data 22.07.2002
Ĵ
Descrio  Programa de Baixa Total das Pre-requisicoes.               
Ĵ
Sintaxe    A185Automa(ExpC1,ExpN1,ExpN2)                              
Ĵ
Parametros ExpC1 = Alias do arquivo                                   
           ExpN1 = Numero do registro                                 
           ExpN2 = Opcao selecionada                                  
Ĵ
Retorno    .T. 						                                  
Ĵ
 Uso       MATA185                                                    
ٱ


/*/
Function A185Automa(cAlias,nReg,nOpc)
Local oRetCq   := Array(2)
Local aAreaAnt := GetArea()
Local aCols    := {}
Local aObjects := {}
Local aPosObj  := {}
Local aSize    := MsAdvSize()
Local aInfo    := {aSize[1],aSize[2],aSize[3],aSize[4],3,3}
Local cVarQ    := ""
Local cNumSA   := ""
Local cPict    := PesqPictQt('D3_QUANT')
Local lPreRequ := .F.
Local lQual    := .F.
Local lStatus  := .F.
Local lGerar   := .F.
Local lRet	   := .T.
Local nQtRes   := 0
Local nQtSal   := 0
Local nQtTotal := 0
Local nQtdSegUm:= 0
Local nRegist  := SCP->(Recno())
Local oNo 	   := LoadBitmap( GetResources(), "LBNO"  )
Local oOk 	   := LoadBitmap( GetResources(), "LBTIK" )
Local lM185MOD2:= ExistBlock("M185MOD2")
Local uRet     := Nil
Local nX       := 0
Local aNumPrj  := {}

Local oDlg, oLbx, oChk, oQatu
Local oQtRes, oQtSal, oQtTotal
Local lMT185BX := .F.
Local bBlock   := Nil
Local nNovaQtd := 0
Local nj       := 0 

Private aRatAFH:= {}
Private aRetCQ := {}
Private nQAtu  := 0

Pergunte("MTA185",.F.)

dbSelectArea("SCP")
dbSetOrder(1)
cNumSA  := SCP->CP_NUM
cItemSA := SCP->CP_ITEM 
If dbSeek(xFilial()+cNumSA)
	lMT185BX := ExistBlock("MT185BX")
	If l185Auto 
		bBlock := {||cItemSA == SCP->CP_ITEM}
	else
		bBlock := {||.T.}	
	EndIf 
	While !Eof() .And. xFilial()+cNumSA == CP_FILIAL+CP_NUM .And. Eval(bBlock) 
		If !SoftLock("SCP")
			Return .F.
		EndIf
		SB2->(dbSetOrder(1))
		If SB2->(dbSeek(xFilial("SB2")+SCP->CP_PRODUTO+SCP->CP_LOCAL))
			//Ŀ
			// ca100RetCQ() ----------->                   
			// [1] -  Saldo do Item                        
			// [2] -  Quantidade diponivel ja reservada    
			// [3] -  Quantidade em Processo de Compra     
			// [4] -  Situacao Atual                       
			// [5] -  Numero da Solicitacao de Compras     
			// [6] -  Numero de Requisicao                 
			// [7] -  Quantidade ja Entregue               
			//
			aRetCQ := ca100RetCQ(SCP->CP_NUM,SCP->CP_ITEM)
		Else
			Help(" ",1,"REGNOIS")
			Return .F.
		EndIf
		If SCP->CP_STATUS == "E"
			lStatus := .T.
			dbSkip()
			Loop
		EndIf

		If Empty(SCP->CP_PREREQU)
			lPreRequ := .T.
			dbSkip()
			Loop
		EndIf

		//Ŀ
		// P.E. utilizado para customizar o aCols da baixa da pre-requisicao 
		//
		If lMT185BX
			uRet := ExecBlock("MT185BX",.F.,.F.,{aRetCQ[2],SCP->CP_PRODUTO,SCP->CP_NUM,SCP->CP_ITEM})
			If Valtype(uRet) == "A" .And. Len(uRet) > 0
				For nX :=1 To Len(uRet)
					aAdd(aCols,uRet[nX])
				Next nX
			EndIf
		Else
			//-- Tratamento para Segunda Unidade de Medida
			nQtdSegUm := IIf(A185SegUm(SCP->CP_PRODUTO)==1,ConvUM(SCP->CP_PRODUTO,aRetCQ[2],0,2),IIf(SCP->CP_QUANT == 0,0,(SCP->CP_QTSEGUM/SCP->CP_QUANT)*aRetCQ[2]))

			aAdd(aCols,{	.F.			,;									// Marca de selecao
							CP_NUM		,; 									// Numero da SA
							CP_ITEM		,;									// Item da SA
							CP_PRODUTO	,;									// Produto
							CP_DESCRI	,;									// Descricao do Produto
							CP_LOCAL	,;									// Armazem
							CP_UM		,;									// UM
							Transform(aRetCQ[2],PesqPictQt('D3_QUANT')),;	// Qtd. a Requisitar (Formato Caracter)
							aRetCQ[2]	,;									// Qtd. a Requisitar
							CP_CC		,;									// Centro de Custo
							CP_SEGUM	,;									// 2a.UM
							nQtdSegUm	,;									// Qtd. 2a.UM
							CP_OP		,;									// Ordem de Producao
							CP_CONTA	,;									// Conta Contabil
							CP_ITEMCTA	,;									// Item Contabil
							CP_CLVL		,;									// Classe Valor
							CriaVar('AFH_PROJET',.F.),; 				 	// Projeto
							CP_NUMOS 	,;									// Nr. da OS
							CriaVar('AFH_TAREFA',.F.),;				 	// Tarefa
							"SCP"	,;										// Alias Walk-Thru
							SCP->(RecNo()) ,;								// Recno Walk-Thru
							CP_NRBPIMS })								// Numero Boletim PIMS

			// Gravacao do PROJETO + TAREFA, caso exista amarrado a SA
			If IntePMS()
				aNumPrj := M185RetPrj(SCP->CP_NUM,SCP->CP_ITEM)
				If Len(aNumPrj) > 0
					aCols[Len(aCols)][17] := aNumPrj[1] // Projeto
					aCols[Len(aCols)][19] := aNumPrj[2] // Tarefa
				EndIf
			EndIf
		EndIf
		dbSkip()
	EndDo
Else
	Help(" ",1,"REGNOIS")
	lRet := .F.
EndIf

If lRet .And. Len(aCols) == 0 .And. lStatus
	If Altera //IF utilizado para nao exibir mensagem quando baixada a pre-requisicao
		Help(" ",1,"A185BX")
	EndIf
	lRet := .F.
EndIf
If lRet .And. Len(aCols) == 0 .And. lPreRequ
	If Altera //IF utilizado para nao exibir mensagem quando baixada a pre-requisicao
		Help(" ",1,"A185PRE")
	EndIf
	lRet := .F.
EndIf

If lRet .And. Len(aCols) == 0
	lRet := .F.
EndIf

If lRet
	dbSelectArea("SCP")
	dbGoTo(nRegist)
	SB2->(dbSetOrder(1))
	If SB2->(dbSeek(xFilial("SB2")+SCP->CP_PRODUTO+SCP->CP_LOCAL))
		//Ŀ
		// ca100RetCQ() ----------->                   
		// [1] -  Saldo do Item                        
		// [2] -  Quantidade diponivel ja reservada    
		// [3] -  Quantidade em Processo de Compra     
		// [4] -  Situacao Atual                       
		// [5] -  Numero da Solicitacao de Compras     
		// [6] -  Numero de Requisicao                 
		// [7] -  Quantidade ja Entregue               
		//
		aRetCQ := ca100RetCQ(SCP->CP_NUM,SCP->CP_ITEM)
		If l185Auto
			nQAtu := SB2->B2_QATU
			nQtRes:= SB2->B2_RESERVA+SB2->B2_QEMP+SB2->B2_QEMPSA+SB2->B2_QACLASS-If(mv_par03==1.And.!Empty(SCP->CP_OP),SCP->CP_QUANT,0)
			nQtSal:= nQAtu - nQtRes
		EndIf 
	EndIf

If !l185Auto

	AADD(aObjects,{100,050,.T.,.F.,.F.})
	AADD(aObjects,{100,100,.T.,.T.,.F.})
	AADD(aObjects,{100,020,.T.,.F.,.F.})
	aPosObj:=MsObjSize(aInfo,aObjects)

	//Ŀ
	// Calcula dimenses 
	//
	oSize := FwDefSize():New( .F. )

	oSize:AddObject( "CIMA" , 100, 80, .T., .F., .T. ) // Nao dimensiona Y
	oSize:AddObject( "BAIXO", 100, 60, .T., .T., .T. ) // Totalmente dimensionavel

	oSize:lProp := .T. // Proporcional
	oSize:aMargins := { 3, 3, 3, 3 } // Espaco ao lado dos objetos 0, entre eles 3

	oSize:Process() // Dispara os calculos

	Define MsDialog oDlg Title OemToAnsi(STR0067) Of oMainWnd Pixel From aSize[7],0 To aSize[6],aSize[5] //"Baixa da Pre-Requisicao"

	//Ŀ
	// Adiciona Panel 
	//

	oPanel1:= tPanel():New(000,000,,oDlg,,,,,,30,oSize:aPosObj[1,3])
	oPanel2:= tPanel():New(000,000,,oDlg,,,,,,70,oSize:aPosObj[2,3])

	oPanel1:Align := CONTROL_ALIGN_TOP
	oPanel2:Align := CONTROL_ALIGN_ALLCLIENT

	@ 2,aPosObj[1,2] To aPosObj[1,3]+11,aPosObj[1,4] Label OemToAnsi(STR0010) Of oPanel1 Pixel	//"Resumo do Estoque"

	@ 10, aPosObj[1,2]+  5 Say OemToAnsi(STR0011) Of oPanel1 Pixel 	//"Quantidade Atual"
	@ 25, aPosObj[1,2]+  5 Say OemToAnsi(STR0012) Of oPanel1 Pixel 	//"- Reservas PV/OP"
	@ 40, aPosObj[1,2]+  5 Say OemToAnsi(STR0013) Of oPanel1 Pixel 	//"= Qtd. Disponvel"

	@ 10, aPosObj[1,2]+150 Say OemToAnsi(STR0017) Of oPanel1 Pixel 	//"Saldo da Pre-Requisicao "
	@ 25, aPosObj[1,2]+150 Say OemToAnsi(STR0018) Of oPanel1 Pixel 	//"Quantidade disp. para entrega"
	@ 40, aPosObj[1,2]+150 Say OemToAnsi(STR0019) Of oPanel1 Pixel 	//"Quantidade em processo de compra"

	@ 10, aPosObj[1,2]+ 75 MsGet oQAtu     Var Transform(nQAtu    ,cPict) Size 50,8 Of oPanel1 Pixel When .F.
	@ 25, aPosObj[1,2]+ 75 MsGet oQtRes    Var Transform(nQtRes   ,cPict) Size 50,8 Of oPanel1 Pixel When .F.
	@ 40, aPosObj[1,2]+ 75 MsGet oQtSal    Var Transform(nQtSal   ,cPict) Size 50,8 Of oPanel1 Pixel When .F.
	@ 10, aPosObj[1,2]+245 MsGet oRetCQ[1] Var Transform(aRetCQ[1],cPict) Size 50,8 Of oPanel1 Pixel When .F.
	@ 25, aPosObj[1,2]+245 MsGet oRetCQ[2] Var Transform(aRetCQ[2],cPict) Size 50,8 Of oPanel1 Pixel When .F.
	@ 40, aPosObj[1,2]+245 MsGet oQtTotal  Var Transform(nQtTotal ,cPict) Size 50,8 Of oPanel1 Pixel When .F.

	@ 55,aPosObj[1,2]+3 CheckBox oChk Var lQual PROMPT OemToAnsi(STR0046) Size 95,09 Of oPanel1 Pixel On CLICK ( AEval(aCols , {|z| z[1] := If(z[1]==.T.,.F.,If(z[9]>0,.T.,.F.))}), oLbx:Refresh(.F.) ) //"Selecionar Todos os Itens"

	@ aPosObj[2,1]+12,aPosObj[2,2] ListBox oLbx Var cVarQ Fields HEADER "",STR0014,STR0043,STR0015,STR0016,STR0044,STR0045,STR0020,STR0047 ;
		Size aPosObj[2,4]-3,aPosObj[2,3]-70 Of oDlg Pixel ;
		On DBLCLICK (aCols:=A185Troca(oLbx:nAt,aCols),oLbx:Refresh()) ;
		On Change (A185MudaVlr(oDlg,cNumSA,aCols[oLbx:nAt,3],aCols[oLbx:nAt,4],aCols[oLbx:nAt,6],aCols[oLbx:nAt,9],@aRetCQ,@nQAtu,@nQtRes,@nQtSal,aPosObj,.T.,oQAtu,oQtRes,oQtSal,oRetCQ,oQtTotal,@nQtTotal),oDlg:Refresh())

	oLbx:SetArray(aCols)
	oLbx:bLine := { || {If(aCols[oLbx:nAt,1],oOk,oNo),aCols[oLbx:nAt,2],aCols[oLbx:nAt,3],aCols[oLbx:nAt,4],aCols[oLbx:nAt,5],aCols[oLbx:nAt,6],aCols[oLbx:nAt,7],aCols[oLbx:nAt,8],aCols[oLbx:nAt,10]}}


	If IntePMS()
		@ aPosObj[3,3]-17, aPosObj[3,4]-160 BUTTON STR0065 SIZE 30 ,14   FONT oDlg:oFont ; //"Projetos"
			MESSAGE STR0066 ;//"Gerenciamento de projetos"
			ACTION {|| If(aCols[oLbx:nAt,1],PmsDlgSAB(cNumSA,aCols[oLbx:nAt,3],aCols[oLbx:nAt,9]),Nil)}  OF oDlg PIXEL

		SetKey(VK_F10,{|| If(aCols[oLbx:nAt,1],PmsDlgSAB(cNumSA,aCols[oLbx:nAt,3],(aCols[oLbx:nAt,9])),Nil)})
	Endif
	Define SButton From aPosObj[3,3]-17, aPosObj[3,4]-120 Type 11 Enable Of oDlg Action A185EdtQtd(oLbx,aCols)
	Define SButton From aPosObj[3,3]-17, aPosObj[3,4]- 85 Type  1 Enable Of oDlg Action (lGerar:=.T.,oDlg:End())
	Define SButton From aPosObj[3,3]-17, aPosObj[3,4]- 50 Type  2 Enable Of oDlg Action (oDlg:End())

	Activate MsDialog oDlg Center

else
    For nJ:=1 to len(aAutoSCP)
		If Upper(AllTrim(aAutoSCP[nJ,1])) == "CP_QUANT"
			nNovaQtd := aAutoSCP[nJ,2]
		EndIf
	Next
	
	A185EdtQtd(Nil,aCols,1,nNovaQtd,@lGerar)
	If lGerar
		A185MudaVlr(NIL,cNumSA,SCP->CP_ITEM,SCP->CP_PRODUTO,SCP->CP_LOCAL,SCP->CP_QUANT,@aRetCQ,@nQAtu,,,,.F.,.F.)
	EndIf 
EndIf

	If IntePms()		// Se usa PMS integrado com o ERP
		SetKey(VK_F10,Nil)
	EndIf

	//Ŀ
	// P.E. utilizado para validar a baixa da Pre-Requisicao        
	//
	If lM185MOD2 .And. lGerar
		lGerar := ExecBlock("M185MOD2",.F.,.F.,aCols)
	Endif

	If !( lGerar )
		lRet := .F.
	Else
		Processa( {|lEnd| lRet := A185GeraAut(cNumSA,aCols),@lEnd},STR0052,STR0053,.F.)
	EndIf

EndIf

//-- Libera os registros bloqueado pelo SoftLock
MsUnlockAll()

RestArea(aAreaAnt)
Return lRet

/*/

Ŀ
Funo    A185Troca  Autor  Larson Zordan          Data 22.07.2002
Ĵ
Descrio  Troca a marca de selecao                                   
Ĵ
Sintaxe    A185Troca(ExpN1,ExpA1)                                     
Ĵ
Parametros ExpN1 = Posicao da marca no array                          
           ExpA1 = Array com os dados                                 
Ĵ
Retorno    ExpA1 = Array com os dados                                 
Ĵ
 Uso       MATA185                                                    
ٱ


/*/
Static Function A185Troca(nIt,aArray)

//Marcar item selecionado
If !aArray[nIt,1]
	If A185QtRequ(aArray[nIt,9],aRetCQ[2],aRetCQ[1],nQAtu)
		aArray[nIt,1] := !aArray[nIt,1]
	EndIf
Else
	//Desmarcar item selecionado
	aArray[nIt,1] := !aArray[nIt,1]
EndIf
Return( aArray )

/*/

Ŀ
Funo    A185MudaVl Autor  Larson Zordan          Data 22.07.2002
Ĵ
Descrio  Atualiza os valores do Resumo do Estoque                   
Ĵ
Sintaxe    A185MudaVlr(ExpO1,ExpC1,ExpC2,ExpC3,ExpC4,ExpN1,ExpA1,     
                       ExpN2,ExpN3,ExpN4,ExpA2,ExpL1)                 
Ĵ
Parametros ExpO1 = Objeto da MsDialog                                 
           ExpC1 = Numero da SA                                       
           ExpC2 = Item da SA                                         
           ExpC3 = Produto                                            
           ExpC4 = Armazem                                            
           ExpN1 = Qtd. a Requisitar                                  
           ExpA1 = Array com valores das Pre-Requisicao               
           ExpN2 = Saldo Atual                                        
           ExpN3 = Reserva PV/OP                                      
           ExpN4 = Qtd. Disponivel                                    
           ExpA2 = Array das posicoes na Tela                         
           ExpL1 = Flag indicando se deve atualizar tela              
Ĵ
Retorno    Nenhum                                                     
Ĵ
 Uso       MATA185                                                    
ٱ


/*/
Static Function A185MudaVlr(oDlg,cNumSA,cItSA,cProduto,cLocal,nQtReq,aRetCQ,nQAtu,nQtRes,nQtSal,aPosObj,lTela,oQAtu,oQtRes,oQtSal,oRetCQ,oQtTotal,nQtTotal)

DEFAULT nQtReq   := 0
DEFAULT nQAtu    := 0
DEFAULT nQtRes   := 0
DEFAULT nQtSal   := 0
DEFAULT nQtTotal := 0
DEFAULT lTela    := .T.

dbSelectArea("SCP")
dbSeek(xFilial()+cNumSA+cItSA)
If SB2->(dbSeek(xFilial("SB2")+cProduto+cLocal))
	//Ŀ
	// ca100RetCQ() ----------->                   
	// [1] -  Saldo do Item                        
	// [2] -  Quantidade diponivel ja reservada    
	// [3] -  Quantidade em Processo de Compra     
	// [4] -  Situacao Atual                       
	// [5] -  Numero da Solicitacao de Compras     
	// [6] -  Numero de Requisicao                 
	// [7] -  Quantidade ja Entregue               
	//
	aRetCQ := ca100RetCQ(cNumSA,cItSA)
	nQAtu := SB2->B2_QATU
	nQtRes:= SB2->B2_RESERVA+SB2->B2_QEMP+SB2->B2_QEMPSA+SB2->B2_QACLASS-If(mv_par03==1.And.!Empty(SCP->CP_OP),SCP->CP_QUANT,0)
	nQtSal:= nQAtu - nQtRes
EndIf

nQtTotal := If( (mv_par02==2), A185QtProc(cProduto), aRetCQ[3] )

If lTela
	oQatu:Refresh()
	oQtRes:Refresh()
	oQtSal:Refresh()
	oRetCq[1]:Refresh()
	oRetCq[2]:Refresh()
	oQtTotal:Refresh()
EndIf

Return

/*/

Ŀ
Funo    A185EdtQtd Autor  Larson Zordan          Data 22.07.2002
Ĵ
Descrio  Editar o campo Quantidade a Requisitar                     
Ĵ
Sintaxe    A185EdtQtd(ExpO1,ExpA1)                                    
Ĵ
Parametros ExpO1 = Objeto do ListBox                                  
           ExpA1 = Array com os dados                                 
Ĵ
Retorno    ExpA1 = Array com os dados                                 
Ĵ
 Uso       MATA185                                                    
ٱ


/*/
Static Function A185EdtQtd( oLbx,aCols,nLinha,nNovaQtd,lRet)
Local nVlr1      := 0
Local nVlr2      := 0
Local cProd      := 0
Local cLocal     := 0
Local nQtdTot    := 0
Local nX 	     := 0
Local nLinAt     := 0 

DEFAULT nNovaQtd := 0 
DEFAULT nLinha   := 1
DEFAULT lRet     := .F.

If oLbx == Nil
	nLinAt := nLinha
else
	nLinAt := oLbx:nAt	
EndIf

nVlr1  := aCols[nLinAt,8]
nVlr2  := aCols[nLinAt,9]
cProd  := aCols[nLinAt,4]
cLocal := aCols[nLinAt,6] 

aCols[nLinAt,8] := aCols[nLinAt,9]

If oLbx != Nil
	lEditCell( aCols, oLbx , PesqPictQt('D3_QUANT'), 8 )
	oLbx:SetFocus()
else
	aCols[nLinAt,8] := nNovaQtd
EndIf 

aCols[nLinAt,9] := aCols[nLinAt,8]
aCols[nLinAt,8] := Transform(aCols[nLinAt,8],PesqPictQt('D3_QUANT'))

For nX := 1 to Len(aCols)
	If aCols[nX,1] .And. cProd == aCols[nX,4] .And. cLocal == aCols[nX,6]
		nQtdTot := nQtdTot + Val(aCols[nX,8])
	EndIf
Next nX
lRet := A185QtRequ(aCols[nLinAt,9],aRetCQ[2],aRetCQ[1],nQAtu,(nQtdTot-Val(aCols[nLinAt,8])),,,,@aCols)
If !lRet 
	aCols[nLinAt,8] := nVlr1
	aCols[nLinAt,9] := nVlr2
Else
	//Marca o item para baixa da pre-requisicao
	aCols[nLinAt,01] := .T.
	aCols[nLinAt,12] :=  IIf(A185SegUm(SCP->CP_PRODUTO)==1,ConvUM(SCP->CP_PRODUTO,aCols[nLinAt,9],0,2),IIf(SCP->CP_QUANT == 0,0,(SCP->CP_QTSEGUM/SCP->CP_QUANT)*aCols[nLinAt,9]))
EndIf
Return( aCols )

/*/

Ŀ
Funo    A185GeraAu Autor  Larson Zordan          Data 23.07.2002
Ĵ
Descrio  Gera as requisicoes usando o Movimentos Modelo 2           
Ĵ
Sintaxe    A185GeraAut(ExpC1,ExpA1)			                          
Ĵ
Parametros ExpC1 = Numero da SA                                       
           ExpA1 = Array com os dados                                 
Ĵ
Retorno    .T. / .F.                                                  
Ĵ
 Uso       MATA185                                                    
ٱ


/*/
Static Function A185GeraAut(cNumSa,aDados,lEnd)
Local lRet 		:= .T.
Local aCopia    := {}
Local lMov      := .F.
Local lValZero  := .F.
Local nX		:= 1
Local cProjeto	:= ""
Local cTarefa	:= ""
Local cDocumento:= ""
Local lChangeDoc:= .F.
Local aRetPE    := {}
Local lMT185Gera:= ExistBlock("MT185GERA")
Local lMT185Dad := ExistBlock("MT185DAD")
Local lCC
Local nZ
Local aDadosPrj := {}
Local aRetSX5   := {}

//Integracao PMSĿ
//Modifica o aDados para ficar aberto por projeto e gerar um registro no SD3
//por cada Solicitacao+item+tarefa                                          
//
If IntePMS().And. Type("aRatAFH")=="A" .And. Len(aRatAFH) > 0
	While nX <= Len(aDados).And.Len(aDados[nX]) >= 21		// Incluidos campos ref. Walk-Thru
		If aDados[nX,1]
			aDadosPrj	:=	PMSAFHDados(aRatAFH,aDados[nX,3],aDados[nX,9])
			aSize(aDados,Len(aDados)+(Len(aDadosPrj)-1))
			For nZ := 1 To Len(aDadosPrj)
				If aDadosPrj[nZ,3] > 0
					If nZ > 1
						aIns(aDados,nX+(nZ-1))
						aDados[nX+(nZ-1)]			:=	aClone(aDados[nX])
					EndIf
					aDados[nX+(nZ-1)]	[17]	:=	aDadosPrj[nZ][1]
					aDados[nX+(nZ-1)]	[19]	:=	aDadosPrj[nZ][2]
					aDados[nX+(nZ-1)]	[09]	:=	aDadosPrj[nZ][3]
				EndIf
			Next
			nX+= (nZ-1)
		Else
			nX++
		EndIf
	EndDo
EndIf

Private bCols     := {|x,y|aCols[x][y]}
Private cXFunc    := "A185Atu2SD3" 
Private a185Dados := aClone(aDados)
Private aCC       := {}
Private aAlter    := {}
Private lMT241GRV := ExistBlock("MT241GRV")
Private lLogMov   := GetMV("MV_IMPMOV")
//Ŀ
// Esta variavel indica se utiliza segunda unidade de medida.   
//
Private lUsaSegUm

//Ŀ
// Variavel utilizada na rotina de atualizacao da SCQ/SCP/SB2   
// disparada pelo MATA241 (controle de transacoes)              
//
Private aDadosCQ  := {}

//Ŀ
// Ponto de Entrada MT185DAD               
//

If lMT185Dad
	aRetPE:= ExecBlock("MT185DAD",.F.,.F.,aDados)
	If  ValType(aRetPE) == "A"
		aDados := aClone(aRetPE)
		a185Dados:= aClone(aRetPE)
	EndIf
EndIf

ProcRegua(Len(aDados),23,4)
For nX := 1 To Len(aDados)
	IncProc()
	If aDados[nX,1]
		//Ŀ
		// Ponto de Entrada MT185GERA              
		//
		If lMT185Gera
			ExecBlock("MT185GERA",.F.,.F.,aDados[nX])
		EndIf
		// Atualiza array aRetCQ
		A185MudaVlr(NIL,cNumSA,aDados[NX,3],aDados[nx,4],aDados[nx,6],aDados[nx,9],@aRetCQ,@nQAtu,,,,.F.)
		If Len(aDados[nX]) >= 21		// Incluidos campos ref. Walk-Thru
			cProjeto	:=	aDados[nX,17]
			cTarefa 	:=	aDados[nX,19]
		Else
			cProjeto	:=	""
			cTarefa		:=	""
		Endif
		If !A185QtRequ(aDados[nX,9],aRetCQ[2],aRetCQ[1],nQAtu,,.F.,cProjeto,cTarefa)
			lRet := .F.
			Exit
		EndIf
		nPos := aScan(aCC,{|x| x == aDados[nX,10]})
		If nPos == 0
			aAdd(aCC,aDados[nX,10])
		EndIf
		//Ŀ
		// Existem itens selecionados              
		//
		lMov := .T.
		//Ŀ
		// Verifica se ha itens zerados.           
		//
		lValZero := If(aDados[nX,9]<=0,.T.,lValZero)
	EndIf
Next nX

If !lMov
	Return(.F.)
EndIf

If lValZero
	Help(" ",1,"VALZERADO")
	Return(.F.)
EndIf

//Ŀ
// Verifica se ha mais de um centro de custo. 
//
lCC := If(Len(aCC)>1,.T.,.F.)

//Ŀ
// Notifica o usuario sobre o uso de mais de  
//| um Centro de Custo na Pre-Requisicao.      |
//
If lCC
	If !MsgYesNo(	OemToAnsi(STR0048)+CHR(13)+; 			//"Esta Pre-Requisicao tem diversos Centros de Custos cadastrados."
					OemToAnsi(STR0049)+CHR(13)+; 			//"Portanto,  ao continuar a rotina,  voce devera digitar o Centro"
					OemToAnsi(STR0050)+CHR(13)+CHR(13)+;	//"de Custo adequado para os itens requisitados."
					OemToAnsi(STR0051))						//"Deseja continuar o processo de requisicao ?"
		Return(.F.)
	EndIf
EndIf


//Ŀ
// Verifica se o custo medio e' calculado On-Line.              
//
If cCusMed == "O"
	Private nHdlPrv 			// Endereco do arquivo de contra prova dos lanctos cont.
	Private lCriaHeader := .T.	// Para criar o header do arquivo Contra Prova
	Private cLoteEst 			// Numero do lote para lancamentos do estoque
	//Ŀ
	// Posiciona numero do Lote para Lancamentos do Estoque.        
	//
	aRetSX5 := FWGetSX5 ('09','EST')
	cLoteEst:=IIF(aRetSX5 == NIL,"EST ",Trim(aRetSX5[1,4]))
	PRIVATE nTotal := 0 		// Total dos lancamentos contabeis
	PRIVATE cArquivo			// Nome do arquivo contra prova
EndIf

//Ŀ
// Estas variaveis indicam para as funcoes de validacao qual    
// programa as esta' chamando.                                  
//
Private l241Auto := .F., l250Auto := .F.
//Ŀ
// Estas variaveis indicam para as funcoes de validacao qual    
// programa as esta' chamando.                                  
//
Private l240:=.F.,l250:=.F.,l241:=.T.,l242:=.F.,l261:=.F.,l185 :=.T.

//Ŀ
// Atualiza Pergunta MTA240						
//
A185AtuPer(1)

aCopia  := aClone(aRotina)
aRotina := {}
For nX := 1 To 5	// Walk_Thru
	aAdd(aRotina,{ "" , "        ", 0 , 6} )
Next

//Ŀ
// A funcao A241Inclui abrira a transacao e gravara as informacoes da tabela SD3.    
// Se estiver tudo certo, ela executara a funcao A185AtuSCQ que atualizara as demais 
// tabelas realizando corretamente o controle de transacao. Toda a operacao estara   
// em uma unica transacao aberta e finalizada pelo MATA241.                          
//
//Variavel private a ser usada pela A185AtuSCQ
aDadosCQ := aClone(aDados)
dbSelectArea("SD3")
dbSetOrder(1)
If lRet .Or. lMov
	If l185Auto
		lRet := A185MT241(@cDocumento,@lChangeDoc)
	Else
		lRet := ( A241Inclui("SD3",0,1,@cDocumento,@lChangeDoc) == 1 )
	EndIf 
	//Ŀ
	// Atualiza Pergunta MTA185						
	//
	A185AtuPer(2)
	aRotina := aClone(aCopia)

	If lChangeDoc
		Help("",1,"A240DOC",,cDocumento,4,30)  // No.Docto. foi alterado
	EndIf

EndIf

//Ŀ
// Ponto de Entrada no final do processo de baixa total 
// das pre-requisicoes, apos o controle de transacao.   
//
If ExistBlock("M185FGR")
   ExecBlock("M185FGR",.F.,.F.,{ lRet, aDados } )
EndIf

Return lRet

/*/

Ŀ
Funo    A185AtuSCQ Autor  Emerson Rony Oliveira  Data 25.06.2009  
Ĵ
Descrio  Grava as demais atualizacoes para a requisicao apos gerar o  
           SD3. Esta funcao sera executada pelo MATA241 e estara dentro 
           da mesma transacao que gerou o(s) registro(s) na SD3.        
Ĵ
Sintaxe    A185AtuSCQ(ExpC1, ExpC1)                                     
Ĵ
Parametros ExpC1 = Numero do documento gerado pelo MATA241 (A241Inclui) 
			   ExpC2 = Sequencia gerada em MATA241 (a241Grava)              
                                                                        
Ĵ
Retorno    NIL                                                          
Ĵ
 Uso       MATA185                                           ?           
ٱ


/*/
Function A185AtuSCQ( cDocSD3, aD3NumSeq )
Local lRet		:= .T.
Local aSD3Area	:= SD3->( GetArea() )
Local nX		:= 0
Local nQtDisp	:= 0
Local nQtRes 	:= 0
Local nRecno 	:= 0
Local nPosSD3	:= 0
Local nAjustaSC1:= 3

Local cSolic  	:= ''
Local cItSolic	:= ''
Local cNumAE  	:= ''
Local cItAE		:= ''
Local cDocSC	:= ''
Local cItSC		:= ''
Local cDocAE	:= ''
Local cAliasDHN	:= ''
Local cSCNum 	:= ''
Local cItemPR 	:= ''

Local aDocs		:= {}
Local aRetSA	:= {}
Local aNumScDhnA:= {}
Local aNumScDhnB:= {}

Local lSCAglut 	:= .F.
Local lM185GRV	:= ExistBlock( "M185GRV" )
Local lWmsNew   := SuperGetMV("MV_WMSNEW",.F.,.F.)
Local lWmsSD3   := Iif(Type('lExecWms')=='L', lExecWms, .F.)
Local aHeadBkp := {}
Local aColsBkp := {}

Default aD3NumSeq := {}

dbSelectArea( 'SD3' )
SD3->( dbSetOrder( 8 ) )

If Type("aDadosCQ") == "A" .And. Len(aDadosCQ) > 0
	If Len( aD3NumSeq ) == 0
		lRet := .F.
	Else
		ProcRegua(Len(aDadosCQ),23,4)
		For nX := 1 To Len(aDadosCQ)
			nQtDisp	:= 0
			nQtRes 	:= 0
			cSolic  := ''
			cItSolic:= ''
			cNumAE  := ''
			cItAE	:= ''
			IncProc()

			If aDadosCQ[nX,1]
				dbSelectArea("SCP")
				dbSeek(xFilial()+aDadosCQ[nX,2]+aDadosCQ[nX,3])

				nPosSD3 := Ascan( aD3NumSeq, { | x | AllTrim( x[ 5 ] ) == AllTrim( aDadosCQ[ nX ][ 02 ] ) .And. AllTrim( x[ 6 ] ) == AllTrim( aDadosCQ[ nX ][ 03 ] ) .And. AllTrim( x[ 3 ] ) == AllTrim( aDadosCQ[ nX ][ 04 ] ) .And. AllTrim( x[ 4 ] ) == AllTrim( aDadosCQ[ nX ][ 06 ] ) } )
				If nPosSD3 == 0
					lRet := .F.
					Exit
				ElseIf (!lWmsNew .Or. lWmsSD3 .Or. !IntWMS(aDadosCQ[nX,4]))
					SD3->( dbSeek( FWxFilial( 'SD3' ) + aD3NumSeq[ nPosSD3 ][ 01 ] + aD3NumSeq[ nPosSD3 ][ 02 ]  ) )
				EndIf

				aRetSA := ca100RetCQ(aDadosCQ[nX,2],aDadosCQ[nX,3])

				//Ŀ
				// ca100RetCQ() ----------->                   
				// [1] -  Saldo do Item                        
				// [2] -  Quantidade diponivel ja reservada    
				// [3] -  Quantidade em Processo de Compra     
				// [4] -  Situacao Atual                       
				// [5] -  Numero da Solicitacao de Compras     
				// [6] -  Numero de Requisicao                 
				// [7] -  Quantidade ja Entregue               
				//
				dbSelectArea("SCQ")
				dbSetOrder(1)
				dbSeek(xFilial()+SCP->CP_NUM+SCP->CP_ITEM)
				//Recupera a SC gerada pela Central de Compras
				aNumScDhnA := COMPosDHN({2,{SCQ->CQ_FILIAL,SCQ->CQ_NUM,SCQ->CQ_ITEM}})
				If aNumSCDhnA[1]
					If (aNumScDhnA[2])->DHN_TIPO == "1" //Solicitao de Compra
						cDocSC	:= (aNumScDhnA[2])->DHN_DOCDES
						cItSC	:= (aNumScDhnA[2])->DHN_ITDES
					ElseIf (aNumScDhnA[2])->DHN_TIPO == "3" //Autorizao de Entrega
						cDocAE	:= (aNumScDhnA[2])->DHN_DOCDES
						cItAE	:= (aNumScDhnA[2])->DHN_ITDES
					EndIf
					(aNumSCDhnA[2])->(DbCloseArea())
				EndIf
				dbSelectArea("SB2")
				dbSetOrder(1)
				dbSeek(xFilial()+SCP->CP_PRODUTO+SCP->CP_LOCAL)
				dbSelectArea("SCP")
				If Reclock("SCP",.F.)
					SCP->CP_QUJE := SCP->CP_QUJE + aDadosCQ[nX,9]
					If SCP->CP_QUJE >= SCP->CP_QUANT
						SCP->CP_STATUS := "E"
						INCLUI := .F.
					EndIf
					MsUnLock()
				EndIf

				If IntePMS() .And. !Empty(aDadosCQ[nX,17]).And.!Empty(aDadosCQ[nX,19])
					DbSelectArea('AF8')
					DbSetOrder(1)
					MsSeek(xFilial()+aDadosCQ[nX,17])
					DbSelectArea('AFH')
					DbSetOrder(1)
					If MsSeek(xFilial()+aDadosCQ[nX,17]+AF8->AF8_REVISA+aDadosCQ[nX,19]+SCP->CP_NUM+SCP->CP_ITEM)
						RecLock('AFH',.F.)
						AFH_QUJE	+=	aDadosCQ[nX,9]
						MsUnLock()
					Endif
				Endif

				dbSelectArea("SCQ")
				While !Eof() .And. CQ_FILIAL+CQ_NUM+CQ_ITEM == xFilial()+SCP->CP_NUM+SCP->CP_ITEM
					If aDadosCQ[nX,9] > 0 .And. Empty(SCQ->CQ_NUMREQ)

						If !(Empty(cDocSC))
							If aDadosCQ[nX,9] > aRetSA[2]
								RecLock("SCQ",.F.)
								SCQ->CQ_QTDISP := SCQ->CQ_QTDISP + aDadosCQ[nX,9] - aRetSA[2]
								MsUnlock()
								dbSelectArea("SC1")
								DbSetOrder(1)
								If dbSeek(xFilial() + cDocSC + cItSC)
									If Empty(C1_PEDIDO) .And. Empty(C1_COTACAO)
										//Ŀ
										// Verifica se Gerou SC Aglutinada. 
										//
										nRecno := SCQ->(Recno())
										lSCAglut := .F.
										aNumScDhnB := COMPosDHN({3,{'1',xFilial("DHN"),SC1->C1_NUM,SC1->C1_ITEM}})
										If aNumScDhnB[1]
											cAliasDHN := aNumScDhnB[2]
											If !Empty(cAliasDHN)
												cSCNum := SCQ->CQ_NUM
												While !((cAliasDHN)->(EOF())) .And. (cAliasDHN)->DHN_TIPO == "1" .And. (cAliasDHN)->(DHN_FILDES+DHN_DOCDES+DHN_ITDES) == xFilial("SC1")+SC1->C1_NUM+SC1->C1_ITEM
													If SCQ->(DbSeek((cAliasDHN)->(DHN_FILORI + DHN_DOCORI + AllTrim(DHN_ITORI))))
														While !(SCQ->(EoF())) .And. SCQ->(CQ_FILIAL + CQ_NUM + AllTrim(CQ_ITEM)) == (cAliasDHN)->(DHN_FILORI + DHN_DOCORI + AllTrim(DHN_ITORI))
															If cSCNum != SCQ->CQ_NUM
																lSCAglut := .T.
																Exit
															EndIf
															SCQ->(dbSkip())
														EndDo
													EndIf
													(cAliasDHN)->(dbSkip())
												End
												(cAliasDHN)->(DbCloseArea())
											EndIf
										EndIf
										SCQ->(dbGoTo(nRecno))
										//dbSetOrder(1)
										// Se Gerou SC Aglutinada, Nao Posso Deletar!!!
										If lSCAglut
											// "Existe uma SC Para Esta Pre-Requisicao." ### "Ajusta-la" ### "Mante-la"
											nAjustaSC1 := Aviso("SIGAEST", STR0028, {STR0029, STR0031})
										Else
											// "Existe uma SC Para Esta Pre-Requisicao." ### "Ajusta-la" ### "Deleta-la" ### "Mante-la"
											nAjustaSC1 := Aviso("SIGAEST", STR0028, {STR0029, STR0030, STR0031})
										EndIf
									Else
										Aviso("SIGAEST", STR0032, {" Ok "})	// "Existe uma SC Em Processo de Compra. Nao Sera Alterada."
									EndIf
								EndIf
								dbSelectArea("SCQ")
							EndIf
							nQtRes  += SCQ->CQ_QUANT - aDadosCQ[nX,9]
							cSolic  := cDocSC
							cItSolic:= cItSC
						ElseIf !Empty(SCQ->CQ_NUMAE)
							nQtRes  += SCQ->CQ_QUANT - aDadosCQ[nX,9]
							cNumAE	:= cDocAE
							cItAE	:= cItAE
						Else
							nQtRes  += SCQ->CQ_QUANT - aDadosCQ[nX,9]
						EndIf
						RecLock("SCQ",.F.)
						SCQ->CQ_NUMREQ := aD3NumSeq[nPosSD3][02]
						If aDadosCQ[nX,9] - SCQ->CQ_QTDISP < 0
							nQtDisp+=SCQ->CQ_QTDISP-aDadosCQ[nX,9]
						EndIf
						MsUnlock()
						cItemPR := SCQ->CQ_NUMSQ
						Exit
					EndIf
					dbSkip()
				EndDo
				If nQtRes > 0 .Or. nQtDisp > 0
					If nQtRes > 0
						a106AtuCQ(nQtRes,nQtDisp,cItemPR,.F.)
					Else
						a106AtuCQ(nQtDisp,nQtDisp,cItemPR,.F.)
					EndIf
				EndIf

				// Valida se o cabealho e os itens esto preenchidos
				If (Type("aHeader") == "A" .And. Type("aCols") == "A")
					// Faz um backup do estado de aCols e aHeader
					aHeadBkp := AClone(aHeader)
					aColsBkp := AClone(aCols)
					// Reinicia ambas as variveis para evitar conflito
					// com o preenchimento de FillGetDados() da SC1 no mata110
					aHeader := {}
					aCols := {}
				EndIf

				If nAjustaSC1 == 1 .Or. (!lSCAglut .And. nAjustaSC1 == 2)
					dbSelectArea("SC1")
					If !(Empty(cDocSC)) .And. dbSeek(xFilial() + cDocSC + cItSC)
						If SC1->C1_QUANT - aDadosCQ[nX,9] == 0
							nAjustaSC1 := 2	// Se a SC For Ficar Com Qtd Zero, Deleta-a.
						EndIf
						If nAjustaSC1 <> 2
							dbSelectArea("SB2")
							dbSetOrder(1)
							dbSeek(xFilial()+SCP->CP_PRODUTO+SCP->CP_LOCAL)
							If Reclock("SB2",.F.)
								SB2->B2_SALPEDI := B2_SALPEDI - If(nAjustaSC1==1, aDadosCQ[nX,9], SC1->C1_QUANT)
								MsUnLock()
							EndIf
							dbSelectArea("SC1")
						EndIf	
						If nAjustaSC1 == 1
							RecLock("SC1",.F.)
							SC1->C1_QUANT := C1_QUANT - aDadosCQ[nX,9]
							MsUnLock()
						Else
							//Ŀ
							// Desvincula da SC e Muda Status Para "D"eletado. 
							// Usado no MATR115.                               
							//

							//VERIFICAR COMO DELETAR DHN

							aadd(aDocs,;
										{	Nil						;	//aPequena[x,1] : Produto
											,Nil					;	//aPequena[x,2] : Quantidade total
											,xFilial("SCP",cFilAnt) ;	//aPequena[x,3] : Filial que ser gerada o documento
											,Nil					;	//aPequena[x,4] : Filial que ser feita entrega do produto
											,NIL					;	//aPequena[x,5] : Documento que ser gerado sendo 1=Solicitao de Compras e 2=Pedido de Compra
											,NIL					;	//aPequena[x,6] : Fornecedor do produto
											,NIL					;	//aPequena[x,7] : Loja do fornecedor do produto
											,NIL					;	//aPequena[x,8] : Condio de pagamento
											,Nil					; 	//aPequena[x,9] : Preo do Produto
											,Nil					; 	//aPequena[x,10] : Array de Rateios
											,SCP->CP_NUM			; 	//aPequena[x,11] : Cdigo Documento
											,SCP->CP_ITEM			}) 	//aPequena[x,12] : Item do Documento

							ComGeraDoc(aDocs,,,,,,,,,5)

							dbSelectArea("SCQ")
							RecLock("SCQ",.F.)
							SCQ->CQ_STATUSC := "D"	// Deletada
							MsUnlock()
							//Ŀ
							// Se Foi Excluida a SC, Encerra a Pre-Requisicao. 
							//
						EndIf
					EndIf
				EndIf

				// Restaura o aHeader e aCols retirado para tratamento dos campos de WalkThru
				aHeader := aHeadBkp
				aCols := aColsBkp

				//Integrao SIGAMDT
				MdtIntSCP( 1, aDadosCQ[nX, 2], aDadosCQ[nX, 3], aD3NumSeq[nPosSD3][02], aDadosCQ[nX, 4],;
						 SD3->D3_NUMSERI, SD3->D3_LOTECTL, SD3->D3_NUMLOTE, SD3->D3_LOCALIZ )

				If lM185GRV
					ExecBlock("M185GRV",.F.,.F.,{nx==Len(aDadosCQ)})
				EndIf
				SD3->(dbSkip())
			EndIf
		Next nX
	EndIf
EndIf

RestArea( aSD3Area )
Return lRet

/*

Ŀ
Funo    A185Atu2SD Autor  Larson Zordan          Data 23.07.2002
Ĵ
Descrio  Atualiza as variaveis de memoria para Inclusao no SD3.     
Ĵ
Parametros Nenhum                                                     
Ĵ
Retorno    Nenhum                                                     
Ĵ
Uso        MATA185                                                    
ٱ


*/
Function A185Atu2SD3(aColsX)
Local cSavAlias := Alias()
Local nX        := 0
Local i         := 0
Local z         := 0
Local nPosRec   := GDFieldPos("D3_REC_WT")
Local nPosAlias := GDFieldPos("D3_ALI_WT")
Local lM185Camp := ExistBlock("M185CAMP")
Local lWmsNew   := SuperGetMv("MV_WMSNEW",.F.,.F.)
Local cProdWms  := ""
Local cTrt      := ""
Local nTamOP    := TamSx3( 'D4_OP' )[ 1 ]
Local nTamCod   := TamSx3( 'D4_COD' )[ 1 ]
Local nTamLoc   := TamSx3( 'D4_LOCAL' )[ 1 ]
Local cFilSD4   := FWxFilial( 'SD4' )
Local aAreaSD4  := SD4->( GetArea() )
Local cCC as character
Local cX3_PROPRI as character
Local cX3_RELACAO as character

dbSelectArea( 'SD4' )
SD4->( dbSetOrder( 2 ) )

aCols := {}
For nX := 1 To Len(a185Dados)
	If a185Dados[nX,1]
		AADD(aCols,Array(Len(aHeader)+1))
		z ++
		dbSelectArea("SB1")
		dbSetOrder(1)
		dbSeek(xFilial()+a185Dados[nX,4])

		//Ŀ
		// Verifica se trabalha com segunda unidade de medida. 
		//
		lUsaSegUm := .T.
		cX3_USADO := GetSX3Cache("B1_SEGUM", "X3_USADO")
		If !X3USO(cX3_USADO)
			cX3_USADO := GetSX3Cache("B2_QTSEGUM", "X3_USADO")
			If !X3USO(cX3_USADO)
				lUsaSegUm := .F.
			EndIf
		EndIf

		For i:=1 to Len(aHeader)

			//Ŀ
			// Cria Linha do aCols.                               
			//
			cCampo:=Alltrim(aHeader[i,2])
			If nPosAlias <> i .And. nPosRec <> i
				If aHeader[i,8] == "C"
					aCols[z][i] := SPACE(aHeader[i,4])
				ElseIf aHeader[i,8] == "N"
					aCols[z][i] := 0
				ElseIf aHeader[i,8] == "D" .And. cCampo != "D3_DTVALID"
					aCols[z][i] := dDataBase
				ElseIf aHeader[i,8] == "D" .And. cCampo == "D3_DTVALID"
					aCols[z][i] := CriaVar("D3_DTVALID")
				ElseIf aHeader[i,8] == "M"
					aCols[z][i] := ""
				Else
					aCols[z][i] := Nil
				EndIf
				If aHeader[i,10] == "V"
					aCols[z][i] := CriaVar(cCampo)
				EndIf
			EndIf
			//Ŀ
			// Insere dados na Linha do aCols.                     
			//
			If cCampo $ "D3_COD"
				aCols[z,i] := a185Dados[nX,4]
				If lWmsNew .And. IntWMS(a185Dados[nX,4])
					cProdWms := a185Dados[nX,4]
				EndIf
			ElseIf cCampo $ "D3_UM"
				aCols[z,i] := a185Dados[nX,7]
			ElseIf cCampo $ "D3_QUANT"
				aCols[z,i] := a185Dados[nX,9]
			ElseIf cCampo $ "D3_SEGUM"
				aCols[z,i] := a185Dados[nX,11]
			ElseIf cCampo $ "D3_QTSEGUM"
				aCols[z,i] := a185Dados[nX,12]
			ElseIf cCampo $ "D3_LOCAL"
				aCols[z,i] := a185Dados[nX,6]
			ElseIf cCampo $ "D3_OP"
				aCols[z,i] := a185Dados[nX,13]
			ElseIf cCampo == "D3_CONTA"
				aCols[z,i] := a185Dados[nX,14]
			ElseIf cCampo $ "D3_DESCRI"
				aCols[z,i] := a185Dados[nX,5]
			ElseIf cCampo $ "D3_ITEMCTA"
				aCols[z,i] := a185Dados[nX,15]
			ElseIf cCampo $ "D3_CLVL"
				aCols[z,i] := a185Dados[nX,16]
			ElseIf cCampo $ "D3_PROJPMS"
				aCols[z,i] := a185Dados[nX,17]
			ElseIf cCampo $ "D3_TASKPMS" .And. Len(a185Dados[nX]) >= 21	// Incluidos campos ref. Walk-Thru
				aCols[z,i] := a185Dados[nX,19]
			ElseIf cCampo $ "D3_OSTEC"
				aCols[z,i] := a185Dados[nX,18]
			ElseIf cCampo $ "D3_GRUPO"
				aCols[z,i] := SB1->B1_GRUPO
			ElseIf cCampo $ "D3_TIPO"
				aCols[z,i] := SB1->B1_TIPO
			ElseIf cCampo $ "D3_NUMSA"
				aCols[z,i] := a185Dados[nX,2]
			ElseIf cCampo $ "D3_NRBPIMS"
				aCols[z,i] := a185Dados[nX,22]
			ElseIf cCampo $ "D3_ITEMSA"
				aCols[z,i] := a185Dados[nX,3]
			ElseIf cCampo $ "D3_ORDEM"
				If AllTrim(GetNewPar("MV_NGMNTNO","N")) == "1" .And. SubStr(a185Dados[nX,13],7,5) == "OS001"
					aCols[z,i] := SubStr(a185Dados[nX,13],1,6)
				EndIf
			ElseIf cCampo $ "D3_TRT"
				If Empty( a185Dados[nX,13] )
					cTrt := CriaVar( "D3_TRT", .F. )
				Else
					If !SD4->( dbSeek( cFilSD4 + Padr( a185Dados[nX,13], nTamOP ) + Padr( a185Dados[nX,4], nTamCod  ) +  Padr( a185Dados[nX,6], nTamLoc ) ) )
						cTrt := CriaVar( "D3_TRT", .F. )
					Else
						cTrt := SD4->D4_TRT
					EndIf
				EndIf
				aCols[z,i] := cTrt
			ElseIf cCampo $ "D3_GARANTI"
				aCols[z,i] := CriaVar( "D3_GARANTI", .T. )
			EndIf
			//Ŀ
			// Inicializador padrao dos campos de Usuario do SX3 	   
			//
			If cCampo == "D3_ALI_WT"
				aCols[z,i] := a185Dados[nX,20]
			ElseIf cCampo == "D3_REC_WT"
				aCols[z,i] := a185Dados[nX,21]
			ElseIf cCampo == "D3_CC"
				aCols[z,i] := a185Dados[nX,10]
			ElseIf cCampo == "D3_SERVIC" .And. lWmsNew .And. Iif(!Empty(cProdWms),IntWMS(cProdWms),.F.)
				aCols[z,i] := Posicione("SB5",1,xFilial("SB5")+cProdWms,"B5_SERVREQ")
			Else
				cX3_PROPRI := GetSX3Cache(cCampo, "X3_PROPRI")
				if cX3_PROPRI == "U" 
					cX3_RELACAO := GetSX3Cache(cCampo, "X3_RELACAO")
					if !Empty(cX3_RELACAO)
						aCols[z,i] := InitPad(cX3_RELACAO)
					EndIf
				EndIf
			EndIf
			//Ŀ
			// M185CAMP - P.E. utilizado para carregar campos de usuario 
			//
			If lM185Camp
				ExecBlock("M185CAMP",.F.,.F.,{cCampo,z,nX,i})
			EndIf
		Next i
		FillCTBEnt("SCP",z,a185Dados[nX,21])
		aCols[z][Len(aHeader)+1] := .F.
	EndIf
Next nX

//Ŀ
// Insere o Centro de Custo se for o mesmo para todos. 
//
cCC := If(Len(aCC)>1,cCC,aCC[1])

//Ŀ
// Campos que podem ser alterados na GetDados.         
//
aAdd(aAlter,"D3_CONTA"  )
aAdd(aAlter,"D3_OP"     )
aAdd(aAlter,"D3_GRUPO"  )
aAdd(aAlter,"D3_CUSTO1" )
aAdd(aAlter,"D3_CUSTO2" )
aAdd(aAlter,"D3_CUSTO3" )
aAdd(aAlter,"D3_CUSTO4" )
aAdd(aAlter,"D3_CUSTO5" )
aAdd(aAlter,"D3_TRT"    )
aAdd(aAlter,"D3_LOTECTL")
aAdd(aAlter,"D3_NUMLOTE")
aAdd(aAlter,"D3_DTVALID")
aAdd(aAlter,"D3_LOCALIZ")
aAdd(aAlter,"D3_NUMSERI")
aAdd(aAlter,"D3_PROJPMS")
aAdd(aAlter,"D3_TASKPMS")
aAdd(aAlter,"D3_ITEMCTA")
aAdd(aAlter,"D3_CLVL")
aAdd(aAlter,"D3_CC")
aAdd(aAlter,"D3_SERVIC")

If GetMv("MV_NGMNTES") = "S"
   aAdd(aAlter,"D3_ORDEM")
Endif

//Ŀ
// Verifica se Existem Campos de Usuario no SX3                 
//
SX3->(dbSetOrder(1))
If SX3->(dbSeek('SD3', .F.))
	Do While !SX3->(Eof()) .And. SX3->X3_ARQUIVO == 'SD3'
		If SX3->X3_PROPRI == 'U'
			aAdd(aAlter,SX3->X3_CAMPO)
		EndIf
		SX3->(dbSkip())
	EndDo
EndIf
dbSelectArea(cSavAlias)
aColsX := aClone(aCols)  // Walk-Thru

RestArea( aAreaSD4 )
Return

/*


Ŀ
Funo    A185QtProc Autor  Larson Zordan          Data 11/12/2002
Ĵ
Descrio  Funcao para Verificar as SC's amarradas ao produto         
Ĵ
Sintaxe    ExpN1 := A185QtProc(ExpC1)                                 
Ĵ
Parametros ExpC1 = Codigo do Produto                                  
Ĵ
Retorno    ExpN1 = qtde.total                                         
Ĵ
 Uso       MATA185                                                    
ٱ


/*/
Function A185QtProc(cProduto)
Local aAreaAnt := GetArea()
Local nQtTotal := 0
Local aStruSC1
Local cAliasSC1
Local cQuery
Local nX

aStruSC1  := SC1->(dbStruct())
cAliasSC1 := "A185SC1"
cQuery    := "SELECT "
cQuery    += "SC1.C1_PRODUTO, Sum(SC1.C1_QUANT) C1_QUANT, Sum(SC1.C1_QUJE) C1_QUJE FROM "
cQuery    += RetSqlName("SC1")+" SC1 "
cQuery    += "WHERE "
cQuery    += "SC1.C1_FILIAL = '"+xFilial("SC1")+"' And "
cQuery    += "SC1.C1_PRODUTO = '"+cProduto+"' And "
cQuery    += "(SC1.C1_QUJE >= 0 Or SC1.C1_QUJE < SC1.C1_QUANT) And "
cQuery    += "SC1.C1_RESIDUO = ' '  AND SC1.D_E_L_E_T_ = ' ' "
cQuery    += "GROUP BY SC1.C1_PRODUTO "
cQuery    := ChangeQuery(cQuery)
dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasSC1,.T.,.T.)
For nX := 1 To Len(aStruSC1)
	If ( aStruSC1[nX][2] <> "C" )
		TcSetField(cAliasSC1,aStruSC1[nX][1],aStruSC1[nX][2],aStruSC1[nX][3],aStruSC1[nX][4])
	EndIf
Next nX

nQtTotal := (cAliasSC1)->C1_QUANT - (cAliasSC1)->C1_QUJE

dbSelectArea(cAliasSC1)
dbCloseArea()

RestArea(aAreaAnt)
Return(nQtTotal)

/*


Ŀ
Funo    A185AtuPer Autor  Marcos V. Ferreira     Data 10/03/2005
Ĵ
Descrio Atualiza o pergunte para chamada das funcoes A240INCLUI e   
			 A241INCLUI												  
Ĵ
Parametros ExpN1 - Tipo de configuracao de tecla F12	              
Ĵ
Retorno    Nenhum                                                     
Ĵ
 Uso       MATA185                                                    
ٱ


*/
Static Function A185AtuPer(nTipo)
Default nTipo := 0

If nTipo == 1
	Pergunte("MTA240",.F.)
	If cCusMed <> "O"
		If !l185Auto
			SetKey(VK_F12, {|| MTA185PERG()})
		EndIf
	EndIf
 ElseIf nTipo == 2
	Pergunte("MTA185",.F.)
	If cCusMed <> "O"
		If !l185Auto
			SetKey(VK_F12, {|| MTA185PERG()})
		EndIf
	EndIf
EndIf

Return
/*


Ŀ
Funo    A185QtdNeg Autor  Marcos V. Ferreira     Data 06/04/2005
Ĵ
Descrio Valida a quantidade estornada, quando eh realizado um       
			 estorno de quantidade negativa							  
Ĵ
Sintaxe    A185QtdNeg(ExpN1,ExpC1,ExpC2)                              
Ĵ
Parametros ExpN1 = qtde.                                              
           ExpC1 = Numero da SC                                       
           ExpC2 = Item da SC                                         
Ĵ
Retorno    ExpN1 = qtde.                                              
Ĵ
 Uso       MATA185                                                    
ٱ


*/
Static Function A185QtdNeg(nQtde,cNumSC,cItemSc)
Local lEstNeg
Local aAreaAnt

DEFAULT cNumSC := ""

If !Empty(cNumSC)
	lEstNeg := If(GetMV('MV_ESTNEG')=='N',.F.,.T.)
	aAreaAnt:= GetArea()

	dbSelectArea("SC1")
	SC1->(dbSetOrder(1))
	If lEstNeg .And. SC1->(dbSeek(xFilial("SC1")+cNumSc+cItemSc))
		If Empty(SC1->C1_PEDIDO) .And. Empty(SC1->C1_COTACAO)
			nQtde := 0
		Endif
	Endif
	RestArea(aAreaAnt)
EndIf
Return nQtde

/*


Ŀ
Funo    A185ValEmp Prog.  Marcos V. Ferreira    Data  18.04.2005
Ĵ
Descrio Valida o saldo empenhado da SA para baixa do pre-requisicao.|
Ĵ
Sintaxe    A185ValEmp(ExpC1,ExpC2,ExpN1,ExpC3,ExpC4)                  
Ĵ
Parametros ExpC1 = cod.produto                                        
           ExpC2 = cod.local	                                      
           ExpN1 = qtde.                                              
           ExpC3 = Numero da SA                                       
           ExpC4 = Item da SA                                         
           ExpA1 = Acols das pre-requisicoes - baixa por pre-requisic.
Ĵ
Retorno    .T. / .F.             	                                  
Ĵ
 Uso      MATA185				                                      
ٱ


*/
Static Function A185ValEmp(cProd,cLocal,nQuant,cNum,cItem,aCols)
Local lRet      := .F.
Local lEstNeg   := SuperGetMv("MV_ESTNEG",.T.,"S")=="S"
Local aAreaSCP  := SCP->(GetArea())
Local aAreaSCQ  := SCQ->(GetArea())
Local aAreaSB2  := SB2->(GetArea())
Local nRecSCQ   := 0
Local nTotDisp  := 0
Local nQatu     := 0
Local nQtRes    := 0
Local nQtSal    := 0
Local nIndex    := 0
Local nQtDisp   := 0
Local cArquivo  := CriaTrab(,.F.)
Local cChave	:="CQ_FILIAL+CQ_PRODUTO+CQ_LOCAL"
Local cFor 	    :="CQ_FILIAL == '"+xFilial("SCQ")+"' .And. CQ_PRODUTO=='"+cProd+"' .And. CQ_LOCAL=='"+cLocal+"'"
Local aRequis   := {}
Local aNumScDhn := {}

Default aCols   := {}

If lEstNeg
	lRet := .T.
Else
	IndRegua("SCQ",cArquivo,cChave,,cFor)
	DbSelectArea("SCQ")
	nIndex := RetIndex("SCQ")
	DbSetOrder(nIndex+1)

    While !Eof()
	   If CQ_NUM == cNum .And. CQ_ITEM == cItem
		  If lPermBx .And. Empty(SCQ->CQ_NUMREQ)
			  nQtDisp := CQ_QTDISP
			  nRecSCQ := SCQ->(Recno())
		  EndIf
	   	  dbSkip()
	   	  Loop
	   EndIf
   	   If Empty(SCQ->CQ_NUMREQ)
	       nTotDisp += SCQ->CQ_QTDISP
	       aNumScDhn := COMPosDHN({2,{SCQ->CQ_FILIAL,SCQ->CQ_NUM,SCQ->CQ_ITEM,"1",'MATA106'}})
	       If lPermBx .And. (!(aNumScDhn[1]) .Or. (aNumScDhn[2])->DHN_TIPO <> "1") .And. Empty(SCQ->CQ_NUMREQ) .And. SCQ->CQ_QTDISP > 0
		       aAdd(aRequis,{.F.,SCQ->CQ_NUM, SCQ->CQ_ITEM, SCQ->CQ_PRODUTO, SCQ->CQ_QUANT, SCQ->CQ_QTDISP, SCQ->(Recno())})
		   EndIf
		   If aNumScDhn[1]
		   		(aNumScDhn[2])->(DbCloseArea())
		   EndIf
	   EndIf
	   dbSelectArea("SCQ")
       dbSkip()
    EndDo

	dbSelectArea("SB2")
	dbSetOrder(1)
	If dbSeek(xFilial()+cProd+cLocal)
		If (B2_QEMPSA-nTotDisp)>=nQuant
		   lRet := .T.
		Else
			nQAtu := SB2->B2_QATU
			nQtRes:= SB2->B2_RESERVA+SB2->B2_QEMP+SB2->B2_QEMPSA+SB2->B2_QACLASS-If(mv_par03==1.And.!Empty(SCP->CP_OP),SCP->CP_QUANT,0)
			nQtSal:= nQAtu - nQtRes
			If nQtSal >= nQuant
				lRet := .T.
			ElseIf (nQtSal+B2_QEMPSA-nTotDisp)>=nQuant
				lRet := .T.
			Else
				If !lPermBx .Or. IsBlind() 
					Help(" ",1,"A185DISP")
				Else
					If Aviso("MV_BXPRERQ",STR0076,{STR0022, STR0023}) == 1 //"Deseja utilizar a quantidade que falta de outra pre-requisicao com saldo disponivel ?"
						lRet := A185BxPre(aRequis,nQuant-nQtDisp,nRecSCQ,aCols)
					EndIf
				EndIf
			EndIf
		EndIf
	EndIf

	//Ŀ
	//Restaura o SCQ                                                          
	//
	dbSelectArea("SCQ")
	RetIndex("SCQ")
	dbClearFilter()
	Ferase(cArquivo+OrdBagExt())

EndIf
RestArea(aAreaSB2)
RestArea(aAreaSCP)
RestArea(aAreaSCQ)
Return lRet

/*


Ŀ
Funo    A185BxEmp  Prog.  Marcos V. Ferreira    Data  15.08.2005
Ĵ
Descrio Atualiza o campo B2_QEMPSA na gravacao da pre-requisicao 	  |
          modelo II.			                                      
Ĵ
Sintaxe    A185BxEmp(ExpN1)				                              
Ĵ
Parametros ExpN1 = numero da linha do aCols 	                      
Ĵ
Retorno    Nenhum					                                  
Ĵ
 Uso      MATA185				                                      
ٱ


*/
Function A185BxEmp(nLinha)
Local aAreaAnt	:= GetArea()
Local aAreaSCP	:= SCP->(GetArea())
Local aAreaSCQ	:= SCQ->(GetArea())
Local aAreaSB2	:= SB2->(GetArea())
Local nPosNumSA	:= 0
Local nPosItmSA	:= 0
Local nPosQuant	:= 0
Local nX 		:= 0
Local aRetSA	:= {}

Default nLinha	 := 0

//Ŀ
// Baixa Empenho SA (Pre-Requisicao)			
//
If (Type('l185') == 'L' .And. l185) .And. (Type('l241') == 'L' .And. l241)

	For nx := 1 To Len(aHeader)
		Do Case
			Case Trim(aHeader[nx][2]) == "D3_NUMSA"
				nPosNumSA:=nX
			Case Trim(aHeader[nx][2]) == "D3_ITEMSA"
				nPosItmSA:=nX
			Case Trim(aHeader[nx][2]) == "D3_QUANT"
				nPosQuant:=nX
		EndCase
	Next nX

	dbSelectArea("SCP")
	If dbSeek(xFilial()+PADR(aCols[nLinha,nPosNumSa], TamSX3("D3_NUMSA")[1] )+PADR(aCols[nLinha,nPosItmSa], TamSX3("D3_ITEMSA")[1]))
		aRetSA := ca100RetCQ(PADR(aCols[nLinha,nPosNumSa],TamSX3("D3_NUMSA")[1] ),PADR(aCols[nLinha,nPosItmSa], TamSX3("D3_ITEMSA")[1]))
		//Ŀ
		// ca100RetCQ() ----------->                   
		// [1] -  Saldo do Item                        
		// [2] -  Quantidade diponivel ja reservada    
		// [3] -  Quantidade em Processo de Compra     
		// [4] -  Situacao Atual                       
		// [5] -  Numero da Solicitacao de Compras     
		// [6] -  Numero de Requisicao                 
		// [7] -  Quantidade ja Entregue               
		//
		dbSelectArea("SCQ")
		dbSetOrder(1)
		dbSeek(xFilial()+SCP->CP_NUM+SCP->CP_ITEM)
		dbSelectArea("SB2")
		dbSetOrder(1)
		dbSeek(xFilial()+SCP->CP_PRODUTO+SCP->CP_LOCAL)
		If Reclock("SB2",.F.)
			SB2->B2_QEMPSA := B2_QEMPSA - If(aCols[nLinha,nPosQuant]<aRetSA[2], aCols[nLinha,nPosQuant], aRetSA[2])
		EndIf
	EndIf
EndIf
RestArea(aAreaSCP)
RestArea(aAreaSCQ)
RestArea(aAreaSB2)
RestArea(aAreaAnt)
Return
/*


Ŀ
Funo    A185RotAut Prog.  Marcos V. Ferreira    Data  13.09.2005
Ĵ
Descrio Chama a rotina automatica do MATA240 para realizar a baixa  |
          da pre-requisicao pela rotina automatica do MATA185         
Ĵ
Parametros Nenhum                                                     
Ĵ
Retorno    .T. / .F.				                                  
Ĵ
 Uso      MATA185				                                      
ٱ


*/
Function A185RotAut()
Local cCampo  := ''
Local aCampos := {}
Local nX	  := 0
Local nPos	  := 0
Local aCopia
Local lAtuAFH := .F.

Private lMSHelpAuto := .F.

If Type("aAutoAFH") <> "U"
	lAtuAFH:= aAutoAFH <> NIL .And. ValType(aAutoAFH) = 'A'
EndIf

dbSelectArea("SB1")
dbSetOrder(1)
If dbSeek(xFilial("SB1")+SCP->CP_PRODUTO)

	//Ŀ
	// ATENCAO - estes campos sao os mesmos utilizados pela  |
	//| funcao A185AtuSD3() qualquer alteracao nesta funcao   |
	//| tambem devera ser realizada no aArray aCampos         |
	//
	aCampos := {{"D3_COD"		,SCP->CP_PRODUTO	},{"D3_UM"	 	,SCP->CP_UM		},;
				{"D3_CONTA"		,SCP->CP_CONTA		},{"D3_CLVL"	,SCP->CP_CLVL	},;
				{"D3_ITEMCTA"	,SCP->CP_ITEMCTA	},{"D3_LOCAL"	,SCP->CP_LOCAL	},;
				{"D3_EMISSAO"	,DDATABASE			},{"D3_GRUPO"	,SB1->B1_GRUPO	},;
				{"D3_CC"		,SCP->CP_CC			},{"D3_SEGUM"	,SCP->CP_SEGUM	},;
				{"D3_QTSEGUM"	,SCP->CP_QTSEGUM	},{"D3_TIPO"	,SB1->B1_TIPO	},;
				{"D3_OP"		,SCP->CP_OP			},{"D3_OSTEC"	,SCP->CP_NUMOS	},;
				{"D3_NUMSA"		,SCP->CP_NUM		},{"D3_ITEMSA"	,SCP->CP_ITEM	},;
				{"D3_QUANT"	,Iif(lAtuAFH .And. Len(aDadosPrj) > 0,aDadosPrj[3],nQtRequ)			}}

	If SCP->(ColumnPos("CP_TRT") > 0)
		aAdd( aCampos,{"D3_TRT"		,SCP->CP_TRT } )
	EndIf

	If lAtuAFH .And. Len(aDadosPrj) > 0 .And. !Empty(aDadosPrj[1])
		aAdd(aCampos,{"D3_PROJPMS"	,aDadosPrj[1] })
		aAdd(aCampos,{"D3_TASKPMS"	,aDadosPrj[2] })
	EndIf

	//Ŀ
	// Prepara o array aAutoSD3 para baixa da pre-requisicao |
	//
	For nX:=1 to Len(aCampos)
		nPos := aScan(aAutoSD3,{ |x| Upper(AllTrim(x[1])) == aCampos[nX,1]})
		If nPos > 0
			cCampo := Upper(AllTrim(aAutoSD3[nPos,1]))
			If Empty(cCampo) .Or. cCampo == "D3_COD" .Or. cCampo == "D3_GRUPO" .Or. cCampo == "D3_TIPO" .Or.;
				cCampo == "D3_QUANT" .Or. cCampo == "D3_PROJPMS" .Or. cCampo == "D3_TASKPMS"
				aAutoSD3[nPos,2] := aCampos[nX,2]
			EndIf
		Else
			aAdd(aAutoSD3,{aCampos[nX,1],aCampos[nX,2],Nil})
		EndIf
	Next nX

	aCopia := aClone(aRotina)

	aRotina	:= {	{nil,nil,nil,1,0,.F.},;
			  		{nil,nil,nil,2,0,.F.},;
			 		{nil,"A240Inclui"	, 0 , 3,0,nil}}	//"Incluir"

	//Ŀ
	// Realiza Inclusao do movimento via MsRotAuto           |
	//
	MsRotAuto(3,aAutoSD3,"SD3")

	aRotina := aClone(aCopia)

EndIf

RETURN IIf(Type("lMsErroAuto") == "L",!lMsErroAuto,.F.)


/*/


Ŀ
Programa  MenuDef    Autor  Fabio Alves Silva      Data 05/10/2006
Ĵ
Descrio  Utilizacao de menu Funcional                               
                                                                      
                                                                      
Ĵ
Retorno   Array com opcoes da rotina.                                 
Ĵ
ParametrosParametros do array a Rotina:                               
          1. Nome a aparecer no cabecalho                             
          2. Nome da Rotina associada                                 
          3. Reservado                                                
          4. Tipo de Transao a ser efetuada:                        
          	  1 - Pesquisa e Posiciona em um Banco de Dados           
              2 - Simplesmente Mostra os Campos                       
              3 - Inclui registros no Bancos de Dados                 
              4 - Altera o registro corrente                          
              5 - Remove o registro corrente do Banco de Dados        
          5. Nivel de acesso                                          
          6. Habilita Menu Funcional                                  
ٱ


/*/
Static Function MenuDef()
Private aRotina	:= {}

aRotina := {	{STR0001,"PesqBrw"   	, 0 , 1,0,.F.},;	//"Pesquisar"
		  		{STR0002,"AxVisual"   	, 0 , 2,0,Nil},;	//"Visualizar"
				{STR0042,"A185Tipo"   	, 0 , 2,0,Nil},;	//"Tipo Baixa"
				{STR0003,"A185Baixar" 	, 0 , 4,0,NIL},;	//"Baixar"
				{STR0054,"A185Estorn"	, 0 , 5,0,Nil},;	//"Estorno"
				{STR0004,"A185Exclui" 	, 0 , 5,0,Nil},;	//"Excluir"
				{STR0037,"A185Encer"  	, 0 , 5,0,Nil},; 	//"Encerrar"
				{STR0033,"A185Legenda"	, 0 , 1,0,.F.},; 	//"Legenda"
        	 	{STR0068,"MsDocument"	, 0 , 4,0,Nil },;	//"Conhecimento"
        	 	{STR0079,"MATR107"		, 0 , 8,0,Nil }} 	//"Termo de Retirada"

If ExistBlock ("MTA185MNU")
	ExecBlock ("MTA185MNU",.F.,.F.)
EndIf

Return (aRotina)

/*


Ŀ
Funo    A185BxPre  Autor  Nereu Humberto Junior  Data 16.05.2007
Ĵ
Descrio  Tela de transferencia de qtds. entre as pre-requisicoes    
           Utilizada apenas quando o MV_BXPRERQ esta com .T.          
Ĵ
Sintaxe   A185BxPre(aRequis,nQtdNec,nRecSCQ)                          
Ĵ
Parametros ExpA1 = Array com as pre-requisicoes com qtds. disponiveis 
           ExpN1 = Quantidade necessaria para a baixa total           
           ExpN2 = Recno da Pre-Requisicao                            
           ExpA1 = Acols das pre-requisicoes - baixa por pre-requisic.
Ĵ
 Uso      MATA185                                                     
ٱ


*/

Function A185BxPre(aRequis,nQuant,nRecSCQ,aCols)

Local nOpc       := 0
Local nx         := 0
Local aPreReq    := aRequis
Local nPreReq    := 0
Local oOk        := LoadBitMap(GetResources(), "LBOK")
Local oNo        := LoadBitMap(GetResources(), "LBNO")
Local aTitCampos := {}
Local bLine      := { || .T. }
Local cLine      := ""
Local lRet       := .F.
Local aAreaSCQ   := SCQ->(GetArea())
Local nQtdAux    := nQuant
Local oPanel,oDlg,oListBox

Default aCols    := {}

//Ŀ
// Exibe os dados na Tela                                   
//
If ( !Empty(aPreReq) )

	aTitCampos := {" ",OemToAnsi(RetTitle("CQ_NUM")),OemToAnsi(RetTitle("CQ_ITEM")),OemToAnsi(RetTitle("CQ_PRODUTO")),OemToAnsi(RetTitle("CQ_QUANT")),OemToAnsi(RetTitle("CQ_QTDISP"))}
	cLine := "{If(aPreReq[oListBox:nAt,1],oOk,oNo),aPreReq[oListBox:nAT][2],aPreReq[oListBox:nAT][3],aPreReq[oListBox:nAT][4],aPreReq[oListBox:nAT][5],aPreReq[oListBox:nAT][6]}"
	//Ŀ
	// Monta dinamicamente o bline do CodeBlock                 
	//
	bLine := &( "{ || " + cLine + " }" )

	DEFINE MSDIALOG oDlg FROM 50,40  TO 285,541 TITLE OemToAnsi(STR0071) Of oMainWnd PIXEL //"Pre-Requisicoes Disponiveis"

	@ 12,0 MSPANEL oPanel PROMPT "" SIZE 100,19 OF oDlg CENTERED LOWERED
	oPanel:Align := CONTROL_ALIGN_TOP

	oListBox := TWBrowse():New( 27,4,243,86,,aTitCampos,,oDlg,,,,,,,,,,,,.F.,,.T.,,.F.,,,)
	oListBox:SetArray(aPreReq)
	oListBox:bLDblClick := { || aPreReq[oListBox:nAt,1] := !aPreReq[oListBox:nAt,1] }
	oListBox:bLine := bLine

	oListBox:Align := CONTROL_ALIGN_ALLCLIENT

	@ 6  ,4   SAY OemToAnsi(STR0072) Of oPanel PIXEL SIZE 150 ,9 //"Quantidade a baixar: "
	@ 4  ,65  MSGET nQuant PICTURE PesqPict('SB2','B2_QATU') When .F. Of oPanel PIXEL SIZE 40,9

	ACTIVATE MSDIALOG oDlg CENTERED ON INIT EnchoiceBar(oDlg,{||(nOpc := 1,nPreReq := oListBox:nAt,oDlg:End())},{||(nOpc := 0,nPreReq := oListBox:nAt,oDlg:End())},,)

	If ( nOpc == 1 ) .And. Aviso(STR0073, STR0074, {STR0022, STR0023}) == 1 //Atencao#"Confirma a transferencia de quantidades entre as pre-requisicoes ?"
		For nx	:= 1 to Len(aPreReq)
			If aPreReq[nx][1]
				If nQtdAux > 0
					If nQtdAux > aPreReq[nx][5]
						nQtdGrv := aPreReq[nx][5]
						nQtdAux -= nQtdGrv
					Else
						nQtdGrv := nQtdAux
						nQtdAux -= nQtdGrv
					Endif
					dbSelectArea("SCQ")
					dbGoto(aPreReq[nx][7])
					//Subtrai a quantidade necessaria da requisicao escolhida
					Reclock("SCQ",.F.)
	                SCQ->CQ_QTDISP -= nQtdGrv
					MsUnlock()
					nPos := aScan(aCols,{ |x| x[2] == SCQ->CQ_NUM .And. x[3] == SCQ->CQ_ITEM .And. x[4] == SCQ->CQ_PRODUTO})
					If nPos > 0
						aCols[nPos,8] := Transform(SCQ->CQ_QTDISP,PesqPictQt('D3_QUANT'))
						aCols[nPos,9] :=SCQ->CQ_QTDISP
                    Endif
					//Soma a quantidade na requisicao posicionada
					dbGoto(nRecSCQ)
					Reclock("SCQ",.F.)
	                SCQ->CQ_QTDISP += nQtdGrv
					MsUnlock()
					lRet := .T.
				Endif
			EndIf
		Next
	Endif
Else
	Aviso(STR0073,STR0075,{"OK"}) //Atencao#"No existe pre-requisicoes disponiveis !"
	lRet := .F.
Endif

RestArea(aAreaSCQ)

Return(lRet)

/*


Ŀ
Funo    A185SegUM  Autor  Microsiga S/A          Data 03.10.2008
Ĵ
Descrio  Funcao utilizada para verificar se o produto utiliza       
           segunda unidade de medida com fator de conversao.          
Ĵ
Sintaxe   A185SegUM(cCod)                                             
Ĵ
Parametros ExpC1 = Codigo do produto                                  
Ĵ
Retorno    ExpN1 = 1 - Utiliza SegUM com fator de conversao           
                   2 - Utiliza SegUM sem fator de conversao           
Ĵ
 Uso      MATA185                                                     
ٱ


*/
Static Function A185SegUm(cCod)
Local nRet     := 1 //-- Caso no utilize SegUm Forcar ConvUM
Local aAreaAnt := GetArea()
Local aAreaSB1 := SB1->(GetArea())
dbSelectArea("SB1")
dbSetOrder(1)
If dbSeek(xFilial("SB1")+cCod)
	If !Empty(SB1->B1_SEGUM) .And. !Empty(SB1->B1_CONV)
		lRet := 1
	ElseIf !Empty(SB1->B1_SEGUM) .And. Empty(SB1->B1_CONV)
		nRet := 2
	EndIf
EndIf
RestArea(aAreaSB1)
RestArea(aAreaAnt)
Return nRet

/*/

Ŀ
Funo     A185OK   Rev.    Bruno Schmidt          Data 02.12.2010 
Ĵ
          Funcao de fazer validacaoes no momento de confirmar          
Ĵ
Sintaxe   A185OK(ExpL1)                                                
Ĵ
ParametrosExpL1: Verifica a Existencia do Ponto de Entrada             
Ĵ
Retorno   .T./.F.	                                                   
Ĵ
Descrio Esta rotina executa o Ponto de Entrada MT185OK para          
          validacoes complementares quando se confirma a EnchoiceBar   
          todas as informacoes vinculadas.                             
Ĵ
Uso        Materiais                                                   
ٱ


/*/
Function A185OK(lMT185OK)
Local lRet  := .T.

IF lMT185OK
  lRet := ExecBlock("MT185OK",.F.,.F.)
	If ValType(lRet) <> "L"
		lRet:= .T.
	EndIf
EndIf

Return lRet
/*


ͻ
Programa  FillCTBEntAutor   Anieli Rodrigues	  Data  18/06/13    
͹
Descricao  Inicaliza campos das entidades contabeis de acordo com a   
           origem.                                                    
͹
Uso        MATA185                                                    
ͼ


*/
Static Function FillCTBEnt(cOrigem,nItem,nRecno)
Local aCTBEnt := CTBEntArr()
Local nX	  := 0
Local aAreaSCP := SCP->(GetArea())

SCP->(DbGoTo(nRecno))

For nX := 1 To Len(aCTBEnt)
	If GDFieldPos("D3_EC"+aCTBEnt[nX]+"CR",aHeader) > 0
		aCols[nItem,GDFieldPos("D3_EC"+aCTBEnt[nX]+"CR")] := (cOrigem)->&("CP_EC"+aCTBEnt[nX]+"CR")
	EndIf
	If GDFieldPos("D3_EC"+aCTBEnt[nX]+"DB",aHeader) > 0
		aCols[nItem,GDFieldPos("D3_EC"+aCTBEnt[nX]+"DB")] := (cOrigem)->&("CP_EC"+aCTBEnt[nX]+"DB")
	EndIf
Next nX

RestArea(aAreaSCP)

Return

/*


ͻ
Programa  A185VldNG  Autor   Caio C. F.			 Data  24/02/14 
͹
Descricao  Avalia se a OS j foi encerrada no SIGAMNT para encerrar   
           a pr-requisio.                                          
͹
Uso        MATA185/MATA240                                            
ͼ


*/

Function A185VldNG(cOP)

Local lRet  := .F.
Local aArea := GetArea()
Local aAreaSTJ := STJ->(GetArea())

If GetMv("MV_NGMNTES") == "S" //Verifica se usa integrao com SIGAMNT
	dbSelectArea("STJ")
 	dbSetOrder(1) // FILIAL + ORDEM + PLANO + TIPOOS + CODBEM + SERVICO + SEQRELA
 	If STJ->(dbSeek(xFilial("STJ")+SubStr(cOP,1,6)))
 		If STJ->TJ_TERMINO == "S"
 			lRet := .T.
 		EndIf
	EndIf
EndIf

RestArea(aAreaSTJ)
RestArea(aArea)

Return lRet

/*


Ŀ
Funao    M185RetPrj  Autor  Materiais             Data 18/09/2014
Ĵ
Descriao  Retorna o codigo do projeto e tarefa amarrado a SA         
Ĵ
 Uso       MATA185                                                    
ٱ

*/
Static Function M185RetPrj(cNumSA,cItem)

Local aArea		:= GetArea()
Local aAreaAFH	:= AFH->(GetArea())
Local aRet			:= {}

dbSelectArea("AFH")
dbsetorder(2)
If MsSeek(xFilial("AFH")+cNumSA+cItem)
	aAdd(aRet,AFH->AFH_PROJET)
	aAdd(aRet,AFH->AFH_TAREFA)
EndIf

RestArea(aAreaAFH)
RestArea(aArea)

Return aRet

/*/{Protheus.doc} CallsOfEst
	Criada para integraes com mdulos de Ativos Fixos (ATFA012) e Compras (MATA103X).
	@type  Function
	@author Mauro Swincik Jr. - SQUAD Entradas
	@since 09/01/2019
	@version P12.1.17
	@return lRet, logical, indica se a chamada atual partiu das rotinas indicadas
		na declarao de lRet.
/*/
Function CallsOfEst()

Local lRet := FwIsInCallStack("MATA240") .Or. FwIsInCallStack("MATA241");
	.Or. FwIsInCallStack("MATA185") // .Or. ...


Return lRet

/*/{Protheus.doc} A185VldExc
Verifica se existem documentos de compra vinculados e pergunta se deseja prosseguir com a exclusao da pre-req
*** Os documentos de compras nao sao alterados ***

@author carlos.capeli
@since 15/10/2020
@return lRet - Indica se deve prosseguir com a exclusao da pre-req
/*/
Static Function A185VldExc(cNumSCP, cItemSCP, lExcDocCom)

Local aAreaAnt  := GetArea()
Local aDocsCom  := {}
Local aNumScDhn := {}
Local cAliasCom := GetNextAlias()
Local cDocSC	:= ""
Local cItSC     := ""
Local cDocAE    := ""
Local cItAE     := ""
Local cTxtWorkA := ""
Local nOpc      := 0
Local nTamTpDoc	:= Len(OemToAnsi(STR0083))
Local nTamNum   := TamSX3("C1_NUM")[1]
Local nTamItem  := TamSX3("C1_ITEM")[1]
Local nTamFor   := Len(OemToAnsi(STR0084))
Local nTamLoja  := Len(OemToAnsi(STR0085))
Local nTamCGC   := TamSX3("A2_CGC")[1]
Local nTamNome	:= TamSX3("A2_NOME")[1]
Local nTamAli	:= Len(OemToAnsi(STR0086))
Local nTamRec	:= 10
Local lContinua := .F.
Local lRet      := .T.

// Texto para ser copiado para area de trabalho
cTxtWorkA := PadR(" ",nTamTpDoc)+chr(9) + PadR(OemToAnsi(STR0087),nTamNum)+chr(9) + PadR(OemToAnsi(STR0088),nTamItem)+chr(9) + PadR(OemToAnsi(STR0084),nTamFor)+chr(9) + PadR(OemToAnsi(STR0085),nTamLoja)+chr(9) +;
			 PadR(OemToAnsi(STR0089),nTamCGC)+chr(9) + PadR(OemToAnsi(STR0090),nTamNome)+chr(9) + PadR(OemToAnsi(STR0086),nTamAli)+chr(9) + PadR(OemToAnsi(STR0091),nTamRec) + CRLF

SCQ->(DbSetOrder(1))
SCQ->(DbSeek(xFilial("SCQ") + cNumSCP + cItemSCP))

// Recupera a SC gerada pela Central de Compras
aNumScDhn := COMPosDHN({2,{SCQ->CQ_FILIAL,SCQ->CQ_NUM,SCQ->CQ_ITEM,"1",'MATA106'}})
If aNumSCDhn[1]
	If (aNumScDhn[2])->DHN_TIPO == "1" //Solicitao de Compra
		cDocSC	:= (aNumScDhn[2])->DHN_DOCDES
		cItSC	:= (aNumScDhn[2])->DHN_ITDES
	EndIf
	(aNumSCDhn[2])->(DbCloseArea())
EndIf
// Recupera a AE gerada pela Central de Compras
aNumScDhn := COMPosDHN({2,{SCQ->CQ_FILIAL,SCQ->CQ_NUM,SCQ->CQ_ITEM,"3",'MATA106'}})
If aNumSCDhn[1]
	If (aNumScDhn[2])->DHN_TIPO == "3" //Autorizao de Entrega
		cDocAE	:= (aNumScDhn[2])->DHN_DOCDES
		cItAE	:= (aNumScDhn[2])->DHN_ITDES
	EndIf
	(aNumSCDhn[2])->(DbCloseArea())
EndIf

If !Empty(cDocSC)
	SC1->(DbSetOrder(1))
	SC1->(DbSeek(xFilial("SC1")+cDocSC+cItSC))
	If !MaCanAltSC("SC1", 1, .F.)
		lExcDocCom := .F.
		lContinua  := .T.
		cNumSC     := SC1->C1_NUM
		cItemSC    := SC1->C1_ITEM
		aAdd(aDocsCom,{" ", SC1->C1_NUM, SC1->C1_ITEM, 0, " ", " ", " ", " ", " ", "SC1", SC1->(Recno())})
		// Texto para ser copiado para area de trabalho
		cTxtWorkA += PadR(OemToAnsi(STR0092),nTamTpDoc)+chr(9) + PadR(SC1->C1_NUM,nTamNum)+chr(9) + PadR(SC1->C1_ITEM,nTamItem)+chr(9) + PadR(" ",nTamFor)+chr(9) + PadR(" ",nTamLoja)+chr(9) +;
					 PadR(" ",nTamCGC)+chr(9) + PadR(" ",nTamNome)+chr(9) + PadR("SC1",nTamAli)+chr(9) + PadR(SC1->(Recno()),nTamRec) + CRLF
	EndIf
EndIf
If !Empty(cDocAE)
	SC7->(DbSetOrder(1))
	SC7->(DbSeek(xFilial("SC7")+cDocAE+cItAE))
	If !MaCanDelPC("SC7", .F.)
		lExcDocCom := .F.
		SA2->(DbSetOrder(1))
		SA2->(DbSeek(xFilial("SA2")+SC7->C7_FORNECE+SC7->C7_LOJA))
		aAdd(aDocsCom,{" ", SC7->C7_NUM, SC7->C7_ITEM, SC7->C7_TIPO, SC7->C7_FORNECE, SC7->C7_LOJA, SA2->A2_TIPO, SA2->A2_CGC, SA2->A2_NOME, "SC7", SC7->(Recno())})
		// Texto para ser copiado para area de trabalho
		cTxtWorkA += PadR(OemToAnsi(STR0083),nTamTpDoc)+chr(9) + PadR(SC7->C7_NUM,nTamNum)+chr(9) + PadR(SC7->C7_ITEM,nTamItem)+chr(9) + PadR(SC7->C7_FORNECE,nTamFor)+chr(9) + PadR(SC7->C7_LOJA,nTamLoja)+chr(9) +;
					 PadR(SA2->A2_CGC,nTamCGC)+chr(9) + PadR(SA2->A2_NOME,nTamNome)+chr(9) + PadR("SC7",nTamAli)+chr(9) + PadR(SC7->(Recno()),nTamRec) + CRLF
	EndIf
EndIf

If lContinua
	BeginSql Alias cAliasCom

		SELECT	SC8.C8_NUM C8_NUM,
				SC8.C8_ITEM C8_ITEM,
				SC8.C8_FORNECE C8_FORNECE,
				SC8.C8_LOJA C8_LOJA,
				SA2.A2_TIPO A2_TIPO,
				SA2.A2_CGC A2_CGC,
				SA2.A2_NOME A2_NOME,
				SC8.R_E_C_N_O_ RECNOC8
			FROM %table:SC8% SC8
			INNER JOIN %table:SA2% SA2
				ON  SA2.A2_FILIAL = %xFilial:SA2%
				AND SA2.A2_COD    = SC8.C8_FORNECE
				AND SA2.A2_LOJA   = SC8.C8_LOJA
				AND SA2.%NotDel%
			WHERE SC8.C8_FILIAL = %xFilial:SC8%
				AND SC8.C8_NUMSC  = %Exp:cNumSC%
				AND SC8.C8_ITEMSC = %Exp:cItemSC%
				AND SC8.%NotDel%
	EndSQL

	While (cAliasCom)->(!Eof())
		aAdd(aDocsCom,{" ", (cAliasCom)->C8_NUM, (cAliasCom)->C8_ITEM, 0, (cAliasCom)->C8_FORNECE, (cAliasCom)->C8_LOJA, (cAliasCom)->A2_TIPO, (cAliasCom)->A2_CGC, (cAliasCom)->A2_NOME, "SC8", (cAliasCom)->RECNOC8})
		// Texto para ser copiado para area de trabalho
		cTxtWorkA += PadR(OemToAnsi(STR0093),nTamTpDoc)+chr(9) + PadR((cAliasCom)->C8_NUM,nTamNum)+chr(9) + PadR((cAliasCom)->C8_ITEM,nTamItem)+chr(9) + PadR((cAliasCom)->C8_FORNECE,nTamFor)+chr(9) + PadR((cAliasCom)->C8_LOJA,nTamLoja)+chr(9) +;
					 PadR((cAliasCom)->A2_CGC,nTamCGC)+chr(9) + PadR((cAliasCom)->A2_NOME,nTamNome)+chr(9) + PadR("SC8",nTamAli)+chr(9) + PadR((cAliasCom)->RECNOC8,nTamRec) + CRLF
		(cAliasCom)->(DbSkip())
	End
	(cAliasCom)->(DbCloseArea())

	BeginSql Alias cAliasCom

		SELECT	SC7.C7_NUM C7_NUM,
				SC7.C7_ITEM C7_ITEM,
				SC7.C7_FORNECE C7_FORNECE,
				SC7.C7_LOJA C7_LOJA,
				SA2.A2_TIPO A2_TIPO,
				SA2.A2_CGC A2_CGC,
				SA2.A2_NOME A2_NOME,
				SC7.R_E_C_N_O_ RECNOC7
			FROM %table:SC7% SC7
			INNER JOIN %table:SA2% SA2
				ON  SA2.A2_FILIAL = %xFilial:SA2%
				AND SA2.A2_COD    = SC7.C7_FORNECE
				AND SA2.A2_LOJA   = SC7.C7_LOJA
				AND SA2.%NotDel%
			WHERE SC7.C7_FILIAL   = %xFilial:SC7%
				AND SC7.C7_NUMSC  = %Exp:cNumSC%
				AND SC7.C7_ITEMSC = %Exp:cItemSC%
				AND SC7.%NotDel%
	EndSQL

	While (cAliasCom)->(!Eof())
		aAdd(aDocsCom,{" ", (cAliasCom)->C7_NUM, (cAliasCom)->C7_ITEM, 0, (cAliasCom)->C7_FORNECE, (cAliasCom)->C7_LOJA, (cAliasCom)->A2_TIPO, (cAliasCom)->A2_CGC, (cAliasCom)->A2_NOME, "SC7", (cAliasCom)->RECNOC7})
		// Texto para ser copiado para area de trabalho
		cTxtWorkA += PadR(OemToAnsi(STR0094),nTamTpDoc)+chr(9) + PadR((cAliasCom)->C7_NUM,nTamNum)+chr(9) + PadR((cAliasCom)->C7_ITEM,nTamItem)+chr(9) + PadR((cAliasCom)->C7_FORNECE,nTamFor)+chr(9) + PadR((cAliasCom)->C7_LOJA,nTamLoja)+chr(9) +;
					 PadR((cAliasCom)->A2_CGC,nTamCGC)+chr(9) + PadR((cAliasCom)->A2_NOME,nTamNome)+chr(9) + PadR("SC7",nTamAli)+chr(9) + PadR((cAliasCom)->RECNOC7,nTamRec) + CRLF
		(cAliasCom)->(DbSkip())
	End
	(cAliasCom)->(DbCloseArea())
EndIf

If Len(aDocsCom) > 0
	cTextoHelp := OemToAnsi(STR0095) + CRLF	// Esta Pre-requisicao possui documentos de compra relacionados.
	cTextoHelp += OemToAnsi(STR0096) + CRLF	// Deseja prosseguir com a exclusao da Pre-requisicao?
	cTextoHelp += OemToAnsi(STR0097)		// Ao confirmar, os documentos de compra nao serao alterados.

	nOpc := Aviso(STR0073, cTextoHelp, {STR0022, OemToAnsi(STR0098), STR0023})

	If nOpc == 1		// Sim
		lRet := .T.
	ElseIf nOpc == 3	// Nao
		lRet := .F.
	Else				// Consultar documentos
		A185DocVin(aDocsCom, cTxtWorkA)
		lRet := .F.
	EndIf
EndIf

RestArea(aAreaAnt)

Return lRet

/*/{Protheus.doc} A185DocVin
Exibe browse com os documentos de compra vinculados
*** Os documentos de compras nao sao alterados ***

@author carlos.capeli
@since 15/10/2020
/*/
Static Function A185DocVin(aDocsCom, cTxtWorkA)

Local aHeadDocs := {" ", OemToAnsi(STR0087), OemToAnsi(STR0088), OemToAnsi(STR0084), OemToAnsi(STR0085), OemToAnsi(STR0089), OemToAnsi(STR0090), OemToAnsi(STR0086), OemToAnsi(STR0091)}
Local aTamCols  := {10,40,25,40,20,55,160,15,30}
Local oSC		:= LoadBitmap(GetResources(),'BR_VERDE')
Local oCT		:= LoadBitmap(GetResources(),'BR_AZUL')
Local oPC		:= LoadBitmap(GetResources(),'BR_AMARELO')
Local oAE		:= LoadBitmap(GetResources(),'BR_LARANJA')
Local bActVisu  := {|| }
Local bActCopy  := {|| }

If Len(aDocsCom) > 0

		Define MsDialog oDlg Title OemToAnsi(STR0099) From 130,130 TO 535,830 Pixel	// Documentos de compra

		oBrowse := TCBrowse():New(01,01,352,140,,aHeadDocs,aTamCols,oDlg,,,,,{||},,,,,,,.F.,,.T.,,.F.,,.T.,.T.)

		oBrowse:SetArray(aDocsCom)

		oBrowse:bLine := {||{ If(aDocsCom[oBrowse:nAt,10]=="SC1",oSC,If(aDocsCom[oBrowse:nAt,10]=="SC8",oCT,If(aDocsCom[oBrowse:nAt,04]==2,oAE,oPC))),;
							  aDocsCom[oBrowse:nAt,02],;
							  aDocsCom[oBrowse:nAt,03],;
  							  aDocsCom[oBrowse:nAt,05],;
							  aDocsCom[oBrowse:nAt,06],;
							  Transform(aDocsCom[oBrowse:nAt,08],(If(aDocsCom[oBrowse:nAt,07]=="J","@!R NN.NNN.NNN/NNNN-99","@R 999.999.999-99"))),;
							  aDocsCom[oBrowse:nAt,09],;
							  aDocsCom[oBrowse:nAt,10],;
							  aDocsCom[oBrowse:nAT,11] } }

		bActVisu := {|| If(aDocsCom[oBrowse:nAt][10]=="SC1", (SC1->(DbGoTo(aDocsCom[oBrowse:nAt][11])), MATA110(,,2)),;
						If(aDocsCom[oBrowse:nAt][10]=="SC7", (SC7->(DbGoTo(aDocsCom[oBrowse:nAt][11])), MATA120(aDocsCom[oBrowse:nAt,04],,,2)),;
						MsgAlert(OemToAnsi(STR0100),STR0002))) }	// Opcao de Visualizar nao disponivel para cotacao
		bActCopy := {|| CopytoClipboard(cTxtWorkA)}

		@ 150, 006 BITMAP RESOURCE 'BR_VERDE' SIZE 10,08 OF oDlg PIXEL NOBORDER
		@ 150, 016 SAY OemToAnsi(STR0092) SIZE 62,20 OF oDlg PIXEL												// Solicitacao de compra
		@ 160, 006 BITMAP RESOURCE 'BR_AZUL' SIZE 10,08 OF oDlg PIXEL NOBORDER
		@ 160, 016 SAY OemToAnsi(STR0093) SIZE 62,20 OF oDlg PIXEL												// Cotacao
		@ 170, 006 BITMAP RESOURCE 'BR_AMARELO' SIZE 10,08 OF oDlg PIXEL NOBORDER
		@ 170, 016 SAY OemToAnsi(STR0094) SIZE 62,20 OF oDlg PIXEL												// Pedido de compra
		@ 180, 006 BITMAP RESOURCE 'BR_LARANJA' SIZE 10,08 OF oDlg PIXEL NOBORDER
		@ 180, 016 SAY OemToAnsi(STR0083) SIZE 62,20 OF oDlg PIXEL												// Autorizacao de entrega
		TButton():New( 150, 122, OemToAnsi(STR0101), oDlg, bActVisu, 080, 012,,,.F.,.T.,.F.,,.F.,,,.F. )		// Visualizar documento
		TButton():New( 165, 122, OemToAnsi(STR0102), oDlg, bActCopy, 080, 012,,,.F.,.T.,.F.,,.F.,,,.F. )		// Copiar conteudo
		TButton():New( 180, 122, OemToAnsi(STR0103), oDlg,{|| oDlg:End() },080,012,,,.F.,.T.,.F.,,.F.,,,.F. )	// Fechar

		Activate MsDialog oDlg Centered

EndIf

Return

/*/{Protheus.doc} A185MT241
Execauto MATA241 quando os dados 
vem da chamada execauto MATA185
@author 
@since 12/12/2022
/*/
Static Function A185MT241( cDocumento, lChangeDoc) 
Local aCposCab  := {}
Local aCposItem := {}
Local atotitem  := {}
Local cDoc      := ''
Local cCodigoTM := ''
Local nX	    := 0
Local nQuant    := 0 
Local dDatEmi   := DDATABASE
Local cLtCtl    := ''
Local cNumLote  := ''
Local cLocaliz  := ''
Local cNumSeri  := ''

// variaveis de controle para a execauto da MATA241
PRIVATE l241        := .T.
PRIVATE l241Auto    := .T.
PRIVATE l185        := .T.
PRIVATE aAutoCab    := {}
PRIVATE aAutoItens  := {}
PRIVATE lMsHelpAuto := .F.

For nX:=1 to len(aAutoSCP)
	If Upper(AllTrim(aAutoSCP[nX,1])) == "CP_QUANT"
		nQuant := aAutoSCP[nX,2]
	EndIf
Next

For nX:=1 to len(aAutoSD3)
	If Upper(AllTrim(aAutoSD3[nX,1])) == "D3_TM"
		cCodigoTM := aAutoSD3[nX,2]
	EndIf
	If Upper(AllTrim(aAutoSD3[nX,1])) == "D3_EMISSAO"
		dDatEmi := aAutoSD3[nX,2]
	EndIf
	If Upper(AllTrim(aAutoSD3[nX,1])) == "D3_DOC"
		cDoc := aAutoSD3[nX,2]
	EndIf
	If Upper(AllTrim(aAutoSD3[nX,1])) == "D3_LOTECTL"
		cLtCtl := aAutoSD3[nX,2]
	EndIf
	If Upper(AllTrim(aAutoSD3[nX,1])) == "D3_NUMLOTE"
		cNumLote := aAutoSD3[nX,2]
	EndIf
	If Upper(AllTrim(aAutoSD3[nX,1])) == "D3_LOCALIZ"
		cLocaliz := aAutoSD3[nX,2]
	EndIf
	If Upper(AllTrim(aAutoSD3[nX,1])) == "D3_NUMSERI"     
		cNumSeri := aAutoSD3[nX,2]
	EndIf
Next

SB1->(dbSetOrder(1))
If SB1->(dbSeek(xFilial("SB1")+SCP->CP_PRODUTO))
	aCposCab := {}
	If !Empty(cDoc)
		AAdd(aCposCab, {'D3_DOC', cDoc, Nil})
	EndIf
	AAdd(aCposCab, {'D3_TM',      cCodigoTM,   Nil})
	AAdd(aCposCab, {'D3_CC',      SCP->CP_CC,  Nil})
	AAdd(aCposCab, {'D3_EMISSAO', dDatEmi,     Nil})

	aCposItem:={{"D3_COD"     ,SCP->CP_PRODUTO ,NIL},;
				{"D3_UM"      ,SCP->CP_UM      ,NIL},; 
				{"D3_QUANT"   ,nQuant          ,NIL},;
				{"D3_CONTA"	  ,SCP->CP_CONTA   ,NIL},;
				{"D3_ITEMCTA" ,SCP->CP_ITEMCTA ,NIL},;
				{"D3_OP"	  ,SCP->CP_OP      ,NIL},;	
				{"D3_NUMSA"	  ,SCP->CP_NUM     ,NIL},;
				{"D3_LOCAL"   ,SCP->CP_LOCAL   ,NIL},;
				{"D3_GRUPO"	  ,SB1->B1_GRUPO   ,NIL},;
				{"D3_QTSEGUM" ,SCP->CP_QTSEGUM ,NIL},;
				{"D3_LOTECTL" ,SCP->CP_LOTE    ,NIL},;
				{"D3_SEGUM"	  ,SCP->CP_SEGUM   ,NIL},;
				{"D3_PROJPMS" ,SCP->CP_PROJETO ,NIL},;
				{"D3_CLVL"	  ,SCP->CP_CLVL    ,NIL},;
				{"D3_TIPO"	  ,SB1->B1_TIPO    ,NIL},;
				{"D3_OSTEC"	  ,SCP->CP_NUMOS   ,NIL},;
				{"D3_ITEMSA"  ,SCP->CP_ITEM    ,NIL},;
				{"D3_PROJPMS" ,SCP->CP_PROJETO ,NIL},;
				{"D3_LOTECTL" ,cLtCtl          ,Nil},;
				{"D3_NUMLOTE" ,cNumLote        ,Nil},;
				{"D3_LOCALIZ" ,cLocaliz		   ,Nil},;
				{"D3_NUMSERI" ,cNumSeri        ,Nil}}
				
	If SCP->(ColumnPos("CP_TRT") > 0)
		aAdd( aCposItem,{"D3_TRT" ,SCP->CP_TRT, NIL } )
	EndIf

	aadd(atotitem,aCposItem)

	aAutoCab := SD3->(MSArrayXDB(aCposCab))
	For nX := 1 To Len(atotitem)
		aAdd(aAutoItens,SD3->(MSArrayXDB(atotitem[nX])))
	Next nX

	lRet := ( A241Inclui("SD3",0,1,@cDocumento,@lChangeDoc) == 1 )
EndIf 
	
Return lRet 

/*/{Protheus.doc} A185GtCols
Filtra aCols para conter apenas itens que possuem quantidade a ser estornado
@author Squad Entradas
@since 13/07/2023
@return Nil
/*/
Static Function A185GtCols()
Local aArea    := GetArea()
Local aAreaSCP := SCP->(GetArea())
Local nPQtd    := GDFieldPos("CP_QUANT")
Local nPReq    := GDFieldPos("CP_REC_WT")
Local nX := 1

While nX <= Len(aCols)
	SCP->(DbGoTo(aCols[nX,nPReq]))
	If SCP->CP_QUJE <= 0
		aDel(aCols, nX)
		aSize(aCols, Len(aCols)-1)
		Loop
	Else
		aCols[nX,nPQtd] := SCP->CP_QUJE
	EndIf
	nX++
EndDo

RestArea(aAreaSCP)
RestArea(aArea)
Return

/*/{Protheus.doc} A185VldIt
Verifica se algum dos itens utiliza WMS
@author Squad Entradas
@since 13/07/2023
@param lWmsNew, boolean, Contedo do parmetro MV_WMSNEW
@return lEstItem, boolean, Se verdadeiro estorna por item
/*/
Static Function A185VldIt(lWmsNew)
Local aArea    := GetArea()
Local aAreaSCP := SCP->(GetArea())
Local nPReq    := GDFieldPos("CP_REC_WT")
Local lEstItem := .F.
Local nX

For nX := 1 To Len(aCols)
	SCP->(DbGoTo(aCols[nX,nPReq]))
	If !lEstItem
		lEstItem := lWmsNew .And. IntWMS(SCP->CP_PRODUTO)
	EndIf
Next

RestArea(aAreaSCP)
RestArea(aArea)
Return lEstItem

/*/{Protheus.doc} FnVlSaOs
Funo para carregar a variavel static '__lSaOrdSep'
@author Leonardo Kichitaro
@since 21/02/2025
/*/
Static Function FnVlSaOs()
	//Validao do ambiente para Ordem de Separacao de SA
	If Type("__lSaOrdSep") == "U"
		If (__lSaOrdSep := FindFunction( 'AcdVldSA' ))
			__lSaOrdSep := AcdVldSA("SCP","CP_ORDSEP")
		EndIf
	EndIf
Return
