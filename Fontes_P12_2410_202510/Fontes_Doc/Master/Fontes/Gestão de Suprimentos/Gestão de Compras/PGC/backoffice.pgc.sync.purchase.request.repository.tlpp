#include 'tlpp-core.th'
#include 'tlpp-rest.th'
#include 'backoffice.pgc.sync.purchase.request.repository.ch'

namespace pgc.syncPurchaseRequestRepository
using namespace pgc.utils

/*/{Protheus.doc} pgcSyncPurchaseRequestRepository
	Classe Adapter para o serviço de solicitações de compra
@author juan.felipe
@since 02/09/2021
/*/
Class pgcSyncPurchaseRequestRepository FROM FWAdapterBaseV2
    public Method New()
    public Method Get()
    public Method postCheckOpen()
    private Method addOthersDataFields()
EndClass


/*/{Protheus.doc} New
	Método construtor
@author juan.felipe
@since 02/09/2021
/*/
Method New(cVerb) Class pgcSyncPurchaseRequestRepository
    _Super:New(cVerb, .T.)
Return Self

/*/{Protheus.doc} Get
	Consulta solicitações de compra
@author juan.felipe
@since 02/09/2021
@param nPage, numeric, número da pagina.
@param nPageSize, numeric, tamanho da página.
@param cRequestCode, character, código da solicitação de compra.
@param nRequestType, numeric, 1- Em aberto; 2- Parcialmente atendidas; 3- Atendidas; 4-Em aberto todas filiais.
@param nGroupBy, numeric, 0- Sem agrupamento; 1- Agrupamento por SC; 2- Agrupamento por Produto.
@return Nil, nulo.
/*/
Method Get(nPage, nPageSize, cRequestCode, nRequestType, nGroupBy) class pgcSyncPurchaseRequestRepository
    Local aArea         As Array
    Local aQueryRequest As Array
    Local cWhere As Character
    Local cFilter As Character
    Local cQuery As Character
    Local oUtils As Object
    Private aSC1Fields := {}

    Default nPage        := 1
	Default nPageSize    := 10
	Default cRequestCode := ""
    Default nRequestType := 0
    Default nGroupBy     := 0
    
    cFilter := ''
    cQuery := ''

	DbSelectArea("SY1")
    // -- Compõe filtro de comprador quando MV_FILTNFC = .T.
    if FindFunction("NFCGetFilCom")
        cFilter := NFCGetFilCom('SC1')

        cQuery := "SELECT C1_NUM FROM " + RetSqlName( 'SC1' ) + " WHERE " + cFilter
        Self:lOk := Empty(cFilter) .Or. NFCVldQuery(cQuery)
        
        If !Self:lOk
            Self:nCode := 400
            Self:cMessage := STR0003 //-- Os filtros do comprador logado no sistema são inválidos. Por favor, revise os filtros no Cadastro do comprador, disponível através do botão 'Busca Avançada'.
        EndIf
    endif

    If Self:lOk
        aArea := FwGetArea()
        aQueryRequest := {}
        cWhere := GetWhere(cRequestCode, nRequestType, cFilter)
        oUtils := pgcUtils():New()

        AddMapFields(self, nGroupBy)

        Self:setPage(nPage)
        Self:setPageSize(nPageSize)
        Self:SetQuery(GetQuery(nGroupBy,nRequestType))
        Self:SetWhere(cWhere)
        Self:SetUseSpaces(.T.)

        If nGroupBy == 0
            Self:SetOrder(SqlOrder(SC1->(IndexKey(1))))
        ElseIf nGroupBy == 1
            Self:SetOrder('C1_FILIAL, C1_NUM, C1_SOLICIT')
        ElseIf nGroupBy == 2
            Self:SetOrder('C1_FILIAL, C1_PRODUTO, B1_DESC')
        EndIf

        aQueryRequest := oUtils:queryRequestToArray(oRest:getQueryRequest())

        If Len(aQueryRequest) > 0
            Self:SetUrlFilter(aQueryRequest)
        EndIf

        Self:SetOrderQuery(oUtils:getQueryParam('ORDER'))
        Self:SetFields(oUtils:getQueryParam('FIELDS'))
        
        If Self:Execute()
            Self:FillGetResponse()
            Self:addOthersDataFields(Self:oJsonObj:oJsonObj, nGroupBy)
        EndIf

        FwRestArea(aArea)
        FwFreeArray(aArea)
        FreeObj(oUtils)
    EndIf
Return Nil

/*/{Protheus.doc} AddMapFields
	Cria o Mapa de campos Protheus x API para as solicitações de compra.
@author juan.felipe
@since 02/09/2021
@param oSelf, object, Objeto - Objeto com herança da classe FWAdapterBaseV2.
@param nGroupBy, numeric, 0- Sem agrupamento; 1- Agrupamento por SC; 2- Agrupamento por Produto.
@return Nil, nulo.
/*/
Static Function AddMapFields(oSelf, nGroupBy)

Local aMapFields := {}
Local cFieldType := ''
Local cX3Type    := ''
Local nX         := 1

    if type("aSC1Fields") == "A" .and. len(aSC1Fields) == 0
        aSC1Fields := FWSX3Util():GetAllFields("SC1",.F.)
    endif

    If nGroupBy == 0
        oSelf:AddMapFields('C1_FILIAL'          , 'C1_FILIAL' , .T., .T., {'C1_FILIAL' , 'C', TamSX3('C1_FILIAL' )[1], 0})//branch
        oSelf:AddMapFields('C1_NUM'             , 'C1_NUM'    , .T., .T., {'C1_NUM'    , 'C', TamSX3('C1_NUM'    )[1], 0})//requestCode
        oSelf:AddMapFields('C1_PRODUTO'         , 'C1_PRODUTO', .T., .F., {'C1_PRODUTO', 'C', TamSX3('C1_PRODUTO')[1], 0})//productCode
        oSelf:AddMapFields('C1_ITEM'            , 'C1_ITEM'   , .T., .T., {'C1_ITEM'   , 'C', TamSX3('C1_ITEM'   )[1], 0})//item
        oSelf:AddMapFields('C1_DESCRI'          , 'C1_DESCRI' , .T., .F., {'C1_DESCRI' , 'C', TamSX3('C1_DESCRI' )[1], 0})//productDescription
        oSelf:AddMapFields('B1_GRUPO'           , 'B1_GRUPO'  , .T., .F., {'B1_GRUPO'  , 'C', TamSX3('B1_GRUPO'  )[1], 0})//productGroup
        oSelf:AddMapFields('BM_DESC'            , 'BM_DESC'   , .T., .F., {'BM_DESC'   , 'C', TamSX3('BM_DESC'   )[1], 0})//productGroupDescription
        oSelf:AddMapFields('C1_DATPRF'          , 'C1_DATPRF' , .T., .F., {'C1_DATPRF' , 'C', TamSX3('C1_DATPRF' )[1], 0})//needDate
        oSelf:AddMapFields('C1_UM'              , 'C1_UM'     , .T., .F., {'C1_UM'     , 'C', TamSX3('C1_UM'     )[1], 0})//unity
        oSelf:AddMapFields('C1_QUANT'           , 'C1_QUANT'  , .T., .F., {'C1_QUANT'  , 'N', TamSX3('C1_QUANT'  )[1], 0})//quantity
        oSelf:AddMapFields('C1_OBS'             , 'C1_OBS'    , .T., .F., {'C1_OBS'    , 'C', TamSX3('C1_OBS'    )[1], 0})//comments
        oSelf:AddMapFields('C1_SOLICIT'         , 'C1_SOLICIT', .T., .F., {'C1_SOLICIT', 'C', TamSX3('C1_SOLICIT')[1], 0})//requester
        oSelf:AddMapFields('C1_FILENT'          , 'C1_FILENT' , .T., .F., {'C1_FILENT' , 'C', TamSX3('C1_FILENT' )[1], 0})//requestBranch
        oSelf:AddMapFields('C1_CC'              , 'C1_CC'     , .T., .F., {'C1_CC'     , 'C', TamSX3('C1_CC'     )[1], 0})//costCenter
        oSelf:AddMapFields('C1_CONTA'           , 'C1_CONTA'  , .T., .F., {'C1_CONTA'  , 'C', TamSX3('C1_CONTA'  )[1], 0})//ledgerAccount
        oSelf:AddMapFields('C1_ITEMCTA'         , 'C1_ITEMCTA', .T., .F., {'C1_ITEMCTA', 'C', TamSX3('C1_ITEMCTA')[1], 0})//accountingItem
        oSelf:AddMapFields('C1_CLVL'            , 'C1_CLVL'   , .T., .F., {'C1_CLVL'   , 'C', TamSX3('C1_CLVL'   )[1], 0})//valueClass
        oSelf:AddMapFields('C1_GRADE'           , 'C1_GRADE'  , .T., .F., {'C1_GRADE'  , 'C', TamSX3('C1_GRADE'  )[1], 0})//grid
        oSelf:AddMapFields('C1_ITEMGRD'         , 'C1_ITEMGRD', .T., .F., {'C1_ITEMGRD', 'C', TamSX3('C1_ITEMGRD')[1], 0})//gridItem
        oSelf:AddMapFields('C1_SEGUM'           , 'C1_SEGUM'  , .T., .F., {'C1_SEGUM'  , 'C', TamSX3('C1_SEGUM'  )[1], 0})//secondUnity
        oSelf:AddMapFields('C1_QTSEGUM'         , 'C1_QTSEGUM', .T., .F., {'C1_QTSEGUM', 'N', TamSX3('C1_QTSEGUM')[1], 0})//quantitySecondUnit
        oSelf:AddMapFields('C1_IDENT'           , 'C1_IDENT'  , .T., .F., {'C1_IDENT'  , 'C', TamSX3('C1_IDENT'  )[1], 0})//trackingIdentifier
        oSelf:AddMapFields('AC9_CODENT'         , 'AC9_CODENT', .T., .F., {'AC9_CODENT', 'C', 10, 0}, )//attachmentQuantity
        oSelf:AddMapFields('C1_SCORI'           , 'C1_SCORI'  , .T., .F., {'C1_SCORI'  , 'C', TamSX3('C1_SCORI'  )[1], 0}, )//original purchase centralized

        if type("aSC1Fields") == "A" .and. len(aSC1Fields) > 0
            aMapFields := oSelf:oJsonObj:aMapFields
            for nX := 1 to len(aSC1Fields)
                if aScan(aMapFields,{|x| x[2]==aSC1Fields[nX]}) == 0 .and. GetSx3Cache(aSC1Fields[nX], "X3_BROWSE") == "S"
                    cX3Type := GetSx3Cache(aSC1Fields[nX],"X3_TIPO")
                    If cX3Type != 'M'
                        cFieldType := If(cX3Type == "N", "N", "C")
                        oSelf:AddMapFields(aSC1Fields[nX],aSC1Fields[nX],.T.,.F.,{aSC1Fields[nX],cFieldType,TamSX3(aSC1Fields[nX])[1], 0})
                    EndIf
                endif
            next nX  
        endif 

    ElseIf nGroupBy == 1
        oSelf:AddMapFields('branch'            , 'C1_FILIAL' , .T., .T., {'C1_FILIAL' , 'C', TamSX3('C1_FILIAL' )[1], 0})
        oSelf:AddMapFields('requestCode'       , 'C1_NUM'    , .T., .T., {'C1_NUM'    , 'C', TamSX3('C1_NUM'    )[1], 0})
        oSelf:AddMapFields('requester'         , 'C1_SOLICIT', .T., .F., {'C1_SOLICIT', 'C', TamSX3('C1_SOLICIT')[1], 0})
        oSelf:AddMapFields('emissionDate'      , 'C1_EMISSAO', .T., .F., {'C1_EMISSAO', 'C', TamSX3('C1_EMISSAO')[1], 0})
        oSelf:AddMapFields('requestingUnit'    , 'C1_UNIDREQ', .T., .F., {'C1_UNIDREQ', 'C', TamSX3('C1_UNIDREQ')[1], 0})
        oSelf:AddMapFields('purchaserCode'     , 'C1_CODCOMP', .T., .F., {'C1_CODCOMP', 'C', TamSX3('C1_CODCOMP')[1], 0})
        oSelf:AddMapFields('deliveryBranch'    , 'C1_FILENT' , .T., .F., {'C1_FILENT' , 'C', TamSX3('C1_FILENT' )[1], 0})
    ElseIf nGroupBy == 2
        oSelf:AddMapFields('branch'            , 'C1_FILIAL' , .T., .T., {'C1_FILIAL' , 'C', TamSX3('C1_FILIAL' )[1], 0})
        oSelf:AddMapFields('productCode'       , 'C1_PRODUTO', .T., .T., {'C1_PRODUTO', 'C', TamSX3('C1_PRODUTO')[1], 0})
        oSelf:AddMapFields('productDescription', 'B1_DESC'   , .T., .F., {'B1_DESC'   , 'C', TamSX3('B1_DESC'   )[1], 0})
        oSelf:AddMapFields('productType'       , 'B1_TIPO'   , .T., .F., {'B1_TIPO'   , 'C', TamSX3('B1_TIPO'   )[1], 0})
        oSelf:AddMapFields('unitMeasurement'   , 'B1_UM'     , .T., .F., {'B1_UM'     , 'C', TamSX3('B1_UM'     )[1], 0})
    EndIf
Return Nil

/*/{Protheus.doc} GetQuery
	Monta a expressão SQL para consulta das solicitações de compra.
@author juan.felipe
@since 02/09/2021
@param nGroupBy, numeric, 0- Sem agrupamento; 1- Agrupamento por SC; 2- Agrupamento por Produto.
@param nRequestType, numeric, 1- Em aberto; 2- Parcialmente atendidas; 3- Atendidas; 4-Em aberto todas filiais.
@return cQuery, string, query das solicitações de compra.
/*/
Static Function GetQuery(nGroupBy, nRequestType)
    Local cQuery            As Character
    Local lOracle           As Logical
    Default nGroupBy        := 0
    default nRequestType    := 0
    
    If nGroupBy == 0
        cQuery := " SELECT #QueryFields#"
        cQuery += " FROM " + RetSqlName( 'SC1' ) + " SC1 "
        cQuery += " LEFT JOIN "+ RetSqlName( 'AC9' ) + " AC9"

        lOracle := Upper(Alltrim(TcGetDb())) == "ORACLE"

        If lOracle
            cQuery += " ON AC9.AC9_CODENT = SC1.C1_FILIAL || SC1.C1_NUM || SC1.C1_ITEM"
        Else
            cQuery += " ON AC9.AC9_CODENT = CONCAT(SC1.C1_FILIAL, SC1.C1_NUM, SC1.C1_ITEM)"
        EndIf

        cQuery += "     AND AC9.AC9_ENTIDA = 'SC1'"
        cQuery += "     AND AC9.D_E_L_E_T_ = ' '"
        cQuery += " LEFT JOIN "+ RetSqlName( 'ACB' ) + " ACB"
        cQuery += "     ON ACB.ACB_FILIAL = AC9.AC9_FILIAL"
        cQuery += "     AND ACB.ACB_CODOBJ = AC9.AC9_CODOBJ"
        cQuery += "     AND ACB.D_E_L_E_T_ = ' '"
        cQuery += " INNER JOIN "+ RetSqlName( 'SB1' ) + " SB1"
        cQuery += "     ON SB1.B1_FILIAL = '" + FWxFilial('SB1') + "'"       
        cQuery += "     AND SB1.B1_COD = SC1.C1_PRODUTO"
        cQuery += "     AND SB1.D_E_L_E_T_ = ' '"
        cQuery += " LEFT JOIN "+ RetSqlName( 'SBM' ) + " SBM"
        cQuery += "     ON SBM.BM_FILIAL = '" + FWxFilial('SBM') + "'"
        cQuery += "     AND SBM.BM_GRUPO = SB1.B1_GRUPO"
        cQuery += "     AND SBM.D_E_L_E_T_ = ' '"
        cQuery += " WHERE #QueryWhere#"
        cQuery += " GROUP BY #QueryFields#"
    ElseIf nGroupBy == 1
        cQuery := " SELECT #QueryFields#"
        cQuery += " FROM " + RetSqlName( 'SC1' ) + " SC1 "
        cQuery += " WHERE #QueryWhere#"
        cQuery += " GROUP BY"
        cQuery += "     SC1.C1_FILIAL, SC1.C1_NUM, SC1.C1_SOLICIT, SC1.C1_EMISSAO,"
        cQuery += "     SC1.C1_UNIDREQ, SC1.C1_CODCOMP, SC1.C1_FILENT"
    ElseIf nGroupBy == 2
        cQuery := " SELECT #QueryFields#"
        cQuery += " FROM " + RetSqlName( 'SC1' ) + " SC1 "
        cQuery += " INNER JOIN "+ RetSqlName( 'SB1' ) + " SB1"
        cQuery += "     ON SB1.B1_FILIAL = '" + FWxFilial('SB1') + "'"
        cQuery += "     AND SB1.B1_COD = SC1.C1_PRODUTO"
        cQuery += "     AND SB1.D_E_L_E_T_ = ' '"
        cQuery += " WHERE #QueryWhere#"
        cQuery += " GROUP BY"
        cQuery += "     SC1.C1_FILIAL, SC1.C1_PRODUTO, SB1.B1_DESC,"
        cQuery += "     SB1.B1_TIPO, SB1.B1_UM"
    EndIf
Return cQuery


/*/{Protheus.doc} GetWhere
	Monta a expressão SQL WHERE para consulta das solicitações de compra.
@author juan.felipe
@since 02/09/2021
@param cRequestCode, character, 
@param nRequestType, numeric, 1- Em aberto; 2- Parcialmente atendidas; 3- Atendidas.
@param cFilter, character, filtro do usuário.
@return cQuery, string, expressão where para consulta das solicitações de compra.
/*/
Static Function GetWhere(cRequestCode, nRequestType, cFilter)
    Local cWhere As Character
    Default cRequestCode := ""
    Default nRequestType := 0
    Default cFilter := ""
    
    if nRequestType == 4
        cWhere := " SC1.C1_FILIAL <> '" + FWxFilial('SC1') + "' " //Não exibir os itens da filial corrente
    else
        cWhere := " SC1.C1_FILIAL = '" + FWxFilial('SC1') + "' "
    endif

    If !Empty(cRequestCode)
        cWhere += "AND SC1.C1_NUM = '"+ cRequestCode +"' "
    ElseIf nRequestType == 1
        cWhere += "AND SC1.C1_QUJE = 0 AND SC1.C1_COTACAO = ' ' AND SC1.C1_RESIDUO = ' ' AND SC1.C1_QUANT > 0 " 
    ElseIf nRequestType == 2
        cWhere += "AND SC1.C1_QUJE > 0 AND SC1.C1_QUJE < SC1.C1_QUANT "
    ElseIf nRequestType == 3
        cWhere += "AND SC1.C1_QUJE = SC1.C1_QUANT "
    EndIf
        
    If Empty(cRequestCode) .And. nRequestType > 0
        cWhere += "AND (SC1.C1_APROV = 'L' OR SC1.C1_APROV = ' ') "
        cWhere += "AND SC1.C1_TPSC <> '2' AND SC1.C1_FLAGGCT <> '1' "
    EndIf

    cWhere += "AND SC1.D_E_L_E_T_ = ' '"

    if nRequestType == 4
        cWhere += " AND SC1.C1_IMPORT <> 'S' AND SC1.C1_SCORI = ' ' AND SC1.C1_QUJE = 0 AND SC1.C1_QUANT > 0"
    endif

    // -- Filtro de usuário
    if !empty(cFilter)
        cWhere += " AND " + cFilter
    endif

Return cWhere

/*/{Protheus.doc} postCheckOpen
	Metodo responsavel por validar regras de consulta de solicitações de compra
@author juan.felipe
@since 14/02/2022
@param oJsonRequests, object, objeto json com os dados das solicitações.
@return oJsonResponse, object, objeto json com os dados das solicitações.
/*/
Method postCheckOpen(oJsonRequests) Class pgcSyncPurchaseRequestRepository
    Local aItems            As Array
    Local aItemsRequests    As Array
    Local aAreas            As Array
    Local cRequestCode      As Character
    Local cItem             As Character
    Local lHasInvalidItem   As Logical
    Local lIsOpen           As Logical
    Local cGridItem         As Character
    Local oJsonRet          As Object
    Local oUtils            As Object
    Local nX                As Numeric
    Local nY                As Numeric
    local cBranch           as character
    Private lMsErroAuto := .F.
    Private lMsHelpAuto := .T.
    Private lAutoErrNoFile := .T.

    Self:lOk := .T.

    aAreas := {SC1->(GetArea()), GetArea()}
    aItems := oJsonRequests["items"]
    aItemsRequests := {}
    lHasInvalidItem := .F.
    oJsonRet := JsonObject():New()
    oUtils := pgcUtils():New()

	A131SetPGC(.T., Nil)
    
    SC1->(dbSetOrder(1))

    For nX := 1 To Len(aItems)
        aItemsRequests := aItems[nX]["purchaserequests"]
        lHasInvalidItem := .F.

        For nY := 1 To Len(aItemsRequests)
            cRequestCode := PadR(aItemsRequests[nY]['c1_num'], Len(SC1->C1_NUM), " ")
            cItem := aItemsRequests[nY]["c1_item"]
            cGridItem := aItemsRequests[nY]["c1_itemgrd"]
            if ( aItemsRequests[nY]['c1_filial'] == aItemsRequests[nY]['c1_filent'] )
                cBranch := FWxFilial('SC1')
            else
                //Se diferente, veio da compra centralizada
                cBranch := aItemsRequests[nY]["c1_filial"]
            endif

            If SC1->(MsSeek( cBranch + cRequestCode + cItem + cGridItem))
                MSExecAuto({|| A131VlItCot()}) //-- Executa função de validação com ExecAuto para ser possível obeter as mensagens de help
                
                lIsOpen := !lMsErroAuto
                
                aItemsRequests[nY]["isopen"] := lIsOpen //-- Caso a SC esteja em aberto atribui .T. a propriedade isopen
                aItemsRequests[nY]["errormessage"] := IIf(!lIsOpen, oUtils:getMessageExecAuto(), "")

                If !lIsOpen .And. !lHasInvalidItem
                    lHasInvalidItem := .T.
                EndIf

                lMsErroAuto := .F. //-- Limpa erro do execAuto
            Else
                aItemsRequests[nY]["isopen"] := .F.
                aItemsRequests[nY]["errormessage"] := STR0002 //-- Este item de solicitação de compra não foi localizado na base de dados.

                If !lHasInvalidItem
                    lHasInvalidItem := .T.
                EndIf
            EndIf
        Next nY
        
        aItems[nX]["hasinvaliditem"] := lHasInvalidItem
    Next nX

    oJsonRet := oJsonRequests

    aEval(aAreas, {|x| RestArea(x), FwFreeArray(x) })
    FreeObj(oUtils)
Return oJsonRet

/*/{Protheus.doc} addOthersDataFields
	Adiciona dados complementares ao JSON de resposta.
@author juan.felipe
@since 01/10/2025
@param oJsonResponse, object, JSON que receberá a propriedade.
@return Nil, nulo.
/*/
Method addOthersDataFields(oJsonResponse, nGroupBy) Class pgcSyncPurchaseRequestRepository
    Local aItems        := {}                 As Array
    Local nX            := 0                  As Numeric
    Default oJsonResponse := Nil
    Default nGroupBy     := 0

    If oJsonResponse <> Nil .And. oJsonResponse:hasProperty('items') .And. nGroupBy == 0
        aItems := oJsonResponse['items']

        For nX := 1 To Len(aItems)
            aItems[nX]['c1_descri'] := NFCProdDesc(aItems[nX]['c1_produto'], aItems[nX]['c1_num'], aItems[nX]['c1_item'])
        Next nX
    EndIf
Return Nil
