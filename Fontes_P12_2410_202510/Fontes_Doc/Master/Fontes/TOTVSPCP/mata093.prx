#INCLUDE "MATA093.CH"
#INCLUDE "PROTHEUS.CH"
#INCLUDE "DBTREE.CH"
#INCLUDE 'FWMVCDEF.CH'

#DEFINE nMaxLaCols 999
#DEFINE MAXGETDAD 999

Static __aPrepared  := {}
/*/


Ŀ
Descrio  PLANO DE MELHORIA CONTINUA                                 
Ĵ
ITEM PMC   Responsavel               Data         |BOPS:             
Ĵ
      01  Erike Yuri da Silva       24/02/2006    |00000092611       
      02  Erike Yuri da Silva       08/12/2005    |                  
      03  Erike Yuri da Silva       02/03/2006    |00000094150       
      04  Erike Yuri da Silva       10/01/2006    |00000079876       
      05  Erike Yuri da Silva       25/01/2006    |00000091944       
      06  Erike Yuri da Silva       25/01/2006    |00000091944       
      07  Erike Yuri da Silva       02/03/2006    |00000094150       
      08  Erike Yuri da Silva        24/02/2006   |00000092611       
      09  Erike Yuri da Silva        08/12/2005   |                  
      10  Erike Yuri da Silva        10/01/2005   |00000079876       
ٱ




Ŀ
Funo     MATA093   Autor  Marcelo Iuspa          Data  26.04.2002 
Ĵ
Descrio  Configurador de Produtos                                     
Ĵ
 Uso       Generico                                                     
Ĵ
 ATUALIZACOES SOFRIDAS DESDE A CONSTRUCAO INICIAL.                       
Ĵ
 PROGRAMADOR   DATA    BOPS   MOTIVO DA ALTERACAO                     
Ĵ
Iuspa         27/06/01                                                
ٱ


*/
Function MATA093()
PRIVATE aProd       := {}
PRIVATE aRotina     := MenuDef()
PRIVATE cCadastro	:= STR0011	 //"Configurador de Produtos"
PRIVATE lCombo      := .F.
PRIVATE lCopia		:= .F.

PERGUNTE("MTA093",.F.)

Set Key VK_F12 TO MT093Perg()

mBrowse(6,1,22,75,"SBP")

Return

/*

Ŀ
Funo    A093CadSBP    Autor Marcelo Iuspa        Data  27/04/02 
Ĵ
Descrio Cadastramento do Configurador de Produtos                   
Ĵ
Sintaxe   A093CadSBP                                                  
Ĵ
 Uso      MATA093                                                     
 ٱ


*/
Function A093CadSBP(cAlias, nReg, nOpcx)
Local oDlg
Local cQuery  := ""
Local lWhen   := If(nOpcx == 4, SBP->BP_DISPUSO # "1", nOpcx = 3)
LOCAL aSize   :={}
LOCAL aInfo   :={}
LOCAL aObjects:={}
LOCAL aPosObj :={}
Local nField  := 0
Local nOpc    := 0
Local aAcho   := A610CriaHeader("SBP", If(nOpcx == 3, "", "BP_BASE") + ", BP_ESTCOD", .T.)
Local aCpo    := A610CriaHeader("SBP", "BP_ESTCOD  ", .T.)
Local oEnchoice
Private cMascara := ""
Private aTela[0][0], aGets[0]

RegToMemory("SBP", nOpcx == 3)
aHeader   := A610CriaHeader("SBQ", "BQ_BASE, BQ_CONJUNT, BQ_DEPENDE, BQ_TIPDEF, BQ_INICIO, BQ_INTATE, BQ_INTDE, BQ_INTSTEP",, .T./*lWalkThru*/ )
If lCopia  //Utilizado somente em inclusoes que sao copias
	For nField := 1 TO FCount()
		M->&(SBP->(FieldName(nField))):=aFldsAnt[nField]
	Next
	M->BP_BASE		:= cBaseDest	//Altera a variavel de memoria com o Codigo base a ser gerado
	M->BP_DISPUSO	:= "2"			//Sempre indisponibiliza para uso
	//Carrega as informacoes do aCols com os dados do codigo de origem
	aCriaCols		:= A610CriaCols("SBQ", aHeader, xFilial("SBQ") + cBaseOrig, {|| SBQ->BQ_FILIAL + SBQ->BQ_BASE == xFilial("SBQ") + cBaseOrig})
	aCriaCols[2]	:= {}			// Zera array de indice 2 pois o mesmo so eh usado na alteracao
Else
	aCriaCols := A610CriaCols("SBQ", aHeader, xFilial("SBQ") + M->BP_BASE, {|| SBQ->BQ_FILIAL + SBQ->BQ_BASE == xFilial("SBQ") + M->BP_BASE})
EndIf

aCols     := ACLONE(aCriaCols[1])
aColsReg  := ACLONE(aCriaCols[2])

If Len(aColsReg) == 0 // nOpcx == 3 .And. Len(aColsReg) == 0
	GDFieldPut("BQ_ITEM", StrZero(1, Len(SBQ->BQ_ITEM)), 1)
Endif

Aadd(aObjects,{100,190,.T.,.T.,.F.}) // Indica dimensoes x e y e indica que redimensiona x e y e assume que retorno sera em linha final coluna final (.F.)
Aadd(aObjects,{100,300,.T.,.T.,.F.}) // Indica dimensoes x e y e indica que redimensiona x e y
Aadd(aObjects,{ 10, 10,.F.,.F.,.F.}) // Indica dimensoes x e y e indica que redimensiona x e y
aSize:=MsAdvSize()
aInfo:={aSize[1],aSize[2],aSize[3],aSize[4],3,3}
aPosObj:=MsObjSize(aInfo,aObjects,.T.)

DEFINE MSDIALOG oDlg TITLE OemToAnsi(cCadastro) From aSize[7],0 TO aSize[6],aSize[5] OF oMainWnd PIXEL

oEnchoice := Msmget():New("SBP" , nReg, nOpcx,,,,aCpo,aPosObj[1],aAcho,,,,,oDlg,, .F.)

oGet:= MSGetDados():New(aPosObj[2,1],aPosObj[2,2],aPosObj[2,3],aPosObj[2,4],If(lWhen, 3,1),"A093LINOK","A093TUDOK","+BQ_ITEM",lWhen,,,,,"A093FILOK")
oGet:oBrowse:bDelete := {|| A093DelSBQ()}

@ aPosObj[3,1],aPosObj[3,2] Say   oSayMasc Prompt STR0012  Size 70, 6 Of oDlg Pixel //"Composio da Mascara:"
@ aPosObj[3,1],aPosObj[3,2]+074 MsGet oGetMasc Var M->cMascara Size 100,5 Of oDlg Pixel When .F.

A093Masc()

ACTIVATE MSDIALOG oDlg ON INIT ( EnchoiceBar(oDlg,{||If(Obrigatorio(aGets, aTela) .And. oGet:TudoOk().And.A093BtnOk(nOpcx),(nOpc:=1,oDlg:End()),nOpc:=0)},{||nOpc:=0,oDlg:End()}))

If nOpc == 1
	Begin Transaction
		A093GrvSBP(nOpcX,aCols, aHeader, aColsReg)
	End Transaction
EndIf

dbSelectArea("SBP")
Return (nOpc == 1)

/*

Ŀ
Funo    A093DelSBQ    Autor Marcelo Iuspa        Data  14/06/02 
Ĵ
Descrio Valida/Executa delecao do aCols ref. SBQ                    
          Nao permite deletar se ja existe cadastramento de itens da  
          caracteristica que esta sendo deletada                      
Ĵ
Sintaxe   A093DelSBQ                                                  
Ĵ
 Uso      MATA093                                                     
ٱ


*/
Function A093DelSBQ()
Local cID  := GDFieldGet("BQ_ID")
Local nPosCar := aScan(aHeader, {|z| z[2] == "BQ_CARACT" })
Local nPosID  := aScan(aHeader, {|z| z[2] == "BQ_ID"     })
Local nPosPri := aScan(aHeader, {|z| z[2] == "BQ_PRISEC" })
Local nPosIte := aScan(aHeader, {|z| z[2] == "BQ_ITEM"   })
Local cCar, cItem, x, y, aCont, z := 0
Local lRet	:= .T.

If ! A093TamMax(.T.)
	lRet := .F.
Endif

If lRet .And. SBS->(dbSeek(xFilial("SBS") + M->BP_BASE + cID)) .And. ! Atail(aCols[n])
	HELP(" ",1,"A093NDEL")
	lRet := .F.
Endif

If lRet .And. SBP->BP_DISPUSO = '1'
	lRet := .F.
EndIf

If lRet
	aCont := {	{nPosCar, cCar }, ;
		{nPosID , cID  }, ;
		{nPosIte, cItem }}

	cCar := aCols[n, nPosCar]
	cItem:= aCols[n, nPosIte]

	For x := 1 to Len(aCols)
		If ! x == n .And. Atail(aCols[n])
			For z := 1 to Len(aCont)
				If aCols[x, aCont[z, 1]] == aCont[z, 2]
					Help(" ",1,"A093IDJA",, AllTrim(RetTitle(aHeader[aCont[z, 1], 2])) + " :  " + Transform(aCont[z, 2], ""), 2, 0)
					lRet := .F.
					Exit
				Endif
			Next
		Endif
		If !lRet
			Exit
		EndIf
	Next
EndIf
If lRet
	Atail(aCols[n]) := ! Atail(aCols[n])
	oGet:oBrowse:Refresh()
EndIf
Return lRet

/*

Ŀ
Funo    A093LinOk     Autor Marcelo Iuspa        Data  26/04/02 
Ĵ
Descrio Validacao de linha na GetDados                              
Ĵ
 Uso      MATA093                                                     
ٱ


*/
Function A093LINOK()
Local nPosPri := aScan(aHeader, {|z| z[2] == "BQ_PRISEC"})
Local nPosTam := aScan(aHeader, {|z| z[2] == "BQ_TAMANHO"})
Local nPosTpGr:= aScan(aHeader, {|z| z[2] == "BQ_TPGRD"})
Local nQuaPri := 0
Local nQtdCol := 0
Local nQtdLin := 0
Local x
Local lRet	:= .T.
Static aObr
If aObr == Nil
	aObr := {	GDFieldPos("BQ_ID"     ) , ;
		GDFieldPos("BQ_ITEM"   ) , ;
		GDFieldPos("BQ_CARACT" ) , ;
		GDFieldPos("BQ_TAMANHO") , ;
		GDFieldPos("BQ_DESCR"  ) , ;
		GDFieldPos("BQ_PRISEC" ) }

	If SBQ->(FieldPos("BQ_TPGRD")) > 0
		Aadd(aObr,GDFieldPos("BQ_TPGRD"))
	EndIf
Endif
For x := 1 to Len(aObr)
	If Empty(aCols[n, aObr[x]]) .And. ! Atail(aCols[n])
		Help(" ",1,"OBRIGAT2",, AllTrim(RetTitle(aHeader[aObr[x], 2])), 3, 0)
		lRet := .F.
		Exit
	Endif
Next
If lRet
	aEval(aCols, {|z| If(z[nPosPri] == "1" .And. ! Atail(z), nQuaPri ++,)})
	If nQuaPri > 1
		HELP(" ",1,"A093PRIMA")
		lRet := .F.
	Endif
EndIf


//Ŀ
//Executa a validacao da interface de grade
//
If lRet.And. !Empty(nPosTpGr)
	If (aCols[1,nPosTpGr] $ "12")
		//Nao pode ser informada interface de grade no incio das caracteristicas do produto
		HELP(" ",1,"A093GRD001")
		lRet := .F.
	EndIf

	x := 0
	If lRet .And. ! Atail(aCols[n])
		aEval(aCols, {|z| If(! Atail(z),x++,) , If(z[nPosTpGr] == "1" .And. ! Atail(z), nQtdLin++,If(z[nPosTpGr] == "2" .And. ! Atail(z),nQtdCol++,))})
		DO CASE
			CASE nQtdLin > 1 .Or. nQtdCol > 1
				// Apenas um dos itens podera ser definido como interface de grade linha ou coluna
				HELP(" ",1,"A093GRD002")
				lRet := .F.
			CASE nQtdLin == 0 .And. nQtdCol == 1
				//Ŀ
				//Nao permite incluir uma interface de grade coluna se nao existir    
				//uma interface grade do tipo linha.                                  
				//Atencao: esta validacao nao foi incluido no A093FilOk por problemas 
				//         encontrados no objeto getdados na epoca.                   
				//
				// No  permitida a incluso de uma interface de grade coluna sem a existncia de uma interface de grade linha.
				HELP(" ",1,"A093GRD003")
				lRet := .F.
			CASE nQtdLin == 1 .And. nQtdCol == 0 .And. ( !(aCols[n,nPosTpGr]$"12") .Or. x == 1)
				// No pode ser definida interface de grade linha sem definir coluna, e vice versa
				HELP(" ",1,"A093GRD004")
				lRet := .F.
			CASE nQtdLin == 1 .And. nQtdCol == 1
				nQtdLin := AsCan(aCols,{|z| z[nPosTpGr]=="1" })
				nQtdCol := AsCan(aCols,{|z| z[nPosTpGr]=="2" })
				If nQtdLin > nQtdCol
					// No pode ser definida interface de grade coluna antes da definicao de interface grade linha
					HELP(" ",1,"A093GRD008")
					lRet := .F.
				EndIf
				If lRet
					x := 0
					aEval(aCols, {|z| If(! Atail(z),x++,) })
					If !(aCols[x,nPosTpGr]$"12")
						//No deve ser informada nenhuma caracterstica ou expresso "entre" ou "aps" uma caracterstica interface grade.
						HELP(" ",1,"A093GRD010")
						lRet := .F.
					ElseIf (x == 2)
						//Nao pode ser informada interface de grade no incio das caracteristicas do produto
						HELP(" ",1,"A093GRD001")
						lRet := .F.
					EndIf
				EndIf
		ENDCASE
	EndIf
EndIf
Return lRet

/*

Ŀ
Funo    A093TudOk     Autor Marcelo Iuspa        Data  26/04/02 
Ĵ
Descrio Validacao TudoOk na GetDados                                
Ĵ
 Uso      MATA093                                                     
ٱ


*/
Function A093TUDOK()
Local nPosTpGr	:= aScan(aHeader, {|z| z[2] == "BQ_TPGRD"})
Local nQtdCol	:= 0
Local nQtdLin 	:= 0
Local nAux
Local lRet		:= .T.

//Ŀ
//Verifica se a definicao da interface de grade esta ativa, e se foi preen
//chida corretamente.                                                     
//
If !Empty(nPosTpGr) .And. MaGrade()
	nPosLin := AsCan(aCols,{|x|x[nPosTpGr]=="1" })
	nPosCol := AsCan(aCols,{|x|x[nPosTpGr]=="2" })
	If (!Empty(nPosLin) .And. Empty(nPosCol)) .Or. (Empty(nPosLin) .And. !Empty(nPosCol))
		// No pode ser definida interface de grade linha sem definir coluna, e vice versa
		HELP(" ",1,"A093GRD004")
		lRet := .F.
	Endif

	If lRet .And. (!Empty(nPosLin) .Or. !Empty(nPosCol))
		nAux := 0
		aEval(aCols, {|z| If(! Atail(z),nAux++,) })
		If (nAux == 2)
			//Nao pode ser informada interface de grade no incio das caracteristicas do produto
			HELP(" ",1,"A093GRD001")
			lRet := .F.
		EndIf
	EndIf
EndIf

Return (lRet)

/*

Ŀ
Funo    A093LinOk2    Autor Marcelo Iuspa        Data  26/04/02 
Ĵ
Descrio Validacao de linha na GetDados                              
Ĵ
 Uso      MATA093                                                     
ٱ


*/
Function A093LINOK2()
Return(.T.)

/*

Ŀ
Funo    A093TudOk2    Autor Marcelo Iuspa        Data  26/04/02 
Ĵ
Descrio Validacao TudoOk na GetDados                                
Ĵ
 Uso      MATA093                                                     
ٱ


*/
Function A093TUDOK2()
Return(.T.)

/*

Ŀ
Funo    A093LinOk3    Autor Marcelo Iuspa        Data  26/04/02 
Ĵ
Descrio Validacao de linha na GetDados                              
Ĵ
 Uso      MATA093                                                     
ٱ


*/
Function A093LINOK3()
Local nI
Local lRet
Local nComp	:= aScan(oGet2:aHeader, {|z| AllTrim(z[2]) == "BU_COMP"})
Local nTRT	:= aScan(oGet2:aHeader, {|z| AllTrim(z[2]) == "BU_TRT"})
Local aSeq:={},nAchoSeq:=0

If Type('aCols')=='U'
	aCols 	:= aClone(oGet2:aCols)
	aHeader	:= aClone(oGet2:aHeader)
	n       := oGet2:oBrowse:nAt
EndIf

lRet  := A093NaoVazio({"BU_QUANT", "BU_INI", "BU_FIM"}, {|| ! Empty(GDFieldGet("BU_COMP",, .T.))},oGet2:oBrowse:nAt)

If lRet
	For nI:=1 To Len(oGet2:aCols)
		If !oGet2:aCols[nI,Len(oGet2:aCols[nI])]
			//Ŀ
			// Verifica se ja existe esta sequencia  
			//
			nAchoSeq:=ASCAN(aSeq,oGet2:aCols[nI,nComp]+If(Empty(nTRT),"",oGet2:aCols[nI,nTRT]) )
			If nAchoSeq > 0
				Aviso(STR0042,STR0043,{"Ok"}) //"Aviso"###"Ja existe esta chave nos dados informados"
				lRet:=.F.
				Exit
			Else
				AADD(aSeq,oGet2:aCols[nI,nComp]+If(Empty(nTRT),"",oGet2:aCols[nI,nTRT]) )
			Endif
		EndIf
	Next nI
EndIf
Return ( lRet )

/*

Ŀ
Funo    A093TudOk3    Autor Marcelo Iuspa        Data  26/04/02 
Ĵ
Descrio Validacao TudoOk na GetDados                                
Ĵ
 Uso      MATA093                                                     
ٱ


*/
Function A093TUDOK3()
Return(.T.)

/*

Ŀ
Funo    A093BTNOk     Autor Marcelo Iuspa        Data  29/04/02 
Ĵ
Descrio Validacao do boto de confirmacao na dialog                 
Ĵ
 Uso      MATA093                                                     
ٱ


*/
Function A093BtnOk(nOpcx)
Local nTamCod   := Len(AllTrim(M->BP_BASE))
Local nPosTam   := aScan(aHeader, {|z| z[2] == "BQ_TAMANHO"})
Local nPosCar   := aScan(aHeader, {|z| z[2] == "BQ_CARACT" })
Local nPosID    := aScan(aHeader, {|z| z[2] == "BQ_ID"     })
Local cID       := GDFieldGet("BQ_ID")
Local x
Local lRet    	:= .T.
Local lContinua := .T.
Local cQuery	:= ""
Local cAliasQry := GetNextAlias()

If nOpcx == 10
	cQuery := " SELECT DISTINCT SB1.B1_BASE " +;
                " FROM " + RetSqlName("SB1") + " SB1 " +;
               " WHERE SB1.B1_FILIAL  = '" + xFilial("SB1") + "' " +;
			     " AND SB1.B1_BASE    = '" + M->BP_BASE + "' " +;
                 " AND SB1.D_E_L_E_T_ = ' ' "
	cQuery := ChangeQuery(cQuery)

	dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasQry,.T.,.T.)

	IF !(cAliasQry)->(EOF()) .Or.;
    	(SBS->(dbSeek(xFilial("SBS") + M->BP_BASE + cID)) .And. ! Atail(aCols[n]))
		HELP(" ",1,"A093NDEL")
		lRet:=.F.
	Else
		If 	SBT->(dbSeek(xFilial("SBT") + SBP->BP_BASE)) .Or. ;
			SBU->(dbSeek(xFilial("SBU") + SBP->BP_BASE))
			lRet := Aviso(STR0042,STR0051,{STR0052,STR0053}) == 1 // "Aviso"###"J existem itens cadastrados para esta  caracteristica. Deseja deletar os cadastros relacionadas a esta famlia de produtos?" ### "Sim" ### "No"
		EndIf
		lContinua := .F.
	EndIf

	(cAliasQry)->(DbCloseArea())

EndIf

If lContinua .And. lRet
	aEval(aCols, {|z| nTamCod += If(Atail(z), 0, z[nPosTam])})
	If ! (lRet := nTamCod <= Len(SB1->B1_COD))
		Help(" ",1,"A093TAMAN")
	EndIf
	If lRet .And. M->BP_DISPUSO == "1" // Checar se os dados estao ok para inicio de utilizacao
		If ! (lRet := SBR->(dbSeek(xFilial("SBR") + M->BP_BASE)))
			Help(" ",1,"A093PADRAO")
		Else
			For x := 1 to Len(aCols)
				If ! Atail(aCols[x])
					cID := aCols[x, nPosID]
					If Len(A093Opc(M->BP_BASE, cId, .F., .T.)) == 0
						lRet := .F.
						Exit
					EndIf
				EndIf
			Next
		EndIf
		If M->BP_CODPAD == "2"
			dbSelectArea("SBQ")
			dbSeek(xFilial("SBQ") + M->BP_BASE)
			While ! Eof() .And. SBQ->(BQ_FILIAL + BQ_BASE) == xFilial("SBQ") + M->BP_BASE
				If SBQ->BQ_INICIO == 0 .And. lRet
					lRet := .F.
					Help(" ",1,"A093ERRCOD")
				EndIf
				dbSkip()
			End
		EndIf
	EndIf
EndIf
Return(lRet)

/*

Ŀ
Funo    A093FilOk     Autor Marcelo Iuspa        Data  13/06/02 
Ĵ
Descrio Validacao dos campos da GetDados                            
Ĵ
 Uso      MATA093                                                     
ٱ


*/
Function A093FilOk()
Local nPosTam := aScan(aHeader, {|z| z[2] == "BQ_TAMANHO"})
Local nPosCar := aScan(aHeader, {|z| z[2] == "BQ_CARACT" })
Local nPosID  := aScan(aHeader, {|z| z[2] == "BQ_ID"     })
Local nPosPri := aScan(aHeader, {|z| z[2] == "BQ_PRISEC" })
Local nPosIte := aScan(aHeader, {|z| z[2] == "BQ_ITEM"   })
Local cReadVar:= StrTran(ReadVar(), "M->", "")
Local nTam, cCar, cID, cPri, cItem, cCam
Local nMax := Len(AllTrim(M->BP_BASE))
Local x
Local lContinua := .T.
Local lRet		:= .T.

If cReadVar == "BQ_MASCARA"
	lRet := A093Masc()
	lContinua	:= .F.
Endif

If lContinua .And. Altera .And. ReadVar() $ "M->BQ_TAMANHO"
	If Len(aColsReg) >= n
		SBQ->( DbGoto(aColsReg[n] ) )
		If SBQ->BQ_TIPDEF == '3' .And. M->BQ_TAMANHO < Len(Alltrim(Str(SBQ->BQ_INTATE)))
			Aviso(STR0042,STR0055,{"Ok"}) //"Aviso"##"Item possui codificao por intervalo. O tamanho definido  inferior ao ltimo cdigo do intervalo !!"
			lRet      := .F.
			lContinua := .F.
		EndIf
	EndIf
EndIf

If lContinua .And. !(cReadVar $ "BQ_ITEM; BQ_TAMANHO; BQ_CARACT; BQ_ID; BQ_PRISEC")
	lContinua := .F.
Endif

If lContinua
	nTam := If(cReadVar == "BQ_TAMANHO", &(ReadVar()), aCols[n, nPosTam])
	cCar := If(cReadVar == "BQ_CARACT" , &(ReadVar()), aCols[n, nPosCar])
	cID  := If(cReadVar == "BQ_ID"     , &(ReadVar()), aCols[n, nPosID ])
	cItem:= If(cReadVar == "BQ_ITEM"   , &(ReadVar()), aCols[n, nPosIte])
	cPri := If(cReadVar == "BQ_PRISEC" , &(ReadVar()), aCols[n, nPosPri])

	If cReadVar == "BQ_PRISEC" .And. cPri # aCols[n, nPosPri]
		If SBT->(dbSeek(xFilial("SBT") + M->BP_BASE)) .Or. SBU->(dbSeek(xFilial("SBU") + M->BP_BASE))
			Help(" ",1,"A093SBTCAD")
			lRet := .F.
		Endif
	Endif

	If lRet .And. cReadVar == "BQ_TAMANHO" .And. nTam > Len(SBS->BS_CODIGO)
		Help(" ",1,"A093TAMSBS",, AllTrim(Str(Len(SBS->BS_CODIGO))), 4, 0)
		lRet := .F.
	Endif

	If lRet .And. cReadVar == "BQ_ID"
		If "-" $ cId .Or. "+" $ cId .Or. "/" $ cId .Or. "*" $ cId .Or. "=" $ cId .Or. " " $ AllTrim(cId)
			Help(" ",1,"A093IDCAR",, RetTitle("BQ_ID"), 4, 0)
			lRet := .F.
		Endif
	Endif

	If lRet
		nMax += nTam
		cCam := &(ReadVar())
		For x := 1 to Len(aCols)
			If ! x == n .And. ! aCols[x, Len(aHeader)+1]
				nMax += aCols[x, nPosTam]
				If aCols[x, nPosCar] == cCar .Or. ;
						aCols[x, nPosID ] == cID  .Or. ;
						aCols[x, nPosIte] == cItem
					Help(" ",1,"A093IDJA",, AllTrim(RetTitle(cReadVar)) + " :  " + Transform(cCam, ""), 2, 0)
					lRet := .F.
					Exit
				Endif
			Endif
		Next
	EndIf

	If lRet .And. nMax > Len(SB1->B1_COD)
		Help(" ",1,"A093TAMAN")
		lRet := .F.
	Endif

	If lRet .And. (cReadVar $ "BQ_TAMANHO; BQ_ID")
		If SBS->(dbSeek(xFilial("SBS") + M->BP_BASE + aCols[n, nPosID])) .And. (cReadVar # "BQ_ID" .Or. ! cID == aCols[n, nPosID])
			Help(" ",1,"A093ITECAD")
			lRet := .F.
		Endif
	Endif
EndIf
Return lRet

/*

Ŀ
Funo    A093TamMax    Autor Marcelo Iuspa        Data  08/09/02 
Ĵ
Descrio Validacao de validacao do tamanho maximo do codigo final    
Ĵ
 Uso      MATA093                                                     
ٱ


*/
Function A093TamMax(lDel)
Local nTamCod := Len(AllTrim(M->BP_BASE))
Local lRet    := .T.
nTamCod += If(lDel # Nil .And. lDel .And. Atail(aCols[n]), GDFieldGet("BQ_TAMANHO", , .T.), 0)
aEval(aCols, {|z, w| nTamCod += If(Atail(z), 0, GDFieldGet("BQ_TAMANHO", w, .T.))})
If ! (lRet := nTamCod <= Len(SB1->B1_COD))
	Help(" ",1,"A093TAMAN")
Endif
Return(lRet)

/*

Ŀ
Funo    A093Masc      Autor Marcelo Iuspa        Data  29/04/02 
Ĵ
Descrio Concatena a mascara                                         
Ĵ
 Uso      MATA093                                                     
ٱ


*/
Function A093Masc
Local x
Local lRet	:= .T.
cMascara := AllTrim(M->BP_MASCARA)

If ReadVar() $ "M->BP_MASCARA; M->BP_BASE"
	If ! Empty(M->BP_BASE) .And. ! Empty(M->BP_MASCARA)
		If Empty(Transform(M->BP_BASE, AllTrim(M->BP_MASCARA)))
			Help(" ",1,"A093MASC")
			lRet := .F.
		Endif
	Endif
Endif

If lRet .And. Altera .And. ReadVar() $ "M->BQ_MASCARA"
	If Len(aColsReg) >= n
		SBQ->( DbGoto(aColsReg[n] ) )
		If SBQ->BQ_TIPDEF == '3' .And. ( !("9" $ M->BQ_MASCARA) .Or. "*" $ Transform(SBQ->BQ_INTATE, AllTrim(M->BQ_MASCARA)) )
			Help(" ",1,"A093MASC")
			lRet := .F.
		EndIf
	EndIf
EndIf

If lRet
	For x := 1 to Len(aCols)
		If ! aCols[x, Len(aCols[x])]
			cMascara += AllTrim(GDFieldGet("BQ_MASCARA", x, .T.))
		Endif
	Next
	oGetMasc:Refresh()
EndIf
Return lRet

/*


Ŀ
 Funo     A093Cargo                                                  
Ĵ
 Autor      Marcelo Antonio Iuspa                     Data  30.04.02 
Ĵ
 Descrio  Posiciona no alias/recno de acordo com CARGO               
Ĵ
  Uso       SigaPCP  Advanced                                         
ٱ


*/
Function A093GoCargo(cAlias1)
Local cCargo := oTree:GetCargo()
Local cAlias := Left(cCargo, 3)
Local nRecno := Val(SubStr(cCargo, 4, 12))
Local lRet   := .F.
(cAlias)->(dbGoto(nRecNo))
If (lRet := cAlias1 # Nil .And. Upper(cAlias) $ Upper(cAlias1) .And. nRecNo # 0)
	SBQ->(dbGoto(Val(Substr(cCargo, 16, 12))))
Endif
Return(lRet)

/*

Ŀ
Funo    A093ConSBP    Autor Marcelo Iuspa        Data  02/05/02 
Ĵ
Descrio Configura regras e estrutura                                
Ĵ
 Uso      MATA093                                                     
ٱ


*/
Function A093ConSBP(cAlias, nReg, nOpcx)
Local nTop     := oMainWnd:nTop+100
Local nLeft    := oMainWnd:nLeft+5
Local nBottom  := oMainWnd:nBottom-35
Local nRight   := oMainWnd:nRight-10
Local aColBut  := {}
Local nLinBut  := 0
Local aID      := {}
Local x        := 0
Local cPrima   := RetTitle("BQ_CARACT")
Local cCombo1  := ""
Local cCombo2  := ""
Local lOk      := .F.
Local lContinua:= .T.
Local cGrava   := ""
Local aSavAre  := SaveArea1({"SBQ", "SBR", "SBS", "SBT", "SBU"})
Local l800x600 := oMainWnd:nClientWidth <= 800 //variavel para posicionamento dos Objetos de acordo com resolucao do video

Private oButton931
Private oButton932
Private aPrima   := {{},{}}
Private aSavCol  := {}
Private aData093C:= {}
Private aHeaSBT  := {}
Private aHeaSBU  := {}
Private aColSBT  := {}
Private aColSBU  := {}
Private aConSav  := {}


aHeaSBT := apBuildHeader("SBT",{"BT_BASE", "BT_IDC1", "BT_IDC2"})
aHeaSBU := apBuildHeader("SBU",{"BU_BASE", "BU_IDC1", "BU_IDC2"})

dbSelectArea("SBQ")
dbSetOrder(1)
dbSeek(xFilial("SBQ") + SBP->BP_BASE)
Aadd(aId, Space(Len(SBQ->BQ_ID + SBS->BS_CODIGO)))
Aadd(aPrima[1], 0)
Aadd(aPrima[2], STR0022) //"Todos"
do While ! Eof() .And. BQ_FILIAL + BQ_BASE == xFilial("SBQ") + SBP->BP_BASE
	If SBQ->BQ_PRISEC == "1"
		cPrima := AllTrim(SBQ->BQ_CARACT)
		If SBQ->BQ_TIPDEF == "1"
			dbSelectArea("SBS")
			dbSetOrder(1)
			dbSeek(xFilial("SBS") + SBQ->(BQ_BASE+BQ_ID))
			do While ! Eof() .And. BS_FILIAL + BS_BASE + BS_ID == xFilial("SBS") + SBQ->(BQ_BASE+BQ_ID)
				Aadd(aId, SBS->(BS_ID + BS_CODIGO))
				Aadd(aPrima[1], SBS->(BS_ID+BS_CODIGO))
				Aadd(aPrima[2], AllTrim(SBS->BS_CODIGO) + " - " + AllTrim(SBS->BS_DESCR))
				dbSkip()
			Enddo
		ElseIf SBQ->BQ_TIPDEF == "2"
			dbSelectArea("SBX")
			dbSetOrder(1)
			dbSeek(xFilial("SBX") + SBQ->BQ_CONJUNT)
			do While ! Eof() .And. BX_FILIAL + BX_CONJUN == xFilial("SBX") + SBQ->BQ_CONJUNT
				Aadd(aId, SBQ->BQ_ID + SBX->BX_CODOP)
				Aadd(aPrima[1], SBQ->BQ_ID + SBX->BX_CODOP +Space(TamSX3("BS_CODIGO")[1]-TamSX3("BX_CODOP")[1]))
				Aadd(aPrima[2], AllTrim(SBX->BX_CODOP) + " - " + AllTrim(SBX->BX_DESC))
				dbSkip()
			Enddo
		ElseIf SBQ->BQ_TIPDEF == "3"   // Intervalo
			// para este tipo no tem ateh o momento uma regra definida
		Endif
		dbSelectArea("SBQ")
	Endif
	dbSkip()
Enddo

If dbSeek(xFilial("SBQ") + SBP->BP_BASE)
	While !(SBQ->(EOF())) .And. SBQ->(BQ_FILIAL+BQ_BASE) == xFilial("SBQ")+SBP->BP_BASE
		If SBQ->BQ_TIPDEF == "1"
			dbSelectArea("SBS")
			If dbSeek(xFilial("SBS") + SBQ->(BQ_BASE + BQ_ID))
				Aadd(aSavCol, {"SBT", aID[1], SBS->(BS_ID + BS_CODIGO), A610CriaCols("SBT", aHeaSBT, xFilial("SBT") + SBS->BS_BASE + aID[1] + SBS->(BS_ID + BS_CODIGO), &('{|| SBT->(BT_FILIAL+BT_BASE+BT_IDC1) == xFilial("SBT")+SBQ->BQ_BASE+"'+aID[1]+'" .And. SBT->BT_IDC2 == SBS->(BS_ID + BS_CODIGO)}'))})
				Aadd(aSavCol, {"SBU", aID[1], SBS->(BS_ID + BS_CODIGO), A610CriaCols("SBU", aHeaSBU, xFilial("SBU") + SBS->BS_BASE + aID[1] + SBS->(BS_ID + BS_CODIGO), &('{|| SBU->(BU_FILIAL+BU_BASE+BU_IDC1) == xFilial("SBU")+SBQ->BQ_BASE+"'+aID[1]+'" .And. SBU->BU_IDC2 == SBS->(BS_ID + BS_CODIGO)}'))})
			EndIf
		ElseIf SBQ->BQ_TIPDEF == "2"
			dbSelectArea("SBX")
			If dbSeek(xFilial("SBX") + SBQ->BQ_CONJUNT)
				Aadd(aSavCol, {"SBT", aID[1], SBQ->BQ_ID + SBX->BX_CODOP, A610CriaCols("SBT", aHeaSBT, xFilial("SBT") + SBQ->BQ_BASE + aID[1] + SBQ->BQ_ID + SBX->BX_CODOP, &('{|| SBT->(BT_FILIAL+BT_BASE+BT_IDC1) = xFilial("SBT")+SBQ->BQ_BASE+"'+aID[1]+'" .And. SBT->BT_IDC2 = SBQ->BQ_ID + SBX->BX_CODOP}'))})
				Aadd(aSavCol, {"SBU", aID[1], SBQ->BQ_ID + SBX->BX_CODOP, A610CriaCols("SBU", aHeaSBU, xFilial("SBU") + SBQ->BQ_BASE + aID[1] + SBQ->BQ_ID + SBX->BX_CODOP, &('{|| SBU->(BU_FILIAL+BU_BASE+BU_IDC1) = xFilial("SBU")+SBQ->BQ_BASE+"'+aID[1]+'" .And. SBU->BU_IDC2 = SBQ->BQ_ID + SBX->BX_CODOP}'))})
			EndIf
		Endif
		SBQ->(dbSkip())
	End
EndIf

If Len(aSavCol) == 0
	Help(" ",1, "A093NOPC1")
	lContinua := .F.
Endif

If lContinua
	aConSav := {0, 1, 1, 1, 1} // Posicoes : 1) Item no Tree; 2) Item no Combo1; 3) Item no Combo2; 4) Item do aCols Restricoes; 5) Item do Acols Estrutura

	DEFINE MSDIALOG oDlg TITLE cCadastro + " - " + StrTran(aRotina[nOpcx, 1],"&","") Of oMainWnd PIXEL FROM nTop,nLeft TO nBottom,nRight
	// Informacoes para montagem do Tree

	oTree:= dbTree():New(10, 05,((nBottom-nTop)/2)-20,((nRight-nLeft)/2)*0.4,oDlg,,,.T.)
	oTree:bChange := {|| A093AtuAcol(0,NIL)}

	oTree:BeginUpdate()
	oTree:Reset()
	oTree:EndUpdate()

	oTree:BeginUpdate()

	dbAddTree oTree PROMPT Transform(AllTrim(SBP->BP_BASE), AllTrim(SBP->BP_MASCARA)) + " - " + SBP->BP_DESCR RESOURCE "FOLDER5", "FOLDER6" CARGO "SBP" + StrZero(Recno(),12) + StrZero(0, 12) OPEN

	dbSelectArea("SBQ")
	dbSetOrder(1)
	dbSeek(xFilial("SBQ") + SBP->BP_BASE)
	do While ! Eof() .And. SBQ->BQ_FILIAL + SBQ->BQ_BASE == xFilial("SBQ") + SBP->BP_BASE
		dbAddTree oTree Prompt AllTrim(SBQ->BQ_ID) + " - " + SBQ->BQ_CARACT RESOURCE "FOLDER5", "FOLDER6" CARGO "SBQ" + StrZero(Recno(),12) OPEN
		If SBQ->BQ_TIPDEF == "1"
			dbSelectArea("SBS")
			dbSeek(xFilial("SBS") + SBQ->BQ_BASE + SBQ->BQ_ID)
			do While ! Eof() .And. SBS->BS_FILIAL + SBS->BS_BASE + SBS->BS_ID == xFilial("SBS") + SBQ->BQ_BASE + SBQ->BQ_ID
				dbAddItem oTree Prompt AllTrim(Transform(SBS->BS_CODIGO, A093Mask())) + " - " +  SBS->BS_DESCR RESOURCE "FOLDER6" CARGO "SBS" + StrZero(RecNo(),12) + StrZero(SBQ->(RecNo()), 12)
				dbSkip()
			Enddo
		ElseIf SBQ->BQ_TIPDEF == "2"
			dbSelectArea("SBX")
			dbSeek(xFilial("SBX") + SBQ->BQ_CONJUNT)
			do While ! Eof() .And. SBX->BX_FILIAL + SBX->BX_CONJUN == xFilial("SBX") + SBQ->BQ_CONJUNT
				dbAddItem oTree Prompt AllTrim(Transform(SBX->BX_CODOP, A093Mask())) + " - " +  SBX->BX_DESC RESOURCE "FOLDER6" CARGO "SBX" + StrZero(RecNo(),12) + StrZero(SBQ->(RecNo()), 12)
				dbSkip()
			Enddo
		Endif
		dbEndTree oTree
		dbSelectArea("SBQ")
		dbSkip()
	Enddo

	oTree:EndUpdate()
	oTree:Refresh()

	@ (oDlg:nHeight/2*0.40)+If(l800x600,35,22),((oDlg:nWidth/2)*0.4)+If(l800x600,5,200) BUTTON oButton931 PROMPT STR0035 ACTION A093CopiaCol() SIZE 34,11 OF oDlg PIXEL
	@ (oDlg:nHeight/2*0.40)+If(l800x600,35,22),((oDlg:nWidth/2)*0.4)+If(l800x600,40,240)BUTTON oButton932 PROMPT STR0044 ACTION A093ColaCol()  SIZE 34,11 OF oDlg PIXEL
	@ 008, ((oDlg:nWidth/2)*0.4)+6 say oSayRest Prompt "" Size 160, 6  Of oDlg Pixel
	@ 018, ((oDlg:nWidth/2)*0.4)+0 to (oDlg:nHeight/2*0.40) + 5, (oDlg:nWidth/2)-5  LABEL "" OF oDlg  PIXEL
	@ 025, ((oDlg:nWidth/2)*0.4)+5  Say cPrima + ":" Size 60, 6  Of oDlg Pixel
	@ 025, ((oDlg:nWidth/2)*0.4)+65 ComboBox oCombo1 Var cCombo1 Items aPrima[2] WHEN lWhen .And. lCombo Size 105, 5 Of oDlg Pixel
	oCombo1:bChange := {|| A093AtuAcol(1,NIL)}

	lWhen:=.T.
	nPosSeq := GDFieldPos("BT_SEQ",aHeaSBT)

	For x := 1 to Len(aSavCol)
		If aSavCol[x, 1] == "SBT" .And. Len(aSavCol[x, 4, 2]) == 0
			aSavCol[x, 4, 1, 1, nPosSeq] := StrZero(1, Len(SBT->BT_SEQ))
		Endif
	Next

	aColSBT	:= ACLONE(aSavCol[1, 4, 1])
	oGet1:= MsNewGetDados():New(40 ,((oDlg:nWidth/2)*0.4)+5,oDlg:nHeight/2*0.40,(oDlg:nWidth/2)-10,3     ,"A093LINOK2","A093TUDOK2","+BT_SEQ",         ,          ,    ,        ,            ,         ,oDlg,aHeaSBT,aColSBT)
	oGet1:oBrowse:bGotFocus     := {|| A093GotFocus(1)}
	oGet1:oBrowse:bLostFocus    := {|| A093LostFocus(1)}
    oGet1:lDelete := .T.

	@ (oDlg:nHeight/2*0.40)+7 , ((oDlg:nWidth/2)*0.4)+5 say oSayEstr Prompt "" Size 160, 6  Of oDlg Pixel
	@ (oDlg:nHeight/2*0.40)+15, ((oDlg:nWidth/2)*0.4)+0 to (oDlg:nHeight/2)-30, (oDlg:nWidth/2)-5  LABEL "" OF oDlg  PIXEL

	@ (oDlg:nHeight/2*0.40)+22, ((oDlg:nWidth/2)*0.4)+5  Say cPrima + ":" Size 60, 6  Of oDlg Pixel
	@ (oDlg:nHeight/2*0.40)+22, ((oDlg:nWidth/2)*0.4)+65 ComboBox oCombo2 Var cCombo2 Items aPrima[2] WHEN lWhen  .And. lCombo Size 105, 5 Of oDlg Pixel
	oCombo2:bChange := {|| A093AtuAcol(2,NIL)}

	aColSBU := ACLONE(aSavCol[2, 4, 1])
	oGet2:= MsNewGetDados():New((oDlg:nHeight/2*0.40)+If(l800x600,48,35),((oDlg:nWidth/2)*0.4)+5,(oDlg:nHeight/2)-34,(oDlg:nWidth/2)-10,3,"A093LINOK3","A093TUDOK3","+BQ_ITEM",,,MAXGETDAD,,,,oDlg,aHeaSBU,aColSBU)
	oGet2:oBrowse:bGotFocus     := {|| A093GotFocus(2)}
	oGet2:oBrowse:bLostFocus    := {|| A093LostFocus(2)}
	oGet2:lDelete := .T.


	aColBut := A093PosButton(oDlg, 2, 34, 3)
	nLinBut := (oDlg:nHeight/2) - 28

	A093AtuAcol(0,NIL)

	// Disabilita combos
	oCombo1:Disable()
	oCombo2:Disable()

	// Disabilita buttons
	oButton931:Disable()
	oButton932:Disable()

	DEFINE SBUTTON 			FROM nLinBut, aColBut[1]  TYPE 1  ACTION (lOk:=.T., oDlg:End()) ENABLE OF oDlg         // oDlg:End()ENABLE OF oDlg
	DEFINE SBUTTON 			FROM nLinBut, aColBut[2]  TYPE 2  ACTION             oDlg:End()  ENABLE OF oDlg
	ACTIVATE MSDIALOG oDlg
	Release Object oTree

	If lOk
		aCols  := ACLONE(aSavCol[1, 4, 1])
		For x := 1 to Len(aSavCol)
			cGrava := '{|| (SBT->BT_BASE := SBP->BP_BASE, SBT->BT_IDC1 := "' + aSavCol[x, 2] + '", SBT->BT_IDC2 := "' + aSavCol[x, 3] + '")}'
			If aSavCol[x, 1] == "SBT"
				A610GravaCol(aSavCol[x, 4, 1], aHeaSBT, aSavCol[x, 4, 2], "SBT", &cGrava, "BT_REGRA")
			Else
				cGrava := StrTran(cGrava, "BT_", "BU_")
				cGrava := StrTran(cGrava, "BT->", "BU->")
				A610GravaCol(aSavCol[x, 4, 1], aHeaSBU, aSavCol[x, 4, 2], "SBU", &cGrava, "BU_COMP")
			Endif
		Next
	Endif
EndIf
RestArea1(aSavAre)
Return

/*

Ŀ
Funo    A093AtuAcol   Autor Marcelo Iuspa        Data  10/05/02 
Ĵ
Descrio Atualiza dados ao navegar pelo dbTree/ComboBox              
Ĵ
 Uso      MATA093                                                     
ٱ


aConSav  := {0, 1, 1, 0, 0}
Posicoes : 1) Item no Tree;
	2) Item no Combo1;
	3) Item no Combo2;
	4) Item do aCols Restricoes;
	5) Item do Acols Estrutura
*/
Function A093AtuAcol(nPosicao,aDadosCopia)
Local aSavAre := SaveArea1({"SBP"})
Local cCargo  := Upper(oTree:GetCargo())
Local lSBS    := A093GoCargo("SBS;SBX")
Local nColSBT := 0
Local nColSBU := 0
Local cCbxSBT := A093RetCombo(oCombo1)
Local cCbxSBU := A093RetCombo(oCombo2)
Local cOrig   := Left(cCargo, 3)
Local cCodigo := Nil
Local cDesc   := Nil
Local lRet    := .T.
Local nPosSeq := GDFieldPos("BT_SEQ",aHeaSBT)

Default aDadosCopia:={}
If !lSBS
	oGet1:oBrowse:lDisablePaint := .T.
	oGet2:oBrowse:lDisablePaint := .T.
	oGet1:oBrowse:Disable()
	oGet2:oBrowse:Disable()
	oGet1:oBrowse:Refresh()
	oGet2:oBrowse:Refresh()
	oCombo1:Disable()
	oCombo2:Disable()
	oButton931:Disable()
	oButton932:Disable()
	lRet := .F.
Else
	oButton931:Enable()
	oButton932:Enable()
Endif

If lRet
	If SBQ->BQ_PRISEC == "1"
		oCombo1:nAt := 1
		oCombo2:nAt := 1
		oCombo1:Refresh()
		oCombo2:Refresh()
		oCombo1:Disable()
		oCombo2:Disable()
		lCombo := .F.
	Else
		oCombo1:Enable()
		oCombo2:Enable()
		lCombo := .T.
	Endif

	If Left(cCargo, 3) == "SBX"
		cCodigo := SBX->BX_CODOP
		cDesc   := SBX->BX_DESC
	Else
		cCodigo := SBS->BS_CODIGO
		cDesc   := SBS->BS_DESCR
	Endif

    //
	//Cria o aCols e adiciona no array aSavCol, caso ainda nao exista 
	//
	nColSBT := aScan(aSavCol, {|z| z[1]+z[2]+z[3] == "SBT" + cCbxSBT + SBQ->BQ_ID + cCodigo})
	If nColSBT == 0
		If SBQ->BQ_TIPDEF == "1"
		 	Aadd(aSavCol, {"SBT", cCbxSBT, SBS->(BS_ID + BS_CODIGO), A610CriaCols("SBT", aHeaSBT, xFilial("SBT") + SBS->BS_BASE + cCbxSBT + SBS->(BS_ID + BS_CODIGO), &('{|| SBT->(BT_FILIAL+BT_BASE+BT_IDC1) == xFilial("SBT")+SBQ->BQ_BASE+"'+cCbxSBT+'" .And. SBT->BT_IDC2 == SBS->(BS_ID + BS_CODIGO)}'))})
		ElseIf SBQ->BQ_TIPDEF == "2"
			Aadd(aSavCol, {"SBT", cCbxSBT, SBQ->BQ_ID + SBX->BX_CODOP, A610CriaCols("SBT", aHeaSBT, xFilial("SBT") + SBQ->BQ_BASE + cCbxSBT + SBQ->BQ_ID + SBX->BX_CODOP, &('{|| SBT->(BT_FILIAL+BT_BASE+BT_IDC1) = xFilial("SBT")+SBQ->BQ_BASE+"'+cCbxSBT+'" .And. SBT->BT_IDC2 = SBQ->BQ_ID + SBX->BX_CODOP}'))})
		EndIf
		nColSBT := Len(aSavCol)

		If Len(aSavCol[nColSBT, 4, 2]) == 0
			aSavCol[nColSBT, 4, 1, 1, nPosSeq] := StrZero(1, Len(SBT->BT_SEQ))
		EndIf
	Endif

	nColSBU := aScan(aSavCol, {|z| z[1]+z[2]+z[3] == "SBU" + cCbxSBU + SBQ->BQ_ID + cCodigo})
	If nColSBU == 0
		If SBQ->BQ_TIPDEF == "1"
			Aadd(aSavCol, {"SBU", cCbxSBU, SBS->(BS_ID + BS_CODIGO), A610CriaCols("SBU", aHeaSBU, xFilial("SBU") + SBS->BS_BASE + cCbxSBU + SBS->(BS_ID + BS_CODIGO), &('{|| SBU->(BU_FILIAL+BU_BASE+BU_IDC1) == xFilial("SBU")+SBQ->BQ_BASE+"'+cCbxSBU+'" .And. SBU->BU_IDC2 == SBS->(BS_ID + BS_CODIGO)}'))})
		ElseIf SBQ->BQ_TIPDEF == "2"
			Aadd(aSavCol, {"SBU", cCbxSBU, SBQ->BQ_ID + SBX->BX_CODOP, A610CriaCols("SBU", aHeaSBU, xFilial("SBU") + SBQ->BQ_BASE + cCbxSBU + SBQ->BQ_ID + SBX->BX_CODOP, &('{|| SBU->(BU_FILIAL+BU_BASE+BU_IDC1) = xFilial("SBU")+SBQ->BQ_BASE+"'+cCbxSBU+'" .And. SBU->BU_IDC2 = SBQ->BQ_ID + SBX->BX_CODOP}'))})
	    EndIf
	    nColSBU := Len(aSavCol)
	EndIf

	oSayRest:SetText(If(lSBS, AllTrim(cDesc) + " - ", "") + STR0017) //"Restries para Formao"
	oSayEstr:SetText(If(lSBS, AllTrim(cDesc) + " - ", "") + STR0018) //"Composio de Estrutura"

	aConSav[4] := nColSBT
	aConSav[5] := nColSBU

	oGet1:oBrowse:lDisablePaint := .T.
	oGet2:oBrowse:lDisablePaint := .T.
	n:= 1


	If nPosicao == 0 .Or. nPosicao == 1
		aColSBT   := aClone(aSavCol[nColSBT, 4, 1])
		oGet1:oBrowse:lDisablePaint := .F.
		oGet1:aCols := aColSBT
		oGet1:oBrowse:Refresh()
	EndIf

	If nPosicao == 0 .Or. nPosicao == 2
		If !Empty(aDadosCopia)
			aColSBU   := aClone(aDadosCopia)
		Else
			aColSBU   := aClone(aSavCol[nColSBU, 4, 1])
		EndIf
		oGet2:oBrowse:lDisablePaint := .F.
		oGet2:aCols := aColSBU
		oGet2:oBrowse:Refresh()
	EndIf

	oGet1:oBrowse:Enable()
	oGet2:oBrowse:Enable()
EndIf
RestArea1(aSavAre)
Return lRet

/*

Ŀ
Funo    A093GotFocus  Autor Marcelo Iuspa        Data  10/05/02 
Ĵ
Descrio Atualiza aCols/aHeader ao entrar na GetDados                
Ĵ
ParametrosnOri -> Identifica qual GetDados que se esta entrando       
Ĵ
 Uso      MATA093                                                     
ٱ


*/
Function A093GotFocus(nOri)
If nOri == 1
	aColSBT   := aClone(aSavCol[aConSav[4], 4, 1])
	oGet1:oBrowse:Refresh()
	n     := oGet1:oBrowse:nAt
Else
	aColSBU   := aClone(aSavCol[aConSav[5], 4, 1])
	oGet2:oBrowse:Refresh()
	n       := oGet2:oBrowse:nAt
Endif
Return(.T.)

/*

Ŀ
Funo    A093LostFocus Autor Marcelo Iuspa        Data  10/05/02 
Ĵ
Descrio Salva aCols/aHeader ao sair da GetDados                     
Ĵ
ParametrosnOri -> Identifica qual GetDados que se esta saindo         
Ĵ
 Uso      MATA093                                                     
ٱ


*/
Function A093LostFocus(nOri)
Local lRet := .T.

If nOri == 1
	aSavCol[aConSav[4], 4, 1] := aClone(oGet1:aCols)
Else
	//-- Valida a linha digitada.
	If A093LINOK3()
		aSavCol[aConSav[5], 4, 1] := aClone(oGet2:aCols)
	Else
		oGet2:oBrowse:SetFocus()
		lRet := .F.
	EndIf
Endif
n := 1
Return ( lRet )

/*

Ŀ
Funo    A093RetCombo  Autor Marcelo Iuspa        Data  10/05/02 
Ĵ
Descrio Pesquisa no arquivo SBS o elemento selecionado nos combos   
Ĵ
 Uso      MATA093                                                     
ٱ


*/
Function A093RetCombo(oCombo)
Local nAt    := oCombo:nAt
Local cRet   := ""
If nAt > 1
	cRet := aPrima[1, nAt]
Else
	cRet := Space(Len(SBS->(BS_ID+BS_CODIGO)))
Endif
Return(cRet)

/*

Ŀ
Funo    A093MontaCod  Autor Marcelo Iuspa        Data  13/06/02 
Ĵ
Descrio Monta codigo inteligente baseado no trecho inicial fornecido
Ĵ
 Uso      MATA093                                                     
ٱ


*/
Function A093MontaCod(cCodigo,lChkGrade)
Local oDlg
Local lOk   := .F.

Local x := 0
Local aCodGrd := {}
Local cBase:= A093VldBase(cCodigo)
Local cCod := AllTrim(cBase)
Local cCodBS := ""
Local aSavAre := SaveArea1({"SB1", "SBP", "SBQ", "SBS", "SBT", "SBU"})
Local nInt := 0
Local cRet := Space(Len(SB1->B1_COD))
DEFAULT lChkGrade := .T.

Private aGetCods  := {}

cCodigo := Pad(If(cCodigo == Nil, "", cCodigo), Len(SB1->B1_COD))
SBP->(dbSeek(xFilial("SBP") + cBase))

If ReadVar() == "M->B1_COD"
	lChkGrade := .F.
EndIf

If A093ChkOpc()
	dbSelectArea("SBQ")
	dbSetOrder(1)
	dbSeek(xFilial("SBQ") + SBP->BP_BASE)

	//Ŀ
	//Verifica se existe controle de grade foi implementado na base do cliente
	//
	If lChkGrade
		lChkGrade	:= ( SBQ->(FieldPos("BQ_TPGRD"))>0 )
	EndIf

	DEFINE MSDIALOG oDlg TITLE AllTrim(Transform(SBP->BP_BASE, SBP->BP_MASCARA)) + " - " + SBP->BP_DESCR Of oMainWnd PIXEL FROM 0,0 TO 220,520
	oScrollBox := TScrollBox():new(oDlg,20,02, 90,208,.T.,.T.,.T.)
	oScrollBox:Align := CONTROL_ALIGN_ALLCLIENT

	If ! SBP->BP_CODPAD == "2"
		cCodigo := SubStr(cCodigo, Len(AllTrim(SBP->BP_BASE)) + 1)
	Endif

	dbSelectArea("SBQ")
	dbSeek(xFilial("SBQ") + SBP->BP_BASE)

	do While ! Eof() .And. SBQ->(BQ_FILIAL + BQ_BASE) == xFilial("SBQ") + SBP->BP_BASE

		//Ŀ
		//Verifica se a definicao da interface de grade esta ativa                
		//
		If lChkGrade .And. (SBQ->BQ_TPGRD $ "12")
			aAdd(aCodGrd,a093IdRec(SBP->BP_BASE,SBQ->BQ_ID))
			SBQ->(DbSkip())
			Loop
		EndIf

		If SBP->BP_CODPAD == "2"
			cCodBS  := Substr(cCodigo, SBQ->BQ_INICIO, SBQ->BQ_TAMANHO)
		Else
			cCodBS  := SubStr(cCodigo, 1, SBQ->BQ_TAMANHO)
			cCodigo := SubStr(cCodigo, SBQ->BQ_TAMANHO + 1)
		Endif
		If     SBQ->BQ_TIPDEF == "1"
			If (! SBS->(dbSeek(xFilial("SBS") + SBQ->(BQ_BASE + BQ_ID) + cCodBS)))
				cCodBS := Space(SBQ->BQ_TAMANHO)
			Endif
		ElseIf SBQ->BQ_TIPDEF == "2"
			If (! SBX->(dbSeek(xFilial("SBX") + SBQ->BQ_CONJUNT + cCodBS)))
				cCodBS := Space(SBQ->BQ_TAMANHO)
			Endif
		ElseIf SBQ->BQ_TIPDEF == "3"
			nInt := (Val(cCod) - (SBQ->BQ_INTATE - SBQ->BQ_INTDE)) / SBQ->BQ_INTDE
			If Int(nInt) - nInt > 0
				cCodBS := Space(SBQ->BQ_TAMANHO)
			Endif
		Endif

		Aadd(aGetCods, {Nil, SBQ->BQ_CARACT, Nil, SBQ->BQ_ID,NIL})


		&("M->" + "_" + a093IdRec(cBase,SBQ->BQ_ID)) := cCodBS
		&("M->" + "D" + a093IdRec(cBase,SBQ->BQ_ID)) := " "

		@ (++ x * 10),  10 Say   aGetCods[x, 1] Prompt ""  Size  80, 6 Of oScrollBox Pixel
		@ ( x * 10),  140 Say   aGetCods[x, 5] Prompt ""  Size  80, 6 Of oScrollBox Pixel

		cVar     := "_" + a093IdRec(cBase,SBQ->BQ_ID)
		cBuf     := Nil
		bGet     := "{ | u | If( PCount() == 0, "+cVar+","+cVar+" := u)}"
		cPicture := Nil
		bWhen    := Nil

		If SBQ->BQ_TIPDEF == "1"
			cF3      := "SBS"
			bValid   := &('{|| (Vazio() .Or. A093ExistCpo("SBS", "' + SBQ->(BQ_BASE + BQ_ID) + '" + ' + "M->_" + a093IdRec(cBase,SBQ->BQ_ID) + ')) .And. If(ExistBlock("MT093VCR"),ExecBlock("MT093VCR",.F.,.F.,{"'+SBQ->BQ_ID+'",M->'+cVar+'}),.T.) .AND. A093IniDsc ("'+SBQ->BQ_ID+'", aGetCods)}')
		ElseIf SBQ->BQ_TIPDEF == "2"
			cF3      := "SBX"
			bValid   := &('{|| (Vazio() .Or. A093ExistCpo("SBX", "' + SBQ->BQ_CONJUNT + '" + ' + "M->_" + a093IdRec(cBase,SBQ->BQ_ID) + ')) .And. If(ExistBlock("MT093VCR"),ExecBlock("MT093VCR",.F.,.F.,{"'+SBQ->BQ_ID+'",M->'+cVar+'}),.T.) .AND. A093IniDsc ("'+SBQ->BQ_ID+'",aGetCods)}')
		ElseIf SBQ->BQ_TIPDEF == "3"                         '
			cF3      := ""
			bValid   := &('{|| (Vazio() .Or. A098VldGetIN(' + AllTrim(Str(SBQ->BQ_INTDE)) + ', ' + AllTrim(Str(SBQ->BQ_INTATE)) + ', ' + AllTrim(Str(SBQ->BQ_INTSTEP)) + ', M->_' + a093IdRec(cBase,SBQ->BQ_ID) + ')) .And. If(ExistBlock("MT093VCR"),ExecBlock("MT093VCR",.F.,.F.,{"'+SBQ->BQ_ID+'",M->'+cVar+'}),.T.) .AND. A093IniDsc ("'+SBQ->BQ_ID+'",aGetCods)}')
		Else
			bValid   := {|| .T.}
			cF3      := ""
		Endif

		If !Empty(cF3)
			cF3 := "A093ConPad('" + cF3 + "', '" + cVar + "', aGetCods["+cValToChar(Len(aGetCods))+"][3])"
		EndIf

		aTail(aGetCods)[3] := TGet():New( 10 + (x * 20), 220, &(bGet),oScrollBox,30,6,cPicture, bValid, , , ,.F., , .T., , .F., bWhen , .F., .F., , .F., .F.,cF3,cVar,cBuf)

		dbSkip()
	Enddo

	aEval(aGetCods, {|x,y| (x[1]:SetText(x[2]), x[3]:Refresh(), x[3]:Move((y*20)-4, 130, 120, 18))})

	ACTIVATE MSDIALOG oDlg ON INIT EnchoiceBar(oDlg,{|| lOk := A093VldCar(aGetCods), If(lOk,oDlg:End(),Nil)},{||oDlg:End()}) CENTERED


	dbSelectArea("SBS")
	dbSetOrder(1)

	For x := 1 to Len(aGetCods)
		cCodBS := &("M->_" + a093IdRec(cBase,aGetCods[x, 4]))
		cCod   += cCodBS
	Next

	If SBP->BP_CODPAD == "2"
		cCod := a093SubsId(SBP->BP_ESTCOD,SBP->BP_BASE)
		//Ŀ
		//Se possuir interface grade, elimina as mesmas.                          
		//
		For x := 1 To Len(aCodGrd)
			cCod := StrTran(cCod,"+_"+aCodGrd[x]+"+","+")
			cCod := StrTran(cCod,"+_"+aCodGrd[x]+" ","")
		Next x
		cCod := &(cCod)
	Endif

	cRet := Pad(If(lOk, cCod, ""), Len(SB1->B1_COD))

	//Ŀ
	//Atualiza variavel de controle de interface de grade                     
	//
	If Type('lAtvGrd')=='L'
		lAtvGrd := !Empty(aCodGrd)
	EndIf
EndIf
RestArea1(aSavAre)
Return cRet

/*/{Protheus.doc} A093ConPad
	Funo para retornar a posio do campo atual.
	@type Function
	@author juliana.oliveira
	@since 13/02/2025
	@version version
	@param cF3, cVar, oGet
	@return ConPad1
/*/
Function A093ConPad(cF3, cVar, oGet)

	If ReadVar() != cVar
		__READVAR := cVar
	EndIf

Return ConPad1(,,,cF3,'M->'+cVar,,,'M->'+cVar, oGet)

/*/


Ŀ
Funo	  A093F3BS  Autor  Marcelo Antonio Iuspa  Data  14/05/02	
Ĵ
Descrio  Exibe as opcoes para o item atual                            
Ĵ
Uso		  Codigo Inteligente de Produto                                
ٱ


/*/
Function A093F3Opt()
Local cTitulo, cAlias, cSeek, bWhile, aFields, bInit, bFor
Local nId := Val(Substr(ReadVar(),2,Len(ReadVar())))
Local aArea := Nil
Local oDlg

SBQ->(dbGoTo(nId))
SBQ->(dbSetOrder(1))

aArea := SaveArea1({"SBP", "SBQ", "SBS", "SBX"})

cTitulo := AllTrim(SBP->BP_DESCR) + " - " + AllTrim(SBQ->BQ_DESCR)

If SBQ->BQ_TIPDEF == "1"
	cAlias := "SBS"
	cSeek  := SBQ->(BQ_BASE + BQ_ID)
	bWhile := {|| SBS->(BS_FILIAL + BS_BASE + BS_ID) == xFilial("SBS") + SBQ->(BQ_BASE + BQ_ID)}
	aFields:= {"BS_CODIGO", "BS_DESCR"}
	bFor   := {|| SBS->BS_ATIVO == "1"}
	bInit  := {|| SBS->BS_CODIGO == &(ReadVar())}
ElseIf SBQ->BQ_TIPDEF == "2"
	cAlias := "SBX"
	cSeek  := SBQ->BQ_CONJUNT
	bWhile := {|| SBX->(BX_FILIAL + BX_CONJUN) == xFilial("SBX") + SBQ->BQ_CONJUNT}
	aFields:= {"BX_CODOP", "BX_DESC"}
	bFor   := {|| SBX->BX_ATIVO == "1"}
	bInit  := {|| SBX->BX_CODOP == &(ReadVar())}
Endif
RestArea1(aArea)


//Ŀ
//Ponto de Entrada antes da montagem da consulta padrao
//
If ExistBlock( "MT093OPT" )
   aRet := ExecBlock("MT093OPT",.F.,.F.,{bWhile, aFields, bFor, bInit})
   If ValType(aRet) == "A" .And. Len(aRet) == 4
     	bWhile := aRet[1]
		aFields:= aRet[2]
		bFor   := aRet[3]
		bInit  := aRet[4]
   EndIf
Endif

lRet := A635Consulta(cTitulo, cAlias, cSeek, bWhile, aFields, bInit, bFor)
Return(lRet)

/*

Ŀ
Funo    A093SimSBP    Autor Marcelo Iuspa        Data  10/05/02 
Ĵ
Descrio  Monta Tree com estrutura de um codigo inteligente fornecido
Ĵ
Uso		  Codigo Inteligente de Produto                              
ٱ


*/
Function A093SimSBP(cAlias, nReg, nOpcx)
Local aFieSB1  := A610CriaHeader("SB1")
Local aSavAre
Local cProd
Local cField, nPos, x
Local cDesc    := ""
Local aStru    := {}

Local nTop     := oMainWnd:nTop+100
Local nLeft    := oMainWnd:nLeft+5
Local nBottom  := oMainWnd:nBottom-60
Local nRight   := oMainWnd:nRight-10
Local aColBut  := {}

Local nLinBut  := 0
Local cCargoIni:= "SBP" + StrZero(SBP->(RecNo()), 12)
Local lOk      := .F.
Local lRet	   := .T.
Local cAliasEstr := If(SBP->BP_ESTRUT=="2","SGG","SG1")

Local oPanel1
Local oPanel2
Local oPanelLeft
Local oPanelRight
Local oPanelR1
Local oPanelR2
Local oPanelSep
Local oEnchoice
Local oSayIt := Nil

Private nCargo := 0
Private aTela[0][0], aGets[0]

aSavAre	:=	SaveArea1({"SBP"})
lRet	:=	A093ChkOpc()  // Retorna se nao tiver opcoes (SBS) para todas as caracteristicas (SBQ)
If lRet
	cProd	:=  A093MontaCod( AllTrim(SBP->BP_BASE), .F. )
	lRet	:=  ! Empty(cProd) .And. A093VldCod(cProd,.F., @cDesc, @aStru, .F.)

	dbSelectArea("SB1")
	dbSetOrder(1)
	If lRet .And. dbSeek(xFilial("SB1") + Pad(cProd, Len(SB1->B1_COD)))
		Help(" ",1, "A093PRODJA")
		lRet := .F.
	Endif

	If lRet
		For x := 1 to Len(aFieSB1)
			cField := aFieSB1[x, 2]
			If (nPos := SBR->(FieldPos(StrTran(cField, "B1_", "BR_")))) > 0
				&("M->" + cField) := SBR->(FieldGet(nPos))
			Else
				&("M->" + cField) := CriaVar(cField)
			Endif
		Next
		M->B1_COD  := cProd
		M->B1_DESC := PadR(AllTrim(cDesc),Len(SB1->B1_DESC))

		A093Campos(cProd)

		DEFINE MSDIALOG oDlg TITLE cCadastro Of oMainWnd PIXEL FROM nTop,nLeft TO nBottom,nRight
		oDlg:lMaximized := .T.

		@ 000,000 MSPANEL oPanel1 OF oDlg
		@ 000,000 MSPANEL oPanelLeft SIZE __DlgWidth(oDlg)-(__DlgWidth(oDlg)/3),0 OF oPanel1
		@ 000,000 MSPANEL oPanelSep SIZE 2,2 OF oPanel1
		@ 000,000 MSPANEL oPanelRight SIZE __DlgWidth(oDlg)/3,0 OF oPanel1
		@ 000,000 MSPANEL oPanel2 OF oDlg
		@ 000,000 MSPANEL oPanelR1 SIZE 30,30 OF oPanel2
		@ 000,000 MSPANEL oPanelR2 SIZE 30,30 OF oPanel2

		oPanelLeft:Align := CONTROL_ALIGN_ALLCLIENT
		oPanelRight:Align := CONTROL_ALIGN_RIGHT
		oPanelSep:Align := CONTROL_ALIGN_RIGHT
		oPanelR2:Align := CONTROL_ALIGN_RIGHT
		oPanelR1:Align := CONTROL_ALIGN_RIGHT

		// Informacoes para montagem do Tree
		oTree:= dbTree():New(0,0,0,0,oPanelRight,,,.T.)
		oTree:Align := CONTROL_ALIGN_ALLCLIENT

		oEnchoice := MsmGet():New( "SB1", , 2,,,,, {10, 04, ((nBottom-nTop)/2)-30,(oDlg:nWidth *.32)-5},,,,,,oPanelLeft,,.T.)
		oEnchoice:oBox:Align := CONTROL_ALIGN_ALLCLIENT

		oTree:BeginUpdate()
		oTree:Reset()
		oTree:EndUpdate()

		oTree:BeginUpdate()

		oTree:AddTree( Transform(AllTrim(SBP->BP_BASE), AllTrim(SBP->BP_MASCARA)) + " - " + SBP->BP_DESCR, .F., "FOLDER5","FOLDER6",,, cCargoIni,,,1)

		dbSelectArea(cAliasEstr)
		dbSetOrder(1)

		oTree:TreeSeek("")

		for x := 1 to Len(aStru)
			(cAliasEstr)->(dbSeek(xFilial(cAliasEstr) + aStru[x, 1]))
			A093Monta(aStru[x, 1], A093Cargo(), 2,aStru[x, 4])
			oTree:TreeSeek(cCargoIni)
		Next

		dbEndTree oTree
		oTree:Refresh()
		oTree:SetFocus()

		oTree:EndUpdate()
		oTree:Refresh()

		aColBut := A093PosButton(oDlg, 2, 34, 3)
		nLinBut := (oDlg:nHeight/2) - 30

		DEFINE SBUTTON oBtnInc  FROM 1,1  TYPE 4  ACTION (lOk := .T., oDlg:End()) ENABLE OF oPanelR1 PIXEL
		DEFINE SBUTTON 			FROM 1,1  TYPE 2  ACTION               oDlg:End()  ENABLE OF oPanelR2 PIXEL

		If ! A093InclOk(SBP->BP_BASE)
			oBtnInc:Disable()
		Endif

		ACTIVATE MSDIALOG oDlg ON INIT AlignObject(oDlg,{oPanel1,oPanel2},1,2,{,030})
		Release Object oTree
		If lOk
			FWMsgRun(, {|oSayIt| A093VldCod(cProd,.T.,,,.T.,.T.,oSayIt) }, "Gerando o Cadastro de Produtos...", "Aguarde")
			
			//Ŀ
			// Recalcula os Niveis                                          
			//
			If GetMv('MV_NIVALT') == 'S'
				MA320Nivel(Nil,.T.)
			EndIf

		Endif
	EndIf
EndIf
RestArea1(aSavAre)
Return lRet

/*/


Ŀ
Funo	  A093Monta Autor  Marcelo Antonio Iuspa  Data  14/06/02	
Ĵ
Descrio  Auxiliar recursiva para montagem do Tree                     
Ĵ
Uso		  Codigo Inteligente de Produto                                
ٱ


/*/
Function A093Monta(cCod, cCargo, nSub,cTrt)
Local cAlias    := Alias()
Local cCargoPai := ""
Local cComp		:= ""
Local cDesc   := ""
Local nRecAnt
Local cAliasEstr:= If(SBP->BP_ESTRUT == "2","SGG","SG1")
Local cPrefixo  := If(cAliasEstr == "SG1","G1_","GG_")
Default cTrt 	:= Space(3)

nSub := If(nSub == Nil, 2, nSub)

dbSelectArea("SB1")
SB1->(dbSetOrder(1))
SB1->(dbSeek(xFilial('SB1') + cCod, .F.))
cDesc := SB1->B1_DESC

oTree:AddItem(AllTrim(cCod)+ " - "+ alltrim(cDesc)+If(Empty(cTrt),""," - "+STR0041 +cTrt),cCargo,"FOLDER6","FOLDER6",,,nSub) //"Sequencia "
oTree:TreeSeek(cCargo)
cCargoPai := cCargo

//-- Se o Componente for Pai, Adiciona sua Estrutura
dbSelectArea(cAliasEstr)
(cAliasEstr)->(dbSetOrder(1))
If (cAliasEstr)->(dbSeek(xFilial(cAliasEstr) + cCod, .F.))
	do While ! Eof() .And. (cAliasEstr)->(&(cPrefixo+"FILIAL")+&(cPrefixo+"COD")) == xFilial(cAliasEstr) + cCod
		nRecAnt := RecNo()
		cComp   := (cAliasEstr)->(&(cPrefixo+"COMP"))
		cTrt	:= (cAliasEstr)->(&(cPrefixo+"TRT"))
		cCargo  := A093Cargo()
		SB1->(dbSeek(xFilial('SB1') + cComp, .F.))
		cDesc := SB1->B1_DESC
		If (cAliasEstr)->(dbSeek(xFilial(cAliasEstr) + (cAliasEstr)->(&(cPrefixo+"COMP")), .F.))
			//-- Adiciona um Nivel a Estrutura
			A093Monta((cAliasEstr)->(&(cPrefixo+"COD")), A093Cargo(),,(cAliasEstr)->(&(cPrefixo+"TRT")))
			oTree:TreeSeek(cCargoPai)
		Else
			//-- Adiciona um Componente a Estrutura
			oTree:AddItem(alltrim(cComp)+ " - "+ alltrim(cDesc)+If(Empty(cTrt),""," - "+STR0041 +cTrt), cCargo, "FOLDER5", "FOLDER6",,, 2) //"Sequencia "
		EndIf
		(cAliasEstr)->(dbGoto(nRecAnt))
		(cAliasEstr)->(dbSkip())
	EndDo
Endif
oTree:Refresh()
oTree:SetFocus()
dbSelectArea(cAlias)
Return

/*/


Ŀ
Funo	 A093Cargo  Autor  Marcelo Antonio Iuspa  Data  14/05/02	
Ĵ
Descrio  Retorna Cargo para ser usado no objeto Tree                  
Ĵ
Uso		  Codigo Inteligente de Produto                                
ٱ


/*/
Function A093Cargo(lReseta)
Static nCargo
Local cAliasEstr := If(SBP->BP_ESTRUT=="2","SGG","SG1")
lReseta := If(lReseta == Nil, .F., lReseta)
nCargo  := If(nCargo   == Nil .Or. lReseta, 0, nCargo)

nCargo ++
Return(StrZero(nCargo, 12) + StrZero((cAliasEstr)->(RecNo()), 12))

/*


Ŀ
Funo	  A093PadSBP   Autor  Marcelo Iuspa		    Data  07/06/02 
Ĵ
Descrio  Altera ou Inclui registro no SBR para dados padrao do produto 
Ĵ
Parametros Nenhum														 
Ĵ
Retorno	  .T.															 
ٱ


*/
Function A093PadSBP()
Local aHeaTMP := A610CriaHeader("SBR", "BR_BASE")
Local aSavAre := SaveArea1({"SBR", "SB1"})
Local aAcho    	:= {}
Local aSize    	:= {}
Local aInfo    	:= {}
Local aObjects 	:= {}
Local aPosObj  	:= {}
Local aButtons  := {}
Local lConf    	:= .F.
Local lInclui  	:= .F.
Local oEnchoice := NIL
Local oDlg	   	:= NIL

Private aTELA[0][0],aGETS[0]

aHeader   := A610CriaHeader("SBU", "BU_BASE, BU_IDC1, BU_IDC2",,.T.)
aCriaCols := A610CriaCols("SBU", aHeader, xFilial("SBU") + SBP->BP_BASE + Space(Len(SBU->BU_IDC1) * 2), {|| SBU->BU_FILIAL + SBU->BU_BASE + SBU->BU_IDC1 + SBU->BU_IDC2 == xFilial("SBU") + SBP->BP_BASE + Space(Len(SBU->BU_IDC1) * 2)})
aCols     := aClone(aCriaCols[1])
aColsReg  := aClone(aCriaCols[2])

dbSelectArea("SBR")
dbSetOrder(1)

lInclui := !dbSeek(xFilial("SBR") + Pad(SBP->BP_BASE, Len(SBR->BR_BASE)))

aAdd(aObjects,{100,190,.T.,.T.,.F.}) // Indica dimensoes x e y e indica que redimensiona x e y e assume que retorno sera em linha final coluna final (.F.)
aAdd(aObjects,{100,320,.T.,.T.,.F.}) // Indica dimensoes x e y e indica que redimensiona x e y e assume que retorno sera em linha final coluna final (.F.)
aSize:=MsAdvSize()
aInfo:={aSize[1],aSize[2],aSize[3],aSize[4],3,3}
aPosObj:=MsObjSize(aInfo,aObjects, .T.)

DEFINE MSDIALOG oDlg TITLE OemToAnsi(cCadastro) From aSize[7],0 TO aSize[6],aSize[5] OF oMainWnd PIXEL

aEval(aHeaTMP, {|z| Aadd(aAcho, z[2])})

RegToMemory("SBR", lInclui)

oEnchoice := MsmGet():New( "SBR", SBR->(RecNo()), If(lInclui,3,4),,,,aACho, aPosObj[1],,,,,, oDlg,,,,,)
oGet:= MSGetDados():New(aPosObj[2,1],aPosObj[2,2],aPosObj[2,3],aPosObj[2,4],3,"A093LINOK4",,,.T.,,,,nMaxLaCols,)

ACTIVATE MSDIALOG oDlg ON INIT ( EnchoiceBar(oDlg,{||If(Obrigatorio(aGets,aTela), If(A093LINOK4(),(lConf := .T.,oDlg:End()),),)},{|| oDlg:End()}))

If lConf
	RecLock("SBR", lInclui, .T.)
	aEval(aAcho, {|z| FieldPut(FieldPos(z), &("M->" + z))})
	SBR->BR_FILIAL := xFilial("SBR")
	SBR->BR_BASE   := SBP->BP_BASE
	MsUnlock()
	A610GravaCol(aCols, aHeader, aColsReg, "SBU", {|| SBU->BU_BASE := SBP->BP_BASE}, "BU_COMP, BU_QUANT")
	// ---- Ponto de entrada APOS GRAVACAO, usado para efetuar alteracoes nos dados do produto (SB1)
	If ExistBlock("A093SBR")
		ExecBlock("A093SBR", .F., .F.)
	EndIf
EndIf

RestArea1(aSavAre)
Return

/*


Ŀ
Funo	  A093VldBase  Autor  Marcelo Iuspa		    Data  07/06/02 
Ĵ
Descrio  Checa a qual base de produto pertence o codigo fornecido      
Ĵ
Parametros Codigo ou parte do codigo contendo codigo base                
Ĵ
Retorno	  Codigo base se encontrado ou branco se nao encontrado		 
ٱ


*/
Function A093VldBase(cCodigo)
Local aSavAre     := {}
Local cBase       := Space(Len(SBP->BP_BASE))
Local x           := Len(Alltrim(SBP->BP_BASE))
Local nCodigo     := 0
Local nTamCodigo  := Len(cCodigo)
Local cFilSBP     := xFilial("SBP")
Local cQuery      := ""
Local aInsert 	  := {}
Local nX          := 0
Local nY          := 0
Local nItmSetQry  := 0
Local nLen 		  := 0
Local nLen2       := 0
Local nPosPrepared:= 0
Local cMD5 		  := ""
Local cAliasQry   := GetNextAlias()
Local lCodVazio   := Iif(Empty(cCodigo), .T., .F.)

If IsInCallStack("OMS010GDLO")
	aSavAre := SBP->(GetArea())
Else
	aSavAre := SaveArea1({"SBP"})
EndIf

If !SBP->(LastRec()) == 0 .Or.  SBP->(dbSeek(xFilial("SBP")))
	dbSelectArea("SBP")
	If dbSeek(xFilial("SBP") + Pad(SubStr(cCodigo, 1, x), Len(SBP->BP_BASE)))
		cBase := SBP->BP_BASE
	ElseIf !(lCodVazio)

		cQuery := "SELECT DISTINCT TBLSBP.BP_BASE FROM ( "

		For nCodigo := 1 to nTamCodigo

			If nCodigo > 1
				cQuery += " UNION "
			EndIf
			aAdd(aInsert,{RetSQLName("SBP"), cFilSBP, Pad(SubStr(cCodigo, 1, nCodigo), Len(SBP->BP_BASE))})
			cQuery += " SELECT BP_BASE FROM ? WHERE BP_FILIAL = ? AND BP_BASE = ? AND D_E_L_E_T_ = ' '"

		Next

		cQuery += ") TBLSBP ORDER BY TBLSBP.BP_BASE"

		nLen := Len(aInsert)
		cMD5 := MD5(cQuery)
		If (nPosPrepared := Ascan(__aPrepared,{|x| x[2] == cMD5})) == 0
			Aadd(__aPrepared,{FWPreparedStatement():New(),cMD5})
			nPosPrepared := Len(__aPrepared)
			__aPrepared[nPosPrepared][1]:SetQuery(ChangeQuery(cQuery))
		Endif

		For nX := 1 To nLen
			nLen2 := Len(aInsert[nX])
			nItmSetQry++
			__aPrepared[nPosPrepared][1]:SetUnsafe(nItmSetQry,aInsert[nX][1])
			For nY := 2 to nLen2
				nItmSetQry++
				__aPrepared[nPosPrepared][1]:SetString(nItmSetQry,aInsert[nX][nY])
			Next
		Next nX

		cQuery := __aPrepared[nPosPrepared][1]:getFixQuery()

		aInsert := aSize(aInsert,0)

		dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasQry,.T.,.T.)

		While !(cAliasQry)->(EOF())
			If !Empty((cAliasQry)->BP_BASE)
				cBase := (cAliasQry)->BP_BASE
				Exit
			EndIf
			(cAliasQry)->(DbSkip())
		EndDo

		(cAliasQry)->(DbCloseArea())
	EndIf
EndIf

If IsInCallStack("OMS010GDLO")
	RestArea(aSavAre)
Else
	//RestArea1(aSavAre)
	//DMANSMARTSQUAD1-28287 - Correo erro conforme spike DMANSMARTSQUAD1-27463
	IF AScan(aSavAre, {|x| AllTrim(x[1]) == ""}) > 0 // verifica se o array aSavAre tem algum elemento vazio
		aDel( aSavAre,AScan( aSavAre, {|x| x[1]=="", (x[2], x[3]) == 0} ) ) // Deleta o elemento vazio absoluto do array
		aSize(aSavAre,AScan(aSavAre, {|x| AllTrim(x[1]) != ""})) // redimensiona o array para o elemento 1 no vazio
		RestArea1(aSavAre)
	Else
		RestArea1(aSavAre)
	Endif
	//*** fim ***
EndIf

Return(cBase)

/*


Ŀ
Funo	  A093VldCod   Autor  Marcelo Iuspa		    Data  07/06/02 
Ĵ
Descrio  Valida se um codigo inteligente e' valido                     
Ĵ
Parametros cCodigo: Codigo a ser validado                                
           lGera  : Se .T. gera SB1 e SG1 do cCodigo fornecido           
           cDesc  : Passaa por referencia, recebe a descricao do produto 
Ĵ
Retorno	  .T. se for um cCodigo possivel de ser criado         		 
ٱ


*/
Function A093VldCod(cCodigo,lGera,cDesc,aEstr,lChkDisp,lConfirma,lHelpFormula,lPulaGrd,lDefStru,nOpcDef,lMata010,oSayIt)
Local aSavAre      := SaveArea1({"SBQ", "SBP", "SBR", "SBS", "SB1", "SG1", "SGG", "SBT", "SBU", "SBX"})
Local aCod         := {}
Local aCodGrd      := {}
Local aCposSB1     := Nil
Local aDadosSb1	   := {}
Local aID          := {}
Local aPrima       := {}
Local aStr         := {}
Local aTamBase2    := TamSX3("B1_BASE2")
Local aSbpBase     := TamSX3("BP_BASE")
Local aSb1Base     := TamSX3("B1_BASE")
Local aVld         := {}
Local cAliasEstr   := If(SBP->BP_ESTRUT=="2","SGG","SG1")
Local cPrefixo     := If(cAliasEstr == "SG1","G1_","GG_")
Local cBase	       := A093VldBase(cCodigo)
Local cCodBS
Local cCodPrd      := ""
Local cCodNew      := cCodigo
Local cDesPrd      := ""
Local cField
Local cLog		   := ""
Local cRetDesc     := ""
Local cSeek
Local cteste       := ' '
Local lOka         := .T.
Local lInclSB1     := .F.
Local lMt093B1     := Existblock("MT093B1")
Local lA093ACOD    := ExistBlock("A093ACOD")
Local lA093ACODVld := .F.
Local lRet		   := .T.
Local lCPOGrd	   := SBQ->(FieldPos("BQ_TPGRD")>0)
Local lAtuEst      := .T.
Local lTamDesc     := TamSX3("B1_DESC")[1]
Local lIncBkp      := .F.
Local lAltBkp      := .F.
Local nLenID       := Len(SBS->(BS_ID + BS_CODIGO))
Local nProd        := 0
Local nSaveSX8
Local nInd		   := 0
Local nX		   := 0
Local oFormSB1     := Nil
Local oModel       := Nil
Local x, z

DEFAULT lPulaGrd	:= .F.
DEFAULT lDefStru	:= .T.
DEFAULT nOpcDef		:= 1
DEFAULT lMata010	:= .F.
Private l010Auto    := If (Type("l010Auto") =="U",.F.,l010Auto)
Static lNivAlt, lExistA093Desc

If Type("aProd") == "U"
	Private aProd := {}
EndIf

PERGUNTE("MTA093",.F.)

If !Empty(cBase)
	If lExistA093Desc == Nil
		lExistA093Desc := ExistBlock("A093DESC")
	Endif

	lGera        := If(ValType(lGera) = "L", lGera, .F.)
	lHelpFormula := lHelpFormula == Nil .Or. lHelpFormula
	SBP->(dbSeek(xFilial("SBP") + cBase))
	SBR->(dbSeek(xFilial("SBR") + Pad(cBase, Len(SBR->BR_BASE))))

	If ! SBP->BP_DISPUSO == "1" .And. (lChkDisp == Nil .Or. lChkDisp)
		Help(" ",1,"A093DISP")
		lRet := .F.
	Endif

	dbSelectArea("SBQ")
	If lRet .And. !dbSeek(xFilial("SBQ") + cBase)
		lRet := .F.
	Endif

	If lRet .And. lGera .And. ! A093InclOk(cBase)
		lRet := .F.
	Endif

	If lRet .And. !SBP->BP_CODPAD == "2"
		cCodigo := SubStr(cCodigo, Len(AllTrim(cBase)) + 1)
	Endif

	do While ! Eof() .And. SBQ->(BQ_FILIAL + BQ_BASE) == xFilial("SBQ") + cBase .And. lRet
		//Ŀ
		//Verifica se deve pular ou nao a interface de grade                      
		//
		If lCPOGrd .And. (SBQ->BQ_TPGRD $ "12")
			Aadd(aCodGrd,AllTrim(SBQ->BQ_ID))
			If !lGera .And. lPulaGrd
				SBQ->( DbSkip() )
				Loop
			EndIf
		EndIf

		If SBP->BP_CODPAD == "2"
			cCodBS  := Substr(cCodigo, SBQ->BQ_INICIO, SBQ->BQ_TAMANHO)
		Else
			cCodBS  := SubStr(cCodigo, 1, SBQ->BQ_TAMANHO)
			cCodigo := SubStr(cCodigo, SBQ->BQ_TAMANHO + 1)
		Endif
		If SBQ->BQ_TIPDEF == "1"
			If (! SBS->(dbSeek(xFilial("SBS") + SBQ->(BQ_BASE + BQ_ID) + cCodBS))) .Or. SBS->BS_ATIVO == "0"
				cCodBS := Space(SBQ->BQ_TAMANHO)
				lRet := .F.
			Else
				cDesc   := SBS->BS_DESCR
				cDesPrd := SBS->BS_DESCPRD
			Endif
		ElseIf SBQ->BQ_TIPDEF == "2"
			If (! SBX->(dbSeek(xFilial("SBX") + SBQ->BQ_CONJUNT + cCodBS))) .Or. SBX->BX_ATIVO == "0"
				cCodBS := Space(SBQ->BQ_TAMANHO)
				lRet := .F.
			Else
				cDesc   := SBX->BX_DESC
				cDesPrd := SBX->BX_DESCPR
			Endif
		ElseIf SBQ->BQ_TIPDEF == "3"
			cDesc    := Padl(AllTrim(cCodBS), SBQ->BQ_TAMANHO, "0")
			cDesPrd  := Padl(AllTrim(cCodBS), SBQ->BQ_TAMANHO, "0")
		Endif

		&("M->" + "_" +a093IdRec(cBase,SBQ->BQ_ID)) := cCodBS
		&("M->" + "D" +a093IdRec(cBase,SBQ->BQ_ID)) := cDesPrd
		If SBQ->BQ_PRISEC == "1"
			Aadd(aPrima, Pad(SBQ->BQ_ID + cCodBS, nLenID))
		Endif
		Aadd(aID, Pad(SBQ->BQ_ID + cCodBS, nLenID))
		Aadd(aCod, {SBQ->BQ_ID, cCodBS, cDesc, cDesPrd, SBQ->BQ_CONJUNT})
		dbSkip()
	Enddo
	Aadd(aPrima, Space(Len(SBS->(BS_ID + BS_CODIGO))))

	If lRet .And. (lGera .Or. ! aEstr == Nil) .And. !lPulaGrd
		SHK->( DbSetOrder(2) )
		dbSelectArea("SBU")
		dbSeek(cSeek := xFilial("SBU") + cBase + Space(Len(SBU->BU_IDC1) * 2))
		do While ! Eof() .And. SBU->(BU_FILIAL + BU_BASE + BU_IDC1 + BU_IDC2) == cSeek
			If A093VldSBU(, .F.)
				Aadd(aStr, {SBU->BU_COMP, SBU->BU_QUANT, SBU->(RecNo()),SBU->BU_TRT})
			Endif
			dbSkip()
		Enddo
	Endif

	If lRet .And. !lPulaGrd
		For x := 1 to Len(aPrima)
			For z := 1 to Len(aID)
				dbSelectArea("SBT")
				If dbSeek(cSeek := xFilial("SBT") + cBase + aPrima[x]+ aID[z])
					do While ! Eof() .And. BT_FILIAL + BT_BASE + BT_IDC1 + BT_IDC2 == cSeek
						Aadd(aVld, SBT->BT_REGRA)
						dbSkip()
					Enddo
				Endif

				If lGera .Or. ! aEstr == Nil
					dbSelectArea("SBU")
					If dbSeek(cSeek := xFilial("SBU") + cBase + aPrima[x] + aID[z])
						do While ! Eof() .And. BU_FILIAL + BU_BASE + BU_IDC1 + BU_IDC2 == cSeek
							If A093VldSBU(, .F.)
								Aadd(aStr, {SBU->BU_COMP, SBU->BU_QUANT, SBU->(RecNo()),SBU->BU_TRT})
							Endif
							dbSkip()
						Enddo
					Endif
				Endif
			Next
		Next
		For x := 1 to Len(aVld)
			lRet := A093VldSBU(aVld[x], lHelpFormula) // &(cValid)
			If !lRet
				Exit
			Endif
		Next
	EndIf

	If lRet .And. !lPulaGrd
		cCodPrd := AllTrim(cBase)
		cDesPrd := AllTrim(SBR->BR_DESCPRD) + " "

		For x := 1 to Len(aCod)
			cCodPrd +=         aCod[x, 2]
			cDesPrd += AllTrim(aCod[x, 4]) + " "
		Next

		If SBP->BP_CODPAD == "2"
			cCodPrd := a093SubsId(SBP->BP_ESTCOD,SBP->BP_BASE)
			If Len(aCodGrd) > 0 .And. !lGera
				cCodPrd := StrTran(cCodPrd,"+_"+a093IdRec(cBase,aCodGrd[1])+"+_"+a093IdRec(cBase,aCodGrd[2]))
			EndIf
			cCodPrd := &(cCodPrd)
		Endif

		//Ŀ
		//PE que permite alterar o codigo do produto informado pelo      
		//operador.                                                	  
		//Atencao: Neste ponto nao existe mais validacao do codigo       
		//sendo assim quem utilizar o PE deve estar ciente que qualquer  
		//alteracao realizada aqui eh de responsabilidade da customizacao
		//
		If lA093ACOD
			cCodNew := ExecBlock("A093ACOD",.F.,.F.,{cCodPrd, cDesPrd, aCod,aCodGrd,lGera})
			If ValType(cCodNew) == "C" .And. !Empty(cCodNew)
				cCodPrd := cCodNew
				cCodigo := cCodNew
				lA093ACODVld := .T.
			EndIf
		EndIf

		cCodPrd := Pad(cCodPrd, Len(SB1->B1_COD))
		cDesPrd := StrTran(cDesPrd, "  ", " ")
		cDesc   := cDesPrd
		IF SBP->BP_CAMPAD == '2' .And. SBY->(dbSeek(xFilial("SBY")+SBP->BP_BASE+"B1_DESC"))
			cDesc := &(a093SubsId(SBY->BY_EXPRES,SBP->BP_BASE, .T.))
		EndIf

		If lExistA093Desc
			If ValType(cRetDesc := ExecBlock("A093DESC", .F., .F., {cCodPrd, cDesPrd, aCod})) == "C" .And. ! Empty(cRetDesc)
				cDesPrd := cRetDesc
				cDesc   := cRetDesc
			Endif
		Endif

		aEstr := aClone(aStr)
	EndIf

	If lRet .And. mv_par02 == 1 .And. Len(cDesPrd) > lTamDesc .And. ((lGera .And. !IsInCallStack("MATA010")) .Or. (!lGera .And. IsInCallStack("MATA010")))
		IF !MsgYesNo(STR0068+RTrim(cCodPrd)+STR0069+STR0070,STR0057) //A descrio do produto X ultrapassou o limite do campo B1_DESC. Deseja continuar?"
			lRet := .F.
		EndIf
	EndIf

	//Ŀ
	// Caso esteja sendo gerado via MATA010, verifica se o codigo foi			
	// alterado. Neste caso nao deve ser tratado como componente da familia.	
	//
	If lMata010 .And. cCodPrd # SB1->B1_COD
		lRet := .F.
	EndIf

	If lRet .And.  lGera .And. !lPulaGrd
		dbSelectArea("SB1")
		dbSetOrder(1)
		//Ŀ
	    // O campo B1_BASE deve ser maior ou igual ao BP_BASE                     
	    //
		If aSb1Base[1] < Len(Alltrim(SBP->BP_BASE))
			Help(" ",1,ALLTRIM(FWSX3Util():GetDescription('B1_BASE')) + "(B1_BASE)", ,STR0073,1,0, , , , , , {STR0074 + cValToChar(aSbpBase[1]) + "."})
			lRet := .F.
		     //Ŀ
		     // Se no tiver grade faz via MVC, caso contrario, utiliza modelo antigo   
		     //
		ElseIf Empty(aCodGrd)
			For x := 1 to fCount()
				cField := StrTran(FieldName(x), "B1_", "BR_")
				If (nPos := SBR->(FieldPos(cField))) > 0
					Aadd(aDadosSb1,{ FieldName(x),SBR->(FieldGet(nPos))})
				Else
					Aadd(aDadosSb1,{ FieldName(x),CriaVar(FieldName(x))})
				Endif

			Next

			M->B1_DESC := PadR(AllTrim(cDesPrd),Len(SB1->B1_DESC))
			M->B1_COD  := cCodPrd

			A093Campos(cCodPrd)

			cDesPrd := M->B1_DESC

			dbSelectArea("SB1")
			dbSetOrder(1)
			If (lInclSB1 := ! dbSeek(xFilial("SB1") + cCodPrd)) .Or. lGera
				If lConfirma # Nil .And. lConfirma .And. lInclSB1
					lOka:=.F.

					DEFINE MSDIALOG   oDlga TITLE    STR0019 From 0,0 TO 160,400 OF oMainWnd PIXEL //"Inclusao de Produto (Codigo Inteligente)"
					@ 40, 16 Say RetTitle("B1_COD")  + ":"  Size 70, 12 Of oDlga Pixel
					@ 60, 16 Say RetTitle("B1_DESC") + ":"  Size 70, 12 Of oDlga Pixel

					@ 40, 70 MsGet M->cCodPrd When .F. Size 100,5 Of oDlga Pixel
					@ 60, 70 MsGet M->cDesPrd When .F. Size 100,5 Of oDlga Pixel
					@ 500,01 Msget cteste              size 10,10 of oDlga Pixel			   // Campo escondido para forar o foco da tela

					ACTIVATE MSDIALOG oDlga CENTERED ON INIT (EnchoiceBar(oDlga,{||lOka:=.T.,if(loka,oDlga:End(),)},{||lOka:=.F.,if(!lOka,oDlga:End(),)}))

				Endif

				If lOka 
					Begin Transaction

						lIncBkp   := INCLUI
						lAltBkp   := ALTERA

						If lInclSB1

							oModel := FwLoadModel("MATA010")
							oModel:SetOperation( MODEL_OPERATION_INSERT )
							oFormSB1  := oModel:GetModel('SB1MASTER')
							oModel:Activate()
							oModel:GetModel("SB1MASTER"):GetStruct():SetProperty('*', MODEL_FIELD_OBRIGAT,.F.)

							For nX := 1 to len(aDadosSb1)
								If lRet .And. (aDadosSb1[nX][1]) $ "B1_COD|B1_FILIAL|B1_DESC"
									Loop
								EndIf

								If X3Uso(GetSx3Cache(aDadosSb1[nX][1],"X3_USADO"))
									lRet := oFormSB1:LoadValue(aDadosSb1[nX][1],aDadosSb1[nX][2] )
								EndIf		

							Next nX

							If lRet
								oFormSB1:LoadValue("B1_FILIAL", FWxFilial("SB1"))
								oFormSB1:LoadValue("B1_COD", cCodPrd )
								oFormSB1:LoadValue("B1_DESC", cDesPrd)

								cCodBS := ""
								For nInd := 1 to LEN(aCod)
									cCodBS += AllTrim(aCod[nInd,5])
									cCodBS += AllTrim(aCod[nInd,2])
								Next nInd

								oFormSB1:LoadValue("B1_BASE2", cCodBS)

								A093Campos(cCodPrd, .t., oFormSB1)

                                //Valida se o tamanho do cd da familia  compativel com o b1_base2
								If Len(cCodBS) > aTamBase2[1]
										Help(" ",1,ALLTRIM(FWSX3Util():GetDescription('B1_BASE2')) + "(B1_BASE2)",,STR0071,1,0, , , , , , { STR0072 + " " + cValToChar(Len(cCodBS)) + "."})
										lRet := .F.
								EndIf

								If lRet
									If ( lRet := oModel:VldData() )
										lRet := FWFormCommit(oModel)
									ELSE

										cLog := cValToChar(oModel:GetErrorMessage()[MODEL_MSGERR_IDFIELDERR]) + ' - '
										cLog += cValToChar(oModel:GetErrorMessage()[MODEL_MSGERR_ID ]) 				 + ' - '
										cLog += cValToChar(oModel:GetErrorMessage()[MODEL_MSGERR_MESSAGE])
										HELP(' ',1,STR0019 ,,cLog,1,0)

									EndIf
								EndIf

								If lMt093B1
									Execblock("MT093B1",.F.,.F.)
								Endif
							Else

								cLog := cValToChar(oModel:GetErrorMessage()[MODEL_MSGERR_IDFIELDERR]) + ' - '
								cLog += cValToChar(oModel:GetErrorMessage()[MODEL_MSGERR_ID ]) 		  + ' - '
								cLog += cValToChar(oModel:GetErrorMessage()[MODEL_MSGERR_MESSAGE])
								HELP(' ',1,STR0019 ,,cLog,1,0)

							EndIf

						Else

							dbSelectArea("SB1")
							SB1->(dbSetOrder(1))
							If SB1->(DbSeek(FWxFilial("SB1") + cCodPrd))

								oModel := FwLoadModel("MATA010")
								oModel:SetOperation( MODEL_OPERATION_UPDATE )
								oFormSB1 := oModel:GetModel('SB1MASTER')
								oModel:Activate()
								oModel:GetModel("SB1MASTER"):GetStruct():SetProperty('*', MODEL_FIELD_OBRIGAT,.F.)

								cCodBS := ""
								For nInd := 1 to LEN(aCod)
									cCodBS += AllTrim(aCod[nInd,5])
									cCodBS += AllTrim(aCod[nInd,2])
								Next nInd
								oFormSB1:LoadValue("B1_BASE2", cCodBS)

								If Len(cCodBS) > aTamBase2[1]
									Help(" ",1,ALLTRIM(FWSX3Util():GetDescription('B1_BASE2')) + "(B1_BASE2)",,STR0071,1,0, , , , , , { STR0072 + " " + cValToChar(Len(cCodBS)) + "."})
									lRet := .F.
								EndIf

								If lRet
									If ( lRet := oModel:VldData() )
										lRet := FWFormCommit(oModel)
									EndIf
								EndIf

							EndIf
						EndIf

					    If lRet 
							nProd:=ASCAN(aProd,cCodPrd)
							
							INCLUI := lIncBkp
							ALTERA := lAltBkp

							dbSelectArea(cAliasEstr)
							dbSetOrder(1)
							If nProd == 0
								If dbSeek(xFilial(cAliasEstr) + cCodPrd)
									If mv_par01 == 1
										lAtuEst := MsgYesNo(OemToAnsi(STR0067),OemToAnsi(STR0057))  //J existe estrutura cadastrada para esse cdigo de produto. Deseja atualizar?
									Else
										lAtuEst := .F.
									EndIf
								Else
									lAtuEst := .T.
								EndIf
							Else
								lAtuEst := .F.
							EndIf	

							If lAtuEst
								A093ZerEstr(cAliasEstr,aStr,cCodPrd,nOpcDef,cPrefixo,lDefStru,aCod,cBase)
							Endif
							Aadd(aProd, cCodPrd)
						EndIf
					End Transaction
				Else
					lRet := .F.
				Endif
			Endif
		Else
			For x := 1 to fCount()
				cField := StrTran(FieldName(x), "B1_", "BR_")
				If (nPos := SBR->(FieldPos(cField))) > 0
					&("M->" + FieldName(x)) := SBR->(FieldGet(nPos))
				Else
					&("M->" + FieldName(x)) := CriaVar(FieldName(x))
				Endif
			Next
			M->B1_DESC := cDesPrd
			M->B1_COD  := cCodPrd

			A093Campos(cCodPrd)

			cDesPrd := M->B1_DESC

			dbSelectArea("SB1")
			dbSetOrder(1)
			If (lInclSB1 := ! dbSeek(xFilial("SB1") + cCodPrd)) .Or. lGera
				If lConfirma # Nil .And. lConfirma .And. lInclSB1
					lOka:=.F.
					DEFINE MSDIALOG   oDlga TITLE    STR0019 From 0,0 TO 160,400 OF oMainWnd PIXEL //"Inclusao de Produto (Codigo Inteligente)"
					@ 40, 16 Say RetTitle("B1_COD")  + ":"  Size 70, 12 Of oDlga Pixel
					@ 60, 16 Say RetTitle("B1_DESC") + ":"  Size 70, 12 Of oDlga Pixel

					@ 40, 70 MsGet M->cCodPrd When .F. Size 100,5 Of oDlga Pixel
					@ 60, 70 MsGet M->cDesPrd When .F. Size 100,5 Of oDlga Pixel
					@ 500,01 Msget cteste              size 10,10 of oDlga Pixel			   // Campo escondido para forar o foco da tela

					ACTIVATE MSDIALOG oDlga CENTERED ON INIT (EnchoiceBar(oDlga,{||lOka:=.T.,if(loka,oDlga:End(),)},{||lOka:=.F.,if(!lOka,oDlga:End(),)}))
				Endif

 				If lOka
				    cCodBS := ""
					For nInd := 1 to LEN(aCod)
						cCodBS += AllTrim(aCod[nInd,5])
						cCodBS += AllTrim(aCod[nInd,2])
					Next nInd
					If Len(cCodBS) > aTamBase2[1]
						Help(" ",1,ALLTRIM(FWSX3Util():GetDescription('B1_BASE2')) + "(B1_BASE2)",,STR0071,1,0, , , , , , { STR0072 + " " + cValToChar(Len(cCodBS)) + "."})
					Else
						Begin Transaction
							If lInclSB1
								//Salva ambiente SX8
								nSaveSX8:= GetSx8Len()
								RecLock("SB1", .T., .F.)
								For x := 1 to fCount()
									If FieldName(x) $ "B1_COD|B1_FILIAL|B1_DESC|"
										Loop
									EndIf

									cField := FieldName(x)
									&("SB1->" + cField) := &("M->" + cField)
								Next
								SB1->B1_FILIAL := xFilial("SB1")
								SB1->B1_COD    := cCodPrd
								SB1->B1_DESC   := cDesPrd
								SB1->B1_BASE2 := cCodBS

								If !Empty(aCodGrd)
									SB1->B1_GRADE := "S"
								EndIf
								MsUnlock()
								If lMt093B1
									Execblock("MT093B1",.F.,.F.)
								Endif

								If __lSX8
									While ( GetSx8Len() > nSaveSX8 )
										ConfirmSX8()
									Enddo
								EvalTrigger()
								EndIf
							Else
								RecLock("SB1", .F., .F.)
								SB1->B1_BASE2 := cCodBS
								MsUnlock()
							EndIf

							dbSelectArea(cAliasEstr)
							dbSetOrder(1)
							If dbSeek(xFilial(cAliasEstr) + cCodPrd)
								If mv_par01 == 1
									lAtuEst := MsgYesNo(OemToAnsi(STR0067),OemToAnsi(STR0057))  //J existe estrutura cadastrada para esse cdigo de produto. Deseja atualizar?
								Else
									lAtuEst := .F.
								EndIf
							Else
								lAtuEst := .T.
							EndIf

							If lAtuEst
								A093ZerEstr(cAliasEstr,aStr,cCodPrd,nOpcDef,cPrefixo,lDefStru,aCod,cBase)
							Endif
						End Transaction
					EndIf
				Else
					lRet := .F.
				Endif
			Endif
		Endif
	EndIf
EndIf

RestArea1(aSavAre)

If !lA093ACOD .or. ( lA093ACOD .and. !lA093ACODVld )
	cCodigo := cCodNew
EndIf

Return lRet

/*


Ŀ
Funo	  A093GerAut   Autor  Marcelo Iuspa		    Data  07/06/02 
Ĵ
Descrio  Combina todas as opcoes possiveis de geracao                  
Ĵ
Parametros Nenhum                                                        
Ĵ
Retorno	  Nenhum                                                        
ٱ


*/
Function A093GerAut()
LOCAL aSize   := {}
LOCAL aInfo   := {}
LOCAL aObjects:= {}
LOCAL aPosObj := {}
Local nOpc	  := 1
Local nLoop   := Nil
Local aSavAre := SaveArea1({"SBQ", "SBR", "SBS", "SBT", "SBU"})
Local aTrab   := {	{"OK"    , "C", 1, 0}, ;
					{"CODIGO", "C", Len(SB1->B1_COD) , 0}, ;
					{"DESCRI"  , "C", Len(SB1->B1_DESC), 0}}
Local aCods   := {}
Local lOk     := .F.
Local lRet    := .T.
Local lDefault:= .T.
Local oTempTable
Local oSayIt  := Nil

Default lAutomacao := .F.

dbSelectArea("SBQ")
dbSetOrder(1)
If !lAutomacao
	dbSeek(xFilial("SBQ") + SBP->BP_BASE)
Else
	dbSeek(xFilial("SBQ") + cFamilia)
Endif
do While ! Eof() .And. BQ_FILIAL + BQ_BASE == xFilial("SBQ") + IIF(lAutomacao, cFamilia, SBP->BP_BASE)
	If SBP->BP_CODPAD == "2" .And. Empty(SBQ->BQ_INICIO)
		aCods := {}
	ElseIf SBQ->BQ_TIPDEF == "1"
		dbSelectArea("SBS")
		dbSeek(xFilial("SBS") + SBQ->(BQ_BASE + BQ_ID))
		Aadd(aCods, {})
		do While ! Eof() .And. BS_FILIAL + BS_BASE + BS_ID == xFilial("SBS") + SBQ->(BQ_BASE + BQ_ID)
			If SBS->BS_ATIVO # "0"
				If SBP->BP_CODPAD == "2"
					Aadd(aCods[Len(aCods)], {AllTrim(BS_CODIGO),AllTrim(BS_ID)})
				Else
					Aadd(aCods[Len(aCods)], {AllTrim(BS_CODIGO),Nil})
				EndIf
			Endif
			dbSkip()
		Enddo
	ElseIf SBQ->BQ_TIPDEF == "2"
		dbSelectArea("SBX")
		dbSeek(xFilial("SBX") + SBQ->BQ_CONJUNT)
		Aadd(aCods, {})
		do While ! Eof() .And. BX_FILIAL + BX_CONJUN == xFilial("SBX") + SBQ->BQ_CONJUNT
			If SBX->BX_ATIVO # "0"
				If SBP->BP_CODPAD == "2"
					Aadd(aCods[Len(aCods)], {AllTrim(BX_CODOP),AllTrim(SBQ->BQ_ID)})
				Else
					Aadd(aCods[Len(aCods)], {AllTrim(BX_CODOP),NIL})
				EndIf
			Endif
			dbSkip()
		Enddo
	ElseIf SBQ->BQ_TIPDEF == "3"
		Aadd(aCods, {})
		For nLoop := SBQ->BQ_INTDE To SBQ->BQ_INTATE Step SBQ->BQ_INTSTEP
			Aadd(aCods[Len(aCods)], {StrZero(nLoop, SBQ->BQ_TAMANHO),Nil,AllTrim(SBQ->BQ_ID)})
		Next
	Endif
	If Len(aCods) == 0
		Help(" ",1,"A093NOSBS",,AllTrim(RetTitle("BQ_CARACT")) + " :  " + AllTrim(SBQ->BQ_ID) + " - " + SBQ->BQ_CARACT,3,1)
		lRet := .F.
		Exit
	Endif
	dbSelectArea("SBQ")
	dbSkip()
Enddo

If lRet .And. !(AllTrim(SBP->BP_DISPUSO)=="1")
	If !MsgYesNo(OemToAnsi(STR0058),OemToAnsi(STR0057)) //"A famlia de produtos no est disponvel para uso. Ainda assim deseja simular a gerao de combinaes?"
		lRet := .F.
	EndIf
Endif

RestArea1(aSavAre)
If lRet
	// Cria Arquivo para markbrowse
	oTempTable := FWTemporaryTable():New("TRB")
	oTempTable:SetFields(aTrab)
	oTempTable:AddIndex("01",{"CODIGO"})
	oTempTable:Create()

	Processa({|| A093Comb(aCods)}, STR0020) //"Gerando combinaes..."

	// Exibe Browse somente se existirem produtos a serem criados! //
	If TRB->(RecCount()) > 0
		TRB->(dbGoTop())

        If !lAutomacao
			Aadd(aObjects,{100,100,.T.,.T.,.F.}) // Indica dimensoes x e y e indica que redimensiona x e y e assume que retorno sera em linha final coluna final (.F.)

			aSize:=MsAdvSize()
			aInfo:={aSize[1],aSize[2],aSize[3],aSize[4],3,3}
			aPosObj:=MsObjSize(aInfo,aObjects,.T.)

			DEFINE MSDIALOG oDlg TITLE OemToAnsi(cCadastro) From aSize[7],0 TO aSize[6],aSize[5] OF oMainWnd PIXEL

			aCpos := {	{"OK"    , "", ''					    , ""}, ;   //"Ok"
						{"CODIGO", "", A093RetDescr("B1_COD")	, ""}, ;
						{"DESCRI", "", A093RetDescr("B1_DESC")	, ""}}

			lInverte:= .F.
			oMark := MsSelect():New("TRB","OK",,aCpos,@lInverte,"x", aPosObj[1])
			oMark:oBrowse:lHasMark := .T.
			oMark:oBrowse:lCanAllMark:=.T.
			oMark:oBrowse:bAllMark := {|| A093MarkAll()}
			oMark:oBrowse:Align := CONTROL_ALIGN_ALLCLIENT

			ACTIVATE MSDIALOG oDlg ON INIT EnchoiceBar(oDlg,{||lOk := .T.,oDlg:End()},{||oDlg:End()})
		Else
			dbSelectArea("TRB")
			DbSetOrder(1)
			If DbSeek(cProd)
				RecLock("TRB", .F.)
					TRB->OK := "x"
				MsUnLock()
				lOk := .T.
			EndIf
		EndIf

		If lOk
			If ! SBP->BP_DISPUSO == "1"
				Help(" ",1,"A093DISP")
			Else
				dbSelectArea("TRB")
				dbGoTop()
				do While ! Eof()
					If TRB->OK == "x"
						FWMsgRun(, {|oSayIt| A093VldCod(TRB->CODIGO,.T.,,,,, .F.,,@lDefault,@nOpc,,oSayIt) }, "Gerando automaticamente o cadastro dos produtos...", "Aguarde")
					Endif
					dbSkip()
				Enddo

				//Ŀ
				// Recalcula os Niveis                                          
				//
				If GetMv('MV_NIVALT') == 'S'
					MA320Nivel(Nil,.T.)
				EndIf

			Endif
		Endif
	Else
		Aviso(STR0042,STR0066,{"Ok"}) //"Aviso"###"No existe nenhum produto a ser criado com o contedo selecionado"
	Endif

	TRB->(dbCloseArea())
	oTempTable:Delete()
EndIf
Return lRet

/*


ͻ
Programa  A093MarkAll  Autor  Marcelo Iuspa     Data   17/06/02   
͹
Desc.     Marca/Desmarca todos os registros                           
͹
Uso        AP6                                                        
ͼ


*/
Function A093MarkAll()
Local nReg := RecNo()
dbGoTop()
dbEval({|| TRB->OK := If(Empty(TRB->OK), "x", " ")})
dbGoto(nReg)
oDlg:Refresh()
Return(.T.)

/*


ͻ
Programa  A093Comb  Autor  Marcelo Iuspa        Data   07/06/02   
͹
Desc.     Combina um array de opcoes em todas as variacoes possives   
͹
ParametrosaComb:= Array com os cadastros                              
͹
Retorno   NULO                                                        
ͼ


*/
Function A093Comb(aComb)
Local x
Local nLen := 0 // Numero Maximo de combinacoes
Local nTotNiveis :=Len(aComb) // Numero total de grupos de composicao
// Conta o numero de combinacoes
For x:=1 to nTotNiveis
	If x == 1
		nLen:=Len(aComb[x])
	Else
		nLen:=nLen*Len(aComb[x])
	EndIf
Next x

// Monta regua com numero de todas as combinacoes
ProcRegua(nLen)

// Monta Arquivo de Trabalho
MontaArq(aComb,nTotNiveis,0,"")
Return

/*


ͻ
Programa  MontaArq  Autor  Rodrigo  A Sartorio  Data   16/09/04   
͹
Desc.     Combina um array de opcoes em todas as variacoes possives   
͹
ParametrosaComb     :=Array com os cadastros                          
          nTotNiveis:=Numero de grupos                                
          nGrupoAtu :=Grupo atual                                     
          cCodigo   :=Codigo parcial ate a chamada                    
          cCodEstr  :=Codigo da estrutura (BP_ESTCOD)                 
͹
Retorno   NULO                                                        
ͼ


*/
Function MontaArq(aComb,nTotNiveis,nGrupoAtu,cCodigo,cCodEstr)
Local x                // Contadores
Local cValida  := ""   // Codigo para validacao
Local cDesc    := ""   // Descricao do produto
Local cCodProd := ""
Local aSBY     := {}
Default cCodigo		:=""  // Parcial do codigo
Default cCodEstr	:=""  // Codigo da estrutura (BP_ESTCOD)
Default nGrupoAtu	:=0   // GrupoAtual
// Soma nivel
nGrupoAtu++
// Compoe o Codigo
For x:=1 to Len(aComb[nGrupoAtu])
	//Criar condicao de controle
	If Empty(cCodigo) .And. SBP->BP_CODPAD == '2'
		cCodEstr := SBP->BP_ESTCOD
		cCodigo	 := cCodEstr
	EndIf
	//Caso nao utilize condicao padrao
	If aComb[nGrupoAtu,x,2]#Nil
		If nGrupoAtu == nTotNiveis
			IncProc()
			cValida := StrTran(If(Empty(cCodEstr),cCodigo,cCodEstr), "@"+aComb[nGrupoAtu,x,2]+"+", "'"+aComb[nGrupoAtu,x,1]+"'+")
			cValida := StrTran(cValida, "@"+aComb[nGrupoAtu,x,2]+" ", "'"+aComb[nGrupoAtu,x,1]+"' ")
			cValida := StrTran(cValida, "@"+aComb[nGrupoAtu,x,2]+",", "'"+aComb[nGrupoAtu,x,1]+"',")
			cValida := StrTran(cValida, "@"+aComb[nGrupoAtu,x,2]+")", "'"+aComb[nGrupoAtu,x,1]+"')")
			cValida := StrTran(cValida, "@"+aComb[nGrupoAtu,x,2]+"}", "'"+aComb[nGrupoAtu,x,1]+"'}")
			cValida := AllTrim(StrTran(cValida, "@"+aComb[nGrupoAtu,x,2]+"]", "'"+aComb[nGrupoAtu,x,1]+"']"))
			cValida := &cValida
			SB1->(dbSetOrder(1))
			If A093VldCod(cValida,.F.,@cDesc,,.F.,,.F.) .And. !SB1->(dbSeek(xFilial("SB1")+Pad(AllTrim(SBP->BP_BASE) + cValida,Len(SB1->B1_COD))))
				RecLock("TRB", .T., .F.)
				TRB->CODIGO := cValida
				TRB->DESCRI := cDesc
				MsUnlock()
			EndIf
		Else
			If Len(aComb) == 2
				cCodEstr := SBP->BP_ESTCOD
				cCodigo	 := cCodEstr
			EndIf
			If At("@"+aComb[nGrupoAtu,x,2],cCodEstr)==0
				cCodEstr := cCodigo
			Else
				cCodigo  := cCodEstr
			EndIf
			cCodEstr := StrTran(cCodEstr, "@"+aComb[nGrupoAtu,x,2]+"+", "'"+aComb[nGrupoAtu,x,1]+"'+")
			cCodEstr := StrTran(cCodEstr, "@"+aComb[nGrupoAtu,x,2]+" ", "'"+aComb[nGrupoAtu,x,1]+"' ")
			cCodEstr := StrTran(cCodEstr, "@"+aComb[nGrupoAtu,x,2]+",", "'"+aComb[nGrupoAtu,x,1]+"',")
			cCodEstr := StrTran(cCodEstr, "@"+aComb[nGrupoAtu,x,2]+")", "'"+aComb[nGrupoAtu,x,1]+"')")
			cCodEstr := StrTran(cCodEstr, "@"+aComb[nGrupoAtu,x,2]+"}", "'"+aComb[nGrupoAtu,x,1]+"'}")
			cCodEstr := StrTran(cCodEstr, "@"+aComb[nGrupoAtu,x,2]+"]", "'"+aComb[nGrupoAtu,x,1]+"']")

			MontaArq(aComb,nTotNiveis,@nGrupoAtu,cCodigo,@cCodEstr)
		EndIf
	Else //Controle Padrao
		If AllTrim(SBP->BP_CODPAD) == '1'
			cValida:=cCodigo+aComb[nGrupoAtu,x,1]
		Else
			cValida := StrTran(If(!Empty(cCodEstr),cCodEstr,cCodigo), "@"+aComb[nGrupoAtu,x,3]+"+", "'"+aComb[nGrupoAtu,x,1]+"'+")
			cValida := StrTran(cValida, "@"+aComb[nGrupoAtu,x,3]+" ", "'"+aComb[nGrupoAtu,x,1]+"' ")
			cValida := StrTran(cValida, "@"+aComb[nGrupoAtu,x,3]+",", "'"+aComb[nGrupoAtu,x,1]+"',")
			cValida := StrTran(cValida, "@"+aComb[nGrupoAtu,x,3]+")", "'"+aComb[nGrupoAtu,x,1]+"')")
			cValida := StrTran(cValida, "@"+aComb[nGrupoAtu,x,3]+"}", "'"+aComb[nGrupoAtu,x,1]+"'}")
			cValida := StrTran(cValida, "@"+aComb[nGrupoAtu,x,3]+"]", "'"+aComb[nGrupoAtu,x,1]+"']")
		EndIf
		If nGrupoAtu == nTotNiveis
			If !AllTrim(SBP->BP_CODPAD) == '1'
				cValida := &(cValida)
				cValida := Substr(cValida,Len(AllTrim(SBP->BP_BASE))+1,Len(cValida))
			EndIf
			IncProc()
			SB1->(dbSetOrder(1))
			If A093VldCod(AllTrim(SBP->BP_BASE)+cValida,.F.,@cDesc,,.F.,,.F.) .And. ! SB1->(dbSeek(xFilial("SB1")+Pad(AllTrim(SBP->BP_BASE) + cValida,Len(SB1->B1_COD))))
				cCodProd := AllTrim(SBP->BP_BASE) + cValida
				//Somente produtos no existentes na SB1 //
				If !SB1->(dbSeek(xFilial("SB1")+Pad(cCodProd,Len(SB1->B1_COD))))
					RecLock("TRB", .T., .F.)
					TRB->CODIGO := cCodProd
					TRB->DESCRI := cDesc
					MsUnlock()
				EndIf
			EndIf
		Else
			MontaArq(aComb,nTotNiveis,@nGrupoAtu,cValida)
		EndIf
	EndIf
Next x
nGrupoAtu--
Return

/*


ͻ
Programa  A093Prod  Autor  Marcelo Iuspa        Data   13/06/02   
͹
Desc.     Valida Gets com uso de codigo inteligente                   
͹
ParametroslGera: Indica se deve ser gerado SB1/SG1                    
͹
Uso        AP6                                                        
ͼ


*/
Function A093Prod(lGera,cReadVar,cContVar,lChkGrade)
Local oModel
Local oModelSB1
Local oModelDA1
Local cBase    := ""
Local cCod     := ""
Local cCodigo  := ""
Local aAreaSB1 := SB1->(GetArea())
Local aAreaSBP := SBP->(GetArea())
Local cDesc    := ""
Local x
Local lRotAuto := Type("lMsHelpAuto") == "L" .And. lMsHelpAuto // Se for usado em Rotina Automatica (MsExecAuto) nao exibe dialogos
Local lContinua:= .T.
Local lRet     := .T.
Local lDefStru := .T.

Private lAtvGrd:= .F. //Controla se existe configuracao de grade no codigo inteligente.

DEFAULT cReadVar := ReadVar()
DEFAULT cContVar := If(Empty(cReadVar), "", &(cReadVar))
DEFAULT lChkGrade := .T.

cBase := A093VldBase(cContVar)
SBP->(dbSetOrder(1))
SBP->(dbSeek(xFilial("SBP")+cBase))

lGera := If(lGera == Nil, .T., lGera)

If Empty(cReadVar) .Or. Empty(cContVar) .Or. Empty(cBase)
	lContinua := .F.
Endif

SB1->(dbSetOrder(1))
If lContinua .And. SB1->(dbSeek(xFilial("SB1") + Pad(cContVar, Len(SB1->B1_COD))))
	lContinua := .F.
Endif

If lContinua .And. !Empty(cBase) .And. "#CONPAD1#" $ "#" + ProcName(1) + "#" + ProcName(2) + "#" + ProcName(3) + "#" + ProcName(4) + "#" + ProcName(5) + "#" + ProcName(6) + "#"
	Help(" ",1,"A093NINC")
	lRet := .F.
Endif

If lContinua .And. lRet .And. !A093DispUso(cBase, .T.)
	lRet := .F.
Endif

If lContinua .And. lRet
	If lRotAuto
		cCod := cContVar
	Else
		//Ŀ
		// Ponto de Entrada para sugerir caracteristicas do produto  
		//
		If ExistBlock("MT093CFG")
			cCod := ExecBlock("MT093CFG",.F.,.F.,{cContVar})
			If ValType(cCod) == "C"
				cContVar := cCod
			Endif
		EndIf
		cCod := A093MontaCod(cContVar,lChkGrade)
		If IsInCallStack("A410ALTERA") .And. ALTERA .And. Empty(cCod)
			cCod := cContVar
		Endif
	Endif
	If ! A093InclOk(cBase)
		lRet := .F.
	Endif
EndIf

If lContinua .And. lRet
	lRet  := A093VldCod(@cCod,.F.,@cDesc,,,!lRotAuto,,lAtvGrd)

	If lRet
		&(cReadVar) := cCod
		//-- Tratamento para formularios em MVC
		If ValType(FWModelActive()) == "O"
			If cReadVar == "M->DA1_CODPRO"	//Tabela de Preos - OMSA010
				oModel    := FWModelActive()
				oModelDA1 := oModel:GetModel("DA1DETAIL")
				oModelDA1:LoadValue("DA1_CODPRO",cCod)
			Else
				oModel   := FWModelActive()
				oModelSB1:= oModel:GetModel("SB1MASTER")
				If oModelSB1 != Nil
					oModelSB1:LoadValue("B1_COD",cCod)
				Else
					FwFldPut(Substr(cReadVar,4),cCod)
				EndIf
			EndIf
		EndIf
		If lGera .And. !lAtvGrd
			//If IsInCallStack("MATA650")
			//	lDefStru := .F.
			//Else
				lDefStru := .T.
			//EndIf
			lRet  := A093VldCod(cCod,.T.,,,, ! lRotAuto,,,lDefStru)

			//---> Obs.: O erro ocorre pq a funo A093VldCod() altera o valor do pergunte MV_PAR02 que j estava com o cdigo inteligente correto,
			//por este motivo que foi colocado a linha abaixo para que seja efetuado a carga com o cdigo novamente para o MV_PAR02 da rotina da Tabela de Preos.
			If  FunName() == "OMSA010" .And. cReadVar == "MV_PAR02"	//F12 - Perguntas da Tabela de Preos - OMSA010
				&(cReadVar) := cCod
			EndIf

			//Ŀ
			// Recalcula os Niveis                                          
			//
			If lRet .And. GetMv('MV_NIVALT') == 'S'
				MA320Nivel(Nil,.T.)
			EndIf

		Else
			SBR->(dbSeek(xFilial("SBR") + cBase))
			For x := 1 to SBR->(fCount())
				If SBR->(FieldName(x)) # "BR_FILIAL" .And. (nPos := (SB1->(FieldPos(StrTran(SBR->(FieldName(x)), "BR_", "B1_"))))) > 0
					&("M->" + SB1->(FieldName(nPos))) := SBR->(FieldGet(x))
				Endif
			Next
			M->B1_COD  := cCod
			M->B1_DESC := Pad(cDesc,Len(SB1->B1_DESC))
			A093Campos(cCod)
		Endif
	Endif
EndIf

RestArea(aAreaSB1)
RestArea(aAreaSBP)
Return(lRet)


/*


ͻ
Programa  A093VldSBUAutor  Marcelo Iuspa        Data   13/06/02   
͹
Desc.     Valida a condicao para adicionar estrutura pelo SBU         
͹
Retorno   True se o componente devera ser adicionado                  
͹
Uso        AP6                                                        
ͼ


*/
Function A093VldSBU(cCond, lMostraHelp)
Local aArea := GetArea()
Local lA093MSG := ExistBlock("A093MSG")
Local cMsg := ""
Local lRet  := .T.
Local cBase := If(cCond==Nil,SBU->BU_BASE,SBP->BP_BASE)
Local x := 0
Local cCondOld := ""

cCond := If(cCond == Nil, SBU->BU_CONDICA, cCond)
cCondOld := cCond
cCond := a093SubsId(cCond,SBP->BP_BASE)

If ! Empty(cCond)
	If A093Form(cCond)
		lRet := &cCond
		If ValType(lRet) # "L"
			HELP(" ",1,"ERR_MSG",,AllTrim(cCond) + " " + STR0023,2,1) //"nao resulta em expressao logica"
			lRet := .T.
		Endif
	Endif
Endif
If ! lRet .And. lMostraHelp # Nil .And. lMostraHelp
	If lA093MSG
		cMsg := ExecBlock("A093MSG",.F.,.F.,{cCondOld})
		If ValType(cMsg) == "C"
			MsgAlert(cMsg)
			lMostraHelp := .F.
		EndIf
	EndIf
	If lMostraHelp //valida novamente pois o PE pode mudar
		Help(" ",1,"A093REGRA",,cCondOld,2,1)
	EndIf
Endif
RestArea(aArea)
Return(lRet)

/*


ͻ
Programa  A093DispUsoAutor  Marcelo Iuspa        Data   19/12/02   
͹
Desc.     Valida se produto esta disponivel para uso                   
͹
Retorno   True se o codigo base estiver disponivel                     
͹
Uso        AP6                                                         
ͼ


*/
Function A093DispUso(cBase, lHelp)
Local aSavAre := SaveArea1({"SBP"})
Local lRet    := Nil
dbSelectArea("SBP")
dbSetOrder(1)
dbSeek(xFilial("SBP") + cBase)
If ! (lRet := SBP->BP_DISPUSO == "1")
	If lHelp # Nil .And. lHelp
		Help(" ",1,"A093DISP")
	Endif
Endif
RestArea1(aSavAre)
Return(lRet)

/*


ͻ
Programa  A093RetDescrAutor  Marcelo Iuspa      Data   25/06/02   
͹
Desc.     Retorna descricao de um campo pelo X3                       
͹
Retorno   X3DESCRIC() do campo fornecido                              
͹
Uso        AP6                                                        
ͼ


*/
Function A093RetDescr(cCampo)
Local aSav := {SX3->(RecNo()), SX3->(IndexOrd())}
Local cRet
SX3->(dbSetOrder(2))
SX3->(dbSeek(cCampo))
cRet := x3descric()
SX3->(dbGoto(      aSav[1] ))
SX3->(dbSetOrder(  aSav[2] ))
Return(cRet)

/*/

Ŀ
Funo     A093Form  Autor  Marcelo Iuspa    i     Data  12/07/02 
Ĵ
Descrio  Rotina verificadora da formula digitada                    
Ĵ
 Uso       MATA093                                                    
ٱ


*/
Function A093Form(cForm)
Local xResult
Local bBlock:=ErrorBlock(),bErro := ErrorBlock( { |e| A093ChekBug(e) } )
Private lRet:=.T.

IF !Empty(cForm)
	Begin Sequence
		xResult := &cForm
	End Sequence

	ErrorBlock(bBlock)
EndIf
Return lRet

/*/

Ŀ
Funo    A093Chekbug  Autor  Marcelo Iuspa        Data  12/07/02 
Ĵ
Descrio  Rotina analizadora do erro                                 
Ĵ
 Uso       MATA093                                                    
ٱ


*/
Static Function A093Chekbug(e)
IF e:gencode > 0
	HELP(" ",1,"ERR_MSG",,e:Description,2,1)
	lRet:=.F.
Endif
Break
Return

/*/

Ŀ
Funo    A093ChkOpc   Autor  Marcelo Iuspa        Data  19/07/02 
Ĵ
Descrio  Checa se existe opcoes para todas as caracteristicas       
Ĵ
 Uso       MATA093                                                    
ٱ


*/
Function A093ChkOpc
Local aSavAre := SaveArea1({"SBQ", "SBR", "SBS", "SBT", "SBU"})
Local lRet    := .T.
Local lAtivo  := .F.
dbSelectArea("SBQ")
If ! (lRet := dbSeek(xFilial("SBQ") + SBP->BP_BASE))
	Help(" ",1, "A093NSBQ")
Endif
Do While ! Eof() .And. lRet .And. SBQ->(BQ_FILIAL + BQ_BASE) == xFilial("SBQ") + SBP->BP_BASE .And. lRet
	If Empty(SBQ->BQ_TIPDEF)
		Help(" ",1,"A093NODEF",,AllTrim(RetTitle("BQ_CARACT")) + " :  " + AllTrim(SBQ->BQ_ID) + " - " + SBQ->BQ_CARACT,3,1)
		lRet := .F.
	ElseIf SBQ->BQ_TIPDEF == "1"
		If ! SBS->(dbSeek(xFilial("SBS") + SBQ->(BQ_BASE + BQ_ID)))
			Help(" ",1,"A093NOSBS",,AllTrim(RetTitle("BQ_CARACT")) + " :  " + AllTrim(SBQ->BQ_ID) + " - " + SBQ->BQ_CARACT,3,1)
			lRet := .F.
		Endif
	ElseIf SBQ->BQ_TIPDEF == "2"
		dbSelectArea("SBX")
		dbSetOrder(1)
		dbSeek(xFilial("SBX") + SBQ->BQ_CONJUNT)
		do While ! Eof() .And. (! lAtivo) .And. SBX->BX_FILIAL + SBX->BX_CONJUN == xFilial("SBX") + SBQ->BQ_CONJUNT
			lAtivo := SBX->BX_ATIVO = "1"
			dbSkip()
		Enddo
		If ! lAtivo
			Help(" ",1,"A093NOSBS",,AllTrim(RetTitle("BQ_CONJUN")) + " :  " + SBQ->BQ_CONJUNT,3,1)
			lRet := .F.
		Endif
	Endif
	dbSelectArea("SBQ")
	dbSkip()
Enddo
RestArea1(aSavAre)
Return(lRet)

/*/

Ŀ
Funo     A093Pri     Autor  Marcelo Iuspa        Data  24/07/02 
Ĵ
Descrio  Retorna chaves primaria / todas (SBT/SBU)                  
Ĵ
 Uso       MATA093                                                    
ٱ


*/
Function A093Pri()
Local aSavAre := SaveArea1({"SBQ", "SBS"})
Local aRetPri := {Space(Len(SBT->BT_IDC1))}
dbSelectArea("SBQ")
dbSeek(xFilial("SBQ") + SBP->BP_BASE)
Do While ! Eof() .And. SBQ->(BQ_FILIAL + BQ_BASE) == xFilial("SBQ") + SBP->BP_BASE
	If SBQ->BQ_PRISEC == "1"
		If SBQ->BQ_TIPDEF == "1"
			dbSelectArea("SBS")
			dbSeek(xFilial("SBS") + SBQ->(BQ_BASE+BQ_ID))
			do While ! Eof() .And. BS_FILIAL + BS_BASE + BS_ID == xFilial("SBS") + SBQ->(BQ_BASE+BQ_ID)
				Aadd(aRetPri, SBS->(BS_ID + BS_CODIGO))
				dbSkip()
			Enddo
		ElseIf SBQ->BQ_TIPDEF == "2"
			dbSelectArea("SBX")
			dbSeek(xFilial("SBX") + SBQ->BQ_CONJUNT)
			do While ! Eof() .And. BX_FILIAL + BX_CONJUN == xFilial("SBX") + SBQ->BQ_CONJUNT
				Aadd(aRetPri, SBQ->BQ_ID + SBX->BX_CONJUN)
				dbSkip()
			Enddo
		Endif
		dbSelectArea("SBQ")
	Endif
	dbSkip()
Enddo
RestArea1(aSavAre)
Return(aRetPri)

/*/

Ŀ
Funo     A093ChavLine Autor  Marcelo Iuspa       Data  24/07/02 
Ĵ
Descrio  Verifica se existe campos chaves duplicados no aCols       
Ĵ
 Uso       MATA093                                                    
ٱ


*/
Function A093ChavLine(aChavUnica)
Local aAux := {}
Local x, y
Local lContinue := .T.
Local lRet	:= .T.
If Atail(aCols[n])
	lContinue := .F.
EndIf
If lContinue
	For x := 1 to Len(aChavUnica)
		nCol := aScan(aHeader, {|z| AllTrim(z[2]) == aChavUnica[x]})
		Aadd(aAux, {aChavUnica[x], nCol, GdFieldGet( aChavUnica[x] , n, .T. )})
	Next
	For x := 1 to Len(aCols)
		If ! x == n .And. ! Atail(aCols[x])
			For y := 1 to Len(aAux)
				If aCols[x, aAux[y, 2]] == aAux[y, 3]
					Help(" ",1,"JAGRAVADO",, RetTitle(aAux[y, 1]) + " :  " + Transform(aAux[y, 3], ""), 3, 0)
					lRet := .F.
				Endif
			Next
		Endif
		If !lRet
			Exit
		EndIf
	Next
EndIf
Return lRet

/*

Ŀ
Funo     A093NaoVazio Autor  Marcelo Iuspa       Data  24/07/02 
Ĵ
Descrio  Verifica campos que nao podem estar vazios                 
Ĵ
 Uso       MATA093                                                    
ٱ


*/
Function A093NaoVazio(aNaoVazio, bCondicao,nLin)
Local x, nCol
Local lContinue := .T.
Local lRet		:= .T.
DEFAULT nLin	:= n

If Atail(aCols[nLin]) .Or. (bCondicao # Nil .And. ! Eval(bCondicao))
	lContinue := .F.
Endif
If lContinue
	For x := 1 to Len(aNaoVazio)
		If Empty(GDFieldGet(aNaoVazio[x],nLin, .T.))
			nCol := GDFieldPos(aNaoVazio[x])
			Help(" ",1,"NVAZIO",, RetTitle(aHeader[nCol, 2]), 3, 0)
			lRet := .F.
			Exit
		Endif
	Next
EndIf
Return lRet

/*/

Ŀ
Funo     A093Mask     Autor  Marcelo Iuspa       Data  09/09/02 
Ĵ
Descrio  Faz tratamento na mascara do SBQ                           
Ĵ
 Uso       MATA093                                                    
ٱ


*/
Function A093Mask(cMask)
cMask := StrTran(If(cMask == Nil,SBQ->BQ_MASCARA,cMask),"@r","") // Troco @R minusculo e maiusculo para evitar
cMask := StrTran(cMask,"@R","") //  usar upper na mascara
Return AllTrim(cMask)

/*/

Ŀ
Funo     A093Cpo      Autor  Marcelo Iuspa       Data  16/09/02 
Ĵ
Descrio  Faz tratamento no codigo do produto inteligente            
Ĵ
 Uso       MATA093                                                    
ٱ


*/
Function A093Cpo()
Local aSubCod := A093SubCod(M->BP_BASE)
Local lSubCod := .F.
Local lRet    := !Left(LTrim(M->BP_BASE), 3) == "MOD"

If ! lRet
	HELP(" ",1,"A093COD")
Endif

If !Empty(M->BP_BASE)
	aEval(aSubCod, {|z| lSubCod := lSubCod .Or. SBP->(dbSeek(xFilial("SBP") + z))})
	lSubCod := lSubCod .Or. SBP->(dbSeek(xFilial("SBP") + AllTrim(M->BP_BASE)))
	If lSubCod
		HELP(" ",1,"A093CODINV")
		lRet := .F.
	Endif

	If lRet
		SB4->(dbSetOrder(1))
		If SB4->(dbSeek(xFilial("SB4")+AllTrim(M->BP_BASE)))
			Help(" ",1,"A550REFER")
			lRet := .F.
		EndIf
	EndIf
Endif

Return(lRet)

/*/

Ŀ
Funo     A093SubCod   Autor  Marcelo Iuspa       Data  07/11/03 
Ĵ
Descrio  Compoe os codigos impedidos de serem usados                
Ĵ
 Uso       MATA093                                                    
ٱ


*/
Function A093SubCod(cBase)
Local nLen   := Len(cBase)
Local aArray := Array(Len(AllTrim(cBase)))
aEval(aArray, {|z, w| aArray[w] := Pad(Substr(cBase, 1, w), nLen)})
Return(aArray)

/*


Ŀ
Funcao    A093ActMenu  Autor  Bruno Sobieski       Data 13/02/2001
Ĵ
Descrio  Funcao de chamada do menu                                  
Ĵ
Sintaxe    A093ActMenu( ExpO1, ExpN1, ExpN2, ExpO2 )                  
Ĵ
Retorno    Logico                                                     
Ĵ
Parametros ExpO1 -> Objeto Tree / ExpN1 -> Dimensao X                 
           ExpN2 -> Dimensao Y  / ExpO2 -> Objeto Menu                
Ĵ
   DATA    Programador   Manutencao Efetuada                         
Ĵ
                                                                     
ٱ


*/
Function A093ActMenu(oTree, nX, nY, oMenu )
Local lRet		:=	.T.
Local cCargo 	:= ""
//Ŀ
// Desabilita todos os itens do menu                            
//
AEval( oMenu:aItems, { |x| x:Disable() } )

cCargo := oTree:GetCargo()

//Ŀ
// Habilita as opcoes de acordo com a entidade do tree          
//
If Left( cCargo, 3 ) == "SBP"
	lRet	:=	.F.
ElseIf Left( cCargo, 3 ) == "SBQ"
	oMenu:aItems[1]:Enable()
ElseIf Left( cCargo, 3 ) == "SBS"
	oMenu:aItems[2]:Enable()
	oMenu:aItems[3]:Enable()
	oMenu:aItems[4]:Enable()
Endif

//Ŀ
// Ativa o Menu PopUp                                           
//
If lRet
	oMenu:Activate( nX, nY, oTree )
Endif

Return lRet

/*

Ŀ
Funo    A093EstSBP    Autor Marcelo Iuspa        Data  27/04/02 
Ĵ
Descrio Estruturacao Codigo e Descricao do Produto                  
Ĵ
Sintaxe   A093EstSBP                                                  
Ĵ
 Uso      MATA093                                                     
ٱ


*/
Function A093EstSBP(cAlias, nReg, nOpcx)
Local oDlg,oCbx1,oCbx2
Local lWhen1    := SBP->BP_DISPUSO # "1" .And. SBP->BP_CODPAD == "2"
Local lWhen2    := SBP->BP_DISPUSO # "1" .And. SBP->BP_CAMPAD == "2"
Local lRet		:= .T.
LOCAL aSize     :={}
LOCAL aInfo     :={}
LOCAL aObjects  :={}
LOCAL aPosObj   :={}
Local aCriaCols := {}
Local aCombos   := {{},{}}
Local cExpress  := Space(80)
Local aPosSBQ   := {}
Local aSavSBQ   := SBQ->(GetArea())
Local nFor      := 1
Local lOk       := .F.
Local lCPOGra	:= SBQ->(FieldPos("BQ_TPGRD")) > 0
Local oPanel1
Local oPanel2
Local oPanelRight
Local oPanelLeft

If (! SBP->BP_CODPAD == "2") .And. (! SBP->BP_CAMPAD == "2")
	Help(" ",1,"A093CODPAD")
	lRet := .F.
Endif

Private cVariavel := ""
Private cVariavel2:= ""
Private lTipoGrd  := .F. // Variavel de controle do tratamento de grade

If lRet
	SetEnch(aRotina[nOpcx, 1] + " - " + AllTrim(SBP->BP_BASE) + " - " + SBP->BP_DESCR)

	SBQ->( DbSetOrder( 1 ) )
	SBQ->( DbSeek( xFilial("SBQ") + SBP->BP_BASE ) )

	SBQ->( DbEval( {||	Aadd( aCombos[1], "@" + AllTrim(BQ_ID))  , ;
		Aadd( aCombos[2], "@" + AllTrim(BQ_ID)) ,;
		If(lCPOGra .And. !lTipoGrd .And. (BQ_TPGRD$"12"),lTipoGrd := .T., ) }, ; //Verifica se eh interface grade
		, ;
		{|| ! Eof() .And. BQ_FILIAL + BQ_BASE == xFilial("SBQ") + SBP->BP_BASE} ) )

	RegToMemory("SB1", .T.)
	RegToMemory("SBP", nOpcx == 3)

	If Empty(M->BP_ESTCOD)
		A093LimpaExp()
	Endif

	aHeader   := A610CriaHeader("SBY", "BY_BASE",, .T./*lWalkThru*/ )
	aCriaCols := A610CriaCols("SBY", aHeader, xFilial("SBY") + M->BP_BASE, {|| Alltrim(SBY->(BY_FILIAL + BY_BASE)) == Alltrim(xFilial("SBY") + M->BP_BASE) })
	aCols     := aClone(aCriaCols[1])
	aColsReg  := aClone(aCriaCols[2])

	Aadd(aObjects,{100,070,.T.,.F.,.F.}) // Indica dimensoes x e y e indica que redimensiona x e y e assume que retorno sera em linha final coluna final (.F.)
	Aadd(aObjects,{100,100,.T.,.T.,.F.}) // Indica dimensoes x e y e indica que redimensiona x e y
	aSize:=MsAdvSize()
	aInfo:={aSize[1],aSize[2],aSize[3],aSize[4],3,3}
	aPosObj:=MsObjSize(aInfo,aObjects,.T.)

	DEFINE MSDIALOG oDlg TITLE OemToAnsi(cCadastro) From aSize[7],0 TO aSize[6],aSize[5] OF oMainWnd PIXEL

	@ 000,000 MSPANEL oPanel1 OF oDlg
	@ 000,000 MSPANEL oPanel2 OF oDlg
	@ 000,000 MSPANEL oPanelLeft SIZE __DlgWidth(oDlg)-(__DlgWidth(oDlg)/8),0 OF oPanel2
	@ 000,000 MSPANEL oPanelRight SIZE __DlgWidth(oDlg)/8,0 OF oPanel2

	oPanel2:Align := CONTROL_ALIGN_ALLCLIENT
	oPanelRight:Align := CONTROL_ALIGN_RIGHT
	oPanelLeft:Align := CONTROL_ALIGN_ALLCLIENT

	oCodigo := TGroup():New(aPosObj[1,1], aPosObj[1,2], aPosObj[1,3],aPosObj[1,4],STR0025, oPanel1,,, .T.)	//"Codigo"
	oCodigo:Align := CONTROL_ALIGN_ALLCLIENT

	@ 006,010  Say STR0027  Size 70, 6 Of oPanel1 Pixel //"Variavel:"
	@ 016,010  COMBOBOX oCbx1 VAR cVariavel ITEMS aCombos[1] SIZE 50, 27 OF oPanel1 WHEN lWhen1 PIXEL

	@ 006,070  Say STR0028  Size 70, 8 Of oPanel1 Pixel //"Expressao:"

	@ 016,070  MsGet M->cExpress Size aPosObj[1,4]-200,7 Of oPanel1 WHEN lWhen1 Pixel

	@ 032,010  Say STR0029  Size aPosObj[2][4]- aPosObj[2][1]-20, 8 Of oPanel1 Pixel //"Composio da Mascara:" //"Resultado - Estrutura do Codigo"
	@ 042,010  MsGet oEstcod VAR M->BP_ESTCOD  Size aPosObj[1,4]-20,8 Of oPanel1 WHEN lWhen1 Pixel VALID A093VldExpr(M->BP_ESTCOD,aCombos[1]) .And. CheckSX3("BP_ESTCOD")
	oB1 := TButton():New(014, aPosObj[1,4] - 120,STR0030, oPanel1,{||A093AddVar(cVariavel, @cExpress,aCombos[1])},40,15,,,.F.,.T.,.F.,,.F.,{||lWhen1},,.F.) //"Adiciona"

	ob2 := TButton():New(014, aPosObj[1,4] - 70,STR0031, oPanel1,{|| A093LimpaExp()},60,15,,,.F.,.T.,.F.,,.F.,{||lWhen1},,.F.) //"Limpa Expressao"

	oGet := MSGetDados():New(4,aPosObj[2,2]+05,aPosObj[2,3]-05,aPosObj[2,4]-70,If(lWhen2, 3,1),"A093SbyLnOk","A093SbyTdOk",,lWhen2,,,,,"A093SbyFiOk",,,,oPanelLeft)
	oGet:oBrowse:Align := CONTROL_ALIGN_ALLCLIENT

	@ 010,003  Say STR0027  Size 50, 6 Of oPanelRight Pixel //"Variavel:"
	@ 020,003  COMBOBOX oCbx2 VAR cVariavel2 ITEMS aCombos[2] SIZE 50, 27 OF oPanelRight WHEN lWhen2 PIXEL
	oB3 := TButton():New(040,003,OemToAnsi(STR0030), oPanelRight,{|| A093AddBrw(cVariavel2),A093VldExpr(M->BP_ESTCOD,aCombos[1])},40,15,,,.F.,.T.,.F.,,.F.,{||lWhen2},,.F.) //Adiciona

	//acerto nos folders para nao perder o foco
	DEFINE SBUTTON FROM 5000,5000 TYPE 5 ACTION Allwaystrue() ENABLE OF oDlg

	ACTIVATE MSDIALOG oDlg ON INIT ( EnchoiceBar(oDlg,{||If(A093SbyBtnOk() .And. oGet:TudoOk(),(lOk := .T.,oDlg:End()),lOk := .F.)},{||nOpc:=0,oDlg:End()}),;
		AlignObject(oDlg,{oPanel1,oPanel2},1,2,{120}))

	If lOk
		RecLock("SBP", .F.)
		SBP->BP_ESTCOD := M->BP_ESTCOD
		MsUnlock()
		A610GravaCol(aCols, aHeader, aColsReg, "SBY", {|| SBY->BY_BASE := M->BP_BASE}, "BY_CAMPO, BY_EXPRES")
		aPosSBQ := A093CheckId(SBP->BP_BASE, M->BP_ESTCOD)
		dbSelectArea("SBQ")
		dbSetOrder(2)
		For nFor := 1 to Len(aPosSBQ)
			If dbSeek(xFilial("SBQ") + SBP->BP_BASE + aPosSBQ[nFor, 1])
				RecLock("SBQ", .F.)
				SBQ->BQ_INICIO := aPosSBQ[nFor, 4]
				MsUnlock()
			Endif
		Next
		RestArea(aSavSBQ)
	Endif
EndIf
dbSelectArea("SBP")
Return lRet

/*


ͻ
funcao    A093AddVarAutor  Marcelo Iuspa        Data   03/27/03   
͹
Desc.     Adiciona a Variavel ou a Expressao a estrutura do codigo    
                                                                      
͹
Uso        AP                                                         
ͼ


*/
Function A093AddVar(cBox, cExpressao,aCbx)
Local cAux
Local lContinua := .T.
Local nTam 		:= Len(aCbx)
Local nPos,nI

If Type('lTipoGrd') == 'U'
	lTipoGrd := .F.
EndIf

If Empty(cExpressao) // se expressao vazia adicionar a variavel
	cAux := Alltrim(cBox)
	nPos := AsCan(aCbx,{|x|x==cAux })
	If ((cAux+"+") $ M->BP_ESTCOD) .Or. ((cAux+" ") $ M->BP_ESTCOD)
		Help(" ",1,"A093VARJA",,cBox,3,1)
		lContinua	:= .F.
	ElseIf lTipoGrd
		If (aCbx[nTam] $ M->BP_ESTCOD)
			//Nao  permitido incluir qualquer expressao aps a interface de grade coluna.
			Help(" ",1,"A093GRD005")
			lContinua := .F.
		ElseIf nPos > (nTam-2)
			nTam := If(nPos == nTam,++nTam,nTam) // Se for a ultima possicao ajusta tamanho para validar a linha

			For nI:=1 To nTam-2
				If !(aCbx[nI]$M->BP_ESTCOD)
					// Nao  permitido incluir qualquer interface de grade linha ou coluna, antes de incluir as demais variveis.
					// As variveis de interface de grade devem ser incluidas no final da expresso, sendo que a interface grade
					// linha deve ser incluida antes da interface grade coluna
					Help(" ",1,"A093GRD006")
					lContinua := .F.
					Exit
				EndIf
			Next
		//ElseIf  (aCbx[nTam-1]#cAux .And. aCbx[nTam]#cAux .And. (aCbx[nTam-1] $ M->BP_ESTCOD) .Or. (aCbx[nTam] $ M->BP_ESTCOD))
			//Nao  permitido incluir qualquer expressao aps uma interface de grade linha ou coluna.
		//	Help(" ",1,"A093GRD007")
		//	lContinua := .F.
		EndIf
	EndIf

	If lContinua
		M->BP_ESTCOD := Pad(AllTrim(M->BP_ESTCOD)+'+'+cAux, Len(M->BP_ESTCOD))
	EndIf
Else // Adiciona valor da expressao
	If lTipoGrd .And. ( (aCbx[nTam-1] $ M->BP_ESTCOD) .Or. (aCbx[nTam] $ M->BP_ESTCOD) )
		//Nao  permitido incluir qualquer expressao aps uma interface de grade linha ou coluna.
		Help(" ",1,"A093GRD007")
	Else
		M->BP_ESTCOD := Pad(AllTrim(M->BP_ESTCOD)+'+"'+Alltrim(cExpressao)+'"', Len(M->BP_ESTCOD))
		cExpressao := Space(Len(cExpressao))
	EndIf
EndIf
oEstCod:Refresh()
Return

/*


ͻ
funcao    A093AddBrwAutor  Marcelo Iuspa        Data   03/27/03   
͹
Desc.     Adiciona a Variavel ou a Expressao a estrutura do codigo    
                                                                      
͹
Uso        AP                                                         
ͼ


*/
Function A093AddBrw(cBox)
Local nPosDesc := GDFieldPos("BY_EXPRES")
Local nLen     := Len(SBY->BY_EXPRES)

If Empty(aCols[n, nPosDesc])
	aCols[n, nPosDesc] := Pad(Alltrim(cBox), nLen)
Else
	aCols[n, nPosDesc] := Pad(AllTrim(aCols[n, nPosDesc])+'+'+Alltrim(cBox), nLen)
Endif
Return

/*


ͻ
funcao    A093LimpaExpAutor  Marcelo Iuspa      Data   08/09/03   
͹
Desc.     Limpa o campo de Estrutura do Codigo                        
                                                                      
͹
Uso        MATA093                                                    
ͼ


*/
Function A093LimpaExp()
M->BP_ESTCOD :=Pad('"'+Alltrim(M->BP_BASE)+'"', Len(M->BP_ESTCOD))
Return

/*


ͻ
funcao    A093ExistFieldAutor  Marcelo Iuspa    Data   25/09/03   
͹
Desc.     Checa se um campo existe no arquivo especificado            
                                                                      
͹
Uso        MATA093                                                    
ͼ


*/
Function A093ExistField(cAlias, cField)
Local   lRet   := .T.
Default cField := &(ReadVar())

cField := Upper(AllTrim(cField))

If ! (lRet := (cAlias)->(FieldPos(cField)) > 0)
	Help(" ",1,"REGNOIS",, cField, 5, 0)
Endif
Return(lRet)

/*


ͻ
funcao    A093SbyLnOk   Autor  Marcelo Iuspa    Data   25/09/03   
͹
Desc.     LinOk do SBY (Personalizacao de campos do SB1)              
                                                                      
͹
Uso        MATA093                                                    
ͼ


*/
Function A093SbyLnOk()
lRet := A093NaoVazio({"BY_CAMPO", "BY_EXPRES"}, {|| .T.})
If	lRet
	If !(lRet := GDFieldGet("BY_CAMPO",, .T.) <> PADR("B1_COD",10))
		Aviso(STR0042,STR0054,{"Ok"}) //"Aviso"###"No  permitido informar o campo 'codigo do produto'."
	EndIf
EndIf
Return(lRet)

/*


ͻ
funcao    A093SbyTdOk   Autor  Marcelo Iuspa    Data   25/09/03   
͹
Desc.     LinOk do SBY (Personalizacao de campos do SB1)              
                                                                      
͹
Uso        MATA093                                                    
ͼ


*/
Function A093SbyTdOk()
* Para eventual uso futuro...
Return(.T.)

/*


ͻ
funcao    A093SbyFiOk   Autor  Marcelo Iuspa    Data   25/09/03   
͹
Desc.     TudoOk do SBY (Personalizacao de campos do SB1)             
                                                                      
͹
Uso        MATA093                                                    
ͼ


*/
Function A093SbyFiOk()
* Para eventual uso futuro...
Return(.T.)

/*


ͻ
Programa  A093SbyBtnOkAutor Marcelo Iuspa       Data   07/04/03   
͹
Desc.     Vaida as descricao digitada                                 
                                                                      
͹
Uso        AP                                                         
ͼ


*/
Function A093SbyBtnOk()
Local lRet := .T.
Return(lRet)

/*


ͻ
Programa  A093VldExprAutor  Marcelo Iuspa       Data   07/04/03   
͹
Desc.     Vaida as descricao digitada                                 
                                                                      
͹
Uso        AP                                                         
ͼ


*/
Function A093VldExpr(cDesc,aCbx)
Local aArea := GetArea()
Local lRet := .T.
Local cAux := Alltrim(cDesc)
Local cAux1:=""

If Type('lTipoGrd') == 'U'
	lTipoGrd := .F.
EndIf

If ReadVar() # "M->BY_EXPRES" .And. lTipoGrd .And.  ( aCbx[Len(aCbx)-1] $ cAux .Or. aCbx[Len(aCbx)] $ cAux )
	cAux1:=	AllTrim(aCbx[Len(aCbx)-1]+"+"+aCbx[Len(aCbx)])
	If !(Right(cAux,Len(cAux1))==cAux1)
		//Nao  permitido incluir qualquer expressao aps a interface de grade linha ou coluna.
		Help(" ",1,"A093GRD007")
		lRet	:= .F.
	EndIf
EndIf

// Criar as variaveis para validacao do codigo e descricao
If lRet
	SBQ->(DbSetOrder(1))
	SBQ->(DbSeek(xFilial("SBQ")+SBP->BP_BASE))
	SBQ->(DbEval({||_SetOwnerPrvt("_" +a093IdRec(SBP->BP_BASE,SBQ->BQ_ID),SBQ->BQ_ID)},,{|| !Eof() .And. SBQ->(BQ_FILIAL+BQ_BASE) == xFilial("SBQ")+SBP->BP_BASE}))
    cAux := a093SubsId(cAux,SBP->BP_BASE)
	lRet := A093Form(cAux)
EndIf
RestArea(aArea)
Return(lRet)

/*


Ŀ
 Funo     A093PosButton                                              
Ĵ
 Autor      Marcelo Antonio Iuspa                     Data  30.04.02 
Ĵ
 Descrio  Calcula coluna dos botoes                                  
Ĵ
  Uso       SigaPCP  Advanced                                         
ٱ


*/
Static Function A093PosButton(oDlg, nQuant, nLarg, nPos)
* nPos 1= Esquerda / 2= Centro / 3= Direita
Local aRet := {}
Local nTodos := (nQuant * (nLarg + 4))
Local nInicio
Local x := 0
nPos := If(nPos == Nil, 2, nPos) // Assume centro como default
If nPos == 1
	nInicio := 10
ElseIf nPos == 2
	nInicio := (oDlg:nWidth/4)-(nTodos/2)
ElseIf nPos == 3
	nInicio := (oDlg:nWidth/2)-(nTodos)-4
Endif
For x := 1 to nQuant
	Aadd(aRet, nInicio + ((x - 1) * (nLarg + 4)))
Next
Return(aRet)

/*


Ŀ
 Funo     A093Opc                                                    
Ĵ
 Autor      Marcelo Antonio Iuspa                     Data  23.09.03 
Ĵ
 Descrio  Retorna as opcoes de uma caracteristica                    
Ĵ
  Uso       SigaPCP  Advanced                                         
ٱ


*/
Function A093Opc(cBase, cId, lAtivo, lMsg)
Local aArea  := SaveArea1({"SBP", "SBQ", "SBS", "SBX"})
Local aRet   := {}
Local cSeek  := Nil
Local nLoop  := Nil
Default cId  := ""
lFiltraAtivo := lAtivo # Nil .And. lAtivo
SBP->(MsSeek(xFilial("SBP") + cBase))
SBQ->(dbSetOrder(2))
SBQ->(MsSeek(xFilial("SBQ") + cBase + cId))
dbSelectArea("SBQ")
If dbSeek(xFilial("SBQ") + cBase + cId)
	If SBQ->BQ_TIPDEF == "1"    // Definicao Manual
		dbSelectArea("SBS")
		If dbSeek(cSeek := xFilial("SBS") + cBase + cId)
			do While ! Eof() .And. SBS->(BS_FILIAL + BS_BASE + BS_ID) == cSeek
				if (! lFiltraAtivo) .Or. SBS->BS_ATIVO == "1"
					Aadd(aRet, {BS_CODIGO, BS_DESCR})
				Else
					cId += SBQ->BQ_ID + " "
				Endif
				dbSkip()
			Enddo
		Else
			cId += SBQ->BQ_ID + " "
		Endif
	ElseIf SBQ->BQ_TIPDEF == "2"    // Definicao por Conjunto
		dbSelectArea("SBX")
		If dbSeek(cSeek := xFilial("SBX") + SBQ->BQ_CONJUNT)
			do While ! Eof() .And. SBX->(BX_FILIAL + BX_CONJUN) == cSeek
				if (! lFiltraAtivo) .Or. SBX->BX_ATIVO == "1"
					Aadd(aRet, {BX_CODOP, BX_DESC})
				Endif
				dbSkip()
			Enddo
		Else
			cId += SBQ->BQ_ID + " "
		Endif
	ElseIf SBQ->BQ_TIPDEF == "3"
		For nLoop := SBQ->BQ_INTDE to SBQ->BQ_INTATE Step SBQ->BQ_INTSTEP
			Aadd(aRet, {StrZero(nLoop, SBQ->BQ_TAMANHO), StrZero(nLoop, SBQ->BQ_TAMANHO)})
			Exit
		Next
	Endif
Endif

If lMsg # Nil .And. lMsg .And. Len(aRet) == 0
	Help(" ",1, "A093NOPC",, RetTitle("BQ_ID") + ": " + cId, 2, 0)
Endif
RestArea1(aArea)
Return(aRet)

/*


Ŀ
Funcao    A093AtuVerSBQ   Autor  Marcelo Iuspa     Data 31/03/2004
Ĵ
Descrio  Processamento para varrer o SBQ preenchendo campo BQ_TIPDEF
           USO NA ATUALIZACAO DE VERSAO                               
Ĵ
Sintaxe    A093AtuVerSBQ                                              
ٱ


*/
Function A093AtuVerSBQ()
Local cSeek
Local cId := RetTitle("BQ_ID") + ": "

UpdSet01(SBQ->(LastRec()))

dbSelectArea("SBQ")
dbSeek(cSeek := xFilial("SBQ"))
Do While ! Eof() .And. BQ_FILIAL == cSeek
	UpdInc01(cId + BQ_ID)
	If SBS->(dbSeek(xFilial("SBS") + SBQ->(BQ_BASE + BQ_ID)))
		RecLock("SBQ")
		SBQ->BQ_TIPDEF := "1"
		MsUnlock()
	Endif
	dbSkip()
Enddo
Return Nil

/*


Ŀ
Funcao    A093CheckId     Autor  Marcelo Iuspa     Data 07/04/2004
Ĵ
Descrio  Checagem de posicao inicial das caracteristicas no codigo  
           do produto                                                 
Ĵ
Sintaxe    A093CheckId(cBase, cExpress)                               
ٱ


*/
Function A093CheckId(cBase, cExpress)
Local cDelim   := "@!!"
Local cDelimOk := "@??"
Local aIdSBQ   := A093ORetSBQ(cBase)
Local nPosIniID:= 0
Local cEvalExp := Nil
Local nFor     := Nil

cExpress := a093SubsId(cExpress,SBP->BP_BASE)
aEval(aIdSBQ, {|z, w| cExpress := StrTran(cExpress, "_" + a093IdRec(SBP->BP_BASE,AllTrim(z[1])), '"' + cDelim + z[3] + '"')})
cEvalExp := &(cExpress)
aSort(aIdSBQ,,, {|z, w| z[3]< w[3]})
For nFor :=1 to Len(aIdSBQ)
	nPosIniID := At(cDelim + aIdSBQ[nFor, 3], cEvalExp)
	aIdSBQ[nFor, 4] := nPosIniID - A093CountDelim(cEvalExp,nPosIniID)
	cEvalExp := StrTran(cEvalExp, cDelim + aIdSBQ[nFor, 3], cDelimOk + aIdSBQ[nFor, 3])
Next

aEval(aIdSBQ, {|z, w| cEvalExp := StrTran(cEvalExp, "@??" +z[3],  z[3] )})

If Len(cEvalExp) > (TamSX3("B1_COD")[1])
	Help(" ",1,"A093TAMAN")
	aIdSBQ := {}
Endif
Return(aIdSBQ)

/*
ܝ

Ŀ
Funcao    A093CountDelim  Autor  Erike Y. da Silva Data 16/05/2006
Ĵ
Descrio  Retorna a quantidade de delimitadores que devem ser subtra-
           idos no calculo para gravacao do BP_INICIO.                
Ĵ
Sintaxe    A093CountDelim(cExpressao,nPosIni)                         
ٱ


*/
Static Function A093CountDelim(cExpressao,nPosIni)
Local nDelim := 0
Local nI

//Ŀ
//Loop que analisara a quantidade de delimitadores existentes na 
//expressao ate o inicio da variavel analisada.                  
//
For nI:=At("@",cExpressao) To nPosIni
	If SubStr(cExpressao,nI,3)$ "@!!|@??"
		nDelim++
	EndIf
Next
If !Empty(nDelim)
	nDelim--
EndIf

Return ( nDelim*3 )

/*


Ŀ
Funcao     A093ORetSBQ    Autor  Marcelo Iuspa     Data 07/04/2004
Ĵ
Descrio  Retorna IDs das caracteristicas e informacoes adicionais   
           para auxiliar no calculo da posicao do ID no codigo        
           do produto que sera criado                                 
Ĵ
Sintaxe    A093ORetSBQ(cBase)                                         
ٱ


*/
Function A093ORetSBQ(cBase)
Local aSavAre := {GetArea(), SBQ->(GetArea())}
Local cSeek   := Nil
Local aRetSBQ := {}
Local nAscii  := Asc("A")

dbSelectArea("SBQ")
dbSetOrder(1)
dbSeek(cSeek := xFilial("SBQ") + cBase)
Do while ! Eof() .And. SBQ->(BQ_FILIAL + BQ_BASE) == cSeek
	Aadd(aRetSBQ, {SBQ->BQ_ID, BQ_TAMANHO, Replicate(Chr(nAscii ++), BQ_TAMANHO), 0})
	dbSkip()
Enddo

RestArea(aSavAre[2])
RestArea(aSavAre[1])

Return(aRetSBQ)

/*

Ŀ
Funo    A093EstCod    Autor Marcelo Iuspa        Data  12/04/04 
Ĵ
Descrio Validacao tamanho final de B1_COD                           
Ĵ
 Uso      MATA093                                                     
ٱ


*/
Function A093EstCod(cEstCod)
Local cCodBase
Local cAspas
Local lRet := .T.
Default cEstCod := M->BP_ESTCOD
If Empty(cEstCod)
	lRet := .F.
EndIf

If ReadVar() == "M->BP_ESTCOD"
	cAspas := SubStr(AllTrim(cEstCod),1,1)
	If lRet .And. cAspas#chr(34) .And. cAspas#chr(39)
		lRet := .F.
	EndIf
	If lRet
		cCodBase := cAspas+AllTrim(M->BP_BASE)+cAspas
		If SubStr(AllTrim(cEstCod),1,Len(cCodBase))#cCodBase
			lRet := .F.
		EndIf
	EndIf
EndIf
If lRet .And. Len(A093CheckId(SBP->BP_BASE, cEstCod)) == 0
	lRet := .F.
Endif
Return lRet

/*

Ŀ
Funo    A093SBSVars   Autor Marcelo Iuspa        Data  12/04/04 
Ĵ
Descrio Retorna array com as opcoes de cada caracteristica          
Ĵ
 Uso      MATA093                                                     
ٱ


*/
Function A093SBSVars(cCodigo)
Local cCodBS  := Nil
Local cDescBS := Nil
Local aSavAre := {GetArea(), SBQ->(GetArea()), SBS->(GetArea())}
Local aRet    := {}

If ! SBP->BP_CODPAD == "2"
	cCodigo := SubStr(cCodigo, Len(AllTrim(SBP->BP_BASE)) + 1)
Endif
dbSelectArea("SBQ")
dbSeek(xFilial("SBQ") + SBP->BP_BASE)
do While ! Eof() .And. SBQ->(BQ_FILIAL + BQ_BASE) == xFilial("SBQ") + SBP->BP_BASE
	If SBP->BP_CODPAD == "2"
		cCodBS  := Substr(cCodigo, SBQ->BQ_INICIO, SBQ->BQ_TAMANHO)
	Else
		cCodBS  := SubStr(cCodigo, 1, SBQ->BQ_TAMANHO)
		cCodigo := SubStr(cCodigo, SBQ->BQ_TAMANHO + 1)
	Endif
	If SBQ->BQ_TIPDEF == "1"
		SBS->(dbSeek(xFilial("SBS") + SBQ->(BQ_BASE + BQ_ID) + cCodBS))
		cDescBS := SBS->BS_DESCPRD
	ElseIf SBQ->BQ_TIPDEF == "2"
		SBX->(dbSeek(xFilial("SBX") + SBQ->BQ_CONJUNT + cCodBS))
		cDescBS := SBX->BX_DESCPR
	ElseIf SBQ->BQ_TIPDEF == "3"
		cDescBS := cCodBS
	Endif
	Aadd(aRet, {SBQ->BQ_ID, cCodBS,cDescBS})
	dbSkip()
Enddo
RestArea(aSavAre[3])
RestArea(aSavAre[2])
RestArea(aSavAre[1])
Return(aRet)

/*

Ŀ
Funo    A093Campos    Autor Marcelo Iuspa        Data  12/04/04 
Ĵ
Descrio Atualiza variaveis de memoria customizadas por SBY          
Ĵ
 Uso      MATA093                                                     
ٱ


*/
Function A093Campos(cCodigo, lModel, oFormSB1)
Local aArea := {GetArea(), SBY->(GetArea()), SBP->(GetArea())}
Local aRet  := {}
Local cSeek := Nil
Local aSBS  := A093SBSVars(cCodigo)
Local lDesc := .F.
Local nFor  := Nil
Local cVar  := Nil
Local cBase := A093VldBase(cCodigo)
Default lModel := .f.

If SBP->(MsSeek(xFilial("SBP")+cBase)) .And. !(SBP->BP_CAMPAD == "1")

	If SBY->(dbSeek(cSeek := xFilial("SBY") + SBP->BP_BASE))
		do While ! SBY->(Eof()) .And. Alltrim(SBY->(BY_FILIAL + BY_BASE)) == Alltrim(cSeek)
			aAdd(aRet, {SBY->BY_CAMPO, SBY->BY_EXPRES})
			SBY->(dbSkip())
		Enddo
	Endif

	For nFor := 1 to Len(aSBS)
		&("M->_" + A093IdRec(SBP->BP_BASE,aSBS[nFor,1])) := AllTrim(aSBS[nFor,2])
		&("M->D" + A093IdRec(SBP->BP_BASE,aSBS[nFor,1])) := AllTrim(aSBS[nFor,3])
	Next
	For nFor := 1 to Len(aRet)
		lDesc := AllTrim(aRet[nFor][1]) == "B1_DESC"
		aRet[nFor, 2] := &(a093SubsId(aRet[nFor, 2],SBP->BP_BASE,lDesc))
		If lModel
			oFormSB1:LoadValue(aRet[nFor, 1], aRet[nFor, 2])
		Else
			&("M->" + aRet[nFor, 1]	) := aRet[nFor, 2]
		EndIf
	Next
EndIf
RestArea(aArea[3])
RestArea(aArea[2])
RestArea(aArea[1])
Return(aRet)

/*

Ŀ
Funo    A093ExistCpo  Autor Marcelo Iuspa        Data  03/07/04 
Ĵ
Descrio Valida opcao informada na simulacao                         
Ĵ
 Uso      MATA093                                                     
ٱ


*/
Function A093ExistCpo(cAlias, cSeek)
Local aArea := {GetArea(), SBS->(GetArea()), SBX->(GetArea())}
Local cHelp := ""
Local lRet  := .T.

If ! ExistCpo(cAlias, cSeek)
	lRet := .F.
Endif

If lRet .And. cAlias == "SBS"
	SBS->(dbSeek(xFilial("SBS") + cSeek))
	cHelp := RetTitle("BQ_CARACT") + ": " + AllTrim(SBS->BS_ID) + " => " + SBS->BS_CODIGO
	lRet  := SBS->BS_ATIVO # "0"
ElseIf lRet .And. cAlias == "SBX"
	SBX->(dbSeek(xFilial("SBX") + cSeek))
	cHelp := RetTitle("BX_CONJUN") + ": " + AllTrim(SBX->BX_CONJUN) + " => " + SBX->BX_CODOP
	lRet  := SBX->BX_ATIVO # "0"
Endif

RestArea(aArea[3])
RestArea(aArea[2])
RestArea(aArea[1])

Return(lRet)

/*/

Ŀ
Funo     A093InclOk   Autor  Marcelo Iuspa       Data  03/01/05 
Ĵ
Descrio  Roda e valida ponto de entrada A093Gera                    
Ĵ
 Uso       MATA093                                                    
ٱ


*/
Function A093InclOk(cBase)
Local lRet093Gera := .T.
Local lRet	:= .T.
Static lRun093Gera := Nil

If lRun093Gera == Nil
	lRun093Gera := ExistBlock("A093Gera")
Endif

If lRun093Gera .And. ValType(lRet093Gera := ExecBlock("A093Gera", .F., .F., {cBase})) == "L" .And. ! lRet093Gera
	lRet := .F.
EndIf
Return lRet

/*

Ŀ
Funo    A093Copia     Autor Erike Yuri da Silva  Data  08/12/05 
Ĵ
Descrio Copia codigo base origem para codigo base destino           
Ĵ
Sintaxe   A093Copia                                                   
Ĵ
 Uso      MATA093                                                     
ٱ


*/
Function A093Copia(cAlias, nReg, nOpcx)
Local oDlg,oGetOrig,oGetDest
Local nField,nRecPos,nI,nOpcao	:= 0
Local cEstCod	:= CriaVar("BP_ESTCOD")
Local aOpcoes	:= {}
Local aRegsSBQ	:= {}
Local aRegsSBT	:= {}
Local aRegsSBU	:= {}
Local aRegsSBR	:= {}
Local aRegsSBY	:= {}
Private cBaseOrig	:= SBP->BP_BASE
Private cBaseDest
Private aFldsAnt	:= {}

//Aguarda informacoes do registro posicionado
For nField:=1 To FCount()
	Aadd(aFldsAnt,FieldGet(nField))
Next

RegToMemory(cAlias,.T.)

DEFINE MSDIALOG oDlg TITLE OemToAnsi(STR0032) From 0,0 TO 140, 200 OF oMainWnd PIXEL //"Copia"

TGroup():New(03, 3, 25, 100,STR0033, oDlg,,, .T.) //"Cod. Base de Origem"
@ 10,10  MSGet oGetOrig VAR cBaseOrig SIZE 80, 10 WHEN .F. OF oDlg PIXEL

TGroup():New(28, 3, 50, 100,STR0034, oDlg,,, .T.) //"Cod. Base de Destino"
@ 35, 010  MSGet oGetDest VAR M->BP_BASE SIZE 80, 10 WHEN !Empty(cBaseOrig) VALID (NaoVazio(M->BP_BASE).And. ExistChav("SB1") .And. ExistChav("SBP") .And. A093Cpo()) OF oDlg PIXEL

DEFINE SBUTTON	FROM 053, 42 TYPE 1  ACTION IF(.T.,(nOpcao:=1, oDlg:End()),) ENABLE OF oDlg PIXEL WHEN !Empty(M->BP_BASE)
DEFINE SBUTTON	FROM 053, 72 TYPE 2  ACTION (nOpcao := 0,oDlg:End()) ENABLE OF oDlg PIXEL

ACTIVATE MSDIALOG oDlg CENTERED

If nOpcao = 1
	lCopia 		:= .T.
	cBaseDest	:= M->BP_BASE
	//Verifica se usuario confirmou a inclusao
	If A093CadSBP(cAlias, nReg, 3)
		aRegsSBQ	:= {}
		aRegsSBR	:= {}
		aRegsSBT	:= {}
		aRegsSBU	:= {}
		aRegsSBY	:= {}
		//Ŀ
		// Carrega informacoes complementares do SBQ                
		//
		DbSelectArea("SBQ")
		DbSetOrder(1)
		DbSeek(xFilial("SBQ")+cBaseOrig)
		While SBQ->( !Eof() .And. BQ_FILIAL+BQ_BASE==xFilial("SBQ")+cBaseOrig )
			Aadd(aRegsSBQ,{BQ_ID,BQ_TIPDEF,BQ_CONJUNT,BQ_INTDE,BQ_INTATE,BQ_INTSTEP})
			SBQ->(DbSkip())
		EndDo
		//Ŀ
		// Carrega informacoes dos dados basicos do produto         
		//
		DbSelectArea("SBR")
		DbSetOrder(1)
		DbSeek(xFilial("SBR")+cBaseOrig)
		nI	:= 0
		While SBR->( !Eof() .And. BR_FILIAL+BR_BASE==xFilial("SBR")+cBaseOrig )
			nI++
			Aadd(aRegsSBR,Array(FCount()))
			For nField:=1 To FCount()
				aRegsSBR[nI,nField] := FieldGet(nField)
			Next
			SBR->(DbSkip())
		EndDo

		//Ŀ
		// Carrega informacoes de restricao para formacao de codigo 
		//
		DbSelectArea("SBT")
		DbSetOrder(1)
		DbSeek(xFilial("SBT")+cBaseOrig)
		nI	:= 0
		While SBT->( !Eof() .And. BT_FILIAL+BT_BASE==xFilial("SBT")+cBaseOrig )
			nI++
			Aadd(aRegsSBT,Array(FCount()))
			For nField:=1 To FCount()
				aRegsSBT[nI,nField] := FieldGet(nField)
			Next
			SBT->(DbSkip())
		EndDo
		//Ŀ
		// Carrega informacoes da composicao da estrutura           
		//
		DbSelectArea("SBU")
		DbSetOrder(1)
		DbSeek(xFilial("SBU")+cBaseOrig)
		nI	:= 0
		While SBU->( !Eof() .And. BU_FILIAL+BU_BASE==xFilial("SBU")+cBaseOrig )
			nI++
			Aadd(aRegsSBU,Array(FCount()))
			For nField:=1 To FCount()
				aRegsSBU[nI,nField] := FieldGet(nField)
			Next
			SBU->(DbSkip())
		EndDo
		//Ŀ
		// Carrega informacoes da descricao (campos)                
		//
		If SBP->BP_CAMPAD=="2"
			DbSelectArea("SBY")
			DbSetOrder(1)
			DbSeek(xFilial("SBY")+cBaseOrig)
			nI	:= 0
			While SBY->( !Eof() .And. BY_FILIAL+BY_BASE==xFilial("SBY")+cBaseOrig )
				nI++
				Aadd(aRegsSBY,Array(FCount()))
				For nField:=1 To FCount()
					aRegsSBY[nI,nField] := FieldGet(nField)
				Next
				SBY->(DbSkip())
			EndDo
		EndIf
		//Ŀ
		// Inicia copia de dados complementares                     
		//
		DbSelectArea("SBQ")
		DbSetOrder(1)
		DbSeek(xFilial("SBQ")+SBP->BP_BASE)
		While SBQ->( !Eof() .And. BQ_FILIAL+BQ_BASE==xFilial("SBQ")+SBP->BP_BASE )
			nRecPos := AsCan(aRegsSBQ,{|x|x[1]==SBQ->BQ_ID})
			If Empty(nRecPos)
				SBQ->(DbSkip())
				Loop
			EndIf
			//Faz as alteracoes necessarias
			RecLock("SBQ",.f.)
			SBQ->BQ_TIPDEF	:= aRegsSBQ[nRecPos,2]
			SBQ->BQ_CONJUNT	:= aRegsSBQ[nRecPos,3]
			SBQ->BQ_INTDE	:= aRegsSBQ[nRecPos,4]
			SBQ->BQ_INTATE	:= aRegsSBQ[nRecPos,5]
			SBQ->BQ_INTSTEP	:= aRegsSBQ[nRecPos,6]
			SBQ->(MsUnLock())

			//Ŀ
			// Copia os campos da opcao das caracteristicas             
			//
			If SBQ->BQ_TIPDEF $ "12"
				aOpcoes := A098LeOpc(cBaseOrig, SBQ->BQ_ID)
				If Len(aOpcoes) > 0
					A098GrvOpc(SBQ->BQ_BASE, SBQ->BQ_ID, aOpcoes)
				EndIf
			EndIf
			SBQ->(DbSkip())
		EndDo
		//Ŀ
		// Carrega informacoes dos dados basicos do produto         
		//
		If !Empty(aRegsSBR)
			DbSelectArea("SBR")
			For nI:=1 To Len(aRegsSBR)
				RecLock("SBR",.T.)
				For nField:=1 To FCount()
					FieldPut(nField,aRegsSBR[nI,nField])
				Next
				SBR->BR_FILIAL	:= xFilial("SBR")
				SBR->BR_BASE	:= SBP->BP_BASE
				SBR->(MsUnLock())
			Next
		EndIf
		//Ŀ
		// Copia os campos da restricao para formacao de codigo     
		//
		If !Empty(aRegsSBT)
			DbSelectArea("SBT")
			For nI:=1 To Len(aRegsSBT)
				RecLock("SBT",.T.)
				For nField:=1 To FCount()
					FieldPut(nField,aRegsSBT[nI,nField])
				Next
				SBT->BT_FILIAL	:= xFilial("SBT")
				SBT->BT_BASE	:= SBP->BP_BASE
				SBT->(MsUnLock())
			Next
		EndIf
		//Ŀ
		// Copia os campos da composicao da estrutura               
		//
		If !Empty(aRegsSBU)
			DbSelectArea("SBU")
			For nI:=1 To Len(aRegsSBU)
				RecLock("SBU",.T.)
				For nField:=1 To FCount()
					FieldPut(nField,aRegsSBU[nI,nField])
				Next
				SBU->BU_FILIAL	:= xFilial("SBU")
				SBU->BU_BASE	:= SBP->BP_BASE
				SBU->(MsUnLock())
			Next
		EndIf
		//Ŀ
		// Definicao da descricao - [Campos nao padroes]            
		//
		If !Empty(aRegsSBY)
			DbSelectArea("SBY")
			For nI:=1 To Len(aRegsSBY)
				RecLock("SBY",.T.)
				For nField:=1 To FCount()
					FieldPut(nField,aRegsSBY[nI,nField])
				Next
				SBY->BY_FILIAL	:= xFilial("SBY")
				SBY->BY_BASE	:= SBP->BP_BASE
				SBY->(MsUnLock())
			Next
		EndIf
		//Ŀ
		// Definicao da descricao - [Estr. do codigo]               
		//
		If SBP->BP_CODPAD=="2"
			nRecPos := SBP->(RecNo())
			If SBP->(DbSeek(xFilial("SBP")+cBaseOrig))
				cEstCod := SBP->BP_ESTCOD
			EndIf
			SBP->(DbGoto(nRecPos))
			//Ajustando estrutura do codigo para o produto base atual
			cEstCod := '"'+AllTrim(SBP->BP_BASE)+'"'+Substr(cEstCod,Len(AllTrim(cBaseOrig))+3,Len(cEstCod))
			RecLock("SBP",.F.)
			SBP->BP_ESTCOD := cEstCod
			SBP->(MsUnLock())
		EndIf
	EndIf
endif
lCopia	:= .F.
DbSelectArea("SBP")
Return

/*

Ŀ
Funo    A093Inclui    Autor Erike Yuri da Silva  Data  10/01/06 
Ĵ
Descrio Funcao que permite a selecao do tipo de inclusao para contor
          nar a limitacao de 10 itens no aRotina o qual gera nao con- 
          formidade para usuarios nao administrador.                  
Ĵ
Sintaxe   A093MInc                                                    
Ĵ
 Uso      MATA093                                                     
ٱ


*/
Function A093MInc(cAlias, nReg, nOpcx)
Local oDlg
Local nVar := 1
Local nOpcao := 0

DbSelectArea("SBP")
If SBP->(RecCount()) > 0 .And. !Eof()
	DEFINE MSDIALOG oDlg TITLE OemToAnsi(STR0037) From 0,0 TO 100, 240 OF oMainWnd PIXEL  //"Escolha a Opcao de Inclusao"
	TGroup():New(2, 3, 35, 117, , oDlg,,, .T.)
	TRadMenu():New( 005, 005, {STR0038,STR0039}, bSETGET(nVar), oDlg, , ,		; // "Incluir Nova Familia de Produtos"###"Copia a Famlia de Produtos Posicionada"
		,,STR0040, , ,110,15, , , ,.T. )  //"Selecione a opo desejada de incluso"
	DEFINE SBUTTON	FROM 038, 52 TYPE 1  ACTION (nOpcao:=1, oDlg:End()) ENABLE OF oDlg PIXEL
	DEFINE SBUTTON	FROM 038, 82 TYPE 2  ACTION (nOpcao := 0,oDlg:End()) ENABLE OF oDlg PIXEL
	ACTIVATE MSDIALOG oDlg CENTERED
Else
	nOpcao := 1
EndIf
If nOpcao == 1
	Do Case
	Case nVar == 1
		A093CadSBP(cAlias, nReg, 3)
	Case nVar == 2
		A093Copia(cAlias, nReg, 4)
	EndCase
EndIf
DbSelectArea("SBP")
Return

/*


Ŀ
Funo    A093LinOk4 Autor Erike Yuri da Silva      Data  02/03/06
Ĵ
Descrio  Valida a Linha da Getdados                                 
Ĵ
 Uso       MATA093                                                    
ٱ


*/
Function A093LinOk4()
Local nComp			:= aScan(aHeader, {|z| z[2] == "BU_COMP"})
Local nTRT			:= aScan(aHeader, {|z| z[2] == "BU_TRT"})
Local nRec			:= aScan(aHeader, {|z| z[2] == "BU_REC_WT"})
Local nOpcio		:= aScan(aHeader, {|x| x[2] == "BU_OPC"})
Local nGrOpc		:= aScan(aHeader, {|x| x[2] == "BU_GROPC"})
Local aSeq:={},i,lRet:=.T.,nAchoSeq:=0

If (Empty(aCols[n,nGrOpc]) .And. !Empty(aCols[n,nOpcio])) .Or. (!Empty(aCols[n,nGrOpc]) .And. Empty (aCols[n,nOpcio]))
	Help(" ",1,"A093VLDOPC")
	lRet := .F.
Else
	If (!Empty(aCols[n,nGrOpc]) .And. !Empty(aCols[n,nOpcio]))
		lRet := ExistCpo("SGA", aCols[n,nGrOpc]+aCols[n,nOpcio])
	EndIf
EndIf

If lRet
	For i:=1 To Len(aCols)
   		If !aCols[i,Len(aCols[i])]
	   		//Ŀ
	   		// Verifica se ja existe esta sequencia  
	   		//
	   		nAchoSeq:=ASCAN(aSeq,aCols[i,nComp]+If(Empty(nTRT),"",aCols[i,nTRT]) )
	   		If nAchoSeq > 0
		 		Aviso(STR0042,STR0043,{"Ok"}) //"Aviso"###"Ja existe esta chave nos dados informados"
				lRet:=.F.
	   			Exit
	 		Else
			DbSelectArea("SBU")
			DbSetOrder(1)
			If DbSeek(xFilial("SBU")+SBP->BP_BASE+ Space(Len(SBU->BU_IDC1) * 2)+ acols[n,nCOmp]+aCols[n,nTRT])
				if recno() <> acols[n,nRec]
					Aviso("Aviso","Ja Existe esta chave na base de dados, posico :"+cValtoChar(recno()),{"Ok"})
					lRet:=.F.
					Exit
				EndIf
			Else
				AADD(aSeq,aCols[i,nComp]+If(Empty(nTRT),"",aCols[i,nTRT]) )
			Endif
		EndIf
	EndIf
	Next i
EndIf
Return lRet

/*


Ŀ
Funo	  A093IsGrade  Autor  Erike Yuri da Silva    Data 26/07/2006
Ĵ
Descrio  Checa se o produto informado eh codigo inteligente e se possui
           configuracao de grade de produtos.                            
Ĵ
Parametros cCodigo: Codigo ou parte do codigo contendo codigo base       
			  lVldRef: Se true e cCodigo com tamanho diferente do esperado  
			  			altera cCodigo para a base da referencia.			 
Ĵ
Retorno	  Codigo base se encontrado ou branco se nao encontrado		 
ٱ


*/
Function A093IsGrade(cCodigo,lVldRef)
Local aSavAre
Local aCoords	:= {}
Local cBase		:= A093VldBase(cCodigo)
Local lRet		:= .F.
Local lCPOGrd	:= SBQ->(FieldPos("BQ_TPGRD")) > 0
Local nTam		:= 0
Default lVldRef := .F.

If !Empty(cBase)
	aSavAre	:= SaveArea1({"SBP","SBQ"})

	//Posiciona na base de codigo estruturado
	DbSelectArea("SBP")
	DbSetOrder(1)
	DbSeek(xFilial("SBP")+cBase)

	DbSelectArea("SBQ")
	DbSetOrder(1)
	DbSeek(xFilial("SBQ")+cBase)
	While SBQ->( !Eof() .And. BQ_FILIAL+BQ_BASE == xFilial("SBQ")+cBase )

		If SBP->BP_CODPAD == "2"	 // Nao eh codigo padrao
			If lCPOGrd .And. (SBQ->BQ_TPGRD $ "12")
				Aadd(aCoords,SBQ->BQ_INICIO)
			EndIf
		Else
			//Despresa itens que nao sao interface grade
			If lCPOGrd .And. (SBQ->BQ_TPGRD $ "12")
				lRet := .T.
				nTam +=Len(RTrim(cBase))
				Exit
			EndIf
			nTam+=SBQ->BQ_TAMANHO
		Endif

		SBQ->(DbSkip())
	EndDo

	If !Empty(aCoords)
		ASort(aCoords)
		nTam := aCoords[1]-1 //O tamanho total sera o inicio a primeira informacao da interface da grade
		lRet := .T.
	EndIf

	//Ŀ
	// Define o tamanho correto para o codigo de referencia
	//
	If ( lRet )
		cCodigo := Substr(cCodigo,1,nTam)
	EndIf

	If lVldRef .And. Len(AllTrim(cCodigo)) < nTam
		cCodigo := cBase
	EndIf

	RestArea1(aSavAre)
EndIf
Return( lRet )

/*


Ŀ
Funo	  A093CopiaCol Autor  Rodrigo Sartorio       Data 19/10/2006
Ĵ
Descrio  Permite realizar copia de itens dos componentes na especifica-
           cao da da caracteristica.                                     
Ĵ
Parametros Codigo ou parte do codigo contendo codigo base                
Ĵ
Retorno	  Codigo base se encontrado ou branco se nao encontrado		 
ٱ


*/
Function A093CopiaCol(oGet)
aData093C := aClone(aColSBU)
Return

Function A093ColaCol()
If !Empty(aData093C)
	// Forca atualizacao do aCols
	A093AtuAcol(0,aData093C)
	// Simula saida do foco para salvar aCols
	A093LostFocus(2)
EndIf
Return
/*


Ŀ
Funo	  A093GrvSBP  | Autor  Erike Yuri da Silva    Data 14/02/2007
Ĵ
Descrio  Atualiza as tabelas ligadas a familia de produtos             
Ĵ
Parametros ExpN1 : Opcao executada pelo operador (inclusao,alteracao etc)
           ExpA1 : aCols com os dados a serem gravados pela rotina       
           ExpA2 : aHeader com os dados de cabecalho da rotina de familia
           ExpA3 : Array de controle contendo os registro (usados em alte
                   racoes.                                               
Ĵ
Retorno	  Nenhum                                               		 
ٱ


*/
Function A093GrvSBP(nOpcX,aCols, aHeader, aColsReg)
Local nField  := 0

If nOpcx == 10 // Ja passou por validacao entao posso deletar

	//Ŀ
	//Apaga  Caracterisitcas SBQ
	//
	cQuery := " UPDATE " + RetSqlName("SBQ") + " SET D_E_L_E_T_ = '*', R_E_C_D_E_L_ = R_E_C_N_O_ "
	cQuery += "   WHERE BQ_FILIAL = '" + xFilial("SBQ") + "' "
	cQuery += "   AND BQ_BASE = '" + SBP->BP_BASE + "' "
	cQuery += "   AND D_E_L_E_T_ = ' ' "
	TCSqlExec( cQuery )

	//Ŀ
	//Apaga Dados Basicos       
	//
	cQuery := " UPDATE " + RetSqlName("SBR") + " SET D_E_L_E_T_ = '*', R_E_C_D_E_L_ = R_E_C_N_O_  "
	cQuery += "   WHERE BR_FILIAL = '" + xFilial("SBR") + "' "
	cQuery += "   AND BR_BASE = '" + SBP->BP_BASE + "' "
	cQuery += "   AND D_E_L_E_T_ = ' ' "
	TCSqlExec( cQuery )

	//Ŀ
	//Composicao de Estrutura   
	//
	cQuery := " UPDATE " + RetSqlName("SBU") + " SET D_E_L_E_T_ = '*', R_E_C_D_E_L_ = R_E_C_N_O_  "
	cQuery += "   WHERE BU_FILIAL = '" + xFilial("SBU") + "' "
	cQuery += "   AND BU_BASE = '" + SBP->BP_BASE + "' "
	cQuery += "   AND D_E_L_E_T_ = ' ' "
	TCSqlExec( cQuery )

	//Ŀ
	//Restr.para Formacao de Codigo   
	//
	cQuery := " UPDATE " + RetSqlName("SBT") + " SET D_E_L_E_T_ = '*', R_E_C_D_E_L_ = R_E_C_N_O_  "
	cQuery += "   WHERE BT_FILIAL = '" + xFilial("SBT") + "' "
	cQuery += "   AND BT_BASE = '" + SBP->BP_BASE + "' "
	cQuery += "   AND D_E_L_E_T_ = ' ' "
	TCSqlExec( cQuery )

	//Ŀ
	//Apaga Familia de produtos 
	//
	RecLock("SBP", .F., .T.)
	SBP->( dbDelete() )
	SBP->( MsUnlock() )
Else
	If nOpcx == 3 .Or. nOpcx == 4
		RecLock("SBP", nOpcx == 3)
		For nField := 1 TO FCount()
			FieldPut(nField,M->&(FieldName(nField)))
		Next
		SBP->BP_FILIAL := xFilial("SBP")
		MsUnlock()
	EndIf
	A093GravaCol(aCols, aHeader, aColsReg, "SBQ", {|| SBQ->BQ_BASE := M->BP_BASE}, "BQ_ID, BQ_TAMANHO, BQ_PRISEC")
EndIf

dbSelectArea("SBP")
Return

/*


ͻ
Programa  A093AnEstr Autor Erike Yuri da Silva  Data  15/02/2007  
͹
Desc.     Dialog para selecao de opcao de sobreposicao ou nao.        
          demais fatores.                                             
͹
Parametros ExpC1 : Titulo da dialog                                   
           ExpC2 : Texto do grupo de selecao                          
           ExpL1 : Variavel logica de controle de cancelamento que    
                   podera ser utilizada em retorno por referencia     
           ExpL2 : Indica se a opcao selecionada sera defalt para toda
                   ocorrencia da resposta                             
           ExpN1 : Indica qual opcao sera pre-selecionada no grupo.   
͹
Uso        AP                                                         
ͼ


*/
Static Function A093AnEstr(cTitle,cTexto,lCancel,lDefault,nopc)
Local oBtn1
Local oBtn2
Local oDlg
Local oRadio
Local oCheck
Default lCancel		:= .F.
Default lDefault	:= .F.
Default nOpc		:= 1

DEFINE MSDIALOG oDlg FROM 000,000 TO 110,260 TITLE cTitle PIXEL

@ 002,005 SAY cTexto SIZE 120,020  PIXEL
@ 025,005 RADIO oRadio VAR nOpc PROMPT STR0045,STR0046 SIZE 060,009 PIXEL //"Sobrescrever"###"Ignorar"
@ 045,005 CHECKBOX oCheck VAR lDefault Prompt STR0022 SIZE 040,009 PIXEL //"Todos"

DEFINE SBUTTON oBtn1 FROM 030,070 TYPE 1 ENABLE PIXEL ACTION (oDlg:End())
DEFINE SBUTTON oBtn2 FROM 030,107 TYPE 2 ENABLE PIXEL ACTION (nOpc := 2,lCancel := .T.,oDlg:End())

ACTIVATE MSDIALOG oDlg CENTER
Return NIL

/*


ͻ
Programa  A093Filtr6 Autor Erike Yuri da Silva  Data  27/02/2007  
͹
Desc.     Filtro do tipo 6 utilizando em consultas SXB                
͹
Parametros ExpC1 : Alias utilizado no filtro da consulta sxb          
͹
Uso        Configurador de Produtos                                   
ͼ


*/
Function A093Filtr6(cAlias)
Local cChave	:= ""
Local cAux
Local nRecNo
Local nTam := TamSX3("HK_BASE")[1]

If cAlias == "SHK"

	SHK->( DbSetOrder(1) )

	If Type('oTree') == 'O'
		cAux	:= oTree:GetCargo()

		//-- Posicionando na tabela SBQ
		nRecNo	:= Val( Right(cAux,12) )
		SBQ->( DbGoto(nRecNo) )
		cChave	+= "SHK->HK_FILIAL == '"+xFilial(cAlias)+"' "
		cChave  += ".AND. SHK->HK_BASE == '"+SubStr(SBQ->BQ_BASE,1,nTam)+"' "
		cChave	+= ".AND. SHK->HK_ID <> '"+SBQ->BQ_ID+"' "
	Else
		cChave	+= "SHK->HK_FILIAL+SHK->HK_BASE == '"+xFilial(cAlias)+SBQ->BQ_BASE+"' "
	EndIf
EndIf

Return &( cChave )

/*


ͻ
Programa  A093Filtr8 Autor Nilton M K           Data  27/01/2012  
͹
Desc.     Filtro do consulta especifica utilizado no SXB SHKCF1       
͹
Parametros ExpC1 : 													  
͹


*/
Function A093Filtr8(cAlias)
Local cAux
Local nRecNo
Local lRet := .F.
Local nTam := TamSX3("HK_BASE")[1]
Local cChave := ""

If cAlias == "SHK"

	SHK->( DbSetOrder(1) )

	If Type('oTree') == 'O'
		cAux	:= oTree:GetCargo()

		//-- Posicionando na tabela SBQ/
		nRecNo	:= Val( Right(cAux,12) )
		SBQ->( DbGoto(nRecNo) )
		cChave	+= "SHK->HK_FILIAL == '"+xFilial(cAlias)+"' "
		cChave  += " .AND. SHK->HK_BASE == '"+SubStr(SBQ->BQ_BASE,1,nTam)+"' "
	Else
		cChave	+= "SHK->HK_FILIAL+SHK->HK_BASE == '"+xFilial(cAlias)+SubStr(SBP->BP_BASE,1,nTam)+"' "
	EndIf
EndIf

Return &( cChave )

/*


ͻ
Programa  A093VLDFSHKAutor Erike Yuri da Silva  Data  27/02/2007  
͹
Desc.     Valida a selecao da formula da quantidade x caracteristica  
͹
Parametros ExpC1 : Alias utilizado no filtro da consulta sxb          
͹
Uso        Configurador de Produtos                                   
ͼ


*/
Function A093VLDFSHK()
Local aArea		:= GetArea()
Local aSHK		:= {SHK->( IndexOrd() ),SHK->( Recno() )}
Local lRet 		:= .T.
Local cCargo	:= ""
Local cFormula	:= &( ReadVar() )
Local nTam 		:= TamSX3("HK_BASE")[1]
Local nRecNo

If !Empty(cFormula)

	SHK->(DbSetOrder(2))
	If SHK->(DbSeek(xFilial("SHK")+cFormula+SubStr(SBP->BP_BASE,1,nTam)))

		//-- Verifica se a chamada eh originaria da especificacao
		If Type('oTree') == 'O'
			cCargo := oTree:GetCargo()

			//-- Posicionando na tabela SBQ
			nRecNo	:= Val( Right(cCargo,12) )
			SBQ->( DbGoto(nRecNo) )
			If SBQ->(BQ_BASE+BQ_ID) == SHK->(HK_BASE+HK_ID)
				HELP(" ",1,"A093FORMSHK")
				lRet := .F.
			EndIf
		EndIf

	Else
		HELP(" ",1,"REGNOIS")
		lRet := .F.
	EndIf

	//-- Restaura Ambiente
	SHK->( DbSetOrder(aSHK[1]) )
	SHK->( DbGoto(aSHK[2]) )

	RestArea(aArea)
EndIf

Return ( lRet )

/*


Ŀ
Programa  MenuDef    Autor  Fabio Alves Silva      Data 01/11/2006
Ĵ
Descrio  Utilizacao de menu Funcional                               
Ĵ
Retorno   Array com opcoes da rotina.                                 
Ĵ
ParametrosParametros do array a Rotina:                               
          1. Nome a aparecer no cabecalho                             
          2. Nome da Rotina associada                                 
          3. Reservado                                                
          4. Tipo de Transao a ser efetuada:                        
              1 - Pesquisa e Posiciona em um Banco de Dados           
              2 - Simplesmente Mostra os Campos                       
              3 - Inclui registros no Bancos de Dados                 
              4 - Altera o registro corrente                          
              5 - Remove o registro corrente do Banco de Dados        
          5. Nivel de acesso                                          
          6. Habilita Menu Funcional                                  
ٱ

*/
Static Function MenuDef()

Private aRotina := {{ STR0001, "AxPesqui"  , 0 , 1,0,.F.}, ; //"Pesquisar"
	{ STR0002, "A093CadSBP", 0 , 2,0,nil}, ; //"Visualizar"
	{ STR0003, "A093MInc"  , 0 , 3,0,nil}, ; //"Incluir"
	{ STR0004, "A093CadSBP", 0 , 4,0,nil}, ; //"Alterar"
	{ STR0005, "A093EstSBP", 0 , 5,0,nil}, ; //"DescricaS"
	{ STR0006, "A093ConSBP", 0 , 6,0,nil}, ; //"eSpecificacao"
	{ STR0007, "A093SimSBP", 0 , 7,0,nil}, ; //"Simulao"
	{ STR0008, "A093PadSBP", 0 , 8,0,nil}, ; //"Dados Padres"
	{ STR0009, "A093GerAut", 0 , 9,0,nil}, ; //"Gera Autom"
	{ STR0010, "A093CadSBP", 0 , 11,0,nil}, ;  //"Excluir"
	{ STR0060, "A093Subs", 0 , 10,0,nil}}  //"Substituir"

//Ŀ
// Ponto de entrada utilizado para inserir novas opcoes no array aRotina  
//
If ExistBlock("MTA093MNU")
	ExecBlock("MTA093MNU", .F., .F.)
EndIf

Return(aRotina)

/*


ͻ
Programa  A093VLDID  Autor Andre Anjos		  Data  11/12/2007  
͹
Desc.     Valida o ID da caracteristica para garantir que nao ha      
		     caracteres especiais no ID								  
͹
Parametros ExpC1 : Alias utilizado no filtro da consulta sxb          
͹
Uso        Configurador de Produtos                                   
ͼ


*/
Function A093VldID()
Local lRet := .T.
Local nI
Local cID := M->BQ_ID

For nI:=1 to Len(cID)
	If (ASC(Substr(cID,nI,1)) >= 33 .And. ASC(Substr(cID,nI,1)) <= 47) .Or.;
				(ASC(Substr(cID,nI,1)) >= 58 .And. ASC(Substr(cID,nI,1)) <= 64) .Or.;
				(ASC(Substr(cID,nI,1)) >= 91 .And. ASC(Substr(cID,nI,1)) <= 96) .Or.;
				(ASC(Substr(cID,nI,1)) >= 123 .And. ASC(Substr(cID,nI,1)) <= 126)
		MsgInfo(STR0056)//O ID da formula possui caracteres invalidos. Sao caracteres validos apenas letras e numeros."
		lRet := .F.
		Exit
	EndIf
Next nI

Return lRet

/*


Ŀ
Funo    a093IdRec  Autor  Andre Anjos		     Data  10/04/08 
Ĵ
Descrio Transforma um ID de caracteristica no seu Recno		  	  
Ĵ
Uso       MATA093                                                     
ٱ


*/
Static Function a093IdRec(cBase,cId)
Local aArea := GetArea()
Local cRet := 0
Local aAreaBQ := SBQ->(GetArea())

dbSelectArea("SBQ")
dbSetOrder(2)
 dbSeek(xFilial("SBQ")+cBase+cId)
cRet := Right(AllTrim(Str(SBQ->(Recno()))),9)

RestArea(aAreaBQ)
RestArea(aArea)
Return cRet

/*


Ŀ
Funo    a093SubsID Autor  Andre Anjos	     	 Data  19/09/08 
Ĵ
Descrio Substitui um ID de caracteristica por sua variavel  		  
Ĵ
ParametroscExpress: Expressao de formacao do codigo do produto        
			 cBase: Codigo base da familia de produtos                   
			 ?lDesc: Indica se est buscando a descrio                  
Ĵ
Uso       MATA093                                                     
ٱ


*/
Static Function a093SubsID(cExpress,cBase,lDesc)
Local aArea := GetArea()
Local aAreaBQ := SBQ->(GetArea())
Local cRecno := ""
Local nPosIni := 1
Local cRet := AllTrim(cExpress)+Space(1)
Local cID := ""
Default lDesc := .F.

dbSelectArea("SBQ")
dbSetOrder(2)
dbSeek(xFilial("SBQ")+cBase)
While !EOF() .And. BQ_FILIAL+BQ_BASE == xFilial("SBQ")+cBase
	cRecno := a093IdRec(cBase,SBQ->BQ_ID)
	cID := AllTrim(BQ_ID)
	nPosIni := 1

	While !Empty(nPosIni)
		nPosIni := At("@"+cID+"+",cRet)
		If Empty(nPosIni)
			nPosIni := At("@"+cID+" ",cRet)
		EndIf
		If Empty(nPosIni)
			nPosIni := At("@"+cID+",",cRet)
		EndIf
		If Empty(nPosIni)
			nPosIni := At("@"+cID+")",cRet)
		EndIf
		If Empty(nPosIni)
			nPosIni := At("@"+cID+"}",cRet)
		EndIf
		If Empty(nPosIni)
			nPosIni := At("@"+cID+"]",cRet)
		EndIf
		If Empty(nPosIni)
			nPosIni := At("@"+cID+"=",cRet)
		EndIf
		If Empty(nPosIni)
			nPosIni := At("@"+cID+"*",cRet)
		EndIf
		If Empty(nPosIni)
			nPosIni := At("@"+cID+"-",cRet)
		EndIf
		If Empty(nPosIni)
			nPosIni := At("@"+cID+"/",cRet)
		EndIf
		If Empty(nPosIni)
			nPosIni := At("@"+cID+"#",cRet)
		EndIf
		If Empty(nPosIni)
			nPosIni := At("@"+cID+"<>",cRet)
		EndIf
		If Empty(nPosIni)
			nPosIni := At("@"+cID+"!",cRet)
		EndIf
		If Empty(nPosIni)
			nPosIni := At("@"+cID+"$",cRet)
		EndIf
		If !Empty(nPosIni)
			cRet := Substr(cRet,1,nPosIni-1) + IIf(lDesc, "D", "_") +cRecno +Substr(cRet,nPosIni+Len(cID)+1,Len(cRet))
		EndIf
	End

	dbSkip()
End

RestArea(aAreaBQ)
RestArea(aArea)
Return cRet

/*


Ŀ
Funo    A093VldCar Autor  Andre Anjos		     Data  25/09/08 
Ĵ
Descrio Valida o preenchimento dos gets de caracteristicas da tela  
			 de montagem do codigo inteligente							  
Ĵ
ParametrosaObj: Array com os dados dos gets							  
Ĵ
Uso       MATA093                                                     
ĝٱ


*/
Static Function A093VldCar(aObj)
Local lRet := .T.
Local nX := 0

For nx := 1 To Len(aObj)
	If Empty(&("_"+a093IdRec(SBP->BP_BASE,aObj[nx,4])))
		Help(" ",1,"OBRIGAT2",,AllTrim(aObJ[nX,2]),3,0)
		lRet := .F.
		Exit
	EndIf
Next nX

Return lRet
/*


Ŀ
Funo    "VldUniMed" Autor  Acio Ferreira Gomes    Data  22/10/08 
Ĵ
Descrio Valida o preenchimento do campo BR_UM,caso seja digitado um 
			 Contedo que no exista na consulta padro ("SAH").		  
Ĵ
Parametros															  
Ĵ
Uso       MATA093                                                     
ٱ


*/
Function VldUniMed()
Local lRet := .T.
Local cUM  := M->BR_UM

dbSelectArea("SAH")
dbsetOrder(1)
dbSeek(xFilial("SAH")+cUM)
If !Found() .Or. AllTrim(AH_UNIMED) <> AllTrim(cUM)
	Help(' ',1, 'REGNOIS')
	lRet := .F.
Endif

Return lRet

/*


Ŀ
Funo      A093Subs   Autor Rodrigo de T.Silva    Data 07.08.2009
Ĵ
Descrio  Substituicao de componentes no config. produtos            
Ĵ
Parametros Nenhum                                                     
Ĵ
Retorno    Nenhum                                                     
Ĵ
 Uso       MATA093                                                    
ٱ

*/
Function A093Subs()
Local aArea     := GetArea()
Local cCodOrig  := Criavar("B1_COD",.F.)   , cCodDest  := Criavar("B1_COD",.F.)
Local cGrpOrig  := Criavar("GA_GROPC",.F.) , cGrpDest  := Criavar("GA_GROPC",.F.)
Local cOpcOrig  := Criavar("GA_OPC",.F.)   , cOpcDest  := Criavar("GA_OPC",.F.)
Local cDescOrig := Criavar("B1_DESC",.F.)  , cDescDest := Criavar("B1_DESC",.F.)
Local oSay      := NIL
Local oSay2		:= NIL
Local oDlg1		:= NIL
Local lOk 		:= .F.
Local lPyme		:= If(Type("__lPyme") <> "U",__lPyme,.F.)
Local oSize

DEFINE MSDIALOG oDlg1 FROM  140,000 TO 400,615 TITLE STR0061 PIXEL //"Substituicao de Componentes"

//Ŀ
// Calcula dimenses                                            
//
oSize := FwDefSize():New(.T.,,,oDlg1)

oSize:AddObject( "COMPORIGINAL"    ,  100, 50, .T., .T. )
oSize:AddObject( "NEWCOMP"   		,  100, 50, .T., .T. )

oSize:lProp := .T. // Proporcional
oSize:aMargins := { 3, 3, 3, 3 } // Espaco ao lado dos objetos 0, entre eles 3

oSize:Process() // Dispara os calculos

DEFINE SBUTTON oBtn FROM 800,800 TYPE 5 ENABLE OF oDlg1
@ oSize:GetDimension("COMPORIGINAL","LININI")  , oSize:GetDimension("COMPORIGINAL","COLINI")  TO ;
	oSize:GetDimension("COMPORIGINAL","LINEND"), oSize:GetDimension("COMPORIGINAL","COLEND") LABEL STR0062 OF oDlg1 PIXEL //"Componente Original"
@ oSize:GetDimension("NEWCOMP","LININI")  , oSize:GetDimension("NEWCOMP","COLINI") TO ;
	oSize:GetDimension("NEWCOMP","LINEND"), oSize:GetDimension("NEWCOMP","COLEND") LABEL STR0063 OF oDlg1 PIXEL //"Novo Componente"


@ oSize:GetDimension("COMPORIGINAL","LININI")+20,oSize:GetDimension("COMPORIGINAL","COLINI")+3 SAY STR0064   SIZE 24,7  OF oDlg1 PIXEL //"Produto"
@ oSize:GetDimension("NEWCOMP","LININI")+20,oSize:GetDimension("NEWCOMP","COLINI")+3 SAY STR0064   SIZE 24,7  OF oDlg1 PIXEL //"Produto"

@ oSize:GetDimension("COMPORIGINAL","LININI")+20,oSize:GetDimension("COMPORIGINAL","COLINI")+25 MSGET cCodOrig   F3 "SB1" Picture PesqPict("SB1","B1_COD") Valid NaoVazio(cCodOrig) .And. ExistCpo("SB1",cCodOrig) .And. A093AtuDes(cCodOrig,@cDescOrig) SIZE 105,09 OF oDlg1 PIXEL
@ oSize:GetDimension("NEWCOMP","LININI")+20,oSize:GetDimension("NEWCOMP","COLINI")+25 MSGET cCodDest   F3 "SB1" Picture PesqPict("SB1","B1_COD") Valid NaoVazio(cCodDest) .And. ExistCpo("SB1",cCodDest) .And. A093AtuDes(cCodDest,@cDescDest) SIZE 105,9 OF oDlg1 PIXEL


If !lPyme
	@ oSize:GetDimension("COMPORIGINAL","LININI")+20,oSize:GetDimension("COMPORIGINAL","COLINI")+150 SAY RetTitle("BU_GROPC") SIZE 42,13 OF oDlg1 PIXEL
	@ oSize:GetDimension("COMPORIGINAL","LININI")+20,oSize:GetDimension("COMPORIGINAL","COLINI")+180 MSGET cGrpOrig   F3 "SGA" Picture PesqPict("SGA","GA_GROPC") Valid Vazio(cGrpOrig) .Or. ExistCpo("SGA",cGrpOrig) SIZE 15,09 OF oDlg1 PIXEL

	@ oSize:GetDimension("COMPORIGINAL","LININI")+20	,oSize:GetDimension("COMPORIGINAL","COLINI")+225 SAY RetTitle("BU_OPC")   SIZE 30,7  OF oDlg1 PIXEL
	@ oSize:GetDimension("COMPORIGINAL","LININI")+20	,oSize:GetDimension("COMPORIGINAL","COLINI")+250 MSGET cOpcOrig   Picture PesqPict("SGA","GA_OPC") Valid IF(!Empty(cGrpOrig),NaoVazio(cOpcOrig).And.ExistCpo("SGA",cGrpOrig+cOpcOrig),Vazio(cOpcOrig)) SIZE 15,09 OF oDlg1 PIXEL

	@ oSize:GetDimension("NEWCOMP","LININI")+20,oSize:GetDimension("NEWCOMP","COLINI")+150 SAY RetTitle("BU_GROPC") SIZE 42,13 OF oDlg1 PIXEL
	@ oSize:GetDimension("NEWCOMP","LININI")+20,oSize:GetDimension("NEWCOMP","COLINI")+180 MSGET cGrpDest   F3 "SGA" Picture PesqPict("SGA","GA_GROPC") Valid Vazio(cGrpDest) .Or. ExistCpo("SGA",cGrpDest) SIZE 15,09 OF oDlg1 PIXEL

 	@ oSize:GetDimension("NEWCOMP","LININI")+20,oSize:GetDimension("NEWCOMP","COLINI")+225 SAY RetTitle("BU_OPC")   SIZE 30,7  OF oDlg1 PIXEL
	@ oSize:GetDimension("NEWCOMP","LININI")+20,oSize:GetDimension("NEWCOMP","COLINI")+250 MSGET cOpcDest   Picture PesqPict("SGA","GA_OPC") Valid IF(!Empty(cGrpDest),NaoVazio(cOpcDest).And.ExistCpo("SGA",cGrpDest+cOpcDest),Vazio(cOpcDest)) SIZE 15,09 OF oDlg1 PIXEL
EndIf

ACTIVATE MSDIALOG oDlg1 CENTER ON INIT EnchoiceBar(oDlg1,{||(lOk:=.T.,oDlg1:End())},{||(lOk:=.F.,oDlg1:End())})

If lOk //Processa substituicao dos componentes
	Processa({||A093PrSubs(cCodOrig,cGrpOrig,cOpcOrig,cCodDest,cGrpDest,cOpcDest)})
EndIf

RestArea(aArea)
Return

/*


Ŀ
Funo    A093PrSubs   Autor Rodrigo de T. Silva   Data 07.08.2009
Ĵ
Descrio  Monta markbowse para selecao e substituicao dos componentes
Ĵ
Sintaxe    A200PrSubs(ExpC1,ExpC2,ExpC3,ExpC4,ExpC5,ExpC6)            
Ĵ
Parametros ExpC1 = Codigo do produto origem                           
           ExpC2 = Grupo de opcionais origem                          
           ExpC3 = Opcionais do produto origem                        
           ExpC4 = Codigo do produto destino                          
           ExpC5 = Grupo de opcionais destino                         
           ExpC6 = Opcionais do produto destino                       
Ĵ
Retorno    Nenhum                                                     
Ĵ
 Uso       MATA093                                                    
ٱ

*/
Static Function A093PrSubs(cCodOrig,cGrpOrig,cOpcOrig,cCodDest,cGrpDest,cOpcDest)
Local cFilSBU     := ""
Local cQrySBU     := ""
Local aIndexSBU   := {}
Local aBackRotina := ACLONE(aRotina)
//Ŀ
// Variavel lPyme utilizada para Tratamento do Siga PyME        
//
Local lPyme		  := If(Type("__lPyme") <> "U",__lPyme,.F.)
Local aMBrowse    := {{"BU_OK",,"",""},;
      					{"BU_BASE"	 ,,RetTitle("BU_BASE")   ,PesqPict("SBU","BU_BASE")}   ,;
        	            {"BU_IDC2"	 ,,STR0065,""}											,;
                        {"BU_COMP"   ,,RetTitle("BU_COMP")   ,PesqPict("SBU","BU_COMP")}   ,;
  					    {"BU_QUANT"  ,,RetTitle("BU_QUANT")  ,PesqPict("SBU","BU_QUANT")}  ,;
                        {"BU_CONDICA",,RetTitle("BU_CONDICA"),PesqPict("SBU","BU_CONDICA")},;
                        {"BU_FORMSHK",,RetTitle("BU_FORMSHK"),PesqPict("SBU","BU_FORMSHK")},;
                        {"BU_OBS"	 ,,RetTitle("BU_OBS")    ,PesqPict("SBU","BU_OBS")}    ,;
                        {"BU_INI"	 ,,RetTitle("BU_INI")    ,PesqPict("SBU","BU_INI")}    ,;
                        {"BU_FIM"	 ,,RetTitle("BU_FIM")    ,PesqPict("SBU","BU_FIM")}    ,;
                        {"BU_POTENCI",,RetTitle("BU_POTENCI"),PesqPict("SBU","BU_POTENCI")},;
                        {"BU_PERDA"  ,,RetTitle("BU_PERDA")  ,PesqPict("SBU","BU_PERDA")}  ,;
                        {"BU_TRT"	 ,,RetTitle("BU_TRT")    ,PesqPict("SBU","BU_TRT")}}

PRIVATE aDadosDest := {cCodDest,cGrpDest,cOpcDest}
PRIVATE cMarca093  := GetMark( , "SBU", "BU_OK" )
PRIVATE bFiltraBrw := NIL
PRIVATE cCadastro  := OemToAnsi(STR0050)
PRIVATE aRotina    := {{STR0060,"A093DoSub", 0 , 1}} //"Substituir"

cFilSBU := "BU_FILIAL == '" +xFilial("SBU") +"' .And. BU_COMP == '" +cCodOrig +"' "
cFilSBU += ".And. BU_BASE # '" +AllTrim(A093VldBase(cCodDest)) +"' "

cQrySBU := "SBU.BU_FILIAL = '" +xFilial("SBU") +"' AND SBU.BU_COMP = '"+cCodOrig+"' "
cQrySBU += "AND SBU.BU_BASE <> '" +AllTrim(A093VldBase(cCodDest)) +"' "

cFilSBU += " .And.BU_GROPC == '" +cGrpOrig +"' .And. BU_OPC == '" +cOpcOrig +"'"
cQrySBU += " AND SBU.BU_GROPC = '" +cGrpOrig +"' AND SBU.BU_OPC = '" +cOpcOrig +"'"

//Ŀ
//Realiza a Filtragem                                                     
//
dbSelectArea("SBU")
dbSetOrder(1)
bFiltraBrw := {|x| If(x==Nil,FilBrowse("SBU",@aIndexSBU,@cFilSBU),{cFilSBU,cQrySBU,"","",aIndexSBU}) }
Eval(bFiltraBrw)

dbSelectArea("SBU")
If !MsSeek(xFilial("SBU"))
	Help(" ",1,"RECNO")
Else
	//Ŀ
	//Monta o browse para a selecao                                           
	//
	MarkBrow("SBU","BU_OK",,aMBrowse, ,cMarca093)
EndIf

//Ŀ
//Restaura condicao original                                              
//
EndFilBrw("SBU",aIndexSBU)
aRotina := aClone(aBackRotina)

Return Nil

/*


Ŀ
Funo    A093DoSub    Autor Rodrigo de T Silva    Data 07.08.2009
Ĵ
Descrio  Grava a substituicao dos componentes                       
Ĵ
Sintaxe    A200DoSub(ExpC1,ExpN1,ExpN2,ExpC2,ExpC3,ExpL1)             
Ĵ
Parametros ExpC1 = Alias do arquivo	              (OPC)               
           ExpN1 = Numero do registro             (OPC)               
           ExpN2 = Numero da opcao selecionada    (OPC)               
           ExpC2 = Marca para substituicao                            
           ExpL1 = Inverte marcacao                                   
Ĵ
Retorno    Nenhum                                                     
Ĵ
 Uso       MATA093                                                    
ٱ

*/
Function A093DoSub(cAlias,nRecno,nOpcx)
Local aRecnosSBU := {}
Local nZ         := 0

dbSelectArea("SBU")
dbGoTop()
While !EOF()
	// Verifica os registros marcados para substituicao
	If IsMark("BU_OK",cMarca093)
		aAdd(aRecnosSBU,Recno())
	EndIf
	dbSkip()
End

// Grava a substituicao de componentes
If !("DB2" $ TCGetDB())
	cQuery := "UPDATE " +RetSqlName("SBU") +" SET BU_COMP = '" +aDadosDest[1]+"' "
	cQuery += ", BU_GROPC = '" +aDadosDest[2] +"', BU_OPC = '" +aDadosDest[3] +"' "
	cQuery +="WHERE R_E_C_N_O_ IN ("
	For nZ := 1 to Len(aRecnosSBU)
		If nz > 1
			cQuery += ","
		EndIf
		cQuery += "'" +Str(aRecnosSBU[nz],10,0) +"'"
	Next nz
	cQuery += ")"
	TcSqlExec(cQuery)
Else
	For nZ:=1 To Len(aRecnosSBU)
		dbGoto(aRecnosSBU[NZ])
		Reclock("SBU",.F.)
		Replace BU_COMP  With aDadosDest[1]
		MsUnlock()
	Next nZ
EndIf

//Fecha MarkBrow
CloseBrowse()

Return

/*


ͻ
Programa  A093AtuDesAutor  |Andre Anjos          Data   12/08/09   
͹
Descricao  Gatilha descricao do produto na substituicao de componentes
͹
Uso        MATA093                                                    
ͼ


*/
Static Function A093AtuDes(cCod,cDesc)
cDesc := Posicione("SB1",1,xFilial("SB1")+cCod,"B1_DESC")
Return .T.

/*


Ŀ
Funo      a200IniDsc Autor     Eduardo Dias      Data 24/11/2009
Ĵ
Descrio  Inicializa a descricao dos codigos digitados               
Ĵ
Sintaxe    A200IniDsc(ExpN1,ExpO1,ExpC1)                              
Ĵ
Parametros ExpN1 = Indica se esta validando origem (1) ou destino (2) 
           ExpO1 = Objeto say que deve ser atualizado                 
           ExpC1 = Codigo do produto digitado                         
Ĵ
Retorno    True                                                       
Ĵ
 Uso       MATA200                                                    
ٱ

*/

Function A093IniDsc(cId, aOBJ)
Local lRet := .T.
Local nPOSOBJ
Local cConteudo := &(ReadVar())
Local aAreaAnt := GetArea()

nPOSOBJ := aScan (aOBJ,{|x|x[4]==cID})

dbSelectArea('SBQ')
dbSetOrder(2)
dbSeek(xFilial('SBQ') + SBP->BP_BASE + cId)

Do Case

	Case BQ_TIPDEF == '1'
		dbSelectArea('SBS')
		dbSetOrder(1)
		dbSeek(xFilial('SBS') + SBP->BP_BASE + cId + cConteudo)
		cConteudo:= SBS->BS_DESCR

	Case BQ_TIPDEF == '2'
		dbSelectArea('SBX')
		dbSetOrder(1)
		dbSeek(xFilial('SBX') + SBQ->BQ_CONJUNT + cConteudo)
//		cConteudo:= SBX->BX_DESCPR
		cConteudo:= SBX->BX_DESC
EndCase
aOBJ[nposobj][5]:SetText(cConteudo)

&("M->" + "D" + a093IdRec(SBP->BP_BASE,cId)) := cConteudo

RestArea(aAreaAnt)

Return lRet

/*


Ŀ
Funo    a093VldOpc   Autor     Anieli Rodrigues  Data 25/08/2011
Ĵ
Descrio Validacao do item do opcional digitado		              
Ĵ
Sintaxe   A093VldOpc()                                                
Ĵ
ParametrosNenhum                                                      
Ĵ
Retorno    Logico                                                     
Ĵ
 Uso       MATA093                                                    
ٱ

*/

Function A093VldOpc()

Local nPos := aScan (aHeader, {|x| AllTrim(x[2]) == "BU_GROPC"})
Local lRet := .T.

If (Empty(aCols[n,nPos]) .And. !Empty(M->BU_OPC)) .Or. (!Empty(aCols[n,nPos]) .And. Empty (M->BU_OPC))
	Help(" ",1,"A093VLDOPC")
	lRet := .F.
Else
	lRet := ExistCpo("SGA", aCols[n,nPos]+M->BU_OPC)
EndIf

Return lRet

/*

Ŀ
Funo    A093GravaCol  Autor Anieli Rodrigues     Data  15/12/12 
Ĵ
Descrio  Funcao para gravacao do aCols da tabela SBQ                
			 |	 em substituicao a funcao A610GravaCol                    
Ĵ
Sintaxe   A093GravaCol                                                
Ĵ
 Uso      MATA093                                                     
ٱ


*/
Function A093GravaCol(aCols, aHeader, aRegCol, cAlias, bBloco, cCampos,lDeleta)
Local nFilial := 0
Local i, j, z, lEmpty := .F.

Default lDeleta := .F.
Default bBloco  := {|| .T.}

cAlias := If(cAlias = Nil, Alias(), cAlias)
dbSelectArea(cAlias)
nFilial := aScan(dbStruct(), {|x| "_FILIAL" $ x[1]})
For i := 1 to Len(aCols)
	If i <= Len(aRegCol)
		dbGoto(aRegCol[i])
		RecLock(cAlias, .f.)
		If aCols[i, Len(aHeader)+1] .Or. lDeleta
			dbDelete()
			MsUnlock()
			Loop
		Endif
	Else
		If ValType(cCampos) == "C"
			For j := 1 to Len(aHeader)
				If AllTrim(aHeader[j, 2]) $ Upper(cCampos)
					If Empty(aCols[i, j])
						lEmpty := .T.
						Loop
					Endif
				Endif
			Next
		Endif
		If ! aCols[i, Len(aHeader)+1] .And. ! lEmpty
			RecLock(cAlias, .T.)
		Else
			Loop
		Endif
	Endif
	For z := 1 to Len(aHeader)
		If !IsHeadRec(aHeader[z][2]) .And. !IsHeadAlias(aHeader[z][2])
			If (nFieldPos := FieldPos(aHeader[z, 2])) > 0
				FieldPut(nFieldPos, aCols[i, z])
			Endif
		Endif
	Next
	If nFilial > 0
		FieldPut(nFilial, xFilial(cAlias))
	Endif
	Eval(bBloco, i)
	MsUnlock()
Next
Return(.T.)

Static Function MT093Perg()

PERGUNTE("MTA093",.T.)

Return


/*/{Protheus.doc} A093ZerEstr
	Chamado TTYDCQ, instruo para zerar as quantidades da estrutura
	@type  Static Function
	@author maiara cunhago
	@since 02/06/2021
	@version 1
	@param 01 cAliasEstr , Character, Identifica se  a tabela de pr-estrutura ou estrutura
	@param 02 aStr       , Array    , Contem as informaes da composio da estrutura.
	@param 03 cCodPrd    , Character, Identifica o cdigo do produto
	@param 04 nOpcDef    , Numrico , Identifica a opo escolhida:
									  0 - Excluir
									  1 - Pesquisar
									  2 - Visualizar
									  3 - Incluir
									  4 - Alterar
									  5 - Descrio
									  6 - Especificao
									  7 - Simulao
									  8 - Dados Padres
									  9 - Gera Automtico
									  10- Substituir
	@param 05 cPrefixo   , Character, Identifica se  um campo da tabela de Estrutura ou Pr-estrutura
	@param 06 lDefStru   , Lgico   , Informa se  a Estrutura - Pr-estrutura est OK
	@param 07 aCod       , Array    , Contm as informaes de opes do produto.
	@param 08 cBase      , Character, Identifica o Nome/Base da estrutura
	/*/
Static Function A093ZerEstr(cAliasEstr,aStr,cCodPrd,nOpcDef,cPrefixo,lDefStru,aCod,cBase)

Local x, z
Local nQtdEstr
Local lMt093G1  := Existblock("MT093G1")
Local nQuant
Local cField
Local nPos
Local lGrava
Local lLoop
Local lInclui

If !IsInCallStack("MATA093")
	dbSelectArea(cAliasEstr)
	dbSetOrder(1)
	For x := 1 to Len(aStr)
		if( dbSeek(xFilial(cAliasEstr) + cCodPrd + aStr[x, 1]+aStr[x, 4]))
			If !(lDefStru)
				A093AnEstr(STR0047,STR0048+' "'+AllTrim(aStr[x, 1])+'" '+STR0049+' "'+AllTrim(cCodPrd)+'" '+STR0050,NIL,@lDefStru,@nOpcDef) // 'Aguarde' ###'O componente'###
			EndIf

			If( nOpcDef == 1 )
				RecLock(cAliasEstr, .F.)
				(cAliasEstr)->(&(cPrefixo+"QUANT")) := 0
				MsUnlock()
			Endif
		Endif
	Next
Endif
//Fim da manuteno referente ao chamado TTYDCQ

dbSelectArea(cAliasEstr)
dbSetOrder(1)
For x := 1 to Len(aStr)
	lInclui := !dbSeek(xFilial(cAliasEstr) + cCodPrd + aStr[x, 1]+aStr[x, 4])

	If lInclui
		lGrava := .T.
	Else
		If !(lDefStru)
			A093AnEstr(STR0047,STR0048+' "'+AllTrim(aStr[x, 1])+'" '+STR0049+' "'+AllTrim(cCodPrd)+'" '+STR0050,NIL,@lDefStru,@nOpcDef) // 'Aguarde' ###'O componente'###
		EndIf
		lGrava := ( nOpcDef == 1 )
	EndIf

	If lGrava
		SBU->(dbGoto(aStr[x, 3]))

		nQtdEstr := SBU->BU_QUANT

		//-- Verifica se existe formula
		If !Empty(SBU->BU_FORMSHK) .And. !Empty(aCod) .And. SHK->( DbSeek(xFilial("SHK")+SBU->BU_FORMSHK+AllTrim(cBase)))
			//-- Inicializa variavel para controle de loop
			lLoop := .T.
			While SHK->(!Eof()) .And. AllTrim(SHK->(HK_FILIAL+HK_CODIGO+HK_BASE)) == AllTrim(xFilial("SHK")+SBU->BU_FORMSHK+AllTrim(cBase))
				If AsCan(aCod,{|x| Trim(x[1]) == Trim(SHK->HK_ID) .And. Trim(x[2]) == Trim(SHK->HK_CODDEF) }) > 0
					nQtdEstr *= SHK->HK_FATOR
					lLoop := .F.
					Exit
				EndIf
				SHK->( DbSkip() )
			EndDo
		EndIf

		RecLock(cAliasEstr, lInclui)

		If IsInCallStack("MATA093")
			nQuant := IIF(lInclui,nQtdEstr,(cAliasEstr)->(&(cPrefixo+"QUANT"))+nQtdEstr)
		Else
			//If ((cAliasEstr)->(&(cPrefixo+"QUANT"))) > 0
			//	nQuant := ((cAliasEstr)->(&(cPrefixo+"QUANT")))
			//Else
			nQuant := IIF(lInclui,nQtdEstr,(cAliasEstr)->(&(cPrefixo+"QUANT"))+nQtdEstr)
			//EndIf
		EndIf

		For z := 1 to fCount()
			cField := StrTran(FieldName(z), cPrefixo, "BU_")
			cField := If(AllTrim(cField)=="BU_OBSERV","BU_OBS",cField) // Ajuste pois o nome do campo no SBU esta errado
			If (nPos := SBU->(FieldPos(cField))) > 0
				cField := SBU->(FieldGet(nPos))
			Else
				cField := CriaVar(FieldName(z))
			Endif
			FieldPut(z, cField)
		Next z
		(cAliasEstr)->(&(cPrefixo+"FILIAL"))	:= xFilial(cAliasEstr)
		(cAliasEstr)->(&(cPrefixo+"COD"))		:= cCodPrd
		(cAliasEstr)->(&(cPrefixo+"QUANT"))   	:= nQuant
		If cAliasEstr == "SGG"
			SGG->GG_STATUS := "1"
		EndIf

		MsUnlock()
		// ---- Ponto de Entrada Apos a gravacao da tabela SG1 - Estruturas dos Produtos
		If lMt093G1
			Execblock("MT093G1",.F.,.F.)
		EndIf
		If lNivAlt == Nil
			PutMV("MV_NIVALT", "S")
			lNivAlt := .T.
		Endif
	Endif
	dbSkip()
Next x
Return
