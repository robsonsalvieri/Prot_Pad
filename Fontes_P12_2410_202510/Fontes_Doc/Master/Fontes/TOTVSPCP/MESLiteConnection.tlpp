#include "tlpp-core.th"
#include "MESLiteConnection.ch"

#DEFINE KEY_TOKEN_MES_LITE "MESLITERC4"

/*/{Protheus.doc} MESLiteConnection
Classe para conexão com o MES LITE.

@author lucas.franca
@since 04/10/2024
@version P12
/*/
Class MESLiteConnection

	Private data cCaminho             as Character
	Private data cErrorRet            as Character
	Private data cHeaderAuthorization as Character
	Private data cJsonEnviado         as Character
	Private data cToken               as Character
	Private data cValueRet            as Character
	Private data cStatusRet           as Character
	Private data oDescricaoErros      as Json
	Private data oRestClient          as Object

	//Construtor/Destrutor
	Public Method New(cCaminho, cToken)
	Public Method Destroy()

	//Métodos para realizar a requisição e obter os retornos
	Public Method executaDelete(cPath, aParametros)
	Public Method executaGet(cPath, aParametros)
	Public Method executaPost(cPath, jData)
	Public Method getJsonEnviado()
	Public Method houveFalhaDeConexao()
	Public Method obtemMensagemDeErro()
	Public Method retornoAPI(cCode, cValue, cError, lFalhaConexao)

	//Métodos internos
	Private Method carregaConfiguracaoIntegracao()
	Private Method carregaDescricaoErros()
	Private Method inicializaRest()
	Private Method retornaHeader()
	Private Method trataParametros(aParametros)

EndClass

/*/{Protheus.doc} new
Instancia a classe 

@author lucas.franca
@since 04/10/2024
@version P12
@param 01 cCaminho, Character, Caminho de conexão
@param 02 cToken  , Character, Token de autenticação
@return Self, Object, Instância da classe
/*/
Method new(cCaminho as Character, cToken as Character) Class MESLiteConnection
	
	Self:cCaminho     := AllTrim(cCaminho)
	Self:cErrorRet    := ""
	Self:cJsonEnviado := ""
	Self:cToken       := cToken
	Self:cValueRet    := ""
	Self:cStatusRet   := ""

	If Empty(Self:cCaminho) .And. Empty(Self:cToken)
		Self:carregaConfiguracaoIntegracao()
	EndIf

	If Right(Self:cCaminho, 1) $ "/\"
		Self:cCaminho := PadR(Self:cCaminho, Len(Self:cCaminho)-1)
	EndIf

	Self:carregaDescricaoErros()
	Self:inicializaRest()
Return Nil

/*/{Protheus.doc} Destroy
Limpa a classe 

@author lucas.franca
@since 04/10/2024
@version P12
@return Nil
/*/
Method Destroy() Class MESLiteConnection
	FreeObj(Self:oRestClient)
	FreeObj(Self:oDescricaoErros)
Return

/*/{Protheus.doc} carregaDescricaoErros
Carrega o objeto com descrições dos erros

@author lucas.franca
@since 04/10/2024
@version P12
@return Nil
/*/
Method carregaDescricaoErros() Class MESLiteConnection
	Self:oDescricaoErros := JsonObject():New()
	Self:oDescricaoErros["000"] := STR0001 //"Falha de comunicação."
	Self:oDescricaoErros["401"] := STR0002 //"Falha de autenticação. Verifique o Caminho e Token de autenticação configurados."
	Self:oDescricaoErros["403"] := STR0002 //"Falha de autenticação. Verifique o Caminho e Token de autenticação configurados."
	Self:oDescricaoErros["404"] := STR0003 //"Endpoint de comunicação não encontrado."
	Self:oDescricaoErros["422"] := STR0004 //"Parâmetros enviados incorretamente."
	Self:oDescricaoErros["429"] := STR0005 //"Limite de requisições atingido. Tente novamente em breve."
	Self:oDescricaoErros["500"] := STR0006 //"Erro indeterminado."
Return

/*/{Protheus.doc} carregaConfiguracaoIntegracao
Carrega caminho e token para integração com o MES.

@author lucas.franca
@since 07/10/2024
@version P12
@return Nil
/*/
Method carregaConfiguracaoIntegracao() Class MESLiteConnection
	SOD->(dbSetOrder(1))
	If SOD->(dbSeek(xFilial("SOD")))
		Self:cCaminho := AllTrim(SOD->OD_CAMINHO)
		
		SOE->(dbSetOrder(1))
		If SOE->(dbSeek(xFilial("SOE") + "TOKEN"))
			Self:cToken := PCPCriptTokenMES(SOE->OE_MEMO1)
		EndIf
	EndIf
Return Nil

/*/{Protheus.doc} inicializaRest
Inicializa o objeto client de comunicação com o rest.

@author lucas.franca
@since 04/10/2024
@version P12
@return Nil
/*/
Method inicializaRest() Class MESLiteConnection
	
	Self:oRestClient := FWRest():New(Self:cCaminho)
	Self:cHeaderAuthorization := "Authorization: Bearer " + Self:cToken

Return Nil

/*/{Protheus.doc} retornoAPI
Retorna por referência a resposta da última requisição realizada

@author lucas.franca
@since 04/10/2024
@version P12
@param 01 cCode        , Character, código HTTP de resposta
@param 02 cValue       , Character, Texto de retorno da API
@param 03 cError       , Character, Mensagem de erro
@param 04 lFalhaConexao, Logical  , Indica se houve falha de conexão
@return Nil
/*/
Method retornoAPI(cCode as Character, cValue as Character, cError as Character, lFalhaConexao as Logical) Class MESLiteConnection
	
	lFalhaConexao := Self:houveFalhaDeConexao()
	If lFalhaConexao
		cCode  := "500"
		cValue := ""
		cError := Self:oDescricaoErros["000"]
		If !Empty(Self:cErrorRet)
			cError += " " + STR0007 + ": " + Self:cErrorRet //Erro
		EndIf
	Else
		cCode  := Self:cStatusRet
		cValue := Self:cValueRet
		cError := Self:obtemMensagemDeErro()
		
		If Empty(cError) .And. Self:oDescricaoErros:hasProperty(cCode)
			cError := Self:oDescricaoErros[cCode]
		EndIf
	EndIf
Return

/*/{Protheus.doc} houveFalhaDeConexao
Verifica se a última mensagem enviada teve falha de conexão ou não

@author lucas.franca
@since 08/10/2024
@version P12
@return lFalha, Logical, Indica se houve falha de conexão
/*/
Method houveFalhaDeConexao() Class MESLiteConnection
	Local lFalha := Empty(Self:cStatusRet) as Logical
Return lFalha

/*/{Protheus.doc} obtemMensagemDeErro
Retorna a mensagem de erro de uma requisição.

@author lucas.franca
@since 08/10/2024
@version P12
@return cMensagem, Character, Mensagem de erro
/*/
Method obtemMensagemDeErro() Class MESLiteConnection
	Local cMensagem := "" as Character
	Local cDetalhes := "" as Character
	Local nStatus   := 0  as Numeric
	Local nIndex    := 0  as Numeric
	Local nTotal    := 0  as Numeric
	Local jRetorno        as Json

	jRetorno := JsonObject():New()
	If !Empty(Self:cValueRet) .And. Empty(jRetorno:fromJson(DecodeUTF8(Self:cValueRet)))
		
		If jRetorno:hasProperty("status")
			nStatus := jRetorno["status"]
		EndIf

		If jRetorno:hasProperty("data") .And. ValType(jRetorno["data"]) == "J"
			
			cMensagem := getValJson(jRetorno["data"], "description")
			cDetalhes := getValJson(jRetorno["data"], "details")
			If !Empty(cDetalhes)
				cMensagem += CHR(10) + cDetalhes
			EndIf
		ElseIf jRetorno:hasProperty("errors") .And. !Empty(jRetorno["errors"]) .And. ValType(jRetorno["errors"]) == "A"

			nTotal := Len(jRetorno["errors"])
			For nIndex := 1 To nTotal
				cMensagem += jRetorno["errors"][nIndex] + CHR(10)
			Next nIndex

		ElseIf nStatus != 403
			cMensagem := getValJson(jRetorno, "statusDescription")
		EndIf
	EndIf
	
	FreeObj(jRetorno)
Return cMensagem

/*/{Protheus.doc} getValJson
Obtém de um json o valor de uma propriedade, caso ela exista.

@type  Static Function
@author lucas.franca
@since 08/10/2024
@version P12
@param 01 jData    , Json     , dados para acesso
@param 02 cProperty, Character, Nome da propriedade para tratar.
@return cValue, Character, Valor obtido
/*/
Static Function getValJson(jData as Json, cProperty as Character)
	Local cValue := "" as Character

	If jData:hasProperty(cProperty) .And. !Empty(jData[cProperty])
		cValue := jData[cProperty]
	EndIf
Return cValue

/*/{Protheus.doc} getJsonEnviado
Retorna o JSON enviado na última mensagem POST

@author lucas.franca
@since 08/10/2024
@version P12
@return cJsonEnviado, Character, Texto do JSON enviado
/*/
Method getJsonEnviado() Class MESLiteConnection
Return Self:cJsonEnviado

/*/{Protheus.doc} retornaHeader
Retorna os headers padrões para a integração

@author lucas.franca
@since 04/10/2024
@version P12
@return aHeader, Array, Array com os dados para envio no header da requisição
/*/
Method retornaHeader() Class MESLiteConnection
	Local aHeader := {} as Array

	aAdd(aHeader, Self:cHeaderAuthorization)
	aAdd(aHeader, "accept: application/json")
Return aHeader

/*/{Protheus.doc} executaGet
Executa uma requisição GET

@author lucas.franca
@since 04/10/2024
@version P12
@param 01 cPath      , Character, Path/Endpoint da API
@param 02 aParametros, Array    , parâmetros que serão enviados para a API 
                                  todos devem estar como tipo CHAR. formato: { {"nome_parametro","valor_parametro"} }
@return lOk, Logic, Identifica se o GET foi executado com sucesso
/*/
Method executaGet(cPath as Character, aParametros as Array) Class MESLiteConnection
	Local cParametros := ""  as Character
	Local lOk         := .T. as Logical

	cParametros       := Self:trataParametros(aParametros)
	Self:cJsonEnviado := ""

	Self:oRestClient:setPath(cPath)
	Self:oRestClient:SetGetParams(cParametros)

	lOk := Self:oRestClient:Get(Self:retornaHeader())

	Self:cValueRet  := Self:oRestClient:GetResult()
	Self:cStatusRet := Self:oRestClient:GetHTTPCode()
	Self:cErrorRet  := Self:oRestClient:GetLastError()
Return lOk

/*/{Protheus.doc} executaPost
Executa o método POST

@author lucas.franca
@since 07/10/2024
@version P12
@param 01 cPath, Character, Path/Endpoint da API
@param 02 jData, Json     , dados para envio. Serão enviados no body da requisição
@return lOk, Logic, Retorna se executou o POST com sucesso
/*/
Method executaPost(cPath as Character, jData as Json) Class MESLiteConnection
	Local lOk := .T. as Logical

	Self:cJsonEnviado := ""

	If jData != Nil
		Self:cJsonEnviado := PCPEncUtf8(jData:toJson())
	EndIf

	Self:oRestClient:setPath(cPath)
	Self:oRestClient:SetPostParams(Self:cJsonEnviado)
	
	lOk := Self:oRestClient:Post( Self:retornaHeader() )

	Self:cValueRet  := Self:oRestClient:GetResult()
	Self:cStatusRet := Self:oRestClient:GetHTTPCode()
	Self:cErrorRet  := Self:oRestClient:GetLastError()
Return lOk

/*/{Protheus.doc} executaDelete
Executa o método DELETE

@author lucas.franca
@since 14/10/2024
@version P12
@param 01 cPath      , Character, Path/Endpoint da API
@param 02 aParametros, Array    , parâmetros que serão enviados para a API 
                                  todos devem estar como tipo CHAR. formato: { {"nome_parametro","valor_parametro"} }
@return lOk, Logic, Retorna se executou o POST com sucesso
/*/
Method executaDelete(cPath as Character, aParametros as Array) Class MESLiteConnection
	Local cParametros := ""  as Character
	Local lOk         := .T. as Logical

	cParametros := Self:trataParametros(aParametros)
	
	If !Empty(cParametros)
		cPath += "?" + cParametros
	EndIf

	Self:oRestClient:setPath(cPath)
	
	lOk := Self:oRestClient:Delete( Self:retornaHeader() )

	Self:cJsonEnviado := "[DELETE] " + Self:cCaminho + cPath
	Self:cValueRet    := Self:oRestClient:GetResult()
	Self:cStatusRet   := Self:oRestClient:GetHTTPCode()
	Self:cErrorRet    := Self:oRestClient:GetLastError()
Return lOk

/*/{Protheus.doc} trataParametros
Trata os parâmetros para envio como queryParam nas requisições

@author lucas.franca
@since 14/10/2024
@version P12
@param 01 aParametros, Array, parâmetros que serão enviados para a API 
                              todos devem estar como tipo CHAR. formato: { {"nome_parametro","valor_parametro"} }
@return cParametros, Character, Parâmetros convertidos para envio como queryParam.
/*/
Method trataParametros(aParametros as Array) Class MESLiteConnection
	Local cParametros := ""  as Character
	Local nIndex      := 0   as Numeric
	Local nTotal      := 0   as Numeric

	If !Empty(aParametros)
		nTotal := Len(aParametros)
		For nIndex := 1 To nTotal
			If nIndex > 1
				cParametros += "&"
			EndIf
			cParametros += aParametros[nIndex][1] + "=" + Escape(aParametros[nIndex][2])
		Next nIndex
	EndIf
Return cParametros

/*/{Protheus.doc} PCPGetTokenMesLite
Retorna o token configurado para o MES Lite, já descriptografado

@type Function
@author lucas.franca
@since 02/10/2024
@version P12
@return cToken, Caracter, Valor do token configurado
/*/
Function PCPGetTokenMesLite()
	Local aArea  := {} As Array
	Local cToken := "" As Character

	aArea := SOE->(GetArea())
	
	SOE->(dbSetOrder(1))
	If SOE->(dbSeek(xFilial("SOE") + "TOKEN" ))
		cToken := PCPCriptTokenMES(AllTrim(SOE->OE_MEMO1))
	EndIf
	SOE->(RestArea(aArea))
	aSize(aArea, 0)

Return cToken

/*/{Protheus.doc} PCPCriptTokenMES
Faz a criptografia/descriptografia do TOKEN
de autenticação do MES Lite utilizando o algoritmo RC4

Exemplo de uso:
PCPCriptTokenMES("abcde") -> retorna um valor criptografado (6AXb2g) por exemplo.
PCPCriptTokenMES("6AXb2g") -> retorna o valor original (abcde).

@type Function
@author lucas.franca
@since 02/10/2024
@version P12
@param cValue, Caracter, Valor a ser criptografato ou descriptografado
@return cValue, Caracter, Valor criptografato/descriptografado
/*/
Function PCPCriptTokenMES(cValue as Character)
	If !Empty(cValue)
		cValue := RC4Crypt(cValue, KEY_TOKEN_MES_LITE, .F.)
	EndIf
Return cValue
