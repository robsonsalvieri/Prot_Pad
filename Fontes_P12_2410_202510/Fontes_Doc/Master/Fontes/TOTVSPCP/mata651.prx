#INCLUDE "TOTVS.CH"
#INCLUDE "PROTHEUS.CH"
#INCLUDE "MATA651.CH"

Static _lNewMRP     := Nil //Integra Apontamentos Online - NewMRP
Static _lMarcou 	:= .F.
Static _lCrpOk      := Nil

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ Mata651  ³ Autor ³ Rodrigo de A. Sartorio³ Data ³ 03/02/99 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Programa que transforma OPs Previstas em Firmes            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe e ³ Void Mata651(void)                                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ ATUALIZACOES SOFRIDAS DESDE A CONSTRUCAO INICIAL.                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ PROGRAMADOR  ³ DATA   ³ BOPS ³  MOTIVO DA ALTERACAO                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Patricia Sal.³19/05/00³004162³Incluir mv_par07/mv_par08               ³±±
±±³ Erike Yuri   ³26/06/06³999999³Conversao para rotina automatica        ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Descri‡…o ³ PLANO DE MELHORIA CONTINUA                                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ITEM PMC  ³ Responsavel              ³ Data         |BOPS:		      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³      01  ³                          ³              |                  ³±±
±±³      02  ³Erike Yuri da Silva       ³26/06/2006    |00000099978       ³±±
±±³      03  ³                          ³              |                  ³±±
±±³      04  ³                          ³              |                  ³±±
±±³      05  ³                          ³              |                  ³±±
±±³      06  ³                          ³              |                  ³±±
±±³      07  ³                          ³              |                  ³±±
±±³      08  ³                          ³              |                  ³±±
±±³      09  ³                          ³              |                  ³±±
±±³      10  ³Erike Yuri da Silva       ³26/06/2006    |00000099978       ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/

/*
ATENCAO: o array da passado como parametro da rotina automatica deve conter os parametros
		 utilizados pela pergunte MTA652, e a partir dele sera executado o filtro. Lembrando
		 que para rotina automatica assumiremos que o a execucao para Firmar/Excluir Op devera
		 ser executado para todo range definido na parametrizacao, sendo assim deve ter muita
		 cautela na utilizacao desta rotina automatica. By Erike Yuri
*/
Function Mata651(aRotAuto,nOpc,lExcSCAuto)
Local	nI			:= 0
Local   lDbFilter   := .F.
Private cMarca 		:= GetMark()
Private nOrdemAtual := 4
Private cFirmaCond  := ' '

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Define Array contendo as Rotinas a executar do programa  ³
//³ ----------- Elementos contidos por dimensao ------------ ³
//³ 1. Nome a aparecer no cabecalho                          ³
//³ 2. Nome da Rotina associada                              ³
//³ 3. Usado pela rotina                                     ³
//³ 4. Tipo de Transa‡„o a ser efetuada                      ³
//³    1 - Pesquisa e Posiciona em um Banco de Dados         ³
//³    2 - Simplesmente Mostra os Campos                     ³
//³    3 - Inclui registros no Bancos de Dados               ³
//³    4 - Altera o registro corrente                        ³
//³    5 - Remove o registro corrente do Banco de Dados      ³
//³    6 - Altera determinados campos sem incluir novos Regs ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Define o cabecalho da tela de atualizacoes               ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Private cCadastro := OemToAnsi(STR0001)	//"OP's Previstas"

PRIVATE aRotina		:= MenuDef()
Private aIndTmp 	:= {}
Private aSavMTA652  := Array(9)
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Definicao de variaveis para rotina de inclusao automatica    ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Private l651Auto := ( aRotAuto <> NIL )

Default nOpc := 3
Default lExcSCAuto := .T.

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Variaveis utilizadas para parametros                         ³
//³ mv_par01            // De  Produto                           ³
//³ mv_par02            // Ate Produto                           ³
//³ mv_par03            // De  Ordem de Producao                 ³
//³ mv_par04            // Ate Ordem de Producao                 ³
//³ mv_par05            // De  Data de Entrega                   ³
//³ mv_par06            // Ate Data de Entrega                   ³
//³ mv_par07            // De  Data de Inicio                    ³
//³ mv_par08            // Ate Data de Inicio                    ³
//³ mv_par09            // Firma OPs Intermediarias              ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Pergunte("MTA652",.F.)

_lMarcou := .F.

lDbFilter := .F.
If l651Auto
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Inicializa perguntas com o arquivo de perguntas SX1      ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	For ni := 1 to 9
		aSavMTA652[ni] := &("mv_par"+StrZero(ni,2))
	Next ni

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Alimenta perguntas a partir do array da rotina automatica³
	//³ ATENCAO: Utilizo aqui o mesmo conceito do MATA116 para   ³
	//³ alimentar perguntas a partir do array da rotina automati-³
	//³ ca. E obrigatorio informar o array na ordem da pergunte. ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	aSavMTA652[01]	:= If(Len(aRotAuto)>=1,aRotAuto[1,2],aSavMTA652[01])
	aSavMTA652[02]	:= If(Len(aRotAuto)>=2,aRotAuto[2,2],aSavMTA652[02])
	aSavMTA652[03]	:= If(Len(aRotAuto)>=3,aRotAuto[3,2],aSavMTA652[03])
	aSavMTA652[04]	:= If(Len(aRotAuto)>=4,aRotAuto[4,2],aSavMTA652[04])
	aSavMTA652[05]	:= If(Len(aRotAuto)>=5,aRotAuto[5,2],aSavMTA652[05])
	aSavMTA652[06]	:= If(Len(aRotAuto)>=6,aRotAuto[6,2],aSavMTA652[06])
	aSavMTA652[07]	:= If(Len(aRotAuto)>=7,aRotAuto[7,2],aSavMTA652[07])
	aSavMTA652[08]	:= If(Len(aRotAuto)>=8,aRotAuto[8,2],aSavMTA652[08])
	aSavMTA652[09]	:= If(Len(aRotAuto)>=9,aRotAuto[9,2],aSavMTA652[09])

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Filtra o arquivo conforme perguntas antes de processar   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	A651Filtra()
	lDbFilter := .F.
	If !Empty(SC2->(DbFilter()))
		lDbFilter := .T.
	EndIf

	A651MarkAt(cMarca)
	DO CASE
		CASE nOpc == 4 //Firma Ops contidas no filtro
			A651Firma("SC2",,4,cMarca)
		CASE nOpc == 5 // Apaga Ops Previstas contidas no filtro
			A651Deleta("SC2",,5,cMarca,,lExcSCAuto)
	ENDCASE
Else
	If Pergunte("MTA652",.T.)
		For ni := 1 to 9
			aSavMTA652[ni] := &("mv_par"+StrZero(ni,2))
		Next ni

		dbSelectArea("SC2")
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Filtra o arquivo conforme perguntas antes de mostrar     ³
		//³ o browse                                                 ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		A651Filtra()
		dbGoTop()

		lDbFilter := .F.
		If !Empty(SC2->(DbFilter()))
			lDbFilter := .T.
		EndIf

		MarkBrow("SC2","C2_OK",,,,cMarca,'A651AllMark("'+cMarca+'")',,,,"M651Mark()",,,,,,,cFirmaCond)
	EndIf
EndIf

IF nOPC == 3 .And. _lMarcou
	If lDbFilter

		cQuery := "UPDATE "
		cQuery += RetSqlName("SC2")+" "
		cQuery += "SET C2_OK = '"+Space(Len(C2_OK))+" '"
		cQuery += " WHERE C2_FILIAL = '" + xFilial('SC2')+ "'"
		cQuery += " AND C2_TPOP = 'P' "
		If	Upper(TcGetDb()) $ 'ORACLE,DB2,POSTGRES,INFORMIX'
			cQuery += " AND (C2_NUM||C2_ITEM||C2_SEQUEN||C2_ITEMGRD) >= '"+AllTrim(aSavMTA652[03])+"'"
			cQuery += " AND (C2_NUM||C2_ITEM||C2_SEQUEN||C2_ITEMGRD) <= '"+AllTrim(aSavMTA652[04])+"'"
		Else
			cQuery += " AND (C2_NUM+C2_ITEM+C2_SEQUEN+C2_ITEMGRD) >= '"+aSavMTA652[03]+"'"
			cQuery += " AND (C2_NUM+C2_ITEM+C2_SEQUEN+C2_ITEMGRD) <= '"+aSavMTA652[04]+"'"
		EndIf
		cQuery += " AND C2_PRODUTO >= '"+aSavMTA652[01]+"'"
		cQuery += " AND C2_PRODUTO <= '"+aSavMTA652[02]+"'"
		cQuery += " AND C2_DATPRF >= '"+DTOS(aSavMTA652[05])+"'"
		cQuery += " AND C2_DATPRF <= '"+DTOS(aSavMTA652[06])+"'"
		cQuery += " AND C2_DATPRI >= '"+DTOS(aSavMTA652[07])+"'"
		cQuery += " AND C2_DATPRI <= '"+DTOS(aSavMTA652[08])+"'"
		cQuery += " AND D_E_L_E_T_ = ' ' "

		TcSqlExec(cQuery)

	EndIf
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Retorna indices do SC2                                       ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
RetIndex("SC2")
aEval(aIndTmp, {|cFile| fErase(cFile+OrdBagExt())})
dbClearFilter()

RETURN

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³ Fun‡…o   ³A651Firma ³ Autor ³Rodrigo de A. Sartorio ³ Data ³ 03/02/99 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Descri‡…o³ Firma as OPs previstas marcadas                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Mata651                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function A651Firma(cAlias,cCampo,nOpcE,cMarca,lInverte)
Local lContinua := .T.
Local lProdAut  := GetMv("MV_PRODAUT")
Local lFirmaOPI := aSavMTA652[09] == 1
Local nSelecao  := 0

nOpc := 4

If !l651Auto .And. lProdAut .And. !lFirmaOPI
	nSelecao  := Aviso(STR0008,STR0009+STR0010+Chr(13)+Chr(10)+STR0011,{STR0012,STR0013}) //"Atenção"##"Todas as OPs intermediárias que possuam vinculo com alguma OP Pai marcada no Browse, serão firmadas, "##"devido o sistema estar parametrizado para trabalhar com produção automática (MV_PRODAUT habilitado). "##"Deseja continuar o processo ?"##"Sim"##"Não"
	lContinua := (nSelecao == 1)
EndIf

If !(ValType(l651Auto)=='L')
	Private l651Auto := .F.
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Executa ponto de entrada antes do processamento          ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If (ExistBlock("MA651PRC"))
	lContinua:=ExecBlock("MA651PRC",.F.,.F.,{cMarca,lInverte})
	If ValType(lContinua) # "L"
		lContinua:=.T.
	EndIf
Endif
If lContinua
	If l651Auto
		a651Proces(cAlias,cCampo,nOpcE,cMarca,lInverte)
	Else
		If MsgYesNo(OemToAnsi(STR0004))	//" Firma as OPs marcadas ?"
			Processa({|lEnd| a651Proces(cAlias,cCampo,nOpcE,cMarca,lInverte)})
		Else
			dbSelectArea("SC2")
			dbGoTop()

       		While !Eof()
       			If SC2->C2_FILIAL == xFilial("SC2") .And. SC2->C2_TPOP=="P" .And.;
					SC2->(C2_NUM+C2_ITEM+C2_SEQUEN+C2_ITEMGRD) >= aSavMTA652[03] .And.;
					SC2->(C2_NUM+C2_ITEM+C2_SEQUEN+C2_ITEMGRD) <= aSavMTA652[04] .And.;
					SC2->C2_PRODUTO >= aSavMTA652[01] .And. SC2->C2_PRODUTO <= aSavMTA652[02] .And.;
					SC2->C2_DATPRF >= aSavMTA652[05] .And. SC2->C2_DATPRF <= aSavMTA652[06] .And.;
					SC2->C2_DATPRI >= aSavMTA652[07].And. SC2->C2_DATPRI <= aSavMTA652[08]
					Reclock('SC2', .F.)
					SC2->C2_OK := Space(Len(C2_OK))
					MsUnlock()
				EndIf
				dbSkip()
			End
		Endif
	EndIf
EndIf
If !l651Auto
	CloseBrowse()
EndIf
Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³ Fun‡…o   ³A651Deleta³ Autor ³Rodrigo de A. Sartorio ³ Data ³ 03/02/99 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Descri‡…o³ Deleta as OPs previstas marcadas                           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Mata651                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function A651Deleta(cAlias,cCampo,nOpcE,cMarca,lInverte,lExcSCAuto)
Local cQuery 	:= ""
Local lContinua := .T.
Local oBrw 		:= Nil

_lCrpOk := Iif(_lCrpOk == Nil, AliasInDic("HWF") .And. FindFunction('PCPA152'),_lCrpOk)

Default lExcSCAuto := .T.

nOPC := 5

If !(ValType(l651Auto)=='L')
	Private l651Auto := .F.
EndIf

If l651Auto
	MTApagaPre(cAlias,cCampo,nOpcE,cMarca,lInverte,,,lExcSCAuto)
Else
	If MsgYesNo(OemToAnsi(STR0005))	//" Deleta as OPs marcadas ?"

		If _lCrpOk			
			cQuery 	  := loadEfe(cMarca)
			lContinua := PCPA152Efetivacao():abreTela(cQuery)
		Endif

		If lContinua
			Processa({|lEnd| MTApagaPre(cAlias,cCampo,nOpcE,cMarca,lInverte)})
		Endif
	Else
		dbSelectArea("SC2")
		dbGoTop()

       While !Eof()
       	If SC2->C2_FILIAL == xFilial("SC2") .And. SC2->C2_TPOP=="P" .And.;
				SC2->(C2_NUM+C2_ITEM+C2_SEQUEN+C2_ITEMGRD) >= aSavMTA652[03] .And.;
				SC2->(C2_NUM+C2_ITEM+C2_SEQUEN+C2_ITEMGRD) <= aSavMTA652[04] .And.;
				SC2->C2_PRODUTO >= aSavMTA652[01] .And. SC2->C2_PRODUTO <= aSavMTA652[02] .And.;
				SC2->C2_DATPRF >= aSavMTA652[05] .And. SC2->C2_DATPRF <= aSavMTA652[06] .And.;
				SC2->C2_DATPRI >= aSavMTA652[07].And. SC2->C2_DATPRI <= aSavMTA652[08]
				Reclock('SC2', .F.)
				SC2->C2_OK := Space(Len(C2_OK))
				MsUnlock()
			EndIf
			dbSkip()
		End
	EndIf
	dbSelectArea("SC2")
	dbSetOrder(4)

	oBrw := GetMBrowse()
	oBrw:SetFilterDefault("")

	CloseBrowse()
EndIf
Return

/*/{Protheus.doc} loadEfe
Retorna a subquery para buscar as ordens efetivadas do CRP.
@author Jefferson Possidonio
@since 16/05/2024
@version P12
@param 01 cMarca , Caracter , Filtro com as Ops marcadas no browser
@return cQuery, Caracter, Query para buscar as ordens efetivadas do CRP.
/*/
Static Function loadEfe(cMarca)
Local cQuery := ""
Local cBanco := Upper(TcGetDb())

cQuery += " AND HWF.HWF_OP IN ("
cquery +=                    " SELECT DISTINCT SC2.C2_NUM||SC2.C2_ITEM||SC2.C2_SEQUEN||SC2.C2_ITEMGRD AS CNUMOP" 
cquery +=                      " FROM ("
cquery +=                            " SELECT C2_NUM,"
cquery +=                                   " MIN(C2_SEQUEN) AS SEQUENC"
cquery +=                              " FROM " + RetSqlName("SC2") 
cquery +=                             " WHERE C2_FILIAL = '" + xFilial("SC2") + "'"
cquery +=                               " AND C2_OK = '" + cMarca + "'"
cquery +=                               " AND D_E_L_E_T_ = ' '"
cquery +=                             " GROUP BY C2_NUM) TAB1"
cquery +=                     " INNER JOIN " + RetSqlName("SC2") + " SC2 " 
cquery +=                        " ON SC2.C2_FILIAL = '" + xFilial("SC2") + "'"
cquery +=                       " AND TAB1.C2_NUM = SC2.C2_NUM"
cquery +=                       " AND SC2.C2_SEQUEN >= TAB1.SEQUENC "
cquery +=                       " AND SC2.D_E_L_E_T_ = ' '"
cquery +=                     " INNER JOIN " + RetSqlName("HWF") + " HWF "
cquery +=                        " ON HWF.HWF_FILIAL = '" + xFilial("HWF") + "'"
cquery +=                       " AND " + PCPQrySC2("SC2", "HWF.HWF_OP")
cquery +=                       " AND HWF.D_E_L_E_T_ = ' ')"

If "MSSQL" $ cBanco
	cQuery := StrTran(cQuery, "||", "+")
EndIf

Return cQuery

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³ Fun‡…o   ³A651Proces³ Autor ³ Rodrigo de A. Sartorio³ Data ³ 03/02/99 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Descri‡…o³ Firma as OP's marcadas                                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Mata651                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function A651Proces(cAlias,cCampo,nOpcE,cMarca,lInverte)
Local aRegs      := {{}}
Local i          := 0
Local j          := 0
Local nRegs      := 0
Local aRegSel    := {}
Local nCntFor    := 0
Local lProdAut   := GetMv("MV_PRODAUT")
Local lFirmaOPI  := aSavMTA652[09] == 1
Local cMsg       := ""
Local lExplPI    := .T.
Local lLite      := .F.
Local lIntPPI    := PCPIntgPPI("SC2", @lLite)
Local lIntNewMRP := Iif(_lNewMRP == Nil, FindFunction("Ma650MrpOn") .AND. Ma650MrpOn(@_lNewMRP),_lNewMRP)
Local aMRPxJson  := Iif(lIntNewMRP, {{}, JsonObject():New()}, Nil)

Private aIntegPPI := {}

If !(ValType(l651Auto)=='L')
	Private l651Auto := .F.
EndIf

cAliasTop := 'SC2TMP'
cQuery    := "SELECT SC2.R_E_C_N_O_ SC2RECNO, SC2.C2_PRODUTO "
cQuery    += "   FROM " +RetSqlName("SC2")+" SC2" "
cQuery    += "  WHERE SC2.C2_FILIAL = '"+xFilial("SC2")+"'  "
cQuery    += "    AND SC2.C2_TPOP   = 'P' "
cQuery    += "    AND SC2.C2_OK     = '" + cMarca + "'" 
cQuery    += "    AND SC2.D_E_L_E_T_ = ' ' "
cQuery    += "  ORDER BY SC2.C2_PRODUTO "

cQuery := ChangeQuery(cQuery)
dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasTop,.T.,.T.)

While (cAliasTop)->(!EOF())
	Aadd( aRegSel, (cAliasTop)->SC2RECNO)
	(cAliasTop)->(dbSkip())
EndDo
(cAliasTop)->(dbclosearea())


//Limpa o filtro na tabela SC2
SC2->(dbClearFilter())
dbSelectArea("SC2")
dbSetOrder(4)

For nCntFor := 1 To Len(aRegSel)
	SC2->(dbGoTo(aRegSel[nCntFor])) //Posiciona no RECNO na SC2
	
	If Len(aRegs[Len(aRegs)]) > 4095
		AADD(aRegs,{})
	EndIf
	
	lExplPI := .F.
	If Len(aRegs[Len(aRegs)]) > 0
		For i:=1 to Len(aRegs)
			If ASCAN(aRegs[i],{ |x| x[1] == SC2->(Recno())}) == 0
				AADD(aRegs[Len(aRegs)],{SC2->(Recno()), SC2->C2_PRODUTO})
				lExplPI := .T.
			EndIf
		Next i
	Else
		AADD(aRegs[Len(aRegs)],{SC2->(Recno()), SC2->C2_PRODUTO})
		lExplPI := .T.
	EndIf 

	//Firma OPs filhas?
	If lExplPI .And. (lFirmaOPI .Or. lProdAut) 
		A651OpsPis(SC2->(C2_NUM+C2_ITEM+C2_SEQUEN+C2_ITEMGRD), aRegs, @nRegs)
	EndIf
	nRegs++
Next nCntFor

dbSelectArea("SC2")
If !l651Auto
	ProcRegua(nRegs,21,4)
EndIf

If Len(aRegs[Len(aRegs)]) > 0
	For i:=1 to Len(aRegs)
		//Ordena array por Produto
		ASORT(aRegs[i],,,{ |x,y| x[2] < y[2]})
	Next i
EndIf

For i:=1 to Len(aRegs)
	For j:=1 to Len(aRegs[i])
		
		If !l651Auto
			IncProc()
		EndIf

		dbGoto(aRegs[i,j,1])
		A651Do()

		dbSelectArea("SC2")
		dbGoto(aRegs[i,j,1])

		//Chama integração com novo MRP
		If lIntNewMRP
			A650AddJIn(@aMRPxJson)
		EndIf
		If lIntPPI
			mata650PPI( , , .T., .T., .F.)
		EndIf
	Next j
Next i

If !l651Auto .And. Len(aIntegPPI) > 0
	cMsg := STR0018 + CHR(10) //"Ocorreram erros na integração com o PCFactory."
	For i := 1 To Len(aIntegPPI)
		cMsg += STR0019 + AllTrim(aIntegPPI[i,1]) + " - " + AllTrim(aIntegPPI[i,2]) + CHR(10) //"OP: "
	Next i
	Aviso(STR0020 ,cMsg,{"Ok"},3) // ERRO
EndIf

If lIntNewMRP .And. aMRPxJson != Nil .And. Len(aMRPxJson[1]) > 0
	MATA650INT("INSERT", aMRPxJson[1])
	aSize(aMRPxJson[1], 0)
	FreeObj(aMRPxJson[2])
	aMRPxJson := Nil
EndIf

Return .T.

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³ Fun‡…o   ³A651Do    ³ Autor ³ Rodrigo de A. Sartorio³ Data ³ 03/02/99 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Descri‡…o³ Atualiza os arquivos envolvidos na Ordem de Producao       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Mata651                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function A651Do()

Local aAtuSD4  	 := {}
Local aCpsSD4  	 := {"D4_FILIAL","D4_COD","D4_LOCAL","D4_OP","D4_DATA","D4_QTDEORI","D4_QUANT","D4_QTSEGUM","D4_LOTECTL","D4_DTVALID","D4_NUMLOTE","D4_TRT","D4_OPORIG"}
Local aRegPed	 := {}
Local aRegsSC7	 := {{}}
Local aSldLote 	 := {}
Local aSldLtEnd  := {}
Local cAlias     := GetNextAlias()	
Local cAliasSD4  := GetNextAlias()	
Local cCompara 	 := ""
Local cFilC1     := xFilial('SC1')
Local cFilD4     := xFilial('SD4')
Local cLocal 	 := ""
Local cOP 		 := ""
Local cOPOrig 	 := ""
Local cOpSC2     := ""
Local cProduto 	 := ""
Local cQuery     := ""
Local cRoteiro   := ""
Local cSeek	   	 := ""
Local cTRT 		 := ""
Local dData    	 := dDataBase
Local dDtValid   := dDataBase
Local lAchouSDC	 := .F.
Local lDeleta  	 := .F.
Local lDisarm    := .T.
Local lEndProd   := .F.
Local lExistLote := .F.
Local lIntSFC	 := IntegraSFC()
Local lLimpaBF 	 := .F.
Local lNew 		 := .T.
Local lUsaRastro := .F.
Local nBaixa   	 := 0
Local nBaixa2  	 := 0
Local nDispLot   := 0
Local nDispLot2  := 0
Local nForLote 	 := 1
Local nInd		 := 0
Local nNewQtde 	 := 0
Local nNewSegU 	 := 0
Local nQuant   	 := 0
Local nQuant2  	 := 0
Local nQtdeDif   := 0
Local nQtdeDif2  := 0
Local nTotSaldo	 := 0
Local nTotSaldo2 := 0
Local i 	   	 := 0
Local j 	   	 := 0

Static cCacheC1  := NIL
Static cCacheD4  := NIL
Static lA651Proc := NIL
Static oPrepSC1
Static oPrepSD4

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Verifica existencia do ponto de entrada                      ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
lA651Proc := IF(ValType(lA651Proc)=="L",lA651Proc,ExistBlock("MA651GRV"))

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Seta ordens a serem utilizadas                               ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
SB1->(dbSetOrder(1))
SB2->(dbSetOrder(1))
SC1->(dbSetOrder(7))
SC7->(dbSetOrder(11))
SD4->(dbSetOrder(2))

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Varre arquivos de OPs                                        ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
dbSelectArea("SC2")
If SC2->C2_TPOP == "P"
	// Inicio Transacao
	Begin Transaction
		cOpSC2 := SC2->C2_NUM+SC2->C2_ITEM+SC2->C2_SEQUEN+SC2->C2_ITEMGRD

		oPrepSD4 := cCacheD4
		If oPrepSD4 == NIL
			cQuery := " SELECT SD4.R_E_C_N_O_ RECD4, SD4.D4_COD "
			cQuery += "   FROM " +  RetSqlName("SD4") + " SD4 "
			cQuery += "  WHERE SD4.D4_FILIAL  = ? "
			cQuery += "    AND SD4.D4_OP      = ? "
			cQuery += "    AND SD4.D_E_L_E_T_ = '' "
			cQuery += "  ORDER BY SD4.D4_COD "

			cQuery   := ChangeQuery(cQuery)
			oPrepSD4 := FWPreparedStatement():New(cQuery) //Construtor da carga.
			cCacheD4 := oPrepSD4
		EndIf

		//Seta um parâmetro na query via String.
		oPrepSD4:SetString(01, cFilD4) 
		oPrepSD4:SetString(02, cOpSC2)

		cQuery := oPrepSD4:GetFixQuery() //Retorna a query com os parâmetros já tratados e substituídos.
		cAliasSD4 := MPSysOpenQuery(cQuery, cAliasSD4) //Abre um alias com a query informada.
		
		While !(cAliasSD4)->(Eof())

			dbSelectArea("SD4")	
			SD4->(dbGoTo((cAliasSD4)->RECD4))
		
			//--Reinicia variaveis
			nDispLot := 0
			nDispLot2 := 0
			nNewQtde := 0
			nNewSegU := 0
			aSldLote := {}
			nForLote := 1
			lDeleta  := .F.
			lLimpaBF := .F.
			lExistLote := .F.
			//-----------------------

			dbSelectArea("SB2")
			If dbSeek(xFilial("SB2")+SD4->D4_COD+SD4->D4_LOCAL)
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Retira quantidade do Empenho Previsto                        ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				//Tratamento para atualizar o saldo pre de produtos negativos
				If SD4->D4_QUANT > 0
					GravaB2Emp("-",SD4->D4_QUANT,"P")
				Else
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Atualiza o B2_SALPED ou B2_SALPRE, somente se o produto ³
					//³ for negativo na estrutura. Caso nao tenha estrutura ou  ³
					//³ nao seja uma producao, nao executara a funcao GravaB2Pre³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If IsCompENeg(SD4->D4_PRODUTO,SD4->D4_COD,NIL,.T.)
						//remove a quantidade prevista
						GravaB2Pre("-",ABS(SD4->D4_QUANT),'P')
						//acrescenta na quantidade firme
						GravaB2Pre("+",ABS(SD4->D4_QUANT),'F')
					EndIf
				EndIf
			EndIf

			lUsaRastro := Rastro(SD4->D4_COD)
			If lUsaRastro
				lExistLote := .T.
				//--Elimina saldo de empenho previsto do lote ---
				If !Empty(SD4->(D4_LOTECTL+D4_NUMLOTE))
					dbSelectArea("SB8")
					dbSetOrder(3)
					cSeek:=xFilial("SB8")+SD4->D4_COD+SD4->D4_LOCAL+SD4->D4_LOTECTL+If(Rastro(SD4->D4_COD,"S"),SD4->D4_NUMLOTE,"")
					cCompara:="B8_FILIAL+B8_PRODUTO+B8_LOCAL+B8_LOTECTL"+If(Rastro(SD4->D4_COD,"S"),"+B8_NUMLOTE","")
					nQuant:=SD4->D4_QUANT
					nQuant2:=SD4->D4_QTSEGUM
					dbSeek(cSeek)
					While !Eof() .And. cSeek == &(cCompara) .And. nQuant > 0
						nBaixa:=Min(B8_QEMPPRE,nQuant)
						nBaixa2:=Min(B8_QEPRE2,nQuant2)
						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³ Retira quantidade do a entrar do Previsto ³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						GravaB8Emp("-",nBaixa,"P",NIL,nBaixa2)
						nQuant-=nBaixa
						nQuant2-=nBaixa2
						dbSkip()
					End
				EndIf

				If Localiza(SD4->D4_COD)
					//BUSCA PRIMEIRO SE TEM REGISTRO NA SDC
					lAchouSDC := .F.

					dbSelectArea("SDC")
					dbSetOrder(2)

					dbSeek(xFilial("SDC")+SD4->D4_COD+SD4->D4_LOCAL+SD4->D4_OP+SD4->D4_TRT+SD4->D4_LOTECTL+If(Rastro(SD4->D4_COD,"S"),SD4->D4_NUMLOTE,""))

					While !Eof() .And. DC_FILIAL+DC_PRODUTO+DC_LOCAL+DC_OP+DC_TRT+DC_LOTECTL+If(Rastro(SD4->D4_COD,"S"),DC_NUMLOTE,"") == ;
									xFilial("SDC")+SD4->D4_COD+SD4->D4_LOCAL+SD4->D4_OP+SD4->D4_TRT+SD4->D4_LOTECTL+If(Rastro(SD4->D4_COD,"S"),SD4->D4_NUMLOTE,"")
						lAchouSDC := .T.

						dbSelectArea("SBF")
						dbSetOrder(1)

						cSeek    := xFilial("SBF")+SD4->D4_LOCAL+SDC->DC_LOCALIZ+SD4->D4_COD+SDC->DC_NUMSERI+SD4->D4_LOTECTL+If(Rastro(SD4->D4_COD,"S"),SD4->D4_NUMLOTE,"")
						cCompara := "BF_FILIAL+BF_LOCAL+BF_LOCALIZ+BF_PRODUTO+BF_NUMSERI+BF_LOTECTL"+If(Rastro(SD4->D4_COD,"S"),"+BF_NUMLOTE","")

						nQuant  := Min(SD4->D4_QUANT,SDC->DC_QUANT)
						nQuant2 := Min(SD4->D4_QTSEGUM,SDC->DC_QTSEGUM)

						dbSeek(cSeek)
						While !Eof() .And. cSeek == &(cCompara) .And. nQuant > 0
							nBaixa:=Min(BF_QEMPPRE,nQuant)
							nBaixa2:=Min(BF_QEPRE2,nQuant2)

							//Retira quantidade do empenho previsto
							GravaBFEmp("-",nBaixa,"P",NIL,nBaixa2)

							nQuant-=nBaixa
							nQuant2-=nBaixa2
							dbSkip()
						End
						SDC->(dbSkip())
					End
					If !lAchouSDC
						dbSelectArea("SBF")
						dbSetOrder(2)

						cSeek    := xFilial("SBF")+SD4->D4_COD+SD4->D4_LOCAL+SD4->D4_LOTECTL+If(Rastro(SD4->D4_COD,"S"),SD4->D4_NUMLOTE,"")
						cCompara := "BF_FILIAL+BF_PRODUTO+BF_LOCAL+BF_LOTECTL"+If(Rastro(SD4->D4_COD,"S"),"+BF_NUMLOTE","")

						nQuant  := SD4->D4_QUANT
						nQuant2 := SD4->D4_QTSEGUM

						dbSeek(cSeek)
						While !Eof() .And. cSeek == &(cCompara) .And. nQuant > 0
							nBaixa:=Min(BF_QEMPPRE,nQuant)
							nBaixa2:=Min(BF_QEPRE2,nQuant2)

							//Retira quantidade do empenho previsto
							GravaBFEmp("-",nBaixa,"P",NIL,nBaixa2)

							nQuant-=nBaixa
							nQuant2-=nBaixa2
							dbSkip()
						End
					EndIf
				EndIf

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Faz a reavaliacao dos lotes empenhados		|
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If !Empty(SD4->(D4_LOTECTL+D4_NUMLOTE)) //.And. !PotencLote(SD4->D4_COD) //LKF AQUI
					//--Inicializa variaveis de controle
					cProduto	:= SD4->D4_COD
					cLocal 		:= SD4->D4_LOCAL
					nQuant 		:= SD4->D4_QUANT
					nQuant2 	:= SD4->D4_QTSEGUM
					cOP 		:= SD4->D4_OP
					dData 		:= SD4->D4_DATA
					cOPOrig 	:= SD4->D4_OPORIG
					cTRT		:= SD4->D4_TRT
					nTotSaldo	:= 0
					nTotSaldo2	:= 0
					nQtdeDif    := 0
					nQtdeDif2   := 0
					lEndProd    := Localiza(SD4->D4_COD)

					//Sugere outro endereço do mesmo lote para o empenho, caso o mesmo não possua mais saldo ao firmar a ordem.
					If lEndProd
						SDC->(dbSelectArea("SDC"))
						SDC->(dbSetOrder(2))
						SDC->(dbSeek(xFilial("SDC")+cProduto+cLocal+cOP+cTRT+SD4->D4_LOTECTL+If(Rastro(SD4->D4_COD,"S"),SD4->D4_NUMLOTE,"")))

						While SDC->(!Eof()) .And.SDC->(DC_FILIAL+DC_PRODUTO+DC_LOCAL+DC_OP+DC_TRT+DC_LOTECTL+If(Rastro(SD4->D4_COD,"S"),DC_NUMLOTE,"")) == ;
									xFilial("SDC")+cProduto+cLocal+cOP+cTRT+SD4->D4_LOTECTL+If(Rastro(SD4->D4_COD,"S"),SD4->D4_NUMLOTE,"")

							aSldLtEnd := SldPorLote(cProduto,cLocal,SDC->DC_QUANT,SDC->DC_QTSEGUM,SD4->D4_LOTECTL,SD4->D4_NUMLOTE,SDC->DC_LOCALIZ,;
													NIL,NIL,.F.,cLocal,NIL,NIL,.F.,dData)
							If Len(aSldLtEnd) < 1
								aSldLote := SldPorLote(SD4->D4_COD,SD4->D4_LOCAL,SD4->D4_QUANT,SD4->D4_QTSEGUM,SD4->D4_LOTECTL,SD4->D4_NUMLOTE,NIL,;
														NIL,NIL,.F.,SD4->D4_LOCAL,NIL,NIL,.F.,SD4->D4_DATA)
								FOR nInd := 1 TO LEN(aSldLote)
									RecLock("SDC",.F.)
									Replace DC_LOCALIZ With aSldLote[nInd,3]
									Replace DC_NUMSERI With aSldLote[nInd,4]
									MsUnLock()
									Exit
								Next nInd
							EndIf
							SDC->(dbSkip())
						EndDo
						aSldLtEnd := {}
						aSldLote  := {}
					EndIf

					aSldLote := SldPorLote(SD4->D4_COD,SD4->D4_LOCAL,SD4->D4_QUANT,SD4->D4_QTSEGUM,SD4->D4_LOTECTL,SD4->D4_NUMLOTE,NIL,;
											NIL,NIL,.F.,SD4->D4_LOCAL,NIL,NIL,.F.,SD4->D4_DATA)

					If !Empty(aSldLote) .And. (SD4->D4_LOTECTL == aSldLote[1,1] .And. If(Rastro(SD4->D4_COD,"S"),SD4->D4_NUMLOTE == aSldLote[1,2],.T.))
						FOR nInd := 1 TO LEN(aSldLote)
							If (SD4->D4_LOTECTL == aSldLote[nInd,1] .And. If(Rastro(SD4->D4_COD,"S"),SD4->D4_NUMLOTE == aSldLote[nInd,2],.T.))
								nTotSaldo  += aSldLote[nInd,5]
								nTotSaldo2 += aSldLote[nInd,6]

								//--Atualiza empenhos por endereco
								If Localiza(SD4->D4_COD)
									//nQuant  := aSldLote[nInd,5]
									//nQuant2 := aSldLote[nInd,6]
									dbSelectArea("SDC")
									dbSetOrder(2)
									dbSeek(xFilial("SDC")+cProduto+cLocal+cOP+SD4->D4_TRT+SD4->D4_LOTECTL+If(Rastro(SD4->D4_COD,"S"),SD4->D4_NUMLOTE,CriaVar("DC_NUMLOTE"))+aSldLote[nInd,3])
									While !Eof() .And. DC_FILIAL+DC_PRODUTO+DC_LOCAL+DC_OP+DC_TRT+DC_LOTECTL+DC_NUMLOTE+DC_LOCALIZ == ;
														xFilial("SDC")+cProduto+cLocal+cOP+SD4->D4_TRT+SD4->D4_LOTECTL+If(Rastro(SD4->D4_COD,"S"),SD4->D4_NUMLOTE,CriaVar("DC_NUMLOTE"))+aSldLote[nInd,3]

										//Verifica se possui saldo para o lote e o endereço que está na SDC
										aSldLtEnd := SldPorLote(SD4->D4_COD,SD4->D4_LOCAL,SDC->DC_QUANT,SDC->DC_QTSEGUM,SD4->D4_LOTECTL,SD4->D4_NUMLOTE,SDC->DC_LOCALIZ,;
																NIL,NIL,.F.,SD4->D4_LOCAL,NIL,NIL,.F.,SD4->D4_DATA)
										nQuant  := aSldLtEnd[1,5]
										nQuant2 := aSldLtEnd[1,6]

										nQtdeDif  += SDC->DC_QUANT - nQuant
										nQtdeDif2 += SDC->DC_QTSEGUM - nQuant2

										RecLock("SDC",.F.)
										Replace DC_QUANT   With Min(DC_QUANT,nQuant)
										Replace DC_QTSEGUM With Min(DC_QTSEGUM,nQuant2)
										MsUnLock()
										nQuant  -= DC_QUANT
										nQuant2 -= DC_QTSEGUM
										dbSkip()
									EndDo
								EndIf
							EndIf
						Next nInd

						//--Mesmo lote porem com saldo menor
						If (SD4->D4_QUANT > nTotSaldo)
							//--Calcula a diferenca a empenhar
							If PotencLote(SD4->D4_COD) .And. !Empty(SD4->D4_POTENCI)
								nNewQtde := (SD4->D4_QUANT - nTotSaldo)*(SD4->D4_POTENCI/100)
								nNewSegU := SD4->D4_QTSEGUM - nTotSaldo2
							Else
								nNewQtde := SD4->D4_QUANT - nTotSaldo
								nNewSegU := SD4->D4_QTSEGUM - nTotSaldo2
							EndIf
							//--Empenha somente o disponivel no lote
							RecLock("SD4",.F.)
							SD4->D4_QTDEORI := nTotSaldo
							SD4->D4_QUANT 	:= nTotSaldo
							SD4->D4_QTSEGUM := nTotSaldo2
							MsUnLock()

							//--Atualiza empenhos por endereco
							If Localiza(SD4->D4_COD)
								nQuant:=SD4->D4_QUANT
								nQuant2:=SD4->D4_QTSEGUM
								dbSelectArea("SDC")
								dbSetOrder(2)

								dbSeek(xFilial("SDC")+cProduto+cLocal+cOP+SD4->D4_TRT+SD4->D4_LOTECTL+If(Rastro(SD4->D4_COD,"S"),SD4->D4_NUMLOTE,CriaVar("DC_NUMLOTE"))+aSldLote[1,3])
								While !Eof() .And. DC_FILIAL+DC_PRODUTO+DC_LOCAL+DC_OP+DC_TRT+DC_LOTECTL+DC_NUMLOTE+DC_LOCALIZ == ;
													xFilial("SDC")+cProduto+cLocal+cOP+SD4->D4_TRT+SD4->D4_LOTECTL+If(Rastro(SD4->D4_COD,"S"),SD4->D4_NUMLOTE,CriaVar("DC_NUMLOTE"))+aSldLote[1,3]
									RecLock("SDC",.F.)
									Replace DC_QUANT With Min(DC_QUANT,nQuant)
									Replace DC_QTSEGUM With Min(DC_QTSEGUM,nQuant2)
									MsUnLock()
									nQuant-=DC_QUANT
									nQuant2-=DC_QTSEGUM
									dbSkip()
								EndDo
							EndIf
						Else
							If nQtdeDif > 0
								nNewQtde := nQtdeDif
								nNewSegU := nQtdeDif2
								RecLock("SD4",.F.)
								SD4->D4_QTDEORI	:= SD4->D4_QTDEORI - nQtdeDif
								SD4->D4_QUANT 	:= SD4->D4_QUANT - nQtdeDif
								SD4->D4_QTSEGUM	:= SD4->D4_QTSEGUM - nQtdeDif2
								MsUnLock()
							EndIf
						EndIf
						//--Atualiza o saldo de empenho no SB8
						dbSelectArea("SB8")
						dbSetOrder(3)
						cSeek:=xFilial("SB8")+SD4->D4_COD+SD4->D4_LOCAL+SD4->D4_LOTECTL+If(Rastro(SD4->D4_COD,"S"),SD4->D4_NUMLOTE,"")
						cCompara:="B8_FILIAL+B8_PRODUTO+B8_LOCAL+B8_LOTECTL"+If(Rastro(SD4->D4_COD,"S"),"+B8_NUMLOTE","")
						nQuant:=SD4->D4_QUANT
						nQuant2:=SD4->D4_QTSEGUM
						dbSeek(cSeek)
						While !Eof() .And. cSeek == &(cCompara) .And. nQuant > 0
							nBaixa:=nQuant
							nBaixa2:=nQuant2
							//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
							//³ Inclui quantidade empenhada no Firme      ³
							//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
							GravaB8Emp("+",nBaixa,"F",NIL,nBaixa2)

							nQuant-=nBaixa
							nQuant2-=nBaixa2
							dbSkip()
						End
					Else
						lDeleta := .T.
						nNewQtde := SD4->D4_QUANT
						nNewSegU := SD4->D4_QTSEGUM
						//--Apaga empenhos por endereco, uma vez que o lote sera alterado e nao podemos garantir a integridade
						If Localiza(SD4->D4_COD)
							dbSelectArea("SDC")
							dbSetOrder(2)
							dbSeek(xFilial("SDC")+cProduto+cLocal+cOP+SD4->D4_TRT+SD4->D4_LOTECTL+If(Rastro(SD4->D4_COD,"S"),SD4->D4_NUMLOTE,""))
							While !Eof() .And. DC_FILIAL+DC_PRODUTO+DC_LOCAL+DC_OP+DC_TRT+DC_LOTECTL+If(Rastro(SD4->D4_COD,"S"),DC_NUMLOTE,"") == ;
														xFilial("SDC")+cProduto+cLocal+cOP+SD4->D4_TRT+SD4->D4_LOTECTL+If(Rastro(SD4->D4_COD,"S"),SD4->D4_NUMLOTE,"")
								RecLock("SDC",.F.)
								dbDelete()
								MsUnLock()

								dbSkip()
							End
							lLimpaBF := .T.
						EndIf
					EndIf

					//--Gera empenho da diferenca em novos lotes
					While nNewQtde > 0
						If nForLote <= Len(aSldLote)
							//--Troca de lote caso o saldo tenha se esgotado
							If !(aSldLote[nForLote,6] > 0)
								nForLote++
								Loop
							EndIf
							cLotectl := aSldLote[nForLote][1]
							cNumlote := aSldLote[nForLote][2]
							dDtValid := aSldLote[nForLote][7]
						Else
							cLotectl := Space(TamSX3("B8_LOTECTL")[1])
							cNumlote := Space(TamSX3("B8_NUMLOTE")[1])
							dDtValid := dDataBase
						EndIf

						//--Busca pela chave unica para saber se soma em empenho ja existente ou se gera novo
						i := aScan(aAtuSD4,{|x| x[2] == cProduto .And. x[4] == cOP .And. x[12] == cTRT .And. x[9] == cLotectl .And. ;
														x[11]== cNumlote .And. x[3] == cLocal .And. x[13] == cOPOrig})
						If i == 0
							//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
							//³ O array aAtuSD4 sera utilizado para gerar os registros de empenho na tabela SD4.      				  ³
							//³ A sequencia de campos no array deve ser identica no array aCpsSD4, declarado no inicio desta funcao.  ³
							//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
							aAdd(aAtuSD4,{xFilial("SD4"),; 			// 1 - FILIAL
												cProduto,; 			// 2 - PRODUTO
												cLocal,; 			// 3 - LOCAL
												cOP,; 				// 4 - OP
												dData,; 			// 5 - DATA
												If(nForLote <= Len(aSldLote),Min(aSldLote[nForLote][5],nNewQtde),nNewQtde),; //6 - QTDEORI
												If(nForLote <= Len(aSldLote),Min(aSldLote[nForLote][5],nNewQtde),nNewQtde),; //7 - QUANT
												If(nForLote <= Len(aSldLote),Min(aSldLote[nForLote][6],nNewSegU),nNewSegU),; //8 - QTSEGUM
												cLotectl,; 			// 9 - LOTECTL
												dDtValid,; 			//10 - DTVALID
												cNumlote,;			//11 - NUMLOTE
												cTRT,;				//12 - TRT
												cOPOrig })			//13 - OPORIG
						Else
							aAtuSD4[i,6] += If(nForLote <= Len(aSldLote),Min(aSldLote[nForLote][5],nNewQtde),nNewQtde)
							aAtuSD4[i,7] += If(nForLote <= Len(aSldLote),Min(aSldLote[nForLote][5],nNewQtde),nNewQtde)
							aAtuSD4[i,8] += If(nForLote <= Len(aSldLote),Min(aSldLote[nForLote][6],nNewSegU),nNewSegU)
						EndIf

						nBaixa := If(nForLote <= Len(aSldLote),Min(aSldLote[nForLote][5],nNewQtde),nNewQtde)
						nBaixa2 := If(nForLote <= Len(aSldLote),Min(aSldLote[nForLote][6],nNewSegU),nNewSegU)

						nNewQtde -= nBaixa
						nNewSegU -= nBaixa2

						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³ Inclui empenho no Firme       ³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						If !Empty(cLotectl+cNumlote)
							dbSelectArea("SB8")
							cSeek:=xFilial("SB8")+cProduto+cLocal
							If i == 0
								cSeek += aAtuSD4[Len(aAtuSD4),9]+If(Rastro(SD4->D4_COD,"S"),aAtuSD4[Len(aAtuSD4),11],"")
							Else
								cSeek += aAtuSD4[i,9]+If(Rastro(SD4->D4_COD,"S"),aAtuSD4[i,11],"")
							EndIf
							dbSetOrder(3)
							dbSeek(cSeek)
							GravaB8Emp("+",nBaixa,"F",NIL,nBaixa2)
							//--Atualiza saldo do lote no array de controle
							aSldLote[nForLote,5] -= nBaixa//Min(aSldLote[nForLote][5],nNewQtde)
							aSldLote[nForLote,6] -= nBaixa2//Min(aSldLote[nForLote][6],nNewSegU)

							//--Troca de lote caso o saldo tenha se esgotado
							If !(aSldLote[nForLote,6] > 0)
								nForLote++
							EndIf
						EndIf
					End
				EndIf
			EndIf
			If Localiza(SD4->D4_COD)
				//BUSCA PRIMEIRO SE TEM REGISTRO NA SDC
				lAchouSDC := .F.

				dbSelectArea("SDC")
				dbSetOrder(2)

				dbSeek(xFilial("SDC")+SD4->D4_COD+SD4->D4_LOCAL+SD4->D4_OP+SD4->D4_TRT+SD4->D4_LOTECTL+If(Rastro(SD4->D4_COD,"S"),SD4->D4_NUMLOTE,""))

				While !Eof() .And. DC_FILIAL+DC_PRODUTO+DC_LOCAL+DC_OP+DC_TRT+DC_LOTECTL+If(Rastro(SD4->D4_COD,"S"),DC_NUMLOTE,"") == ;
								xFilial("SDC")+SD4->D4_COD+SD4->D4_LOCAL+SD4->D4_OP+SD4->D4_TRT+SD4->D4_LOTECTL+If(Rastro(SD4->D4_COD,"S"),SD4->D4_NUMLOTE,"")
					lAchouSDC := .T.

					dbSelectArea("SBF")
					dbSetOrder(1)

					cSeek    := xFilial("SBF")+SD4->D4_LOCAL+SDC->DC_LOCALIZ+SD4->D4_COD+SDC->DC_NUMSERI+SD4->D4_LOTECTL+If(Rastro(SD4->D4_COD,"S"),SD4->D4_NUMLOTE,"")
					cCompara := "BF_FILIAL+BF_LOCAL+BF_LOCALIZ+BF_PRODUTO+BF_NUMSERI+BF_LOTECTL"+If(Rastro(SD4->D4_COD,"S"),"+BF_NUMLOTE","")

					nQuant  := Min(SD4->D4_QUANT,SDC->DC_QUANT)
					nQuant2 := Min(SD4->D4_QTSEGUM,SDC->DC_QTSEGUM)

					dbSeek(cSeek)
					While !Eof() .And. cSeek == &(cCompara) .And. nQuant > 0

						//Retira quantidade do empenho previsto
						If !lUsaRastro //Se possui controle de lote, já retirou o empenho previsto.
							nBaixa:=Min(BF_QEMPPRE,nQuant)
							nBaixa2:=Min(BF_QEPRE2,nQuant2)

							GravaBFEmp("-",nBaixa,"P",NIL,nBaixa2)
						EndIf

						nBaixa  := Min(SBFSaldo(/*01*/,"SBF",/*03*/,.F.,.F.),nQuant)
						nBaixa2 := Min(SBFSaldo(/*01*/,"SBF",/*03*/,.T.,.F.),nQuant2)

						If !lLimpaBF
							GravaBFEmp("+",nBaixa,"F",NIL,nBaixa2)
						EndIf

						nQuant-=nBaixa
						nQuant2-=nBaixa2
						dbSkip()
					End
					SDC->(dbSkip())
				End
				If !lAchouSDC .And. lExistLote
					dbSelectArea("SBF")
					dbSetOrder(2)

					cSeek    := xFilial("SBF")+SD4->D4_COD+SD4->D4_LOCAL+SD4->D4_LOTECTL+If(Rastro(SD4->D4_COD,"S"),SD4->D4_NUMLOTE,"")
					cCompara := "BF_FILIAL+BF_PRODUTO+BF_LOCAL+BF_LOTECTL"+If(Rastro(SD4->D4_COD,"S"),"+BF_NUMLOTE","")

					nQuant  := SD4->D4_QUANT
					nQuant2 := SD4->D4_QTSEGUM

					dbSeek(cSeek)
					While !Eof() .And. cSeek == &(cCompara) .And. nQuant > 0

						//Inclui quantidade como empenho firme
						If !lUsaRastro //Se possui controle de lote, já retirou o empenho previsto.
							nBaixa:=Min(BF_QEMPPRE,nQuant)
							nBaixa2:=Min(BF_QEPRE2,nQuant2)

							GravaBFEmp("-",nBaixa,"P",NIL,nBaixa2)
						EndIf

						nBaixa  := Min(SBFSaldo(/*01*/,"SBF",/*03*/,.F.,.F.),nQuant)
						nBaixa2 := Min(SBFSaldo(/*01*/,"SBF",/*03*/,.T.,.F.),nQuant2)

						If !lLimpaBF
							GravaBFEmp("+",nBaixa,"F",NIL,nBaixa2)
						EndIf

						nQuant-=nBaixa
						nQuant2-=nBaixa2
						dbSkip()
					End
				EndIf
			EndIf

			If SB2->(dbSeek(xFilial("SB2")+SD4->D4_COD+SD4->D4_LOCAL)) .AND. SD4->D4_QUANT > 0
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Inclui quantidade no Empenho Firme                           ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				GravaB2Emp("+",SD4->D4_QUANT,"F")
			EndIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Verifica se o material vai ser comprado                      ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If Empty(SD4->D4_OPORIG)
				SB1->(dbSeek(xFilial("SB1")+SD4->D4_COD))

				oPrepSC1 := cCacheC1	
				If oPrepSC1 == NIL
					cQuery := " SELECT SC1.R_E_C_N_O_ RECC1 "
					cQuery += "   FROM " +  RetSqlName("SC1") + " SC1 "
					cQuery += "  WHERE SC1.C1_FILIAL  = ? "
					cQuery += "    AND SC1.C1_TPOP    = 'P' "
					cQuery += "    AND SC1.C1_OP      = ? "
					cQuery += "    AND SC1.C1_PRODUTO = ? "
					cQuery += "    AND SC1.D_E_L_E_T_ = '' "

					cQuery    := ChangeQuery(cQuery)
					oPrepSC1 := FWPreparedStatement():New(cQuery) //Construtor da carga.
					cCacheC1 := oPrepSC1
				EndIf

				//Seta um parâmetro na query via String.
				oPrepSC1:SetString(01, cFilC1) 
				oPrepSC1:SetString(02, SD4->D4_OP)
				oPrepSC1:SetString(03, SD4->D4_COD)

				cQuery := oPrepSC1:GetFixQuery() //Retorna a query com os parâmetros já tratados e substituídos.
				cAlias := MPSysOpenQuery(cQuery, cAlias) //Abre um alias com a query informada.
		
				While !(cAlias)->(Eof())
					
					SC1->(dbGoTo((cAlias)->RECC1))

					dbSelectArea("SB2")
					If dbSeek(xFilial("SB2")+SC1->C1_PRODUTO+SC1->C1_LOCAL)
																				
						//Retira quantidade do a entrar do Previsto 
						GravaB2Pre("-",SC1->C1_QUANT,"P")
						
						//Inclui quantidade a entrar no Firme     
						GravaB2Pre("+",SC1->C1_QUANT,"F")

						SC1->(dbGoTo((cAlias)->RECC1))

						Reclock("SC1",.F.)
							Replace C1_TPOP With "F"
						MsUnlock()						
					EndIf
					
					(cAlias)->(dbSkip())
				EndDo
				(cAlias)->(dbCloseArea())

				If SB1->B1_CONTRAT == "S"
					dbSelectArea("SC7")
					If dbSeek(xFilial("SC7")+"P"+SD4->D4_OP)
						Do While !Eof() .And. C7_FILIAL+C7_TPOP+C7_OP == xFilial("SC7")+"P"+SD4->D4_OP
							If SD4->D4_COD == C7_PRODUTO
								dbSelectArea("SB2")
								If dbSeek(xFilial("SB2")+SC7->C7_PRODUTO+SC7->C7_LOCAL)
									//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
									//³ Retira quantidade do a entrar do Previsto ³
									//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
									GravaB2Pre("-",SC7->C7_QUANT,"P")
									//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
									//³ Inclui quantidade a entrar no Firme       ³
									//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
									GravaB2Pre("+",SC7->C7_QUANT,"F")
									If Len(aRegsSC7[Len(aRegsSC7)]) > 4095
										AADD(aRegsSC7,{})
									EndIf
									AADD(aRegsSC7[Len(aRegsSC7)],{SC7->(Recno())})
								EndIf
								dbSelectArea("SC7")
							EndIf
							dbSkip()
						EndDo
						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³ Grava o Tipo das OPs nos PCs com "P"      ³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						For i:=1	to Len(aRegsSC7)
							For j:=1 to Len(aRegsSC7[i])
								dbGoto(aRegsSC7[i,j,1])
								Reclock("SC7",.F.)
								Replace C7_TPOP With "F"
								MsUnlock()
								//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
								//³ Monta array dos documentos para TOTVS Colab. ³
								//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
								If aScan(aRegPed,SC7->C7_NUM) == 0
									aAdd(aRegPed,SC7->C7_NUM)
								EndIf
							Next j
						Next i
					EndIf
				EndIf
			EndIf
			dbSelectArea("SD4")
			If lDeleta
				RecLock("SD4",.F.)
				dbDelete()
				MsUnLock()
			EndIf
			(cAliasSD4)->(dbSkip())
		EndDo
		(cAliasSD4)->(DbCloseArea())
		
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Envia o documento programacao de entrega para o TOTVS Colaboracao ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If (SuperGetMV("MV_TPOPDOC",.F.,.F.)) .And. FWLSEnable(TOTVS_COLAB_ONDEMAND) .And. SC7->C7_TPCOLAB <> "PEF" .And. SC7->C7_TPOP == "F"
			For i:=1 To Len(aRegPed)
				If Empty(SC7->C7_TPCOLAB)
					ExpXML_PC(aRegPed[i])
				Else
					ExpXML_PE(aRegPed[i])
				EndIf
			Next i
			aRegPed := {}
		EndIf
		//Cria novos empenhos conforme necessidade do conceito FEFO dos lotes
		For i := 1 To Len(aAtuSD4)
			lNew := .T.
			dbSelectArea("SD4")
			dBSetOrder(1)
			dbSeek(aAtuSD4[i,1]+aAtuSD4[i,2]+aAtuSD4[i,4]+aAtuSD4[i,12]+aAtuSD4[i,9]+aAtuSD4[i,11])//D4_FILIAL+D4_COD+D4_OP+D4_TRT+D4_LOTECTL+D4_NUMLOTE
			While !EOF() .And. SD4->(D4_FILIAL+D4_COD+D4_OP+D4_TRT+D4_LOTECTL+D4_NUMLOTE) == aAtuSD4[i,1]+aAtuSD4[i,2]+aAtuSD4[i,4]+aAtuSD4[i,12]+aAtuSD4[i,9]+aAtuSD4[i,11]
				If D4_LOCAL+D4_OPORIG == aAtuSD4[i,3]+aAtuSD4[i,13]
					lNew := .F.
					Exit
				EndIf
				dbSkip()
			End
			RecLock("SD4",lNew)
			For j := 1 To Len(aCpsSD4)
				If aCpsSD4[j] $ "D4_QTDEORI*D4_QUANT*D4_QTSEGUM"
					If lNew
						Replace &(aCpsSD4[j]) With aAtuSD4[i,j]
					Else
						Replace &(aCpsSD4[j]) With &(aCpsSD4[j]) + aAtuSD4[i,j]
					EndIf
				Else
					Replace &(aCpsSD4[j]) With aAtuSD4[i,j]
				EndIf
			Next j
			MsUnLock()

			If SB2->(dbSeek(aAtuSD4[i,1]+aAtuSD4[i,2]+aAtuSD4[i,3]))
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Inclui quantidade a entrar no Firme       ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				GravaB2Emp('+',aAtuSD4[i,7],"F",.F.)
			Endif
		Next i
		dbSelectArea("SB2")
		If dbSeek(xFilial("SB2")+SC2->C2_PRODUTO+SC2->C2_LOCAL)
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Retira quantidade do a entrar do Previsto ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			GravaB2Pre("-",SC2->C2_QUANT,"P")
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Inclui quantidade a entrar no Firme       ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			GravaB2Pre("+",SC2->C2_QUANT,"F")

			//Se vinculada a PV, converte B2_QEMPPREE em B2_QEMPN
			A651AtEmpN(1,SC2->(C2_NUM+C2_ITEM))
		EndIf

		Reclock("SC2",.F.)
		Replace C2_TPOP With "F"

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Gera integracao com Inspecao de Processos (QIP), caso exista ³
		//| Obs: funcao OPGeraQIP esta contida no PCPXFUN.				 ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		OPGeraQIP()

		MsUnlock()

		//-- Integracao com Chao de Fabrica ou parâmetro MV_PCPATOR = .T.
		If lIntSFC .Or. SuperGetMV("MV_PCPATOR",.F.,.F.) == .T.
			RegToMemory("SC2",.F.,.F.)
			lDisarm := .T.
			//Se Chão de fabrica estiver ativo
			If lIntSFC
				lDisarm := A650IntSFC(3,1)//-- Gera OP
			EndIf
			If (lDisarm)
				cRoteiro := SC2->C2_ROTEIRO //Roteiro da ordem de produção
				If Empty(cRoteiro)//Verifica se a ordem de produção possui um roteiro
					cRoteiro := Posicione("SB1",1,xFilial("SB1")+SC2->C2_PRODUTO,"B1_OPERPAD")//Roteiro do produto
					If Empty(cRoteiro)//Verifica se o produto possui um roteiro
						cRoteiro := StrZero(1,TamSX3("G2_CODIGO")[1])//Atribui por padrão "01" se não houver nenhum roteiro informado
					EndIf
				EndIf
				SC2->(TAPSOperac(C2_NUM+C2_ITEM+C2_SEQUEN+C2_ITEMGRD,C2_PRODUTO,cRoteiro,C2_QUANT))
				//Se Chão de fabrica estiver ativo
				If lIntSFC
					lDisarm := A650IntSFC(4,2)
					If (lDisarm) //-- Gera Operacoes e Rede Pert
						lDisarm := A650IntSFC(4,3) //-- Gera Reservas
					EndIf
				EndIf
			EndIf
		EndIf

		If !lDisarm
			DisarmTransaction()
		EndIf
	//Fim Transacao
	End Transaction

	//Executa ponto de entrada apos mudar tipo da OP
	If lA651Proc
		ExecBlock("MA651GRV",.F.,.F.)
	EndIf
EndIf
dbSelectArea("SC2")

Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³ Fun‡…o   ³A651Filtra³ Autor ³ Rodrigo de A. Sartorio³ Data ³ 03/02/99 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Descri‡…o³ Indice condicional conforme as perguntas                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Mata651                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
FUNCTION A651Filtra(nOrder)
LOCAL cIndice,nInd
Local cNomeInd:=CriaTrab(NIL,.F.)
nOrder := If(nOrder=Nil,4,nOrder)

cFirmaCond:=""

Aadd(aIndTmp, cNomeInd)

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Gera index de trabalho do SC2                                ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
dbSelectArea("SC2")
dbSetOrder(nOrder)
cIndice   := Indexkey()
cFirmaCond += "C2_FILIAL=='"+xFilial("SC2")+"' .And. C2_TPOP=='P' .And. "
cFirmaCond += "C2_NUM+C2_ITEM+C2_SEQUEN+C2_ITEMGRD >= '"+aSavMTA652[03]+"' .And. C2_NUM+C2_ITEM+C2_SEQUEN+C2_ITEMGRD <= '"+aSavMTA652[04]+"' .And. "
cFirmaCond += "dTos(C2_DATPRF) >= '"+dTos(aSavMTA652[05])+"' .And. dTos(C2_DATPRF) <= '"+dTos(aSavMTA652[06])+"' .And. "
cFirmaCond += "C2_PRODUTO >= '"+aSavMTA652[01]+"' .And. C2_PRODUTO <= '"+aSavMTA652[02]+"' .And. "
cFirmaCond += "dTos(C2_DATPRI) >= '"+dTos(aSavMTA652[07])+"' .And. dTos(C2_DATPRI) <= '"+dTos(aSavMTA652[08])+"'"

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Ponto de Entrada para alterar ou complementar o filtro na SC2 ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If ExistBlock("MA651FIL")
	cFirmaCond := ExecBlock("MA651FIL",.F.,.F.,{cFirmaCond})
Endif

IndRegua("SC2",cNomeInd,cIndice,,cFirmaCond,STR0006)	//"Selecionando Registros..."
nInd := RetIndex("SC2")
dbSetOrder(nInd+1)
Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³ Fun‡…o   ³A651Pesqui³ Autor ³ Marcelo Iuspa         ³ Data ³ 24/09/01 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Descri‡…o³ Botao Pesquisa do aRotina                                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Mata651                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function A651Pesqui
Local cCampo,nReg
Local nOpt1:=nOrdemAtual
Local cOrd
Local oDlg, nOpca := 0
Private aOrd := {}
PesqOrd("SC2")
cCampo  := Space(40)
aEval(aOrd, {|x, y| aOrd[y] := OemToAnsi(x)})
cOrd := aOrd[nOrdemAtual]

nOPC := 1

DEFINE MSDIALOG oDlg FROM 5, 5 TO 14, 50 TITLE OemToAnsi(STR0007) //"Pesquisar"
@ 0.6,1.3 COMBOBOX oCBX VAR cOrd ITEMS aOrd  SIZE 165,44  ON CHANGE (nOpt1:=oCbx:nAt)  OF oDlg FONT oDlg:oFont
@ 2.1,1.3 MSGET cCampo SIZE 165,10
DEFINE SBUTTON FROM 055,122   TYPE 1 ACTION (nOpca := 1,oDlg:End()) ENABLE OF oDlg
DEFINE SBUTTON FROM 055,149.1 TYPE 2 ACTION oDlg:End() ENABLE OF oDlg
ACTIVATE MSDIALOG oDlg CENTERED
If nOpca == 0
	Return 0
Endif
dbSetOrder(nOpt1)
nOrdemAtual := IndexOrd()
A651Filtra(nOrdemAtual)
nReg := RecNo()
If ! dbSeek(xFilial("SC2")+trim(cCampo), .T.)
	dbGoTo(nReg)
	Help(" ",1,"PESQ01")
EndIF
Return .T.

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³MA651Filtro ³ Autor ³Rodrigo de A Sartorio³ Data ³ 03/02/99 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Estabelece o topo e o Fim da markbrowse                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ MA651Filtro                                                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA651                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
Function MA651Filtro(lTop)
Local cRetorno := ""
If lTop
cRetorno:=xFilial("SC2")+"P"
Else
cRetorno:=xFilial("SC2")+Repl(Chr(255),Len(SC2->C2_TPOP))
EndIf
Return(cRetorno)
*/

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³MTApagaPre³ Autor ³Rodrigo de A. Sartorio ³ Data ³26/01/1999³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Funcao generica para apagar OPs/SCs/AEs previstas restauran³±±
±±³          ³ do os valores dos campos B2_QEMPPRE,B2_SALPPRE E B8_QEMPPRE³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ MTApagaPre(ExpL1,ExpC1)                                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Alias utilizado                                    ³±±
±±³          ³ ExpC2 = Campo chamado pela MarkBrowse                      ³±±
±±³          ³ ExpN1 = Opcao do ARotina                                   ³±±
±±³          ³ ExpC3 = Marca utilizada pela MarkBrowse                    ³±±
±±³          ³ ExpL1 = Indica se marcou tudo (.T.) ou nao (.F.)           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ GENERICO MATERIAIS                                         ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function MTApagaPre(cAlias,cCampo,nOpcE,cMarca,lInverte,oCenterPanel,lMta710,lExcSCAuto)
Local nReg:=Recno()
Local aArea:={Alias(),IndexOrd(),Recno()}
Local nOldOrder:=SC2->(IndexOrd())
Local lSelect	:= .F.
Local aAreaAtu := {}
Local cTipoDHN := "1"
Local lMrpDel  := SuperGetMV("MV_MRPDEL",.F.,.F.) // APAGA SOMENTE REGISTRO DO MRP
Local lMrpFUn  := IsInCallStack("MATA712") .OR. IsInCallStack("PCPA107") // FUNCOES DO MRP

Local lDelTBMRP  := _lNewMRP == NIL
Local lIntNewMRP := Iif(_lNewMRP == Nil, FindFunction("Ma650MrpOn") .AND. Ma650MrpOn(@_lNewMRP),_lNewMRP)
Local aMRPxJson  := Iif(lIntNewMRP, {{}, JsonObject():New()}, Nil) //{aDados para commit, JsonObject() com RECNOS} - Integracao Novo MRP - APONTAMENTOS

Default lMta710 := .F.
Default lExcSCAuto := .T.

If !(Type('l651Auto')=='L')
	Private l651Auto := .F.
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Verifica se houve selecao de OPs                                   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If !l651Auto .And. !lMta710
	lSelect :=If(PCOUNT()>0,.T.,.F.)
EndIf
If !lSelect
	dbSelectArea("SC2")
	dbSetOrder(4)
	nOldOrder:=4
	dbSeek(xFilial("SC2")+"P")
Else
	//Caso tenha perdido o filtro, o mesmo sera refeito
	//isso se faz necessario devido a falha na funcao MARKBROW
	//que esta limpando o filtro.
	If Empty(SC2->(DbFilter()))
		A651Filtra()
	EndIf
	dbGotop()
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Utiliza funcao padrao de exclusao de OPs                           ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If !l651Auto
	If (oCenterPanel==Nil)
		ProcRegua(LastRec(),21,4)
	Else
		oCenterPanel:SetRegua1(SC2->(LastRec()))
	EndIf
EndIf
Do While !Eof() .And. SC2->(C2_FILIAL+C2_TPOP) == xFilial("SC2")+"P"

	If !l651Auto
		If (oCenterPanel==Nil)
			IncProc()
		Else
			oCenterPanel:IncRegua1(OemToAnsi(STR0014))
		EndIf
	EndIf

	IF lMrpDel .AND. lMrpFUn
	  IF EMPTY(SC2->C2_SEQMRP) // Não foi gerado pelo MRP
		dbskip()
		loop
	  ENDIF
	EndIF

	If !lSelect .Or. (lSelect .And. IsMark("C2_OK",cMarca,lInverte))
		dbSelectArea("SHC")
		dbSetOrder(1)
		dbSeek(xFilial("SHC")+DTOS(SC2->C2_DATPRI)+SC2->C2_PRODUTO)
		While !Eof() .And. HC_FILIAL+Dtos(HC_DATA)+HC_PRODUTO == xFilial("SHC")+DTOS(SC2->C2_DATPRI)+SC2->C2_PRODUTO
			If SHC->HC_OP == SC2->(C2_NUM+C2_ITEM+C2_SEQUEN+C2_ITEMGRD)
				Reclock("SHC",.F.)
				Replace HC_OP With Criavar("HC_OP",.F.)
				Replace HC_STATUS With Criavar("HC_STATUS",.F.)
				MsUnlock()
				Exit
			EndIf
			dbSkip()
		End
		dbSelectArea("SC2")
		nReg:=Recno()
		A650Deleta("SC2",nReg,5,{},If(lMta710,"MATA710","MATA651"),.F.,@aMRPxJson)
		dbSelectArea("SC2")
		dbSetOrder(nOldOrder)
		dbGoto(nReg)
	EndIf
	dbSkip()
EndDo
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Processamento sem selecao de OPs                                   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If !lSelect .And. lExcSCAuto
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Exclui as Solicitacoes de Compras                                  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	dbSelectArea("SC1")
	dbSetOrder(7)
	If (oCenterPanel<>Nil) .And. !l651Auto
		oCenterPanel:SetRegua1(SC1->(LastRec()))
	EndIf
	dbSeek(xFilial("SC1")+"P")
	Do While !SC1->(Eof()) .And. SC1->(C1_FILIAL+C1_TPOP) == xFilial("SC1")+"P"
		If (oCenterPanel<>Nil) .And. !l651Auto
			oCenterPanel:IncRegua1(OemToAnsi(STR0015))
		EndIf

		IF lMrpDel .AND. lMrpFUn
		  IF EMPTY(SC1->C1_SEQMRP ) // Não foi gerado pelo MRP
			dbskip()
			loop
		  ENDIF
		EndIF

		If Type('aProcMRP') == "A" .And. !Empty(SC1->C1_SEQMRP)
			aAdd(aProcMRP, {SC1->C1_SEQMRP, SC1->C1_PRODUTO, SC1->C1_QUANT} )
		EndIf
		dbSelectArea("SB2")
		If !dbSeek(xFilial("SB2")+SC1->C1_PRODUTO+SC1->C1_LOCAL)
			CriaSB2(SC1->C1_PRODUTO,SC1->C1_LOCAL)
		EndIf
		GravaB2Pre("-",SC1->C1_QUANT,SC1->C1_TPOP)
		dbSelectArea("SC1")

		//Executa a exclusão da tabela DHN
		aAreaAtu := GetArea()
		COMEXCDHN("1",xFilial("SC1"),SC1->C1_NUM)
		RestArea(aAreaAtu)

		RecLock("SC1",.F.,.T.)
		dbDelete()
		MsUnlock()
		dbSkip()
	EndDo
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Exclui os Pedidos de Compras                                       ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	dbSelectArea("SC7")
	dbSetOrder(11)
	If (oCenterPanel<>Nil) .And. !l651Auto
		oCenterPanel:SetRegua1(SC7->(LastRec()))
	EndIf
	dbSeek(xFilial("SC7")+"P")
	Do While !Eof() .And. C7_TPOP == "P"
		If (oCenterPanel<>Nil) .And. !l651Auto
			oCenterPanel:IncRegua1(OemToAnsi(STR0016))
		EndIf

		IF lMrpDel .AND. lMrpFUn
		  IF EMPTY(SC7->C7_SEQMRP ) // Não foi gerado pelo MRP
			dbskip()
			loop
		  ENDIF
		EndIF

		dbSelectArea("SB2")
		If !dbSeek(xFilial("SB2")+SC7->C7_PRODUTO+SC7->C7_LOCAL)
			CriaSB2(SC7->C7_PRODUTO,SC7->C7_LOCAL)
		EndIf
		GravaB2Pre("-",SC7->C7_QUANT,SC7->C7_TPOP)
		// Volta saldo ate a autorizacao de entrega
		dbSelectArea("SC3")
		dbSetOrder(1)
		If dbSeek(xFilial("SC3")+SC7->C7_NUMSC+SC7->C7_ITEMSC)
			RecLock("SC3",.F.)
			Replace C3_QUJE With C3_QUJE - SC7->C7_QUANT
			If C3_QUANT > C3_QUJE .And. C3_ENCER == "E"
				Replace C3_ENCER 	With " "
			Endif
			MsUnlock()
		EndIf
		dbSelectArea("SC7")

		//Executa a exclusão da tabela DHN
		aAreaAtu := GetArea()
		If SC7->C7_TIPO == 2
			cTipoDHN := "3"
		Else
			cTipoDHN := "2"
		EndIf
		COMEXCDHN(cTipoDHN,xFilial("SC7"),SC7->C7_NUM)
		RestArea(aAreaAtu)

		RecLock("SC7",.F.,.T.)
		dbDelete()
		MsUnlock()
		dbSkip()
	EndDo
	dbSelectArea(aArea[1])
	dbSetOrder(aArea[2])
	dbGoto(aArea[3])
EndIf

//Chama integração de apontamentos com novo MRP
If lIntNewMRP
	envIntMrp("INSERT", @aMRPxJson, lDelTBMRP)
EndIf

Return

/*/{Protheus.doc} envIntMrp
Envia os empenhos para o MRP

@type  Static Function
@author brunno.costa
@since 23/07/2019
@version P12.1.27
@param cOperac    , Character, Operação em execução (INSERT/DELETE)
@param aMRPxJson  , Array    , Array com os dados para enviar - APONTAMENTOS.
@param lDelTBMRP  , logico   , indica se deve excluir a tabela temporaria
@return Nil
/*/
Static Function envIntMrp(cOperac, aMRPxJson, lDelTBMRP)
	Local aAreaAtu   := GetArea()

	//Integra os dados com a API - APONTAMENTOS
	MATA650INT(cOperac, aMRPxJson[1])
	aSize(aMRPxJson[1], 0)
	FreeObj(aMRPxJson[2])
	aMRPxJson[2] := Nil

	//Inicializa variável de controle da integração com o novo MRP
	If lDelTBMRP
		_lNewMRP := Nil
	EndIf

	RestArea(aAreaAtu)
Return Nil



/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³ Fun‡…o   ³A651OpsPis³ Autor ³ Marcelo Iuspa         ³ Data ³ 29/03/05 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Descri‡…o³ Acumula Recnos de Ops de Pis para firmar junto com Op do PA³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Mata651                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function A651OpsPis(cOp, aRegs, nRegs)
Local aSavAre := {SD4->(GetArea()), SC2->(GetArea()), GetArea()}
Local cSeek   := Nil

SC2->(dbSetOrder(1))

dbSelectArea("SD4")
dbSetOrder(2)

dbSeek(cSeek := xFilial("SD4") + cOp)
do While ! Eof() .And. SD4->(D4_FILIAL+D4_OP) == cSeek
	If !Empty(SD4->D4_OPORIG)
		
		If Len(aRegs[Len(aRegs)]) > 4095
			AADD(aRegs,{})
		EndIf
		
		SC2->(dbSeek(xFilial("SC2") + SD4->D4_OPORIG))
		AADD(aRegs[Len(aRegs)],{SC2->(Recno()), SC2->C2_PRODUTO})
		nRegs ++
		A651OpsPis(SD4->D4_OPORIG, aRegs, @nRegs)
	Endif
	dbSkip()
Enddo

RestArea(aSavAre[1])
RestArea(aSavAre[2])
RestArea(aSavAre[3])

Return(.T.)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFuncao    ³M651Mark  ºAutor³Tatiane Marques       º Data ³ 25/08/2008  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºOBjetivo  ³ Chamada no duplo click da MarkBrow                         º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ MATA651                                                    º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function M651Mark()
Local lRet:= .T.
Local aAreaAnt   := GetArea()

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Ponto de entrada na marcação de OP.³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If ExistBlock("M651Dpc")
	lRet:= ExecBlock("M651Dpc",.F.,.F.)
	If ValType(lRet)<>"L"
		lRet:= .T.
	EndIf
EndIf

If IsMark('C2_OK', cMarca)
	Reclock('SC2', .F.)
	SC2->C2_OK := Space(Len(C2_OK))
	MsUnlock()
ElseIf lRet
	Reclock('SC2', .F.)
	SC2->C2_OK := cMarca
	MsUnlock()
EndIf

_lMarcou := .T.

RestArea(aAreaAnt)
Return lRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³A651AtEmpNºAutor  ³Andre Anjos	     º Data ³  09/02/09	   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDescricao ³ Converte empenhos previstos (B2_QEMPPRE) em empenhos firmes º±±
±±º 		 ³ para PV (B2_QEMPN).										   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³ nTipo: Documento firmado (1= OP ; 2= SC)                    º±±
±±º			 ³ cDoc: Numero + item do documento			                   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ MATA651 E MATA652                                           º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function A651AtEmpN(nTipo,cDoc)
Local aArea := GetArea()
Local nQuant := 0

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Calcula o saldo a faturar e ainda nao reservados³
//³para compor o valor a somar no campo B2_QEMPN.  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
dbSelectArea("SC6")
If nTipo == 1
	SC6->(dbSetOrder(7)) //C6_FILIAL+C6_NUMOP+C6_ITEMOP
ElseIf nTipo == 2
	SC6->(dbSetOrder(9)) //C6_FILIAL+C6_NUMSC+C6_ITEMSC
EndIf

SC6->(dbSeek(xFilial("SC6")+cDoc))
While SC6->(!EOF()) .And. &(IndexKey()) == xFilial("SC6")+cDoc .AND. SC6->C6_PRODUTO == SC2->C2_PRODUTO
	//Nao processa pedidos com residuo eliminado ou ja encerrados
	If Alltrim(SC6->C6_BLQ) == "R" .Or. SC6->C6_QTDVEN <= SC6->C6_QTDENT
		SC6->(dbSkip())
		Loop
	EndIf

	//calcula a quantidade alterada
	nQuant := (SC6->C6_QTDVEN-SC6->C6_QTDENT-SC6->C6_QTDRESE - A650QLibPV())
	//Subtrai B2_QEMPPRE
	A650AtEmpN(nQuant,"-","P")
	//Soma B2_QEMPN
	A650AtEmpN(nQuant,"+","F")

	SC6->(dbSkip())
End

RestArea(aArea)
Return

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ A651AllMark³ Autor ³ Ricardo Berti 	    ³ Data ³ 19/04/11 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Marca todos os Registros da MarkBrowse()                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³cMarca    = Caracter de Marcacao                            ³±±
±±³          ³															  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ MATA651                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function A651AllMark(cMarca)
Local aArea		:= GetArea()
Local cCpoMarca	:= 'C2_OK'
Local cAlias	:= Alias()

dbSelectArea(cAlias)
dbSetOrder(1)
dbGoTop()

While !Eof()
	Reclock(cAlias, .F.)
	//-- Verifica se Marca ou Desmarca Todos
	If !(&(cCpoMarca)==cMarca)
		//-- Marca registro posicionado
		Fieldput(Fieldpos(cCpoMarca), cMarca)
	Else
		//-- Desmarca registro posicionado
		Fieldput(Fieldpos(cCpoMarca), '')
	EndIf
	MsUnlock()
	dbSkip()
EndDo

_lMarcou := .T.

RestArea(aArea)
Return
/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Programa  ³MenuDef   ³ Autor ³ Aline Damasceno       ³ Data ³30/09/2013³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Utilizacao de menu Funcional                               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Array com opcoes da rotina.                                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³Parametros do array a Rotina:                               ³±±
±±³          ³1. Nome a aparecer no cabecalho                             ³±±
±±³          ³2. Nome da Rotina associada                                 ³±±
±±³          ³3. Reservado                                                ³±±
±±³          ³4. Tipo de Transa‡„o a ser efetuada:                        ³±±
±±³          ³	  1 - Pesquisa e Posiciona em um Banco de Dados           ³±±
±±³          ³    2 - Simplesmente Mostra os Campos                       ³±±
±±³          ³    3 - Inclui registros no Bancos de Dados                 ³±±
±±³          ³    4 - Altera o registro corrente                          ³±±
±±³          ³    5 - Remove o registro corrente do Banco de Dados        ³±±
±±³          ³5. Nivel de acesso                                          ³±±
±±³          ³6. Habilita Menu Funcional                                  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/

Static Function MenuDef()
PRIVATE aRotina:= {	{STR0002,"A651Firma",0,4,0,.f.},;		//"Firma OPs"
					{STR0007,"A651PEsqui",0,1,0,.f.},; 	//"Pesquisar"
					{STR0003,"A651Deleta",0,5,0,.f.} }	//"Exclui OPs"

Return(aRotina)

/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³ Funcao    ³ A651MarkAt ³ Autor ³ Materiais          ³ Data ³ 11/12/14 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Descricao ³ Marca todos os registros de Ordens de Producao que        ³±±
±±³           ³ atendem a parametrizacao da rotina automatica             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso       ³ MATA651                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function A651MarkAt(cMarca)

Local aArea := GetArea()

If !Empty(SC2->(DbFilter()))
	dbSelectArea("SC2")
	dbGoTop()
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Marca todos os registos baseado no fitro   ³
	//³ realizado na SC2 pela funcao A651Filtra()  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	While !Eof()
		If SC2->C2_FILIAL == xFilial("SC2") .And. SC2->C2_TPOP=="P" .And.;
				SC2->(C2_NUM+C2_ITEM+C2_SEQUEN+C2_ITEMGRD) >= aSavMTA652[03] .And.;
				SC2->(C2_NUM+C2_ITEM+C2_SEQUEN+C2_ITEMGRD) <= aSavMTA652[04] .And.;
				SC2->C2_PRODUTO >= aSavMTA652[01] .And. SC2->C2_PRODUTO <= aSavMTA652[02] .And.;
				SC2->C2_DATPRF >= aSavMTA652[05] .And. SC2->C2_DATPRF <= aSavMTA652[06] .And.;
				SC2->C2_DATPRI >= aSavMTA652[07].And. SC2->C2_DATPRI <= aSavMTA652[08]
			Reclock('SC2', .F.)
			SC2->C2_OK := cMarca
			MsUnlock()
			_lMarcou := .T.
		EndIf
		SC2->(dbSkip())
	EndDo
EndIf

RestArea(aArea)

Return Nil
