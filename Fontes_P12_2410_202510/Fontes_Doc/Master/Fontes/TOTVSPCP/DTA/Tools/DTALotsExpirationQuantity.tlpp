#Include "tlpp-core.th"
#Include "TOTVS.CH"
#Include "DTALOTSEXPIRATIONQUANTITY.CH"

#DEFINE MAX_DAYS_SUGGESTION 180
#DEFINE MAX_DAYS 365
#DEFINE MAX_PRODUCTS 20

/*/{Protheus.doc} DTALotsExpirationQuantity
Classe responsável pela ferramenta dos produtos que possuem lotes a vencer/vencidos nos período

@author lucas.franca/renan.roeder
@since 29/09/2025
@version P12
/*/
Class DTALotsExpirationQuantity
	Static Method getData(jFilters as Json) as Array
	Static Method loadTool() as Character
EndClass

/*/{Protheus.doc} loadTool
Método que faz a carga das propriedades das ferramentas disponíveis por esta classe. Alimenta as tabelas HZV/HZW.

@author lucas.franca/renan.roeder
@since 29/09/2025
@version P12
@return cErrorMessage, Character, Indica se houve erro na carga da ferramenta
/*/
Method loadTool() as Character Class DTALotsExpirationQuantity
	Local cDescription  := ""                              as Character
	Local cErrorMessage := ""                              as Character
	Local cName         := "get_lots_expirations_quantity" as Character
	Local cRules        := ""                              as Character
	Local cVersion      := "001"                           as Character
	Local oLoadTool     := Nil                             as Object

	If DTALoad():toolIsUpdated(cName, cVersion)
		Return ""
	EndIf
	cDescription := STR0001 //"Retorna os produtos que possuem saldo em lotes com vencimento no período informado."
	cRules := "\n - " + I18N(STR0002,{"end_date_optional"}) //"Quando o usuário solicitar apenas produtos vencidos, utilize '#1[end_date_optional]#' com valor menor que o dia de hoje."
	cRules += "\n - " + I18N(STR0003, {"start_date_optional"}) //"Quando o usuário solicitar apenas produtos a vencer (vencendo, vencerão), utilize '#1[start_date_optional]#' com valor maior ou igual ao dia de hoje."
	cRules += "\n - " + I18N(STR0004, {"start_date_optional", "end_date_optional"}) //"A diferença de dias entre '#1[start_date_optional]#' e '#2[end_date_optional]#' deve ser no máximo de 365 dias. Consultas em datas distantes da data atual são permitidas. Este limite NÃO possui nenhuma relação com a DATA ATUAL."
	oLoadTool := DTALoad():New()
	oLoadTool:setName(cName)
	oLoadTool:setClassName("DTALotsExpirationQuantity")
	oLoadTool:setDataMethod("getData")
	oLoadTool:setVersion(cVersion)
	oLoadTool:setDescription(cDescription)
	oLoadTool:setShortDescription(STR0001) //"Retorna os produtos que possuem saldo em lotes com vencimento no período informado."
	oLoadTool:setExample(STR0005) //"Tenho produtos vencidos no estoque?"
	oLoadTool:setExample(STR0006) //"Liste os produtos que vencem a partir de amanhã"
	oLoadTool:setExample(STR0007) //"Quais produtos possuem lotes que vencerão no próximo mês?"
	oLoadTool:setExample(I18N(STR0008, {"start_date_optional", "end_date_optional"})) //"Qual o saldo de lotes que estão vencendo entre '#1[start_date_optional]#' e '#2[end_date_optional]#'?"
	oLoadTool:setRules(cRules)
	oLoadTool:setGroup("product_information")
	oLoadTool:setStrict(.T.)
	oLoadTool:addParameter("start_date_optional"     , {"string", "null"}, STR0009, .T.) //"Filtro da data inicial para busca dos produtos que possuem lotes com vencimento no período."
	oLoadTool:addParameter("end_date_optional"       , {"string", "null"}, STR0010, .T.) //"Filtro da data final para busca dos produtos que possuem lotes com vencimento no período."
	oLoadTool:addGlossary("product_code"             , STR0011) //"Código do produto"
	oLoadTool:addGlossary("product_description"      , STR0012) //"Descrição do produto"
	oLoadTool:addGlossary("product_unit_measure"     , STR0013) //"Unidade de medida do produto"
	oLoadTool:addGlossary("total_lots_balance"       , STR0014) //"Saldo no período"
	oLoadTool:addGlossary("total_quantity_to_address", STR0015) //"Quantidade a endereçar no período"
	oLoadTool:addGlossary("products_list"            , STR0016) //"Lista dos produtos"
	oLoadTool:addGlossary("total_products"           , STR0017) //"Quantidade de produtos"
	If !oLoadTool:createTool()
		cErrorMessage := oLoadTool:getErrorMessage()
	EndIf
	oLoadTool:Destroy()
Return cErrorMessage

/*/{Protheus.doc} getDataPeriod
Método que faz a busca dos produtos com lotes que tenham vencimento no período.
@author lucas.franca/renan.roeder
@since 29/09/2025
@version P12
@param 01 jFilters, Json, Filtros que serão aplicados para a busca dos saldos em estoque.
@return aReturn, Array, Array com os dados encontrados, sendo:
		aReturn[1] - Logical - Identifica se processou com sucesso a busca.
		aReturn[2] - Json    - Dados obtidos na busca ou mensagem de erro caso não consiga fazer a busca.
		aReturn[3] - Numeric - Status que representa o retorno (200 ok, 400 erro.)
/*/
Method getData(jFilters as Json) as Array Class DTALotsExpirationQuantity
	Local aLots    := {}  as Array
	Local aReturn  := {}  as Array
	Local cAlias   := ""  as Character
	Local cContext := ""  as Character
	Local cQuery   := ""  as Character
	Local jData    := Nil as Json
	Local jItem    := Nil as Json
	Local nIndex   := 0   as Numeric
	Local nSize    := 0   as Numeric
	Local oQuery   := Nil as Object

	If !Empty(jFilters["start_date_optional"])
		jFilters["start_date_optional"] := PCPConvDat(jFilters["start_date_optional"], 1)
		If Empty(jFilters["start_date_optional"])
			Return DTAUtils():APIErrorMessage(400, I18N(STR0018, {"start_date_optional"})) //"Parâmetro '#1[PARAMETRO]#' não é uma data válida. Informe uma data correta para realizar a pesquisa."
		EndIf
	EndIf
	If !Empty(jFilters["end_date_optional"])
		jFilters["end_date_optional"] := PCPConvDat(jFilters["end_date_optional"], 1)
		If Empty(jFilters["end_date_optional"])
			Return DTAUtils():APIErrorMessage(400, I18N(STR0018, {"end_date_optional"})) //"Parâmetro '#1[PARAMETRO]#' não é uma data válida. Informe uma data correta para realizar a pesquisa."
		EndIf
	EndIf
	If Empty(jFilters["start_date_optional"])
		If !Empty(jFilters["end_date_optional"])
			jFilters["start_date_optional"] := jFilters["end_date_optional"] - MAX_DAYS_SUGGESTION
		Else
			jFilters["start_date_optional"] := dDataBase - MAX_DAYS_SUGGESTION
		EndIf
	EndIf
	If Empty(jFilters["end_date_optional"])
		If !Empty(jFilters["start_date_optional"])
			jFilters["end_date_optional"] := jFilters["start_date_optional"] + MAX_DAYS_SUGGESTION
		EndIf
	EndIf
	If (jFilters["end_date_optional"] - jFilters["start_date_optional"]) > MAX_DAYS
		Return DTAUtils():APIErrorMessage(400, I18N(STR0019, {"start_date_optional", "end_date_optional", MAX_DAYS})) //"Parâmetros '#1[start_date_optional]#' e '#2[end_date_optional]#' devem possuir um intervalo máximo de #3[MAX_DAYS]# dias entre eles."
	EndIf

	nSize := GetSX3Cache("NNR_CODIGO", "X3_TAMANHO")
	jData := {"products_list": Array(0), "total_products": 0}

	cQuery := "SELECT SB8.B8_PRODUTO, SB1.B1_DESC, SB1.B1_UM, SUM(SB8.B8_QACLASS) B8_QACLASS, MIN(SB8.B8_DTVALID) VALIDADE "
	cQuery +=   "FROM " + RetSqlName("SB8") + " SB8 "
	cQuery +=  "INNER JOIN " + RetSqlName("SB1") + " SB1 ON SB1.B1_FILIAL = ? AND SB1.B1_COD = SB8.B8_PRODUTO AND SB1.D_E_L_E_T_ = ' ' "
	cQuery +=  "WHERE SB8.B8_FILIAL = ? "
	cQuery +=    "AND SB8.B8_DTVALID BETWEEN ? AND ? "
	cQuery +=    "AND SB8.B8_SALDO > 0 "
	cQuery +=    "AND SB8.B8_DATA <= ? "
	cQuery +=    "AND SB8.D_E_L_E_T_  = ' ' "
	cQuery +=  "GROUP BY SB8.B8_PRODUTO, SB1.B1_DESC, SB1.B1_UM "
	cQuery +=  "ORDER BY VALIDADE, SB8.B8_PRODUTO"

	oQuery := FwExecStatement():New(ChangeQuery(cQuery))
	oQuery:setString(1, xFilial("SB1"))
	oQuery:setString(2, xFilial("SB8"))
	oQuery:setDate(3, jFilters["start_date_optional"])
	oQuery:setDate(4, jFilters["end_date_optional"])
	oQuery:setDate(5, dDataBase)

	cAlias := oQuery:OpenAlias()
	While (cAlias)->(!Eof())
		If jData["total_products"] < MAX_PRODUCTS
			jItem := JsonObject():New()
			jItem["product_code"        ] := RTrim((cAlias)->(B8_PRODUTO))
			jItem["product_description" ] := RTrim((cAlias)->(B1_DESC))
			jItem["product_unit_measure"] := RTrim((cAlias)->(B1_UM))
			jItem["total_lots_balance"  ] := 0
			If (cAlias)->B8_QACLASS > 0
				jItem["total_quantity_to_address"] := (cAlias)->B8_QACLASS
			EndIf
			aLots := SldPorLote((cAlias)->B8_PRODUTO, Space(nSize), 999999999999999, 999999999999999, Nil, Nil, Nil, Nil, Nil, .F., Replicate("Z", nSize), .T.,, .T., dDataBase,,,.T.)
			If !Empty(aLots)
				For nIndex := 1 To Len(aLots)
					If (aLots[nIndex][7] >= jFilters["start_date_optional"] .And. aLots[nIndex][7] <= jFilters["end_date_optional"])
						jItem["total_lots_balance"] += aLots[nIndex][5]
					EndIf
				Next nIndex
			EndIf
			aAdd(jData["products_list"], jItem)
			jItem := Nil
		EndIf
		jData["total_products"]++
		(cAlias)->(dbSkip())
	End
	(cAlias)->(dbCloseArea())
	cContext := I18N(STR0020,{dToc(jFilters["start_date_optional"]), dToc(jFilters["end_date_optional"])}) //"Faça a observação ao final da resposta que o período utilizado na busca foi de #1[start_date_optional]# até #2[end_date_optional]#."
	If jData["total_products"] > MAX_PRODUCTS
		cContext += "\n" + I18N(STR0021,{"products_list", MAX_PRODUCTS}) //"A '#1[products_list]#' está limitada aos primeiros #2[MAX_PRODUCTS]# produtos encontrados, e não é possível obter a lista completa dos produtos."
	EndIf
	aReturn  := {.T., {"context": cContext, "data": jData}, 200}
	aSize(aLots, 0)
	jData := Nil
	oQuery:Destroy()
	FreeObj(oQuery)
Return aReturn
