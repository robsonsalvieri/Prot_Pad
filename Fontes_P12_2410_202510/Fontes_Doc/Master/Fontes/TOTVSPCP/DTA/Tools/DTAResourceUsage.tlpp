#Include "TLPP-CORE.TH"
#Include "TOTVS.CH"
#Include "DTAResourceUsage.ch"

#DEFINE BREAK_LINE " \n "

/*/{Protheus.doc} DTAResourceUsage
Classe responsável pela ferramenta de busca de informações de utilização do recurso

@author lucas.franca/renan.roeder
@since 21/01/2025
@version P12
/*/
Class DTAResourceUsage
	Static Method calculateUsagePercent(cHoursUsed as Character, cHoursCapacity as Character) as Character
	Static Method convertTimeToMinutes(cTime as Character, nTimeType as Numeric) as Numeric
	Static Method getReasonIndex(jResource as Json, cAlias as Character) as Numeric
	Static Method getResourceIndex(aResources as Array, cAlias as Character) as Numeric
	Static Method getUsageData(jFilters as Json) as Array
	Static Method getUnproductiveHoursData(jFilters as Json) as Array
	Static Method loadTool() as Character
	Static Method loadUsageTool() as Character
	Static Method loadUnproductiveHoursTool() as Character
	Static Method rankReasonHours(aReasons as Array)
	Static Method rankResourceHours(aResources as Array)
	Static Method searchUnproductiveHours(jFilters as Json) as Json
EndClass

/*/{Protheus.doc} loadTool
Método que faz a carga das propriedades das ferramentas disponíveis por esta classe. Alimenta as tabelas HZV/HZW.

@author lucas.franca/renan.roeder
@since 21/01/2025
@version P12
@return cErrorMessage, Character, Retorna a mensagem de erro caso a ferramenta não tenha sido criada
/*/
Method loadTool() as Character Class DTAResourceUsage
	Local cErrorMessage := "" as Character

	cErrorMessage := DTAResourceUsage():loadUsageTool()
	cErrorMessage += DTAResourceUsage():loadUnproductiveHoursTool()
Return cErrorMessage

/*/{Protheus.doc} loadUsageTool
Carga da ferramenta get_resource_usage com a utilização do recurso

@author lucas.franca/renan.roeder
@since 21/01/2025
@version P12
@return cErrorMessage, Character, Retorna a mensagem de erro caso a ferramenta não tenha sido criada
/*/
Method loadUsageTool() as Character Class DTAResourceUsage
	Local cDescription  := ""  as Character
	Local cErrorMessage := ""  as Character
	Local cName         := ""  as Character
	Local cVersion      := ""  as Character
	Local oLoadTool     := Nil as Object

	cName    := "get_resource_usage"
	cVersion := "002"

	If DTALoad():toolIsUpdated(cName, cVersion)
		Return ""
	EndIf

	cDescription := STR0001 //"Fornece informações detalhadas sobre a utilização de um recurso em um intervalo de datas específico. A análise inclui a capacidade total do recurso e as horas consumidas durante o período, diferenciando entre horas produtivas e improdutivas."
	oLoadTool := DTALoad():New()
	oLoadTool:setName(cName)
	oLoadTool:setClassName("DTAResourceUsage")
	oLoadTool:setDataMethod("getUsageData")
	oLoadTool:setVersion(cVersion)
	oLoadTool:setDescription(cDescription)
	oLoadTool:setShortDescription(STR0002) //"Retorna as informações de capacidade do recurso"
	oLoadTool:setExample(I18N(STR0003, {"resource_code"})) //"Como foi a utilização do recurso '#1[RECURSO]#' ontem?"
	oLoadTool:setExample(I18N(STR0004, {"resource_code"})) //"Quanto foi utilizado da capacidade do recurso '#1[RECURSO]#' no mês passado?"
	oLoadTool:setExample(I18N(STR0005, {"resource_code"})) //"Quantas horas foram apontadas no recurso '#1[RECURSO]#' no mês de janeiro de 2025?"
	oLoadTool:setStrict(.T.)
	oLoadTool:setGroup("resource_usage")
	oLoadTool:addParameter("resource_code", "string", STR0008 + "." + BREAK_LINE + STR0018, .T.) //Código do recurso + . \n + "O código do recurso pode conter somente letras, somente números ou a combinação de caracteres, podendo ou não ter caracteres especiais. Exemplo: 'R001', 'INJET', '000001', 'TORNO1'."
	oLoadTool:addParameter("start_date"   , "string", STR0006, .T.) //"Filtro da data inicial para busca da utilização do recurso."
	oLoadTool:addParameter("end_date"     , "string", STR0007, .T.) //"Filtro da data final para busca da utilização do recurso."
	oLoadTool:addGlossary("resource_code"           , STR0008) //"Código do recurso"
	oLoadTool:addGlossary("resource_description"    , STR0009) //"Descrição do recurso"
	oLoadTool:addGlossary("capacity"                , STR0010) //"Capacidade total do recurso"
	oLoadTool:addGlossary("productive_hours"        , STR0011) //"Horas produtivas apontadas"
	oLoadTool:addGlossary("unproductive_hours"      , STR0012) //"Horas improdutivas apontadas"
	oLoadTool:addGlossary("reported_hours"          , STR0013) //"Total de horas apontadas"
	oLoadTool:addGlossary("usage_percentage"        , STR0014) //"Utilização geral da capacidade"
	oLoadTool:addGlossary("productive_percentage"   , STR0015) //"Utilização produtiva da capacidade"
	oLoadTool:addGlossary("unproductive_percentage" , STR0016) //"Utilização improdutiva da capacidade"
	oLoadTool:addGlossary("production_efficiency"   , STR0017) //"Proporção de horas improdutivas em relação às produtivas"
	If !oLoadTool:createTool()
		cErrorMessage := oLoadTool:getErrorMessage()
	EndIf
	oLoadTool:Destroy()
Return cErrorMessage

/*/{Protheus.doc} loadUnproductiveHoursTool
Carga da ferramenta get_unproductive_hours_per_resource com a utilização do recurso

@author lucas.franca/renan.roeder
@since 11/04/2025
@version P12
@return cErrorMessage, Character, Retorna a mensagem de erro caso a ferramenta não tenha sido criada
/*/
Method loadUnproductiveHoursTool() as Character Class DTAResourceUsage
	Local cDescription  := ""  as Character
	Local cErrorMessage := ""  as Character
	Local cName         := ""  as Character
	Local cVersion      := ""  as Character
	Local oLoadTool     := Nil as Object

	cName    := "get_unproductive_hours_per_resource"
	cVersion := "002"

	If DTALoad():toolIsUpdated(cName, cVersion)
		Return ""
	EndIf

	cDescription := STR0019 //"Fornece um rank com quais recursos possuem as maiores horas improdutivas registradas, com a classificação das horas pelos motivos de horas improdutivas."
	cDescription += " " + I18N(STR0020, {"resource_code_optional", "unproductive_reason_optional"}) //"A busca é realizada para um período específico de datas, e opcionalmente podem ser realizados filtros pelo '#1[RECURSO]#' e '#2[MOTIVO]#'."
	cDescription += " " + STR0021 //"As horas improdutivas também podem ser reconhecidas pelo termo horas paradas."
	oLoadTool := DTALoad():New()
	oLoadTool:setName(cName)
	oLoadTool:setClassName("DTAResourceUsage")
	oLoadTool:setDataMethod("getUnproductiveHoursData")
	oLoadTool:setVersion(cVersion)
	oLoadTool:setDescription(cDescription)
	oLoadTool:setShortDescription(STR0022) //"Retorna quais recursos tiveram mais horas improdutivas no período"
	oLoadTool:setExample(I18N(STR0023, {"start_date", "end_date"})) //"Quais recursos tiveram mais horas improdutivas entre as datas '#1[DATA_INICIO]#' e '#2[DATA_FIM]#'?"
	oLoadTool:setExample(I18N(STR0024, {"resource_code"})) //"Quantas horas improdutivas o recurso '#1[RECURSO]#' teve no último mês?"
	oLoadTool:setExample(I18N(STR0025, {"unproductive_reason_code"})) //"Quanto foi registrado de paradas para o motivo '#1[MOTIVO]#' neste mês?"
	oLoadTool:setStrict(.T.)
	oLoadTool:setGroup("resource_usage")
	oLoadTool:addParameter("start_date"                  , "string", STR0033, .T.) //"Filtro da data inicial para busca das horas improdutivas."
	oLoadTool:addParameter("end_date"                    , "string", STR0034, .T.) //"Filtro da data final para busca das horas improdutivas."
	oLoadTool:addParameter("resource_code_optional"      , {"string", "null"}, STR0008 + ". " + BREAK_LINE + STR0018 + BREAK_LINE + STR0035, .T.) //Código do recurso + . \n + "O código do recurso pode conter somente letras, somente números ou a combinação de caracteres, podendo ou não ter caracteres especiais. Exemplo: 'R001', 'INJET', '000001', 'TORNO1'. + \n + "Quando este argumento for enviado com o valor null serão retornadas as horas improdutivas considerando todos os recursos."
	oLoadTool:addParameter("unproductive_reason_optional", {"string", "null"}, STR0036 + BREAK_LINE + STR0037, .T.) //"Código do motivo de horas improdutivas. + \n + "Quando este argumento for enviado com o valor null serão retornadas as horas improdutivas considerando todos os motivos de horas improdutivas."
	oLoadTool:addGlossary("total_unproductive_hours"       , STR0026) //"Total de horas improdutivas apontadas"
	oLoadTool:addGlossary("resources_list"                 , STR0027) //"Lista com os recursos relacionados as horas improdutivas"
	oLoadTool:addGlossary("resource_code"                  , STR0008) //"Código do recurso"
	oLoadTool:addGlossary("resource_description"           , STR0009) //"Descrição do recurso"
	oLoadTool:addGlossary("resource_unproductive_hours"    , STR0028) //"Quantidade de horas improdutivas do recurso"
	oLoadTool:addGlossary("reason_list"                    , STR0029) //"Lista com os motivos de horas improdutivas do recurso"
	oLoadTool:addGlossary("unproductive_reason_code"       , STR0030) //"Código do motivo das horas improdutivas"
	oLoadTool:addGlossary("unproductive_reason_description", STR0031) //"Descrição do motivo das horas improdutivas"
	oLoadTool:addGlossary("reason_unproductive_hours"      , STR0032) //"Quantidade de horas improdutivas no motivo"
	
	If !oLoadTool:createTool()
		cErrorMessage := oLoadTool:getErrorMessage()
	EndIf
	oLoadTool:Destroy()
Return cErrorMessage

/*/{Protheus.doc} getUsageData
Busca os dados da utilização do recurso dentro de um período. Para a busca, é obrigatório que sejam enviados os filtros:
"resource_code" - código do recurso;
"start_date" - data inicial;
"end_date" - data final.

@author lucas.franca/renan.roeder
@since 21/01/2025
@version P12
@param 01 jFilters, Json, Filtros que serão aplicados para a busca das ordens.
@return aReturn, Array, Array com os dados encontrados, sendo:
        aReturn[1] - Logical - Identifica se processou com sucesso a busca.
        aReturn[2] - Json    - Dados obtidos na busca ou mensagem de erro caso não consiga fazer a busca.
        aReturn[3] - Numeric - Status que representa o retorno (200 ok, 400 erro.)
/*/
Method getUsageData(jFilters as Json) as Array Class DTAResourceUsage
	Local aReturn           := {}  as Array
	Local aSuggestions      := {}  as Array
	Local cContext          := ""  as Character
	Local cReferenceDate    := ""  as Character
	Local jAppointmentHours := Nil as Json
	Local jData             := Nil as Json

	If Empty(jFilters["resource_code"]) .Or. Empty(jFilters["start_date"]) .Or. Empty(jFilters["end_date"])
		Return DTAUtils():APIErrorMessage(400, I18N(STR0038, {"resource_code", "start_date", "end_date"})) //"Para realizar a busca da utilização do recurso, os parâmetros '#1[CODIGO]#', '#2[DATA_INI]#' e '#3[DATA_FIM]#' devem ser informados."
	EndIf

	jFilters["start_date"] := PCPConvDat(jFilters["start_date"], 1)
	If Empty(jFilters["start_date"])
		Return DTAUtils():APIErrorMessage(400, I18N(STR0039, {"start_date"})) //"Parâmetro '#1[DATA]#' não é uma data válida. Informe uma data correta para realizar a pesquisa."
	EndIf
	
	jFilters["end_date"] := PCPConvDat(jFilters["end_date"], 1)
	If Empty(jFilters["end_date"])
		Return DTAUtils():APIErrorMessage(400, I18N(STR0039, {"end_date"})) //"Parâmetro '#1[DATA]#' não é uma data válida. Informe uma data correta para realizar a pesquisa."
	EndIf

	jFilters["resource_code"] := Upper(PadR(jFilters["resource_code"], GetSX3Cache("H1_CODIGO", "X3_TAMANHO")))
	SH1->(dbSetOrder(1))
	If !SH1->(dbSeek(xFilial("SH1") + jFilters["resource_code"]))
		Return DTAUtils():APIErrorMessage(400, I18N(STR0040, {RTrim(jFilters["resource_code"])})) //"O recurso #1[CODIGO]# não existe. Informe um recurso existente para realizar a pesquisa."
	EndIf

	jAppointmentHours := PCPMonitorUtils():CalculaTempoApontamentoOperacao(cFilAnt, "'"+SH1->H1_CODIGO+"'", {jFilters["start_date"], jFilters["end_date"]}, .F., , "H6_DATAINI")
	cReferenceDate    := jAppointmentHours:getNames()[1]
	
	jData := JsonObject():New()
	jData["resource_code"          ] := RTrim(SH1->H1_CODIGO)
	jData["resource_description"   ] := RTrim(SH1->H1_DESCRI)
	jData["capacity"               ] := PCPA152Disponibilidade():buscaHorasRecurso(SH1->H1_CODIGO, jFilters["start_date"], jFilters["end_date"])["totalHoras"]
	jData["productive_hours"       ] := PCPMonitorUtils():TransformaMinutosCentesimaisParaTempo(jAppointmentHours[cReferenceDate]["P"], 1)
	jData["unproductive_hours"     ] := PCPMonitorUtils():TransformaMinutosCentesimaisParaTempo(jAppointmentHours[cReferenceDate]["I"], 1)
	jData["reported_hours"         ] := PCPMonitorUtils():TransformaMinutosCentesimaisParaTempo(jAppointmentHours[cReferenceDate]["P"] + jAppointmentHours[cReferenceDate]["I"], 1)
	jData["usage_percentage"       ] := DTAResourceUsage():calculateUsagePercent(jData["reported_hours"    ], jData["capacity"])
	jData["productive_percentage"  ] := DTAResourceUsage():calculateUsagePercent(jData["productive_hours"  ], jData["capacity"])
	jData["unproductive_percentage"] := DTAResourceUsage():calculateUsagePercent(jData["unproductive_hours"], jData["capacity"])
	jData["production_efficiency"  ] := DTAResourceUsage():calculateUsagePercent(jData["unproductive_hours"], jData["productive_hours"])

	aAdd(aSuggestions, {"label": STR0041}) //"Quais ordens de produção preciso produzir nesse recurso hoje?"
	aAdd(aSuggestions, {"label": STR0042}) //"Esse recurso possui uma parada iniciada?"

	cContext := I18N(STR0043, {"resource_code", "resource_description", "resource_code", "resource_description"}) //"Quando apresentar as informações de um recurso, sempre combine o '#1[CODIGO]#' e a '#2[DESCRICAO]#' em uma única frase, no seguinte formato: Recurso: ['#3[CODIGO]#'] - ['#4[DESCRICAO]#']."
	aReturn  := {.T., {"context": cContext, "data": jData, "suggestions": aSuggestions}, 200}

	aSuggestions := Nil
	FreeObj(jAppointmentHours)
	jData := Nil
Return aReturn

/*/{Protheus.doc} getUnproductiveHoursData
Busca quantidade de horas improdutivas dos recursos dentro do período, montando um rank com os recursos com mais horas improdutivas.
Para a busca, é obrigatório que sejam enviados os filtros:
"start_date" - data inicial;
"end_date" - data final.
Opcionalmente, podem ser filtrados:
"resource_code_optional" - código do recurso;
"unproductive_reason_optional" - motivo de horas improdutivas.

@author lucas.franca/renan.roeder
@since 11/04/2025
@version P12
@param 01 jFilters, Json, Filtros que serão aplicados para a busca das ordens.
@return aReturn, Array, Array com os dados encontrados, sendo:
        aReturn[1] - Logical - Identifica se processou com sucesso a busca.
        aReturn[2] - Json    - Dados obtidos na busca ou mensagem de erro caso não consiga fazer a busca.
        aReturn[3] - Numeric - Status que representa o retorno (200 ok, 400 erro.)
/*/
Method getUnproductiveHoursData(jFilters as Json) as Array Class DTAResourceUsage
	Local aReturn  := {}  as Array
	Local aSuggestions := {} as Array
	Local cContext := ""  as Character
	Local jData    := Nil as Json

	If Empty(jFilters["start_date"]) .Or. Empty(jFilters["end_date"])
		Return DTAUtils():APIErrorMessage(400, I18N(STR0044, {"start_date", "end_date"})) //"Para realizar a busca de horas improdutivas, os parâmetros '#1[DATA_INI]#' e '#2[DATA_FIM]#' devem ser informados."
	EndIf

	jFilters["start_date"] := PCPConvDat(jFilters["start_date"], 1)
	If Empty(jFilters["start_date"])
		Return DTAUtils():APIErrorMessage(400, I18N(STR0039, {"start_date"})) //"Parâmetro '#1[DATA]#' não é uma data válida. Informe uma data correta para realizar a pesquisa."
	EndIf
	
	jFilters["end_date"] := PCPConvDat(jFilters["end_date"], 1)
	If Empty(jFilters["end_date"])
		Return DTAUtils():APIErrorMessage(400, I18N(STR0039, {"end_date"})) //"Parâmetro '#1[DATA]#' não é uma data válida. Informe uma data correta para realizar a pesquisa."
	EndIf

	If !Empty(jFilters["resource_code_optional"])
		jFilters["resource_code_optional"] := Upper(PadR(jFilters["resource_code_optional"], GetSX3Cache("H1_CODIGO", "X3_TAMANHO")))
		SH1->(dbSetOrder(1))
		If !SH1->(dbSeek(xFilial("SH1") + jFilters["resource_code_optional"]))
			Return DTAUtils():APIErrorMessage(400, I18N(STR0040, {RTrim(jFilters["resource_code_optional"])})) //"O recurso #1[CODIGO]# não existe. Informe um recurso existente para realizar a pesquisa."
		EndIf
	EndIf

	If !Empty(jFilters["unproductive_reason_optional"])
		jFilters["unproductive_reason_optional"] := Upper(PadR(jFilters["unproductive_reason_optional"], GetSX3Cache("CYN_CDSP", "X3_TAMANHO")))
		CYN->(dbSetOrder(1))
		If !CYN->(dbSeek(xFilial("CYN") + jFilters["unproductive_reason_optional"]))
			Return DTAUtils():APIErrorMessage(400, I18N(STR0045, {RTrim(jFilters["unproductive_reason_optional"])})) //"O motivo de horas improdutivas #1[CODIGO]# não existe. Informe um motivo existente para realizar a pesquisa."
		EndIf
	EndIf

	jData := DTAResourceUsage():searchUnproductiveHours(jFilters)
	If Len(jData["resources_list"]) > 0
		DTAResourceUsage():rankResourceHours(@jData["resources_list"])
		jData["total_unproductive_hours"] := __Min2Hrs(jData["total_unproductive_hours"], .T.)
		aAdd(aSuggestions, {"label": STR0046}) //"Esses recursos possuem paradas iniciadas?"
		
		cContext := I18N(STR0043, {"resource_code", "resource_description", "resource_code", "resource_description"}) //"Quando apresentar as informações de um recurso, sempre combine o '#1[CODIGO]#' e a '#2[DESCRICAO]#' em uma única frase, no seguinte formato: Recurso: ['#3[CODIGO]#'] - ['#4[DESCRICAO]#']."
		cContext += BREAK_LINE + I18N(STR0047, {"unproductive_reason_code", "unproductive_reason_description", "unproductive_reason_code", "unproductive_reason_description"}) //"Quando apresentar as informações de um motivo de horas improdutivas, sempre combine o '#1[CODIGO]#' e a '#2[DESCRICAO]#' em uma única frase, no seguinte formato: Motivo: ['#3[CODIGO]#'] - ['#4[DESCRICAO]#']."
		aReturn  := {.T., {"context": cContext, "data": jData, "suggestions": aSuggestions}, 200}
		aSuggestions := Nil
	Else
		Return DTAUtils():APIErrorMessage(400, STR0048) //"Não foram encontradas horas improdutivas para o período informado."
	EndIf
	jData := Nil
Return aReturn

/*/{Protheus.doc} searchUnproductiveHours
Faz a busca na tabela SH6 das horas improdutivas apontadas de acordo com os filtros estabelecidos.

@author lucas.franca/renan.roeder
@since 11/04/2025
@version P12
@param 01, jFilters, Json, JSON com os parâmetros para filtro
@return jData, Json, Informações de horas improdutivas encontradas
/*/
Method searchUnproductiveHours(jFilters as Json) as Json Class DTAResourceUsage
	Local cAlias         := ""  as Character
	Local cQuery         := ""  as Character
	Local jData          := Nil as Json
	Local nPosParam      := 0   as Numeric
	Local nResourceIndex := 0   as Numeric
	Local nReasonIndex   := 0   as Numeric
	Local nTime          := 0   as Numeric
	Local oQuery         := Nil as Object

	cQuery := "SELECT SH6.H6_TEMPO, SH6.H6_TIPOTEM, SH6.H6_MOTIVO, CYN.CYN_DSSP, SH6.H6_RECURSO, SH1.H1_DESCRI"
	cQuery +=  " FROM " + RetSqlName("SH6") + " SH6"
	cQuery +=  " LEFT JOIN " + RetSqlName("CYN") + " CYN"
	cQuery +=    " ON CYN.CYN_FILIAL = ?"
	cQuery +=   " AND CYN.CYN_CDSP   = SH6.H6_MOTIVO"
	cQuery +=   " AND CYN.D_E_L_E_T_ = ' '"
	cQuery += " INNER JOIN " + RetSqlName("SH1") + " SH1"
	cQuery +=    " ON SH1.H1_FILIAL  = ?"
	cQuery +=   " AND SH1.H1_CODIGO  = SH6.H6_RECURSO"
	cQuery +=   " AND SH1.D_E_L_E_T_ = ' '"
	cQuery += " WHERE SH6.H6_FILIAL  = ?"
	cQuery +=   " AND SH6.H6_DATAINI BETWEEN ? AND ?"
	cQuery +=   " AND SH6.H6_TIPO    = 'I'"
	If !Empty(jFilters["resource_code_optional"])
		cQuery += " AND SH6.H6_RECURSO = ?"
	EndIf
	If !Empty(jFilters["unproductive_reason_optional"])
		cQuery += " AND SH6.H6_MOTIVO = ?"
	EndIf
	cQuery +=   " AND SH6.D_E_L_E_T_ = ' '"

	oQuery := FwExecStatement():New(cQuery)
	oQuery:setString(++nPosParam, xFilial("CYN"))
	oQuery:setString(++nPosParam, xFilial("SH1"))
	oQuery:setString(++nPosParam, xFilial("SH6"))
	oQuery:setDate(++nPosParam, jFilters["start_date"])
	oQuery:setDate(++nPosParam, jFilters["end_date"])
	If !Empty(jFilters["resource_code_optional"])
		oQuery:setString(++nPosParam, jFilters["resource_code_optional"])
	EndIf
	If !Empty(jFilters["unproductive_reason_optional"])
		oQuery:setString(++nPosParam, jFilters["unproductive_reason_optional"])
	EndIf

	jData  := {"total_unproductive_hours": 0, "resources_list": Array(0)}
	cAlias := oQuery:openAlias()
	While (cAlias)->(!Eof())
		nResourceIndex := DTAResourceUsage():getResourceIndex(@jData["resources_list"], cAlias)
		nReasonIndex   := DTAResourceUsage():getReasonIndex(@jData["resources_list"][nResourceIndex], cAlias)

		nTime := DTAResourceUsage():convertTimeToMinutes((cAlias)->H6_TEMPO,(cAlias)->H6_TIPOTEM)
		jData["total_unproductive_hours"] += nTime
		jData["resources_list"][nResourceIndex]["resource_unproductive_hours"] += nTime
		jData["resources_list"][nResourceIndex]["reason_list"][nReasonIndex]["reason_unproductive_hours"] += nTime

		(cAlias)->(dbSkip())
	End
	(cAlias)->(dbCloseArea())
	oQuery:Destroy()
	FreeObj(oQuery)
Return jData

/*/{Protheus.doc} getResourceIndex
Retorna o índice do array de recursos de acordo com o código do recurso
Se não encontrar o índice para o recurso, irá criar uma nova posição no array

@author lucas.franca/renan.roeder
@since 11/04/2025
@version P12
@param 01, aResources, Array    , Array de recursos para busca
@param 02, cAlias    , Character, Alias da query com as informações em processamento
@return nIndex, Numeric, Índice do array de recursos
/*/
Method getResourceIndex(aResources as Array, cAlias as Character) as Numeric Class DTAResourceUsage
	Local jResource := Nil as Json
	Local nIndex    := 0   as Numeric

	nIndex := aScan(aResources, {|x| x["resource_code"] == (cAlias)->H6_RECURSO})
	If nIndex == 0
		jResource := JsonObject():New()
		jResource["resource_code"              ] := (cAlias)->H6_RECURSO
		jResource["resource_description"       ] := RTrim((cAlias)->H1_DESCRI)
		jResource["resource_unproductive_hours"] := 0
		jResource["reason_list"                ] := {}

		aAdd(aResources, jResource)
		nIndex := Len(aResources)
	EndIf
	jResource := Nil
Return nIndex

/*/{Protheus.doc} getReasonIndex
Retorna o índice do array de motivos de horas improdutivas de acordo com o código do motivo para o recurso
Se não encontrar o índice para o motivo, irá criar uma nova posição no array

@author lucas.franca/renan.roeder
@since 11/04/2025
@version P12
@param 01, jResource, Json     , Json com as informações do recurso
@param 02, cAlias   , Character, Alias da query com as informações em processamento
@return nIndex, Numeric, Índice do array de motivos de horas improdutivas para o recurso
/*/
Method getReasonIndex(jResource as Json, cAlias as Character) as Numeric Class DTAResourceUsage
	Local jReason := Nil as Json
	Local nIndex  := 0   as Numeric

	nIndex := aScan(jResource["reason_list"], {|x| x["unproductive_reason_code"] == (cAlias)->H6_MOTIVO})
	If nIndex == 0
		jReason := JsonObject():New()
		jReason["unproductive_reason_code"       ] := (cAlias)->H6_MOTIVO
		jReason["unproductive_reason_description"] := RTrim((cAlias)->CYN_DSSP)
		jReason["reason_unproductive_hours"      ] := 0
		If Empty(jReason["unproductive_reason_description"])
			jReason["unproductive_reason_description"] := STR0049 //"Horas improdutivas sem classificação de motivo."
		EndIf
		aAdd(jResource["reason_list"], jReason)
		nIndex := Len(jResource["reason_list"])
		jReason := Nil
	EndIf
Return nIndex

/*/{Protheus.doc} rankResourceHours
Monta o RANK de quais recursos possuem as maiores horas apontadas.
Irá ordenar o array pela quantidade de horas, da maior até o menor.
Também irá converter as horas de minutos para HH:MM e adicionar TRIM nas informações do tipo CHAR.

@author lucas.franca/renan.roeder
@since 11/04/2025
@version P12
@param 01, aResources, Array, Array com os recursos com horas improdutivas apontadas (passado como referência)
@return Nil
/*/
Method rankResourceHours(aResources as Array) Class DTAResourceUsage
	Local nIndex := 0 as Numeric

	aSort(aResources,,,{|x,y| x["resource_unproductive_hours"] > y["resource_unproductive_hours"]})

	For nIndex := 1 To Len(aResources)
		aResources[nIndex]["resource_unproductive_hours"] := __Min2Hrs(aResources[nIndex]["resource_unproductive_hours"], .T.)
		aResources[nIndex]["resource_code"              ] := RTrim(aResources[nIndex]["resource_code"])
		DTAResourceUsage():rankReasonHours(@aResources[nIndex]["reason_list"])
	Next nIndex
Return

/*/{Protheus.doc} rankReasonHours
Monta o RANK de quais motivos vinculados a um recurso possuem as maiores horas apontadas.
Irá ordenar o array pela quantidade de horas, da maior até o menor.
Também irá converter as horas de minutos para HH:MM e adicionar TRIM nas informações do tipo CHAR.

@author lucas.franca/renan.roeder
@since 11/04/2025
@version P12
@param 01, aReasons, Array, Array com os motivos de horas improdutivas de um recurso (passado como referência)
@return Nil
/*/
Method rankReasonHours(aReasons as Array) Class DTAResourceUsage
	Local nIndex := 0 as Numeric

	aSort(aReasons,,,{|x,y| x["reason_unproductive_hours"] > y["reason_unproductive_hours"]})

	For nIndex := 1 To Len(aReasons)
		aReasons[nIndex]["reason_unproductive_hours"] := __Min2Hrs(aReasons[nIndex]["reason_unproductive_hours"], .T.)
		aReasons[nIndex]["unproductive_reason_code" ] := RTrim(aReasons[nIndex]["unproductive_reason_code"])
	Next nIndex
Return

/*/{Protheus.doc} convertTimeToMinutes
Converte um tempo que está no formato normal ou centesimal em minutos
Ex: "01:50" com tipo de tempo centesimal, irá retornar 90 minutos.
    "01:30" com tipo de tempo normal, irá retornar 90 minutos.

@author lucas.franca/renan.roeder
@since 11/04/2025
@version P12
@param 01, cTime    , Character, String das horas para conversão
@param 02, nTimeType, Numeric  , Tipo de tempo, 1=Normal;2=Centesimal
@return nMinutes, Numeric, Minutos correspondentes ao horário
/*/
Method convertTimeToMinutes(cTime as Character, nTimeType as Numeric) as Numeric Class DTAResourceUsage
	Local aHours   := {} as Array
	Local nMinutes := 0  as Numeric

	If nTimeType == 1
		nMinutes := __Hrs2Min(cTime)
	Else
		aHours   := StrTokArr(cTime, ":")
		nMinutes := Val(aHours[1]) * 60
		nMinutes += Round(Val(aHours[2]) * 0.6, 0)
		aSize(aHours, 0)
	EndIf
Return nMinutes

/*/{Protheus.doc} calculateUsagePercent
Calcula o percentual de utilização entre duas horas

@author lucas.franca/renan.roeder
@since 21/01/2025
@version P12
@param 01, cHoursUsed    , Character, Horas utilizadas para efetuar o cálculo. Ex - "02:30"
@param 02, cHoursCapacity, Character, Horas da capacidade para efetuar o cálculo. Ex - "16:14"
@return cUsagePercent, Character, Percentual de uso entre as duas horas no formato texto "15.4 %"
/*/
Method calculateUsagePercent(cHoursUsed as Character, cHoursCapacity as Character) as Character Class DTAResourceUsage
	Local cUsagePercent := "" as Character
	Local nUsagePercent := 0  as Numeric
	
	nUsagePercent := Round(( __Hrs2Min(cHoursUsed) / __Hrs2Min(cHoursCapacity) ) * 100, 2)
	cUsagePercent := cValToChar(nUsagePercent) + " %"
Return cUsagePercent
