#Include "tlpp-core.th"
#Include "TOTVS.CH"
#Include "DTAProductLotsExpiration.ch"

#DEFINE BREAK_LINE "\n"

/*/{Protheus.doc} DTAProductLotsExpiration
Classe responsável pela ferramenta dos lotes do produto próximos a vencer

@author lucas.franca/renan.roeder
@since 21/01/2025
@version P12
/*/
Class DTAProductLotsExpiration
	Static Method getDataPeriod(jFilters as Json) as Array
	Static Method getDataUsage(jFilters as Json) as Array
	Static Method loadTool() as Character
	Static Method loadToolPeriod() as Character
	Static Method loadToolUsage() as Character
EndClass

/*/{Protheus.doc} loadTool
Método que faz a carga das propriedades das ferramentas disponíveis por esta classe. Alimenta as tabelas HZV/HZW.

@author lucas.franca/renan.roeder
@since 21/01/2025
@version P12
@return cErrorMessage, Character, Indica se houve erro na carga da ferramenta
/*/
Method loadTool() as Character Class DTAProductLotsExpiration
	Local cErrorMessage := "" as Character

	cErrorMessage := DTAProductLotsExpiration():loadToolPeriod()
	cErrorMessage += DTAProductLotsExpiration():loadToolUsage()
Return cErrorMessage

/*/{Protheus.doc} loadToolPeriod
Método que faz a carga das propriedades das ferramentas disponíveis por esta classe. Alimenta as tabelas HZV/HZW.

@author lucas.franca/renan.roeder
@since 21/01/2025
@version P12
@return cErrorMessage, Character, Indica se houve erro na carga da ferramenta
/*/
Method loadToolPeriod() as Character Class DTAProductLotsExpiration
	Local cDescription  := ""                            as Character
	Local cErrorMessage := ""                            as Character
	Local cName         := "get_product_lots_expiration" as Character
	Local cRules        := ""                            as Character
	Local cVersion      := "003"                         as Character
	Local oLoadTool     := Nil                           as Object

	If DTALoad():toolIsUpdated(cName, cVersion)
		Return ""
	EndIf
	cDescription := STR0001 //"Obtém informações sobre os lotes de um produto que estão com o prazo de validade próximo ou já vencido, dentro de um período específico."
	cRules := I18N(STR0002, {"product_code"}) //"Se o argumento '#1[ARGUMENTO]#' não for informado pelo usuário, solicite a informação antes de realizar a pesquisa. "
	oLoadTool := DTALoad():New()
	oLoadTool:setName(cName)
	oLoadTool:setClassName("DTAProductLotsExpiration")
	oLoadTool:setDataMethod("getDataPeriod")
	oLoadTool:setVersion(cVersion)
	oLoadTool:setDescription(cDescription)
	oLoadTool:setShortDescription(STR0003) //"Busca os lotes do produto que vencerão no período informado"
	oLoadTool:setExample(I18N(STR0004, {"product_code"})) //"Quais lotes do produto '#1[CODIGO]#' vencem até o final deste mês?"
	oLoadTool:setExample(I18N(STR0005, {"product_code"})) //"Quais lotes do produto '#1[CODIGO]#' vencerão hoje?"
	oLoadTool:setRules(cRules)
	oLoadTool:setGroup("product_information")
	oLoadTool:setStrict(.T.)
	oLoadTool:addParameter("product_code", "string" , STR0006 + "." + BREAK_LINE + STR0007, .T.) //"Código do produto + . \n + "O código do produto pode conter somente letras, somente números ou a combinação de caracteres, podendo ou não ter caracteres especiais. Exemplo: '00255141', 'BICICLETA', 'SKATE', 'SKT001', 'PRODUTO001'."
	oLoadTool:addParameter("start_date"  , "string" , STR0008, .T.) //"Filtro da data inicial para busca dos lotes do produto."
	oLoadTool:addParameter("end_date"    , "string" , STR0009, .T.) //"Filtro da data final para busca dos lotes do produto."
	oLoadTool:addGlossary("product_code"            , STR0006) //"Código do produto"
	oLoadTool:addGlossary("product_description"     , STR0010) //"Descrição do produto"
	oLoadTool:addGlossary("product_unit_measure"    , STR0011) //"Unidade de medida do produto"
	oLoadTool:addGlossary("lots"                    , STR0012) //"Lista de lotes do produto"
	oLoadTool:addGlossary("lot_code"                , STR0013) //"Código do lote"
	oLoadTool:addGlossary("lot_expiration_date"     , STR0014) //"Vencimento do lote"
	oLoadTool:addGlossary("lot_stock_balance"       , STR0015) //"Saldo em estoque do lote"
	oLoadTool:addGlossary("lot_warehouse_code"      , STR0016) //"Código do armazém do lote"
	If !oLoadTool:createTool()
		cErrorMessage := oLoadTool:getErrorMessage()
	EndIf
	oLoadTool:Destroy()
Return cErrorMessage

/*/{Protheus.doc} getDataPeriod
Método que faz a busca os lotes do produto com vencimento no período.
@author lucas.franca/renan.roeder
@since 21/01/2025
@version P12
@param 01 jFilters, Json, Filtros que serão aplicados para a busca dos saldos em estoque.
@return aReturn, Array, Array com os dados encontrados, sendo:
        aReturn[1] - Logical - Identifica se processou com sucesso a busca.
        aReturn[2] - Json    - Dados obtidos na busca ou mensagem de erro caso não consiga fazer a busca.
        aReturn[3] - Numeric - Status que representa o retorno (200 ok, 400 erro.)
/*/
Method getDataPeriod(jFilters as Json) as Array Class DTAProductLotsExpiration
	Local aLots        := {}  as Array
	Local aReturn      := {}  as Array
	Local aSuggestions := {}  as Array
	Local cContext     := ""  as Character
	Local cLotCode     := ""  as Character
	Local cWarehouse   := ""  as Character
	Local jData        := Nil as Json
	Local nSize        := 0   as Numeric
	Local nPosLot      := 0   as Numeric
	Local nIndex       := 0   as Numeric

	If Empty(jFilters["product_code"]) .Or. Empty(jFilters["start_date"]) .Or. Empty(jFilters["end_date"])
		Return DTAUtils():APIErrorMessage(400, I18N(STR0017, {"product_code", "start_date", "end_date"})) //"Para realizar a busca dos lotes do produto, os parâmetros '#1[PARAM_1]#', '#2[PARAM_2]#' e '#3[PARAM_3]#' devem ser informados."
	EndIf
	jFilters["start_date"] := PCPConvDat(jFilters["start_date"], 1)
	If Empty(jFilters["start_date"])
		Return DTAUtils():APIErrorMessage(400, I18N(STR0018, {"start_date"})) //"Parâmetro '#1[PARAMETRO]#' não é uma data válida. Informe uma data correta para realizar a pesquisa."
	EndIf
	jFilters["end_date"] := PCPConvDat(jFilters["end_date"], 1)
	If Empty(jFilters["end_date"])
		Return DTAUtils():APIErrorMessage(400, I18N(STR0018, {"end_date"})) //"Parâmetro '#1[PARAMETRO]#' não é uma data válida. Informe uma data correta para realizar a pesquisa."
	EndIf
	jFilters["product_code"] := Upper(PadR(jFilters["product_code"], GetSX3Cache("B1_COD", "X3_TAMANHO")))
	SB1->(dbSetOrder(1))
	If !SB1->(dbSeek(xFilial("SB1") + jFilters["product_code"]))
		Return DTAUtils():APIErrorMessage(400, I18N(STR0019, {RTrim(jFilters["product_code"])})) //"O produto #1[PRODUTO]# não existe. Informe um produto existente para realizar a pesquisa."
	EndIf
	If !SB1->B1_RASTRO == "L"
		Return DTAUtils():APIErrorMessage(400, I18N(STR0020, {RTrim(jFilters["product_code"])})) //"O produto #1[PRODUTO]# não é controlado por lote."
	EndIf
	nSize := GetSX3Cache("NNR_CODIGO", "X3_TAMANHO")
	jData := JsonObject():New()
	jData["product_code"        ] := RTrim(SB1->B1_COD)
	jData["product_description" ] := RTrim(SB1->B1_DESC)
	jData["product_unit_measure"] := RTrim(SB1->B1_UM)
	aLots := SldPorLote(SB1->B1_COD, Space(nSize), 999999999999999, 999999999999999, Nil, Nil, Nil, Nil, Nil, .F., Replicate("Z", nSize), .T.,, .T., dDataBase,,,.T.)
	If !Empty(aLots)
		jData["lots"] := {}
		For nIndex := 1 To Len(aLots)
			If (aLots[nIndex][7] >= jFilters["start_date"] .And. aLots[nIndex][7] <= jFilters["end_date"]) .And. aLots[nIndex][5] > 0
				cLotCode   := RTrim(aLots[nIndex][1])
				cWarehouse := aLots[nIndex][11]
				nPosLot    := aScan(jData["lots"], {|x| x["lot_code"] == cLotCode .And. x["lot_warehouse_code"] == cWarehouse})
				If nPosLot > 0
					jData["lots"][nPosLot]["lot_stock_balance"] += aLots[nIndex][5]
				Else
					aAdd(jData["lots"], {"lot_code": cLotCode, "lot_stock_balance": aLots[nIndex][5], "lot_expiration_date": PCPConvDat(aLots[nIndex][7],2), "lot_warehouse_code": cWarehouse})
				EndIf
			EndIf
		Next nIndex
		aSize(aLots, 0)
		If Len(jData["lots"]) > 0
			aAdd(aSuggestions, {"label": STR0021}) //"Quais ordens de produção estão consumindo esses lotes?"
			cContext := I18N(STR0022, {"product_code", "product_description", "product_code", "product_description"}) //"Quando apresentar as informações de um produto, sempre combine o '#1[PRODUTO]#' e a '#2[DESCRICAO]#' em uma única frase, no seguinte formato: Produto: ['#3[PRODUTO]#'] - ['#4[DESCRICAO]#']."
			cContext += BREAK_LINE + I18N(STR0023, {"lots", "lot_code", "lot_warehouse_code"}) //"Os itens da lista '#1[LISTA]#' devem ser apresentados separadamente considerando seu identificador único que é composto pelos atributos '#2[LOTE]#' e '#3[ARMAZEM]#'."
			aReturn := {.T., {"context": cContext, "data": jData, "suggestions": aSuggestions}, 200}
			aSuggestions := Nil
		Else
			aReturn := DTAUtils():APIErrorMessage(400, STR0024) //"Não foram encontrados lotes do produto no período informado."
		EndIf
	Else
		aReturn := DTAUtils():APIErrorMessage(400, STR0025) //"Não foram encontrados lotes do produto."
	EndIf
	jData := Nil
Return aReturn

/*/{Protheus.doc} loadToolUsage
Método que faz a carga das propriedades das ferramentas disponíveis por esta classe. Alimenta as tabelas HZV/HZW.

@author lucas.franca/renan.roeder
@since 21/01/2025
@version P12
@return cErrorMessage, Character, Indica se houve erro na carga da ferramenta
/*/
Method loadToolUsage() as Character Class DTAProductLotsExpiration
	Local cDescription  := ""                      as Character
	Local cErrorMessage := ""                      as Character
	Local cName         := "get_product_lot_usage" as Character
	Local cRules        := ""                      as Character
	Local cVersion      := "002"                   as Character
	Local oLoadTool     := Nil                     as Object

	If DTALoad():toolIsUpdated(cName, cVersion)
		Return ""
	EndIf
	cDescription := STR0026 //"Fornece informações de quais ordens de produção vão consumir o lote do produto."
	cRules := I18N(STR0002, {"product_code"}) //"Se o argumento '#1[ARGUMENTO]#' não for informado pelo usuário, solicite a informação antes de realizar a pesquisa. "
	cRules += BREAK_LINE + I18N(STR0002, {"lot_code"}) //"Se o argumento '#1[ARGUMENTO]#' não for informado pelo usuário, solicite a informação antes de realizar a pesquisa. "
	oLoadTool := DTALoad():New()
	oLoadTool:setName(cName)
	oLoadTool:setClassName("DTAProductLotsExpiration")
	oLoadTool:setDataMethod("getDataUsage")
	oLoadTool:setVersion(cVersion)
	oLoadTool:setDescription(cDescription)
	oLoadTool:setShortDescription(STR0027) //"Busca quais ordens de produção vão consumir o lote do produto"
	oLoadTool:setExample(I18N(STR0028, {"lot_code", "product_code"})) //"Quais ordens de produção estão usando o lote '#1[LOTE]#' do produto '#2[PRODUTO]#'?"
	oLoadTool:setExample(I18N(STR0040, {"lot_code", "product_code"})) //"O lote '#1[LOTE]#' do produto '#2[PRODUTO]#' está em qual OP?"
	oLoadTool:setRules(cRules)
	oLoadTool:setGroup("product_information")
	oLoadTool:setStrict(.T.)
	oLoadTool:addParameter("product_code", "string" , STR0006 + "." + BREAK_LINE + STR0007, .T.) //"Código do produto + . \n + "O código do produto pode conter somente letras, somente números ou a combinação de caracteres, podendo ou não ter caracteres especiais. Exemplo: '00255141', 'BICICLETA', 'SKATE', 'SKT001', 'PRODUTO001'."
	oLoadTool:addParameter("lot_code"    , "string" , STR0013 + "." + BREAK_LINE + STR0034 + BREAK_LINE + STR0035, .F.) //Código do lote + . \n + O código do lote pode conter somente letras, somente números ou a combinação de caracteres. Exemplo: 'AUTO000001', 'LT22012022', '7726618930'. + \n + Quando este argumento for enviado com o valor null serão retornados os saldos de todos os lotes."
	oLoadTool:addGlossary("product_code"                         , STR0006) //"Código do produto"
	oLoadTool:addGlossary("product_description"                  , STR0010) //"Descrição do produto"
	oLoadTool:addGlossary("product_unit_measure"                 , STR0011) //"Unidade de medida do produto"
	oLoadTool:addGlossary("lots"                                 , STR0012) //"Lista de lotes do produto"
	oLoadTool:addGlossary("lot_code"                             , STR0013) //"Código do lote"
	oLoadTool:addGlossary("lot_expiration_date"                  , STR0014) //"Vencimento do lote"
	oLoadTool:addGlossary("lot_stock_balance"                    , STR0015) //"Saldo em estoque do lote"
	oLoadTool:addGlossary("lot_warehouse_code"                   , STR0016) //"Código do armazém do lote"
	oLoadTool:addGlossary("production_orders_list"               , STR0029) //"Lista das ordens de produção com consumo do saldo do lote"
	oLoadTool:addGlossary("total_orders"                         , STR0041) //"Quantidade de ordens de produção que possuem o lote do produto no empenho"
	oLoadTool:addGlossary("total_balance"                        , STR0042) //"Saldo total empenhado do produto no lote"
	oLoadTool:addGlossary("production_order_code"                , STR0030) //"Código da ordem de produção"
	oLoadTool:addGlossary("production_order_product"             , STR0031) //"Produto da ordem de produção"
	oLoadTool:addGlossary("production_order_product_description" , STR0038) //"Descrição do produto da ordem de produção"
	oLoadTool:addGlossary("production_order_product_unit_measure", STR0039) //"Unidade de medida do produto da ordem de produção"
	oLoadTool:addGlossary("production_order_allocation_balance"  , STR0043) //"Saldo do empenho na ordem de produção"
	oLoadTool:addGlossary("allocation_date_list"                 , STR0044) //"Lista de empenhos da ordem por data"
	oLoadTool:addGlossary("allocation_balance"                   , STR0032) //"Quantidade do empenho a ser consumida"
	oLoadTool:addGlossary("allocation_date"                      , STR0033) //"Data do empenho"
	If !oLoadTool:createTool()
		cErrorMessage := oLoadTool:getErrorMessage()
	EndIf
	oLoadTool:Destroy()
Return cErrorMessage

/*/{Protheus.doc} getDataUsage
Método que faz a busca dos empenhos/ordens que utilizam determinado lote

@author lucas.franca/renan.roeder
@since 21/01/2025
@version P12
@param 01 jFilters, Json, Filtros que serão aplicados para a busca dos saldos em estoque.
@return aReturn, Array, Array com os dados encontrados, sendo:
        aReturn[1] - Logical - Identifica se processou com sucesso a busca.
        aReturn[2] - Json    - Dados obtidos na busca ou mensagem de erro caso não consiga fazer a busca.
        aReturn[3] - Numeric - Status que representa o retorno (200 ok, 400 erro.)
/*/
Method getDataUsage(jFilters as Json) as Array Class DTAProductLotsExpiration
	Local aLots             := {}  as Array
	Local aReturn           := {}  as Array
	Local cContext          := ""  as Character
	Local cLotCode          := ""  as Character
	Local cWarehouse        := ""  as Character
	Local jOrders           := Nil as Json
	Local jData             := Nil as Json
	Local lAllRows          := .T. as Logical
	Local lAddContext       := .F. as Logical
	Local nIndex            := 0   as Numeric
	Local nSize             := 0   as Numeric
	Local nPosLot           := 0   as Numeric

	If Empty(jFilters["product_code"])
		Return DTAUtils():APIErrorMessage(400, I18N(STR0036, {"product_code"})) //"Para realizar a busca dos lotes do produto, o parâmetro '#1[PARAMETRO]#' deve ser informado."
	EndIf
	If Empty(jFilters["lot_code"])
		Return DTAUtils():APIErrorMessage(400, I18N(STR0036, {"lot_code"})) //"Para realizar a busca dos lotes do produto, o parâmetro '#1[PARAMETRO]#' deve ser informado."
	EndIf
	jFilters["lot_code"] := PadR(jFilters["lot_code"], GetSX3Cache("B8_LOTECTL", "X3_TAMANHO"))
	jFilters["product_code"] := Upper(PadR(jFilters["product_code"], GetSX3Cache("B1_COD", "X3_TAMANHO")))
	SB1->(dbSetOrder(1))
	If !SB1->(dbSeek(xFilial("SB1") + jFilters["product_code"]))
		Return DTAUtils():APIErrorMessage(400, I18N(STR0019, {RTrim(jFilters["product_code"])})) //"O produto #1[PRODUTO]# não existe. Informe um produto existente para realizar a pesquisa."
	EndIf
	If !SB1->B1_RASTRO == "L"
		Return DTAUtils():APIErrorMessage(400, I18N(STR0020, {RTrim(jFilters["product_code"])})) //"O produto #1[PRODUTO]# não é controlado por lote."
	EndIf
	nSize := GetSX3Cache("NNR_CODIGO", "X3_TAMANHO")
	jData := JsonObject():New()
	jData["product_code"        ] := RTrim(SB1->B1_COD)
	jData["product_description" ] := RTrim(SB1->B1_DESC)
	jData["product_unit_measure"] := RTrim(SB1->B1_UM)
	aLots := SldPorLote(SB1->B1_COD, Space(nSize), 999999999999999, 999999999999999, jFilters["lot_code"], Nil, Nil, Nil, Nil, .F., Replicate("Z", nSize), .T.,, .T., dDataBase,,,.T.)
	If !Empty(aLots)
		jData["lots"] := {}
		For nIndex := 1 To Len(aLots)
			cLotCode   := RTrim(aLots[nIndex][1])
			cWarehouse := aLots[nIndex][11]
			nPosLot    := aScan(jData["lots"], {|x| x["lot_code"] == cLotCode .And. x["lot_warehouse_code"] == cWarehouse})
			//Quando possui controle de endereço, sumariza a quantidade por armazém + lote.
			If nPosLot > 0
				jData["lots"][nPosLot]["lot_stock_balance"] += aLots[nIndex][5]
			Else
				jOrders := DTAProductionOrderAllocations():getAllocationsFromProduct(SB1->B1_COD, aLots[nIndex][1], aLots[nIndex][11], @lAllRows)
				aAdd(jData["lots"], {"lot_code": cLotCode, "lot_stock_balance": aLots[nIndex][5], "lot_expiration_date": PCPConvDat(aLots[nIndex][7],2), "lot_warehouse_code": cWarehouse, "production_orders_list": jOrders})
				lAddContext := lAddContext .Or. !lAllRows
				jOrders := Nil
			EndIf
		Next nIndex
		aSize(aLots, 0)
		cContext := I18N(STR0022, {"product_code", "product_description", "product_code", "product_description"}) //"Quando apresentar as informações de um produto, sempre combine o '#1[PRODUTO]#' e a '#2[DESCRICAO]#' em uma única frase, no seguinte formato: Produto: ['#3[PRODUTO]#'] - ['#4[DESCRICAO]#']."
		cContext += BREAK_LINE + I18N(STR0023, {"lots", "lot_code", "lot_warehouse_code"}) //"Os itens da lista '#1[LISTA]#' devem ser apresentados separadamente considerando seu identificador único que é composto pelos atributos '#2[LOTE]#' e '#3[ARMAZEM]#'."
		If lAddContext
			cContext += BREAK_LINE
			cContext += I18N(STR0037, {"production_orders_list"}) //"Este lote é utilizado em muitos empenhos. A '#1[LISTA_ORDENS]#' possui informações parciais sobre quais ordens de produção utilizam este lote, e não será possível consultar a totalidade das informações através do Chat. O usuário deve ser orientado que está visualizando informações parciais, e para consultar as informações completas deve ser realizada a consulta nas rotinas de Empenhos do ERP Protheus."
		EndIf
		aReturn := {.T., {"context": cContext, "data": jData}, 200}
	Else
		aReturn := DTAUtils():APIErrorMessage(400, STR0025) //"Não foram encontrados lotes do produto."
	EndIf
	jData := Nil
Return aReturn
