#Include "TLPP-CORE.TH"
#Include "TOTVS.CH"
#Include "DTAPRODUCTIONORDERALLOCATIONS.CH"

/*/{Protheus.doc} DTAProductionOrderAllocations
Classe responsável pela ferramenta de busca dos empenhos da ordem de produção

@author lucas.franca/renan.roeder
@since 21/03/2025
@version P12
/*/
Class DTAProductionOrderAllocations
	Static Method getData(jFilters as Json) as Array
	Static Method loadTool() as Character
	Static Method getAllocationsList(cProductionOrder as Character) as Array
	Static Method getAllocationsFromProduct(cProductCode as Character, cLotCode as Character, cWarehouseCode as Character, lAllRows as Logical, dStartDate as Date, dEndDate as Date) as Json
	Static Method getStockQuantity(cProduct as Character, cWarehouse as Character, cLotCode as Character) as Numeric
	Static Method getListOfOrders(jOrders as Json) as Array
EndClass

/*/{Protheus.doc} loadTool
Método que faz a carga das propriedades das ferramentas disponíveis por esta classe. Alimenta as tabelas HZV/HZW.

@author lucas.franca/renan.roeder
@since 21/03/2025
@version P12
@return cErrorMessage, Character, Indica se houve erro na carga da ferramenta
/*/
Method loadTool() as Character Class DTAProductionOrderAllocations
	Local cDescription  := ""  as Character
	Local cErrorMessage := ""  as Character
	Local cName         := ""  as Character
	Local cVersion      := ""  as Character
	Local oLoadTool     := Nil as Object

	cName    := "get_production_order_allocations"
	cVersion := "001"

	If DTALoad():toolIsUpdated(cName, cVersion)
		Return ""
	EndIf

	cDescription := STR0001 //"Fornece uma lista com os empenhos de uma ordem de produção. Os empenhos de uma ordem de produção são as matérias-primas utilizadas na execução da ordem de produção, e também podem ser chamados de componentes. "
	oLoadTool := DTALoad():New()
	oLoadTool:setName(cName)
	oLoadTool:setClassName("DTAProductionOrderAllocations")
	oLoadTool:setDataMethod("getData")
	oLoadTool:setVersion(cVersion)
	oLoadTool:setDescription(cDescription)
	oLoadTool:setShortDescription(STR0003) //"Fornece os empenhos da ordem de produção"
	oLoadTool:setExample(I18N(STR0004, {"production_order_code"})) //"Quais são os empenhos da ordem de produção '#1[production_order_code]#'?"
	oLoadTool:setExample(I18N(STR0005, {"production_order_code"})) //"Quais são os componentes da ordem '#1[production_order_code]#'?"
	oLoadTool:setExample(I18N(STR0006, {"production_order_code"})) //"Quais materiais a ordem '#1[production_order_code]#' precisa para ser feita?"
	oLoadTool:setStrict(.T.)
	oLoadTool:setGroup("production_order")
	oLoadTool:addParameter("production_order_code", "string", STR0007 + ". \n " + STR0008, .T.) //"Código da Ordem de Produção, também conhecido como OP ou Ordem" //"O código da ordem de produção pode conter somente letras, somente números ou a combinação de caracteres. Exemplo: '00549801001', 'pcpXYZ01005', '00000103001', '10010602001001'."
	oLoadTool:addGlossary("production_order_code" , STR0007) //"Código da Ordem de Produção, também conhecido como OP ou Ordem"
	oLoadTool:addGlossary("product_code"          , STR0009) //"Código do produto da ordem"
	oLoadTool:addGlossary("product_description"   , STR0010) //"Descrição do produto da ordem"
	oLoadTool:addGlossary("product_unit_measure"  , STR0011) //"Unidade de medida do produto"
	oLoadTool:addGlossary("allocations_list"      , STR0012) //"Lista dos empenhos/componentes da ordem"
	oLoadTool:addGlossary("component_code"        , STR0013) //"Código do componente"
	oLoadTool:addGlossary("component_description" , STR0014) //"Descrição do componente"
	oLoadTool:addGlossary("component_unit_measure", STR0015) //"Unidade de medida do componente"
	oLoadTool:addGlossary("planned_quantity"      , STR0016) //"Quantidade planejada do componente"
	oLoadTool:addGlossary("balance_quantity"      , STR0017) //"Quantidade a ser consumida do componente"
	oLoadTool:addGlossary("stock_quantity"        , STR0018) //"Quantidade disponível em estoque do componente"
	oLoadTool:addGlossary("allocation_date"       , STR0019) //"Data do componente"
	oLoadTool:addGlossary("warehouse_code"        , STR0020) //"Armazém do componente"
	oLoadTool:addGlossary("lot_code"              , STR0021) //"Código do lote vinculado ao componente"
	oLoadTool:addGlossary("is_labor_product"      , STR0032) //"É um produto de mão de obra?"

	If !oLoadTool:createTool()
		cErrorMessage := oLoadTool:getErrorMessage()
	EndIf
	oLoadTool:Destroy()
Return cErrorMessage

/*/{Protheus.doc} getData
Busca a lista de empenhos da ordem de produção. Para a busca, é obrigatório que seja enviado o filtro:
"production_order_code" - código da ordem de produção;

@author lucas.franca/renan.roeder
@since 21/03/2025
@version P12
@param 01 jFilters, Json, Filtros que serão aplicados para a busca.
@return aReturn, Array, Array com os dados encontrados, sendo:
        aReturn[1] - Logical - Identifica se processou com sucesso a busca.
        aReturn[2] - Json    - Dados obtidos na busca ou mensagem de erro caso não consiga fazer a busca.
        aReturn[3] - Numeric - Status que representa o retorno (200 ok, 400 erro.)
/*/
Method getData(jFilters as Json) as Array Class DTAProductionOrderAllocations
	Local aReturn       := {}  as Array
	Local aSuggestions  := {}  as Array
	Local cContext      := ""  as Character
	Local jData         := Nil as Json

	If Empty(jFilters["production_order_code"])
		Return DTAUtils():APIErrorMessage(400, I18N(STR0022, {"production_order_code"})) //"Argumento '#1[production_order_code]#' não foi informado. Informe um código de ordem de produção para realizar a pesquisa."
	EndIf
	jFilters["production_order_code"] := PadR(jFilters["production_order_code"], GetSX3Cache("C2_OP", "X3_TAMANHO"))
	SC2->(dbSetOrder(1))
	If SC2->(dbSeek(xFilial("SC2") + jFilters["production_order_code"]))
		SB1->(dbSetOrder(1))
		SB1->(dbSeek(xFilial("SB1") + SC2->(C2_PRODUTO)))
		jData := JsonObject():New()
		jData["production_order_code"] := RTrim(jFilters["production_order_code"])
		jData["product_code"         ] := RTrim(SB1->B1_COD)
		jData["product_description"  ] := RTrim(SB1->B1_DESC)
		jData["product_unit_measure" ] := RTrim(SB1->B1_UM)
		jData["allocations_list"     ] := DTAProductionOrderAllocations():getAllocationsList(jFilters["production_order_code"])

		cContext := I18N(STR0023, {"product_code", "product_description", "product_code", "product_description"}) //"Quando apresentar as informações de um produto, sempre combine o '#1[product_code]#' e a '#2[product_description]#' em uma única frase, no seguinte formato: Produto: ['#3[product_code]#'] - ['#4[product_description]#']."
		cContext += " \n " + I18N(STR0025, {"allocations_list", "is_labor_product"}) //"Os itens da lista '#1[allocations_list]#' sempre devem ser exibidos em formato de tabela. O campo '#2[is_labor_product]#' não deve ser exibido como coluna."
		cContext += " \n " + I18N(STR0026, {"planned_quantity"}) //"O campo '#1[planned_quantity]#' indica a quantidade total planejada do componente para executar a ordem de produção. Quando esta informação estiver negativa, indica que é um subproduto."
		cContext += " \n " + I18N(STR0027, {"balance_quantity"}) //"O campo '#1[balance_quantity]#' indica a quantidade do componente que ainda não foi consumida na execução da ordem de produção."
		cContext += " \n " + I18N(STR0028, {"stock_quantity"}) //"O campo '#1[stock_quantity]#' indica a quantidade disponível em estoque do componente considerando o armazém e lote do componente."
		cContext += " \n " + I18N(STR0029, {"balance_quantity", "stock_quantity"}) //"Realize a análise se existe saldo em estoque para atender o empenho somente quando for solicitado e considere a seguinte regra: Se '#1[balance_quantity]#' for menor ou igual que '#2[stock_quantity]#', então existe saldo para atender o empenho."
		cContext += " \n " + I18N(STR0033, {"stock_quantity", "is_labor_product", "true"}) //"A quantidade de saldo em estoque contida no campo '#1[stock_quantity]#' não se aplica para os empenhos que possuem o campo '#2[is_labor_product]#' com valor '#3[true]#', pois esses produtos são para informar mão de obra. Dessa forma, mesmo que esse não possua saldo em estoque suficiente, ainda pode atender o empenho."
		aAdd(aSuggestions, {"label": STR0030}) //"Os empenhos da ordem de produção possuem saldo em estoque suficiente?"
		aReturn      := {.T., {"context": cContext, "data": jData, "suggestions": aSuggestions}, 200}
		jData        := Nil
		aSuggestions := Nil
	Else
		aReturn := DTAUtils():APIErrorMessage(400, I18N(STR0031, {RTrim(jFilters["production_order_code"])})) //"A ordem de produção #1[production_order_code]# não foi encontrada. Informe um código de ordem de produção existente para realizar a pesquisa."
	EndIf
Return aReturn

/*/{Protheus.doc} getAllocationsList
Retorna uma lista com os empenhos da ordem de produção

@author lucas.franca/renan.roeder
@since 21/03/2025
@version P12
@param 01 cProductionOrder, Character, Código da ordem de produção
@return aAllocations, Array, Array com os dados dos empenhos da ordem de produção
/*/
Method getAllocationsList(cProductionOrder as Character) as Array Class DTAProductionOrderAllocations
	Local aAllocations := {}  as Array
	Local cAlias       := ""  as Character
	Local cQuery       := ""  as Character
	Local jItem        := Nil as Json
	Local oQuery       := Nil as Object

	cQuery := "SELECT SD4.D4_COD, SB1.B1_DESC, SB1.B1_UM, SD4.D4_LOCAL, SD4.D4_OP, SD4.D4_QTDEORI, SD4.D4_QUANT, SD4.D4_ROTEIRO, SD4.D4_OPERAC, SD4.D4_DATA, SD4.D4_LOTECTL "
	cQuery += "FROM " + RetSqlName("SD4") + " SD4 "
	cQuery += "INNER JOIN " + RetSqlName("SB1") + " SB1 "
	cQuery +=    "ON SB1.B1_FILIAL = ? "
	cQuery +=   "AND SB1.B1_COD = SD4.D4_COD "
	cQuery +=   "AND SB1.D_E_L_E_T_ = ' ' "
	cQuery += "WHERE SD4.D4_FILIAL = ? "
	cQuery +=   "AND SD4.D4_OP = ? "
	cQuery +=   "AND SD4.D_E_L_E_T_ = ' ' "
	cQuery += "ORDER BY SD4.D4_COD, SD4.D4_LOCAL "
	oQuery := FwExecStatement():New(cQuery)
	oQuery:setString(1, xFilial("SB1"))
	oQuery:setString(2, xFilial("SD4"))
	oQuery:setString(3, cProductionOrder)
	cAlias := oQuery:openAlias()
	While (cAlias)->(!Eof())
		jItem := JsonObject():New()
		jItem["production_order_code" ] := RTrim((cAlias)->(D4_OP))
		jItem["component_code"        ] := RTrim((cAlias)->(D4_COD))
		jItem["component_description" ] := RTrim((cAlias)->(B1_DESC))
		jItem["component_unit_measure"] := RTrim((cAlias)->(B1_UM))
		jItem["warehouse_code"        ] := RTrim((cAlias)->(D4_LOCAL))
		jItem["planned_quantity"      ] := (cAlias)->(D4_QTDEORI)
		jItem["balance_quantity"      ] := (cAlias)->(D4_QUANT)
		jItem["stock_quantity"        ] := DTAProductionOrderAllocations():getStockQuantity((cAlias)->D4_COD, (cAlias)->D4_LOCAL, (cAlias)->D4_LOTECTL)
		jItem["allocation_date"       ] := PCPConvDat((cAlias)->(D4_DATA), 5)
		jItem["lot_code"              ] := RTrim((cAlias)->(D4_LOTECTL))
		jItem["is_labor_product"      ] := IsProdMOD((cAlias)->(D4_COD))
		aAdd(aAllocations, jItem)
		jItem := Nil
		(cAlias)->(dbSkip())
	End
	(cAlias)->(dbCloseArea())
	oQuery:Destroy()
	FreeObj(oQuery)
Return aAllocations

/*/{Protheus.doc} getStockQuantity
Busca o saldo em estoque do empenho

@author lucas.franca/renan.roeder
@since 07/04/2025
@version P12
@param 01 cProduct  , Character, Código do produto
@param 02 cWarehouse, Character, Código do armazém
@param 03 cLotCode  , Character, Código do lote
@return nQuantity, Numeric, Quantidade de saldo em estoque
/*/
Method getStockQuantity(cProduct as Character, cWarehouse as Character, cLotCode as Character) as Numeric Class DTAProductionOrderAllocations
	Local aStockData  := {}  as Array
	Local jParameters := Nil as Json
	Local nQuantity   := 0   as Numeric

	jParameters := JsonObject():New()
	jParameters["product_code"  ] := cProduct
	jParameters["warehouse_code"] := cWarehouse
	jParameters["lot_code"      ] := cLotCode

	aStockData := DTAStockBalance():getData(jParameters)
	If aStockData[1]
		nQuantity := aStockData[2]["data"]["items"][1]["stock_balance"]
	EndIf

	FwFreeArray(aStockData)
	FreeObj(jParameters)
Return nQuantity

/*/{Protheus.doc} getAllocationsFromProduct
Busca quais empenhos/ordens utilizam determinado produto, podendo filtrar por armazém e lote

@author lucas.franca/renan.roeder
@since 03/09/2025
@version P12
@param 01 cProductCode  , Character, Código do produto
@param 02 cLotCode      , Character, Código do lote
@param 03 cWarehouseCode, Character, Código do armazém
@param 04 lAllRows      , Logical  , Retorna por referência se a lista retornada contém todos os registros encontrados ou não. Retorno limitado à 20 registros.
@param 05 dStartDate    , Date     , Data inicial para filtrar os empenhos
@param 06 dEndDate      , Date     , Data final para filtrar os empenhos
@return jData, Json, objeto com os dados da utilização do empenho
/*/
Method getAllocationsFromProduct(cProductCode as Character, cLotCode as Character, cWarehouseCode as Character, lAllRows as Logical, dStartDate as Date, dEndDate as Date) as Json Class DTAProductionOrderAllocations
	Local aFilters          := {}  as Array
	Local cAlias            := ""  as Character
	Local cQuery            := ""  as Character
	Local cLastOrder        := ""  as Character
	Local jOrders           := Nil as Json
	Local jData             := Nil as Json
	Local nCountOrders      := 0   as Integer
	Local nTotalBalance     := 0   as Numeric
	Local nTotalOrders      := 0   as Integer
	Local oQuery            := Nil as Object

	lAllRows := .T.
	jOrders  := JsonObject():New()
	aAdd(aFilters, xFilial("SB1"))
	aAdd(aFilters, xFilial("SD4"))
	aAdd(aFilters, cProductCode)

	cQuery := "SELECT SD4.D4_OP, "
	cQuery +=        "SD4.D4_PRODUTO, "
	cQuery +=        "SB1.B1_DESC, "
	cQuery +=        "SB1.B1_UM, "
	cQuery +=        "SD4.D4_COD, "
	cQuery +=        "SD4.D4_DATA, "
	cQuery +=        "SUM(SD4.D4_QUANT) D4_QUANT"
	cQuery +=   "FROM " + RetSqlName("SD4") + " SD4 "
	cQuery +=  "INNER JOIN " + RetSqlName("SB1") + " SB1 "
	cQuery +=     "ON SB1.B1_FILIAL = ? "
	cQuery +=    "AND SB1.B1_COD = SD4.D4_PRODUTO "
	cQuery +=    "AND SB1.D_E_L_E_T_ = ' ' "
	cQuery +=  "WHERE SD4.D4_FILIAL = ? "
	cQuery +=    "AND SD4.D4_COD = ? "
	If !Empty(cLotCode)
		cQuery += "AND SD4.D4_LOTECTL = ? "
		aAdd(aFilters, cLotCode)
	EndIf
	If !Empty(cWarehouseCode)
		cQuery += "AND SD4.D4_LOCAL = ? "
		aAdd(aFilters, cWarehouseCode)
	EndIf
	If !Empty(dStartDate)
		cQuery += "AND SD4.D4_DATA >= ? "
		aAdd(aFilters, dStartDate)
	EndIf
	If !Empty(dEndDate)
		cQuery += "AND SD4.D4_DATA <= ? "
		aAdd(aFilters, dEndDate)
	EndIf
	cQuery +=    "AND SD4.D_E_L_E_T_ = ' ' "
	cQuery +=    "AND SD4.D4_QUANT <> 0 "
	cQuery +=  "GROUP BY SD4.D4_OP, SD4.D4_PRODUTO, SB1.B1_DESC, SB1.B1_UM, SD4.D4_COD, SD4.D4_DATA "
	cQuery +=  "ORDER BY SD4.D4_OP, SD4.D4_DATA "
	oQuery := FwExecStatement():New()
	oQuery:setQuery(ChangeQuery(cQuery))
	oQuery:setParams(aFilters)
	cAlias := oQuery:openAlias()
	While (cAlias)->(!EoF())
		nTotalBalance += (cAlias)->D4_QUANT
		If Empty(cLastOrder) .Or. cLastOrder <> (cAlias)->D4_OP
			nTotalOrders++
			cLastOrder := (cAlias)->D4_OP
		EndIf
		
		If jOrders:hasProperty((cAlias)->D4_OP)
			jOrders[(cAlias)->D4_OP]["production_order_allocation_balance"] += (cAlias)->D4_QUANT
			aAdd(jOrders[(cAlias)->D4_OP]["allocation_date_list"], {"allocation_date": PCPConvDat((cAlias)->D4_DATA, 5), "allocation_balance": (cAlias)->D4_QUANT})
		ElseIf nCountOrders < 20
			nCountOrders++
			jOrders[(cAlias)->D4_OP] := JsonObject():New()
			jOrders[(cAlias)->D4_OP]["production_order_code"                ] := RTrim((cAlias)->D4_OP)
			jOrders[(cAlias)->D4_OP]["production_order_product"             ] := RTrim((cAlias)->D4_PRODUTO)
			jOrders[(cAlias)->D4_OP]["production_order_product_description" ] := RTrim((cAlias)->B1_DESC)
			jOrders[(cAlias)->D4_OP]["production_order_product_unit_measure"] := RTrim((cAlias)->B1_UM)
			jOrders[(cAlias)->D4_OP]["production_order_allocation_balance"  ] := (cAlias)->D4_QUANT
			jOrders[(cAlias)->D4_OP]["allocation_date_list"                 ] := {{"allocation_date": PCPConvDat((cAlias)->D4_DATA, 5), "allocation_balance": (cAlias)->D4_QUANT}}
		EndIf
		(cAlias)->(dbSkip())
	End
	(cAlias)->(dbCloseArea())
	If nTotalOrders > nCountOrders
		lAllRows := .F.
	EndIf
	jData := {"total_balance": nTotalBalance, "total_orders" : nTotalOrders, "production_orders_list": DTAProductionOrderAllocations():getListOfOrders(jOrders)}
	
	jOrders := Nil
	oQuery:Destroy()
	FreeObj(oQuery)
	aSize(aFilters, 0)
Return jData

/*/{Protheus.doc} getListOfOrders
Retorna a lista de ordens como um array

@author lucas.franca/renan.roeder
@since 04/09/2025
@version P12
@param 01 jOrders, Json, Lista de ordens em formato JSON
@return aOrders, Array, Lista das ordens em formato Array
/*/
Method getListOfOrders(jOrders as Json) as Array Class DTAProductionOrderAllocations
	Local aOrders := {} as Array
	Local aNames  := {} as Array
	Local nIndex  := 0  as Integer

	aNames := jOrders:getNames()
	For nIndex := 1 To Len(aNames)
		aAdd(aOrders, jOrders[aNames[nIndex]])
	Next nIndex
	aSize(aNames, 0)
Return aOrders
