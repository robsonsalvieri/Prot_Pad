#Include "tlpp-core.th"
#Include "TOTVS.CH"
#Include "DTASTOCKBALANCE.CH"

/*/{Protheus.doc} DTAStockBalance
Classe responsável pela ferramenta de busca dos saldos em estoque do produto para um armazém.

@author lucas.franca/renan.roeder
@since 21/01/2025
@version P12
/*/
Class DTAStockBalance
	Static Method getData(jFilters as Json) as Array
	Static Method loadTool() as Character
EndClass

/*/{Protheus.doc} loadTool
Método que faz a carga das propriedades das ferramentas disponíveis por esta classe. Alimenta as tabelas HZV/HZW.

@author lucas.franca/renan.roeder
@since 21/01/2025
@version P12
@return cErrorMessage, Character, Indica se houve erro na carga da ferramenta
/*/
Method loadTool() as Character Class DTAStockBalance
	Local cDescription  := ""                             as Character
	Local cErrorMessage := ""                             as Character
	Local cName         := "get_stock_balance_by_product" as Character
	Local cRules        := ""                             as Character
	Local cVersion      := "004"                          as Character
	Local oLoadTool     := Nil                            as Object

	If DTALoad():toolIsUpdated(cName, cVersion)
		Return ""
	EndIf
	cDescription := STR0032 //"Busca o saldo em estoque do produto, retornando a lista de armazéns onde o produto possui saldo e as suas respectivas quantidades."
	cDescription += "\n" + STR0033 //"Opcionalmente, pode ser realizado filtro por código de armazém/lote. Neste caso, os saldos retornados também terão as informações do saldo em estoque detalhado por lote."
	cRules := I18N(STR0002, {"product_code"}) //"Se o argumento '#1[product_code]#' não for informado pelo usuário, solicite a informação antes de realizar a pesquisa. "
	cRules += "\n" + STR0034 //"A ferramenta não possui informação dos endereços de estoque atribuídos ao produto no armazém."
	oLoadTool := DTALoad():New()
	oLoadTool:setName(cName)
	oLoadTool:setClassName("DTAStockBalance")
	oLoadTool:setDataMethod("getData")
	oLoadTool:setVersion(cVersion)
	oLoadTool:setDescription(cDescription)
	oLoadTool:setShortDescription(STR0004) //"Busca saldos em estoque para um produto"
	oLoadTool:setExample(I18N(STR0035, {"product_code"})) //"Qual o saldo em estoque do produto '#1[product_code]#'?"
	oLoadTool:setExample(I18N(STR0036, {"product_code", "warehouse_code_optional"})) //"Qual o saldo em estoque do produto '#1[product_code]#' no armazém '#2[warehouse_code_optional]#'?"
	oLoadTool:setExample(I18N(STR0037, {"lot_code_optional", "product_code"})) //"Qual o saldo do lote '#1[lot_code_optional]#' do produto '#2[product_code]#'?"
	oLoadTool:setExample(I18N(STR0038, {"product_code", "warehouse_code_optional", "lot_code_optional"})) //"Quanto tem em estoque do produto '#1[product_code]#' no armazém '#2[warehouse_code_optional]#' para o lote '#3[lot_code_optional]#'?"
	oLoadTool:setRules(cRules)
	oLoadTool:setGroup("product_information")
	oLoadTool:setStrict(.T.)
	oLoadTool:addParameter("product_code"           , "string"          , STR0007 + ". \n " + STR0010, .T.) //"Código do produto" //"O código do produto pode conter somente letras, somente números ou a combinação de caracteres, podendo ou não ter caracteres especiais. Exemplo: '00255141', 'BICICLETA', 'SKATE', 'SKT001', 'PRODUTO001'."
	oLoadTool:addParameter("warehouse_code_optional", {"string", "null"}, STR0008, .T.) //"Código do armazém"
	oLoadTool:addParameter("lot_code_optional"      , {"string", "null"}, STR0009 + ". \n " + STR0012 + " \n " + STR0013, .F.) //"Código do lote" //"O código do lote pode conter somente letras, somente números ou a combinação de caracteres. Exemplo: 'AUTO000001', 'LT22012022', '7726618930'." //"Quando este argumento for enviado com o valor null serão retornados os saldos de todos os lotes."
	oLoadTool:addGlossary("product_code"             , STR0007) //"Código do produto"
	oLoadTool:addGlossary("product_description"      , STR0014) //"Descrição do produto"
	oLoadTool:addGlossary("product_unit_measure"     , STR0015) //"Unidade de medida do produto"
	oLoadTool:addGlossary("stock_balance"            , STR0016) //"Saldo em estoque"
	oLoadTool:addGlossary("warehouse_code"           , STR0008) //"Código do armazém"
	oLoadTool:addGlossary("warehouse_description"    , STR0017) //"Descrição do armazém"
	oLoadTool:addGlossary("lots"                     , STR0018) //"Lista de lotes do produto"
	oLoadTool:addGlossary("lot_code"                 , STR0009) //"Código do lote"
	oLoadTool:addGlossary("quantity_in_lot"          , STR0019) //"Quantidade no lote"
	oLoadTool:addGlossary("expiration_date"          , STR0020) //"Data de validade do lote"
	oLoadTool:addGlossary("quantity_to_address"      , STR0029) //"Quantidade do produto pendente de endereçamento"
	oLoadTool:addGlossary("total_stock_balance"      , STR0040) //"Soma do saldo em estoque em todos os armazéns"
	oLoadTool:addGlossary("total_quantity_to_address", STR0041) //"Soma da quantidade do produto pendente de endereçamento em todos os armazéns"
	If !oLoadTool:createTool()
		cErrorMessage := oLoadTool:getErrorMessage()
	EndIf
	oLoadTool:Destroy()
Return cErrorMessage

/*/{Protheus.doc} getData
Método que faz a busca dos saldos em estoque do produto para um armazém.
Além dos filtros obrigatórios de código do produto e código do armazém, o usuário pode filtrar o código de um lote especifico.
@author lucas.franca/renan.roeder
@since 21/01/2025
@version P12
@param 01 jFilters, Json, Filtros que serão aplicados para a busca dos saldos em estoque.
@return aReturn, Array, Array com os dados encontrados, sendo:
        aReturn[1] - Logical - Identifica se processou com sucesso a busca.
        aReturn[2] - Json    - Dados obtidos na busca ou mensagem de erro caso não consiga fazer a busca.
        aReturn[3] - Numeric - Status que representa o retorno (200 ok, 400 erro.)
/*/
Method getData(jFilters as Json) as Array Class DTAStockBalance
	Local aLots          := {}  as Array
	Local aReturn        := {}  as Array
	Local aSuggestions   := {}  as Array
	Local cAlias         := ""  as Character
	Local cContext       := ""  as Character
	Local cQuery         := ""  as Character
	Local cLotCode       := ""  as Character
	Local jData          := Nil as Json
	Local lUseAddress    := .F. as Logical
	Local lError         := .F. as Logical
	Local lFoundLot      := .F. as Logical
	Local nIndex         := 0   as Numeric
	Local nIndStock      := 0   as Numeric
	Local nLenStock      := 0   as Numeric
	Local nPosLot        := 0   as Numeric
	Local oPreparedQuery := Nil as Object

	If Empty(jFilters["product_code"])
		Return DTAUtils():APIErrorMessage(400, STR0021) //"É necessário informar o código do produto para a consulta de saldos em estoque."
	EndIf
	jFilters["product_code"] := PadR(Upper(jFilters["product_code"]), GetSX3Cache("B1_COD", "X3_TAMANHO"))
	SB1->(dbSetOrder(1))
	If !SB1->(dbSeek(xFilial("SB1") + jFilters["product_code"]))
		Return DTAUtils():APIErrorMessage(400, I18N(STR0023, {RTrim(jFilters["product_code"])})) //"O produto #1[product_code]# não existe. Informe um código de produto válido para realizar a pesquisa."
	EndIf
	jFilters["warehouse_code_optional"] := Upper(PadR(jFilters["warehouse_code_optional"], GetSX3Cache("NNR_CODIGO", "X3_TAMANHO")))
	If !Empty(jFilters["warehouse_code_optional"])
		NNR->(dbSetOrder(1))
		If !NNR->(dbSeek(xFilial("NNR") + jFilters["warehouse_code_optional"]))
			Return DTAUtils():APIErrorMessage(400, I18N(STR0024, {RTrim(jFilters["warehouse_code_optional"])})) //"O armazém #1[warehouse_code_optional]# não existe. Informe um código de armazém válido para realizar a pesquisa."
		EndIf
	EndIf
	jFilters["lot_code_optional"] := PadR(jFilters["lot_code_optional"], GetSX3Cache("B8_LOTECTL", "X3_TAMANHO"))

	lUseAddress := Localiza(jFilters["product_code"])

	cQuery := "SELECT SB2.B2_COD, SB2.B2_LOCAL, SB2.B2_QATU, SB2.B2_QACLASS, NNR.NNR_DESCRI "
	cQuery +=   "FROM " + RetSqlName("SB2") + " SB2 " 
	cQuery +=  "INNER JOIN " + RetSqlName("NNR") + " NNR "
	cQuery +=     "ON NNR.NNR_FILIAL = ? "
	cQuery +=    "AND NNR.NNR_CODIGO = SB2.B2_LOCAL "
	cQuery +=    "AND NNR.D_E_L_E_T_ = ' ' "
	cQuery +=  "WHERE SB2.B2_FILIAL = ? "
	cQuery +=    "AND SB2.B2_COD    = ? "
	cQuery +=    "AND SB2.D_E_L_E_T_ = ' ' "

	oPreparedQuery := FwExecStatement():New(ChangeQuery(cQuery))
	oPreparedQuery:setString(1, xFilial("NNR"))
	oPreparedQuery:setString(2, xFilial("SB2"))
	oPreparedQuery:setString(3, jFilters["product_code"])

	cAlias := oPreparedQuery:OpenAlias()
	If (cAlias)->(!Eof())
		jData   := JsonObject():New()
		jData["product_code"             ] := RTrim(SB1->B1_COD)
		jData["product_description"      ] := RTrim(SB1->B1_DESC)
		jData["product_unit_measure"     ] := RTrim(SB1->B1_UM)
		jData["total_stock_balance"      ] := 0
		jData["total_quantity_to_address"] := 0
		jData["items"] := {} 
		While (cAlias)->(!Eof())
			jData["total_stock_balance"      ] += (cAlias)->B2_QATU
			jData["total_quantity_to_address"] += (cAlias)->B2_QACLASS
			If !Empty(jFilters["warehouse_code_optional"]) .And. jFilters["warehouse_code_optional"] != (cAlias)->B2_LOCAL
				(cAlias)->(dbSkip())
				Loop
			EndIf
			aAdd(jData["items"], JsonObject():New())
			nLenStock++
			jData["items"][nLenStock]["warehouse_code"       ] := (cAlias)->B2_LOCAL
			jData["items"][nLenStock]["warehouse_description"] := RTrim((cAlias)->NNR_DESCRI)
			jData["items"][nLenStock]["stock_balance"        ] := (cAlias)->B2_QATU
			If lUseAddress
				jData["items"][nLenStock]["quantity_to_address"  ] := (cAlias)->B2_QACLASS
			EndIf
			
			(cAlias)->(dbSkip())
		End
		(cAlias)->(dbCloseArea())
		If nLenStock == 0
			lError := .T.
			aReturn := DTAUtils():APIErrorMessage(400, STR0011) //"Não foi encontrado saldo em estoque para o produto no armazém informado."
		EndIf
	Else
		lError := .T.
		aReturn := DTAUtils():APIErrorMessage(400, STR0005) //"Não foi encontrado saldo em estoque para o produto."
	EndIf
	If !lError .And. SB1->B1_RASTRO == "L"
		If (!Empty(jFilters["warehouse_code_optional"]) .Or. !Empty(jFilters["lot_code_optional"]))
			For nIndStock := 1 To nLenStock
				aLots := SldPorLote(jFilters["product_code"], jData["items"][nIndStock]["warehouse_code"], 999999999999999, 999999999999999, jFilters["lot_code_optional"], Nil, Nil, Nil, Nil, .F., jData["items"][nIndStock]["warehouse_code"], .T.,, .T., dDataBase,,,.T.)
				If !Empty(aLots)
					jData["items"][nIndStock]["lots"] := {}
					For nIndex := 1 To Len(aLots)
						cLotCode := RTrim(aLots[nIndex][1])
						nPosLot  := aScan(jData["items"][nIndStock]["lots"], {|x| x["lot_code"] == cLotCode})
						If nPosLot > 0
							jData["items"][nIndStock]["lots"][nPosLot]["quantity_in_lot"] += aLots[nIndex][5]
						Else
							lFoundLot := .T.
							aAdd(jData["items"][nIndStock]["lots"], {"lot_code": cLotCode, "quantity_in_lot": aLots[nIndex][5], "expiration_date": PCPConvDat(aLots[nIndex][7],2)})
						EndIf
					Next nIndex
					aSize(aLots, 0)
				EndIf
			Next nIndStock
			If lFoundLot
				aAdd(aSuggestions, {"label": STR0025}) //"Quais ordens de produção estão consumindo esses lotes?"
			ElseIf !Empty(jFilters["lot_code_optional"])
				lError := .T.
				aReturn := DTAUtils():APIErrorMessage(400, I18N(STR0006, {RTrim(jFilters["lot_code_optional"])})) //"Não foi encontrado saldo em estoque para o produto no lote #1[lot_code_optional]]#."
			EndIf
		Else
			cContext := I18N(STR0022, {RTrim(jData["product_code"])}) + "\n" //"O produto #1[product_code]# possui controle por lote, e o saldo dos lotes do produto pode ser acessado se a ferramenta realizar uma nova consulta filtrando pelo código do armazém ou código do lote." 
		EndIf
	EndIf
	If !lError
		If lUseAddress
			cContext += "\n" + I18N(STR0031, {"quantity_to_address", "stock_balance"}) //"'#1[quantity_to_address]#' indica quantidades do produto no '#2[stock_balance]#' que não podem ser utilizadas, pois precisam primeiro ser endereçadas no estoque."
		Else
			jData:delName("total_quantity_to_address")
		EndIf
		aReturn := {.T., {"context": cContext, "data": jData, "suggestions": aSuggestions}, 200}
	EndIf
	aSuggestions := Nil
	jData := Nil
	oPreparedQuery:Destroy()
	FreeObj(oPreparedQuery)
Return aReturn
