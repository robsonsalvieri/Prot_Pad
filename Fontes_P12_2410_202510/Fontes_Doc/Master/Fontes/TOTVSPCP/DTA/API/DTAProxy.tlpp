#Include "TOTVS.CH"
#Include "tlpp-core.th"
#Include "DTAProxy.ch"

#DEFINE BREAK_LINE "\n"

/*/{Protheus.doc} DTAProxy
Classe responsável pela comunicação com o DTA PROXY

@author lucas.franca/renan.roeder
@since 21/01/2025
@version P12
/*/
Class DTAProxy
	Public Data aToolCalls      as Array
	Public Data aToolsScore     as Array
	Public Data aToolsHistory   as Array
	Public Data cThreadId       as Character
	Public Data jProxyData      as Json
	Public Data jSuggestions    as Json
	Public Data lUseTools       as Logical
	Public Data oMonitor        as Object
	Private Data cToken         as Character
	
	Public Method New(cThreadId, jChatRequest, lUseTools, cSessionId) Constructor
	Public Method destroy()
	Public Method runProxyRequest() as Character
	Public Method runToolFunction()
	Public Method setToken(cToken as Character)
	Private Method createDataForProxyRequest(jChatRequest as Json)
	Private Method postDTACompletion(cStartTime as Character, cEndTime as Character) as Character
	Private Method evaluateProxyResponse(cAnswer as Character, cStartTime as Character, cEndTime as Character) as Character
	
	Static Method getChatModel() as Character
	Static Method getEmbeddingModel() as Character
	Static Method getMessageHistoryToScore(aHistory as Array) as Character
	Static Method getTemperature() as Numeric
	Static Method getTools(aTools as Array) as Array
	Static Method getFilteredTools(aTools as Array, nQuantityTools as Numeric, cContent as Character, oMonitor as Object, aToolsScore as Array) as Array
	Static Method formatToolObject(jTool as Json) as Json
	Static Method postDTAEmbedding(aContent as Array) as Character
	Static Method setChatHistory(jProxyData as Json, aChatMessages as Array)
	Static Method setChatUserContent(jProxyData as Json, cMessage as Character)
	Static Method setDeveloperDefinition(jProxyData as Json)
	Static Method setProxyAuthorizationHeader(aHeader as Array, cToken as Character)
	Static Method setProxyModel(jProxyData as Json)
	Static Method setProxyTemperature(jProxyData as Json)
	Static Method setToolCatalogBySimilarity(jProxyData as Json, cContent as Character, oMonitor as Object)
	Static Method formatToolExamples(aExamples as Array) as Character
EndClass

/*/{Protheus.doc} New
Método construtor da classe. 
Já inicializa tudo que é necessário para executar as requisições ao proxy.

@author lucas.franca/renan.roeder
@since 21/01/2025
@version P12
@param 01 cThreadId   , Character, ID da thread recebido para controle dos eventos do monitor (log)
@param 02 jChatRequest, Json     , Requisição do CHAT, contendo histórico e mensagens do usuário
@param 03 lUseTools   , Logical  , Indica se devem ser utilizadas ferramentas. Útil para não enviar ferramentas para teste de conexão com Proxy.
@parma 04 cSessionId  , Character, ID da sessão, que é utilizado para identificar o chat do usuário
@return Self, Object, Instância da classe
/*/
Method New(cThreadId as Character, jChatRequest as Json, lUseTools as Logical, cSessionId as Character) Class DTAProxy
	Default lUseTools  := .T.

	Self:aToolsHistory := {}
	Self:aToolsScore   := {}
	Self:cThreadId     := cThreadId
	Self:jProxyData    := JsonObject():New()
	Self:jSuggestions  := JsonObject():New()
	Self:lUseTools     := lUseTools
	Self:oMonitor      := DTAMonitor():New(cThreadId, cSessionId)

	Self:createDataForProxyRequest(jChatRequest)
Return Self

/*/{Protheus.doc} destroy
Limpa as propriedades da classe.

@author lucas.franca/renan.roeder
@since 21/01/2025
@version P12
@return Nil
/*/
Method destroy() Class DTAProxy
	Self:oMonitor:destroy()
	FreeObj(Self:oMonitor)

	Self:aToolCalls      := Nil
	Self:aToolsScore     := Nil
	Self:aToolsHistory   := Nil
	Self:jProxyData      := Nil
	Self:jSuggestions    := Nil
Return

/*/{Protheus.doc} runProxyRequest
Executa a requisição para o DTA Proxy conforme dados preenchidos em Self:jProxyData.
Também avalia o retorno da requisição e monta as propriedades de controle para execução de ferramentas e controle de histórico.

@author lucas.franca/renan.roeder
@since 21/01/2025
@version P12
@return cResponse, Character, Resposta obtida na requisição caso não precise executar ferramentas.
/*/
Method runProxyRequest() as Character Class DTAProxy
	Local cAnswer         := "" as Character
	Local cResponse       := "" as Character
	Local cStartTime      := "" as Character
	Local cEndTime        := "" as Character

	//Executa a requisição e avalia o retorno
	cAnswer   := Self:postDTACompletion(@cStartTime, @cEndTime)
	cResponse := Self:evaluateProxyResponse(cAnswer, cStartTime, cEndTime)
Return cResponse

/*/{Protheus.doc} createDataForProxyRequest
Cria o objeto Self:jProxyData para realizar as requisições para o DTA Proxy.

@author lucas.franca/renan.roeder
@since 21/01/2025
@version P12
@param 01 jChatRequest, Json, Requisição do CHAT, contendo histórico e mensagens do usuário
@return Nil
/*/
Method createDataForProxyRequest(jChatRequest as Json) Class DTAProxy
	Local cScorePayload := "" as Character

	//Monta dados para requisição ao DTA Proxy.
	DTAProxy():setProxyModel(@Self:jProxyData)
	DTAProxy():setProxyTemperature(@Self:jProxyData)
	DTAProxy():setDeveloperDefinition(@Self:jProxyData)
	If jChatRequest:hasProperty("data") .And. jChatRequest["data"]:hasProperty("dta-chat-messages")
		DTAProxy():setChatHistory(@Self:jProxyData, jChatRequest["data"]["dta-chat-messages"])
	EndIf
	DTAProxy():setChatUserContent(@Self:jProxyData, jChatRequest["content"])
	If Self:lUseTools
		cScorePayload := DTAProxy():getMessageHistoryToScore(Self:jProxyData["messages"])
		Self:aToolsScore := DTAProxy():setToolCatalogBySimilarity(@Self:jProxyData, cScorePayload, @Self:oMonitor)
	EndIf
Return

/*/{Protheus.doc} postDTACompletion
Realiza a requisição HTTP ao DTA PROXY v1/chat/completions para realizar a conversa com o assistente

@author lucas.franca / renan.roeder
@since 20/12/2024
@version P12
@param 01 cStartTime, Character, Tempo de inicio da requisição
@param 02 cEndTime  , Character, Tempo de fim da requisição
@return cAnswer, Character, Retorno da requisição
/*/
Method postDTACompletion(cStartTime as Character, cEndTime as Character) as Character Class DTAProxy
	Local aHeader      := {} as Array
	Local cURL         := "" as Character
	Local cAnswer      := "" as Character
	Local cSendMessage := "" as Character
	
	cStartTime := FWTimeStamp(5, Date(), TimeFull())
	cURL       := DTAParameters():getParameter("proxy_url") + DTAParameters():getParameter("endpoint_chat")
	cSendMessage := DTAUtils():encodeUTF8(Self:jProxyData:ToJson())
	DTAUtils():cleanBreakLine(@cSendMessage)
	DTAProxy():setProxyAuthorizationHeader(@aHeader, Self:cToken)
	cAnswer := HTTPPost(cURL, "", cSendMessage, , aHeader)
	DTAUtils():validateHTTPResponse(cAnswer, "postDTACompletion", cSendMessage)
	cEndTime := FWTimeStamp(5, Date(), TimeFull())
Return cAnswer

/*/{Protheus.doc} postDTAEmbedding
Realiza a requisição HTTP ao DTA PROXY v1/embeddings para gerar o embedding

@author lucas.franca / renan.roeder
@since 20/12/2024
@version P12
@param 01 aContent, Array, Array com as strings para gerar o embdding
@return cAnswer, Character, Retorno da requisição
/*/
Method postDTAEmbedding(aContent as Array) as Character Class DTAProxy
	Local aHeader      := {}                 as Array
	Local cAnswer      := ""                 as Character
	Local cSendMessage := ""                 as Character
	Local cURL         := ""                 as Character
	Local jData        := JsonObject():New() as Json
	Local nIndex       := 0                  as Numeric

	For nIndex := 1 To Len(aContent)
		aContent[nIndex] := DTAUtils():encodeUTF8(aContent[nIndex])
	Next nIndex
	jData["model"] := DTAProxy():getEmbeddingModel()
	jData["input"] := aContent
	cSendMessage   := jData:ToJson()
	DTAProxy():setProxyAuthorizationHeader(@aHeader)
	cURL    := DTAParameters():getParameter("proxy_url") + DTAParameters():getParameter("endpoint_embedding")
	cAnswer := HTTPPost(cURL, "", cSendMessage, , aHeader)
	DTAUtils():validateHTTPResponse(cAnswer, "postDTAEmbedding", cSendMessage)
	aSize(aHeader, 0)
	FreeObj(jData)
Return cAnswer

/*/{Protheus.doc} setProxyAuthorizationHeader
Adiciona o header de autenticação para a requisição HTTP ao Proxy.

@author lucas.franca/renan.roeder
@since 21/01/2025
@version P12
@param 01 aHeader, Array    , Array para adicionar o header
@param 02 cToken , Character, Token utilizado para teste de conexão. Se não enviado utiliza o token padrão configurado.
@return Nil
/*/
Method setProxyAuthorizationHeader(aHeader as Array, cToken as Character) Class DTAProxy
	If Empty(cToken)
		cToken := DTAParameters():getParameter("token")
	EndIf
	aAdd(aHeader, "Authorization: Bearer " + cToken)
Return

/*/{Protheus.doc} setToken
Define um token de autenticação a ser utilizado nas requisições com o DTA Proxy.
Utilizado para realizar o teste de conexão com um token específico

@author lucas.franca/renan.roeder
@since 23/04/2025
@version P12
@param 01 cToken, Character, Token que será utilizado no teste
@return Nil
/*/
Method setToken(cToken as Character) Class DTAProxy
	Self:cToken := cToken
Return

/*/{Protheus.doc} getChatModel
Retorna o nome do modelo do método completion

@author lucas.franca / renan.roeder
@since 20/12/2024
@version P12
@return model_chat, Character, Nome do modelo
/*/
Method getChatModel() as Character Class DTAProxy
Return DTAParameters():getParameter("model_chat")

/*/{Protheus.doc} getTemperature
Retorna a temperatura que será utilizada pelo modelo

@author lucas.franca / renan.roeder
@since 20/12/2024
@version P12
@return model_temperature, Numeric, Temperatura do modelo
/*/
Method getTemperature() as Numeric Class DTAProxy
Return DTAParameters():getParameter("model_temperature")

/*/{Protheus.doc} getEmbeddingModel
Retorna o nome do modelo para gerar embedding

@author lucas.franca / renan.roeder
@since 20/12/2024
@version P12
@return model_embedding, Character, Nome do modelo
/*/
Method getEmbeddingModel() as Character Class DTAProxy
Return DTAParameters():getParameter("model_embedding")

/*/{Protheus.doc} evaluateProxyResponse
Avalia a resposta do Proxy, verificando se é necessário executar funções ou se já possui a resposta para o usuário

@author lucas.franca / renan.roeder
@since 20/12/2024
@version P12
@param 01 cAnswer   , Character, Resposta da requisição ao Proxy
@param 02 cStartTime, Character, Tempo de inicio da requisição
@param 03 cEndTime  , Character, Tempo de fim da requisição
@return cResponse, Character, Resposta para o usuário quando não precisar executar funções
/*/
Method evaluateProxyResponse(cAnswer as Character, cStartTime as Character, cEndTime as Character) as Character Class DTAProxy
	Local aTool      := {}  as Array
	Local cResponse  := ""  as Character
	Local cProxyData := ""  as Character
	Local jChoice    := Nil as Json
	Local jAnswer    := Nil as Json
	Local nIndTool   := 0   as Numeric
	Local nTotTool   := 0   as Numeric

	/*
	Avalia a resposta do DTA, que pode ser:
		finish_reason = STOP - indica que a IA já tem a resposta, e deve apresentar ao usuário.
			Neste caso, obtém o content da mensagem e irá retornar essa mensagem para o CHAT.

		finish_reason = tool_calls - indica que a IA precisa de informações das funções para determinar a resposta.
			Neste caso a IA retorna uma lista de ferramentas e seus parâmetros para serem executados.
			Vai pegar essas ferramentas selecionadas montando o array aToolCalls para posteriormente executar estas funções.
	
	O retorno desse método será:
		- Se finish_reason = STOP, retorna em cResponse o texto que deve ser exibido no CHAT
		- Se finish_reason = tool_calls, retorna por referência em aToolCalls o array aToolCalls com as ferramentas para execução, e cResponse será vazio.
	
	*/

	Self:aToolCalls := {}
	cProxyData := Self:jProxyData:ToJson()
	jAnswer := JsonObject():New()
	jAnswer:fromJson(DTAUtils():decodeUTF8(cAnswer))
	If jAnswer:hasProperty("choices")
		If Len(jAnswer["choices"]) > 0
			jChoice := jAnswer["choices"][1]
			
			If jChoice["finish_reason"] == "stop"
				cResponse := jChoice["message"]["content"]			
			ElseIf jChoice["finish_reason"] == "tool_calls"
				aTool := jChoice["message"]["tool_calls"]
				nTotTool := Len(aTool)
				For nIndTool := 1 To nTotTool
					aAdd(Self:aToolCalls, {aTool[nIndTool]["id"], aTool[nIndTool]["function"]["name"], aTool[nIndTool]["function"]["arguments"] })
				Next nIndTool
				aTool := Nil
				//armazena a solicitação de execução de ferramentas pelo assistente
				aAdd(Self:aToolsHistory, jChoice["message"])
				aAdd(Self:jProxyData["messages"], jChoice["message"])
			EndIf
			FreeObj(jChoice)
		EndIf
	EndIf
	Self:oMonitor:createGenerationEvent(cProxyData, jAnswer:ToJson(), .F., jAnswer["usage"], cStartTime, cEndTime)
	FreeObj(jAnswer)
Return cResponse

/*/{Protheus.doc} runToolFunction
Faz a execução das funções solicitadas pelo assistente

@author lucas.franca / renan.roeder
@since 20/12/2024
@version P12
@return Nil
/*/
Method runToolFunction() Class DTAProxy
	Local aToolReturn    := {}  as Array
	Local cFunction      := ""  as Character
	Local cId            := ""  as Character
	Local cArguments     := ""  as Character
	Local cStartTime     := ""  as Character
	Local jCalledTool    := Nil as Json
	Local lExceededCalls := .F. as Logical
	Local nIndex         := 0   as Numeric
	Local nTotal         := 0   as Numeric

	/*
		Executa uma ferramenta/função solicitada pelo assistente.
		Armazena nos arrays aToolsHistory e o jProxyData["messages"] o retorno de cada ferramenta/função executada.
		
		aToolsHistory: Armazena as solicitações de execução das ferramentas e o resultado da execução das ferramentas para servir de contexto histórico nas próximas interações do usuário no chat.
		               É usado como base para gerar o objeto dta-chat-steps.

		jProxyData["messages"]: São as mensagens que serão enviadas para o DTA Proxy, onde irá conter todo o histórico e definições, e também
		a resposta de cada tools, para que o assistente processe a solicitação do usuário. Armazena apenas as informações da interação corrente.
	*/
	nTotal         := Len(Self:aToolCalls)
	lExceededCalls := DTAUtils():getMaxToolCalls() < nTotal
	Self:jSuggestions := JsonObject():New() //limpa as sugestões das ferramentas para manter apenas as sugestões da solicitação corrente
	For nIndex := 1 To nTotal 
		cId          := Self:aToolCalls[nIndex][1]
		cFunction    := Self:aToolCalls[nIndex][2]
		cArguments   := Self:aToolCalls[nIndex][3]
		cStartTime   := FWTimeStamp(5, Date(), TimeFull())
		If lExceededCalls
			aToolReturn := {Nil, I18N(STR0001, {DTAUtils():getMaxToolCalls(), nTotal})} //"Limite de ferramentas excedido. O limite atual é de #1[LIMITE_TOOL]# ferramentas, mas foram solicitadas #2[QTD_TOOL]# ferramentas. Esta ferramenta não foi executada. Oriente o usuário para refinar a busca atual ou utilizar menos informações."
		Else
			aToolReturn := DTAUtils():callToolFunction(cFunction, cArguments, @Self:jSuggestions)
		EndIf
		jCalledTool  := JsonObject():New()
		jCalledTool["role"        ] := "tool"
		jCalledTool["tool_call_id"] := cId
		jCalledTool["content"     ] := aToolReturn[2]
		Self:oMonitor:createSpanEvent(cFunction, cArguments, jCalledTool["content"], cStartTime, FWTimeStamp(5, Date(), TimeFull()), aToolReturn[1])
		aAdd(Self:jProxyData["messages"], jCalledTool)
		aAdd(Self:aToolsHistory, jCalledTool)
		jCalledTool := Nil
		aSize(aToolReturn, 0)
	Next nIndex
Return

/*/{Protheus.doc} setProxyModel
Define o modelo utilizado no chat

@author lucas.franca / renan.roeder
@since 20/12/2024
@version P12
@param 01 jProxyData, Json Object, Objeto json com dados para requisição ao proxy (passado como referência)
@return Nil
/*/
Method setProxyModel(jProxyData as Json) Class DTAProxy
	jProxyData["model"] := DTAProxy():getChatModel()
Return

/*/{Protheus.doc} setProxyTemperature
Define a temperatura que o modelo deve utilizar para as respostas

@author lucas.franca / renan.roeder
@since 20/12/2024
@version P12
@param 01 jProxyData, Json Object, Objeto json com dados para requisição ao proxy (passado como referência)
@return Nil
/*/
Method setProxyTemperature(jProxyData as Json) Class DTAProxy
	jProxyData["temperature"] := DTAProxy():getTemperature()
Return

/*/{Protheus.doc} setDeveloperDefinition
Define as orientações iniciais do assistente

@author lucas.franca / renan.roeder
@since 20/12/2024
@version P12
@param 01 jProxyData, Json Object, Objeto json com dados para requisição ao proxy (passado como referência)
@return Nil
/*/
Method setDeveloperDefinition(jProxyData as Json) Class DTAProxy
	Local cDefinition := "" as Character

	jProxyData["messages"] := {}
	cDefinition := "### " + STR0003 + BREAK_LINE + BREAK_LINE //"Contexto de Data"
	cDefinition += "**" + STR0004 + "**: " + I18N(STR0005, {PCPConvDat(dDataBase, 2), RTrim(DiaSemana(dDataBase))}) + BREAK_LINE + BREAK_LINE //"IMPORTANTE" //"Considere que a data de hoje é #1[DATA_ATUAL]# e o dia da semana de hoje é #2[DIA_SEMANA]#."
	cDefinition += ">>> " + STR0006 + BREAK_LINE //"Entrada: valor do tipo data"
	cDefinition += ">>> " + I18N(STR0007, {Set(_SET_DATEFORMAT)}) + BREAK_LINE //"Saída para usuário: formato #1[DATE_FORMAT]#"
	cDefinition += ">>> " + STR0008 //"Saída para ferramentas: formato yyyy-mm-dd"
	aAdd(jProxyData["messages"], {"role": "developer", "content": cDefinition})

	cDefinition := "### " + STR0042 + BREAK_LINE + BREAK_LINE //RESTRIÇÕES DE FILIAL
	cDefinition += " - " + I18N(STR0043, {"**'" + cFilAnt + " - " + AllTrim(FWFilialName()) + "'**"}) + BREAK_LINE //"Você está acessando a filial #1[FILIAL]# e seu acesso é restrito às informações desta filial."
	cDefinition += " - " + STR0044 + BREAK_LINE //"Suas respostas não precisam citar a filial atual, direta ou indiretamente."
	cDefinition += " - " + STR0045 //"Se o usuário solicitar dados de outra filial, você deve orientar o usuário que não pode fornecer informações de outras filiais."
	aAdd(jProxyData["messages"], {"role": "developer", "content": cDefinition})

	cDefinition := "### " + STR0009 + BREAK_LINE + BREAK_LINE //"Contexto de Idioma"
	cDefinition += "**" + STR0004 + "**: " + I18N(STR0010, {DTAUtils():getLanguageName()}) //"IMPORTANTE" //"Sempre responda no idioma #1[NOME_IDIOMA]#."
	aAdd(jProxyData["messages"], {"role": "developer", "content": cDefinition})

	cDefinition := "### " + STR0011 + BREAK_LINE //"Especialidade"
	cDefinition += "**" + STR0012 + "**: " + STR0013 + BREAK_LINE + BREAK_LINE //"REGRA" //"Você é um assistente de IA especialista em planejamento, programação e controle de produção em um contexto industrial. Responda apenas sobre o ERP TOTVS Protheus."
	cDefinition += "#### " + STR0014 + BREAK_LINE //"Limite de Assunto"
	cDefinition += STR0015 + BREAK_LINE + BREAK_LINE //"Se o tema for software de mercado, responda somente sobre o ERP TOTVS Protheus."
	cDefinition += "#### " + STR0016 + BREAK_LINE //"Restrições"
	cDefinition += STR0017 + BREAK_LINE //"Fale apenas sobre assuntos que tenham relação com [tool] e/ou [assistant]."
	cDefinition += STR0018 //"Caso contrário, responda: Não posso falar sobre esse assunto pois não possuo uma fonte de dados para consulta."
	aAdd(jProxyData["messages"], {"role": "developer", "content": cDefinition})

	cDefinition := "### " + STR0019 + BREAK_LINE + BREAK_LINE //"Regras de Erros de Ferramentas"
	cDefinition += ">>> code: 400" + BREAK_LINE
	cDefinition += ">>> " + STR0020 + BREAK_LINE + BREAK_LINE //"Ação: Solicite ao usuário a correção de parâmetros."
	cDefinition += "---" + BREAK_LINE + BREAK_LINE
	cDefinition += ">>> code: 404" + BREAK_LINE
	cDefinition += ">>> " + STR0021 //"Ação: Execute novamente a solicitação com informações corretas."
	aAdd(jProxyData["messages"], {"role": "developer", "content": cDefinition})	

	cDefinition := "### " + STR0022 + BREAK_LINE + BREAK_LINE //"Explicação Matemática"
	cDefinition += "**" + STR0004 + "**: " + STR0023 + BREAK_LINE + BREAK_LINE //"IMPORTANTE" //"Explique fórmulas matemáticas em palavras, sem formatação matemática."
	cDefinition += I18N(STR0024, {DTAUtils():getLanguageName()}) //"Valores numéricos devem ser apresentados ao usuário com separadores de milhares e decimais conforme o padrão do idioma #1[NOME_IDIOMA]#."
	aAdd(jProxyData["messages"], {"role": "developer", "content": cDefinition})	

	cDefinition := "### " + STR0025 + BREAK_LINE + BREAK_LINE //"Formatação das Respostas"
	cDefinition += "**" + STR0012 + "**: " + STR0026 + BREAK_LINE + BREAK_LINE //"REGRA" //"Formate sempre usando Markdown."
	cDefinition += "---" + BREAK_LINE + BREAK_LINE
	cDefinition += "<" + STR0027 + ">" + BREAK_LINE //"contexto"
	cDefinition += "* " + I18N(STR0028, {"*"}) + BREAK_LINE //"Use listas iniciadas por #1[ASTERISCO]#."
	cDefinition += "* " + I18N(STR0029,{"**", "**"}) + BREAK_LINE //"Use #1[ASTERISCO]#negrito#2[ASTERISCO]# para destaques."
	cDefinition += "</" + STR0027 + ">" //"contexto"
	aAdd(jProxyData["messages"], {"role": "developer", "content": cDefinition})

	cDefinition := "### " + STR0030 + BREAK_LINE //"Definições de negócio"
	cDefinition += "> **"+STR0031+"**: " + STR0032 //"Estrutura (BOM - Bill of Materials)" //"lista de componentes vinculada a um produto. É a definição da engenharia de produtos indicando o padrão de materiais utilizados para a fabricação do produto."
	cDefinition += BREAK_LINE+"---"+BREAK_LINE
	cDefinition += "> **"+STR0033+"**: " + STR0034 //"Ordem de produção (OP)" //"documento que define a fabricação de um produto, incluindo quantidade, datas, processo produtivo e componentes utilizados. Também chamada de OP ou Ordem, é identificada por um código alfanumérico único."
	cDefinition += BREAK_LINE+"---"+BREAK_LINE
	cDefinition += "> **"+STR0035+"**: " + STR0036 //"Empenho" //"lista de materiais reservados para a execução de uma ordem de produção. Diferente da estrutura (BOM), que define o padrão de materiais de um produto, o empenho está sempre vinculado a uma ordem específica. Também pode ser chamado de componentes da ordem ou materiais da ordem."
	cDefinition += BREAK_LINE
	cDefinition += "**"+STR0004+"**: " + STR0037 //"IMPORTANTE" //"Embora pareçam semelhantes, Empenho e Estrutura são entidades distintas. Consultas sobre Estrutura não devem retornar informações de Empenho, e consultas sobre Empenho não devem retornar informações de Estrutura."
	cDefinition += BREAK_LINE+"---"+BREAK_LINE
	cDefinition += "> **"+STR0038+"**: " + STR0039 //"Armazém" //"É o local físico ou a entidade lógica designada no sistema para a guarda e o controle de mercadorias. Ele é o ponto central para as operações de recebimento, estocagem, movimentação e expedição de produtos, permitindo o rastreamento preciso do inventário. O código do armazém pode conter somente letras, somente números ou a combinação de caracteres. Exemplo: '01', '98', 'AL', 'L1'."
	cDefinition += BREAK_LINE+"---"+BREAK_LINE
	cDefinition += "> **"+STR0040+"**: " + STR0041 //"Endereço de Estoque" //"Identifica a localização exata de um produto dentro de um armazém. Ele funciona como uma coordenada, dividindo o espaço em áreas, corredores, prateleiras e posições, para permitir a localização e movimentação rápida e precisa das mercadorias."
	cDefinition += BREAK_LINE+"---"+BREAK_LINE
	aAdd(jProxyData["messages"], {"role": "developer", "content": cDefinition})
Return

/*/{Protheus.doc} setChatHistory
Atribui ao objeto json que se comunicará ao proxy o histórico das mensagens, incluindo orientações iniciais, chamadas de ferramentas e mensagens de usuários
para guardar o contexto correto do chat

@author lucas.franca / renan.roeder
@since 20/12/2024
@version P12
@param 01 jProxyData   , Json Object, Passado como referência para adicionar o histórico do chat
@param 02 aChatMessages, Array      , Array com as mensagens do chat do tipo assistant (output) e user (input)
@return Nil
/*/
Method setChatHistory(jProxyData as Json, aChatMessages as Array) Class DTAProxy
	Local aToolsHistory    := {} as Array
	Local nIndHistory      := 0  as Numeric
	Local nIndToolsHistory := 0  as Numeric
	Local nIndUpdMsg       := 0  as Numeric

	nIndUpdMsg := Len(jProxyData["messages"])
	For nIndHistory := 1 To Len(aChatMessages)
		If aChatMessages[nIndHistory]["type"] == "output"         .And.;
		   aChatMessages[nIndHistory]["body"]:hasProperty("data") .And.;
		   aChatMessages[nIndHistory]["body"]["data"]:hasProperty("dta-tools-history")

			aToolsHistory := aChatMessages[nIndHistory]["body"]["data"]["dta-tools-history"]
			For nIndToolsHistory := 1 To Len(aToolsHistory)
				aAdd(jProxyData["messages"], aToolsHistory[nIndToolsHistory])
				nIndUpdMsg++
			Next nIndToolsHistory
			aToolsHistory := Nil
		EndIf
		aAdd(jProxyData["messages"], JsonObject():New())
		nIndUpdMsg++
		jProxyData["messages"][nIndUpdMsg]["role"]    := Iif(aChatMessages[nIndHistory]["type"] == "input", "user", "assistant")
		jProxyData["messages"][nIndUpdMsg]["content"] := aChatMessages[nIndHistory]["body"]["content"]
	Next
Return

/*/{Protheus.doc} setChatUserContent
Atribui ao objeto json que se comunicará ao proxy a ultima mensagem do usuário

@author lucas.franca / renan.roeder
@since 20/12/2024
@version P12
@param 01 jProxyData, Json Object, Passado como referência para adicionar o histórico do chat
@param 02 cMessage  , Character  , Mensagem do usuário
@return Nil
/*/
Method setChatUserContent(jProxyData as Json, cMessage as Character) Class DTAProxy
	Local jUserContent := JsonObject():New() as Json

	jUserContent["role"   ] := "user"
	jUserContent["content"] := cMessage
	aAdd(jProxyData["messages"], jUserContent)
	jUserContent := Nil
Return

/*/{Protheus.doc} getMessageHistoryToScore
Ajusta conteudo da mensagem do usuário para dar o contexto da conversa para gerar o score

Irá retornar as mensagens do usuário concatenadas com quebra de linha

@author lucas.franca / renan.roeder
@since 20/12/2024
@version P12
@param 01 aHistory, Array    , Array com o histórico do chat
@return cMessage, Character, Historico de mensagens que serão usadas para gerar o embedding
/*/
Method getMessageHistoryToScore(aHistory as Array) as Character Class DTAProxy
	Local cMessage     := "" as Character
	Local nIndHistory  := 0  as Numeric

	For nIndHistory := 1 To Len(aHistory)
		If aHistory[nIndHistory]["role"] == "user"
			If !Empty(cMessage)
				cMessage += BREAK_LINE
			EndIf
			cMessage += aHistory[nIndHistory]["content"]
		EndIf
	Next nIndHistory
Return cMessage

/*/{Protheus.doc} setToolCatalogBySimilarity
Atribui ao objeto jProxyData a lista de ferramentas selecionadas pelo score de similaridade

@author lucas.franca / renan.roeder
@since 20/12/2024
@version P12
@param 01 jProxyData, Json Object, Objeto recebido como referência para gravar a lista de ferramentas
@param 02 cContent  , Character  , Conteudo da mensagem do usuário que será usado para gerar o embedding para comparação com as tools
@param 03 oMonitor  , Object     , Objeto da classe DTAMonitor
@return aToolsScore, Array, Array com o score das ferramentas selecionadas
/*/
Method setToolCatalogBySimilarity(jProxyData as Json, cContent as Character, oMonitor as Object) Class DTAProxy
	Local aTools         := Nil as Array
	Local aToolsCatalog  := Nil as Array
	Local aToolsScore    := {}  as Array
	Local nQuantityTools := 0   as Numeric

	aToolsCatalog  := DTAUtils():getToolsCatalog()
	nQuantityTools := DTAParameters():getParameter("quantity_tools")
	If nQuantityTools >= Len(aToolsCatalog)
		aTools := DTAProxy():getTools(aToolsCatalog)
	Else
		aTools := DTAProxy():getFilteredTools(aToolsCatalog, nQuantityTools, cContent, oMonitor, @aToolsScore)
	EndIf
	jProxyData["tools"] := aTools
	aTools := Nil
	aSize(aToolsCatalog, 0)
Return aToolsScore

/*/{Protheus.doc} getTools
Retorna todas as ferramentas formatadas para envio ao DTA PROXY

@author lucas.franca / renan.roeder
@since 16/05/2025
@version P12
@param 01 aTools, Array, lista das ferramentas disponíveis
@return aToolsScore, Array, Array com as ferramentas formatadas
/*/
Method getTools(aTools as Array) as Array Class DTAProxy
	Local aToolsScore := {} as Array
	Local nIndTools   := 0  as Numeric

	For nIndTools := 1 To Len(aTools)
		aAdd(aToolsScore, DTAProxy():formatToolObject(@aTools[nIndTools]))
	Next nIndTools
Return aToolsScore

/*/{Protheus.doc} getFilteredTools
Retorna as ferramentas filtradas de acordo com a similaridade com a pergunta do usuário, e formatadas para envio ao DTA PROXY

@author lucas.franca / renan.roeder
@since 16/05/2025
@version P12
@param 01 aTools        , Array    , lista das ferramentas disponíveis
@param 02 nQuantityTools, Numeric  , quantidade de ferramentas a serem retornadas
@param 03 cContent      , Character, Conteudo da mensagem do usuário que é usado para gerar o embedding para comparação com as ferramentas
@param 04 oMonitor      , Object   , Objeto da classe DTAMonitor
@param 05 aToolsScore   , Array    , Retorna por referencia o score das tools
@return aSimilarTools, Array, Array com as ferramentas formatadas e filtradas
/*/
Method getFilteredTools(aTools as Array, nQuantityTools as Numeric, cContent as Character, oMonitor as Object, aToolsScore as Array) as Array Class DTAProxy
	Local aEmbedding     := Nil as Array
	Local aSimilarTools  := {}  as Array
	Local cEndTime       := ""  as Character
	Local cStartTime     := ""  as Character
	Local jEmbedding     := Nil as Json
	Local nIndTools      := 0   as Numeric
	Local nStartTime     := 0   as Numeric

	cStartTime := FWTimeStamp(5, Date(), TimeFull())
	jEmbedding := DTAUtils():getEmbedding({cContent})
	cEndTime   := FWTimeStamp(5, Date(), TimeFull())
	aEmbedding := DTAUtils():getEmbeddingVector(jEmbedding)
	nStartTime := MicroSeconds()
	For nIndTools := 1 To Len(aTools)
		aTools[nIndTools]["score"] := DTAUtils():calculateVectorSimilarity(aTools[nIndTools]["embedding"], aEmbedding)
	Next nIndTools

	aSort(aTools,,,{|x,y| x["score"] > y["score"]})
	For nIndTools := 1 To nQuantityTools
		aAdd(aToolsScore, {"name": aTools[nIndTools]["name"], "score": aTools[nIndTools]["score"]})
		aAdd(aSimilarTools, DTAProxy():formatToolObject(@aTools[nIndTools]))
	Next nIndTools
	jEmbedding["tools"] := JsonObject():New()
	jEmbedding["tools"]["list" ] := aSimilarTools
	jEmbedding["tools"]["score"] := aToolsScore
	jEmbedding["tools"]["time_spent_on_search"] := MicroSeconds() - nStartTime
	oMonitor:createGenerationEvent(cContent, jEmbedding:ToJson(), .T., jEmbedding["usage"], cStartTime, cEndTime)

	aSize(aEmbedding, 0)
	FreeObj(jEmbedding)
Return aSimilarTools

/*/{Protheus.doc} formatToolObject
Formata o objeto da tool para envio ao DTA PROXY

@author lucas.franca / renan.roeder
@since 16/05/2025
@version P12
@param 01 jTool, Json, objeto da ferramenta
@return jFormattedTool, Json, Ferramenta no formato correto para envio ao dta proxy
/*/
Method formatToolObject(jTool as Json) as Json Class DTAProxy
	Local cExamples      := ""  as Character
	Local jFormattedTool := Nil as Json

	jFormattedTool := JsonObject():New()
	jFormattedTool["type"    ] := "function"
	jFormattedTool["function"] := JsonObject():New()
	jFormattedTool["function"]["name"       ] := jTool["name"       ]
	jFormattedTool["function"]["description"] := jTool["description"]
	cExamples := DTAProxy():formatToolExamples(DTAUtils():getToolExamples(jTool["name"]))
	If !Empty(cExamples)
		jFormattedTool["function"]["description"] += BREAK_LINE + cExamples
	EndIf
	If !Empty(jTool["rules"])
		jFormattedTool["function"]["description"] += BREAK_LINE + jTool["rules"]
	EndIf
	jFormattedTool["function"]["strict"     ] := jTool["strict"     ]
	jFormattedTool["function"]["parameters" ] := jTool["parameters" ]

	aSize(jTool["embedding"], 0)
	FreeObj(jTool)
Return jFormattedTool

/*/{Protheus.doc} formatToolExamples
Monta a string com os exemplos da ferramenta, utilizando um formato padrão para o envio dos exemplos ao Proxy.

@author lucas.franca / renan.roeder
@since 14/04/2025
@version P12
@param 01 aExamples, Array, Array com os exemplos da ferramenta
@return cExamples, Character, String com os exemplos formatados
/*/
Method formatToolExamples(aExamples as Array) as Character Class DTAProxy
	Local cExamples := "" as Character
	Local nIndex    := 0  as Numeric

	For nIndex := 1 To Len(aExamples)
		cExamples += BREAK_LINE + "- " + aExamples[nIndex]["description"]
	Next nIndex
	If !Empty(cExamples)
		cExamples := I18N(STR0002, {cExamples}) //"Pode responder perguntas como:#1[PERGUNTA]#"
	EndIf
Return cExamples
