#include "totvs.ch"
#include "msobject.ch"
#include "totvs.framework.treports.integratedprovider.th"
#include "tlpp-core.th"
#include "tlpp-rest.th"
#include "pcp.treports.estrutura.ch"

namespace totvs.protheus.sigapcp.treportsintegratedprovider

@totvsFrameworkTReportsIntegratedProvider(active=.T., team="SIGAPCP", tables="SG1,SB1", name="Relação Simplificada das Estruturas", country="ALL", initialRelease="12.1.2210", customTables="SG1,SB1")

/*/{Protheus.doc} EstruturaTReportsBusinessObject
Classe para criação do Objeto de Negócio para listagem da estrutura dos produtos

@author ana.paula
@since 25/04/2023
@version 1.0
/*/
class EstruturaTReportsBusinessObject from totvs.framework.treports.integratedprovider.IntegratedProvider
    public method new() as object
    public method getData() as object
    public method getSchema() as object

    protected data aFields as array
    protected data aStruct as array
endclass

/*/{Protheus.doc} new
Método de instância da classe
 
@return object: self

@author ana.paula
@since 25/04/2023
@version 1.0
/*/ 
method new() as object class EstruturaTReportsBusinessObject
    _Super:new()
    //Define a Área
    self:appendArea(STR0001)//STR0001 - "PCP"    
 
    //Define o nome do Objeto de Negócio
    self:setDisplayName(STR0002)//STR0002 - "Estrutura"
    
    //Define a descrição do Objeto de Negócio
    self:setDescription(STR0003)//STR0003 - "Relação Simplificada das Estruturas"

    self:setPergunte("TRESTRU") //Indica o pergunte que será utilizado no relatório
return self

/*/{Protheus.doc} getData
Retorna os dados do objeto de negócio
 
@param nPage, numérico, indica a página atual do relatório
@param oFilter, objeto, contém o filtro do TReports
 
@return object: self:oData

@author ana.paula
@since 25/04/2023
@version 1.0
/*/
Method getData(nPage as numeric, oFilter as object) as object class EstruturaTReportsBusinessObject
    Local aMopc      := {}                                    as array
    Local aParam     := Array(9)                              as array
    Local aTables    := {}                                    as Array
    Local cAlias     := ""                                    as character
    Local cBanco     := TCGetDB()                             as character
    Local cCodPaiAnt := ' '                                   as character
    Local cDescEmp   := ""                                    as character
    Local cDescFil   := ""                                    as character
    Local cFixVar    := ' '                                   as character
    Local cOpcDft    := ""                                    as character
    Local cProOpcT   := ""                                    as character
    Local cQuery     := ""                                    as character
    Local cQuery1    := ""                                    as character
    Local cQuery2    := ""                                    as character
    Local cQuery3    := ""                                    as character
    Local cQuery4    := ""                                    as character
    Local cRevisao   := ' '                                   as character
    Local dDatRef                                             as date
    Local jParams    := Nil                                   as json
    Local lDatRef    := .T.                                   as logical
    Local lNegEstr   := GETMV("MV_NEGESTR")                   as logical
    Local lRevAtu    := FindFunction('PCPREVATU') .AND. SuperGetMv("MV_REVFIL",.F.,.F.) as logical
    Local lUsaSBZ    := SuperGetMV("MV_ARQPROD", .F., "SB1") == 'SBZ'                   as logical
    Local lVlOpc     := .T.                                   as logical
    Local nAteNiv    := 0                                     as numeric //aParam[8] - Imprime Ate Nivel
    Local nPosParam  := 0                                     as numeric
    Local nQuantItem := 0                                     as numeric
    Local nQuantPai  := 0                                     as numeric
    Local nX         := 0                                     as numeric
    Local oExec      := Nil                                   as object
    Local ojItems    := Nil                                   as json

    jParams := oFilter:getParameters() //metodo para retorno do json dos parâmetros

    aParam[1] := pcpValidParam(jParams["MV_PAR01"][1]) //Do Produto?
    aParam[2] := pcpValidParam(jParams["MV_PAR02"][1]) //Ate o Produto?
    aParam[3] := pcpValidParam(jParams["MV_PAR03"][1]) //Do Tipo?
    aParam[4] := pcpValidParam(jParams["MV_PAR04"][1]) //Ate o Tipo?
    aParam[5] := pcpValidParam(jParams["MV_PAR05"][1]) //Do Grupo?
    aParam[6] := pcpValidParam(jParams["MV_PAR06"][1]) //Ate o  Grupo?
    aParam[7] := pcpValidParam(jParams["MV_PAR07"][1]) //Qual revisao da estrutura
    aParam[8] := jParams["MV_PAR08"][1] //Imprime Ate Nivel
    aParam[9] := jParams["MV_PAR09"][1] //Data de Referencia

    If aParam[8] == ""
        nAteNiv := 999
    Else
        nAteNiv := Val(aParam[8])
    EndIf

    If aParam[9] == "0001-01-01T00:00:00"
        lDatRef := .F.
    Else 
        aParam[9] := pcpconvdat(aParam[9], 1)
        lDatRef  := .T.
    EndIf

    //Query Recursiva da SG1
    cQuery1 := " WITH ExplodeEstrutura(G1_FILIAL, "
    cQuery1 +=                       " RECNO, "
    cQuery1 +=                       " G1_REVINI, "
    cQuery1 +=                       " G1_REVFIM, "
    cQuery1 +=                       " G1_COD, "
    cQuery1 +=                       " G1_COMP, "
    cQuery1 +=                       " G1_TRT, "
    cQuery1 +=                       " G1_OBSERV, "
    cQuery1 +=                       " G1_PERDA, "
    cQuery1 +=                       " G1_QUANT, "
    cQuery1 +=                       " G1_FIXVAR, "
    cQuery1 +=                       " G1_INI, "
    cQuery1 +=                       " G1_FIM, "
    cQuery1 +=                       " G1_GROPC, "
    cQuery1 +=                       " G1_OPC, "
    cQuery1 +=                       " NIVEL, "
    cQuery1 +=                       " COD_PAI, "
    cQuery1 +=                       " NIVEL_PAI, "
    cQuery1 +=                       " EHPAI "

    PcpInCposPerson(@self:aStruct, @cQuery1, self:getCustomFields(),.T.,.T.,"B1_",)

    cQuery1 += ") "
    cQuery1 += " AS ( "

    cQuery2 += " SELECT SG1_Base.G1_FILIAL, "
    cQuery2 +=       " SG1_Base.R_E_C_N_O_, "
    cQuery2 +=       " SG1_Base.G1_REVINI, "
    cQuery2 +=       " SG1_Base.G1_REVFIM, "
    cQuery2 +=       " SG1_Base.G1_COD, "
    cQuery2 +=       " SG1_Base.G1_COMP, "
    cQuery2 +=       " SG1_Base.G1_TRT, "
    cQuery2 +=       " SG1_Base.G1_OBSERV, "
    cQuery2 +=       " SG1_Base.G1_PERDA, "
    cQuery2 +=       " SG1_Base.G1_QUANT, "
    cQuery2 +=       " SG1_Base.G1_FIXVAR, "
    cQuery2 +=       " SG1_Base.G1_INI, "
    cQuery2 +=       " SG1_Base.G1_FIM, "
    cQuery2 +=       " SG1_Base.G1_GROPC, "
    cQuery2 +=       " SG1_Base.G1_OPC, "
    cQuery2 +=       " 2 as NIVEL, "
    cQuery2 +=       " SG1_Base.G1_COD as COD_PAI, "
    cQuery2 +=       " CAST(ROW_NUMBER() OVER(ORDER BY SG1_Base.G1_FILIAL,  SG1_Base.G1_COD,  SG1_Base.G1_COMP,  SG1_Base.G1_TRT ASC) AS VARCHAR(4000)) as NIVEL_PAI, "
    cQuery2 +=       " 'S' EHPAI "

    aadd(aTables,{'G1_','SG1_Base.'})
    PcpInCposPerson(@self:aStruct, @cQuery2, self:getCustomFields(),.T.,.T.,"B1_",aTables)
    aTables := {}

    cQuery2 +=   " FROM " + RetSqlName("SG1") + " SG1_Base "
    cQuery2 +=   " INNER JOIN " + RetSqlName("SB1") + " SB1 ON SB1.B1_FILIAL = ? "
	cQuery2 +=   " AND SB1.B1_COD = SG1_Base.G1_COD "
	cQuery2 +=   " AND SB1.D_E_L_E_T_  = ' ' "
    If !EMPTY(aParam[7])
        cQuery2 += " AND ? BETWEEN SG1_Base.G1_REVINI AND SG1_Base.G1_REVFIM "
    Else
        If lUsaSBZ .And. lRevAtu
            cQuery2 += " LEFT JOIN "+RetSqlName("SBZ")+" SBZ ON SBZ.BZ_FILIAL = ? AND SBZ.BZ_COD = SB1.B1_COD AND SBZ.D_E_L_E_T_ = ' ' "
        EndIf
    EndIf
    cQuery2 +=  " WHERE SG1_Base.G1_FILIAL = ? "
    cQuery2 +=    " AND SG1_Base.G1_COD   >= ? "
    cQuery2 +=    " AND SG1_Base.G1_COD   <= ? "
    If lDatRef
        cQuery2 +=    " AND SG1_Base.G1_INI <= ? "
        cQuery2 +=    " AND SG1_Base.G1_FIM >= ? "
    EndIf
    cQuery2 +=    " AND SG1_Base.D_E_L_E_T_ = ' ' "
    If EMPTY(aParam[7])
        If lUsaSBZ .And. lRevAtu
            cQuery2 += " AND (CASE WHEN SBZ.BZ_REVATU = ' ' OR SBZ.BZ_REVATU IS NULL THEN SB1.B1_REVATU ELSE SBZ.BZ_REVATU END BETWEEN SG1_Base.G1_REVINI AND SG1_Base.G1_REVFIM) "
        Else
            cQuery2 += " AND ( SB1.B1_REVATU BETWEEN SG1_Base.G1_REVINI AND SG1_Base.G1_REVFIM) "
        EndIf
    EndIf
    
    cQuery3 +=  " UNION ALL "
    cQuery3 +=  " SELECT SG1_Rec.G1_FILIAL, "
    cQuery3 +=        " SG1_Rec.R_E_C_N_O_, "
    cQuery3 +=        " SG1_Rec.G1_REVINI, "
    cQuery3 +=        " SG1_Rec.G1_REVFIM, "
    cQuery3 +=        " SG1_Rec.G1_COD, "
    cQuery3 +=        " SG1_Rec.G1_COMP, "
    cQuery3 +=        " SG1_Rec.G1_TRT, "
    cQuery3 +=        " SG1_Rec.G1_OBSERV, "
    cQuery3 +=        " SG1_Rec.G1_PERDA, "
    cQuery3 +=        " SG1_Rec.G1_QUANT, "
    cQuery3 +=        " SG1_Rec.G1_FIXVAR, "
    cQuery3 +=        " SG1_Rec.G1_INI, "
    cQuery3 +=        " SG1_Rec.G1_FIM, "
    cQuery3 +=        " SG1_Rec.G1_GROPC, "
    cQuery3 +=        " SG1_Rec.G1_OPC, "
    cQuery3 +=        " Qry_Recurs.NIVEL+1 as NIVEL, "
    cQuery3 +=        " Qry_Recurs.COD_PAI as COD_PAI, "
    cQuery3 +=        " CAST(Qry_Recurs.NIVEL_PAI || CAST(ROW_NUMBER() OVER(ORDER BY SG1_Rec.G1_FILIAL,  SG1_Rec.G1_COD,  SG1_Rec.G1_COMP,  SG1_Rec.G1_TRT ASC) as varchar(4000)) as varchar(4000)) as NIVEL_PAI, "
    cQuery3 +=        " 'N' EHPAI "

    aadd(aTables,{'G1_','SG1_Rec.'})
    PcpInCposPerson(@self:aStruct, @cQuery3, self:getCustomFields(),.T.,.T.,"B1_",aTables)
    aTables := {}

    cQuery3 +=    " FROM " + RetSqlName("SG1") + " SG1_Rec" 
    cQuery3 +=   " INNER JOIN ExplodeEstrutura Qry_Recurs "
    cQuery3 +=      " ON Qry_Recurs.G1_COMP = SG1_Rec.G1_COD "
    cQuery3 +=   " WHERE SG1_Rec.G1_FILIAL = ? "
    cQuery3 +=     " AND SG1_Rec.D_E_L_E_T_ = ' ' ) "
    
    //Query do resultado
    cQuery4 += " SELECT " 
    //Campos SG1
    cQuery4 +=         " Resultado.G1_FILIAL, "
    cQuery4 +=         " Resultado.RECNO, "
    cQuery4 +=         " Resultado.G1_REVINI, "
    cQuery4 +=         " Resultado.G1_REVFIM, "
    cQuery4 +=         " Resultado.G1_COD, "
    cQuery4 +=         " Resultado.G1_COMP, "
    cQuery4 +=         " Resultado.G1_TRT, "
    cQuery4 +=         " Resultado.G1_OBSERV, "
    cQuery4 +=         " Resultado.G1_PERDA, "
    cQuery4 +=         " Resultado.G1_QUANT, "
    cQuery4 +=         " Resultado.G1_FIXVAR, "
    cQuery4 +=         " Resultado.G1_INI, "
    cQuery4 +=         " Resultado.G1_FIM, "
    cQuery4 +=         " Resultado.G1_GROPC, "
    cQuery4 +=         " Resultado.G1_OPC , "
    //Campos SB1
    cQuery4 +=         " SB1.B1_DESC, "
    cQuery4 +=         " SB1.B1_TIPO, "
    cQuery4 +=         " SB1.B1_GRUPO, "
    cQuery4 +=         " SB1.B1_UM, "
    If lUsaSBZ .And. lRevAtu
        cQuery4 +=     " SBZ.BZ_QB B1_QB , "
        cQuery4 +=     " SBZ.BZ_OPC B1_OPC, "
        cQuery4 +=     " CASE WHEN SBZ.BZ_REVATU = ' ' OR SBZ.BZ_REVATU IS NULL THEN 
        cQuery4 +=     "      SB1.B1_REVATU ELSE SBZ.BZ_REVATU END B1_REVATU, "
    Else
        cQuery4 +=     " SB1.B1_QB, "
        cQuery4 +=     " SB1.B1_OPC, "
        cQuery4 +=     " SB1.B1_REVATU, "
    Endif
    //Campos AUX
    cQuery4 +=         " Resultado.NIVEL, "
    cQuery4 +=         " Resultado.COD_PAI, "
    cQuery4 +=         " Resultado.NIVEL_PAI, "
    cQuery4 +=         " Resultado.EHPAI "

    aadd(aTables,{'G1_','Resultado.'})
    aadd(aTables,{'B1_','SB1.'})
    PcpInCposPerson(@self:aStruct, @cQuery4, self:getCustomFields(),.T.,.T.,,aTables)
    aTables := {}

	cQuery4 +=    " FROM ExplodeEstrutura Resultado "
    cQuery4 +=       " INNER JOIN " + RetSqlName("SB1") + " SB1 "
    cQuery4 +=               " ON SB1.B1_FILIAL = ? "
	cQuery4 +=              " AND SB1.B1_COD = Resultado.G1_COD "
    cQuery4 +=              " AND SB1.B1_TIPO  >= ? "
    cQuery4 +=              " AND SB1.B1_TIPO  <= ? "
    cQuery4 +=              " AND SB1.B1_GRUPO >= ? "
    cQuery4 +=              " AND SB1.B1_GRUPO <= ? "
	cQuery4 +=              " AND SB1.D_E_L_E_T_ = ' ' "
    If lUsaSBZ .And. lRevAtu
        cQuery4 += " LEFT JOIN "+RetSqlName("SBZ")+" SBZ ON SBZ.BZ_FILIAL = ? AND SBZ.BZ_COD = SB1.B1_COD AND SBZ.D_E_L_E_T_ = ' ' "
    EndIf
    cQuery4 += " WHERE "
    If lUsaSBZ .And. lRevAtu
        cQuery4 += " (Resultado.EHPAI = 'S' "
        cQuery4 += " OR CASE WHEN SBZ.BZ_REVATU = ' ' OR SBZ.BZ_REVATU IS NULL THEN "
        cQuery4 += " SB1.B1_REVATU ELSE SBZ.BZ_REVATU END " 
        cQuery4 += " BETWEEN Resultado.G1_REVINI AND Resultado.G1_REVFIM) "
    Else
        cQuery4 += " (Resultado.EHPAI = 'S' 
        cQuery4 += " OR SB1.B1_REVATU BETWEEN Resultado.G1_REVINI AND Resultado.G1_REVFIM) "
    EndIf

    cQuery4 +=     " ORDER BY Resultado.G1_FILIAL, Resultado.COD_PAI, Resultado.NIVEL_PAI, Resultado.G1_COD, Resultado.G1_COMP "

    cQuery := cQuery1 + cQuery2 + cQuery3 + cQuery4

    If "POSTGRES" $ cBanco
		//Altera sintaxe da clausula WITH
		cQuery := StrTran(cQuery, 'WITH ', 'WITH recursive ')
    ElseIf "MSSQL" $ cBanco
		//Substitui concatenação || por +
		cQuery := StrTran(cQuery, '||', '+')
	EndIf

    nPosParam := 1

    oExec := FwExecStatement():New(cQuery)

    oExec:setString(nPosParam++, xFilial("SB1"))
    If !EMPTY(aParam[7])
        oExec:setString(nPosParam++, aParam[7]) // Revisão
    Else
        If lUsaSBZ .And. lRevAtu
            oExec:setString(nPosParam++, xFilial("SBZ"))
        EndIf
    Endif
    oExec:setString(nPosParam++, xFilial("SG1"))
    oExec:setString(nPosParam++, aParam[1]) // Produto de:
    oExec:setString(nPosParam++, aParam[2]) // Produto até
    If lDatRef
        oExec:setDate(nPosParam++, aParam[9]) // Data de Referência
        oExec:setDate(nPosParam++, aParam[9]) // Data de Referência
    EndIf
    oExec:setString(nPosParam++, xFilial("SG1"))
    oExec:setString(nPosParam++, xFilial("SB1"))
    oExec:setString(nPosParam++, aParam[3]) // Tipo de:
    oExec:setString(nPosParam++, aParam[4]) // Tipo até:
    oExec:setString(nPosParam++, aParam[5]) // Grupo de:
    oExec:setString(nPosParam++, aParam[6]) // Grupo até:
    If lUsaSBZ .And. lRevAtu
        oExec:setString(nPosParam++, xFilial("SBZ"))
    EndIf
    
    cAlias := oExec:OpenAlias()

    If (cAlias)->(!Eof())
        cDescEmp := FWGrpName()
        cDescFil := FWFilialName(, (cAlias)->G1_FILIAL, 1)
    EndIf
    If lUsaSBZ .And. lRevAtu
        SBZ->(dbSetOrder(1))
    Else
        SB1->(dbSetOrder(1))
    Endif
    SG1->(dbSetOrder(1))

    If lDatRef
        dDatRef := aParam[9]
    else
        dDatRef := dDataBase
    EndIf

    While (cAlias)->(!Eof())

        If (cAlias)->NIVEL > nAteNiv
            (cAlias)->(DBSkip())
            Loop
        EndIf

        If (cAlias)->G1_FIXVAR $ 'V'
            cFixVar := STR0004 //STR0004 - 'VARIAVEL'
        Else
            cFixVar := STR0005 //STR0005 - 'FIXA'
        EndIf

        //Leitura da SB1 para o produto PAI
        If lUsaSBZ .And. lRevAtu
            SBZ->(MsSeek(xFilial('SBZ')+(cAlias)->G1_COD))
            //Se o produto pai tem especificado quais são os opcionais deve obdecer essa ordem. 
		    If !Empty((cAlias)->B1_OPC)
		    	aMopc := Str2Array(SBZ->BZ_MOPC,.F.)
                cOpcDft := SBZ->BZ_MOPC
		    Else 
		    	aMopc := {}
                cOpcDft := ""
		    EndIf
        Else
		    SB1->(MsSeek(xFilial('SB1')+(cAlias)->G1_COD))
            //Se o produto pai tem especificado quais são os opcionais deve obdecer essa ordem. 
		    If !Empty((cAlias)->B1_OPC)
			    aMopc := Str2Array(SB1->B1_MOPC,.F.)
                cOpcDft := SB1->B1_MOPC
		    Else 
			    aMopc := {}
                cOpcDft := ""
		    EndIf
        Endif

        //Se não existir nenhum grupo/opcional default, deverá listar todos os opcionais
        lVlOpc := .T.
	    If Empty(cOpcDft) 
	    	lVlOpc := .F.
	    EndIf

        If (cAlias)->G1_COD == (cAlias)->COD_PAI
            cCodPaiAnt := (cAlias)->COD_PAI
            If lUsaSBZ .And. lRevAtu
                nQuantPai := RetFldProd((cAlias)->COD_PAI,"BZ_QB")
            Else
                nQuantPai := RetFldProd((cAlias)->COD_PAI,"B1_QB")
            Endif
            If nQuantPai == 0
                nQuantPai := 1
            EndIf
        EndIf

        If cCodPaiAnt != (cAlias)->G1_COD 
            cCodPaiAnt := (cAlias)->G1_COD 
            nQuantPai := nQuantItem
        EndIf

        If (cAlias)->EHPAI = 'S' .And. !EMPTY(aParam[7])
            cRevisao := aParam[7]
        Else 
            cRevisao := (cAlias)->B1_REVATU
        EndIf

        //Leitura da SG1 para o componente da estrutura
        SG1->(DBGoto((cAlias)->RECNO))

        cProOpcT   := ((cAlias)->G1_COD + (cAlias)->G1_COMP + (cAlias)->G1_TRT )
        If Empty(cOpcDft) .OR. ExistOpc(cOpcDft, (cAlias)->G1_GROPC+(cAlias)->G1_OPC, cProOpcT, "")
            nQuantItem := ExplEstr(nQuantPai,dDatRef,cOpcDft,cRevisao,,,,,,,,,lVlOpc)
            If !((lNegEstr .Or. (!lNegEstr .And. QtdComp(nQuantItem,.T.) > QtdComp(0) )) .And. (QtdComp(nQuantItem,.T.) # QtdComp(0,.T.)))
                (cAlias)->(DBSkip())
                Loop
            EndIf
        Else
            nQuantItem := 0
            (cAlias)->(DBSkip())
            Loop
        EndIf

        //Leitura da SB1 para buscar dados do componente da estrutura
        //Essa leitura da SB1 sempre tem que ser a última antes do appendData
        //Todas as outras devem ocorrer antes desse ponto
        If lUsaSBZ .And. lRevAtu
		    SBZ->(MsSeek(xFilial('SBZ')+(cAlias)->G1_COMP))
        Else
            SB1->(MsSeek(xFilial('SB1')+(cAlias)->G1_COMP))
        Endif

        ojItems := JsonObject():new()

        for nX := 1 To Len(self:aStruct)
            If self:aStruct[nX][1] $ 'DESCCOMP/UMCOMP/TPCOMP/GRCOMP'
                //Campos Auxiliares
                ojItems[self:aStruct[nX][1]] := SB1->&(self:aStruct[nX][5]) 
            elseif self:aStruct[nX][1] $ 'QBCOMP' //Tratamento para B1_QB igual a zero, tem que ser 1
                If lUsaSBZ .And. lRevAtu
                    If SBZ->&(self:aStruct[nX][5]) == 0
                        ojItems[self:aStruct[nX][1]] := 1
                    else
                        ojItems[self:aStruct[nX][1]] := SBZ->&(self:aStruct[nX][5])
                    EndIf
                Else
                    If SB1->&(self:aStruct[nX][5]) == 0
                        ojItems[self:aStruct[nX][1]] := 1
                    else
                        ojItems[self:aStruct[nX][1]] := SB1->&(self:aStruct[nX][5])
                    EndIf
                Endif
            elseif self:aStruct[nX][1] $ 'QTDNEC'
                ojItems[self:aStruct[nX][1]] := nQuantItem 
            elseif self:aStruct[nX][1] $ 'DTREF'
                ojItems[self:aStruct[nX][1]] := totvs.framework.treports.date.dateToTimeStamp(dDatRef)
            elseif self:aStruct[nX][1] $ 'DESCEMP'
                ojItems[self:aStruct[nX][1]] := cDescEmp
            elseif self:aStruct[nX][1] $ 'DESCFIL'
                ojItems[self:aStruct[nX][1]] := cDescFil
            elseif self:aStruct[nX][1] $ 'G1PERDA'
                ojItems[self:aStruct[nX][1]] := ((cAlias)->G1_PERDA)/100
            else
                //Campos do select principal
                If self:aStruct[nX][1] == "B1QB" //Tratamento para B1_QB igual a zero, tem que ser 1
                    If (cAlias)->&(self:aStruct[nX][5]) == 0
                        ojItems[self:aStruct[nX][1]] := 1
                    else
                        ojItems[self:aStruct[nX][1]] := (cAlias)->&(self:aStruct[nX][5])
                    EndIf
                ElseIf self:aStruct[nX][1] == "G1FIXVAR" //Tratamento para imprimir o STR do campo G1_FIXVAR
                    ojItems[self:aStruct[nX][1]] := cFixVar
                Elseif self:aStruct[nX][3] == "date" //Converter data para o formato padrão - 2023-01-27T15:31:43Z
                    ojItems[self:aStruct[nX][1]] := totvs.framework.treports.date.stringToTimeStamp((cAlias)->&(self:aStruct[nX][5]))
                Else
                    ojItems[self:aStruct[nX][1]] := (cAlias)->&(self:aStruct[nX][5])
                EndIf                           
            Endif
        next nX
    
        self:ProcessData()
        self:oData:appendData(ojItems)

        (cAlias)->(DBSkip())

    EndDo 

    (cAlias)->(DBCloseArea())
    oExec:Destroy()
    FreeObj(oExec)
    
Return self:oData

/*/{Protheus.doc} getSchema
Retorna a estrutura dos campos
 
@return object: self:oSchema

@author ana.paula
@since 25/04/2023
@version 1.0
/*/
Method getSchema() as object class EstruturaTReportsBusinessObject
    Local nX         := 0                                                               as numeric
    Local lRevAtu    := FindFunction('PCPREVATU') .AND. SuperGetMv("MV_REVFIL",.F.,.F.) as logical
    Local lUsaSBZ    := SuperGetMV("MV_ARQPROD", .F., "SB1") == 'SBZ'                   as logical


    //Campos do select principal
    self:aFields := {"G1_FILIAL","G1_COD","G1_COMP","G1_TRT","G1_OBSERV","G1_PERDA","G1_QUANT",;
                     "G1_FIXVAR","G1_INI","G1_FIM","G1_GROPC","G1_OPC",;
                     "B1_DESC","B1_TIPO","B1_GRUPO","B1_UM","B1_QB","B1_OPC ","B1_REVATU"}
                     
    self:aStruct := PcpTrGetStruct(self:aFields)

    //Campos Auxiliares
    AAdd(self:aStruct , {"DESCCOMP", "DESC_COMP", "string", "DESC_COMP" , "B1_DESC"  })
    AAdd(self:aStruct , {"UMCOMP"  , "UM_COMP"  , "string", "UM_COMP"   , "B1_UM"    })
    If lUsaSBZ .And. lRevAtu
        AAdd(self:aStruct , {"QBCOMP"  , "QB_COMP"  , "number", "QB_COMP"   , "BZ_QB"    })
    Else
        AAdd(self:aStruct , {"QBCOMP"  , "QB_COMP"  , "number", "QB_COMP"   , "B1_QB"    })
    Endif
    AAdd(self:aStruct , {"TPCOMP"  , "TP_COMP"  , "string", "TIPO_COMP" , "B1_TIPO"  })
    AAdd(self:aStruct , {"GRCOMP"  , "GR_COMP"  , "string", "GRUPO_COMP", "B1_GRUPO" })
    AAdd(self:aStruct , {"QTDNEC"  , "QTD_NEC"  , "number", "QTD_NEC"   , "G1_QUANT" })
    AAdd(self:aStruct , {"DTREF"   , "DT_REF"   , "date"  , "DT_REF"    , "DT_REF"   })
    AAdd(self:aStruct , {"NIVEL"   , "NIVEL"    , "number", "NIVEL"     , "NIVEL"    })
    AAdd(self:aStruct , {"CODPAI"  , "COD_PAI"  , "string", "COD_PAI"   , "COD_PAI"  })
    AAdd(self:aStruct , {"NIVELPAI", "NIVEL_PAI", "string", "NIVEL_PAI" , "NIVEL_PAI"})
    AAdd(self:aStruct , {"DESCEMP" , "DESC_EMP" , "string", "DESC_EMP"  , "DESC_EMP" })
    AAdd(self:aStruct , {"DESCFIL" , "DESC_FIL" , "string", "DESC_FIL"  , "DESC_FIL" })

    For nX := 1 To Len(self:aStruct)
        self:addProperty(self:aStruct[nX][1], self:aStruct[nX][2], self:aStruct[nX][3], self:aStruct[nX][4], self:aStruct[nX][5])
    Next nX

Return self:oSchema
