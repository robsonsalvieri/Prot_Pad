#Include "PCPXFUN.CH"
#INCLUDE "PROTHEUS.CH"
#INCLUDE "FWADAPTEREAI.CH"
#INCLUDE "fwlibversion.ch"

#DEFINE TABELAS_MES_LITE "|SB1|SC2|"

Static _lFunPPI    := ExistBlock('PCPXFUNPPI')
Static lIntSFC     := ExisteSFC("SC2") .And. !IsInCallStack("AUTO650")
Static slPCPREVATU := FindFunction('PCPREVATU')  .AND.  SuperGetMv("MV_REVFIL",.F.,.F.)
Static _oIntMESON  := JsonObject():New()
Static _lFilPrMES  := Nil
/*

0
Ŀ
         ATUALIZACOES SOFRIDAS DESDE A CONSTRUAO INICIAL.             
Ĵ
Programador  Data    BOPS   Motivo da Alteracao                     
Ĵ
Rodrigo Sart14/10/98XXXXXX Acerto na funcao ConvTime()              
Rodrigo Sart18/06/9915632AAcertada verificacao de Saldo por Operacao
ٱ



Ŀ
Funo     ChkPCP    Autor  Waldemiro L. Lustosa   Data  30/08/95 
Ĵ
Descrio  Avalia o parmetro MV_PRECISA e os campos com binarios.    
Ĵ
 Uso       SIGAPCP                                                    
ٱ


*/
Function ChkPCP(lAltera)
Local lRet := .T.

Default lAltera := .F.

If lAltera
	DbSelectArea("SH7")
	DbSelectArea("SH9")
	SH7->(DbGoTop())
	SH9->(DbGoTop())
	If !(SH7->(EOF()) .Or. SH9->(EOF()))
		lRet := .F.
		Help(" ",1,"SH7SH9DADOS",,"Somente  possivel alterar o parametro MV_PRECISA, se as tabelas SH7 e SH9 estiverem vazias. Somente assim  possivel garantir a integridade das informaes")
	EndIf
EndIf

Return( lRet )

	/*


Ŀ
Funo	 A680Prod	 Autor  Marcelo Bomura Abe	 Data  19.01.94 
Ĵ
Descrio Pega o Campo Produto para a funcao CONPAD1 no CASE=SH8. 	  
Ĵ
Sintaxe	 A680Prod													  
Ĵ
Parametros 															  
Ĵ
 Uso		 MATA680													  
ٱ


*/
Function A680Prod()
dbSelectArea("SC2")
dbSeek(cFilial+SubStr(SH8->H8_OP,1,6)+SubStr(SH8->H8_OP,7,2)+SubStr(SH8->H8_OP,9,3)+Right(SH8->H8_OP,Len(SC2->C2_ITEMGRD)) )
dbSelectArea("SH8")
Return SC2->C2_PRODUTO
/*


Ŀ
Funo	 A680SalOpe Autor  Marcelo Bomura Abe	 Data  19.01.94 
Ĵ
Descrio Calcula o Saldo Por Operacao Alocada.						  
Ĵ
Sintaxe	 A680SalOpe(Void)											  
Ĵ
Parametros 															  
Ĵ
 Uso		 MATA680													  
ٱ


*/
Function A680SalOpe()
Local nSaldoPCP:=0
Local nRet:=0
Local aArea:=GetArea()

dbSelectArea("SC2")
If dbSeek(cFilial+SubStr(SH8->H8_OP,1,6)+SubStr(SH8->H8_OP,7,2)+SubStr(SH8->H8_OP,9,3)+Right(SH8->H8_OP,Len(SC2->C2_ITEMGRD)) )
	dbSelectArea("SH6")
	dbSetOrder(1)
	dbSeek(xFilial()+SH8->H8_OP+SC2->C2_PRODUTO+SH8->H8_OPER)
	While !Eof() .And. H6_FILIAL+H6_OP+H6_PRODUTO+H6_OPERAC == xFilial("SH8")+SH8->H8_OP+SC2->C2_PRODUTO+SubStr(SH8->H8_OPER,1,2)
		If SH8->H8_RECURSO == SH6->H6_RECURSO .And. SH8->H8_SEQROTA == SH6->H6_SEQ .And. SH8->H8_DESDOBR == SH6->H6_DESDOBR
			If SH8->H8_SEQCARG == SH6->H6_SEQCARG
				nSaldoPCP += H6_QTDPROD+H6_QTDPERD+H6_PERDANT
			EndIf
		Endif
		dbSkip()
	End
EndIf
//Ŀ
// Verifica saldo no arquivo de operacoes (caso nao tenha ocorrido
// apontamento de todas operacoes) ou saldo no arquivo de OPs     
//
nRet:=Max(0,SH8->H8_QUANT - nSaldoPCP)
RestArea(aArea)
Return nRet

/*


Ŀ
Funo    Bit2Tempo  Autor  Waldemiro L. Lustosa   Data  08/10/95 
Ĵ
Descrio  Tranforma Numero de Bits em Tempo de Operacao              
Ĵ
Sintaxe    ExpC1=Bit2Tempo(ExpN2)                                     
Ĵ
Parametros ExpC1 = Retorna o tempo de Operacao no formato "HHHH:MM"   
           ExpN2 = Numero de Bits a ser transformado                  
Ĵ
 Uso       SIGAPCP                                                    
ٱ


*/
Function Bit2Tempo(nBits,lAvalia)
Local nHoras, cTempo, nBitsMin, nMinutos, nTamHoras
Local nPrecisao := GetMV("MV_PRECISA")

nHoras := Int( nBits / nPrecisao )

nTamHoras := IIf( lAvalia == NIL, 4, Len(Alltrim(Str(nHoras,8,0))) )

nTamHoras := IIf( nTamHoras == 1, 2, nTamHoras )

cTempo := StrZero( nHoras, nTamHoras, 0)

nBitsMin := ( ( nBits / nPrecisao ) - Int( nBits / nPrecisao ) ) * nPrecisao
nMinutos := ( 60 / nPrecisao ) * nBitsMin

cTempo += ":"+StrZero( nMinutos, 2, 0)

Return cTempo

/*


Ŀ
Funo     PosiMaq   Autor  Ary Medeiros           Data           
Ĵ
Descrio  Retorna a posicao da maquina dentro do arquivo binario     
                                                                      
Ĵ
Sintaxe    ExpN1=Posimaq(ExpC2,ExpA3)                                 
Ĵ
Parametros ExpN1 = Retorna a posiao da maquina                        
           ExpC2 = Codigo da maquina a ser localizada                 
           ExpA3= Array com dados do arquivo binario                  
Ĵ
 Uso       SIGAPCP                                                    
ٱ


*/
Function PosiMaq(cMaq,cIndex)
Return((At(cMaq,cIndex)-1)/7)

/*


Ŀ
Funo     ChkBatchOP   Autor  Waldemiro Lustosa   Data  27/02/96 
Ĵ
Descrio  Funo que verifica se todas as OPs/SCs filhas foram gera- 
           das a partir das Ordens de Produo cadastradas.           
Ĵ
 Uso       MATA690                                                    
ٱ


*/
Function ChkBatchOP()
Local lRet := .F.
Local cAlias := Alias()

a650RegOPI(@lRet)
dbSelectArea(cAlias)

Return lRet

/*


Ŀ
Funo      TransHora   Autor  Waldemiro Lustosa   Data  17/01/96 
Ĵ
Descrio Avalia a Picture a ser impressa para Horas (C)entesimais ou 
          (N)ormais.                                                  
Ĵ
Sintaxe    TransHora(ExpC1,ExpC2,ExpN1,ExpC3)                         
Ĵ
Parametros ExpC1 = Campo a ser impresso                               
           ExpC2 = Tipo de hora utilizada (MV_TPHR)                   
           ExpN1 = Coluna em que deve ser impresso o campo            
Ĵ
 Uso       Generico                                                   
ٱ


*/
Function TransHora(cCpo,cTipo,nColuna,cTot)
Local cPict,nHora,nMinuto,cString
cCampo:=cCpo
If cTot==NIL
	cTot:=""
Else
	cCpo := cTot
Endif
If cTipo=="C"
	@ li,nColuna PSay &cCpo Picture PesqPictQT(Subs(cCampo,6,Len(cCampo)-5),9)
Else
	nHora	  := Int(&cCpo)
	nMinuto := (&cCpo-nHora)*(.6)*100
	cString := StrZero(nHora,5)+StrZero(nMinuto,2)
	@ li,nColuna+1 PSay Transform(cString,'@R 99999:99')
Endif
Return

/*


Ŀ
Funo     ConvTime  Autor Rodrigo de A. Sartorio  Data  12.03.98 
Ĵ
Descrio  Converte o tempo em bits para impressao de acordo com o    
           parametro selecionado (MV_TPHR). Se o parametro do tempo   
           estiver centesimal, o retorno ser numerico, se estiver    
           normal o retorno ser caracter.                            
Ĵ
Sintaxe    ConvTime(ExpN1,ExpN2,ExpC1)                                
Ĵ
Parametros ExpN1 = Tempo em Bits                                      
           ExpN2 = Tempo no formato centesimal                        
           ExpC1 = Tempo no formato normal                            
Ĵ
 Uso       RELATORIOS PCP                                             
ٱ


*/
Function ConvTime(nBits,nTempoCen,cTempoNor,cForcaTipo)
Static cTipoTemp:=""
Local nPos:=0,nTempo:=CriaVar("G2_TEMPAD")
Local cTempo:=""
Default cForcaTipo := ""
If Empty(cTipoTemp)
	cTipoTemp:=GetMV("MV_TPHR")
EndIf
If !Empty(cForcaTipo)
	cTipoTemp:=cForcaTipo
EndIf
If nBits # NIL .And. ValType(nBits) == "N"
	//Ŀ
	// Obtem o horario no formato NORMAL (00:00)                    
	//
	cTempo:=Bit2Tempo(nBits)
	//Ŀ
	// Caso necessario obtem o horario no formato CENTESIMAL (00.00)
	//
	If cTipoTemp == "C"
		nPos	:=AT(":",cTempo)
		nTempo:=Val(Substr(cTempo,1,nPos-1)+"."+Substr(cTempo,nPos+1))
		nTempo:=Int(nTempo)+(((nTempo-Int(nTempo))/60)*100)
	EndIf
ElseIf nTempoCen # NIL .And. ValType(nTempoCen) == "N"
	If cTipoTemp == "C"
		nTempo:=nTempoCen
	Else
		//Ŀ
		// Tranf. o horario CENTESIMAL (0.00) no formato NORMAL (00:00) 
		//
		cTempo:=StrZero(nTempoCen,5,2)
		nPos  :=AT(".",cTempo)
		cTempo:=(Substr(cTempo,1,nPos-1)+":"+Substr(cTempo,nPos+1,2))
	EndIf
ElseIf cTempoNor # NIL .And. ValType(cTempoNor) == "C"
	//Ŀ
	// Obtem o horario no formato NORMAL (00:00)                    
	//
	If cTipoTemp == "N"
		cTempo:=cTempoNor
	Else
		//Ŀ
		// Caso necessario obtem o horario no formato CENTESIMAL (00.00)
		//
		nPos	:=AT(":",cTempoNor)
		nTempo:=Val(Substr(cTempoNor,1,nPos-1)+"."+Substr(cTempoNor,nPos+1))
		nTempo:=Int(nTempo)+(((nTempo-Int(nTempo))/60)*100)
	EndIf
EndIf
Return IF(cTipoTemp=="C",nTempo,cTempo)

/*


Ŀ
Funo     TimePict  Autor Rodrigo de A. Sartorio  Data  12.03.98 
Ĵ
Descrio  Retorna a picture para hora centesimal ou normal           
Ĵ
Sintaxe    TimePict()                                                 
Ĵ
 Uso       RELATORIOS PCP                                             
ٱ


*/
Function TimePict()
Static cTipoTemp:=""
Local cPicture:=""
If Empty(cTipoTemp)
	cTipoTemp:=GetMV("MV_TPHR")
EndIf
If cTipoTemp == "C"
	cPicture := "@E " +Replicate("9",TamSx3("H6_TEMPO")[1]-3) +".99"
EndIf
Return cPicture

/*

Ŀ
Funo    ConvTimeH6  Autor  Marcelo Iuspa          Data  03/10/01 
Ĵ
Descrio  Converte tempo centesimal para o formato solicitado         
Ĵ
 Sintaxe   ExpC1:=ConvTimeH6(ExpN1, ExpC2)                             
Ĵ
Parametros ExpC1 = Tempo convertido de acordo com parametro informado  
           ExpN1 = Identifica qual o formato de hora desejado, sendo:  
                   1=Retorna de acordo com MTA680 (mv_par03);          
                   2=Retorna de acordo com MV_TPHR                     
                   3=Retorna formato normal                            
                   4=Retorna formato centesimal                        
           ExpC2 = Hora a ser convertida. Se Nil, usa H6_TEMPO         
Ĵ
 Uso       MATA680/MATA681                                             
ٱ


*/
*
* REMOVER ESTA FUNCAO POSTERIORMENTE (Obs. Em 27/01/2003)
*
Function ConvTimeH6(nTipo, cTime)
// mv_par03 - Tempo do Apontamento (1) Normal (2) Centesimal
// nTipo: 1=Retorna de acordo com MTA680 (mv_par03);
//        2=Retorna de acordo com MV_TPHR
//        3=Retorna formato normal
//        4=Retorna formato centesimal
// Obs  : Parametro recebido devera ser sempre no formato centesimal
Local nPar03    := Posicione("SX1", 1, "MTA68003", "X1_PRESEL")
Local cTpHr     := GetMV("MV_TPHR")
Local nPos, nTempo, nHoras, nMinutos
Local cResult

cTime := If(cTime==Nil,SH6->H6_TEMPO,cTime)
nTipo := If(nTipo==Nil,1,nTipo)
If nTipo == 4 .Or. (nTipo == 1 .And. nPar03 == 2) .Or. (nTipo == 2 .And. cTpHr == "C")
	cResult := cTime
Else
	nPos     := AT(":", If(":" $ cTime, cTime, PesqPict("SH6","H6_TEMPO")))
	nTempo   := Val(StrTran(cTime,':','.'))
	nHoras	 := Int(nTempo)
	nMinutos := (nTempo - Int(nTempo)) * 60
	cResult  := StrZero(nHoras,nPos-1)+":"+StrZero(nMinutos,2)
Endif
Return(cResult)

/*

Ŀ
Funo    TimeH6      Autor  Marcelo Iuspa          Data  27/01/03 
Ĵ
Descrio  Converte H6_TEMPO para centesimal ou normal                 
Ĵ
 Sintaxe   ExpC1:=TimeH6(ExpC1)                                        
Ĵ
Parametros ExpC1 = Formato do tempo a ser retornado                    
Ĵ
 Uso       MATA680/MATA681                                             
ٱ


*/
Function TimeH6(cFormato, cFieldH6, cAlias)
// mv_par03 - Tempo do Apontamento (1) Normal (2) Centesimal
Local nPar03   := Posicione("SX1", 1, "MTA68003", "X1_PRESEL")
Local nForOri  := Nil
Local cForOri  := Nil
Local nField   := Nil
Default cAlias := "SH6"
Static cTpHr

If cTpHr == Nil
	cTpHr := GetMV("MV_TPHR")
Endif

nForOri := If(!Empty((cAlias)->H6_TIPOTEM), (cAlias)->H6_TIPOTEM, nPar03)
cForOri := If(nForOri == 1, "N", "C")

nField := (cAlias)->(FieldPos(If(cFieldH6 == Nil, "H6_TEMPO", Upper(cFieldH6))))

Return(A680ConvHora((cAlias)->(FieldGet(nField)), cForOri, If(cFormato == Nil, cTpHr, cFormato)))



/*


Ŀ
Funo    OpenSemSH8	  Autor  Erike Yuri        Data 12/12/2006
Ĵ
Descrio  Cria semaforo para SH8 permitindo exclusividade no tabela  
           por filial.                                                
Ĵ
Parametros ExpL1 :Mostara Help caso nao consiga exclusividade no SH8  
Ĵ
 Uso       SIGAPCP                                                   
ٱ


*/
Function OpenSemSH8(lShowHelp)
Local lMT690SH8 :=  If(ExistBlock("MT690SH8"),ExecBlock("MT690SH8",.F.,.F.),.T.)//ponto de entrada para definir se locka ou no a SH8
Local lRet := .T.
DEFAULT lShowHelp := .T.

If lMT690SH8
	lRet := LockByName("SH8USO"+cNumEmp,.T.,.T.,.T.)
EndIf

If !lRet .And. lShowHelp
	Help(" ",1,"SH8EmUso")
EndIf

Return ( lRet  )



/*


Ŀ
Funo    ClosSemSH8	  Autor  Erike Yuri        Data 12/12/2006
Ĵ
Descrio  Fecha semaforo do SH8 permitindo que o mesmo fique disponi-
           vel para a filial corrente.                                
Ĵ
Parametros Nenhum                                                     
Ĵ
 Uso       SIGAPCP                                                   
ٱ


*/
Function ClosSemSH8()
Return UnLockByName("SH8USO"+cNumEmp,.T.,.T.,.T.)



/*


Ŀ
Funo    IsLockSH8		  Autor  Erike Yuri        Data 12/12/2006
Ĵ
Descrio  Retorna informacao se SH8 esta locado (exclusivo) para al- 
           gum processo, ou nao.                                      
Ĵ
Parametros ExpL1: Mostara Help caso nao consiga exclusividade no SH8  
Ĵ
 Uso       SIGAPCP                                                   
ٱ


*/
Function IsLockSH8(lShowHelp)
Local lLock := LockByName("SH8USO"+cNumEmp,.T.,.T.,.T.)
Local lRet	:= .T.
DEFAULT lShowHelp := .T.

If lLock
	UnLockByName("SH8USO"+cNumEmp,.T.,.T.,.T.)
	lRet := .F.
EndIf

If lRet .And. lShowHelp
	Help(" ",1,"SH8EmUso")
EndIf

Return ( lRet )

/*


ͻ
Programa  OPGeraQIP Autor  Andre Anjos          Data   06/30/09   
͹
Descricao  Gera integracao com Inspecao de Processos (SIGAQIP) quando 
           houver (o registro no arquivo SC2 deve estar posicionado e 
           com lock aplicado).										  
͹
Uso        MATA650, MATA651 e MATA720                                 
ͼ


*/
Function OPGeraQIP()
Local aArea   := GetArea()
Local aRetEsp  := {}
Local cQipPcp  := SuperGetMV("MV_QINSPEC",.F.,"1")
Local lIntQIP  := If(cModulo=="QIP",.T.,IntQIP())
Local lMT650QIP := If(ExistBlock("MT650QIP"),ExecBlock("MT650QIP",.F.,.F.),.T.)
Local lQPMTA650 := .T.
Local nNumCqPr := Posicione("SB1",1,FwxFilial("SB1")+SC2->C2_PRODUTO, "B1_NUMCQPR")
Local nVerifica := 0

	DEFAULT lOpQIP    := .T.

If cQipPcp == "1" .and. !lMT650QIP
	lOpQIP := .F.
	RETURN
EndIf

If Existblock ("QPMTA650")
  lQPMTA650 := Execblock ("QPMTA650",.F.,.F.)
Endif

If SC2->C2_TPOP == "F"  .And. lQPMTA650 //.And. nNumCqPr <> 0
	If IntQIP(SC2->C2_PRODUTO,"1",If(cModulo=="QIP","E","T")) //Define a integracao com o QIP
		If SC2->C2_VERIFI == 0
			nVerifica := QIPSitInsPro(.T.)
		EndIF
		aRetEsp := QIPRevRot(SC2->C2_PRODUTO)
		RecLock("SC2",.F.)
		If nVerifica <> 0
			SC2->C2_VERIFI := nVerifica
			If nVerifica == 2 //Gera o Codigo do Certificado de Qualidade
				SC2->C2_LAUDO  := "A"
				SC2->C2_CERQUA := QA_SEQUSX6("QIP_CEQU",TamSX3("C2_CERQUA")[1],"S","Certificado Qualidade")
			EndIf
		EndIF
		SC2->C2_REVI   := aRetEsp[1]
		SC2->C2_GRUPO  := aRetEsp[3]
		SC2->C2_IDEINV := INVERTE(SC2->C2_NUM) //Ordem invertida p/ controle de Skip-Lote
		MsUnlock()
		//Ŀ
		// Atualiza o Movimento OP x Lotes	(Integracao QIP x PCP)		 
		//
		QIPAtualiza("SC2",1)
	ElseIf lMT650QIP .And. lIntQIP .And. SuperGetMV("MV_QINSPEC",.T.,"1") == "2"	//Por Apontamento
		aRetEsp := QIPRevRot(SC2->C2_PRODUTO)
		RecLock("SC2",.F.)
		SC2->C2_VERIFI := 1
		SC2->C2_REVI   := aRetEsp[1]
		SC2->C2_GRUPO  := aRetEsp[3]
		SC2->C2_IDEINV := INVERTE(SC2->C2_NUM)
		MsUnlock()
	EndIf
EndIf

RestArea(aArea)
Return

/*


Ŀ
Funo    COMXFUN_V   Autor Andre Anjos		     Data  30/06/09 
Ĵ
Descrio  Funcao utilizada para verificar a ultima versao do fonte   
			  PCPXFUN.PRX aplicado no rpo do cliente, assim verificando  
			  a necessidade de uma atualizacao neste fonte.			  
Ĵ
 Uso       EST/PCP/FAT/COM	                                          
ٱ


*/
Function PCPXFUN_V
Local nRet := 20090630 // 30 de junho de 2009
Return nRet

/*/

Ŀ
Funo    UsrGrEng   Autor  Rodrigo T. Silva       Data  04.11.10 
Ĵ
Descrio  Retorna os Grupos de Engenharia do Usuario.                
Ĵ
Parametros ExpC1 = Codigo do usuario a ser verificado.                
Ĵ
Retorno    RetA1 = Array contendo os codigos dos grupos.              
Ĵ
Uso        Generico.                                                  
ٱ


/*/
Function UsrGrEng(cUser)
Local aArea 	 := GetArea()
Local cGrupoUser := ""

If !Empty(cUser)
	dbSelectArea("SGK")
	dbSetOrder(2)
	If dbSeek(xFilial()+cUser)
		cGrupoUser := SGK->GK_GRAPROV
	EndIf
Endif

RestArea(aArea)
Return cGrupoUser


/*


Ŀ
Funo     MaAlcEng  Autor  Rodrigo T. Silva		 Data 03.11.2010
Ĵ
Descrio  Controla a alcada dos documentos (SGN- Alcadas Engenharia) 
Ĵ
Sintaxe    MaAlcEng(ExpA1,ExpD1,ExpN1)				               	  
Ĵ
Parametros ExpA1 = Array com informacoes do documento                 
                 [1] Numero do documento                              
                 [2] Tipo de Documento                                
                 [3] Codigo do Usuario                                
                 [4] Grupo do Aprovador                               
                 [5] Observacao			                              
           ExpD1 = Data de referencia 				                  
           ExpN1 = Operacao a ser executada                           
                 1 = Inclusao do documento                            
                 2 = Transferencia para Superior                      
                 3 = Exclusao do documento                            
                 4 = Aprovacao do documento                           
                 5 = Estorno da Aprovacao                             
                 6 = Bloqueio Manual da Aprovacao                     
Ĵ
 Uso       Generico                                                   
ٱ


*/
Function MaAlcEng(aDocto,dDataRef,nOper,lRegSGn)
Local aArea			:= GetArea()
Local aAreaSGN		:= SGN->(GetArea())
Local cAuxNivel 	:= ""
Local cDocto		:= If(aDocto[1]==Nil,"",aDocto[1])
Local cGrupo		:= If(aDocto[4]==Nil,"",aDocto[4])
Local cNivIgual 	:= ""
Local cObs      	:= If(Len(aDocto)>4,If(aDocto[5]==Nil, "",aDocto[5]),"")
Local cQuery    	:= ""
Local cStatusAnt 	:= ""
Local cTipoDoc		:= If(aDocto[2]==Nil,"",aDocto[2])
Local cTipoLib  	:= ""
Local cUsuario		:= If(aDocto[3]==Nil,"",aDocto[3])
Local dDataLib  	:= IIF(dDataRef==Nil,dDataBase,dDataRef)
Local lAchou		:= .F.
Local lExistSGN		:= .F.
Local lFirstNiv 	:= .T.
Local lRetorno		:= .T.

DEFAULT dDataRef := dDataBase
DEFAULT lAutomacao := .F.
DEFAULT lRegSGn 	:= .F.

If Empty(cGrupo)
	cGrupo := UsrGrEng(SGG->GG_USUARIO)
Endif

nRec := ' '

If lRetorno
	Do Case
		Case nOper == 1 //Inclusao do Documento
			SGM->(dbSetOrder(2))
			If !Empty(cGrupo) .And. SGM->(dbSeek(xFilial("SGM")+cGrupo))
				While !Eof() .And. SGM->(GM_FILIAL+GM_COD)	 == xFilial("SGM")+cGrupo
					If lFirstNiv
						cAuxNivel := SGM->GM_NIVEL
						lFirstNiv := .F.
					EndIf

					//Verifica se o item ja existem para aprovao, senao inclui
					cAliasTmp   := GetNextAlias()
					cQuery := " SELECT COUNT(GN_NUM) AS CONT "
					cQuery += " FROM "+ RetSqlName( "SGN" ) +" SGN "
					cQuery += " WHERE "
					cQuery += " GN_FILIAL = '" + xFilial( "SGN" ) + "' "
					cQuery += " AND GN_TIPO = 'SGG' "
					cQuery += " AND GN_NUM  = '"+cDocto+  "' "
					cQuery += " AND GN_USER = '"+SGM->GM_USER+  "' "
					cQuery += " AND GN_NIVEL = '"+SGM->GM_NIVEL+  "' "
					cQuery += " AND D_E_L_E_T_ = ''  "
					cQuery := ChangeQuery(cQuery)

					dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasTmp,.T.,.T.)

					If ((cAliasTmp)->CONT > 0 )
						lExistSGN := .T.
						lRegSGn	  := .T.
					EndIf
					(cAliasTmp)->(dbCloseArea())

					IF ! lExistSGN
						Reclock("SGN",.T.)
						SGN->GN_FILIAL	:= xFilial("SGN")
						SGN->GN_TIPO	:= cTipoDoc
						SGN->GN_NUM 	:= cDocto
						SGN->GN_USER	:= SGM->GM_USER
						SGN->GN_NIVEL	:= SGM->GM_NIVEL
						SGN->GN_STATUS	:= IIF(SGM->GM_NIVEL == cAuxNivel,"02","01")
						SGN->GN_TIPOLIB	:= SGM->GM_TPLIBER
						SGN->GN_EMISSAO := dDataBase
						MsUnlock()
					EndIf

					SGM->(dbSkip())

					lExistSGN := .F.

				EndDo
			EndIf
			lRetorno := lFirstNiv
		Case nOper == 2 //Transferencia da Alcada para o Superior
			If SGN->(!Eof()) .And. SGN->(GN_FILIAL+GN_TIPO+GN_NUM) == xFilial("SGN")+cTipoDoc+cDocto
				// Carrega dados do Registro a ser tranferido e exclui
				cTipoDoc := SGN->GN_TIPO
				cAuxNivel:= SGN->GN_STATUS
				cNextNiv := SGN->GN_NIVEL
				dDataRef := SGN->GN_EMISSAO
				cAprovOri:= SGN->GN_USERLIB
				cTipoLib := SGN->GN_TIPOLIB
				Reclock("SGN",.F.,.T.)
				dbDelete()
				MsUnlock()

				// Inclui Registro para Aprovador Superior
				Reclock("SGN",.T.)
				SGN->GN_FILIAL	:= xFilial("SGN")
				SGN->GN_NUM		:= cDocto
				SGN->GN_TIPO	:= cTipoDoc
				SGN->GN_NIVEL	:= cNextNiv
				SGN->GN_USER	:= cUsuario
				SGN->GN_STATUS	:= cAuxNivel
				SGN->GN_EMISSAO := dDataRef
				SGN->GN_TIPOLIB := cTipoLib
				SGN->GN_OBS     := cObs
				MsUnlock()
			EndIf
			lRetorno := .T.
		Case nOper == 3 //-- Rejeicao
			SGN->(dbSetOrder(2))
			If SGN->(dbSeek(xFilial("SGN")+cTipoDoc+cDocto+cUsuario))
				Reclock("SGN",.F.)
				GN_STATUS	:= "04"
				GN_DATALIB	:= dDataLib
				GN_USERLIB	:= cUsuario
				SGN->GN_OBS := cObs
				nRecno	 	:= SGN->(Recno())
				MsUnlock()
				SGN->(dbSetOrder(1))
				While SGN->(!Eof()) .And. SGN->(GN_FILIAL+GN_TIPO+GN_NUM) == xFilial("SGN")+cTipoDoc+cDocto
					If SGN->GN_STATUS <> "04"
						Reclock("SGN",.F.)
						GN_STATUS	:= "06"
						GN_DATALIB	:= dDataLib
						GN_USERLIB	:= cUsuario
						GN_OBS	    := STR0025+AllTrim(UsrRetName(cUsuario)) +"." //Rejeitado pelo usurio
						MsUnlock()
					EndIf
					SGN->(dbSkip())
				EndDo
			EndIf
		Case nOper == 4 //Aprovacao do documento
			//Ŀ
			// Posiciona a Tabela SGM pelo Aprovador de Origem caso o Documento tenha sido 
			//| transferido por Ausncia Temporria ou Transferncia superior e o aprovador |
			//| de destino no fizer parte do Grupo de Aprovao.                           |
			//
			dbSelectArea("SGM")
			dbSetOrder(3)
			dbSeek(xFilial("SGM")+cGrupo+cUsuario)
			//Ŀ
			// Libera a pre-estrutura pelo aprovador				
			//
			dbSelectArea("SGN")
			dbSetOrder(2)
			dbSeek(xFilial("SGN")+cTipoDoc+cDocto+cUsuario)
			While !Eof() .And. xFilial("SGN")+cTipoDoc+cDocto+cUsuario == SGN->(GN_FILIAL+GN_TIPO+GN_NUM+GN_USER)
				cAuxNivel := SGN->GN_NIVEL
				If SGN->GN_STATUS == "02"
					Reclock("SGN",.F.)
					SGN->GN_STATUS	:= "03"
					SGN->GN_OBS		:= If(Len(aDocto)>4,aDocto[5],"")
					SGN->GN_DATALIB	:= dDataLib
					SGN->GN_USERLIB	:= cUsuario
					MsUnlock()
				EndIf
				nRec := SGN->(RecNo())
				dbSkip()
			EndDo
			SGN->(dbSetOrder(1))
			dbSeek(xFilial("SGN")+cTipoDoc+cDocto+cAuxNivel)
			While !Eof() .And. xFilial("SGN")+cTipoDoc+cDocto == SGN->(GN_FILIAL+GN_TIPO+GN_NUM)
				If cAuxNivel == SGN->GN_NIVEL .And. SGN->GN_STATUS != "03" .And. SGN->GN_TIPOLIB $ "U"
					lRetorno := .F.
					Exit
				EndIf
				If cAuxNivel == SGN->GN_NIVEL .And. SGN->GN_STATUS != "03" .And. SGN->GN_TIPOLIB $ "NE"
					Reclock("SGN",.F.)
					SGN->GN_STATUS	:= "05"
					SGN->GN_DATALIB	:= dDataLib
					SGN->GN_USERLIB	:= SGM->GM_USER
					SGN->GN_OBS		:= STR0026+" "+AllTrim(UsrRetName(SGM->GM_USER)) +"." //Aprovado pelo usurio
					MsUnlock()
				EndIf
				If SGN->GN_NIVEL > cAuxNivel .And. SGN->GN_STATUS != "03" .And. !lAchou
					lAchou := .T.
					cNextNiv := SGN->GN_NIVEL
				EndIf
				If lAchou .And. SGN->GN_NIVEL == cNextNiv .And. SGN->GN_STATUS != "03"
					Reclock("SGN",.F.)
					SGN->GN_STATUS := If(SGM->GM_TPLIBER=="E","05",;
						If(( Empty(cNivIgual) .Or. cNivIgual == GN_NIVEL ) .And. cStatusAnt <> "01" ,"02",GN_STATUS))
					If SGN->GN_STATUS == "05"
						SGN->GN_DATALIB	:= dDataLib
					EndIf
					MsUnlock()
					cNivIgual := GN_NIVEL
					lAchou    := .F.
				Endif
				cStatusAnt := SGN->GN_STATUS
				dbSkip()
			EndDo
			//Ŀ
			// Reposiciona e verifica se ja esta totalmente liberado.       
			//
			If !Empty(nRec)
				dbGoto(nRec)
				If lRetorno
					While !Eof() .And. xFilial("SGN")+cTipoDoc+cDocto == SGN->(GN_FILIAL+GN_TIPO+GN_NUM)
						If SGN->GN_STATUS != "03" .And. SGN->GN_STATUS != "05"
							lRetorno := .F.
						EndIf
						dbSkip()
					EndDo
				EndIf
			EndIf
		Case nOper == 6 //Bloqueio manual
			dbSelectArea("SGN")
			dbSetOrder(1)
			dbSeek(xFilial("SGN")+cTipoDoc+cDocto+cAuxNivel)

			If !lAutomacao
				Reclock("SGN",.F.)
				GN_STATUS   := "07"
				GN_OBS	    := If(Len(aDocto)>4,aDocto[5],"")
				GN_DATALIB  := dDataRef
				GN_USERLIB	:= cUsuario
				cAuxNivel   := GN_NIVEL
				MsUnlock()
			EndIf
			lRetorno 	:= .F.

			//Ŀ
			// Bloqueia todos os Aprovadores do Nvel  
			//
			nRec := RecNo()

			While !Eof() .And. xFilial("SGN")+cTipoDoc+cDocto+cAuxNivel == SGN->(GN_FILIAL+GN_TIPO+GN_NUM+GN_NIVEL)
				If SGN->GN_STATUS != "07"
					Reclock("SGN",.F.)
					SGN->GN_STATUS	:= "08"
					SGN->GN_OBS	    := STR0027+AllTrim(UsrRetName(cUsuario)) +"." //Bloqueado pelo usurio
					SGN->GN_DATALIB	:= dDataRef
					SGN->GN_USERLIB	:= cUsuario
					MsUnlock()
				EndIf
				dbSkip()
			EndDo
	EndCase
	If ExistBlock("MTALCDOC")
		Execblock("MTALCDOC",.F.,.F.,{aDocto,dDataRef,nOper})
	Endif
EndIf

RestArea(aAreaSGN)
RestArea(aArea)

Return(lRetorno)

/*/

Ŀ
Funo    GrpEng 	 Autor  Rodrigo Toledo         Data  18.11.10 
Ĵ
Descrio  Retorna se o usuario possui ao menos um grupo de engenharia
Ĵ
Parametros ExpC1 = Codigo do usuario.                				  
			  ExpC2 = Codigo do engenheiro.               				  
Ĵ
Retorno    Achou = .T. / .F.                                          
Ĵ
Uso        Generico.                                                  
ٱ


/*/
Function GrpEng(cCodUsu,cCodEng)
Local aArea    	:= GetArea()
Local lAchou	:= .F.
Local cGrupo	:= ""
Local nRecno	:= 0
cCodEng := IIF(Empty(cCodEng),RetCodUsr(),cCodEng)

dbSelectArea("SGL")
dbSetOrder(2)
dbSeek(xFilial("SGL")+cCodUsu)
While !Eof() .And. SGL->GL_USER == cCodUsu
	cGrupo := SGL->GL_COD
	nRecno := SGL->(Recno())
	dbSelectArea("SGL")
	dbSetOrder(1)
	dbSeek(xFilial("SGL")+cGrupo)
	While !Eof() .And. SGL->GL_COD == cGrupo
		If SGL->GL_USER == cCodEng
			lAchou := .T.
		EndIf
		SGL->(dbSkip())
	End
	If lAchou
		Exit
	EndIf
	SGL->(dbSetOrder(2))
	SGL->(dbGoto(nRecno))
	SGL->(dbSkip())
End

RestArea(aArea)
Return lAchou

/*


ͻ
Programa   PCPLOAD  Autor  Leonardo Quintania   Data   04/01/2012 
͹
Descricao  Funcao executada na entrada do modulo SIGAPCP.             
͹
Uso        SIGAPCP													  
ͼ


*/
Function PCPLOAD()

//Ŀ
// Realiza Bloqueio automatico de Inventario com base no parametro MV_BLQINVA 
//
MATA271(.T.)

Return

/*


ͻ
Programa   PCPINITFUN Autor   TOTVS S/A         Data   21/01/2014 
͹
Desc.     Executa as funcoes de inicializacao do modulo de compras    
͹
Uso        SIGAPCP                                                    
ͼ


*/
Function PCPINITFUN()

//Ŀ
// MA215CHECK - Funcao utilizada para verificar se no momento da abertura  |
//              do modulo existem tabelas exclusivas abertas pela rotina   |
//|              MATA215 ou por outro processo.                             |
//
MA215CHECK()

Return

/*/

Ŀ
Funo     CusFabItem    Autor  Andre Anjos           Data   20/12/12 
Ĵ
Descrio  Retorna o custo de fabricacao de um item.					  
Ĵ
Parametros cProd: codigo do produto.							    	  
           nTipo: identifica a modalidade de custo desejada:			  
           			1- Mensal (SB9 - B9_CM)								  
           			2- On-Line (SB2 - B2_CM)							  
           			3- Reposicao (SB1 - B1_CUSTD)						  
           			4- Ultima compra (SB1 - B1_UPRC)					  
Ĵ
Retorno    aRet: valores de custo divididos da seguinte forma:            
           			aRet[1]- custo material								  
           			aRet[2]- custo de preparacao (setup)				  
           			aRet[3]- custo GGF									  
ٱ


/*/
Function CusFabItem(cProd,nTipo,nQuant)
Local aRet    := {0,0,0}
Local nRecBkp := 0
Local aHoras  := {}
Local aValSub := {}

Default nQuant := 1

SB1->(dbSetOrder(1))
SB9->(dbSetOrder(1))
SB2->(dbSetOrder(1))
SG1->(dbSetOrder(1))
SG2->(dbSetOrder(1))

//-- Processa itens da estrutura
If SG1->(dbSeek(xFilial("SG1")+cProd))
	While !SG1->(EOF()) .And. SG1->(G1_FILIAL+G1_COD) == xFilial("SG1")+cProd
		nQuantComp := ExplEstr(nQuant)

		//-- Soma custo do material (se materia prima)
		If nQuantComp > 0
			SB1->(dbSeek(xFilial("SB1")+SG1->G1_COMP))
			nRecBkp := SG1->(Recno())
			If !SG1->(dbSeek(xFilial("SG1")+SG1->G1_COMP))
				Do Case
					Case nTipo == 1
						SB9->(dbSeek(xFilial("SB9")+SB1->(B1_COD+B1_LOCPAD)+Replicate("z",8),.T.))
						SB9->(dbSkip(-1))
						If SB9->(B9_FILIAL+B9_COD) == xFilial("SB9")+SB1->B1_COD
							aRet[1] += nQuantComp * SB9->B9_CM1
						EndIf
					Case nTipo == 2 .or. nTipo == 5 //online ou offline
						If SB2->(dbSeek(xFilial("SB2")+SB1->(B1_COD+B1_LOCPAD)))
							aRet[1] += nQuantComp * SB2->B2_CM1
						EndIf
					Case nTipo == 3
						aRet[1] += nQuantComp * xMoeda(RetFldProd(SB1->B1_COD,"B1_CUSTD"),Val(RetFldProd(SB1->B1_COD,"SB1->B1_MCUSTD")),1,RetFldProd(SB1->B1_COD,"B1_UCALSTD"),2)
					Case nTipo == 4
						aRet[1] += nQuantComp * RetFldProd(SB1->B1_COD,"B1_UPRC")
				EndCase
			Else
				//-- Faz chamada recursiva se fabricado para obter custos dos filhos
				aValSub := CusFabItem(SG1->G1_COD,nTipo,nQuantComp)
				aRet[1] += aValSub[1]
				aRet[2] += aValSub[2]
				aRet[3] += aValSub[3]
			EndIf
			SG1->(dbGoTo(nRecBkp))
		EndIf

		SG1->(dbSkip())
	End

	//-- Soma custo das horas de producao do item
	If SB1->B1_FANTASM <> 'S'
		aHoras := CusRoteiro(cProd,nTipo)
		aRet[2] += aHoras[1]
		aRet[3] += aHoras[2]
	EndIf
Else
	SB1->(dbSeek(xFilial("SB1")+cProd))

	//-- Soma custo do material (se materia prima)
	Do Case
		Case nTipo == 1
			SB9->(dbSeek(xFilial("SB9")+SB1->(B1_COD+B1_LOCPAD)+Replicate("z",8),.T.))
			SB9->(dbSkip(-1))
			If SB9->(B9_FILIAL+B9_COD) == xFilial("SB9")+SB1->B1_COD
				aRet[1] += SB9->B9_CM1
			EndIf
		Case nTipo == 2 .or. nTipo == 5 //online ou offline
			If SB2->(dbSeek(xFilial("SB2")+SB1->(B1_COD+B1_LOCPAD)))
				aRet[1] += SB2->B2_CM1
			EndIf
		Case nTipo == 3
			aRet[1] += xMoeda(RetFldProd(SB1->B1_COD,"B1_CUSTD"),Val(RetFldProd(SB1->B1_COD,"SB1->B1_MCUSTD")),1,RetFldProd(SB1->B1_COD,"B1_UCALSTD"),2)
		Case nTipo == 4
			aRet[1] += RetFldProd(SB1->B1_COD,"B1_UPRC")
	EndCase
EndIf

Return aRet

/*/

Ŀ
Funo     CusRoteiro    Autor  Andre Anjos           Data   20/12/12 
Ĵ
Descrio  Retorna os custos (preparacao e operacao) de fabricacao de um  
           item (unitario) considerando-se seu roteiro padrao.			  
Ĵ
Parametros cProduto: codigo do produto.									  
Ĵ
Retorno    aRet: quantidade de horas gastas na fabricacao				  
           		aRet[1]: custo das horas de preparacao.					  
           		aRet[2]: custo das horas de operacao.					  
ٱ


/*/
Static Function CusRoteiro(cProduto,nTipo)
Local nOperTot := 0
Local nPrepTot := 0
Local nHrsOper := 0
Local nHrsPrep := 0
Local nQuant   := 1
Local nQtdeAux := 0
Local nCustoUn := 0
Local cRoteiro := A650VldRot(cProduto,If(Empty(SB1->B1_OPERPAD),"01",SB1->B1_OPERPAD))

PRIVATE nPrecisao := SuperGetMV("MV_PRECISA",.F.,4)
PRIVATE lCusFil   := SuperGetMV("MV_CUSFIL",.F.,"A") == "F"
PRIVATE lCusEmp	  := SuperGetMv("MV_CUSFIL",.F.,"A") == "E"
PRIVATE dInicio   := SuperGetMV("MV_ULMES",.F.,SToD("19970101"))+1
PRIVATE lBat 	  := .T.
PRIVATE lOpenTRT  := .F.

SH7->(dbSetOrder(1))
SH1->(dbSetOrder(1))

SG2->(dbSetOrder(1))
SG2->(dbSeek(xFilial("SG2")+cProduto+cRoteiro))
While !SG2->(EOF()) .And. SG2->(G2_FILIAL+G2_PRODUTO+G2_CODIGO) == xFilial("SG2")+cProduto+cRoteiro
	//-- Posiciona recurso
	SH1->(dbSeek(xFilial("SH1")+SG2->G2_RECURSO))

	//-- Calcula tempo de duracao baseado no Tipo de Operacao
	If SG2->G2_TPOPER $ " 1"
		nHrsOper := Round(nQuant*(If(Empty(A690HoraCt(SG2->G2_TEMPAD)),1,A690HoraCt(SG2->G2_TEMPAD))/If(Empty(SG2->G2_LOTEPAD),1,SG2->G2_LOTEPAD)),5)
		If SH1->H1_MAOOBRA # 0
			nHrsOper := Round(nHrsOper/SH1->H1_MAOOBRA,5)
		EndIf
	ElseIf SG2->G2_TPOPER == "4"
		nQtdeAux := nQuant % If(Empty(SG2->G2_LOTEPAD),1,SG2->G2_LOTEPAD)
		nQtdeAux := Int(nQuant) + If(nQtdeAux > 0,If(Empty(SG2->G2_LOTEPAD),1,SG2->G2_LOTEPAD) - nQtdeAux,0)
		nHrsOper := Round(nQtdeAux * (If(Empty(A690HoraCt(SG2->G2_TEMPAD)),1,A690HoraCt(SG2->G2_TEMPAD)) / If(Empty(SG2->G2_LOTEPAD),1,SG2->G2_LOTEPAD)),5)
		If SH1->H1_MAOOBRA # 0
			nHrsOper := Round(nHrsOper/SH1->H1_MAOOBRA,5)
		EndIf
	ElseIf SG2->G2_TPOPER == "2" .Or. SG2->G2_TPOPER == "3"
		nHrsOper := If(Empty(A690HoraCt(SG2->G2_TEMPAD)),1,A690HoraCt(SG2->G2_TEMPAD))
	EndIf

	nHrsPrep := A690HoraCt(If(Empty(SG2->G2_FORMSTP),SG2->G2_SETUP,Formula(SG2->G2_FORMSTP)))	//-- Soma setup
	nHrsPrep += A690HoraCt(SG2->G2_TEMPEND)				//-- Soma tempo fim da operacao

	nCustoUn := CusUnitMOD(nTipo,SH1->H1_CODIGO,@lOpenTRT)

	//-- Acumula custo nas variaveis de retorno
	nOperTot += nHrsOper * nCustoUn
	nPrepTot += nHrsPrep * nCustoUn

	SG2->(dbSkip())
End

Return {nPrepTot,nOperTot}

/*


ͻ
Programa  CusUnitMODAutor  Microsiga            Data   02/22/13   
͹
Descricao  Retorna o custo unitario da mao de obra.                   
͹
Parametros nTipo: identifica a modalidade de custo desejada:		  
           			1- Mensal (SB9 - B9_CM)							  
           			2- On-Line (SB2 - B2_CM)						  
           			3- Reposicao (SB1 - B1_CUSTD)					  
           			4- Ultima compra (SB1 - B1_UPRC)				  
           cRecurso: cdigo do recurso da MOD.						  
ͼ


*/
Function CusUnitMOD(nTipo,cRecurso,lOpenTRT)
Local nRet 	     := 0
Local cProdMod   := PadR(APrModRec(cRecurso),TamSX3("B1_COD")[1])
Local lCusFil    := AllTrim(SuperGetMV('MV_CUSFIL' ,.F.,"A")) $ "F|E"
Local lExistProc := .F.
Local cIDProc    := EngSPS19Signature()//MT330VERIDPROC()

#IFDEF TOP
lExistProc := ExistProc(GetSPName("MAT004","19"), cIDProc) .And. ;
              ExistProc(GetSPName("MAT007","19"), cIDProc) .And. ;
              ExistProc(GetSPName("MAT009","19"), cIDProc) .And. ;
              ExistProc(GetSPName("MAT016","19"), cIDProc) .And. ;
              ExistProc(GetSPName("MAT052","19"), cIDProc) .And. ;
              ExistProc(GetSPName("MAT054","19"), cIDProc)
#ENDIF

//-- Obtem custo unitario da mao de obra
SB1->(dbSetOrder(1))
SB1->(dbSeek(xFilial("SB1")+cProdMod))

Do Case
	Case nTipo == 1 //Mensal
		SB9->(dbSeek(xFilial("SB9")+cProdMod+SB1->B1_LOCPAD+Replicate("z",8),.T.))
		SB9->(dbSkip(-1))
		If SB9->B9_COD == cProdMod
			nRet := SB9->B9_CM1
		EndIf
    Case nTipo == 3 //Reposio
			nRet := xMoeda(SB1->B1_CUSTD,Val(SB1->B1_MCUSTD),1,SB1->B1_UCALSTD,2)
	Case nTipo == 5 //Offline
		//Busca o custo dos saldos atuais.
		If SB2->(dbSeek(xFilial("SB2")+cProdMod+SB1->B1_LOCPAD))
			nRet := SB2->B2_CM1
		EndIf
    Otherwise
		//-- Faz o calculo on-line
		If lCusFil
			A330TRT(Nil,Nil,.F.,0,@lOpenTRT,lExistProc,{{.T.,cFilAnt}}) // DMANMAT01-40991 e DMANSMARTSQUAD1-28625
		EndIf
		//online, recalcula o mod.
		A330Mod(SB1->B1_COD,SB1->B1_CCCUSTO,SB1->B1_GCCUSTO)
		//Busca o custo dos saldos atuais.
		If SB2->(dbSeek(xFilial("SB2")+cProdMod+SB1->B1_LOCPAD))
			nRet := SB2->B2_CM1
		EndIf
EndCase

TRT->(dbCloseArea())
lOpenTRT := .F.

Return nRet

//-------------------------------------------------------------------------------------------------
/*/{Protheus.doc} PCPIntgPPI

Funo para verificao de integrao com o PC-Factory

@author  Lucas Konrad Frana
@version P12
@since   13/08/2015
@param 01 cTabela, Caracter, Tabela usada na integrao
@param 02 lLite  , Logic   , Retorna por referncia se est habilitado o MES LITE.
@return  lRet  - Indica se existe a integrao com o PC-Factory.
           .T. -> Integrao ativa
           .F. -> Integrao no ativa.
/*/
//-------------------------------------------------------------------------------------------------
/*

   Para realizar a integrao com o PPI:
   Parametrizar a integrao, no programa PCPA109
   A funo PCPIntgPPI()->.T./.F. ir verificar se a integrao est ativa.
   Com a integrao ativa, deve-se criar a tabela temporria para realizao dos filtros. Funo PCPTmpPPI(cTable)->Nome da temp table.
   Para realizar a comunicao, verificar os filtros parametrizados. Funo PCPFiltPPI(cTable, cValue, cPont, cTemp)-> .T./.F.
   Se a funo PCPFiltPPI retornar .T., utilizar o Adapter da mensagem que se deseja enviar para o PPI.
   Com a mensagem gerada, utilizar a funo PCPWebsPPI(cXml)->{lStatus,cMsg} para realizar o envio da mensagem.
   Aps o envio da mensagem, criar o XML fisicamente com a funo PCPXmLPPI(cStatus, cTransac, cRegist, cDtEnvio, cHrEnvio, cXml)->Nome XML,
     Esta funo j verifica o parmetro para criao do arquivo fsico na tabela SOD.
   E no final, deve criar a tabela SOF, utilizando a funo PCPCriaSOF(cTransac, cRegist, cStatus, cGeraXml, cNomeXml, cDtEnvio, cHrEnvio, cUsu, cMsgRet, cXml).

*/
Function PCPIntgPPI(cTabela, lLite)
	Local aFilInt  := Nil
	Local lRet     := .F.   
	Local nI       := 0
	Local nTotFil  := 0

	Default cTabela := Nil

	lLite := .F.

	//Verificar se a filial corrente possui cadastro da integrao com o PPI que esteja ativa.
	lRet := PCPMESHabl(cTabela,, @lLite)

	//Se a filial corrente possuir integrao, processar a integrao.
	If lRet
   		Return lRet
	EndIf

	//Para o cadastro do produto, verificar se alguma outra filial possui integrao
	If cTabela == "SB1"
		aFilInt := getFilInt()
		nTotFil := Len(aFilInt)
		lRet    := .F.

		//Se a filial corrente no possuir integrao verificar se outra filial possui integrao
		For nI := 1 To nTotFil
			//Verificar se alguma filial possui cadastro da integrao com o PPI que esteja ativa.
			lRet := PCPMESHabl(cTabela, aFilInt[nI], @lLite)
			If lRet
				Exit
			EndIf
		Next nI
		aSize(aFilInt, 0)
	EndIf

Return lRet

/*/{Protheus.doc} PCPMESHabl
Verifica se a integrao TOTVS MES est habilitada, considerando MES padro e MES Lite.

@type  Function
@author lucas.franca
@since 07/10/2024
@version P12
@param 01 cTabela , Caracter, Tabela de integrao para validao
@param 02 cFilVld , Caracter, Cdigo da filial para validao
@param 03 lMESLite, Logic   , Retorna por referncia se est habilitado o MES Lite.
@return lAtivo, Logic, Identifica se a integrao MES est habilitada
/*/
Function PCPMESHabl(cTabela, cFilVld, lMESLite)
	Local aAreaSOD  := {}
	Local cTabCache := "PADRAO"
	Local lAtivo    := .F.

	Default cFilVLd  := cFilAnt
	Default lMESLite := .F.

	If !Empty(cTabela)
		cTabCache := cTabela
	EndIf
	cTabCache += "_" + cFilVLd

	//Se tem o PE PCPXFUNPPI, no utiliza o cache
	If _lFunPPI .Or. !_oIntMESON:hasProperty(cTabCache)
		aAreaSOD := SOD->(GetArea())

		SOD->(dbSetOrder(1))
		If SOD->(dbSeek(xFilial("SOD", cFilVld)))
			//OD_ATIVO=1 - MES padro. OD_ATIVO=3 - MES LITE.
			lMESLite := !Empty(cTabela) .And. SOD->OD_ATIVO == "3" .And. cTabela $ TABELAS_MES_LITE
			lAtivo   := SOD->OD_ATIVO == "1" .Or. lMESLite
			
			If lAtivo .And. _lFunPPI
				lAtivo := ExecBlock('PCPXFUNPPI',.F.,.F.,FunName())
			EndIf
		EndIf
		
		SOD->(RestArea(aAreaSOD))
		aSize(aAreaSOD, 0)
		
		lMESLite := lMESLite .And. lAtivo
		_oIntMESON[cTabCache] := {lAtivo, lMESLite}
	EndIf

	lAtivo   := _oIntMESON[cTabCache][1]
	lMESLite := _oIntMESON[cTabCache][2]
Return lAtivo

//-------------------------------------------------------------------------------------------------
/*/{Protheus.doc} PCPWebsPPI

Funo para enviar o XML para o PCFactory

@param cXml     - Contedo do XML gerado.
@param cCaminho - Caminho do webservice (SOD->OD_CAMINHO)

@return aRet - Array com o retorno do PCFactory
         [1] Status do envio. 1 - OK, 2 - Pendente, 3 - Erro
         [2] Mensagem de retorno do PCFactory
         [3] XML enviado ao PCFactory
         [4] XML recebido do PCFactory

@author  Lucas Konrad Frana
@version P12
@since   13/08/2015
/*/
//-------------------------------------------------------------------------------------------------
Function PCPWebsPPI(cXml, cCaminho)
	Local aRet       := {"","","",""}
	Local aRetPar    := {}
	Local cError     := ""
	Local cWarning   := ""
	Local cReturn    := ""
	Local cXmlUtf8   := ""
	Local cOperation := ""
	Local aOperation := {}
	Local nPos       :=  0
	Local lMV_COPPI  := SuperGetMv("MV_COPPI",.F.,.F.)
	Default cCaminho := ""

	Static oWsPPI

	Private oRet
	Private oTXML := tXmlManager():New()

	If Empty(cCaminho)
		dbSelectArea("SOD")
		SOD->(dbSetOrder(1))
		If SOD->(dbSeek(xFilial("SOD")+"1"))
			cCaminho := AllTrim(SOD->OD_CAMINHO)
		Else
			aRet[1] := "2"
			aRet[2] := STR0005 //"No existe caminho de WebService cadastrado. Verifique os parmetros da integrao."
		EndIf
	EndIf

	If lMV_COPPI .and. oWsPPI == Nil
		oWsPPI:= TWsdlManager():New()

		If !oWsPPI:parseUrl(cCaminho)
			aRet[1] := "2"
			aRet[2] := STR0035 + STR0039 + AllToChar(oWsPPI:cError) //"No foi possvel realizar a conexo com o WebService do TOTVS MES. Favor verificar as configuraes de conexo. Erro: "
			oWsPPI := Nil
		EndIf
	EndIF

	//LOGS - Parmetro de gerao de logs, quando necessitar de maiores informaes sobre erros de conexo.
	//oWsPPI:lVerbose := .T.

	//Se j tiver o objeto instanciado, no instancia novamente.
	If lMV_COPPI // Utiliza nova conexo dos arquivos WSD
		aOperation := oWsPPI:ListOperations()
		nPos := aScan(aOperation, {|x| Upper(x[1]) == "RECEIVEMESSAGE"})
		If nPos > 0
			cOperation := aOperation[nPos][1]
		Else
			aRet[1] := "2"
			aRet[2] := STR0060 //"O link  um wsdl vlido. Porm no contm os mtodos utilizados para integrao com o TOTVS MES. Favor verificar as configuraes de conexo."
		EndIf

		If !oWsPPI:SetOperation(cOperation)
			aRet[1] := "2"
			aRet[2] := STR0059 + cOperation + STR0039 + AllToChar(oWsPPI:cError) //"No conseguiu setar a operao XXXX. Erro:"
		EndIf
	Else
		//Se j tiver o objeto instanciado, no instancia novamente.
		If Type('oWsInteg') == "O"
			oWsPPI  := oWsInteg
			aRetPar := {.T.,""}
		Else
			//Instancia o WS Client do PPI
			oWsPPI := WSPCFactory():New()

			//Carrega os parmetros do WS
			aRetPar := oWsPPI:getLinks(cCaminho)
		EndIf
	EndIf

	cXml := StrTran(cXml,CHR(129),"")
	cXml := StrTran(cXml,CHR(141),"")
	cXml := StrTran(cXml,CHR(143),"")
	cXml := StrTran(cXml,CHR(144),"")
	cXml := StrTran(cXml,CHR(157),"")

	cXmlUtf8 := EncodeUTF8(cXml)
	If cXmlUtf8 != Nil
		cXml := cXmlUtf8
	EndIf

	cXml := StrTran(cXml,CHR(129),"")
	cXml := StrTran(cXml,CHR(141),"")
	cXml := StrTran(cXml,CHR(143),"")
	cXml := StrTran(cXml,CHR(144),"")
	cXml := StrTran(cXml,CHR(157),"")

	If lMV_COPPI
		cXml := "<![CDATA[" + cXml + "]]>"

		If !oWsPPI:setValue(0,cXml)
			aRet[1] := "2"
			aRet[2] := STR0061 + STR0039 + AllToChar(oWsPPI:cError) //"No foi possvel utilizar o XML. Erro: "
			aRet[3] := cXml
		EndIf

		//Solicita Autorizao
		SOE->(dbSetOrder(1))
		If SOE->(dbSeek(xFilial("SOE")+"SEGURANCA")) .And. SOE->(ColumnPos("OE_CHAR1"))
			If !Empty(SOE->OE_CHAR1) .And. !Empty(SOE->OE_MEMO1)
				oWsPPI:AddHttpHeader( "Authorization", " Basic "+Encode64(AllTrim(SOE->OE_CHAR1)+":"+AllTrim(SOE->OE_MEMO1) ))
			EndIf
		EndIf

		//Envia a mensagem para o PPI
		If oWsPPI:SendSoapMsg()
			cReturn := oWsPPI:GetParsedResponse()
			nPos := At("<TOTVSMESSAGE", UPPER(cReturn))
			If nPos > 0
				cReturn := SubStr(cReturn, nPos)
				nPos := At("</TOTVSMESSAGE>", UPPER(cReturn))
				If nPos > 0
					cReturn := SubStr(cReturn, 1, nPos+14)
				Else
					aRet[1] := "2"
					aRet[2] := StrTran(cReturn,CHR(09)," ")
					aRet[3] := cXml
					aRet[4] := cReturn
				EndIf
			Else
				aRet[1] := "2"
				aRet[2] := StrTran(cReturn,CHR(09)," ")
				aRet[3] := cXml
				aRet[4] := cReturn
			EndIf
			//Recupera o retorno da mensagem
      		oRet := oTXML:Parse(cReturn)
		EndIf
	Else
		If aRetPar[1]
			//Envia a mensagem para o PPI
			If oWsPPI:receiveMessage(cXml)
				//Recupera o retorno da mensagem
				cReturn := EncodeUTF8(oWsPPI:creceiveMessageResult)
				oRet    := oTXML:Parse(cReturn)
			Else
				//No conectou com o WS da PPI.
				aRet[1] := "2"
				aRet[2] := STR0035 //"No foi possvel realizar a conexo com o WebService do TOTVS MES. Verifique as configuraes de conexo."
			EndIf
		Else
			//No conectou com o WS da PPI.
			aRet[1] := "2"
			aRet[2] := aRetPar[2]
		EndIf
	EndIF

	If aRet[1] == ""
		aRet[3] := cXml
		aRet[4] := cReturn
		If oRet == .T. .And. Empty(oTXML:Error()) .And. Empty(oTXML:Warning())
			//Integrao realizada com sucesso
			If ValType(oTXML:XPathGetNodeValue("/TOTVSMessage/ResponseMessage/ProcessingInformation/Status")) != "U" .And.;
			   UPPER(oTXML:XPathGetNodeValue("/TOTVSMessage/ResponseMessage/ProcessingInformation/Status")) == "OK"
				aRet[1] := "1"
				aRet[2] := "OK"
			Else
				//Ocorreu algum erro durante a integrao.
				If ValType(oTXML:XPathGetNodeValue("/TOTVSMessage/ResponseMessage/ProcessingInformation/Status")) != "U" .And.; 
				   UPPER(oTXML:XPathGetNodeValue("/TOTVSMessage/ResponseMessage/ProcessingInformation/Status")) == "ERROR"
					aRet[1] := "3"
					aRet[2] := getMessage() //Retorna o cdigo do erro: descrio do erro.
				EndIf
			EndIf
			FwFreeObj(oRet)
			oRet := Nil
		Else
			aRet[1] := "3"
			aRet[2] := STR0040 //"No foi possvel realizar o parse do XML de retorno do TOTVS MES."
		EndIf
    EndIf

	FwFreeObj(oTXML)
	oTXML := Nil

Return aRet

//-------------------------------------------------------------------------------------------------
/*/{Protheus.doc} getMessage

Retorna a mensagem de erro do PCFactory. Faz a leitura do objeto oRet, deve estar definido como Private

@return cMessage - String contendo as mensagens do PCFactory.

@author  Lucas Konrad Frana
@version P12
@since   04/09/2015
/*/
//-------------------------------------------------------------------------------------------------
Static Function getMessage()
	Local aErro    := {}
	Local cMessage := ""
	Local nI       := 0

	If ValType(oTXML:XPathGetChildArray('/TOTVSMessage/ResponseMessage/ProcessingInformation/ListOfMessages')) == "A"
		aErro := oTXML:XPathGetChildArray('/TOTVSMessage/ResponseMessage/ProcessingInformation/ListOfMessages')
		
	 	//Retornou vrias mensagens
	 	For nI := 1 To Len(aErro)	
	 	    If oTXML:XPathGetAtt(aErro[nI][2], 'code') != Nil
	 	        If AllTrim(oTXML:XPathGetAtt(aErro[nI][2], 'code')) == "9999" .And.;
	 	           AT('THE LIST OF ERRORS HAS VALUES', Upper(aErro[nI][3])) > 0
	 	        	//Se  o erro que apenas replica todos os erros da lista, no adiciona na mensagem.
	 	        	Loop
	 	        EndIf
	 	        //Adiciona uma quebra de linha
	 	        cMessage += CHR(10)
	 	        //Adiciona a mensagem.
	 	        cMessage += AllTrim(oTXML:XPathGetAtt(aErro[nI][2], 'code')) + ": " +;
	 	                    AllTrim(aErro[nI][3])
	 	    EndIf
	 	Next nI
	EndIf

	aSize(aErro, 0)
	aErro := Nil
	
Return cMessage

//-------------------------------------------------------------------------------------------------
/*/{Protheus.doc} PCPCriaSOF

Funo para criao da tabela SOF - Integrao PCP Protheus x PCFactory

@param cTransac - Nome da tabela que est sendo enviada ao PCFactory.
@param cRegist  - Cdigo do registro que est sendo enviado.
@param cStatus  - Status do envio. 1 - OK; 2 - Pendente; 3 - Erro.
@param cGeraXml - Gerou XML. 1 - Sim; 2 - No.
@param cNomeXml - Nome do arquivo XML gerado.
@param cDtEnvio - Data de envio do XML.
@param cHrEnvio - Hora de envio do XML.
@param cUsu     - Usurio que enviou o XML para o PCFactory.
@param cMsgRet  - Mensagem de retorno do PCFactory.
@param cXml     - Contedo do XML gerado.
@param lLite    - indica que  MES LITE

@author  Lucas Konrad Frana
@version P12
@since   13/08/2015
/*/
//-------------------------------------------------------------------------------------------------
Function PCPCriaSOF(cTransac, cRegist, cStatus, cGeraXml, cNomeXml, cDtEnvio, cHrEnvio, cUsu, cMsgRet, cXml, lLite)
	Local aArea      := GetArea()
	Local cAliasSOF  := GetNextAlias()
	Local cDirEnv    := ""
	Local cDiretorio := ""
	Local cDirPend   := ""
	Local cQuery     := ""
	Local cRotina    := FunName()
	Local lDelSOF    := .T.
	Local lDelSOFEst := .F.
	Local lGeraXML   := .F.
	Local lTratEsp   := .F.

	Default lLite    := .F.

	dbSelectArea("SOD")
	SOD->(dbSetOrder(1))
	If SOD->(dbSeek(xFilial("SOD"))) .And. SOD->OD_ATIVO $ "|1|3|"
		If cStatus == "1"
			cDiretorio := SOD->OD_DIRENV
		Else
			cDiretorio := SOD->OD_DIRPEND
		EndIf
		cDirEnv  := SOD->OD_DIRENV
		cDirPend := SOD->OD_DIRPEND

		If SOD->OD_GERAXML == "1"
			lGeraXML := .T.
		EndIf
	EndIf

	If AllTrim(cGeraXml) == "2"
		cNomeXml := ""
	EndIf

	If !lLite
		If ("ITEMSTOCKLEVEL" $ AllTrim(Upper(cNomeXml))) .And. (cTransac $ "SB2|SB8|SBF") .And. AllTrim(Upper(cRotina)) != "PCPA110"
			lDelSOF := .F.
		EndIf

		If ("ITEMSTOCKLEVEL" $ AllTrim(Upper(cNomeXml))) .And. (cTransac $ "SB2|SB8|SBF") .And. AllTrim(Upper(cRotina)) == "PCPA110"
			lTratEsp := .T.
		EndIf

		If ("ITEMSTOCKLEVEL" $ AllTrim(Upper(cNomeXml))) .And. (cTransac $ "SB2|SB8|SBF")
			lDelSOFEst := .T.
		EndIf
	EndIf

	If lDelSOF
		//Procura na SOF pela transao e registro
		cQuery := " SELECT R_E_C_N_O_ RECSOF "
		cQuery +=   " FROM " + RetSqlName("SOF") + " SOF "
		cQuery +=  " WHERE SOF.OF_FILIAL  = '" + xFilial("SOF") + "' "
		cQuery +=    " AND SOF.OF_TRANSAC = '" + cTransac + "' "
		cQuery +=    " AND SOF.OF_REGIST  = '" + cRegist  + "' "

		If lTratEsp //Se for via PCPA110 excluir somente aquele registro
			cQuery +=    " AND SOF.OF_DTENVIO  = '" + cDtEnvio  + "' "
			cQuery +=    " AND SOF.OF_HRENVIO  = '" + cHrEnvio  + "' "
		EndIf

		cQuery +=    " AND SOF.D_E_L_E_T_ = ' ' "

		cQuery := ChangeQuery(cQuery)

		dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasSOF,.T.,.T.)

		//Se encontrou, apaga o registro
		If !(cAliasSOF)->(Eof())
			SOF->(dbGoTo((cAliasSOF)->(RECSOF)))

			RecLock("SOF",.F.)
			SOF->(dbDelete())
			SOF->(MsUnLock())
		EndIf

		(cAliasSOF)->(dbCloseArea())
	EndIf

	//Insere o novo registro na SOF
	RecLock("SOF",.T.)
	SOF->OF_FILIAL  := xFilial("SOF")
	SOF->OF_TRANSAC := cTransac
	SOF->OF_REGIST  := cRegist
	SOF->OF_STATUS  := cStatus
	SOF->OF_GERAXML := cGeraXml
	SOF->OF_NOMEXML := cNomeXml
	SOF->OF_DTENVIO := StoD(cDtEnvio)
	SOF->OF_HRENVIO := cHrEnvio
	SOF->OF_USU     := cUsu
	SOF->OF_MSGRET  := cMsgRet
	SOF->OF_XML     := cXml
	If lLite
		SOF->OF_PROGRAM := cRotina
	Else
		SOF->OF_PROGRAM := PCPRotXml(cXml)
	EndIf

	//Se est reprocessando o arquivo, gera a data/hora de reprocessamento.
	If AllTrim(Upper(cRotina)) == "PCPA110"
		SOF->OF_DATPROC := Date()
		SOF->OF_HORPROC := Time()
	EndIf
	SOF->(MsUnLock())
	RestArea(aArea)

	If lDelSOFEst

		//Se tiver mais de um registro com o Status 1 para o registro em questo
		//Deixar o ltimo e apagar os demais
		//Os registros com status 2 deve manter para ser enviado para o MES

		//Se o status do registro processado for '2' pode apagar todos os regitros com status 1
		//Se o status do registro processado for '1' deve procurar se existe registro com status 2
		//Se no existir deve manter o ltimo registro com o status 1
		//Se existir pode apagar todos os registros com status 1
		If cStatus == '1'
			lPrimeiro := .T.

			//Procura quantidade de registros para o registro em questo com status 2
			cAliasSOF  := GetNextAlias()
			cQuery := " SELECT R_E_C_N_O_ RECNOSOF "
			cQuery +=   " FROM " + RetSqlName("SOF") + " SOF "
			cQuery +=  " WHERE SOF.OF_FILIAL  = '" + xFilial("SOF") + "' "
			cQuery +=    " AND SOF.OF_TRANSAC = '" + cTransac + "' "
			cQuery +=    " AND SOF.OF_REGIST  = '" + cRegist  + "' "
			cQuery +=    " AND SOF.OF_STATUS  <>  '1' "
			cQuery +=    " AND SOF.D_E_L_E_T_ = ' ' "

			cQuery := ChangeQuery(cQuery)
			dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasSOF,.T.,.T.)
			If !(cAliasSOF)->(Eof())
				//Se existir pode apagar todos os registros com status 1
				lPrimeiro := .F.
			EndIf
			(cAliasSOF)->(dbCloseArea())
		Else
			//Se o status do registro processado for '2' pode apagar todos os regitros com status 1
			lPrimeiro := .F.
		EndIf

		cAliasSOF  := GetNextAlias()
		cQuery := " SELECT R_E_C_N_O_ RECNOSOF "
		cQuery +=   " FROM " + RetSqlName("SOF") + " SOF "
		cQuery +=  " WHERE SOF.OF_FILIAL  = '" + xFilial("SOF") + "' "
		cQuery +=    " AND SOF.OF_TRANSAC = '" + cTransac + "' "
		cQuery +=    " AND SOF.OF_REGIST  = '" + cRegist  + "' "
		cQuery +=    " AND SOF.OF_STATUS  =  '1' "
		cQuery +=    " AND SOF.D_E_L_E_T_ = ' ' "
		cQuery +=    " ORDER BY RECNOSOF DESC "

		cQuery := ChangeQuery(cQuery)

		dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasSOF,.T.,.T.)

		//Se encontrou, apaga o registro
		While !(cAliasSOF)->(Eof())
			If lPrimeiro
				//O primeiro registro  o mais atual, ento no exclui.
				//Deve-se sempre manter o mais atual, os demais sero excludos
				lPrimeiro = .F.
			Else
				SOF->(dbGoTo((cAliasSOF)->(RECNOSOF)))

				If lGeraXML //Apagar o XML
					cNomeXml := retXmlName(SOF->OF_STATUS, SOF->OF_REGIST, DtoS(SOF->OF_DTENVIO), SOF->OF_HRENVIO, cTransac)
					If SOF->OF_STATUS == "1"
						FErase(AllTrim(cDirEnv)+cNomeXml)
					Else
						FErase(AllTrim(cDirPend)+cNomeXml)
					EndIf
				EndIf

				RecLock("SOF",.F.)
				SOF->(dbDelete())
				SOF->(MsUnLock())
			EndIf

			(cAliasSOF)->(dbSkip())
		EndDo
		(cAliasSOF)->(dbCloseArea())
	EndIf

Return

//-------------------------------------------------------------------------------------------------
/*/{Protheus.doc} PCPXmlPPI

Funo para criao arquivo fsico do XML.

@param cStatus   - Status do envio. 1 - OK; 2 - Pendente; 3 - Erro.
@param cTransac  - Nome da tabela que est sendo enviada ao PCFactory.
@param cRegist   - Cdigo do registro que est sendo enviado.
@param cDtEnvio  - Data de envio do XML.
@param cHrEnvio  - Hora de envio do XML.
@param cXml      - XML enviado.
@param lLite     - Indica que  MES LITE (usa JSON no lugar de XML)

@return cNomeXml - Retorna o nome do XML criado.

@author  Lucas Konrad Frana
@version P12
@since   14/08/2015
/*/
//-------------------------------------------------------------------------------------------------
Function PCPXmlPPI(cStatus, cTransac, cRegist, cDtEnvio, cHrEnvio, cXml, lLite)
	Local aArea      := GetArea()
	Local lGeraXML   := .F.
	Local lRet       := .T.
	Local cDiretorio := ""
	Local cDirEnv    := ""
	Local cDirPend   := ""
	Local cNomeXml   := ""
	Local cQuery     := ""
	Local cAliasSOF  := GetNextAlias()
	Local cMsg       := ""
	Local nHandle    := 0
	Local cRotina    := FunName()
	Local lDelSOF    := .T.
	Local lTratEsp   := .F.

	Default lLite := .F.

	If !lLite
		If ("ITEMSTOCKLEVEL" $ AllTrim(Upper(cXml))) .And. (cTransac $ "SB2|SB8|SBF") .And. AllTrim(Upper(cRotina)) != "PCPA110"
			lDelSOF := .F.
		EndIf

		If ("ITEMSTOCKLEVEL" $ AllTrim(Upper(cXml))) .And. (cTransac $ "SB2|SB8|SBF") .And. AllTrim(Upper(cRotina)) == "PCPA110"
			lTratEsp := .T.
		EndIf
	EndIf

	dbSelectArea("SOD")
	SOD->(dbSetOrder(1))
	If SOD->(dbSeek(xFilial("SOD"))) .And. SOD->OD_ATIVO $ "|1|3|"
		If cStatus == "1"
			cDiretorio := SOD->OD_DIRENV
		Else
			cDiretorio := SOD->OD_DIRPEND
		EndIf
		cDirEnv  := SOD->OD_DIRENV
		cDirPend := SOD->OD_DIRPEND

		If SOD->OD_GERAXML == "1"
			lGeraXML := .T.
		EndIf
	EndIf

	If lGeraXML

		//Valida se o diretrio est vlido.
		If !ExistDir(cDiretorio)
			cMsg := STR0036 + AllTrim(cDiretorio) + STR0037 //"O diretrio '" XXX "'  invlido."
			lRet := .F.
		EndIf

		If lRet
	 		If lDelSOF
				//Verifica se existe um arquivo do mesmo item com ok/pendencia/erro
				cQuery := " SELECT R_E_C_N_O_ RECSOF "
				cQuery +=   " FROM " + RetSqlName("SOF") + " SOF "
				cQuery +=  " WHERE SOF.OF_FILIAL  = '" + xFilial("SOF") + "' "
				cQuery +=    " AND SOF.OF_TRANSAC = '" + cTransac + "' "
				cQuery +=    " AND SOF.OF_REGIST  = '" + cRegist  + "' "

				If lTratEsp //Se for via PCPA110 excluir somente aquele registro
					cQuery +=    " AND SOF.OF_DTENVIO  = '" + cDtEnvio  + "' "
					cQuery +=    " AND SOF.OF_HRENVIO  = '" + cHrEnvio  + "' "
				EndIf

				cQuery +=    " AND SOF.D_E_L_E_T_ = ' ' "

				cQuery := ChangeQuery(cQuery)

				dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasSOF,.T.,.T.)
				If !(cAliasSOF)->(Eof())
					//Se existir uma pendncia, exclui o XML.
					SOF->(dbGoTo((cAliasSOF)->(RECSOF)))
					cNomeXml := retXmlName(SOF->OF_STATUS, SOF->OF_REGIST, DtoS(SOF->OF_DTENVIO), SOF->OF_HRENVIO, cTransac, lLite)
					If SOF->OF_STATUS == "1"
						FErase(AllTrim(cDirEnv)+cNomeXml)
					Else
						FErase(AllTrim(cDirPend)+cNomeXml)
					EndIf
				EndIf
				(cAliasSOF)->(dbCloseArea())
			EndIf

			//Retira barra
			cRegist:= STRTRAN(cRegist, "/", "-")

			 //Inicia criao do arquivo XML
			cNomeXml := retXmlName(cStatus, cRegist, cDtEnvio, cHrEnvio, cTransac, lLite)

			nHandle := FCreate(AllTrim(cDiretorio)+cNomeXml)

			If nHandle > -1
				FWrite(nHandle,cXml)
				FClose(nHandle)
				cMsg := cNomeXml
         	Else
				lRet := .F.
				cMsg := STR0038 + AllTrim(cDiretorio) + STR0039 + Str(FError()) //"Erro ao criar o arquivo XML no diretrio '" XXX "'. Erro: "
			EndIf
			//Fim criao do arquivo XML.
		EndIf
	EndIf
	RestArea(aArea)

Return {lRet, cMsg}

//-------------------------------------------------------------------------------------------------
/*/{Protheus.doc} retXmlName

Funo para criao arquivo fsico do XML.

@param cStatus   - Status do envio. 1 - OK; 2 - Pendente; 3 - Erro.
@param cRegist   - Cdigo do registro que est sendo enviado.
@param cDtEnvio  - Data de envio do XML.
@param cHrEnvio  - Hora de envio do XML.
@param cTransac  - Tabela que est gerando o XML.
@param lLite     - indica que  MES LITE (utiliza JSON ao invs de XML)

@return cNomeXml - Retorna o nome do XML criado.

@author  Lucas Konrad Frana
@version P12
@since   14/08/2015
/*/
//-------------------------------------------------------------------------------------------------
Static Function retXmlName(cStatus, cRegist, cDtEnvio, cHrEnvio, cTransac, lLite)
	Local cNomeXml   := ""
	Local cExtension := ".xml"

	Default lLite := .F.

	If lLite
		cExtension := ".json"
	EndIf

	cHrEnvio := StrTran(cHrEnvio,":")

	Do Case
		Case cStatus == "1"
			cNomeXml := "OK_"
		Case cStatus == "2"
			cNomeXml := "PEND_"
		Case cStatus == "3"
			cNomeXml := "ERR_"
	EndCase

	Do Case
		Case cTransac == "SB1" // Produto
			cNomeXML += "ITEM_"
		Case cTransac $ "SH1|CYB" // Recurso
			cNomeXml += "MACHINE_"
		Case cTransac == "NNR" // Local de estoque
			cNomeXml += "WAREHOUSE_"
		Case cTransac == "SC2" //Ordem de produo
			cNomeXml += "PRODUCTIONORDER_"
		Case cTransac == "SG1" //Estrutura
			cNomeXml += "ITEMSTRUCTURE_"
		Case cTransac == "SG2" //Roteiro de operaes
			cNomeXml += "ITEMSCRIPT_"
		Case cTransac == "CYH" //Recursos (cho de fbrica)
			cNomeXml += "RESOURCE_"
		Case cTransac == "SH4" //Ferramentas (PCP)
			cNomeXml += "RESOURCE_"
		Case cTransac == "SBE" //Endereo
			cNomeXml += "ADDRESSSTOCK_"
		Case cTransac == 'SB2' // Saldo Estoque
			cNomeXml += "ITEMSTOCKLEVEL_"
		Case cTransac == 'SB8' // Saldo Estoque
			cNomeXml += "ITEMSTOCKLEVEL_"
		Case cTransac == 'SBF' // Saldo Estoque
			cNomeXml += "ITEMSTOCKLEVEL_"
	EndCase
	cNomeXml += AllTrim(cDtEnvio) + AllTrim(cHrEnvio) + "_" + AllTrim(cRegist) + cExtension
Return cNomeXml

//-------------------------------------------------------------------------------------------------
/*/{Protheus.doc} PCPxDtXml

Funo para recuperar a data/hora de envio que foi registrado no XML.

@param cXml   - String com o XML enviado

@return aRet - Array com a data e hora de envio.
          [1] - Data de envio AAAAMMDD
          [2] - Hora de envio HH:MM:SS

@author  Lucas Konrad Frana
@version P12
@since   14/08/2015
/*/
//-------------------------------------------------------------------------------------------------
Function PCPxDtXml(cXml)
	Local cError     := ""
	Local cWarning   := ""
	Local aRet       := {"",""}

	Private oXml

	If Type("oTXML") == "U"
		Private oTXML := tXmlManager():New()
	EndIf
	
	cXml := PCPxForXML(cXml)

	oXml := oTXML:Parse(cXml)
	If oXml == .T. .And. Empty(oTXML:Error()) .And. Empty(oTXML:Warning())
		aDtHrEnvio := StrTokArr(oTXML:XPathGetNodeValue("/TOTVSMessage/MessageInformation/GeneratedOn"),"T")
		aRet[1]    := SubStr(aDtHrEnvio[1],1,4)+SubStr(aDtHrEnvio[1],6,2)+SubStr(aDtHrEnvio[1],9,2)
		aRet[2]    := aDtHrEnvio[2]
		FwFreeObj(oTXML)
		oTXML := Nil
	EndIf

Return aRet

//-------------------------------------------------------------------------------------------------
/*/{Protheus.doc} PCPxForXML

Funo para retirar o caracter especial & do XML.

@param cXml   - String com o XML enviado
@return cXml - String com o XML sem o caracter especial &

@author  Michele Lais Girardi
@version P12
@since   04/02/2022
/*/
//-------------------------------------------------------------------------------------------------
Function PCPxForXML(cXml)

	cXml := StrTran( cXml, "&", " " )

Return cXml

//-------------------------------------------------------------------------------------------------
/*/{Protheus.doc} PCPRotXml

Funo para recuperar a rotina que gerou o xml.

@param cXml   - String com o XML enviado

@return cRotina - Rotina que gerou o XML. Ex: MATA650

@author  Lucas Konrad Frana
@version P12
@since   24/08/2015
/*/
//-------------------------------------------------------------------------------------------------
Function PCPRotXml(cXml)
   Local cError    := ""
   Local cWarning  := ""
   Local cRotina   := ""

   Private oXml

	If Type("oTXML") == "U"
		Private oTXML := tXmlManager():New()
	EndIf

   	oXml := oTXML:Parse(cXml)
   	If oXml == .T. .And. Empty(oTXML:Error()) .And. Empty(oTXML:Warning())
   		  If ValType(oTXML:xPathGetAtt('/TOTVSMessage/MessageInformation/Product', 'name')) != "U"
	  		 cRotina := oTXML:xPathGetAtt('/TOTVSMessage/MessageInformation/Product', 'name')
      	EndIf
      	FwFreeObj(oTXML)
      	oTXML := Nil
   	EndIf

Return cRotina

//-------------------------------------------------------------------------------------------------
/*/{Protheus.doc} PCPEvntXml

Funo para recuperar o evento que foi enviado no XML

@param 01 cXml , Caracter, XML/JSON enviado na integrao
@param 02 lLite, Logic   , Indica se utiliza integrao MES LITE ou Padro.
@return cEvent - Evento do XML. upsert/delete

@author  Lucas Konrad Frana
@version P12
@since   14/08/2015
/*/
//-------------------------------------------------------------------------------------------------
Function PCPEvntXml(cXml, lLite)
	Local cError     := ""
	Local cWarning   := ""
	Local cEvent     := ""

	Private oXml
	If lLite
		cEvent := "upsert"
		If Left(cXml, 8) == "[DELETE]"
			cEvent := "delete"
		EndIf
	Else
		oXml := XmlParser(cXml, "_", @cError, @cWarning)
		If oXml != Nil .And. Empty(cError) .And. Empty(cWarning)
			If Type("oXml:_TOTVSMessage:_BusinessMessage:_BusinessEvent:_Event") != "U"
				cEvent := oXml:_TOTVSMessage:_BusinessMessage:_BusinessEvent:_Event:Text
			EndIf
			FwFreeObj(oXml)
			oXml := Nil
		EndIf
	EndIf

Return cEvent

//-------------------------------------------------------------------------------------------------
/*/{Protheus.doc} PCPFiltPPI

Funo para realizar o filtro da integrao com o PCFactory, conforme cadastros na tabela SOE.

@param cTable - Nome da tabela que ser filtrada.
@param cValue - Valor que ser adicionado no filtro
@param cPont  - Indica a forma que ser referenciado um campo.
						Exemplo: Para acessar o M->B1_COD, o parmetro cPont deve ser igual a "M".
									 Para acessar o SB1->B1_COD, o parmetro cPont deve ser igual a "SB1".
									 Quando for necessrio acessar um valor de um modelo (oModel), deve ser
									 passado o parmetro como "oModel:GetValue('?')", e a varivel oModel deve ser Private.

@return lRet - .T. se o registro ser integrado, .F. se no ser integrado.

@author  Lucas Konrad Frana
@version P12
@since   14/08/2015
/*/
//-------------------------------------------------------------------------------------------------
Function PCPFiltPPI(cTable, cValue, cPont)
	Local aArea     := GetArea()
	Local lRet      := .T.
	Local cFiltro   := ""

	//Verifica se existe algum filtro para a tabela na SOE
	dbSelectArea("SOE")
	SOE->(dbSetOrder(1))
	If SOE->(dbSeek(xFilial("SOE")+cTable))
		cFiltro := SOE->OE_FILTRO
		//Troca as aspas duplas por simples.
		cFiltro := StrTran(cFiltro,'"',"'")
	EndIf

	//Se existe algum filtro cadastrado, realiza a consulta para verificar se o item ser integrado.
	If !Empty(cFiltro)
		If ValType(cValue) == "N"
			cValue := cValToChar(cValue)
		EndIf

		cFiltro := cFiltro
		cFiltro := StrTran(cFiltro," AND "," .AND. ")
		cFiltro := StrTran(cFiltro," OR "," .OR. ")
		cFiltro := StrTran(cFiltro," ="," ==")
		cFiltro := StrTran(cFiltro,AllTrim(cTable)+"."," ")
		cFiltro := convLike(cFiltro)
		cFiltro := conTamInf(cFiltro,cTable)
		cFiltro := aJustFlds(cFiltro,cTable,cPont)
		lRet := &(cFiltro)
	EndIf
	RestArea(aArea)
Return lRet

//-------------------------------------------------------------------------------------------------
/*/{Protheus.doc} aJustFlds

Ajusta os campos da string de filtro.

@param cFiltro - Filtro que ser utilizado
@param cTable - Nome da tabela que ser filtrada.
@param cPont - Ponteiro que est sendo utilizado

@return cFiltro - Filtro com os campos corretos

@author  Lucas Konrad Frana
@version P12
@since   28/12/2016
/*/
//-------------------------------------------------------------------------------------------------
Static Function aJustFlds(cFiltro,cTable,cPont)
	Local cNome      := ""
	Local cCampo     := ""
	Local cNewCampo  := ""
	Local cNewFiltro := cFiltro
	Local nI         := 0
	Local nX         := 0
	Local aCampos    := {}

	If SubStr(cTable,1,1) == "S"
		cNome := SubStr(cTable,2,2) + "_"
	Else
		cNome := AllTrim(cTable)+"_"
	EndIf

	For nI := 1 To Len(cFiltro)
		//Encontrou um campo
		If SubStr(cFiltro, nI, Len(cNome)) == cNome
			For nX := nI To Len(cFiltro)
				If SubStr(cFiltro,nX,1) $ " ')"
					cCampo := SubStr(cFiltro, nI, nX-nI)
					//Se j processou esse campo.
					If aScan(aCampos,cCampo) > 0
						Exit
					EndIf
					//Quando existir o caracter '?' dentro do cPont, significa
					//que os valores devem ser pegos de um model.
					//Ex: oModel:GetValue('?')
					//o '?' dever ser substituido pelo nome do campo que 
					//necessrio recuperar o valor.
					//Caso no exista o '?' na cPont, utiliza ponteiro para
					//recuperar o valor do campo.
					//Ex: M->B1_COD || SB1->B1_COD
					If AT("?",cPont) > 0
						cNewCampo := StrTran(cPont,"?",AllTrim(cCampo))
					Else
						cNewCampo := AllTrim(cPont) + "->" + AllTrim(cCampo)
					EndIf
					cNewFiltro := StrTran(cNewFiltro,AllTrim(cCampo),AllTrim(cNewCampo))
					aAdd(aCampos,AllTrim(cCampo))
					Exit
				EndIf
			Next nX
		EndIf
	Next nI
Return cNewFiltro

//-------------------------------------------------------------------------------------------------
/*/{Protheus.doc} conTamInf

Ajusta o tamanho das informaes no filtro.

@param cFiltro - Filtro que ser utilizado
@param cTable - Nome da tabela que ser filtrada.

@return cFiltro - Filtro com o tamanho dos valores corrigidos.

@author  Lucas Konrad Frana
@version P12
@since   28/04/2016
/*/
//-------------------------------------------------------------------------------------------------
Static Function conTamInf(cFiltro,cTable)
	Local cNome    := ""
	Local cCampo   := ""
	Local cTipo    := ""
	Local cValor   := ""
	Local cSubs    := ""
	Local cSubsAux := ""
	Local nI       := 1
	Local nX       := 0
	Local nJ       := 0
	Local nTam     := 0
	Local lPula    := .F.

	If SubStr(cTable,1,1) == "S"
		cNome := SubStr(cTable,2,2) + "_"
	Else
		cNome := AllTrim(cTable)+"_"
	EndIf

	While nI <= Len(cFiltro)
		//Encontrou um campo
		If SubStr(cFiltro, nI, Len(cNome)) == cNome
			nTam  := 0
			cTipo := ""
			For nX := nI To Len(cFiltro)
				If SubStr(cFiltro,nX,1) == " "
					cCampo := SubStr(cFiltro, nI, nX-nI)
					//Verifica se este campo est sendo utilizando em uma instruo LIKE. Se sim, ignora este campo.
					lPula := .F.
					For nJ := nI To 1 Step -1
						If SubStr(cFiltro, nJ, 1) == " "
							If nJ > 1 .And. SubStr(cFiltro, nJ-1, 1) == " "
								Loop
							EndIf
							If nJ > 1 .And. SubStr(cFiltro, nJ-1, 1) == "$"
								lPula := .T.
							EndIf
							Exit
						EndIf
					Next nJ
					If lPula
						Exit
					EndIf
					aRet   := TamSX3(AllTrim(cCampo))
					If Len(aRet) > 0
						nTam   := aRet[1]
						cTipo  := aRet[3]
					EndIf
					Exit
				EndIf
			Next nX
			If cTipo == "C"
				//Se  do tipo Char, busca o valor que est no filtro para corrigir o tamanho.
				cValor := ""
				For nX := nI To Len(cFiltro)
					If SubStr(cFiltro,nX,1) == "'"
						For nJ := nX+1 To Len(cFiltro)
							If SubStr(cFiltro,nJ,1) == "'"
								cValor := SubStr(cFiltro,nX+1,nJ-nX-1)
								Exit
							EndIf
						Next nJ
						Exit
					EndIf
				Next nX
				If !Empty(cValor)
					cSubs := SubStr(cFiltro,nI, nJ-nI+1)
					cSubsAux := cSubs
					cSubs := StrTran(cSubs,"'"+cValor+"'","'"+PadR(cValor,nTam)+"'")
					cFiltro := StrTran(cFiltro,cSubsAux,cSubs)
				EndIf
			ElseIf cTipo == "D"
				//Se  do tipo Data, busca o valor que est no filtro para adicionar a funo StoD()
				cValor := ""
				For nX := nI To Len(cFiltro)
					If SubStr(cFiltro,nX,1) == "'"
						For nJ := nX+1 To Len(cFiltro)
							If SubStr(cFiltro,nJ,1) == "'"
								cValor := SubStr(cFiltro,nX+1,nJ-nX-1)
								Exit
							EndIf
						Next nJ
						Exit
					EndIf
				Next nX
				If !Empty(cValor)
					cSubs := SubStr(cFiltro,nI, nJ-nI+1)
					cSubsAux := cSubs
					cSubs := StrTran(cSubs,"'"+cValor+"'","StoD('"+cValor+"')")
					cFiltro := StrTran(cFiltro,cSubsAux,cSubs)
				EndIf
			EndIf
		EndIf
		nI ++
	EndDo

Return cFiltro

//-------------------------------------------------------------------------------------------------
/*/{Protheus.doc} convLike

Converte as expresses "Like" do SQL para expresses em ADVPL, para ser utilizado do dbSetFilter

@param cFiltro - Filtro que ser utilizado

@return cFiltro - Filtro convertido

@author  Lucas Konrad Frana
@version P12
@since   28/04/2016
/*/
//-------------------------------------------------------------------------------------------------
Static Function convLike(cFiltro)
	Local nI      := 1
	Local nX      := 1
	Local cCampo  := ""
	Local cExpres := ""
	Local cAux    := ""

	While AT("NOT LIKE",cFiltro) > 0
		cCampo  := ""
		cExpres := ""
		For nI := AT("NOT LIKE",cFiltro)-2 To 1 Step -1
			//Encontra o campo que foi feito o NOT LIKE, para fazer a inverso.
			//Ex: B1_COD NOT LIKE '%ABC%' deve ser transformado em ! 'ABC' $ B1_COD
			If SubStr(cFiltro,nI,1) == " "
			   cCampo := SubStr(cFiltro, nI, AT("NOT LIKE",cFiltro)-nI)
			   Exit
			EndIf
		Next nI
		If !Empty(cCampo)
			//Encontra o valor da expresso
			For nI := AT("NOT LIKE",cFiltro) To Len(cFiltro)
				If SubStr(cFiltro, nI, 2) == "'%"
					For nX := nI To Len(cFiltro)
						If SubStr(cFiltro, nX, 2) == "%'"
							cExpres := SubStr(cFiltro, nI+2, nX-nI-2)
							Exit
						EndIf
					Next nX
					Exit
				EndIf
			Next nI
			If !Empty(cExpres)
				cAux := " ! '" + cExpres + "' $ " + cCampo
				cFiltro := StrTran(cFiltro,cCampo + "NOT LIKE '%"+cExpres+"%'",cAux)
			EndIf
		EndIf
	EndDo
	While AT("LIKE",cFiltro) > 0
		cCampo  := ""
		cExpres := ""
		For nI := AT("LIKE",cFiltro)-2 To 1 Step -1
			//Encontra o campo que foi feito o NOT LIKE, para fazer a inverso.
			//Ex: B1_COD LIKE '%ABC%' deve ser transformado em 'ABC' $ B1_COD
			If SubStr(cFiltro,nI,1) == " "
			   cCampo := SubStr(cFiltro, nI, AT("LIKE",cFiltro)-nI)
			   Exit
			EndIf
		Next nI
		If !Empty(cCampo)
			//Encontra o valor da expresso
			For nI := AT("LIKE",cFiltro) To Len(cFiltro)
				If SubStr(cFiltro, nI, 2) == "'%"
					For nX := nI To Len(cFiltro)
						If SubStr(cFiltro, nX, 2) == "%'"
							cExpres := SubStr(cFiltro, nI+2, nX-nI-2)
							Exit
						EndIf
					Next nX
					Exit
				EndIf
			Next nI
			If !Empty(cExpres)
				cAux := " '" + cExpres + "' $ " + cCampo
				cFiltro := StrTran(cFiltro,cCampo + "LIKE '%"+cExpres+"%'",cAux)
			EndIf
		EndIf
	EndDo
Return cFiltro

//-------------------------------------------------------------------------------------------------
/*/{Protheus.doc} getStrVal

Retorna um valor em formato de string para adicionar no SQL Insert

@param uValue - Valor que ser formatado para string
@param cTipo  - Tipo de dado cadastrado no SX3

@return cValue -> valor formatado em string.

@author  Lucas Konrad Frana
@version P12
@since   01/09/2015
/*/
//-------------------------------------------------------------------------------------------------
Static Function getStrVal(uValue, cTipo)
   Local cValue := "''"

   Do Case
      Case cTipo == "C"
         If ValType(uValue) != "C" .Or. Empty(uValue)
            uValue := " "
         EndIf
         cValue := "'" + uValue + "'"
      Case cTipo == "N"
         If ValType(uValue) != "N" .Or. Empty(uValue)
            uValue := 0
         EndIf
         cValue := cValToChar(uValue)
      Case cTipo == "D"
         If (ValType(uValue) != "N" .And. ValType(uValue) != "D") .Or. Empty(uValue)
            uValue := StoD('19000101')
         EndIf
         If ValType(uValue) == "D"
            cValue := "StoD('"+DtoS(uValue)+"')"
         Else
            If ValType(uValue) == "N"
               cValue := "StoD('"+cValToChar(uValue)+"')"
            Else
               cValue := "'" + uValue + "'"
            EndIf
         EndIf
      Case cTipo == "L"
         If ValType(uValue) != "L" .Or. Empty(uValue)
            uValue := .F.
         EndIf
         If uValue
            cValue := ".T."
         Else
            cValue := ".F."
         EndIf
      Otherwise
         cValue := "'" + uValue + "'"
   End

Return cValue

//-------------------------------------------------------------------------------------------------
/*/{Protheus.doc} PCPRetTmp

Volta o nome da tabela temporria na varivel cTmpPPI

@param cProgram - Programa que est executando a integrao
@param cTemp    - Nome da tabela temporria anterior

@author  Lucas Konrad Frana
@version P12
@since   29/10/2015
/*/
//-------------------------------------------------------------------------------------------------
Function PCPRetTmp(cPrograma, cTemp)

   If FunName() != cPrograma
      If Type('cTmpPPI') == "C"
         If Select(cTmpPPI) >= 0
            TCDelFile(cTmpPPI)
         EndIf
         If AllTrim(cTmpPPI) != AllTrim(cTemp)
            cTmpPPI := cTemp
         Else
            cTmpPPI := Nil
         EndIf
      EndIf
   EndIf
Return

//-------------------------------------------------------------------------------------------------
/*/{Protheus.doc} PCPGtSeqOG

Busca uma sequncia para utilizao na incluso da tabela SOG.

@param cTransac  - Indica a transao da tabela SOG
@param cRecurso  - Recurso da tabela SOG
@param cOp        - Ordem de produo da tabela SOG
@param cProduto  - Cdigo do produto da tabela SOG
@param nQuant    - Quantidade da tabela SOG
@param dDtApont  - Data inicial de apontamento da tabela SOG
@param cHrApont  - Hora inicial de apontamento da tabela SOG
@param dDtFApont - Data final de apontamento da tabela SOG
@param cHrFApont - Hora final de apontamento da tabela SOG
@param cStatus   - Status da tabela SOG
@param cOperac   - Operao de apontamento da tabela SOG

@return nSeq - Sequncia que ser utilizada

@author  Lucas Konrad Frana
@version P11
@since   26/11/2015
/*/
//-------------------------------------------------------------------------------------------------
Function PCPGtSeqOG(cTransac, cRecurso, cOp, cProduto, nQuant, dDtApont, cHrApont, dDtFApont, cHrFApont, cStatus, cOperac, dData, cHora)
   Local aBkpArea  := GetArea()
   Local cAliasQry := GetNextAlias()
   Local cQuery    := ""
   Local nSeq      := 0  
   
   Default cHora  := ""
   Default dData  := StoD("")
   
   cOperac := PadR(cOperac,TamSX3("OG_OPERAC")[1])

   cQuery := " SELECT MAX(OG_SEQ) SEQUENCIA "
   cQuery +=   " FROM " + RetSqlName("SOG") + " SOG "
   cQuery +=  " WHERE SOG.OG_FILIAL  = '" + xFilial("SOG") + "' "
   cQuery +=    " AND SOG.OG_TRANSAC = '" + cTransac + "'"
   cQuery +=    " AND SOG.OG_RECURSO = '" + Iif(cRecurso==Nil,' ', cRecurso) + "'"
   cQuery +=    " AND SOG.OG_OP      = '" + Iif(cOp==Nil,' ', cOp) + "'"
   cQuery +=    " AND SOG.OG_PRODUTO = '" + Iif(cProduto==Nil,' ',cProduto) + "'"
   cQuery +=    " AND SOG.OG_QUANTID = "  + Iif(nQuant==Nil,'0',cValToChar(nQuant))
   cQuery +=    " AND SOG.OG_DTAPONT = '" + Iif(dDtApont==Nil,' ',DtoS(dDtApont)) + "'"
   cQuery +=    " AND SOG.OG_HRAPONT = '" + Iif(cHrApont==Nil,' ',cHrApont)+ "'"
   cQuery +=    " AND SOG.OG_DTFIMAP = '" + Iif(dDtFApont==Nil,' ',DtoS(dDtFApont)) + "'"
   cQuery +=    " AND SOG.OG_HRFIMAP = '" + Iif(cHrFApont==Nil,' ',cHrFApont) + "'"
   cQuery +=    " AND SOG.OG_STATUS  = '" + cStatus + "'"
   cQuery +=    " AND SOG.OG_OPERAC  = '" + cOperac + "'"
   
   If !Empty(dData)
      cQuery +=    " AND SOG.OG_DATA = '" + DtoS(dData) + "'"
      cQuery +=    " AND SOG.OG_HORA = '" + cHora + "'"
   EndIf 
   
   cQuery := ChangeQuery(cQuery)
   dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasQry,.T.,.T.)
   If !(cAliasQry)->(Eof())
      nSeq := (cAliasQry)->(SEQUENCIA) + 1
   Else
      nSeq := 1
   EndIf
   (cAliasQry)->(dbCloseArea())
   RestArea(aBkpArea)
Return nSeq

//-------------------------------------------------------------------------------------------------
/*/{Protheus.doc} PCPCriaSOG

Insere um novo registro na tabela SOG.

@param cTransac  - Indica a transao da tabela SOG
@param cRecurso  - Recurso da tabela SOG
@param cOp        - Ordem de produo da tabela SOG
@param cProduto  - Cdigo do produto da tabela SOG
@param nQuant    - Quantidade da tabela SOG
@param dDtApont  - Data inicial de apontamento da tabela SOG
@param cHrApont  - Hora inicial de apontamento da tabela SOG
@param dDtFApont - Data final de apontamento da tabela SOG
@param cHrFApont - Hora final de apontamento da tabela SOG
@param oRcvXml   - Objeto com o XML que foi recebido.
@param cStatus   - Status da tabela SOG
@param cEstorno  - Indica se  um registro de estorno
@param cOperac   - Operao de apontamento da tabela SOG
@param cMsg      - Mensagem que ser gravada na tabela SOG.
@param cMotv     - Cdigo do motivo de parada/refugo
@param cTpMv     - Tipo do movimento ('E'ntrada/'S'aida)
@param cPrdDst   - Cdigo do produto destino
@param cPrdOrg   - Cdigo do produto origem
@param cLocOrg   - Cdigo do local origem
@param cLocDst   - Cdigo do local destino

@author  Lucas Konrad Frana
@version P11
@since   26/11/2015
/*/
//-------------------------------------------------------------------------------------------------
Function PCPCriaSOG(cTransac, cRecurso, cOp, cProduto, nQuant, dDtApont, cHrApont, dDtFApont, cHrFApont, oRcvXml, cStatus, cEstorno, cOperac, cMsg, cMotv, cTpMv, cPrdDst, cPrdOrg, cLocOrg, cLocDst, cIdMes)

   Local aTamSX3 :={}
   Local cHora   := ""
   Local dData   := StoD("")
   Local nDecSOG := 0  
   Local nSeq    := 0
   Local nTry    := 0
   
   Default cOp       := ''
   Default cProduto  := ''
   Default cRecurso  := ''
   Default nQuant    := 0
   
   Default dDtApont  := StoD("")
   Default cHrApont  := ""
   Default dDtFApont := StoD("")
   Default cHrFApont := ""
   Default cStatus   := '1'
   Default cEstorno  := '1'
   Default cOperac   := ''
   Default cMsg      := 'OK'
   Default cMotv     := ""
   Default cTpMv     := ""
   Default cPrdDst   := ""
   Default cPrdOrg   := ""
   Default cLocOrg   := ""
   Default cLocDst   := ""
   Default cIdMes    := ""

   //Utiliza semforo para no incluir registros com chave duplicada na tabela SOG, quando receber vrias mensagens iguais.
   nTry := 0
   While !LockByName("INSERTSOG"+cEmpAnt+cFilAnt,.T.,.T.)
      nTry++
      If nTry > 1000
      	//Conout("Excedeu o limite de tentativas (1000) para travar a tabela SOG e inserir os dados.")
      	Return
      EndIf
      //Conout("Tentativa " + cValToChar(nTry) + " para gravar a tabela SOG.")
      Sleep(100)
   End
    
   aTamSX3:=TamSX3("OG_QUANTID")
   nDecSOG:=aTamSX3[2]

   nQuant:= Round(nQuant,nDecSOG)

   dData := Date()
   cHora := Time()

   //Utiliza semforo para no incluir registros com chave duplicada na tabela SOG, quando receber vrias mensagens iguais.
   //If LockByName("INSERTSOG"+cEmpAnt+cFilAnt,.T.,.T.)
      nSeq := PCPGtSeqOG(cTransac, cRecurso, cOp, cProduto, nQuant, dDtApont, cHrApont, dDtFApont, cHrFApont, cStatus, cOperac, dData, cHora)

      RecLock("SOG",.T.)
      SOG->OG_FILIAL  := xFilial("SOG")
      SOG->OG_TRANSAC := cTransac
      SOG->OG_RECURSO := cRecurso
      SOG->OG_OP      := cOp
      SOG->OG_PRODUTO := cProduto
      SOG->OG_QUANTID := nQuant
      SOG->OG_DTAPONT := dDtApont
      SOG->OG_HRAPONT := cHrApont
      SOG->OG_DTFIMAP := dDtFApont
      SOG->OG_HRFIMAP := cHrFApont
      SOG->OG_DATA    := dData
      SOG->OG_HORA    := cHora
      SOG->OG_XML     := XMLSaveStr(oRcvXml)
      SOG->OG_OPERAC  := cOperac
      SOG->OG_MSGRET  := cMsg
      SOG->OG_STATUS  := cStatus
      SOG->OG_ESTORNO := cEstorno
      SOG->OG_SEQ     := nSeq
      SOG->OG_MOTIVO  := cMotv
      SOG->OG_TPMV    := cTpMv
      SOG->OG_PRODST  := cPrdDst
      SOG->OG_PROORG  := cPrdOrg
      SOG->OG_LOCORG  := cLocOrg
      SOG->OG_LOCDST  := cLocDst
      SOG->OG_IDMES   := cIdMes
      MsUnlock()
      UnLockByName("INSERTSOG"+cEmpAnt+cFilAnt,.T.,.T.)
   //EndIf

Return Nil

//-------------------------------------------------------------------------------------------------
/*/{Protheus.doc} PCPAtuSOH

Funo para Inserir/Atualizar registros na tabela SOH

@param cTransac	- Transao que est sendo executada.
@param cIdMes		- ID do TOTVS MES.
@param cMsg		- Mensagem de retorno do Protheus
@param cStatus	- Status da integrao ('0' - Processando, '1' - OK, '2' - Erro)

@return Nil

@author  Lucas Konrad Frana
@version P11
@since   10/08/2016
/*/
//-------------------------------------------------------------------------------------------------
Function PCPAtuSOH(cTransac, cIdMes, cMsg, cStatus)
Default cMsg     := ""
Default cStatus  := "0"
Default lAutomacao := .F.

cIdMes := PadR(cIdMes, TamSX3("OH_IDMES")[1])


dbSelectArea("SOH")
SOH->(dbSetOrder(1))
If SOH->(dbSeek(xFilial("SOH")+cIdMes))
	//Atualiza o registro
	If !lAutomacao
		RecLock("SOH",.F.)
			SOH->OH_MSG    := cMsg
			SOH->OH_STATUS := cStatus
		SOH->(MsUnLock())
	EndIf
Else
	//Inclui o registro
	RecLock("SOH",.T.)
		SOH->OH_FILIAL  := xFilial("SOH")
		SOH->OH_TRANSAC := cTransac
		SOH->OH_IDMES   := cIdMes
		SOH->OH_MSG     := cMsg
		SOH->OH_STATUS  := cStatus
		If cStatus == "0"
			//Grava a data/hora de incio do processamento
			SOH->OH_DATA := DATE()
			SOH->OH_HORA := Time()
		EndIf
	SOH->(MsUnLock())
EndIf

Return

//-------------------------------------------------------------------------------------------------
/*/{Protheus.doc} PCPVldIMes

Valida se  permitido executar a integrao TOTVS MES com o ID informado na mensagem.

@param cIdMes			- ID do TOTVS MES.
@param cMsg			- Mensagem de retorno. Passar por referncia (@cMsg)
@param cStatus		- Status do processamento (0=Em processamento;1=Ok;2=Erro). Passar por referncia (@cStatus)
@param lReprocess	- Identifica se o registro dever ser processado novamente, caso tenha sido processando anteriormente com erro.

@return lRet			- Identifica se a integrao ser executada ou no.

@author  Lucas Konrad Frana
@version P11
@since   10/08/2016
/*/
//-------------------------------------------------------------------------------------------------
Function PCPVldIMes(cIdMes, cMsg, cStatus,lReprocess)
Local lRet := .T.

Default lReprocess := .F.

dbSelectArea("SOH")
SOH->(dbSetOrder(1))
If SOH->(dbSeek(xFilial("SOH")+PadR(cIdMes,TamSX3("OH_IDMES")[1])))
	cStatus := SOH->OH_STATUS
	If SOH->OH_STATUS == "0"
		cMsg := "ID " + AllTrim(cIdMes) + STR0043 //" est sendo processado pelo Protheus."
		lRet := .F.
	ElseIf SOH->OH_STATUS == "1"
		cMsg := "ID " + AllTrim(cIdMes) + STR0044 + AllTrim(SOH->OH_MSG) //" j processado. Status: "
		lRet := .F.
	ElseIf SOH->OH_STATUS == "2"
		If lReprocess
			lRet := .T.
		Else
			cMsg := "ID " + AllTrim(cIdMes) + STR0044 + AllTrim(SOH->OH_MSG) //" j processado. Status: "
			lRet := .F.
		EndIf
	EndIf
Else
	lReprocess := .F.
EndIf
If !lRet
	lReprocess := .F.
EndIf
cMsg := StrTran(cMsg," Reprocessado.","")
Return lRet

//-------------------------------------------------------------------------------------------------
/*/{Protheus.doc} PCPIntgMRP

Busca o parmetro da integrao com o PPI Multitask para a rotina do MRP.

@return cInteg - Parmetro da integrao. 1 - No integra; 2 - Gera pendncia; 3 - Integra.

@author  Lucas Konrad Frana
@version P11
@since   27/11/2015
/*/
//-------------------------------------------------------------------------------------------------
Function PCPIntgMRP()
   Local cInteg := "1"

   dbSelectArea("SOE")
   SOE->(dbSetOrder(1))
   If SOE->(dbSeek(xFilial("SOE")+"SC2"))
      cInteg := Iif(Empty(SOE->OE_PARINTG),"1",AllTrim(SOE->OE_PARINTG))
   EndIf
Return cInteg

//-------------------------------------------------------------------------------------------------
/*/{Protheus.doc} PCPObrigat

Verifica se os campos obrigatrios foram informados.

@param cTable	- Tabela que ser verificada

@return lRet	- Indica se os campos esto vlidos.

@author  Lucas Konrad Frana
@version P11
@since   15/08/2016
/*/
//-------------------------------------------------------------------------------------------------
Function PCPObrigat(cTable)
Local lRet    := .T.
/*Local aAreaX3 := SX3->(GetArea())
Local nI      := 0

SX3->(dbSetOrder(1))
If SX3->(dbSeek(cTable))
	While SX3->(!Eof()) .And. AllTrim(SX3->X3_ARQUIVO) == AllTrim(cTable)
		If SX3->X3_CONTEXT != "V" .And. X3Obrigat(SX3->X3_CAMPO) .And. Empty(&("M->"+SX3->X3_CAMPO)) .And. X3USO(SX3->X3_USADO,10)
			If ValType(&("M->"+SX3->X3_CAMPO)) == "N" .And. &("M->"+SX3->X3_CAMPO) == Nil .Or. ValType(&("M->"+SX3->X3_CAMPO)) != "N"
				Help( ,, 'Help',, STR0041 + AllTrim(SX3->X3_CAMPO) + " - " + AllTrim(SX3->X3_DESCRIC) + STR0042 , 1, 0 ) //"Campo obrigatrio '" X3_CAMPO - X3_DESCRIC "' no informado."
				lRet := .F.
				Exit
			EndIf
		EndIf
		SX3->(dbSkip())
	End
EndIf
SX3->(RestArea(aAreaX3))*/
Return lRet

//-------------------------------------------------------------------------------------------------
/*/{Protheus.doc} PCPIntgAPS

Busca o parmetro da integrao com o PPI Multitask para a rotina do APS.

@return cInteg - Parmetro da integrao. 0 - No integra; 1 - Integra.

@author  Michelle Ramos Henriques
@version P12
@since   23/10/2017
/*/
//-------------------------------------------------------------------------------------------------
Function PCPIntgAPS()
   Local cInteg := "0"

   If SOE->(ColumnPos("OE_VAR4"))
      dbSelectArea("SOE")
      SOE->(dbSetOrder(1))
      If SOE->(dbSeek(xFilial("SOE")+"SC2"))
         cInteg := Iif(Empty(SOE->OE_VAR4),"1",AllTrim(OE_VAR4))
      EndIf
   EndIf
Return cInteg

//-------------------------------------------------------------------
/*/{Protheus.doc} PCPREVTAB
Funo para gravao do campo Reviso, se grava na SB1, SBZ ou ambas
@author  Thiago.Zoppi
@since   28/08/2018
@version P12
@param cCodPro		- Produto a ser alerado a reviso
@param cRevisao		- Reviso a ser grava no produto SBZ, SB1 ou ambos.
@return Nil

Quando as tabelas SG1 e SBZ estiverem com modo exclusivo e
MV_ARQPROD = "SBZ" - gravar reviso no campo BZ_REVATU
e alm dos parametros acima se a SB1 for exclusiva, tambm gravar
nos campos BZ_REVATU e B1_REVATU.
/*/
//-------------------------------------------------------------------
FUNCTION PCPREVTAB(cCodPro,cRevisao)
Local aArea			:= GetArea()
Local lModFilSG1	:= FWModeAccess("SG1",3)== "E"  //Filial
Local lModFilSBZ	:= FWModeAccess("SBZ",3)== "E"	//Filial
Local lModFilSB1	:= FWModeAccess("SB1",3)== "E" //Filial
Local lARQPRODBZ	:= SuperGetMV("MV_ARQPROD",.F.,"SB1") == "SBZ"
Local lRevFil		:= SuperGetMv("MV_REVFIL",.F.,.F.) // controla revisao estrutura por filial SBZ

	dbSelectArea("SBZ")
	If FieldPos("BZ_REVATU") > 0 .AND. lModFilSG1 .AND. lModFilSBZ .AND. lARQPRODBZ .and. lRevFil

		dbSelectArea("SBZ")
		aAreaSBZ:=GetArea()
		dbSetOrder(1)
		If dbSeek(xFilial("SBZ")+cCodPro)
			RecLock("SBZ",.F.)
			Replace BZ_REVATU With cRevisao
			MsUnlock()
			RestArea(aAreaSBZ)

				IF lModFilSB1
					dbSelectArea("SB1")
					aAreaSB1:=GetArea()
					dbSetOrder(1)
					If dbSeek(xFilial("SB1")+cCodPro)
						RecLock("SB1",.F.)
						Replace B1_REVATU With cRevisao
						MsUnlock()
					EndIf
					RestArea(aAreaSB1)
				EndIf

		ELSE

			dbSelectArea("SB1")
			aAreaSB1:=GetArea()
			dbSetOrder(1)
			If dbSeek(xFilial("SB1")+cCodPro)
				RecLock("SB1",.F.)
				Replace B1_REVATU With cRevisao
				MsUnlock()
			EndIf
			RestArea(aAreaSB1)

		EndIf

	ELSE

		dbSelectArea("SB1")
		aAreaSB1:=GetArea()
		dbSetOrder(1)
		If dbSeek(xFilial("SB1")+cCodPro)
			RecLock("SB1",.F.)
			Replace B1_REVATU With cRevisao
			MsUnlock()
		EndIf
		RestArea(aAreaSB1)

	EndIf
RestArea(aArea)
RETURN

//-------------------------------------------------------------------
/*/{Protheus.doc} PCPREVATU
Funo que retorna a revisao do produto.
@author  Thiago.Zoppi
@since   28/08/2018
@version P12
@param cCodPro		- Produto a ser alerado a reviso
@return cRevisao	- Reviso dp produto
/*/
//-------------------------------------------------------------------
FUNCTION PCPREVATU(cCodPro)
Local aArea			:= GetArea()
Local aAreaSB1		:= SB1->(GetArea())
Local aAreaSBZ		:= SBZ->(GetArea())
Local cDadosProd	:= SuperGetMV("MV_ARQPROD",.F.,"SB1")
Local cRevisao		:= ''
Local cQuery		:= ''
Local cWhereBZ		:= ', BZ_REVATU '
Local lRevAtuCpo    := .T.
Local lRevFil		:= SuperGetMv("MV_REVFIL",.F.,.F.) // controla revisao estrutura por filial SBZ

DbSelectArea("SBZ")
If FieldPos("BZ_REVATU") < 0
	lRevAtuCpo := .F.
	cWhereBZ   := ''
EndIf

cQuery	:= "SELECT B1_COD, BZ_COD, B1_REVATU "+cWhereBZ+" "
cQuery  += " FROM "+RetSqlName('SB1')+ " SB1 "
cQuery  += " LEFT JOIN "+RetSqlName('SBZ')+ " SBZ ON (BZ_FILIAL = '"+xFilial("SBZ")+"' AND BZ_COD = B1_COD AND SBZ.D_E_L_E_T_ = ' ')"
cQuery	+= " WHERE "
cQuery	+= " SB1.B1_FILIAL = '"+xFilial("SB1")+"' AND "
cQuery	+= " SB1.B1_COD = '"+AllTrim(cCodPro)+"' AND "
cQuery	+= " SB1.D_E_L_E_T_ = ' ' "

cQuery := ChangeQuery(cQuery)
dBUseArea(.T.,"TOPCONN",TCGENQRY(,,cQuery),"QRYSBZ",.F.,.T.)

If !Empty(QRYSBZ->B1_REVATU)
	cRevisao := QRYSBZ->B1_REVATU
Else
	cRevisao :=Criavar("B1_REVATU",.F.)
EndIf

IF cDadosProd == "SBZ" .AND. lRevFil .AND. lRevAtuCpo
	If !Empty(QRYSBZ->BZ_REVATU)
		cRevisao := QRYSBZ->BZ_REVATU
	EndIf
EndIf

QRYSBZ->(DbCloseArea())

RestArea(aAreaSB1)
RestArea(aAreaSBZ)
RestArea(aArea)

RETURN cRevisao

/*

Ŀ
 Funo    Estrut    Autor  Rodrigo de A. Sartorio Data  03/08/95 
Ĵ
 Descrio Faz a explosao de uma estrutura a partir do SG1            
Ĵ
 Sintaxe   ExpA1:= Estrut(ExpC1,ExpN1,ExpL1,ExpL2)                    
Ĵ
Parametros ExpC1 = Codigo do produto a ser explodido                  
           ExpN2 = Quantidade base para explosao da estrutura         
           ExpL3 = Identifica se explode somente primeiro nivel       
           ExpL4 = Identifica se explode PRE-ESTRUTURA                
           ExpL5 = Identifica se considera produto bloqueado          
Ĵ
Observao Como e uma funcao recursiva precisa ser criada uma variavel
           private nEstru com valor 0 antes da chamada da funo.     
Ĵ
 Uso       GENERICO                                                   
ٱ

*/
Function Estrut(cProduto,nQuant,lOneLevel,lPreEstru,lPrdBlq,lCtrlRev,cRevisao)
LOCAL nRegi
LOCAL nQuantItem := 0
LOCAL cCodigo,cComponente,cTrt,cGrOpc,cOpc
Local aArea := GetArea()

DEFAULT cRevisao  := " "
DEFAULT lCtrlRev  := .F.
DEFAULT lOneLevel := .F.
DEFAULT lPreEstru := .F.
DEFAULT lPrdBlq   := .T.

nQuant:=IF(nQuant == NIL,1,nQuant)
nEstru++
If nEstru == 1
	aEstrutura:={}
EndIf

dbSelectArea(If(lPreEstru,"SGG","SG1"))
dbSetOrder(1)
dbSeek(xFilial()+cProduto)
While !Eof() .And. If(lPreEstru,GG_FILIAL+GG_COD,G1_FILIAL+G1_COD) == xFilial()+cProduto
	
	nRegi:=Recno()
	cCodigo    :=If(lPreEstru,GG_COD,G1_COD)
	cComponente:=If(lPreEstru,GG_COMP,G1_COMP)
	cTrt       :=If(lPreEstru,GG_TRT,G1_TRT)
	cGrOpc     :=If(lPreEstru,GG_GROPC,G1_GROPC)
	cOpc       :=If(lPreEstru,GG_OPC,G1_OPC)

	//Nao Considera Componentes fora da Revisao
	If lCtrlRev .And. !lPreEstru
		If  (cRevisao # Nil) .And. ;
			!(SG1->G1_REVINI <= cRevisao .And. (SG1->G1_REVFIM >= cRevisao .Or. SG1->G1_REVFIM = ' '))
			SG1->(MsGoto(nRegi))
			SG1->(dbSkip())
			Loop
		EndIf
	EndIf

	If cCodigo != cComponente

		If !lPrdBlq
			SB1->(DbSetOrder(1))
			If SB1->(DbSeek(xFilial("SB1")+cComponente))
	            If SB1->B1_MSBLQL=="1"
	            	dbSkip()
	            	Loop
	            EndIf
	        EndIf
        EndIf

		nProcura:=aScan(aEstrutura,{|x| x[1] == nEstru .And. x[2] == cCodigo .And. x[3] == cComponente .And. x[5] == cTrt})
		If nProcura  = 0
			nQuantItem:=ExplEstr(nQuant,nil,nil,nil,nil,lPreEstru)
			AADD(aEstrutura,{nEstru,cCodigo,cComponente,nQuantItem,cTrt,cGrOpc,cOpc,Recno()})
		Else
			nProcura:=aScan(aEstrutura,{|x| x[1] == nEstru .And. x[2] == cCodigo .And. x[3] == cComponente .And. x[5] == cTrt .And. x[4] == 0 })
			If nProcura > 0
				nQuantItem:=ExplEstr(nQuant,nil,nil,nil,nil,lPreEstru)
				If nQuantItem > 0
					aEstrutura[nProcura,4] := nQuantItem
					aEstrutura[nProcura,6] := cGrOpc
					aEstrutura[nProcura,7] := cOpc
					aEstrutura[nProcura,8] := Recno()
				EndIf
			EndIf
		EndIf

		//Ŀ
		// Verifica se existe sub-estrutura               
		//
		If !lOneLevel
			nRecno:=Recno()
			dbSeek(xFilial()+cComponente)
			IF Found()
				
				cCodigo:=If(lPreEstru,GG_COD,G1_COD)
				
				If lCtrlRev
					cRevisao := " "
					SB1->(DbSetOrder(1))
					If SB1->(DbSeek(xFilial("SB1")+cCodigo))
						If slPCPREVATU
							cRevisao := PCPREVATU(SB1->B1_COD)
						Else
							cRevisao := SB1->B1_REVATU
						EndIf
					EndIf
				EndIf

				Estrut(cCodigo,nQuantItem,nil,lPreEstru,lPrdBlq,lCtrlRev,cRevisao)
				nEstru --
			Else
				MsGoto(nRecno)
				nProcura:=aScan(aEstrutura,{|x| x[1] == nEstru .And. x[2] == cCodigo .And. x[3] == cComponente .And. x[5] == cTrt})
				If nProcura  = 0
					nQuantItem:=ExplEstr(nQuant,nil,nil,nil,nil,lPreEstru)
					AADD(aEstrutura,{nEstru,cCodigo,cComponente,nQuantItem,cTrt,cGrOPc,cOpc,Recno()})
				Else
					nProcura:=aScan(aEstrutura,{|x| x[1] == nEstru .And. x[2] == cCodigo .And. x[3] == cComponente .And. x[5] == cTrt .And. x[4] == 0 })
					If nProcura > 0
						nQuantItem:=ExplEstr(nQuant,nil,nil,nil,nil,lPreEstru)
						If nQuantItem > 0
							aEstrutura[nProcura,4] := nQuantItem
							aEstrutura[nProcura,6] := cGrOpc
							aEstrutura[nProcura,7] := cOpc
							aEstrutura[nProcura,8] := Recno()
						EndIf
					EndIf
				EndIf
			Endif
		EndIf
	EndIf
	MsGoto(nRegi)
	dbSkip()
Enddo
RestArea(aArea)
Return(aEstrutura)

//-------------------------------------------------------------------------------------------------
/*/{Protheus.doc} PCPVldRev

Verifica se a reviso do prduto na estrutura informada  valida

@param cProd  - Produto pai
@param cRev   - Reviso Estrutura


@return lRet - .T. - Existe Reviso; .F. No existe Reviso

@author  FABIO DAVID CORTES
@version P12
@since   17/04/2017
/*/
//-------------------------------------------------------------------------------------------------
Function PCPVldRev(cProd,cRev)
	Local cQuery    := ""
	Local aBkpArea  := GetArea()
	Local cAliasQry := GetNextAlias()
	Local lRet		:= .F.

	dbSelectArea("SG5")
	dbSetOrder(1)
	If MsSeek( xFilial("SG5")+cProd+cRev)
		If SG5->G5_MSBLQL = '1'
			lRet	 := .F.
		Else
			lRet	 := .T.
		EndIf	
	Else
		cQuery := " SELECT G1_COMP "
		cQuery += " FROM " + RetSqlName("SG1") + " SG1 "
		cQuery += " WHERE SG1.G1_FILIAL  = '" + xFilial("SG1") + "' "
		cQuery += " AND SG1.G1_COD     = '" + cProd + "'"
		cQuery += " AND '" + cRev + "' BETWEEN G1_REVINI AND G1_REVFIM "
		cQuery += " AND D_E_L_E_T_ = '' "

		cQuery := ChangeQuery(cQuery)
		dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasQry,.T.,.T.)
		If !(cAliasQry)->(Eof())
			lRet	 := .T.
		Else
			lRet	 := .F.
		EndIf
		(cAliasQry)->(dbCloseArea())
		RestArea(aBkpArea)
	EndIf

Return lRet

/*/{Protheus.doc} PCPXSldSB2
@param 01 cFilialArm, characters, indica a filial do produto a ter seu saldo pesquisado
@param 02 cProduto  , characters, indica o produto a ter seu saldo pesquisado
@param 03 cLocal    , characters, indica o armazm do produto a ter seu saldo pesquisado
@return nSaldo, numeric, saldo em estoque para o Produto e Local

@author Marcelo Neumann
@since 14/03/2019
@version 1.0
/*/
Function PCPXSldSB2(cFilialArm, cProduto, cLocal)

	Local aArea     := GetArea()
	Local cAliasSB2 := GetNextAlias()
	Local cQuerySB2 := ""
	Local nSaldo    := 0

	cQuerySB2 := "SELECT *"
	cQuerySB2 +=  " FROM " + RetSqlName("SB2")
	cQuerySB2 += " WHERE B2_FILIAL  = '" + xFilial("SB2",cFilialArm) + "'"
	cQuerySB2 +=   " AND B2_COD     = '" + cProduto + "'"
	cQuerySB2 +=   " AND B2_LOCAL   = '" + cLocal + "'"
	cQuerySB2 +=   " AND D_E_L_E_T_ = ' '"

	dbUseArea(.T., "TOPCONN", TcGenQry( , , cQuerySB2), cAliasSB2, .T., .T.)
	While (cAliasSB2)->(!Eof())
		nSaldo += SaldoSB2(/*lNecessidade*/,/*lEmpenho*/,/*dDataFim*/,/*lConsTerc*/,/*lConsNPT*/,cAliasSB2,/*nQtdEmp*/,/*nQtdPrj*/,/*lSaldoSemR*/,/*dDtRefSld*/,/*lConsEmpSA*/)
		dbSkip()
	End
	(cAliasSB2)->(dbCloseArea())

	RestArea(aArea)

Return nSaldo

/*/{Protheus.doc} PCPXLocCmp
Retorna o local de consumo (armazm) do componente:
	1. Pesquisa pelo armazm na estrutura:
		Atravs do cdigo do produto pai, componente, TRT e reviso do componente.
		Campo: G1_LOCCONS

	2. Se no possuir armazm na estrutura, pesquisa pelo armazm no centro de trabalho:
		Atravs do roteiro padro do produto pai (B1_OPERPAD)
		Checa a operao onde o componente  utilizado (SGF) ou ltima operao (SG2).
		Com a operao, identifica-se o centro de trabalho (G2_CTRAB).
		No cadastro de centro de trabalho deve-se buscar o local de consumo.
		Campo: HB_LOCAL.

	3. Se no existir armazm no centro de trabalho, pesquisar o armazm no produto.
		Campo: B1_LOCPAD

@param 01 cProd   , characters, cdigo do produto
@param 02 cComp   , characters, cdigo do componente
@param 03 cTrt    , characters, sequncia (TRT) do componente na estrutura
@param 04 cRevisao, characters, reviso a ser considerada na busca do componente
@param 05 dData   , date      , data a ser considerada na busca da verso da produo
@param 06 nQuant  , numeric   , quantidade a ser considerada na busca da verso da produo
@return aLocal, array, local de consumo do componente:
                       [1] Cdigo do local
					   [2] Indicador da Origem: 1 (Estrutura)
					                            2 (Centro de Trabalho)
												3 (Verso da Produo)
												4 (Produto)

@author Marcelo Neumann
@since 17/12/2018
@version 1.0
/*/
Function PCPXLocCmp(cProd, cComp, cTrt, cRevisao, dData, nQuant)

    Local aArea     := GetArea()
	Local aAreaSG1  := SG1->(GetArea())
	Local aAreaSG2  := SG2->(GetArea())
	Local aAreaSB1  := SB1->(GetArea())
	Local aAreaSGF  := SGF->(GetArea())
	Local aAreaSHB  := SHB->(GetArea())
	Local cAliasQry := GetNextAlias()
	Local cQuery    := ""
	Local cRotPad   := ""
	Local cOperac   := ""
	Local cCenTrab  := ""
	Local cLocal    := ""
	Local nOrigem   := 0
	Local aLocal    := {}

	Default dData   := dDataBase

	//1. Pesquisa pelo armazm na estrutura
	BeginSQL Alias cAliasQry
		SELECT SG1.G1_LOCCONS
		  FROM %Table:SG1% SG1
		 WHERE SG1.G1_FILIAL = %XFilial:SG1%
		   AND SG1.G1_COD    = %Exp:cProd%
		   AND SG1.G1_COMP   = %Exp:cComp%
		   AND SG1.G1_TRT    = %Exp:cTrt%
		   AND %Exp:cRevisao% BETWEEN SG1.G1_REVINI AND SG1.G1_REVFIM
		   AND SG1.%NotDel%
	EndSQL
	If !(cAliasQry)->(Eof())
		cLocal  := (cAliasQry)->G1_LOCCONS
		nOrigem := 1
	EndIf
	(cAliasQry)->(dbCloseArea())

	//2. Se no possuir armazm na estrutura, pesquisa pelo armazm no centro de trabalho
	If Empty(cLocal)
		//Busca o roteiro padro do produto pai
		dbSelectArea("SB1")
		SB1->(dbSetOrder(1))
		If SB1->(MsSeek(xFilial("SB1") + cProd))
			//Verifica se o roteiro existe
			dbSelectArea("SG2")
			SG2->(dbSetOrder(1))
			If SG2->(MsSeek(xFilial("SG2") + cProd + SB1->B1_OPERPAD))
				cRotPad := SB1->B1_OPERPAD
			EndIf
		EndIf

		//Se existir um roteiro padro do produto pai
		If !Empty(cRotPad)
			//Busca a operao cadastrada para o Roteiro-Produto-Componente
			dbSelectArea("SGF")
			SGF->(dbSetOrder(2))
			If SGF->(MsSeek(xFilial("SGF") + cProd + cRotPad + cComp + cTrt))
				cOperac := SGF->GF_OPERAC
			EndIf

			//Busca o Centro de Trabalho
			cQuery := "SELECT SG2.G2_CTRAB"                              + ;
					   " FROM " + RetSqlName("SG2") + " SG2"             + ;
					  " WHERE SG2.G2_FILIAL  = '" + xFilial("SG2") + "'" + ;
						" AND SG2.G2_PRODUTO = '" + cProd          + "'" + ;
						" AND SG2.G2_CODIGO  = '" + cRotPad        + "'" + ;
						" AND SG2.D_E_L_E_T_ = ' '"

			If !Empty(cOperac)
				//Se existe a amarrao na SGF, busca pela operao
				cQuery += " AND SG2.G2_OPERAC = '" + cOperac + "'"
			Else
				//Se no, busca a ltima operao
				cQuery += " ORDER BY SG2.G2_OPERAC DESC"
			EndIf
			cQuery := ChangeQuery(cQuery)

			dbUseArea(.T., "TOPCONN", TCGENQRY( , , cQuery), cAliasQry, .T., .T.)
			If (cAliasQry)->(!Eof())
				cCenTrab := (cAliasQry)->G2_CTRAB
			End
			(cAliasQry)->(dbCloseArea())

			//Se encontrou o Centro de Trabalho, busca o Local cadastrado para ele
			If !Empty(cCenTrab)
				dbSelectArea("SHB")
				SHB->(dbSetOrder(1))
				If SHB->(MsSeek(xFilial("SHB") + cCenTrab))
					cLocal  := SHB->HB_LOCAL
					nOrigem := 2
				EndIf
			EndIf
		EndIf
	EndIf

	//3. Se no existir armazm no centro de trabalho, pesquisa o armazm da verso da produo
	If Empty(cLocal)
		//Busca a Verso de Produo
		cQuery := "SELECT SVC.VC_LOCCONS"                            + ;
		           " FROM " + RetSqlName("SVC") + " SVC"             + ;
		          " WHERE SVC.VC_FILIAL  = '" + xFilial("SVC") + "'" + ;
		            " AND SVC.VC_PRODUTO = '" + cProd          + "'" + ;
		            " AND (SVC.VC_DTINI  = ' ' OR SVC.VC_DTINI <= '" + DToS(dData) + "')" + ;
		            " AND (SVC.VC_DTFIM  = ' ' OR SVC.VC_DTFIM >= '" + DToS(dData) + "')" + ;
		            " AND SVC.D_E_L_E_T_ = ' '"

		If !Empty(nQuant)
			cQuery += " AND SVC.VC_QTDDE  <= '" + cValToChar(nQuant) + "'"
			cQuery += " AND SVC.VC_QTDATE >= '" + cValToChar(nQuant) + "'"
		EndIf

		cQuery += " ORDER BY SVC.R_E_C_N_O_"
		cQuery := ChangeQuery(cQuery)

		dbUseArea(.T., "TOPCONN", TCGENQRY( , , cQuery), cAliasQry, .T., .T.)
		If (cAliasQry)->(!Eof())
			cLocal := (cAliasQry)->VC_LOCCONS
			nOrigem := 3
		End
		(cAliasQry)->(dbCloseArea())
	EndIf

	//4. Se no existir armazm na verso da produo, pesquisa o armazm no produto
	If Empty(cLocal)
		dbSelectArea("SB1")
		SB1->(dbSetOrder(1))
		If SB1->(MsSeek(xFilial("SB1") + cComp))
			cLocal  := SB1->B1_LOCPAD
			nOrigem := 4
		EndIf
	EndIf

	aAdd(aLocal, cLocal )
	aAdd(aLocal, nOrigem)

	SG1->(RestArea(aAreaSG1))
	SG2->(RestArea(aAreaSG2))
	SB1->(RestArea(aAreaSB1))
	SGF->(RestArea(aAreaSGF))
	SHB->(RestArea(aAreaSHB))
	RestArea(aArea)

Return aLocal

//-------------------------------------------------------------------
/*/{Protheus.doc} VisOpcPcp(cProduto,mOpc,cOpc,nExibeAll)
Funo que abre uma janela popup para visualizao dos opcionais.
@author Lucas Konrad Frana
@since 09/09/2014
@param cProduto - Cdigo do produto. Utilizado quando existir o mOpc
@param mOpc - Valor do memo dos opcionais, que ser transformado em um array.
@param cOpc - String concatenada com os opcionais, no formato GGGIIII/ (Grupo, Item)
@param nExibeAll - Utilizado quando existir o mOpc, indicar se sero considerados todos os opcionais (2), ou somente
        o opcional do produto passado por parmetro.
@version 1.0
@return .T.
/*/
//-------------------------------------------------------------------
Function VisOpcPcp(cProduto,mOpc,cOpc,nExibeAll)
   Local aOpc     := { }
   Local aHeader  := { }
   Local aSizes   := { }
   //Local cREPGOPC := GetMv("MV_REPGOPC")
   Local oDlg
   Local oPanel
   Local oGroup
   Local oBrowse

   Default nExibeAll := 1
   Default lAutomacao := .F.

   aOpc := aClone(ListOpc(cProduto,mOpc,cOpc,nExibeAll))

   If !Empty(mOpc)
      aAdd(aHeader,SubStr(STR0046,1,Len(STR0046)-1)) //Produto
      aAdd(aHeader,STR0047) //Descrio
      aAdd(aSizes,60)
      aAdd(aSizes,100)
      aAdd(aSizes,30)
      aAdd(aSizes,70)
      aAdd(aSizes,30)
      aAdd(aSizes,70)
   Else
      aAdd(aSizes,60)
      aAdd(aSizes,100)
      aAdd(aSizes,60)
      aAdd(aSizes,100)
   EndIf

   aAdd(aHeader,STR0048) //Grupo
   aAdd(aHeader,STR0047) //Descrio
   aAdd(aHeader,AllTrim(STR0049)) //Item
   aAdd(aHeader,STR0047) //Descrio

   If Len(aOpc) > 0

      //If cREPGOPC == "S"
      //   aSort(aOpc, , , {|x,y|(x[1]+x[3]+x[5] < y[1]+y[3]+y[5])})
      //Else
      //   aSort(aOpc, , , {|x,y|(x[3]+x[5] < y[3]+y[5])})
      //EndIf
	  If !lAutomacao
		DEFINE MSDIALOG oDlg TITLE STR0050 FROM 0,0 TO 350,800 PIXEL

		oPanel:= tPanel():Create(oDlg, 1, 1,,,,,,, 350, 800)
		oPanel:Align := CONTROL_ALIGN_ALLCLIENT

		oGroup:= TGroup():New(05,07,152,396,STR0050,oPanel,,,.T.)

		oBrowse := TWBrowse():New(14,12,380,135,,aHeader,aSizes,oPanel,,,,,,,,,,,,.F.,,.T.,,.F.,,.T.,.T.)
		oBrowse:SetArray(aOpc)
		If !Empty(mOpc)
			oBrowse:bLine := {||{ aOpc[oBrowse:nAT,01],aOpc[oBrowse:nAt,02],aOpc[oBrowse:nAt,03],aOpc[oBrowse:nAt,04],aOpc[oBrowse:nAt,05],aOpc[oBrowse:nAt,06]}}
		Else
			oBrowse:bLine := {||{ aOpc[oBrowse:nAT,03],aOpc[oBrowse:nAt,04],aOpc[oBrowse:nAt,05],aOpc[oBrowse:nAt,06]}}
		EndIf

		DEFINE SBUTTON FROM 158,370 TYPE 1 ACTION (oDlg:End()) ENABLE OF oPanel
		ACTIVATE MSDIALOG oDlg CENTER
	 EndIf
   Else
      Help( ,, 'Help',, STR0051 , 1, 0 )
   EndIf
Return .T.

//-------------------------------------------------------------------
/*/{Protheus.doc} ListOpcPcp(cProduto,mOpc,cOpc,nExibeAll)
Funo que interpreta os opcionais concatenados, e retorna um array com as descries dos grupos e dos itens opcionais.
@author Lucas Konrad Frana
@since 09/09/2014
@param cProduto - Cdigo do produto. Utilizado quando existir o mOpc
@param mOpc - Valor do memo dos opcionais, que ser transformado em um array.
@param cOpc - String concatenada com os opcionais, no formato GGGIIII/ (Grupo, Item)
@param nExibeAll - Utilizado quando existir o mOpc, indicar se sero considerados todos os opcionais (2), ou somente
        o opcional do produto passado por parmetro.
@version 1.0
@return aOpc
/*/
//-------------------------------------------------------------------
Function ListOpcPcp(cProduto,mOpc,cOpc,nExibeAll)
   Local aOpc    := { }
   /*
      aOpc: Array que contm os grupos e os itens opcionais.
      Exemplo: String "02 01  /ROD02  /"
      Ir retornar um array da seguinte maneira
      aOpc[1][1] := "Produto" Obs: Somente quando for do tipo MEMO(_MOPC), se for Char (_OPC), ir retornar nulo.
      aOpc[1][2] := "Descrio do produto" Obs: Somente quando for do tipo MEMO(_MOPC), se for Char (_OPC), ir retornar nulo.
      aOpc[1][3] := "02 "                             GA_GROPC
      aOpc[1][4] := "Descrio do grupo de opcionais" GA_DESCGRP
      aOpc[1][5] := "01  "                            GA_OPC
      aOpc[1][6] := "Descrio do item opcional"      GA_DESCOPC
      aOpc[2][1] := "Produto" Obs: Somente quando for do tipo MEMO(_MOPC), se for Char (_OPC), ir retornar nulo.
      aOpc[2][2] := "Descrio do produto" Obs: Somente quando for do tipo MEMO(_MOPC), se for Char (_OPC), ir retornar nulo.
      aOpc[2][3] := "ROD"                             GA_GROPC
      aOpc[2][4] := "Descrio do grupo de opcionais" GA_DESCGRP
      aOpc[2][5] := "02  "                            GA_OPC
      aOpc[2][6] := "Descrio do item opcional"      GA_DESCOPC
   */
   Local aMOpc    := { }
   Local nI       := 0
   Local nIOpc    := 0
   Local nTamGrp  := TamSX3("GA_GROPC")[1]
   Local nTamItm  := TamSX3("GA_OPC")[1]
   Local nTamProd := TamSX3("B1_COD")[1]
   Local aOldArea := GetArea()
   Default nExibeAll := 1

   If Empty(nExibeAll)
      nExibeAll := 1
   EndIf

   If !Empty(cOpc) .And. Empty(mOpc)
      dbSelectArea("SGA")
      SGA->(dbSetOrder(1))
      For nI := 1 To Len(cOpc)
         If( SGA->(dbSeek(xFilial("SGA") + SubStr(cOpc,nI,(nTamGrp+nTamItm)))))
            aAdd(aOpc,{Nil,Nil,SGA->GA_GROPC,;
                       SGA->GA_DESCGRP,;
                       SGA->GA_OPC,;
                       SGA->GA_DESCOPC})
            nI = nI + nTamGrp + nTamItm
         EndIf
      Next
   Else
      dbSelectArea("SB1")
      SB1->(dbSetOrder(1))
      dbSelectArea("SGA")
      SGA->(dbSetOrder(1))

      aMOpc := Str2Array(mOpc,.F.)

      If aMOpc == Nil
         If !Empty(mOpc)
            For nI := 1 To Len(mOpc)
               If( SGA->(dbSeek(xFilial("SGA") + SubStr(mOpc,nI,(nTamGrp+nTamItm)))))
                  aAdd(aOpc,{Nil,Nil,SGA->GA_GROPC,;
                             SGA->GA_DESCGRP,;
                             SGA->GA_OPC,;
                             SGA->GA_DESCOPC})
                  nI = nI + nTamGrp + nTamItm
               EndIf
            Next nI
            If Len(aOpc) < 1
               aAdd(aOpc,{"","","","","",""})
            EndIf
            Return aOpc
         Else
            Return {{"","","","","",""}}
         EndIf
      EndIf

      For nI := 1 To Len(aMOpc)
         If AllTrim(aMOpc[nI][2]) == "/"
            Loop
         EndIf
         If SubStr(aMOpc[nI][1],Iif(((Len(aMOpc[nI][1])-(nTamProd*2))-5) < 1,1,(Len(aMOpc[nI][1])-(nTamProd*2))-5),nTamProd) == cProduto .Or. nExibeAll == 2
            If SB1->(dbSeek(xFilial("SB1") + SubStr(aMOpc[nI][1],Iif(((Len(aMOpc[nI][1])-(nTamProd*2))-5) < 1,1,(Len(aMOpc[nI][1])-(nTamProd*2))-5),nTamProd) ))
               For nIOpc := 1 To Len(aMOpc[nI][2])
                  If( SGA->(dbSeek(xFilial("SGA") + SubStr(aMOpc[nI][2],nIOpc,(nTamGrp+nTamItm)))))
                     If aScan(aOpc, {|x| x[1] == SB1->B1_COD .And. ;
                                         x[3] == SGA->GA_GROPC .And. ;
                                         x[5] == SGA->GA_OPC } ) == 0
                        aAdd(aOpc,{SB1->B1_COD,;
                                   SB1->B1_DESC,;
                                   SGA->GA_GROPC,;
                                   SGA->GA_DESCGRP,;
                                   SGA->GA_OPC,;
                                   SGA->GA_DESCOPC})
                     EndIf
                     nIOpc = nIOpc + nTamGrp + nTamItm
                  EndIf
               Next nI
            EndIf
         EndIf
      Next

   EndIf
   RestArea(aOldArea)
Return aOpc

/*


ͻ
Programa   MtPeOpcPcpAutor  Andre Anjos         Data   17/12/09   
͹
Descricao  Funcao que verifica se para determinado produto ha cadastro
           de opcionais X cliente, retornando o opcional do cadastro. 
͹
Uso        EST/PCP/FAT												  
ͼ


*/
Function MtPeOpcPcp(cProduto,cCliente,aGrupos)
Local cRet 		:= ""
Local nPos		:= 0
Local cFamilia := A093VldBase(cProduto)

	SDJ->(dbSetOrder(1))
	SDJ->(dbSeek(xFilial("SDJ")+cCliente+cFamilia))
	While SDJ->(!EOF()) .And. SDJ->(DJ_FILIAL+DJ_CLIENTE+DJ_TIENDA+DJ_FAMILIA) == xFilial("SDJ")+cCliente+cFamilia
		nPos := aScan(aGrupos,{|x| x == SDJ->DJ_GPOOPC})
		If nPos > 0
			cRet += SDJ->(DJ_GPOOPC+DJ_ITEOPC)+"/"
		EndIf
		SDJ->(dbSkip())
	End
Return cRet

/*


Ŀ
 Funo     OpcTdOkPcp                                                 
Ĵ
 Autor      Rodrigo de Almeida Sartorio               Data  12/09/97 
Ĵ
 Descrio  Verifica se esta tudo Ok na selecao dos opcionais          
            e monta string com os opcionais selecionados               
Ĵ
Sintaxe     OpcTudOk(ExpC1,ExpA1,ExpA2,ExpA3,ExpC2)                    
Ĵ
Parametros  ExpC1 = Codigo do produto                                  
            ExpA1 = Array utilizado na marcacao                        
            ExpA2 = Array com os grupo de Opcionais                    
            ExpA3 = Registros selecionados                             
            ExpC2 = String com os Opcionais selecionados               
Ĵ
  Uso       Selecao de Opcionais                                       
ٱ


*/
Function OpcTdOkPcp(cProduto,aArray,aGrupos,aRegs,cOpcionais,cProg,aOpcionAUX,cOpcMark)
LOCAL nAcho:=0,nString:=0,i, i1
LOCAL lRet:=.T.
LOCAL aTam:=TAMSX3("GA_OPC")
LOCAL cDefault:=""
LOCAL cBackOpc:=cOpcionais
Local aArea := GetArea()
Local lObrigat := .T.
Local cOpcSB1  := ""
Local lOpcPadrao:= SuperGetMV("MV_REPGOPC",.F.,"N") == "N"

Default cOpcMark := ""

If cProg # "MATA010"
	//Ŀ
	//Valida se todos grupos tiveram um item selecionado ou possuem
	//opcional default cadastrado no SB1                           
	//
	SB1->(dbSetOrder(1))
	For i:=1 to Len(aGrupos)
		lObrigat := .T.
		nAcho := IIF(ASCAN(aArray,{|x| x[4] == aGrupos[i] .And. x[8]}) != 0,ASCAN(aArray,{|x| x[4] == aGrupos[i] .And. x[1]}),1)
		// Pesquisa no array se grupo nao teve item marcado
		//nAcho:=ASCAN(aArray,{|x| x[4] == aGrupos[i] .And. x[1]})
		// Caso nao achou item marcado procura opcional default
		If nAcho == 0
			If SGA->(dbSeek(xFilial("SGA")+aGrupos[i]))
				lObrigat := Iif(SGA->GA_OBG=="0",.F.,.T.)
			EndIf

			If lObrigat .And. SB1->(dbSeek(xFilial("SB1")+cProduto))
				If FunName() $ "MATA712"
      				cOpcSB1 := Iif(!Empty(SB1->B1_OPC),SB1->B1_OPC,SB1->B1_MOPC)
				Else
					cOpcSB1 := Iif(Empty(SB1->B1_MOPC),SB1->B1_OPC,SB1->B1_MOPC)
   				EndIf

				If !Empty(cOpcSB1)
					// Verifica se o grupo esta na primeira posicao
					If Substr(cOpcSB1,1,Len(SGA->GA_GROPC)) == aGrupos[i]
						nString:=1
					Else
						// Procura grupo nas posicoes seguintes
						nString:=AT("/"+aGrupos[i],cOpcSB1)
					EndIf
					If nString > 0
						nString:=IF(nString=1,1,nString+1)
						cDefault:=Substr(cOpcSB1,nString,Len(SGA->GA_GROPC+SGA->GA_OPC))
						nAcho:=0
						nAcho:=ASCAN(aArray,{|x| Substr(x[3],1,Len(SGA->GA_OPC)) == Substr(cDefault,Len(SGA->GA_GROPC)+1) })
						If nAcho > 0
							cOpcionais+=cDefault+"/"
						EndIf
					EndIf
				EndIf
				// Caso nao achou o grupo no campo de opcionais default
				If nString <=0 .Or. nAcho <= 0
					If lObrigat
						Help ("",1,"MARCAGRUPO",,aGrupos[i],1,22)
						lRet:=.F.
						// Restaura os opcionais digitados anteriormente
						cOpcionais:=cBackOpc
						Exit
					Else
						cOpcionais += Space(Len(SGA->GA_GROPC)+Len(SGA->GA_OPC)) + "/"
					EndIf
				EndIf
			EndIf
		EndIf
	Next i
EndIf
// Monta a string de retorno
If lRet
	If !Empty(aOpcionAUX)
		For i:=1 to Len(aArray)
			If aArray[i,1]
				For i1:=1 to Len(aOpcionAUX)
					If aOpcionAUX[i1,3]  == aArray[i,3] .And.;
						aOpcionAUX[i1,4] == aArray[i,4]
						aOpcionAUX[i1,1] := .T.
					EndIf
				Next i1
			Else
				For i1:=1 to Len(aOpcionAUX)
					If aOpcionAUX[i1,3]  == aArray[i,3] .And.;
						aOpcionAUX[i1,4] == aArray[i,4]
						aOpcionAUX[i1,1] := .F.
					EndIf
				Next i1
			EndIf
		Next i

		For i:=1 to Len(aOpcionAUX)
			If aOpcionAUX[i,1]
				If cProg == "MATA010" .Or. cProg == "MATA018"
					If !lOpcPadrao
                    	cOpcionais+=aOpcionAUX[i,4]+Substr(aOpcionAUX[i,3],1,aTam[1])+"/"
            	 	Else
                     	If AT(aOpcionAUX[i,4]+Substr(aOpcionAUX[i,3],1,aTam[1])+"/",cOpcionais) < 1 .And. ;
                      	  AT(aOpcionAUX[i,4]+Substr(aOpcionAUX[i,3],1,aTam[1])+"/",cOpcMark) < 1
                      	  cOpcionais+=aOpcionAUX[i,4]+Substr(aOpcionAUX[i,3],1,aTam[1])+"/"
                   		EndIf
                  	EndIf
				Else	
				   cOpcionais+=aOpcionAUX[i,4]+Substr(aOpcionAUX[i,3],1,aTam[1])+"/"
				Endif 	   
				AADD(aRegs,{aOpcionAUX[i,7],aOpcionAUX[i,6],aOpcionAUX[i,9]})
			EndIf
		Next i
	Else
		For i:=1 to Len(aArray)
			If aArray[i,1]
				If !lOpcPadrao
					cOpcionais+=aArray[i,4]+Substr(aArray[i,3],1,aTam[1])+"/"
				Else
					If AT(aArray[i,4]+Substr(aArray[i,3],1,aTam[1])+"/",cOpcionais) < 1 .And. ;
						AT(aArray[i,4]+Substr(aArray[i,3],1,aTam[1])+"/",cOpcMark) < 1
						cOpcionais+=aArray[i,4]+Substr(aArray[i,3],1,aTam[1])+"/"
					EndIf
				EndIf

				AADD(aRegs,{aArray[i,7],aArray[i,6],aArray[i,9]})
			EndIf
		Next i
	EndIf
EndIf
RestArea(aArea)
Return lRet

/*

Ŀ
Funo     MarkOpcPcp   Autor Rodrigo de A. Sartorio  Data  17/12/97 
Ĵ
Descrio  Funcao recursiva que permite a selecao de Opcionais .      
Ĵ
Sintaxe    MarkOpc(ExpC1,ExpC2,ExpA1,ExpC3,ExpC4)                     
Ĵ
Parametros ExpC1 = Produto a ter os opcionais escolhidos.             
           ExpC2 = Retorno da string com os opcionais selecionados.   
           ExpA1 = Array com retorno de toda estrutura utilizada      
           ExpC3 = Produto pai da Estrutura                           
           ExpC4 = String com os produtos da estrutura                
Ĵ
 Uso       Generico                                                   
ٱ


*/
Function MarkOpcPcp(cProduto,cRet,aRetorOpc,cProdPai,cProdAnt,cProg,cOpcMarc,lVisual,nNivel,nQtd,dDataVal,cRevisao,lPreEstr,lexiste,nDecimais,lGeraOPI)

Static oOk,oNo,oBr

Local aArea		:=GetArea()
Local cCadastro	:=STR0052+cProduto //"Opcionais Disponiveis - "
Local nAcho		:=0
Local nString	:=0
Local i			:=0
Local nOpca		:=1
Local aGrupos	:={}
Local aRegs		:={}
Local cOpcionais:="" // Variavel utilizada para retorno da string
Local nTamDif	:=(Len(SGA->GA_OPC)+Len(SGA->GA_DESCOPC)+13)-(Len(SGA->GA_GROPC)+Len(SGA->GA_DESCGRP)+3)
Local lOpcPadrao:= SuperGetMV("MV_REPGOPC",.F.,"N") == "N"

Local aOpcionais:={}
Local aOpcionAUX :={}
Local aSize     :={}
Local aPosObj   :={}
Local aInfo     :={}
Local aObjects  :={}
Local nDifSize  :=0
Local lRet      :=.T.
Local lSELEOPC  :=ExistBlock("SELEOPC")
Local lAddOpc   :=ExistBlock("ADDOPC")
Local aCopyRegs :={}
Local oDlg,oOpc,cOpc
Local lGerOPI	:= ExistBlock("MTGEROPI")
Local lRetOPI   := .T.
Local nQuantItem:= 1
Local lRetOpc 	:= .F.
Local aOpcRET	:= {}
Local lTela		:= .T.
Local nQtdAx  := 0
Local cOpcSele := ""
Local cOpcComp := ""
Local cOpcDefa := ""
Local lOpcDefa := .F.
Local lMTOPCADD := ExistBlock("MTOPCADD")
Local lPCPREVATU	:= FindFunction('PCPREVATU')
Local cRevAtual 	:= ''
Local dDataCmp      := Nil

Default cProg 	  :=""
Default cOpcMarc  :=""
Default lVisual   :=.F.
Default nQtd      :=0
Default dDataVal  :=dDataBase
Default lPreEstr  :=.F.
Default nDecimais := TamSX3("D4_QUANT")[2]
Default lGeraOPI  := SuperGetMV("MV_GERAOPI")

cProduto := PadR(cProduto,Len(SB1->B1_COD))
//Ŀ
// Caso nao exista cria array que registra todos os niveis da estrutura    
//
If Type("aRetorOpc") <> "A"
	aRetorOpc:={}
EndIf

//Ŀ
// Monta titulo da janela com o codigo do produto+descricao    
//
SB1->(dbSetOrder(1))
If SB1->(MsSeek(xFilial("SB1")+cProduto))
	cCadastro:=STR0052+AllTrim(cProdPai)+If(!Empty(cProdPai)," - > ","")+Rtrim( cProduto )+" / " + Left(SB1->B1_DESC,25) //"Opcionais Disponiveis - "
	If Empty(cOpcMarc)
		cOpcMarc := Iif(Empty(RetFldProd(SB1->B1_COD,"B1_MOPC")),RetFldProd(SB1->B1_COD,"B1_OPC"),RetFldProd(SB1->B1_COD,"B1_MOPC"))
	EndIf
EndIf

//Ŀ
// Estrutura do array dos opcionais                            
//
// 1 Marcado (.T. ou .F.)
// 2 Titulo("0") ou Item("1")
// 3 Item Opcional+Descricao Opcional
// 4 Grupo de Opcionais
// 5 Registro no SG1
// 6 Nivel no SG1
// 7 Recno do SG1
// 8 Componente Ok (.T.) ou Vencido (.F.)
// 9 Codigo do componente
//10 Default ?

If Empty(cOpcDefa)
	dbSelectArea("SB1")
	dbSetOrder(1)
	lAchouB1 := MsSeek(xFilial("SB1")+cProduto)
	If lAchouB1
		cOpcDefa := SB1->B1_OPC
	EndIf
EndIf

//Ŀ
// Varre a estrutura do produto                                
//
dbSelectArea(IIf(lPreEstr,"SGG","SG1"))
dbSetOrder(1)
dbSeek(xFilial()+cProduto)
Do While !Eof() .And. IIf(lPreEstr,SGG->GG_FILIAL+SGG->GG_COD == xFilial("SGG")+cProduto,SG1->G1_FILIAL+SG1->G1_COD == xFilial("SG1")+cProduto)

	If !lPreEstr
		If SB1->B1_GRADE == "S" .AND. Empty(cRevisao) .AND. cProg == "MATA650"
			cRevisao := PCPREVATU(cProduto)
		EndIf

		//cRevAtual := PCPREVATU(SG1->G1_COD)
		If !(cRevisao >= SG1->G1_REVINI .AND. cRevisao <= SG1->G1_REVFIM)
			dbSkip()
			Loop
		EndIf
	EndIf

	If !Empty(IIf(lPreEstr,SGG->GG_GROPC,SG1->G1_GROPC)) .And. !Empty(IIf(lPreEstr,SGG->GG_OPC,SG1->G1_OPC))
		lExisteOpc := .T.
		cOpcArq := If(lPreEstr,SGG->GG_GROPC+SGG->GG_OPC,SG1->G1_GROPC+SG1->G1_OPC)

		If (!Empty(cOpcDefa) .And. !Empty(cOpcArq) .And. !(cOpcArq $ cOpcDefa)) .Or. (Empty(cOpcDefa) .Or. Empty(cOpcArq))
			lOpcDefa := .F.
		Else
			lOpcDefa := .T.
		EndIf

		// Caso ja tenha opcionais preenchidos, pesquisa se nao  o grupo
		// atual
		If !Empty(cRet)
			// Verifica se  a primeira posicao
			If Substr(cRet,1,Len(SGA->GA_GROPC)) == IIf(lPreEstr,SGG->GG_GROPC,SG1->G1_GROPC)
				nString:=1
			Else
				// Procura grupo no campo de opcionais default
				nString:=AT("/"+IIf(lPreEstr,SGG->GG_GROPC,SG1->G1_GROPC),cRet)
			EndIf
			If nString > 0 .And. lOpcPadrao
				cOpcSele := SubStr(cRet,Iif(nString==1,1,nString+1),Len(SGA->GA_GROPC)+Len(SGA->GA_OPC))
				cOpcComp := IIf(lPreEstr,SGG->GG_GROPC+SGG->GG_OPC,SG1->G1_GROPC+SG1->G1_OPC)

				//somente incluir se o opcional do componente for o opcional selecionado
				If cOpcSele == cOpcComp
					If SGA->(dbSeek(xFilial("SGA")+IIf(lPreEstr,SGG->GG_GROPC+SGG->GG_OPC,SG1->G1_GROPC+SG1->G1_OPC)))
						// Verifica se o grupo ja foi incluido
						nAcho:=ASCAN(aGrupos,IIf(lPreEstr,SGG->GG_GROPC,SG1->G1_GROPC))
						//Valida datas e revisao
						If !Empty(nQtd)
							nQuantItem := Round(ExplEstr(nQtd,dDataVal,"",cRevisao,,lPreEstr,,,,,,.T.,.F.),nDecimais)
						EndIf
						If nAcho == 0
							AADD(aGrupos,IIf(lPreEstr,SGG->GG_GROPC,SG1->G1_GROPC))
							// Adiciona titulo ao array
							AADD(aOpcionAUX,{.F.,"0",SGA->GA_GROPC+" - "+SGA->GA_DESCGRP+Space(nTamDif),SGA->GA_GROPC,SGA->(Recno()),IIf(lPreEstr,SGG->GG_NIV+SGG->GG_COMP,SG1->G1_NIV+SG1->G1_COMP),IIf(lPreEstr,SGG->(Recno()),SG1->(Recno())),QtdComp(nQuantItem)>QtdComp(0),IIf(lPreEstr,SGG->GG_COMP,SG1->G1_COMP),lOpcDefa})
						EndIf

						// Verifica se o grupo ja foi digitado neste nivel
						nAcho:=ASCAN(aOpcionAUX,{ |x| x[2] == "1" .And. x[4] == SGA->GA_GROPC .And. x[5] == SGA->(Recno())})
						If nAcho == 0
							// Adiciona item ao array
							AADD(aOpcionAUX,{.T.,;
					  			"1",;
					  			SGA->GA_OPC+" - "+SGA->GA_DESCOPC,;
					  			SGA->GA_GROPC,;
					  			SGA->(Recno()),;
					  			IIf(lPreEstr,SGG->GG_NIV+SGG->GG_COMP,SG1->G1_NIV+SG1->G1_COMP),;
					  			IIf(lPreEstr,SGG->(Recno()),SG1->(Recno())),;
					  			QtdComp(nQuantItem)!=QtdComp(0),;
					  			IIf(lPreEstr,SGG->GG_COMP,SG1->G1_COMP),;
					  			lOpcDefa})
						Else
							// Verifica se o grupo e produto ja foi digitado neste nivel
							nAcho:=ASCAN(aOpcionAUX,{ |x| x[2] == "1" .And. x[4] == SGA->GA_GROPC .And. x[5] == SGA->(Recno()) .And. x[9] == SG1->G1_COMP })
							If nAcho == 0
								// Adiciona item ao array
								If SG1->G1_INI > dDataBase .Or. SG1->G1_FIM < dDataBase
									AADD(aOpcionAUX,{.T.,"1",SGA->GA_OPC+" - "+SGA->GA_DESCOPC,SGA->GA_GROPC,SGA->(Recno()),IIf(lPreEstr,SGG->GG_NIV+SGG->GG_COMP,SG1->G1_NIV+SG1->G1_COMP),IIf(lPreEstr,SGG->(Recno()),SG1->(Recno())),QtdComp(nQuantItem,.T.)>QtdComp(0,.T.),IIf(lPreEstr,SGG->GG_COMP,SG1->G1_COMP),lOpcDefa})
								Else
									AADD(aOpcionAUX,{.T.,"1",SGA->GA_OPC+" - "+SGA->GA_DESCOPC,SGA->GA_GROPC,SGA->(Recno()),IIf(lPreEstr,SGG->GG_NIV+SGG->GG_COMP,SG1->G1_NIV+SG1->G1_COMP),IIf(lPreEstr,SGG->(Recno()),SG1->(Recno())),.T.,IIf(lPreEstr,SGG->GG_COMP,SG1->G1_COMP),lOpcDefa})
								EndIf
							EndIf
						EndIf
					EndIf
				EndIf
				dbSkip()
				Loop
			EndIf
		EndIf
		If SGA->(dbSeek(xFilial("SGA")+IIf(lPreEstr,SGG->GG_GROPC+SGG->GG_OPC,SG1->G1_GROPC+SG1->G1_OPC)))
			//-- Ponto de Entrada para validar os Opcionais
			If	lSELEOPC
				lRet := ExecBlock('SELEOPC',.F.,.F.,{lPreEstr,cRevisao})
				If ValType(lRet) <> 'L'
					lRet := .T.
				EndIf
				If !lRet //-- Se o Opcional nao for valido
					If lPreEstr
					    SGG->(dbSkip())
					Else
						SG1->(dbSkip())
					EndIf
					Loop
				EndIf
			EndIf

			// Verifica se o grupo ja foi incluido
			nAcho:=ASCAN(aGrupos,IIf(lPreEstr,SGG->GG_GROPC,SG1->G1_GROPC))
			//Valida datas e revisao
			If !Empty(nQtd)
				nQuantItem := Round(ExplEstr(nQtd,dDataVal,"",cRevisao,,lPreEstr,,,,,,.T.,.F.),nDecimais)
			EndIf
			If nAcho == 0
				AADD(aGrupos,IIf(lPreEstr,SGG->GG_GROPC,SG1->G1_GROPC))
				// Adiciona titulo ao array
				AADD(aOpcionais,{.F.,"0",SGA->GA_GROPC+" - "+SGA->GA_DESCGRP+Space(nTamDif),SGA->GA_GROPC,SGA->(Recno()),IIf(lPreEstr,SGG->GG_NIV+SGG->GG_COMP,SG1->G1_NIV+SG1->G1_COMP),IIf(lPreEstr,SGG->(Recno()),SG1->(Recno())),QtdComp(nQuantItem)!=QtdComp(0),IIf(lPreEstr,SGG->GG_COMP,SG1->G1_COMP),lOpcDefa})
				AADD(aOpcionAUX,aClone(aTail(aOpcionais)))
			EndIf

			// Verifica se o grupo ja foi digitado neste nivel
			nAcho:=ASCAN(aOpcionais,{ |x| x[2] == "1" .And. x[4] == SGA->GA_GROPC .And. x[5] == SGA->(Recno())})
			If nAcho == 0
				// Adiciona item ao array
					AADD(aOpcionais,{OpcSelec(cOpcMarc, SGA->GA_GROPC+SGA->GA_OPC, cProdAnt, IIf(lPreEstr,SGG->GG_COMP+SGG->GG_TRT,SG1->G1_COMP+SG1->G1_TRT)),;
						  "1",;
						  SGA->GA_OPC+" - "+SGA->GA_DESCOPC,;
						  SGA->GA_GROPC,;
						  SGA->(Recno()),;
						  IIf(lPreEstr,SGG->GG_NIV+SGG->GG_COMP,SG1->G1_NIV+SG1->G1_COMP),;
						  IIf(lPreEstr,SGG->(Recno()),SG1->(Recno())),;
						  QtdComp(nQuantItem)!=QtdComp(0),;
						  IIf(lPreEstr,SGG->GG_COMP,SG1->G1_COMP),;
						  lOpcDefa})

					AADD(aOpcionAUX,aClone(aTail(aOpcionais)))
			Else
				// Verifica se o grupo e produto ja foi digitado neste nivel
				nAcho:=ASCAN(aOpcionAUX,{ |x| x[2] == "1" .And. x[4] == SGA->GA_GROPC .And. x[5] == SGA->(Recno()) .And. x[7] == IIf(lPreEstr,SGG->(Recno()),SG1->(Recno())) })
				If nAcho == 0
					// Adiciona item ao array
					If SG1->G1_INI > dDataBase .Or. SG1->G1_FIM < dDataBase
						AADD(aOpcionAUX,{SGA->GA_GROPC+SGA->GA_OPC $ cOpcMarc,"1",SGA->GA_OPC+" - "+SGA->GA_DESCOPC,SGA->GA_GROPC,SGA->(Recno()),IIf(lPreEstr,SGG->GG_NIV+SGG->GG_COMP,SG1->G1_NIV+SG1->G1_COMP),IIf(lPreEstr,SGG->(Recno()),SG1->(Recno())),QtdComp(nQuantItem,.T.)>QtdComp(0,.T.),IIf(lPreEstr,SGG->GG_COMP,SG1->G1_COMP),lOpcDefa})
					Else
						AADD(aOpcionAUX,{SGA->GA_GROPC+SGA->GA_OPC $ cOpcMarc,"1",SGA->GA_OPC+" - "+SGA->GA_DESCOPC,SGA->GA_GROPC,SGA->(Recno()),IIf(lPreEstr,SGG->GG_NIV+SGG->GG_COMP,SG1->G1_NIV+SG1->G1_COMP),IIf(lPreEstr,SGG->(Recno()),SG1->(Recno())),.T.,IIf(lPreEstr,SGG->GG_COMP,SG1->G1_COMP),lOpcDefa})
						nAcho:=ASCAN(aOpcionais,{ |x| x[2] == "1" .And. x[4] == SGA->GA_GROPC .And. x[5] == SGA->(Recno())})
						If nAcho > 0
							aOpcionais[nAcho,8] := .T.
						EndIf
					EndIf
				Else
					If QtdComp(nQuantItem,.T.)!=QtdComp(0,.T.)
						aOpcionAUX[nAcho,8] := .T.
						nAcho:=ASCAN(aOpcionais,{ |x| x[2] == "1" .And. x[4] == SGA->GA_GROPC .And. x[5] == SGA->(Recno())})
						If nAcho > 0
							aOpcionais[nAcho,8] := .T.
						EndIf
					EndIf
				EndIf
			EndIf
		EndIf
	Else
		// Caso nao tenha opcionais neste nivel, guarda o registro para
		// pesquisar em niveis inferiores
		If !Empty(nQtd)
			//Valida datas e revisao
			nQuantItem := Round(ExplEstr(nQtd,dDataVal,"",cRevisao,,lPreEstr,,,,,,.T.,.F.),nDecimais)
		EndIf

		//Se o componente no estiver vlido, no adiciona em aRegs para processar prximos nveis.
		If (!Empty(nQtd) .And. !Empty(nQuantItem)) .Or. (Empty(nQtd))
			AADD(aRegs,{IIf(lPreEstr,SGG->(Recno()),SG1->(Recno())),IIf(lPreEstr,SGG->GG_NIV+SGG->GG_COMP,SG1->G1_NIV+SG1->G1_COMP),IIf(lPreEstr,SGG->GG_COMP,SG1->G1_COMP)})
		EndIf
	EndIf
	dbSkip()
EndDo

//Ŀ
// Caso tenha opcionais neste nivel, monta a tela de seleao   
//
If Len(aOpcionais) > 0
	// Valor padrao para DIALOG
	nOpca:=0
	// Sorteia array com grupos
	ASORT(aGrupos)
	// Sorteia array com opcionais
	ASORT(aOpcionais,,,{|x,y| x[4]+x[2]+x[3] < y[4]+y[2]+y[3] })
	//Ŀ
	// Verifica se ha opcional X cliente						   
	//
	If cProg == "MATA410" .And. AllTrim(M->C5_SOLOPC) == '2'
	   cOpcionais := MtPesqOpc(cProduto,M->(C5_CLIENTE+C5_LOJACLI),aGrupos)
	   aEval(aOpcionais, {|x| If(x[4]+Substr(x[3],1,Len(SGA->GA_OPC)) $ cOpcionais,x[1]:=.T.,x[1]:=.F.) })
	   cOpcionais := ""
	   lTela := !OpcTudOk(cProduto,aOpcionais,aGrupos,@aRegs,@cOpcionais,cProg,.F.,cRet)
	EndIf
	If lTela
		If !IsBlind()
			//Ŀ
			// Le na resource os bitmaps utilizados no Listbox p/ seleao  
			//
			If oOk == NIL
				oOk := LoadBitmap( GetResources(), "LBOK")
			EndIf
			If oNo == NIL
				oNo := LoadBitmap( GetResources(), "LBNO")
			EndIf
			If oBr == NIL
				oBr := LoadBitmap(GetResources(),'')
			EndIf

			//Ŀ
			// Calcula automaticamente as dimensoes dos objetos            
			//
			aSize := MsAdvSize(.F.)
			aObjects := {}
			AAdd( aObjects, { 100,  20, .T., .F. } )
			AAdd( aObjects, { 100, 100, .T., .T., .T. } )
			AAdd( aObjects, { 100,  15, .T., .F. } )

			//Ŀ
			// Diminui o tamanho retornado e garante que a largura da Dialog nao ultrapasse 600 
			//
			nDifSize := 0
			If ( aSize[ 5 ] - 80 ) > 600
				nDifSize := aSize[ 5 ] - 80 - 600
			EndIf

			aSize[ 3 ] -= 40 + nDifSize / 2
			aSize[ 4 ] -= 40

			aSize[ 5 ] -= 80 + nDifSize
			aSize[ 6 ] -= 80

			aInfo   := { aSize[ 1 ], aSize[ 2 ], aSize[ 3 ], aSize[ 4 ], 3, 2 }
			aPosObj := MsObjSize( aInfo, aObjects )

			Do While .T.

				DEFINE MSDIALOG oDlg TITLE cCadastro From aSize[7],0 To aSize[6],aSize[5] OF oMainWnd PIXEL

				@ 05, 03 SAY cCadastro OF oDlg PIXEL

				@ 15, 00 TO 17, 2000 PIXEL

				If lMTOPCADD
					aOpcRet := ExecBlock("MTOPCADD",.F.,.F.,{aOpcionais})
				EndIf

				@ aPosObj[2,1],aPosObj[2,2] LISTBOX oOpc VAR cOpc Fields HEADER "",STR0053,STR0054,"Default",iif(len(aOpcRet) > 0,aOpcRet[1,1],' ')  SIZE aPosObj[2,3],aPosObj[2,4] ON DBLCLICK If(!lVisual,(aOpcionais:=OpcTroca(oOpc:nAt,aOpcionais),oOpc:Refresh()),) NOSCROLL OF oDlg PIXEL  //"Grupos/Itens Opcionais"###"Validade Componente"
				oOpc:SetArray(aOpcionais)
				oOpc:bLine := { || {If(aOpcionais[oOpc:nAt,2]=="0",oBr,IF(aOpcionais[oOpc:nAt,1],oOk,oNo)),aOpcionais[oOpc:nAt,3],If(aOpcionais[oOpc:nAt,2]=="0","",If(aOpcionais[oOpc:nAt,8]," Ok",STR0055)),If(aOpcionais[oOpc:nAt,2]=="0","",If(aOpcionais[oOpc:nAt,10],STR0056,STR0057)),iif (len(aOpcRet)>1,aOpcRet[oOpc:nAt+1,2],' ')}} //" Vencido"
				DEFINE SBUTTON FROM aPosObj[3,1]+2,aPosObj[3,4] - 57 TYPE 1 ACTION (IF(If(!lVisual .OR. (!INCLUI .And. !ALTERA),OpcTudOk(cProduto,aOpcionais,aGrupos,@aRegs,@cOpcionais,cProg,aOpcionAUX,cRet),.T.),(nOpca:=1,oDlg:End()),)) ENABLE OF oDlg PIXEL
				DEFINE SBUTTON FROM aPosObj[3,1]+2,aPosObj[3,4] - 27 TYPE 2 ACTION (nOpca:=0,oDlg:End()) ENABLE OF oDlg PIXEL
				ACTIVATE MSDIALOG oDlg CENTERED
				If nOpcA == 1 .Or. lVisual
					Exit
				ElseIf nOpca == 0
					Exit
				EndIf
			EndDo
		Else
			IF (ASCAN(aOpcionais,{|x| x[8]})) > 0
				IF OpcTudOk(cProduto,aOpcionais,aGrupos,@aRegs,@cOpcionais,,aOpcionAUX,cRet)
					nOpcA := 1
				EndIf
			Else
				nOpcA := 1
			EndIf
		EndIf
	Else
		nOpcA := 1
	EndIf
	If !lOpcPadrao
		cRet+=cOpcionais
	Else
		If AT(cOpcionais,cRet) < 1
			cRet+=cOpcionais
		EndIf
	EndIf
	// Este trecho foi removido pois nas chamadas recursivas o opcional selecionado no nivel anterior estava sendo substituido indevidamente
	//If !lOpcPadrao .And. nNivel > 1
	//	aRetorOpc[Len(aRetoropc),2]:=cOpcionais
	//EndIf
Else
	If Len(aOpcionAUX) > 0
		OpcTudOk(cProduto,aOpcionais,aGrupos,@aRegs,@cOpcionais,cProg,aOpcionAUX,cRet)
		If !lOpcPadrao
			cRet+=cOpcionais
		Else
			If AT(cOpcionais,cRet) < 1
				cRet+=cOpcionais
			EndIf
		EndIf
	EndIf
EndIf
//Ŀ
// Ponto de Entrada para adicionar mais opcionais ao array aRegs.	
//
 If lAddOpc
	aCopyRegs := aClone(aRegs)
	aRegs     := ExecBlock('ADDOPC',.F.,.F.,{aRegs,cProdAnt,cOpcionais})
	If ValType(aRegs) <> 'A'
		aRegs := aClone(aCopyRegs)
	EndIf
EndIf

//Ŀ
// Ponto de entrada para a utilizado para verificar a 		    
// necessidade de gerar ou nao OPs intermediarias				
//
If lGerOPI
	lRetOPI:=ExecBlock("MTGEROPI",.F.,.F.)
	If ValType(lRetOPI) # "L"
		lRetOPI:=.T.
	EndIf
EndIf

//Ŀ
//Na inclusao manual de OPs, nao deve analisar opcionais de           
//outros niveis da estrutura, quando o parametro MV_GERAOPI for Falso 
//
If /*lRetOPI .And.*/ (  lGeraOPI .Or. (!( "C2_PRODUTO" $ ReadVar())))                                   // qdo vier da incluso da OP (mata650) e MV_GERAOPI = .F., no tem
	ASORT(aRegs,,,{|x,y| x[2] < y[2]})                                                              // sentido o cursor estar posicionado no produto para funcionar o MV_GERAOPI
	// Varre o array para que sejam selecionados os itens restantes
	For i:=1 to Len(aRegs)

		SB1->(MsSeek(xFilial("SB1")+aRegs[i,3] ))

		If IIf(lPreEstr,SGG->(dbSeek(xFilial("SGG")+aRegs[i,3])),SG1->(dbSeek(xFilial("SG1")+aRegs[i,3])))  .And. (lGeraOPI == .T. .OR. SB1->B1_FANTASM == 'S') .And. lRetOPI
			If lPreEstr
				SGG->(MsGoto(aRegs[i,1]))
			Else
				SG1->(MsGoto(aRegs[i,1]))
			EndIf
			// Adiciona no array que registra todos os niveis da estrutura
			AADD(aRetorOpc,{cProdAnt+IIf(lPreEstr,SGG->GG_COMP+SGG->GG_TRT,SG1->G1_COMP+SG1->G1_TRT),cOpcionais})
			nNivel+=1
			dDataCmp := dDataVal

            nQtdAx := Round(ExplEstr(nQtd,dDataVal,"",cRevisao,,lPreEstr,,,,,,.T.,.F.),nDecimais)
			SB1->(MsSeek(xFilial("SB1")+IIf(lPreEstr,SGG->GG_COMP,SG1->G1_COMP)))
			IF (SG1->G1_INI <= dDataVal .And. SG1->G1_FIM >= dDataVal)
				If IsInCallStack("MATA650")
					If SB1->B1_FANTASM == 'S' .Or. lGeraOPI
						Do Case
							Case RetFldProd(SB1->B1_COD,"B1_TIPE") == "H"
								dDataCmp -= Int(RetFldProd(SB1->B1_COD,"B1_PE")/24)
							Case SB1->B1_TIPE == "S"
								dDataCmp -= (RetFldProd(SB1->B1_COD,"B1_PE") * 7)
							Case SB1->B1_TIPE == "M"
								dDataCmp -= (RetFldProd(SB1->B1_COD,"B1_PE") * 30)
							Case SB1->B1_TIPE == "A"
								dDataCmp -= (RetFldProd(SB1->B1_COD,"B1_PE") * 365)
							OtherWise
								dDataCmp -= RetFldProd(SB1->B1_COD,"B1_PE")
						EndCase
						cRevAtual :=  IIF(lPCPREVATU , PCPREVATU(SB1->B1_COD), SB1->B1_REVATU )
						lRetOpc := MarkOpcPcp(IIf(lPreEstr,SGG->GG_COMP,SG1->G1_COMP),@cRet,aRetorOpc,IIf(lPreEstr,SGG->GG_COD,SG1->G1_COD),cProdAnt+IIf(lPreEstr,SGG->GG_COMP+SGG->GG_TRT,SG1->G1_COMP+SG1->G1_TRT),cProg,cOpcMarc,lVisual,nNivel,nQtdAx,dDataCmp,cRevAtual,lPreEstr,@lExisteOpc,nDecimais)
						If !lRetOpc
							nOpca := 0
						EndIf
						nNivel-=1
					EndIf
				Else
					Do Case
						Case RetFldProd(SB1->B1_COD,"B1_TIPE") == "H"
							dDataCmp -= Int(RetFldProd(SB1->B1_COD,"B1_PE")/24)
						Case SB1->B1_TIPE == "S"
							dDataCmp -= (RetFldProd(SB1->B1_COD,"B1_PE") * 7)
						Case SB1->B1_TIPE == "M"
							dDataCmp -= (RetFldProd(SB1->B1_COD,"B1_PE") * 30)
						Case SB1->B1_TIPE == "A"
							dDataCmp -= (RetFldProd(SB1->B1_COD,"B1_PE") * 365)
						OtherWise
							dDataCmp -= RetFldProd(SB1->B1_COD,"B1_PE")
					EndCase
					cRevAtual :=  IIF(lPCPREVATU , PCPREVATU(SB1->B1_COD), SB1->B1_REVATU )
					lRetOpc := MarkOpcPcp(IIf(lPreEstr,SGG->GG_COMP,SG1->G1_COMP),@cRet,aRetorOpc,IIf(lPreEstr,SGG->GG_COD,SG1->G1_COD),cProdAnt+IIf(lPreEstr,SGG->GG_COMP+SGG->GG_TRT,SG1->G1_COMP+SG1->G1_TRT),cProg,cOpcMarc,lVisual,nNivel,nQtdAx,dDataCmp,cRevAtual,lPreEstr,@lExisteOpc,nDecimais,lGeraOPI)
					If !lRetOpc
						nOpca := 0
					EndIf
					nNivel-=1
				EndIf
			EndIf
		Else
			If lPreEstr
				SGG->(MsGoto(aRegs[i,1]))
			Else
				SG1->(MsGoto(aRegs[i,1]))
			EndIf
			//If !lOpcPadrao
				// Adiciona no array que registra todos os niveis da estrutura
				AADD(aRetorOpc,{cProdAnt+IIf(lPreEstr,SGG->GG_COMP+SGG->GG_TRT,SG1->G1_COMP+SG1->G1_TRT),SG1->G1_GROPC+SG1->G1_OPC+"/"})
			//EndIf
		EndIf
	Next I
EndIf
RestArea(aArea)
Return nOpcA == 1

/*

Ŀ
Funo     SeleOpcPcp Autor Rodrigo de A. Sartorio Data  12/09/97 
Ĵ
Descrio  Retorna a selecao de opcionais de acordo com os parametros 
           recebidos.                                                 
Ĵ
Sintaxe    SeleOpcPcp(ExpN1)                                          
Ĵ
Parametros ExpN1 = Expressao numerica usada para indicar o tipo de    
           entrada de dados (1) Enchoice (2) GetDados (3) GetDB       
           (4) Get Fixo                                               
           ExpC2 = Nome do Programa                                   
           ExpC3 = Codigo do Produto                                  
           ExpL4 = Verifica se Produto e uma referencia               
           ExpC5 = Retorno com a string de opcionais                  
           ExpC6 = Opcionais marcados                                 
           ExpC7 = Campo com o nome do produto pai                    
           ExpL8 = Visualiza janela de selecao de opcionais           
Ĵ
 Uso       Generico                                                   
ٱ


*/
Function SeleOpcPcp(nTipo,cProg,cProd,lReferencia,cRet,cOpcMarc,cCampo,lVisual,nQtd,dDataVal,cRevisao,lPreEstr,mRet,nDecimais,lGeraOPI)
Local nz		:= 0
Local nPosOpc	:= 0
Local nPosMOpc	:= 0
Local cProduto	:= ""
Local cVarOpc	:= ""
Local cVarMOpc	:= ""
Local nEnd		:= ""
Local nEndOpc	:= 0
Local nEndMOpc	:= 0
Local cVar		:= ""
Local aTam		:= {}
Local aBack		:= {}
Local aArea		:= GetArea()
Local lSeleOpc	:= .T.
Local lRet		:= .T.
Local oModel    := FWModelActive()
Local lMVC 		:= oModel <> NIL .And. AllTrim(Upper(oModel:GetSource())) == AllTrim(Upper(cProg))
Local oView
Local lMark		:= .F.
Local aFields

//Ŀ
//| Parametro utilizado para indicar se permite repetir o mesmo grupo de    |
//| opcionais em varios niveis ou nao.                                      |
//
Local lOpcPadrao:= GetNewPar("MV_REPGOPC","N") == "N"

//Ŀ
//| Ponto de entrada utilizado para inibir a tela de selecao de opcionais.  |
//
Local lMTSeleOp := ExistBlock("MTSELEOP")

Default cRet	  :=""
Default cOpcMarc  :=""
Default lVisual   :=.F.
Default cCampo    :=ReadVar()
Default nQtd 	  :=0
Default lPreEstr  :=.F.
Default mRet      := ""
Default nDecimais := TamSX3("D4_QUANT")[2]
Default lGeraOPI  := SuperGetMV("MV_GERAOPI")

cProg       := If(cProg		 	== NIL, "", cProg)
lReferencia := If(lReferencia	== NIL, .F., lReferencia)
cProduto	:= If(cProd			== NIL,&(ReadVar()),cProd)

IF empty(dDataVal) .AND. cProg == "MATA650" .and. SB1->B1_GRADE == "S"
	dDataVal := dDataBase
EndIf

//Ŀ
//| Caso nao exista cria array que registra todos os niveis da estrutura    |
//
If Type("aRetorOpc") <> "A"
	aRetorOpc:={}
EndIf

If cProg $ "MATA010|MATA010M|MATA018"
	lRet     := .F.
	If cProg == "MATA010" .Or. cProg == "MATA010M"
		cCampo := "M->B1_COD"
	Else
		cCampo := "M->BZ_COD"
	EndIf
	cProduto :=  cProd
EndIf

//Ŀ
// Verifica atraves de parametro se deve ou nao verificar      
// cadastramento de opcionais                                  
//
If !(GetMV("MV_SELEOPC",.T.)) .Or. (GetMV("MV_SELEOPC",.T.) .And. GetMV("MV_SELEOPC") == "S")
	If	lMTSeleOp
		lSeleOpc:= ExecBlock("MTSELEOP",.F.,.F.,{cRet,cProd,cProg})
	EndIf
	If lSeleOpc
		//Ŀ
		// Define qual campo deve ser atualizado                       
		//
		If cMODULO = "EEC"
			cVarOpc  := Substr(cCAMPO,4,AT("_",cCAMPO)-3)+"OPC"
			cVarMOpc := Substr(cCAMPO,4,AT("_",cCAMPO)-3)+"MOP"
		Else
			cVarOpc  := Substr(cCampo,4,AT("_",cCAMPO)-3)+"OPC"
			cVarMOpc := Substr(cCampo,4,AT("_",cCAMPO)-3)+"MOPC"
		EndIf
		aTam     := TAMSX3(cVarOpc)
		cVarOpc  := cVarOpc+Space(10-Len(cVarOpc))
		cVarMOpc := cVarMOpc+Space(10-Len(cVarMOpc))

		cVar := Iif(lOpcPadrao,cVarOpc,cVarMOpc)

		//Ŀ
		// Verifica se os campos estao em uso                          
		//
		// Selecao em Enchoice
		If lMVC
			oView := FWViewActive()
			If oView <> NIL
				aFields := oView:GetListFields()
				If aScan(aFields, {|x| AllTrim(Upper(x[2])) == AllTrim(Upper(cVarOpc)) }) > 0 .Or. aScan(aFields, {|x| AllTrim(Upper(x[2])) == AllTrim(Upper(cVarMOpc)) }) > 0
					lMark := .T.
				EndIf
			EndIf
		Else
			If nTipo == 1
				nEnd     := Ascan(aGets,{ |x| Substr(x,9,10) == Iif(lOpcPadrao,cVarOpc,cVarMOpc )} )
				nEndOpc  := Ascan(aGets,{ |x| Substr(x,9,10) == cVarOpc  } )
				nEndMOpc := Ascan(aGets,{ |x| Substr(x,9,10) == cVarMOpc } )
				If nEndOpc > 0 .Or. nEndMOpc > 0
					lMark := .T.
				EndIf
				// Selecao em GetDados ou Selecao em GetDb
			ElseIf nTipo == 2 .Or. nTipo == 3
				// Obtem posicao dos opcionais em caso de GetDados
				nPosOpc  := Ascan(aHeader,{ |x| x[2] == cVarOpc  })
				nPosMOpc := Ascan(aHeader,{ |x| x[2] == cVarMOpc })
				If nPosOpc > 0 .Or. nPosMOpc > 0
					lMark := .T.
				EndIf
				// Selecao em Get Fixo
			ElseIf nTipo == 4
				lMark := .T.
			EndIf
		EndIf

		If lMark
			// Funcao recursiva para selecao de opcionais
			lExisteOpc := .F.

			If Empty(cRevisao)
				cRevisao := CriaVar("B1_REVATU")
				If cProg # "MATA650"
					cRevisao := PCPREVATU(cProduto)
				EndIf
			EndIf

			lRet:=MarkOpcPcp(cProduto,@cRet,aRetorOpc,"",cProduto,cProg,cOpcMarc,lVisual,1,nQtd,dDataVal,cRevisao,lPreEstr,@lExisteOpc,nDecimais,lGeraOPI)

			IF !lExisteOpc
				cRet := ""
				aRetorOpc := {}
			EndIF

		EndIf
		//Ŀ
		// Grava no array somente a arvore dos itens que tem opcional  
		//
		If Len(aRetorOpc) > 0 .And. !lOpcPadrao
			aBack:=ACLONE(aRetorOpc)
			aRetorOpc:={}
			For nz:=1 to Len(aBack)
				If !Empty(aBack[nz,2])
					AADD(aRetorOpc,aBack[nz])
				EndIf
			Next nz
		EndIf
		//Ŀ
		// Preenche o conteudo dos campos com os opcionais selecionados
		//
		If !lVisual
			If ((!Empty(cRet) .And. lOpcPadrao) .Or. (Len(aRetorOpc) > 0 .And. !lOpcPadrao ) .Or. (nTipo == 2 .And. !Empty(cRet)) )
				// Selecao em Enchoice
				If lMVC
					//Verifica se existe o campo _OPC no modelo para atribuir o valor.
					If !Empty(FwFindId(cVarOpc))
						FWFldPut(cVarOpc,PADR(cRet,aTam[1]),,oModel,.F., .T.)
					EndIf
					//Verifica se existe o campo _MOPC no modelo para atribuir o valor.
					If !Empty(FwFindId(cVarMOpc))
						FWFldPut(cVarMOpc,Array2STR(aRetorOpc,.F.),,oModel,.F., .T.)
					EndIf
				Else
					// Selecao em Enchoice
					If nTipo == 1
						If cMODULO = "EEC"
							&(Substr(cCampo,1,7)+"OPC"):=PADR(cRet,TamSX3(Substr(cCAMPO,4,AT("_",cCAMPO)-3)+"OPC")[1])
							cVar := Substr(cCAMPO,4,AT("_",cCAMPO)-3)+"MOP"
							SX3->(dbSetOrder(2))
							If SX3->(dbSeek(cVar))
								&(Substr(cCampo,1,7)+"MOPC"):=Array2STR(aRetorOpc,.F.)
							EndIf
						Else
							&(Substr(cCampo,1,6)+"OPC"):=PADR(cRet,TamSX3(Substr(cCampo,4,AT("_",cCAMPO)-3)+"OPC")[1])
							cVar := Substr(cCampo,4,AT("_",cCAMPO)-3)+"MOPC"
							SX3->(dbSetOrder(2))
							If SX3->(dbSeek(cVar))
								&(Substr(cCampo,1,6)+"MOPC"):=Array2STR(aRetorOpc,.F.)
							EndIf
						EndIf
						If nEndOpc > 0
							nEndOpcAT  := aScan(atela,{|x| Subs(x[5],2,2) == Subs(aGets[nEndOpc],1,2) })
							aTela[nEndOpcAT][Val(Subs(aGets[nEndOpc],3,1))*2] := cRET+Space(Len(aTela[nEndOpcAT][Val(Subs(aGets[nEndOpc],3,1))*2])-Len(cRet))
						EndIf
						If nEndMOpc > 0
							nEndMOpcAT := aScan(atela,{|x| Subs(x[5],2,2) == Subs(aGets[nEndMOpc],1,2) })
							aTela[nEndMOpcAT][Val(Subs(aGets[nEndMOpc],3,1))*2] := Array2STR(aRetorOpc,.F.)
						EndIf
						// Selecao em GetDados
					ElseIf nTipo == 2
						If nPosOpc > 0
							aCols[n,nPosOpc] := PADR(cRet,aTam[1])
						EndIf
						If nPosMOpc > 0 .and. len(aRetorOpc) > 0
							aCols[n,nPosMOpc] := Array2STR(aRetorOpc,.F.)
						EndIf
						// Selecao em GetDb
					ElseIf nTipo == 3
						If nPosMOpc > 0
							&("TMP1->"+cVarMOpc):= Array2STR(aRetorOpc,.F.)
						EndIf
						If nPosOpc > 0
							&("TMP1->"+cVarOpc):= PADR(cRet,aTam[1])
						EndIf
					EndIf
				EndIf
			EndIf
		EndIf
		RestArea(aArea)
	EndIf
EndIf
If Len(aRetorOpc) > 0
	mRet := Array2STR(aRetorOpc,.F.)
EndIf
lRefresh:=.T.
Return If(nTipo==4,cRet,lRet)

//-------------------------------------------------------------------
/*/{Protheus.doc} OpcSelPcp()
Verifica se o opcional foi selecionado para o componente/nivel atual.

@param cOpcMarc	- String com os opcionais selecionados.
@param cOpc		- Grupo+Opcional da tabela SGA.
@param cProdAnt	- String com os produtos da estrutura.
@param cCompTrt - Componente + sequncia da estrutura.

@author Lucas Konrad Frana
@since 02/09/2016
@version P12
@return lRet
/*/
//--------------------------------------------------------------------
Function OpcSelPcp(cOpcMarc, cOpc, cProdAnt, cCompTrt)

Local aOpc	     := Str2Array(cOpcMarc,.F.)
Local lOpcPadrao := SuperGetMV("MV_REPGOPC",.F.,"N") == "N"
Local lRet	     := .F.
Local lExiste    := .F.
Local nI	     := 0

If lOpcPadrao // MV_REPGOPC = No
	If (aOpc != Nil .And. Len(aOpc) > 0 .And. !Empty(aOpc[1]))  // Existe registro no array aOpc
		If VALTYPE(aOpc[1]) == "A" // Existe a segunda opo no array aOpc
			lExiste := .T.
		EndIf
	EndIf
EndIf

If ((aOpc != Nil .And. Len(aOpc) > 0 .And. !Empty(aOpc[1])) .And. !lOpcPadrao) .Or. lExiste
	For nI := 1 To Len(aOpc)
		If aOpc[nI,1] == cProdAnt + cCompTrt
			If cOpc $ aOpc[nI,2]
				lRet := .T.
			EndIf
			Exit
		EndIf
	Next nI
Else
	lRet := cOpc $ cOpcMarc
EndIf

Return lRet

/*/{Protheus.doc} PCPPergSB1
Funo para validar se o produto tem estrutura ou pr-estrutura
Uso: Consulta Padro SB1CMP

@author brunno.costa
@since 08/10/2018
@version 12

@param nOpcao, numrico, indica:
- 1 para verificar se o produto possui estrutura
- 2 para verificar se o produto possui pr-estrutura
- 3 para indicar o nome da consulta padro a ser utilizada - PCPA135
@param cVarRef   , caracter, indica o nome da varivel de referncia                                  - 'nOpcao = 3'
@param nDefPre   , numrico, contedo utilizado para comparao com cVarRef em caso de Pr-Estrutura  - 'nOpcao = 3'
@param nDefEstr  , numrico, contedo utilizado para comparao com cVarRef em caso de Estrutura      - 'nOpcao = 3'
@param lConsCpos , logico, indica se avalia (pr-)estrutura com base em campos relacionados da SB1    - 'nOpcao = 1 ou 2'
@param lMsSeekBco, logico, indica se avalia os registros da SB1 vlidos com base em MsSeek na SG1/SGG - 'nOpcao = 1 ou 2'
							true  = usa MsSeek
							false = usa DbUseArea
@return lRet , Lgico  , Caso .T. adiciona o registro, caso .F. registro no  mostrado.
@type function
/*/
//-------------------------------------------------------------------
Function PCPPergSB1(nOpcao, cVarRef, nDefPre, nDefEstr, lConsCpos, lMsSeekBco)

	Local aAreaOLD
	Local cProduto 	   := SB1->B1_COD
	Local oReturn
	Local cBanco        := TCGetDB()

	Default cVarRef    := "MV_PAR01"
	Default nDefPre    := 1
	Default nDefEstr   := 2
	Default lConsCpos  := .T.
	Default lMsSeekBco := .T.
	Default lAutomacao := .F.

	If nOpcao == 1
		oReturn  	:= .T.
		If !lConsCpos .OR. (Empty(SB1->B1_REVATU) .AND. Empty(SB1->B1_UREV) .AND. SB1->B1_QB == 0)
			If lMsSeekBco
				If !SG1->(MsSeek(xFilial("SG1") + cProduto)) // Verifica se o produto tem estrutura.
					oReturn := .F.
				EndIf
			Else
				IF cBanco == "MSSQL"
					cQuery :=  " SELECT TOP 1 G1_COD "
				Else
					cQuery :=  " SELECT G1_COD "
				EndIf
				cQuery +=  " FROM " + RetSqlName("SG1")
				cQuery +=  " WHERE D_E_L_E_T_=' ' "
				cQuery +=        " AND G1_FILIAL ='" + xFilial("SG1", SB1->B1_FILIAL) + "' "
				cQuery +=        " AND G1_COD ='" + SB1->B1_COD + "' "
				IF cBanco == "ORACLE"
					cQuery +=        " AND ROWNUM = 1 "
				ElseIF cBanco == "POSTGRES"
					cQuery +=        " ORDER BY 1 LIMIT 1 "
				EndIf
				dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),"SB1SG1",.F.,.F.)
				dbSelectArea("SB1SG1")
				If SB1SG1->(Eof())
					oReturn := .F.
				EndIf
				SB1SG1->(dbCloseArea())
			EndIf
		EndIf
		DbSelectArea("SB1") //Retorna Alias SB1 como ativo para evitar error.log

	ElseIf nOpcao == 2
		oReturn  	:= .T.
		If !lConsCpos .OR. SB1->B1_QBP == 0
			If lMsSeekBco
				If !SGG->(MsSeek(xFilial("SGG") + cProduto)) // Verifica se o produto tem pr-estrutura.
					oReturn := .F.
				EndIf
			Else
				IF cBanco == "MSSQL"
					cQuery :=  " SELECT TOP 1 GG_COD "
				Else
					cQuery :=  " SELECT GG_COD "
				EndIf
				cQuery +=  " FROM " + RetSqlName("SGG")
				cQuery +=  " WHERE D_E_L_E_T_=' ' "
				cQuery +=        " AND GG_FILIAL ='" + xFilial("SGG", SB1->B1_FILIAL) + "' "
				cQuery +=        " AND GG_COD ='" + SB1->B1_COD + "' "
				IF cBanco == "ORACLE"
					cQuery +=        " AND ROWNUM = 1 "
				ElseIF cBanco == "POSTGRES"
					cQuery +=        " ORDER BY 1 LIMIT 1 "
				EndIf
				dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),"SB1SGG",.F.,.F.)
				dbSelectArea("SB1SGG")
				If SB1SGG->(Eof())
					oReturn := .F.
				EndIf
				SB1SGG->(dbCloseArea())
			EndIf
		EndIf
		DbSelectArea("SB1") //Retorna Alias SB1 como ativo para evitar error.log

	ElseIf nOpcao == 3
		If ValType(&(cVarRef)) == "N"
			If &(cVarRef) == nDefPre
				If lMsSeekBco
					aAreaOLD 	:= SGG->(GetArea()) // Salva rea posicionada.
					dbSelectArea("SGG")
					SGG->(dbSetOrder(1))
				EndIf
				If !lAutomacao
					oReturn := ConPad1(,,,"SB1PGG")
				Endif
				If lMsSeekBco
					RestArea(aAreaOLD) // Retorna rea salva.
				EndIf

			ElseIf &(cVarRef) == nDefEstr
				If lMsSeekBco
					aAreaOLD 	:= SG1->(GetArea()) // Salva rea posicionada.
					dbSelectArea("SG1")
					SG1->(dbSetOrder(1))
				EndIf
				If !lAutomacao
					oReturn := ConPad1(,,,"SB1PG1")
				EndIf
				If lMsSeekBco
					RestArea(aAreaOLD) // Retorna rea salva.
				EndIf

			EndIf
		Else
			If &(cVarRef) != "Estrutura"
				If lMsSeekBco
					aAreaOLD 	:= SGG->(GetArea()) // Salva rea posicionada.
					dbSelectArea("SGG")
					SGG->(dbSetOrder(1))
				EndIf
				If !lAutomacao
					oReturn := ConPad1(,,,"SB1PGG")
				EndIf
				If lMsSeekBco
					RestArea(aAreaOLD) // Retorna rea salva.
				EndIf

			Else
				If lMsSeekBco
					aAreaOLD 	:= SG1->(GetArea()) // Salva rea posicionada.
					dbSelectArea("SG1")
					SG1->(dbSetOrder(1))
				EndIf
				If !lAutomacao
					oReturn := ConPad1(,,,"SB1PG1")
				EndIf
				If lMsSeekBco
					RestArea(aAreaOLD) // Retorna rea salva.
				EndIf

			EndIf
		EndIf

	EndIf

Return oReturn

/*/{Protheus.doc} PCPExisCmp
Verifica se o componente faz parte da estrutura/pr-estrutura - Query's no banco
@author brunno.costa
@since 12/12/2018
@version 1.0
@param lPreEstrutura, lgico   , indicador lgico se o produto  de pr-estrutura
@param cProduto     , caracter , cdigo do produto a ser avaliado
@param cComponente  , caracter , cdigo do componente a ser avaliado
@param cRevisao     , caracter , cdigo da reviso do produto pai a ser avaliada
@param lGetPath     , lgico   , indica se retorna por referncia os caminhos
@param aPaths       , array    , array com os caminhos do componente na estrutura, retorno por referncia
                                 aPaths[x] := {Path, Componente, Nivel}
@return Nil
/*/
Function PCPExisCmp(lPreEstrutura, cProduto, cComponente, cRevisao, lGetPath, aPaths)

	Local aArea        := GetArea()
	Local aAreaSB1     := SB1->(GetArea())
	Local cAliasTop    := GetNextAlias()
	Local cAliasSelect := Iif(lPreEstrutura, RetSqlName( "SGG" ), RetSqlName( "SG1" ))
	Local cBanco       := TCGetDB()
	Local cJoinRecur   := ""
	Local cQuery       := ""
	Local cQueryBase   := ""
	Local cWherePai    := ""
	Local cWhereSB1    := "" 
	Local lReturn      := .F.


	Default lPreEstrutura := .T.
	Default cProduto      := ""
	Default cComponente   := ""
	Default cRevisao      := Posicione("SB1",1,xFilial("SB1")+cProduto,"B1_REVATU")
	Default lGetPath      := .F.
	Default aPaths        := {}

	If !Empty(cProduto) .and. !Empty(cComponente)

		//Prepara trechos exclusivos para SG1
		If !lPreEstrutura
			cWherePai  := " AND G1_REVINI <= '" + cRevisao + "' AND G1_REVFIM >= '" + cRevisao + "' "

			cJoinRecur := " INNER JOIN " + RetSqlName( "SB1" ) + " b1 "
			cJoinRecur += "     ON b1.B1_COD = rec.G1_COD "
			cJoinRecur += "     AND b1.B1_REVATU BETWEEN rec.G1_REVINI AND rec.G1_REVFIM "

			cWhereSB1 := "      AND  b1.B1_FILIAL = '" + xFilial("SB1") + "' "
			cWhereSB1 += "      AND  b1.D_E_L_E_T_ = ' '  "

		EndIf

		//Cria Query base para todos os bancos
		cQueryBase := " WITH EstruturaRecursiva(G1_COMP, G1_REVINI, G1_REVFIM, G1_COD, Nivel, Path)  "
		cQueryBase += " AS ( "
		cQueryBase += "     SELECT "
		cQueryBase += "         G1_COMP, "
		cQueryBase += " 		G1_REVINI, "
		cQueryBase += " 		G1_REVFIM, "
		cQueryBase += " 		G1_COD, "
		cQueryBase += " 		1 as Nivel, "
		cQueryBase += " 		Cast(G1_COMP AS VarChar(255)) AS Path "
		cQueryBase += "  	FROM " + cAliasSelect
		cQueryBase += "  	WHERE G1_COD = '" + cProduto + "' and D_E_L_E_T_ = ' ' "
		cQueryBase += "       AND G1_FILIAL = '" + xFilial("SG1") + "' "
		cQueryBase += cWherePai
		cQueryBase += "  	UNION ALL  "
		cQueryBase += "  	SELECT "
		cQueryBase += "  	    estrutura.G1_COMP, "
		cQueryBase += " 		estrutura.G1_REVINI, "
		cQueryBase += " 		estrutura.G1_REVFIM, "
		cQueryBase += " 		estrutura.G1_COD, "
		cQueryBase += "  	    rec.Nivel + 1 AS Nivel,  "
		cQueryBase += " 		Cast((rec.Path || '|' || estrutura.G1_COMP) AS VarChar(255)) Path   "
		cQueryBase += "  	FROM " + cAliasSelect + " estrutura "
		cQueryBase += "  	    INNER JOIN EstruturaRecursiva rec   "
		cQueryBase += "  	         ON estrutura.G1_COD = rec.G1_COMP  "
		cQueryBase += cJoinRecur
		cQueryBase += "  	WHERE rec.Path NOT LIKE '%|' || estrutura.G1_COMP || '%' "
		cQueryBase += "  	  AND estrutura.D_E_L_E_T_ = ' ' "
		cQueryBase += "  	  AND estrutura.G1_FILIAL = '" + xFilial("SG1") + "' "
		cQueryBase += cWhereSB1
		cQueryBase += "   ) "
		cQueryBase += " SELECT G1_COMP as Componente, Nivel, Path "
		cQueryBase += " FROM EstruturaRecursiva  "
		cQueryBase += " WHERE G1_COMP = '" + cComponente + "' "

		//Atribui Query Padro
		cQuery := cQueryBase

		//Realiza ajustes da Query para cada banco
		If cBanco == "ORACLE"

			//Limita a 1 registro
			If !lGetPath
				cQuery += "        AND ROWNUM = 1 "
			EndIf

			//Ordena por Path
			cQuery += "  ORDER BY 3 "

		ElseIf cBanco == "POSTGRES"

			//Altera sintaxe da clausula WITH
			cQuery := StrTran(cQuery, 'WITH ', 'WITH recursive ')

			//Ordena por Path
			cQuery += "  ORDER BY 3 "

			//Limita a 1 registro
			If !lGetPath
				cQuery += " LIMIT 1 "
			EndIf

			//Corrige Falhas internas de Binrio - POSTGRES
			cQuery := StrTran(cQuery,chr(13)," ")
			cQuery := StrTran(cQuery,chr(10)," ")
			cQuery := StrTran(cQuery,chr(09)," ")

		//ElseIf cBanco == "MSSQL"
		Else
			//Substitui concatenao || por +
			cQuery := StrTran(cQuery, '||', '+')

			//Limita a 1 registro
			If !lGetPath
				cQuery := StrTran(cQuery, 'G1_COMP as Componente', 'TOP 1 G1_COMP as Componente')
			EndIf

			//Ordena por Path
			cQuery += "  ORDER BY 3 "
		EndIf

		If lPreEstrutura
			cQuery := StrTran(cQuery, 'G1_', 'GG_')
		EndIf
	EndIf

	dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasTop,.T.,.T.)
	If !(cAliasTop)->(Eof())
		lReturn := .T.
	EndIf
	If lGetPath
		While !(cAliasTop)->(Eof())
			aAdd(aPaths, {(cAliasTop)->Path, (cAliasTop)->Componente, (cAliasTop)->Nivel})
			(cAliasTop)->(DbSkip())
		EndDo
	EndIf
	(cAliasTop)->(dbCloseArea())
	RestArea(aAreaSB1)
	RestArea(aArea)

Return lReturn

/*/{Protheus.doc} PCPCnvPerg
Converte a Pergunta SX1 em chamada ParamBox
@author brunno.costa
@since 12/12/2018
@version 1.0
@param cPergunta, caracter, cdigo da pergunta do configurador
@param lShow    , lgico  , indica se deve exibir a pergunta ou no
@param aOpcoes  , array   , array com as opes especiais para substituio do ParamBox
                  [1] Tipo do parametro
                   1 - MsGet
                     [2] : Descricao
                     [3] : String contendo o inicializador do campo
                     [4] : String contendo a Picture do campo
                     [5] : String contendo a validacao
                     [6] : Consulta F3
                     [7] : String contendo a validacao When
                     [8] : Tamanho do MsGet
                     [9] : Flag .T./.F. Parametro Obrigatorio ?
                   2 - Combo
                     [2] : Descricao
                     [3] : Numerico contendo a opcao inicial do combo
                     [4] : Array contendo as opcoes do Combo
                     [5] : Tamanho do Combo
                     [6] : Validacao
                     [7] : Flag .T./.F. Parametro Obrigatorio ?
					 [8] : String contendo a validacao When

					[***Demais opes no homologadas***]

@param lRecursiva, lgico  , indica chamada recursiva - recupera contedo anterior do MV_PAR
@param cTitulo   , caracter, ttulo que ser apresentado na tela
@param bOk       , bloco   , bloco de validao do boto ok
@param aButtons  , array   , array de botes conforme padro ParamBox
@param lCentered , lgico  , indica se a ParamBox ser aberta centralizada
@param nPosX     , numrico, indicador de posio X de abertura da ParamBox
@param nPosy     , numrico, indicador de posio Y de abertura da ParamBox
@param cLoad     , caracter, nome da rotina utilizada no ParamSave
@param lCanSave  , lgico  , indica se permite que o usurio administrador salve/bloqueie os parmetros padres
@param lUserSave , lgico  , indica se qualquer usurio permite salvar os parmetros padres (pr requisito lCanSave)
@return lReturn  , lgico  , indica se a tela de parmetros foi confirmada ou cancelada

Ao utilizar, CUIDADO com:
--> Tamanhos inicializadores padres e Pictures de campos get, necessrio repassar devido limitao da FwSX1Util();
--> Chamadas de CONSULTAS PADRES, necessrio repassar devido limitao da FwSX1Util();
--> Notar INEXISTNCIA de HELP;
/*/
Function PCPCnvPerg(cPergunta, lShow, aOpcoes, lRecursiva, cTitulo, bOk, aButtons, lCentered, nPosX, nPosy, cLoad, lCanSave, lUserSave)
	Local lReturn   := .T.
	Local aParamBox := {}
	Local oPergunta := FWSX1Util():New()
	Local oAux
	Local nInd
	Local aRet
	Local lOpc      := !Empty(aOpcoes)
	Local aCombo    := {}
	Local cTitPergun:= ""

	Default lRecursiva := .F.
	Default cTitulo    := STR0058 //"Parmetros:"
	DEFAULT bOk        := {|| (.T.)}
	DEFAULT aButtons   := {}
	DEFAULT lCentered  := .T.
	DEFAULT nPosX      := 0
	DEFAULT nPosY      := 0
	DEFAULT cLoad      := ProcName(1)
	DEFAULT lCanSave   := .F.
	DEFAULT lUserSave  := .F.
	DEFAULT lAutomacao := .F.

	//Recupera contedo anterior
	If lRecursiva
		For nInd := 1 to Len(aOpcoes)
			aOpcoes[nInd][3] := &("MV_PAR" + PadL(nInd, 2, '0'))
		Next nInd
	EndIf

	oPergunta:AddGroup(cPergunta)
	oPergunta:SearchGroup()
	oAux := oPergunta:aGrupo[1][2]

	For nInd := 1 to Len(oAux)
		cTitPergun := AllTrim(StrTran(oAux[nInd]:CX1_Pergunt, "?", ""))
		If oAux[nInd]:CX1_GSC == "G"	//GET
			If oAux[nInd]:CX1_TIPO == "C"		// Tipo caractere
				aAdd(aParamBox,{Iif(!lOpc .OR. aOpcoes[nInd][1] == Nil, 1             , aOpcoes[nInd][1]),;
								Iif(!lOpc .OR. aOpcoes[nInd][2] == Nil, cTitPergun    , aOpcoes[nInd][2]),;
								Iif(!lOpc .OR. aOpcoes[nInd][3] == Nil, Space(15)     , aOpcoes[nInd][3]),;
								Iif(!lOpc .OR. aOpcoes[nInd][4] == Nil, ""            , aOpcoes[nInd][4]),;
								Iif(!lOpc .OR. aOpcoes[nInd][5] == Nil, ""            , aOpcoes[nInd][5]),;
								Iif(!lOpc .OR. aOpcoes[nInd][6] == Nil, ""            , aOpcoes[nInd][6]),;
								Iif(!lOpc .OR. aOpcoes[nInd][7] == Nil, ""            , aOpcoes[nInd][7]),;
								Iif(!lOpc .OR. aOpcoes[nInd][8] == Nil, 100           , aOpcoes[nInd][8]),;
								Iif(!lOpc .OR. aOpcoes[nInd][9] == Nil, .F.           , aOpcoes[nInd][9])})

			ElseIf oAux[nInd]:CX1_TIPO == "N"	// Tipo numrico
				aAdd(aParamBox,{Iif(!lOpc .OR. aOpcoes[nInd][1] == Nil, 1             , aOpcoes[nInd][1]),;
								Iif(!lOpc .OR. aOpcoes[nInd][2] == Nil, cTitPergun    , aOpcoes[nInd][2]),;
								Iif(!lOpc .OR. aOpcoes[nInd][3] == Nil, 0             , aOpcoes[nInd][3]),;
								Iif(!lOpc .OR. aOpcoes[nInd][4] == Nil, "@E 99,999.99", aOpcoes[nInd][4]),;
								Iif(!lOpc .OR. aOpcoes[nInd][5] == Nil, ""            , aOpcoes[nInd][5]),;
								Iif(!lOpc .OR. aOpcoes[nInd][6] == Nil, ""            , aOpcoes[nInd][6]),;
								Iif(!lOpc .OR. aOpcoes[nInd][7] == Nil, ""            , aOpcoes[nInd][7]),;
								Iif(!lOpc .OR. aOpcoes[nInd][8] == Nil, 100           , aOpcoes[nInd][8]),;
								Iif(!lOpc .OR. aOpcoes[nInd][9] == Nil, .F.           , aOpcoes[nInd][9])})

			ElseIf oAux[nInd]:CX1_TIPO == "D"	// Tipo data
				aAdd(aParamBox,{Iif(!lOpc .OR. aOpcoes[nInd][1] == Nil, 1             , aOpcoes[nInd][1]),;
								Iif(!lOpc .OR. aOpcoes[nInd][2] == Nil, cTitPergun    , aOpcoes[nInd][2]),;
								Iif(!lOpc .OR. aOpcoes[nInd][3] == Nil, Ctod(Space(8)), aOpcoes[nInd][3]),;
								Iif(!lOpc .OR. aOpcoes[nInd][4] == Nil, ""            , aOpcoes[nInd][4]),;
								Iif(!lOpc .OR. aOpcoes[nInd][5] == Nil, ""            , aOpcoes[nInd][5]),;
								Iif(!lOpc .OR. aOpcoes[nInd][6] == Nil, ""            , aOpcoes[nInd][6]),;
								Iif(!lOpc .OR. aOpcoes[nInd][7] == Nil, ""            , aOpcoes[nInd][7]),;
								Iif(!lOpc .OR. aOpcoes[nInd][8] == Nil, 50            , aOpcoes[nInd][8]),;
								Iif(!lOpc .OR. aOpcoes[nInd][9] == Nil, .F.           , aOpcoes[nInd][9])})
			EndIf
		EndIf

		If oAux[nInd]:CX1_GSC == "C"	//COMBO
			aCombo := {}
			aAdd(aCombo, oAux[nInd]:CX1_DEF01)
			aAdd(aCombo, oAux[nInd]:CX1_DEF02)
			If !Empty(oAux[nInd]:CX1_DEF03)
			 	aAdd(aCombo, oAux[nInd]:CX1_DEF03)
			EndIf
			If !Empty(oAux[nInd]:CX1_DEF04)
			 	aAdd(aCombo, oAux[nInd]:CX1_DEF04)
			EndIf
			If !Empty(oAux[nInd]:CX1_DEF05)
			 	aAdd(aCombo, oAux[nInd]:CX1_DEF05)
			EndIf
			If aOpcoes[nInd][4] == Nil .OR. Empty(aOpcoes[nInd][4])
				aOpcoes[nInd][4] := aClone(aCombo)
			Endif

			aAdd(aParamBox,{Iif(!lOpc .OR. aOpcoes[nInd][1] == Nil, 2             , aOpcoes[nInd][1]),;
							Iif(!lOpc .OR. aOpcoes[nInd][2] == Nil, cTitPergun    , aOpcoes[nInd][2]),;
							Iif(!lOpc .OR. aOpcoes[nInd][3] == Nil, 1             , aOpcoes[nInd][3]),;
							Iif(!lOpc .OR. aOpcoes[nInd][4] == Nil, aCombo        , aOpcoes[nInd][4]),;
							Iif(!lOpc .OR. aOpcoes[nInd][5] == Nil, 100           , aOpcoes[nInd][5]),;
							Iif(!lOpc .OR. aOpcoes[nInd][6] == Nil, ""            , aOpcoes[nInd][6]),;
							Iif(!lOpc .OR. aOpcoes[nInd][7] == Nil, .F.           , aOpcoes[nInd][7]),;
							Iif(!lOpc .OR. aOpcoes[nInd][8] == Nil, Nil           , aOpcoes[nInd][8]),;
							Iif(!lOpc .OR. aOpcoes[nInd][9] == Nil, Nil           , aOpcoes[nInd][9])})
		EndIf

	Next nInd
	If !lAutomacao
		lReturn := ParamBox(aParamBox, cTitulo, @aRet, bOk, aButtons, lCentered, nPosX, nPosy, Nil /*oDlgWizard*/, cLoad, lCanSave, lUserSave)
	Else
		aRet := {}
	EndIf
	If lReturn
		//Corrige Contedo Numrico de Retorno dos Combos
		For nInd := 1 to Len(aRet)
			If oAux[nInd]:CX1_GSC == "C";
				.AND. ValType(&("MV_PAR" + PadL(nInd, 2, '0'))) != "N";
				.AND. aOpcoes[nInd][4] != Nil;
				.AND. !Empty(aOpcoes[nInd][4])

				If oAux[nInd]:CX1_TIPO == "N"
					&("MV_PAR" + PadL(nInd, 2, '0')) := aScan(aOpcoes[nInd][4], {|x| AllTrim(x) == AllTrim(aRet[nInd])})
				Else
					&("MV_PAR" + PadL(nInd, 2, '0')) := cValToChar(aScan(aOpcoes[nInd][4], {|x| AllTrim(x) == AllTrim(aRet[nInd])}))
				EndIf
			EndIf
		Next nInd
	EndIf

Return lReturn

/*/{Protheus.doc} PCPa650PPI

Realiza a integrao com o PC-Factory - PPI Multitask

@param 01 cXml     , Caracter, XML que ser enviado. Caso no seja passado esse parametro, ser realizada
                                a chamada do Adapter para criao do XML.
                                Se for passado esse parmetro, no ser exibida a mensagem de erro caso exista,
                                nem ser considerado o filtro da tabela SOE.
@param 02 cOp      , Caracter, Obrigatrio quando utilizado o parmetro cXml. Contm o cdigo da OP (NUM+ITEM+SEQUEN)
@param 03 lTable   , Logic   , Indica se ser utilizado variveis de memria ou do registro posicionado para recuperar os valores.
                                 .T. -> (SC2->C2_NUM)
                                 .F. -> (M->C2_NUM)
@param 04 lPendAut , Logic   , Indica se ser gerada a pendncia sem realizar a pergunta para o usurio, caso ocorra algum erro.
@param 05 lExclusao, Logic   , Indica se est chamando para rotina de excluso.
@param 06 lFiltra  , Logic   , Identifica se ser realizado ou no o filtro do registro.
@param 07 lInCustom, Logic   , Identifica execuo para customizao. No valida rotina permitida para executar 
                               a integrao e adiciona protees de interface. 
                               USO EXCLUSIVO PARA CUSTOMIZAES. FONTE PADRO ESTE PARMETRO DEVE SER SEMPRE .F.

@author  Lucas Konrad Frana
@version P12
@since   02/09/2015
@return lRet, Logic, Indica se a integrao com o PC-Factory foi realizada.
           .T. -> Integrao Realizada
           .F. -> Integrao no realizada.
/*/
Function PCPa650PPI(cXml, cOp, lTable, lPendAut, lExclusao, lFiltra, lInCustom)
	Local aArea      := GetArea()
	Local aRetArq    := {}
	Local aRetData   := {}
	Local aRetWS     := {}
	Local aRetXML    := {}
	Local aRotinas   := {}
	Local aRetLite   := {.T., .F.}
	Local cIntMrp    := Iif(Type('cIntgPPI')=="C",cIntgPPI,"1")
	Local cGerouXml  := ""
	Local cNomeXml   := ""
	Local cOperacao  := ""
	Local cPont      := "M"
	Local cRoteiro   := ""
	Local cFunMenu   := AllTrim(FunName())
	Local lMRP       := .F.
	Local lSoPend    := .F.
	Local lRet       := .T.
	Local lBkpInc    := Iif(Type('INCLUI') == "L", INCLUI, Nil)
	Local lBkpAlt    := Iif(Type('ALTERA') == "L", ALTERA, Nil)
	Local lBkpReset  := .F.
	Local lLite      := .F.
	Local lForceDel  := .F.

	//Varivel utilizada para identificar que est sendo executada a integrao para o PPI dentro do MATI650.
	Private lRunPPI   := .T.
	Private cPonteiro := ""

	Default cXml      := ""
	Default cOp       := ""
	Default lTable    := .F.
	Default lPendAut  := .F.
	Default lExclusao := .F.
	Default lFiltra   := .T.
	Default lInCustom := .F.

	//Verificao se  MES LITE.
	PCPIntgPPI("SC2", @lLite)

	If !lLite
		aAdd(aRotinas,"MATA380")
		aAdd(aRotinas,"MATA381")
		aAdd(aRotinas,"MATA690")
		aAdd(aRotinas,"MATA712")
		aAdd(aRotinas,"SFCA310")
		aAdd(aRotinas,"PCPA107")
		aAdd(aRotinas,"PCPA146")
		aAdd(aRotinas,"MATA637")
	EndIf

	aAdd(aRotinas,"MATA650")
	aAdd(aRotinas,"MATA651")
	aAdd(aRotinas,"PCPA111")
	aAdd(aRotinas,"PCPA110")
	aAdd(aRotinas,"PCPA124")
	aAdd(aRotinas,"PCPA114")
	aAdd(aRotinas,"PCPA145")

	//Neste momento, no ir realizar a integrao com as ordens que so geradas
	//a partir do MRP, por questo de performance.
	//A integrao das ordens geradas pelo MRP ser realizada posteriormente, em uma thread separada.
	If lInCustom == .F. .And. ;
	   ((Type('lProj711') == "L" .And. lProj711 == .T.) .Or.;
	    (aScan(aRotinas,{|x| x == cFunMenu}) <= 0 .AND. !(Type('l650Auto') == "L" .And. l650Auto)))
		Return .T.
	EndIf

	If cFunMenu $ "MATA712|PCPA107|PCPA146|PCPA145"
		lMRP    := .T.
		lSoPend := cIntMrp == "2"
	EndIf

	//Se est executando o MRP, e o parmetro est configurado para no integrar, no faz nada.
	If lMRP .And. cIntMrp == "1"
		Return .T.
	EndIf

	If lBkpInc == Nil .Or. lBkpAlt == Nil
		INCLUI    := .F.
		ALTERA    := .T.
		lBkpReset := .T.
	EndIf

	If lTable
		cPont := "SC2"
	Else
		cPont := "M"
	EndIf

	If lInCustom
		//Executando via customizao, fora gerao automtica de pendncia.
		lPendAut := .T.
	EndIf

	cPonteiro := cPont

	If Empty(cXml)
		If lExclusao
			cOperacao := Lower(STR0064) //"excluir"
		Else
			If INCLUI
				cOperacao := Lower(STR0062) //"incluir"
			Else
				cOperacao := Lower(STR0063) //"alterar"
			EndIf
		EndIf
		cOp := &(cPont+'->(C2_NUM+C2_ITEM+C2_SEQUEN+C2_ITEMGRD)')
	ElseIf PCPEvntXml(cXml, lLite) == "delete"
		lExclusao := .T.
	EndIf

	//Execuo de integrao da excluso de OP, recebendo os dados de integrao (cxml).
	//Indica que a SC2 j foi apagada, e deve apenas executar a integrao dessa OP sem buscar nada na SC2.
	lForceDel := lLite .And. lExclusao .And. !Empty(cXml)

	If lExclusao
		INCLUI    := .F.
		ALTERA    := .F.
		lBkpReset := .T.
	EndIf

	If lLite
		aRetLite := totvs.protheus.manufacturing.meslite.productionorder.integraOrdem(cOp, cPont, lExclusao, lPendAut, cOperacao, lForceDel, lSoPend, lFiltra, cXml)
		lRet     := aRetLite[1]
	EndIf

	//Realiza filtro na tabela SOE, para verificar se a ordem de produo entra na integrao.
	If !lLite .And. (!Empty(cXml) .Or. !lFiltra .Or. (filtraPrd(&(cPont + "->C2_PRODUTO")) .And. PCPFiltPPI("SC2", cOp, cPont)))
		If Empty(cXml) .And. Empty(&(cPont+'->C2_ROTEIRO')) .And. !lExclusao
			If lPendAut .Or. (Type('l650Auto') == "L" .And. l650Auto)
				dbSelectArea("SB1")
				SB1->(dbSetOrder(1))
				If SB1->(dbSeek(xFilial("SB1")+&(cPont+'->C2_PRODUTO')))
					cRoteiro := Iif(Empty(SB1->B1_OPERPAD),"01",SB1->B1_OPERPAD)
					If cPont == "SC2"
						RecLock("SC2",.F.)
							SC2->C2_ROTEIRO := cRoteiro
						SC2->(MsUnLock())
					Else
						&(cPont+'->C2_ROTEIRO') := cRoteiro
					EndIf
				EndIf
			Else
				Aviso(STR0065,STR0066,{"Ok"},2) //"Roteiro no informado. Para ordens de produo que so integradas com o TOTVS MES este campo  obrigatrio."
				lRet := .F.
			EndIf
		EndIf

		If lRet
			//Adapter para criao do XML
			If Empty(cXml)
				aRetXML := MATI650("", TRANS_SEND, EAI_MESSAGE_BUSINESS,"2.004")
			Else
				aRetXML := {.T.,cXml}
			EndIf
			/*
			aRetXML[1] - Status da criao do XML
			aRetXML[2] - String com o XML
			*/

			If aRetXML[1]
				//Retira os caracteres especiais
				aRetXML[2] := EncodeUTF8(aRetXML[2])

				//Se est realizando a excluso das ops previstas pelo MRP, apenas salva o XML para processar
				//posteriormente. Isso  feito para no afetar muito na performance do MRP.
				If lMRP .And. IsInCallStack("MTApagaPre")
					aAdd(aDelOpsPPI,{aRetXML[2],cOp})
					Return .T.
				EndIf

				//Busca a data/hora de gerao do XML
				aRetData := PCPxDtXml(aRetXML[2])
				/*
					aRetData[1] - Data de gerao AAAAMMDD
					aRetData[1] - Hora de gerao HH:MM:SS
				*/

				//Envia o XML para o PCFactory
				If lMRP .And. cIntMrp == "2"
					aRetWS := {"2",STR0067} //"Pendente processamento MRP."
				Else
					aRetWS := PCPWebsPPI(aRetXML[2])
				EndIf
				/*
					aRetWS[1] - Status do envio (1 - OK, 2 - Pendente, 3 - Erro.)
					aRetWS[2] - Mensagem de retorno do PPI
				*/
				If aRetWS[1] != "1" .And. Empty(cXml)
					If lPendAut .Or. (Type('l650Auto') == "L" .And. l650Auto) .Or. lMRP
						lRet := .T.
					Else
						//"Ateno! Ocorreram erros na integrao com o TOTVS MES. Erro: "
						// XXXXXX
						// XXXXXX
						// "Deseja incluir/alterar/excluir a ordem de produo no protheus e gerar pendncia para integrao?"
						If !MsgYesNo(STR0068 + AllTrim(aRetWS[2]) +CHR(10)+;
									STR0069 + AllTrim(cOperacao) +STR0070)
							lRet := .F.
						EndIf
					EndIf
				EndIf

				If lRet
					//Cria o XML fisicamente no diretrio parametrizado
					aRetArq := PCPXmLPPI(aRetWS[1],"SC2",cOp,aRetData[1],aRetData[2],aRetXML[2])
					/*
						aRetArq[1] Status da criao do arquivo. .T./.F.
						aRetArq[2] Nome do XML caso tenha criado. Mensagem de erro caso no tenha criado o XML.
					*/
					If !aRetArq[1]
						If Empty(cXml) .And. (!lPendAut .And. (Type('l650Auto') == "L" .And. !l650Auto))
							Alert(aRetArq[2])
						EndIf
					Else
						cNomeXml := aRetArq[2]
					EndIf

					If Empty(cNomeXml)
						cGerouXml := "2"
					Else
						cGerouXml := "1"
					EndIf

					//Cria a tabela SOF
					PCPCriaSOF("SC2",cOp,aRetWS[1],cGerouXml,cNomeXml,aRetData[1],aRetData[2],__cUserId,aRetWS[2],aRetXML[2])

					//Array com as ops intermedirias que tiveram erro.
					If Type('aIntegPPI') == "A"
						If aRetWS[1] != "1"
							aAdd(aIntegPPI,{cOp,aRetWS[2]})
						EndIf
					EndIf
				EndIf
			EndIf
		EndIf
	EndIf

	//Tratativa para retornar .F. mesmo quando  pendncia automtica;
	//Utilizado apenas para o programa de sincronizao, carga mquina e execuo customizada.
	If (lInCustom                     .Or. ;
	    cFunMenu == "PCPA111"         .Or. ;
		cFunMenu == "MATA690"         .Or. ;
		cFunMenu == "MATA381"         .Or. ;
		cFunMenu == "MATA380"         .Or. ;
		IsInCalLStack("SFCA315AV")    .Or. ;
		IsInCallStack("MATA637SC2") ) .And. ;
		( !lLite .And. (Len(aRetWS) > 0 .And. aRetWS[1] != "1") .Or.;
		   lLite .And. aRetLite[2] == .T.)
		lRet := .F.
	EndIf

	If lBkpReset
		ALTERA := lBkpAlt
		INCLUI := lBkpInc
	EndIf

	RestArea(aArea)

Return lRet

/*/{Protheus.doc} filtraPrd
Aplica filtro de produto na OP se parametrizado.
Chamada protegida para a funo do fonte manufacturing.meslite.productionorder

@type  Static Function
@author lucas.franca
@since 24/10/2024
@version P12
@param cProduto, Caracter, Cdigo do produto para filtro
@return lFiltOk, Logic, Indica se o filtro permite a integrao
/*/
Static Function filtraPrd(cProduto)
	Local lFiltOk := .T.

	If _lFilPrMES == Nil
		_lFilPrMES := tlpp.ffunc("totvs.protheus.manufacturing.meslite.productionorder.filtraProdutoNaOrdem", .F.)
	EndIf

	If _lFilPrMES
		lFiltOk := totvs.protheus.manufacturing.meslite.productionorder.filtraProdutoNaOrdem(cProduto)
	EndIf
Return lFiltOk

/*


Ŀ
Funcao    PCP650AvPV  Autor  Sergio S. Fuzinaka    Data  14.04.10 
Ĵ
Descricao Executa a avaliacao do Pedido de Venda.                     
                                                                      
Ĵ
 Uso      Generico                                                    
ٱ


*/
Function PCP650AvPV(lValQtd)
	Local aArea      := GetArea()
	Local aAreaSB2   := SB2->( GetArea() )
	Local aAreaSC2   := SC2->( GetArea() )
	Local aAreaSC6   := SC6->( GetArea() )
	Local aAreaSD3   := SD3->( GetArea() )
	Local cAliasQry  := ""
	Local cChkCols   := ""
	Local cChkOP     := ""
	Local cItemOP    := ""
	Local cItemOpAnt := ""
	Local cItemPV    := ""
	Local cLocal     := ""
	Local cNumOP     := ""
	Local cNumOpAnt  := ""	
	Local cNumPV     := ""
	Local cProduto   := ""
	Local cSequenOP  := ""
	Local lAltera    := Iif(Type('ALTERA') == "L", ALTERA, .T.)
	Local lAlterouOP := .F.
	Local lContinua  := .T.
	Local lExclui    := .T.
	Local lExcluiuOp := .F.

	Default lValQtd := .T.

	If SC6->C6_TPOP == "F" //OP Firme   	
       
	   //Se no tiver o nmero da OP preenchido  porque no vou gerada OP ainda para esse item do pedido
	   //ou o nmero da OP foi retirado (apagado) do pedido, sendo necessrio, nesse ltimo caso, desvincular a OP do pedido
	   If !Empty(SC6->C6_NUMOP) 

		    POSICIONE("SGJ",1,xFilial("SGJ")+SC6->(C6_NUM+C6_ITEM+C6_PRODUTO+C6_LOCAL)+SC2->(C2_NUM+C2_ITEM+C2_SEQUEN),"GJ_NUMOP")
			cNumPV    := SC6->C6_NUM
			cItemPV   := SC6->C6_ITEM
			cProduto  := SC6->C6_PRODUTO
			cLocal    := SC6->C6_LOCAL
			cNumOP    := SC6->C6_NUMOP
			cItemOP   := SC6->C6_ITEMOP

			If lValQtd			
				//Verifica a tabela SGJ - se no encontrar registro ou a quantidade for zero  porque foi alterada alguma informao 
				//da chave, e nesse caso dever excluir a OP (as variveis lExclui e lContinua j foram inicializadas com .T.)
				
				//Deve ser utilizado campo GJ_QEMPN onde  gravado a quantidade do pedido de venda.
				//Caso no momento da gerao da OP tenha saldo parcial em estoque, o GJ_QUANT ficar diferente do C6_QTDVEN
				//Quando o campo o GJ_QUANT  diferente do C6_QTDVEN, estava excluindo indevidamente a OP ao alterar o campo Qtd. Liberada no MATA410.
				cAliasQry := GetNextAlias()
				BeginSQL Alias cAliasQry			 
				 SELECT GJ_QEMPN AS SGJ_QEMPN
				   FROM %Table:SGJ% SGJ
				  WHERE SGJ.GJ_FILIAL  = %XFilial:SGJ%
				    AND SGJ.GJ_NUMPV   = %Exp:cNumPV%
				    AND SGJ.GJ_ITEMPV  = %Exp:cItemPV%
				    AND SGJ.GJ_PRODUTO = %Exp:cProduto%
				    AND SGJ.GJ_NUMOP   = %Exp:cNumOP%
				    AND SGJ.GJ_ITEMOP  = %Exp:cItemOP%
				    AND SGJ.%NotDel%
				EndSQL
				
				//Se encontrar registro e a quantidade da SGJ for igual a quantidade da SC6 quer dizer que no dever excluir a OP. 				
				//Se as quantidades foram diferentes, ento dever excluir, no sendo necessrio 
				//alterar os valores da variveis que j foram inicializadas com .T.
				If !(cAliasQry)->(Eof()) .And. (cAliasQry)->SGJ_QEMPN == SC6->C6_QTDVEN
					lExclui   := .F.
					lContinua := .F.
				ElseIf (cAliasQry)->(Eof()) .Or. (cAliasQry)->SGJ_QEMPN == 0 //se no encontrar registro, verifica se foi alterado no nmero da OP
					(cAliasQry)->(dbCloseArea())
				    cAliasQry := GetNextAlias()
			 		BeginSQL Alias cAliasQry
					 SELECT GJ_NUMOP, GJ_ITEMOP
				   	   FROM %Table:SGJ% SGJ
				  	  WHERE SGJ.GJ_FILIAL  = %XFilial:SGJ%
				    	AND SGJ.GJ_NUMPV   = %Exp:cNumPV%
				    	AND SGJ.GJ_ITEMPV  = %Exp:cItemPV%
				    	AND SGJ.GJ_PRODUTO = %Exp:cProduto%
				    	AND SGJ.%NotDel%
					EndSQL
                    
					//se foi alterado o nmero da OP (troca), na tabela SC6 j estar o nmero novo da OP
					//e a tabela SC2 j estar posicionada nessa nova OP, porm a SGJ estar com o nmero antigo
					While (cAliasQry)->(!Eof())
						cNumOpAnt  := (cAliasQry)->GJ_NUMOP
						cItemOpAnt := (cAliasQry)->GJ_ITEMOP
						(cAliasQry)->(dbSkip())
					End
					//Se encontrou para o pedido, item e produto um registro na tabela SGJ,  porque mudou a OP
					//nesse caso as variveis do nmero, item e sequncia da OP sero carregadas com as informaes 
					//anteriores  alteraa
					If !Empty(cNumOpAnt) .And. (cNumOpAnt != cNumOP .Or. cItemOpAnt != cItemOP)
					   cNumOP    := cNumOpAnt
					   cItemOP   := cItemOpAnt
					   lAlterouOP := .T.  //essa varivel identifica que houve troca de OP
					EndIf 
				EndIf
				(cAliasQry)->(dbCloseArea())
			EndIf

			//Verifica se tem quantidade produzida e se houver no exclui a OP
			If lContinua
				cAliasQry := GetNextAlias()
				BeginSQL Alias cAliasQry
				  SELECT 1
				    FROM %Table:SGJ% SGJ
				   INNER JOIN %Table:SC2% SC2
				      ON SC2.C2_FILIAL  = %XFilial:SC2%
				     AND SC2.C2_NUM     = SGJ.GJ_NUMOP
				     AND SC2.C2_ITEM    = SGJ.GJ_ITEMOP
				     AND SC2.C2_SEQUEN  = SGJ.GJ_SEQUEN
				     AND SC2.C2_ITEMGRD = SGJ.GJ_ITGRDOP
				   WHERE SGJ.GJ_FILIAL  = %XFilial:SGJ%
				     AND SGJ.GJ_NUMPV   = %Exp:cNumPV%
				     AND SGJ.GJ_ITEMPV  = %Exp:cItemPV%
				     AND SGJ.GJ_NUMOP   = %Exp:cNumOP%
				     AND SGJ.GJ_ITEMOP  = %Exp:cItemOP%
				     AND SC2.C2_QUJE    > 0
				     AND SGJ.%NotDel%
				     AND SC2.%NotDel%
				EndSQL
				If !(cAliasQry)->(Eof())
					lExclui   := .F.
					lContinua := .F.
				EndIf
				(cAliasQry)->(dbCloseArea())
			EndIf

			//Verifica se tem movimentao no estornada e se houver no exclui a OP
			If lContinua
				cAliasQry := GetNextAlias()
				BeginSQL Alias cAliasQry
				  SELECT 1
				    FROM %Table:SGJ% SGJ
				   INNER JOIN %Table:SD3% SD3
				      ON SD3.D3_FILIAL   = %XFilial:SD3%
				     AND SD3.D3_OP       = (SGJ.GJ_NUMOP || SGJ.GJ_ITEMOP || SGJ.GJ_SEQUEN || SGJ.GJ_ITGRDOP)
				   WHERE SGJ.GJ_FILIAL   = %XFilial:SGJ%
				     AND SGJ.GJ_NUMPV    = %Exp:cNumPV%
				     AND SGJ.GJ_ITEMPV   = %Exp:cItemPV%
				     AND SGJ.GJ_NUMOP    = %Exp:cNumOP%
				     AND SGJ.GJ_ITEMOP   = %Exp:cItemOP%
				     AND SD3.D3_ESTORNO  = ' '
				     AND SGJ.%NotDel%
				     AND SD3.%NotDel%
				EndSQL
				If !(cAliasQry)->(Eof())
					lExclui   := .F. 
					lContinua := .F.
				EndIf
				(cAliasQry)->(dbCloseArea())
			EndIf
            
			lExcluiuOp := .F.  //varivel criada para controle da troca de OP, j que a rotina automtica do MATA650 consegue excluir a OP, mas no a SGJ
			//Exclui todas as OPs originadas pelo pedido/item
			If lExclui
				cAliasQry := GetNextAlias()
				BeginSQL Alias cAliasQry
				  SELECT GJ_NUMOP, GJ_ITEMOP, GJ_SEQUEN, GJ_ITGRDOP
				    FROM %Table:SGJ% SGJ
				   WHERE SGJ.GJ_FILIAL  = %XFilial:SGJ%
				     AND SGJ.GJ_NUMOP   = %Exp:cNumOP%
				     AND SGJ.GJ_ITEMOP  = %Exp:cItemOP%
				     AND SGJ.%NotDel%
				EndSQL
 
				dbSelectArea("SC2")
				SC2->(dbSetOrder(1))

				While (cAliasQry)->(!Eof())
					If SC2->(dbSeek(xFilial("SC2") + (cAliasQry)->GJ_NUMOP + (cAliasQry)->GJ_ITEMOP + (cAliasQry)->GJ_SEQUEN + (cAliasQry)->GJ_ITGRDOP))
						POSICIONE("SGJ",1,xFilial("SGJ")+SC2->(C2_PEDIDO+C2_ITEMPV+C2_PRODUTO+C2_LOCAL+C2_NUM+C2_ITEM+C2_SEQUEN),"GJ_NUMOP")
						A650RotAut(5)
						lExcluiuOp := .T.  //identificou que a OP foi excluda
					EndIf
					(cAliasQry)->(dbSkip())
				End
				(cAliasQry)->(dbCloseArea())
			Endif
		EndIf
        
		//Aqui vai entrar caso a OP tenha sido apagada do pedido ou o nmero da OP tenha sido alterado e ela no tenha
		//sido excluda no processo acima por ter produo ou movimento no estornado, ou tenha sido excluda, porm sem excluir a SGJ,
		//esse caso ser excludo o registro do SGJ e desvinculado o pedido da OP
		If (Empty(SC6->C6_NUMOP) .And. !lExcluiuOp).Or. lAlterouOP

			If lAltera //S deve entrar aqui se for modificao ou excluso
				If !lAlterouOP //se no houve alterao do nmero da OP, recarrega as variveis, seno utiliza com as informaes da OP anterior carregada acima
					Restarea(aAreaSC2)
					cNumPV     := SC6->C6_NUM
					cItemPV    := SC6->C6_ITEM
					cProduto   := SC2->C2_PRODUTO
   				 	cNumOP     := SC2->C2_NUM
				 	cItemOP    := SC2->C2_ITEM
				 EndIf

				cAliasQry  := GetNextAlias()

				BeginSQL Alias cAliasQry
				  SELECT GJ_FILIAL, GJ_NUMPV, GJ_ITEMPV, GJ_PRODUTO, GJ_LOCAL, GJ_NUMOP, GJ_ITEMOP, GJ_SEQUEN, GJ_ITGRDOP
				    FROM %Table:SGJ% SGJ
				   WHERE SGJ.GJ_FILIAL  = %XFilial:SGJ%
				     AND SGJ.GJ_NUMPV   = %Exp:cNumPV%
					 AND SGJ.GJ_ITEMPV  = %Exp:cItemPV%
					 AND SGJ.GJ_PRODUTO = %Exp:cProduto%
					 AND SGJ.GJ_NUMOP   = %Exp:cNumOP%
					 AND SGJ.GJ_ITEMOP  = %Exp:cItemOP%
				     AND SGJ.%NotDel%
				EndSQL

				While (cAliasQry)->(!Eof())
					If SGJ->( dbSeek( xFilial("SGJ")+(cAliasQry)->(GJ_NUMPV+GJ_ITEMPV+GJ_PRODUTO+GJ_LOCAL+GJ_NUMOP+GJ_ITEMOP+GJ_SEQUEN) ) )
						cChkOP   := AllTrim( (cAliasQry)->(GJ_NUMOP + GJ_ITEMOP + GJ_SEQUEN) )
						cChkCols := Alltrim( aCols[1][aScan(aHeader,{|x| AllTrim(x[2])=="C6_NUMOP"})]+;
											 aCols[1][aScan(aHeader,{|x| AllTrim(x[2])=="C6_ITEMOP"})] + SC2->C2_SEQUEN) // DMANSMARTSQUAD1-28606 - Desvincula PV x OP
	                    
						//Se o nmero da OP estiver em branco ou tenha sido alterado o nmero por outro ento segue para excluso da SGJ
						If cChkOP != cChkCols .Or. lAlterouOP
							If SC2->(dbSeek(xFilial("SC2")+(cAliasQry)->(GJ_NUMOP + GJ_ITEMOP + GJ_SEQUEN)) )
								A650DelSGJ("I","D") //Exclui a SGJ e desvincula o pedido
							ElseIf lExcluiuOp  //se a OP foi excluda no processo acima (pela troca de nmero), no haver mais o registro na SC2
							    cSequenOP := (cAliasQry)->GJ_SEQUEN
							    dbSelectArea("SC6")
								SC6->(dbSetOrder(1))
								If SC6->(dbSeek(xFilial("SC6")+(cAliasQry)->(GJ_NUMPV + GJ_ITEMPV + GJ_PRODUTO)) )
								   A650DelSGJ("I","N",cSequenOP,cNumOP,cItemOP) //Exclui a SGJ e no desvincula (pq a OP j foi excluda)
								EndIf
							Endif
						Endif
					Endif
					(cAliasQry)->(dbSkip())
				EndDo
				(cAliasQry)->(dbCloseArea())
			EndIf
		Endif
	Endif

	RestArea(aArea)
	RestArea(aAreaSC2)
	RestArea(aAreaSC6)
	RestArea(aAreaSD3)
	RestArea(aAreaSB2)

Return


/*/{Protheus.doc} CalcEntreg
Varre a estrutura do produto e calcula o prazo de entrega, considerando
o maior tempo de determinado "n" da estrutura.

@author lucas.franca
@since 27/12/2018
@version P12
@param cProduto, character, Cdigo do produto da ordem de produo
@param nQuant  , numeric  , Quantidade da ordem de produo
@param dDataEnt, date     , Data de incio da ordem de produo
@return nMaxPrazo, numeric, Prazo total para entrega dos componentes.
/*/
Function PCPCalcEnt(cProduto,nQuant,dDataEnt)
	Local aArea      := GetArea()
	Local aAreaSG1	 := SG1->(GetArea())
	Local aEstrutura := {}
	Local cQuery     := ""
	Local cAliasTop  := "GETSTRUCT"
	Local cBanco     := TCGetDB()
	Local cArqProd   := SuperGetMV("MV_ARQPROD",.F.,"SB1")
	Local nIndEstru  := 0
	Local nIndReg    := 0
	Local nRegistro  := 0
	Local nMaxPrazo  := 0
	Local nPrazoEstr := 0
	Local nPrazo     := 0
	Local nQtdEstru  := 0
	Local dDataEstru := Date()
	Local lRevFil    := SuperGetMv("MV_REVFIL",.F.,.F.)

	Default dDataEnt := dDataBase

	dbSelectArea("SBZ")
	If !FieldPos("BZ_REVATU") > 0
		lRevFil := .F.
	EndIf

	cQuery :=  " WITH ALLESTRUTURAS(G1_COD,G1_COMP,CAMINHO) "
	cQuery +=    " AS (SELECT G1ANCORA.G1_COD, "
	cQuery +=               " G1ANCORA.G1_COMP, "
	cQuery +=               " CAST(G1ANCORA.R_E_C_N_O_ AS VARCHAR(1024)) AS CAMINHO "
	cQuery +=          " FROM " + RetSqlName("SG1") + " G1ANCORA "
	cQuery +=         " WHERE G1ANCORA.G1_FILIAL  = '"+ xFilial("SG1") +"'"
	cQuery +=           " AND G1ANCORA.D_E_L_E_T_ = ' ' "
	cQuery +=           " AND G1ANCORA.G1_COD     = '"+ cProduto +"'"
	cQuery +=           " AND G1ANCORA.G1_INI     <= '"+ DtoS(dDataBase) +"'"
	cQuery +=           " AND G1ANCORA.G1_FIM     >= '"+ DtoS(dDataBase) +"'"

	//Validao da reviso --- Os componentes devem estar dentro da reviso atual do produto PAI.
	If cArqProd == "SBZ" .And. lRevFil
		//Valida com a reviso atual da SB1 (B1_REVATU)
		cQuery +=       " AND ( "
		cQuery +=  ChangeQuery("SELECT ISNULL(SBZ.BZ_REVATU, SB1.B1_REVATU ) "               +;
		                       " FROM " + RetSqlName("SB1") + " SB1 "                        +;
							   " LEFT OUTER JOIN " + RetSqlName("SBZ") + " SBZ "             +;
							                " ON SBZ.BZ_FILIAL  = '" + xFilial("SBZ") + "' " +;
								           " AND SBZ.D_E_L_E_T_ = ' ' "                      +;
								           " AND SBZ.BZ_COD     = SB1.B1_COD "               +;
		                      " WHERE SB1.B1_FILIAL  = '" + xFilial("SB1") + "' "            +;
		                        " AND SB1.D_E_L_E_T_ = ' ' "                                 +;
		                        " AND SB1.B1_COD     = G1ANCORA.G1_COD ")
		cQuery +=           " ) "
		cQuery += " BETWEEN G1ANCORA.G1_REVINI AND G1ANCORA.G1_REVFIM "
	Else
		//Valida com a reviso atual da SB1 (B1_REVATU)
		cQuery +=       " AND (SELECT SB1.B1_REVATU "
		cQuery +=              " FROM " + RetSqlName("SB1") + " SB1 "
		cQuery +=             " WHERE SB1.B1_FILIAL  = '" + xFilial("SB1") + "' "
		cQuery +=               " AND SB1.D_E_L_E_T_ = ' ' "
		cQuery +=               " AND SB1.B1_COD     = G1ANCORA.G1_COD ) "
		cQuery +=       " BETWEEN G1ANCORA.G1_REVINI AND G1ANCORA.G1_REVFIM "
	EndIf
	cQuery +=         " UNION ALL "
	cQuery +=         " SELECT ESTRUTURA.G1_COD, "
	cQuery +=                " ESTRUTURA.G1_COMP, "
	cQuery +=                " CAST(REC.CAMINHO || '|' || CAST(ESTRUTURA.R_E_C_N_O_ AS VARCHAR(10)) AS VARCHAR(1024)) AS CAMINHO "
	cQuery +=           " FROM "+ RetSqlName("SG1") +" ESTRUTURA "
	cQuery +=          " INNER JOIN ALLESTRUTURAS REC "
	cQuery +=             " ON ESTRUTURA.G1_COD = REC.G1_COMP "
	cQuery +=          " WHERE ESTRUTURA.D_E_L_E_T_ = ' ' "
	cQuery +=            " AND ESTRUTURA.G1_FILIAL  = '"+ xFilial("SG1") +"'"
	cQuery +=       " ) "
	cQuery += " SELECT ALLESTRUTURAS.G1_COD, "
	cQuery +=        " ALLESTRUTURAS.G1_COMP, "
	cQuery +=        " ALLESTRUTURAS.CAMINHO "
	cQuery +=   " FROM ALLESTRUTURAS "
	cQuery +=  " WHERE NOT EXISTS (SELECT 1 "
	cQuery +=                      " FROM "+ RetSqlName("SG1") +" SG1 "
	cQuery +=                     " WHERE SG1.G1_FILIAL = '"+ xFilial("SG1") +"'"
	cQuery +=                       " AND SG1.D_E_L_E_T_ = ' ' "
	cQuery +=                       " AND ALLESTRUTURAS.G1_COMP = SG1.G1_COD) "

	If cBanco == "POSTGRES"
		cQuery := StrTran(cQuery, 'WITH ', 'WITH RECURSIVE ')
	EndIf

	If cBanco != "POSTGRES" .And. cBanco != "ORACLE"
		cQuery := StrTran(cQuery, '||', '+')
	EndIf

	cQuery := StrTran(cQuery,chr(13)," ")
	cQuery := StrTran(cQuery,chr(10)," ")
	cQuery := StrTran(cQuery,chr(09)," ")

	dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasTop,.T.,.T.)

	While (cAliasTop)->(!Eof())
		aAdd(aEstrutura,StrTokArr((cAliasTop)->(CAMINHO),"|"))
		(cAliasTop)->(dbSkip())
	End
	(cAliasTop)->(dbCloseArea())

	For nIndEstru := 1 To Len(aEstrutura)
		//Percorre todas as estruturas e verifica qual delas possui o maior prazo.
		/**
		aEstrutura[1] (array com os recnos de cada nvel da estrutura)
		aEstrutura[1][1] (caracter, recnos do registro da SG1)
		aEstrutura[1][2] (caracter, recnos do registro da SG1)
		aEstrutura[2] (array com os recnos de cada nvel da estrutura)
		aEstrutura[2][1] (caracter, recnos do registro da SG1)
		aEstrutura[2][2] (caracter, recnos do registro da SG1)
		 */

		//Varivel de controle - prazo da estrutura corrente.
		nPrazoEstr := 0
		//Varivel de controle - Quantidade do componente na estrutura
		nQtdEstru  := nQuant

		//Varivel de controle - Data da estrutura
		dDataEstru := dDataEnt

		For nIndReg := 1 To Len(aEstrutura[nIndEstru])
			nRegistro := Val(aEstrutura[nIndEstru][nIndReg])
			SG1->(dbGoTo(nRegistro))
			nQtdEstru := ExplEstr(nQtdEstru,nil,nil,nil,nil,.F.)
			If nQtdEstru > 0
				nPrazo := CalcPrazo(SG1->G1_COMP,SG1->G1_QUANT,,,.F.,dDataEstru)
				nPrazoEstr += nPrazo
				dDataEstru -= nPrazo
			Else
				Exit
			EndIf
		Next nIndReg

		//Verifica se o prazo desta estrutura  o maior prazo e armazena na varivel nMaxPrazo.
		If nPrazoEstr > nMaxPrazo
			nMaxPrazo := nPrazoEstr
		EndIf
	Next nIndEstru

	SG1->(RestArea(aAreaSG1))
	RestArea(aArea)
Return nMaxPrazo

/*/{Protheus.doc} vldOpACD
Verifica se uma OP pode ser excluda quando existe integrao do SIGAACD x SIGASFC.
Ser utilizada a OP que estiver posicionada na SC2.

@author lucas.franca
@since 03/09/2018
@return lRet	- Indica se a OP pode ser excluda ou no, de acordo com a integrao do SIGAACD x SIGASFC.
/*/
Function PCPvlOpACD()
	Local lRet      := .T.
	Local lIntACD   := SuperGetMV("MV_INTACD",.F.,"0") == "1"
	Local cAliasCZH := "VERCZH"
	Local aArea     := {}

	If lIntSFC .And. lIntACD
		aArea := GetArea()

		//Busca movimentaes realizadas no SIGAACD para essa ordem que ainda no foram integrados com o SFC.
		cQuery := "SELECT COUNT(*) TOTAL "
		cQuery +=  " FROM " + RetSqlName("CZH") + " CZH "
		cQuery += " WHERE CZH.CZH_FILIAL = '" + xFilial("CZH") + "' "
		cQuery +=   " AND CZH.D_E_L_E_T_ = ' ' "
		cQuery +=   " AND CZH.CZH_NRORPO = '" + SC2->(C2_NUM+C2_ITEM+C2_SEQUEN+C2_ITEMGRD) + "' "
		cQuery +=   " AND CZH.CZH_STTR   = '1' " //Movimentaes pendentes de integrao com o SFC.

		cQuery := ChangeQuery(cQuery)

		dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasCZH,.T.,.T.)

		If (cAliasCZH)->(TOTAL) > 0
			lRet := .F.
			Help( ,  , "Help", ,STR0071 + AllTrim(SC2->(C2_NUM+C2_ITEM+C2_SEQUEN+C2_ITEMGRD)) + ".",; // "Existem movimentaes realizadas para esta ordem de produo no mdulo SIGAACD. No ser possvel excluir a ordem de produo XXXX."
				 1, 0, ,,,,,{STR0072}) //"Para excluir a ordem de produo, realize o estorno das movimentaes do mdulo SIGAACD."
		EndIf

		(cAliasCZH)->(dbCloseArea())

		RestArea(aArea)
	EndIf
Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} MATA650SG2()
Funo de consulta especfica SG2002

@author  Renan Roeder
@version P12
@since   26/06/2017
/*/
//-------------------------------------------------------------------
Function PCPA650SG2()
   Local oDlg, oLbx
   Local aCpos  := {}
   Local aRet   := {}
   Local cQuery := ""
   Local cAlias := GetNextAlias()
   Local lRet   := .F.
   Local cFilSG2 := xFilial("SG2")

   DEFAULT l650Auto	   := .F.
   DEFAULT lAutomacao  := .F.

   cQuery := " SELECT DISTINCT SG2.G2_CODIGO, SG2.G2_PRODUTO "
   cQuery +=   " FROM " + RetSqlName("SG2") + " SG2 "
   cQuery +=  " WHERE SG2.D_E_L_E_T_ = ' ' "
   cQuery +=    " AND SG2.G2_FILIAL  = '" + cFilSG2 + "' "
   If !Empty(M->C2_PRODUTO)
      cQuery += " AND SG2.G2_PRODUTO = '" + M->C2_PRODUTO + "' "
   EndIf
   cQuery += " ORDER BY 2,1 "

   cQuery := ChangeQuery(cQuery)

   dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAlias,.T.,.T.)

   While (cAlias)->(!Eof())
      aAdd(aCpos,{(cAlias)->(G2_CODIGO), (cAlias)->(G2_PRODUTO)})
      (cAlias)->(dbSkip())
   End
   (cAlias)->(dbCloseArea())

   If Len(aCpos) < 1
      aAdd(aCpos,{" "," "})
   EndIf

   If !l650Auto .and. !lAutomacao
      DEFINE MSDIALOG oDlg TITLE STR0073  FROM 0,0 TO 240,500 PIXEL //"Roteiro de operaes"

      @ 10,10 LISTBOX oLbx FIELDS HEADER STR0074 /*"Roteiro"*/, STR0075 /*"Produto"*/  SIZE 230,95 OF oDlg PIXEL

      oLbx:SetArray( aCpos )
      oLbx:bLine     := {|| {aCpos[oLbx:nAt,1], aCpos[oLbx:nAt,2]}}
      oLbx:bLDblClick := {|| {oDlg:End(), lRet:=.T., aRet := {oLbx:aArray[oLbx:nAt,1],oLbx:aArray[oLbx:nAt,2]}}}


      DEFINE SBUTTON FROM 107,213 TYPE 1 ACTION (oDlg:End(), lRet:=.T., aRet := {oLbx:aArray[oLbx:nAt,1],oLbx:aArray[oLbx:nAt,2]})  ENABLE OF oDlg
      ACTIVATE MSDIALOG oDlg CENTER
   EndIF

   If Len(aRet) > 0 .And. lRet
      If Empty(aRet[1])
         lRet := .F.
      Else
         SG2->(dbSetOrder(1))
         SG2->(dbSeek(cFilSG2+aRet[2]+aRet[1]))
      EndIf
   EndIf
Return lRet


/*


ͻ
Programa  A650IntSFCAutor  Andre Anjos		  Data   02/05/11   
͹
Descricao  Gera integracao com Chao de Fabrica.                       
͹
Parametros nOpc: 3- Inclusao				  						  
			  		 4- Alteracao				  						  
			  		 5- Exclusao				  						  
			  nEvento: 1- Inclusao de OP pai						  	  
			  nEvento: 2- Alteracao para geracao das operacoes			  
			  nEvento: 3- Alteracao para geracao dos empenhos			  
			  nEvento: 4- Inclusao de OP filha							  
			  nEvento: 5- Alteracao do cadastro						  
͹
Uso        MATA650                                                    
ͼ


*/
Function PCPIntSFC(nOpc, nEvento, cError, cNome, oModel, cAlias)
Local aArea      := GetArea()
Local lRet       := .T.
Local aCpoCYQ    := {}
Local aCpoCY9    := {}
Local aCpoCYD    := {}
Local aCpoCYP    := {}
Local nX         := 0
Local nY         := 0
Local nItErro    := 0
Local aAux       := {}
Local aBackup    := Array(2)
Local cRoteiro   := ' '
Local aAreaSG2   := {}
Local lModelEnv  := .T.
Local lValid     := .F.
Private l010Auto := .F.
Default cAlias   := IIf(nOpc # 5 .And. (nEvento==1 .OR. nEvento==5), "M", "SC2")
Default oModel   := .F.

If ValType(oModel) == "L"
	oModel		:= FWLoadModel("SFCA100")
	lModelEnv	:= .F.
EndIf

If Type("Inclui") == "L"
	aBackup[1] := INCLUI
EndIf

If Type("Altera") == "L"
	aBackup[2] := ALTERA
EndIf

If Empty(cRoteiro := &(cAlias+"->C2_ROTEIRO") )
	If Empty(cRoteiro := Posicione("SB1",1,xFilial("SB1")+&(cAlias+"->C2_PRODUTO"),"B1_OPERPAD"))
		cRoteiro := Posicione("SG2",1,xFilial("SG2")+&(cAlias+"->C2_PRODUTO")+StrZero(1,TamSX3("G2_CODIGO")[1]),"G2_CODIGO")
	EndIf
EndIf

lValid := .F.
//Busca operaes vlidas
SG2->(dbSetOrder(1))
SG2->(dbSeek(xFilial("SG2")+&(cAlias+"->C2_PRODUTO")+cRoteiro))
While !SG2->(Eof()) .And. xFilial("SG2")+&(cAlias+"->C2_PRODUTO")+cRoteiro == SG2->(G2_FILIAL+G2_PRODUTO+G2_CODIGO)

	If !Empty(SG2->G2_DTINI)
		If SG2->G2_DTINI > &(cAlias+"->C2_DATPRI")
			SG2->(dbSkip())
			Loop
		EndIf
	EndIf
	If !Empty(SG2->G2_DTFIM)
		If SG2->G2_DTFIM < &(cAlias+"->C2_DATPRI")
			SG2->(dbSkip())
			Loop
		EndIf
	EndIf

	lValid := .T.
	Exit
End

If &(cAlias+"->C2_TPOP") == "F" .And. lValid
	SB1->(dbSetOrder(1))
	SB1->(dbSeek(xFilial("SB1")+&(cAlias+"->C2_PRODUTO")))

	//Ŀ
	//Define campos a serem atualizados no cabecalho do cadastro de Ordem Pr - SFC 
	//
	If nOpc == 3
		aAdd(aCpoCYQ,{"CYQ_NRORPO",&(cAlias+"->(C2_NUM+C2_ITEM+C2_SEQUEN+C2_ITEMGRD)")})
		aAdd(aCpoCYQ,{"CYQ_CDAC",&(cAlias+"->C2_PRODUTO")})
		aAdd(aCpoCYQ,{"CYQ_DSAC",SB1->B1_DESC})
		aAdd(aCpoCYQ,{"CYQ_CDDP",&(cAlias+"->C2_LOCAL")})
		aAdd(aCpoCYQ,{"CYQ_QTOR",&(cAlias+"->C2_QUANT")})
		aAdd(aCpoCYQ,{"CYQ_TPORPO","1"})
		aAdd(aCpoCYQ,{"CYQ_CDUN",&(cAlias+"->C2_UM")})
		aAdd(aCpoCYQ,{"CYQ_CDPDOR",&(cAlias+"->(C2_PEDIDO+C2_ITEMPV)")})
		aAdd(aCpoCYQ,{"CYQ_TPST","1"})
		aAdd(aCpoCYQ,{"CYQ_TPSTOR","2"})
		aAdd(aCpoCYQ,{"CYQ_TPRPOR",Posicione("CZ3",1,xFilial("CZ3")+SB1->B1_COD,"CZ3_TPRPOR")})
		aAdd(aCpoCYQ,{"CYQ_CDES",xFilial("SC2")})
		aAdd(aCpoCYQ,{"CYQ_CDGE",SB1->B1_GRUPO})
		aAdd(aCpoCYQ,{"CYQ_DSGE",Posicione("SBM",1,xFilial("SBM")+SB1->B1_GRUPO,"BM_DESC")})
		aAdd(aCpoCYQ,{"CYQ_VLPSLQ",SB1->B1_PESO})
		aAdd(aCpoCYQ,{"CYQ_VLPSBR",SB1->B1_PESBRU})

		SF5->(dbSeek(xFilial("SF5")+SuperGetMV("MV_TMPAD",.F.,"")))
		aAdd(aCpoCYQ,{"CYQ_TPMOD","1"})
		aAdd(aCpoCYQ,{"CYQ_TPGGF",If(SF5->F5_TRANMOD = "S","2","1")})
	EndIf

	If nOpc # 5 .And. (nEvento == 1 .Or. nEvento == 4 .Or. nEvento == 5)
		aAdd(aCpoCYQ,{"CYQ_DTBGOR",&(cAlias+"->C2_DATPRI")})
		aAdd(aCpoCYQ,{"CYQ_DTEDOR",&(cAlias+"->C2_DATPRF")})
	EndIf

	//oModel := FWLoadModel("SFCA100")
	oModel:SetOperation(nOpc)

	//Ŀ
	//Quando se tratar de alteracao ou exclusao primeiramente o registro devera ser posicionado 
	//
	If nOpc # 3
		dbSelectArea("CYQ")
		dbSetOrder(1)
		dbSeek(xFilial("CYQ")+&(cAlias+"->(C2_NUM+C2_ITEM+C2_SEQUEN+C2_ITEMGRD)"))
	EndIf

	N := 1

	//Ŀ
	//Ativa o modelo de dados 
	//
	lRet := oModel:Activate()

	If nOpc # 5
		aAux := oModel:GetModel("CYQMASTER"):GetStruct():GetFields()

		For nX := 1 To Len(aCpoCYQ)
			If aScan(aAux,{|x| AllTrim(x[3]) ==  AllTrim(aCpoCYQ[nX,1])}) > 0
				If !(oModel:SetValue("CYQMASTER",aCpoCYQ[nX,1],aCpoCYQ[nX,2]))
					lRet := .F.
					Exit
				EndIf
			EndIf
		Next nX
	EndIf

	If lRet .And. nOpc == 4 .And. nEvento == 2
		SG2->(dbSetOrder(1))
		SHY->(dbSetOrder(1))
		SHY->(dbSeek(xFilial("SHY")+&(cAlias+"->(C2_NUM+C2_ITEM+C2_SEQUEN+C2_ITEMGRD)")))
		While !SHY->(EOF()) .And. SHY->(HY_FILIAL+HY_OP) == xFilial("SHY")+&(cAlias+"->(C2_NUM+C2_ITEM+C2_SEQUEN+C2_ITEMGRD)")
		    SG2->(dbSeek(xFilial("SG2")+&(cAlias+"->C2_PRODUTO+SHY->(HY_ROTEIRO+HY_OPERAC)")))

		    //Ŀ
			//Define campos da folder 'Operacoes da Ordem' a serem atualizados no cadastro de OP  
			//
			aAdd(aCpoCY9,{})

			aAdd(aTail(aCpoCY9),{"CY9_NRORPO",SHY->HY_OP})
			aAdd(aTail(aCpoCY9),{"CY9_CDAT",SHY->HY_OPERAC})
			aAdd(aTail(aCpoCY9),{"CY9_DSAT",SHY->HY_DESCRI})
			aAdd(aTail(aCpoCY9),{"CY9_CDAC",&(cAlias+"->C2_PRODUTO")})
			aAdd(aTail(aCpoCY9),{"CY9_DSAC",Posicione("SB1",1,xFilial("SB1")+&(cAlias+"->C2_PRODUTO"),"B1_DESC")})
			aAdd(aTail(aCpoCY9),{"CY9_TPAT","1"})
			aAdd(aTail(aCpoCY9),{"CY9_CDCETR",SHY->HY_CTRAB})
			aAdd(aTail(aCpoCY9),{"CY9_DSCETR",Posicione("SHB",1,xFilial("SHB")+SHY->HY_CTRAB,"HB_NOME")})
			aAdd(aTail(aCpoCY9),{"CY9_TPUNTE","1"})
			aAdd(aTail(aCpoCY9),{"CY9_QTTEMQ",SHY->HY_TEMPOM})
			aAdd(aTail(aCpoCY9),{"CY9_QTTESU",SHY->HY_TEMPOS})
			aAdd(aTail(aCpoCY9),{"CY9_CDRT",SHY->HY_ROTEIRO})
			aAdd(aTail(aCpoCY9),{"CY9_CDFE",SHY->HY_FERRAM})
			aAdd(aTail(aCpoCY9),{"CY9_QTAT",SHY->HY_QUANT})
			aAdd(aTail(aCpoCY9),{"CY9_TPTE",If(SG2->G2_TPOPER=="3","1",If(SG2->G2_TPOPER=="4","3",SG2->G2_TPOPER))})
			aAdd(aTail(aCpoCY9),{"CY9_QTLOPA",SG2->G2_LOTEPAD})
			aAdd(aTail(aCpoCY9),{"CY9_LGCERP",Posicione("CYI",1,xFilial("CYI")+SHY->HY_CTRAB,"CYI_LGCERP")})

			//Ŀ
			//Define campos da folder 'Rede Pert' a serem atualizados no cadastro de OP  
			//
			SHY->(dbSkip())
			If !SHY->(EOF()) .And. SHY->(HY_FILIAL+HY_OP) == xFilial("SHY")+&(cAlias+"->(C2_NUM+C2_ITEM+C2_SEQUEN+C2_ITEMGRD)")
				aAdd(aCpoCYD,{})

				aAdd(aTail(aCpoCYD),{"CYD_NRORPO",SHY->HY_OP})
				aAdd(aTail(aCpoCYD),{"CYD_CDAC",SG2->G2_PRODUTO})
				aAdd(aTail(aCpoCYD),{"CYD_CDACPV",SG2->G2_PRODUTO})
				aAdd(aTail(aCpoCYD),{"CYD_CDRT",SHY->HY_ROTEIRO})
				aAdd(aTail(aCpoCYD),{"CYD_CDRTPV",SHY->HY_ROTEIRO})
				aAdd(aTail(aCpoCYD),{"CYD_CDAT",SHY->HY_OPERAC})
				aAdd(aTail(aCpoCYD),{"CYD_CDATPV",SG2->G2_OPERAC})

				aAreaSG2 := SG2->(GetArea())

				SG2->(dbSetOrder(1))
				SG2->(dbSeek(xFilial("SG2")+&(cAlias+"->C2_PRODUTO+SHY->(HY_ROTEIRO+HY_OPERAC)")))

				If SG2->G2_TPSOBRE == "2"
					aAdd(aTail(aCpoCYD),{"CYD_VLPNOV",SG2->G2_TEMPSOB})
				ElseIf SG2->G2_TPSOBRE == "1"
					aAdd(aTail(aCpoCYD),{"CYD_VLPNOV",100})
				ElseIf SG2->G2_TPSOBRE == "3"
					nVlpnov := Round((SG2->G2_TEMPSOB * 100) / SG2->G2_TEMPAD,2)
					If nVlpnov > 100
						nVlpnov := 100
					EndIf
					aAdd(aTail(aCpoCYD),{"CYD_VLPNOV",nVlpnov})
				EndIf

				RestArea(aAreaSG2)

				aAdd(aTail(aCpoCYD),{"CYD_QTTETS",SG2->G2_TEMPEND})
			EndIf
		End

		//Ŀ
		//Quando alteracao deleta linhas das grids 'Operacoes' e 'Rede' para nova inclusao 
		//
		For nX := 1 To oModel:GetModel("CY9DETAIL"):GetQtdLine()
			oModel:GetModel("CY9DETAIL"):GoLine(nX)
			oModel:GetModel("CY9DETAIL"):SetValue("CY9_IDAT","0")
			oModel:GetModel("CY9DETAIL"):DeleteLine()
		Next nX

		For nX := 1 To oModel:GetModel("CYDDETAIL"):GetQtdLine()
			oModel:GetModel("CYDDETAIL"):GoLine(nX)
			oModel:GetModel("CYDDETAIL"):DeleteLine()
		Next nX

		aAux := oModel:GetModel("CY9DETAIL"):GetStruct():GetFields()

		For nY := 1 To Len(aCpoCY9)
			oModel:GetModel("CY9DETAIL"):AddLine()

			For nX := 1 To Len(aCpoCY9[nY])
				If aScan(aAux,{|x| AllTrim(x[3]) ==  AllTrim(aCpoCY9[nY,nX,1])}) > 0
					If !(oModel:SetValue("CY9DETAIL",aCpoCY9[nY,nX,1],aCpoCY9[nY,nX,2]))
						lRet := .F.
						nItErro := Len(oModel:GetModel("CY9DETAIL"):aCols)
						Exit
					EndIf
				EndIf
			Next nX

			If !lRet
				Exit
			EndIf
		Next nY

		If Empty(nItErro) .And. lRet
			aAux := oModel:GetModel("CYDDETAIL"):GetStruct():GetFields()

			For nY := 1 To Len(aCpoCYD)
				oModel:GetModel("CYDDETAIL"):AddLine()

				For nX := 1 To Len(aCpoCYD[nY])
					If aScan(aAux,{|x| AllTrim(x[3]) ==  AllTrim(aCpoCYD[nY,nX,1])}) > 0
						If !(oModel:SetValue("CYDDETAIL",aCpoCYD[nY,nX,1],aCpoCYD[nY,nX,2]))
							lRet := .F.
							nItErro := Len(oModel:GetModel("CYDDETAIL"):aCols)
							Exit
						EndIf
					EndIf
				Next nX

				If !lRet
					Exit
				EndIf
			Next nY
		EndIf
	EndIf

	If lRet .And. nOpc == 4 .And. nEvento == 3
		SGF->(dbSetOrder(2))
		SHY->(dbSetOrder(1))
		SHY->(dbSeek(xFilial("SHY")+&(cAlias+"->(C2_NUM+C2_ITEM+C2_SEQUEN+C2_ITEMGRD)")))
		If !SHY->(dbSeek(xFilial("SHY")+SHY->(HY_OP+HY_ROTEIRO)+Replicate("z",TamSX3("G2_OPERAC")[1]),.T.))
			SHY->(dbSkip(-1))
		EndIf
		SD4->(dbSetOrder(2))
		SD4->(dbSeek(xFilial("SD4")+&(cAlias+"->(C2_NUM+C2_ITEM+C2_SEQUEN+C2_ITEMGRD)")))
		While !SD4->(EOF()) .And. SD4->(D4_FILIAL+D4_OP) == xFilial("SD4")+&(cAlias+"->(C2_NUM+C2_ITEM+C2_SEQUEN+C2_ITEMGRD)")
			aAdd(aCpoCYP,{})

			aAdd(aTail(aCpoCYP),{"CYP_NRORPO",SD4->D4_OP})
			aAdd(aTail(aCpoCYP),{"CYP_CDMT",SD4->D4_COD})
			aAdd(aTail(aCpoCYP),{"CYP_NRSQMT",SD4->D4_TRT})
			aAdd(aTail(aCpoCYP),{"CYP_DSMT",Posicione("SB1",1,xFilial("SB1")+SD4->D4_COD,"B1_DESC")})
			aAdd(aTail(aCpoCYP),{"CYP_DSACPI",Posicione("SB1",1,xFilial("SB1")+&(cAlias+"->C2_PRODUTO"),"B1_DESC")})
			aAdd(aTail(aCpoCYP),{"CYP_CDACPI",&(cAlias+"->C2_PRODUTO")})
			aAdd(aTail(aCpoCYP),{"CYP_CDRT",SHY->HY_ROTEIRO})
			If SGF->(dbSeek(xFilial("SGF")+&(cAlias+"->C2_PRODUTO")+SHY->HY_ROTEIRO+SD4->D4_COD))
				aAdd(aTail(aCpoCYP),{"CYP_CDAT",SGF->GF_OPERAC})
			Else
				aAdd(aTail(aCpoCYP),{"CYP_CDAT",SHY->HY_OPERAC})
			EndIf
			aAdd(aTail(aCpoCYP),{"CYP_CDDP",SD4->D4_LOCAL})
			aAdd(aTail(aCpoCYP),{"CYP_CDLO",SD4->D4_LOTECTL})
			aAdd(aTail(aCpoCYP),{"CYP_QTMT",SD4->D4_QUANT})
			aAdd(aTail(aCpoCYP),{"CYP_CDUN",Posicione("SB1",1,xFilial("SB1")+SD4->D4_COD,"B1_UM")})
			aAdd(aTail(aCpoCYP),{"CYP_DTMT",SD4->D4_DATA})
			aAdd(aTail(aCpoCYP),{"CYP_TPST","1"})

			SD4->(dbSkip())
		End

		aAux := oModel:GetModel("CYPDETAIL"):GetStruct():GetFields()

		//Ŀ
		//Quando alteracao deleta linhas das grids 'Operacoes' e 'Rede' para nova inclusao 
		//
		For nX := 1 To oModel:GetModel("CYPDETAIL"):GetQtdLine()
			oModel:GetModel("CYPDETAIL"):GoLine(nX)
			oModel:GetModel("CYPDETAIL"):DeleteLine()
		Next nX

		For nY := 1 To Len(aCpoCYP)
			oModel:GetModel("CYPDETAIL"):AddLine()

			For nX := 1 To Len(aCpoCYP[nY])
				If aScan(aAux,{|x| AllTrim(x[3]) ==  AllTrim(aCpoCYP[nY,nX,1])}) > 0
					If !(oModel:SetValue("CYPDETAIL",aCpoCYP[nY,nX,1],aCpoCYP[nY,nX,2]))
						lRet := .F.
						nItErro := nX
						Exit
					EndIf
				EndIf
			Next nX

			If !lRet
				Exit
			EndIf
		Next nY
	EndIf

	If lRet
		If (lRet := oModel:VldData())
			lRet := oModel:CommitData()
		EndIf
	EndIf

	If !lRet
		A010SFCErr(oModel,@cError,nItErro,cNome,SC2->(C2_NUM+C2_ITEM+C2_SEQUEN+C2_ITEMGRD))
	EndIf

	oModel:DeActivate()
	RestArea(aArea)
EndIf

If aBackup[1] # NIL
	INCLUI := aBackup[1]
EndIf

If aBackup[2] # NIL
	ALTERA := aBackup[2]
EndIf

If !lModelEnv
	oModel:Destroy()
EndIf

Return lRet

/*


Ŀ
Funcao    A650VldPV   Autor  Sergio S. Fuzinaka    Data  15.04.10 
Ĵ
Descricao Executa validacao na rotina de alteracao do Pedido de Venda 
                                                                      
Ĵ
 Uso      Generico                                                    
ٱ


*/
Function PCPVldPV()

Local lRet		:= .T.
Local aArea		:= GetArea()
Local aAreaSC2	:= SC2->( GetArea() )
Local aAreaSD3	:= SD3->( GetArea() )
Local nQtdVen	:= IIf( ReadVar() == "M->C6_QTDVEN", &( ReadVar() ), 0 )	//C6_QTDVEN

If SC6->C6_TPOP == "F" .And. !Empty( SC6->C6_NUMOP ) .And. nQtdVen <> SC6->C6_QTDVEN	//Gerado OP

	dbSelectArea("SGJ")
	dbSetOrder(1)
	If dbSeek( xFilial("SGJ")+SC6->(C6_NUM+C6_ITEM+C6_PRODUTO+C6_LOCAL+C6_NUMOP+C6_ITEMOP) )
		dbSelectArea("SC2")
		dbSetOrder(1)
		If dbSeek(xFilial("SC2")+SGJ->(GJ_NUMOP+GJ_ITEMOP+GJ_SEQUEN+GJ_ITGRDOP))
			If SC2->C2_QUJE > 0		//Qtd. produzida
				lRet := .F.
				Help(" ",1,"A410ALTPV")
			Else
				dbSelectArea("SD3")
				dbSetOrder(1)
				If dbSeek(xFilial("SD3")+SC2->(C2_NUM+C2_ITEM+C2_SEQUEN+C2_ITEMGRD))
					While !Eof() .And. SD3->(D3_FILIAL+D3_OP) == SC2->C2_FILIAL+SC2->(C2_NUM+C2_ITEM+C2_SEQUEN+C2_ITEMGRD)
						If SD3->D3_ESTORNO <> "S"
							lRet := .F.
							Help(" ",1,"A410ALTPV")
						Endif
						SD3->(dbSkip())
					Enddo
				Endif
			Endif
			If lRet
				If Aviso(STR0076 ,STR0077 +SC2->C2_NUM+"/"+SC2->C2_ITEM+ STR0078 +CHR(13)+CHR(10)+CHR(13)+CHR(10)+"Confirma a alterao?",{"Sim","Nao"}) == 2
					// "Ateno",  "Este item gerou a OP ",   ", a alterao da quantidade ir exclu-la!",
					lRet := .F.
				Endif
			Endif
		Endif
	Endif

Endif

RestArea( aAreaSD3 )
RestArea( aAreaSC2 )
RestArea( aArea )

Return( lRet )

/*

Ŀ
Funao    A390PPI    Autor Ana Paula dos Santos   Data  20/05/2021
Ĵ
Descriao Integrao PPI                                              
ٱ

*/
Function PCP390PPI(cProduto, cLocal, cSerie, cLoteCtl, cNumLote,;
                        cDtValid, nQuant, cTipMov, cSeq, cDoc, cEvent, aDelete)

Default cEvent  := 'upsert'
Default cTipMov := '3'

If IsInCallStack("A220Deleta") .OR. IsInCallStack("A220AtuSD5")
	Return
EndIf

// Integrao com TOTVS MES
if PCPIntgPPI()
	dbSelectArea("SOE")
	SOE->(dbSetOrder(1))
	If SOE->(dbSeek(xFilial("SOE")+"SB2")) .AND. ALLTRIM(SOE->OE_VAR3) == '1'

		//Enviar saldo que est sendo distribuido para o lote na tag QuantityUpdated
		MATA225PPI( cProduto,; // Produto
					cLocal,; // Armazm
					'',; // Localizao
					cSerie,; // Nmero de srie
					cLoteCtl,; // Lote
					cNumLote,; // Sub-lote
					cDtValid,;  // Data
					nQuant,; // Quantidade
					cTipMov,; // Tipo de movimento
					cSeq,; // Sequencia
					cDoc,; // Documento
					aDelete,; //Registros excluidos
					cEvent) // Ao
	Endif
Endif

Return

/*/{Protheus.doc} PCPMETRIC
Funo para integrar ID de mtrica com o dashboard CAROL
@type  Function
@author ana.paula
@since 08/09/2021
@version P12.1.27
@param 01 cIdProg, Character, Subrotina que esta gerando da metrica
@param 02 aArrayID, Array   , Array que contem o ID da mtrica e o valor a ser integrado
@param 03 lPutInfo, Logic   , Indica que deve ser executada a funo FWLSPutASyncInfo aps o addMetrics. Utilizado em rotinas que no so chamadas pelo MENU.
@param 04 lUseCustom, Logic , Indica que deve ir usar a classe FwCustomMetrics.
@param 05 cRotina, Character, Rotina que est definindo a mtrica.
/*/
Function PCPMETRIC(cIdProg, aArrayID, lPutInfo, lUseCustom, cRotina)

	Local cBanco := Upper(TcgetDB())
	Local nX     := 0

	Default lPutInfo   := .F.
	Default lUseCustom := .F.

	If !lUseCustom .and. FwLibVersion() >= "20200727"
		For nX := 1 To Len(aArrayID)
			FWMetrics():addMetrics(cIdProg, {aArrayID[nX]})
		Next nX
		If lPutInfo
			FWLSPutASyncInfo("LS006", , "10", cIdProg)
		EndIf
	ElseIf FwLibVersion() >= "20210517" .and. !("|"+cBanco+"|" $ "|OPENEDGE|INFORMIX|DB2|")
		FwCustomMetrics():setSumMetric(cIdProg, aArrayID[1], aArrayID[2], /*dDateSend*/, /*nLapTime*/, cRotina)
	EndIf

Return
