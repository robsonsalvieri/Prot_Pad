#INCLUDE "FILEIO.CH"
#INCLUDE "QAXFUN.CH"
#INCLUDE "TOTVS.CH"

#DEFINE Confirma 1
#DEFINE Redigita 2
#DEFINE Abandona 3
#DEFINE N_USADO   ""  // No Usado
#DEFINE N_RESERV  ""               // NO USADO / NO BROWSE

STATIC VOGAIS 		:= "aAeEiIoOuU"
STATIC CONSOANTE 	:= "bBcCdDfFgGhHjJkKlLmMnNoPqQrRsStTvVwWxXyYzZ"
STATIC ESPECIAIS 	:= "$@%&*+-)(/#<=>{|}~[\]^_`',:;!.?"+Chr(34)
STATIC FIMLINHA     := ":;!.?,' "+Chr(34)

/*

Ŀ
Funo	 MontAhead  Autor  Vera Lucia S. Simoes   Data  25/11/97 
Ĵ
Descrio  Monta vetor aHeader utilizado na getdados 				  
Ĵ
 Uso		  Generico 												  
ٱ

*/
Function MontAhead(cAlias)
aHeader := aClone(APBuildHeader(cAlias))
nUsado  := Len(aHeader)
Return(aHeader)

/*

Ŀ
Funo	  QA_NDEPT  Autor  Wanderley Goncalves Jr Data  26.11.97 
Ĵ
Descrio  Gatilho para preencher a descricao do Departamento 		  
Ĵ
Sintaxe	  QA_NDEPT(ExpC1,ExpL1)									  
Ĵ
Parametros ExpC1 = Codigo do Departamento							  
			  ExpL1 = Indica se e' gatilho                               
Ĵ
 Uso		  Generico-Cham. no X3_RELACAO,X3_INIBRW e gatilhos (Depart) 
ٱ

*/
Function QA_NDEPT(cCodDe,lGatilho,cFilCod)
Local aArea:= GetArea()
Local cDesc:= ""

Default cFilCod := xFilial("QAD")
Default lGatilho:= .T.

// Incluido tratamento para a inicializao padrao da rotina de No Conformidade
If Type("INCLUI") <> "L"
	Inclui:= .F.
EndIf

cDesc:= Space(Len(QAD->QAD_DESC))

If FWModeAccess("QAD") == "C"//Empty(xFilial("QAD")) Filial Compartilhada
	//cFilCod := xFilial("QAD")
	cFilCod := SUBSTR(cFilCod,1,LEN(ALLTRIM(xFilial("QAD"))))
	cFilCod := Padr(cFilCod,FWSizeFilial())
Else
	cFilCod := xFilial("QAD")
EndIf

If !Inclui .Or. lGatilho	// Se Inic. Padrao ou gatilho a partir do cod. Depart.
	DbSelectArea("QAD")
	DbSetOrder(1)
	IF FWModeAccess("QDC",3) == "E"
		If QAD->(DbSeek(cFilCod + cCodDe))
			cDesc:= QAD->QAD_DESC
		Endif
	else
		If QAD->(DbSeek(PadR("",FWSizeFilial())+cCodDe))
			cDesc:= QAD->QAD_DESC
		Endif
		IF EMPTY(cDesc)
			If QAD->(DbSeek(cFilCod+cCodDe))
				cDesc:= QAD->QAD_DESC
			Endif
		ENDIF
	Endif
Endif
RestArea(aArea)
Return cDesc

/*/{Protheus.doc} CalcObjScr
Funo que calcula Objeto de tela oDlg
@type  Function
@author Fbio Boarini
@since 01/09/2023
@version 1.00
@param 01 - oDlg, objeto, objeto dilogo
@return aCoords, array, coodenadas de tela
/*/
Function CalcObjScr(oDlg)
	Local aCoords   := {} // array das coordenadas de tela em pixels
	Local nColFim   := 0
	Local nColIni   := 0
	Local nLinFim   := 0
	Local nLinIni   := 0
	Local oSizeDlg  := Nil

	oSizeDlg := FwDefSize():New(.T.,,,oDlg)
	oSizeDlg:AddObject( "TXT", 70, 35, .T., .T. ) // 70% dimensionavel
	oSizeDlg:lLateral := .F. //Indica se os objetos serao dispostos lateralmente
	oSizeDlg:lProp    := .T. //Indica se mantem a proporcao de tamanho dos objetos dimensionveis
	oSizeDlg:aMargins := { 3, 3, 3, 3 } // Espaco ao lado dos objetos 0, entre eles 3
	oSizeDlg:Process() // Dispara os calculos	

	nLinIni := oSizeDlg:GetDimension("TXT","LININI")
	AADD( aCoords, nLinIni )
	nColIni := oSizeDlg:GetDimension("TXT","COLINI")
	AADD( aCoords, nColIni )
	nLinFim := oSizeDlg:GetDimension("TXT","LINEND")
	AADD( aCoords, nLinFim )
	nColFim := oSizeDlg:GetDimension("TXT","COLEND")
	AADD( aCoords, nColFim )

Return aCoords

/*

Ŀ
Funo	 QA_TEXTO	 Autor  Vera / Wanderley 	   Data  01.12.97   
Ĵ
Descrio  Trata textos - VERSAO DOS/WINDOWS						  
Ĵ
Sintaxe	  QA_TEXTO(ExpC1,ExpC2,ExpN1,ExpC3,ExpC4,ExpA1,ExpN2,ExpC5,; 
			  			ExpL1,ExpC6)									  
Ĵ
Parametros ExpC1 = Chave do Texto (j convertida) 					  
			  ExpC2 = Especie do Texto									  
			  ExpN1 = Tamanho da linha do texto						  
			  ExpC3 = Titulo do Texto: somente informativo na tela		  
			  ExpC4 = Codigo do Titulo: somente informativo na tela 	  
			  ExpA1 = Array contendo os textos a serem editados		  
			  ExpN2 = Linha do vetor axTextos							  
			  ExpC5 = Cabecalho da tela de Texto						  
			  ExpL1 = Edita ou no o texto. 							  
			  ExpC6 = Alias do arquivo para gravar o texto 			  
Ĵ
Uso		  Generico 												  
Ĵ
Obs		  O vetor axTextos deve ser criado no programa chamador, como
			  private, e passado via parametro, como referencia (@).	  
			  O vetor axTextos deve ser inicializado apos cada funcao de 
			  inclusao,alteracao e exclusao.							  
ٱ


*/

Function QA_TEXTO(cChave,cEspecie,nTamLin,cTit,cCod,axTextos,nLi,cCab,;
	lEdita,cAliasQA2,lApres)

Local aCoords 		:= {}
Local aSize			:= FwGetDialogSize()//MsAdvSize()
Local cTexto        := ""
Local nOpcA 		:= 0
Local nPos			:= 0
Local oDlg          := Nil
Local oFontMet      := TFont():New("Courier New",6,0)
Local oTexto   		:= Nil

Private lEdit       := Iif(lEdita == NIL, .T., lEdita)

Default cAliasQA2   := "QA2"
Default lApres      := .T.

//Ŀ
// Recupera Texto ja' existente (nLi e' a linha atual da getdados)     
//
cTexto := QA_RecTxt( cChave, cEspecie, nLi, nTamLin, cAliasQA2, axtextos)

//Ŀ
// Ponto de Entrada para inicializacao dos campos MEMO                 
//
If ExistBlock("QDOAP37")
	cTexto := ExecBlock("QDOAP37",.F.,.F.,{cEspecie,cTexto})
Endif

If lApres
	
	oDlg := MSDialog():New(aSize[1]+50,aSize[2]+50,aSize[3]-50,aSize[4]-50,cCab,,,,,CLR_BLACK,,,,.T.)
	aCoords := CalcObjScr(oDlg) // Calcula a proporo do Objeto de Tela
	@ aCoords[1] ,aCoords[2] TO aCoords[3]-21, aCoords[4]-39 LABEL cTit  OF oDlg  PIXEL //" Objetivo "
	
	oTGet1 := TGet():New(acoords[1]-20,010,{|u|if(PCount()==0,cCod,cCod:=u)},oDlg,aCoords[4]-59, 010,"@!",,0,,,.F.,,.T.,,.F.,{||.F.},.F.,.F.,,.F.,,,cCod,,,, )

	If lEdit
	   oTexto := tMultiget():new(acoords[1]+17,010,{| u | if( pCount() > 0, cTexto := u, cTexto )},oDlg,aCoords[4]-59,aCoords[3]-81,oFontMet,,,,,.T.,,,,,,.F.,,,,,.F.)
	   oTexto:lWordWrap:=.T.
	Else
	   oTexto := tMultiget():new(acoords[1]+17,010,{| u | if( pCount() > 0, cTexto := u, cTexto )},oDlg,aCoords[4]-59,aCoords[3]-81,oFontMet,,,,,.T.,,,,,,.T.,,,,,.F.)
	   oTexto:lWordWrap:=.T.
	Endif
	
	DEFINE SBUTTON FROM aCoords[3]-11,010 TYPE 1 ACTION (nOpca := 1,oDlg:End()) ENABLE OF oDlg
	DEFINE SBUTTON FROM aCoords[3]-11,040 TYPE 2 ACTION (nOpca := 2,oDlg:End()) ENABLE OF oDlg
	
	ACTIVATE MSDIALOG oDlg CENTERED
Else
	nOpca:= 1
EndIf

If nOpca = Confirma
	// Confirma
	lGrava	  := .T.
	nPos := ascan(axTextos, {|x| x[1] == nLi })
	If nPos == 0
		Aadd(axTextos, { nLi, cTexto } )
	Else
		axTextos[nPos][2] := cTexto
	Endif
EndIf

Return If(nOpca==Confirma,.T.,.F.)

/*

Ŀ
Funo	 QA_Rectxt  Autor  Vera / Wanderley 	     Data  02.12.97 
Ĵ
Descrio  Recupera um texto do arquivo de textos 					  
Ĵ
Sintaxe	  QA_RecTxt(ExpC1,ExpC2,ExpN1,ExpN2,ExpC3,ExpA1,ExpL1,ExpC4) 
Ĵ
Parametros ExpC1 = Chave do Texto (ja' convertida)                    
			  ExpC2 = Especie do Texto									  
			  ExpN1 = Linha da GetDados que esta posicionada	    	  
			  ExpN2 = Tamanho da linha do texto						  
			  ExpC3 = Alias do arquivo para leitura (QA2 ou tempor.)	  
			   Obs.:  Se for arq. temp., deve ter a mesma estrut. do QA2.
			  ExpA1 = Array contendo o texto a ser recuperado 			  
			  ExpL1 = Chamada para atualizar o texto no Word  			  
			  ExpC4 = Filial a ser atribuida na variavel de memoria	  
Ĵ
 Uso		  QA_TEXTO 												  
ٱ

*/
Function QA_Rectxt(cChave,cEspecie,nX,nTamLin,cAliasQA2,axTextos,lWord,cFilla)

Local cAlias     := Iif(cAliasQA2 == NIL,"QA2",cAliasQA2)
Local cFilTxt    := SuperGetMv("MV_QATEXTO",.F.,"1") //1=SIM ; 2=NAO
Local cQuebra    := ""
Local cSavFilAnt := cFilAnt
Local cTexto     := ""
Local lAux       := .F.
Local nOrd       := &(cAlias+"->(IndexOrd(IndexKey()))")
Local nPos       := 0
Local nRec       := &(cAlias+"->(Recno())")

Default axTextos := {}
Default cFilla   := xFilial(cAlias)
Default lWord    := .F.
Default nTamLin  := GetSX3Cache("QA2_TEXTO","X3_TAMANHO")
Default nX       := 1

If Type("M->QDH_FILIAL") == "U"
	M->QDH_FILIAL := cFilla
ElseIf Type("M->QE6_FILIAL") == "U"
	M->QE6_FILIAL := cFilla
ElseIf Type("M ->QP6_FILIAL") == "U"
	M->QP6_FILIAL := cFilla
ElseIf Type("M->QM6_FILIAL") == "U"
	M->QM6_FILIAL := cFilla
EndIf

If cFilTxt == "2"
	If nModulo == 24 .AND. Type("M->QDH_FILIAL") <> "U" //Controle de Documentos
		If cFilAnt <> M->QDH_FILIAL
			cFilAnt := M->QDH_FILIAL
			lAux := .T.
		EndIf
	ElseIf nModulo == 21 .AND. Type("M->QE6_FILIAL") <> "U"  //Inspecao de Entradas
		If cFilAnt <> M->QE6_FILIAL
			cFilAnt := M->QE6_FILIAL
			lAux := .T.
		EndIf
	ElseIf nModulo == 25 .AND. Type("M->QP6_FILIAL") <> "U" //Inspecao de Processos
		If cFilAnt <> M->QP6_FILIAL
			cFilAnt := M->QP6_FILIAL
			lAux := .T.
		EndIf
	ElseIf nModulo == 22 .AND. Type("M->QM6_FILIAL") <> "U" //Metrologia
		If cFilAnt <> M->QM6_FILIAL
			cFilAnt := M->QM6_FILIAL
			lAux := .T.
		EndIf
	EndIf
EndIf

cQuebra:= If(lWord,CHR(11),Chr(13)+Chr(10))

// Tratamento para tabela QA2 exclusiva com filial do usuario
If nModulo == 24 .AND. cAlias == "QA2" .AND. FWModeAccess("QA2")=="E" .AND. ;
(Alltrim(FunName()) $ "QDOA050/QDOA030/QDOLOAD").AND. cFilTxt == "2"
	If Alltrim(cEspecie) == "CRI"
		cFilla := M->QDH_FILMAT
	Else
		cFilla := M->QDH_FILIAL
	Endif
Endif

If len(axTextos) > 0
	nPos := ascan(axTextos,{ |x| x[1] == nX })
	If nPos <> 0
		cTexto:= axTextos[nPos][2]
	EndIf
EndIf
If nPos == 0
	dbSelectArea( cAlias )
	dbSetOrder(If(cAlias=="QA2",1,IndexOrd()))
	If dbSeek( cFilla + cEspecie + cChave )
		If Alltrim(cAlias) == "QA2"
			While !Eof() .and. QA2_FILIAL+QA2_ESPEC+QA2_CHAVE == cFilla+cEspecie+cChave
				If At("\13\10",QA2->QA2_TEXTO) > 0
					cTexto+= SubStr(QA2->QA2_TEXTO,1,At("\13\10",QA2->QA2_TEXTO) - 1)
					If !Empty(Alltrim(cTexto))
						cTexto+= cQuebra
					Endif
				Else
					cTexto+= RTrim(QA2->QA2_TEXTO)
				EndIf
				QA2->(DbSkip())
			Enddo
		Else
			While !Eof() .and. QA3_FILIAL+QA3_ESPEC+QA3_CHAVE == cFilla+cEspecie+cChave
				If At("\13\10",QA3->QA3_TEXTO) > 0
					cTexto+= SubStr(QA3->QA3_TEXTO,1,At("\13\10",QA3->QA3_TEXTO) - 1)
					If !Empty(Alltrim(cTexto))
						cTexto+= cQuebra
					Endif
				Else
					cTexto+= RTrim(QA3->QA3_TEXTO)
				EndIf
				QA3->(DbSkip())
			Enddo
		Endif
	EndIf
EndIf

&(cAlias+"->(dbGoTo("+Alltrim(Str(nRec))+"))")
&(cAlias+"->(dbSetOrder("+Alltrim(Str(nOrd))+"))")

If lAux
	cFilAnt := cSavFilAnt
EndIf

Return(cTexto)

/*

Ŀ
Funo	 QA_GrvTxt  Autor  Vera / Wanderley 	     Data  02.12.97 
Ĵ
Descrio  Grava o texto editado com QA_TEXTO, a partir do axTextos   
Ĵ
Sintaxe	  QA_GrvTxt(ExpC1,ExpC2,ExpN1,ExpA1,ExpC3,ExpN2,ExpN3,ExpC4) 
Ĵ
Parametros ExpC1 = Chave do Texto (j convertida) 					  
			  ExpC2 = Especie do Texto									  
			  ExpN1 = Linha da Getdados que esta posicionado			  
			  ExpA1 = Vetor axTextos, que contem os textos digitados	  
			  ExpC3 = Alias do arquivo para gravacao (QA2 ou tempor.)	  
			   Obs.:  Se for arq. temp., deve ter a mesma estrut. do QA2.
			  ExpN2 = Tamanho da linha na tela - Default 75 Carct.		  
			  ExpN3 = Numero limite de linhas                     		  
			  ExpC4 = Filial a ser atribuida na variavel de memoria	  
Ĵ
 Uso		  Generico 												  
ٱ

*/
Function QA_GrvTxt(cChave,cEspecie,nX,axTextos,cAliasQA2,nTamLin,nLinLim,cFilla)

Local cOldAlias		:= Select()
Local cTexto		:= ""
Local nI 			:= 0
Local nLinhas		:= {}
Local cCampo 		:= "" // Auxiliar na gravao, para gerar macro do campo
Local cFilTxt		:= GetMv("MV_QATEXTO",.F.,"1") //1=SIM ; 2=NAO
Local lAux	 		:= .F.
Local cSavFilAnt 	:= cFilAnt
Local cAlias		:= Alias()
Local lAlterFil		:= .F.

Default nTamLin		:= 75
Default axTextos	:= {}
Default cAliasQA2 	:= "QA2"
Default nLinLim 	:= 0
Default cFilla   	:= xFilial(cAlias)

If Type("M->QDH_FILIAL") == "U"
	M->QDH_FILIAL := cFilla
ElseIf Type("M->QE6_FILIAL") == "U"
	M->QE6_FILIAL := cFilla
ElseIf Type("M ->QP6_FILIAL") == "U"
	M->QP6_FILIAL := cFilla
ElseIf Type("M->QM6_FILIAL") == "U"
	M->QM6_FILIAL := cFilla
EndIf

If cFilTxt == "2"
	If nModulo == 24 .AND. Type("M->QDH_FILIAL") <> "U" //Controle de Documentos
		If cFilAnt <> M->QDH_FILIAL .AND. cEspecie <> "CRI"
			cFilAnt := M->QDH_FILIAL
			lAux := .T.
		ElseIf cFilAnt <> M->QDH_FILIAL .AND. AllTrim(cEspecie) == "CRI"
			cFilAnt := M->QDH_FILMAT
			lAux := .T.
		EndIf
	ElseIf nModulo == 21 .AND. Type("M->QE6_FILIAL") <> "U" //Inspecao de Entradas
		If cFilAnt <> M->QE6_FILIAL
			cFilAnt := M->QE6_FILIAL
			lAux := .T.
		EndIf
	ElseIf nModulo == 25 .AND. Type("M->QP6_FILIAL") <> "U" //Inspecao de Processos
		If cFilAnt <> M->QP6_FILIAL
			cFilAnt := M->QP6_FILIAL
			lAux := .T.
		EndIf
	ElseIf nModulo == 22 .AND. Type("M->QM6_FILIAL") <> "U" //Metrologia
		If cFilAnt <> M->QM6_FILIAL
			cFilAnt := M->QM6_FILIAL
			lAux := .T.
		EndIf
	EndIf
EndIf

If len(axTextos) > 0

	cTexto    := axTextos[1,2]
	nTamLin   := If(nTamLin >= Len(QA2->QA2_TEXTO),nTamLin-6,nTamLin)

	While !Empty(cTexto)
		cLine := Subs(cTexto,1,nTamLin)
		nTexto:= At(Chr(13),cLine)
		If nTexto > 0
			cLine := Subs(cLine,1,nTexto-1)+"\13\10"
			nTexto+= 2
		Else
			If !Empty(cLine)
				nTexto := nTamLin+1
			    nLen1 := Len(cLine)
				nLen2 := Len(Trim(cLine))

				//verifica se tem espaco no final da linha para colocar no inicio do proximo registro
				If nLen1 <> nLen2
					cLine := Trim(cLine)
					nTexto -= (nLen1 - nLen2)
				EndIf
			Else
				If Len(cTexto) > nTamLin
					cLine := "\13\10"
					nTexto := nTamLin+1
				Endif
			EndIf
		EndIf
		cTexto := Subs(cTexto,nTexto)
		aadd(nLinhas,cLine)
		If nLinLim > 0 .AND. Len(nLinhas) > nLinLim  // Ateno regra J&J limita linhas  a 999 quando configurado
			Exit
		EndIf
	EndDo

	//Para incluir no QA2 mesmo texto em branco.
	If nModulo == 21 .or. nModulo == 25  			//inibido a gravao dos caracteres de controle segundo fnc : 00000023797/2010
		If Empty(axTextos[1,2])
//			aadd(nLinhas,"\13\10")
			aadd(nLinhas," ")
	    EndIF
	Endif

	// Tratamento para tabela QA2 exclusiva com filial do usuario
	If nModulo == 24 .AND. cAliasQA2 == "QA2" .AND. FWModeAccess("QA2")=="E" .AND. ;
	(Alltrim(FunName()) $ "QDOA050/QDOA030/QDOLOAD") .AND. cFilTxt == "2" .AND. Alltrim(cEspecie) == "CRI"
		cFilla 		:= M->QDH_FILMAT
		lAlterFil	:= .T.
	Endif

	dbSelectArea(cAliasQA2)
	dbSetOrder(1)
	dbseek(Iif(lAlterFil,cFilla,xFilial(cAliasQA2)) + cEspecie + cChave)
	For nI := 1 to len(nLinhas)
		If Alltrim(cAliasQA2) == "QA2"
			If !Eof() .and. QA2_FILIAL+QA2_ESPEC+QA2_CHAVE == Iif(lAlterFil,cFilla,xFilial(cAliasQA2))+cEspecie+cChave
				RecLock(cAliasQA2, .f.) // Lock
			Else
				RecLock(cAliasQA2, .t.) // Append
				cCampo  := cAliasQA2+"->"+cAliasQA2+"_FILIAL"
				&cCampo := Iif(lAlterFil,cFilla,xFilial(cAliasQA2))
				cCampo  := cAliasQA2+"->"+cAliasQA2+"_CHAVE"
				&cCampo := cChave
				cCampo  := cAliasQA2+"->"+cAliasQA2+"_ESPEC"
				&cCampo := cEspecie
			EndIf
			cCampo  := cAliasQA2+"->QA2_SEQ"
			&cCampo := StrZero(nI,3)
			cCampo  := cAliasQA2+"->"+cAliasQA2+"_TEXTO"
			&cCampo := nLinhas[nI]
			MsUnlock()
		Else
			If !Eof() .and. QA3_FILIAL+QA3_ESPEC+QA3_CHAVE == Iif(lAlterFil,cFilla,xFilial(cAliasQA2))+cEspecie+cChave
				RecLock(cAliasQA2, .f.) // Lock
			Else
				RecLock(cAliasQA2, .t.) // Append
				cCampo  := cAliasQA2+"->"+cAliasQA2+"_FILIAL"
				&cCampo := Iif(lAlterFil,cFilla,xFilial(cAliasQA2))
				cCampo  := cAliasQA2+"->"+cAliasQA2+"_CHAVE"
				&cCampo := cChave
				cCampo  := cAliasQA2+"->"+cAliasQA2+"_ESPEC"
				&cCampo := cEspecie
				cCampo  := cAliasQA2+"->"+cAliasQA2+"_SEQ"
				&cCampo := StrZero(nI,3)
				cCampo  := cAliasQA2+"->"+cAliasQA2+"_DATA"
				&cCampo := dDataBase
				cCampo  := cAliasQA2+"->"+cAliasQA2+"_DATINV"
				&cCampo := Inverte(dDataBase)
			EndIf
			cCampo  := cAliasQA2+"->"+cAliasQA2+"_TEXTO"
			&cCampo := nLinhas[nI]
			MsUnlock()
		Endif
		dbSkip()
	Next nI

	//Ŀ
	// Deleta as linhas anteriores se texto digitado for menor 	
	//
	If Alltrim(cAliasQA2) == "QA2"
		While QA2->(!Eof()) .And. QA2_FILIAL+QA2_ESPEC+QA2_CHAVE == xFilial('QA2')+cEspecie+cChave
			RecLock(cAliasQA2)
			dbDelete()
			MsUnlock()
			QA2->(dbSkip())
		Enddo
	Else
		While QA3->(!Eof()) .And. QA3_FILIAL+QA3_ESPEC+QA3_CHAVE == xFilial('QA3')+cEspecie+cChave
			RecLock(cAliasQA2)
			dbDelete()
			MsUnlock()
			QA3->(dbSkip())
		Enddo
	Endif
Else
	cTexto    := "\13\10"
	dbSelectArea(cAliasQA2)
	dbseek(Iif(lAlterFil,cFilla,xFilial(cAliasQA2)) + cEspecie + cChave)
	If Alltrim(cAliasQA2) == "QA2"
		If !Eof() .and. QA2_FILIAL+QA2_ESPEC+QA2_CHAVE == Iif(lAlterFil,cFilla,xFilial(cAliasQA2))+cEspecie+cChave
			RecLock(cAliasQA2, .f.) // Lock
		Else
			RecLock(cAliasQA2, .t.) // Append
			cCampo  := cAliasQA2+"->"+cAliasQA2+"_FILIAL"
			&cCampo := Iif(lAlterFil,cFilla,xFilial(cAliasQA2))
			cCampo  := cAliasQA2+"->"+cAliasQA2+"_CHAVE"
			&cCampo := cChave
			cCampo  := cAliasQA2+"->"+cAliasQA2+"_ESPEC"
			&cCampo := cEspecie
		EndIf
		cCampo  := cAliasQA2+"->QA2_SEQ"
		&cCampo := "001"
		cCampo  := cAliasQA2+"->"+cAliasQA2+"_TEXTO"
		&cCampo := cTexto
		MsUnlock()
	Else
		If !Eof() .and. QA3_FILIAL+QA3_ESPEC+QA3_CHAVE == Iif(lAlterFil,cFilla,xFilial(cAliasQA2))+cEspecie+cChave
			RecLock(cAliasQA2, .f.) // Lock
		Else
			RecLock(cAliasQA2, .t.) // Append
			cCampo  := cAliasQA2+"->"+cAliasQA2+"_FILIAL"
			&cCampo := Iif(lAlterFil,cFilla,xFilial(cAliasQA2))
			cCampo  := cAliasQA2+"->"+cAliasQA2+"_CHAVE"
			&cCampo := cChave
			cCampo  := cAliasQA2+"->"+cAliasQA2+"_ESPEC"
			&cCampo := cEspecie
			cCampo  := cAliasQA2+"->"+cAliasQA2+"_SEQ"
			&cCampo := "001"
			cCampo  := cAliasQA2+"->"+cAliasQA2+"_DATA"
			&cCampo := dDataBase
			cCampo  := cAliasQA2+"->"+cAliasQA2+"_DATINV"
			&cCampo := Inverte(dDataBase)
		EndIf
		cCampo  := cAliasQA2+"->"+cAliasQA2+"_TEXTO"
		&cCampo := cTexto
		MsUnlock()
	Endif
EndIf

dbSelectArea(cOldAlias)

Return NIl

/*

Ŀ
Funo	 QA_PicNum  Autor  Vera Lucia S. Simoes   Data  24.12.97 
Ĵ
Descrio  Retorna a picture para campos numericos, de acordo com seu 
			  tamanho e numero de casas decimais que devera' ter.        
Ĵ
Sintaxe	  QA_PicNum(ExpC1,ExpN1)									  
Ĵ
Parametros ExpC1 = Campo do arquivo que tera' a picture               
			  ExpN1 = Numero de casas decimais 						  
Ĵ
 Uso		  Generico 												  
ٱ


*/
Function QA_PicNum(cCampo,nDecim,nVlIn,nVlFin,lFzPt)

Local cPict   := ""
Local nRecSx3 := 0
Local nTam    := 0

Default	lFzPt := .T.

If lFzPt
	nRecSx3 := SX3->(Recno())
	nTam := GetSX3Cache(cCampo,"X3_TAMANHO")	// A picture tera' o tamanho def. p/ o campo no SX3
	SX3->(dbGoTo(nRecSx3))
Else
	nTam := Len(nVlIn)
Endif

If nDecim == 0
	cPict := "@E "+Replicate('9',nTam)
Else
	cPict := "@E "+Replicate('9',nTam-(nDecim+1)) + '.' + Replicate('9',nDecim)
EndIf

Return(cPict)

/*


Ŀ
Funo	  QA_PICT	 Autor  Wanderley Goncalves Jr Data  09/02/98 
Ĵ
Descrio  Retorna a picture de "cCampo" a partir de cValor.          
Ĵ
Sintaxe	  QA_PICT("cCampo",cValor)                                   
Ĵ
Parametros ExpC1 = Nome do Campo que tera' a picture a ser definida   
			  ExpC2 = Valor do Campo referencia (cpo. que define a pict) 
Ĵ
 Uso		  Geral 													  
ٱ


*/
Function QA_PICT(cCampo,cValor,nVlIn,nVlFin,lFzPt)
Local cPict := ""
Default nVlIn	:= 0
Default nVlFin	:= 0
Default lFzPt	:= .T.

//Ŀ
// Verifica o numero de casas decimais do Valor de Referencia 			
//
If lFzPt
	nDec := QA_NumDec(cValor)	 // Valor de Referencia
Else
	nDec := QA_NumDec(nVlIn)	 // Valor de Referencia
Endif
//Ŀ
// Define a picture a partir no. casas decimais do cCampo		
//
cPict := QA_PicNum(cCampo,nDec,nVlIn,nVlFin,lFzPt)
Return (cPict)

/*

Ŀ
Funo	  QA_Dupl	   Autor  Wanderley Gonalves	   Data  19/01/98 
Ĵ
Descrio  Duplica registros 								   		    
Ĵ
Parametros ExpL1 = Alias do arquivo										
			  ExpB1 = Bloco para Replace 									
			  ExpC1 = Arquivo para Replace									
Ĵ
 Uso		  SIGAQMT														
ٱ


*/

Function QA_Dupl(lVolta, bCodRepl, cArq)

Local nCampos, nI, nRec, lRetorno := .t., aCampos:= {}

dbSelectArea(cArq)

If lVolta
	nRec := Recno()
EndIf
nCampos := fCount()
For nI := 1 to nCampos
	aadd(aCampos,FieldGet(nI))
Next

If RecLock(cArq,.T.)

	For nI := 1 to len(aCampos)
		 Fieldput(nI, aCampos[nI])
	Next
	If !Empty(bCodRepl)
		Eval(bCodRepl)
	EndIf
	MsUnLock()
Else
	lRetorno := .f.
EndIf
If lvolta .Or. !lRetorno
	dbGoto(nRec)
EndIf
Return(lRetorno)

/*


Ŀ
Funo	  QA_VlHr	 Autor  Vera Lucia S. Simoes   Data  06/02/98 
Ĵ
Descrio  Valida campo Hora no formato 99:99						  
Ĵ
Sintaxe	  QA_VlHr(ExpC1) 											  
Ĵ
Parametros ExpC1 = Hora no formato 99:99 							  
Parametros ExpL1 = .T. indica p/ retorno .T. quando hora esta vazia   
Ĵ
Retorno	  Retorna .t. ou .f. p/ hora valida ou nao					  
Ĵ
 Uso		  Generico 												  
ٱ


*/
Function QA_VlHr(cHora,lEmpty,lPadrao)
Local lTMKPMS := If(GetMv("MV_QTMKPMS",.F.,1) == 1,.F.,.T.)
Local lRet := .T.

Default lEmpty  := .F.
Default lPadrao := .T.

If lTMKPMS
	If lPadrao
		If Val(Left(cHora,2)) < 0 .Or. Val(Left(cHora,2)) > 23 .Or.;
				Val(Right(cHora,2)) < 0 .Or. Val(Right(cHora,2)) > 59 .Or.;
				Empty(Right(cHora,2)) .Or. Empty(Left(cHora,2))
			lRet := .F.
		EndIf
	Else
	 	If !Empty(Left(cHora,4)) .Or. !Empty(Right(cHora,2))
			If Val(Left(cHora,4)) < 0 .Or. Val(Left(cHora,4)) > 9999 .Or.;
				Val(Right(cHora,2)) < 0 .Or. Val(Right(cHora,3)) > 59 .Or.;
				Empty(Right(cHora,2)) .Or. Empty(Left(cHora,4))
				lRet := .F.
			Endif
		Endif
	EndIf
EndIf

//Ŀ
// Verifica se esta com a hora em branco para nao validar 
//
If lEmpty
	If Empty(Left(cHora,2)) .And. Empty(Right(cHora,2))
		lRet := .T.
	EndIf
EndIf

Return(lRet)

/*


Ŀ
Funo	  QA_CALXM  Autor  Vera Lucia S. Simoes   Data  02/03/98 
Ĵ
Descrio  Retorna o calculo da mediana de um conjunto de valores	  
Ĵ
Sintaxe	  QA_CALXM(ExpA1)											  
Ĵ
Parametros ExpA1 = Array contendo os valores para o calculo			  
Ĵ
 Uso		  Generico 												  
ٱ


*/
Function QA_CALXM(aValores)

Local nXm,nLen

//Ŀ
// Ordena os valores em ordem crescente							  
//
Asort(aValores)

//Ŀ
// Verifica se o no. de elementos  par ou mpar e calcula mediana	  
//
nLen := len(aValores)
If mod(nLen,2) == 0	// par
	// A mediana  a mdia dos 2 valores centrais
	nXm := ( aValores[nLen/2] + aValores[(nLen/2)+1] ) / 2
Else
	// A mediana  o valor central
	nXm := aValores[(nLen+1)/2]
EndIf
Return(nXm)

/*


Ŀ
Funo	  QA_ENUM	 Autor  WanderLey Goncalves    Data  25/03/98 
Ĵ
Descrio  Verifica se campo e numerico e troca ponto por virgula	  
Ĵ
Sintaxe	  QE_NUM( Expc1 )											  
Ĵ
Parametros Expc1 = Campo a sofrer consistencia 						  
Ĵ
 Uso		  Geral 													  
ٱ


*/
Function QA_ENUM( cVar )
Local cValor := &cVar
Local lRet := .f.
If cValor # Nil
	If Valtype(cValor) == 'N'
		cValor := Str(cValor)
	EndIf

	If QA_VerNum(@cValor)
		&cVar := cValor
		lRet := .T.
	Else
		lRet := .F.
	EndIf
Endif
Return(lRet)

/*


Ŀ
Funo	  QA_CHKFIL Autor  Aldo Marini Junior	 Data  24.04.98 
Ĵ
Descrio  Gatilho para preencher a descricao da Filial 			  
Ĵ
Sintaxe	  QA_CHKFIL(ExpC1,ExpC2,ExpL2)								  
Ĵ
Parametros ExpC1 = Codigo da Filial									  
			  ExpC2 = Codigo da Filial a ser atualizada(variavel)        
			  ExpL1 = Indica se vai retornar descr.da filial ou Validar  
Ĵ
 Uso		  Generico-Cham. no X3_RELACAO,X3_INIBRW e gatilhos	      
ٱ


*/
Function QA_CHKFIL(nCodDe,cFilMat,lRetorna,cEmpMat)
Local aAreaSM0 := SM0->( GetArea() )
Local cArea    := Alias()
Local nOrdem   := IndexOrd()
Local xRet     := .F. // Logico ou caracter

DeFault cEmpMat  := cEmpAnt
DeFault cFilMat  := FWCODFIL() //FWGETCODFILIAL //SM0->M0_CODFIL
Default lRetorna := .F.

dbSelectArea("SM0")
If !dbSeek( cEmpMat + nCodDe ) .AND. !dbSeek( cEmpMat + RTrim(nCodDe) )
	If lRetorna
		If !dbSeek( cEmpMat )
			xRet := OemToAnsi(STR0049)	// "Filial Inexistente"
		Else
			xRet := AllTrim(SM0->M0_NOMECOM)
		Endif
	Else
		Help(" ",1,"QAFILNEXI")
		xRet := .F.
	Endif
Else
	cFilMat := nCodDe
	If lRetorna
		xRet := AllTrim(SM0->M0_NOME) + If(!Empty(SM0->M0_FILIAL),"/"+AllTrim(SM0->M0_FILIAL),"")
	Else
		xRet := .T.
	Endif
Endif

RestArea( aAreaSM0 )
If ! Empty(cArea)
	dbSelectArea( cArea )
	dbSetOrder( nOrdem )
Endif

IF READVAR() $ "M->QDD_FILA|M->QD2_FILDEP"
	If FWModeAccess("QAD") == "C" //Filial Compartilhada
		cCampo := SUBSTR(READVAR(), At( ">", READVAR() ) + 1, LEN(READVAR()))

		IF FWModeAccess("QAD", 2) == "E" //Unidade de negcio exclusiva

			IF SUBSTR(nCodDe, At( "U", FWSM0Layout() ), LEN(FWUnitBusiness())) <> FWUnitBusiness()
				// STR0100 - "O compartilhamento da tabela de departamentos(QAD) no permite utilizar esta filial."
				// STR0101 - "Escolha outra filial ou altere o comprtilhamento da tabela QAD."
				Help(NIL, NIL, FWX3Titulo(cCampo), NIL,STR0100, 1, 0, NIL, NIL, NIL, NIL, NIL, {STR0101})
				xRet := .F.
			ENDIF

		ENDIF

	EndIf
ENDIF

Return(xRet)

/*

Ŀ
Funo	  QA_CHKMAT Autor  Aldo Marini Junior	 Data  24.04.98 
Ĵ
Descrio  Verifica se funcionario existe e nao  demitido 			  
Ĵ
Sintaxe	  QA_CHKMAT(ExpC1,ExpC2,ExpL1)								  
Ĵ
Parametros ExpC1 = Codigo da Filial									  
			  ExpC2 = Codigo do Funcionario 							  
			  ExpL1 = Exibe o help ou nao								  
Ĵ
 Uso		  Generico-Cham. no X3_RELACAO,X3_INIBRW e gatilhos (Manual) 
ٱ

*/
Function QA_CHKMAT(cCodFI,cCodDe,lExibHelp)

Local lRet   := .T.
Local nOrdQAA:= QAA->(IndexOrd())

Default lExibHelp:= .T.

If !Empty(cCodDe)
	QAA->(DbSetOrder(1))
	If QAA->(DbSeek(cCodFI + cCodDe))
		If ! QA_SitFolh()
			If lExibHelp
				Help(" ",1,"QAUSRINAT") // Usuario esta com a situacao de Inativo no Cadastro.
			EndIf
			lRet:=.F.
		Endif
	Else
		If lExibHelp
			Help(" ",1,"QAUSRNEXI") // Usuario Nao Cadastrado
		EndIf
		lRet:= .F.
	Endif
Endif

QAA->(DbSetOrder(nOrdQAA))

Return(lRet)

/*

Ŀ
Funo	  TitSX3	 Autor  Vera Lucia S. Simoes   Data  03/02/98 
Ĵ
Descrio  Busca Titulo e Descricao do campo no SX3					  
Ĵ
Sintaxe	  TitSX3(ExpC1)											  
Ĵ
Parametros ExpC1 = Campo a ser pesquisado							  
Ĵ
Retorno	  Retorna o Array com o Titulo e Descricao do Campo		  
Ĵ
 Uso		  Generico 												  
ٱ

*/
Function TitSX3(cCampo)

Local cAlias:= Alias()
Local aTit	:= {}
Local nordSx3 := SX3->(Indexord())
Local nRegSx3 := SX3->(Recno())

dbSelectArea("SX3")
dbSetOrder(2)
If dbSeek(cCampo)
	aTit := {X3Titulo(),X3Descric()}
Endif
dbSetOrder(nOrdSx3)
dbgoto(nRegSx3)

dbSelectArea(cAlias)
Return( aTit )

/*


Ŀ
Funo	  WriteMv	 Autor  Vera Lucia S. Simoes   Data  26/05/98 
Ĵ
Descrio  Altera o valor de um parametro, via programa 			  
Ĵ
Sintaxe	  WriteMv(ExpC1,ExpU1,ExpC2,ExpN1,ExpN2) 				      
Ĵ
Parametros ExpC1 = Nome do parametro								  
			  ExpU1 = Valor a ser atualizado							  
			  ExpC2 = Tipo do parametro (C,N,D,L) 						  
			  ExpN1 = Tamanho do parametro								  
			  ExpN2 = Decimais do parametro 							  
Ĵ
Retorno	  Retorna .t. se gravou corretamente						  
Ĵ
 Uso		  Generico 												  
ٱ


*/
Function WriteMv(cNomePar,uValor,cTipo,nTam,nDec)

Local cAlias	:= Alias()
Local nRegSx6	:= SX6->(Recno())
Local lRetu 	:= .f.
Local cValor	:= uValor

Default cTipo := ValType(uValor)
Default nTam  := Len(uValor)
Default nDec  := 0

//Ŀ
// Transforma o valor em tipo caracter								  
//
If cTipo == "N"
	cValor := AllTrim(Str(uValor,nTam,nDec))
ElseIf cTipo == "D"
	cValor := DtoC(uValor)
ElseIf cTipo == "L"
	cValor := Iif(uValor,"T","F")
EndIf

//Ŀ
// Grava o novo conteudo											  
//
dbSelectArea("SX6")
If dbSeek(xFilial("SX6")+cNomePar)
	PutMv(cNomePar,cValor)
	lRetu := .t.
EndIf
dbgoto(nRegSx6)

dbSelectArea(cAlias)
Return(lRetu)

/*


Ŀ
Funo	  UltDia	 Autor  Vera Lucia S. Simoes   Data  15/05/98 
Ĵ
Descrio  Retona data com o ultimo dia corrente do mes/ano			  
Ĵ
Sintaxe	  UltDia(ExpC1,ExpC2)										  
Ĵ
Parametros ExpC1 = Mes 												  
			  ExpC2 = Ano 												  
Ĵ
Retorno	  Retorna data com o ultimo dia corrente do mes/ano		  
Ĵ
 Uso		  Generico 												  
ٱ


*/
Function UltDia(cMes,cAno)
Local aAux := { "31","28","31","30","31","30","31","31","30","31","30","31"}
Local cDia

If Val(cMes) == 2
	cDia := Iif( Mod(Val(cAno),4) == 0,"29","28" )
Else
	cDia := aAux[Val(cMes)]
EndIf
Return(Ctod(cDia+"/"+cMes+"/"+cAno,"ddmmyy"))

/*

Ŀ
Funo	 QABUTTON	 Autor  FERNANDO GODOY		 Data  25/06/98 
Ĵ
Descrio  Monta um buttonbar com uma botao especifico				  
Ĵ
Parametros ExpU1 - Acao do botao Ok.								  
			  ExpU2 - Acao do botao Cancel. 							  
			  ExpU3 - Acao do botao Personalizado.						  
			  ExpC1 - Tooltip do botao personalizado.					  
			  ExpO1 - Dialog mae da ButtonBar. 						  
			  ExpC2 - Bitmap na Dll Advanced para o botao personalizado. 
Ĵ
Retorno	  Nil														  
Ĵ
 Uso		 Siga quality 												  
ٱ


*/

Function QAButton(bOk,bCancel,bExec,cTooltip,oDlgPad,cBitmap)

Local oBar

Default cToolTip := ""

//DEFINE BUTTONBAR oBar SIZE 25,25 3D TOP OF oDlgPad
DEFINE BUTTON RESOURCE "S4WB005N" OF oBar ACTION NaoDisp() TOOLTIP STR0010 //"Recortar"
DEFINE BUTTON RESOURCE "S4WB006N" OF oBar ACTION NaoDisp() TOOLTIP STR0011 //"Copiar"
DEFINE BUTTON RESOURCE "S4WB007N" OF oBar ACTION NaoDisp() TOOLTIP STR0012 //"Colar"
DEFINE BUTTON RESOURCE "S4WB008N" OF oBar GROUP ACTION Calculadora() TOOLTIP STR0013 //"Calculadora..."
DEFINE BUTTON RESOURCE "S4WB009N" OF oBar ACTION Agenda() TOOLTIP STR0014 //"Agenda..."
DEFINE BUTTON RESOURCE "S4WB010N" OF oBar ACTION OurSpool() TOOLTIP STR0015 //"Gerenciador de Impresso..."
DEFINE BUTTON RESOURCE "S4WB016N" OF oBar GROUP ACTION HelProg() TOOLTIP STR0016 //"Help de Programa..."

DEFINE BUTTON oBtnEst RESOURCE cBitmap OF oBar GROUP ACTION Eval(bExec);
	TOOLTIP cToolTip + STR0017 //"<Ctrl + A>"

SetKey(1,oBtnEst:bAction)	// K_CTRL_A

DEFINE BUTTON oBtOk RESOURCE "OK" OF oBar GROUP ACTION ( lOk := Eval(bOk)) ;
	TOOLTIP STR0018 //"<Ctrl + O>"

SetKEY(15,oBtOk:bAction)	// K_CTRL_O

DEFINE BUTTON oBtCan RESOURCE "CANCEL" OF oBar ACTION ( Eval(bCancel)) ;
	TOOLTIP STR0019 //"<Ctrl + X>"

SetKEY(24,oBtCan:bAction)	// K_CTRL_X

oBar:bRClicked := { || AllwaysTrue() }

Return NIL

/*

Ŀ
Funo	  ExistCpo2 Autor  Jose Fernandes Godoy   Data  20/07/98 
Ĵ
Descrio  Processa o criterio de validacao dos campos				  
Ĵ
Sintaxe e  ExpL1:=Existcpo(ExpC1,ExpC2,ExpN1,ExpC3)					  
Ĵ
Parametros ExpC1 = Alias do arquivo a verificar						  
			  ExpC2 = Chave de pesquisa								  
			  ExpN1 = Ordem de pesquisa								  
			  ExpC3 = Mensagem a ser apresentada quando nao encontrar	  
			  ExpC4 = Mensagem a ser apresentada para Soluo			  
Ĵ
 Uso		  Generico 												  
ٱ

*/

Function ExistCpo2(cAlias,cChave,nOrdem,cHelp,cSoluc)

Local cFil      := Iif(Subs(cAlias,1,3) == "SM2",Space(FWSizeFilial()),cFilial)
Local nOldOrder := IndexOrd()
Local nSalvReg  := 0
Local xAlias    := Alias()

Default cHelp  := STR0020 //"Registro no existe"
Default cSoluc := ""

If Subs(cAlias,1,3) != "SM2" .AND. Type("cFilial") == "U"
    cFil := xFilial(cAlias)
EndIf

If ValType(cChave) = "U"
	cChave := &(ReadVar())
Endif

dbSelectArea(cAlias)

If !(EOF() .Or. RecC() == 0)
	nSalvReg := RecNo()
EndIf

nOrdem := Iif(nOrdem==Nil,IndexOrd(),nOrdem)
dbSetOrder(nOrdem)
dbSeek(cFil+cChave)

IF Found()
	If nSalvReg > 0
		dbGoTo(nSalvReg)
	EndIf
	dbSelectArea(xAlias)
	dbSetorder(nOldOrder)
	Return .T.
Else
	dbSetorder(nOrdem)
	dbSeek(cFil+cChave)
	If Found()
		If nSalvReg > 0
			Go nSalvReg
		EndIf
		dbSelectArea(xAlias)
		dbSetOrder(nOldOrder)
		Return .T.
	Endif
Endif

Tone(3000,1)
Help(NIL, NIL, STR0021, NIL, cHelp, 1, 0, NIL, NIL, NIL, NIL, NIL, {cSoluc} ) //"Ateno"

If nSalvReg > 0
	dbGoto(nSalvReg)
EndIf
dbSelectArea(xAlias)
dbSetorder(nOldOrder)
Return .F.

/*

Ŀ
Funo	  QaTit 	 Autor  Wanderley Goncalves    Data  30/07/98 
Ĵ
Descrio  Retorna descricao do campo conforme SX3					  
Ĵ
Sintaxe	  QaTit(ExpC1,ExpN1,ExpL1)									  
Ĵ
Parametros ExpC1 = Campo do SX3 									  
			  ExpN1 = Tamanho maximo do titulo 						  
			  ExpL1 = Retorna no formato "....: "                        
Ĵ
 Uso		  Generico 												  
ٱ

*/
Function QaTit(cCampo,nTam,lForm)

Local cTexto := Alltrim(TitSx3(cCampo)[1])

If lForm == Nil
	lForm := .f.
EndIf

If Len(cTexto) > nTam
	If lForm
		cTexto := Subs(cTexto,1,nTam-2)+': '
	Else
		cTexto := Subs(cTexto,1,nTam)
	EndIf
Else
	If lForm
		cTexto := cTexto + Replicate(".",nTam-Len(cTexto)-2)+': '
	EndIf
EndIf

Return(cTexto)

/*


Ŀ
Funo	 Q_SomaHora Autor  Sergio Silveira/FGodoy Data  7/29/1998
Ĵ
Descrio Soma um campo caracter em hora/minutos/segundos			  
Ĵ
Parametros [<ExpC1>] - Hora em formato HH:MM:SS						  
			  <ExpC2>	 - Tempo a adicionar em formato HH:MM:SS		  
Ĵ
Retorno	  <ExpC3> - Hora adicionada no formato HH:MM:SS			  
Ĵ
Uso		 Generico													  
ٱ


*/

Function Q_SomaHora(cHora,cHora2)
Local nSec		:= 0
Local nSec2 	:= 0
Local nHrInt	:= 0
Local nRestSec := 0
Local nMnInt	:= 0
Local lRet		:= .T.
Local cCap		:= OemToAnsi(STR0007) //"Ateno"

cHora 	:= Iif(ValType(cHora) <> "C",Time(),cHora )
cHora2	:= Iif(ValType(cHora) <> "C",Time(),cHora2)

If Val(Left(cHora,2)) > 23
	MessageDlg(OemToAnsi(STR0008),cCap,1) //"Hora informada invlida"
	lRet := .F.
EndIf
If lRet
	If Val(Left(cHora2,2)) > 23
		MessageDlg(OemToAnsi(STR0009),cCap,1)	//"Hora a adicionar informada invlida"
		lRet := .F.
	EndIf
EndIf

If lRet
	//Ŀ
	// Hora informada 
	//
	nSec		:= (Val(Left(cHora,2)) * 3600) + Val(Substr(cHora,4,2)) * 60 + Val(Right(cHora,2))
	nSec2 	:= (Val(Left(cHora2,2)) * 3600) + Val(Substr(cHora2,4,2)) * 60 + Val(Right(cHora2,2))
	nSec += nSec2
	If nSec > 86400
		nSec -= 86400
	EndIf
	nHrInt	:= Int(nSec/3600)
	nRestSec := nSec - nHrInt * 3600

	If nRestSec <> 0
		nMnInt	:= Int(nRestSec/60)
		nRestSec := nRestSec - (nMnInt * 60)
	EndIf
EndIf

cHora := StrZero(nHrInt,2) + ":" + StrZero(nMnInt,2) + ":" + StrZero(nRestSec,2)

Return cHora

/*

Ŀ
Funo	  Pertence2 Autor  Jose Fernades Godoy    Data 12/08/1998
Ĵ
Descrio  Processa o criterio de validacao dos campos		    	  
Ĵ
Sintaxe e  ExpL1 :=  Pertence(ExpC1,ExpC2,ExpC3)					  
Ĵ
Parametros ExpL1 = Valor Logico de Retorno (.T. ou .F.) 			  
			  ExpC1 = Campo a verificar								  
			  ExpC2 = String onde deve estar contida a ExpC1			  
			  ExpC3 = Texto da Mensagem a ser Exibida.					  
Ĵ
 Uso		  Generico 												  
ٱ

*/

Function Pertence2(cString,cCampo,cTexto)
LOCAL cElem

IF cCampo == nil
	cCampo := &(ReadVar())
ENDIF
IF ValType(cCampo) = "N"
	While Len(cString) > 0
		cElem:=Parse(@cString)
		IF Val(cElem) = cCampo
			Return .T.
		Endif
	End
	cCampo:=" "
ENDIF

If !(cCampo$cString)
	MessageDlg(cTexto,,1)
	Return .F.
Endif
Return .T.

/*


Ŀ
Funo	 MsgGet2	 Autor  Fernando Godoy		 Data 10/14/1998
Ĵ
Descrio Dialog para Get com um texto na tela 						  
Ĵ
Parametros[ExpC1] - Titulo da Janela								  
			 [ExpC2] - Texto a ser mostrado na tela					  
			 [ExpC3] - Variavel passada com parametro @ para o GET		  
			 [ExpC4] - Nome do icone na Dll ativa 						  
			 [ExpB1] - Bloco de codigo com valid do GET 				  
			 [ExpC5] - Picture do GET 									  
Ĵ
Retorno	 ExpL1 - .T. ou .F. dependendo do botao presionado			  
Ĵ
Uso		 Generico													  
ٱ


*/

Function MsgGet2( cTitle, cText, uVar, cIcoFile, bValidGet, cPict )

Local oDlg
Local lOk	:= .f.
Local oGet

DEFAULT uVar	  := ""
DEFAULT cText	  := ""
DEFAULT cTitle   := STR0021 //"Ateno"
DEFAULT bValidGet:= {||.T.}
DEFAULT cIcoFile := "WATCH"
DEFAULT cPict	  := ""

DEFINE MSDIALOG oDlg FROM 10, 20 TO 18, 59.5 TITLE cTitle OF GetWndDefault()

@ 0.4, 4 SAY cText OF oDlg SIZE 120, 20
@ 2.2, 4 MSGET oGet VAR uVar SIZE 120, 10 OF oDlg PICTURE cPict
oGet:bGotFocus := {|| oGet:SetPos(0)}
oGet:Set3dLook()
oGet:bValid := bValidGet

@ 0.5, 1 ICON RESOURCE cIcoFile OF oDlg

@ 4, 20 BUTTON STR0022 OF oDlg SIZE 35, 12 ; //"&Ok"
	ACTION ( lOk := .T., oDlg:End() )

@ 4, 29 BUTTON STR0023 OF oDlg SIZE 35, 12 ; //"&Cancela"
	ACTION ( lOk := .F. , oDlg:End() ) CANCEL

ACTIVATE MSDIALOG oDlg CENTERED

Return lOk

/*


Ŀ
Funo	 ShowHide	 Autor  Fernando Godoy		 Data  9/17/1998
Ĵ
Descrio Mostra e Esconde Objetos na tela							  
Ĵ
ParametrosExpA1 - Array com os Handles dos Objetos					  
			 ExpA2 - Array com a posicao no array para ser exibido		  
Ĵ
Retorno	 Nil 														  
Ĵ
Uso		 A140GrvAll												  
ٱ


*/

Function ShowHide(aHandle,aShow)
Local nLoop := 1

For nLoop := 1 To Len(aHandle)
	If StrZero(nLoop,2) $ aShow[1]
		aHandle[nLoop]:Show()
	Else
		aHandle[nLoop]:Hide()
	EndIf
	aHandle[nLoop]:Refresh()
Next nLoop

Return Nil

/*/


Ŀ
Funo	  QA_DESUM  Autor  Vera/Wanderley		 Data  16.10.98 
Ĵ
Descrio  Retorna a Descricao da Unidade de Medida, completa ou 	  
			  resumida.												  
Ĵ
Sintaxe	  QA_DESUM()												  
Ĵ
Parametros ExpC1 = Codigo da Unidade Medida / Amostragem			  
			  ExpL1 = Indica se  gatilho								  
			  ExpN1 = Indica se retornara a descr. resumida ou completa  
Ĵ
Retorno	  ExpC1 = Descricao 										  
			  Obs.: Nao retornar array com as 2 descr. pq. da' erro no   
			  		no inicializador padrao.							  
Ĵ
 Uso		  Generico 												  
ٱ


/*/
Function QA_DESUM(cUnid,lGatilho,nOpDes)

Local aArea := GetArea()
Local cRet  := Space(GetSX3Cache("AH_UMRES","X3_TAMANHO"))

Default nOpDes := 1
Default lGatilho := .t.

If Type("INCLUI") <> "L"
	Inclui:= .F.
EndIf

IF !Inclui .Or. lGatilho // Se Inic. Padrao ou gatilho
	If !Empty(cUnid)
		SAH->(dbSetOrder(1))
		SAH->(dbSeek(xFilial("SAH")+cUnid))
		cRet := Iif(nOpDes==1,SAH->AH_UMRES,SAH->AH_DESCPO)
	EndIf
EndIf
RestArea(aArea)

Return(cRet)

/*


Ŀ
Funo	 GeraTxt32  Autor  Fernando Godoy		 Data 12/22/1998
Ĵ
Descrio Grava um arquivo Txt no formato da OCX QC_CHART			  
Ĵ
ParametrosExpA1 - Array com os dados a gravar						  
			 ExpC1 - Arquivo para dados								  
			 ExpC2 - Diretorio para gerar o arquivo					  
Ĵ
Retorno	 ExpL1 - TRUE - caso criou o arquivo corretamente e FALSE	  
			  caso tenha havido alguma falha							  
Ĵ
Uso		 Generico													  
ٱ


*/
Function GeraTxt32( aDados , cFile , cDir )
Local lOk		:= .T.
Local nHandle	:= 0
Local nSec		:= 0

Default cFile	:= "QACHART.SPC"
Default aDados := { }

cDir := Alltrim(cDir)
if !(Right(cDir,1) == "\")
	cDir += "\"
Endif

//Ŀ
//											
//	 Formato do array a ser passado		    
//											
// Array de uma coluna contendo uma string 
//											
//
If File( cDir+cFile )
	If FErase(cDir+cFile) == 0
		lOk := .T.
	else
		nSec := Seconds()
		While FErase(cDir+cFile) <> 0
			if Seconds() > nSec + 5
				lOk := .F.
				Exit
			Endif
		EndDo
		if !lOk
			MsgStop(STR0024,STR0021) //"Outro usurio utilizando o arquivo. Tente novamente" ### "Ateno"
		Endif
	Endif
Endif
If lOk
	IF (nHandle := FCREATE(cDir+cFile, FC_NORMAL)) == -1
		lOk := .F.
		If FError()=3											// Path Not Found
			MsgStop(STR0026,STR0021) //"O Diretrio/Pasta informado no parmetro 'MV_QDIRGRA' no existe. O grfico no poder ser gerado." ### "Ateno"
		Else
			MsgStop( STR0025 + cDir+cFile,STR0021  )	//"No foi possvel criar o arquivo para o grfico " ### "Ateno"
		EndIf
	Endif
Endif
If lOk
	aEval( aDados, { |cTexto,nX| FWrite( nHandle, cTexto + Chr(13)+Chr(10) ), Len(cTexto) } )
	FClose(nHandle)
Endif
Return lOk

/*


Ŀ
Funo	 QA_Leg 	 Autor  Fernando Godoy		 Data  2/24/1999
Ĵ
Descrio Legenda para os ensaios									  
Ĵ
ParametrosExpO1 - Handle da Dlg de ensaios							  
			  															  
Ĵ
Retorno	 Nil 														  
Ĵ
Uso		 Generico													  
ٱ


*/

Function QA_Leg(oDlgEns)
Local oDlgLeg
Local oBtn
Local oBmp1
Local oBmp2
Local oBmp3

DEFINE MSDIALOG oDlgLeg TITLE STR0035 FROM 1,1 TO 098,285 OF oDlgEns PIXEL //"Legenda"

@ 05,5 BITMAP oBmp1 RESOURCE "BR_VERMELHO" SIZE 8,8 PIXEL OF oDlgLeg NOBORDER WHEN .F.
@ 15,5 BITMAP oBmp2 RESOURCE "BR_VERDE"    SIZE 8,8 PIXEL OF oDlgLeg NOBORDER WHEN .F.
@ 25,5 BITMAP oBmp3 RESOURCE "BR_CINZA"    SIZE 8,8 PIXEL OF oDlgLeg NOBORDER WHEN .F.

@ 05, 15 SAY STR0036 OF oDlgLeg PIXEL SIZE 80,10 //"Ensaio com No Conformidades"
@ 15, 15 SAY STR0037 OF oDlgLeg PIXEL SIZE 80,10 //"Ensaio sem No Conformidades"
@ 25, 15 SAY STR0038 OF oDlgLeg PIXEL SIZE 80,10 //"Ensaio sem medies"

@ 01,103 BUTTON oBtn PROMPT STR0039 PIXEL OF oDlgLeg ACTION oDlgLeg:End()	SIZE 35,11 DEFAULT//"&Voltar"

ACTIVATE MSDIALOG oDlgLeg CENTER

Release Objects oBmp1
Release Objects oBmp2
Release Objects oBmp3

Return Nil

/*


Ŀ
Funo	 QA_LegTree Autor  Fernando Godoy		 Data  2/25/1999
Ĵ
Descrio Legenda sobre as cores das pastas do dbtree				  
Ĵ
ParametrosNil 														  
			  															  
Ĵ
Retorno	 Nil 														  
Ĵ
Uso		 Generico													  
ٱ


*/

Function QA_LegTree()
Local oDlgLeg
Local oBtn
Local oBmp1
Local oBmp2
Local oBmp3
Local oBmp4
Local oBmp5

DEFINE MSDIALOG oDlgLeg TITLE STR0035 FROM 1,1 TO 128,284 OF GetWndDefault() PIXEL //"Legenda"

@ 05,5 BITMAP oBmp1 RESOURCE "FOLDER10" SIZE 8,8 PIXEL OF oDlgLeg NOBORDER WHEN .F.
@ 15,5 BITMAP oBmp2 RESOURCE "FOLDER12" SIZE 8,8 PIXEL OF oDlgLeg NOBORDER WHEN .F.
@ 25,5 BITMAP oBmp3 RESOURCE "FOLDER14" SIZE 8,8 PIXEL OF oDlgLeg NOBORDER WHEN .F.
@ 35,5 BITMAP oBmp4 RESOURCE "FOLDER5"  SIZE 8,8 PIXEL OF oDlgLeg NOBORDER WHEN .F.
@ 45,5 BITMAP oBmp5 RESOURCE "FOLDER7"  SIZE 8,8 PIXEL OF oDlgLeg NOBORDER WHEN .F.

@ 05, 16 SAY STR0040 OF oDlgLeg PIXEL SIZE 83,10 //"Laboratrio com laudo Aprovado"
@ 15, 16 SAY STR0041 OF oDlgLeg PIXEL SIZE 83,10 //"Laboratrio com Data de Entrada"
@ 25, 16 SAY STR0042 OF oDlgLeg PIXEL SIZE 83,10 //"Pasta inacessvel"
@ 35, 16 SAY STR0043 OF oDlgLeg PIXEL SIZE 83,10 //"Laboratrio sem informaes"
@ 45, 16 SAY STR0044 OF oDlgLeg PIXEL SIZE 83,10 //"Laboratrio com laudo Reprovado"

@ 01,103 BUTTON oBtn PROMPT STR0039 PIXEL OF oDlgLeg ACTION oDlgLeg:End() SIZE 35,11 DEFAULT //"&Voltar"

ACTIVATE MSDIALOG oDlgLeg CENTER

Release Objects oBmp1
Release Objects oBmp2
Release Objects oBmp3
Release Objects oBmp4
Release Objects oBmp5

Return Nil

/*/


Ŀ
Funo	 ReturnTrue Autor  Yale Amorim			 Data  06/10/98 
Ĵ
Descrio  Retorna sempre verdadeiro ao executar qualquer funcao ou   
			  expressao como parametro.								  
Ĵ
Sintaxe	  ReturnTrue( x )							     			  
Ĵ
  Ex: 	  ...VALID If(nVar>10,ReturnTrue((nVar:=1,oDlg:End())),.f.)  
Ĵ
 Uso		  Generico 												  
ٱ


/*/
Function ReturnTrue(x)
Return .T.

/*/


Ŀ
Funo	 ReturnFalse Autor Yale Amorim			 Data  06/10/98 
Ĵ
Descrio  Retorna sempre falso ao executar qualquer funcao ou		  
			  expressao como parametro.								  
Ĵ
Sintaxe	  ReturnFalse( x )											  
Ĵ
  Ex: 	  ...VALID If(nVar>10,.T.,ReturnFalse((nVar:=1,oDlg:End()))) 
Ĵ
 Uso		  Generico 												  
ٱ


/*/
Function ReturnFalse(x)
Return .F.


/*/


Ŀ
Funo	  InfoSX2	 Autor  Yale Amorim			 Data  06/10/98 
Ĵ
Descrio  Traz o conteudo do arquivo SX2 de um referido alias de	  
			  arquivo, retornando o conteudo do campo especificado. 	  
Ĵ
Sintaxe	  InfoSX2( <cAlias>,<cCampo> ) => uResult		    		  
Ĵ
 Uso		  Generico 												  
ٱ


/*/
Function InfoSX2( cAlias, cCampo )
cAlias := If( cAlias == NIL, Alias(), cAlias )
cCampo := If( cCampo == NIL, "", cCampo )
SX2->( DbSeek( cAlias ) )
Return SX2->( FieldGet( FieldPos( cCampo ) ) )

/*/


Ŀ
Funo	  CriaTemp  Autor  Yale Amorim			 Data  06/10/98 
Ĵ
Descrio  Cria um indice temporario atribuindos a funcao "INDREGUA()"
			  e apaga automaticamente o arquivo temporario associado	  
			  ao arquivo, mensionado no parametro <cArqTmp>.			  
Ĵ
Retorno	  Esta funcao retorna o nome do novo arquivo de indice asso- 
			  ciado ao arquivo de dados. 								  
Ĵ
Sintaxe	  CriaIndice(<cAlias>,<cChave>,<cFiltro>,<cMens>,<cArqTmp>)  
Ĵ
Parametros cAlias  - Alias do arquivo em uso. Assume o corrente caso  
			  			 nao especificado.								  
			  cChave  - Indice ao qual devera ser criado. Assume o cor-  
			  			 rente caso nao especificado. 					  
			  cFiltro - Filtro de selecao de registros. 				  
			  cMens   - Mensagem a ser apresentado na criacao do indice  
			  cArqTemp- Arquivo temporario anterior. Caso seja informado 
			  			 e existe, sera excluido e criado um novo arquivo 
Ĵ
 Uso		  Generico 												  
ٱ


/*/
Function CriaTemp( cAlias, cChave, cFiltro, cMens, cArqTemp )
Local nIndice
cAlias	:= If( cAlias == NIL, Alias(), cAlias )
cArqTemp := If( cArqTemp == NIL, "", cArqTemp )
DbSelectArea( cAlias )
cChave	:= If( cChave == NIL, IndexKey(), cChave )
nIndice	:= ApagaTemp( cArqTemp )
cArqTemp := CriaTrab( NIL,.F. )
cMens 	:= If( cMens == NIL, OemToAnsi( STR0045 ), cMens )  // "Aguarde..."

IndRegua( cAlias, cArqTemp, cChave,, cFiltro, cMens )

nIndice := RetIndex(cAlias)

DbSetOrder( nIndice + 1 )
DbGoTop()
Return cArqTemp


/*/


Ŀ
Funo	  ApagaTemp Autor  Yale Amorim			 Data  06/10/98 
Ĵ
Descrio  Apaga o indice temporario associado ao arquivo de dados.   
Ĵ
Sintaxe	  ApagaTemp(<cAlias>,<cArqTmp>) 							  
Ĵ
Parametros cAlias  - Alias do arquivo em uso. Assume o corrente caso  
			  			 nao especificado.								  
			  cArqTemp- Arquivo temporario associado ao arquivo de dados 
Ĵ
 Uso		  Generico 												  
ٱ


/*/
Function ApagaTemp( cArqTemp, cAlias )
Local nIndex
cAlias	:= If( cAlias == NIL, Alias(), cAlias )
cArqTemp := If( cArqTemp == NIL, "", cArqTemp )

DbSelectArea( cAlias )
nIndex	:= RetIndex( cAlias )
SET FILTER TO

If !Empty( cArqTemp )
	cArqTemp += ".NTX"
	FileDelete( cArqTemp )
End

cArqTemp := ""
Return nIndex

/*/


Ŀ
Funo	 FileDelete Autor  Yale Amorim			 Data  06/10/98 
Ĵ
Descrio  Apaga o arquivo especificado em um dado diretorio. 		  
Ĵ
 Uso		  Generico 												  
ٱ


/*/
Function FileDelete( cFile )
Local lResult := .F.
If File( cFile )
	If FErase( cFile ) == 0
		lResult := .T.
	End
End
Return lResult

/*/


Ŀ
Funo    Call32     Autor  Cesar Eduardo Valadao  Data  17/09/99 
          CallDLL32                                               
          CloseDLL32                                              
Ĵ
Descrio  Call32 - Abre a DLL. A nRet32 Deve Ser Publica e Passada   
                    Passada Por Referencia.                           
           CallDLL32 - Substitui a Chamada em MS-C, que no Protheus   
                    Nao eh Mais Necessaria.                           
           CloseDLL32 - Fecha a DLL.                                  
           No Protheus Toda a Comunicacao com as DLL's Sao Feitas Por:
           ExecInDLLOpen - Abre a DLL. Recebe o Nome da DLL e retorna 
                    o Handle da DLL.                                  
           ExecInDLLRun - Executa a DLL.                              
                    Recebe o Handle, o Identificador e a String de    
                    Entrada. Retorna Uma String de Resposta.          
           ExecInDLLClose - Fecha a DLL.                              
ٱ


/*/
Function Call32(nRet32)
/*
Inibida esta funcao para ser incluida na funcao CallDll32, devido ao problema que executado
o sistema atraves do AP5RMT. Nao entra no programa SIGAQIE.PRW e consequentemente da por falta
da variavel nRet32.

nRet32 := ExecInDLLOpen("QAChart.DLL")
if nRet32 == -1
	Final("QAChart.DLL Nao Localizada. Ela deve estar no diretorio BIN.")
endif
*/
Return Nil

/*/

Ŀ
Funcao	  CallDll32 Autor  Robson Ramiro A. Oliv  Data  03/07/03 
Ĵ
Descricao  Abre a DLL MsChart ou QaChart                         	  
Ĵ
Sintaxe	 CallDll32 	   											  
Ĵ
Parametros ExpC1 = Funcao a ser executada na DLL					  
           ExpC2 = Nome do arquivo SPC com os dados					  
           ExpC3 = Tipo da carta de controle/atributo				  
           ExpC4 = Diretorio onde se encontra o arquivo SPC  		  
           ExpC5 = Tipo de grafico a ser exibido					  
           ExpC6 = Nome do usuario logado   						  
           ExpC7 = "FALSE" ou "TRUE" para somente a geracao do BMP	  
Ĵ
 Uso		  Generico 												  
ٱ

/*/

Function CallDll32(pTipo, pFile, pTipoCarta, pDirSiga, pWhatForm, pUser, pPrint, pView)

Local nRet, cResposta
Local cPath		:= GetRemoteIniName()
Local cPathAlt  := GetMv("MV_QDIRGRA")
Local lPathAlt  := .F.

Private nRet32 		:= 0

Default pPrint 		:= "FALSE"
Default pView 		:= "TRUE"
Default pTipoCarta  := ""
Default pDirSiga	:= ""
Default pWhatForm	:= ""
Default pUser		:= ""

If GetBuild() >= "7.00.170117A"
	Alert(STR0097) //"A verso atual do smartclient no suporta os grficos selecionados"
	nRet := -1
	Return(nRet)
EndIf

If At("\",cPath) > 0
	Do While Right(cPath,1) <> "\"
		If Right(cPath,1) <> "\"
			cPath := Stuff(cPath,Len(cPath),1,"")
		Endif
	Enddo
Else
    lPathAlt := .T.
	If QA_VerQDir(cPathAlt)
	   cPath := cPathAlt
	Else
		Return
	EndIf
Endif

If File(cPath+"MsChart.DLL",2)
	If !lPathAlt
		nRet32 := ExecInDLLOpen("MsChart.DLL")
	Else
		nRet32 := ExecInDLLOpen(cPath+"MsChart.DLL")
	EndIf
Else
	nRet32 := ExecInDLLOpen("QaChart.DLL")
Endif

If GetRemoteType() == 2 .and. pTipoCart <> "" // Remote Linux
	Alert(OemToAnsi(STR0085)) //"Esta opcao nao esta disponivel para Remote LINUX !"
	nRet := -1
	Return(nRet)
Endif

If nRet32 == -1
	Alert(OemToAnsi(STR0064)) //"DLL de Graficos nao localizada. Ela deve estar no diretorio BIN\REMOTE."
Else
	If Upper(pTipo) == "SHOWCHART"
		cResposta := ExecInDLLRun(nRet32,1,pFile+","+pTipoCarta+","+pDirSiga+","+pWhatForm+","+pUser+","+pPrint+","+pView+",")
	Elseif Upper(pTipo) == "NOFUNC"
		cResposta := ExecInDllRun(nRet32,0,pFile)
	Elseif Upper(pTipo) == "STUDENTINV"
		cResposta := ExecInDLLRun(nRet32,2,pFile)
		ExecInDLLClose(nRet32)
		Return cResposta
	Endif

	nRet := Val(cResposta)
	ExecInDLLClose(nRet32)
EndIf

Return(nRet)


/*/

Ŀ
Funcao	  CloseDll32 Autor  Robson Ramiro A. Oliv  Data  03/07/03 
Ĵ
Descricao  Abre a DLL MsChart ou QaChart                         	   
Ĵ
Sintaxe	 CallDll32 	   											   
Ĵ
Parametros Void                                  				       
Ĵ
 Uso		  Generico 						       					   
ٱ

/*/
Function CloseDll32

Local 	cPath	:= GetRemoteIniName()
Private	nRet32	:= 0

Do While Right(cPath,1) <> "\"
	If Right(cPath,1) <> "\"
		cPath := Stuff(cPath,Len(cPath),1,"")
	Endif
Enddo

If File(cPath+"MsChart.DLL",2)
	nRet32 := ExecInDLLOpen("MsChart.DLL")
Else
	nRet32 := ExecInDLLOpen("QaChart.DLL")
Endif

ExecInDLLClose(nRet32)

Return(Nil)


/*

Ŀ
Funao    QA_USUARIO Autor  Aldo Marini Junior        Data  09/08/01 
Ĵ
Descriao Retorna um array com dados do Usuario Logado                   
Ĵ
Sintaxe   QA_USUARIO()                                                   
Ĵ
Parametro Nenhum                                                         
Ĵ
Uso       SIGAQNC - Generico                                             
ٱ

*/
Function QA_USUARIO()

Local aArray 	:= {.F.,"","","","",""}
Local aAreaAnt 	:= GetArea()
Local aAreaQAA	:= QAA->(GetArea())

DbSelectArea("QAA")
DbSetOrder(6)

If QAA->(DbSeek(TRIM(UPPER(cUsername))))
   aArray[1]:= .T.
   aArray[2]:= QAA->QAA_FILIAL
   aArray[3]:= QAA->QAA_MAT
   aArray[4]:= QAA->QAA_CC
   If !Empty(AllTrim(QAA->QAA_EMAIL))
	   aArray[5]:= QAA->QAA_EMAIL
	Else
		If !Empty(UsrRetMail(__CUSERID))
			aArray[5] := AllTrim(UsrRetMail(__CUSERID))
		Else
			aArray[5] := "SIGA"+cModulo
		EndIf
	Endif
	aArray[6]:= QAA->QAA_NOME
EndIf

RestArea(aAreaQAA)
RestArea(aAreaAnt)

Return aArray
/*


ͻ
Programa  MSRPortQM2Autor  Fernandes/Denis      Data   01/22/02   
͹
Desc.     Funcao responsavel pela leitura dos dados do instrumento    
          conectado a uma porta.                                      
͹
Retorno	 ExpL1 : Timer 				                      		  
          ExpL2 : Porta que esta conectado o instrumento              
          ExpL3 : Bits por Segundo                                    
          ExpL4 : Valor                                               
          ExpL5 : Bit Dados                                           
          ExpL6 : Bit Stop                                            
          ExpL7 : TimeOut                                             
          ExpL8 : Casa(s) Decimal(is) a ser(em) considerada(s)		  
͹
Uso        QMTA140/141/142                                            
ͼ


*/
Function MSRPortQM2( oTmr,cPorta, cBaudRate, nTeste, cData, nStop,cTimeout, nTam )
Local cBufferVar := Space(100)
Local nHandle := -1
Local nLen	:= 1
Default lOnline := .T.
Default nTam:= 2

If lOnline //Flag para identificar que o instrumento esta ativado a porta
	//Ŀ
	//Desativa o timer para nao chamar novamente a funcao enquanto esta lendo
	//
	oTmr:DeActivate()
	//Ŀ
	//Realiza abertura da Porta
	//
	If MyOpenQM2( @nHandle, cPorta, cBaudRate, nTeste, cData, nStop, cTimeout)
		//Ŀ
		//Aguarda 1 segundo para conseguir ler
		//
		inkey(1)
		nBytes := FRead(nHandle, @cBufferVar, Len(cBufferVar))
		cBufferVar := SubStr(StrTran(cBufferVar,".",","),nLen,Len(cBufferVar))
		If SubStr(cBufferVar,1,1) == "+"
			nLen := 3
		Endif
		cBufferVar := SubStr(StrTran(cBufferVar,".",","),nLen,(Len(cBufferVar)-1))
		cBufferVar := StrTran(Str(SuperVal(cBufferVar),10,nTam),".",",")
		FClose( nHandle )
	EndIf
	//
	//Ativa o timer novamente, para chamar a funcao "n" vezes
	//
	oTmr:Activate()
Endif
Return cBufferVar
/*


ͻ
Programa  MyOpenQM2 Autor  Fernandes/Denis      Data   01/22/02   
͹
Desc.     Funcao responsavel pela abertura da porta a qual o instru-  
          mento esta conectado.                                       
͹
Retorno	 ExpL1 : Handle(status da porta)			         		  
          ExpL2 : Porta que esta conectado o instrumento              
          ExpL3 : Bits por Segundo                                    
          ExpL4 : Valor                                               
          ExpL5 : Bit Dados                                           
          ExpL6 : Bit Stop                                            
          ExpL7 : TimeOut                                             
͹
Uso        QMTA140/141/142                                            
ͼ


*/
Function MyOpenQM2( nHandle, cPorta, cBaudRate, nTeste, cData, nStop, cTimeout )
Local lRet := .T.
Local cSettings := cBaudRate + "," +;
						 Alltrim(Str(nTeste))+","+;
						 cData+","+;
						 Alltrim(Str(nStop)+","+;
						 Alltrim(cTimeOut))
If nAmbiente == 1
	cPorta := "SERVER"+cPorta
Endif
//Ŀ
//O parametros aSettings dever ter o seguinte formato:               
//aSettings := cBaudRate + "," + cParity + "," + cData + "," + cStop 
//Onde:                                                              
//     cBaudRate pode ser qualquer valor das constantes de velocidade
//     cParity pode ser qualquer valor das contantes de paridade     
//     cData pode ser qualquer valor entre 4 e 8                     
//     cStop pode ser qualquer valor das contantes de Stopbits       
//                                                                   
//OBS: Sempre separados por virgula (,) e sem espacos                
//

nHandle := fopenPort(cPorta,cSettings)

If nHandle == -1
	MsgStop(OemToAnsi(STR0047)+Alltrim(cPorta)+OemToAnsi(STR0048)) //"Nao foi possivel abrir a porta: " - ". Verifique as configuracoes: "
	lRet := .F.
Endif

Return lRet

/*

Ŀ
Funo	  QA_NFUNC  Autor  Eduardo de Souza       Data  23/03/02 
Ĵ
Descrio  Gatilho para preencher a descricao da Funcao/Cargo 		  
Ĵ
Sintaxe	  QA_NFUNC(ExpC1,ExpL1)									  
Ĵ
Parametros ExpC1 = Codigo da Funcao/Cargo							  
			  ExpL1 = Indica se e' gatilho                               
			  ExpC2 = Filial da Funcao                                   
Ĵ
 Uso		  Generico - Cham. no X3_RELACAO,X3_INIBRW e gatilhos        
ٱ

*/
Function QA_NFUNC(cCodDe,lGatilho,cFilCod)

Local cDesc:= ""

Default lGatilho:= .T.
Default cFilCod := xFilial("QAC")

If Type("INCLUI") <> "L"
	Inclui:= .F.
EndIf

cDesc:= Space(Len(QAC->QAC_DESC))

If !Inclui .Or. lGatilho	// Se Inic. Padrao ou gatilho a partir do cod. Depart.
	If QAC->(DbSeek(cFilCod + cCodDe))
		cDesc:= QAC->QAC_DESC
	Endif
EndIf

Return cDesc

/*

Ŀ
Funao	 QA010VrCfg Autor Newton R. Ghiraldelli   Data  09/12/99 
Ĵ
Descriao Verifica a existencia de apelido no configurador            
Ĵ
Sintaxe	 QA010VrCfg()                                                
Ĵ
 Uso       QAXA010 - Siga Quality (Generico)                          
ٱ

*/
Function QA010VrCfg(lTudoOk)

Local lContinua:= .T.
Local nPosQAA  := QAA->(Recno())
Local nOrdQAA  := QAA->(IndexOrd())

DEFAULT lTudoOk := .F.

If ! lTudoOk .And. Empty(M->QAA_APELID)
	M->QAA_APELID := M->QAA_LOGIN
ElseIf lTudoOk .And. Empty(M->QAA_APELID)
	If MsgYesNo(STR0065,STR0007) //"Confirma o preenchimento do apelido utilizando o login ?"###"Atencao"
		M->QAA_APELID := M->QAA_LOGIN
	Else
		MsgAlert(STR0066,OemToAnsi(STR0007)) //"Ateno" //"O Apelido devera ser digitado ! Verifique !"
		Return .F.
	Endif
Endif
M->QAA_LOGIN := Upper(M->QAA_LOGIN)
If !Empty(M->QAA_LOGIN)
	PswUpper(.T.)
	PswOrder(2)
	If PswSeek(M->QAA_LOGIN)
		QAA->(DbSetOrder(6))
		IF INCLUI
			If QAA->(MSSeek(PADR(M->QAA_LOGIN,25)))
				MsgAlert(OemToAnsi(STR0050),OemToAnsi(STR0051)) //"J existe um usurio cadastrado com este apelido" ### "Ateno"
				lContinua := .F.
			Endif
		Else
			IF PADR(M->QAA_LOGIN,25)<>PADR(QAA->QAA_LOGIN,25)
				If QAA->(MSSeek(PADR(M->QAA_LOGIN,25)))
					If M->QAA_MAT <> QAA->QAA_MAT
						MsgAlert(OemToAnsi(STR0050),OemToAnsi(STR0051)) //"J existe um usurio cadastrado com este apelido" ### "Ateno"
						lContinua := .F.
					Endif
				Endif
			ENDIF
		ENDIF
		If lTudoOk .And. M->QAA_RECMAI = "1" .And. Empty(M->QAA_EMAIL)
			MsgAlert(OemToAnsi(STR0057),OemToAnsi(STR0051)) //"Preencha o email do usuario !!" ### "Ateno"
			lContinua := .F.
		Endif
	Else
		MsgAlert(OemToAnsi(STR0052),OemToAnsi(STR0051)) //"No foi encontrado a ocorrncia deste apelido no configurador!!!" ### "Ateno"
		lContinua := .F.
	Endif

	PswUpper(.F.)
Endif

QAA->(DbSetOrder(nOrdQAA))
QAA->(DbGoto(nPosQAA))

Return lContinua


/*

Ŀ
Funao	  QX10VldEmp  Autor  Eduardo de Souza     Data  10/07/02 
Ĵ
Descriao  Verifica codigo do Usuario na Integracao com SIGAGPE.      
Ĵ
Sintaxe    QX10VldEmp()                                               
Ĵ
 Uso       QAXA010 - Siga Quality (Generico)                          
ٱ

*/
Function QX10VldEmp(lIntGPE)

Default lIntGPE:= .F.

If Inclui .And. M->QAA_TPUSR <> "1" .And. lIntGPE // Inclusao, Tipo Outros e Integrado com SIGAGPE
	cEmpUsr:= SubStr(M->QAA_MAT,1,2)
	cFilUsr:= SubStr(M->QAA_MAT,3,FWSizeFilial())
	If !EMPTY(FWSM0Util():GetSM0Data( cEmpUsr , cFilUsr )) // https://tdn.totvs.com/x/NLNVGg
		Help(" ",1,"QX10CODNP") // "Codigo esta reservado para uso no Modulo SIGAGPE."
		Return .F.
	EndIf
EndIf

Return .T.

/*

Ŀ
Funao	  QX10VdEmpF  Autor  Eduardo de Souza     Data  26/08/02 
Ĵ
Descriao  Verifica codigo da Funcao na Integracao com SIGAGPE.       
Ĵ
Sintaxe    QX10VdEmpF()                                               
Ĵ
 Uso       QAXA010 - Siga Quality (Generico)                          
ٱ

*/
Function QX10VdEmpF(lIntGPE)

Default lIntGPE:= .F.

If Inclui .And. lIntGPE // Inclusao e Integrado com SIGAGPE
	cEmpUsr:= SubStr(M->QAC_FUNCAO,1,2)
	cFilUsr:= SubStr(M->QAC_FUNCAO,3,FWSizeFilial())
	If SM0->(DbSeek(cEmpUsr+cFilUsr))
		Help(" ",1,"QX10CODNP") // "Codigo esta reservado para uso no Modulo SIGAGPE."
		Return .F.
	EndIf
EndIf

Return .T.

/*

Ŀ
Funao	  QX10VdEmpD  Autor  Eduardo de Souza     Data  26/08/02 
Ĵ
Descriao  Verifica codigo do Departamento na Integracao com SIGAGPE. 
Ĵ
Sintaxe    QX10VdEmpD()                                               
Ĵ
 Uso       QAXA010 - Siga Quality (Generico)                          
ٱ

*/
Function QX10VdEmpD(lIntGPE)

Default lIntGPE:= If(GetMv("MV_QGINT",.F.,"N") == "S",.T.,.F.)

If Inclui .And. lIntGPE // Inclusao e Integrado com SIGAGPE
	cEmpUsr:= SubStr(M->QAD_CUSTO,1,2)
	cFilUsr:= SubStr(M->QAD_CUSTO,3,FWSizeFilial())
	If SM0->(DbSeek(cEmpUsr+cFilUsr))
		Help(" ",1,"QX10CODNP") // "Codigo esta reservado para uso no Modulo SIGAGPE."
		Return .F.
	EndIf
EndIf

Return .T.

/*

Ŀ
Funao	  QX10VDtFim  Autor  Eduardo de Souza     Data  03/08/02 
Ĵ
Descriao  Valida a Data Fim do cadastro de Usuarios.                 
Ĵ
Sintaxe    QX10VDtFim()                                               
Ĵ
 Uso       QAXA010 - Siga Quality (Generico)                          
ٱ

*/
Function QX10VDtFim()

If !Empty(M->QAA_FIM) .And. M->QAA_FIM < M->QAA_INICIO
	Help(" ",1,"QXDTFIM") // "A Data Final nao pode ser menor que a Data de Inicio."
	Return .F.
EndIf

Return .T.

/*

Ŀ
Funao	  QA_TRAVUSR  Autor  Eduardo de Souza     Data  04/09/02 
Ĵ
Descriao  Trava o acesso do usuario caso for inativo.                
Ĵ
Sintaxe    QA_TRAVUSR()                                               
Ĵ
 Uso       Siga Quality (Generico)                                    
ٱ

*/
Function QA_TRAVUSR()
Local cApelido	:= TRIM(UPPER(cUserName))
Local xRet			:= Nil

If Empty(cApelido)
	xRet := NIL
Else

	DbSelectArea("QAA")
	DbSetOrder(6)

	If QAA->(DbSeek(cApelido)) // Verifica se deve ser feita a validao para bloqueio de usurio
		If !QA_SitFolh()
			PswBlock(cApelido)
			MsgAlert(OemToAnsi(STR0053)+chr(13)+; //"Este usuario encontra-se inativo e nao pode ter acesso aos sistemas de qualidade."
			OemToAnsi(STR0054),; //"Seu login ser bloqueado para evitar problemas de inconsistencia na base de dados."
			OemToAnsi(STR0007))  //"Atencao"
			Final(STR0055) //"Usuario Bloqueado"
		Endif
	Else
		If cApelido <> OemToAnsi(STR0056) //"Administrador"
			xRet := .T.
		Endif
	EndIf
	QAA->(DbSetOrder(1))

EndIf

Return xRet


/*/

Ŀ
Funcao	  ConSX3    Autor  Robson Ramiro A. Oliv  Data  05/09/02 
Ĵ
Descricao  Retorna o nome da consulta padrao no SX3              	  
Ĵ
Sintaxe	 ConSX3(ExpC1)	   											  
Ĵ
Parametros ExpC1 = Campo do dicionario (SX3)						  
Ĵ
 Uso		  Generico 												  
ٱ

/*/

Function ConSX3(cCampo)
Local aAreaAtu 	:= GetArea()
Local cF3		:= ""

If !Empty(GetSx3Cache(cCampo,"X3_CAMPO"))
	cF3 := GetSx3Cache(cCampo,"X3_F3")
Endif

RestArea(aAreaAtu)
Return cF3

/*

Ŀ
Funo	  QA_CBox   Autor  Eduardo de Souza       Data  24/10/02 
Ĵ
Descrio  Retorna String com descricao do combo                      
Ĵ
Sintaxe	  QA_CBox(ExpC1,ExpC2)                              		  
Ĵ
Parametros ExpC1 = Campo a ter o Combo pesquisado                     
           ExpC2 = Conteudo do campo                                  
Ĵ
Uso		  Generico                               					  
ٱ

*/
Function QA_CBox(cCampo,cConteudo)

Local cBox:= Posicione("SX3", 2, cCampo, "x3CBox()")
Local nPos:= At(cConteudo + "=",cBox)
Local cSub:= SubStr(cBox, nPos + Len(cConteudo) + 1 )
Local nFim:= If(";" $ cSub, At(";", cSub) - 1, Len(cSub))
Local cRet:= If(nPos=0,"",SubStr(cSub, 1, nFim))

Return(cRet)

/*

Ŀ
Funo	 QA_SitFolh Autor  Wagner Mobile Costa    Data  21/03/03 
Ĵ
Descrio  Retorna se o funcionario esta ativo [RA_SITFOLH/RA_DEMISSA]
Ĵ
Sintaxe	  QA_SitFolh()                                      		  
Ĵ
Uso		  Generico                               					  
ٱ

*/
Function QA_SitFolh

Local lRet := .F.

If 	(	(Empty(QAA->QAA_FIM) .And. QAA->QAA_STATUS <> "2") .Or.;
		(! Empty(QAA->QAA_FIM) .And. QAA->QAA_FIM >= dDataBase)) .And.;
	(Empty(QAA->QAA_INICIO) .Or. dDataBase >= QAA->QAA_INICIO)
	lRet := .T.
Endif

Return lRet

/*

Ŀ
Funo	 QA_FilSitF Autor  Wagner Mobile Costa    Data  21/03/03 
Ĵ
Descrio  Retorna string para filtro do cadastro de funcionarios     
Ĵ
Sintaxe	  QA_FilSitF()                                      		  
Ĵ
Uso		  Generico                               					  
ٱ

*/
Function QA_FilSitF(lFormatSql, lAlias)

Local cFiltro := ""
Local cAlias  := If(lAlias <> Nil .And. lAlias, "QAA.", "")

DEFAULT lFormatSql 	:= .F.

If lFormatSql
	cFiltro	:= 	"(((" + 	cAlias + "QAA_FIM = ' ' AND " + ;
							cAlias + "QAA_STATUS <> '2') OR "+;
					 "(" + 	cAlias + "QAA_FIM <> ' ' AND " +;
					 		cAlias + "QAA_FIM >= '" + Dtos(dDataBase) + "')) AND " +;
				 "(QAA_INICIO = ' ' OR '" + Dtos(dDataBase) + "' >= " +;
							cAlias + "QAA_INICIO))"
Else
	If TCSrvType() # "AS/400"
		cFiltro := 	"(((Empty(QAA_FIM) .And. QAA_STATUS <> '2') .Or. " +;
				 	 "(! Empty(QAA_FIM) .And. QAA_FIM >= dDataBase)) .And. " +;
				 	 "(Empty(QAA_INICIO) .Or. Dtos(QAA_INICIO) <= '" + Dtos(dDataBase) + "'))"
	Else
		cFiltro := 	"((( QAA_FIM = CTOD(SPACE(8)) .And. QAA_STATUS <> '2') .Or. " +;
				 	 "( QAA_FIM <> CTOD(SPACE(8)) .And. QAA_FIM >= dDataBase)) .And. " +;
				 	 "( QAA_INICIO = CTOD(SPACE(8)) .Or. Dtos(QAA_INICIO) <= '" + Dtos(dDataBase) + "'))"
	Endif
Endif

Return cFiltro

/*

Ŀ
Funo	 Q_MemoArray Autor  Wagner Mobile Costa   Data  05/05/03 
Ĵ
Descrio  Retorna a partir de um memo passado um array baseado quebra
Ĵ
Sintaxe	  QA_FilSitF()                                      		  
Ĵ
Uso		  Generico                               					  
ٱ

*/

Function Q_MemoArray(mMemo, aTxtDet, nTamQuebra)

Local cLinha  := ""
Local nPula   := 0
Local nTamLin := 0

DEFAULT nTamQuebra := 80

While ! Empty(mMemo)
	nPula	:= 0
	nTamLin := nTamQuebra
	If At(Chr(13) + Chr(10), mMemo) > 0 .And. At(Chr(13) + Chr(10), mMemo) > nTamQuebra
		QbrPalavra(mMemo, @nTamLin, nTamQuebra)

	ElseIf At(Chr(13) + Chr(10), mMemo) > 0
		nTamLin := Min(nTamQuebra,At(Chr(13) + Chr(10), mMemo)-1 )
		nPula	:= 3
		
	ElseIf At(Chr(10), mMemo) > 0 .AND. At(Chr(10), mMemo) > nTamQuebra
		QbrPalavra(mMemo, @nTamLin, nTamQuebra)

	ElseIf At(Chr(10), mMemo) > 0
		nTamLin := Min(nTamQuebra, At(Chr(10), mMemo)-1 )
		nPula	:= 2

	Else
		QbrPalavra(mMemo, @nTamLin, nTamQuebra)

	Endif

	cLinha := Subs(mMemo, 1, nTamLin) + Space(nTamQuebra)
	cLinha := Left(cLinha, nTamQuebra)
	Aadd(aTxtDet, cLinha)
	If Empty(Subs(mMemo, nTamLin + nPula, 1))
		nTamLin++
	EndIf
	mMemo := Subs(mMemo, nTamLin + nPula, Len(mMemo))
EndDo

For nTamLin := Len(aTxtDet) To 1 Step -1	// Tiro espacos em branco no final
	If ! Empty(aTxtDet[nTamLin])
		Exit
	Endif
Next

aTxtDet := ASize(aTxtDet, nTamLin)

Return aTxtDet

/*/{Protheus.doc} QbrPalavra
Corrige a quebra de linha para no quebrar uma palavra no meio
@author Willian Ramalho
@since 02/07/2025
@param 01 - mMemo		, Caracter, conteudo da descrio detalhada
@param 02 - nTamLin 	, Numerico, tamanho da linha
@param 03 - nTamQuebra	, Numerico, tamanho da quebra de linha
@return 
/*/
Static Function QbrPalavra(mMemo, nTamLin, nTamQuebra)

	While .T.
		If Empty(Subs(mMemo,nTamLin,1))
			Exit
		EndIf

		//Caso de erro de digitacao de texto sem espacos...
		If nTamLin < 0
			nTamLin := nTamQuebra
			Exit
		EndIf

		nTamLin--
	EndDo

Return

/*/{Protheus.doc} QVRFANEXO
Inclui / Visualiza Documento Anexo
@author Cleber Souza
@since 04/11/2002
@version 1.0 - Cleber Souza - 04/11/2002
@version 2.0 - brunno.costa - 15/05/2023
@param 01 - nOpc      , numrico, opo no mBrowse
@param 02 - cFileTrm  , caracter, nome do arquivo para visualizar / incluir
@param 03 - cAlias    , caracter, alias do modulo que esta usando a rotina para identificacao de cQPathDocP default
@param 04 - cQPathDocP, caracter, diretrio armazenamento arquivo no rootpath
@param 05 - cArqAnexo , caracter, nome do arquivo nico baseado em UID
@param 06 - nMaximo   , numrico, tamanho mximo do arquivo em KB permitido para seguir
@return cFileTrm, caracter, caracter, nome do arquivo para visualizar / incluir
/*/
Function QVRFANEXO(nOpc, cFileTrm, cAlias, cQPathDocP, cArqAnexo, nMaximo)

Local cFile      := ""
Local cFileTmp   := ""
Local cQPathTrmP := Alltrim(QDOPATH()[3])
Local lMSUID     := cArqAnexo <> Nil
Local lTamValido := .T.
Local nPos       := 0
Local nTrm       := 0

Default cQPathDocP := Alltrim(GetMv("MV_"+cAlias+"DOC")) 
Default nMaximo    := 0

Private cQPathTrm := cQPathTrmP
Private cQPathDoc := cQPathDocP

cFileTrm := IIF(cFileTrm==Nil,"",Alltrim(cFileTrm))
If !Right( cQPathTrm,1 ) == "\"
	cQPathTrm := cQPathTrm + "\"
Endif

If !Right( cQPathDoc,1 ) == "\"
	cQPathDoc := cQPathDoc + "\"
Endif

IF Empty(cFileTrm)

	If nOpc == 2	// Visualizar - Opcao Cadastro
		MsgAlert(STR0058,STR0059) //"Nao existe nenhum documento anexo." ### "Atenao"
	Else

		If lMSUID
			cFile     := Trim(cGetFile(PADR(STR0060,27)+"|*.*|" ,STR0061,0,,.T.,49,,)) //"Todos Arquivos(*.*)" ### "Selecione Diretorio e Arquivo"
			If !Empty(cFile)
				nPos      := RAT(".",cFile)
				If nPos > 0
					cArqAnexo += "." + aTail(StrtoKarr(cFile,"."))
				EndIf
				cFileTrm  := cFile
			EndIf
		Else
			cFile     := Trim(cGetFile(PADR(STR0060,27)+"|*.*|" ,STR0061,0,,.T.,49,,)) //"Todos Arquivos(*.*)" ### "Selecione Diretorio e Arquivo"
			nPos      := RAT(".",cFile)
			cArqAnexo := "TMP"+StrZero(Val(QA_SEQU("TMP",12,"N","")),10) + Substr(cFile,nPos,(Len(Alltrim(cFile))+1)-nPos)
			cFileTrm  := cArqAnexo
		EndIf

		lTamValido := nMaximo == 0 .OR. QAFILESIZE(cFileTrm, "") <= nMaximo

		If !lTamValido
			cFileTrm  := ""
			cArqAnexo := ""
			//STR0098 - "Arquivo muito grande."
			//STR0099 - "Selecione um arquivo de at"
			Help(NIL, NIL, "QAXFUNTAM", NIL, STR0098, 1, 0, NIL, NIL, NIL, NIL, NIL, {STR0099 + " " + cValToChar( Round(nMaximo / 1000, 3) )+ "MB."})
		EndIf

		If !Empty(cFile) .AND. lTamValido

			If AT(":",cFile) > 0
				__CopyFile(cFile,cQPathTrm + cArqAnexo)
				If !File(cQPathTrm + cArqAnexo)
					Help(" ",1,"QAXNAOCOP")
					Return
				Endif
				__CopyFile(cFile,cQPathDoc + cArqAnexo)
				If !File(cQPathDoc + cArqAnexo)
					Help(" ",1,"QAXNAOCOP")
					Return
				Endif
  	  		Else
				If !__CopyFile(cFile,cQPathTrm + cArqAnexo)
					Help(" ",1,"QAXNAOCOP")
					Return
				Endif

				If !__CopyFile(cFile,cQPathTrm + cArqAnexo)
					Help(" ",1,"QAXNAOCOP")
					Return
				Endif

				cFileTmp := ""
				For nTrm:= Len(cFile) to 1 STEP -1
					If SubStr(cFile,nTrm,1) == "\"
						Exit
					Endif
					cFileTmp := SubStr(cFile,nTrm,1)+cFileTmp
				Next

				__CopyFile(cQPathTrm+cFileTmp,cQPathTrm + cArqAnexo)
				If File(cQPathTrm+cFileTmp)
					FErase(cQPathTrm+cFileTmp)
				Endif
	  		Endif

 			If File(cQPathTrm+cFileTrm).And. ;
				MsgYesNo(STR0062 ,STR0063) //"Deseja Visualizar o Documento Agora?" ### "Atenao"
				QA_OPENARQ(cQPathTrm+cFileTrm)//Programa para abrir arquivo com qualquer extensao. - QAXFUNA.PRX
			Endif 
		Endif
	Endif
	If !Empty(cFileTrm)
		cFileTrm  := StrTran(aTail(StrtoKarr(cFileTrm,"\")),"\","")
		cFileTrm  := StrTran(aTail(StrtoKarr(cFileTrm,"/")),"/","")
	EndIf
Else
	//Ŀ
	//Visualiza Documento Anexo. 			   
	//
	If !File(cQPathTrm+AllTrim(cFileTrm))
		If !CpyS2T(cQPathDOC+AllTrim(cFileTrm),cQPathTrm,.T.)
			If !File(cQPathTrm+AllTrim(cFileTrm))
				Help(" ",1,"QAXNAOCOP")
				Return
			Endif
		Endif
	EndIf

	If File(cQPathTrm+cFileTrm)
        QA_OPENARQ(cQPathTrm+cFileTrm)//Programa para abrir arquivo com qualquer extensao. - QAXFUNA.PRX
	Endif
Endif

Return (cFileTrm)

/*/{Protheus.doc} QAFILESIZE
Retorna tamanho do arquivo em KB

@author brunno.costa
@since 16/05/2023
@version P12
@param 01 - cArquivo, caracter, nome do arquivo para checagem
@param 02 - cPath   , caracter, diretrio do arquivo
@return nTamanho, nmero, tamanho do arquivo em KB
/*/
Function QAFILESIZE(cArquivo, cPath)

    Local oFile    := Nil
    Local nTamanho := 0

	Default cPath := Alltrim(QDOPATH()[3])

	cArquivo := cPath + cArquivo
  
    //Realiza a abertura do arquivo para pegar o tamanho em bytes
    oFile := FWFileReader():New(cArquivo)
    If oFile:Open()
        nTamanho := oFile:GetFileSize()
        oFile:Close()
    EndIf
	nTamanho := Round(nTamanho / 1024, 0)
	nTamanho := Iif(nTamanho == 0, 1, nTamanho)
	
Return nTamanho

/*

Ŀ
Funo	 QA_NewChave Autor  Cleber Souza          Data  15/09/03 
Ĵ
Descrio  Retorna chave de ligao do QA2.                           
Ĵ
Sintaxe	  QA_NewChave()                                      		  
Ĵ
Uso		  Generico                               					  
ٱ

*/

Function QA_NewChave(cAlias,nOrdem)
Local aAreaAlias := {}
Local aArea      := GetArea()
Local cChave     := ""
Local nSaveSX8   := GetSX8Len()

DEFAULT cAlias   := ""
DEFAULT nOrdem   := 0

While .T.
	cChave := GetSxeNum("QA2","QA2_CHAVE",,2)
	dbSelectArea("QA2")
	dbSetOrder(2)
	While dbSeek(xFilial("QA2")+cChave)

		While ( GetSX8Len() > nSaveSx8 )
			ConfirmSX8()
		EndDo

		cChave := GetSxeNum("QA2","QA2_CHAVE",,2)
		dbSelectArea("QA2")
		dbSetOrder(2)

	EndDo

	While ( GetSX8Len() > nSaveSx8 )
		ConfirmSX8()
	EndDo

	//Valida chave de origem.
	If !Empty(cAlias)
		dbSelectArea(cAlias)
		aAreaAlias := GetArea()
		dbSetOrder(nOrdem)
		If !dbSeek(xFilial(cAlias)+cChave)
			Exit
		EndIF
	Else
		Exit
	EndIF

EndDo

If !Empty(cAlias)
	RestArea(aAreaAlias)
EndIf

RestArea(aArea)

Return cChave

/*/

Ŀ
Funcao     QaxIdioma  Autor  Robson Ramiro A.Olive Data  05.09.03 
Ĵ
Descricao  Retorna a Descricao no idioma selecionado                  
Ĵ
Sintaxe    QaxIdioma((cCpoPor, cCpoEng, cCpoSpa)                      
Ĵ
Parametros ExpC1 = Nome do Campo com a descricao em Portugues         
           ExpC2 = Nome do Campo com a descricao em Ingles      	  
           ExpC3 = Nome do Campo com a descricao em Espanhol    	  
Ĵ
 Uso       Quality                                                    
ٱ


/*/

Function QaxIdioma(cCpoPor, cCpoEng, cCpoSpa)

Local cReturn

If Upper(__Language) == "SPANISH"
	cReturn := &cCpoSpa
Elseif Upper(__Language) == "ENGLISH"
	cReturn := &cCpoEng
Else
	cReturn := &cCpoPor
Endif

Return cReturn

/*


Ŀ
Funao	  JustificaTxt Autor  Paulo Emidio de Barros  Data 06/11/2003
Ĵ
Descriao  Justifica um texto, devolvendo o mesmo em (n) linhas 		  
Ĵ
Parametros EXPC1 = Texto 												  
			  EXPN2 = Tamanho de cada linha a ser formatada				  
			  EXPL3 = Se pula linha quando encontra ENTER no texto.		  
Ĵ
Retorno	  EXPA1 = Vetor com o Texto formatado por linhas				  
Ĵ
Uso		  Generico														  
ٱ


*/
Function JustificaTXT(cString,nTamanho,lQuebra,lRecTxt)
Local lContinua := .T.
Local aTexto    := {}
Local cTexto    := AllTrim(cString)+" "
Local nBranco   := " "
Local cLinha    := ""
Local nLinha    := 0
Local nLetra    := 0
Local xQuebra   := CHR(13)+CHR(10)
Local nQuebra   := 0

DEFAULT lQuebra := .F.
DEFAULT lRecTxt := .F.

While lContinua
	If lRecTxt .AND. At(xQuebra,cTexto) > 0// Tratamento especial para o RecText
		cLinha := ""
		nQuebra := At(xQuebra,cTexto)
		// Analiso as quebras e caso necessario as retiro
		While nQuebra > 0
			cLinha := SubStr(cTexto,1,nQuebra-1)
			Aadd(aTexto,cLinha)
			cTexto := Stuff(cTexto,1,nQuebra+1,"")
			nQuebra := At(xQuebra,cTexto)
		EndDo
		cLinha := ""
	EndIF

	If lQuebra
		While .T.
			nQuebra := At(xQuebra,cTexto)
			If nQuebra+Len(cLinha) < nTamanho .and. nQuebra > 0
				cLinha += SubStr(cTexto,1,nQuebra-1)
			    cTexto := Stuff(cTexto,1,nQuebra+1,"")
		    	Aadd(aTexto,cLinha)
		   		cLinha := ""
		   	Else
		   		Exit
			EndIf
		EndDo
	EndIf

	nBranco := At(" ",cTexto)
	If nBranco-1 <= nTamanho
		If (Len(cLinha)+nBranco -1) <= nTamanho  // Acrescentado anteriormente branco no cTexto no final e inserido '-1' para desconsiderar o tamanho
			If nBranco > 0
				cLinha += SubStr(cTexto,1,nBranco)
   			    cTexto := Stuff(cTexto,1,nBranco,"")
  			Else
  				If Len(cLinha) > 0
  					If Len(cLinha+cTexto) >= nTamanho
		   	       		Aadd(aTexto,cLinha)
				   		cLinha := ""
				   	EndIf

					cLinha += SubStr(cTexto,1,nTamanho)
				    cTexto := Stuff(cTexto,1,nTamanho,"")
   	    	   		Aadd(aTexto,cLinha)
		   			cLinha := ""
  				EndIf
			EndIf
   		Else
   			Aadd(aTexto,cLinha)
   			cLinha := ""
   		EndIf
   	Else
   	   	If nbranco >nTamanho .or. (len(cLinha)+nbranco)> nTamanho
   			Aadd(aTexto,cLinha)
   			cLinha := ""
   			cLinha += SubStr(cTexto,1,nTamanho)
   			Aadd(aTexto,cLinha)
			cLinha := ""
			cTexto := Stuff(cTexto,1,nTamanho,"")
		Else
   			cLinha += SubStr(cTexto,1,nTamanho)
   			//Descarrega a linha pendente, pois a string ultrapassa o tamanho maximo
		Endif
	Endif

	If Len(trim(cTexto)) == 0
		If Len(trim(cLinha)) > 0
			Aadd(aTexto,cLinha)
			cLinha := ""
			cTexto := Stuff(cTexto,1,nTamanho,"")
		EndIf
		lContinua := .F.
	EndIf
EndDo

For nLinha := 1 to Len(aTexto)-1
	aTexto[nLinha] := AllTrim(aTexto[nLinha])

	If Len(aTexto[nLinha]) < nTamanho
		If At(" ",aTexto[nLinha]) == 0
			aTexto[nLinha] += Space(nTamanho-Len(aTexto[nLinha]))
		Else
			nLetra := 0
			While Len(AllTrim(aTexto[nLinha])) < nTamanho
				nLetra++
				If SubStr(aTexto[nLinha],nLetra,1) == " "
				   aTexto[nLinha] := Stuff(aTexto[nLinha],nLetra,0," ")
				   nLetra++
				EndIf
	            If nLetra > nTamanho
	            	nLetra := 0
	            EndIf
			EndDo
		EndIf
	EndIf
Next nLinha

If Len(aTexto) == 0
    aTexto := {" "}
EndIf

Return(aTexto)

/*


Ŀ
Funo	 QNCMAILVCT  Autor  Rodrigo Gomes        Data   26.08.03 
Ĵ
Descrio Monta o corpo do email para Notificacao de Pendencias       
Ĵ
Sintaxe	 QNCMAILVCT()												  
Ĵ
           ExpN1 = Numerico definindo o  modulo que esta chamando     
           ExpA1 = Array contendo os dados do Corpo do E-mail         
           ExpN2 = Formato do E-mail (1=HTML / 2=Texto)               
           ExpC1 = Titulo do Cabecalho                                
           ExpC1 = Sub-Titulo do Corpo do E-mail                      
           ExpC1 = Descricao do Codigo                                
Ĵ
 Uso		  Generico                                                   
ٱ

*/

Function QNCMAILVCT(nMod,aMail,nTpMail,cTitCab,cSTitCor,cDesCod)
// Modulo 1 --> SIGAQNC
// Modulo 2 --> SIGAQDO
// Modulo 3 --> SIGAQAD

Local cMsg    := ""
Local cRoda   := ""
Local cMakCod := ""
Local cTpAud  := ""
Local i       := 0

If nMod == 1
	cRoda := STR0079 //"Mensagem gerada automaticamente pelo Sistema SIGAQNC - Controle de Nao-conformidades"
ElseIf nMod == 2
	cRoda := STR0080 //"Mensagem gerada automaticamente pelo Sistema SIGAQDO - Controle de Documentos"
ElseIf nMod == 3
	cRoda := STR0081 //"Mensagem gerada automaticamente pelo Sistema SIGAQAD - Controle de Auditoria"

	If aMail[1,4] == 1
		cTpAud  := STR0082 //"Auditoria"
	Else
		cTpAud  := STR0083 //"Agendamento"
	EndIf
EndIf

//Ŀ
//Verifica se vai usar o formato HTML ou texto
//
If nTpMail == 1

	//
	//Monta o Cabecalho de acordo com o modulo que esta chamando.
	//
	If nMod == 1
		cMsgCab := StrTran(PadR(cDesCod,19)," ",'&nbsp;') + '&nbsp;&nbsp;'
		cMsgCab += StrTran(PadR(STR0084,50)," ",'&nbsp;') + '&nbsp;&nbsp;'+OemToAnsi(STR0088)+'</font></P>' //"Vencimento"
	ElseIf nMod == 2
		cMsgCab := StrTran(PadR(cDesCod,20)," ",'&nbsp;') + '&nbsp;&nbsp;'
		cMsgCab += StrTran(PadR(STR0084,40)," ",'&nbsp;') + '&nbsp;&nbsp;'+OemToAnsi(STR0087)+'</font></P>' //"Dt.Geracao"
	ElseIf nMod == 3

		//Ŀ
		//Verifica se e Agendamento ou Auditoria
		//
		If aMail[1,4] == 1
			cMsgCab := StrTran(PadR(cDesCod,9)," ",'&nbsp;') + '&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'
			cMsgCab += StrTran(PadR(STR0067,11)," ",'&nbsp;') + '&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;' //"Data Inicio"
			cMsgCab += StrTran(PadR(STR0068,17)," ",'&nbsp;') + '&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Tipo</font></P>' //"Data Encer.Prev."
		Else
			cMsgCab := StrTran(PadR(cDesCod,9)," ",'&nbsp;') + '&nbsp;&nbsp;'
			cMsgCab += StrTran(PadR(STR0069,40)," ",'&nbsp;') + '&nbsp;&nbsp;' //"Motivo"
			cMsgCab += StrTran(PadR(STR0070,10)," ",'&nbsp;') + '&nbsp;&nbsp;Tipo</font></P>' //"Dt.Entrev."
		EndIf
	EndIf

	//Ŀ
	//Apos definicao do Cabecalho, monta o Corpo  do E-mail (HTML)
	//
	cMsg+='<html> <head> <title>SIGAQNC</title> </head>'
	cMsg+='<body>'
	cMsg+='<table border=1 width="657" height="29" cellspacing="1" bordercolorlight="#0099cc" bordercolordark="#0099cc" bordercolor="#0099cc" bgcolor="#0099cc" >'
	cMsg+='	<tr><td width="606" height="1" align="left" bordercolor="#0099cc" bordercolorlight="#0099cc" bordercolordark="#0099cc" bgcolor="#0099cc" >'
	cMsg+='		<p align="center"><font size="3" face="Courier New" color="#FFFFFF"><b> MENSAGEM </b></font></td>'	//
	cMsg+='	</tr>'
	cMsg+='	<tr><td height="26" bordercolor="#0099cc" bordercolorlight="#0099cc" bordercolordark="#0099cc" bgcolor="#FFFFFF" width="606">'
	cMsg+='		<p align="left">'+cTitCab+'</td>'
	cMsg+='	</tr>'
	cMsg+='</table>'
	cMsg+='<BR>'
	cMsg+='<TABLE borderColor=#000080 width=658 border=1>'
	cMsg+='<TBODY>'
	cMsg+='<TR>'
	cMsg+='<TD width=648>'
	cMsg+='<p align="center"><font color="#0000FF"><b>' + cSTitCor + '</b></font></TD></TR>'
	cMsg+='<TR>'
	cMsg+='<TD width=648>'
	cMsg+='<P style="MARGIN: 0px"><font face="Courier New" size="2"> <b>'
	cMsg+= cMsgCab + '<P style="MARGIN: 0px">&nbsp;</P> </b>'

	//Ŀ
	//Varre o array que foi passado para esta funcao e imprime
	//os dados de acordo com o modulo que esta chamando       |
	//
	For i:=1 To Len(aMail)
		cMsg+='<P style="MARGIN: 0px"><font face="Courier New" size="2">'

		//Ŀ
		//Verifica a particularidade de cada modulo, para impressao correta.
		//
		If nMod == 1
			cMakCod := StrTran( TransForm(aMail[i,1],"@R ###########/####"), " ", '&nbsp;') + "-" + aMail[i,2]
		ElseIf nMod == 2
			cMakCod := StrTran( PadR( AllTrim(aMail[i,1])+ "-"+ aMail[i,2],20), " ", '&nbsp;')
		ElseIf nMod == 3
			If aMail[i,4] == 1
				cMakCod := StrTran( PadR( AllTrim(aMail[i,1]),9), " ", '&nbsp;')+ '&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'
				cMakCod += StrTran(PadR(DToC(aMail[i,2]),11)," ",'&nbsp;') + '&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'
				cMakCod += StrTran(PadR(DToC(aMail[i,3]),17)," ",'&nbsp;') + '&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'
				cMakCod += cTpAud
			Else
				cMakCod := StrTran(PadR( AllTrim(aMail[i,1]),9), " ", '&nbsp;')+ '&nbsp;&nbsp;'
				cMakCod += StrTran(PadR(aMail[i,2],40)," ",'&nbsp;') + '&nbsp;&nbsp;'
				cMakCod += StrTran(PadR(DToC(aMail[i,3]),10)," ",'&nbsp;') + '&nbsp;&nbsp;'
				cMakCod += cTpAud
			EndIf
		EndIf

		cMsg+= cMakCod + '&nbsp;&nbsp;'

		If nMod != 3
			cMsg+= StrTran(PadR(aMail[i,3],IIf(nMod == 1,50,40))," ",'&nbsp;') + '&nbsp;&nbsp;' + DToC(aMail[i,4]) + '</font></P>'
		EndIf
	Next i

	//Ŀ
	//Termina de contar o corpo do E-mail.
	//
	cMsg+='</TD></TR></TBODY></TABLE>'
	cMsg+='<BR>'
	cMsg+='<p><FONT size=2><EM>'+cRoda+'</EM></FONT></p>'
	cMsg+='</body></html>'
Else
	cMsg := cTitCab+CHR(13)+CHR(10)+CHR(13)+CHR(10)
	cMsg += cSTitCor+CHR(13)+CHR(10)+CHR(13)+CHR(10)

	//Ŀ
	//Varre o array que foi passado para esta funcao e imprime
	//os dados de acordo com o modulo que esta chamando       |
	//
	For i:=1 To Len(aMail)
		cMsg+= cDesCod + ": "

		//Ŀ
		//Verifica a particularidade de cada modulo, para impressao correta.
		//
		If nMod == 1
			cMakCod := TransForm(aMail[i,1],"@R ######/####") + "-" + aMail[i,2]
		ElseIf nMod == 2
			cMakCod := PadR( AllTrim(aMail[i,1]) + "-" + aMail[i,2],20)
		ElseIf nMod == 3
			cMsg+= AllTrim(aMail[i,1]) + CHR(13)+CHR(10)

			//Ŀ
			//Verifica se e Agendamento ou Auditoria
			//
			If aMail[1,4] == 1
				cMsg+= STR0071 //"Data Inicio: "
				cMsg+= DToC(aMail[i,2]) + CHR(13)+CHR(10)
				cMsg+= STR0072 //"Data Encer.Prev.: "
				cMsg+= DToC(aMail[i,3]) + CHR(13)+CHR(10)
				cMsg+= STR0073 //"Tipo: "
				cMsg+= cTpAud + CHR(13)+CHR(10) + CHR(13)+CHR(10)
			Else
				cMsg+= STR0074 //"Motivo: "
				cMsg+= PadR(aMail[i,2],40) + CHR(13)+CHR(10)
				cMsg+= STR0075 //"Dt.Entrev.: "
				cMsg+= DToC(aMail[i,3]) + CHR(13)+CHR(10)
				cMsg+= STR0073 //"Tipo: "
				cMsg+= cTpAud + CHR(13)+CHR(10) + CHR(13)+CHR(10)
			EndIf
		EndIf

		If nMod != 3
			cMsg+= cMakCod + CHR(13)+CHR(10)
			cMsg+= STR0076 //"Descricao: "
			cMsg+= PadR(aMail[i,3],IIf(nMod == 1,50,40)) + CHR(13)+CHR(10)
			cMsg+= IIf(nMod == 2,STR0077,STR0078) //"Dt.Geracao: "###"Vencimento: "
			cMsg+= DToC(aMail[i,4]) + CHR(13)+CHR(10) + CHR(13)+CHR(10)
		EndIf

	Next i
	cMsg += CHR(13)+CHR(10)
	cMsg += cRoda + CRLF
EndIf

Return (cMsg)

/*/

Ŀ
Funcao	  QaCheckFK Autor  Robson Ramiro A. Oliv  Data  12/03/04 
Ĵ
Descricao  Checa se existe integridade no banco						  
Ĵ
Sintaxe	  QaCheckFK 	   											  
Ĵ
Parametros Void                                   			  		  
Ĵ
 Uso		  Generico 												  
ٱ

/*/

Function QaCheckFK

Local lRetorno

lRetorno := .F.

If __lFKInUse
	Alert(OemToAnsi(STR0086)) //"Esta opcao nao esta disponivel para Bases com Integridade Relacional !"
	lRetorno := .T.
Endif

Return lRetorno

/*


ͻ
Programa  QA_CalHorAutor  Cleber Souza          Data   12/12/03   
͹
Desc.      Programa de conversao de horas para minutos.	              
Ĵ
Parametros EXPN1 = Numero de Dias.						  		      
           EXPN2 = Hora informados para conversao.		  		      
           EXPN3 = Hora informados para conversao.		  		      
Ĵ
Retorno    EXPC1 = Resultado da Hora somada.						  
͹
Uso        Geral	                                                  
ͼ


*/
Function QA_CalHor(nDia,nHr,nHrLab)

Local nRest:=0,nLabor:=0,nVar:=0,nInt,nDec

nRest := (Val(Subs(nHr,1,2)) * 60) + Val(Subs(nHr,4,2))
nLabor:= (Val(Subs(nHrLab,1,2)) * 60) + Val(Subs(nHrLab,4,2))

If nDia == 0	 								// Se for no Mesmo dia
	nVar := nRest - nLabor
Else
	nVar := ((nDia - 1) * 24 * 60 ) + ((24 * 60) - nLabor) + nRest
EndIf

nInt := Int(nVar / 60)
nDec := Mod(nVar , 60)

Return(Str(nInt,6)+":"+StrZero(nDec,2))

/*


Ŀ
Funao	 QA_CalLiPol Autor  Cleber Souza			 Data  04/12/03 
Ĵ
Descriao  Efetua o calculo de polegada para valor decimal.           
Ĵ
ParametrosEXPC1	- Limite fornecido para calculo						  
Ĵ
Retorno	 EXPN1	- Resultado do Calculo								  
Ĵ
 Uso		  Geral	               								      
ٱ


*/
Function QA_CalLiPol(cLimite)
Local nLim	 := 0
Local nPosInt
Local nPosFrc

//Novo calculo
cLimite := AllTrim(cLimite)
cLimite := Lower(cLimite)
nPosInt := At("i",cLimite)
nPosFrc := At("/",cLimite)
//Caso seja valor inteiro sem a parte fracionada.
If nPosInt <> 0 .And. nPosFrc == 0
	nLim := Val(StrTran(AllTrim(cLimite),"i",""))
Else //Caso contrario efetua o calculo
	nPosInt := If(nPosInt>nPosFrc,0,nPosInt)
	nVlrInt := Val(SubStr(cLimite,1,nPosInt-1))
	nVlrNum := Val(SubStr(cLimite,nPosInt+1,nPosFrc-(nPosInt+1)))
	nVlrDen := Val(SubStr(cLimite,nPosFrc+1,Len(cLimite)-nPosFrc))
	If nVlrDen > 0
		nLim := nVlrInt + (nVlrNum/nVlrDen)
	Else
		nLim := nVlrInt
	EndIf
EndIf
Return(nLim)

/*/


Ŀ
Funo	 QA_CalPol	  Autor Cleber Souza           Data  02/12/03 
Ĵ
Descrio  Valida os Campos AFI,AFS,LIC e LSC, quando  os mesmos forem
           informados em polegadas.                                   
Ĵ
Parametros EXPC1 - Campo que sera feita a validacao					  
           EXPL1 - Define se valor esta em polegada					  
Ĵ
Retorno	  EXPL1 - Resultado da Validacao							  
Ĵ
 Uso		  Geral     		   										  
ٱ


/*/
Function QA_CalPol(cCampo,lVlrPol)
Local cVar     := ""
Local nPosNml  := 0
Local nPosAsp  := 0
Local nPosBar  := 0
Local lRetorno := .T.
Local nOcoAsp  := 0
Local nOcoBar  := 0
Local nOcoDes  := 0
Local nIntPol  := 0
Local nDecPol  := 0
Local nX       := 0

Default lVlrPol := .T.

cVar    := If(ValType(cCampo)=="N",Lower(AllTrim(Str(cCampo))),Lower(AllTrim(cCampo)))
nPosNml := At('i',cVar)

If !lVlrPol
	lRetorno := .T.
Else
	If nPosNml+1 < Len(AllTrim(cVar)) .And. !IsDigit(Substr(cVar,nPosNml+1,1))
		Help(" ",1,"QAPOLINV")  //Valor em polegada est incorreto.
		lRetorno := .F.
	Else
		If !( At('"',cVar) > 0 .Or. At("'",cVar) > 0 )
			If !Empty(cVar)
				For nX := 1 to Len(cVar)
					If     SubStr(cVar,nX,1) == 'i'
						nOcoAsp++
					ElseIf SubStr(cVar,nX,1) == '/'
						nOcoBar++
					ElseIf !IsDigit(SubStr(cVar,nX,1))
						nOcoDes++
					EndIf
				Next
				If nOcoAsp > 1 .Or. nOcoAsp == 0 .Or. nOcoBar > 1 .Or.;
					nOcoDes > 0 .Or. At(" ",cVar) > 0
					lRetorno := .F.
				Else
					nPosAsp := At('i',cVar)
					nPosBar := At('/',cVar)
					If nPosBar > 0
						If nPosBar > nPosAsp
							nIntPol := Val(SubStr(cVar,nPosAsp+1,nPosBar-(nPosAsp-1)))
							nDecPol := Val(SubStr(cVar,nPosBar+1,Len(cVar)-nPosbar))
						Else
							nIntPol := Val(SubStr(cVar,1,nPosBar-1))
							nDecPol := Val(SubStr(cVar,nPosBar+1,nPosAsp-(nPosBar-1)))
						EndIf
						If nDecPol == 0
							lRetorno := .F.
						Else
							If lVlrPol
								nResto := 128%nDecPol
								If nResto > 0
									lRetorno := .F.
								EndIf
							EndIf
						EndIf
					EndIf
				EndIf
			EndIf
		Else
			lRetorno := .F.
		EndIf
	EndIf
EndIf

Return(lRetorno)

/*/


Ŀ
Funao	  QA_RetFilEmp Autor  Paulo Emidio de Barros  Data 05/08/2004
Ĵ
Descriao  Retorna um vetor com todas as filiais da empresa selecionada.  
Ĵ
Parametros EXPA1[x,1] = Codigo da Empresa							   	  
			  		[x,2] = Codigo da Filial							   	  
			  		[x,3] = Nome da Empresa								   	  
			  		[x,4] = Nome da Filial								   	  
Ĵ
Retorno	  EXPA1 													 	  
Ĵ
Uso		  Generico														  
ٱ


/*/
Function QA_RetFilEmp(cEmpresa)
Local aAreaAnt := GetArea()
Local aAreaSM0 := SM0->(GetArea())
Local aRetorno := {}

//Ŀ
// Preenche o vetor aRetorno com as Filiais associadas a Empresa  
// selecionada.												   
//
SM0->(dbSetOrder(1))
SM0->(dbSeek(cEmpresa))
While SM0->(!Eof()) .And. SM0->M0_CODIGO==cEmpresa
    Aadd(aRetorno,{SM0->M0_CODIGO,FWCodFil(cEmpresa),SM0->M0_NOME,SM0->M0_FILIAL}) //FWGETCODFILIAL
	SM0->(dbSkip())
EndDo

RestArea(aAreaSM0)
RestArea(aAreaAnt)
Return(aRetorno)

/*


ͻ
Programa  QAXFUN    Autor  Cicero Cruz          Data   20/10/05   
͹
Desc.      Valida se e diretorio local                                
                                                                      
͹
Uso        Ambientes Qualidade                                        
ͼ


*/
Function QA_VerQDir(cDir)
Local lRet := .T.
	If substr(cDir,1,1) $ '\'
		MsgAlert(STR0095)   // "MV_QDIRGRA - Verifique a configuracao! Este parametro deve se referir a um Diretorio Local!"
		lRet := .F.
	EndIf
Return lRet

/*


ͻ
Programa  QA_CarEsp Autor  Telso Carneiro       Data   01/11/05   
͹
Desc.      Verifica o caracter invalido da String                     
                                                                      
͹
Uso        Generico                                                   
ͼ


*/
Function QA_CarEsp(cVar)
Local lRet		:=.T.
Local aNaoValido:={"<",">","%",",","(",")","/","\","$","==","=","#","+","!","|","'",'"'}  //Array caracteres nao validos para composicao do texto
Local nY        :=0
Local cCarMsg	:=""

AEval(aNaoValido,{|x| cCarMsg+=" "+x})

For nY:=1 to Len(aNaoValido)
	If aNaovalido[nY] $  cVar
		MsgAlert( OemToAnsi(STR0096)+cCarMsg, OemToAnsi(STR0007) )  //"Existe caracter invalido nesta composio"###"Ateno"
		lRet	:= .F.
		Exit
	Endif
Next

Return(lRet)


/*


Ŀ
Funcao     QA_AmbDet   Autor  Cicero Cruz            Data  23/01/06 
Ĵ
Descricao  Retorna a caracteristica requerida  do modulo                
Ĵ
Sintaxe    QA_AmbDet                                                    
Ĵ
Opcao      Parametro      Retorno                                      
(nOpc)     Requisitado                                                 
   1       nAmb           Sigla Ambiente                               
   2       nAmb           Nome Ambiente                                
   3       cSigla         Numero Ambiente                              
   4       cSigla         Nome Ambiente                                
Ĵ
 Uso		  SIGATMK - (Integracao)                 					    
ٱ


*/
// Numero, Sigla, Nome Ambiente
Function QA_AmbDet(nAmb, cSigla, nOpc )
Local aRetMod	:= RetModName()
Local cRet
Local nX

Do Case
Case ( nOpc == 1 )
	nX:=Ascan(aRetMod,{|x| x[1]==nAmb})
	if nX > 0
		cRet := aRetMod[nX][2]
	EndIf
Case ( nOpc == 2 )
	nX:=Ascan(aRetMod,{|x| x[1]==nAmb})
	if nX > 0
		cRet := aRetMod[nX][3]
	EndIf
Case ( nOpc == 3 )
	nX:=Ascan(aRetMod,{|x| x[2]==alltrim(cSigla)})
	if nX > 0
		cRet := aRetMod[nX][1]
	EndIf
Case ( nOpc == 4 )
	nX:=Ascan(aRetMod,{|x| x[2]==alltrim(cSigla)})
	if nX > 0
		cRet := aRetMod[nX][3]
	EndIf
OtherWise
	Return ""
EndCase
Return cRet


/*


ͻ
Programa  QAD015Led Autor  Leandro Sabino       Data  16/11/2006  
͹
Desc.     Montagem do Led do MBrowse da rotina de Transferenica dos   
          lancamentos Pendentes da Auditoria por Usuario - QADA015    
͹
Uso       QAD015Led()                                                 
ͼ


*/
Function QAD015Led()

	Local aBuscaPed  := {}
	Local aRecTrf    := {}
	Local cFilAtu    := ""
	Local cMatAtu    := ""
	Local cTxtEvi    := ""
	Local lPendLider := .F.
	Local lPendNorm  := .F.
	Local lUsrAtivo  := .F.
	Local lVerEvid   := SuperGetMv("MV_QADEVI",.T.,.F.)
	Local nIs        := 0
	Local nRetorno   := Nil

	//Ŀ
	//Validando se o usuario esta ativo ou nao.
	//
	If 	(	(Empty(QAA->QAA_FIM) .And. QAA->QAA_STATUS <> "2") .Or.;
			(! Empty(QAA->QAA_FIM) .And. QAA->QAA_FIM >= dDataBase)) .And.;
		(Empty(QAA->QAA_INICIO) .Or. dDataBase >= QAA->QAA_INICIO)
		lUsrAtivo := .T.
	Endif


	//Ŀ
	// Carrega os Lactos de Transferencia e QAB                     
	//
	cFilAtu	 := QAA->QAA_FILIAL
	cMatAtu  :=	QAA->QAA_MAT
	aAdd(aBuscaPed,{cFilAtu,cMatAtu})

	QAB->(DbSetOrder(2))

	//Ŀ
	// Carrega os Lactos de Transferencia e Matricula atual         
	//
	If QAB->(DbSeek(cFilAtu+cMatAtu))
		While QAB->(!Eof()) .And. QAB->QAB_FILP + QAB->QAB_MATP == cFilAtu + cMatAtu
			If Ascan(aRecTrf,QAB->(Recno())) > 0
				QAB->(DbSkip())
				Loop
			Else
				Aadd(aRecTrf,QAB->(Recno()))
			Endif
			If QAB->QAB_FILP+QAB->QAB_MATP == cFilAtu+cMatAtu
				If QAB->QAB_FILP+QAB->QAB_MATP <> QAB->QAB_FILD+QAB->QAB_MATD
					If Ascan(aBuscaPed,{|X| X[1]+X[2] == QAB->QAB_FILD+QAB->QAB_MATD}) == 0
						Aadd(aBuscaPed,{QAB->QAB_FILD,QAB->QAB_MATD})
					Endif
				EndIf
				cFilAtu := QAB->QAB_FILD
				cMatAtu := QAB->QAB_MATD
				QAB->(DbSeek(cFilAtu+cMatAtu))
			Else
				QAB->(DbSkip())
			EndIf
		EndDo
	EndIf

	cFilAtu	 := QAA->QAA_FILIAL
	cMatAtu  :=	QAA->QAA_MAT

	For nIs := 1 TO Len(aBuscaPed)

		//Ŀ
		//Pendencias de Auditor Lider
		//
		QUB->(DbSetOrder(2))
		QUB->(dbSetFilter({|| Empty(QUB->QUB_ENCREA) },'Empty(QUB->QUB_ENCREA)'))
		QUB->(dbGotop())
		While QUB->(!Eof())

			//Ŀ
			//Pendencias de Auditor 
			//
			IF QUH->(DbSeek(QUB->QUB_FILIAL+QUB->QUB_NUMAUD))
				While QUH->(!Eof()) .And. QUH->QUH_FILIAL == QUB->QUB_FILIAL .AND. QUH->QUH_NUMAUD == QUB->QUB_NUMAUD .AND. !lPendNorm

					IF QUH->QUH_FILMAT == aBuscaPed[nIs,1] .AND. QUH->QUH_CODAUD == aBuscaPed[nIs,2]
						If QUD->(DbSeek(QUH->QUH_FILIAL+QUH->QUH_NUMAUD+QUH->QUH_SEQ))
							While QUD->(!Eof()) .And. QUD->QUD_FILIAL+QUD->QUD_NUMAUD+QUD->QUD_SEQ == QUH->QUH_FILIAL+QUH->QUH_NUMAUD+QUH->QUH_SEQ .AND. !lPendNorm
								//Ŀ
								//Verifica se questao Nao esta respondida.          
								//
								If !Empty(QUD->QUD_DTAVAL)
									If lVerEvid
										cTxtEvi := MsMM(QUD->QUD_EVICHV,GetSX3Cache("QUD_EVIDE1","X3_TAMANHO"))
										//Ŀ
										//Verifica se o texto da Evidencia esta preenchido. 
										//
										If Empty(cTxtEvi)
											lPendNorm := .T.
										EndIf
									EndIf
								Else
									lPendNorm := .T.
								Endif

								QUD->(DbSkip())
							EndDo
						EndIf
					Endif
					QUH->(DbSkip())
				EndDo
			Endif

			QUB->(DbSkip())
		EndDo

		//Ŀ
		//Pendencias Agenda de Auditor Lider
		//
		If !lPendNorm .AND. aBuscaPed[nIs,1]+aBuscaPed[nIs,2] == cFilAtu+cMatAtu //Usuario Transf. QAB
			QUA->(dbSetFilter({||QUA->QUA_FILMAT == aBuscaPed[nIs,1] .And. QUA->QUA_MAT == aBuscaPed[nIs,2]},'QUA->QUA_FILMAT == "'+aBuscaPed[nIs,1]+'" .And. QUA->QUA_MAT    == "'+aBuscaPed[nIs,2]+'"'))
			QUA->(dbGotop())
			While QUA->(!Eof())
				If QUA->QUA_STATUS=="1"
					lPendLider := .T.
				EndIf
				QUA->(DbSkip())
			EndDo

			//Ŀ
			//Pendencias Agenda de Auditor 
			//
			IF lExtQUM

				QUM->(dbSetFilter({|| QUM->QUM_FILMAT == aBuscaPed[nIs,1] .And. QUM->QUM_CODAUD == aBuscaPed[nIs,2]},'QUM->QUM_FILMAT == "'+aBuscaPed[nIs,1]+'" .And. QUM->QUM_CODAUD == "'+aBuscaPed[nIs,2]+'"'))
				QUM->(DbGotop())
				While QUM->(!Eof())

					IF Posicione("QUA",3,QUM->QUM_FILIAL+QUM->QUM_NUMAUD,"QUA_STATUS")=="1"
						lPendLider := .T.
					Endif

					QUM->(DbSkip())
				EndDo

			Endif
		EndIf
		
		If      lUsrAtivo .And. !lPendNorm .And. !lPendLider //usuario ativo s/lanamento pendente
			nRetorno =  1
		ElseIf !lUsrAtivo .And. !lPendNorm                   //usuario inativo s/lancamento pendente
			nRetorno =  2
		ElseIf  lUsrAtivo .And. (lPendNorm .Or. lPendLider)  //usuario ativo c/lancamento pendente
			nRetorno =  3
		ElseIf !lUsrAtivo .And. (lPendNorm .Or. lPendLider)  //usuario inativo c/ lancamento pendente
			nRetorno =  4
		Endif

	Next

Return(nRetorno)


/*


Ŀ
Funo    QA_SXESXF  Autor  Aldo Marini Junior     Data 23/11/2006
Ĵ
Descrio  Funcao generica para geracao de chave e verificacao da     
			  existencia quando ja houver a sequencia gerada			  
Ĵ
Parametros ExpC1 = Caracter contendo o alias                          
			  ExpC2 = Caracter contendo o campo referencia      		  
			  ExpC3 = Caracter contendo o alias do SX8     			  
			  ExpC4 = Caracter contendo a ordem do alias    			  
Ĵ
Retorno   cChave - Chave com o numero sequencial gerado               
Ĵ
Uso       Generico - Modulos Qualidade                                
ٱ


*/
Function QA_SXESXF(cAlias,cCampo,cAliasSX8,cOrdem)
Local aArea    := (cAlias)->(GetArea())
Local nSaveSx8 := GetSx8Len()
Local cChave   := ""

//Ŀ
// Gera a chave de ligacao									 
//
dbSelectArea(cAlias)
dbSetOrder(cOrdem)
cChave := GetSxeNum(cAlias,cCampo,cAliasSX8,cOrdem)
While dbSeek(xFilial(cAlias)+cChave)
  	While ( GetSx8Len() > nSaveSX8 )
     	ConfirmSX8()
    EndDo
    cChave := GetSxeNum(cAlias,cCampo,cAliasSX8,cOrdem)
EndDo
RestArea(aArea)

Return(cChave)

/*


ͻ
Programa  RetSIX    Autor  Cicero Cruz          Data  16/01/2007  
͹
Desc.      Retorna o Indice utilizado na  tabela                      
͹
Uso       RetSIX()                                                    
ͼ


*/
Function RetSIX(cAlias, cIndice, lRet, aCampos)

	Local aIndices := {}
	Local cAux     := ""
	Local cRetI    := Iif(lRet,cAlias+"->(","")

	//Ŀ
	// Carrega os Indices do Sindex 
	//
	If FWSIXUtil():ExistIndex(cAlias, cIndice)
		aIndices := FWSIXUtil():GetAliasIndexes( cAlias  )
		aEval(aIndices[Val(cIndice)], {|cCampo| cAux += Iif(Empty(cAux), cCampo, "+"+cCampo) } )
		While At("+",cAux) >= 1
			If Len(cRetI) == 0 .AND. aScan(aCampos,AllTrim(Substr(cAux,1,At("+",cAux)-1)))==0
				cRetI += Substr(cAux,1,At("+",cAux)-1)
			ElseIf aScan(aCampos,AllTrim(Substr(cAux,1,At("+",cAux)-1)))==0
				If cRetI == cAlias+"->(" .OR. cRetI == ""
					cRetI += Substr(cAux,1,At("+",cAux)-1)
				Else
					cRetI += "+"+Substr(cAux,1,At("+",cAux)-1)
				Endif
			EndIf
			cAux := Substr(cAux,At("+",cAux)+1,Len(cAux))
		EndDo
		if Len(cRetI) == 0  .AND. aScan(aCampos,AllTrim(Substr(cAux,1,Len(cAux))))==0
			cRetI += Substr(cAux,1,Len(cAux))
		ElseIf aScan(aCampos,AllTrim(Substr(cAux,1,Len(cAux))))==0
			cRetI += "+"+Substr(cAux,1,Len(cAux))
		EndIf
	EndIf

	cRetI += Iif(lRet,")","")
Return cRetI

/*


Ŀ
Funo    QAXUser    Autor   Cicero Cruz           Data  26/12/06 
Ĵ
Descrio  Retorna dados do Usuario com base no ID User...            
Ĵ
Sintaxe    ExpC2 := QAXUser(ExpC1,ExpN1) 	   	                      
Ĵ
Parametros| ExpC1 := __cUserID (Codigo de ID do Usuario).              |
          | ExpN1 := Numero do dado a retornar.                        |
          | 	  Onde: 1 - Devolve o proprio ID User.                    |
          |          2 - Devolve o Login Ex. Administrador.            |
          |          3 - Devolve o PSW.                                |
          |          4 - Devolve o Nome do Usuario.                    |
          |          5 - Devolve a Metricula do QAA                    |
Ĵ
 Uso       Quality                                                    
ٱ


*/
Function QAXUser(cIdUser,nRet)
Local cUser := {}

//Ŀ
// nRet == 1 -> Retorna ID User                                 
// nRet == 2 -> Retorna Login                                   
// nRet == 3 -> Retorna PSW                                     
// nRet == 4 -> Retorna Nome                                    
// nRet == 5 -> Retorna Matricula                               
//
Default nRet := 1

If nRet == 5
	QAA->(DbSetOrder(6))
	If QAA->(DbSeek(UPPER(PswChave(RetCodUsr()))))
		cUser := QAA->QAA_MAT
    EndIf
Else
	PswOrder(1)
	If PswSeek(cIdUser)
		cUser := PswRet(1)[1][nRet]
	EndIf
EndIf

Return( cUser )

/*


Ŀ
Funo    QA_Range   Autor   Cicero Cruz           Data  05/03/07 
Ĵ
Descrio  Trata o parametro Range                                    
Ĵ
 Uso       Quality                                                    
ٱ


*/
Function QA_Range(cCont, cCampo, cExt, lTop)
Local nTexto1 := 0
Local nTexto2 := 0
Local cTexto  := ""
Local cAux    := ""
Local nPos    := 0
Local lAchou  := .F.
Local lOr     := .F.
Local nTamanho  := GetSx3Cache(cCampo,"X3_TAMANHO")

nTexto1 := At("-",cCont)
nTexto2 := At(";",cCont)
If nTexto1 > 0 .AND. nTexto2 > 0
	While !Empty(cCont)
		If Subs(cCont,1,1) == "-" .AND. Len(cAux) > 0
  			If lAchou
				lAchou := .F.
				If lOr
					cTexto += " OR "
				EndIf
				cTexto += QA_MExprRange(cAux, cCampo, cExt, lTop)
				lOr := Iif(lOr,.F.,.T.)
				cAux := ""
				cCont := Subs(cCont,2,Len(cCont)-2)
			Else
			    If Len(cTexto) > 0
				    lOr := .T.
			    EndIf
			    cAux += Subs(cCont,1,1)
				cCont := Subs(cCont,2,Len(cCont)-1)
				lAchou := .T.
			EndIf
		ElseIf Subs(cCont,1,1) == ";" .AND. Len(cAux) > 0
  			If At("-",cAux) > 0
  				lAchou := .F.
				If lOr
					cTexto += " OR "
				EndIf
				cTexto += QA_MExprRange(cAux, cCampo, cExt, lTop)
				lOr := Iif(lOr,.F.,.T.)
				cAux := ""
				cCont := Subs(cCont,2,Len(cCont)-2)
  			ElseIf lAchou .AND. At(";",Subs(cCont,2,Len(cCont)-1)) > 0 .AND. (At("-",Subs(cCont,2,Len(cCont)-1)) < At(";",Subs(cCont,2,Len(cCont)-1)))
		        lAchou := .F.
				If lOr
					cTexto += " OR "
				EndIf
				cTexto += QA_MExprRange(cAux, cCampo, cExt, lTop)
				lOr := Iif(lOr,.F.,.T.)
				cAux := ""
				cCont := Subs(cCont,2,Len(cCont)-2)
			ElseIf nPos == 1  .AND.  At(";",Subs(cCont,2,Len(cCont)-1)) == 0
			    If lOr
					cTexto += " OR "
				EndIf
				If (At(";",cAux) == 0 .OR. At(";",cAux) == Len(cAux) ) .AND. At("-",cCont) > 0
					If Subs(cAux,Len(cAux),1) == ";"
						cTexto += cExt+"."+cCampo+" = '"+PadL(Subs(cAux,1,Len(cAux)-1),nTamanho)+"'"
					Else
						cTexto += cExt+"."+cCampo+" = '"+PadL(cAux,nTamanho)+"'"
					EndIf
					lOr := Iif(lOr,.F.,.T.)
					cAux := ""
					cCont := Subs(cCont,2,Len(cCont)-2)
					nPos := 0
					lAchou := .F.
				Else
				  	lAchou := .F.
					cTexto += QA_MExprRange(cAux, cCampo, cExt, lTop)
					lOr := Iif(lOr,.F.,.T.)
					cAux := ""
					cCont := Subs(cCont,2,Len(cCont)-2)
					nPos := 0
				EndIf
			Else
  			    If Len(cTexto) > 0
				    lOr := .T.
			    EndIf
			    cAux += Subs(cCont,1,1)
				cCont := Subs(cCont,2,Len(cCont)-1)
				lAchou := .T.
				nPos++
			EndIf
        Else
		    If nPos > 0  .AND.  At(";",Subs(cCont,2,Len(cCont)-1)) == 0
			    If lOr
					cTexto += " OR "
				EndIf
				If (At(";",cAux) == 0 .OR. At(";",cAux) == Len(cAux) ) .AND. At("-",cCont) > 0
					If Subs(cAux,Len(cAux),1) == ";"
						cTexto += cExt+"."+cCampo+" = '"+PadL(Subs(cAux,1,Len(cAux)-1),nTamanho)+"'"
					Else
						cTexto += cExt+"."+cCampo+" = '"+PadL(cAux,nTamanho)+"'"
					EndIf
					lOr := Iif(lOr,.F.,.T.)
					cAux := ""
					cCont := Subs(cCont,1,Len(cCont)-2)
					nPos := 0
					lAchou := .F.
				Else
				  	lAchou := .F.
					If lOr
						cTexto += " OR "
					EndIf
					cTexto += QA_MExprRange(cAux, cCampo, cExt, lTop)
					lOr := Iif(lOr,.F.,.T.)
					cAux := ""
					cCont := Subs(cCont,2,Len(cCont)-2)
				EndIf
			Else
		    	cAux += Subs(cCont,1,1)
				cCont := Subs(cCont,2,Len(cCont)-1)
			EndIf
	    EndIf
	Enddo
	If Len(cAux) > 0
	    If lOr
			cTexto += " OR "
		EndIf
		cTexto += QA_MExprRange(cAux, cCampo, cExt, lTop)
	EndIf
Else
	cTexto := QA_MExprRange(cCont, cCampo, cExt, lTop)
EndIf

Return cTexto

/*


Ŀ
Funo    QA_Range   Autor   Cicero Cruz           Data  05/03/07 
Ĵ
Descrio  Gera a Expresso                                           
Ĵ
 Uso       Quality                                                    
ٱ


*/
Function QA_MExprRange(cCont, cCampo, cExt, lTop)
Local cTexto  	:= ""
Local lPassou 	:= .F.
Local lBet	  	:= .F.
Local lVig	  	:= .F.
Local lRan1	  	:= .F.
Local nTamanho  := GetSx3Cache(cCampo,"X3_TAMANHO")

Default lTop  := .T.

If lTop
	nTexto:= At(";",cCont) //"111111;222222"

	If nTexto > 0
		lRan1 := .T.
	Else
		lRan1 := .F.
	EndIf

	While !Empty(cCont)

		nTexto:= At(Iif(lRan1,";","-"),cCont)

		If nTexto > 0 .AND. lRan1
			lPassou := .T.
			If lVig
			cTexto += ","
			EndIf
			cTexto += "'"+PadL(Subs(cCont,1,nTexto-1),nTamanho)+"'"
			nTexto += 1
			lVig := .T.
		Elseif nTexto > 0 .AND. !lRan1
			nTexto:= At("-",cCont) //"111111-222222"
			If nTexto > 0
				If !lBet
					lPassou := .T.
					cTexto += "BETWEEN "
					lBet := .T.
				EndIf
				cTexto += "'"+PadL(Subs(cCont,1,nTexto-1),nTamanho)+"'"
				nTexto += 1
            EndIf
		Else
			If lRan1 .AND. Len(cTexto) > 0
				cTexto += ",'"+PadL(AllTrim(Subs(cCont,1,Len(cCont))),nTamanho)+"'"
				nTexto := Len(cCont)
			ElseIf !lRan1 .AND. lBet .AND. Len(cTexto) > 0
				cTexto += " AND '"+PadL(AllTrim(Subs(cCont,1,Len(cCont))),nTamanho)+"'"
				nTexto := Len(cCont)
			EndIf
		EndIf

		If At(Iif(lRan1,";","-"),cCont) > 0
			cCont := Subs(cCont,nTexto,(Len(cCont)-nTexto)+1)
		Else
			cCont := ""
		EndIf

	Enddo

	If lPassou
	     If lRan1
	        cTexto := cExt+"."+cCampo+" IN ("+AllTrim(cTexto)+")"
	     Else
	        cTexto := cExt+"."+cCampo+" "+AllTrim(cTexto)+" "
	     EndIf
	EndIf

Endif

Return cTexto

/*

Ŀ
Funo    SX3Desc    Autor  Rafael S. Bernardi     Data 17/03/2007
Ĵ
Descrio Devolve array com a descricao dos campos no SX3             
Ĵ
Parametros ExpA1 = Array com nomes dos campos que se quer a descricao 
Ĵ
 Uso      SIGAQIP                                                     
ٱ

*/
Function SX3Desc(aParam)
Local aRet  := {}
Local aArea := GetArea()
Local nOrdem := SX3->(IndexOrd())
Local nX

dbSelectArea("SX3")
dbSetOrder(2)

For nX := 1 to Len(aParam)
	dbSeek(aParam[nX])
	aAdd(aRet, X3Descric())
Next nX

SX3->(dbSetOrder(nOrdem))
RestArea(aArea)
Return aRet

 /*


ͻ
Programa   QADivFra Autor   Sandra Ribeiro      Data   01/01/09   
          |                 | Cicero Odilio            |             
͹
Desc.      Analisa necessidade de diviso silbica                    
͹


*/
Function QADivFra(cTextoOri, nTamanho)
Local aSilaba   := {}
Local aSilaba2  := {}
Local aTexto    := {}
Local cPalavra  := ""
Local cTexto    := cTextoOri
Local cLinha    := ""
Local nI        := 0
Local nEspaco   := 0
Local nEnter    := 0

//Ŀ
// O recurso de divisao silabica eh usado apenas na impressao          
//


While Len(cTexto) > 0
    cTexto := Alltrim(cTexto) + " "   // Acrescentado para evitar o nEspaco = ZERO
	nEnter := At(chr(13)+chr(10),cTexto)

	If nEnter =1
       	Aadd(aTexto,cLinha)
	   	cLinha := ""
  		cTexto := Stuff(cTexto,1,nEnter+1,"")
 		Loop
	Endif
	nEspaco:= At(" ",cTexto)
	If nEspaco >0 .AND.(nEspaco -1) <= nTamanho
		If (Len(cLinha)+nEspaco -1) <= nTamanho  // Inserido "-1" para desconsiderar o "ESPACO" final na quebra
			If nEspaco > 0
				cLinha += SubStr(cTexto,1,nEspaco)
		    	cLinha += ""
   			    cTexto := Stuff(cTexto,1,nEspaco,"")
  			Else
  				If Len(cLinha) > 0
  					If Len(cLinha+cTexto) >= nTamanho
		   	       		Aadd(aTexto,cLinha)
				   		cLinha := ""
				   	EndIf
  				EndIf
			cLinha += SubStr(cTexto,1,nTamanho)
			cLinha += " "
			cTexto := Stuff(cTexto,1,nTamanho,"")
   	       	Aadd(aTexto,cLinha)
		   	cLinha := ""
			EndIf
   		Else
   			cPalavra := SubStr(cTexto,1,nEspaco)
			If Len(aSilaba2) = 0
				aSilaba := QAXDivQAL(cPalavra)
				aSilaba2:= aClone(aSilaba)
			Endif
	        For nI := 1 To Len(aSilaba)
	        	If (Len(cLinha)+Len(Trim(aSilaba[nI])) < nTamanho).AND.(nI < Len(aSilaba))
			   		cLinha := cLinha + Alltrim(aSilaba[nI])
			    ElseIf nI == Len(aSilaba).AND.(Len(cLinha)+Len(Trim(aSilaba[nI])) = nTamanho)
			   		cLinha := cLinha + Alltrim(aSilaba[nI])
					Aadd(aTexto,cLinha)
			   		cLinha := ""
			    ElseIf nI == Len(aSilaba).AND.(Len(cLinha)+Len(aSilaba[nI]) > nTamanho)
					Aadd(aTexto,cLinha+Iif(/*Right(Alltrim(clinha),1) $ FIMLINHA .OR. */Right(cLinha,1) == " ","","-"))
			   		cLinha := ""
					cLinha := Alltrim(aSilaba[nI])+ " "
				ElseIf nI == Len(aSilaba).AND.(Len(cLinha)+Len(Trim(aSilaba[nI])) < nTamanho)
					cLinha := cLinha + Alltrim(aSilaba[nI])+" "
			    Else
		    		Aadd(aTexto,cLinha+Iif(/*Right(Alltrim(clinha),1) $ FIMLINHA .OR. */Right(cLinha,1) == " ","","-"))
			   		cLinha := ""
			   		cLinha := cLinha + aSilaba[nI]
	 		    EndIf
	 		    If Len(aSilaba2)>1
		 		    aDel(aSilaba2,1)
				    aSize(aSilaba2,Len(aSilaba2)-1)
				EndIf
	 		Next

   			cTexto := Stuff(cTexto,1,nEspaco,"")
   			aSilaba := {}
   			aSilaba2:= {}
   		EndIf
   	Else
   		If nEspaco == 0
   			cPalavra := SubStr(cTexto,1,Len(cTexto))
   		Else
   			cPalavra := SubStr(cTexto,1,nEspaco)
   		EndIf
 		aSilaba := QAXDivQAL(cPalavra)
		If nEspaco > 0 .OR. nEnter > 0  //tratamento da ultima palavra ou ... quando o texto eh unica palavra com o tamnanho maior da coluna a ser impressa
	        If Len(aSilaba) > 0
				cLinha := iif(len(Trim(cLinha))>1, Trim(cLinha)+" ", "")
			EndIf
	 	    For nI := 1 To Len(aSilaba)-1
	 	    	 If Len(cLinha)+Len(aSilaba[nI]) < nTamanho
		   			cLinha := cLinha + Alltrim(aSilaba[nI])
	 	    	 Else
		   	    	Aadd(aTexto,cLinha+Iif(/*Right(Alltrim(clinha),1) $ FIMLINHA .OR. */Right(cLinha,1) == " ","","-"))
		   			cLinha := ""
		   			cLinha := cLinha + Alltrim(aSilaba[nI])
	 	    	 EndIf
	 	    Next
			If Len(cLinha)+Len(aSilaba[nI]) < nTamanho
				cLinha += aSilaba[nI]
			Else
				If Len(cLinha)+Len(aSilaba[nI]) > nTamanho
                    If len(cLinha) > 0
					   Aadd(aTexto,cLinha+Iif(/*Right(Alltrim(clinha),1) $ FIMLINHA .OR. */Right(cLinha,1) == " ","","-"))
					   cLinha := ""
                    Endif
					cLinha += aSilaba[nI]
				EndIf
			EndIf
	   		cTexto := Stuff(cTexto,1,nEspaco,"")
	   		aSilaba := {}
	   		aSilaba2 := {}
        Else
   	        If Len(aSilaba) > 1
   	        	For nI := 1 To Len(aSilaba)-1
		 	    	 If Len(cLinha)+Len(aSilaba[nI]) < nTamanho
			   			cLinha := cLinha + Alltrim(aSilaba[nI])
	 		    	 Else
		   		    	Aadd(aTexto,cLinha+Iif(/*Right(Alltrim(clinha),1) $ FIMLINHA .OR. */Right(cLinha,1) == " ","","-"))
		   				cLinha := ""
		   				cLinha := cLinha + Alltrim(aSilaba[nI])
		 	    	 EndIf
		 	    	 cTexto := Stuff(cTexto,1,Len(aSilaba[nI]),"")
 	    		Next
	   		Else
	   			If Len(cLinha)+Len(aSilaba[1]) < nTamanho
	   				cLinha := cLinha + Alltrim(aSilaba[1])
		    	Else
		   		   	Aadd(aTexto,cLinha+Iif(/*Right(Alltrim(clinha),1) $ FIMLINHA .OR. */Right(cLinha,1) == " ","","-"))
		   			cLinha := ""
		   			cLinha := cLinha + Alltrim(aSilaba[1])
		 	    EndIf
		 	    cTexto := Stuff(cTexto,1,Len(aSilaba[1]),"")
	   		EndIf
	   		aSilaba := {}
	   		aSilaba2:= {}
        EndIf
    EndIf
	If Len(Trim(cTexto)) == 0
		lContinua := .F.
	   	Aadd(aTexto,cLinha)
		cLinha := ""
	EndIf
EndDo

cTexto := ""
For nI := 1 To Len(aTexto)
	cTexto += aTexto[nI]+Chr(13)+Chr(10)
Next
cTexto += cLinha

Return cTexto

/*


ͻ
Programa  DICXGAPAL Autor   Sandra Ribeiro/     Data   01/01/09   
          |                 | Cicero Odilio            |             
͹
Desc.      Grava as Palavras                                          
͹
Uso        QMTA150                                                    
ͼ


*/

Function QAXACENTO(cPalavra, nOpcao)
Local cPalAlt 	 := ""
Local nI		 := 0
Local cLetra	 := ""
Local nPosV		 := 0
Local nPosC		 := 0
Local cVogais	 := "aeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOU"
Local cAcenSubst := "      "//No mexer nestes simbolos pois sao os acentos
Local cAcentoV	 := "      " //Vogais acentuadas - No mexer nestes simbolos pois sao os acentos
Local cConsSubst := ""     // C cedilha maiusculo e enhe maiusculo  //No mexer nestes simbolos pois sao os acentos
Local cConsoante := "cCnN"
Local cAcentoC	 := ""     //COnsoantes acentuadas - No mexer nestes simbolos pois sao os acentos

Default nOpcao := 1

If nOpcao == 1
	For nI := 1 to Len(Alltrim(cPalavra))
		cLetra 	:= SubStr(AllTrim(cPalavra),nI,1)
		nPosV 	:= At(cLetra,cAcentoV)
		If nPosV > 0
			cLetra := SubStr(cVogais,nPosV,1)
		EndIf
		nPosC 	:= At(cLetra,cAcentoC)
		If nPosC > 0
			cLetra := SubStr(cConsoante,nPosC,1)
		EndIf
		cPalAlt += cLetra
	Next
ElseIf nOpcao == 2
	For nI := 1 to Len(Alltrim(cPalavra))
		cLetra 	:= SubStr(AllTrim(cPalavra),nI,1)
		nPosV 	:= At(cLetra,cAcentoV)
		If nPosV > 0
			cLetra := SubStr(cAcenSubst,nPosV,1)
		EndIf
		nPosC 	:= At(cLetra,cAcentoC)
		If nPosC > 0
			cLetra := SubStr(cConsSubst,nPosC,1)
		EndIf
		cPalAlt += cLetra
	Next
EndIf

Return cPalAlt

/*


ͻ
Programa   QAXDivQALAutor   Sandra Ribeiro      Data   01/01/09   
          |                 | Cicero Odilio            |             
͹
Desc.      Separa as silabas de uma palavra                           
͹


*/
Function QAXDivQAL(cTextoOri)
Local aSilabas  :=  {}
Local cSeparada := ""
Local cSilaba   := ""
Local nBranco	:= 0
Local nVlrAr
Local cTexAux   :=""

DBSelectArea("QAL")
DBSetOrder(1)

While Right(Alltrim(cTextoOri),1) $ FIMLINHA
	cTexAux += Right(Alltrim(cTextoOri),1)
    cTextoOri := Stuff(cTextoOri,len(Alltrim(cTextoOri)),1,"")
EndDo

If  DbSeek(xFilial("QAL")+UPPER(QAXACENTO(cTextoOri,1)))
	cSeparada := QAL->QAL_SILABA
	nBranco := At(" ",AllTrim(cSeparada))
	While nBranco > 0
		cSilaba := SubStr(AllTrim(cSeparada),1,nBranco)
		AAdd(aSilabas,SubStr(AllTrim(cTextoOri),1,nBranco-1))
		cSeparada := Stuff(cSeparada,1,nBranco,"")
		cTextoOri:= Stuff(cTextoOri,1,len(AllTrim(cSilaba)),"")
		nBranco := At(" ",AllTrim(cSeparada))
	EndDo
	AAdd(aSilabas,cTextoOri)
Else
	AAdd(aSilabas,cTextoOri)
EndIf

nVlrAr := Len(aSilabas)

If Len(cTexAux)>0
	aSilabas[nVlrAr] := Alltrim(aSilabas[nVlrAr])+cTexAux
EndIf

If nVlrAr > 0
	aSilabas[nVlrAr] := Alltrim(aSilabas[nVlrAr])+" "
Endif

Return aSilabas


/*/{Protheus.doc} QAStrToASC
	Converte string com caractere especial em string com conteudo ASCII para utilizao em query SQL
	@type  Function
	@author Clio Pedro Ribeiro Fernandes Pereira
	@since 14/04/2022
	@param cString, caractere, string que deseja ser convertida
	@return cReturn, caractere, string convertida
	/*/

Function QAStrToASC(cString)

	Local cAnsi   := ""
	Local cConct  := ""
	Local cReturn := FwQtToChr(cString)                                            //Remove caracretes especiais FRAME

	Static cDbType := AllTrim(Upper(TcGetDb()))

	cConct  := IIf("MSSQL"==cDbType, "+"       , "||"     )
	cAnsi   := IIf("MSSQL"==cDbType, "CHAR(63)", "CHR(63)")                         //Determina Cdigo Converso ASCII para "?"
	cReturn := StrTran( cReturn, "?"         , "'" + cConct + cAnsi + cConct + "'") //Remove caractere especial "?"
	cReturn := StrTran( cReturn, "''"+cConct , ""                                 ) //Remove duplo ''+cConcat

Return cReturn


/*/{Protheus.doc} QLTGetHelp
Retorna Help padro
@type  Function
@author brunno.costa
@since 26/03/2025
@return aRet, array, array com cdigo, problema e soluo do help {cTitulo, cMsgHlp, cSolHlp}
/*/
Function QLTGetHelp()

Local cMsgHlp		:= ''
Local cSolHlp		:= ''
Local cTitulo       := ''
Local nQtdElem		:= 0
Local nX			:= 1
Local lPadrao		:= !( FWIsInCallStack("EXECBLOCK") .OR. FWIsInCallStack("EXECTEMPLATE") )	//Verifica se a funo est sendo chamada por funes do Padro ou por Customizaes e/ou Templates
Local aRet			:= {'',''}
Local aHelp

If	lPadrao
	//S executa a funo se for chamada por funes do padro, e no possuir funes CUSTOMIZADAS ou de TEMPLATE na pilha de chamadas...
	aHelp	:= FwGetUltHlp()
	If ValType(aHelp) == 'A' .AND. Len(aHelp) == 3

		cTitulo := aHelp[1]

		//Mensagem
		nQtdElem := Len(aHelp[2])
		For nX := 1 to nQtdElem
			cMsgHlp += If(Empty(cMsgHlp), '', ' ') + AllTrim(aHelp[2][nX])
		Next nX

		//Soluo
		nQtdElem := Len(aHelp[3])
		For nX := 1 to nQtdElem
			cSolHlp += If(Empty(cSolHlp), '', ' ') + AllTrim(aHelp[3][nX])
		Next nX
		aRet	:= {cTitulo, cMsgHlp, cSolHlp}
	EndIf

	FwClearHlp()	//Limpa ltimo help executado
	FreeObj(aHelp)
EndIf
Return aRet

/*/{Protheus.doc} LOCALIZSRA
Funo que localiza a matrcula(QAA) na tabela de funcionrio(SRA)

@type  Function
@author thiago.rover
@since 26/05/2025
@param 01 - cEmpAux, caracter, empresa para preparao do ambiente
@param 02 - cFilAux, caracter, filial para preparao do ambiente
@param 03 - cMatricula, caracter, chave filial+matrcula que ser utilizada no posicionamento da tabela SRA
@param 04 - cModulo, caracter, mdulo para preparao do ambiente

@return nRetorno, nmero, retorna: 0 se a tabela SRA NO foi localizada ou ocorreu falha na abertura do ambiente 
                                   1 se a matrcula foi localizada na tabela SRA 
                                   2 se a matrcula NO foi localizada na tabela SRA
/*/
Function LOCALIZSRA(cEmpAux, cFilAux, cMatricula, cModulo)

Local bErrorBlock := Nil
Local lAmbiente   := .T.
Local nRetorno    := 0 // No localizou a tabela SRA ou Ocorreu falha na abertura do ambiente, retornar 0

bErrorBlock := ErrorBlock({|| lAmbiente := .F.}) // Define o bloco de tratamento de erro

RpcSetType(3)
lAmbiente := RpcSetEnv(cEmpAux, cFilAux,,, cModulo) // Abre o ambiente com a empresa, filial e mdulo informados

If lAmbiente
	dbSetOrder(1) // Filial + Matrcula
	dbSelectArea("SRA")
	If Select("SRA") > 0 // Verifica se a tabela SRA est aberta
		If SRA->(dbSeek(cMatricula))
			nRetorno := 1 // Localizou a matrcula na tabela SRA
		Else
			nRetorno := 2 // No localizou a matrcula na tabela SRA
		Endif		
	SRA->(DbCloseArea())
	EndIf
EndIf

ErrorBlock(bErrorBlock) // Restaura o bloco de erro original

RpcClearEnv() // Limpa o ambiente

Return nRetorno
