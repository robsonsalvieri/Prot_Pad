#include "TOTVS.CH"
#INCLUDE "QMTA040.CH"

/*


Ŀ
Funo	  QMTA040	 Autor  Wanderley Goncalves Jr Data  01/12/97 
Ĵ
Descrio  Programa de atualizacao de Escalas				  		  
Ĵ
Sintaxe	  Void QMTA040												  
Ĵ
Uso		  SIGAQMT													  
Ĵ
 ATUALIZACOES SOFRIDAS DESDE A CONSTRUCAO INICIAL. 				  	  
Ĵ
 PROGRAMADOR   DATA    BOPS 	MOTIVO DA ALTERACAO				  	  
Ĵ
Denis Martins 19/03/02      Trazer o tipo de tolerancia que esta ca-
                            dastrado no arquivo de padroes.          
Denis Martins 22/04/02      Ajuste na delecao/gravacao de padroes ti
                            po soma qdo existir mais de um ponto na  
                            escala.                                  
ٱ

 
*/
Static Function MenuDef()

Local aRotina := { {STR0043  ,"AxPesqui"  , 0 , 1,,.F.},;    // "Pesq." 
					{STR0044  ,"AxVisual"  , 0 , 2},;    // "Visual."
					{STR0045  ,"A040Iesc"  , 0 , 3},;    // "Incl."   
					{STR0046  ,"A040Iesc"  , 0 , 4},;    // "Alt."   
					{STR0047  ,"A040Desc"  , 0 , 5, 3},; // "Excl."   
					{STR0048  ,"A040Jun"   , 0 , 4} }    // "Padres"

Return aRotina

Function QMTA040() 

Local lQM040Brow := ExistBlock("QM040BROW")
Local aRotAdic   := {}

//Ŀ
// Define Variaveis 											 
//
Private aTela[0][0]
Private oCbxTol
Private nTipTol := 1
Private cTipTol                                          
Private cTipGrav                                         
Private aCRA := { OemToAnsi(STR0008), OemToAnsi(STR0014), OemToAnsi(STR0007) }  //"Confirma" ### "Redigita" ### "Abandona"

//Ŀ
// Define o cabecalho da tela de atualizacoes					 
//
Private cCadastro := OemtoAnsi(STR0006)  //"Escalas"
Private nTamQM3   := TamSx3("QM3_PADRAO")[1]

//Ŀ
// Define Array contendo as Rotinas a executar do programa 	 
// ----------- Elementos contidos por dimensao ------------	 
// 1. Nome a aparecer no cabecalho 							 
// 2. Nome da Rotina associada									 
// 3. Usado pela rotina										 
// 4. Tipo de Transao a ser efetuada							 
//	 1 - Pesquisa e Posiciona em um Banco de Dados				 
//	 2 - Simplesmente Mostra os Campos							 
//	 3 - Inclui registros no Bancos de Dados					 
//	 4 - Altera o registro corrente								 
//	 5 - Remove o registro corrente do Banco de Dados			 
//
Private aRotina := MenuDef()

QM9->(DbSetOrder(1))
If lQM040Brow
	ExecBlock("QM040BROW",.F.,.F.)
Endif

//Ŀ	
// Ponto de entrada - Adiciona rotinas ao aRotina       
//
If ExistBlock("QM040ROT")
	aRotAdic := ExecBlock("QM040ROT", .F., .F.)
	If ValType(aRotAdic) == "A"
		AEval(aRotAdic,{|x| AAdd(aRotina,x)})
	EndIf
EndIf

//Ŀ
// Endereca a funcao de BROWSE									 
//
mBrowse( 6, 1,22,75,"QM9")

Return .T.

/*
antigo a040Chav

Ŀ
Funo	 qmt040Chv  Autor  Wanderley Goncalves    Data  03/02/98 
Ĵ
Descrio  Validacao dos campos chave 								  
Ĵ
 Uso		  Qmta040 - E' chamada no X3_VALID.                          
ٱ


*/
Function qmt040Chv()
Local lRet := .T.
Local cVar := readvar() // Conteudo da variavel do campo Revisao de Faixa

If ! Empty( M->QM9_ESCALA ) .and. ! Empty( M->QM9_REVESC )
	If Alltrim(cVar) == "M->QM9_REVESC"
		lRet := FreeForUse("QM9",M->QM9_ESCALA+M->QM9_REVESC)
		If lRet 
			dbSelectArea("QM9")
			If dbSeek( xFilial() + M->QM9_ESCALA +  Inverte(M->QM9_REVESC) ) 
				Help( " ", 1, "JAGRAVADO" )
				lRet := .F.
			Endif
		Endif
	Endif
EndIf

Return( lRet )

/*

Ŀ
Funo	  A040Iesc  Autor  Wanderley Goncalves Jr Data  16/12/97 
Ĵ
Descrio  Programa de manutencao de Escalas - Inclusao 			  
Ĵ
Sintaxe	  A040Iesc(ExpC1,ExpN1,ExpN2)								  
Ĵ
Parametros ExpC1 = Alias do arquivo									  
			  ExpN1 = Numero do registro 								  
			  ExpN2 = Opcao selecionada								  
Ĵ
 Uso		  QMTA040													  
Ĵ
 PROGRAMADOR   DATA    BOPS 	MOTIVO DA ALTERACAO					  
Ĵ
Iuri Seto     31/08/00 5095 Gerar nova revisao ao alterar uma escala
ٱ


*/
FUNCTION A040Iesc(cAlias,nReg,nOpc)
Local oDlg
Local nOpca		:= 0
Local cCadastro := STR0006 + " - " + iif(nOpc==3,UPPER(STR0045),UPPER(STR0046)) //Cadastro de Escalas
Local aPosEnch	:= {}
Local cRevInv   := ""
Local cRev      := "" 

Local aPosObj := {}  
Local aObjects:= {}   
Local aInfo   := {}  
Local aSize   := {}


Private cTipAnt	:= ""
Private lTamSom	:= GetMv("MV_QMTPCES") == "1" //Para escalas do tipo soma considerar decimais definida na escala
Private aTELA[0][0]
Private aGETS[0]
Private cUtRev  := ""                

//Ŀ
// Define tamanho da tela                     
//
aSize := MsAdvSize(, .F., 400 )
aObjects := {}
AAdd( aObjects, { 100, 600, .T., .T. } )

aInfo := { aSize[ 1 ], aSize[ 2 ], aSize[ 3 ], aSize[ 4 ], 3, 3 } 
aPosObj := MsObjSize( aInfo, aObjects )

//Ŀ
// Monta a entrada de dados do arquivo							 
//

While .T.

	//Ŀ
	// Envia para processamento dos Gets		   
	//
	nOpcA:=0

	if nOpc == 3  // Inclusao
		RegToMemory(cAlias,.T.)

		DEFINE MSDIALOG oDlg TITLE cCadastro FROM aSize[7],000 to aSize[6],aSize[5] OF GetWndDefault() PIXEL 
		oDlg:lMaximized:=.T.	
		EnChoice( cAlias, nReg, nOpc,,,,,aPosObj[1],, , , ,,,) //"Quanto  incluso?"
		ACTIVATE MSDIALOG oDlg ON INIT (QMTA040EnBar(oDlg,{|| If(Obrigatorio(aGets,aTela),(lRet:=A040TDOK(cAlias,nOpc),If(lRet,oDlg:End(),.F.)),.F.)},{ ||nOpca := 2,oDlg:End()},nOpc)) CENTERED
	elseif nOpc == 4	// Alteracao
		cUtRev := QMA040UltR(QM9->QM9_ESCALA)
		If QM9->QM9_REVESC <> cUtRev
			HELP(" ",1,"QMTALTREV") // Nao e possivel alterar esta revisao. Somente a ultima revisao pode ser alterada.
		Else
			cTipAnt := QM9->QM9_TIPAFE
			If !QMA040Cal(QM9->QM9_ESCALA,QM9->QM9_REVESC)

				RegToMemory(cAlias,.F.)
		
				DEFINE MSDIALOG oDlg TITLE cCadastro FROM aSize[7],000 to aSize[6],aSize[5] OF GetWndDefault() PIXEL 
				oDlg:lMaximized:=.T.
			
				
				EnChoice( cAlias, nReg, nOpc,,,,,aPosObj[1],, , , ,,,) //"Quanto  incluso?"
	
				ACTIVATE MSDIALOG oDlg ON INIT (QMTA040EnBar(oDlg,{|| If(Obrigatorio(aGets,aTela),(lRet:=A040TDOK(cAlias,nOpc),If(lRet,lRet := QMT040CvUn(),.F.),If(lRet,oDlg:End(),.F.)),.F.)},{ ||nOpca := 2,oDlg:End()},nOpc)) CENTERED
			Else		
				nOpcA:=AltRevisao( cAlias, nReg, nOpc, , , , ,'A040TDOK("QM9",,.f.)') //,"Qmt040Rev()"
				If nOpca == 4 // Se realmente houve alteracao no registro.
					cRevInv := QM9->QM9_REVINV 
					cRev    := QM9->QM9_REVESC 
					RecLock("QM9",.F.)
//					Replace QM9->QM9_REVESC with StrZero(Val(cUtRev)+1,2)
					Replace QM9->QM9_REVINV with Inverte(QM9->QM9_REVESC,2)
					Replace QM9->QM9_DATREV	 with dDataBase				
					MsUnlock()
					FkCommit()
					If QM9->QM9_TIPAFE $ "1,2,3,9"
						QMA040DpPa(cRevInv)
					ElseIf QM9->QM9_TIPAFE $ "5"
						QMA040DpPS(cUtRev)
					EndIf
				Endif
			EndIf
		Endif

	Endif
	Exit
EndDo
dbSelectArea(cAlias)
return


/*


Ŀ
Funo	  A040TdOK  Autor  Wanderley Goncalves Jr Data  05/02/97 
Ĵ
Descrio  Verifica informacoes antes da gravacao 					  
Ĵ
Sintaxe	  A040TdOk(ExpC1,ExpN1,ExpN2)								  
Ĵ
 Uso		  QMTA040													  
ٱ


*/

FUNCTION A040TdOk(cAlias,nOpc,lVerif)
Local	lRet	 := .t.
Local	aArea	 := GetArea()
Local	aStru	 := {}
Local	aTam	 := {}
Local	lExit	 := .F.
Local	i		 := 0
Local 	bCampo   := {|nCPO| Field(nCPO) }
Local  oTmpTable:= NIL
Default nOpc	 := 4          
Default lVerif   := .t.
If lRet
	If M->QM9_ORGAFE == "I" .and. empty(M->QM9_TIPAFE)
		Help( " ", 1, "A040TIPOOB" ) // Para calibracao interna,  obrigatorio 
											  // o cadastramento do tipo de afericao.
		lRet := .F.
	EndIf 	
EndIf

If lRet
	If !empty(M->QM9_TIPAFE) .and. empty(M->QM9_LAUDO) .and. M->QM9_NROMED > 0
		Help( " ", 1, "A040LAUDO") 	// Campo LAUDO obrigatorio para o tipo de 
											  	// Calibracao determinado.
		lRet := .F.
	EndIf 	
EndIf

If lRet 
	//Ŀ
	// Se for externo sem medicoes, no preencher campo tipo de laudo 
	//
	If M->QM9_ORGAFE == "E" .and. M->QM9_NROMED == 0 .and. !empty(M->QM9_TIPAFE)
		Help( " ", 1, "A040NLAUDO") 	// Campo TIPO DE CALIBRAO no deve ser 
											  	// preenchido para origem externo e sem medies. 
		lRet := .F.
	EndIf 	
EndIf

If lRet 
	//Ŀ
	// Se for externo sem medicoes, Laudo s poder ser 1 ou 2 
	//
	If M->QM9_ORGAFE == "E" .and. M->QM9_NROMED == 0 .and. !(M->QM9_LAUDO$"1$2$ ")
		Help( " ", 1, "A040ILAUDO") 	// Para origem externo sem medicoes, o campo
											  	// LAUDO s poder ser incerteza, com ou sem 
												// confirmao metrolgica ou branco.
		lRet := .F.
	EndIf 	
EndIf

//Ŀ
// Altera de texto retornado pelo gatilho para							   
// valor determinado no combo para gravacao - Somente para Calibradores.  
//
  
If M->QM9_TIPAFE == "4"
	If Alltrim(M->QM9_VALESP) == "Fixo" 
		M->QM9_VALESP := '1'
	EndIf
Endif

If M->QM9_PERRO == OemtoAnsi(STR0040) // "Em relacao a tabela"
	M->QM9_PERRO := '3'
EndIf

M->QM9_REVINV := Inverte( M->QM9_REVESC )

If lRet 
	lRet := qmt040VNM()
EndIf

If lRet
	lRet := qmt040VTL()
EndIf

If Altera
	If lRet
		If (M->QM9_TIPAFE $ "4|8" .and. !(cTipAnt $ "4|8")) .or.;
		   (!(M->QM9_TIPAFE $ "4|8") .and. (cTipAnt $ "4|8"))
			aStru := {}
			aTam := TamSX3("QMK_FILIAL")
			Aadd(aStru,{ "TMP_FILIAL","C",aTam[1],aTam[2] })
			aTam := TamSX3("QMK_ESCALA")
			Aadd(aStru,{ "TMP_ESCALA","C",aTam[1],aTam[2] })
			aTam := TamSX3("QMK_TIPO")
			Aadd(aStru,{ "TMP_TIPO","C",aTam[1],aTam[2] })
			aTam := TamSX3("QMK_REVTIP")
			Aadd(aStru,{ "TMP_REVTIP","C",aTam[1],aTam[2] })
			
			
			oTmpTable := FWTemporaryTable():New( "IMPTMP" )
			oTmpTable:SetFields( aStru )
			oTmpTable:AddIndex("indice1", {"TMP_FILIAL","TMP_ESCALA"} )
			oTmpTable:Create()

			Processa ({||G040Temp()})

			IMPTMP->(dbGoTop())
			While !IMPTMP->(Eof())
				dbSelectArea("QMK")
				dbSetOrder(1)
				If dbSeek(xFilial("QMK")+IMPTMP->TMP_TIPO+Inverte(IMPTMP->TMP_REVTIP))
					While !Eof() .and. xFilial("QMK")+QMK->QMK_TIPO+QMK->QMK_REVTIP==;
							IMPTMP->TMP_FILIAL+IMPTMP->TMP_TIPO+IMPTMP->TMP_REVTIP
						dbSelectArea("QM9")
						dbSetOrder(01)
						If dbSeek(xFilial("QM9")+IMPTMP->TMP_ESCALA)
							If (M->QM9_TIPAFE $ "4|8" .and. !(cTipAnt $ "4|8"))
								Help(" ",1,"A040DICAL")
								M->QM9_TIPAFE = cTipAnt
								lExit := .T.
								lRet  := .F.	
							ElseIf (!(M->QM9_TIPAFE $ "4|8") .and. (cTipAnt $ "4|8"))
								Help(" ",1,"A040IGCAL")
								M->QM9_TIPAFE = cTipAnt
								lExit := .T.
								lRet  := .F.	
							Endif
						Endif 
						If lExit
							Exit
						Endif
						dbSelectArea("QMK")
						dbSkip()
					Enddo					     
				Endif
				If lExit
					Exit
				Endif
				dbSelectArea("IMPTMP")
				dbSkip()
			Enddo
			oTmpTable:Delete()
			dbSelectArea("QMK")
			RetIndex("QMK")                      
			Set Filter to
			QMK->(DbSetOrder(1))
			RestArea(aArea)
		Endif
	Endif				
Endif	

If lRet .and. lVerif
	dbSelectArea("QM9")
	If nOpc == 3 //Se for inclusao
		RecLock(cAlias,.T.)
	Else
		RecLock(cAlias,.F.)	
	Endif	             
	
	For i := 1 TO FCount()
		FieldPut(i,M->&(EVAL(bCampo,i)))
	Next i
	Replace QM9->QM9_FILIAL With xFilial("QM9")
	Replace QM9->QM9_REVINV With Inverte(QM9->QM9_REVESC)
	MsUnlock()   
Endif

Return(lRet)

/*


Ŀ
Funo	  A040Desc  Autor  Wanderley Goncalves Jr Data  14/11/97 
Ĵ
Descrio  Programa de exclusao de Escalas - Delecao 				  
Ĵ
Sintaxe	  A040Desc(ExpC1,ExpN1,ExpN2)								  
Ĵ
Parametros ExpC1 = Alias do arquivo									  
			  ExpN1 = Numero do registro 								  
			  ExpN2 = Opcao selecionada								  
Ĵ
 Uso		  QMTA040													  
ٱ


*/

FUNCTION A040Desc(cAlias,nReg,nOpc)
Local nOpcA //,nCntDele := 0 ,cCod ,aAC := { OemToAnsi(STR0007),OemToAnsi(STR0008) }	//"Abandona"###"Confirma" 
Local oDlg
Local lDeleta := .f.
Local aArea   := GetArea()
Local cChave  := "" // chave para delecao do QMQ   

Local aPosObj := {}  
Local aObjects:= {}   
Local aInfo   := {}  
Local aSize   := {}     

//Ŀ
// Monta a entrada de dados do arquivo						     
//
Private aTELA[0][0]
Private aGETS[0]     

//Ŀ
// Define tamanho da tela                     
//
aSize := MsAdvSize(, .F., 400 )
aObjects := {}
AAdd( aObjects, { 100, 600, .T., .T. } )

aInfo := { aSize[ 1 ], aSize[ 2 ], aSize[ 3 ], aSize[ 4 ], 3, 3 } 
aPosObj := MsObjSize( aInfo, aObjects )

While .T.
	//Ŀ
	// Envia para processamento dos Gets		   
	//
	nOpcA:=0
	dbSelectArea(cAlias)
	
	DEFINE MSDIALOG oDlg TITLE cCadastro FROM aSize[7],000 to aSize[6],aSize[5] OF GetWndDefault() PIXEL   
		nOpcA:=EnChoice( cAlias, nReg, nOpc, ,"AC",OemToAnsi(STR0009),,aPosObj[1])  //"Quanto  excluso?" 
		nOpca := 1
	ACTIVATE MSDIALOG oDlg ON INIT EnchoiceBar(oDlg,{|| nOpca := 2,oDlg:End()},{|| nOpca := 1,oDlg:End()})

	dbSelectArea(cAlias)

	If nOpcA == 2
		If QM9->QM9_REVESC <> QMA040UltR(QM9->QM9_ESCALA)
			HELP(" ",1,"QMTDELREV") // Nao e possivel excluir esta revisao. Somente a ultima revisao pode ser excluida.
		ElseIf QMA040Cal(QM9->QM9_ESCALA,QM9->QM9_REVESC)
			HELP(" ",1,"A040MEES") // Existem  medies cadastradas para esta
								  // escala. No ser possvel sua excluso.
		Else	
			lDeleta := .T.
			if QM9->QM9_ORGAFE	== "E"
				DbSelectArea("QMK")
				DbSetOrder(2)
				If QMK->(dbSeek( xFilial("QMK")+QM9->QM9_ESCALA ))
					HELP(" ",1,"A040ESFA")	// Nao e possivel excluir escala, pois esta associada a uma familia.
					lDeleta := .F.           
				EndIf
			EndIf			
			If QM9->QM9_TIPAFE $ "1,2,3,9,4,8"
				//Ŀ
				// Verifica se esta associado a alguma familia.                 
				//
				DbSelectArea("QMK")
				DbSetOrder(2)
				If QMK->(dbSeek( xFilial("QMK")+QM9->QM9_ESCALA ))
					HELP(" ",1,"A040ESFA")	// Nao e possivel excluir escala, pois esta associada a uma familia.
					lDeleta := .F.           
				ElseIf QM9->QM9_TIPAFE $ "1,2,3,9"
					//Ŀ
					// Se Tipo == 1,2,3 ou 9 verifica se existem padroes associados 
					// no QMC. 													 
					//
					dbSelectArea("QMC")
					dbSetOrder(1)
					IF QMC->(dbSeek(xFilial("QMC")+QM9->QM9_ESCALA+Inverte(QM9->QM9_REVESC)))
						HELP(" ",1,"A040PAES") // Nao  possvel excluir escalas, pois 
											  // existem padroes amarrados a mesma.
						lDeleta := .F.											  
					EndIf	
				EndIf
			ElseIf QM9->QM9_TIPAFE == "5"
				//Ŀ	
				// Se Tipo == 5 verifica de existem padroes associados no QMA   
				// (soma de padroes)										     
				//
				dbSelectArea("QMA")
				dbSetOrder(1)
				If dbSeek(xFilial("QMA")+QM9->QM9_ESCALA+QM9->QM9_REVESC)
					HELP(" ",1,"A040PAES") // Nao  possvel excluir escala, pois 
												  // existem padroes amarrados a mesma.
					lDeleta := .F.											  	
				Endif            
			Endif
			If lDeleta
				//Ŀ
				// Verifica se escala esta cad. em um instr. utilizado na cal.  
				//
				If QMA040VIU()
					HELP(" ",1,"A040ESIU") // Nao e possivel excluir escala, pois esta cadastrada em um Instrumento Utilizado na calibracao.
					lDeleta := .F.											  	
				Else					
					//Ŀ
					// Verifica se escala esta cad.em um padrao secundario na cal.  
					//
					If QMA040VPS()
						HELP(" ",1,"A040ESPS")	// Nao e possivel excluir escala, pois esta cadastrada como Padrao Secundario na calibracao.
						lDeleta := .F.											  	
					EndIf
				EndIf 
				//Verifica se existe padroes secundarios amarrados nesta faixa
				DbSelectArea("QMH")
				DbSetOrder(1)
				If dbSeek(xFilial('QMH') + QM9->QM9_ESCALA) 
			 		HELP(" ",1,"A040FXPAD")	// Nao e possivel excluir faixa, pois esta cadastrada com Padrao Secundario.
			 		lDeleta := .F.
				Endif
			EndIf
				
			If lDeleta
				BEGIN TRANSACTION
				//Ŀ
				// Apaga a escala.                                                 
				//
				dbSelectArea("QM9")
				dbSetOrder(1)
				cChave := QM9->QM9_ESCALA+QM9->QM9_REVESC
				RecLock("QM9",.F.)
				dbDelete()
				MsUnlock()
        	
				//Ŀ
				// Apaga a tabela de faixa de aceitacao.                           
				//
				dbSelectArea("QMQ")
				dbSetOrder(1)
				If QMQ->(dbSeek(xFilial()+cChave))
					RecLock("QMQ",.F.,.T.)
					dbDelete()
					MsUnlock()
				EndIf

				//Ŀ
				// Apaga as familias que podem ser usadas na calibracao da escala.	
				//
				DbSelectArea("QMH")
				DbSetOrder(1)
				If dbSeek(xFilial('QMH') + Subs(cChave,1,TamSx3("QM9_ESCALA")[1])) // S escala
					Do while xFilial('QMH') + Subs(cChave,1,TamSx3("QM9_ESCALA")[1]) ==;
								QMH->QMH_FILIAL + QMH->QMH_ESCALA 
						RecLock("QMH",.F.,.T.)
						dbDelete()
						MsUnlock()
						DbSkip()
					EndDo
				EndIf
				END TRANSACTION
	        	Exit
			EndIf 	
		EndIf 	
	EndIf

	Exit

EndDo

dbSelectArea(cAlias)
dbGoTop()

RestArea( aArea )

Return(Nil)

/*

Ŀ
Funo	  A040Coin  Autor  Wanderley Goncalves Jr Data  16/12/97 
Ĵ
Descrio  Consistencia para o numero de medicoes minimas de acordo   
			  com o Tipo de Laudo (Incerteza deve ter  mais de 1 medicao)
Ĵ
Sintaxe	  A040Coin()												  
Ĵ
 Uso		  QMTA040													  
ٱ


*/

FUNCTION A040Coin()

If M->QM9_LAUDO == "1" .or. M->QM9_LAUDO == "2"
	If M->QM9_NROMED = 1
		HELP(" ",1,"A040NUMMED")   
		Return(.f.)
	EndIf
EndIf
Return(.T.)

/*

Ŀ
Funo	  A040CoMe  Autor  Wanderley Goncalves Jr Data  16/12/97 
Ĵ
Descrio  Consistencia para o numero de medicoes minimas de acordo   
			  com o Tipo de Laudo (Incerteza deve ter  mais de 1 medicao)
			  prevendo alteracao do campo Tipo de Laudo depois do no.	  
Ĵ
Sintaxe	  A040CoMe()												  
Ĵ
 Uso		  QMTA040													  
ٱ


*/

FUNCTION A040Come()
Local nRet := m->qm9_nromed
If (empty(M->QM9_NROMED) .or. M->QM9_NROMED=1) .and. M->QM9_LAUDO $ "12";
	.and. (M->QM9_ORGAFE = "I" .and. M->QM9_NROMED > 0)        //M->QM9_COLETA = "S")
	help(" ",1,"a040tipo")
	nRet := 2
EndIf
Return nRet


/*
antigo A040DsTp

Ŀ
Funo	 qmt040DsTp Autor  Wanderley Goncalves Jr Data  16/12/97 
Ĵ
Descrio  Programa para aparecer descricao do Tipo na Browse 		  
Ĵ
Sintaxe	  qmt040DsTp()												  
Ĵ
Parametros 															  
Ĵ
 Uso		  QMTA040 - X3_INIBRW do campo QM9_DESCTP					  
ٱ


*/

FUNCTION qmt040DsTp()
If ExistBlock("qm040NEs")                   
	Return(ExecBlock("qm040NEs",.F.,.F.,{QM9->QM9_TIPAFE}))
Else
	Do Case
		Case QM9->QM9_TIPAFE == "1"
			  Return(padr(OemToAnsi(STR0016),25)) // "Simples"
		Case QM9->QM9_TIPAFE == "2"
			  Return(padr(OemToAnsi(STR0017),25)) // "Completa"
		Case QM9->QM9_TIPAFE == "3"
			  Return(padr(OemToAnsi(STR0018),25)) // "Presso"
		Case QM9->QM9_TIPAFE == "4"
			  Return(padr(OemToAnsi(STR0019),25)) // "Calibrador"
		Case QM9->QM9_TIPAFE == "5"
			  Return(padr(OemToAnsi(STR0020),25)) // "Soma"
		Case QM9->QM9_TIPAFE == "6"
			  Return(padr(OemToAnsi(STR0021),25)) // "Faixa"
		Case QM9->QM9_TIPAFE == "7"
			  Return(padr(OemToAnsi(STR0022),25)) // "Folga/Luz"
		Case QM9->QM9_TIPAFE == "8"
			  Return(padr(OemToAnsi(STR0023),25)) // "Calibrador Completa"
		Case QM9->QM9_TIPAFE == "9"
			  Return(padr(OemToAnsi(STR0049),25)) // "Relogio"
	EndCase 
Endif	

Return(Nil)


/*

Ŀ
			 Funcoes para controle de Cadastro de Padroes				  
ٱ





Ŀ
Funo	  A040PaEs  Autor  Wanderley Goncalves    Data  06/01/98 
Ĵ
Descrio  Cadastra Padroes para Escalas 							  
Ĵ
Sintaxe	  A040PaEs(ExpC1,ExpN1,ExpN2)								  
Ĵ
Parametros ExpC1 = Alias do arquivo									  
			  ExpN1 = Numero do registro 								  
			  ExpN2 = Opcao selecionada no menu						  
Ĵ
 Uso		  QMTA040													  
ٱ


*/
FUNCTION A040Paes(cAlias,nReg,nOpcx)

Local nCnt
Local nSavRec
Local nOpca   :=0
Local nRecNc
Local lInclui := .f.
Local oDlg
Local lGravaOk := .T.
Local cCampo := ""		// Auxiliar para macro
Local aCosAa := {}
Local cSeek
Local cWhile

Private oGetPon 			// Getdados
Private nPos	 := 0		// Posicao QMC_PADRAO
Private nPosTol := 0		// Posicao QMC_TOLER
Private nOldTol
Private nOldTMin
Private nPosTMin := 0		//Posicao QMC_TOLMIN
//Ŀ
// So poderao cadastrar padroes os tipos Simples (1), Com-  
// pleto(2), Pressao(3) e Relogio(9).						 
// - Os Tipos Calibrador(4) e Calibrador Completo(8) SOMENTE
//	padrao Secundario.										 
// - O tipo Soma(5) cadastra Pontos.						 
// - O tipo Faixa(6) - a ser definido. 					 
// - O tipo Folga e Luz (7) NUNCA cadastra padroes.		 
//

If !(QM9->QM9_TIPAFE $ "1,2,3,5,9") 
	If QM9->QM9_TIPAFE $ "4,8"
		Help(" ",1,"A040TIPO48")  // Os Pontos deste Tipo devem ser cadastrados
											// nos prprios Instrumentos.
	Else	 
		Help(" ",1,"A040NCAPAD")  // Tipo nao permite cadastramento de pontos    
	EndIf
	Return(nOpca)
EndIf

If QM9->QM9_TIPAFE == "5"  // Se for tipo Soma
	A040SOMA()
	Return(nOPCa)
EndIf

//Ŀ
// Verifica se ha' padroes ja' existentes para a escala     
//
dbSelectArea("QMC")
dbSetOrder(1)
nSavRec := RecNo()
dbSeek( xFilial()+QM9->QM9_ESCALA+Inverte(QM9->QM9_REVESC ))

nRecNc := RecNo()
nCnt := 0
While !EOF() .And.;
		QMC->QMC_ESCALA == QM9->QM9_ESCALA .and.;
		QMC->QMC_REVESC == QM9->QM9_REVESC .and.;
		QMC->QMC_FILIAL == xFilial('QMC')
	nCnt++
	dbSkip()
EndDo
lInclui := Iif(nCnt==0,.t.,.f.)
dbGoto(nRecNc)

//Ŀ
// Monta a entrada de dados do arquivo							 
//
Private aHeader  := {}
Private Continua := .F.
Private nOpc     := 4
Private nUsado   := 0


//Ŀ
// Salva a integridade dos campos de Bancos de Dados 			 
//
dbSelectArea("SX2")  // Posiciona pq. rotinas internas utilizam inf. do SX2
dbSeek("QMC")

dbSelectArea("QMC")
dbGoto(nRecNc)

cSeek  := QMC_FILIAL+QMC_ESCALA+QMC_REVINV
cWhile := "QMC_FILIAL+QMC_ESCALA+QMC_REVINV"

If lInclui
	FillGetDados(nOpc,"QMC" ,1     ,       ,             ,         ,         ,          ,        ,      ,        ,lInclui,          ,        ,          ,           ,            ,)
  //FillGetDados(nOpc,Alias ,nOrdem,cSeek  ,bSeekWhile   ,uSeekFor ,aNoFields,aYesFields,lOnlyYes,cQuery,bMontCols,lEmpty ,aHeaderAux,aColsAux,bAfterCols,bBeforeCols,bAfterHeader,cAliasQry
Else
	FillGetDados(nOpc,"QMC",1     ,cSeek   ,{|| &cWhile},         ,         ,          ,        ,      ,        ,       ,          ,        ,          ,           ,            ,)
  //FillGetDados(nOpc,Alias ,nOrdem,cSeek  ,bSeekWhile  ,uSeekFor ,aNoFields,aYesFields,lOnlyYes,cQuery,bMontCols,lEmpty ,aHeaderAux,aColsAux,bAfterCols,bBeforeCols,bAfterHeader,cAliasQry
EndIf

nUsado := Len(aHeader)


//Ŀ
// Verifica qual a posicao do campo PADRAO no Header 		   
//
nPos	:=	ASCAN(aHeader,{|x| alltrim(x[2]) = "QMC_PADRAO"})
nPosTol	:=	ASCAN(aHeader,{|x| alltrim(x[2]) = "QMC_TOLER"})
nPosTMin:=	ASCAN(aHeader,{|x| alltrim(x[2]) = "QMC_TOLMIN"})
nPosPdr	:=	ASCAN(aHeader,{|x| alltrim(x[2]) = "QMC_PADRAO"})


dbSelectArea("QMC")
dbGoto(nRecNc)

Continua 	:= .F.
nOpca 		:= 0

aCosAa		:= aClone(aCols)

DEFINE MSDIALOG oDlg TITLE OemtoAnsi(STR0012) From 9,0 To 28,80 OF oMainWnd // "Escala" 
oDlg:lMaximized := .F.
	@ 1.1 , .5	SAY OemToAnsi(STR0012) // "Escala"
	@ 1.1 , 4	SAY QM9->QM9_ESCALA    

	oGetPon := MSGetDados():New(41,5,130,315,nOpcx,"A040PLinOk","A040PTudOk",,.T.,,,,999)

ACTIVATE MSDIALOG oDlg ON INIT EnchoiceBar(oDlg,;
	{||nopca:=1,Iif(oGetPon:TudoOk() .And. A040VldPxF(aCosAa),(nOpca:=1,oDlg:End()),;
	nOpca:=0)},{||nOpca:= 0,oDlg:End()})

If nOpcA == 1 
	Begin Transaction
		lGravaOk := A040Pgrves(cAlias)
		If !lGravaOK 
			Help(" ",1,"A040NAOGRV")
		Else	
			//Processa Gatilhos
			EvalTrigger()
		EndIf 
	End Transaction
Endif

dbSelectArea(cAlias)

Return nOpca


/*


Ŀ
Funo	 A040PLinOk Autor  Wanderley Goncalves    Data  06/01/98 
Ĵ
Descrio  Critica se a linha digitada esta' Ok                       
Ĵ
Parametros ExpC1 = Objeto a ser verificado. 						  
Ĵ
 Uso		  Qmta040													  
ٱ


*/

Function A040PLinOk(o)
Local nPosI := ASCAN(aHeader,{|x| alltrim(x[2]) = "QMC_PADRAO"})
Local nx, lRet := .T.

//Ŀ
// Se deixar a ultima linha em branco, deleta a mesma 
//
If Empty(aCols[Len(aCols),1]) .And. n > 1
	Adel( aCols, Len(aCols) )
	ASize( aCols, Len( aCols) - 1)
	n := Len( aCols )
	oGetPon:oBrowse:Refresh()
	oGetPon:Refresh()
EndIf

//Ŀ
// Verifica se campo escala esta' preenchido                   
//
For nx := 1 To Len(aHeader)

	If Empty(aCols[n][nx])
		If Trim(aHeader[nx][2]) == "QMC_PADRAO" 
			Help(" ",1,"QA_CPOOBR")
			lRet := .F.
			Exit
		Endif

		If !lRet
			Exit
		Endif
	Endif
Next nx

//Ŀ
// Verifica se o padrao  esta' cadastrado          
//
If lRet
	If nPosI > 0
		If ! Empty(aCols[n][nPosI])
			If ! ExistCpo("QM3",aCols[n][nPosI])
				lRet := .f.
			EndIf
		EndIf       
	Endif
EndIf

Return lRet

/*


Ŀ
Funo	 A040PGrvEs Autor  Wanderley Goncalves    Data  06/01/98 
Ĵ
Descrio  Grava os padroes por escalas								  
Ĵ
 Uso		  QMTA040													  
ٱ


*/
Function A040PGrvEs(cAlias)

Local nx
Local ny
Local nMaxArray := Len(aCols)

dbSelectArea("QMC")

//Ŀ
// Grava o arquivo QMC		   
//
For nX := 1 to nMaxArray
	If ! Empty(aCols[nX][nPosPdr]) // Cod. Escala nao vazio
		If !Acols[nX][Len(aCols[nX])] // Nao esta deletado
			If dbSeek(xFilial("QMC") + QM9->QM9_ESCALA + QM9->QM9_REVINV + aCols[nX][nPosPdr])
				RecLock("QMC",.F.)   // Lock
			Else
				RecLock("QMC",.T.)   // Append
			Endif
			For ny := 1 to Len(aHeader)
				If aHeader[ny][10] # "V"
					cVar := Trim(aHeader[ny][2])
					Replace &cVar. With aCols[nx][ny]
				Endif
			Next ny
			QMC->QMC_FILIAL := xFilial("QMC")      
			QMC->QMC_ESCALA := QM9->QM9_ESCALA
			QMC->QMC_REVESC := QM9->QM9_REVESC
			QMC->QMC_REVINV := Inverte(QMC->QMC_REVESC)
			MsUnlock()
		Else
			//Ŀ
			// Cancela o padrao no QMC				  
			//
			If dbSeek(xFilial("QMC") + QM9->QM9_ESCALA + QM9->QM9_REVINV + aCols[nX][nPosPdr])        
				dbSelectArea("QM7")
				dbSetOrder(2)
				If ! dbSeek(cFilial+QMC->QMC_ESCALA+QMC->QMC_REVESC+QMC->QMC_PADRAO)
					RecLock("QMC",.F.,.T.)
					dbDelete()
					MsUnLock()
				EndIf
				dbSelectArea("QMC")              
			EndIf
		EndIf
	EndIf
Next nx

Return .T.

/*
antigo A040PVlPs


Ŀ
Funo	 qmt040VlPs Autor  Wanderley Goncalves    Data  06/01/98 
Ĵ
Descrio  Valida campo de Padrao									  
Ĵ
 Uso		  QMTA040 - E' chamada no X3_VALID do cpo. QMC_PADRAO - SX3  
ٱ


*/
Function qmt040VlPs()
Local lRetu := .t.
Local nI
Local cVar := &(readvar()) // Conteudo da variavel do campo Escala
Local cTolMin
Local nDTol := ASCAN(aHeader,{|x| alltrim(x[2]) = "QMC_TIPTOL"})
Local nLinCnt := 0 

//Ŀ
// Verifica se mudou o Padrao (Alterou o campo ja' digitado)      
//
If !Empty(aCols[n][nPosPdr]) .and. !Empty(cVar) .and. aCols[n][nPosPdr] <> cVar
	Help(" ",1,"NAOALTERA") // Campo nao pode ser alterado   
	lRetu := .f.
EndIf

If lRetu
	//Ŀ
	// Verifica se o Padrao cadastrado
	//
	cColAnt			:= aCols[n][nPosPdr] 
	cTolAnt			:= aCols[n][nPosTol]
	cTolMin			:= aCols[n][nPosTMin]	
	aCols[n][nPosPdr] := M->QMC_PADRAO
	If ! ExistCpo("QM3",aCols[n][nPosPdr])
		aCols[n][nPosPdr] := cColAnt
		lRetu := .f.
	EndIf
	
	//Ŀ
	// Verifica se a unidade de medida  a mesma da escala. 
	// Se for, devolve a tolerancia.                        
	//
	
	QM3->(DbSetOrder(1))
	If QM3->(DbSeek(xFilial("QM3")+aCols[n][nPosPdr]))
		If lRetu
			If !Empty(QM3->QM3_VALDAF)
				If dDataBase > QM3->QM3_VALDAF
					MsgStop(STR0072,STR0073)
					aCols[n][nPosPdr] := CriaVar("QMC_PADRAO",.T.)
					lRetu := .F.
				Endif		
			Endif
		Endif
		If lRetu
			// Verifica se possuem a mesma unidade de medida e se padrao nao e do tipo atributo
			If QM9->QM9_UNIMED <> QM3->QM3_UNIMED .and. QM3->QM3_TIPPAD <> "A"
				DbSelectArea("SAP")
				dbSetOrder(01)
				If !(dbSeek(xFilial("SAP")+QM3->QM3_UNIMED+QM9->QM9_UNIMED))
					lRetu := .f.
					Help(" ",1,"A040UNIMED") // "Padrao nao pode ser associado a escala, pois possui unidade de medida diferente")
					                          // "Cadastre a conversao."
				Endif
			EndIf
		EndIf
	EndIf
EndIf

// Ajustando tamanho dos campos pseudonumricos
aeval(aCols,{|x| nLinCnt++, aCols[nLinCnt,nPosTol] := PadL(x[nPosTol],TAMSX3("QMC_TOLER")[1]," "), aCols[nLinCnt,nPosTMin] := PadL(x[nPosTMin],TAMSX3("QMC_TOLMIN")[1]," ")})

If lRetu
	If Empty(Alltrim(QM3->QM3_TOLER))
		aCols[n][nPosTol]	:= Space(10)	
	Else
		aCols[n][nPosTol]	:= QM3->QM3_TOLER
	Endif
	If Empty(Alltrim(QM3->QM3_TOLMIN))
		aCols[n][nPosTMin]	:= Space(10)
	Else
		aCols[n][nPosTMin]	:= QM3->QM3_TOLMIN	
	Endif
	aCols[n][nDTol]		:= QM3->QM3_TIPTOL
	//Ŀ
	// Verifica se o Padrao ja' existe                 
	//
	For nI := 1 to len(aCols)
		If cVar == acols[nI][nPosPdr] .and. nI != n .and.;
			aCOLS[nI][Len(aCols[nI])] == .F. // Se ja' existir este padrao sec.
			Help(" ",1,"A040EXIPAD") // "Padrao j relacionado a esta Escala"
			aCols[n][nPosPdr] 	:= cColAnt
			aCols[n][nPosTol]	:= cTolAnt
			aCols[n][nPosTMin] := cTolMin			
			lRetu 				:= .f.
			Exit
		EndIf
	Next nI
EndIf

Return(lRetu)

/*

Ŀ
		Funes para controle de Cadastro de Padres Secundrios 		  
ٱ





Ŀ
Funo	  A040Pase  Autor  Wanderley Goncalves    Data  06/01/98 
Ĵ
Descrio  Cadastra Tipos Secundarios para Escalas					  
Ĵ
Sintaxe	  A040Pase(ExpC1,ExpN1,ExpN2)								  
Ĵ
Parametros ExpC1 = Alias do arquivo									  
			  ExpN1 = Numero do registro 								  
			  ExpN2 = Opcao selecionada no menu						  
Ĵ
 Uso		  QMTA040													  
ٱ


*/

FUNCTION A040Pase(cAlias,nReg,nOpcx)

Local nCnt
Local nSavRec
Local nOpca    :=0
Local nRecNc
Local lInclui  := .f.
Local oDlg
Local lGravaOk := .T.
Local cCampo   := ""  // Auxiliar para geracao de macros
Local cSeek
Local cWhile

Private oGetSec  // Getdados Secundaria
Private nPos	 := 0

//Ŀ
// So NO podero cadastrar tipos secundrios as seguintes  
// situaes: 												 
// - Campo QM9_INSUTI	  (Grava ou no Instrumento			 
// Utilizado) est "S"   para os Tipos Simples(1), Comple-  
// to(2), Pressao(3), Soma(5) e Relogio(9)					 
// - SEMPRE para os tipos calibrador(4) e calibrador com-	 
//	pleto(8).												 
// - NUNCA para o tipo Folga e Luz(7).	 					  
// - Tipo Faixa(6) a ser definido. 						  
//


If QM9->QM9_TIPAFE $  "6,7" .or.;
	QM9->QM9_INSUTI = "S" .and.;
	QM9->QM9_TIPAFE $ "1,2,3,5,9"  
			Help(" ",1,"A040NCAPAS")  // Tipo nao permite cadastramento de padro        
											  // secundrio ou campo Usa Inst.Ut. est pre-
											  // enchido com "S".
	Return(nOpca)
EndIf

//Ŀ
// Verifica se ha' padroes sec ja' existentes para a escala 
//
dbSelectArea("QMH")
nSavRec := QMH->(RecNo())
dbSeek( xFilial()+QM9->QM9_ESCALA )

nRecNc := QMH->(RecNo())
nCnt := 0
While !EOF() .And.;
		QMH->QMH_ESCALA == QM9->QM9_ESCALA .and.;
		QMH->QMH_FILIAL == xFilial("QMH")
	nCnt++
	dbSkip()
End
lInclui := Iif(nCnt==0,.t.,.f.)
dbGoto(nRecNc)

//Ŀ
// Monta a entrada de dados do arquivo							 
//
Private aHeader  := {}
Private Continua := .F.
Private nOpc     := 4
Private nUsado   := 0

//Ŀ
// Salva a integridade dos campos de Bancos de Dados 			 
//
dbSelectArea("SX2")  // Posiciona pq. rotinas internas utilizam inf. do SX2
dbSetOrder(1)
dbSeek("QMH")

dbSelectArea("QMH")
dbGoto(nRecNc)

cSeek  := QMH_FILIAL+QMH->QMH_ESCALA
cWhile := "QMH_FILIAL+QMH->QMH_ESCALA"

If lInclui
	FillGetDados(nOpc,"QMH" ,1     ,       ,             ,         ,         ,          ,        ,      ,        ,lInclui,          ,        ,          ,           ,            ,)
  //FillGetDados(nOpc,Alias ,nOrdem,cSeek  ,bSeekWhile   ,uSeekFor ,aNoFields,aYesFields,lOnlyYes,cQuery,bMontCols,lEmpty ,aHeaderAux,aColsAux,bAfterCols,bBeforeCols,bAfterHeader,cAliasQry
Else
	FillGetDados(nOpc,"QMH",1     ,cSeek   ,{|| &cWhile},         ,         ,          ,        ,      ,        ,       ,          ,        ,          ,           ,            ,)
  //FillGetDados(nOpc,Alias ,nOrdem,cSeek  ,bSeekWhile  ,uSeekFor ,aNoFields,aYesFields,lOnlyYes,cQuery,bMontCols,lEmpty ,aHeaderAux,aColsAux,bAfterCols,bBeforeCols,bAfterHeader,cAliasQry
EndIf

nUsado := Len(aHeader)

Continua 	:= .F.
nOpca 		:= 0

DEFINE MSDIALOG oDlg TITLE OemtoAnsi(STR0012) From 9,0 To 28,80 OF oMainWnd // "Escala" 
	oDlg:lMaximized := .F.	
	@ 1.1 , .5	SAY OemToAnsi(STR0012) //"Escala"
	@ 1.1 , 4  SAY QM9->QM9_ESCALA    

	oGetSec := MSGetDados():New(41,5,130,315,nOpcx,"Qmt040TOk","AllwaysTrue",,.T.,,,,999)

ACTIVATE MSDIALOG oDlg ON INIT EnchoiceBar(oDlg,{||nOpca:=1,;
	If(oGetSec:TudoOk(),(nOpca := 1,oDlg:End()),nOpca:=0)},;
	{||nOpca:=0,oDlg:End()})
	
//Ŀ
// Verifica qual a posicao do campo PADSEC no Header 		   
//
nPos := ASCAN(aHeader,{|x|x[2] = "QMH_PADSEC"})

If nOpcA == 1 
	Begin Transaction
		lGravaOk := A040grves(cAlias)
		If !lGravaOK 
			Help(" ",1,"A040NAOGRV")
		Else	
			//Processa Gatilhos
			EvalTrigger()
		EndIf 
	End Transaction
Endif

dbSelectArea(cAlias)

Return nOpca

/*
antigo a040LinOk


Ŀ
Funo	 Qmt040lOk  Autor  Wanderley Goncalves    Data  06/01/98 
Ĵ
Descrio  Critica se a linha digitada esta' Ok                       
Ĵ
Parametros ExpC1 = Objeto a ser verificado. 						  
Ĵ
 Uso		  Qmta040													  
ٱ


*/

Function Qmt040lOk(o)

Local nx, lRet := .T.

nPos := ASCAN(aHeader,{|x|x[2] = "QMH_PADSEC"})
//Ŀ
// Se deixar a ultima linha em branco, deleta a mesma 
//
If Empty(aCols[Len(aCols),1]) .And. n > 1
	Adel( aCols, Len(aCols) )
	ASize( aCols, Len( aCols) - 1)
	n := Len( aCols )
	oGetSec:oBrowse:Refresh()
EndIf

//Ŀ
// Verifica se campo escala esta' preenchido                   
//
For nx := 1 To Len(aHeader)

	If Empty(aCols[n][nx])
		If Trim(aHeader[nx][2]) == "QMH_PADSEC" 
			Help(" ",1,"QA_CPOOBR")
			lRet := .F.
			Exit
		Endif

		If !lRet
			Exit
		Endif
	Endif
Next nx

//Ŀ
// Verifica se o padrao secundrio esta' cadastrado
//

If lRet
	If ! Empty(aCols[n][nPos])
		If ! ExistCpo("QM1",aCols[n][nPos])
			lRet := .f.
		EndIf
	EndIf
EndIf
Return lRet

/*


Ŀ
Funo	 A040GrvEs  Autor  Wanderley Goncalves    Data  06/01/98 
Ĵ
Descrio  Grava os padroes secundarios por escalas					  
Ĵ
 Uso		  QMTA040													  
ٱ


*/
Function A040GrvEs(cAlias)

Local nx
Local ny
Local nMaxArray := Len(aCols)

dbSelectArea("QMH")

//Ŀ
// Grava o arquivo QMH 	   
//
For nX := 1 to nMaxArray
	If ! Empty(aCols[nX][nPos]) // Cod. Escala nao vazio
		If !Acols[nX][nUsado+1] // Nao esta deletado
			If dbSeek(xFilial('QMH') + QM9->QM9_ESCALA + aCols[nX][nPos])
				RecLock("QMH",.F.)   // Lock
			Else
				RecLock("QMH",.T.)   // Append
			Endif
			For ny := 1 to Len(aHeader)
				If aHeader[ny][10] # "V"
					cVar := Trim(aHeader[ny][2])
					Replace &cVar. With aCols[nx][ny]
				Endif
			Next ny
			QMH->QMH_FILIAL := xFilial('QMH')      
			QMH->QMH_ESCALA := QM9->QM9_ESCALA
			MsUnlock()
		Else
			//Ŀ
			// Cancela o padrao no QMH				  
			//
			If dbSeek(xFilial('QMH') + QM9->QM9_ESCALA + aCols[nX][nPos])        
				RecLock("QMH",.F.,.T.)
				dbDelete()
				MsUnlock()
			EndIf
		EndIf
	EndIf
Next nx

Return .T.

/*


Ŀ
Funo	  A040VlPs  Autor  Wanderley Goncalves    Data  06/01/98 
Ĵ
Descrio  Valida campo de Padrao Secundario						  
Ĵ
 Uso		  QMTA040 - E' chamada no X3_VALID do cpo. QMH_PADSEC - SX3  
ٱ


*/
Function A040VlPs()
Local lRetu := .T.
Local nI
Local aColsAnt
Local cVar := &(readvar()) // Conteudo da variavel do campo Escala
		
npos:= ASCAN(aHeader,{|x|x[2] = "QMH_PADSEC"})
//Ŀ
// Verifica se mudou o Padrao Secundario (Alterou o campo ja' digitado) 
//
If !Empty(aCols[n][nPos]) .and. !Empty(cVar) .and. aCols[n][nPos] <> cVar
	Help(" ",1,"NAOALTERA") // Campo nao pode ser alterado   
	lRetu := .F.
EndIf


If lRetu
	//Ŀ
	// Verifica se o Padrao Secundrio esta' cadastrado
	//
	aColsAnt 		:= aCols[n][nPos]
	aCols[n][nPos] := M->QMH_PADSEC
	If ! ExistCpo("QM1",aCols[n][nPos])
		lRetu := .F.
	EndIf
EndIf

If lRetu
	//Ŀ
	// Verifica se o Padrao Secundrio ja' existe      
	//
	For nI := 1 to len(aCols)
		If cVar == acols[nI][nPos] .and. nI <> n .and.;
		aCOLS[nI][nUsado+1] == .F.// Se ja' existir este padrao sec.
				Help(" ",1,"A040EXIPSE") // "Padrao Secundario j relacionado a esta Escala"
		   		aCols[n][nPos] := aColsAnt
				lRetu := .F.
		
		EndIf
	Next nI
EndIf                             

Return(lRetu)

/*


Ŀ
Funo	  A040Soma  Autor  Wanderley Goncalves    Data  08/01/98 
Ĵ
Descrio  Abre tela para cadastro de Pontos para Tipo Soma			  
Ĵ
 Uso		  QMTA040									  				  
ٱ


*/
Function A040Soma()

//Ŀ
// Cria array de trabalho 										 
//
MontaArray()

Return(Nil)

/*


Ŀ
Funo	 MontaArray Autor  Wanderley Goncalves    Data  09.01.98 
Ĵ
Descrio  Monta Array dos Pontos do Tipo Soma 						  
Ĵ
Sintaxe	  MontaArray(void)											  
Ĵ
Parametros 															  
Ĵ
 Uso		  Genrico 												  
Ĵ
 ATUALIZACOES SOFRIDAS DESDE A CONSTRUCAO INICIAL. 					  
Ĵ
 PROGRAMADOR   DATA    BOPS 	MOTIVO DA ALTERACAO					  
Ĵ
Iuri Seto     25/09/00  --	 Alteracao do Especificado e Tolerancia  
                          	 do oGetSoma de inteiro para decimal.    
ٱ


*/
STATIC Function MontaArray()

Local aAlter    := {}
Local aRecQMA   := {} //Usado para armazenar o Alias e Recno do QMA para o Walk Thru
Local cEspec    := ""
Local cKey	    := ""
Local cTamEsc   := GetNewPar("MV_QDECPAD","1") //Considerar o tamanho de casas decimais do padrao
Local cTipQMA   := ""
Local cTolMin   := ""
Local lExistCal := .F.
Local lRet	    := .F.
Local lUniGual  := .T.
Local nCoef	    := 1
Local nDec      := 0
Local nDecMa    := 0
Local nDecMi    := 0
Local nI        := 0
Local nX	    := 0
Local oFnt      := Nil

Private aTabela    := {} // Array dos Pontos
Private aTabPad    := {} // Array contendo os padroes de todas os pontos
Private cFaixa     := ""
Private lAbandona  := .t.
Private oDlgEscala := Nil 
Private oGetSoma   := Nil

dbSelectArea("QMA")
dbSetOrder(1)
nSavRec := RecNo()
dbSeek( xFilial("QMA")+QM9->QM9_ESCALA+QM9->QM9_REVESC )

nRecNc := RecNo()

Do While !QMA->(EOF()) .And. xFilial("QMA")+QM9->QM9_ESCALA+QM9->QM9_REVESC ==;
	QMA->QMA_FILIAL+QMA->QMA_ESCALA+QMA->QMA_REVESC
	cFaixa := QMA->QMA_FAIXA
	cToler := ""
	cTolMin:= ""
	nEspec := 0
    If lTamSom
	    nDec   := 0	
	Endif

	Do While !QMA->(EOF()) .And. QMA->QMA_FILIAL+QMA->QMA_ESCALA+QMA->QMA_REVESC+QMA->QMA_FAIXA == ;
			xFilial('QMA')+QM9->QM9_ESCALA+QM9->QM9_REVESC+cFaixa
      lUniGual := .T.
		QM3->(DbSetOrder(1))

		If QM3->(DbSeek(xFilial('QM3') + QMA->QMA_PADRAO))
		   dbSelectArea("SAP")
		   dbSetOrder(1)
		   If QM3->QM3_UNIMED <> QM9->QM9_UNIMED
				If !dbSeek(xFilial("SAP")+QM3->QM3_UNIMED+QM9->QM9_UNIMED)
					Help(" ",1,"A140UNIDIF")
				Else
					nCoef := SAP->AP_COEF
					lUniGual := .F.
				Endif		   
		   Else
		   	nCoef := 1
		   Endif
		
			Aadd(aTabPad,{QM3->QM3_PADRAO,;
				  IIf(lUniGual,QM3->QM3_ESPEC ,Alltrim(StrTran(Str(SuperVal(QM3->QM3_ESPEC)*nCoef),".",","))),; 
				  IIf(lUniGual,QM3->QM3_TOLMIN,Alltrim(StrTran(Str(SuperVal(QM3->QM3_TOLMIN)*nCoef),".",","))),;
				  IIf(lUniGual,QM3->QM3_TOLER ,Alltrim(StrTran(Str(SuperVal(QM3->QM3_TOLER)*nCoef),".",","))),;
				  IIf(lUniGual,QM3->QM3_UNIMED,QM9->QM9_UNIMED),;
				  QMA->QMA_FAIXA,; 
				  QMTCbox("QMA_TIPTOL",QMA->QMA_TIPTOL),QM3->(Alias()),QM3->(Recno()),;
				  .F.})
			
			nEspec += SuperVal(QM3->QM3_ESPEC)*nCoef
			If !lUniGual
				If Alltrim(cTamEsc) == "1"
					If !Empty(QM9->QM9_ESCALI)
						nDec := QA_NUMDEC(QM9->QM9_ESCALI)
					Else
						nDec := QA_NUMDEC(QM3->QM3_ESPEC)+QA_NUMDEC(StrTran(Str(nCoef),".",","))
					Endif
				Else 
					nDec := QA_NUMDEC(QM3->QM3_ESPEC)				
				Endif
				cToler := Iif(SuperVal(QMA->QMA_TOLER)*nCoef > SuperVal(cToler)*nCoef,;
					QMA->QMA_TOLER,cToler) 
				cTolMin := Iif(SuperVal(QMA->QMA_TOLMIN)*nCoef > SuperVal(cTolMin)*nCoef,;
					QMA->QMA_TOLMIN,cTolMin)					
			Else
				nDec := If(nDec>QA_NUMDEC(QM3->QM3_ESPEC),nDec,;
								QA_NUMDEC(QM3->QM3_ESPEC))
				cToler := Iif(SuperVal(QMA->QMA_TOLER) > SuperVal(cToler),;
								QMA->QMA_TOLER,cToler)
				cTolMin := Iif(SuperVal(QMA->QMA_TOLMIN) > SuperVal(cTolMin),;
								QMA->QMA_TOLMIN,cTolMin)
			Endif	
		EndIf
		
		If lTamSom
			nDecMa	:= QA_NUMDEC(QMA->QMA_TOLER)
			nDecMi	:= QA_NUMDEC(QMA->QMA_TOLMIN)
			cToler := Str(SuperVal(cToler),TamSx3("QMA_TOLER")[1],nDecMa)
			cToler := StrTran(cToler,'.',',')		
			cTolMin := Str(SuperVal(cTolMin),TamSx3("QMA_TOLMIN")[1],nDecMi)
			cTolMin := StrTran(cTolMin,'.',',')		
		Else		
			cToler := Str(SuperVal(cToler),TamSx3("QMA_TOLER")[1],nDec)
			cToler := StrTran(cToler,'.',',')		
			cTolMin := Str(SuperVal(cTolMin),TamSx3("QMA_TOLMIN")[1],nDec)
			cTolMin := StrTran(cTolMin,'.',',')		
    	Endif
		cTipQMA := QMTCbox("QMA_TIPTOL",QMA->QMA_TIPTOL)
		
		aAdd(aRecQMA,{QMA->(Alias()),QMA->(Recno())})
		
		QMA->(DbSkip())
	EndDo

	cEspec := Str(nEspec,TamSx3("QM3_ESPEC")[1],nDec)
	cEspec := StrTran(cEspec,'.',',')
	
	If Alltrim(SubStr(cEspec,1,1)) == "*" 
		cEspec := Str(nEspec,TamSx3("QM3_ESPEC")[1],nDec-1)
		cEspec := StrTran(cEspec,'.',',')
	Endif
	//Ŀ
	// Adiciona no array aTabela para mostrar no browse 
	//
	Aadd(aTabela,{cFaixa,cEspec,cTolMin,cToler,QM3->QM3_UNIMED,cTipQMA,;
	aRecQMA[Len(aRecQMA)][1],aRecQMA[Len(aRecQMA)][2]})
	
EndDo

nRecNc := RecNo()

dbSelectArea("QMA")
dbSetOrder(1)
If dbSeek(xFilial("QMA")+QM9->QM9_ESCALA)
	While QMA->(!Eof()) .and. QMA->QMA_ESCALA == QM9->QM9_ESCALA
		If QMA->QMA_REVESC >= QM9->QM9_REVESC
			lExRev := .T.
			Exit
		Endif
		dbSelectArea("QMA")
		dbSkip()
	Enddo
Endif
If lExRev  
	lExRev := .F.
	dbSelectArea("QM7")
	dbSetOrder(1)
	cKey   := "QM7_FILIAL+QM7_ESCALA+QM7_PONTO"
	cQuery := "SELECT QM7.QM7_FILIAL,QM7.QM7_ESCALA,QM7.QM7_PONTO,QM7.QM7_REVESC "
	cQuery += "FROM " + RetSqlName("QM7")+" QM7 "
	cQuery += "WHERE QM7.QM7_FILIAL='"+xFilial("QM7")+"' AND "
	cQuery += "QM7.QM7_ESCALA = '"+QM9->QM9_ESCALA+"'  AND "			
	cQuery += "QM7.QM7_REVESC = '"+QM9->QM9_REVESC+"'  AND "				
	cQuery += "QM7.D_E_L_E_T_ = ' ' "
	cQuery += " ORDER BY " + SqlOrder(cKey)

	dbUseArea(.T., "TOPCONN", TCGenQry(,,cQuery),"QM7TRB", .F., .T.)

	While !QM7TRB->(Eof())
		lExRev  := .T.
		Exit
	Enddo	

	QM7TRB->(dbCloseArea())	
Endif
dbSelectArea("QMA")
dbGoTo(nRecNc)
If (Len( aTabela ) == 0)
	Aadd(aTabela,{ Space(TamSx3("QMA_FAIXA")[1]),0,;
		0,0, Space(TamSx3("QM3_UNIMED")[1]),Space(TamSx3("QMA_TIPTOL")[1]),;
		QMA->(Alias()),0})
EndIf

//Ŀ
// Monta aHeader para a Getdados sem se basear no SX3 
//
Private aHeader := {}
AADD(aHeader,{OemToAnsi(STR0010) ,"VAR01","@!",10,0,; //"Ponto"
	"PontosWin(aTabPad,oGetSoma,@cFaixa,'P')","","C",;
	"TRB","V"})
	
AADD(aHeader,{OemToAnsi(STR0025) ,"VAR02","@!",;  //"@E 999,999,999.9999",; Especificado
	10,4,".t.","","N","TRB","V"})
If !lTamSom	
	AADD(aHeader,{OemToAnsi(STR0064)  ,"VAR03","@!",;     //"@E 999,999,999.9999",; Toler.Minima
		10,4,"M->VAR03 >= aCols[n][3] .And. PontosWin(aTabPad,oGetSoma,@cFaixa,'T')",;
		"","N","TRB","V"})
		
	AADD(aHeader,{OemToAnsi(STR0065)  ,"VAR04","@!",;     //"@E 999,999,999.9999",;  Toler.Maxima
		10,4,"M->VAR04 >= aCols[n][4] .And. PontosWin(aTabPad,oGetSoma,@cFaixa,'T')",;
		"","N","TRB","V"})
Else
	AADD(aHeader,{OemToAnsi(STR0064)  ,"VAR03","@!",;     //"@E 999,999,999.9999",; Toler.Minima
		10,4,"PontosWin(aTabPad,oGetSoma,@cFaixa,'T')",;
		"","N","TRB","V"})
		
	AADD(aHeader,{OemToAnsi(STR0065)  ,"VAR04","@!",;     //"@E 999,999,999.9999",;  Toler.Maxima
		10,4,"PontosWin(aTabPad,oGetSoma,@cFaixa,'T')",;
		"","N","TRB","V"})
Endif
AADD(aHeader,{OemToAnsi(STR0066),"VAR05","@!",10,0,".t.","",; //Unidade de Medida
	"C","TRB","V"})
 
AADD(aHeader,{OemToAnsi(STR0067),"VAR06","@!",10,0,".t.","",; //Tipo Calc.Toler
	"C","TRB","V"})
	
// Inclui coluna de registro atraves de funcao generica
ADHeadRec("QMA",aHeader)

Private aCols	:= Array( Len(aTabela), Len(aHeader) )

//Ŀ
// Define quais colunas podem ser editadas 
//
Aadd( aAlter , "VAR03" )
Aadd( aAlter , "VAR04" )

//Ŀ
// Monta aCols com os dados pre-carregados 
//
For nI := 1 to Len(aTabela)
	For nX := 1 to Len(aHeader)
		aCols[nI][nX] := aTabela[nI][nX]
	Next nX
	aAdd(aCols[nI],.F.)
Next nI

DEFINE FONT oFnt NAME "Arial" BOLD

DEFINE MSDIALOG oDlgEscala FROM	80,112 TO 374,671 ;
	TITLE Oemtoansi(STR0015) PIXEL Of GetWndDefault() // "Padres por Escala"
oDlgEscala:lMaximized := .F.
@ 33, 5 TO 50, 120 OF oDlgEscala  PIXEL
@ 37, 14 SAY STR0012 SIZE 26, 7 OF oDlgEscala PIXEL FONT oFnt // "Escala"
@ 37, 68 SAY xPadL(alltrim(QM9->QM9_ESCALA),53) SIZE 53, 7 OF oDlgEscala PIXEL

oGetSoma := MsGetDados():New(52,5,150,275,3,"SomaLinOK","AllwaysTrue",,.T.,aAlter,,,999)
oGetSoma:oBrowse:bDrawSelect := { || VerLin() }

ACTIVATE MSDIALOG oDlgEscala ON INIT EnchoiceBar(oDlgEscala,;
	{|| IIf(lRet := SomaLinOk(),oDlgEscala:End(),.F.)},{|| oDlgEscala:End()})

If lRet //Caso confirme, grava os dados da Escala

	QMTA040AuxClass():marcaComoDeletadaALinhaDoArrayAuxiliarDePadroesSeNaoHouverCalibracao(aCols, @aTabPad, QM9->QM9_ESCALA, QM9->QM9_REVESC)

	a040Grava()
EndIf

oFnt:End()
	
Return NIL

/*


Ŀ
Funo	  A040Pict  Autor  Wanderley Goncalves    Data  16/01/98 
Ĵ
Descrio  Define a picture do campo de tolerancia a partir do numero 
			  de casas decimais definidas no campo Especificado		  
Ĵ
Sintaxe	  A040Pict("cCampo")                                         
Ĵ
Parametros ExpC1 = Nome do Campo que tera' a picture a ser definida   
Ĵ
 Uso		  QmtA040													  
ٱ


*/
Function A040Pict(cCampo,cEspec)
Local cPict := ""
Local nTam := TamSx3("QMA_TOLER")[1]
Local nDec := 0

//Ŀ
// Verifica o numero de casas decimais do Nominal 	    
//
nDec := QA_NumDec(cEspec)	 // Valor Nominal 

//Ŀ
// Define a picture a partir do no. casas decimais do Nominal  
//

If nDec == 0
	cPict := "@E "+Replicate('9',nTam)
Else
	cPict := "@E "+Replicate('9',nTam-(nDec+1)) + '.' + Replicate('9',nDec)
EndIf


Return (cPict)

/*
antigo a040TudoOk


Ŀ
Funo	 Qmt040TOk  Autor  Wanderley Goncalves    Data  22/01/98 
Ĵ
Descrio  Critica se toda a getdados esta' Ok                        
Ĵ
Parametros ExpC1 = Objeto a ser verificado. 						  
Ĵ
 Uso		  QMTA040													  
ٱ


*/
Function Qmt040TOk(o)
Local nI
Local lRet := .t.

For nI := 1 to Len(aCols)
	If ! Qmt040lOk(o)
		lRet := .f.
		Exit
	EndIf
Next

Return(lRet)

/*


Ŀ
Funo	 A040PTudOk Autor  Wanderley Goncalves    Data  22/01/98 
Ĵ
Descrio  Critica se toda a getdados esta' Ok                        
Ĵ
Parametros ExpC1 = Objeto a ser verificado. 						  
Ĵ
 Uso		  QMTA040													  
ٱ


*/
Function A040PTudOk(o)
Local nI
Local lRet := .t.                              

For nI := 1 to Len(aCols)
	If ! A040PLinOk(o)
		lRet := .f.
		Exit
	EndIf
Next

Return(lRet)

/*
antigo a040ValNM


Ŀ
Funo	 qmt040VNM  Autor  Wanderley Goncalves Jr Data  30/01/98 
Ĵ
Descrio  Valida numero de medicoes								  
Ĵ
 Uso		  X3_VALID do QM9_NROMED									  
ٱ


*/
Function qmt040VNM()
Local lRet := .t.

If M->QM9_ORGAFE=="I" .and. M->QM9_NROMED = 0
	HELP(" ",1,"A040NMEDOB") // Para orgo calibrador Interno,  obrigatorio
									 // cadastrar medicoes	 
	lRet := .f.
  
ElseIf M->QM9_NROMED = 1 .and. M->QM9_LAUDO $ ('1$2')
	HELP(" ",1,"A040NMED01") // No pode haver uma unica medicao quando 
									 // tipo de Laudo  com Incerteza, pois exis-
									 // tem calculos de mdia.
	lRet := .f.

ElseIf M->QM9_NROMED = 0 .and. M->QM9_LAUDO $ ('1$2')

	HELP(" ",1,"A040OBCAMP") // Como no existiro medies,  obrigatrio 
									 // o preenchimento dos campos incerteza e laudo
									 // dos instrumentos no cadastro de instrumentos.

	//Ŀ
	// Atualiza aTela, porque o Help exibe na tela o valor anterior    
	//
	M->QM9_NROMED := 0

EndIf

Return(lRet)


/*
antigo A040DigTab


Ŀ
Funo    qmt040DiTb Autor  Wanderley Goncalves Jr Data  02/02/98 
Ĵ
Descrio  Cria tabela de laudo 									  
Ĵ
 Uso       QMTA040                                                    
ٱ


*/
Function qmt040DiTb()
/*
Local aLaudo  := {}
Local nOpcA
Local aArea := GetArea()
Local nRepIni, nRepFim, nResIni, nResFim, nAceIni, nAceFim
Local cEsRepr, cEsApRs, cEsAppr
If M->QM9_TABELA == "S"
	
	DbSelectArea("QMQ")
	DbSetOrder(1)

	do while .t.
		aLaudo := {}
		If QMQ->(DbSeek(xFilial('QMQ')+M->QM9_ESCALA+M->QM9_REVESC))
			aadd(aLaudo,{ OemToAnsi(Tabela("QA","REPROV")) ,QMQ->QMQ_REPINI,QMQ->QMQ_REPFIM } )  // Reprovado
			aadd(aLaudo,{ OemToAnsi(Tabela("QA","APREST")) ,QMQ->QMQ_RESINI,QMQ->QMQ_RESFIM } ) // Aprovado com restrio
			aadd(aLaudo,{ OemToAnsi(Tabela("QA","APROV" )) ,QMQ->QMQ_ACEINI,QMQ->QMQ_ACEFIM } ) // Aprovado
			nRepIni := QMQ->QMQ_REPINI
			nRepFim := QMQ->QMQ_REPFIM                    
			nResIni := QMQ->QMQ_RESINI
			nResFim := QMQ->QMQ_RESFIM
			nAceIni := QMQ->QMQ_ACEINI
			nAceFim := QMQ->QMQ_ACEFIM
		Else
			aadd(aLaudo,{ OemToAnsi(Tabela("QA","REPROV")), 0.101, 100.000 } ) // Reprovado
			aadd(aLaudo,{ OemToAnsi(Tabela("QA","APREST")), 0.011,   0.100 } ) // Aprovado com restrio
			aadd(aLaudo,{ OemToAnsi(Tabela("QA","APROV")) , 0.000,   0.010 } ) // Aprovado
			nRepIni := 0.101          
			nRepFim := 100.000
			nResIni := 0.011
			nResFim := 0.100
			nAceIni := 0.000
			nAceFim := 0.010
		EndIf

		cEsRepr := OemToAnsi(Tabela("QA","REPROV"))
		cEsApRs := OemToAnsi(Tabela("QA","APREST"))
		cEsAppr := OemToAnsi(Tabela("QA","APROV"))

		DEFINE MSDIALOG oDlg FROM	21,49 TO 212,408 TITLE OemToAnsi( STR0038 ) PIXEL // "LAUDO"

		@ 0, 4 TO 69, 171 OF oDlg	PIXEL

		@ 8, 119  SAY OemToAnsi( STR0035 ) SIZE 25, 7 OF oDlg PIXEL // "Limite" 
		@ 15, 96  SAY OemToAnsi( STR0036 ) SIZE 25, 7 OF oDlg PIXEL // "Inferior"
		@ 15, 139 SAY OemToAnsi( STR0037 ) SIZE 25, 7 OF oDlg PIXEL // "Superior"
		
		@ 26, 8	 SAY cEsRepr SIZE 76, 7  OF oDlg PIXEL 		
		@ 24, 89  MSGET nRepIni PICTURE "999.999" ;
		VALID  Inferior(@aLaudo, oDlg ) .AND. (oDlg:Refresh(),.t.) ;
		SIZE 37, 10 OF oDlg PIXEL
		
		@ 24, 132 MSGET nRepFim PICTURE "999.999" ;
		VALID Inferior(@aLaudo ) .AND. ( oDlg:Refresh(),.t.);
		SIZE 37, 10 OF oDlg PIXEL

		@ 41, 8	 SAY  cEsApRs SIZE 76, 7  OF oDlg PIXEL
		@ 39, 89  MSGET nResIni PICTURE "999.999" ;
		VALID Inferior(@aLaudo ) .AND. (oDlg:Refresh(),.t.);
		SIZE 37, 10 OF oDlg PIXEL
		
		@ 39, 132 MSGET nResFim PICTURE "999.999" ;
		VALID Inferior(@aLaudo ) .AND. (oDlg:Refresh(),.t.);
		SIZE 37, 10 OF oDlg PIXEL

		@ 56, 8	 SAY cEsAppr SIZE 76, 7  OF oDlg PIXEL
		@ 55, 89  MSGET nAceIni PICTURE "999.999" ;
		VALID Inferior(@aLaudo ) .AND. (oDlg:Refresh(),.t.);
		SIZE 37, 10 OF oDlg PIXEL
		
		@ 55, 132 MSGET nAceFim PICTURE "999.999" ;
		VALID Inferior(@aLaudo ) .AND. (oDlg:Refresh(),.t.);
		SIZE 37, 10 OF oDlg PIXEL

		DEFINE SBUTTON FROM 79,103 TYPE 1 ENABLE OF oDlg Action (nOpca:=1,oDlg:End())
		DEFINE SBUTTON FROM 79,138 TYPE 2 ENABLE OF oDlg Action (nOpca:=0,oDlg:End())
		ACTIVATE MSDIALOG oDlg CENTERED
	
		If nOpcA == 2 // Redigita
			Loop
		ElseIf nOpcA == 1 // Confirma
			If QMQ->(Eof())
				Reclock("QMQ",.T.)  // Append
				QMQ->QMQ_FILIAL := xFilial('QMQ')
				QMQ->QMQ_ESCALA := M->QM9_ESCALA
			Else
				Reclock("QMQ",.F.)  // Lock
			EndIf 
			QMQ->QMQ_REPINI := aLaudo[1,2]
			QMQ->QMQ_REPFIM := aLaudo[1,3]
			QMQ->QMQ_RESINI := aLaudo[2,2]
			QMQ->QMQ_RESFIM := aLaudo[2,3]
			QMQ->QMQ_ACEINI := aLaudo[3,2]
			QMQ->QMQ_ACEFIM := aLaudo[3,3]
			MsUnlock()
		EndIf

		exit

	enddo

endif

RestArea(aArea)
*/
return(.T.)

Function Inferior( aLaudo, oDlg )

Local nI
Local lReturn	 := .T.
Local aLauCopy  := aClone( aLaudo )

For nI := 1 to Len( aLaudo )
	
	If nI > 1 
		aLaudo[nI,3] := aLaudo[nI-1,2] - 0.001
		If aLaudo[nI,3] < 0.000 
			lReturn := .F.
		EndIF
	EndIf
	
	If ( aLaudo[nI,2] >= aLaudo[nI,3] )
		aLaudo[nI,2] := aLaudo[nI,3] - 0.001
		If aLaudo[nI,2] < 0.000 
			lReturn := .F.
		EndIF
	EndIf

Next nI

// Se houver valores negativos, restaura o valor original do array
If ! lReturn
	aLaudo := {}
	aLaudo := aClone( aLauCopy )
EndIf

Return( lReturn )

/*
antigo a040WLaudo


Ŀ
Funo	 qmt040WLau Autor  Wanderley Goncalves Jr Data  04/02/98 
Ĵ
Descrio  Ativa campo ou nao conforme campos anteriores			  
Ĵ
 Uso		  X3_WHEN do QM9_TABELA									  
ٱ


*/
Function qmt040WLau()

If M->QM9_LAUDO $ ('1,2') .or. M->QM9_TIPAFE == '7' 
	Return(.F.)
EndIf

Return(.T.)

/*


Ŀ
Funo	 A040WERRO  Autor  Wanderley Goncalves Jr Data  04/02/98 
Ĵ
Descrio  Ativa campo ou nao conforme campos anteriores			  
Ĵ
 Uso		  X3_WHEN do QM9_TABELA									  
ٱ


*/
Function A040WERRO()

If M->QM9_TIPAFE <> '7' .or. M->QM9_LAUDO $ '3,4,9'
	If M->QM9_TABELA = 'S' 
		Return(OemtoAnsi(STR0040)) // "Em relacao a tabela"
	EndIf
EndIf

Return('')

/*
antigo a040ValErr


Ŀ
Funo	 qmt040VErr Autor  Wanderley Goncalves Jr Data  05/02/98 
Ĵ
Descrio  Valida campo de Percentual de Erro						  
Ĵ
 Uso		  X3_VALID do QM9_PERRO									  
ٱ


*/
Function qmt040VErr()

If (M->QM9_TIPAFE = '7' .or. M->QM9_LAUDO $ '1,2') 
	Return(.F.)
EndIf                   

If M->QM9_PERRO = '3'

	Msgalert(STR0121) // "Selecione uma das opes: 1 = Em relao ao especificado, 2 = Em relacao aos limites"
	Return(.F.)
Endif
/*
If M->QM9_TABELA = 'N' .and. M->QM9_PERRO = '3'
	HELP(" ",1,"A040PERRO") // 'Erro nao pode ser determinado em relacao a tabela'
	Return(.F.)
EndIf
*/

Return(.T.)

/*
antigo A040WTab


Ŀ
Funo	 qmt040WTab Autor  Wanderley Goncalves Jr Data  05/02/98 
Ĵ
Descrio  Permite ou nao a entrada de dados no campo QM9->QM9_PERRO  
Ĵ
 Uso		  X3_WHEN do QM9_PERRO 									  
ٱ


*/
Function qmt040WTab()

If M->QM9_LAUDO $ '12' .or. M->QM9_LAUDO = "7" .or. M->QM9_TABELA = 'S'
	Return(.F.)
EndIf   

Return(.T.)

/*
antigo a040WhTol


Ŀ
Funo	 qmt040WhTo Autor  Wanderley Goncalves Jr Data  06/02/98 
Ĵ
Descrio  Guarda valor real da tolerancia do padrao 				  
Ĵ
 Uso		  X3_WHEN do QMC_TOLER 									  
ٱ


*/
Function qmt040WhTo()

Local nPos 		:= ASCAN(aHeader,{|x| alltrim(x[2]) = "QMC_TOLER" }) 
Local nPosMin	:= ASCAN(aHeader,{|x| alltrim(x[2]) = "QMC_TOLMIN" }) 

nOldTol := aCols[n,nPOS]  //M->QMC_TOLER                          
nOldTMin:= aCols[n,nPosMin]

Return(.T.)

/*


Ŀ
Funo	 A040VTol	 Autor  Wanderley Goncalves Jr Data  06/02/98 
Ĵ
Descrio  Valida valor da Tolerancia digitada 						  
Ĵ
 Uso		  X3_VALID do QMC_TOLER/QMC_TOLMIN							  
ٱ


*/
Function A040VTol()
Local nPosPadd	:=	ASCAN(aHeader,{|x| alltrim(x[2]) = "QMC_PADRAO"})
Local cCampo	:= ReadVar() 
Local nVaTMa
Local nVaTMi

If Alltrim(cCampo) == "M->QMC_TOLER"
	If Valtype(M->QMC_TOLER) == "C"
		nVaTMa := SuperVal(M->QMC_TOLER)
	Else
		nVaTMa := M->QMC_TOLER
	Endif
	If Alltrim(nOldTol) == "" 
		nOldTol	:= "0"
	Endif
	If nVaTMa < SuperVal(nOldTol)
		Help( " ", 1, "A040VTOL" ) // Nova tolerancia no pode ser menor que a anterior
		Return(.f.)
	EndIf
Else 
	If Valtype(M->QMC_TOLMIN) == "C"
		nVaTMi := SuperVal(M->QMC_TOLMIN)
	Else
		nVaTMi := M->QMC_TOLMIN
	Endif
	If Alltrim(nOldTMin) == ""
		nOldTMin := "0"
	Endif
	If nVaTMi < SuperVal(nOldTMin)
		Help( " ", 1, "A040VTOL" ) // Nova tolerancia no pode ser menor que a anterior
		Return(.f.)
	EndIf
Endif	

dbSelectArea("QM3")
dbSetOrder(1)
If dbSeek(xFilial("QM3")+aCols[n][nPosPadd])
	dbSelectArea("QM7")
	dbSetOrder(2)
	If dbSeek(cFilial+QMC->QMC_ESCALA+QMC->QMC_REVESC+aCols[n][nPosPadd])
		MessageDlg(STR0118+Chr(13)+Chr(10)+STR0119,,3) //"Por favor realize a revisao da escala"
		Return .F.
	Endif		
Endif

Return(.T.)

/*


Ŀ
Funo	  A040Jun	 Autor  Alessandro/Fernando G. Data  06.05.98 
Ĵ
Descrio  Monta RadioGroup com selecao para Padrao/Padrao secundario 
Ĵ
Sintaxe	  A040Jun(void)											  
Ĵ
 Uso		  QMTA040													  
ٱ


*/
Function A040Jun(cAlias,nReg,nOpcx)

Local oDlg
Local oRad
Local nItem   := 1
Local nOpc		:= 0
Local oFontDlg := TFont():New("Arial",6,15,.f.,.t.)
Private lTamSom	:= GetMv("MV_QMTPCES")=="1" //Para escalas do tipo soma considerar decimais definida na escala
Private lExRev		:= .F.

DEFINE MSDIALOG oDlg FROM	35,37 TO 140,300 TITLE OemToAnsi(STR0050) PIXEL //"Padres"

@ 05,05 TO 40,80 OF oDlg PIXEL

@ 13, 11 RADIO oRad VAR nItem 3D SIZE 50, 11 ;
			PROMPT OemToAnsi(STR0051),; //"&Ponto"
			OemToAnsi(STR0052) OF oDlg PIXEL //"&Secundrio"

DEFINE SBUTTON FROM 11, 90 TYPE 1 ENABLE OF oDlg Action (nOpc:=1,oDlg:End())
DEFINE SBUTTON FROM 24, 90 TYPE 2 ENABLE OF oDlg Action (nOpc:=0,oDlg:End())

ACTIVATE MSDIALOG oDlg Centered

//Ŀ
// Caso confirmar verifica qual rotina vai chamar 
//
If nOpc == 1
	If nItem == 1
		A040Paes(cAlias,nReg,nOpcx)
	Else
		A040Pase(cAlias,nReg,nOpcx)
	EndIf
EndIf

oFontDlg:End()

Return NIL

/*
antigo a040ValTl


Ŀ
Funo	 qmt040VTl  Autor  Wanderley Goncalves    Data  17.04.98 
Ĵ
Descrio  Valida tipo de laudo conforme selecoes anteriores		  
Ĵ
Sintaxe	  qmt0400VTL(void)											  
Ĵ
 Uso		  QMTA040													  
ٱ


*/

Function qmt040VTL()
Local lRet := .t.

If M->QM9_ORGAFE == "E" .and. Empty(M->QM9_TIPAFE)
	If M->QM9_LAUDO $ "3$4"
	    If M->QM9_NROMED == 0
			Help( " ", 1, "A040TLINV" )  // Tipo de Laudo Invlido para 
			lRet := .f. 				  // Calibrao externa
		Else
			Help( " ", 1, "A040TCLINV" )//Tipo de Calibracao,Laudo e Nro. de Medicoes invalidos para calibracao externa.
			lRet := .f.
		Endif			
	EndIf
EndIf

Return(lRet)

/*


Ŀ
Funo	 SomaLinOk  Autor  Fernando Godoy	     Data  06/05/98 
Ĵ
Descrio  Verifica se a linha da Getdados esta Ok					  
Ĵ
Parametros ExpO1 = Objeto a ser verificado. 						  
Ĵ
 Uso		  Qmta040													  
ٱ


*/
Function SomaLinOk()
Local lRet := .T.

If Empty(aCols[n][1])
	If lExRev
		If Empty(aCols[Len(aCols),1]) .And. n > 1
			Adel( aCols, Len(aCols) )
			ASize( aCols, Len( aCols) - 1)
			n := Len( aCols )
			lRet := .T.
			oGetSoma:oBrowse:Refresh()
		Else
			Help( " ", 1, "JAGRAVADO" )
			MessageDlg(OemToAnsi(STR0070),,3) //"Nao e permitido alterar caracteristicas de pontos/padroes dessa escala. Existe revisao superior"
			lRet := .F.
		Endif
		Return lRet
	Endif
Endif
//Ŀ
// Se deixar a ultima linha em branco, deleta a mesma 
//
If Empty(aCols[Len(aCols),1]) .And. n > 1
	Adel( aCols, Len(aCols) )
	ASize( aCols, Len( aCols) - 1)
	n := Len( aCols )
	lRet := .T.
ElseIf n == 1 .and. Empty(aCols[n][1])
//Ŀ
// Verifica se campo ponto esta' preenchido                    
//
   	Help(" ",1,"QA_CPOOBR")
	lRet := .F.
EndIf

oGetSoma:oBrowse:Refresh()

Return lRet

/*


Ŀ
Funo	 PontosWin  Autor  Fernando Godoy	     Data  06/05/98 
Ĵ
Descrio  Digitao dos pontos.            						  
Ĵ
Parametros Sem parametros.											  
Ĵ
 Uso		  Qmta040													  
Ĵ
 ATUALIZACOES SOFRIDAS DESDE A CONSTRUCAO INICIAL. 					  
Ĵ
 PROGRAMADOR   DATA    BOPS 	MOTIVO DA ALTERACAO					  
Ĵ
Iuri Seto     25/09/00  --	 Alteracao do Especificado e Tolerancia  
                          	 do oGetSoma de inteiro para decimal.    
ٱ


*/
Function PontosWin(aTabPad,oGetSoma,cFaixa,cTipo)

Local aColsSoma	:= Aclone( aCols	 )
Local aHeaderSoma := Aclone( aHeader )
Local nSoma 		:= n
Local nI 			:= 0
Local nE 			:= 0
Local cAux			:= "0"
Local aAlteracao	:= {}
Local lAlterou 	:= .T.
Local lRet			:= .F.
Local aTabShow 	:= {}
Local cMensag		:= ""
Local nTamPadrao	:= 10
Local oDlgPontos
Local oFnt
Local nPos			:= 0
Local nAux			:= 0
Local nDec			:= 0
Local cAuxMin	:= "0"
Local aTipTol :=QMTCombo("QMA_TIPTOL")
Local lAchou := .T.	
Local nLie
Local nLse
Local nLieAnt := -1
Local nLseAnt := -1
Local VAR03 := aCols[n][3]
Local VAR04 := aCols[n][4]
Local aArea 		:= GetArea()
Local lPergs		:= .T.
Local cIndex		:= ""
Local cKey			:= ""
Local cCond			:= ""
Local nIndex		:= 0
Local cToleraMa		:= ""	
Local cToleraMi		:= ""	
Local aAltera		:= {}
Local nX			:= 0
Local nd			:= 0
Private oGetPontos

oGetSoma:oBrowse:lDisablePaint := .T.

//Ŀ
// Verifica se a chamada vem da Tolerncia 
//
If cTipo == "T"
	If lExRev
		cMensag := Oemtoansi(STR0069) //"Confirma Visualizao ?"
	Else
		cMensag := Oemtoansi(STR0055) //"Confirma Alterao ?"	
	Endif	
	cFaixa	:= aCols[n][1]
	cTipGrav:= aCols[n][6]
	cToleraMi:= aCols[n][3]
	cToleraMa:= aCols[n][4]	
Else
	For nI := 1 to Len( aCols )
		If Alltrim(M->VAR01) == Alltrim(aCols[nI][1]) .And. nI <> n
			Tone(3000,1)
			MsgStop(Oemtoansi(STR0056),Oemtoansi(STR0054)) //"Ponto j cadastrado para esse tipo! Informe outro."
			lAlterou := .F.
			lRet		:= .F.
		EndIf
	Next nI
	If lExRev
		cMensag := Oemtoansi(STR0069) //"Confirma Visualizao ?"
	Else
		cMensag := Oemtoansi(STR0057)//"Confirma os dados ?"
	Endif	
	//Ŀ
	// Define a faixa com o aCols atual 
	//
	cFaixa := M->VAR01
EndIf

//Ŀ
// Verifica se Alterou e se o campo faixa esta preenchido. 
//
If !Empty( cFaixa ) .And. lAlterou
	If lExRev
		MsgInfo(OemToAnsi(STR0070),OemToAnsi(STR0071)) //"Nao e permitido alterar caracteristicas de pontos/padroes dessa escala. Existe revisao superior" //"Pontos/Soma"
		aCols[n][3] := cToleraMi
		aCols[n][4] := cToleraMa		
	Endif
 
 	dbSelectArea("QM7")
	dbSetOrder(1)

	cKey   := "QM7_FILIAL+QM7_ESCALA+QM7_PONTO"
	cQuery := "SELECT QM7.QM7_FILIAL,QM7.QM7_ESCALA,QM7.QM7_PONTO,QM7.QM7_REVESC "
	cQuery += "FROM " + RetSqlName("QM7")+" QM7 "
	cQuery += "WHERE QM7.QM7_FILIAL='"+xFilial("QM7")+"' AND "
	cQuery += "QM7.QM7_ESCALA = '"+QM9->QM9_ESCALA+"'  AND "			
	cQuery += "QM7.QM7_REVESC = '"+QM9->QM9_REVESC+"'  AND "				
	cQuery += "QM7.D_E_L_E_T_ = ' ' "
	cQuery += " ORDER BY " + SqlOrder(cKey)

	dbUseArea(.T., "TOPCONN", TCGenQry(,,cQuery),"QM7TRB", .F., .T.)

	While !QM7TRB->(Eof())
		lPergs := .F.
		Exit
	Enddo	

	QM7TRB->(dbCloseArea())	

	RestArea(aArea)
	
	If MsgYesNo(cMensag,Oemtoansi(STR0058)) //"Confirmacao"
		aCols   := {}
		aHeader := {}
		
		nTamPadrao := TamSx3("QMA_PADRAO")[1]
		
		//Ŀ
		// Monta aHeader para a Getdados sem se basear no SX3 
		//
		If !lPergs
			AADD(aHeader,{OemToAnsi(STR0010) ,"QMA_PADRAO","@!",nTamPadrao,0,".f.","",;
				"C","QM3"," "})
			AADD(aHeader,{OemToAnsi(STR0025) ,"PON02","@!",TamSX3("QM3_ESPEC")[1],0,".t.","",;
				"C","QM3","V"})
			AADD(aHeader,{OemToAnsi(STR0064) ,"PON03","@!",TamSx3("QM3_TOLER")[1],0,".T.","",;
				"C","QM3","V"})
			AADD(aHeader,{OemToAnsi(STR0065) ,"PON04","@!",TamSx3("QM3_UNIMED")[1],0,".t.","",;
				"C","QM3","V"})
			AADD(aHeader,{OemToAnsi(STR0066) ,"PON05","@!",TamSx3("QM3_UNIMED")[1],0,".t.","",;
				"C","QM3","V"})
			//Ŀ
			// Define quais colunas podem ser editadas 
			//
			Aadd( aAlteracao, "" )
	    Else
			AADD(aHeader,{OemToAnsi(STR0010) ,"QMA_PADRAO","@!",nTamPadrao,0,"a040Check()","",;
				"C","QM3"," "})
			AADD(aHeader,{OemToAnsi(STR0025) ,"PON02","@!",TamSX3("QM3_ESPEC")[1],0,".t.","",;
				"C","QM3","V"})
			AADD(aHeader,{OemToAnsi(STR0064) ,"PON03","@!",TamSx3("QM3_TOLMIN")[1],0,".T.","",;
				"C","QM3","V"})
			AADD(aHeader,{OemToAnsi(STR0065) ,"PON04","@!",TamSx3("QM3_TOLER")[1],0,".T.","",;
				"C","QM3","V"})
			AADD(aHeader,{OemToAnsi(STR0066) ,"PON05","@!",TamSx3("QM3_UNIMED")[1],0,".t.","",;
				"C","QM3","V"})
			//Ŀ
			// Define quais colunas podem ser editadas 
			//
			Aadd( aAlteracao, "QMA_PADRAO" )
		Endif
		
		// Inclui coluna de registro atraves de funcao generica
		ADHeadRec("QM3",aHeader)
		
		//Ŀ
		// Monta array somente com os ponto da escala utilizada 
		//
		For nI := 1 to len(aTabPad)
			If !Empty(aColsSoma[nSoma,1])
				If alltrim(aColsSoma[nSoma][1]) == alltrim(aTabPad[nI,6]) .and.;
					!aTabPad[nI,Len(aTabPad[nI])] // nao deletado
					Aadd( aTabShow, {aTabPad[nI,1],aTabPad[nI,2],;
						aTabPad[nI,3],aTabPad[nI,4],aTabPad[nI,5],;
						aTabPad[nI,8],aTabPad[nI,9]} ) //,aTabPad[nI,6]
				EndIf
			EndIf
		Next nI
		
		If !Empty( aTabShow )
			aCols  := Array( Len(aTabShow), Len(aHeader))
		Else
			aCols  := {{ Space(nTamPadrao),Space(TamSx3("QM3_ESPEC")[1]),;
				Space(TamSx3("QM3_TOLMIN")[1]),Space(TamSx3("QM3_TOLER")[1]),;
				Space(TamSx3("QM3_UNIMED")[1]),QM3->(Alias()),0,.F. }}
		EndIf
		
		//Ŀ
		// Monta aCols com os dados pre-carregados 
		//
		For nI := 1 to Len(aTabShow)
			For nX := 1 to Len(aCols[nI])
				aCols[nI][nX] := aTabShow[nI][nX]
			Next nX
			aAdd(aCols[nI],.F.)
		Next nI
        
		DEFINE FONT oFnt NAME "Arial" BOLD
		
		//Ŀ
		// Constroi a tela com a getDados 
		//
		DEFINE MSDIALOG oDlgPontos FROM	110,62 TO 414,621 ;
			TITLE Oemtoansi(STR0029) PIXEL Of oDlgEscala // "Padres por ponto"
		
		@ 13, 3 TO 65, 150 OF oDlgPontos  PIXEL
		@ 39, 14 SAY STR0012 SIZE 26, 7 OF oDlgPontos PIXEL FONT oFnt // "Escala"
		@ 39, 44 SAY xPadR(alltrim(QM9->QM9_ESCALA),53) SIZE 56, 7 ;
			OF oDlgPontos PIXEL
		@ 39, 102 SAY STR0024 SIZE 26, 7 OF oDlgPontos PIXEL FONT oFnt // "Ponto"
		@ 39, 120 SAY xPadR(cFaixa,53) SIZE 53, 7 OF oDlgPontos PIXEL
		@ 39, 191 SAY OemToAnsi(STR0059) SIZE 38, 7 OF oDlgPontos PIXEL FONT oFnt // "Tp.Calc.Toler.:"
		@ 37, 235 COMBOBOX oCbxTol VAR cTipTol ITEMS aTipTol ON CHANGE (nTipTol:=oCbxTol:nAt) SIZE 45, 47 OF oDlgPontos PIXEL
        
		oCbxTol:bLostFocus := {||oCbxTol:Disable(),cTipGrav := oCbxTol:aItems[oCbxTol:nat]}
		
		If cTipo == "T" //Qdo da alteracao,nao deixar modificar o combo
			oCbxTol:SetText(cTipGrav)
			oCbxTol:Disable()
		Endif
			
		If lPergs
			oGetPontos := MsGetDados():New(55,3,140,275,3,"SomaLinPo",;
				"AllwaysTrue",,.T.,aAlteracao,,,999)
		Else
			oGetPontos := MsGetDados():New(52,5,140,275,2,".T.",;
				".T.",,.F.,aAlteracao)
		Endif        
			 
		ACTIVATE MSDIALOG oDlgPontos ON INIT EnchoiceBar(oDlgPontos,;
			IIF(!lExRev,{|| lRet:= .T.,SomaLinPo(),oDlgPontos:End()},{|| lRet:= .F.,oDlgPontos:End()}),{|| lRet := .F.,oDlgPontos:End()})
		For nd := 1 To Len(aCols)                              
		    If nd != 1 
		       If Empty(aCols[nd-1][1])
		          lRet := .F.
		       Endif 
		    Endif
			
			If aCols[nd][Len(aCols[nd])]
			    nPosTPad := Ascan( aTabPad, { |x| Alltrim(x[1])+Alltrim(x[2])+Alltrim(x[6]) ==;
			    								   Alltrim(aCols[nd][1])+Alltrim(aCols[nd][2])+Alltrim(aColsSoma[nSoma][1]) } ) 
				If nPosTPad > 0
					aTabPad[nPosTPad][Len(aTabPad[nPosTPad])] := .T.
				Endif	
				
		    Endif
		Next nd

		oFnt:End()
		
		//Ŀ
		// Verifica se o aCols ficou em branco 
		//
		If Empty( aCols[1][1] )                     
			lRet := .F.
		EndIf
		
		If lRet
			nAux := 0
			nDec := 0
			aColsSoma[nSoma][2] := "0"
			
			//Le os registros e procura se o tipo de calculo e numerico. Caso afirma-,
			//tivo, somente ira comparar qual a tolerancia e maior.
			//Caso contrario, devera converter para poder comparar a maior tolerancia

			For nI := 1 To Len(aCols)
				dbSelectArea("QM3")
				dbSetOrder(1)
				If !aCols[nI][Len(aCols[nI])]
					If dbSeek(xFilial("QM3")+aCols[nI][1])
						If nTipTol == 1 .and. nTipTol == Val(QM3->QM3_TIPTOL)
							lAchou := .F.
						Else
							lAchou := .T.
							Exit
						Endif
					Else 
						MessageDlg(STR0053,,3) //Padrao/Ponto nao encontrado
					Endif	
				Endif
			Next nI
			
			For nI := 1 to Len( aCols )
				If !aCols[nI][Len(aCols[nI])] // Soma se nao estiver deletado
					nAux := SuperVal(aColsSoma[nSoma][2]) + SuperVal(aCols[nI][2])
					nLieAnt := -1
					nLseAnt := -1
					For nE := 1 to Len(aCols)
						If !aCols[nE][Len(aCols[nE])] // Considera se nao estiver deletado
							If !lAchou						 
								If SuperVal(aCols[nE][3]) == 0
									cAuxMin := aCols[nE][3]								
								Endif
								If SuperVal(aCols[nE][3]) > SuperVal(cAuxMin)
									cAuxMin := aCols[nE][3]
								EndIf
								
								If SuperVal(aCols[nE][4]) == 0		
									cAux := aCols[nE][4]								
								Endif                   
		
								If SuperVal(aCols[nE][4]) > SuperVal(cAux)
									cAux := aCols[nE][4]
								EndIf
							Else   
								If nE <> 1
									nLieAnt := (SuperVal(aCols[nE-1][2])-(SuperVal(aCols[nE-1][2])*SuperVal(aCols[nE-1][3]))/100)
									nLseAnt := (SuperVal(aCols[nE-1][2])+(SuperVal(aCols[nE-1][2])*SuperVal(aCols[nE-1][3]))/100)														
								Endif
								nLie := (SuperVal(aCols[nE][2])-(SuperVal(aCols[nE][2])*SuperVal(aCols[nE][3]))/100)
								nLse := (SuperVal(aCols[nE][2])+(SuperVal(aCols[nE][2])*SuperVal(aCols[nE][3]))/100)							

        	                	If nLie == 0
	        	                	cAuxMin := aCols[nE][3]
        	                	Endif                      
        	                	If nLie > nLieAnt
            	            		cAuxMin := aCols[nE][3]
                	        	Endif                       
							    
								If nLse == 0
									cAux := aCols[nE][4]								
								Endif 							
							
								If nLse > nLseAnt
                        			cAux := aCols[nE][4]
                        		Endif                                               	
							Endif
					
							If QA_NumDec(aCols[nE][2]) > nDec
								nDec := QA_NumDec(aCols[nE][2])
							EndIf
						EndIf
					Next nE
					aColsSoma[nSoma][2] := StrTran(Str(nAux,TamSX3("QM3_ESPEC")[1],nDec),".",",")
					//Ŀ
					// Inclui os padroes dos pontos. 
					//
					nPoTab := 0
					If cTipo == "P"
						If QM9->QM9_TIPAFE == "5"
							Aadd(aTabPad,{aCols[ni][1],aCols[ni][2],aCols[ni][3],aCols[ni][4],aCols[ni][5],M->VAR01,cTipGrav,QM3->(Alias()),QM3->(Recno()),aCols[ni][Len(aCols[nI])]})
						Else
							Aadd(aTabPad,{aCols[ni][1],aCols[ni][2],aCols[ni][3],aCols[ni][4],aCols[ni][5],M->VAR01,cTipGrav,aCols[ni][Len(aCols[nI])] } )
						Endif
					Else
						nPoTab := Ascan( aTabPad, { |x| Alltrim(x[1]) == Alltrim(aCols[ni][1]) } )
						If nPoTab == 0
							If QM9->QM9_TIPAFE == "5"
								Aadd(aTabPad,{aCols[ni][1],aCols[ni][2],aCols[ni][3],aCols[ni][4],aCols[ni][5],aColsSoma[nSoma][1],cTipGrav,QM3->(Alias()),QM3->(Recno()),aCols[nI][Len(aCols[nI])] } )
							Else
								Aadd(aTabPad,{aCols[ni][1],aCols[ni][2],aCols[ni][3],aCols[ni][4],aCols[ni][5],aColsSoma[nSoma][1],cTipGrav,aCols[nI][Len(aCols[nI])] } )
							Endif
						EndIf
					EndIf			
					// Para deletar
					If !empty(aColsSoma[nSoma][1])
						nPos := Ascan( aTabPad, { |x| Alltrim(x[6])+AllTrim(x[1]) ==;
							  Alltrim(aColsSoma[nSoma][1])+ Alltrim(aCols[nI][1]) } )
					Else
						nPos := Ascan( aTabPad, { |x| Alltrim(x[6])+AllTrim(x[1]) ==;
								  Alltrim(M->VAR01)+ Alltrim(aCols[nI][1]) } )
					EndIf

					If nPos <> 0
						If empty(aColsSoma[nSoma][1])
							aTabPad[nPos,6] := SubStr(M->VAR01,1,nTamQM3)//aCols[nI,5] 
						Else
							aTabPad[nPos,6] := SubStr(aColsSoma[nSoma][1],1,nTamQM3)//aCols[nI,5] 					
						Endif										   
					Else
					   Aadd(aTabPad,{aCols[nI][1],aCols[nI][2],aCols[nI][3],aCols[nI][4],aCols[nI][5],aColsSoma[nSoma][1],cTipGrav,aCols[nI][6]} )
					Endif   
			    Endif
			Next nI
			//Ŀ
			// Verifica se a tolerancia digita  maior que a cadastrada 
			//
			If cTipo == "T"
				If !lExRev
					M->VAR03 := aCols[n][3]					

					If SuperVal(cAuxMin) > SuperVal(M->VAR03)
						M->VAR03 := cAuxMin
					EndIf                   

					M->VAR04 := aCols[n][4]
							
					If SuperVal(cAux) > SuperVal(M->VAR04)
						M->VAR04 := cAux
					EndIf                   				
				Else
					M->VAR03	:= cToleraMi
					M->VAR04	:= cToleraMa	
				Endif	
			Else
				aColsSoma[nSoma][3] := cAuxMin
				aColsSoma[nSoma][4] := cAux
			EndIf
			aColsSoma[nSoma][5] := aCols[1][5]
			aColsSoma[nSoma][6] := cTipGrav
			//Ŀ
			// Inclui a na tabela os novos pontos 
			//
			If cTipo == "P"
				Aadd(aTabela,{M->VAR01,aColsSoma[nSoma][2],aColsSoma[nSoma][3],aColsSoma[nSoma][4],aColsSoma[nSoma][5]})
			EndIf 	  
		EndIf

		//Ŀ
		// Restaura as variaveis para a getdados 
		//
		aCols   := Aclone( aColsSoma )
		aHeader := Aclone( aHeaderSoma )
		n		:= nSoma
	Else
		lRet := .F.
	EndIf
EndIf

Aadd(aAltera,"VAR03")
Aadd(aAltera,"VAR04")
oGetSoma:aAlter := aAltera
oGetSoma:oBrowse:aAlter := aAltera
oGetSoma:oBrowse:lDisablePaint := .F.

Return lRet

/*


Ŀ
Funo	 VerLin 	 Autor  Fernando Godoy 	     Data  06/05/98 
Ĵ
Descrio  Verifica se a linha digitada esta vazia para liberar apenas
			  o primeiro get,  caso contrrio libera apena o Terceiro.   
Ĵ
Parametros Sem parametros.								  			  
Ĵ
 Uso		  Qmta040									  				  
ٱ


*/
Function VerLin()
Local aAlter := {}
	If n == Len(aCols) .And. Empty(aCols[Len(acols),1])
		Aadd( aAlter , "VAR01" )
		oGetSoma:aAlter := aAlter
		oGetSoma:oBrowse:aAlter := aAlter
		oGetSoma:Refresh()
	Else
		Aadd( aAlter , "VAR03" )
		oGetSoma:oBrowse:aAlter := aAlter
		oGetSoma:Refresh()  		
		
		Aadd( aAlter , "VAR04" )
		oGetSoma:oBrowse:aAlter := aAlter
		oGetSoma:aAlter := aAlter
		oGetSoma:Refresh()  		

	EndIf
Return Nil

/*


Ŀ
Funo	 SomaLinPo  Autor  Fernando Godoy	     Data  06/05/98 
Ĵ
Descrio  Verifica se a linha da Getdados esta Ok					  
Ĵ
Parametros ExpO1 = Objeto a ser verificado. 						  
Ĵ
 Uso		  Qmta040													  
ٱ


*/
Function SomaLinPo()
Local aArea := GetArea()
Local lRet := .T.
//Ŀ
// Se deixar a ultima linha em branco, deleta a mesma 
//

If Empty(aCols[Len(aCols),1]) .And. n > 1
	Adel( aCols, Len(aCols) )
	ASize( aCols, Len( aCols) - 1 )
	n := Len( aCols )           
	lRet := .T.
ElseIf n == 1 .and. Empty(aCols[n][1])
//Ŀ
// Verifica se campo ponto esta' preenchido                    
//
   	Help(" ",1,"QA_CPOOBR")
    lRet := .F.                 
EndIf

oGetPontos:oBrowse:Refresh()

RestArea( aArea )

Return lRet

/*


Ŀ
Funo	 a040Check  Autor  Fernando Godoy  	     Data  21/05/98 
Ĵ
Descrio  Verifica se o padrao informado existe no cadastro. 		  
Ĵ
Parametros Sem parametros.								  			  
Ĵ
 Uso		  Qmta040									  				  
ٱ


*/
Function a040Check()

Local lRet	:= .T.
Local aArea := GetArea()
Local nI 	:= 1
Local nCoef := 1
Local nPosQMA		:= ASCAN(aHeader,{|x| alltrim(x[2]) = "QMA_PADRAO"})
dbSelectArea("QM3")
dbSetOrder(1)
If !dbSeek( xFilial("QM3") + M->QMA_PADRAO )
	Tone(3000,1)
	MsgStop(OemtoAnsi(STR0053),OemtoAnsi(STR0054))//Padrao nao encontrado / Atencao
	lRet := .F.
Else
	//Ŀ
	//Verifica se padro ja foi cadastrado 
	//
	If QM3->QM3_TIPPAD == "A"
		MessageDlg(STR0068,,3)//"Para escalas do tipo soma, nao e permitido cadastrar padroes tipo Atributo" 			 
		If nPosQMA <> 0
			aCols[n][nPosQMA] := CriaVar("QMA_PADRAO",.T.)
		Endif	
		lRet := .F.
	Else	
		For nI = 1 to len(aCols)	
			If Alltrim(M->QMA_PADRAO) == Alltrim(aCols[nI][1]) .And. nI <> n
				HELP(" ",1,"A040PACAD")  // "Padro j cadastrado para este Ponto"
				lRet := .F.
				Exit
			EndIf
		Next nI
	Endif	

	If lRet
		If !Empty(QM3->QM3_VALDAF)
			If dDataBase > QM3->QM3_VALDAF
				MsgStop(STR0072,STR0073) //Aviso de padrao vencido
				aCols[n][nPosQMA] := CriaVar("QMA_PADRAO",.T.)
				lRet := .F.
			Endif		
		Endif	
	Endif
	If lRet
		If Len(aCols) > 0  
			For nI := 1 to Len(aCols)
				If Alltrim(QM3->QM3_UNIMED) <> Alltrim(QM9->QM9_UNIMED) 
					dbSelectArea("SAP")
					dbSetOrder(1)
					If !dbSeek(xFilial("SAP")+QM3->QM3_UNIMED+QM9->QM9_UNIMED)
						lRet := .F.
						HELP(" ",1,"A140UNIDIF")
						Exit
					Else 
						nCoef := SAP->AP_COEF
					Endif	
				EndIf
			Next nI
		EndIf
	EndIf
	
	//Ŀ
	// Se tudo estiver Ok inclui no Acols as especificacoes 
	//
	If lRet
		If nCoef <> 1 // Unidades Diferentes
			aCols[n][2] := StrTran(Str(SuperVal(QM3->QM3_ESPEC)*nCoef),".",",")
			aCols[n][3] := StrTran(Str(SuperVal(QM3->QM3_TOLMIN)*nCoef),".",",")
			aCols[n][4] := StrTran(Str(SuperVal(QM3->QM3_TOLER)*nCoef),".",",")			
			aCols[n][5] := QM9->QM9_UNIMED
		Else 
			aCols[n][2] := QM3->QM3_ESPEC
			aCols[n][3] := QM3->QM3_TOLMIN
			aCols[n][4] := QM3->QM3_TOLER
			aCols[n][5] := QM3->QM3_UNIMED					
		Endif	
	EndIf
	
EndIf

RestArea( aArea )

Return lRet

/*


Ŀ
Funo	 a040Grava  Autor  Fernando Godoy		 Data  25/05/98 
Ĵ
Descrio  Grava as informacoes sobre as escalas. 					  
Ĵ
Parametros Sem parametros.							 			      
Ĵ
 Uso		  Qmta040													  
Ĵ
 ATUALIZACOES SOFRIDAS DESDE A CONSTRUCAO INICIAL. 					  
Ĵ
 PROGRAMADOR   DATA    BOPS 	MOTIVO DA ALTERACAO					  
Ĵ
Iuri Seto     25/09/00  --	 Alteracao do Especificado e Tolerancia  
                          	 do oGetSoma de inteiro para decimal.    
ٱ


*/
Static Function a040Grava()
Local nI 	 := 1
Local nPos   := 0
Local nUsado := IIF(Findfunction("A040Soma"),Len(aHeader),0)

IF Findfunction("A040Soma").And. nUsado <> 0 .And. aCols[n][nUsado+1]
	MSGAlert(STR0123) //Caso o cadastro QM3 (padres para calibrao) esteja ativo o registro no ser deletado.
EndIf

dbSelectArea("QMA")
dbSetOrder(1)
For nI := 1 to Len( aTabpad )
	If !dbSeek( xFilial("QMA")+QM9->(QM9_ESCALA+QM9_REVESC) + aTabPad[nI][6] + aTabPad[nI][1] )
		If !aTabPad[nI][Len(aTabpad[nI])]
		   RecLock("QMA",.T.)
		   QMA->QMA_FILIAL := xFilial('QMA')
		   QMA->QMA_ESCALA := QM9->QM9_ESCALA
	 	   QMA->QMA_REVESC := QM9->QM9_REVESC
		   QMA->QMA_FAIXA  := aTabPad[nI][6]
		   QMA->QMA_PADRAO := aTabPad[nI][1]
		   If (nPos:=Ascan( aCols, { |x| Alltrim(x[1]) == Alltrim(aTabPad[nI][6]) } )) > 0
				QMA->QMA_TOLMIN := Alltrim(aCols[nPos][3])
				QMA->QMA_TOLER := Alltrim(aCols[nPos][4])
				QMA->QMA_TIPTOL := SubStr(aCols[nPos][6],1,1)
		   EndIf 
		   MsUnLock()
		Endif
	Else
		If !aTabPad[nI][Len(aTabPad[nI])]
			If (nPos:=Ascan( aCols, { |x| Alltrim(x[1]) == Alltrim(aTabPad[nI][6]) } )) > 0
				RecLock("QMA",.F.)
				QMA->QMA_TOLMIN := Alltrim(aCols[nPos][3]) 
				QMA->QMA_TOLER  := Alltrim(aCols[nPos][4]) 
				MsUnLock()
			EndIf
		Else
			RecLock("QMA",.F.)
			QMA->(DbDelete())
			MsUnlock()
		EndIf
	EndIf
Next nI

N := 1

Return Nil


/*
antigo a040VOrg


Ŀ
Funo	 qmt040VOrg Autor  Wanderley Goncalves    Data  18/06/98 
Ĵ
Descrio  Verifica se deve ser digitado Departamento ou Laboratorio  
			  como Orgao Calibrador, de acordo com o campo destino da	  
			  calibracao, limpando o campo oposto, se necessario.		  
Ĵ
Parametros Sem parametros.											  
Ĵ
 Uso		  Qmta040													  
ٱ


*/
Function qmt040VOrg()

If M->QM9_ORGAFE == 'I'
	M->QM9_LABOR := CriaVar("QM9_LABOR",.T.)
ElseIf M->QM9_ORGAFE == 'E'
	M->QM9_DEPTO := CriaVar("QM9_DEPTO",.T.)
EndIf

Return(.T.)

/*


Ŀ
Funo	  QMA040VIU Autora Iuri Seto              Data  18/08/00 
Ĵ
Descrio  Verif. se a escala esta cad. em um instr. utilizado na cal.
Ĵ
Sintaxe	  QMA040VIU()								  				  
Ĵ
Retorno    .T., e utilizado na cal.; .F., nao e utilizado na cal.	  
Ĵ
Uso		  QMTA040									  				  
ٱ

 
*/
Function QMA040VIU()
Local 	lRet	:= .F.
Local	cIndice := CriaTrab(NIL,.F.)
Local	cChave 	:= "QMI->QMI_FILIAL+QMI->QMI_ESCPAD"   
Local	cExpr	:= "QMI->QMI_FILIAL == '" + xFilial('QMI') + "' .And. QMI->QMI_ESCPAD == '" + QM9->QM9_ESCALA +"'"

IndRegua("QMI",cIndice,cChave,,cExpr,,.F.)
nIndice := RetIndex("QMI")
dbSetOrder(nIndice+1)
dbGoTop()  
If !Eof()
	lRet := .T.
EndIf

dbSelectArea("QMI")
RetIndex("QMI")                      
Set Filter to
Ferase(cIndice + OrdBagExt())
QMI->(DbSetOrder(1))
QMI->(DbGoTop())

Return(lRet)

/*


Ŀ
Funo	  QMA040VPS Autora Iuri Seto              Data  18/08/00 
Ĵ
Descrio  Verif. se a escala esta cad. como padrao secundario na cal.
Ĵ
Sintaxe	  QMA040VPS()												  
Ĵ
Retorno    .T., e utilizado na cal.; .F., nao e utilizado na cal.	  
Ĵ
Uso		  QMTA040													  
ٱ

 
*/
Function QMA040VPS()
Local 	lRet	:= .F.
Local	cIndice := CriaTrab(NIL,.F.)
Local	cChave 	:= "QMS->QMS_FILIAL+QMS->QMS_ESCPAD"   
Local	cExpr	:= "QMS->QMS_FILIAL == '" + xFilial('QMS') + "' .And. QMS->QMS_ESCPAD == '" + QM9->QM9_ESCALA + "'"

IndRegua("QMS",cIndice,cChave,,cExpr,,.F.)
nIndice := RetIndex("QMS")
dbSetOrder(nIndice+1)
dbGoTop()  
If !Eof()
	lRet := .T.
EndIf

dbSelectArea("QMS")
RetIndex("QMS")                      
Set Filter to
Ferase(cIndice + OrdBagExt())
QMI->(DbSetOrder(1))
QMI->(DbGoTop())

Return(lRet)

/*


Ŀ
Funo	  QMA040PRe Autora Iuri Seto              Data  24/08/00 
Ĵ
Descrio  Retorna a proxima revisao disponivel.                      
Ĵ
Sintaxe	  QMA040PRe(ExpC1)											  
Ĵ
Parametros ExpC1 : Escala											  
Ĵ
Retorno    Proxima Revisao da escala.								  
Ĵ
Uso		  QMTA040													  
ٱ

 
*/
Function QMA040PRe(cEscala)
Local	cAlias	:= Select()
Local	cOrdem	:= IndexOrd()
Local	nRegis	:= Recno()
Local	cProxRev:= ""

DbSelectArea("QM9")
QM9->(DbSetOrder(1))
If QM9->(DBSeek(xFilial("QM9")+cEscala))
EndIf

DbSelectArea(cAlias)
DbSetOrder(cOrdem)
DbGoto(nRegis)
Return(cProxRev)

/*/


Ŀ
Funo    QMA040UltR Autora Iuri Seto              Data  28/08/00 
Ĵ
Descrio  Retorna a ultima revisao da escala enviando como parametro.
Ĵ
Sintaxe    QMA040UltR(ExpC1)                                          
Ĵ
Parametros ExpC1 = Codigo da escala                                   
Ĵ
 Uso       QMTA040                                                    
ٱ


/*/
Function QMA040UltR(cEscala)
Local cRevisao 	:= ""            
Local cAlias	:= Select()
Local nOrdem	:= IndexOrd()
Local nRegis 	:= RECNO()

DbSelectArea("QM9")
DbSetOrder(1)
If QM9->(DbSeek(xFilial("QM9")+cEscala))
	cRevisao := QM9->QM9_REVESC
EndIf

DbSelectArea(cAlias)
DbSetOrder(nOrdem)
DbGoto(nRegis)
Return(cRevisao)


/*/


Ŀ
Funo    QMA040DpPa Autora Iuri Seto              Data  14/09/00 
Ĵ
Descrio  Duplica a associacao de padroes.                           
Ĵ
Sintaxe    QMA040DpPa(ExpC1)                                          
Ĵ
Parametros ExpC1 = Revisao do padrao origem                           
Ĵ
 Uso       QMTA040                                                    
ٱ


/*/
Function QMA040DpPa(cRevInv)
Local nRegis
Local bCampo := {|nCPO| Field(nCPO) }
Local i := 0

DbSelectArea("QMC")
DbSetOrder(1)
IF QMC->(DbSeek(xFilial("QMC")+QM9->QM9_ESCALA+cRevInv))
	While !EOF() .And. xFilial("QMC")+QM9->QM9_ESCALA+cRevInv ==;
		QMC->QMC_FILIAL+QMC->QMC_ESCALA+QMC->QMC_REVINV
	
		FOR i := 1 TO FCount()
			M->&(EVAL(bCampo,i)) := FieldGet(i)
		NEXT i
		M->QMC_REVESC := QM9->QM9_REVESC
		M->QMC_REVINV := QM9->QM9_REVINV
		nRegis := Recno()							
									
		RecLock("QMC",.T.)
		For i := 1 TO FCount()
			FieldPut(i,M->&(EVAL(bCampo,i)))
		Next i
		MsUnlock()   
	                    	
		DbGoto(nRegis)
		DbSkip()
	EndDo							
EndIf
Return(Nil)

/*/


Ŀ
Funo    QMA040DpPS Autora Iuri Seto              Data  14/09/00 
Ĵ
Descrio  Duplica a associacao de padroes do tipo soma.              
Ĵ
Sintaxe    QMA040DpPS(ExpC1)                                          
Ĵ
Parametros ExpC1 = Revisao do padrao origem                           
Ĵ
 Uso       QMTA040                                                    
ٱ


/*/
Function QMA040DpPS(cRev)
Local nRegis
Local bCampo := {|nCPO| Field(nCPO) }
Local i := 0

DbSelectArea("QMA")
DbSetOrder(1)
IF QMA->(DbSeek(xFilial("QMA")+QM9->QM9_ESCALA+cRev))
	While !EOF() .And. xFilial("QMA")+QM9->QM9_ESCALA+cRev ==;
		QMA->QMA_FILIAL+QMA->QMA_ESCALA+QMA->QMA_REVESC
         	
		FOR i := 1 TO FCount()
			M->&(EVAL(bCampo,i)) := FieldGet(i)
		NEXT i
		M->QMA_REVESC := QM9->QM9_REVESC
		nRegis := Recno()							
								
		RecLock("QMA",.T.)
		For i := 1 TO FCount()
			FieldPut(i,M->&(EVAL(bCampo,i)))
		Next i
		MsUnlock()   
                 	
		DbGoto(nRegis)
		DbSkip()
	EndDo							
EndIf
Return(Nil)

/*


Ŀ
Funo	 QMA040Cal  Autora Iuri Seto              Data  14/09/00 
Ĵ
Descrio  Verifica se a rev. da escala ja foi utilizada na calibracao
Ĵ
 Uso		  QMTA040													  
ٱ


*/
Function QMA040Cal(cEscala,cRevEsc)
Local 	lRet	:= .F.
DbSelectArea("QM7")
QM7->(DbSetOrder(2))
If QM7->(DbSeek(xFilial("QM7")+cEscala+cRevEsc))
	lRet := .T.
EndIf
Return(lRet)
/*


ͻ
Funcao    QMTCombo      Autor  Denis Martins    Data   08/22/01   
͹
Desc.     Funcao que le o itens do combo no SX3 e retorna num array   
                                                                      
͹
Uso        QMTA040                                                    
ͼ


*/
Function QMTCombo(cCampo)
Local aArea    := GetArea()
Local cBox     := ""
Local aBox     := {}
Local nPosicao1:= 0
Local nPosicao2:= 0
Local cElem1 	:= cElem2:= ""

dbSelectArea("SX3")
dbSetOrder(2)
If ( MsSeek(cCampo) )
	cBox  := x3cbox(cCampo)
	While ( !Empty(cBox) )
		nPosicao1   := At(";",cBox)
		If ( nPosicao1 == 0 )
			nPosicao1 := Len(cBox)+1
		EndIf
		nPosicao2   := At("=",cBox)
		cElem1 := SubStr(cBox,1,nPosicao2-1)
		cElem2 := SubStr(cBox,nPosicao2+1,nPosicao1-nPosicao2-1)
		aadd(aBox,cElem1+' - '+cElem2)
		cBox := SubStr(cBox,nPosicao1+1)
	EndDo
EndIf
dbSelectArea("SX3")
dbSetOrder(1)

RestArea(aArea)
Return(aBox)

/*


Ŀ
Funo	  QMTCBox   Autor  Denis Martins          Data  08/22/01 
Ĵ
Descrio  Retorna String com descricao do combo                      
Ĵ
Sintaxe	  QMTCBox(ExpC1,ExpC2)                              		  
Ĵ
Parametros ExpC1 = Campo a ter o Combo pesquisado                     
           ExpC2 = Conteudo do campo                                  
Ĵ
Uso		  Generico                               					  
ٱ

*/
Function QMTCBox(cCampo, cConteudo)
Local cBox := Posicione("SX3", 2, cCampo, "x3CBox()")
Local nPos := At(cConteudo + "=", cBox)
Local cSub := SubStr(cBox, nPos)
Local nFim := If(";" $ cSub, At(";", cSub) - 1, Len(cSub))
Local cRet := If(nPos=0,"",SubStr(cSub, 1, nFim))
cRet := StrTran(cRet,"="," - ")
Return(cRet)

/*


ͻ
Programa  G040Temp()Autor  Denis Martins        Data   10/01/01   
͹
Desc.     Gera arquivo temporario e grava arquivos auxiliar para veri-
          ficar se a escala corrente podera sofrer alteracao no Tipo  
          de Calibracao.                                              
͹
Uso        QMTA040                                                    
ͼ


*/
Static Function G040Temp()
Local cIndice	:= ""
Local cChave
Local cExpr
Local lRet := .T.
Local aArea := GetArea()
Local nIndice := 0

dbSelectArea("QMK")
dbSetOrder(01)
dbGoTop()

cChave := "SELECT QMK_FILIAL,QMK_ESCALA,QMK_TIPO,QMK_REVTIP"
cChave += " FROM " + RetSqlName("QMK") +" QMK "
cChave += " WHERE QMK.QMK_FILIAL = '"	+ xFilial("QMK") + "' AND "
cChave += " QMK.QMK_ESCALA = '" + M->QM9_ESCALA + "' AND " 
cChave += " QMK.D_E_L_E_T_ = ' ' "

dbUseArea(.T., "TOPCONN", TCGenQry(,,cChave),"TRBMK", .F., .T.)
dbSelectArea("TRBMK")

dbGoTop()  
If Eof()
	lRet := .F.
EndIf

If lRet
	While !Eof()
		IMPTMP->(dbAppend())
		IMPTMP->TMP_FILIAL	:=	TRBMK->QMK_FILIAL 
		IMPTMP->TMP_ESCALA	:=	TRBMK->QMK_ESCALA 
		IMPTMP->TMP_TIPO	:=	TRBMK->QMK_TIPO
		IMPTMP->TMP_REVTIP	:=	TRBMK->QMK_REVTIP		
	dbSkip()
	Enddo
Endif

dbSelectArea("QMK")
RetIndex("QMK")                      
Set Filter to
Ferase(cIndice+OrdBagExt())

If ( Select("TRBMK") != 0 )
    DbSelectArea("TRBMK")
    DbCloseArea()
	FErase("TRBMK"+GetDBExtension()) 
	FErase("TRBMK"+OrdBagExt())
EndIf	

RestArea(aArea)
Return .T.

/*


ͻ
Programa  qmt040Grv Autor  Denis Martins        Data   22/04/02   
͹
Desc.     Realizar gravacao do campo Revisao Invertida apos inclusao  
          da escalas.                                                 
͹
Uso        QMTA040()                                                  
ͼ


*/
Function qmt040grv()

RecLock("QM9",.F.)
Replace QM9->QM9_REVINV with Inverte(QM9->QM9_REVESC,2)
MsUnLock()

Return Nil
/*/


Ŀ
Funao	  QMTA040EnBar Autor  Denis Martins               Data  25/06/03 
Ĵ
Descriao   Monta a Enchoice Bar                                              
Ĵ
Sintaxe	   QMTA040EnBar( oDlg, bOk, bCancel, nOpc )                       	  
Ĵ
Parametros  oDlg        Objeto da Tela que contera a enchoice                
            bOk         Bloco executado quando da confirmacao(Botao Ok)      
            bCancel     Bloco executado quando do cancelamento(Botao Cancela)
            nOpc        Opcao de selecao do aRotina                          
Ĵ
Uso		   QMTA140                                                           
ٱ


/*/
Function QMTA040EnBar( oDlg, bOk, bCancel,nOpc )
Local aButtons := {}
Default nOpc	:= 4
aAdd(aButtons,{"SDUPROP",{|| QMT040AtPadr(.F.,oDlg,nOpc)},OemToAnsi(STR0120),OemToAnsi(STR0074)}) //"Padroes Automaticos"
EnchoiceBar(oDlg,bOk,bCancel,,aButtons)

Return Nil

/*/


Ŀ
Funao	  QMT040AtPadr  Autor  Denis Martins               Data  25/06/03 
Ĵ
Descriao   Gera Padroes Automatico                                            
Ĵ
Sintaxe	   A040AtPadr() 							                      	   
Ĵ
Parametros  lCads       Verifica se vem do cadastro de Padroes                
            oDlg        Janela                                                
Ĵ
Uso		   QMTA040                                                            
ٱ


/*/
Function QMT040AtPadr(lCads,oDlg,nOpc)
Local cCads := STR0074//"Gera Padroes"
Local oDlgPd
Local oGrpPd
Local oGrpIn                
Local oCbx
Local oCbxTT
Local lExEsc	:= .T.
Local nOpca     := 0
Local lRetu     := .T.
Default lCads	:= .F.
Default nOpc	:= 4
Private cDesPUt	:= GetMv("MV_QPDAUT",.F.,"PDAUTO") 
Private cPits
Private oGetFin         
Private oGetIni
Private oGetPas
Private oGetIncer
Private nVlrIni 
Private nVlrFin 
Private cPasso	:= Space(3)         
Private cCbx
Private nTipT	:= 1
Private nTipoTo := 1
Private cIncer	:= CriaVar("QM3_INCERT",.F.)
Private oGetTMa
Private oGetTMI
Private cTolMx	:= CriaVar("QM3_TOLER",.F.)
Private cTolMi	:= CriaVar("QM3_TOLMIN",.F.)
Private oGetUM
Private cUnMi	:= CriaVar("AH_UNIMED",.F.)
Private cCbxTT	:= CriaVar("QM3_TIPTOL",.F.)
Private oGetNCer 
Private cNumCer := CriaVar("QM3_CERTIF",.F.)
Private oGetFAfe
Private nFafe	:= CriaVar("QM3_FREQAF",.F.)
Private oGetDtCal 
Private dDtCals := dDataBase
Private oGetVAfe 
Private dDtAfer := dDataBase
Private oChkPto 
Private lChkPto := .T.
Private lObCad	
Private lPergta	:= .T.

If lCads
	nVlrIni := CriaVar("QM9_ESCALI",.F.)
	nVlrFin := CriaVar("QM9_ESCALF",.F.)
	lObCad	:= .T.
Else
	nVlrIni := M->QM9_ESCALI
	nVlrFin := M->QM9_ESCALF
	cUnMi	:= M->QM9_UNIMED	
	If !(M->QM9_TIPAFE $ "4|8| ")
		lObCad	:= Obrigatorio(aGets,aTela)
	Else
		Help( " ", 1, "A040NPAUT" ) //Nao eh permitido associar padroes para esse tipo de laudo
		lObCad	:= 	.F.
	Endif	
Endif	                                


If lObCad
	
	DEFINE MSDIALOG oDlgPd TITLE cCads FROM 9,0 TO 33,50 OF oMainWnd
	
	@ 2.2,.5 Group oGrpPd TO 5.2,24.3 LABEL STR0075 OF oDlgPd COLOR CLR_BLUE   //"Valores"
	@ 3,1.2	SAY STR0076	OF oDlgPd  //"Inicial"
	@ 3,3.3	MSGET oGetIni VAR nVlrIni	OF oDlgPd  PICTURE PesqPict("QM9","QM9_ESCALF") SIZE 35,7.5 VALID Eval({||QA_ENUM("nVlrIni"),cPits := QA_PICT(,,nVlrIni,nVlrIni,.F.)})  //cCampo,nDecim,nVlIn,nVlFin,lFzPt 
	@ 3,9.5	SAY STR0077	OF oDlgPd  //"Final"
	@ 3,11.6 MSGET oGetFin VAR nVlrFin	OF oDlgPd PICTURE PesqPict("QM9","QM9_ESCALF") SIZE 35,7.5 VALID Eval({||QA_ENUM("nVlrFin")}) 
	@ 3,18.1 SAY STR0078 OF oDlgPd  //"Passo"
	@ 3,20.2 MSGET oGetPas VAR cPasso	OF oDlgPd SIZE 20,7.5 
	@ 55,9 CHECKBOX oChkPto VAR lChkPto SIZE 053,006 OF oDlgPd PROMPT OemToAnsi(STR0116)//"Cria Ponto Inicial"	
	
	@ 5.6,.5 Group oGrpIn TO 12.1,24.3 LABEL STR0079 OF  oDlgPd COLOR CLR_BLUE   //"Informacoes"
	@ 6.5,1.1 SAY STR0080	OF oDlgPd SIZE 20,7.5 	//"Tipo Padrao"
	@ 6.4,5.3 COMBOBOX oCbx VAR cCbx ITEMS {STR0081,STR0082,STR0083} ON CHANGE (nTipT:=oCbx:nAt,qmt040VPadAOS()) SIZE 45, 47 OF oDlgPd //Objetivo # Subjetivo # Atributo
	@ 7.7,1.1 SAY STR0084	OF oDlgPd SIZE 20,7.5 	//6
	@ 7.7,5.3 MSGET oGetIncer VAR cIncer OF oDlgPd PICTURE PesqPict("QM3","QM3_INCERT") SIZE 35,7.5 VALID Eval({||QA_ENUM("cIncer")}) 
	@ 9,1.1 SAY STR0065	OF oDlgPd SIZE 20,7.5 	
	@ 9,5.3 MSGET oGetTMa VAR cTolMx OF oDlgPd PICTURE PesqPict("QM3","QM3_TOLER") SIZE 35,7.5 VALID Eval({||QA_ENUM("cTolMx")}) 
	@ 10.5,1.1 SAY STR0064	OF oDlgPd SIZE 20,7.5 	
	@ 10.5,5.3 MSGET oGetTMi VAR cTolMi OF oDlgPd PICTURE PesqPict("QM3","QM3_TOLMIN") SIZE 35,7.5  VALID Eval({||QA_ENUM("cTolMi")}) 
	@ 11.8,1.1 SAY STR0085	OF oDlgPd SIZE 20,7.5 	
	@ 11.8,5.3 MSGET oGetUM VAR cUnMi OF oDlgPd PICTURE PesqPict("SAH","AH_UNIMED") SIZE 18,7.5  F3 "SAH";	
		VALID Eval( {|| lExEsc := ExistCpo("SAH",cUnMi),If(!lCads,If(lExEsc,QMT040CoUn(cUnMi),.F.),lExEsc)})  
	@ 6.5,13 SAY STR0095	OF oDlgPd SIZE 18,7.5 //Tp.Tolerancia	
	@ 6.4,17.2 COMBOBOX oCbxTT VAR cCbxTT ITEMS {STR0093,STR0094} ON CHANGE (nTipoTo:=oCbxTT:nAt) SIZE 45, 47 OF oDlgPd //Numerico - Percentual

	@ 7.7,13 SAY STR0096 OF oDlgPd SIZE 20,7.5 	//Numero de Certificado
	@ 7.7,17.2 MSGET oGetNCer VAR cNumCer OF oDlgPd PICTURE PesqPict("QM3","QM3_CERTIF") SIZE 35,7.5   
	@ 9,13 SAY STR0097 OF oDlgPd SIZE 20,7.5 //Data de Calibracao
	@ 9,17.2 MSGET oGetDtCal VAR dDtCals OF oDlgPd PICTURE PesqPict("QM3","QM3_DATAF") SIZE 40,7.5  
	@ 10.5,13 SAY STR0098 OF oDlgPd SIZE 20,7.5 	//Frequencia de Afericao
	@ 10.5,17.2 MSGET oGetFAfe VAR nFafe OF oDlgPd PICTURE PesqPict("QM3","QM3_FREQAF") SIZE 35,7.5  
	@ 11.8,13 SAY STR0099 OF oDlgPd SIZE 20,7.5 	//Data de Afericao
	@ 11.7,17.2 MSGET oGetVAfe VAR dDtAfer OF oDlgPd PICTURE PesqPict("QM3","QM3_VALDAF") SIZE 40,7.5  
	oGetFAfe:bLostFocus := {|| dDtAfer := dDtCals+nFafe}
	oGetVAfe:Refresh()

	ACTIVATE MSDIALOG oDlgPd ON INIT QMTA040EnPd(oDlgPd,;
	{||(lRetu := QMT040VPdAut(oDlgPd,lCads,oDlg,nOpc),If(lRetu,(nOpca := 1,oDlgPd:End()),nOpca := 0))},{||lRetu := .t.,nOpca:= 0,oDlgPd:End()},lCads) CENTERED

	
	If nOpca == 1
		If oDlg <> Nil
			oDlg:End()
		Endif
	Endif
Endif

Return lRetu
/*


ͻ
Programa  QMT040VPdAutAutor  Denis Martins        Data   25/06/03   
͹
Desc.     Valida gravacao de padroes e associa os padroes a escala cor- 
          rente                                                       	
͹
ParametrosExp1.:Dialog                                                 	
          Exp2.:Cadastro de Padroes / Escalas                         	
͹
Uso        QMTA040                                                   	
ͼ


*/
Function QMT040VPdAut(oDlgPd,lCads,oDlg,nOpc)
Local lRet	:= .T.
Local lVez	:= 1
Local nTot	:= 0
Local cCods	:= ""
Local lFirst	:= .T.
Local nTolMx	:= 0
Local nTolMi	:= 0
Local nIncers	:= 0
Local lGrvOk	:= .F.
Local aGrvQMC	:= {}
Local nx		:= 1
Local lMsYNo	:= .F.
Local lqm040NPa := ExistBlock("qm040NPa")
Default nOpc	:= 4

If Empty(nVlrIni)
	MessageDlg(STR0086,,3) //"Favor digitar o campo Valor Inicial"			
	lRet	:= .F.
Endif

If Empty(nVlrFin)
	MessageDlg(STR0087,,3) //"Favor digitar o campo Valor Final"				
	lRet	:= .F.	
Endif

If Empty(cPasso)
	MessageDlg(STR0088,,3) //"Favor digitar o campo Passo"					
	lRet	:= .F.	
Endif

If Empty(nTipT)
	MessageDlg(STR0089,,3) //"Favor digitar o campo Tipo Padrao"						
	lRet	:= .F.	
Endif

If nTipT == 1
/*	
	If Empty(cTolMx)
		MessageDlg(STR0091,,3) //"Favor digitar o campo Tolerancia Maxima"
		lRet	:= .F.		
	Endif
	
	If Empty(cTolMi)
		MessageDlg(STR0092,,3) //"Favor digitar o campo Tolerancia Minima"
		lRet	:= .F.		
	Endif
*/
	If Empty(cCbxTT)
		MessageDlg(STR0100,,3) //"Favor digitar o campo Tipo de Tolerancia"
		lRet	:= .F.		
	Endif
	
	If Empty(cNumCer)
		MessageDlg(STR0101,,3) //"Favor digitar o campo Numero do Certificado"
		lRet	:= .F.		
	Endif

	If Empty(nFafe)
		MessageDlg(STR0102,,3) //"Favor digitar o campo Frequencia de Afericao"
		lRet	:= .F.		
	Endif
Endif

If Empty(cUnMi)
	MessageDlg(STR0103,,3) //"Favor digitar o campo Unidade de Medida"
	lRet := .F.
Endif

If lRet
	lVez := .T.
	lFirst := .T.
	nTot := 0
	
    Do While lVez
		dbSelectArea("QM3")
		dbSetOrder(1)

		If lFirst
			nVlrIni := StrTran(nVlrIni,".",",")	  
			nTot := SuperVal(nVlrIni)
			nTolMx := SuperVal(cTolMx)
			nTolMi := SuperVal(cTolMi)
			nIncers := SuperVal(cIncer)
		Else
			nTot := nTot + SuperVal(cPasso)
		Endif      

		If nTot > SuperVal(nVlrFin)		
			lVez := .F.
		Endif
		
		If lChkPto
			If lqm040NPa //Cria nome de acordo com a necessidade do cliente                  
				cCods := ExecBlock("qm040NPa",.F.,.F.,{cDesPUt,nTot})
			Else // Parametro + Valor Inicial
				cCods := Alltrim(SubStr(cDesPUt,1,6))+Alltrim(Str(nTot))		
			Endif	
        Else
			If !lFirst
				If lqm040NPa //Cria nome de acordo com a necessidade do cliente                   
					cCods := ExecBlock("qm040NPa",.F.,.F.,{cDesPUt,nTot})
				Else // Parametro + Valor Inicial
					cCods := Alltrim(SubStr(cDesPUt,1,6))+Alltrim(Str(nTot))		
				Endif	  
			Else
				nTot := nTot + SuperVal(cPasso)
				If lqm040NPa //Cria nome de acordo com a necessidade do cliente                   
					cCods := ExecBlock("qm040NPa",.F.,.F.,{cDesPUt,nTot})
				Else
					If nTot > SuperVal(nVlrFin)		
						lVez := .F.
					Else
						cCods := Alltrim(SubStr(cDesPUt,1,6))+Alltrim(Str(nTot))			
					Endif	
				Endif	
			Endif
        Endif

		cCods := PadR(cCods,TamSX3("QM3_PADRAO")[1])
	
		lFirst := .F.

		If Empty(cCods)
			MessageDlg(STR0104,,2) //"Nenhum ponto padrao criado !!!"
			lVez := .F.		
			Exit
		Endif

		If lVez
			If !dbSeek(xFilial()+cCods) //Colocar dbSelectArea QM3
				RecLock("QM3",.T.)
				Replace QM3_FILIAL With xFilial()
				Replace QM3_PADRAO With cCods
				Replace QM3_REVPAD With "00"
				Replace QM3_DESCRI With cCods
				Replace QM3_INVRPD With Inverte(QM3->QM3_REVPAD)
				Replace QM3_INCERT With Transform(nIncers,QA_PICT(,,nVlrIni,nVlrIni,.F.)) 
				Replace QM3_ESPEC  With Transform(nTot,QA_PICT(,,nVlrIni,nVlrIni,.F.))
				Replace QM3_TOLER  With Transform(nTolMx,QA_PICT(,,nVlrIni,nVlrIni,.F.))
				Replace QM3_TOLMIN With Transform(nTolMi,QA_PICT(,,nVlrIni,nVlrIni,.F.))
				Replace QM3_UNIMED With cUnMi
				Replace QM3_DATREV With dDataBase
				Replace QM3_CERTIF With cNumCer
				
				If nFafe <> 0
					Replace QM3_DATAF  With dDtCals
					Replace QM3_FREQAF With nFafe
					Replace QM3_VALDAF With dDtAfer
				Endif
									
				If nTipoTo == 1
					Replace QM3_TIPTOL With "1"
				Else
					Replace QM3_TIPTOL With "2"
				Endif
				
				If nTipT == 1 //Padrao Objetivo
					Replace QM3_TIPPAD With "O"
				ElseIf nTipT == 2 //Padrao Subjetivo
					Replace QM3_TIPPAD With "S"
				Else
					Replace QM3_TIPPAD With "A" //Padrao Atributo
				Endif
				
				MsUnLock()
				
				If !lCads .and. lPergta
					If lMsYNo := MsgYesNo(STR0105,STR0106) //"Associacao"
						//Ver tipo Soma
						If !(Alltrim(M->QM9_TIPAFE) $ "4|8|5| ")
							
							lGrvOk := A040TdOk("QM9",nOpc)
							
							If lGrvOk
								dbSelectArea("QMC")
								dbSetOrder(1)
								RecLock("QMC",.T.)
								Replace QMC->QMC_FILIAL	With xFilial("QMC")
								Replace QMC->QMC_ESCALA	With M->QM9_ESCALA
								Replace QMC->QMC_PADRAO	With cCods
								Replace QMC->QMC_TOLER	With Transform(nTolMx,QA_PICT(,,nVlrIni,nVlrIni,.F.))
								Replace QMC->QMC_TOLMIN	With Transform(nTolMi,QA_PICT(,,nVlrIni,nVlrIni,.F.))
								Replace QMC->QMC_REVESC With M->QM9_REVESC
								Replace QMC->QMC_REVINV With Inverte(M->QM9_REVESC)
								If nTipoTo == 1
									Replace QMC->QMC_TIPTOL With "1"
								Else
									Replace QMC->QMC_TIPTOL With "2"							
								Endif	
								MsUnLock()
							Endif
						Endif
					Endif
					lPergta := .F.
				ElseIf !lPergta
					If !(Alltrim(M->QM9_TIPAFE) $ "4|8|5| ")
						
						If lGrvOk
							dbSelectArea("QMC")
							dbSetOrder(1)
							RecLock("QMC",.T.)
							Replace QMC->QMC_FILIAL	With xFilial("QMC")
							Replace QMC->QMC_ESCALA	With M->QM9_ESCALA
							Replace QMC->QMC_PADRAO	With cCods
							Replace QMC->QMC_TOLER	With Transform(nTolMx,QA_PICT(,,nVlrIni,nVlrIni,.F.))
							Replace QMC->QMC_TOLMIN	With Transform(nTolMi,QA_PICT(,,nVlrIni,nVlrIni,.F.))
							Replace QMC->QMC_REVESC With M->QM9_REVESC
							Replace QMC->QMC_REVINV With Inverte(M->QM9_REVESC)
							If nTipoTo == 1
								Replace QMC->QMC_TIPTOL With "1"
							Else
								Replace QMC->QMC_TIPTOL With "2"							
							Endif	
							MsUnLock()
						Endif
					Endif
				Endif
			Else       
				If !lCads
					Aadd(aGrvQMC,{xFilial("QMC"),M->QM9_ESCALA,QM3->QM3_PADRAO,QM3->QM3_TOLER,;	
					QM3->QM3_TOLMIN,M->QM9_REVESC,Inverte(M->QM9_REVESC),If(nTipoTo == 1,"1","2")})
				Endif	
			Endif
		Endif
	Enddo
//	oDlgPd:End()
Endif

//Associa todos os pontos na amarracao. . .
If Len(aGrvQMC) > 0                           
	If !lGrvOk
		lGrvOk := A040TdOk("QM9",nOpc)	
	Endif
	If lGrvOk
		If !lMsYNo
			If lMsYNo := MsgYesNo(STR0105,STR0106) //"Associacao"			
				lMsYNo := .T.
			Else
				lMsYNo := .F.				
			Endif
		Endif
		If lMsYNo			
			For nx := 1 To Len(aGrvQMC)
				dbSelectArea("QMC")
				dbSetOrder(1)  
				If !dbSeek(xFilial()+aGrvQMC[nx][2]+aGrvQMC[nx][7]+aGrvQMC[nx][3])
					RecLock("QMC",.T.)
					Replace QMC->QMC_FILIAL	With aGrvQMC[nx][1]
					Replace QMC->QMC_ESCALA	With aGrvQMC[nx][2]
					Replace QMC->QMC_PADRAO	With aGrvQMC[nx][3]
					Replace QMC->QMC_TOLER	With aGrvQMC[nx][4]
					Replace QMC->QMC_TOLMIN	With aGrvQMC[nx][5]
					Replace QMC->QMC_REVESC With aGrvQMC[nx][6]
					Replace QMC->QMC_REVINV With aGrvQMC[nx][7]
					Replace QMC->QMC_TIPTOL With aGrvQMC[nx][8]
					MsUnLock()
				Endif	
			Next nx  
		Endif
	Endif
Endif 

Return lRet
/*


ͻ
Programa  qmt040VPadAOSAutor  Denis Martins        Data   07/08/03   
͹
Desc.     Habilita /Desabilita campos a serem digitados               	 
                                                                      	 
͹
Uso        QMTA040                                                    	 
ͼ


*/
Function qmt040VPadAOS()
If nTipT == 3
	oGetIncer:Disable()
	oGetTMa:Disable()
	oGetTMi:Disable()
	oGetNCer:Disable() 
	oGetFAfe:Disable()
	oGetDtCal:Disable()
	oGetVAfe:Disable() 
Else
	oGetIncer:Enable()
	oGetTMa:Enable()
	oGetTMi:Enable()
	oGetNCer:Enable()
	oGetFAfe:Enable()
	oGetDtCal:Enable()
	oGetVAfe:Enable()
Endif    

Return

/*


ͻ
Programa  QMT040CoUnAutor  Denis Martins        Data   07/10/03   
͹
Desc.     Verifica se as unidades de medidas sao diferentes			  
          escala - padrao automatico                                  
͹
Uso        QMTA040                                                    
ͼ


*/
Function QMT040CoUn(cUnMi)
Local lRet := .T. 
If cUnMi <> M->QM9_UNIMED
	dbSelectArea("SAP")
	dbSetOrder(1)
	If !dbSeek(xFilial("SAP")+cUnMi+M->QM9_UNIMED)
		Help(" ",1,"A040AUMED") //"As unidades de medida padrao automatico/escala sao diferentes, favor cadastrar a conversao."
		lRet := .F.
	Endif
Endif          
Return lRet

/*


ͻ
Programa  QMTA040EnPdAutor  Denis Martins        Data   07/10/03   
͹
Desc.     Enchoice Bar do Padrao Automatico                            
          Botao conversao de medidas                                   
͹
Uso        QMTA040                                                     
ͼ


*/
Function QMTA040EnPd( oDlgPd, bOk, bCancel, lCads )
Local aButtons := {}                             
If !lCads
	aAdd(aButtons,{"NOTE"  ,{|| QMT040ConMed()},STR0108,STR0112}) //"Conversao de Medidas"
Endif
EnchoiceBar(oDlgPd,bOk,bCancel,,aButtons)

Return Nil

/*


ͻ
Programa  QMT040ConMedAutor  Denis Martins        Data   07/10/03   
͹
Desc.     Realiza conversao de unidade de medida padrao automatico      
͹
Uso        QMTA040                                                      
ͼ


*/
Function QMT040ConMed()
Local oDlgC
Local nOpca := 0
Local cDescD	:= ""
Local cDescP	:= ""	                              
Local lGrvUn	:= .F.
Private cConDe	:= CriaVar("AH_UNIMED",.F.)
Private cConPara:= CriaVar("AH_UNIMED",.F.)
Private nConver	:= 0	
cConDe	 := cUnMi
cConPara := M->QM9_UNIMED

DEFINE MSDIALOG oDlgC TITLE STR0108 FROM 33,25 TO 180,349 PIXEL  //Conversao de Medidas

@ 012,005 To 69,155 OF oDlgC PIXEL
@ 006,008 SAY STR0109 SIZE 120, 7 OF oDlgC PIXEL  // Informe o Fator de Conversao
@ 020,008 SAY STR0110 SIZE 55, 7 OF oDlgC PIXEL  // De:
@ 020,038 MSGET cConde F3 "SAH" Valid (ExistCpo("SAH") .and. QMTA040ShwD(@cDescD,cConde)) OF oDlgC PIXEL
@ 020,062 SAY cDescD SIZE 90, 7 OF oDlgC PIXEL
@ 035,008 SAY STR0111 SIZE 18, 7 OF oDlgC PIXEL  //Para:
@ 035,038 MSGET cConPara F3 "SAH" Valid (ExistCpo("SAH") .and. QMTA040ShP(@cDescP,cConPara)) OF oDlgC PIXEL
@ 035,062 SAY cDescP OF oDlgC SIZE 90, 7 PIXEL
@ 049,008 SAY STR0112 SIZE 34, 7 OF oDlgC PIXEL	//Conversao
@ 049,038 MSGET nConver Picture PesqPict("SAP","AP_COEF") SIZE 45, 11 OF oDlgC PIXEL

DEFINE SBUTTON FROM 36, 120 TYPE 1 ACTION (nOpca := 1,lGrvUn := qmt040grsap(cConde,cConPara,nConver,oDlgC),If(lGrvUn,oDlgC:End(),.F.)) ENABLE OF oDlgC 
DEFINE SBUTTON FROM 52, 120 TYPE 2 ACTION (nOpca := 0, oDlgC:End()) ENABLE OF oDlgC

ACTIVATE MSDIALOg oDlgC CENTERED
Return 

Static Function QMTA040ShwD(cDescD,cConde)
dbSelectArea("SAH")
dbSetOrder(01)
dbSeek(xFilial("SAH")+cConde)
cDescD := SAH->AH_UMRES
Return .T.

Static Function QMTA040ShP(cDescP,cConPara)
dbSelectArea("SAH")
dbSetOrder(01)
dbSeek(xFilial("SAH")+cConPara)
cDescP := SAH->AH_UMRES
Return .T.

/*


ͻ
Programa  qmt040grsapAutor  Denis Martins        Data   10/07/03   
͹
Desc.     Realizar gravacao de conversao de medidas                    
                                                                       
͹
Uso        QMTA040 					                                   
ͼ


*/
Function qmt040grsap(cConde,cConPara,nConver,oDlgC)
Local aArea := GetArea()
Local lRet	:= .T.
If cConde == cConPara
	Help( " ", 1, "A040IGMED" )	//"Nao e permitido unidades de medidas iguais."
	lRet := .F.
Endif

If lRet
	If nConver == 0
		Help( " ", 1, "A040IGZER" )	//Nao eh permitido conversao de medidas com valores igual a zero		
		lRet := .F.
	Endif
Endif

If lRet
	dbSelectArea("SAP")
	dbSetOrder(1)
	If !dbSeek(xFilial("SAP")+cConde+cConPara)
		Reclock("SAP",.T.)
		Replace AP_DE	with cConde
		Replace AP_PARA	with cConPara
		Replace AP_COEF	with nConver
		MsUnlock()
	Endif
Endif	

RestArea(aArea)

Return lRet
/*


ͻ
Programa  QMT040CvUnAutor  Denis Martins        Data   01/13/04   
͹
Desc.     Caso o usuario deseje no momento da alteracao da faixa, tro-
          car a unidade de medida, verificar se existe conversao.     
͹
Uso       QMTA040                                                     
ͼ


*/
Function QMT040CvUn()
Local lRet := .T.
If Altera
	If !(M->QM9_TIPAFE $ "4|8| ")
		If M->QM9_TIPAFE <> "5"
			dbSelectArea("QMC")
			dbSetOrder(1)
			If dbSeek(xFilial()+M->QM9_ESCALA+Inverte(M->QM9_REVESC))
				While QMC->(!Eof()) .and. QMC->QMC_FILIAL+QMC->QMC_ESCALA+Inverte(QMC->QMC_REVESC)  == ;
					xFilial()+M->QM9_ESCALA+Inverte(M->QM9_REVESC)
					dbSelectArea("QM3")
					dbSetOrder(1)
					If dbSeek(xFilial()+QMC->QMC_PADRAO)
						If QM3->QM3_UNIMED <> M->QM9_UNIMED
							dbSelectArea("SAP")
							dbSetOrder(1)
							If !dbSeek(xFilial()+QM3->QM3_UNIMED+M->QM9_UNIMED)
								lRet := .f.
								Help(" ",1,"A040UNIMED") // "Padrao nao pode ser associado a escala, pois possui unidade de medida diferente")
								// "Cadastre a conversao."
								Exit
							Endif
						Endif
					Endif
					dbSelectArea("QMC")
					dbSetOrder(1)
					dbSkip()
				Enddo
			Else
				lRet := .T.
			Endif
		Else
			dbSelectArea("QMA")
			dbSetOrder(1)
			If dbSeek(xFilial()+M->QM9_ESCALA+Inverte(M->QM9_REVESC))
				While QMA->(!Eof()) .and. QMA->QMA_FILIAL+QMA->QMA_ESCALA+QMA->QMA_REVESC ==;
					xFilial("QMA")+M->QM9_ESCALA+M->QM9_REVESC
					dbSelectArea("QM3")
					dbSetOrder(1)
					If dbSeek(xFilial()+QMA->QMA_PADRAO)
						If QM3->QM3_UNIMED <> M->QM9_UNIMED
							dbSelectArea("SAP")
							dbSetOrder(1)
							If !dbSeek(xFilial()+QM3->QM3_UNIMED+M->QM9_UNIMED)
								lRet := .f.
								Help(" ",1,"A040UNIMED") // "Padrao nao pode ser associado a escala, pois possui unidade de medida diferente")
								// "Cadastre a conversao."
								Exit
							Endif
						Endif
					Endif
					dbSelectArea("QMA")
					dbSetOrder(1)
					dbSkip()
				Enddo
			Else
				lRet := .T.
			Endif
		Endif
	Endif
Endif

Return lRet

/*


ͻ
Programa  QM040AcQM9Autor  Denis Martins        Data              
͹
Desc.     Incluir no menu SIGAQMT a funcao QM040AcQM9 (Acerta o QM9_  
          NROMED) para as faixas que foram criadas revisao.           
͹
Uso        MENU SIGAQMT                                               
ͼ


*/
Function QM040AcQM9()
Local aQM9 := {}
Local nSom := 0
Local cEscca :="" 
Local cEsRev :="" 
dbSelectArea("QM6")
dbSetOrder(1)
dbGoTop()

While !QM6->(Eof())
	dbSelectArea("QM7")
	dbSetOrder(1)
	If dbSeek(xFilial()+QM6->QM6_INSTR+QM6->QM6_REVINS+DTOS(QM6->QM6_DATA)+QM6->QM6_CSEQ)
    	While !QM7->(Eof()) .and. QM7->QM7_FILIAL+QM7->QM7_INSTR+QM7->QM7_REVINS+DTOS(QM7->QM7_DATA)+QM7->QM7_CSEQ ==;
			QM6->QM6_FILIAL+QM6->QM6_INSTR+QM6->QM6_REVINS+DTOS(QM6->QM6_DATA)+QM6->QM6_CSEQ
			If Alltrim(cEscca) <> Alltrim(QM7->QM7_ESCALA) //.and. Val(cEsRev) <> Val(QM7->QM7_REVESC)  
				cEscca := Alltrim(QM7->QM7_ESCALA) 
				cEsRev := Alltrim(QM7->QM7_REVESC) 
				dbSelectArea("QM8")
				dbSetOrder(1)
				If dbSeek(xFilial()+QM7->QM7_INSTR+QM7->QM7_REVINS+DTOS(QM7->QM7_DATA)+QM7->QM7_CSEQ+QM7->QM7_ESCALA+QM7->QM7_REVESC)
					While !QM8->(Eof()) .and. QM8->QM8_FILIAL+QM8->QM8_INSTR+QM8->QM8_REVINS+DTOS(QM8->QM8_DATA)+QM8->QM8_CSEQ+QM8->QM8_ESCALA+QM8->QM8_REVESC+QM8->QM8_PADRAO ==;
					xFilial("QM7")+QM7->QM7_INSTR+QM7->QM7_REVINS+DTOS(QM7->QM7_DATA)+QM7->QM7_CSEQ+QM7->QM7_ESCALA+QM7->QM7_REVESC+QM7->QM7_PONTO										
					nSom++
					dbSelectArea("QM8")
					dbSetOrder(1)
					dbSkip()
					Enddo
					dbSelectArea("QM9")
					dbSetOrder(1)
					If dbSeek(xFilial()+QM7->QM7_ESCALA+Inverte(QM7->QM7_REVESC))
						If !Empty(QM7->QM7_LABOR)
							RecLock("QM9",.F.)
							Replace QM9->QM9_TIPAFE With nSom
							MsUnlock()
						Endif
						If QM9->QM9_NROMED > 0
							If QM9->QM9_NROMED <> nSom 
								RecLock("QM9",.F.)
								Replace QM9->QM9_NROMED With nSom
								MsUnlock()
								Aadd(aQM9,{QM9->QM9_ESCALA,QM9->QM9_REVESC})							
							Endif
						Endif					
						
					Endif
				Endif					
			Endif
			nSom := 0
			cEscca := Alltrim(QM7->QM7_ESCALA) 
			cEsRev := Alltrim(QM7->QM7_REVESC) 
	    	dbSelectArea("QM7")
	    	dbSkip()
    	Enddo
	Endif
	dbSelectArea("QM6")
	dbSkip()
Enddo

Return Nil

/*


ͻ
Programa  Q070PICTR Autor  Denis Martins        Data              
͹
Desc.     Ajuste de apresentacao de picture campo QM9_ESCALF          
                                                                      
͹
Uso        QMTA040                                                    
ͼ


*/
Function Q070PICTR()
Local cPict := ""
Local lVisual	:= Iif(Inclui .Or. Altera,.F.,.T.)
	If !lVisual 	
		cPict := Q070PC("QM9_ESCALI")
	Endif	
Return cPict
/*


ͻ
Programa  QMTA040   Autor  Renata Cavalcante    Data   05/05/08   
͹
Desc.      Validao do campo de Valor Final                          
                                                                      
͹
Uso        Validao do campo de Valor Final                          
ͼ


*/
Function Q040VldVal

Local lRet:=.T.

If Empty(M->QM9_ESCALI)
	MessageDlg(STR0122,,3)//"Para informar o valor final  necessrio informar o valor inicial"
    lRet:=.F.
Endif

Return(lRet)

/*/


Ŀ
Funcao    A040VldPxF Autor  Sergio S. Fuzinaka     Data  23.09.08 
Ĵ
Descricao Valida a amarracao Padroes x Faixas                         
                                                                      
Ĵ
Uso       QMTA040                                                     
ٱ


/*/         
Static Function A040VldPxF(aCosAa)

Local aArea		:= {}
Local aAreaQM3	:= {}
Local aAreaQM7	:= {}
Local lExistCal := .F.
Local lRet		:= .T.
Local nX		:= 0
Local nY		:= 0
Local nPosPad	:=	ASCAN(aHeader,{|x| Alltrim(x[2]) = "QMC_PADRAO"})

If Len( aCosAa ) > 0

	aArea	:= GetArea()
	aAreaQM3:= QM3->(GetArea())
	aAreaQM7:= QM7->(GetArea())
	
	For nX := 1 To Len(aCosAa)
		dbSelectArea("QM3")
		dbSetOrder(1)
		If dbSeek(xFilial("QM3")+aCosAa[nX][nPosPad])
			dbSelectArea("QM7")
			dbSetOrder(2)
			If dbSeek(cFilial+QMC->QMC_ESCALA+QMC->QMC_REVESC+aCosAa[nX][nPosPad])
				lExistCal := .T.
				Exit
			Endif		
		Endif
	Next nX
		
	If lExistCal
		If Len(aCosAa) == Len(aCols)
			For nX := 1 To Len(aCosAa)
				For nY := 1 To Len(aCosAa[nX])
					If aCosAa[nX,nY] <> aCols[nX,nY]
						lRet := .F.
						Exit
					Endif
				Next nY
			Next nX
		Else
			lRet := .F.
		Endif

		If !lRet 
			MessageDlg(STR0118+Chr(13)+Chr(10)+STR0119,,3) //"Por favor realize a revisao da escala"
		Endif
	Endif
	
	RestArea( aAreaQM7 )
	RestArea( aAreaQM3 )
	RestArea( aArea )

Endif

Return( lRet )

/*/{Protheus.doc} QMTA040AuxClass
Classe agrupadora de mtodos auxiliares do QMTA040
@author rafael.kleestadt
@since 20/06/2024
@version 1.0
/*/
CLASS QMTA040AuxClass FROM LongNameClass

    METHOD new() Constructor
    METHOD marcaComoDeletadaALinhaDoArrayAuxiliarDePadroesSeNaoHouverCalibracao(aCols, aTabPad, cEscala, cRevEsc)
    
ENDCLASS

/*/{Protheus.doc} new
Construtor da Classe
@author rafael.kleestadt
@since 20/06/2024
@version 1.0
@param param_name, param_type, param_descr
@return return_var, return_type, return_description
/*/
METHOD new() CLASS QMTA040AuxClass
Return Self


/*/{Protheus.doc} marcaComoDeletadaALinhaDoArrayAuxiliarDePadroesSeNaoHouverCalibracao
Marca como deletada a linha do array auxiliar de padres se a linha da grid for deletada e no houver calibraes pra esse padro
@author rafael.kleestadt
@since 20/06/2024
@version 1.0
@param aCols, array, array manipulado na grid de padres
@param aTabPad, array, array auxiliar de padres
@param cEscala, caractere, faixa
@param cRevEsc, caractere, reviso da faixa
/*/
Method marcaComoDeletadaALinhaDoArrayAuxiliarDePadroesSeNaoHouverCalibracao(aCols, aTabPad, cEscala, cRevEsc) CLASS QMTA040AuxClass
	Local aArea	    := GetArea()
	Local aAreaQM3  := QM3->(GetArea())
	Local aAreaQM7  := QM7->(GetArea())
	Local lExistCal	:= .F.
	Local nCont	    := 0

	For nCont := 1 To Len(aCols)
		lExistCal := .F.                              
		If aCols[nCont][Len(aCols[nCont])] //Linha deletada

			DbSelectArea("QM3")
			QM3->(dbSetOrder(1))
			If QM3->(DbSeek(xFilial("QM3")+aCols[nCont][1]))
				DbSelectArea("QM7")
				QM7->(dbSetOrder(2))
				If QM7->(DbSeek(xFilial("QM7")+cEscala+cRevEsc+aCols[nCont][1]))
					lExistCal := .T.
				Endif		
			Endif
			
			If !lExistCal //Se no possui calibrao marca como true para ser deletado.
				aTabPad[nCont][Len(aTabPad[nCont])] := .T.
			Endif	
			
		Endif
	Next nCont
	
	RestArea(aAreaQM3)
	RestArea(aAreaQM7)
	RestArea(aArea)

Return Nil
