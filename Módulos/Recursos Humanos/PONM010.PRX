#INCLUDE "PONM010.CH"
#INCLUDE "PROTHEUS.CH"
#INCLUDE "PONCALEN.CH"
#INCLUDE "HEADERGD.CH"
#INCLUDE "FILEIO.CH"
#INCLUDE "FWLIBVERSION.CH"

Static lPonaPo1Block	:= ExistBlock( "PONAPO1" )
Static lPonaPo2Block	:= ExistBlock( "PONAPO2" )
Static lPonaPo3Block	:= ExistBlock( "PONAPO3" )
Static lPonaPo5Block	:= ExistBlock( "PONAPO5" )
Static lPonaPo6Block	:= ExistBlock( "PONAPO6" )
Static lPonaPo7Block	:= ExistBlock( "PONAPO7" )
Static lPonaPo8Block	:= ExistBlock( "PONAPO8" )
Static lPnm010CposBlock	:= ExistBlock( "PNM010CPOS" )
Static lPnm010Ref1Block	:= ExistBlock( "PNM010REF1" )
Static lPnm010R2Block	:= ExistBlock( "PNM010R2" )
Static lPnm010IniBlock  := ExistBlock( "PNM010INI" )
Static lExInAs400		  := ExeInAs400()
Static __LastParam__	:= {}
Static lPort1510 		:= Port1510() 	//Verifica se Portaria 1510/2009 esta em vigor.
Static lIntegDef 		:= FindFunction("GETROTINTEG") .And. FindFunction("FWHASEAI")
Static _aAuxPerApo		:= {}
Static __oSt
Static lTemTmpSRA		:= .F.
Static oMsSelect

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o	 ³ PONM010	³ Autor ³ Equipe Advanced RH    ³ Data ³01/03/1996³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Classifica‡„o das Marca‡”es                                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ SIGAPON                                                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³         ATUALIZACOES SOFRIDAS DESDE A CONSTRU€AO INICIAL.             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Programador ³ Data   ³ BOPS ³  Motivo da Alteracao                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Leandro Dr. ³13/04/14³      ³Retirada de ajustes, database e FieldPos  ³±±
±±³            ³        ³      ³que nao serao utilizados na P12.		  ³±±
±±³Allyson M.  ³16/07/14³TPSJLN³Ajuste em GetMrBySra() p/ ordernar a query³±±
±±³			   ³ 		³      ³por PIS caso o relogio seja REP 		  ³±±
±±³Luis Artuso ³18/07/14³TQCB94³Ajuste em Ponm010Processa para validar o  ³±±
±±³			   ³ 		³      ³periodo aberto da filial.				  ³±±
±±³Luis Artuso |27/08/14|TQHGBM|Ajuste para nao permitir gerar apontamento³±±
±±³			   | 		|      |para filiais que estejam fora do periodo  ³±±
±±³			   | 		|      |ou data posterior a database.             ³±±
±±³Renan Borges|07/05/15|TSDV21|Ajuste para classificar refeição correta- ³±±
±±³			   | 		|      |mente quando turno for noturno.           ³±±
±±³Renan Borges|05/06/15|TSMCG5|Ajuste para utilizar data de apontamento  ³±±
±±³			   | 		|      |para realizar o fechamento do período cor-³±±
±±³			   | 		|      |retamente.                                ³±±
±±³Allyson M.  |16/10/15|TTPMJ1|Ajuste p/ schedule p/ somente efetuar     ³±±
±±³			   | 		|      |classificacao dos funcionarios que tive-  ³±±
±±³			   | 		|      |ram registros lidos p/ performance; p/    ³±±
±±³			   | 		|      |gravar marcacoes de funcionarios alocados ³±±
±±³			   | 		|      |em filial diferente da filial do relogio e³±±
±±³			   | 		|      |p/ nao efetuar a leitura de relogios com  ³±±
±±³			   | 		|      |registro de bloqueado (P0_MSBLQL = 1)     ³±±
±±³			   | 		|      |Ajuste p/ validacao do campo P0_INC.      ³±±
±±³			   | 		|      |Ao executar a rotina de leitura/apontamen-³±±
±±³			   | 		|      |to, deve ser gerado log de ocorrencia     ³±±
±±³			   | 		|      |informando relogios do tipo 'REP' que nao ³±±
±±³			   | 		|      |tenham o tipo incremental, conforme bole- ³±±
±±³			   | 		|      |tim disponivel:                           ³±±
±±³			   | 		|      |http://tdn.totvs.com/x/9YRsAQ             ³±±
±±³			   | 		|      |Ajuste p/ ajustar a data fim de apontamen-³±±
±±³			   | 		|      |to, quando houver demissão. Deve ser      ³±±
±±³			   | 		|      |enviada como data final a data base, para ³±±
±±³			   | 		|      |eliminar os apontamentos gerados apos a   ³±±
±±³			   | 		|      |data de demissao.                         ³±±
±±³Renan B.    |07/12/15|TTTSI7|Ajuste para considerar corretamente o ran-³±±
±±³			   | 		|      |ge de data. Se informar apenas um dia para³±±
±±³			   | 		|      |leitura/apontamento (Ex.: 01/10 a 01/10 a ³±±
±±³			   | 		|      |rotina ignorava a execucao do apontamento ³±±
±±³			   | 		|      |devido erro na cláusula de validacao em   ³±±
±±³			   | 		|      |lContinua.                                ³±±
±±³Renan Borges|18/04/16|TUJU54|Ajuste para montar intervalo do filtro cor³±±
±±³			   | 		|      |retamente quando o modo de compartilhamen-³±±
±±³			   | 		|      |to da tabela de relogio for exclusivo.    ³±±
±±³Matheus M.  |06/07/16|TUXBWK|Ajustes na integração TSA x Ponto na opção³±±
±±³			   | 		|      |de importação de refeições.				  ³±±
±±³Raquel Hager|19/04/16|TVSOVR|Ajuste para não realizar leitura de marca-³±±
±±³			   | 		|      |ções anteriores à Data de Admissão.       ³±±
±±³Oswaldo L.  |03/04/17|DRHPONTP-164|       Projeto cTree                ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Function Ponm010(	lWork		,;	//01 -> Se o "Start" foi via WorkFlow
					lUserDef 	,;	//02 -> Se deve considerar as configuracoes dos parametros do usuario
					lLimita		,;	//03 -> Se deve limitar a Data Final de Apontamento a Data Base
					cProcFil	,;	//04 -> Filial a Ser Processada
					lProcFil	,;	//05 -> Processo por Filial
					lApoNLidas	,;	//06 -> Apontar quando nao Leu as Marcacoes para a Filial
					lForceR		,;	//07 -> Se deve Forcar o Reapontamento
					xAutoCab	,;
					xAutoItens	,;
					nOpcAuto    ,;
					cProcessa   ,;  //11 -> '1'->Leitura , '2'->Apontamento , '3'->Ambos
					cTipoRel    ,;  //12 -> '1'->Funcionario , '2'->Relogio
					dDtIni   	,;  //13 -> Data inicio para leitura das marcacoes - Via Workflow
					dDtFim   	,;  //14 -> Data Fim para leitura das marcacoes - Via Workflow
					lnewPonWork  ;
				)

Local aArea					:= GetArea()
Local aArqSel				:= {}
Local aChkAlias	        	:= {}
Local aButtons				:= {}

Local cChar		 			:= IF( ( TcSrvType() == "AS/400" ) , "9" , "Z" )
Local cSvFilAnt				:= cFilAnt
Local lChkAlias				:= .F.
Local lExib2Plan			:= FwLibVersion() >= "20240520"
Local lExec2Plan			:= FwIsInCallStack("WFLAUNCHER") .or. FwIsInCallStack("FWBOSCHDEXECUTE")
Local cTrbTmp               := GetNextAlias()
Local nAt1					:= 0

DEFAULT lWork				:= .F.
DEFAULT lUserDef			:= .F.
DEFAULT lLimita				:= .T.
DEFAULT cProcFil			:= .F.
DEFAULT lProcFil			:= .F.
DEFAULT lApoNLidas			:= .F.
DEFAULT lForceR				:= .F.

DEFAULT lPonaPo1Block		:= ExistBlock( "PONAPO1" )
DEFAULT lPonaPo2Block		:= ExistBlock( "PONAPO2" )
DEFAULT lPonaPo3Block		:= ExistBlock( "PONAPO3" )
DEFAULT lPonaPo5Block		:= ExistBlock( "PONAPO5" )
DEFAULT lPonaPo6Block		:= ExistBlock( "PONAPO6" )
DEFAULT lPonaPo7Block		:= ExistBlock( "PONAPO7" )
DEFAULT lPonaPo8Block		:= ExistBlock( "PONAPO8" )
DEFAULT lPnm010CposBlock	:= ExistBlock( "PNM010CPOS" )
DEFAULT lPnm010Ref1Block	:= ExistBlock( "PNM010REF1" )
DEFAULT lPnm010R2Block	    := ExistBlock( "PNM010R2" )
DEFAULT lPnm010IniBlock	    := ExistBlock( "PNM010INI" )
DEFAULT lExInAs400			:= ExeInAs400()
DEFAULT xAutoCab   			:= NIL
DEFAULT xAutoItens 			:= NIL
DEFAULT nOpcAuto   			:= NIL
DEFAULT cProcessa			:= "3"
DEFAULT cTipoRel			:= "2"
DEFAULT dDtIni				:= Ctod("//")
DEFAULT dDtFim				:= Ctod("//")
DEFAULT lnewPonWork			:= .F.

PRIVATE aAutoCab   			:= xAutoCab
PRIVATE aAutoItens 			:= xAutoItens
PRIVATE nAutoOpc   			:= If(nOpcAuto <> NIL,nOpcAuto,3)
PRIVATE lPN010Auto 			:= ValType(xAutoCab)=="A" .And. ValType(xAutoItens) == "A"

Private cCadastro   		:= OemToAnsi(STR0001 ) // 'Leitura/Apontamento Marcacoes'
Private lAbortPrint 		:= .F.

Private lFiltRel			:= .F. //Filtra Relogios
Private lMultThread			:= .F. //Somente é verdadeiro se ambiente for TOP e parametro MV_PONMULT for maior que zero
Private nMultThread			:= 0
Private lGeolocal 			:= SP8->(ColumnPos("P8_LATITU")) > 0 .And. SP8->(ColumnPos("P8_LONGIT")) > 0
Private lPn090Lock			:= .F.

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Variaves do Processo WorkFlow								   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Private lSchedDef		:= FWGetRunSchedule()
Private lWorkFlow		:= lWork .OR. lSchedDef
Private lUserDefParam	:= lUserDef
Private lLimitaDataFim	:= lLimita
Private cFilProc		:= cProcFil
Private lProcFilial		:= lProcFil
Private lApontaNaoLidas := lApoNLidas
Private lForceReaponta	:= lForceR
Private nProcessa		:= Val(cProcessa)
Private nTipoRel		:= Val(cTipoRel)
Private dDtIniWf		:= dDtIni
Private dDtFimWf  		:= dDtFim
Private oTmpTabFO1
Private aRegsRARFE 		:= {}
Private lWorkNew		:= lnewPonWork

If lPort1510
	cCadastro += fPortTit() //Complementa titulo da tela com dizeres referente a portaria.
EndIf

nMultThread := SuperGetMv( "MV_PONMULT" , NIL , 0 )
lMultThread := If(nMultThread > 1,.T.,.F.)

lFiltRel := ( SuperGetMv("MV_FILTREL",NIL,"N") == "S" )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Carrega a Filial a Ser Processada Quando WorkFlow            ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
//Não é necessário carregar quando vem do SchedDef
IF ( lWorkFlow .AND. !lSchedDef )
	cFilAnt := IF( ( ValType( cFilProc ) == "C" ) .and. Len(Alltrim(cFilProc)) > 0 , cFilProc , cFilAnt )
EndIF

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ So Executa se os Modos de Acesso dos Arquivos Relacionados es³
³ tiverm OK e se For Encontrado o Periodo de Apontamento.      ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
IF ValidArqPon( !( lWorkFlow ) )

	If lPn010Auto
		
		Private dPerDe 			:= Ctod("//")
		Private dPerAte 		:= Ctod("//")
		Private dPerIni			:= Ctod("//")
		Private dPerFim			:= Ctod("//")
		Private dData   		:= Ctod("//")
		Private aLogFile		:= {}
		Private nDiasExtA 		:= 0
		Private nDiasExtP 		:= 0
		Private lChkPonMesAnt	:= .F.
		Private lPonWork		:= !lWorkNew .And. IsInCallStack("U_PonScheduler")
		Private nGravadas	 	:= 0
		Private cFunMat			:= ""
		Private cFilFECAux   	:= ""
		Private cFilOld    		:= "__cFilOld__"
		Private nAponta 		:= 1
		Private nTipo      		:= 0
		
		Begin Sequence
			
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Verifica se existe o funcionario enviado pelo Rotina Automatica  ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			nXFilial := aScan(aAutoCab,{|x| AllTrim(x[1]) == "RA_FILIAL" })
			nXMatric := aScan(aAutoCab,{|x| AllTrim(x[1]) == "RA_MAT" })
	        cFunMat  := aAutoCab[nXFilial][2] + aAutoCab[nXMatric][2]

			If nXFilial > 0 .And. nXMatric > 0
				dbSelectArea("SRA")
				dbSetOrder(1)
				If !dbSeek( cFunMat )
					aAdd(aLogFile,STR0159+ " " + aAutoCab[nXFilial][2] + " - " + aAutoCab[nXMatric][2])
					Break
				Endif
			Endif

			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Envia o array com as marcacoes para a rotina de gravacao 		   ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			If !GetPonMesDat( @dPerDe , @dPerAte , SRA->RA_FILIAL )
				Break
			EndIf

			If !GetPonMesDat( @dPerIni , @dPerFim , SRA->RA_FILIAL )
				dPerIni := dPerDe
				dPerFim	:= dPerAte
			EndIf

			nDiasExtA 	:= Min(Abs( SuperGetMv( "MV_GETDIAA" , NIL , 2  , SRA->RA_FILIAL ) ), 7)	//-- Quantidade de Dias a ser considerada antes do inicio do Periodo de  Apontamento a ser considerada na Leitura/Apontamento
			nDiasExtP 	:= Min(Abs( SuperGetMv( "MV_GETDIAP" , NIL , 2  , SRA->RA_FILIAL ) ), 7)	//-- Quantidade de Dias a ser considerada apos  o fim do Periodo de  Apontamento a ser considerada na Leitura/Apontamento

			// comando para o retorno da Integdef ser direcionado para este fonte
			SetRotInteg( "PONM010" )


			// Inclusao do ExecAuto
			If nAutoOpc == 3
				GetMrBySra()
			Else


				Begin Transaction
					dbSelectArea("SP8")
					dbSetOrder(2) // P8_FILIAL+P8_MAT+DTOS(P8_DATA)+STR(P8_HORA,5,2)

					For nAt1 :=1 to Len(aAutoItens)
						nP1Filial	:= aScan(aAutoItens[nAt1],{|x| AllTrim(x[1]) == "P8_FILIAL" })
						nP1Matric	:= aScan(aAutoItens[nAt1],{|x| AllTrim(x[1]) == "P8_MAT" })
						nP1Data		:= aScan(aAutoItens[nAt1],{|x| AllTrim(x[1]) == "P8_DATA" })
						nP1Hora		:= aScan(aAutoItens[nAt1],{|x| AllTrim(x[1]) == "P8_HORA" })

						If !dbSeek( aAutoItens [nAt1, nP1Filial, 2] + aAutoItens [nAt1, nP1Matric, 2] + DTOS(aAutoItens [nAt1, nP1Data, 2]) + STR(aAutoItens [nAt1, nP1Hora, 2],5,2) )
							aAdd(aLogFile,STR0160 + " - " + DTOC(aAutoItens[nAt1,nP1Data,2]) + " - " + STR(aAutoItens[nAt1,nP1Hora,2],5,2) ) // "Marcação não encontrada!"
						Else
							If !Empty(SP8->P8_DATAAPO) .And. SP8->P8_APONTA = 'S'
								aAdd(aLogFile,STR0161 + " - " + DTOC(aAutoItens[nAt1,nP1Data,2]) + " - " + STR(aAutoItens[nAt1,nP1Hora,2],5,2) ) // "Marcação já apontada, não será possível a exclusão!"
							Else
								If SP8->P8_TIPOREG == "O"
									aAdd(aLogFile,STR0163 + " - " + DTOC(aAutoItens[nAt1,nP1Data,2]) + " - " + STR(aAutoItens[nAt1,nP1Hora,2],5,2) ) // "Marcação original não poderá ser excluida!"
								Else
									RecLock("SP8",.F.)
									dbDelete()
									MsUnLock()

									If lIntegDef
										Inclui := .F.
										Altera := .F.

										// indica o fonte para chamar na resposta da integração e dispara a integraçaõ
										SetRotInteg( "PONM010" )
										FwIntegdef( "PONM010" )
									EndIf
								Endif
							Endif
						Endif
					Next
				End Transaction

			Endif

		End Sequence

	Else

		aAdd( aChkAlias , "CTT" )
		aAdd( aChkAlias , "SP0" )
		aAdd( aChkAlias , "SP1" )
		aAdd( aChkAlias , "SP2" )
		aAdd( aChkAlias , "SP3" )
		aAdd( aChkAlias , "SP4" )
		aAdd( aChkAlias , "SP5" )
		aAdd( aChkAlias , "SP6" )
		aAdd( aChkAlias , "SP8" )
		aAdd( aChkAlias , "SP9" )
		aAdd( aChkAlias , "SPA" )
		aAdd( aChkAlias , "SPC" )
		aAdd( aChkAlias , "SPD" )
		aAdd( aChkAlias , "SPE" )
		aAdd( aChkAlias , "SPF" )
		aAdd( aChkAlias , "SPJ" )
		aAdd( aChkAlias , "SPK" )
		aAdd( aChkAlias , "SPM" )
		aAdd( aChkAlias , "SPW" )
		aAdd( aChkAlias , "SPY" )
		aAdd( aChkAlias , "SPZ" )
		aAdd( aChkAlias , "SR6" )
		aAdd( aChkAlias , "SR8" )
		aAdd( aChkAlias , "SRA" )
		aAdd( aChkAlias , "SRW" )
		aAdd( aChkAlias , "SX5" )

		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Ponto de Entrada antes da abertura da tela inicial. CH TDVVVX³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		IF ( !lWorkFlow .and. lPnm010IniBlock )
			ExecBlock( "PNM010INI"  , .F. , .F. )
		EndIF

		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Recupera Valores dos Parametros para Filtragem de ³
		³ Arquivos de Relogios.								³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	    GetParam(.T., cChar)

		IF !lWork
			aAdd(aButtons, {STR0124 ,{|oCenterPanel| fHistRFE(oCenterPanel)}, "RELATORIO"}) // "Visualizar"
		  	
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Se MV_FILTREL for setado para "S" habilita botao  ³
			³ para filtro de Arquivos de Relogios.				³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			If lFiltRel
				aAdd(aButtons, {STR0247,{|oCenterPanel| SelecRel(lWorkFlow, lUserDefParam, cProcFil, lProcFil, @aArqSel, cTrbTmp, oCenterPanel)}, "WATCH"}) // "Filtrar"
				lExib2Plan := .F.
	        Endif

			TNewProcess():New("PONM010", STR0001 , {|oSelf| Ponm010Processa(aArqSel, cChar, oSelf, lExec2Plan, lWork, cTrbTmp)}, STR0241 + STR0242 + STR0243, "PNM010", aButtons, Nil, NIL, NIL, !lSchedDef, .F., lExib2Plan) // "Leitura/Apontamento Marcaçöes" / "Este programa tem como objetivo efetuar a leitura do arquivo gerado pelo " "relógio, e apontar as marcaçöes de acordo com a tabela " "de horário do funcionário."

		ElseIF ( lChkAlias := RestartNotUse( aChkAlias ) )

			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Redefine nModulo de forma a Garantir que o Modulo seja o SIGAPON		³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			SetModulo( "SIGAPON" , "PON" )

			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Inicializa as Static do SIGAPON                 					 ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			PonDestroyStatic()

			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Executa o Processo de Leitura/Apontamento       					 ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			Ponm010Processa(,cChar)

			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Fecha todos os Arquivos Abertos em RestartNotUse()				 ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			CloseNotUse()

		EndIF
    Endif
EndIF

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Elimina Arquivo Temporario e Indice						   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
If !Empty(Select(cTrbTmp))
	dbSelectArea(cTrbTmp)
	dbCloseArea()
	If oTmpTabFO1 <> Nil
	    oTmpTabFO1:Delete()
	    Freeobj(oTmpTabFO1)
    EndIf
Endif

cFilAnt := cSvFilAnt

RestArea( aArea )

If lPn010Auto
	Return ( { Len(aLogFile) == 0 , aLogFile } )
Endif

Return( NIL )

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³Ponm010Processa³Autor³Equipe de RH        ³ Data ³ 01/03/96 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Realizar a Leitura e Classifica‡„o das Marca‡oes.          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ PonM010                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function Ponm010Processa(aArqSel, cChar, oProcess, lExec2Plan, lWork, cTrbTmp)

Local aAreaSP0			:= SP0->( GetArea() )
Local aAreaSP2			:= SP2->( GetArea() )
Local aAreaSP8			:= SP8->( GetArea() )
Local aAreaSPE			:= SPE->( GetArea() )
Local aAreaSRA			:= SRA->( GetArea() )
Local aLogs		 		:= Array(15)
Local aLogTitle	 		:= Array(15)
Local aAbreArqRel		:= {}
Local aArqRelFilt		:= {}
Local aArqInd	 		:= {}
Local aMultSRA			:= {}
Local aLogPerg			:= {}

Local bBuildDataFile	:= { || NIL }
Local bMsAguarde		:= { || NIL }

Local cArquivo			:= ""
Local cArqSrv			:= ""
Local cMarc				:= ""
Local cTipoArq			:= ""
Local cTipoArqOriginal	:= ""
Local cArqDbf	 		:= ""
Local cFlag				:= ""
Local cFilialSP0		:= ""
Local cFilAntSp0		:= "__cFilAntSp0__"
Local cAviso			:= ""
Local cMsg				:= ""
Local cMsgReg1			:= ""

Local lBuildDataFile	:= .F.
Local lCpyT2Srv			:= .F.
Local lSP0Comp			:= FWModeAccess("SP0",1) == "C" .AND. FWModeAccess("SP0",2) == "C" .AND. FWModeAccess("SP0",3) == "C"
Local lAbreArqRel		:= .F.
Local lGetMrBySra		:= .F.
Local lRobo				:= IsInCallStack("AUTJOBRUNCT")
Local nGetMrBySra		:= 0
Local nX				:= 0
Local nY				:= 0
Local nPosArqRel		:= 0
Local nPosRel			:= 0
Local nHandle    		:= 0
Local nCount     		:= 0
Local nLoop				:= 0
Local nCount2     		:= 0
Local nLoop2			:= 0
Local nTotNGrav			:= 0
Local dPerApoI			:= cToD("//")
Local dPerApoF			:= cToD("//")
Local cFilAtu			:= ""
Local lContinua			:= .F.
Local lMsBlQl			:= SP0->( FieldPos( "P0_MSBLQL" ) ) != 0
Local cTbTmpName        := ""
Local lIntRR1Car		:= SuperGetMv("MV_APICLOD", .F., .T.)
Local lIntRR1Sur		:= SuperGetMv("MV_APISUR", NIL, .F.)
Local lIntegRR1			:= .F.
Local dDtBaseAux		:= dDataBase
Local lMemoCalc			:= .F.

Static aSp8Fields
Static nSp8Fields
Static aRfeFields
Static nRfeFields
Static aMarcFields
Static nMarcFields
Static lExecLtr				:= .T.
Static oTmpSRARec

Private aTabCalend 			:= {}
Private aCalendFunc			:= {}
Private aTabPadrao			:= {}
Private aLogFile   			:= {}
Private aLogDemis			:= {}
Private aLogAdmis			:= {}
Private aLogFilDif			:= {}
Private aLogFiltro			:= {}
Private aLogFunAfa			:= {}
Private aLogMarFor			:= {}
Private aLogPerFec			:= {}
Private aLogAceFil			:= {}
Private aLogAcesso			:= {}
Private aLogRefeic			:= {}
Private aCodigos   			:= {}
Private aRecsBarG			:= {}
Private aSemCracha 			:= {}
Private aVisitante 			:= {}
Private aSemCpfPis 			:= {}
Private aTabRef				:= {}
Private aMarcNoGer			:= {}
Private bSraScope  			:= { || .F. }
Private bSraScop2  			:= { || .F. }
Private bAcessaSRA 			:= &("{ || " + ChkRH(FunName(),"SRA","2") + "}")
Private bCondDelAut			:= { || .T. }

Private cTxtAlias  			:= ""
Private cCracha    			:= ""
Private cMatricula 			:= ""
Private cFuncao    			:= ""
Private cGiro      			:= ""
Private cCusto	   			:= ""
Private cRelogio   			:= ""
Private cCCDe	   			:= ""
Private cCCAte     			:= ""
Private cTurnoDe   			:= ""
Private cTurnoAte  			:= ""
Private cMatDe     			:= ""
Private cMatAte    			:= ""
Private cNomeDe    			:= ""
Private cNomeAte   			:= ""
Private cFilOld    			:= "__cFilOld__"
Private cMatOld    			:= ""
Private __cSvFilAnt			:= cFilAnt
Private cFilDe	   			:= ""
Private cFilAte    			:= Space(3)
Private cRelDe     			:= ""
Private cRelAte    			:= Space(3)
Private cTimeIni			:= Time()
Private cTimeAprIni			:= ""
Private cFilTnoDe	 		:= ""
Private cFilTnoAte 			:= ""
Private cCategoria			:= ""
Private cFilTnoSRA 			:= ""
Private cFilSRA	 			:= ""
Private cAliasSP8	 		:= "SP8"
Private cQrySp8Alias		:= cAliasSP8
Private cPerAponta			:= Space( IF( ( GetSx3Cache( "P8_PAPONTA" , "X3_TAMANHO" ) == NIL ) , 16 , GetSx3Cache( "P8_PAPONTA" , "X3_TAMANHO" ) ) )
Private cSpaceRegra			:= Space( GetSx3Cache( "RA_REGRA  "	, "X3_TAMANHO" ) )
Private cP8TpMarca			:= Space( GetSx3Cache( "P8_TPMARCA" , "X3_TAMANHO" ) )
Private cP8Turno			:= Space( GetSx3Cache( "P8_TURNO  " , "X3_TAMANHO" ) )
Private cP8Ordem			:= Space( GetSx3Cache( "P8_ORDEM  " , "X3_TAMANHO" ) )
Private cSpCracha	 		:= ""
Private cSpPIS	 			:= ""
Private cSpyCracha	 		:= ""
Private cSpyVisita	 		:= ""
Private cSpyNumero	 		:= ""
Private cSpMatPrv	 		:= ""
Private cFilSP0    			:= ""
Private cFilSP9    			:= ""
Private cFilSPZ				:= ""
Private cLastFil			:= "__cLastFil__"
Private cFilTnoOld			:= "__cFilTnoOld__"
Private cFilTnoSeqOld		:= "__cFilTnoSeqOld__"
Private cFilSPE	 			:= ""
Private cFilRefAnt			:= ""
Private cDurLeitura			:= "00:00:00"
Private cDurApoClas			:= "00:00:00"
Private cIniVisita			:= ""
Private cFimVisita			:= ""
Private cDeAte     			:= ""
Private cMsgBarG1			:= ""
Private cLogFile			:= ""
Private cMsgLog				:= ""
Private cAliasCc			:= "CTT"
Private cCampoCc			:= ( PrefixoCpo( cAliasCc ) + "_CUSTO" )
Private cFilRelLid			:= ""
Private cFilRelUti			:= ""
Private cAliasRfe	 		:= "RFE"
Private cQryRfeAlias		:= cAliasRFE
Private cSituacoes 			:= ""

Private dPerDeVis			:= Ctod("//")
Private dPerAteVis			:= Ctod("//")
Private nSerIniVis
Private nSerFimVis

Private dPerIni				:= Ctod("//")
Private dPerFim				:= Ctod("//")
Private dData      			:= Ctod("//")

Private lChkPonMesAnt		:= .F.
Private lSR6Comp			:= Empty( xFilial( "SR6" ) )
Private lIncProcG1			:= .T.
Private lSraQryOpened		:= .F.
Private lCaClockIn 			:= SuperGetMv( "MV_APICLO0" , NIL , .F. )
Private lSuricato			:= SuperGetMv( "MV_TSREP" , NIL , .F. )
Private lTSREP				:= lSuricato .Or. lCaClockIn

Private nOrdemCc			:= RetOrdem( cAliasCc , ( PrefixoCpo( cAliasCc ) + "_FILIAL" ) + "+" + cCampoCc )
Private nHora      			:= 0
Private nCountTime			:= 0
Private nCount1Time			:= 0
Private nIncPercG1			:= 0
Private nIncPercG2			:= 0
Private nLidas	 			:= 0
Private nSraLstRec	 		:= 0
Private nGravadas	 		:= 0
Private nLenPIS 			:= 0
Private nLenCracha 			:= TamSX3("RA_CRACHA")[1]
Private nLenSPYCracha 		:= TamSX3("PY_CRACHA")[1]
Private nLenSPYNumero 		:= TamSX3("PY_NUMERO")[1]
Private nLenSPYVisita 		:= TamSX3("PY_VISITA")[1]
Private nLenMatPrv 			:= Len( SPE->PE_MATPROV )
Private nReaponta	 		:= 0
Private nFuncProc			:= 0
Private nTipo      			:= 0
Private nRecsBarG			:= 0
Private nDiasExtA			:= 0
Private nDiasExtP			:= 0
Private nRecnoSRA			:= 0
Private cPerg				:= ""
Private cFilFECAux   		:= ""
Private lPonWork			:= !lWorkNew .And. IsInCallStack("U_PonScheduler")
Private lSp8QryOpened := .F.

If lPort1510
	nLenPIS	:= TamSX3("RFE_PIS")[1]
EndIf

Default aSp8Fields		:= ( cAliasSP8 )->( dbStruct() )
Default nSp8Fields		:= Len( aSp8Fields )
Default oProcess		:= Nil
Default lExec2Plan		:= .F.
Default lWork			:= .F.
Default aArqSel			:= {}
Default cTrbTmp			:= ""

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Carrega os MV_'s do SX6 para Variaveis do Sistema            ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
cIniVisita	:= SuperGetMv("MV_VISIINI")
cFimVisita	:= SuperGetMv("MV_VISIFIM")
cIniVisita	:= IF(cIniVisita==NIL, Replicate("Z",nLenCracha), Substr(Alltrim(cIniVisita),1,nLenCracha))
cFimVisita	:= IF(cFimVisita==NIL, Replicate("Z",nLenCracha), Substr(Alltrim(cFimVisita),1,nLenCracha))
cSpCracha	:= Space( nLenCracha )
cSpPIS 		:= Space( nLenPIS )
cSpyCracha	:= Space( nLenSPYCracha )
cSpyNumero	:= Space( nLenSPYNumero )
cSpyVisita	:= Space( nLenSPYVisita )
cSpMatPrv	:= Space( nLenMatPrv )

nDiasExtA 	:= Min(Abs( SuperGetMv( "MV_GETDIAA" , NIL , 2  , cFilAnt ) ), 7)	//-- Quantidade de Dias a ser considerada antes do inicio do Periodo de  Apontamento a ser considerada na Leitura/Apontamento
nDiasExtP 	:= Min(Abs( SuperGetMv( "MV_GETDIAP" , NIL , 2  , cFilAnt ) ), 7)	//-- Quantidade de Dias a ser considerada apos  o fim do Periodo de  Apontamento a ser considerada na Leitura/Apontamento
cFilRelUti	:= If( !Empty( SuperGetMv("MV_PM010LA",,"N") ), SuperGetMv("MV_PM010LA"), "N" )
/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Setando as Perguntas que serao utilizadas no Programa        ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
If !lSchedDef
	If lWorkFlow .And. !lUserDefParam
		If !Empty(dDtIniWf)
			dPerIni := dDtIniWf
			dPerFim := dDtFimWf
		ElseIf !PerAponta( @dPerIni , @dPerFim , Nil , .F. )
			dPerIni := Ctod("//")
			dPerFim := Ctod("//")
		EndIf
	EndIf
	If FindFunction("RetPergLog")
		RetPergLog(aLogPerg, "PNM010")
	EndIf
Endif

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Carregando as Perguntas                                      ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
cFilDe    := IF( lWorkFlow .and. lUserDefParam .and. !lProcFilial , mv_par01 , IF( !lWorkFlow .or. lSchedDef , mv_par01 , IF( lProcFilial , Iif(lSP0Comp, cFilAnt, xFilial("SP0", cFilAnt)) , Space(FwGetTamFilial) ) ) )		//Filial De
cFilAte   := IF( lWorkFlow .and. lUserDefParam .and. !lProcFilial , mv_par02 , IF( !lWorkFlow .or. lSchedDef , mv_par02 , IF( lProcFilial , cFilAnt , Replicate(cChar,Len(SRA->RA_FILIAL) ) ) ) )								//Filial Ate
cCCDe     := IF( lWorkFlow .and. lUserDefParam , mv_par03 , IF( !lWorkFlow .or. lSchedDef , mv_par03 , ""	) )																													//Centro de Custo De
cCCAte    := IF( lWorkFlow .and. lUserDefParam , mv_par04 , IF( !lWorkFlow .or. lSchedDef , mv_par04 , Replicate(cChar,Len(SRA->RA_CC) )	) )																					//Centro de Custo Ate
cTurnoDe  := IF( lWorkFlow .and. lUserDefParam , mv_par05 , IF( !lWorkFlow .or. lSchedDef , mv_par05 , ""	) )																													//Turno De
cTurnoAte := IF( lWorkFlow .and. lUserDefParam , mv_par06 , IF( !lWorkFlow .or. lSchedDef , mv_par06 , Replicate(cChar,Len(SRA->RA_TNOTRAB) ) ) )																				//Turno Ate
cMatDe    := IF( lWorkFlow .and. lUserDefParam , mv_par07 , IF( !lWorkFlow .or. lSchedDef , mv_par07 , ""  ) )																													//Matricula De
cMatAte   := IF( lWorkFlow .and. lUserDefParam , mv_par08 , IF( !lWorkFlow .or. lSchedDef , mv_par08 , Replicate(cChar,Len(SRA->RA_MAT) ) ) )																					//Matricula Ate
cNomeDe   := IF( lWorkFlow .and. lUserDefParam , mv_par09 , IF( !lWorkFlow .or. lSchedDef , mv_par09 , ""	) )																													//Nome De
cNomeAte  := IF( lWorkFlow .and. lUserDefParam , mv_par10 , IF( !lWorkFlow .or. lSchedDef , mv_par10 , Replicate(cChar,Len(SRA->RA_NOME) ) ) )																					//Nome Ate
cRelDe    := IF( lWorkFlow .and. lUserDefParam , mv_par11 , IF( !lWorkFlow .or. lSchedDef , mv_par11 , ""	) )																													//Relogio De
cRelAte   := IF( lWorkFlow .and. lUserDefParam , mv_par12 , IF( !lWorkFlow .or. lSchedDef , mv_par12 , Replicate(cChar,Len(SP0->P0_RELOGIO) ) ) )																				//Relogio Ate
dPerDe 	  := IF( lWorkFlow .and. lUserDefParam , mv_par13 , IF( !lWorkFlow .or. lSchedDef , mv_par13 , dPerIni	) )																												//Periodo De
dPerAte	  := IF( lWorkFlow .and. lUserDefParam , IF( lLimitaDataFim , Min( dDataBase , mv_par14 ) , mv_par14 )  , IF( !lWorkFlow .or. lSchedDef , mv_par14 , IF( lLimitaDataFim , Min( dDataBase , dPerFim ) , dPerFim ) ) )	//Periodo Ate
cRegDe 	  := IF( lWorkFlow .and. lUserDefParam , mv_par15 , IF( !lWorkFlow .or. lSchedDef , mv_par15 , ""	) )																													//Regra De
cRegAte	  := IF( lWorkFlow .and. lUserDefParam , mv_par16 , IF( !lWorkFlow .or. lSchedDef , mv_par16 , Replicate(cChar,Len(SRA->RA_REGRA) ) ) )																					//Regra Ate
nTipo     := IF( lWorkFlow .and. lUserDefParam , mv_par17 , IF( !lWorkFlow .or. lSchedDef , mv_par17 , nProcessa	) )																											//Tipo de Processamento 1=Leitura 2=Apontamento 3=Ambos
nAponta	  := IF( lWorkFlow .and. lUserDefParam , mv_par18 , IF( !lWorkFlow .or. lSchedDef , mv_par18 , 4	) )																													//Leitura/Apontamento 1=Marcacoes 2=Refeicoes 3=Acesso 4=Marcacoes e Refeicoes 5=Todos
nReaponta := IF( lWorkFlow .and. lUserDefParam , mv_par19 , IF( !lWorkFlow .or. lSchedDef , mv_par19 , IF( lForceReaponta , 3 , 4 ) ) )																							//Reapontar 1= Marcacoes 2=Refeicoes 3=Ambos 4=Nenhum
nGetMrBySra:= IF( lWorkFlow .and. lUserDefParam , mv_par20 , IF( !lWorkFlow .or. lSchedDef , mv_par20 , nTipoRel )  )																											//Reapontar 1= Marcacoes 2=Refeicoes 3=Ambos 4=Nenhum
cCategoria := IF( lWorkFlow .and. lUserDefParam , mv_par21 , IF( !lWorkFlow .or. lSchedDef , mv_par21 , "ACDEGHMPST"	) )																										//Categorias
cSituacoes := IF( lWorkFlow .and. lUserDefParam , mv_par22 , IF( !lWorkFlow .or. lSchedDef , mv_par22 , " ADFT"	) )																												//Situações

If lWorkFlow .and. !lUserDefParam .and. Empty(dPerDe) .and. !lSchedDef
	If !GetPonMesDat( @dPerDe , @dPerAte , cFilProc )
		Return Nil
	EndIf
EndIf

// Busca os arquivos selecionados caso o parâmetro MV_FILTREL esteja ativo, não seja PONWORK e é para realizar leitura ou ambos.
If (nTipo == 1 .Or. nTipo == 3) .And. lFiltRel .And. !lWork
	aArqSel := {}
	If !Empty(cTrbTmp) .And. Select(cTrbTmp) > 0
		RhRel(cTrbTmp, @aArqSel)
	EndIf
EndIf

If (!lWorkFlow .Or. lSchedDef, dDataBase := dPerAte, Nil)

If lSP0Comp //Se relógio for compartilhado, verifica se fechamento esta sendo efetuado
	If !Pn090Open(@cMsg, @cAviso,.T.,DtoS(dPerDe) + DtoS(dPerAte),.T.,,,"A")
		If !lWorkFlow
			MsgStop( cMsg, cAviso )
		Else
			ConOut("")
			ConOut( cAviso )
			ConOut( cMsg )
			ConOut("")
		EndIf
		Return Nil
	EndIf
EndIf

// Verifica se deve usar a MSA ou RR1
If lSuricato .And. lCaClockIn
	If lIntRR1Car <> lIntRR1Sur
		Help(,, OemToAnsi(STR0174),, OemToAnsi(STR0175), 1, 0) // Se houver integração com a Carol e Suricato os parâmetros MV_APICLOD e MV_APISUR precisam estar com o mesmo conteúdo.
		Return .F.
	Else
		lIntegRR1 := If(lIntRR1Car,.T.,.F.)
	EndIf
ElseIf lSuricato .And. !lCaClockIn
	lIntegRR1 := If(lIntRR1Sur,.T.,.F.)
ElseIf !lSuricato .And. lCaClockIn
	lIntegRR1 := If(lIntRR1Car,.T.,.F.)
EndIf

// Se for usar a MSA e ela não existir, cria a tabela
If !lIntegRR1
	If !fTemTabMSA()
		fCriaTab(lWorkFlow)
	EndIf
EndIf 

If GetlMemoCalc()
	If (lMemoCalc := fMsgMCalc(nTipo))
		lMemoCalc := .T.
		fTabMCalc() 
		
		If nTipo == 1 .Or. nTipo == 3
			GravaMCalc("01", 0, "*** " + STR0206 + " ***") // "Memória de cálculo Leitura de Marcações de Ponto"
			fMcalcPar("01") // Grava os parâmetros no Log
			fMcalcTab("01") // Grava o compartilhamento das tabelas no log
			fMcalcFon("01") // Grava as datas dos fontes no log
		EndIf
		
		If nTipo == 2 .Or. nTipo == 3
			GravaMCalc("02", 0, "*** " + STR0248 + " ***") // "Memória de cálculo Apontamento de Horas Extras"
			fMcalcPar("02") // Grava os parâmetros no Log
			fMcalcTab("02") // Grava o compartilhamento das tabelas no log
			fMcalcFon("02") // Grava as datas dos fontes no log
		EndIf
	EndIf
EndIf

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Verifica o Tipo de Controle                              	   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
lGetMrBySra:= If( nGetMrBySra == 1, .T., .F. )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Inicializa Filial/Turno De/Ate							   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
cFilTnoDe	:= ( cFilDe + cTurnoDe )
cFilTnoAte	:= ( cFilAte + cTurnoAte )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Cria o Bloco dos Funcionarios que atendam ao Scopo	   	   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
bSraScope := { || (;
						( RA_TNOTRAB	>= cTurnoDe	) .and. ( RA_TNOTRAB	<= cTurnoAte	) .and. ;
						( RA_FILIAL		>= cFilde	) .and. ( RA_FILIAL		<= cFilAte		) .and. ;
						( RA_NOME		>= cNomeDe	) .and. ( RA_NOME		<= cNomeAte		) .and. ;
						( RA_MAT		>= cMatDe	) .and. ( RA_MAT		<= cMatAte		) .and. ;
						( RA_CC			>= cCCDe	) .and. ( RA_CC			<= cCCAte		) .and. ;
						( RA_REGRA		>= cRegDe	) .and. ( RA_REGRA		<= cRegAte		) .and. ;
						( RA_REGRA <> cSpaceRegra	) .and. ( RA_CATFUNC $ cCategoria ) .and. ;
						( RA_SITFOLH $ cSituacoes );
					  );
		     }
bSraScop2 := { || (;
						( RA_TNOTRAB	>= cTurnoDe	) .and. ( RA_TNOTRAB	<= cTurnoAte	) .and. ;
						( RA_NOME		>= cNomeDe	) .and. ( RA_NOME		<= cNomeAte		) .and. ;
						( RA_MAT		>= cMatDe	) .and. ( RA_MAT		<= cMatAte		) .and. ;
						( RA_CC			>= cCCDe	) .and. ( RA_CC			<= cCCAte		) .and. ;
						( RA_REGRA		>= cRegDe	) .and. ( RA_REGRA		<= cRegAte		) .and. ;
						( RA_REGRA <> cSpaceRegra	) .and. ( RA_CATFUNC $ cCategoria ) .and. ;
						( RA_SITFOLH $ cSituacoes );
					  );
		     }

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Carrega Log do Inicio do Processo de Leitura/Apontamento     ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
aAdd(aLogFile, STR0020  + Dtoc(MsDate()) + ', as ' + Time() + '.') // '- Inicio da Leitura/Apontamento em '

If oProcess <> Nil
	// Inclui a informação no log do tNewProcess
	oProcess:SaveLog(STR0020  + Dtoc(MsDate()) + ', as ' + Time() + '.') // '- Inicio da Leitura/Apontamento em '
EndIf

Begin Sequence

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Verifica o Tipo de Controle                              	   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	IF nGetMrBySra == 1 .and. nAponta = 3
		aAdd(aLogFile, STR0122 )// '*** ATENCAO: LEITURA NAO CONCLUIDA ***'
		aAdd(aLogFile, '- '+STR0121 )//'- Para o Controle de Acesso, a Leitura deve ser feita a apartir do Cad.Relógios.'
		Break
	ENDIF
	
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ >>				Se Leitura ou Ambos			  			<< ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	IF ( ( nTipo == 1 ) .or. ( nTipo == 3 ) )
		If oProcess <> Nil
			// Incrementa a regua de processamento principal
			oProcess:SetRegua1(3)

			// Incrementa a regua de processamento principal
			oProcess:IncRegua1(STR0089) // "Lendo..."
		EndIf
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Define o Bloco para a MsAguarde()                            ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		bMsAguarde		:= { ||;
									lBuildDataFile := SP0BldData(;
																	@cTipoArq,;
																	IF( !Empty( cArqSrv ) , cArqSrv , cArquivo ),;
																	@cArqDbf,;
																	@aArqInd,;
																	@cTxtAlias,;
																	@aLogFile,;
																	dPerDe	,;
																	dPerAte	,;
																	nDiasExtA,;
																	nDiasExtP,;
																	.F.,;
																	lWorkFlow,;
																	cArquivo;
																),;
									dbSelectArea( "SP0" );
							}
		
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Define o Bloco para a Criacao do .DBF a partir do .TXT       ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		bBuildDataFile	:= { ||	IF( lWorkFlow ,;
								( Eval( bMsAguarde ) ),;
								MsAguarde( bMsAguarde , OemToAnsi( STR0066 + STR0071 ) , If(SP0->P0_TIPOARQ="R",IIf(lCaClockIn,STR0166,STR0146),Lower( cArquivo )) );//"Carregando Marca‡”es. "###"Aguarde..." ### Arquivo de Integracao Carol Clock in...  ### "Arquivo de Integracao TSA..."
							   ),;
							lBuildDataFile;
			 	   			}
		
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Carrega Log do Inicio do Processo de Leitura                 ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		cMsgLog := ( STR0083  + Dtoc(MsDate()) + ', as ' + Time() + '.' ) // '- Inicio da Leitura em '
		aAdd( aLogFile , cMsgLog )
		IF lWorkFlow .And. !lRobo
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Enviando Mensagens para o Console do Server                 			³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			ConOut("")
			ConOut( cMsgLog )
			ConOut("")
		EndIF
		
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Inicializa as Ordens para Leitura                            ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		SP0->( dbSetOrder( RetOrdem( "SP0" , "P0_FILIAL+P0_RELOGIO" ) ) )								//-- Rel¢gios
	    SPY->( dbSetOrder( RetOrdem( "SPY" , "PY_FILIAL+PY_CRACHA+DTOS(PY_DTVISIT)+PY_NUMERO" ) ) )				//-- Visitas
	    SPZ->( dbSetOrder( RetOrdem( "SPZ" , "PZ_FILIAL+PZ_CRACHA+DTOS(PZ_DATA)" ) ) )							//-- Marcacoes de Visitas (Cracha  + Data da Marcacao)

		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Monta Filtro para Validacao do Relogio a ser Lido            ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		cFilSP0 := IF( Len(Alltrim( xFilial("SP0"))) > 0, cFilDe , Space(FwGetTamFilial) )
		cDeAte  := IF( lSP0Comp ,"P0_RELOGIO<=cRelAte","P0_FILIAL+P0_RELOGIO<=xFilial('SP0', cFilAte)+cRelAte")

		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Obtem Filial das Marcacoes de Acessos				           ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		cFilSPZ := xFilial("SPZ", cFilSP0)


		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Posiciona no Relogio de Acordo com os Parametros do usuario  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		SP0->( MsSeek( xFilial("SP0", cFilSP0) + cRelDe , .T. ) )

		If oProcess <> Nil		
			aRecsBarG := {}
			CREATE SCOPE aRecsBarG FOR (P0_FILIAL >= cRelDe .And. P0_FILIAL <= cDeAte)
			nRecsBarG := SP0->(ScopeCount(aRecsBarG))

			// Define a quantidade de registros para a regua de processamento secundária
			oProcess:SetRegua2(nRecsBarG)
		EndIf

		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Percorre todos os Relogios para Leitura                      ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		While SP0->( !Eof() .and. &( cDeAte ) )

			If oProcess <> Nil
				IF !( lSP0Comp )
					//'Filial:'###'Relogio:'
					cMsgBarG1 := SP0->( STR0097 + " " + P0_FILIAL + " / " + STR0096 + " " + P0_RELOGIO + " - " + P0_DESC )
				Else
					//'Relogio:'
					cMsgBarG1 := SP0->( STR0096 + " " + P0_RELOGIO + " - " + P0_DESC )
				EndIF

				// Incrementa a regua de processamento secundária
				oProcess:IncRegua2(cMsgBarG1) // "Filial: " " Relogio: "
			EndIf

			If lMsBlQl .And. SP0->P0_MSBLQL == '1'
				SP0->( dbSkip() )
				Loop
			EndIf
			
			If lPort1510
				IF !(SP0->P0_INC $"1.2")  //--Relogio sem configuracao
					aAdd(aLogFile, STR0144  + xFilial("SP0") + 	STR0096 + Space(1) + SP0->P0_RELOGIO) //"No cadastro de relógios, informe se o arquivo de marcações é incrementado ou não. Filial: "##"Relógio:"##
					SP0->( dbSkip() )
					Loop
				Else
					If ( !(Empty(SP0->P0_REP)) .AND. (SP0->P0_INC == '2') )
						aAdd(aLogFile, " - " + STR0164  + xFilial("SP0") + Space(1) + SP0->P0_RELOGIO + STR0165) //"O tipo do relógio: xxx # deve ser incremental. Corrija o cadastro.
						SP0->( dbSkip() )
						Loop
					EndIf
				EndIF
			EndIf
			
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Incrementa Contador de Tempos                      		   ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			++nCountTime
			
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Seta filial corrente do relógio lido se param. igual S	   ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			cFilRelLid := If ( cFilRelUti == "S" .and. ( Len(Alltrim( xFilial("SP0") ) ) > 0 ), SP0->P0_FILIAL, "" )
						
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Le Somente os Relogios Selecionados                          ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	        //-- Verifica se relogio esta entre os filtrados
			nPosRel:= 0
			If !(lWork) .And. lFiltRel .And.!Empty(aArqSel)
				If Empty((nPosRel:=Ascan(aArqSel,{|x |x[1] == SP0->(P0_FILIAL+P0_RELOGIO) } ) ))
					SP0->( dbSkip() )
					Loop
				EndIF
			Else
				IF SP0->(	( P0_FILIAL  < xFilial("SP0", cFilSP0) ) .or. ( P0_FILIAL  > xFilial("SP0", cFilAte) ) .or. ;
							( P0_RELOGIO < cRelDe  ) .or. ( P0_RELOGIO > cRelAte ) )
					SP0->( dbSkip() )
					Loop
				EndIF
			Endif
			
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Verifica o Tipo de Leitura a Ser Feita                       ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			IF !( nAponta == 5 )
				IF SP0->(;
							( ( nAponta == 1 ) .and. ( P0_CONTROL $ "R.A" ) );
							.or.;
							( ( nAponta == 2 ) .and. ( P0_CONTROL $ "P.A" ) );
							.or.;
							( ( nAponta == 3 ) .and. ( P0_CONTROL $ "R.P" ) );
							.or.;
							( ( nAponta == 4 ) .and. ( P0_CONTROL $ "A"   ) );
							)
					SP0->( dbSkip() )
					Loop
				EndIF
			EndIF
			
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Abandona o Processamento									   ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			IF ( lAbortPrint )
				aAdd(aLogFile, STR0028  + Dtoc(MsDate()) + ', as ' + Time() + ' ...') // '- Cancelado pelo Operador em '
				Break
			EndIF
			
			// Carrega a configuração básica do relógio ( cabeçalho ).
			cFilialSp0		:= SP0->P0_FILIAL
			cRelogio  		:= AllTrim( SP0->P0_RELOGIO )
			cTipoArq  		:= SP0->P0_TIPOARQ
			cTipoArqOriginal:=cTipoArq
			cControle 		:= SP0->P0_CONTROL
			
			If cFilialSP0 != cFilAntSp0
				cFilAntSp0 := cFilialSP0
				If !GetPonMesDat( @dPerIni , @dPerFim , cFilialSP0 )
					dPerIni := dPerDe
					dPerFim	:= dPerAte
				EndIf
			EndIf
			
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Se o controle da Leitura/Apontamento for pelo Cadastro de   ³
			³ relogios identifica o tipo do mesmo. 					      ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			If !lGetMrBySra
				
				If cControle == "A"
					/*/
					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					³ Para controle de Acesso de Visitantes Seta o Periodo        ³
					³ conforme pergunte.									      ³
					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
					
					dPerDeVis 	:= IF( lWorkFlow .and. lUserDefParam , mv_par13 , IF( !lWorkFlow .or. lSchedDef , mv_par13 , dPerIni	) )																												//Periodo De
					dPerAteVis	:= IF( lWorkFlow .and. lUserDefParam , IF( lLimitaDataFim , Min( dDataBase , mv_par14 ) , mv_par14 )  , IF( !lWorkFlow .or. lSchedDef , mv_par14 , IF( lLimitaDataFim , Min( dDataBase , mv_par14 ) , mv_par14 ) ) )	//Periodo Ate
					
					nSerIniVis 	:= Round( __fDhtoNS( dPerDeVis	,00.00 )  , 5 )
					nSerFimVis 	:= Round( __fDhtoNS( dPerAteVis	,23.59 )  , 5 )
				Endif
			Endif
			
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Trata a Selecao de Arquivos de Marcacoes a serem lidos       ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			If !(lWork) .AND. lFiltRel .AND.!Empty(aArqSel)
				aArqRelFilt:= aClone( aArqSel[nPosRel,2] )
			Else
				aArqRelFilt:= {SP0->P0_ARQUIVO}
			Endif
            //-- Corre cada Arquivo de Marcacoes para cada Relogio Lido
			For nLoop:= 1 To Len(aArqRelFilt)
				cArquivo  := AllTrim( aArqRelFilt[nLoop] )
				
				/*/
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Recupera o valor original do Tipo de Arquivo alterado pela   ³
				³ funcao SP0BldData()										   ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
				cTipoArq := cTipoArqOriginal
				
				/*/
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Nao Abre arquivos com D'river quando processo via WorkFlow    ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
				IF ( lWorkFlow )
					IF ( At( ":" , cArquivo ) > 0 )
						Conout(STR0022  + AllTrim(cArquivo) + STR0023)
						Conout(aLogFile, STR0024  + AllTrim(cRelogio))
						aAdd(aLogFile, STR0022  + AllTrim(cArquivo) + STR0023 )	// '- O arquivo '###' nao pode ser aberto e sera ignorado.'
						aAdd(aLogFile, STR0024  + AllTrim(cRelogio))			// '  Verifique a existencia do arquivo e a configuracao do Relogio '
						Loop
					EndIF
				EndIF
				
				/*/
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Tenta abrir o arquivo gerado pelo rel¢gio                    ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
				IF !( lAbreArqRel := AbreArqRel( cTipoArq , cArquivo , @nHandle , .F. , .F. , @cArqSrv , @lCpyT2Srv ) )
					If GetRemoteType() == 5 .Or. SubStr(cArquivo,1,1) != "\"
						aAdd(aLogFile, STR0167) // "- Durante a utilização do WebApp, arquivos que estão fora da pasta Protheus_Data não serão lidos."
						aAdd(aLogFile, STR0168) // "- Por favor coloque o arquivo do relógio dentro da pasta Protheus_Data e altere o cadastro do relógio"
						aAdd(aLogFile, STR0169) // "- ou execute a rotina pelo Smartclient."
						aAdd(aLogFile, "- " + STR0096 + " " + AllTrim( cRelogio ) ) // "- Relogio: "
					Else
						aAdd(aLogFile, STR0022  + AllTrim(cArquivo) + STR0023 ) // '- O arquivo '###' nao pode ser aberto e sera ignorado.'
						aAdd(aLogFile, STR0022  + AllTrim(cArquivo) + STR0023 ) // '- O arquivo '###' nao pode ser aberto e sera ignorado.'
						aAdd(aLogFile, STR0024  + AllTrim(cRelogio))			// '  Verifique a existencia do arquivo e a configuracao do Relogio '
					EndIf
					IF ( cTipoArq == "D" ) //-- Fecha o Arquivo atualmente aberto
						TxtAliasClose( @cTxtAlias )
					Else
						IF ( nHandle > 0 )
							fClose(nHandle)
						EndIF
					EndIF
					Loop
				Else
					IF ( ( nPosArqRel := aScan( aAbreArqRel , { |x| x[1] == cFilAnt } ) ) == 0 )
						aAdd( aAbreArqRel , { cFilAnt , SP0->P0_FILIAL  , { cArquivo } } )
					Else
						aAdd( aAbreArqRel[ nPosArqRel , 03 ] , cArquivo )
					EndIF
				EndIF
				
				/*/
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Verifica se o Arquivo foi Aberto                             ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
				IF ( cTipoArq == "T" )
					IF ( nHandle <= 0 )
						aAdd(aLogFile, STR0022  + AllTrim(cArquivo) + STR0023 )	// '- O arquivo '###' nao pode ser aberto e sera ignorado.'
						aAdd(aLogFile, STR0024  + AllTrim(cRelogio))			// '  Verifique a existencia do arquivo e a configuracao do Relogio '
						Loop
					Else
						fClose( nHandle )
					EndIF
				EndIF
				
				If lExecLtr .Or. cTipoArq == "T" .Or. lWorkNew
					
					// Memória de cálculo
					If lMemoCalc
						nCarol_Suri := If(cTipoArq == "R", If(Empty(SP0->P0_REP), 1, 2), 0)
						GravaMCalc("01", 0, "-" + STR0096 + " - " + cRelogio) // "Relógio"
						GravaMCalc("01", 1, SP0->P0_DESC + If(nCarol_Suri > 0, " (" + If(nCarol_Suri == 1, "Clock in", "Suricato") + ")", ""))
						GravaMCalc("01", 1, STR0208 + SP0->(If(Empty(P0_TPREP) .Or. P0_TPREP == "1", "1510", If(P0_TPREP == "2", "REP-A", If(P0_TPREP == "3", "REP-C", "REP-P"))))) // "Leiaute: "
						GravaMCalc("01", 1, STR0209 + cArquivo) // "Arquivo: "
					EndIf
					
					// Converte o Arquivo
					IF !Eval( bBuildDataFile )
						Loop
					EndIF
				EndIf
								
				//Se portaria estiver ativa utiliza tabela RFE ao invés do arquivo temporario
				If lPort1510
					cTxtAlias := "RFE"
				EndIf
				
				/*/
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Carregando as Marcacoes                                  	   ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
				IF lGetMrBySra
					GetMrBySra()
				Else
					GetMrBySp0()
				EndIF
				
				If ( lPort1510 )
					If SP0->P0_INC == '2' .And. SP0->P0_TIPOARQ != "R"
						// Se relogio nao incremental e nao TSA
						/*/
						ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						|Deleta marcacoes copiadas para RFE que nao foram classificadas.  |
						|Rotina necessaria pois quando o arquivo nao e incremental, se a  |
						|leitura for feita somente para um funcionario, todos os registros|
						|do TXT sao gravados na RFE, pois nao e feita consistencia dos    |
						|parametros informados no PONM010 no PONA030, isto ocasionava     |
						|marcacoes duplicadas na proxima leitura, no caso do mesmo TXT    |
						|ser lido, mas com parametros de branco a ZZZZZZ na matricula     |
						|por exemplo.													  |
						ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
						fDelRFE(SP0->P0_FILIAL, SP0->P0_RELOGIO)
					EndIf
				EndIf
				
				/*/
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Fecha e Exclui os Arquivos Temporarios					  ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
				CloseTxtAlias( cTxtAlias , cArqDbf , aArqInd , lCpyT2Srv , cArqSrv , cArquivo )
				
				// Retira o lock virtual criado para as tabelas
				If lPn090Lock
					Pnm090UnlockPer(,.T.,,,"A") //Desfaz o lock virtual da filial
					lPn090Lock := .F.
				EndIf
				
			Next
			
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Posiciona no Proximo Relogio                                ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			SP0->( dbSkip() )
			
		EndDo
		
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Gera o Log de Final de Leitura e Calcula o Tempo            ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		cDurLeitura := FinalLeitura( @aLogFile, nLidas, nGravadas, lWorkFlow, lRobo )
		
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Reinicializa Variaveis da BarGauge1                         ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		aRecsBarG	:= {}
		nRecsBarG	:= 0
	Else
		If oProcess <> Nil
			oProcess:SetRegua1(2)
		EndIf	
	EndIF
	
	If lSP0Comp
		lExecLtr := .F.
	Else
		lExecLtr := .T.
	EndIf
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Se for WorkFlow e nao Conseguiu Abrir os Arquivos para Leitura³
	³nao Efetua o Apontamento									   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	IF ( ( lWorkFlow ) .and. ( lProcFilial ) .and.  !( lApontaNaoLidas ) )
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Se nTipo for Leitura ou Leitura e Apontamento, Nao efetua    a³
		³Classificacao/Apontamento para Filiais nao Lidas			   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		IF ( ( nTipo == 1 ) .or. ( nTipo == 3 ) )
			IF !( lAbreArqRel := ( aScan( aAbreArqRel , { |x| x[1] == cFilAnt } ) > 0 ) )
				cMsgLog := ( STR0116 )		//'- Nao foi encontrado arquivo do Relogio para a filial: '
				aAdd( aLogFile , cMsgLog )
				IF ( lWorkFlow )
					/*/
					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					³ Enviando Mensagens para o Console do Server                 			³
					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
					ConOut("")
					ConOut( cMsgLog )
					ConOut("")
				EndIF
				cMsgLog := ( STR0117 )		//'- As marcacoes dessa filial nao foram apontadas.'
				aAdd( aLogFile , cMsgLog )
				IF ( lWorkFlow )
					/*/
					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					³ Enviando Mensagens para o Console do Server                 			³
					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
					ConOut("")
					ConOut( cMsgLog )
					ConOut("")
				EndIF
				Break
			EndIF
		EndIF
	EndIF

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Abandona o Processamento									   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	IF ( lAbortPrint )
		aAdd(aLogFile, STR0028  + Dtoc(MsDate()) + ', as ' + Time() + ' ...') // '- Cancelado pelo Operador em '
		Break
	EndIF
	
	// Para Leitura de Marcacoes de Acessos Nao Prossegue.
	IF ( nAponta == 3 )
	   Break
	EndIF
	
	// Log ao Inicio da Classificacao/Apontamento
	IF ( nTipo == 1 )
		cMsgLog := ( STR0112 + Dtoc(MsDate()) + ', as ' + Time() + '.' )	//'- Inicio da Classificacao em '
		aAdd(aLogFile, cMsgLog )
	ElseIF ( ( nTipo == 2 ) .or. ( nTipo == 3 ) )
		cMsgLog := ( STR0114 + Dtoc(MsDate()) + ', as ' + Time() + '.' )	//'- Inicio da Classificacao/Apontamento em '
		aAdd(aLogFile, cMsgLog )
	EndIF
	
	If lMemoCalc
		GravaMCalc("01", 0, "-" + STR0233) // "Classificação"
	EndIf
	
	// >>  		Classificação e/ou Apontamento                	<<
	IF lWorkFlow .And. !lRobo
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Enviando Mensagens para o Console do Server                 			³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		ConOut("")
		ConOut( cMsgLog )
		ConOut("")
	EndIF
	
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Inicializa as Ordens para a Classifica‡„o/Apontamento        ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	SP8->( dbSetOrder( RetOrdem( "SP8" , "P8_FILIAL+P8_MAT+DTOS(P8_DATA)+STR(P8_HORA,5,2)" ) ) )	//-- Marca‡”es
	SPF->( dbSetOrder( RetOrdem( "SPF" , "PF_FILIAL+PF_MAT+DtoS(PF_DATA)" ) ) )						//-- Altera‡”es de Turno
	
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Seleciona Informacoes dos Funcionarios                       ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	IF !SelectSra(.T.)
		Break
	EndIF
	
	// Contagem do tempo para classificação/Apontamento
	cTimeAprIni := Time()

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Atualiza Mensagem da Segunda Barra de Gauge        		   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	If oProcess <> Nil
		IF ( ( nTipo == 2 ) .or. ( nTipo == 3 ) )
			cMsgReg1 := STR0090 //'Apontando...'
		Else
			cMsgReg1 := STR0091 //'Classificando...'
		EndIF

		// Incrementa a regua de processamento principal
		oProcess:IncRegua1(cMsgReg1)

		// Define a quantidade de registros para a regua de processamento secundária se não for multi thread, caso contrário a régua será criada posteriormente
		If !lMultThread
			oProcess:SetRegua2(nSraLstRec)
		EndIf
	EndIf
	

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Reinicializa cFilOld										   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	cFilOld := "__cFilOld__"

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Processa o Apontamento de Marcacoes/Refeicoes                ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	While SRA->(;
					!Eof();
					.and.;
					( ( cFilTnoSRA := ( RA_FILIAL + RA_TNOTRAB ) ) >= cFilTnoDe );
					.and.;
		            ( cFilTnoSRA <= cFilTnoAte );
		        )

		If oProcess <> Nil .And. !lMultThread
			// Incrementa a regua de processamento secundária
			oProcess:IncRegua2(STR0238 + SRA->RA_FILIAL + " - " + SRA->RA_MAT) //
		EndIf

		If nTipo == 1 .And. !lTemTmpSRA .And. !Empty(aRegsRARFE)
			If aScan(aRegsRARFE, {|x| x[1] == SRA->R_E_C_N_O_}) == 0
				SRA->(dbSkip())
				Loop
			EndIf
		EndIf

		If (SRA->RA_FILIAL $ cFilFECAux)
			SRA->( dbSkip() )
			Loop
		EndIf

 		IF !( lSraQryOpened )
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Consiste filtro do intervalo De / Ate                        ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			IF SRA->( !Eval( bSraScope ) )
				SRA->( dbSkip() )
				Loop
 			EndIF
 		EndIF

		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Aborta o processamento caso seja pressionado Alt + A         ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		IF ( lAbortPrint )
			aAdd(aLogFile, STR0028  + Dtoc(MsDate()) + STR0059 + Time() + ' ...') // '- Cancelado pelo Operador em '###', as '
			Break
		EndIF

		If !( SRA->RA_FILIAL == cFilAtu ) // Verifica o periodo de apontamento da filial
			GetPonMesDat( @dPerApoI , @dPerApoF , SRA->RA_FILIAL )
			lContinua	:=  ( dPerApoI <= dPerAte )
			cFilAtu	:=	SRA->RA_FILIAL
		EndIf

		If ( lContinua )
			If !( lMultThread )
				// Efetua a Classificação e o Apontamento das Marcações
				IF !Ponm010Aponta( .T. )
					SRA->(dbSkip())
					LOOP
				EndIF
			Else
				aAdd(aMultSRA, {SRA->RA_FILIAL, SRA->RA_MAT} )
			EndIf
		EndIf
		
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Seleciona pr¢ximo funcion rio                               ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		SRA->( dbSkip() )
		
	EndDo

	If lMultThread
		Pnm010MultProc(aMultSRA, cFilFECAux, lPonWork, lSchedDef, lUserDefParam, oProcess)
	EndIf

	// Apura a Duracao da Classificacao/Apontamento
	cDurApoClas := RemainingTime(cTimeAprIni, GetFirstRemaining(), .F.)

/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Exclui fisicamente os registros deletados na SPC             ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	If !lWorkFlow
		MsgRun(OemToAnsi(STR0158),OemToAnsi(STR0058),{|| Chk_Pack( "SPC" , -1 , 1 ) } ) //"Preparando arquivo de apontamentos"###"Aguarde..."
	Else
		Chk_Pack( "SPC" , -1 , 1 )
	EndIf

Recover

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ >>				Se Leitura ou Ambos			  			<< ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	IF ( ( nTipo == 1 ) .or. ( nTipo == 3 ) )

		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Fecha e Exclui os Arquivos Temporarios					  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		CloseTxtAlias( cTxtAlias , cArqDbf , aArqInd , lCpyT2Srv , cArqSrv , cArquivo )

		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Gera o Log de Final de Leitura e Calcula o Tempo            ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		IF ( cDurLeitura == "00:00:00" )
			cDurLeitura := FinalLeitura( @aLogFile, nLidas, nGravadas, lWorkFlow, lRobo )
			++nCountTime
		EndIF
	EndIF


End Sequence

If lSP0Comp .or. lPn090Lock
	Pnm090UnlockPer(,.T.,,,"A") //Desfaz o lock virtual da filial
EndIf

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Fecha as Querys e Restaura os Padros                        ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
IF ( lSp8QryOpened )
	IF ( ( Select( cQrySp8Alias ) > 0 ) .and. !( cQrySp8Alias == cAliasSP8 ) )
		( cQrySp8Alias )->( dbCloseArea() )
		dbSelectArea( "SP8" )
	EndIF
EndIF
IF ( lSraQryOpened )
	SRA->( dbCloseArea() )
	ChkFile( "SRA" )
EndIF

lSraQryOpened := .F.

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Log ao Final da Classificacao/Apontamento                             ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
IF ( nTipo == 1 )
	cMsgLog := ( STR0113 + Dtoc(MsDate()) + ', as ' + Time() + '.' )	//'- Final da Classificacao em '
	aAdd( aLogFile , cMsgLog )
ElseIF ( ( nTipo == 2 ) .or. ( nTipo == 3 ) )
	cMsgLog := ( STR0115 + Dtoc(MsDate()) + ', as ' + Time() + '.' )	//'- Final da Classificacao/Apontamento em '
	aAdd( aLogFile , cMsgLog )
EndIF
IF lWorkFlow .And. !lRobo
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Enviando Mensagens para o Console do Server                 			³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	ConOut("")
	ConOut( cMsgLog )
	ConOut("")
EndIF

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Gera Log de Ocorrencias                                     ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
aAdd(aLogFile, STR0052 + Dtoc(MsDate()) + ", as " + Time() + ".")								// '- Final da Leitura/Apontamento em '

If oProcess <> Nil
	// Incrementa a regua de processamento 1 finalizando a execução do PONM010.
	oProcess:IncRegua1(STR0245) // "Processo Finalizado"
	
	// Inclui a informação no log do tNewProcess
	oProcess:SaveLog( STR0052 + Dtoc(MsDate()) + ", as " + Time() + ".") // '- Final da Leitura/Apontamento em '
EndIf

aAdd(aLogFile, "- " + STR0100 + ": " + RemainingTime( cTimeIni , GetFirstRemaining() , .F. ) )	// 'Decorridos'
IF ( ( nTipo == 1 ) .or. ( nTipo == 3 ) )
	aAdd(aLogFile , STR0105 + " " + cDurLeitura )								// '- Tempo de Leitura:'
	aAdd(aLogFile , STR0109 + MediumTime( cDurLeitura , nLidas , .T. ) )		// '- Tempo medio de Leitura: '
EndIF
IF ( nTipo == 1 )
	aAdd(aLogFile, STR0106 + " " + cDurApoClas )								// '- Tempo de Classificacao:'
	aAdd(aLogFile , STR0111 + MediumTime( cDurApoClas , nFuncProc , .T. ) )		// '- Tempo medio de Classificacao: '
ElseIF ( ( nTipo == 2 ) .or. ( nTipo == 3 ) )
	aAdd(aLogFile, STR0107 + " " + cDurApoClas )								// '- Tempo de Classificacao/Apontamento:'
	aAdd(aLogFile , STR0110 + MediumTime( cDurApoClas , nFuncProc , .T. ) )		// '- Tempo medio Classificacao/Apontamento: '
EndIF
cMsgLog := ( STR0078 + StrZero( nFuncProc , 10 ) + "." )
aAdd( aLogFile , cMsgLog )														// '- Numero de Funcionarios Processados: '

//-- Forca quebra de pagina pelo 'estouro' de linhas
IF !Empty( aMarcNoGer )
	aAdd( aLogFile , " "	 )
	aAdd( aLogFile , " "	 )
	aAdd( aLogFile , " "	 )
	aAdd( aLogFile , " "	 )
Endif

IF lWorkFlow .And. !lRobo
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Enviando Mensagens para o Console do Server                 			³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	ConOut("")
	ConOut( cMsgLog )
	ConOut("")
EndIF

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Carrega o Titulo das Ocorrencias do Log                     ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
aLogTitle[1]	:= STR0062	// "OCORRENCIAS DURANTE A LEITURA/APONTAMENTO"
aLogTitle[2]	:= STR0065	// "CRACHAS/PIS NAO CADASTRADOS"
aLogTitle[3]	:= STR0063	// "CRACHAS DE VISITANTES"
aLogTitle[4]	:= STR0170	// "INTEGRAÇÃO COM A CAROL"
aLogTitle[5]	:= STR0176 // "FUNCIONÁRIOS DEMITIDOS COM MARCAÇÕES"
aLogTitle[6]	:= STR0177 // "FUNCIONÁRIOS DE FILAIS DIFERENTES DO RELÓGIO"
aLogTitle[7]	:= STR0178 // "FUNCIONÁRIOS COM MARCAÇÕES ANTES DA ADMISSÃO"
aLogTitle[8]	:= STR0179 // "FUNCIONÁRIOS FORA DO FILTRO"
aLogTitle[9]	:= STR0180 // "FUNCIONÁRIOS COM MARCAÇÕES NO AFASTAMENTO"
aLogTitle[10]	:= STR0181 // "MARCAÇÕES FORA DO PERÍODO"
aLogTitle[11]	:= STR0182 // "PERÍODO FECHADO"
aLogTitle[12]	:= STR0183 // "PERMISSÃO DE ACESSO A FILIAL"
aLogTitle[13]	:= STR0184 // "MARCAÇÕES DE REFEIÇÃO"
aLogTitle[14]	:= STR0185 // "MARCAÇÕES DE ACESSO"
aLogTitle[15]	:= STR0237 // "MARCAÇÕES SEM PIS E CPF"

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Carrega em aLogs os Logs de Ocorrencia                      ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
aLogs[1] := aClone( aLogFile	)
aLogs[2] := aClone( aSemCracha	)
aLogs[3] := aClone( aVisitante	)

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Redefine o Array aSemCracha 								  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
aSemCracha := {}
If ( ( nCount := Len( aLogs[2] ) ) > 0 )
	nTotNGrav	:= 0

	For nX := 1 To nCount
		aAdd( aSemCracha , STR0186 + cValToChar(aLogs[2,nX,2]) + STR0187 + Left(aLogs[2,nX,1] + cSpPIS, nLenPis)) // "Existem marcações que não foram encontradas para o PIS/Cracha "
		nTotNGrav += aLogs[2,nX,2]
	Next nX

	aAdd(aSemCracha, "")
	aAdd(aSemCracha, STR0188 + cValToChar(nTotNGrav)) // "Total de Marcações Não Gravadas: "
EndIF
aLogs[2] := aClone( aSemCracha )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Redefine o Array aVisitante				  				  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
aVisitante := {}
IF ( ( nCount := Len( aLogs[3] ) ) > 0 )
	aAdd( aVisitante , STR0064 ) // '- No. Cracha/PIS   No. de Marcacoes Encontradas'
	aAdd( aVisitante , "" )
	For nX := 1 To nCount
		aAdd( aVisitante , Left( aLogs[ 3 , nX , 1 ] + cSpCracha , nLenCracha ) + " - " + StrZero( aLogs[ 3 , nX , 2 ] , 5 ) )
	Next nX
EndIF
aLogs[3] := aClone( aVisitante )


/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Carrega Informações sobre marcações não geradas no Log de Ocorrencia   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
IF !Empty( aMarcNoGer )

   AADD(aLogTitle, STR0137 ) // 'Marcações Não Geradas'
   AADD(aLogs, aClone(aMarcNoGer))

   	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Redefine o Array aMarcNoGer 								  ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	aMarcNoGer := {}
	IF ( ( nCount := Len( aLogs[Len(aLogs)] ) ) > 0 )
		AADD(aMarcNoGer, PADR(STR0138,10) + SPACE(1) + PADR(STR0139,90) + SPACE(1) +  STR0140 ) // //' Data     Marcações                                        Observação'

	  	For nLoop := 1 To nCount
	  	    nCount2		:=Len(aLogs[Len(aLogs), nLoop, 2 ] )
	  	    cMat		:=aLogs[Len(aLogs), nLoop, 1 ]
   		    aAdd( aMarcNoGer , __PrtThinLine() )
	  	    aAdd( aMarcNoGer , cMat )
   		    aAdd( aMarcNoGer , __PrtThinLine() )
	  		For nLoop2:= 1 To nCount2
			   	//-- Corre todas as marcacoes do dia
			   	dData	:= PADR(Dtoc(aLogs[Len(aLogs), nLoop, 2, nLoop2, 1 ]),10) //Data
		 	   	cMsg 	:= STR0141 											//"Marcaçõpes em quantidade ímpar"
		   		cMarc	:= ""
				For nX := 1 TO Len( aLogs[ Len(aLogs), nLoop, 2, nLoop2, 2] )     //Array das Marcacoes
					If Len(cMarc) > 81
					   IF "IMPAR"$ UPPER(aLogs[Len(aLogs), nLoop, 2, nLoop2,3 ])  //Tipo de Ocorrencia ('Impar')
				  		  aAdd( aMarcNoGer , dData  + SPACE(1) +  PADR(cMarc, 90) )
			  			  dData 	:= Space(10)
						  cMarc	:= ""
					   ENDIF
					Endif

	    			cFlag:=  If( aLogs[ Len(aLogs), nLoop,  2, nLoop2, 2, nX, 4 ] <> "A", Space(3), "[A]" )
	    			cMarc+= StrTran(StrZero(aLogs[ Len(aLogs), nLoop,  2, nLoop2, 2, nX, 2 ],5,2),'.',':') + cFlag + Space(1)

				Next nX
				IF "IMPAR"$ UPPER(aLogs[Len(aLogs), nLoop,  2, nLoop2, 3 ])
					aAdd( aMarcNoGer , dData + SPACE(1) +  PADR(cMarc, 90) + SPACE(1) + cMsg ) // "Marcaçõpes em quantidade ímpar"
				ENDIF
			Next nLoop2
		Next nLoop
	EndIF
	aLogs[ Len(aLogs) ] := aClone( aMarcNoGer )

Endif

If lCaClockIn
	aLogs[4] := { STR0171 + SuperGetMv("MV_APICLO3", .F., '') } //"Configuração do parâmetro MV_APICLO3: "
EndIf

// Log marcações não gravadas para funcionários que possuem marcações após a data de demissão
aLogs[5] := aClone(aLogDemis)
aLogDemis := {}

If !Empty(aLogs[5])
	nTotNGrav	:= 0
	nCount		:= Len(aLogs[5])
	
	For nY := 1 To nCount
		aAdd(aLogDemis, STR0189 + AllTrim(aLogs[5,nY,1]) + " - " + aLogs[5,nY,2] + STR0190 + cValToChar(aLogs[5,nY,4]) + STR0201 + "(" + aLogs[5,nY,3] + ")") // "O Funcionário da filial e matrícula possui marcações após sua demissão"
		nTotNGrav += aLogs[5,nY,4]
	Next

	aAdd(aLogDemis, "")
	aAdd(aLogDemis, STR0188 + cValToChar(nTotNGrav)) // "Total de Marcações Não Gravadas: "
EndIf

aLogs[5] := aClone(aLogDemis)

// Log marcações não gravadas para funcionários que pertencem a outra filial do relógio executado
aLogs[6] := aClone(aLogFilDif)
aLogFilDif := {}

If !Empty(aLogs[6])
	nTotNGrav	:= 0
	nCount		:= Len(aLogs[6])
	
	For nY := 1 To nCount
		aAdd(aLogFilDif, STR0189 + AllTrim(aLogs[6,nY,1]) + " - " + aLogs[6,nY,2] + STR0190 + cValToChar(aLogs[6,nY,4]) + STR0191 +"(" + AllTrim(aLogs[6,nY,3]) + ")") // "O Funcionário da filial e matrícula possui marcações de um relógio de outra filial"
		nTotNGrav += aLogs[6,nY,4]
	Next

	aAdd(aLogFilDif, "")
	aAdd(aLogFilDif, STR0188 + cValToChar(nTotNGrav)) // "Total de Marcações Não Gravadas: "
EndIf

aLogs[6] := aClone(aLogFilDif)

// Log marcações não gravadas para funcionários que possuem marcações antes da data de admissão
aLogs[7] := aClone(aLogAdmis)
aLogAdmis := {}

If !Empty(aLogs[7])
	nTotNGrav	:= 0
	nCount		:= Len(aLogs[7])
	
	For nY := 1 To nCount
		aAdd(aLogAdmis, STR0189 + AllTrim(aLogs[7,nY,1]) + " - " + aLogs[7,nY,2] + STR0190 + cValToChar(aLogs[7,nY,4]) + STR0192 + "(" + aLogs[7,nY,3] + ")") // "O Funcionário da filial e matrícula possui marcações antes da sua admissão"
		nTotNGrav += aLogs[7,nY,4]
	Next

	aAdd(aLogAdmis, "")
	aAdd(aLogAdmis, STR0188 + cValToChar(nTotNGrav)) // "Total de Marcações Não Gravadas: "
EndIf

aLogs[7] := aClone(aLogAdmis)

// Log marcações não gravadas para funcionários que não estão no filtro da execução
aLogs[8] := aClone(aLogFiltro)
aLogFiltro := {}

If !Empty(aLogs[8])
	nTotNGrav	:= 0
	nCount		:= Len(aLogs[8])
	
	For nY := 1 To nCount
		aAdd(aLogFiltro, STR0189 + AllTrim(aLogs[8,nY,1]) + " - " + aLogs[8,nY,2] + STR0190 + cValToChar(aLogs[8,nY,3]) + STR0193) // "O Funcionário da filial e matrícula possui marcações que não serão gravadas por estar fora do filtro"
		nTotNGrav += aLogs[8,nY,3]
	Next

	aAdd(aLogFiltro, "")
	aAdd(aLogFiltro, STR0188 + cValToChar(nTotNGrav)) // "Total de Marcações Não Gravadas: "
EndIf

aLogs[8] := aClone(aLogFiltro)

// Log marcações não gravadas para funcionários afastados
aLogs[9] := aClone(aLogFunAfa)
aLogFunAfa := {}

If !Empty(aLogs[9])
	nTotNGrav	:= 0
	nCount		:= Len(aLogs[9])
	
	For nY := 1 To nCount
		aAdd(aLogFunAfa, STR0189 + AllTrim(aLogs[9,nY,1]) + " - " + aLogs[9,nY,2] + STR0190 + cValToChar(aLogs[9,nY,5]) + STR0194 + "(" + aLogs[9,nY,3] + STR0202 + aLogs[9,nY,4] + ")") // "O Funcionário da filial e matrícula possui marcações em seu afastamento"
		nTotNGrav += aLogs[9,nY,5]
	Next

	aAdd(aLogFunAfa, "")
	aAdd(aLogFunAfa, STR0188 + cValToChar(nTotNGrav)) // "Total de Marcações Não Gravadas: "
EndIf

aLogs[9] := aClone(aLogFunAfa)

// Log marcações não gravadas fora do período
aLogs[10] := aClone(aLogMarFor)
aLogMarFor := {}

If !Empty(aLogs[10])
	nTotNGrav	:= 0
	nCount		:= Len(aLogs[10])
	
	For nY := 1 To nCount
		aAdd(aLogMarFor, STR0186 + cValToChar(aLogs[10,nY,2]) + STR0195 + AllTrim(aLogs[10,nY,1])) // "Existem marcações que não foram gravadas devido estarem fora do período da filial "
		nTotNGrav += aLogs[10,nY,2]
	Next

	aAdd(aLogMarFor, "")
	aAdd(aLogMarFor, STR0188 + cValToChar(nTotNGrav)) // "Total de Marcações Não Gravadas: "
EndIf

aLogs[10] := aClone(aLogMarFor)

// Log marcações não gravadas fora do período
aLogs[11] := aClone(aLogPerFec)
aLogPerFec := {}

If !Empty(aLogs[11])
	nTotNGrav	:= 0
	nCount		:= Len(aLogs[11])
	
	For nY := 1 To nCount
		aAdd(aLogPerFec, STR0186 + cValToChar(aLogs[11,nY,2]) + STR0196 + AllTrim(aLogs[11,nY,1]) + STR0197) // "Existem marcações que não foram gravas devido o período da filial estar fechado"
		nTotNGrav += aLogs[11,nY,2]
	Next

	aAdd(aLogPerFec, "")
	aAdd(aLogPerFec, STR0188 + cValToChar(nTotNGrav)) // "Total de Marcações Não Gravadas: "
EndIf

aLogs[11] := aClone(aLogPerFec)

// Permissão de acesso a filial
aLogs[12] := aClone(aLogAceFil)
aLogAceFil := {}

If !Empty(aLogs[12])
	nTotNGrav	:= 0
	nCount		:= Len(aLogs[12])
	
	For nY := 1 To nCount
		aAdd(aLogAceFil, STR0198 + AllTrim(aLogs[12,nY,1]) + STR0199 + cValToChar(aLogs[12,nY,2]) + STR0200) // "O usuário logado não possui acesso a filial e por isso marcações não foram gravadas"
		nTotNGrav += aLogs[12,nY,2]
	Next

	aAdd(aLogAceFil, "")
	aAdd(aLogAceFil, STR0188 + cValToChar(nTotNGrav)) // "Total de Marcações Não Gravadas: "
EndIf

aLogs[12] := aClone(aLogAceFil)

// Marcações de refeições não gravadas.
aLogs[13] := aClone(aLogRefeic)
aLogRefeic := {}

If !Empty(aLogs[13])
	aAdd(aLogRefeic, AllTrim(aLogs[13,1,1]))
	aAdd(aLogRefeic, "")
	aAdd(aLogRefeic, STR0188 + cValToChar(aLogs[13,1,2])) // "Total de Marcações Não Gravadas: "
EndIf

aLogs[13] := aClone(aLogRefeic)

// Marcações de acesso não gravadas.
aLogs[14] := aClone(aLogAcesso)
aLogAcesso := {}

If !Empty(aLogs[14])
	aAdd(aLogAcesso, AllTrim(aLogs[14,1,1]))
	aAdd(aLogAcesso, "")
	aAdd(aLogAcesso, STR0188 + cValToChar(aLogs[14,1,2])) // "Total de Marcações Não Gravadas: "
EndIf

aLogs[14] := aClone(aLogAcesso)

// Marcações Sem PIS e CPF não gravadas.
aLogs[15] := aClone(aSemCpfPis)
aLogAcesso := {}

If !Empty(aLogs[15])
	aAdd(aSemCpfPis, AllTrim(aLogs[15,1,1]))
	aAdd(aSemCpfPis, "")
	aAdd(aSemCpfPis, STR0188 + cValToChar(aLogs[15,1,2])) // "Total de Marcações Não Gravadas: "
EndIf

aLogs[15] := aClone(aSemCpfPis)

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Gera e Mostra o Log 										  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
If !lWorkFlow
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Gera e Mostra o Log 										  ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	cTbTmpName := "L" + dtos(dDataBase) + StrTran(Time(),':','',1,4)
	cLogFile := fMakeLog(	aLogs																,;	//Array que contem os Detalhes de Ocorrencia de Log
							aLogTitle															,;	//Array que contem os Titulos de Acordo com as Ocorrencias
							"PNM010"															,;	//Pergunte a Ser Listado
							.T.																	,;	//Se Havera "Display" de Tela
							IF( lProcFilial , cTbTmpName , Nil )								,;	//Nome Alternativo do Log
							NIL																	,;	//Titulo Alternativo do Log
							"G"																	,;	//Tamanho Vertical do Relatorio de Log ("P","M","G")
							"L"																	,;	//Orientacao do Relatorio ("P" Retrato ou "L" Paisagem )
							NIL																	,;	//Array com a Mesma Estrutura do aReturn
							NIL 						 										,;	//Se deve Manter ( Adicionar ) no Novo Log o Log Anterior
							aLogPerg															 ;	//Array com as perguntas selecionadas
						 )
Endif

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Ponto de Entrada ao Final do Processo						  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
IF ( lPonaPo8Block )
	ExecBlock( "PONAPO8" , .F. , .F. , { aAbreArqRel , cLogFile } )
EndIF

aRegsRARFE := Nil

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Restaura os Dados de Entrada         						  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
RestArea( aAreaSP0 )
RestArea( aAreaSP2 )
RestArea( aAreaSP8 )
RestArea( aAreaSPE )
RestArea( aAreaSRA )

If ValType(oTmpSRARec) == "O"
	oTmpSRARec:Delete()
	FwFreeObj(oTmpSRARec)
EndIf

If lMemoCalc
	
	//Gera o arquivo e exclui os dados da tabela temporária
	If nTipo == 1 .Or. nTipo == 3
		ArqMCalcPN("01")
	EndIf
	
	If nTipo == 2 .Or. nTipo == 3
		ArqMCalcPN("02")
	EndIf
	
	CleanMCalc()
	
EndIf

If(!Empty(GetGlbValue("__cUserPon")), ClearGlbValue("__cUserPon"), Nil)

dDataBase := dDtBaseAux

Return( NIL )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³CloseTxtAlias³ Autor ³Marinaldo de Jesus   ³ Data ³22/01/2003³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Fecha a Area e Exclui os Arquivos Temporarios utilizados   no³
³          ³processo de Leitura das Marcacoes							 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL                                                  	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Uso      ³PONM010                                                      ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function CloseTxtAlias( cTxtAlias , cArqDbf , aArqInd , lCpyT2Srv , cArqSrv , cArquivo )

Local nLoop
Local nLoops
Local cPonArq := If( !Empty( SuperGetMv("MV_POARQ",.F.,"N") ), SuperGetMv("MV_POARQ",.F.,"N"), "2" )

If !lPort1510
	IF ( !Empty( cTxtAlias ) .and. ( Select( cTxtAlias ) > 0 ) )
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Fecha o Arquivo atualmente aberto 						  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		TxtAliasClose( cTxtAlias )
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Exclui os Arquivos Temporarios 							  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		IF ( cTxtAlias == "__TMPRELOG" )
			fErase( cArqDbf )
			nLoops := Len( aArqInd )
			For nLoop := 1 To nLoops
				fErase( aArqInd[ nLoop ] )
			Next nLoop
		EndIF
	EndIF
EndIf

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³cPonArq - indica que só copia o arquivo para o StartPath caso ³
³o parametro MV_POARQ esteja com valor NÃO					   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
If (cPonArq != "1")
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Se copiou para o server, Exclui                           			 ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	IF ( ( lCpyT2Srv ) .and. !Empty( cArqSrv ) )
		IF !( Upper( AllTrim( cArquivo ) ) == Upper( AllTrim( cArqSrv ) ) )
			fErase( cArqSrv )
		EndIF
	EndIF
EndIf

Return( NIL )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³FinalLeitura ³ Autor ³Marinaldo de Jesus   ³ Data ³22/01/2003³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Gera Log do Final da Leitura e Retorna o Tempo de Processamen³
³          ³to															 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL                                                  	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Uso      ³PONM010                                                      ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function FinalLeitura( aLogFile, nLidas, nGravadas, lWorkFlow, lRobo )

Local cDurLeitura	:= "00:00:00"
Local cMsgLog		:= ""

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Adiciona ao Log o Final do Processo de Leitura e o Numero de³
³ Marcacoes Lidas											  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
cMsgLog := ( STR0084  + Dtoc(MsDate()) + ', as ' + Time() + '.' )	// '- Final da Leitura em '
aAdd( aLogFile , cMsgLog )
IF lWorkFlow .And. !lRobo
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Enviando Mensagens para o Console do Server                 			³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	ConOut("")
	ConOut( cMsgLog )
	ConOut("")
EndIF
cMsgLog := ( STR0067  + StrZero( nLidas	, 10 ) + '.' )			// '- Numero de Marcacoes Lidas: '
aAdd( aLogFile , cMsgLog )
IF lWorkFlow .And. !lRobo
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Enviando Mensagens para o Console do Server                 			³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	ConOut("")
	ConOut( cMsgLog )
	ConOut("")
EndIF
cMsgLog := ( STR0060  + StrZero( nGravadas , 10 ) + '.' )			// '- Numero de Marcacoes Gravadas: '
aAdd( aLogFile , cMsgLog )
IF lWorkFlow .And. !lRobo
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Enviando Mensagens para o Console do Server                 			³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	ConOut("")
	ConOut( cMsgLog )
	ConOut("")
EndIF

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Guarda o Tempo Final da Leitura							  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
cDurLeitura := RemainingTime( cTimeIni , GetFirstRemaining() , .F. )

Return( cDurLeitura )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o	   ³Ponm010Ref³ Autor ³Equipe Advanced RH     ³ Data ³06/03/1996³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³ Grava as marca‡”es do refeit¢rio.						  	³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Uso  	   ³ PONM010													³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function Ponm010Ref(	cCodRel		,;	//Codigo do Relogio
							cFil		,;	//Filial do Funcionario
							cMatricula	,;	//Matricula do Funcionario
							dData		,;	//Data da Marcacao
							nHorario	,;	//Horario da Marcacao
							cCusto		,;	//Centro de Custo da Marcacao
							cTipDesp	,;	//Tipo do Parametro Despreza Marcacao
							nDespRef	,;	//Quantidade/Minutos a Serem Desprezadas
							nGravadas	 ;	//Quantidade de Marcacoes Gravadas
						 )

Local cSvFilAnt	:= cFilAnt
Local cSeek		:= ""
Local cKey		:= ""
Local lMin		:= .F.
Local lGrava	:= .T.
Local nRefs		:= 1

DEFAULT nGravadas	:= 0

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Se Existir o Parametro MV_DESPREF verifica quais marcacoes  de³
³verao ser Desprezadas	- By Naldo							   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
IF ( !Empty(cTipDesp) .and. cTipDesp $ "N_M" )
	IF ( lMin  := ( cTipDesp == "M" ) )
		nDespRef	:= __Hrs2Min( nDespRef )
		cSeek		:= ( cFil + cMatricula + Dtos(dData) )
	Else
		cSeek		:= ( cFil + cMatricula + Dtos(dData) + Str(nHorario,5,2) )
	EndIF
	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Descricao: Ponto de Entrada antes da gravacao padrao da refei-³
	³cao. Se for retornado .T. processa a gravacao padrao caso     ³
	³contrario nao executa a gravacao.							   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	If lPnm010R2Block
	   	IF ( ValType( uRetBlock := ExecBlock("PNM010R2",.F.,.F.,;
		   	{	 cCodRel	,;	//Codigo do Relogio
				 cFil		,;	//Filial do Funcionario
				 cMatricula	,;	//Matricula do Funcionario
				 dData		,;	//Data da Marcacao
				 nHorario	,;	//Horario da Marcacao
				 cCusto		,;	//Centro de Custo da Marcacao
				 cTipDesp	,;	//Tipo do Parametro Despreza Marcacao
				 nDespRef	;	//Quantidade/Minutos a Serem Desprezadas
		   })  ) == "L" )
	   	   lGrava:= uRetBlock
	    Else
		    lGrava:= .F.
	    Endif
	Else
		IF SP5->( MsSeek( cSeek , .F. ) )
			cKey := ( cFil + cMatricula + Dtos(dData) )
			While SP5->( !Eof() .and. ( P5_FILIAL + P5_MAT + Dtos(P5_DATA) == cKey ) ;
							    .and. IF(lMin,lMin,P5_HORA == nHorario ) )

				IF ( !( lMin ) .and. ( ( ++nRefs ) > nDespRef ) )
					lGrava := .F.
					If Empty(aLogRefeic)
						aAdd(aLogRefeic,{STR0203,1})
					Else
						aLogRefeic[1,2]++
					EndIf
				ElseIF ( ( lMin ) .and. ( __Hrs2Min( SP5->( DataHora2Val(P5_DATA,P5_HORA,dData,nHorario) ) ) <= nDespRef ) )
					lGrava := .F.
					If Empty(aLogRefeic)
						aAdd(aLogRefeic,{STR0204,1})
					Else
						aLogRefeic[1,2]++
					EndIf
				EndIF
				IF !( lGrava )
					Exit
				EndIF
				SP5->( dbSkip() )
			EndDo
		EndIF
	Endif
EndIF

IF ( lGrava )
    //-- Troca Filial para Integridade
    cFilAnt	:= IF( !Empty( cFil ) , cFil , cFilAnt )
	IF RecLock( "SP5" , .T. , .T. )
		SP5->P5_FILIAL	:= cFil
		SP5->P5_MAT		:= cMatricula
		SP5->P5_DATA	:= dData
		SP5->P5_HORA	:= nHorario
		SP5->P5_RELOGIO := cCodRel
		SP5->P5_CC		:= cCusto
		SP5->P5_FLAG	:= "E"
		SP5->( MsUnlock() )
	EndIF
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Incrementa o contador de Marcacoes Gravadas				   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	++nGravadas
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Ponto de Entrada Apos a Gravacao de Um novo Registro de  Refei³
	³cao - By Naldo												   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	IF ( lPonapo7Block )
		ExecBlock( "PONAPO7" , .F. , .F. , SP5->( Recno() ) )
	EndIF
EndIF

//-- Restaura valor original da Filial de Entrada
cFilAnt	:=	cSvFilAnt

Return( NIL )

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o	 ³fChkPer   ³ Autor ³Equipe Advanced RH     ³ Data ³05/12/1998³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Valida o Periodo de acordo com o MV_PAPONTA				  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³fChkPer( dPerDe , dPerAte )								  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso		 ³PONM010	 												  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Static Function fChkPer( dPerDe , dPerAte , cFil )

Local dPerIni	:= Ctod("//")
Local dPerFim	:= Ctod("//")
Local lRet		:= .T.

DEFAULT dPerDe	:= Ctod("//")
DEFAULT dPerAte	:= Ctod("//")

Begin Sequence
	IF !( lRet := !Empty( dPerDe ) )
		Break
	EndIF
	IF !( lRet := !Empty( dPerAte ) )
		Break
	EndIF
	IF !( lRet := !( dPerDe > dPerAte ) )
		Break
	EndIF
	IF !( lRet := GetPonMesDat( @dPerIni , @dPerFim , cFil ) )
		Break
	EndIF
	IF !( lRet := !( dPerAte < dPerIni ) )
		Break
	EndIF
	IF !( lRet := !( dPerDe >= dPerIni .and. dPerDe <= dPerFim .and. dPerAte > dPerFim ) )
		Break
	EndIF
End Sequence

Return( lRet )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³GetNewResult³ Autor ³Marinaldo de Jesus    ³ Data ³31/07/2001³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Remonta aResult Apenas com Marcacoes nao Alteradas e ja  Apon³
³          ³tadas														 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³GetNewResult(@aResult,aLastApo,aMarcacoes,aTabCalend)		 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³aResult		-> Array com os Resultados Dia a Dia			 ³
³          ³aLastApo	-> Array com os Resultados Dia a Dia Ja Apontados³
³          ³aMarcacoes	-> Array com as Marcacoes a Serem Apontadas      ³
³          ³aTabCalend 	-> Calendario de Marcacoes                       ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL                                                  	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Uso      ³PONM010                                                      ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function GetNewResult(aResult,aLastApo,aMarcacoes,aTabCalend)

Local cOrdem	:= ""
Local nFornY	:= Len( aLastApo )
Local nOrdIni	:= Val( aTabCalend[ 01 , CALEND_POS_ORDEM ] )
Local nOrdFim	:= Val( aTabCalend[ Len( aTabCalend ) , CALEND_POS_ORDEM ] )
Local nPos		:= 0
Local nPos1		:= 0
Local nY		:= 0
Local nX		:= 0

IF ( nFornY > 0 )
	For nX := nOrdIni To nOrdFim
		cOrdem := StrZero( nX , 2 )
		IF aScan( aMarcacoes , { |x| x[AMARC_ORDEM] == cOrdem .and. x[AMARC_APONTA] != "S" } ) > 0 .or. ;
		   aScan( aMarcacoes , { |x| x[AMARC_ORDEM] == cOrdem } ) == 0
			Loop
		EndIF
		IF ( nPos1 := aScan( aTabCalend , { |x|  x[ CALEND_POS_ORDEM ] == cOrdem .and. x[ CALEND_POS_TIPO_MARC ] == "1E" } ) ) > 0
			IF ( nPos := aScan( aLastApo , { |x| x[ 01 ] == aTabCalend[ nPos1 , CALEND_POS_DATA ] } ) ) > 0
				For nY := nPos To nFornY
					IF aLastApo[ nY , 01 ] == aTabCalend[ nPos1 , CALEND_POS_DATA ]
						fGeraRes(	@aResult						,; //01 -> Array com os Resultados do Dia
									aLastApo[ nY, 01 ]				,; //02 -> Data da Geracao
									aLastApo[ nY, 03 ]				,; //03 -> Numero de Horas Resultantes
									aLastApo[ nY, 02 ]				,; //04 -> Codigo do Evento
									aLastApo[ nY, 04 ]				,; //05 -> Centro de Custo a ser Gravado
									aLastApo[ nY, 05 ]				,; //06 -> Tipo de Marcacao
									.F.								,; //07 -> True para Acumular as Horas
									/*cPeriodo	*/					,; //08 -> Periodo de Apuracao
									/*nTole		*/					,; //09 -> Tolerancia
									/*cArred	*/					,; //10 -> Tipo de Arredondamento a Ser Utilizado
									/*lSubstitui*/					,; //11 -> Substitui a(s) Hora(s) Existente(s)
									/*cFuncao	*/					,; //12 -> Funcao
				  					/*cDepto	*/					,; //13 -> Depto para gravacao
									/*cPosto	*/					,; //14 -> Posto para gravacao
									/*cProcesso	*/					,; //15 -> Periodo para Gravacao
									/*cRoteiro	*/					,; //16 -> Processo para Gravacao
									/*cPerApo	*/					,; //17 -> Periodo para Gravacao
									/*cNumPagto	*/ 					,; //18 -> NumPagto para Gravacao
									aLastApo[ nY, ARESULT_TURNO  ]	,; //19 -> Turno de Trabalho
									aLastApo[ nY, ARESULT_SEMANA ]	,; //20 -> Semana/Sequencia do Turno
									aLastApo[ nY, ARESULT_TIPOHE ]	,; //21 -> Tipo de Hora Extra
									aLastApo[ nY, ARESULT_PERCENT]	;  //22 -> Percentual de Valorizacao
								 )
					Else
						Exit
					EndIF
				Next nY
			EndIF
		EndIF
	Next nX
EndIF

Return( NIL )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³GetMrBySra   ³ Autor ³Marinaldo de Jesus   ³ Data ³07/09/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Obtem as marcacoes dos Funcionarios							 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL                                                  	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Uso      ³PONM010                                                      ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function GetMrBySra()

Local cSvFilAnt		:= cFilAnt
Local nDespMin		:= GetDespMin()
Local aLastMarca
Local aMarcacoes
Local aNewMarca
Local aProvCrachas
Local aCrachas
Local aGetArea 		:= {}
Local aPerFecha		:= {}
Local cMarcFer
Local cMvDespRef
Local cNumRep
Local cEmpOrg
Local cDhOrg
Local cIdOrg
Local cSpaceMotVrg := If(lPort1510,Space( GetSx3Cache( "P8_MOTIVRG" , "X3_TAMANHO" ) ),Nil)
Local cMotivo	   := If(lPort1510,fInitMotivo( xFilial("RFD"), "1" , "3" ),Nil)
Local cPerDe       := If(lWorkFlow, DtoS(dPerIni - nDiasExtA), DtoS(dPerDe - nDiasExtA))
Local cPerAte      := DtoS(dPerAte + nDiasExtP)

Local dIniGet
Local dFimGet

Local lCpoUser		:= .F.
Local lDespMin		:= ( nDespMin != 0 )//com o parametro igual o zero, nao havera desprezo de marcacoes
Local lIntMen
Local lGetMarcAuto	:= .F.
Local lRfeQryOpened := .F.
Local lSP0Comp		:= FWModeAccess("SP0",1) == "C" .AND. FWModeAccess("SP0",2) == "C" .AND. FWModeAccess("SP0",3) == "C"
local lRepCarol		:= .F.
local lPulaMarc		:= .F.

Local nLoop
Local nLoops
Local nCracha
Local nCrachas
Local nDespRef
Local nTab
Local nRecQry
Local nX
Local nY

Static nSerIni
Static nSerFim

Local ATotCracha		:= {}
Local cQuery	 		:= ""
Local cSvQuery			:= ""
Local cSvCracha			:= ""
Local cSvDat			:= ""
Local nField			:= 0
Local cPrefixo
Local cRfeRetSqlName

Local lCaClockIn := SuperGetMv( "MV_APICLO0" , NIL , .F. )

Local lGeoFence		:= lCaClockIn .And. RFE->( ColumnPos("RFE_LATITU") ) > 0
Local lMVGeoFen		:= SuperGetMv( "MV_GEOFENC", NIL, .T. )
Local cLatitude  	:= ""
Local cLongitude 	:= ""
Local cGeofence  	:= ""
Local cTipoREP		:= ""
Local lSP0TPREP		:= SP0->( ColumnPos("P0_TPREP") ) > 0
Local lCpos671 		:= fValid671()
Local cFuso			:= ""
Local cCCTREP		:= ""
Local cConec		:= ""
Local cTipAfas		:= ""
Local dIniAfas		:= cToD(" / / ")
Local dFimAfas		:= cToD(" / / ")
Local cFilMarc		:= ""

Local lMemoCalc		:= GetlMemoCalc()
Local cMemoQuery	:= ""
Local nRecMultV		:= 0

Local lTipoDoc		:= SP0->( ColumnPos("P0_TIPODOC") ) > 0
Local cTipoDoc		:= "1"

If !lPn010Auto
	If lPort1510
		cPrefixo			:= ( PrefixoCpo( cAliasRFE ) + "_" )
		cRfeRetSqlName	    := InitSqlName( cAliasRfe )
		DEFAULT aRfeFields	:= ( cAliasRfe )->( dbStruct() )
		DEFAULT nRfeFields 	:= Len( aRfeFields )
		cQryRfeAlias := ( "__Q" + cAliasRfe + "QRY" )
	EndIf
Endif

Private lREP		:= .F.
Private lMultVinc	:= .F.

If Type("lPn010Auto") == "U"
	Private lPn010Auto := .F.
Endif

If lPort1510
	lREP := !Empty(SP0->P0_REP) .Or. (lCaClockIn .And. SP0->P0_TIPOARQ == "R") 
EndIf

If !lSP0TPREP .Or. (lSP0TPREP .And. Empty(SP0->P0_TPREP))
	cTipoREP := "1"
Else
	cTipoREP := SP0->P0_TPREP
EndIf

If SP0->P0_TIPOARQ == "R" .And. Empty(SP0->P0_REP)
	lRepCarol	:= .T.
	cConec		:= SuperGetMv("MV_APICLO3", .F., '')
	cConec		:= Left(cConec, GetSx3Cache("RFE_NUMREP", "X3_TAMANHO"))
EndIf

If lTipoDoc
	cTipoDoc := SP0->P0_TIPODOC
	cTipoDoc := If(Empty(cTipoDoc), "1", cTipoDoc)
EndIf

// Reinicializa cFilOld
cFilOld := ""

If lMemoCalc
	GravaMCalc("01", 1, "-" + STR0210 + "(PONM010)") // "Leitura Por Funcionário"
EndIf

Begin Sequence
	
	SPE->( dbSetOrder( RetOrdem( "SPE" , "PE_FILIAL+PE_MAT" ) ) )
	SPF->( dbSetOrder( RetOrdem( "SPF" , "PF_FILIAL+PF_MAT+DtoS(PF_DATA)" ) ) )
	SP8->( dbSetOrder( RetOrdem( "SP8" , "P8_FILIAL+P8_MAT+DTOS(P8_DATA)+STR(P8_HORA,5,2)" ) ) )
	
	// Seleciona Informacoes dos Funcionarios
	If !lPn010Auto
		IF !SelectSra(.F.)
			Break
		EndIF
	Endif
	
	// Inicializa aMarcacoes
	aMarcacoes := Array( 01 , Array( ELEMENTOS_AMARC ) )
	
	If !lPn010Auto
		cCondSRA := "( ( cFilTnoSRA := ( RA_FILIAL + RA_TNOTRAB ) ) >= cFilTnoDe ) .and. ( cFilTnoSRA <= cFilTnoAte )
	Else
		cCondSRA := "( ( cFilFunSRA := ( RA_FILIAL + RA_MAT ) ) >= cFunMat ) .and. ( cFilFunSRA <= cFunMat )
	Endif
	
	// Processa o Apontamento de Marcacoes/Refeicoes
	While SRA->(;
					!Eof();
					.and.;
                    &(cCondSRA) ;
				)
		
		// Obtenho Filial e Matricula do Funcionario
		cFilSRA 	:= SRA->RA_FILIAL
		cMatricula	:= SRA->RA_MAT
		nRecMultV	:= 0
		
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Abandona o Processamento									   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		IF ( lAbortPrint )
			aAdd( aLogFile , STR0028 + Dtoc(MsDate()) + ', as ' + Time() + ' ...') // '- Cancelado pelo Operador em '
			Break
		EndIF
		
		If !lPn010Auto
			IF !( lSraQryOpened )
				/*/
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Consiste filtro do intervalo De / Ate                        ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
				IF SRA->( !Eval( bSraScope ) )
					SRA->( dbSkip() )
					Loop
				EndIF
			EndIF
			
			// Incrementa a Regua de Processamento
			IF !( lWorkFlow )
				
				// Consiste controle de acessos e filiais validas
				IF SRA->( !( cFilSRA $ fValidFil() ) .or. !Eval( bAcessaSRA ) )
					SRA->( dbSkip() )
					Loop
				EndIF
			Else
				/*/
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ So processa para a Filial Corrente                           ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
				IF ( lProcFilial )
					IF ( cFilSRA <> cFilProc )
						SRA->( dbSkip() )
						Loop
					Endif
				EndIF
			EndIF
		EndIf
		
		If cFilSRA $ cFilFECAux //Período bloqueado
			SRA->( dbSkip() )
			Loop
		EndIf
		
		// Verifica o Periodo de Apontamento
        IF !( cFilSRA == cFilOld )
			// Se teve mudança de filial, fecha a filial anterior para não travar o processo
			If lPn090Lock
				Pnm090UnlockPer(cFilOld,.T.)
				lPn090Lock := .F.
			EndIf
			
			cFilOld := cFilSRA
			
			If !lPn010Auto .And. !lSP0Comp //Se relógio não for compartilhado, verifica se fechamento esta sendo efetuado para a filial atual
				If !Pn090Open(, ,.T.,DtoS(dPerDe) + DtoS(dPerAte),.F.,cFilSRA,.F.,"S")
					If !lWorkFlow
						aAdd( aLogFile , STR0172 + cFilSRA + STR0173 ) // '- O fechamento da filial ' + SRA->RA_FILIAL + ' esta sendo efetuado em outro processo. Tente novamente mais tarde.'
					Else
						ConOut("")
						ConOut( STR0172 + cFilSRA + STR0173 )
						ConOut("")
					EndIf
					cFilFECAux += cFilSRA + "/"
					SRA->( dbSkip() )
					Loop
				Else
					lPn090Lock := .T.
				EndIf
			EndIf
			
			IF !( CheckPonMes( @dPerIni, @dPerFim, .F., .T. , ( !( lWorkFlow ) .and. !( lChkPonMesAnt ) .and. !(lMultThread) .And. !(lPn010Auto) ) , cFilOld ) )
				lChkPonMesAnt := .F.
				aAdd( aLogFile , STR0006 ) 					// '- O Periodo Informado nos Parametros e invalido. Informe um Periodo Valido'
				aAdd( aLogFile , STR0008 ) 					// 'ou'
				aAdd( aLogFile , STR0002 + " " + cFilOld )	// '- Nao Foi Encontrado periodo de Apontamento para a Filial: '
				aAdd( aLogFile , STR0007 ) 					// '- A Leitura/Apontamento nao puderam ser concluidos. Favor Cadastrar o Periodo'
				IF !( lWorkFlow )
					lAbortPrint := .T.
					If lRfeQryOpened
						(cQryRfeAlias)-> (dbCloseArea())
						RestArea( aGetArea )
					EndIf
					Break
				EndIF
			Else
				lChkPonMesAnt := .T.
			EndIF
			
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Seta o Periodo conforme Pergunte             				  ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			/*
			dPerDe 	  := IF( lWorkFlow .and. lUserDefParam , mv_par13 , IF( !lWorkFlow , mv_par13 , dPerIni	) )																												//Periodo De
			dPerAte	  := IF( lWorkFlow .and. lUserDefParam , IF( lLimitaDataFim , Min( dDataBase , mv_par14 ) , mv_par14 )  , IF( !lWorkFlow , mv_par14 , IF( lLimitaDataFim , Min( dDataBase , dPerFim ) , dPerFim ) ) )	//Periodo Ate
			*/
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Verifica se o Periodo eh Valido              				  ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			IF !fChkPer( dPerDe , dPerAte , cFilOld )
				aAdd( aLogFile , STR0006 ) // '- O Periodo Informado nos Parametros e invalido. Informe um Periodo Valido'
				IF !( lWorkFlow )
					lAbortPrint := .T.
					Break
				EndIF
			EndIF
			If lWorkFlow
				nSerIni := Round( __fDhtoNS( sToD(cPerDe) - nDiasExtA, 00.00 ), 5 )
			Else
				nSerIni := Round( __fDhtoNS( Max( dPerIni , dPerDe  ) - nDiasExtA, 00.00 )  , 5 )
			EndIf
			nSerFim := Round( __fDhtoNS( Min( dPerFim , dPerAte ) + nDiasExtP, 23.59 )  , 5 )
			
			dIniGet	:= ( Max( dPerIni , dPerDe  ) - 8 )
			dFimGet := ( Min( dPerFim , dPerAte ) + 8 )
			
			// Obtem parametro se le marcacoes funcionarios em ferias
			cMarcFer 	:= SuperGetMv("MV_MARCFER",,"N",cFilSRA)
			
			// Verifica se Devera Carregar as Marcacoes Automaticas em GetMarcacoes
			lGetMarcAuto := ( SuperGetMv( "MV_GETMAUT" , NIL , "S" , cFilSRA ) == "S" )
			
			// Busca o ultimo período fechado da filial do funcionário
			aPerFecha := fGetSPO(cFilSRA)
		EndIF
		
		// Inicializa os Arrays de Marcacoes Anteriores e Novas
		aNewMarca	:= {}
		aLastMarca	:= {}
		aTabCalend	:= {}
		
		// Carrega as Marcacoes Anteriores do Funcionario
		IF !GetMarcacoes(	@aLastMarca 		,;	//01 -> Marcacoes dos Funcionarios
							@aTabCalend			,;	//02 -> Calendario de Marcacoes
							NIL					,;	//03 -> Tabela Padrao
							NIL					,;	//04 -> Turnos de Trabalho
							dIniGet				,;	//05 -> Periodo Inicial
							dFimGet				,;	//06 -> Periodo Final
							cFilSRA				,;	//07 -> Filial
							cMatricula			,;	//08 -> Matricula
							NIL					,;	//09 -> Turno
							NIL					,;	//10 -> Sequencia de Turno
							NIL					,;	//11 -> Centro de Custo
							NIL					,;	//12 -> Alias para Carga das Marcacoes
							NIL					,;	//13 -> Se carrega Recno em aMarcacoes
							NIL					,;	//14 -> Se considera Apenas Ordenadas
							NIL					,;  //15 -> Verifica as Folgas Automaticas
							NIL					,;  //16 -> Se Grava Evento de Folga Mes Anterior
							NIL					,;	//17 -> Se Carrega as Marcacoes Automaticas
							NIL					,;	//18 -> Registros de Marcacoes Automaticas que deverao ser Deletados
							NIL					,;	//19 -> Bloco para avaliar as Marcacoes Automaticas que deverao ser Desprezadas
							.F.					,;	//20 -> Se Considera o Periodo de Apontamento das Marcacoes
							.F.					 ;	//21 -> Se Efetua o Sincronismo dos Horarios na Criacao do Calendario
						)
			aAdd(aLogFile, STR0118  + AllTrim(SRA->RA_TNOTRAB) + '.')													// '- Nao Foi Possivel Carregar as Marcacoes do Funcionario'
			SRA->( aAdd(aLogFile, STR0043  + AllTrim(SRA->RA_MAT) + ' - ' + AllTrim(SRA->RA_NOME) + STR0044 ) )			// '  As marca‡”es do funcionario '###' nao'
			aAdd(aLogFile, STR0119 )
			SRA->( dbSkip() )
			Loop
		EndIF
		
		// Processo para o Periodo Selecionado nos Parametos
		dData		:= ( __fNStoDH( nSerIni , "D" ) - 1 )
		nLoops		:= ( nSerFim - nSerIni )
		aProvCrachas:= GetProv(__fNStoDH( nSerIni , "D" ), __fNStoDH( nSerFim , "D" ))
		
		// Se nao for via ExecAuto
		If !lPn010Auto
			
			//Se a portria estiver ativa e for TOP, cria query da RFE
			If lPort1510 .and. TcSrvType() != "AS/400"
				//Monta array com todos os crachas do periodo
				ATotCracha := {}
				For nLoop := 0 To nLoops
					++dData
					
					IF  ( cMarcFer == "N" )
						IF ( nTab := aScan(aTabCalend, {|x| x[1] == dData .and. x[4] == '1E' }) ) > 0.00
							IF ( aTabCalend[ nTab , CALEND_POS_AFAST ] )  .AND. 	( aTabCalend[	nTab	,	CALEND_POS_TIP_AFAST		] == "F" )
								Loop
							EndIF
						EndIF
					EndIF
					
					cData := Dtos( dData )
					
					aCrachas	:= GetCracha(dData, aProvCrachas, cTipoDoc)
					nCrachas	:= Len( aCrachas )
					For nX := 1 To nCrachas
						If aScan(ATotCracha, {|x| x[2, 1] == aCrachas[nX, 1] } ) == 0
							aAdd(ATotCracha, {cData, aCrachas[nX]} )
						EndIf
					Next nX
				Next nLoop
				
				aGetArea	:= GetArea()
				nCrachas := Len(aTotCracha)
				
				If !(nCrachas > 0 )
					SRA->( dbSkip() )
					Loop
				EndIf
				
				If lRep
					( cTxtAlias )->(dbSetOrder(RetOrder("RFE","RFE_PIS+RFE_CPF+DTOS(RFE_DATA)+STR(RFE_HORA,5,2)")))
				Else
					( cTxtAlias )->(dbSetOrder(RetOrder("RFE","RFE_CRACHA+DTOS(RFE_DATA)+STR(RFE_HORA,5,2)")))
				EndIf
				
				cQuery := "SELECT "
				For nField := 1 To nRfeFields
					cQuery += aRfeFields[ nField , 01 ] + ", "
				Next nField
				cQuery += "R_E_C_N_O_ RECNO  "
				
				cQuery := SubStr( cQuery , 1 , Len( cQuery ) - 2 )
				
				cQuery += ( " FROM " + cRfeRetSqlName + " " + cAliasRFE )
				cQuery += ( " WHERE ( " )
				For nY := 1 to nCrachas
					cQuery += ( cAliasRFE + "." + cPrefixo )
					If !lRep .And. cTipoDoc == "1"
						cQuery += ( "CRACHA='"+ aTotCracha[nY, 2, 1]+"'" )
					Else
						cQuery += "PIS <> ''"
						cQuery += " AND " + cAliasRFE + "." + cPrefixo + "PIS = '" + aTotCracha[nY, 2, 1] + "'"
						If lCpos671
							cQuery += " OR (" + cAliasRFE + "." + cPrefixo + "CPF <> ''"
							cQuery += " AND " + cAliasRFE + "." + cPrefixo + "CPF = '" + aTotCracha[nY, 2, 2] + "')"
						EndIf
					EndIf
					If nY < nCrachas
						cQuery += ( " OR " )
					EndIf
				Next nY
				
				// Validação da filail e matrícula já preenchidos
				cQuery += " OR ("
				cQuery += cAliasRFE + "." + cPrefixo
				cQuery += "FILORG = '" + SRA->RA_FILIAL + "'"
				cQuery += " AND "
				cQuery += cAliasRFE + "." + cPrefixo
				cQuery += "MATORG = '" + SRA->RA_MAT + "'"
				cQuery += ")"
				
				cQuery += ( " ) AND ( " )
				
				cQuery += ( cAliasRFE + "." + cPrefixo )
				cQuery += ( "DATA>='"+cPerDe+"'" )
				cQuery += ( " AND " )
				cQuery += ( cAliasRFE + "." + cPrefixo )
				cQuery += ( "DATA<='"+cPerAte+"'" )
				
				cQuery += ( " ) AND ( " )
				
				cQuery += ( cAliasRFE + "." + cPrefixo )
				cQuery += ( "FLAG='0'" )
				cQuery += ( " OR " )
				cQuery += ( cAliasRFE + "." + cPrefixo )
				cQuery += ( "NATU='3'" )
				
				cQuery += ( ") " )
				
				If !lRepCarol
					cQuery += ( " AND " )
					cQuery += (cAliasRFE + "." + cPrefixo)
					cQuery += ("RELOGI='"+cRelogio+"'")
				Else
					cQuery += " AND (" + cAliasRFE + "." + cPrefixo + "ORIG = '" + SRA->RA_FILIAL + "' OR " + cAliasRFE + "." + cPrefixo + "ORIG = ' ')"
				EndIf
				
				If (lRepCarol, cQuery += " AND " + cAliasRFE + "." + cPrefixo + "NUMREP = '" + cConec + "'", Nil)
				
				cQuery += ( " AND " )
				
				cQuery += ( cAliasRFE + ".D_E_L_E_T_=' ' " )
				cQuery += ( "ORDER BY " + SqlOrder( (cAliasRFE)->( IndexKey() ) ) )
				
				// Salva Query Atual Para Posterior Remontagem
				cSvQuery	:= cQuery
				
				// Salva Cracha e Data Para Posterior remontagem da Query
				cSvCracha	:= cCracha
				cSvDat		:= cData
				
				cQuery := ChangeQuery( cQuery )
				
				dbUseArea(.T., "TOPCONN", TCGenQry(,,cQuery), cQryRfeAlias, .F., .T.)
				
				For nField := 1 To nRfeFields
					IF !( aRfeFields[ nField , 02 ] == "C" )
						TcSetField(cQryRfeAlias,aRfeFields[nField,01],aRfeFields[nField,02],aRfeFields[nField,03],aRfeFields[nField,04])
					EndIF
				Next nField
				
				lRfeQryOpened := .T.
				
				//Fixa nLoops e nCrachas para fazer apenas uma vez os FOR abaixo
				nLoops := 0
				nCrachas := 1
				
				If lMemoCalc
					GravaMCalc("01", 2, STR0051 + ": " + cFilSRA + " - " + cMatricula) // Funcionário
					GravaMCalc("01", 3, STR0207) // "Query para busca das marcações na RFE: "
					cMemoQuery := cQuery
					nTabs := 4
					While Len(cMemoQuery) > 0
						GravaMCalc("01", nTabs, Left(cMemoQuery, 254), .F.)
						cMemoQuery := SubStr(cMemoQuery, 255)
						nTabs := 0
					EndDo
					//Quebra de linha
					GravaMCalc("01", 0, "")
					If (cQryRfeAlias)->(Eof())
						GravaMCalc("01", 3, STR0211)
					EndIf
				EndIf
				
			EndIf
			
			For nLoop := 0 To nLoops
				
				//Se nao montou query
				If !(lRfeQryOpened)  .And. !lPn010Auto
					/*/
					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					³ Obtem a Data para Pesquisa                                   ³
					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
					++dData
					
					/*/
					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					³ Consiste Afastamento do funcionario                          ³
					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
					IF  ( cMarcFer == "N" )
						IF ( nTab := aScan(aTabCalend, {|x| x[1] == dData .and. x[4] == '1E' }) ) > 0.00
							IF ( aTabCalend[ nTab , CALEND_POS_AFAST ] )  .AND. 	( aTabCalend[	nTab	,	CALEND_POS_TIP_AFAST		] == "F" )
								Loop
							EndIF
						EndIF
					EndIF
					
					/*/
					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					³Transforma a Data em String para Montagem da Query e da Chave³
					³de Pesquisa												  ³
					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
					cData := Dtos( dData )
					
					/*/
					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					³ Obtem os Crachas do Funcionario na Data					   ³
					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
					aCrachas	:= GetCracha( dData, aProvCrachas )
					nCrachas	:= Len( aCrachas )
					
					If lPort1510
						( cTxtAlias )->(dbSetOrder(RetOrder("RFE","RFE_CRACHA+DTOS(RFE_DATA)+STR(RFE_HORA,5,2)")))
					EndIf
				EndIf
				
				For nCracha := 1 To nCrachas
					
					//Se nao montou query
					If !(lRfeQryOpened)
						cCracha := aCrachas[ nCracha ]
						
						/*/
						ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						³ Verifica se Existem Marcacoes para o Cracha                  ³
						ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
						If !lPort1510
							IF !( cTxtAlias )->( MsSeek( ( cCracha + cData ) , .F. ) )
								Loop
							EndIF
							cQryRfeAlias := cTxtAlias
						EndIf
					EndIF

					// Loop para ler o arquivo gerado pelo relogio.
					While (cQryRfeAlias )->(!Eof())
						lPulaMarc := .F.
						
						If lPort1510
							If !( lRfeQryOpened ) .and. (!( ( cQryRfeAlias )->RFE_CRACHA == cCracha ) .or. !( ( cQryRfeAlias )->RFE_DATA == dData ))
								Exit
							EndIf
							// Desconsidera as marcacoes ja processadas e cujo cracha foi reconhecido.
							If !(( cQryRfeAlias )->RFE_FLAG == "0")  .AND. (( cQryRfeAlias )->RFE_NATU <> "3")
								( cQryRfeAlias )->( dbSkip() )
								Loop
							EndIf
							
							If !lSP0Comp .And. !Empty(( cQryRfeAlias )->RFE_FILIAL) .and. !(AllTrim(( cQryRfeAlias )->RFE_FILIAL) $ cFilSRA) .And. !lRepCarol
								( cQryRfeAlias )->( dbSkip() )
								Loop
							EndIf 
						Else
							If !( ( cQryRfeAlias )->CRACHA == cCracha ) .or. !( ( cQryRfeAlias )->DDATE == dData )
								Exit
							EndIf
						EndIf

						If Len(aProvCrachas) > 0
							If aScan(aProvCrachas, {|x| x[1] == AllTrim((cQryRfeAlias)->RFE_CRACHA) .And. x[2] >= (cQryRfeAlias)->RFE_DATA .And. x[3] <= (cQryRfeAlias)->RFE_DATA}) == 0 .And. AllTrim(SRA->RA_CRACHA) <> AllTrim((cQryRfeAlias)->RFE_CRACHA)
								(cQryRfeAlias)->(dbSkip())
								Loop
							EndIf
						EndIf

						// Obtem o conteudo dos campos
						If lPort1510
							dData		:= ( cQryRfeAlias )->RFE_DATA
							nHora		:= ( cQryRfeAlias )->RFE_HORA
							cCodRel		:= ( cQryRfeAlias )->RFE_RELOGI
							cFuncao		:= ( cQryRfeAlias )->RFE_FUNCAO
							cGiro		:= ( cQryRfeAlias )->RFE_GIRO
							cCusto		:= ( cQryRfeAlias )->RFE_CC
							cNumRep		:= ( cQryRfeAlias )->RFE_NUMREP
							cEmpOrg		:= ( cQryRfeAlias )->RFE_EMPORG
							cDhOrg		:= ( cQryRfeAlias )->RFE_DHORG
							cIdOrg		:= ( cQryRfeAlias )->RFE_IDORG
							cFilMarc	:= ( cQryRfeAlias )->RFE_ORIG
							
							If lGeoFence
								cLatitude  := (cQryRfeAlias)->RFE_LATITU
								cLongitude := (cQryRfeAlias)->RFE_LONGIT
								cGeofence  := (cQryRfeAlias)->RFE_GEOFEN
							EndIf
							
							If lCpos671
								cFuso := AllTrim(( cQryRfeAlias )->RFE_FUSO)
								cCCTREP := AllTrim(( cQryRfeAlias )->RFE_CCTREP)
							EndIf						
							
						Else
							nHora   := ( cQryRfeAlias )->HORA
							cCodRel := ( cQryRfeAlias )->CODREL
							cFuncao := ( cQryRfeAlias )->FUNCAO
							cGiro   := ( cQryRfeAlias )->GIRO
							cCusto  := ( cQryRfeAlias )->CUSTO
						EndIf
						
						If lMemoCalc
							GravaMCalc("01", 3, STR0212 + cIdOrg + " | " + dToC(dData) + "-" + Transform(StrZero(nHora * 100, 4), "@R XX:XX")) // "Marcação: "
							// "Data" - "Hora: " - "Crachá: "
							GravaMCalc("01", 4, "NSR: " + cIdOrg + " | " + STR0138 + ": " + dToC(dData) + " | " + STR0213 + Transform(StrZero(nHora * 100, 4), "@R XX:XX") + " | PIS: " + (cQryRfeAlias)->RFE_PIS + " | CPF: " + (cQryRfeAlias)->RFE_CPF + " | " + STR0214 + (cQryRfeAlias)->RFE_CRACHA)
						EndIf
						
						// Tratamento para verificar se ha multiplos vinculos, so para relogio REP
						// Só faz a validação dos multiplos vínculos se não existir a filial da marcação para os relógios do Clock In.
						If ((lREP .And. !lRepCarol) .Or. (lRepCarol .And. Empty(cFilMarc))) .And. Empty((cQryRfeAlias)->RFE_MATORG)
							If lMemoCalc
								GravaMCalc("01", 4, STR0215) // "Verificação de Múltiplos Vínculos"
							EndIf
							aMultVinc := fValdMultV(SRA->RA_PIS, SRA->RA_CIC, (cQryRfeAlias)->RFE_FILIAL, cCategoria, dData, nHora)
							
							If lMultVinc .And. !Empty(aMultVinc)
								cFilSRA 	:= aMultVinc[1, 1]
								cMatricula	:= aMultVinc[1, 2]
								nRecMultV	:= aMultVinc[1, 3]
								GravaMCalc("01", 5, STR0216 + cFilSRA + " - " + cMatricula) // "Atribuído: "
							EndIf
						ElseIf lRepCarol
							cFilSRA := SRA->RA_FILIAL
						EndIf
						
						// Não considera marcações que não sejam do relógio atual.
						IF !( lRfeQryOpened ) .and. ( cCodRel <> cRelogio )
							( cQryRfeAlias )->( dbSkip() )
							Loop
						EndIF
						
						If SRA->RA_SITFOLH == 'D' .and. lPort1510 .and. SRA->RA_DEMISSA < dData
							( cQryRfeAlias )->( dbSkip() )
							Loop
						EndIf
						
						// Valida se a marcação está dentro de um período fechado, se sim pula a marcação.
						If !Empty(aPerFecha)
							If !Empty(aPerFecha) .And. dData <= sToD(aPerFecha[1,3])
								(cQryRfeAlias)->(dbSkip())
								Loop
							EndIf
						EndIf
						
						// Numero de Marcacoes Lidas
						++nLidas
						
						// Consiste Funcionário quanto à Admissão
						If SRA->RA_ADMISSA > dData
							If Empty(aLogAdmis)
								aAdd(aLogAdmis,{SRA->(RA_FILIAL),SRA->(RA_MAT),DtoC(SRA->RA_ADMISSA),1})
							Else
								For nY := 1 To Len(aLogAdmis)
									If aLogAdmis[nY,1] == SRA->(RA_FILIAL) .And. aLogAdmis[nY,2] == SRA->(RA_MAT)
										aLogAdmis[nY,4]++
									ElseIf nY == Len(aLogAdmis)
										aAdd(aLogAdmis,{SRA->(RA_FILIAL),SRA->(RA_MAT),DtoC(SRA->RA_ADMISSA),1})
									EndIf
								Next
							EndIf
							
							(cQryRfeAlias)->(dbSkip())
							Loop
						EndIf
						
						If fAfasta(cFilSRA,cMatricula,dData,@dIniAfas,@dFimAfas,@cTipAfas)
							cMarcFer := SuperGetMv("MV_MARCFER",,"N",cFilSRA)
							IF ( cMarcFer == "N" )
								IF (;
										( dData >= dIniAfas .and. dData <= dFimAfas );
										.or.;
										( dData >= dIniAfas .and. Empty( dFimAfas ) );
									)
									If Empty(aLogFunAfa)
										aAdd(aLogFunAfa,{SRA->(RA_FILIAL),SRA->(RA_MAT),DtoC(dIniAfas),DtoC(dFimAfas),1})
									Else
										For nY := 1 To Len(aLogFunAfa)
											If aLogFunAfa[nY,1] == SRA->(RA_FILIAL) .And. aLogFunAfa[nY,2] == SRA->(RA_MAT)
												aLogFunAfa[nY,5]++
											ElseIf nY == Len(aLogFunAfa)
												aAdd(aLogFunAfa,{SRA->(RA_FILIAL),SRA->(RA_MAT),DtoC(dIniAfas),DtoC(dFimAfas),1})
											EndIf
										Next
									EndIf

									(cQryRfeAlias)->(dbSkip())
									Loop
								EndIF
							EndIF
						EndIF
						
						// Controle de refeitorio.
						IF ( cControle == "R" )
							cMvDespRef	:= StrTran(Upper(Alltrim(SuperGetMv("MV_DESPREF",,"",cFilSRA)))," ","")
							nDespRef	:= Val( SubStr( cMvDespRef , 2 ) )
							Ponm010Ref(cCodRel,cFilSRA,cMatricula,dData,nHora,Ponm010CcChk( cCusto ),SubStr(cMvDespRef,1,1),nDespRef,@nGravadas)
							
							If lPort1510
								/*/
								ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
								³ Atualiza Flag de marcacao do RFE                            ³
								ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
								If lRfeQryOpened
									dbSelectArea(cQryRfeAlias)
									nRecQry := (cQryRfeAlias)->RECNO
									dbSelectArea(cAliasRFE)
									( cAliasRFE )->(dbGoTo(nRecQry))
									IF RecLock( cAliasRFE , .F. )
										( cAliasRFE )->RFE_FLAG   := "1"
										( cAliasRFE )->RFE_FILORG := cFilSRA
										( cAliasRFE )->RFE_MATORG := cMatricula
										( cAliasRFE )->RFE_DATAAP := dData
										If lSP0Comp
											( cAliasRFE )->RFE_FILIAL := xFilial("RFE",cFilSRA)
										EndIf
										( cAliasRFE )->( MsUnLock() )
									EndIf
									dbSelectArea(cQryRfeAlias)
								Else
									IF RecLock( cQryRfeAlias , .F. )
										( cQryRfeAlias )->RFE_FLAG   := "1"
										( cQryRfeAlias )->RFE_FILORG := cFilSRA
										( cQryRfeAlias )->RFE_MATORG := cMatricula
										( cQryRfeAlias )->RFE_DATAAP := dData
										If lSP0Comp
											( cQryRfeAlias )->RFE_FILIAL := xFilial("RFE",cFilSRA)
										EndIf
										( cQryRfeAlias )->( MsUnLock() )
									EndIf
								EndIf
							EndIf
							
							( cQryRfeAlias )->( dbSkip() )
							Loop
						EndIF
						
						// Verifica se Esta Dentro do Intervalo definido do MV_DESPMIN
						lIntMen := lDespMin .And. ( aScan( aLastMarca , { |x| ( __Min2Hrs( DataHora2Val( x[ AMARC_DATA ] , x[ AMARC_HORA ] , dData , nHora ) ) <= nDespMin ) .and. ( x[ AMARC_FLAG ] <> 'A' .or.  ( lGetMarcAuto .and. x[ AMARC_FLAG ] == 'A'))} ) > 0 )
						
						// Não Considera Marcações com intervalo menor que o permitido
						IF ( lIntMen ) .and. !lPort1510 //-- Se portaria estiver ativa gravara como desconsiderada
							/*/
							ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
							³ PONTO DE ENTRADA                                             ³
							³ Chamado quando alguma marcacao for descartada em funcao do   ³
							³ parametro MV_DESPMIN.                                        ³
							ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
							IF ( lPonaPo6Block )
								/*/
								ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
								³ Atualizo a Variavel cCusto para Uso no Ponto de Entrada	  ³
								ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
								cCusto := Ponm010CcChk( cCusto )
								/*/
								ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
								³ Troca Filiais para Integridade		                      ³
								ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
							cFilAnt	:= IF( !Empty( cFilSRA ) , cFilSRA , cFilAnt )
								ExecBlock( "PONAPO6" , .F. , .F. )
								cFilAnt	:= cSvFilAnt
							EndIF
							
							( cQryRfeAlias )->( dbSkip() )
							Loop
						EndIF
						
						If lIntMen .And. lMemoCalc
							GravaMCalc("01", 4, STR0217) // "Marcação será gravada como Desconsiderada por conta do parâmetro MV_DESPMIN"
						EndIf
						
						// Carrega aMarcacoes
						aMarcacoes[ 01 , AMARC_DATA    	] := dData					//01 - Data da Marcacao
						aMarcacoes[ 01 , AMARC_HORA    	] := nHora					//02 - Hora da Marcacao
						aMarcacoes[ 01 , AMARC_ORDEM   	] := cP8Ordem				//03 - Ordem da Marcacao
						aMarcacoes[ 01 , AMARC_FLAG    	] := "E"					//04 - Flag (Origem) da Marcacao
						aMarcacoes[ 01 , AMARC_RECNO   	] := 0						//05 - Recno
						aMarcacoes[ 01 , AMARC_TURNO   	] := cP8Turno				//06 - Turno da Marcacao (Sera Carregado na PutOrdMarc())
						aMarcacoes[ 01 , AMARC_FUNCAO  	] := cFuncao				//07 - Funcao do Relogio
						aMarcacoes[ 01 , AMARC_GIRO    	] := cGiro					//08 - Giro do Relogio
						aMarcacoes[ 01 , AMARC_CC      	] := Ponm010CcChk( cCusto )	//09 - Centro de Custo da Marcacao
						aMarcacoes[ 01 , AMARC_APONTA  	] := "N"					//10 - Flag de Marcacao Apontada
						aMarcacoes[ 01 , AMARC_RELOGIO	] := cCodRel				//11 - Relogio da Marcacao
						aMarcacoes[ 01 , AMARC_TIPOMARC	] := cP8TpMarca				//12 - Flag de Tipo de Marcacao
						aMarcacoes[ 01 , AMARC_L_ORIGEM	] := .F.					//13 - Define Se a Marcacao Pode ou Nao ser (Re)Ordenada
						aMarcacoes[ 01 , AMARC_PERAPONTA] := cPerAponta				//15 - String de Data com o Periodo de Apontamento
						If lPort1510
							aMarcacoes[ 01 , AMARC_DATAAPO		] := CtoD('//')					  		//25 - Data de Apontamento
							aMarcacoes[ 01 , AMARC_NUMREP		] := cNumRep					   		//26 - Numero do REP
							aMarcacoes[ 01 , AMARC_TPMCREP		] := If(lIntMen,"D",Space(01))	   		//27 - Tipo de Marcacao no REP
							aMarcacoes[ 01 , AMARC_TIPOREG		] := "O"								//28 - Tipo de Registro
							aMarcacoes[ 01 , AMARC_MOTIVRG		] := If(lIntMen,cMotivo,cSpaceMotVrg)	//29 - Motivo da desconsideracao/inclusao
							aMarcacoes[ 01 , AMARC_EMPORG		] := cEmpOrg					   		//31 - Empresa Origem da marcacao
							aMarcacoes[ 01 , AMARC_FILORG		] := cFilSRA       				   		//32 - Filial Origem da marcacao
							aMarcacoes[ 01 , AMARC_MATORG		] := cMatricula							//33 - Matricula Origem da marcacao
							aMarcacoes[ 01 , AMARC_DHORG		] := cDhOrg								//34 - Data/Hora Origem da marcacao
							aMarcacoes[ 01 , AMARC_IDORG		] := cIdOrg						   		//35 - Identificacao da Origem da marcacao
							
							If lRfeQryOpened
								nRecQry := (cQryRfeAlias)->RECNO
								dbSelectArea(cAliasRFE)
								( cAliasRFE )->(dbGoTo(nRecQry))
								
								IF RecLock( cAliasRFE , .F. )
									( cAliasRFE )->RFE_FILORG := cFilSRA
									( cAliasRFE )->RFE_MATORG := cMatricula
									( cAliasRFE )->RFE_NATU   := "0"
									( cAliasRFE )->RFE_FLAG   := "1"
									
									If lRepCarol
										( cAliasRFE )->RFE_RELOGI	:= cRelogio
										( cAliasRFE )->RFE_RELSP0	:= cRelogio
										aMarcacoes[ 01 , AMARC_RELOGIO	] := cRelogio
									EndIf
									
									If lSP0Comp
										( cAliasRFE )->RFE_FILIAL   := xFilial("RFE", cFilSRA)
									EndIf
									
									( cAliasRFE )->( MsUnLock() )
									
									If lMemoCalc
										// "Registro atualizado na RFE."
										GravaMCalc("01", 4, STR0218  + " RFE_NATU = '0' | RFE_FLAG = '1' | " + "Recno: " + cValToChar((cQryRfeAlias)->RECNO))
									EndIf
								EndIf
								dbSelectArea(cQryRfeAlias)
							Else
								IF RecLock( cQryRfeAlias , .F. )
									( cQryRfeAlias )->RFE_FILORG := cFilSRA
									( cQryRfeAlias )->RFE_MATORG := cMatricula
									( cQryRfeAlias )->RFE_NATU   := "0"
									( cQryRfeAlias )->RFE_FLAG   := "1"
									( cQryRfeAlias )->( MsUnLock() )
								EndIf
							EndIf
						EndIf
						
						If lGeoFence
							aMarcacoes[ 01 , AMARC_LATITU	] := cLatitude	//36 - Latitude (marcacao geolocalizacao)
							aMarcacoes[ 01 , AMARC_LONGIT	] := cLongitude	//37 - Longitude (marcacao geolocalizacao)
							aMarcacoes[ 01 , AMARC_GEOFENCE	] := cGeofence	//38 - Dentro ou fora do perímetro
							If cGeofence == "2" .And.  !lMVGeoFen // Despreza marcações fora do perímetro
								aMarcacoes[ 01 , AMARC_TPMCREP	] := "D"
								aMarcacoes[ 01 , AMARC_MOTIVRG	] := cMotivo
							EndIf
						EndIf
						
						If lCpos671
							aMarcacoes[ 01 , AMARC_FUSO	]	:= cFuso
							aMarcacoes[ 01 , AMARC_CCTREP ]	:= cCCTREP
						EndIf
						
						// Carrega a Nova Marcacao a Ser Gravadas
						aAdd( aNewMarca, aClone(aMarcacoes[01]))
						
						If lMultVinc .And. nRecMultV > 0 .And. !lPn010Auto .And. aScan(aRegsRARFE, {|x| x[1] == nRecMultV }) == 0
							aAdd(aRegsRARFE, {nRecMultV})
						EndIf
						
						If lMemoCalc
							GravaMCalc("01", 4, STR0219) // "Marcação gravada na SP8"
						EndIf
						
						// Carrega Marcacao para Comparacao no MV_DESPMIN
						aAdd( aLastMarca	, aClone( aMarcacoes[ 01 ] ) )
						
						// Posiciona na Proxima marcação
						
						( cQryRfeAlias )->( dbSkip() )
						
					EndDo
					
				Next nCracha
				
			Next nLoop
			
			If lRfeQryOpened
				(cQryRfeAlias)-> (dbCloseArea())
				RestArea( aGetArea )
				lRfeQryOpened	:=	.F.
			EndIf
        Else
			// Atualizacao Automatica
			nLoops := Len(aAutoItens)
			For nLoop := 1 To nLoops
				If aScan(aAutoItens[nLoop], { |x| GetSx3Cache(x[1], "X3_PROPRI") == "U"  } ) > 0
					lCpoUser	:= .T.
					Exit
				EndIf
			Next nLoop			
			
			For nLoop := 1 To nLoops
				
				/*/
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Verifica a existencia das marcacoes e desconsidera          ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
				dbSelectArea("SP8")
				dbSetOrder(2)
				If dbSeek( Pn010AutoRead( aAutoItens[nLoop] , "P8_FILIAL" ) + ;
							Pn010AutoRead( aAutoItens[nLoop] , "P8_MAT" ) + ;
							DTOS(Pn010AutoRead( aAutoItens[nLoop] , "P8_DATA" )) + ;
							STR(Pn010AutoRead( aAutoItens[nLoop] , "P8_HORA" ),5,2) 	)
							aAdd(aLogFile,STR0162 + " - " + DTOC(Pn010AutoRead( aAutoItens[nLoop] , "P8_DATA" ))+ " - " + STR(Pn010AutoRead( aAutoItens[nLoop] , "P8_HORA" ),5,2) ) // "MarcaÇão já existente!"
					Loop
				Endif
				
				dbSelectArea("SRA")
				
				/*/
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Carrega aMarcacoes                                          ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
				aMarcacoes[ 01 , AMARC_DATA    	] := Pn010AutoRead( aAutoItens[nLoop] , "P8_DATA" )			//01 - Data da Marcacao
				aMarcacoes[ 01 , AMARC_HORA    	] := Pn010AutoRead( aAutoItens[nLoop] , "P8_HORA" )			//02 - Hora da Marcacao
				aMarcacoes[ 01 , AMARC_ORDEM   	] := " "					//03 - Ordem da Marcacao
				aMarcacoes[ 01 , AMARC_FLAG    	] := "I"					//04 - Flag (Origem) da Marcacao
				aMarcacoes[ 01 , AMARC_RECNO   	] := 0						//05 - Recno
				aMarcacoes[ 01 , AMARC_TURNO   	] := SRA->RA_TNOTRAB		//06 - Turno da Marcacao (Sera Carregado na PutOrdMarc())
				aMarcacoes[ 01 , AMARC_FUNCAO  	] := " "					//07 - Funcao do Relogio
				aMarcacoes[ 01 , AMARC_GIRO    	] := " "					//08 - Giro do Relogio
				aMarcacoes[ 01 , AMARC_CC      	] := IIF(IsInCallStack("TECA910"), Pn010AutoRead( aAutoItens[nLoop] , "P8_CC" ), SRA->RA_CC)				//09 - Centro de Custo da Marcacao
				aMarcacoes[ 01 , AMARC_APONTA  	] := "N"					//10 - Flag de Marcacao Apontada
				aMarcacoes[ 01 , AMARC_RELOGIO	] := " "					//11 - Relogio da Marcacao
				aMarcacoes[ 01 , AMARC_TIPOMARC	] := " "					//12 - Flag de Tipo de Marcacao
				aMarcacoes[ 01 , AMARC_L_ORIGEM	] := .F.					//13 - Define Se a Marcacao Pode ou Nao ser (Re)Ordenada
				aMarcacoes[ 01 , AMARC_PERAPONTA] := " "					//15 - String de Data com o Periodo de Apontamento
				If lPort1510
					aMarcacoes[ 01 , AMARC_DATAAPO		] := CtoD('//')					  		//25 - Data de Apontamento
					aMarcacoes[ 01 , AMARC_NUMREP		] := " "						   		//26 - Numero do REP
					aMarcacoes[ 01 , AMARC_TPMCREP		] := " "						   		//27 - Tipo de Marcacao no REP
					aMarcacoes[ 01 , AMARC_TIPOREG		] := "I"								//28 - Tipo de Registro
					aMarcacoes[ 01 , AMARC_MOTIVRG		] := fInitMotivo(xFilial("RFD"),"1","1")//29 - Motivo da desconsideracao/inclusao
					aMarcacoes[ 01 , AMARC_EMPORG		] := " "						   		//31 - Empresa Origem da marcacao
					aMarcacoes[ 01 , AMARC_FILORG		] := " "   	    				   		//32 - Filial Origem da marcacao
					aMarcacoes[ 01 , AMARC_MATORG		] := " "								//33 - Matricula Origem da marcacao
					aMarcacoes[ 01 , AMARC_DHORG		] := " "								//34 - Data/Hora Origem da marcacao
					aMarcacoes[ 01 , AMARC_IDORG		] := " "						   		//35 - Identificacao da Origem da marcacao
				EndIf
				If lGeolocal
					aMarcacoes[ 01 , AMARC_LATITU	] := " "					  				//36 - Latitude (marcacao geolocalizacao)
					aMarcacoes[ 01 , AMARC_LONGIT	] := " "				 					//37 - Longitude (marcacao geolocalizacao)
					aMarcacoes[ 01 , AMARC_GEOFENCE	] := " "				 					//38 - Define se a marcação está dentro ou fora do perímetro
				EndIf
				
				aMarcacoes[01, AMARC_FILCCT] := Pn010AutoRead(aAutoItens[nLoop], "P8_FILCCT")	//39 - Filial da convenção coletiva
				aMarcacoes[01, AMARC_CODCCT] := Pn010AutoRead(aAutoItens[nLoop], "P8_CODCCT")	//40 - Código da convenção coletiva
				aMarcacoes[01, AMARC_FUSO  ] := Pn010AutoRead(aAutoItens[nLoop], "P8_FUSO")		//41 - Fuso horário da marcação
				aMarcacoes[01, AMARC_CCTREP] := Pn010AutoRead(aAutoItens[nLoop], "P8_CCTREP")	//42 - Código da convenção coletiva da marcação (Clock in)
				
				If lCpoUser
					aEval( aAutoItens[nLoop], { |x| Iif( GetSx3Cache(x[1], "X3_PROPRI") == "U", aAdd(aMarcacoes[ 01 ], {x[1], x[2]}), Nil ) } ) 
				EndIf
				
				/*/
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Carrega a Nova Marcacao a Ser Gravadas                 	  ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
				aAdd( aNewMarca		, aClone( aMarcacoes[ 01 ] ) )
				
				/*/
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Carrega Marcacao para Comparacao no MV_DESPMIN			  ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
				aAdd( aLastMarca	, aClone( aMarcacoes[ 01 ] ) )
				
			Next nLoop
			
        Endif
		
		// Contador para Numero de Marcacoes Gravadas
		nGravadas += Len( aNewMarca )
		
		// Grava o arquivo de marcações.
		PutMarcacoes( aNewMarca , cFilSRA , cMatricula , "SP8" , .T., Nil, Nil, Nil, lWorkFlow, nTipo, lCpoUser, !lMultVinc )
		
		If !lPn010Auto .And. aScan( aRegsRARFE, {|x| x[1] == SRA->R_E_C_N_O_}) == 0 .And. Len(aNewMarca) > 0
			aAdd(aRegsRARFE, {SRA->R_E_C_N_O_})
		EndIf
		
		SRA->( dbSkip() )
		
	EndDo
	
End Sequence

// Execlui a tabela após o processamento
If lPn090Lock
	Pnm090UnlockPer(,.T.,,,"A") //Desfaz o lock virtual da filial
	lPn090Lock	:= .F.
EndIf

cFilAnt := cSvFilAnt

Return( NIL )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³GetCracha    ³ Autor ³Marinaldo de Jesus   ³ Data ³22/01/2003³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Obtem o Cracha do Funcionario								 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL                                                  	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Uso      ³GetMrBySra() em PONM010                                      ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function GetCracha(dData, aProvCrachas, cTipoDoc)
Local aCrachas	:= { }
Local cPIS		:= ""
Local cCPF		:= ""
Local nI

DEFAULT aProvCrachas	:= {}
DEFAULT cTipoDoc := "1"

If !lREP .And. cTipoDoc == "1"
	aAdd( aCrachas, {SRA->RA_CRACHA, ""})
	
	For nI:= 1 to Len(aProvCrachas)
		If ( dData >= aProvCrachas[nI, 2] ) .And. ( dData <=  aProvCrachas[nI, 3] )
			cCracha :=  aProvCrachas[nI, 1]
			aAdd( aCrachas, {cCracha, ""})
			Exit
		EndIF
	Next nI
	
Else
	
	cPIS := AllTrim(SRA->RA_PIS)
	cCPF := AllTrim(SRA->RA_CIC)
	
	If lREP
		If Len(cPIS) == 11
			cPIS := PadL( cPIS, nLenPIS, "0" )
		EndIf
	EndIf
	
	If !Empty(cPIS) .Or. !Empty(cCPF)
		aAdd( aCrachas, {cPIS, cCPF})
	EndIf
EndIf

Return( aCrachas )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³GetProv      ³ Autor ³Marinaldo de Jesus   ³ Data ³22/01/2003³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³                                					 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL                                                  	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Uso      ³                                                             ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function GetProv(dPerIni, dPerFim, cFilSP0, cCracha, lExecRel)
Local aCrachas	:= {}
Local cFilSPE 	:= xFilial( "SPE" , SRA->RA_FILIAL )
Local cKeySeek	:= ( cFilSPE + SRA->RA_MAT )
Local cQuery	:= ""
Local cAliasTMP := GetNextAlias()

Default cFilSP0		:= ""
Default cCracha		:= ""
Default lExecRel	:= .F.

If !lExecRel
	IF SPE->( MsSeek( cKeySeek , .F. ) )
		While SPE->( !Eof() .and. ( cKeySeek == ( PE_FILIAL + PE_MAT ) ) )
			IF SPE->(;
						( PE_DATAINI > dPerFim );
						.or.;
						( PE_DATAFIM < dPerIni );
					)
					SPE->( dbSkip() )
					Loop
			Else
				aAdd( aCrachas , {AllTrim( SPE->PE_MATPROV ), SPE->PE_DATAINI, SPE->PE_DATAFIM} )
			Endif
			SPE->( dbSkip() )
		EndDo
	EndIF
Else
	If __oSt == Nil
		__oSt := FWPreparedStatement():New()

		cQuery := "SELECT PE_FILIAL, PE_MAT "
		cQuery += "FROM " + RetSqlName("SPE") + " SPE "
		cQuery += "WHERE PE_MATPROV = ? "
		cQuery += "  AND PE_FILIAL LIKE (?)"
		cQuery += "  AND PE_DATAINI <= ? "
		cQuery += "  AND PE_DATAFIM >= ? "
		cQuery += "  AND D_E_L_E_T_= ' '"
		cQuery := ChangeQuery(cQuery)
		
		__oSt:SetQuery(cQuery)
	EndIf

	cFilSP0 := AllTrim(cFilSP0) + "%"

	__oSt:SetString(1, cCracha)
	__oSt:SetString(2, cFilSP0)
	__oSt:SetString(3, dToS(dPerIni))
	__oSt:SetString(4, dToS(dPerIni))

	cQuery := __oSt:getFixQuery()
	
	dbUseArea(.T., "TOPCONN", TcGenQry(,, cQuery), cAliasTMP, .T., .T.)

	While !(cAliasTMP)->(Eof())
		aAdd(aCrachas,{(cAliasTMP)->PE_FILIAL,(cAliasTMP)->PE_MAT})
		(cAliasTMP)->(dbSkip())
	Enddo

	(cAliasTMP)->(dbCloseArea())
EndIf
Return( aCrachas )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³GetMrBySp0	 ³ Autor ³Marinaldo de Jesus   ³ Data ³07/09/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Obtem as marcacoes dos Funcionarios							 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL                                                  	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Uso      ³PONM010                                                      ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function GetMrBySp0()

Local cSvFilAnt		:= cFilAnt
Local lFound		:= .F.
Local nDespMin		:= GetDespMin()

Local aMarcacoes
Local aPerFecha		:= {}
Local aMultVinc		:= {}
Local aCrachas		:= {}

Local cMvDespRef
Local cMvDespVis
Local cMarcFer
Local cKeyAux
Local cKeyCracha
Local cLastKey := "****"
Local cTipAfas
Local cNumRep
Local cEmpOrg
Local cDhOrg
Local cIdOrg
Local cSpaceMotVrg 	:= If(lPort1510,Space( GetSx3Cache( "P8_MOTIVRG" , "X3_TAMANHO" ) ),Nil)
Local cMotivo	   	:= If(lPort1510, fInitMotivo( xFilial("RFD"), "1" , "3" ),Nil)
Local lGeoFence		:= lCaClockIn .And. RFE->( ColumnPos("RFE_LATITU") ) > 0
Local lMVGeoFen		:= SuperGetMv( "MV_GEOFENC", NIL, .T. )
Local cLatitude  	:= ""
Local cLongitude 	:= ""
Local cGeofence  	:= ""

Local dIniAfas
Local dFimAfas

Local lDespMin		:= ( nDespMin != 0 )//com o parametro igual o zero, nao havera desprezo de marcacoes
Local lIntMen
Local lGetMarcAuto	:= .F.
Local lMarcQryOpened := .F.
Local lREP			:= .F.

Local nDespVis
Local nOrdSRA
Local nSerMarc
Local nPos
Local nI			:= 0
Local nX			:= 0
Local nY			:= 0

Static nSerIni
Static nSerFim

Local cQuery	 		:= ""
Local cQueryMarc		:= ""
Local cSvQuery			:= ""
Local cSvFil			:= ""
Local cSvMat			:= ""
Local cSvDat			:= ""
Local cFilRFE			:= ""
Local cFilAux			:= ""
Local cCPF				:= ""
Local cTipoREP			:= ""
Local cPrefixo			:= ( PrefixoCpo( cAliasSP8 ) + "_" )
Local cSp8Fields		:= ( Padr( cPrefixo+"FILIAL" , 10 ) + "/" + Padr( cPrefixo+"MAT" , 10) + "/" + Padr( cPrefixo+"DATA" , 10 )+ "/" + Padr( cPrefixo+"DATAAPO" , 10 )+ "/" + Padr( cPrefixo+"HORA" , 10 ) + "/" + Padr( cPrefixo+"FLAG" , 10 ) )
Local cSp8RetSqlName	:= InitSqlName( cAliasSP8 )
Local lChangeQry		:= .T.
Local lSP0Comp			:= FWModeAccess("SP0",1) == "C" .AND. FWModeAccess("SP0",2) == "C" .AND. FWModeAccess("SP0",3) == "C"
Local nField			:= 0
Local lSP0TPREP 		:= SP0->( ColumnPos("P0_TPREP") ) > 0
Local lRepCarol			:= .F.
Local lCpos671 			:= fValid671()
Local cFuso				:= ""
Local cCCTREP			:= ""
Local cConec			:= ""
Local lMemoCalc			:= GetlMemoCalc()
Local nTabs				:= 0
Local cMemoQuery		:= ""
Local cCrachasMemo		:= ""
Local cFilMarc			:= ""

Local lTipoDoc			:= SP0->( ColumnPos("P0_TIPODOC") ) > 0
Local cTipoDoc			:= ""

If lPort1510
	Private aGetArea		:= {}
	Private cAliasMarc		:= ""
	
	cAliasMarc		:= "RFE"
	
	Private cPrefMarc		:= ( PrefixoCpo( cAliasMarc ) + "_" )
	Private cMarcRetSqlName	:= InitSqlName( cAliasMarc )
	Private cPerDe			:= ""
	Private cPerAte			:= ""
	Private nRecQry			:= 0
	
	DEFAULT aMarcFields		:= ( cAliasMarc )->( dbStruct() )
	DEFAULT nMarcFields 	:= Len( aMarcFields )
	
	cQryMarcAlias := ( "__Q" + cAliasMarc + "QRY" )
	
EndIf

cQrySp8Alias := ( "__Q" + cAliasSP8 + "QRY" )

Private lMultVinc	:= .F.
Private aTabMult	:= {}

If !lSP0TPREP .Or. (lSP0TPREP .And. Empty(SP0->P0_TPREP))
	cTipoREP := "1"
Else
	cTipoREP := SP0->P0_TPREP
EndIf

If SP0->P0_TIPOARQ == "R" .And. Empty(SP0->P0_REP)
	lRepCarol	:= .T.
	cConec		:= SuperGetMv("MV_APICLO3", .F., '')
	cConec		:= Left(cConec, GetSx3Cache( "RFE_NUMREP", "X3_TAMANHO"))
EndIf

If lTipoDoc
	cTipoDoc := SP0->P0_TIPODOC
	cTipoDoc := If(Empty(cTipoDoc), "1", cTipoDoc)
EndIf

Begin Sequence
	
	//Fecha a Query da SRA
	IF ( lSraQryOpened )
		SRA->( dbCloseArea() )
		ChkFile( "SRA" )
	EndIF
	
	lSraQryOpened := .F.
	
	If lPort1510
		lREP := !Empty(SP0->P0_REP) .Or. (lCaClockIn .And. SP0->P0_TIPOARQ == "R") 
	EndIf
	
	If !lTSREP .And. !lREP .Or. !lPort1510
		If lTipoDoc .And. cTipoDoc != "1"
			If cTipoDoc == "2"
				SRA->( dbSetOrder(RetOrdem( "SRA" , "RA_CIC+RA_FILIAL" )))
			Else
				SRA->( dbSetOrder(RetOrdem( "SRA" , "RA_PIS+RA_FILIAL" )))
			EndIf 
		Else
			SRA->( dbSetOrder(RetOrdem( "SRA" , "RA_CRACHA+RA_FILIAL" )))
		EndIf
	Else
		SRA->( dbSetOrder( RetOrdem( "SRA" , "RA_PIS+RA_FILIAL" ) ) )
	EndIf
	
	SPE->( dbSetOrder( RetOrdem( "SPE" , "PE_FILIAL+PE_MATPROV+PE_MAT+DTOS(PE_DATAINI)" ) ) )
	SP8->( dbSetOrder( RetOrdem( "SP8" , "P8_FILIAL+P8_MAT+DTOS(P8_DATA)+STR(P8_HORA,5,2)" ) ) )
	
	// Integracao SIGAPON x TSREP
	If lPort1510
		dbSelectArea( cTxtAlias )
	EndIf
	
	// Se a portria estiver ativa e for TOP, cria query da RFE
	If lPort1510 .and. TcSrvType() != "AS/400"
		
		aGetArea	:= GetArea()
		cPerDe 		:= If(lWorkFlow, DtoS(dPerIni - nDiasExtA), DtoS(dPerDe - nDiasExtA))
		cPerAte     := DtoS(dPerAte + nDiasExtP)
		
		If lSP0Comp
			cFilAux	:= cFilDe
			cFilDe	:= ""
		EndIf
		
		( cTxtAlias )->(dbSetOrder(RetOrder("RFE","RFE_FILIAL+RFE_CRACHA+DTOS(RFE_DATA)+STR(RFE_HORA,5,2)")))
		
		cQueryMarc := "SELECT "
		For nField := 1 To nMarcFields
			cQueryMarc += aMarcFields[ nField , 01 ] + ", "
		Next nField
		
		cQueryMarc += "R_E_C_N_O_ RECNO  "
		
		cQueryMarc := SubStr(cQueryMarc , 1 , Len( cQueryMarc ) - 2)
		
		cQueryMarc += (" FROM " + cMarcRetSqlName + " " + cAliasMarc)
		cQueryMarc += (" WHERE ( ")
		
		cQueryMarc += (cAliasMarc + "." + cPrefMarc)
		cQueryMarc += ("DATA>='"+cPerDe+"'")
		cQueryMarc += (" AND " )
		cQueryMarc += (cAliasMarc + "." + cPrefMarc)
		cQueryMarc += ("DATA<='"+cPerAte+"'")
		cQueryMarc += (") AND (")
		cQueryMarc += (cAliasMarc + "." + cPrefMarc)
		cQueryMarc += ("FLAG='0'")
		cQueryMarc += (" OR ")
		cQueryMarc += (cAliasMarc + "." + cPrefMarc)
		cQueryMarc += ("NATU='3')")
		
		If !lRepCarol
			cQueryMarc += (" AND ")
			cQueryMarc += (cAliasMarc + "." + cPrefMarc)
			cQueryMarc += ("RELOGI='"+cRelogio+"'")
			cQueryMarc += (" AND (")
			cQueryMarc += (cAliasMarc + "." + cPrefMarc)
			cQueryMarc += ("FILIAL>='"+cFilDe+"'")
			cQueryMarc += (" AND ")
			cQueryMarc += (cAliasMarc + "." + cPrefMarc)
			cQueryMarc += ("FILIAL<='"+cFilAte+"'")
			cQueryMarc += (")")
		EndIf
		
		If (lRepCarol, cQueryMarc += " AND " + cAliasMarc + "." + cPrefMarc + "NUMREP = '" + cConec + "'", Nil)
		
		cQueryMarc += ( " AND " )
		
		cQueryMarc += ( cAliasMarc + ".D_E_L_E_T_=' ' " )
		cQueryMarc += ( "ORDER BY RFE_FILIAL, RFE_PIS, RFE_CRACHA, RFE_DATA, RFE_HORA")
		
		// Salva Query Atual Para Posterior Remontagem
		cSvQuery	:= cQueryMarc
		
		cQueryMarc := ChangeQuery( cQueryMarc )
		
		dbUseArea(.T., "TOPCONN", TCGenQry(,,cQueryMarc), cQryMarcAlias, .F., .T.)
		
		For nField := 1 To nMarcFields
			IF !( aMarcFields[ nField , 02 ] == "C" )
				TcSetField(cQryMarcAlias,aMarcFields[nField,01],aMarcFields[nField,02],aMarcFields[nField,03],aMarcFields[nField,04])
			EndIF
		Next nField
		
		lMarcQryOpened := .T.
		
		If lSP0Comp
			cFilDe	:= cFilAux
		EndIf
		
		If lMemoCalc
			GravaMCalc("01", 1, "-" + STR0220 + "(PONM010)") // "Leitura por Relógio"
			GravaMCalc("01", 2, STR0207) // "Query para busca das marcações na RFE: "
			cMemoQuery := cQueryMarc
			nTabs := 3
			While Len(cMemoQuery) > 0
				GravaMCalc("01", nTabs, Left(cMemoQuery, 254), .F.)
				cMemoQuery := SubStr(cMemoQuery, 255)
				nTabs := 0
			EndDo
			//Quebra de linha
			GravaMCalc("01", 0, "")
			If (cQryMarcAlias)->(Eof())
				GravaMCalc("01", 2, STR0211) // "Nenhuma Marcação Encontrada"
			EndIf
		EndIf 
		
	EndIf
	
	// Pocisiona no Inicio do Arquivo a Ser Lido e Verifica o Numero de Campos
	If !lMarcQryOpened
		cQryMarcAlias := cTxtAlias
		( cQryMarcAlias )->( dbGotop() )
	EndIf
	
	// Loop para ler o arquivo gerado pelo relogio.
	While ( cQryMarcAlias )->( !Eof() )
		
		// Aborta o processamento
		IF ( lAbortPrint )
			aAdd(aLogFile, STR0028  + Dtoc(MsDate()) + ', as ' + Time() + ' ...') // '- Cancelado pelo Operador em '
			Break
		EndIF
		
		// Obtem o conteudo dos campos
		If lPort1510
			
			// Desconsidera as marcacoes ja processadas e cujo cracha foi reconhecido.
			If !(( cQryMarcAlias )->RFE_FLAG == "0")  .AND. (( cQryMarcAlias )->RFE_NATU <> "3")
				( cQryMarcAlias )->( dbSkip() )
				Loop
			EndIf
			
			If !lSP0Comp
				cFilRFE := ( cQryMarcAlias )->RFE_FILIAL
			Else
				cFilRFE := ""
			EndIf
			
			cCracha := ( cQryMarcAlias )->RFE_CRACHA
			cPIS	:= AllTrim(( cQryMarcAlias )->RFE_PIS)
			
			If lCpos671
				cCPF	:= AllTrim(( cQryMarcAlias )->RFE_CPF)
				cFuso	:= AllTrim(( cQryMarcAlias )->RFE_FUSO)
				cCCTREP	:= AllTrim(( cQryMarcAlias )->RFE_CCTREP)
			EndIf
			
			dData		:= ( cQryMarcAlias )->RFE_DATA
			nHora		:= ( cQryMarcAlias )->RFE_HORA
			cCodRel		:= ( cQryMarcAlias )->RFE_RELOGI
			cFuncao		:= ( cQryMarcAlias )->RFE_FUNCAO
			cGiro		:= ( cQryMarcAlias )->RFE_GIRO
			cCusto		:= ( cQryMarcAlias )->RFE_CC
			cNumRep		:= ( cQryMarcAlias )->RFE_NUMREP
			cEmpOrg		:= ( cQryMarcAlias )->RFE_EMPORG
			cDhOrg		:= ( cQryMarcAlias )->RFE_DHORG
			cIdOrg		:= ( cQryMarcAlias )->RFE_IDORG
			cFilMarc	:= ( cQryMarcAlias )->RFE_ORIG
			
			If lGeoFence
				cLatitude  := (cQryMarcAlias)->RFE_LATITU
				cLongitude := (cQryMarcAlias)->RFE_LONGIT
				cGeofence  := (cQryMarcAlias)->RFE_GEOFEN
			EndIf
			
		ElseIf !lTSREP .And. !lPort1510
			cCracha := ( cQryMarcAlias )->CRACHA
			dData	:= ( cQryMarcAlias )->DDATE
			nHora   := ( cQryMarcAlias )->HORA
			cCodRel := ( cQryMarcAlias )->CODREL
			cFuncao := ( cQryMarcAlias )->FUNCAO
			cGiro   := ( cQryMarcAlias )->GIRO
			cCusto  := ( cQryMarcAlias )->CUSTO
		EndIf
		
		// Não considera marcações que não sejam do relógio atual.
		If !lTSREP .And. !( lMarcQryOpened ) .and. ( cCodRel # cRelogio )
			( cQryMarcAlias )->( dbSkip() )
			Loop
		EndIf
		
		// Número de Marcações Lidas
		++nLidas
		
		If lMemoCalc
			GravaMCalc("01", 2, STR0212 + cIdOrg + " | " + dToC(dData) + "-" + Transform(StrZero(nHora * 100, 4), "@R XX:XX")) // "Marcação: "
			// "Data" - "Hora: " - "Crachá: "
			GravaMCalc("01", 3, "NSR: " + cIdOrg + " | " + STR0138 + ": " + dToC(dData) + " | " + STR0213 + Transform(StrZero(nHora * 100, 4), "@R XX:XX") + " | PIS: " + If(!Empty(cPIS), cPis, " ") + " | CPF: " + If(!Empty(cCPF), cCPF, " ") + " | " + STR0214 + If(!Empty(cCracha), cCracha, " "))
		EndIf
		
		// Se Relogio for de Acesso Grava Marcacao Sem consistir Cracha
		If (cControle == "A" )
			
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Desconsidera marca‡”es fora do periodo informado			  ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			If ( ( ( nSerMarc := __fDhtoNS(dData,nHora) ) < nSerIniVis ) .or. ( nSerMarc > nSerFimVis  ) )
				If Empty(aLogMarFor)
					aAdd(aLogMarFor,{(cQryMarcAlias)->RFE_FILIAL,1})
				Else
					For nY := 1 To Len(aLogMarFor)
						If aLogMarFor[nY,1] == (cQryMarcAlias)->RFE_FILIAL
							aLogMarFor[nY,2]++
						ElseIf nY == Len(aLogMarFor)
							aAdd(aLogMarFor,{(cQryMarcAlias)->RFE_FILIAL,1})
						EndIf
					Next
				EndIf

				(cQryMarcAlias)->(dbSkip())
				Loop
			EndIF
			
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Trata as Marcacoes de Acessos						           ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			cMvDespVis	:= StrTran(Upper(Alltrim(SuperGetMv("MV_DESPVIS",,"N99",cFilSPZ)))," ","")
			nDespVis	:= Val( SubStr( cMvDespVis , 2 ) )
			fVisitante(cFilSPZ, cCracha, cSpyCracha , nLenSpyCracha, cSpyVisita, nLenSpyVisita, cSpyNumero, nLenSpyNumero, dData, nHora, cCodRel, cCusto, @nGravadas, SubStr(cMvDespVis,1,1), nDespVis )
			
			If lPort1510
				If lMarcQryOpened
					nRecQry := ( cQryMarcAlias )->RECNO
					dbSelectArea(cAliasMarc)
					( cAliasMarc )->(dbGoTo(nRecQry))
					IF RecLock( cAliasMarc , .F. )
						( cAliasMarc )->RFE_NATU   := "2"
						( cAliasMarc )->RFE_FLAG   := "1"
						( cAliasMarc )->( MsUnLock() )
					EndIf
					dbSelectArea(cQryMarcAlias)
				Else
					IF RecLock( cQryMarcAlias , .F. )
						( cQryMarcAlias )->RFE_NATU   := "2"
						( cQryMarcAlias )->RFE_FLAG   := "1"
						( cQryMarcAlias )->( MsUnLock() )
					EndIf
				EndIf
			EndIf
			
			( cQryMarcAlias )->( dbSkip() )
			Loop
		Endif
		
		// Adiciona crach  na lista de "Crach s de Visitantes"
		If !lTSREP .And. ( cCracha >= cIniVisita .and. cCracha <= cFimVisita )
			If (nPos := aScan(aVisitante, {|x| x[1] == cCracha})) > 0
				aVisitante[nPos,2] ++
			Else
				aAdd(aVisitante, {cCracha, 1})
			EndIf
			If lPort1510
				If lMarcQryOpened
					nRecQry := ( cQryMarcAlias )->RECNO
					dbSelectArea(cAliasMarc)
					( cAliasMarc )->(dbGoTo(nRecQry))
					IF RecLock( cAliasMarc , .F. )
						( cAliasMarc )->RFE_NATU   := "1"
						( cAliasMarc )->RFE_FLAG   := "1"
						( cAliasMarc )->( MsUnLock() )
					EndIf
					dbSelectArea(cQryMarcAlias)
				Else
					IF RecLock( cQryMarcAlias , .F. )
						( cQryMarcAlias )->RFE_NATU   := "1"
						( cQryMarcAlias )->RFE_FLAG   := "1"
						( cQryMarcAlias )->( MsUnLock() )
					EndIf
				EndIf
			EndIf
			( cQryMarcAlias )->( dbSkip() )
			Loop
		EndIf
		
		// Posiciona o Arquivo de Funcionários de acordo com o Crachá
		If !lTSREP .And. !lREP
			If lTipoDoc .And. cTipoDoc != "1"
				If cTipoDoc == "2"
					cKeyCracha	:= cCPF
				Else
					cKeyCracha	:= cPIS
				EndIf 
			Else
				cKeyCracha	:= Left( cCracha + cSpCracha , nLenCracha )
			EndIf
		ElseIf !lTSREP .And. lREP
			If Len( cPIS ) == 12
				cPIS	:= SubStr( cPIS, 2, 11 )
			EndIf
			cKeyCracha := If(!Empty(cPIS), cPIS, cCPF)
		ElseIf lTSREP
			cPIS		:= cValToChar( cPIS )
			If Len( cPIS ) == 12
				cPIS := SubStr( cPIS, 2, 11 )
				cPIS := PadR(cPIS,12)
			EndIf
			If !Empty(cPis)
				cKeyCracha	:= cPIS
			ElseIf !Empty(cCPF)
				cKeyCracha	:= cCPF
			Else
				cKeyCracha	:= Left( cCracha + cSpCracha , nLenCracha )
			Endif
		EndIf
		
		// Adiciona a filial da marcação se existir
		If lRepCarol .And. !Empty(cFilMarc)
			cKeyCracha += cFilMarc
		EndIf
		
        //Força SetOrder para o SRA.
		If !cKeyCracha == cLastKey
			
			cLastKey := cKeyCracha
			
			If lPort1510
				If !( SRA->(IndexOrd()) >= 1 ) .Or. (Empty(cPIS) .And. lTSREP) .Or. (lREP .And. SRA->(IndexOrd()) >= 1)
					If (!lTSREP .And. !lREP) .Or. (Empty(cPIS) .And. Empty(cCPF))
						SRA->( dbSetOrder( RetOrdem( "SRA" , "RA_CRACHA+RA_FILIAL" ) ) )
					Else
						If !Empty(cPIS)
							SRA->( dbSetOrder( RetOrdem( "SRA", "RA_PIS+RA_FILIAL" ) ) )
						Else
							SRA->( dbSetOrder( RetOrdem( "SRA", "RA_CIC+RA_FILIAL" ) ) )
						EndIf
					EndIf
				EndIf
			Else
				If !( SRA->(IndexOrd()) >= 1 )
					SRA->( dbSetOrder( RetOrdem( "SRA" , "RA_CRACHA+RA_FILIAL" ) ) )
				Endif
			Endif
			
			lFound := .F.
			
			If !Empty((cQryMarcAlias)->RFE_FILORG) .And. !Empty((cQryMarcAlias)->RFE_MATORG)
				SRA->(dbSetOrder(RetOrdem( "SRA", "RA_FILIAL+RA_MAT")))
				lFound := SRA->(MsSeek( (cQryMarcAlias)->RFE_FILORG + (cQryMarcAlias)->RFE_MATORG, .F.))
			EndIf
			
			If !lFound .And. SRA->(IndexOrd()) == RetOrdem( "SRA", "RA_CRACHA+RA_FILIAL" )
				SRA->(MsSeek(cKeyCracha, .F.))
				While SRA->RA_CRACHA == cKeyCracha
					If SRA->(Eval(bSraScope))
						lFound := .T.
						EXIT
					EndIf
					SRA->(dbSkip())
				EndDo
			ElseIf !lFound
				If !Empty(cPIS) .And. !Empty(cCPF)
					For nI := 1 To 2
						If nI == 1
							cKeyCracha := cPIS
							SRA->( dbSetOrder( RetOrdem( "SRA", "RA_PIS+RA_FILIAL" ) ) )
						Else	
							cKeyCracha := cCPF
							SRA->( dbSetOrder( RetOrdem( "SRA", "RA_CIC+RA_FILIAL" ) ) )
						EndIf

						If lRepCarol .And. !Empty(cFilMarc)
							cKeyCracha += cFilMarc
						EndIf

						lFound := SRA->(MsSeek(cKeyCracha, .F.))
						
						If lFound
							cKeyCracha := cPIS
							Exit
						EndIf
					Next
				Else
					lFound := SRA->(MsSeek(cKeyCracha, .F.))
				EndIf
			EndIf
		EndIf 
		
		If lMemoCalc
			GravaMCalc("01", 3, STR0221) // "Busca pelo Funcionário:"
			GravaMCalc("01", 4, "Chave: " + cKeyCracha + " | Indice da SRA: " + SRA->(IndexKey(IndexOrd())))
			GravaMCalc("01", 4, If(lFound, STR0222 + SRA->(RA_FILIAL + " - " + RA_MAT), STR0223)) // "Funcionário Encontrado: " - "Funcionário Não Localizado"
		EndIf
		
		IF !lFound
			
			cKeyCracha	:= Left( cCracha + cSpMatPrv , nLenMatPrv )
			
			// Para localizar a filial cracha provisorio considera a filial do relogio, caso o arquivo seja exclusivo
			cFilSPE	 	:= xFilial( "SPE" , If ( !Empty(cFilRelLid), cFilRelLid, SP0->P0_FILIAL) )
			
			aCrachas := GetProv(dData, , cFilSPE, cCracha, .T.)
			
			// Procura no Cadastro de Crachas Provisorios
			nOrdSRA := SRA->( IndexOrd() )
			SRA->( dbSetOrder( RetOrdem( "SRA" , "RA_FILIAL+RA_MAT" )))
			
			cCrachasMemo := ""
			
			For nX := 1 To Len(aCrachas) > 0
				cCrachasMemo += aCrachas[1, 2]
				IF (lFound := SRA->( MsSeek( aCrachas[1, 1] + aCrachas[1, 2] , .F. )))
					cFilSRA		:= SRA->RA_FILIAL
					cMatricula	:= SRA->RA_MAT
					Exit
				EndIF
			Next
			
			If lMemoCalc
				GravaMCalc("01", 4, STR0224 + STR0225 + cCrachasMemo) // "Busca por Crachá Provisório." - "Crachás: "
				GravaMCalc("01", 4, If(lFound, STR0222 + SRA->(RA_FILIAL + " - " + RA_MAT), STR0223)) // "Funcionário Encontrado: " - "Funcionário Não Localizado"
			EndIf
			
			SRA->(dbSetOrder(nOrdSRA))
		Else
			
			cFilSRA 	:= SRA->RA_FILIAL
			cMatricula	:= SRA->RA_MAT
			nRecnoSRA	:= SRA->( Recno() )
			
			If (Empty(cMatOld), cMatOld := cMatricula, Nil)
			
			// Tratamento para verificar se ha multiplos vinculos, so para relogio REP
			If lREP .And. Empty((cQryMarcAlias)->RFE_FILORG) .And. Empty((cQryMarcAlias)->RFE_MATORG)
				
				If lMemoCalc
					GravaMCalc("01", 4, STR0215) // STR0215
				EndIf

				// Só faz a validação dos multiplos vínculos se não existir a filial da marcação.
				If !lRepCarol .Or. (lRepCarol .And. Empty(cFilMarc))
					aMultVinc := fValdMultV(cPIS, cCPF, cFilRFE, cCategoria, dData, nHora)
					
					If lMultVinc .And. !Empty(aMultVinc)
						cFilSRA 	:= aMultVinc[1, 1]
						cMatricula	:= aMultVinc[1, 2]
						cMatOld		:= cMatricula
						SRA->(dbGoTo(aMultVinc[1, 3]))
						If lMemoCalc
							GravaMCalc("01", 5, STR0216 + cFilSRA + " - " + cMatricula) // "Atribuído: "
						EndIf
					EndIf
				EndIf
			EndIf
		EndIF
		
		// Adiciona crachá na lista de "Marcações não Encontradas
		IF !( lFound )
			If lREP
				cCracha := cPIS
			EndIf
			
			IF ( nPos := aScan(aSemCracha,{|x|x[1]==cCracha}) ) > 0
				aSemCracha[nPos,2] ++
			Else
				aAdd(aSemCracha, {cCracha, 1} )
			EndIF
			
			If !lTSREP .And. lPort1510
				If lMarcQryOpened
					nRecQry := ( cQryMarcAlias )->RECNO
					dbSelectArea(cAliasMarc)
					( cAliasMarc )->(dbGoTo(nRecQry))
					IF RecLock( cAliasMarc , .F. )
						( cAliasMarc )->RFE_FLAG   := "1"
						( cAliasMarc )->( MsUnLock() )
					EndIf
					dbSelectArea(cQryMarcAlias)
				Else
					IF RecLock( cQryMarcAlias , .F. )
						( cQryMarcAlias )->RFE_FLAG   := "1"
						( cQryMarcAlias )->( MsUnLock() )
					EndIf
				EndIf
			EndIf
			
			( cQryMarcAlias )->( dbSkip() )
			Loop
		EndIF
		
		// So processa para a Filial Corrente
		IF lWorkFlow .And. lProcFilial .And. SP0->P0_TIPOARQ != "R"
			IF !( cFilSRA == cFilAnt )
				( cQryMarcAlias )->( dbSkip() )
				Loop
			EndIF
		EndIF

		// Consiste filtro do intervalo De / Ate ( Leituta TXT )
		If SRA->( !Eval( bSraScop2 ) )
			If Empty(aLogFiltro)
				aAdd(aLogFiltro, {SRA->(RA_FILIAL),SRA->(RA_MAT),1})
			Else
				For nY := 1 To Len(aLogFiltro)
					If aLogFiltro[nY,1] == SRA->(RA_FILIAL) .And. aLogFiltro[nY,2] == SRA->(RA_MAT)
						aLogFiltro[nY,3]++
					ElseIf nY == Len(aLogFiltro)
						aAdd(aLogFiltro,{SRA->(RA_FILIAL),SRA->(RA_MAT),1})
					EndIf
				Next
			EndIf

			(cQryMarcAlias)->(dbSkip())
			Loop
		EndIf
		
		// Consiste Funcionarios Demitidos
		If SRA->(RA_SITFOLH == "D" .and. !Empty(RA_DEMISSA) .and. dData > RA_DEMISSA)
			If Empty(aLogDemis)
				aAdd(aLogDemis, {SRA->(RA_FILIAL),SRA->(RA_MAT),DtoC(SRA->RA_DEMISSA),1})
			Else
				For nY := 1 To Len(aLogDemis)
					If aLogDemis[nY,1] == SRA->(RA_FILIAL) .And. aLogDemis[nY,2] == SRA->(RA_MAT)
						aLogDemis[nY,4]++
					ElseIf nY == Len(aLogDemis)
						aAdd(aLogDemis,{SRA->(RA_FILIAL), SRA->(RA_MAT),DtoC(SRA->RA_DEMISSA),1})
					EndIf
				Next
			EndIf

			(cQryMarcAlias)->(dbSkip())
			Loop
		EndIF
		
		// Se o cadastro do relogio é exclusivo não será realizada
		// a leitura/apontamento de funcionarios de outra filial
		If !Empty(cFilRFE) .And. !(AllTrim(cFilRFE) $ SRA->(RA_FILIAL)) .And. !lRepCarol
			If Empty(aLogFilDif)
				aAdd(aLogFilDif, {SRA->(RA_FILIAL),SRA->(RA_MAT),cFilRFE,1})
			Else
				For nY := 1 To Len(aLogFilDif)
					If aLogFilDif[nY,1] == SRA->(RA_FILIAL) .And. aLogFilDif[nY,2] == SRA->(RA_MAT)
						aLogFilDif[nY,4]++
					ElseIf nY == Len(aLogFilDif)
						aAdd(aLogFilDif,{SRA->(RA_FILIAL), SRA->(RA_MAT), cFilRFE,1})
					EndIf
				Next
			EndIf

			(cQryMarcAlias)->(dbSkip())
			Loop
		EndIF
		
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Consiste Funcionarios quanto à Admissão                      ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		If SRA->RA_ADMISSA > dData
			If Empty(aLogAdmis)
				aAdd(aLogAdmis,{SRA->(RA_FILIAL),SRA->(RA_MAT),DtoC(SRA->RA_ADMISSA),1})
			Else
				For nY := 1 To Len(aLogAdmis)
					If aLogAdmis[nY,1] == SRA->(RA_FILIAL) .And. aLogAdmis[nY,2] == SRA->(RA_MAT)
						aLogAdmis[nY,4]++
					ElseIf nY == Len(aLogAdmis)
						aAdd(aLogAdmis,{SRA->(RA_FILIAL),SRA->(RA_MAT),DtoC(SRA->RA_ADMISSA),1})
					EndIf
				Next
			EndIf

			(cQryMarcAlias)->(dbSkip())
			Loop
		EndIF

		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Consiste controle de acessos e filiais validas               ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		If !( lWorkFlow )
			IF SRA->( !( cFilSRA $ fValidFil() ) .or. !Eval(bAcessaSRA) )
				If Empty(aLogAceFil)
					aAdd(aLogAceFil, {SRA->(RA_FILIAL),1})
				Else
					For nY := 1 To Len(aLogAceFil)
						If aLogAceFil[nY,1] == SRA->(RA_FILIAL)
							aLogAceFil[nY,2]++
						ElseIf nY == Len(aLogAceFil)
							aAdd(aLogAceFil,{SRA->(RA_FILIAL),1})
						EndIf
					Next
				EndIf

				(cQryMarcAlias)->(dbSkip())
				Loop
			EndIF
		EndIF
		
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Consiste Afastamento do funcionario                          ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		If fAfasta(cFilSRA,cMatricula,dData,@dIniAfas,@dFimAfas,@cTipAfas)
			cMarcFer := SuperGetMv("MV_MARCFER",,"N",cFilSRA)
			IF ( cMarcFer == "N" )
				IF (;
						( dData >= dIniAfas .and. dData <= dFimAfas );
						.or.;
				   		( dData >= dIniAfas .and. Empty( dFimAfas ) );
				   	)
					If Empty(aLogFunAfa)
						aAdd(aLogFunAfa,{SRA->(RA_FILIAL),SRA->(RA_MAT),DtoC(dIniAfas),DtoC(dFimAfas),1})
					Else
						For nY := 1 To Len(aLogFunAfa)
							If aLogFunAfa[nY,1] == SRA->(RA_FILIAL) .And. aLogFunAfa[nY,2] == SRA->(RA_MAT)
								aLogFunAfa[nY,5]++
							ElseIf nY == Len(aLogFunAfa)
								aAdd(aLogFunAfa,{SRA->(RA_FILIAL),SRA->(RA_MAT),DtoC(dIniAfas),DtoC(dFimAfas),1})
							EndIf
						Next
					EndIf

					(cQryMarcAlias)->(dbSkip())
					Loop
				EndIF
			EndIF
		EndIF
		
		If cFilSRA $ cFilFECAux //Período bloqueado
			(cQryMarcAlias)->( dbSkip() )
			Loop
		EndIf
		
		// Verifica o Periodo de Apontamento
        IF !( cFilSRA == cFilOld )
			cFilOld := cFilSRA
			
			If !lSP0Comp //Se relógio não for compartilhado, verifica se fechamento esta sendo efetuado para a filial atual
				If !Pn090Open(, ,.T.,DtoS(dPerDe) + DtoS(dPerAte),.F.,cFilSRA,.F.,"A")
					If !lWorkFlow
						aAdd( aLogFile , STR0172 + cFilSRA + STR0173 ) // '- O fechamento da filial ' + SRA->RA_FILIAL + ' esta sendo efetuado em outro processo. Tente novamente mais tarde.'
					Else
						ConOut("")
						ConOut( STR0172 + cFilSRA + STR0173 )
						ConOut("")
					EndIf
					cFilFECAux += cFilSRA + "/"
					(cQryMarcAlias)->( dbSkip() )
					Loop
				Else
					lPn090Lock := .T.
				EndIf
			EndIf
			
			IF !( CheckPonMes( @dPerIni, @dPerFim, .F. , .T. , ( !( lWorkFlow ) .and. !( lChkPonMesAnt ) .and. !(lMultThread) ) , cFilOld ) )
				lChkPonMesAnt := .F.
				aAdd( aLogFile , STR0006 ) 					// '- O Periodo Informado nos Parametros e invalido. Informe um Periodo Valido'
				aAdd( aLogFile , STR0008 ) 					// 'ou'
				aAdd( aLogFile , STR0002 + " " + cFilOld )	// '- Nao Foi Encontrado periodo de Apontamento para a Filial: '
				aAdd( aLogFile , STR0007 ) 					// '- A Leitura/Apontamento nao puderam ser concluidos. Favor Cadastrar o Periodo'
				IF !( lWorkFlow )
					lAbortPrint := .T.
					If lMarcQryOpened
						(cQryMarcAlias)-> (dbCloseArea())
						RestArea( aGetArea )
					EndIf
					Break
				EndIF
			Else
				lChkPonMesAnt := .T.
			EndIF
			
			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Verifica se o Periodo eh Valido              				  ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			IF !fChkPer( dPerDe , dPerAte , cFilOld )
				aAdd( aLogFile , STR0006 ) // '- O Periodo Informado nos Parametros e invalido. Informe um Periodo Valido'
				IF !( lWorkFlow )
					lAbortPrint := .T.
					Break
				EndIF
			EndIF
			
			// Busca o ultimo período fechado da filial do funcionário
			aPerFecha := fGetSPO(cFilSRA)
			
			If lSchedDef
				nSerIni := Round( __fDhtoNS( dPerDe - nDiasExtA, 00.00 ), 5 )
				nSerFim := Round( __fDhtoNS(mv_par14 + nDiasExtP, 23.59 ), 5 )
			Else
				If lWorkFlow
					nSerIni := Round( __fDhtoNS( sToD(cPerDe) - nDiasExtA, 00.00 ), 5 )
				Else
					nSerIni := Round( __fDhtoNS( Max( dPerIni, dPerDe  ) - nDiasExtA, 00.00 ), 5 )
				EndIf 
				nSerFim := Round( __fDhtoNS( Min( dPerFim, dPerAte ) + nDiasExtP, 23.59 ), 5 )
			EndIf
			
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Verifica se Devera Carregar as Marcacoes Automaticas      em³
			³ GetMarcacoes												  ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			lGetMarcAuto := ( SuperGetMv( "MV_GETMAUT" , NIL , "S" , cFilSRA ) == "S" )
		EndIF
		
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Desconsidera marca‡”es com diferen‡as de datas maiores que 2³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		If (((nSerMarc := __fDhtoNS(dData,nHora)) < nSerIni) .Or. (nSerMarc > nSerFim)) .Or. (cControle == "R" .And. (nSerMarc < __fDhtoNS(dPerIni, 00.00) .Or. nSerMarc > nSerFim))
			If Empty(aLogMarFor)
				aAdd(aLogMarFor,{SRA->(RA_FILIAL),1})
			Else
				For nY := 1 To Len(aLogMarFor)
					If aLogMarFor[nY,1] == SRA->(RA_FILIAL)
						aLogMarFor[nY,2]++
					ElseIf nY == Len(aLogMarFor)
						aAdd(aLogMarFor,{SRA->(RA_FILIAL),1})
					EndIf
				Next
			EndIf

			(cQryMarcAlias)->(dbSkip())
			Loop
		EndIF

		// Valida se a marcação está dentro de um período fechado, se sim pula a marcação.
		If !Empty(aPerFecha)
			If !Empty(aPerFecha) .And. dData <= sToD(aPerFecha[1,3])
				If Empty(aLogPerFec)
					aAdd(aLogPerFec,{SRA->(RA_FILIAL),1})
				Else
					For nY := 1 To Len(aLogPerFec)
						If aLogPerFec[nY,1] == SRA->(RA_FILIAL)
							aLogPerFec[nY,2]++
						ElseIf nY == Len(aLogPerFec)
							aAdd(aLogPerFec,{SRA->(RA_FILIAL),1})
						EndIf
					Next
				EndIf

				(cQryMarcAlias)->(dbSkip())
				Loop
			EndIf
		EndIf
		
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Controle de refeitorio.                                     ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		IF ( cControle == "R" )
			cMvDespRef	:= StrTran(Upper(Alltrim(SuperGetMv("MV_DESPREF",,"",cFilSRA)))," ","")
			nDespRef	:= Val( SubStr( cMvDespRef , 2 ) )
			Ponm010Ref(cCodRel,cFilSRA,cMatricula,dData,nHora,Ponm010CcChk( cCusto ),SubStr(cMvDespRef,1,1),nDespRef,@nGravadas)
			
			If lPort1510
				If lMarcQryOpened
				   	dbSelectArea(cQryMarcAlias)
				   	nRecQry := ( cQryMarcAlias )->RECNO
			   		dbSelectArea(cAliasMarc)
			   		( cAliasMarc )->(dbGoTo(nRecQry))
					IF RecLock( cAliasMarc , .F. )
						( cAliasMarc )->RFE_FLAG	:= "1"
						( cAliasMarc )->RFE_FILORG	:= cFilSRA
						( cAliasMarc )->RFE_MATORG	:= cMatricula
						( cAliasMarc )->RFE_DATAAP	:= dData
						( cAliasMarc )->( MsUnLock() )
					EndIf
					dbSelectArea(cQryMarcAlias)
				Else
					IF RecLock( cQryMarcAlias , .F. )
						( cQryMarcAlias )->RFE_FLAG	:= "1"
						( cQryMarcAlias )->RFE_FILORG	:= cFilSRA
						( cQryMarcAlias )->RFE_MATORG	:= cMatricula
						( cQryMarcAlias )->RFE_DATAAP	:= dData
						( cQryMarcAlias )->( MsUnLock() )
					EndIf
				EndIf
			EndIf
			
			( cQryMarcAlias )->( dbSkip() )
			Loop
		EndIF
		
		// Reinicializa lIntMen
		lIntMen := .F.
		
		// Transforma a Data em String para Montagem da Query e da Chave de Pesquisa
		cData := Dtos( dData )
		
		// Monta Chave Auxiliar Para Pesquisa no SP8
		cKeyAux := ( cFilSRA + cMatricula + cData )
		
		// Consiste diferen‡a entre a Marcação Gravada e a Atual
		IF !( lExInAs400 )
			
			// Monta a Query Para Verificar as Marcacoes Ja Gravadas do SP8
			IF ( lChangeQry := Empty( cQuery ) )
				cQuery := "SELECT "
				For nField := 1 To nSp8Fields
					IF ( aSp8Fields[ nField , 01 ] $ cSp8Fields )
						cQuery += aSp8Fields[ nField , 01 ] + ", "
					EndIF
				Next nField
				cQuery := SubStr( cQuery , 1 , Len( cQuery ) - 2 )
				cQuery += ( " FROM " + cSp8RetSqlName + " " + cAliasSP8 )
				cQuery += ( " WHERE " )
				cQuery += ( cAliasSP8 + "." + cPrefixo )
				cQuery += ( "FILIAL='"+cFilSRA+"'" )
				cQuery += ( " AND " )
				cQuery += ( cAliasSP8 + "." + cPrefixo )
				cQuery += ( "MAT='"+cMatricula+"'" )
				cQuery += ( " AND " )
				cQuery += ( cAliasSP8 + "." + cPrefixo )
				cQuery += ( "DATA='"+cData+"'" )
				cQuery += ( " AND " )
				cQuery += ( cAliasSP8 + ".D_E_L_E_T_=' ' " )
				cQuery += ( "ORDER BY " + SqlOrder( (cAliasSP8)->( IndexKey() ) ) )
				/*/
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Salva Query Atual Para Posterior Remontagem                 ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
				cSvQuery	:= cQuery
				/*/
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Sava Filial, Matricula e Data Para Posterior remontagem   da³
				³ Query														  ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
				cSvFil		:= cFilSRA
					cSvMat		:= cMatricula
					cSvDat		:= cData
				Else
					/*/
					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					³ Remonta a Query Substituindo os Valores Anteriores pelos atu³
					³ ais														  ³
					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
					IF ( lChangeQry := !( cKeyAux == ( cSvFil + cSvMat + cSvDat ) ) )
						cQuery		:= StrTran( cSvQuery	, ( "FILIAL='"+cSvFil+"'"	) , ( "FILIAL='"+cFilSRA+"'"	) )
						cQuery		:= StrTran( cQuery		, ( "MAT='"+cSvMat+"'"		) , ( "MAT='"+cMatricula+"'"	) )
						cQuery		:= StrTran( cQuery 		, ( "DATA='"+cSvDat+"'"		) , ( "DATA='"+cData+"'"		) )
						/*/
						ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						³ Salva Query Atual Para Posterior Remontagem                 ³
						ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
						cSvQuery	:= cQuery
						/*/
						ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						³ Salva Filial, Matricula e Data Para Posterior remontagem  da³
						³ Query														  ³
						ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
						cSvFil		:= cFilSRA
						cSvMat		:= cMatricula
						cSvDat		:= cData
					EndIF
				EndIF
			IF ( lChangeQry )
				cQuery := ChangeQuery( cQuery )
			EndIF
			IF ( lSp8QryOpened := MsOpenDbf(.T.,"TOPCONN",TcGenQry(NIL,NIL,cQuery),cQrySp8Alias,.T.,.T.,.F.,.F.))
				For nField := 1 To nSp8Fields
					IF !( aSp8Fields[ nField , 02 ] == "C" )
						IF ( aSp8Fields[ nField , 01 ] $ cSp8Fields )
							TcSetField(cQrySp8Alias,aSp8Fields[nField,01],aSp8Fields[nField,02],aSp8Fields[nField,03],aSp8Fields[nField,04])
						EndIF
					EndIF
				Next nField
			EndIF
		EndIF
		IF !( lSp8QryOpened )
			cQrySp8Alias	:= cAliasSP8
			( cQrySp8Alias )->( MsSeek( cKeyAux , .F. ) )
		Else
			cKeyAux := ( cFilSRA + cMatricula )
		EndIF
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Verifica se Esta Dentro do Intervalo definido do MV_DESPMIN ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		While lDespMin .And. ( cQrySp8Alias )->( !Eof() .and. ( cKeyAux == ( P8_FILIAL + P8_MAT + If(lSp8QryOpened,"",DtoS(P8_DATAAPO))) ) )
			If lSp8QryOpened .and. ( cQrySp8Alias )->P8_DATAAPO > dData
				Exit
			EndIf
			
			IF lIntMen := ( __Min2Hrs( ( cQrySp8Alias )->( DataHora2Val( P8_DATA , P8_HORA , dData , nHora ) ) ) <= nDespMin ) .and. ( ( cQrySp8Alias )->P8_FLAG <> 'A' .or.  ( lGetMarcAuto .and. ( cQrySp8Alias )->P8_FLAG == 'A'))
				Exit
			EndIF
			( cQrySp8Alias )->( dbSkip() )
		EndDo
		
		IF ( lSp8QryOpened )
			( cQrySp8Alias )->( dbCloseArea() )
			dbSelectArea(cQryMarcAlias)
			lSp8QryOpened := .F.
		EndIF
		
		If lIntMen .And. lMemoCalc
			GravaMCalc("01", 3, STR0217) // "Marcação será gravada como Desconsiderada por conta do parâmetro MV_DESPMIN"
		EndIf
		
		
		// Não Aponta Marcações com intervalo menor que o permitido
		If ( lIntMen ) .and. !lPort1510
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ PONTO DE ENTRADA                                             ³
			³ Chamado quando alguma marcacao for descartada em funcao do   ³
			³ parametro MV_DESPMIN.                                        ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			IF ( lPonaPo6Block )
				/*/
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Atualizo a Variavel cCusto para Uso no Ponto de Entrada	  ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
				cCusto := Ponm010CcChk( cCusto )
				/*/
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Troca Filiais para Integridade		                      ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
				cFilAnt	:= IF( !Empty( cFilSRA ) , cFilSRA , cFilAnt )
				ExecBlock( "PONAPO6" , .F. , .F. )
				cFilAnt	:= cSvFilAnt
			EndIF
			
			( cQryMarcAlias )->( dbSkip() )
			Loop
		EndIF
		
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Carrega aMarcacoes                                          ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		IF Empty( aMarcacoes )
			aMarcacoes := Array( 01 , Array( ELEMENTOS_AMARC ) )
		EndIF
		aMarcacoes[ 01 , AMARC_DATA    	] := dData				  			//01 - Data da Marcacao
		aMarcacoes[ 01 , AMARC_HORA    	] := nHora				  			//02 - Hora da Marcacao
		aMarcacoes[ 01 , AMARC_ORDEM   	] := cP8Ordem			  			//03 - Ordem da Marcacao
		aMarcacoes[ 01 , AMARC_FLAG    	] := "E"				  			//04 - Flag (Origem) da Marcacao
		aMarcacoes[ 01 , AMARC_RECNO   	] := 0					   			//05 - Recno
		aMarcacoes[ 01 , AMARC_TURNO   	] := cP8Turno			   			//06 - Turno da Marcacao (Sera Carregado na PutOrdMarc())
		aMarcacoes[ 01 , AMARC_FUNCAO  	] := cFuncao			   			//07 - Funcao do Relogio
		aMarcacoes[ 01 , AMARC_GIRO    	] := cGiro				   			//08 - Giro do Relogio
		aMarcacoes[ 01 , AMARC_CC      	] := Ponm010CcChk( cCusto )			//09 - Centro de Custo da Marcacao
		aMarcacoes[ 01 , AMARC_APONTA  	] := "N"				   			//10 - Flag de Marcacao Apontada
		aMarcacoes[ 01 , AMARC_RELOGIO	] := cRelogio			  			//11 - Relogio da Marcacao
		aMarcacoes[ 01 , AMARC_TIPOMARC	] := cP8TpMarca			  			//12 - Flag de Tipo de Marcacao
		aMarcacoes[ 01 , AMARC_L_ORIGEM	] := .F.				  			//13 - Define Se a Marcacao Pode ou Nao ser (Re)Ordenada
		aMarcacoes[ 01 , AMARC_PERAPONTA] := cPerAponta			 			//15 - String de Data com o Periodo de Apontamento
		If lPort1510
			aMarcacoes[ 01 , AMARC_DATAAPO		] := CtoD('//')	  		   				//25 - Data de Apontamento
			aMarcacoes[ 01 , AMARC_NUMREP		] := cNumRep	  		   				//26 - Numero do REP
			aMarcacoes[ 01 , AMARC_TPMCREP		] := If(lIntMen,"D",Space(01))			//27 - Tipo de Marcacao no REP
			aMarcacoes[ 01 , AMARC_TIPOREG		] := "O"								//28 - Tipo de Registro
			aMarcacoes[ 01 , AMARC_MOTIVRG		] := If(lIntMen,cMotivo,cSpaceMotVrg)	//29 - Motivo da desconsideracao/inclusao
			aMarcacoes[ 01 , AMARC_EMPORG		] := cEmpOrg			   				//31 - Empresa Origem da marcacao
			aMarcacoes[ 01 , AMARC_FILORG		] := cFilSRA      		   				//32 - Filial Origem da marcacao
			aMarcacoes[ 01 , AMARC_MATORG		] := cMatricula    						//33 - Matricula Origem da marcacao
			aMarcacoes[ 01 , AMARC_DHORG		] := cDhOrg				   				//34 - Data/Hora Origem da marcacao
			aMarcacoes[ 01 , AMARC_IDORG		] := cIdOrg		   		   				//35 - Identificacao da Origem da marcacao
			
			If lMarcQryOpened
				nRecQry := ( cQryMarcAlias )->RECNO
				dbSelectArea(cAliasMarc)
				( cAliasMarc )->(dbGoTo(nRecQry))
				IF RecLock( cAliasMarc , .F. )
					( cAliasMarc )->RFE_FILORG := cFilSRA
					( cAliasMarc )->RFE_MATORG := cMatricula
					( cAliasMarc )->RFE_NATU   := "0"
					( cAliasMarc )->RFE_FLAG   := "1"
					
					If lRepCarol
						( cAliasMarc )->RFE_RELOGI	:= cRelogio
						( cAliasMarc )->RFE_RELSP0	:= cRelogio
					EndIf
					
					If lSP0Comp
						( cAliasMarc )->RFE_FILIAL   := xFilial("RFE",cFilSRA)
					EndIf
					( cAliasMarc )->( MsUnLock() )
				EndIf
				
				
				dbSelectArea(cQryMarcAlias)
			Else
				IF RecLock( cQryMarcAlias , .F. )
					( cQryMarcAlias )->RFE_FILORG := cFilSRA
					( cQryMarcAlias )->RFE_MATORG := cMatricula
					( cQryMarcAlias )->RFE_NATU   := "0"
					( cQryMarcAlias )->RFE_FLAG   := "1"
					If lSP0Comp
						( cQryMarcAlias )->RFE_FILIAL   := xFilial("RFE",cFilSRA)
					EndIf
					( cQryMarcAlias )->( MsUnLock() )
				EndIf
			EndIf
			
			If lMemoCalc
				GravaMCalc("01", 3, STR0218 + " RFE_NATU = '0' | RFE_FLAG = '1' | " + "Recno: " + cValToChar((cQryMarcAlias)->RECNO)) // "Registro atualizado na RFE."
			EndIf
			
		EndIf
		
		If lGeolocal 
			aMarcacoes[ 01 , AMARC_LATITU	] := " "		//36 - Latitude (marcacao geolocalizacao)
			aMarcacoes[ 01 , AMARC_LONGIT	] := " "		//37 - Longitude (marcacao geolocalizacao)
		EndIf
		
		If lGeoFence
			aMarcacoes[ 01 , AMARC_LATITU	] := cLatitude	//36 - Latitude (marcacao geolocalizacao)
			aMarcacoes[ 01 , AMARC_LONGIT	] := cLongitude	//37 - Longitude (marcacao geolocalizacao)
			aMarcacoes[ 01 , AMARC_GEOFENCE	] := cGeofence	//38 - Dentro ou fora do perímetro
			If cGeofence == "2" .And.  !lMVGeoFen // Despreza marcações fora do perímetro
				aMarcacoes[ 01 , AMARC_TPMCREP	] := "D"
				aMarcacoes[ 01 , AMARC_MOTIVRG	] := cMotivo
			EndIf
		EndIf
		
		If lCpos671
			aMarcacoes[ 01 , AMARC_FUSO	]	:= cFuso
			aMarcacoes[ 01 , AMARC_CCTREP ]	:= cCCTREP
		EndIf
		
		// Contador para Numero de Marcacoes Gravadas
		++nGravadas
		
		// Grava o arquivo de marcações.
		PutMarcacoes( aMarcacoes , cFilSRA , cMatricula , "SP8" , .T., Nil, Nil, Nil, lWorkFlow, nTipo )
		
		If lMemoCalc
			GravaMCalc("01", 3, STR0219) // "Marcação gravada na SP8"
		EndIf
		
		If lMarcQryOpened .And. aScan( aRegsRARFE, { |x| x[1] == SRA->( Recno() ) } ) == 0
			aAdd(aRegsRARFE, { SRA->( Recno() ) } )
		EndIf
		
		// Retira o lock virtual criado para as tabelas
		If lPn090Lock
			Pnm090UnlockPer(,.T.,,,"A") //Desfaz o lock virtual da filial
			lPn090Lock	:= .F.
		EndIf
		
		lMultVinc	:= .F.
		
		// Posiciona na Proxima marcação
		( cQryMarcAlias )->( dbSkip() )
		
	EndDo
	
	If lMarcQryOpened
		(cQryMarcAlias)-> (dbCloseArea())
		RestArea( aGetArea )
	EndIf
	
End Sequence

cFilAnt := cSvFilAnt

Return( NIL )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³SelectSra	 ³ Autor ³Marinaldo de Jesus   ³ Data ³09/09/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Funcao para Selecionar as Informacoes do SRA				 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL                                                  	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Uso      ³PONM010                                                      ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function SelectSra(lCheckRegs)

Local lSelectOk := .F.

Local nField
Local uRet

Local aStruSRA			:= {}
Local aTempSRA			:= SRA->( dbStruct() )
Local aCposSRA			:= {}
Local cCatQuery			:= ""
Local cQuery	 		:= ""
Local cQueryCond		:= ""
Local cSitQuery         := ""
Local nContField		:= 0
Local nCateg			:= 0
Local nSitua			:= 0
Local lTmpSRA			:= .F.

Default lCheckRegs		:= .F.

For nCateg:=1 to Len(cCategoria)
	cCatQuery += "'"+Subs(cCategoria,nCateg,1)+"'"
	If ( nCateg+1) <= Len(cCategoria)
		cCatQuery += ","
	EndIf
Next nCateg

For nSitua:=1 to Len(cSituacoes)
	cSitQuery += "'" + Subs(cSituacoes,nSitua,1) + "'"
	If (nSitua+1) <= Len(cSituacoes)
		cSitQuery += ","
	EndIf
Next nSitua

If lCheckRegs .And. nTipo == 1 .And. Len(aRegsRARFE) > 0
	lTmpSRA := fTmpSRA(aRegsRARFE, @oTmpSRARec)
EndIf

Begin Sequence
	
	If nTipo == 1 .And. lCheckRegs
		SRA->(dbCloseArea())
		lSraQryOpened := .F.
	EndIf
	
	If !lSraQryOpened
		If nTipo == 1 .And. lCheckRegs .And. Len( aRegsRARFE ) == 0 //Workflow e leitura de marcacoes
			Break
		EndIf
		SRA->( dbSetOrder( RetOrdem( "SRA" , "RA_FILIAL+RA_TNOTRAB+RA_SEQTURN+RA_REGRA+RA_MAT" ) ) )
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Seta apenas os Campos do SRA que serao Utilizados           ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		nContField	:= Len(aTempSRA)
		aAdd( aCposSRA , "RA_FILIAL"	)
		aAdd( aCposSRA , "RA_MAT" 		)
		aAdd( aCposSRA , "RA_NOME"		)
		aAdd( aCposSRA , "RA_CC"		)
		aAdd( aCposSRA , "RA_TNOTRAB"	)
		aAdd( aCposSRA , "RA_SEQTURN"	)
		aAdd( aCposSRA , "RA_REGRA"  	)
		aAdd( aCposSRA , "RA_ADMISSA"  	)
		aAdd( aCposSRA , "RA_DEMISSA"  	)
		aAdd( aCposSRA , "RA_CATFUNC"  	)
		aAdd( aCposSRA , "RA_SITFOLH"  	)
		aAdd( aCposSRA , "RA_HRSEMAN" 	)
		aAdd( aCposSRA , "RA_AFASFGT" 	)
		aAdd( aCposSRA , "RA_RESCRAI"   )
		aAdd( aCposSRA , "RA_MSBLQL"    )
		aAdd( aCposSRA , "RA_CRACHA"    )
		aAdd( aCposSRA , "RA_PIS"    	)
		aAdd( aCposSRA , "RA_CIC"    	)
		aAdd( aCposSRA , "RA_NASC"    	)
		
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Verifica e Seta os campos a mais incluidos no Mex             ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		fAdCpoSra(aCposSra)
		
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Ponto de Entrada para Campos do Usuario                      ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		IF ( lPnm010CposBlock )
			IF ( ValType( uRet := ExecBlock("PNM010CPOS",.F.,.F.,aCposSRA) ) == "A" )
				IF Len( uRet ) >= Len( aCposSRA )
					aCposSRA := aClone(uRet)
					uRet	 := NIL
				EndIF
			EndIF
		EndIF
		
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Abandona o Processamento									   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		IF ( lAbortPrint )
			aAdd(aLogFile, STR0028  + Dtoc(MsDate()) + ', as ' + Time() + ' ...') // '- Cancelado pelo Operador em '
			Break
		EndIF
		
		For nField := 1 To nContField
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Abandona o Processamento									   ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			IF ( lAbortPrint )
				aAdd(aLogFile, STR0028  + Dtoc(MsDate()) + ', as ' + Time() + ' ...') // '- Cancelado pelo Operador em '
				Break
			EndIF
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Carrega os Campos do SRA para a Montagem da Query			   ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			IF aScan( aCposSRA , { |x| x == AllTrim( aTempSRA[ nField , 1 ] ) } ) > 0
				aAdd( aStruSRA , aClone( aTempSRA[ nField ] ) )
			EndIF
		Next nField
		aCposSRA	:= aTempSRA := NIL
		nContField	:= Len( aStruSRA )
		cQuery := "SELECT "
		For nField := 1 To nContField
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Abandona o Processamento									   ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			IF ( lAbortPrint )
				aAdd(aLogFile, STR0028  + Dtoc(MsDate()) + ', as ' + Time() + ' ...') // '- Cancelado pelo Operador em '
				Break
			EndIF
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Inclui os Campos na Montagem da Query						   ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			cQuery += aStruSRA[ nField , 1 ] + ", "
		Next nField
		
		cQuery += "SRA.R_E_C_N_O_ "
				
		cQueryCond	:= " FROM "
		cQueryCond	+= InitSqlName("SRA") + " SRA "

		If nTipo == 1 .And. lCheckRegs .And. lTmpSRA
			cQueryCond	+= " INNER JOIN " + oTmpSRARec:GetRealName() + " TMPSRA ON TMPSRA.RECSRA = SRA.R_E_C_N_O_ "
		EndIf
		
		cQueryCond	+= "WHERE "
		cQueryCond	+= "("
		cQueryCond	+=		"SRA.RA_DEMISSA='"+Space(Len(Dtos(dPerDe)))+"'"
		cQueryCond	+= 		" OR "
		cQueryCond	+= 		"SRA.RA_DEMISSA>='"+Dtos(dPerDe)+"'"
		cQueryCond	+= ")"
		cQueryCond	+= " AND "
		cQueryCond	+= "SRA.RA_ADMISSA<='"+Dtos(dPerAte)+"'"
		cQueryCond	+= " AND "
		cQueryCond	+= "SRA.RA_FILIAL>='"+cFilDe+"'"
		cQueryCond	+= " AND "
		cQueryCond	+= "SRA.RA_FILIAL<='"+cFilAte+"'"
		cQueryCond	+= " AND "
		cQueryCond	+= "SRA.RA_TNOTRAB>='"+cTurnoDe+"'"
		cQueryCond	+= " AND "
		cQueryCond	+= "SRA.RA_TNOTRAB<='"+cTurnoAte+"'"
		cQueryCond	+= " AND "
		cQueryCond	+= "SRA.RA_MAT>='"+cMatDe+"'"
		cQueryCond	+= " AND "
		cQueryCond	+= "SRA.RA_MAT<='"+cMatAte+"'"
		cQueryCond	+= " AND "
		cQueryCond	+= "SRA.RA_NOME>='"+cNomeDe+"'"
		cQueryCond	+= " AND "
		cQueryCond	+= "SRA.RA_NOME<='"+cNomeAte+"'"
		cQueryCond	+= " AND "
		cQueryCond	+= " ( "
		cQueryCond	+= 		"SRA.RA_REGRA<>'"+cSpaceRegra+"'"
		cQueryCond	+= 		" AND "
		cQueryCond	+= 		" ( "
		cQueryCond	+= 			"SRA.RA_REGRA>='"+cRegDe+"'"
		cQueryCond	+= 			" AND "
		cQueryCond	+= 			"SRA.RA_REGRA<='"+cRegAte+"'"
		cQueryCond	+= 		" ) "
		cQueryCond	+= " ) "
		cQueryCond	+= " AND "
		cQueryCond	+= "SRA.RA_CC>='"+cCCDe+"'"
		cQueryCond	+= " AND "
		cQueryCond	+= "SRA.RA_CC<='"+cCCAte+"'"
		cQueryCond  += " AND "
		cQueryCond  += "SRA.RA_CATFUNC IN (" + Upper(cCatQuery) + ")"
		cQueryCond	+= " AND "
		cQueryCond  += "SRA.RA_SITFOLH IN (" + Upper(cSitQuery) + ")"
		cQueryCond	+= " AND "
		cQueryCond	+= "SRA.D_E_L_E_T_=' ' "
		
		cQuery		+= cQueryCond
		cQuery		+= "ORDER BY RA_CATFUNC DESC, "+SqlOrder( SRA->( IndexKey() ) )
		cQuery		:= ChangeQuery(cQuery)
		
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Abandona o Processamento									   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		IF ( lAbortPrint )
			aAdd(aLogFile, STR0028  + Dtoc(MsDate()) + ', as ' + Time() + ' ...') // '- Cancelado pelo Operador em '
			Break
		EndIF
		SRA->( dbCloseArea() ) //Fecha o SRA para uso da Query
		IF ( lSraQryOpened := MsOpenDbf(.T.,"TOPCONN",TcGenQry(,,cQuery),"SRA",.T.,.T.,.F.,.F.))
			For nField := 1 To nContField
				IF ( aStruSRA[nField,2] <> "C" )
					TcSetField("SRA",aStruSRA[nField,1],aStruSRA[nField,2],aStruSRA[nField,3],aStruSRA[nField,4])
				EndIF
			Next nField
			
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Verifica o Total de Registros a Serem Processados            ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			cQuery := "SELECT COUNT(*) QRYLASTREC "
			cQuery += cQueryCond
			cQuery := ChangeQuery(cQuery)
			IF ( MsOpenDbf(.T.,"TOPCONN",TcGenQry(,,cQuery),"__QRYCOUNT",.T.,.T.,.F.,.F.))
				nSraLstRec := __QRYCOUNT->QRYLASTREC
				__QRYCOUNT->( dbCloseArea() )
				dbSelectArea( "SRA" )
			EndIf
		Else
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Restaura Arquivo Padrao e Ordem                             ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			ChkFile( "SRA" )
			SRA->( dbSetOrder( RetOrdem( "SRA" , "RA_FILIAL+RA_TNOTRAB+RA_SEQTURN+RA_REGRA+RA_MAT" ) ) )
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Procura primeiro funcion rio.                               ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			SRA->( MsSeek( cFilTnoDe , .T. ) )
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Verifica o Total de Registros a Serem Processados            ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			IF !( lWorkFlow )
				aRecsBarG := {}
				CREATE SCOPE aRecsBarG FOR SRA->( Eval( bSraScope ) )
				MsAguarde( { || nSraLstRec := SRA->( ScopeCount( aRecsBarG ) ) } )
			EndIF
		EndIF
	Else
		SRA->( dbGotop() )
	EndIF
	
	IF !( lWorkFlow ) .And. nTipo == 1 .And. lCheckRegs
		++nCountTime
	EndIF

	lSelectOk := .T.
	
End Sequence

Return( lSelectOk  )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³Ponm010Aponta³ Autor ³Marinaldo de Jesus   ³ Data ³09/09/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Classificacao e Apontamento das Marcacoes   				 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL                                                  	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Uso      ³PONM010                                                      ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function Ponm010Aponta(lIncProc)

Local aAreaSP8		:= SP8->( GetArea("SP8") )
Local aAbonosPer	:= {}
Local aPeriodos		:= {}
Local cSvFilAnt		:= cFilAnt
Local lApHeDtm	 	:= .F.
Local lGetMarcAuto	:= .T.
Local lApontaOk		:= .T.

Local aLastApo
Local aMarcacoes
Local aMarcTot
Local aMarcDel
Local aMarcClone
Local aRecsMarcAutDele
Local aResult
Local aCalenAux		:= {}

Local cDsrAutPa
Local cPd
Local cPdEmpr
Local cFil
Local cTno
Local cMat
Local cSeq
Local cCc
Local cNome
Local cPaponta		:= SuperGetMv("MV_PAPONTA",,"")

Local dPerIGeA
Local dPerFGeA

Local lAjustMarc

Local nX
Local nSerIni
Local nSerFim
Local nMinSize
Local nSizeaMcClo
Local nSizeaMarca
Local nMarc
Local nLoop			:= 1
Local nLoopFim      := 1
Local nPosIni		:= 0
Local nPosFim		:= 0
Local nPosUtMarc
Local nPosPerIni
Local nPosPerFim

Local uPerIniDel
Local uPerFimDel
Local uRet
Local nLenCalend	:=	0
Local nOrdemData	:=	0
Local dPer1Ini
Local dPer1Fim
Local dPer2Ini
Local dPer2Fim

Local lMemoCalc		:= GetlMemoCalc()
Local lMemoCalcA	:= lMemoCalc .And. (nTipo == 2 .Or. nTipo == 3) // Apontamento

lMemoCalc := lMemoCalc .And. (nTipo == 1 .Or. nTipo == 3) // Leitura

DEFAULT lIncProc := .T.

Begin Sequence

	// Redefine variaveis.
	SRA->(;
				cFil 	:= RA_FILIAL	,;
				cTno 	:= RA_TNOTRAB	,;
				cMat 	:= RA_MAT		,;
				cSeq	:= RA_SEQTURN	,;
				cCC		:= RA_CC		,;
				cNome	:= RA_NOME		 ;
		)
	
	If lMemoCalc
		GravaMCalc("01", 1, STR0051 + ": " + SRA->RA_FILIAL + " - " + SRA->RA_MAT) //  "Funcionário"
	EndIf
	If lMemoCalcA
		GravaMCalc("02", 0, "-" + STR0051 + ": " + SRA->RA_FILIAL + " - " + SRA->RA_MAT) //  "Funcionário"
	EndIf
	
	lAjustMarc	:= ( ( PosSR6( cTno , cFil , "R6_MCIMPJC" , 01 ) == "2" ) )
	
	IF !( lWorkFlow ) .and. !lMultThread
		// Consiste controle de acessos e filiais validas
		IF SRA->( !( cFil $ fValidFil()) .or. !Eval( bAcessaSRA ))
			Break
		EndIF
	EndIF
	
	// Reinicializa aTaPadrao Quando Nao for Compartilhada
	IF !( cFil == cFilOld ) //cFil eh Atribuida a cFilOld Na proxima Comparacao
		
		// Verifica o Periodo de Apontamento
		IF !( cFil == cFilOld )
			IF !CheckPonMes( @dPerIni, @dPerFim, .F., .T. , ( !( lWorkFlow ) .and. !( lChkPonMesAnt ) .and. !(lMultThread) ) , cFil )
				lChkPonMesAnt := .F.
				aAdd( aLogFile , STR0002 ) // '- Nao Foi Encontrado periodo de Apontamento para a Filial: '
				aAdd( aLogFile , STR0007 ) // '- A Leitura/Apontamento nao puderam ser concluidos. Favor Cadastrar o Periodo'
				IF !( lWorkFlow )
					Break
				EndIF
			Else
				lChkPonMesAnt := .T.
			EndIF
			IF !fChkPer( dPerDe , dPerAte )
				aAdd( aLogFile , STR0006 ) // '- O Periodo Informado nos Parametros e invalido. Informe um Periodo Valido'
				IF !( lWorkFlow )
					lChkPonMesAnt := .F.
					Break
				EndIF
			EndIF
		EndIF
		
		// Reinicializa a Tabela de Horario Padrao
		IF xRetModo("SRA","SPJ",.F.)
			aTabPadrao := {}
		EndIF
		
		// Verifica se Devera Carregar as Marcacoes Automaticas em GetMarcacoes
		lGetMarcAuto := ( SuperGetMv( "MV_GETMAUT" , NIL , "S" , cFil ) == "S" )
	EndIF
	
	// Verifica se o funcionario foi demitido antes do Período
	IF SRA->(;
				( RA_SITFOLH == "D" );
				.and.;
				!Empty( RA_DEMISSA );
				.and.;
				( RA_DEMISSA < dPerIni );
			 )
    	Break
	EndIF
	
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Define o Periodo para a Geracao das Marcacoes Automaticas e ³
	³ Para a Montagem do Calendario e Para o Apontamento das  Mar ³
	³ cacoes                                                      ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	dPerIGeA		:= dPerDe
	dPerFGeA		:= dPerAte
	IF SRA->( RA_ADMISSA > dPerDe .and. RA_ADMISSA <= dPerAte )
		dPerIGeA	:= SRA->RA_ADMISSA
	EndIF
	IF SRA->( RA_DEMISSA < dPerAte .and. !Empty( RA_DEMISSA ) )
		dPerFGeA	:= dDataBase
	EndIF
	dPerIGeA	:= Max( dPerIGeA , dPerDe  )
	dPerFGeA	:= Min( dPerFGeA , dPerAte )
	IF ( dPerFGeA < dPerIGeA )
		Break //Demissao Anterior aa data inicial
	EndIF
	
	//sempre fazemos o apontamento do periodo anterior, atual e do proximo, pois podemos estar no fim de um periodo e inicio de outro, e conter marcações dos 2 periodos nos TXT.
	// ou podem existir marcações do período anterior, no caso de horário noturno
	nLoopFim := 2
	
	If Len(cPaponta) > 5
		dPer1Ini := dPer2Ini := dPerIni
		dPer1Fim := dPer2Fim := dPerFim
		
		// Período de apontamento futuro
		PonIncDate( @dPer1Ini, @dPer1Fim)
		
		// Período de apontamento anterior
		PonDecDate( @dPer2Ini, @dPer2Fim)
	Else
		dPer1Ini := MonthSum(dPerIni,1)
		If dPer1Ini < DaySum(dPerFim, 1)
			dPer1Ini := DaySum(dPerFim, 1) // Tratamento para fevereiro
		EndIf
		dPer1Fim := MonthSum(dPerFim,1)
		dPer2Ini := MonthSub(dPerIni,1)
		dPer2Fim := DaySub(dPerIni,1)
	EndIf
	
	aAdd(aPeriodos,dPerIni)
	aAdd(aPeriodos,dPerFim)
	aAdd(aPeriodos,dPer1Ini)
	aAdd(aPeriodos,dPer1Fim)
	If fApontAnt(dPer2Ini, dPer2Fim)
		aAdd(aPeriodos,dPer2Ini)
		aAdd(aPeriodos,dPer2Fim)
		nLoopFim := 3
	EndIf
	
	For nLoop := 1 to nLoopFim
		aTabPadrao 	:= {}
		aCalenAux  	:= {}
		
		If nLoop == 1
			nPosPerIni := nLoop
			nPosPerFim := nPosPerIni + 1
		Else
			nPosPerIni += 2
			nPosPerFim += 2
		EndIf
		
		If lMemoCalc
			GravaMCalc("01", 2, STR0234 + dToC(aPeriodos[nPosPerIni]) + " - " + dToC(aPeriodos[nPosPerFim])) // "Período: "
		EndIf
		
		If lMemoCalcA .And. nLoop == 1
			GravaMCalc("02", 1, STR0234 + dToC(aPeriodos[nPosPerIni]) + " - " + dToC(aPeriodos[nPosPerFim])) // "Período: "
		EndIf
		
		// Cria Tabela de Horário Padrão do Funcionário
		IF SRA->( !CriaCalend(	aPeriodos[nPosPerIni]	,;	//01 -> Data Inicial do Periodo
								aPeriodos[nPosPerFim]	,;	//02 -> Data Final do Periodo
								cTno		,;	//03 -> Turno Para a Montagem do Calendario
								cSeq		,;	//04 -> Sequencia Inicial para a Montagem Calendario
								@aTabPadrao	,;	//05 -> Array Tabela de Horario Padrao
								@aTabCalend	,;	//06 -> Array com o Calendario de Marcacoes
								cFil		,;	//07 -> Filial para a Montagem da Tabela de Horario
								cMat		,;	//08 -> Matricula para a Montagem da Tabela de Horario
								cCc			,;	//09 -> Centro de Custo para a Montagem da Tabela
								NIL     	,;	//10 -> Array com as Trocas de Turno
								NIL			,;	//11 -> Array com Todas as Excecoes do Periodo
								NIL			,;	//12 -> Se executa Query para a Montagem da Tabela Padrao
								.T.			,;	//13 -> Se executa a funcao se sincronismo do calendario
								NIL			 ;	//14 -> Se Forca a Criacao de Novo Calendario
							);
				)
			aAdd(aLogFile, STR0046  + AllTrim(cTno) + '.')													// '- Foram encontradas inconsistencias na Tabela do Turno'
			SRA->( aAdd(aLogFile, STR0043  + AllTrim(cMat) + ' - ' + AllTrim(cNome) + STR0044 ) )			// '  As marca‡”es do funcionario '###' nao'
			aAdd(aLogFile, STR0047 )																		// '  serao classificadas. Verificar o castramento de Tabelas de Hor rio para este Turno.'
			Break
		EndIF
		
		If !Empty(aTabCalend) .And. aTabCalend[Len(aTabCalend), CALEND_POS_TIPO_DIA] == "D" .And. aTabCalend[Len(aTabCalend), CALEND_POS_DATA] > aTabCalend[Len(aTabCalend), CALEND_POS_DATA_APO]
			SRA->( CriaCalend(	aPeriodos[nPosPerFim]+1	,;	//01 -> Data Inicial do Periodo
								aPeriodos[nPosPerFim]+1	,;	//02 -> Data Final do Periodo
								cTno		,;	//03 -> Turno Para a Montagem do Calendario
								cSeq		,;	//04 -> Sequencia Inicial para a Montagem Calendario
								{}			,;	//05 -> Array Tabela de Horario Padrao
								@aCalenAux	,;	//06 -> Array com o Calendario de Marcacoes
								cFil		,;	//07 -> Filial para a Montagem da Tabela de Horario
								cMat		,;	//08 -> Matricula para a Montagem da Tabela de Horario
								cCc			,;	//09 -> Centro de Custo para a Montagem da Tabela
								NIL     	,;	//10 -> Array com as Trocas de Turno
								NIL			,;	//11 -> Array com Todas as Excecoes do Periodo
								NIL			,;	//12 -> Se executa Query para a Montagem da Tabela Padrao
								.T.			,;	//13 -> Se executa a funcao se sincronismo do calendario
								NIL			 ;	//14 -> Se Forca a Criacao de Novo Calendario
							);
				)		
		EndIf
		
		// Monta Condicoes para verificacao das Marcações Automáticas que deverão ser Desprezadas
		IF !( lGetMarcAuto )
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Periodo Incicial											  ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			uPerIniDel	:= GetInfoPosTab( CALEND_POS_LIM_MARCACAO , "1E" , dPerIGeA , aTabCalend )
			uPerIniDel	:= DataHora2Str( uPerIniDel[1] , uPerIniDel[2] )
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Periodo Final    											  ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			uPerFimDel	:= GetInfoPosTab( CALEND_POS_LIM_MARCACAO , "__LASTMARC__" , dPerFGeA , aTabCalend )
			uPerFimDel	:= DataHora2Str( uPerFimDel[1] , uPerFimDel[2] )
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Condicao         											  ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			bCondDelAut	:= { |cDataHora| cDataHora := DataHora2Str( P8_DATA , P8_HORA ) , ( ( cDataHora >= uPerIniDel ) .and. ( cDataHora <= uPerFimDel ) ) }
		EndIF
		
		//Inicio do Processo de Classificacao das Marcacoes
			// 1=Apontamento ou 4=Marc. e Ref. ou 5=Todos
			IF (( nAponta == 1 ) .or. ( nAponta == 4 ) .or. ( nAponta == 5 ))
				
				// Verifica a Troca de Filial
				IF !( cFil == cFilOld )
					
					// Atualiza cFilOld
					cFilOld := cFil //A Atribuicao deve ser Feita Aqui pois eh a ultima comparacao
					
					// Carrega Codigos de Eventos.
					IF ( ( nTipo == 2 ) .or. ( nTipo == 3 ) ) //2=Apontamento;3=Ambos
						lApHeDtm	:= ( SuperGetMv( "MV_APHEDTM" , NIL , "N" , cFil ) == "S" )
				        cFilSP9		:= fFilFunc("SP9") //-- Obtem a Filial de Eventos
						//-- Nao carregar novamente o cadastro de eventos qdo o mesmo for compartilhado
						IF ( !Empty( cFilSP9 ) .or. ( Len( aCodigos ) == 0 ) )
							aCodigos := {}
							IF !( fCargaId( @aCodigos , cFil , .F. ) )
								aAdd(aLogFile, STR0042  + AllTrim(cFil) + '.')													// '- Nao foram encontrados eventos cadastrados para a filial '
								SRA->( aAdd(aLogFile, STR0043  + AllTrim(cMat) + ' - ' + AllTrim(cNome) + STR0044 ) )		// '  As marca‡”es do funcionario '###' nao'
								aAdd(aLogFile, STR0045 )																		// '  serao classificadas. Verificar o cadastramento de Eventos para esta filial.'
								Break
							EndIF
							cDsrAutPa	:= PosSP9( "036N" , cFilOld , "P9_CODIGO" , 2 ) //Evento DSR Mes Anterior
		   					cPd			:= PosSP9( "016A" , cFilOld , "P9_CODIGO" , 2 ) //Evento Desc. Ref.Parte Func.
	       					cPdEmpr		:= PosSP9( "015A" , cFilOld , "P9_CODIGO" , 2 ) //Evento Desc. Ref.Parte Empresa
						EndIF
					EndIF
					
				EndIF
				
				// Cria array com as marcações do Periodo para o funcionário.
				IF !GetMarcacoes(	@aMarcTot	 			,;	//01 -> Marcacoes dos Funcionarios
									@aTabCalend				,;	//02 -> Calendario de Marcacoes
									NIL						,;	//03 -> Tabela Padrao
									NIL						,;	//04 -> Turnos de Trabalho
									aPeriodos[nPosPerIni]	,;	//05 -> Periodo Inicial
									aPeriodos[nPosPerFim]	,;	//06 -> Periodo Final
									NIL						,;	//07 -> Filial
									NIL						,;	//08 -> Matricula
									NIL						,;	//09 -> Turno
									NIL						,;	//10 -> Sequencia de Turno
									NIL						,;	//11 -> Centro de Custo
									NIL						,;	//12 -> Alias para Carga das Marcacoes
									NIL						,;	//13 -> Se carrega Recno em aMarcacoes
									NIL						,;	//14 -> Se considera Apenas Ordenadas
									NIL						,;  //15 -> Verifica as Folgas Automaticas
									NIL						,;  //16 -> Se Grava Evento de Folga Mes Anterior
									lGetMarcAuto			,;	//17 -> Se Carrega as Marcacoes Automaticas
									@aRecsMarcAutDele		,;	//18 -> Registros de Marcacoes Automaticas que deverao ser Deletados
									bCondDelAut				,;	//19 -> Bloco para avaliar as Marcacoes Automaticas que deverao ser Desprezadas
									.T.						,;	//20 -> Se Considera o Periodo de Apontamento das Marcacoes
									NIL						,;	//21 -> Se Efetua o Sincronismo dos Horarios na Criacao do Calendario
									.T.					 	 ;	//22 -> Se carrega as marcacoes desconsideradas (Uso com lPort1510)
							 	)
					aAdd(aLogFile, STR0118  + AllTrim(cTno) + '.')													// '- Nao Foi Possivel Carregar as Marcacoes do Funcionario'
					SRA->( aAdd(aLogFile, STR0043  + AllTrim(cMat) + ' - ' + AllTrim(cNome) + STR0044 ) )			// '  As marca‡”es do funcionario '###' nao'
					aAdd(aLogFile, STR0119 )																		// '  serao classificadas/apontadas.'
					Break
				EndIF
				
				If lMemoCalc .And. Empty(aMarcTot)
					GravaMCalc("01", 4, STR0235) //"Nenhuma marcação encontrada para o período."
				EndIf
				
				// Copia de aMarcacoes para Comparacao na Saida
				aMarcClone := aClone( aMarcTot )
				
				If lPort1510
					aMarcacoes := {}
					aMarcDel   := {}
					aScan( aMarcTot, { |x| If (x[AMARC_TPMCREP] == "D", aAdd(aMarcDel, aClone(x)), aAdd(aMarcacoes, aClone(x)))})
				Else
					aMarcacoes := aMarcTot
				EndIf
				
				// Aborta o processamento caso seja pressionado Alt + A
				IF ( lAbortPrint )
					aAdd(aLogFile, STR0028  + Dtoc(MsDate()) + ', as ' + Time() + ' ...') // '- Cancelado pelo Operador em '
					Break
				EndIF
				
				/*/
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³Ponto de Entrada Para Array a Marcacoes antes da Ordenacao das³
				³Marcacoes, Antes do Apontamento e Antes de Gravar no SP8.     ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
				IF ( lPonapo1Block )
					
					If lMemoCalc
						GravaMCalc("01", 3, STR0236 + " PONAPO1") // "Chamada do Ponto de entrada"
					EndIf
					
					IF ( ValType( uRet := ExecBlock( "PONAPO1" , .F. , .F. , aMarcacoes ) ) == "A" )
						aMarcacoes	:= aClone( uRet )
						uRet		:= NIL
					EndIF
				EndIF
				
				If lPort1510 .and. !Empty(aMarcDel)
					For nMarc := 1 to Len(aMarcDel)
						aAdd( aMarcacoes, aClone(aMarcDel[nMarc]) )
					Next nMarc
				EndIf
				
				// Ordena as marcaões
				If lPonWork
					PutOrdMarc( @aMarcacoes, aTabCalend, (nReaponta == 1 .or. nReaponta == 3), lAjustMarc, If( nLoopFim == 1, dPerIGeA,( If( nLoop == 1, dPerIGeA, If( lLimitaDataFim, Min( dDataBase, dPerIni ), dPerIni ) ) ) ), If( nLoopFim == 1, dPerFGeA,( If( nLoop == 1, dPerFGeA, If( lLimitaDataFim, Min( dDataBase, dPerFim ), dPerFim ) ) ) ), cFil, cMat, aCalenAux, ( ( nReaponta == 1 ) .or. ( nReaponta == 3 ) ))
				Else
					PutOrdMarc( @aMarcacoes, aTabCalend, (nReaponta == 1 .or. nReaponta == 3), lAjustMarc, If( nLoop == 1, dPerIGeA, If( lLimitaDataFim, Min(dDataBase, dPerIni), dPerIni )), If( nLoop == 1, dPerFGeA, If( lLimitaDataFim, Min(dDataBase, dPerFim), dPerFim )), cFil, cMat, aCalenAux )
				EndIf
				
				If lPort1510 .and. !Empty(aMarcDel)
					aMarcTot   := aMarcacoes
					aMarcacoes := {}
					aMarcDel   := {}
					aScan( aMarcTot, { |x| If (x[AMARC_TPMCREP] == "D",aAdd(aMarcDel,aClone(x)),aAdd(aMarcacoes,aClone(x))) } )
				EndIf
				
				// Gera marcações Automáticas.
				aMarcAux:={}
				PutMarcAuto( aTabCalend , @aMarcacoes , If( nLoopFim == 1, dPerIGeA,( If( nLoop == 1, dPerIGeA, If( lLimitaDataFim, Min( dDataBase, dPerIni ), dPerIni ) ) ) ) , If( nLoopFim == 1, dPerFGeA,( If( nLoop == 1, dPerFGeA, If( lLimitaDataFim, Min( dDataBase, dPerFim ), dPerFim ) ) ) ), cFil, Nil, NIl, @aMarcAux )
				
				//-- Inclui ocorrencias de marcacoes não geradas
				If !Empty(aMarcAux)
					AADD(aMarcNoGer,{cMat + "-" + cNome, aMarcAux})
				EndIf
				
				/*/
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³Ponto de Entrada Para Array a Marcacoes Apos Ordenado e Com as³
				³Marcacoes Automaricas Antes do Apontamento e Antes de   Gravar³
				³no SP8                                                        ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
				IF ( lPonaPo5Block )
					IF ( ValType( uRet := ExecBlock("PONAPO5" , .F. , .F. , { aMarcacoes , aTabcalend } ) ) == "A" )
						aMarcacoes	:= aClone(uRet)
						uRet 		:= NIL
					EndIF
				EndIF
				
				// Troca Filiais para Integridade
				cFilAnt := IF( !Empty( cFil ) , cFil , cFilAnt )
				
				// 2=Apontamento  ou 3=Ambos
				IF (( nTipo == 2 ) .or. ( nTipo == 3 )) .And. nReaponta <> 4
					
					aResult := {}
					
					/*/
					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					³ Quando o Apontamento nao for pela data da Marcacao e nao  for³
					³ forcado o Reapontamento, carrega os Eventos que ja Haviam  si³
					³ do Apontados e que nao Sofreram  alteracoes.				   ³
					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
					IF !lApHeDtm .And. nReaponta <> 4
						aLastApo := GetLastApo( If( nLoopFim == 1, dPerIGeA,( If( nLoop == 1, dPerIGeA, If( lLimitaDataFim, Min( dDataBase, dPerIni ), dPerIni ) ) ) ) , If( nLoopFim == 1, dPerFGeA,( If( nLoop == 1, dPerFGeA, If( lLimitaDataFim, Min( dDataBase, dPerFim ), dPerFim ) ) ) ) )
						GetNewResult( @aResult , aLastApo , aMarcacoes , aTabCalend )
					EndIF

					/*/
					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					³ Verifica param.Turno se a 1a.Falta ‚ DSR e                  ³
					³ Verifica as datas de Excecoes quando for 1a.Falta=Folga     ³
					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
					fDiasFolga( aClone( aMarcacoes ) , @aTabCalend , dPerIni , dPerFim , cDsrAutPa )

					/*/
					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					³ Efetua o apontamento das marca‡”es                          ³
					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
					dPerFGeA := Min( dDataBase, dPerFGeA )
					dPerIGeA := Max( dPerIni, dPerIGeA )
					IF !Aponta(	If( nLoop == 1 .And. !lPonWork, dPerIGeA, aPeriodos[nPosPerIni] ) 	,;	//01 - Periodo Inicial do Apontamento
								If( nLoop == 1 .And. !lPonWork, dPerFGeA, aPeriodos[nPosPerFim] ) 	,;	//02 - Periodo Final do Apontamento
								@aMarcacoes								,;	//03 - Array com as Marcacoes dos Funcionarios
								aTabCalend								,;	//04 - Array com o Calendario de Marcacoes
								cFil									,;	//05 - Filial do Funcionario
								cMat									,;	//06 - Matricula do Funcionario
								aCodigos								,;	//07 - Array com os Eventos do Ponto
								@aResult								,;	//08 - Array com os Resultados Dia a Dia
								If(nLoop == 1 .Or. lPonWork, .T., .F.)	,;	//09 - Gravar Apontamento
								.F.										,;	//10 - Se Permite interrupcao durante o Processamento (HELP)
								@aLogFile								,;	//11 - Array com os Logs de Apontamento
								@aAbonosPer								,;	//12 - Array com Todos os Abonos do Periodo (Por Referencia)
								Nil										,;	//13 - Indica que foi chamada recursivamente pelo apontamento pela saída
								Nil										,;	//14 - Array com informações do acols da SPC, SP8 e SPK
								If(lPonWork .And. lLimitaDataFim,.T.,.F.);	//15 - Se limita os apontamentos utilizando a database do sistema (Obs: quando for Scheduler)
							   )
						SRA->( aAdd( aLogFile , STR0050 + STR0051 + AllTrim(cMat) + ' - ' + cFil+'/'+AllTrim( cNome ) + "."  ) ) // '- Nao foi possivel realizar o apontamento das marcacoes do' ###'funcionario '
					EndIF

				EndIF
				
				If lPort1510 .and. !Empty(aMarcDel)
					For nMarc := 1 to Len(aMarcDel)
						aAdd( aMarcacoes , aClone(aMarcDel[nMarc]) )
					Next nMarc
				EndIf
				
				// Reordena corretamente o tipo de marcação nas marcações processadas
				fAltTpMarc(@aMarcacoes)
				
				// Verifica se Houve alteracao para efetuar a gravacao
				IF !( ArrayCompare( aMarcClone, aMarcacoes ))
					
					// Deleta os Registros de Marcacoes Automaticas que foram recarregadas
					IF !( lGetMarcAuto )
						PonDelRecnos( "SP8" , aRecsMarcAutDele , bCondDelAut )
					EndIF
					
					// Procura o Elemento inicial para a Gravacao das Marcacoes
					nSizeaMcClo		:= Len( aMarcClone )
					nSizeaMarca		:= Len( aMarcacoes )
					nMinSize		:= Min( nSizeaMcClo , nSizeaMarca )
					
					// Grava as Marcacoes no SP8
					IF ( nMinSize > 0 )
						For nX := 1 To nMinSize
							IF !( ArrayCompare( aMarcClone[ nX ] , aMarcacoes[ nX ] ) )
								// Grava Apenas o que foi Alterado
								PutMarcacoes( { aMarcacoes[ nX ] } , cFil , cMat , "SP8" , .F., Nil, Nil, Nil, lWorkFlow, nTipo )
							EndIF
						Next nX
						
						// Grava as Novas informacoes
						IF ( ( nX > nMinSize ) .and. ( nMinSize < nSizeaMarca ) )
							PutMarcacoes( aMarcacoes , cFil , cMat , "SP8" , .F. , NIL , nX, Nil, lWorkFlow, nTipo )
						EndIF
					Else
						// Grava Todas as Marcacoes
						PutMarcacoes( aMarcacoes , cFil , cMat , "SP8" , .F., Nil, Nil, Nil, lWorkFlow, nTipo )
					EndIF
					
					// Reinicializa aMarcClone
					aMarcClone := {}
				EndIF
				
				If lPort1510 .and. !Empty(aMarcDel)
					aMarcTot   := aMarcacoes
					aMarcacoes := {}
					aMarcDel   := {}
					aScan( aMarcTot, { |x| If (x[AMARC_TPMCREP] == "D",aAdd(aMarcDel,x),aAdd(aMarcacoes,x)) } )
				EndIf
				
				// Ponto de Entrada Para Array a Marcacoes apos Gravar o SP8
				IF ( lPonapo2Block )
					IF ( ValType( uRet := ExecBlock( "PONAPO2" , .F. , .F. , { aMarcacoes , aTabcalend } ) ) == "A" )
						aMarcacoes	:= aClone( uRet )
						uRet		:= NIL
					EndIF
				EndIF
				
				// Executa o Ponto de Entrada Que Deixou de Ser Executado no Apontamento
				IF ( lPonaPo3Block )
					ExecBlock( "PONAPO3" , .F. , .F. , { aClone( aMarcacoes ) , aClone( aTabCalend ) } , .F. )
				EndIF
				
				// Restaura Filial de entrada da Rotina
				cFilAnt	:= cSvFilAnt
				
			EndIF
			
		// Final do Processo de Classificacao das Marcacoes
		
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Inicio do Processo de Classificacao das Refeicoes           ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			IF ( ( nAponta == 2 )  .or. ( nAponta == 4 ) .or. ( nAponta == 5 ) ) //2=Refeicoes;4=Marc e Ref ;5=Todos
				
				IF ( ( nTipo == 2 ) .or. ( nTipo == 3 ) ) //2=Apontamento 3=Ambos
					
					/*/
					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					³ Carrega Tabela de Refeicao                                  ³
					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
					IF ( cFil <> cFilRefAnt )
						cFilRefAnt := cFil
						aTabRef := {}
						IF !fTabRef( @aTabRef , fFilFunc("SP1") )
							//--Registra Inconsistencia
							IF ( aScan( aLogFile , { |x| ( x == STR0095 ) } ) == 0 )
								aAdd(aLogFile, STR0095 )			// '*** ATENCAO: APONTAMENTO NAO CONCLUIDO ***'
								aAdd(aLogFile, STR0079 )  	  		// 'Tabela de Refeicao Inconsistente:'
								aAdd(aLogFile, STR0082 + "ZZ" + " - " + STR0097 + " " + cFil )		//'- Tipo de Refeicao Nao Cadastrado: '
							EndIF
							IF ( nAponta == 2 )
								lApontaOk := .F.
							EndIF
							Break
						EndIF
					EndIF
					
					nLenCalend	:=	Len(aTabCalend)
					nOrdemData	:= aTabCalend[nLenCalend,CALEND_POS_ORDEM]
					nPosFim 	:= aScan( aTabCalend, { |x| x[2] == nOrdemData } )
					nPosUtMarc	:= nLenCalend - nPosFim
					
					/*/
					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					³ Estabelece Datas para Inicio e Final do Per¡odo            ³
					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
					If ( ( ( nPosIni := aScan( aTabCalend, { |x| x[1] == dPerDe } ) ) > 0 ) .And. ( nPosFim > 0 ) .And. ( Len( aTabCalend ) >= nPosFim + nPosUtMarc ) )
						nSerIni := __fDhtoNS( aTabCalend[ nPosIni , CALEND_POS_LIM_MARCACAO , 1 ], aTabCalend[ nPosIni, CALEND_POS_LIM_MARCACAO , 2 ] )
						nPosFim	+= nPosUtMarc
						nSerFim := __fDhtoNS( aTabCalend[ nPosFim , CALEND_POS_LIM_MARCACAO , 1 ], aTabCalend[ nPosFim ,CALEND_POS_LIM_MARCACAO , 2 ] )
						//-- Quando Ultima Sequencia da Tabela Tiver Horario Zerado, soma mais um dia
						IF ( aTabCalend[ nPosFim , CALEND_POS_HORA ] == 0 )
							++nSerFim
						EndIF
					Else
						nSerIni := __fDhtoNS( aTabCalend[ 1 , CALEND_POS_LIM_MARCACAO , 1 ], aTabCalend[ 1, CALEND_POS_LIM_MARCACAO , 2 ] )
						nSerFim := __fDhtoNS( aTabCalend[Len(aTabCalend),CALEND_POS_LIM_MARCACAO,1] , aTabCalend[Len(aTabCalend),CALEND_POS_LIM_MARCACAO,2] )
						//-- Quando Ultima Sequencia da Tabela Tiver Horario Zerado, soma mais um dia
						IF ( aTabCalend[ Len( aTabCalend ) , CALEND_POS_HORA ] == 0 )
							++nSerFim
						EndIF
					EndIf
					/*/
					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					³ Classifica as Refeicoes dos Funcionarios                    ³
					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
					IF !fGeraRef( aTabCalend , cFil , cMat , nSerIni , nSerFim , ( ( nReaponta == 2 ) .or. ( nReaponta == 3 ) ) , cPd , cPdEmpr )
					 	//--Registra Inconsistencia
			      	    aAdd(aLogFile, "" )
					    aAdd(aLogFile, STR0095 )      // '*** ATENCAO: APONTAMENTO NAO CONCLUIDO ***'
						IF ( nAponta == 2 )
							lApontaOk := .F.
						EndIF
						Break
					EndIF

				EndIF

			EndIF
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Final do Processo de Classificacao das Refeicoes            ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	Next nLoop

End Sequence

cFilAnt := cSvFilAnt
RestArea( aAreaSP8 )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Numero de Funcionarios Processados						  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
++nFuncProc

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Verifica se Deve continuar o Processamento				  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
IF ( lApontaOk )
	lApontaOk := (;
						!( lAbortPrint );
						.and.;
						( lChkPonMesAnt );
				 )
EndIF

Return( lApontaOk )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³GetDespMin   ³ Autor ³Marinaldo de Jesus   ³ Data ³09/09/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Retorna Conteudo Valido Referente ao parametro MV_DESPMIN	 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL                                                  	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Uso      ³PONM010                                                      ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function GetDespMin()
Return( Min( __Min2Hrs( Val( SuperGetMv("MV_DESPMIN",NIL,"0") ) ) , 0.59 ) )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³Ponm010CcChk ³ Autor ³Marinaldo de Jesus   ³ Data ³15/09/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Verifica se o Centro de Custo do Relogio eh Valido       	 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL                                                  	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³PONM010                                                      ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function Ponm010CcChk( cCusto )

IF Empty( cCusto )				// Se nao Tiver Centro de Custo
	cCusto := SP0->P0_CC		//Assume o Cadastrado no Relogio
	IF Empty( cCusto )      	//Caso Contrario
		cCusto := SRA->RA_CC	//Assume o Centro de Custo do SRA
	ElseIF !( Upper( AllTrim( cCusto ) ) == Upper( AllTrim( PosAlias( cAliasCc , cCusto , cFilSRA , cCampoCc , nOrdemCc , .F. ) ) ) )
		cCusto := SRA->RA_CC	//Assume o Centro de Custo do SRA Se o Centro de Custo nao Estiver Cadastrado
	EndIF
ElseIF !( Upper( AllTrim( cCusto ) ) == Upper( AllTrim( PosAlias( cAliasCc , cCusto , cFilSRA , cCampoCc , nOrdemCc , .F. ) ) ) )
	cCusto := SP0->P0_CC		//Assume o Cadastrado no Relogio
	IF Empty( cCusto )      	//Caso Contrario
		cCusto := SRA->RA_CC	//Assume o Centro de Custo do SRA
	ElseIF !( Upper( AllTrim( cCusto ) ) == Upper( AllTrim( PosAlias( cAliasCc , cCusto , cFilSRA , cCampoCc , nOrdemCc , .F. ) ) ) )
		cCusto := SRA->RA_CC	//Assume o Centro de Custo do SRA Se o Centro de Custo nao Estiver Cadastrado
	EndIF
EndIF

Return( cCusto )

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ fGeraRef ³ Autor ³ Mauricio MR           ³ Data ³ 02/08/01 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Classificar as marcacoes de refeicoes                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function fGeraRef( aTabCalend , cFil , cMat , nSerIni , nSerFim , lReaponta , cPdPar , cPdEmprPar )

Local aArea			:= GetArea()
Local aStruSP5		:= SP5->( dbStruct() )       //Colocar no Inicio do Programa
Local cAliasSP5		:= 'SP5'
Local cFilMat		:= ""
Local cSvFilAnt		:= cFilAnt
Local uRet

//-- Marcacoes de Refeicao
Local aCampos		:=	{}
//-- Query
Local nContField	:=	0
Local cQuery		:= ''
Local nX			:=	0
Local nPosCalend	:=	0
//-- Identificacao da Refeicao
Local cCodRef		:=	''
Local cSeqRef		:=	''
Local cTipoRef		:=	''
Local cGeraFol		:=	''
Local cPD			:=	''
Local cPDEmpr		:=	''
Local nSeqMarc		:=	0
Local nValref		:=	0
Local nDescFun		:=	0
Local nSerMarc		:=  0
Local nDtHrMarc		:= 0
Local cRelogio		:= ''
Local dDataApo		:= CTOD("//")

//-- Variaveis auxiliares para buscar a Identificacao das Refeicoes
Local cData			:=	''
Local cHora			:=	''
Local cHoraAux		:=	''
Local aTabRef		:=	{}   //Tabela com as Informacoes de Identificacao de Refeicao
Local aContSeq		:=	{}   //Array contador de Seq de Marcacao por Data/Tipo
Local nPosTipo		:=	0
Local lRet			:=	.T.
Local lSp5QryOpened	:= .F.

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Troca Filial para Integridade								  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
cFilAnt	:= IF( !Empty( cFil ) , cFil , cFilAnt )

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Cria array com as marca‡”es do Periodo para o funcion rio.  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
aMarcRef := {}
SP5->( dbSetOrder( RetOrdem( "SP5" , "P5_FILIAL+P5_MAT+DTOS(P5_DATA)+STR(P5_HORA,5,2)" ) ) )

IF !( lExInAs400 )
	cInicio		:= Dtos( aTabCalend[ 01 , 01 ] - 7 )
	cFinal		:= Dtos( aTabCalend[ Len(aTabCalend) , 01 ] + 7 )
	cAliasSP5	:= "QSP5"
	nContField	:= Len(aStruSP5)
	cQuery := "SELECT "
	For nX := 1 To nContField
        cQuery += aStruSP5[ nX , 01 ] + ", "
	Next nX
	cQuery += "R_E_C_N_O_ RECNO "
	cQuery += "FROM "+InitSqlName("SP5")+" SP5 "
	cQuery += "WHERE SP5.P5_FILIAL='"+SRA->RA_FILIAL+"' AND "
	cQuery += "SP5.P5_MAT='"+SRA->RA_MAT+"' AND "
	cQuery += "SP5.P5_DATA>='"+cInicio+"' AND "
	cQuery += "SP5.P5_DATA<='"+cFinal+"' AND "
	cQuery += "SP5.D_E_L_E_T_=' ' "
	cQuery += "ORDER BY "+SqlOrder( SP5->( IndexKey() ) )
	cQuery := ChangeQuery(cQuery)
	IF ( lSp5QryOpened := MsOpenDbf(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasSP5,.T.,.T.,.F.,.F.))
		For nX := 1 To nContField
			IF ( aStruSP5[nX][2] <> "C" )
				TcSetField(cAliasSP5,aStruSP5[nX][1],aStruSP5[nX][2],aStruSP5[nX][3],aStruSP5[nX][4])
			EndIF
		Next nX
	EndIF
EndIF
IF !( lSp5QryOpened )
	cAliasSP5 := "SP5"
EndIF

cFilMat := ( cFil + cMat )

IF !( lSp5QryOpened )
	(cAliasSP5)->( MsSeek( cFilMat , .F.) )
EndIF
//--Carrega as Marcacoes de Refeicao do Filial + Mat para o Array aCampos
While (cAliasSP5)->( !Eof() .and. ( cFilMat == P5_FILIAL + P5_MAT ) )

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Aborta o processamento caso seja pressionado Alt + A         ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	IF ( lAbortPrint )
		aAdd(aLogFile, STR0028  + Dtoc(MsDate()) + ', as ' + Time() + ' ...') // '- Cancelado pelo Operador em '
		Exit
	EndIF

	//-- Ignora marca‡”es fora do Per¡odo
	IF (cAliasSP5)->( nSerMarc := __fDhtoNS(P5_DATA,P5_HORA) ) < nSerIni .or. nSerMarc > nSerFim
		(cAliasSP5)->( dbSkip() )
		Loop
	EndIF
	aAdd(aCampos, Array( 16 ) )             					//-- ** Array aCampos **
 	nLenCampos := Len( aCampos )
	(cAliasSP5)->(aCampos[nLenCampos,01] := P5_DATA			)	//-- 01 Data
	(cAliasSP5)->(aCampos[nLenCampos,02] := P5_HORA			)	//-- 02 Hora
	IF !( lSp5QryOpened )
		(cAliasSP5)->(aCampos[nLenCampos,03] := Recno() )	//-- 03 Recno em SP5
	Else
		(cAliasSP5)->(aCampos[nLenCampos,03] := RECNO	)	//-- 03 Recno em SP5
	EndIF

	(cAliasSP5)->(aCampos[nLenCampos,04] := P5_CC  			)	//-- 04 Centro de Custo
	(cAliasSP5)->(aCampos[nLenCampos,05] := P5_RELOGIO 		)	//-- 05 Relogio
	(cAliasSP5)->(aCampos[nLenCampos,06] := P5_FLAG    		)	//-- 06 Flag Origem Marc
 	(cAliasSP5)->(aCampos[nLenCampos,07] := P5_SEQ    	   		)	//-- 07 Seq. Refeicao
	(cAliasSP5)->(aCampos[nLenCampos,08] := P5_TIPOREF    		)	//-- 08 Tipo Refeicao
	(cAliasSP5)->(aCampos[nLenCampos,09] := P5_GERAFOL   		)	//-- 09 Gerar p/folha
 	(cAliasSP5)->(aCampos[nLenCampos,10] := P5_PD   			)	//-- 10 Cod. Desc. Ref. Func.
  	(cAliasSP5)->(aCampos[nLenCampos,11] := P5_VALREF   		)	//-- 11 Valor da Refeicao
	(cAliasSP5)->(aCampos[nLenCampos,12] := P5_APONTA   		)	//-- 12 Flag de Apontamento
   	(cAliasSP5)->(aCampos[nLenCampos,13] := P5_CODREF  		)	//-- 13 Cod. da Refeicao
    (cAliasSP5)->(aCampos[nLenCampos,14] := P5_PDEMPR 			)	//-- 14 Cod. Desc. Ref. Empresa
	(cAliasSP5)->(aCampos[nLenCampos,15] := P5_DESCFUN			)	//-- 15 Desc. Ref. Funcionario
	(cAliasSP5)->(aCampos[nLenCampos,16] := P5_DATAAPO			)	//-- 16 Data de Apontamento
	(cAliasSP5)->( dbSkip() )

EndDo

IF ( lSp5QryOpened )
   ( cAliasSP5 )->( dbCloseArea() )
   dbSelectArea( "SP5" )
EndIF

//-- Indexa as Marcacoes de Refeicao  por Data + Hora
aSort(@aCampos,,,{|x,y| DtoS(x[1])+StrTran(StrZero(x[2],5,2),'.','') < DtoS(y[1])+StrTran(StrZero(y[2],5,2),'.','')})

//-- Inicia a Gravacao das Informacoes de Identificacao das Refeicoes
SP5->( dbSetOrder( RetOrdem( "SP5" , "P5_FILIAL+P5_MAT+DTOS(P5_DATA)+STR(P5_HORA,5,2)" ) ) )

//-- Inicializa as variavies auxiliares
nLenCampos 	:= 	Len( aCampos )  	//-- Total de Marcacoes de Refeicoes
cData		:= 	''               	//-- Variavel para verificacao de quebra de Data
cHora       := 	'' 					//-- Variavel para verificacao de quebra de Hora
cHoraAux	:= 	''

//-- Corre Todas as Marcacoes de Refeicoes para Identificar o Tipo de Refeicao
For nX := 1 to nLenCampos

	//-- Se Nao Reaponta e Aponta ='S' desconsidera para efeito de classificacao
	//-- da refeicao
	IF (!lReaponta .and. aCampos[ nX , 12 ] == "S") .Or. (!Empty(aCampos[nX,16]))
		Loop
	EndIF

	// Converte a data e hora em um número para identificar a data de apontamento
	nDtHrMarc := fDhToNS(aCampos[nX,1], aCampos[nX,2])

	//-- Posiciona na Tabela Calendario (Data)  para obter o Codigo de Ref. da Data
	IF (nPosCalend := aScan(aTabCalend, {|x| (x[CALEND_POS_LIE] <> Nil .And. x[CALEND_POS_LSS] <> Nil) .And. (nDtHrMarc >= x[CALEND_POS_LIE] .And. nDtHrMarc <= x[CALEND_POS_LSS])})) > 0
		//-- Obtem o Codigo de Refeicao da Data da Marcacao lida na TabCalend
		cCodRef	:=	aTabCalend[nPosCalend][18]
		dDataApo:=	aTabCalend[nPosCalend][CALEND_POS_DATA_APO]
	EndIF
	
	//Inicializa variavel auxiliar para conter a Hora da Refeicao
	cHoraaux :=	Str( aCampos[ nX,2 ],5,2 )

	//-- Se Codigo de Refeicao em Branco Nao houve controle sobre a Marcacao da Refeicao
	//-- gera Valores Padrao  ("ZZ" - Outros)
	If Empty(cCodRef)
	   cSeqRef		:=	''
	   cTipoRef		:=	'ZZ'
	   cGeraFol		:=	'S'
	   cPD			:=	cPdPar
       cPDEmpr		:=	cPdEmprPar
	   nValRef		:=	0
	   nDescFun		:=	0
	   dDataApo		:=  CTOD("//")
	Else
	   //Se marcacao gerada pela Leitura do Relogio
	   If aCampos[nX,6] == 'E'
		    cRelogio:=	aCampos[nX,5]
			//Identifica a Refeicao na Data/Hora marcada (Somente Checa Refeicoes Geradas)
		    If Empty(Len(aTabRef:=Aclone(fIdentRef(aTabCalend,cHoraAux,cCodRef,Dtoc( aCampos[ nX,1 ] ), cRelogio  ))))
		    	//Nao Encontrou a Tabela de Refeicao /Tipo de Refeicao de Acordo com o Codigo passado
			    lRet:= .F.
				Exit
			Endif

           	//-- Iguala Conteudo de Variaveis utilizadas para atualizacao de campos
           	//-- Conteudo de aTabRef
	   		//----	{P1_Seq, P1_TipoRef, P1_Horaini, P1_HoraFim, P1_GeraFol, P1_PD, PM_ValRef, PM_PDEMPR, PM_DESCFUN}
			cSeqRef		:=	aTabRef[1]
			cTipoRef	:=	aTabRef[2]
			cPD			:=	aTabRef[6]
			nValRef		:=	aTabRef[7]
			cPDEmpr		:=	aTabRef[8]
			nDescFun	:=	aTabRef[9]

   			//-- Se o Valor da Refeicao Nao For Nulo e Nao Houver Desconto do Funcionario
   			//-- Flag serah setado para Nao descontar o valor da refeicao na Folha de Pagto.
   			If !Empty(nValRef) .and. Empty(nDescFun)
   	  			cGeraFol	:="N"
   			Else
   				cGeraFol	:=	aTabRef[5]
   			Endif

	   Else
	   		//-- Marcacoes Cadastradas pelo Usuario sao Regravadas
			cSeqRef		:=	aCampos[nX,07]
			cTipoRef	:=	aCampos[nX,08]
			cGeraFol	:=	aCampos[nX,09]
			cPD	   		:=	aCampos[nX,10]
			nValRef		:=	aCampos[nX,11]
			cCodRef		:=  aCampos[nX,13]
			cPDEmpr		:=	aCampos[nX,14]
			nDescFun	:=	aCampos[nX,15]
	   Endif
	Endif
	//--Iguala Variaveis verificadoras de quebra Data/Hora
	cData 	:= Dtos( aCampos[ nX,1 ] )
	cHora 	:= Str( aCampos[ nX,2 ],5,2 )

	aCampos[nX,07]	:= cSeqRef
	aCampos[nX,08]	:= cTipoRef
	aCampos[nX,09]	:= cGeraFol
	aCampos[nX,10]	:= cPD
	aCampos[nX,11]	:= nValRef
	aCampos[nX,12]	:= "S"
	aCampos[nX,13]	:= cCodRef
	aCampos[nX,14]	:= cPDEmpr
	aCampos[nX,15]	:= nDescFun
	aCampos[nX,16]	:= dDataApo
	//Pega Proxima Marcacao de Refeicao
Next nX

//Se Nao foi encontrada inconformidade na rotina de classificacao gera as seq ref
If lRet
	//-- Indexa as Marcacoes de Refeicao  por Data + Tippo
	aSort(@aCampos,,,{|x,y| DtoS(x[1])+ x[8] < DtoS(y[1])+ y[8]})

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Ponto de Entrada para Tratamento das Refeicoes antes da	  ³
	³ classificacao e gravacao de suas sequencias				  ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	IF ( lPnm010Ref1Block )
		IF ( ValType( uRet := ExecBlock("PNM010REF1",.F.,.F.,aClone(aCampos) ) ) == "A" )
			 aCampos		:= If( ValType(uRet) == "A", uRet , aCampos	)
		EndIF
	EndIF

	//-- Inicializa as variavies auxiliares
	nSeqMarc 	:=	0 		//-- Sequencia da Marcacao da Refeicao
	cData		:= ''       //-- Variavel para verificacao de quebra de Data
	cTipoRef	:=	'' 		//-- Variavel para verificacao de Tipo de Refeicao

	//-- Corre Todas as Marcacoes de Refeicoes
	For nX := 1 to nLenCampos

		//--Verifica a Quebra de Data/Tipo da Marcacao
		If (cData + cTipoRef ) <>	;
		   ( Dtos( aCampos[ nX,1 ] ) + aCampos[ nX,8 ] )


			//-- Se quebra de Data
			If cData <> Dtos( aCampos[ nX,1 ] )
				cData 		:= 	Dtos( aCampos[ nX,1 ] )
			  	//-- Inicializa array contador de seq de tipo ref por Tipo
				aContSeq := {}
				nPosTipo := 0
				//-- Se ocorreu quebra de data, zera contador de Sequencia de Refeicao
				nSeqMarc :=	0
			Endif

			//Se Houve Quebra de Tipo de Refeicao na Data Lida
		    If cTipoRef  <> aCampos[ nX,8 ]

				cTipoRef	:=	aCampos[ nX,8 ]

		    	//--Inicializa a Sequencia de Marcacoes de Refeicao
				//-- Se aContSeq nao Vazia
				IF nPosTipo > 0
					aContSeq[ nPosTipo , 2 ] := nSeqMarc
					nSeqMarc := 0
				EndIF

				IF ( nPosTipo := aScan( aContSeq,{ |xtipo| xtipo[1] == cTipoRef } ) ) == 0
				    aAdd( aContSeq , { cTipoRef , 0 } )
					nPosTipo := Len( aContSeq )
				EndIF

				//-- Iguala a variavel contador de seq com o valor anterior da seq
				nSeqMarc := aContSeq[ nPosTipo , 2 ]

			Endif

		Endif

		//--Posiciona no Registro do SP5  conforme numero de registro armazenado anteriormente
		SP5->(DbGoto(aCampos[nX][3]))

		IF SP5->( RecLock( "SP5" , .F. ) )
			SP5->P5_CODREF		:= aCampos[nX][13]
			SP5->P5_SEQ			:= aCampos[nX][07]
			SP5->P5_TIPOREF		:= aCampos[nX][08]
			SP5->P5_SEQMARC		:= StrZero(++nSeqMarc,2)
			SP5->P5_GERAFOL 	:= aCampos[nX][09]
			SP5->P5_PD			:= aCampos[nX][10]
			SP5->P5_VALREF		:= aCampos[nX][11]
			SP5->P5_APONTA		:= aCampos[nX][12]
			SP5->P5_PDEMPR		:= aCampos[nX][14]
			SP5->P5_DESCFUN		:= aCampos[nX][15]
			SP5->P5_DATAAPO		:= aCampos[nX][16]
			SP5->( MsUnLock() )
		EndIF
		//Pega Proxima Marcacao de Refeicao
	Next nX
Endif

RestArea(aArea)

cFilAnt	:= cSvFilAnt

Return( lRet )

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ fIdentRef³ Autor ³ Mauricio MR           ³ Data ³ 02/08/01 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Identifica as Refeicao da Marcacao                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function fIdentRef(aTabCalend, pHora, cCodRef, cData, cRelogio)
Local aRet			:=	{}
Local nPosTabRef	:=	0
Local nPosTipoRef	:=	0
Local cHoraOrig		:=	''

cHoraOrig	:=	pHora

pHora		:=Val(pHora)


//--Procura a Tabela de Refeicao
nPosTabRef := Ascan(aTabRef, {|xRef| xRef[1] == cCodRef})

//--Se Encontrou
If !EMPTY(nPosTabRef)

    //-- Procura o Tipo de Refeicao de acordo com o horario da marcacao
    //-- Verifica se Hora ini e Hora fim forem zeradas o Tipo Ref  eh "ZZ" e por
    //-- isso nao  considera esse horario para enquadramento da hora a ser classificada
	nPosTipoRef := Ascan(aTabRef[nPosTabRef][2], {|xTabTipoRef|Iif( !Empty(xTabTipoRef[3]) .or. !Empty(xTabTipoRef[4]), ( Pna150Hor(,xTabTipoRef[3] , xTabTipoRef[4], pHora) .AND. (xTabTipoRef[10] == cRelogio)), .F.)})

    //-- Procura pelo Horario para Relogio em Branco se Nao encontrou para o relogio especifico
    If Empty(nPosTipoRef)
     	nPosTipoRef:=Ascan(aTabRef[nPosTabRef][2],;
           {|xTabTipoRef|Iif(	!Empty(xTabTipoRef[3]) .or. !Empty(xTabTipoRef[4]) 			,;
	                             ( Pna150Hor(,xTabTipoRef[3] , xTabTipoRef[4], pHora) 	.AND.   ;
	 	                         	(xTabTipoRef[10] == SPACE(LEN(xTabTipoRef[10])) )			;
	                             )		,;
                             	.F.		 ;
                             ) 			 ;
           })
    Endif

    //--Se Encontrou
    If !EMPTY(nPosTipoRef)

       //Obtem as informacoes sobre a refeicao
       // nSeqRef, cTipoRef ,  nSeqMarc	, cGeraFol	,  cPD
       aRet:=aTabRef[nPosTabRef][2][nPosTipoRef]

    Else

       	//--Registra Inconsistencia Sem Abortar Operacao
		aAdd(aLogFile, STR0079 + cCodRef )  // 'Tabela de Refeicao Inconsistente:'
		aAdd(aLogFile, STR0081 + cData+ ' '+ cHoraOrig) // '- Horario nao encontrado: '

       //Prenche array com conteudo para tipo de refeicao -> "Outros"
       	//--	{P1_Seq, P1_TipoRef, P1_Horaini, P1_HoraFim, P1_GeraFol, P1_PD, PM_ValRef}
        //-- Procura o Tipo de Refeicao "ZZ"
        nPosTipoRef:=Ascan(aTabRef[nPosTabRef][2],{|xTipoRef| xTipoRef[2] == "ZZ" })

        //--Se Encontrou Tipo "ZZ"
    	If !EMPTY(nPosTipoRef)

       		//Obtem as informacoes sobre a refeicao
       		// nSeqRef, cTipoRef ,  nSeqMarc	, cGeraFol	,  cPD
       		aRet:=aTabRef[nPosTabRef][2][nPosTipoRef]

    	Else

       		//--Registra Inconsistencia Sem Abortar Operacao
			aAdd(aLogFile, STR0079 + cCodRef )  // 'Tabela de Refeicao Inconsistente:'
			aAdd(aLogFile, STR0082 + "ZZ")	    //'- Tipo de Refeicao Nao Cadastrado: '
            aRet	:=	{'' , 'ZZ' ,,,'','', 0 }
        Endif
    Endif
Else
	//--Aborta Operacao
	aAdd(aLogFile, STR0079 + cCodRef ) // 'Tabela de Refeicao Inconsistente:'
	aAdd(aLogFile, STR0080 ) 			// '- Codigo de Tabela nao encontrado'
    aRet	:= {}
Endif

Return( aRet )

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ FTABREF   ³ Autor ³ Mauricio MR           ³ Data ³ 02/08/01 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Carregar Array com os Dados das Refeicoes para uma Filial   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ FTABREF(aTabRef,cFil)                                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ aTabRef = Array com os Dados das Refeicoes                  ³±±
±±³          ³ cFil    = Filial a ser Pesquisada                           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Ponm010                                                     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function FTABREF( aTabRef, cFil )

Local aArea			:= 	GetArea()
Local aAreaSP1		:= 	{}
Local aAreaSPM		:= 	{}
Local aTabTipoRef	:=	{}
Local cTipoRefAnt	:=	''
Local nValRef		:=	0
Local cPD			:=	''
Local cPDEmpr		:=	''
Local nDescFun      := 	0
Local nElem			:=	0
Local lRet      	:= 	.T.
Local cCodRefAnt	:= ''
Local cFilSPM		:= xFilial("SPM", cFil)

//-- Carrega Tabela de Tipos de Refeicao
dbSelectArea('SPM')
aAreaSPM := GetArea()
SPM->(MsSeek(cFilSPM))
While SPM->( !Eof() .And. PM_FILIAL == cFilSPM )
	SPM->(aAdd(aTabTipoRef, { PM_TIPOREF, PM_VALREF, PM_PD, PM_PDEMPR, Round(PM_VALREF * (PM_PERCFUN / 100), 2)}))
	SPM->(dbSkip())
EndDo

//-- Deve Haver pelo menos o Tipo de Refeicao ZZ
If Empty(aTabTipoRef)
	lRet :=	.F.
Endif

//-- Corre Refeicoes se Houver Tipos Cadastrados
If lRet
	dbSelectArea('SP1')
	aAreaSP1	:= GetArea()
	
	// |--aTabRef  (ESTRUTURA)    (Nivel 01) ----------------------------------------------
	//	 |--CodRef                (Nivel 02)
	//   	|-------P1_Seq
	//		|-------P1_TipoRef
	//		|-------P1_Horaini
	//		|-------P1_HoraFim    (Nivel 03)
	//		|-------P1_GeraFol
	//		|-------P1_PD
	//		|-------PM_ValRef
	//		|-------PM_PDEmpr
	//		|-------PM_DescFun
	//-------------------------------------------------------------------------------
	
	SP1->(MsSeek(cFil))
	While SP1->( !Eof() .And. P1_FILIAL == cFil )
		
		If SP1->P1_CODREF <> cCodRefAnt
			cCodRefAnt := SP1->P1_CODREF
			AAdd(aTabRef, {SP1->P1_CODREF, {}})
		EndIf
		
		//-- Verifica a Existencia do TipoRef na Tabela de Refeicoes
		If cTipoRefAnt # SP1->P1_TIPOREF
			cTipoRefAnt := SP1->P1_TIPOREF
			nElem :=Ascan(aTabTipoRef, {|x| x[1] == SP1->P1_TIPOREF })
			If Empty(nElem)
			   aTabRef:={}
			   //--Registra Inconsistencia Aborta Operacao
				aAdd(aLogFile, STR0079 + SP1->P1_CODREF )  // 'Tabela de Refeicao Inconsistente:'
				aAdd(aLogFile, STR0082 + SP1->P1_TIPOREF)	//'- Tipo de Refeicao Nao Cadastrado: '

			   Exit
			Endif
			
			//-- Atualiza o Valor da Refeicao de acordo com o seu tipo
			nValref	:=	aTabTipoRef[nElem,2]
			//-- Atualiza o Cod.Evento Desc. Refeicao Parte Funcionario
			cPD		:=	aTabTipoRef[nElem,3]
			//-- Atualiza o Cod.Evento Desc. Refeicao Parte Empresa
			cPDEmpr	:=	aTabTipoRef[nElem,4]
			//-- Atualiza o Valor Desconto da Refeicao Parte Funcionario
			nDescFun	:=	aTabTipoRef[nElem,5]
			
		Endif
		
		aAdd(aTail(aTabRef)[2], {	SP1->P1_SEQ			,;
									SP1->P1_TIPOREF 	,;
									SP1->P1_HORAINI 	,;
									SP1->P1_HORAFIM  	,;
									SP1->P1_GERAFOL   	,;
									cPD 		    	,;
									nValRef 		    ,;
									cPDEmpr		    	,;
									nDescFun			,;
									SP1->P1_RELOGIO		})
		
		SP1->(dbSkip())
	EndDo
	RestArea( aAreaSP1 )
Endif

RestArea( aArea )

Return( lRet )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³fVisitante   ³ Autor ³Mauricio MR		   ³ Data ³17/12/2003³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Grava Marcacoes de Visitantes								 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL                                                  	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Uso      ³PONM010                                                      ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function fVisitante(cFilSPZ, cCracha, cSpyCracha , nLenSpyCracha, cSpyVisita, nLenSpyVisita, cSpyNumero, nLenSpyNumero, dData, nHora, cCodRel, cCusto , nGravadas,  cTipDesp, nDespVis)

Local aArea			:= GetArea()
Local aSPZArea		:= SPZ->(GetArea())
Local cKey			:= ''
Local cSeek 		:= ''
Local cSetOrdem		:= ""
Local cSvFilAnt		:= cFilAnt
Local lGrava		:= .T.
Local lMin
Local nAcessos		:= 1
Local nSetOrder

DEFAULT cSpyNumero:= Space(nLenSpyNumero)
DEFAULT cSpyVisita:= Space(nLenSpyVisita)

cSetOrder			:= ""

If (Empty(cFilSPZ), cFilSPZ := Space(GetSx3Cache("PZ_FILIAL","X3_TAMANHO")), Nil)

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Data  <=> _FILIAL+_MAT+_VISITA+_CRACHA+_NUMERO+_DTOS(_DATA)+STR(_HORA,5,2)    	  	  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
cSetOrdem += "PZ_FILIAL+PZ_VISITA+PZ_CRACHA+PZ_NUMERO+DTOS(PZ_DATA)+STR(PZ_HORA,5,2)"

nSetOrder	:= RetOrdem( "SPZ" , cSetOrdem )

SPZ->( dbSetOrder( nSetOrder ) )

cCracha	:= Left(cCracha + cSpyCracha, nLenSpyCracha)

cSeek 	:= ( cFilSPZ + cSpyVisita + cCracha + cSpyNumero + Dtos(dData) + Str(nHora,5,2)+ "3" )

IF ( !Empty(cTipDesp) .and. cTipDesp $ "N_M" )
	IF ( lMin  := ( cTipDesp == "M" ) )
		nDespVis	:= __Hrs2Min( nDespVis )
		cSeek		:= (  cFilSPZ + cSpyVisita + cCracha + cSpyNumero + Dtos(dData)  )
	Else
		cSeek		:= (  cFilSPZ + cSpyVisita + cCracha + cSpyNumero + Dtos(dData) + Str(nHora,5,2)+ "3" )
	EndIF
	IF SPZ->( dbSeek( cSeek , .F. ) )
		cKey := ( cFilSPZ + cSpyVisita + cCracha + cSpyNumero + Dtos(dData) )
		While SPZ->( !Eof() .and. ( PZ_FILIAL + PZ_VISITA + PZ_CRACHA + PZ_NUMERO + Dtos(PZ_DATA) == cKey ) ;
						    .and. IF(lMin,lMin,PZ_HORA == nHora ) )
			IF ( !( lMin ) .and. ( ( ++nAcessos ) > nDespVis ) )
				lGrava := .F.
				If Empty(aLogAcesso)
					aAdd(aLogAcesso,{STR0203,1})
				Else
					aLogAcesso[1,2] += 1
				EndIf
			ElseIF ( ( lMin ) .and. ( __Hrs2Min( SPZ->( DataHora2Val(PZ_DATA,PZ_HORA,dData,nHora) ) ) <= nDespVis ) )
				lGrava := .F.
				If Empty(aLogAcesso)
					aAdd(aLogAcesso,{STR0205,1})
				Else
					aLogAcesso[1,2] += 1
				EndIf
			EndIF
			IF !( lGrava )
				Exit
			EndIF
			SPZ->( dbSkip() )
		EndDo
	EndIF
EndIF

If lGrava
	cFilAnt		:= IF( !Empty( cFilSPZ ) , cFilSPZ , cFilAnt )
	IF RecLock( "SPZ" , .T. , .T. )
		SPZ->PZ_FILIAL	:= cFilSPZ
		SPZ->PZ_CRACHA  := cCracha
		SPZ->PZ_DATA	:= dData
		SPZ->PZ_HORA	:= nHora
		SPZ->PZ_RELOGIO := cCodRel
		SPZ->PZ_TPMARCA	:= "3"
		SPZ->PZ_FLAG	:= "E"
		SPZ->( MsUnlock() )
	EndIF
	++ nGravadas
Endif

RestArea(aSPZArea)
RestArea(aArea)

cFilAnt := cSvFilAnt

Return( NIL )




/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³SelecRel     ³ Autor ³Mauricio MR		   ³ Data ³07/03/2005³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Seleciona Relogios e Arquivos para Leitura de marcacoes		 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL                                                  	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Uso      ³PONM010                                                      ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/

Static Function SelecRel(lWorkFlow, lUserDefParam, cProcFil, lProcFil, aArqSel, cTrbTmp, oCenterPanel)
Local cMarK				:= GetMark()
Local aSvKeys			:= GetKeys()
Local aAdvSize			:= {}
Local aInfoAdvSize		:= {}
Local aObjCoords		:= {}
Local aObjSize			:= {}

Local bLDblClick		:= { || RhMkMrk(cTrbTmp , .F., .F. , cCpoCtrl, cMark, @aArqSel)}
Local bAllMark			:= { || RhMkAll(cTrbTmp , .F., .T. , cCpoCtrl, cMark, oCenterPanel, @aArqSel)}

Local aBrowseFields		:= {}
Local cCpoCtrl			:= 'MARK'
Local cMsg				:= ""


//-- Variaveis de Parametros
Local nAponta
Local cFilDe
Local cFilAte
Local cFilSP0
Local cRelDe
Local cRelAte
Local lRelogios

Private	bMarkAll

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Obtem conteudo dos parametros para pesquisa		     	   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
cFilDe    := MV_PAR01
cFilAte   := MV_PAR02
cRelDe    := MV_PAR11
cRelAte   := MV_PAR12
nAponta	  := MV_PAR18

cFilSP0   := IF( !Empty( xFilial("SP0") ) , cFilDe , Space(02) )

lRelogios:= Relogios(cTrbTmp, @aBrowseFields, cMark, @aArqSel, cFilSP0, cFilAte, cRelDe, cRelAte, nAponta)

oTButton := TButton():Create(oCenterPanel,,, STR0244, {|| Relogios(cTrbTmp, @aBrowseFields, cMark, @aArqSel, cFilSP0, cFilAte, cRelDe, cRelAte, nAponta, oCenterPanel)}, 60, 15,,,, .T.,,)

Begin Sequence
    //-- Verifica a Existencia de Relogios conforme parametros
	If !lRelogios
		cMsg := STR0131	//"Não foram encontrados"
   		cMsg += CRLF
   		cMsg += STR0132 //Relógios conforme os "
   		cMsg += CRLF
   		cMsg += STR0133 //"parâmetros:"
    	cMsg += CRLF
   		cMsg += STR0134 //"Filial De e Até, "
    	cMsg += CRLF
   		cMsg += STR0135 //"Relógio De e Até, "
    	cMsg += CRLF
   		cMsg += STR0136 //"ou Leitura/Apontamento."
   		MsgInfo( OemToAnsi( cMsg ) , cCadastro )
	Endif

	(cTrbTmp)->(dbGotop())

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Define a Tecla de Atalho para Marcar Todos <F9>       	   	   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	bMarkAll := {|| CursorWait(), Eval(bAllMark), CursorArrow()}
	
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Monta as Dimensoes para o Dialogo Principal				   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	aAdvSize	:= MsAdvSize()

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Monta as Dimensoes dos Objetos                               ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	aInfoAdvSize	:= { aAdvSize[1] , aAdvSize[2] , aAdvSize[3] , aAdvSize[4] , 0 , 0 }
	aAdd( aObjCoords , { 000 , 000 , .T. , .T. } )
	aObjSize		:= MsObjSize( aInfoAdvSize , aObjCoords )
	aMsSltCoords	:= { aObjSize[1,1] , aObjSize[1,2] , aObjSize[1,3] , aObjSize[1,4] }

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Monta Dialogo 						                       ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	oMsSelect := MsSelect():New(;
									cTrbTmp	,;	//Alias	do Arquivo de Filtro
									cCpoCtrl        ,;	//Campo para controle do mark
									NIL				,;	//Condicao para o Mark
									aBrowseFields	,;	//Array com os Campos para o Browse
									.F.				,;	//lInverte
									cMark			,;	//Conteudo a Ser Gravado no campo de controle do Mark
									aMsSltCoords	,;	//Coordenadas do Objeto
									NIL				,;  //?
									NIL				,;	//?
									oCenterPanel	 ;	//Objeto Dialog
							)

	oMsSelect:oBrowse:lCanAllMark	:= .T.
	oMsSelect:oBrowse:lHasMark	 	:= .T.
	oMsSelect:bMark	 				:= bLDblClick
	oMsSelect:oBrowse:bAllMark      := bMarkAll
	oMsSelect:oBrowse:Refresh()
	oCenterPanel:Refresh()

	RestKeys( aSvKeys , .T. )

	CursorArrow()
End Sequence
Return

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³GetParam     ³ Autor ³Mauricio MR		   ³ Data ³14/03/2005³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Obtem os conteudos dos parametros			   		         ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL                                                  	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Uso      ³PONM010                                                      ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function GetParam(lInicializa, cChar)
//-- Variaveis de Parametros
Local nAponta
Local cFilDe
Local cFilAte
Local cRelDe
Local cRelAte
Local lok := .F.

DEFAULT lInicializa	:=.F.
/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Setando as Perguntas que serao utilizadas no Programa        ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
If lInicializa .AND. !lSchedDef
	Pergunte( "PNM010" , .F. )
Endif

While !lOk

	lOk := .T.

	cFilDe    := IF( lWorkFlow .and. lUserDefParam .and. !lProcFilial , mv_par01 , IF( !lWorkFlow .OR. lSchedDef , mv_par01 , IF( lProcFilial , cFilAnt , "" ) ) )		//Filial De
	cFilAte   := IF( lWorkFlow .and. lUserDefParam .and. !lProcFilial , mv_par02 , IF( !lWorkFlow .OR. lSchedDef , mv_par02 , IF( lProcFilial , cFilAnt , Replicate(cChar,Len(SRA->RA_FILIAL) ) ) ) )								//Filial Ate
	cRelDe    := IF( lWorkFlow .and. lUserDefParam , mv_par11 , IF( !lWorkFlow .OR. lSchedDef , mv_par11 , ""	) )										  // Relogio De
	cRelAte   := IF( lWorkFlow .and. lUserDefParam , mv_par12 , IF( !lWorkFlow .OR. lSchedDef , mv_par12 , Replicate(cChar,Len(SP0->P0_RELOGIO) ) ) ) // Relogio Ate
	nAponta	  := IF( lWorkFlow .and. lUserDefParam , mv_par18 , IF( !lWorkFlow .OR. lSchedDef , mv_par18 , 3	) )																													//Leitura/Apontamento 1=Marcacoes 2=Refeicoes 3=Acesso 4=Marcacoes e Refeicoes 5=Todos

	__LastParam__:= {cFilDe,cFilAte,cRelDe,cRelAte, nAponta}


	//-- Validar se a tabela SP0 - relógios é compartilhada
	//-- e se o mv_par20 está por relógio e o mv_par01 preenchido
	If !lInicializa
		If Empty(xFilial("SP0"))
			If mv_par20 == 2 .and. !Empty(mv_par01)
				Help("",1,"PONM010VALPAR")
				lOk := .F.
				Pergunte( "PNM010" , .T. )
			EndIf
		EndIf
	EndIf

Enddo

Return

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³RhMkAll      ³ Autor ³Mauricio MR		   ³ Data ³07/03/2005³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Marca/Desmarca todos os elementos do browse   		         ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL                                                  	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Uso      ³PONM010                                                      ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/

Static Function RhMkAll( cAlias, lInverte, lTodos, cCpoCtrl, cMark, oDlg, aArqSel )
Local nRecno		:= (cAlias)->(Recno())

(cAlias)->( dbGotop() )

While (cAlias)->( !Eof() )

	RhMkMrk( cAlias , lInverte , lTodos, cCpoCtrl, cMark, aArqSel)

	(cAlias)->( dbSkip() )
EndDo

(cAlias)->( MsGoto( nRecno ) )

oDlg:Refresh()
Return

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³RhMkMrk      ³ Autor ³Mauricio MR		   ³ Data ³07/03/2005³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Marca/Desmarca um elemento do browse   				         ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL                                                  	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Uso      ³PONM010                                                      ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/

Function RhMkMrk( cAlias , lInverte , lTodos, cCpoCtrl, cMark, aRel)
Local cTemp
Local cSpaceMarca	:= Space(Len(cMark))

DEFAULT cAlias		:= Alias()

If lTodos
    If lInverte
	   	If IsMark( cCpoCtrl, cMarK)
		  cTemp:= cSpaceMarca
		Else
	      cTemp:= cMark
		Endif
	Else
		cTemp:=cMark
	Endif
Else
	If IsMark( cCpoCtrl, cMarK, lInverte)
		cTemp:= If(lInverte, cSpaceMarca, cMark)
	Else
	   cTemp:= If(lInverte, cMark, cSpaceMarca)
	Endif
Endif


//-- Alteracao Selecao
(cAlias)->(RecLock(cAlias,.F.))
	&(cAlias+'->'+cCpoCtrl) := cTemp
(cAlias)->(MsUnlock())

Return .T.


/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³RhRel        ³ Autor ³Mauricio MR		   ³ Data ³07/03/2005³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Array FINAL com os Relogios Selecionados			   		 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL                                                  	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Uso      ³PONM010                                                      ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/

Static Function RhRel( cAlias, aRel )
Local nPosRel

(cAlias)->( dbGotop() )

//-- Corre Todos os Registros de Filial+Relogios+Arquivos
While (cAlias)->( !Eof() )

 	//Se Selecionou novo Arquivo
     If !Empty( (cAlias)->MARK )
		 If !Empty(aRel) .AND. !Empty((nPosRel:=Ascan(aRel,{|x| x[1] = (cAlias)->(Filial+Relogio)})))
	 		//-- Adiciona o Novo Arquivo Selecionado a Filial+Relogio ja existente
		 	AADD(aRel[nPosRel,2], (cAlias)->Arquivo)
		 Else
		     //-- Adiciona nova Chave Filial+Relogio e o Novo Arquivo
		   	  AADD(aRel, { (cAlias)->(Filial+Relogio), {(cAlias)->Arquivo} } )
		 Endif
	 Endif
	(cAlias)->( dbSkip() )
EndDo

Return

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³Relogios     ³ Autor ³Mauricio MR		   ³ Data ³07/03/2005³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Obtem os Relogios para Selecao via  browse  		         ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL                                                  	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Uso      ³PONM010                                                      ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/

Static Function Relogios(cAliasTemp, aBrowseFields,   cMark, aRel, cFilSP0, cFilAte, cRelDe, cRelAte, nAponta, oCenterPanel)
Local aHeader
Local aCposOrigem:= { "P0_FILIAL", "P0_RELOGIO", "P0_DESC","P0_TIPOARQ", "P0_CONTROL", "P0_ARQUIVO"}
Local aCols
Local aSelArq
Local lRet := .T.

Default oCenterPanel := Nil

cFilSP0	:= MV_PAR01
cFilAte	:= MV_PAR02
cRelDe	:= MV_PAR11
cRelAte	:= MV_PAR12

//-- Carrega todos os Registros de Relogios conforme Filial e Relogio
aCols := GetRelogios(@aHeader, cFilSP0, cFilAte, cRelDe, cRelAte, nAponta)

//-- Carrega todos os Arquivos conforme os diretorios especificados em cada Relogio
If !Empty(aSelArq	:=	AppendArquivos(aHeader, aCols))
	If oMsSelect <> NIl .And. oCenterPanel <> Nil
		oMsSelect:oBrowse:Refresh()
		oCenterPanel:Refresh()
	EndIf
Else
    //-- Nao existem relogios conforme parametros informados
    lRet := .F.
EndIf

//-- Cria Arquivo temporario mesmo q vazio para poder utilizar o oMsSelect
CriaArqRel(cMark, aCposOrigem, @aBrowseFields, aHeader, aSelArq, aRel, cAliasTemp,'FILIAL+RELOGIO')

Return lRet

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³CriaArqRel   ³ Autor ³Mauricio MR		   ³ Data ³07/03/2005³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Cria Arquivo de Relogios para Selecao via  browse  	         ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL                                                  	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Uso      ³PONM010                                                      ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/

Static Function CriaArqRel(cMarca, aCposOrigem,aBrowseFields,  aHeader, aSelArq, aRel, cAliasTemp, cKeyInd)
Local cSpaceMarca	:= Space(Len(cMarca))
Local aFields		:= {}
Local cCampo
Local cRotina		:= 'PONM010'
Local lRet			:= .T.
Local nLoop
Local nOriginal
Local nPosCpo
Local nTotLoop
Local aLstIndices := {}
If !Empty(Select(cAliasTemp))
	dbSelectArea(cAliasTemp)
	dbCloseArea()

	If oTmpTabFO1 <> Nil
	    oTmpTabFO1:Delete()
	    Freeobj(oTmpTabFO1)
    EndIf
Endif

//-- Adiciona Campo de Selecao para o MarkBorwse
AADD(aFields,{	'MARK','C',2,	0 })
AADD(aBrowseFields,	{'MARK', cRotina, ""})

//-- Adiciona Demais Campos do Arquivo Temporario
nTotLoop	:= Len(aCposOrigem)
For nLoop:=1 To nTotLoop
	nPosCpo	:= 	GdFieldPos(aCposOrigem[nLoop]	,aHeader)
	cCampo	:=	STRTRAN(aHeader[nPosCpo,__AHEADER_FIELD__], 'P0_',"")

	If cCampo == "DESC"//erro de frame caso exista um campo de nome DESC no aFields.Por esta razão, modifiquei o nome
		cCampo := "XDESC"
	EndIf

	AADD(aFields,{	cCampo          					,;
	               	aHeader[nPosCpo,__AHEADER_TYPE__]	,;
	               	aHeader[nPosCpo,__AHEADER_WIDTH__]	,;
	               	aHeader[nPosCpo,__AHEADER_DEC__] 	;
	             };
	      )
   AADD(aBrowseFields,{	cCampo, cRotina, aHeader[nPosCpo,__AHEADER_TITLE__] } )
Next nLoop

//Abre o Arquivo Temporario

AAdd (aLstIndices, {"FILIAL","RELOGIO"}  )
oTmpTabFO1:= RhCriaTrab(cAliasTemp, aFields, aLstIndices)

IF (lRet := (Select( cAliasTemp ) > 0 .And. Len(aSelarq) > 0))

	nTotLoop	:= Len(aSelarq)
	nOriginal	:= Len( aSelArq[1] )

	ProcRegua( (cAliasTemp)->(RecCount()) / ((cAliasTemp)->(RecCount())) )

	For nLoop:=1 to nTotLoop

   	    (cAliasTemp)->(Reclock(cAliasTemp,.T.) )

   		(cAliasTemp)->MARK 		:= If( aSelArq[nLoop,nOriginal], cMarca, cSpaceMarca)
		(cAliasTemp)->FILIAL 	:= aSelArq[nLoop,1]
	    (cAliasTemp)->RELOGIO 	:= aSelArq[nLoop,2]
	    (cAliasTemp)->TIPOARQ 	:= aSelArq[nLoop,3]
	    (cAliasTemp)->CONTROL 	:= aSelArq[nLoop,4]
	    (cAliasTemp)->XDESC 	:= aSelArq[nLoop,5]
   		(cAliasTemp)->ARQUIVO	:= aSelArq[nLoop,6]

   	    (cAliasTemp)->(MsUnlock())


 		//Se Selecionou novo Arquivo
    	If !Empty((cAliasTemp)->MARK )
	       //-- Adiciona nova Chave Filial+Relogio e o Novo Arquivo
    	   AADD(aRel, { (cAliasTemp)->(FILIAL+RELOGIO), {(cAliasTemp)->ARQUIVO} } )
    	Endif

       	IncProc( STR0130 + (cAliasTemp)->FILIAL+ " / " + (cAliasTemp)->RELOGIO )

	Next nLoop
	(cAliasTemp)->( dbGotop() )
EndIF

Return( lRet )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³AppendArquivos   ³ Autor ³Mauricio MR	   ³ Data ³07/03/2005³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Obtem Arquivos para cada Relogio Existente				     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL                                                  	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Uso      ³PONM010                                                      ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/

Static Function AppendArquivos(aHeader, aCols)
Local aFiles
Local aSelArq    	:= {}
Local cFilRel
Local cFile
Local cTipo
Local cRelogio
Local cControle
Local cDesc
Local nLoop
Local nTot 			:= Len(aCols)
Local nPosFilial
Local nPosArq
Local nPosDesc
Local nPosTipo
Local nPosRelogio
Local nPosControle

nPosFilial	:=	GdFieldPos("P0_FILIAL"	,aHeader)
nPosArq		:=	GdFieldPos("P0_ARQUIVO"	,aHeader)
nPosTipo	:=	GdFieldPos("P0_TIPOARQ"	,aHeader)
nPosDesc 	:=	GdFieldPos("P0_DESC"	,aHeader)
nPosRelogio :=	GdFieldPos("P0_RELOGIO"	,aHeader)
nPosControle:=	GdFieldPos("P0_CONTROL",aHeader)

////-- Corre Todos os Relogios
For nLoop:=1 To nTot
  cFilRel	:= aCols[nLoop, nPosFilial]
  cDesc		:= aCols[nLoop, nPosDesc]
  cRelogio	:= aCols[nLoop, nPosRelogio]
  cControle	:= aCols[nLoop, nPosControle]
  cFile		:= GetDir(aCols[nLoop, nPosArq])
  cTipo		:= aCols[nLoop, nPosTipo]
  aFiles	:= Directory(cFile+'\'+If(cTipo == 'T', '*.TXT', '*.DBF'),"D")

  Aeval(aFiles,{|x|AADD(aSelArq, {cFilRel,cRelogio,cTipo,cControle, cDesc,cFile+x[1], (UPPER(ALLTRIM(cFile+x[1])) == UPPER(ALLTRIM(aCols[nLoop, nPosArq]))) })})

Next nLoop

Return (Aclone(aSelArq))


/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³GetDir			 ³ Autor ³Mauricio MR	   ³ Data ³07/03/2005³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Obtem o Diretorio a partir do nome de Arquivo do Cad. Relogio³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL                                                  	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Uso      ³PONM010                                                      ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/

Static Function  GetDir(cCols)
Local cDrive
Local cDir

SplitPath(cCols, @cDrive, @cDir)
cDir := Alltrim(cDrive) + Alltrim(cDir)
cDir := StrTran(cDir, "/", "\" )
Return cDir


/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³GetRelogios		 ³ Autor ³Mauricio MR	   ³ Data ³07/03/2005³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Obtem os registros de relogios a partir do Cad. Relogio      ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL                                                  	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Uso      ³PONM010                                                      ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/

Static function GetRelogios(aHeader, cFilSP0, cFilAte, cRelDe, cRelAte, nAponta)

Local bSkip
Local cKey		:= cFilSP0
Local uQueryCond
Local aRecnos
Local aNotFields := {'P0_FILIAL', 'P0_RELOGIO', 'P0_ARQUIVO','P0_DESC','P0_TIPOARQ','P0_CONTROL'}
/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Le Somente os Relogios conforme Parametros Informados        ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/

bSkip:= {|| SP0->(	( P0_FILIAL  < cFilSP0 ) .or. ( P0_FILIAL  > cFilAte ) .or. ;
			    		( P0_RELOGIO < cRelDe  ) .or. ( P0_RELOGIO > cRelAte ) ) .OR.;
			    	 !VerControle(nAponta);
		 }



uQueryCond:=  Array( 09 )
uQueryCond[01]	:= "P0_FILIAL >='"+cFilSP0+"'"
uQueryCond[02]	:= " AND "
uQueryCond[03]	:= "P0_FILIAL <='"+cFilAte+"'"
uQueryCond[04]	:= " AND "
uQueryCond[05]	:= "P0_RELOGIO >='"+cRelDe+"'"
uQueryCond[06]	:= " AND "
uQueryCond[07]	:= "P0_RELOGIO <='"+cRelAte+"'"
uQueryCond[08]	:= " AND "
uQueryCond[09]	:= "D_E_L_E_T_=' ' "

aCols:=	GdMontaCols(	@aHeader		,;	//01 -> Array com os Campos do Cabecalho da GetDados
						    			,;	//02 -> Numero de Campos em Uso
						           		,;	//03 -> [@]Array com os Campos Virtuais
						       			,;	//04 -> [@]Array com os Campos Visuais
						'SP0'			,;	//05 -> Opcional, Alias do Arquivo Carga dos Itens do aCols
						aNotFields		,;	//06 -> Opcional, Campos que nao Deverao constar no aHeader
						@aRecnos		,;	//07 -> [@]Array unidimensional contendo os Recnos
						'SP0'		   	,;	//08 -> Alias do Arquivo Pai
						cKey			,;	//09 -> Chave para o Posicionamento no Alias Filho
						NIL				,;	//10 -> Bloco para condicao de Loop While
						bSkip			,;	//11 -> Bloco para Skip no Loop While
						.T.          	,;	//12 -> Se Havera o Elemento de Delecao no aCols
						.T.     		,;	//13 -> Se cria variaveis Publicas
						.T.             ,;	//14 -> Se Sera considerado o Inicializador Padrao
						.T.    	        ,;	//15 -> Lado para o inicializador padrao
						          		,;	//16 -> Opcional, Carregar Todos os Campos
						            	,;	//17 -> Opcional, Nao Carregar os Campos Virtuais
						uQueryCond		,;	//18 -> Opcional, Utilizacao de Query para Selecao de Dados
						.T.         	,;	//19 -> Opcional, Se deve Executar bKey  ( Apenas Quando TOP )
						.T.         	,;	//20 -> Opcional, Se deve Executar bSkip ( Apenas Quando TOP )
						.F.         	,;	//21 -> Carregar Coluna Fantasma e/ou BitMap ( Logico ou Array )
						.T.           	,;	//22 -> Inverte a Condicao de aNotFields carregando apenas os campos ai definidos
						.F.          	,;	//23 -> Verifica se Deve Checar se o campo eh usado
						.T.     		,;	//24 -> Verifica se Deve Checar o nivel do usuario
						.F.         	,;	//25 -> Verifica se Deve Carregar o Elemento Vazio no aCols
						            	,;	//26 -> [@]Array que contera as chaves conforme recnos
						.F.				,;	//27 -> [@]Se devera efetuar o Lock dos Registros
						.F.				,;	//28 -> [@]Se devera obter a Exclusividade nas chaves dos registros
						         		,;	//29 -> Numero maximo de Locks a ser efetuado
						.F.         	,;	//30 -> Utiliza Numeracao na GhostCol
						.T.      		 ;	//31 -> Carrega os Campos de Usuario
					)
Return (aClone(aCols))

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³VerControle		 ³ Autor ³Mauricio MR	   ³ Data ³13/05/2005³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Consiste o controle do relogio e a opcao de processo esco-   ³
³          ³lhido.                                                       ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL                                                  	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Uso      ³PONM010                                                      ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/

Static Function VerControle(nAponta)
Local lRet	:= .T.

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Verifica o Tipo de Leitura a Ser Feita                       ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
IF !( nAponta == 5 )
   	IF SP0->(;
  				( ( nAponta == 1 ) .and. ( P0_CONTROL $ "R.A" ) );
   				.or.;
   				( ( nAponta == 2 ) .and. ( P0_CONTROL $ "P.A" ) );
   				.or.;
	   			( ( nAponta == 3 ) .and. ( P0_CONTROL $ "R.P" ) );
	  			.or.;
	   			( ( nAponta == 4 ) .and. ( P0_CONTROL $ "A"   ) );
	   		)
	   		lRet:= .F.
	  EndIF
Endif

Return lRet

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³Pnm010Proc 		 ³ Autor ³Equipe RH        ³ Data ³          ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³                                                             ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³                             								 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³                         									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL                                                  	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Uso      ³PONM010                                                      ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function Pnm010Proc()
Local lRet:= .T.

If mv_par20 == 1 .and. mv_par18= 3
	Aviso( STR0120, STR0121, {"Ok"} ) //"Atencao"###' Para o Controle de Acesso, a Leitura deve ser feita a apartir do Cad.Relógios.'
ENDIF

If Empty(xFilial("SP0"))
	If mv_par20 == 2 .and. !Empty(mv_par01)
		Help("",1,"PONM010VALPAR")
		lRet := .F.
	EndIf
EndIf

Return(lRet)

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³fHistRFE 		 ³ Autor ³Leandro Drumond  ³ Data ³15/10/2009³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Exibe o historico de leitura.                                ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³                             								 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³                         									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL                                                  	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Uso      ³PONM010                                                      ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function fHistRFE(oCenterPanel)
Local aArea				:= GetArea()
Local nRecno			:= 0
Local aAdvSize		:= {}
Local aObjCoords	:= {}
Local aInfoAdvSize	:= {}
Local nWidth		:= 0
Local nHeight		:= 0

Default oCenterPanel	:= Nil

aAdvSize        := MsAdvSize()
aAdd( aObjCoords , {000 , 000 , .T. , .T.})
aInfoAdvSize    := {aAdvSize[1], aAdvSize[2], aAdvSize[3], aAdvSize[4], 0, 0}
aObjSize    	:= MsObjSize(aInfoAdvSize, aObjCoords) 

nHeight			:= aObjSize[1,3]
nWidth			:= aObjSize[1,4]

If oCenterPanel <> Nil
	Begin Sequence
		DbSelectArea('RFB')
		nRecno := ('RFB')->(LastRec())

		If (( nRecno - 100) > 0)
			DbGoTo(nRecno-100)
		EndIf

		oBrowse := BrGetDDB():New(1, 1, nWidth, nHeight,,,,oCenterPanel,,,,,,,,,,,,.F.,'RFB',.T.,,.F.,,, )
		oBrowse:bCustomEditCol	:= {||.T.}
		oBrowse:bDelOk			:= {||.T.}
		oBrowse:AddColumn(TCColumn():New(PosAlias( "SX3" , "RFB_FILIAL" , "" , "X3Titulo()" , 2 , .F. ),{||RFB->RFB_FILIAL },,,,'LEFT',,.F.,.F.,,,,.F.,))
		oBrowse:AddColumn(TCColumn():New(PosAlias( "SX3" , "RFB_RELOGI" , "" , "X3Titulo()" , 2 , .F. ),{||RFB->RFB_RELOGI },,,,'LEFT',,.F.,.F.,,,,.F.,))
		oBrowse:AddColumn(TCColumn():New(PosAlias( "SX3" , "RFB_NUMREP" , "" , "X3Titulo()" , 2 , .F. ),{||RFB->RFB_NUMREP },,,,'LEFT',,.F.,.F.,,,,.F.,))
		oBrowse:AddColumn(TCColumn():New(PosAlias( "SX3" , "RFB_ARQ"    , "" , "X3Titulo()" , 2 , .F. ),{||RFB->RFB_ARQ    },,,,'LEFT',,.F.,.F.,,,,.F.,))
		oBrowse:AddColumn(TCColumn():New(PosAlias( "SX3" , "RFB_DTHRLI" , "" , "X3Titulo()" , 2 , .F. ),{||RFB->RFB_DTHRLI },,,,'LEFT',,.F.,.F.,,,,.F.,))
		oBrowse:AddColumn(TCColumn():New(PosAlias( "SX3" , "RFB_DTHRLF" , "" , "X3Titulo()" , 2 , .F. ),{||RFB->RFB_DTHRLF },,,,'LEFT',,.F.,.F.,,,,.F.,))
		oBrowse:GoUp()
		oBrowse:Refresh()
	End Sequence
EndIf

RestArea(aArea)
Return

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o	 ³fVerMultVinc  ³ Autor ³ Allyson M.        ³ Data ³ 06/08/10 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Verificar se ha multiplos vinculos conforme PIS.			  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³            												  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso		 ³ PONM010  												  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Static Function fVerMultVinc(cPIS, cFilRFE, cCPF)
	
	Local aArea	   		:= GetArea()
	Local aFuncs   		:= {}
	Local cAliasQry		:= ""
	Local nCont	   		:= 0
	Local cWhere		:= ""
	Local lMemoCalc		:= GetlMemoCalc()
	Local cMemoTexto	:= ""
	Local nTabs			:= 0
	
	DEFAULT cPIS		:= ""
	DEFAULT cCPF		:= ""
	
	lMultVinc := .F.
	
	If !Empty(cPIS) .Or. !Empty(cCPF)
		
		cPIS := Padr(cPIS, 12)
		
		If !Empty(cPis)
			cWhere := "AND RA_PIS = '" + AllTrim(cPIS) + "' "
		ElseIf !Empty(cCPF)
			cWhere := "AND RA_CIC = '" + AllTrim(cCPF) + "' "
		EndIf
		
		cWhere := "%" + cWhere + "%"
		
		cAliasQry	:= GetNextAlias()
		
		BeginSql alias cAliasQry
			SELECT
			  SRA.RA_FILIAL,
			  SRA.RA_PIS,
			  SRA.RA_MAT,
			  SRA.RA_NOME,
			  SRA.RA_CC,
			  SRA.RA_TNOTRAB,
			  SRA.RA_REGRA,
			  SRA.RA_SITFOLH,
			  SRA.RA_DEMISSA,
			  SRA.RA_CATFUNC,
			  R_E_C_N_O_ RECNO
			FROM %table:SRA% SRA
			WHERE SRA.%notDel% 
			%Exp:cWhere%
			ORDER BY RA_RESCRAI
		EndSql
		
		If lMemoCalc
			cMemoTexto := GetlastQuery()[2]
			nTabs := 6
			GravaMCalc("01", 5, STR0221) // "Busca pelo Funcionário:"
			While Len(cMemoTexto) > 0
				GravaMCalc("01", nTabs, Left(cMemoTexto, 254), .F.)
				cMemoTexto := SubStr(cMemoTexto, 255)
				nTabs := 0
			EndDo
			//Quebra de linha
			GravaMCalc("01", 0, "")
		EndIf
		
		While (cAliasQry)->( !Eof() )
			nCont++//contador do numero de funcionarios com mesmo PIS ou CPF 
			//Se a data da marcação não for maior do que a data de demissão
			If (cAliasQry)->(Eval(bSraScope)) .And. !(cAliasQry)->( RA_SITFOLH == "D" .And. !Empty(RA_DEMISSA) .And. Dtos(dData) > RA_DEMISSA ) .And. ( Empty(cFilRFE) .Or. AllTrim(cFilRFE) $ RA_FILIAL )
				(cAliasQry)->(aAdd( aFuncs, {RA_FILIAL, RA_MAT, RA_CC, RA_TNOTRAB, RA_CATFUNC, RA_DEMISSA, RECNO}))
			EndIf
			
			(cAliasQry)->( dbSkip() )
		EndDo
		
		( cAliasQry )->( dbCloseArea() )
		
		If nCont > 1
			lMultVinc := .T.
		EndIf
		
		If lMemoCalc
			GravaMCalc("01", 5, STR0226 + If(lMultVinc, STR0227, STR0228)) // "Múltiplos Vínculos: " - "SIM" - "NÃO"
			If lMultVinc
				cMemoTexto := ""
				aEval(aFuncs, {|x| cMemoTexto += x[1] + " - " + x[2] + " | " })
				GravaMCalc("01", 5, STR0229 + cMemoTexto) // "Vínculos: "
			EndIf
		EndIf
		
		RestArea( aArea )
	EndIf
	
Return( aFuncs )

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o	 ³fDelRFE       ³ Autor ³ Leandro Dr.       ³ Data ³ 13/04/12 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Apagar registros nao classificados da RFE.      			  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³            												  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso		 ³ PONM010  												  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±/*/
Static Function fDelRFE(cFilRFE, cRelRFE)

Local aArea 		:= GetArea()
Local cQuery		:= ""

cQuery := "DELETE FROM " + InitSqlName("RFE") + " WHERE RFE_FILIAL = '" + cFilRFE + "' AND RFE_RELSP0 ='" + cRelRFE + "' AND RFE_NATU = '3' AND RFE_FLAG = '0' "

TcSqlExec( cQuery )

TcRefresh( InitSqlName("RFE") )

RestArea(aArea)

Return Nil

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o	 ³Pnm010MntThread³ Autor ³ Leandro Dr.      ³ Data ³ 01/05/12 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Monta o array para utilizar multi-thread.      			  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³            												  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso		 ³ PONM010  												  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±/*/
Static Function Pnm010MntThread(aRegSRA)
Local aThreads	 := {}
Local nQtdRec	 := Len(aRegSRA)
Local nRegProc   := 0
Local nInicio	 := 1
Local nX		 := 0
Local nY		 := 0

If nMultThread > 20
	nMultThread := 20  //Limita threads a 20
EndIf

If nQtdRec > nMultThread
	aThreads := Array(nMultThread)

	For nX := 1 to nMultThread
		// Quantidade de registros a processar
		nRegProc += IIf( nX == nMultThread , nQtdRec - nRegProc, Int(nQtdRec/nMultThread) )
		aThreads[nX] := {}

        For nY := nInicio to nRegProc
			aAdd(aThreads[nX],aRegSRA[nY])
        	nInicio := nRegProc
        Next nY
        nInicio++
	Next nX
ElseIf nQtdRec > 0
	aAdd(aThreads, aRegSRA)
EndIf

Return aThreads

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o	 ³Pnm010MultProc ³ Autor ³ Leandro Dr.      ³ Data ³ 01/05/12 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Processa multi threads.                        			  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³            												  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso		 ³ PONM010  												  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±/*/
Static Function Pnm010MultProc(aRegSRA, cFilFECAux, lPonWork, lSchedDef, lUserDefParam, oProcess)
Local aJobAux		:= {}
Local aMarcNo		:= {}
Local cJobFile		:= ''
Local cJobAux		:= ''
Local cStartPath 	:= GetSrvProfString("Startpath","")
Local cLogError		:= ''
Local nLoop 		:= 0
Local nLoops		:= 0
Local nLoopAux 		:= 0
Local nMarcs		:= 0
Local nRetry_0 		:= 0
Local nRetry_1 		:= 0
Local nPos			:= 0
Local nX			:= 0
Local nTotRegs		:= 0
Local nTotThread	:= 0
Local nRegsOk		:= 0
Local nQtdSRA		:= Len(aRegSRA)
Local cTabTmpName   := ''
Local lFechOk		:= .T.
Local cUserBkp		:= ""

Default oProcess	:= Nil

aRegSRA := Pnm010MntThread(aRegSRA)

nLoops := Len(aRegSRA)

nTotRegs 	:= nQtdSRA / nLoops
nTotThread  := nTotRegs

If nLoops > 0
	
	If oProcess <> Nil
		// Define a quantidade de registros para a regua de processamento secundária
		oProcess:SetRegua2(nLoops)
	EndIf
	
	PutGlbValue("nFunProc","0")
	PutGlbValue("__cUserPon", __cUserId)
	GlbUnLock()
	
	For nLoop:=1 to nLoops
		
		If oProcess <> Nil
			// Incrementa a regua de processamento secundária
			oProcess:IncRegua2(STR0246 + If(!Empty(aRegSRA[nLoop]), aRegSRA[nLoop,1,1], "")) // "Processando funcionários da filial: "
		EndIf
		
	    cTabTmpName := "J" + Alltrim(STR(nLoop)) + dtos(dDataBase) + StrTran(Time(),':','',1,4)
		// Informacoes do semaforo
		cJobFile:= cStartPath +  cTabTmpName +".job"

		// Adiciona o nome do arquivo de Job no array aJobAux
		aAdd(aJobAux,{StrZero(nLoop,2),cJobFile})

		// Inicializa variavel global de controle de thread
		cJobAux:="PNM010"+cEmpAnt+cFilAnt+StrZero(nLoop,2)
		PutGlbValue(cJobAux,"0")
		GlbUnLock()

		PutGlbValue("nFun"+StrZero(nLoop,2),"0")
		GlbUnLock()

		PutGlbValue('aLog'+StrZero(nLoop,2),"")
		GlbUnLock()

		PutGlbVars('aMarc'+StrZero(nLoop,2),{})
		GlbUnLock()
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Dispara thread    ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		StartJob("Pnm010Thread",GetEnvServer(),.F.,{cEmpAnt,cFilAnt,aRegSRA[nLoop],cJobFile,StrZero(nLoop,2),lWorkFlow,dPerIni,dPerFim,dPerDe,dPerAte,nAponta,nTipo,nReaponta,dDataBase,__cUserId,cUserBkp, lLimitaDataFim, lGeolocal, cFilFECAux, lPonWork, lSchedDef, lUserDefParam})

	Next nLoop

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Controle de Seguranca para MULTI-THREAD                                   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	For nLoop:=1 to nLoops

		nPos := aScan(aJobAux,{|x| x[1] == StrZero(nLoop,2)})

		// Informacoes do semaforo
		cJobFile:= aJobAux[nPos,2]

		// Inicializa variavel global de controle de thread
		cJobAux:="PNM010"+cEmpAnt+cFilAnt+StrZero(nLoop,2)

		While .T.

			If !( lWorkFlow )

				nRegsOk := 0

				For nLoopAux := 1 to nLoops
					nRegsOk += Val(GetGlbValue("nFun"+StrZero(nLoopAux,2)))
				Next nLoopAux

				If nRegsOk >= nTotRegs
					nTotRegs += nTotThread
				EndIf
			EndIf

			Do Case
				// TRATAMENTO PARA ERRO DE SUBIDA DE THREAD
				Case GetGlbValue(cJobAux) == '0'
					If nRetry_0 > 50
						Conout(Replicate("-",65))				  						//"-----------------------------------------------------"
						Conout("PONM010: " + STR0148 + " " + StrZero(nLoop,2) )		//"PONM010: Não foi possivel subir a thread"
						Conout(Replicate("-",65))  										//"-----------------------------------------------------"
						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³ Atualiza o log de processamento			    ³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						Final(STR0148) 	 												//"Não foi possivel subir a thread"
					Else
						nRetry_0 ++
					EndIf
				// TRATAMENTO PARA ERRO DE CONEXAO
				Case GetGlbValue(cJobAux) == '1'
					If FCreate(cJobFile) # -1
						If nRetry_1 > 5
							Conout(Replicate("-",65)) 						//"------------------------------------------------"
							Conout("PONM010: " + STR0149 ) 					//"PONM010: Erro de conexao na thread"
							Conout(STR0150 + StrZero(nLoop,2) )				//"Thread numero : "
							Conout(STR0151)									//"Numero de tentativas excedidas"
							Conout(Replicate("-",65))  						//"------------------------------------------------"
							//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
							//³ Atualiza o log de processamento			    ³
							//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
							Final("PONM010: " + STR0149)   					//"PONM010: Erro de conexao na thread"
						Else
			    			// Inicializa variavel global de controle de Job
							PutGlbValue(cJobAux, "0" )
							GlbUnLock()
							// Reiniciar thread
							Conout(Replicate("-",65))				 				//"------------------------------------------------"
							Conout("PONM010: " + STR0149 ) 							//"PONM010: Erro de conexao na thread"
							Conout(STR0152	+ StrZero(nRetry_1,2))					//"Tentativa numero: "
							Conout(STR0153 + StrZero(nLoop,2))						//"Reiniciando a thread : "
							Conout(Replicate("-",65))                 				//"------------------------------------------------"
							//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
							//³ Dispara thread 						        ³
							//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
							StartJob("Pnm010Thread",GetEnvServer(),.F.,{cEmpAnt,cFilAnt,aRegSRA[nLoop],cJobFile,StrZero(nLoop,2),lWorkFlow,dPerIni,dPerFim,dPerDe,dPerAte,nAponta,nTipo,nReaponta,dDataBase,__cUserId,cUserBkp, lLimitaDataFim, lGeolocal, cFilFECAux, lPonWork},@lFechOk)
						EndIf
						nRetry_1 ++
					EndIf
				// TRATAMENTO PARA ERRO DE APLICACAO
				Case GetGlbValue(cJobAux) == '2'
					If FCreate(cJobFile) # -1
						Conout(Replicate("-",65))									//"-------------------------------------------------"
						Conout("PONM010: " + STR0154  )								//"PONM010: Erro de aplicacao na thread"
						Conout(STR0150 + StrZero(nLoop,2))							//"Thread numero : "
						Conout(Replicate("-",65))  									//"--------------------------------------------------"
						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³ Atualiza o log de processamento			    ³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						Final("PONM010: " + STR0154) 								//"PONM010: Erro de aplicacao na thread"
					EndIf
				// THREAD PROCESSADA CORRETAMENTE
				Case GetGlbValue(cJobAux) == '3'
					Exit
			EndCase
			Sleep(2500)
		End
	Next nLoop

	For nLoop := 1 to nLoops
		cLogError  := GetGlbValue("aLog"+StrZero(nLoop,2))
		GetGlbVars( "aMarc" + StrZero(nLoop, 2), @aMarcNo )
		nX := 1
		If !Empty(cLogError)
			While .T.
				If At("*",cLogError) == 0
					aAdd(aLogFile,cLogError)
					Exit
				Else
					aAdd(aLogFile,SubStr(cLogError,nX,At("*",cLogError)-1))
					cLogError := SubStr(cLogError,At("*",cLogError)+1,Len(cLogError))
				EndIf
			EndDo
		EndIf

		If !Empty(aMarcNo)
			For nMarcs := 1 To Len(aMarcNo)
				aAdd( aMarcNoGer, aClone( aMarcNo[nMarcs] ) )
			Next nMarcs
		EndIf
	Next nLoop
	
	nFuncProc := Val(GetGlbValue("nFunProc"))
	
	For nLoop := 1 to Len(aJobAux)
		cJobFile:= aJobAux[nLoop,2]
		If File(cJobFile)
			fErase(cJobFile) // Apaga arquivo ja existente
		EndIf
	Next nLoop
EndIf

Return Nil

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³Pnm010Thread  ³ Autor ³ Leandro Drumond   ³ Data ³27.04.2012³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Job para execucao das multi-threads.                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ PONM010()                                                  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function Pnm010Thread(aParam,lFechOk)
Local nLoop	  	:= 0
Local nLoops   	:= 0
Local nX		:= 0
Local cEmp		:= aParam[1]
Local cFil		:= aParam[2]
Local aRegSRA	:= aParam[3]
Local cJobFile	:= aParam[4]
Local cThread	:= aParam[5]
Local cLogError := ''
Local bErro		:= Nil

Private aTabCalend		:= {}
Private aTabPadrao		:= {}
Private aLogFile		:= {}
Private aCodigos   		:= {}
Private aMarcNoGer		:= {}
Private aTabRef			:= {}
Private bCondDelAut		:= { || .T. }
Private cFilTnoSeqOld	:= "__cFilTnoSeqOld__"
Private cLastFil		:= "__cLastFil__"
Private cFilOld    		:= "__cFilOld__"
Private cFilRefAnt		:= ""
Private dPerIni			:= aParam[7]
Private dPerFim			:= aParam[8]
Private dPerDe			:= aParam[9]
Private dPerAte			:= aParam[10]
Private nIncPercG1		:= 0
Private nIncPercG2		:= 0
Private nAponta			:= aParam[11]
Private nTipo			:= aParam[12]
Private nReaponta		:= aParam[13]
Private nFuncProc		:= 0
Private lSR6Comp		:= .F.
Private lIncProcG1		:= .T.
Private lMultThread		:= .T.
Private lChkPonMesAnt	:= .F.
Private lAbortPrint		:= .F.
Private lWorkFlow 		:= aParam[6]
Private lLimitaDataFim	:= aParam[17]
Private cFilFECAux	    := aParam[19]
Private lPonWork	    := aParam[20]
Private lSchedDef	    := aParam[21]
Private lUserDefParam	:= aParam[22]

DEFAULT lFechOk	:= .T.

bErro := ErrorBlock( { |oErr| ErroForm( oErr , @lFechOk, @aLogFile, cThread ) } )

// Apaga arquivo ja existente
If File(cJobFile)
	fErase(cJobFile)
EndIf

// Criacao do arquivo de controle de jobs
nHd1 := MSFCreate(cJobFile)

// STATUS 1 - Iniciando execucao do Job
PutGlbValue("PNM010"+cEmp+cFil+cThread, "1" )
GlbUnLock()

// Seta job para nao consumir licensas
RpcSetType(3)

// Seta job para empresa filial desejada
RpcSetEnv( cEmp, cFil,,, 'PON', "PONM010")

IF Empty(cFilAnt)
	cFilAnt:= cFil
Endif

//Iguala database com thread principal
dDataBase := aParam[14]

Conout(DtoC(Date())+ " " + Time() + " PONM010: " + STR0155 + cThread + STR0156 )

lSR6Comp := Empty( xFilial( "SR6" ) )

// STATUS 2 - Conexao efetuada com sucesso
PutGlbValue("PNM010"+cEmp+cFil+cThread, "2" )
GlbUnLock()

DbSelectArea('SRA')

nLoops  := Len(aRegSRA)

Begin Sequence

	For nLoop := 1 to nLoops

		If SRA->( dbSeek( aRegSRA[nLoop][1]+aRegSRA[nLoop][2] ) )
			
			If !(SRA->RA_FILIAL $ cFilFECAux)
				Begin Transaction
					lFechOk := Ponm010Aponta( .F. )
					
					If(!lFechOk, DisarmTransaction(), NIL)
				End Transaction
			EndIf
			
		EndIf
		
		PutGlbValue("nFun"+cThread,AllTrim(STR(nLoop)))
		GlbUnLock()
		
	Next nLoop
	
End Sequence

ErrorBlock( bErro )

If !Empty(aLogFile)
	For nX := 1 to Len(aLogFile)
		If nX == 1
			cLogError += aLogFile[nX]
		Else
			cLogError += "*" + aLogFile[nX]
		EndIf
		PutGlbValue("aLog"+cThread,cLogError)
		GlbUnLock()
	Next nX
EndIf

If !Empty(aMarcNoGer)
	For nX := 1 to Len(aMarcNoGer)
		PutGlbVars( "aMarc" + cThread, { aClone( aMarcNoGer[nX] ) } )
		GlbUnLock()
	Next nX
Else
	PutGlbVars( "aMarc" + cThread, {} )
EndIf

Conout(DtoC(Date())+ " " + Time() + " PONM010: " + STR0155 + cThread + STR0157)

// STATUS 3 - Processamento efetuado com sucesso
PutGlbValue("PNM010"+cEmp+cFil+cThread,"3")
GlbUnLock()

//Incrementa contador de funcionarios processados
nFuncProc += Val(GetGlbValue("nFunProc"))
PutGlbValue("nFunProc", STR(nFuncProc) )
GlbUnLock()

Return

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³Pn010AutoRead ³ Autor ³ IP Rh Inovacao    ³ Data ³09.01.2013³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Retorna o conteudo do array da rotina automatica.          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpA1 - array aAutoItens com os itens a serem incluidos	  ³±±
±±³          ³ ExpC1 - Nome do campo a ser pesquisado    				  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ PONM010()                                                  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function Pn010AutoRead( aArray , cCampo )
Local nPos 		:= 0
Local cConteudo := ""

If Len(aArray) > 0
	If ( nPos := aScan ( aArray , {|x| UPPER(AllTrim(x[1])) == UPPER(AllTrim(cCampo)) }) ) > 0
		cConteudo := aArray [ nPos ,2 ]
	Endif
Endif

Return cConteudo

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³IntegDef	    ³ Autor ³ 				    ³ Data ³22.03.2013³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Chama a função PONN010 para fazer integração				  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ PONM010()                                                  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function IntegDef( cXML, nTypeTrans, cTypeMessage, cVersaoMU )

Local aRet := {}

aRet:= PONN010( cXml, nTypeTrans, cTypeMessage, cVersaoMU )

Return aRet



/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao   ³SchedDef	    						    ³ Data ³19/02/2018³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descricao ³ Chama a função PONN010 pelo Scheduler					  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ PONM010()                                                  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function SchedDef()

Local aParam := {}
Local aOrd	 := {}

aParam := { "P" 		,;
			"PNM010" 	,;
			""			,;
			aOrd		,;
}

Return aParam

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³ErroForm 		³Autor³Leandro Drumond     ³ Data ³27/07/2015³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Verifica os Erros na Execucao da Formula                     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL                                                  	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico                                                     ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function ErroForm(	oErr			,;	//01 -> Objeto oErr
							lNotErro		,;	//02 -> Se Ocorreu Erro ( Retorno Por Referencia )
							aLog			,;
							cNumJob			;
						)

Local aErrorStack
Local cMsgHelp	:= ""

DEFAULT lNotErro	:= .T.

IF !( lNotErro := !( oErr:GenCode > 0 ) )
	cMsgHelp += "Error Description: "
	cMsgHelp += oErr:Description
	aAdd( aLog, cMsgHelp )
	aErrorStack	:= Str2Arr( oErr:ErrorStack , Chr( 10 ) )
	aEval( aErrorStack , { |X| aAdd(aLog, X) } )

	PutGlbValue("nTemErro"+cNumJob,"1")
	GlbUnLock()
EndIF

Break

Return( NIL )

/*/{Protheus.doc} fApontAnt
Verifica se realiza o apontamento do período anterior caso exista algum registro apontado para esse período
@author Allyson Mesashi
@since 26/01/2021
@version P12.1.27
/*/
Static Function fApontAnt( dPerIni, dPerFim )

Local aArea		:= GetArea()
Local cAliasQry	:= ""
Local cFilSP8	:= "%'"+SRA->RA_FILIAL+"'%"
Local cPerApo	:= "%'"+dToS(dPerIni)+dToS(dPerFim)+"'%"
Local lApont 	:= .F.
Local nPos		:= 0

If (nPos := aScan( _aAuxPerApo, { |x| x[1] == SRA->RA_FILIAL } )) == 0
	cAliasQry	:= GetNextAlias()
	
	BeginSql alias cAliasQry
		SELECT COUNT(*) AS CONT
		FROM %table:SP8% SP8
		WHERE SP8.P8_FILIAL = %exp:cFilSP8% AND 
		SP8.P8_PAPONTA = %exp:cPerApo% AND 
		SP8.%notDel%
	EndSql
	
	If (cAliasQry)->( !EoF() )
		lApont := (cAliasQry)->CONT > 0
	EndIf
	
	(cAliasQry)->( dbCloseArea() )
	
	If !lApont // Se não encontrou registros apontados na SP8 verifica se o período está fechado
		dbSelectArea("SPO")
		dbSetOrder(2)
		If !SPO->(dbSeek(xFilial("SPO", SRA->RA_FILIAL) + dToS(dPerIni)))
			lApont := .T.
		EndIf
	EndIf 
	
	aAdd( _aAuxPerApo, { SRA->RA_FILIAL, lApont })
	
Else
	lApont := _aAuxPerApo[nPos, 2]
EndIf

RestArea(aArea)

Return lApont

/*/{Protheus.doc} fGetSPO
Retorna o ultimo período fechado
@type  Static Function
@author Marco Nakazawa
@since 28/12/2023
/*/
Static Function fGetSPO(cFilFunc)
	Local aRet		:= {}
	Local cAlias	:= GetNextAlias()
	
	Default cFilFunc := ""

	If (!Empty(cFilFunc), cFilFunc := xFilial("SPO",cFilFunc),Nil)
	
	BeginSql Alias cAlias
		SELECT 
		  PO_FILIAL,
		  PO_DATAINI,
		  PO_DATAFIM
		FROM %table:SPO% SPO
		WHERE SPO.PO_RESPONS = 'S'
		  AND SPO.PO_FILIAL = %exp:cFilFunc%
		  AND SPO.%notDel%
		ORDER BY PO_DATAFIM DESC
	EndSql
	
	While (cAlias)->(!EoF())
		aAdd(aRet, {(cAlias)->PO_FILIAL, (cAlias)->PO_DATAINI, (cAlias)->PO_DATAFIM})
		Exit
	EndDo

	(cAlias)->(DbCloseArea())

Return aRet

/*/{Protheus.doc} fValdMultV
Verifica se o funcionário possui multiplos vinculos
@type  Static Function
@author Marco Nakazawa
@since 05/03/2024
/*/
Static Function fValdMultV(cPISFunc, cCPFFunc, cFilRFE, cCategoria, dData, nHora)
Local aRet			:= {}
Local aFuncs		:= {}
Local aTabPadrao	:= {}
Local nPosMultV		:= 0
Local nDifHr		:= 0
Local nDifHrAnt		:= 0
Local nRecno		:= 0
Local nCount		:= 0
Local nLenaFuncs	:= 0
Local nSerMar		:= 0
Local nSerMIni		:= 0
Local nSerMFim		:= 0
Local nHorFim		:= 0
Local nPosDia		:= 0
Local nPosDiaFim	:= 0
Local cFilFunc		:= ""
Local cMatFunc		:= ""
Local cFilFunAnt	:= ""
Local cMatFunAnt	:= ""
Local lCompara		:= .F.

Default cPISFunc	:= ""
Default cCPFFunc	:= ""
Default cFilRFE		:= ""
Default cCategoria	:= ""
Default nHora		:= 0
Default dData		:= cToD(" / / ")

If (!Empty(cPISFunc) .Or. !Empty(cCPFFunc)) .And. !Empty(dData)
	aFuncs 		:= fVerMultVinc(cPISFunc, cFilRFE, cCPFFunc)
	nLenaFuncs 	:= Len(aFuncs)
	
	If !Empty(aFuncs) .And. nLenaFuncs > 1
		nPosMultV	:= 0
		nDifHr		:= 0
		nDifHrAnt	:= 0
		cFilFunAnt	:= ""
		cMatFunAnt	:= ""
		
		For nCount := 1 To nLenaFuncs
			If !(aFuncs[nCount,05] $ cCategoria)
				loop
			EndIf
			
			If !(cFilFunAnt == aFuncs[nCount,1] .And. cMatFunAnt == aFuncs[nCount,2])
				aTabCalend 	:= {}
				aTabPadrao 	:= {}
				nHorFim		:= 0
				nSerMIni	:= 0
				nSerMFim	:= 0
				nSerMar 	:= 0
				nPosDiaFim	:= 0
				
				CriaCalend(	mv_par13		,;	//01 -> Data Inicial do Periodo
						mv_par14			,;	//02 -> Data Final do Periodo
						aFuncs[nCount, 04]	,;	//03 -> Turno Para a Montagem do Calendario
						'01'				,;	//04 -> Sequencia Inicial para a Montagem Calendario
						@aTabPadrao			,;	//05 -> Array Tabela de Horario Padrao
						@aTabCalend			,;	//06 -> Array com o Calendario de Marcacoes
						aFuncs[nCount, 01]	,;	//07 -> Filial para a Montagem da Tabela de Horario
						aFuncs[nCount, 02]	,;	//08 -> Matricula para a Montagem da Tabela de Horario
						aFuncs[nCount, 03]	,;	//09 -> Centro de Custo para a Montagem da Tabela
						NIL     			,;	//10 -> Array com as Trocas de Turno
						NIL					,;	//11 -> Array com Todas as Excecoes do Periodo
						NIL					,;	//12 -> Se executa Query para a Montagem da Tabela Padrao
						.T.					,;	//13 -> Se executa a funcao se sincronismo do calendario
						.T.			 		,;	//14 -> Se Forca a Criacao de Novo Calendario
						Nil					,;	//15 -> Array com marcacoes para tratamento de Turnos Opcionais
						Nil					,;	//16 -> Se considera as exceções cadastradas
						Nil					,;	//17 -> Chamada do GPEXPER
						.F.					 ;	//18 -> Considera a SRA posicionada para a montagem do calendário
					)
			EndIf
			
			//Procura o horario na tabela padrao de acordo com o dia da semana
			IF !Empty(aTabPadrao) .And. (nPosDia := aScan( aTabPadrao[1][3] , { |x| x[20] == Dow(dData)})) > 0
				//Gera o serial do horario inicial do dia
				nSerMIni  := __fDHtoNS(dData, SubHoras(aTabPadrao[1][3][nPosDia][1], aTabPadrao[1][3][nPosDia][30]))
				
				//Verifica e gera o serial do horario final do dia
				If !Empty(aTabPadrao[1][3][nPosDia][8])
					nHorFim := aTabPadrao[1][3][nPosDia][8]
				ElseIf !Empty(aTabPadrao[1][3][nPosDia][6])
					nHorFim := aTabPadrao[1][3][nPosDia][6]
				ElseIf !Empty(aTabPadrao[1][3][nPosDia][4])
					nHorFim := aTabPadrao[1][3][nPosDia][4]
				Else
					nHorFim := aTabPadrao[1][3][nPosDia][2]
				EndIf
				
				nSerMFim 	:= __fDHtoNS(dData, SomaHoras(nHorFim, aTabPadrao[1][3][nPosDia][31]))
				//Gera o serial do horario da marcacao
				nSerMar		:= __fDHtoNS(dData, nHora)
				
				If (nSerMar >= nSerMIni .And. nSerMar <= nSerMFim)
					// Se a marcação está dentro do limite inferior e superior verifica qual marcação da tabela de horário padrão mais se aproxima
					nSerMIni	:= __fDHtoNS(dData, aTabPadrao[1][3][nPosDia][1])
					nSerMFim 	:= __fDHtoNS(dData, nHorFim)
					
					nDifHr	:= Min(Abs(nSerMIni - nSerMar), Abs(nSerMFim - nSerMar))
					
					If !lCompara
						nDifHrAnt	:= nDifHr
						nPosMultV	:= nCount
						lCompara 	:= .T.
					Else
						If nDifHr < nDifHrAnt .Or. (!Empty(aFuncs[nCount,6]) .And. DtoS(dData) < aFuncs[nCount,6])
							nPosMultV	:= nCount
							nDifHrAnt	:= nDifHr
						EndIf
					EndIf
				EndIf
			EndIF
			
			cFilFunAnt := aFuncs[nCount,1]
			cMatFunAnt := aFuncs[nCount,2]
		Next
		
		If nLenaFuncs > 0 .And. nPosMultV > 0
			cFilFunc 	:= aFuncs[nPosMultV, 1]
			cMatFunc	:= aFuncs[nPosMultV, 2]
			nRecno		:= aFuncs[nPosMultV, 7]
		EndIf
		
		If !Empty(cFilFunc) .And. !Empty(cMatFunc) .And. !Empty(nRecno)
			aAdd(aRet,{cFilFunc,cMatFunc,nRecno})
		EndIf
	ElseIf nLenaFuncs == 1
		aAdd(aRet,{aFuncs[nLenaFuncs, 1], aFuncs[nLenaFuncs, 2], aFuncs[nLenaFuncs, 7]})
	EndIf
EndIf

Return aRet

//-------------------------------------------------------------------
/*{Protheus.doc} fTmpSRA
Cria a tabela temporária dos R_E_C_N_O_ da SRA que precisam ter suas marcação classificadas
@author  Marco Nakazawa
@since   26/04/2024
*/
//-------------------------------------------------------------------
Static Function fTmpSRA(aRecnos, oTmpSRARec)
	Local cTmpAlias	:= GetNextAlias()
	Local aFields	:= {}
	Local nI		:= 0
	Local cTCAlias	:= ""
	Local lRet		:= .F.

	Default aRecnos		:= {}
	Default oTmpSRARec	:= Nil

	If !Empty(aRecnos)
		aAdd(aFields, {"RECSRA",  "N", 15, 0})

		oTmpSRARec := FWTemporaryTable():New(cTmpAlias)
		oTmpSRARec:SetFields( aFields )
		oTmpSRARec:AddIndex("1",{"RECSRA"})
		oTmpSRARec:Create()

		cTCAlias := oTmpSRARec:GetTableNameForTCFunctions()

		oBulk := FwBulk():New(cTCAlias)

		oBulk:SetFields(aFields)

		For nI := 1 To Len(aRecnos)
			oBulk:AddData({aRecnos[nI,1]})
		Next

		oBulk:Close()
		oBulk:Destroy()
		oBulk := Nil
		
		If (Empty(AllTrim(oTmpSRARec:GetRealName())), lTemTmpSRA := lRet := .F., lRet := lTemTmpSRA := .T.)
	EndIf
Return lRet

/*/{Protheus.doc} fMcalcPar
Gera na memória de cálculo a descrição e o conteúdo dos parâmetros utilizados pela rotina
@type function
@author Cícero Alves
@since 23/08/2024
@param cTipo, character, Tipo do LOG ("01" = Leitura; "02" = Apontamento)
@return NIL, NIL
/*/
Static Function fMcalcPar(cTipo)
	
	Local aParametros 	:= {}
	Local aPClcokIn 	:= {"MV_APICLO0", "MV_APICLO3", "MV_GEOFENC", "MV_APICLOD"}
	Local aPSuricato 	:= {"MV_TSREP", "MV_APISUR", "MV_TPLMARC"}
	
	If cTipo == "01"
		// Leitura
		aParametros := {"MV_PAPONTA", "MV_PONMES", "MV_FILTREL", "MV_GETDIAA", "MV_GETDIAP", "MV_PM010LA", "MV_POARQ", "MV_MARCFER", "MV_GETMAUT", "MV_DESPMIN", "MV_PONDIV", "MV_TECXRH"}	
	Else
		// Apontamento
		aParametros := {"MV_PAPONTA", "MV_PONMES", "MV_GETDIAA", "MV_GETDIAP", "MV_PM010LA", "MV_MARCFER", "MV_TECXRH", "MV_PONMULT", "MV_APDSRCC", "MV_ADNOTHR", "MV_MCIMPAR", "MV_ACMHEXT",;
						"MV_APHEDTM", "MV_JTHEDTM", "MV_MCIGUAL", "MV_HRINTER", "MV_ARRINTE", "MV_ARRSEXP", "MV_DSRHORI", "MV_DSRTAB", "MV_APONTAF", "MV_APOHRAF", "MV_HRTBBCO"}
	EndIf
	
	GravaMCalc(cTipo, 0, "-" + STR0230) // "Parâmetros"
	aEval(aParametros, {|x| GravaMCalc(cTipo, 1, GetTxtParam(x))})
	
	If cTipo == "01"
		GravaMCalc("01", 1, "Clock in")
		aEval(aPClcokIn, {|x| GravaMCalc("01", 2, GetTxtParam(x))})
		
		GravaMCalc("01", 1, "Suricato")
		aEval(aPSuricato, {|x| GravaMCalc("01", 2, GetTxtParam(x))})
	EndIf
	
Return

/*/{Protheus.doc} fMcalcFon
Gera na memória de cálculo a data dos fontes utilizados
@type function
@author Cícero Alves
@since 23/08/2024
@param cTipo, character, Tipo do LOG ("01" = Leitura; "02" = Apontamento)
@return NIL, NIL
/*/
Static Function fMcalcFon(cTipo)
	
	Local nI		:= 0
	Local aFontes	:= {"PONM010.PRX", "PONA030.PRX", "PONXFUN.PRX", "PONXFUN1.PRX" }
	Local aInfo		:= {}
	
	If cTipo == "02"
		aAdd(aFontes, "PONXAPO.PRX")
		aAdd(aFontes, "PONCLAPO.PRX")
		aAdd(aFontes, "RHLIBHRS.PRX")
	EndIf
	
	GravaMCalc(cTipo, 0, "-" + STR0231) // "Datas dos Fontes"
	For nI := 1 To Len(aFontes)
		aInfo := GetApoInfo(aFontes[nI])
		GravaMCalc(cTipo, 1, aFontes[nI] +  ": " + DToC(aInfo[4]) + " - " + aInfo[5])
	Next nI
	
Return

/*/{Protheus.doc} fMcalcTab
Gera na memória de cálculo o compartilhamento das tabelas utilizadas pela rotina
@type function
@author Cícero Alves
@since 23/08/2024
@param cTipo, character, Tipo do LOG ("01" = Leitura; "02" = Apontamento)
@return NIL, NIL
/*/
Static Function fMcalcTab(cTipo)
	
	Local nI		:= 0
	Local cCompart	:= ""
	Local aTabelas	:= {}
	
	If cTipo == "01"
		aTabelas := {"SP0", "RFB", "SPE", "RFE", "RR1"}
	Else
		aTabelas := {"SPA", "SPD", "SPJ", "SPO", "SPT", "SP3", "SP4", "SP6", "SP9"}
	EndIf
	
	GravaMCalc(cTipo, 0, "-" + STR0232) // "Compartilhamento das Tabelas"
	For nI := 1 To Len(aTabelas)
		cCompart := FWModeAccess(aTabelas[nI], 1)
		cCompart += FWModeAccess(aTabelas[nI], 2)
		cCompart += FWModeAccess(aTabelas[nI], 3)
		GravaMCalc(cTipo, 1, aTabelas[nI] +  " - " + PosAlias( "SX2", aTabelas[nI], "", "X2Nome()", 1, .F.) + ": " + cCompart)
	Next nI
	
Return
