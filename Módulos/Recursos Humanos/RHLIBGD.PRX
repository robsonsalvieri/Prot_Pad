#INCLUDE "HEADERGD.CH"
#INCLUDE "PROTHEUS.CH"
#INCLUDE "RHLIBGD.CH"

/*
зддддддддддбддддддддддддддбддддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁInRhLibGDExec ЁAutor ЁMarinaldo de Jesus   Ё Data Ё14/05/2003Ё
цддддддддддеддддддддддддддаддддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁExecutar Funcoes Dentro de RHLIBGD                           Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   ЁInRhLibGDExec( cExecIn , aFormParam )						 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁuRet                                                 	     Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁObserva┤└oЁ                                                      	     Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGenerico 													 Ё
юддддддддддаддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды*/
Function InRhLibGDExec( cExecIn , aFormParam )        
Local uRet

DEFAULT cExecIn		:= ""
DEFAULT aFormParam	:= {}

IF !Empty( cExecIn )
	cExecIn	:= BldcExecInFun( cExecIn , aFormParam )
	uRet	:= __ExecMacro( cExecIn )
EndIF

Return( uRet )

/*/
зддддддддддбддддддддддддддбдддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁGdObrigat	  ЁAutorЁMarinaldo de Jesus   Ё Data Ё10/08/2004Ё
цддддддддддеддддддддддддддадддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁRetorna os Campos Obrigatorios para a GetDados              Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁaHeader														Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGenerico  	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function GdObrigat( aHeader , cAlias )

Local aGdObrigat := {}

Local cField
Local nField
Local nFields

DEFAULT cAlias	:= Alias()
IF Empty( aHeader )
	aHeader := GdAllFields( cAlias , @nFields )
Else
	nFields := Len( aHeader )
EndIF	

For nField := 1 To nFields
	cField := aHeader[ nField , __AHEADER_FIELD__ ]
	IF CpoObrigat( cField )
		aAdd( aGdObrigat , cField )
	EndIF
Next nField

Return( aGdObrigat )

/*/
зддддддддддбддддддддддддддбдддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁGdAllFields	  ЁAutorЁMarinaldo de Jesus   Ё Data Ё20/12/2004Ё
цддддддддддеддддддддддддддадддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁMontar Array de Cabecalho da GetDados com Todos os Campos	Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁaHeader														Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGenerico  	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function GdAllFields( cAlias , nUsado , lVirtual )
DEFAULT lVirtual := .F.
Return( GdMontaHeader( @nUsado , NIL , NIL , cAlias , NIL , .T. , !( lVirtual ) , .F. , .F. , .F. , .F. , .F. , .T. ) )

/*/
зддддддддддбддддддддддддддбдддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁGdMontaHeader ЁAutorЁMarinaldo de Jesus   Ё Data Ё17/05/2002Ё
цддддддддддеддддддддддддддадддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁMontar Array de Cabecalho da GetDados                       Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁaHeader														Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGenerico  	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function GdMontaHeader( nUsado			,;	//01 -> Por Referencia contera o numero de campos em Uso
						aVirtual		,;	//02 -> Por Referencia contera os Campos do Cabecalho da GetDados que sao Virtuais
						aVisual			,;	//03 -> Por Referencia contera os Campos do Cabecalho da GetDados que sao Visuais
						cAlias			,;	//04 -> Opcional, Alias do Arquivo Para Montagem do aHeader
						aNotFields		,;	//05 -> Opcional, Campos que nao Deverao constar no aHeader
						lAllFields		,;	//06 -> Opcional, Carregar Todos os Campos
						lNotVirtual 	,;	//07 -> Nao Carrega os Campos Virtuais
						uGhostBmpCol	,;	//08 -> Carregar Coluna Fantasma e/ou BitMap ( Logico ou Array )
						lOnlyNotFields	,;	//09 -> Inverte a Condicao de aNotFields carregando apenas os campos ai definidos
						lChkX3Uso		,;	//10 -> Verifica se Deve Checar se o campo eh usado
						lChkNivel		,;	//11 -> Verifica se Deve Checar o nivel do usuario
						lNumGhostCol	,;	//12 -> Utiliza Numeracao na GhostCol
						lCposUser		,;	//13 -> Carrega os Campos de Usuario
						lX3Tela			,;  //14 -> Verificar o campo X3_TELA para montagem do Header
						aCpoCar			 ;	//15 -> Campos que sempre serЦo carregados no header, mesmo quando nЦo usados
					   )

Local aAreaSX3			:= SX3->( GetArea() )
Local aHeader			:= {}
Local bNotFields		:= { |cCpo| ( cCpo == cCampo ) }
Local lUsuario			:= .F.

Local cCampo
Local cX3cBox
Local cX3Titulo
Local cGhostInit
Local cBitMapInit
Local lAddFields
Local lUsado
Local lGhostCol
Local lColBmp
Local nSx3Recno
Local nSx3NextRecno
Local nGhostSize
Local nBitMapSize

DEFAULT nUsado			:= 0
DEFAULT aVirtual		:= {}
DEFAULT cAlias			:= Alias()
DEFAULT aNotFields		:= {}
DEFAULT lAllFields		:= .F.
DEFAULT lNotVirtual		:= .F.
DEFAULT uGhostBmpCol	:= .F.
DEFAULT lOnlyNotFields	:= .F.
DEFAULT lChkX3Uso		:= .T.
DEFAULT	lChkNivel		:= .T.
DEFAULT lNumGhostCol	:= .F.
DEFAULT lCposUser		:= .T.
DEFAULT lX3Tela			:= .T.
DEFAULT aCpoCar			:= {}

cNivel := IF( Type("cNivel") == "U" , "9" , cNivel )

nUsado		:= 0
aVirtual	:= {}
aVisual		:= {}
cAlias		:= Upper( AllTrim( cAlias ) )

SX3->( dbSetOrder( 1 ) )
IF SX3->( dbSeek( cAlias , .F. ) )
	IF ( ValType( uGhostBmpCol ) == "L" )
		lGhostCol	:= uGhostBmpCol
		lColBmp		:= .F.

		IF ( lNumGhostCol )
			cGhostInit	:= "GdNumItem('GHOSTCOL')"
			nGhostSize	:= GHOSTCOLSIZE
		EndIF

		DEFAULT cGhostInit	:= ""
		DEFAULT nGhostSize	:= 0
	ElseIF ( ValType( uGhostBmpCol ) == "A" )
		IF ( lGhostCol	:= ( ( nUsado := aScan( uGhostBmpCol , { |x| Upper( AllTrim( x[1] ) ) == "GHOSTCOL" } ) ) > 0 ) )
			IF ( Len( uGhostBmpCol[ nUsado ] ) >= 2 )
				cGhostInit	:= uGhostBmpCol[ nUsado , 2 ]
			EndIF

			IF ( Len( uGhostBmpCol[ nUsado ] ) >= 3 )
				nGhostSize	:= uGhostBmpCol[ nUsado , 3 ]
			EndIF

			IF ( lNumGhostCol )
				DEFAULT cGhostInit	:= "GdNumItem('GHOSTCOL')"
				DEFAULT nGhostSize	:= GHOSTCOLSIZE
			EndIF

			DEFAULT cGhostInit	:= ""
			DEFAULT nGhostSize	:= 0
		EndIF
		
		IF ( lColBmp	:= ( ( nUsado := aScan( uGhostBmpCol , { |x| Upper( AllTrim( x[1] ) ) == "COLBMP" } ) ) > 0 ) )
			IF ( Len( uGhostBmpCol[ nUsado ] ) >= 2 )
				cBitMapInit := uGhostBmpCol[ nUsado , 2 ]
			EndIF
			
			IF ( Len( uGhostBmpCol[ nUsado ] ) >= 3 )
				nBitMapSize	:= uGhostBmpCol[ nUsado , 3 ]
			EndIF
			
			DEFAULT cBitMapInit := "'BR_VERMELHO'"
			DEFAULT nBitMapSize := COLBMPSIZE
		EndIF
	Else
		lGhostCol	:= .F.	
		lColBmp		:= .F.
	EndIF
	
	nUsado := 0
	IF ( ( lColBmp ) .and. !( lNotVirtual ) )
		aAdd( aVirtual , "COLBMP" )
		aAdd( aVisual  , "COLBMP" )
		++nUsado
		aAdd( aHeader , Array( __ELEMENTOS_AHEADER__ ) )
		aHeader[ nUsado , __AHEADER_TITLE__		]	:= ""
		aHeader[ nUsado , __AHEADER_FIELD__		]	:= "COLBMP"
		aHeader[ nUsado , __AHEADER_PICTURE__	]	:= "@BMP"
		aHeader[ nUsado , __AHEADER_WIDTH__		]	:= nBitMapSize
		aHeader[ nUsado , __AHEADER_DEC__		]	:= 0
		aHeader[ nUsado , __AHEADER_VALID__		]	:= ""
		aHeader[ nUsado , __AHEADER_USE__		]	:= Chr(251)
		aHeader[ nUsado , __AHEADER_TYPE__		]	:= "C"
		aHeader[ nUsado , __AHEADER_F3__		]	:= ""
		aHeader[ nUsado , __AHEADER_CONTEXT__	]	:= "V"
		aHeader[ nUsado , __AHEADER_CBOX__		]	:= ""
		aHeader[ nUsado , __AHEADER_INITPAD__	]	:= cBitMapInit
		aHeader[ nUsado , __AHEADER_WHEN__		]	:= ""
		aHeader[ nUsado , __AHEADER_VISUAL__	]	:= "V"
		aHeader[ nUsado , __AHEADER_VLDUSR__	]	:= ""
		aHeader[ nUsado , __AHEADER_RESERV16__	]	:= ""
		aHeader[ nUsado , __AHEADER_RESERV17__	]	:= .F.
	EndIF
	
	While SX3->( !Eof() .and. Upper( AllTrim( X3_ARQUIVO ) ) == cAlias )
		IF !GetNextRecno( "SX3" , @nSx3NextRecno , @nSx3Recno , 1 )
			Exit
		EndIF
		
		cCampo := Upper( AllTrim( SX3->X3_CAMPO ) )
		IF ( lChkX3Uso )
			lUsado		:= SX3->( X3Uso( X3_USADO ) )
			IF !GotoNextRecno( "SX3" , nSx3Recno , 1 )
				Exit
			EndIF
		EndIF
		
		IF ( lCposUser )
			lUsuario := ( SX3->X3_PROPRI $ "uU" )
		EndIF
		
		lAddFields	:= SX3->(;
								( lAllFields .Or. (aScan( aCpoCar, bNotFields) > 0 ));
								.or.;
								(;
									IF( lOnlyNotFields ,;
											(;
												( aScan( aNotFields , bNotFields ) > 0 );
												.or.;
												( lUsuario );
											),;	
											( aScan( aNotFields , bNotFields ) == 0 ) ;
									   );
									.and.;
									IF( lChkX3Uso , lUsado , .T. );
									.and.;
									IF( !CpoObrigat( cCampo ) , IF( lChkNivel , ( cNivel >= X3_NIVEL ) , .T. ) , .T. );
								);
							)
		
		If !( lAddFields )
			IF !GotoNextRecno( "SX3" , nSx3NextRecno , 1 )
				Exit
			Else
				Loop
			EndIF
		EndIF
		
		IF ( SX3->X3_CONTEXT $ "Vv" )
			IF ( lNotVirtual )
				IF !GotoNextRecno( "SX3" , nSx3NextRecno , 1 )
					Exit
				Else
					Loop
				EndIF
			EndIF
			
			aAdd( aVirtual , cCampo )
		EndIF
		
		IF ( SX3->X3_VISUAL $ "SsVv" )
			aAdd( aVisual , cCampo )
		EndIF
		
		cX3cBox 	:= SX3->( X3cBox() )
		IF !GotoNextRecno( "SX3" , nSx3Recno , 1 )
			Exit
		EndIF
		
		cX3Titulo	:= SX3->( AllTrim( X3Titulo() ) )
		IF !GotoNextRecno( "SX3" , nSx3Recno , 1 )
			Exit
		EndIF
		
		If SX3->(FieldPos("X3_TELA")) <> 0 .and. lX3Tela
			if !(Alltrim(MV_MODFOL) $ Alltrim(SX3->X3_TELA)) .and. !(Empty(SX3->X3_TELA))
				IF !GotoNextRecno( "SX3" , nSx3NextRecno , 1 )
					Exit
				Else
					Loop
				EndIF
			endif
		endif

		++nUsado
		
		aAdd( aHeader , Array( __ELEMENTOS_AHEADER__ ) )
		aHeader[ nUsado , __AHEADER_TITLE__		]	:= cX3Titulo
		aHeader[ nUsado , __AHEADER_FIELD__		]	:= cCampo
		aHeader[ nUsado , __AHEADER_PICTURE__	]	:= AllTrim( SX3->X3_PICTURE )
		aHeader[ nUsado , __AHEADER_WIDTH__		]	:= SX3->X3_TAMANHO
		aHeader[ nUsado , __AHEADER_DEC__		]	:= SX3->X3_DECIMAL
		aHeader[ nUsado , __AHEADER_VALID__		]	:= AllTrim( SX3->X3_VALID )
		aHeader[ nUsado , __AHEADER_USE__		]	:= SX3->X3_USADO
		aHeader[ nUsado , __AHEADER_TYPE__		]	:= SX3->X3_TIPO
		aHeader[ nUsado , __AHEADER_F3__		]	:= SX3->X3_F3
		aHeader[ nUsado , __AHEADER_CONTEXT__	]	:= SX3->X3_CONTEXT
		aHeader[ nUsado , __AHEADER_CBOX__		]	:= cX3cBox
		aHeader[ nUsado , __AHEADER_INITPAD__	]	:= AllTrim( SX3->X3_RELACAO )
		aHeader[ nUsado , __AHEADER_WHEN__		]	:= AllTrim( SX3->X3_WHEN )
		aHeader[ nUsado , __AHEADER_VISUAL__	]	:= SX3->X3_VISUAL
		aHeader[ nUsado , __AHEADER_VLDUSR__	]	:= AllTrim( SX3->X3_VLDUSER )
		aHeader[ nUsado , __AHEADER_RESERV16__	]	:= ""
		aHeader[ nUsado , __AHEADER_RESERV17__	]	:= X3Obrigat(SX3->X3_CAMPO)
		IF !GotoNextRecno( "SX3" , nSx3NextRecno , 1 )
			Exit
		EndIF
	End While
	
	IF ( ( lGhostCol ) .and. !( lNotVirtual ) )
		aAdd( aVirtual , "GHOSTCOL" )
		aAdd( aVisual  , "GHOSTCOL" )
		++nUsado
		aAdd( aHeader , Array( __ELEMENTOS_AHEADER__ ) )
		aHeader[ nUsado , __AHEADER_TITLE__		]	:= ""
		aHeader[ nUsado , __AHEADER_FIELD__		]	:= "GHOSTCOL"
		aHeader[ nUsado , __AHEADER_PICTURE__	]	:= ""
		aHeader[ nUsado , __AHEADER_WIDTH__		]	:= nGhostSize
		aHeader[ nUsado , __AHEADER_DEC__		]	:= 0
		aHeader[ nUsado , __AHEADER_VALID__		]	:= ""
		aHeader[ nUsado , __AHEADER_USE__		]	:= Chr(251)
		aHeader[ nUsado , __AHEADER_TYPE__		]	:= "C"
		aHeader[ nUsado , __AHEADER_F3__		]	:= ""
		aHeader[ nUsado , __AHEADER_CONTEXT__	]	:= "V"
		aHeader[ nUsado , __AHEADER_CBOX__		]	:= ""
		aHeader[ nUsado , __AHEADER_INITPAD__	]	:= cGhostInit
		aHeader[ nUsado , __AHEADER_WHEN__		]	:= ""
		aHeader[ nUsado , __AHEADER_VISUAL__	]	:= "V"
		aHeader[ nUsado , __AHEADER_VLDUSR__	]	:= ""
		aHeader[ nUsado , __AHEADER_RESERV16__	]	:= ""
		aHeader[ nUsado , __AHEADER_RESERV17__	]	:= .F.
	EndIF
		
	If !lNotVirtual
		ADHeadRec(cAlias, @aHeader)
		GDResizeWTColumns(@aHeader)
		
		aAdd( aVirtual , aHeader[AScan(aHeader, { |aColumns| IsHeadRec(aColumns[__AHEADER_FIELD__]) }), __AHEADER_FIELD__])
		aAdd( aVirtual , aHeader[AScan(aHeader, { |aColumns| IsHeadAlias(aColumns[__AHEADER_FIELD__]) }), __AHEADER_FIELD__])		
		aAdd( aVisual  , aHeader[AScan(aHeader, { |aColumns| IsHeadRec(aColumns[__AHEADER_FIELD__]) }), __AHEADER_FIELD__])		
		aAdd( aVisual  , aHeader[AScan(aHeader, { |aColumns| IsHeadAlias(aColumns[__AHEADER_FIELD__]) }), __AHEADER_FIELD__])
	EndIf
		
	nUsado:= Len(aHeader)
EndIF
	
SX3->( dbSetOrder( aAreaSX3[ 02 ] ) )
Return AClone(aHeader)

/*/
зддддддддддбддддддддддддддбдддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁGdMontaCols   ЁAutorЁMarinaldo de Jesus   Ё Data Ё17/05/2002Ё
цддддддддддеддддддддддддддадддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁMontar Array de Dados da GetDados                           Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё< Vide Parametros Formais >									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ< Vide Parametros Formais >									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁaCols 														Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGenerico  	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function OLDGdMontaCols(aHeader			,;	//01 -> Array com os Campos do Cabecalho da GetDados
						nUsado			,;	//02 -> Numero de Campos em Uso
						aVirtual		,;	//03 -> [@]Array com os Campos Virtuais
						aVisual			,;	//04 -> [@]Array com os Campos Visuais
						cAlias			,;	//05 -> Opcional, Alias do Arquivo Carga dos Itens do aCols
						aNotFields		,;	//06 -> Opcional, Campos que nao Deverao constar no aHeader
						aRecnos			,;	//07 -> [@]Array unidimensional contendo os Recnos
						cAliasPai   	,;	//08 -> Alias do Arquivo Pai
						cKey			,;	//09 -> Chave para o Posicionamento no Alias Filho
						bKey			,;	//10 -> Bloco para condicao de Loop While
						bSkip			,;	//11 -> Bloco para Skip no Loop While
						lDeleted		,;	//12 -> Se Havera o Elemento de Delecao no aCols 
						lCriaPub		,;	//13 -> Se cria variaveis Publicas
						lInitPad		,;	//14 -> Se Sera considerado o Inicializador Padrao
						cLado			,;	//15 -> Lado para o inicializador padrao
						lAllFields		,;	//16 -> Opcional, Carregar Todos os Campos
						lNotVirtual 	,;	//17 -> Opcional, Nao Carregar os Campos Virtuais
						uQueryCond		,;	//18 -> Opcional, Utilizacao de Query para Selecao de Dados
						lTopExebKey		,;	//19 -> Opcional, Se deve Executar bKey  ( Apenas Quando TOP )
						lTopExebSkip	,;	//20 -> Opcional, Se deve Executar bSkip ( Apenas Quando TOP )
						uGhostBmpCol	,;	//21 -> Carregar Coluna Fantasma e/ou BitMap ( Logico ou Array )
						lOnlyNotFields	,;	//22 -> Inverte a Condicao de aNotFields carregando apenas os campos ai definidos
						lChkX3Uso		,;	//23 -> Verifica se Deve Checar se o campo eh usado
						lChkNivel		,;	//24 -> Verifica se Deve Checar o nivel do usuario
						lPutEmpyaCols	,;	//25 -> Verifica se Deve Carregar o Elemento Vazio no aCols
						aKeyRecnos		,;	//26 -> [@]Array que contera as chaves conforme recnos
						lLockRecnos		,;	//27 -> [@]Se devera efetuar o Lock dos Registros
						lUseCode		,;	//28 -> [@]Se devera obter a Exclusividade nas chaves dos registros
						nMaxLocks		,;	//29 -> Numero maximo de Locks a ser efetuado
						lNumGhostCol	,;	//30 -> Utiliza Numeracao na GhostCol
						lCposUser		 ;	//31 -> Carrega os Campos de Usuario
					)

Return(;
			OLDGdBuildCols(	@aHeader,;
							@nUsado,;
							@aVirtual,;
							@aVisual,;
							@cAlias,;
							@aNotFields,;
							@aRecnos,;
							@cAliasPai,;
							@cKey,;
							@bKey,;
							@bSkip,;
							@lDeleted,;
							@lInitPad,;
							@lAllFields,;
							@lNotVirtual,;
							@uQueryCond,;
							@lTopExebKey,;
							@lTopExebSkip,;
							@uGhostBmpCol,;
							@lOnlyNotFields,;
							@lChkX3Uso,;
							@lChkNivel,;
							@lPutEmpyaCols,;
							@aKeyRecnos,;
							@lLockRecnos,;
							@lUseCode,;
							@nMaxLocks,;
							@lNumGhostCol,;
							@lCposUser;
						);
		)

/*/
зддддддддддбддддддддддддддбдддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁGdBuildCols   ЁAutorЁMarinaldo de Jesus   Ё Data Ё17/05/2002Ё
цддддддддддеддддддддддддддадддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁMontar Array de Dados da GetDados                           Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё< Vide Parametros Formais >									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ< Vide Parametros Formais >									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁaCols 														Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGenerico  	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function OLDGdBuildCols(	aHeader			,;	//01 -> Array com os Campos do Cabecalho da GetDados
						nUsado			,;	//02 -> Numero de Campos em Uso
						aVirtual		,;	//03 -> [@]Array com os Campos Virtuais
						aVisual			,;	//04 -> [@]Array com os Campos Visuais
						cAlias			,;	//05 -> Opcional, Alias do Arquivo Carga dos Itens do aCols
						aNotFields		,;	//06 -> Opcional, Campos que nao Deverao constar no aHeader
						aRecnos			,;	//07 -> [@]Array unidimensional contendo os Recnos
						cAliasPai   	,;	//08 -> Alias do Arquivo Pai
						cKey			,;	//09 -> Chave para o Posicionamento no Alias Filho
						bKey			,;	//10 -> Bloco para condicao de Loop While
						bSkip			,;	//11 -> Bloco para Skip no Loop While
						lDeleted		,;	//12 -> Se Havera o Elemento de Delecao no aCols 
						lInitPad		,;	//13 -> Se Sera considerado o Inicializador Padrao
						lAllFields		,;	//14 -> Opcional, Carregar Todos os Campos
						lNotVirtual 	,;	//15 -> Opcional, Nao Carregar os Campos Virtuais
						uQueryCond		,;	//16 -> Opcional, Utilizacao de Query para Selecao de Dados
						lTopExebKey		,;	//17 -> Opcional, Se deve Executar bKey  ( Apenas Quando TOP )
						lTopExebSkip	,;	//18 -> Opcional, Se deve Executar bSkip ( Apenas Quando TOP )
						uGhostBmpCol	,;	//19 -> Carregar Coluna Fantasma e/ou BitMap ( Logico ou Array )
						lOnlyNotFields	,;	//20 -> Inverte a Condicao de aNotFields carregando apenas os campos ai definidos
						lChkX3Uso		,;	//21 -> Verifica se Deve Checar se o campo eh usado
						lChkNivel		,;	//22 -> Verifica se Deve Checar o nivel do usuario
						lPutEmpyaCols	,;	//23 -> Verifica se Deve Carregar o Elemento Vazio no aCols
						aKeyRecnos		,;	//24 -> [@]Array que contera as chaves conforme recnos
						lLockRecnos		,;	//25 -> [@]Se devera efetuar o Lock dos Registros
						lUseCode		,;	//26 -> [@]Se devera obter a Exclusividade nas chaves dos registros
						nMaxLocks		,;	//27 -> Numero maximo de Locks a ser efetuado
						lNumGhostCol	,;	//28 -> Utiliza Numeracao na GhostCol
						lCposUser		,;	//29 -> Carrega os Campos de Usuario
						lExecTopQry		 ;	//30 -> Se deve executar a Query para TOP - se estiver como .F. trata como DBF
					)

	Local aArea				:= GetArea()
	Local aCols				:= {}
	Local lAddRecnos		:= (ValType( aRecnos ) 	== "A")
	Local lKeyRecnos		:= ( ValType( aKeyRecnos )	== "A" )
	Local lbKey				:= .T.
	Local lbSkip			:= .T.
	Local lGdLocks			:= .T.
	Local nColsRecno		:= 0
	
	Local aChrDelStr
	Local bAscanField
	Local bInitPad
	Local cAliasQuery
	Local cIndexCode
	Local cKeyCode
	Local cInitPad
	Local uInitPad
	Local cNumGhostCol
	Local lBuildHeader
	Local nField
	Local nFields
	Local nCols
	Local nPosVirt
	Local nRecno
	Local nNextRecno
	Local nOrder
	
	#IFDEF TOP
		Local cTypeQryCond
	
		Local lChkFile		:= .F.
		Local lQueryOpened	:= .F.
	
		Local aAreaAlias
		Local aParser
		Local aFields
		Local cQuery
		Local cSvAlias
		Local cPrefixoCpo
		Local cFieldFil
		Local nQuery
		Local nQuerys
		Local nPosField
	#ENDIF
	
	DEFAULT aHeader 		:= {}
	DEFAULT nUsado			:= 0
	DEFAULT aVirtual		:= {}
	DEFAULT aVisual			:= {}
	DEFAULT aNotFields		:= {}
	DEFAULT cAlias			:= Alias()
	DEFAULT aRecnos 		:= {}
	DEFAULT cAliasPai		:= Alias()
	DEFAULT cKey			:= ( cAliasPai )->( __ExecMacro( IndexKey() ) )
	DEFAULT bKey			:= { |cKey| SubStr( __ExecMacro( cIndexKey ) , 1 , Len( cKey ) ) == cKey }
	DEFAULT bSkip			:= { || .F. }
	DEFAULT lDeleted		:= .T.	
	DEFAULT	lInitPad		:= .T.
	DEFAULT lAllFields		:= .F.
	DEFAULT lNotVirtual		:= .F.
	DEFAULT uQueryCond		:= {}
	DEFAULT lTopExebKey		:= .T.
	DEFAULT lTopExebSkip	:= .T.
	DEFAULT uGhostBmpCol	:= .F.
	DEFAULT lOnlyNotFields	:= .F.
	DEFAULT lOnlyNotFields	:= .F.
	DEFAULT lChkX3Uso		:= .T.
	DEFAULT	lChkNivel		:= .T.
	DEFAULT lPutEmpyaCols	:= .T.
	DEFAULT lLockRecnos		:= .F.
	DEFAULT lUseCode		:= .F.
	DEFAULT nMaxLocks		:= GetAdsLckRec()
	DEFAULT lNumGhostCol	:= .F.
	DEFAULT lExecTopQry		:= .T.
	
	
	IF ( lBuildHeader := ( Empty( aHeader ) .or. ( ( nUsado := Len( aHeader ) ) == 0 ) ) )
		aHeader := GdMontaHeader(;
									@nUsado			,;	//01 -> Por Referencia contera o numero de campos em Uso
				   					@aVirtual		,;	//02 -> Por Referencia contera os Campos do Cabecalho da GetDados que sao Virtuais
									@aVisual		,;	//03 -> Por Referencia contera os Campos do Cabecalho da GetDados que sao Visuais
									cAlias			,;	//04 -> Opcional, Alias do Arquivo Para Montagem do aHeader
									aNotFields		,;	//05 -> Opcional, Campos que nao Deverao constar no aHeader
									lAllFields		,;	//06 -> Opcional, Carregar Todos os Campos
									lNotVirtual 	,;	//07 -> Nao Carrega os Campos Virtuais
									uGhostBmpCol	,;	//08 -> Carregar Coluna Fantasma e/ou BitMap ( Logico ou Array )
									lOnlyNotFields	,;	//09 -> Inverte a Condicao de aNotFields carregando apenas os campos ai definidos
									lChkX3Uso		,;	//10 -> Verifica se Deve Checar se o campo eh usado
									lChkNivel		,;	//11 -> Verifica se Deve Checar o nivel do usuario
									lNumGhostCol	,;	//12 -> Utiliza Numeracao na GhostCol
									lCposUser		 ;	//13 -> Carrega os Campos de Usuario
					   			)
	Else
		nUsado := Len( aHeader )
	EndIF
	
	Begin Sequence
	
		IF ( nUsado == 0 )
			Break
		EndIF
		
		IF ( lAddRecnos )
			aRecnos := {}
		EndIF
	
		IF ( lKeyRecnos )
			aKeyRecnos := {}
		EndIF
	
		bAscanField		:= { |cCpo| ( cCpo == aHeader[ nField , __AHEADER_FIELD__ ] ) }
		cAliasQuery		:= cAlias
		nCols 			:= IIF( lDeleted , ( nUsado + 1 ) , nUsado )
		cIndexKey		:= Upper( AllTrim( ( cAliasQuery )->( IndexKey() ) ) )
		cIndexCode		:= cIndexKey
		nOrder			:= ( cAliasQuery )->( IndexOrd() )
	
		IF ( lNumGhostCol )
			cNumGhostCol := Replicate( "0" , GHOSTCOLSIZE )
		Else
			cNumGhostCol := ""
		EndIF
	
		#IFNDEF TOP
			( cAliasQuery )->( dbSeek( cKey , .F. ) )
		#ELSE
			If lExecTopQry
				cTypeQryCond := ValType( uQueryCond )
				
				IF (;
						( cTypeQryCond $ "A/C" );
						.and.;
						!Empty( uQueryCond );
					)
					cSvAlias		:= Alias()
					cQuery			:= "SELECT "
					nFields			:= Len( aHeader )

					For nField := 1 To nFields
						IF ( ( nPosVirt := aScan( aVirtual , bAscanField ) ) == 0 )
							cQuery += aHeader[ nField , __AHEADER_FIELD__ ] + ", "
						EndIF
					Next nField
					
					cQuery		+= "R_E_C_N_O_ RECNO"
					cQuery 		+= " FROM "
					cQuery 		+= InitSqlName( cAliasQuery )
					cQuery		+= " WHERE "
					
					IF ( cTypeQryCond == "A" )
						nQuerys := Len( uQueryCond )
						For nQuery := 1 To nQuerys
							cQuery += uQueryCond[ nQuery ]
						Next nQuery
					Else
						cQuery += uQueryCond
					EndIF	
					
					cQuery		+= " ORDER BY " + SqlOrder( cIndexKey )
					cQuery		:= ChangeQuery( cQuery )
					aAreaAlias  := ( cAliasQuery )->( GetArea() )
					lChkFile	:= ( !( lNotVirtual ) .or. ( lInitPad ) )
					
					IF ( lChkFile )
						( cAliasQuery )->( dbCloseArea() )
					Else
						cAliasQuery := ( "QRY" + cAliasQuery )
					EndIF
					
					IF ( lQueryOpened := MsOpenDbf(.T.,"TOPCONN", TcGenQry(NIL, NIL, cQuery), cAliasQuery,.F.,.T.) )
						cQuery 		:= ""
						nQuery 		:= 0
						nQuerys 	:= 0
						nFields		:= Len( aHeader )
						
						For nField := 1 To nFields
							IF ( ( nPosVirt := aScan( aVirtual , bAscanField ) ) == 0 )
								IF !( aHeader[ nField , __AHEADER_TYPE__ ] == "C" )
									TCSetField(	cAliasQuery,;
												aHeader[nField,__AHEADER_FIELD__],;
												aHeader[nField,__AHEADER_TYPE__],;
												aHeader[nField,__AHEADER_WIDTH__],;
												aHeader[nField,__AHEADER_DEC__])
								EndIf
							EndIF
						Next nField           
						
						lbKey	:= lTopExebKey
						lbSkip	:= lTopExebSkip
						
						IF ( lLockRecnos )
							lAddRecnos	:= lLockRecnos
							aRecnos		:= {}
						EndIF
						
						IF ( lUseCode )
							aChrDelStr	:= { "DTOS" , "STR" , "STRZERO" , "(" , ")" , "," }
							aFields		:= StrToArray( cIndexCode , "+" , { | cString | StrDelChr( @cString , aChrDelStr ) , .T. } )
							aFields		:= FieldsChgCpo( cAlias , aClone( aFields ) , aHeader )
							aParser		:= StrToArray( cIndexCode )
							cPrefixoCpo	:= ( PrefixoCpo( cAlias ) + "_" )
							cFieldFil	:= ( cPrefixoCpo + "FILIAL" )
							cIndexCode	:= ""
							nFields := Len( aFields )

							For nField := 1 To nFields
								IF ( cFieldFil == aFields[ nField ] )
									IF ( GdFieldPos( cFieldFil , aHeader ) > 0 )
										cIndexCode += cFieldFil
										IF ( nField < nFields )
											cIndexCode += "+"
										EndIF
									ElseIF ( GetSx3Cache( cFieldFil , "X3_TAMANHO" ) <> NIL )
										cIndexCode += ( "xFilial('" + cAlias + "')" )
										IF ( nField < nFields )
											cIndexCode += "+"
										EndIF
									EndIF
								ElseIF ( GdFieldPos( aFields[ nField ] , aHeader ) > 0 )
									nPosField := aScan( aParser , { |x| ( aFields[ nField ] $ x ) } )
									IF ( nPosField > 0 )
										cIndexCode += aParser[ nPosField ]
										IF ( nField < nFields )
											cIndexCode += "+"
										EndIF
									EndIF
								EndIF
							Next nField                             
							
							IF ( SubStr( cIndexCode , -1 ) == "+" )
								cIndexCode := SubStr( cIndexCode , 1 , ( Len( cIndexCode ) - 1 ) )	
							EndIF
							
							aParser			:= {}
							aFields			:= {}
							aKeyRecnos		:= {}
							lKeyRecnos		:= lUseCode
						EndIF
					Else
						IF ( lChkFile )
							ChkFile( cAliasQuery )
						Else
							cAliasQuery := cAlias
						EndIF
						RestArea( aAreaAlias )
						( cAliasQuery )->( dbSeek( cKey , .F. ) )
					EndIF
				Else
					( cAliasQuery )->( dbSeek( cKey , .F. ) )
				EndIF
			Else
				( cAliasQuery )->( dbSeek( cKey , .F. ) )
			EndIF
		#ENDIF
	
		While ( cAliasQuery )->( !Eof() .and. IF( lbKey , Eval( bKey , cKey ) , .T. ) )
			/*/
			здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Obtem o Proximo Registro                    				   Ё
			юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды*/
			#IFNDEF TOP
				IF !GetNextRecno( cAliasQuery , @nNextRecno , @nRecno , nOrder )
					Exit
				EndIF
			#ELSE
				IF !( lQueryOpened )
					IF !GetNextRecno( cAliasQuery , @nNextRecno , @nRecno , nOrder )
						Exit
					EndIF
				EndIF
			#ENDIF
			
			IF (;
					( lbSkip );
					.and.;
					( cAliasQuery )->( Eval( bSkip ) );
				)
				#IFNDEF TOP
					IF !GotoNextRecno( cAliasQuery , nNextRecno , nOrder )
						Exit
					EndIF
				#ELSE
					IF !( lQueryOpened )
						IF !GotoNextRecno( cAliasQuery , nNextRecno , nOrder )
							Exit
						EndIF
					Else
						( cAliasQuery )->( dbSkip() )
					EndIF
				#ENDIF
				Loop
			EndIF
			
			IF (;
					( lKeyRecnos );
					.or.;
					( lUseCode );
				)
				IF ( CheckExecForm( { || cKeyCode := ( cAliasQuery )->( __ExecMacro( cIndexCode ) ) } , .F. ) )
					IF ( lKeyRecnos )
						aAdd( aKeyRecnos , cKeyCode )
					EndIF
				Else
					cKeyCode	:= NIL
					lKeyRecnos	:= .F.
					lUseCode	:= .F.
				EndIf
			EndIf
			
			#IFNDEF TOP
				IF ( ( nColsRecno + 1 ) <= nMaxLocks )
					IF !( lGdLocks := GdLocks( cAlias , @lLockRecnos , { nRecno } , @lUseCode , { cKeyCode } , nMaxLocks ) )
						Exit
					EndIF
				EndIF	
			#ELSE
				IF ( lQueryOpened )
					nRecno := ( cAliasQuery )->( RECNO )
				Else
					IF ( ( nColsRecno + 1 ) <= nMaxLocks )
						IF !( lGdLocks := GdLocks( cAlias , @lLockRecnos , { nRecno } , @lUseCode , { cKeyCode } , nMaxLocks  ) )
							Exit
						EndIf
					EndIf
				EndIf
			#ENDIF

			IF ( lAddRecnos )
				aAdd( aRecnos , nRecno )
			EndIF
			
			aAdd( aCols , Array( nCols ) )
			++nColsRecno
			nFields := Len( aHeader )

			For nField := 1 To nFields
				IF ( ( nPosVirt := aScan( aVirtual , bAscanField ) ) == 0 )
					aCols[ nColsRecno , nField ] := ( cAliasQuery )->( __ExecMacro( aHeader[ nField , __AHEADER_FIELD__ ] ) )
				Else
					IF ( aHeader[ nField , __AHEADER_FIELD__ ] == "GHOSTCOL" )
						IF ( lNumGhostCol )
							cNumGhostCol := GdNumItem( "GHOSTCOL" , cNumGhostCol , nColsRecno , aHeader , aCols , nField , .F. )
						EndIF
						
						aCols[ nColsRecno , nField ] := cNumGhostCol
					Else
						IF (;
								( lInitPad );
								.and.;
								!Empty( cInitPad := aHeader[ nField , __AHEADER_INITPAD__ ] );
							)	
							bInitPad	:= __ExecMacro( " { || uInitPad := " + cInitPad + " } " )

							IF !CheckExecForm( bInitPad , .F. )
								uInitPad := GetValType( aHeader[ nField , __AHEADER_TYPE__ ] , aHeader[ nField , __AHEADER_WIDTH__ ] )
							EndIF
						Else
							uInitPad := GetValType( aHeader[ nField , __AHEADER_TYPE__ ] , aHeader[ nField , __AHEADER_WIDTH__ ] )
						EndIF
						
						aCols[ nColsRecno , nField ] := uInitPad
					EndIF
				EndIF
			Next nField
			
			IF ( lDeleted )
				aCols[ nColsRecno , nCols ] := .F.
			EndIF
			
			#IFNDEF TOP
				IF !GotoNextRecno( cAliasQuery , nNextRecno , nOrder )
					Exit
				EndIF
			#ELSE
				IF !( lQueryOpened )
					IF !GotoNextRecno( cAliasQuery , nNextRecno , nOrder )
						Exit
					EndIF
				Else
					( cAliasQuery )->( dbSkip() )
				EndIF
			#ENDIF
		End While
		
		#IFDEF TOP
			IF ( lQueryOpened )
				IF ( Select( cAliasQuery ) > 0 )
					(cAliasQuery)->( dbCloseArea() )
					cAliasQuery := cAlias
					
					IF ( lChkFile )
						ChkFile( cAliasQuery )
					EndIF
					
					RestArea( aAreaAlias )
					dbSelectArea( cSvAlias )
				EndIF
				
				lGdLocks := GdLocks( cAlias , @lLockRecnos , aRecnos , @lUseCode , aKeyRecnos , nMaxLocks  )
			EndIF
		#ENDIF
		
		IF !( lGdLocks )
			nColsRecno	:= 0
			aCols		:= {}
			aRecnos		:= {}

			IF ( lKeyRecnos )
				aKeyRecnos	:= {}
			EndIf
			
			Break
		EndIF
	
		IF (;
				( nColsRecno == 0 );
				.and.;
				( lPutEmpyaCols );
			)
			
			nColsRecno	:= 1
			aCols 		:= Array( nColsRecno , nCols )
			nFields	:= Len( aHeader )
			
			For nField := 1 To nFields
				IF ( aHeader[ nField , __AHEADER_FIELD__ ] == "GHOSTCOL" )
					IF ( lNumGhostCol )
						cNumGhostCol := GdNumItem( "GHOSTCOL" , cNumGhostCol , nColsRecno , aHeader , aCols , nField , .F. )
					EndIF
					aCols[ nColsRecno , nField ] := cNumGhostCol
				Else
					IF (;
							( lInitPad );
							.and.;
							!Empty( cInitPad := aHeader[ nField , __AHEADER_INITPAD__ ] );
						)	
						bInitPad	:= __ExecMacro( " { || uInitPad := " + cInitPad + " } " )
						IF !CheckExecForm( bInitPad , .F. )
							uInitPad := GetValType( aHeader[ nField , __AHEADER_TYPE__ ] , aHeader[ nField , __AHEADER_WIDTH__ ] )
						EndIF
					Else
						uInitPad := GetValType( aHeader[ nField , __AHEADER_TYPE__ ] , aHeader[ nField , __AHEADER_WIDTH__ ] )
					EndIF
					
					aCols[ nColsRecno , nField ] := uInitPad
				EndIF
			Next nField
			
			IF ( lDeleted )
				aCols[ 01 , nCols ] := .F.
			EndIf
		EndIf
	
	End Sequence
		
	RestArea( aArea )

Return( aClone( aCols ) )

/*/
зддддддддддбддддддддддддддбдддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁGdLocks		  ЁAutorЁMarinaldo de Jesus   Ё Data Ё06/03/2003Ё
цддддддддддеддддддддддддддадддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁLock dos Registros na GdBuildCols                           Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё< Vide Parametros Formais >									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ< Vide Parametros Formais >									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁaCols 														Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGenerico  	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function GdLocks(	cAlias		,;	//01 -> Alias para Lock
							lLockRecnos ,;	//02 -> Se Havera Lock dos Recnos
							aRecnos		,;	//03 -> Array com os Recnos para Lock
							lUseCode	,;	//04 -> Se Havera Reserva do Registro (Codigo)
							aKeysCode	,;	//05 -> Array com os Registros (Codigos) a Serem reservados
							nMaxLocks	 ;	//06 -> Numero Maximo de Locks
						)

Local lLocksOk := .T.

IF ( ( lLockRecnos ) .and. ( lUseCode ) )
	lLocksOk := LockRegsCode( cAlias , aRecnos , aKeysCode , 1 , 1 , lUseCode , nMaxLocks )
	
	IF !( lLocksOk )
		lUseCode := ( lLockRecnos := lLocksOk )
	EndIF
ElseIF ( lLockRecnos )
	lLocksOk := LockRegsCode( cAlias , aRecnos , NIL , 1 , 1 , .F. , nMaxLocks )
	
	IF !( lLocksOk )
		lLocksOk := lLockRecnos
	EndIF
ElseIF ( lUseCode )
	lLocksOk := LockRegsCode( cAlias , NIL , aKeysCode , 1 , 1 , lUseCode  , nMaxLocks )
	
	IF !( lLocksOk )
		lUseCode := lLocksOk
	EndIF
EndIF

Return( lLocksOk )

/*/
зддддддддддбдддддддддддддбдддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁMkArrEdFlds	 ЁAutorЁMarinaldo de Jesus    Ё Data Ё29/10/2002Ё
цддддддддддедддддддддддддадддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁDefinir os Campos Alteraveis e Editaveis Baseado no  aHeaderЁ
Ё          ЁaCols, aVisual, aVirtual. Retorna aNaoAltera, aAltera, aFielЁ
Ё          Ёds															Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGenerico 	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function MkArrEdFlds(	nOpc		,;	//Opcao Conforme aRotina
						aHeader 	,;	//Array com os Campos com a Estrutura para a GetDados
						aVisual 	,;	//Array com os Campos Visuais
						aVirtual	,;	//Array com os Campos Virtuais
						aNaoAltera	,;	//Array com os Campos Nao Alteraveis
						aAltera		,;	//Array com os Campos Alteraveis
						aFields		 ;	//Array apenas com Todos os Campos
				    )
				    
Local cCpo
Local nLoop
Local nLoops

DEFAULT aHeader		:= {}
DEFAULT aVisual		:= {}
DEFAULT aVirtual	:= {}
DEFAULT aNaoAltera	:= {}
DEFAULT aAltera		:= {}
DEFAULT aFields		:= {}

/*/
здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Carrega aFields											   Ё
юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
nLoops := Len( aHeader )
For nLoop := 1 To nLoops
	aAdd( aFields , aHeader[ nLoop , __AHEADER_FIELD__ ] )
Next nLoop

/*/
здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Define os Campos Editaveis								   Ё
юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
nLoops := Len( aVisual )
For nLoop := 1 To nLoops
	cCpo := aVisual[ nLoop ]
	aAdd( aNaoAltera , cCpo )
Next nLoop

nLoops := Len( aFields )

For nLoop := 1 To nLoops
	cCpo := aFields[ nLoop ]
	IF ( aScan( aNaoAltera , { |cNaoA| cNaoA == cCpo } ) == 0 )
		/*/
		здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Campos Editaveis Apenas na Inclusao (3) ou Alteracao (4)	   Ё
		юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		IF ( ( nOpc == 3 ) .or. ( nOpc == 4 ) )
			aAdd( aAltera , cCpo )
		Else
			aAdd( aNaoAltera , cCpo )
		EndIF
	EndIF
Next nLoop

Return( NIL )

/*/
зддддддддддбдддддддддддддддддбдддддбддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁGdDelItens 		 ЁAutorЁMarinaldo de JesusЁ Data Ё04/05/2004Ё
цддддддддддедддддддддддддддддадддддаддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁDeletar Itens da GetDados               					Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGenerico 													Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function GdDelItens( aCols , aColsPos )

Local nPosDelete := aColsPos[ 3 ]
Local nLoops	 := Len( aColsPos[ 1 ] )

Local bAeval
Local nLoop

IF ( nLoops > 0 )
	bAeval	:= "{ |aColsnLin|"
	bAeval	+= 		"IF("
	bAeval	+= 			"("
	For nLoop := 1 To nLoops
		bAeval	+= 			"("
		If ValType( aColsPos[2,nLoop] ) == "N"
			bAeval	+=				"AllToChar(aColsnLin["+AllTrim(Str(aColsPos[1,nLoop]))+"],'9999999999.9999',.T.)"
			bAeval	+= 				"=="
			bAeval	+= 				"'" + AllToChar(aColsPos[2,nLoop],'9999999999.9999',.T.) + "'"
		Else
			bAeval	+=				"AllToChar(aColsnLin["+AllTrim(Str(aColsPos[1,nLoop]))+"],NIL,.T.)"
			bAeval	+= 				"=="
			bAeval	+= 				"'" + AllToChar(aColsPos[2,nLoop],NIL,.T.) + "'"
		EndIf
		bAeval	+= 			")"
		IF ( nLoop < nLoops )
			bAeval	+= " .and. "
		EndIF
	Next nLoop
	bAeval	+=			")"
	bAeval	+= 			","
	bAeval	+=				"aColsnLin[nPosDelete] := .T."
	bAeval	+= 				","
	bAeval	+= 				"NIL"
	bAeval	+=			")"
	bAeval	+= "}"
	bAeval	:= __ExecMacro( bAeval )
Else
	bAeval	:= { |aColsnLin| aColsnLin[nPosDelete] := .T. }
EndIF
	
Return( aEval( aCols , bAeval ) )

/*/
зддддддддддбдддддддддддддддддбдддддбддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁGdRstItens		 ЁAutorЁMarinaldo de JesusЁ Data Ё04/05/2004Ё
цддддддддддедддддддддддддддддадддддаддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁRestaurar Itens Deletados da GetDados     					Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGenerico  													Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function GdRstItens( aCols , aColsPos , bGdRstOk )

Local aPosDele	 := {}
Local nElementos := 0
Local nPosDelete := aColsPos[ 3 ]
Local nLoops	 := Len( aColsPos[ 1 ] )

Local bAeval
Local nLoop
Local nDeletados

IF ( nLoops > 0 )
	bAeval	:= "{ | aColsnLin , nLin |"
	bAeval	+= 		"IF("
	bAeval	+= 			"("
	For nLoop := 1 To nLoops
		bAeval	+= 			"("
		bAeval	+= 				"AllToChar(aColsnLin["+AllTrim(Str(aColsPos[1,nLoop]))+"],NIL,.T.)"
		bAeval	+= 				"=="
		bAeval	+= 				"'" + AllToChar(aColsPos[2,nLoop],NIL,.T.) + "'"
		bAeval	+= 			")"
		IF ( nLoop < nLoops )
			bAeval	+= " .and. "
		EndIF
	Next nLoop
	bAeval	+=			")"
	bAeval	+= 			","
	bAeval	+= 				"("
	bAeval	+=					"++nElementos,"
	bAeval	+=					"IF( aColsnLin[ nPosDelete ] , aAdd( aPosDele , nLin ) , NIL )"
	bAeval	+= 				")"
	bAeval	+= 				","
	bAeval	+= 				"NIL"
	bAeval	+=			")"
	bAeval	+= "}"
	bAeval	:= __ExecMacro( bAeval )
Else
	bAeval	:= { | aColsnLin , nLin | ++nElementos , IF( aColsnLin[ nPosDelete ] , aAdd( aPosDele , nLin ) , NIL ) }
EndIF
	
/*/
здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
ЁVerifica Se Existem Elementos e Quantos Estao Deletados       Ё
юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
aEval( aCols , bAeval )

/*/
здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
ЁRestaura Apenas Quando Todos os Elementos Estiverem Deletados Ё
юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
nDeletados := Len( aPosDele )
IF ( ( nDeletados > 0 ) .and. ( nDeletados == nElementos ) )
	DEFAULT bGdRstOk := { | aColsnLin , nLin | .T. }
	bAeval := { | aColsnLin , nLin | IF(;
						   					( aScan( aPosDele , nLin ) > 0 );
											.and.;
											Eval( bGdRstOk , aColsnLin , nLin ),;
											aColsnLin[ nPosDelete ] := .F. ,;
											NIL;
						 				);
			 }
	aEval( aCols , bAeval )
EndIF

Return( NIL )

/*/
зддддддддддбдддддддддддддддддбдддддбддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁIsInGetDados	 ЁAutorЁMarinaldo de JesusЁ Data Ё28/03/2004Ё
цддддддддддедддддддддддддддддадддддаддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁVerifica se Esta executando a partir da GetDados            Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGenerico                    								Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function IsInGetDados( aFields )
                
Local IsInGetDados
Local nField
Local nFields

Begin Sequence

	IF !( IsInGetDados := ( Type( "aHeader" ) == "A" ) )
		Break
	EndIF

	IF !( IsInGetDados := ( Type( "aCols" ) == "A" ) )
		Break
	EndIF

	IF !( IsInGetDados := ( Type( "n" ) == "N" ) )
		Break
	EndIF
	
	IF ( ValType( aFields ) == "A" )
		nFields := Len( aFields )
		For nField := 1 To nFields
			IF !( IsInGetDados := ( GdFieldPos( aFields[ nField ] ) > 0 ) )
				Break
			EndIF
		Next nField
	EndIF	

End Sequence

Return( IsInGetDados )

/*/
зддддддддддбдддддддддддддддддбдддддбддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁGdTransfaCols    ЁAutorЁMarinaldo de JesusЁ Data Ё06/05/2003Ё
цддддддддддедддддддддддддддддадддддаддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁPermuta de Informacoes Entre aCols 							Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGenerico 													Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function GdTransfaCols(	aColsAll    	,;	//01 -> Array com a Estrutura do aCols Contendo todos os Dados
						aCols			,;	//02 -> Array com a Estrutura do aCols Contendo Dados Especificos
						aHeader			,;	//03 -> Array com a Estrutura do aHeader Contendo Informacoes dos Campos
						aPosScanAll		,;	//04 -> Array com as Posicoes dos Campos para Pesquisa
						cKeyFindAll		,;	//05 -> Chave para Busca no aColsAll para Carga do aCols
						aPosSortAll		,;	//06 -> Array com as Posicoes dos Campos para Ordenacao
						aPosKeyAll		,;	//07 -> Array com as Posicoes dos Campos e Chaves para Pesquisa
						aHeaderAll		,;	//08 -> Array com a Estrutura do aHeaderAll Contendo Informacoes dos Campos
						lStatusDel		,;	//09 -> Conteudo do Elemento "Deleted" ( para uso na GdRmkaCols() )
						lChangeAll		,;	//10 -> Se deve Transferir do aCols para o aColsAll
						lChangeCols    	,;	//11 -> Se deve Transferir do aColsAll para o aCols
						lExistDelet		,;	//12 -> Se Existe o Elemento de Delecao no aCols ( para uso na GdRmkaCols() )
						lInitPad		,;	//13 -> Se deve Carregar os Inicializadores padroes ( para uso na GdRmkaCols() )
						cLado			,;	//14 -> Lado para o Inicializador padrao ( para uso na GdRmkaCols() )
						lCriaPub		,;	//15 -> Se deve criar variais Publicas ( para uso na GdRmkaCols() )
						bColsToAll		,;	//16 -> Condicao para a Transferencia do aCols para o aColsAll
						bAllToCols		 ;	//17 -> Condicao para a Transferencia do aColsAll para o aCols
					   )

Return(;
			GdColsExChange(;
								@aColsAll,;
								@aCols,;
								@aHeader,;
								@aPosScanAll,;
								@cKeyFindAll,;
								@aPosSortAll,;
								@aPosKeyAll,;
								@aHeaderAll,;
								@lStatusDel,;
								@lChangeAll,;
								@lChangeCols,;
								@lExistDelet,;
								@lInitPad,;
								@bColsToAll,;
								@bAllToCols;
						   );
	   )

/*/
зддддддддддбдддддддддддддддддбдддддбддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁGdColsExChange	 ЁAutorЁMarinaldo de JesusЁ Data Ё05/08/2004Ё
цддддддддддедддддддддддддддддадддддаддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁPermuta de Informacoes Entre aCols 							Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGenerico 													Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function GdColsExChange(	aColsAll    	,;	//01 -> Array com a Estrutura do aCols Contendo todos os Dados
		 					aCols			,;	//02 -> Array com a Estrutura do aCols Contendo Dados Especificos
							aHeader			,;	//03 -> Array com a Estrutura do aHeader Contendo Informacoes dos Campos
							aPosScanAll		,;	//04 -> Array com as Posicoes dos Campos para Pesquisa
							cKeyFindAll		,;	//05 -> Chave para Busca no aColsAll para Carga do aCols
							aPosSortAll		,;	//06 -> Array com as Posicoes dos Campos para Ordenacao
							aPosKeyAll		,;	//07 -> Array com as Posicoes dos Campos e Chaves para Pesquisa
							aHeaderAll		,;	//08 -> Array com a Estrutura do aHeaderAll Contendo Informacoes dos Campos
							lStatusDel		,;	//09 -> Conteudo do Elemento "Deleted" ( para uso na GdRmkaCols() )
							lChangeAll		,;	//10 -> Se deve Transferir do aCols para o aColsAll
							lChangeCols    	,;	//11 -> Se deve Transferir do aColsAll para o aCols
							lExistDelet		,;	//12 -> Se Existe o Elemento de Delecao no aCols ( para uso na GdRmkaCols() )
							lInitPad		,;	//13 -> Se deve Carregar os Inicializadores padroes ( para uso na GdRmkaCols() )
							bColsToAll		,;	//14 -> Condicao para a Transferencia do aCols para o aColsAll
							bAllToCols		 ;	//15 -> Condicao para a Transferencia do aColsAll para o aCols
					   )

Local aFindKey
Local aColsAux
Local bKeySortAll
Local bKeyScanAll
Local cKeyAtuCols
Local cKeySortAll
Local cKeyScanAll
Local lEqualHeader
Local lPosKeyAll
Local nItem	
Local nItens
Local nItem1
Local nItens1
Local nFindKey
Local nElement

DEFAULT aColsAll		:= {}
DEFAULT aCols			:= {}
DEFAULT aHeader			:= {}
DEFAULT aPosScanAll		:= {}
DEFAULT cKeyFindAll		:= NIL
DEFAULT aPosSortAll		:= aClone( aPosScanAll )
DEFAULT aPosKeyAll		:= {}
DEFAULT aHeaderAll		:= aClone( aHeader     )
DEFAULT lStatusDel		:= .T.
DEFAULT	lChangeAll		:= .T.
DEFAULT	lChangeCols    	:= .T.
DEFAULT lExistDelet		:= .T.
DEFAULT	lInitPad		:= .F.
DEFAULT bColsToAll		:= { | aCols , aHeader , nItem | .T. }
DEFAULT bAllToCols		:= { | aColsAll , aHeaderAll , nFindKey | .T. }

/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
ЁReinicializa aCols e aColsAll se estiverem vazios		  	  Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
IF Empty( aCols )
	aCols := GdRmkaCols( aHeader , lStatusDel , lExistDelet , lInitPad )
EndIF
IF Empty( aColsAll )
	aColsAll := GdRmkaCols( aHeaderAll , lStatusDel , lExistDelet , lInitPad )
EndIF

/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
ЁMonta a Chave e o Bloco para "Sorteio" das Informacoes		  Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
IF ( ( nItens := Len( aPosSortAll ) ) > 0 )
	cKeySortAll := "("
	For nItem := 1 To nItens
		nElement := aPosSortAll[ nItem ]
		If nElement > 0
			IF ( ValType( aColsAll[ 1 , nElement ] ) == "D" )
				cKeySortAll += "Dtos(x["+AllTrim(Str(nElement))+"])+"
			ElseIF ( ValType( aColsAll[ 1 , nElement ] ) == "N" )
				cKeySortAll += "Str(x["+AllTrim(Str(nElement))+"],"+AllTrim(Str(aHeaderAll[nElement,__AHEADER_WIDTH__]))+","+AllTrim(Str(aHeaderAll[nElement,__AHEADER_DEC__]))+")+"
			ElseIF ( ValType( aColsAll[ 1 , nElement ] ) $ "C_M" )
				cKeySortAll	+= "x["+AllTrim(Str(nElement))+"]+"
			ElseIF ( ValType( aColsAll[ 1 , nElement ] ) == "L" )
				cKeySortAll	+= "IF(x["+AllTrim(Str(nElement))+"],'0', '1')+"
			EndIF
		EndIf
	Next nItem
	cKeySortAll := ( SubStr( cKeySortAll , 1 , Len(cKeySortAll) - 1 ) + ")" )
	cKeySortAll += "<"
	cKeySortAll += StrTran( cKeySortAll , "x[" , "y[" )
	cKeySortAll := ( SubStr( cKeySortAll , 1 , Len(cKeySortAll) - 1 ) )
	bKeySortAll := __ExecMacro( "{|x,y|" + cKeySortAll + "}" )
	aSort( aColsAll , NIL , NIL , bKeySortAll )
EndIF
	
/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
ЁMonta a Chave e o Bloco para pesquisa das Informacoes		  Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
IF !( lPosKeyAll := !Empty( aPosKeyAll ) )

	IF ( ( nItens := Len( aPosScanAll ) ) > 0 )

		cKeyAtuCols	:= ""
		cKeyScanAll	:= ""
		For nItem := 1 To nItens
			nElement := aPosScanAll[ nItem ]
			IF ( ValType( aCols[ 1 , nElement ] ) == "D" )
				cKeyAtuCols	+= Dtos( aCols[ 1 , nElement ]	)
				cKeyScanAll	+= "Dtos(x["+AllTrim(Str(nElement))+"])+"
			ElseIF ( ValType( aCols[ 1 , nElement ] ) == "N" )
				cKeyAtuCols	+= Str( aCols[ 1 , nElement ] , aHeader[ nElement , __AHEADER_WIDTH__ ] , aHeader[ nElement , __AHEADER_DEC__ ] )
				cKeyScanAll	+= "Str(x["+AllTrim(Str(nElement))+"],"+AllTrim(Str(aHeader[nElement,__AHEADER_WIDTH__]))+","+AllTrim(Str(aHeader[nElement,__AHEADER_DEC__]))+")+"
			ElseIF ( ValType( aCols[ 1 , nElement ] ) $ "C_M" )
				cKeyAtuCols	+= aCols[ 1 , nElement ]
				cKeyScanAll	+= "x["+AllTrim(Str(nElement))+"]+"
			ElseIF ( ValType( aCols[ 1 , nElement ] ) == "L" )
				cKeyAtuCols	+= IF( aCols[ 1 , nElement ] , ".T." , ".F." )
				cKeyScanAll	+= "IF(x["+AllTrim(Str(nElement))+"],'.T.', '.F.')+"
			EndIF
		Next nItem

		cKeyScanAll := ( SubStr( cKeyScanAll , 1 , Len(cKeyScanAll) - 1 ) + "==" )
		bKeyScanAll := __ExecMacro( "{|x|" + cKeyScanAll + '"' + cKeyAtuCols + '"' + "}" )

	EndIF

Else

	IF ( ( nItens := Len( aPosKeyAll ) ) > 0 )

		cKeyAtuCols	:= ""
		cKeyScanAll	:= ""
		For nItem := 1 To nItens
			nElement := aPosKeyAll[ nItem , 01 ]
			IF ( ValType( aColsAll[ 1 , nElement ] ) == "D" )
				cKeyAtuCols	+= Dtos( aPosKeyAll[ nItem , 02 ] )
				cKeyScanAll	+= "Dtos(x["+AllTrim(Str(nElement))+"])+"
			ElseIF ( ValType( aColsAll[ 1 , nElement ] ) == "N" )
				cKeyAtuCols	+= Str( aPosKeyAll[ nItem , 02 ] , aHeaderAll[ nElement , __AHEADER_FIELD__ ] , aHeaderAll[ nElement , __AHEADER_WIDTH__ ] )
				cKeyScanAll	+= "Str(x["+AllTrim(Str(nElement))+"],"+AllTrim(Str(aHeader[nElement,__AHEADER_FIELD__]))+","+AllTrim(Str(aHeader[nElement,__AHEADER_WIDTH__]))+")+"
			ElseIF ( ValType( aColsAll[ 1 , nElement ] ) $ "C_M" )
				cKeyAtuCols	+= aPosKeyAll[ nItem , 02 ]
				cKeyScanAll	+= "x["+AllTrim(Str(nElement))+"]+"
			ElseIF ( ValType( aColsAll[ 1 , nElement ] ) == "L" )
				cKeyAtuCols	+= IF( aPosKeyAll[ nItem , 02 ] , ".T." , ".F." )
				cKeyScanAll	+= "IF(x["+AllTrim(Str(nElement))+"],'.T.', '.F.')+"
			EndIF
		Next nItem

		cKeyScanAll := ( SubStr( cKeyScanAll , 1 , Len(cKeyScanAll) - 1 ) + "==" )
		bKeyScanAll := __ExecMacro( "{|x|" + cKeyScanAll + '"' + cKeyAtuCols + '"' + "}" )

	EndIF

EndIF

/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
ЁCompara se o Conteudo dos aHeaders sao iguais				  Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
lEqualHeader := ArrayCompare( aHeader , aHeaderAll )

/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
ЁTransfere do aCols para o aColsAll    					  	  Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
IF ( lChangeAll )
	
	aFindKey	:= {}
	nFindKey	:= 0
	While ( ( nFindKey := aScan( aColsAll , bKeyScanAll , ++nFindKey ) ) > 0 )
		aAdd( aFindKey ,  nFindKey )
	End While
	
	IF ( ( nItens := Len( aFindKey ) ) > 0 )
		For nItem := 1 To nItens
			nElement := aFindKey[ nItem ]
			aColsAll[ nElement ] := {}
		Next nItem
		nItens	 := Len( aColsAll )
		bKeyScanAll	:= { |x| Empty( x ) }
		While ( ( nFindKey := aScan( aColsAll , bKeyScanAll ) ) > 0 )
			aDel( aColsAll , nFindKey )
			aSize( aColsAll , --nItens )
		End While
	EndIF
	
	IF ( ( nItens := Len( aCols ) ) > 0 )

		IF !( lEqualHeader )
			aColsAux := GdRmkaCols( aHeaderAll , .T. )
		EndIF

		For nItem := 1 To nItens

			IF !Eval( bColsToAll , aCols , aHeader , nItem )
				Loop
			EndIF

			IF ( lEqualHeader )
				aAdd( aColsAll , aClone( aCols[ nItem ] ) )
			Else
				aAdd( aColsAll , aClone( aColsAux[ 01 ] ) )
				nElement	:= Len( aColsAll )
				nItens1		:= Len( aHeader )
				For nItem1 := 1 To nItens1
					GdFieldPut(;
								aHeader[ nItem1 , __AHEADER_FIELD__ ],;
								aCols[ nItem , nItem1 ],;
								nElement,;
								aHeaderAll,;
								@aColsAll;
							   )	
				Next nItem1
				GdFieldPut(;
							"GDDELETED",;
							GdFieldGet( "GDDELETED" , nItem , NIL , aHeader , aCols ),;
							nElement,;
							aHeaderAll,;
							@aColsAll;
						   )	
				IF ( lPosKeyAll )
					nItens1 := Len( aPosKeyAll )
					For nItem1 := 1 To nItens1
						aColsAll[ nElement , aPosKeyAll[ nItem1 , 01 ] ] := aPosKeyAll[ nItem1 , 02 ]
					Next nITem1
				EndIF
			EndIF	

		Next nItens  

	EndIF
	
	If ValType(bKeySortAll) <> "U"
		aSort( aColsAll , NIL , NIL , bKeySortAll )
	EndIf

EndIF
	
/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
ЁTransfere do aColsAll para o aCols    					  	  Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
aCols				:= {}
DEFAULT cKeyFindAll	:= cKeyAtuCols
lChangeCols			:= IF( lChangeCols , !( cKeyFindAll == NIL ) , lChangeCols )
IF ( lChangeCols )

	bKeyScanAll	:= __ExecMacro( "{|x|" + cKeyScanAll + '"' + cKeyFindAll + '"' + "}" )

	IF !( lEqualHeader )
		aColsAux := GdRmkaCols( aHeader , .T. )
	EndIF

	nFindKey	:= 0
	While ( ( nFindKey := aScan( aColsAll , bKeyScanAll , ++nFindKey ) ) > 0 )

		IF !Eval( bAllToCols , aColsAll , aHeaderAll , nFindKey )
			Loop
		EndIF

		IF ( lEqualHeader )
			aAdd( aCols , aClone( aColsAll[ nFindKey ] ) )
		Else
			aAdd( aCols , aClone( aColsAux[ 01 ] ) )
			nElement := Len( aCols )
			nItens1 := Len( aHeader )
			For nItem1 := 1 To nItens1
				GdFieldPut(;
							aHeader[ nItem1 , __AHEADER_FIELD__ ],;
							aColsAll[ nFindKey , GdFieldPos( aHeader[ nItem1 , __AHEADER_FIELD__ ] , aHeaderAll ) ],;
							nElement,;
							aHeader,;
							@aCols;
						  )
			Next nItem1
			GdFieldPut(;
							"GDDELETED",;
							GdFieldGet( "GDDELETED" , nFindKey , NIL , aHeaderAll , aColsAll ),;
							nElement,;
							aHeader,;
							@aCols;
						   )	
		EndIF	

	End While

EndIF
		
/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
ЁReinicializa aCols e aColsAll se estiverem vazios		  	  Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
IF Empty( aCols )
	aCols := GdRmkaCols( aHeader , lStatusDel , lExistDelet	, lInitPad )
EndIF
IF Empty( aColsAll )
	aColsAll := GdRmkaCols( aHeaderAll , lStatusDel , lExistDelet , lInitPad )
EndIF

Return( NIL )

/*/
зддддддддддбдддддддддддддддддбдддддбддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁGdRmkaCols  	 ЁAutorЁMarinaldo de JesusЁ Data Ё06/05/2003Ё
цддддддддддедддддддддддддддддадддддаддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁReconstroi aCols de Acordo com a Estrutura do aHeader		Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGenerico     												Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function GdRmkaCols(	aHeader 		,;	//Array com a Estrutura para criacao do aCols
						lStatusDel		,;	//Estado do Elemento de Delecao no aCols
						lExistDelet		,;	//Se existe o Elemento de Delecao
						lInitPad		 ;	//Se deve carregar os inicializadores padroes
					)

Local aCols
Local bInitPad
Local cInitPad
Local nItem
Local nItens
Local uInitPad

DEFAULT aHeader		:= {}
DEFAULT lStatusDel	:= .F.
DEFAULT lExistDelet	:= .T.
DEFAULT lInitPad	:= .T.

nItens	:= Len( aHeader )
aCols	:= Array( 01 , nItens + IF( lExistDelet , 1 , 0 ) )
For nItem := 1 To nItens
	uInitPad := NIL
	IF (;
			( lInitPad );
			.and.;
			( Len( aHeader[ nItem ] ) >= __AHEADER_INITPAD__ );
			.and.;
			!Empty( cInitPad := aHeader[ nItem , __AHEADER_INITPAD__ ] );
		)
		bInitPad := __ExecMacro( " { || uInitPad := " + cInitPad + " } " )
		IF (;
				!CheckExecForm( bInitPad , .F. , NIL ,  );
				.or.;
				( uInitPad == NIL );
			)
			uInitPad := GetValType( aHeader[ nItem , __AHEADER_TYPE__ ] , aHeader[ nItem , __AHEADER_WIDTH__ ] )
		EndIF
	Else
		IF ( lInitPad )
			IF ( GetSx3Cache( aHeader[ nItem , __AHEADER_FIELD__ ] , "X3_CAMPO" ) <> NIL )
				bInitPad := { || uInitPad := CriaVar( aHeader[ nItem , __AHEADER_FIELD__ ] , lInitPad , NIL , .F. ) }
			Else
				bInitPad := { || uInitPad := GetValType( aHeader[ nItem , __AHEADER_TYPE__ ] , aHeader[ nItem , __AHEADER_WIDTH__ ] ) }
			EndIF
			IF (;
					!CheckExecForm( bInitPad , .F. , NIL ,  );
					.or.;
					( uInitPad == NIL );
				)
				uInitPad := GetValType( aHeader[ nItem , __AHEADER_TYPE__ ] , aHeader[ nItem , __AHEADER_WIDTH__ ] )
			EndIF
		Else
			uInitPad := GetValType( aHeader[ nItem , __AHEADER_TYPE__ ] , aHeader[ nItem , __AHEADER_WIDTH__ ] )
		EndIF
	EndIF
	aCols[ 01 , nItem ] := uInitPad
Next nItem
IF ( lExistDelet )
	aCols[ 01 , nItem ] := lStatusDel
EndIF

Return( aCols )

/*/
зддддддддддбддддддддддддддддбдддддбдддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o	   ЁGdNumItem		ЁAutorЁMarinaldo de Jesus Ё Data Ё18/07/2003Ё
цддддддддддеддддддддддддддддадддддадддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁRetorna proxima Sequencia Valida para um Determinado  campo	Ё
Ё          Ёda GetDados que possui numeracao automatica					Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁNIL                      									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso	   ЁGenerica      										    	Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function GdNumItem(	cCpo		,;	//Campo para a Numeracao Sequencial
					cLastNum	,;	//Numero Sequencial Anterior
					nLine		,;	//Linha Atual
					aFormHeader ,;	//Array com a Mesma Estrutura do aHeader ( Campos )
					aFormCols	,;	//Array com a Mesma Estrutura do aCols ( Itens )
					nPosCpo		,;	//Indice do Campo
					lAscan		,;	//Se Executa aScan
					bAscan		,;	//Bloco para o aScan
					cbAscanNum	 ;	//Numero a ser utilizado por bAscan ( Deve ser utilizado por Referencia )
				   )

Local cNumItem

Local nTam
Local nLineSub1

Private aCols	:= IF( !( Type( "aCols"   ) == "A" ) , {} , aCols  )
Private aHeader	:= IF( !( Type( "aHeader" ) == "A" ) , {} , aHeader )
Private n		:= IF( !( Type( "n" ) == "N" ) , 1 , n )

DEFAULT nLine		:= n
DEFAULT aFormHeader	:= aHeader
DEFAULT aFormCols	:= aCols

DEFAULT nPosCpo := GdFieldPos( cCpo , aFormHeader )

cNumItem := cLastNum

IF ( nPosCpo > 0 )
	IF Empty( cNumItem )
		nLineSub1	:= Max( ( nLine - 1 ) , 1 )
		
		IF !Empty( aFormCols )
			cNumItem := aFormCols[ nLineSub1 , nPosCpo ]
		EndIF
		
		IF Empty( cNumItem )
			nTam		:= aFormHeader[ nPosCpo , 04 ]
			cNumItem	:= Replicate( "0" , nTam )
		EndIF
	EndIF
	
	cNumItem := Soma1( cNumItem )
	DEFAULT lAscan := .T.
	
	IF ( lAscan )
		If Len(aFormCols) > 1
			cNumItem 	:= Soma1( aFormCols[Len(aFormCols) - 1][nPosCpo] )
		EndIf
	EndIF
Else
	IF ( cNumItem <> NIL )
		cNumItem := Soma1( cNumItem )
	Else
		DEFAULT cNumItem := ""
	EndIF
EndIF

cLastNum := cNumItem

Return( cNumItem )

/*/
зддддддддддбдддддддддддддддддбдддддбддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁGdSplitDel	 	 ЁAutorЁMarinaldo de JesusЁ Data Ё05/08/2004Ё
цддддддддддедддддддддддддддддадддддаддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁSepara as Informacoes que Foram Deletadas na GetDados		Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGenerico                      								Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function GdSplitDel( aHeader , aCols , aRecnos , aColsDel , aRecnosDel )

Local lGdSplitDel := .F.

Local nDeleted
Local nPosDele
Local nCol
Local nCols
Local nRecnos

aColsDel	:= {}
aRecnosDel	:= {}

Begin Sequence

	nDeleted := GdFieldPos( "GDDELETED" , aHeader )

	IF (;
			( nDeleted == 0 );
			.or.;
			( ( nPosDele := aScan( aCols , { |x| x[ nDeleted ] } ) ) == 0 );
		)	
		Break
	EndIF

	nCols		:= Len( aCols )
	nRecnos		:= Len( aRecnos )
	For nCol := nPosDele To nCols
		IF ( aCols[ nCol , nDeleted ] )
			IF ( nCol <= nRecnos )
				lGdSplitDel := .T.
				aAdd( aColsDel 		, aClone( aCols[ nCol ] ) )
				aAdd( aRecnosDel	, aRecnos[ nCol ] )
				aRecnos[ nCol ] := NIL
			EndIF
			aCols[ nCol ] := NIL
		EndIF
	Next nCol
	IF ( aScan( aCols , { |x| ( x == NIL ) } ) > 0 )
		While ( ( nCol := aScan( aCols , { |x| ( x == NIL ) } ) ) > 0 )
			aDel( aCols , nCol )
			aSize( aCols , --nCols )
		End While
		While ( ( nCol := aScan( aRecnos , { |x| ( x == NIL ) } ) ) > 0 )
			aDel( aRecnos , nCol )
			aSize( aRecnos , --nRecnos )
		End While
	EndIF

End Sequence

Return( lGdSplitDel )

/*/
зддддддддддбдддддддддддддбдддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁGdSuperDel   ЁAutorЁMarinaldo de Jesus    Ё Data Ё05/08/2003Ё
цддддддддддедддддддддддддадддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁMarcar e Desmarcar as Informacoes da GetDados como DeletadasЁ
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<vide parametros formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<vide parametros formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGenerico 	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function GdSuperDel( aHeader , aCols , oObjGetDados , lStatusDel , bCondDel )

Local baEval	:= { |aColsItem| IF( Eval( bCondDel , aColsItem ) , aColsItem[ nDeleted ] := lStatusDel , NIL ) }

Local nDeleted

DEFAULT lStatusDel	:= .T.
DEFAULT bCondDel	:= { | aColsItem | .T. }

IF ( ValType( aCols ) == "A" )
	IF ( ValType( aHeader ) == "A" )
		nDeleted := GdFieldPos( "GDDELETED" , aHeader )
	EndIF
	IF ( nDeleted > 0 )
		aEval( aCols , baEval )
	EndIF	
EndIF
	
IF ( ValType( oObjGetDados ) == "O" )
	nDeleted := GdFieldPos( "GDDELETED" , oObjGetDados:aHeader )
	IF ( nDeleted > 0 )
		aEval( oObjGetDados:aCols , baEval )
		oObjGetDados:oBrowse:Refresh()
	EndIF	
EndIF

Return( NIL )

/*/
зддддддддддбдддддддддддддбдддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁGdGetBlock   ЁAutorЁMarinaldo de Jesus    Ё Data Ё10/08/2004Ё
цддддддддддедддддддддддддадддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁRetornar Bloco Verificacao de Campos Vazios no aCols        Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<vide parametros formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<vide parametros formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGenerico 	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function GdGetBlock( cAlias , aFormalHeader , lDefaultRet , cConcat , lNot )

Local bCondDel		:= { || lDefaultRet }
Local cbCondDel		:= ""

Local aObrigat
Local nField
Local nFields
Local nFieldPos
Local nConcat

DEFAULT aFormalHeader	:= aHeader
DEFAULT lNot			:= .F.
DEFAULT cConcat		    := ".or."
DEFAULT lDefaultRet		:= .T.

cConcat := AllTrim( Lower( cConcat ) )

aObrigat := GdObrigat( aFormalHeader )
nFields := Len( aObrigat )
For nField := 1 To nFields
	nFieldPos := GdFieldPos( aObrigat[ nField ] , aFormalHeader )
	IF ( nFieldPos > 0 )
		IF ( lNot )
			cbCondDel += "!"
		EndIF
		cbCondDel += "Empty(aColsItem[" + AllTrim( Str( nFieldPos ) ) + "])"
		cbCondDel += cConcat
	EndIF
Next nField

IF !Empty( cbCondDel )
	nConcat	:= Len( cConcat )
	IF ( SubStr( cbCondDel , -( nConcat ) ) == cConcat )
		cbCondDel := SubStr( cbCondDel , 1 , ( Len( cbCondDel ) - nConcat ) )
	EndIF
	cbCondDel	:= "{ |aColsItem| " + cbCondDel + "}"
	bCondDel	:= __ExecMacro( cbCondDel )
EndIF

Return( bCondDel )

/*/
зддддддддддбддддддддддддддддбдддддбдддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o	   ЁGdPutInfoData	ЁAutorЁMarinaldo de Jesus Ё Data Ё14/10/2003Ё
цддддддддддеддддддддддддддддадддддадддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁGrava as Informacoes da GetDados                           	Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁNIL                      									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso	   ЁGenerica      										    	Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function GdPutInfoData(	aGdInfo			,;	//01 -> Array com as Informacoes a Serem Gravadas
						cExecute		,;	//02 -> Tipo de Execucao "D"elete,"P"ut
						lTopDelItens	,;	//03 -> Se quanto TOP (e alteracao) exclui os itens antes de regrava-los
						lExecSort		,;	//04 -> Se executara o Sort no aCols
						lDelMestre		,;	//05 -> Utilizado na chamada recursiva quando lTopDelItens == .T.
						lChkMestre		,;	//06 -> Se devera verificar o Alias Mestre
						nRecnoMestre	 ;  //07 -> Retorna o recno do cadastro mestre
					  )

Local aItens
Local aSubItens
Local aMsMmPut
Local aMsMmCpos
Local aSubIMsMmCpos
Local aHeader
Local aCposKey
Local aCols
Local aVirtuais
Local aRecnos
Local aSubIRecnos
Local aRecAux
Local bSortaCols
Local bCndDelSubItens
Local cAliasMestre
Local cMestreFldFil
Local cAliasItens
Local cAliasSubItens
Local cAliasMsMm
Local cPrefixoCpo
Local lMestre
Local lDelete
Local lPut
Local lAppend
Local lLock
Local nHeader
Local nHeaders
Local nCol
Local nCols
Local nRecno
Local nRecnos
Local nCpoMemo
Local nMestre
Local nMestres
Local nItem
Local nItens
Local nSubItem
Local nSubItens
Local nCpoKey
Local nCpoKeys
Local nDeleted
Local nRegMestre
Local nMsMmPut
Local nMsMmPuts
Local nFieldPos
Local uCnt

Default	nRecnoMestre	:= 0

DEFAULT aGdInfo			:= {}
DEFAULT cExecute		:= ""
#IFDEF TOP
	DEFAULT lTopDelItens	:= .T.
	DEFAULT lExecSort		:= .F.
#ELSE
	DEFAULT lTopDelItens	:= .F.
	DEFAULT lExecSort		:= .T.
#ENDIF
DEFAULT lDelMestre		:= .T.
DEFAULT lChkMestre		:= .T.

cExecute	:= Upper( Alltrim( cExecute ) )
lPut		:= ( SubStr( cExecute , 1 , 1 ) == "P" )
lDelete		:= ( SubStr( cExecute , 1 , 1 ) == "D" )

/*/
здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
ЁVerifica se, primeiro, ira deletar os Itens e Sub-Itens	   Ё
юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
#IFDEF TOP
	IF ( ( lPut ) .and. ( lTopDelItens ) )
		lTopDelItens	:= .F.
		lDelMestre 		:= .F.
		GdPutInfoData( @aGdInfo , "D" , lTopDelItens , .F. , lDelMestre )
	EndIF
#ENDIF

nMestres := Len( aGdInfo )
For nMestre := 1 To nMestres

	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	ЁVerifica se o Alias eh Valido                     			   Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	IF ( lChkMestre )
	
		IF (;
				Empty( cAliasMestre	:= aGdInfo[ nMestre , 01 ] );
				.or.;
				!( ValType( cAliasMestre ) == "C" );
			)
			Loop
		EndIF
		/*/
		здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Carrega o Registro do Arquivo Mestre          		   	   Ё
		юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		nRegMestre	    := IF( ( ValType( aGdInfo[ nMestre , 02 ] ) == "N" ) , aGdInfo[ nMestre , 02 ] , 0 )
	
		/*/
		здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		ЁVerifica se Considerara o Arquivo Mestre          			   Ё
		юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		lMestre			:= IF( ( ValType( aGdInfo[ nMestre , 03 ] ) == "L" ) , aGdInfo[ nMestre , 03 ] , .F. )
		IF (;
				( lMestre );
				.and.;
				!( lPut );
			)
			lMestre := lDelMestre
		EndIF
		
		/*/
		здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		ЁCarrega o Cabecalho de Campos do Arquivo Mestre   			   Ё
		юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		aHeader			:= IF( ( ValType( aGdInfo[ nMestre , 04 ] ) == "A" ) , aClone( aGdInfo[ nMestre , 04 ] ) , {} )
	
		/*/
		здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		ЁCarrega os Campos Virtuais do Arquivo Mestre   			   Ё
		юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		aVirtuais		:= IF( ( ValType( aGdInfo[ nMestre , 05 ] ) == "A" ) , aClone( aGdInfo[ nMestre , 05 ] ) , {} )
    
	Else
	
		lMestre := .F.

	EndIF
	
	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	ЁCarrega os Itens Relacionados ao Arquivo Mestre               Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	aItens			:= IF( ( ValType( aGdInfo[ nMestre , 07 ] ) == "A" ) , aClone( aGdInfo[ nMestre , 07 ] ) , {} )

	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	ЁInicializa o Array que contera as Informacoes a serem GravadasЁ
	Ёno SYP														   Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	aMsMmPut		:= {}

	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Se for Exclusao               							   Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	IF ( lDelete )

		IF !Empty( nRegMestre )

			Begin Transaction
		
				/*/
				здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				Ё Posiciona no Registro do Arquivo Mestre 				   	   Ё
				юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
				( cAliasMestre )->( MsGoto( nRegMestre ) )
				lLock := ( cAliasMestre )->( RecLock( cAliasMestre , .F. , .F. ) )
				/*/
				здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				Ё Se nГo Conseguiu o Lock Abandona        				   	   Ё
				юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
				IF !( lLock )
					Break
				EndIF

				/*/
				здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				Ё Deleta os Registros dos Arquivos Itens					   Ё
				юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
				nItens := Len( aItens )
				For nItem := 1 To nItens

					/*/
					здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
					ЁVerifica se o Alias eh Valido                     			   Ё
					юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
					IF (;
							Empty( cAliasItens := aItens[ nItem , 01 ] );
							.or.;
							!( ValType( cAliasItens ) == "C" );
						)
						Loop
					EndIF

					/*/
					здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
					Ё Carrega os Recnos Referentes aos Itens             	   	   Ё
					юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
					aRecnos 	:= IF( ( ValType( aItens[ nItem , 06 ] ) == "A" ) , aClone( aItens[ nItem , 06 ] ) , {} )

					/*/
					здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
					Ё Carrega os Campos Memos referentes aos Itens			   	   Ё
					юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
					aMsMmCpos	:= IF( ( ValType( aItens[ nItem , 07 ] ) == "A" ) , aClone( aItens[ nItem , 07 ] ) , {} )

					/*/
					здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
					Ё Carrega o Array de Sub-Itens                 			   	   Ё
					юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
					aSubItens	:= IF( ( ValType( aItens[ nItem , 09 ] ) == "A" ) , aClone( aItens[ nItem , 09 ] ) , {} )
					nSubItens	:= Len( aSubItens )
					For nSubItem := 1 To nSubItens
					
						/*/
						здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
						Ё Consiste o Alias de Sub-Itens            			   	   	   Ё
						юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
						IF (;
								Empty( cAliasSubItens := aSubItens[ nSubItem , 01 ] );
								.or.;
								!( ValType( cAliasSubItens ) == "C" );
							)
							Loop
						EndIF
						
						/*/
						здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
						Ё Carrega os Recnos Referentes aos Sub-Itens           	   	   Ё
						юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
						aSubIRecnos		:= IF( ( ValType( aSubItens[ nSubItem , 02 ] ) == "A" ) , aClone( aSubItens[ nSubItem , 02 ] ) , {} )
							
						/*/
						здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
						Ё Carrega os Campos Memos referentes aos Sub-Itens		   	   Ё
						юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
						aSubIMsMmCpos	:= IF( ( ValType( aSubItens[ nSubItem , 03 ] ) == "A" ) , aClone( aSubItens[ nSubItem , 03 ] ) , {} )

						/*/
						здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
						Ё Carrega o Alias para o MsMm dos Sub-Itens        		   	   Ё
						юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
						cAliasMsMm	:= IF( ( ValType( aSubItens[ nSubItem , 05 ] ) == "C" ) , IF( Empty( aSubItens[ nSubItem , 05 ] ) , "SYP" , aSubItens[ nSubItem , 05 ] ) , "SYP" )
	
						/*/
						здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
						Ё Deleta os Sub-Itens e os Memos Correspondentes			   Ё
						юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
						( cAliasSubItens )->( DelRecnos( cAliasSubItens , @aSubIRecnos , NIL , NIL , aSubIMsMmCpos , cAliasMsMm ) )
						aSubItens[ nSubItem , 02 ] := aClone( aSubIRecnos )

						/*/
						здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
						Ё Redefine os Recnos                        				   Ё
						юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	    	    		aGdInfo[ nMestre , 07 , nItem , 09 , nSubItem , 02 ] := aClone( aSubIRecnos )

					Next nSubItem

					/*/
					здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
					Ё Carrega o Alias para o MsMm dos Itens	        		   	   Ё
					юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
					cAliasMsMm	:= IF( ( ValType( aItens[ nItem , 10 ] ) == "C" ) , IF( Empty( aItens[ nItem , 10 ] ) , "SYP" , aItens[ nItem , 10 ] ) , "SYP" )

					/*/
					здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
					Ё Deleta os Itens e os Memos Correspondentes				   Ё
					юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
					( cAliasItens )->( DelRecnos( cAliasItens , @aRecnos , NIL , NIL , aMsMmCpos , cAliasMsMm ) )
					aItens[ nItem , 06 ] := aClone( aRecnos )

					/*/
					здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
					Ё Redefine os Recnos                        				   Ё
					юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	    	    	aGdInfo[ nMestre , 07 , nItem , 06 ] := aClone( aRecnos )

				Next nItem

				IF ( lMestre )

					/*/
					здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
					Ё Carrega os Campos Memos referentes ao Mestre				   Ё
					юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
					aMsMmCpos := IF( ( ValType( aGdInfo[ nMestre , 06 ] ) == "A" ) , aClone( aGdInfo[ nMestre , 06 ] ) , {} )

					/*/
					здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
					Ё Carrega o Alias para o MsMm do Mestre	        		   	   Ё
					юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
					cAliasMsMm	:= IF( ( ValType( aGdInfo[ nMestre , 08 ] ) == "C" ) , IF( Empty( aGdInfo[ nMestre , 08 ] ) , "SYP" , aGdInfo[ nMestre , 08 ] ) , "SYP" )

					/*/
					здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
					Ё Deleta as Informacoes do Arquivo Mestre e os Memos a ele RelaЁ
					Ё cionados													   Ё
					юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
					( cAliasMestre )->( DelRecnos( cAliasMestre , { nRegMestre } , NIL , NIL , aMsMmCpos , cAliasMsMm ) )

				EndIF

				( cAliasMestre )->( MsUnLock() )
	
			End Transaction
		
		EndIF

	ElseIF ( lPut )
	
		Begin Transaction

			Begin Sequence
		
				/*/
				здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				Ё Loca o Registro no Arquivo Mestre       			   		   Ё
				юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
				IF ( lChkMestre )

					IF !Empty( nRegMestre )
	
						( cAliasMestre )->( MsGoto( nRegMestre ) )
						lLock := ( cAliasMestre )->( RecLock( cAliasMestre , .F. , .F. ) )
						/*/
						здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
						Ё Se nГo Conseguiu o Lock Abandona        				   	   Ё
						юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
						IF !( lLock )
							Break
						EndIF
	
					ElseIF ( lMestre )
						
						lLock := ( cAliasMestre )->( RecLock( cAliasMestre , .T. , .F. ) )
						/*/
						здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
						Ё Se nГo Conseguiu o Lock Abandona        				   	   Ё
						юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
						IF !( lLock )
							Break
						EndIF
	
					Else
						
						Break
								
					EndIF
				
				EndIF
					
				IF ( lMestre )
					
					/*/
					здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
					ЁObtem os campos Memo dos Arquivo Mestre           			   Ё
					юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
					aMsMmCpos := IF( ( ValType( aGdInfo[ nMestre , 06 ] ) == "A" ) , aClone( aGdInfo[ nMestre , 06 ] ) , {} )

					/*/
					здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
					Ё Carrega o Alias para o MsMm do Mestre	        		   	   Ё
					юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
					cAliasMsMm	:= IF( ( ValType( aGdInfo[ nMestre , 08 ] ) == "C" ) , IF( Empty( aGdInfo[ nMestre , 08 ] ) , "SYP" , aGdInfo[ nMestre , 08 ] ) , "SYP" )

					/*/
					здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
					ЁObtendo e Gravando o Conteudo da Filial do Arquivo Mestre	   Ё
					юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
					cMestreFldFil := ( PrefixoCpo( cAliasMestre ) + "_FILIAL" )
					IF ( ( nHeader := GdFieldPos( cMestreFldFil , aHeader ) ) == 0 )
						IF ( ( cAliasMestre )->( ( nFieldPos := FieldPos( cMestreFldFil ) ) ) > 0 )
							( cAliasMestre )->( FieldPut( nFieldPos , xFilial( cAliasMestre ) ) )
						EndIF
					EndIF

					/*/
					здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
					ЁGravando Informacoes do Arquivo Mestre            			   Ё
					юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
					nHeaders := Len( aHeader )
					For nHeader := 1 To nHeaders
	
						IF ( aScan( aVirtuais , { |cCpo| ( cCpo == aHeader[ nHeader , __AHEADER_FIELD__ ] ) } ) == 0 )
	
							IF ( ( nFieldPos := ( cAliasMestre )->( FieldPos( aHeader[ nHeader , __AHEADER_FIELD__ ] ) ) ) > 0 )
								uCnt := GetMemVar( aHeader[ nHeader , __AHEADER_FIELD__ ] )
								( cAliasMestre )->( FieldPut( nFieldPos , uCnt ) )
							EndIF	
	
						ElseIF ( ( nCpoMemo := aScan( aMsMmCpos , { |cCpo| ( cCpo[1] == aHeader[ nHeader , __AHEADER_FIELD__ ] ) } ) ) > 0 )
	
							/*/
							здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
							Ё Armazena as Informacoes que serao gravadas no SYP      	   Ё
							юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
							IF ( ( nFieldPos := ( cAliasMestre )->( FieldPos( aMsMmCpos[nCpoMemo,02] ) ) ) > 0 )
								uCnt := ( cAliasMestre )->( FieldGet( nFieldPos ) )
								( cAliasMestre )->( aAdd( aMsMmPut , { Recno() , uCnt , GetMemVar( aHeader[ nHeader , __AHEADER_FIELD__ ] ) , aMsMmCpos[nCpoMemo,02] , cAliasMsMm } ) )
							EndIF	
	
						EndIF
	
					Next nHeader
					/**************************************************************
					* Retorna o recno                                             *
					***************************************************************/
					nRecnoMestre := ( cAliasMestre )->( Recno() )
					
					/*/
					здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
					ЁNa Inclusao, apos a Gravacao do Mestre, UnLock para efetivar aЁ
					ЁGravacao                                                      Ё
					юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
					IF ( ( lMestre ) .and. Empty( nRegMestre ) )
						( cAliasMestre )->( MsUnLock() )
						( cAliasMestre )->( FkCommit() )
						lLock := ( cAliasMestre )->( RecLock( cAliasMestre , .F. , .F. ) )
						/*/
						здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
						Ё Se nГo Conseguiu o Lock Abandona        				   	   Ё
						юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
						IF !( lLock )
							Break
						EndIF
					EndIF

					/*/
					здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
					Ё Grava as Informacoes no SYP                           	   Ё
					юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
					IF ( ( nMsMmPuts := Len( aMsMmPut ) ) > 0 )
						
						For nMsMmPut := 1 To nMsMmPuts

							/*/
							здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
							Ё Se nao Tiver Numeracao e nem Texto vai para o Proximo	  	   Ё
							юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
							IF (;
									Empty( aMsMmPut[ nMsMmPut , 02 ] );
									.and.;
									Empty( aMsMmPut[ nMsMmPut , 03 ] );
								)
								Loop
							EndIF

							( cAliasMestre )->( dbGoto( aMsMmPut[ nMsMmPut , 01 ] ) )
							lLock := ( cAliasMestre )->( RecLock( cAliasMestre , .F. , .F. ) )
							/*/
							здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
							Ё Se nГo Conseguiu o Lock tenta o proximo  				   	   Ё
							юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
							IF !( lLock )
								Loop
							EndIF

							MsMm(	aMsMmPut[ nMsMmPut , 02 ]	,;
									NIL							,;
									NIL							,;
									aMsMmPut[ nMsMmPut , 03 ]	,;
									1							,;
									NIL							,;
									NIL							,;
									cAliasMestre				,;
									aMsMmPut[ nMsMmPut , 04 ]	,;
									aMsMmPut[ nMsMmPut , 05 ]	 ;
								)

							lLock := ( cAliasMestre )->( RecLock( cAliasMestre , .F. , .F. ) )
							/*/
							здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
							Ё Se nГo Conseguiu o Lock tenta o proximo  				   	   Ё
							юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
							IF !( lLock )
								Loop
							EndIF

						Next nMsMmPut

					EndIF

				EndIF

				/*/
				здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				Ё Grava as Informacoes nos Arquivos Itens	              	   Ё
				юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
				nItens := Len( aItens )
				For nItem := 1 To nItens

					/*/
					здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
					ЁVerifica se o Alias eh Valido                     			   Ё
					юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
					IF (;
							Empty( cAliasItens := aItens[ nItem , 01 ] );
							.or.;
							!( ValType( cAliasItens ) == "C" );
						)	
						Loop
					EndIF
					
					/*/
					здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
					ЁObtem Array com os Campos Chaves dos Itens        			   Ё
					юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
					aCposKey	:= IF( ( ValType( aItens[ nItem , 02 ] ) == "A" ) , aClone( aItens[ nItem , 02 ] ) , {} )
					
					/*/
					здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
					ЁObtem o aHeader Referente aos Itens               			   Ё
					юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
					IF Empty( aHeader := IF( ( ValType( aItens[ nItem , 03 ] ) == "A" ) , aClone( aItens[ nItem , 03 ] ) , {} ) )
						Loop
					EndIF
					
					/*/
					здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
					ЁObtem o aCols Referente aos Itens               			   Ё
					юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
					IF Empty( aCols := IF( ( ValType( aItens[ nItem , 04 ] ) == "A" ) , aClone( aItens[ nItem , 04 ] ) , {} ) )
						Loop
					EndIF

					/*/
					здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
					ЁObtem os Campos Virtuais dos Itens              			   Ё
					юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
					aVirtuais	:= IF( ( ValType( aItens[ nItem , 05 ] ) == "A" ) , aClone( aItens[ nItem , 05 ] ) , {} )

					/*/
					здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
					ЁObtem os Recnos dos Itens                       			   Ё
					юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
					aRecnos 	:= IF( ( ValType( aItens[ nItem , 06 ] ) == "A" ) , aClone( aItens[ nItem , 06 ] ) , {} )

					/*/
					здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
					ЁRemonta aRecnos Eliminado Recnos Invalidos      			   Ё
					юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
					nRecnos := Len( aRecnos )
					IF ( aScan( aRecnos , { |x| Empty( x ) } ) > 0 )
						aRecAux	:= {}
						For nRecno := 1 To nRecnos
							IF Empty( aRecnos[ nRecno ] )
								Loop
							EndIF
							aAdd( aRecAux , aRecnos[ nRecno ] )
						Next nRecno
						aRecnos	:= aClone( aRecAux )
						nRecnos	:= Len( aRecnos )
						aRecAux	:= NIL
					EndIF

					/*/
					здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
					ЁObtem os Campos Memo dos Itens                       		   Ё
					юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
					aMsMmCpos	:= IF( ( ValType( aItens[ nItem , 07 ] ) == "A" ) , aClone( aItens[ nItem , 07 ] ) , {} )

					/*/
					здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
					ЁDefine Bloco para Sort dos Itens                     		   Ё
					юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
					bSortaCols	:= aItens[ nItem , 08 ]

					/*/
					здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
					Ё Carrega o Array de Sub-Itens                 			   	   Ё
					юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
					aSubItens		:= IF( ( ValType( aItens[ nItem , 09 ] ) == "A" ) , aClone( aItens[ nItem , 09 ] ) , {} )
					nSubItens		:= Len( aSubItens )

					/*/
					здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
					ЁInicializa o Array que contera as Informacoes a serem GravadasЁ
					Ёno SYP														   Ё
					юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
					aMsMmPut	:= {}

					/*/
					здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
					ЁObtem o Prefixo dos campos									   Ё
					юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
					cPrefixoCpo := ( PrefixoCpo( cAliasItens ) + "_" )
		
					/*/
					здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
					ЁVerifica o Numero de Campos Chaves							   Ё
					юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
					nCpoKeys	:= Len( aCposKey )

					/*/
					здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
					ЁVerifica o Numero de Campos								   Ё
					юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
					nHeaders	:= Len(	aHeader	 )

					/*/
					здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
					ЁVerifica a Quantidade de Dados								   Ё
					юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
					nCols		:= Len(	aCols	 )

					/*/
					здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
					ЁObtem a Posicao de Delecao    								   Ё
					юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
					nDeleted	:= GdFieldPos( "GDDELETED" , aHeader )
		
					/*/
					здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
					ЁSorteia pelos registros que nao serao deletados para reaproveiЁ
					Ёtar todos os recnos existentes							   	   Ё
					юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
					IF ( lExecSort )
						bSortaCols	:= IF( ( ValType( bSortaCols ) == "B" ) , bSortaCols , { |x| !x[nDeleted] } )
						aSort( aCols , NIL , NIL , bSortaCols )
					EndIF
			
					IF ( nRecnos == nCols )

						For nRecno := 1 To nRecnos

							IF !( lAppend := Empty( aRecnos[ nRecno ] ) )
								( cAliasItens )->( dbGoto( aRecnos[ nRecno ] ) )
								lAppend := ( cAliasItens )->( Eof() )
							EndIF

							IF !( aCols[ nRecno , nDeleted ] )

								lLock := ( cAliasItens )->( RecLock( cAliasItens , lAppend , .F. ) )
								/*/
								здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
								Ё Se nГo Conseguiu o Lock tenta o proximo  				   	   Ё
								юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
								IF !( lLock )
									Loop
								EndIF

								For nCpoKey := 1 To nCpoKeys

									IF ( ( nFieldPos := ( cAliasItens )->( FieldPos( ( cPrefixoCpo + aCposKey[ nCpoKey , 01 ] ) ) ) ) > 0 )
										uCnt := aCposKey[ nCpoKey , 02 ]
										( cAliasItens )->( FieldPut( nFieldPos , uCnt ) )
									EndIF	

								Next nCpoKey

								For nHeader := 1 To nHeaders

									IF ( aScan( aVirtuais , { |cCpo| ( cCpo == aHeader[ nHeader , __AHEADER_FIELD__ ] ) } ) == 0 )

										IF ( ( nFieldPos := ( cAliasItens )->( FieldPos( aHeader[ nHeader , __AHEADER_FIELD__ ] ) ) ) > 0 )
											uCnt := aCols[ nRecno , nHeader ]
											( cAliasItens )->( FieldPut( nFieldPos , uCnt ) )
										EndIF	

									ElseIF ( ( nCpoMemo := aScan( aMsMmCpos , { |cCpo| ( cCpo[1] == aHeader[ nHeader , __AHEADER_FIELD__ ] ) } ) ) > 0 )

										/*/
										здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
										Ё Carrega o Alias para o MsMm dos Itens	        		   	   Ё
										юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
										cAliasMsMm	:= IF( ( ValType( aItens[ nItem , 10 ] ) == "C" ) , IF( Empty( aItens[ nItem , 10 ] ) , "SYP" , aItens[ nItem , 10 ] ) , "SYP" )

										/*/
										здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
										Ё Armazena as Informacoes que serao gravadas no SYP      	   Ё
										юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
										IF ( ( nFieldPos := ( cAliasItens )->( FieldPos( aMsMmCpos[nCpoMemo,02] ) ) ) > 0 )
											uCnt := ( cAliasItens )->( FieldGet( nFieldPos ) )
											( cAliasItens )->(  aAdd( aMsMmPut , { Recno() , uCnt , aCols[ nRecno , nHeader ] , aMsMmCpos[nCpoMemo,02] , cAliasMsMm } ) )
										EndIF

									EndIF

								Next nHeader

								( cAliasItens )->( MsUnlock() )
								( cAliasItens )->( FkCommit() )
							
							ElseIF !( lAppend )
				
								/*/
								здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
								Ё Verifica se Possui Sub-Itens                 			   	   Ё
								юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
								IF ( nSubItens > 0 )

									For nSubItem := 1 To nSubItens
									
										/*/
										здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
										Ё Carrega Informacoes de Sub-Itens            			   	   Ё
										юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
										IF (;
												Empty( cAliasSubItens := aSubItens[ nSubItem , 01 ] );
												.or.;
												!( ValType( cAliasSubItens ) == "C" );
											)
											Loop
										EndIF		
						
										/*/
										здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
										Ё Carrega os Recnos Referentes aos Sub-Itens           	   	   Ё
										юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
										aSubIRecnos		:= IF( ( ValType( aSubItens[ nSubItem , 02 ] ) == "A" ) , aClone( aSubItens[ nSubItem , 02 ] ) , {} )
							
										/*/
										здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
										Ё Carrega os Campos Memos referentes aos Sub-Itens		   	   Ё
										юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
										aSubIMsMmCpos	:= IF( ( ValType( aSubItens[ nSubItem , 03 ] ) == "A" ) , aClone( aSubItens[ nSubItem , 03 ] ) , {} )
							
										/*/
										здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
										Ё Carrega a Condicao para Delecao dos Sub-Itens			   	   Ё
										юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
										bCndDelSubItens := IF( ( ValType( aSubItens[ nSubItem , 04 ] ) == "B" ) , aSubItens[ nSubItem , 04 ] , NIL )

										/*/
										здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
										Ё Carrega o Alias para o MsMm dos Sub-Itens        		   	   Ё
										юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
										cAliasMsMm	:= IF( ( ValType( aSubItens[ nSubItem , 05 ] ) == "C" ) , IF( Empty( aSubItens[ nSubItem , 05 ] ) , "SYP" , aSubItens[ nSubItem , 05 ] ) , "SYP" )
										
										/*/
										здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
										Ё Deleta os Sub-Itens e os Memos Correspondentes			   Ё
										юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
										( cAliasSubItens )->( DelRecnos( cAliasSubItens , @aSubIRecnos , bCndDelSubItens , nRecno , aSubIMsMmCpos , cAliasMsMm ) )
										aSubItens[ nSubItem , 02 ] := aClone( aSubIRecnos )

									Next nSubItem
								
								EndIF
								
								/*/
								здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
								Ё Carrega o Alias para o MsMm dos Itens	        		   	   Ё
								юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
								cAliasMsMm	:= IF( ( ValType( aItens[ nItem , 10 ] ) == "C" ) , IF( Empty( aItens[ nItem , 10 ] ) , "SYP" , aItens[ nItem , 10 ] ) , "SYP" )

								/*/
								здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
								Ё Deleta Registro do Arquivo Itens e os Memos Correspondentes  Ё
								юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
								( cAliasItens )->( DelRecnos( cAliasItens , { aRecnos[ nRecno ] } , NIL , NIL , aMsMmCpos , cAliasMsMm ) )

							EndIF

						Next nRecno

					ElseIF ( nRecnos < nCols )

						For nRecno := 1 To nRecnos

							IF !( lAppend := Empty( aRecnos[ nRecno ] ) )
								( cAliasItens )->( dbGoto( aRecnos[ nRecno ] ) )
								lAppend := ( cAliasItens )->( Eof() )
							EndIF

							IF !( aCols[ nRecno , nDeleted ] )

								lLock := ( cAliasItens )->( RecLock( cAliasItens , lAppend , .F. ) )
								/*/
								здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
								Ё Se nГo Conseguiu o Lock tenta o proximo  				   	   Ё
								юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
								IF !( lLock )
									Loop
								EndIF

								For nCpoKey := 1 To nCpoKeys

									IF ( ( nFieldPos := ( cAliasItens )->( FieldPos( ( cPrefixoCpo + aCposKey[ nCpoKey , 01 ] ) ) ) ) > 0 )
										uCnt := aCposKey[ nCpoKey , 02 ]
										( cAliasItens )->( FieldPut( nFieldPos , uCnt ) )
									EndIF	

								Next nCpoKey

								For nHeader := 1 To nHeaders

									IF ( aScan( aVirtuais , { |cCpo| ( cCpo == aHeader[ nHeader , __AHEADER_FIELD__ ] ) } ) == 0 )

										IF ( ( nFieldPos := ( cAliasItens )->( FieldPos( aHeader[ nHeader , __AHEADER_FIELD__ ] ) ) ) > 0 )
											uCnt := aCols[ nRecno , nHeader ]
											( cAliasItens )->( FieldPut( nFieldPos , uCnt ) )
										EndIF

									ElseIF ( ( nCpoMemo := aScan( aMsMmCpos , { |cCpo| ( cCpo[1] == aHeader[ nHeader , __AHEADER_FIELD__ ] ) } ) ) > 0 )

										/*/
										здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
										Ё Carrega o Alias para o MsMm dos Itens	        		   	   Ё
										юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
										cAliasMsMm	:= IF( ( ValType( aItens[ nItem , 10 ] ) == "C" ) , IF( Empty( aItens[ nItem , 10 ] ) , "SYP" , aItens[ nItem , 10 ] ) , "SYP" )
										
										/*/
										здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
										Ё Armazena as Informacoes que serao gravadas no SYP      	   Ё
										юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
										IF ( ( nFieldPos := ( cAliasItens )->( FieldPos( aMsMmCpos[nCpoMemo,02] ) ) ) > 0 )
											uCnt := ( cAliasItens )->( FieldGet( nFieldPos ) )
											( cAliasItens )->(  aAdd( aMsMmPut , { Recno() , uCnt , aCols[ nRecno , nHeader ] , aMsMmCpos[nCpoMemo,02] , cAliasMsMm } ) )
										EndIF

									EndIF

								Next nHeader

								( cAliasItens )->( MsUnlock() )
								( cAliasItens )->( FkCommit() )

							ElseIF !( lAppend )

								/*/
								здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
								Ё Verifica se Possui Sub-Itens                 			   	   Ё
								юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
								IF ( nSubItens > 0 )

									For nSubItem := 1 To nSubItens
									
										/*/
										здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
										Ё Carrega Informacoes de Sub-Itens            			   	   Ё
										юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
										IF (;
												Empty( cAliasSubItens := aSubItens[ nSubItem , 01 ] );
												.or.;
												!( ValType( cAliasSubItens ) == "C" );
											)
											Loop
										EndIF		
						
										/*/
										здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
										Ё Carrega os Recnos Referentes aos Sub-Itens           	   	   Ё
										юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
										aSubIRecnos		:= IF( ( ValType( aSubItens[ nSubItem , 02 ] ) == "A" ) , aClone( aSubItens[ nSubItem , 02 ] ) , {} )
							
										/*/
										здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
										Ё Carrega os Campos Memos referentes aos Sub-Itens		   	   Ё
										юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
										aSubIMsMmCpos	:= IF( ( ValType( aSubItens[ nSubItem , 03 ] ) == "A" ) , aClone( aSubItens[ nSubItem , 03 ] ) , {} )
							
										/*/
										здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
										Ё Carrega a Condicao para Delecao dos Sub-Itens			   	   Ё
										юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
										bCndDelSubItens := IF( ( ValType( aSubItens[ nSubItem , 04 ] ) == "B" ) , aSubItens[ nSubItem , 04 ] , NIL )

										/*/
										здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
										Ё Carrega o Alias para o MsMm dos Sub-Itens        		   	   Ё
										юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
										cAliasMsMm	:= IF( ( ValType( aSubItens[ nSubItem , 05 ] ) == "C" ) , IF( Empty( aSubItens[ nSubItem , 05 ] ) , "SYP" , aSubItens[ nSubItem , 05 ] ) , "SYP" )

										/*/
										здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
										Ё Deleta os Sub-Itens e os Memos Correspondentes			   Ё
										юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
										( cAliasSubItens )->( DelRecnos( cAliasSubItens , @aSubIRecnos , bCndDelSubItens , nRecno , aSubIMsMmCpos , cAliasMsMm ) )
										aSubItens[ nSubItem , 02 ] := aClone( aSubIRecnos )

									Next nSubItem
								
								EndIF
								
								/*/
								здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
								Ё Carrega o Alias para o MsMm dos Itens	        		   	   Ё
								юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
								cAliasMsMm	:= IF( ( ValType( aItens[ nItem , 10 ] ) == "C" ) , IF( Empty( aItens[ nItem , 10 ] ) , "SYP" , aItens[ nItem , 10 ] ) , "SYP" )

								/*/
								здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
								Ё Deleta Registro do Arquivo Itens e os Memos Correspondentes  Ё
								юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
								( cAliasItens )->( DelRecnos( cAliasItens , { aRecnos[ nRecno ] } , NIL , NIL , aMsMmCpos , cAliasMsMm ) )

							EndIF

						Next nRecno

						For nCol := nRecno To nCols

							IF !( aCols[ nCol , nDeleted ] )

								lLock := ( cAliasItens )->( RecLock( cAliasItens , .T. , .F. ) )
								/*/
								здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
								Ё Se nГo Conseguiu o Lock tenta o proximo  				   	   Ё
								юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
								IF !( lLock )
									Loop
								EndIF

								For nCpoKey := 1 To nCpoKeys

									IF ( ( nFieldPos := ( cAliasItens )->( FieldPos( ( cPrefixoCpo + aCposKey[ nCpoKey , 01 ] ) ) ) ) > 0 )
										uCnt := aCposKey[ nCpoKey , 02 ]
										( cAliasItens )->( FieldPut( nFieldPos , uCnt ) )
									EndIF	

								Next nCpoKey

								For nHeader := 1 To nHeaders

									IF ( aScan( aVirtuais , { |cCpo| ( cCpo == aHeader[ nHeader , __AHEADER_FIELD__ ] ) } ) == 0 )

										IF ( ( nFieldPos := ( cAliasItens )->( FieldPos( aHeader[ nHeader , __AHEADER_FIELD__ ] ) ) ) > 0 )
											uCnt := aCols[ nCol , nHeader ]
											( cAliasItens )->( FieldPut( nFieldPos , uCnt ) )
										EndIF	

									ElseIF ( ( nCpoMemo := aScan( aMsMmCpos , { |cCpo| ( cCpo[1] == aHeader[ nHeader , __AHEADER_FIELD__ ] ) } ) ) > 0 )

										/*/
										здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
										Ё Carrega o Alias para o MsMm dos Itens	        		   	   Ё
										юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
										cAliasMsMm	:= IF( ( ValType( aItens[ nItem , 10 ] ) == "C" ) , IF( Empty( aItens[ nItem , 10 ] ) , "SYP" , aItens[ nItem , 10 ] ) , "SYP" )

										/*/
										здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
										Ё Armazena as Informacoes que serao gravadas no SYP      	   Ё
										юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
										IF ( ( nFieldPos := ( cAliasItens )->( FieldPos( aMsMmCpos[nCpoMemo,02] ) ) ) > 0 )
											uCnt := ( cAliasItens )->( FieldGet( nFieldPos ) )
											( cAliasItens )->(  aAdd( aMsMmPut , { Recno() , uCnt , aCols[ nCol , nHeader ] , aMsMmCpos[nCpoMemo,02] , cAliasMsMm } ) )
										EndIF

									EndIF

								Next nHeader

								( cAliasItens )->( MsUnlock() )
								( cAliasItens )->( FkCommit() )

							EndIF

						Next nCol

					EndIF

					/*/
					здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
					Ё Carrega o Alias para o MsMm dos Itens	        		   	   Ё
					юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
					cAliasMsMm	:= IF( ( ValType( aItens[ nItem , 10 ] ) == "C" ) , IF( Empty( aItens[ nItem , 10 ] ) , "SYP" , aItens[ nItem , 10 ] ) , "SYP" )

					/*/
					здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
					Ё Grava as Informacoes no SYP                           	   Ё
					юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
					IF ( ( nMsMmPuts := Len( aMsMmPut ) ) > 0 )
						
						For nMsMmPut := 1 To nMsMmPuts
	
							/*/
							здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
							Ё Se nao Tiver Numeracao e nem Texto vai para o Proximo	  	   Ё
							юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
							IF (;
									Empty( aMsMmPut[ nMsMmPut , 02 ] );
									.and.;
									Empty( aMsMmPut[ nMsMmPut , 03 ] );
								)
								Loop
							EndIF		
							
							( cAliasItens )->( dbGoto( aMsMmPut[ nMsMmPut , 01 ] ) )
							lLock := ( cAliasItens )->( RecLock( cAliasItens , .F. , .F. ) )
							/*/
							здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
							Ё Se nГo Conseguiu o Lock tenta o proximo  				   	   Ё
							юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
							IF !( lLock )
								Loop
							EndIF

							MsMm(	aMsMmPut[ nMsMmPut , 02 ]	,;
									NIL							,;
									NIL							,;
									aMsMmPut[ nMsMmPut , 03 ]	,;
									1							,;
									NIL							,;
									NIL							,;
									cAliasItens					,;
									aMsMmPut[ nMsMmPut , 04 ]	,;
									aMsMmPut[ nMsMmPut , 05 ]	 ;
								 )

							( cAliasItens )->( MsUnLock() )
							( cAliasItens )->( FkCommit() )							
	
						Next nMsMmPut
					
					EndIF
	
				Next nItem

			End Sequence

			IF ( lChkMestre )
				( cAliasMestre )->( MsUnLock() )
				( cAliasMestre )->( FkCommit() )
			EndIF	
		
		End Transaction
	
	EndIF

Next nMestre
	
Return( NIL )

/*/
зддддддддддбддддддддддддддддбдддддбдддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o	   ЁGdPutIStrSItens ЁAutorЁMarinaldo de Jesus Ё Data Ё14/10/2003Ё
цддддддддддеддддддддддддддддадддддадддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁRetorna Estrutura Padrao para o Array aSubItens que sera utiЁ
Ё          Ёlizado em GdPutInfoData										Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁArray com a Estrutura do aSubItens							Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso	   ЁGenerica      										    	Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function GdPutIStrSItens( nElem )

Local aSubItens := IF( Empty( nElem ) , Array( 05 ) , Array( nElem , 05 ) )

/*/
	aSubItens[1] <==> Alias do Sub-Itens
	aSubItens[2] <==> Array contendo os Recnos dos Sub-Itens
	aSubItens[3] <==> Array contendo os campos de Memo dos Sub-Itens
	aSubItens[4] <==> Bloco com a Condicao para Delecao dos Sub-Itens
	aSubItens[5] <==> Alias para a MsMm ( DEFAULT "SYP" )
/*/

Return( aClone( aSubItens ) )

/*/
зддддддддддбддддддддддддддддбдддддбдддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o	   ЁGdPutIStrItens	ЁAutorЁMarinaldo de Jesus Ё Data Ё14/10/2003Ё
цддддддддддеддддддддддддддддадддддадддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁRetorna Estrutura Padrao para o Array aItens que sera  utiliЁ
Ё          Ёzado em GdPutInfoData										Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁArray com a Estrutura do aItens								Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso	   ЁGenerica      										    	Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function GdPutIStrItens( nElem )

Local aItens := IF( Empty( nElem ) , Array( 10 ) , Array( nElem , 10 ) )

/*/
	aItens[01] <==>	Alias do Itens
	aItens[02] <==> Array contendo os Campos Chaves dos Itens e conteudo a ser gravado
	aItens[03] <==>	Array contendo informacoes de Cabecalho do aItens (aHeader)
	aItens[04] <==>	Array contendo informacoes de Detalhe do aItens (aCols)
	aItens[05] <==>	Array contendo os campos virtuais do aItens
	aItens[06] <==> Array contendo os Recnos dos Itens
	aItens[07] <==> Array contendo os campos de Memo dos Itens
	aItens[08] <==> Bloco para Sort dos Itens
	aItens[09] <==>	Array contendo Informacoes de Sub-Itens
	aItens[10] <==>	Alias para a MsMm ( DEFAULT "SYP" )
/*/

Return( aClone( aItens ) )

/*/
зддддддддддбддддддддддддддддбдддддбдддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o	   ЁGdPutIStrMestre	ЁAutorЁMarinaldo de Jesus Ё Data Ё14/10/2003Ё
цддддддддддеддддддддддддддддадддддадддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁRetorna Estrutura Padrao para o Array aMestre que sera utiliЁ
Ё          Ёzado em GdPutInfoData										Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁArray com a Estrutura do aMestre							Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso	   ЁGenerica      										    	Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function GdPutIStrMestre( nElem )

Local aMestre := IF( Empty( nElem ) , Array( 08 ) , Array( nElem , 08 ) )

/*/
	aMestre[01] <==> Alias do Arquivo Mestre
	aMestre[02] <==> Recno do Arquivo Mestre
	aMestre[03] <==> .T. para considerar o Arquivo Mestre e .F. caso contrario
	aMestre[04] <==> Cabecalho de Campos do Arquivo Mestre (aHeader)
	aMestre[05] <==> Campos Virtuais do Arquivo Mestre
	aMestre[06] <==> Campos Memos referentes ao Mestre
	aMestre[07] <==> Itens Relacionados ao Arquivo Mestre
	aMestre[08] <==> Alias para a MsMm ( DEFAULT "SYP" )
/*/

Return( aClone( aMestre ) )

/*/
зддддддддддбдддддддддддддддддбдддддбддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁGdRstDblClick 	 ЁAutorЁMarinaldo de JesusЁ Data Ё20/03/2004Ё
цддддддддддедддддддддддддддддадддддаддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁRestaura e Executa o oGetDados:oBrowse:blDblClick			Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁoGetDados:oBrowse:blDblClick								Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function GdRstDblClick( oGetDados , blDblClick )

Local bSvblDblClick

bSvblDblClick := oGetDados:oBrowse:blDblClick
oGetDados:oBrowse:blDblClick := blDblClick
Eval( oGetDados:oBrowse:blDblClick )
oGetDados:oBrowse:blDblClick := bSvblDblClick

Return( NIL )

/*/
зддддддддддбддддддддддддддбдддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁSaveoGet()    ЁAutorЁMarinaldo de Jesus   Ё Data Ё28/06/2002Ё
цддддддддддеддддддддддддддадддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁSalva aHeader, aCols e n para que sejam restaurados pela ResЁ
Ё          ЁtaroGet()													Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё< Vide Parametros Formais >									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ< Vide Parametros Formais >									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁaCols 														Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGenerico  	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function SaveoGet( cPosSave , oGet )

Local aSvoGet := Array( 6 )

DEFAULT cPosSave := "ALL"

cPosSave := Upper( AllTrim( cPosSave ) )

IF ( Type("aHeader") == "A" )
	IF ( cPosSave == "ALL" .or. "1" $ cPosSave )
		aSvoGet[1] := aClone( aHeader )
	EndIF	
EndIF	
IF ( Type("aCols") == "A" )
	IF ( cPosSave == "ALL" .or. "3" $ cPosSave )
		aSvoGet[2] := aClone( aCols   )
	EndIF	
EndIF	
IF ( Type("n") == "N" )
	IF ( cPosSave == "ALL" .or. "3" $ cPosSave )
		aSvoGet[3] := n
	EndIF	
EndIF	

IF ( ValType( oGet ) == "O" )
	IF ValType( oGet:oBrowse:nColPos ) == "N"
		IF ( cPosSave == "ALL" .or. "4" $ cPosSave )
			aSvoGet[4] := oGet:oBrowse:nColPos
		EndIF
	EndIF
	IF ValType( oGet:oBrowse:nRowPos ) == "N"
		IF ( cPosSave == "ALL" .or. "5" $ cPosSave )
			aSvoGet[5] := oGet:oBrowse:nRowPos
		EndIF
	EndIF
	IF ValType( oGet:oBrowse:nAt ) == "N"
		IF ( cPosSave == "ALL" .or. "6" $ cPosSave )
			aSvoGet[6] := oGet:oBrowse:nAt
		EndIF
	EndIF
EndIF

Return( aClone( aSvoGet ) )

/*/
зддддддддддбддддддддддддддбдддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁRestartoGet   ЁAutorЁMarinaldo de Jesus   Ё Data Ё28/06/2002Ё
цддддддддддеддддддддддддддадддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁRestaura aHeader, aCols e n Salvos em SaveoGet()            Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё< Vide Parametros Formais >									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ< Vide Parametros Formais >									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁaCols 														Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGenerico  	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function RestartoGet( aSvoGet , cPosRestart , oGet )

DEFAULT aSvoGet		:= Array( 5 )
DEFAULT cPosRestart := "ALL"

cPosRestart := Upper( AllTrim( cPosRestart ) )

IF ( !Empty( aSvoGet[1] ) .and. Type( "aHeader" ) == "A" )
	IF ( ValType( aSvoGet[1] ) == "A" )
		IF ( cPosRestart == "ALL" .or. "1" $ cPosRestart )
			IF ( Type( "aHeader" ) == "A" )
				aHeader := aClone( aSvoGet[1] )
			EndIF	
		EndIF	
	EndIF	
EndIF	

IF ( !Empty( aSvoGet[2] ) .and. Type( "aCols" ) == "A" )
	IF ( ValType( aSvoGet[2] ) == "A" )
		IF ( cPosRestart == "ALL" .or. "2" $ cPosRestart )
			IF ( Type( "aCols" ) == "A" )
				aCols := aClone( aSvoGet[2] )
			EndIF
		EndIF
	EndIF	
EndIF	

IF !Empty( aSvoGet[3] ) .and. Type( "n" ) == "N"
	IF ( ValType( aSvoGet[3] ) == "N" )
		IF ( cPosRestart == "ALL" .or. "3" $ cPosRestart )
			n := aSvoGet[3]
		EndIF
	EndIF
EndIF

IF ( ValType( oGet ) == "O" )
	IF !Empty( aSvoGet[4] ) .and. ValType( oGet:oBrowse:nColPos ) == "N"
		IF ( ValType( aSvoGet[4] ) == "N" )
			IF ( cPosRestart == "ALL" .or. "4" $ cPosRestart )
				oGet:oBrowse:nColPos := aSvoGet[4]
			EndIF
		EndIF
	EndIF
	IF !Empty( aSvoGet[5] ) .and. ValType( oGet:oBrowse:nRowPos ) == "N"
		IF ( ValType( aSvoGet[5] ) == "N" )
			IF ( cPosRestart == "ALL" .or. "5" $ cPosRestart )
				oGet:oBrowse:nRowPos := aSvoGet[5]
			EndIF
		EndIF
	EndIF
	IF !Empty( aSvoGet[6] ) .and. ValType( oGet:oBrowse:nAt ) == "N"
		IF ( ValType( aSvoGet[6] ) == "N" )
			IF ( cPosRestart == "ALL" .or. "6" $ cPosRestart )
				oGet:oBrowse:nAt := aSvoGet[6]
			EndIF
		EndIF
	EndIF
EndIF

Return( NIL )

/*/
зддддддддддбддддддддддддбдддддбдддддддддддддддддддддддддбддддбдддддддддд©
ЁFun┤┘o    ЁFieldsChgCpoЁAutorЁMarinaldo de Jesus       ЁDataЁ11/08/2004Ё
цддддддддддеддддддддддддадддддадддддддддддддддддддддддддаддддадддддддддд╢
ЁDescri┤┘o ЁChange de Campos confortme aHeader                  		Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGenerico              			                  	   		Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function FieldsChgCpo( cAlias , aFields , aFormalHeader )

Local nField
Local nFields
Local nFieldPos

IF ( Type( "aHeader" ) == "A" )
	DEFAULT aFormalHeader := aHeader
EndIF

IF Empty( aFormalHeader )
	aFormalHeader := GdAllFields( cAlias )
EndIF

nFields := Len( aFormalHeader )
For nField := 1 To nFields
	IF ( ( nFieldPos := aScan( aFields , { |e| ( aFormalHeader[ nField , __AHEADER_FIELD__ ] $ e ) } ) ) > 0 )
		IF ( aFormalHeader[ nField , __AHEADER_FIELD__ ] <> aFields[ nFieldPos ] )
			aFields[ nFieldPos ] := aFormalHeader[ nField , __AHEADER_FIELD__ ]
		EndIF
	EndIF
Next nField

Return( aFields )

/*/
зддддддддддбдддддддддддддддддбдддддбддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁInAddLine		 ЁAutorЁMarinaldo de JesusЁ Data Ё28/03/2004Ё
цддддддддддедддддддддддддддддадддддаддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁVerifica se Esta executando a partir do Metodo AddLine      Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGenerico                     								Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function InAddLine( cStackExit )
Return( IsInCallStack( "ADDLINE" , cStackExit ) )

/*/
зддддддддддбддддддддддддддбдддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁaFlds2Str     ЁAutorЁMarinaldo de Jesus   Ё Data Ё23/09/2004Ё
цддддддддддеддддддддддддддадддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁMonta String a Partir do Array aFields                      Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁaHeader														Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGenerico  	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function aFlds2Str( cAlias , aFields , aColsn , aHeader )

Local cFieldsStr := ""

Local nField
Local nFields
Local nFieldPos
Local uCnt

Begin Sequence

	IF Empty( aFields )
		Break
	EndIF

	IF (;
			!Empty( aColsn );
			.and.;
			!Empty( aHeader );
		)
		nFields := Len( aFields )
		For nField := 1 To nFields
			IF ( ( nFieldPos := GdFieldPos( aFields[ nField ] , aHeader ) ) == 0 )
				Loop
			EndIF
			uCnt 		:= aColsn[ nFieldPos ]
			cFieldsStr	+= AllToChar( uCnt , aHeader[ nFieldPos , __AHEADER_PICTURE__ ] , .T. )
		Next nLoop
	Else
		cFieldsStr := ( cAlias )->( __ExecMacro( X2Unique2Index( cAlias , aFields ) ) )
	EndIF

End Sequence
	
Return( cFieldsStr )

/*/
зддддддддддбддддддддддддддддбдддддбдддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o	   ЁGetStrBlkAsc	ЁAutorЁMarinaldo de Jesus Ё Data Ё17/12/2004Ё
цддддддддддеддддддддддддддддадддддадддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁRetorna String de CodeBlock para um Ascan					Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁNIL                      									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso	   ЁGenerica      										    	Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function GetStrBlkAsc( aHeader , uFieldsKey , uCntFieldsKey , cConCat , cOperator )
Return( GetStrBlock( aHeader , uFieldsKey , uCntFieldsKey , cConCat , cOperator , .F. )  )

/*/
зддддддддддбддддддддддддддддбдддддбдддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o	   ЁGetStrBlock		ЁAutorЁMarinaldo de Jesus Ё Data Ё20/12/2004Ё
цддддддддддеддддддддддддддддадддддадддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁRetorna String de CodeBlock									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁNIL                      									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso	   ЁGenerica      										    	Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function GetStrBlock( aHeader , uFieldsKey , uCntFieldsKey , cConCat , cOperator , lFields )

Local cStrBlock := "{ || .F. }"

Local cTypeKey
Local cField

Local nPosKey
Local nField
Local nFields

Begin Sequence

	DEFAULT cOperator	:= "=="
	DEFAULT lFields		:= .T.
	IF ( !Empty( uFieldsKey ) )
		cTypeKey := ValType( uFieldsKey )
		IF ( cTypeKey == "C" )
			cField	:= Upper( AllTrim( uFieldsKey ) )
			nPosKey := GdFieldPos( cField , aHeader )
			IF ( nPosKey > 0 )
				IF !( cField == "GDDELETED" )
					IF ( lFields )
						cStrBlock := "{ || AllToChar( " + aHeader[ nPosKey , __AHEADER_FIELD__ ] + " , '" + aHeader[ nPosKey , __AHEADER_PICTURE__ ] + "' , .T. )" + cOperator + "'" + AllToChar( uCntFieldsKey , aHeader[ nPosKey , __AHEADER_PICTURE__ ] , .T. ) + "' }"
					Else
						cStrBlock := "{ |x| AllToChar( x[" + AllTrim( Str( nPosKey ) ) + "] , '" + aHeader[ nPosKey , __AHEADER_PICTURE__ ] + "' , .T. )" + cOperator + "'" + AllToChar( uCntFieldsKey , aHeader[ nPosKey , __AHEADER_PICTURE__ ] , .T. ) + "' }"
					EndIF
				ElseIF !( lFields )
					cStrBlock := "{ |x| AllToChar( x[" + AllTrim( Str( nPosKey ) ) + "] , NIL , .T. )" + cOperator + "'" + AllToChar( uCntFieldsKey , NIL , .T. ) + "' }"
				EndIF
			EndIF
		ElseIF ( cTypeKey == "A" )
			nFields := Len( uFieldsKey )
			IF ( nFields <> Len( uCntFieldsKey ) )
				Break
			EndIF
			DEFAULT cConCat := " .and. "
			IF ( lFields )
				cStrBlock := "{ || "
			Else
				cStrBlock := "{ |x| "
			EndIF
			For nField := 1 To nFields
				cField	:= Upper( AllTrim( uFieldsKey[ nField ] ) )
				nPosKey := GdFieldPos( cField , aHeader )
				IF ( nPosKey > 0 )
					IF !( cField == "GDDELETED" )
						IF ( lFields )
							cStrBlock	+= "AllToChar( " + aHeader[ nPosKey , __AHEADER_FIELD__ ] + " , '" + aHeader[ nPosKey , __AHEADER_PICTURE__ ] + "' , .T. )" + cOperator + "'" + AllToChar( uCntFieldsKey[ nField ] , aHeader[ nPosKey , __AHEADER_PICTURE__ ] , .T. ) + "' "
						Else
							cStrBlock	+= "AllToChar( x[" + AllTrim( Str( nPosKey ) ) + "] , '" + aHeader[ nPosKey , __AHEADER_PICTURE__ ] + "' , .T. )" + cOperator + "'" + AllToChar( uCntFieldsKey[ nField ] , aHeader[ nPosKey , __AHEADER_PICTURE__ ] , .T. ) + "' "
						EndIF	
					ElseIF !( lFields )
						cStrBlock	+= "AllToChar( x[" + AllTrim( Str( nPosKey ) ) + "] , NIL , .T. )" + cOperator + "'" + AllToChar( uCntFieldsKey[ nField ] , NIL , .T. ) + "' "
					EndIF	
					IF ( nField < nFields )
						cStrBlock	+= cConCat
					EndIF
				EndIF
			Next nField
			cStrBlock += " } "
		EndIF
	EndIF

End Sequence

Return( cStrBlock )

/*/
зддддддддддбддддддддддддддддбдддддбдддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o	   ЁGdDefault		ЁAutorЁMarinaldo de Jesus Ё Data Ё20/12/2004Ё
цддддддддддеддддддддддддддддадддддадддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁReinicializa os Valores dos Campos em aCols               	Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁNIL                      									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso	   ЁGenerica      										    	Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function GdDefault( uDefaultCpo , cAlias , aHeader , aCols , nLine , lInitPad )

Local aNewCols

Local bInitPad

Local cInitPad

Local nField
Local nLoop
Local nLoops
Local nPosAlias

Local uInitPad

Begin Sequence

	DEFAULT uDefaultCpo := "ALLCPOS"

	IF Empty( aHeader )
		IF Empty( cAlias )
			Break
		EndIF
		cAlias	:= Upper( AllTrim( cAlias ) )
		aHeader	:= GdAllFields( cAlias )
	EndIF

	IF Empty( aHeader )
		Break
	EndIF

	DEFAULT aCols	    := {}
	DEFAULT lInitPad	:= .T.

	IF ( ValType( uDefaultCpo ) == "C" )
		IF ( uDefaultCpo == "ALLCPOS" )
			aNewCols := GdRmkaCols(	aHeader 		,;	//Array com a Estrutura para criacao do aCols
									.F.				,;	//Estado do Elemento de Delecao no aCols
									.T.				,;	//Se existe o Elemento de Delecao
									lInitPad		 ;	//Se deve carregar os inicializadores padroes
								  )
			IF Empty( aCols )
				aCols := aClone( aNewCols )
			Else
				aEval( aCols , { |aColsElem| aColsElem := aClone( aNewCols ) } )
			EndIF	
		ElseIF ( ( nField := GdFieldPos( uDefaultCpo , aHeader ) ) > 0 )
			IF (;
					( lInitPad );
					.and.;
					!Empty( cInitPad := aHeader[ nField , __AHEADER_INITPAD__ ] );
				)	
				bInitPad	:= __ExecMacro( " { || uInitPad := " + cInitPad + " } " )
				IF !CheckExecForm( bInitPad , .F. )
					uInitPad := GetValType( aHeader[ nField , __AHEADER_TYPE__ ] , aHeader[ nField , __AHEADER_WIDTH__ ] )
				EndIF
			Else
				uInitPad := GetValType( aHeader[ nField , __AHEADER_TYPE__ ] , aHeader[ nField , __AHEADER_WIDTH__ ] )
			EndIF
			IF (;
					!Empty( nLine );
					.and.;
					( nLine <= Len( aCols ) ); 
				)	
				aCols[ nLine , nField ] := uInitPad
			Else
				aEval( aCols , { |aColsElem| aColsElem[ nField ] := uInitPad } )
			EndIF	
		EndIF
    ElseIF ( ValType( uDefaultCpo ) == "A" )
		nLoops := Len( uDefaultCpo )
		For nLoop := 1 To nLoops
			IF ( ( nField := GdFieldPos( uDefaultCpo[ nLoop ] , aHeader ) ) > 0 )
				IF (;
						( lInitPad );
						.and.;
						!Empty( cInitPad := aHeader[ nField , __AHEADER_INITPAD__ ] );
					)	
					bInitPad	:= __ExecMacro( " { || uInitPad := " + cInitPad + " } " )
					IF !CheckExecForm( bInitPad , .F. )
						uInitPad := GetValType( aHeader[ nField , __AHEADER_TYPE__ ] , aHeader[ nField , __AHEADER_WIDTH__ ] )
					EndIF
				Else
					uInitPad := GetValType( aHeader[ nField , __AHEADER_TYPE__ ] , aHeader[ nField , __AHEADER_WIDTH__ ] )
				EndIF
				IF (;
						!Empty( nLine );
						.and.;
						( nLine <= Len( aCols ) );
					)	
					aCols[ nLine , nField ] := uInitPad
				Else
					aEval( aCols , { |aColsElem| aColsElem[ nField ] := uInitPad } )
				EndIF
			EndIF
		Next nLoop
    EndIF

End Sequence

Return( NIL )

/*/
зддддддддддбддддддддддддддддбдддддбдддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o	   ЁGdQueryCond		ЁAutorЁMarinaldo de Jesus Ё Data Ё20/12/2004Ё
цддддддддддеддддддддддддддддадддддадддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁRetorna aQueryCond para uso na GdBuildCols/GdMontaCols		Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁNIL                      									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso	   ЁGenerica      										    	Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function GdQueryCond( cAlias , uCposWhere , uCntsWhere , aHeader )

Local aQueryCond
Local aCposInfo

Local cCpoWhere
Local cTypeCposWhere
Local cTypeCntsWhere

Local lTypeCDM

Local nGdPosCpo
Local nField
Local nFields

Begin Sequence

	IF Empty( aCposWhere )
		Break
	EndIF

	IF (;
			( ( cTypeCposWhere := ValType( uCposWhere ) ) == "A" );
			.and.;
			( ( cTypeCntsWhere := ValType( uCntsWhere ) ) == "A" );
			.and.;
			!( Len( uCposWhere ) == Len( uCntsWhere ) );
		)
		Break
	EndIF

	IF Empty( cAlias )
		Break
	EndIF
	cAlias	:= Upper( AllTrim( cAlias ) )

	IF !( cTypeCposWhere $ "C/A" )
		Break
	EndIF

	DEFAULT aHeader := {}

	IF ( cTypeCposWhere == "C" )
		cCpoWhere	:= Upper( AllTrim( uCposWhere ) )
		IF ( AliasCpo( cCpoWhere ) <> cAlias )
			Break
		EndIF
		nGdPosCpo := GdFieldPos( cCpoWhere , aHeader )
		IF ( nGdPosCpo == 0 )
			aCposInfo		:= PosAlias( "SX3" , cCpoWhere , NIL , { "X3_CONTEXT" , "X3_TYPE" , "X3_PICTURE" } , 2 , .F. )
		Else
			aCposInfo		:= Array( 3 )
			aCposInfo[1]	:= PosAlias( "SX3" , cCpoWhere , NIL , "X3_CONTEXT" , 2 , .F. )
			aCposInfo[2]	:= aHeader[ nGdPosCpo , __AHEADER_TYPE__	]
			aCposInfo[3]	:= aHeader[ nGdPosCpo , __AHEADER_PICTURE__ ]
		EndIF	
		IF (;
				Empty( aCposInfo );
				.or.;
				( aCposInfo[1] $ "Vv" );
			)	
			Break
		EndIF
		lTypeCDM		:= ( aCposInfo[2] $ "C/D/M" )
		aQueryCond		:= Array( 3 )
		aQueryCond[1]	:= cTypeCposWhere + "=" + IF( lTypeCDM , "'" , "" ) + AllToChar( uCntsWhere , aCposInfo[3] , .T. ) + IF( lTypeCDM , "'" , "" )
		aQueryCond[2]	:= " AND "
		aQueryCond[3]	:= "D_E_L_E_T_ = ' ' "
	ElseIF ( cTypeCposWhere == "A" )
		aQueryCond	:= {}
		nFields		:= Len( uCposWhere )
		nQueryCond	:= 0
		For nField := 1 To nFields
			cCpoWhere	:= uCposWhere[ nField ]
			IF (;
					Empty( cCpoWhere );
					.or.;
					(;
						cCpoWhere := Upper( AllTrim( cCpoWhere ) ),;
						( AliasCpo( cCpoWhere ) <> cAlias );
					);	
				)
				Loop
			EndIF
			nGdPosCpo	:= GdFieldPos( cCpoWhere , aHeader )
			IF ( nGdPosCpo == 0 )
				aCposInfo		:= PosAlias( "SX3" , cCpoWhere , NIL , { "X3_CONTEXT" , "X3_TYPE" , "X3_PICTURE" } , 2 , .F. )
			Else
				aCposInfo		:= Array( 3 )
				aCposInfo[1]	:= PosAlias( "SX3" , cCpoWhere , NIL , "X3_CONTEXT" , 2 , .F. )
				aCposInfo[2]	:= aHeader[ nGdPosCpo , __AHEADER_TYPE__	]
				aCposInfo[3]	:= aHeader[ nGdPosCpo , __AHEADER_PICTURE__ ]
			EndIF	
			IF (;
					Empty( aCposInfo );
					.or.;
					( aCposInfo[1] $ "Vv" );
				)	
				Loop
			EndIF
			lTypeCDM	:= ( aCposInfo[2] $ "C/D/M" )
			aAdd( aQueryCond , cTypeCposWhere + "=" + IF( lTypeCDM , "'" , "" ) + AllToChar( uCntsWhere , aCposInfo[3] , .T. ) + IF( lTypeCDM , "'" , "" ) )
			IF ( nField < nFields )
				aAdd( aQueryCond , " AND " )
			EndIF
		Next nField
		IF !Empty( aQueryCond )
			IF ( AllTrim( aQueryCond[ Len( aQueryCond ) ] ) <> "AND" )
				aAdd( aQueryCond , " AND " )
			EndIF	
		EndIF
		aAdd( aQueryCond , "D_E_L_E_T_ = ' ' " )
	EndIF

End Sequence

Return( aQueryCond )

/*/
зддддддддддбдддддддддддддбдддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁGdVldFields	 ЁAutorЁMarinaldo de Jesus    Ё Data Ё14/02/2005Ё
цддддддддддедддддддддддддадддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁExecutar as Funcoes de Validacao de Campos na LinhaOk da GetЁ
Ё          ЁDados														Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁValidacao da LinhaOk na GetDados							Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function GdVldFields( aHeader )

Local lGdFieldsOk	:= .T.

Local bVldFields

Local cVldSys
Local cVldUsr

Local nField
Local nFields

Begin Sequence

	IF Empty( aHeader )
		Break
	EndIF

	nFields := Len( aHeader )
	For nField := 1 To nFields

		cVldSys := aHeader[ nField , __AHEADER_VALID__	]
		cVldUsr	:= aHeader[ nField , __AHEADER_VLDUSR__	]

		IF (;
				!Empty( cVldSys );
				.and.;
				!Empty( cVldUsr );
			)	
			bVldFields := "{ || "
			bVldFields += cVldSys
			bVldFields += ".and."
			bVldFields += cVldUsr
			bVldFields += "}"
		ElseIF (;
					!Empty( cVldSys );
					.and.;
					Empty( cVldUsr );
				)	
				bVldFields := "{ || "
				bVldFields += cVldSys
				bVldFields += "}"
		ElseIF (;
					Empty( cVldSys );
					.and.;
					!Empty( cVldUsr );
				)
			bVldFields := "{ || "
			bVldFields += cVldUsr
			bVldFields += "}"
		Else
			Loop
		EndIF

		bVldFields 	:= __ExecMacro( bVldFields )

		lGdFieldsOk	:= Eval( bVldFields )

		IF !( lGdFieldsOk )
			Break
		EndIF

	Next nField

End Sequence

Return( lGdFieldsOk )




/*/
зддддддддддбддддддддддддддбдддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFuncao    ЁGDMontaCols   ЁAutorЁRogerio Ribeiro	  Ё Data Ё05/01/2007Ё
цддддддддддеддддддддддддддадддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescricao ЁMontar Array de Dados da GetDados                           Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё															Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ															Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁaCols 														Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGenerico  	                                                Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁObs       Ё bSkip pode ser um array ou um bloco de codigo, exemplos:   Ё
Ё          Ё Bloco de cod. - {|| XXX <> YYY}  	                        Ё
Ё          Ё Array - {{{|| XXX <> YYY}, {|| .T.}, {|| .F.}},            Ё 
Ё          Ё {bCond2, bTrue2, bFalse2},... {bCondN, bTrueN, bFalseN}}   Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function GDMontaCols(	aHeader			,;	//01 -> Array com os Campos do Cabecalho da GetDados
						nUsado			,;	//02 -> Numero de Campos em Uso
						aVirtual		,;	//03 -> [@]Array com os Campos Virtuais
						aVisual			,;	//04 -> [@]Array com os Campos Visuais
						cAlias			,;	//05 -> Opcional, Alias do Arquivo Carga dos Itens do aCols
						aNotFields		,;	//06 -> Opcional, Campos que nao Deverao constar no aHeader
						aRecnos			,;	//07 -> [@]Array unidimensional contendo os Recnos
						cAliasPai   	,;	//08 -> Alias do Arquivo Pai
						cKey			,;	//09 -> Chave para o Posicionamento no Alias Filho
						bKey			,;	//10 -> Bloco para condicao de Loop While
						bSkip			,;	//11 -> Bloco para Skip no Loop While Atencao - Veja obs acima
						lDeleted		,;	//12 -> Se Havera o Elemento de Delecao no aCols 
						lCriaPub		,;	//13 -> Se cria variaveis Publicas
						lInitPad		,;	//14 -> Se Sera considerado o Inicializador Padrao
						cLado			,;	//15 -> Lado para o inicializador padrao
						lAllFields		,;	//16 -> Opcional, Carregar Todos os Campos
						lNotVirtual 	,;	//17 -> Opcional, Nao Carregar os Campos Virtuais
						uQueryCond		,;	//18 -> Opcional, Utilizacao de Query para Selecao de Dados
						lTopExebKey		,;	//19 -> Opcional, Se deve Executar bKey  ( Apenas Quando TOP )
						lTopExebSkip	,;	//20 -> Opcional, Se deve Executar bSkip ( Apenas Quando TOP )
						uGhostBmpCol	,;	//21 -> Carregar Coluna Fantasma e/ou BitMap ( Logico ou Array )
						lOnlyNotFields	,;	//22 -> Inverte a Condicao de aNotFields carregando apenas os campos ai definidos
						lChkX3Uso		,;	//23 -> Verifica se Deve Checar se o campo eh usado
						lChkNivel		,;	//24 -> Verifica se Deve Checar o nivel do usuario
						lPutEmpyaCols	,;	//25 -> Verifica se Deve Carregar o Elemento Vazio no aCols
						aKeyCodes		,;	//26 -> [@]Array que contera as chaves conforme recnos
						lLockRecnos		,;	//27 -> [@]Se devera efetuar o Lock dos Registros
						lUseCode		,;	//28 -> [@]Se devera obter a Exclusividade nas chaves dos registros
						nMaxLocks		,;	//29 -> Numero maximo de Locks a ser efetuado
						lNumGhostCol	,;	//30 -> Utiliza Numeracao na GhostCol
						lCposUser		,;	//31 -> Carrega os Campos de Usuario
						nOpcx			,;	//32 -> Numero correspondente a operaГЦo a ser executada, exemplo: 3 - inclusao, 4 alteracaЦo e etc;
						lEmpty			;	//33 -> 
					)
					
	Local aRows:= GDBuildCols(	@aHeader,;				//01
								@nUsado,;				//02
								@aVirtual,;				//03
								@aVisual,;				//04
								@cAlias,;				//05
								@aNotFields,;			//06
								@aRecnos,;				//07
								@cAliasPai,;			//08
								@cKey,;					//09
								@bKey,;					//10
								@bSkip,;				//11
								@lDeleted,;				//12
								@lInitPad,;				//13
								@lAllFields,;			//14
								@lNotVirtual,;			//15
								@uQueryCond,;			//16
								@lTopExebKey,;			//17
								@lTopExebSkip,;			//18
								@uGhostBmpCol,;			//19
								@lOnlyNotFields,;		//20
								@lChkX3Uso,;			//21
								@lChkNivel,;			//22
								@lPutEmpyaCols,;		//23
								@aKeyCodes,;			//24
								@lLockRecnos,;			//25
								@lUseCode,;				//26
								@nMaxLocks,;			//27
								@lNumGhostCol,;			//28
								@lCposUser,;			//29
								NIL,;					//30
								@nOpcx,;				//31								
								lEmpty)					//32								
Return aRows

/*/
зддддддддддбддддддддддддддбдддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFuncao    ЁGDBuildCols   ЁAutorЁRogerio Ribeiro	  Ё Data Ё05/01/2007Ё
цддддддддддеддддддддддддддадддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescricao ЁMontar Array de Dados da GetDados                           Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё															Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ															Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁaCols 														Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGenerico  	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function GDBuildCols(	aHeaderRef		,;	//01 -> Array com os Campos do Cabecalho da GetDados
						nUsado			,;	//02 -> Numero de Campos em Uso
						aVirtual		,;	//03 -> [@]Array com os Campos Virtuais
						aVisual			,;	//04 -> [@]Array com os Campos Visuais
						cAlias			,;	//05 -> Opcional, Alias do Arquivo Carga dos Itens do aCols
						aNotFields		,;	//06 -> Opcional, Campos que nao Deverao constar no aHeader
						aRecnos			,;	//07 -> [@]Array unidimensional contendo os Recnos
						cAliasPai   	,;	//08 -> Alias do Arquivo Pai
						cKey			,;	//09 -> Chave para o Posicionamento no Alias Filho
						bKey			,;	//10 -> Bloco para condicao de Loop While
						bSkip			,;	//11 -> Bloco CСdigo ou Array para Skip no Loop While
						lDeleted		,;	//12 -> Se Havera o Elemento de Delecao no aCols 
						lInitPad		,;	//13 -> Se Sera considerado o Inicializador Padrao
						lAllFields		,;	//14 -> Opcional, Carregar Todos os Campos
						lNotVirtual 	,;	//15 -> Opcional, Nao Carregar os Campos Virtuais
						uQueryCond		,;	//16 -> Opcional, Utilizacao de Query para Selecao de Dados
						lTopExebKey		,;	//17 -> Opcional, Se deve Executar bKey  ( Apenas Quando TOP )
						lTopExebSkip	,;	//18 -> Opcional, Se deve Executar bSkip ( Apenas Quando TOP )
						uGhostBmpCol	,;	//19 -> Carregar Coluna Fantasma e/ou BitMap ( Logico ou Array )
						lOnlyNotFields	,;	//20 -> Inverte a Condicao de aNotFields carregando apenas os campos ai definidos
						lChkX3Uso		,;	//21 -> Verifica se Deve Checar se o campo eh usado
						lChkNivel		,;	//22 -> Verifica se Deve Checar o nivel do usuario
						lPutEmpyaCols	,;	//23 -> Verifica se Deve Carregar o Elemento Vazio no aCols
						aKeyCodes		,;	//24 -> [@]Array que contera as chaves conforme recnos
						lLockRecnos		,;	//25 -> [@]Se devera efetuar o Lock dos Registros
						lUseCode		,;	//26 -> [@]Se devera obter a Exclusividade nas chaves dos registros
						nMaxLocks		,;	//27 -> Numero maximo de Locks a ser efetuado
						lNumGhostCol	,;	//28 -> Utiliza Numeracao na GhostCol
						lCposUser		,;	//29 -> Carrega os Campos de Usuario
						lExecTopQry		,;	//30 -> Se deve executar a Query para TOP - se estiver como .F. trata como DBF
						nOpcx			,;	//31 -> Numero correspondente a operaГЦo a ser executada, exemplo: 3 - inclusao, 4 alteracaЦo e etc;					
						lEmpty			,;	//32 -> Numero correspondente a operaГЦo a ser executada, exemplo: 3 - inclusao, 4 alteracaЦo e etc;
						cIndKey			,;	//33 -> Chave cKey passada como caracter para retornar a ordem a ser pesquisada no alias
						nModMile		)	//34 -> Caso a chamada tenha sido via integraГЦo Mile, recebe o modulo 7 como padrЦo.			

	Local aArea:= GetArea()
	Local aAliasArea
	Local aHeaderAux:= NIL
	Local aColsAux	:= NIL
	Local lRestoreH:= .F.
	Local lRestoreC:= .F.
	Local aYesFields
	Local bAfterHeader
	Local aRows:= {}
	Local nIndexOrd
	Local cIndexKey
	Local cQuery
	Local bSeekFor:= IIF(bSkip != NIL, If(ValType(bSkip) == "A" ,bSkip ,{||Eval(bSkip) == .F.}), NIL)
	Local cAliasQuery
 
	Default cAlias			:= Alias()
	Default cAliasPai		:= Alias()
	Default aHeaderRef 		:= {}
	Default nUsado			:= 0
	Default aVirtual		:= {}
	Default aVisual			:= {}
	Default aNotFields		:= {}
	Default aRecnos 		:= {}
	Default cKey			:= ( cAliasPai )->( __ExecMacro( IndexKey() ) )
	Default bKey			:= { || SubStr( (cAlias)->(__ExecMacro(cIndexKey)) , 1 , Len( cKey ) )}
	Default lDeleted		:= .T.	
	Default lInitPad		:= .T.
	Default lAllFields		:= .F.
	Default lNotVirtual		:= .F.
	Default	lCposUser		:= .F.	
	Default uQueryCond		:= {}
	Default lTopExebKey		:= .T.
	Default lTopExebSkip	:= .T.
	Default uGhostBmpCol	:= .F.
	Default lOnlyNotFields	:= .F.
	Default lOnlyNotFields	:= .F.
	Default lChkX3Uso		:= .T.
	Default lChkNivel		:= .T.
	Default lPutEmpyaCols	:= .T.
	Default lLockRecnos		:= .F.
	Default lUseCode		:= .F.
	Default nMaxLocks		:= GetAdsLckRec()
	Default lNumGhostCol	:= .F.
	Default lExecTopQry		:= .T.
	Default cIndKey			:= "NIL"
	If cIndKey <> "NIL"
		(cAlias)->(dbSetOrder(RetOrder(cAlias , cIndKey))) // ORDENA PELO INDICE ESPECIFICADO
	EndIf
	Default nOpcx			:= IIF( (cAlias)->(dbSeek(cKey)) , 4, 3)
	Default lEmpty			:= NIL
	Default nModMile		:= nModulo

	If (Type("aHeader") != "U")
		If aHeaderRef != aHeader
			lRestoreH:= .T.
			aHeaderAux:= AClone(aHeader)
		EndIf
	EndIf
	
	If (Type("aCols") != "U")
		lRestoreC:= .T.
		aColsAux:= AClone(aCols)
	EndIf

	Begin Sequence
		nIndexOrd	:= (cAlias)->(IndexOrd())
		cIndexKey	:= (cAlias)->(Upper(AllTrim(IndexKey())))
		nUsado 		:= Len(aHeaderRef)
		cAliasQuery	:= cAlias
	
		If (Empty(aHeaderRef) .OR. (nUsado == 0 )) 
			aYesFields:= GDBuildYesFields(	cAlias			,;	//01 -> Opcional, Alias do Arquivo Para Montagem do aHeader
											aNotFields		,;	//02 -> Opcional, Campos que nao Deverao constar no aHeader
											lAllFields		,;	//03 -> Opcional, Carregar Todos os Campos
											lNotVirtual 	,;	//04 -> Nao Carrega os Campos Virtuais
											lOnlyNotFields	,;	//05 -> Inverte a Condicao de aNotFields carregando apenas os campos ai definidos
											lChkX3Uso		,;	//06 -> Verifica se Deve Checar se o campo eh usado
											lChkNivel		,;	//07 -> Verifica se Deve Checar o nivel do usuario
											lCposUser		,;	//08 -> Carrega os Campos de Usuario
											nModMile		)	//09 -> Modulo a ser usado quando chamada da funГЦo partir do Mile.	
											
		Else
			aYesFields:= GDGetYesFields(aHeaderRef)
		EndIf
		     
		If (Len(aYesFields) == 0)
			Break
		EndIF

#IFDEF TOP
		cQuery:= GDBuildQuery(cAlias, aYesFields, uQueryCond, lExecTopQry)
		lChkFile	:= ( !( lNotVirtual ) .or. ( lInitPad ) )   
		
		If cQuery != NIL
			aAliasArea:= (cAlias)->(GetArea())

			( cAliasQuery )->( dbCloseArea() )
			cAliasQuery := ( "QRY" + cAliasQuery )
	  	EndIf
#ENDIF

		bAfterHeader := {|aHeaderPar|	GDAfterHeader(	aHeaderPar,		; 
														aYesFields,		;
														cAlias,			;
														lNotVirtual,	; 
														uGhostBmpCol,	;
														lNumGhostCol	;
												  );
						}
						
  		bCriaVar := {|cField| CriaVarRH(	cField		,;
  											lInitPad	,;
  											aHeaderRef	;  											
  										); 										
  					}
  					
 					
		aHeaderRef:= {}
			
		FillGetDados(	nOpcx				,; //1-nOpcx - numero correspondente Ю operaГЦo a ser executada, exemplo: 3 - inclusЦo, 4 alteraГЦo e etc;
						cAlias				,; //2-cAlias - area a ser utilizada;
						nIndexOrd			,; //3-nOrder - ordem correspondente a chave de indice para preencher o  acols;
						cKey				,; //4-cSeekKey - chave utilizada no posicionamento da area para preencher o acols;
						bKey				,; //5-bSeekWhile - bloco contendo a expressЦo a ser comparada com cSeekKey na condiГЦo  do While.
						bSeekFor			,; //6-uSeekFor - pode ser utilizados de duas maneiras:1- bloco-de-cСdigo, condiГЦo a ser utilizado para executar o Loop no While;2╨ - array bi-dimensional contendo N.. condiГУes, em que o 1╨ elemento И o bloco condicional, o 2╨ И bloco a ser executado se verdadeiro e o 3╨ И bloco a ser executado se falso, exemplo {{bCondicao1, bTrue1, bFalse1}, {bCondicao2, bTrue2, bFalse2}.. bCondicaoN, bTrueN, bFalseN};
						NIL					,; //7-aNoFields - array contendo os campos que nЦo estarЦo no aHeader;
						aYesFields			,; //8-aYesFields - array contendo somente os campos que estarЦo no aHeader;
						NIL					,; //9-lOnlyYes - se verdadeiro, exibe apenas os campos de usuАrio;
						cQuery				,; //10-cQuery - query a ser executada para preencher o acols(Obs. Nao pode haver MEMO);
						NIL					,; //11-bMontCols - bloco contendo funГЦo especifica para preencher o aCols; Exmplo:{|| MontaAcols(cAlias)}
						lEmpty				,; //12-lEmpty
						aHeaderRef			,; //13-aHeaderAux
						aRows				,; //14-aColAux
						NIL					,; //15-bAfterCols - Bloco de codigo a ser executado apСs a inclusЦo de uma linha no Acols
						NIL					,; //16-bBeforeCols - Bloco de codigo contendo expressЦo para sair do While, И executado antes de inserir nova linha no aCols
						bAfterHeader		,; //17-bAfterHeader - Bloco de codigo a ser executado apСs o preenchimento do aheader com os campos padrЦo e antes de incluir os campos reservados para o WalkThru. Ex: {|aHeader| AlterHeader(aHeader) }
						cAliasQuery			,; //18-cAliasQry
						bCriaVar			 ; //19-bCriaVar
					)

#IFDEF TOP
		If cQuery != NIL
			ChkFile( cAlias )
			RestArea(aAliasArea)
		EndIf
#ENDIF
		GDResizeWTColumns(@aHeaderRef)

		If !lPutEmpyaCols
			GDRemoveEmptyRows(@aHeaderRef, @aRows)
		EndIf
					  
	   	aRecNos:= GDGetRecNos(aHeaderRef, aRows)
		aKeyCodes:= GDGetKeyCodes(	cAlias,				;
									aHeaderRef,			;
									aRows,	  			;
									cIndexKey)
				  
		If lLockRecnos
			If !GDLockRows(	cAlias			,;	//01 -> Alias para Lock
							@aRecNos		,;	//02 -> [@] Array com os Recnos para Lock
							@aKeyCodes		,;	//03 -> [@] Array com os Registros (Codigos) a Serem reservados							
							@lLockRecNos	,;	//04 -> Se Havera Lock dos Recnos
							@lUseCode		,;	//05 -> Se Havera Reserva do Registro (Codigo)
							nMaxLocks		,;	//06 -> Numero Maximo de Locks)
							(cQuery!= NIL)	;	//07 -> Se foi utilizada query TopConnect ou tratado como DBF
						   )
				aRows:= {}
				aRecNos:= {}
				aKeyCodes:= {}
	   		EndIf
		EndIf
			  
		nUsado := Len(aHeaderRef)
		aVirtual:= GDGetVirtualFields(aHeaderRef)
		aVisual:= GDGetVisualFields(aHeaderRef)
	End Sequence

	If lRestoreH; aHeader:= AClone(aHeaderAux); EndIf	
	If lRestoreC; aCols:= AClone(aColsAux);	 EndIf
	
	RestArea(aArea)
Return aRows


/*/
зддддддддддбддддддддддддддддддбдддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFuncao    |GDGetVirtualFieldsЁAutorЁRogerio Ribeiro	  Ё Data Ё05/01/2007Ё
цддддддддддеддддддддддддддддддадддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescricao ЁRecupera lista de campos virtuais.								Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё																Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ																Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁArray com os nomes dos campos virtuais.							Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁRHLIBGD															Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function GDGetVirtualFields(aHeader)
	Local nx
	Local aVirtual:= {}

	For nx := 1 To Len(aHeader)//nTotal
		If aHeader[nx][__AHEADER_CONTEXT__] $ "Vv"
			AAdd(aVirtual, aHeader[nx, __AHEADER_FIELD__])
		EndIf
	Next nx
Return aVirtual


/*/
зддддддддддбддддддддддддддддддбдддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFuncao    |GDGetVisualFields ЁAutorЁRogerio Ribeiro	  Ё Data Ё05/01/2007Ё
цддддддддддеддддддддддддддддддадддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescricao ЁRecupera lista de campos visuais.								Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё																Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ																Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁArray com os nomes dos campos visuais.	 						Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁRHLIBGD															Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function GDGetVisualFields(aHeader)
	Local nx
	Local aVisual:= {}
	Local nTotal:= aScan(aHeader , { |aColumns| IsHeadRec(aColumns[__AHEADER_FIELD__]) } ) - 2

	If (nTotal <= 0)
		nTotal:= Len(aHeader)
	EndIf
	
	For nx := 1 To nTotal
		If aHeader[nx][__AHEADER_VISUAL__] == "V"
			AAdd(aVisual, aHeader[nx, __AHEADER_FIELD__])
		EndIf
	Next nx
Return aVisual

#IFDEF TOP
/*/
зддддддддддбддддддддддддддддддбдддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFuncao    |GDBuildQuery	  ЁAutorЁRogerio Ribeiro	  Ё Data Ё05/01/2007Ё
цддддддддддеддддддддддддддддддадддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescricao ЁFuncao que monta uma query SQL para ser passada p/ FillGetDados Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё																Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ																Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁUma query SQL valida, ou NIL	 								Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁRHLIBGD															Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function GDBuildQuery(	cAlias,	;
								aYesFields,	;
								uQueryCond,	;
								lExecTopQry ;
							  )
Local nCount
Local nFields
Local cIndexKey
Local cQuery

	If !lExecTopQry .OR. (uQueryCond == NIL) .OR. Len(uQueryCond) = 0
		Return NIL	
	EndIf
	
	nFields:= Len(aYesFields)
	cIndexKey:= (cAlias)->(Upper(AllTrim(IndexKey())))
	cQuery:= " SELECT "

	For nCount := 1 To nFields
		If !(GetSX3Cache(aYesFields[nCount], "X3_CONTEXT") $ "Vv")
			cQuery += aYesFields[nCount] + ", "	
		EndIf
	Next nCount
	
	cQuery		+= "	R_E_C_N_O_"
	cQuery 		+= " FROM "
	cQuery 		+= "	" + InitSqlName(cAlias) + " "
	cQuery += " WHERE "

	If ( ValType(uQueryCond) == "A" )
		For nCount := 1 To Len(uQueryCond)
			cQuery += uQueryCond[ nCount ] + " "
		Next nCount
	Else
		cQuery += uQueryCond
	EndIf
		
	If (At("D_E_L_E_T_", cQuery) == 0)		
		cQuery += " AND "
		cQuery += " D_E_L_E_T_ = ' ' "
	EndIf
	
	cQuery += " ORDER BY " + SqlOrder(cIndexKey)
	cQuery := ChangeQuery(cQuery)

Return cQuery
#ENDIF



/*/
зддддддддддбддддддддддддддддддбдддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFuncao    |GDGetRecNos		  ЁAutorЁRogerio Ribeiro	  Ё Data Ё05/01/2007Ё
цддддддддддеддддддддддддддддддадддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescricao ЁRecupera um array com os RecNos dos registros					Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё																Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ																Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁArray com os RecNos.	 															Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁRHLIBGD															Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function GDGetRecNos(aHeader, aRows)
	Local nx
	Local aRecNos:= {}
	Local nPosRecNo:= aScan(aHeader , { |aColumns| IsHeadRec(aColumns[__AHEADER_FIELD__]) } )
	
	If nPosRecNo != 0 
		For nx := 1 To Len(aRows)
			If (aRows[nx, nPosRecNo]!= 0)
				AAdd(aRecNos, aRows[nx, nPosRecNo])
			EndIf
		Next nx
	EndIf
Return aRecNos


/*/
зддддддддддбддддддддддддддддддбдддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFuncao    |GDGetKeyCodes	  ЁAutorЁRogerio Ribeiro	  Ё Data Ё05/01/2007Ё
цддддддддддеддддддддддддддддддадддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescricao ЁRecupera as chaves dos registros, pelo indice atual.			Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё																Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ																Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁArray com as chaves dos registros.	 															Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁRHLIBGD															Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function GDGetKeyCodes(	cAlias,		;
								aHeader,	;
								aRows,		;
								cIndexKey)

	Local nRow
	Local aKeyCodes:= {}
	Local nPosRecNo:= aScan(aHeader , { |aColumns| IsHeadRec(aColumns[__AHEADER_FIELD__]) } )
	
	If nPosRecNo != 0	
		For nRow:= 1 to Len(aRows)
			If !Empty(aRows[nRow][nPosRecNo])
				(cAlias)->(DBGoto(aRows[nRow][nPosRecNo]))
	
				aAdd(aKeyCodes, (cAlias)->( __ExecMacro( cIndexKey )) )
			Else 
				aAdd(aKeyCodes, "")
			EndIf
		Next nRow
	EndIf
	
Return aKeyCodes


/*/
зддддддддддбддддддддддддддддддбдддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFuncao    |GDGetYesFields	  ЁAutorЁRogerio Ribeiro	  Ё Data Ё05/01/2007Ё
цддддддддддеддддддддддддддддддадддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescricao ЁRecupera uma lista dos campos que deverao aparecer no GetDados.	Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё																Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ																Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁArray com o nome dos campos.	 															Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁRHLIBGD															Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function GDGetYesFields(aHeader)
	Local aYesFields:= {}
	Local nCount
	
	For nCount:= 1 to Len(aHeader)
		If aHeader[nCount, __AHEADER_FIELD__] $ "COLBMP#GHOSTCOL" .OR. "_REC_WT" $ aHeader[nCount, __AHEADER_FIELD__]  .Or. "_ALI_WT" $ aHeader[nCount,__AHEADER_FIELD__]  
			Loop	     
		EndIf
		
		AAdd(aYesFields, aHeader[nCount, __AHEADER_FIELD__])
	Next nCount
Return aYesFields


/*/
зддддддддддбддддддддддддддддддбдддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFuncao    |GDAfterHeader	  ЁAutorЁRogerio Ribeiro	  Ё Data Ё05/01/2007Ё
цддддддддддеддддддддддддддддддадддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescricao ЁMetodo executado pela fillgetdados, apos a montagem do aHeader	Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё																Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ																Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁRHLIBGD															Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function GDAfterHeader(	aHeader,		;
								aYesFields,		;
								cAlias,			;
								lNotVirtual,	;
								uGhostBmpCol,	;
								lNumGhostCol)
	GDExtendHeader(@aHeader)

	GDRecoveryHeader(@aHeader, aYesFields)
	

	If !lNotVirtual
		GDBmpColProcess(@aHeader, uGhostBmpCol)
			
		GDGhostColProcess(@aHeader, uGhostBmpCol, lNumGhostCol)
	EndIf
	
Return


/*/
зддддддддддбддддддддддддддддддбдддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFuncao    |GDBmpColProcess	  ЁAutorЁRogerio Ribeiro	  Ё Data Ё05/01/2007Ё
цддддддддддеддддддддддддддддддадддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescricao ЁVerifica se deve incluir a COLBMP e seleciona inicializ. e tam.	Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё																Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ																Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   Ё.T. se incluiu a coluna.	 									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁRHLIBGD															Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function GDBmpColProcess(aHeader, uGhostBmpCol)
	Local lAddCol:= .F.
	Local nPos
	Local cInit := "'BR_VERMELHO'"
	Local nSize := COLBMPSIZE
		
	If ( ValType( uGhostBmpCol ) == "A" )
		nPos:= aScan( uGhostBmpCol , { |x| Upper( AllTrim( x[1] ) ) == "COLBMP" } )
		lAddCol:= (nPos  > 0)
		
		If lAddCol
			If ( Len(uGhostBmpCol[nPos] ) >= 2 )
				cInit := uGhostBmpCol[nPos, 2]
			EndIf
			
			If ( Len( uGhostBmpCol[nPos] ) >= 3 )
				nSize	:= uGhostBmpCol[nPos, 3]
			EndIf		
		EndIF
	Else
		lAddCol:= .F.
	EndIF
	
	If lAddCol
		GDAddBmpColumn(@aHeader, nSize, cInit)	
	EndIf
Return lAddCol



/*/
зддддддддддбддддддддддддддддддбдддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFuncao    |GDAddBmpColumn	  ЁAutorЁRogerio Ribeiro	  Ё Data Ё05/01/2007Ё
цддддддддддеддддддддддддддддддадддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescricao ЁAjusta o tamanho do Header e insere a COLBMP na primeira posicaoЁ
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё																Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ																Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁRHLIBGD															Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function GDAddBmpColumn(aHeader, nSize, cInit)
	aSize(aHeader, Len(aHeader) + 1)
	aIns(aHeader, 1)

	aHeader[1]:= Array( __ELEMENTOS_AHEADER__ )	

	aHeader[1, __AHEADER_TITLE__	]	:= ""
	aHeader[1, __AHEADER_FIELD__	]	:= "COLBMP"
	aHeader[1, __AHEADER_PICTURE__	]	:= "@BMP"
	aHeader[1, __AHEADER_WIDTH__	]	:= nSize
	aHeader[1, __AHEADER_DEC__		]	:= 0
	aHeader[1, __AHEADER_VALID__	]	:= ""
	aHeader[1, __AHEADER_USE__		]	:= Chr(251)
	aHeader[1, __AHEADER_TYPE__		]	:= "C"
	aHeader[1, __AHEADER_F3__		]	:= ""
	aHeader[1, __AHEADER_CONTEXT__	]	:= "V"
	aHeader[1, __AHEADER_CBOX__		]	:= ""
	aHeader[1, __AHEADER_INITPAD__	]	:= cInit
	aHeader[1, __AHEADER_WHEN__		]	:= ""
	aHeader[1, __AHEADER_VISUAL__	]	:= "V"
	aHeader[1, __AHEADER_VLDUSR__	]	:= ""
	aHeader[1, __AHEADER_RESERV16__	]	:= ""
	aHeader[1, __AHEADER_RESERV17__	]	:= .F.
Return


/*/
зддддддддддбддддддддддддддддддбдддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFuncao    |GDGhostColProcess ЁAutorЁRogerio Ribeiro	  Ё Data Ё05/01/2007Ё
цддддддддддеддддддддддддддддддадддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescricao ЁVerifica se deve incluir a GHOSTCOL e seleciona inic. e tam.	Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё																Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ																Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   Ё.T. se incluiu a coluna.	 									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁRHLIBGD															Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function GDGhostColProcess(aHeader, uGhostBmpCol, lNumGhostCol)
	Local lAddCol
	Local nPos
	Local cGhostInit	:= ""
	Local nGhostSize	:= 0
	
	If (ValType( uGhostBmpCol ) == "L")
		lAddCol:= uGhostBmpCol

		If lNumGhostCol
			cGhostInit	:= "GdNumItem('GHOSTCOL')"
			nGhostSize	:= GHOSTCOLSIZE
		EndIF
	ElseIf (ValType(uGhostBmpCol) == "A")
		nPos := aScan( uGhostBmpCol , { |x| Upper( AllTrim( x[1] ) ) == "GHOSTCOL" } )
		lAddCol	:= (nPos> 0) 
		
		If lAddCol
			If (Len(uGhostBmpCol[nPos] ) >= 2 )
				cGhostInit	:= uGhostBmpCol[nPos , 2]
			Else
				If lNumGhostCol
					cGhostInit	:= "GdNumItem('GHOSTCOL')"
				EndIf
			EndIF

			If ( Len( uGhostBmpCol[nPos] ) >= 3 )
				nGhostSize	:= uGhostBmpCol[nPos , 3 ]
			Else			
				If lNumGhostCol
					nGhostSize	:= GHOSTCOLSIZE			
				EndIf
			EndIF
		EndIf	
	Else
		lAddCol	:= .F.	
	EndIf
	
	If (lAddCol)
		GDAddGhostColumn(@aHeader, nGhostSize, cGhostInit)	
	EndIf
Return lAddCol


/*/
зддддддддддбддддддддддддддддддбдддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFuncao    |GDAddGhostColumn  ЁAutorЁRogerio Ribeiro	  Ё Data Ё05/01/2007Ё
цддддддддддеддддддддддддддддддадддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescricao ЁAjusta o tamanho do Header e insere a GHOSTCOL.					Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё																Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ																Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   Ё	 															Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁRHLIBGD															Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function GDAddGhostColumn(aHeader, nSize, cInit)	
	Local nPos:= aScan( aHeader , { |aColumns| IsHeadRec(aColumns[__AHEADER_FIELD__]) } ) - 1
	aSize(aHeader, Len(aHeader) + 1)
	
	If (nPos <=0)
		nPos:= Len(aHeader)
	EndIf
	
	aIns(aHeader, nPos)
	

	aHeader[nPos]:= Array( __ELEMENTOS_AHEADER__ )	
	aHeader[nPos , __AHEADER_TITLE__	]	:= ""
	aHeader[nPos , __AHEADER_FIELD__	]	:= "GHOSTCOL"
	aHeader[nPos , __AHEADER_PICTURE__	]	:= ""
	aHeader[nPos , __AHEADER_WIDTH__	]	:= nSize
	aHeader[nPos , __AHEADER_DEC__		]	:= 0
	aHeader[nPos , __AHEADER_VALID__	]	:= ""
	aHeader[nPos , __AHEADER_USE__		]	:= Chr(251)
	aHeader[nPos , __AHEADER_TYPE__		]	:= "C"
	aHeader[nPos , __AHEADER_F3__		]	:= ""
	aHeader[nPos , __AHEADER_CONTEXT__	]	:= "V"
	aHeader[nPos , __AHEADER_CBOX__		]	:= ""
	aHeader[nPos , __AHEADER_INITPAD__	]	:= cInit
	aHeader[nPos , __AHEADER_WHEN__		]	:= ""
	aHeader[nPos , __AHEADER_VISUAL__	]	:= "V"
	aHeader[nPos , __AHEADER_VLDUSR__	]	:= ""
	aHeader[nPos , __AHEADER_RESERV16__	]	:= ""
	aHeader[nPos , __AHEADER_RESERV17__	]	:= .F.
Return


/*/
зддддддддддбддддддддддддддддддбдддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFuncao    |GDBuildYesFields  ЁAutorЁRogerio Ribeiro	  Ё Data Ё05/01/2007Ё
цддддддддддеддддддддддддддддддадддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescricao ЁMonta uma lista de campos que serao passados para o fillGetDadosЁ
Ё		   Ёutilizando como regra os parametros recebidos					Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё																Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ																Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁArray com os nomes dos campos									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁRHLIBGD															Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function GDBuildYesFields(	cAlias			,;	//01 -> Opcional, Alias do Arquivo Para Montagem do aHeader
									aNotFields		,;	//02 -> Opcional, Campos que nao Deverao constar no aHeader
									lAllFields		,;	//03 -> Opcional, Carregar Todos os Campos
									lNotVirtual 	,;	//04 -> Nao Carrega os Campos Virtuais
									lOnlyNotFields	,;	//05 -> Inverte a Condicao de aNotFields carregando apenas os campos ai definidos
									lChkX3Uso		,;	//06 -> Verifica se Deve Checar se o campo eh usado
									lChkNivel		,;	//07 -> Verifica se Deve Checar o nivel do usuario
					  				lCposUser		,;	//08 -> Carrega os Campos de Usuario
					  				nModMile		)	//09 -> Modulo a ser usado quando chamada da funГЦo partir do Mile.	
	
	Local aAreaSX3			:= SX3->( GetArea() )
	Local aHeader			:= {}
	Local bNotFields		:= { |cCpo| ( cCpo == cCampo ) }
	Local lUsuario			:= .F.
	Local cCampo
	Local cX3cBox
	Local cX3Titulo
	Local lAddFields
	Local lUsado
	Local lGhostCol
	Local lColBmp
	Local nSx3Recno
	Local nSx3NextRecno
	Local nGhostSize
	Local nBitMapSize
	Local nUsado			:= 0
	
	Default cAlias			:= Alias()
	Default aNotFields		:= {}
	Default lAllFields		:= .F.
	Default lNotVirtual		:= .F.
	Default lOnlyNotFields	:= .F.
	Default lChkX3Uso		:= .T.
	Default lChkNivel		:= .T.
	Default lCposUser		:= .T.
	Default nModMile		:= nModulo
	
	cNivel	:= IF( Type("cNivel") == "U" , "9" , cNivel )
	cAlias	:= Upper( AllTrim( cAlias ) )
	
	SX3->( dbSetOrder( 1 ) )
	IF SX3->( dbSeek( cAlias , .F. ) )
		While SX3->( !Eof() .and. Upper( AllTrim( X3_ARQUIVO ) ) == cAlias )
			IF !GetNextRecno( "SX3" , @nSx3NextRecno , @nSx3Recno , 1 )
				Exit
			EndIF
			
			cCampo := Upper( AllTrim( SX3->X3_CAMPO ) )
			IF ( lChkX3Uso )
				lUsado		:= SX3->(X3Uso(X3_USADO, nModMile))
				IF !GotoNextRecno( "SX3" , nSx3Recno , 1 )
					Exit
				EndIF
			EndIF
			
			IF ( lCposUser )
				lUsuario := ( SX3->X3_PROPRI $ "uU" )
			EndIF
			
			lAddFields	:= SX3->(;
									( lAllFields );
									.or.;
									(;
										IF( lOnlyNotFields ,;
												(;
													( aScan( aNotFields , bNotFields ) > 0 );
													.or.;
													( lUsuario );
												),;	
												( aScan( aNotFields , bNotFields ) == 0 ) ;
										   );
										.and.;
										IF( lChkX3Uso , lUsado , .T. );
										.and.;
										IF( !CpoObrigat( cCampo ) , IF( lChkNivel , ( cNivel >= X3_NIVEL ) , .T. ) , .T. );
									);
								)
			
			If !( lAddFields )
				IF !GotoNextRecno( "SX3" , nSx3NextRecno , 1 )
					Exit
				Else
					Loop
				EndIF
			EndIF
			
			IF ( SX3->X3_CONTEXT $ "Vv" )
				IF ( lNotVirtual )
					IF !GotoNextRecno( "SX3" , nSx3NextRecno , 1 )
						Exit
					Else
						Loop
					EndIF
				EndIF
			EndIF
					                   
			If SX3->(FieldPos("X3_TELA")) <> 0
				if !(Alltrim(MV_MODFOL) $ Alltrim(SX3->X3_TELA)) .and. !(Empty(SX3->X3_TELA))
					IF !GotoNextRecno( "SX3" , nSx3NextRecno , 1 )
						Exit
					Else
						Loop
					EndIF
				endif
			endif
				
			++nUsado			
			aAdd( aHeader , cCampo)

			IF !GotoNextRecno( "SX3" , nSx3NextRecno , 1 )
				Exit
			EndIf
		End While
	EndIf
		
	SX3->( dbSetOrder( aAreaSX3[ 02 ] ) )
Return aClone(aHeader)


/*/
зддддддддддбддддддддддддддддддбдддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFuncao    |				  ЁAutorЁRogerio Ribeiro	  Ё Data Ё05/01/2007Ё
цддддддддддеддддддддддддддддддадддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescricao ЁProcessa cada registro efetuando locks e tratando erros			Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё																Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ																Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   Ё.T. se todos os locks foram realizados com sucesso.				Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁRHLIBGD															Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function GDLockRows( cAlias		,;	//01 -> Alias para Lock
							aRecNos		,;	//02 -> [@] Array com os RecNos para Lock
							aKeyCodes	,;	//03 -> [@] Array com os Registros (Codigos) a Serem reservados							
							lLockRecnos ,;	//04 -> Se Havera Lock dos Recnos
							lUseCode	,;	//05 -> Se Havera Reserva do Registro (Codigo)
							nMaxLocks	,;	//06 -> Numero Maximo de Locks)
							lUseQuery	;	//07 -> Se foi utilizada query TopConnect ou tratado como DBF
						   )
	Local nRow
	Local lGDLocks:= .T.

	For nRow:= 1 to Len(aRecNos)
		(cAlias)->(dbGoto(aRecNos[nRow]))	
		
		#IFNDEF TOP
			IF (nRow <= nMaxLocks)
				lGdLocks := GDLocks(cAlias , @lLockRecnos , { aRecNos[nRow] } , @lUseCode , { aKeyCodes[nRow] } , nMaxLocks ) 
				
				IF !lGdLocks; Exit; EndIf
			EndIF	
		#ELSE
			IF !lUseQuery
				If (nRow <= nMaxLocks)
					lGdLocks := GDLocks( cAlias , @lLockRecnos , { aRecNos[nRow] } , @lUseCode , { aKeyCodes[nRow] } , nMaxLocks  )
					
					IF !lGdLocks; Exit; EndIf
				EndIf
			EndIf
		#ENDIF
	Next nRow
	
	#IFDEF TOP
		IF lUseQuery
			lGdLocks := GDLocks( cAlias , @lLockRecnos , aRecNos , @lUseCode , aKeyCodes , nMaxLocks  )
		EndIF
	#ENDIF
Return lGdLocks


/*/
зддддддддддбддддддддддддддддддбдддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFuncao    |GDExtendHeader	  ЁAutorЁRogerio Ribeiro	  Ё Data Ё05/01/2007Ё
цддддддддддеддддддддддддддддддадддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescricao ЁAltera o Header padrao do FillGetDados incluindo colunas extras	Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё																Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ																Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁRHLIBGD															Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function GDExtendHeader(aHeader)
	Local aColumn
	Local nCount
	Local nIndexOrd:= SX3->(IndexOrd())
	SX3->(dbSetOrder(2))	
	
	For nCount:= 1 to Len(aHeader)
		aColumn:= aHeader[nCount]

		aColumn[__AHEADER_TITLE__	]	:= AllTrim( aColumn[__AHEADER_TITLE__	])
		aColumn[__AHEADER_FIELD__	]	:= AllTrim( aColumn[__AHEADER_FIELD__	])
		aColumn[__AHEADER_PICTURE__	]	:= AllTrim( aColumn[__AHEADER_PICTURE__	])
		aColumn[__AHEADER_VALID__	]	:= AllTrim( aColumn[__AHEADER_VALID__	])

		If (Len(aColumn) < __ELEMENTOS_AHEADER__)
			ASize(aColumn, __ELEMENTOS_AHEADER__)		
                             
			SX3->(MsSeek(aColumn[__AHEADER_FIELD__])) 
					
			aColumn[__AHEADER_CBOX__	]	:= SX3->(X3CBox())
			aColumn[__AHEADER_INITPAD__	]	:= AllTrim(	GetSx3Cache(aColumn[__AHEADER_FIELD__], "X3_RELACAO") )
			aColumn[__AHEADER_WHEN__	]	:= AllTrim(	GetSx3Cache(aColumn[__AHEADER_FIELD__], "X3_WHEN") )
			aColumn[__AHEADER_VISUAL__	]	:= AllTrim(	GetSx3Cache(aColumn[__AHEADER_FIELD__], "X3_VISUAL") )
			aColumn[__AHEADER_VLDUSR__	]	:= AllTrim(	GetSx3Cache(aColumn[__AHEADER_FIELD__], "X3_VLDUSER") )
//			aColumn[__AHEADER_RESERV16__]	:= AllTrim(	GetSx3Cache(aColumn[__AHEADER_FIELD__], "X3_OBRIGAT") )
			aColumn[__AHEADER_RESERV16__]	:= ""
			aColumn[__AHEADER_RESERV17__]	:= X3Obrigat(AllTrim(aColumn[__AHEADER_FIELD__]) )
		EndIf
	Next nCount
	
	SX3->(dbSetOrder(nIndexOrd))	
Return


/*/
зддддддддддбддддддддддддддддддбдддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFuncao    |GDRecoveryHeader  ЁAutorЁRogerio Ribeiro	  Ё Data Ё05/01/2007Ё
цддддддддддеддддддддддддддддддадддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescricao ЁAltera o Header da fillGetDados incluindo colunas removidas 	Ё
Ё		   Ёindevidamente.													Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё																Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ																Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁRHLIBGD															Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function GDRecoveryHeader(aHeader, aYesFields)
	Local nPos
	Local aColumn
	Local nCount
	Local nIndexOrd  := SX3->(IndexOrd())
	Local aYesHeader := aClone(aHeader)
	
	SX3->(dbSetOrder(2))	
	
	For nCount:= 1 to Len(aYesFields)
		cField:= AllTrim( aYesFields[nCount])
		nPos:= aScan(aHeader , { |aColumn| AllTrim( aColumn[__AHEADER_FIELD__]) == cField} )
	
		If (nPos == 0)
			ASize(aYesHeader, Len(aYesHeader) + 1)
			AIns(aYesHeader, nCount)
			aColumn:= aYesHeader[nCount]:= Array(__ELEMENTOS_AHEADER__)
                             
			SX3->(MsSeek(cField)) 

			aColumn[__AHEADER_TITLE__	]	:= SX3->( AllTrim( X3Titulo() ) )
			aColumn[__AHEADER_FIELD__	]	:= cField
			aColumn[__AHEADER_PICTURE__	]	:= AllTrim( GetSx3Cache(cField, "X3_PICTURE") )
			aColumn[__AHEADER_WIDTH__	]	:= GetSx3Cache(cField, "X3_TAMANHO")
			aColumn[__AHEADER_DEC__		]	:= GetSx3Cache(cField, "X3_DECIMAL")
			aColumn[__AHEADER_VALID__	]	:= AllTrim( GetSx3Cache(cField, "X3_VALID") )
			aColumn[__AHEADER_USE__		]	:= GetSx3Cache(cField, "X3_USADO")
			aColumn[__AHEADER_TYPE__	]	:= GetSx3Cache(cField, "X3_TIPO")
			aColumn[__AHEADER_F3__		]	:= GetSx3Cache(cField, "X3_F3")
			aColumn[__AHEADER_CONTEXT__	]	:= GetSx3Cache(cField, "X3_CONTEXT")
			aColumn[__AHEADER_CBOX__	]	:= SX3->(X3cBox())
			aColumn[__AHEADER_INITPAD__	]	:= AllTrim(	GetSx3Cache(cField, "X3_RELACAO") )
			aColumn[__AHEADER_WHEN__	]	:= AllTrim(	GetSx3Cache(cField, "X3_WHEN") )
			aColumn[__AHEADER_VISUAL__	]	:= GetSx3Cache(cField, "X3_VISUAL")
			aColumn[__AHEADER_VLDUSR__	]	:= AllTrim(	GetSx3Cache(cField, "X3_VLDUSER") )
//			aColumn[__AHEADER_RESERV16__]	:= AllTrim( GetSx3Cache(cField, "X3_OBRIGAT") )
			aColumn[__AHEADER_RESERV16__]	:= ""
			aColumn[__AHEADER_RESERV17__]	:= X3Obrigat(Alltrim(cField) )
		elseif nCount <> nPos
			aYesHeader[nCount] := aClone(aHeader[nPos])
		EndIf
	Next nCount
	
	SX3->(dbSetOrder(nIndexOrd))	
	aHeader := aClone(aYesHeader)
Return 


/*/
зддддддддддбддддддддддддддбдддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFuncao    |GDSaveRecords ЁAutorЁRogerio Ribeiro	  Ё Data Ё05/01/2007Ё
цддддддддддеддддддддддддддадддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescricao ЁSalva os dados do aCols e aHeader no banco de dados.        Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё															Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ															Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   Ё.T. para uma gravacao com sucesso. 							Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGenerico  	                                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function GDSaveRecords	(	cAlias	,;  //01 -> Alias da tabela onde serao salvos os registros
							aHeader	,;  //02 -> Array com os Campos do Cabecalho da GetDados
							aRows	  ,;  //03 -> Array com os registros a salvar.
							bInsert	  ,;  //04 -> Bloco a ser executado apos o lock na tabela, ao incluir um registro.
							bUpdate	  ,;  //05 -> Bloco a ser executado apos o lock no registro para alteraГЦo.
							bDelete	  ,;  //06 -> Bloco a ser executado apos o lock no registro para exclusao.
							aMsMmCpos ,;  //07 -> Array com os Campos do tipo memo que deverao ser gravados.
							cAliasMsMm ;  //08 -> Alias da tabela que serao gravados os campos do tipo memo. DEFAULT : SYP
						)
	Local lInclusao := .F.
	Local lExclusao := .F.
	Local nx		:= 0
	Local ny		:= 0
	Local aRowAux	:= {}
	Local aMsMmPut  := {}
	Local nPosRecNo := aScan(aHeader , { |aColumn| IsHeadRec(aColumn[__AHEADER_FIELD__]) } )
	Local nCpoMemo  := 0
	Local nFieldPos := 0
	Local nMsMmPuts := 0
	Local nMsMmPut  := 0
	Local uCnt
	DEFAULT aMsMmCpos := {}
       
	Begin Transaction
		For nx := 1 To Len(aRows)
			aRowAux:= aRows[nx]
			lInclusao := aRowAux[nPosRecNo] == 0
			lExclusao := ATail(aRowAux)
					
			If lInclusao .AND. !lExclusao			//Inclusao
				RecLock(cAlias, .T.)
	
				If (bInsert != NIL); Eval(bInsert); Endif
			ElseIf !lInclusao .AND. !lExclusao		//Alteracao
				(cAlias)->(dbGoto(aRowAux[nPosRecNo]))			
				RecLock(cAlias, .F.)
	
				If (bUpdate != NIL); Eval(bUpdate); Endif
			ElseIf lExclusao						//Exclusao
				If !lInclusao
					(cAlias)->(dbGoto(aRowAux[nPosRecNo]))
					RecLock(cAlias, .F.)
					
					If (bDelete != NIL); Eval(bDelete); Endif
					
					(cAlias)->(dbDelete())
				Endif
                
				//Deleta os campos memos
				( cAlias )->( DelRecnos( cAlias , { aRowAux[nPosRecNo] } , NIL , NIL , aMsMmCpos , cAliasMsMm ) )
				Loop				
			Endif	                           	
			
			For ny := 1 To Len(aHeader)		
				If !(aHeader[ny][__AHEADER_CONTEXT__] $ "Vv")
					(cAlias)->(FieldPut(FieldPos(aHeader[ny][__AHEADER_FIELD__]), aRowAux[ny]))
				EndIf
				
				IF ( ( nCpoMemo := aScan( aMsMmCpos , { |cCpo| ( cCpo[1] == aHeader[ ny , __AHEADER_FIELD__ ] ) } ) ) > 0 )
					/*/
					здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
					Ё Armazena as Informacoes que serao gravadas no SYP      	   Ё
					юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
					IF ( ( nFieldPos := ( cAlias )->( FieldPos( aMsMmCpos[nCpoMemo,02] ) ) ) > 0 )
						uCnt := ( cAlias )->( FieldGet( nFieldPos ) )
						( cAlias )->( aAdd( aMsMmPut , { Recno() , uCnt , aRowAux[ny] , aMsMmCpos[nCpoMemo,02] , cAliasMsMm } ) )
					EndIF	
				EndIF
			Next ny
			
			MsUnlock()
			If !( lExclusao .and. !lInclusao )	//Inclusao ou Alteracao
				/*/
				здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				Ё Grava as Informacoes no SYP                           	   Ё
				юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
				IF ( ( nMsMmPuts := Len( aMsMmPut ) ) > 0 )
					
					For nMsMmPut := 1 To nMsMmPuts
	
						/*/
						здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
						Ё Se nao Tiver Numeracao e nem Texto vai para o Proximo	  	   Ё
						юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
						IF (;
								Empty( aMsMmPut[ nMsMmPut , 02 ] );
								.and.;
								Empty( aMsMmPut[ nMsMmPut , 03 ] );
							)
							Loop
						EndIF
	
						( cAlias )->( dbGoto( aMsMmPut[ nMsMmPut , 01 ] ) )
						lLock := ( cAlias )->( RecLock( cAlias , .F. , .F. ) )
						/*/
						здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
						Ё Se nГo Conseguiu o Lock tenta o proximo  				   	   Ё
						юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
						IF !( lLock )
							Loop
						EndIF
	
						MsMm(	aMsMmPut[ nMsMmPut , 02 ]	,;
								NIL							,;
								NIL							,;
								aMsMmPut[ nMsMmPut , 03 ]	,;
								1							,;
								NIL							,;
								NIL							,;
								cAlias      				,;
								aMsMmPut[ nMsMmPut , 04 ]	,;
								aMsMmPut[ nMsMmPut , 05 ]	 ;
							)
	
						lLock := ( cAlias )->( RecLock( cAlias , .F. , .F. ) )
						/*/
						здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
						Ё Se nГo Conseguiu o Lock tenta o proximo  				   	   Ё
						юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
						IF !( lLock )
							Loop
						EndIF
	
					Next nMsMmPut

					( cAlias )->( MsUnLock() )

				EndIF
				
			EndIF
		Next nx
	
	End Transaction
Return .T.

/*/
зддддддддддбддддддддддддддддддбдддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFuncao    |GDRemoveEmptyRows ЁAutorЁRogerio Ribeiro	  Ё Data Ё05/01/2007Ё
цддддддддддеддддддддддддддддддадддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescricao ЁRemove as linhas em branco do aRows.				        	Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё																Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ																Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGenerico														Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function GDRemoveEmptyRows(aHeader, aRows)
	Local nRow
	Local nPosRecNo := aScan(aHeader , { |aColumn| IsHeadRec(aColumn[__AHEADER_FIELD__]) } )

	For nRow:= Len(aRows) To 1 Step -1
		If aRows[nRow, nPosRecNo] = 0
			ADel(aRows, nRow)
			ASize(aRows, Len(aRows) - 1)
		EndIf
	Next nRow
Return 


Static Function GDResizeWTColumns(aHeader)
	Local nPos
	
	If (nPos:= aScan(aHeader , { |aColumns| IsHeadRec(aColumns[__AHEADER_FIELD__]) } )) > 0
		ASize(aHeader[nPos], __ELEMENTOS_AHEADER__)
		aHeader[nPos, __AHEADER_CBOX__]		:= ""
		aHeader[nPos, __AHEADER_INITPAD__]	:= ""
		aHeader[nPos, __AHEADER_WHEN__	]	:= ""
		aHeader[nPos, __AHEADER_VISUAL__]	:= "V"
		aHeader[nPos, __AHEADER_VLDUSR__]	:= ""
		aHeader[nPos, __AHEADER_RESERV16__]	:= ""
		aHeader[nPos, __AHEADER_RESERV17__]	:= .F.
	EndIf

	If (nPos:= aScan(aHeader , { |aColumns| IsHeadAlias(aColumns[__AHEADER_FIELD__]) } )) > 0
		ASize(aHeader[nPos], __ELEMENTOS_AHEADER__)
		aHeader[nPos, __AHEADER_CBOX__]		:= ""
		aHeader[nPos, __AHEADER_INITPAD__]	:= ""
		aHeader[nPos, __AHEADER_WHEN__	]	:= ""
		aHeader[nPos, __AHEADER_VISUAL__]	:= "V"
		aHeader[nPos, __AHEADER_VLDUSR__]	:= ""
		aHeader[nPos, __AHEADER_RESERV16__]	:= ""
		aHeader[nPos, __AHEADER_RESERV17__]	:= .F.
	EndIf
Return

/*
эээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFUNCAO    ЁGDVALIDGETЁ AUTOR Ё MOHANAD ODEH          Ё DATA Ё17/04/2013Ё╠╠
╠╠цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDESCRICAO ЁVALIDA GETDADOS (LINHAS DUPLICADAS E/OU CAMPOS OBRIGATORIOS)Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁPARAMETROSЁ aCpo -> VETOR COM CAMPOS PARA COMPOR A CHAVE DE PESQUISA   Ё╠╠
╠╠Ё          Ё nModelo -> INDICA O MODELO DE VALIDACAO:                   Ё╠╠
╠╠Ё          Ё   1 - APENAS VALIDA                                        Ё╠╠
╠╠Ё          Ё   2 - VALIDA E EXIBE MENSAGEM DE ERRO                      Ё╠╠
╠╠Ё          Ё   3 - VALIDA E EXIBE MENSAGEM DE ERRO INFORMANDO OS CAMPOS Ё╠╠
╠╠Ё          Ё   4 - VALIDA E EXIBE MENSAGEM DE ERRO INFORMANDO OS CAMPOS Ё╠╠
╠╠Ё          Ё       E AS LINHAS COM DUPLICIDADE                          Ё╠╠
╠╠Ё          Ё aNoEmpty -> VETOR COM CAMPOS DE PREENCHIMENTO OBRIGATORIO  Ё╠╠
╠╠Ё          Ё lShowAviso -> SE EXIBE MENSAGEM                            Ё╠╠
╠╠Ё          Ё aHdr -> OBJETO AHEADER QUANDO NAO FOR O DEFAULT            Ё╠╠
╠╠Ё          Ё aCls -> OBJETO ACOLS QUANDO NAO FOR O DEFAULT              Ё╠╠
╠╠Ё          Ё nAt -> LINHA DO ACOLS EM QUE ESTA POSICIONADO QUANDO NAO   Ё╠╠
╠╠Ё          Ё FOR O DEFAULT                                              Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁRETORNO   Ё lRet                                                       Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠*/
Function GDVALIDGET(aCpo, nModelo, aNoEmpty, lShowAviso, aHdr, aCls, nAt)
Local aAux      	:= {}
Local aLinhas   	:= {}
Local aChkNoEmpty	:= {}
Local aEmptys		:= {}
Local cString		:= ""
Local cEmptyString	:= ""
Local cCrLf			:= Chr(13) + Chr(10)
Local cMsgAviso		:= ""
Local lRet			:= .T.
Local lDuplic		:= .F.
Local lEmpty		:= .F. 
Local lnAtDel		:= .T.
Local nLoop     	:= 0
Local nLoop2    	:= 0
Local nPosCampo 	:= 0
Local nPosAtu   	:= 0

DEFAULT nModelo 	:= 1
DEFAULT aNoEmpty	:= {}
DEFAULT lShowAviso	:= .T.
DEFAULT aHdr		:= aHeader
DEFAULT aCls		:= aCols
DEFAULT nAt			:= N

//MONTA O ARRAY AUXILIAR COM OS CAMPOS A SEREM VALIDADOS
For nLoop := 1 To Len(aCpo)
	IF ((nPosCampo := GDFieldPos(aCpo[nLoop], aHdr)) == 0)
		Loop
	EndIF
	AAdd(aAux, {aCpo[nLoop], nPosCampo, .F.})
Next nLoop

For nLoop := 1 To Len(aNoEmpty)
	IF ((nPosCampo := GDFieldPos(aNoEmpty[nLoop], aHdr)) == 0)
		Loop
	EndIF
	aAdd(aChkNoEmpty, {aNoEmpty[nLoop], nPosCampo, .F.})
Next nLoop

// ORDENA POR POSICAO NO ACOLS
ASORT(aAux,,, {|x,y| y[2] > x[2]})
ASORT(aChkNoEmpty,,, {|x,y| y[2] > x[2]})  

// VALIDA SE LINHA POSICIONADA NAO ESTA DELETADA
lnAtDel := !GDDeleted(nAt, aHdr, aCls)

//PERCORRE O ACOLS PARA VERIFICAR AS LINHAS DUPLICADAS
For nLoop := 1 To Len(aCls)
	If !GDDeleted(nLoop, aHdr, aCls)
		IF (nAt <> nLoop)
			For nLoop2 := 1 To Len(aAux)
				//MARCA NO ARRAY CASO O CAMPO ESTEJA DUPLICADO
				nPosAtu := aAux[nLoop2, 2]
				aAux[nLoop2, 3] := (aCls[nLoop, nPosAtu] == aCls[nAt, nPosAtu])
			Next nLoop2
		EndIF	
		For nLoop2 := 1 To Len(aChkNoEmpty)

			//MARCA NO ARRAY CASO O CAMPO ESTEJA VAZIO
			nPosAtu := aChkNoEmpty[nLoop2, 2]
			aChkNoEmpty[nLoop2, 3] := Empty(aCls[nLoop, nPosAtu])

		Next nLoop2

		// PESQUISA ALGUM CAMPO QUE NAO ESTEJA DUPLICADO
		lDuplic := ((nAt <> nLoop) .And. lnAtDel .And. Empty(AScan(aAux, {|x| !x[3]})))

		// PESQUISA ALGUM CAMPO QUE ESTEJA VAZIO
		lEmpty	:= !Empty(aScan(aChkNoEmpty, {|x| x[3]}))

		If ((lDuplic) .or. (lEmpty))
			lRet := .F.
			If nModelo == 4
				IF (lDuplic)
					AAdd(aLinhas, nLoop)
				EndIF
				IF (lEmpty)
					aAdd(aEmptys, nLoop) 
				EndIF	
			Else 	
				Exit									
			EndIf
		EndIf

		// MARCA TODOS OS CAMPOS COMO NAO DUPLICADOS NOVAMENTE
		IF (lDuplic)
			AEval(aAux, {|x| x[3] := .F.})
		EndIF	

		// MARCA TODOS OS CAMPOS COMO NAO VAZIOS NOVAMENTE
		IF (lEmpty)
			aEval(aChkNoEmpty, {|x| x[3] := .F.})
		EndIF	

	EndIf

Next nLoop

If !lRet .And. nModelo <> 1
	// MONTA A MENSAGEM CONFORME O MODELO
	IF (lDuplic := !Empty(aLinhas))
		cString := OemToAnsi(STR0002) // "A linha atual possui uma chave duplicada no browse."
	EndIF

	IF (lEmpty := !Empty(aEmptys))
		cEmptyString := OemToAnsi(STR0003) // "A linha atual possui campo de Preenchimento ObrigatСrio."  
	EndIF	

	If nModelo == 3 .Or. nModelo == 4
		IF (lDuplic)
			cString += cCrLf + OemToAnsi(STR0004) // "Campo(s):  "
			For nLoop := 1 To Len(aAux)
				cString += aHdr[aAux[nLoop,2], 1] + ", " 		
			Next nLoop
			cString := Left( cString, Len( cString ) - 2 ) + "."
		EndIF	
		
		IF (lEmpty)
			cEmptyString += cCrLf + OemToAnsi(STR0004) // "Campo(s):  "
			For nLoop := 1 To Len(aChkNoEmpty)
				cEmptyString += aHdr[aChkNoEmpty[nLoop, 2], 1] + ", "
			Next nLoop
			cEmptyString := Left(cEmptyString, Len(cEmptyString) - 2) + "."
		EndIF

		If nModelo == 4
			IF (lDuplic)
				cString += cCrLf + OemToAnsi(STR0005) // "Linha(s):  "
				For nLoop := 1 to Len(aLinhas)
					cString += AllTrim(Str(aLinhas[nLoop])) + ", "
				Next nLoop
				cString := Left(cString, Len(cString) - 2) + "."
			EndIF

			IF (lEmpty)
				cEmptyString += cCrLf + OemToAnsi(STR0005) // "Linha(s):  "
				For nLoop := 1 To Len(aEmptys)
					cEmptyString += AllTrim(Str(aEmptys[nLoop])) + ", "
				Next nLoop
				cEmptyString := Left(cEmptyString, Len(cEmptyString) - 2) + "."
			EndIF
		EndIf
	EndIf
	// EXIBE A MENSAGEM
	IF ((lDuplic) .and. (lEmpty))
		cMsgAviso := cString
		cMsgAviso += cCrLf
		cMsgAviso += cCrLf
		cMsgAviso += cEmptyString
	ElseIF (lDuplic)
		cMsgAviso := cString
	ElseIF (lEmpty)
		cMsgAviso := cEmptyString
	EndIF
	IF (lShowAviso)
		MsgInfo(cMsgAviso, OemToAnsi(STR0001)) // "ATENCAO!"
	EndIF
EndIf

Return(lRet)
