#INCLUDE "PONXFUN.CH"  
#INCLUDE "PONCALEN.CH"
#INCLUDE "PROTHEUS.CH"    
#INCLUDE "ARFF.CH"

#DEFINE DPORT1510  "25/11/09"

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Static Utilizadas na CriaCalend()  						   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ /*/
Static __dPerCalIni
Static __dPerCalFim
/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Static Utilizadas na CalendCria()  						   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static __aLstTabCal	:= {}
Static __aLstTabTno	:= {}	
Static __cKeyBldCal	:= "__cKeyBldCal"
Static __nFilTabTno	:= 0
/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Static Utilizadas na fTabPadrao()  						   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static __nLstTabPadPos

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Static Utilizadas na fTabMarc()    						   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static __aLstTbMarc

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Static Utilizadas na ToScheduleOverTime()					   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static __aHeLastGera__
Static __cHeLastKey__

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Static Utilizadas na GetTabArred()					   	   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static __aTabArr
Static __aTabFilArr

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Static Utilizadas na GetTabExtra()					   	   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static __aTabEx
Static __lEscalonamento 
Static cFilStatic		//Para uso em DEFAULTFIL

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Static Utilizadas na fFeriado()   					   	   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static __aFeriadoStatic

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Define o Numero Maximo de Ordens para o P8_ORDEM             ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static __nTamP8Ordem	:= InitP8PgOrdSize(1)

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Define o Numero Maximo de Ordens para o PG_ORDEM             ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static __nTamPGOrdem	:= InitP8PgOrdSize(2)

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Static com as Eventos carregados pela fEventos()             ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static __aEvefEve__	:= {}

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Static para a fCargaId										  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static aCargaIdCache 	:= {}

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Static para a PutMarcAuto()								  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static _aSpaHeader
Static _aSr6Header

Static _cSr6LastTno
Static _cSpaLastReg
Static _cSpceFuncao
Static _cSpceGiro
Static _cSpceRelogi

Static _nSpaHeader
Static _nSr6Header

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Verifica a Existencia do Arquivo de Pre-Abonos.  ( Nao devera³
³constar em versoes Futuras )								  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static lRF0ChkTable

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Static Utilizadas na Calendcria e Turnos Opcionais	   	   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static __aAllTnoOpc
Static __lChkTnoOpc	

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Variavel para uso em Query para preencher em branco		  ³
³o campo Motivo do Abono 								  	  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static __cLimpaMotAbo	

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Variavel para uso da Geracao Automatica de Marcacoes		  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static lPnMcAut01	:= ExistBlock( "PNMCAUT01" )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Variavel para manipulacao do calendario apos sua montagem	  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static lPnmTabCalen := ExistBlock( "PNMTABC01" )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Variavel para alterar motivo de inclusao de marcacao auto.	  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static lPnmMotMarc := ExistBlock( "PNMMOTMARC" )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Variavel para manipulacao da autorizacao do evento		      ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static lPnmAutEven := ExistBlock( "PNMAUTEVEN" )

//--Se existe o ponto de entrada PNAPOSPC
Static lPnaApoSrc   := ExistBlock( "PNAPOSPC" )
// PE que permite ignorar uma exceção cadastrada para o período
Static lPnmExcFi	:= ExistBlock( "PNMEXCFI")

Static lAltTol := ExistBlock( "PNMTOLALT" )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Variavel para a gravação dos campos de auditoria do ponto	  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static __lCpoDataAlt	
Static __lCpoUsuaAlt
Static __lUsuaCpo

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Verifica se Portaria 1510/2009 esta em vigor.				  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static lPort1510 := Port1510()    

//-- Campos da tabela SPC para atendimento a portaria 1.510
Static __lCpoTurno	
Static __lCpoSemana	
Static __lCpoTipoHE
Static __lCpoPercent	

Static aSr6Info		:= {}
Static aSr6Struct 	:= { "R6_INIHNOT", "R6_FIMHNOT", "R6_MINHNOT", "R6_APODFER", "R6_TPEXFER", "R6_TPEXFEN", "R6_AUTOHEF", "R6_ASFOLGA", "R6_TNOOPC" }
Static lSr6Ok		 := .T.
Static aSpaInfo		:= {}
Static aSpaStruct 	:= { "PA_PAGINT", "PA_FERIADO","PA_TPAPONT" }
Static lSpaOk		:= .T.

//-- Variavel usada para verificar se o disparo da funcao IntegDef() pode ser feita manualmente
Static lIntegDef := FindFunction("GETROTINTEG") .And. FindFunction("FWHASEAI")
Static lAutoGS   := FindFunction("TecPNMTAB") .and. FindFunction("TecExecPNM")
Static lValidGS  := FindFunction("TecBOrdMrk")

Static lMarcAut := .F.

Static aEvesIds := {}
Static lCpoPer	:= NIL
Static lCpoIsento := NIL
Static lSitFunc := NIL

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³PonxFun   ³ Autor ³ *EQUIPE RH ADVANCED*  		 	³ Data ³02/02/1996³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³ Biblioteca de Fun‡”es Utilizadas no M¢dulo SigaPon        			  ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³ Void                                                   			  ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³ Gen‚rico                                                  			  ³
ÃÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³                     ATUALIZACOES SOFRIDAS DESDE A CONSTRU€AO INICIAL. 		  ³
ÃÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Programador ³ Data   ³ FNC			   ³  Motivo da Alteracao                     ³
ÃÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Leandro Dr. |13/04/14|Req. 003251     |Retirada de ajustes, database e fieldpos  | 
|			 |		  |			       |que nao devem mais ser utilizados na P12. | 
³Christiane V|11/04/14| M_RH003/003252 |Gravação da SR8_NUMID no array aTabCalend | 
³Luis Artuso |11/08/14|00000026073/2014|Adicionado o ID de ponto '038N' na rotina | 
|			 |		  |			 TQGSV0|ObtemEveNoDele, para nao excluir evento de| 
|			 |		  |			       |hora extra inter jornada entre periodos.  |
³Luis Artuso |28/08/14|00000023699/2014|Ajuste em LoadTnoOpc para inicializacao da| 
|			 |		  |			 TQDZCS|variavel __aAllTnoOpc (Devido errorlog ao | 
|			 |		  |			       |executar a rotina)  quando o parametro    |  
|			 |		  |			       |MV_PONMULT(Multi Thread) estiver ativado. |
³Luis Artuso |27/08/14|00000026462/2014|Adicionado texto (STR0240) para informar  | 
|			 |		  |			 TQHGBM|ao usuario a filial que sera processada,  |
|			 |		  |			       |quando a data estiver fora do periodo de  |
|			 |		  |			       |apontamento.                              |
³Luis Artuso |31/10/14|00000036174/2014|Efetuado ajuste para gravar o tipo de mar |
|			 |		  |			 TQTIIL|cacao, quando utilizar o intervalo pre-as |
|			 |		  |			       |sinalado.                                 |
³Luis Artuso |18/12/14|00000044673/2014|Efetuado ajuste para nao ordenar marcacoes|
|			 |		  |			 TRH164|desprezadas, quando utilizar o ajuste de  | 
|			 |		  |			       |marcacoes.                                |
³Luis Artuso |04/02/15|00000037711/2014|Ajuste na alteracao da segunda-feira como | 
|			 |		  |		     TQVSYT|DSR automatico p/ nao perder o limite do  | 
|			 |		  |			       |horario.                                  |
|Luis Artuso |31/07/15|          TSYWKY|Ajuste p/ atualizar os eventos de hora ex-|
|            |        |                |tra autorizada/nao autorizada quando hou- |
|        	 |	      |				   |ver quebra de filial.                     |
|Gustavo M.  |01/12/15|     PCDEF-86252|Ajuste na inicialização do pergunte PONMES|
|Renan Borges|07/12/15|		     TTTSI7|Ajuste p/ apurar horas não realizadas e   | 
|			 |		  |			       |horas extras corretamente, de acordo com o| 
|			 |		  |			       |artigo 58 da CLT, respeitando as tolerân- |
|			 |		  |			       |cias por marcações e por períodos.        |
|Renan Borges|08/01/16|		     TUDTQO|Ajuste para em regras que o feriado seja  | 
|			 |		  |			       |trabalhado e o turno possua a 1° Falta Fol| 
|			 |		  |			       |ga com "Sim" gere DSR para o primeiro dia | 
|			 |		  |			       |de falta mesmo sendo feriado corretamente.| 
|Matheus M.  |28/01/16|		     TUJERC|Ajuste para considerar as marcações em    | 
|			 |		  |			       |dias que contém exceções e são feriados   |
|			 |		  |			       |trabalhados.						      |  
|Renan Borges|17/02/16|		     TUJEA3|Ajuste para definir o periodo corretamente| 
|			 |		  |			       |ao incluir pela opção de dia inicial/final| 
|Renan Borges|04/08/16|		     TVTHKK|Criação do ponto de entrada PNMTOLALT para| 
|			 |		  |			       |alterar a tolerância conforme a data da   | 
|			 |		  |			       |marcação, por exemplo no sábado a tolerân-| 
|			 |		  |			       |cia é diferente do que nos outros dias.   | 
|Allyson M.	 |29/12/16|		   MRH-4015|Ajuste na validação do pré-abono p/ não   | 
|			 |		  |			       |gerar abono com 60 minutos   			  |
|Renan Borges|17/01/17|        MRH-3465|Ajuste para lançar e apontar marcações cor|
|            |        |                |retamente quando for alterada a regra de  |
|            |        |                |apontamento do funcionário, de saida para |
|            |        |                |entrada.                                  |
|Gabriel A.  |06/02/17|        MRH-6292|Ajuste para não valorizar cReg e cSeq     |
|            |        |                |quando for chamada do cadastro de período.|
|Renan Borges|03/03/17|        MRH-5987|Ajuste parar na leitura do relógio na roti|
|            |        |                |na (PONM010), sistema esta posicionando as|
|            |        |                | marcações impares corretamente quando o  |
|            |        |                |campo Mc.Imp.JC(R6_MCIMPJC) está igual a  |
|            |        |                |"sim".                                    |
|Oswaldo L   |27-04-17|     DRHPONTP300| Entre os dias 24-04-17 e 26-04-17	      |
|            |        |                | baixamos os fontes do TFS das pastas	  |
|            |        |                | MAIN, 12.1.14 e 12.1.16. Conforme   	  |
|            |        |                | solicitado fizemos merge delas,depois	  |
|            |        |                | removemos alteracoes em SX         	  |
|Renan Borges|22/05/17|    DRHPONTP-425|Ajuste para que após alterar o campo "Con-|
|            |        |                |sid. Marc" para "Não" na rotina regra de  |
|            |        |                |apontamento (PONA060), o sistema mostre as| 
|            |        |                | marcações corretamente.                  |
|M. Silveira |14/06/17|    DRHPONTP-988|Ajuste em PutMarcAuto p/ avaliar da forma |
|            |        |                |correta os dados ao gerar marc.automaticas|
|M. Silveira |31/07/17|   DRHPONTP-1375|Ajuste em GravaSPC p/ avaliar quando as   |
|            |        |                |horas abonadas sao maiores a calculada.   |
|Oswaldo L   |01-08-17|   DRHPONTP-1050|Baixar Interj inovacao 12.1.18 p/ 12.1.17 |
|Oswaldo L   |02-08-17|   DRHPONTP-1050|Ajuste inicialização de array na FGeraRes |
ÀÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/



/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³InPonxFunExec³ Autor ³Marinaldo de Jesus   ³ Data ³14/05/2003³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Executar Funcoes Dentro de PONXFUN                           ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³InPonxFunExec( cExecIn , aFormParam )						 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³uRet                                                 	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico 													 ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function InPonxFunExec( cExecIn , aFormParam )
         
Local uRet

DEFAULT cExecIn		:= ""
DEFAULT aFormParam	:= {}

IF !Empty( cExecIn )
	cExecIn	:= BldcExecInFun( cExecIn , aFormParam )
	uRet	:= &( cExecIn )
EndIF

Return( uRet )

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³AbreArqRel³ Autor ³ Equipe Advanced RH    ³ Data ³29/02/1996³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Abre o arquivo gerado pelo rel¢gio.                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³                                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Function AbreArqRel(	cTipoArq	,;	//01 -> Tipo do Arquivo a ser Aberto. "T"ext File, "D"ata File
						cArquivo	,;	//02 -> Caminho completo do arquivo
						nHandle		,;	//03 -> Handle do Arquivo ( Quando Tipo = "T" )
						lEnchoice	,;	//04 -> Se esta sendo Executado aa partir da Enchoice
						lStop		,;	//05 -> Se deve Emitir Mensagens
						cArqSrv		,;	//06 -> Nome do arquivo no server
						lCpyT2Srv	,;	//07 -> Se o arquivo foi copiado para o server
						lForceCopy	 ;	//08 -> Forca copia do arquivo para o server
					 )
Local aAuxRelo		:= {}
Local aSvAlias		:= GetArea()
Local cExt			:= ""
Local cDiretorio	:= ""
Local cRdd			:= "DBFCDX"
Local cMsgAlert		:= ""
Local cPathSrv		:= Upper(GetPvProfString( GetEnvServer() , "StartPath" , "" , GetAdv97() ) )
Local lRet			:= .T.
Local nPos			:= 0
Local cPonArq		:= If( !Empty( SuperGetMv("MV_POARQ",.F.,"N") ), SuperGetMv("MV_POARQ",.F.,"N"), "2" )
Local lLinux		:= If(GetSrvInfo()[2] == "Linux",.T.,.F.)

DEFAULT cTipoArq	:= "T"
DEFAULT cArquivo	:= ""
DEFAULT nHandle		:= 0
DEFAULT lEnchoice	:= .F.
DEFAULT lStop	  	:= .T.
DEFAULT cArqSrv		:= "" 
DEFAULT lCpyT2Srv	:= .F. 
DEFAULT lForceCopy	:= .F.

cArquivo			:= Upper( AllTrim( cArquivo ) )
nHandle				:= 0
cArqSrv				:= ""
lCpyT2Srv			:= .F.

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Tratamento de acordo com o Tipo de Arquivo - R - REP		   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
IF ( cTipoArq == "R" )
	Return .T.
Endif

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Array com os alias dos arquivos abertos (s¢ para o PONA030)  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
IF ( lEnchoice .and. cTipoArq == "D" )
	IF ( Type( "aAliasRelo" ) == "U" )
		_SetOwnerPrvt( "aAliasRelo" , {} )
	EndIF
	DEFAULT aAliasRelo := {}
EndIF

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Inicializa cTxtAlias uma Estancia Acima					   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
IF ( Type( "cTxtAlias" ) == "U" )
	_SetOwnerPrvt( "cTxtAlias" )
EndIF

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Obtem o Nome Real do Arquivo Sem Path e nem Extenso		   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
cTxtAlias := cArquivo


/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Alteracao solcitada pelo Andre Gentil para contornar a situa ³
³ cao de nao gravacao de arquivo do remote para o servidor.    ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
/*
IF ( ( nPos := At( ":" , cTxtAlias ) ) > 0 )
	cTxtAlias := SubStr( cTxtAlias , ++nPos )
EndIF
*/

While ( At( "\" , cTxtAlias ) > 0 )
	IF ( ( nPos := At( "\" , cTxtAlias ) ) > 0 )
		cTxtAlias := SubStr( cTxtAlias , ++nPos )
	EndIF
End While

While ( At( "/" , cTxtAlias ) > 0 )
	IF ( ( nPos := At( "/" , cTxtAlias ) ) > 0 )
		cTxtAlias := SubStr( cTxtAlias , ++nPos )
	EndIF
End While

While ( At( "." , cTxtAlias ) > 0 )
	IF ( ( nPos := At( "." , cTxtAlias ) ) > 0 )
		cTxtAlias := Left( cTxtAlias , --nPos )
	EndIF
End While

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Obtem a Extensao do Arquivo								   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
IF ( ( nPos := At( "." , cArquivo ) ) > 0 )
	cExt := Upper( AllTrim( SubStr( cArquivo , nPos ) ) )
EndIF

// Verifica a Existencia de "\" ou "/" barras separadoras de diretorio
If !( Left(cPathSrv, 1) $ "\/" )
	cPathSrv := If(lLinux, "/", "\") + cPathSrv
EndIf

If !( Right(cPathSrv, 1) $ "\/" )
	cPathSrv += If(lLinux, "/", "\")
EndIf

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Obtem o Nome do arquivo no Server 							   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
cArqSrv := Upper( AllTrim( ( cPathSrv + ( cTxtAlias + cExt ) ) ) )

If lEnchoice
    If !Empty(aAliasRelo)   
       nPos:=0   
       For nPos:=1 To Len(aAliasRelo)
           fCloseArqRel(	aAliasRelo, nPos, 	aAliasRelo[nPos,01 ],  aAliasRelo[nPos,02 ], aAliasRelo[nPos,03 ],;
           										aAliasRelo[nPos,04 ],  aAliasRelo[nPos,05 ], aAliasRelo[nPos,06 ],;
           										cTxtAlias, cArquivo ;
           				)
       Next nPos                    
       aAuxRelo		:= Aclone(aAliasRelo)
       aAliasRelo	:= {}             
       //-- Nao considera arquivo marcados para delecao
       Aeval(aAuxRelo, {|x| If ( x[1] == "DEL", NIL, AADD(aAliasRelo,aClone(x)) ) } )
      				 
	   lCpyT2Srv	:= ( aScan( aAliasRelo , {|x| x[1] == cTxtAlias .AND. x[02] .and.    x[04 ]  == cTipoArq .and. x[06 ]  == cArquivo  } ) > 0 ) 
	Endif   
Endif		
	    
/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³cPonArq - indica que só copia o arquivo para o StartPath caso ³
³o parametro MV_POARQ esteja com valor NÃO					   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
If (cPonArq != "1")
	If !lCpyT2Srv  .or. lForceCopy
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Copia o arquivo para o Servidor							   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		IF ( lCpyT2Srv := !(;
								( cArquivo == StrTran( cArqSrv , "/" , "\" ) ) .and.;
								( cArquivo == StrTran( cArqSrv , "\" , "/" ) );
							);
			)  
			
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³Quando o Arquivo Nao Estiver no Server     				   ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			IF ( lCpyT2Srv := !( Upper( StrTran( cArquivo , " " , "" ) ) == Upper( StrTran( cArqSrv , " " , "" ) ) ) )
		
				/*/
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³Copia-o                                    				   ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			    //lCpyT2Srv := __CopyFile( cArquivo , cArqSrv ) //__CopyFile() Recomendacao do Fernando Ramalho ao Inves do CpyT2S() 14/10/2002 16:38h. Naldo.
		
				/*/
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Alteracao solcitada pelo Andre Gentil para contornar a situa ³
				³ cao de nao gravacao de arquivo do remote para o servidor.    ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		       
			   //	IF ( ( At( ":" , cArquivo ) ) > 0 )
			   //		lCpyT2Srv := CpyT2S( cArquivo , cPathSrv ) //CpyT2S() Recomendacao do Andre Gentil 13/12/2005 11:55h. Mauricio.
			   //	Else

			   // Se o arquivo estiver fora da protheus_data e smartclient for HTML não copio o arquivo para a system, devido a uma limitação do WebApp.
				If GetRemoteType() != 5 .Or. SubStr(cArquivo,1,1) == "\"
					If lLinux
						// caso seja Linux renomeio o arquivo txt para que seja possível realizar o __CopyFile para a pasta system.
						cArquivo	:= Lower(StrTran(cArquivo,"/","\"))
						cArqSrv		:= Lower(StrTran(cArqSrv,"/","\"))
						cDiretorio	:= Lower(SubStr(cArquivo,1,Len(cArquivo)-Len(cTxtAlias+cExt)))
						
						Do Case
							Case File(cDiretorio + Upper(cTxtAlias+cExt),,.F.)
								fRename(cDiretorio + Upper(cTxtAlias+cExt),cDiretorio + Lower(cTxtAlias+cExt),,.F.)

							Case File(cDiretorio + Upper(cTxtAlias) + Lower(cExt),,.F.)
								fRename(cDiretorio + Upper(cTxtAlias) + Lower(cExt), cDiretorio + Lower(cTxtAlias+cExt),,.F.)

							Case File(cDiretorio + Lower(cTxtAlias) + Upper(cExt),,.F.)
								fRename(cDiretorio + Lower(cTxtAlias) + Upper(cExt),cDiretorio + Lower(cTxtAlias+cExt),,.F.)
						EndCase
					EndIf

					lCpyT2Srv := __CopyFile( cArquivo , cArqSrv ) //__CopyFile() Recomendacao do Fernando Ramalho ao Inves do CpyT2S() 14/10/2002 16:38h. Naldo.
				EndIf
			   //	Endif
		        
				/*/
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ No Ap7 Existe uma Nao  Conformidade com o Retorno da 	 funcao³
				³ __CopyFile(). Esta retornando NIL Quando deveria Retornar .T.³
				³ ou .F. Caso Tenha Conseguido ou Nao Copiar o Arquivo. Ate que³
				³ a Nao Conformidade Seja corrigida o valor DEFAULT da variavel³
				³ de Retorno da __CopyFile ( lCpyT2Srv ) sera False (.F.)  Caso³
				³ Contrario sera o Proprio retorno da Funcao				   ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
				DEFAULT lCpyT2Srv := .F.
		
			EndIF
		Endif
	EndIF
EndIf


/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Tratamento de acordo com o Tipo de Arquivo					   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
IF ( cTipoArq == "D" )
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Abre o arquivo no padr„o DBASE								   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	IF ( !Empty( cTxtAlias ) .and. Select( cTxtAlias ) > 0 )
		( cTxtAlias )->( dbCloseArea() )
		RestArea( aSvAlias )
	EndIF
	IF ( lRet := MsFile( cArqSrv , NIL , cRdd ) )
		IF (;
				!( CheckExecForm( { || lRet := MsOpenDbf( .T. , cRdd , cArqSrv , cTxtAlias , .T. , .F. ) } , lStop , "NODBFFILE" ) );
				.or.;
				!( lRet );
			 )
			lRet		:= .F.
			cMsgAlert	:= ( STR0156 + " " + cArqSrv )	//'Nao foi possivel abrir o arquivo:'
		EndIF
	Else
		cMsgAlert := ( STR0058 + cArqSrv ) 				//"Arquivo do Relogio nao Encontrado no Servidor: "
	EndIF
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Inclui o Alias aberto para posterior fechamento			   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	IF ( lEnchoice .and. Select( cTxtAlias ) > 0 )
		IF  ( ( nPos := aScan( aAliasRelo , {|x| x[1] == cTxtAlias  .and.  x[04 ]  == cTipoArq .and. 	x[06] == cArquivo } )) == 0 )
			aAdd( aAliasRelo , { cTxtAlias , lCpyT2Srv , cArqSrv , cTipoArq , nHandle, cArquivo } )
		Else
			aAliasRelo[ nPos , 02 ] := lCpyT2Srv
			aAliasRelo[ nPos , 03 ]	:= cArqSrv
			aAliasRelo[ nPos , 04 ]	:= cTipoArq
			aAliasRelo[ nPos , 05 ]	:= nHandle
			aAliasRelo[ nPos , 06 ]	:= cArquivo
		EndIF
	EndIF
Else
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Abre o arquivo no padr„o ASCII								   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	IF ( lRet := File( cArqSrv ) ) 
	   	nPos	:= 0 
   		IF ( Type( "aAliasRelo" ) <> "U" )
		   	//-- Verifica a necessidade de abrir o arquivo caso o mesmo não esteja aberto.
		    nPos := aScan( aAliasRelo , {|x| x[1] == cTxtAlias  .and.  x[04 ]  == cTipoArq .and. 	x[06] == cArquivo } )
		Endif
		If nPos == 0
			nHandle := fOpen( cArqSrv )
			IF ( fError() # 0 .or. nHandle < 0 )
				cMsgAlert := ( STR0156 + " " + cArqSrv )	//'Nao foi possivel abrir o arquivo:'
				lRet := .F.
			EndIF
		Endif	
	Else
		cMsgAlert := ( STR0058 + cArqSrv )				//"Arquivo do Relogio nao Encontrado no Servidor:
	EndIF
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Inclui o Alias aberto para posterior fechamento			   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	IF ( lEnchoice .and. nHandle > 0 )
		IF  ( ( nPos := aScan( aAliasRelo , {|x| x[1] == cTxtAlias  .and.  x[04 ]  == cTipoArq .and. 	x[06] == cArquivo } )) == 0 )
			aAdd( aAliasRelo , { ALLTRIM(cTxtAlias) , lCpyT2Srv , cArqSrv , cTipoArq , nHandle, cArquivo } )
		Else
			aAliasRelo[ nPos , 02 ] := lCpyT2Srv
			aAliasRelo[ nPos , 03 ]	:= cArqSrv
			aAliasRelo[ nPos , 04 ]	:= cTipoArq
			aAliasRelo[ nPos , 05 ]	:= nHandle
			aAliasRelo[ nPos , 06 ]	:= cArquivo
		EndIF
	EndIF
EndIF

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Mensagens de Nao Abertura dos Arquivos             		   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
IF ( lStop .and. !lRet )
	IF !Empty( cMsgAlert )
		MsgAlert( cMsgAlert , STR0059 ) //"Alerta"
	Else
		Help( "" , 1 , "A030NOPEN" )
	EndIF
EndIF

Return( lRet )


/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³fCloseArqRel³ Autor ³ Equipe Advanced RH  ³ Data ³29/02/1996³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Fecha o arquivo gerado pelo rel¢gio.                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³                                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/

Static Function fCloseArqRel(aAliasRelo, nFile, cTxtAlias, lCpyT2Srv, cArqSrv, cTipoArq, nHandle, cArq, cTxt, cArquivo)

//-- Quando o arquivo a ser consultado possuir o mesmo nome de algum arquivo anteriormente lido
//-- Fecha e elimina o arquivo anterior 
If ( cTxtAlias == cTxt)  .and. ( cArq  == cArquivo ) 
	 
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Fecha os Arquivos Abertos em AbreArqRel()					 			 ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	IF ( cTipoArq == "D" )
		TxtAliasClose( cTxtAlias )
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Se copiou para o server, Exclui                           			 ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		IF ( lCpyT2Srv )
			If ( fErase(Lower( cArqSrv ) ) < 0 )
					MsgAlert( fError() , STR0059 ) //"Alerta"
			Endif   
		EndIF
	ElseIF (;
				( cTipoArq == "T" );
				.and.;
				( nHandle > 0 );
			)	
		fClose( nHandle ) 
		If lCpyT2Srv .And. fErase(Lower( cArqSrv ) ) < 0
			MsgAlert( fError() , STR0059 ) //"Alerta"
		Endif   
	EndIF
	aAliasRelo[nFile, 1] := "DEL"
Endif
Return (NIL)

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ProcForm  ³ Autor ³ Wiliam                ³ Data ³ 29.02.96 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Rotina para tratamento da formula                          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Function ProcForm( cFormula )

Local bErro       := ErrorBlock( { |e| ErrorForm( e ) } )
Local lResult     := .T.

IF ( ValType( cFormula ) == "C" )
	cFormula := AllTrim( cFormula )
	IF Len(cFormula) > 0
		lResult := ExecForm( cFormula )
	EndIF
Else
	lResult := ExecForm( cFormula )
EndIF	

ErrorBlock( bErro )

Return( lResult )

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ExecForm	³ Autor ³ Wiliam                ³ Data ³ 29.02.96 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Executa a formula e retorna o resultado                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Static Function ExecForm( cFormula )

Local xRet
Begin Sequence
	xRet := &(cFormula)
	If !ValType( xRet ) == "C"
		Help(" ",1,"FNOCHAR" )
		xRet := .F.
	Else
		xRet := .T.
	Endif
	RECOVER
	Help(" ",1,"FORMINVAL" , , OemToAnsi( GetTitulo() ) , 5 , 0 )
	xRet := .F.
End Sequence

Return( xRet )
/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³GetTitulo ³ Autor ³ Mauricio MR           ³ Data ³ 16.09.02 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Obtem o Titulo em SX3 correspondente a variavel lida       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Static Function GetTitulo()

Local aArea			:= GetArea()
Local aAreaSX3 		:= SX3->( GetArea() )   
Local aAreaSXA 		:= SXA->( GetArea() )   
Local cCampo		:= UPPER(StrTran(ReadVar(),"M->",""))
Local cTitulo		:= ''          
Local cAlias      	:= ''
Local cFolder   	:= ''

SX3->(dbSetOrder(2)) 

//-- Obtem informacoes sobre o campo 
IF SX3->(dbSeek(cCampo))
   cTitulo		:=  STR0154 + X3Titulo()
   cAlias		:= GetSx3Cache(cCampo, "X3_ARQUIVO")
   cFolder		:= GetSx3Cache(cCampo, "X3_FOLDER")
    //-- Obtem Informacoes sobre o nome da Pasta se Existir
	If !Empty(cFolder)               
		IF SXA->( dbSeek(cAlias+cFolder) )
		   cTitulo:= STR0153+ALLTRIM(XADESCRIC()) + ' / ' +cTitulo
		Endif	
	Endif
Endif	

RestArea( aAreaSXA )
RestArea( aAreaSX3 ) 
RestArea( aArea) 

Return( cTitulo )

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ErrorForm ³ Autor ³ Wiliam                ³ Data ³ 29.02.96 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Rotina para tratamento de erros da formula                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Static Function ErrorForm( oError )

IF ( oError:gencode > 0 )
	Break
ENDIF

Return( NIL )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³fTabPadrao³ Autor ³ Equipe Advanced RH    ³ Data ³ 15/03/96 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Retorna um array com a tabela de hor rio padr„o do turno.   ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³fTabPadrao( aTabTno , cFil , cTurno )						³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³aTab   - Array com os Dados da Tabela                       ³
³          ³cFil   - Filial Para Pesquisa                               ³
³          ³cTurno - Turno para Pesquisa                                ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³ lRet                                                       ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³ Generico                                                   ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function fTabPadrao( aTabTno , cFil , cTurno , lExecQryTop , bCond )

Local aArray		:= {}
Local cAlias		:= "SPJ"
Local cAliasQuery	:= cAlias
Local cCustoSpace   := Space( GetSx3Cache( "RA_CC" , "X3_TAMANHO" ) )
Local cFilTno		:= ""
Local lRet      	:= .T.
Local lSpjIntSrep	:= .F.
Local nPos			:= 0
Local nLenTab		:= 0
Local nRecno		:= 0

Static aSpjFields
Static cQrySpjFields
Static nSpjFields

DEFAULT aTabTno			:= {}
DEFAULT cTurno			:= Space( GetSx3Cache( "RA_TNOTRAB" , "X3_TAMANHO" ) )
DEFAULT bCond			:= { || .T. }
DEFAULT __nLstTabPadPos	:= 0
                                       
cFil	:= xFilial( "SPJ" , cFil )
cFilTno := ( cFil + cTurno )

lSpjIntSrep	:= ( Type("SPJ->PJ_INTSREP") # "U" )

If ( ( ( nLenTab := Len( aTabTno ) ) == 0 ) .or. ( __nLstTabPadPos > nLenTab ) )
	__nLstTabPadPos := 0
EndIf

If ( ( __nLstTabPadPos == 0 ) .or. !( ( aTabTno[ __nLstTabPadPos , 01 ] + aTabTno[ __nLstTabPadPos , 02 ] ) == cFilTno ) )
	If ( ( nPos := aScan( aTabTno , { |x| x[1]+x[2] == cFilTno } ) ) == 0 ) .AND. !Empty(cTurno) 
		( aAdd( aTabTno, { cFil , cTurno , aArray } ) , ( __nLstTabPadPos := ( nLenTab := Len( aTabTno ) ) ) )
		
		cAliasQuery	:= cAlias
		lRet := ( cAliasQuery )->( dbSeek( cFilTno ) )

		If ( lRet )
			While ( cAliasQuery )->( !Eof() .and. ( cFilTno == PJ_FILIAL+PJ_TURNO ) )
				If !( cAliasQuery )->( Eval( bCond ) )
					( cAliasQuery )->( dbSkip() )
					Loop
				EndIf

				nRecno := ( cAliasQuery )->( Recno() )

				( cAliasQuery )->( aAdd( aTabTno[nLenTab,3 ] , {	PJ_ENTRA1		,;	// 01 - Primeira Entrada
							   				       					PJ_SAIDA1		,;	// 02 - Primeira Saida
								       								PJ_ENTRA2		,;	// 03 - Segunda Entrada
																	PJ_SAIDA2		,;	// 04 - Segunda Saida
																	PJ_ENTRA3		,;	// 05 - Terceira Entrada
																	PJ_SAIDA3		,;	// 06 - Terceira Saida
																	PJ_ENTRA4		,;	// 07 - Quarta Entrada
																	PJ_SAIDA4		,;	// 08 - Quarta Saida
																	PJ_HRSTRAB		,;	// 09 - Numero de Horas Trabalhadas 1a. Jornada
																	PJ_HRSTRA2		,;	// 10 - Numero de Horas Trabalhadas	2a. Jornada
																	PJ_HRSTRA3		,;	// 11 - Numero de Horas Trabalhadas 3a. Jornada
																	PJ_HRSTRA4		,;	// 12 - Numero de Horas Trabalhadas 4a. Jornada
																	PJ_HRSINT1  	,;	// 13 - Numero de Horas 1o. Intervalo
																	PJ_HRSINT2		,;	// 14 - Numero de Horas 2o. Intervalo
																	PJ_HRSINT3		,;	// 15 - Numero de Horas 3o. Intervalo
																	""       		,;	// 16 - Marcacao Refere-se ao Proximo Dia
																	0				,;	// 17 - TabMarc("SPJ")	Numero de Marcacoes da Tabela
																	PJ_TPDIA		,;  // 18 - Tipo do Dia
																	PJ_SEMANA		,;	// 19 - Sequencia da Marcacao
																	Val(PJ_DIA)		,;  // 20 - Numero Correspondente ao Dia da Semana
																	"N"				,;  // 21 - Refere-se a Excecao
																	""				,;  // 22 - Motivo da Excecao
																	PJ_TPEXT		,;  // 23 - Tipo de Extra Normal
																	PJ_TPEXTN		,;	// 24 - Tipo de Extra Noturna
																	cCustoSpace	    ,;	// 25 - Centro de Custo Periodo 1
																	cCustoSpace	    ,;  // 26 - Centro de Custo Periodo 2
																	cCustoSpace	    ,;	// 27 - Centro de Custo Periodo 3
																	cCustoSpace	    ,;	// 28 - Centro de Custo Periodo 4
																	PJ_NONAHOR 	    ,;	// 29 - Aponta Nona Hora
																	PJ_HORMENO	    ,;	// 30 - Limite de Horario Inicial
																	PJ_HORMAIS	    ,;	// 31 - Limite de Horario Final
																	PJ_JND1CON	    ,;	// 32 - 1a. Jornada Continua
																	PJ_JND2CON	    ,;	// 33 - 2a. Jornada Continua
																	PJ_JND3CON	    ,;	// 34 - 3a. Jornada Continua
																	PJ_JND4CON	    ,;	// 35 - 4a. Jornada Continua
																	PJ_CODREF	    ,;	// 36 - Codigo da Refeicao
																	nRecno			,;	// 37 - Recno
																	If(lPort1510 .And. lSpjIntSrep, PJ_INTSREP, '');	// 38 - Intervalo para geracao do ACJEF
														     	};
										);
								  )		 
				( cAliasQuery )->( dbSkip() )
			End While
		EndIf
	Else
	   	If nPos > 0
			__nLstTabPadPos := nPos
		EndIf
	EndIf
EndIf	

Return( lRet )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³GetInfoPosTab³Autor³ Marinaldo de Jesus   ³ Data ³17/10/2001³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Retorna o Conteudo da Tabela de Horario Padrao Conforme   os³
³          ³Parametros Passados											³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Ponto Eletronico                                            ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³nSerFim                            							³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function GetInfoPosTab(	nPosTip 	,;	//01 -> Posicao em aTabCalend para Obtencao da Informacao
						cFlagMarc	,;	//02 -> Flag da Marcacao "1E,1S,..."
						dData		,;	//03 -> Data em aTabCalend
						aTabCalend	,;	//04 -> Calendario de Marcacoes
						aTabPadrao	,;	//05 -> Tabela de Horario Padrao
						dPerIni		,;	//06 -> Periodo Inicial de Apontamento
						dPerFim		,;	//07 -> Periodo Final de Apontamento	
						lFunc		,;	//08 -> Informacao Referente a Funcionario
						cTno		,;	//09 -> Turno de Trabalho
						cSeq		,;	//10 -> Sequencia
						cFil		,;	//11 -> Filial
						lExce		,;  //12 -> Carrega Excecoes 
						bAscan		,;	//13 -> Bloco para Pesquisa em aTabCalend
						nRetPosTab  ;	//14 -> Retorno da Posicao do aTabCalend 	
					   )

Local aSvTabsCal	:= {}
Local cOrdem		:= ""
Local lContinua		:= .T.
Local lLastMarc		:= .F.
Local nPosTab		:= 0
Local nLenCalend	:= 0
Local uRet			:= NIL

IF ( ( Type("aTnoGetInfoTab") == "U" ) .or. ( Type("aTnoGetInfoTab") != "A" ) )
	Private aTnoGetInfoTab := {}
EndIF	

DEFAULT nPosTip		:= CALEND_POS_TURNO
DEFAULT cFlagMarc	:= "1E"
DEFAULT dData		:= dDataBase
DEFAULT aTabCalend	:= {}
DEFAULT aTabPadrao	:= {}
DEFAULT dPerIni		:= Ctod("//")
DEFAULT dPerFim		:= Ctod("//")
DEFAULT lFunc		:= .T.
DEFAULT cTno		:= SRA->RA_TNOTRAB
DEFAULT cSeq		:= SRA->RA_SEQTURN
DEFAULT cFil		:= SRA->RA_FILIAL
DEFAULT lExce		:= .F.
DEFAULT bAscan		:= { |x| x[CALEND_POS_DATA] == dData .and. x[CALEND_POS_TIPO_MARC] == cFlagMarc }

IF ( lLastMarc := ( ( cFlagMarc := Upper( AllTrim( cFlagMarc ) ) ) == "__LASTMARC__" ) )
	cFlagMarc := "1E"
EndIF

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Verifica se o Calendario foi passado como parametro		  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
IF Empty( aTabCalend )
	IF ( Empty( dPerIni ) .or. Empty( dPerFim ) )
		lContinua := PerAponta( @dPerIni , @dPerFim , dData , NIL , cFil )
	EndIF
	IF ( lContinua )
        /*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Salva o Conteudo do Calendario por Turno        			  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		aSvTabsCal := GetTabCal()
        /*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Cria o Calendario de Marcacoes                  			  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		lContinua := CriaCalend(	dPerIni 								,;	//01 -> Data Inicial do Periodo
				   					Min( dPerFim , dData )					,;	//02 -> Data Final do Periodo
							   		cTno									,;	//03 -> Turno Para a Montagem do Calendario
							   		cSeq									,;	//04 -> Sequencia Inicial para a Montagem Calendario
							   		@aTabPadrao								,;	//05 -> Array Tabela de Horario Padrao
							   		@aTabCalend								,;	//06 -> Array com o Calendario de Marcacoes
							   		cFil     								,;	//07 -> Filial para a Montagem da Tabela de Horario
							   		IF(lFunc,SRA->RA_MAT,NIL)  				,;	//08 -> Matricula para a Montagem da Tabela de Horario
							   		IF(lFunc .and. lExce,SRA->RA_CC,NIL)	,;	//09 -> Centro de Custo para a Montagem da Tabela
							   		IF(lFunc,@aTnoGetInfoTab,NIL)	 		,;  //10 -> Array com as Trocas de Turno
							   		NIL										,;	//11 -> Array com Todas as Excecoes do Periodo
									NIL										,;	//12 -> Se executa Query para a Montagem da Tabela Padrao
									.F.										,;	//13 -> Se executa a funcao se sincronismo do calendario
									NIL										 ;	//14 -> Se Forca a Criacao de Novo Calendario
							  	  )
	EndIF
EndIF

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Efetua a Pesquisa e Retorna o Conteudo do Elemento Desejado  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
IF ( lContinua )
	IF ( ( nPosTab := aScan( aTabCalend , bAscan ) ) > 0 )
		IF ( ( nPosTip > 0 ) .and. nPosTip <= Len( aTabCalend[ nPosTab ] ) )
			IF ( lLastMarc )
				cOrdem		:= aTabCalend[ nPosTab , CALEND_POS_ORDEM ]
				nLenCalend	:= Len( aTabCalend )
				While ( nPosTab <= nLenCalend )
					IF !( cOrdem == aTabCalend[ nPosTab , CALEND_POS_ORDEM ] )
						--nPosTab
						Exit
					EndIF
					IF ( nPosTab < nLenCalend )
						++nPosTab
					Else
						Exit
					EndIF
				End While	
			EndIF
			IF ( ValType( aTabCalend[ nPosTab , nPosTip ] ) == "A" )
				uRet := aClone( aTabCalend[ nPosTab , nPosTip ] )
			Else
				uRet := aTabCalend[ nPosTab , nPosTip ]
			EndIF	
		EndIF
	EndIF
EndIF

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Se nao Obteve retorno Carrega valores DEFAULT                ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
IF ( ( uRet == NIL ) .and. ( nPosTip > 0 ) )

	nRetPosTab	:= 0

	Do Case 
		Case nPosTip == CALEND_POS_DATA			; uRet := Ctod("//")
		Case nPosTip == CALEND_POS_ORDEM		; uRet := ""
		Case nPosTip == CALEND_POS_HORA			; uRet := 0
		Case nPosTip == CALEND_POS_TIPO_MARC	; uRet := ""
		Case nPosTip == CALEND_POS_NUM_MARC 	; uRet := 0
		Case nPosTip == CALEND_POS_TIPO_DIA 	; uRet := ""
		Case nPosTip == CALEND_POS_HRS_TRABA	; uRet := 0
		Case nPosTip == CALEND_POS_SEQ_TURNO	; uRet := Space(TamSX3("PF_SEQUEDE")[1])
		Case nPosTip == CALEND_POS_HRS_INTER	; uRet := 0
		Case nPosTip == CALEND_POS_EXCECAO		; uRet := ""
		Case nPosTip == CALEND_POS_MOT_EXECAO	; uRet := ""
		Case nPosTip == CALEND_POS_TIPO_HE_NOR	; uRet := ""
		Case nPosTip == CALEND_POS_TIPO_HE_NOT	; uRet := ""
		Case nPosTip == CALEND_POS_TURNO		; uRet := Space(TamSX3("PF_TURNODE")[1])
		Case nPosTip == CALEND_POS_CC			; uRet := ""
		Case nPosTip == CALEND_POS_PG_NONA_HORA	; uRet := ""
		Case nPosTip == CALEND_POS_LIM_MARCACAO	; uRet := { Ctod("//") , 0 }
		Case nPosTip == CALEND_POS_COD_REFEICAO	; uRet := ""
		Case nPosTip == CALEND_POS_FERIADO		; uRet := .F.
		Case nPosTip == CALEND_POS_TP_HE_FER_NR	; uRet := ""
		Case nPosTip == CALEND_POS_TP_HE_FER_NT	; uRet := ""
		Case nPosTip == CALEND_POS_DESC_FERIADO ; uRet := ""
		Case nPosTip == CALEND_POS_REGRA		; uRet := Space(TamSX3("PF_REGRADE")[1])
		Case nPosTip == CALEND_POS_AFAST		; uRet := ""
		Case nPosTip == CALEND_POS_TIP_AFAST	; uRet := ""
		Case nPosTip == CALEND_POS_INI_AFAST	; uRet := Ctod("//")
		Case nPosTip == CALEND_POS_FIM_AFAST	; uRet := Ctod("//")
		Case nPosTip == CALEND_POS_INI_H_NOT	; uRet := 0
		Case nPosTip == CALEND_POS_FIM_H_NOT	; uRet := 0
		Case nPosTip == CALEND_POS_MIN_H_NOT	; uRet := 0
		Case nPosTip == CALEND_POS_TRAB_FERIADO	; uRet := .F.
		Case nPosTip == CALEND_POS_APON_FERIAS  ; uRet := .F.
		Case nPosTip == CALEND_POS_TP_HE_NR_FER ; uRet := ""
		Case nPosTip == CALEND_POS_TP_HE_NT_FER ; uRet := ""
		Case nPosTip == CALEND_POS_PAGINT		; uRet := ""
		Case nPosTip ==	CALEND_POS_TIPO_ORIG_DIA; uRet := "" 
		Case nPosTip ==	CALEND_POS_HE_AUTO_FER  ; uRet := .T. 
		Case nPosTip ==	CALEND_POS_CODFUNC		; uRet := "" 
		Case nPosTip ==	CALEND_POS_DEPTO		; uRet := "" 
		Case nPosTip ==	CALEND_POS_POSTO		; uRet := "" 
		Case nPosTip ==	CALEND_POS_PERIODO		; uRet := "" 
		Case nPosTip ==	CALEND_POS_ROTEIRO		; uRet := "" 
		Case nPosTip ==	CALEND_POS_PROCESSO		; uRet := "" 
		Case nPosTip ==	CALEND_POS_NUM_PAGTO	; uRet := "" 
		Case nPosTip ==	CALEND_POS_JORN			; uRet := "" 
		Case nPosTip ==	CALEND_POS_P2ID			; uRet := "" 
		Case nPosTip ==	CALEND_POS_R8ID			; uRet := "" 
		Case nPosTip ==	CALEND_POS_DATA_APO		; uRet := "" 
		Case nPosTip ==	CALEND_POS_JND_CON		; uRet := "" 
		Case nPosTip ==	CALEND_POS_LIE			; uRet := "" 
		Case nPosTip ==	CALEND_POS_LSE			; uRet := "" 
		Case nPosTip ==	CALEND_POS_LIS			; uRet := "" 
		Case nPosTip ==	CALEND_POS_LSS			; uRet := "" 
		Case nPosTip ==	CALEND_POS_INTSREP		; uRet := "" 		
	EndCase
Else
	nRetPosTab := nPosTab
EndIF

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Restaura o Conteudo do Calendario por Turno        		  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
IF !Empty( aSvTabsCal )
	SetTabCal( aSvTabsCal )
EndIF	

Return( uRet )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³RstTabPadrao	³Autor³Marinaldo de Jesus ³ Data ³11/03/2003³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Reinicializa as Staticas utilizadas em fTabPadrao()        	³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico													³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function RstTabPadrao()
Return( ( __nLstTabPadPos := NIL ) )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³CriaCalend³ Autor ³ Marinaldo de Jesus    ³ Data ³15/12/2003³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Alimenta um Array com o Calend rio de um Per¡odo.           ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³< Vide Parametros Formais >								    ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³< Vide Parametros Formais >									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³ Generico                                                   ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function CriaCalend(	dDataIni	,; //01 -> Data Inicial do Periodo
		 				dDataFim	,; //02 -> Data Final do Periodo
						cTno		,; //03 -> Turno Para a Montagem do Calendario
						cSeq		,; //04 -> Sequencia Inicial para a Montagem Calendario
						aTabPadrao	,; //05 -> Array Tabela de Horario Padrao
						aTabCalend	,; //06 -> Array com o Calendario de Marcacoes
						cFil		,; //07 -> Filial para a Montagem da Tabela de Horario
						cMat		,; //08 -> Matricula para a Montagem da Tabela de Horario
						cCc			,; //09 -> Centro de Custo para a Montagem da Tabela
						aTurnos		,; //10 -> Array com as Trocas de Turno
						aExcePer	,; //11 -> Array com Todas as Excecoes do Periodo
						lExecQryTop ,; //12 -> Se executa Query para a Montagem da Tabela Padrao
						lSncMaMe	,; //13 -> Se executa a funcao se sincronismo do calendario
						lForceNew	,; //14 -> Se Forca a Criacao de Novo Calendario
						aMarcacoes  ,; //15 -> Array com marcacoes para tratamento de Turnos Opcionais
						lExcecoes 	,; //16 -> Se considera as exceções cadastradas
						lGPEXPER 	,; //17 -> Chamada do GPEXPER
						lUsaFilMat	,; //18 -> Considera a SRA posicionada para a montagem do calendário
						nSomaDias	 ; //19 -> Adiciona a quantidade de dias no inicio do período para buscar trocas de turnos
					)

Local lCriaCalOk	:= .T.
Local lNewCalend	:= .F.
Local lChkMat		:= ( cMat <> NIL )
Local lAcumulado	:= .F.
Local aTipo
Local aTabAux		:= {} 
Local dDataAux
Local dPerIni
Local dPerFim
Local dPerAuxIni
Local dPerAuxFim
Local dIniCalend
Local dFimCalend
Local bQualSeq
Local nPosTrcT
Local nLoop
Local nLoops
Local cReg

DEFAULT lSncMaMe	:= .F.
DEFAULT lForceNew	:= .T.
DEFAULT aMarcacoes	:= {}
DEFAULT __lChkTnoOpc	:= SuperGetMv("MV_TNOOPC",NIL,"N") == "S"
DEFAULT lPnmTabCalen	:= ExistBlock( "PNMTABC01" )
DEFAULT lExcecoes	:= .T.
DEFAULT lGPEXPER	:= .F.
DEFAULT lUsaFilMat	:= .T.
DEFAULT nSomaDias	:= 0

Begin Sequence

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Garanto que dDataFim nunca sera menor que dDataIni          ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	IF ( dDataFim < dDataIni )
		dDataAux := dDataIni
		dDataIni := dDataFim
		dDataFim := dDataAux	
	EndIF

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Verifica se Devera Criar Novo Calendario                    ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	IF ( ( lChkMat ) .and. ( lForceNew ) )
		IF ( ( __dPerCalIni == NIL ) .or. ( __dPerCalFim == NIL ) )
			IF !( lCriaCalOk := GetPonMesDat( @__dPerCalIni , @__dPerCalFim , cFil ) )
				Break
			EndIF
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Garanto que __dPerCalFim nunca sera menor que __dPerCalIni  ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			IF ( __dPerCalFim < __dPerCalIni )
				dDataAux 		:= __dPerCalIni
				__dPerCalIni	:= __dPerCalFim
				__dPerCalFim	:= dDataAux	
			EndIF
		EndIF	
		dPerIni := __dPerCalIni
		dPerFim := __dPerCalFim
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Forca a Criacao de um novo Calendario sempre que o   Periodo³
		³ for Diferente do Periodo Atual para que Busquemos o Turno	 e³
		³ a Sequencia Referentes a Data Inicial de Geracao do  Calenda³
		³ rio														  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		lNewCalend := ( dDataIni <> dPerIni ) .Or. lGPEXPER
	Else
		dPerIni := dDataIni
		dPerFim := dDataFim
	EndIF					  

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Para Periodos Anteriores Criar novo Calendario apenas Quando³
	³ nao Existir Troca de Turno para o Inicio do Periodo         ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	IF ( ( lChkMat ) .and. ( lForceNew ) )
		IF !( lNewCalend ) 
			IF ( dDataFim < dPerIni )
				/*/
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Remonta o Calendario Apenas se Nao Existir Troca de Turno pa³
				³ ra o Primeiro dia da Montagem do Calendario                 ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
				fTrocaTno( Min( dPerIni , dDataIni ) , Max( dPerFim , dDataFim ) , @aTurnos , NIL , NIL , .F. )
				IF ( lNewCalend := ( ( nPosTrcT := aScan( aTurnos , { |x| x[2] == If(dDataIni < SRA->RA_ADMISSA .and. dDataFim >= SRA->RA_ADMISSA, SRA->RA_ADMISSA, dDataIni) } ) ) == 0 ) )
					/*/
					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					³ Para Periodos Anteriores Criar novo Calendario apenas Quando³
					³ nao Existir Troca de Turno para o Inicio do Periodo         ³
					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
					IF ( Len( aTurnos ) > 0 )
						dPerIni	:= aTurnos[ 01 , 02 ]
						dPerFim := ( dPerIni + ( ( dDataFim - dDataIni ) + 1 ) )
						cTno	:= aTurnos[ 01 , 01 ]
						cSeq	:= aTurnos[ 01 , 03 ]
					EndIF
				Else
					/*/
					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					³ Se Tiver Troca de Turno, os Turnos e Sequencias Serao  Retor³
					³ nados pelo Proprio Calendario                               ³
					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
					dPerIni := dDataIni
					dPerFim := dDataFim
					cTno	:= aTurnos[ nPosTrcT , 01 ]
					cSeq	:= aTurnos[ nPosTrcT , 03 ]
				EndIF
			EndIF	
		Else
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Remonta o Calendario Apenas se Nao Existir Troca de Turno pa³
			³ ra o Primeiro dia da Montagem do Calendario                 ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			fTrocaTno( Min( dPerIni , dDataIni ) , Max( dPerFim , dDataFim ) , @aTurnos , NIL , NIL , .F. )
			IF !( lNewCalend := ( ( nPosTrcT := aScan( aTurnos , { |x| x[2] == If(dDataIni < SRA->RA_ADMISSA .and. dDataFim >= SRA->RA_ADMISSA, SRA->RA_ADMISSA, dDataIni) } ) ) == 0 ) )
				dPerIni	:= dDataIni
				dPerFim	:= dDataFim
				cTno	:= aTurnos[ nPosTrcT , 01 ]
				cSeq	:= aTurnos[ nPosTrcT , 03 ]
			EndIF
		EndIF
	EndIF
	
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Verifica a Data para a Montagem do 1o Calendario			  ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	IF ( lNewCalend )
		IF ( dDataIni > dPerFim )
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Inicio do Periodo Solicitado Posterior ao Periodo em Aberto ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			IF ( aScan( aTurnos , { |x| x[2] > dPerFim .and. x[2] <= dDataFim } ) > 0 )
				/*/
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Se Houver Troca de Turno, considera a Menor e a Maior   Data³
				³ para a Montagem do Calendario para que sejam Consideradas as³
				³ Trocas de Turno											  ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
				dIniCalend	:= Min( dPerIni , dDataIni )
				dFimCalend	:= Max( dPerFim , dDataFim )
			Else
				/*/
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Caso Contrario o Turno e a Sequencia serao retornados   pela³
				³ fQualSeq()												  ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
				dIniCalend	:= dPerIni
				dFimCalend	:= dPerFim
			EndIF
		ElseIF ( dDataFim < dPerIni )
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Final do Periodo Solicitado Anterior ao Periodo em Aberto   ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			dIniCalend	:= dPerIni
			dFimCalend	:= dPerFim
		ElseIF ( dDataIni <> dPerIni )
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Periodo Solicitado Diferente do Periodo em Aberto			  ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			dIniCalend	:= Min( dPerIni , dDataIni )
			dFimCalend	:= Max( dPerFim , dDataFim )
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Se Nao Tiver Troca de Turno no Inicio do Periodo para a Gera³
			³ cao do Primeiro Calendario, Verifica o Periodo Anterior	  ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			IF ( aScan( aTurnos , { |x| x[2] == dIniCalend } ) == 0 )
				dPerAuxIni := dPerIni
				dPerAuxFim := dPerFim
				/*/
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Cria o Calendario do Periodo Anterior                       ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
				IF !( lCriaCalOk := PerAponta( @dPerAuxIni , @dPerAuxFim , ( dPerIni - 1 ) , .F. , cFil , .T. , NIL , .F. , .T. ) )
					Break
				EndIF
				/*/
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Carrega as Trocas de Turno a Partir do Inicio do Periodo  An³
				³ Terior													  ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
				fTrocaTno( dPerAuxIni , dFimCalend , @aTurnos , NIL , NIL , .F. )
				/*/
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Busca a Primeira Troca inferior ao Periodo para a Geracao do³
				³ Calendario          										  ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
				IF ( ( nPosTrcT := aScan( aTurnos , { |x| x[2] <= dIniCalend } ) ) > 0 )
					/*/
					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					³ Busca a Troca mais Proxima                                  ³
					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
					nLoops := ( nPosTrcT + 1 )
					While ( ( nLoops := aScan( aTurnos , { |x| x[2] <= dIniCalend } , nLoops ) ) > 0 )
						nPosTrcT := nLoops
						++nLoops
					End While
					/*/
					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					³ Adiciona a Troca de Turno para o Inicio do Periodo para a Ge³
					³ racao do Calendario										  ³
					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
					IF ( nPosTrcT > 0 )
						aAdd( aTurnos , aClone( aTurnos[ nPosTrcT ] ) )
						aTurnos[ Len( aTurnos ) , 02 ] := dIniCalend
						/*/
						ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						³ Ordena as Trocas por Ordem de Data						  ³
						ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
						aSort( @aTurnos , NIL , NIL , { |x,y| ( x[2] < y[2] ) } )
					EndIF
				EndIF
			EndIF
		ElseIf lGPEXPER
			dIniCalend	:= dPerIni
			dFimCalend	:= dDataFim		
		EndIF
	Else
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Neste Caso o Periodo Solicitado eh Equivalente ao Periodo em³
		³ Aberto													  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		If nSomaDias > 0
			dIniCalend	:= dPerIni - nSomaDias
		Else
			dIniCalend	:= dPerIni
		EndIf
		dFimCalend	:= dPerFim
	EndIF     
    
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Verifica Se Calendario e do Periodo Anterior			  	  ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
    lAcumulado := ( dFimCalend < dPerIni )
	
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Cria o Calendario do Periodo Atual       				  	  ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	IF !( lCriaCalOk := CalendCria(	dIniCalend								,; //01 -> Data Inicial do Periodo
									dFimCalend								,; //02 -> Data Final do Periodo
									cTno									,; //03 -> Turno Para a Montagem do Calendario
									cSeq									,; //04 -> Sequencia Inicial para a Montagem Calendario
									@aTabPadrao								,; //05 -> Array Tabela de Horario Padrao
									@aTabCalend								,; //06 -> Array com o Calendario de Marcacoes
									cFil									,; //07 -> Filial para a Montagem da Tabela de Horario
									cMat									,; //08 -> Matricula para a Montagem da Tabela de Horario
									cCc										,; //09 -> Centro de Custo para a Montagem da Tabela
									@aTurnos								,; //10 -> Array com as Trocas de Turno
									@aExcePer								,; //11 -> Array com Todas as Excecoes do Periodo
									lExecQryTop 							,; //12 -> Se executa Query para a Montagem da Tabela Padrao
									( ( lSncMaMe ) .and. !( lNewCalend ) )	,; //13 -> Se executa a funcao se sincronismo do calendario
									lAcumulado								,; //14 -> Se o Calendario eh do periodo anterior
									aMarcacoes								,; //15 -> Array de Marcacoes para tratamento de Turnos Opcionais
									NIL										,; //16 -> Regra de apontamento
									NIL										,; //17 -> Se atualiza tada dDataIni com a data da última trica de turno
									lExcecoes 	 							,; //18 -> Se considera as exceções cadastradas
									lUsaFilMat 	 							 ; //19 -> Considera a SRA posicionada para a montagem do calendário
								);
		)
		Break
	EndIF

	If nSomaDias > 0
		dIniCalend	:= dIniCalend + nSomaDias
	EndIf

	If dIniCalend > aTabCalend[1,CALEND_POS_DATA_APO]
		For nLoop := 1 to Len(aTabCalend)
			If aTabCalend[nLoop,CALEND_POS_DATA_APO] >= dIniCalend
				aAdd(aTabAux,aTabCalend[nLoop])
			EndIf
		Next nLoop
		If !Empty( aTabAux )
			aSort(aTabAux,,,{|x,y| x[CALEND_POS_ORDEM ]+x[CALEND_POS_TIPO_MARC] < y[CALEND_POS_ORDEM ]+y[CALEND_POS_TIPO_MARC] })
			aTabCalend := {}
			aTabCalend := aClone(aTabAux)
		EndIf
	EndIf

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Se nao for Criar novo Calendario, Abandona				  ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	IF !( lNewCalend )
		Break
	EndIF

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Obtem o Turno para o Novo Calendario       			  	  ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	cTno	:= GetInfoPosTab(	CALEND_POS_TURNO	,;	//01 -> Posicao em aTabCalend para Obtencao da Informacao
								"1E"				,;	//02 -> Flag da Marcacao "1E,1S,..."
								dDataIni			,;	//03 -> Data em aTabCalend
								aTabCalend			 ;	//04 -> Calendario de Marcacoes
				   		 	)
	IF Empty( cTno )
		IF ( dDataFim < dPerIni )
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Pode Ocorrer Turno em Branco para Periodo Anterior		  ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			cTno := GetInfoPosTab(	CALEND_POS_TURNO	,;	//01 -> Posicao em aTabCalend para Obtencao da Informacao
									"1E"				,;	//02 -> Flag da Marcacao "1E,1S,..."
									dIniCalend			,;	//03 -> Data em aTabCalend
									aTabCalend			 ;	//04 -> Calendario de Marcacoes
					   		 	 )
		Else
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Ou Quando a Existe Jornada Continua e a Data Inicial nao cor³
			³ responte ao Inicio da Jornada								  ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			aTipo	:= { "1E" , "1S" , "2E" , "2S" , "3E" , "3S" , "4E" , "4S" }
			nLoops	:= Len( aTipo )
			For nLoop := 2 To nLoops
				cTno := GetInfoPosTab(	CALEND_POS_TURNO	,;	//01 -> Posicao em aTabCalend para Obtencao da Informacao
										aTipo[ nLoop ]		,;	//02 -> Flag da Marcacao "1E,1S,..."
										dDataIni			,;	//03 -> Data em aTabCalend
										aTabCalend			 ;	//04 -> Calendario de Marcacoes
					 	 			  )
				IF !Empty( cTno )
					Exit
				EndIF
			Next nLoop
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Se ainda assim nao achou o turno, procura a Partir do  Perio³
			³ do Final do Periodo em Aberto                               ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			IF Empty( cTno )
				dPerIni := ( dPerFim - 1 )
				While ( Empty( cTno ) .and. ( ( ++dPerIni ) < dDataFim ) )
					For nLoop := 1 To nLoops
						cTno := GetInfoPosTab(	CALEND_POS_TURNO	,;	//01 -> Posicao em aTabCalend para Obtencao da Informacao
												aTipo[ nLoop ]		,;	//02 -> Flag da Marcacao "1E,1S,..."
												dPerIni				,;	//03 -> Data em aTabCalend
												aTabCalend			 ;	//04 -> Calendario de Marcacoes
							 	 			  )
						IF !Empty( cTno )
							Exit
						EndIF
					Next nLoop
				End While
			EndIF
		EndIF
	EndIF					   		 	

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Obtem a Sequencia para o Novo Calendario       			  ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	cSeq	:= GetInfoPosTab(	CALEND_POS_SEQ_TURNO	,;	//01 -> Posicao em aTabCalend para Obtencao da Informacao
								"1E"					,;	//02 -> Flag da Marcacao "1E,1S,..."
								dDataIni				,;	//03 -> Data em aTabCalend
								aTabCalend				 ;	//04 -> Calendario de Marcacoes
				   		 	)

/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Obtem a Regra para o Novo Calendario  	     			  ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/				   		 	
	cReg	:= GetInfoPosTab(	CALEND_POS_REGRA		,;	//01 -> Posicao em aTabCalend para Obtencao da Informacao
								"1E"					,;	//02 -> Flag da Marcacao "1E,1S,..."
								dDataIni				,;	//03 -> Data em aTabCalend
								aTabCalend				 ;	//04 -> Calendario de Marcacoes
				   		 	)

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Retorna a Sequencia do Proximo Periodo 					  ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	bQualSeq	:= { || IF( Empty( cSeq ) , fQualSeq( aClone( aTabCalend ) , @aTabPadrao , dDataIni , cTno, aClone( aTurnos ) ) , cSeq ) }
	
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Cria o Calendario do Periodo Selecionado					  ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	IF !( lCriaCalOk := CalendCria(	dDataIni			,; //01 -> Data Inicial do Periodo
									dDataFim			,; //02 -> Data Final do Periodo
									cTno				,; //03 -> Turno Para a Montagem do Calendario
									Eval( bQualSeq )	,; //04 -> Sequencia Inicial para a Montagem Calendario
									@aTabPadrao			,; //05 -> Array Tabela de Horario Padrao
									@aTabCalend			,; //06 -> Array com o Calendario de Marcacoes
									cFil				,; //07 -> Filial para a Montagem da Tabela de Horario
									cMat				,; //08 -> Matricula para a Montagem da Tabela de Horario
									cCc					,; //09 -> Centro de Custo para a Montagem da Tabela
									@aTurnos			,; //10 -> Array com as Trocas de Turno
									@aExcePer			,; //11 -> Array com Todas as Excecoes do Periodo
									lExecQryTop 		,; //12 -> Se executa Query para a Montagem da Tabela Padrao
									lSncMaMe			,; //13 -> Se executa a funcao se sincronismo do calendario
									NIL					,; //14 -> Se o Calendario eh do Periodo anterior 
									NIL					,; //15 -> Array de marcacoes para tratamento de Turnos Opcionais
									cReg				,; //16 -> Regra de apontamento
									.F.					,; //17 -> Se atualiza tada dDataIni com a data da última trica de turno
									lExcecoes 	 		 ; //18 -> Se considera as exceções cadastradas
								);
		)
		Break
	EndIF			  			
	If dIniCalend > aTabCalend[1,CALEND_POS_DATA_APO]
		For nLoop := 1 to Len(aTabCalend)
			If aTabCalend[nLoop,CALEND_POS_DATA_APO] >= dIniCalend
				aAdd(aTabAux,aTabCalend[nLoop])
			EndIf
		Next nLoop
		If !Empty( aTabAux )
			aSort(aTabAux,,,{|x,y| x[CALEND_POS_ORDEM ]+x[CALEND_POS_TIPO_MARC] < y[CALEND_POS_ORDEM ]+y[CALEND_POS_TIPO_MARC] })
			aTabCalend := {}
			aTabCalend := aClone(aTabAux)
		EndIf
	EndIf
End Sequence

// Funcionário intermitente
If lCriaCalOk .And. SRA->RA_TPCONTR == "3"
	
	DiasConvoc(@aTabCalend)
	
EndIf

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Ponto de Entrada para edicao do array aTabCalend             ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
IF ( lPnmTabCalen )
	IF ( ValType( uRet := ExecBlock("PNMTABC01",.F.,.F., { aTabCalend, lCriaCalOk, cFil, cMat }) ) == "A" )
		aTabCalend := aClone(uRet)
		uRet	   := NIL
	EndIF
ElseIf lAutoGS .AND. TecExecPNM()
	IF ( ValType( uRet := TecPNMTAB( aTabCalend, lCriaCalOk, cFil, cMat) ) == "A" )
		aTabCalend := aClone(uRet)
		uRet	   := NIL
	EndIF
EndIF

Return( lCriaCalOk )


/*/{Protheus.doc} DiasConvoc
Altera os dias que não tem convocação para não trabalhado
Altera o Centro de custo conforme a convocação
@type static function
@author Cí­cero Alves
@since 20/02/2025
@param aTabCalend, array, Calendário do Ponto
@return nil, nil
/*/
Static Function DiasConvoc(aTabCalend)
	
	Local nI 		:= 1
	Local nPosConv	:= 0
	Local clastOrd	:= "***"
	Local aConvoc 	:= {}
	
	Private lContrInt 	:= SRC->(ColumnPos("RC_CONVOC")) > 0
	
	aConvoc := BuscaConv(aTabCalend[1][CALEND_POS_DATA], aTabCalend[Len(aTabCalend)][CALEND_POS_DATA], .T.)
	
	While nI <= Len(aTabCalend)
		
		clastOrd := aTabCalend[nI][CALEND_POS_ORDEM]
		
		If (nPosConv := aScan(aConvoc, {|x| aTabCalend[nI][CALEND_POS_DATA_APO] >= x[2] .And. aTabCalend[nI][CALEND_POS_DATA_APO] <= x[3] })) == 0
			While nI <= Len(aTabCalend) .And. aTabCalend[nI][CALEND_POS_ORDEM] == clastOrd
				aTabCalend[nI][CALEND_POS_TIPO_DIA] := "N"
				aTabCalend[nI][CALEND_POS_TIPO_ORIG_DIA] := "N"
				clastOrd := aTabCalend[nI][CALEND_POS_ORDEM]
				nI++
			EndDo
		ElseIf Len(aConvoc[nPosConv]) > 11
			While nI <= Len(aTabCalend) .And. aTabCalend[nI][CALEND_POS_ORDEM] == clastOrd
				aTabCalend[nI][CALEND_POS_CC] := If(!Empty(aConvoc[nPosConv][12]), aConvoc[nPosConv][12], aTabCalend[nI][CALEND_POS_CC])
				clastOrd := aTabCalend[nI][CALEND_POS_ORDEM]
				nI++
			EndDo
		EndIf
		
	EndDo
	
Return


/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³RstCriaCalend	³Autor³Marinaldo de Jesus ³ Data ³11/03/2003³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Reinicializa as Staticas utilizadas em CriaCalend()        	³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico													³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function RstCriaCalend()

__dPerCalIni	:= NIL
__dPerCalFim	:= NIL

Return( NIL )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³CalendCria³Autores   ³                      ³    ³          ³
³          ³          ³Versao I  ³Equipe Advanced RH    ³Data³24/11/1997³
³          ³          ³Versao II ³Marinaldo de Jesus    ³Data³18/09/2003³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Alimenta um Array com o Calend rio de um Per¡odo.           ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³< Vide Parametros Formais >								    ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³< Vide Parametros Formais >									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico                                                    ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function CalendCria(	dDataIni	,; //01 -> Data Inicial do Periodo
		 				dDataFim	,; //02 -> Data Final do Periodo
						cTno		,; //03 -> Turno Para a Montagem do Calendario
						cSeq		,; //04 -> Sequencia Inicial para a Montagem Calendario
						aTabPadrao	,; //05 -> Array Tabela de Horario Padrao
						aTabCalend	,; //06 -> Array com o Calendario de Marcacoes
						cFil		,; //07 -> Filial para a Montagem da Tabela de Horario
						cMat		,; //08 -> Matricula para a Montagem da Tabela de Horario
						cCc			,; //09 -> Centro de Custo para a Montagem da Tabela
						aTurnos		,; //10 -> Array com as Trocas de Turno
						aExcePer	,; //11 -> Array com Todas as Excecoes do Periodo
						lExecQryTop ,; //12 -> Se executa Query para a Montagem da Tabela Padrao
						lSncMaMe	,; //13 -> Se executa a funcao se sincronismo do calendario
						lAcumulado	,; //14 -> Se o Calendario eh do Periodo anterior 
						aMarcacoes  ,; //15 -> Array de marcacoes para tratamento de Turnos Opcionais
						cReg		,; //16 -> Regra de apontamento
						lDtIni		,; //17 -> se atualiza data inicial com base nas trocas de turno
						lExcecoes 	,; //18 -> Se considera as exceções cadastradas
						lUsaFilMat 	 ; //19 -> Considera a SRA posicionada para a montagem do calendário
					)

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Variaveis de Inicializacao Obrigatoria					  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Local aMarcId	 		:= { NIL , NIL }
Local aTipo				:= { "1E" , "1S" , "2E" , "2S" , "3E" , "3S" , "4E" , "4S" }
Local aOrdens			:= {}
Local cOrdem			:= ""
Local dDataApo			:= Ctod("")
Local lCriaCalOk		:= .T.
Local lForceSinc		:= .F.
Local lExistTrcTno 		:= .F.
Local lBldNewOrd		:= .F. 
Local nDias				:= 0 
Local nSeq				:= 0
Local nFornY			:= Len( aTipo )
Local nOrdem			:= 0

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Variaveis que serao inicializadas para Turnos Opcionais	  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Local aDiaTurnoOK
/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Variaveis que serao inicializadas no Corpo da Funcao		  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Local aExcecoes
Local aTabTno
Local aTabOrig
Local aAfasta   
Local aSvAlias		:= {}
Local aTnoOpcData 	:= {}
Local bAsc

Local cFilSP3
Local cFilSRA
Local cFilSPJ
Local cFilSR6
Local cFilSPA
Local cRegOrig
Local cTipoDia
Local cTipAfas
Local cIdAfas 
Local cTpExNorFer
Local cTpExNotFer
Local cPagInt
Local cKeyAtu
Local cNewTno
Local cNewReg
Local cCcCal
Local cTnoDefault := SRA->RA_TNOTRAB

Local dData
Local dIniAfas
Local dFimAfas

Local lExce
Local lExceData
Local lJndC
Local lFeriado
Local lIncrementa	:= .F.  //Incremento do dia de apontamento para jornada continua
Local lChkMat
Local lChkCc
Local lAfastper
Local lAfast
Local lAponFer
Local lTrbFeriado 
Local lHeAutoFer
Local lTrocaTno  
Local lTnoOpcData
Local lAllTnoOpc
Local lBldCalTnoSeq
Local lNewTno
Local lNewReg

Local nPos
Local nX
Local nFornX
Local nY  
Local nTno
Local nLenCalend
Local nPosOrdem
Local nSerial
Local nIniHnot
Local nFimHnot
Local nMinHNot
Local nHrTrab
Local nHrInte
Local nPosRg			:= 0 
Local nPosTr			:= 0
Local lApoSaida			:= .F.
Local lCpoApoSai		:= If (SPA->(ColumnPos("PA_TPAPONT")) > 0, .T., .F.)
Local lApontAfas		:= SuperGetMv('MV_APONTAF',.F.,.F.)
Local cCposSPA			:= ""
Local lIsento			:= .F.
Local aTransf			:= {}
Local lTemTransf		:= .F.
Local nLenTransf		:= 0
Local nI				:= 0
Local nPosDia			:= 0
Local nW 				:= 0
Local lTemTurno			:= .F.

Private n1EPos			:= 0

DEFAULT cTno			:= IF( Type( "SRA->RA_TNOTRAB" ) != "U" , SRA->RA_TNOTRAB	,  "" )
DEFAULT cSeq			:= IF( Type( "SRA->RA_SEQTURN" ) != "U" , SRA->RA_SEQTURN	,  "" )
DEFAULT cReg			:= IF( Type( "SRA->RA_REGRA" ) != "U" , SRA->RA_REGRA	,  "" )
DEFAULT aTabPadrao		:= {}
DEFAULT cFil			:= IF( Type( "SRA->RA_FILIAL" ) != "U" , SRA->RA_FILIAL		,  "" )
DEFAULT lSncMaMe		:= .F.
DEFAULT lAcumulado		:= .F. 
DEFAULT aMarcacoes		:= {}
DEFAULT lDtIni			:= .T.
DEFAULT lExcecoes		:= .T.
DEFAULT __aAllTnoOpc	:= {}
DEFAULT lCpoIsento		:= SPA->(ColumnPos("PA_ISENTO")) > 0
DEFAULT lUsaFilMat		:= .T.

lSitFunc := If(lSitFunc == NIL, SP2->(ColumnPos("P2_SITFUN")) > 0, lSitFunc)

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Obtem a Filial Para a Pesquisa das Excecoes                 ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
cFilSRA := cFil

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Obtem a Filial Para a Pesquisa dos Feriados                 ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
cFilSP3	:= xFilial( "SP3" , cFil )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Obtem a Filial Para a Montagem do Calendario                ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
cFilSPJ := xFilial( "SPJ" , cFil )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Obtem a Filial do SR6                                       ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
cFilSR6 := xFilial( "SR6" , cFil )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Obtem a Filial do SPA                                       ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
cFilSPA	:= xFilial( "SPA" , cFil )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Verifica se Passou Centro de Custo e Matricula              ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
lChkMat := !( cMat == NIL ) .And. lUsaFilMat
lChkCc	:= !( cCc  == NIL )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Se passou a Matricula Carrega as Trocas de Tuno do Periodo  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
IF ( lChkMat )
	IF Empty( aTurnos )
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Carrega as Trocas de Turno/Regra do Periodo				  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		DEFAULT aTurnos := {}
		lTrocaTno := fTrocaTno( dDataIni , dDataFim , @aTurnos , NIL , cSeq )
	Else
		lTrocaTno := .T.
	EndIF
	IF ( ( nPos := aScan( aTurnos , { |x| x[2] == If(dDataIni < SRA->RA_ADMISSA .and. dDataFim >= SRA->RA_ADMISSA, SRA->RA_ADMISSA, dDataIni) } ) ) > 0 )
		cTno 	:= aTurnos[ nPos , 01 ]
		cSeq	:= aTurnos[ nPos , 03 ]
		cReg 	:= aTurnos[ nPos , 05 ]
	ElseIf Empty(cReg)
		cReg	:= SRA->RA_REGRA
	EndIF
	nForNx := Len(aTurnos) + 1
	If lDtIni
		For nX:= 1 to Len(aTurnos)
			If aTurnos[(nForNx - nX),2] <= dDataIni//verifica em ordem decrescente
				dDataIni := aTurnos[(nForNx - nX),2]
				Exit
			EndIf
		Next
	EndIf 	
ElseIf Empty(cReg)
	cReg	:= IF( Type( "SRA->RA_REGRA" ) != "U" , SRA->RA_REGRA , cReg )
EndIF

If FunName() == "GPEA400"
	cReg   := ""
EndIf

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Salva Turno, Sequencia e Regra Iniciais                     ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
cNewTno	:= cTno
cNewReg	:= cReg

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Obtem a Sequencia Inicial do Turno                          ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
nSeq := Val( cSeq )

aExcePer := {}

IF ( lExce := ( lChkCc .and. lChkMat ) )
	lTemTransf := PonSitPer(cFil , cMat , dDataIni , dDataFim, NIL, @aTransf, .F.)
	nLenTransf := Len(aTransf)
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Carrega Todas as Excecoes do Periodo Quando o RDD for TOP   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	lExce := GetExceTop( cFilSRA , cMat , cCc , aTurnos , dDataIni , dDataFim , @aExcePer, aTransf )
EndIF


/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Carrega os Afastamentos Referente ao Periodo                ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
IF ( lAfastper := ( lChkMat ) )
	If lPort1510 .And. Empty( Alias() )
		dbSelectArea("SR8")
	EndIf
	lAfastper := fAfastaPer( @aAfasta , dDataIni , dDataFim , cFilSRA , cMat )
EndIF	

Begin Sequence
	
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Monta a Chave Atual                                         ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	DEFAULT cNewReg := "__cNewReg__"
	cKeyAtu := ( cEmpAnt + cFil + Dtos( dDataIni ) + Dtos( dDataFim ) + cNewTno + cSeq + cNewReg + AllToChar( lSncMaMe ) )
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Verifica se Houve alteracao ou se o Calendario para o  Turno³
	³ esta vazio e Recria										  ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	IF ( lBldCalTnoSeq := ( !( cKeyAtu == __cKeyBldCal ) .or. Empty( __aLstTabCal ) .Or. !lUsaFilMat ) )
		aTabCalend		:= {}	
		aTabTno			:= {}
		__aLstTabCal	:= {}
		__aLstTabTno	:= {}
		__cKeyBldCal	:= cKeyAtu
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Monta o Calendario de Marcacoes padrao para o   Turno/Sequen³
		³ cia Corrente												  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		IF !( lCriaCalOk := BldCalTnoSeq(	dDataIni		,;	//01 -> Data Inicial do Periodo
											dDataFim		,;	//02 -> Data Final do Periodo
											aTipo			,;	//03 -> Tipos de Marcacoes Possiveis
											cNewTno			,;	//04 -> Turno Para a Montagem do Calendario
											cSeq			,;	//05 -> Sequencia Inicial para a Montagem Calendario
											cNewReg			,;	//06 -> Regra do Funcionario
											@aTabPadrao		,;	//07 -> Array Tabela de Horario Padrao
											@aTabCalend		,;	//08 -> Array com o Calendario de Marcacoes
											@aTabTno		,;	//09 -> Tabela do Turno Corrente
											cFil			,;	//10 -> Filial para a Montagem da Tabela de Horario
											lExecQryTop 	,;	//11 -> Se executa Query para a Montagem da Tabela Padrao
											lSncMaMe		 ;	//12 -> Se executa a funcao se sincronismo do calendario	
										);
			)							 	
			Break
		EndIF
		__aLstTabCal	:= aClone( aTabCalend )
		__aLstTabTno	:= aClone( aTabTno )
	EndIF
	
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Inicializa o Array aTabCalend ( Calendario das Marcacoes )  ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	aTabCalend := aClone( __aLstTabCal )

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Carrega Informacoes Especificas do Funcionario              ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	IF ( lChkMat )

		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Carrega a Tabela do Turno Corrente				  		  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		aTabTno := aClone( __aLstTabTno )    
		
		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Obtem todos os Turnos Opcionais			                   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/    
		lAllTnoOpc := .F.
		If __lChkTnoOpc
			If lTrocaTno                     
				For nTno:= 1 To Len(aTurnos)               
					//-- Carrega todos os horarios opcionais do turno
			    	If LoadTnoOpc(cFilSPJ, aTurnos[nTno, 1],__aAllTnoOpc, @aTabPadrao)
			    	   lAllTnoOpc := .T.
			    	Endif   
			    Next
			Else
				//-- Carrega todos os horarios opcionais do turno
			    If LoadTnoOpc(cFilSPJ, cNewTno,__aAllTnoOpc, @aTabPadrao)
		    	   lAllTnoOpc := .T.
		    	Endif   
			Endif  
        Endif
        
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Carrega as Marcacoes do Funcionario para Ajustar os Turnos  ³
		³ em funcao da existencia de turnos opcionais				  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/	        
		If lAllTnoOpc 
			If Empty(aMarcacoes) 
				GetMarcOpc(	@aMarcacoes						,;	//01 -> Marcacoes dos Funcionarios
							dDataIni 						,;	//02 -> Periodo Inicial
							dDataFim 						,;	//03 -> Periodo Final
							cFil							,;	//04 -> Filial
							cMat							,;	//05 -> Matricula
							cTno							,;	//06 -> Turno
							cSeq							,;	//07 -> Sequencia de Turno
							cCc								,;	//08 -> Centro de Custo 
							If(lAcumulado, "SPG", "SP8")     ; //09 -> Obtem as marcacoes do Alias conforme o periodo considerado.
						  )         
			Endif  		  
	    Endif    

	    /*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Loop For/Next para a Carga das Marcacoes do Periodo         ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		aDiaTurnoOk:= {}
		nFornX := ( dDataFim - dDataIni )
		For nX := 0 To nFornX
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Data a ser verificada										  ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			dData := ( dDataIni + nX )
			
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ A Sequencia eh incrementada a Cada Segunda Feira			  ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			IF ( ( nX != 0 ) .and. ( Dow( dData ) == 2 ) )
				nSeq++
			EndIF 
			
			IF ( lIncrementa ) 
				/*/
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Verifica se a Sequˆncia atual est  cadastrada na Tabela. Pes³
				³ quisa a Sequencia Primeiro com o StrZero( n , 1 ) "0" e   De³
				³ pois com StrZero( n , 2 ) "00"						      ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
				bAsc := { |x| AllTrim( x[19] ) == StrZero( nSeq , IF( nSeq < 10 , 1 , 2 ) ) .or. AllTrim( x[19] ) == StrZero( nSeq , 2 ) }
				nSeq := IF( aScan( aTabTno , bAsc ) == 0 , 1 , nSeq )

				/*/
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Para Jornada Continua corre todas as datas para que seja    ³
				³ verificada se alguma segunda-feira ocorre durante a jornada ³
				³ e, assim, incrementarmos a sequencia.						  ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			    If nDias > 0
			      --nDias 
			      Loop
			    Endif   
			    lIncrementa := .F.
			EndIF 
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Ordem da Marcacao     									  ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			nOrdem++
			cOrdem		:= StrZero( nOrdem , Max( __nTamP8Ordem , Len( AllTrim( Str( nOrdem ) ) ) ) )
			dDataApo	:= dData
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Procura a Ordem no Calendario Generico					  ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			IF (; 
					(;
						nPosOrdem := aScan( __aLstTabCal , { |x|;
																( x[ CALEND_POS_ORDEM ] == cOrdem ) .and.;
																( x[ CALEND_POS_TIPO_MARC ] == "1E" );
														    };
							     		  );
					) == 0 ;
				)
				Loop
			EndIF													     		  

			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Se houver Sincronismo, adiciona a Ordem          		  	  ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			IF ( lSncMaMe )
				aAdd( aOrdens , cOrdem )
			EndIF	

			//-- Prepara tabela de verificacao de turnos
			If lAllTnoOpc
				AADD(aDiaTurnoOK, {dData, SPACE(1) })
			Endif

			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Pesquisa as Trocas de Turno/Sequencia/Regra Durante o  Perio³
			³ do														  ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			IF (;
					( lTrocaTno );
					.and.;
					( dDataIni != dData );
					.and.;
					( ( nPos := aScan( aTurnos , { |x| x[2] == dData } ) ) > 0 );
				)	
				lExistTrcTno	:= .T.
				cNewTno 		:= aTurnos[ nPos , 01 ]
				cSeq	 		:= aTurnos[ nPos , 03 ]
				cNewReg 		:= aTurnos[ nPos , 05 ]
				nSeq			:= Val( cSeq )
				/*/
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Carrega a Tabela Para o Novo Turno de Acordo com as Trocas  ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
				fTabPadrao( @aTabPadrao , @cFilSPJ , cNewTno , lExecQryTop )
				/*/
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Pesquisa e Carrega a Tabela do Turno Corrente				  ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
				IF ( lCriaCalOk := ( nPos := aScan( aTabPadrao, { |x| x[2] == cNewTno .and. ( x[1] == cFilSPJ .or. Empty( x[1] ) ) } ) ) > 0 )
					aTabTno := aClone( aTabPadrao[ nPos , 3 ] )
				Else
					Break
				EndIF
			EndIF
			
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Verifica se a Sequˆncia atual est  cadastrada na Tabela. Pes³
			³ quisa a Sequencia Primeiro com o StrZero( n , 1 ) "0" e   De³
			³ pois com StrZero( n , 2 ) "00"						      ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			bAsc := { |x| AllTrim( x[19] ) == StrZero( nSeq , IF( nSeq < 10 , 1 , 2 ) ) .or. AllTrim( x[19] ) == StrZero( nSeq , 2 ) }
			nSeq := IF( aScan( aTabTno , bAsc ) == 0 , 1 , nSeq )
			
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³Verifica se o Dia da Semana da Sequencia e equivalente ao Dia³
			³da Data a Ser Pesquisada. Pesquisa a Sequencia  Primeiro  com³
			³o StrZero( n , 1 ) "0" e Depois com o StrZero( n , 2 ) "00"  ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			bAsc := { |x| (	AllTrim( x[19] ) == StrZero( nSeq , IF( nSeq < 10 , 1 , 2 ) ) .or. AllTrim( x[19] ) == StrZero( nSeq , 2 ) ) ;
						  .and. x[20] == Dow(dData);
					 }
			IF !( lCriaCalOk := ( nPos := aScan( aTabTno , bAsc ) ) > 0 )
				Break
			EndIF
			
			// Verificar se o Funcionario Está Afastado na Data
			dIniAfas	:= Ctod("//")
			dFimAfas	:= Ctod("//")
			cTipAfas	:= __aLstTabCal[ nPosOrdem , CALEND_POS_TIP_AFAST ]                                       
			cIdAfas		:= __aLstTabCal[ nPosOrdem , CALEND_POS_R8ID ]
			
			IF ( lAfast := ( lAfastper ) )
				lAfast := fAfasta( cFilSRA , cMat , dData , @dIniAfas , @dFimAfas , @cTipAfas , aAfasta , @cIdAfas )
				If lAfast .And. fTemSuspGS(SRA->RA_FILIAL, SRA->RA_MAT, dToS(dData)) .And. (fIntRHGS() .Or. ObtemIdPon( aEvesIds, "043A", .F. ))
					lAfast := .F.
				EndIf
			EndIF
			
			// Verifica se na Data Houve Exceção e Substitui os Horários da Tabela
			lExceData := .F.
			If lExcecoes .And. lExce .And. lChkCc
				aExcecoes := {}
				cTipoDia  := aTabTno[nPos,18]
				IF (( lExce ) .and. GetExcecoes( @aExcecoes , cNewTno , cCC , cFilSRA , cMat , dData , @cTipoDia , aExcePer ))
					
					If lSitFunc .And. aExcecoes[1][25] > 0 .And. !IsInCallStack("PONA140")
						SP2->(dbGoTo(aExcecoes[1][25]))
						cSitFuncExc := Upper(AllTrim(SP2->P2_SITFUN))
						If !Empty(cSitFuncExc) .And. !(cSitFuncExc == "***")
							If (lAfast .And. !(cTipAfas $ cSitFuncExc)) .Or. (!lAfast .And. !("N" $ cSitFuncExc))
								aExcecoes := {}
								cTipoDia  := aTabTno[nPos, 18]
							EndIf
						EndIf
					EndIf
					
					// Salva a Tabela Padrao/Regra da Semana Que Serao  Modificados em Funcao de Excecoes
					aTabOrig  := aClone( aTabTno )
					cRegOrig  := cNewReg
					
					// Se Houver Excecoes na Data Substitui os Horarios/Regra pelos da Excecao
					If (lExceData := (!Empty( aExcecoes ) .and. (Empty( aExcecoes[ 01 , 33 ] ) .or. ( aExcecoes[ 01 , 33 ] == cTipoDia ))))
						IF ( aExcecoes[01,46] <> "S" )					// Assume o Horario das Excecooes
							aTabTno[nPos,01] 	:= aExcecoes[01,05]		// 01 - 1a Entrada
							aTabTno[nPos,02] 	:= aExcecoes[01,06]		// 02 - 1a Saida
							aTabTno[nPos,03] 	:= aExcecoes[01,07]		// 03 - 2a Entrada
							aTabTno[nPos,04] 	:= aExcecoes[01,08]		// 04 - 2a Saida
							aTabTno[nPos,05] 	:= aExcecoes[01,09]		// 05 - 3a Entrada
							aTabTno[nPos,06] 	:= aExcecoes[01,10]		// 06 - 3a Saida
							aTabTno[nPos,07] 	:= aExcecoes[01,11]		// 07 - 4a Entrada
							aTabTno[nPos,08] 	:= aExcecoes[01,12]		// 08 - 4a Saida
							aTabTno[nPos,09] 	:= aExcecoes[01,16]		// 09 - Horas Trabalhadas 1a. Jornada
							aTabTno[nPos,10] 	:= aExcecoes[01,17]		// 10 - Horas Trabalhadas 2a. Jornada
							aTabTno[nPos,11] 	:= aExcecoes[01,18]		// 11 - Horas Trabalhadas 3a. Jornada
							aTabTno[nPos,12] 	:= aExcecoes[01,19]		// 12 - Horas Trabalhadas 4a. Jornada
							aTabTno[nPos,13] 	:= aExcecoes[01,26]		// 13 - Horas de Intervalo 1S
							aTabTno[nPos,14] 	:= aExcecoes[01,27]		// 14 - Horas de Intervalo 2S
							aTabTno[nPos,15] 	:= aExcecoes[01,28]		// 15 - Horas de Intervalo 3S
							aTabTno[nPos,16] 	:= ""					// 16 - Marcacao e do dia seguinte ?
							aTabTno[nPos,17] 	:= aExcecoes[01,20]		// 17 - Numero de Marcacoes
							aTabTno[nPos,29] 	:= aExcecoes[01,34]		// 29 - Aponta Nona Hora
							aTabTno[nPos,30] 	:= aExcecoes[01,35]		// 30 - Limite de Horario Inicial
							aTabTno[nPos,31] 	:= aExcecoes[01,36]		// 31 - Limite de Horario Final
							aTabTno[nPos,32] 	:= aExcecoes[01,37]		// 32 - 1a. Jornada Continua
							aTabTno[nPos,33] 	:= aExcecoes[01,38]		// 33 - 2a. Jornada Continua
							aTabTno[nPos,34]	:= aExcecoes[01,39]		// 34 - 3a. Jornada Continua
							aTabTno[nPos,35]	:= aExcecoes[01,40]		// 35 - 4a. Jornada Continua
							aTabTno[nPos,36]	:= aExcecoes[01,41]		// 36 - Codigo da Refeicao
						EndIF
						aTabTno[nPos,18] 	:= aExcecoes[01,23]		// 18 - Tipo do Dia
						aTabTno[nPos,19] 	:= aTabTno[ nPos, 19 ]	// 19 - Sequencia da Marcacao
						aTabTno[nPos,20] 	:= Dow( dData )      	// 20 - Numero Correspondente ao Dia da Semana
						aTabTno[nPos,21] 	:= "E"					// 21 - Flag Indicador de Excecao
						aTabTno[nPos,22] 	:= aExcecoes[01,21]		// 22 - Motivo da Excecao
						aTabTno[nPos,23] 	:= aExcecoes[01,22]		// 23 - Codigo Hora Extra Normal
						aTabTno[nPos,24] 	:= aExcecoes[01,24]		// 24 - Codigo Hora Extra Noturna
						aTabTno[nPos,25] 	:= If (!Empty(aExcecoes[01,3]) .And. Empty(aExcecoes[01,29]), aExcecoes[01,3], aExcecoes[01,29])	// 25 - Centro de Custo Periodo 1 (1a.E-1a.S)
						aTabTno[nPos,26] 	:= If (!Empty(aExcecoes[01,3]) .And. Empty(aExcecoes[01,30]), aExcecoes[01,3], aExcecoes[01,30])	// 26 - Centro de Custo Periodo 2 (2a.E-2a.S)
						aTabTno[nPos,27] 	:= If (!Empty(aExcecoes[01,3]) .And. Empty(aExcecoes[01,31]), aExcecoes[01,3], aExcecoes[01,31])	// 27 - Centro de Custo Periodo 3 (3a.E-3a.S)
						aTabTno[nPos,28] 	:= If (!Empty(aExcecoes[01,3]) .And. Empty(aExcecoes[01,32]), aExcecoes[01,3], aExcecoes[01,32])	// 28 - Centro de Custo Periodo 4 (4a.E-4a.S)
						
						cNewReg		  	 	:= aExcecoes[01,42]		// Regra de Apontamento
						nIniHnot	  	 	:= aExcecoes[01,43]		// Inicio da Hora Noturna
						nFimHnot	  	 	:= aExcecoes[01,44]		// Final da Hora Noturna
						nMinHnot	  		:= aExcecoes[01,45]		// Minutos da Hora Noturna
					EndIF
				EndIF 
			Endif  
			
		   /*/
		   ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		   ³ Checa a Existencia de Turnos Opcionais				          ³
		   ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/    
			lTnoOpcData := .F.
			If ! lExceData
			 	If lAllTnoOpc
				   	/*/
					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					³ Salva a Tabela Padrao/Regra da Semana Que Serao  Modificados³
					³ em Funcao de Excecoes										  ³
					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
					aTabOrig  := aClone( aTabTno )
					cRegOrig  := cNewReg
					( aTnoOpcData := GetTnoOpc( cNewTno, dData, @aDiaTurnoOK, aTabPadrao, @aTabTno[nPos], cFilSPJ, @aMarcacoes) )

				   	lTnoOpcData := aTnoOpcData[1]
                Endif
			EndIF
			
			IF !( lBldNewOrd )
				/*/
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Verifica se Teve Alguma Alteracao                		  	  ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
				IF ( lBldNewOrd := (;
										( lExistTrcTno ) .or. ;	//Troca de Turno na Data
										( lExceData	   ) .or. ;	//Excecao na Data
										( lTnoOpcData  ) .or. ;	//Turno Opcional
										( lAfast	   )  	  ;	//Afastamento na Data
									 );
					)
					/*/
					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					³ Verifica se Deve Re-Sincronizar o Calendario     		  	  ³
					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
					lForceSinc := lBldNewOrd
				Else
					Loop
				EndIF
			EndIF        
	
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Carrega os Valores DEFAULT para o Dia            		  	  ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			lAponFer	:= __aLstTabCal[ nPosOrdem	,	CALEND_POS_APON_FERIAS	]
			cTpExNorFer	:= __aLstTabCal[ nPosOrdem	,	CALEND_POS_TP_HE_NR_FER	]
			cTpExNotFer	:= __aLstTabCal[ nPosOrdem	,	CALEND_POS_TP_HE_NT_FER	]
			cPagInt 	:= __aLstTabCal[ nPosOrdem	,	CALEND_POS_PAGINT		]
			lFeriado 	:= __aLstTabCal[ nPosOrdem	, 	CALEND_POS_FERIADO		]
       		lTrbFeriado	:= __aLstTabCal[ nPosOrdem	,	CALEND_POS_TRAB_FERIADO	] 
       		lHeAutoFer	:= __aLstTabCal[ nPosOrdem	,	CALEND_POS_HE_AUTO_FER	] 
			lApoSaida	:= .F. 
       		

			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Define o Tipo do Dia                                    	  ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			cTipoDia := aTabTno[ nPos , 18 ]

			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Verifica se Teve Alteracao no Turno              		  	  ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			IF( lNewTno	:= ( cNewTno <> cTno ) )
				cTno := cNewTno
			EndIF

			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Verifica se Teve Alteracao na Regra              		  	  ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			IF( lNewReg	:= ( cNewReg <> cReg ) )
				cReg := cNewReg
			EndIF
			
			IF ( nPosRg := aScan( aSpaInfo , { |x| x[1] == cFilSPA .and. x[2] == cNewReg } ) ) == 0
				aSvAlias := GetArea()
				
				cCondSPA := "% PA_FILIAL = '"+cFilSPA+"' AND "
				cCondSPA += "PA_CODIGO = '"+cNewReg+"' %"
				
				cQrySPA := GetNextAlias()
				
				cCposSPA := "PA_PAGINT, PA_FERIADO, R_E_C_N_O_ RECNO"
				
				If	lCpoApoSai
					cCposSPA += ", PA_TPAPONT"
				EndIf
				
				// Campo que indica que o funcionário é isento de marcação
				If lCpoIsento
					cCposSPA += ", PA_ISENTO"
				EndIf
				
				cCposSPA := "%" + cCposSPA + "%"
				
				BeginSql alias cQrySPA
					SELECT %exp:cCposSPA%
					FROM %table:SPA% SPA
					WHERE
					%exp:cCondSPA% AND SPA.%NotDel%
				EndSql
				
				If (cQrySpa)->(!Eof())
					
					(cQrySpa)->(aAdd( aSpaInfo, { cFilSPA, cNewReg, PA_PAGINT, PA_FERIADO, RECNO }))
					
					aAdd(aTail(aSpaInfo), If(lCpoApoSai, (cQrySpa)->PA_TPAPONT, "1"))
					
					aAdd(aTail(aSpaInfo), If(lCpoIsento, (cQrySpa)->PA_ISENTO, "1"))
					
					lCriaCalOk	:= .T.
					lSpaOk 		:= .T.						
					SPA->( MsGoto( (cQrySpa)->RECNO ) )						
					(cQrySPA)->(dbCloseArea())
				Else
					lCriaCalOk	:= .F.
					lSpaOk 		:= .F.
					(cQrySPA)->(dbCloseArea())
					Break
				EndIf
				
				RestArea( aSvAlias )
				
				nPosRg 	:= aScan( aSpaInfo , { |x| x[1] == cFilSPA .and. x[2] == cNewReg } )
				cPagInt := aSpaInfo[nPosRg, 3]
				lApoSaida	:= If(aSpaInfo[nPosRg, 6] == "2",.T.,.F.)
				lIsento := aSpaInfo[nPosRg, 7] == "2"
				
			Else
				lCriaCalOk	:= .T.
				lSpaOk 		:= .T.										
				cPagInt		:= aSpaInfo[nPosRg, 3]
				lApoSaida	:= If(aSpaInfo[nPosRg, 6] == "2",.T.,.F.)
				lIsento		:= aSpaInfo[nPosRg, 7] == "2"
				SPA->( MsGoto( aSpaInfo[nPosRg, 5] ) )
			EndIf
			
			If !lSpaOk
				lCriaCalOk	:= .F.
				Break
			EndIf
			
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Verifica Se o Dia em Questao eh um Feriado				  ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			lTrbFeriado := .F.
			IF ( lFeriado := __aLstTabCal[ nPosOrdem , CALEND_POS_FERIADO ] )
				lTrbFeriado := ( aSpaInfo[nPosRg, 4] == "S" )
       		EndIF

			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ As horas extras para funcionario em ferias sao por padrao	  ³
			³ autorizadas.												  ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/			
			lHeAutoFer	:= .T.
			
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Se nao Existir Excecao na Data Redefine o Tipo do Dia   	  ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			IF !( lExceData )

				IF ( nPosTr := aScan( aSr6Info , { |x| x[1] == cFilSPJ .and. x[2] == cTno } ) ) == 0
					aSvAlias := GetArea()
						
					cCondSR6 := "% R6_FILIAL = '"+cFilSPJ+"' AND "
					cCondSR6 += "R6_TURNO  = '"+cTno+"' %"
									
					cQrySR6 := GetNextAlias()
					
					BeginSql alias cQrySR6
						SELECT R6_INIHNOT, R6_FIMHNOT, R6_MINHNOT, R6_APODFER, R6_TPEXFER, R6_TPEXFEN, R6_AUTOHEF, R6_ASFOLGA, R6_TNOOPC, R_E_C_N_O_ RECNO
						FROM %table:SR6% SR6
						WHERE
						%exp:cCondSR6% AND SR6.%NotDel%
					EndSql
					
					If (cQrySr6)->(!Eof())
						aAdd( aSr6Info, { cFilSPJ, cTno, (cQrySr6)->(R6_INIHNOT), (cQrySr6)->(R6_FIMHNOT), (cQrySr6)->(R6_MINHNOT), (cQrySr6)->(R6_APODFER), (cQrySr6)->(R6_TPEXFER), (cQrySr6)->(R6_TPEXFEN), (cQrySr6)->(R6_AUTOHEF), (cQrySr6)->RECNO, (cQrySr6)->(R6_ASFOLGA), (cQrySr6)->(R6_TNOOPC) } )
						lCriaCalOk	:= .T.
						lSr6Ok 		:= .T.						
						SR6->( MsGoto( (cQrySR6)->RECNO ) )						
						(cQrySR6)->(dbCloseArea())
					Else
						lCriaCalOk	:= .F.
						lSr6Ok 		:= .F.						
						(cQrySR6)->(dbCloseArea())
						Break
					EndIf
					
					RestArea( aSvAlias )
					
					nPosTr := aScan( aSr6Info , { |x| x[1] == cFilSPJ .and. x[2] == cTno } )
					
				Else
					lCriaCalOk	:= .T.
					lSr6Ok 		:= .T.						
					SR6->( MsGoto( aSr6Info[nPosTr, 10] ) )
				EndIf
				
				If !lSr6Ok
					lCriaCalOk	:= .F.
					Break
				EndIf
				
				/*/
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Obtem a Hora Noturna de Acordo com o Turno                  ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
				nIniHnot := aSr6Info[nPosTr, 3]	// Inicio da Hora Noturna
				nFimHnot := aSr6Info[nPosTr, 4]	// Final da Hora Noturna
				nMinHnot := aSr6Info[nPosTr, 5]	// Minutos da Hora Noturna
				
				/*/
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Se estiver Afastado Define o Dia como Nao Trabalhado        ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
				IF ( lAfast )
					cTipoDia := "N"	//Nao Trabalhado
				EndIF
				
				/*/
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Verifica se Aponta para Funcionario em Ferias            	  ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
				IF ( cTipAfas == "F" )
					IF ( lAponFer := ( aSr6Info[nPosTr, 6] == "S" ) )
					
						/*/
						ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						³ Se funcionario em Ferias com Direito a Apontamento       	  ³
						ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
						cTpExNorFer	:= aSr6Info[nPosTr, 7]	//Normal Ferias
						cTpExNotFer	:= aSr6Info[nPosTr, 8]	//Noturna Ferias      
						
						/*/
						ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						³ Verifica se horas extras sao autorizadas para funcionario   ³
						³ em ferias.												  ³
						ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
						lHeAutoFer := If ( aSr6Info[nPosTr, 9] == "1" .or. Empty( aSr6Info[nPosTr, 9] ), .T. , .F. )	 // 1 ou branco - Autorizadas (Padrao) , 2- Nao Autorizadas
						
					EndIF
				Else
					/*/
					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					³ Se funcionario nao Trabalha em Feriado e dia For Feriado 	  ³
					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
					IF (;
					 		( lFeriado );			//Dia eh Feriado	
					 		.and.;
					 		!( lTrbFeriado );		//Funcionario Nao Trabalha em Feriado
					 	)
						cTipoDia := "F" //Feriado
					EndIF
				EndIF
			ElseIf lApontAfas .And. lAfast
				cTipoDia := "N"	//Nao Trabalhado
			EndIF
			
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Garante que os Minutos da Hora Nunca Sera Menor que Zero	  ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			nMinHnot := IF( nMinHnot <= 0 , 60 , nMinHNot )	// Minutos da Hora Noturna

			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Carrega Informacoes do Feriado                          	  ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			cP3TpExt	:= __aLstTabCal[ nPosOrdem	,	CALEND_POS_TP_HE_FER_NR	]
			cP3TpExtN	:= __aLstTabCal[ nPosOrdem	,	CALEND_POS_TP_HE_FER_NT	]
			cP3Desc		:= __aLstTabCal[ nPosOrdem	,	CALEND_POS_DESC_FERIADO	]

			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Exclui a Ordem Existente para Inclusao de Nova Ordem    	  ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			IF ( ( nY := nPosOrdem ) > 0 )
				nLenCalend := Len( aTabCalend )
				While (;
							( nY <= nLenCalend )  .and. ;
							( nLenCalend > 0 )	  .and.	;
							( aTabCalend[ nY , CALEND_POS_ORDEM ] >= __aLstTabCal[ nPosOrdem , CALEND_POS_ORDEM ] );
					   )
					aDel( aTabCalend , nY )
					aSize( aTabCalend , --nLenCalend )
				End While
			EndIF
			
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Loop For/Next para a Carga das Marcacoes do Dia             ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/  
			For nY := 1 To nFornY
				
				/*/
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Abandona Quando as Marcacoes estiverem Vazias e Nao For  Jor³
				³ nada Continua												  ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
				IF (;
						( ( nY == 3 ) .and. ( ( aTabTno[ nPos , 03 ] + aTabTno[ nPos , 04 ] ) == 0 ) .and. ( aTabTno[ nPos , 33 ] != "S" ) ) .or. ;
				   		( ( nY == 5 ) .and. ( ( aTabTno[ nPos , 05 ] + aTabTno[ nPos , 06 ] ) == 0 ) .and. ( aTabTno[ nPos , 34 ] != "S" ) ) .or. ;
				   		( ( nY == 7 ) .and. ( ( aTabTno[ nPos , 07 ] + aTabTno[ nPos , 08 ] ) == 0 ) .and. ( aTabTno[ nPos , 35 ] != "S" ) )      ;
				   	)	
					Exit
				EndIF
				
				/*/
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Carrega Informacoes Especificas para a Nova Ordem           ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
				IF ( lBldNewOrd )
					
					/*/
					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					³ Incrementa dData e nDias Quando Marcacao for do Dia Seguinte³
					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
					IF ( aTabTno[ nPos , nY ] <  aTabTno[ nPos , IF( nY == 1 , nY , nY-1 ) ] )
						++dData
						++nDias
					EndIF
					
					/*/
					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					³ Incrementa dData e nDias Caso Jornada Continua			  ³
					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
					IF (;
							lJndC := (;
										( ( nY == 2 ) .and. ( aTabTno[ nPos , 32 ] == "S" ) ) .or. ;
					   		  	    	( ( nY == 4 ) .and. ( aTabTno[ nPos , 33 ] == "S" ) ) .or. ;
					   			    	( ( nY == 6 ) .and. ( aTabTno[ nPos , 34 ] == "S" ) ) .or. ;
					   			    	( ( nY == 8 ) .and. ( aTabTno[ nPos , 35 ] == "S" ) )	   ;
					   			 	 );
					   	)
					   	lIncrementa	:= .T.
					   	lJorCont:= .T.
						++dData
						++nDias
					Else
						lJorCont:= .F.		
					EndIF
					
					/*/
					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					³Verifica Centro de Custo, Horas Trabalhadas e Horas de  Inter³
					³Valo														  ³
					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
					cCcCal	:= ""
					nHrTrab := 0
					nHrInte := 0
					Do Case
						Case ( aTipo[ nY ] $ "1E*1S" )
							cCcCal := aTabTno[ nPos , 25 ]
							IF ( aTipo[ nY ] == "1E" )
								nHrTrab := aTabTno[ nPos , 09 ]
							Else
								nHrInte := aTabTno[ nPos , 13 ]
							EndIF
						Case ( aTipo[ nY ] $ "2E*2S" )
							cCcCal := aTabTno[ nPos , 26 ]
							IF ( aTipo[ nY ] == "2E" )
								nHrTrab := aTabTno[ nPos , 10 ]
							Else
								nHrInte := aTabTno[ nPos , 14 ]
							EndIF	
						Case ( aTipo[ nY ] $ "3E*3S" )
							cCcCal := aTabTno[ nPos , 27 ]
							IF ( aTipo[ nY ] == "3E" )
								nHrTrab := aTabTno[ nPos , 11 ]
							Else
								nHrInte := aTabTno[ nPos , 15 ]
							EndIF	
						Case ( aTipo[ nY ] $ "4E*4S" )
							cCcCal := aTabTno[ nPos , 28 ]
							IF ( aTipo[ nY ] == "4E" )
								nHrTrab := aTabTno[ nPos , 12 ]
							EndIF	
					EndCase			
					
					/*/
					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					³ Carrega Novo Elemento no Calendario   					  ³
					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
					aAdd( aTabCalend, Array( ELEMENTOS_ATABCALEND ) )
					If ( nY == 1 )
						n1EPos		 := Len( aTabCalend )
					EndIf
					nLenCalend := Len( aTabCalend )
					
					//Verificação para correta utilização dos turnos, quando há turnos opcionais
					If lTnoOpcData
						cNewTno := aTnoOpcData[2]
					Else 
						cNewTno := cTno
					EndIf
					
					aTabCalend[	nLenCalend	,	CALEND_POS_DATA				] := dData																					// 01 - Data
					aTabCalend[	nLenCalend	,	CALEND_POS_DATA_APO			] := dDataApo																				// 48 - Data de Apontamento
					aTabCalend[	nLenCalend	,	CALEND_POS_ORDEM			] := cOrdem																					// 02 - Ordem
					aTabCalend[	nLenCalend	,	CALEND_POS_HORA				] := aTabTno[ nPos , nY ]      																// 03 - Hora
					aTabCalend[	nLenCalend	,	CALEND_POS_TIPO_MARC		] := aTipo[ nY ]          																	// 04 - Tipo Marc
					aTabCalend[	nLenCalend	,	CALEND_POS_NUM_MARC			] := aTabTno[ nPos , 17 ]     																// 05 - No Marc.
					aTabCalend[	nLenCalend	,	CALEND_POS_TIPO_DIA			] := cTipoDia     																			// 06 - Tipo Dia
					aTabCalend[	nLenCalend	,	CALEND_POS_HRS_TRABA		] := nHrTrab																				// 07 - Horas Trabalhada no Periodo
					aTabCalend[	nLenCalend	,	CALEND_POS_SEQ_TURNO		] := aTabTno[ nPos , 19 ]   																// 08 - Sequˆncia de Turno
					aTabCalend[	nLenCalend	,	CALEND_POS_HRS_INTER		] := nHrInte																				// 09 - Horas de Intervalo
					aTabCalend[	nLenCalend	,	CALEND_POS_EXCECAO			] := aTabTno[ nPos , 21 ]																	// 10 - Excecao ( E-Excecao, # E - nao e excecao )
					aTabCalend[	nLenCalend	,	CALEND_POS_MOT_EXECAO		] := aTabTno[ nPos , 22 ]																	// 11 - Motivo da Excecao
					aTabCalend[	nLenCalend	,	CALEND_POS_TIPO_HE_NOR		] := aTabTno[ nPos , 23 ]																	// 12 - Tipo de hora extra normal
					aTabCalend[	nLenCalend	,	CALEND_POS_TIPO_HE_NOT		] := aTabTno[ nPos , 24 ]																	// 13 - Tipo de hora extra noturna
					aTabCalend[	nLenCalend	,	CALEND_POS_TURNO			] := cNewTno																				// 14 - Turno de Trabalho

					If lTemTransf
						For nI := 1 to nLenTransf
							If dDataApo < aTransf[nI,7] .And. Empty(cCcCal)
								cCcCal := aTransf[nI,3]
								Exit
							EndIf
						Next
					EndIf

					aTabCalend[	nLenCalend	,	CALEND_POS_CC				] := cCcCal																					// 15 - Centro de Custo do Periodo 
					aTabCalend[	nLenCalend	,	CALEND_POS_PG_NONA_HORA		] := aTabTno[ nPos , 29 ]																	// 16 - Pagamento de Nona Hora
					IF ( nY == 1 )
						nSerial		:= ( __fDhToNS( dData , aTabTno[ nPos , nY ] ) - __fDhToNS( NIL , aTabTno[ nPos , 30 ] ) )
						aMarcId[1]	:= __fNsToDh( nSerial , "D" )
						aMarcId[2]	:= __fNsToDh( nSerial , "H" )

						nPosDia 	:= nLenCalend
						aTabCalend[nLenCalend, CALEND_POS_LIE] := nSerial
					Else
						aMarcId[1] := Ctod("//")
						aMarcId[2] := 0
					EndIF
					aTabCalend[	nLenCalend	,	CALEND_POS_LIM_MARCACAO		] := aClone( aMarcId )																		// 17 - Limite de Marcacao Inicial
					aTabCalend[	nLenCalend	,	CALEND_POS_COD_REFEICAO		] := IF(Empty(aTabTno[nPos,36]).and.!Empty(aTabOrig),aTabOrig[nPos,36],aTabTno[nPos,36])	// 18 - Codigo da Refeicao
					aTabCalend[	nLenCalend	,	CALEND_POS_FERIADO			] := lFeriado																				// 19 - Dia e Feriado
					aTabCalend[	nLenCalend	,	CALEND_POS_TP_HE_FER_NR		] := cP3TpExt																				// 20 - Tipo de Hora Extra Feriado Normal
					aTabCalend[	nLenCalend	,	CALEND_POS_TP_HE_FER_NT 	] := cP3TpExtN																				// 21 - Tipo de Hora Extra Feriado Noturna
					aTabCalend[	nLenCalend	,	CALEND_POS_DESC_FERIADO		] := cP3Desc																				// 22 - Descricao do Feriado
					aTabCalend[	nLenCalend	,	CALEND_POS_REGRA			] := cNewReg																				// 23 - Regra de Apontamento
					aTabCalend[	nLenCalend	,	CALEND_POS_AFAST			] := lAfast																					// 24 - Funcionario Afastado
					aTabCalend[	nLenCalend	,	CALEND_POS_TIP_AFAST		] := cTipAfas																				// 25 - Tipo de Afastamento
					aTabCalend[	nLenCalend	,	CALEND_POS_INI_AFAST		] := dIniAfas																				// 26 - Data Inicial do Afastamento
					aTabCalend[	nLenCalend	,	CALEND_POS_FIM_AFAST		] := dFimAfas																				// 27 - Data Final do Afastamento
					aTabCalend[	nLenCalend	,	CALEND_POS_INI_H_NOT		] := nIniHnot																				// 28 - Inicio da Hora Noturna
					aTabCalend[	nLenCalend	,	CALEND_POS_FIM_H_NOT		] := nFimHnot																				// 29 - Final da Hora Noturna
					aTabCalend[	nLenCalend	,	CALEND_POS_MIN_H_NOT		] := nMinHnot																				// 30 - Minutos da Hora Noturna
					aTabCalend[	nLenCalend	,	CALEND_POS_TRAB_FERIADO		] := lTrbFeriado																			// 31 - Se funcionario Trabalha em Dias Feriados
					aTabCalend[	nLenCalend	,	CALEND_POS_APON_FERIAS		] := lAponFer																				// 32 - Se Aponta Quando Afastamento em Ferias
					aTabCalend[	nLenCalend	,	CALEND_POS_TP_HE_NR_FER		] := cTpExNorFer																			// 33 - Tipo de hora extra normal (Ferias)
					aTabCalend[	nLenCalend	,	CALEND_POS_TP_HE_NT_FER		] := cTpExNotFer																			// 34 - Tipo de hora extra noturna (Ferias)	
					aTabCalend[	nLenCalend	,	CALEND_POS_PAGINT			] := cPagInt																				// 35 - Tipos de Intervalos Que sao Pagos conforme Regra
					aTabCalend[ nLenCalend	,   CALEND_POS_TIPO_ORIG_DIA    ] := aTabTno[nPos,18]																		// 36 - Tipo Original do Dia conforme excecao mas sem considerar a regra e/ou afastamentos
					aTabCalend[ nLenCalend	,   CALEND_POS_HE_AUTO_FER      ] := lHeAutoFer																				// 37 - Se H.Extras são autorizadas para funcionario em ferias				
					aTabCalend[ nLenCalend	,   CALEND_POS_INTSREP 		    ] := aTabTno[nPos,38]																		// 38 - Intervalo para geracao do ACJEF
					aTabCalend[	nLenCalend	,	CALEND_POS_R8ID				] := cIdAfas																				// 47 - Identificação do Afastamento
					aTabCalend[	nLenCalend	,	CALEND_POS_ISENTMARC		] := lIsento																				// 56 - Funcionário isento de marcação
				EndIF
				
				/*/
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Define a Posicao do Calendario quando nao Remontar Ordem    ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/  
				IF !( lBldNewOrd )
					IF ( ( ++nLenCalend ) > Len( aTabCalend )  )
						Exit
					EndIF
				EndIF
				
			Next nY
			
			If lTnoOpcData
				lTemTurno := .F.
				If Len(aTurnos) > 1
					For nW := Len(aTurnos) To 1 Step -1
						If dData + 1 >= aTurnos[nW,2]
							cNewTno := aTurnos[nW,1]
							lTemTurno := .T.
							Exit
						EndIf
					Next
				EndIf
				If !lTemTurno
					cNewTno := cTnoDefault
				EndIf
			EndIf  
			
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Quando inserir nova ordem verifica o Sincronismo            ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/  
			IF ( lBldNewOrd )
				nSerial		:= ( __fDhToNS( aTabCalend[ nLenCalend , CALEND_POS_DATA ] , aTabCalend[ nLenCalend , CALEND_POS_HORA ] ) + __fDhToNS( NIL ,aTabTno[ nPos , 31 ]) )
				aMarcId[1]	:= __fNsToDh( nSerial , "D" )
				aMarcId[2]	:= __fNsToDh( nSerial , "H" )
				
				aTabCalend[nPosDia, CALEND_POS_LSS] := nSerial
				aTabCalend[nLenCalend, CALEND_POS_LIM_MARCACAO] := aClone(aMarcId)
			EndIF				
			
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Se Houve Alteracao na Tabela Padrao/Regra em Funcao das Exce³
			³ coes, Restaura os Padroes								      ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			IF ( !Empty( aTabOrig ) )
				aTabTno		:= aClone( aTabOrig )
				aTabOrig	:= {}
				cNewReg		:= cRegOrig
				cRegOrig	:= ""
			EndIF
			
			If lApoSaida
				fApoSaida(aTabCalend, nLenCalend, aTabTno, nPos)
			EndIf	
			
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Se Nao eh jornada continua, os dias acrescidos no dia de    ³
			³ apontamento nao serao considerados.					      ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		    If !lIncrementa
		       nDias	:= 0
			Else
			   //-- Desconsidera o ultimo incremento para considerar a ultima data incrementada
			   -- nDias
		    Endif
			
		Next nX                  
		
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Reordena Calendario conforme Ordem							  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		IF ( lForceSinc )
			aSort( aTabCalend , NIL , NIL , { |x,y|	;
														(;
															x[ CALEND_POS_ORDEM 	] + ;
															x[ CALEND_POS_TIPO_MARC	]	;
														) < ;
														(;
															y[ CALEND_POS_ORDEM 	] + ;
															y[ CALEND_POS_TIPO_MARC	]	;
														);
											 };
				  )
		EndIF

	EndIF
	
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Sincroniza horarios iniciais da tabela para evitar intervalos³
	³entre os limites inicial do dia corrente e final do dia  ante³
	³rior.														  ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	IF ( ( lSncMaMe ) .and. ( lForceSinc ) )
		CalSncMaMe(	@aTabCalend	,;	//01 -> Calendario de Marcacoes
					@aTabPadrao	,;	//02 -> Tabela de Horario Padrao
					aOrdens		,;	//03 -> Array com as Ordens do Calendario
					dDataIni	,;	//04 -> Inicio do Periodo de Apontamento
					dDataFim	,; 	//05 -> Final do Periodo de Apontamento
					cTno		,;	//06 -> Turno de Trabalho
					cSeq		,;	//07 -> Sequencia de Turno
					cFil     	,;	//08 -> Filial do Funcionario
					cMat   		,;	//09 -> Matricula do Funcionario
					cCc   		,;	//10 -> Centro de Custo do Funcionario
					.F.			,;	//11 -> Marcacoes Sendo carregadas pela Ordem
					lChkMat		 ;	//12 -> Se o Calendario esta sendo Montado por Funcionario
		   		   )
	EndIF	   		   

End Sequence

Return( lCriaCalOk )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³BldCalTnoSeq	³Autor³Marinaldo de Jesus ³ Data ³17/09/2003³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Cria Calendario de Marcacoes Padrao Para o Turno/Sequencia  ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico													³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function BldCalTnoSeq(	dDataIni		,;	//01 -> Data Inicial do Periodo
								dDataFim		,;	//02 -> Data Final do Periodo
								aTipo			,;	//03 -> Tipos de Marcacoes Possiveis
								cTno			,;	//04 -> Turno Para a Montagem do Calendario
								cSeq			,;	//05 -> Sequencia Inicial para a Montagem Calendario
								cReg			,;	//06 -> Regra do Funcionario
								aTabPadrao		,;	//07 -> Array Tabela de Horario Padrao
								aTabCalend		,;	//08 -> Array com o Calendario de Marcacoes
								aLstTabTno		,;	//09 -> Tabela do Turno Corrente
								cFil			,;	//10 -> Filial para a Montagem da Tabela de Horario
								lExecQryTop 	,;	//11 -> Se executa Query para a Montagem da Tabela Padrao
								lSncMaMe		 ;	//12 -> Se executa a funcao se sincronismo do calendario
							)
/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Variaveis de Inicializacao Obrigatoria					  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Local aMarcId	 	:= { NIL , NIL }
Local aTabTno		:= {}
Local aOrdens		:= {}
Local lCriaCalOk	:= .T.
Local lAponFer		:= .F.
Local nOrdem		:= 0
Local nFornY		:= Len( aTipo )
Local nSeq			:= Val( cSeq )
Local nDias			:= 0
Local lChkReg		:= ( !Empty( cReg ) .and. ( cReg <> "__cNewReg__" ) )
Local lHeAutoFer	:= .T.
Local cCposSPA		:= ""
Local lIsento		:= .F.

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Variaveis que serao inicializadas no Corpo da Funcao		  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Local aSvAlias		:= {}

Local bAsc

Local cOrdem
Local dDataApo	:= Ctod("")
Local cFilSP3
Local cFilSPJ
Local cFilSR6
Local cFilSPA
Local cPagInt
Local cP3TpExt
Local cP3TpExtN
Local cP3Desc
Local cCcCal

Local dData

Local lJndC
Local lFeriado 
Local lIncrementa	:= .F. //Incrementa dia de periodo de apontamento para jornada continua
Local lDiaSeguinte	:= .F. //Define se já foi incrementado um dia por ser "Dia seguinte"
Local lTrbFeriado

Local nIniHnot
Local nFimHnot
Local nMinHNot
Local nSerial
Local nLenTabPad
Local nLenCalend
Local nX
Local nY
Local nFornX
Local nPos
Local nHrTrab
Local nHrInte
Local nPosRg		:= 0
Local nPosTr		:= 0
Local nPosDia		:= 0
Local lApoSaida		:= .F.
Local lCpoApoSai	:= If (SPA->(ColumnPos("PA_TPAPONT")) > 0, .T., .F.) 

Private n1EPos		:= 0

Default lCpoIsento := SPA->(ColumnPos("PA_ISENTO")) > 0

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Obtem a Filial Para a Pesquisa dos Feriados                 ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
cFilSP3	:= xFilial( "SP3" , cFil )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Obtem a Filial Para a Montagem do Calendario                ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
cFilSPJ := xFilial( "SPJ" , cFil )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Obtem a Filial do SR6                                       ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
cFilSR6 := xFilial( "SR6" , cFil )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Obtem a Filial do SPA                                       ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
cFilSPA	:= xFilial( "SPA" , cFil )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Carrega as Tabelas de Horario Padrao da Filial/Turno        ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
fTabPadrao( @aTabPadrao , @cFilSPJ , cTno , lExecQryTop )
IF ( ( ( nLenTabPad := Len( aTabPadrao ) ) == 0 ) .or. ( __nFilTabTno > nLenTabPad ) )
	__nFilTabTno := 0
EndIF	

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Se nao Verificar a Regra carrega os Espacos correspondentes ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
IF !( lChkReg )
	cReg := Space( GetSx3Cache( "PA_CODIGO" , "X3_TAMANHO" ) )
EndIF

Begin Sequence
	
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Pesquisa e Carrega a Tabela do Turno Corrente				  ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	IF ( ( __nFilTabTno > 0 ) .and. ( __nFilTabTno <= nLenTabPad ) .and. ( ( cFilSPJ + cTno ) == ( aTabPadrao[ __nFilTabTno , 01 ] + aTabPadrao[ __nFilTabTno , 02 ] ) ) )
		aTabTno := aClone( aTabPadrao[ __nFilTabTno , 3 ] )
	Else
		IF ( lCriaCalOk := ( ( nPos := aScan( aTabPadrao , { |x| x[1] == cFilSPJ .and. x[2] == cTno } ) ) > 0 ) )
			aTabTno := aClone( aTabPadrao[ nPos , 3 ] )
			__nFilTabTno := nPos
		Else
			Break
		EndIF
	EndIF	
	
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Salva a Tabela do Turno Corrente              			  ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	aLstTabTno := aClone( aTabTno )
	
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Inicializa o Array aTabCalend ( Calendario das Marcacoes )  ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	aTabCalend := {}
	
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Loop For/Next para a Carga das Marcacoes do Periodo         ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	nFornX := ( dDataFim - dDataIni )
	For nX := 0 To nFornX
		
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Data a ser verificada										  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		dData := ( dDataIni + nX )
		
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ A Sequencia eh incrementada a Cada Segunda Feira			  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		IF ( ( nX != 0 ) .and. ( Dow( dData ) == 2 ) )
			nSeq++
		EndIF
		
		IF ( lIncrementa ) 
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Verifica se a Sequˆncia atual est  cadastrada na Tabela. Pes³
			³ quisa a Sequencia Primeiro com o StrZero( n , 1 ) "0" e   De³
			³ pois com StrZero( n , 2 ) "00"						      ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			bAsc := { |x| AllTrim( x[19] ) == StrZero( nSeq , IF( nSeq < 10 , 1 , 2 ) ) .or. AllTrim( x[19] ) == StrZero( nSeq , 2 ) }
			nSeq := IF( aScan( aTabTno , bAsc ) == 0 , 1 , nSeq )

			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Para Jornada Continua corre todas as datas para que seja    ³
			³ verificada se alguma segunda-feira ocorre durante a jornada ³
			³ e, assim, incrementarmos a sequencia.						  ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		    If nDias > 0
		      --nDias 
		      Loop
		    Endif   
		    lIncrementa := .F.
		EndIF
		
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Ordem da Marcacao     									  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		nOrdem++
		cOrdem := StrZero( nOrdem , Max( __nTamP8Ordem , Len( AllTrim( Str( nOrdem ) ) ) ) )
		
		dDataApo	:= dData
		
		IF ( lSncMaMe )
			aAdd( aOrdens , cOrdem )
		EndIF
		
		lApoSaida	:= .F. 
		
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Verifica se a Sequˆncia atual est  cadastrada na Tabela. Pes³
		³ quisa a Sequencia Primeiro com o StrZero( n , 1 ) "0" e   De³
		³ pois com StrZero( n , 2 ) "00"						      ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		bAsc := { |x| AllTrim( x[19] ) == StrZero( nSeq , IF( nSeq < 10 , 1 , 2 ) ) .or. AllTrim( x[19] ) == StrZero( nSeq , 2 ) }
		nSeq := IF( aScan( aTabTno , bAsc ) == 0 , 1 , nSeq )
		
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Verifica se o Dia da Semana da Sequencia e equivalente ao Dia³
		³da Data a Ser Pesquisada. Pesquisa a Sequencia  Primeiro  com³
		³o StrZero( n , 1 ) "0" e Depois com o StrZero( n , 2 ) "00"  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		bAsc := { |x| (	AllTrim( x[19] ) == StrZero( nSeq , IF( nSeq < 10 , 1 , 2 ) ) .or. AllTrim( x[19] ) == StrZero( nSeq , 2 ) ) ;
					  .and. x[20] == Dow(dData);
				 }
		IF !( lCriaCalOk := ( nPos := aScan( aTabTno, bAsc ) ) > 0 )
			Break
		EndIF
		
		IF ( nPosTr := aScan( aSr6Info , { |x| x[1] == cFilSPJ .and. x[2] == cTno } ) ) == 0
			aSvAlias := GetArea()

			cCondSR6 := "% R6_FILIAL = '"+cFilSPJ+"' AND "
			cCondSR6 += "R6_TURNO  = '"+cTno+"' %"
							
			cQrySR6 := GetNextAlias()
			
			BeginSql alias cQrySR6
				SELECT R6_INIHNOT, R6_FIMHNOT, R6_MINHNOT, R6_APODFER, R6_TPEXFER, R6_TPEXFEN, R6_AUTOHEF, R6_ASFOLGA, R6_TNOOPC, R_E_C_N_O_ RECNO
				FROM %table:SR6% SR6
				WHERE
				%exp:cCondSR6% AND SR6.%NotDel%
			EndSql
			
			If (cQrySr6)->(!Eof())
				aAdd( aSr6Info, { cFilSPJ, cTno, (cQrySr6)->(R6_INIHNOT), (cQrySr6)->(R6_FIMHNOT), (cQrySr6)->(R6_MINHNOT), (cQrySr6)->(R6_APODFER), (cQrySr6)->(R6_TPEXFER), (cQrySr6)->(R6_TPEXFEN), (cQrySr6)->(R6_AUTOHEF), (cQrySr6)->RECNO, (cQrySr6)->(R6_ASFOLGA), (cQrySr6)->(R6_TNOOPC) } )
				lCriaCalOk	:= .T.
				lSr6Ok 		:= .T.						
				SR6->( MsGoto( (cQrySR6)->RECNO ) )						
				(cQrySR6)->(dbCloseArea())				
			Else
				lCriaCalOk	:= .F.
				lSr6Ok 		:= .F.						
				(cQrySR6)->(dbCloseArea())
				Break
			EndIf
			
			RestArea( aSvAlias )

			nPosTr := aScan( aSr6Info , { |x| x[1] == cFilSPJ .and. x[2] == cTno } )

		Else
			lCriaCalOk	:= .T.
			lSr6Ok 		:= .T.						
			SR6->( MsGoto( aSr6Info[nPosTr, 10] ) )			
		EndIf		
				
		If !lSr6Ok
			lCriaCalOk	:= .F.
			Break
		EndIf
		
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Obtem a Hora Noturna de Acordo com o Turno                  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		nIniHnot := aSr6Info[nPosTr, 3]	// Inicio da Hora Noturna
		nFimHnot := aSr6Info[nPosTr, 4]	// Final da Hora Noturna
		nMinHnot := aSr6Info[nPosTr, 5]	// Minutos da Hora Noturna

		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Garante que os Minutos da Hora Nunca Sera Menor que Zero	  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		nMinHnot := IF( nMinHnot <= 0 , 60 , nMinHNot )				// Minutos da Hora Noturna

		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Verifica Quais Intervalos Sao Pagos             			  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		cPagInt := ""
		IF ( lChkReg )
			IF ( nPosRg := aScan( aSpaInfo , { |x| x[1] == cFilSPA .and. x[2] == cReg } ) ) == 0			
				
				aSvAlias := GetArea()
				
				cCondSPA := "% PA_FILIAL = '"+cFilSPA+"' AND "
				cCondSPA += "PA_CODIGO  = '"+cReg+"' %"
				
				cQrySPA := GetNextAlias()
				
				cCposSPA := "PA_PAGINT, PA_FERIADO, R_E_C_N_O_ RECNO"
				
				If	lCpoApoSai
					cCposSPA += ", PA_TPAPONT"
				EndIf
				
				// Campo isentos de marcação
				If lCpoIsento
					cCposSPA += ", PA_ISENTO"
				EndIf
				
				cCposSPA := "%" + cCposSPA + "%"
				
				BeginSql alias cQrySPA
					SELECT %exp:cCposSPA%
					FROM %table:SPA% SPA
					WHERE
					%exp:cCondSPA% AND SPA.%NotDel%
				EndSql
				
				If (cQrySpa)->(!Eof())
					
					(cQrySpa)->(aAdd( aSpaInfo, { cFilSPA, cReg, PA_PAGINT, PA_FERIADO, RECNO }))
					
					aAdd(aTail(aSpaInfo), If(lCpoApoSai, (cQrySpa)->PA_TPAPONT, "1"))
					
					aAdd(aTail(aSpaInfo), If(lCpoIsento, (cQrySpa)->PA_ISENTO, "1"))
					
					lCriaCalOk	:= .T.
					lSpaOk 		:= .T.
					SPA->( MsGoto( (cQrySpa)->RECNO ) )
					(cQrySPA)->(dbCloseArea())
				Else
					lCriaCalOk	:= .F.
					lSpaOk 		:= .F.
					(cQrySPA)->(dbCloseArea())
					Break
				EndIf
				
				RestArea( aSvAlias )
				
				nPosRg 	:= aScan( aSpaInfo , { |x| x[1] == cFilSPA .and. x[2] == cReg } )
				cPagInt := aSpaInfo[nPosRg, 3]				
				lApoSaida	:= If(aSpaInfo[nPosRg, 6] == "2",.T.,.F.)
				lIsento := aSpaInfo[nPosRg, 7] == "2"
				
			Else
				lCriaCalOk	:= .T.
				lSpaOk 		:= .T.	
				cPagInt := aSpaInfo[nPosRg, 3]				
				lApoSaida	:= If(aSpaInfo[nPosRg, 6] == "2",.T.,.F.)
				lIsento := aSpaInfo[nPosRg, 7] == "2"
				SPA->( MsGoto( aSpaInfo[nPosRg, 5] ) )
			EndIf
			
			If !lSpaOk .And. FunName() <> "GPEA400"
				lCriaCalOk	:= .F.
				Break
			EndIf
			
		EndIF
		
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Verifica Se o Dia em Questao eh um Feriado				  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		lTrbFeriado := .F.
		IF ( lFeriado := fFeriado( cFilSP3 , dData, Nil, dDataIni, dDataFim ) )
			cP3TpExt		:= SP3->P3_TPEXT
			cP3TpExtN		:= SP3->P3_TPEXTN
			cP3Desc			:= SP3->P3_DESC
			IF ( lChkReg )
				lTrbFeriado := ( aSpaInfo[nPosRg, 4] == "S" )
			EndIF
		Else
			cP3TpExt	:= ""
			cP3TpExtN	:= ""
			cP3Desc		:= ""
		EndIF		
		
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Define o Tipo do Dia                                    	  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		cTipoDia := aTabTno[ nPos , 18 ]
		
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Se funcionario nao Trabalha em Feriado e dia For Feriado 	  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		IF ( ( lFeriado ) .and. !( lTrbFeriado ) )
			cTipoDia := "F" //Feriado
		EndIF 
		
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Loop For/Next para a Carga das Marcacoes do Dia             ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/  
		For nY := 1 To nFornY
			
			lDiaSeguinte := .F.

			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Abandona Quando as Marcacoes estiverem Vazias e Nao For  Jor³
			³ nada Continua												  ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			IF (;
					( ( nY == 3 ) .and. ( ( aTabTno[ nPos , 03 ] + aTabTno[ nPos , 04 ] ) == 0 ) .and. ( aTabTno[ nPos , 33 ] != "S" ) ) .or. ;
			   		( ( nY == 5 ) .and. ( ( aTabTno[ nPos , 05 ] + aTabTno[ nPos , 06 ] ) == 0 ) .and. ( aTabTno[ nPos , 34 ] != "S" ) ) .or. ;
			   		( ( nY == 7 ) .and. ( ( aTabTno[ nPos , 07 ] + aTabTno[ nPos , 08 ] ) == 0 ) .and. ( aTabTno[ nPos , 35 ] != "S" ) )      ;
			   	)	
				Exit
			EndIF
			
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Incrementa dData e nDias Quando Marcacao for do Dia Seguinte³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			IF ( aTabTno[ nPos , nY ] <  aTabTno[ nPos , IF( nY == 1 , nY , nY-1 ) ] )
				++dData
				++nDias
				lDiaSeguinte := .T.
			EndIF
			
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Incrementa dData e nDias Caso Jornada Continua			  ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			IF (;
					lJndC := (;
								( ( nY == 2 ) .and. ( aTabTno[ nPos , 32 ] == "S" ) ) .or. ;
			   		  	    	( ( nY == 4 ) .and. ( aTabTno[ nPos , 33 ] == "S" ) ) .or. ;
			   			    	( ( nY == 6 ) .and. ( aTabTno[ nPos , 34 ] == "S" ) ) .or. ;
			   			    	( ( nY == 8 ) .and. ( aTabTno[ nPos , 35 ] == "S" ) )	   ;
			   			 	 );
			   	)
				If !lDiaSeguinte
					++dData
					++nDias
				EndIf
				lIncrementa	:= .T. 
				lJorCont := .T.
			Else
				lJorCont := .F.
			EndIF
			
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³Verifica Centro de Custo, Horas Trabalhadas e Horas de  Inter³
			³Valo														  ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			cCcCal	:= ""
			nHrTrab := 0
			nHrInte := 0
			Do Case
				Case ( aTipo[ nY ] $ "1E*1S" )
					cCcCal := aTabTno[ nPos , 25 ]
					IF ( aTipo[ nY ] == "1E" )
						nHrTrab := aTabTno[ nPos , 09 ]
					Else
						nHrInte := aTabTno[ nPos , 13 ]
					EndIF
				Case ( aTipo[ nY ] $ "2E*2S" )
					cCcCal := aTabTno[ nPos , 26 ]
					IF ( aTipo[ nY ] == "2E" )
						nHrTrab := aTabTno[ nPos , 10 ]
					Else
						nHrInte := aTabTno[ nPos , 14 ]
					EndIF	
				Case ( aTipo[ nY ] $ "3E*3S" )
					cCcCal := aTabTno[ nPos , 27 ]
					IF ( aTipo[ nY ] == "3E" )
						nHrTrab := aTabTno[ nPos , 11 ]
					Else
						nHrInte := aTabTno[ nPos , 15 ]
					EndIF	
				Case ( aTipo[ nY ] $ "4E*4S" )
					cCcCal := aTabTno[ nPos , 28 ]
					IF ( aTipo[ nY ] == "4E" )
						nHrTrab := aTabTno[ nPos , 12 ]
					EndIF	
			EndCase			
			
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Carrega Novo Elemento no Calendario   					  ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			aAdd( aTabCalend, Array( ELEMENTOS_ATABCALEND ) )
			If ( nY == 1)
				n1EPos		 := Len( aTabCalend )
			EndIf
			nLenCalend := Len( aTabCalend )
			aTabCalend[	nLenCalend	,	CALEND_POS_DATA				] := dData																			// 01 - Data
			aTabCalend[	nLenCalend	,	CALEND_POS_DATA_APO			] := dDataApo			                                                            // 48 - Data de Apontamento
			aTabCalend[	nLenCalend	,	CALEND_POS_ORDEM			] := cOrdem																			// 02 - Ordem
			aTabCalend[	nLenCalend	,	CALEND_POS_HORA				] := aTabTno[ nPos , nY ]      														// 03 - Hora
			aTabCalend[	nLenCalend	,	CALEND_POS_TIPO_MARC		] := aTipo[ nY ]          															// 04 - Tipo Marc
			aTabCalend[	nLenCalend	,	CALEND_POS_NUM_MARC			] := aTabTno[ nPos , 17 ]     														// 05 - No Marc.
			aTabCalend[	nLenCalend	,	CALEND_POS_TIPO_DIA			] := cTipoDia     																	// 06 - Tipo Dia
			aTabCalend[	nLenCalend	,	CALEND_POS_HRS_TRABA		] := nHrTrab									 							 		// 07 - Horas Trabalhada no Periodo
			aTabCalend[	nLenCalend	,	CALEND_POS_SEQ_TURNO		] := aTabTno[ nPos , 19 ]   														// 08 - Sequˆncia de Turno
			aTabCalend[	nLenCalend	,	CALEND_POS_HRS_INTER		] := nHrInte																		// 09 - Horas de Intervalo
			aTabCalend[	nLenCalend	,	CALEND_POS_EXCECAO			] := aTabTno[ nPos , 21 ]															// 10 - Excecao ( E-Excecao, # E - nao e excecao )
			aTabCalend[	nLenCalend	,	CALEND_POS_MOT_EXECAO		] := aTabTno[ nPos , 22 ]															// 11 - Motivo da Excecao
			aTabCalend[	nLenCalend	,	CALEND_POS_TIPO_HE_NOR		] := aTabTno[ nPos , 23 ]															// 12 - Tipo de hora extra normal
			aTabCalend[	nLenCalend	,	CALEND_POS_TIPO_HE_NOT		] := aTabTno[ nPos , 24 ]															// 13 - Tipo de hora extra noturna
			aTabCalend[	nLenCalend	,	CALEND_POS_TURNO			] := cTno																			// 14 - Turno de Trabalho
			aTabCalend[	nLenCalend	,	CALEND_POS_CC				] := cCcCal										 							 		// 15 - Centro de Custo do Periodo 
			aTabCalend[	nLenCalend	,	CALEND_POS_PG_NONA_HORA		] := aTabTno[ nPos , 29 ]															// 16 - Pagamento de Nona Hora
			IF ( nY == 1 )
				nSerial		:= ( __fDhToNS( dData , aTabTno[ nPos , nY ] ) - __fDhToNS( NIL , aTabTno[ nPos , 30 ] ) )
				aMarcId[1]	:= __fNsToDh( nSerial , "D" )
				aMarcId[2]	:= __fNsToDh( nSerial , "H" )
				
				nPosDia 	:= nLenCalend
				aTabCalend[nLenCalend, CALEND_POS_LIE] := nSerial
			Else
				aMarcId[1] := Ctod("//")
				aMarcId[2] := 0
			EndIF
			aTabCalend[	nLenCalend	,	CALEND_POS_LIM_MARCACAO		] := aClone( aMarcId )																// 17 - Limite de Marcacao Inicial
			aTabCalend[	nLenCalend	,	CALEND_POS_COD_REFEICAO		] := aTabTno[ nPos , 36 ]															// 18 - Codigo da Refeicao
			aTabCalend[	nLenCalend	,	CALEND_POS_FERIADO			] := lFeriado																		// 19 - Dia e Feriado
			aTabCalend[	nLenCalend	,	CALEND_POS_TP_HE_FER_NR		] := cP3TpExt																		// 20 - Tipo de Hora Extra Feriado Normal
			aTabCalend[	nLenCalend	,	CALEND_POS_TP_HE_FER_NT 	] := cP3TpExtN																		// 21 - Tipo de Hora Extra Feriado Noturna
			aTabCalend[	nLenCalend	,	CALEND_POS_DESC_FERIADO		] := cP3Desc																		// 22 - Descricao do Feriado
			aTabCalend[	nLenCalend	,	CALEND_POS_REGRA			] := cReg																			// 23 - Regra de Apontamento
			aTabCalend[	nLenCalend	,	CALEND_POS_AFAST			] := .F.																			// 24 - Funcionario Afastado
			aTabCalend[	nLenCalend	,	CALEND_POS_TIP_AFAST		] := ""																				// 25 - Tipo de Afastamento
			aTabCalend[	nLenCalend	,	CALEND_POS_INI_AFAST		] := Ctod("//")																		// 26 - Data Inicial do Afastamento
			aTabCalend[	nLenCalend	,	CALEND_POS_FIM_AFAST		] := Ctod("//")																		// 27 - Data Final do Afastamento
			aTabCalend[	nLenCalend	,	CALEND_POS_INI_H_NOT		] := nIniHnot																		// 28 - Inicio da Hora Noturna
			aTabCalend[	nLenCalend	,	CALEND_POS_FIM_H_NOT		] := nFimHnot																		// 29 - Final da Hora Noturna
			aTabCalend[	nLenCalend	,	CALEND_POS_MIN_H_NOT		] := nMinHnot																		// 30 - Minutos da Hora Noturna
			aTabCalend[	nLenCalend	,	CALEND_POS_TRAB_FERIADO		] := lTrbFeriado																	// 31 - Se funcionario Trabalha em Dias Feriados
			aTabCalend[	nLenCalend	,	CALEND_POS_APON_FERIAS		] := lAponFer																		// 32 - Se Aponta Quando Afastamento em Ferias
			aTabCalend[	nLenCalend	,	CALEND_POS_TP_HE_NR_FER		] := ""																				// 33 - Tipo de hora extra normal (Ferias)
			aTabCalend[	nLenCalend	,	CALEND_POS_TP_HE_NT_FER		] := ""																				// 34 - Tipo de hora extra noturna (Ferias)	
			aTabCalend[	nLenCalend	,	CALEND_POS_PAGINT			] := cPagInt																		// 35 - Tipos de Intervalos Que sao Pagos conforme Regra
			aTabCalend[ nLenCalend	,   CALEND_POS_TIPO_ORIG_DIA    ] := aTabTno[nPos,18]																// 36 - Tipo Original do Dia conforme excecao mas sem considerar a regra e/ou afastamentos
			aTabCalend[ nLenCalend	,   CALEND_POS_HE_AUTO_FER      ] := lHeAutoFer	
			aTabCalend[ nLenCalend	,   CALEND_POS_INTSREP 		    ] := aTabTno[nPos,38]																// 38 - Intervalo para geracao do ACJEF
			aTabCalend[	nLenCalend	,	CALEND_POS_ISENTMARC		] := lIsento																		// 56 - Funcionário isento de marcação
		Next nY
		
		nSerial		:= ( __fDhToNS( aTabCalend[ nLenCalend , CALEND_POS_DATA ] , aTabCalend[ nLenCalend , CALEND_POS_HORA ] ) + __fDhToNS( NIL ,aTabTno[ nPos , 31] ) )
		aMarcId[1]	:= __fNsToDh( nSerial , "D" )
		aMarcId[2]	:= __fNsToDh( nSerial , "H" )
		
		aTabCalend[nPosDia, CALEND_POS_LSS] := nSerial
		aTabCalend[nLenCalend, CALEND_POS_LIM_MARCACAO] := aClone( aMarcId )																			// 17 - Limite de Marcacao Final
		
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Se Nao eh jornada continua, os dias acrescidos no dia de    ³
		³ apontamento nao serao considerados.					      ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	    If !lIncrementa
	       nDias	:= 0
		Else
		   //-- Desconsidera o ultimo incremento para considerar a ultima data incrementada
		   -- nDias
	    Endif
		
		If lApoSaida
			fApoSaida(aTabCalend, nLenCalend, aTabTno, nPos)
		EndIf
		
	Next nX                  
	
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Sincroniza horarios iniciais da tabela para evitar intervalos³
	³entre os limites inicial do dia corrente e final do dia  ante³
	³rior.														  ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	IF ( lSncMaMe )
		CalSncMaMe(	@aTabCalend	,;	//01 -> Calendario de Marcacoes
					@aTabPadrao	,;	//02 -> Tabela de Horario Padrao
					aOrdens		,;	//03 -> Array com as Ordens do Calendario
					dDataIni	,;	//04 -> Inicio do Periodo de Apontamento
					dDataFim	,; 	//05 -> Final do Periodo de Apontamento
					cTno		,;	//06 -> Turno de Trabalho
					cSeq		,;	//07 -> Sequencia de Turno
					cFil     	,;	//08 -> Filial do Funcionario
					NIL   		,;	//09 -> Matricula do Funcionario
					NIL   		,;	//10 -> Centro de Custo do Funcionario
					.F.			,;	//11 -> Marcacoes Sendo carregadas pela Ordem
					.F.			 ;	//12 -> Se o Calendario esta sendo Montado por Funcionario
		   		   )
	EndIF	   		   
	
End Sequence

Return( lCriaCalOk )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³RstCalendCria	³Autor³Marinaldo de Jesus ³ Data ³11/03/2003³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Reinicializa as Staticas utilizadas em CalendCria()        	³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico													³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function RstCalendCria()

__aLstTabCal	:= {}
__aLstTabTno	:= {}
__cKeyBldCal	:= "__cKeyBldCal"
__nFilTabTno	:= 0  
__aAllTnoOpc	:= {}
aSr6Info		:= {}
aSpaInfo		:= {}

Return( NIL )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³GetTabCal		³Autor³Marinaldo de Jesus ³ Data ³18/09/2003³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Retorna Array contendo __aLstTabCal e __aLstTabTno			³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico													³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function GetTabCal()

Local aTabsCal := Array( 03 )

aTabsCal[ 01 ] := aClone( __aLstTabCal )
aTabsCal[ 02 ] := aClone( __aLstTabTno )
aTabsCal[ 03 ] := __cKeyBldCal

Return( aClone( aTabsCal ) )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³SetTabCal		³Autor³Marinaldo de Jesus ³ Data ³18/09/2003³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Restaura  __aLstTabCal e __aLstTabTno que foram salvos  pela³
³          ³GetTabCal()													³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico													³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function SetTabCal( aTabsCal )

__aLstTabCal	:= aClone( aTabsCal[ 01 ] )
__aLstTabTno	:= aClone( aTabsCal[ 02 ] )
__cKeyBldCal	:= aTabsCal[ 03 ]

Return( NIL )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³CalSncMaMe  ³Autor³ Marinaldo de Jesus    ³ Data ³28/08/2003³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Sincroniza o HorMais e HorMenos do Calendario de Marcacoes  ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>	                                ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>	                                ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico                                                    ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function CalSncMaMe(	aTabCalend	,;	//01 -> Calendario de Marcacoes
							aTabPadrao	,;	//02 -> Tabela de Horario Padrao
							aOrdens		,;	//03 -> Array com as ordens do Calendario
							dPerIni		,;	//04 -> Inicio do Periodo de Apontamento
							dPerFim		,; 	//05 -> Final do Periodo de Apontamento
							cTno		,;	//06 -> Turno de Trabalho
							cSeq		,;	//07 -> Sequencia de Turno
							cFil     	,;	//08 -> Filial do Funcionario
							cMat   		,;	//09 -> Matricula do Funcionario
							cCc   		,;	//10 -> Centro de Custo do Funcionario
							lMarcOrder	,;	//11 -> Marcacoes Sendo carregadas pela Ordem
							lCalendFunc	 ;	//12 -> Se o Calendario esta sendo Montado por Funcionario
				   		   )

Local aMarcId		:= {}
Local cOrdemAtu		:= ""
Local cOrdemAnt		:= ""
Local nPosCalAtu	:= 0
Local nPosCalAnt	:= 0
Local nPosCalUlt	:= 0
Local nLoop			:= 0
Local nLoops		:= Len( aOrdens )
Local nSerial		:= 0
Local nHrsAtu		:= 0
Local nHrsAnt		:= 0
Local nDifHrs		:= 0
Local nHorMeno		:= 0
Local nHorMais		:= 0
Local nFator		:= 0
Local nContAnt		:= 1
Local nCont			:= 1
Local nLenCalend	:= Len(aTabCalend)

IF ( nLoops >= 2.00 )
	For nLoop := 1 To nLoops
		cOrdemAtu	:= aOrdens[ nLoop ]
		nPosCalAtu	:= aScan( aTabCalend, {|x|( x[ CALEND_POS_ORDEM ] == cOrdemAtu ) .and. ( x[ CALEND_POS_TIPO_MARC ] == "1E" )}, ++nPosCalAtu)
		IF ( nLoop == 1 )
			IF ( nPosCalAtu > 0 )
				nSerial := RetSerIni(	aClone( aTabCalend )	,;	//01 -> Copia do Calendario de Marcacoes
										@aTabPadrao				,;	//02 -> Tabela de Horario Padrao
										dPerIni					,;	//03 -> Inicio do Periodo de Apontamento
										dPerFim					,; 	//04 -> Final do Periodo de Apontamento
										cTno					,;	//05 -> Turno de Trabalho
										cSeq					,;	//06 -> Sequencia de Turno
										cFil     				,;	//07 -> Filial do Funcionario
										cMat   					,;	//08 -> Matricula do Funcionario
										cCc   					,;	//09 -> Centro de Custo do Funcionario
										lMarcOrder				,;	//10 -> Marcacoes Sendo carregadas pela Ordem
										lCalendFunc	 			 ;	//11 -> Se o Calendario esta sendo Montado por Funcionario
									)
				aTabCalend[	nPosCalAtu, CALEND_POS_LIM_MARCACAO, 01	] := __fNsToDh( nSerial, "D" )
				aTabCalend[	nPosCalAtu, CALEND_POS_LIM_MARCACAO, 02	] := __fNsToDh( nSerial, "H" )
			EndIF	
		ElseIF ( nLoop == nLoops )
			IF ((nPosCalUlt := aScan(aTabCalend, { |x| ( x[ CALEND_POS_ORDEM ] == cOrdemAtu ) .and. !Empty( x[ CALEND_POS_LIM_MARCACAO , 01 ] ) .and. ( x[ CALEND_POS_TIPO_MARC ] <> "1E" )}, ++nPosCalAtu)) > 0 )	
				cOrdemAnt	:= aOrdens[ nLoop-1]
				nPosCalAnt	:= aScan(aTabCalend, { |x| ( x[ CALEND_POS_ORDEM ] == cOrdemAnt ) .and. !Empty( x[ CALEND_POS_LIM_MARCACAO , 01 ] ) .and. ( x[ CALEND_POS_TIPO_MARC ] <> "1E" )}, ++nPosCalAnt)
				nHrsAnt		:= 0
				
				While nContAnt <= nLenCalend .And. aTabCalend[nContAnt][CALEND_POS_ORDEM] <= cOrdemAnt
					If aTabCalend[nContAnt][CALEND_POS_ORDEM] == cOrdemAnt
						nHrsAnt := SomaHoras(nHrsAnt, aTabCalend[nContAnt][CALEND_POS_HRS_TRABA])
					EndIf
					nContAnt++
				EndDo
				
				IF ( nHrsAnt > 0 )
					nSerial := (;
									__fDhToNS(;
												aTabCalend[ nPosCalAnt , CALEND_POS_LIM_MARCACAO , 01 ] ,;
												aTabCalend[ nPosCalAnt , CALEND_POS_LIM_MARCACAO , 02 ]	;
											) + ;
									__fDhToNS( NIL , 0.01  );
								)         
					
					nPosCalAnt := aScan(;
												aTabCalend , { |x|;
																	( x[ CALEND_POS_ORDEM ] == cOrdemAtu ) .and.;
																	!Empty( x[ CALEND_POS_LIM_MARCACAO , 01 ] ) .and.;
																	( x[ CALEND_POS_TIPO_MARC ] == "1E" );
															},;
												++nPosCalAnt;
									)
					aTabCalend[	nPosCalAnt , CALEND_POS_LIM_MARCACAO , 01	] := __fNsToDh( nSerial , "D" )
					aTabCalend[	nPosCalAnt , CALEND_POS_LIM_MARCACAO , 02	] := __fNsToDh( nSerial , "H" )
				Endif		
				nSerial := RetSerFim(	aClone( aTabCalend )	,;	//01 -> Copia do Calendario de Marcacoes
										@aTabPadrao				,;	//02 -> Tabela de Horario Padrao
										dPerIni					,;	//03 -> Inicio do Periodo de Apontamento
										dPerFim					,; 	//04 -> Final do Periodo de Apontamento
										cTno					,;	//05 -> Turno de Trabalho
										cSeq					,;	//06 -> Sequencia de Turno
										cFil     				,;	//07 -> Filial do Funcionario
										cMat   					,;	//08 -> Matricula do Funcionario
										cCc   					,;	//09 -> Centro de Custo do Funcionario
										lMarcOrder				,;	//10 -> Marcacoes Sendo carregadas pela Ordem
										lCalendFunc	 			 ;	//11 -> Se o Calendario esta sendo Montado por Funcionario
									)
				aTabCalend[	nPosCalUlt , CALEND_POS_LIM_MARCACAO , 01	] := __fNsToDh( nSerial , "D" )
				aTabCalend[	nPosCalUlt , CALEND_POS_LIM_MARCACAO , 02	] := __fNsToDh( nSerial , "H" )
			EndIF
		Else
			cOrdemAnt	:= aOrdens[ nLoop - 1 ]
			nPosCalAnt	:= aScan( aTabCalend , { |x| ( x[ CALEND_POS_ORDEM ] == cOrdemAnt ) .and. !Empty( x[ CALEND_POS_LIM_MARCACAO , 01 ] ) .and. ( x[ CALEND_POS_TIPO_MARC ] <> "1E" )}, ++nPosCalAnt)
			If nPosCalAtu > 0 .And. nPosCalAnt > 0
				nHrsAtu		:= 0
				nHrsAnt		:= 0
				
				While nCont <= nLenCalend .And. aTabCalend[nCont][CALEND_POS_ORDEM] <= cOrdemAtu
					If aTabCalend[nCont][CALEND_POS_ORDEM] == cOrdemAtu
						nHrsAtu := SomaHoras(nHrsAtu, aTabCalend[nCont][CALEND_POS_HRS_TRABA])
					EndIf
					nCont++
				EndDo
				
				While nContAnt <= nLenCalend .And. aTabCalend[nContAnt][CALEND_POS_ORDEM] <= cOrdemAnt
					If aTabCalend[nContAnt][CALEND_POS_ORDEM] == cOrdemAnt
						nHrsAnt := SomaHoras(nHrsAnt, aTabCalend[nContAnt][CALEND_POS_HRS_TRABA])
					EndIf
					nContAnt++
				EndDo
				
				IF ( nHrsAnt > 0 )
					nSerial := (;
									__fDhToNS(;
												aTabCalend[ nPosCalAnt , CALEND_POS_LIM_MARCACAO , 01 ] ,;
												aTabCalend[ nPosCalAnt , CALEND_POS_LIM_MARCACAO , 02 ]	;
											) + ;
									__fDhToNS( NIL , 0.01  );
								)
					aTabCalend[	nPosCalAtu , CALEND_POS_LIM_MARCACAO , 01	] := __fNsToDh( nSerial , "D" )
					aTabCalend[	nPosCalAtu , CALEND_POS_LIM_MARCACAO , 02	] := __fNsToDh( nSerial , "H" )
				ElseIF ( ( nHrsAnt == 0 ) .and. ( nHrsAtu == 0 ) )
					nHorMais	:= DataHora2Val(;
												aTabCalend[ nPosCalAnt , CALEND_POS_DATA ],;
												aTabCalend[ nPosCalAnt , CALEND_POS_HORA ],;
												aTabCalend[	nPosCalAnt , CALEND_POS_LIM_MARCACAO , 01 ],;
												aTabCalend[	nPosCalAnt , CALEND_POS_LIM_MARCACAO , 02 ],;
												"H";
											)
					nHorMeno	:= DataHora2Val(;
												aTabCalend[ nPosCalAtu , CALEND_POS_DATA ],;
												aTabCalend[ nPosCalAtu , CALEND_POS_HORA ],;
												aTabCalend[	nPosCalAtu , CALEND_POS_LIM_MARCACAO , 01 ],;
												aTabCalend[	nPosCalAtu , CALEND_POS_LIM_MARCACAO , 02 ],;
												"H";
											)
					nDifHrs := DataHora2Val(;
												aTabCalend[	nPosCalAnt , CALEND_POS_LIM_MARCACAO , 01 ],;
												aTabCalend[	nPosCalAnt , CALEND_POS_LIM_MARCACAO , 02 ],;
												aTabCalend[	nPosCalAtu , CALEND_POS_LIM_MARCACAO , 01 ],;
												aTabCalend[	nPosCalAtu , CALEND_POS_LIM_MARCACAO , 02 ] ;
											)
					nFator	:= ( nHorMais / ( nHorMais + nHorMeno ) )
					nDifHrs *= nFator
					nDifHrs := NoRound( nDifHrs , 0 )
					nDifHrs := __Min2Hrs( nDifHrs )
					aMarcId := RetFimTab(	aTabCalend[	nPosCalAnt , CALEND_POS_LIM_MARCACAO , 01 ]	,;	//01 -> Data da Primeira Marcacao
											aTabCalend[	nPosCalAnt , CALEND_POS_LIM_MARCACAO , 02 ]	,;	//02 -> Hora da Primeira Marcacao
											nDifHrs									 				 ;	//03 -> Total de Horas a Trabalhar
										)										
					aTabCalend[	nPosCalAnt , CALEND_POS_LIM_MARCACAO , 01 ] := aMarcId[1]
					aTabCalend[	nPosCalAnt , CALEND_POS_LIM_MARCACAO , 02 ] := aMarcId[2]
					aMarcId := RetFimTab(	aMarcId[1]	,;	//01 -> Data da Primeira Marcacao
											aMarcId[2]	,;	//02 -> Hora da Primeira Marcacao
											0.01		 ;	//03 -> Total de Horas a Trabalhar
										)										
					aTabCalend[	nPosCalAtu , CALEND_POS_LIM_MARCACAO , 01 ] := aMarcId[1]
					aTabCalend[	nPosCalAtu , CALEND_POS_LIM_MARCACAO , 02 ] := aMarcId[2]
				Else
					nSerial := (;
									__fDhToNS(;
												aTabCalend[ nPosCalAtu , CALEND_POS_LIM_MARCACAO , 01 ] ,;
												aTabCalend[ nPosCalAtu , CALEND_POS_LIM_MARCACAO , 02 ]	;
											  ) - ;
								   __fDhToNS( NIL , 0.01  );
								)
					aTabCalend[	nPosCalAnt , CALEND_POS_LIM_MARCACAO , 01 ] := __fNsToDh( nSerial , "D" )
					aTabCalend[	nPosCalAnt , CALEND_POS_LIM_MARCACAO , 02 ] := __fNsToDh( nSerial , "H" )
				EndIF
			EndIF
		EndIF
	Next nLoop
EndIF

Return( NIL )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³TabMarc   ³ Autor ³ Marinaldo de Jesus    ³ Data ³12/03/2003³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Retorna numero de Elementos Permitidos para o Calendario    ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>	                                ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>	                                ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico                                                    ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function TabMarc( cAlias , aMarcs )

Local cCampo  	:= ""
Local cCampoE 	:= ""
Local cCampoS 	:= ""
Local cPrefixo	:= ""
Local nX      	:= 0
Local nCtaMarc	:= 0
Local nCampos 	:= 0

DEFAULT cAlias			:= Alias()
DEFAULT __aLstTbMarc	:= {}

cAlias	:= Upper( AllTrim( cAlias ) )
aMarcs	:= {}

IF ( ( nX := aScan( __aLstTbMarc , { |x| x[1] == cAlias } ) ) > 0 )

	aMarcs		:= aClone( __aLstTbMarc[ nX , 02 ] )
	nCtaMarc	:= __aLstTbMarc[ nX , 03 ]

Else
	
	If FunName() $ "PONA040" .And. Type("aHeader") <> "U" .And. nColMarc > 4

		cCampoE := ( cPrefixo + "ENT" )
		cCampoS := ( cPrefixo + "SAI" )

		For nX := 1 To Len(aHeader)
			cCampo := aHeader[nX][2]
			IF ( SubStr( cCampo , 1 , 3 ) == cCampoE ) .or. ( SubStr( cCampo , 1 , 3 ) == cCampoS )
				aAdd( aMarcs , cValToChar(Val(SubStr( cCampo , 4 , 2 ))) + SubStr( cCampo , 1 , 1 ) )
			EndIF
		Next nX

	Else

		cPrefixo := PrefixoCpo( cAlias )

		cCampoE := ( cPrefixo + "_ENTRA" )
		cCampoS := ( cPrefixo + "_SAIDA" )

		nCampos := ( cAlias )->( fCount() )
		For nX := 1 To nCampos
			cCampo := ( cAlias )->( FieldName( nX ) )
			IF ( SubStr( cCampo , 1 , 8 ) == cCampoE ) .or. ( SubStr( cCampo , 1 , 8 ) == cCampoS )
				aAdd( aMarcs , SubStr( cCampo , 9 , 1 ) + SubStr( cCampo , 4 , 1 ) )
			EndIF
		Next nX
		aSort( @aMarcs )
	EndIf

	
	aAdd( __aLstTbMarc , { cAlias , aClone( aMarcs ) , ( nCtaMarc := Len( aMarcs ) ) } )

EndIF

Return( nCtaMarc )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³ GravaSPC ³ Autor ³ Equipe Advanced RH    ³ Data ³10/04/1996³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³ Grava o resultado no SPC.                                  ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³ GravaSPC()                                                 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³                                                            ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³ Generico                                                   ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function GravaSPC(	aResult		,;	//01 -> Array com os Resultados a serem Gravados
					cFil		,;	//02 -> Filial do Funcionario
					cMat		,;	//03 -> Matricula do Funcionario
					cEveMesA	,;	//04 -> Eventos do Mes Anterior que nao poderao ser apagados
					dPerIni		,;	//05 -> Periodo Inicial
					dPerFim		,;	//06 -> Periodo Final
					aAbonosPer	 ;	//07 -> Array com Todos os Abonos no Periodo
				)

Local aSPC			:= {}
Local cAlias		:= "SPC"
Local cAliasQuery	:= cAlias
Local cSvFilAnt		:= cFilAnt
Local nOrder		:= RetOrdem( "SPC" , "PC_FILIAL+PC_MAT+PC_PD+DTOS(PC_DATA)+PC_TPMARCA+PC_CC" )
Local nSvOrder		:= SPC->( IndexOrd() )

Local aAbonos
Local aInfAbonos
Local aPreAbonos
Local aNewAbonos
Local cCodAbono
Local cMsgErr
Local nPos
Local nX
Local nFornX
Local nLenSPC
Local nHrsAbono
Local nHrsPreAbono
Local lGravar
Local nPosX

Local aTamQuantC		:= {}
Local aTamAbonos		:= {}
Local cIniData	 		:= ""
Local cFimData			:= ""
Local cQuery	 		:= ""
Local aSvAlias			:= GetArea()
Local cTableName		:= ""
Local cCpoRecno			:= ""
Local cUserPon			:= If(!Empty(GetGlbValue("__cUserPon")), GetGlbValue("__cUserPon"), __cUserId)

Static aSpcFields
Static cQrySpcFields
Static nSpcFields
Static __oSt6
Static __cEmpAux6

DEFAULT aSpcFields := ( cAlias )->( dbStruct() )
DEFAULT nSpcFields := Len( aSpcFields )
DEFAULT lCpoCCT	   :=  SP4->(ColumnPos("P4_CODCCT") > 0)

If ( cQrySpcFields == NIL )
	cQrySpcFields := ""
	For nX := 1 To nSpcFields
		cQrySpcFields += aSpcFields[ nX , 01 ] + ", "
	Next nX
EndIf

DEFAULT cEveMesA		:= ""
DEFAULT lRF0ChkTable	:= fVerTabRF0()  	//Verifica a Existencia da Tabela de Pre-Abonos e se a mesm possui registro
DEFAULT __cLimpaMotAbo	:= Space( TamSx3("PC_ABONO")[1] )	//Variavel auxiliar para preencher em branco o campo Motivo do Abono
DEFAULT __lCpoDataAlt	:= SuperGetMv("MV_PONLOG",NIL,"N") == "S" 
DEFAULT __lCpoUsuaAlt	:= SuperGetMv("MV_PONLOG",NIL,"N") == "S"

cFilAnt	:= If( !Empty( cFil ) , cFil , cFilAnt )

bAsc   := { |x|	x[1] == aResult[ nX , ARESULT_DATA		];
				.and.;
				x[2] == aResult[ nX , ARESULT_EVENTO	];
				.and.;
				x[5] == aResult[ nX , ARESULT_CC		];
				.and.;
				x[6] == aResult[ nX , ARESULT_TPMARCA	];
		  } 

If !( nSvOrder == nOrder )
	( cAlias )->( dbSetOrder( nOrder ) )
EndIf

aTamQuantC	:= TamSx3("PC_QUANTC")
aTamAbonos	:= TamSx3("PC_QTABONO")
cTableName	:= InitSqlName( cAlias )
cCpoRecno	:= "R_E_C_N_O_"
cIniData	:= Dtos( dPerIni )
cFimData	:= Dtos( dPerFim )

cAliasQuery := ( "__Q" + cAliasQuery + "QRY" )

If __oSt6 == Nil .or. ( __cEmpAux6 == Nil .or. __cEmpAux6 <> cEmpAnt )
	__cEmpAux6   := cEmpAnt

	__oSt6 := FWPreparedStatement():New()

	cQuery := "SELECT "
	cQuery += cQrySpcFields
	cQuery += "R_E_C_N_O_ RECNO"
	cQuery += " FROM "
	cQuery += cTableName
	cQuery += " WHERE "
	cQuery += "PC_FILIAL = ? "
	cQuery += " AND "
	cQuery += "PC_MAT = ? "
	cQuery += " AND "
	cQuery += "( "
	cQuery += 		"PC_DATA >= ? AND "
	cQuery += 		"PC_DATA <= ? "
	cQuery += " )"
	cQuery += " AND "
	cQuery += "D_E_L_E_T_ = ' ' "
	cQuery += "ORDER BY " + SqlOrder( (cAlias)->( IndexKey() ) )

	cQuery := ChangeQuery( cQuery )

	__oSt6:SetQuery(cQuery)
EndIf

__oSt6:SetString(1,cFil)
__oSt6:SetString(2,cMat)
__oSt6:SetString(3,cIniData)
__oSt6:SetString(4,cFimData)

cQuery := __oSt6:getFixQuery()

dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasQuery)

For nX := 1 To nSpcFields
	If !( aSpcFields[ nX , 02 ] == "C" )
		TcSetField(cAliasQuery,aSpcFields[nX,01],aSpcFields[nX,02],aSpcFields[nX,03],aSpcFields[nX,04])
	EndIf
Next nX

While ( cAliasQuery )->( !Eof() )
	If ( cAliasQuery )->( ( PC_DATA >= dPerIni ) .and. ( PC_DATA <= dPerFim ) )
		aAdd( aSPC, Array( 15 ) )
		nLenSPC := Len( aSPC )
		aSPC[ nLenSPC , 01 ] := ( cAliasQuery )->( PC_DATA		)
		aSPC[ nLenSPC , 02 ] := ( cAliasQuery )->( PC_PD		)
		aSPC[ nLenSPC , 03 ] := ( cAliasQuery )->( PC_QUANTC	)
		aSPC[ nLenSPC , 04 ] := ( cAliasQuery )->( PC_QUANTI	)
		aSPC[ nLenSPC , 05 ] := ( cAliasQuery )->( PC_CC		)
		aSPC[ nLenSPC , 06 ] := ( cAliasQuery )->( PC_TPMARCA	)
		aSPC[ nLenSPC , 07 ] := ( cAliasQuery )->( RECNO 		)
		aSPC[ nLenSPC , 08 ] := ( cAliasQuery )->( PC_ABONO 	)
		aSPC[ nLenSPC , 09 ] := ( cAliasQuery )->( PC_QTABONO 	) 
		
		//-- Portaria 1.510
		If cPaisLoc == "BRA"
			aSPC[ nLenSPC , 10 ] := ( cAliasQuery )->( PC_TURNO 	)
			aSPC[ nLenSPC , 11 ] := ( cAliasQuery )->( PC_SEMANA	)
			aSPC[ nLenSPC , 12 ] := ( cAliasQuery )->( PC_TIPOHE	)
			aSPC[ nLenSPC , 13 ] := ( cAliasQuery )->( PC_PERCENT	)
		EndIf
		
		// Convenção coletiva de trabalho
		If lCpoCCT
			aSPC[ nLenSPC , 14 ] := ( cAliasQuery )->( PC_FILCCT)
			aSPC[ nLenSPC , 15 ] := ( cAliasQuery )->( PC_CODCCT)
		EndIf
	EndIf
	( cAliasQuery )->( dbSkip() )
End While

( cAliasQuery )->( dbCloseArea() )
RestArea( aSvAlias )

nLenSPC := Len( aSPC )

lRF0ChkTable	:= fVerTabRF0()//FOI PRECISO FORÇAR ESTA CHAMADA SEMPRE POIS AO EDITAR A TELA DE MARCACAO SALVAR E ENTRAR DE NOVO PARA RE-EDITAR VARIAS VEZES OS MESMOS DADOS 
        	                   //O SISTEMA DEIXAVA A VARIAVEL lRF0ChkTable como FALSE a partir da segunda modificacao, pois nao passava mais no "Default" 

nFornX := Len( aResult )
For nX := 1 To nFornX

	IF ( ( aResult[ nX , ARESULT_DATA ] >= dPerIni ) .and. ( aResult[ nX , ARESULT_DATA ] <= dPerFim ) )

		nHrsAbono	:= fAbonos( aResult[ nX , ARESULT_DATA ] , aResult[ nX , ARESULT_EVENTO ] , NIL , @aAbonos , aResult[ nX , ARESULT_TPMARCA ] , aResult[ nX , ARESULT_CC ] , aAbonosPer )
		fFiltAbo( aAbonos , { |x| x[ AABONOS_FLAG ] == "P" } , { |x| x[ AABONOS_FLAG ] <> "P" } , @aInfAbonos )
		cCodAbono	:= IF( !Empty( aInfAbonos ) , aInfAbonos[ 01 , AABONOS_CODIGO ] , __cLimpaMotAbo )
        aNewAbonos	:= {}

	    IF ( ( lRF0ChkTable ) .and. Empty( aInfAbonos ) )

			aNewAbonos	:= aResult[ nX , ARESULT_RESULT_APO ]
			nHrsPreAbono := fFiltAbo( aAbonos , { |x| x[ AABONOS_FLAG ] <> "P"} , { |x| x[ AABONOS_FLAG ] == "P"} , @aPreAbonos )
		    
		    nHrsAbono	:= SubHoras( nHrsAbono , nHrsPreAbono )
		    nHrsAbono	:= __TimeSum( nHrsAbono ,  aResult[ nX , ARESULT_NUM_ABO_HRS]) //01 -> Array com as Horas Abonadas para o Evento do Dia (Evento + Tipo Marc + C.Custo)
		    nHrsAbono	:= SomaHoras( nHrsAbono ,  0.00)
			
			cCodAbono	:= IF( !Empty( aInfAbonos ) , aInfAbonos[ 01 , AABONOS_CODIGO ] , IF( !Empty( aNewAbonos ) , aNewAbonos[ 01 , AABONOS_CODIGO ] , __cLimpaMotAbo ) )

        EndIF
		
		cCodAbono	:= IF( !Empty( cCodAbono ) , cCodAbono , __cLimpaMotAbo )
		IF ( ( nPos := aScan( aSPC , bAsc ) ) > 0 )
			IF ( aSPC[ nPos , 7 ] == 0 ) //Eof()
				Loop //Existem Apontamentos Duplicados.... Isso nao Pode Ocorrer....
			EndIF
			IF (;
					( aSPC[ nPos , 3 ] <> aResult[ nX , ARESULT_HORAS ] );
					.or.;
					( aSPC[ nPos , 8 ] <> cCodAbono );
					.or.;
					( aSPC[ nPos , 9 ] <> nHrsAbono  .Or. nHrsAbono > aResult[ nX , ARESULT_HORAS ] );
					.or.;
					( aSPC[ nPos , 10 ] <> aResult[ nX , ARESULT_TURNO ] );
					.or.;
					( aSPC[ nPos , 11 ] <> aResult[ nX , ARESULT_SEMANA ] );					
					.or.;
					( aSPC[ nPos , 12 ] <> aResult[ nX , ARESULT_TIPOHE ] );					
					.or.;
					( aSPC[ nPos , 13 ] <> aResult[ nX , ARESULT_PERCENT ] );					
					.or.;
					(lCpoCCT .And. (aSPC[ nPos, 14] <> aResult[ nX, ARESULT_FILCCT] .Or. aSPC[ nPos, 15] <> aResult[ nX, ARESULT_CODCCT ]));
				)	
				( cAlias )->( dbGoTo( aSPC[ nPos , 7 ] ) )
				
				cQuery := "UPDATE "
				cQuery += cTableName
				cQuery += " SET "
				cQuery += "PC_QUANTC="		+ Str( aResult[ nX , ARESULT_HORAS ] , aTamQuantC[1] , aTamQuantC[2] )
				cQuery += ", "
				cQuery += "PC_CC='"			+ aResult[ nX , ARESULT_CC ] + "'"
				cQuery += ", "
				cQuery += "PC_TPMARCA='"	+ aResult[ nX , ARESULT_TPMARCA ] + "'"
				cQuery += ", "
				cQuery += "PC_QTABONO="		+ Str( Min(nHrsAbono,aResult[ nX , ARESULT_HORAS ]) , aTamAbonos[1] , aTamAbonos[2] )
				cQuery += ", "
				cQuery += "PC_ABONO='"		+ cCodAbono + "'"
				
				//-- Portaria 1.510
				If cPaisLoc == "BRA"
					cQuery += ", "
					cQuery += "PC_TURNO='"			+ aResult[ nX , ARESULT_TURNO ] + "'"
					cQuery += ", "
					cQuery += "PC_SEMANA='"			+ aResult[ nX , ARESULT_SEMANA ] + "'"
					cQuery += ", "
					cQuery += "PC_TIPOHE='"			+ aResult[ nX , ARESULT_TIPOHE ] + "'"
					cQuery += ", "
					cQuery += "PC_PERCENT="		+ ALLTRIM(STR(aResult[ nX , ARESULT_PERCENT ] ))
				EndIf
				
				// Convenção coeltiva de trabalho
				If lCpoCCT
					cQuery += ", PC_FILCCT='" + If(!Empty(aResult[ nX, 21]), aResult[ nX, 21], " " ) + "'"
					cQuery += ", PC_CODCCT='" + If(!Empty(aResult[ nX, 22]), aResult[ nX, 22], " " ) + "'"
				EndIf 
				
				cQuery += " WHERE " 
				cQuery += cCpoRecno + "=" + Str( aSPC[ nPos , 7 ] , 10 , 0 ) 
				
				TcSqlExec( cQuery )
				cQuery := ""
				
			EndIF
			aSPC[ nPos , 7 ] := 0
		Else
			
			lGravar	:= .T.
			If ( nLenSPC > 0 )
				nPosX	:= Ascan( aSPC , { |x| dToS(x[1]) + x[2] == dToS(aResult[nX , 1]) + aResult[nX , 2] } )
				
				If ( nPosX > 0 )
					If aSPC[nPosX,1] == aResult[nX , ARESULT_DATA] .And. aSPC[nPosX,2] == aResult[nX , ARESULT_EVENTO] .And. aSPC[nPosX,3] == aResult[nX , ARESULT_HORAS] .And. aSPC[nPosX,6] == aResult[nX , ARESULT_TPMARCA]
						aSPC[ nPosX , 7 ] := 0
						lGravar	:= .F.
					EndIf 
				EndIf
			EndIf
				
			If ( (lGravar) .AND. ( RecLock( cAlias , .T. , .F. )) )									
				
				( cAlias )->( PC_FILIAL		)	:= cFil
				( cAlias )->( PC_MAT		)	:= cMat
				( cAlias )->( PC_DATA		)	:= aResult[ nX , ARESULT_DATA		]
				( cAlias )->( PC_PD			)	:= aResult[ nX , ARESULT_EVENTO 	]
				( cAlias )->( PC_QUANTC		)	:= aResult[ nX , ARESULT_HORAS  	]
				( cAlias )->( PC_CC			)	:= aResult[ nX , ARESULT_CC			]
				( cAlias )->( PC_TPMARCA	)	:= aResult[ nX , ARESULT_TPMARCA	]
				( cAlias )->( PC_QTABONO	)	:= Min(nHrsAbono,aResult[ nX , ARESULT_HORAS ])
				( cAlias )->( PC_ABONO		)	:= cCodAbono
				If __lCpoDataAlt .And. __lCpoUsuaAlt
				   	( cAlias )->( PC_DATAALT )	:= MsDate()
					( cAlias )->( PC_USUARIO )	:= If(Empty(cUserPon), " ", cUserPon)
				EndIf
				
				//-- Portaria 1.510
				If cPaisLoc == "BRA"
					( cAlias )->( PC_TURNO 	)  	:= aResult[ nX , ARESULT_TURNO ]
					( cAlias )->( PC_SEMANA	)  	:= aResult[ nX , ARESULT_SEMANA]
					( cAlias )->( PC_TIPOHE	)  	:= aResult[ nX , ARESULT_TIPOHE]
					( cAlias )->( PC_PERCENT)  	:= aResult[ nX , ARESULT_PERCENT]
				EndIf
				
				// Convenção coletiva de trabalho
				If lCpoCCT
					( cAlias )->( PC_FILCCT) := If(!Empty(aResult[ nX, 21]), aResult[ nX, 21], " " )
					( cAlias )->( PC_CODCCT) := If(!Empty(aResult[ nX, 22]), aResult[ nX, 22], " " )
				EndIf
				
				( cAlias )->( MsUnLock() )
			EndIf
		EndIf
		
		DelAbo( aPreAbonos )

		IF !Empty( aNewAbonos )

			GravaAbo( 	cFil								,;	//01 -> Filial do Funcionario
						cMat								,;	//02 -> Matricula do Funcionario
						aNewAbonos				    		,;	//03 -> Horarios do Apontamento Abonado
						aResult[ nX , ARESULT_DATA		]	,;	//04 -> Data da Geracao
						aResult[ nX , ARESULT_EVENTO	]	,;	//05 -> Codigo do Evento
						aResult[ nX , ARESULT_CC		]	,;	//06 -> Centro de Custo a ser Gravado
						aResult[ nX , ARESULT_TPMARCA	]	 ;	//07 -> Tipo de Marcacao   
					) 
		EndIF
		
	EndIF
	
Next nX

For nX := 1 To nLenSPC
	IF (;
			( aSPC[ nX , 7 ] > 0 );
			.and.;
			( aSPC[ nX , 4 ] == 0 );
			.and.;
			!( aSPC[ nX , 02 ] $ cEveMesA );
		 )
		( cAlias )->( dbGoTo( aSPC[ nX , 7 ] ) )
		IF RecLock( cAlias , .F. , .F. )
			IF !( cAlias )->( FkDelete( @cMsgErr ) )
				( cAlias )->( RollBackDelTran( cMsgErr ) )
			EndIF
			( cAlias )->( MsUnLock() )
		EndIF
		fAbonos( aSPC[ nX , 01 ] , aSPC[ nX , 2 ] , NIL , @aAbonos , aSPC[ nX , 6 ] , aSPC[ nX , 5 ] , aAbonosPer )
		DelAbo( aAbonos )
	EndIF
Next nX

IF !( nSvOrder == nOrder )
	( cAlias )->( dbSetOrder( nSvOrder ) )
EndIF

cFilAnt	:= cSvFilAnt

If lPnaApoSrc		 
	ExecBlock( "PNAPOSPC" , .F. , .F. , { cFil , cMat } , .F. )
EndIf

Return( NIL )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³GravaAbo  ³ Autor ³ Mauricio MR           ³ Data ³10/05/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Grava o Abonos no SPK.		                                ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>                                   ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>                                   ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Gravacao dos Pre-Abonos no SPK                              ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function GravaAbo(	cFil						,;	//01 -> Filial do Funcionario
							cMat						,;	//02 -> Matricula do Funcionario
							aHorarios				    ,;	//03 -> Horarios do Apontamento Abonado
							dDtGer						,;	//04 -> Data da Geracao
							cEvento						,;	//05 -> Codigo do Evento
							cCusto   					,;	//06 -> Centro de Custo a ser Gravado
							cTpMarc						 ;	//07 -> Tipo de Marcacao   
						 ) 

Local lPkTpMarca	:= ( Type( "SPK->PK_TPMARCA" ) == "C" )

Local nLoop
Local nLoops

DEFAULT	__lUsuaCpo		:= SPK->(ColumnPos("PK_USUARIO") > 0 .And. ColumnPos("PK_DATAALT") > 0 )

nLoops := Len( aHorarios )
For nLoop := 1 To nLoops
	
	IF SPK->( RecLock( "SPK" , .T. , .F. ) )
		SPK->PK_FILIAL	:= cFil
		SPK->PK_MAT		:= cMat
		SPK->PK_CODABO	:= aHorarios[ nLoop , AABONOS_CODIGO ] 
		SPK->PK_CODEVE	:= cEvento
	    SPK->PK_DATA	:= dDtGer
		SPK->PK_CC		:= cCusto
		SPK->PK_HRSABO	:= aHorarios[ nLoop , AABONOS_HORAS_ABO	] 
		SPK->PK_HORINI	:= aHorarios[ nLoop , AABONOS_HORAS_INI	]
		SPK->PK_HORFIM	:= aHorarios[ nLoop , AABONOS_HORAS_FIM	] 
		IF ( lPkTpMarca )
			SPK->PK_TPMARCA	:= cTpMarc
		EndIF
		SPK->PK_FLAG	:= "P"
		If __lUsuaCpo .And. __lCpoDataAlt .And. __lCpoUsuaAlt
			SPK->PK_DATAALT 	:= MsDate()
			SPK->PK_USUARIO 	:= __cUserId
		EndIf
		SPK->( MsUnLock() )
	EndIF        
	
	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Altera Flag da Faixa de Pre-Abono							  ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/	
	If aHorarios[ nLoop , ELEMENTOS_AABONOS + 1 ] > 0  // Para ( SR6->( FieldPos( "R6_HRINTER" ) ) > 0 ) ...podem existir registros forçados de abono cujo recno não existe na RF0 	
		RF0->( dbgoto( aHorarios[ nLoop , ELEMENTOS_AABONOS + 1 ] ) )
	
		If	RF0->RF0_ABONA <> 'S'
			IF RecLock( 'RF0' , .F. , .F. )
			   RF0->RF0_ABONA := 'S' 
			   RF0->( MsUnLock() )	
	        Endif
		EndIf 
	EndIf

Next nLoop

aHorarios := {}

Return( NIL )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³ DelAbo   ³ Autor ³ Mauricio MR           ³ Data ³13/05/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³ Deleta Abonos no SPK.		                                ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³ Vide Parametros                                            ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³                                                            ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³ Generico                                                   ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function DelAbo( aPreAbonos ) //01 -> Array de Abonos Pre-Abonados

Local cMsgErr
Local nLoop
Local nLoops

DEFAULT aPreAbonos := {}

nLoops := Len( aPreAbonos )
For nLoop := 1 To nLoops
	SPK->( dbGoto( aPreAbonos[ nLoop , AABONOS_RECNO ] ) )
	IF ( SPK->( Recno() ) == aPreAbonos[ nLoop , AABONOS_RECNO ] )
		IF RecLock( "SPK" , .F. , .F. )
			IF !SPK->( FkDelete( @cMsgErr ) )
				SPK->( RollBackDelTran( cMsgErr ) )
			EndIF
			SPK->( MsUnLock() )
		EndIF
	EndIF	
Next nLoop

aPreAbonos := {}

Return( NIL )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³fFiltAbo		³Autor³Mauricio MR		  ³ Data ³12/05/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Filtra Abonos											    ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico                  	                                ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function fFiltAbo( aAbonos , bSkip , bCondRet , aRetorno )

Local nHrsAbo	:= 0

Local nLoop
Local nLoops

DEFAULT aAbonos		:= {}
DEFAULT bSkip 		:= { || .F. }
DEFAULT bCondRet 	:= { || .T. }

aRetorno := {}

nLoops := Len( aAbonos )
For nLoop := 1 To nLoops
    IF Eval( bSkip , aAbonos[ nLoop ] )
       Loop
    EndIF
	IF Eval( bCondRet , aAbonos[ nLoop ] )
	   aAdd( aRetorno , aAbonos[ nLoop ] )
	EndIF
	nHrsAbo := SomaHoras( nHrsAbo , aAbonos[ nLoop , AABONOS_HORAS_ABO	] )
Next nLoop

Return( nHrsAbo )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³PerAponta ³ Autor ³ Equipe Advanced RH    ³ Data ³14/04/1997³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Retorna a data inicio e fim para apontamento das marcacoes. ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³          ³Obs.:Quando a Data Inicial e Maior que a Data Final a fun‡„o³
³          ³ir  considerar que o apontamento ‚ feito de um mes para   ou³
³          ³tro, e quando a Data Final for maior que a Data Inicial,   a³
³          ³fun‡„o ir  considerar que o apontamento ‚ feito no mˆs.     ³
³          ³Caso a dData nao for passado assume a dDataBase do Sistema. ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico                                                    ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function PerAponta(		dPerIni			,;	//Data Inicial passada como referencia
						dPerFim 		,;	//Data Final   passada como referencia
						dData			,;	//Data Base
						lShowHelp		,;	//Mostrar o Help
						cFil			,;	//Filial para GetMv
						lNewPer			,;	//Se eh para gerar um novo periodo
						lPerCompleto	,;	//Se o periodo esta preenchido com AAAAMMDD/AAAAMMDD ou AAAAMMDDAAAAMMDD (por referencia)
						lIncDate		,;	//Se Quando lNewPer Incrementa Data, caso contrario Decrementa
						lUseParamPer	,;	//Se quando periodo completo considerar dPerIni e dPerFim passados como parametro
						lForceDate		 ;  //Indica que deve criar o novo período baseado na database informada, ignorando se o período foi definido como completo
				 )

Local cSvFilAnt			:= cFilAnt
Local lPerNotOk			:= .F.

Local cDiaIni
Local cDiaFim
Local cMesIni
Local cMesFim
Local cAnoIni
Local cAnoFim
Local cPerAponta
Local nDiaIni
Local nDiaFim
Local nMesIniAux

DEFAULT dPerIni			:= Ctod("//")
DEFAULT dPerFim			:= Ctod("//")
DEFAULT dData			:= dDataBase
DEFAULT lShowHelp		:= .T.
DEFAULT cFil			:= cSvFilAnt
DEFAULT lNewPer			:= .F.
DEFAULT lIncDate		:= .T.
DEFAULT lUseParamPer	:= .F.
DEFAULT lForceDate		:= .F.

lPerCompleto		:= .F.

If !(FunName() == "PONA290")
	cFilAnt := IF( !Empty( cFil ) , cFil , cFilAnt )
Else
	cPerAponta := GetPaponta() //carrega o cPerAponta a partir do cFilAnt
EndIf

Begin Sequence

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Verifica o Modo de Acesso do Cadastro de Periodos de Apontamen³
	³to															   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	IF !( lPerNotOk := CheckModSPO() )
		Break
	EndIF

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Verifica se o Conteudo do  MV_PAPONTA esta OK  			   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	IF ( lPerNotOk := !PapontaOk( @cPerAponta , @nDiaIni , @nDiaFim , cFil ) )
		Break
	EndIF

	//Verifica se o período foi informado de forma completa: 20010101/20010131
	lPerCompleto := PerCompleto( @cPerAponta )

	//Se deve ignorar o período completo informado, ajusta nDiaIni e nDiaFim para calcular o novo período
	If lForceDate .and. lPerCompleto
		nDiaIni := Val(SubStr(cPerAponta, 7,2))
		nDiaFim := Val(SubStr(cPerAponta, 16,2))
		nMesIniAux := Val(SubStr(cPerAponta, 5,2))
		lPerCompleto := .F.
	EndIf
	
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Para Possibilitar que o periodo seja definido pelo    usuario³
	³ Este devera ser preenchido com a String de Data da   Seguinte³
	³ te forma AAAAMMDD/AAAAMMDD ou AAAAMMDDAAAAMMDD. Onde AAAA cor³
	³ responde ao ano com 4 digitos, MM ao mes com 2 digitos e   DD³
	³ corresponde ao dia com 2 Digitos. A barra (/) separadora   se³
	³ servira apenas para facilitar a leitura do periodo pelo  usua³
	³ rio. Essa forma de Preenchimento do Parametro ira   facilitar³
	³ as Empresas que reduzem ou aumentam o periodo em  determinado³
	³ mes. Obs.: Essa forma de preenchimento devera ser   utilizada³
	³ apenas para os meses em que o periodo for diferente do padrao³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	If lPerCompleto
		
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Quando Nao Considerar as Datas Passadas Redefine-as   conferme³
		³conteudo de MV_PAPONTA										   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		IF !( lUseParamPer )
			dPerIni := Stod( Left(	cPerAponta , 08 ) )
			dPerFim := Stod( Right(	cPerAponta , 08 ) )
		EndIF	
		
		// Quando for um novo Periodo Incrementa ou Decrementa
		// Só gera um novo período se a data não estiver contida no período atual
		IF ( lNewPer ) .And. dData < dPerIni .Or.  dData > dPerFim 
			// Apura o Novo periodo baseado no numero de dias do periodo anterior
			IF ( lIncDate )
				PonIncDate( @dPerIni , @dPerFim )
			Else
				PonDecDate( @dPerIni , @dPerFim )
			EndIF	
		EndIF
		
		Break
		
	EndIF
	
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³A Principio, Inicio ‚ no mes corrente.						   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	IF ( nDiaIni > nDiaFim )
		
		cMesIni := Month2Str( dData )
		cAnoIni := Year2Str( dData )
		cDiaIni := Day2Str( Min( nDiaIni , f_UltDia( Ctod( "01/" + cMesIni + "/" + cAnoIni , "DDMMYYYY" ) ) ) )
		dPerIni := Ctod( cDiaIni + "/" + cMesIni + "/" + cAnoIni , "DDMMYYYY" )
		
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Acrescenta um dia ao Periodo Inicial se Inicio do Periodo for ³
		³>= 29 e Mes Fev.											   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		IF (;
				(;
					( Month( dPerIni ) == 2 );
					.or.;
					( ( Month( dPerIni ) - 1 )  == 2 );
				);
				.and.;
				( nDiaIni >= 29 );
			)	
			IF ( Day( dPerIni ) != nDiaIni )
				dPerIni++
			EndIF
		EndIF
		
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Se Inicio for Apos Data-Base, Retrocede 1 mes.				   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		IF ( dPerIni > dData )
			cMesIni := Month2Str( IF( Month( dData ) - 1 == 0 , 12 , Month( dData ) -1 ) )
			cAnoIni := Year2Str( IF( cMesIni == "12" , Year(dData) - 1 , Year( dData ) ) )
			cDiaIni := Day2Str( Min( nDiaIni , f_UltDia( Ctod( "01/" + cMesIni + "/" + cAnoIni , "DDMMYYYY" ) ) ) )
			dPerIni := Ctod( cDiaIni + "/" + cMesIni + "/" + cAnoIni , "DDMMYYYY" )
		EndIF
		
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³A Principio, Data Final ‚ 1 mes apos a data Inicial.		   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		cMesFim := Month2Str( IF( Month( dPerIni ) + 1 == 13 , 1 , Month( dPerIni ) + 1 ) )
		cAnoFim := Year2Str( IF( cMesFim == "01" , Year( dPerIni ) + 1 , Year( dPerIni ) ) )
		cDiaFim := Day2Str( Min( nDiaFim , f_UltDia( Ctod( "01/" + cMesFim + "/" + cAnoFim , "DDMMYYYY" ) ) ) )
		dPerFim := Ctod( cDiaFim + "/" + cMesFim + "/" + cAnoFim , "DDMMYYYY" )
		
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³A Data Final ‚ no mesmo mes da Data Inicio.				   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		IF ( ( dPerFim - dPerIni ) > 50 )
			cDiaFim := Day2Str( Min( nDiaFim , f_UltDia( Ctod( "01/" + cMesIni + "/" + cAnoIni , "DDMMYYYY" ) ) ) )
			dPerFim := Ctod( cDiaFim + "/" + cMesIni + "/" + cAnoIni , "DDMMYYYY" )
		EndIF
		
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Acrescenta um dia ao Periodo Inicial quando o dia deste    for³
		³igual ao do Periodo Final									   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		IF (;
				(;
					( Day( dPerIni ) == Day( dPerFim ) );
					.or.;
					( Day( dPerIni ) < Day( dPerFim ) );
		    	);
		    	.and.;
		    	( AnoMes( dPerIni ) != AnoMes( dPerFim ) );
		   ) 
			dPerIni++
		EndIF
		
		Break
		
	EndIF
	
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³A Principio, Final ‚ no mes corrente.						   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	cMesFim := Month2Str( dData )
	cAnoFim := Year2Str( dData )
	cDiaFim := Day2Str( Min( nDiaFim , f_UltDia( Ctod( "01/" + cMesFim + "/" + cAnoFim , "DDMMYYYY" ) ) ) )
	dPerFim := Ctod( cDiaFim + "/" + cMesFim + "/" + cAnoFim , "DDMMYYYY" )
	
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Se Final for Antes da Data-Base, Avan‡a 1 mes.				   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	IF ( dPerFim < dData )
		cMesFim := Month2Str( IF( Month( dData ) + 1 == 13 , 1 , Month( dData ) +1 ) )
		cAnoFim := Year2Str( IF( cMesFim == "01" , Year( dData ) + 1 , Year( dData ) ) )
		cDiaFim := Day2Str( Min( nDiaFim , f_UltDia( Ctod( "01/" + cMesFim +"/" + cAnoFim , "DDMMYYYY" ) ) ) )
		dPerFim := Ctod( cDiaFim + "/" + cMesFim + "/" + cAnoFim , "DDMMYYYY" )
	EndIF
	
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³A Principio, Data Inicial ‚ 1 mes anterior a data Final.	   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	If nDiaFim > nDiaIni
		If Empty(nMesIniAux) .Or. (!Empty(nMesIniAux) .And. Month( dPerFim ) == nMesIniAux)
			cMesIni := Month2Str( IF( Month( dPerFim ) - 1 == 0 , 12 , Month( dPerFim ) ) )
			cAnoIni := Year2Str( IF( cMesIni == "12" , Year(dPerFim) - 1 , Year( dPerFim ) ) )
			cDiaIni := Day2Str( Min( nDiaIni , f_UltDia( Ctod( "01/" + cMesIni + "/" + cAnoIni , "DDMMYYYY" ) ) ) )
			dPerIni := Ctod( cDiaIni + "/" + cMesIni + "/" + cAnoIni , "DDMMYYYY" )
		Else
			cMesIni := Month2Str( IF( Month( dPerFim ) - 1 == 0 , 12 , Month( dPerFim ) -1 ) )
			cAnoIni := Year2Str( IF( cMesIni == "12" , Year(dPerFim) - 1 , Year( dPerFim ) ) )
			cDiaIni := Day2Str( Min( nDiaIni , f_UltDia( Ctod( "01/" + cMesIni + "/" + cAnoIni , "DDMMYYYY" ) ) ) )
			dPerIni := Ctod( cDiaIni + "/" + cMesIni + "/" + cAnoIni , "DDMMYYYY" )
		EndIf
	Else
		cMesIni := Month2Str( IF( Month( dPerFim ) - 1 == 0 , 12 , Month( dPerFim ) -1 ) )
		cAnoIni := Year2Str( IF( cMesIni == "12" , Year(dPerFim) - 1 , Year( dPerFim ) ) )
		cDiaIni := Day2Str( Min( nDiaIni , f_UltDia( Ctod( "01/" + cMesIni + "/" + cAnoIni , "DDMMYYYY" ) ) ) )
		dPerIni := Ctod( cDiaIni + "/" + cMesIni + "/" + cAnoIni , "DDMMYYYY" )
	EndIf
	
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³A Data Inicial ‚ no mesmo mes da Data Final.				   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	IF ( ( dPerFim - dPerIni ) > 50 ) 
		cDiaIni := Day2Str( Min( nDiaIni , f_UltDia( Ctod( "01/" + cMesFim + "/" + cAnoFim , "DDMMYYYY" ) ) ) )
		dPerIni := Ctod( cDiaIni + "/" + cMesFim + "/" + cAnoFim , "DDMMYYYY" )
	EndIF
	
End Sequence

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Se ocorreu alguma Inconsistencia Verifica se Deve Mostrar   o³
³ Help														   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
IF ( lPerNotOk )
	IF ( lShowHelp )
		Help("" , 1 , "PERNCAD" )
	EndIF	
EndIF

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Restaura cFilAnt											   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
cFilAnt := cSvFilAnt
	
Return( !( lPerNotOk ) )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³GetPerAtu		³Autor³Marinaldo de Jesus ³ Data ³25/08/2003³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Disponibilizar Dialogo para Alteracao do Periodo 			³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>     								³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Pona080Calend												³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Retorno  ³NIL															³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³< Vide Parametros Formais >									³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function GetPerAtu( dDataIni , dDataFim , oDataIni , oDataFim )

GetPonMesDat( @dDataIni , @dDataFim  , xFilial("SRA") )
IF ( ValType( oDataIni ) == "O" )
	oDataIni:Refresh()
EndIF	
IF ( ValType( oDataFim ) == "O" )
	oDataFim:Refresh()
EndIF	

Return( NIL )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³GetPerPrev		³Autor³Marinaldo de Jesus ³ Data ³25/08/2003³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Disponibilizar Dialogo para Alteracao do Periodo 			³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>     								³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Pona080Calend												³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Retorno  ³NIL															³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³< Vide Parametros Formais >									³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function GetPerPrev(	dDataIni	,;
						dDataFim	,;
						oDataIni	,;
						oDataFim	,;
						lShowHelp	,;
						lGetNewPer	,;
						lIncDate	,;
						lUseParamPer ;
					)

Local dData := ( dDataIni - 1 )

Local nFimPer
Local nDay

DEFAULT lShowHelp		:= .T.
DEFAULT lGetNewPer		:= .T.
DEFAULT lIncDate		:= .F.
DEFAULT lUseParamPer	:= .T.

IF PapontaOk( NIL , NIL , @nFimPer )
	IF ( nFimPer <> NIL )
		nDay := Day( dData )
		IF ( nDay > nFimPer )
			While ( Day( dData ) <> nFimPer )
				--dData	
			End While
		EndIF	
	EndIF
EndIF

PerAponta(	@dDataIni 		,;	//Data Inicial passada como referencia
			@dDataFim 		,;	//Data Final   passada como referencia
			dData			,;	//Data Base
			lShowHelp		,;	//Mostrar o Help
			xFilial("SRA")	,;	//Filial para GetMv
			lGetNewPer		,;	//Se eh para gerar um novo periodo
			NIL				,;	//Se o periodo esta preenchido com AAAAMMDD/AAAAMMDD ou AAAAMMDDAAAAMMDD (por referencia)
			lIncDate		,;  //Se Quando lNewPer Incrementa Data, caso contrario Decrementa
			lUseParamPer  	 ;	//Se quando periodo completo considerar dPerIni e dPerFim passados como parametro
		  )

IF ( ValType( oDataIni ) == "O" )
	oDataIni:Refresh()
EndIF	
IF ( ValType( oDataFim ) == "O" )
	oDataFim:Refresh()
EndIF	

Return( NIL )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³GetPerNext		³Autor³Marinaldo de Jesus ³ Data ³25/08/2003³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Disponibilizar Dialogo para Alteracao do Periodo 			³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>     								³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Pona080Calend												³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Retorno  ³NIL															³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³< Vide Parametros Formais >									³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function GetPerNext(	dDataIni 	,;
						dDataFim 	,;
						oDataIni 	,;
						oDataFim 	,;
						lShowHelp	,;
						lGetNewPer	,;
						lIncDate	,;
						lUseParamPer ;
					)

Local dData := ( dDataFim + 1 )

Local nIniPer
Local nDay

DEFAULT lShowHelp		:= .T.
DEFAULT lGetNewPer		:= .T.
DEFAULT lIncDate		:= .T.
DEFAULT lUseParamPer    := .T.

IF PapontaOk( NIL , @nIniPer )
	IF ( nIniPer <> NIL )
		nDay := Day( dData )
		IF ( nDay < nIniPer )
			While ( Day( dData ) <> nIniPer )
				++dData	
			End While
		EndIF	
	EndIF
EndIF

PerAponta(	@dDataIni 		,;	//Data Inicial passada como referencia
			@dDataFim 		,;	//Data Final   passada como referencia
			dData			,;	//Data Base
			lShowHelp		,;	//Mostrar o Help
			xFilial("SRA")	,;	//Filial para GetMv
			lGetNewPer		,;	//Se eh para gerar um novo periodo 
			NIL				,;	//Se o periodo esta preenchido com AAAAMMDD/AAAAMMDD ou AAAAMMDDAAAAMMDD (por referencia)
			lIncDate		,;  //Se Quando lNewPer Incrementa Data, caso contrario Decrementa
			lUseParamPer 	 ;	//Se quando periodo completo considerar dPerIni e dPerFim passados como parametro
		  )

IF ( ValType( oDataIni ) == "O" )
	oDataIni:Refresh()
EndIF	
IF ( ValType( oDataFim ) == "O" )
	oDataFim:Refresh()
EndIF	

Return( NIL )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³GetPerSPO		³Autor³Marinaldo de Jesus ³ Data ³29/08/2003³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Retorna consulta SXB ao RPO                      			³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>     								³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Pona080Calend												³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Retorno  ³NIL															³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³< Vide Parametros Formais >									³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function GetPerSPO( dDataIni , dDataFim , oDataIni , oDataFim )

IF ( PerApoConPad() )
	dDataIni := SPO->PO_DATAINI
	dDataFim := SPO->PO_DATAFIM
	IF ( ValType( oDataIni ) == "O" )
		oDataIni:Refresh()
	EndIF	
	IF ( ValType( oDataFim ) == "O" )
		oDataFim:Refresh()
	EndIF	
EndIF

Return( NIL )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³GetPaponta ³ Autor ³ Marinaldo de Jesus   ³ Data ³30/06/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Obtem o Conteudo do parametro MV_PAPONTA                    ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico                                                    ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function GetPaponta( cFil )

Local cSvFilAnt		:= cFilAnt

Local cPerAponta

DEFAULT cFil		:= cFilAnt

cFilAnt		:= IF( !Empty( cFil ) , cFil , cFilAnt )
cPerAponta	:= AllTrim( StrTran( GetMv( "MV_PAPONTA" , NIL , "" ) , " " , "" ) )
cFilAnt		:= cSvFilAnt

Return( cPerAponta )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³PapontaOk  ³ Autor ³ Marinaldo de Jesus   ³ Data ³30/06/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Verifica se o parametro MV_PAPONTA este com o Conteudo OK   ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico                                                    ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function PapontaOk( cPerAponta , nIniPer , nFimPer , cFil )

Local lPapontaOk := .T.

DEFAULT cPerAponta := GetPaponta( cFil )

Begin Sequence

	IF !( lPapontaOk := !Empty( cPerAponta ) )
		Break
	EndIF
	
	IF PerCompleto( @cPerAponta )
		Break
	EndIF

	nIniPer	:= Val( Left( cPerAponta , 2 ) )
	IF !( lPapontaOk := ( nIniPer > 0 ) )
		Break
	EndIF

	nFimPer := Val( Right( cPerAponta , 2 ) )
	IF !( lPapontaOk := ( nFimPer > 0 ) )
		Break
	EndIF

	IF !( lPapontaOk := ( nIniPer <= 31 ) )
		Break
	EndIF

	IF !( lPapontaOk := ( nFimPer <= 31 ) )
		Break
	EndIF

	IF !( lPapontaOk := ( nIniPer <> nFimPer ) )
		Break
	EndIF

End Sequence

Return( lPapontaOk )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³PerCompleto³ Autor ³ Marinaldo de Jesus   ³ Data ³30/06/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Verifica se o parametro MV_PAPONTA este Preenchido com o con³
³          ³teudo equivalente a "AAAAMMDD/AAAAMMDD"                     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico                                                    ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function PerCompleto( cPerAponta , cFil )
DEFAULT cPerAponta := GetPaponta( cFil )
Return( ( ( Len( cPerAponta ) == 17 ) .or. ( Len( cPerAponta ) == 16 ) ) )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³GetPonMes  ³ Autor ³ Marinaldo de Jesus   ³ Data ³01/07/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Obtem o Conteudo do parametro MV_PONMES                     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico                                                    ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function GetPonMes( cFil )

Local cSvFilAnt		:= cFilAnt

Local cPonMes

DEFAULT cFil		:= cFilAnt
If !(FunName() == "PONA290")
	cFilAnt	:= IF( !Empty( cFil ) , cFil , cFilAnt )
EndIf
cPonMes	:= AllTrim( StrTran( GetMv( "MV_PONMES" , NIL , "" ) , " " , "" ) )
cFilAnt	:= cSvFilAnt

Return( cPonMes )

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³DescAbono ³ Autor ³ Equipe Advanced RH    ³ Data ³11/03/2002³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Verifica a existencia do codigo de abono e retorna a Desc. ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Function DescAbono( cCodigo , cTipoRet , cCampo , cFil , nSize )

Local uRet			:= ""

Local nPoscCampo
Local nPosQtdAbo
Local nPosQtdCal
Local cCpoQtdAbo
Local cCpoQtdCal

DEFAULT cTipoRet	:= ""
DEFAULT cCodigo 	:= ""
DEFAULT cCampo		:= ""
DEFAULT nSize		:= GetSx3Cache( "P6_DESC" , "X3_TAMANHO" )

cTipoRet	:= Upper( AllTrim( cTipoRet ) )
cCampo		:= Upper( AllTrim( cCampo ) )
cFil		:= xFilial( "SP6" , cFil )
cCodigo		:= IF( Empty( cCodigo ) .and. cTipoRet == "L" , &(ReadVar()) , cCodigo )

IF SP6->( MsSeek( cFil + cCodigo ) )
	uRet 		:= IF( ( cTipoRet == "L" ) , .T. , Padr( SP6->P6_DESC , nSize ) )
	cCpoQtdAbo	:= IF( cCampo == "PC_DESCABO" , "PC_QTABONO" ,"PH_QTABONO" )
	cCpoQtdCal	:= IF( cCampo == "PC_DESCABO" , "PC_QUANTC"  ,"PH_QUANTC"  )
	IF IsInGetDados( { cCampo , cCpoQtdAbo , cCpoQtdCal } )
	    IF ( ( nPoscCampo := GdFieldPos( cCampo ) ) > 0 )
			aCols[n,nPoscCampo] := SP6->P6_DESC
    	EndIF
		IF ( ( cTipoRet == "L" ) .and. ( cCampo $ "PC_DESCABO*PH_DESCABO" ) )
			nPosQtdAbo := GdFieldPos( cCpoQtdAbo )
			nPosQtdCal := GdFieldPos( cCpoQtdCal )
			IF nPosQtdAbo > 0 .and. nPosQtdCal > 0
				IF aCols[n,nPosQtdAbo] == 0
					aCols[n,nPosQtdAbo] := aCols[n,nPosQtdCal] // Calculado
				EndIF
			EndIF
		EndIF
	EndIF
Else
	uRet := IF( ( cTipoRet == "L" ) , .F. , Space( nSize ) )
EndIF

Return( uRet )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³fCargaId³Autor³Mauro     1a. Versao  	   ³ Data ³18/12/1996³
³          ³        ³Autor³Marinaldo 2a. Versao  	   ³ Data ³04/08/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Carregar Array com os Identificadores e Verbas               ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>                                    ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>                                    ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico                                                     ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function fCargaId( aCodigos , cFil , lStop )

Local lRet			:= .T.
Local lShowHelp		:= .T.

Local cFilSX5
Local cFilSP9
Local nOrderSP9
Local nSvSp9Ord
Local nPosEmpFil
Local nLenaCod

aCodigos			:= {}

DEFAULT cFil		:= xFilial( "SP9" , IF( Type( "SRA->RA_FILIAL" ) == "C" , SRA->RA_FILIAL , NIL ) )
DEFAULT lStop		:= .T.

Begin Sequence

	DEFAULT aCargaIdCache	:= {}
	
	cFilSP9	:= xFilial( "SP9" , cFil )
	IF ( ( nPosEmpFil := aScan( aCargaIdCache , { |x| ( x[1] == cEmpAnt ) .and. ( x[2] == cFilSp9 ) } ) ) > 0 )
		Break
	EndIF

	cFilSX5	:= xFilial( "SX5" , cFil )
	IF !( lRet := SX5->( MsSeek( cFilSX5 + "20" , .F. ) ) )
		IF ( lStop )
			lShowHelp := .F.
			Help( "" , 1 , "EVENTNCAD" )
		EndIF
		Break
	EndIF

	nOrderSP9	:= RetOrdem( "SP9" , "P9_FILIAL+P9_IDPON+P9_CODIGO" )
	nSvSp9Ord	:= SP9->( IndexOrd() )
	IF !( nOrderSP9 == nSvSp9Ord )
		SP9->( dbSetOrder( nOrderSP9 ) )
	EndIF
	SP9->( dbSeek( cFilSP9 , .F. ) )
	While SP9->( !Eof() .and. ( P9_FILIAL == cFilSP9 ) )
		IF SP9->( !Empty( P9_IDPON ) .Or. !Empty( P9_CODFOL ) .Or. P9_DESCDSR == "S") 
			aAdd( aCodigos , Array( 04 ) )
			nLenaCod := Len( aCodigos )
			aCodigos[nLenaCod,01] := SP9->P9_CODIGO
			aCodigos[nLenaCod,02] := SP9->P9_IDPON
			aCodigos[nLenaCod,03] := SP9->P9_DESCDSR
			aCodigos[nLenaCod,04] := SP9->P9_CODFOL
		EndIF
		SP9->(dbSkip())
	End While
	SP9->( dbSetOrder( nSvSp9Ord ) )
	aAdd( aCargaIdCache , { cEmpAnt , cFilSP9 , aClone( aCodigos ) } )
	nPosEmpFil	:= Len( aCargaIdCache )
	aCodigos	:= {}

End Sequence

IF !Empty( nPosEmpFil )
	aCodigos := aClone( aCargaIdCache[ nPosEmpFil , 3 ] )
EndIF

IF !( lRet := !Empty( aCodigos ) )
	IF ( ( lStop ) .and. ( lShowHelp ) )
		Help( " ",1,"EVENTNCAD" )
	EndIF	
EndIF

Return( lRet )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³RstfCargaId   ³ Autor ³Marinaldo de Jesus     ³ Data ³04/08/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Reinicializa as Statics em fCargaId()                       	³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³																³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL																³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function RstfCargaId()

aCargaIdCache := {}

Return( NIL )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o	   ³GetEveIdPon   ³Autor³ Marinaldo de Jesus  ³ Data ³15/08/2002³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Retorna Array com Identificadores de Ponto x Eventos de acor³
³          ³do com o SX5                                				³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais> 									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais> 									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso	   ³Generico 												    ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function GetEveIdPon( aCodigos , cFil , aLogFile, lChkEve )

Local aEveIds		:= {}
Local aArea			:= GetArea()
Local aAreaSX5		:= SX5->( GetArea() )
Local aLastLog		:= {}
Local aSX5			:= {}
Local cTabId		:= "20"
Local cChaveId		:= ""
Local cIdPon		:= "" 
Local nEveId 		:= 0
Local nPosId		:= 0
Local nEvesSX5		:= 0
Local nTotIdPonto	:= 0
Local nI			:= 0
Local nLenSX5		:= 0

DEFAULT aCodigos	:= {}
DEFAULT cFil		:= cFilSX5
DEFAULT aLogfile	:= {}  
DEFAULT lChkEve		:= .F.

IF Empty( aCodigos )
	aCodigos := {}
	fCargaId( @aCodigos , cFil , .F. )
EndIF

aLastLog := aClone( aLogFile )

cFil 		:= xFilial( "SX5" , cFil )
cChaveId	:= ( cFil + cTabId )

IF SX5->( dbSeek( cChaveId , .F. ) ) 
	aSX5 := FWGetSX5("20")

	If !Empty(aSX5)
		nLenSX5 := Len(aSX5)	

		For nI := 1 To nLenSX5
		If aSX5[nI,1] == cFil
			aAdd( aEveIds , Array( 3 ) )
			cIdPon						:= Upper( AllTrim( aSX5[nI,3] ) )
			aEveIds[ ++nEveId , 01 ]	:= cIdPon
		IF ( nPosId := aScan( aCodigos , { |x| Upper( AllTrim( x[2] ) ) == cIdPon } ) ) == 0
			aEveIds[ nEveId , 02 ]	:= ""
		Else
			aEveIds[ nEveId , 02 ]	:= aCodigos[ nPosId , 01 ]
		EndIF
		aEveIds[ nEveId , 03 ]		:= SX5->( x5Descri() )   
		IF lChkEve
			IF Empty( aEveIds[ nEveId , 02 ] ) 
				aAdd( aLogFile , ( STR0117 + aEveIds[ nEveId , 01 ] + " - " + aEveIds[ nEveId , 03 ] ) ) //'Nao Foi Encontrado Evento para o Id. de Ponto: '
			EndIF
		EndIF
		EndIf
		Next
	EndIf
EndIF             

nTotIdPonto:= 44

nEvesSX5 := Len( aEveIds )

If nEvesSX5 >= 46 .And. nEvesSX5 <= 51
	nTotIdPonto := nEvesSX5
EndIf

IF ( !( ArrayCompare( aLastLog , aLogFile ) ) .or. ( nEvesSX5 < nTotIdPonto ) .or. ( nEvesSX5 > nTotIdPonto ) )
	aAdd( aLogFile , "" )
	aAdd( aLogFile , STR0118 )									//'- O Apontamento nao foi Efetuado porque Foram Encontradas Inconsitencias nos Eventos. ' 
	IF ( ( nEvesSX5 < nTotIdPonto ) .or. ( nEvesSX5 > nTotIdPonto ) )
		IF ( nEvesSX5 < nTotIdPonto )
			aAdd( aLogFile , STR0180 )							//'- Estao faltado codigos de Identificadores de Ponto na Tabela 20 do Configurador. '
 	 	ElseIF ( nEvesSX5 > nTotIdPonto )
			aAdd( aLogFile , STR0183 )							//'- Existem Identificadores do Ponto Duplicados na Tabela 20 do Condigurador.'
		EndIF
 	 	aAdd( aLogFile , STR0181 + StrZero( nTotIdPonto , 2 ) )			//'- Numero de Identificadores requeridos: '
 	 	aAdd( aLogFile , STR0182 + StrZero( nEvesSX5 , 2 ) )	//'- Numero de Identificadores Existentes: '
	Else
		IF lChkEve
			aAdd( aLogFile , STR0119 )								//'- Esta Faltando Vincular os Identificadores de Ponto Acima a Eventos. '
		EndIF
	EndIF
EndIF

( RestArea( aAreaSX5 ) , RestArea( aArea ) )

Return( aClone( aEveIds ) )  



/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o	   ³ObtemEveNoDele³Autor³ Marinaldo de Jesus  ³ Data ³15/08/2002³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Obtem Eventos que nao Podem ser Deletados pela GravaSPC()   ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais> 									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais> 									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso	   ³Generico 												    ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function ObtemEveNoDele( aCodigos )

Local cEvesNoDele	:= ""
Local nPos			:= 0

DEFAULT aCodigos := {}

//-- Evento de Faltas/Antrasos Meses Anteriores Autorizado
IF ( nPos := aScan( aCodigos , { |x| x[2] == "022A" } ) ) > 0
	cEvesNoDele += aCodigos[ nPos , 01 ]
EndIF

//-- Evento de Faltas/Antrasos Meses Anteriores Nao Autorizado
IF ( nPos := aScan( aCodigos , { |x| x[2] == "021N" } ) )  > 0
	cEvesNoDele += ( "/" + aCodigos[ nPos , 01 ] )
EndIF

//-- Evento de DSR Ultima Semana Periodo Anterior
IF ( nPos := aScan( aCodigos , { |x| x[2] == "036N" } ) ) > 0
	cEvesNoDele += ( "/" + aCodigos[ nPos , 01 ] )
EndIF

//-- Evento de Hora Extra Inter Jornada Ultima Semana Periodo Anterior
If Type('lHrInter') == 'L'
	IF ( (lHrInter) .AND. (nPos := aScan( aCodigos , { |x| x[2] == "038N" } ) ) > 0 )
		cEvesNoDele += ( "/" + aCodigos[ nPos , 01 ] )		
	EndIF
EndIf

Return( cEvesNoDele )    


/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³ObtemIdPon   ³Autor ³Mauricio MR          ³ Data ³25/03/2005³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Verifica a Existencia do Id.Ponto e Evento correspondente   ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³< Vide Parametros Formais >								  	³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³< Vide Parametros Formais >								  	³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function ObtemIdPon( aEvesIds, cId, lOnlyId )
Local lRet	:= .F.
Local nPos	:= 0   

Default aEvesIds := {}
DEFAULT lOnlyId:= .F.

If Empty(aEvesIds)
	aEvesIds := GetEveIdPon( , xFilial("SRA") )
EndIf

If lOnlyId
	lRet:= !Empty( (nPos:= Ascan(aEvesIds,{|aId| SUBSTR(aId[1],1,4) == cId  } ) ))
Else
	lRet:= !Empty( (nPos:= Ascan(aEvesIds,{|aId| SUBSTR(aId[1],1,4) == cId .AND. !Empty(aId[2]) } ) ))
Endif
Return lRet

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³fTotaliza ³ Autor ³ Mauro                 ³ Data ³ 10/12/96 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Totalizar as Verbas do SPC                                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Function fTotaliza( aTotaliza , cFil , cMat , bAcessaSPC )

Local cFilMat		:= ""
Local dDataIni		:= Ctod("//")
Local dDataFim		:= dDataIni

DEFAULT cFil 		:= SRA->RA_FILIAL
DEFAULT cMat 		:= SRA->RA_MAT
DEFAULT aTotaliza	:= {}
DEFAULT bAcessaSPC	:= { || .T. }

IF PerAponta( @dDataIni , @dDataFim , NIL , NIL , cFil )

	cFilMat	:= ( cFil + cMat )
	IF SPC->( dbSeek( cFilMat , .F.  ) )
	
		While SPC->( !Eof() .and. cFilMat == PC_FILIAL + PC_MAT )
	
			IF SPC->( PC_DATA < dDataIni .or. PC_DATA > dDataFim )
				SPC->( dbSkip() )
				Loop
			EndIF
	
			IF !Eval( bAcessaSPC )
				SPC->( dbSkip() )
				Loop
			EndIF
	
			IF SPC->( ( nPos := aScan( aTotaliza , { |x| x[1] = IF( !Empty( PC_PDI ) , PC_PDI , PC_PD ) } ) ) > 0 )
				aTotaliza[nPos,2] := SomaHoras( aTotaliza[nPos,2] , SPC->( IF( PC_QUANTI > 0 , 0 , SubHoras( PC_QUANTC , PC_QTABONO ) ) ) )
				aTotaliza[nPos,3] := SomaHoras( aTotaliza[nPos,3] , SPC->PC_QUANTI  )
				aTotaliza[nPos,4] := SomaHoras( aTotaliza[nPos,4] , SPC->PC_QTABONO )
			Else
				SPC->( aAdd( aTotaliza , { IF( !Empty( PC_PDI ) , PC_PDI , PC_PD ) , IF( PC_QUANTI > 0 , 0 , SubHoras( PC_QUANTC , PC_QTABONO ) ) , PC_QUANTI , PC_QTABONO } ) )
			EndIF
			
			SPC->( dbSkip() )

		End While
	
	EndIF

EndIF
	
Return( NIL )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³fTabTurno ³ Autor ³ Equipe Advanced RH    ³ Data ³18/11/1997³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³ Preenche um Array com a Tabela de Hor rios dos Turnos      ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³ fTabTurno( aTabTno , cFil )                                ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parƒmetros³ aTabTno = Array a ser alimentado com as Tabelas            ³
³          ³ cFil    = Filial para Pesquisa                             ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³ lRet                                                       ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³ Gen‚rico                                                   ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function fTabTurno(aTabTno, cFil, lExecQryTop, bCond, cTurno)

Local lRet		:= .T.
Local nSR6Rec	:= SR6->( Recno() )

DEFAULT aTabTno	:= {}
DEFAULT cTurno	:= ""

IF ( lRet := xRetModo("SR6","SPJ") )
	IF cFil == NIL
		If !Empty(cTurno)
			SR6->( MsSeek( xFilial( "SR6" , cFil ) + cTurno , .T. ) )
		Else
			SR6->( dbGoTop() )
		EndIf
	Else
		cFil := xFilial( "SR6" , cFil )
		If !Empty(cTurno)
			SR6->( MsSeek( cFil + cTurno , .T. ) )
		Else
			SR6->( MsSeek( cFil , .T. ) )
		EndIf
	EndIF

	While SR6->( !Eof() .And. If(cFil == Nil, .T., cFil == R6_FILIAL) .And. If(Empty(cTurno), .T., R6_TURNO == cTurno))
		fTabPadrao( @aTabTno , SR6->R6_FILIAL , SR6->R6_TURNO , lExecQryTop , bCond )
		SR6->( dbSkip() )
	End While
	IF !( lRet := !Empty( aTabTno ) )
		Help(' ',1,'TPADNCAD')
	EndIF
EndIF

IF ( SR6->( Recno() ) != nSR6Rec )
	SR6->( dbGoto( nSR6Rec ) )
EndIF

Return( lRet )

/*/{Protheus.doc} fTrocaTno
Adiciona os Turnos pelos quais o funcionario passou durante o periodo.
@type function
@author Equipe Advanced RH
@since 03/09/1998
@param dPerIni, date, Periodo Inicial a ser pesquizado
@param dPerFim, date, Periodo Final a ser pesquizado
@param aTurnos, array, Array a ser alimentado com as trocas de turno
@param aSPF, array, Array com as Trocas de Turno do SPF
@param cSeq, character, sequência da tabela de horário usada na inclusão da troca de turno no 1º dia
@param lAddTrcIniPer, logical, indica se deve ser incluída uma troca de turno no 1º dia do período mesmo que não tenha trocas na SPF
@return logical, Indica se houve trocas de turno no período
/*/
Function fTrocaTno( dPerIni, dPerFim, aTurnos, aSPF, cSeq, lAddTrcIniPer )

Local cFil			:= SRA->RA_FILIAL
Local cMat			:= SRA->RA_MAT
Local cRegra		:= SRA->RA_REGRA
Local cTurno		:= SRA->RA_TNOTRAB
Local cSeqTurn		:= SRA->RA_SEQTURN
Local lInterm		:= SRA->RA_TPCONTR == "3"
Local cAlias		:= "SPF"
Local cAliasQuery	:= cAlias
Local dData     	:= Ctod("//")
Local lTrocaTno		:= .F.
Local nX        	:= 0
Local nFornX		:= 0
Local nY        	:= 0
Local nFornY		:= 0
Local cIniData	 	:= ""
Local cFimData		:= ""
Local cQuery		:= ""
Local aSvAlias		:= GetArea()

Private lContrInt 	:= SRC->(ColumnPos("RC_CONVOC")) > 0

Static aSpfFields
Static cQrySpfFields
Static nSpfFields
Static __oSt4
Static __cEmpAux4

DEFAULT aSpfFields := ( cAlias )->( dbStruct() )
DEFAULT nSpfFields := Len( aSpfFields )

If ( cQrySpfFields == NIL )
	cQrySpfFields := ""
	For nX := 1 To nSpfFields
		cQrySpfFields += aSpfFields[ nX , 01 ] + ", "
	Next nX
EndIf

DEFAULT dPerIni 		:= Ctod("//")
DEFAULT dPerFim			:= Ctod("//")
DEFAULT aTurnos			:= {}
DEFAULT aSPF			:= {}
DEFAULT lAddTrcIniPer	:= .T.

If Empty( dPerIni ) .or. Empty( dPerFim )
	PerAponta( @dPerIni , @dPerFim , NIL , NIL , cFil )
EndIf

aTurnos := {}

IF Empty( aSPF ) 
	
	cIniData	:= Dtos( dPerIni )
	cFimData	:= Dtos( dPerFim )
	
	cAliasQuery := ( "__Q" + cAliasQuery + "QRY" )
	
	If __oSt4 == Nil .or. ( __cEmpAux4 == Nil .or. __cEmpAux4 <> cEmpAnt )
		
		__cEmpAux4   := cEmpAnt
		
		__oSt4 := FWPreparedStatement():New()
		
		cQuery := "SELECT "
		cQuery += cQrySpfFields
		cQuery += "R_E_C_N_O_ RECNO "
		cQuery += " FROM "
		cQuery += InitSqlName( cAlias )
		cQuery += " WHERE "
		cQuery += "PF_FILIAL = ? "
		cQuery += " AND "
		cQuery += "PF_MAT = ? "
		cQuery += " AND "
		cQuery += "PF_DATA >= ? "
		cQuery += " AND "
		cQuery += "PF_DATA <= ? "
		cQuery += " AND "
		cQuery += "PF_TURNODE <> ' ' "
		cQuery += " AND "
		cQuery += "PF_TURNOPA <> ' ' "
		cQuery += " AND "
		cQuery += "D_E_L_E_T_ = ' ' "
		cQuery += "ORDER BY " + SqlOrder( (cAlias)->( IndexKey() ) )
		
		cQuery := ChangeQuery( cQuery )
		
		__oSt4:SetQuery(cQuery)
		
	EndIf
	
	__oSt4:SetString(1,cFil)
	__oSt4:SetString(2,cMat)
	__oSt4:SetString(3,cIniData)
	__oSt4:SetString(4,cFimData)
	
	cQuery := __oSt4:getFixQuery()
	
	dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasQuery)
	
	For nX := 1 To nSpfFields
		If !( aSpfFields[ nX , 02 ] == "C" )
			TcSetField(cAliasQuery,aSpfFields[nX,01],aSpfFields[nX,02],aSpfFields[nX,03],aSpfFields[nX,04])
		EndIf
	Next nX
	
	While ( cAliasQuery )->( !Eof() )
		
		( cAliasQuery )->( aAdd(	aSPF , {	PF_TURNODE									,;	//01 - Turno De
												PF_TURNOPA									,;	//02 - Turno Para
												PF_DATA										,;	//03 - Data
												PF_SEQUEDE									,;	//04 - Sequencia De
												PF_SEQUEPA									,;	//05 - Sequencia Para
												IF(!Empty(PF_REGRADE),PF_REGRADE,cRegra)	,;	//06 - Regra De
												IF(!Empty(PF_REGRAPA),PF_REGRAPA,cRegra)	 ;	//07 - Regra Para
			      		   					};
		    					);
			  			 )
		( cAliasQuery )->( dbSkip() )
	End While
	
	( cAliasQuery )->( dbCloseArea() )
	RestArea( aSvAlias )
	
EndIf

IF ( Len(aSPF) > 0 )
	aSort( @aSPF , NIL , NIL , { |x,y| ( x[3] < y[3] ) } )
	nFornX := ( dPerFim - dPerIni )
	For nX := 0 To nFornX
		dData := dPerIni + nX
		nFornY := Len(aSPF)
		For nY := 1 To nFornY
			IF aSPF[nY,3] >= dData .And. nY < Len(aSPF) .And. dData <= aSPF[nY+1,3] .Or. ;
				aSPF[nY,3] >= dData .And. nY == Len(aSPF)
				//-- Inclui o 1o. "TURNO DE" como 1o. do periodo
				//-- qdo nao houver troca no primeiro dia do periodo
				IF Len(aTurnos)==0 .And. aSPF[nY,3] # dPerIni .and. lAddTrcIniPer
					aAdd(aTurnos, {	aSPF[nY, 1],;								//01 - Turno De
									dPerIni,;									//02 - Data
									IF(Empty(aSPF[nY,4]),cSeqTurn,aSPF[nY,4]),;	//03 - Sequencia De
									0,;											//04 - Numero Serial
									IF(Empty(aSPF[nY,6]),cRegra,aSPF[nY,6]);	//05 - Regra De
							      };
						 )
				EndIF
				//-- Inclui os "TURNO PARA" do periodo
				IF aScan(aTurnos, {|x| x[1] == aSPf[nY,2] .And. x[2] == aSPF[nY,3]}) == 0
					aAdd(aTurnos, {	aSPF[nY, 2],;								//01 - Turno Para
									aSPF[nY, 3],;								//02 - Data
									IF(Empty(aSPF[nY,5]),cSeqTurn,aSPF[nY,5]),;	//03 - Sequencia Para
									0,;											//04 - Numero Serial
									IF(Empty(aSPF[nY,7]),cRegra,aSPF[nY,7]);	//05 - Regra Para
								  };
						 )
				EndIF
				Exit
			EndIF
		Next nY
	Next nX
EndIF

IF !( lTrocaTno := !Empty( aTurnos ) )
	DEFAULT cSeq := cSeqTurn
	If lAddTrcIniPer .Or. lInterm
		aAdd( aTurnos , { cTurno , dPerIni , cSeq , 0 , cRegra } )
	EndIF	
EndIF

If lInterm
	fAddCovTrcTno(dPerIni, dPerFim, @aTurnos, @lTrocaTno)
EndIf

Return( lTrocaTno )

/*/{Protheus.doc} fAddCovTrcTno
Adicionam os turnos das convocações no array de trocas de turno para funcionários intermitentes
@type static function
@author Cí­cero Alves
@since 20/02/2025
@param dPerIni, date, Data inicial do período
@param dPerFim, date, Data final do período
@param aTurnos, array, Array com as trocas de turno - Passado por referência
@param lTrocaTno, logical, indica se houve troca de turno no período - Passado por referência
@return nil, nil
/*/
Static Function fAddCovTrcTno(dPerIni, dPerFim, aTurnos, lTrocaTno)
	
	Local nI, nJ 		:= 1
	Local lInclui		:= .T.
	Local aConvoc 		:= BuscaConv(dPerIni, dPerFim, .T.)
	
	If Len(aTurnos) > 1
		aSort(aTurnos,,, {|x, y| x[2] > y[2]})
	EndIf
	
	For nI := 1 To Len(aConvoc)
		If Len(aConvoc[nI]) > 12 .And. (!Empty(aConvoc[nI][13]) .Or. !Empty(aConvoc[nI][14]) .Or. !Empty(aConvoc[nI][15]))
			
			nJ := 1
			lInclui := .T.
			While nJ <= Len(aTurnos)
				If aTurnos[nJ][2] <= aConvoc[nI][3]
					
					If lInclui
						If aTurnos[nJ][2] == aConvoc[nI][3]
							aTurnos[nJ][2] := aConvoc[nI][3] + 1
						Else
							aAdd(aTurnos, aClone(aTurnos[nJ]))
							aTail(aTurnos)[2] := aConvoc[nI][3] + 1
						EndIf
						lInclui := .F.
					EndIf
					
					If aTurnos[nJ][2] <= aConvoc[nI][2]
						
						aAdd(aTurnos, aClone(aTurnos[nJ]))
						
						aTail(aTurnos)[1] := If(!Empty(aConvoc[nI][13]), aConvoc[nI][13], aTurnos[nJ][1])
						aTail(aTurnos)[2] := aConvoc[nI][2]
						aTail(aTurnos)[3] := If(!Empty(aConvoc[nI][14]), aConvoc[nI][14], aTurnos[nJ][3])
						aTail(aTurnos)[5] := If(!Empty(aConvoc[nI][15]), aConvoc[nI][15], aTurnos[nJ][5])
						
						If aTurnos[nJ][2] == aConvoc[nI][2]
							aDel(aTurnos, nJ)
							aSize(aTurnos, Len(aTurnos)-1)
						EndIf
						
						EXIT
						
					ElseIf aTurnos[nJ][2] < aConvoc[nI][3]
						aTurnos[nJ][1] := If(!Empty(aConvoc[nI][13]), aConvoc[nI][13], aTurnos[nJ][1])
						aTurnos[nJ][3] := If(!Empty(aConvoc[nI][14]), aConvoc[nI][14], aTurnos[nJ][3])
						aTurnos[nJ][5] := If(!Empty(aConvoc[nI][15]), aConvoc[nI][15], aTurnos[nJ][5])
					EndIf
				EndIf
				
				nJ++
				
			EndDo
			
			aSort(aTurnos,,, {|x, y| x[2] > y[2]})
			
		EndIf
	Next nI
	
	aSort(aTurnos, ,, {|x, y| x[2] < y[2]})
	
	lTrocaTno := !Empty(aTurnos)
	
Return

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³fDepuraSP2³ Autor ³ Fernando Joly Siquini ³ Data ³ 27.08.98 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Filtra SP2 deixando somente excecoes do Per¡odo            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ fDepuraSP2(cArqInd, dPerIni, dPerFim)                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ cArqInd = Nome do Arquivo de Indice (passar com "@")       ³±±
±±³          ³ dPerIni = Inicio do Periodo de Depura‡„o                   ³±±
±±³          ³ dPerFim = Final do Periodo de Depura‡„o                    ³±±
±±³          ³ lShowDialog = Mostrar Dialogo na IndRegua                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Function fDepuraSP2( cArqInd , dPerIni , dPerFim , lShowDialog )

Local cChave		:= "P2_FILIAL+P2_MAT+P2_CC+P2_TURNO+DtoS(P2_DATA)+P2_TIPODIA"
Local cPerIni		:= ""
Local cPerFim		:= ""
Local cQuery		:= ""

DEFAULT cArqInd		:= ""
DEFAULT dPerIni		:= dDataBase
DEFAULT dPerFim		:= dDataBase
DEFAULT lShowDialog := .T.

IF !Empty( cArqInd )
	RetIndex( "SP2" )
	SP2->( dbSetOrder( RetOrdem( "SP2" , cChave ) ) )
	fErase( cArqInd + OrdBagExt() )
	cArqInd := ""
EndIF

cPerIni	:= Dtos( dPerIni )
cPerFim := Dtos( dPerFim )

cArqInd	:= CriaTrab("",.F.)
cQuery  += '(((DtoS(P2_DATAATE)>="'+cPerIni+'".AND.DtoS(P2_DATAATE)<="'+cPerFim+'").OR.'
cQuery  += '(DtoS(P2_DATAATE)>="'+cPerFim+'".AND.DtoS(P2_DATA)<="'+cPerIni+'")).OR.'
cQuery  += '(DtoS(P2_DATA)>="'+cPerIni+'".AND.DtoS(P2_DATA)<="'+cPerFim+'"))'

IndRegua( "SP2" , cArqInd , cChave ,, cQuery , STR0056 , lShowDialog ) // 'Depurando Excecoes...'

Return( NIL )

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³ fTabSP4  ³ Autor ³ Aldo Marini Junior    ³ Data ³ 15/10/99 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Carrega tabela de Eventos do Tipo de Hora Extra            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Function fTabSP4(aCodAut,cFilP4)
Local cAliasTmp		:= GetNextAlias()

DEFAULT cFilP4 		:= xFilial("SP4")


BeginSql alias cAliasTmp
	SELECT DISTINCT P4_FILIAL,P4_TURNO,P4_CODAUT
	FROM %table:SP4% SP4
	WHERE
	SP4.P4_FILIAL = %exp:cFilP4%
	AND SP4.%NotDel%
EndSql

While !(cAliasTmp)->(Eof())
	aAdd( aCodAut , {(cAliasTmp)->P4_FILIAL,(cAliasTmp)->P4_TURNO,(cAliasTmp)->P4_CODAUT,"A"} )
	(cAliasTmp)->(Dbskip())
End
(cAliasTmp)->(DbCloseArea())

cAliasTmp		:= GetNextAlias()
BeginSql alias cAliasTmp
	SELECT DISTINCT P4_FILIAL,P4_TURNO,P4_CODNAUT
	FROM %table:SP4% SP4
	WHERE
	SP4.P4_FILIAL = %exp:cFilP4%
	AND SP4.%NotDel%
EndSql

While !(cAliasTmp)->(Eof())
	aAdd( aCodAut , {(cAliasTmp)->P4_FILIAL,(cAliasTmp)->P4_TURNO,(cAliasTmp)->P4_CODNAUT,"N"} )
	(cAliasTmp)->(Dbskip())
End
(cAliasTmp)->(DbCloseArea())


aCodAut := aSort( aCodAut , NIL , NIL , { |x,y| x[2]+x[3] > y[2]+y[3] } )

Return( NIL )

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³fBscEven  ³ Autor ³ Aldo Marini Junior    ³ Data ³ 28.12.98 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Retorna % ou Efetua validacao do Evento                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ fBscEven(cEvento,nTipo,nTpEvento)                          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ cEvento  = Codigo do Evento a ser pesquisado               ³±±
±±³          ³ nTipo    = 1-Percentual Evento 2-Validacao do Evento       ³±±
±±³          ³ nTpEvento= 1-Autorizado 2-Nao Autorizado 3-Ambos           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±*/
Function fBscEven( cEvento , nTipo , nTpEvento )

Local nPerc		:= 100
Local cCodFol	:= ""
Local lRet		:= .T.

IF nTipo == 1
	IF ( nPerc := PosSP9(cEvento,SRA->RA_FILIAL,"P9_BHPERC") ) <= 0
		nPerc := 100
	EndIF
Else
	//-- Ponto de entrada para processo diferente na verificao da autorizacao do evento.
	If lPnmAutEven
		lRet := ExecBlock("PNMAUTEVEN", .F., .F., {cEvento, nTpEvento} )
	Else
		cCodFol := PosSP9(cEvento,SRA->RA_FILIAL,"P9_CODFOL")
		IF ( Empty(cCodFol) .and. nTpEvento == 1 ) .or. ( !Empty(cCodFol) .and. nTpEvento == 2 )
			lRet := .F.
		EndIF
	EndIf
EndIF

Return( IF( nTipo == 1 , nPerc ,  lRet ) )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³fValidMarc	³ Autor ³Equipe Advanced RH    ³ Data ³11/07/2001³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Validar a multipla escolha do tipo de marcacao 1E/1S ..		 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³fValidMarc( l1Elem , cTipo )								 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³                                                     		 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³.T.                                                  	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Apontamento                                                  ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function fValidMarc( l1Elem , cTipo )

Local aMarc		:= {}
Local aStruct	:= SPJ->( dbStruct() )
Local bSort		:= { || NIL }
Local cMarc		:= ""
Local cTitulo	:= ""
Local cMvParDef	:= ""
Local cMvPar	:= &( Alltrim( ReadVar() ) )
Local nX		:= 0
Local nCampos	:= Len( aStruct )

Private uMvRet	:= Alltrim( ReadVar() )

l1Elem			:= IF( l1Elem == NIL .and. ValType( l1Elem ) != "L" , .F. , .T. )

bSort := { |x,y| ( SubStr( x[1] , 9 , 1 ) + SubStr( x[1] , 4 , 1 ) );
				 <;
				 ( SubStr( y[1] , 9 , 1 ) + SubStr( y[1] , 4 , 1 ) );
		 }

CursorWait()

	aSort( @aStruct , NIL , NIL , bSort )
	
	IF ( cTipo != "I" )
		For nX := 1 To nCampos
			cCampo := Upper( AllTrim( aStruct[ nX , 01 ] ) )
			IF Subs(cCampo,1,8) $ "PJ_ENTRA_PJ_SAIDA"
				cMarc := SubStr( cCampo , 9 , 1 ) + SubStr( cCampo , 4 , 1 )
				cMvParDef += ( cMarc + "-" )
				aAdd( aMarc , cMarc += ( "-" + GetDescMarc( cMarc  ) ) )
			EndIF
		Next nX
	Else
		aAdd( aMarc , "I1-" + GetDescMarc( "I1" ) )
		aAdd( aMarc , "I2-" + GetDescMarc( "I2" ) )
		aAdd( aMarc , "I3-" + GetDescMarc( "I3" ) )
		cMvParDef := "I1-I2-I3-"
	EndIF

CursorArrow()
	
IF ( cMvPar != NIL )
	IF f_Opcoes(@cMvPar,cTitulo,aMarc,cMvParDef,12,49,l1Elem,3,Len(aMarc))
		&(uMvRet) := cMvPar
	EndIF	
EndIF	

Return( .T. )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o	   ³fTolerancia³ Autor ³Equipe Advanced RH    ³ Data ³22/03/2001³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³ Extrai a tolerancia da regra de apontamento.               ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³ fTolerancia(cString, nMarc)								³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³ cString - String contendo as tolerancias separadas por '-' ³
³          ³ nMarc   - Numero sequencial da marcacao referente a tol. 	³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso	   ³ Generico 													³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function fTolerancia( cString , nMarc , nTpTol , dData )

Local nTolera := 0				//-- Retorno da tolerancia
Local nY      := 0				//-- Contador da quantidade de tolerancias
Local nPos    := 1				//-- Posicao para extracao de cString
Local nLenStr := 0             	//-- Tamanho da String
Default nTpTol:= 0
Default dData := Ctod("//")

If lAltTol
	IF ( ValType( cRet := ExecBlock( "PNMTOLALT", .F. , .F. , {dData, nTpTol, cString} ) ) == "C" )
		cString := cRet
	EndIf   
EndIf
nLenStr :=  Len(cString)

While ( nPos <= nLenStr )
	nY++
	IF ( nY > nMarc )
		Exit
	ElseIF ( nY == nMarc )
		nTolera := __Min2Hrs( Val( Subs( cString , nPos , 2 ) ) )
		Exit
	EndIF
	nPos += 3
End While

Return( nTolera )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Funcao	   ³fAbonos   ³Autor³Equipe Advanced RH Ver. I³ Data ³04/04/2001³
³          ³          ³     ³Marinaldo de Jesus Ver.II³ Data ³27/04/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descricao ³Verifica a existencia de abonos.                            ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso	   ³Generico 												  	³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function fAbonos(	dData		,;	//Data do Abono
					cPD			,;	//Evento do Abono
					nHora		,;	//Hora Inicial do Abono
					aAbonos		,;	//Array onde serao carregados os Abonos
					cTpMarca	,;	//Tipo de Marcacao
					cCC			,;	//Centro de Custo
					aAbonosPer	,;	//Array com Todos os Abonos do Periodo   
					lDeletados	;   //Se considera Deletados pre-informados  para uso em Memoria
				)

Local lPassTpMarca		:= !( cTpMarca == NIL )
Local lPassCC			:= !( cCC == NIL )
Local nHrsAbo			:= 0

Local aTamSx3
Local bEval
Local bFiltro
Local cFilSPK
Local cCond_01
Local cCond_02
Local cbCond
Local lAbonosPer
Local nLenAbo
Local nSvOrder
Local nOrder

DEFAULT cTpMarca		:= Space( GetSx3Cache( "PK_TPMARCA" , "X3_TAMANHO" ) )         
DEFAULT lDeletados		:= .F.

IF ( Type( "lMemoria" ) <> "L" )
	Private lMemoria := .F.
EndIF

aAbonos	 := {}

IF !( lMemoria )

	lAbonosPer := ( ValType( aAbonosPer ) == "A" )

	IF !( lAbonosPer )

		aTamSx3		:= TamSx3( "PK_HORINI" )
		bEval		:= { |e1 , e2 | e1 == &(e2) }
		cFilSPK		:= SRA->RA_FILIAL
		nSvOrder	:= SPK->( IndexOrd() )
		nOrder		:= RetOrdem( "SPK" , "PK_FILIAL+PK_MAT+DTOS(PK_DATA)+PK_CODEVE+STR(PK_HORINI,"+AllTrim(Str(aTamSx3[1]))+","+AllTrim(Str(aTamSx3[2]))+")+PK_CC" )

		IF ( lPassTpMarca )
		   cbCond	:=	"SPK->PK_TPMARCA $ cTpMarca"
		EndIF
		IF ( lPassCC )
		   cbCond	:= IF( !Empty( cbCond ) , cbCond + " .and. " , "" ) + "SPK->PK_CC==cCC"
		EndIF
		IF Empty( cbCond )
		   cbCond	:=	".T."
		EndIF
		bFiltro  := &( "{ ||" + cbCond + " }" )
		IF ( ( nHora == NIL ) .and. ( cPD # NIL ) )
			cCond_01	:= ( cFilSPK +  SRA->RA_MAT + Dtos( dData ) + cPD )
			cCond_02	:= "PK_FILIAL+PK_MAT+Dtos(PK_DATA)+PK_CODEVE"
		ElseIF ( nHora == NIL .and. cPD == NIL )
			cCond_01	:= ( cFilSPK + SRA->RA_MAT + Dtos( dData ) )
			cCond_02	:= "PK_FILIAL+PK_MAT+Dtos(PK_DATA)"
		Else
			cCond_01	:= ( cFilSPK + SRA->RA_MAT + Dtos(dData) + cPD + Str( nHora , aTamSx3[1] , aTamSx3[2] ) )
			cCond_02	:= "PK_FILIAL+PK_MAT+Dtos(PK_DATA)+PK_CODEVE+Str(PK_HORINI,"+AllTrim(Str(aTamSx3[1]))+","+AllTrim(Str(aTamSx3[2]))+")"
		EndIF

		IF !( nSvOrder == nOrder )
			SPK->( dbSetOrder( nOrder ) )
		EndIF

		IF SPK->( MsSeek( cCond_01 ) )
			While SPK->( !Eof() .and. Eval( bEval , cCond_01 , cCond_02 ) )
		        IF Eval( bFiltro )
					aAdd( aAbonos , Array( ELEMENTOS_AABONOS ) )
					nLenAbo := Len( aAbonos )
					aAbonos[ nLenAbo , AABONOS_CODIGO 		] := SPK->PK_CODABO
					aAbonos[ nLenAbo , AABONOS_HORAS_ABO	] := SPK->PK_HRSABO
					aAbonos[ nLenAbo , AABONOS_HORAS_INI	] := SPK->PK_HORINI
					aAbonos[ nLenAbo , AABONOS_HORAS_FIM	] := SPK->PK_HORFIM
					aAbonos[ nLenAbo , AABONOS_DATA			] := SPK->PK_DATA
					aAbonos[ nLenAbo , AABONOS_CC			] := SPK->PK_CC
					aAbonos[ nLenAbo , AABONOS_TPMARCA		] := SPK->PK_TPMARCA
					aAbonos[ nLenAbo , AABONOS_CODEVE		] := SPK->PK_CODEVE
					aAbonos[ nLenAbo , AABONOS_RECNO		] := SPK->( Recno() )
					aAbonos[ nLenAbo , AABONOS_FLAG			] := SPK->PK_FLAG
				   	nHrsAbo := SomaHoras( nHrsAbo , SPK->PK_HRSABO )
				EndIF
				SPK->( dbSkip() )
			End While
		EndIF
		
		IF !( nSvOrder == nOrder )
			SPK->( dbSetOrder( nSvOrder ) )
		EndIF

	Else

		nHrsAbo := GetAbonosPer( dData , cPD , nHora , @aAbonos , cTpMarca , cCC , aAbonosPer , lPassTpMarca , lPassCC )
			
	EndIF
	
Else

	nHrsAbo := fAbonosMem( dData , cPD , nHora , @aAbonos , cTpMarca , cCC , lPassTpMarca , lPassCC, lDeletados )

EndIF

Return( nHrsAbo )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Funcao	   ³GetAbonosPer³Autor ³Marinaldo de Jesus    ³ Data ³20/01/2003³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descricao ³Carrega aAbonos a Partir do Conteudo de aAbonosPer			³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso	   ³fAbonos()													³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function GetAbonosPer(	dData			,;	//Data do Abono
								cPD				,;	//Evento do Abono
								nHora			,;	//Hora Inicial do Abono
								aAbonos			,;	//Array onde serao carregados os Abonos
								cTpMarca		,;	//Tipo de Marcacao
								cCC				,;	//Centro de Custo
								aAbonosPer		,;	//Array com Todos os Abonos do Periodo
								lPassTpMarca	,;	//Se passou o Tipo da Marcacao em fAbonos
								lPassCC			 ;	//Se passou o Centro de Custo em fAbonos
							)
                
Local aTamSx3	:= TamSx3( "PK_HORINI" )
Local nHrsAbo	:= 0

Local bEval
Local bFiltro
Local bCond_01
Local bCond_02
Local cbCond
Local nLenAbo
Local nAbonosPer
Local nPosAbono

aAbonos	 := {}

IF ( lPassTpMarca )
   cbCond	:=	"aAbonosPer[ nPosAbono ," + AllTrim( Str( AABONOS_TPMARCA ) ) + "] $ cTpMarca"
EndIF
IF ( lPassCC )
   cbCond := IF( !Empty( cbCond ) , cbCond + " .and. " , "" ) + "aAbonosPer[ nPosAbono ," + Str( AABONOS_CC ) + "] == cCC"
EndIF
IF Empty( cbCond )
   cbCond	:= ".T."
EndIF
bFiltro		:= &( "{ || " + cbCond + " } " )
IF ( ( nHora == NIL ) .and. ( cPD # NIL ) )
	bCond_01	:= { || Dtos( dData ) + cPD }
	bCond_02	:= { || Dtos( aAbonosPer[ nPosAbono , AABONOS_DATA ] ) + aAbonosPer[ nPosAbono , AABONOS_CODEVE ] }
ElseIF ( ( nHora == NIL ) .and. ( cPD == NIL ) )
	bCond_01	:= { || Dtos( dData ) }
	bCond_02	:= { || Dtos( aAbonosPer[ nPosAbono , AABONOS_DATA ] ) }
Else
	bCond_01	:= { || Dtos( dData ) + cPD + Str( nHora , aTamSx3[1] , aTamSx3[2] ) }
	bCond_02	:= { || Dtos( aAbonosPer[ nPosAbono , AABONOS_DATA ] ) + aAbonosPer[ nPosAbono , AABONOS_CODEVE ] + Str( aAbonosPer[ nPosAbono , AABONOS_HORAS_INI ] , aTamSx3[1] , aTamSx3[2] ) }
EndIF

nAbonosPer	:= Len( aAbonosPer )
IF ( ( nPosAbono := aScan( aAbonosPer , { |x| x[ AABONOS_DATA ] == dData } ) ) > 0 )
	bEval := { | b1 , b2 | Eval( b1 ) == Eval( b2 ) }
	For nPosAbono := nPosAbono To nAbonosPer
		IF ( !Eval( bEval , bCond_01 , bCond_02 ) .or. !Eval( bFiltro ) )
			Loop
		EndIF
		aAdd( aAbonos , Array( ELEMENTOS_AABONOS ) )
		nLenAbo := Len( aAbonos )
		aAbonos[ nLenAbo , AABONOS_CODIGO 		] := aAbonosPer[ nPosAbono , AABONOS_CODIGO 	]
		aAbonos[ nLenAbo , AABONOS_HORAS_ABO	] := aAbonosPer[ nPosAbono , AABONOS_HORAS_ABO	]
		aAbonos[ nLenAbo , AABONOS_HORAS_INI	] := aAbonosPer[ nPosAbono , AABONOS_HORAS_INI	]
		aAbonos[ nLenAbo , AABONOS_HORAS_FIM	] := aAbonosPer[ nPosAbono , AABONOS_HORAS_FIM	]
		aAbonos[ nLenAbo , AABONOS_DATA			] := aAbonosPer[ nPosAbono , AABONOS_DATA		]
		aAbonos[ nLenAbo , AABONOS_CC			] := aAbonosPer[ nPosAbono , AABONOS_CC			]
		aAbonos[ nLenAbo , AABONOS_TPMARCA		] := aAbonosPer[ nPosAbono , AABONOS_TPMARCA	]
		aAbonos[ nLenAbo , AABONOS_CODEVE		] := aAbonosPer[ nPosAbono , AABONOS_CODEVE		]
		aAbonos[ nLenAbo , AABONOS_RECNO		] := aAbonosPer[ nPosAbono , AABONOS_RECNO		]
		aAbonos[ nLenAbo , AABONOS_FLAG			] := aAbonosPer[ nPosAbono , AABONOS_FLAG		]
		nHrsAbo := SomaHoras( nHrsAbo , aAbonosPer[ nPosAbono , AABONOS_HORAS_ABO	] )
	Next nPosAbono
EndIF

Return( nHrsAbo )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Funcao	   ³fAbonosMem³Autor³Mauricio MR        Ver. I³ Data ³04/04/2001³
³          ³          ³     ³Marinaldo de Jesus Ver.II³ Data ³27/04/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descricao ³Verifica a existencia de abonos (Trabalha com a Memoria)	³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso	   ³fAbonos()													³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function fAbonosMem(	dData			,;	//Data do Abono
							cPD				,;	//Evento do Abono
							nHora			,;	//Hora Inicial do Abono
							aAbonos			,;	//Array onde serao carregados os Abonos
							cTpMarca		,;	//Tipo de Marcacao
							cCC				,;	//Centro de Custo
							lPassTpMarca	,;	//Se passou o Tipo da Marcacao em fAbonos
							lPassCC			, ;	//Se passou o Centro de Custo em fAbonos   
							lDeletados		;   //Se considera Deletados pre-informados
						   )								

Local nHrsAbo	:= 0

Local aAboCols
Local aTamSx3
Local bFiltro
Local cCond_01
Local cCond_02
Local cbCond
Local nLenAbo
Local nX
Local nLenX
Local nPkCodAbo
Local nPkHorIni
Local nPkHorFim
Local nPkHrsAbo
Local nPkCodEve
Local nPkTpMarca
Local nPkCc
Local nPkFlag

DEFAULT lDeletados	:= .F.

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Se Existir a Variavel bAboCols ( e for um bloco )   utilizada³
³ para a Montagem do aAboCols, Executa						   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
IF ( Type( "bAboCols" ) == "B" )

	aTamSx3		:= TamSx3( "PK_HORINI" )
	nPkData		:= GdFieldPos( "PK_DATA"    , aAboHeader )
	nPkCodAbo	:= GdFieldPos( "PK_CODABO" 	, aAboHeader )
	nPkHorIni	:= GdFieldPos( "PK_HORINI" 	, aAboHeader )
	nPkHorFim	:= GdFieldPos( "PK_HORFIM" 	, aAboHeader )
	nPkHrsAbo	:= GdFieldPos( "PK_HRSABO" 	, aAboHeader )
	nPkCodEve	:= GdFieldPos( "PK_CODEVE" 	, aAboHeader ) 
	nPkTpMarca	:= GdFieldPos( "PK_TPMARCA"	, aAboHeader )            
	nPkCc 		:= GdFieldPos( "PK_CC"		, aAboHeader ) 
	nPkFlag		:= GdFieldPos( "PK_FLAG"	, aAboHeader ) 

	aAboCols	:= Eval( bAboCols )

	IF ( lPassTpMarca )
	   cbCond := 'aAboCols[nX, nPkTpMarca]$cTpMarca'
	EndIF
	IF ( lPassCC )
	   cbCond := IF( !Empty(cbCond) , cbCond + ' .and. ','') + 'aAboCols[nX, nPkCc]==cCC'
	EndIF
	IF Empty(cbCond)
	   cbCond := '.T.'
	EndIF

	bFiltro  := &("{||"+cbCond+" }") 
	
	IF ( ( nHora == NIL ) .and. ( cPD # NIL ) )
		cCond_01	:= ( Dtos( dData ) + cPD )
		cCond_02	:= { |nElem| Dtos( aAboCols[ nElem , nPkData ] ) + aAboCols[ nElem , nPkCodEve ] }
	ElseIF ( ( nHora == NIL ) .and. ( cPD == NIL ) )
		cCond_01	:= ( Dtos( dData ) )
		cCond_02	:= { |nElem| Dtos( aAboCols[ nElem , nPkData ] ) }
	Else
		cCond_01	:= ( Dtos(dData) + cPD + Str( nHora , aTamSx3[1] , aTamSx3[2] ) )
		cCond_02	:= { |nElem| Dtos( aAboCols[ nElem, nPkData ] ) + aAboCols[ nElem , nPkCodEve ] + Str( aAboCols[ nElem , nPkHorIni ] , aTamSx3[1] , aTamSx3[2] ) }
	EndIF
	               
	nLenX := Len( aAboCols )
	For nX := 1 To nLenX
		IF ( cCond_01 == Eval( cCond_02 , nX ) )
			IF Eval( bFiltro )
				IF !Empty(aAboCols[nX, nPkCodAbo]) .AND. ( IF( lDeletados, .T., !aAboCols[ nX, Len( aAboCols[nX] ) ]) )
					aAdd( aAbonos , Array( ELEMENTOS_AABONOS ) )
					nLenAbo := Len( aAbonos )
					aAbonos[ nLenAbo , AABONOS_CODIGO 		] := aAboCols[ nX , nPkCodAbo 	]
					aAbonos[ nLenAbo , AABONOS_HORAS_ABO	] := aAboCols[ nX , nPkHrsAbo 	]
					aAbonos[ nLenAbo , AABONOS_HORAS_INI	] := aAboCols[ nX , nPkHorIni 	]
					aAbonos[ nLenAbo , AABONOS_HORAS_FIM	] := aAboCols[ nX , nPkHorFim 	]
					aAbonos[ nLenAbo , AABONOS_DATA			] := aAboCols[ nX , nPkData 	]
					aAbonos[ nLenAbo , AABONOS_CC			] := aAboCols[ nX , nPkCc	 	]
					aAbonos[ nLenAbo , AABONOS_TPMARCA		] := aAboCols[ nX , nPkTpMarca	]
					aAbonos[ nLenAbo , AABONOS_CODEVE		] := aAboCols[ nX , nPkCodEve	]
					aAbonos[ nLenAbo , AABONOS_RECNO		] := nX
					aAbonos[ nLenAbo , AABONOS_FLAG			] := aAboCols[ nX , nPkFlag		]
				EndIF
				IF !Empty( aAboCols[ nX , nPkCodAbo ] ).AND. (IF( lDeletados, .T., !aAboCols[ nX, Len( aAboCols[nX] ) ]) )
					nHrsAbo := SomaHoras( nHrsAbo , aAboCols[ nX , nPkHrsAbo ] )
				EndIF
			EndIF
		EndIF
	Next nX

EndIF
	
Return( nHrsAbo )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Funcao	   ³fAbonosPer ³ Autor ³Marinaldo de Jesus    ³ Data ³20/01/2003³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descricao ³Carrega no Array aAbonos    Todos os Abonos do Periodo		³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso	   ³Generico 												  	³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function fAbonosPer( aAbonos , dPerIni , dPerFim , cFil , cMat )

Local aTamSx3		:= TamSx3( "PK_HORINI" )
Local cAlias		:= "SPK"
Local cAliasQuery	:= cAlias
Local nOrder		:= RetOrdem( "SPK" , "PK_FILIAL+PK_MAT+DTOS(PK_DATA)+PK_CODEVE+STR(PK_HORINI,"+AllTrim(Str(aTamSx3[1]))+","+AllTrim(Str(aTamSx3[2]))+")+PK_CC" )
Local nOrdSPK		:= ( cAlias )->( IndexOrd() )

Local cFilMat
Local lExistAbo
Local nLenAbo

Local aOldAlias			:= GetArea()
Local cIniData	 		:= ""
Local cFimData			:= ""
Local cQuery	 		:= ""
Local nX				:= 0

Static aSpkFields
Static cQrySpkFields
Static nSpkFields
Static __oSt5
Static __cEmpAux5

DEFAULT aSpkFields := ( cAlias )->( dbStruct() )
DEFAULT nSpkFields := Len( aSpkFields )

If ( cQrySpkFields == NIL )
	cQrySpkFields := ""	
	For nX := 1 To nSpkFields
		cQrySpkFields += aSpkFields[ nX , 01 ] + ", "
	Next nX
EndIf

aAbonos := {}

DEFAULT dPerIni := Ctod("//")
DEFAULT dPerFim := Ctod("//")
DEFAULT cFil	:= SRA->RA_FILIAL
DEFAULT cMat	:= SRA->RA_MAT

If !( nOrdSPK == nOrder )
	( cAliasQuery )->( dbSetOrder( nOrder ) )
EndIf

cFilMat := ( cFil + cMat )

cIniData	:= Dtos( dPerIni )
cFimData	:= Dtos( dPerFim )

cAliasQuery := ( "__Q" + cAliasQuery + "QRY" )

If __oSt5 == Nil .or. ( __cEmpAux5 == Nil .or. __cEmpAux5 <> cEmpAnt )

	__cEmpAux5   := cEmpAnt

	__oSt5 := FWPreparedStatement():New()

	cQuery := "SELECT "
	cQuery += cQrySpkFields
	cQuery += "R_E_C_N_O_ RECNO "
	cQuery += " FROM "
	cQuery += InitSqlName( cAlias )
	cQuery += " WHERE "
	cQuery += "PK_FILIAL = ? "
	cQuery += " AND "
	cQuery += "PK_MAT = ? "
	cQuery += " AND "
	cQuery += "PK_DATA >= ? "
	cQuery += " AND "
	cQuery += "PK_DATA <= ? "
	cQuery += " AND "
	cQuery += "D_E_L_E_T_ = ' ' "
	cQuery += "ORDER BY " + SqlOrder( (cAlias)->( IndexKey() ) )

	cQuery := ChangeQuery( cQuery )

	__oSt5:SetQuery(cQuery)
EndIf

__oSt5:SetString(1,cFil)
__oSt5:SetString(2,cMat)
__oSt5:SetString(3,cIniData)
__oSt5:SetString(4,cFimData)

cQuery := __oSt5:getFixQuery()

dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasQuery)

For nX := 1 To nSpkFields
	IF !( aSpkFields[ nX , 02 ] == "C" )
		TcSetField(cAliasQuery,aSpkFields[nX,01],aSpkFields[nX,02],aSpkFields[nX,03],aSpkFields[nX,04])
	EndIF
Next nX
				
While ( cAliasQuery )->( !Eof() )

	aAdd( aAbonos , Array( ELEMENTOS_AABONOS ) )
	nLenAbo := Len( aAbonos )
	aAbonos[ nLenAbo , AABONOS_CODIGO 		] := ( cAliasQuery )->( PK_CODABO	)
	aAbonos[ nLenAbo , AABONOS_HORAS_ABO	] := ( cAliasQuery )->( PK_HRSABO	)
	aAbonos[ nLenAbo , AABONOS_HORAS_INI	] := ( cAliasQuery )->( PK_HORINI	)
	aAbonos[ nLenAbo , AABONOS_HORAS_FIM	] := ( cAliasQuery )->( PK_HORFIM	)
	aAbonos[ nLenAbo , AABONOS_DATA			] := ( cAliasQuery )->( PK_DATA		)
	aAbonos[ nLenAbo , AABONOS_CC			] := ( cAliasQuery )->( PK_CC		)
	aAbonos[ nLenAbo , AABONOS_TPMARCA		] := ( cAliasQuery )->( PK_TPMARCA	)
	aAbonos[ nLenAbo , AABONOS_CODEVE		] := ( cAliasQuery )->( PK_CODEVE	)
	aAbonos[ nLenAbo , AABONOS_RECNO		] := ( cAliasQuery )->( RECNO 	)
	aAbonos[ nLenAbo , AABONOS_FLAG			] := ( cAliasQuery )->( PK_FLAG		)
	( cAliasQuery )->(  dbSkip() )
End While

( cAliasQuery )->( dbCloseArea() )
RestArea( aOldAlias )

lExistAbo := ( Len( aAbonos ) > 0 )

If !( nOrdSPK == nOrder )
	SPK->( dbSetOrder( nOrdSPK ) )
EndIf

Return( lExistAbo )

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³ RetSeq   ³ Autor ³ Alexsandro Pereira    ³ Data ³ 25/08/00 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Retorna a sequencia inicial do turno de um periodo qualquer³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ RetSeq(cSeqAtual,cTurno,dPerIni,dPerFim,dData,aTabPadrao)  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ cSeqAtual  - Sequencia do periodo atual                    ³±±
±±³          ³ cTurno     - Turno de trabalho atual                       ³±±
±±³          ³ dPerIni    - Data inicio do periodo a se calcular sequencia³±±
±±³          ³ dPerFim    - Data fim do periodo a se calcular sequencia   ³±±
±±³          ³ dData      - Data referente ao periodo para calculo sequenc³±±
±±³          ³ aTabPadrao - Tabela de horario padrao                      ³±±
±±³          ³ cSeqAnt    - Sequencia anterior calculada (retornado p/fun)³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Gen‚rico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±*/
Function RetSeq(cSeqAtual,cTurno,dPerIni,dPerFim,dData,aTabPadrao,cSeqAnt,cFil)

//-- Calcula a sequencia inicial do periodo retroativo
//-- funcao chamada quando nao houver troca de turno.
Local dPerAntIni := Ctod('  /  /  ')	//-- Data inicial do periodo anterior
Local dPerAntFim := Ctod('  /  /  ')	//-- Data final do periodo anterior
Local dDataSeg   := Ctod('  /  /  ')	//-- Data da ultima segunda-feira
Local nSemanas   := 0					//-- Numero de semanas
Local nQtdSeq    := 0					//-- Quantidade de sequencias da tabela de horario padrao
Local nPosTab    := 0					//-- Posicao do turno na tabela de horario padrao
Local cFilSPF    := SRA->RA_FILIAL		//-- Codigo da filial do arquivo SPF

DEFAULT cFil := cFilAnt

//-- Quando a sequencia nao for informada, assume-se "01"
cSeqAtual := If(cSeqAtual==Nil .Or. Val(cSeqAtual)=0,'01',cSeqAtual)

//-- Obtem o total de sequencias da tabela
If (nPosTab := aScan(aTabPadrao, { |x| x[1] == fFilFunc('SPJ') .And. x[2] == cTurno })) > 0
	If Len(aTabPadrao[nPosTab]) >= 3
		If Len(aTabPadrao[nPosTab,3]) > 0
			If Len(aTabPadrao[nPosTab,3,Len(aTabPadrao[nPosTab,3])]) >= 19
				nQtdSeq := Val(aTabPadrao[nPosTab,3,Len(aTabPadrao[nPosTab,3]),19])
			EndIf
		EndIf
	EndIf
Endif

//-- Carrega o periodo de apontamento.
If !PerAponta(@dPerAntIni,@dPerAntFim,dData,NIL,cFil)
	Return .F.
Endif

//-- verifica as trocas de turno a partir do periodo escolhido ate a data atual
If SPF->(dbSeek(cFilSPF+SRA->RA_MAT+DTos(dPerIni),.T.))
	If SPF->PF_FILIAL+SPF->PF_MAT == cFilSPF+SRA->RA_MAT .And. SPF->PF_DATA <= dPerAntIni-1
		//-- Carrega o periodo de apontamento.
		cSeqAtual := SPF->PF_SEQUEDE
		cTurno    := SPF->PF_TURNODE
		//-- Carrega o periodo de apontamento.
		If !PerAponta(@dPerAntIni,@dPerAntFim,SPF->PF_DATA,NIL,cFil)
			Return .F.
		Endif
	Endif
Endif

//-- Se a data fim do antepenultimo periodo nao for na segunda-feira
If Dow(dPerAntIni-1) # 2
	//-- Obtem a data da segunda-feira do antepenultimo periodo.
	dDataSeg := (dPerAntIni-1) - (Dow(dPerAntIni-1) - 2)
	Else
	dDataSeg := dPerAntIni-1
Endif

//-- Calcula o numero de semanas decorridas desde a data inicial do periodo a obter a sequencia.
nSemanas  := If((nSemanas:=(dDataSeg-dPerIni)/7) > Int(nSemanas),Int(nSemanas := nSemanas + 1),nSemanas)
cSeqAnt   := Val(cSeqAtual)-nSemanas
cSeqAnt   := If(cSeqAnt<=1,nQtdSeq + cSeqAnt ,cSeqAnt)
cSeqAnt   := StrZero(ABS(cSeqAnt),2)

Return (cSeqAnt<>cSeqAtual)

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³ fGeraExtra³ Autor ³ Mauro Sergio          ³ Data ³ 07/11/96 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³ Gerar a Verba de Horas Extras                               ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³< Vide Parametros Formais >								   	 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³< Vide Parametros Formais >								   	 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Geracao de Horas Extras                                      ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function fGeraExtra(	aTabExtra	,;//01 -> Array contendo os Tipos de Horas Extras
						cTpExtra	,;//02 -> Tipo de Hora Extra a ser Gerado
						nThoras		,;//03 -> Numero de Horas Extras Autorizadas	
						nTNhoras	,;//04 -> Numero de Horas Extras Nao Autorizadas	
						aResult		,;//05 -> Array com os Resultados do Apontamento do Dia
						aTotais		,;//06 -> Array com os Totais Apontados por Evento do Dia 
						dData		,;//07 -> Data da Gravacao
						cRotina		,;//08 -> Rotina Chamadora da Funcao
						cPeriodo	,;//09 -> Periodo de Apuracao 
						lSoma		,;//10 -> Soma ao Valor Existente
						cCusto		,;//11 -> Centro de Custo Para Gravacao
						cTpMarc		,;//12 -> Tipo de Marcacao
						lMvAcmHExt	,;//13 -> Considerar Todas as Horas Extras do Dia Para o Escalonamento
						lSubstitui	,;//14 -> Se Substitui as Horas Existentes
						cFuncao		,;//15 -> Funcao para gravacao
						cDepto		,;//16 -> Depto para gravacao
						cPosto		,;//17 -> Posto para gravacao  
						cProcesso 	,;//18 -> Processo para Gravacao								
						cRoteiro	,;//19 -> Roteiro para Gravacao
						cPeriodo	,;//20 -> Periodo para Gravacao								
						cNumPagto	,;//21 -> NumPagto para Gravacao	
						cTurno 		,;//19 -> Turno de Trabalho
						cSemana		,;//20 -> Semana/Sequencia do Turno
						aTotDia     ,;//21 -> Totais diarios     
						dDataApo	; //22 -> Data do Apontamento
				  	)

Local aExTipo

Local bEvalSomaA
Local bEvalSomaN

Local cEvento  
Local cTipoHE
Local nPercent
Local lRotFec

Local nResto
Local nHoras 
Local nHorasApo		:= 0  
Local nHorasAux		:= 0
Local nSaldoAnt		:= 0
Local nPos
Local nX
Local nFornX
Local nN 

DEFAULT nThoras		:= 0
DEFAULT nTNhoras	:= 0
DEFAULT aTotDia		:= {} 
DEFAULT dDataApo	:= dData

IF (( nThoras > 0 ) .or. ( nTNhoras > 0 ))

	nHorasApo := If(nThoras == 0, nHorasApo := nTNhoras, nHorasApo := nThoras)
	
	aExTipo := {}
	nResto  := 0
	
	DEFAULT lSoma			:= .F.
	DEFAULT cCusto			:= Space( GetSx3Cache( "PC_CC" 		, "X3_TAMANHO" ) )
	DEFAULT cTpMarc 		:= Space( GetSx3Cache( "PC_TPMARCA"	, "X3_TAMANHO" ) )
	DEFAULT lMvAcmHExt		:= .F.  
	
	//-- Portaria 1.510
	DEFAULT __lCpoTurno		:= ( cPaisLoc == "BRA" ) //campo utilizaod somente no Brasil   
	DEFAULT __lCpoSemana	:= ( cPaisLoc == "BRA" ) //campo utilizaod somente no Brasil   
	DEFAULT __lCpoTipoHE	:= ( cPaisLoc == "BRA" ) //campo utilizaod somente no Brasil   
    
	IF __lCpoTurno .and. __lCpoSemana .and. __lCpoTipoHE .and. __lCpoPercent
		DEFAULT cTurno  	:= Space( GetSx3Cache( "PC_TURNO"		, "X3_TAMANHO" ) )
		DEFAULT cSemana		:= Space( GetSx3Cache( "PC_SEMANA"		, "X3_TAMANHO" ) )	
		DEFAULT cTipoHE		:= Space( GetSx3Cache( "PC_TIPOHE"		, "X3_TAMANHO" ) )	
		DEFAULT nPercent	:= 0
	Else                                                                                
		cTurno  			:= Space( GetSx3Cache( "PJ_TURNO"		, "X3_TAMANHO" ) )
		cSemana				:= Space( GetSx3Cache( "PJ_SEMANA"		, "X3_TAMANHO" ) )	
		cTipoHE				:= Space( GetSx3Cache( "P4_TIPO"		, "X3_TAMANHO" ) )		
		nPercent			:= 0
	Endif
	
	//-- 'APO' para Apontamento e 'FEC' para Fechamento
	cRotina  := IF( Empty( cRotina )  , "APO" , Upper( cRotina  ) )
	cPeriodo := IF( Empty( cPeriodo ) , "D"   , Upper( cPeriodo ) )
	
	lRotFec  := ( cRotina == "FEC" )
	
	Begin Sequence
	
		IF ( lMvAcmHExt )
			ToScheduleOverTime(	aTabExtra		,;	//01 - Array contendo os Tipos de Horas Extras
								cTpExtra		,;	//02 - Tipo de Hora Extra a ser Gerado
								nThoras			,;	//03 - Numero de Horas Extras Autorizadas
								nTNhoras		,;	//04 - Numero de Horas Extras Nao Autorizadas
								aResult			,;	//05 - Array com os Resultados do Apontamento do Dia
								aTotais			,;	//06 - Array com os Totais Apontados por Evento do Dia
								dData			,;	//07 - Data da Gravacao
								cRotina			,;	//08 - Rotina Chamadora da Funcao
								cPeriodo		,;	//09 - Periodo de Apuracao
								lSoma			,;	//10 - Soma ao Valor Existente
								cCusto			,;	//11 - Centro de Custo Para Gravacao
								cTpMarc			,;	//12 - Tipo de Marcacao
								lSubstitui		,;	//13 - Se Substitui as Horas Existentes 
							 	/*cFuncao	*/	,;  //14 - Funcao para Gravacao
								/*cDepto	*/	,;  //15 - Depto para Gravacao
								/*cPosto	*/	,;  //16 - Posto para Gravacao
								/*cProcesso	*/	,;  //17 - Processo para Gravacao																								
								/*cPeriodo	*/	,;  //18 - Periodo para Gravacao
								/*cRoteiro	*/	,;  //19 - Processo para Gravacao								
								/*cNumPagto	*/	,;  //20 - NumPagto para Gravacao
								cTurno 			,;  //21 - Turno de Trabalho
								cSemana			,;  //22 - Semana/Sequencia do Turno 
								aTotDia    		,;	//23 - Totais diarios     
								dDataApo		; 	//24 - Data do Apontamento								
							  )
			Break
	    EndIF
		
		//--Gerar Array do Tipo Desejado
		aExTipo := GetExTipo( aTabExtra , @cTpExtra )
		
		IF ( lSoma )
			IF !( lRotFec )
				bEvalSomaA	:= { |x| IF(;
											(;
												( x[ ARESULT_DATA ] == dData );
												.and.;
												( x[ ARESULT_EVENTO ] == aExTipo[ nX , 4 ] );
												.and.;
												( x[ ARESULT_CC ] == cCusto );
												.and.;
												( x[ ARESULT_TPMARCA ] == cTpMarc );
											),;
											(;
												nThoras := SomaHoras( nThoras , x[ ARESULT_HORAS ] ),;
												x[ ARESULT_HORAS ] := 0;
											),;
											NIL;
										);
								}
				bEvalSomaN	:= { |x| IF(;
											(;
												( x[ ARESULT_DATA ] == dData );
												.and.;
												( x[ ARESULT_EVENTO ] == aExTipo[ nX , 5 ] );
												.and.;
												( x[ ARESULT_CC ] == cCusto );
												.and.;
												( x[ ARESULT_TPMARCA ] == cTpMarc );
											),;
											(;
												nTNhoras := SomaHoras( nTNhoras , x[ ARESULT_HORAS ] ),;
												x[ ARESULT_HORAS ] := 0;
											),;
											NIL;
										);
								}
			Else
				bEvalSomaA	:= { |x| IF(;
											(;
												( x[ ATOTAIS_DATA ] == dData );
												.and.;
												( x[ ATOTAIS_EVENTO_PONTO ] == aExTipo[ nX , 4 ] );
												.and.;
												( x[ ATOTAIS_CENTO_DE_CUSTO ] == cCusto );
											),;
											(;
												nThoras := SomaHoras( nThoras , x[ ATOTAIS_HORAS ] ),;
												x[ ATOTAIS_HORAS ] := 0;
											),;
											NIL;
										);
								}
				bEvalSomaN	:= { |x| IF(;
											(;
												( x[ ATOTAIS_DATA ] == dData );
												.and.;
												( x[ ATOTAIS_EVENTO_PONTO ] == aExTipo[ nX , 5 ] );
												.and.;
												( x[ ATOTAIS_CENTO_DE_CUSTO ] == cCusto );
											),;
											(;
												nTNhoras := SomaHoras( nTNhoras , x[ ATOTAIS_HORAS ] ),;
												x[ ATOTAIS_HORAS ] := 0;
											),;
											NIL;
										);
								}  
				nSaldoAnt	:=SubHoras(nTHoras, nHorasApo)				
			EndIF
			//--Soma Horas Quando Existir mais de uma Geracao para o mesmo dia
			nFornX	:= Len( aExTipo )
			For nX := 1 To nFornX
				IF !Empty( nThoras )
					IF ( lRotFec )
						aEval( aTotais , bEvalSomaA )
					Else
						aEval( aResult , bEvalSomaA )
					EndIF	
				EndIF
				IF !Empty( nTNhoras )
					IF ( lRotFec )
						aEval( aTotais , bEvalSomaN )
					Else
						aEval( aResult , bEvalSomaN )
					EndIF	
				EndIF
			Next nX
		EndIF

		//-- 1o. para Autorizado e 2o. para Nao Autorizada
		For nN := 1 To 2
			nResto := IF( nN == 1 , nThoras , nTNhoras )
			//-- Aplicar a Tabela de Horas Extras		
			While ( nResto > 0 )
				//--Procura a faixa de horas
				nHoras	:= Round(nResto,2)
				IF ( ( nPos := aScan( aExTipo , { |x| nHoras >= x[2] .And. nHoras <= x[3] } ) ) > 0 )
					cEvento := aExTipo[ nPos , IF( nN == 1 , 4 , 5 ) ]
					cTipoHE	:= aExTipo[ nPos , 1 ]
					nPercent:= aExTipo[ nPos , 6 ]
					nHoras  := SubHoras( nResto , SubHoras( aExTipo[ nPos , 2 ] , 0.01 ) )
					IF lPort1510	.and. ( lRotFec )
						/*
						ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						³ Calculo das horas extras diarias para agregar ao aTotais 	  ³
						³ independente do periodo de apuracao das mesmas.			  ³						
						ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
						IF nHorasApo > nHoras
							nHorasApo:= SubHoras( nHorasApo , nHoras) 
							nHorasAux:= nHoras
						Else
						    nHorasAux:= nHorasApo
						    nHorasApo:= 0
						Endif
					Endif
									
					//--Gerar no Array de Resultado e Totais
					IF !( lRotFec )
						fGeraRes(	@aResult		,; //01 -> Array com os Resultados
									dData			,; //02 -> Data da Gravacao	
									nHoras			,; //03 -> Valor a Ser Gravado	
									cEvento			,; //04 -> Codigo onde Gravar
									cCusto			,; //05 -> Centro de Custo Onde Gravar
									cTpMarc			,; //06 -> Tipo da Marcacao
									lSoma			,; //07 -> Se soma a valor ja Existente
									cPeriodo		,; //08 -> Periodo para a Tolerancia
									0				,; //09 -> Tolerancia
									"H"				,; //10 -> Tipo de Arredondamento a Ser considerado
									lSubstitui		,; //11 -> Substitui a(s) Hora(s) Existente(s)
									/*cFuncao	*/	,; //12 -> Funcao  
				  					/*cDepto	*/	,; //13 -> Depto para gravacao
									/*cPosto	*/	,; //14 -> Posto para gravacao
									/*cProcesso	*/	,; //15 -> Periodo para Gravacao
									/*cRoteiro	*/	,; //16 -> Processo para Gravacao
									/*cPerApo	*/	,; //17 -> Periodo para Gravacao
									/*cNumPagto	*/ 	,; //18 -> NumPagto para Gravacao
									cTurno 			,; //19 -> Turno de Trabalho
									cSemana			,; //20 -> Semana/Sequencia do Turno
									cTipoHE			,; //21 -> Tipo de Hora Extra
									nPercent		;  //22 -> Percentual de Valorizacao							
								 )
					Else
						IF ( lSubstitui == NIL )
							lSubstitui := !( lSoma )
						EndIF
						fGeraTot(	@aTotais 		,;	//01 -> Array com os Totais do Ponto
									dData			,;	//02 -> Data para Pesquisa e Gravacao no aTotais
									nHoras			,;	//03 -> Horas para Soma ou Geracao
									0   			,;	//04 -> Valor para Soma ou Geracao
									cEvento			,;	//05 -> Evento do Ponto para Pesquisa
									cCusto			,;	//06 -> Centro de Custo para Comparacao
									SRA->RA_FILIAL	,;	//07 -> Filial para Pesquisa no SP9									
									NIL				,;	//08 -> Verba da Folha
									lSubstitui	 	,;	//09 -> Substitui a(s) Hora(s) Existente(s) em aTotais   
									/*cFuncao	*/	,;  //10 -> Funcao  
				  					/*cDepto	*/	,;  //11 -> Depto para gravacao
									/*cPosto	*/	,;  //12 -> Posto para gravacao
									/*cProcesso	*/	,;  //13 -> Periodo para Gravacao
									/*cRoteiro	*/	,;  //14 -> Processo para Gravacao
									/*cPerApo	*/	,;  //15 -> Periodo para Gravacao
									/*cNumPagto	*/ 	,;  //16 -> NumPagto para Gravacao
									cTurno 			,;  //17 -> Turno de Trabalho
									cSemana			,;  //18 -> Semana/Sequencia do Turno
									cTipoHE			,;  //19 -> Tipo de Hora Extra
									nPercent		;   //20 -> Percentual de valorizacao									
								)
						IF lPort1510
							/*
							ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
							³ Geracao das horas extras diarias para agregar ao aTotais 	  ³
							³ independente do periodo de apuracao das mesmas.			  ³						
							ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
							IF nHorasAux > 0
								fGeraTot(	@aTotDia 		,;	//01 -> Array com os Totais do Ponto
											dDataApo		,;	//02 -> Data para Pesquisa e Gravacao no aTotais
											nHorasAux		,;	//03 -> Horas para Soma ou Geracao
											0   			,;	//04 -> Valor para Soma ou Geracao
											cEvento			,;	//05 -> Evento do Ponto para Pesquisa
											cCusto			,;	//06 -> Centro de Custo para Comparacao
											SRA->RA_FILIAL	,;	//07 -> Filial para Pesquisa no SP9									
											NIL				,;	//08 -> Verba da Folha
											lSubstitui	 	,;	//09 -> Substitui a(s) Hora(s) Existente(s) em aTotais   
											/*cFuncao	*/	,;  //10 -> Funcao  
						  					/*cDepto	*/	,;  //11 -> Depto para gravacao
											/*cPosto	*/	,;  //12 -> Posto para gravacao
											/*cProcesso	*/	,;  //13 -> Periodo para Gravacao
											/*cRoteiro	*/	,;  //14 -> Processo para Gravacao
											/*cPerApo	*/	,;  //15 -> Periodo para Gravacao
											/*cNumPagto	*/ 	,;  //16 -> NumPagto para Gravacao
											cTurno 			,;  //17 -> Turno de Trabalho
											cSemana			,;  //18 -> Semana/Sequencia do Turno
											cTipoHE			,;  //19 -> Tipo de Hora Extra
											nPercent		;   //20 -> Percentual de valorizacao									
										)  
							Endif			
						Endif
					EndIF
					nResto  := SubHoras( nResto , SubHoras( nResto , SubHoras( aExTipo[ nPos , 2 ] , 0.01 ) ) )
				Else
					Exit
				EndIF
			End While
		
		Next nN
		
	End Sequence
	
EndIF
	
Return( NIL )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³ToScheduleOverTime³Autor ³Marinaldo de Jesus ³Data³11/07/2002³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Gerar Horas Extras Escalonads                                ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³< Vide Parametros Formais >									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³< Vide Parametros Formais >								   	 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Geracao de Horas Extras                                      ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function ToScheduleOverTime(	aTabExtra	,;	//01 -> Array contendo os Tipos de Horas Extras
								cTpExtra	,;	//02 -> Tipo de Hora Extra a ser Gerado
								nThoras		,;	//03 -> Numero de Horas Extras Autorizadas
								nTNhoras	,;	//04 -> Numero de Horas Extras Nao Autorizadas
								aResult		,;	//05 -> Array com os Resultados do Apontamento do Dia
								aTotais		,;	//06 -> Array com os Totais Apontados por Evento do Dia
								dData		,;	//07 -> Data da Gravacao
								cRotina		,;	//08 -> Rotina Chamadora da Funcao
								cPeriodo	,;	//09 -> Periodo de Apuracao
								lSoma		,;	//10 -> Soma ao Valor Existente
								cCusto		,;	//11 -> Centro de Custo Para Gravacao
								cTpMarc		,;	//12 -> Tipo de Marcacao
								lSubstitui	,;	//13 -> Se Substitui as Horas Existentes  
								cFuncao		,;	//14 -> Funcao para Gravacao
								cDepto		,;	//15 -> Depto para Gravacao
								cPosto		,;	//16 -> Posto para Gravacao
								cProcesso	,;	//17 -> Processo para Gravacao																								
								cPeriodo	,;	//18 -> Periodo para Gravacao
								cRoteiro	,;	//19 -> Processo para Gravacao								
								cNumPagto	,;	//20 -> NumPagto para Gravacao
								cTurno 		,;	//21 -> Turno de Trabalho
								cSemana		,; 	//22 -> Semana/Sequencia do Turno 
								aTotDia     ,;	//23 -> Totais diarios     
								dDataApo	; 	//24 -> Data do Apontamento								
							)

Local aExTipo		:= {}
Local lAutoriza		:= .F.
Local lRotFec		:= ( cRotina == "FEC" )

Local cEvento
Local cTipoHE 
Local nPercent
Local cHeKeyAtu
Local cTipoDia

Local nResto
Local nHoras 
Local nHorasAux		:= 0 
Local nPos
Local nPosPlus1
Local nPos1  
Local nN
Local nLenExt
Local nLenGer
Local nPosTpDia 
Local dDataDia			

DEFAULT nThoras			:= 0
DEFAULT nTNhoras		:= 0
DEFAULT __aHeLastGera__	:= {}
DEFAULT __cHeLastKey__	:= "__cHeLastKey__"   

//-- Portaria 1.510
DEFAULT __lCpoTurno		:= ( cPaisLoc == "BRA" ) //campo utilizaod somente no Brasil   
DEFAULT __lCpoSemana	:= ( cPaisLoc == "BRA" ) //campo utilizaod somente no Brasil   
DEFAULT __lCpoTipoHE	:= ( cPaisLoc == "BRA" ) //campo utilizaod somente no Brasil   
DEFAULT __lCpoPercent	:= ( cPaisLoc == "BRA" ) //campo utilizaod somente no Brasil   
    
IF __lCpoTurno .and. __lCpoSemana .and. __lCpoTipoHE .and. __lCpoPercent
	DEFAULT cTurno  	:= Space( GetSx3Cache( "PC_TURNO"		, "X3_TAMANHO" ) )
	DEFAULT cSemana		:= Space( GetSx3Cache( "PC_SEMANA"		, "X3_TAMANHO" ) )	
	DEFAULT cTipoHE		:= Space( GetSx3Cache( "PC_TIPOHE"		, "X3_TAMANHO" ) )	
	DEFAULT nPercent	:= 0
Else
	cTurno  			:= Space( GetSx3Cache( "PJ_TURNO"		, "X3_TAMANHO" ) )
	cSemana				:= Space( GetSx3Cache( "PJ_SEMANA"		, "X3_TAMANHO" ) )	
	cTipoHE				:= Space( GetSx3Cache( "P4_TIPO"		, "X3_TAMANHO" ) )		
	nPercent			:= 0
Endif

//--Gerar Array do Tipo Desejado
aExTipo 	:= GetExTipo( aTabExtra , @cTpExtra )
nLenExt 	:= Len( aExTipo )
cTipoDia	:= GetDiaToEx( cTpExtra )

cHeKeyAtu	:= ( cEmpAnt + cFilAnt + SRA->RA_MAT + Dtos( dData ) )
IF !( cHeKeyAtu == __cHeLastKey__ )
	__aHeLastGera__	:= {}
	__cHeLastKey__	:= cHeKeyAtu

	aAdd( __aHeLastGera__ , { cTipoDia , nThoras , nTNhoras , {}, {} } )
	nPosTpDia := Len( __aHeLastGera__ )
Else
	IF ( ( nPosTpDia := aScan( __aHeLastGera__ , { |x| x[1] == cTipoDia } ) ) == 0 )
		aAdd( __aHeLastGera__ , { cTipoDia , 0 , 0 , {}, {} } )
		nPosTpDia := Len( __aHeLastGera__ )
	EndIF
	__aHeLastGera__[ nPosTpDia , 02 ] := SomaHoras( __aHeLastGera__[ nPosTpDia , 02 ] , nThoras  )
	__aHeLastGera__[ nPosTpDia , 03 ] := SomaHoras( __aHeLastGera__[ nPosTpDia , 03 ] , nTNhoras )
EndIF


//-- 1o. para Autorizado e 2o. para Nao Autorizada
For nN := 1 To 2
	lAutoriza := ( nN == 1 )
	nResto := IF( ( lAutoriza ) , __aHeLastGera__[ nPosTpDia , 02 ] , __aHeLastGera__[ nPosTpDia , 03 ] )
	nPos := 0
	While ( nResto > 0 ) .and. ( ++nPos <= nLenExt )
		//-- Aplicar a Tabela de Horas Extras
		nPosPlus1	:= Min( nPos + 1 , nLenExt )
		nHoras  	:= Min( nResto , SubHoras( aExTipo[ Min( nPosPlus1 , nLenExt ) , 02 ] , aExTipo[ nPos , 02 ] ) )
		nHoras 		:= IF( nHoras == 0 , nResto , nHoras )
		nResto		:= SubHoras( nResto , nHoras )
		cEvento 	:= aExTipo[ nPos , IF( ( lAutoriza ) , 04 , 05 ) ]
		cTipoHE		:= aExTipo[ nPos , 1 ]
		nPercent	:= aExTipo[ nPos , 6 ]			
		nPos1 		:= 0
		nLenGer 	:= Len( __aHeLastGera__[ nPosTpDia , 04 ] ) 
		
		//-- Subtrai da quantidade de Horas remanescentes o total de horas ja enviadas para 
		//-- o aResult
		While ( ++nPos1 <= nLenGer )
			IF ( ;
					__aHeLastGera__[ nPosTpDia , 04 , nPos1 , 01 ] == nPos;
					.and.;
					__aHeLastGera__[ nPosTpDia , 04 , nPos1 , 04 ] == lAutoriza;
					.and.;
					(;
						__aHeLastGera__[ nPosTpDia , 04 , nPos1 , 03 ] <> cEvento;
						.or.;
						__aHeLastGera__[ nPosTpDia , 04 , nPos1 , 05 ] <> cTpMarc;
						.or.;
						__aHeLastGera__[ nPosTpDia , 04 , nPos1 , 09 ] <> dDataApo;
						.or.;
						__aHeLastGera__[ nPosTpDia , 04 , nPos1 , 06 ] <> cCusto;
					);
				)
				nHoras  := SubHoras( nHoras , __aHeLastGera__[ nPosTpDia , 04 , nPos1 , 02 ] )
			EndIF
		End While  
		
		//-- Substitui o total de horas da faixa para o evento pelo total de horas calculadas
		IF ( nPos1 := aScan( __aHeLastGera__[ nPosTpDia , 04 ]	, { |x|	x[1] == nPos;
																		.and.;
																		x[3] == cEvento;
																		.and.;
																		x[4] == lAutoriza;
																		.and.;
																		x[5] == cTpMarc;
																		.and.;
																		x[9] == dDataApo;
																		.and.;
																		x[6] == cCusto;
												  	   			  };
							);
			 ) > 0
			
			__aHeLastGera__[ nPosTpDia , 04 , nPos1 , 02 ] := nHoras
			
			nHorasAux:=	nHoras  
			
			dDataDia :=	__aHeLastGera__[ nPosTpDia , 04 , nPos1 , 09 ]
			
		Else
			aAdd( __aHeLastGera__[ nPosTpDia , 04 ] , { nPos , nHoras , cEvento , lAutoriza , cTpMarc , cCusto, cTipoHE, nPercent, dDataApo } )
		    nHorasAux	:= nHoras 
		    dDataDia	:= dDataApo
		EndIF
		
		//--Gerar no Array de Resultado e Totais
		IF !Empty( nHoras )
			IF !( lRotFec )
				DEFAULT lSubstitui		:= .T.
				fGeraRes(	@aResult			,; //01 -> Array com os Resultados
							dData				,; //02 -> Data da Gravacao	
							nHoras				,; //03 -> Valor a Ser Gravado	
							cEvento				,; //04 -> Codigo onde Gravar
							cCusto				,; //05 -> Centro de Custo Onde Gravar
							cTpMarc				,; //06 -> Tipo da Marcacao
							lSoma				,; //07 -> Se soma a valor ja Existente
							cPeriodo			,; //08 -> Periodo para a Tolerancia
							0   				,; //09 -> Tolerancia
							"H" 				,; //10 -> Tipo de Arredondamento a ser Considerado
							lSubstitui			,; //11 -> Substitui a(s) Hora(s) Existente(s)
							/*cFuncao	*/		,; //12 -> Funcao  
							/*cDepto	*/		,; //13 -> Depto para gravacao
							/*cPosto	*/		,; //14 -> Posto para gravacao
							/*cProcesso	*/		,; //15 -> Periodo para Gravacao
							/*cRoteiro	*/		,; //16 -> Processo para Gravacao
							/*cPerApo	*/		,; //17 -> Periodo para Gravacao
							/*cNumPagto	*/ 		,; //18 -> NumPagto para Gravacao
							cTurno 				,; //19 -> Turno de Trabalho
							cSemana				,; //20 -> Semana/Sequencia do Turno
							cTipoHE				,; //21 -> Tipo de Hora Extra
							nPercent			;  //22 -> Percentual de valorizacao
						 )
			Else
				IF ( lSubstitui == NIL )
					lSubstitui := !( lSoma )
				EndIF
				fGeraTot(	@aTotais 		,;	//01 -> Array com os Totais do Ponto
							dData			,;	//02 -> Data para Pesquisa e Gravacao no aTotais
							nHoras			,;	//03 -> Horas para Soma ou Geracao
							0   			,;	//04 -> Valor para Soma ou Geracao
							cEvento			,;	//05 -> Evento do Ponto para Pesquisa
							cCusto			,;	//06 -> Centro de Custo para Comparacao
							SRA->RA_FILIAL	,;	//07 -> Filial para Pesquisa no SP9
							NIL				,;	//08 -> Verba da Folha
							lSubstitui	 	,;	//09 -> Substitui a(s) Hora(s) Existente(s) em aTotais   
							/*cFuncao	*/	,;  //10 -> Funcao  
		  					/*cDepto	*/	,;  //11 -> Depto para gravacao
							/*cPosto	*/	,;  //12 -> Posto para gravacao
							/*cProcesso	*/	,;  //13 -> Periodo para Gravacao
							/*cRoteiro	*/	,;  //14 -> Processo para Gravacao
							/*cPerApo	*/	,;  //15 -> Periodo para Gravacao
							/*cNumPagto	*/ 	,;  //16 -> NumPagto para Gravacao
							cTurno 			,;  //17 -> Turno de Trabalho
							cSemana			,;  //18 -> Semana/Sequencia do Turno
							cTipoHE			,;  //19 -> Tipo de Hora Extra
							nPercent		;   //20 -> Percentual de valorizacao							
						) 
						IF lPort1510 .and. ( lRotFec )
							/*
							ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
							³ Geracao das horas extras diarias para agregar ao aTotais 	  ³
							³ independente do periodo de apuracao das mesmas.			  ³						
							ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
						
								fGeraTot(	@aTotDia 		,;	//01 -> Array com os Totais do Ponto
											dDataDia		,;	//02 -> Data para Pesquisa e Gravacao no aTotais
											nHorasAux		,;	//03 -> Horas para Soma ou Geracao
											0   			,;	//04 -> Valor para Soma ou Geracao
											cEvento			,;	//05 -> Evento do Ponto para Pesquisa
											cCusto			,;	//06 -> Centro de Custo para Comparacao
											SRA->RA_FILIAL	,;	//07 -> Filial para Pesquisa no SP9									
											NIL				,;	//08 -> Verba da Folha
											lSubstitui	 	,;	//09 -> Substitui a(s) Hora(s) Existente(s) em aTotais   
											/*cFuncao	*/	,;  //10 -> Funcao  
						  					/*cDepto	*/	,;  //11 -> Depto para gravacao
											/*cPosto	*/	,;  //12 -> Posto para gravacao
											/*cProcesso	*/	,;  //13 -> Periodo para Gravacao
											/*cRoteiro	*/	,;  //14 -> Processo para Gravacao
											/*cPerApo	*/	,;  //15 -> Periodo para Gravacao
											/*cNumPagto	*/ 	,;  //16 -> NumPagto para Gravacao
											cTurno 			,;  //17 -> Turno de Trabalho
											cSemana			,;  //18 -> Semana/Sequencia do Turno
											cTipoHE			,;  //19 -> Tipo de Hora Extra
											nPercent		;   //20 -> Percentual de valorizacao									
										)  
								
						Endif						
			EndIF
		EndIF
	End While	
Next nN

Return( NIL )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³RstToScheduleOverTime³Aut³Marinaldo de Jesus³Data³11/03/2003³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Reinicializa as Staticas utilizadas em ToScheduleOverTime() ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico													³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function RstToScheduleOverTime()

__aHeLastGera__ := NIL
__cHeLastKey__	:= "__cHeLastKey__"

Return( NIL )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³GetExTipo		  ³Autor ³Marinaldo de Jesus ³Data³28/08/2002³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Retorna Array com o Tipo de Hora Extra a ser utilizado       ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³< Vide Parametros Formais >									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³< Vide Parametros Formais >								   	 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Geracao de Horas Extras                                      ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function GetExTipo( aTabExtra , cTpExtra )

Local aExTipo	:= {}
Local bEval		:= { |x| IF( x[1] == cTpExtra , aAdd( aExTipo , x ) , NIL ) }

aEval( aTabExtra , bEval )

//-- Quando nao Encotrar o Tipo de Hora Extra Exato, Procura o Tipo Correspondente
//-- 5=1;6=2;7=3;8=4	//HE Noturnas/Normais	
//-- B=A;D=C;F=E;H=G	//HE Intervalos Noturnas/Normais
IF Empty( aExTipo )
	Do Case
		Case ( cTpExtra $ "H_G" )			//Tipos de Intervalo Feriado
			IF ( cTpExtra == "H" )			//Hora Extra Intervalo Noturna Feriado
				cTpExtra	:= "8"			//Hora Extra Feriado Noturna
				aEval( aTabExtra , bEval )
				IF Empty( aExTipo )
					cTpExtra	:= "G"    	//Hora Extra Intervalo Diurna Feriado
					aEval( aTabExtra , bEval )
				EndIF
				IF Empty( aExTipo )
					cTpExtra	:= "4"		//Hora Extra Feriado Diurna
					aEval( aTabExtra , bEval )
				EndIF
			ElseIF ( cTpExtra == "G" )		//Hora Extra Intervalo Diurna Feriado
				cTpExtra	:= "4"			//Hora Extra Feriado Diurna
				aEval( aTabExtra , bEval )
			EndIF
		Case ( cTpExtra $ "F_E" )			//Tipos de Intervalo Compensado
			IF ( cTpExtra == "F" )			//Hora Extra Intervalo Noturna Compensado
				cTpExtra	:= "7"			//Hora Extra Compensado Noturna
				aEval( aTabExtra , bEval )
				IF Empty( aExTipo )
					cTpExtra	:= "E"	    //Hora Extra Intervalo Diurna Compensado
					aEval( aTabExtra , bEval )
				EndIF
				IF Empty( aExTipo )
					cTpExtra	:= "3"		//Hora Extra Compensado Diurna
					aEval( aTabExtra , bEval )
				EndIF
			ElseIF ( cTpExtra == "E" )		//Hora Extra Intervalo Diurna Compensado
				cTpExtra := "3"				//Hora Extra Compensado Diurna
				aEval( aTabExtra , bEval )
			EndIF
		Case ( cTpExtra $ "D_C" )			//Tipos de Intervalo DSR
			IF ( cTpExtra == "D" )			//Hora Extra Intervalo Noturna DSR
				cTpExtra	:= "6"			//Hora Extra DSR Noturna
				aEval( aTabExtra , bEval )
				IF Empty( aExTipo )
					cTpExtra := "C"			//Hora Extra Intervalo Diurna DSR
					aEval( aTabExtra , bEval )
				EndIF
				IF Empty( aExTipo )
					cTpExtra := "2"			//Hora Extra DSR Diurna
					aEval( aTabExtra , bEval )
				EndIF
			ElseIF ( cTpExtra == "C" )		//Hora Extra Intervalo Diurna DSR
				cTpExtra := "2"				//Hora Extra DSR Diurna
				aEval( aTabExtra , bEval )
			EndIF
		Case ( cTpExtra $ "B_A" )			//Tipos de Intervalo Normal
			IF ( cTpExtra == "B" )			//Hora Extra Intervalo Noturna Normal
				cTpExtra	:= "5"			//Hora Extra Noturna Normal
				aEval( aTabExtra , bEval )
				IF Empty( aExTipo )
					cTpExtra	:= "A"		//Hora Extra Intervalo Normal
					aEval( aTabExtra , bEval )
				EndIF
				IF Empty( aExTipo )
					cTpExtra := "1"			//Hora Extra Normal
					aEval( aTabExtra , bEval )
				EndIF
			ElseIF ( cTpExtra == "A" )		//Hora Extra Intervalo Normal
				cTpExtra := "1"				//Hora Extra Normal
				aEval( aTabExtra , bEval )
			EndIF	
		OtherWise							//Tipos de Horas Extras
			cTpExtra := IF( Val( cTpExtra ) > 4 , StrZero( Val( cTpExtra ) - 4 , 1 ) , cTpExtra )
			aEval( aTabExtra , bEval )
	EndCase
EndIF

Return( aExTipo )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³GetTpExInt		  ³Autor ³Marinaldo de Jesus ³Data³10/09/2003³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Retorna Tipo de Hora Extra de Intervalo Conforme Tipo do Dia ³
³          ³ou Tipo de Hora Extra										 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³< Vide Parametros Formais >									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³< Vide Parametros Formais >								   	 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico                                                     ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function GetTpExInt( cTpDiaExt , lNoturna )

Local cTpExtInt		:= "A"

DEFAULT cTpDiaExt	:= "S"
DEFAULT lNoturna	:= .F.

Do Case
	Case ( cTpDiaExt $ "F_8_4" ) ; ( cTpExtInt := IF( lNoturna , "H" , "G" ) )	//Feriado
	Case ( cTpDiaExt $ "C_7_3" ) ; ( cTpExtInt := IF( lNoturna , "F" , "E" ) )	//Compensado
	Case ( cTpDiaExt $ "D_6_2" ) ; ( cTpExtInt := IF( lNoturna , "D" , "C" ) )	//DSR
	Case ( cTpDiaExt $ "S_5_1" ) ; ( cTpExtInt := IF( lNoturna , "B" , "A" ) )	//Normal
End Case

Return( cTpExtInt )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³GetDiaToEx		  ³Autor ³Marinaldo de Jesus ³Data³22/09/2003³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Retorna Tipo do Dia de Acordo com o Tipo de Horas Extras     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³< Vide Parametros Formais >									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³< Vide Parametros Formais >								   	 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico                                                     ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function GetDiaToEx( cTpExtra )

Local cTipoDia	:= ""

DEFAULT cTpExtra := "S"

Do Case
	Case ( cTpExtra $ "F_8_4" ) ; ( cTipoDia := "F" )	//Feriado
	Case ( cTpExtra $ "C_7_3" ) ; ( cTipoDia := "C" )	//Compensado
	Case ( cTpExtra $ "D_6_2" ) ; ( cTipoDia := "D" )	//DSR
	Case ( cTpExtra $ "S_5_1" ) ; ( cTipoDia := "S" )	//Normal
End Case

Return( cTipoDia )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³fGeraRes     ³Autor ³Equipe Advanced RH   ³ Data ³01/04/1997³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Gerar no Array a Result os Resultados do Apontamento        ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³< Vide Parametros Formais >								  	³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³< Vide Parametros Formais >								  	³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function fGeraRes(	aResult		,; //01 -> Array com os Resultados do Dia
					dDtGer		,; //02 -> Data da Geracao
					nHoras		,; //03 -> Numero de Horas Resultantes
					cEvento		,; //04 -> Codigo do Evento
					cCusto		,; //05 -> Centro de Custo a ser Gravado
					cTpMarc		,; //06 -> Tipo de Marcacao
					lSoma		,; //07 -> True para Acumular as Horas
					cPeriodo	,; //08 -> Periodo de Apuracao
					nTole		,; //09 -> Tolerancia
					cArred		,; //10 -> Tipo de Arredondamento a Ser Utilizado
					lSubstitui	,; //11 -> Substitui a(s) Hora(s) Existente(s)
					cFuncao		,; //12 -> Funcao  
					cDepto		,; //13 -> Depto para gravacao
					cPosto		,; //14 -> Posto para gravacao
					cProcesso	,; //15 -> Periodo para Gravacao
					cRoteiro	,; //16 -> Processo para Gravacao
					cPerApo		,; //17 -> Periodo para Gravacao
					cNumPagto	,; //18 -> NumPagto para Gravacao
					cTurno 		,; //19 -> Turno de Trabalho
					cSemana		,; //20 -> Semana/Sequencia do Turno
					cTipoHE		,; //21 -> Tipo de Hora Extra
					nPercent	,; //22 -> Percentual de Valorizacao
					lTolHrNReal	,; //23 -> Horas nao realizadas (atrasado/saida antecipada)
					aHrNReal	,; //24 -> Array com as Horas nao realizadas (atrado/saida antecipada)
					cQtdAbono	,; //25 -> Quantidade de horas de Abono
					nTolHrEvt	,; //26 -> Tolerancia do Evento do ponto (Atrado/Saida antecipada)		
					lTemTolSai	 ; //27 -> A tolerância por marcação para Atraso/Saida está preenchida
				  )
Local bAsc
Local nRes
Local lTolOk			:= .F.
Local lGravaResult		:= .F.

DEFAULT cEvento 		:= ""
DEFAULT cPeriodo		:= ""
DEFAULT nHoras			:= 0
DEFAULT nTole			:= 0
DEFAULT nTolHrEvt		:= 0
DEFAULT lTolHrNReal		:= .F.
DEFAULT aHrNReal        := {}
DEFAULT cQtdAbono		:= 0
DEFAULT lTemTolSai		:= .F.

DEFAULT lCpoCCT	   		:=  SP4->(ColumnPos("P4_CODCCT") > 0)

Static nCusto := NIL
Static nTpMarc := NIL

DEFAULT nCusto := GetSx3Cache("PC_CC", "X3_TAMANHO" )
DEFAULT nTpMarc := GetSx3Cache("PC_TPMARCA", "X3_TAMANHO")

IF !Empty( cEvento ) .and. ( nHoras > 0 ) .and. ( IF( cPeriodo == "D" , IF( ( nTole > 0 ) , ( NoRound(nHoras) > nTole ) , .T. ) , .T. ) .OR. (lTolHrNReal) )
		
		If lTolHrNReal
			lTolOk := IF( cPeriodo == "D" , IF( ( lTemTolSai .Or. nTole > 0 ) , ( NoRound(nHoras) > nTole ) , .F. ) , .F. )
			If !Empty(aHrNReal)
				If ( ( nPos := aScan( aHrNReal , { |x| x[1] == dDtGer .and. x[2] == cEvento } ) ) > 0 )
					If ( Empty(cTpMarc) .And. lSoma )
						aHrNReal[nPos,3] := SomaHoras(aHrNReal[nPos,3],nHoras)
						If lTolOk
							aHrNReal[nPos,5] := SomaHoras(aHrNReal[nPos,5],nHoras)
						ElseIf nTolHrEvt < aHrNReal[nPos,3] .And. nTolHrEvt <> 0
							aHrNReal[nPos,5] := aHrNReal[nPos,3]
						EndIf
						nHoras	:= aHrNReal[nPos,3]
					Else
						aAdd(aHrNReal,{dDtGer,cEvento,nHoras,lTolOk,If(lTolOk,nHoras,0), cTpMarc})					
					EndIf
					If !lTolOk
						aHrNReal[nPos,4] := .F.
					EndIf
				Else
					aAdd(aHrNReal,{dDtGer,cEvento,nHoras,lTolOk,If(lTolOk,nHoras,0), cTpMarc})
				EndIf
			Else
				If nTolHrEvt > 0 .Or. NoRound(nHoras) > nTole
					aAdd(aHrNReal,{dDtGer,cEvento,nHoras,lTolOk,If(lTolOk,nHoras,0), cTpMarc})
				EndIf
			EndIf
		EndIf
	
	DEFAULT aResult 	:= {}
	DEFAULT dDtGer  	:= dDataBase
	DEFAULT cCusto  	:= Space(nCusto)
	DEFAULT cTpMarc		:= Space(nTpMarc)
	DEFAULT lSoma   	:= .F.
	DEFAULT cArred		:= ""
	DEFAULT lSubstitui	:= .F. 
	
	//-- Portaria 1.510
	DEFAULT __lCpoTurno		:= ( cPaisLoc == "BRA" ) //campo utilizaod somente no Brasil  
	DEFAULT __lCpoSemana	:= ( cPaisLoc == "BRA" ) //campo utilizaod somente no Brasil   
	DEFAULT __lCpoTipoHE	:= ( cPaisLoc == "BRA" ) //campo utilizaod somente no Brasil   
	DEFAULT __lCpoPercent	:= ( cPaisLoc == "BRA" ) //campo utilizaod somente no Brasil   
	
	IF __lCpoTurno .and. __lCpoSemana .and. __lCpoTipoHE .and. __lCpoPercent
		DEFAULT cTurno  	:= Space( GetSx3Cache( "PC_TURNO"		, "X3_TAMANHO" ) )
		DEFAULT cSemana		:= Space( GetSx3Cache( "PC_SEMANA"		, "X3_TAMANHO" ) )	
		DEFAULT cTipoHE		:= Space( GetSx3Cache( "PC_TIPOHE"		, "X3_TAMANHO" ) )	
		DEFAULT nPercent	:= 0
	Else
		cTurno  			:= Space( GetSx3Cache( "PJ_TURNO"		, "X3_TAMANHO" ) )
		cSemana				:= Space( GetSx3Cache( "PJ_SEMANA"		, "X3_TAMANHO" ) )	
		cTipoHE				:= Space( GetSx3Cache( "P4_TIPO"		, "X3_TAMANHO" ) )		
		nPercent			:= 0
	Endif
	
	bAsc	:= { |x| x[ARESULT_DATA] == dDtGer .and. x[ARESULT_EVENTO] == cEvento .and. x[ARESULT_CC] == cCusto .and. x[ARESULT_TPMARCA] == cTpMarc }
	nRes	:= 0
	
	lSoma := IF( lSoma .and. lSubstitui , !( lSubstitui ) , lSoma )
	IF ( ( lSoma .or. lSubstitui ) .and. ( nRes := aScan( aResult , bAsc  ) ) > 0 )
		IF ( lSoma )
			If lTolHrNReal .And. Empty(cTpMarc)
				aResult[ nRes , ARESULT_HORAS ] := nHoras
			Else
				aResult[ nRes , ARESULT_HORAS ] := SomaHoras( aResult[ nRes , ARESULT_HORAS ] , nHoras )
			EndIf
		ElseIF ( lSubstitui )
			aResult[ nRes , ARESULT_HORAS ] := nHoras
		EndIF
	Else
	
		lGravaResult	:=	((nTole == 0) .OR. (nHoras > nTole) .OR. (nTolHrEvt > 0) )
		If ( lGravaResult )
			
			aAdd( aResult , Array( ELEMENTOS_ARESULT ) )
			nRes := Len( aResult )
			aResult[ nRes , ARESULT_DATA 		] := dDtGer			//01 - Data da Geracao
			aResult[ nRes , ARESULT_EVENTO		] := cEvento		//02 - Codigo do Evento
			aResult[ nRes , ARESULT_HORAS		] := nHoras			//03 - Horas
			aResult[ nRes , ARESULT_CC			] := cCusto			//04 - Centro de Custo
			aResult[ nRes , ARESULT_TPMARCA		] := cTpMarc		//05 - Tipo da Marcacao
			aResult[ nRes , ARESULT_ARRED		] := cArred			//06 - Tipo de Arredondamento a Ser Utilizado
			aResult[ nRes , ARESULT_DTOS_DATA	] := Dtos( dDtGer )	//07 - String de Data
			aResult[ nRes , ARESULT_NUM_ABO_HRS	] := cQtdAbono		//08 - Qtde Horas Abonadas do Evento
			aResult[ nRes , ARESULT_RESULT_APO	] := {}				//09 - Array de Horarios Abonados para o Evento
			/*aResult[ nRes , ARESULT_FUNCAO	] := cFuncao	*/	//10 - Funcao
			/*aResult[ nRes , ARESULT_DEPTO	    ] := cDepto		*/	//15 - Depto 
			/*aResult[ nRes , ARESULT_POSTO	    ] := cPosto		*/	//16 - Posto 
			/*aResult[ nRes , ARESULT_PROCESSO  ] := cProcesso	*/	//11 - Processo
			/*aResult[ nRes , ARESULT_PERIODO	] := cPerApo 	*/	//12 - Periodo
			/*aResult[ nRes , ARESULT_ROTEIRO	] := cRoteiro	*/	//13 - Roteiro 	
			/*aResult[ nRes , ARESULT_NUM_PAGTO ] := cNumPagto	*/	//14 - NumPagto			
			
			aResult[ nRes , ARESULT_TURNO    	] := cTurno			//15 - Turno de trabalho
			aResult[ nRes , ARESULT_SEMANA   	] := cSemana		//16 - Semana/Sequencia do turno
			aResult[ nRes , ARESULT_TIPOHE   	] := cTipoHE		//17 - Tipo de Horas Extras
			aResult[ nRes , ARESULT_PERCENT  	] := nPercent		//18 - Percentual de Valorizacao			
			
			If lCpoCCT .And. !Empty(cTipoHE)
				aResult[ nRes, ARESULT_FILCCT] := GetFilCCT()
				aResult[ nRes, ARESULT_CODCCT] := GetCodCCT()
			EndIf
			
		EndIf
	EndIf
EndIF

Return( NIL )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³AjustaResult ³Autor ³Marinaldo de Jesus   ³ Data ³18/07/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Ajustar as Horas em aResult os Resultados do Apontamento    ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³< Vide Parametros Formais >								  	³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³< Vide Parametros Formais >								  	³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function AjustaResult( aResult )

Local aResAux
Local nRes
Local nResults

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Acertando as Horas                                          ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
IF ( ( nResults := Len( aResult ) ) > 0 )
	For nRes := 1 To nResults
		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Nao Mexer no Calculo abaixo. Ele eh utilizado para   efetuar³
		³ a correta conversao das horas que ateh este ponto estao  com³
		³ mais de 2 casas decimais ( Necessario para que o calculo das³
		³ Horas de Adicional Noturno Fiquem Ok )                      ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		aResult[ nRes , ARESULT_HORAS ] := __TimeSum( __TimeSum( aResult[ nRes , ARESULT_HORAS ] , 0 ) , 0 )
	Next nRes
	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Remonta o aResult Eliminaldo Apontamentos Zerados           ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	IF ( aScan( aResult , { |x| x[ ARESULT_HORAS ] == 0 } ) > 0 )
		aResAux := aClone( aResult )
		aResult	:= {}
		For nRes := 1 To nResults
			IF !Empty( aResAux[ nRes , ARESULT_HORAS ] )
				aAdd( aResult , aClone( aResAux[ nRes ] ) )
			EndIF
		Next nRes
	EndIF
EndIF	

Return( NIL )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³fGeraTot     ³Autor ³Marinaldo de Jesus   ³ Data ³24/09/2002³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Gerar no Array aTotais os Totais Apontado					³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³< Vide Parametros Formais >								  	³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³< Vide Parametros Formais >								  	³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function fGeraTot(	aTotais 		,;	//01 -> Array com os Totais do Ponto
					dData			,;	//02 -> Data para Pesquisa e Gravacao no aTotais
					nHoras			,;	//03 -> Horas para Soma ou Geracao
					nValor			,;	//04 -> Valor para Soma ou Geracao
					cEvento			,;	//05 -> Evento do Ponto para Pesquisa
					cCusto			,;	//06 -> Centro de Custo para Comparacao
					cFil			,;	//07 -> Filial para Pesquisa no SP9
					cVerba			,;	//08 -> Verba da Folha
					lSubstitui		,;	//09 -> Substitui a(s) Hora(s) Existente(s) em aTotais   
					cFuncao			,;  //10 -> Funcao  
					cDepto			,;  //11 -> Depto para gravacao
					cPosto			,;  //12 -> Posto para gravacao
					cProcesso		,;  //13 -> Periodo para Gravacao
					cRoteiro		,;  //14 -> Processo para Gravacao
					cPerApo			,;  //15 -> Periodo para Gravacao
					cNumPagto		,;  //16 -> NumPagto para Gravacao
					cTurno 			,;  //17 -> Turno de Trabalho
					cSemana			,;  //18 -> Semana/Sequencia do Turno
					cTipoHE			,;  //19 -> Tipo de Hora Extra   
					nPercent		,; 	//20 -> Percentual de Valorizacao
					cFilCCT			,;  //21 -> Filial da CCT
					cCodCCT			;  	//22 -> Código da CCT
				)

Local bAsc		:= { || .F. }
Local nPos		:= 0

DEFAULT aTotais		:= {}
DEFAULT dData		:= Ctod("//")
DEFAULT nHoras		:= 0
DEFAULT nValor		:= 0
DEFAULT cEvento		:= Space( GetSx3Cache( "PB_PD"	, "X3_TAMANHO" ) )
DEFAULT cCusto		:= Space( GetSx3Cache( "PB_CC"	, "X3_TAMANHO" ) )
DEFAULT cFil		:= fFilFunc( "SP9" )
DEFAULT cVerba		:= PosSP9( cEvento , cFil , "P9_CODFOL" , 1 )
DEFAULT lSubstitui	:= .F.  
DEFAULT cTipoHE		:= "" 
DEFAULT nPercent	:= 0
DEFAULT cFilCCT		:= ""
DEFAULT cCodCCT		:= ""

bAsc := { |x|	(;
					( x[ATOTAIS_EVENTO_PONTO] 	== cEvento );
					.and.;
					( x[ATOTAIS_DATA]			== dData );
					.and.;
					( x[ATOTAIS_CENTO_DE_CUSTO]	== cCusto );
				);
		}

IF ( ( nPos := aScan( aTotais , bAsc ) ) > 0 )
	IF ( lSubstitui )
		aTotais[ nPos , ATOTAIS_HORAS ] := nHoras
		aTotais[ nPos , ATOTAIS_VALOR ] := nValor
	Else
	    aTotais[ nPos , ATOTAIS_HORAS ] := SomaHoras( aTotais[ nPos , ATOTAIS_HORAS] , nHoras )
		aTotais[ nPos , ATOTAIS_VALOR ] += nValor
	EndIF
Else
	aAdd( aTotais , Array( ELEMENTOS_DO_ATOTAIS ) )
	nPos := Len( aTotais )
	aTotais[ nPos , ATOTAIS_DATA			] := dData				//01 - Data do Evento
	aTotais[ nPos , ATOTAIS_EVENTO_PONTO	] := cEvento			//02 - Codigo do Evento
	aTotais[ nPos , ATOTAIS_HORAS			] := nHoras				//03 - Quantidade do Evento
	aTotais[ nPos , ATOTAIS_CODIGO_FOLHA	] := cVerba				//04 - Codigo para a Folha
	aTotais[ nPos , ATOTAIS_CENTO_DE_CUSTO	] := cCusto				//05 - Centro de Custo do Evento
	aTotais[ nPos , ATOTAIS_VALOR			] := nValor				//06 - Valor do Evento
	aTotais[ nPos , ATOTAIS_DTOS_DATA		] := Dtos( dData )		//07 - String de Data   
	aTotais[ nPos , ATOTAIS_TIPOHE			] := cTipoHE			//08 - Tipo de Hora Extra
	aTotais[ nPos , ATOTAIS_PERCENT			] := nPercent			//09 - Percentual de Valorizacao da HE
	aTotais[ nPos , ATOTAIS_FILCCT			] := cFilCCT			//17 - Filial CCT
	aTotais[ nPos , ATOTAIS_CODCCT			] := cCodCCT			//18 - Código CCT
EndIF

Return( nPos )


/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³fGerRFF      ³Autor ³Mauricio MR		  ³ Data ³04/12/2009³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Gerar no Array aRFF os Totais Apontados para o SREP      	³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³< Vide Parametros Formais >								  	³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³< Vide Parametros Formais >								  	³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function fGerRFF(	aTotais 		,;	//01 -> Array com os Totais do Ponto
					dData			,;	//02 -> Data para Pesquisa e Gravacao no aTotais
					cEvento			,;	//03 -> Evento do Ponto para Pesquisa
					cEveOrig		,;	//04 -> Codigo do Evento de Origem da Informacao
					nHoras			,;	//05 -> Horas para Soma ou Geracao     
					nAbonadas		,;  //06 -> Quantidade horas Abonadas
					nBanco			,;  //07 -> Quantidade horas Banco de Horas
					cCusto			,;	//08 -> Centro de Custo para Comparacao
					cPerApo			,;  //09 -> Periodo para Gravacao
					cTipoHE			,;  //10 -> Tipo de Hora Extra   
					nPercent		,; 	//11 -> Percentual de Valorizacao		
					lSubstitui		,;	//12 -> Substitui a(s) Hora(s) Existente(s) em aTotais   				  
					cSinal			;	//13 -> Sinal da quantidade horas
				  )

Local bAsc		:= { || .F. }
Local nPos		:= 0

DEFAULT aTotais		:= {}
DEFAULT dData		:= Ctod("//")
DEFAULT cEvento		:= Space( GetSx3Cache( "RFF_PD"	, "X3_TAMANHO" ) )
DEFAULT cEveOrig	:= Space( GetSx3Cache( "RFF_PD"	, "X3_TAMANHO" ) )
DEFAULT nHoras		:= 0
DEFAULT nAbonadas   := 0
DEFAULT nBanco		:= 0
DEFAULT cCusto		:= Space( GetSx3Cache( "RFF_CC"	, "X3_TAMANHO" ) )
DEFAULT cPerApo		:= ""   
DEFAULT cTipoHE		:= "" 
DEFAULT nPercent	:= 0
DEFAULT lSubstitui	:= .F.  
DEFAULT cSinal		:= "1" 

bAsc := { |x|	(;
					( x[ARFF_EVENTO_PONTO] 	== cEvento );
					.and.;
					( x[ARFF_DATA]			== dData );
					.and.;
					( x[ARFF_CENTRO_DE_CUSTO]	== cCusto );
				);
		}

IF ( ( nPos := aScan( aTotais , bAsc ) ) > 0 )
	IF ( lSubstitui )
		aTotais[ nPos , ARFF_HORAS ] 			:= nHoras
		aTotais[ nPos , ARFF_HORAS_ABONADAS ] 	:= nAbonadas
		aTotais[ nPos , ARFF_HORAS_BANCO 	] 	:= nBanco		
	Else
	    aTotais[ nPos , ARFF_HORAS ] 			:= SomaHoras( aTotais[ nPos , ARFF_HORAS] 			, nHoras )
	    aTotais[ nPos , ARFF_HORAS_ABONADAS ] 	:= SomaHoras( aTotais[ nPos , ARFF_HORAS_ABONADAS] 	, nAbonadas )	    
  		aTotais[ nPos , ARFF_HORAS_BANCO ] 		:= SomaHoras( aTotais[ nPos , ARFF_HORAS_BANCO] 	, nBanco )	    
	EndIF
Else

	aAdd( aTotais , Array( ELEMENTOS_DO_ARFF ) )
	nPos := Len( aTotais )
	aTotais[ nPos , ARFF_DATA			] := dData				//01 - Data do Evento
	aTotais[ nPos , ARFF_EVENTO_PONTO	] := cEvento			//02 - Codigo do Evento
	aTotais[ nPos , ARFF_HORAS			] := nHoras				//03 - Quantidade do Evento
	aTotais[ nPos , ARFF_CENTRO_DE_CUSTO] := cCusto				//04 - Centro de Custo do Evento
	aTotais[ nPos , ARFF_DTOS_DATA		] := Dtos( dData )		//05 - String de Data   
	aTotais[ nPos , ARFF_EVENTO_ORIGEM	] := cEveOrig			//06 - Codigo do Evento de Origem da Informacao
	aTotais[ nPos , ARFF_HORAS_ABONADAS	] := nAbonadas			//07 - Quantidade horas Abonadas
	aTotais[ nPos , ARFF_HORAS_BANCO	] := nBanco				//08 - Quantidade horas para Banco de Horas
	aTotais[ nPos , ARFF_PERIODO_APO	] := cPerApo			//09 - Quantidade do Evento     
	aTotais[ nPos , ARFF_TIPOHE			] := cTipoHE			//10 - Tipo de Hora Extra
	aTotais[ nPos , ARFF_PERCENT		] := nPercent			//11 - Percentual de Valorizacao da HE     
	aTotais[ nPos , ARFF_HORAS_SINAL	] := cSinal				//12 - Sinal da quantidade. '1' - Positivo '2' - Negativo

EndIF

Return( nPos )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³fDiasFolga³ Autor ³Equipe Advanced RH     ³ Data ³11/02/1999³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Altera aTabCalend de Forma a Transformar o Dia em DSR       ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³fDiasFolga(aMarcacoes,aTabCalend,dPerIni,dPerFim...)		³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico                                                    ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function fDiasFolga(	aMarcacoes		,;	//01 -> Array padrao contendo as marcacoes           
						aTabCalend		,;	//02 -> Array padrao contendo o calendario do func.  
						dPerIni			,;	//03 -> Inicio do Periodo de Apontamento             
						dPerFim			,;	//04 -> Final do Periodo de Apontamento              
						cCodDsrAutPa	,;	//05 -> Codigo do DSR Ult. Semana do Periodo Anterior
						lAcumulado		,;	//06 -> Se a Pesquisa deve ser Feita nos Acumulados  
						lGrava			 ;	//07 -> Nao Gravar o Evento
					)

Local aFaltas		:= {}
Local aDomingo		:= {}
Local cOrdem		:= ""
Local cGeraDSR		:= "N"
Local cUltOrd		:= ""
Local cUltOrdDom	:= ""
Local cAliasPesq	:= "SPC"
Local cFilSRA		:= NIL 
Local cFilSR6		:= xFilial( "SR6", SRA->RA_FILIAL ) 
Local cMatSRA		:= NIL 
Local cPrefixo		:= ""
Local cTipAfas		:= ""
Local cMsgErr		:= ""
Local dData			:= Ctod("//")
Local dUltDiaTab	:= dData
Local dIniAfas		:= dData
Local dFimAfas		:= dData
Local lCodDSRAutPa	:= .F.
Local lGerDSRAutPa	:= .F.
Local lRet			:= .F.
Local lLock			:= .F.
Local nDias			:= 0
Local nCount		:= 0
Local nX			:= 0
Local nPos			:= 0
Local nPos2			:= 0
Local nPos3			:= 0
Local nProxD		:= 0
Local nCt			:= 0	
Local nFornCt		:= 0
Local nLenTab		:= 0
Local nRecDSRAutPa	:= 0

DEFAULT aMarcacoes	:= {}
DEFAULT aTabCalend	:= {}
DEFAULT dPerIni		:= dDataBase
DEFAULT dPerFim		:= dDataBase
DEFAULT cCodDsrAutPa:= ""
DEFAULT lAcumulado	:= .F.
DEFAULT lGrava		:= .T.
DEFAULT cFilSRA		:= SRA->RA_FILIAL
DEFAULT cMatSRA		:= SRA->RA_MAT

IF lAcumulado
	cAliasPesq	:= "SPH"
EndIF

cAliasPesq		:= Upper( AllTrim( cAliasPesq ) )
cPrefixo		:= ( PrefixoCpo( cAliasPesq ) + "_" )
nLenTab			:= Len(aTabCalend)
nDias			:= ( ( dPerFim - dPerIni ) + 1 )
dData			:= dPerIni
lCodDSRAutPa	:= !( cCodDsrAutPa == "@" .or. Empty(cCodDsrAutPa) )
cUltOrd			:= aTabCalend[nLenTab,CALEND_POS_ORDEM]

IF ( nPos := aScan( aTabCalend , { |x| x[CALEND_POS_ORDEM] == cUltOrd .and. x[CALEND_POS_TIPO_MARC] == "1E" } ) ) > 0
	dUltDiaTab	:= aTabCalend[ nPos , CALEND_POS_DATA ]
EndIF

aEval( aTabCalend , {;
						 |x,y|;
						 		 IF( x[CALEND_POS_TIPO_MARC]=="1E" .and. Dow(x[CALEND_POS_DATA]) == 1 ,;
						 		 	 cUltOrdDom := aTabCalend[y,CALEND_POS_ORDEM] ,;
						 		 	 NIL;
						 		 	);
					 };
	  )

For nCount := 1 To nDias

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Guarda a Ordem da Tabela									  ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	cOrdem := StrZero( nCount , __nTamP8Ordem )
	IF (nPos := aScan(aTabCalend, {|x| x[CALEND_POS_ORDEM] == cOrdem})) > 0
		dData := aTabCalend[nPos,CALEND_POS_DATA]
	Else
		dData++
		Loop
	EndIF

	IF Dow(dUltDiaTab) != 1
		IF lCodDSRAutPa
			IF ( cAliasPesq )->( MsSeek( cFilSRA + cMatSRA + cCodDsrAutPa + Dtos(dPerFim+1) ) )
				nRecDSRAutPa := SPC->( Recno() )
			EndIF
		EndIF
	EndIF

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Verifica as Trocas de Turno								  ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	IF ( fBscTnoFolga(cFilSR6,aTabCalend[nPos,CALEND_POS_TURNO]) # "S" )

		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Se a semana iniciou-se com um turno com DSR automatico,iden ³
		³ tifica-se a parte da semana com DSR automatico ate a data	  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		IF	 cGeraDSR == "S"   
		    //-- Calcula a segunda-feira que antecedeu a data atual
		    aAdd( aDomingo,{ dData , If( Dow(dData) == 1, (dData-6), dData -( Dow(dData) - 2 )  ) } )
		EndIF
		cGeraDSR := "N"
		dData++
		Loop
	EndIF

	cGeraDSR := "S"

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Obtem o Inicio e Fim de Cada Semana para Verifica se a Falta³
	³ Esta ou Nao Dentro da Mesma								  ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	IF ( Dow(dData) == 1 )
		aAdd(aDomingo,{dData,dData-6})
	ElseIF ( dData == dPerFim )
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Verifica qual o Proximo Domingo							  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		While ( Dow( dData ) != 1 )
			++dData
		End While
		aAdd(aDomingo,{dData,dData-6})
		dData := dPerFim
	EndIF

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Marca‡„o anterior a Admiss„o.                               ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	IF SRA->(;
				( RA_SITFOLH == Space( GetSx3Cache( "RA_SITFOLH" , "X3_TAMANHO" ) ) );
				.and.;
				( dData < RA_ADMISSA );
			)
		dData++
		Loop
	EndIF

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Marca‡„o posterior a Demiss„o ou Transferencia              ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	IF SRA->( RA_SITFOLH $ "DúT" .and. !Empty(RA_DEMISSA) .and. dData > RA_DEMISSA )
		dData ++
		Loop
	EndIF

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Marca‡„o dentro de intervalo de Afastamento.                ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	cTipAfas	:=	aTabCalend[ nPos , CALEND_POS_TIP_AFAST ]
	dIniAfas	:=	aTabCalend[ nPos , CALEND_POS_INI_AFAST ]
	dFimAfas	:=	aTabCalend[ nPos , CALEND_POS_FIM_AFAST ]
	IF aTabCalend[ nPos , CALEND_POS_AFAST ] .and. ;
		( dData >= dIniAfas .And. dData <= IF( Empty( dFimAfas ) , dData , dFimAfas ) )
		IF ( ( SR6->R6_APODFER == "S" ) .And. ( cTipAfas == "F" ) )
			dData := dData
		Else
			dData ++
			Loop
		EndIF
	EndIF

	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Verifica quais os dias sao faltas, caso este dia nao tenha  ³
	| lancamento e o mesmo seja um feriado, ele nao e considerado |
	| uma falta.							 					  |
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ	
	*/
	If !aTabCalend[ nPos, CALEND_POS_FERIADO] .OR. aTabCalend[ nPos, CALEND_POS_TRAB_FERIADO] 
		IF ( nPos := aScan( aMarcacoes, { |x| x[3] == cOrdem } ) ) == 0 
			nPos:= Ascan( aTabCalend  , {|x| x[CALEND_POS_DATA] == dData })
			If ( nPos > 0 ) .AND. ( aTabCalend[nPos , CALEND_POS_TIPO_DIA ] == 'S' )
				aAdd( aFaltas, dData )
			EndIf
		EndIF
	EndIf
	
Next nCount

nFornCt := Len(aDomingo)

For nCt := 1 To nFornCt

	dData := aDomingo[nCt,1]

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Verifica a Qual Semana a Falta Pertence                     ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	IF ( nPos := aScan( aFaltas, {|x| x <= aDomingo[nCt,1] .and. x >= aDomingo[nCt,2] } ) ) > 0
		dData := aFaltas[nPos]
	Else
		Loop
	EndIF

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Se for a Primeira Semana Verifica se Ja Teve DSR na   Ultima³
	³ Semana do Periodo de Apontamento Anterior e Nao Gera o   DSR³
	³ Automatico para a Semana.									  ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	IF ( ( nCt == 1 ) .and. ( lCodDSRAutPa ) )
		IF ( cAliasPesq )->( MsSeek( cFilSRA + cMatSRa + cCodDsrAutPa + Dtos(dPerIni) ) )
			Loop
		EndIF
	EndIF

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Se ja houver excecao para a data em questao nao altera o  Ho³
	³ rario														  ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	IF ( nPos2 := aScan(aTabCalend, { |x| x[CALEND_POS_DATA] == dData .and. x[CALEND_POS_TIPO_MARC] == "1E" } ) ) > 0 .and.;
	   ( fBscTnoFolga(cFilSR6,aTabCalend[nPos2,CALEND_POS_TURNO]) == "S" )
		nX		:= nPos2
		lRet	:= .T.
		While ( ( nX <= nLenTab ) .and. aTabCalend[nPos2,CALEND_POS_ORDEM] == aTabCalend[nX,CALEND_POS_ORDEM] )
			IF aTabCalend[nX,CALEND_POS_EXCECAO] # "E"
				/*/
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Atualiza a folga diretamente em aTabCalend				  ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
				IF ( ( nX - nPos2 ) < 2 )
					aTabCalend[ nX , CALEND_POS_HORA        ] := 0											//Hora
					aTabCalend[ nX , CALEND_POS_TIPO_DIA    ] := "D"										//Tipo do Dia
					aTabCalend[ nX , CALEND_POS_HRS_INTER   ] := 0											//Intervalo
					aTabCalend[ nX , CALEND_POS_MOT_EXECAO  ] := STR0101									//*/** DSR Automatico ***
					aTabCalend[ nX , CALEND_POS_TIPO_HE_NOR ] := SR6->(IF(Empty(R6_TPEXT),"2",R6_TPEXT))	//Tipo de Horas Extras Normais
					aTabCalend[ nX , CALEND_POS_TIPO_HE_NOT ] := SR6->(IF(Empty(R6_TPEXTN),"6",R6_TPEXTN))	//Tipo de Horas Extras Noturnas
					If ( ( nX - nPos2 ) == 1 )  
						If ( nPos3 := aScan(aTabCalend, { |x| x[CALEND_POS_DATA] == dData + 1 .and. x[CALEND_POS_TIPO_MARC] == "1E" } ) ) > 1
							aTabCalend[ nX, CALEND_POS_LIM_MARCACAO ] := aClone( aTabCalend[ nPos3 - 1, CALEND_POS_LIM_MARCACAO ] )//Limite da Marcacao							
						EndIf
					EndIf
				Else
					/*/
					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					³ Elimina os Elementos que Nao serao Utilizados em aTabCalend ³
					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
					aDel(aTabCalend,nX)
					aSize(aTabCalend,--nLenTab)
					--nX
				EndIF	
			EndIF
			nX++
		End While
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Quando For a Ultima Semana e o Dia Nao For um Domingo e   Ti³
		³ver Sido Gerado um DSR Grava o Evento de DSR Automatico   Mes³
		³Anterior Para o Proximo Mes								  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		IF ( ( Dow(dUltDiaTab) != 1 ) .and. !( lAcumulado ) .and. ( lGrava ) )
			IF ( ( lCodDSRAutPa ) .and. ( aTabCalend[ nPos2 , CALEND_POS_ORDEM ] >= cUltOrdDom ) .and. ( aTabCalend[ nPos2 , CALEND_POS_ORDEM ] <= cUltOrd ) )
				lGerDSRAutPa := .T.
				IF(  Dow( aTabCalend[ nPos2 , CALEND_POS_DATA ] ) == 1 )
					IF ( ( nProxD := aScan( aTabCalend , { |x| x[CALEND_POS_DATA] == ( aTabCalend[ nPos2 , CALEND_POS_DATA ] + 1 ) .and. x[CALEND_POS_TIPO_MARC] == "1E" } ) ) > 0 )
						/*/
						ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						³ Nao Gera quando for o Domingo da Penultima Semana		      ³
						ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
						lGerDSRAutPa := !( Dow( aTabCalend[ nProxD , CALEND_POS_DATA ] ) == 2 ) 
					EndIF
				EndIF	
				IF ( lGerDSRAutPa )
					IF !Empty( nRecDSRAutPa )
						( cAliasPesq )->( dbGoto( nRecDSRAutPa ) )
						lLock := ( cAliasPesq )->( RecLock( cAliasPesq , .F. , .F. ) )
					Else
						lLock := RecLock( cAliasPesq , .T. , .F. )
					EndIF
					IF ( lLock )
						( cAliasPesq )->( &(cPrefixo+"FILIAL")	)	:= cFilSRA
						( cAliasPesq )->( &(cPrefixo+"MAT")		)	:= cMatSRA
						( cAliasPesq )->( &(cPrefixo+"DATA")	)	:= ( dPerFim + 1 )
						( cAliasPesq )->( &(cPrefixo+"PD")		)	:= cCodDsrAutPa
						( cAliasPesq )->( &(cPrefixo+"CC")		)	:= SRA->RA_CC
						( cAliasPesq )->( &(cPrefixo+"QUANTC")	)	:= 0.01
						( cAliasPesq )->( MsUnLock() )
					EndIF
				EndIF
			EndIF
		EndIF
	EndIF
Next

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Quando nao Houver DSR Automatico a Ser Gerado e Ja Existir  o³
³Evento, Exclui.											  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
IF ( !( lAcumulado ) .and. ( lGrava ) )
	IF ( !( lGerDSRAutPa ) .and. !Empty( nRecDSRAutPa ) )
		( cAliasPesq )->( dbGoto( nRecDSRAutPa ) )
		IF ( cAliasPesq )->( RecLock( cAliasPesq , .F. , .F. ) )
			IF !( cAliasPesq )->( FkDelete( @cMsgErr ) )
				( cAliasPesq )->( RollBackDelTran( cMsgErr ) )
			EndIF
			( cAliasPesq )->( MsUnLock() )
		EndIF	
	EndIF
EndIF

Return( lRet )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³fBscTnoFolga ³Autor³ Equipe Advanced RH   ³ Data ³10/02/1999³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³ Retorna (S/N) parametro do Turno - 1a.Falta da Semana=Folga³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³fBscTnoFolga( cFil , cTno )                                 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³ fDiasFolga()	                                            ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function fBscTnoFolga( cFil , cTno )

Local aArea			:= GetArea()
Local cR6AsFolga	:= ""
Local nPosTr 		:= 0

IF ( nPosTr := aScan( aSr6Info , { |x| x[1] == cFil .and. x[2] == cTno } ) ) == 0
	cCondSR6 := "% R6_FILIAL = '"+cFil+"' AND "
	cCondSR6 += "R6_TURNO  = '"+cTno+"' %"
					
	cQrySR6 := GetNextAlias()
	
	BeginSql alias cQrySR6
		SELECT R6_INIHNOT, R6_FIMHNOT, R6_MINHNOT, R6_APODFER, R6_TPEXFER, R6_TPEXFEN, R6_AUTOHEF, R6_ASFOLGA, R6_TNOOPC, R_E_C_N_O_ RECNO
		FROM %table:SR6% SR6
		WHERE
		%exp:cCondSR6% AND SR6.%NotDel%
	EndSql
	
	If (cQrySr6)->(!Eof())
		aAdd( aSr6Info, { cFil, cTno, (cQrySr6)->(R6_INIHNOT), (cQrySr6)->(R6_FIMHNOT), (cQrySr6)->(R6_MINHNOT), (cQrySr6)->(R6_APODFER), (cQrySr6)->(R6_TPEXFER), (cQrySr6)->(R6_TPEXFEN), (cQrySr6)->(R6_AUTOHEF), (cQrySr6)->RECNO, (cQrySr6)->(R6_ASFOLGA), (cQrySr6)->(R6_TNOOPC) } )
		SR6->( MsGoto( (cQrySR6)->RECNO ) )						
		cR6AsFolga	:= (cQrySr6)->(R6_ASFOLGA)
	EndIf
	(cQrySR6)->(dbCloseArea())	
Else
	SR6->( MsGoto( aSr6Info[nPosTr, 10] ) )
	cR6AsFolga	:= aSr6Info[nPosTr, 11]
EndIf

RestArea(aArea)

Return( cR6AsFolga )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o	   ³PosSP9	  ³ Autor ³ Marinaldo de Jesus	  ³ Data ³17/01/2003³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³< vide parametros formais >									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³< vide parametros formais >									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³cCompKey	= Chave Complementar para Pesquisa			  	³
³          ³cFil    	= Filial do Evento que deseja 	 			  	³
³          ³cCampo  	= Campo  do Evento que Deseja Pesquisar 		³
³          ³nOrdem  	= Ordem  da Pesquisa                    		³
³          ³lMsGoto 	= Se Deve Reposicionar Recno            		³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso	   ³ Generico 													³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function PosSP9( cCompKey , cFil , uCampo , nOrdem , lMsGoto )
DEFAULT lMsGoto := .T.
Return( PosAlias( "SP9" , cCompKey , cFil , uCampo , nOrdem , lMsGoto ) )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o	   ³PosSPA	  ³ Autor ³ Marinaldo de Jesus	  ³ Data ³17/01/2003³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Posiciona no Evento Desejado no SPA							³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³< vide parametros formais >									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³< vide parametros formais >									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso	   ³Generico 													³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function PosSPA( cCompKey , cFil , uCampo , nOrdem , lMsGoto )
DEFAULT lMsGoto := .T.
Return( PosAlias( "SPA" , cCompKey , cFil , uCampo , nOrdem , lMsGoto ) )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o	   ³PosSR6	  ³ Autor ³ Marinaldo de Jesus	  ³ Data ³17/01/2003³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Posiciona no Turno Desejado no SR6							³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³< vide parametros formais >									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³< vide parametros formais >									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso	   ³Generico 													³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function PosSR6( cCompKey , cFil , uCampo , nOrdem , lMsGoto )
DEFAULT lMsGoto := .T.
Return( PosAlias( "SR6" , cCompKey , cFil , uCampo , nOrdem , lMsGoto ) )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o	   ³PosSP6	  ³ Autor ³ Marinaldo de Jesus	  ³ Data ³17/01/2003³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Posiciona no Abono Desejado no SP6						    ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³< vide parametros formais >									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³< vide parametros formais >									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso	   ³Generico 													³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function PosSP6( cCompKey , cFil , uCampo , nOrdem , lMsGoto )
DEFAULT lMsGoto := .T.
Return( PosAlias( "SP6" , cCompKey , cFil , uCampo , nOrdem , lMsGoto ) )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³fQualSeq    ³ Autor ³Marinaldo de Jesus    ³ Data ³26/10/2000³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Retorna o numero da Seq do Turno de Acordo com a Data Inicial³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³fQualSeq( aTabCalend , aTabPadrao , dPerIni , cTurno )		 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³aTabCalend -> Calendario do Periodo Atual          		     ³
³          ³aTabPadrao -> Calendario Padrao                    		     ³
³          ³dPerIni    -> Data do Periodo Inicial para achar a Seq.		 ³
³          ³cTurno     -> Turno Atual do Funcionario           		     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³cSeq - Sequencia Inicial da Tabela de Horario Padrao		 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico                                                     ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function fQualSeq( aTabCalend , aTabPadrao , dPerIni , cTurno, aTurnos )

Local aSeq		:= {}
Local cSeq		:= ""
Local cFil		:= xFilial( "SPJ" , SRA->RA_FILIAL )
Local dQualSeg  := dPerIni
Local dSegAtu   := Ctod('//')
Local dSvSegAt  := Ctod('//')
Local nLenTurno	:= 0
Local nPosTab	:= 0
Local nSegund   := 0
Local nSvPosT	:= 0
Local nX		:= 0
Local nFornX	:= 0

Default aTurnos := {}

cTurno 		:= IF( cTurno == NIL , SRA->RA_TNOTRAB , cTurno )
nLenTurno 	:= Len( aTurnos )

If nLenTurno > 0
	nPosTab := aScan( aTabCalend , { |x| x[CALEND_POS_TIPO_MARC] == "1E" .And. x[CALEND_POS_DATA] == aTurnos[nLenTurno, 2] } )
Else
	nPosTab := aScan( aTabCalend , { |x| x[CALEND_POS_TIPO_MARC] == "1E" } )
EndIf

IF ( nPosTab > 0 )
	dSegAtu := aTabCalend[ nPosTab , CALEND_POS_DATA 		]
	cSeq	:= aTabCalend[ nPosTab , CALEND_POS_SEQ_TURNO	]
	cTurno	:= aTabCalend[ nPosTab , CALEND_POS_TURNO		]
Else
	cSeq	:= SRA->RA_SEQTURN
	dSegAtu := dPerIni
EndIF

IF ( ( nPosTab := aScan( aTabPadrao , { |x| x[1] == cFil .and. x[ 2 ] == cTurno } ) ) > 0 )
	nFornX := Len( aTabPadrao[ nPosTab , 3 ] )
	For nX := 1 To nFornX
		IF ( aScan( aSeq , { |x| x[ 1 ] == aTabPadrao[ nPosTab , 3 , nX , 19 ] } ) == 0 )
			aAdd( aSeq , { aTabPadrao[ nPosTab , 3 , nX , 19 ] , '' } )
		EndIF
	Next nX
EndIF

IF ( Dow( dQualSeg ) != 2 )
	While ( Dow( --dQualSeg ) != 2 )
	End While
EndIF

IF ( Dow( dSegAtu ) != 2 )
	While ( Dow( --dSegAtu ) != 2 )
	End While
EndIF

IF ( !Empty( aSeq ) .and. ( Len( aSeq ) > 1 ) )
	IF ( ( nPosTab := aScan( aSeq, { |x| x[ 1 ] == cSeq } ) ) > 0 )
       	aSeq[ nPosTab , 2 ] := dSegAtu
		nSvPosT	 := nPosTab
        dSvSegAt := dSegAtu
		While ( ++nPosTab <= Len( aSeq ) )
			aSeq[ nPosTab , 2 ] := ( dSegAtu := ( dSegAtu + 7 ) )
		End While
		nPosTab := nSvPosT
        dSegAtu := dSvSegAt
		While ( --nPosTab >= 1 )
        	aSeq[ nPosTab , 2 ] := ( dSegAtu := ( dSegAtu - 7 ) )
		End While
		dSegAtu := dSvSegAt
		IF ( ( nTotSeq := Len( aSeq ) ) > 1 )
			nPosTab := nSvPosT
            IF ( dSegAtu > dQualSeg )
	            nSegund := ( dSegAtu - dQualSeg ) / 7
       			While ( --nSegund >= 0 )
					IF ( nPosTab == 1 )
						nPosTab := nTotSeq
					Else
						--nPosTab
					EndIF
				End While
			Else
                nSegund := ( dQualSeg - dSegAtu ) / 7
                While ( --nSegund >= 0 )
					IF ( nPosTab == nTotSeq )
						nPosTab := 1
					Else
						++nPosTab
					EndIF
				End While
			EndIF
            cSeq := aSeq[ nPosTab , 1 ]
        Else
			cSeq := aSeq[ 1 , 1 ]
		EndIF
	EndIF
EndIF

Return( cSeq )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³fHrsTrabGat ³ Autor ³Marinaldo de Jesus    ³ Data ³24/10/2000³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Calcula Total de Horas da Tabela de Horario Padrao		     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³fHrsTrabGat()												 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³cTipo  -> "H"oras, "I"ntervalo, "T"otal de Horas			 ³
³          ³cAlias -> "SPJ" Tabela de Horario Padrao ou "SP2" Excecoes	 ³
³          ³cObj   -> "GD" GetDatos, "MB" mBrowse ou "DB" Arquivo		 ³
³          ³cInt   -> Quando cTipo = "I", qual Intervalo "1", "2" ou "3" ³
³          ³          Quando cTipo = "H", qual Periodo "1","2","3" ou "4"³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³nHoras									                     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Gatilho                                                      ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function fHrsTrabGat( cTipo , cAlias , cObj , cInt )

Local nHoras		:= 0
Local cVar			:= IF( cObj == "DB" , "" , Upper( AllTrim( ReadVar() ) ) )
Local cPrefixo		:= ""
Local dE1			:= dDataBase
Local dS1			:= Ctod('//')
Local dE2			:= Ctod('//')
Local dS2			:= Ctod('//')
Local dE3			:= Ctod('//')
Local dS3			:= Ctod('//')
Local dE4			:= Ctod('//')
Local dS4			:= Ctod('//')
Local dS5			:= Ctod('//')
Local dS6			:= Ctod('//')
Local lHnotTab		:= .F.
Local lHnotTbI		:= .F.
Local lNoExecGat	:= ( Type( "lHrsTrbGat" ) == "L" .and. !( lHrsTrbGat ) )
Local nE1			:= 0
Local nS1			:= 0
Local nE2			:= 0
Local nS2			:= 0
Local nE3			:= 0
Local nS3			:= 0
Local nE4			:= 0
Local nS4			:= 0
Local nE5			:= 0
Local nS5			:= 0
Local nE6			:= 0
Local nS6			:= 0
Local nI1			:= 0
Local nI2			:= 0
Local nI3			:= 0
Local nI4			:= 0
Local nI5			:= 0
Local nI1c			:= 0
Local nI2c			:= 0
Local nI3c			:= 0
Local nI4c			:= 0
Local nI5c			:= 0
Local nHr1			:= 0
Local nHr2			:= 0
Local nHr3			:= 0
Local nHr4			:= 0
Local nHr5			:= 0
Local nHr6			:= 0
Local nJn1			:= 0
Local nJn2			:= 0
Local nJn3			:= 0
Local nJn4			:= 0
Local nJn5			:= 0
Local nJn6			:= 0
Local nIniHnot		:= 0
Local nFimHnot		:= 23.59
Local nMinHnot		:= 60
Local nColsMarc		:= SuperGetmv( "MV_COLMARC" , NIL , 2 , cFilAnt )
Local lAdNotHr		:= SuperGetMV("MV_ADNOTHR", .F., .F.)
Local lCustom		:= .F.

cTipo		:= IF(cTipo == NIL .or. ValType(cTipo) != "C", "H"  ,IF(!(Upper(AllTrim(cTipo ))$"I_H_T"),"H",Upper(AllTrim(cTipo))))
cAlias		:= IF(cAlias == NIL .or. ValType(cTipo)!= "C", "SPJ" , Upper( AllTrim( cAlias ) ) )
cObj		:= IF(cObj == NIL .or. ValType(cTipo) != "C", "GD" ,IF(!(Upper(AllTrim(cObj ))$"GD_MB_DB"),"GD",Upper(AllTrim(cObj))))
cObj		:= IF(cAlias == "SP2" .and. Type("lGatForceGd") == "L" .and. cObj != "DB" , IF( lGatForceGd , "GD" , cObj ) , cObj )
cInt		:= IF(cInt == NIL .or. ValType(cInt) != "C", ""  ,IF(!(Upper(AllTrim(cInt ))$"1_2_3_4_5_6"),"",AllTrim(cInt)))
cPrefixo	:= ( PrefixoCpo( cAlias ) + "_" )
lCustom		:= cPaisLoc $ "BRA" .And. cAlias == "SPJ" .And. (nColsMarc == 5 .Or. nColsMarc == 6) 

Begin Sequence

	IF ( lNoExecGat )
		Break
	EndIF

	IF ( cAlias == "SPJ" )
		lHnotTab	:= ( SR6->R6_HNOTTAB == "S" )
		lHnotTbI	:= ( SR6->R6_HNOTTBI == "S" )
		nIniHnot	:= SR6->R6_INIHNOT
		nFimHnot	:= SR6->R6_FIMHNOT
		nMinHnot	:= SR6->R6_MINHNOT
	ElseIF ( cAlias == "SP2" )
		IF ( cObj == "GD" )
			lHnotTab	:= ( GdFieldGet( cPrefixo+"HNOTTAB") == "S" )
			lHnotTbI	:= ( GdFieldGet( cPrefixo+"HNOTTBI") == "S" )
			nIniHnot	:= GdFieldGet( cPrefixo+"INIHNOT")
			nFimHnot	:= GdFieldGet( cPrefixo+"FIMHNOT")
			nMinHnot	:= GdFieldGet( cPrefixo+"MINHNOT")
		ElseIF ( cObj == "MB" )
			lHnotTab	:= ( GetMemVar( "P2_HNOTTAB" ) == "S" )
			lHnotTbI	:= ( GetMemVar( "P2_HNOTTBI" ) == "S" )
			nIniHnot	:= GetMemVar( "P2_INIHNOT" )
			nFimHnot	:= GetMemVar( "P2_FIMHNOT" )
			nMinHnot	:= GetMemVar( "P2_MINHNOT" )
		ElseIF	( cObj == "DB" )
			lHnotTab	:= (cAlias)->( &( cPrefixo+"HNOTTAB") == "S" )
			lHnotTbI	:= (cAlias)->( &( cPrefixo+"HNOTTBI") == "S" )
			nIniHnot	:= (cAlias)->( &( cPrefixo+"INIHNOT") )
			nFimHnot	:= (cAlias)->( &( cPrefixo+"FIMHNOT") )
			nMinHnot	:= (cAlias)->( &( cPrefixo+"MINHNOT") )
		EndIF
	EndIF
	
	IF ( cObj == "GD" )
		
		nE1		:= GdFieldPos( cPrefixo+"ENTRA1" )
		nS1		:= GdFieldPos( cPrefixo+"SAIDA1" )
		nE2		:= GdFieldPos( cPrefixo+"ENTRA2" )
		nS2		:= GdFieldPos( cPrefixo+"SAIDA2" )
		nE3		:= GdFieldPos( cPrefixo+"ENTRA3" )
		nS3		:= GdFieldPos( cPrefixo+"SAIDA3" )
		nE4		:= GdFieldPos( cPrefixo+"ENTRA4" )
		nS4		:= GdFieldPos( cPrefixo+"SAIDA4" )
		nI1		:= GdFieldPos( IF( cAlias == "SPJ" , "PJ_HRSINT1" , "P2_HRINTV1" )  )
		nI2		:= GdFieldPos( IF( cAlias == "SPJ" , "PJ_HRSINT2" , "P2_HRINTV2" )  )
		nI3		:= GdFieldPos( IF( cAlias == "SPJ" , "PJ_HRSINT3" , "P2_HRINTV3" )  )
		nI1c	:= GdFieldPos( cPrefixo+"INTERV1" )
		nI2c	:= GdFieldPos( cPrefixo+"INTERV2" )
		nI3c	:= GdFieldPos( cPrefixo+"INTERV3" )
		nHr1	:= GdFieldPos( cPrefixo+"HRSTRAB" )
		nHr2	:= GdFieldPos( cPrefixo+"HRSTRA2" )
		nHr3	:= GdFieldPos( cPrefixo+"HRSTRA3" )
		nHr4	:= GdFieldPos( cPrefixo+"HRSTRA4" )
		nJn1	:= GdFieldPos( cPrefixo+"JND1CON" )
		nJn2	:= GdFieldPos( cPrefixo+"JND2CON" )
		nJn3	:= GdFieldPos( cPrefixo+"JND3CON" )
		nJn4	:= GdFieldPos( cPrefixo+"JND4CON" )

		// Trata até 6 conjuntos de marcacoes
		If lCustom .And. GdFieldPos( cPrefixo+"ENTRA5" ) > 0
			nE5		:= GdFieldPos( cPrefixo+"ENTRA5" )
			nS5		:= GdFieldPos( cPrefixo+"SAIDA5" )
			nI4		:= GdFieldPos( cPrefixo+"HRSINT4" )
			nI4c	:= GdFieldPos( cPrefixo+"INTERV4" )
			nHr5	:= GdFieldPos( cPrefixo+"HRSTRA5" )
			nJn5	:= GdFieldPos( cPrefixo+"JND5CON" )
			If nColsMarc == 6
				nE6		:= GdFieldPos( cPrefixo+"ENTRA6" )
				nS6		:= GdFieldPos( cPrefixo+"SAIDA6" )
				nI5		:= GdFieldPos( cPrefixo+"HRSINT5" )
				nI5c	:= GdFieldPos( cPrefixo+"INTERV5" )
				nHr6	:= GdFieldPos( cPrefixo+"HRSTRA6" )
				nJn6	:= GdFieldPos( cPrefixo+"JND6CON" )
			EndIf
		Else
			lCustom 	:= .F.
		EndIf
	
		dS1		:= IF( nS1 > 0 .and. nE1 > 0 .and. aCols[ n , nS1 ] >= aCols[ n , nE1 ] , dE1 , dE1 + 1 )
		dS1		:= IF( nS1 > 0 .and. nE1 > 0 .and. nJn1 .and. aCols[ n , nS1 ] >= aCols[ n , nE1 ] .and. aCols[ n , nJn1 ] == "S", dS1 + 1 , dS1 )
		dE2		:= IF( nE2 > 0 .and. nS1 > 0 .and. aCols[ n , nE2 ] >= aCols[ n , nS1 ] , dS1 , dS1 + 1 )
		dS2		:= IF( nS2 > 0 .and. nE2 > 0 .and. aCols[ n , nS2 ] >= aCols[ n , nE2 ] , dE2 , dE2 + 1 )
		dS2		:= IF( nS2 > 0 .and. nE2 > 0 .and. nJn2 > 0 .and. aCols[ n , nS2 ] >= aCols[ n , nE2 ] .and. aCols[ n , nJn2 ] == "S", dS2 + 1 , dS2 )
		dE3		:= IF( nE3 > 0 .and. nS2 > 0 .and. aCols[ n , nE3 ] >= aCols[ n , nS2 ] , dS2 , dS2 + 1 )
		dS3		:= IF( nS3 > 0 .and. nE3 > 0 .and. aCols[ n , nS3 ] >= aCols[ n , nE3 ] , dE3 , dE3 + 1 )
		dS3		:= IF( nS3 > 0 .and. nE3 > 0 .and. nJn3 > 0 .and. aCols[ n , nS3 ] >= aCols[ n , nE3 ] .and. aCols[ n , nJn3 ] == "S", dS3 + 1 , dS3 )
		dE4		:= IF( nE4 > 0 .and. nS3 > 0 .and. aCols[ n , nE4 ] >= aCols[ n , nS3 ] , dS3 , dS3 + 1 )
		dS4		:= IF( nS4 > 0 .and. nE4 > 0 .and. aCols[ n , nS4 ] >= aCols[ n , nE4 ] , dE4 , dE4 + 1 )
		dS4		:= IF( nS4 > 0 .and. nE4 > 0 .and. nJn4 > 0 .and. aCols[ n , nS4 ] >= aCols[ n , nE4 ] .and. aCols[ n , nJn4 ] == "S", dS4 + 1 , dS4 )

		If lCustom
			dE5		:= IF( nE4 > 0 .and. nS4 > 0 .and. aCols[ n , nE5 ] >= aCols[ n , nS4 ] , dS4 , dS4 + 1 )
			dS5		:= IF( nS5 > 0 .and. nE5 > 0 .and. aCols[ n , nS5 ] >= aCols[ n , nE5 ] , dE5 , dE5 + 1 )
			dS5		:= IF( nS5 > 0 .and. nE5 > 0 .and. nJn5 > 0 .and. aCols[ n , nS5 ] >= aCols[ n , nE5 ] .and. aCols[ n , nJn5 ] == "S", dS5 + 1 , dS5 )
			If nColsMarc == 6
				dE6		:= IF( nE5 > 0 .and. nS4 > 0 .and. aCols[ n , nE5 ] >= aCols[ n , nS4 ] , dS4 , dS4 + 1 )
				dS6		:= IF( nS6 > 0 .and. nE6 > 0 .and. aCols[ n , nS6 ] >= aCols[ n , nE6 ] , dE6 , dE6 + 1 )
				dS6		:= IF( nS6 > 0 .and. nE6 > 0 .and. nJn6 > 0 .and. aCols[ n , nS6 ] >= aCols[ n , nE6 ] .and. aCols[ n , nJn6 ] == "S", dS6 + 1 , dS6 )
			EndIf
		EndIf
	
	ElseIF ( cObj == "MB" )
		
		dS1 := IF( IF( cAlias == "SP2" , GetMemVar( "P2_SAIDA1" ) >= GetMemVar( "P2_ENTRA1" ) , GetMemVar( "PJ_SAIDA1" ) >= GetMemVar( "PJ_ENTRA1" ) ) , dE1 , dE1 + 1 )
		dS1 := IF( IF( cAlias == "SP2" , GetMemVar( "P2_SAIDA1" ) >= GetMemVar( "P2_ENTRA1" ) .and. GetMemVar( "P2_JND1CON" ) == "S" , GetMemVar( "PJ_SAIDA1" ) >= GetMemVar( "PJ_ENTRA1" ) .and. GetMemVar( "PJ_JND1CON" ) == "S" ) , dS1 + 1 , dS1 )
		dE2 := IF( IF( cAlias == "SP2" , GetMemVar( "P2_ENTRA2" ) >= GetMemVar( "P2_SAIDA1" ) , GetMemVar( "PJ_SAIDA1" ) >= GetMemVar( "PJ_ENTRA1" ) ) , dS1 , dS1 + 1 )
		dS2 := IF( IF( cAlias == "SP2" , GetMemVar( "P2_SAIDA2" ) >= GetMemVar( "P2_ENTRA2" ) , GetMemVar( "PJ_SAIDA1" ) >= GetMemVar( "PJ_ENTRA1" ) ) , dE2 , dE2 + 1 )
		dS2 := IF( IF( cAlias == "SP2" , GetMemVar( "P2_SAIDA2" ) >= GetMemVar( "P2_ENTRA2" ) .and. GetMemVar( "P2_JND2CON" ) == "S" , GetMemVar( "PJ_SAIDA1" ) >= GetMemVar( "PJ_ENTRA1" ) .and. GetMemVar( "PJ_JND2CON" ) == "S" ) , dS2 + 1 , dS2 )
		dE3 := IF( IF( cAlias == "SP2" , GetMemVar( "P2_ENTRA3" ) >= GetMemVar( "P2_SAIDA2" ) , GetMemVar( "PJ_SAIDA1" ) >= GetMemVar( "PJ_ENTRA1" ) ) , dS2 , dS2 + 1 )
		dS3 := IF( IF( cAlias == "SP2" , GetMemVar( "P2_SAIDA3" ) >= GetMemVar( "P2_ENTRA3" ) , GetMemVar( "PJ_SAIDA1" ) >= GetMemVar( "PJ_ENTRA1" ) ) , dE3 , dE3 + 1 )
		dS3 := IF( IF( cAlias == "SP2" , GetMemVar( "P2_SAIDA3" ) >= GetMemVar( "P2_ENTRA3" ) .and. GetMemVar( "P2_JND3CON" ) == "S" , GetMemVar( "PJ_SAIDA1" ) >= GetMemVar( "PJ_ENTRA1" ) .and. GetMemVar( "PJ_JND3CON" ) == "S" ) , dS3 + 1 , dS3 )
		dE4 := IF( IF( cAlias == "SP2" , GetMemVar( "P2_ENTRA4" ) >= GetMemVar( "P2_SAIDA3" ) , GetMemVar( "PJ_SAIDA1" ) >= GetMemVar( "PJ_ENTRA1" ) ) , dS3 , dS3 + 1 )
		dS4 := IF( IF( cAlias == "SP2" , GetMemVar( "P2_SAIDA4" ) >= GetMemVar( "P2_ENTRA4" ) , GetMemVar( "PJ_SAIDA1" ) >= GetMemVar( "PJ_ENTRA1" ) ) , dE4 , dE4 + 1 )
		dS4 := IF( IF( cAlias == "SP2" , GetMemVar( "P2_SAIDA4" ) >= GetMemVar( "P2_ENTRA4" ) .and. GetMemVar( "P2_JND4CON" ) == "S" , GetMemVar( "PJ_SAIDA1" ) >= GetMemVar( "PJ_ENTRA1" ) .and. GetMemVar( "PJ_JND4CON" ) == "S" ) , dS4 + 1 , dS4 )
	
	ElseIF ( cObj == "DB" )
	
		dS1 := (cAlias)->(IF( &(cPrefixo+"SAIDA1") >= &(cPrefixo+"ENTRA1") ,dE1 , dE1 + 1 ))
		dS1 := (cAlias)->(IF( &(cPrefixo+"SAIDA1") >= &(cPrefixo+"ENTRA1") .and. &(cPrefixo+"JND1CON") == "S" ,dS1 + 1 , dS1 ))
		dE2 := (cAlias)->(IF( &(cPrefixo+"ENTRA2") >= &(cPrefixo+"SAIDA1") ,dS1 , dS1 + 1 ))
		dS2 := (cAlias)->(IF( &(cPrefixo+"SAIDA2") >= &(cPrefixo+"ENTRA2") ,dE2 , dE2 + 1 ))
		dS2 := (cAlias)->(IF( &(cPrefixo+"SAIDA2") >= &(cPrefixo+"ENTRA2") .and. &(cPrefixo+"JND1CON") == "S" ,dS2 + 1 , dS2 ))
		dE3 := (cAlias)->(IF( &(cPrefixo+"ENTRA3") >= &(cPrefixo+"SAIDA2") ,dS2 , dS2 + 1 ))
		dS3 := (cAlias)->(IF( &(cPrefixo+"SAIDA3") >= &(cPrefixo+"ENTRA3") ,dE3 , dE3 + 1 ))
		dS3 := (cAlias)->(IF( &(cPrefixo+"SAIDA3") >= &(cPrefixo+"ENTRA3") .and. &(cPrefixo+"JND1CON") == "S" ,dS3 + 1 , dS3 ))
		dE4 := (cAlias)->(IF( &(cPrefixo+"ENTRA4") >= &(cPrefixo+"SAIDA3") ,dS3 , dS3 + 1 ))
		dS4 := (cAlias)->(IF( &(cPrefixo+"SAIDA4") >= &(cPrefixo+"ENTRA4") ,dE4 , dE4 + 1 ))
		dS4 := (cAlias)->(IF( &(cPrefixo+"SAIDA4") >= &(cPrefixo+"ENTRA4") .and. &(cPrefixo+"JND1CON") == "S" ,dS4 + 1 , dS4 ))
	
	EndIF	
	
	IF cTipo == "H"
		IF cObj == "GD"
			IF cInt == "1"
				nHoras := fCalHoras( dE1 , aCols[ n , nE1 ] , dS1 , aCols[ n , nS1 ] , NIL , NIL , If(lAdNotHr, .F., lHnotTab) , dE1 , NIL , nIniHnot , nFimHnot , nMinHnot )
			ElseIF cInt == "2"
				nHoras := fCalHoras( dE2 , aCols[ n , nE2 ] , dS2 , aCols[ n , nS2 ] , NIL , NIL , If(lAdNotHr, .F., lHnotTab) , dE2 , NIL , nIniHnot , nFimHnot , nMinHnot )
			ElseIF cInt == "3" .And. nE3 > 0 .And. nS3 > 0
				nHoras := fCalHoras( dE3 , aCols[ n , nE3 ] , dS3 , aCols[ n , nS3 ] , NIL , NIL , If(lAdNotHr, .F., lHnotTab) , dE3 , NIL , nIniHnot , nFimHnot , nMinHnot )
			ElseIF cInt == "4" .And. nE4 > 0 .And. nS4 > 0
				nHoras := fCalHoras( dE4 , aCols[ n , nE4 ] , dS4 , aCols[ n , nS4 ] , NIL , NIL , If(lAdNotHr, .F., lHnotTab) , dE4 , NIL , nIniHnot , nFimHnot , nMinHnot )
			EndIF	

			If lCustom
				If cInt == "5"
					nHoras := fCalHoras( dE5 , aCols[ n , nE5 ] , dS5 , aCols[ n , nS5 ] , NIL , NIL , lHnotTab , dE5 , NIL , nIniHnot , nFimHnot , nMinHnot )
				EndIf
				If nColsMarc == 6 .And. cInt == "6"
					nHoras := fCalHoras( dE6 , aCols[ n , nE6 ] , dS6 , aCols[ n , nS6 ] , NIL , NIL , lHnotTab , dE6 , NIL , nIniHnot , nFimHnot , nMinHnot )
				EndIf
			EndIf
		ElseIF cObj == "MB"
			IF cAlias == "SP2"
				IF cInt == "1"
					nHoras := fCalHoras( dE1 , GetMemVar( "P2_ENTRA1" ) , dS1 , GetMemVar( "P2_SAIDA1" ) , NIL , NIL , lHnotTab , dE1 ,NIL , nIniHnot , nFimHnot , nMinHnot )
				ElseIF cInt == "2"
					nHoras := fCalHoras( dE2 , GetMemVar( "P2_ENTRA2" ) , dS2 , GetMemVar( "P2_SAIDA2" ) , NIL , NIL , lHnotTab , dE2 ,NIL , nIniHnot , nFimHnot , nMinHnot )
				ElseIF cInt == "3"
					nHoras := fCalHoras( dE3 , GetMemVar( "P2_ENTRA3" ) , dS3 , GetMemVar( "P2_SAIDA3" ) , NIL , NIL , lHnotTab , dE3 ,NIL , nIniHnot , nFimHnot , nMinHnot )
				ElseIF cInt == "4"
					nHoras := fCalHoras( dE4 , GetMemVar( "P2_ENTRA4" ) , dS4 , GetMemVar( "P2_SAIDA4" ) , NIL , NIL , lHnotTab , dE4 ,NIL , nIniHnot , nFimHnot , nMinHnot )
				EndIF
			ElseIF cAlias == "SPJ"
				IF cInt == "1"
					nHoras := fCalHoras( dE1 , GetMemVar( "PJ_ENTRA1" ) , dS1 , GetMemVar( "PJ_SAIDA1" ) , NIL , NIL , lHnotTab , dE1 , NIL , nIniHnot , nFimHnot , nMinHnot )
				ElseIF cInt == "2"
					nHoras := fCalHoras( dE2 , GetMemVar( "PJ_ENTRA2" ) , dS2 , GetMemVar( "PJ_SAIDA2" ) , NIL , NIL , lHnotTab , dE2 , NIL , nIniHnot , nFimHnot , nMinHnot )
				ElseIF cInt == "3"
					nHoras := fCalHoras( dE3 , GetMemVar( "PJ_ENTRA3" ) , dS3 , GetMemVar( "PJ_SAIDA3" ) , NIL , NIL , lHnotTab , dE3 , NIL , nIniHnot , nFimHnot , nMinHnot )
				ElseIF cInt == "4"
					nHoras := fCalHoras( dE4 , GetMemVar( "PJ_ENTRA4" ) , dS4 , GetMemVar( "PJ_SAIDA4" ) , NIL , NIL , lHnotTab , dE4 , NIL , nIniHnot , nFimHnot , nMinHnot )
				EndIF
			EndIF
		ElseIF cObj == "DB"
			IF cInt == "1"
				nHoras := (cAlias)->(fCalHoras(dE1,&(cPrefixo+"ENTRA1"),dS1,&(cPrefixo+"SAIDA1"),NIL,NIL,lHnotTab,dE1,NIL,nIniHnot,nFimHnot,nMinHnot))
			ElseIF cInt == "2"
				nHoras := (cAlias)->(fCalHoras(dE2,&(cPrefixo+"ENTRA2"),dS2,&(cPrefixo+"SAIDA2"),NIL,NIL,lHnotTab,dE2,NIL,nIniHnot,nFimHnot,nMinHnot))
			ElseIF cInt == "3"
				nHoras := (cAlias)->(fCalHoras(dE3,&(cPrefixo+"ENTRA3"),dS3,&(cPrefixo+"SAIDA3"),NIL,NIL,lHnotTab,dE3,NIL,nIniHnot,nFimHnot,nMinHnot))
			ElseIF cInt == "4"
				nHoras := (cAlias)->(fCalHoras(dE4,&(cPrefixo+"ENTRA4"),dS4,&(cPrefixo+"SAIDA4"),NIL,NIL,lHnotTab,dE4,NIL,nIniHnot,nFimHnot,nMinHnot))
			EndIF
		EndIF
	ElseIF cTipo == "I"
		IF cInt == "1" .or. cVar $ ( cPrefixo+"INTERV1" )
			IF cObj == "GD"
				IF aCols[ n , nI1c ] == "S"
					nHoras := fCalHoras( dS1 , aCols[ n , nS1 ] , dE2 , aCols[ n , nE2 ] , NIL , NIL , If(lAdNotHr, .F., lHnotTbI) , dE1 , NIL , nIniHnot , nFimHnot , nMinHnot )
				EndIF
			ElseIF cObj == "MB"
				IF IF( cAlias == "SP2" , GetMemVar( "P2_INTERV1" ) , GetMemVar( "PJ_INTERV1" ) ) == "S"
					nHoras := fCalHoras(dS1,IF(cAlias=="SP2",GetMemVar( "P2_SAIDA1" ),GetMemVar( "PJ_SAIDA1" )),dE2,IF(cAlias=="SP2",GetMemVar( "P2_ENTRA2" ),GetMemVar( "PJ_ENTRA2" )),0,0,lHnotTbI,dE1,NIL,nIniHnot,nFimHnot,nMinHnot)
				EndIF
			ElseIF cObj == "DB"
				IF (cAlias)->( &(cPrefixo+"INTERV1") == "S" )
					nHoras := (cAlias)->(fCalHoras(dS1,&(cPrefixo+"SAIDA1"),dE2,&(cPrefixo+"ENTRA2"),NIL,NIL,lHnotTbI,dE1,NIL,nIniHnot,nFimHnot,nMinHnot))
				EndIF		
			EndIF
		ElseIF (nI2c > 0 .And. (cInt == "2" .Or. cVar $ ( cPrefixo+"INTERV2" ))) .Or. (cObj == "DB" .And. cInt == "2")
			IF cObj == "GD"
				IF aCols[ n, nI2c ] == "S" .And. nS2 > 0 .And. nE3 > 0
					nHoras := fCalHoras( dS2 , aCols[ n , nS2 ] , dE3 , aCols[ n , nE3 ] , 0 , 0 , lHnotTbI , dE2 , NIL , nIniHnot , nFimHnot , nMinHnot )
				EndIF
			ElseIF cObj == "MB"
				IF IF( cAlias == "SP2" , GetMemVar( "P2_INTERV2" ) , GetMemVar( "PJ_INTERV2" ) ) == "S"
					nHoras := fCalHoras(dS2,IF(cAlias=="SP2",GetMemVar( "P2_SAIDA2" ),GetMemVar( "PJ_SAIDA2" )),dE3,IF(cAlias=="SP2",GetMemVar( "P2_ENTRA3" ),GetMemVar( "PJ_ENTRA3" )),NIL,NIL,lHnotTbI,dE2,NIL,nIniHnot,nFimHnot,nMinHnot)
				EndIF
			ElseIF cObj == "DB"
				IF (cAlias)->( &(cPrefixo+"INTERV2") == "S" )
					nHoras := (cAlias)->(fCalHoras(dS2,&(cPrefixo+"SAIDA2"),dE3,&(cPrefixo+"ENTRA3"),NIL,NIL,lHnotTbI,dE2,NIL,nIniHnot,nFimHnot,nMinHnot))
				EndIF	
			EndIF
		ElseIF nI3c > 0 .And. (cInt == "3" .or. cVar $ ( cPrefixo+"INTERV3" )) .Or. (cObj == "DB" .And. cInt == "3")
			IF cObj == "GD"
				IF aCols[ n , nI3c ] == "S" .And. nS3 > 0 .And. nE4 > 0
					nHoras := fCalHoras( dS3 , aCols[ n , nS3 ] , dE4 , aCols[ n , nE4 ] , NIL , NIL , lHnotTbI , dE3 , NIL , nIniHnot , nFimHnot , nMinHnot )
				EndIF	
			ElseIF cObj == "MB"
				IF IF( cAlias == "SP2" , GetMemVar( "P2_INTERV3" ) , GetMemVar( "PJ_INTERV3" ) ) == "S"
					nHoras := fCalHoras(dS3,IF(cAlias=="SP2",GetMemVar( "P2_SAIDA3" ),GetMemVar( "PJ_SAIDA3" )),dE4,IF(cAlias=="SP2",GetMemVar( "P2_ENTRA4" ),GetMemVar( "PJ_ENTRA4" )),NIL,NIL,lHnotTbI,dE3,NIL,nIniHnot,nFimHnot,nMinHnot)
				EndIF    
			ElseIF cObj == "DB"
				IF (cAlias)->( &(cPrefixo+"INTERV3") == "S" )
					nHoras := (cAlias)->(fCalHoras(dS3,&(cPrefixo+"SAIDA3"),dE4,&(cPrefixo+"ENTRA4"),NIL,NIL,lHnotTbI,dE3,NIL,nIniHnot,nFimHnot,nMinHnot))
				EndIF
			EndIF
		ElseIF lCustom .And. cInt == "4" .or. cVar $ ( cPrefixo+"INTERV4" )
			IF cObj == "GD"
				IF aCols[ n , nI4c ] == "S"
					nHoras := fCalHoras( dS4 , aCols[ n , nS4 ] , dE5 , aCols[ n , nE5 ] , NIL , NIL , lHnotTbI , dE4 , NIL , nIniHnot , nFimHnot , nMinHnot )
				EndIF	
			EndIf
		ElseIF lCustom .And. cInt == "5" .or. cVar $ ( cPrefixo+"INTERV5" )
			IF cObj == "GD"
				IF aCols[ n , nI5c ] == "S"
					nHoras := fCalHoras( dS5 , aCols[ n , nS5 ] , dE6 , aCols[ n , nE6 ] , NIL , NIL , lHnotTbI , dE5 , NIL , nIniHnot , nFimHnot , nMinHnot )
				EndIF	
			EndIf
		EndIF
	ElseIF cTipo == "T"
		IF cObj == "GD"
	 		nHoras := If(nI1 > 0, SomaHoras( nHoras , aCols[ n , nI1  ] ), nHoras )
			nHoras := If(nI2 > 0, SomaHoras( nHoras , aCols[ n , nI2  ] ), nHoras )
			nHoras := If(nI3 > 0, SomaHoras( nHoras , aCols[ n , nI3  ] ), nHoras )
			nHoras := If(nHr1 > 0, SomaHoras( nHoras , aCols[ n , nHr1 ] ), nHoras )
			nHoras := If(nHr2 > 0, SomaHoras( nHoras , aCols[ n , nHr2 ] ), nHoras )
			nHoras := If(nHr3 > 0, SomaHoras( nHoras , aCols[ n , nHr3 ] ), nHoras )
			nHoras := If(nHr4 > 0, SomaHoras( nHoras , aCols[ n , nHr4 ] ), nHoras )

			If lCustom
				nHoras := If(nI4 > 0, SomaHoras( nHoras , aCols[ n , nI4  ] ), nHoras )
				If nColsMarc == 5
					nHoras := If(nHr5 > 0, SomaHoras( nHoras , aCols[ n , nHr5 ] ), nHoras )
				ElseIf nColsMarc == 6
					nHoras := If(nI5 > 0, SomaHoras( nHoras , aCols[ n , nI5  ] ), nHoras )
					nHoras := If(nHr6 > 0, SomaHoras( nHoras , aCols[ n , nHr6 ] ), nHoras )
				EndIf
			EndIf
		ElseIF cObj == "DB"
	 		nHoras := SomaHoras( nHoras , (cAlias)->(IF(cAlias=="SP2",P2_HRINTV1,PJ_HRSINT1) ) )
			nHoras := SomaHoras( nHoras , (cAlias)->(IF(cAlias=="SP2",P2_HRINTV2,PJ_HRSINT2) ) )
			nHoras := SomaHoras( nHoras , (cAlias)->(IF(cAlias=="SP2",P2_HRINTV3,PJ_HRSINT3) ) )
			nHoras := SomaHoras( nHoras , (cAlias)->( &(cPrefixo+"HRSTRAB") ) )
			nHoras := SomaHoras( nHoras , (cAlias)->( &(cPrefixo+"HRSTRA2") ) )
			nHoras := SomaHoras( nHoras , (cAlias)->( &(cPrefixo+"HRSTRA3") ) )
			nHoras := SomaHoras( nHoras , (cAlias)->( &(cPrefixo+"HRSTRA4") ) )
		ElseIF cObj == "MB"
	 		nHoras := SomaHoras( nHoras , IF( cAlias == "SP2",GetMemVar( "P2_HRINTV1" ),GetMemVar( "PJ_HRSINT1" ) ) )
			nHoras := SomaHoras( nHoras , IF( cAlias == "SP2",GetMemVar( "P2_HRINTV2" ),GetMemVar( "PJ_HRSINT2" ) ) )
			nHoras := SomaHoras( nHoras , IF( cAlias == "SP2",GetMemVar( "P2_HRINTV3" ),GetMemVar( "PJ_HRSINT3" ) ) )
			nHoras := SomaHoras( nHoras , IF( cAlias == "SP2",GetMemVar( "P2_HRSTRAB" ),GetMemVar( "PJ_HRSTRAB" ) ) )
			nHoras := SomaHoras( nHoras , IF( cAlias == "SP2",GetMemVar( "P2_HRSTRA2" ),GetMemVar( "PJ_HRSTRA2" ) ) )
			nHoras := SomaHoras( nHoras , IF( cAlias == "SP2",GetMemVar( "P2_HRSTRA3" ),GetMemVar( "PJ_HRSTRA3" ) ) )
			nHoras := SomaHoras( nHoras , IF( cAlias == "SP2",GetMemVar( "P2_HRSTRA4" ),GetMemVar( "PJ_HRSTRA4" ) ) )
		EndIF
	EndIF

End Sequence
	
Return(__TimeSum(__TimeSum( nHoras, 0 ), 0) )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³__Excecoes ³Autor ³ Equipe Advanced RH    ³ Data ³19/04/2001³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Carrega a Tabela de Exce‡”es                	            ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³__Excecoes(aArray,cTurno,cCC,cMat,dData,nRecno,aExcePer)	³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parƒmetros³< Vide Parametros Formais >							        ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Obs.:     ³Matida a Funcao Apenas Para Compatibilidade com os Programas³
³          ³Especificos que ja Estao Sendo Utilizados nos Cliente.  Reco³
³          ³mendado o uso da GetExcecoes()								³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³SIGAPON                                                     ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function __Excecoes(aArray,cTurno,cCC,cMat,dData,nRecno,aExcePer)

Local cFil 		:= SRA->RA_MAT
Local lExcecao	:= .F.

DEFAULT aArray		:= {}
DEFAULT cTurno		:= SRA->RA_TNOTRAB
DEFAULT cCC			:= SRA->RA_CC
DEFAULT cMat		:= SRA->RA_MAT
DEFAULT dData		:= dDataBase
DEFAULT nRecno		:= 0
DEFAULT aExceper	:= {}	

lExcecao := GetExcecoes(	@aArray		,; // 01 - Array a ser Carregado com as Exce‡oes
							cTno		,; // 02 - Turno de Trabalho do Funcion rio
							cCC			,; // 03 - Centro de Custo do Funcion rio
							cFil		,; // 04 - Filial do Funcionario
							cMat		,; // 05 - Matricula do Funcion rio
							dData		,; // 06 - Data a ser pesquisada
							""			,; // 07 - Tipo do Dia Para a Excecao
							aExcePer	,; // 08 - Array com Todas as Exce‡oes do Periodo
							NIL			,; // 09 - Periodo Inicial Para Carga de aExcePer
							NIL			,; // 10 - Periodo Final   Para Carga de aExcePer
							.F.			,; // 11 - True para Carregar Todas as Excecoes do Periodo
							.F.			 ; // 12 - Mostrar Dialogo na IndRegua
						)

Return( lExcecao )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³GetExcecoes³Autor ³ Marinaldo de Jesus    ³ Data ³19/04/2001³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Carrega a Tabela de Exce‡”es                	            ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³GetExcecoes()												³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parƒmetros³< Vide Parametros Formais >							        ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Obs.:     ³Quando a procura For Feita em Arquivo (SP2) ira posicionar o³
³          ³Recno Correspondente `a Excecao.                            ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³SIGAPON                                                     ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function GetExcecoes(	aArray		,; // 01 - Array a ser Carregado com as Exce‡oes
						cTno		,; // 02 - Turno de Trabalho do Funcion rio
						cCC			,; // 03 - Centro de Custo do Funcion rio
						cFil		,; // 04 - Filial do Funcionario
						cMat		,; // 05 - Matricula do Funcion rio
						dData		,; // 06 - Data a ser pesquisada
						cTipoDia 	,; // 07 - Tipo do Dia Para a Excecao             					
						aExcePer	,; // 08 - Array com Todas as Exce‡oes do Periodo
						dPerIni		,; // 09 - Periodo Inicial Para Carga de aExcePer
						dPerFim		,; // 10 - Periodo Final   Para Carga de aExcePer 
						lPeriodo	,; // 11 - True para Carregar Todas as Excecoes do Periodo
						lShowDialog ,; // 12 - Mostrar Dialogo na IndRegua
						lForceGoto	,; // 13 - Se, quando pesquisa em array, forca o posicionamento no SP2	
						lBusca		 ;
					 )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Variaveis de Inicializacao Obrigatoria					  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Local aExceTip		:= {}
Local cRegra		:= SRA->RA_REGRA
Local cSpcTipoDia	:= Space( GetSx3Cache( "P2_TIPODIA" , "X3_TAMANHO" ) ) 
Local lExcecao		:= .F.
Local lArray		:= .F.
Local nFornY		:= RetCondExce()

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Variaveis que serao inicializadas no Corpo da Funcao		  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Local aString
Local baScan
Local bCond
Local bLoop
Local bExce
Local cArqInd
Local nFornX
Local nX
Local nY
Local nI
Local nPos
Local nRecno
Local nLenExcePe
Local aTransf := {}

Static	cIndKeyExc
Static	nOrderExce

DEFAULT aArray		:= {}
DEFAULT cTno		:= SRA->RA_TNOTRAB
DEFAULT cCC			:= SRA->RA_CC
DEFAULT cFil		:= SRA->RA_FILIAL
DEFAULT cMat		:= SRA->RA_MAT
DEFAULT dData		:= dDataBase       
DEFAULT cTipoDia	:= cSpcTipoDia
DEFAULT aExcePer	:= {}
DEFAULT dPerIni		:= dDataBase
DEFAULT dPerFim		:= dDataBase
DEFAULT lPeriodo	:= .F.
DEFAULT lShowDialog := .F.
DEFAULT lForceGoto	:= .F.
DEFAULT lBusca		:= .T.

Begin Sequence
	
	If(Empty(aExcePer) .And. lBusca, (;
		PonSitPer(cFil, cMat, dPerIni, dPerFim, NIL, @aTransf, .F.),;
		GetExceTop(cFil, cMat, cCC, aTurnos, dPerIni, dPerFim, @aExcePer, aTransf)), NIL)
	
	If (( ValType( aExcePer ) == "A") .And. (lArray := ((nLenExcePe := Len(aExcePer)) > 0 )))  //Pesquizando em Array
		
		baScan := { |x| x[2] + Dtos( x[3] ) + Dtos( x[4] ) == aExcePer[ nX , 35 ] + Dtos( aExceper[ nX , 02 ] ) + Dtos( aExceper[ nX , 03 ] ) }
		
		bCond := { |x| ( x[1] + x[6] + x[5] + x[4] + Dtos( x[2] ) ) == aString[1]  .or. ;
					   ( x[1] + x[6] + x[5] + x[4]                ) == aString[2]     	;
				 }
		
		bExce := { |e| dData >= aExcePer[e,2] .and. dData <= IF(!Empty(aExcePer[e,3]),aExcePer[e,3],aExcePer[e,2]) }
		
	   	bLoop := { |e,f| IF( f == "L" , aExcePer[e,1] + aExcePer[e,6] + aExcePer[e,5] + aExcePer[e,4] != aString[2] ,;
						   			    aExcePer[e,1] + aExcePer[e,6] + aExcePer[e,5] + aExcePer[e,4] == aString[2]  ;
							)																						 ;
	   			 }
		
		For nI := 1 To nLenExcePe
			If (dData >= aExcePer[nI,2] .And. dData <= aExcePer[nI,3]) .And. cCC <> aExcePer[nI,5]
				cCC := aExcePer[nI,5]
			EndIf
		Next
		
		For nY := 1 To nFornY
			
			aString  := RetCondExce( cFil , cMat , cTno , cCC , dData , nY )
			
			IF ( ( nPos := aScan( aExcePer, bCond ) ) > 0 )
				nFornX  := ( nFornX := Len( aExcePer ) )
				For nX := nPos To nFornX
					IF ( nX > nFornX )
						Exit
					EndIF	
					IF Eval( bLoop , nX , "L" ) 
						IF Eval( bLoop , nFornX , "F" ) .and. Eval( bExce , nFornX )
							lExcecao := .T.
							IF ( Empty( aExceTip ) .or. ( aScan( aExceTip , baScan ) == 0 ) )
								aAdd( aExceTip , {   			   			 ;
													nFornX		   			,;	//01 -> Indice da Excecao em aExcePer
													aExcePer[ nFornX , 35 ]	,;	//02 -> Tipo do Dia Para Excecao
													aExceper[ nFornX , 02 ]	,;	//03 -> Data Inicial da Excecao
													aExceper[ nFornX , 03 ] ,;	//04 -> Data Final da Excecao
													aExceper[ nFornX , 01 ] ,;	//05 -> Filial
													aExceper[ nFornX , 06 ] ,;	//06 -> Matricula do Funcionario
													aExceper[ nFornX , 05 ] ,;	//07 -> Centro de Custo
													aExceper[ nFornX , 04 ]	,;	//08 -> Turno 
													aExcePer[ nFornX , 27 ]  ;	//09 -> Recno
												  };
									 )
								--nFornX	 
							EndIF
						Else
							--nFornX
						EndIF
						Loop
					EndIF
					IF Eval( bExce , nX )
						lExcecao := .T.
						IF ( Empty( aExceTip ) .or. ( aScan( aExceTip , baScan ) == 0 ) )
							aAdd( aExceTip , {   					 ;
												nX					,;	//01 -> Indice da Excecao em aExcePer
												aExcePer[ nX , 35 ]	,;	//02 -> Tipo do Dia Para Excecao
												aExceper[ nX , 02 ]	,;	//03 -> Data Inicial da Excecao
												aExceper[ nX , 03 ] ,;	//04 -> Data Final da Excecao
												aExceper[ nX , 01 ] ,;	//05 -> Filial
												aExceper[ nX , 06 ] ,;	//06 -> Matricula do Funcionario
												aExceper[ nX , 05 ] ,;	//07 -> Centro de Custo
												aExceper[ nX , 04 ]	,;	//08 -> Turno 
												aExcePer[ nX , 27 ]  ;	//09 -> Recno
											   };
								 )
						EndIF
					EndIF
					IF Eval( bLoop , nFornX , "F" )  .and. Eval( bExce , nFornX )
						lExcecao := .T.
						IF ( Empty( aExceTip ) .or. ( aScan( aExceTip , baScan ) == 0 ) )
							aAdd( aExceTip , {   			   			 ;
												nFornX		   			,;	//01 -> Indice da Excecao em aExcePer
												aExcePer[ nFornX , 35 ]	,;	//02 -> Tipo do Dia Para Excecao
												aExceper[ nFornX , 02 ]	,;	//03 -> Data Inicial da Excecao
												aExceper[ nFornX , 03 ] ,;	//04 -> Data Final da Excecao
												aExceper[ nFornX , 01 ] ,;	//05 -> Filial
												aExceper[ nFornX , 06 ] ,;	//06 -> Matricula do Funcionario
												aExceper[ nFornX , 05 ] ,;	//07 -> Centro de Custo
												aExceper[ nFornX , 04 ]	,;	//08 -> Turno 
												aExcePer[ nFornX , 27 ]  ;	//09 -> Recno
											   };
								 )
							--nFornX	 
						EndIF
					Else
						--nFornX
					EndIF
				Next nX
			EndIF
			
		Next nY
		
	EndIF
	
End Sequence

lExcecao := .F.
IF !( lPeriodo )

	nPos := 0
	IF !Empty( aExceTip )

		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Procura Excecao sem o Tipo do Dia                            ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	   	baScan	:= { |e| (;
	   						(;
	   							e[5] +			;	//Filial
	   							e[6] +			;	//Matricula
	   							e[7] +			;	//Centro de Custo
	   							e[8] + 			;	//Turno
	   							e[2]			;	//Tipo do Dia
	   						);	
	   						==					;
							(;
								aString[2] +	;
								cSpcTipoDia		;
							);	
	   					 );
		   			 }
	
		For nY := 1 To nFornY
	
			aString := RetCondExce( cFil , cMat , cTno , cCC , dData , nY )
			IF ( ( nPos := aScan( aExceTip , baScan ) ) > 0 )
	        	Exit
	        EndIF
	
		Next nY
	
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Procura Excecao Expecifica para o Tipo do Dia                ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		IF ( ( nPos == 0 ) )
	    
		   	baScan	:= { |e| (;
		   						(;
		   							e[5] +			;	//Filial
		   							e[6] +			;	//Matricula
		   							e[7] +			;	//Centro de Custo
		   							e[8] +			;	//Turno
		   							e[2]			;	//Tipo do Dia
		   						);	
		   						==					;
		   						(;
		   							aString[2] +	;
		   							cTipoDia		;
		   						);	
		   					 );
			   			 }
		
			For nY := 1 To nFornY
		
				aString := RetCondExce( cFil , cMat , cTno , cCC , dData , nY )
				IF ( ( nPos := aScan( aExceTip , baScan ) ) > 0 )
		        	Exit
		        EndIF
		
			Next nY
	
		EndIF
		
	EndIF

	IF ( lExcecao := ( nPos > 0 ) )
	
		cTipoDia	:= aExceTip[ nPos , 02 ]
		nRecno      := aExceTip[ nPos , 09 ]
	
		IF !( lArray )
			IF ( SP2->( Recno() ) != nRecno )
				SP2->( dbGoto( nRecno ) )
			EndIF
		Else
			IF ( lForceGoto )
				IF ( SP2->( Recno() ) != nRecno )
					SP2->( dbGoto( nRecno ) )
				EndIF
			EndIF
			nPos := aExceTip[ nPos , 01 ]
		EndIF
	
		SP2->( fAddExce( @aArray , lArray , aExceper , nPos , dData , cRegra , nRecno ) )

	EndIF
	
ElseIF ( lPeriodo )

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Neste Ponto a Chamada devera ser Feita Pela Processa()       ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	SP2->( ProcRegua( RecCount() ) , dbGoTop() )

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Depura o Arquivo de Excecoes Carregando as Excecoes do Periodo³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	fDepuraSP2( @cArqInd , dPerIni , dPerFim , lShowDialog )

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Carrega as Excecoes do Periodo                             ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	aExcePer := {}
	While SP2->( !Eof() )
		IncProc(OemToAnsi(STR0060))	// 'Carregando as Exce‡”es do Per¡odo...'
		SP2->( fAddExce( @aExcePer , NIL , NIL , NIL , NIL , cRegra , Recno() ) )
		SP2->( dbSkip() )
	End While

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Restaura Indices do SP2 e Apaga Indice Temporario          ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	IF !Empty( cArqInd )
		RetIndex("SP2")
		SP2->( dbSetOrder( nOrderExce ) )
		fErase( cArqInd + OrdBagExt() )
	EndIF

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Carrega o Retorno da Funcao                                ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	lExcecao := ( Len( aExcePer ) > 0 )

EndIF

Return( lExcecao )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³RetCondExce	  ³ Autor ³Marinaldo de Jesus    ³ Data ³19/04/2001³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Retorna Array com Chaves para a Pesquisa das Excecoes          ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³RetCondExce( cFil , cMat , cTno , cCC , dData , nInd )		   ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³                                         					   ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³xRet ->	Qdo PCount() = 0 , Numero de Condicoes Existentes, caso³
³          ³       	Contrario, Array de 2 Posicoes contendo as Chaves  para³
³          ³       	a Pesquisa das Excecoes.                               ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	       ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³GetExcecoes()												   ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function RetCondExce( cFil , cMat , cTno , cCC , dData , nInd )

Local cSpcP2Mat	:= Space( GetSx3Cache( "P2_MAT    " , "X3_TAMANHO" ) ) 
Local cSpcP2Cc	:= Space( GetSx3Cache( "P2_CC     " , "X3_TAMANHO" ) ) 
Local cSpcP2Tno	:= Space( GetSx3Cache( "P2_TURNO  " , "X3_TAMANHO" ) ) 
Local xRet		:= NIL

IF Empty( PCount() )
	xRet := 8.00
Else
	xRet := Array( 02 )
	IF nInd == 1		//Pesquisando Mat + CC + Turno
		xRet[1]		:=  ( cFil + cMat + cCC + cTno + Dtos( dData ) )
		xRet[2]		:=  ( cFil + cMat + cCC + cTno )
	ElseIF nInd == 2	//Pesquisando Mat + CC + şşşşş
		xRet[1]		:=	( cFil + cMat + cCC + cSpcP2Tno + Dtos( dData ) )
		xRet[2]		:=  ( cFil + cMat + cCC + cSpcP2Tno )
	ElseIF nInd == 3	//Pesquisando Mat + şş + Turno
		xRet[1]		:=	( cFil + cMat + cSpcP2Cc + cTno + Dtos( dData ) )
		xRet[2]		:=  ( cFil + cMat + cSpcP2Cc + cTno )
	ElseIF nInd == 4	//Pesquisando Mat + şş + şşşşş
		xRet[1]		:=	( cFil + cMat + cSpcP2Cc + cSpcP2Tno + Dtos( dData ) )
		xRet[2]		:=  ( cFil + cMat + cSpcP2Cc + cSpcP2Tno )
	ElseIF nInd == 5	//Pesquisando şşş + CC + Turno
		xRet[1]		:=  ( cFil + cSpcP2Mat + cCC + cTno + Dtos( dData ) )
		xRet[2]		:=  ( cFil + cSpcP2Mat + cCC + cTno )
	ElseIF nInd == 6	//Pesquisando şşş + şş + Turno
		xRet[1]		:=  ( cFil + cSpcP2Mat + cSpcP2Cc + cTno + Dtos( dData ) )
	    xRet[2]		:=  ( cFil + cSpcP2Mat + cSpcP2Cc + cTno )
	ElseIF nInd == 7	//Pesquisando şşş + CC + şşşşş
		xRet[1]		:=  ( cFil + cSpcP2Mat + cCC + cSpcP2Tno + Dtos( dData ) ) 
	    xRet[2]		:=  ( cFil + cSpcP2Mat + cCC + cSpcP2Tno )
	ElseIF nInd == 8	//Pesquisando şşş + şş + şşşşş
		xRet[1]		:=  ( cFil + cSpcP2Mat + cSpcP2Cc + cSpcP2Tno + Dtos( dData ) )
		xRet[2]		:=  ( cFil + cSpcP2Mat + cSpcP2Cc + cSpcP2Tno )
	EndIF
EndIF
	
Return( xRet )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³GetExceTop ³Autor ³ Marinaldo de Jesus    ³ Data ³07/06/2001³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Carrega a Tabela de Exce‡”es                	            ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³GetExcecoes()												³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parƒmetros³< Vide Parametros Formais >							        ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Ponto Eletronico RDD TOPCONNECT                             ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function GetExceTop( cFil		,; //01 -> Filial
					 cMat 		,; //02 -> Matricula
					 cCc		,; //03 -> Centro de Custo
					 aTurnos	,; //04 -> Array com os Turnos do Funcionario
					 dPerIni	,; //05 -> Periodo Inicial
					 dPerFim	,; //06 -> Periodo Final
					 aArray  	,; //07 -> Array a ser carregado com as Excecoes
					 aTransf	 ; //08 -> Array de transferência
					)

Local aSvAlias  	:= GetArea()
Local lRet			:= .F.
Local baScan		:= { || NIL }
Local cPerIni		:= Dtos( dPerIni )
Local cPerFim		:= Dtos( dPerFim )
Local cRegra		:= SRA->RA_REGRA
Local cSpaceMat		:= Space( GetSx3Cache( "RA_MAT    " , "X3_TAMANHO" ) )
Local cSpaceCus 	:= Space( GetSx3Cache( "RA_CC     " , "X3_TAMANHO" ) )
Local cSpaceTur 	:= Space( GetSx3Cache( "RA_TNOTRAB" , "X3_TAMANHO" ) )
Local cQuery		:= ""
Local cQueryTrf		:= ""
Local cTno			:= ""
Local cAliasQuery	:= "__QSP2QRY"
Local cInitSqlName	:= InitSqlName("SP2")
Local nLenTurno		:= 0
Local nX			:= 0
Local nY			:= 0
Local nSvOrder		:= SP2->( IndexOrd() )
Local lTemTransf	:= .F.
Local nLenTransf	:= 0
Local nI			:= 0
Local cSpaceDel		:= " "

Static aStruSP2
Static cIndKeyExc
Static cQrySp2Fields
Static nOrderExce
Static nFieldsSP2
Static __oSt1
Static __oSTransf
Static __cEmpAux

DEFAULT cIndKeyExc	:= "P2_FILIAL+P2_MAT+P2_CC+P2_TURNO+DtoS(P2_DATA)+P2_TIPODIA"
DEFAULT nOrderExce	:= RetOrdem( "SP2" , cIndKeyExc )
DEFAULT aTransf		:= {}

lTemTransf := !Empty(aTransf)

If ( aStruSP2	== NIL )
	aStruSP2	:= SP2->( dbStruct() )
	nFieldsSP2	:= Len( aStruSP2 )
EndIf

If ( cQrySp2Fields == NIL )
	cQrySp2Fields := ""
	For nX := 1 To nFieldsSP2
		cQrySp2Fields += aStruSP2[ nX , 01 ] + ", "
	Next nX
EndIf

aArray := {}

If ( nOrderExce == nSvOrder )
	SP2->( dbSetOrder( nOrderExce ) )
EndIf    

baScan	:= { |x| x[1] ==  (cAliasQuery)->P2_FILIAL	.AND. ; //Filial
		  		 x[2] ==  (cAliasQuery)->P2_DATA	.AND. ; //Data De
				 x[3] ==  (cAliasQuery)->P2_DATAATE	.AND. ; //Data Ate
				 x[4] ==  (cAliasQuery)->P2_TURNO	.AND. ; //Turno
				 x[5] ==  (cAliasQuery)->P2_CC		.AND. ; //Centro de Custo
				 x[6] ==  (cAliasQuery)->P2_MAT		.AND. ; //Matricula
				 x[35] == (cAliasQuery)->P2_TIPODIA		  ; //Tipo do Dia Para Excecao
            }

nLenTurno := Len( aTurnos )
For nY := 1 To nLenTurno

	cTno	:= aTurnos[ nY , 01 ]
	
	If __oSt1 == Nil .or. ( __cEmpAux == Nil .or. __cEmpAux <> cEmpAnt )
		__cEmpAux   := cEmpAnt

		__oSt1 := FWPreparedStatement():New()

		cQuery	:= "SELECT "
		cQuery  += cQrySp2Fields
		cQuery	+= "R_E_C_N_O_ RECNO"
		cQuery	+= " FROM "
		cQuery	+= cInitSqlName
		cQuery	+= " WHERE "
		cQuery	+= "("
		cQuery	+=		"("
		cQuery	+= 			"("
		cQuery	+= 				"P2_FILIAL = ? AND P2_MAT = ? AND P2_CC = ? AND P2_TURNO = ? "
		cQuery	+= 			")"
		cQuery	+= 			" OR "
		cQuery	+= 			"("
		cQuery	+= 				"P2_FILIAL = ? AND P2_MAT = ? AND P2_CC = ? AND P2_TURNO = ? "
		cQuery	+= 			")"
		cQuery	+= 			" OR "
		cQuery	+= 			"("
		cQuery	+= 				"P2_FILIAL = ? AND P2_MAT = ? AND P2_CC = ? AND P2_TURNO = ? "
		cQuery	+=			")"
		cQuery	+=			" OR "
		cQuery	+= 			"("
		cQuery	+= 				"P2_FILIAL = ? AND P2_MAT = ? AND P2_CC = ? AND P2_TURNO = ? "
		cQuery	+=			")"
		cQuery	+=			" OR "
		cQuery	+= 			"("
		cQuery	+= 				"P2_FILIAL = ? AND P2_MAT = ? AND P2_CC = ? AND P2_TURNO = ? "
		cQuery	+= 			")"
		cQuery	+= 			" OR "
		cQuery	+= 			"("
		cQuery	+= 				"P2_FILIAL = ? AND P2_MAT = ? AND P2_CC = ? AND P2_TURNO = ? "
		cQuery	+= 			")"
		cQuery	+= 			" OR "
		cQuery	+= 			"("
		cQuery	+= 				"P2_FILIAL = ? AND P2_MAT = ? AND P2_CC = ? AND P2_TURNO = ? "
		cQuery	+= 			")"
		cQuery	+= 			" OR "
		cQuery	+= 			"("
		cQuery	+= 				"P2_FILIAL = ? AND P2_MAT = ? AND P2_CC = ? AND P2_TURNO = ? "
		cQuery	+=			")"  
		cQuery	+=		")"
		cQuery	+=		" AND "
		cQuery	+=		"("
		cQuery	+= 			"("
		cQuery	+= 			 	"P2_DATAATE BETWEEN ? AND ? " 
		cQuery	+= 			")"
		cQuery	+= 			" OR "
		cQuery	+= 			"("
		cQuery	+= 				"P2_DATA BETWEEN ? AND ? "
		cQuery	+= 			")"
		cQuery	+= 			" OR "
		cQuery	+= 			"("
		cQuery	+= 				"P2_DATAATE >= ? AND P2_DATA <= ? "
		cQuery	+=			")"
		cQuery	+=		")"
		cQuery	+= ")"
		
		cQuery	:= ChangeQuery( cQuery )

		__oSt1:SetQuery(cQuery)
	EndIf

	__oSt1:SetString(1,cFil)
	__oSt1:SetString(2,cMat)
	__oSt1:SetString(3,cCc)
	__oSt1:SetString(4,cTno)
	__oSt1:SetString(5,cFil)
	__oSt1:SetString(6,cMat)
	__oSt1:SetString(7,cCc)
	__oSt1:SetString(8,cSpaceTur)
	__oSt1:SetString(9,cFil)
	__oSt1:SetString(10,cMat)
	__oSt1:SetString(11,cSpaceCus)
	__oSt1:SetString(12,cTno)
	__oSt1:SetString(13,cFil)
	__oSt1:SetString(14,cMat)
	__oSt1:SetString(15,cSpaceCus)
	__oSt1:SetString(16,cSpaceTur)
	__oSt1:SetString(17,cFil)
	__oSt1:SetString(18,cSpaceMat)
	__oSt1:SetString(19,cCc)
	__oSt1:SetString(20,cTno)
	__oSt1:SetString(21,cFil)
	__oSt1:SetString(22,cSpaceMat)
	__oSt1:SetString(23,cSpaceCus)
	__oSt1:SetString(24,cTno)
	__oSt1:SetString(25,cFil)
	__oSt1:SetString(26,cSpaceMat)
	__oSt1:SetString(27,cCc)
	__oSt1:SetString(28,cSpaceTur)
	__oSt1:SetString(29,cFil)
	__oSt1:SetString(30,cSpaceMat)
	__oSt1:SetString(31,cSpaceCus)
	__oSt1:SetString(32,cSpaceTur)
	__oSt1:SetString(33,cPerIni)
	__oSt1:SetString(34,cPerFim)
	__oSt1:SetString(35,cPerIni)
	__oSt1:SetString(36,cPerFim)
	__oSt1:SetString(37,cPerFim)
	__oSt1:SetString(38,cPerIni)
	
	cQuery := __oSt1:getFixQuery()
	
	cQuery	+=	" AND D_E_L_E_T_ = ' '"
	cQuery	+= " ORDER BY "+SqlOrder( SP2->( IndexKey() ) )

	dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasQuery)
	
	For nX := 1 To nFieldsSP2
		If ( aStruSP2[nX,02] <> "C" )
			TcSetField(cAliasQuery,aStruSP2[nX,01],aStruSP2[nX,02],aStruSP2[nX,03],aStruSP2[nX,04])
		EndIf
	Next nX

	While ( cAliasQuery )->( !Eof() )

		If aScan( aArray , baScan ) == 0
			( cAliasQuery )->( fAddExce( @aArray , NIL , NIL , NIL , NIL , cRegra , RECNO ) )
		EndIf
		
		( cAliasQuery )->( dbSkip() )
	
	End While

	(cAliasQuery)->(dbCloseArea())
	
	If lTemTransf
		nLenTransf := Len(aTransf)
		For nI := 1 To nLenTransf
			// Procura exceções apenas se teve troca de centro de custo na transferência
			If aTransf[nI,3] <> aTransf[nI,6] .And. aTransf[nI,7] >= dPerIni .And. aTransf[nI,7] <= dPerFim
				If __oSTransf == Nil
					cQueryTrf := "SELECT "
					cQueryTrf += cQrySp2Fields
					cQueryTrf += "R_E_C_N_O_ RECNO"
					cQueryTrf += " FROM "
					cQueryTrf += cInitSqlName
					cQueryTrf += " WHERE "
					cQueryTrf +=		"("
					cQueryTrf +=			"("
					cQueryTrf +=				"P2_FILIAL = ? AND P2_MAT = ? AND P2_CC = ?"
					cQueryTrf +=			")"
					cQueryTrf +=			" OR "
					cQueryTrf +=			"("
					cQueryTrf +=				"P2_FILIAL = ? AND P2_MAT = ? AND P2_CC = ?"
					cQueryTrf +=			")"
					cQueryTrf +=			" OR "
					cQueryTrf +=			"("
					cQueryTrf +=				"P2_FILIAL = ? AND P2_MAT = ? AND P2_CC = ?"
					cQueryTrf +=			")"
					cQueryTrf +=		")"
					cQueryTrf +=		" AND "
					cQueryTrf +=		"("
					cQueryTrf +=			"("
					cQueryTrf +=				"P2_DATAATE >= ? AND P2_DATAATE <= ?" 
					cQueryTrf +=			")"
					cQueryTrf +=			" OR "
					cQueryTrf +=			"("
					cQueryTrf +=				"P2_DATA >= ? AND P2_DATA <= ?"
					cQueryTrf +=			")"
					cQueryTrf +=			" OR "
					cQueryTrf +=			"("
					cQueryTrf +=				"P2_DATA >= ? AND  P2_DATAATE <= ? "
					cQueryTrf +=			")"
					cQueryTrf +=		")"
					cQueryTrf += " AND D_E_L_E_T_ = ?"
					cQueryTrf += " ORDER BY " + SqlOrder(SP2->(IndexKey()))

					cQueryTrf := ChangeQuery(cQueryTrf)

					__oSTransf := FwExecStatement():New(cQueryTrf)
				EndIf

				__oSTransf:SetString(1,cFil)
				__oSTransf:SetString(2,cMat)
				__oSTransf:SetString(3,aTransf[nI,3])
				__oSTransf:SetString(4,cFil)
				__oSTransf:SetString(5,cSpaceMat)
				__oSTransf:SetString(6,aTransf[nI,3])
				__oSTransf:SetString(7,cFil)
				__oSTransf:SetString(8,cMat)
				__oSTransf:SetString(9,cSpaceCus)
				__oSTransf:SetString(10,cPerIni)
				__oSTransf:SetString(11,dToS(aTransf[nI,7] - 1))
				__oSTransf:SetString(12,cPerIni)
				__oSTransf:SetString(13,dToS(aTransf[nI,7] - 1))
				__oSTransf:SetString(14,cPerIni)
				__oSTransf:SetString(15,dToS(aTransf[nI,7] - 1))
				__oSTransf:SetString(16,cSpaceDel)

				cAliasQuery := __oSTransf:OpenAlias()
	
				For nX := 1 To nFieldsSP2
					If ( aStruSP2[nX,02] <> "C" )
						TcSetField(cAliasQuery,aStruSP2[nX,01],aStruSP2[nX,02],aStruSP2[nX,03],aStruSP2[nX,04])
					EndIf
				Next nX

				While (cAliasQuery)->( !Eof())
					If aScan(aArray, baScan) == 0
						(cAliasQuery)->(fAddExce(@aArray , NIL , NIL , NIL , NIL , cRegra , RECNO))
						
						If aArray[Len(aArray),3] >= aTransf[nI,7]
							aArray[Len(aArray),3] := aTransf[nI,7] - 1
						EndIf
					EndIf
					
					(cAliasQuery)->(dbSkip())
				End While

				(cAliasQuery)->(dbCloseArea())
			EndIf
		Next
	EndIf		
Next nY	

If ( nOrderExce == nSvOrder )
	SP2->( dbSetOrder( nSvOrder ) )
EndIf

lRet := !( Empty( aArray ) )

RestArea( aSvAlias )
	
Return( lRet )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³fAddExce      ³ Autor ³Marinaldo de Jesus    ³ Data ³18/07/2001³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Carregar o Array de Excecoes com Informacoes do SP2            ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³SP2>->( fAddExce( @aArray ) )                          		   ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³                                         					   ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³aArray   -> Array que contera as Excecoes do SP2               ³
³          ³lArray   -> Quando True Carrega Excecao de aExcePer            ³
³          ³aExcePer -> Array com as Excecoes por Periodo                  ³
³          ³nPos     -> Posicao da Excecao em aExcePer                     ³
³          ³dData    -> Data da Excecao                                    ³
³          ³cRegra   -> Regra de Apontamento do Cadastro de Funcionarios   ³
³          ³nRecno   -> Recno Correspondente a Excecao                     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	       ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³GetExcecoes() e GetExceTop()								   ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function fAddExce( aArray , lArray , aExceper , nPos , dData , cRegra , nRecno )

Local nLenArray := 0
Local cHerdHor	:= "N"

//PE para desprezar a excecao ja posicionada em tabela temporaria baseada na SP2 
If lPnmExcFi 
	If ExecBlock("PNMEXCFI",.F.,.F.,{aArray, lArray, aExceper, nPos, dData, cRegra, nRecno, GetArea()[1]}, .F.) 
		Return(nil) 
	Endif 
EndIf

IF !( lArray )
	cRegra		:=	IF( Empty( P2_REGRA ) , cRegra , P2_REGRA )
	cHerdHor	:=	IF( ( P2_HERDHOR == "S" ) , "S", "N" )
EndIF

IF ( dData == NIL ) //Carrega as Excecoes Por Periodo
	aAdd(aArray, Array( 48 ) )
	nLenArray := Len( aArray )
	aArray[nLenArray,01] := P2_FILIAL	//01 - Filial
	aArray[nLenArray,02] := P2_DATA		//02 - Data da Excecao
	aArray[nLenArray,03] := P2_DATAATE	//03 - Data Final da Excecao
	aArray[nLenArray,04] := P2_TURNO	//04 - Turno para a Excecao
	aArray[nLenArray,05] := P2_CC		//05 - Centro de Custo para a Excecao
	aArray[nLenArray,06] := P2_MAT		//06 - Matricula para a Excecao
	aArray[nLenArray,07] := P2_ENTRA1	//07 - 1a. Entrada
	aArray[nLenArray,08] := P2_SAIDA1	//08 - 1a. Saida
	aArray[nLenArray,09] := P2_ENTRA2	//09 - 2a. Entrada
	aArray[nLenArray,10] := P2_SAIDA2	//10 - 2a. Saida
	aArray[nLenArray,11] := P2_ENTRA3	//11 - 3a. Entrada
	aArray[nLenArray,12] := P2_SAIDA3	//12 - 3a. Saida
	aArray[nLenArray,13] := P2_ENTRA4	//13 - 4a. Entrada
	aArray[nLenArray,14] := P2_SAIDA4	//14 - 4a. Saida
	aArray[nLenArray,15] := P2_INTERV1	//15 - Primeira Saida Intervalo
	aArray[nLenArray,16] := P2_INTERV2	//16 - Segunda Saida Intervalo
	aArray[nLenArray,17] := P2_INTERV3	//17 - Terceira Saida Intervalo
	aArray[nLenArray,18] := P2_HRSTRAB	//18 - Horas Trabalhadas 1a. Jornada
	aArray[nLenArray,19] := P2_HRSTRA2	//19 - Horas Trabalhadas 2a. Jornada
	aArray[nLenArray,20] := P2_HRSTRA3	//20 - Horas Trabalhadas 3a. Jornada
	aArray[nLenArray,21] := P2_HRSTRA4	//21 - Horas Trabalhadas 4a. Jornada
	aArray[nLenArray,22] := 0			//22 - Numero de Marcacoes da Tabela (Nao usado)
	aArray[nLenArray,23] := P2_MOTIVO	//23 - Motivo da Excecao
	aArray[nLenArray,24] := P2_CODHEXT	//24 - Codigo da Hora Extra Normal
	aArray[nLenArray,25] := P2_TRABA	//25 - Dia Trabalhado
	aArray[nLenArray,26] := P2_CODHNOT	//26 - Codigo da Hora Extra Noturna
	aArray[nLenArray,27] := nRecno		//27 - Registro da Excecao
	aArray[nLenArray,28] := P2_HRINTV1	//28 - Horas do Primeiro Intervalo
	aArray[nLenArray,29] := P2_HRINTV2	//29 - Horas do Segundo Intervalo
	aArray[nLenArray,30] := P2_HRINTV3	//30 - Horas do Terceiro Intervalo
	aArray[nLenArray,31] := P2_CCPER01	//31 - Centro de Custo da 1a. Jornada
	aArray[nLenArray,32] := P2_CCPER02	//32 - Centro de Custo da 2a. Jornada
	aArray[nLenArray,33] := P2_CCPER03	//33 - Centro de Custo da 3a. Jornada
	aArray[nLenArray,34] := P2_CCPER04	//34 - Centro de Custo da 4a. Jornada
	aArray[nLenArray,35] := P2_TIPODIA	//35 - Tipo do Dia para a Excecao
	aArray[nLenArray,36] := P2_NONAHOR	//36 - Aponta Nona Hora
	aArray[nLenArray,37] := P2_HORMENO	//37 - Limite de Horario Inicial
	aArray[nLenArray,38] := P2_HORMAIS	//38 - Limite de Horario Final
	aArray[nLenArray,39] := P2_JND1CON	//39 - 1a. Jornada Continua
	aArray[nLenArray,40] := P2_JND2CON	//40 - 2a. Jornada Continua
	aArray[nLenArray,41] := P2_JND3CON	//41 - 2a. Jornada Continua
	aArray[nLenArray,42] := P2_JND4CON	//42 - 2a. Jornada Continua
	aArray[nLenArray,43] := P2_CODREF	//43 - Codigo da Refeicao
	aArray[nLenArray,44] := cRegra		//44 - Regra de Apontamento
	aArray[nLenArray,45] := P2_INIHNOT	//45 - Inicio da Hora Noturna
	aArray[nLenArray,46] := P2_FIMHNOT	//46 - Final da Hora Noturna
	aArray[nLenArray,47] := P2_MINHNOT	//47 - Minutos da Hora Noturna 
	aArray[nLenArray,48] := cHerdHor	//48 - Herda Hora (Mantem o Horario do Calendario) 
Else //Carrega as Excecoes na Data
	aAdd( aArray , Array( 46 ) )
	nLenArray := Len( aArray )
	aArray[nLenArray,01] := dData					//01 - Data
	IF ( lArray )
		aArray[nLenArray,02] := aExcePer[nPos,04]	//02 - Turno
		aArray[nLenArray,03] := aExcePer[nPos,05]	//03 - CC
		aArray[nLenArray,04] := aExcePer[nPos,06]	//04 - Mat
		aArray[nLenArray,05] := aExcePer[nPos,07]	//05 - Entra1
		aArray[nLenArray,06] := aExcePer[nPos,08]	//06 - Saida1
		aArray[nLenArray,07] := aExcePer[nPos,09]	//07 - Entra2
		aArray[nLenArray,08] := aExcePer[nPos,10]	//08 - Saida2
		aArray[nLenArray,09] := aExcePer[nPos,11]	//09 - Entra3
		aArray[nLenArray,10] := aExcePer[nPos,12]	//10 - Saida3
		aArray[nLenArray,11] := aExcePer[nPos,13]	//11 - Entra4
		aArray[nLenArray,12] := aExcePer[nPos,14]	//12 - Saida4
		aArray[nLenArray,13] := aExcePer[nPos,15]	//13 - Intervalo1
		aArray[nLenArray,14] := aExcePer[nPos,16]	//14 - Intervalo2
		aArray[nLenArray,15] := aExcePer[nPos,17]	//15 - Intervalo3
		aArray[nLenArray,16] := aExcePer[nPos,18]	//16 - Horas Trabalhadas 1a. Jornada
		aArray[nLenArray,17] := aExcePer[nPos,19]	//17 - Horas Trabalhadas 2a. Jornada
		aArray[nLenArray,18] := aExcePer[nPos,20]	//18 - Horas Trabalhadas 3a. Jornada
		aArray[nLenArray,19] := aExcePer[nPos,21]	//19 - Horas Trabalhadas 4a. Jornada
		aArray[nLenArray,20] := aExcePer[nPos,22]	//20 - TabMarc("SP2") Numero de Marcacoes da Tabela
		aArray[nLenArray,21] := aExcePer[nPos,23]	//21 - Motivo
		aArray[nLenArray,22] := aExcePer[nPos,24]	//22 - HExt
		aArray[nLenArray,23] := aExcePer[nPos,25]	//23 - Traba
		aArray[nLenArray,24] := aExcePer[nPos,26]	//24 - HENot
		aArray[nLenArray,25] := aExcePer[nPos,27]	//25 - Recno
		aArray[nLenArray,26] := aExcePer[nPos,28]	//26 - Horas do 1o. Intervalo	
		aArray[nLenArray,27] := aExcePer[nPos,29]	//27 - Horas do 2o. Intervalo
		aArray[nLenArray,28] := aExcePer[nPos,30]	//28 - Horas do 3o. Intervalo
		aArray[nLenArray,29] := aExcePer[nPos,31]	//29 - Centro de Custo Periodo 1 (1a.E-1a.S)
		aArray[nLenArray,30] := aExcePer[nPos,32]	//30 - Centro de Custo Periodo 2 (2a.E-2a.S)
		aArray[nLenArray,31] := aExcePer[nPos,33]	//31 - Centro de Custo Periodo 3 (3a.E-3a.S)
		aArray[nLenArray,32] := aExcePer[nPos,34]	//32 - Centro de Custo Periodo 4 (4a.E-4a.S)
		aArray[nLenArray,33] := aExcePer[nPos,35]	//33 - Tipo do Dia para a Excecao
		aArray[nLenArray,34] := aExcePer[nPos,36]	//34 - Aponta Nona Hora
		aArray[nLenArray,35] := aExcePer[nPos,37]	//35 - Limite de Horario Inicial
		aArray[nLenArray,36] := aExcePer[nPos,38]	//36 - Limite de Horario Inicial
		aArray[nLenArray,37] := aExcePer[nPos,39]	//37 - 1a. Jornada Continua
		aArray[nLenArray,38] := aExcePer[nPos,40]	//38 - 2a. Jornada Continua
		aArray[nLenArray,39] := aExcePer[nPos,41]	//39 - 2a. Jornada Continua
		aArray[nLenArray,40] := aExcePer[nPos,42]	//40 - 2a. Jornada Continua
		aArray[nLenArray,41] := aExcePer[nPos,43]	//41 - Codigo da Refeicao
		aArray[nLenArray,42] := aExcePer[nPos,44]	//42 - Regra de Apontamento
		aArray[nLenArray,43] := aExcePer[nPos,45]	//43 - Inicio da Hora Noturna
		aArray[nLenArray,44] := aExcePer[nPos,46]	//44 - Final da Hora Noturna
		aArray[nLenArray,45] := aExcePer[nPos,47]	//45 - Minutos da Hora Noturna  
		aArray[nLenArray,46] := aExcePer[nPos,48]	//46 - Herda Hora (Mantem o Horario do Calendario) 
	Else
		aArray[nLenArray,02] :=	P2_TURNO			//02 - Turno
		aArray[nLenArray,03] := P2_CC				//03 - CC
		aArray[nLenArray,04] := P2_MAT				//04 - Mat
		aArray[nLenArray,05] := P2_ENTRA1			//05 - Entra1
		aArray[nLenArray,06] := P2_SAIDA1			//06 - Saida1
		aArray[nLenArray,07] := P2_ENTRA2			//07 - Entra2
		aArray[nLenArray,08] := P2_SAIDA2			//08 - Saida2
		aArray[nLenArray,09] := P2_ENTRA3			//09 - Entra3
		aArray[nLenArray,10] := P2_SAIDA3			//10 - Saida3
		aArray[nLenArray,11] := P2_ENTRA4			//11 - Entra4
		aArray[nLenArray,12] := P2_SAIDA4			//12 - Saida4
		aArray[nLenArray,13] := P2_INTERV1			//13 - Intervalo1
		aArray[nLenArray,14] := P2_INTERV2			//14 - Intervalo2
		aArray[nLenArray,15] := P2_INTERV3			//15 - Intervalo3
		aArray[nLenArray,16] := P2_HRSTRAB			//16 - Horas Trabalhadas 1a. Jornada
		aArray[nLenArray,17] := P2_HRSTRA2			//17 - Horas Trabalhadas 2a. Jornada
		aArray[nLenArray,18] := P2_HRSTRA3			//18 - Horas Trabalhadas 3a. Jornada
		aArray[nLenArray,19] := P2_HRSTRA4			//19 - Horas Trabalhadas 4a. Jornada
		aArray[nLenArray,20] := 0					//20 - TabMarc("SP2") Numero de Marcacoes da Tabela
		aArray[nLenArray,21] := P2_MOTIVO			//21 - Motivo
		aArray[nLenArray,22] := P2_CODHEXT			//22 - HExt
		aArray[nLenArray,23] := P2_TRABA			//23 - Traba
		aArray[nLenArray,24] := P2_CODHNOT			//24 - HENot
		aArray[nLenArray,25] := nRecno				//25 - Recno
		aArray[nLenArray,26] := P2_HRINTV1			//26 - Horas do 1o. Intervalo	
		aArray[nLenArray,27] := P2_HRINTV2			//27 - Horas do 2o. Intervalo
		aArray[nLenArray,28] := P2_HRINTV3			//28 - Horas do 3o. Intervalo
		aArray[nLenArray,29] := P2_CCPER01			//29 - Centro de Custo Periodo 1 (1a.E-1a.S)
		aArray[nLenArray,30] := P2_CCPER02			//30 - Centro de Custo Periodo 2 (2a.E-2a.S)
		aArray[nLenArray,31] := P2_CCPER03			//31 - Centro de Custo Periodo 3 (3a.E-3a.S)
		aArray[nLenArray,32] := P2_CCPER04			//32 - Centro de Custo Periodo 4 (4a.E-4a.S)
		aArray[nLenArray,33] := P2_TIPODIA			//33 - Tipo do Dia para a Excecao
		aArray[nLenArray,34] := P2_NONAHOR			//34 - Aponta Nona Hora
		aArray[nLenArray,35] := P2_HORMENO			//35 - Limite de Horario Inicial
		aArray[nLenArray,36] := P2_HORMAIS			//36 - Limite de Horario Inicial
		aArray[nLenArray,37] := P2_JND1CON			//37 - 1a. Jornada Continua
		aArray[nLenArray,38] := P2_JND2CON			//38 - 2a. Jornada Continua
		aArray[nLenArray,39] := P2_JND3CON			//39 - 2a. Jornada Continua
		aArray[nLenArray,40] := P2_JND4CON			//40 - 2a. Jornada Continua
		aArray[nLenArray,41] := P2_CODREF			//41 - Codigo da Refeicao
		aArray[nLenArray,42] := cRegra				//42 - Regra de Apontamento
		aArray[nLenArray,43] := P2_INIHNOT			//43 - Inicio da Hora Noturna
		aArray[nLenArray,44] := P2_FIMHNOT			//44 - Final da Hora Noturna
		aArray[nLenArray,45] := P2_MINHNOT			//45 - Minutos da Hora Noturna
		aArray[nLenArray,46] := cHerdHor			//46 - Herda Hora (Mantem o Horario do Calendario) 
	EndIF
EndIF
	
Return( NIL )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³PutHrsTab  ³Autor ³ Marinaldo de Jesus    ³ Data ³27/04/2001³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Atualiza as Horas da Tabela de Horario/Excecoes		        ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³PutHrsTab( cAlias , lProcess )								³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parƒmetros³cAlias   -> Alias da Tabela a Ser Atualizada                ³
³          ³            "SP2" -> Excecoes                               ³
³          ³            "SPJ" -> Tabela de Horario Padrao               ³
³          ³lProcess -> False Executa via Processa()                    ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³                                                            ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function PutHrsTab( cAlias , lProcess )

Local bEval			:= { |e| &(e) }
Local cCond			:= ""
Local cPerg			:= ""
Local cPref			:= ""
Local cSeek			:= ""
Local nHoras		:= 0

Private lAbortPrint := .F.

DEFAULT cAlias	 := "SPJ"
DEFAULT lProcess := .F.

cAlias	:= Upper( AllTrim( cAlias ) )
cPerg	:= IF( cAlias == "SPJ" , "PNCAPJ" , "PNCAP2" )
cPref	:= ( PrefixoCpo( cAlias ) + "_" )

IF cAlias == "SPJ"
	cCond := "PJ_FILIAL+PJ_TURNO"
Else
	cCond := "P2_FILIAL+DTOS(P2_DATA)"
EndIF	

IF !( lProcess )
	IF Pergunte( cPerg , .T. )
		Processa( { || PutHrsTab( cAlias , .T. ) } , IF( cAlias == "SPJ" , STR0061 , STR0062 ) ,, .T. )
		Return( NIL )
	EndIF
Else
	Pergunte( cPerg , .F. )
	dbSelectArea( cAlias )
	( cAlias )->( ProcRegua( RecCount() ) , dbGotop() , dbSetOrder( RetOrdem( cAlias , cCond ) ) )
	IF !Empty( xFilial( cAlias ) )
		cSeek := ( xFilial(cAlias,MV_PAR01) + IF( cAlias == "SPJ" , MV_PAR03 , Dtos( MV_PAR03 ) ) )
	Else
		cSeek := ( Space( FWGETTAMFILIAL ) + IF( cAlias == "SPJ" , MV_PAR03 , Dtos( MV_PAR03 ) ) )
	EndIF
	( cAlias )->( dbSeek( cSeek , .T. ) )
	While ( cAlias )->( !Eof() .and. Eval( bEval , cCond ) <= MV_PAR02 + IF( cAlias == "SPJ" , MV_PAR04 , Dtos( MV_PAR04 ) ) )
	    IncProc( STR0063 )
	    IF ( lAbortPrint )
	    	Exit
	    EndIF	
	    IF RecLock( cAlias , .F. , .F. )
			nHoras := 0
			nHoras := __TimeSum(SomaHoras( nHoras , ( ( cAlias )->( IF( cAlias == "SPJ" , PJ_HRSINT1 , P2_HRINTV1 ) )	:= fHrsTrabGat( "I" , cAlias , "DB" , "1" ) ) ), 0 )
			nHoras := __TimeSum(SomaHoras( nHoras , ( ( cAlias )->( IF( cAlias == "SPJ" , PJ_HRSINT2 , P2_HRINTV2 ) )	:= fHrsTrabGat( "I" , cAlias , "DB" , "2" ) ) ), 0 )
			nHoras := __TimeSum(SomaHoras( nHoras , ( ( cAlias )->( IF( cAlias == "SPJ" , PJ_HRSINT3 , P2_HRINTV3 ) )	:= fHrsTrabGat( "I" , cAlias , "DB" , "3" ) ) ), 0 )
			nHoras := __TimeSum(SomaHoras( nHoras , ( ( cAlias )->( &(cPref+"HRSTRAB") ) := fHrsTrabGat( "H" , cAlias , "DB" , "1" ) ) ) ,0 )
			nHoras := __TimeSum(SomaHoras( nHoras , ( ( cAlias )->( &(cPref+"HRSTRA2") ) := fHrsTrabGat( "H" , cAlias , "DB" , "2" ) ) ) ,0 )
			nHoras := __TimeSum(SomaHoras( nHoras , ( ( cAlias )->( &(cPref+"HRSTRA3") ) := fHrsTrabGat( "H" , cAlias , "DB" , "3" ) ) ) ,0 )
			nHoras := __TimeSum(SomaHoras( nHoras , ( ( cAlias )->( &(cPref+"HRSTRA4") ) := fHrsTrabGat( "H" , cAlias , "DB" , "4" ) ) ) ,0 )
			( cAlias )->( IF( cAlias == "SPJ" , PJ_HRTOTAL , P2_TOTHORA ) ) := nHoras
			( cAlias )->( MsUnLock() )
		EndIF	
		( cAlias )->( dbSkip() ) 
	End While
EndIF
	
Return( NIL )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³CheckPonMes   ³ Autor ³Marinaldo de Jesus    ³ Data ³14/05/2001³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Valida o Parametro de Fechamento do Ponto em Relacao ao Periodo³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide parametros Formais>									   ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide parametros Formais>									   ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³lRet -> Se a Competencia e' Valida                             ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	       ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generica                                                       ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function CheckPonMes(	dPerIni			,;	//Periodo Inicial de Apontamento
						dPerFim 		,;	//Periodo Final   de Apontamento
						lPut			,;	//Se True Grava Novo Periodo no Parametro do SX6
						lContinua		,;	//Se True Mesmo que o Periodo Nao For Valido ira contornar True.
						lShowHelp		,;	//Se False Nao Mostra o Help. DEFAULT True
						cFil			,;	//Filial para PerAponta()
						lNewPer			,;	//Se eh para gerar novo periodo (Para PerAponta())
						lPerCompleto	 ;	//Se o periodo esta preenchido com AAAAMMDD/AAAAMMDD ou AAAAMMDDAAAAMMDD (por referencia)
					 )

Local cHelp			:= ""
Local cPerg			:= "PONMES"
Local dIniFec		:= Ctod("//")
Local dFimFec		:= Ctod("//")
Local lRet			:= .T.
Local lExistPonMes	:= .T.
Local lModPer		:= .T.

DEFAULT	dPerIni		:= Ctod("//")
DEFAULT	dPerFim 	:= Ctod("//")
DEFAULT lPut		:= .F.
DEFAULT lContinua	:= .F.
DEFAULT lShowHelp	:= .T.
DEFAULT cFil		:= cFilAnt
DEFAULT lNewPer		:= .F.

IF ( lRet := CheckModSPO() )
	IF ( lRet := ( GetPonMesDat( @dIniFec , @dFimFec , cFil ) .and. !lPut ) )
		IF ( lRet := PerAponta( @dPerIni , @dPerFim , NIL , lShowHelp , cFil , NIL , @lPerCompleto ) )
			lRet := ( ( dIniFec == dPerIni ) .and. ( dFimFec <= dPerFim ) )
			IF ( !lRet .and. !lContinua .and. lShowHelp )
				cHelp += ( STR0064 + Dtoc( dIniFec ) + Chr(13) )					//'Data Inicial: '
				cHelp += ( STR0065 + Dtoc( dFimFec ) )								//'Data Final  : '
				Help( " " , 1 , "PERIIVALID" , , cHelp , 4 , 0 )
			ElseIF ( lContinua .and. !lRet )
				cHelp += STR0240 + cFil + " - "										//'Filial a processar :'
				cHelp += STR0066													//'O Periodo de Apontamento: '
				cHelp += Dtoc( dIniFec )
				cHelp += STR0067													//' a '
				cHelp += Dtoc( dFimFec )                                        	
				cHelp += STR0068													//'ainda n„o foi Fechado. Deseja Continuar?'
				IF ( lShowHelp )
					lRet := MsgNoYes( OemToAnsi( cHelp ) , OemToAnsi( STR0069 ) )	//"Aten‡„o"
				Else
					lRet := .T.
				EndIF
			EndIF
		EndIF
	Else
		IF !( lPut )
			IF ( lShowHelp )
				SetMVValue(cPerg,"MV_PAR01",cTod("//"))
				If Pergunte( cPerg , .T.)
					Pergunte( cPerg , .F.) // Acerto para atualizar o MV_PAR01
				Else
					MV_PAR01	:= cTod("//")
					Return .F.
				EndIf
				
			EndIF
		EndIF
		IF ( lRet := PerAponta( @dPerIni , @dPerFim , IF( lPut , ( ++dPerFim ) , IF( Empty( MV_PAR01 ) .or. !( ValType( MV_PAR01 ) == "D" ) , dDataBase , MV_PAR01 ) ) , lShowHelp , cFil , lNewPer , @lPerCompleto ) )
			If ( lPut .or. ( !lPut .and. !Empty( MV_PAR01 ))) .And. (lRet := PonOkModPer( "", dPerIni, dPerFim, .T., lShowHelp))
				IF !( lExistPonMes := PutMvFil( "MV_PONMES" , ( Dtos( dPerIni ) + "/" + Dtos( dPerFim ) ) , cFil ) )
					cHelp := OemToAnsi( STR0115 )										//'N„o Existe o Parametro MV_PONMES Para a Filial : '
					cHelp += CRLF
					cHelp += OemToAnsi( STR0116 )										//'Deseja Inclui-lo?'
					IF ( lShowHelp )
						IF MsgNoYes( OemToAnsi( cHelp ) , OemToAnsi( STR0069 ) )		//"Aten‡„o"
							IF ( lExistPonMes := CheckModSPO() )
								IF ( lExistPonMes := PutMvFil( "MV_PONMES" , ( Dtos( dPerIni ) + "/" + Dtos( dPerFim ) ) , cFil ) )
									lPut := .T.
								EndIF
							EndIF	
						EndIF
					EndIF
				Else
					lPut := .T.
				EndIF
		    EndIF
		    IF ( !( lPut ) .and. lExistPonMes )
			    IF ( lShowHelp )
			    	lRet := CheckPonMes( @dPerIni , @dPerFim , .F. , lContinua , lShowHelp , cFil , lNewPer )
	    		EndIF
	    	ElseIF !( lExistPonMes )
	    		IF ( lShowHelp )
	    			Help( " " , 1 , "NOMVPONMES" , , ( STR0114 + cFil ) , 4 , 0 ) //"Filial: "
	    		EndIF	
	    	EndIF                
	    Else
			IF ( lModPer )
				IF ( lShowHelp )
					lModPer := PonModPer( lModPer , cFil )
					lRet	:= CheckPonMes( @dPerIni , @dPerFim , .F. , .F. , .F. , cFil , .F. )
				EndIF
			EndIF
	    EndIF
	EndIF
EndIF


Return( lRet )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³ValidArqPon   ³ Autor ³Marinaldo de Jesus    ³ Data ³14/05/2001³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Valida o Relacionamentos dos Arquivos do Ponto Eletronico      ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³ValidArqPon( lShowHelp )                           			   ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³                                         					   ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³lRet -> Se todos os Arquivos Estao com o Relacionamento Correto³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	       ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generica                                                       ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function ValidArqPon( lShowHelp )
Return( PonRelationFile( lShowHelp ) )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³PonRelationFile³ Autor ³Marinaldo de Jesus   ³ Data ³14/05/2001³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Valida o Relacionamentos dos Arquivos do Ponto Eletronico      ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³PonRelationFile( void )                            			   ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³                                         					   ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³lRet -> Se todos os Arquivos Estao com o Relacionamento Correto³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	       ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generica                                                       ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function PonRelationFile( lShowHelp )

Local cMsg			:= ""
Local lRetModo		:= .T.

Static lPonChkRel
Static cLastEmpChk

DEFAULT lShowHelp	:= .T.

DEFAULT lRF0ChkTable	:= fVerTabRF0()  	//Verifica a Existencia da Tabela de Pre-Abonos e se a mesm possui registro

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Coloca o Ponteiro do Mouse em Estado de Espera               ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
IF ( lShowHelp )
	CursorWait()
EndIF	

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Consiste o Modo de Acesso dos Arquivos                       ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Begin Sequence
	DEFAULT lPonChkRel 	:= .T.
	DEFAULT cLastEmpChk	:= cEmpAnt
	IF ( cLastEmpChk <> cEmpAnt )
		lPonChkRel := .T.
	EndIF
	IF !( lPonChkRel )
		Break
	EndIF
	IF !( lRetModo := xRetModo("SRA","SP2",lShowHelp) )
		Break
	EndIF
	IF !( lRetModo := xRetModo("SRA","SP5",lShowHelp) )
		Break
	EndIF
	IF !( lRetModo := xRetModo("SRA","SP8",lShowHelp) )
		Break
	EndIF
	IF !( lRetModo := xRetModo("SRA","SPB",lShowHelp) )
		Break
	EndIF
	IF !( lRetModo := xRetModo("SRA","SPC",lShowHelp) )
		Break
	EndIF
	IF !( lRetModo := xRetModo("SRA","SPF",lShowHelp) )
		Break
	EndIF
	IF !( lRetModo := xRetModo("SRA","SPG",lShowHelp) )
		Break
	EndIF
	IF !( lRetModo := xRetModo("SRA","SPH",lShowHelp) )
		Break
	EndIF
	IF !( lRetModo := xRetModo("SRA","SPI",lShowHelp) )
		Break
	EndIF
	IF !( lRetModo := xRetModo("SRA","SPK",lShowHelp) )
		Break
	EndIF
	IF !( lRetModo := xRetModo("SRA","SPL",lShowHelp) )
		Break
	EndIF
	IF !( lRetModo := xRetModo("SRA","SPN",lShowHelp) )
		Break
	EndIF
	IF !( lRetModo := xRetModo("SRA","SPS",lShowHelp) )
		Break
	EndIF	
	IF !( lRetModo := xRetModo("SRA","SPT",lShowHelp) )
		Break
	EndIF	
	
	//-- Se Existir a tabela de Pre-abonos, checa modo de acesso compativel
	IF lRF0ChkTable
		IF !( lRetModo := xRetModo("SRA","RF0",lShowHelp) )
			Break
		EndIF	
	Endif

	IF !( lRetModo := xRetModo("SR6","SPJ",lShowHelp) )
		Break
	EndIF
	IF !Empty( xFilial( "SP9" ) )
		IF !( lRetModo := xRetModo("SP9","SP4",lShowHelp) )
			Break
		EndIF
	EndIF	
	IF !( lRetModo := xRetModo("SP1","SPM",lShowHelp) )
		Break
	EndIF  
	
	IF lPort1510
		IF !( lRetModo := xRetModo("RFB","RFE",lShowHelp) )
			Break
		Endif
	Endif
	
	IF ( GetMv( "MV_SP0SPEM" , NIL , "S" ) == "S" )
		IF !( lRetModo := xRetModo("SPE","SP0",lShowHelp) )
			Break
		EndIF
	EndIF
	IF !( lRetModo := xRetModo("SPU","SPV",lShowHelp) )
		Break
	EndIF
	IF !( lRetModo := xRetModo("SPU","SPX",lShowHelp) )
		Break
	EndIF
	IF !( lRetModo := xRetModo("SPY","SPZ",lShowHelp) )
		Break
	EndIF
	IF !( lRetModo := ( __nTamP8Ordem == __nTamPGOrdem  ) )
		cMsg := STR0157	//'O Tamanho do Campo P8_ORDEM e diferente do Tamanho do Campo PG_ORDEM'
		cMsg += CRLF
		cMsg += STR0158 //'Contacte o Administrador do Sistema para compatibilizar os campos'
		Break
	EndIF
	lPonChkRel := .F.
End Sequence

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Restaura o Ponteiro do Mouse                                 ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
IF ( lShowHelp )
	CursorArrow()
EndIF	

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Se estiver Tudo Ok nao verifica Novamente					   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
IF ( ( lPonChkRel := !( lRetModo ) ) .and. !Empty( cMsg ) )
	IF ( lShowHelp )
		MsgInfo( OemToAnsi( cMsg ) , OemToAnsi( STR0158 ) )	//  'Aten‡„o!'
	EndIF
EndIF

Return( lRetModo )

/*/Apenas para Compatibilizacao com Versoes Anterior*/
Function Classifica( aMarcacoes , aTabCalend  )       
Return( PutOrdMarc( aMarcacoes , aTabCalend ) )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³PutOrdMarc  ³ Autor ³Marinaldo de Jesus    ³ Data ³23/05/2001³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Carrega as Ordens no Array a Marcacoes de Acordo com o  Calen³
³          ³dario de Marcacoes.                                          ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³PutOrdMarc( @aMarcacoes , aTabCalend )						 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³aMarcacoes -> Array com as Marcacoes do Periodo    		     ³
³          ³aTabCalend -> Calendario de Marcacoes do Periodo   		     ³
³          ³lNotFlag   -> Exclui os Flags de Marcacao forcando o Reaponta³
³          ³              mento.										 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL                                                  	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Apontamento                                                  ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function PutOrdMarc( aMarcacoes, aTabCalend, lNotFlag, lAjustMarc, dPerIni, dPerFim, cFil, cMat, aCalenAux, lForcApo, lAtulizRFE )

Local aJaProc		:= {} 
Local aMarNextPer   := {}
Local aTabClone		:= {}
Local aOrd			:= {}   
Local cSpaceOrd		:= Space( __nTamP8Ordem )

Local bNoFlag
Local cOrd 
Local dDataApo 
Local cOrdAnt	:= ""  
Local cTurnoAnt	:= ""
Local cSeqAnt	:= ""  
Local dDataAnt  := Ctod("")
Local cMarc
Local cTno
Local cSeq
Local cSpacePer
Local cPerAponta  
Local cPerAnt
Local cUltOrdem  
Local dDataOrd	:=Ctod(Space(8))
Local nPosUltOrdem
Local nTab
Local nVezTab
Local nMar 
Local nMar1 
Local nPrimMarc
Local nMarcSemOrdem	:= 0  
Local nVezMar
Local nVezMar1
Local nSvTab
Local nQtde
Local nHours      
Local nHoursTot	:= 0      
Local nPosDt
Local nTamPer
Local nPosCalend
Local lMemoCalc := .F.

DEFAULT lNotFlag		:= .F.   
DEFAULT lAjustMarc   	:= .F.
DEFAULT lForcApo		:= .F.
DEFAULT dPerIni			:= Ctod("//")
DEFAULT dPerFim			:= Ctod("//")
DEFAULT cFil			:= SRA->RA_FILIAL
DEFAULT cMat			:= SRA->RA_MAT
DEFAULT aCalenAux		:= {}
DEFAULT lAtulizRFE		:= .T.

// Obtem o Tamanho do campo P8_PAPONTA
nTamPer := GetSx3Cache( "P8_PAPONTA" , "X3_TAMANHO" )
DEFAULT nTamPer := 16
cSpacePer := Space( nTamPer )

If Type("lPn010Auto") == "U"
	Private lPn010Auto := .F.
Endif

If IsInCallStack("PONM010") .And. !Type("nTipo") == "U"
	lMemoCalc := GetlMemoCalc()
	// Executa a memória de cálculo apenas para a leitura
	lMemoCalc := lMemoCalc .and. (nTipo == 1 .Or. nTipo == 3)
Endif

// Desflega  Marcacoes Apontados conforme lNotFlag
If lPort1510
	If !lForcApo
		bNoFlag :=	{ 	|x|   IF( lNotFlag .And. (dPerIni == Ctod("//") .Or. dPerFim == Ctod("//") .Or. (x[AMARC_DATAAPO] >= dPerIni .And. x[AMARC_DATAAPO] <= dPerFim)), ( x[AMARC_APONTA] := "N" ) , NIL );		//Desflega Apontamento conforme lNotFlag
			 	 	}
	Else
		bNoFlag := {|x| x[AMARC_APONTA] := "N"}
	EndIf
Else
	If !lForcApo
		bNoFlag :=	{ 	|x|   IF( lNotFlag , ( x[AMARC_APONTA] := "N" ) , NIL );		//Desflega Apontamento conforme lNotFlag
					}
	Else
		bNoFlag := {|x| x[AMARC_APONTA] := "N"}
	EndIf
Endif

Begin Sequence
	
	IF ( Empty( aMarcacoes ) .or. Empty( aTabCalend ) )
		Break
	EndIF
	
	// Obtem o Numero de Elementos do Calendario de Marcacoes
	nVezTab := Len( aTabCalend )
	
	// Obtem o Periodo de Apontamento Conforme Calenario de Marcacoes
	cPerAponta		:= Dtos( aTabCalend[ 01 , CALEND_POS_DATA_APO ] )
	cUltOrdem		:= aTabCalend[ nVezTab	, CALEND_POS_ORDEM	]
	nPosUltOrdem    := aScan( aTabCalend , { |x| ( x[ CALEND_POS_ORDEM ] == cUltOrdem  ) .and. ( x[CALEND_POS_TIPO_MARC] == "1E" ) } )
	cPerAponta		+= Dtos( aTabCalend[ nPosUltOrdem , CALEND_POS_DATA_APO ] )
	
	// Obtem o HorMais e HorMenos
	For nTab := 1 To nVezTab
		IF ( Empty( cOrd ) .or. ( cOrd != aTabCalend[ nTab , CALEND_POS_ORDEM ] ) )
			cOrd := aTabCalend[ nTab , CALEND_POS_ORDEM ]
		EndIF
		IF ( Empty( cTno ) .or. ( cTno != aTabCalend[ nTab , CALEND_POS_TURNO ] ) )
			cTno := aTabCalend[ nTab , CALEND_POS_TURNO ]
		EndIF	
		IF ( Empty( cSeq ) .or. ( cSeq != aTabCalend[ nTab , CALEND_POS_SEQ_TURNO ] ) )
			cSeq := aTabCalend[ nTab , CALEND_POS_SEQ_TURNO ]
		EndIF	                                 
		IF ( Empty( dDataApo) .or. ( dDataApo != aTabCalend[ nTab , CALEND_POS_DATA_APO ] ) )
			dDataApo := aTabCalend[ nTab , CALEND_POS_DATA_APO ]
		EndIF		
		IF !Empty( aTabCalend[ nTab , CALEND_POS_LIM_MARCACAO , 1 ] )
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Se a Ordem for Diferente da Ordem Lida Anteriormente		   ³
			³ recalcula as Horas Trabalhadas para a Ordem				   ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			If (cOrdAnt <> cOrd)
				cOrdAnt	:= cOrd
				nHours 	:= 0 
				aEval( aTabCalend , { |x| IF( x[CALEND_POS_ORDEM] == cOrd , nHours := SomaHoras( nHours , x[CALEND_POS_HRS_TRABA] ) , NIL ) }, nTab )
				dDataAnt  := dDataApo
			Endif
			cMarc := DataHora2Str( aTabCalend[ nTab, CALEND_POS_LIM_MARCACAO, 1], aTabCalend[ nTab, CALEND_POS_LIM_MARCACAO, 2 ] )
			aAdd( aOrd, {	cOrd									,;	//01 - Ordem da Marcacao
					    	cTno									,; 	//02 - Turno da Marcacao
						    IF( Empty( nHours ) , "" , cMarc )		,; 	//03 - String para Comparacao correspondente ao HorMeno/HorMais para Dias Com Horas na Tabela
							aTabCalend[ nTab , CALEND_POS_DATA ] 	,; 	//04 - Data de Referencia da Ordem
							cMarc									,;	//05 - String para Comparacao correspondente ao HorMeno/HorMais para Marcacoes Nao Ordenadas
							cSeq									,;	//06 - Sequencia do Turno
							dDataApo								,;	//07 - Data de Apontamento da Marcacao							
							aTabCalend[ nTab , CALEND_POS_TIPO_DIA ];	//08 - Tipo do Dia							
						};
				)
		EndIF	
		nHoursTot := SomaHoras( nHoursTot , aTabCalend[nTab, CALEND_POS_HRS_TRABA] ) 
	Next nTab
	
	// Corre Todas as Marcacoes
	nVezMar := Len( aMarcacoes )
	nVezTab := Len( aOrd )
	nSvTab	:= 1
	
	For nMar := 1 To nVezMar
		
		// Limpa Todas as Ordens de Marcacoes nao Infomadas/Modificadas
		IF !aMarcacoes[nMar, AMARC_L_ORIGEM] 
			aMarcacoes[nMar, AMARC_ORDEM] := cSpaceOrd 
			aMarcacoes[nMar, AMARC_DATAAPO]	:= Ctod("")
		Endif
		
		If lMemoCalc
			// "Marcação: "
			GravaMCalc("01", 3, STR0257 + If(!Empty(aMarcacoes[nMar][AMARC_IDORG]), aMarcacoes[nMar][AMARC_IDORG], "") + " | " + dToc(aMarcacoes[nMar][AMARC_DATA]) + "-" + Transform(StrZero(aMarcacoes[nMar][AMARC_HORA] * 100, 4), "@R XX:XX"))
		EndIf
		
		// Ordena as Marcações com Horário no Calendário de Marcações
		IF !Empty( nHoursTot )
			IF Empty( cMarc := aMarcacoes[ nMar, AMARC_DTHR2STR ])
				cMarc	:= DataHora2Str( aMarcacoes[ nMar , AMARC_DATA ] , aMarcacoes[ nMar , AMARC_HORA ] )
			EndIF	
			For nTab := nSvTab To nVezTab Step 2
				If Empty(aMarcacoes[ nMar, AMARC_DATAAPO ])
					nPosCalend := aScan(aTabCalend, { |x| x[CALEND_POS_DATA_APO] == aMarcacoes[ nMar, AMARC_DATA ]})
				Else
					nPosCalend := aScan(aTabCalend,{ |x| x[CALEND_POS_DATA_APO] == aMarcacoes[ nMar , AMARC_DATAAPO ] })
				EndIf
				
				IF (( cMarc >= aOrd[nTab, 3 ]) .and. (cMarc <= aOrd[ nTab + 1, 3]) .AND. nPoscalend > 0 )
					If (lPnmTabCalen .OR. lAutoGS) .AND. lValidGS .AND. SuperGetMv("MV_TECXRH",,.F.)
						TecBOrdMrk(@aMarcacoes, nMar, aOrd, nTab, cMarc, aTabCalend, nPosCalend, cFil, cMat)
						nSvTab := nTab
						Exit
					Else
						IF !( aMarcacoes[ nMar, AMARC_L_ORIGEM ] )
							aMarcacoes[nMar, AMARC_ORDEM	] := aOrd[nTab, 1]
							aMarcacoes[nMar, AMARC_DATAAPO 	] := aOrd[nTab, 7]
							aMarcacoes[nMar, AMARC_SEQ		] := aOrd[nTab, 6]
						EndIF
						aMarcacoes[nMar, AMARC_TURNO	] 	:= aOrd[nTab, 2]
						aMarcacoes[nMar, AMARC_DTHR2STR ]	:= cMarc           
						If lMemoCalc
							GravaMCalc("01", 4, STR0258) // "Horário encontrado no Calendário"
							//"Ordem: " - "Data de Apontamento: " - "Turno: "
							GravaMCalc("01", 4, STR0259 + aMarcacoes[nMar, AMARC_ORDEM] + " | " + STR0260 + dToC(aMarcacoes[nMar, AMARC_DATAAPO]) + " | " + STR0261 + aMarcacoes[nMar, AMARC_TURNO])
						EndIf
						nSvTab := nTab
						Exit
					EndIf
				EndIF
			Next nTab
		Endif
		
		If lMemoCalc .And. Empty( aMarcacoes[nMar, AMARC_ORDEM])
			GravaMCalc("01", 4, STR0262) // "Marcação não ordenada"
		EndIf
		
		// Obtem a Primeira Marcação sem Ordem
		If Empty( nMarcSemOrdem ) 
			If Empty( aMarcacoes[nMar, AMARC_ORDEM] )
				nMarcSemOrdem:= nMar
			Endif
		Endif
		
		// Refaz Status da Marcação para Reapontar ou Não
		Eval(bNoFlag, aMarcacoes[nMar])
		
	Next nMar
	
	// Ordena as Marcações sem Horário no Calendário de Marcações
	IF ( !Empty(nMarcSemOrdem) )
		
		nMar := nMarcSemOrdem
		For nMar := nMarcSemOrdem To nVezMar
			cOrd 		:= ""
			cTno 		:= ""
			cSeq 		:= ""	 
			dDataApo	:= Ctod("")			
			IF ( ( nMar := aScan( aMarcacoes , { |x| Empty( x[AMARC_ORDEM] ) } ) ) == 0 )
				Exit
			EndIF
			IF ( aScan( aJaProc , { |x| x == nMar } ) == 0 )
				aAdd( aJaProc , nMar )
			Else
				Exit
			EndIF	
			For nSvTab := nMar To nVezMar
				IF ( Empty( cOrd ) .and. ( ( nTab := aScan( aOrd , { |x| Empty( x[3] ) .and. x[4] == aMarcacoes[ nMar , AMARC_DATA ] } ) ) > 0 ) )
					IF Empty( cMarc := aMarcacoes[ nMar , AMARC_DTHR2STR ] )
						cMarc := DataHora2Str( aMarcacoes[ nMar , AMARC_DATA ] , aMarcacoes[ nMar , AMARC_HORA ] )
					EndIF	
					cOrd  		:= aOrd[ nTab , 01 ]
					cTno  		:= aOrd[ nTab , 02 ]
					cSeq  		:= aOrd[ nTab , 06 ]  
					dDataApo	:= aOrd[ nTab , 07 ]					
					If nTab >= nVezTab
					     aOrd[ nTab , 03 ] := cMarc
					Else
					     aOrd[ nTab , 03 ] := aOrd[ nTab + 1 , 03 ] := cMarc
					EndIf
				EndIF
				IF Empty( cOrd )
					cOrd 		:= "__NaoOrdenada__"	//Ordem Nao Encontrada
					dDataApo	:= cToD("//")		//Data de Apontamento Nao Encontrada
					IF ( ( nPosDt := aScan( aMarcacoes , { |x| x[ AMARC_DATA ] == aMarcacoes[ nSvTab , AMARC_DATA ] .and. !Empty( x[AMARC_ORDEM] ) } ) ) > 0 )
						IF (;
								(;
									nQtde := 0 ,;
									aEval( aMarcacoes, { |x| IF( x[AMARC_ORDEM] == aMarcacoes[ nPosDt , AMARC_ORDEM ] .And. x[AMARC_TPMCREP] != "D", nQtde++ , NIL ) } ),;
									( nQtde % 2 > 0 );
								 );
							 )
							cOrd 	:= aMarcacoes[ nPosDt , AMARC_ORDEM 	]
							cTno 	:= aMarcacoes[ nPosDt , AMARC_TURNO 	]
							cSeq 	:= aMarcacoes[ nPosDt , AMARC_SEQ 	  	]  
							dDataApo:= aMarcacoes[ nPosDt , AMARC_DATAAPO 	]
						EndIF
					EndIF
				EndIF
				IF (;
						Empty( aMarcacoes[ nSvTab , AMARC_ORDEM ] ) .and.;
						(;
						 	( aMarcacoes[ nSvTab , AMARC_DATA ] == aMarcacoes[ nMar , AMARC_DATA ] ) .or.;
							(;
								nQtde := 0 ,;
								aEval( aMarcacoes, { |x| IF( x[AMARC_ORDEM] == cOrd , nQtde++ , NIL ) } ),;
								( nQtde % 2 > 0 );
							);
						  );
					 )
					aMarcacoes[ nSvTab , AMARC_ORDEM ] 	:= cOrd
					aMarcacoes[ nSvTab , AMARC_TURNO ] 	:= cTno
					aMarcacoes[ nSvTab , AMARC_SEQ   ] 	:= cSeq  
					aMarcacoes[ nSvTab , AMARC_DATAAPO]	:= dDataApo					
				Else
					Exit
				EndIF    
				/*/
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Refaz Status da Marcacao para Reapontar ou Nao			   ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
				Eval(bNoFlag, aMarcacoes[nMar] )
			Next nSvTab
		Next nMar
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Encaixa as Marcacoes Perdidas                                ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		IF ( ( nMar := aScan( aMarcacoes , { |x| ( x[AMARC_ORDEM] == "__NaoOrdenada__" ) } ) ) > 0 )
			For nMar := nMar To nVezMar
				/*/
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Despreza Marcacoes ja Ordenadas                              ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
				IF !( aMarcacoes[ nMar , AMARC_ORDEM ] == "__NaoOrdenada__" )
					Loop
				EndIF
				IF Empty( cMarc := aMarcacoes[ nMar , AMARC_DTHR2STR ] )
					cMarc := DataHora2Str( aMarcacoes[ nMar , AMARC_DATA ] , aMarcacoes[ nMar , AMARC_HORA ] )
				EndIF
				For nTab := 1 To nVezTab Step 2
					IF ( cMarc >= aOrd[ nTab , 5 ] ) .and. ( cMarc <= aOrd[ nTab + 1 , 5 ] )
						//Se o horário pertencer a última ordem, for um dia de DSR cuja data limite posterior seja superior a data de apontamento (turno noturno), verifica se
						//o dia seguinte é um dia trabalhado e se a marcação se encaixa nos limites da jornada do dia seguinte para priorizar a classificação nesse outro dia
						If aOrd[ nTab , 1 ] == cUltOrdem .And. aOrd[ nTab , 8 ] == "D" .And. aOrd[ nTab+1 , 4 ] > aOrd[ nTab+1 , 7 ] .And.;
							!Empty(aCalenAux) .And. aCalenAux[1, CALEND_POS_TIPO_DIA] == "S" .And.;
							cMarc >= DataHora2Str( aCalenAux[1, CALEND_POS_LIM_MARCACAO, 1], aCalenAux[1, CALEND_POS_LIM_MARCACAO, 2] ) .And. cMarc <= DataHora2Str( aCalenAux[Len(aCalenAux), CALEND_POS_LIM_MARCACAO, 1], aCalenAux[ Len(aCalenAux), CALEND_POS_LIM_MARCACAO, 2] )							
								Exit
						EndIf						
						IF !( aMarcacoes[ nMar , AMARC_L_ORIGEM ] )
							aMarcacoes[ nMar , AMARC_ORDEM ]:= aOrd[ nTab , 1 ]
						EndIF
						aMarcacoes[ nMar , AMARC_TURNO ] 	:= aOrd[ nTab , 2 ]  
						aMarcacoes[ nMar , AMARC_DTHR2STR ]	:= cMarc
						aMarcacoes[ nMar , AMARC_SEQ 	] 	:= aOrd[ nTab , 6 ] 
						aMarcacoes[ nMar , AMARC_DATAAPO ] 	:= aOrd[ nTab , 7 ]  						
						Exit
					EndIF
				Next nTab             
 
			Next nMar
		EndIF
	EndIF
	
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Tratamento  de modo a ajustar as marcacoes de saida de jorna ³
	³ da que devido a horas extras recairam na ordem seguinte.     ³
	³ (Inicialmente para tratamento de extras em jornada continua) ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	If lAjustMarc
	 	/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Reordena Calendario conforme Ordem							  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		aSort( @aMarcacoes , NIL , NIL , { |x,y|	(x[AMARC_ORDEM] + x[AMARC_DTHR2STR] );
									 				<;
									     			(y[AMARC_ORDEM] + y[AMARC_DTHR2STR] );
							     		  };
	 		  )

		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Corre Todas as Marcacoes 									   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		nNumMar	:= 0
		cOrdAnt	:= "!!" 
		dDataAnt:= "!!"
		For nMar := 1 To nVezMar
		  	
		  	cOrd	:= aMarcacoes[ nMar , AMARC_ORDEM ] 
	  		dDataApo:= aMarcacoes[ nMar , AMARC_DATAAPO ] 
		  	//-- Se a data da primeira marcacao da ordem for maior ou igual a data final do periodo não considera a 
		  	//-- marcacao pois provavelmente nao foram lidas todas as marcacoes do dia.
		  	If nNumMar == 0 
		  	   	dDataOrd:= aMarcacoes[nMar, AMARC_DATA]
		  	   	If dDataOrd	> dPerFim
		  	   		Loop
		  	   	Endif  
		  	   	
		  	Endif
		  	
			//- Se a ordem mudou  ou se for a Ultima Marcacao
			If ( cOrd <> cOrdAnt ) .or. ( nMar == nVezMar  .and. dDataOrd == aTabCalend[ nPosUltOrdem , CALEND_POS_DATA ])
			   //-- Verifica se houve marcacoes em quantidade impar  para o dia 
			   If (nNumMar % 2) > 0 .or. (  nMar == nVezMar )
			       
			       //-- Obtem as informacoes da ordem anterior a quebra de ordem
		           If ( nMar == nVezMar ) .AND. dDataApo == dPerFim
						/*/
						ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						³ Cria array com as marca‡”es do Proximo Periodo 		  	  ³
						ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			            aMarNextPer	:= {}  
			            aTabClone	:= {}
						GetMarcacoes(	@aMarNextPer				,;	//01 -> Marcacoes dos Funcionarios
										@aTabClone					,;	//02 -> Calendario de Marcacoes
										NIL							,;  //03 -> Tabela Padrao
										NIL							,;  //04 -> Turnos de Trabalho  
										dPerFim+1					,;  //05 -> Periodo Inicial
										dPerFim+7					,;  //06 -> Periodo Final
										cFil						,;  //07 -> Filial
										cMat						,;  //08 -> Matricula 
										NIL							,;	//09 -> Turno
										NIL							,;	//10 -> Sequencia de Turno
										NIL							,;	//11 -> Centro de Custo
										NIL							,;	//12 -> Alias para Carga das Marcacoes
										NIL							,;	//13 -> Se carrega Recno em aMarcacoes
										NIL							,;	//14 -> Se considera Apenas Ordenadas
										NIL							,;  //15 -> Verifica as Folgas Automaticas
										NIL							,;  //16 -> Se Grava Evento de Folga Mes Anterior
										NIL							,;	//17 -> Se Carrega as Marcacoes Automaticas
										NIL							,;	//18 -> Registros de Marcacoes Automaticas que deverao ser Deletados
										NIL							,;	//19 -> Bloco para avaliar as Marcacoes Automaticas que deverao ser Desprezadas
										.F.							,;	//20 -> Se Considera o Periodo de Apontamento das Marcacoes
										.F.							 ;	//21 -> Se Efetua o Sincronismo dos Horarios na Criacao do Calendario
								 	)  

						 /*/
						ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						³ Ordena as marca‡”es                                         ³
						ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
						PutOrdMarc( @aMarNextPer , aTabClone , .T. )   
				  
					    //-- Inicializa contador de quantidade de marcacoes para a ordem
				        nNumMar:= 0 
				        cOrdAnt:=cOrd  
				        dDataAnt:=dDataApo  
				        nVezMar1:= Len(aMarNextPer)
					      
			            //-- Obtem as marcacoes para a primeira ordem do periodo seguinte
			            cOrd	:= "!!" 
			            dDataApo:= "!!"
			            For nMar1 := 1 To nVezMar1        
			                //-- Conta a quantidade de marcacoes para a proxima ordem
			                If ( aMarNextPer[ nMar1 , AMARC_RECNO ] <> aMarcacoes[nMar,AMARC_RECNO])
							    If cOrd == "!!"
			                    	cOrd		:= aMarNextPer[ nMar1 , AMARC_ORDEM ] 
		                    		dDataApo	:= aMarNextPer[ nMar1 , AMARC_DATAAPO ]
			                    	nPrimMarc  	:= nMar1 
			                    Endif
			                    
			                	If aMarNextPer[nMar1, AMARC_ORDEM] == cOrd  
			                   		nNumMar++
			                	Else
			                		Exit
				                Endif
							Endif
			            Next nMar1   
			            
			            //-- Se a quantidade de marcacoes da ordem seguinte for impar
			            //-- Ajusta a primeira marcacao da ordem para a ordem anterior
			            If (nNumMar % 2) > 0
			                AADD(aMarcacoes, aClone( aMarNextPer[nPrimMarc] ) )
			                //Aeval(aMarNextPer, {|x|  AADD( aMarcacoes[ Len( aMarcacoes ) ], aClone( a ) ) } )
						    //-- Seta aMar
	                        nMar := Len(aMarcacoes)
					    Else
					    	Exit
					    Endif                  

                   Endif 
                   
   			       
   			       //-- Se a quantidade de marcacoes da ordem seguinte for impar
		           //-- Ajusta a primeira marcacao da ordem para a ordem anterior
		           If (nNumMar % 2) > 0 .AND. !aMarcacoes[nMar , AMARC_TPMCREP ] == "D"
				  	   aMarcacoes[ nMar , AMARC_ORDEM 		] := cOrdAnt
				  	   aMarcacoes[ nMar , AMARC_TURNO 		] := cTurnoAnt  
				  	   aMarcacoes[ nMar , AMARC_PERAPONTA 	] := cPerAnt    
				  	   aMarcacoes[ nMar , AMARC_SEQ 		] := cSeqAnt 
					   aMarcacoes[ nMar , AMARC_DATAAPO 	] := dDataAnt				  	    
				  	   	/*/
						ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						³ Refaz Status da Marcacao para Reapontar ou Nao			   ³
						ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
						Eval(bNoFlag, aMarcacoes[nMar])
					    nNumMar		:= 0    			       
					    cOrdAnt		:= "!!"
					    dDataAnt	:= "!!"
						Loop
				   Endif 
			   Endif    
		       cOrdAnt		:= aMarcacoes[ nMar , AMARC_ORDEM 		]    
		       cTurnoAnt	:= aMarcacoes[ nMar , AMARC_TURNO 		]   
		       cPerAnt		:= aMarcacoes[ nMar , AMARC_PERAPONTA 	]   
		       cSeqAnt		:= aMarcacoes[ nMar , AMARC_SEQ 		] 
		       dDataAnt		:= aMarcacoes[ nMar , AMARC_DATAAPO		]  		       
			   nNumMar		:= 0    			       
			Endif
			
			nNumMar++
		Next nMar

    Endif
    
    /*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Reordeno corretamente o tipo de marcação nas marcações 	   ³
	³ processadas												   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
    fAltTpMarc(@aMarcacoes)
    
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Refaz Status da Marcacao em funcao de estar ou nao ordenada  ³
	³ e atualiza o periodo de apontamento						   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	PutCposRep( @aMarcacoes,cSpaceOrd,cSpacePer,cPerAponta)
    
    /*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Inclui Data de Apontamento na RFE para as s marcacoes originais  ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	If lPort1510 .And. !lPn010Auto .And. lAtulizRFE
		RFEDataApo(aMarcacoes , aTabCalend, cFil)		
	EndIf
    
End Sequence
	
Return( NIL )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³RFEDataApo  ³ Autor ³Leandro Drumond       ³ Data ³25/03/2010³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Carrega a Data de Apontamento na tabela RFE de acordo com as ³
³          ³marcacoes.                                                   ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³RFEDataApo( aMarcacoes , aTabCalend )						 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³aMarcacoes -> Array com as Marcacoes do Periodo    		     ³
³          ³aTabCalend -> Calendario de Marcacoes do Periodo   		     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL                                                  	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Apontamento                                                  ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function RFEDataApo(aMarcacoes , aTabCalend, cFil)

Local cChave  		:= ""
Local cPerAponta	:= ""
Local cUltOrdem     := ""
Local cChaveSPO     := ""
Local cBckSPO       := ""
Local nMar	  		:= 0
Local nPosUltOrdem	:= 0
Local nVezMar 		:= 0
Local nVezTab 		:= 0
Local lSP0Comp		:= FWModeAccess("SP0",1) == "C" .AND. FWModeAccess("SP0",2) == "C" .AND. FWModeAccess("SP0",3) == "C"

DEFAULT cFil		:= SRA->RA_FILIAL

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Obtem o Numero de Elementos do Calendario de Marcacoes        ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
nVezTab := Len( aTabCalend )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Obtem o Periodo de Apontamento Conforme Calenario de Marcacoes³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
cPerAponta		:= Dtos( aTabCalend[ 01 , CALEND_POS_DATA ] )
cUltOrdem		:= aTabCalend[ nVezTab	, CALEND_POS_ORDEM	]
nPosUltOrdem    := aScan( aTabCalend , { |x| ( x[ CALEND_POS_ORDEM ] == cUltOrdem  ) .and. ( x[CALEND_POS_TIPO_MARC] == "1E" ) } )
cPerAponta		+= Dtos( aTabCalend[ nPosUltOrdem , CALEND_POS_DATA ] )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Corre Todas as Marcacoes 									   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
nVezMar := Len( aMarcacoes )

RFE->(DbsetOrder(RetOrder("RFE","RFE_FILIAL+RFE_EMPORG+RFE_FILORG+RFE_MATORG+RFE_DHORG+RFE_IDORG")))

For nMar := 1 To nVezMar  
	
    cBckSPO	 := cChaveSPO
	cChaveSPO:=	If(aMarcacoes[nMar, AMARC_RELOGIO ] == Nil, "",aMarcacoes[nMar, AMARC_RELOGIO ]) + If(aMarcacoes[nMar, AMARC_NUMREP] == Nil, "",aMarcacoes[nMar, AMARC_NUMREP])
	
    If cBckSPO != cChaveSPO .And. !lSP0Comp
		
		cFil := GetFilSP0(aMarcacoes[nMar, AMARC_RELOGIO], aMarcacoes[nMar, AMARC_NUMREP])
	Endif
	
	If lSP0Comp
		cFil := xFilial("RFE",aMarcacoes[ nMar , AMARC_FILORG])
	EndIf

   	If aMarcacoes[ nMar , AMARC_TIPOREG ] == "O"
		cChave:= xFilial("RFE",cFil)				+ ;
				 aMarcacoes[ nMar , AMARC_EMPORG] 	+ ;
				 aMarcacoes[ nMar , AMARC_FILORG]  	+ ;
				 aMarcacoes[ nMar , AMARC_MATORG]  	+ ;
				 aMarcacoes[ nMar , AMARC_DHORG] 	+ ;
				 aMarcacoes[ nMar , AMARC_IDORG]
		If  RFE->( DbSeek(cChave) ) 
			While RFE->( !EOF() ) .and. ;
			      RFE->( RFE_FILIAL+RFE_EMPORG+RFE_FILORG+RFE_MATORG+RFE_DHORG+RFE_IDORG == cChave )
					
				IF	( RFE->RFE_NUMREP == aMarcacoes[ nMar , AMARC_NUMREP 	] ) .And. ;
					( RFE->RFE_RELOGI == aMarcacoes[ nMar , AMARC_RELOGIO  ] ) .And. ;
					( RFE->RFE_DATA == aMarcacoes[ nMar , AMARC_DATA  ] )
				
					IF RecLock( 'RFE' , .F. )
						RFE->RFE_DATAAP  := aMarcacoes[ nMar , AMARC_DATAAPO ]
						RFE->RFE_PERAPO  := cPerAponta
						RFE->( MsUnLock() )
					EndIF	
				Endif
				RFE->(Dbskip())
			End While		
		EndIf

   	EndIf
	
Next nMar

Return (NIL)

/*/{Protheus.doc} GetFilSP0
Retorna a filial do relógio de acordo com o código e REP passados
@type  Static Function
@author Cícero Alves
@since 17/03/2025
/*/
Static Function GetFilSP0(cRelogio, cREP)
	
	Local cQuery		:= ""
	Local cAliasSP0		:= ""
	Local cCodFilSP0	:= ""
	
	DEFAULT cRelogio := " "
	DEFAULT cREP := " "
	
	Static oSP0Query := NIL
	
	If oSP0Query == NIL
		cQuery := "SELECT P0_FILIAL FROM " + RetSqlName("SP0")
		cQuery += " WHERE P0_RELOGIO = ? " 
		cQuery += " AND P0_REP = ? "
		cQuery += " AND D_E_L_E_T_ = ' '"
		cQuery := ChangeQuery(cQuery)
		oSP0Query := FWExecStatement():New(cQuery)
	EndIf
	
	oSP0Query:SetString(1, cRelogio)
	oSP0Query:SetString(2, cREP)
	
	cAliasSP0 := oSP0Query:OpenAlias()
	
	If (cAliasSP0)->(!EoF())
		cCodFilSP0 := (cAliasSP0)->P0_FILIAL
	EndIf
	
	(cAliasSP0)->(dbCloseArea())
	
Return cCodFilSP0

/*
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³PutCposRep  ³ Autor ³Mauricio MR           ³ Data ³16/10/2009³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Refaz Status da Marcacao em funcao de estar ou nao ordenada  ³
³          ³e atualiza o periodo de apontamento                          ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³PutCposRep( @aMarcacoes,cSpaceOrd,cSpacePer,cPerAponta)		 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³aMarcacoes -> Array com as Marcacoes do Periodo    		     ³
³          ³cSpaceOrd  -> Inicializador do campo Ordem		   		     ³
³          ³cSpacePer  -> Inicializador do campo Periodo                 ³
³          ³cPerAponta -> Periodo de Apontamento 						 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL                                                  	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Apontamento                                                  ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
*/

Static Function PutCposRep( aMarcacoes,cSpaceOrd,cSpacePer,cPerAponta)
Local nMarc	:= Len(aMarcacoes)
Local nx	:= 0 

For nx:= 1 to nMarc

	IF ( aMarcacoes[nx, AMARC_ORDEM] == "__NaoOrdenada__" ) //Se Marcacao nao Ordenada
	     aMarcacoes[nx, AMARC_ORDEM		] 		:= cSpaceOrd 		//Preenche a Ordem com Brancos
		 aMarcacoes[nx, AMARC_APONTA	]		:= "N" 				//Desflega Apontamento
		 aMarcacoes[nx, AMARC_PERAPONTA	]		:= cSpacePer 		//Limpa Periodo de Apontamento  
	 	 aMarcacoes[nx, AMARC_DATAAPO	]	    := Ctod("") 		//Limpa Data de Apontamento										
	Else
		IF !(aMarcacoes[nx, AMARC_L_ORIGEM	])
			aMarcacoes[nx, AMARC_PERAPONTA	] 		:= cPerAponta			//Carrega Periodo de Apontamento
		Endif
	Endif
         
Next nX
Return (Nil)


/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³fTipoExtra  ³ Autor ³Marinaldo de Jesus    ³ Data ³31/03/2001³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Valida os Tipos de Horas Extras                              ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³fTipoExtra( cTipo , @cDescr )              			 		 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³cTipo     -> Tipo das Horas Extras                     		 ³
³          ³cDescr 	  -> Descriacao das Horas Extras               		 ³
³          ³lShowHelp -> Mostrar o Help                            		 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³lRet                                                 	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Apontamento                                                  ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function fTipoExtra( cTipo , cDescr , lShowHelp )

Local aTipos 		:= Array( 16 , 2 )
Local lRet	 		:= .T.
Local nPos	 		:= 0

DEFAULT cTipo		:= ""
DEFAULT cDescr		:= ""
DEFAULT lShowHelp	:= .T.

aTipos[ 01 , 01 ] :=  "1" ; aTipos[ 01 , 02 ] := STR0070 //'Normal'
aTipos[ 02 , 01 ] :=  "2" ; aTipos[ 02 , 02 ] := STR0071 //'D.S.R.'
aTipos[ 03 , 01 ] :=  "3" ; aTipos[ 03 , 02 ] := STR0072 //'Compensado'
aTipos[ 04 , 01 ] :=  "4" ; aTipos[ 04 , 02 ] := STR0073 //'Feriado'
aTipos[ 05 , 01 ] :=  "5" ; aTipos[ 05 , 02 ] := STR0074 //'Normal Noturna'
aTipos[ 06 , 01 ] :=  "6" ; aTipos[ 06 , 02 ] := STR0075 //'D.S.R. Noturna'
aTipos[ 07 , 01 ] :=  "7" ; aTipos[ 07 , 02 ] := STR0076 //'Compensada Noturna'
aTipos[ 08 , 01 ] :=  "8" ; aTipos[ 08 , 02 ] := STR0077 //'Feriado Noturna'
aTipos[ 09 , 01 ] :=  "A" ; aTipos[ 09 , 02 ] := STR0078 //'Intervalo'
aTipos[ 10 , 01 ] :=  "B" ; aTipos[ 10 , 02 ] := STR0079 //'Intervalo Noturna'
aTipos[ 11 , 01 ] :=  "C" ; aTipos[ 11 , 02 ] := STR0195 //'Intervalo DSR'
aTipos[ 12 , 01 ] :=  "D" ; aTipos[ 12 , 02 ] := STR0196 //'Intervalo Noturna DSR'
aTipos[ 13 , 01 ] :=  "E" ; aTipos[ 13 , 02 ] := STR0197 //'Intervalo Compensado'
aTipos[ 14 , 01 ] :=  "F" ; aTipos[ 14 , 02 ] := STR0198 //'Intervalo Noturna Compensado'
aTipos[ 15 , 01 ] :=  "G" ; aTipos[ 15 , 02 ] := STR0199 //'Intervalo Feriado'
aTipos[ 16 , 01 ] :=  "H" ; aTipos[ 16 , 02 ] := STR0200 //'Intervalo Noturna Feriado'

IF ( lRet := ( ( nPos := aScan( aTipos , { |x| x[1] == cTipo } ) ) > 0 ) )
	cDescr := aTipos[ nPos , 2 ]
ElseIF lShowHelp
	Help(" ",1,"CTIPOHE")
EndIF

Return( lRet )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³GetTabArred	³ Autor ³Marinaldo de Jesus    ³ Data ³12/04/2001³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Carrega as Tabelas de Arredondamentos do SPD                 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³GetTabArred( cFil , cTno , cTip )							 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³cFil -> Filial Para a Pesquisa no SP5              		     ³
³          ³cTno -> Turno  Para a Pesquisa no SP5              		     ³
³          ³cTip -> Tipo do Arredondamento a Ser Carregado     		     ³
³          ³        "A" -> Atrasos                             		     ³
³          ³        "D" -> DSR                                 		     ³
³          ³        "F" -> Faltas                              		     ³
³          ³        "H" -> Horas Extras                        		     ³
³          ³        "N" -> Horas Noturnas                      		     ³
³          ³        "S" -> Saidas Antecipadas                  		     ³
³          ³        "9" -> Nona Hora                           		     ³
³          ³lFullTable -> .T. -> Carrega toda a tabela de Arredondamento ³
³          ³               para a Filial informada  	       		     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³aCloneTabArr <=> Array Contendo as Tabelas de Arredondamentos³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Apontamento                                                  ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function GetTabArred( cFil , cTno , cTip, lFullTable )

Local aAux			:= {}
Local bAscan		:= { || .T. }
Local cKey			:= ""
Local cKeyPesq		:= ""
Local cLenTno		:= ""
Local cTipo			:= ""
Local cAlias		:= "SPD"
Local cAliasQuery	:= cAlias
Local lTnoOrFil		:= .T.
Local lAtu			:= .T.    
Local lQueryOpened	:= .F.
Local nArreds		:= 0
Local nTabs			:= 0
Local nPos			:= 0
Local nPosTno		:= 0
Local nOrder		:= RetOrdem( "SPD" , "PD_FILIAL+PD_TIPO+PD_TURNO" )
Local nSvOrder		:= SPD->( IndexOrd() ) 

Local cPrefixo		:= ( PrefixoCpo( cAlias ) + "_" )
Local cQuery		:= ""
Local cSvQuery		:= ""
Local aSvAlias 		:= GetArea()
Local nX			:= 0

Static aSpdFields
Static cQrySpdFields
Static nSpdFields

DEFAULT cTip		:= "ADFHNS9"
DEFAULT cFil		:= SRA->RA_FILIAL
DEFAULT cTno		:= SRA->RA_TNOTRAB
DEFAULT lFullTable	:= .F.  

cAliasQuery := ( "__Q" + cAliasQuery + "QRY" )

DEFAULT aSpdFields := ( cAlias )->( dbStruct() )
DEFAULT nSpdFields := Len( aSpdFields )

IF ( cQrySpdFields == NIL )
	cQrySpdFields := ""
	For nX := 1 To nSpdFields
		cQrySpdFields += aSpdFields[ nX , 01 ] + ", "
	Next nX
EndIF

cLenTno		:= Space( GetSx3Cache( "PD_TURNO  " , "X3_TAMANHO" ) ) 
cTip		:= StrTran( cTip , " " , "" )
cTipo		:= cTip
cFil		:= xFilial( cAlias , cFil )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Monta Bloco para Pesquisa dos Tipos de Arredondamento.       ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
baScan		:= { |x| If(  !lFullTable,;
										 ( ( x[1] == cFil ) .or. Empty( x[1] ) )   	;
									  	  .and.								 	   		;
									     ( ( x[2] == cTno ) .or. Empty( x[2] ) )   	;
									     .and.								 	   		;
									     ( x[3] == cTipo ) 						   		,;
								     	 ( ( x[1] == cFil ) .or. Empty( x[1] ) )   	;
						) ;		     	 
		   		}



DEFAULT	__aTabArr	:= {}
DEFAULT	__aTabFilArr:= {}


/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Se foi Selecionado apenas um Determinado Tipo                ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
IF !lFullTable 
	IF ( nTabs := Len( cTipo ) ) == 1
		IF !Empty( __aTabArr )
			lAtu := ( ( nPos := aScan( __aTabArr , bAscan ) ) == 0 .or. ( nPos > 0 .and. Empty( __aTabArr[nPos , 2] ) ) )
		EndIF
	Else
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Caso contrario Considera Todos os Tipos Validos              ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		cTip := "ADFHNS9"
	EndIF
Else           
    /*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Forca Carregar Todas as Tabelas de Arredondamento da Filial  ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	IF !Empty( __aTabArr )
			lAtu 	:= ( ( nPos := aScan( __aTabArr , bAscan ) ) == 0  )  
	Endif		
	nTabs	:= 1 
	cTip 	:= "ADFHNS9" 
	cTno	:=  cLenTno  
EndIF

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Se a Tabela de Arredondamento Estiver Vazia ou se for forcada³
³ uma Atualizacao											   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
IF ( Empty( __aTabArr ) .or. ( lAtu ) )
	
	IF !Empty( nTabs )

		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Seta a Ordem para Pesquisa                                   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		IF !( nSvOrder == nOrder )
			SPD->( dbSetOrder( nOrder ) )
		EndIF

		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Verifica os Tipos de Arredondamento                          ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		For nArreds := 1 To nTabs
		    
		

			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³Verifica se o Tipo em Questao ja foi Carregado e se possui con³
			³teudo														   ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/  
			IF !lFullTable 
				cTipo := SubStr( cTip , nArreds , 1 )
				lAtu:= ( ( ( nPos := aScan( __aTabArr , bAscan ) ) == 0 )  .or. ( nPos > 0 .and. Empty( __aTabArr[nPos , 2] ) ) )
			Else	                                 
				cTipo := SPACE(1)
				lAtu:= ( ( nPos := aScan( __aTabArr , bAscan ) ) == 0 )
			Endif
			
			If 	lAtu
				/*/
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³Monta Query para pesquisa do Turno Especifico                 ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
				cQuery		:= "SELECT "
				cQuery		+= cQrySpdFields
				cQuery		:= SubStr( cQuery , 1 , Len( cQuery ) - 2 )
				cQuery		+= " FROM "
				cQuery		+= InitSqlName( cAlias )
				cQuery		+= " WHERE "
				cQuery		+= cPrefixo+"FILIAL='"+cFil+"'"
				cQuery		+= " AND " 
				If !lFullTable
					cQuery		+= cPrefixo+"TIPO='"+cTipo+"'"
					cQuery		+= " AND "
					cQuery		+= cPrefixo+"TURNO='"+cTno+"'"
					cQuery		+= " AND "
				Endif	
				cQuery		+= "D_E_L_E_T_=' ' "
				cQuery		+= "ORDER BY " + SqlOrder( (cAlias)->( IndexKey() ) )
				cSvQuery	:= cQuery
				cQuery		:= ChangeQuery( cQuery )
				/*/
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³Verifica se conseguiu Montar a Query                          ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
				IF ( lQueryOpened := MsOpenDbf(.T.,"TOPCONN",TcGenQry(NIL,NIL,cQuery),cAliasQuery,.F.,.T.) )
					For nX := 1 To nSpdFields
						IF !( aSpdFields[ nX , 02 ] == "C" )
							TcSetField(cAliasQuery,aSpdFields[nX,01],aSpdFields[nX,02],aSpdFields[nX,03],aSpdFields[nX,04])
						EndIF
					Next nX
					
					/*/
					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					³Se nao achou o Turno Especifico	                           ³
					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
					lTnoOrFil := ( cAliasQuery )->( !Eof() )  
					
					IF !( lTnoOrFil )
						( cAliasQuery )->( dbCloseArea() )	
						IF !lFullTable
							/*/
							ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
							³Monta Query para pesquisa do Turno Generico ( Em Branco )     ³
							ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
							cQuery := StrTran( cSvQuery , ( "TURNO='"+cTno+"'" ) , ( "TURNO='"+cLenTno+"'" ) )
							cQuery := ChangeQuery( cQuery )
							/*/
							ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
							³Verifica se conseguiu Montar a Query para o Turno Generico    ³
							ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
							IF ( lQueryOpened := MsOpenDbf(.T.,"TOPCONN",TcGenQry(NIL,NIL,cQuery),cAliasQuery,.F.,.T.) )
								For nX := 1 To nSpdFields
									IF !( aSpdFields[ nX , 02 ] == "C" )
										TcSetField(cAliasQuery,aSpdFields[nX,01],aSpdFields[nX,02],aSpdFields[nX,03],aSpdFields[nX,04])
									EndIF
								Next nX
								/*/
								ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
								³Se nao Existia o Tipo para o Turno Generico (Em Branco)       ³
								ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
								IF ( nPos == 0 )
									/*/
									ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
									³Pesquisa o Turno Generico ( Em Branco )                       ³
									ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
									IF ( cAliasQuery )->( Eof() )
										/*/
										ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
										³Se nao Encontrou o Turno Generico, carrega Tabela Vazia       ³
										ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
										aAdd( __aTabArr , { cFil , cLenTno , cTipo , {} } )
										( cAliasQuery )->( dbCloseArea() )
										Loop
									EndIF
								EndIF
							Else
								/*/
								ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
								³Caso contrario Pesquisa Direto no Arquivo                     ³
								ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
								cAliasQuery := cAlias
							EndIF
						Else
							/*/
							ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
							³Se nao Existia o Tipo para o Turno Generico (Em Branco)       ³
							ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
							IF ( nPos == 0 )
								/*/
								ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
								³Se nao Encontrou a Filial, carrega Tabela Vazia       		   ³
								ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
								aAdd( __aTabArr , { cFil , cLenTno , cTipo , {} } )
								Loop                                                                       
							Endif	
						Endif	
					Endif	
				Else
					/*/
					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					³Caso contrario Pesquisa Direto no Arquivo                     ³
					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
					cAliasQuery := cAlias
				EndIF

				IF !( lQueryOpened )
					/*/
					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					³Procura pelo Turno Especifico	 		                       ³
					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/ 
					IF !lFullTable
						cKeyPesq 	:=  cFil + cTipo + cTno 
					Else                                       
						cKeyPesq 	:=  cFil 
					Endif
					
					lTnoOrFil := ( cAliasQuery )->( dbSeek( cKeyPesq ) ) 

					/*/
					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					³Se nao Existe o Turno Especifico procura pelo Generico        ³
					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/ 
					IF !( lTnoOrFil )
						IF !lFullTable
							/*/
							ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
							³Se nao Existia o Tipo para o Turno Generico (Em Branco)       ³
							ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
							IF ( nPos == 0 )
								/*/
								ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
								³Pesquisa o Turno Generico ( Em Branco )                       ³
								ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
								IF ( cAliasQuery )->( !dbSeek( cFil + cTipo + cLenTno ) )
									/*/
									ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
									³Se nao Encontrou o Turno Generico, carrega Tabela Vazia       ³
									ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
									aAdd( __aTabArr , ( cAliasQuery )->( { cFil , PD_TURNO , PD_TIPO , {} } ) )
									Loop
								EndIF
							Endif	
						Else
							If ( nPos == 0 )
								/*/
								ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
								³Se nao Encontrou a Filial, carrega Tabela Vazia       		   ³
								ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
								aAdd( __aTabArr , { cFil , cLenTno , cTipo , {} } )
								Loop
							Endif	
						EndIF
					Endif	
                EndIF
				
				/*/
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Se Encontrou o Turno e Este ainda nao Esta Carregado         ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
				IF ( ( lTnoOrFil ) .or. ( nPos == 0 ) )
				
					If !lFullTable
						/*/
						ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						³ Carrega as Informacoes para o Turno						   ³
						ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
						aAdd( __aTabArr , { cFil , IF( lTnoOrFil , cTno , cLenTno ) , cTipo , {} } )
						nPos := Len( __aTabArr )
	
						/*/
						ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						³ Carrega os Itens para o Turno      						   ³
						ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
						cKey := ( cFil + cTipo + IF( lTnoOrFil , cTno , cLenTno ) )
						While ( cAliasQuery )->( !Eof() .and. PD_FILIAL+PD_TIPO+PD_TURNO == cKey )
						    ( cAliasQuery )->( aAdd( __aTabArr[ nPos , 4 ] , { PD_DE , PD_ATE , PD_HORAS } ) )
							( cAliasQuery )->( dbSkip() )
						End While
                    Else 
						/*/
						ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						³ Carrega todos Itens para Filial      						   ³
						ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/  
						cKey:= ""
						While ( cAliasQuery )->( !Eof() .and. ( PD_FILIAL == cFil ) )
							If ( cKey <> ( cAliasQuery )->( cFil + PD_TIPO + PD_TURNO )  )
							     cKey := ( cAliasQuery )->( cFil + PD_TIPO + PD_TURNO )  
								/*/
								ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
								³ Carrega as Informacoes para a Filial + Tipo + Turno		   ³
								ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
								aAdd( __aTabArr , ( cAliasQuery )->( { cFil , PD_TURNO , PD_TIPO , {} } ) )
								nPos := Len( __aTabArr )								
							Endif	                    
					    	( cAliasQuery )->( aAdd( __aTabArr[ nPos , 4 ] , { PD_DE , PD_ATE , PD_HORAS } ) )
							( cAliasQuery )->( dbSkip() )
						End While
                    Endif
				EndIF

				/*/
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³Se Montou a Query, Fecha-a                                    ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
				IF ( ( lQueryOpened ) .and. ( Select( cAliasQuery ) > 0 ) )
					( cAliasQuery )->( dbCloseArea() )
				EndIF
				
			EndIF
	
		Next nArreds

		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Restaura a Ordem de Entrada         					   	   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		IF !( nSvOrder == nOrder )
			SPD->( dbSetOrder( nSvOrder ) )
		EndIF

	Else

		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Neste Caso nao Foi passado Nenhum Tipo de Arredondamento 	   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		aAdd( __aTabArr , { "" , "" , "" , {} } )

	EndIF
	
EndIF

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Garante o Fechamento da Query no retorno da funcao           ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
IF ( Select( cAliasQuery ) > 0 )
	( cAliasQuery )->( dbCloseArea() )
EndIF
/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Restaura dados de Entrada                                    ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
RestArea( aSvAlias )

If !lFullTable .And. Len(__aTabArr) > 1 .And. (nPosTno := aScan( __aTabArr, { |x| x[2] == cTno } ) ) > 0
	aAux	:= { aClone( __aTabArr[nPosTno] ) }
Else
	aAux	:= aClone( __aTabArr )
EndIf

Return( aAux )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³RstGetTabArred	³Autor³Marinaldo de Jesus ³ Data ³11/03/2003³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Reinicializa as Staticas utilizadas em GetTabArred()       	³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico													³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function RstGetTabArred() 
__aTabArr 		:= 	NIL 
__aTabFilArr	:=  NIL
Return( NIL )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³RetTabArred	³ Autor ³Marinaldo de Jesus    ³ Data ³10/04/2002³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Retorna Tabela de Arredondamento Especifica baseada no  Array³
³          ³Carregado Atraves de GetTabArred()							 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³RetTabArred( aArreds , cFil , cTno , cTip )					 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³aArreds -> Array com todos as Tabelas de Arredondamentos	 ³
³          ³cFil 	-> Filial para Procura								 ³
³          ³cTno	-> Turno  Para a Pesquisa no SP5              		 ³
³          ³cTipo	-> Tipo do Arredondamento a Ser Carregado     		 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³aArred  -> Tabela com Arredondamento Especifico				 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Apontamento                                                  ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function RetTabArred( aArreds , cFil , cTno , cTipo )

Local aArred := {}
Local bAscan := { || .T. }
Local nPosAr := 0

baScan	:= { |x| ( ( x[1] == cFil ) .or. Empty( x[1] ) ) ;
			  	 .and.								 	 ;
			      ( x[2] == cTno )						 ;
			     .and.								 	 ;
			     ( x[3] == cTipo )						 ;
			}

IF ( ( nPosAr := aScan( aArreds , bAscan ) ) == 0 )
	baScan	:= { |x| ( ( x[1] == cFil ) .or. Empty( x[1] ) ) ;
				  	 .and.								 	 ;
				     Empty( x[2] )							 ;
				     .and.								 	 ;
			    	 ( x[3] == cTipo )						 ;
				}
	nPosAr := aScan( aArreds , bAscan )
EndIF

IF ( nPosAr > 0 )
	aArred := aClone( aArreds[ nPosAr , 4 ] )
EndIF

Return( aClone( aArred ) )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³fArredHoras	³ Autor ³Marinaldo de Jesus    ³ Data ³12/04/2001³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Efetua o Arredondamento de Horas de Acordo com o Array       ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³nHrs   -> Horas Arredondadas                                 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Apontamento                                                  ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function fArredHoras(	nHrs		,;	//01 -> Horas a Serem Arredondadas
						aArrs		,;	//02 -> Array com os Arredondamentos
						cTip		,;	//03 ->	Tipo de Horas a Arredondar:"A"trasos ; "D"SR ; "F"altas ; "H"oras Extras ; "N"Horas Noturnas ; "S"aidas Antecipadas
						cFil		,;	//04 -> Filial Para a Pesquisa no SP5
						cTno		,;	//05 -> Turno  Para a Pesquisa no SP5
						lArrdIntegr	 ;	//06 -> Se Arredonda as Horas Integralmente	
					 )
                                                          
Local nArrVal		:= 0
Local nArre			:= 0
Local nLenArre		:= 0

DEFAULT nHrs		:= 0
DEFAULT aArrs		:= {}
DEFAULT cTip		:= ""
DEFAULT cFil		:= SRA->RA_FILIAL
DEFAULT cTno		:= SRA->RA_TNOTRAB
DEFAULT lArrdIntegr	:= .F.

IF ( !Empty( cTip ) .and. Empty( aArrs ) )
	aArrs := ( GetTabArred( cTip , cFil , cTno  )[ 1 , 3 ] )
EndIF

nLenArre := Len( aArrs )
For nArre := 1 To nLenArre
	nArrVal := IF( !( lArrdIntegr ) , SubHoras( nHrs , __NoRound( nHrs , 0 ) ) , nHrs )
	IF (;
			( __NoRound( nArrVal , 2 ) >= __NoRound( aArrs[ nArre , 1 ] , 2 ) );
			.and.;
  	   		( __NoRound( nArrVal , 2 ) <= __NoRound( aArrs[ nArre , 2 ] , 2 ) );
  	   	)	
		IF !( lArrdIntegr )
			nHrs := SomaHoras( __NoRound( nHrs , 0 ) , aArrs[ nArre , 3 ] )
		Else
			nHrs := aArrs[ nArre , 3 ]
		EndIF
		Exit
	EndIF
Next nArre

Return( nHrs )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³GetTabExtra	³ Autor ³Marinaldo de Jesus    ³ Data ³16/04/2001³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Carrega Array com os Tipos de Horas Extras                   ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³lRet      -> True se Conseguir Carregar os Tipos de H.E.     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Apontamento                                                  ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function GetTabExtra(	aTabExtra		,;	//01 -> Array a ser Carregado com os Tipos de H.E.
						cFil			,;	//02 -> Filial para Pesquisa no SP4
						cTno			,;	//03 -> Turno para Pesquisa no SP4
						lTodas			,;	//04 -> Atualizar as Tabelas de Horas Extras
						lShowHelp		,;	//05 -> Mostrar o Help
						lEscalonar		,;	//06 -> Se trata o escalonamento
						nErrorNumber	,;	//07 -> Numero de retorno de erro. 1 - Tabela de HE nao encontrada 2 - Tabela de HE nao configurada corretamente
						cHelp			,;	//08 -> Mensagem Complementar ao Help ( Retorno por Referencia )
						lRstTabEx		,;	//09 -> Atualiza tabela de eventos ao quebrar a filial
						cFilCCT		 	,;	//10 -> Filial da Convenção Coletiva de Trabalho
						cCodCCT		 	 ;	//11 -> Código da Convenção Coletiva de Trabalho
					 )

Local aEscala		:= {}
Local baScan		:= { || .T. }
Local cAlias		:= "SP4"
Local cAliasQuery	:= cAlias
Local cTpHe			:= ""
Local cTnoAux		:= "#####"
Local lRet			:= .F.
Local lModFil		:= .F. 
Local lQueryOpened	:= .F.
Local nPos			:= 0
Local nOrder		:= RetOrdem( "SP4" , "P4_FILIAL+P4_TURNO+P4_TIPO" )
Local nSvOrder		:= SP4->( IndexOrd() ) 

Local aSvAlias		:= GetArea()
Local cPrefixo		:= ( PrefixoCpo( cAlias ) + "_" )
Local cQuery		:= ""
Local cSvQuery		:= ""
Local cSvTno		:= ""	
Local nX			:= 0

Static aSp4Fields
Static cQrySp4Fields
Static nSp4Fields
Static lFirstHelp := .T.
Static lCpoCCT

DEFAULT cFil			:= SRA->RA_FILIAL
DEFAULT cTno			:= SRA->RA_TNOTRAB
DEFAULT nErrorNumber	:= 0   
DEFAULT lTodas			:= .F.
DEFAULT lShowHelp		:= .F.
DEFAULT __aTabEx		:= {}
DEFAULT lRstTabEx		:= .F.
DEFAULT cFilCCT			:= "" 
DEFAULT cCodCCT			:= ""

cAliasQuery := ( "__Q" + cAliasQuery + "QRY" )

DEFAULT aSp4Fields := ( cAlias )->( dbStruct() )
DEFAULT nSp4Fields := Len( aSp4Fields )
DEFAULT lCpoCCT	   :=  SP4->(ColumnPos("P4_CODCCT") > 0)


lCpoPer := If(lCpoPer != NIL, lCpoPer, SP4->(ColumnPos("P4_PERHEXT") > 0))

IF ( cQrySp4Fields == NIL )
	cQrySp4Fields := ""
	For nX := 1 To nSp4Fields
		cQrySp4Fields += aSp4Fields[ nX , 01 ] + ", "
	Next nX
EndIF

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Se o parametro de escalonamento foi passado				  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
IF !( lEscalonar == NIL )
   __lEscalonamento	:= lEscalonar
Else
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Se eh a primeira vez ou ocorreu quebra de filial E NAO    foi³
	³para escalonar Obtem o parametro de escalonamento			  ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	IF ( lModFil := ( ( cFilStatic == NIL )  .or. ( cFilStatic != cFil    ) ) )
		__lEscalonamento	:=	NIL
		cFilStatic			:= 	cFil
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Considerar Todas as Horas Extras do Dia Para o Escalonamento ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
    	DEFAULTFIL __lEscalonamento := ( SuperGetMv("MV_ACMHEXT",,"N",cFil) == "S" )
	EndIF
EndIF

aTabExtra	:= {}
baScan		:= { |x| ( x[1] == cFil .or. Empty( x[1] ) )	;
					  .and.									;
					 ( x[2] == cTno .or. Empty( x[2] ) )    ;
			   }

cFil := xFilial( cAlias , cFil )

If lRstTabEx
	__aTabEx	:= {}
EndIf

IF ( Empty( __aTabEx ) .or. ( !lTodas .and. ( nPos := aScan( __aTabEx , baScan ) ) == 0 .or. ( nPos > 0 .and. Empty( __aTabEx[ nPos , 2 ] ) ) ) )
	
	IF !( nOrder == nSvOrder )
		( cAlias )->( dbSetOrder( nOrder ) )
	EndIF
	
	cQuery := "SELECT "
	cQuery += cQrySp4Fields
	cQuery := SubStr( cQuery , 1 , Len( cQuery ) - 2 )
	cQuery += " FROM "
	cQuery += InitSqlName( cAlias )
	cQuery += " WHERE "
	cQuery += cPrefixo+"FILIAL='"+cFil+"'"
	cQuery += " AND "
	IF !( lTodas )
		cQuery += cPrefixo+"TURNO='"+cTno+"'"
		cQuery += " AND "
		cSvTno := cTno
	EndIF
	If lCpoCCT
		If !Empty(cCodCCT)
			cQuery += "( P4_CODCCT = '' "
			cQuery += "AND P4_TIPO NOT IN (SELECT P4_TIPO FROM " + InitSqlName( cAlias ) + " WHERE P4_FILCCT = '" + cFilCCT + "' AND P4_CODCCT = '" + cCodCCT + "' AND D_E_L_E_T_=' ' ) "
			cQuery += "OR (P4_FILCCT = '" + cFilCCT + "' AND P4_CODCCT = '" + cCodCCT + "'))"
			cQuery += " AND "
		Else
			cQuery += "P4_CODCCT = '' AND "
		EndIf
	EndIF
	cQuery += "D_E_L_E_T_=' ' "
	cQuery += "ORDER BY " + SqlOrder( (cAlias)->( IndexKey() ) )
	
	cSvQuery	:= cQuery
	cQuery		:= ChangeQuery( cQuery )
	
	IF ( lQueryOpened := MsOpenDbf(.T.,"TOPCONN",TcGenQry(NIL,NIL,cQuery),cAliasQuery,.F.,.T.) )
		For nX := 1 To nSp4Fields
			IF !( aSp4Fields[ nX , 02 ] == "C" )
				TcSetField(cAliasQuery,aSp4Fields[nX,01],aSp4Fields[nX,02],aSp4Fields[nX,03],aSp4Fields[nX,04])
			EndIF
		Next nX
		IF !( lRet := ( cAliasQuery )->( !Eof() ) )
			IF !( lTodas )
				( cAliasQuery )->( dbCloseArea() )
				cTno	:= Space( GetSx3Cache( "P4_TURNO  " , "X3_TAMANHO" ) )
				cQuery	:= StrTran( cSvQuery , ( "TURNO='"+cSvTno+"'" ) , ( "TURNO='"+cTno+"'" ) )
				cQuery	:= ChangeQuery( cQuery )
				IF ( lQueryOpened := MsOpenDbf(.T.,"TOPCONN",TcGenQry(NIL,NIL,cQuery),cAliasQuery,.F.,.T.) )
					For nX := 1 To nSp4Fields
						IF !( aSp4Fields[ nX , 02 ] == "C" )
							TcSetField(cAliasQuery,aSp4Fields[nX,01],aSp4Fields[nX,02],aSp4Fields[nX,03],aSp4Fields[nX,04])
						EndIF
					Next nX 
					IF ( nPos == 0 )
						IF !( lRet := ( cAliasQuery )->( !Eof() ) )
							( cAliasQuery )->( dbCloseArea() )
						EndIF
					EndIF
				EndIF
			EndIF
		EndIF
    EndIF
	
	IF !( lQueryOpened )
		
		cAliasQuery := cAlias
		IF ( lTodas )
			lRet := ( cAliasQuery )->( dbSeek( cFil , .F. ) )
		Else
			IF !( lRet := ( cAliasQuery )->( dbSeek( cFil + cTno ) ) )
				IF ( nPos == 0 )
					lRet := ( cAliasQuery )->( dbSeek( cFil + ( cTno := Space( GetSx3Cache( "P4_TURNO  " , "X3_TAMANHO" ) ) ) ) )
				EndIF
			EndIF
		EndIF
	EndIF
	
	IF ( ( lRet ) .and. ( Select( cAliasQuery ) > 0 ) )
		If !lTodas
			aAdd( __aTabEx , { cFil , cTno , {} } )
		EndIf
		While ( cAliasQuery )->( !Eof() .and. cFil == P4_FILIAL .and. IF( lTodas , lTodas , cTno == P4_TURNO ) )
			If lTodas .and. cTnoAux <> ( cAliasQuery )->P4_TURNO
				If Empty(( cAliasQuery )->P4_TURNO)
					aAdd( __aTabEx , { cFil , "TODAS" , {} } )
				Else
					aAdd( __aTabEx , { cFil , ( cAliasQuery )->P4_TURNO , {} } )
				EndIf
				cTnoAux := ( cAliasQuery )->P4_TURNO
			EndIf
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³Adiciona a Informacao da Tabela de Hora Extras em Array  auxi³
			³liar para verificar consistencia da mesma para uso do  escalo³
			³namento de horas											  ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			( cAliasQuery )->( aAdd( aEscala , { P4_TIPO , P4_DE , P4_ATE ,P4_CODAUT , P4_CODNAUT }  ) )
			
			// Carrega a Tabela de Horas Extras
			If lCpoPer
				(cAliasQuery)->(aAdd(__aTabEx[Len(__aTabEx), 3], {P4_TIPO, P4_DE, P4_ATE, P4_CODAUT, P4_CODNAUT, P4_PERCENT, P4_PERHEXT, P4_TOLHEPE}))
			Else
				( cAliasQuery )->( aAdd( __aTabEx[ Len( __aTabEx ) , 3 ] , { P4_TIPO , P4_DE , P4_ATE ,P4_CODAUT , P4_CODNAUT, P4_PERCENT } ) )
			EndIf
			( cAliasQuery )->( dbSkip() )
		EndDo
		
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Se foi solicitada a interrupcao do processamento ao   ocorrer³
		³alguma inconsistencia, procedemos com a verificacao da  incon³
		³sistencia para efeito de escalonamento					      ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		IF ( __lEscalonamento )
			IF !( lRet := fVerEscala( aEscala, @cHelp ) )
        		If lShowHelp
					cHelp := STR0155 + " " + cHelp //-- "Tabela de Horas Extras Nao Configurada para Escalonamento"
        			nErrorNumber	:= 2.00		//-- Retorno de erro para a funcao chamadora
				ElseIf IsInCallStack("PONM010") .And. lFirstHelp
					lFirstHelp := .F.
					Aadd(aLogFile, "- " + STR0155 + cHelp)
				EndIf
	   		EndIF
		EndIF
		
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Se Estiver Ok Monta a Tabela de Horas Extras				  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		IF ( lRet )
			IF !( lTodas ) 
				baScan := { |x| ( x[1] == cFil .or. Empty( x[1] ) )	.and. ( x[2] == cTno )}
				IF ( ( nPos := aScan( __aTabEx , baScan ) ) == 0 )
					baScan := { |x| ( x[1] == cFil .or. Empty( x[1] ) )	.and.Empty( x[2] )}
					nPos := aScan( __aTabEx , baScan )
				EndIF		
			EndIF
		EndIF
	EndIF
	
	IF ( ( lQueryOpened ) .and. ( Select( cAliasQuery ) > 0 ) )
		( cAliasQuery )->( dbCloseArea() )
	EndIF	
	
	IF !( nOrder == nSvOrder )
		( cAlias )->( dbSetOrder( nSvOrder ) )
	EndIF

EndIF

IF ( lTodas .And. lRet .And. ( lRet := !Empty( __aTabEx ) ) )
	aEval( __aTabEx , { |x,y| IF( __aTabEx[y,1] == cFil , aAdd( aTabExtra , aClone( __aTabEx[y,3] ) ) , NIL ) } )
ElseIF ( lRet := ( nPos > 0 ) )
	aTabExtra := aClone( __aTabEx[ nPos , 3 ] )
	cTpHe := ""
	//Obtem todos os tipos com turno
	aEval( aTabExtra , { |x| cTpHe += x[1]} )
	nPos:= Ascan( __aTabEx, {|x| x[2] == "TODAS" } )
	If nPos > 0 .and. Len(__aTabEx[nPos][3]) > 0
		//Inclui todos os demais tipos genéricos
		aEval( __aTabEx[nPos][3] , { |x| IF( !(x[1] $ cTpHe), aAdd( aTabExtra , aClone( x ) ) , NIL ) } )
	EndIf
EndIf

IF ( ( lShowHelp ) .And. !( lRet ) ) .And. lFirstHelp
    IF !Empty( cHelp ) 
		// "Verifique o cadastro de tipos de horas hextra. Certifique que todos os 8 tipos estão cadastradaos e que as faixas estão corretas."
		Help(NIL, NIL, "TABHENCAD", NIL, cHelp, 1, 0, NIL, NIL, NIL, NIL, NIL, {STR0242})
	Else
		HELP(" ", 1, "TABHENCAD" )
	EndIF
	lFirstHelp := .F.
EndIF

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Fornece o numero de erro ao executar a funcao  ( considerando³
³que nao ocorreu algum ainda) se nao foi encontrada a   tabela³
³de He para a chave de pesquisa (filial e/ou turno).		  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
IF Empty(nErrorNumber)
   nErrorNumber := IF( !( lRet ) , 1 , 0 )
EndIF

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Garante o Fechamento da Query no retorno da funcao           ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
IF ( Select( cAliasQuery ) > 0 )
	( cAliasQuery )->( dbCloseArea() )
EndIF	
/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Restaura dados de Entrada                                    ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
RestArea( aSvAlias )

Return( lRet )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³RstGetTabExtra	³Autor³Marinaldo de Jesus ³ Data ³11/03/2003³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Reinicializa as Staticas utilizadas em GetTabExtra()		³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico													³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function RstGetTabExtra()

__aTabEx			:= NIL
__lEscalonamento	:= NIL	
cFilStatic			:= NIL

Return( NIL )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³fTpoExtra   ³ Autor ³Marinaldo de Jesus   ³ Data ³28/09/2000³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Retorna o Tipo de Horas Extras de Acordo com o Dia          ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³Tipo de Hora Extra                                    	    ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      		³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Uso      ³Apontamento                                                 ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function fTpoExtra(	dData		,;	//Data para pesquisa do Tipo de Hora Extra
					aTabClone	,;	//Copia do Array com o Calendario de Marcacoes
					nPosCalend	,;	//Indice em aTabCalend
					aTabPadrao	 ;  //Array Tabela de Horario Padrao
				  )

Local aSvTabsCal
Local cTpExtra
Local nPos

DEFAULT dData		:= Ctod("//")
DEFAULT aTabClone	:= {}
DEFAULT nPosCalend	:= 0
DEFAULT aTabPadrao	:= {}

Begin Sequence

	IF !Empty( aTabClone ) .and. IF( Empty( nPosCalend ) , ( nPos := aScan( aTabClone, { |x| x[ CALEND_POS_DATA_APO ] == dData .and. x[ CALEND_POS_TIPO_MARC ] == "1E" } ) ) > 0 ,( nPos:= nPosCalend, .T. ) )
		nPosCalend := nPos
	Else
		aTabClone	:= {}
		//Salva o Conteudo do Calendario por Turno
		aSvTabsCal	:= GetTabCal()
 		//Cria o Calendario para a Data
		IF ( SRA->( CriaCalend(	dData		,;	//01 -> Data Inicial do Periodo
								dData		,;	//02 -> Data Final do Periodo
								RA_TNOTRAB	,;	//03 -> Turno Para a Montagem do Calendario
								RA_SEQTURN	,;	//04 -> Sequencia Inicial para a Montagem Calendario
								aTabPadrao	,;	//05 -> Array Tabela de Horario Padrao
								@aTabClone	,;	//06 -> Array com o Calendario de Marcacoes
								RA_FILIAL	,;	//07 -> Filial para a Montagem da Tabela de Horario
								RA_MAT		,;	//08 -> Matricula para a Montagem da Tabela de Horario
								RA_CC		,;	//09 -> Centro de Custo para a Montagem da Tabela
								NIL    		,;	//10 -> Array com as Trocas de Turno
								NIL     	,;	//11 -> Array com Todas as Excecoes do Periodo
								NIL         ,;	//12 -> Se executa Query para a Montagem da Tabela Padrao
								.F.			,;	//13 -> Se executa a funcao se sincronismo do calendario
								NIL      	 ;	//14 -> Se Forca a Criacao de Novo Calendario
							 );
					);
			)
			IF ( ( nPos := aScan( aTabClone, { |x| x[ CALEND_POS_DATA ] == dData .and. x[ CALEND_POS_TIPO_MARC ] == "1E" } ) ) > 0 )
				nPosCalend := nPos
			EndIF
		EndIF
	EndIF
	
	IF ( nPosCalend > 0 )
		IF ( aTabClone[ nPosCalend , CALEND_POS_APON_FERIAS ] )
			cTpExtra := aTabClone[nPosCalend,CALEND_POS_TP_HE_NT_FER]+"-"+aTabClone[nPosCalend,CALEND_POS_TP_HE_NR_FER]
		Else
			IF ( aTabClone[ nPosCalend , CALEND_POS_FERIADO ] )				//Dia Corresponde a Feriado
				IF ( aTabClone[ nPosCalend , CALEND_POS_EXCECAO ] == "E" )	//Dia Corresponde a Excecao em Feriado
					cTpExtra := aTabClone[nPosCalend,CALEND_POS_TIPO_HE_NOT]+"-"+aTabClone[nPosCalend,CALEND_POS_TIPO_HE_NOR]
				Else
					IF !( aTabClone[ nPosCalend , CALEND_POS_TRAB_FERIADO ] )	//Se nao Trabalha em Feriado
						cTpExtra	:= IF(Empty(aTabClone[ nPosCalend , CALEND_POS_TP_HE_FER_NT ]),"8",aTabClone[ nPosCalend , CALEND_POS_TP_HE_FER_NT ])
						cTpExtra	+= "-"
						cTpExtra	+= IF(Empty(aTabClone[ nPosCalend , CALEND_POS_TP_HE_FER_NR ]),"4",aTabClone[ nPosCalend , CALEND_POS_TP_HE_FER_NR ])
					Else                        //Trabalha em Feriado
						cTpExtra := aTabClone[ nPosCalend , CALEND_POS_TIPO_HE_NOT ] + "-" + aTabClone[ nPosCalend , CALEND_POS_TIPO_HE_NOR ]
					EndIF
				EndIF
			Else
				cTpExtra := aTabClone[ nPosCalend , CALEND_POS_TIPO_HE_NOT ]+"-"+aTabClone[ nPosCalend , CALEND_POS_TIPO_HE_NOR ]
			EndIF
		EndIF
	EndIF

End Sequence
	
cTpExtra := IF( Empty( cTpExtra ) , "5-1" , cTpExtra ) //DEFAULT

//Restaura o Conteudo do Calendario por Turno
IF ( aSvTabsCal <> NIL )
	SetTabCal( aSvTabsCal )
EndIF

Return( cTpExtra )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³fVerEscala	³ Autor ³Mauricio MR           ³ Data ³12/11/2002³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Consiste a Tabela de HE para uso com Escalonamento de Horas  ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³fVerEscala( aTabHE )									     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³aTabHE   -> Array de um Turno/Filial a Ser Consistido.		 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³lRet     -> True se OK ou .F. se houver inconsistencia       ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Funcao GetTabExtra()                                         ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function fVerEscala(aTabHE, cHelp)  

Local aCompara	:= {'1-5','2-6','3-7','4-8','A-B','C-D','E-F','G-H'}  
Local aDiurno	:= {}
Local aNoturno	:= {}
Local cTipo		:= ''
Local cTipoPar	:= ''
Local lRet		:= .T.
Local nLenaTab  := Len(aTabHE)     
Local cTipoAnt	:= ''
Local nDiurno	:= 0
Local nNoturno	:= 0
Local nPos		:= 0
Local nFaixas	:= 0

//-- Percorre todos os tipos de HE
For nFaixas := 1 To nLenaTab
       
    //-- Para cada Tipo lido procura o seu Tipo "Noturno" correspondente     
    cTipo:=aTabHE[nFaixas, 1] 
    
    //-- Despreza Faixas de Tipos ja lidos e Despreza noturnos
    If  (cTipoAnt == cTipo) .OR. (cTipo >'4' .AND. !(cTipo $'ACEG'))
       Loop
    Endif
  
    //-- Se nao encontrou o correspondente Noturno
    If Empty( nPos:= Ascan( aCompara, {|cPar| cTipo == Substr(cPar,1,1) } ) )
       //-- Obtem o proximo
       Loop
    Endif      

    //-- Extrai o noturno correspondente
    cTipoPar:=Substr(aCompara[nPos],-1,1)
    
    //-- Iguala variavel auxiliar que mantera o ultimo tipo lido para evitar processamento desnecessario
    cTipoAnt:=cTipo

    //-- Monta array com as faixas do tipo diurno     
    aDiurno:={}
    nDiurno:=0  
    aEval(aTabHE,{|aTipo| If( aTipo[1] == cTipo, (nDiurno++, aAdd( aDiurno, aTipo )) , Nil ) })
     
    //-- Monta array com as faixas do tipo noturno correspondente
    aNoturno:= {}  
    nNoturno:= 0
    aEval(aTabHE,{|aTipo| If( aTipo[1] == cTipoPar,(nNoturno++, aAdd( aNoturno, aTipo )) , Nil ) })
    
    //-- Verificar se qtde de faixas de valores diurnas e noturnas diferem entre si
    If nDiurno <> nNoturno
       lRet := .F.
	   // "As horas hestras e suas correspondentes noturnas devem ter a mesma quantidade de faixas de escalonamento."
	   cHelp := STR0243
       Exit
    Endif   
                                 
    //-- Percorre Cada uma das faixas do Noturno correspondente
    nPos:=nDiurno
    Do While nPos >0                                          
       //-- Verifica Se existem diferenca entre os Limites Inicial e final em cada faixas correspondente
       If aDiurno[nPos,2] <> aNoturno[nPos,2] .OR. aDiurno[nPos,3] <> aNoturno[nPos,3]
          lRet := .F.
		  // "As faixas para as horas extras e suas correspondentes noturnas devem ter os mesmos limites."
		  cHelp := STR0244
          Exit
       Endif   
       nPos--
    End While
    
    //-- Se houve diferenca de faixas abandona rotina
    IF ! lRet
       Exit
    Endif
Next nFaixas

Return( lRet )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³fFeriado() ³ Autor ³ Marinaldo de Jesus   ³ Data ³01/06/2001³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³ Verifica se a Data passada ‚ ou nao um Feriado.            ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³ fFeriado( cFil, dDate , cDesc )						    ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³ SIGAPON                                                    ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³ lRet <=> True se Data Feriado, False se n„o                ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³ cFil  = Variavel com a Filial do Funcionario.              ³
³          ³ dDate = Data a Ser Verificada no SP3                       ³
³          ³ cDesc = Descricao do Feriado                               ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function fFeriado( cFil , dDate , cDesc, dDataIni, dDataFim )

Local aSaveArea	:= GetArea()
Local cAno		:= ""
Local dData		:= ""
Local dDatePos	:= ""
Local lFeriado	:= .F.
Local nI		:= 0
Local nLoop		:= 0
Local nAnoDtIni	:= 0
Local nAnoDtFim	:= 0

DEFAULT dDate				:= dDataBase
DEFAULT dDatePos 			:= dDataBase
DEFAULT cDesc				:= ""
DEFAULT __aFeriadoStatic	:= {}
DEFAULT dDataIni			:= dDate
DEFAULT dDataFim			:= dDate

If (ValType(dDataIni) == "D", nAnoDtIni := Year(dDataIni), nAnoDtIni := Year(dDataBase))
If (ValType(dDataFim) == "D", nAnoDtFim := Year(dDataFim), nAnoDtFim := Year(dDataBase))

// Verifica se o intervalo do dDataIni e dDataFim são de anos diferentes para serem validados com o feriado fixo de outros anos
If nAnoDtIni < nAnoDtFim
	While nAnoDtIni < nAnoDtFim
		nAnoDtIni++
		nLoop++
	EndDo
EndIf

cDesc := ""
cFil  := xFilial( "SP3" , cFil )
	
IF ( nPosFer := aScan( __aFeriadoStatic , { |x| x[1] == cFil .and. x[2] == dDate } ) ) == 0
	cCondSP3 := "% P3_FILIAL = '"+cFil+"' AND "
    cCondSP3 += " ( ( P3_DATA >= '"+dToS(dDataIni)+"' AND "
    cCondSP3 += " P3_DATA <= '"+dToS(dDataFim)+"' ) OR "
    cCondSP3 += " ( P3_MESDIA >= '"+MesDia(dDataIni)+"' "
    If Month(dDataFim) >= Month(dDataIni)
    	cCondSP3 += " AND P3_MESDIA <= '"+MesDia(dDataFim)+"' AND "
    Else
    	cCondSP3 += " OR P3_MESDIA <= '"+MesDia(dDataFim)+"' AND " 
    EndIf
    cCondSP3 += " P3_FIXO = 'S' ) ) %"
					
	cQrySP3 := GetNextAlias()

	BeginSql alias cQrySP3
		SELECT P3_FILIAL, P3_DATA, P3_MESDIA, P3_DESC, P3_FIXO, R_E_C_N_O_ RECNO 
		FROM %table:SP3% SP3
		WHERE
		%exp:cCondSP3% AND SP3.%NotDel%
	EndSql
	
	While (cQrySp3)->(!Eof())
		//-- Se nao for feriado fixo, adiciona pela data cadastrada
		If Empty( (cQrySp3)->(P3_MESDIA) )
			aAdd( __aFeriadoStatic , { (cQrySp3)->(P3_FILIAL) , Stod( (cQrySp3)->(P3_DATA) ) , (cQrySp3)->(P3_DESC) , (cQrySp3)->RECNO, .T. } )			
		//-- Caso contrario, realiza verificacao da data e adiciona no array
		Else
			cAno  := Str( Year(dDataIni), 4 )
			If Year( dDataFim ) > Year( dDataIni )
				dData := Stod( ( cAno + (cQrySp3)->(P3_MESDIA) ) )
				If dData < dDataIni
					dData := YearSum( dData , 1 )
				EndIf
			Else
				dData := Stod( ( cAno + (cQrySp3)->(P3_MESDIA) ) )
			EndIf
			aAdd( __aFeriadoStatic , { (cQrySp3)->(P3_FILIAL) , dData , (cQrySp3)->(P3_DESC) , (cQrySp3)->RECNO, .T. } )						
			
			// Verifica se deve incluir o feriado fixo em outros anos de acordo com a dDataFim
			If nLoop > 0
				For nI := 1 To nLoop
					If YearSum(dData, nI) <= dDataFim
						aAdd( __aFeriadoStatic , { (cQrySp3)->(P3_FILIAL) , YearSum(dData, nI) , (cQrySp3)->(P3_DESC) , (cQrySp3)->RECNO, .T. } )
					EndIf
				Next
			EndIf
		EndIf

		(cQrySp3)->( dbSkip() )
		Loop
	End While
	
	(cQrySP3)->(dbCloseArea())

	//-- Verifica se o primeiro dia do periodo esta no array, seta como feriado e posiciona na SP3
	IF ( nPosFer := aScan( __aFeriadoStatic , { |x| x[1] == cFil .and. x[2] == dDate } ) ) > 0
		lFeriado := .T.
		dbSelectArea("SP3")
		SP3->( MsGoto( __aFeriadoStatic[ nPosFer , 04 ] ) )
		cDesc := __aFeriadoStatic[ nPosFer , 03 ]
	Else
		RestArea(aSaveArea)			
	EndIf

	//-- Alimenta os outros dias do periodo no array sendo dias normais
	dDatePos := dDate
	While dDatePos <= dDataFim
		IF ( nPosFer := aScan( __aFeriadoStatic , { |x| x[1] == cFil .and. x[2] == dDatePos } ) ) == 0
			aAdd( __aFeriadoStatic , { cFil , dDatePos , cDesc , 0 , .F. } )
		EndIf
		dDatePos++
		Loop
	End While
        
        //-- Ordena por filial e data
	aSort( __aFeriadoStatic, , , { | x, y | x[1]+dToS(x[2]) < y[1]+dTos(y[2]) } )		
Else
	IF ( lFeriado := __aFeriadoStatic[ nPosFer , 05 ] )
		cDesc := __aFeriadoStatic[ nPosFer , 03 ]
	EndIF
	SP3->( MsGoto( __aFeriadoStatic[ nPosFer , 04 ] ) )
EndIF
	
Return( lFeriado )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³RstfFeriado		³Autor³Marinaldo de Jesus ³ Data ³11/03/2003³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Reinicializa as Staticas utilizadas em fFeriado()        	³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico													³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function RstfFeriado()
Return( ( __aFeriadoStatic := NIL ) )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³fDescTno  ³ Autor ³ Marinaldo de Jesus    ³ Data ³07/06/2001³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³ Retorna uma descri‡„o do Turno de Trabalho Solicitado      ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³fDescTno(cFil,cTno)                                         ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³cFil - Filial para Pesquisa                                 ³
³          ³cTno - Turno para Pesquisa                                  ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico                                                    ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function fDescTno( cFil , cTno, nTam )

Local cString := Space(50)

DEFAULT nTam	:= 50
cString := Left( fDesc( "SR6" , cTno , "R6_DESC" , nTam , cFil , NIL , .F. ) , nTam )

Return( cString )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³GetDescMarc ³ Autor ³Marinaldo de Jesus    ³ Data ³12/06/2001³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Retorna a Descricao dos Tipos de Marcacoes                   ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³GetDescMarc( cMarca )			              			 	 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³cMarca  -> Tipo de Marcacao                          		 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³cDesc                                                	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico                                                     ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function GetDescMarc( cMarca )

Local aMarca := Array( 11 , 2 )
Local cDescr := ""
Local nPos	 := 0

DEFAULT cMarca	:= ""

cMarca := StrTran( Upper( Alltrim( cMarca  ) ) , " " , "" )

aMarca[ 01 , 01 ] :=  "1E" ; aMarca[ 01 , 02 ] := STR0080 //'1a. Entrada'
aMarca[ 02 , 01 ] :=  "1S" ; aMarca[ 02 , 02 ] := STR0081 //'1a. Saida  '
aMarca[ 03 , 01 ] :=  "2E" ; aMarca[ 03 , 02 ] := STR0082 //'2a. Entrada'
aMarca[ 04 , 01 ] :=  "2S" ; aMarca[ 04 , 02 ] := STR0083 //'2a. Saida  '
aMarca[ 05 , 01 ] :=  "3E" ; aMarca[ 05 , 02 ] := STR0084 //'3a. Entrada'
aMarca[ 06 , 01 ] :=  "3S" ; aMarca[ 06 , 02 ] := STR0085 //'3a. Saida  '
aMarca[ 07 , 01 ] :=  "4E" ; aMarca[ 07 , 02 ] := STR0086 //'4a. Entrada'
aMarca[ 08 , 01 ] :=  "4S" ; aMarca[ 08 , 02 ] := STR0087 //'4a. Saida  '
aMarca[ 09 , 01 ] :=  "I1" ; aMarca[ 09 , 02 ] := STR0088 //'1o. Intervalo '
aMarca[ 10 , 01 ] :=  "I2" ; aMarca[ 10 , 02 ] := STR0089 //'2o. Intervalo '
aMarca[ 11 , 01 ] :=  "I3" ; aMarca[ 11 , 02 ] := STR0090 //'3o. Intervalo '

IF ( ( nPos := aScan( aMarca , { |x| x[1] == cMarca } ) ) > 0 )
	cDescr := aMarca[ nPos , 2 ]
EndIF

Return( cDescr )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³Chk_IdPon ³ Autor ³Marinaldo de Jesus     ³ Data ³10/07/2001³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³ Consiste os Identificadores de Ponto                       ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³Chk_IdPon( Codigo )                                         ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³ codigo = codigos da folha                                  ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³ SP9                                                        ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function Chk_IdPon()

Local aArea		:= GetArea()
Local aAreaSP9	:= {}
Local cSpaceIdP := Space( GetSx3Cache( "P9_IDPON  " , "X3_TAMANHO" ) ) 
Local cId		:= GetMemVar( "P9_IDPON" )
Local lRet		:= .F.
Local nOrder	:= RetOrdem( "SP9" , "P9_FILIAL+P9_IDPON+P9_CODIGO" )

aAreaSP9 := SP9->( GetArea() )
IF !( aAreaSP9[2] == nOrder )
	SP9->( dbSetOrder( nOrder ) )
EndIF	

IF lRet := SP9->( dbSeek( xFilial("SP9") + cId ) .and. IF( Altera , Recno() # aAreaSP9[3] , .T. ) .and. cId # cSpaceIdP )
	Help(" ",1,"XREPCODFOL")
EndIF

RestArea( aAreaSP9 )
RestArea( aArea	   )

Return( !lRet )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³GetLastApo  ³ Autor ³Marinaldo de Jesus    ³ Data ³27/07/2001³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Retornar array com os Resultados dos Apontamentos            ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³GetLastApo( [ dPerIni ],[ dPerFim ],[ cAlias ],[ aCpos ] )	 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³dPerIni 	-> Periodo Inicial de Apontamento            	 ³
³          ³dPerFim 	-> Periodo Final   de Apontamento            	 ³
³          ³cAlias  	-> Alias Para Pesquisa ("SPC" ou "SPH")      	 ³
³          ³aCpos   	-> Campos Para a Montagem da Query           	 ³
³          ³lInformado	-> Se considera os Dados Informados    	 		 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³aResult                                              	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico                                                     ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function GetLastApo( dPerIni , dPerFim , cAlias , aCpos , lInformado )

Local aAreaSPC		:= {}
Local aResult		:= {}
Local aSvAlias		:= GetArea()
Local bSort			:= { || NIL }
Local cFil	    	:= SRA->RA_FILIAL
Local cMat			:= SRA->RA_MAT
Local cFilMat		:= ( cFil + cMat )
Local cAliasQuery	:= ""
Local cPrefixo		:= ""
Local cCpoPD		:= "PD"
Local cCpoQtd		:= "QUANTC"
Local cOrdem		:= ""
Local lSPC			:= .F.
Local lSort			:= .F.
Local lQueryOpened	:= .F.
Local nOrdem		:= 1

//-- Portaria 1.510
Local cTurno  	
Local cSemana	
Local cTipoHE	
Local nPercent	

Local aStru			:= {}
Local cIniData		:= ""
Local cFimData		:= ""
Local cQuery		:= ""
Local cQryStru		:= ""
Local nCpos			:= 0
Local nX			:= 0
    
Static aSPCStruct
Static aSPHStruct
Static cQrySPCStruct
Static cQrySPHStruct

DEFAULT aCpos	:= {}
DEFAULT dPerIni 	:= Ctod("//")
DEFAULT dPerFim 	:= Ctod("//")
DEFAULT cAlias		:= "SPC"
DEFAULT lInformado	:= .F.  
  
cAlias		:= Upper( AllTrim( cAlias ) )
cPrefixo 	:= ( PrefixoCpo( cAlias ) + "_" )
lSPC		:= ( cAlias == "SPC" )
cAliasQuery	:= cAlias
aAreaSPC	:= ( cAlias )->( GetArea() )

//-- Portaria 1.510
DEFAULT __lCpoTurno		:= ( cPaisLoc == "BRA" ) //campo utilizaod somente no Brasil   
DEFAULT __lCpoSemana	:= ( cPaisLoc == "BRA" ) //campo utilizaod somente no Brasil   
DEFAULT __lCpoTipoHE	:= ( cPaisLoc == "BRA" ) //campo utilizaod somente no Brasil   
DEFAULT __lCpoPercent	:= ( cPaisLoc == "BRA" ) //campo utilizaod somente no Brasil  

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Define a Ordem para Pesquisa								   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
cOrdem	:= ( cPrefixo+'FILIAL+' )
cOrdem	+= ( cPrefixo+'MAT+' )
cOrdem	+= ( 'Dtos('+cPrefixo+'DATA'+')+' )
cOrdem	+= ( cPrefixo+'PD+' )
cOrdem	+= ( cPrefixo+'TPMARCA+' )
cOrdem	+= ( cPrefixo+'CC' )
/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Verifica a Existencia de Indice Fil+Mat+Data... e utiliza-o.  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
nOrdem	:= RetOrdem( cAlias , cOrdem )

IF ( nOrdem > 1 )
	( cAlias )->( dbSetOrder( nOrdem ) )
Else
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Na Ausencia do Indice forca a ordenacao					   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	lSort	:= .T.  
	bSort	:= { |x,y|	(;
							x[ARESULT_DTOS_DATA]	+ ;
							x[ARESULT_EVENTO] 		+ ;
							x[ARESULT_TPMARCA] 		+ ;
							x[ARESULT_CC] 			  ;
						);
							 < 					  	  ;
						(;
							y[ARESULT_DTOS_DATA]	+ ;
							y[ARESULT_EVENTO] 		+ ;
							y[ARESULT_TPMARCA] 		+ ;
							x[ARESULT_CC] 		 	  ;
						);
				};

EndIF

IF Empty( dPerIni ) .or. Empty( dPerFim )
	PerAponta( @dPerIni , @dPerFim , NIL , NIL , cFil )
EndIF

DEFAULT aSPCStruct := SPC->( dbStruct() )
DEFAULT aSPHStruct := SPH->( dbStruct() )

cIniData := Dtos( dPerIni )
cFimData := Dtos( dPerFim )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Seta apenas os Campos do SPC/SPH que serao Utilizados       ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
aAdd( aCpos , cPrefixo + "FILIAL"  )
aAdd( aCpos , cPrefixo + "MAT" 	   )
aAdd( aCpos , cPrefixo + "PD"	   )
aAdd( aCpos , cPrefixo + "DATA"	   )
aAdd( aCpos , cPrefixo + "QUANTC"  )
aAdd( aCpos , cPrefixo + "CC"	   )
aAdd( aCpos , cPrefixo + "TPMARCA" ) 

IF __lCpoTurno .and. __lCpoSemana .and. __lCpoTipoHE .and. __lCpoPercent
	aAdd( aCpos , cPrefixo + "TURNO" 	)
	aAdd( aCpos , cPrefixo + "SEMANA" 	)
	aAdd( aCpos , cPrefixo + "TIPOHE" 	)
	aAdd( aCpos , cPrefixo + "PERCENT" 	)
Endif

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Quando forcar a carga dos dados Informados				   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
IF ( lInformado )
	aAdd( aCpos , cPrefixo + "PDI"	   )
	aAdd( aCpos , cPrefixo + "QUANTI"  )
EndIF

nCpos := IF( lSPC , Len( aSPCStruct ) , Len( aSPHStruct ) )
For nX := 1 To nCpos
	IF aScan( aCpos , { |x| x == AllTrim( IF( lSPC , aSPCStruct[ nX , 1 ] , aSPHStruct[ nX , 1 ] ) ) } ) > 0
		aAdd( aStru , aClone( IF( lSPC , aSPCStruct[ nX ] , aSPHStruct[ nX ] ) ) )
		IF ( ( lSPC ) .and. !( cQrySPCStruct == NIL ) ) 
			IF !( aSPCStruct[ nX , 1 ] $ cQrySPCStruct )
				cQrySPCStruct := NIL
			EndIF
		ElseIF !( cQrySPHStruct == NIL )
			IF !( aSPHStruct[ nX , 1 ] $ cQrySPHStruct )
				cQrySPHStruct := NIL
			EndIF
		EndIF
	EndIF
Next nX

aCpos	:= NIL
nCpos	:= Len( aStru )

IF ( lSPC )
	IF ( cQrySPCStruct == NIL )
		cQrySPCStruct := ""
		For nX := 1 To nCpos
			cQrySPCStruct += aStru[ nX , 1 ] + ", "
		Next nX
	EndIF
	cQryStru := cQrySPCStruct
Else
	IF ( cQrySPHStruct == NIL )
		cQrySPHStruct := ""
		For nX := 1 To nCpos
			cQrySPHStruct += aStru[ nX , 1 ] + ", "
		Next nX
	EndIF
	cQryStru := cQrySPHStruct
EndIF

cQuery	:= "SELECT "
cQuery	+= cQryStru
cQuery	:= SubStr( cQuery , 1 , Len( cQuery ) - 2 )
cQuery	+= " FROM "
cQuery	+= InitSqlName( cAlias )
cQuery	+= " WHERE "
cQuery	+= cPrefixo + "FILIAL='"+cFil+"'"
cQuery	+= " AND "
cQuery	+= cPrefixo + "MAT='"+cMat+"'"
cQuery	+= " AND "
cQuery	+= cPrefixo + "DATA>='"+cIniData+"'"
cQuery	+= " AND "
cQuery	+= cPrefixo + "DATA<='"+cFimData+"'"
cQuery	+= " AND "
cQuery	+= "D_E_L_E_T_=' ' "
cQuery	+= "ORDER BY " + SqlOrder( ( cAlias )->( IndexKey() ) )

cQuery	:= ChangeQuery(cQuery)
cAliasQuery += "QRY"

IF ( lQueryOpened := MsOpenDbf(.T.,"TOPCONN",TcGenQry(NIL,NIL,cQuery),cAliasQuery,.F.,.T.) )
	For nX := 1 To nCpos
		IF ( aStru[nX,2] <> "C" )
			TcSetField(cAliasQuery,aStru[nX,1],aStru[nX,2],aStru[nX,3],aStru[nX,4])
		EndIF
	Next nX
EndIF
	
IF !( lQueryOpened )
	cAliasQuery := cAlias
	( cAliasQuery )->( dbSeek( cFilMat , .F. ) )
EndIF	

While ( cAliasQuery )->( !Eof() .and. ( ( &(cPrefixo+"FILIAL") + &(cPrefixo+"MAT") ) == cFilMat ) )
		
	IF !( lQueryOpened )
		IF ( cAliasQuery )->( &(cPrefixo+"DATA") < dPerIni .or. &(cPrefixo+"DATA") > dPerFim )
			( cAliasQuery )->( dbSkip() )
			Loop
		EndIF
	EndIF

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Quando forcar a carga dos dados Informados				   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	IF ( lInformado )
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Altera o Nome do Campo correspondente ao Evento a ser conside³
		³ rado														   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		IF !Empty( ( cAliasQuery )->( &(cPrefixo+"PDI") ) )
			cCpoPD := "PDI"
		Else
			cCpoPD := "PD"
		EndIF
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Altera o Nome do Campo correspondente a Quantidade a ser  con³
		³ siderada													   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		IF !Empty( ( cAliasQuery )->( &(cPrefixo+"QUANTI") ) )
			cCpoQtd := "QUANTI"
		Else
			cCpoQtd := "QUANTC"
		EndIF	
	EndIF
	
	IF __lCpoTurno .and. __lCpoSemana .and. __lCpoTipoHE .and. __lCpoPercent
		cTurno	:= 	( cAliasQuery )->( &(cPrefixo+"TURNO"	) )
		cSemana	:= 	( cAliasQuery )->( &(cPrefixo+"SEMANA"	) )
		cTipoHE	:= 	( cAliasQuery )->( &(cPrefixo+"TIPOHE"	) )
		nPercent:= 	( cAliasQuery )->( &(cPrefixo+"PERCENT") )
	Endif
	
	
			
	( cAliasQuery )->( fGeraRes(	@aResult				,; //01 -> Array com os Resultados do Dia
									&(cPrefixo+"DATA")		,; //02 -> Data da Geracao
									&(cPrefixo+cCpoQtd)		,; //03 -> Numero de Horas Resultantes
									&(cPrefixo+cCpoPD)		,; //04 -> Codigo do Evento
									&(cPrefixo+"CC")		,; //05 -> Centro de Custo a ser Gravado
									&(cPrefixo+"TPMARCA")	,; //06 -> Tipo de Marcacao
									.F.						,; //07 -> True para Acumular as Horas
									/*cPeriodo	*/			,; //08 -> Periodo de Apuracao
									/*nTole		*/			,; //09 -> Tolerancia
									/*cArred	*/			,; //10 -> Tipo de Arredondamento a Ser Utilizado
									/*lSubstitui*/			,; //11 -> Substitui a(s) Hora(s) Existente(s)
									/*cFuncao	*/			,; //12 -> Funcao  
									/*cDepto	*/			,; //13 -> Depto para gravacao
									/*cPosto	*/			,; //14 -> Posto para gravacao
									/*cProcesso	*/			,; //15 -> Periodo para Gravacao
									/*cRoteiro	*/			,; //16 -> Processo para Gravacao
									/*cPerApo	*/			,; //17 -> Periodo para Gravacao
									/*cNumPagto	*/ 			,; //18 -> NumPagto para Gravacao
									cTurno 					,; //19 -> Turno de Trabalho
									cSemana					,; //20 -> Semana/Sequencia do Turno
									cTipoHE					,; //21 -> Tipo de Hora Extra
									nPercent				;  //22 -> Percentual de Valorizacao			
								);
					)

	( cAliasQuery )->( dbSkip() )

End While

IF ( ( lQueryOpened ) .and. ( Select( cAliasQuery ) > 0 ) )
	( cAliasQuery )->( dbCloseArea() )
	dbSelectArea( cAlias )				//Restaura Arquivo Original
EndIF	

( cAlias )->( dbSetOrder( aAreaSPC[ 02 ] ) )

RestArea( aSvAlias )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Ordena aResult para Acumulados pois nao Existe o Indice 02   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
IF ( lSort )
	aSort( @aResult , NIL , NIL , bSort ) 
EndIF
		
Return( aResult )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³fEventos   ³ Autor ³ Marinaldo de Jesus   ³ Data ³23/08/2001³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³ListBox com a Selecao dos Eventos do Ponto                  ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³fEventos( cCampo , l1Elem )			    					³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico                                                    ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³.T. por ser Utilizado em Validacao                          ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³ cCampo 	- Campo Chave                                   ³
³          ³ l1Elem 	- Se deve Mostrar Apenas 1 Elemento             ³
³          ³ cPreSelect	- Eventos que ja foram Selecionados             ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function fEventos( cCampo , l1Elem , cPreSelect )

Local aPreSelect	:= {}
Local aEventos		:= {}
Local cTitulo		:= ""
Local cFilSP9		:= xFilial( "SP9" )
Local cFilSRV		:= xFilial( "SRV" )
Local cMvPar		:= &( Alltrim( ReadVar() ) )
Local cMvParDef		:= ""
Local cMvRetor		:= ""
Local cMvParam		:= ""
Local cReplicate	:= ""
Local nFor			:= 0
Local nLenFor		:= Len( AllTrim( cMvPar ) )
Local nTamCpo		:= 0

DEFAULT l1Elem 			:= .F.
DEFAULT cCampo 			:= "P9_CODIGO"
DEFAULT cPreSelect		:= ""

cCampo		:= Upper( AllTrim( cCampo ) )
nTamCpo		:= GetSx3Cache( cCampo , "X3_TAMANHO" )
cReplicate  := Replicate( "*" , nTamCpo )

CursorWait()

	IF !( l1Elem )
		nLenFor := Len( AllTrim( cMvPar ) )
		For nFor := 1 To nLenFor Step 3
			cMvParam += SubStr( cMvPar , nFor , nTamCpo )
			cMvParam += cReplicate
		Next nFor
	EndIF
	cMvPar := cMvParam
	
	IF ( Empty( __aEvefEve__ ) )
		SP9->( dbSetOrder( RetOrdem( "SP9" , "P9_FILIAL+" + cCampo ) ) )
		__aEvefEve__	:= BldafEventos( cFilSP9 , cCampo , cFilSRV )
	EndIF	
	
	nLenFor := Len( cPreSelect )
	For nFor := 1 To Len( cPreSelect ) Step nTamCpo
		aAdd( aPreSelect , SubStr( cPreSelect , nFor , nTamCpo ) )
	Next nFor
	
	nLenFor := Len( __aEvefEve__ )
	For nFor := 1 To nLenFor
		IF ( aScan( aPreSelect , SubStr( __aEvefEve__[ nFor ] , 1 , nTamCpo ) ) == 0 )
			cMvParDef += SubStr( __aEvefEve__[ nFor ] , 1 , nTamCpo )
			aAdd( aEventos , __aEvefEve__[ nFor ] )
		EndIF
	Next nFor

CursorArrow()
	
IF f_Opcoes( @cMvPar , cTitulo , aEventos , cMvParDef , 12 , 49 , l1Elem , nTamCpo , 20 )

	CursorWait()

		nLenFor := Len( cMvPar )
		For nFor := 1 To nLenFor Step nTamCpo
			IF ( SubStr( cMvpar , nFor , nTamCpo ) # cReplicate )
				cMvRetor += SubStr( cMvPar , nFor , nTamCpo )
			EndIF
		Next nFor

		&( Alltrim( ReadVar() ) ) := AllTrim( cMvRetor )

	CursorArrow()

EndIF
	
Return( .T. )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³BldafEventos  ³ Autor ³Marinaldo de Jesus     ³ Data ³12/09/2003³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Carregar os Eventos do SP9 conforme Filial                    	³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³cFilSP9 - Filial do SP9											³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³aEventos - Array com a String de Codigo + Descricao do Evento   ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function BldafEventos( cFilSP9 , cCampo , cFilSRV )

Local aArea		:= GetArea()
Local aQuery	:= {}
Local aEventos	:= {}
Local bAscan	:= { |x| ( x == cCpoDes ) } 
Local bSkip		:= { || .F. }
Local cCntCpo	:= ""
Local cCpoDes	:= ""
Local nOrdSrv	:= 0
Local lSRVComp	:= FWModeAccess("SRV",1) == "C" .AND. FWModeAccess("SRV",2) == "C" .AND. FWModeAccess("SRV",3) == "C"

Begin Sequence

	IF ( SP9->( FieldPos( cCampo ) ) == 0 )
		Break
	EndIF

	IF ( cCampo == "P9_CODFOL" )
		nOrdSrv := RetOrdem( "SRV" , "RV_FILIAL+RV_COD" )
		bSkip	:= { || (;
							cCpoDes := (;
											( cCntCpo := &( cCampo ) )	+ ;
											" - "						+ ;
											PosSRV( cCntCpo , cFilSRV , "RV_DESC" , nOrdSrv , .F. );
									    );
						),;
						IF( aScan( aEventos , bAscan ) == 0 .and. !Empty( cCntCpo ),;
							aAdd( aEventos , cCpoDes ),;
							NIL;
						  ),;
						 (;
						 	cCntCpo	:= "" ,;
						 	.F.;
						 );
				  }
	Else
		bSkip	:= { || (;
							cCpoDes := (;
											( cCntCpo := &( cCampo ) )	+ ;
											" - "						+ ;
											P9_DESC						  ;
										);
						 ),;
						 IF( aScan( aEventos , bAscan ) == 0 .and. !Empty( cCntCpo ),;
						 	 aAdd( aEventos , cCpoDes ),;
						 	 NIL;
						 	),;
						 (;
						 	cCntCpo	:= "" ,;
						 	.F.;
						 );	
					}
		If (lSRVComp, cFilSRV := cFilSP9, Nil)
	EndIF

	aQuery		:= Array( 03 )
	If (Empty(cFilSRV) .And. !Empty(cFilSP9), aQuery[01] := "P9_FILIAL <> ''", aQuery[01] := "P9_FILIAL='"+cFilSP9+"'")
	aQuery[02]	:= " AND "
	aQuery[03]	:= "D_E_L_E_T_=' ' "

	SP9->( GdBuildCols(	NIL				,;	//01 -> Array com os Campos do Cabecalho da GetDados
						NIL				,;	//02 -> Numero de Campos em Uso
						NIL				,;	//03 -> [@]Array com os Campos Virtuais
						NIL				,;	//04 -> [@]Array com os Campos Visuais
						NIL				,;	//05 -> Opcional, Alias do Arquivo Carga dos Itens do aCols
						{				 ;
							"P9_FILIAL"	,;
							cCampo		,;
							"P9_DESC"	 ;
						}				,;	//06 -> Opcional, Campos que nao Deverao constar no aHeader
						NIL				,;	//07 -> [@]Array unidimensional contendo os Recnos
						"SP9"			,;	//08 -> Alias do Arquivo Pai
						cFilSP9			,;	//09 -> Chave para o Posicionamento no Alias Filho
						NIL				,;	//10 -> Bloco para condicao de Loop While
						bSkip			,;	//11 -> Bloco para Skip no Loop While
						.F.				,;	//12 -> Se Havera o Elemento de Delecao no aCols 
						.F.				,;	//13 -> Se Sera considerado o Inicializador Padrao
						.F.				,;	//14 -> Opcional, Carregar Todos os Campos
						.F.				,;	//15 -> Opcional, Nao Carregar os Campos Virtuais
						aQuery			,;	//16 -> Opcional, Utilizacao de Query para Selecao de Dados
						.F.				,;	//17 -> Opcional, Se deve Executar bKey  ( Apenas Quando TOP )
						.T.				,;	//18 -> Opcional, Se deve Executar bSkip ( Apenas Quando TOP )
						.F.				,;	//19 -> Carregar Coluna Fantasma e/ou BitMap ( Logico ou Array )
						.T.				,;	//20 -> Inverte a Condicao de aNotFields carregando apenas os campos ai definidos
						.F.				,;	//21 -> Verifica se Deve Checar se o campo eh usado
						.F.				,;	//22 -> Verifica se Deve Checar o nivel do usuario
						.F.				 ;	//23 -> Verifica se Deve Carregar o Elemento Vazio no aCols
					   );
		  )

End Sequence

RestArea( aArea )

Return( aClone( aEventos ) )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³RstfEventos   ³ Autor ³Marinaldo de Jesus     ³ Data ³11/09/2003³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Reinicializa as Statics em RstfEventos()                       	³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³																³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL																³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function RstfEventos()
Return( ( __aEvefEve__ := {} ) )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³GetMarcacoes³Autor ³ Marinaldo de Jesus   ³ Data ³25/08/2001³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Retornar Array aMarcacoes com as Marcacoes do Periodo       ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³GetMarcacoes(@aMarcacoes,[@]aTabCalend...)					³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Ponto Eletronico                                            ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³lGetMarcOk                         							³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³ < Vide Parametros Formais >								³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function GetMarcacoes(	aMarcacoes			,;	//01 -> Marcacoes dos Funcionarios
						aTabCalend			,;	//02 -> Calendario de Marcacoes
						aTabPadrao			,;	//03 -> Tabela Padrao
						aTurnos				,;	//04 -> Turnos de Trabalho
						dPerIni 			,;	//05 -> Periodo Inicial
						dPerFim				,;	//06 -> Periodo Final
						cFil				,;	//07 -> Filial
						cMat				,;	//08 -> Matricula
						cTno				,;	//09 -> Turno
						cSeq				,;	//10 -> Sequencia de Turno
						cCc					,;	//11 -> Centro de Custo
						cAlias				,;	//12 -> Alias para Carga das Marcacoes
						lRecno				,;	//13 -> Se carrega Recno em aMarcacoes
						lOrdem				,;	//14 -> Se considera Apenas Ordenadas
						lDiasFolga			,;  //15 -> Verifica as Folgas Automaticas
						lGrvFolgPa  		,;  //16 -> Se Grava Evento de Folga Mes Anterior
						lGetMarcAuto		,;	//17 -> Se Carrega as Marcacoes Automaticas
						aRecsMarcAut	    ,;	//18 -> Registros de Marcacoes Automaticas que deverao ser Desprezadas
						bCondMarcAut		,;	//19 -> Bloco para avaliar as Marcacoes Automaticas que deverao ser Desprezadas
						lChkPerAponta		,;	//20 -> Se Considera o Periodo de Apontamento das Marcacoes
						lSncMaMe			,;	//21 -> Se Efetua o Sincronismo dos Horarios na Criacao do Calendario
						lLoadDel			,;  //22 -> Se carrega as marcacoes desconsideradas (Uso com lPort1510)
						lSP8AndSPG			 ;  //23 -> Se carrega as marcacoes das duas tabelas SP8 e SPG
					  )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Variaveis de Inicializacao Obrigatoria					  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Local aSvAlias			:= GetArea()
Local lGetMarcOk 		:= .T.
Local lQueryOpened		:= .F.
Local aCpoQry			:= {"FILIAL", "MAT", "DATA", "HORA", "CC", "ORDEM", "FLAG", "APONTA", "TURNO", "RELOGIO", "FUNCAO", "GIRO", "TPMARCA", "PAPONTA", "PROCES", "ROTEIR", "PERIODO", "NUMPAG", "DEPTO", "POSTO", "CODFUNC", "DATAAPO", "SEMANA", "NUMREP", "TPMCREP", "SEQJRN", "TIPOREG", "MOTIVRG", "EMPORG", "FILORG", "MATORG", "DHORG", "IDORG", "DATAALT", "HORAALT", "USUARIO"}

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Variaveis que serao inicializadas no Corpo da Funcao		  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/      

Local cFilMat
Local cAliasQuery  
Local cPrefixo
Local cCod036N
Local cPriOrdem
Local cUltOrdem	
Local cAtuOrdem
Local cPerAponta
Local cPer1Apon
Local cAntOrdem
Local cPrxOrdem
Local cDtHrAntOrd
Local cDtHrPrxOrd
Local cDtHrLimIni
Local cDtHrLimFim
Local cDtHrAtu
Local cSetOrdem
Local lNotOrdena    
Local nLenMarc
Local nSvIndexOrd
Local nPosUltOrdem
Local nLenTabCal
Local nPosPrxOrd
Local nPosAntOrd
Local nSetOrder
Local lGeolocal := SP8->(ColumnPos("P8_LATITU")) > 0 .And. SP8->(ColumnPos("P8_LONGIT")) > 0  
Local lGeoFence	:= lGeolocal .And. SP8->(ColumnPos("P8_GEOFEN")) > 0
Local lCCT		:= SP8->(ColumnPos("P8_CODCCT")) > 0
Local lFuso671	:= SP8->(ColumnPos("P8_FUSO")) > 0
Local lCCTREP	:= SP8->(ColumnPos("P8_CCTREP")) > 0

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Variaveis de Inicializacao Obrigatoria					  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Local aGetMarcFields	:= {}

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Variaveis que serao inicializadas no Corpo da Funcao		  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Local cQryMarcFields
Local cIniData
Local cFimData
Local cQuery
Local nGetMarcFields
Local nX

Static aGetSP8Fields
Static cQrySP8Fields
Static cQrySPGFields
Static nGetSP8Fields
Static aGetSPGFields
Static nGetSPGFields

Static __oSt2
Static __cEmpAux2
Static __oSt3
Static __cEmpAux3
Static __cAliasAux
Static __lChkPerApo
Static cQuerySP8
Static cQuerySPG

DEFAULT cFil				:= SRA->RA_FILIAL
DEFAULT cMat				:= SRA->RA_MAT
DEFAULT cTno				:= SRA->RA_TNOTRAB
DEFAULT cSeq				:= SRA->RA_SEQTURN
DEFAULT dPerIni				:= Ctod("//")
DEFAULT dPerFim				:= Ctod("//")
DEFAULT aTabPadrao			:= {}
DEFAULT aTabCalend			:= {}
DEFAULT aTurnos				:= {}
DEFAULT cAlias				:= "SP8"
DEFAULT lRecno				:= .T.
DEFAULT lOrdem				:= .F.
DEFAULT lDiasFolga			:= .F.
DEFAULT lGrvFolgPa			:= .F.
DEFAULT lGetMarcAuto		:= .T.
DEFAULT bCondMarcAut		:= { || .T. }
DEFAULT lChkPerAponta		:= .T.
DEFAULT lSncMaMe			:= .T.
DEFAULT lLoadDel			:= .F.
DEFAULT lSP8AndSPG			:= .F.

aRecsMarcAut				:= {}

If lGeolocal
	aAdd( aCpoQry, "LATITU" )
	aAdd( aCpoQry, "LONGIT" )
EndIf

If lGeoFence
	aAdd( aCpoQry, "GEOFEN" )
EndIf

If lCCT
	aAdd( aCpoQry, "FILCCT" )
	aAdd( aCpoQry, "CODCCT" )
EndIf

If lFuso671
	aAdd( aCpoQry, "FUSO" )
EndIf

If lCCTREP
	aAdd( aCpoQry, "CCTREP" )
EndIf

Begin Sequence

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Carrega o Calendario do Periodo Caso Esteja Vazio            ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	IF Empty( aTabCalend )
		IF ( Empty( dPerIni ) .or. Empty( dPerFim ) )
			IF !( lGetMarcOk := PerAponta( @dPerIni , @dPerFim , NIL , NIL , cFil ) )
				Break
			EndIF	
		EndIF	
		IF !( lGetMarcOk := CriaCalend(	dPerIni 	,;	//01 -> Data Inicial do Periodo
			  			   			   	dPerFim		,;	//02 -> Data Final do Periodo
								   		cTno		,;	//03 -> Turno Para a Montagem do Calendario
								   		cSeq		,;	//04 -> Sequencia Inicial para a Montagem Calendario
								   		@aTabPadrao	,;	//05 -> Array Tabela de Horario Padrao
								   		@aTabCalend	,;	//06 -> Array com o Calendario de Marcacoes
								   		cFil     	,;	//07 -> Filial para a Montagem da Tabela de Horario
								   		cMat   		,;	//08 -> Matricula para a Montagem da Tabela de Horario
								   		cCc   		,;	//09 -> Centro de Custo para a Montagem da Tabela
								   		@aTurnos	,;	//10 -> Array com as Trocas de Turno
										NIL			,;	//11 -> Array com Todas as Excecoes do Periodo
										NIL			,;	//12 -> Se executa Query para a Montagem da Tabela Padrao
										lSncMaMe	,;	//13 -> Se executa a funcao se sincronismo do calendario
										NIL			 ;	//14 -> Se Forca a Criacao de Novo Calendario
							  		  );
			)
			Break
		EndIF
	ElseIF ( Empty( dPerIni ) .or. Empty( dPerFim ) )
		cPriOrdem		:= aTabCalend[ 01 , CALEND_POS_ORDEM	]
		dPerIni			:= aTabCalend[ 01 , CALEND_POS_DATA_APO		]
		nLenTabCal		:= Len( aTabCalend )
		cUltOrdem		:= aTabCalend[ nLenTabCal , CALEND_POS_ORDEM ]
		nPosUltOrdem    := aScan( aTabCalend , { |x| ( x[ CALEND_POS_ORDEM ] == cUltOrdem  ) .and. ( x[CALEND_POS_TIPO_MARC] == "1E" ) } )
		IF ( nPosUltOrdem > 0 )
			dPerFim := aTabCalend[ nPosUltOrdem , CALEND_POS_DATA ]
		ElseIF !( lGetMarcOk := PerAponta( @dPerIni , @dPerFim , NIL , NIL , cFil ) )
			Break
		EndIF
	EndIF	
	
	cAlias			:= Upper( AllTrim( cAlias ) )
	cAliasQuery 	:= cAlias
	cPrefixo		:= ( PrefixoCpo( cAliasQuery ) + "_" )
	aMarcacoes  	:= {}
	nLenTabCal		:= Len( aTabCalend )
	cPriOrdem		:= aTabCalend[ 01			, CALEND_POS_ORDEM	]
	cUltOrdem		:= aTabCalend[ nLenTabCal	, CALEND_POS_ORDEM	]
	IF ( lChkPerAponta )
		cPerAponta		:= Dtos( aTabCalend[ 01 , CALEND_POS_DATA_APO ] )
		cPer1Apon		:= Dtos( aTabCalend[ 01 , CALEND_POS_DATA ] )
		nPosUltOrdem    := aScan( aTabCalend , { |x| ( x[ CALEND_POS_ORDEM ] == cUltOrdem  ) .and. ( x[CALEND_POS_TIPO_MARC] == "1E" ) } )
		IF ( nPosUltOrdem > 0 )
			cPerAponta		+= Dtos( aTabCalend[ nPosUltOrdem , CALEND_POS_DATA_APO ] )
			cPer1Apon		+= Dtos( aTabCalend[ nPosUltOrdem , CALEND_POS_DATA ] )
		EndIf
	EndIF
	cDtHrLimIni		:= DataHora2Str(;
										aTabCalend[ 01 , CALEND_POS_LIM_MARCACAO , 01 ],;
										aTabCalend[ 01 , CALEND_POS_LIM_MARCACAO , 02 ];
									)
	cDtHrLimFim		:= DataHora2Str(;
										aTabCalend[ nLenTabCal , CALEND_POS_LIM_MARCACAO , 01 ],;
										aTabCalend[ nLenTabCal , CALEND_POS_LIM_MARCACAO , 02 ];
									)
	
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Seleciona o Arquivo de Marca‡”es e Seta a Ordem corresponden³
	³ te:														  ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	nSvIndexOrd := ( cAlias )->( IndexOrd() )
	cSetOrdem	:= ""
	IF ( lOrdem )
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Ordem <=> _FILIAL+_MAT+_ORDEM+_DTOS(_DATA)+STR(_HORA,5,2)	  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		cSetOrdem += cPrefixo+"FILIAL+"
		cSetOrdem += cPrefixo+"MAT+"
		cSetOrdem += cPrefixo+"ORDEM+"
		cSetOrdem += "DTOS("+cPrefixo+"DATA)+"
		cSetOrdem += "STR("+cPrefixo+"HORA,5,2)" 
	Else
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Data  <=> _FILIAL+_MAT+_DTOS(_DATA)+STR(_HORA,5,2)    	  	  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		cSetOrdem += cPrefixo+"FILIAL+"
		cSetOrdem += cPrefixo+"MAT+"
		cSetOrdem += "DTOS("+cPrefixo+"DATA)+"
		cSetOrdem += "STR("+cPrefixo+"HORA,5,2)" 
	EndIF
	nSetOrder	:= RetOrdem( cAlias , cSetOrdem )
	IF !( nSvIndexOrd == nSetOrder )
		( cAlias )->( dbSetOrder( nSetOrder ) )
	EndIF

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Cria array com as marca‡”es do Periodo para o funcion rio.  ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Monta Query para Carga das Marcacoes                         ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	IF ( cAlias == "SP8" ) .And. ! lSP8AndSPG
		IF ( aGetSP8Fields == NIL )
			aGetSP8Fields	:= (cAlias)->( dbStruct() )
			nGetSP8Fields	:= Len( aGetSP8Fields )
			cQrySP8Fields	:= ""
			For nX := 1 To nGetSP8Fields
        		cQrySP8Fields += aGetSP8Fields[ nX , 01 ] + ", "
			Next nX
		EndIF
		aGetMarcFields	:= aClone( aGetSP8Fields )
		cQryMarcFields	:= cQrySP8Fields
		nGetMarcFields	:= nGetSP8Fields
	ElseIf ( cAlias == "SPG" ) .And. ! lSP8AndSPG 
		IF ( aGetSPGFields == NIL )
			aGetSPGFields	:= (cAlias)->( dbStruct() )
			nGetSPGFields	:= Len( aGetSPGFields )
			cQrySPGFields	:= ""
			For nX := 1 To nGetSPGFields
        		cQrySPGFields += aGetSPGFields[ nX , 01 ] + ", "
			Next nX
		EndIF	
		aGetMarcFields	:= aClone( aGetSPGFields )
		cQryMarcFields	:= cQrySPGFields
		nGetMarcFields	:= nGetSPGFields
	EndIF
	
	cIniData	:= Dtos( aTabCalend[ 01			, CALEND_POS_DATA ] - 7 )
	cFimData	:= Dtos( aTabCalend[ nLenTabCal , CALEND_POS_DATA ] + 7 )
	
	cAliasQuery := ( "__Q" + cAliasQuery + "QRY" )
	
	If ! lSP8AndSPG

		If __oSt3 == Nil .or. ( __cEmpAux3 == Nil .or. __cEmpAux3 <> cEmpAnt ) .or. ( __cAliasAux == Nil .or. __cAliasAux <> cAlias ) .or. ( __lChkPerApo == Nil .or. __lChkPerApo <> lChkPerAponta )

			__cEmpAux3   := cEmpAnt
			__cAliasAux  := cAlias
			__lChkPerApo := lChkPerAponta
			__oSt3 		 := FWPreparedStatement():New()

			cQuery := "SELECT "
			cQuery += cQryMarcFields
			cQuery += "R_E_C_N_O_ RECNO "
			cQuery += " FROM "
			cQuery += InitSqlName(cAlias)
			cQuery += " WHERE "
			cQuery += cPrefixo + "FILIAL = ? "
			cQuery += " AND "
			cQuery += cPrefixo + "MAT = ? "
			cQuery += " AND "
			cQuery += cPrefixo + "DATA >= ? "
			cQuery += " AND "
			cQuery += cPrefixo + "DATA <= ? "
			IF ( lChkPerAponta )
				cQuery += " AND "
				cQuery += " ( "
				cQuery +=		cPrefixo + "PAPONTA = ? "
				cQuery += 		" OR "
				cQuery +=		cPrefixo + "PAPONTA = ? "
				cQuery += 		" OR "
				cQuery +=		cPrefixo + "PAPONTA = ? "
				cQuery += 		" OR "
				cQuery +=       " ( "
				cQuery += 		cPrefixo + "DATAAPO >= ? "
				cQuery += 		" AND "
				cQuery += 		cPrefixo + "DATAAPO <= ? "
				cQuery += 		" ) "
				cQuery += " ) "
			EndIF
			
			cQuery += " AND "
			cQuery += "D_E_L_E_T_=' ' "
			cQuery += "ORDER BY " + SqlOrder( (cAlias)->( IndexKey() ) )
			
			cQuery := ChangeQuery(cQuery)

			__oSt3:SetQuery(cQuery)

		EndIf

		__oSt3:SetString(1,cFil)
		__oSt3:SetString(2,cMat)
		__oSt3:SetString(3,cIniData)
		__oSt3:SetString(4,cFimData)

		If lChkPerAponta
			__oSt3:SetString(5,cPerAponta)
			__oSt3:SetString(6,cPer1Apon)
			__oSt3:SetString(7,Space(Len(cPerAponta)))
			__oSt3:SetString(8,cIniData)
			__oSt3:SetString(9,cFimData)
		EndIf

		cQuery := __oSt3:getFixQuery()

		dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasQuery)
		
		lQueryOpened := .T.
		
		For nX := 1 To nGetMarcFields
			IF ( aGetMarcFields[ nX , 02 ] <> "C" )
				TcSetField(cAliasQuery,aGetMarcFields[nX,01],aGetMarcFields[nX,02],aGetMarcFields[nX,03],aGetMarcFields[nX,04])
			EndIF
		Next nX

		TcSetField(cAliasQuery,"RECNO","N",10,0)
		
		cFilMat := ( cFil + cMat )
	Else

		cAliasQuery := GetNextAlias()

		If __oSt2 == Nil .or. ( __cEmpAux2 == Nil .or. __cEmpAux2 <> cEmpAnt )

			__cEmpAux2   := cEmpAnt
			__oSt2 		 := FWPreparedStatement():New()

			If cQuerySP8 == NIL
				cQuerySP8 := ""
				cQuerySPG := ""
				aEval(aCpoQry, {|x| cQuerySP8 += "P8_" + x + ",", cQuerySPG += "PG_" + x + ","})
			EndIf
			
			cQuery := "SELECT "
			cQuery += cQuerySP8
			cQuery += "R_E_C_N_O_ RECNO "
			cQuery += " FROM "
			cQuery += InitSqlName("SP8") + " SP8 "
			cQuery += " WHERE "
			cQuery += "P8_FILIAL = ? "
			cQuery += " AND "
			cQuery += "P8_MAT = ? "
			cQuery += " AND "
			cQuery += "P8_DATA >= ? "
			cQuery += " AND "
			cQuery += "P8_DATA <= ? "
			cQuery += " AND "
			cQuery += "SP8.D_E_L_E_T_ = ' ' "
			cQuery += "UNION "
			cQuery += "SELECT "
			cQuery += cQuerySPG
			cQuery += "R_E_C_N_O_ RECNO "
			cQuery += " FROM "
			cQuery += InitSqlName("SPG") + " SPG "
			cQuery += " WHERE "
			cQuery += "PG_FILIAL = ? "
			cQuery += " AND "
			cQuery += "PG_MAT = ? "
			cQuery += " AND "
			cQuery += "PG_DATA >= ? "
			cQuery += " AND "
			cQuery += "PG_DATA <= ? "
			cQuery += " AND "
			cQuery += "SPG.D_E_L_E_T_ = ' ' "			
			cQuery += "ORDER BY P8_FILIAL, P8_MAT, P8_DATA, P8_HORA "
			
			cQuery := ChangeQuery(cQuery)

			__oSt2:SetQuery(cQuery)

		EndIf
		
		__oSt2:SetString(1,cFil)
		__oSt2:SetString(2,cMat)
		__oSt2:SetString(3,cIniData)
		__oSt2:SetString(4,cFimData)
		__oSt2:SetString(5,cFil)
		__oSt2:SetString(6,cMat)
		__oSt2:SetString(7,cIniData)
		__oSt2:SetString(8,cFimData)

		cQuery := __oSt2:getFixQuery()

		dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasQuery)
		
		lQueryOpened := .T.

		If ( aGetSP8Fields == NIL )
			aGetSP8Fields	:= (cAlias)->( dbStruct() )
			nGetSP8Fields	:= Len( aGetSP8Fields )
			cQrySP8Fields	:= ""
			For nX := 1 To nGetSP8Fields
        		cQrySP8Fields += aGetSP8Fields[ nX , 01 ] + ", "
			Next nX
		EndIf
		
		For nX := 1 To nGetSP8Fields
			If ( aGetSP8Fields[ nX , 02 ] <> "C" ) .and. aGetSP8Fields[ nX , 01 ] $ cQuerySP8
				TcSetField(cAliasQuery,aGetSP8Fields[nX,01],aGetSP8Fields[nX,02],aGetSP8Fields[nX,03],aGetSP8Fields[nX,04])
			EndIf
		Next nX

		TcSetField(cAliasQuery,"RECNO","N",10,0)
		
	EndIf
	
	cFilMat := ( cFil + cMat )
    
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Obtem as Marcacoes validas para o Periodo                    ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	While ( cAliasQuery )->( !Eof() .and. ( &( cPrefixo+"FILIAL+"+cPrefixo+"MAT" ) == cFilMat ) )
        
		//Verifica se deve carregar as marcacoes desconsideradas
		If lPort1510 .and. !lLoadDel
			If ( cAliasQuery )->( &(cPrefixo+"TPMCREP") ) == "D"
				( cAliasQuery )->( dbSkip() )
				Loop
			EndIf
		EndIf
		
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Verificando a Ordem das Marcacoes                            ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		IF ( lOrdem )
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Ignora Marcacoes nao Ordenadas                               ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			IF Empty( cAtuOrdem := ( cAliasQuery )->( &( cPrefixo+"ORDEM" ) ) )
				( cAliasQuery )->( dbSkip() )
				Loop
			EndIF	
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Obtem String de Data Hora da Marcacao Referente a Ordem Atual³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			cDtHrAtu 	:= ( cAliasQuery )->( DataHora2Str( &( cPrefixo+"DATA" ) , &( cPrefixo+"HORA" ) ) )
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Ignora Marcacoes Fora dos Limites Considerando a Ordem 	   ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/     
			//-- Verifica a ordem se nao for checar o periodo de apontamento ou
			//-- se for para checar, mas o periodo de apontamento estah vazio (ou seja verifico a ordem pois a 
			//-- checagem do periodo nao consiguirah verificar se a marcacao se encontra entre os limites do periodo)
			IF !( lChkPerAponta ) .OR. ( lChkPerAponta .and. Empty( (cAliasQuery)->( &(cPrefixo+"PAPONTA") ) ) )
				IF (;
						(;
							( cAtuOrdem >= cPriOrdem   ) .and. ( cDtHrAtu < cDtHrLimIni );	//Marcacao de Periodo Posterior
						 ) .or. ;
						 (;
							( cAtuOrdem <= cUltOrdem   ) .and. ( cDtHrAtu > cDtHrLimFim );	//Marcacao de Periodo Anterior
						 );
					)		
					( cAliasQuery )->( dbSkip() )
					Loop
				EndIF
			
				/*/
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³Se for a Primeira Ordem, compara Horarios em Relacao ao Limite³
				³Final da Proxima Ordem									   	   ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
				IF ( cAtuOrdem == cPriOrdem )
					IF Empty( nPosPrxOrd )
						cPrxOrdem	:= StrZero( ( Val( cAtuOrdem ) + 1 ) , __nTamP8Ordem )
						nPosPrxOrd	:= aScan(;
												aTabCalend , { |x|;
																	( x[ CALEND_POS_ORDEM ] == cPrxOrdem ) .and.;
																	!Empty( x[ CALEND_POS_LIM_MARCACAO , 01 ] ) .and.;
																	( x[ CALEND_POS_TIPO_MARC ] <> "1E" );
														 	  };
									 		)
	                   	IF ( nPosPrxOrd > 0 )
							cDtHrPrxOrd := DataHora2Str(;
															aTabCalend[ nPosPrxOrd , CALEND_POS_LIM_MARCACAO , 01 ],;
															aTabCalend[ nPosPrxOrd , CALEND_POS_LIM_MARCACAO , 02 ];
														)
	    				EndIF
					EndIF
					IF ( nPosPrxOrd > 0 )
						IF ( cDtHrAtu > cDtHrPrxOrd )
							( cAliasQuery )->( dbSkip() )
							Loop
						EndIF
					EndIF	
				EndIF
				/*/
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³Se for a Ultima Ordem, compara Horarios em Relacao ao   Limite³
				³Inicial da Ordem Anterior       							   ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
				IF ( cAtuOrdem == cUltOrdem )
					IF Empty( nPosAntOrd )
						cAntOrdem	:= StrZero( ( Val( cAtuOrdem ) - 1 ) , __nTamP8Ordem )
						nPosAntOrd	:= aScan(;
												aTabCalend , { |x|;
																	( x[ CALEND_POS_ORDEM ] == cAntOrdem ).and.; 
																	( x[ CALEND_POS_TIPO_MARC ] == "1E" );
														 	  };
									 		)
						IF ( nPosAntOrd > 0 )
							cDtHrAntOrd := DataHora2Str(;
															aTabCalend[ nPosAntOrd , CALEND_POS_LIM_MARCACAO , 01 ],;
															aTabCalend[ nPosAntOrd , CALEND_POS_LIM_MARCACAO , 02 ];
														)
						EndIF
					EndIF
					IF ( nPosAntOrd > 0 )
						IF ( cDtHrAtu <= cDtHrAntOrd )
							( cAliasQuery )->( dbSkip() )
							Loop
						EndIF
					EndIF	
				EndIF
			Endif	
		Else
			// Ignora Marcacoes Fora do Período de Apontamento
			If (!Empty((cAliasQuery)->(&(cPrefixo+"DATAAPO"))) .And. (((cAliasQuery)->(&(cPrefixo+"DATAAPO")) < dPerIni) .Or. ((cAliasQuery)->(&(cPrefixo+"DATAAPO")) > dPerFim)))
				( cAliasQuery )->( dbSkip() )
				Loop
			EndIF
		EndIF
		
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Ignora Marcacoes Fora do Periodo de Apontamento              ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		IF ( lChkPerAponta )
			IF ( !Empty( (cAliasQuery)->( &(cPrefixo+"DATAAPO") ) ) .and. ( ( (cAliasQuery)->( &(cPrefixo+"DATAAPO") ) < dPerIni )  .Or. ( (cAliasQuery)->( &(cPrefixo+"DATAAPO") ) > dPerFim ) ) )
				( cAliasQuery )->( dbSkip() )
				Loop
			EndIF	
		EndIF

		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Verifica se Deve Carregar as Marcacoes Automaticas           ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		IF ( !( lGetMarcAuto ) .and. ( cAliasQuery )->( &( cPrefixo+"FLAG" ) == "A" .and. Eval( bCondMarcAut ) ) )
			IF !( lQueryOpened )
				aAdd( aRecsMarcAut , ( cAliasQuery )->( Recno() ) )
			Else
				aAdd( aRecsMarcAut , ( cAliasQuery )->( RECNO ) )
			EndIF
			( cAliasQuery )->( dbSkip() )
			Loop
		EndIF

		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Carrega as Marcacoes do Funcionario                          ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		aAdd( aMarcacoes , Array( ELEMENTOS_AMARC ) )
		nLenMarc := Len( aMarcacoes )
		( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_DATA   ] := &(cPrefixo+"DATA")	)					//01 - Data
		( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_HORA   ] := &(cPrefixo+"HORA")	)					//02 - Hora
		( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_ORDEM  ] := &(cPrefixo+"ORDEM")	)				//03 - Ordem
		( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_FLAG   ] := &(cPrefixo+"FLAG")	)					//04 - Flag
		IF ( lRecno )
			IF !( lQueryOpened )
				( cAliasQuery )->(aMarcacoes[ nLenMarc , AMARC_RECNO ] := Recno() 	)					//05 - Recno 
			Else                                                                                	
				( cAliasQuery )->(aMarcacoes[ nLenMarc , AMARC_RECNO ] := RECNO		)				//05 - Recno 
			EndIF
		Else
			aMarcacoes[ nLenMarc , AMARC_RECNO ] := 0														//05 - Recno
		EndIF
		( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_TURNO		] := &(cPrefixo+"TURNO")	)			//06 - Turno
		( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_FUNCAO		] := &(cPrefixo+"FUNCAO")	)			//07 - Funcao 
		( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_GIRO		] := &(cPrefixo+"GIRO") 	)			//08 - Giro
		( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_CC			] := &(cPrefixo+"CC")		)			//09 - Centro de Custo
		( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_APONTA		] := &(cPrefixo+"APONTA")	)			//10 - Flag de Apontamento
		( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_RELOGIO		] := &(cPrefixo+"RELOGIO")	)			//11 - Relogio
		( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_TIPOMARC	] := &(cPrefixo+"TPMARCA")	)			//12 - Tipo da Marcacao
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Verifica se a Marcacao sera ordenada                         ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		lNotOrdena := (;
							( aMarcacoes[ nLenMarc , AMARC_FLAG ] $ "M,I" ) .and.;
							!Empty( aMarcacoes[ nLenMarc , AMARC_ORDEM  ] );
					   )		
		aMarcacoes[ nLenMarc , AMARC_L_ORIGEM ] := lNotOrdena												//13 - Logico Origem 
		aMarcacoes[ nLenMarc , AMARC_DTHR2STR ] := DataHora2Str(;                                           
																	aMarcacoes[ nLenMarc , AMARC_DATA ] ,;
																	aMarcacoes[ nLenMarc , AMARC_HORA ]  ;
																)                                           //14 - String de Data/Hora para aSort
		( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_PERAPONTA	] := &(cPrefixo+"PAPONTA")	)	   		//15 - Periodo de Apontamento
		If lPort1510
			( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_SEQ			] := &(cPrefixo+"SEMANA") 	)
			( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_DATAAPO		] := &(cPrefixo+"DATAAPO") 	)		//25 - Data de Apontamento
			( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_NUMREP		] := &(cPrefixo+"NUMREP") 	)		//26 - Numero do REP
			( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_TPMCREP		] := &(cPrefixo+"TPMCREP")	)		//27 - Tipo de Marcacao no REP
			( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_TIPOREG		] := &(cPrefixo+"TIPOREG")	)		//28 - Tipo de Registro
			( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_MOTIVRG		] := &(cPrefixo+"MOTIVRG")	)		//29 - Motivo da desconsideracao/inclusao
			( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_EMPORG		] := &(cPrefixo+"EMPORG")	)		//31 - Empresa Origem da marcacao
			( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_FILORG		] := &(cPrefixo+"FILORG")	)		//32 - Filial Origem da marcacao
			( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_MATORG		] := &(cPrefixo+"MATORG")	)		//33 - Matricula Origem da marcacao
			( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_DHORG		] := &(cPrefixo+"DHORG")	)		//34 - Data/Hora Origem da marcacao
			( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_IDORG		] := &(cPrefixo+"IDORG")	)       //35 - Identificacao da Origem da marcacao
		EndIf
		If lGeolocal
			( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_LATITU	] := &(cPrefixo+"LATITU")	)       //36 - Latitude (marcacao geolocalizacao)
			( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_LONGIT	] := &(cPrefixo+"LONGIT")	)       //37 - Longitude (marcacao geolocalizacao)
		EndIf
		If lGeoFence
			( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_GEOFENCE ] := &(cPrefixo+"GEOFEN")	)       //38 - Dentro ou fora do perímetro
		EndIf
		
		If lCCT
			( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_FILCCT	] := &(cPrefixo+"FILCCT")	)       //39 - Filial Convenção coletiva
			( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_CODCCT	] := &(cPrefixo+"CODCCT")	)       //40 - Código Convenção coletiva
		EndIf
		
		If lFuso671
			( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_FUSO	] := &(cPrefixo+"FUSO")	)			//41 - Fuso horário da marcação
		EndIf
		
		If lCCTREP
			( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_CCTREP	] := &(cPrefixo+"CCTREP")	)			//41 - Fuso horário da marcação
		EndIf
		
		( cAliasQuery )->( dbSkip() )
	End While
	
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Fecha a Query e Seta a Area do Arquivo Original              ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
    IF ( ( lQueryOpened ) .and. ( Select( cAliasQuery ) > 0 ) )
    	( cAliasQuery )->( dbCloseArea() )
    	dbSelectArea( cAlias )
    EndIF	

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Restaura a Ordem de Entrada                                  ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	IF !( nSvIndexOrd == IF( lOrdem , 1 , 2 ) )
		( cAlias )->( dbSetOrder( nSvIndexOrd ) )
	EndIF	

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Verifica as Folgas Automaticas apenas Quando Marcacoes ja  ti³
	³ verem Sido Ordenadas										   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	IF ( ( lDiasFolga ) .and. ( lOrdem ) )
		cCod036N := PosSP9("036N",cFil,"P9_CODIGO",2)
		fDiasFolga(aClone(aMarcacoes),@aTabCalend,dPerIni,dPerFim,cCod036N,( cAlias == "SPG" ) , lGrvFolgPa )
	EndIF
	
End Sequence

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Restaura a Area de Entrada                                   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
RestArea( aSvAlias )
	
Return( lGetMarcOk )  


/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³GetMarcOPC  ³Autor ³ Mauricio MR		  ³ Data ³12/08/2005³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Retornar Array aMarcacoes com as Marcacoes do Periodo       ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³GetMarcOpc(@aMarcacoes,...)									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Ponto Eletronico                                            ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³lGetMarcOk                         							³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³ < Vide Parametros Formais >								³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function GetMarcOpc(	aMarcacoes			,;	//01 -> Marcacoes dos Funcionarios
						dPerIni 			,;	//02 -> Periodo Inicial
						dPerFim				,;	//03 -> Periodo Final
						cFil				,;	//04 -> Filial
						cMat				,;	//05 -> Matricula
						cTno				,;	//06 -> Turno
						cSeq				,;	//07 -> Sequencia de Turno
						cCc					,;	//08 -> Centro de Custo
						cAlias				,;	//09 -> Alias para Carga das Marcacoes
						lRecno				,;	//10 -> Se carrega Recno em aMarcacoes
						lGetMarcAuto		,;	//11 -> Se Carrega as Marcacoes Automaticas
						aRecsMarcAut	    ,;	//12 -> Registros de Marcacoes Automaticas que deverao ser Desprezadas
						bCondMarcAut		;	//13 -> Bloco para avaliar as Marcacoes Automaticas que deverao ser Desprezadas
					  )
   
/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Variaveis de Inicializacao Obrigatoria					  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Local aSvAlias			:= GetArea()
Local lGetMarcOk 		:= .T.
Local lQueryOpened		:= .F.

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Variaveis que serao inicializadas no Corpo da Funcao		  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/      
Local cFilMat
Local cAliasQuery  
Local cPrefixo
Local cSetOrdem
Local lNotOrdena    
Local nLenMarc
Local nSerMarc
Local nSerIni
Local nSerFim
Local nSvIndexOrd
Local nSetOrder

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Variaveis de Inicializacao Obrigatoria					  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Local aGetMarcFields	:= {}

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Variaveis que serao inicializadas no Corpo da Funcao		  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Local cQryMarcFields
Local cIniData
Local cFimData
Local cQuery
Local nGetMarcFields
Local nX

Static aGetSP8Fields
Static cQrySP8Fields
Static cQrySPGFields
Static nGetSP8Fields
Static aGetSPGFields
Static nGetSPGFields

DEFAULT cFil				:= SRA->RA_FILIAL
DEFAULT cMat				:= SRA->RA_MAT
DEFAULT cTno				:= SRA->RA_TNOTRAB
DEFAULT cSeq				:= SRA->RA_SEQTURN
DEFAULT dPerIni				:= Ctod("//")
DEFAULT dPerFim				:= Ctod("//")
DEFAULT cAlias				:= "SP8"
DEFAULT lRecno				:= .T.
DEFAULT lGetMarcAuto		:= .T.
DEFAULT bCondMarcAut		:= { || .T. }

aRecsMarcAut				:= {}

nSerIni := __fDHtoNS( dPerIni-7,00.00 )
nSerFim := __fDHtoNS( dPerFim+7,23.59 )
	
Begin Sequence

	cAlias			:= Upper( AllTrim( cAlias ) )
	cAliasQuery 	:= cAlias
	cPrefixo		:= ( PrefixoCpo( cAliasQuery ) + "_" )
	aMarcacoes  	:= {}

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Seleciona o Arquivo de Marca‡”es e Seta a Ordem corresponden³
	³ te:														  ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	nSvIndexOrd := ( cAlias )->( IndexOrd() )
	cSetOrdem	:= ""
	
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Data  <=> _FILIAL+_MAT+_DTOS(_DATA)+STR(_HORA,5,2)    	  	  ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	cSetOrdem += cPrefixo+"FILIAL+"
	cSetOrdem += cPrefixo+"MAT+"
	cSetOrdem += "DTOS("+cPrefixo+"DATA)+"
	cSetOrdem += "STR("+cPrefixo+"HORA,5,2)" 

	nSetOrder	:= RetOrdem( cAlias , cSetOrdem )
	IF !( nSvIndexOrd == nSetOrder )
		( cAlias )->( dbSetOrder( nSetOrder ) )
	EndIF

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Cria array com as marca‡”es do Periodo para o funcion rio.  ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Monta Query para Carga das Marcacoes                         ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	IF ( cAlias == "SP8" )
		IF ( aGetSP8Fields == NIL )
			aGetSP8Fields	:= (cAlias)->( dbStruct() )
			nGetSP8Fields	:= Len( aGetSP8Fields )
			cQrySP8Fields	:= ""
			For nX := 1 To nGetSP8Fields
        		cQrySP8Fields += aGetSP8Fields[ nX , 01 ] + ", "
			Next nX
		EndIF
		aGetMarcFields	:= aClone( aGetSP8Fields )
		cQryMarcFields	:= cQrySP8Fields
		nGetMarcFields	:= nGetSP8Fields
	ElseIF ( cAlias == "SPG" )
		IF ( aGetSPGFields == NIL )
			aGetSPGFields	:= (cAlias)->( dbStruct() )
			nGetSPGFields	:= Len( aGetSPGFields )
			cQrySPGFields	:= ""
			For nX := 1 To nGetSPGFields
        		cQrySPGFields += aGetSPGFields[ nX , 01 ] + ", "
			Next nX
		EndIF	
		aGetMarcFields	:= aClone( aGetSPGFields )
		cQryMarcFields	:= cQrySPGFields
		nGetMarcFields	:= nGetSPGFields
	EndIF
	cIniData	:= Dtos( dPerIni-7 )
	cFimData	:= Dtos( dPerFim+7 )
	cAliasQuery := ( "__Q" + cAliasQuery + "QRY" )
	cQuery := "SELECT "
	cQuery += cQryMarcFields
	cQuery += "R_E_C_N_O_ RECNO "
	cQuery += " FROM "
	cQuery += InitSqlName(cAlias)
	cQuery += " WHERE "
	cQuery += cPrefixo + "FILIAL='"+cFil+"'"
	cQuery += " AND "
	cQuery += cPrefixo + "MAT='"+cMat+"'"
	cQuery += " AND "
	cQuery += cPrefixo + "DATA>='"+cIniData+"'"
	cQuery += " AND "
	cQuery += cPrefixo + "DATA<='"+cFimData+"'"
	//?-Implementado o tratamento do PAPONTA
	cQuery += " AND ("
	cQuery += cPrefixo + "PAPONTA='"+Space(Len(SP8->P8_PAPONTA))+"'"
	cQuery += " OR "
	cQuery += cPrefixo + "PAPONTA='"+DTOS(dPerIni)+DTOS(dPerFim)+"')"
	
	cQuery += " AND "
	cQuery += "D_E_L_E_T_=' ' "
	cQuery += "ORDER BY " + SqlOrder( (cAlias)->( IndexKey() ) )
	cQuery := ChangeQuery(cQuery)
	IF ( lQueryOpened := MsOpenDbf(.T.,"TOPCONN",TcGenQry(NIL,NIL,cQuery),cAliasQuery,.F.,.T.) )
		For nX := 1 To nGetMarcFields
			IF ( aGetMarcFields[ nX , 02 ] <> "C" )
				TcSetField(cAliasQuery,aGetMarcFields[nX,01],aGetMarcFields[nX,02],aGetMarcFields[nX,03],aGetMarcFields[nX,04])
			EndIF
		Next nX
	Else
		cAliasQuery := cAlias
	EndIF	
			
	cFilMat := ( cFil + cMat )

	IF !( lQueryOpened )
		cAliasQuery := cAlias
		( cAliasQuery )->( dbSeek( cFilMat , .F. ) )
	EndIF		

	/*/       
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Obtem as Marcacoes validas para o Periodo                    ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	While ( cAliasQuery )->( !Eof() .and. ( &( cPrefixo+"FILIAL+"+cPrefixo+"MAT" ) == cFilMat ) )

		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Ignora Marcacoes Fora dos Limites Considerando o Serial      ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		IF (;
				( cAliasQuery )->(;
									(;
										nSerMarc := __fDHtoNS( &( cPrefixo+"DATA" ),&( cPrefixo+"HORA" ) );
									);
								  ) < nSerIni;
				.or.;
				( nSerMarc > nSerFim );
			 )
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Ignora Marcacoes Fora dos Limites Considerando o Serial      ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			( cAliasQuery )->( dbSkip() )
			Loop
		EndIF
	
		/*/   
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Verifica se Deve Carregar as Marcacoes Automaticas           ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		IF ( !( lGetMarcAuto ) .and. ( cAliasQuery )->( &( cPrefixo+"FLAG" ) == "A" .and. Eval( bCondMarcAut ) ) )
			IF !( lQueryOpened )
				aAdd( aRecsMarcAut , ( cAliasQuery )->( Recno() ) )
			Else
				aAdd( aRecsMarcAut , ( cAliasQuery )->( RECNO ) )
			EndIF
			( cAliasQuery )->( dbSkip() )
			Loop
		EndIF

		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Carrega as Marcacoes do Funcionario                          ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		aAdd( aMarcacoes , Array( ELEMENTOS_AMARC ) )
		nLenMarc := Len( aMarcacoes )
		( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_DATA   ] := &(cPrefixo+"DATA")	)					//01 - Data
		( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_HORA   ] := &(cPrefixo+"HORA")	)					//02 - Hora
		( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_ORDEM  ] := &(cPrefixo+"ORDEM")	)					//03 - Ordem
		( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_FLAG   ] := &(cPrefixo+"FLAG")	)					//04 - Flag
		IF ( lRecno )
			IF !( lQueryOpened )
				( cAliasQuery )->(aMarcacoes[ nLenMarc , AMARC_RECNO ] := Recno() 	)					//05 - Recno 
			Else                                                                                	
				( cAliasQuery )->(aMarcacoes[ nLenMarc , AMARC_RECNO ] := RECNO		)					//05 - Recno 
			EndIF
		Else
			aMarcacoes[ nLenMarc , AMARC_RECNO ] := 0														//05 - Recno
		EndIF
		( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_TURNO		] := &(cPrefixo+"TURNO")	)			//06 - Turno
		( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_FUNCAO		] := &(cPrefixo+"FUNCAO")	)			//07 - Funcao 
		( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_GIRO		] := &(cPrefixo+"GIRO") 	)			//08 - Giro
		( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_CC			] := &(cPrefixo+"CC")		)			//09 - Centro de Custo
		( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_APONTA		] := &(cPrefixo+"APONTA")	)			//10 - Flag de Apontamento
		( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_RELOGIO		] := &(cPrefixo+"RELOGIO")	)			//11 - Relogio
		( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_TIPOMARC	] := &(cPrefixo+"TPMARCA")	)			//12 - Tipo da Marcacao
		
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Verifica se a Marcacao sera ordenada                         ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		lNotOrdena := (;
							( aMarcacoes[ nLenMarc , AMARC_FLAG ] $ "M,I" ) .and.;
							!Empty( aMarcacoes[ nLenMarc , AMARC_ORDEM  ] );
					   )		
		aMarcacoes[ nLenMarc , AMARC_L_ORIGEM ] := lNotOrdena												//13 - Logico Origem 
		aMarcacoes[ nLenMarc , AMARC_DTHR2STR ] := DataHora2Str(;                                           
																	aMarcacoes[ nLenMarc , AMARC_DATA ] ,;
																	aMarcacoes[ nLenMarc , AMARC_HORA ]  ;
																)                                           //14 - String de Data/Hora para aSort
		( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_PERAPONTA	    ] := &(cPrefixo+"PAPONTA")	)		//15 - Periodo de Apontamento
		aMarcacoes[ nLenMarc , AMARC_TNOPC	] :=  SPACE(2) 											//16 - Semana/Sequencia da Tabela de Horario Padrao utilizado em turno opcional para identificar o horario
	   	( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_SEQ		] := If(lPort1510,&(cPrefixo+"SEMANA"), SPACE(2) )	) //31 - Semana/Sequencia da Tabela de Horario Padrao 
		aMarcacoes[ nLenMarc , AMARC_DIA	] := SPACE(2)											//17 - Dia da semana da Tabela de Horario Padrao (turno opcional) ja identificado
		( cAliasQuery )->( dbSkip() )
	End While

	/*/   
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Fecha a Query e Seta a Area do Arquivo Original              ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
    IF ( ( lQueryOpened ) .and. ( Select( cAliasQuery ) > 0 ) )
    	( cAliasQuery )->( dbCloseArea() )
    	dbSelectArea( cAlias )
    EndIF	

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Restaura a Ordem de Entrada                                  ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	IF !( nSvIndexOrd ==  2  )
		( cAlias )->( dbSetOrder( nSvIndexOrd ) )
	EndIF	

End Sequence

/*/   
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Restaura a Area de Entrada                                   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
RestArea( aSvAlias )
	
Return( lGetMarcOk )  

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³GetTnoOpc   ³Autor ³ Mauricio MR		  ³ Data ³12/08/2005³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Retornar Array com Horario para substituicao do pre-esta-   ³
³          ³belecido em funcao da marcacao realiazada.                  ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³GetTnoOpc(cTurno,...)									    ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Ponto Eletronico                                            ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³lRet	                         							³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³ < Vide Parametros Formais >								³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function GetTnoOpc( cTurno,  dData, aDiaTurnoOK, aTabPadrao, aTabTno, cFilSPJ, aMarcacoes)

Local aReturn	:= {}                
Local aHorOpc
Local aSerial
Local aTemp
Local cSeq         
Local nDia  
Local lRet	:= .F.  
Local nHorOpc		 
Local nPos1
Local nPos2
Local nPosTnoOpc		
Local nPosTnoEscolhido 
Local nHora
Local nSerIniTno
Local nSerFimTno 
Local uHora        
Local nSerIni
Local nSerFim
Local nSerMeiaJorn
Local nI
Local nPosTurno

Begin Sequence 
    nHora	:= aTabTno[01]                                                                   
    cSeq	:= aTabTno[19]
    nDia	:= aTabTno[20]
    
	//-- Obtem Todos os Horarios para Filial + Turno + Dia
	If (nPosTnoOpc:=Ascan(__aAllTnoOpc,{|x| ( x[1] + x[2] ) == (cFilSPJ + cTurno ) }) ) >  0
		aHorOpc:=aClone(__aAllTnoOpc[nPosTnoOpc, 3, nDia])
		
		nPosTurno := Ascan(aSr6Info,{|x| ( x[1] + x[2] ) == (cFilSPJ + cTurno ) })

		For nI:=1 To Len(aHorOpc)
			If (nPosTurno > 0,aAdd(aHorOpc[nI], aSr6Info[nPosTurno, 12]),aAdd(aHorOpc[nI], aSr6Info[1, 12]))
		Next
		
		aAdd(aHorOpc, aTabTno)
		aAdd(aHorOpc[Len(aHorOpc)], cTurno)
		aSort( @aHorOpc , NIL , NIL , { |x,y| ( x[1] < y[1] ) } )    	 
	Else    
	   Break
	Endif
	
	//-- Verifica se existe horario para o turno opcional
    If Empty(aHorOpc)                     
       Break
    Endif   
                                               
	//Obtem os limites maximos possiveis para o dia  
	aSerial		:= fLimitTnoOpc(dData, aHorOpc[ 1 ] )
	nSerIniTno 	:= aSerial[1]                     
	aSerial		:= fLimitTnoOpc(dData, aHorOpc[ Len(aHorOpc) ] )
	nSerFimTno 	:= aSerial[2]
	
	//-- Procura pela primeira marcacao ainda nao verificada
	
	If (nPos1:= Ascan(aMarcacoes, {|x| EMPTY( x[AMARC_TNOPC] )  } ) )  ==   0
	   Break
	Endif   
	nSerIni:=nSerFim:=0
    
    //-- Corre todas as marcacoes a partir da primeira marcacao nao classificada
	For nPos2:= nPos1 To Len(aMarcacoes)
 	
		If ( !Empty( aMarcacoes[nPos2, AMARC_TNOPC] ) )
	 		Loop
		Endif	

	    uHora	:= aMarcacoes[nPos2, AMARC_HORA]
	    uHora	:= If( ValType( uHora ) = "C", Val(uHora), uHora ) 
	    nSerMarc:= __fDHtoNS(aMarcacoes[nPos2, AMARC_DATA], uHora )
	    
	    //-- Verifica se Marcacao esta fora dos limites maximos do turno
	    If nSerMarc < nSerIniTno 
	       Loop                                                                     
	       
	    ElseIf 	nSerMarc > nSerFimTno
	    	Exit
	    Endif
	    
	    //-- Verifica se Marcacao esta entre os limites do turno ja verificado  (se ja foi identificado)
	    If !Empty(nSerIni)
	        If (nSerMarc < nSerIni) 
	            Loop
	        ElseIf nSerMarc > nSerFim  .and. aMarcacoes[nPos2, AMARC_ORDEM] <> aMarcacoes[nPos1, AMARC_ORDEM]
	            Exit
	        Else
	        	aMarcacoes[nPos2, AMARC_TURNO]	:= cTurno  	    
		        aMarcacoes[nPos2, AMARC_SEQ] 	:= aHorOpc[ nPosTnoEscolhido, 19 ]
		   		aMarcacoes[nPos2, AMARC_DIA] 	:= aHorOpc[ nPosTnoEscolhido, 20 ] 
		   		aMarcacoes[nPos2, AMARC_TNOPC] 	:= aHorOpc[ nPosTnoEscolhido, 19 ]
		        Loop
	        Endif    
	    Endif 
	    
   	    //-- Verifica a qual das entradas possiveis para o turno a marcacao mais se aproxima
    	aTemp := {} 
    	For nHorOpc  := 1 To Len(aHorOpc) 
	    	aAdd( aTemp , { nHorOpc , DataHora2Val( 	aMarcacoes[nPos2, AMARC_DATA]	,;
													 	uHora							,;
													 	dData							,;
													 	aHorOpc[ nHorOpc , 01 ]	    	,;
													 	"H"							 	;
												  ),aHorOpc[nHorOpc][len(aHorOpc[nHorOpc])];
							};											  
			 	)
		Next nHorOpc
		
		aSort( aTemp, NIL, NIL, { |x, y| x[2] <= y[2] } )
	                            
	 	//--Gera o Limite do Turno Selecionado para o Dia
		nPosTnoEscolhido 	:= aTemp[1,1]
		aSerial				:= fLimitTnoOpc(dData, aHorOpc[ nPosTnoEscolhido], .T. )
	    nSerIni				:= aSerial[1]
	    nSerFim				:= aSerial[2]  
	    nSerMeiaJorn		:= aSerial[3]  
	        
	   	//-- Verifica se a Marcacao esta fora dos limites do turno (Entre o HorMenos e a MeiaJornada)
	    If ( nSerMarc < nSerIni .or.  nSerMarc > nSerMeiaJorn )
	       nSerIni := ""
	       Loop                                                                     
	    Endif  

		cTurno := aTemp[1,3]
			
	   	aMarcacoes[nPos2, AMARC_TURNO]	:= cTurno 	    
	    aMarcacoes[nPos2, AMARC_SEQ] 	:= aHorOpc[ nPosTnoEscolhido, 19 ]
	   	aMarcacoes[nPos2, AMARC_DIA] 	:= aHorOpc[ nPosTnoEscolhido, 20 ]
		aMarcacoes[nPos2, AMARC_TNOPC] 	:= aHorOpc[ nPosTnoEscolhido, 19 ]
	    aDiaTurnoOK[ Len(aDiaTurnoOK), 2 ]  	:= {cTurno, aHorOpc[ nPosTnoEscolhido, 19 ], aHorOpc[ nPosTnoEscolhido, 20 ] }
	    
	    aTabTno[01] 	:=aHorOpc[ nPosTnoEscolhido][01]		// 01 - 1a Entrada
		aTabTno[02] 	:=aHorOpc[ nPosTnoEscolhido][02]		// 02 - 1a Saida
		aTabTno[03] 	:=aHorOpc[ nPosTnoEscolhido][03]		// 03 - 2a Entrada
		aTabTno[04] 	:=aHorOpc[ nPosTnoEscolhido][04]		// 04 - 2a Saida
		aTabTno[05] 	:=aHorOpc[ nPosTnoEscolhido][05]		// 05 - 3a Entrada
		aTabTno[06] 	:=aHorOpc[ nPosTnoEscolhido][06]		// 06 - 3a Saida
		aTabTno[07] 	:=aHorOpc[ nPosTnoEscolhido][07]		// 07 - 4a Entrada
		aTabTno[08] 	:=aHorOpc[ nPosTnoEscolhido][08]		// 08 - 4a Saida
		aTabTno[09] 	:=aHorOpc[ nPosTnoEscolhido][09]		// 09 - Horas Trabalhadas 1a. Jornada
		aTabTno[10] 	:=aHorOpc[ nPosTnoEscolhido][10]		// 10 - Horas Trabalhadas 2a. Jornada
		aTabTno[11] 	:=aHorOpc[ nPosTnoEscolhido][11]		// 11 - Horas Trabalhadas 3a. Jornada
		aTabTno[12] 	:=aHorOpc[ nPosTnoEscolhido][12]		// 12 - Horas Trabalhadas 4a. Jornada
		aTabTno[13] 	:=aHorOpc[ nPosTnoEscolhido][13]		// 13 - Horas de Intervalo 1S
		aTabTno[14] 	:=aHorOpc[ nPosTnoEscolhido][14]		// 14 - Horas de Intervalo 2S
		aTabTno[15] 	:=aHorOpc[ nPosTnoEscolhido][15]		// 15 - Horas de Intervalo 3S
		aTabTno[16] 	:= ""									// 16 - Marcacao e do dia seguinte ?
		aTabTno[17] 	:=aHorOpc[ nPosTnoEscolhido][17]		// 17 - Numero de Marcacoes
		aTabTno[29] 	:=aHorOpc[ nPosTnoEscolhido][29]		// 29 - Aponta Nona Hora
		aTabTno[30] 	:=aHorOpc[ nPosTnoEscolhido][30]		// 30 - Limite de Horario Inicial
		aTabTno[31] 	:=aHorOpc[ nPosTnoEscolhido][31]		// 31 - Limite de Horario Final
		aTabTno[32] 	:=aHorOpc[ nPosTnoEscolhido][32]		// 32 - 1a. Jornada Continua
		aTabTno[33] 	:=aHorOpc[ nPosTnoEscolhido][33]		// 33 - 2a. Jornada Continua
		aTabTno[34]		:=aHorOpc[ nPosTnoEscolhido][34]		// 34 - 3a. Jornada Continua
		aTabTno[35]		:=aHorOpc[ nPosTnoEscolhido][35]		// 35 - 4a. Jornada Continua
		aTabTno[36]		:=aHorOpc[ nPosTnoEscolhido][36]		// 36 - Codigo da Refeicao
	  
		//Obtem os limites maximos possiveis para o dia  
		nSerIniTno 	:= nSerIni                    
		nSerFimTno 	:= nSerFim

	    lRet	:= .T.
	Next nPos2
End

AADD( aReturn, lRet )
AADD( aReturn, cTurno)

Return (aReturn)   

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³fLimitTnoOpc³Autor ³ Mauricio MR		  ³ Data ³12/08/2005³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Retornar Array com os limites do dia para a identificacao   ³
³          ³de horario para Turnos Opcionais do funcionario.            ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³fLimitTnoOpc(dDataTno, aTabTno)							    ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Ponto Eletronico                                            ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³Array  com os limites {nSerialIni, nSerialFim}	 			³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³ < Vide Parametros Formais >								³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function fLimitTnoOpc(dDataTno, aTabTno, lMeiaJorn)

Local dData		:=	dDataTno
Local dDataI		
Local dDataF			
Local nY
Local nFornY    := 8 // 1E, 1S...4E,4S.
Local nSerialIni
Local nSerialFim    
Local nSeriaMeiaJorn
Local nHoraI			
Local nHoraF			
Local nDifHrs 		

Local aMeiaJorn		
Local aRetorno		
   
DEFAULT lMeiaJorn	:= .F.

    /*/
    
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Loop For/Next para a Carga das Marcacoes do Dia             ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/  
	
	For nY := 1 To nFornY

		/*/
		
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Abandona Quando as Marcacoes estiverem Vazias e Nao For  Jor³
		³ nada Continua												  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	
		IF (;
				( ( nY == 3 ) .and. ( ( aTabTno[ 03 ] + aTabTno[  04 ] ) == 0 ) .and. ( aTabTno[ 33 ] != "S" ) ) .or. ;
		   		( ( nY == 5 ) .and. ( ( aTabTno[ 05 ] + aTabTno[  06 ] ) == 0 ) .and. ( aTabTno[ 34 ] != "S" ) ) .or. ;
		   		( ( nY == 7 ) .and. ( ( aTabTno[ 07 ] + aTabTno[  08 ] ) == 0 ) .and. ( aTabTno[ 35 ] != "S" ) )      ;
		   	)	
			Exit
		EndIF

		/*/
	
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Incrementa dData e nDias Quando Marcacao for do Dia Seguinte³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	
		IF ( aTabTno[ nY ] <  aTabTno[ IF( nY == 1 , nY , nY-1 ) ] )
			++dData
		EndIF

		/*/
		
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Incrementa dData e nDias Caso Jornada Continua			  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	
		IF (;
				 (;
							( ( nY == 2 ) .and. ( aTabTno[ 32 ] == "S" ) ) .or. ;
		   		  	    	( ( nY == 4 ) .and. ( aTabTno[ 33 ] == "S" ) ) .or. ;
		   			    	( ( nY == 6 ) .and. ( aTabTno[ 34 ] == "S" ) ) .or. ;
		   			    	( ( nY == 8 ) .and. ( aTabTno[ 35 ] == "S" ) )	   ;
		   		 );
		   	)
			++dData
		EndIF

		IF ( nY == 1 )
			nSerialIni		:= ( __fDhToNS( dData , aTabTno[ nY ] ) - __fDhToNS( NIL , aTabTno[ 30 ] ) )
			If lMeiaJorn
				dDataI		:= dData
				nHoraI		:= aTabTno[ nY ]
			Endif	
		EndIF
	Next nY
	nSerialFim		:= ( __fDhToNS( dData , aTabTno[ Min(nY-1, nFornY) ] ) + __fDhToNS( NIL ,aTabTno[ 31 ] ) )

	If lMeiaJorn
		dDataF			:= dData
		nHoraF			:= aTabTno[ Min(nY-1, nFornY) ]	
		
		nDifHrs 		:= DataHora2Val(dDataI,	nHoraI,	dDataF, nHoraF)
		nDifHrs 		:= __NoRound( nDifHrs/2 , 0 )
		nDifHrs 		:= __Min2Hrs( nDifHrs )
	
		aMeiaJorn		:= RetFimTab(dDataI, nHoraI, nDifHrs )										
		nSeriaMeiaJorn	:= __fDhToNS( aMeiaJorn[1] , aMeiaJorn[2] )
	    aRetorno		:= {nSerialIni, nSerialFim, nSeriaMeiaJorn }
    Else
	    aRetorno		:= {nSerialIni, nSerialFim, Nil } 
    Endif
    
Return( aRetorno )


/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³LoadTnoOpc  ³Autor ³ Mauricio MR		  ³ Data ³12/08/2005³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Retornar Array com os horarios dos turnos opcionais de um   ³
³          ³turno.												        ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³LoadTnoOpc(cFilSPJ, ...)								    ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Ponto Eletronico                                            ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³lRet											 			³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³ < Vide Parametros Formais >								³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/       
 
Static Function LoadTnoOpc(cFilSPJ, cTurno,__aAllTnoOpc, aTabPadrao) 
Local aArea			:= GetArea()
Local aSeq			:= {}
Local cTnoOpc		:= ""
Local cR6TnoOpc		:= ""
Local lRet			:= .F.
Local nPosAllTnoOpc
Local nPosSeq
Local nPosTabPad
Local nPosTr		:= 0
DEFAULT __aAllTnoOpc	:= {}

Begin Sequence
	//-- Verifica se Turno ainda nao foi carregado
	If (nPosAllTnoOpc	:= Ascan(__aAllTnoOpc, {|x| x[1] == cFilSPJ .And. x[2] == cTurno } ) ) ==  0
	    //-- Verifica se trata de um turno opcional
		IF ( nPosTr := aScan( aSr6Info , { |x| x[1] == cFilSPJ .and. x[2] == cTurno } ) ) == 0
			cCondSR6 := "% R6_FILIAL = '"+cFilSPJ+"' AND "
			cCondSR6 += "R6_TURNO  = '"+cTurno+"' %"
							
			cQrySR6 := GetNextAlias()
			
			BeginSql alias cQrySR6
				SELECT R6_INIHNOT, R6_FIMHNOT, R6_MINHNOT, R6_APODFER, R6_TPEXFER, R6_TPEXFEN, R6_AUTOHEF, R6_ASFOLGA, R6_TNOOPC, R_E_C_N_O_ RECNO
				FROM %table:SR6% SR6
				WHERE
				%exp:cCondSR6% AND SR6.%NotDel%
			EndSql
			
			If (cQrySr6)->(!Eof())
				aAdd( aSr6Info, { cFilSPJ, cTurno, (cQrySr6)->(R6_INIHNOT), (cQrySr6)->(R6_FIMHNOT), (cQrySr6)->(R6_MINHNOT), (cQrySr6)->(R6_APODFER), (cQrySr6)->(R6_TPEXFER), (cQrySr6)->(R6_TPEXFEN), (cQrySr6)->(R6_AUTOHEF), (cQrySr6)->RECNO, (cQrySr6)->(R6_ASFOLGA), (cQrySr6)->(R6_TNOOPC) } )
				SR6->( MsGoto( (cQrySR6)->RECNO ) )						
				cR6TnoOpc	:= (cQrySr6)->(R6_TNOOPC) 
			EndIf
			(cQrySR6)->(dbCloseArea())
		Else
			SR6->( MsGoto( aSr6Info[nPosTr, 10] ) )
			cR6TnoOpc	:= aSr6Info[nPosTr, 12]				
	    EndIf

	    cTnoOpc:= cR6TnoOpc

	    If !Empty( cTnoOpc )
		    If (nPosTabPad	:= aScan(aTabPadrao, { |x| x[1] == cFilSPJ .And. x[2] == cTnoOpc })) == 0  
		   	   	/*/   
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Carrega a Tabela Para o turno ainda nao carregado           ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
				fTabPadrao( @aTabPadrao , cFilSPJ , cTnoOpc, .T. ) 
			    If (nPosTabPad:= aScan(aTabPadrao, { |x| x[1] == cFilSPJ .And. x[2] == cTnoOpc })) == 0
			       Break
			    Endif
			Endif
		
			//-- Monta Tabela de Horarios Opcionais para o turno lido
			AADD(__aAllTnoOpc, {cFilSPJ, cTurno, Array(7,1) } )  
			nPosAllTnoOpc	:= Len(__aAllTnoOpc)
 		    Aeval(__aAllTnoOpc[ nPosAllTnoOpc,3 ], { |x| x:= {} } )
		   	aSeq		:= aClone( aTabPadrao[ nPosTabPad, 3 ] )
		   	For nPosSeq := 1 To Len(aSeq)  
		   	  	AADD(__aAllTnoOpc[nPosAllTnoOpc, 3, aSeq[nPosSeq, 20] ],  aClone( aSeq[nPosSeq] )  )	   		
		   	Next  
		    lRet:= .T.		   	
		Endif   	
	Else                        
	    lRet:= .T.		   	
	Endif       
End

RestArea(aArea)

Return( lRet )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³PutMarcacoes³Autor ³ Marinaldo de Jesus   ³ Data ³03/04/2002³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Gravar o Array aMarcacoes                                   ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Ponto Eletronico                                            ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL                                							³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/

Function PutMarcacoes(	aMarcacoes	,;	//01 -> Array contendo as Marcacoes do Funcionario
						cFil		,;	//02 -> Filial do Funcionario
						cMat		,;	//03 -> Matricula do Funcionario
						cAlias		,;	//04 -> Arquivo para Gravacao ( "SP8" ou "SPG" )
						lNewRec		,;	//05 -> Se Forca a Inclusao de Novo Registro
						lSubsDtHr	,;	//06 -> Se Forca a Substituicao da Data/Hora
						nPosIni		,;	//07 -> Posicao Inicial para o aMarcacoes
						lSubsAll	,;	//08 -> Se Forca a Substituicao de Tudo
						lWorkFlow	,;	//09 -> Se eh executado via workflow
						nTipo		,;	//10 -> Se leitura, apontamento ou ambos
						lCpoUser	,;	//11 -> Se deve gravar campos do usuário
						lUsaFilMat	 ;	//12 -> Considera a Filial e Matricula informada nos parâmetros
					 )

Local cSvFilAnt := cFilAnt

Local aArea
Local cChave
Local cPrefixo
Local cSetOrdem
Local lGoto
Local lAddNew
Local lLock
Local nCont
Local nCount
Local nLenMarc
Local nOrder
Local cRetQry := ""

Local aCposChar
Local aTamHora
Local cTableName
Local cCpoRecno
Local cQryUpdate	
Local nCpoChar
Local nCposChar
Local lGeolocal := SP8->(ColumnPos("P8_LATITU")) > 0 .And. SP8->(ColumnPos("P8_LONGIT")) > 0
Local lGeoFence	:= lGeolocal .And. SP8->(ColumnPos("P8_GEOFEN")) > 0
Local lIntegRR1	:= .F.
Local lTsRep	:= SuperGetMv("MV_TSREP", .F., .F.)
Local lIntRR1Car:= SuperGetMv("MV_APICLOD", .F., .T.)
Local lIntRR1Sur:= SuperGetMv("MV_APISUR", .F., .T.)
Local lTemRR1	:= AliasInDic("RR1")
Local lCaClockIn:= SuperGetMv( "MV_APICLO0" , NIL , .F. )
Local lFuso671	:= SP8->(ColumnPos("P8_FUSO")) > 0
Local lCCTREP	:= SP8->(ColumnPos("P8_CCTREP")) > 0
Local lCCT		:= SP8->(ColumnPos("P8_CODCCT")) > 0
Local cUserPon	:= If(!Empty(GetGlbValue("__cUserPon")), GetGlbValue("__cUserPon"), __cUserId)

DEFAULT aMarcacoes	:= {}
DEFAULT cFil		:= SRA->RA_FILIAL
DEFAULT cMat		:= SRA->RA_MAT
DEFAULT cAlias		:= "SP8"
DEFAULT lNewRec		:= .F.
DEFAULT lSubsDtHr	:= .F.
DEFAULT nPosIni		:= 1
DEFAULT lSubsAll	:= .F.
DEFAULT	lWorkFlow	:= .F.
DEFAULT	nTipo		:= 1
DEFAULT	lUsaFilMat	:= .T.

If (lTsRep .And. !lIntRR1Sur) .Or. (lCaClockIn .And. !lIntRR1Car)
	lIntegRR1 := .F.
ElseIf (lTsRep .And. lIntRR1Sur .And. lTemRR1) .Or. (lCaClockIn .And. lIntRR1Car .And. lTemRR1)
	lIntegRR1 := .T.
EndIf

If Type("lPn010Auto") == "U"
	Private lPn010Auto := .F.
Endif

cAlias	    := Upper( AllTrim( cAlias ) )
cPrefixo	:= ( PrefixoCpo( cAlias ) + "_" )
cFilAnt		:= IF( !Empty( cFil ) , cFil , cFilAnt )

aTamHora	:= TamSx3( cPrefixo+"HORA" )
cTableName	:= InitSqlName( cAlias )
cCpoRecno	:= "R_E_C_N_O_"
cQryUpdate	:= ""

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Garanto que Filial e Matricula nao Terao Strings Nulas de  for³
³ma a Evitar erro no UpDate quando Base em TOP                 ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
cFil	:= Padr( cFil	, GetSx3Cache( cPrefixo+"FILIAL"	, "X3_TAMANHO" ) )
cMat	:= Padr( cMat	, GetSx3Cache( cPrefixo+"MAT"		, "X3_TAMANHO" ) )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Obtenho o Tamanho dos Campos Char para garantir que no  Update³
³nao Ocorra erro de NULLL quando Base em TOP                   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
aCposChar := {}
aAdd( aCposChar , { AMARC_FLAG		, GetSx3Cache( cPrefixo+"FLAG"		, "X3_TAMANHO" ) } )
aAdd( aCposChar , { AMARC_FUNCAO	, GetSx3Cache( cPrefixo+"FUNCAO"	, "X3_TAMANHO" ) } )
aAdd( aCposChar , { AMARC_GIRO		, GetSx3Cache( cPrefixo+"GIRO"		, "X3_TAMANHO" ) } )
aAdd( aCposChar , { AMARC_CC		, GetSx3Cache( cPrefixo+"CC" 		, "X3_TAMANHO" ) } )
aAdd( aCposChar , { AMARC_RELOGIO	, GetSx3Cache( cPrefixo+"RELOGIO"	, "X3_TAMANHO" ) } )
aAdd( aCposChar , { AMARC_ORDEM		, GetSx3Cache( cPrefixo+"ORDEM" 	, "X3_TAMANHO" ) } )
aAdd( aCposChar , { AMARC_TURNO		, GetSx3Cache( cPrefixo+"TURNO" 	, "X3_TAMANHO" ) } )
aAdd( aCposChar , { AMARC_APONTA	, GetSx3Cache( cPrefixo+"APONTA"	, "X3_TAMANHO" ) } )
aAdd( aCposChar , { AMARC_TIPOMARC	, GetSx3Cache( cPrefixo+"TPMARCA"	, "X3_TAMANHO" ) } )
If lPort1510
	aAdd( aCposChar , { AMARC_MOTIVRG	, GetSx3Cache( cPrefixo+"MOTIVRG"	, "X3_TAMANHO" ) } )
	aAdd( aCposChar , { AMARC_SEQ		, GetSx3Cache( cPrefixo+"SEMANA"	, "X3_TAMANHO" ) } )
	aAdd( aCposChar , { AMARC_EMPORG	, GetSx3Cache( cPrefixo+"EMPORG"	, "X3_TAMANHO" ) } )		
	aAdd( aCposChar , { AMARC_FILORG	, GetSx3Cache( cPrefixo+"FILORG"	, "X3_TAMANHO" ) } )		
	aAdd( aCposChar , { AMARC_MATORG	, GetSx3Cache( cPrefixo+"MATORG"	, "X3_TAMANHO" ) } )
	aAdd( aCposChar , { AMARC_DHORG		, GetSx3Cache( cPrefixo+"DHORG"		, "X3_TAMANHO" ) } )		
	aAdd( aCposChar , { AMARC_IDORG		, GetSx3Cache( cPrefixo+"IDORG"		, "X3_TAMANHO" ) } )
EndIf
If lGeolocal //Geolocalizacao
	aAdd( aCposChar , { AMARC_LATITU, GetSx3Cache( cPrefixo+"LATITU"	, "X3_TAMANHO" ) } )
	aAdd( aCposChar , { AMARC_LONGIT, GetSx3Cache( cPrefixo+"LONGIT"	, "X3_TAMANHO" ) } )
EndIf

If lGeoFence .And. lIntegRR1
	aAdd( aCposChar , { AMARC_GEOFENCE, GetSx3Cache( cPrefixo+"GEOFEN"	, "X3_TAMANHO" ) } )
EndIf

If lFuso671
	aAdd( aCposChar , { AMARC_FUSO, GetSx3Cache( cPrefixo+"FUSO"	, "X3_TAMANHO" ) } )
EndIf

If lCCTREP
	aAdd( aCposChar , { AMARC_CCTREP, GetSx3Cache( cPrefixo+"CCTREP"	, "X3_TAMANHO" ) } )
EndIf

If lCCT
	aAdd( aCposChar , { AMARC_FILCCT, GetSx3Cache( cPrefixo+"FILCCT"	, "X3_TAMANHO" ) } )
	aAdd( aCposChar , { AMARC_CODCCT, GetSx3Cache( cPrefixo+"CODCCT"	, "X3_TAMANHO" ) } )
EndIf

nCposChar := Len( aCposChar )

aArea 		:= ( cAlias )->( GetArea() )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Seleciona o Arquivo de Marca‡”es e Seta a Ordem corresponden³
³te: _FILIAL+_MAT+_DTOS(_DATA)+STR(_HORA,5,2)    	  		  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
cSetOrdem	:= cPrefixo+"FILIAL+"
cSetOrdem	+= cPrefixo+"MAT+"
cSetOrdem	+= "DTOS("+cPrefixo+"DATA)+"
cSetOrdem	+= "STR("+cPrefixo+"HORA,5,2)" 
    	
nOrder		:= RetOrdem( cAlias , cSetOrdem )	

IF !( aArea[2] == nOrder )
	( cAlias )->( dbSetOrder( nOrder ) )
EndIF	

nLenMarc := Len( aMarcacoes )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Ordena as marca‡”es                                         ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
// Se for via ExecAuto
If lPn010Auto

	aTabPadrao := {}

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Cria Tabela de Horario Padrao do Funcionario                ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	IF SRA->( !CriaCalend(	dPerIni			,;	//01 -> Data Inicial do Periodo
							dPerFim			,;	//02 -> Data Final do Periodo
							SRA->RA_TNOTRAB	,;	//03 -> Turno Para a Montagem do Calendario
							SRA->RA_SEQTURN	,;	//04 -> Sequencia Inicial para a Montagem Calendario
							@aTabPadrao		,;	//05 -> Array Tabela de Horario Padrao
							@aTabCalend		,;	//06 -> Array com o Calendario de Marcacoes
							SRA->RA_FILIAL	,;	//07 -> Filial para a Montagem da Tabela de Horario
							SRA->RA_MAT 	,;	//08 -> Matricula para a Montagem da Tabela de Horario
							SRA->RA_CC		,;	//09 -> Centro de Custo para a Montagem da Tabela
							NIL     		,;	//10 -> Array com as Trocas de Turno
							NIL				,;	//11 -> Array com Todas as Excecoes do Periodo
							NIL				,;	//12 -> Se executa Query para a Montagem da Tabela Padrao
							.T.				,;	//13 -> Se executa a funcao se sincronismo do calendario
							NIL			 	;	//14 -> Se Forca a Criacao de Novo Calendario
						  );
		     )
		aAdd(aLogFile, STR0236+ AllTrim(SRA->RA_TNOTRAB) + '.')												// '- Foram encontradas inconsistencias na Tabela do Turno'
		SRA->( aAdd(aLogFile, STR0237  + AllTrim(SRA->RA_MAT) + ' - ' + AllTrim(SRA->RA_NOME) + STR0238 ) )	// '  As marca‡”es do funcionario '###' nao'
		aAdd(aLogFile, STR0239 )																				// '  serao classificadas. Verificar o castramento de Tabelas de Hor rio para este Turno.'
		Return
	EndIF

	PutOrdMarc( @aMarcacoes , aTabCalend , .F., .F., dPerIni, dPerFim, cFil, cMat )
Endif

For nCount := nPosIni To nLenMarc
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Garanto que os Campos Char nao Terao Strings Nulas de forma  a³
	³ma a Evitar erro no UpDate quando Base em TOP                 ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	For nCpoChar := 1 To nCposChar
		aMarcacoes[ nCount , aCposChar[ nCpoChar , 1 ] ] := Padr( aMarcacoes[ nCount , aCposChar[ nCpoChar , 1 ] ] , aCposChar[ nCpoChar , 2 ] )
	Next nCpoChar
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Se nao estiver forcando a Inclusao de um Novo Registro		   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	IF !( lNewRec )
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Posiciona no Registro a ser Alteradao e seta a Inclusao   como³
		³False (.F.)												   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		IF ( lGoto := ( ValType( aMarcacoes[ nCount , AMARC_RECNO ] ) == "N" .and. !Empty( aMarcacoes[ nCount , AMARC_RECNO ] ) ) )
			lAddNew	:= .F.
		Else
			cChave	:= ( cFil + cMat + Dtos( aMarcacoes[ nCount , AMARC_DATA ] ) + Str( aMarcacoes[ nCount , AMARC_HORA ] , 5 , 2 ) )
			lAddNew := !( ( cAlias )->( dbSeek( cChave , .F. ) ) )
		EndIF
	Else
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Forca a Inclusao de um novo Registro						   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		lAddNew := .T.
	EndIF
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Trava o Registro conforme lAddNew   						   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	IF lAddNew
		lLock := ( cAlias )->( RecLock( cAlias , lAddNew , .F. ) )
	Else
		lLock := .T.
	EndIF

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Se nao Consegui o Lock Tenta o Proximo						   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	IF !( lLock )
		Loop
	EndIF

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Grava as Informacoes                						   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	IF ( ( lAddNew ) .or. ( lSubsAll  ) )
		IF ( lAddNew )
			If (lUsaFilMat, (cAlias)->( &(cPrefixo+"FILIAL")) := cFil, (cAlias)->( &(cPrefixo+"FILIAL")) := aMarcacoes[nCount, AMARC_FILORG])
			If (lUsaFilMat, (cAlias)->( &(cPrefixo+"MAT")) := cMat, (cAlias)->( &(cPrefixo+"MAT")) := aMarcacoes[nCount, AMARC_MATORG])
			( cAlias )->( &( cPrefixo+"DATA"    ) )	:= aMarcacoes[ nCount , AMARC_DATA    	]		//01 - Data da Marcacao
			( cAlias )->( &( cPrefixo+"HORA"    ) )	:= aMarcacoes[ nCount , AMARC_HORA    	]		//02 - Hora da Marcacao
			( cAlias )->( &( cPrefixo+"FLAG"    ) )	:= aMarcacoes[ nCount , AMARC_FLAG    	]		//04 - Flag (Origem) da Marcacao
			( cAlias )->( &( cPrefixo+"FUNCAO"  ) )	:= aMarcacoes[ nCount , AMARC_FUNCAO	]		//07 - Funcao do Relogio
			( cAlias )->( &( cPrefixo+"GIRO"    ) )	:= aMarcacoes[ nCount , AMARC_GIRO    	]		//08 - Giro do Relogio
			( cAlias )->( &( cPrefixo+"CC"      ) )	:= aMarcacoes[ nCount , AMARC_CC      	]		//09 - Centro de Custo da Marcacao
			( cAlias )->( &( cPrefixo+"RELOGIO" ) )	:= aMarcacoes[ nCount , AMARC_RELOGIO 	]		//11 - Relogio da Marcacao
		Else
			cQryUpdate := "UPDATE "
			cQryUpdate += cTableName
			cQryUpdate += " SET "
			cQryUpdate += cPrefixo +"FILIAL='"	+ cFil + "'"
			cQryUpdate += ", "
			cQryUpdate += cPrefixo +"MAT='"		+ cMat + "'"
			cQryUpdate += ", "
			cQryUpdate += cPrefixo +"DATA='"	+ Dtos( aMarcacoes[ nCount , AMARC_DATA ] ) + "'"
			cQryUpdate += ", "
			cQryUpdate += cPrefixo +"HORA="		+ Str(  aMarcacoes[ nCount , AMARC_HORA ] , aTamHora[1] , aTamHora[2] )
			cQryUpdate += ", "
			cQryUpdate += cPrefixo +"FLAG='"	+ aMarcacoes[ nCount , AMARC_FLAG    	] + "'"
			cQryUpdate += ", "
			cQryUpdate += cPrefixo +"FUNCAO='"	+ aMarcacoes[ nCount , AMARC_FUNCAO		] + "'"
			cQryUpdate += ", "
			cQryUpdate += cPrefixo +"GIRO='"	+ aMarcacoes[ nCount , AMARC_GIRO   	] + "'"
			cQryUpdate += ", "
			cQryUpdate += cPrefixo +"CC='"		+ aMarcacoes[ nCount , AMARC_CC      	] + "'"
			cQryUpdate += ", "
			cQryUpdate += cPrefixo +"RELOGIO='"	+ aMarcacoes[ nCount , AMARC_RELOGIO	] + "'"
		EndIF
	ElseIF ( lSubsDtHr )
		cQryUpdate := "UPDATE "
		cQryUpdate += cTableName
		cQryUpdate += " SET "
		cQryUpdate += cPrefixo +"DATA='"	+ Dtos( aMarcacoes[ nCount , AMARC_DATA ] ) + "'"
		cQryUpdate += ", "
		cQryUpdate += cPrefixo +"HORA="		+ Str(  aMarcacoes[ nCount , AMARC_HORA ] , aTamHora[1] , aTamHora[2] )
	EndIF
	
	IF lAddNew
		( cAlias )->( &( cPrefixo+"ORDEM"   ) )	:= aMarcacoes[ nCount , AMARC_ORDEM   	]	//03 - Ordem da Marcacao
		( cAlias )->( &( cPrefixo+"TURNO"   ) )	:= aMarcacoes[ nCount , AMARC_TURNO		]	//06 - Turno da Marcacao
		( cAlias )->( &( cPrefixo+"APONTA"  ) )	:= aMarcacoes[ nCount , AMARC_APONTA  	]	//10 - Flag de Marcacao Apontada
		( cAlias )->( &( cPrefixo+"TPMARCA" ) )	:= aMarcacoes[ nCount , AMARC_TIPOMARC	]	//12 - Tipo da Marcacao
		( cAlias )->( &( cPrefixo+"PAPONTA" ) )	:= aMarcacoes[ nCount , AMARC_PERAPONTA	]	//15 - String de Data com o Periodo de Apontamento
		( cAlias )->( &( cPrefixo+"FLAG"    ) )	:= aMarcacoes[ nCount , AMARC_FLAG    	]	//04 - Flag (Origem) da Marcacao
		If lPort1510
			( cAlias )->( &( cPrefixo+"NUMREP"  ) )	:= aMarcacoes[ nCount , AMARC_NUMREP	] 						//26 - Numero do REP
			( cAlias )->( &( cPrefixo+"TPMCREP" ) )	:= aMarcacoes[ nCount , AMARC_TPMCREP	] 						//27 - Tipo de Marcacao no REP
			( cAlias )->( &( cPrefixo+"TIPOREG" ) )	:= aMarcacoes[ nCount , AMARC_TIPOREG	]						//28 - Tipo de Registro
			( cAlias )->( &( cPrefixo+"MOTIVRG" ) )	:= aMarcacoes[ nCount , AMARC_MOTIVRG	]						//29 - Motivo da desconsideracao/inclusao
			( cAlias )->( &( cPrefixo+"SEMANA"  ) )	:= aMarcacoes[ nCount , AMARC_SEQ		]						//16 - Semana/Sequencia do turno da Tabela Padrao
			( cAlias )->( &( cPrefixo+"EMPORG"  ) )	:= aMarcacoes[ nCount , AMARC_EMPORG	]						//31 - Empresa Origem da marcacao
			( cAlias )->( &( cPrefixo+"FILORG"  ) )	:= aMarcacoes[ nCount , AMARC_FILORG	]   					//32 - Filial Origem da marcacao
			( cAlias )->( &( cPrefixo+"MATORG"  ) )	:= aMarcacoes[ nCount , AMARC_MATORG	]   					//33 - Matricula Origem da marcacao
			( cAlias )->( &( cPrefixo+"DHORG"	) )	:= aMarcacoes[ nCount , AMARC_DHORG		]						//34 - Data/Hora Origem da marcacao
			( cAlias )->( &( cPrefixo+"IDORG"	) )	:= aMarcacoes[ nCount , AMARC_IDORG		]						//35 - Identificacao da Origem da marcacao
			( cAlias )->( &( cPrefixo+"DATAAPO" ) )	:= aMarcacoes[ nCount , AMARC_DATAAPO	]						//25 - Data de apontamento
			( cAlias )->( &( cPrefixo+"DATAALT" ) )	:= MsDate()														//Data de alteracao
			( cAlias )->( &( cPrefixo+"HORAALT" ) )	:= SUBSTR(Time(),1,2) + SUBSTR(Time(),4,2) + SUBSTR(Time(),7,2)	//Hora da alteracao
			( cAlias )->( &( cPrefixo+"USUARIO" ) )	:= If(Empty(cUserPon), " ", cUserPon)							//Usuario utilizador
		EndIf
		If lGeolocal //Geolocalizacao
			( cAlias )->( &( cPrefixo+"LATITU"  ) )	:= aMarcacoes[ nCount , AMARC_LATITU	] 	//36 - Latitude (marcacao geolocalizacao)
			( cAlias )->( &( cPrefixo+"LONGIT" ) )	:= aMarcacoes[ nCount , AMARC_LONGIT	] 	//Longitude (marcacao geolocalizacao)
		EndIf
		If lGeoFence .And. lIntegRR1
			( cAlias )->( &( cPrefixo+"GEOFEN"  ) )	:= aMarcacoes[ nCount , AMARC_GEOFENCE	] 	//38 - Dentro ou fora do perímetro
		EndIf
		
		If lCCT
			( cAlias )->( &( cPrefixo+"FILCCT"  ) )	:= aMarcacoes[ nCount , AMARC_FILCCT ] 	//39 - Filial da convenção coletiva
			( cAlias )->( &( cPrefixo+"CODCCT"  ) )	:= aMarcacoes[ nCount , AMARC_CODCCT ] 	//40 - Código da convenção coletiva
		EndIf
		
		If lFuso671
			( cAlias )->( &( cPrefixo+"FUSO"  ) )	:= aMarcacoes[ nCount , AMARC_FUSO	] 	//41 - Fuso horário da marcação
		EndIf
		
		If lCCTREP
			( cAlias )->( &( cPrefixo+"CCTREP"  ) )	:= aMarcacoes[ nCount , AMARC_CCTREP ] 	//42 - Fuso horário da marcação
		EndIf
		
		If lCpoUser
			For nCont := ELEMENTOS_AMARC + 1 To Len(aMarcacoes[nCount])
				( cAlias )->( &( aMarcacoes[nCount, nCont, 1] ) ) := aMarcacoes[nCount, nCont, 2]
			Next nCont
		EndIf
	Else
		IF Empty( cQryUpdate )
			cQryUpdate := "UPDATE "
			cQryUpdate += cTableName
			cQryUpdate += " SET "
		Else
			cQryUpdate += ", "
		EndIF
		cQryUpdate += cPrefixo +"ORDEM='"	+ aMarcacoes[ nCount , AMARC_ORDEM   	] + "'"
		cQryUpdate += ", "
		cQryUpdate += cPrefixo +"TURNO='"	+ aMarcacoes[ nCount , AMARC_TURNO		] + "'"
		cQryUpdate += ", "
		cQryUpdate += cPrefixo +"APONTA='"	+ aMarcacoes[ nCount , AMARC_APONTA  	] + "'"
		cQryUpdate += ", "
		cQryUpdate += cPrefixo +"TPMARCA='"	+ aMarcacoes[ nCount , AMARC_TIPOMARC	] + "'"
		cQryUpdate += ", "
		cQryUpdate += cPrefixo +"PAPONTA='"	+ aMarcacoes[ nCount , AMARC_PERAPONTA	] + "'"
		cQryUpdate += ", "
		cQryUpdate += cPrefixo +"FLAG='"	+ aMarcacoes[ nCount , AMARC_FLAG    	] + "'"
		If lPort1510
			cQryUpdate += ", "
			cQryUpdate += cPrefixo +"NUMREP='"	+ aMarcacoes[ nCount , AMARC_NUMREP		] + "'"
			cQryUpdate += ", "
			cQryUpdate += cPrefixo +"TPMCREP='"	+ aMarcacoes[ nCount , AMARC_TPMCREP	] + "'"
			cQryUpdate += ", "
			cQryUpdate += cPrefixo +"TIPOREG='"	+ aMarcacoes[ nCount , AMARC_TIPOREG	] + "'"
			cQryUpdate += ", "
			cQryUpdate += cPrefixo +"MOTIVRG='"	+ aMarcacoes[ nCount , AMARC_MOTIVRG	] + "'"
			cQryUpdate += ", "
			cQryUpdate += cPrefixo +"SEMANA='"	+ aMarcacoes[ nCount , AMARC_SEQ		] + "'"
			cQryUpdate += ", "
			cQryUpdate += cPrefixo +"EMPORG='"	+ aMarcacoes[ nCount , AMARC_EMPORG		] + "'"	  
			cQryUpdate += ", "
			cQryUpdate += cPrefixo +"FILORG='"	+ aMarcacoes[ nCount , AMARC_FILORG		] + "'"	  				
			cQryUpdate += ", "
			cQryUpdate += cPrefixo +"MATORG='"	+ aMarcacoes[ nCount , AMARC_MATORG		] + "'"
			cQryUpdate += ", "
			cQryUpdate += cPrefixo +"DHORG='"	+ aMarcacoes[ nCount , AMARC_DHORG		] + "'"	  
			cQryUpdate += ", "
			cQryUpdate += cPrefixo +"IDORG='"	+ aMarcacoes[ nCount , AMARC_IDORG		] + "'"	  								
			cQryUpdate += ", "
			cQryUpdate += cPrefixo +"DATAAPO='"	+ Dtos( aMarcacoes[ nCount , AMARC_DATAAPO ] ) + "'"
			cQryUpdate += ", "
			cQryUpdate += cPrefixo +"DATAALT='"	+ DtoS(MsDate()) + "'"
			cQryUpdate += ", "
			cQryUpdate += cPrefixo +"HORAALT='"	+ SUBSTR(Time(),1,2) + SUBSTR(Time(),4,2) + SUBSTR(Time(),7,2) + "'"
			If !lWorkflow			
				cQryUpdate += ", "
				cQryUpdate += cPrefixo +"USUARIO='"	+ If(Empty(cUserPon), " ", cUserPon) + "'"
			EndIf					
		EndIf
		If lGeolocal
			cQryUpdate += ", "
			cQryUpdate += cPrefixo +"LATITU='"	+ aMarcacoes[ nCount , AMARC_LATITU	] + "'"
			cQryUpdate += ", "	
			cQryUpdate += cPrefixo +"LONGIT='"	+ aMarcacoes[ nCount , AMARC_LONGIT	] + "'"	
		EndIf
		
		If lGeoFence .And. lIntegRR1 
			cQryUpdate += ", "
			cQryUpdate += cPrefixo +"GEOFEN='"	+ aMarcacoes[ nCount , AMARC_GEOFENCE	] + "'"
		EndIf
		
		If lCCT
			cQryUpdate += ", "
			cQryUpdate += cPrefixo +"FILCCT='"	+ aMarcacoes[ nCount , AMARC_FILCCT	] + "'"
			cQryUpdate += ", "
			cQryUpdate += cPrefixo +"CODCCT='"	+ aMarcacoes[ nCount , AMARC_CODCCT	] + "'"
		EndIf
		
		If lFuso671
			cQryUpdate += ", "
			cQryUpdate += cPrefixo +"FUSO='"	+ aMarcacoes[ nCount , AMARC_FUSO	] + "'"
		EndIf
		
		If lCCTREP
			cQryUpdate += ", "
			cQryUpdate += cPrefixo +"CCTREP='"	+ aMarcacoes[ nCount , AMARC_CCTREP	] + "'"
		EndIf
		
		If lCpoUser
			For nCont := ELEMENTOS_AMARC + 1 To Len(aMarcacoes[nCount])
				cQryUpdate += ", "
				cQryUpdate += aMarcacoes[nCount, nCont, 1] + " = '"	
				If ValType( aMarcacoes[nCount, nCont, 2] ) == "C"
					cQryUpdate += aMarcacoes[nCount, nCont, 2] + "'"
				ElseIf ValType( aMarcacoes[nCount, nCont, 2] ) == "D"
					cQryUpdate += dToS(aMarcacoes[nCount, nCont, 2]) + "'"
				Else
					cQryUpdate += cValToChar(aMarcacoes[nCount, nCont, 2]) + "'"
				EndIf
			Next nCont
		EndIf
	EndIF
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Destrava o Registro                 						   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	IF lAddNew
		( cAlias )->( MsUnlock() )
	Else
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Substitui os valores                						   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		IF !Empty( cQryUpdate )
			cQryUpdate += " WHERE " 
			cQryUpdate += cCpoRecno + "=" + Str( aMarcacoes[ nCount , AMARC_RECNO ] , 10 , 0 )
			cRetQry := TcSqlExec( cQryUpdate )
							 
			If cRetQry <> 0 
				If !lWorkflow 
					MsgStop("TCSQLError() " + TCSQLError())
				Else
					ConOut( "TCSQLError() " + TCSQLError() )	
				EndIf
			EndIf
			cQryUpdate := ""
		EndIF
	EndIF
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Grava o Recno no aMarcacoes         						   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	IF (;
			( lAddNew );
			.or.;
			Empty( aMarcacoes[ nCount , AMARC_RECNO ] );
		)
		aMarcacoes[ nCount , AMARC_RECNO ] := ( cAlias )->( Recno() )						//05 - Recno
	EndIF

	If nTipo == 1 .Or. nTipo == 3 // Leitura ou Ambos
		If (lPnmTabCalen .OR. lAutoGS) .AND. lValidGS .AND. SuperGetMv("MV_TECXRH",,.F.)
			//Integração com o GS
			TecCheckIn(/*cCracha*/,;
						cFil,;
						aMarcacoes[nCount,AMARC_DATA],;
						aMarcacoes[nCount,AMARC_HORA],;
						aMarcacoes[nCount,AMARC_TURNO],;
						cMat,;
						aMarcacoes[nCount,AMARC_TIPOMARC],;
						aMarcacoes[nCount,AMARC_SEQ],;
						aMarcacoes[nCount,AMARC_DATAAPO];
						)
		EndIf
	EndIf
	
	If cAlias == "SP8"

		// --------------------------------------------------
		//  Verifica se há integração por EAI habilitada
		If lIntegDef
			Altera := .F.
			Inclui := .T.
			SetRotInteg( "PONM010" )
			FwIntegdef("PONM010")
		EndIf
		
	EndIf
	
	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³lAddNew eh Setada como .F.          						   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	lAddNew := .F.
Next nCount
( cAlias )->( dbSetOrder( aArea[ 02 ] ) )

cFilAnt := cSvFilAnt

Return( NIL )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³GetPerAponta³ Autor ³ Marinaldo de Jesus  ³ Data ³27/09/2001³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³ListBox com a Selecao dos Periodos de Apontamento           ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³GetPerAponta( nNumPerAnt , cFil , cMat , lReturn , uMvPar )	³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico                                                    ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³Se Validacao .T. c.c. Array com os Periodos de Apontamento  ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³nNumPerAnt	- Numero de Periodos a Serem Listados			³
³          ³cFil		- Filial do Funcionario							³
³          ³cMat		- Matricula do Funcionario						³
³          ³lReturn		- Retorno Logico Quando Validacao				³
³          ³uMvPar	    - Opcional.Variavel Receptora do Valor da Opcao ³  
³          ³              Escolhida.                                    ³  
³          ³aPerSPO     - Periodos do SPO                       		³  
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function GetPerAponta( nNumPerAnt , cFil , cMat , lReturn , lSelectOne , uMvPar , aPerSPO )

Local aAreaSRA		:= {}
Local aPeriodos		:= {}
Local aShowPer		:= {}
Local bAscPer		:= { |x| x[1] == dPerIni .and. x[2] == dPerFim }
Local cMvParDef		:= ""
Local dAdmissa		:= Ctod("//")
Local dPerIni		:= Ctod("//")
Local dPerFim		:= Ctod("//")
Local dDtAux		:= CtoD("//")
Local lItera		:= .T.
Local lFunc			:= .T.
Local lMvPar		:= !( uMvPar == NIL )
Local lPerCompleto	:= .F.
Local nPer			:= 0
Local nPerSPO		:= 0
Local nItera		:= 0

DEFAULT nNumPerAnt	:= 12
DEFAULT lReturn		:= .T.
DEFAULT lSelectOne	:= .T.
DEFAULT aPerSPO		:= {}

uMvPar	:= IF( lReturn , IF( !lMvPar , &( Alltrim( ReadVar() ) ) , uMvPar ) , "" )

IF ( lReturn )
	CursorWait()
EndIF	

IF ( lFunc := ( cFil != NIL .and. cMat != NIL ) )
	aAreaSRA := SRA->( GetArea() )
	IF !( SRA->( RA_FILIAL+RA_MAT == cFil+cMat ) )
		SRA->( dbSetOrder( RetOrdem("SRA") ) )
		SRA->( dbSeek( cFil + cMat ) )
	EndIF
	dAdmissa := SRA->RA_ADMISSA
	SRA->( dbSetOrder( aAreaSRA[ 02 ] ) )
EndIF		

IF ( lMvPar )
	aAdd( aPeriodos, { Stod( SubStr( uMvPar , 1 , 8 ) ) , Stod( SubStr( uMvPar , 9 , 8 ) ) } )
EndIF

IF !GetPonMesDat( @dPerIni , @dPerFim , cFil )
	If !(PerAponta( @dPerIni , @dPerFim , NIL , NIL , cFil ,  .F. , @lPerCompleto ))
		lItera := .F. //encerra processamento caso tenha retornado erro na carga dos parametros
	EndIf
Else
	IF ( aScan( aPeriodos , bAscPer ) == 0 )
		aAdd( aPeriodos, { dPerIni , dPerFim } )
	EndIF
EndIF

IF ( ( nPerSPO := Len( aPerSPO ) ) > 0 )
	aSort( aPerSPO , NIL , NIL , { |x,y| Dtos(x[1])+Dtos(x[2]) > Dtos(y[1])+Dtos(y[2]) } )
EndIF
	
While ( lItera )

	++nItera
    
	IF ( lItera := ( --nNumPerAnt > 0 ) )
		IF ( nPerSPO == 0 )
		 	If lFunc
		 		--dPerIni
		 	Endif
			IF ( !( lPerCompleto ) .and. ( nItera == 1 ) )
				PerAponta( dPerIni , dPerFim , dPerIni , NIL , cFil , .F. , @lPerCompleto )
			EndIF
			IF ( lPerCompleto )
				PonDecDate( @dPerIni , @dPerFim )
			Else
				dDtAux := MonthSub(dPerIni,1) //decrementa, em 1 mes, a dataBase a ser passada para montagem do periodo de apontamento
				PerAponta( @dPerIni , @dPerFim , dDtAux , NIL , cFil , .T. , NIL )
			EndIF
		Else
			IF !( lItera := ( ++nPer <= nPerSPO ) )
				Exit
			EndIF	
			dPerIni := aPerSPO[ nPer , 01 ]
			dPerFim := aPerSPO[ nPer , 02 ]
		EndIF
		IF ( aScan( aPeriodos , bAscPer ) == 0 )
			aAdd( aPeriodos, { dPerIni , dPerFim } )
		EndIF
		IF !( lItera := !( IF( lFunc , dPerIni < dAdmissa , .F. ) ) )
			Exit
		EndIF
	EndIF

End While

IF !Empty( aPeriodos )
	aSort( aPeriodos , NIL , NIL , { |x,y| Dtos(x[1])+Dtos(x[2]) < Dtos(y[1])+Dtos(y[2]) } )
	aEval( aPeriodos , { |x| aAdd( aShowPer , Dtoc(x[1])+ STR0067 + Dtoc(x[2]) ) , ( cMvParDef += Dtos(x[1])+Dtos(x[2]) ) } )
EndIF

IF ( lReturn )
	CursorArrow()
	IF f_Opcoes( @uMvPar , STR0100 , aShowPer , cMvParDef , 12 , 49 , lSelectOne , 16 , ( 16 * nNumPerAnt ) ) //Periodos de Apontamento
		IF ( !Empty( uMvPar := StrTran( uMvPar , "*" , "" ) ) .and. !( lMvPar ) )
			&( ReadVar() ) := uMvPar
		EndIF
	EndIF	
EndIF

Return( IF( lReturn , lReturn , aPeriodos ) )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³RetSerIni   ³Autor ³ Marinaldo de Jesus   ³ Data ³26/06/2003³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Retorna Numero Serial p/ o Inicio do Periodo de Apontamento ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>                   				³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Ponto Eletronico                                            ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³nSerIni                            							³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function RetSerIni(	aTabCalend	,;	//01 -> Copia do Calendario de Marcacoes
					aTabPadrao	,;	//02 -> Tabela de Horario Padrao
					dPerIni		,;	//03 -> Inicio do Periodo de Apontamento
					dPerFim		,; 	//04 -> Final do Periodo de Apontamento
					cTno		,;	//05 -> Turno de Trabalho
					cSeq		,;	//06 -> Sequencia de Turno
					cFil     	,;	//07 -> Filial do Funcionario
					cMat   		,;	//08 -> Matricula do Funcionario
					cCc   		,;	//09 -> Centro de Custo do Funcionario
					lMarcOrder	,;	//10 -> Marcacoes Sendo carregadas pela Ordem
					lCalendFunc  ;	//11 -> Se o Calendario Esta Sendo Montado por funcionario
				   )

Local nHoursDay	:= 0
Local nHoursTab := 0

Local aSvTabsCal
Local cPriOrdem
Local cUltOrdem
Local lHorTabPad	:=SuperGetMv("MV_HRTBBCO",NIL,.F.)
Local nSerIni
Local nDays
Local nPosUltOrdem
Local nLenCalend

DEFAULT aTabCalend		:= {}
DEFAULT aTabPadrao		:= {}
DEFAULT dPerIni			:= Ctod("//")
DEFAULT dPerFim			:= Ctod("//")
DEFAULT lCalendFunc		:= .T.

IF ( lCalendFunc )
	DEFAULT cFil		:= SRA->RA_FILIAL
	DEFAULT cMat		:= SRA->RA_MAT
	DEFAULT cTno		:= SRA->RA_TNOTRAB
	DEFAULT cSeq		:= SRA->RA_SEQTURN
	DEFAULT cCc			:= SRA->RA_CC
EndIF	
DEFAULT lMarcOrder	:= .F.

Begin Sequence

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Verifica se o Calendario foi passado como parametro		  ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	IF Empty( aTabCalend )
		IF ( Empty( dPerIni ) .or. Empty( dPerFim ) )
			IF !( PerAponta( @dPerIni , @dPerFim , NIL , NIL , cFil ) )
				Break
			EndIF
		EndIF
        /*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Salva o Conteudo do Calendario por Turno        			  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		aSvTabsCal := GetTabCal()
		IF !(;
				CriaCalend(	dPerIni 	,;	//01 -> Data Inicial do Calendario
						   	dPerFim		,;	//02 -> Data Final do Calendario
					   		cTno		,;	//03 -> Turno de Trabalho
					   		cSeq		,;	//04 -> Sequencia de Turno
					   		@aTabPadrao	,;	//05 -> Tabela de Horario Padrao
					   		@aTabCalend	,;	//06 -> Calendario de Marcacoes
					   		cFil     	,;	//07 -> Filial do Funcionario
					   		cMat   		,;	//08 -> Matricula do Funcionario
					   		cCc   		,;	//09 -> Centro de Custo do Funcionario
							NIL			,;	//10 -> Array com as Trocas de Turno
							NIL			,;	//11 -> Array com Todas as Excecoes do Periodo
							NIL			,;	//12 -> Se executa Query para a Montagem da Tabela Padrao
							.F.			,;	//13 -> Se executa a funcao se sincronismo do calendario
							NIL			 ;	//14 -> Se Forca a Criacao de Novo Calendario
					  	  );
			)					  	  
			Break
		EndIF					  	  
	ElseIF ( Empty( dPerIni ) .or. Empty( dPerFim ) )
		dPerIni			:= aTabCalend[ 01 , CALEND_POS_DATA ]
		cUltOrdem		:= aTabCalend[ Len( aTabCalend ) , CALEND_POS_ORDEM ]
		nPosUltOrdem    := aScan( aTabCalend , { |x| ( x[ CALEND_POS_ORDEM ] == cUltOrdem  ) .and. ( x[CALEND_POS_TIPO_MARC] == "1E" ) } )
		IF ( nPosUltOrdem > 0 )
			dPerFim := aTabCalend[ nPosUltOrdem , CALEND_POS_DATA ]
		Else
			IF !( PerAponta( @dPerIni , @dPerFim , NIL , NIL , cFil ) )
				Break
			EndIF
		EndIF
	EndIF
	
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Define o Numero Serial correspondente ao primeiro dia do Peri³
	³odo de Apontamento											  ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	nSerIni := __fDHtoNS(aTabCalend[ 01 , CALEND_POS_LIM_MARCACAO , 01 ], aTabCalend[ 01, CALEND_POS_LIM_MARCACAO , 02 ] )
	
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Quando Primeiro Dia da Tabela Tiver o Horario Zerado Decremen³
	³ta um Dia													  ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	cPriOrdem := aTabCalend[ 01 , CALEND_POS_ORDEM ]
	aEval( aTabCalend ,{ |x|;
					 	 	 IF( x[CALEND_POS_ORDEM] == cPriOrdem ,;
					 	 	 		 nHoursDay := SomaHoras( nHoursDay , x[CALEND_POS_HRS_TRABA] ),;
					 	 	 		 nHoursTab := SomaHoras( nHoursTab , x[CALEND_POS_HRS_TRABA] );
					 	 	 	);
					  };
		  )
	IF ( Empty( nHoursDay ) .and. !Empty( nHoursTab := SomaHoras( nHoursDay , nHoursTab ) ) )
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Monta Novo Periodo de Apontamento                   	  	  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		nDays	:= ( ( dPerFim - dPerIni ) + 1 )
		dPerFim	:= ( aTabCalend[ 01 , CALEND_POS_DATA ] - 1 )
		dPerIni := ( dPerFim - nDays )
        /*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Salva o Conteudo do Calendario por Turno        			  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		IF Empty( aSvTabsCal )
			aSvTabsCal := GetTabCal()
		EndIF
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Cria Calendario com o Ultimo dia do Periodo Anterior         ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		IF CriaCalend(	dPerFim		,;	//01 -> Data Inicial do Calendario
		   		   		dPerFim		,;	//02 -> Data Final do Calendario
						cTno		,;	//03 -> Turno de Trabalho
						cSeq		,;	//04 -> Sequencia de Turno
						@aTabPadrao	,;	//05 -> Tabela de Horario Padrao
						@aTabCalend	,;	//06 -> Calendario de Marcacoes
						cFil     	,;	//07 -> Filial do Funcionario
						cMat   		,;	//08 -> Matricula do Funcionario
						cCc   		,;	//09 -> Centro de Custo do Funcionario
						NIL			,;	//10 -> Array com as Trocas de Turno
						NIL			,;	//11 -> Array com Todas as Excecoes do Periodo
						NIL			,;	//12 -> Se executa Query para a Montagem da Tabela Padrao
						.F.			,;	//13 -> Se executa a funcao se sincronismo do calendario
						NIL			 ;	//14 -> Se Forca a Criacao de Novo Calendario
					  )
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³Procura o Proximo Dia com Horario na Tabela         	  	  ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			IF lHorTabPad
				IF Type("lJorCont") <> "U" .And. lJorCont
				 	While ( nHoursDay := 0 , aEval( aTabCalend , { |x| nHoursDay := SomaHoras( nHoursDay , x[CALEND_POS_HRS_TRABA] ) } ) , nHoursDay == 0 )
				   		IF ( ( --dPerFim ) < dPerIni )
					   		Exit
					 	EndIF   
						aTabCalend := {}
						IF !CriaCalend(	dPerFim		,;	//01 -> Data Inicial do Calendario
				   		    			dPerFim		,;	//02 -> Data Final do Calendario
							  			cTno		,;	//03 -> Turno de Trabalho
										cSeq		,;	//04 -> Sequencia de Turno
										@aTabPadrao	,;	//05 -> Tabela de Horario Padrao
										@aTabCalend	,;	//06 -> Calendario de Marcacoes
										cFil     	,;	//07 -> Filial do Funcionario
										cMat   		,;	//08 -> Matricula do Funcionario
										cCc   		,;	//09 -> Centro de Custo do Funcionario
										NIL			,;	//10 -> Array com as Trocas de Turno
										NIL			,;	//11 -> Array com Todas as Excecoes do Periodo
										NIL			,;	//12 -> Se executa Query para a Montagem da Tabela Padrao
										.F.			,;	//13 -> Se executa a funcao se sincronismo do calendario
										NIL			 ;	//14 -> Se Forca a Criacao de Novo Calendario
							  		)
						
						EndIF					  		
					End While
				  	IF Empty( nHoursDay )   
					 
					 /*/ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						³Se nao Achou Horas na Tabela Decrementa o Primeiro Serial	  ³
						ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
				  		--nSerIni 
			   		Else
					 
						
				     /*/ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						³Caso Contrario Considera como Primeira Marcacao a ultima  Mar³
						³cacao do Dia Anterior(Respeitando o HorMais) somado de um  mi³
						³nuto.  													  ³
						ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
					  	nLenCalend	:= Len( aTabCalend )
						nSerIni 	:= __fDHtoNS( aTabCalend[ nLenCalend , CALEND_POS_LIM_MARCACAO , 01 ] , SomaHoras( aTabCalend[ nLenCalend , CALEND_POS_LIM_MARCACAO , 02 ] , 0.01 ) )
			   		EndIF
			    Else
			   		nLenCalend	:= Len( aTabCalend )
					nSerIni 	:= __fDHtoNS( aTabCalend[ nLenCalend , CALEND_POS_LIM_MARCACAO , 01 ] , SomaHoras( aTabCalend[ nLenCalend , CALEND_POS_LIM_MARCACAO , 02 ] , 0.01 ) )
			    Endif  
	   		Else
		     /*/ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³Procura o Proximo Dia com Horario na Tabela         	  	  ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
				While ( nHoursDay := 0 , aEval( aTabCalend , { |x| nHoursDay := SomaHoras( nHoursDay , x[CALEND_POS_HRS_TRABA] ) } ) , nHoursDay == 0 )
					IF ( ( --dPerFim ) < dPerIni )
						Exit
					EndIF
					aTabCalend := {}
					IF !CriaCalend(	dPerFim		,;	//01 -> Data Inicial do Calendario
			   		    			dPerFim		,;	//02 -> Data Final do Calendario
						  			cTno		,;	//03 -> Turno de Trabalho
									cSeq		,;	//04 -> Sequencia de Turno
									@aTabPadrao	,;	//05 -> Tabela de Horario Padrao
									@aTabCalend	,;	//06 -> Calendario de Marcacoes
									cFil     	,;	//07 -> Filial do Funcionario
									cMat   		,;	//08 -> Matricula do Funcionario
									cCc   		,;	//09 -> Centro de Custo do Funcionario
									NIL			,;	//10 -> Array com as Trocas de Turno
									NIL			,;	//11 -> Array com Todas as Excecoes do Periodo
									NIL			,;	//12 -> Se executa Query para a Montagem da Tabela Padrao
									.F.			,;	//13 -> Se executa a funcao se sincronismo do calendario
									NIL			 ;	//14 -> Se Forca a Criacao de Novo Calendario
						  		)
						Exit
					EndIF					  		
				End While
				IF Empty( nHoursDay )
					/*/
					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					³Se nao Achou Horas na Tabela Decrementa o Primeiro Serial	  ³
					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
					--nSerIni
				Else
					/*/
					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					³Caso Contrario Considera como Primeira Marcacao a ultima  Mar³
					³cacao do Dia Anterior(Respeitando o HorMais) somado de um  mi³
					³nuto.  													  ³
					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
					nLenCalend	:= Len( aTabCalend )
					nSerIni 	:= __fDHtoNS( aTabCalend[ nLenCalend , CALEND_POS_LIM_MARCACAO , 01 ] , SomaHoras( aTabCalend[ nLenCalend , CALEND_POS_LIM_MARCACAO , 02 ] , 0.01 ) )
				EndIF
			Endif
		Else
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³Se nao Achou Horas na Tabela Decrementa o Primeiro Serial	  ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			--nSerIni
		EndIF	
	ElseIF Empty( nHoursTab )
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Neste Caso a Tabela nao Tem Horario e o Serial deve ser Decre³
		³mentado													  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		--nSerIni
	EndIF

End Sequence

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Restaura o Conteudo do Calendario por Turno        		  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
IF !Empty( aSvTabsCal )
	SetTabCal( aSvTabsCal )
EndIF

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Verifica se Deve Decrementar o Serial Obtido				  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Return( IF( lMarcOrder ,  --nSerIni , nSerIni ) )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³RetSerFim   ³Autor ³ Marinaldo de Jesus   ³ Data ³11/10/2001³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Retorna Numero Serial para o Fim do Periodo de Apontamento  ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>                   				³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Ponto Eletronico                                            ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³nSerFim                            							³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function RetSerFim(	aTabCalend	,;	//01 -> Copia do Calendario de Marcacoes
					aTabPadrao	,;	//02 -> Tabela de Horario Padrao
					dPerIni		,;	//03 -> Inicio do Periodo de Apontamento
					dPerFim		,; 	//04 -> Final do Periodo de Apontamento
					cTno		,;	//05 -> Turno de Trabalho
					cSeq		,;	//06 -> Sequencia de Turno
					cFil     	,;	//07 -> Filial do Funcionario
					cMat   		,;	//08 -> Matricula do Funcionario
					cCc   		,;	//09 -> Centro de Custo do Funcionario
					lMarcOrder	,;	//10 -> Marcacoes Sendo carregadas pela Ordem
					lCalendFunc  ;	//11 -> Se o Calendario Esta Sendo Montado por funcionario
				   )

Local nHoursDay	:= 0
Local nHoursTab := 0

Local aSvTabsCal
Local cUltOrdem   
Local lHorTabPad	:=SuperGetMv("MV_HRTBBCO",NIL,.F.)
Local nSerFim
Local nDays
Local nPosUltOrdem

DEFAULT aTabCalend	:= {}
DEFAULT aTabPadrao	:= {}
DEFAULT dPerIni		:= Ctod("//")
DEFAULT dPerFim		:= Ctod("//")
DEFAULT cFil		:= SRA->RA_FILIAL
DEFAULT lCalendFunc	:= .T.
IF ( lCalendFunc )
	DEFAULT cMat		:= SRA->RA_MAT
	DEFAULT cTno		:= SRA->RA_TNOTRAB
	DEFAULT cSeq		:= SRA->RA_SEQTURN
	DEFAULT cCc			:= SRA->RA_CC
EndIF
DEFAULT lMarcOrder	:= .F.

Begin Sequence

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Verifica se o Calendario foi passado como parametro		  ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	IF Empty( aTabCalend )
		IF ( Empty( dPerIni ) .or. Empty( dPerFim ) )
			IF !( PerAponta( @dPerIni , @dPerFim , NIL , NIL , cFil ) )
				Break
			EndIF
		EndIF
        /*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Salva o Conteudo do Calendario por Turno        			  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		aSvTabsCal := GetTabCal()
		IF !(;
				CriaCalend(	dPerIni 	,;	//01 -> Data Inicial do Calendario
						   	dPerFim		,;	//02 -> Data Final do Calendario
				   			cTno		,;	//03 -> Turno de Trabalho
					   		cSeq		,;	//04 -> Sequencia de Turno
					   		@aTabPadrao	,;	//05 -> Tabela de Horario Padrao
					   		@aTabCalend	,;	//06 -> Calendario de Marcacoes
					   		cFil     	,;	//07 -> Filial do Funcionario
					   		cMat   		,;	//08 -> Matricula do Funcionario
				   			cCc   		,;	//09 -> Centro de Custo do Funcionario
							NIL			,;	//10 -> Array com as Trocas de Turno
							NIL			,;	//11 -> Array com Todas as Excecoes do Periodo
							NIL			,;	//12 -> Se executa Query para a Montagem da Tabela Padrao
							.F.			,;	//13 -> Se executa a funcao se sincronismo do calendario
							NIL			 ;	//14 -> Se Forca a Criacao de Novo Calendario
					  	  );
			)
			Break					  	  
		EndIF
	ElseIF ( Empty( dPerIni ) .or. Empty( dPerFim ) )
		dPerIni			:= aTabCalend[ 01 , CALEND_POS_DATA ]
		cUltOrdem		:= aTabCalend[ Len( aTabCalend ) , CALEND_POS_ORDEM ]
		nPosUltOrdem    := aScan( aTabCalend , { |x| ( x[ CALEND_POS_ORDEM ] == cUltOrdem  ) .and. ( x[CALEND_POS_TIPO_MARC] == "1E" ) } )
		IF ( nPosUltOrdem > 0 )
			dPerFim := aTabCalend[ nPosUltOrdem , CALEND_POS_DATA ]
		Else
			IF !( PerAponta( @dPerIni , @dPerFim , NIL , NIL , cFil ) )
				Break
			EndIF
		EndIF
	EndIF
	
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Define o Numero Serial correspondente ao ultimo dia do  Perio³
	³do de Apontamento											  ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	nSerFim := __fDHtoNS(aTabCalend[Len(aTabCalend),CALEND_POS_LIM_MARCACAO,1] , aTabCalend[Len(aTabCalend),CALEND_POS_LIM_MARCACAO,2] )
	
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Quando ultimo Dia da Tabela Tiver o Horario Zerado Soma  Mais³
	³um Dia														  ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	cUltOrdem := aTabCalend[Len(aTabCalend),CALEND_POS_ORDEM]
	aEval( aTabCalend ,{ |x|;
					 	 	 IF( x[CALEND_POS_ORDEM] == cUltOrdem ,;
					 	 	 		 nHoursDay := SomaHoras( nHoursDay , x[CALEND_POS_HRS_TRABA] ),;
					 	 	 		 nHoursTab := SomaHoras( nHoursTab , x[CALEND_POS_HRS_TRABA] );
					 	 	 	);
					  };
		  )	
	
	
  	IF ( Empty( nHoursDay ) .and. !Empty( nHoursTab := SomaHoras( nHoursDay , nHoursTab ) ) )
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Monta Novo Periodo de Apontamento                   	  	  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		nDays	:= ( ( dPerFim - dPerIni ) + 1 )
		dPerIni := ( aTabCalend[ Len(aTabCalend) , CALEND_POS_DATA ]  + 1 )
		dPerFim := ( dPerIni + nDays )
        /*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Salva o Conteudo do Calendario por Turno        			  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		IF Empty( aSvTabsCal )
			aSvTabsCal := GetTabCal()
		EndIF	
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Cria Calendario com o Primeiro dia do Proximo Periodo de Apon³
		³tamento													  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		IF CriaCalend(	dPerIni		,;	//01 -> Data Inicial do Calendario
		   		   		dPerIni		,;	//02 -> Data Final do Calendario
						cTno		,;	//03 -> Turno de Trabalho
						cSeq		,;	//04 -> Sequencia de Turno
						@aTabPadrao	,;	//05 -> Tabela de Horario Padrao
						@aTabCalend	,;	//06 -> Calendario de Marcacoes
						cFil     	,;	//07 -> Filial do Funcionario
						cMat   		,;	//08 -> Matricula do Funcionario
						cCc   		,;	//09 -> Centro de Custo do Funcionario
						NIL			,;	//10 -> Array com as Trocas de Turno
						NIL			,;	//11 -> Array com Todas as Excecoes do Periodo
						NIL			,;	//12 -> Se executa Query para a Montagem da Tabela Padrao
						.F.			,;	//13 -> Se executa a funcao se sincronismo do calendario
						NIL			 ;	//14 -> Se Forca a Criacao de Novo Calendario
					  )
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³Procura o Proximo Dia com Horario na Tabela         	  	  ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		IF lHorTabPad
				IF Type("lJorCont") <> "U" .And. lJorCont
				 	While ( nHoursDay := 0 , aEval( aTabCalend , { |x| nHoursDay := SomaHoras( nHoursDay , x[CALEND_POS_HRS_TRABA] ) } ) , nHoursDay == 0 )
				   		IF ( ( ++dPerIni ) > dPerFim )
					 		Exit
					 	EndIF
						aTabCalend := {}
						IF !CriaCalend(	dPerIni		,;	//01 -> Data Inicial do Calendario
				   		    			dPerIni		,;	//02 -> Data Final do Calendario
							  			cTno		,;	//03 -> Turno de Trabalho
										cSeq		,;	//04 -> Sequencia de Turno
										@aTabPadrao	,;	//05 -> Tabela de Horario Padrao
										@aTabCalend	,;	//06 -> Calendario de Marcacoes
										cFil     	,;	//07 -> Filial do Funcionario
										cMat   		,;	//08 -> Matricula do Funcionario
										cCc   		,;	//09 -> Centro de Custo do Funcionario
										NIL			,;	//10 -> Array com as Trocas de Turno
										NIL			,;	//11 -> Array com Todas as Excecoes do Periodo
										NIL			,;	//12 -> Se executa Query para a Montagem da Tabela Padrao
										.F.			,;	//13 -> Se executa a funcao se sincronismo do calendario
										NIL			 ;	//14 -> Se Forca a Criacao de Novo Calendario
							  		)
							Exit
						EndIF					  		
				 	End While
				  	IF Empty( nHoursDay )
					
				  /*/	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						³Se nao Achou Horas na Tabela Incremente o Ultimo Serial	  ³
						ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
					 	++nSerFim
					Else
					/*/
						ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						³Caso Contrario Considera como Ultima Marcacao a Primeira  Mar³
						³cacao do Proximo Dia (Respeitando o HorMenos) subtraido de um³
						³minuto.													  ³
						ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
					nSerFim := __fDHtoNS( aTabCalend[ 01 , CALEND_POS_LIM_MARCACAO , 01 ] , SubHoras( aTabCalend[ 01 , CALEND_POS_LIM_MARCACAO , 02 ] , 0.01 ) )
					EndIF
			    Else
			   		 /*/ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						³Caso Contrario Considera como Ultima Marcacao a Primeira  Mar³
						³cacao do Proximo Dia (Respeitando o HorMenos) subtraido de um³
						³minuto.													  ³
						ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
					nSerFim := __fDHtoNS( aTabCalend[ 01 , CALEND_POS_LIM_MARCACAO , 01 ] , SubHoras( aTabCalend[ 01 , CALEND_POS_LIM_MARCACAO , 02 ] , 0.01 ) )
			    Endif   
			Else    	
				While ( nHoursDay := 0 , aEval( aTabCalend , { |x| nHoursDay := SomaHoras( nHoursDay , x[CALEND_POS_HRS_TRABA] ) } ) , nHoursDay == 0 )
			   		IF ( ( ++dPerIni ) > dPerFim )
				 		Exit
				 	EndIF
					aTabCalend := {}
					IF !CriaCalend(	dPerIni		,;	//01 -> Data Inicial do Calendario
			   		    			dPerIni		,;	//02 -> Data Final do Calendario
						  			cTno		,;	//03 -> Turno de Trabalho
									cSeq		,;	//04 -> Sequencia de Turno
									@aTabPadrao	,;	//05 -> Tabela de Horario Padrao
									@aTabCalend	,;	//06 -> Calendario de Marcacoes
									cFil     	,;	//07 -> Filial do Funcionario
									cMat   		,;	//08 -> Matricula do Funcionario
									cCc   		,;	//09 -> Centro de Custo do Funcionario
									NIL			,;	//10 -> Array com as Trocas de Turno
									NIL			,;	//11 -> Array com Todas as Excecoes do Periodo
									NIL			,;	//12 -> Se executa Query para a Montagem da Tabela Padrao
									.F.			,;	//13 -> Se executa a funcao se sincronismo do calendario
									NIL			 ;	//14 -> Se Forca a Criacao de Novo Calendario
						  		)
						Exit
					EndIF					  		
			 	End While
				IF Empty( nHoursDay )
				
			  /*/	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					³Se nao Achou Horas na Tabela Incremente o Ultimo Serial	  ³
					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
				 	++nSerFim
				Else
				/*/
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³Caso Contrario Considera como Ultima Marcacao a Primeira  Mar³
				³cacao do Proximo Dia (Respeitando o HorMenos) subtraido de um³
				³minuto.													  ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
				nSerFim := __fDHtoNS( aTabCalend[ 01 , CALEND_POS_LIM_MARCACAO , 01 ] , SubHoras( aTabCalend[ 01 , CALEND_POS_LIM_MARCACAO , 02 ] , 0.01 ) )
				EndIF
			Endif
		Else
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³Se nao Achou Horas na Tabela Incremente o Ultimo Serial	  ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			++nSerFim
		EndIF	
	ElseIF Empty( nHoursTab )
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Neste Caso a Tabela nao Tem Horario e o Serial deve ser incre³
		³mentado													  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		++nSerFim
	EndIF

End Sequence

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Restaura o Conteudo do Calendario por Turno        		  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
IF !Empty( aSvTabsCal )
	SetTabCal( aSvTabsCal )
EndIF
	
/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Verifica se Deve Incrementar o Serial Obtido				  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Return( IF( lMarcOrder , ++nSerFim , nSerFim ) )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³PutMarcAuto  ³Autor³ Marinaldo de Jesus   ³ Data ³13/08/2001³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Gerar Marcacoes Automaticas no Array aMarcacoes             ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<vide parametros formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico                                                    ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³lAuto														³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<vide parametros formais>									³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function PutMarcAuto(	aTabCalend	,;
						aMarcacoes	,;
						dPerIni		,;
						dPerFim		,;
						cFil		,;
						lChkTables	,;
						lSobrepoe	,;
						aMarcNoGer   ;
					)
                    	
Local aCloneMarc	:= aClone( aMarcacoes )
Local aMAuto		:= {}
Local cCusto		:= SRA->RA_CC 
Local lSpaIsMemVar	:= .F.
Local lSr6IsMemVar	:= .F.

Local aTDia
Local aMDia
Local aTab_Marc
Local aFields  
Local aMarcGer  
Local aMarcDia		:= {}
Local aSvAlias		:= {}
Local aIntervalo	:= {{"1S","2E"},{"2S","3E"},{"3S","4E"}}

Local cOrdem
Local cMarcAut  
Local cNewMarcAut
Local cMarc 
Local cUltmarc
Local cTipMarcDia
Local cMarcsObriga
Local cMarcsEfe
Local cFilRegra
Local cFilTurno
Local cTpMarc
Local cPerAponta
Local cAutoSai
Local cUltOrdem
Local cMotivoAut
Local cMotivoInc
Local cIntPreDet	:= " "
Local cIntTotDet    := " "
Local cRegraAnt     := ""
Local cSpaceNumRep
Local cSpaceMotivo
Local cSpaceTpMar
Local cCodMot
Local cRet
Local cInMovel 		:= ""
Local cCompMar 		:= ""  

Local dDtMarc  
Local dDtApo

Local lAuto
Local lInterv
Local lAleat
Local lAutomSM
Local lTrabFer
Local lMarcsObriga
Local lAutoSai
Local lCompletaMar
Local lIntPreDet    := .F.

Local nY
Local nFornY
Local nTab
Local nLenTab
Local nMarc
Local nLenMarc
Local nOrdem
Local nForOrdem
Local nField
Local nMarcsGer
Local nMarcsEfe
Local nLenMAuto
Local nMarcAut
Local nPosUltOrd
Local nInterv
Local nHrTrab
Local nAleato
Local nPos
Local nMinuto
Local nSvRecno
Local nTab_Marc
Local nPosRg		:= 0
Local nPosTr		:= 0
Local nIntPreDet    := 0
Local nMovPint 		:= 0
Local nI	 		:= 0
Local nPosSI 		:= 0
Local nLenInt		:= Len(aIntervalo)
Local nLenATabM		:= 0
Local lSumIntAleat := SuperGetMv("MV_SUMINTA",NIL,2) == 1
Local lMarcAut02	:= ExistBlock("MARCAUT2")
Local lMarcAut03	:= ExistBlock("MARCAUT3")
Local lPONM030		:= IsInCallStack("PONM030")

DEFAULT aTabCalend	:= {}
DEFAULT aMarcacoes	:= {}   
DEFAULT aMarcNoGer	:= {}
DEFAULT dPerIni		:= Ctod("//")
DEFAULT dPerFim		:= Ctod("//")
DEFAULT cFil		:= cFilAnt 
DEFAULT lChkTables	:= .T.
DEFAULT lSobrepoe	:= .F.
DEFAULT lPnMcAut01	:= ExistBlock( "PNMCAUT01" )

IF ( Empty( dPerIni ) .or. Empty( dPerFim ) )
	PerAponta( @dPerIni , @dPerFim , NIL , NIL , cFil )
EndIF

DEFAULT	_aSpaHeader		:= GdMontaHeader( @_nSpaHeader , NIL , NIL , "SPA" , NIL , .T. , .T. , .F. , .F. , .F. , .F. , .F. , .F. )
DEFAULT	_aSr6Header		:= GdMontaHeader( @_nSr6Header , NIL , NIL , "SR6" , NIL , .T. , .T. , .F. , .F. , .F. , .F. , .F. , .F. )

DEFAULT	_cSpaLastReg	:= "_cSpaLastReg"
DEFAULT _cSr6LastTno	:= "_cSr6LastTno"

DEFAULT _cSpceFuncao	:= Space( GetSx3Cache( "P8_FUNCAO " , "X3_TAMANHO" ) )
DEFAULT _cSpceGiro		:= Space( GetSx3Cache( "P8_GIRO   " , "X3_TAMANHO" ) )
DEFAULT _cSpceRelogi	:= Space( GetSx3Cache( "P8_RELOGIO" , "X3_TAMANHO" ) )

DEFAULT lPnmMotMarc		:= ExistBlock( "PNMMOTMARC" )

cUltOrdem	:= aTabCalend[ Len( aTabcalend ) , CALEND_POS_ORDEM ]
nForOrdem	:= Val( cUltOrdem )
nLenTab		:= Len( aTabCalend )
nLenMarc	:= Len( aMarcacoes )
cFilRegra	:= xFilial( "SPA" , cFil )
cFilTurno	:= xFilial( "SR6" , cFil )
cPerAponta	:= Dtos( aTabCalend[ 01 , CALEND_POS_DATA_APO ] )
nPosUltOrd	:= aScan( aTabCalend , { |x| x[ CALEND_POS_ORDEM ] == cUltOrdem .and. x[ CALEND_POS_TIPO_MARC ] == "1E" } )
cPerAponta	+= Dtos( aTabCalend[ nPosUltOrd , CALEND_POS_DATA_APO ] )

IF !( lChkTables )
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Carrega Informacoes da Regra de Apontamento          	      ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	cMarcAut := StrTran( GetMemVar( "PA_MARCAUT" ) , "*" , "" )
	cMarcAut += IF( SubStr(cMarcAut,-1) != "-" .and. !Empty(cMarcAut) , "-" , "" )
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Carrega Informacoes da Regra de Apontamento          	      ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	lAleat	  		:= ( GetMemVar( "PA_ALEATOR" ) == "S" )
	lAutomSM    	:= ( GetMemVar( "PA_AUTOMSM" ) == "S" )
	lCompletaMar	:= ( GetMemVar( "PA_COMPMAR" ) == "S" )
	nMinuto			:= Abs( GetMemVar( "PA_MINALEA" ) )
	
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Verifica se Devera Gerar Marcacoes em Dias Nao Trabalhados  ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	lAutoSai := !Empty( cAutoSai := AllTrim( StrTran( GetMemVar( "R6_AUTOSAI" ) , "*" , "" ) ) )
EndIF

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Garante que as marcacoes de um dia nao interfiram no proximo³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
aMarcNoGer	:= {}

If lPort1510
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Inicializa desc. do motivo para geracao automatica.         ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	cMotivoAut 	 := fInitMotivo(xFilial("RFD"),"1","4")
	cMotivoInc 	 := fInitMotivo(xFilial("RFD"),"1","1")
	If lPnmMotMarc
		IF ( ValType( cRet := ExecBlock( "PNMMOTMARC", .F. , .F. , ) ) == "C" )
		   cMotivoInc := cRet
		EndIf   
	EndIf	
	cCodMot		 := fInitCodMot(xFilial("RFD"),"1","2")
	cSpaceNumRep := Space( GetSx3Cache( "P8_NUMREP" , "X3_TAMANHO" ) )
	cSpaceMotivo := Space( GetSx3Cache( "P8_MOTIVRG" , "X3_TAMANHO" ) )
	cSpaceTpMar	 := Space( GetSx3Cache( "P8_TPMCREP" , "X3_TAMANHO" ) )
EndIf

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Processa para Todas as Ordens da Tabela de Horario		  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
For nOrdem := 1 To nForOrdem

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Inicializa as Variaveis									  ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	cOrdem			:= StrZero( nOrdem , __nTamP8Ordem )
    cTipMarcDia		:= ""
    cMarcsObriga	:= ""
    lMarcsObriga	:= .F.
	
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Procura a Ordem em aTabCalend.                              ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	IF ( nTab := aScan( aTabCalend, { |x| x[CALEND_POS_ORDEM] == cOrdem .and. x[CALEND_POS_TIPO_MARC] == "1E"  } ) ) > 0
	
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Verifica se Esta Dentro do Periodo de Apontamento           ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		IF ( aTabCalend[ nTab , CALEND_POS_DATA_APO ] < dPerIni .or. aTabCalend[ nTab , CALEND_POS_DATA_APO ] > dPerFim )
			Loop
		EndIF
		
		// Verifica se o funcinário é isento de marcação 
		If aTabCalend[nTab, CALEND_POS_ISENTMARC]
			LOOP
		EndIf
		
        //- Guarda a Data de Apontamento para uso no registro de marcacoes nao geradas para o dia
		dDtApo 		:=  aTabCalend[ nTab , CALEND_POS_DATA_APO ] 
		aMarcGer	:= {}

		IF ( nPosRg := aScan( aSpaInfo , { |x| x[1] == cFilRegra .and. x[2] == aTabCalend[ nTab , CALEND_POS_REGRA ] } ) ) == 0
			aSvAlias := GetArea()
				
			cCondSPA := "% PA_FILIAL = '"+cFilRegra+"' AND "
			cCondSPA += "PA_CODIGO = '"+aTabCalend[ nTab , CALEND_POS_REGRA ]+"' %"
							
			cQrySPA := GetNextAlias()

			BeginSql alias cQrySPA
				SELECT R_E_C_N_O_ RECNO
				FROM %table:SPA% SPA
				WHERE
				%exp:cCondSPA% AND SPA.%NotDel%
			EndSql
			
			If (cQrySpa)->(!Eof())
				SPA->( MsGoto( (cQrySpa)->RECNO ) )						
				(cQrySPA)->(dbCloseArea())
			Else
				(cQrySPA)->(dbCloseArea())
				Loop
			EndIf
			
			RestArea( aSvAlias )
        Else
			SPA->( MsGoto( aSpaInfo[nPosRg, 5] ) )        	
        EndIf
	
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Seta os Campos da Regra									  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		IF (;
				( lChkTables );
				.and.;
				(;
					( _cSpaLastReg <> ( cFilRegra + aTabCalend[ nTab , CALEND_POS_REGRA ] ) );
					.or.;
					!( lSpaIsMemVar );
				);
			)

			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Armazena Filial e Regra Anterior                     	      ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			_cSpaLastReg := ( cFilRegra + aTabCalend[ nTab , CALEND_POS_REGRA ] )

			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Obtem as informacoes em Cache do SPA                        ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			aFields	:= {}
			For nField := 1 To _nSpaHeader
				aAdd( aFields , _aSpaHeader[ nField , __AHEADER_FIELD__ ] )
			Next nField
			aFields := PosSPA( aTabCalend[ nTab , CALEND_POS_REGRA ] , cFilRegra , aFields , 1 , .F. )

			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Carrega e Alimenta as Variaveis de Memoria para o SPA	      ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			For nField := 1 To _nSpaHeader
				SetMemVar( _aSpaHeader[ nField , __AHEADER_FIELD__ ] , aFields[ nField ] , .T. )
			Next nField

			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Verifica se as Variaveis de Memoria foram Carregadas 	      ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			lSpaIsMemVar := IsMemVar( "PA_MARCAUT" )

			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Carrega Informacoes da Regra de Apontamento          	      ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			cMarcAut := StrTran( GetMemVar( "PA_MARCAUT" ) , "*" , "" )
			cMarcAut += IF( SubStr(cMarcAut,-1) != "-" .and. !Empty(cMarcAut) ,"-" , "" )

			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Carrega Informacoes da Regra de Apontamento          	      ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			lAleat	  		:= ( GetMemVar( "PA_ALEATOR" ) == "S" )
			lAutomSM    	:= ( GetMemVar( "PA_AUTOMSM" ) == "S" )
			lCompletaMar	:= ( GetMemVar( "PA_COMPMAR" ) == "S" )
			nMinuto			:= Abs( GetMemVar( "PA_MINALEA" ) )
			cInMovel		:= ( GetMemVar( "PA_INMOVEL" ) )
			nMovPint		:= ( GetMemVar( "PA_MOVPINT" ) )
			cCompMar		:= ( GetMemVar( "PA_COMPMAR" ) )			
			
			If lPort1510
				If SRA->RA_REGRA <> cRegraAnt
					cIntPreDet	:= AllTrim( StrTran( GetMemVar( "PA_ASSIN" ) , "I" , "" ) )
					While nIntPreDet < Len(cIntPreDet)  
						If !(SubStr(cIntPreDet,nIntPreDet,1) $ '*-') 
					   		cIntTotDet += SubStr(cIntPreDet,nIntPreDet,1) + "S" + Alltrim(Str(Val(SubStr(cIntPreDet,nIntPreDet,1)) + 1)) + "E|"    //-nS|nE
					   	Endif 
						nIntPreDet ++			
					EndDo
					cRegraAnt	:= SRA->RA_REGRA
				Endif
			EndIf
			
			DEFAULT lCompletaMar	:= .F.

		EndIF

		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Se nao Tiver Marcacoes a Gerar Vai Para o Proximo Dia	      ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		IF Empty( nMarcAut := Len( cMarcAut ) )
			Loop
		EndIF

		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Verifica se Funcionario Trabalha em Dias Feriado     	      ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		lTrabFer	:= (;
							aTabCalend[	nTab , CALEND_POS_FERIADO		];
							.and.;
							aTabCalend[	nTab , CALEND_POS_TRAB_FERIADO	];
						)	

		IF ( nPosTr := aScan( aSr6Info , { |x| x[1] == cFilTurno .and. x[2] == aTabCalend[ nTab , CALEND_POS_TURNO ] } ) ) == 0
			aSvAlias := GetArea()
			
			cCondSR6 := "% R6_FILIAL = '"+cFilTurno+"' AND "
			cCondSR6 += "R6_TURNO  = '"+aTabCalend[ nTab , CALEND_POS_TURNO ]+"' %"
							
			cQrySR6 := GetNextAlias()
			
			BeginSql alias cQrySR6
				SELECT R_E_C_N_O_ RECNO
				FROM %table:SR6% SR6
				WHERE
				%exp:cCondSR6% AND SR6.%NotDel%
			EndSql
			
			If (cQrySr6)->(!Eof())
				SR6->( MsGoto( (cQrySR6)->RECNO ) )						
				(cQrySR6)->(dbCloseArea())
			Else
				(cQrySR6)->(dbCloseArea())
				Loop
			EndIf		     	
                
			RestArea( aSvAlias )
        Else
	        SR6->( MsGoto( aSr6Info[nPosTr, 10] ) )
        EndIf

		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Seta os Campos do Turno									  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		IF (;
				( lChkTables );
				.and.;
				(;
					( _cSr6LastTno <> ( cFilTurno + aTabCalend[ nTab , CALEND_POS_TURNO ] ) );
					.or.;
					!( lSr6IsMemVar );
				);	
			)	

			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Armazena Filial e Turno Anterior                     	      ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			_cSr6LastTno := ( cFilTurno + aTabCalend[ nTab , CALEND_POS_TURNO ] )

			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Obtem as informacoes em Cache do SR6                        ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			aFields	:= {}
			For nField := 1 To _nSr6Header
				aAdd( aFields , _aSr6Header[ nField , __AHEADER_FIELD__ ] )
			Next nSpaHeader
			aFields := PosSR6( aTabCalend[ nTab , CALEND_POS_TURNO ] , cFilTurno , aFields , 1 , .F. )

			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Carrega e Alimenta as Variaveis de Memoria para o SR6	      ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			For nField := 1 To _nSr6Header
				SetMemVar( _aSr6Header[ nField , __AHEADER_FIELD__ ] , aFields[ nField ] , .T. )
			Next nField

			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Verifica se as Variaveis de Memoria foram Carregadas 	      ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			lSr6IsMemVar := IsMemVar( "R6_AUTOSAI" )

			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Verifica se Devera Gerar Marcacoes em Dias Nao Trabalhados  ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			lAutoSai := !Empty( cAutoSai := AllTrim( StrTran( GetMemVar( "R6_AUTOSAI" ) , "*" , "" ) ) )

		EndIF

		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Verifica os Tipos de Marcacoes para o Dia                   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		For nMarc := nTab To nLenTab
			IF ( aTabCalend[ nMarc , CALEND_POS_ORDEM ] == cOrdem )
				cUltmarc	:=  ( aTabCalend[ nMarc , CALEND_POS_TIPO_MARC ] + "-" ) 
				cTipMarcDia += cUltmarc
			Else
				Exit
			EndIF	
		Next nMarc  
		
    	/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Limita as Marcacoes automaticas a maior marcacao da Tabela   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/ 
		cNewMarcAut	:= "" 
		IF !empty(cUltmarc)        	
	       	For nMarc := 1 To Len(cMarcAut) Step 3
			
	       		cMarc:= SubStr( cMarcAut , nMarc , 3 )
	       		If cMarc <= cUltmarc
		       		cNewMarcAut+= cMarc
		       	Endif
	
	       	Next nX
        Else 
	        cNewMarcAut:= cMarcAut
        Endif          
        
    	/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Verifica novamente a existencia de marcacoes a gerar	      ³
		³ Se nao Tiver Marcacoes a Gerar Vai Para o Proximo Dia	      ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		IF Empty( nMarcAut := Len( cNewMarcAut ) )
			Loop
		EndIF    
	
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Verifica Quais Marcacoes sao Obrigatorias                   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
       	cMarcsObriga	:= cTipMarcDia
       	nMarcsGer	 	:= 0
       	For nMarc := 1 To nMarcAut Step 3
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Apura o Numero de Marcacoes a Gerar						  ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			nMarcsGer++
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³Se Todas as Marcacoes Obrigatorias Foram Efetuadas sai do For³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
       		IF Empty( cMarcsObriga := StrTran( cMarcsObriga , SubStr( cNewMarcAut , nMarc , 3 ) , "" ) )
       			Exit
       		EndIF
       	Next nX

		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Reinicializa as Variaveis Tabela e Marcacoes                ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		aTDia := {}
		aMDia := {}
		

		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ N„o gera Marca‡oes Autom ticas em Feriados e Dias Nao Traba ³
		³ lhados                                                      ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		IF (;
					aTabCalend[ nTab , CALEND_POS_FERIADO ] .AND. ( aTabCalend[ nTab , CALEND_POS_EXCECAO ] != "E" );
					.and.;
					!( lTrabFer );
					.and.;
					( !(lAutosai) .OR. !(aTabCalend[nTab , CALEND_POS_TIPO_DIA] $ cAutoSai ));
			)		
			Loop
		EndIF
		
		// Não gera Marcações Automáticas Para Funcionários Afastados
		If aTabCalend[nTab, CALEND_POS_EXCECAO] != "E" .And. aTabCalend[nTab, CALEND_POS_AFAST]
			IF (((aTabCalend[nTab, CALEND_POS_DATA] >= aTabCalend[nTab, CALEND_POS_INI_AFAST]);
				.and.;
				(aTabCalend[nTab, CALEND_POS_DATA] <= aTabCalend[nTab, CALEND_POS_FIM_AFAST]));
				.or.;
				((aTabCalend[nTab, CALEND_POS_DATA] >= aTabCalend[nTab, CALEND_POS_INI_AFAST ]);
				.and.;
				Empty( aTabCalend[nTab, CALEND_POS_FIM_AFAST ])))	
				LOOP
			EndIF
		EndIF
		
		While (;
					( nTab <= nLenTab );
					.and.;
					( cOrdem == aTabCalend[ nTab , CALEND_POS_ORDEM ] );
			  )
			aAdd( aTDia,;
							{;
								aTabCalend[ nTab , CALEND_POS_DATA		]	,;	//01 - Data
						   		aTabcalend[ nTab , CALEND_POS_HORA		]	,;	//02 - Hora
						   		aTabCalend[ nTab , CALEND_POS_TIPO_MARC	]	,;	//03 - Tipo Marcacao
						   		aTabCalend[ nTab , CALEND_POS_TIPO_DIA	]	,;	//04 - Tipo do Dia
						   		aTabCalend[ nTab , CALEND_POS_HRS_INTER	]	,;	//05 - Horas de Intervalo
						   		aTabCalend[ nTab , CALEND_POS_TURNO		]	,;	//06 - Turno de Trabalho
						   		aTabCalend[ nTab , CALEND_POS_CC		]	,;	//07 - Centro de Cuto
						   		aTabCalend[ nTab , CALEND_POS_FERIADO	]	,;	//08 - Dia Corresponde a Feriado
						   		aTabCalend[ nTab , CALEND_POS_HRS_TRABA	]	,;	//09 - Horas Trabalhadas
						   		aTabCalend[ nTab , CALEND_POS_SEQ_TURNO	]	 ;	//10 - Sequencia do Turno
							};
				 )
			nTab++
		End While
		nTab := 0
		aEval( aTDia , { |x| nTab := SomaHoras( nTab , x[9] ) } )
	
	Else

		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Nao Encontrou a Ordem no Calendario                         ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		Loop

	EndIF

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Procura a Ordem em aMarcacoes.                              ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	IF ( ( nMarc := aScan( aMarcacoes, { |x| x[3] == cOrdem } ) ) > 0 )
		While (;
					( nMarc <= nLenMarc );
					.and.;
					( cOrdem == aMarcacoes[ nMarc , 3 ] );
			   )
			aAdd( aMDia , { aMarcacoes[ nMarc , 1 ] , aMarcacoes[ nMarc , 2 ], nMarc, aMarcacoes[ nMarc ,AMARC_FLAG] } )
			nMarc++
		End While
		nMarc := 0
	EndIF

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ So Gerar Marcacoes nos Dias em Que Existirem Marcacoes ou se³
	³ Tiver Horas Trabalhadas no Calendario de Marcacoes          ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	IF (;
			( nTab == 0 );
			.or.;
			(;
				Empty( aMDia );
				.and.;
				!( lAutomSM );  
			 );
		)
		Loop
	EndIF

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ S¢ gera Marca‡oes Autom ticas se o tipo do dia for "S"im.   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	IF !( aTDia[1,4] == "S" )
	    IF ( lAutoSai ) 
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ S¢ gera Marca‡oes Autom ticas se o tipo do dia for "C"-Compensado ³
			³ ou "D" - Descanso ou Dia marcacao for Feriado					    ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			IF !(;
					( aTDia[1,4] $ cAutoSai );
					.or.;
					( aTDia[1,8] );
				 )
				Loop
			EndIF
		Else
			Loop
		EndIF			
	EndIF

	// Se o funcionário não possui intervalo, as marcações automaticas são referente ao intervalo 
	// e não está para completar as marcações não gera marcações automáticas
	If Len(aTDia) == 2 .And. !lCompletaMar .And. ("1S-2E" $ cMarcAut .And. !("1E" $ cMarcAut))
		Loop
	EndIf
	
	lMarcAut := .F.
	If ((cInMovel == "S" .And. cCompMar == "S"  .And. nMovPint > 0) .Or. (cInMovel == "N" .And. cCompMar == "N" .And. nMovPint == 0)) .And. (nPosTabM := (aScan(aTDia, { |x|  x[5] > 0 })))
		If (aScan(aMDia, { |x| x[2] > aTDia[nPosTabM, 2] .And. x[2] <= SomaHoras(aTDia[nPosTabM, 2],nMovPint) })) == 0
			lMarcAut := .T.
		EndIf
	EndIf

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Verifica Qual Horario da Tabela Esta Sem Marcacao           ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	aTab_Marc := StuffMarcTab( aTDia , aMDia , cNewMarcAut )

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Inverte Marcacao de Entrada de Intervalo com Marcacao de  En³
	³ trada Quando Marcacao de Intervalo for Menor que Marcacao da³
	³ tabela													  ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	AjustMarc( aTDia , NIL , aTab_Marc , NIL , cNewMarcAut , .T. , aClone( aMDia ) , lAutoSai )

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Insere a marcacao lida e nao incluida no aTab_Marc qdo. se  ³
	³ tratar da ultima saida (situacao nao contemplada na aproxim.³
	³ de horarios de StuffMarcTab).								  ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	nTab_Marc := Len( aTab_Marc )
	
	For nMarc := 1 To Len( aMDia )
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Verifica se a marcacao ja foi incluida em aTabMarc.         ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		IF ( aScan( aTab_Marc, { |x| If( !Empty( x[ 2 ] ), x[ 2, 1 ] == aMDia[ nMarc , 1 ] .And. x[ 2 , 2 ] == aMDia[ nMarc , 2 ], .F. ) } ) == 0 )
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Nao encontrou ultima saida e a marcacao nao lida e nao      ³
			³ incluida eh maior que a ultima saida prevista no calendario,³
			³ entao assume como sendo a ultima saida.                     ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			IF Empty( aTab_Marc[ nTab_Marc , 2 ] ) .And. DataHora2Str( aMDia[ nMarc , 1 ] , aMDia[ nMarc , 2 ] ) > aTab_Marc[ nTab_Marc , 4 ]
				aTab_Marc[ nTab_Marc , 2 ] := { aMDia[ nMarc , 1 ], aMDia[ nMarc , 2 ] }
				aTab_Marc[ nTab_Marc , 3 ] := nMarc
				aTab_Marc[ nTab_Marc , 4 ] := DataHora2Str( aTab_Marc[ nTab_Marc , 1 , 1 ] , aTab_Marc[ nTab_Marc , 1 , 2 ] )
				aTab_Marc[ nTab_Marc , 5 ] := aMDia[ nMarc , 3 ]
			EndIF
		EndIF
	Next nMarc                     

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Ponto de Entrada para Remanejamento dos Horarios de         ³
	³ Tabela X Marcacoes realizadas.						      ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	If lPnMcAut01                                                     
		If ( ValType( uRet := ExecBlock("PNMCAUT01" , .F. , .F. , {aTab_Marc, aTDia, aMdia,  cNewMarcAut  } ) ) == "A" )
		   aTab_Marc:= aClone(uRet)
		Endif
	Endif	

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Totaliza o Numero de Marcacoes ja Efetuadas                 ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	nMarcsEfe := 0
	cMarcsEfe := ""
	MarcEfetuadas(aTab_Marc, lSobrepoe,  cTipMarcDia,  cMarcsObriga, @nMarcsEfe, @cMarcsEfe) 

	// Verifica quais marcações de intervalos não foram geradas e se deve completar
	If !lCompletaMar
		nLenATabM := Len(aTab_Marc)

		For nI := 1 To nLenInt
			nPosSI := aScan(aTab_Marc, {|x| x[6] == aIntervalo[nI,1]})

			If nPosSI > 0 .And. nPosSI + 1 < nLenATabM
				If aTab_Marc[nPosSI, 6] $ cNewMarcAut .And. aTab_Marc[nPosSI + 1, 6] $ cNewMarcAut
					If Empty(aTab_Marc[nPosSI, 2]) .And. !Empty(aTab_Marc[nPosSI + 1, 2]) .And. aTab_Marc[nPosSI, 6] $ cNewMarcAut
						aTab_Marc[nPosSI, 7] := .F.
					ElseIf !Empty(aTab_Marc[nPosSI, 2]) .And. Empty(aTab_Marc[nPosSI + 1, 2]) .And. aTab_Marc[nPosSI, 6] $ cNewMarcAut
						aTab_Marc[nPosSI + 1, 7] := .F.
					EndIf
				EndIf
			EndIf
		Next
	EndIf

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Verifica se as Marcacoes Obrigatorias foram efetuadas       ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
    IF !( lMarcsObriga := ( Empty( cMarcsObriga ) .and. Empty( cMarcsEfe ) ) )
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ So verifica as Marcacoes Obrigatorias se nao for   Completar³
		³ as Marcacoes que Faltam 									  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
    	IF !( lCompletaMar )
    		if(lMarcAut02)
    			uRet := ExecBlock("MARCAUT2" , .F. , .F. , {cNewMarcAut,cMarcsObriga,cMarcsEfe,nMarcsGer,lMarcsObriga})
    			If ( ValType(uRet) == "A" .And. Len(uRet) > 4)		   			
		   			cNewMarcAut	:= uRet[1]
		   			cMarcsObriga	:= uRet[2]
		   			cMarcsEfe		:= uRet[3]
		   			nMarcsGer		:= uRet[4]
		   			lMarcsObriga	:= uRet[5]
				Endif
    			
    			IF Empty( cNewMarcAut )
					Exit
				Endif    				
    		else    		
				For nMarc := 1 To Len( cMarcsObriga ) Step 3
	   				IF !( lMarcsObriga := ( SubStr( cMarcsObriga , nMarc , 3 ) $ cMarcsEfe ) )
	   					Exit 
					EndIF
	   			Next nMarc
    		endIf
       EndIF	
    ElseIF (;
    			( lCompletaMar );
    			.and.;
    			( lAutomSM );
    		 )
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Deixar a Carga de Todas as Marcacoes, quando estas nao  exis³
		³ tirem, para lAutomSM     									  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
    	lCompletaMar := .F.
    EndIF

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Gera as Marcacoes Automaticas                               ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	IF (;
			(;
				( lMarcsObriga );
				.or.;
				( lCompletaMar );
			);
			.and.;
			( ( nFornY := Len( aTab_Marc ) ) > 0 );
		 )            
		 
		 If !( lSobrepoe )
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³Recalcula as marcacoes a serem geradas subtraindo as marca-  ³
			³coes efetuadas.											  ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			For nMarc := 1 To Len(cMarcsEfe) Step 3
				
				/*/
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³Diminue as marcacoes geradas a cada marcacao ja efetuada     ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	       		IF SubStr( cMarcsEfe , nMarc , 3 )$ cNewMarcAut
					nMarcsGer--
	       		EndIF
	       	Next nX
	
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Se todas as marcacoes a gerar ja foram efetuadas vai para a ³
			³ proxima ordem.											  ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/		       	
			If Empty(nMarcsGer)
			   Loop
			Endif
		Endif
		
		//-- Inicializa todas as marcacoes do dia (Antigas e Geradas)
		aMarcDia	:= aclone(aMDia)
		
		nPosInt := 0
		
		For nY := 1 To nFornY
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ So Gera Quando Nao Existir Marcacoes ou se Sobrescreve      ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			IF (;
					!Empty( aTab_Marc[ nY , 02 ] );
					.and.;
					!( lSobrepoe );
				) 
				 //-- Altera o estado do flag para nao demonstra-lo como automatico ("A") no caso de log de
                 //-- geracao de marcacoes impares. 
                 If !Empty(aMarcDia)
                    If !Empty(aTab_Marc[nY, 03])
		                 aMarcDia[aTab_Marc[nY, 03],4] := "E"				
		            Endif
		         Endif        
				Loop
			EndIF

			If !aTab_Marc[nY, 7]
				loop
			EndIf

			IF ( nPos := aScan( aTDia , { |x|	x[1] == aTab_Marc[ nY , 01 , 01 ] .and. ;
			   									x[2] == aTab_Marc[ nY , 01 , 02 ]		;
									    };
						      );
				) > 0
				/*/
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³Verifica se Devera Gerar a Marcacao Automatica para o Tipo de³
				³Marcacao em questao. Se o Tipo Nao Estiver Selecionado e a Di³
				³ferenca de Horas Entre o Tipo Selecionado e um Tipo  Imediata³
				³mente Anterior ou Posterior Que Tenha Sido Selecionado    for³
				³igual, tambem Gera a Marcacao Automatica. Pois Neste caso nao³
				³da Para Identificar a Quem Pertence a Marcacao Efetuada.     ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
				IF (;
						(;
							AjustMarc( aTDia , nPos , aTab_Marc , nY , cNewMarcAut );
							.or.;
							( aTDia[nPos,3] $ cNewMarcAut );
						 );
						.and.;
				   		( Len( aTDia ) - nMarcsGer >= nMarcsEfe );
				   	)	
                Else
                    //-- Altera o estado do flag para nao demonstra-lo como automatico ("A") no caso de log de
                    //-- geracao de marcacoes impares.
                    If !Empty(aMarcDia)
	                    If !Empty(aTab_Marc[nY, 03])
			                 aMarcDia[aTab_Marc[nY, 03],4] := "E"				
			            Endif
			        Endif   
                	Loop
                EndIF
			Else
					 //-- Altera o estado do flag para nao demonstra-lo como automatico ("A") no caso de log de
                    //-- geracao de marcacoes impares.
                    If !Empty(aMarcDia)
	                    If !Empty(aTab_Marc[nY, 03])
			                 aMarcDia[aTab_Marc[nY, 03],4] := "E"				
			            Endif
			        Endif  
				Loop
			EndIF

			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³Retorna as Horas Maximas Para a Geracao Aleatoria. Os Minutos³
			³Aleatorios nao  podem Exceder `a metada da Jornada.		  ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			IF ( lAleat ) //Marcacao Aleatoria
				IF ( nTab := aScan( aTabCalend, { |x| x[CALEND_POS_TIPO_MARC] == aTDia[nPos,3] .and. x[CALEND_POS_DATA] == aTDia[nPos,1] } ) ) > 0
					IF ( aTabCalend[ nTab , CALEND_POS_HRS_INTER ] > 0 .or. SubStr(aTDia[nPos,3],-1) == "E" )
						IF ( lInterv := ( aTabCalend[ nTab , CALEND_POS_HRS_INTER ] > 0 ) )
						    nInterv := Min( ( __Hrs2Min( aTabCalend[ nTab , CALEND_POS_HRS_INTER ] ) / 2 ) , nMinuto )
						ElseIF ( lInterv := ( aTabCalend[ Max( 1 , nTab - 1 ) , CALEND_POS_HRS_INTER ] > 0 ) )
							nInterv := Min( ( __Hrs2Min( aTabCalend[ Max( 1 , nTab - 1  ) , CALEND_POS_HRS_INTER ] ) / 2 ) , nMinuto )
						EndIF
					EndIF
					IF ( aTabCalend[ nTab , CALEND_POS_HRS_TRABA ] > 0 .or. SubStr(aTDia[nPos,3],-1) == "S" )
						IF ( aTabCalend[ nTab , CALEND_POS_HRS_TRABA ] > 0 )
						    nHrTrab := Min( ( __Hrs2Min( aTabCalend[ nTab , CALEND_POS_HRS_TRABA ] ) / 2 ) , nMinuto )
						ElseIF ( aTabCalend[ Max( 1 , nTab - 1 ) , CALEND_POS_HRS_TRABA ] > 0 )
							nHrTrab := Min( ( __Hrs2Min( aTabCalend[ nTab - 1 , CALEND_POS_HRS_TRABA ] ) / 2 ) , nMinuto )
						EndIF
					EndIF	
				EndIF
				dDtMarc	:= aTDia[nPos,1]
				nMarc	:= aTDia[nPos,2]
				/*/
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Gera minutos aleatorios									  ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
				IF ( SubStr(aTDia[nPos,3],-1) == "E" ) //-- Marcacoes de entrada
					IF lInterv
						If lSumIntAleat
							//Se houve marcacao anterior soma a diferenca entre o realizado e o programado
							If Len(aMarcGer) > 0
								nMarc := aTDia[nPos,2] + (aMarcGer[Len( aMarcGer ),2] - aTDia[nPos-1,2])
							EndIf						
							nMarc := DataHora2Ale(@dDtMarc,nMarc,nInterv,@nAleato,"S")
						Else
							nMarc := DataHora2Ale(@dDtMarc,nMarc,nInterv,@nAleato,"E")
						EndIf					
					Else
						nMarc := DataHora2Ale(@dDtMarc,nMarc,nHrTrab,@nAleato,"E")
					EndIF	
				Else //-- Marcacoes de saida
					IF lInterv
						nMarc := DataHora2Ale(@dDtMarc,nMarc,nInterv,@nAleato,"S")
					Else
						nMarc := DataHora2Ale(@dDtMarc,nMarc,nHrTrab,@nAleato,"S")
					EndIF	
				EndIF
      			lInterv := .F.
      		Else
      			dDtMarc	:= aTDia[nPos,1]
      			nMarc	:= aTDia[nPos,2]
      		EndIF	
            
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Obtem o Tipo de Marcacao a Ser Gerada						  ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			cTpMarc := aTDia[nPos,3]

			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Carrega as Marcacoes Automaticas							  ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			aAdd( aMarcGer , Array( ELEMENTOS_AMARC + 1 ) )
			nLenMAuto := Len( aMarcGer )
			aMarcGer[ nLenMAuto , AMARC_DATA		] := dDtMarc											// 01 - Data
			aMarcGer[ nLenMAuto , AMARC_HORA		] := nMarc												// 02 - Hora
			aMarcGer[ nLenMAuto , AMARC_ORDEM		] := cOrdem												// 03 - Ordem
			aMarcGer[ nLenMAuto , AMARC_FLAG		] := If(lPONM030,"G","A")								// 04 - Flag
			aMarcGer[ nLenMAuto , AMARC_RECNO		] := 0													// 05 - Recno
			aMarcGer[ nLenMAuto , AMARC_TURNO		] := aTDia[nPos,6]										// 06 - Turno
			aMarcGer[ nLenMAuto , AMARC_FUNCAO		] := _cSpceFuncao              							// 07 - Funcao
			aMarcGer[ nLenMAuto , AMARC_GIRO		] := _cSpceGiro               							// 08 - Giro
			aMarcGer[ nLenMAuto , AMARC_CC			] := IF(!Empty(aTDia[nPos,7]),aTDia[nPos,7],cCusto )	// 09 - Centro Custo
			aMarcGer[ nLenMAuto , AMARC_APONTA		] := "N"												// 10 - Flag de Apontamento
			aMarcGer[ nLenMAuto , AMARC_RELOGIO		] := _cSpceRelogi               						// 11 - Relogio
			aMarcGer[ nLenMAuto , AMARC_TIPOMARC	] := cTpMarc											// 12 - Tipo da Marcacao
			aMarcGer[ nLenMAuto , AMARC_L_ORIGEM	] := .F.												// 13 - Logico
			aMarcGer[ nLenMAuto , AMARC_DTHR2STR	] := DataHora2Str(;                                          
																	aMarcGer[ nLenMAuto , AMARC_DATA ] ,;
																	aMarcGer[ nLenMAuto , AMARC_HORA ]  ;
																  )                                    		//14 - String de Data/Hora para aSort
			aMarcGer[ nLenMAuto , AMARC_PERAPONTA	] := cPerAponta											//15 - String de Data com o Periodo de Apontamento
			If lPort1510
	            If( aTDia[nPos,3] $ cIntTotDet )
	            	lIntPreDet := .T.
	            Else
	            	lIntPreDet := .F.
	            EndIf
    			
				aMarcGer[ nLenMAuto , AMARC_DATAAPO	] := dDtApo												//25 - Data de Apontamento
				aMarcGer[ nLenMAuto , AMARC_NUMREP	] := cSpaceNumRep										//26 - Numero do REP
				aMarcGer[ nLenMAuto , AMARC_TPMCREP	] := cSpaceTpMar										//27 - Tipo de Marcacao no REP
				aMarcGer[ nLenMAuto , AMARC_TIPOREG	] := If(lIntPreDet,"P","I")								//28 - Tipo de Registro
				aMarcGer[ nLenMAuto , AMARC_MOTIVRG	] := If(lIntPreDet,cMotivoAut,cMotivoInc)  				//29 - Motivo da inclusao
				aMarcGer[ nLenMAuto , AMARC_SEQ		] := aTDia[nPos,10]										// 06 - Semana/Sequencia do Turno
			EndIf
			aMarcGer[ nLenMAuto , ELEMENTOS_AMARC  + 1 ] := If( !EMPTY( aTab_Marc[ nY, 02 ] ), aTab_Marc[ nY , 05 ], 0 ) //16 - Ponteiro para a marcacao a ser subsituida (se possuir hora correspondente) ou incluida (o trabalhador nao realizou a marcacao)

			//-- Marcacoes do dia (Antigas e Geradas)
			 If !EMPTY( aTab_Marc[ nY, 02 ] ) 
			 	If !Empty(aMarcDia)
				    If !Empty(aTab_Marc[nY, 03]) 
					    aMarcDia[ aTab_Marc[ nY , 03 ],1 ]:= dDtMarc
					    aMarcDia[ aTab_Marc[ nY , 03 ],2 ]:= nMarc
					    aMarcDia[ aTab_Marc[ nY , 03 ],4 ]:= "A"
				    Endif
				Endif    
			 Else
			    aAdd(aMarcDia, { dDtMarc, nMarc,0, "A"	}  )
			 Endif
			    
		Next nY
   		aSort( @aMarcDia , NIL , NIL , { |x,y| ( Dtoc(x[1]) + StrZero( x[2] , 5 , 2 ) ) <  ( Dtoc(y[1]) + StrZero( y[2] , 5 , 2 ) ) } )
       if(lMarcAut03)
   			uRet := ExecBlock("MARCAUT3" , .F. , .F. ,  {aClone(aMarcDia)})
			If ( ValType(uRet) == "A" .And. Len(uRet) > 0)		   			
	   			aMarcDia := aClone(uRet[1])		   			
			Endif	
   		endIf
        //-- Verifica se serao geradas marcacoes em quantidade impar
       If ( Len(aMarcDia) % 2 ) > 0                                         
       	AADD(aMarcNoGer, {dDtApo, aClone( aMarcDia ), "IMPAR" } )	                                 
       else       
	    	//-- Adiciona cada uma das marcações geradas para a ordem lida
	    	Aeval(aMarcGer, {|x| AADD(aMAuto, aClone(x) ) } )
       Endif
        
	EndIF

Next nOrdem

/*/                  
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ As Marca‡oes Autom ticas s„o Transferidas para o aMarcacoes.³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
IF ( ( nLenMarc := Len( aMAuto ) ) > 0 )

	For nMarc := 1 To nLenMarc
        If Empty( aMAuto[ nMarc , ELEMENTOS_AMARC  + 1 ] ) 
		    nPos := aScan(	aMarcacoes, { |x|;
		    									x[ AMARC_DATA  		] == aMAuto[ nMarc , AMARC_DATA  		];
		    									.and.;
												x[ AMARC_TIPOMARC  	] == aMAuto[ nMarc , AMARC_TIPOMARC  	];
												.and.;
												x[ AMARC_FLAG  		] == aMAuto[ nMarc , AMARC_FLAG		  	];
												.and.;
												x[ AMARC_ORDEM 		] == aMAuto[ nMarc , AMARC_ORDEM 		];
												.and.;
												x[ AMARC_HORA 		] == aMAuto[ nMarc , AMARC_HORA 		];
								  		};
					 	  )
        Else 
        	nPos :=  aMAuto[ nMarc , ELEMENTOS_AMARC  + 1 ] 
        Endif
		IF ( nPos > 0 )

			IF !( lSobrepoe ) .or. ( lPort1510 .and. aMarcacoes[ nPos , AMARC_TIPOREG] == "O" )
		    	Loop
		    EndIF

			nSvRecno 						:= aMarcacoes[ nPos , AMARC_RECNO ]
			aMarcacoes[ nPos ]				:= aClone( aMAuto[ nMarc ] ) 
			aMarcacoes[ nPos , AMARC_RECNO]	:= nSvRecno

		Else

			aAdd( aMarcacoes , aClone( aMAuto[ nMarc ] ) )

		EndIF

	Next nMarc

EndIF

/*/	
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ O Array aMarcacoes ‚ indexado por Ordem + Data + Hora.      ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
IF ( lAuto := !ArrayCompare( aMarcacoes , aCloneMarc ) )
	aSort( @aMarcacoes , NIL , NIL , { |x,y|	(x[AMARC_ORDEM]+x[AMARC_DTHR2STR]);
								 				<;
								     			(y[AMARC_ORDEM]+y[AMARC_DTHR2STR]);
						     		  };
		  )
EndIF

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Reordeno corretamente o tipo de marcação nas marcações 	   ³
³ geradas												   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
fAltTpMarc(@aMarcacoes)

Return( lAuto )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³MarcEfetuadas ³ Autor ³Mauricio MR			  ³ Data ³17/06/2005³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Calcula o numero de marcacoes efetuadas	                       	³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³																³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL																³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function MarcEfetuadas(aTab_Marc, lSobrepoe,  cTipMarcDia,  cMarcsObriga, nMarcsEfe, cMarcsEfe)
Local cTipMarc	:= ""
Local nX		:= 0     
Local nFor 		:= Len(aTab_Marc)

For nX:=1 to nFor
    //-- Se Existir marcacao 
	If !Empty( aTab_Marc[ nX, 2 ] ) 
		If !lSobrepoe
		    //-- Acumula todas as marcacoes efetuadas
		    nMarcsEfe++
		    cMarcsEfe+= SubStr(cTipMarcDia, Getfxy( 3, nX ), 3 ) 	
		Else                                               
		    //-- Acumula como efetuadas apenas as marcacoes que devem existir (as nao selecionadas para gerar)
		    cTipMarc := SubStr(cTipMarcDia, Getfxy( 3, nX ), 3 )
		    If cTipMarc  $ cMarcsObriga
				cMarcsEfe+= cTipMarc
			    nMarcsEfe++
			Endif 
		Endif		 	
	Endif 
Next nX 		 
REturn ( NIL )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³RstMarcAuto	  ³ Autor ³Marinaldo de Jesus     ³ Data ³05/10/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Reinicializa as Statics em PutMarcAuto()                       	³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³																³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL																³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function RstMarcAuto()

_aSpaHeader		:= NIL
_aSr6Header		:= NIL

_cSr6LastTno	:= NIL
_cSpaLastReg	:= NIL
_cSpceFuncao	:= NIL
_cSpceGiro		:= NIL
_cSpceRelogi	:= NIL

lPa_CompMar		:= NIL

_nSpaHeader		:= NIL
_nSr6Header		:= NIL

Return( NIL )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³StuffMarcTab ³Autor³ Marinaldo de Jesus   ³ Data ³13/08/2001³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Unir Array de Marcacoes x Tabela para verificar a Marcacao  ³
³          ³que falta.													³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³StuffMarcTab( aTab , aMarc )     						    ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³PutMarcAuto()                                               ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³Array com os Respectivos pares Marcacoes x Tabela           ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³ aTab  = Array com os Horarios da Tabela                    ³
³          ³ aMarc = Array com as Marcacoes do Funcionario              ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function StuffMarcTab( aTab , aMarc, cNewMarcAut )

Local aUnion		:= {}
Local aTemp			:= {}
Local aTemp1		:= {}
Local cDtHr1		:= ""
Local cDtHr2		:= ""
Local nHora1		:= 0
Local nHora2		:= 0
Local nTab   		:= 0
Local nForTab		:= Len( aTab )
Local nMarc	 		:= 0
Local nForMarc		:= Len( aMarc )
Local nI			:= 0
Local nLenUnion		:= 0

For nTab  := 1 To nForTab
	aTemp := {}
	For nMarc := 1 To nForMarc
		aAdd( aTemp , { nMarc , DataHora2Val(	aTab[  nTab , 01  ]		,;
											 	aTab[  nTab , 02  ]		,;
											 	aMarc[ nMarc , 01 ]		,;
											 	aMarc[ nMarc , 02 ]		,;
											 	"H"						 ;
											  ),;
											 	aMarc[ nMarc , 03 ]    ,;
											 	aTab[ nTab , 03 ]       ;
						};											  
			 )
	Next nMarc
	
	If nForTab == nForMarc .And. lMarcAut == .F.
		If  nTab <= nForMarc
			IF !Empty( aTemp )
				aAdd( aUnion , { { aTab[ nTab , 01 ] , aTab[ nTab , 02 ] }							 ,;
								 { aMarc[ aTemp[ nTab , 01 ] , 01 ] , aMarc[ aTemp[ nTab , 01 ] , 02 ] } ,;
								 aTemp[ nTab , 01 ],;
								 DataHora2Str( aTab[ nTab , 01 ] , aTab[ nTab , 02 ] ),;
								 aTemp[nTab,03],;
								 aTemp[nTab,04];
							    };
			     	)
			Else
				aAdd( aUnion , { { aTab[ nTab , 01 ] , aTab[ nTab , 02 ] }	 ,;
								 {}											 ,;
								 0,;
								 DataHora2Str( aTab[ nTab , 01 ] , aTab[ nTab , 02 ] ),;
								 0,;
								 "";
							    };
			     	)
			EndIF	
		Endif
	Else
		aSort( @aTemp , NIL , NIL , { |x,y| x[2] < y[2] } )
		IF !Empty( aTemp )
			aAdd( aUnion , { { aTab[ nTab , 01 ] , aTab[ nTab , 02 ] }							 ,;
								{ aMarc[ aTemp[ 01 , 01 ] , 01 ] , aMarc[ aTemp[ 01 , 01 ] , 02 ] } ,;
								aTemp[ 01 , 01 ],;
								DataHora2Str( aTab[ nTab , 01 ] , aTab[ nTab , 02 ] ),;
								aTemp[01,03],;
								aTemp[01,04];
							};
	     		)
		Else
			aAdd( aUnion , { { aTab[ nTab , 01 ] , aTab[ nTab , 02 ] }	 ,;
								{}											 ,;
								0,;
								DataHora2Str( aTab[ nTab , 01 ] , aTab[ nTab , 02 ] ),;
								0,;
								"";
							};
	     		)
		EndIF	
	EndIF
Next nTab

IF !Empty( aUnion )
	aSort( @aUnion , NIL , NIL , { |x,y| x[4] < y[4] } )
EndIF

IF !Empty( aMarc )

	aTemp := {}
	
	nForTab := Len( aUnion )
	For nTab := 1 To nForTab
		For nMarc := 1 To nForTab
			IF ( ( aUnion[ nTab , 3 ] == aUnion[ nMarc , 3 ] ) .and. !ArrayCompare( aUnion[ nTab ] , aUnion[ nMarc ] ) )
				IF ( aScan( aTemp , { |x| x[4] == aUnion[ nTab , 4 ] } ) == 0 )
					aAdd( aTemp , aClone( aUnion[ nTab ] ) )
					aTemp[ Len( aTemp ) , 03 ] := nTab
				EndIF	
			EndIF   
		Next nMarc
	Next nTab
	
	IF !Empty( aTemp )
	
		aSort( @aTemp , NIL , NIL , { |x,y| x[4] < y[4] } )
	
		nForTab := Len( aTemp )
		For nTab := 1 To nForTab
			cDtHr1 := DataHora2Str( aTemp[ nTab , 02 , 01 ] , aTemp[ nTab , 02 , 02 ] )
			nHora1 := DataHora2Val( aTemp[ nTab , 01 , 01 ] ,;
									aTemp[ nTab , 01 , 02 ] ,;
									aTemp[ nTab , 02 , 01 ] ,;
									aTemp[ nTab , 02 , 02 ] ,;
									"H";
								   )
			IF ( aScan( aTemp1 , { |x| x[1] == cDtHr1 .and. x[2] == aTemp[ nTab , 03 ] .and. x[3] == nHora1 } ) == 0 )
				aAdd( aTemp1 , { cDtHr1 , aTemp[ nTab , 03 ] , nHora1, aTemp[ nTab, 04 ] } )
			EndIF
			For nMarc := nTab + 1 To nForTab
				IF ( cDtHr2 := DataHora2Str( aTemp[ nMarc , 02 , 01 ] , aTemp[ nMarc , 02 , 02 ] ) ) == cDtHr1
					nHora2 := DataHora2Val( aTemp[ nMarc , 01 , 01 ] ,;
											aTemp[ nMarc , 01 , 02 ] ,;
											aTemp[ nMarc , 02 , 01 ] ,;
											aTemp[ nMarc , 02 , 02 ] ,;
											"H";
										   )
					IF ( aScan( aTemp1 , { |x| x[1] == cDtHr2 .and. x[2] == aTemp[ nMarc , 03 ] .and. x[3] == nHora2 } ) == 0 )
						If nMarc == nForTab .And. cDtHr2 <= aTemp[ nMarc , 04 ] .And. cDtHr2 >= aTemp[ nMarc -1 , 04 ]
							If !(aTemp[ nMarc, 06 ] $ cNewMarcAut)
								aAdd( aTemp1 , { cDtHr2 , aTemp[ nMarc , 03 ] , 0 , aTemp[ nMarc, 04 ] } )
							Else
								aAdd( aTemp1 , { cDtHr2 , aTemp[ nMarc , 03 ] , nHora2, aTemp[ nMarc, 04 ] } )		
							EndIf
						Else
							aAdd( aTemp1 , { cDtHr2 , aTemp[ nMarc , 03 ] , nHora2, aTemp[ nMarc, 04 ] } )	
						EndIf 
					EndIF
					nTab := nMarc
				Else
					Exit
				EndIF
			Next nMarc
		Next nTab
		
		aSort( @aTemp1 , NIL , NIL , { |x,y| x[1] + StrZero( x[3] , 5 , 2 ) < y[1] + StrZero( y[3] , 5 , 2 ) } )
		
		nForTab := Len( aTemp1 )
		For nTab := 1 To nForTab
			For nMarc := nTab + 1 To nForTab
				IF aTemp1[ nMarc , 1 ] == aTemp1[ nTab , 1 ]
					aUnion[ aTemp1[ nMarc , 2 ] , 02 ] := {}
					nTab := nMarc
				Else
					Exit
				EndIF	
			Next nMarc	
		Next nTab
	
	EndIF

EndIF

// Cria uma nova coluna para informar as marcações de intervalo que deverão ser geradas.
nLenUnion := Len(aUnion)

For nI := 1 To nLenUnion
	aAdd(aUnion[nI], .T.)
Next

Return( aUnion )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³AjustMarc()  ³Autor³ Marinaldo de Jesus   ³ Data ³14/08/2001³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³AjustMarc()													³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³AjustMarc(aTDia,nPos,<@>aTab_Marc,nY,cMarcAut,lInverte)		³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³PutMarcAuto()                                               ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³True se a Diferenca for Igual                               ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³ aTDia    	= Array com as Marcacoes da Tabela de Horario	³
³          ³ nPos     	= Indice de aTDia								³
³          ³ aTab_Marc	= Array com Horarios da Tabela x Marcacoes 		³
³          ³ nY       	= Indice para aTab_Marc                    		³
³          ³ cMarcaut	= Marcacoes a Serem Geradas						³
³          ³ lInverte	= Inverter Marcacao de Entrada de Intervalo  com³
³          ³              Entrada do Expediente							³
³          ³ aMDia      = Array com as Reais Marcacoes do Dia			³
³          ³ lAutoSai   = Se Gera Marcacoes de Intervalo Para Dias N.T. ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function AjustMarc( aTDia , nPos , aTab_Marc , nY , cMarcAut , lInverte , aMDia , lAutoSai )

Local cTipMarc		:= ""
Local dDtTab		:= Ctod("//")
Local dDtMar		:= Ctod("//")
Local lRet			:= .F.
Local nHrTab		:= 0
Local nHrMar		:= 0
Local nLenDia		:= Len( aTDia )
Local nLenTma		:= Len( aTab_Marc )
Local nHora1		:= 0
Local nHora2		:= 0.01
Local nMarcs		:= 0
Local nMarc			:= 0
Local nLenMarcs		:= 0

DEFAULT nPos		:= 0
DEFAULT nY			:= 0
DEFAULT lInverte	:= .F.
DEFAULT aMDia		:= {}

lInverte := IF( lInverte , ( Len( cMarcAut ) == 6 .and. SubStr( cMarcAut , 2 , 1 ) == "S" .and. SubStr( cMarcAut , 5 , 1 ) == "E" ) , lInverte )

IF ( nLenDia > 0 )

	IF !( lInverte ) .and. Len( cMarcAut ) == 3.00 .and. !Empty( nPos ) .and. !( aTDia[ nPos , 3 ] $ cMarcAut )

		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Verifica se Devera Gerar a Marcacao Automatica para o Tipo de³
		³Marcacao em questao. Se o Tipo Nao Estiver Selecionado e a Di³
		³ferenca de Horas Entre o Tipo Selecionado e um Tipo  Imediata³
		³mente Anterior ou Posterior Que Tenha Sido Selecionado    for³
		³igual, tambem Gera a Marcacao Automatica. Pois Neste caso nao³
		³da Para Identificar a Quem Pertence a Marcacao Efetuada.     ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		IF ( "E" $ aTDia[ nPos , 3 ] )
			cTipMarc := StrZero( Val( SubStr( aTDia[ nPos , 3 ] , 1 , 1 ) ) - 1 , 1 ) + SubStr( aTDia[ nPos , 3 ] , -1 )
		ElseIF ( "S" $ aTDia[ nPos , 3 ] )
			cTipMarc := StrZero( Val( SubStr( aTDia[ nPos , 3 ] , 1 , 1 ) ) + 1 , 1 ) + SubStr( aTDia[ nPos , 3 ] , -1 )
		EndIF
	
		IF ( SubStr( cTipMarc , 1 , 1 ) + SubStr( cMarcAut , 2 , 1 ) ) $ cMarcAut
	
			IF ( "E" $ aTDia[ nPos , 3 ] )
	
				IF !Empty( aTab_Marc[ Max( 1 , nY - 1 ) , 2 ] ) .and. !Empty( aTDia[ Max( 1 , nPos - 1 ) ] )
				
					dDtMar := aTab_Marc[ Max( 1 , nY - 1 ) , 2 , 1 ]
					nHrMar := aTab_Marc[ Max( 1 , nY - 1 ) , 2 , 2 ]
		
					dDtTab := aTDia[ nPos , 1 ]
					nHrTab := aTDia[ nPos , 2 ]
					nHora1 := DataHora2Val( dDtTab , nHrTab , dDtMar , nHrMar , "H" )
		
					dDtTab := aTDia[ Max( 1 , nPos - 1 ) , 1 ]
					nHrTab := aTDia[ Max( 1 , nPos - 1 ) , 2 ]
					nHora2 := DataHora2Val( dDtTab , nHrTab , dDtMar , nHrMar , "H" )
				
				EndIF
	
			ElseIF ( "S" $ aTDia[ nPos , 3 ] )
	
				IF !Empty( aTab_Marc[ Min( nLenTma , nY  + 1 ) , 2 ] ) .and. !Empty( aTDia[ Min( nLenDia , nPos + 1 ) ] )
	
					dDtMar := aTab_Marc[ Min( nLenTma , nY  + 1 ) , 2 , 1 ]
					nHrMar := aTab_Marc[ Min( nLenTma , nY  + 1 ) , 2 , 2 ]
		
					dDtTab := aTDia[ nPos , 1 ]
					nHrTab := aTDia[ nPos , 2 ]
					nHora1 := DataHora2Str( dDtTab , nHrTab , dDtMar , nHrMar )
		
					dDtTab := aTDia[ Min( nLenDia , nPos + 1 ) , 1 ]
					nHrTab := aTDia[ Min( nLenDia , nPos + 1 ) , 2 ]
					nHora2 := DataHora2Str( dDtTab , nHrTab , dDtMar , nHrMar )
	
				EndIF	
		
			EndIF
	
			lRet := ( nHora1 == nHora2 )
	
		EndIF
	
	ElseIF ( lInverte )

		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Apenas Quando Existirem Marcacoes Efetivas 				  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		IF ( nLenMarcs := Len( aMDia ) ) > 0 
		
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Ajusta a Saida  ( Quando nao for a ultima )				  ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			For nY := 1 To nLenTma
	
				IF ( Empty( aTab_Marc[ nY , 02 ] ) .or. ( nY == nLenTma )  )
					Loop
				EndIF
				
				IF ( nPos := aScan( aTDia , { |x|	x[1] == aTab_Marc[ nY , 01 , 01 ] .and. ;
					   								x[2] == aTab_Marc[ nY , 01 , 02 ]		;
										    };
								   );
					) > 0 .and. aTDia[nPos,3] $ cMarcAut .and. SubStr( aTDia[nPos,3] , -1 ) == "S"
					
					/*/
					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					³ Se Marcacao de Encaixe for menor que marcacao da Tabela Zera³
					³ a Marcacao de Encaixe										  ³
					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
					IF Empty( aTab_Marc[ nY - 1 , 02 ] ) .and. ;
					   DataHora2Str(aTab_Marc[nY,02,01],aTab_Marc[nY,02,02]) < DataHora2Str(aTab_Marc[nY,01,01],aTab_Marc[nY,01,02])
						aTab_Marc[ nY - 1 , 02 ]	:= aClone( aTab_Marc[ nY , 02 ] )
						aTab_Marc[ nY , 02 ]		:= {}
						Exit
					Else
						Loop
					EndIF
	        	
	        	EndIF
			
			Next nY

			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Ajusta a Saida  ( Quando for a Ultima e Numero de  Marcacoes³
			³ da Tabela for igual a 2 )									  ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
            IF ( ( nLenTma == 2 ) .and. ( nLenMarcs == nLenTma ) )
            	IF ( Empty( aTab_Marc[ nLenTma , 02 ] ) .and. !Empty( aTab_Marc[ nLenTma - 1 , 02 ] ) )
            		aTab_Marc[ nLenTma , 02 ]		:= aClone( aTab_Marc[ nLenTma - 1 , 02 ] )
            		aTab_Marc[ nLenTma , 02 , 01 ]	:= aMDia[ nLenMarcs , 01 ]
            		aTab_Marc[ nLenTma , 02 , 02 ]	:= aMDia[ nLenMarcs , 02 ]
            	EndIF
            EndIF
	
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Ajusta a Entrada ( Quando nao for a Primeira ) 			  ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			For nY := 1 To nLenTma
	
				IF ( Empty( aTab_Marc[ nY , 02 ] ) .or. ( nY == 1 )  )
					Loop
				EndIF
				
				IF ( nPos := aScan( aTDia , { |x|	x[1] == aTab_Marc[ nY , 01 , 01 ] .and. ;
					   								x[2] == aTab_Marc[ nY , 01 , 02 ]		;
										    };
								   );
					) > 0 .and. aTDia[nPos,3] $ cMarcAut .and. SubStr( aTDia[nPos,3] , -1 ) == "E"
					
					/*/
					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					³ Se Marcacao de Encaixe for maior que marcacao da Tabela Zera³
					³ a Marcacao de Encaixe										  ³
					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
					IF DataHora2Str(aTab_Marc[nY,02,01],aTab_Marc[nY,02,02]) > DataHora2Str(aTab_Marc[nY,01,01],aTab_Marc[nY,01,02])
						/*/
						ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						³ Apenas Quando for formar Pares de Marcacoes ou Quando o Dia ³
						³ Nao For Trabalhado e Gerar Marcacoes para Dias Nao Trabalha ³
						³ dos ( lAutoSai ) ou Ainda Quando a Marcacao de Entrada  for ³
						³ a Ultima Marcacao do Dia.									  ³
						ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			    		IF ( nMarc := aScan( aMDia , { |x| x[1] == aTab_Marc[nY,02,01] .and. x[2] == aTab_Marc[nY,02,02] } ) ) > 0
					        IF ( ( nMarcs := ( nLenMarcs - ( nMarc + 1 ) ) % 2 ) > 0 .or. ( nMarc == nLenMarcs ) )
								IF ( nMarc == nLenMarcs )
									IF ( nY + 1 ) <= Len( aTab_Marc )
										aTab_Marc[ nY + 1 , 02 ]	:= aClone( aTab_Marc[ nY , 02 ] )
										aTab_Marc[ nY , 02 ]		:= {}
									EndIF
								Else
									aTab_Marc[ nY , 02 ] := {}
								EndIF
							ElseIF ( lAutoSai .and. ( aTDia[ nPos , 04 ] != "S" ) )
								IF ( nY + 1 ) <= Len( aTab_Marc )
									aTab_Marc[ nY + 1 , 02 ]	:= aClone( aTab_Marc[ nY , 02 ] )
									aTab_Marc[ nY , 02 ]		:= {}
								EndIF
							EndIF	
						EndIF	
						Exit
					/*/
					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					³Neste Caso a Marcacao foi Encaixada como Entrada de Intervalo³
					³Simula a Saida no Expediente para Poder Gerar a Saida do   In³
					³tervalo													  ³
					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
					ElseIF ( nY + 1 ) <= Len( aTab_Marc ) .and. Empty( aTab_Marc[ nY + 1 , 02 ] )
						aTab_Marc[ nY + 1 , 02 ] := aClone( aTab_Marc[ nY , 02 ] )
						Exit
					Else
						Loop
					EndIF
	        	
	        	EndIF
			
			Next nY
		
		EndIF
	
	EndIF
	
EndIF

Return( lRet )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³PonDestroyStatic³Autor³Marinaldo de Jesus ³ Data ³26/11/2001³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Reinicializar as Variaveis Staticas do SIGAPON    			³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³PonDestroyStatic( <aDestroy> )								³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³SIGAPON                                                     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL															³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³ aDestroy -> Pilha com as Funcoes que terao Statics Reinicia³
³          ³ 			 lizadas       									³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function PonDestroyStatic( aDestroy )

Begin Sequence

	DEFAULT aDestroy := {}
	IF ( Empty( aDestroy ) .or. ( ValType( aDestroy ) != "A" ) )
		aDestroy := Array( 21 )
		aDestroy[01] := "RstAponta()"
		aDestroy[02] := "RstfFeriado()"
		aDestroy[03] := "RstGetTabExtra()"
		aDestroy[04] := "RstGetTabArred()"
		aDestroy[05] := "SuperGetMv()"
		aDestroy[06] := "RstToScheduleOverTime()"
		aDestroy[07] := "RstTimeRemaining()"
		aDestroy[08] := "RstPosAlias()"
		aDestroy[09] := "ResetSqlName()"
		aDestroy[10] := "RstCalendCria()"
		aDestroy[11] := "RstCriaCalend()"
		aDestroy[12] := "RstTabPadrao()"
		aDestroy[13] := "RstEnchoVlds()"
		aDestroy[14] := "RstfEventos()"
		aDestroy[15] := "RstCheckSx9()"
		aDestroy[16] := "RstfCargaId()"
		aDestroy[17] := "RstMarcAuto()"
		aDestroy[18] := "RstExistField()"
		aDestroy[19] := "RstFilExistField()"
		aDestroy[20] := "RstGetCache()"
		aDestroy[21] := "RstGetAdsLckRec()"
		aEval( aDestroy , { |x| IF( !Empty(x) .and. FindFunction(x) , &(x) , NIL ) } )
	ElseIF ( ValType( aDestroy ) == "A" )
		aEval( aDestroy , { |x| IF( !Empty(x) .and. FindFunction(x) , IF( SubStr( ( x := StrTran( x ," ","") ) , -2 )!="()",&(x+"()"),&(x)) , NIL ) } )
	EndIF

	lRF0ChkTable := NIL //Verifica a Existencia do Arquivo de Pre-Abonos ( Nao devera constar em versoes Futuras )
	//Final do Bloco a ser excluido na para a fase 3

    //-- Descarta Variavel para uso em Query
	__cLimpaMotAbo := NIL
End Sequence
	
Return( NIL )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³GetPonMesDat    ³Autor³Marinaldo de Jesus ³ Data ³10/12/2001³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Retorna a Data Inicial e Final do Parametro MV_PONMES		³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³GetPonMes( @dPerIni , @dPerFim , cFil )						³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³SIGAPON                                                     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL															³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³dPerIni  -> Data Inicial do Periodo de Apontamento em Aberto³
³          ³dPerFim  -> Data Final   do Periodo de Apontamento em Aberto³
³          ³cFil     -> Filial para GetMv()								³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function GetPonMesDat( dPerIni , dPerFim , cFil )
         
Local cPonMes		:= ""
Local cPerAponta	:= ""
Local cSvFilAnt		:= cFilAnt
Local lRet			:= .T.

DEFAULT dPerIni		:= Ctod("//")
DEFAULT dPerFim		:= Ctod("//")
DEFAULT cFil		:= cSvFilAnt

If !(FunName() == "PONA290")
	cFilAnt := IF( !Empty( cFil ) , cFil , cFilAnt )
EndIf

Begin Sequence

	IF !( lRet := CheckModSPO() )
		Break
	EndIF
	
	IF Empty( cPonMes := GetPonMes( cFil ) )
		cPerAponta := GetPaponta( cFil )
		IF ( PerCompleto( cPerAponta ) )
	    	cPonMes := cPerAponta
    		PutMvFil( "MV_PONMES" , cPonMes , cFilAnt )
	    EndIF
	EndIF

	IF !( lRet := !Empty( dPerIni := Stod( Left( cPonMes , 08 ) ) ) )
		Break
	EndIF
	
	IF !( lRet := !Empty( dPerFim := Stod( Right( cPonMes , 08 ) ) ) )
		Break
    EndIF

	IF !( lRet := MaxP8PGOrdVld( dPerIni , dPerFim ) )
		Break
	EndIF

End Sequence

cFilAnt := cSvFilAnt

Return( lRet )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³ValidPonData    ³Autor³Marinaldo de Jesus ³ Data ³10/12/2001³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Valida as Datas Digitadas nos Lancamentos do SIGAPON		³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³SIGAPON                                                     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL															³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³< Vide Parametros Formais 									³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function ValidPonData(	dData		,;	//01 -> Data a Ser Validada
						cTipValid	,;	//02 -> Tipo da Validacao "G" - GetDados (Periodo) ; "P" - Validar o MV_PONMES
						dPerIni		,;	//03 -> Periodo Inicial
						dPerFim		,;	//04 -> Periodo Final
						lAcumulado	,;	//05 -> Se Informacao de Arquivo Acumulado
						lShowHelp	,;  //06 -> Mostrar ou Nao o Help
						cFil		 ;	//07 -> Filial para PerAponta
					  )

Local cHelp	:= ""
Local lRet	:= .T.

DEFAULT dData		:= Ctod("//")
DEFAULT cTipValid	:= "G"
DEFAULT dPerIni 	:= Ctod("//")
DEFAULT dPerFim		:= Ctod("//")
DEFAULT lAcumulado	:= .F.
DEFAULT lShowHelp	:= .T.
DEFAULT cFil		:= cFilAnt

cTipValid := Upper( AllTrim( cTipValid ) )

Begin Sequence

	IF ( Empty( dPerIni ) .or. Empty( dPerFim ) )
		IF !( lRet := PerAponta( @dPerIni , @dPerFim , NIL , lShowHelp , cFil ) )
			Break
		EndIF
	EndIF

	IF ( cTipValid == "G" )
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Nao Podem Haver Lancamentos Fora do Periodo em Aberto		   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		IF ( ( dData < dPerIni ) .or. ( dData > dPerFim ) )
			lRet := .F.
			cHelp += ( OemToAnsi( STR0108 ) + Space(50) + Chr(13) )								//'A Data Informada e Invalida.'
			cHelp += OemToAnsi( STR0106 )														//'Per¡odo em Aberto: '
			cHelp += ( Dtoc( dPerIni ) + STR0104 +  Dtoc( dPerFim )  ) + Space(50) + Chr(13)	//' a '
			cHelp += Space(50) + Chr(13)
			cHelp += Space(50) + Chr(13)
		EndIF
		Break
	EndIF

	IF ( cTipValid == "P" )
		IF ( lAcumulado )
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Nao Podem Haver Lancamentos para Periodos Posteriores ao Peri³
			³ odo de Apontamento em Aberto.						   		   ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			lRet := !( dData >= dPerIni )
			cHelp += ( OemToAnsi( STR0105 ) + Space(50) + Chr(13) )								//'N„o Podem Haver Lan‡amentos Acumulados'
			cHelp += ( OemToAnsi( STR0107 ) + Space(50) + Chr(13) )								//'Para Este Per¡odo: '
			cHelp += OemToAnsi( STR0106 )														//'Per¡odo em Aberto: '
			cHelp += ( Dtoc( dPerIni ) + STR0104 +  Dtoc( dPerFim )  ) + Space(50) + Chr(13)	//' a '
			cHelp += Space(50) + Chr(13)
			cHelp += Space(50) + Chr(13)
		Else
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Nao Podem Haver Lancamentos para Periodo Anteriores ao  Perio³
			³ do de Apontamento em Aberto.							   	   ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			lRet := !( dData < dPerIni )
			cHelp += ( OemToAnsi( STR0102 ) + Space(50) + Chr(13) )								//'N„o Podem Haver Lan‡amentos para Per¡odo'
			cHelp += ( OemToAnsi( STR0103 ) + Space(50) + Chr(13) )								//'Posterior ao Periodo em Aberto: '
			cHelp += OemToAnsi( STR0106 )														//'Per¡odo em Aberto: '
			cHelp += ( Dtoc( dPerIni ) + STR0104 +  Dtoc( dPerFim )  ) + Space(50) + Chr(13)	//' a '
		EndIF	
		Break
	EndIF
	
End Sequence
	
IF ( !( lRet ) .and. ( lShowHelp ) )
	IF !Empty( cHelp )
		Help( " " , 1 , "NOVALIDPER" , , cHelp , 1 , 0 )
	EndIF	
EndIF

Return( lRet )

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³DescPdPon ³ Autor ³ Equipe Advanced RH    ³ Data ³23/02/1995³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Retorna a Descricao do Codigo de Provento / Desconto       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Function DescPdPon( cEvento , cFil , nBytes )

Local cRet		:= ""
Local nSvOrder	:= SP9->( IndexOrd() )
Local nOrder	:= RetOrdem( "SP9" , "P9_FILIAL+P9_CODIGO" )

DEFAULT nBytes := 20

IF ( nBytes > 20 )
	nBytes := 20
EndIF

cFil := xFilial( "SP9" , cFil )

IF !( nOrder == nSvOrder )
	SP9->( dbSetOrder( nOrder ) )
EndIF
	
IF !Empty(cEvento) .AND. (SP9->(MsSeek(cFil+cEvento)) )
	cRet := Left( SP9->P9_DESC + Space( nBytes ) , nBytes )
Else
	cRet := Left( STR0001 + Space( nBytes ) , nBytes ) // '** Nao Cadastrado **'
EndIF

SP9->( dbSetOrder( nSvOrder ) )

Return( cRet )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³ShowTipoDia ³ Autor ³Marinaldo de Jesus    ³ Data ³19/07/2002³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Validar a multipla escolha de tipo de Dia              		 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³ShowTipoDia( cTipo , l1Elem )								 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³                                                     		 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³.T.                                                  	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Apontamento                                                  ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function ShowTipoDia( cTipoDia , l1Elem , lDisplay )

Local aTpDia		:= {}
Local aOpc			:= {}
Local cTitulo		:= ""
Local cMvParDef		:= ""
Local cMvPar		:= ""
Local nTpDia		:= 0
Local nTpDias		:= 0
Local nPosTpDia		:= 0
Local uRet			:= NIL

DEFAULT cTipoDia	:= "CDFNS"
DEFAULT l1Elem		:= .F.
DEFAULT lDisplay	:= .T.

aAdd( aTpDia , { "C" , STR0109	} )	//"Compensado"
aAdd( aTpDia , { "D" , STR0110	} )	//"DSR"
aAdd( aTpDia , { "F" , STR0111	} )	//"Feriado"
aAdd( aTpDia , { "N" , STR0112	} )	//"Nao Trabalhado"
aAdd( aTpDia , { "S" , STR0113 	} )	//"Trabalhado"

IF ( lDisplay )  

	CursorWait()

	    cMvPar				:= &( Alltrim( ReadVar() ) )
		cTipoDia			:= Upper( AllTrim( cTipoDia ) )
		l1Elem				:= IF( ValType( l1Elem ) != "L" , .F. , l1Elem )
		MvRet				:= Alltrim( ReadVar() )

		nTpDias := Len( cTipoDia )
		For nTpDia := 1 To nTpDias
			IF ( nPosTpDia := aScan( aTpDia , { |x| x[1] == SubStr( cTipoDia , nTpDia , 1 ) } ) ) > 0
				cMvParDef += aTpDia[ nPosTpDia , 01 ]
				aAdd( aOpc , aTpDia[ nPosTpDia , 01 ] += ( "-" + aTpDia[ nPosTpDia , 02 ] ) )
			EndIF
		Next nX

	CursorArrow()

	IF ( uRet := ( cMvPar != NIL ) )
		IF f_Opcoes(@cMvPar,cTitulo,aOpc,cMvParDef,12,49,l1Elem,1)
			&(MvRet) := cMvPar
		EndIF	
	EndIF

Else

	IF ( nPosTpDia := aScan( aTpDia , { |x| x[1] == cTipoDia } ) ) > 0
		uRet := aTpDia[ nPosTpDia , 02 ]
	EndIF

EndIF
	
Return( uRet )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³ValidPerSPO ³ Autor ³Marinaldo de Jesus    ³ Data ³29/07/2002³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Validar as Datas no Cadastro de Periodos de Apontamento		 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais >									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais >									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³lRet                                                 	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico                                                     ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function ValidPerSPO(	cFil		,;	//Filial de Referencia Para Pesquisa no SPO
						dPerIni 	,;	//Periodo Inicial para Valiadacao
						dPerFim		,;	//Periodo Final Para Validacao
						lNotInclui	,;	//Quando Inclui nao Estiver Definido, qual sera o seu valor
						lShowHelp	,;	//Se deve Mostrar Help
						aPeriodos	,;	//Periodos que foram carregados
						lValidPer	 ;	//Se deve validar os Periodos
					)

Local aAreaSPO		:= SPO->( GetArea() )
Local cAlias		:= "SPO"
Local lRet			:= .T.

Local dPoDataIni
Local dPoDataFim
Local dFirstDate
Local dLastDate
Local nRecno

DEFAULT dPerIni		:= IF( IsMemVar("PO_DATAINI") , GetMemVar( "PO_DATAINI" ) , Ctod("//") )
DEFAULT dPerFim		:= IF( IsMemVar("PO_DATAFIM") , GetMemVar( "PO_DATAFIM" ) , Ctod("//") )
DEFAULT lNotInclui	:= .F.
DEFAULT lShowHelp	:= .T.
DEFAULT lValidPer	:= .T.

aPeriodos := {}

Begin Sequence

	IF !( lRet := MaxP8PGOrdVld( dPerIni , dPerFim , lShowHelp ) )
		Break
	EndIF

	Inclui	:= IF( ( Type( "Inclui" ) == "U" ) , lNotInclui , Inclui )
	cFil	:= xFilial( cAlias , cFil )

	SPO->( dbSetOrder( RetOrdem( "SPO" , "PO_FILIAL+DTOS(PO_DATAINI)" ) ) )
	SPO->(dbGoTop())
	IF ( cAlias )->( dbSeek( cFil , .F. ) )
		While ( cAlias )->( !Eof() .and. PO_FILIAL == cFil )
			IF IF( Inclui , Inclui , !( nRecno := ( cAlias )->( Recno() ) == aAreaSPO[ 3 ] ) )
				dPoDataIni	:= ( cAlias )->(PO_DATAINI)
				IF Empty( dFirstDate )
					dFirstDate	:= dPoDataIni
				EndIF
				dPoDataFim	:= ( cAlias )->(PO_DATAFIM) //carrega a data fim do periodo
				dLastDate	:= dPoDataFim
				IF ( lValidPer )
					IF ConflictDate( dPerIni , dPerFim , dPoDataIni , dPoDataFim )
						lRet := .F.
						Break
					EndIF
				EndIF
				aAdd( aPeriodos , { dPoDataIni , dPoDataFim , nRecno } )
			EndIF
			( cAlias )->( dbSkip() )
		End While
	EndIF
End Sequence

IF ( ( lShowHelp ) .and. !( lRet ) )
	Help(" ",1,"PONA290PER")
EndIF

Return( lRet )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o	   ³PutPerSPO	  ³Autor³ Marinaldo de Jesus  ³ Data ³09/08/2002³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Gravar Periodo de Apontamento na Tabela de Periodos de  Apon³
³          ³Tamento														³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais> 									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>                                   ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso	   ³ Generico 												    ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function PutPerSPO( cFil , dPerIni , dPerFim , cFlag , cRespon )

Local aArea		:= GetArea()
Local cAlias	:= "SPO"
Local lRet		:= .F.

DEFAULT cFil	:= ""
DEFAULT dPerIni	:= Ctod("//")
DEFAULT dPerFim	:= Ctod("//")
DEFAULT cFlag	:= "0"
DEFAULT cRespon	:= "S"

IF !( cFlag $ "01" )
	cFlag := "0"
EndIF

IF !( cRespon $ "US" )
	cRespon := "U"
EndIF

IF (lRet := ValidPerSPO( @cFil, dPerIni, dPerFim, .T., .F., , .T. ))
	IF ( lRet := ( cAlias )->( RecLock( cAlias , .T. , .F. ) ) )
		( cAlias )->( PO_FILIAL ) := cFil
		( cAlias )->( PO_DATAINI ):= dPerIni
		( cAlias )->( PO_DATAFIM ):= dPerFim
		( cAlias )->( PO_FLAGFEC ):= cFlag
		( cAlias )->( PO_RESPONS ):= cRespon
		( cAlias )->( MsUnLock() )
	EndIF
EndIF

RestArea( aArea )

Return( lRet )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o	   ³RetPerSPO	  ³Autor³ Marinaldo de Jesus  ³ Data ³29/08/2002³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Retornar Periodos de Apontamento do SPO                     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais> 									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>                                   ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso	   ³ Generico 												    ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function RetPerSPO( cFil )

Local aArea		:= GetArea()
Local aAreaSPO	:= SPO->( GetArea() )
Local aPerSPO	:= {}

cFil := xFilial( "SPO" , cFil )

SPO->( dbSeek( cFil ) )

While SPO->( !Eof() .and. cFil == PO_FILIAL )
	SPO->( aAdd( aPerSPO , { PO_DATAINI , PO_DATAFIM } ) , dbSkip() )
End While

( RestArea( aAreaSPO ) , RestArea( aArea ) )

Return( aPerSPO )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o	   ³CheckModSPO   ³Autor³ Marinaldo de Jesus  ³ Data ³09/08/2002³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Verifica o Modo de Acesso do SPO e,se nao for compartilhado,³
³          ³Duplica os Parametros MV_PONMES e MV_PAPONTA				³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais> 									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>                                   ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso	   ³ Generico 												    ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function CheckModSPO()

Local aArea		:= GetArea()
Local aAreaSMO	:= SM0->( GetArea() )
Local lRet		:= .T.

Static lPrimVez := .T.

Begin Sequence

	IF !lPrimVez .Or. ( lRet := Empty( xFilial( "SPO" ) ) )
		Break
	EndIF
	
	If lPrimVez
		lPrimVez := .F.
	EndIf

	IF ( lRet := SM0->( dbSeek( cEmpAnt , .F. ) ) )
		While SM0->( !Eof() .and. M0_CODIGO == cEmpAnt )
			IF ( lRet := DuplicaMv(FWGETCODFILIAL, "MV_PONMES" ) )
				IF !( lRet := DuplicaMv(FWGETCODFILIAL, "MV_PAPONTA" ) )
					lPrimVez := .T.
					Break
				EndIF
			Else
				lPrimVez := .T.
				Break
			EndIF
			SM0->( dbSkip() )
		End While
	EndIF

End Sequence

IF !( lRet )
	Help( "" , 1 , "NOEXISTMVS" )
EndIF

( RestArea(  aAreaSMO ) , RestArea(  aArea ) )

Return( lRet )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o	   ³PerApoConPad  ³Autor³ Marinaldo de Jesus  ³ Data ³12/08/2002³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Monta Consulta Padrao para o Periodo de Apontamento  baseada³
³          ³no SPO                                      				³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais> 									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<void>                                                      ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso	   ³Generico 												    ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function PerApoConPad()
Return( ConPad1( NIL , NIL , NIL , "SPO" , NIL , NIL , .F. ) ) 

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o	   ³PutPerMvPar	  ³Autor³ Marinaldo de Jesus  ³ Data ³26/08/2002³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Carregar o Periodo de Apontamento nas Variaveis dos   Parame³
³          ³tros                                        				³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais> 									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais> 									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso	   ³Generico 												    ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function PutPerMvPar(cParGroup, cParDt1, cParDt2)
Local lRet			:= .T.
Local lConPad		:= .T.
Local cMvPar1		:= ""
Local cMvPar2		:= ""
Local oSX1			:= FWSX1Util():New()

DEFAULT cParGroup	:= ""
DEFAULT cParDt1		:= ""
DEFAULT cParDt2 	:= ""

If !Empty(cParGroup) .And. !Empty(cParDt1) .And. !Empty(cParDt2) .And. (lConPad := PerApoConPad())
	oSX1:AddGroup(cParGroup)
	oSX1:SearchGroup()

	cMvPar1 := "mv_par" + cParDt1
	cMvPar2 := "mv_par" + cParDt2

	If Len(oSX1:aGrupo) > 0 .And. Len(oSX1:aGrupo[1][2]) > 0
		If aScan(oSX1:aGrupo[1, 2], {|x| AllTrim(Lower(x:CX1_VAR01)) == cMvPar1 .And. x:CX1_TIPO == "D"}) > 0
			SetMVValue(cParGroup, cMvPar1, SPO->PO_DATAINI,.T.)
		EndIf
		If aScan(oSX1:aGrupo[1, 2], {|x| AllTrim(Lower(x:CX1_VAR01)) == cMvPar2 .And. x:CX1_TIPO == "D"}) > 0
			SetMVValue(cParGroup, cMvPar2, SPO->PO_DATAFIM,.T.)
		EndIf
		
	EndIf
EndIf
Return( lRet )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o	   ³PonRetOpcBox  ³Autor³ Marinaldo de Jesus  ³ Data ³10/09/2002³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Retornar as Opcoes para o X3_BOX                            ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³#PonRetOpcBox( nOpcBox )									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais> 									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso	   ³SX3->X3_BOX   												³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function PonRetOpcBox( nOpcBox )

Local cOpcBox	:= ""

DEFAULT nOpcBox	:= 0

IF ( nOpcBox == 01 )
	If cPaisLoc == "RUS"
		cOpcBox += ( "S=" + STR0113 + ";"	)	//"Trabalhado"
	    cOpcBox += ( "N=" + STR0112	     	)	//"Nao Trabalhado"
	Else
		cOpcBox += ( "S=" + STR0113 + ";"	)	//"Trabalhado"
	    cOpcBox += ( "C=" + STR0109	+ ";"	)	//"Compensado"
	    cOpcBox	+= ( "D=" + STR0110 + ";"	)	//"D.S.R"
	    cOpcBox += ( "N=" + STR0112	     	)	//"Nao Trabalhado"
	EndIf
ElseIF ( nOpcBox == 02 )
	cOpcBox += ( "S=" + STR0113 + ";"	)	//"Trabalhado"
	cOpcBox += ( "C=" + STR0109	+ ";"	)	//"Compensado"
	cOpcBox	+= ( "D=" + STR0110 + ";"	)	//"D.S.R"
	cOpcBox += ( "N=" + STR0112	+ ";"	)	//"Nao Trabalhado"
	cOpcBox += ( "F=" + STR0111	   		)	//"Feriado"	
ElseIF ( nOpcBox == 03 )
	cOpcBox += ( "1=" + STR0120 + ";"	)	//"Normal"
	cOpcBox += ( "2=" + STR0110	+ ";"	)	//"D.S.R"
	cOpcBox	+= ( "3=" + STR0109 + ";"	)	//"Compensada"
	cOpcBox += ( "4=" + STR0111	+ ";"	)	//"Feriado"
	cOpcBox += ( "5=" + STR0121	+ ";"	)	//"Noturna Normal"
	cOpcBox += ( "6=" + STR0122	+ ";"	)	//"Noturna D.S.R"
	cOpcBox += ( "7=" + STR0123	+ ";"	)	//"Noturna Compensada"
	cOpcBox += ( "8=" + STR0124	     	)	//"Noturna Feriado"
ElseIF ( nOpcBox == 04 )
	cOpcBox += ( "1=" + STR0120 + ";"	)	//"Normal"
	cOpcBox += ( "2=" + STR0110	+ ";"	)	//"D.S.R"
	cOpcBox	+= ( "3=" + STR0109 + ";"	)	//"Compensada"
	cOpcBox += ( "4=" + STR0111	+ ";"	)	//"Feriado"
	cOpcBox += ( "5=" + STR0121	+ ";"	)	//"Noturna Normal"
	cOpcBox += ( "6=" + STR0122	+ ";"	)	//"Noturna D.S.R"
	cOpcBox += ( "7=" + STR0123	+ ";"	)	//"Noturna Compensada"
	cOpcBox += ( "8=" + STR0124	+ ";"  	)	//"Noturna Feriado"
	cOpcBox += ( "A=" + STR0078	+ ";"	)	//"Intervalo Normal"
	cOpcBox += ( "B=" + STR0079	+ ";"   )	//"Intervalo Noturna"
	cOpcBox += ( "C=" + STR0195	+ ";"   )	//"Intervalo DSR"
	cOpcBox += ( "D=" + STR0196	+ ";"   )	//"Intervalo Noturna DSR"
	cOpcBox += ( "E=" + STR0197	+ ";"   )	//"Intervalo Compensado"
	cOpcBox += ( "F=" + STR0198	+ ";"   )	//"Intervalo Noturna Compensado"
	cOpcBox += ( "G=" + STR0199	+ ";"   )	//"Intervalo Feriado"
	cOpcBox += ( "H=" + STR0200         )	//"Intervalo Noturna Feriado"
ElseIF ( nOpcBox == 05 )
	cOpcBox += ( "S=" + STR0125 + ";"	)	//'Sim'
	cOpcBox += ( "N=" + STR0126      	)	//'Nao'
ElseIF ( nOpcBox == 06 )
	cOpcBox += ( "1E=" + STR0080 + ";"	)	//'1a. Entrada'
	cOpcBox += ( "1S=" + STR0081 + ";"	)	//'1a. Saida  '
	cOpcBox += ( "2E=" + STR0082 + ";"	)	//'2a. Entrada'
	cOpcBox += ( "2S=" + STR0083 + ";"	)	//'2a. Saida  '
	cOpcBox += ( "3E=" + STR0084 + ";"	)	//'3a. Entrada'
	cOpcBox += ( "3S=" + STR0085 + ";"	)	//'3a. Saida  '
	cOpcBox += ( "4E=" + STR0086 + ";"	)	//'4a. Entrada'
	cOpcBox += ( "4S=" + STR0087 + ";"	)	//'4a. Saida  '
	cOpcBox += ( "5E=" + STR0245 + ";"	)	//'5a. Entrada'
	cOpcBox += ( "5S=" + STR0246 + ";"	)	//'5a. Saida  '
	cOpcBox += ( "6E=" + STR0247 + ";"	)	//'6a. Entrada'
	cOpcBox += ( "6S=" + STR0248		)	//'6a. Saida  '
ElseIF ( nOpcBox == 07 )
	 cOpcBox += ( "1I=" + STR0088 + ";"	)	//'1o. Intervalo '
	 cOpcBox += ( "2I=" + STR0089 + ";"	)	//'2o. Intervalo '
	 cOpcBox += ( "3I=" + STR0090       )	//'3o. Intervalo '
ElseIF ( nOpcBox == 08 )
	 cOpcBox += ( "S=" + STR0125 + ";"	)	//'Sim'
	 cOpcBox += ( "N=" + STR0126 + ";" 	)	//'Nao'
	 cOpcBox += ( "D=" + STR0110 + ";"	)	//"D.S.R"
	 cOpcBox += ( "C=" + STR0109      	)	//"Compensado"
ElseIF ( nOpcBox == 09 )
	 cOpcBox += ( "T=" + STR0127 + ";"	)	//"Total"
	 cOpcBox += ( "P=" + STR0128      	)	//"Parcial"
ElseIF ( nOpcBox == 10 )
	 cOpcBox += ( "1=" + STR0129 + ";"	)	//"Provento"
	 cOpcBox += ( "2=" + STR0130 + ";"	)	//"Desconto"
	 cOpcBox += ( "3=" + STR0131      	)	//"Base"
ElseIF ( nOpcBox == 11 )
	 cOpcBox += ( "S=" + STR0132 + ";"	)	//"Semanal"
	 cOpcBox += ( "Q=" + STR0133 + ";"	)	//"Quinzenal"
	 cOpcBox += ( "M=" + STR0134      	)	//"Mensal"
ElseIF ( nOpcBox == 12 )
	 cOpcBox += ( "D=" + STR0135 + ";"	)	//"Diario"	 
	 cOpcBox += ( "S=" + STR0132 + ";"	)	//"Semanal"
	 cOpcBox += ( "Q=" + STR0133 + ";"	)	//"Quinzenal"
	 cOpcBox += ( "M=" + STR0134      	)	//"Mensal"
ElseIF ( nOpcBox == 13 )
	 cOpcBox += ( "A=" + STR0136 + ";"	)	//"Anterior"	 
	 cOpcBox += ( "P=" + STR0137 + ";"	)	//"Posteior"
	 cOpcBox += ( "T=" + STR0138		)	//"Todos"
ElseIF ( nOpcBox == 14 )
	 cOpcBox += ( "H=" + STR0139 + ";"	)	//"Horas"	 
	 cOpcBox += ( "V=" + STR0140 + ";"	)	//"Valor"
	 cOpcBox += ( "D=" + STR0141		)	//"Dias"
ElseIF ( nOpcBox == 15 )
	 cOpcBox += ( "A=" + STR0142 + ";"	)	//"Atrasos"	 
	 cOpcBox += ( "S=" + STR0143 + ";"	)	//"Saidas Antecipadas"
	 cOpcBox += ( "H=" + STR0144 + ";"	)	//"Horas Extras"
	 cOpcBox += ( "D=" + STR0145 + ";"	)	//"Descanso Semanal Remunerado"
	 cOpcBox += ( "F=" + STR0146 + ";"	)	//"Faltas"
	 cOpcBox += ( "N=" + STR0147 + ";"	)	//"Adicional Noturno"
	 cOpcBox += ( "9=" + STR0148      	)	//"Nona Hora"
ElseIF ( nOpcBox == 16 )
	 cOpcBox += ( "0=" + STR0149 + ";"	)	//"Fechado"
	 cOpcBox += ( "1=" + STR0150      	)	//"Aberto"
ElseIF ( nOpcBox == 17 )
	 cOpcBox += ( "S=" + STR0151 + ";"	)	//"Sistema"
	 cOpcBox += ( "U=" + STR0152     	)	//"Usuario"
ElseIF ( nOpcBox == 18 )
	 cOpcBox += ( "1=" + STR0129 + ";"	)	//"Provento"
	 cOpcBox += ( "2=" + STR0130 + ";"	)	//"Desconto"
	 cOpcBox += ( "3=" + STR0216 + ";"	)	//"Base ( Provento )"
	 cOpcBox += ( "4=" + STR0217        )	//"Base ( Desconto )"
EndIF

Return( cOpcBox )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³MaxP8PGOrdVld	³Autor³Marinaldo de Jesus ³ Data ³24/01/2003³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Validar o Numero de Ordens possiveis para o SP8 e SPG confor³
³          ³me Periodo de Apontamento									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico													³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function MaxP8PGOrdVld( dPerIni , dPerFim , lShowHelp , nOrdens )
         
Local cMsg			:= ""
Local lOrdensOk		:= .F.
Local nDias			:= 0

DEFAULT dPerIni		:= Ctod("//")
DEFAULT dPerFim		:= Ctod("//")
DEFAULT lShowHelp	:= .T.

nDias 	:= ( ( dPerFim - dPerIni ) + 1 )
nOrdens	:= Val( Replicate( "9" , __nTamP8Ordem ) )
Begin Sequence
	IF !( lOrdensOk := ( nDias <= nOrdens ) )
		cMsg := STR0160 //"O numero de dias do periodo ultrapassou o numero de ordens permitidas para o SP8"
		Break
	EndIF
	nOrdens	:= Val( Replicate( "9" , __nTamPGOrdem ) )
	IF !( lOrdensOk := ( nDias <= nOrdens ) )
		cMsg := STR0161 //"O numero de dias do periodo ultrapassou o numero de ordens permitidas para o SPG"
		Break
	EndIF
End Sequence	

IF ( lShowHelp )
	IF ( !( lOrdensOk ) .and. !Empty( cMsg ) )
		cMsg += CRLF
		cMsg += STR0162 + AllTrim( Str( nDias ) )	//'Numero de dias do Periodo:'
	 	cMsg += CRLF
	 	cMsg += STR0163 + AllTrim( Str( nOrdens ) )	//'Numero Maximo de Ordens:
		MsgInfo( OemToAnsi( cMsg ) , OemToAnsi( STR0159 ) ) //"Aten‡„o!"
	EndIF
EndIF

Return( lOrdensOk  )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³PonIncDate		³Autor³Marinaldo de Jesus ³ Data ³28/01/2003³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Incrementa Periodo de Acordo com os dias do Periodo Anterior³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico													³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function PonIncDate( dPerIni , dPerFim  )

Local dDateAux
Local nDias

DEFAULT dPerIni	:= Ctod("//")
DEFAULT dPerFim	:= Ctod("//")

IF ( dPerFim < dPerIni )
	dDateAux	:= dPerIni
	dPerIni		:= dPerFim
	dPerFim		:= dDateAux
EndIF

nDias		:= ( dPerFim - dPerIni )
dPerIni 	:= ( dPerFim + 1  )
dPerFim 	:= ( dPerIni + nDias )

Return( nDias )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³PonDecDate		³Autor³Marinaldo de Jesus ³ Data ³22/01/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Decrementa Periodo de Acordo com os dias do Periodo Anterior³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico													³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function PonDecDate( dPerIni , dPerFim  )

Local dDateAux
Local nDias

DEFAULT dPerIni	:= Ctod("//")
DEFAULT dPerFim	:= Ctod("//")

IF ( dPerFim < dPerIni )
	dDateAux	:= dPerIni
	dPerIni		:= dPerFim
	dPerFim		:= dDateAux
EndIF

nDias		:= ( dPerFim - dPerIni )
dPerFim 	:= ( dPerIni - 1 )
dPerIni 	:= ( dPerFim - nDias )

Return( nDias )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³PonDelRecnos	³Autor³Marinaldo de Jesus ³ Data ³12/03/2003³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Deletar Registros conforme Alias e Array aRecnos            ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico													³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function PonDelRecnos(	cAlias			,;	//01 -> Alias
						aRecnos 		,;	//02 -> Array com os Recnos
						bCondDele		,;	//03 -> Bloco com a Condicao para Delecao
						uParbCondDele	,;	//04 -> Parametro para o Bloco 
						aMsMmCpos		,;	//05 -> Array com os campos Memo para Delecao
						cAliasMsMm		 ;	//06 -> Alias para a MsMm
					)
Return(DelRecnos(@cAlias,@aRecnos,@bCondDele,@uParbCondDele,@aMsMmCpos,@cAliasMsMm))

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³PonModPer	³ Autor ³Marinaldo de Jesus    ³ Data ³06/09/2002³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Possibilitar a Alteracao do parametro MV_PERAPONTA e a  conse³
³          ³sequente atualizacao do MV_PONMES							 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL															 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico													 ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function PonModPer( lModPer , cFil )

DEFAULT lModPer := .T.

IF ( lModPer )
	lModPer := PonActModPer( cFil )
EndIF

Return( MbrChgLoop( .F. ) )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³PonActModPer³ Autor ³Marinaldo de Jesus    ³ Data ³06/09/2002³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Possibilitar a Alteracao do parametro MV_PERAPONTA e a  conse³
³          ³sequente atualizacao do MV_PONMES							 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL															 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³SIGAPON     												 ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function PonActModPer( cFil )

Local aSvKeys		:= GetKeys()
Local bSet15		:= { || NIL }
Local bSet24		:= { || NIL }
Local cAntDiaIniFim	:= Space( 05 )
Local cAtuDiaIniFim	:= Space( 05 )
Local cNewPerPutMv	:= ""
Local cSvFilAnt		:= cFilAnt
Local cMsgPaponta	:= ""
Local dAntIniPer	:= Ctod("//")
Local dAntFimPer	:= Ctod("//")
Local dAtuIniPer	:= Ctod("//")
Local dAtuFimPer	:= Ctod("//")
Local dIniPonMes	:= Ctod("//")
Local dFimPonMes	:= Ctod("//")
Local lModPerOk		:= .F.
Local lModPonMes	:= .F.
Local lPapontaPer	:= .F.
Local lVisualizar	:= .F.
Local nOpcModPer	:= 0
Local oDlg 			:= NIL
Local oFont			:= NIL
Local oGroup1		:= NIL
Local oGroup2		:= NIL
Local oGroup3		:= NIL

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Declaração de arrays para dimensionar tela                   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Local aAdvSize		:= {}
Local aInfoAdvSize	:= {}
Local aObjSize		:= {}
Local aObjCoords	:= {}

Local aAdv1Size		:= {}
Local aInfo1AdvSize	:= {}
Local aObj1Size		:= {}
Local aObj1Coords	:= {}

Local aAdv2Size		:= {}
Local aInfo2AdvSize	:= {}
Local aObj2Size		:= {}
Local aObj2Coords	:= {}

Local aAdv3Size		:= {}
Local aInfo3AdvSize	:= {}
Local aObj3Size		:= {}
Local aObj3Coords	:= {}

DEFAULT cFil		:= cSvFilAnt

cFilAnt := IF( !Empty( cFil ) , cFil , cFilAnt )
       
IF !( Type( "Inclui" ) == "L" )
	Inclui := .F.
EndIF

IF !( Type( "cCadastro" ) == "C" )
	Private cCadastro := ""
EndIF

IF !( ( nOpcModPer := PonOpcModPer() ) == 0 )

	cAntDiaIniFim := GetPaponta( cFil )

	GetPonMesDat( @dIniPonMes , @dFimPonMes , cFilAnt )

	lModPonMes	:= ( nOpcModPer == 2 )
	lVisualizar	:= ( nOpcModPer == 3 )

	IF ( lPapontaPer := PerCompleto( cAntDiaIniFim ) )
		dAntIniPer		:= Stod( Left(	cAntDiaIniFim , 08 ) )
		dAntFimPer		:= Stod( Right( cAntDiaIniFim , 08 ) )
		cAntDiaIniFim	:= Space( 05 )
	Else
		cAntDiaIniFim	:= Left( cAntDiaIniFim, 02 ) + '/' + Right( cAntDiaIniFim , 02 )
	EndIF
	
	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Monta as Dimensoes dos Objetos         					   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	aAdvSize		:= MsAdvSize( ,.T.,380)
	aInfoAdvSize	:= { aAdvSize[1] , aAdvSize[2] , aAdvSize[3] , aAdvSize[4] , 5 , 5 }					 
	aAdd( aObjCoords , { 000 , 035 , .T. , .F. } )			//1-Periodo Anterior
	aAdd( aObjCoords , { 000 , 035 , .T. , .F. } )			//2-Novo Periodo
	aAdd( aObjCoords , { 000 , 035 , .T. , .F. } )			//3-Periodo Atual
	aObjSize	:= MsObjSize( aInfoAdvSize , aObjCoords )
	
	//Divisao 1. linha - Periodo Anterior
	aObj1Coords := {}
	aAdv1Size    := aClone(aObjSize[1])

	aInfo1AdvSize    := { aAdv1Size[2] , aAdv1Size[1] , aAdv1Size[4] , aAdv1Size[3] , 15 , 15 }
	aAdd( aObj1Coords , { 000 , 000 , .T. , .T. } )
	aAdd( aObj1Coords , { 000 , 000 , .T. , .T. } )
	aAdd( aObj1Coords , { 000 , 000 , .T. , .T. } )
	aAdd( aObj1Coords , { 000 , 000 , .T. , .T. } )
	aObj1Size := MsObjSize( aInfo1AdvSize , aObj1Coords,,.T.)
	
	//Divisao 2. linha - Novo Periodo
	aObj2Coords := {}
	aAdv2Size    := aClone(aObjSize[2])
	
	aInfo2AdvSize    := { aAdv2Size[2] , aAdv2Size[1] , aAdv2Size[4] , aAdv2Size[3] , 15 , 15 }
	aAdd( aObj2Coords , { 000 , 000 , .T. , .T. } )
	aAdd( aObj2Coords , { 000 , 000 , .T. , .T. } )
	aAdd( aObj2Coords , { 000 , 000 , .T. , .T. } )
	aAdd( aObj2Coords , { 000 , 000 , .T. , .T. } )
	aObj2Size := MsObjSize( aInfo2AdvSize , aObj2Coords,,.T.)
	
	
	//Divisao 3. linha - Periodo Atual
	aObj3Coords := {}
	aAdv3Size    := aClone(aObjSize[3])
	
	aInfo3AdvSize    := { aAdv3Size[2] , aAdv3Size[1] , aAdv3Size[4] , aAdv3Size[3] , 15 , 15 }
	aAdd( aObj3Coords , { 000 , 000 , .T. , .T. } )
	aAdd( aObj3Coords , { 000 , 000 , .T. , .T. } )
	aAdd( aObj3Coords , { 000 , 000 , .T. , .T. } )
	aAdd( aObj3Coords , { 000 , 000 , .T. , .T. } )
	aObj3Size := MsObjSize( aInfo3AdvSize , aObj3Coords,,.T.)
	
	DEFINE FONT oFont NAME "Arial" SIZE 0,-11 BOLD
	DEFINE MSDIALOG oDlg TITLE OemToAnsi( cCadastro + " - " + STR0167 ) From aAdvSize[7],0 TO aAdvSize[6]-20 ,aAdvSize[5] OF GetWndDefault() PIXEL	//"Modificar Periodo de Apontamento"

		If lVisualizar
			@ aObjSize[1,1] , aObjSize[1,2]	GROUP oGroup1 TO aObjSize[1,3] , aObjSize[1,4] LABEL OemToAnsi(STR0218) OF oDlg PIXEL		//""Periodo Atual do Parametro MV_PAPONTA"
			oGroup1:oFont:=oFont
		Else
			@ aObjSize[1,1] , aObjSize[1,2]	GROUP oGroup1 TO aObjSize[1,3] , aObjSize[1,4] LABEL OemToAnsi(STR0168) OF oDlg PIXEL		//""Periodo Anterior do Parametro MV_PAPONTA"
			oGroup1:oFont:=oFont
		EndIf
	
		IF !( lPapontaPer )
			@ aObj1Size[1,1] , aObj1Size[1,2] SAY OemToAnsi( STR0164 )	SIZE	100,10 OF oDlg PIXEL FONT oFont	//"Dia Inicial/Final"
			@ aObj1Size[2,1] , aObj1Size[2,2] GET cAntDiaIniFim		SIZE	50,10 OF oDlg PIXEL FONT oFont WHEN ( .F. ) PICTURE "99/99" 
	    Else
			@ aObj1Size[1,1], aObj1Size[1,2] SAY OemToAnsi( STR0165 )	SIZE	100,10 OF oDlg PIXEL FONT oFont	//"Anterior"
			@ aObj1Size[2,1], aObj1Size[2,2] GET dAntIniPer			SIZE	50,10 OF oDlg PIXEL FONT oFont	WHEN ( .F. )
			@ aObj1Size[3,1], aObj1Size[3,2] GET dAntFimPer			SIZE	50,10 OF oDlg PIXEL FONT oFont	WHEN ( .F. )
	    EndIF
	    
		IF !( lVisualizar )

			IF !( lModPonMes )
				@ aObjSize[2,1] , aObjSize[2,2]	GROUP oGroup2 TO aObjSize[2,3] , aObjSize[2,4] LABEL OemToAnsi(STR0169) OF oDlg PIXEL		//"Novo Periodo para o Parametro MV_PAPONTA"
			Else
			@ aObjSize[2,1] , aObjSize[2,2]	GROUP oGroup2 TO aObjSize[2,3] , aObjSize[2,4] LABEL OemToAnsi(STR0235) OF oDlg PIXEL		//"Novo Periodo para o Parametro MV_PONMES"			
			EndIf
			oGroup2:oFont:=oFont
		
			IF !( lModPonMes )
				@ aObj2Size[1,1] , aObj2Size[1,2] SAY OemToAnsi( STR0164 )	SIZE	100,10 OF oDlg PIXEL FONT oFont	//"Dia Inicial/Final"
				@ aObj2Size[2,1] , aObj2Size[2,2] GET cAtuDiaIniFim		SIZE	50,10 OF oDlg PIXEL FONT oFont	WHEN( IF( !( lModPonMes ) , IF( lVisualizar , !( lVisualizar ) , !( lModPonMes ) ) , .F. ) ) PICTURE "99/99"
			Else
				@ aObj2Size[1,1] , aObj2Size[1,2] SAY OemToAnsi( STR0165 )	SIZE	100,10 OF oDlg PIXEL FONT oFont	//"Periodo"
				@ aObj2Size[2,1] , aObj2Size[2,2] GET dAtuIniPer			SIZE	50,10 OF oDlg PIXEL FONT oFont	WHEN( IF( lModPonMes , IF( lVisualizar , !( lVisualizar ) , lModPonMes ) , .F. ) )	
				@ aObj2Size[3,1] , aObj2Size[3,2] GET dAtuFimPer			SIZE	50,10 OF oDlg PIXEL FONT oFont	WHEN( IF( lModPonMes , IF( lVisualizar , !( lVisualizar ) , lModPonMes ) , .F. ) )	
			EndIF
        Else
       		aObjSize[3]	:=	aClone(aObjSize[2])
       		aObj3Size	:=	aClone(aObj2Size)
       		
		
		EndIF
	
		@ aObjSize[3,1] , aObjSize[3,2] GROUP oGroup3 TO aObjSize[3,3] , aObjSize[3,4] LABEL OemToAnsi(STR0178) OF oDlg PIXEL			//"Periodo Atual do parametro MV_PONMES"
		oGroup3:oFont:=oFont

  		@ aObj3Size[1,1] , aObj3Size[1,2]	GET dIniPonMes	SIZE	50,10 OF oDlg PIXEL FONT oFont	WHEN( .F. )	 
		@ aObj3Size[2,1] , aObj3Size[2,2]	GET dFimPonMes	SIZE	50,10 OF oDlg PIXEL FONT oFont	WHEN( .F. )	 
			
		IF ( lVisualizar )
			bSet15	:= { || oDlg:End() }
		Else
			bSet15	:= { || IF( lModPerOk := PonOkModPer( StrTran( cAtuDiaIniFim , "/" , "" ) , dAtuIniPer , dAtuFimPer , lModPonMes ) , oDlg:End() , lModPerOk ) }
		EndIF
		bSet24		:= { || oDlg:End() }
	
	ACTIVATE MSDIALOG oDlg CENTERED ON INIT EnchoiceBar( oDlg , bSet15 , bSet24  ) 
	
	IF ( ( lModPerOk ) .and. !( lVisualizar ) )
	    IF ( lModPonMes )
			cNewPerPutMv := ( Dtos( dAtuIniPer ) + "/" + Dtos( dAtuFimPer ) )
			PutMvFil( "MV_PAPONTA"	, cNewPerPutMv  , cFilAnt )
			PutMvFil( "MV_PONMES"	, cNewPerPutMv  , cFilAnt )
		Else
			cNewPerPutMv := cAtuDiaIniFim
			PutMvFil( "MV_PAPONTA"	, cNewPerPutMv  , cFilAnt )
			PutMvFil( "MV_PONMES"	, "" , cFilAnt )
			lModPerOk := CheckPonMes( @dAtuIniPer , @dAtuFimPer , .F. , .F. , .T. , cFilAnt , .F. , NIL )
			If lModPerOk
				
				cMsgPaponta := MsgPaponta( cNewPerPutMv, dAtuIniPer, dAtuFimPer, cFilAnt )
				
		    	If !Empty(cMsgPaponta) //Caso exista inconsistencia, retorna parametros aos valores antigos
					PutMvFil( "MV_PAPONTA"	, cAntDiaIniFim  , cFilAnt )
					PutMvFil( "MV_PONMES" , "" , cFilAnt )
					CheckPonMes( @dAntIniPer , @dAntFimPer , .F. , .F. , .F. , cFilAnt , .F. , NIL )
					cMsgPaponta += CRLF + CRLF + STR0228 
				EndIf
			Else
				PutMvFil( "MV_PAPONTA", cAntDiaIniFim, cFilAnt )
				PutMvFil( "MV_PONMES", "", cFilAnt )
			EndIF
		EndIF
		If lModPerOk
			//"Caso as Marcações já tenham sido apontadas, será necessário forçar o Reapontamento para ajustá-las ao novo período."
			If Empty( cMsgPaponta )
				cMsgPaponta := ( Dtoc( dAtuIniPer ) + " - " + Dtoc( dAtuFimPer ) + CRLF + CRLF + STR0177 )
				MsgInfo( OemToAnsi( cMsgPaponta ) , OemToAnsi( STR0176 ) )	//"Novo Periodo do Ponto em Aberto"
			Else
				cMsgPaponta := ( Dtoc( dAtuIniPer ) + " - " + Dtoc( dAtuFimPer ) + CRLF + CRLF + cMsgPaponta )
				MsgInfo( OemToAnsi( cMsgPaponta ) , OemToAnsi( STR0229 ) )	//"Configuração Incorreta do Pe´riodo"
			EndIf
		EndIf
	EndIF
	
	IF ( Type( "Inclui" ) == "L" )
		Inclui := .F.
	EndIF

EndIF

RestKeys( aSvKeys , .T. )

cFilAnt := cSvFilAnt

Return( lModPerOk )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o	   ³PonOpcModPer 	³Autor³Marinaldo de Jesus ³ Data ³04/03/2002³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Dialogo com as Opcoes para Modificacao do Periodo 			³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³PonOpcModPer()												³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³ 															³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³Numero da Opcao da Mudanca do Periodo:1 -> Dia Inicial/Final³
³          ³                                      2 -> Periodo          ³
³          ³                                      3 -> Visualizar		³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso	   ³PonModPer()											    	³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function PonOpcModPer()

Local aSvKeys		:= GetKeys()
Local bSet15		:= { || lOpcOk := .T. , RestKeys( aSvKeys , .T. ) ,  oDlg:End() }
Local bSet24		:= { || RestKeys( aSvKeys , .T. ) , oDlg:End() }
Local nOpcModPer	:= 1
Local lOpcOk		:= .F.
Local oRadio		:= NIL
Local oDlg			:= NIL
Local oGroup		:= NIL
Local oFont			:= NIL

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Declaração de arrays para dimensionar tela		                         ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Local aAdvSize		:= {}
Local aInfoAdvSize	:= {}
Local aObjSize		:= {}
Local aObjCoords	:= {}

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Monta as Dimensoes dos Objetos         					   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
aAdvSize		:= MsAdvSize(,.T.,70)
aInfoAdvSize	:= { aAdvSize[1] , aAdvSize[2] , aAdvSize[3] , aAdvSize[4] , 10, 10 }					 
aAdd( aObjCoords , { 0 , 50 , .T. , .F. } )
aObjSize	:= MsObjSize( aInfoAdvSize , aObjCoords )

DEFINE FONT oFont NAME "Arial" SIZE 0,-11 BOLD
DEFINE MSDIALOG oDlg FROM  aAdvSize[7],0 TO (aAdvSize[6]-30),(aAdvSize[5]) TITLE OemToAnsi( STR0167 ) OF GetWndDefault() PIXEL	//"Modificar Periodo de Apontamento"

	@ aObjSize[1,1],aObjSize[1,2]	GROUP oGroup TO aObjSize[1,3],(aObjSize[1,4]/1.30) LABEL OemToAnsi(STR0166) OF oDlg PIXEL	//"Escolha a Op‡„o para a Modifica‡„o do Parametro:"
	oGroup:oFont:=oFont
	
	@ aObjSize[1,1]+10,aObjSize[1,2]+10	RADIO oRadio VAR nOpcModPer ITEMS 	OemToAnsi(STR0164)	,;			//"Dia Inicial/Final"
										   			OemToAnsi(STR0165)	,;			//"Periodo"
										   			OemToAnsi(STR0179)	 ;			//'Apenas Visualizar'
				SIZE 115,010 OF oDlg PIXEL
	
	oDlg:lEscClose := .F. //Nao permite sair ao se pressionar a tecla ESC.	

ACTIVATE MSDIALOG oDlg CENTERED ON INIT EnchoiceBar( oDlg , bSet15 , bSet24 )

RestKeys( aSvKeys , .T. )

IF !( lOpcOk )
	nOpcModPer := 0
EndIF

Return( nOpcModPer )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o	   ³PonOkModPer  	³Autor³Marinaldo de Jesus ³ Data ³04/03/2002³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Validar o Novo Periodo de Apontamento             			³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³PonOkModPer()												³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso	   ³PonModPer()											    	³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function PonOkModPer( cPeriodo, dPerIni, dPerFim, lPeriodo, lShowHelp )

Local cMsg			:= ""
Local lOK			:= .F.

Default lShowHelp := .T.

Begin Sequence

	IF ( lPeriodo )
		IF !( lOk := ( !Empty( dPerIni ) .and. !Empty( dPerFim ) ) )
			cMsg := STR0173	// "Data Inicial ou Data Final em Branco"
			Break
		EndIF
		IF !( lOk := ( dPerFim >= dPerIni ) )
			cMsg := STR0172 //"Data Inicial maior que Data Final"
			Break
		EndIF
		IF !( lOk := MaxP8PGOrdVld( dPerIni , dPerFim ) )
			cMsg := ""
			Break
		EndIF
		IF !( lOk := ValidPerSPO( cFilAnt , dPerIni , dPerFim , .T. , .F. ) )
			cMsg := STR0171 // "Não é possível selecionar um período já existente no cadastro de períodos (Tabela SPO). Verifique o período informado."
			Break
		EndIF
	Else
		IF !( lOk := ( !Empty( cPeriodo ) ) )
			cMsg := STR0170	//"O Periodo nao pode ficar em Branco"
			Break
		EndIF
	EndIF

End Sequence

IF lShowHelp .And. ( !( lOk ) .and. !Empty( cMsg ) )
	MsgInfo( OemToAnsi( cMsg ) , OemToAnsi( STR0174 + " - " + STR0175  ) ) //"Aten‡„o!"###"Existem Inconsistencias a serem verificadas."
EndIF

Return( lOk )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o	   ³MsgPaponta  	³Autor³Marinaldo de Jesus ³ Data ³01/07/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Verifica se Existe Alguma Inconsistencia no preenchimento do³
³          ³MV_PAPONTA e Emite Mensagem correspondente				    ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<vide parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso	   ³PonModPer()											    	³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function MsgPaponta( cPerAponta , dAtuIniPer , dAtuFimPer , cFil )

Local cMsgPaponta	:= ""
Local lMaisDias		:= .F.

Local cMsgIniPer
Local cMsgFimPer
Local cMesAux
Local cAnoAux
Local dDataAux
Local nDiaAux
Local nMesAux
Local nAnoAux
Local nUltDiaMes
Local nDiaIni
Local nDiaFim
Local nIniDif
Local nFimDif

Begin Sequence

	IF PerCompleto( @cPerAponta , cFil )
		Break
	EndIF

	IF !PapontaOk( cPerAponta , NIL , NIL , cFil )
		Help( "" , 1 , "PERNCAD" )
		Break
	EndIF

	nDiaIni := Day( dAtuIniPer )
	nDiaFim := Day( dAtuFimPer )

	IF ( AnoMes( dAtuIniPer ) == AnoMes( dAtuFimPer ) )

 		IF ( nDiaIni > 1 )
			nIniDif := ( nDiaIni - 1 )
			IF ( nIniDif > 0 )
				cMsgIniPer	:= Day2Str( nIniDif )
				cMsgIniPer	+= " "
				cMsgIniPer	+= STR0210	//"dia(s), no Inicio do período,"
			EndIF
		EndIF

 		nUltDiaMes := f_UltDia( Ctod( "01/" + Month2Str( dAtuFimPer ) + "/" + Year2Str( dAtuFimPer ) , "DDMMYYYY" ) )
 		IF ( nDiaFim < nUltDiaMes )
			nFimDif := ( nUltDiaMes - nDiaFim )
			IF ( nFimDif > 0 )
				IF !Empty( cMsgIniPer )
					cMsgIniPer += " "
					cMsgIniPer += STR0211 //"e"
					cMsgIniPer += " "
				EndIF
				cMsgFimPer := Day2Str( nFimDif )
				cMsgFimPer += " "
				cMsgFimPer += STR0212	//"dia(s), no Final do período,"
			EndIF
		EndIF

 		Break

 	EndIF

	IF ( nDiaIni > nDiaFim )

		nFimDif := ( ( nDiaIni - nDiaFim ) - 1 )
		IF ( nFimDif > 0 )
			cMsgFimPer := Day2Str( nFimDif )
			cMsgFimPer += " "
			cMsgFimPer += STR0212	//"dia(s), no Final do período,"
		EndIF
		
		Break

	EndIF

	IF ( nDiaIni < nDiaFim )

		nUltDiaMes	:= f_UltDia( Ctod( "01/" + Month2Str( dAtuIniPer ) + "/" + Year2Str( dAtuIniPer ) , "DDMMYYYY" ) )
		nIniDif		:= ( ( nUltDiaMes - nDiaIni ) + 1 )
		nFimDif		:= nDiaFim
		IF ( lMaisDias := ( ( nIniDif + nFimDif ) > nUltDiaMes ) )
			nFimDif := ( ( nIniDif + nFimDif ) - nUltDiaMes )
			cMsgFimPer := STR0214 //"mais"
			cMsgFimPer += " "
			cMsgFimPer += Day2Str( nFimDif )
			cMsgFimPer += " "
			cMsgFimPer += STR0212	//"dia(s), no Final do período,"
			Break
		EndIF

		nDiaAux		:= ( nDiaIni - 1 )
		nMesAux		:= ( Month( dAtuFimPer ) + 1 )
		nAnoAux		:= Year( dAtuFimPer )
		IF ( nMesAux > 12 )
			nMesAux := 1
			++nAnoAux
		EndIF
		cMesAux		:= Month2Str( nMesAux )
		cAnoAux		:= Year2Str( nAnoAux )
		dDataAux	:= Ctod( Day2Str( nDiaAux ) + "/" + cMesAux + "/" + cAnoAux , "DDMMYYYY" )
		While Empty( dDataAux )
			dDataAux := Ctod( Day2Str( --nDiaAux ) + "/" + cMesAux + "/" + cAnoAux , "DDMMYYYY" )
		End While
		nUltDiaMes	:= f_UltDia( Ctod( "01/" + Month2Str( dAtuFimPer ) + "/" + Year2Str( dAtuFimPer ) , "DDMMYYYY" ) )
		nFimDif		:= ( nUltDiaMes - nDiaFim )
		nFimDif		+= Day( dDataAux )
		IF ( nFimDif > 0 )
			cMsgFimPer := Day2Str( nFimDif )
			cMsgFimPer += " "
			cMsgFimPer += STR0212	//"dia(s), no Final do período,"
		EndIF
		
		Break

	EndIF

End Sequence

IF !Empty( cMsgIniPer ) .or. !Empty( cMsgFimPer )
	cMsgPaponta := STR0209	//"A Configuração Atual do MV_PAPONTA fará com que"
	cMsgPaponta += " "
	IF !Empty( cMsgIniPer )
		cMsgPaponta += cMsgIniPer
	EndIF	
	IF !Empty( cMsgFimPer )
		cMsgPaponta += cMsgFimPer
	EndIF	
	cMsgPaponta += " "
	IF !( lMaisDias )
		cMsgPaponta += STR0213	//"seja(m) desconsiderado(s) pelo sistema."
	Else
		cMsgPaponta += STR0215	//"seja(m) considerados(s) pelo sistema."
	EndIF	
	cMsgPaponta := ( STR0208 + CRLF + CRLF + cMsgPaponta ) //"Atenção!!!!"
EndIF	

Return( cMsgPaponta )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³InitP8PgOrdSize³Autor³Marinaldo de Jesus   ³ Data ³03/06/2002³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Inicializa as Statics __nTamP8PgOrdSize e __nTamP8PgOrdSize  ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL                                                  	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico 													 ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function InitP8PgOrdSize(nOpc)

Local nTam

DEFAULT nOpc := 1

IF ( Select("SX3") > 0 )
	IF ( nOpc == 1 )
		nTam := GetSx3Cache( "P8_ORDEM" , "X3_TAMANHO" )
	Else
		nTam := GetSx3Cache( "PG_ORDEM" , "X3_TAMANHO" )
	EndIF
EndIF
DEFAULT nTam := 2

Return( nTam )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o	   ³PonLockRegs		³Autor³Marinaldo de Jesus ³ Data ³11/06/2003³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Tentativa de Lock em Varios Registros             			³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³lLocked                  									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso	   ³Generico   											    	³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function PonLockRegs(	cAlias			,;	//01 -> Alias onde os Registros devera haver Lock dos Registros
						aRegsLock		,;	//02 -> Array com os Recnos para Lock
						aKeysCode		,;	//03 -> Array com as Chaves para MayIUseCode
						nTentaLocks		,;	//04 -> Numero de Tentativas de Lock
						nSecondsWait	,;	//05 -> Segundos a aguardar para nova tentativa
						lMayIUseCode	,;	//06 -> Se ira utilizar MayIUseCode
						nMaxLocks		 ;	//07 -> Numero maximo de Locks
					)
Return(LockRegsCode(@cAlias,@aRegsLock,@aKeysCode,@nTentaLocks,@nSecondsWait,@lMayIUseCode,@nMaxLocks))

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o	   ³PonFreeLocks    ³Autor³Marinaldo de Jesus ³ Data ³11/06/2003³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Chamada da FreeLocks                                        ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL                        									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso	   ³Generico   											    	³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function PonFreeLocks( cAlias , nReg , lFreeUseCode , cUseCode )
Return( FreeLocks( cAlias , nReg , lFreeUseCode , cUseCode ) )
/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o	   ³fDemissao       ³Autor³Mauricio MR        ³ Data ³27/01/2005³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Verifica a Situacao de Demissao do Funcionario              ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL                        									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso	   ³SIGAPON   											    	³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function fDemissao(cSituacao, cRescRais)
Local cRet    
If cRescRais$'30/31'
	cRet:= 'T'
Else 
	cRet:= cSituacao
Endif   
Return( cRet )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³fVerTabRF0   ³Autor ³Mauricio MR          ³ Data ³05/10/05  ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Verifica a Existencia da tabela de Pre-abonos e se a mesma  ³
³          ³possui registros.                                           ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³< Vide Parametros Formais >								  	³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³< Vide Parametros Formais >								  	³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function  fVerTabRF0()
Local lRet		:= .F.
Local lVazio	:= .T.

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Verifica a Existencia da Tabela RF0 e se a mesma  ³
³possui conteudo. Somente nessas condicoes sera	   ³
³verficada a existencia de pre-abonos.			   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
lRet:= Sx2ChkTable( "RF0",, @lVazio) 	

lRet:= ( lRet .AND. !lVazio)

If cPaisLoc == "BRA" .And. SR6->(!Eof()) .And. SR6->R6_HRINTER > 0 //sempre deixa ligado esta 
	lRet := .T.
EndIf

Return ( lRet )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³Port1510     ³Autor ³Leandro Drumond      ³ Data ³02/10/09  ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Verifica se Portaria 1510/2009 esta em vigor.               ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³< Vide Parametros Formais >								  	³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³< Vide Parametros Formais >								  	³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function Port1510()
Local lRet := .F.

If DPORT1510 == "25/11/09" .and. cPaisLoc == "BRA"
	lRet := .T.
EndIf

Return lRet

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³fVerBasePort ³Autor ³Leandro Drumond      ³ Data ³02/10/09  ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Verifica se Base foi adequada a Portaria 1510/2009.         ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³< Vide Parametros Formais >								  	³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³< Vide Parametros Formais >								  	³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function fVerBasePort(lShowHelp)

Return (cPaisLoc == "BRA")

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³fGetMotivo  ³ Autor ³ Leandro Drumond     ³ Data ³ 05/10/09 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Monta dialogo para inclusao de motivo de desconsideracao   ³±±
±±³			 ³ ou inclusao de marcacao.                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Manutencoes                                                ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±*/
Function fGetMotivo( cMotivo, cHelp, nOpc, cCodMot )

Local cTitJan := ""
Local lRet    := .F.
Local oDlg
Local oGroup
Local oFont
Local oMotivo
Local aSvKeys		:= GetKeys()

Local bSet15
Local bSet24
Local aButtons := {}

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Declaração de arrays para dimensionar tela		                         ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Local oSize			:= Nil

Local bTeclaALT_R := SetKey( K_ALT_R		, NIL )  

SetKey( VK_F3  , {||NIL}  )
SetKey( K_ALT_R ,{||NIL}  ) 

cMotivo := fInitMotivo( xFilial("RFD"), "1" , Alltrim(Str(nOpc)) )
cCodMot := fInitCodMot( xFilial("RFD"), "2" , Alltrim(Str(nOpc)) )

M->P8_MOTIVRG:= cMotivo
M->RFD_CODIGO:= cCodMot

cHelp   := ""

If nOpc == 1  //Inclusao
	cTitJan := OemToAnsi(STR0222)  //"Motivo de inclusão"
ElseIf nOpc == 2 .or. nOpc == 3//Exclusao
	cTitJan := OemTOAnsi(STR0221)  //"Motivo para desconsideração"
EndIf

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Monta as Dimensoes dos Objetos         					   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
oSize := FwDefSize():New()             
oSize:AddObject( "CABECALHO",(oSize:aWindSize[3]*1.1),130 , .F., .F. ) // Não dimensionavel
oSize:aMargins 	:= { 0, 0, 0, 0 } // Espaco ao lado dos objetos 0, entre eles 3		
oSize:lProp 	:= .F. // Proporcional             
oSize:Process() 	   // Dispara os calculos   	

DEFINE FONT oFont NAME "Arial" SIZE 0,-11 BOLD
DEFINE MSDIALOG oDlg FROM  0,0 TO 130,(oSize:aWindSize[3]*1.1) TITLE OemToAnsi(cTitJan) PIXEL

bSet15 := {|| lRet := .T., oDlg:End()}
bSet24 := {|| lRet := .F., oDlg:End()}

@ oSize:GetDimension("CABECALHO","LININI")+3,oSize:GetDimension("CABECALHO","COLINI")+3 GROUP oGroup TO oSize:GetDimension("CABECALHO","LINEND") * 0.39 ,( oSize:GetDimension("CABECALHO","COLEND") * 0.5 ) OF oDlg PIXEL

@ oSize:GetDimension("CABECALHO","LININI")+10,oSize:GetDimension("CABECALHO","COLINI")+15 MSGET oMotivo Var M->P8_MOTIVRG PICTURE GetSx3Cache( "P8_MOTIVRG", "X3_PICTURE" ) F3 "RFD";
						VALID (  PVldCpoOK(M->P8_MOTIVRG,," ") .And. !Empty( M->P8_MOTIVRG ) .And. fValCodRFD( xFilial("RFD"), M->P8_MOTIVRG ) );
						WHEN .T. SIZE oSize:aWindSize[3]*0.52,10 OF oDlg PIXEL HASBUTTON
@0,0 BUTTON oBtnConfirm PROMPT "" SIZE 00,00 PIXEL ACTION Eval({|| iif(fValEnter(@lRet),oDlg:End(),Nil) })
                                                                     
ACTIVATE MSDIALOG oDlg ON INIT EnchoiceBar( oDlg , bSet15 , bSet24 , Nil , aButtons ) CENTERED

//Se cancelou, limpa cMotivo
If !(lRet)
	M->P8_MOTIVRG := ""
	If nOpc == 1 //Inclusao
		cHelp := Space(01) + OEMTOANSI(STR0225) + CRLF //"Para inclusão de nova marcação"
		cHelp += Space(01) + OEMTOANSI(STR0226) + CRLF //"é necessário informar um motivo."
	ElseIf nOpc == 2 //Exclusao
		cHelp := Space(01) + OEMTOANSI(STR0223) + CRLF //"Para que a marcação seja desconsiderada"
		cHelp += Space(01) + OEMTOANSI(STR0226) + CRLF //"é necessário informar um motivo."
	ElseIf nOpc == 3 //Exclusao em lote
		cHelp := Space(01) + OEMTOANSI(STR0224) + CRLF //"Para que as marcações sejam desconsiderada"
		cHelp += Space(01) + OEMTOANSI(STR0226) + CRLF //"é necessário informar um motivo."
	EndIf	
EndIf

cMotivo:= M->P8_MOTIVRG
RestKeys( aSvKeys , .T. )
SetKey( K_ALT_R		, bTeclaALT_R )

Return( lRet )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³fInitMotivo ³ Autor ³ Leandro Drumond     ³ Data ³ 07/10/09 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Busca motivo padrao da tabela RFD de acordo com o indice   ³±±
±±³			 ³ Sera exibido o primeiro motivo                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Manutencoes                                                ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±*/
Function fInitMotivo( cFil, cAplic , cTipo )
Local aArea	  := GetArea()
Local cMotivo := Space(GetSx3Cache( "RFD_DESC"	, "X3_TAMANHO" ))

DEFAULT cFil   := xFilial("RFD")
DEFAULT cAplic := "1"
DEFAULT cTipo  := "0"

DbSelectArea("RFD")

RFD->( dbSetOrder( 02 ) )

If RFD->( dbSeek( cFil+cAplic+cTipo , .F.  ) )
	cMotivo := Padr( RFD->RFD_DESC , GetSx3Cache( "RFD_DESC"	, "X3_TAMANHO" ) )
EndIf

RestArea(aArea)

Return (cMotivo)        

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³fInitCodMot ³ Autor ³ Bianca C. Lima      ³ Data ³ 07/10/09 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Busca cod. motivo padrao da tabela RFD de acordo c/indice  ³±±
±±³			 ³ 								                              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Manutencoes                                                ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±*/
Function fInitCodMot( cFil, cAplic , cTipo )
Local aArea	  := GetArea()
Local cCodMot := Space(GetSx3Cache( "RFD_CODIGO"	, "X3_TAMANHO" ))

DEFAULT cFil   := xFilial("RFD")
DEFAULT cAplic := "1"
DEFAULT cTipo  := "0"

DbSelectArea("RFD")

RFD->( dbSetOrder( 02 ) )

If RFD->( dbSeek( cFil+cAplic+cTipo , .F.  ) )
	cCodMot := Padr( RFD->RFD_CODIGO , GetSx3Cache( "RFD_CODIGO"	, "X3_TAMANHO" ) )
EndIf

RestArea(aArea)

Return (cCodMot)

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³fValCodRFD	 ³ Autor ³Igor Franzoi		   ³ Data ³29/06/2010³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Envia mensagem ao usuario em caso de codigo numerico digitado³
³		   ³e o mesmo nao existir na tabela RFD							 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³fValCodRFD( cCodPes ) 										 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³uRet                                                 	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico 													 ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function fValCodRFD( cFilPes, cCodPes )

Local lRet		:= .T.

Local cCodAux	:= GetSx3Cache( "RFD_CODIGO" , "X3_TAMANHO" )
Local cAlias	:= "RFD"

Local aArea	:= GetArea()

DEFAULT	cCodPes	:= ""

If !Empty(cCodPes)

	cCodAux := SubStr( AllTrim(cCodPes),1,2 )
	
	If Empty(SubStr(cCodPes,3,3))
		
		dbSelectArea(cAlias)
		(cAlias)->( dbSetOrder( RetOrdem( "RFD","RFD_FILIAL+RFD_CODIGO+RFD_APLIC+RFD_TIPO" ) ) )
		
		If ( (cAlias)->(dbSeek( cFilPes+cCodAux )) )
			//STR0230 = "Existe Motivo de Manutenção com o código informado:"
			//STR0231 = "Deseja utilizá-lo?"
			//STR0208 = "Atenção"			
			If MsgNoYes( OemToAnsi( STR0230 ) +" "+AllTrim(cCodAux)+"!"+CRLF+OemToAnsi( STR0231 ),;
						 OemToAnsi( STR0208 ) ) 
				M->P8_MOTIVRG := (cAlias)->(RFD_DESC)
			EndIf
		EndIf
	
	EndIf
		
EndIf

RestArea(aArea)

Return lRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³fPortTit    ³ Autor ³ Leandro Drumond     ³ Data ³ 24/11/09 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Complementa titulo das telas com dizeres referentes a      ³±±
±±³			 ³ Portaria 1510/2009.                                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ GENERICO                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±*/
Function fPortTit()
Local cTitulo := OEMTOANSI(STR0227) //' - SREP - Portaria 1510/2009 de 21.08.2009'
Return cTitulo                                     

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³PVldCpoOK	  ³ Autor ³Ricardo Berti 	    ³ Data ³26/09/2011³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Retira caracteres especiais/invalidos de um campo		  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ PVldCpoOK( cCpo , cLstChar , cNewChar )				 	  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ cCpo 	- variavel para retirar carac. especiais		  ³±±
±±³          ³ cLstChar - lista de caracteres especiais		 			  ³±±
±±³          ³ cNewChar - Caracter p/substituir os especiais/Default=vazio³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ .T.			 			 							 	  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
*/
Function PVldCpoOK( cCpo , cLstChar , cNewChar )
Local nTamCpo
Local nX		 := 0

DEFAULT	cCpo	 := ""
DEFAULT	cLstChar := "`'@#$%¨&*()_+={}[]~^?!/\;:><|" + '"'
DEFAULT	cNewChar := ""

If !Empty(cCpo)

	nTamCpo := Len(cCpo)

	For nX:=1 To Len(cLstChar)
        While SubsTr(cLstChar,nX,1) $ cCpo
			cCpo := StrTran( cCpo , SubsTr(cLstChar,nX,1) , cNewChar )
		EndDo
	Next                
	
	If Len(cCpo) < nTamCpo
		cCpo += Replicate(" ", nTamCpo - Len(Ccpo) )
    EndIf

	If AllTrim(ReadVar()) == "M->P8_MOTIVRG"
		M->P8_MOTIVRG:= cCpo
	EndIf

EndIf

Return (.T.)


/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³fApoSaida	  ³ Autor ³Renan Borges	    ³ Data ³17/01/2017³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Retira caracteres especiais/invalidos de um campo		  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ PVldCpoOK( cCpo , cLstChar , cNewChar )				 	  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ cCpo 	- variavel para retirar carac. especiais		  ³±±
±±³          ³ cLstChar - lista de caracteres especiais		 			  ³±±
±±³          ³ cNewChar - Caracter p/substituir os especiais/Default=vazio³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ .T.			 			 							 	  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
*/
Function fApoSaida(aTabCalend, nUltPos, aTabTno, nPos)
Local nX
Local aMarcId	 	:= { NIL , NIL }
Local nSerial

If aTabCalend[nUltPos,CALEND_POS_HORA] < aTabCalend[n1EPos,CALEND_POS_HORA]
	For nX := n1EPos to nUltPos
		--aTabCalend[nX,CALEND_POS_DATA]		
	Next nX
	
		nSerial		:= ( __fDhToNS( aTabCalend[n1EPos,CALEND_POS_DATA] , aTabTno[ nPos , 1 ] ) - __fDhToNS( NIL , aTabTno[ nPos , 30 ] ) )
		aMarcId[1]	:= __fNsToDh( nSerial , "D" )
		aMarcId[2]	:= __fNsToDh( nSerial , "H" )

		aTabCalend[	n1EPos	,	CALEND_POS_LIM_MARCACAO		] := aClone( aMarcId )
	
		nSerial		:= ( __fDhToNS( aTabCalend[ nUltPos , CALEND_POS_DATA ] , aTabCalend[ nUltPos , CALEND_POS_HORA ] ) + __fDhToNS( NIL ,aTabTno[ nPos , 31] ) )
		aMarcId[1]	:= __fNsToDh( nSerial , "D" )
		aMarcId[2]	:= __fNsToDh( nSerial , "H" )

		aTabCalend[	nUltPos	,	CALEND_POS_LIM_MARCACAO	] := aClone( aMarcId )
EndIf

Return (.T.)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³fTemSuspGS  ³ Autor ³Flavio S. COrrea	    ³ Data ³20/09/2016³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Verifica se tem suspensao								  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
*/
Function fTemSuspGS(cFilMat, cMat, cData)
	
	Local aArea		:= GetArea()
	Local lRet 		:= .F.
	Local dDData    := STOD(cData)
	
	dbSelectArea("TIT")
	dbSetOrder(3)
	
	If TIT->(dbSeek(cFilMat + cMat))
		While( TIT->TIT_FILIAL + TIT_MAT == cFilMat + cMat)
			If TIT->TIT_AFASTA = "1" .And. TIT->TIT_DATA <= dDData .And. dDData <= DaySum(TIT->TIT_DATA, TIT->TIT_QTDDIA -1 )
				lRet := .T.
				EXIT
			EndIf
			TIT->(dbSkip())
		EndDo
	EndIf
	
	RestArea(aArea)
	
Return lRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³fAltTpMarc  ³ Autor ³Marco N. Nakazawa    ³ Data ³09/08/2019³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Ordena e preenche o campo P8_TPMARCA 					  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
*/
Function fAltTpMarc (aMarcacoes)
Local nI

If !Empty(aMarcacoes)
	For nI:=1  To Len(aMarcacoes)
		If nI == 1
			nPosApo := 1
		    aMarcacoes[ nI , AMARC_TIPOMARC ] := cValToChar(nPosApo)+"E"
		    cTpApo := "S"
		ElseIf aMarcacoes[ nI , AMARC_ORDEM ] == aMarcacoes[ nI-1 , AMARC_ORDEM ]
			If SubStr(aMarcacoes[ nI-1 , AMARC_TIPOMARC ],2,1) == "E"
				aMarcacoes[ nI , AMARC_TIPOMARC ] := cValToChar(nPosApo)+cTpApo
				nPosApo++
				cTpApo := "E"
			Else
				aMarcacoes[ nI , AMARC_TIPOMARC ] := cValToChar(nPosApo)+cTpApo
				cTpApo := "S"
			EndIf
		ElseIf aMarcacoes[ nI , AMARC_ORDEM ] <> aMarcacoes[ nI-1 , AMARC_ORDEM ]
			nPosApo := 1
			aMarcacoes[ nI , AMARC_TIPOMARC ] := cValToChar(nPosApo)+"E"
			cTpApo := "S"
		EndIf
	Next
EndIf

Return ( NIL )
