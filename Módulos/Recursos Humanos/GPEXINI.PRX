#INCLUDE "PROTHEUS.CH"
#INCLUDE "GPEX1INI.CH"

Static oHash_Tab
Static aTab_Fol		:= {}				//Array com as Tabelas da Folha
Static aRot13       := {}				//Array contendo o roteiro a ser executado (13o.)
Static aSRYBkp 		:= {}		// cabecalho do arquivo RC2 na base do cliente
Static aSRMBkp		:= {}		// cabecalho do arquivo RC3 na base do cliente
Static aRC2Bkp		:= {}
Static aRC3Bkp		:= {}
Static aPdFerMS 	:= {}
Static aCodFolT  	:= {}
Static cTurnoAnt 	:= "__cTurnoAnt__"//Turno Anterior
Static nTamFilAux
Static nTamRFO_COD
Static nTamRN_COD
Static nTamSind
Static lRefAbono	:= If(SRV->(ColumnPos( 'RV_REFABON' )) > 0, .T., .F.)
Static lIniS033	 	:= .T.
Static lTemSeqMV
Static lTemIN2110
Static lTemTribIR
Static lGrvRAZRAW
Static lChkEConsig
Static aEstb		:= fGM23SM0(,.T.,,.T.)
Static lConsig
Static cPdUltFil	:= ""
Static __lMemCalc
Static lTemRU6

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±ºPrograma  ³GPIniForm ³ Autor ³Microsiga                          ³ Data ³ 09-07-02 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Criacao das formulas Padroes da Microsiga                              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³             ATUALIZACOES SOFRIDAS DESDE A CONSTRU€AO INICIAL.                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Programador ³ Data   ³ BOPS/FNC         ³  Motivo da Alteracao                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Leandro Dr. ³23/09/12³           M12RH01³Requisito RHU210 - Unificação das folhas. ³±±
±±³Flavio Corr ³17/07/15³ TSWORN           ³Campo novo na SRY - RY_CONTAB             ³±±
±±³Allyson M   ³01/09/15³            TTBHWJ³Ajuste no fPosTab() p/ permitir a busca   ³±±
±±³		       ³        ³                  ³com 3 condicoes.                          ³±±
±±³Allyson M.  ³14/10/15³            TTLNPT³Ajuste em fCarrTab() p/ verificar         ³±±
±±³            ³        ³                  ³estrutura quando tabela for a S033 pois   ³±±
±±³            ³        ³                  ³a estrutura foi alterada.			      ³±±
±±³Renan Borges³27/10/15³            TTNSUW³Ajuste para calcular folha corretamente,  ³±±
±±³            ³        ³                  ³buscando as informações das tabelas auxili³±±
±±³            ³        ³                  ³ares corretamente, quando forem cadastra- ³±±
±±³            ³        ³                  ³das mensalmente. Na função ftabela, utili-³±±
±±³            ³        ³     		       ³zar a data do periodo aberto para buscar  ³±±
±±³            ³        ³                  ³as informações nas tabelas auxiliares, e  ³±±
±±³            ³        ³                  ³não a database.                           ³±±
±±³EstherV.    ³09/12/15³PCDEF2015_2016-677³Declaracao das variaveis cTab3Type e      ³±±
±±³            ³        ³                  ³cCnt3Type.                                ³±±
±±³Raquel Hager³02/02/16³            TUHLUS³Ajuste na funcao fCarMvto para considerar ³±±
±±³            ³        ³                  ³RGB_DTREF em branco ou dentro da competen-³±±
±±³            ³        ³                  ³cia de calculo para verbas informadas,    ³±±
±±³            ³        ³                  ³exceto para o roteiro de PLR que utiliza  ³±±
±±³            ³        ³                  ³campo para controle de pagamento.         ³±±
±±³            ³        ³                  ³Ajuste para gravar no aPd a dDtaPgto caso ³±±
±±³            ³        ³                  ³a Dt Ref estiver em branco ou dentro da   ³±±
±±³            ³        ³                  ³competência exceto para roteiro PLR e     ³±±
±±³            ³        ³                  ³fechamento.							      ³±±
±±³Raquel Hager³10/02/16³TUJQLJ            ³Ajuste para gravar a dDtRef               ³±±
±±³            ³        ³                  ³no aPd e consequentemente na SRC.		  ³±±
±±³Raquel Hager³19/02/16³TUKE03            ³Ajuste para inicializar dDtaPg.           ³±±
±±³Raquel Hager³23/02/16³TUNV61            ³Ajuste para gravacao de Dt Pagto/Ref.     ³±±
±±³Gustavo M.  ³30/03/16³TUVWVG            ³Melhoria de performance nas férias.	      ³±±
±±³Raquel Hager³30/05/16³TVGSTO            ³Ajuste para data de pagamento de PLR seja ³±±
±±³            ³        ³                  ³a do cadastro para registros I/G.         ³±±
±±³Gabriel A.  ³24/06/16³TVGZA5            ³Ajuste para quando for comissionado e     ³±±
±±³            ³        ³                  ³roteiro BEN, procurar as verbas também    ³±±
±±³            ³        ³                  ³no roteiro FOL.                           ³±±
±±³Allyson M.  ³12/07/16³TURHSE            ³Ajuste em GravaCalc() p/ nao gravar o     ³±±
±±³            ³        ³                  ³calculo se tiver sido executada antes do  ³±±
±±³            ³        ³                  ³roteiro de VT.			      			  ³±±
±±³Cícero Alves³25/07/16³TURHSE            ³Ajuste em  FCriaRoteiro para posicionar no³±±
±±³            ³        ³                  ³arquivo correto ao deletar o registro	  ³±±
±±³Renan Borges³03/08/16³TVSZY6            ³Ajuste para considerar verbas informadas  ³±±
±±³            ³        ³                  ³nas férias corretamente no dissidio retroa³±±
±±³            ³        ³                  ³tivo.                                     ³±±
±±³Allyson M.  ³05/08/16³TVSZY6            ³Ajuste para considerar verbas informadas  ³±±
±±³            ³        ³                  ³nas férias corretamente 				  ³±±
±±³Allyson M.  ³17/08/16³TVVMIR            ³Ajuste na ordenação da query em fCarMvto()³±±
±±³            ³        ³                  ³p/ não gerar erro em Oracle				  ³±±
±±³Allyson M.  ³26/08/16³TVRUMR            ³Ajuste em fPosTab() p/ receber data p/    ³±±
±±³            ³        ³                  ³busca dos dados da tabela				  ³±±
±±³Gabriel A.  ³23/09/16³TVEQT2            ³Ajuste para buscar os conteúdos das       ³±±
±±³            ³        ³                  ³tabelas de acordo com a filial corrente.  ³±±
±±³Allyson M.  ³10/10/16³TVYB07            ³Ajuste p/ não considerar verbas informadas³±±
±±³            ³        ³                  ³nas férias se o período de apuração das	  ³±±
±±³            ³        ³                  ³diferenças for o mesmo da folha	pois as   ³±±
±±³            ³        ³                  ³verbas já serão carregadas via RGB        ³±±
±±³Gustavo M.  ³10/12/16³MRH-3106          ³Ajuste em fComp13Fol() p/ não verificar o ³±±
±±³            ³        ³                  ³roteiro 132 na provisão					  ³±±
±±³Raquel Hager³28/12/16³MRH-3736          ³Ajuste em fCarMvto para carregar verbas do³±±
±±³            ³        ³                  ³do tipo Informada quando função estiver	  ³±±
±±³            ³        ³                  ³sendo executada pelo Complemento de 13º.  ³±±
±±³Raquel Hager³18/01/16³MRH-4927          ³Ajuste em fCarMvto para considerar a Resci³±±
±±³            ³        ³                  ³são calculada no mês que está sendo calcu ³±±
±±³            ³        ³                  ³lada Folha de Pagamento e trazer apenas os³±±
±±³            ³        ³                  ³registros gerados pela Rescisão.          ³±±
±±³Gabriel A.  ³19/01/17³MRH-5055          ³Ajuste para incorporar ao salário apenas  ³±±
±±³            ³        ³                  ³verbas que foram informadas, na provisão. ³±±
±±³Jônatas A.  ³23/01/17³MRH-5183          ³Ajuste em fRetTab p/ considerar a filial  ³±±
±±³            ³        ³                  ³do funcionário na carga da tabela.        ³±±
±±³Allyson M.  ³24/01/17³MRH-4639          ³Ajuste em fCarrTab() p/ efetuar query na  ³±±
±±³            ³        ³                  ³busca dos dados da RCC devido performance ³±±
±±³Jônatas A.  ³27/01/17³MRH-5183          ³Ajuste em fRetTab p/ receber parametro    ³±±
±±³            ³        ³                  ³passado pelo homolognet.                  ³±±
±±³Raquel Hager³13/02/17³MRH-6464          ³Ajuste em fCarmvto para utilizar uma varia³±±
±±³            ³        ³                  ³vel local para associar a Dt.Ref. da RGB. ³±±
±±³Jônatas A.  ³24/04/17³DRHPAG-106        ³Ajuste em GravaAdt p/ gerar no SRC apenas ³±±
±±³            ³        ³                  ³lançamentos da semana calculada.          ³±±
±±³Marcos Cout ³10/08/17³DRHESOCP-766      ³Subir fonte no pacote                     ³±±
±±³  Marco A.  ³17/10/17³   TSSERMI01-209  ³Se realiza modificacion en fCarrTab, para ³±±
±±³            ³        ³                  ³cerrar area de trabajo cAliasRCC, dentro  ³±±
±±³            ³        ³                  ³de While. (ARG)                           ³±±
±±³Oswaldo L   ³01/12/17³DRHPAG-8855       ³Acerto para permitir selecionar bancos da ³±±
±±³            ³        ³                  ³filial conectada S052, no fonte gpem080   ³±±
±±³Eduardo K.  ³05/02/18³MPRIMESP-13628    ³Ajuste em fCarrTab()/ p/ não ocorrer erro ³±±
±±³            ³        ³                  ³na tabela S052 com filial em branco.      ³±±
±±³João Balbino³07/03/18³MPRIMESP-14153    ³Ajuste em fCarrTab()/ p/ não ocorrer erro ³±±
±±³            ³        ³                  ³log quando chamda do GPER040.             ³±±
±±³  Marco A.  ³12/08/20³    DMINA-9750    ³Ajuste en la funcion fPosTab(), para asig-³±±
±±³            ³        ³                  ³nar el valor de xFilial("SRA") a variable ³±±
±±³            ³        ³                  ³default cFilSeek. (MI)                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function GpIniForm()
Local aArea
Local aAreaRC2
Local aAreaRC3

Local cFunc		:= ( "GpFor" + cPaisLoc + "()" )
DbSelectArea("RC3")
/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Verificar a existencia da formula padrao do pais corrente     ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
If FindFunction( cFunc )
	aArea		:= GetArea()
	aAreaRC2	:= RC2->( GetArea( "RC2" ) )
	aAreaRC3	:= RC3->( GetArea( "RC3" ) )
	__ExecMacro( cFunc )
	RestArea( aAreaRc2 )
	RestArea( aAreaRc3 )
	RestArea( aArea )
EndIf

Return( NIL )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o	   ³fNewOldSx3    ³Autor³ Mauricio T. Takakura³ Data ³09/11/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Val. estrutura da tabela RC2 e RC3 do Cliente c/ Nova Versao³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³fNewOldSx3                									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais> 									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Uso	   ³Generico      												³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function fNewOldSx3( aFatherHeader	,;	// Cabecalho do Item Pai
					 aChildHeader   ,;	// Cabecalho do Item Filho
					 cFatherAlias	,;	// Alias do Father
					 cChildAlias	,; 	// Alias Child
					 lX3Tela		 ;  // Verificar o campo X3_TELA para montagem do Header
					)

Local aCliFatherHdr := {}		// cabecalho do arquivo RC2 na base do cliente
Local aCliChildHdr	:= {}		// cabecalho do arquivo RC3 na base do cliente

Local cCampo					// nome do campo para validacao
Local cNotField	  	:= ""		// campos nao encontrados

Local lRet		  	:= .T.		// variavel de retorno

Local nUsado					// campos usados
Local nPos
Local nX

DEFAULT aFatherHeader	:= {}
DEFAULT aChildHeader 	:= {}
DEFAULT cFatherAlias	:= ""
DEFAULT cChildAlias		:= ""
DEFAULT lX3Tela			:= .T.

If !Empty(cFatherAlias)
	If cFatherAlias == "SRY"
		If Empty(aSRYBkp)
			aCliFatherHdr := ( cFatherAlias )->( GdMontaHeader( @nUsado, NIL, NIL, NIL, NIL, .T.,,,,,,,,lX3Tela ) )
			aSRYBkp := aClone(aCliFatherHdr)
		Else
			aCliFatherHdr := aClone(aSRYBkp)
		EndIf
	ElseIf cFatherAlias == "RC2"
		If Empty(aRC2Bkp)
			aCliFatherHdr := ( cFatherAlias )->( GdMontaHeader( @nUsado, NIL, NIL, NIL, NIL, .T.,,,,,,,,lX3Tela ) )
			aRC2Bkp := aClone(aCliFatherHdr)
		Else
			aCliFatherHdr := aClone(aRC2Bkp)
		EndIf
	Else
		aCliFatherHdr := ( cFatherAlias )->( GdMontaHeader( @nUsado, NIL, NIL, NIL, NIL, .T.,,,,,,,,lX3Tela ) )
	EndIf
EndIf

If !Empty(cChildAlias)
	If cChildAlias == "SRM"
		If Empty(aSRMBkp)
			aCliChildHdr  := ( cChildAlias )->( GdMontaHeader( @nUsado, NIL, NIL, NIL, NIL, .T.,,,,,,,,lX3Tela ) )
			aSRMBkp		:= aClone(aCliChildHdr)
		Else
			aCliChildHdr := aClone(aSRMBkp)
		EndIf
	ElseIf cChildAlias == "RC3"
		If Empty(aRC3Bkp)
			aCliChildHdr  := ( cChildAlias )->( GdMontaHeader( @nUsado, NIL, NIL, NIL, NIL, .T.,,,,,,,,lX3Tela ) )
			aRC3Bkp		:= aClone(aCliChildHdr)
		Else
			aCliChildHdr := aClone(aRC3Bkp)
		EndIf
	Else
		aCliChildHdr  := ( cChildAlias )->( GdMontaHeader( @nUsado, NIL, NIL, NIL, NIL, .T.,,,,,,,,lX3Tela ) )
	EndIf

EndIf


/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Verificar se todos os campos da tabela padrao possuem na base ³
³ do cliente.                                                   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
For nX := 1 To Len(aFatherHeader)
	cCampo := Upper(aFatherHeader[nX,2])

	nPos := aScan(aCliFatherHdr,  { |x|  Upper(x[2]) == cCampo })
	If nPos == 0  .And. (cFatherAlias + "->" + aFatherHeader[ nX, 2 ] <> "SRY->RY_MODULO" )
		cNotField += " " + cFatherAlias + "->" + aFatherHeader[ nX, 2 ] + CRLF
	EndIf
Next nX

For nX := 1 To Len(aChildHeader)
	cCampo := Upper(aChildHeader[nX, 2])
	nPos := aScan(aCliChildHdr,  { |x|  Upper(x[2]) == cCampo })
	If nPos == 0
		cNotField += " " + cChildAlias + "->" + aChildHeader[ nX, 2 ] + CRLF
	EndIf
Next nX
If !Empty(cNotField)
	MsgInfo( STR0123 + CRLF + cNotField + STR0124 + CRLF +; // "O(s) campo(s) " ### " nao Existe(m) no Banco de Dados!"
			 STR0125 )										// "Atualize a Estrutura das Tabelas!"
	lRet := .F.
EndIf

Return( lRet )

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³fFormGravaºAutor  ³Microsiga           º Data ³21/08/2002   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Inclusao de Formulas Padroes no RC2 e RC3                   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³Inclusao de Formulas Padroes no RC2 e RC3                   º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Function fFormGrava( aRc2Cols	,; 	//01 -> Formulas a gravar da tabela RC2
					 aRc3Cols	,;	//02 -> Itens da tabela RC3
					 aRC2Header	,;	//03 -> Cabecalho do Item Pai
					 aRC3Header ,;	//04 -> Cabecalho do Item Filho
					 aSYPHeader	,; 	//07 -> Cabecalho da tabela de Campos Memos
					 aSYPMemo	 ; 	//08 -> Itens do campo Memo
					)

Local aMemoBco		:= {}
Local aRc3Recnos

Local cKey
Local cCampo
Local cCodObs
Local cRc2Filial
Local cSYPFilial
Local cRc2Origem
Local cRc2Codigo
Local lAddNew

Local nX
Local nG
Local nY
Local nRc2Versao
Local nFieldPos
Local nPosField
Local nRc3SeqPai
Local nPosSYPSeq
Local nPosSYPFilial

nRc2Versao	:= GdFieldPos ( "RC2_VERSAO" , aRC2Header )
nRc2Origem	:= GdFieldPos ( "RC2_ORIGEM" , aRC2Header )
nRc2Codigo	:= GdFieldPos ( "RC2_CODIGO" , aRC2Header )
cRc2Filial	:= xFilial("RC2")
cSYPFilial	:= xFilial("SYP")

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Gravacao da Formula                                           ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
cNewVersao 	:= aRc2Cols[1,nRc2Versao]
cRc2Origem	:= aRc2Cols[1,nRc2Origem]
cRc2Codigo	:= aRc2Cols[1,nRc2Codigo]
nPosSYPFilial:= GdFieldPos ( "YP_FILIAL" , aSYPHeader )
nPosSYPSeq	 := GdFieldPos ( "YP_SEQ" , aSYPHeader )


DbSelectArea("RC2")
RC2->( dbSetOrder(RetOrdem("RC2","RC2_FILIAL+RC2_ORIGEM+RC2_CODIGO")) )
lAddNew	:= RC2->( !MsSeek( cRc2Filial + cRc2Origem + cRc2Codigo ) )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Atualizar a formula                                           ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
IF RC2->( RecLock( "RC2" , lAddNew ) )

	// gravacao dos campos comuns //
	For nG := 1 To Len(aRC2Header)
	   	cCampo		:= Upper( aRC2Header[nG, 2] )
    	nFieldPos	:= RC2->( FieldPos( cCampo ) )
    	IF ( nFieldPos > 0 )
	   		IF !( cCampo $ "RC2_FILIAL/RC2_RECOMP/RC2_CODOBS" )
	    		nPosField := GdFieldPos( cCampo , aRC2Header )
	    		IF ( nPosField > 0 )
	    			RC2->( FieldPut( nFieldPos , aRc2Cols[ 1 , nPosField ] ) )
	    		EndIF
	    	ElseIF cCampo == "RC2_CODOBS"
	    		IF lAddNew .Or. ( !lAddNew .and. Empty(aRc2Cols[ 1 , nPosField ]) )
		    		nPosField := GdFieldPos( cCampo , aRC2Header )
		    		IF ( nPosField > 0 )
		    			IF ( !lAddNew .and. Empty(aRc2Cols[ 1 , nPosField ]) )
		    				cCodObs := RC2->RC2_CODOBS
		    			EndIf
		    			RC2->( FieldPut( nFieldPos , aRc2Cols[ 1 , nPosField ] ) )
	    			EndIF
	    		EndIF
	    	Else
	    		RC2->( FieldPut( nFieldPos , cRc2Filial ) )
	    	EndIF
	    EndIF
	Next nG
	nFieldPos := RC2->( FieldPos( "RC2_RECOMP" ) )
	IF ( nFieldPos > 0 )
		RC2->( FieldPut( nFieldPos , "1" ) )
	EndIF
	RC2->( MsUnLock() )
	IF Empty( cCodObs )
		cCodObs := RC2->RC2_CODOBS
	Else
		cKey := xFilial( "SYP" ) + cCodObs
		SYP->( DbSeek( cKey, .F. ) )
		If !lAddNew .and. SYP->( !Eof() )
			While SYP->( !Eof() ) .and. SYP->(YP_FILIAL+YP_CHAVE) == cKey
				aAdd( aMemoBco, { SYP->YP_FILIAL, SYP->YP_CHAVE, SYP->YP_SEQ, "" } )
				SYP->( DbSkip() )
			EndDo
        EndIf
	EndIF

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Gravacao do campo de Observacoes                              ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	If !Empty(aSYPMemo)

		DbSelectArea( "SYP" )
		DbSetOrder( 1 ) // YP_FILIAL+YP_CHAVE+YP_SEQ

		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Armazenar para verificar se existe necessidade de excluir    ³
		³ algum item do banco de dados.                                ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		cKey := cSYPFilial + cCodObs
		DbSeek( cKey, .F. )
		If !lAddNew
			While !Eof() .and. SYP->(YP_FILIAL+YP_CHAVE) == cKey
				aAdd( aMemoBco, { SYP->YP_FILIAL, SYP->YP_CHAVE, SYP->YP_SEQ, "" } )
				DbSkip()
			EndDo
		Else
			If SYP->( !Eof() )
				cCodObs := GetSX8Num("SYP","YP_CHAVE")
				ConfirmSX8()
			EndIf
		EndIf

		For nX := 1 To Len( aSYPMemo )
			cKey := cSYPFilial + cCodObs + aSYPMemo[ nX, nPosSYPSeq]
			DbSeek( cKey, .F. )
			If SYP->( Eof() )
				RecLock("SYP",.T.,.T.)
			Else
				RecLock("SYP",.F.,.T.)
			EndIf
			For nY := 1 To Len( aSYPHeader )
				cCampo := aSYPHeader[ nY, 2 ]
				If cCampo == "YP_CHAVE"
					SYP->( &cCampo ) := cCodObs
				ElseIf cCampo == "YP_FILIAL"
					SYP->( &cCampo ) := cSYPFilial
				Else
					SYP->( &cCampo ) := aSYPMemo[nX,nY]
				EndIf
			Next nY
			SYP->( MsUnLock() )
			If !lAddNew
				nPosArr := ascan( aMemoBco, { | x, y| x[1] == cSYPFilial .and. x[2] = cCodObs .and. x[3] == aSYPMemo[ nX, nPosSYPSeq] })
				If nPosArr > 0
					aMemoBco[nPosArr, 4] := "1"
				EndIf
			EndIf
		Next nX

		If RC2->RC2_CODOBS <> cCodObs
			RC2->( RecLock( "RC2" , .F., .T. ) )
			RC2->RC2_CODOBS := cCodObs
			RC2->( MsUnLock() )
		EndIf
	EndIf

	If Len( aMemoBco ) > 0 .and. !lAddNew
		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Excluir da Tabela os itens que nao necessitam mais 		   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		If Len( aSYPMemo ) < Len( aMemoBco )
			For nX := 1 To Len( aMemoBco )
				If aMemoBco[nX, 4] == "1"
					Loop
				Else
					cKey := aMemoBco[nX, 1] + aMemoBco[nX, 2] + aMemoBco[nX, 3]
					SYP->( DbSeek( cKey, .F. ) )
					If SYP->( !Eof() )
						RecLock("SYP",.F.,.T.)
						SYP->( dbDelete() )
						SYP->( MsUnLock() )
					EndIf
				EndIF
			Next nX
		EndIf
	EndIf

	Rc2RecSry() //Forcar a Recompilacao do Roteiro

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Efetua a Delecao do RC3 antes de fazer a inclusao       	    ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	dbSelectArea("RC3")
	aRc3Recnos	:= {}
	nFieldPos	:= RC3->( FieldPos( "RC3_SEQPAI" ) )
	RC3->( dbSetOrder( 1 ) ) // RC3_FILIAL+RC3_ORIGEM+RC3_CODIGO+RC3_SEQFOR+RC3_SEQPAI
	If RC3->( dbSeek( cRc2Filial + cRc2Origem + cRc2Codigo ) )
		cRc2Filial := AllTrim(Upper(cRc2Filial))
		cRc2Origem := AllTrim(Upper(cRc2Origem))
		cRc2Codigo := AllTrim(Upper(cRc2Codigo))
		While RC3->(;
						!Eof();
						.and.;
						(;
							(;
								AllTrim(Upper(RC3_FILIAL));
								+;
								AllTrim(Upper(RC3_ORIGEM));
								+;
								AllTrim(Upper(RC3_CODIGO));
							);
							==;
			            	(;
			            		cRc2Filial;
			            		+;
			            		cRc2Origem;
			            		+;
			            		cRc2Codigo;
			            	);
			            );
			       )
			IF RecLock( "RC3" , .F. )
				aAdd( aRc3Recnos , RC3->( Recno() ) )
				RC3->( FieldPut( nFieldPos , Space( GetSx3Cache( "RC3_SEQPAI" , "X3_TAMANHO" ) ) ) )
				RC3->( MsUnlock() )
			EndIF
			RC3->( dbSkip() )
		EndDo
	EndIf

	For nG := 1 To Len( aRc3Recnos )
		RC3->( MsGoto( aRc3Recnos[ nG ] ) )
		IF RC3->( Eof() )
			Loop
		EndIF
		IF RecLock( "RC3" , .F. )
			RC3->( dbDelete() )
			RC3->( MsUnlock() )
		EndIF
	Next nG

	aRc3Recnos := {}
	For nG := 1 to Len(aRc3Cols)

		IF RC3->( RecLock( "RC3" , .T. ) )
			// gravacao dos campos //
			For nY := 1 To Len(aRC3Header)
				cCampo 		:= Upper(aRC3Header[nY, 2])
				IF ( cCampo <> "RC3_SEQPAI" )
					nFieldPos	:= RC3->( FieldPos( cCampo ) )
					IF ( nFieldPos > 0 )
						If ( cCampo != "RC3_FILIAL" )
					    	nPosField := GdFieldPos( cCampo , aRC3Header )
					    	IF ( nPosField > 0 )
					    		RC3->( FieldPut( nFieldPos , aRc3Cols[ nG , nPosField ] ) )
					    	EndIF
					    Else
				    		RC3->( FieldPut( nFieldPos , cRc2Filial ) )
					    EndIf
					EndIF
				EndIF
			Next nY
			aAdd( aRc3Recnos , { RC3->( Recno() ) , nG } )
			RC3->( MsUnlock() )
		EndIF
	Next nG

	//Gravando a Sequencia Pai
	nFieldPos	:= RC3->( FieldPos( "RC3_SEQPAI" ) )
	nRc3SeqPai	:= GdFieldPos( "RC3_SEQPAI" , aRC3Header )
	IF (;
			( nFieldPos > 0 );
			.and.;
			( nRc3SeqPai > 0 );
		)
		For nG := 1 To Len( aRc3Recnos )
			RC3->( MsGoto( aRc3Recnos[ nG , 1 ] ) )
			IF RC3->( Eof() )
				Loop
			EndIF
			IF RC3->( RecLock( "RC3" , .F. ) )
				RC3->( FieldPut( nFieldPos , aRc3Cols[ aRc3Recnos[ nG , 2 ] , nRc3SeqPai ] ) )
				RC3->( MsUnlock() )
			EndIF
		Next nG
	EndIF

EndIF

Return( NIL )

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±ºPrograma  ³GPIniTab  ³ Autor ³Mauricio T. Takakura   ³ Data ³ 06/12/04 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Criacao das Definicoes de Tabelas Padroes                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³         ATUALIZACOES SOFRIDAS DESDE A CONSTRU€AO INICIAL.             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Programador ³ Data   ³ BOPS ³  Motivo da Alteracao                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³            ³        ³      ³                                          ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Function GpIniTab()

Local aArea

Local cFunc		:= ( "GpTab" + cPaisLoc + "()" )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Verificar a existencia da formula padrao do pais corrente     ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
IF FindFunction( cFunc )
	aArea		:= GetArea()
	__ExecMacro( cFunc )
	RestArea( aArea )
EndIF

// Atualizar Motivo de Desligamento
fAtMot()
fVldS151()

Return( NIL )

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³fGravaTab ºAutor  ³Mauricio T. Takakuraº Data ³06/12/2004   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Inclusao de Definicao Tabelas Padroes no RCB                º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³Gpea310.prx                                                 º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Function fGravaTab( aRCBHeader	,;		// cabecalho da Nova Versao - Arquivo Padrao
					aRCBItens	 ;		// Itens a serem atualizados
				  )

Local cFilRCB 		:= xFilial( "RCB" )
Local cCodigo 		:= aRCBItens[1, GdFieldPos( 'RCB_CODIGO' , aRCBHeader )]
Local cCampo

Local nFieldPos
Local nX
Local nY

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Excluir os Itens da Tabela para Incluir posteriormente 	   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
DbSelectArea( "RCB" )
DbSetOrder( 1 )
DbSeek( cFilRCB + cCodigo )
While !Eof() .and. RCB->( RCB_FILIAL + RCB_CODIGO ) == cFilRCB + cCodigo
	IF RecLock( "RCB" , .F. )
		RCB->( dbDelete() )
		RCB->( MsUnlock() )
	EndIF
	RCB->( dbSkip() )
EndDo

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Incluir os Itens da Definicao Tabelas                  	   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
For nX := 1 To Len( aRCBItens )

	IF RCB->( RecLock( "RCB" , .T. ) )

		// gravacao dos campos //
		For nY := 1 To Len(aRCBHeader)
			cCampo 		:= Upper(aRCBHeader[nY, 2])
			nFieldPos	:= RCB->( FieldPos( cCampo ) )
			IF ( nFieldPos > 0 )
				If ( cCampo != "RCB_FILIAL" )
			    	RCB->( FieldPut( nFieldPos , aRCBItens[nX, nY] ) )
			    Else
		    		RCB->( FieldPut( nFieldPos , cFilRCB ) )
			    EndIf
			EndIF
		Next nY
		RCB->( MsUnlock() )
	EndIF
Next nX

Return( NIL )

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³GPInifunc ºAutor  ³Microsiga           º Data ³  08-21-02   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³                                                            º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP7                                                        º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Function GpIniFuncao()

Local aArea
Local cFunc

If cPaisLoc == "RUS"
	cFunc		:= ( "GpFunRus" + "()" )
Else
	cFunc		:= ( "GpFunAll" + "()" )
EndIf

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Verificar a existencia da Bibioteca de Funcoes Padroes        ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
IF FindFunction( cFunc )
	aArea		:= GetArea()
	__ExecMacro( cFunc )
	RestArea( aArea )
EndIF

Return( NIL )

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³fGravaFuncºAutor  ³Mauricio T. Takakuraº Data ³  07-12-04   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Funcao para gravacao das funcoes da biblioteca			  º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ MP8                                                        º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Function fGravaFunc(	aRc4Cols	,;	// Cabecalho das Funcoes
						aRc5Cols 	,;	// Parametros da Funcao
						aRc4Header	,;
						aRc5Header	,;
						aRc4Memo	,;
						aRc5Memo	 ;
					)

Local cCampo
Local cValueMemo
Local cRc4Filial
Local cRc4NomFun

Local lAddNew

Local nG
Local nY
Local nRc4Memo
Local nRc5Memo
Local nFieldPos
Local nPosField
Local nPosCpoMemo

DEFAULT aRC4Memo := {}
DEFAULT aRC5Memo := {}

nRc4NomFun		 := GdFieldPos ( "RC4_NOMFUN" , aRC4Header )
cRc4Filial		 := xFilial("RC4")
cRc4NomFun		 := aRc4Cols[1, nRc4NomFun]

DbSelectArea("RC4")
RC4->( dbSetOrder(RetOrdem("RC4","RC4_FILIAL+RC4_NOMFUN")) )
lAddNew	:= RC4->( !MsSeek( cRc4Filial + cRc4NomFun ) )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Atualizar a funcao                                            ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
IF RC4->( RecLock( "RC4" , lAddNew ) )

	// gravacao dos campos comuns //
	For nG := 1 To Len(aRC4Header)
	   	cCampo		:= Upper( aRC4Header[nG, 2] )
    	nFieldPos	:= RC4->( FieldPos( cCampo ) )
    	IF ( nFieldPos > 0 )
	   		If !( cCampo $ "RC4_FILIAL" )
	    		nPosField := GdFieldPos( cCampo , aRC4Header )
	    		IF ( nPosField > 0 )
	    			RC4->( FieldPut( nFieldPos , aRc4Cols[ 1 , nPosField ] ) )
	    		EndIF
	    	Else
	    		RC4->( FieldPut( nFieldPos , cRc4Filial ) )
	    	EndIf
	    EndIF
	Next nG
	RC4->( MsUnLock() )

	// gravacao dos campos Memos Virtuais //
	For nG := 1 To Len(aRC4Header)
		cCampo := Upper(aRC4Header[nG, 2])
	    If (aRC4Header[nG, 8] == "M") .and. ((nRc4Memo := aScan(aRC4Memo, { |x|  Upper(x[2]) == cCampo })) > 0)
	    	nPosCpoMemo := GdFieldPos( aRC4Memo[nRc4Memo, 1], aRC4Header)
	    	cValueMemo := StrTran(aRc4Cols[1,GdFieldPos(cCampo,aRC4Header)], "\13\10", CRLF)
			MsMm(aRc4Cols[1,nPosCpoMemo],80,NIL,cValueMemo ,1,NIL,NIL,"RC4", aRC4Memo[nRc4Memo, 1])
		EndIf
	Next nG

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Efetua a Delecao do RC5 antes de fazer a inclusao       	    ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	dbSelectArea( "RC5" )
	RC5->( dbSetOrder(RetOrdem("RC5","RC5_FILIAL+RC5_NOMFUN+RC5_SEQ")) )
	If RC5->( dbSeek( cRc4Filial + cRc4NomFun ) )
		cRc4Filial := AllTrim(Upper(cRc4Filial))
		cRc4NomFun := AllTrim(Upper(cRc4NomFun))
		While RC5->(;
						!Eof();
						.and.;
						(;
							(;
								AllTrim(Upper(RC5_FILIAL));
								+;
								AllTrim(Upper(RC5_NOMFUN));
							);
							==;
			            	(;
			            		cRc4Filial;
			            		+;
			            		cRc4NomFun;
			            	);
			            );
			       )
			IF RecLock( "RC5" , .F. )
				RC5->( dbDelete() )
				RC5->( MsUnlock() )
			EndIF
			RC5->( dbSkip() )
		EndDo
	EndIf

	For nG := 1 to Len(aRc5Cols)

		IF RC5->( RecLock( "RC5" , .T. ) )
			// gravacao dos campos //
			For nY := 1 To Len( aRC5Header )
				cCampo 		:= Upper( aRC5Header[nY, 2] )
				nFieldPos	:= RC5->( FieldPos( cCampo ) )
				IF ( nFieldPos > 0 )
					If ( cCampo != "RC5_FILIAL" )
				    	nPosField := GdFieldPos( cCampo , aRC5Header )
				    	IF ( nPosField > 0 )
				    		RC5->( FieldPut( nFieldPos , aRc5Cols[ nG , nPosField ] ) )
				    	EndIF
				    Else
				   		RC5->( FieldPut( nFieldPos , cRc4Filial ) )
				    EndIf
				EndIF
			Next nY
			RC5->( MsUnlock() )
		EndIF

		// gravacao dos campos memos virtuais //
		For nY := 1 To Len( aRC5Header )
			cCampo := Upper( aRC5Header[nY, 2] )
			If ( aRC5Header[nY, 8] == "M" ) .and. ( nRc5Memo := aScan(aRC5Memo, { |x|  Upper(x[2]) == cCampo }) > 0 )
		    	nPosCpoMemo := GdFieldPos( aRC5Memo[nRc5Memo, 1], aRC5Header)
	   	    	cValueMemo := StrTran(aRc5Cols[GdFieldPos(cCampo, aRC5Header)], "13/10", CRLF)
				MsMm(aRc5Cols[nPosCpoMemo],80,NIL, cValueMemo,1,NIL,NIL,"RC5", aRC5Memo[nRc5Memo, 1])
		    EndIf
		Next nY
	Next nG
EndIF

Return( NIL )

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o	 ³fCarMnemo ³ Autor ³ R.H. -  Natie         ³ Data ³ 23/05/02 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Carrega as variaveis p/cadastro de Mnemonicos              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³ fMnemo()                                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parƒmetros³                                                            ³±±
±±³			 ³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso		 ³ Gen‚rico 												  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Function fCarMnemo()

Local aAux		:= {}
Local aRCAHeader:= {}

Local bFunc		:= { || NIL }

Local cCampo	:= ""
Local cFilRCA	:= xFilial( "RCA" )
Local cMnemo	:= ""
Local cFunction	:= ( "GpMne" + cPaisLoc )
Local cUrl 		:= ""

Local dDataAtu  := date()

Local nFieldPos
Local nPosField
Local nPosMnemo
Local nPosAcumul
Local nPosDesc
Local nPosConteu
Local nPosTipo
Local nAux
Local nAuxs
Local nX
Local nPosProc
Local nOp

Local uCnt

Local lUpdate	:= .F.

Static lShowMsg := !IsBlind()

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Verificar a existencia do mnemonico padrao do pais corrente   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
IF FindFunction( cFunction )
	bFunc := __ExecMacro( "{ ||  " + cFunction + "( @aAux , @aRCAHeader ) }" )
	Eval( bFunc )
	nPosMnemo  := GdFieldPos ( "RCA_MNEMON" , aRCAHeader )
	nPosAcumul := GdFieldPos ( "RCA_ACUMUL" , aRCAHeader )
	nPosDesc   := GdFieldPos ( "RCA_DESC" , aRCAHeader )
	nPosConteu := GdFieldPos ( "RCA_CONTEU" , aRCAHeader )
	nPosTipo   := GdFieldPos ( "RCA_TIPO" , aRCAHeader )
	nPosProc   := GdFieldPos ( "RCA_PROCES" , aRCAHeader )
	nAuxs 	   := Len(aAux)
	DbSelectarea( "RCA")
	DbSetOrder( 1 )
	For nAux := 1 To nAuxs
		cMnemo := Padr(Upper( AllTrim( aAux[ nAux, nPosMnemo ])),TamSX3("RCA_MNEMON")[1])
		lUpdate := .F.
		If !RCA->(dbSeek(cFilRCA + cMnemo))
			IF RecLock("RCA",.T.,.T.)
				For nX := 1 To Len(aRCAHeader)
				   	cCampo := Upper(aRCAHeader[nX, 2])
					nFieldPos := RCA->( FieldPos( cCampo ) )
					IF ( nFieldPos > 0 )
						If ( aRCAHeader[nX, 2] == "RCA_FILIAL" )
							uCnt := cFilRCA
						Else
					    	nPosField := GdFieldPos( cCampo , aRCAHeader )
					    	IF ( nPosField == 0 )
					    		Loop
					    	EndIF
					    	uCnt := aAux[ nAux , nPosField ]
						Endif
						RCA->( FieldPut( nFieldPos , uCnt ) )
					EndIF
				Next nX
				RCA->( MsUnlock() )
			EndIF
		Else
			If nPosAcumul > 0
				If AllTrim(RCA->RCA_ACUMUL) <>  AllTrim(aAux[ nAux, nPosAcumul ])
					lUpdate := .T.
					RecLock("RCA",.F.,.T.)
					RCA->RCA_ACUMUL := aAux[ nAux, nPosAcumul ]
				EndIf
			EndIf
			If AllTrim(RCA->RCA_MNEMON) == "P_SEGFALT" .and. AllTrim(RCA->RCA_CONTEU) <> ".T."
				If lShowMsg
					cUrl := "https://tdn.totvs.com/pages/viewpage.action?pageId=839962203"
					If DtoS(dDataAtu) < "20240601"
						nOp := Aviso(STR0136,STR0133 + CRLF + CRLF + CRLF + STR0135 + cUrl,{OemToAnsi(STR0137),OemToAnsi(STR0138)})//"A partir de 01/06/2024 o mnemônico P_SEGFALT (antigo MV_SEGFALT) obrigatoriamente deverá ser ativado." ### "Consulte a documentação em: "
					Else
						nOp := Aviso(STR0136,STR0134 + CRLF +  CRLF + CRLF + STR0135 + cUrl,{OemToAnsi(STR0137),OemToAnsi(STR0138)})//"A partir de 01/06/2024 o mnemônico P_SEGFALT (antigo MV_SEGFALT) passou a ser obrigatório e foi ativado automaticamente." ### "Consulte a documentação em: "
					EndIf
					If nOp == 2
						shellExecute("Open",cUrl, "", "", 1)
					EndIf
					lShowMsg := .F. 
				EndIf
				If DtoS(dDataAtu) >= "20240601"
					If !lUpdate
						lUpdate := .T.
						RecLock("RCA",.F.,.T.)
					EndIf
					RCA->RCA_CONTEU := ".T."
				EndIf
			EndIf			
			If nPosDesc > 0
				If AllTrim(RCA->RCA_DESC) <>  AllTrim(aAux[ nAux, nPosDesc ])
					If !lUpdate
						lUpdate := .T.
						RecLock("RCA",.F.,.T.)
					EndIf
					RCA->RCA_DESC := aAux[ nAux, nPosDesc ]
				EndIf
			EndIf
			If nPosConteu > 0 .and. SubStr(RCA->RCA_MNEMON,1,2) <> "P_"
				If AllTrim(RCA->RCA_CONTEU) <>  AllTrim(aAux[ nAux, nPosConteu ])
					If !lUpdate
						lUpdate := .T.
						RecLock("RCA",.F.,.T.)
					EndIf
					RCA->RCA_CONTEU := aAux[ nAux, nPosConteu ]
				EndIf
			EndIf
			If nPosTipo > 0
				If AllTrim(RCA->RCA_TIPO) <>  AllTrim(aAux[ nAux, nPosTipo ])
					If !lUpdate
						lUpdate := .T.
						RecLock("RCA",.F.,.T.)
					EndIf
					RCA->RCA_TIPO := aAux[ nAux, nPosTipo ]
					If AllTrim(RCA->RCA_MNEMON) == "P_ADCINTEG" //Retirar no próximo release
						RCA->RCA_CONTEU := If(&(RCA->RCA_CONTEU),'"12345"','""')
					EndIf
				EndIf
			EndIf
			If nPosProc > 0
				If AllTrim(RCA->RCA_PROCES) <>  AllTrim(aAux[ nAux, nPosProc ])
					If !lUpdate
						lUpdate := .T.
						RecLock("RCA",.F.,.T.)
					EndIf
					RCA->RCA_PROCES := aAux[ nAux, nPosProc ]
				EndIf
			EndIf
			If lUpdate
				RCA->( MsUnlock() )
			EndIf
		EndIf
	Next nAux
EndIf

Return( NIL )

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o	 ³ FCHKSRM	³ Autor ³ J. Ricardo 			³ Data ³		  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Verifica a existencia do Roteiro de Calculo				  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Function FCHKSRM(cFilCarrega)
	Local lRet := .T.
	Local cAlias := ALIAS()
	Local nRecSx2 := SX2->(RECNO())
	dbSelectArea("SX2")
	dbSeek("SRM")

	cFilCarrega:= xFilial("SRM", cFilCarrega)

	If ! FGeraRoteiro(cFilCarrega)
		lRet := (.F.)
	Endif

	SX2->(DBGOTO(nRecSx2))
	dbSelectArea(cAlias)
Return (lRet)

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o	 ³ FGeraRoteiro 	³ Autor ³ J. Ricardo	³ Data ³    	  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Gera roteiro para cada um dos eventos					  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Function fGeraRoteiro( cFilSRM, aRotPadrao, lPadrao, aIdErro, lAmbos, lGP290REPL, aRotBkp, aSRYHBKP, aSRMHBkp, aSYPHBkp, lForcaComp )

Local aRotSRY		:= {}					// Tabela de Roteiros
Local aSRYHeader	:= {}					// Header de SRY
Local aSRMHeader 	:= {}
Local aSYPHeader	:= {}
Local aSYPMemo		:= {}

Local bFunc

Local cRotNum		:= ""
Local cRoteiro		:= ""
Local cChave		:= ""
Local cFunction		:= ""

Local lRet			:= .T.

Local nPosCalculo
Local nPosDes
Local nPosVersao
Local nPosAlias
Local nPosOrdinar
Local nPosInteg
Local nPosTipo
Local nPosObs
Local nPosPerg
Local nPosContab
Local nPosModulo
Local nX

DEFAULT cFilSRM		:= xFilial( "SRM" , cFilSRM )
DEFAULT aRotPadrao	:= {}
DEFAULT aIdErro		:= {}
DEFAULT lPadrao		:= .F.
DEFAULT lAmbos		:= .F.
DEFAULT lGP290REPL	:= .F.
DEFAULT lForcaComp	:= .F.
DEFAULT aRotBkp		:= {}
DEFAULT aSRYHBKP	:= {}
DEFAULT aSRMHBkp	:= {}
DEFAULT aSYPHBkp	:= {}

aRoteiro	:= {}
aRotPadrao	:= {}

cFunction := ( "GpRot" + If(fUsaGFP() .AND. cModulo == "GFP" .AND. !lAmbos,"GFP",cPaisLoc) )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Verificar a existencia da formula padrao do pais corrente     ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
IF !( lRet := FindFunction( cFunction ) )
	Return .F.
EndIF

If lGP290REPL .And. !Empty(aRotBkp)
	aRotSRY 	:= aClone(aRotBkp)
	aSRYHeader 	:= aClone(aSRYHBKP)
	aSRMHeader 	:= aClone(aSRMHBkp)
	aSYPHeader 	:= aClone(aSYPHBkp)
EndIf

If !lGP290REPL .Or. Empty(aRotBkp)
	bFunc := __ExecMacro( "{ || GpRot" + If(fUsaGFP() .AND. cModulo == "GFP" .AND. !lAmbos ,"GFP",cPaisLoc) + "( @aRotSRY , @aSRYHeader , @aSRMHeader, @aSYPHeader ) }" )
	IF !( lRet := Eval( bFunc ) )
		Return .F.
	EndIF
EndIf

nPosCalculo := GdFieldPos( "RY_CALCULO"	, aSRYHeader )
nPosDes		:= GdFieldPos( "RY_DESC"	, aSRYHeader )
nPosVersao	:= GdFieldPos( "RY_VERSAO"	, aSRYHeader )
nPosAlias	:= GdFieldPos( "RY_ALIAS"	, aSRYHeader )
nPosOrdinar	:= GdFieldPos( "RY_ORDINAR"	, aSRYHeader )
nPosTipo	:= GdFieldPos( "RY_TIPO"	, aSRYHeader )
nPosObs		:= GdFieldPos( "RY_CODOBS"	, aSRYHeader )
nPosPerg	:= GdFieldPos( "RY_PERGUNT"	, aSRYHeader )
nPosInteg	:= GdFieldPos( "RY_INTEGRA"	, aSRYHeader )
nPosContab	:= GdFieldPos( "RY_CONTAB"	, aSRYHeader )
nPosModulo	:= GdFieldPos( "RY_MODULO"	, aSRYHeader )

For nX := 1 To Len( aRotSry )
		If lPadrao .AND. lAmbos .AND. nPosModulo > 0 .AND. aRotSry[ nX , nPosModulo ] <> "3"
			Loop
		EndIf
		aAdd( aRotPadrao ,{ aRotSry[ nX , nPosCalculo ] , aRotSry[ nX , nPosDes ], aRotSry[ nX , nPosAlias ], aRotSry[ nX , nPosOrdinar ], aRotSry[ nX , nPosTipo ],;
		 					aRotSry[ nX , nPosObs ], aRotSry[ nX , nPosPerg ], aRotSry[ nX , nPosInteg] , aRotSry[ nX , nPosContab],Iif(nPosModulo > 0, aRotSry[ nX , nPosModulo ],"")} )
	Next nX

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Se nao For para Retornar o aRotPadrao Carrega os Roteiros     ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
IF !( lPadrao )

	cRotNum := "0000"
	For nX := 1 To Len( aRotPadrao )
		cRotNum 	:= Soma1( cRotNum )
		cRoteiro	:= aRotPadrao[ nX , 1 ]
		cFunction	:= ( "Rot" + If(fUsaGFP() .AND. cModulo == "GFP" .AND. !lAmbos,"GFP",cPaisLoc) + cRotNum )
		IF FindFunction( cFunction )
			bFunc := __ExecMacro( "{ || " + cFunction + "(cRoteiro , c__Roteiro , @aRoteiro, @aSYPMemo) }" )
			Eval( bFunc )
		EndIF
	Next nX

	cChave := aRotSry[ aScan( aRotSry , { |x, y| x[ nPosCalculo ] == c__Roteiro } ) , nPosVersao ]

	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Efetua a Geracao dos Roteiros Padroes    					   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	lRet := FCriaRoteiro( cFilSRM , c__Roteiro , aRotPadrao , cChave , aSRMHeader, aSYPMemo, aSYPHeader, @aIdErro, lGP290REPL, aRotBkp, aSRYHBKP, aSRMHBkp, aSYPHBkp, lForcaComp )

Else

	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Caso contrario Retorna apenas o aRotPadrao					³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	lRet := lPadrao

EndIF

If lGP290REPL .And. lPadrao .And. !Empty(aRotSRY)
	aRotBkp 	:= aClone(aRotSRY)
	aSRYHBKP 	:= aClone(aSRYHeader)
	aSRMHBkp 	:= aClone(aSRMHeader)
	aSYPHBkp 	:= aClone(aSYPHeader)
EndIf

Return( lRet )

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o	 ³ FCriaRoteiro	    ³ Autor	J. Ricardo	    ³ Data ³		  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Grava Roteiro no SRM 									  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Function FCriaRoteiro(cFil, cTipo, aRotPadrao, cChave, aSRMHeader, aSYPMemo, aSYPHeader, aIdErro, lGP290REPL, aRotBkp, aSRYHBKP, aSRMHBkp, aSYPHBkp, lForcaComp)

Local aRotUsua	:= {}
Local aRotNovo	:= {}
Local aMemoBco  := {}

Local cKey
Local cCampo
Local cAlias	:= "SRM"
Local cDesc		:= ""
Local cPergunt  := ""
Local cSeq		:= ""
Local cCliChave := "000"
Local cSryAlias	:= ""
Local cSryOrdinar:=""
Local cSryTipo	:= ""
Local cCodObs	:= ""
Local cSrySeqFil:= ""
Local cIdAux	:= ""
Local cVerbAux	:= ""
Local cSryContab:= ""
Local cSryModulo:= ""
Local cFilAux	:= ""

Local lRet		:= .T.
Local lRevisao := .F.
Local lNovo		:= .F.
Local nX 		:= 0.00
Local nY		:= 0.00
Local nReg		:= 0.00
Local nRoteiro	:= 0.00
Local nPosRot	:= 0.00
Local nTamSeq   := TamSX3( "RM_SEQ    ")[1]
Local nPosArr
Local nPosSYPFilial
Local nPosSYPChave
Local nPosSYPSeq
Local lSRYModulo:= SRY->(ColumnPos("RY_MODULO")) > 0

DEFAULT aIdErro 	:= {}
DEFAULT aRotBkp		:= {}
DEFAULT aSRYHBKP	:= {}
DEFAULT aSRMHBkp	:= {}
DEFAULT aSYPHBkp	:= {}
DEFAULT lGP290REPL 	:= .F.
DEFAULT lForcaComp  := .F.

Begin Sequence

	nPosSYPFilial	:= GdFieldPos ( "YP_FILIAL" , aSYPHeader )
	nPosSYPChave 	:= GdFieldPos ( "YP_CHAVE" , aSYPHeader )
	nPosSYPSeq		:= GdFieldPos ( "YP_SEQ" , aSYPHeader )
	nPosSYPTexto	:= GdFieldPos ( "YP_TEXTO" , aSYPHeader )

	cTipo := Upper( AllTrim( cTipo ) )
	IF ( nPosRot := aScan( aRotPadrao , { |x| x[1] == cTipo } ) ) > 0.00
		cDesc 		:= aRotPadrao[ nPosRot , 2 ]
		cSryAlias	:= aRotPadrao[ nPosRot , 3 ]
		cSryOrdinar	:= aRotPadrao[ nPosRot , 4 ]
		cSryTipo	:= aRotPadrao[ nPosRot , 5 ]
		cCodObs		:= aRotPadrao[ nPosRot , 6 ]
		cPergunt	:= aRotPadrao[ nPosRot , 7 ]
		cIntegra	:= aRotPadrao[ nPosRot , 8 ]
		cSryContab  := aRotPadrao[ nPosRot , 9 ]
		cSryModulo  := aRotPadrao[ nPosRot ,10 ]
	EndIF

	cFil := xFilial( "SRY" , cFil )

	dbSelectArea("SRY")
	lNovo := !(SRY->( dbSeek ( cFil + cTipo ) ))
	If !Empty(SRY->RY_VERSAO)
		cCliChave := SRY->RY_VERSAO
	EndIf

	dbSelectArea("SRM")
	// Avalia se necessita de Revisao
	If SRM->( dbSeek ( cFil + cTipo ) )
		While SRM->(;
						!Eof();
						.and.;
						( ( RM_FILIAL + RM_CALCULO ) == ( cFil + cTipo ) );
					)
			IF (;
					SRM->( Val( RM_SEQ ) % 10 == 0);
					.and.;
					( Val(cCliChave) < Val(cChave) );
				)
				lRevisao := .T.
				Exit
			EndIF
			SRM->( dbSkip() )
		EndDo
		IF !( lRevisao ) .and. !lForcaComp
			lRet := .T.
			Break
		EndIF
		SRM->( dbSeek( cFil + cTipo ) )
		While SRM->(;
						!Eof();
						.and.;
						( ( RM_FILIAL + RM_CALCULO ) == ( cFil + cTipo ) );
					)

			cSeq := StrZero( Val( SRM->RM_SEQ ) , nTamSeq )

			nReg++
			aAdd( aRotUsua, {} )
			For nX := 1 To Len(aSRMHeader)
				If aSRMHeader[nX, 2] == "RM_SEQ"
					aAdd(aRotUsua[nReg], cSeq)
				Else
					aAdd( aRotUsua[nReg] , SRM->( FieldGet( FieldPos( aSRMHeader[nX, 2] ) ) ) )
				EndIf
			Next nX

			SRM->( dbSkip() )
		EndDo

		cSrySeqFil := ""
		If Empty(SRY->RY_SEQFIL)
			cSrySeqFil := GetSrySeqFil(cFil)
		EndIf

		RecLock("SRY",lNovo,.T.)

		SRY->RY_FILIAL	:= If(lNovo,cFil,SRY->RY_FILIAL)
		SRY->RY_CALCULO	:= If(lNovo,cTipo,SRY->RY_CALCULO)
		SRY->RY_DESC	:= If(lNovo,cDesc,SRY->RY_DESC)
		SRY->RY_ORIGEM 	:= If(lNovo,"1",SRY->RY_ORIGEM)
		SRY->RY_CODOBS 	:= If(lNovo,cCodObs,SRY->RY_CODOBS)

		SRY->RY_VERSAO	:= cChave
		SRY->RY_RECOMP	:= "1"	//Forca a Recompilacao do Roteiro
		SRY->RY_TIPO 	:= cSryTipo
		SRY->RY_ORDINAR	:= cSryOrdinar
		SRY->RY_ALIAS	:= cSryAlias
		SRY->RY_DESC	:= cDesc
		SRY->RY_PERGUNT	:= cPergunt
		If !Empty(cSrySeqFil)
			SRY->RY_SEQFIL	:= cSrySeqFil
		EndIf
		If SRY->RY_CODOBS <> cCodObs
			cCodObs := SRY->RY_CODOBS
		EndIf
		SRY->RY_INTEGRA := cIntegra
		SRY->RY_CONTAB := cSryContab
		If lSRYModulo
			SRY->RY_MODULO := cSryModulo
		EndIf
		SRY->( MsUnLock() )

		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Gravacao e/ou alteracao das observacoes              		   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		If !Empty(aSYPMemo)
			DbSelectArea( "SYP" )
			DbSetOrder( 1 ) // YP_FILIAL+YP_CHAVE+YP_SEQ

			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Armazenar para verificar se existe necessidade de excluir    ³
			³ algum item do banco de dados.                                ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			cKey := aSYPMemo[ 1, nPosSYPFilial] + cCodObs
			DbSeek( cKey, .F. )
			While !Eof() .and. SYP->(YP_FILIAL+YP_CHAVE) == cKey
				aAdd( aMemoBco, { SYP->YP_FILIAL, SYP->YP_CHAVE, SYP->YP_SEQ, "" } )
				DbSkip()
			EndDo

			For nX := 1 To Len( aSYPMemo )
				cKey := aSYPMemo[ nX, nPosSYPFilial] + cCodObs + aSYPMemo[ nX, nPosSYPSeq]
				DbSeek( cKey, .F. )
				If SYP->( Eof() )
					RecLock("SYP",.T.,.T.)
				Else
					RecLock("SYP",.F.,.T.)
				EndIf
				For nY := 1 To Len( aSYPHeader )
					cCampo := aSYPHeader[ nY, 2 ]
					If cCampo == "YP_CHAVE"
						SYP->( &cCampo ) := cCodObs
					Else
						SYP->( &cCampo ) := aSYPMemo[nX,nY]
					EndIf
				Next nY
				SYP->( MsUnLock() )
				nPosArr := ascan( aMemoBco, { | x, y| x[1] == aSYPMemo[ nX, nPosSYPFilial] .and. x[2] = cCodObs .and. x[3] == aSYPMemo[ nX, nPosSYPSeq] })
				If nPosArr > 0
					aMemoBco[nPosArr, 4] := "1"
				EndIf
			Next nX

			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Excluir da Tabela os itens que nao necessitam mais 		   ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			If Len( aSYPMemo ) < Len( aMemoBco )
				For nX := 1 To Len( aMemoBco )
					If aMemoBco[nX, 4] == "1"
						Loop
					Else
						cKey := aMemoBco[nX, 1] + aMemoBco[nX, 2] + aMemoBco[nX, 3]
						DbSeek( cKey, .F. )
						If !Eof()
							RecLock("SYP",.F.,.T.)
							SYP->( dbDelete() )
							SYP->( MsUnLock() )
						EndIf
					EndIf
				Next nX
			EndIf
		EndIf
	EndIF

	IF Len(aRotUsua) > 0
		IF !FReorRot( @aRoteiro , @aRotUsua , nTamSeq , aSRMHeader )
			lRet := .F.
			Break
		EndIF
		aRotNovo := aClone(aRotUsua)
	Else
		aRotNovo := aClone(aRoteiro)
	EndIF

	dbSelectArea(cAlias)

	cFilAux := MyRandon(Len(cFilAnt))

	While SRM->( dbSeek( cFil + cTipo , .F. ) )
		IF RecLock( cAlias , .F. , .T. )
			SRM->RM_FILIAL := cFilAux
			SRM->( MsUnlock() )
		Else
			lRet := .F.
			Break
		EndIF
	EndDo

    // Ajustado a ordem de gravacao(integridade). Primeiro Pai(SRY) e depois a tabela filho(SRM).
	IF SRY->( !dbSeek( cFil + cTipo , .F. ) ) .And. !(cTipo == fGetCalcRot("5") .And. cPaisLoc == "PAR") // cTipo == "131"
		cSrySeqFil := GetSrySeqFil(cFil)
		RecLock("SRY",.T.,.F.)
		SRY->RY_FILIAL	:= cFil
		SRY->RY_CALCULO	:= cTipo
		SRY->RY_DESC	:= cDesc
		SRY->RY_ORIGEM 	:= "1"
		SRY->RY_VERSAO 	:= cChave
		SRY->RY_ALIAS	:= cSryAlias
		SRY->RY_ORDINAR	:= cSryOrdinar
		SRY->RY_TIPO	:= cSryTipo
		SRY->RY_RECOMP	:= "1"	//Forca a Recompilacao do Roteiro
		SRY->RY_CODOBS 	:= cCodObs
		SRY->RY_PERGUNT	:= cPergunt
		SRY->RY_SEQFIL	:= cSrySeqFil
		SRY->RY_INTEGRA	:= cIntegra
		SRY->RY_CONTAB  := cSryContab
		If lSRYModulo
			SRY->RY_MODULO := cSryModulo
		EndIf
		SRY->( MsUnLock() )

		If !Empty(aSYPMemo)
			DbSelectArea( "SYP" )
			DbSetOrder( 1 ) // YP_FILIAL+YP_CHAVE+YP_SEQ
			cKey := aSYPMemo[ 1, nPosSYPFilial] + aSYPMemo[ 1, nPosSYPChave]
			DbSeek( cKey, .F. )
			If !Eof()
				cCodObs := GetSX8Num("SYP","YP_CHAVE")
				ConfirmSX8()
			Else
				cCodObs	 := aSYPMemo[ 1, nPosSYPChave]
			EndIf
			For nX := 1 To Len( aSYPMemo )
				RecLock("SYP",.T.,.T.)
				For nY := 1 To Len( aSYPHeader )
					cCampo := aSYPHeader[ nY, 2 ]
					If cCampo == "YP_CHAVE"
						SYP->( &cCampo ) := cCodObs
					Else
						SYP->( &cCampo ) := aSYPMemo[nX,nY]
					EndIf
				Next nY
				SYP->( MsUnLock() )
			Next nX
			If SRY->RY_CODOBS <> cCodObs
				RecLock("SRY",.F.,.T.)
				SRY->RY_CODOBS := cCodObs
				SRY->( MsUnLock() )
			EndIf
		EndIf
	EndIF

	For nRoteiro := 1 To Len(aRotNovo)
		IF SRM->( dbSeek(cFilAux) )
			RecLock(cAlias,.F.)
			lNovo := .F.
		Else
			RecLock(cAlias,.T.)
			lNovo := .T.
		EndIF
		For nX := 1 To Len(aSRMHeader)
			If aSRMHeader[nX, 2] == "RM_FILIAL"
				SRM->RM_FILIAL	:= cFil
			ElseIf aSRMHeader[nX, 2] == "RM_VERBA"
				cCampo   := Upper(aSRMHeader[nX, 2])
				cIdAux 	 := aRotNovo[nRoteiro, GdFieldPos( cCampo , aSRMHeader ) ]
				If !Empty(cIdAux)
					cVerbAux := FGetCodFol(cIdAux)
					If Empty(cVerbAux)
						aAdd(aIdErro,(cIdAux + " - " + FGetCodFol(cIdAux,,,.T.)))
					EndIf
				Else
					cVerbAux := ""
				EndIf
				SRM->( FieldPut( FieldPos( cCampo ) , cVerbAux ) )
			Else
			   	cCampo := Upper(aSRMHeader[nX, 2])
			   	If !(Alltrim(aRotNovo[nRoteiro, GdFieldPos( "RM_FORMULA" , aSRMHeader )]) == "S_MULTV()" .And. Alltrim(cCampo) == "RM_HABILIT" .And. !lNovo)
			   		SRM->( FieldPut( FieldPos( cCampo ) , aRotNovo[nRoteiro, GdFieldPos( cCampo , aSRMHeader ) ] ) )
			   	EndIf
			Endif
		Next nX
		SRM->( MsUnlock() )
	Next nRoteiro

	SRM->( dbSeek(cFilAux) )
	While SRM->( !Eof() .and. AllTrim(RM_FILIAL) == cFilAux )
		RecLock("SRM",.F.)
		SRM->( dbDelete() )
		SRM->( MsUnlock() )
		SRM->( dbSkip() )
	EndDo

	SRY->( GetFunRot( RY_FILIAL, RY_CALCULO, .T., Nil, Nil, Nil, Nil, Nil, Nil, Nil, lGP290REPL, aRotBkp, aSRYHBKP, aSRMHBkp, aSYPHBkp ) )

End Sequence

Return( lRet )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³GPEXINI   ºAutor  ³Microsiga           º Data ³  10-11-02   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Reorganiza o Roteiro                                        º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP7                                                        º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function FReorRot( aRoteiro , aRotUsua , nTamSeq , aSRMHeader )

Local nFor 		:= 0
Local nContador := 0
Local nPos      := 0
Local nLenRot 	:= 0
Local nPosChave := 0
Local nPosSeq	:= 0
Local nPosCalc  := 0
Local nPosHab	:= 0

nPosChave 	:= GdFieldPos ( "RM_CHAVE"		, aSRMHeader )
nPosSeq		:= GdFieldPos ( "RM_SEQ" 		, aSRMHeader )
nPosCalc	:= GdFieldPos ( "RM_CALCULO"	, aSRMHeader )
nPosHab		:= GdFieldPos ( "RM_HABILIT"	, aSRMHeader )

nLenRot := Len( aRoteiro )
For nFor := 1 To nLenRot
	If aRoteiro[nFor, nPosChave] = "N" // Testa se e' um novo item ou Sub-item
		If aScan(aRotUsua,{ |X| AllTrim(X[nPosChave]) == AllTrim(aRoteiro[nFor,nPosChave]) }) > 0
			Loop
		Endif
		nPos := aScan(aRotUsua,{ |X| X[nPosSeq] = aRoteiro[nFor,nPosSeq] })
		If nPos > 0
			For nContador := nPos To Len(aRotUsua)
				// Se a sequencia for maior que a sequencia
				// onde foi incluso o sub-item sai do for
				If aRoteiro[nFor,nPosSeq] > aRotUsua[nContador, nPosSeq]
					Loop
				Endif
				aRotUsua[ nContador , nPosSeq ] = StrZero(Val(aRotUsua[nContador, nPosSeq]) + 10 , nTamSeq )
			Next
		EndIf
		// Adiciona o Novo item ou sub-item
		aAdd(aRotUsua,aClone( aRoteiro[ nFor ] ) )
	Endif
Next

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Carrega no Roteiro Padrao os Roteiros do Usuario     		   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
nLenRot := Len( aRotUsua )
For nFor := 1 To nLenRot
	IF Val( aRotUsua[ nFor , nPosSeq ] ) % 10 != 0.00
		aAdd( aRoteiro , aClone( aRotUsua[ nFor ] ) )
	//-- Verifica se Rot. do usuario estava Desabilidato e mantem na atualizacao
	Elseif aRotUsua[nFor, nPosHab] == "2" .and. !Empty(aRotUsua[nFor, nPosChave])
		nPos := aScan(aRoteiro,{ |x| AllTrim(x[10]+x[2]) == AllTrim(aRotUsua[nFor, nPosCalc]+aRotUsua[nFor,nPosChave])})
		If nPos > 0
			aRoteiro[nPos,nPosHab] := "2"
		Endif
	EndIF
Next nFor

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Carrega o Flag de Roteiro Habilitado                 		   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
aEval( aRoteiro , { |x| IF( !( x[nPosHab] == "2" ) , x[nPosHab] := "1" , NIL ) } )

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ O Roteiro do Usuario Passa a Ser uma Copia do Padrao com   as³
³ alteracoes.                                                  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
aRotUsua := aClone( aRoteiro )

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Deixa a Matriz na Ordem de Sequencia + Sub-Sequencia 		   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
aRotUsua := aSort(aRotUsua,,,{ |x,y| x[nPosSeq] < y[nPosSeq] } )

Return( .T. )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³GpeRstCache		³ Autor ³Marinaldo de Jesus³ Data ³30/01/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Executa as Rotinas de Inicializacao de variaveis em Cache	 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL                                                    	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Uso      ³Generico                                                     ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function GpeRstCache()

IF ( FindFunction( "fSrvStatic" ) )
	fSrvStatic()
EndIF

IF ( FindFunction( "RstfVerbas" ) )
	RstfVerbas()
EndIF

IF ( FindFunction( "RstExecCalc" ) )
	RstExecCalc()
EndIF

IF FindFunction( "RstRetOrdem" )
	RstRetOrdem()
EndIF

IF FindFunction("ApdCacheClear")
	ApdCacheClear()
EndIF

IF FindFunction("RstGpexIni")
	RstGpexIni()
EndIF

IF FindFunction("RstXMED")
    RstXMED()
EndIf

Return( NIL )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³RstGpexIni	  ³Autor ³Marinaldo de Jesus   ³ Data ³24/11/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Reinicializar as Static utilizadas no GPEXINI  toda vez   que³
³          ³Retornar ao Menu											 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL                                                    	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico 													 ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function RstGpexIni()

aTab_Fol	:= {}				//Array com as Tabelas da Folha
aRot13      := {}				//Array contendo o roteiro a ser executado (13o.)
cTurnoAnt	:= "__cTnoAnt__"	//Turno Anterior
nTamFilAux  := FwGetTamFilial

If ValType(oHash_Tab) == "O"
	HMClean(oHash_Tab)
	FreeObj(oHash_Tab)
	oHash_Tab := Nil
EndIf

Return( NIL )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³InGpexIniExec ³Autor ³Marinaldo de Jesus   ³ Data ³24/08/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Executar Funcoes Dentro de GPEXINI                           ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³InGpexIniExec( cExecIn , aFormParam )						 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³uRet                                                 	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico 													 ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function InGpexIniExec( cExecIn , aFormParam )

Local uRet

DEFAULT cExecIn		:= ""
DEFAULT aFormParam	:= {}

IF !Empty( cExecIn )
	cExecIn	:= BldcExecInFun( cExecIn , aFormParam )
	uRet	:= __ExecMacro( cExecIn )
EndIF

Return( uRet )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³IniaCodFol	   ³Autor³Marinaldo de Jesus  ³ Data ³15/11/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Funcao para Inicializacao do Mnemonico aCodFol              ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³IniaCodFol( cFil )	 									    ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³cFil														³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Inicializacao do Mnemonico aCodFol		                    ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function IniaCodFol( cFil )

Local aCodFol := {}

DEFAULT cFil := cFilAnt

If !fp_CodFol( @aCodFol , cFil, .F. )
	aCodFol := {}
EndIf

Return( aClone( aCodFol ) )

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFuncao    ³fC13MaternºAutor  ³Natie               º Data ³  30/10/03   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Calcula Valor 13o Salario Ref.avos de Lic.Maternidade       º±±
±±º          ³e o Adiciona na Base INSS de 13o Salario                    º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³ cTipo => Tipo de Processo                                  º±±
±±º          ³          "R" - Rescisao                                    º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ SIGAGPE                                                    º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Function fC13Matern()

Local 	nAvos_OQ 	:= 0
Local 	n13AvInd 	:= 0
Local 	nBaseInss	:= 0

Private	aTInss13	:= aClone(aTInss)          			 // Tabela de Inss

//-- Se roteiro de rescisao, abater avo indenizado para depois calcular Base INSS
aEval( aAfast ,{ |X| nAvos_OQ += If( X[5] $ "Q", X[1], 0 ) })
//-- Para acidente de trabalho nao utilizamos os avos de afastamento para refazer a base de inss,
//-- conforme intrucao do RPS art.214 paragrafo 6o. e 7o:
//-- Contribuicao Previdenciaria: sobre o valor integral da gratificacao natalina quando do pagamento ou credito da
//-- ultima parcela ou na rescisao do contrato de trabalho. Boletim IOB 47/2003 pg.15.
If nAvos_OQ > 0
	//-- 13§ Sobre Aviso Previo
	aEval( aPd ,{ |X| n13AvInd  += If ( X[1]==aCodFol[115,1] .And. X[9] # "D" ,X[5] ,0)})
	//-- Base Inss Ate Lim p/ 13o. Sal./ Base Inss Acima Lim p/ 13o. Sal
	aEval( aPd ,{ |X| nBaseInss += If ( x[1] $ aCodFol[19,1]+"*"+aCodFol[20,1] .And. X[9] # "D",x[5],0.00) })

	If n13AvInd > 0 .And. RetValSrv(aCodFol[115,1],SRA->RA_FILIAL,"RV_INSS") == "S"
		nBaseInss 	-= n13AvInd
		nBaseInss	:= Max(nBaseInss,0)
	Endif

	//-- Se houver Base de INSS s/13 Salario,  proporcionaliza para achar o valor do 13o Salario Sal.Maternidade/Acidente e
	//-- adiciona-o na BAse de Inss 13o
	If nBaseInss > 0 .and. nAvos > 0
		nBaseInss := Round( ( fRetDec(@nBaseInss) / nAvos ) * nAvos_OQ , 2 )
		fSCAfas(  nBaseInss , .T.  )
	Endif
Endif

Return( NIL )

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFuncao    ³fGeraAdtS ºAutor  ³Emerson Rosa        º Data ³  15/07/04   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDescricao ³Gera os adicionais por tempo de servico no aPd.             º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³cCodAdt   - Codigo do Adicional por tempo de servico        º±±
±±º          ³nAdtServ  - Valor total do adicional (Anuenio + Bienio +...)º±±
±±º          ³nTDiasMes - Total de dias do mes (normalmente 30)			  º±±
±±º          ³nDiasProp - Dias para a proporcionalizacao				  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ SIGAGPE                                                    º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Function fGeraAdtS(cCodAdt,nAdtServ,nTDiasMes,nDiasProp,cRotCalc)
Local nCnt
Local cRotAux := fGetCalcRot("4")

DEFAULT cRotCalc := "   "

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Se existir o array gera todos os adicionais					 ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If Type( "aAdtServ" ) # "U" .And. Len( aAdtServ ) > 0
	For nCnt := 1 To Len(aAdtServ)
		If ( cRotCalc == cRotAux .Or. RetValSrv(aAdtServ[nCnt,1], SRA->RA_FILIAL,"RV_INCORP") # "S" ) .And.; // If cRotCalc == "RES"
		   aScan(aPd,{ |X| X[1] == aAdtServ[nCnt,1] .And. X[9] # "D" } ) == 0
			FGeraVerba(aAdtServ[nCnt,1],Round( ( aAdtServ[nCnt,3] / nTDiasMes ) * nDiasProp,2))
		EndIf
	Next nCnt
ElseIf nAdtServ > 0 .And. ( cRotCalc == cRotAux .Or. RetValSrv(cCodAdt, SRA->RA_FILIAL,"RV_INCORP") # "S" ) .And.; // If cRotCalc == "RES"
       aScan(aPd,{ |X| X[1] == cCodAdt .And. X[9] # "D" } ) == 0
	fGeraVerba(cCodAdt,Round((nAdtServ / nTDiasMes) * nDiasProp,2))
EndIf

Return( NIL )

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFuncao    ³ fChkBsIr ºAutor  ³Emerson Rosa        º Data ³  05/08/04   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDescricao ³Checa a existencia de verbas com incidencia do Ir           º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³ aPd - Array com as verbas que serao checadas				  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ SIGAGPE                                                    º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Function fChkBsIr(aPd,DiasTrab,dData_pgto,cRoteiro)
Local lRet    := .F.
Local nBaseIr := 0
Local lIrNeg	:= Len(aCodFol) >= 1726 .And. !Empty(aCodFol[1726,1]) .And. !Empty(aCodFol[1727,1])

DEFAULT cRoteiro := fGetCalcRot("1") //"FOL"

If cRoteiro == fGetCalcRot("2") //"ADI"
	If ( aScan( aPd, { |X| X[1] == aCodFol[106,1] } ) == 0 ) .And.;
	   ( RetValSrv(aCodfol[006,1],SRA->RA_FILIAL,"RV_IR") == "S" )
		lRet := .T.
	EndIf
	If !lRet .And. lIrNeg
		If ( aScan( aPd, { |X| X[1] == aCodFol[1727,1] } ) == 0 ) .And.;
		   ( RetValSrv(aCodfol[006,1],SRA->RA_FILIAL,"RV_IR") == "S" )
			lRet := .T.
		EndIf
	EndIf
ElseIf cRoteiro == fGetCalcRot("4") //"RES"
	If ( aScan( aPd, { |X| X[1] == aCodFol[106,1] } ) == 0 )
		lRet := .T.
	EndIf
	If !lRet .And. lIrNeg
		If ( aScan( aPd, { |X| X[1] == aCodFol[1727,1] } ) == 0 )
			lRet := .T.
		EndIf
	EndIf
Else
	If DiasTrab > 0 .And. !( SRA->RA_CATFUNC $ "A*P" )
		lRet := .T.
	Else
		aEval( aPd ,{ |X| IF(X[3] <= cSemana .And. X[1] # aCodFol[151,1],SomaInc(X,5,@nBaseIr,11,"N",12,"N",Month(dData_pgto),,aCodFol),Nil) } )
		lRet := ( nBaseIr > 0 )
	EndIf
EndIf

Return( lRet )

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFuncao    ³fBsGComis ºAutor  ³Emerson Rosa        º Data ³  30/09/04   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDescricao ³Funcao para montagem do valor total de comissao             º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³ 															  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ SIGAGPE                                                    º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Function fBsGComis(aPd, nTotComiss, aCodFol)

aEval( aPd ,{ |X| SomaInc(X,1,@nTotComis, , , , , , ,aCodFol) })

Return( NIL )

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³CarParam  ºAutor  ³Microsiga           º Data ³  03/06/01   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Carrega parametros Sx6 conforme Filial 					  º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP5                                                        º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Function FCarParam(cFilPar)

Local cFilAtual := cFilAnt

cFilAnt := cFilPar

cAboAnt 	:= GetMvRH("MV_ABOPEC")    			// Parametro para abono antes das ferias
cAboAnt 	:= If(cAboAnt =="S","1","2")
cCalcInf 	:= GetMvRH("MV_CALCINF")
nValArred 	:= GetMvRH("MV_ARREDFO")           	// Arredondamento da folha
cChkSem   	:= GetMvRH("MV_GPCHSEM")
nValArr13 	:= GetMvRH("MV_ARRED13")				// Arredondamento do 13o. salario
nValArrAd   := GetMvRH("MV_ARREDAD")           	// Arredondamento do Adiantamento
nValArrFe	:= GetMvRH("MV_ARREDFE")            	// Arredondamento de Ferias
cMedDir   	:= P_MEDDIREN			           	// Medias de direito
cAbatAfas 	:= GetMvRH("MV_ABATAFA")          	// Abate avos no 13o. salario
cPgSalMat 	:= GetMvRH("MV_PGSALMA")           	// Paga Salario Maternidade
cInssFM	  	:= GetMvRH("MV_DINSSFM")	 			// Desc.Inss Ferias MS
cCompMes    := GetMvRH("MV_COMPMES") 			// Carrega parametro composicao do mes
cAdtoPro    := GetMvRH("MV_ADTOPRO")           	// Calcula Adiantamento Proporcional
cDif13Neg 	:= GetNewPar("MV_DF13NEG","S")        	// Gerar diferenca de 13o. negativa S/N
lMAprendiz  := GetMvRH("MV_MAPREND", .F., .F.) 	// Calculo do Menor Aprendiz

cFilAnt := cFilAtual

Return(.T.)

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFuncao    ³fChkTurno ºAutor  ³Emerson Rosa        º Data ³  13/08/04   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDescricao ³ Busca a composicao do mes no turno do funcionario		  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³ 															  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ SIGAGPE                                                    º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Function fChkTurno()

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Busca composicao do mes do parametro turno de trabalho		 ³
//³ se estiver zerado, considera parametro normal				 ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
cTurnoAnt := SRA->RA_FILIAL+SRA->RA_TNOTRAB

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Funcao para Carregar o Array aSemanas						 ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If !fCarPeriodo( cPeriodo , cRot , @aPeriodo , @lUltSemana , @nPosSem )
	nRet := 3
Else
	Normal   :=  aPeriodo[nPosSem,14]
	Descanso :=  aPeriodo[nPosSem,13]
EndIf

If Normal == 0 .Or. Descanso == 0
	If GetRemoteType() == -1
		MsgLogGrid( Ap5GetHelp("GPMSHNODE"), .F. )
	Else
		HELP(' ',1,"GPMSHNODE")
	EndIf
	lFinalCalc := .T.
EndIf

Return Nil

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³fCarTab(aTabelas)³Autor³Mauro Sergio       ³Data ³21/07/2002³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Carregar Tabelas no array para calculo                      ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³fCarTab( aTabelas )		       								³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Uso      ³Calculo Gpexcal1 Gpexcalc                                   ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Retorno  ³       														³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³aTabelas -> Array com a carga da tabela       				³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function fCarrTab( aTabFol, cTab, dDataRef, lOnlyTab, cAnoMes, lCarNew, cFil )

Local aCabTab 	:= {}
Local aSvTabFol	:= aClone( aTab_Fol )
Local aOnlyTab  := {}
Local cFilRcc	:= "" //Determina Filial Pesquisa Rcc
Local cAnoMesRef:= ""
Local nPosIni	:= 0
Local nColAte	:= 0
Local nTamCpo 	:= 0
Local cConteudo	:= ""
Local nT 		:= 0
Local nFound	:= 0
Local nX        := 0
Local lRet      := .T.
Local cAliasRCC := "RCC"
Local cOrdem 	:= "%RCC.RCC_FILIAL,RCC.RCC_CODIGO,RCC.RCC_FIL,RCC.RCC_CHAVE,RCC.RCC_SEQUEN%"
Local cWhere 	:= ""
Local cWhereAux := ""
Local cContTmp	:= ""

DEFAULT lOnlyTab := .F.
// Ativar flag caso a rotina mae esteja atualizando a tabela
// durante o processo e existe a adicao de novos itens na
// tabela RCC e estes precisam ser atualizados/inclusos no array aTab_Fol
DEFAULT lCarNew := .F.
DEFAULT cFil    := xFilial("SRA")

Static aRCBS033  := {}
Static oStRCC
Static __cEmpAnt := cEmpAnt

If cTab == "S033"
	If lIniS033
		GpIniTab()
		lIniS033 := .F.
	EndIf
	RstGpexIni()
EndIf

//--Determina Filial de Busca da tabela RCB
dbSelectArea("RCB")
cFilRcb := xFilial("RCB",cFil)

//--Determina Filial Pesquisa RCC
dbSelectArea("RCC")
cFilRcc := xFilial("RCC",cFil)

//--Determina Data a ser Carregada
dDataRef := If (dDataRef == Nil, dDataBase,dDataRef)

//--Determina o Ano Mes a ser Carregado
cAnoMesRef := If (cAnoMes == Nil, AnoMes(dDataRef), cAnoMes)

nFound := aScan(aTab_Fol, { |x| x[1]= cTab } )

If nFound == 0  .Or. lCarNew

	//--Monta a clausula where para query da RCC
	If cTab == "S052"
		cWhere := "%(RCC.RCC_FIL = '" + cFil + "' OR  RCC.RCC_FIL = '"+Space(TamSx3("RCC_FIL")[1])+"') AND RCC.RCC_CODIGO = '" + cTab + "'"
	Else
		cWhere := "%RCC.RCC_FILIAL = '" + cFilRcc + "' AND RCC.RCC_CODIGO = '" + cTab + "'"
	EndIf

	If cTab == "S033" .AND. Substr(cAnoMesRef,5,6) == "12" .AND. Type("cTipoRot") <> "U" .And. cTipoRot = "6" //caso seja 132, busca valor acumulado em AAAA13 para compor aliquota corretamente
		cWhere += " AND RCC.RCC_CHAVE = '" + Substr(cAnoMesRef,1,4)+"13" + "'"
	ElseIf cTab $ "S033*S035"
		If cPaisLoc == "ARG"
			cWhereAux := cWhere + " AND RCC.RCC_CHAVE = '' %"
		EndIf
		cWhere += " AND RCC.RCC_CHAVE = '" + cAnoMesRef + "'"
	EndIf
	If cPaisLoc == "ARG" .and. !(cTab $ "S033*S035")
		cWhereAux := cWhere + " AND RCC.RCC_CHAVE = '' %"
	EndIf
	cWhere += "%"

	//--Posiciona no Primeiro Elemento do Cabecalho da Tabela
	dbSelectArea("RCB")
	DbSetOrder(1)
	If !dbSeek(cFilRcb+cTab)
		lRet := .F.
	Else
		While ! Eof()

			If cTab # RCB->RCB_CODIGO
				Exit
			Endif

			//--Carrega o Cabecalho da Tabela
			//Caso seja a tabela S033, guarda a estrutura da RCB p/ não verificar toda vez
			If cTab != "S033" .Or. (cTab == "S033" .And. Empty(aRCBS033))
				//--Carrega o Cabecalho da Tabela
				aCabTab := {}
				While ! Eof() .And. cTab == RCB->RCB_CODIGO
					If !(cTab == "S042" .And. AllTrim(RCB_CAMPOS) == "Sequencia" .AND. cPaisLoc == "BRA")
						RCB->(Aadd(aCabTab,{RCB_CAMPOS,RCB_TIPO,RCB_TAMAN,RCB_DECIMA}))
					EndIf
					dbSelectArea("RCB")
					dbSkip()
				Enddo
				If cTab == "S033"
					aRCBS033 := aClone(aCabTab)
				EndIf
			ElseIf cTab == "S033" .And. !Empty(aRCBS033)
				aCabTab := aClone(aRCBS033)
			EndIf

			cAliasRCC := "RCCQRY"

			If cPaisLoc == "ARG"
				If Select(cAliasRCC) > 0
					(cAliasRCC)->(dbCloseArea())
				EndIf
			EndIf

			If cTab == "S043"
				BeginSql Alias cAliasRCC
					SELECT RCC.*
					FROM %table:RCC% RCC
					WHERE %exp:cWhere% AND
						   RCC.%notDel%
						   AND RCC.RCC_FIL <> %exp:Space(Tamsx3("RCC_FILIAL")[1])%
				    UNION
					SELECT RCC.*
					FROM %table:RCC% RCC
					WHERE %exp:cWhere% AND
						   RCC.%notDel%
						   AND RCC.RCC_FIL = %exp:Space(Tamsx3("RCC_FILIAL")[1])%

				EndSql

			ElseIf cPaisLoc <> 'ARG'

				If oStRCC == Nil .Or. __cEmpAnt <> cEmpAnt
					If __cEmpAnt <> cEmpAnt
						RstGpexIni()
					EndIf
					__cEmpAnt := cEmpAnt
					oStRCC 	:= FWPreparedStatement():New()

					cQuery := "SELECT * FROM " + RetSqlName('RCC') + " RCC WHERE "
					cQuery += "( RCC_FIL = ? OR RCC_FIL = ? OR RCC_FILIAL = ? ) AND "
					cQuery += "RCC_CODIGO = ?  AND "
					cQuery += "D_E_L_E_T_ = ' ' "

					cQuery := ChangeQuery(cQuery)

					oStRCC:SetQuery(cQuery)
				EndIf

				If cTab == "S052"
					oStRCC:SetString(1,cFil)
					oStRCC:SetString(2,Space(TamSx3("RCC_FIL")[1]))
					oStRCC:SetString(3,"XXYYXXYYXX#%&")//Não encontrar
				Else
					cWhere := "%RCC.RCC_FILIAL = '" + cFilRcc + "' AND RCC.RCC_CODIGO = '" + cTab + "'"
					oStRCC:SetString(1,"XXYYXXYYXX#%&")//Não encontrar
					oStRCC:SetString(2,"XXYYXXYYXX#%&")//Não encontrar
					oStRCC:SetString(3,cFilRcc)
				EndIf

				oStRCC:SetString(4,cTab)

				cQuery := oStRCC:getFixQuery()

				Iif(Select(cAliasRCC) > 0, (cAliasRCC)->( dbclosearea()),Nil)

				dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasRCC)

			Else
				BeginSql Alias cAliasRCC
					SELECT RCC.*
					FROM %table:RCC% RCC
					WHERE %exp:cWhere% AND
						   RCC.%notDel%
					ORDER BY %exp:cOrdem%
				EndSql

				IF (cAliasRCC)->(Eof()) .and. cPaisLoc == "ARG" //Tratamento para RCC_CHAVE igual a branco.
					(cAliasRCC)->( dbCloseArea() )
					BeginSql Alias cAliasRCC
						SELECT RCC.*
						FROM %table:RCC% RCC
						WHERE %exp:cWhereAux% AND
							RCC.%notDel%
						ORDER BY %exp:cOrdem%
					EndSql
				EndIf
			EndIf

			//--Carregar Dados das Tabelas
			If cTab != "S052"
				While (cAliasRCC)->( ! Eof() .And. (cAliasRCC)->RCC_FILIAL+(cAliasRCC)->RCC_CODIGO == cFilRcc+cTab )

					If cPaisLoc <> "ARG"
						If cTab == "S033" .AND. Substr(cAnoMesRef,5,6) == "12" .AND. Type("cTipoRot") <> "U" .And. cTipoRot = "6"
							If (cAliasRCC)->RCC_CHAVE <> Substr(cAnoMesRef,1,4)+"13"
								(cAliasRCC)->( dbSkip() )
								Loop
							EndIf
						ElseIf cTab $ "S033*S035"
							If (cAliasRCC)->RCC_CHAVE <> cAnoMesRef
								(cAliasRCC)->( dbSkip() )
								Loop
							EndIf
						EndIf
					EndIf

			 		Aadd(aTab_Fol,{cTab,(cAliasRCC)->RCC_FIL,(cAliasRCC)->RCC_CHAVE,(cAliasRCC)->RCC_SEQUEN})
			 		Aadd(aSvTabFol,{cTab,(cAliasRCC)->RCC_FIL,(cAliasRCC)->RCC_CHAVE,(cAliasRCC)->RCC_SEQUEN})
			 		Aadd(aOnlyTab,{cTab,(cAliasRCC)->RCC_FIL,(cAliasRCC)->RCC_CHAVE,(cAliasRCC)->RCC_SEQUEN})

					nPosIni := 1
					nColAte := 1
					For nT:= 1 To Len(aCabTab)

						//--Tamanho do Campo
						nTamCpo := aCabTab[nT,3]
						cContTmp := (cAliasRCC)->RCC_CONTEU
						If cTab == "S042" .and. Len(alltrim(cContTmp)) >= 17
							cContTmp := substr((cAliasRCC)->RCC_CONTEU,3)
						EndIf
						//--Guarda conteudo do campo na Variavel
						If aCabTab[nT,2] == "C"
							cConteudo := Subs(cContTmp,nPosIni,nTamCpo)
						ElseIf aCabTab[nT,2] == "N"
							cConteudo := Val(Subs(cContTmp,nPosIni,nTamCpo))
						ElseIf aCabTab[nT,2] == "D"
							cConteudo := Subs(cContTmp,nPosIni,nTamCpo)
							cConteudo := If("/" $ cConteudo , CtoD(cConteudo) , StoD(cConteudo))
						Endif

				 		Aadd(aTab_Fol[Len(aTab_Fol)],cConteudo)
				 		Aadd(aSvTabFol[Len(aSvTabFol)],cConteudo)
				 		Aadd(aOnlyTab[Len(aOnlyTab)],cConteudo)

						//--Posicao Proximo Campo
						nPosIni += nTamCpo
					Next nT

					(cAliasRCC)->( dbSkip() )
				Enddo
			Else

				While (cAliasRCC)->(!Eof()) .And. (cAliasRCC)->RCC_CODIGO == cTab

					If ( (cAliasRCC)->RCC_FIL == cFil  .or. Empty((cAliasRCC)->RCC_FIL))

				 		Aadd(aTab_Fol,{cTab,(cAliasRCC)->RCC_FIL,(cAliasRCC)->RCC_CHAVE,(cAliasRCC)->RCC_SEQUEN})
				 		Aadd(aSvTabFol,{cTab,(cAliasRCC)->RCC_FIL,(cAliasRCC)->RCC_CHAVE,(cAliasRCC)->RCC_SEQUEN})
				 		Aadd(aOnlyTab,{cTab,(cAliasRCC)->RCC_FIL,(cAliasRCC)->RCC_CHAVE,(cAliasRCC)->RCC_SEQUEN})

						nPosIni := 1
						nColAte := 1
						For nT:= 1 To Len(aCabTab)

							//--Tamanho do Campo
							nTamCpo := aCabTab[nT,3]

							//--Guarda conteudo do campo na Variavel
							If aCabTab[nT,2] == "C"
								cConteudo := Subs((cAliasRCC)->RCC_CONTEU,nPosIni,nTamCpo)
							ElseIf aCabTab[nT,2] == "N"
								cConteudo := Val(Subs((cAliasRCC)->RCC_CONTEU,nPosIni,nTamCpo))
							ElseIf aCabTab[nT,2] == "D"
								cConteudo := Subs((cAliasRCC)->RCC_CONTEU,nPosIni,nTamCpo)
								cConteudo := If("/" $ cConteudo , CtoD(cConteudo) , StoD(cConteudo))
							Endif

					 		Aadd(aTab_Fol[Len(aTab_Fol)],cConteudo)
					 		Aadd(aSvTabFol[Len(aSvTabFol)],cConteudo)
					 		Aadd(aOnlyTab[Len(aOnlyTab)],cConteudo)

							//--Posicao Proximo Campo
							nPosIni += nTamCpo
						Next nT
					EndIf

					(cAliasRCC)->( dbSkip() )
				Enddo
			EndIf

			(cAliasRCC)->( dbCloseArea() )

			If cTab == "S033"
				dbSelectArea("RCB")
				Exit
			Else
				dbSelectArea("RCB")
				dbSkip()
			EndIf
		Enddo
	EndIf
Else
	For nX := 1 To Len( aTab_Fol )
		//# Verifica se a tabela ainda nao existe
		If aTab_Fol[nX, 1] == cTab
		    If aScan(aSvTabFol, { |x| x[1]= cTab } ) == 0
				aAdd( aSvTabFol, aClone( aTab_Fol[nX] ) )
			EndIf
			aAdd( aOnlyTab, aClone( aTab_Fol[nX] ) )
		EndIf
	Next nX
EndIf

If lOnlyTab
	aTabFol := aClone(aOnlyTab)
Else
	aTabFol := aClone(aSvTabFol)
EndIf

If ValType(oHash_Tab) == "O"
	HMClean(oHash_Tab)
	FreeObj(oHash_Tab)
	oHash_Tab := Nil
EndIf

//Melhoria de performance, criação de hash
oHash_Tab := AToHM(aTab_Fol, 1, 0, 2, 0, 3, 0, 4, 0)

Return lRet

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³fTabela()		 ³Autor³Mauro Sergio       ³Data ³21/07/2002³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Retornar Conteudo de uma tabela criada                      ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³fTabela( cCodTab,nLinha,nColuna )		       				³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Uso      ³Calculo Gpexcal1 Gpexcalc                                   ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Retorno  ³       														³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³cCodTab 	= Codigo da tabela                         	    ³
³          ³nLinhaTab  	= Linha a ser retornada                    	    ³
³          ³nColTab 	= Coluna a Ser Retornada                  	    ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function fTabela( cCodTab,nLinTab,nColTab,dDataRef,cFilTab )

Local lCarTab 	:= .F.
Local nPosTab 	:= 0
Local cResult	:= ""
Local aKey		:= {}
Local lRet		:= .F.
Local lAchou 	:= .F.
Local aLogCalc
Local aRet
Local nX		:= 0

DEFAULT cFilTab 	:= SRA->RA_FILIAL
DEFAULT nTamFilAux  := FwGetTamFilial

dDataRef	:= If (dDataref == Nil .or. Empty(dDataRef), If(Type("aPeriodo") <> "U" .and. Len(aPeriodo) > 0, aPeriodo[1][4] ,dDataBase), dDataRef)

//--Verifica a existencia do array das tabelas caso nao exista define e carrega
If ValType(aTab_Fol) # "A" .Or. Empty(aTab_Fol)
	aTab_Fol := {}
	lCarTab	 := .T.
Endif

//--Verifica se Existe a Tabela Indicada no Array se nao existir
//--Seta variavel para carregar
If Ascan(aTab_Fol,{ |x| x[1] == cCodTab}) == 0
	lCarTab := .T.
Endif

//--Carrega Tabela quando variavel lCarTab == .T.
If lCarTab
	fCarrTab( @aTab_Fol,cCodTab,dDataRef )
EndIf

aAdd(aKey, cCodTab + cFilTab + MesAno(dDataRef) + Strzero(nLinTab,3) )
aAdd(aKey, cCodTab + Space(nTamFilAux) + MesAno(dDataRef) + Strzero(nLinTab,3) )
aAdd(aKey, cCodTab + cFilTab + Space(6) + Strzero(nLinTab,3) )
aAdd(aKey, cCodTab + Space(nTamFilAux) + Space(6) + Strzero(nLinTab,3) )

For nX := 1 to Len(aKey)
	lAchou := HMGet(oHash_Tab, aKey[nX], aRet)
	If lAchou
		cResult := Iif(Len(aRet[1]) < nColTab + 1, "", aRet[1, nColTab + 1])
		lRet 	:= .T.
		Exit
	EndIf
Next nX

//-Tratamento pra Gestao Corporativa
If fIsCorpManage() .and. !lAchou
	lAchou := fVer_Fol(@nPosTab,aTab_Fol,cCodTab,dDataRef,nLinTab)
	If lAchou .And. ((nColTab+1) <= Len(aTab_Fol[nPosTab])) .AND. (aTab_Fol[nPosTab,nColTab+1] # Nil)
		cResult := aTab_Fol[nPosTab,nColTab+1]
	Else
		lRet := .F.
	EndIf
EndIf

If ! lRet
	aLogCalc := LogExecRot()
    If ValType(aLogCalc) # "U" .And. ValType(aLogCalc) == "A" .And. Len(aLogCalc) > 0
		cMsg := STR0126 +" ["+ cCodTab + "]  " + STR0127 + " [" + Strzero(nLinTab,4) + "]  " + STR0128 + " [" + StrZero(nColTab,4) + "]  " +STR0129
		AddLogExecRot( cMsg )		// adiciona no Log de Erros
	Else
		Help(" ",1,"GPETABNCAD")
	EndIf
EndIf

Return(cResult)

/*
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³ fVer_Fol()      ³Autor³ Ademar Fernandes  ³Data ³15/03/2011³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³-Verifica se a Tabela Auxiliar esta cadastrada no RCC.      ³
³          ³                                                            ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Uso      ³ Gestao Corporativa - P11                                   ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
*/
Static Function fVer_Fol(nPosTab,aTab_Fol,cCodTab,dDataRef,nLinTab)
Local lAchou := .F.
DEFAULT nLinTab := 0

	//.Combinacoes possiveis
	//.Empr / UNeg / Fil
	//.  E      E     E  (ja testado acima)
	//.  E      E     C
	//.  E      C     E
	//.  E      C     C
	//.  C      C     C  (ja testado acima)
	//.  C      C     E
	//.  C      E     C
	//.  C      E     E

	If ( nPosTab :=    Ascan(aTab_Fol,{ |x| x[1] == cCodTab .And. x[2] == FwCompany()+FwUnitBusiness()+Space(Len(FwFilial()))				.And. x[3] == MesAno(dDataRef) .And. Iif(nLinTab>0, x[4] == Strzero(nLinTab,3), .T.) })) > 0
		lAchou := .T.
	ElseIf( nPosTab := Ascan(aTab_Fol,{ |x| x[1] == cCodTab .And. x[2] == FwCompany()+Space(Len(FwUnitBusiness()))+FwFilial()				.And. x[3] == MesAno(dDataRef) .And. Iif(nLinTab>0, x[4] == Strzero(nLinTab,3), .T.) })) > 0
		lAchou := .T.
	ElseIf( nPosTab := Ascan(aTab_Fol,{ |x| x[1] == cCodTab .And. x[2] == FwCompany()+Space(Len(FwUnitBusiness()))+Space(Len(FwFilial()))	.And. x[3] == MesAno(dDataRef) .And. Iif(nLinTab>0, x[4] == Strzero(nLinTab,3), .T.) })) > 0
		lAchou := .T.
	ElseIf( nPosTab := Ascan(aTab_Fol,{ |x| x[1] == cCodTab .And. x[2] == Space(Len(FwCompany()))+Space(Len(FwUnitBusiness()))+FwFilial()	.And. x[3] == MesAno(dDataRef) .And. Iif(nLinTab>0, x[4] == Strzero(nLinTab,3), .T.) })) > 0
		lAchou := .T.
	ElseIf( nPosTab := Ascan(aTab_Fol,{ |x| x[1] == cCodTab .And. x[2] == Space(Len(FwCompany()))+FwUnitBusiness()+Space(Len(FwFilial()))	.And. x[3] == MesAno(dDataRef) .And. Iif(nLinTab>0, x[4] == Strzero(nLinTab,3), .T.) })) > 0
		lAchou := .T.
	ElseIf( nPosTab := Ascan(aTab_Fol,{ |x| x[1] == cCodTab .And. x[2] == Space(Len(FwCompany()))+FwUnitBusiness()+FwFilial()				.And. x[3] == MesAno(dDataRef) .And. Iif(nLinTab>0, x[4] == Strzero(nLinTab,3), .T.) })) > 0
		lAchou := .T.

	Elseif( nPosTab := Ascan(aTab_Fol,{ |x| x[1] == cCodTab .And. x[2] == FwCompany()+FwUnitBusiness()+Space(Len(FwFilial()))				.And. x[3] == Space(6) .And. Iif(nLinTab>0, x[4] == Strzero(nLinTab,3), .T.) })) > 0
		lAchou := .T.
	Elseif( nPosTab := Ascan(aTab_Fol,{ |x| x[1] == cCodTab .And. x[2] == FwCompany()+Space(Len(FwUnitBusiness()))+FwFilial()				.And. x[3] == Space(6) .And. Iif(nLinTab>0, x[4] == Strzero(nLinTab,3), .T.) })) > 0
		lAchou := .T.
	Elseif( nPosTab := Ascan(aTab_Fol,{ |x| x[1] == cCodTab .And. x[2] == FwCompany()+Space(Len(FwUnitBusiness()))+Space(Len(FwFilial()))	.And. x[3] == Space(6) .And. Iif(nLinTab>0, x[4] == Strzero(nLinTab,3), .T.) })) > 0
		lAchou := .T.
	Elseif( nPosTab := Ascan(aTab_Fol,{ |x| x[1] == cCodTab .And. x[2] == Space(Len(FwCompany()))+Space(Len(FwUnitBusiness()))+FwFilial()	.And. x[3] == Space(6) .And. Iif(nLinTab>0, x[4] == Strzero(nLinTab,3), .T.) })) > 0
		lAchou := .T.
	Elseif( nPosTab := Ascan(aTab_Fol,{ |x| x[1] == cCodTab .And. x[2] == Space(Len(FwCompany()))+FwUnitBusiness()+Space(Len(FwFilial()))	.And. x[3] == Space(6) .And. Iif(nLinTab>0, x[4] == Strzero(nLinTab,3), .T.) })) > 0
		lAchou := .T.
	Elseif( nPosTab := Ascan(aTab_Fol,{ |x| x[1] == cCodTab .And. x[2] == Space(Len(FwCompany()))+FwUnitBusiness()+FwFilial()				.And. x[3] == Space(6) .And. Iif(nLinTab>0, x[4] == Strzero(nLinTab,3), .T.) })) > 0
		lAchou := .T.
	Endif

Return(lAchou)

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³fPosTab()		 ³Autor³Mauro Sergio       ³Data ³21/07/2002³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Retorna a Linha ou o Conteudo de uma coluna da tabela       ³
³          ³por comparacao do conteudo,operador e coluna de comparacao. ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³fPosTab(cCodTab,nColuna,cCond)   		       				³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Uso      ³Calculo Formulas			                                ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Retorno  ³       														³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³cCodTab 	= Codigo da tabela                         	    ³
³          ³uCOnt1  	= Conteudo1 para comparacao			            ³
³          ³cOper1    	= Operador 1 para comparacao                    ³
³          ³nColTab1 	= Numero da Coluna1 para comparacao             ³
³          ³uCOnt2  	= Conteudo2 para comparacao			            ³
³          ³cOper2    	= Operador 2 para comparacao                    ³
³          ³nColTab2 	= Numero da Coluna2 para comparacao             ³
³          ³nColRet     = Numero da Coluna para retorno do Conteudo     ³
³          ³aASort		= Ordena os elementos conforme array especifico	³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function fPosTab( cCodTab,uCont1,cOper1,nColTab1,uCont2,cOper2,nColTab2,nColRet,nLinRet,nLinTab,lCarTab,cFilSeek,uCont3,cOper3,nColTab3,dDtTab,aASort,aTabDef,lOnlyTab,lCarNew,lChkData,lChkFil)

Local cTab1Type
Local cTab2Type
Local cTab3Type
Local cCnt1Type
Local cCnt2Type
Local cCnt3Type

Local nX 		:= 0
Local nPosTab 	:= 0
Local lRet		:= .T.
Local lAchou 	:= .F.
Local cFilTab
Local nFor
Local nTab
Local uRet		:= ""
Local cX		:= ""
Local cY		:= ""
Local cSort		:= ""
Local aLogCalc
Local cMsg
Local aInfoRCB	:= {}

DEFAULT lCarNew		:= .F.
DEFAULT lCarTab 	:= .F.
DEFAULT lOnlyTab	:= .F.
DEFAULT nLinRet 	:= 0
DEFAULT cFilSeek	:= IIf(cPaisLoc <> "BRA", xFilial("SRA"), SRA->RA_FILIAL)
DEFAULT dDtTab		:= cToD("//")
DEFAULT aASort		:= {}	//Array numerico para ordenacao. Exemplo: {1,2,3,4,7,8}
DEFAULT nTamFilAux	:= FwGetTamFilial
DEFAULT aTabDef		:= {}
DEFAULT lChkData	:= .F.
DEFAULT lChkFil		:= .F.

If !Empty(aTabDef)
	aTab_Fol := aClone(aTabDef)
EndIf

cFilTab := cFilSeek

If Type( "dDataref" ) == "U"
	dDataRef := dDataBase
EndIf

If !Empty(dDtTab)
	dDataRef := dDtTab
EndIf

//--Verifica a existencia do array das tabelas caso nao exista define e carrega
If ValType(aTab_Fol) # "A" .Or. Empty(aTab_Fol)
	aTab_Fol := {}
	lCarTab	 := .T.
Endif

//--Verifica se Existe a Tabela Indicada no Array se nao existir
//--Seta variavel para carregar
If Ascan(aTab_Fol,{ |x| x[1] == cCodTab}) == 0
	lCarTab := .T.
Endif

//--Carrega Tabela quando variavel lCarTab == .T.
If lCarTab
	If !Empty(aASort)
		@aTab_Fol := {}
	EndIf
	fCarrTab( @aTab_Fol,cCodTab,dDataRef,lOnlyTab,,lCarNew,cFilSeek )
	If Len(aTab_Fol) > 0 .And. cCodTab <> "S043"
		If Empty(aASort)
			aSort(aTab_Fol,,,{ |x,y|  x[1]+x[2]+x[3]+x[4] < y[1]+y[2]+y[3]+y[4] })
		Else
			For nX := 1 To Len(aASort)

				If aASort[nX] > 4 .AND. ValType( aTab_Fol[1][aASort[nX]] ) == "N"
					aInfoRCB := fRetRCB(cFilSeek,cCodTab, STRZERO(aASort[nX]-4,2))
					cX += If( nX == 1, '', '+') + 'StrZero(x[' + cValToChar( aASort[nX] ) + '],' + cValToChar(aInfoRCB[1][5]) + ')'
					cY += If( nX == 1, '', '+') + 'StrZero(y[' + cValToChar( aASort[nX] ) + '],' + cValToChar(aInfoRCB[1][5]) + ')'
				Else
					cX += If( nX == 1, '', '+') + 'cValToChar(x[' + cValToChar( aASort[nX] ) + '])'
					cY += If( nX == 1, '', '+') + 'cValToChar(y[' + cValToChar( aASort[nX] ) + '])'
				EndIf

			Next nX
			cSort := 'aSort(aTab_Fol,,,{ |x,y| ' + cX + ' < ' + cY + '})'
			&( cSort )
		EndIf
	EndIf
Endif

//--Verifica se Existe a Tabela Cadastrada
If ( nPosTab := Ascan(aTab_Fol,{ |x| x[1] == cCodTab .And.x[2] == cFilTab .And. x[3] == MesAno(dDataRef) })) > 0
	lAchou := .T.
ElseIf ( nPosTab := Ascan(aTab_Fol,{ |x| x[1] == cCodTab .And.x[2] == Space(nTamFilAux).And. x[3] == MesAno(dDataRef) })) > 0
	lAchou := .T.
Elseif ( nPosTab := Ascan(aTab_Fol,{ |x| x[1] == cCodTab .And.x[2] == cFilTab .And. x[3] == Space(6) })) > 0
	lAchou := .T.
Elseif ( nPosTab := Ascan(aTab_Fol,{ |x| x[1] == cCodTab .And.x[2] == Space(nTamFilAux) .And. x[3] == Space(6) })) > 0
	lAchou := .T.
EndIf

//-Tratamento pra Gestao Corporativa
If fIsCorpManage() .and. !lAchou
	lAchou := fVer_Fol(@nPosTab,aTab_Fol,cCodTab,dDataRef,)
EndIf

If nLinRet > 0
	nPosTab := nLinRet
EndIf

If lAchou

	//--Montagem dos Blocos de comparacao
	If uCont1 # Nil .And. uCont2 # Nil .And. uCont3 # Nil .And. cOper1 # Nil .And. cOper2 # Nil .And. cOper3 # Nil
		bBloco3 := & ( '({|x,y,z|uCont1' + cOper1 + 'x .And. uCont2' + cOper2 + 'y .And. uCont3' + cOper3 + 'z})' )
	EndIf
	If uCont1 # Nil .And. uCont2 # Nil .And. cOper1 # Nil .And. cOper2 # Nil
	    bBloco2 := & ( '({|x,y|uCont1' + cOper1 + 'x .And. uCont2' + cOper2 + 'y})' )  //({|x| nArea>=x})
	Endif
	If uCont1 # Nil .And. cOper1 # Nil
	    bBloco1 := & ( '({|x,y|uCont1' + cOper1 + 'x })' )
	Endif

	//--Verifica se Pasou a coluna de busca inicial
	nFor := Len(aTab_fol)
	If nPosTab > nFor
		nPosTab := nFor
	EndIf
	For nTab := nPosTab To nFor

		If !(aTab_Fol[nTab,1] == cCodTab)
			Exit
		EndIf

		//-- Verificar o tipo da campo e do conteudo das variaveis
		If uCont1 # Nil
			cTab1Type := ValType(aTab_Fol[nTab,nColTab1+1])
			cCnt1Type := ValType(uCOnt1)
		EndIf
		If uCont2 # Nil
			cTab2Type := ValType(aTab_Fol[nTab,nColTab2+1])
			cCnt2Type := ValType(uCOnt2)
		EndIf
		If uCont3 # Nil
			cTab3Type := ValType(aTab_Fol[nTab,nColTab3+1])
			cCnt3Type := ValType(uCOnt3)
		EndIf

		//--Tratamento para versao da folha Modelo 2
		If MV_MODFOL = '2'
			If cTab1Type <> cCnt1Type
				If cCnt1Type == "D" .and. cTab1Type == "C"
					uCOnt1 := CtoD( uCOnt1 )
				ElseIf cCnt1Type == "C" .and. cTab1Type == "D"
					uCOnt1 := DtoC( uCOnt1 )
				ElseIf cCnt1Type == "C" .and. cTab1Type == "N"
					uCOnt1 := Val( uCOnt1 )
				ElseIf cCnt1Type == "N" .and. cTab1Type == "C"
					uCOnt1 := AllTrim(Str( uCOnt1 ))
				EndIf
			EndIf
			If cTab2Type <> cCnt2Type
				If cCnt2Type == "D" .and. cTab2Type == "C"
					uCOnt2 := CtoD( uCOnt2 )
				ElseIf cCnt2Type == "C" .and. cTab2Type == "D"
					uCOnt2 := DtoC( uCOnt2 )
				ElseIf cCnt2Type == "C" .and. cTab2Type == "N"
					uCOnt2 := Val( uCOnt2 )
				ElseIf cCnt2Type == "N" .and. cTab2Type == "C"
					uCOnt2 := AllTrim(Str( uCOnt2 ))
				EndIf
			EndIf
			If cTab3Type <> cCnt3Type
				If cCnt3Type == "D" .and. cTab3Type == "C"
					uCOnt3 := CtoD( uCOnt3 )
				ElseIf cCnt3Type == "C" .and. cTab3Type == "D"
					uCOnt3 := DtoC( uCOnt3 )
				ElseIf cCnt3Type == "C" .and. cTab3Type == "N"
					uCOnt3 := Val( uCOnt3 )
				ElseIf cCnt3Type == "N" .and. cTab3Type == "C"
					uCOnt3 := AllTrim(Str( uCOnt3 ))
				EndIf
			EndIf
		EndIf

		//--Verifica se Passou a coluna de Busca final se passou analisa a coluna
		//--Inicial e final para ver se o valor passado se encaixa nesta condicao
		If uCont1 # Nil .And. uCont2 # Nil .And. uCont3 # Nil
			If cCnt1Type = cTab1Type .And.;
			   cCnt2Type = cTab2Type .And.;
			   cCnt3Type = cTab3Type
				If Eval(bBloco3, aTab_Fol[nTab,nColTab1+1], aTab_Fol[nTab,nColTab2+1], aTab_Fol[nTab,nColTab3+1]) .and.;
					   (!lChkData .or. Empty(aTab_Fol[nTab][3]) .or. AnoMes(dDataRef) == aTab_Fol[nTab][3]) .and.;
					   (!lChkFil .or. Empty(aTab_Fol[nTab][2]) .or. cFilTab == aTab_Fol[nTab][2])
					nLinRet := Val(aTab_Fol[nTab][4])
					If nColRet # Nil .And. ! Empty(nColRet)
						uRet 	:= aTab_Fol[nTab,nColRet+1]
					Endif
					Exit
				Else
					nLinRet := 0
				Endif
			Endif
		ElseIf uCont1 # Nil .And. uCont2 # Nil
			If cCnt1Type = cTab1Type .And. ;
				cCnt2Type = cTab2Type
				If Eval(bBloco2, aTab_Fol[nTab,nColTab1+1],aTab_Fol[nTab,nColTab2+1])
					nLinRet := IIf(!IsAlpha(aTab_Fol[nTab][4]), Val(aTab_Fol[nTab][4]), RHAlphSeq(aTab_Fol[nTab][4]))
					If nColRet # Nil .And. ! Empty(nColRet)
						uRet 	:= aTab_Fol[nTab,nColRet+1]
					Endif
					Exit
				Else
					nLinRet := 0
				Endif
			Endif
		//Verifica se Passoua coluna Inicial e verifica se o valor passado
		// e menor ou igual ao conteudo da coluna informada
		Elseif 	uCont1 # Nil
			If cCnt1Type = cTab1Type
				If Eval(bBloco1, aTab_Fol[nTab,nColTab1+1])
					nLinRet := Val(aTab_Fol[nTab][4])    //nTab
					If nColRet # Nil .ANd. ! Empty(nColRet)
						uRet 	:= aTab_Fol[nTab,nColRet+1]
					Endif
					Exit
				Else
					nLinRet := 0
				Endif
			Endif
		Endif
	Next nTab
Else
	lRet := .F.
Endif

If !lRet
	aLogCalc := LogExecRot()
	If ValType(aLogCalc) # "U" .And. ValType(aLogCalc) == "A" .And. Len(aLogCalc) > 0
		cMsg := STR0126 + " [" + cCodTab + "]  " + STR0129
		AddLogExecRot( cMsg )		// adiciona no Log de Erros
    Else
    	Help(" ",1,"GPETABNCAD")
    Endif
Endif

Return( If (nColret # Nil , uRet, nLinRet))

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³SetFuncoes		³ Autor ³Mauro Sergio Test.³ Data ³10/06/2002³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Inicializa as Funcoes para uso em Formulas				 	 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL                                                  	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Uso      ³Generico                                                     ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function SetFuncoes( cFil , aFuncoes )

Local aArea			:= GetArea()
Local aAreaRC4		:= RC4->( GetArea() )
Local cFilRC4		:= xFilial( "RC4" , cFil )
Local cFilRC5		:= xFilial( "RC5" , cFil )
Local lSet			:= .T.

Static lIniFuncao

DEFAULT lIniFuncao	:= .T.
DEFAULT aFuncoes	:= {}

//--INICIALIZADOR DAS FUNCOES PADROES
If ( lIniFuncao )
	GpIniFuncao()
	lIniFuncao := .F.
Endif

IF Empty( aFuncoes )

	RC4->( dbSetOrder( 01 ) )

	IF ( lSet := RC4->( dbSeek( cFilRC4 , .F. ) ) )

		While RC4->( !Eof() .and. ( RC4_FILIAL == cFilRC4 ) )

			RC4->( aAdd( aFuncoes , { AllTrim( RC4->RC4_NOMFUN ) , RC4_DESC }))

			dbSelectArea("RC5")
			If dbSeek(cFilRC5+RC4->RC4_NOMFUN+"001")
				While ! Eof() .And. RC5->RC5_FILIAL+RC5->RC5_NOMFUN == cFilRC5+RC4->RC4_NOMFUN

					If Len(aFuncoes) > 0
						RC5->( aAdd( aFuncoes[Len(aFuncoes)],{RC5_PARAM , RC5_TPARAM , RC5_OBRIG , Recno() } ))
					Endif

					RC5->( dbSkip() )

				Enddo
			Endif

			RC4->( dbSkip() )

		End While

	EndIF

	( RestArea( aAreaRC4 ) , RestArea( aArea ) )

EndIF

Return( lSet )

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³fCarMvto  ºAutor  ³Microsiga           º Data ³  07/30/03   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³                                                            º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Function fCarMvto(cFil, cMatr, cSemana, cProces, cPeriodo, cRoteiro, cNumPag, cConvoc, lExcluiSRC, cBenOp)

Local aArea			:= GetArea()
Local aAreaSRH		:= SRH->(GetArea())
Local aStruRGB 		:= RGB->(dbStruct())
Local aTabS137		:= {}
Local aVbAuxFer		:= {}
Local aVbManual		:= {}
Local aECons		:= {}
Local cAliasRGB		:= "RGB"
Local cQuery		:= ""
Local cQryAux		:= ""
Local cWhere		:= ""
Local cSeq			:= ""
Local cNPagAux  	:= ""
Local cAno			:= ""
Local cDel			:= " "
Local dDtRefRgb		:= CtoD("//")
Local nPosParam		:= 0
Local nX			:= 0
Local nTot			:= 0
Local cCampos		:= ""
Local aStru2RGB		:= {}
Local lItemClVl 	:= GetMvRH( "MV_ITMCLVL", .F., "2" ) $ "1*3"
Local lTemMultV		:= .F.
Local lRes			:= .F.
Local lFer			:= .F.
Local lComissBen	:= (SRA->RA_CATFUNC == "C" .And. cRoteiro == "BEN")
Local lProvisao		:= IsInCallStack("GPEM070") .or. IsInCallStack("GPM070GRD")
Local lGPER080		:= IsInCallStack("GPER080")
Local cBkpBenOp		:= ""
Local cBkpConvoc	:= ""
Local lContrInt		:= If(SRC->(ColumnPos( 'RC_CONVOC' )) > 0,.T.,.F.)
Local lNrBen		:= SRC->( ColumnPos( 'RC_NRBEN' ) ) > 0
Local lUsaPLS		:= If(!Empty(TamSX3("RGB_LOTPLS")) .AND. RGB->(ColumnPos( 'RGB_LOTPLS' )) > 0,.T.,.F.)
Local cVerbaMS      := ""
Local nContVb   	:= 0
Local nDPAdc1   	:= 0
Local nDPAdc2   	:= 0
Local nValEmpCons   := 0
Local nValorMS      := 0
Local nValorVerb    := 0
Local nRefMes		:= 0
Local nRefMS		:= 0
Local nVerbaApd		:= 0
Local nVerbaInf		:= 0
Local nMesesCon 	:= 0
Local nRefCons 		:= 0
Local nTotCons		:= 0
Local nMes			:= 0
Local nValEConsig   := 0	
Local nValProv		:= 0
Local lIrNeg		:= Len(aCodFol) >= 1726 .And. !Empty(aCodFol[1726,1]) .And. !Empty(aCodFol[1727,1])
Local cEmpCons		:= ""
Local cPdFerMes		:= ""
Local cPdFerMSeg	:= ""
Local cPdFolMes		:= ""
Local cPdFolMSeg	:= ""
Local cVbs			:= ""
Local cPerAnt		:= ""
Local cCompet		:= ""
Local lOkVb1893		:= .T.
Local lTem132Per	:= .F.
Local lVerMultv		:= .F.
Local lConvoc		:= .F.
Local lLctoDia      := .F.

DEFAULT cSemana		:= Space(2)
DEFAULT cFil		:= SRA->RA_FILIAL
DEFAULT cMatr		:= SRA->RA_MAT
DEFAULT cProces		:= SRA->RA_PROCES
DEFAULT cPeriodo	:= Space( GetSx3Cache("RCH_PER"		, "X3_TAMANHO") )
DEFAULT cRoteiro	:= GetRotExec()
DEFAULT cNumPag		:= Space( GetSx3Cache("RCH_NUMPAG"	, "X3_TAMANHO") )
DEFAULT cConvoc		:= If(lContrInt,Space( GetSx3Cache("RC_CONVOC"	, "X3_TAMANHO") )," ")
DEFAULT lExcluiSRC	:= .T.
DEFAULT cBenOp		:= If(lNrBen, Space( GetSx3Cache("RC_NRBEN", "X3_TAMANHO") )," ")
DEFAULT lConsig		:= GetMvRH("MV_CONSIG",, .F.)
DEFAULT lTemSeqMV	:= If(SRC->(ColumnPos( 'RC_SEQMV' )) > 0 .and. SRR->(ColumnPos( 'RR_SEQMV' )) > 0 ,.T.,.F.)
DEFAULT aDissInf	:= {}
DEFAULT lTemIN2110	:= SRC->( ColumnPos( "RC_IN2110" ) ) > 0
DEFAULT lTemTribIR	:= SRC->( ColumnPos( "RC_TRIBIR" ) ) > 0
DEFAULT __lMemCalc 	:= (cPaisLoc == "BRA" .And. fMemCalc())

Private lGestPubl 	:= IIF(ExistFunc("fUsaGFP"),fUsaGFP(),.F.)

Static nRGBOrd		:= RetOrdem("RGB","RGB_FILIAL+RGB_PROCES+RGB_PERIOD+RGB_SEMANA+RGB_ROTEIR+RGB_MAT+RGB_PD+RGB_SEQ")
Static nSRCOrd		:= RetOrdem("SRC","RC_FILIAL+RC_MAT+RC_PERIODO+RC_ROTEIR+RC_SEMANA+RC_PD")
Static nSRDOrd		:= RetOrdem("SRD","RD_FILIAL+RD_MAT+RD_PROCES+RD_ROTEIR+RD_PERIODO+RD_SEMANA")
Static __oSt1
Static __cEmpAux
Static __cFilAux
Static __lComiss
Static __cTpRotAnt

aPd 		:= If ( Type("aPd") # "A",{},aPd)
lDissidio	:= If ( Type("lDissidio") == "U",.F.,lDissidio)
lIncCompl	:= If ( Type("P_INCCOMPL") == "U",.F.,P_INCCOMPL)
lVerMultv   := If ( Type("P_MULTV") == "U",.F.,P_MULTV)
lGrvRAZRAW  := .F.
cBkpConvoc  := cConvoc
cBkpBenOp  	:= cBenOp

If (Type("lSalInco") == "U" .Or. !lSalInco) .And. (SRA->RA_TPCONTR != "3" .Or. aConvocacao[6]) //Não ttrata multv se estiver calculando o roteiro INC
	If lVerMultv
		If lTemSeqMV
			If ( lTemMultV := fLoadMultv(.F.) )
				CSEQMV := " "
				If lDissidio .Or. (cTipoRot == "6" .And. lCalcFol)
					SRD->(DbSetOrder(nSRDOrd))
					If SRD->(DbSeek(SRA->RA_FILIAL + SRA->RA_MAT + cProcesso + cRoteiro + cPeriodo + cNumPag )) //Busca base ir outras empresas
						CSEQMV := SRD->RD_SEQMV
					EndIf
					If Empty(cSEQMV)
						lTemMultV := .F. //Se não tinha sequencia MULTV o cálculo não foi tratado com o novo cálculo
						//Validação do período porque somente no fim de 07/2022 que o P_MULTV passou a ser obrigatório
						If lDissidio .Or. cPeriodo <= "202207"
							P_MULTV := .F.
						EndIf
					EndIf
				Else
					SRC->(DbSetOrder(nSRCOrd))
					If SRC->(DbSeek(SRA->RA_FILIAL + SRA->RA_MAT + cPeriodo + cRoteiro + cNumPag )) //Busca base ir outras empresas
						CSEQMV := SRC->RC_SEQMV
					EndIf
				EndIf
				If CSEQMV == " " .And. SRA->RA_SITFOLH == "D" .And. MesAno(SRA->RA_DEMISSA) == cPeriodo
					DbSelectArea("SRR")
					DbSetOrder(1)
					If SRR->(DbSeek(SRA->RA_FILIAL + SRA->RA_MAT + "R" + DTOS(SRA->RA_DEMISSA)))
						cSeqMV := SRR->RR_SEQMV
					Endif
				Endif
			EndIf
		Else
			P_MULTV := .F.  //Se não foi criado o campo, torna o mnemonico falso para consitnuar com o processo padrão.
		EndIf
	EndIf
EndIf

//Memória de Cálculo
If __lMemCalc
	fAddMemLog("Cálculo possui múltiplos vínculos ? "+ If(lTemMultV, "Sim.", "Não."),1,2)
EndIf

If !(lDissidio .And. IsInCallStack("S_CMEDFER"))
	If lExcluiSRC .And. (Type("lSalInco") == "U" .Or. !lSalInco) .And. (Type("lBkpCompl") == "U" .Or. !lBkpCompl)//Não apaga SRC se estiver calculando o roteiro INC ou folha complementar

		//--Exclui registros existentes na SRC
		cQuery := "DELETE FROM " + RetSqlName("SRC") + " "
		cQuery += "WHERE RC_FILIAL='" + cFil + "' AND "
		cQuery += "RC_PROCES='" + cProces + "' AND "
		cQuery += "RC_MAT='" + cMatr + "' AND "
		cQuery += "RC_PERIODO='" + cPeriodo + "' AND "
		cQuery += "RC_SEMANA='" + cNumPag + "' AND "
		cQuery += "RC_ROTEIR='" + cRoteiro + "' "
		If lContrInt
			cQuery += " AND RC_CONVOC='" + cConvoc + "' "
		EndIf
		If lNrBen
			cQuery += " AND RC_NRBEN='" + cBenOp + "' "
		EndIf

		TcSqlExec( cQuery )

	EndIf

	If( cTipoRot == "1" .and. P_CCOMP13 == 'S' ) .or. ( cTipoRot == "6" .and. P_CCOMP13 == 'S' .And. lCalcFol )
		lTem132Per := fTem132Per() //Verifica se houve pagamento de 13º no ano
	EndIf

	cQuery := ""

	dbSelectArea( "RGB" )
	DbSetOrder(nRGBOrd)

	cAliasRGB := "QRGB"

	If ( Select( cAliasRGB ) > 0 )
		( cAliasRGB )->( dbCloseArea() )
	EndIf

	If __oSt1 == Nil .or. ( __cEmpAux == Nil .or. __cEmpAux <> cEmpAnt ) .or. __cTpRotAnt <> cTipoRot .or. __cFilAux <> cFilAnt .or. __lComiss <> lComissBEN

		DEFAULT lChkEConsig := fChkeConsig()

		__cEmpAux   := cEmpAnt
		__cFilAux   := cFilAnt
		__cTpRotAnt := cTipoRot
		__lComiss	:= lComissBEN

		__oSt1 := FWPreparedStatement():New()

		cQuery := "SELECT "
		cQuery += "	RGB_FILIAL, RGB_MAT, RGB_PROCES, RGB_ROTEIR, "
		cQuery += "	RGB_PERIOD, RGB_PD, RGB_VALOR, RGB_HORAS, "
		cQuery += "	RGB_SEMANA, RGB_CC, RGB_TIPO1, RGB_PARCEL, "
		cQuery += "	RGB_SEQ, RGB_QTDSEM, RGB_DTREF,RGB_TIPO2,CAST(RGB_ROTORI AS VARCHAR("+Alltrim(Str(TamSX3("RGB_ROTORI")[1]))+")) AS RGB_ROTORI, ' ' AS TMP_DEL, RGB_DTREF AS TMP_PAG "
		If lContrInt
			cQuery += "	, RGB_CONVOC "
		EndIf
		If lNrBen
			cQuery += "	, RGB_NRBEN "
		EndIf
		If lTemIN2110
			cQuery += "	, RGB_IN2110 "
		EndIf
		If lTemTribIR
			cQuery += "	, RGB_TRIBIR "
		EndIf
		If lItemClVl
			cQuery += "	,RGB_ITEM, RGB_CLVL "
		EndIf
		If lUsaPLS
			cQuery += "	,CAST(RGB_LOTPLS AS VARCHAR("+Alltrim(Str(TamSX3("RGB_LOTPLS")[1]))+")) AS RGB_LOTPLS "
			cQuery += " ,CAST(RGB_CODRDA AS VARCHAR("+Alltrim(Str(TamSX3("RGB_CODRDA")[1]))+")) AS RGB_CODRDA "
		EndIf
		cQuery += "	,RGB_IDCMPL, RGB_NUMID "
		cQuery += "FROM " + RetSqlName("RGB")+ " RGB "
		cQuery += "WHERE RGB.RGB_FILIAL = ? AND " //1 - cFil
		cQuery += "RGB.RGB_PROCES = ? AND " //2 - cProces
		cQuery += "RGB.RGB_PERIOD = ? AND " //3 - cPeriodo
		//Se for complementar carrega os lancamentos das semanas anteriores
		If !lCalcCompl
			cQuery += "RGB.RGB_SEMANA = ? AND " //4 - cNumpag
		Else
			cQuery += "RGB.RGB_SEMANA <= ? AND " //4 - cNumPag
		EndIf

		cQuery += " *TIPOPESQ* "

		cQuery += "RGB.RGB_MAT = ? AND " //5 - cMatr
		cQuery += "RGB.D_E_L_E_T_=' ' "
		If lContrInt
			//Quando há rescisão de contrato intermitente, o campo RGB_CONVOC não é preenchido, pois não existe o camp de convocação na SRR.
			//Com a tratativa abaixo, caso for cálculo de folha após cálculo de rescisão, será gravada a convocação ativa da competência do cálculo.
			cQuery += "AND ( RGB.RGB_CONVOC = ? OR " //6 - cConvoc
			cQuery += "RGB.RGB_ROTORI = '" + fGetCalcRot("4") + "' )"
		Else
		 	cQuery += "AND RGB.RGB_MAT = ? " //6 - cMatr (COMPATIBILIZAÇÃO DA QUERY)
		EndIf
		If lNrBen
			cQuery += "AND RGB.RGB_NRBEN = ? "
		EndIf

		If cTipoRot == '3' .And. (lDissidio .Or. IsInCallStack("fCDifFerias") .And. cPeriodo < cSvSetPer)
			cQuery += "UNION SELECT "
			cQuery += "	RR_FILIAL, RR_MAT, RR_PROCES, RR_ROTEIR, "
			cQuery += "	RR_PERIODO, RR_PD, RR_VALOR, RR_HORAS, "
			cQuery += "	RR_SEMANA, RR_CC, RR_TIPO1, 0, "
			cQuery += "	RR_SEQ,0,RR_DATA, RR_TIPO2,CAST('   ' AS VARCHAR("+Alltrim(Str(TamSX3("RGB_ROTORI")[1]))+")) AS RD_ROTORI, ' ' AS TMP_DEL, RR_DATAPAG AS TMP_PAG "
			If lContrInt
				cQuery += "	, '' AS RGB_CONVOC "
			EndIf
			If lNrBen
				cQuery += "	, '' AS RGB_NRBEN "
			EndIf
			If lTemIN2110
				cQuery += "	, '' AS RGB_IN2110 "
			EndIf
			If lTemTribIR
				cQuery += "	, '' AS RGB_TRIBIR "
			EndIf
			If lItemClVl
				cQuery += "	,RR_ITEM, RR_CLVL "
			EndIf

			If lUsaPLS
				cQuery += "	,CAST('          ' AS VARCHAR("+Alltrim(Str(TamSX3("RD_LOTPLS")[1]))+")) AS RD_LOTPLS "
				cQuery += " ,CAST('      ' AS VARCHAR("+Alltrim(Str(TamSX3("RD_CODRDA")[1]))+")) AS RD_CODRDA "
			EndIf

			cQuery += "	,RR_IDCMPL, RR_NUMID "
			cQuery += "FROM " + RetSqlName("SRR")+ " SRR "
			cQuery += "WHERE SRR.RR_FILIAL = ? AND " //7 - cFil
			cQuery += "SRR.RR_PROCES = ? AND " //8 - cProces
			cQuery += "SRR.RR_PERIODO = ? AND " //9 - cPeriodo
			cQuery += "SRR.RR_SEMANA <= ? AND " //10 - cNumPag
			cQuery += "(SRR.RR_TIPO2='I' OR SRR.RR_TIPO2='G') AND "
			cQuery += "SRR.RR_ROTEIR = ? AND " //11 - cRoteiro
			cQuery += "SRR.RR_MAT = ? AND " //12 - cMatr
			cQuery += "SRR.D_E_L_E_T_=' ' "
		ElseIf !(P_CCOMP13 = 'S' .And. cRot == fGetCalcRot('6') .And. lCalcFol)
			cQuery += "UNION SELECT "
			cQuery += "	RD_FILIAL, RD_MAT, RD_PROCES, RD_ROTEIR, "
			cQuery += "	RD_PERIODO, RD_PD, RD_VALOR, RD_HORAS, "
			cQuery += "	RD_SEMANA, RD_CC, RD_TIPO1, 0, "
			cQuery += "	RD_SEQ, RD_QTDSEM, RD_DTREF, RD_TIPO2,CAST('   ' AS VARCHAR("+Alltrim(Str(TamSX3("RGB_ROTORI")[1]))+")) AS RD_ROTORI, ' ' AS TMP_DEL, RD_DATPGT AS TMP_PAG "
			If lContrInt
				cQuery += "	, RD_CONVOC "
			EndIf
			If lNrBen
				cQuery += "	, RD_NRBEN "
			EndIf
			If lTemIN2110
				cQuery += "	, RD_IN2110 "
			EndIf
			If lTemTribIR
				cQuery += "	, RD_TRIBIR "
			EndIf

			If lItemClVl
				cQuery += "	,RD_ITEM, RD_CLVL "
			EndIf

			If lUsaPLS
				cQuery += "	,CAST(RD_LOTPLS AS VARCHAR("+Alltrim(Str(TamSX3("RD_LOTPLS")[1]))+")) AS RD_LOTPLS "
				cQuery += " ,CAST(RD_CODRDA AS VARCHAR("+Alltrim(Str(TamSX3("RD_CODRDA")[1]))+")) AS RD_CODRDA "
			EndIf

			cQuery += "	,RD_IDCMPL, RD_NUMID "
			cQuery += "FROM " + RetSqlName("SRD")+ " SRD "
			cQuery += "WHERE SRD.RD_FILIAL = ? AND " //7 - cFil
			cQuery += "SRD.RD_PROCES = ? AND " //8 - cProces
			cQuery += "SRD.RD_PERIODO = ? AND " //9 - cPeriodo
			If lDissidio
                cQuery += "(("
            EndIf
			cQuery += "SRD.RD_SEMANA <= ? AND " //10 - cNumPag
			If lProvisao .Or. lGPER080
				cQuery += "(SRD.RD_TIPO2='I' OR SRD.RD_TIPO2='G') AND "
			EndIf
			If lComissBEN
				cQuery += "(SRD.RD_ROTEIR = ? OR " //11 - cRoteiro
				cQuery += "SRD.RD_ROTEIR = '" + fGetRotOrdinar() + "') AND "
			ElseIf cTipoRot == "N"//Retificadora
				cQuery += "SRD.RD_ROTEIR = ? AND " //11 - fGetRotOrdinar()
			Else
				cQuery += "SRD.RD_ROTEIR = ? " + Iif( !lDissidio, "AND ", "" ) //11 - cRoteiro
                If lDissidio
                    cQuery += ") OR SRD.RD_ROTEIR = '" + fGetCalcRot("N") + "') AND "
                EndIf
			EndIf
			cQuery += "SRD.RD_MAT = ? AND " //12 - cMatr
			cQuery += "SRD.D_E_L_E_T_=' ' "
		ElseIf (P_CCOMP13 = 'S' .And. cRot == fGetCalcRot('6') .And. lCalcFol) // Utiliza as verbas do tipo Informadas
			cQuery += "UNION SELECT "
			cQuery += "	RD_FILIAL, RD_MAT, RD_PROCES, RD_ROTEIR, "
			cQuery += "	RD_PERIODO, RD_PD, RD_VALOR, RD_HORAS, "
			cQuery += "	RD_SEMANA, RD_CC, RD_TIPO1, 0, "
			cQuery += "	RD_SEQ, RD_QTDSEM, RD_DTREF, RD_TIPO2,CAST('   ' AS VARCHAR("+Alltrim(Str(TamSX3("RGB_ROTORI")[1]))+")) AS RD_ROTORI, ' ' AS TMP_DEL, RD_DATPGT AS TMP_PAG "
			If lContrInt
				cQuery += "	, RD_CONVOC "
			EndIf
			If lNrBen
				cQuery += "	, RD_NRBEN "
			EndIf
			If lTemIN2110
				cQuery += "	, RD_IN2110 "
			EndIf
			If lTemTribIR
				cQuery += "	, RD_TRIBIR "
			EndIf

			If lItemClVl
				cQuery += "	,RD_ITEM, RD_CLVL "
			EndIf

			If lUsaPLS
				cQuery += "	,CAST(RD_LOTPLS AS VARCHAR("+Alltrim(Str(TamSX3("RD_LOTPLS")[1]))+")) AS RD_LOTPLS "
				cQuery += " ,CAST(RD_CODRDA AS VARCHAR("+Alltrim(Str(TamSX3("RD_CODRDA")[1]))+")) AS RD_CODRDA "
			EndIf

			cQuery += "	,RD_IDCMPL, RD_NUMID "
			cQuery += "FROM " + RetSqlName("SRD")+ " SRD "
			cQuery += "WHERE SRD.RD_FILIAL = ? AND " //7 - cFil
			cQuery += "SRD.RD_PROCES = ? AND " //8 - cProces
			cQuery += "SRD.RD_PERIODO = ? AND " //9 -  cPeriodo
			cQuery += "SRD.RD_SEMANA <= ? AND " //10 - cNumPag
			cQuery += "(SRD.RD_TIPO2='I' OR SRD.RD_TIPO2='G' OR SRD.RD_PD IN ('" + aCodFol[19,1] + "','" + aCodFol[20,1] + "') ) AND "
			If lComissBEN
				cQuery += "(SRD.RD_ROTEIR = ? OR " //11 - cRoteiro
				cQuery += "SRD.RD_ROTEIR = '" + fGetRotOrdinar() + "') AND "
			Else
				cQuery += "SRD.RD_ROTEIR = ? AND " //11 - cRoteiro
			EndIf
			cQuery += "SRD.RD_MAT = ? AND " //12 - cMatr
			cQuery += "SRD.D_E_L_E_T_=' ' "

		EndIf
		cQuery += "ORDER BY 1,3,5,9,4,2,6,13"

		cQuery := ChangeQuery(cQuery)

		__oSt1:SetQuery(cQuery)

	EndIf

	__oSt1:SetString(++nPosParam,cFil)//1
	__oSt1:SetString(++nPosParam,cProces)//2
	__oSt1:SetString(++nPosParam,cPeriodo)//3
	__oSt1:SetString(++nPosParam,cNumPag)//4

	__oSt1:SetString(++nPosParam,cMatr)//5

	If lContrInt
		__oSt1:SetString(++nPosParam,cConvoc)//6
	Else
		__oSt1:SetString(++nPosParam,cMatr)//6
	EndIf

	If lNrBen
		__oSt1:SetString(++nPosParam, cBenOp)//7
	EndIf

	If cTipoRot == '3' .And. (lDissidio .Or. IsInCallStack("fCDifFerias") .And. cPeriodo < cSvSetPer)
		__oSt1:SetString(++nPosParam,cFil)//8
		__oSt1:SetString(++nPosParam,cProces)//9
		__oSt1:SetString(++nPosParam,cPeriodo)//10
		__oSt1:SetString(++nPosParam,cNumPag)//11
		__oSt1:SetString(++nPosParam,cRoteiro)//12
		__oSt1:SetString(++nPosParam,cMatr)//13
	ElseIf !(P_CCOMP13 = 'S' .And. cRot == fGetCalcRot('6') .And. lCalcFol)
		__oSt1:SetString(++nPosParam,cFil)//8
		__oSt1:SetString(++nPosParam,cProces)//9
		__oSt1:SetString(++nPosParam,cPeriodo)//10
		__oSt1:SetString(++nPosParam,cNumPag)//11
		If cTipoRot == "N"//Retificadora
			__oSt1:SetString(++nPosParam,fGetRotOrdinar())//12
		Else
			__oSt1:SetString(++nPosParam,cRoteiro)//12
		EndIf
		__oSt1:SetString(++nPosParam,cMatr)//13
	ElseIf (P_CCOMP13 = 'S' .And. cRot == fGetCalcRot('6') .And. lCalcFol) // Utiliza as verbas do tipo Informadas
		__oSt1:SetString(++nPosParam,cFil)//8
		__oSt1:SetString(++nPosParam,cProces)//9
		__oSt1:SetString(++nPosParam,cPeriodo)//10
		__oSt1:SetString(++nPosParam,cNumPag)//11
		__oSt1:SetString(++nPosParam,cRoteiro)//12
		__oSt1:SetString(++nPosParam,cMatr)//13
	EndIf

	cQuery := __oSt1:getFixQuery()

	If lComissBEN
		cQryAux := "( RGB.RGB_ROTEIR = '" + cRoteiro + "' OR RGB.RGB_ROTEIR = '" + fGetCalcRot('1') + "' ) AND "
	Else
		If( cTipoRot == "1" .and. P_CCOMP13 == 'S' .And. lTem132Per) //Esta calculando a folha do mês 12, paga complemento, então não deve carregar as verbas de diferença de 13º lançadas na RGB
			cQryAux := "RGB.RGB_ROTEIR = '" + cRoteiro + "' AND RGB.RGB_PD NOT IN ('" + aCodFol[28,1] + "','" + aCodFol[348,1] + "') AND "
		ElseIf( cTipoRot == "6" .and. P_CCOMP13 == 'S' .And. lCalcFol .And. lTem132Per) //Esta calculando a complementar do 13º, carregar as verbas de diferença de 13º lançadas na folha
			cQryAux := "( RGB.RGB_ROTEIR = '" + cRoteiro + "' OR RGB.RGB_ROTEIR = '" + fGetCalcRot('1') + "' ) AND "
		Else
			cQryAux := "RGB.RGB_ROTEIR = '" + cRoteiro + "' AND "
		EndIf
	EndIf

	cQuery := Replace(cQuery,'*TIPOPESQ*',cQryAux )

	dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasRGB)

	aStru2RGB 	:= QRGB->(dbStruct())

	Aeval( aStru2RGB, { |x| cCampos+=x[1] + "/" } )

	For nX := 1 To Len(aStruRGB)
		If ( aStruRGB[nX][1] $ cCampos .AND. aStruRGB[nX][2] <> "C" )
			TcSetField(cAliasRGB,aStruRGB[nX][1],aStruRGB[nX][2],aStruRGB[nX][3],aStruRGB[nX][4])
		EndIf
	Next nX

	dbSelectArea(cAliasRGB)

	While (cAliasRGB)->( !Eof() )
		cDel 	:= (cAliasRGB)->TMP_DEL
		dDtaPg 	:= If( SRA->RA_CATFUNC $ "A*P" .AND. SRA->RA_TIPOPGT == "S", If(empty(StoD((cAliasRGB)->TMP_PAG)),DDATA_PGTO,(StoD((cAliasRGB)->TMP_PAG))) , (cAliasRGB)->RGB_DTREF )
		lRes	:= If((cAliasRGB)->RGB_ROTORI == fGetCalcRot('4'),.T.,.F.)
		lFer	:= If((cAliasRGB)->RGB_ROTORI == fGetCalcRot('3'),.T.,.F.)
		lLctoDia:= RetValSrv((cAliasRGB)->RGB_PD,(cAliasRGB)->RGB_FILIAL,"RV_LCTODIA") == 'S' .and. !lFer //Se for férias ignora lançamento diário e aumenta sequencia (quando existir mais de uma no período)

		cVbs := aCodFol[106,1]+'*'+aCodFol[107,1]+'*'+aCodFol[12,1]
		If lIrNeg
			cVbs += '*'+aCodFol[1727,1]
		EndIf

		If ( (Empty(SRA->RA_DEMISSA)) .And. !(RGB_PD $ cVbs) .And. !lRes .And. !lFer .And. !(RGB_TIPO2 == 'F') .And. (!lDissidio .Or. !(RGB_TIPO2 == 'K')) .And.;
		    !( (SRA->RA_CATFUNC $ "A*H*T" .And. SRA->RA_TIPOPGT == "S") .Or. (SRA->RA_CATFUNC == "A" .And. SRA->RA_TIPOPGT == "S" .And. (cAliasRGB)->RGB_SEMANA == cSemana) ) ) .Or. cTipoRot == "F"
			dDtaPg := dData_Pgto
		EndIf

		If ( !lIncCompl .And. cTipoRot == "6" .and. P_CCOMP13 == 'S' .And. lCalcFol .And. !((cAliasRGB)->RGB_PD $ aCodFol[28,1] + "','" + aCodFol[348,1]);
		.And. !((cAliasRGB)->RGB_TIPO2 $ "I/G" .And. RetValSrv((cAliasRGB)->RGB_PD,(cAliasRGB)->RGB_FILIAL,"RV_REF13") == 'S') )
			(cAliasRGB)->( dbSkip() )
			Loop
		EndIf

		If lCalcCompl .And. !Empty(SRA->RA_DEMISSA) .And. AnoMes(SRA->RA_DEMISSA) <= cPeriodo .And.	(cAliasRGB)->RGB_SEMANA < cSemana
			(cAliasRGB)->( dbSkip() )
			Loop
		EndIf

		If lProvisao .And. (cAliasRGB)->RGB_ROTEIR == "FOL";
		.And. ((RetValSrv((cAliasRGB)->RGB_PD,(cAliasRGB)->RGB_FILIAL,"RV_ADICTS") == 'S') .Or. (RetValSrv((cAliasRGB)->RGB_PD,(cAliasRGB)->RGB_FILIAL,"RV_PERICUL") == 'S') .Or. (RetValSrv((cAliasRGB)->RGB_PD,(cAliasRGB)->RGB_FILIAL,"RV_INSALUB") == 'S') );
		.And. RetValSrv((cAliasRGB)->RGB_PD,(cAliasRGB)->RGB_FILIAL,"RV_INCORP") == 'N'
			(cAliasRGB)->( dbSkip() )
			Loop
		Endif

		If lDissidio
			nVerbaApd := Ascan(APD, {|x| x[1] == (cAliasRGB)->RGB_PD .And. x[9] <> "D"})
			nVerbaInf := Ascan(aDissInf, {|x| x[6] == (cAliasRGB)->RGB_PD})
			If nVerbaApd > 0 .And. nVerbaInf > 0  //evito adicionar a verba novamente no APD no dissidio para evitar somar o valor origem + o recalculado
				(cAliasRGB)->( dbSkip() )
				Loop
			Endif
		EndIf

		dDtRefRgb	:= RGB_DTREF

		cSeq := (cAliasRGB)->RGB_SEQ
		If lCalcCompl .Or. (lDissidio .And. (cAliasRGB)->RGB_ROTEIR == fGetCalcRot("N"))
			cNPagAux := cNumPag
		Else
			cNPagAux := (cAliasRGB)->RGB_SEMANA
		EndIf

		//Verifica se tem mais de uma Convocação no mes para considerar todas verbas
		lConvoc := .F.
		If lDissidio .And. SRA->RA_TPCONTR == "3" .And. Empty((cAliasRGB)->RGB_SEQ) .And. !Empty((cAliasRGB)->RGB_CONVOC )
			lConvoc := .T.
		EndIf

		If ( nPos := Ascan(aPd,{ |X| X[1]+X[2]+Iif( lItemClVl, x[13]+x[14], "")+X[3]+Iif( lConvoc,"",X[11])+x[22]+x[26]+Iif(lLctoDia,DtoS(x[18]),"") == (cAliasRGB)->(RGB_PD + RGB_CC + Iif( lItemClVl, RGB_ITEM+RGB_CLVL, "")) + cNPagAux + Iif(lConvoc,"",cSeq)+ cConvoc + cBenOp + Iif(lLctoDia,DtoS((cAliasRGB)->RGB_DTREF),"")} ) ) > 0
			If lDissidio .And. (cAliasRGB)->RGB_ROTEIR == fGetCalcRot("N")
                aPd[nPos, 4] += (cAliasRGB)->RGB_HORAS
                aPd[nPos, 5] += (cAliasRGB)->RGB_VALOR
                (cAliasRGB)->( dbSkip() )
                Loop
            EndIf
			While .T.
				cSeq := Soma1(cSeq)
				If ( nPos := Ascan(aPd,{ |X| X[1]+X[2]+Iif( lItemClVl, x[13]+x[14], "")+X[3]+X[11]+Iif(lConvoc,"",x[22])+x[26] == (cAliasRGB)->(RGB_PD + RGB_CC + Iif( lItemClVl, RGB_ITEM+RGB_CLVL, "")) + cNPagAux + cSeq + Iif(lConvoc,"",cConvoc) + cBenOp } ) ) == 0
					Exit
				EndIf
			EndDo
		EndIf

		If lContrInt .And. !Empty((cAliasRGB)->RGB_CONVOC)
			cConvoc := (cAliasRGB)->RGB_CONVOC
		Else
			cConvoc := cBkpConvoc
		EndIf

		If lNrBen .And. !Empty((cAliasRGB)->RGB_NRBEN)
			cBenOp := (cAliasRGB)->RGB_NRBEN
		Else
			cBenOp := cBkpBenOp
		EndIf

		If cTipoRot == "3" .And. Empty( RetValSrv( (cAliasRGB)->RGB_PD,(cAliasRGB)->RGB_FILIAL,"RV_CODFOL" ) )

			//Se verba veio de lançamentos fixos, ignora pois será gravada na função correspondente
			If lDissidio .and. (cAliasRGB)->RGB_TIPO2 == "G" .and. "RG1" $ (cAliasRGB)->RGB_NUMID
				dbSelectArea(cAliasRGB)
				dbSkip()
				Loop 
			EndIf

			If RetValSrv( (cAliasRGB)->RGB_PD,(cAliasRGB)->RGB_FILIAL,"RV_REFFER" ) == "S"
				cVerbaMS := fBusMesSeg( (cAliasRGB)->RGB_PD )
			EndIf

			nRefMes := (cAliasRGB)->RGB_HORAS

			If !Empty(cVerbaMS)
				nValorMS   := ( (cAliasRGB)->RGB_VALOR / ( NDIASFM + NDIASABM + NDIASFMS + NDIASABMS ) ) * (NDIASFMS + NDIASABMS) //Valor proporcional a férias e abono mês seguinte
				nValorVerb := ( (cAliasRGB)->RGB_VALOR / ( NDIASFM + NDIASABM + NDIASFMS + NDIASABMS ) ) * (NDIASFM + NDIASABM) //Valor proporcional a férias e abono
				If nValorMS > 0
					nRefMes	   := NDIASFM + NDIASABM
					nRefMS	   := NDIASFMS + NDIASABMS
				EndIf
			Else
				nValorVerb := (cAliasRGB)->RGB_VALOR
			EndIf

			If lItemClVl
				(cAliasRGB)->( FMatriz(RGB_PD,nValorVerb,nRefMes,cNPagAux,RGB_CC,RGB_TIPO1,RGB_TIPO2,RGB_PARCEL,cDel,dDtapg,,cSeq,RGB_QTDSEM,RGB_ITEM,RGB_CLVL,RGB_NUMID,,RGB_IDCMPL, dDtRefRgb,,,,cConvoc,,If(lUsaPLS,RGB_LOTPLS,""),If(lUsaPLS,RGB_CODRDA,"") ) )
				If nValorMS > 0
					(cAliasRGB)->( FMatriz(cVerbaMS,nValorMS,nRefMS,cNPagAux,RGB_CC,RGB_TIPO1,RGB_TIPO2,RGB_PARCEL,cDel,dDtapg,,cSeq,RGB_QTDSEM,RGB_ITEM,RGB_CLVL,RGB_NUMID,,RGB_IDCMPL, dDtRefRgb,,,,cConvoc,,If(lUsaPLS,RGB_LOTPLS,""),If(lUsaPLS,RGB_CODRDA,"") ) )
				EndIf
			Else
				(cAliasRGB)->( FMatriz(RGB_PD,nValorVerb,nRefMes,cNPagAux,RGB_CC,RGB_TIPO1,RGB_TIPO2,RGB_PARCEL,cDel,dDtapg,,cSeq,RGB_QTDSEM,,,RGB_NUMID,,RGB_IDCMPL, dDtRefRgb,,,,cConvoc,,If(lUsaPLS,RGB_LOTPLS,""),If(lUsaPLS,RGB_CODRDA,"")) )
				If nValorMS > 0
					(cAliasRGB)->( FMatriz(cVerbaMS,nValorMS,nRefMS,cNPagAux,RGB_CC,RGB_TIPO1,RGB_TIPO2,RGB_PARCEL,cDel,dDtapg,,cSeq,RGB_QTDSEM,,,RGB_NUMID,,RGB_IDCMPL, dDtRefRgb,,,,cConvoc,,If(lUsaPLS,RGB_LOTPLS,""),If(lUsaPLS,RGB_CODRDA,"")) )
				EndIf
			EndIf
		Else
			(cAliasRGB)->( FMatriz(RGB_PD, RGB_VALOR, RGB_HORAS, cNPagAux, RGB_CC, RGB_TIPO1, RGB_TIPO2, RGB_PARCEL, cDel, dDtapg, Nil, cSeq, RGB_QTDSEM, IIf(lItemClVl, RGB_ITEM, ""), IIf(lItemClVl, RGB_CLVL, ""), RGB_NUMID, Nil, RGB_IDCMPL, dDtRefRgb, Nil, Nil, Nil, cConvoc, Nil, Iif(lUsaPLS, RGB_LOTPLS, ""), Iif(lUsaPLS, RGB_CODRDA, ""), Nil, cBenOp, Iif(lTemIN2110, RGB_IN2110, ""), Iif(lTemTribIR, RGB_TRIBIR, "") ) )
		EndIf
        If __lMemCalc .And. (cAliasRGB)->RGB_TIPO2 $ "I/G" .And. aScan( aVbManual, { |x| x[1] == (cAliasRGB)->RGB_PD } ) == 0
            aAdd( aVbManual, { (cAliasRGB)->RGB_PD, RetValSrv( (cAliasRGB)->RGB_PD, (cAliasRGB)->RGB_FILIAL, "RV_CODFOL" ), AllTrim( RetValSrv( (cAliasRGB)->RGB_PD, (cAliasRGB)->RGB_FILIAL, "RV_DESC" ) ) } )
        EndIf

		//Se não for dissídio, se for roteiro da folha e a verba veio do roteiro FER
		If Len(aPd) > 0 .And. !lDissidio .And. cRoteiro == fGetCalcRot("1") .And. (lFer .Or. ((cAliasRGB)->RGB_TIPO2 == "F" .And. RetValSrv( (cAliasRGB)->RGB_PD,(cAliasRGB)->RGB_FILIAL,"RV_REFFER" ) == "S") )
			aAdd( aVbAuxFer, aClone( aPd[Len(aPd)] ) )
		EndIf
		dbSelectArea(cAliasRGB)
		dbSkip()
	EndDo

	RestArea( aAreaSRH )

	//Gera verbas de contrapartida do eSocial Id 1562/1722/1723/1893
	If cPaisLoc == "BRA" .And. cTipoRot == "1" .And. !Empty(aVbAuxFer)
		lOkVb1893 := fGerBasFer( aVbAuxFer )
	EndIf

	dbSelectArea(cAliasRGB)
	dbCloseArea()

	If lOkVb1893
		If( lIncCompl .And. cTipoRot == "6" .and. P_CCOMP13 == 'S' .And. lCalcFol)
			aEval(  apd, { |x| If( !(x[1] $ aCodFol[28,1] + "','" + aCodFol[348,1]) .And. !(x[7] $ "I/G" .And. RetValSrv(x[1],SRA->RA_FILIAL,"RV_REF13") == 'S'), x[9] := "D", Nil  ) } )
		EndIf

		If cTipoRot == "5"
			cAliasAux	:= GetNextAlias()
			cAno := SubStr(cPeriodo,1,4)
			cWhere   := "SRD.RD_FILIAL = '"+cFil+"' AND SRD.RD_MAT = '"+cMatr+"' AND "+;
						"(SRD.RD_PD = '"+aCodFol[22,1]+"' OR SRD.RD_PD = '"+aCodFol[24,1]+"' OR "+;
						"SRD.RD_PD = '"+aCodFol[163,1]+"' ) AND "+;
						"SRD.RD_PERIODO >= '"+cAno+"01' AND SRD.RD_PERIODO <= '"+cAno+"12'"
			cWhere   := "%"+cWhere+"%"

			BeginSql alias cAliasAux
				SELECT RD_VALOR
				FROM %table:SRD% SRD
				WHERE %exp:cWhere% AND SRD.%notDel%
			EndSql
			nAntec13 := 0 //Zera mnemonico de 13º pago
			NANT13SAL := 0 //Zera mnemonico de 13º pago
			While !(cAliasAux)->(Eof())
				nAntec13 += (cAliasAux)->(RD_VALOR)
				NANT13SAL += (cAliasAux)->(RD_VALOR)
				(cAliasAux)->(dbskip())
			Enddo
			(cAliasAux)->(dbCloseArea())

			//Busca verbas da primeira parcela pagas no movimento
			dbSelectArea("SRC")
			dbSetOrder(1)
			If dbSeek(cFil+cMatr)
				While !Eof() .And. SRC->RC_FILIAL+SRC->RC_MAT == cFil+cMatr
					If SRC->RC_PD $ ( aCodFol[022,1] + "/" + aCodFol[024,1] + "/" + aCodFol[163,1] )
						nAntec13 += SRC->RC_VALOR
						NANT13SAL += SRC->RC_VALOR
					EndIf
					dbSkip()
				End While
			EndIf
		EndIf

		If cTipoRot == "5" .and. Empty(nAntec13)
			//Busca pagamento de 13º na RGB
			dbSelectArea("RGB")
			dbSetOrder(6) //RGB_FILIAL+RGB_MAT+RGB_PERIOD+RGB_ROTEIR+RGB_SEMANA+RGB_PD
			If dbSeek(cFil+cMatr+cPeriodo)
				While !Eof() .And. RGB->RGB_FILIAL+RGB->RGB_MAT+RGB->RGB_PERIOD == cFil+cMatr+cPeriodo
					If RGB->RGB_PD $ ( aCodFol[022,1] + "/" + aCodFol[024,1] + "/" + aCodFol[163,1] ) .AND.  RGB_ROTEIR $ fGetCalcRot("1")+"/"+fGetCalcRot("9")
						nAntec13 += RGB->RGB_VALOR
						NANT13SAL += RGB->RGB_VALOR
					EndIf
					dbSkip()
				End While
			EndIf
		EndIf

		//Se funcionário esta demitido e esta calculando a folha devido a rescisão complementar, apenas grava o conteúdo carregado no aPD e finaliza calculo do funcionário
		If (Type("lSalInco")=="U" .Or. !lSalInco) .And. (!Empty(aPd) .Or. lCalcCompl) .And. (cTipoRot $ "1/9") .And. !Empty(SRA->RA_DEMISSA) .And. AnoMes(SRA->RA_DEMISSA) <= cPeriodo //"FOL"
			//Verifica se existe registro de rescisão na RGB
			cAliasAux	:= GetNextAlias()
			cWhere   := "RGB.RGB_FILIAL = '"+cFil+"' AND RGB.RGB_MAT = '"+cMatr+"' AND "+;
						"RGB.RGB_PERIOD = '"+cPeriodo+"' AND RGB.RGB_PROCES = '" + cProces + "' AND "+;
						"RGB.RGB_ROTORI = '" + fGetCalcRot("4") + "'"
			cWhere   := "%"+cWhere+"%"

			BeginSql alias cAliasAux
				SELECT COUNT(*) TOTALREG
				FROM %table:RGB% RGB
					WHERE 		%exp:cWhere% AND
					RGB.%notDel%
			EndSql

			nTot := (cAliasAux)->TOTALREG

			(cAliasAux)->(dbCloseArea())

			If nTot > 0 //Existe registro de rescisão complementar na RGB, apenas grava e pula para o próximo funcionário
				//Exclui registro da RU6 da folha, caso ela tenha sido calculada antes da rescisão
				fDelDepRU6()
				GRAVACALC()
				NOPRCREG()
			EndIf

		EndIf

		// Busca verbas lancadas em Folha que incorporam Salario
		// Alterando valor do Salario Hora e afetando Medias pagas no 132
		If lDissidio .And. cTipoRot == "6" .and. !lCalcFol
			//Busca pagamento de 13º na RGB
			dbSelectArea("SRD")
			dbSetOrder(5) //RD_FILIAL+RD_MAT+RD_PROCES+RD_ROTEIR+RD_PERIODO+RD_SEMANA
			If dbSeek(cFil+cMatr+cProcesso+fGetCalcRot("1")+cPeriodo+cSemana)
				While !Eof() .And. SRD->(RD_FILIAL+RD_MAT+RD_PROCES+RD_ROTEIR+RD_PERIODO+RD_SEMANA) == cFil+cMatr+cProcesso+fGetCalcRot("1")+cPeriodo+cSemana
					If 	 SRD->RD_TIPO2 $ "I" .And. ;
						RetValSRV( SRD->RD_PD, cFil, "RV_INCORP" ) == "S"
						If RetValSRV( SRD->RD_PD, cFil, "RV_CODFOL" ) $ "0001/0002/0003/0004/0005";
						.And. SRD->(RD_ROTEIR) = "FOL" .And. SubStr(SRA->RA_ADTPOSE,4,1) == "N" //Verifico se o funcionário não possui cadastro de ATS e a mesma foi lançada manualmente no roteito 132, em caso de dissidio não adiciono no APD do 132 para evitar duplicidade
								dbSkip()
								Loop
						Endif
						If lItemClVl
							SRD->( fMatriz(RD_PD,RD_VALOR,RD_HORAS,RD_SEMANA,RD_CC,RD_TIPO1,RD_TIPO2,,,,,RD_SEQ,RD_QTDSEM,RD_ITEM,RD_CLVL,,,RD_IDCMPL,,,,,RD_CONVOC,,If(lUsaPLS,RD_LOTPLS,""),If(lUsaPLS,RD_CODRDA,"") ) )
						Else
							SRD->( fMatriz(RD_PD,RD_VALOR,RD_HORAS,RD_SEMANA,RD_CC,RD_TIPO1,RD_TIPO2,,,,,RD_SEQ,RD_QTDSEM,,,,,RD_IDCMPL,,,,,RD_CONVOC,,If(lUsaPLS,RD_LOTPLS,""),If(lUsaPLS,RD_CODRDA,"") ) )
						EndIf
					EndIf
					dbSkip()
				End While
			EndIf
		EndIf

		//Tratamento para "provisão" do eConsignado no adiantamento
		If cTipoRot == "2" .And. !Empty(aCodFol[1974,1]) .and. !Empty(aCodFol[1975,1])
			nValEConsig := 0			
			nValProv    := 0

			SRK->(DbSetOrder(1))
			If SRK->(DbSeek(SRA->RA_FILIAL+SRA->RA_MAT))
				While SRK->(!Eof() .and. RK_FILIAL + RK_MAT == SRA->RA_FILIAL + SRA->RA_MAT)
					If SRK->RK_STATUS == "2" .And. SRK->RK_EMPCONS == "1" .and. RetValSRV( SRK->RK_PD, SRA->RA_FILIAL, "RV_NATUREZ" ) == "9253"
						nValEConsig += 	SRK->RK_VALORPA							
					EndIf
					SRK->(dbSkip())
				EndDo
			EndIf
			If nValEConsig == 0 .and. lChkEConsig 
				cCompet := SubStr(cPeriodo,5,2)+SubStr(cPeriodo,1,4)
				RUO->(DbSetOrder(3))
				If RUO->(DbSeek(SRA->RA_FILIAL+SRA->RA_MAT+cCompet))
					While RUO->(!Eof() .and. RUO_FILIAL + RUO_MAT + RUO_COMPET == SRA->RA_FILIAL + SRA->RA_MAT + cCompet)
						nValEConsig += 	RUO->RUO_VLPARC							
						RUO->(dbSkip())
					EndDo
				EndIf
			EndIf
			If nValEConsig > 0 
				If !Empty(aCodFol[1971, 1]) .And. (nValProv := fBuscaProv(aCodFol[1971, 1] + If(!Empty(aCodFol[1972, 1]), "/" + aCodFol[1972, 1], ""), .T.)) > 0
					nValEConsig -= nValProv
				EndIf
				fMatriz(aCodFol[1974,1], ( nValEConsig / 100 ) * SRA->RA_PERCADT, SRA->RA_PERCADT )
				nValEConsig := 0
			EndIf
		EndIf

		If cTipoRot == "3" .And. !(lDissidio .Or. IsInCallStack("fCDifFerias"))
			//Tratamento para "provisão" do eConsignado nas férias
			If !Empty(aCodFol[1971,1]) .and. !Empty(aCodFol[1973,1])
				nValEConsig := 0			
				nValProv    := 0

				SRK->(DbSetOrder(1))
				If SRK->(DbSeek(SRA->RA_FILIAL+SRA->RA_MAT))
					While SRK->(!Eof() .and. RK_FILIAL + RK_MAT == SRA->RA_FILIAL + SRA->RA_MAT)
						If SRK->RK_STATUS == "2" .And. SRK->RK_EMPCONS == "1" .and. RetValSRV( SRK->RK_PD, SRA->RA_FILIAL, "RV_NATUREZ" ) == "9253"
							If AnoMes(SRK->RK_DTVENC) == cPeriodo .or. ( SRK->RK_PARCELA > 1 .and.  fVldParCons() )
								nValEConsig += SRK->RK_VALORPA
								aAdd(aECons, {SRK->RK_PD+AllTrim(SRK->RK_NRCONTR), SRK->RK_VALORPA})
							EndIf
						EndIf
						SRK->(dbSkip())
					EndDo
				EndIf
				If lChkEConsig 
					cCompet := SubStr(cPeriodo,5,2)+SubStr(cPeriodo,1,4)
					RUO->(DbSetOrder(3))
					If RUO->(DbSeek(SRA->RA_FILIAL+SRA->RA_MAT+cCompet))
						While RUO->(!Eof() .and. RUO_FILIAL + RUO_MAT + RUO_COMPET == SRA->RA_FILIAL + SRA->RA_MAT + cCompet)
							If RUO->RUO_INTEGR == "2" 
								nValEConsig += RUO->RUO_VLPARC	
								If (nPos := aScan(aECons, {|x| x[1] == RUO->RUO_PD+AllTrim(RUO->RUO_NRCONT)})) > 0
									nValEConsig -= aECons[nPos][2]
								EndIf							
							EndIf
							RUO->(dbSkip())
						EndDo
					EndIf
				EndIf
				If nValEConsig > 0 
					If !Empty(aCodFol[1974, 1]) .And. (nValProv := fBuscaProv(aCodFol[1974, 1], .F.)) > 0
						nValEConsig -= nValProv
					EndIf
					fMatriz(aCodFol[1971,1], nValEConsig / nDiasPerF1 * (nDiasFM+If(Empty(aCodFol[1972,1]),nDiasFMS,0)), (nDiasFM+If(Empty(aCodFol[1972,1]),nDiasFMS,0)) )
					If !Empty(aCodFol[1972,1]) .and. nDiasFMS > 0
						fMatriz(aCodFol[1972,1], nValEConsig / nDiasPerF2 * nDiasFMS, nDiasFMS)
					EndIf
				EndIf
			EndIf

			If lConsig
				fCarrTab( @aTabS137, "S137", Nil, .T. )
				If !Empty(aTabS137)
					nPos := aScan( aTabS137, { |x| x[2] == cFil } )
					If nPos == 0
						nPos := aScan( aTabS137, { |x| x[2] == Space(FwGetTamFilial) } )
					EndIf
					If nPos > 0
						cEmpCons 	:= aTabS137[nPos, 05]
						cPdFerMes 	:= aTabS137[nPos, 08]
						cPdFerMSeg 	:= aTabS137[nPos, 09]
						cPdFolMes 	:= aTabS137[nPos, 10]
						cPdFolMSeg 	:= aTabS137[nPos, 11]
						If !Empty(cEmpCons) .And. !Empty(cPdFerMes) .And. !Empty(cPdFolMes)
							RGB->( dbSetOrder(1) )
							If RGB->( dbSeek( cFil+cMatr ) )
								While RGB->( !EoF() ) .And. RGB->RGB_FILIAL+RGB->RGB_MAT == cFil+cMatr
									If RGB->RGB_PROCES == cProces .And. RGB->RGB_PERIOD == cPeriodo .And. RGB->RGB_SEMANA == cNumPag .And. RGB->RGB_PD == cEmpCons
										nValEmpCons += RGB->RGB_VALOR
									EndIf
									RGB->( dbSkip() )
								End
							EndIf
						EndIf
						If nValEmpCons == 0 //Verifica se houve desconto de consignado no mês anterior e se não foi a última parcela
							nMesesCon 	:= P_MCONSFER
							SRD->( dbSetOrder(1) )
							cPerAnt := cPeriodo
							For nMes := 1 to nMesesCon
								cPerAnt := SubMesAno( cPerAnt )
								If SRD->( dbSeek( cFil + cMatr + cPerAnt) )
									While SRD->( !EoF() .And. RD_FILIAL + RD_MAT + RD_DATARQ == cFil + cMatr + cPerAnt)
										If SRD->RD_PROCES == cProces .And. SRD->RD_PD == cEmpCons
											If SRD->RD_HORAS > 0 
												nRefCons := Int(SRD->RD_HORAS)
												nTotCons := Val(SubStr(cValToChar(SRD->RD_HORAS-nRefCons),3))
												If nRefCons + nMes <= nTotCons //Se ainda faltam parcelas para descontar
													nValEmpCons += SRD->RD_VALOR
													Exit 
												EndIf
											EndIf
										EndIf
										SRD->( dbSkip() )
									End
								EndIf
							Next nMes
						EndIf
						If nValEmpCons > 0
							IF SRA->RA_CATFUNC $ "H*G"
								If GetMvRH("MV_DIASPER",,"1") == "1"
									nDPAdc1 := nDPAdc2 := nDiasPerF1
								Else
									nDPAdc1 := nDPAdc2 := 30
								EndIf
							Else
								nDPAdc1 := nDiasPerF1
								nDPAdc2 := nDiasPerF2
							EndIf
							If Empty(cPdFerMSeg)
								fMatriz(cPdFerMes, nValEmpCons / nDPAdc1 * (nDiasFM+nDiasAbM+nDiasFMS+nDiasAbMS) )
							ElseIf !Empty(cPdFolMSeg)
								fMatriz(cPdFerMes, nValEmpCons / nDPAdc1 * (nDiasFM+nDiasAbM) )
								fMatriz(cPdFerMSeg, nValEmpCons / nDPAdc2 * (nDiasFMS+nDiasAbMS) )
							EndIf
						EndIf
					EndIf
				EndIf
			EndIf
		EndIf
	Else
		If dDatabase <= cToD("15/08/2022")
			AddLogExecRot(STR0130)//"A partir de 15/08/2022 o identificador 1893 se tornará obrigatório e o sistema não permitirá o calculo de férias sem o cadastro da verba vinculada ao ID"
		Else
			AddLogExecRot(STR0132)//"É obrigatório possuir verba vinculada ao ID 1893 devido exigência do eSocial"
			NoPrcReg()
		EndIf
		AddLogExecRot(STR0131 + "https://tdn.totvs.com/x/uk0wJg")//"Para mais informações consulte:"
	EndIf

    If __lMemCalc
        fAddMemLog("Verbas informadas no cálculo ? " + Iif( !Empty(aVbManual), "Sim.", "Não." ), 1, 2 )
        For nContVb := 1 To Len(aVbManual)
            If nContVb == 1
                fAddMemLog("Verbas informadas : ", 1, 3)
            EndIf
            fAddMemLog( "Código : " + aVbManual[nContVb, 1] + " - ID : " + aVbManual[nContVb, 2] + " - Descrição : " + aVbManual[nContVb, 3], 1, 3 )
        Next nContVb
    EndIf
EndIf

If lTemMultV .and. cTipoRot <> "F" .And. !( ( ( SRA->RA_CATFUNC $ "A*P*E*G" .and. Empty(SRA->RA_SALARIO) ) .Or. cTipoRot == "K" ) .and. Empty(aPd) .And. !fTemLanc()) //Se for autonomo/estagiário sem salário e sem verbas lançadas, não carrega bases de múltiplos vínculos
	fLoadMultv(.T.)
EndIf

//Se existir provisionamento de eConsignado, gera verbas para contabilização.
If ( aScan(aPd, {|x| x[1] $ aCodFol[1972,1] + "/" + aCodFol[1973,1] + "/" + aCodFol[1975,1] }) ) > 0
	//Gera verba 1976 com os valores provisionados nas férias no mês para uso na contabilização
	If !Empty(aCodFol[1976, 1])
		nValEConsig := 0
		aEval(aPd, {|x| If(x[1] == aCodFol[1973,1] .and. x[9] <> "D", nValEConsig += x[5], If(x[1] == aCodFol[1972,1] .and. x[9] <> "D", nValEConsig -= x[5], Nil))})
		If nValEConsig > 0
			fMatriz(aCodFol[1976, 1], nValEConsig)
		EndIf
	EndIf 

	//Gera verba 1977 com os valores provisionados no adiantamento para uso na contabilização
	If !Empty(aCodFol[1977, 1])
		nValEConsig := 0
		aEval(aPd, {|x| If(x[1] == aCodFol[1975,1] .and. x[9] <> "D", nValEConsig += x[5], Nil)})
		If nValEConsig > 0
			fMatriz(aCodFol[1977, 1], nValEConsig)
		EndIf
	EndIf
EndIf

RestArea(aArea)

Return(aPd)

/*/{Protheus.doc} fLoadMultv
Verifica se funcionários possuir outros vínculos e gera as verbas dos outros vínculos
@author Leandro Drumond
@since 15/04/2020
@version 1.0
/*/
Function fLoadMultv(lCarrPd)

Local aArea		:= GetArea()
Local aAreaSRA  := SRA->(GetArea())
Local aAreaRHH  := RHH->(GetArea())
Local aFilMat	:= {}
Local aCodFolX  := {}
Local aCodFolSav:= aClone(aCodFol)
Local aVerbasDel:= {}
Local cCodVerba := ""
Local cFilMat   := SRA->RA_FILIAL + SRA->RA_MAT
Local cFilMatIn := ""
Local cAliasAux := ""
Local cAliasAux2:= ""
Local cFilMatSRC:= ""
Local cFilMatSRD:= ""
Local cFilMatSRR:= ""
Local cFilMatOri:= ""
Local cPdAuxSRC	:= ""
Local cPdAuxSRD	:= ""
Local cPdAuxSRR	:= ""
Local cPdAux1	:= ""
Local cPdAux2	:= ""
Local cFilMatAux:= ""
Local cCpoSRC	:= ""
Local cCpoSRD	:= ""
Local cCpoSRR	:= ""
Local cRotADI	:= fGetCalcRot('2')
Local cRotAut	:= fGetCalcRot("9")
Local cRotRes	:= fGetCalcRot("4")
Local cRotRes13	:= fGetCalcRot("4") + "/" + fGetCalcRot("5") + "/" + fGetCalcRot("6")
Local cRotAtu   := If(cTipoRot $ "1*9", fGetCalcRot("1") + "/" + fGetCalcRot("9"), fGetCalcRot(cTipoRot))
Local cRotFOL   := fGetCalcRot("1")
Local cRotFER   := fGetCalcRot("3")
Local cRotMV    := cRotAut + "/" + cRotFOL + "/" + cRotFER + "/" + fGetCalcRot("6")
Local cAuxSeqMv	:= "0"
Local cAnoMes	:= AnoMes(dData_Pgto)
Local cCpf		:= SRA->RA_CIC
Local cCnpjAtu	:= ""
Local cTipo     := If(lDissidio, "I", "C")
Local cFiltroAnt:= SRA->(DbFilter())
Local cJoinSRC	:= ""
Local cJoinSRD	:= ""
Local cJoinSRR	:= ""
Local cUltFilSRC:= ""
Local cSemAux   := ""
Local lCompl13	:= (cTipoRot == "6" .And. lCalcFol)
Local lMultv	:= .F.
Local lMultEmp  := .F.
Local nContSRA	:= 0
Local nX  		:= 0
Local nPos		:= 0
Local nBsInssOut:= 0
Local nInssOut	:= 0
Local nInssFOut	:= 0
Local nBsIROut  := 0
Local nIrOut	:= 0
Local nBsAut	:= 0
Local nBsInss13 := 0
Local nInss13	:= 0
Local nBsIr13   := 0
Local nIr13   	:= 0
Local nBsIrFOut := 0
Local nIrFOut   := 0
Local bFiltSra
Local nBsInssMs := 0
Local nInssMsOut:= 0
Local nValAux   := 0
Local nValVerba	:= 0

Local aIrTrib 	:= {}
Local aCodBenef	:= {}
Local cVerbDed 	:= ""
Local lTem1951  := Len(aCodFol) > 0 .And. !Empty(aCodFol[1951,1])

Local lTribComp13 := .F.
Local lTribCompF  := .F.

DEFAULT lCarrPd     := .F.
DEFAULT lTemIN2110	:= SRC->( ColumnPos( "RC_IN2110" ) ) > 0
DEFAULT lTemTribIR	:= SRC->( ColumnPos( "RC_TRIBIR" ) ) > 0

lResExt				:= If( Type("lResExt") 		== "U"	, .F., lResExt)

nInssAOut := 0

If Empty(cCpf) .or. cTipoRot == "5" //Roteiro de primeira parcela não calcula IR e INSS, portanto, não precisa verificar MULTV
	Return .F.
EndIf

If cTipoRot == "K" .and. !Empty(SRA->RA_DEMISSA) //Se estiver calculando o roteiro VEX e vínculo esta demitido, não prossegue.
	Return .F.
EndIf

If !lCarrPd .Or. P_TPAPUIR == "2"
	If (nPos := Ascan(aEstb,{|x| AllTrim(x[1]) == AllTrim(SRA->RA_FILIAL)})) > 0
		cCnpjAtu := aEstb[nPos][2]
	EndIf
EndIf

Static nOrderMULTV := RetOrder("SRA","RA_CIC+RA_FILIAL+RA_MAT")

DbSelectArea("SRA")
DbSetOrder(nOrderMULTV)

If cTipoRot $ "3*4"
	SRA->(DbSetFilter({||.T.}, ".T."))
EndIf

SRA->(DbSeek(SRA->RA_CIC))

While SRA->(!Eof() .and. SRA->RA_CIC == cCpf)
	If SRA->RA_FILIAL + SRA->RA_MAT <> cFilMat .and. !(SRA->RA_RESCRAI $ "30/31") .And. (!lDissidio .or. AnoMes(SRA->RA_ADMISSA) <= cPeriodo)
		lMultv 	:= .T.
		nContSRA++
		If lCarrPd
			aAdd(aFilMat, {SRA->RA_FILIAL, SRA->RA_MAT, SRA->RA_PROCES, SRA->RA_TIPOPGT})
		ElseIf !lMultEmp
			If (nPos := Ascan(aEstb,{|x| AllTrim(x[1]) == AllTrim(SRA->RA_FILIAL)})) > 0
				If SubStr(cCnpjAtu,1,8) <> SubStr(aEstb[nPos][2],1,8)
					lMultEmp := .T.
				EndIf
			EndIf
		EndIf
	EndIf
	SRA->(DbSkip())
EndDo

RestArea(aAreaSRA)

If cTipoRot $ "3*4"
	If !Empty(cFiltroAnt)
		bFiltSra := &('{ || ' + cFiltroAnt + ' } ')
		SRA->(DbSetFilter(bFiltSra, cFiltroAnt))
	EndIf
EndIf

If lDissidio .And. SRA->RA_SITFOLH == "D" .And. SRA->RA_RESCRAI $ "30/31" .And. AnoMes(SRA->RA_DEMISSA) >= cPeriodo .And. nContSRA == 1
	lMultv := .F.
EndIf

If !lCarrPd
	lGrvRAZRAW  := lMultEmp
EndIf

RHH->( dbSetOrder(1) )//RHH_FILIAL+RHH_MAT+RHH_MESANO+RHH_DATA+RHH_VB+RHH_CC+RHH_ITEM+RHH_CLVL+RHH_SEMANA+RHH_SEQ+RHH_ROTEIR

If lMultV .and. lCarrPd

	For nX := 1 to Len(aFilMat)
		cFilMatIn += If(Empty(cFilMatIn), "" , ",") + "'" + aFilMat[nX,1] + aFilMat[nX,2] + "'"
		If nX == 1
			cFilMatSRC := "%("
			cFilMatSRD := "%("
			cFilMatSRR := "%("
		Else
			cFilMatSRC += " OR "
			cFilMatSRD += " OR "
			cFilMatSRR += " OR "
		EndIf
		cFilMatSRC += "(SRC.RC_FILIAL = '" + aFilMat[nX,1] + "' AND SRC.RC_MAT = '" + aFilMat[nX,2] + "')"
		cFilMatSRD += "(SRD.RD_FILIAL = '" + aFilMat[nX,1] + "' AND SRD.RD_MAT = '" + aFilMat[nX,2] + "')"
		cFilMatSRR += "(SRR.RR_FILIAL = '" + aFilMat[nX,1] + "' AND SRR.RR_MAT = '" + aFilMat[nX,2] + "')"
		If nX == Len(aFilMat)
			cFilMatSRC += ")%"
			cFilMatSRD += ")%"
			cFilMatSRR += ")%"
		EndIf

		// Cria APD para cada filial de Pesquisa
		If aScan( aCodFolT, { |x| x[1] == aFilMat[nX][1] } ) == 0
			aCodFolX := {}
			If FP_CODFOL(@aCodFolX, aFilMat[nX][1])
				Aadd(aCodFolT, { aFilMat[nX][1], aCodFolX })
			EndIf
		EndIf

	Next nX

	cFilMatOri := "%SRR.RR_FILIAL = '" + SRA->RA_FILIAL + "' AND SRR.RR_MAT = '" + SRA->RA_MAT + "'%"

	If !Empty(aFilMat)
		cAliasAux   := GetNextAlias()
		cAliasAux2  := GetNextAlias()

		If SRA->RA_CATFUNC $ "E*G" //Estagiário não recolhe INSS portantop não carrega dos demais vínculos
			cPdAux1		:= '0009'+'0010'+'0015'+'0016'+'0027'+'0066'+'0067'+'0071'+'0106'+'0992'+'0993'
		Else
			cPdAux1		:= '0009'+'0010'+'0013'+'0014'+'0015'+'0016'+'0019'+'0020'+'0027'+'0064'+'0065'+'0066'+'0067'+'0070'+'0071'+'0106'+'0221'+'0288'+'0289'+'0992'+'0993'+'1384'+'1412'
		EndIf

		cJoinSRC    := "%" + FWJoinFilial("SRC", "SRV") +"%"
		cPdAuxSRC  	:= "% SRV.RV_CODFOL IN ( " + fSqlIN( cPdAux1, 4 ) + " ) %"

		cJoinSRD    := "%" + FWJoinFilial("SRD", "SRV") +"%"
		cPdAuxSRD  	:= "% SRV.RV_CODFOL IN ( " + fSqlIN( cPdAux1, 4 ) + " ) %"

		If Empty(aPdFerMS) .Or. cPdUltFil != SRA->RA_FILIAL
			aPdFerMS	:= fCarPdFMS()
			cPdUltFil 	:= SRA->RA_FILIAL
		EndIf
		cPdAux2		:= cPdAux1 + '0232' + StrTran( aPdFerMS[2], "/" )

		cJoinSRR    := "%" + FWJoinFilial("SRR", "SRV")  +"%"
		cPdAuxSRR	:= "% SRV.RV_CODFOL IN ( " + fSqlIN( cPdAux2, 4 ) + ") %"

		cCpoSRC     := "RC_FILIAL, RC_MAT, RC_ROTEIR AS ROTEIRO, RC_PD, RC_CC, RC_DATA, RC_VALOR, RC_PERIODO, 'SRC' AS TAB, RC_SEQMV, RC_TIPO2, RC_SEMANA"
		cCpoSRD		:= "RD_FILIAL, RD_MAT, RD_ROTEIR AS ROTEIRO, RD_PD, RD_CC, RD_DATPGT, RD_VALOR, RD_PERIODO, 'SRD' AS TAB, " + Iif( lDissidio .Or. lCompl13, "RD_SEQMV", "'0' AS RC_SEQMV") + ", RD_TIPO2, RD_SEMANA"
        cCpoSRR     := "RR_FILIAL, RR_MAT, RR_ROTEIR AS ROTEIRO, RR_PD, RR_CC, RR_DATAPAG, RR_VALOR, RR_PERIODO, 'SRR' AS TAB, RR_SEQMV, RR_TIPO2, RR_SEMANA"

        If lTemIN2110
            cCpoSRC += ", RC_IN2110"
            cCpoSRD += ", RD_IN2110"
            cCpoSRR += ", ' ' AS RC_IN2110"
        EndIf

		If lTemTribIR
			cCpoSRC += ", RC_TRIBIR"
            cCpoSRD += ", RD_TRIBIR"
            cCpoSRR += ", RR_TRIBIR"
		EndIf

        cCpoSRC := "%" + cCpoSRC + "%"
        cCpoSRD := "%" + cCpoSRD + "%"
        cCpoSRR := "%" + cCpoSRR + "%"

		cDataIni 	:= cAnoMes+"01"
		cDataFim  	:= cAnoMes + StrZero(F_ULTDIA(StoD(cAnoMes+"01")),2)

		BeginSql alias cAliasAux
			COLUMN RC_DATA AS DATE
			COLUMN RD_DATPGT AS DATE
			COLUMN RR_DATAPAG AS DATE
			SELECT %exp:cCpoSRC%
			FROM %table:SRC% SRC
			INNER JOIN %Table:SRV% SRV
			ON %exp:cJoinSRC% AND %exp:cPdAuxSRC%  AND SRC.RC_PD = SRV.RV_COD AND SRV.%NotDel%
			WHERE %exp:cFilMatSRC% AND
			( SRC.RC_DATA BETWEEN %exp:cDataIni% AND %exp:cDataFim% OR SRC.RC_PERIODO = %exp:cPeriodo% ) AND
			SRC.%notDel%

			UNION ALL
			SELECT %exp:cCpoSRD%
			FROM %table:SRD% SRD
			INNER JOIN %Table:SRV% SRV
			ON %exp:cJoinSRD% AND %exp:cPdAuxSRD%  AND SRD.RD_PD = SRV.RV_COD AND SRV.%NotDel%
			WHERE %exp:cFilMatSRD% AND
			( SRD.RD_DATPGT BETWEEN %exp:cDataIni% AND %exp:cDataFim% OR SRD.RD_PERIODO = %exp:cPeriodo% ) AND
			SRD.%notDel%

			UNION ALL
			SELECT %exp:cCpoSRR%
			FROM %table:SRR% SRR
			INNER JOIN %Table:SRV% SRV
			ON %exp:cJoinSRR% AND %exp:cPdAuxSRR%  AND SRR.RR_PD = SRV.RV_COD AND SRV.%NotDel%
			WHERE %exp:cFilMatSRR% AND
			( SRR.RR_DATAPAG BETWEEN %exp:cDataIni% AND %exp:cDataFim% OR SRR.RR_PERIODO = %exp:cPeriodo% ) AND
			SRR.%notDel%
			ORDER BY TAB, ROTEIRO
		EndSql
		//Ordenado pela tabela para que férias e rescisão fiquem por último, de modo a possibilitar a verificação se já foram calculados na folha.
		cUltFilSRC	:= ""

		While !(cAliasAux)->(Eof())

            If lTemIN2110 .And. (cAliasAux)->RC_IN2110 == "1"
                (cAliasAux)->( dbSkip() )
                Loop
            EndIf

			//Carrega aCodFol da Filial pesquisada
			If  cUltFilSRC != (cAliasAux)->RC_FILIAL
				cUltFilSRC := (cAliasAux)->RC_FILIAL
				If ( nPos := aScan( aCodFolT, { |x| x[1] == (cAliasAux)->RC_FILIAL} ) ) == 0
					(cAliasAux)->(dbSkip())
					Loop
				EndIf
				aCodFol := aClone(aCodFolT[nPos][2])
			EndIf

			/*Se for cálculo de rescisão e registro atual for "Folha", verifica se já foi calculado rescisão neste vínculo e, 
			se o mês/ano de pagamento for o mesmo, ignora a base de IR da folha pois ela foi somada na rescisão.*/
			If cTipoRot == "4" .and. (cAliasAux)->RC_PD == aCodFol[15,1] .and. (cAliasAux)->ROTEIRO == cRotFOL .and. AnoMes((cAliasAux)->RC_DATA) == cPeriodo
				If SRG->(DbSeek((cAliasAux)->RC_FILIAL + (cAliasAux)->RC_MAT))
					If AnoMes(SRG->RG_DATAHOM) == AnoMes((cAliasAux)->RC_DATA)
						(cAliasAux)->(dbSkip())
						Loop
					EndIf
				EndIf
			EndIf

			If !(cTipoRot == "6" .and. (cAliasAux)->ROTEIRO <> cRotAtu ) .and. ( ( (cAliasAux)->TAB == "SRD" .And. !lDissidio .And. !lCompl13 ) .or. ( Empty(cSEQMV) .And. ( !Empty((cAliasAux)->RC_SEQMV) .Or. ((cAliasAux)->TAB == "SRR" .And. SRA->RA_SITFOLH != "D") ) ) .or. ( !Empty(CSEQMV)  .and. ( !Empty((cAliasAux)->RC_SEQMV) .or. ((cAliasAux)->TAB == "SRR" .And. SRA->RA_SITFOLH != "D") ) .and. CSEQMV > (cAliasAux)->RC_SEQMV ) .Or. (lDissidio .And. (cAliasAux)->RC_PERIODO == cPeriodo .And. (cAliasAux)->RC_PD $ (aCodFol[19,1]+"/"+aCodFol[20,1]+"/"+aCodFol[13,1]+"/"+aCodFol[14,1]+"/"+aCodFol[221,1]+"/"+aCodFol[1384,1]+"/"+aCodFol[64,1]+"/"+aCodFol[65,1]+"/"+ aCodFol[70,1]) ) )
                If lTemTribIR .and. lTem1951 .and. (cAliasAux)->ROTEIRO $ cRotMV .and. ( AnoMes((cAliasAux)->RC_DATA) == cAnoMes .OR. ( (cAliasAux)->ROTEIRO  == cRotFER .and. (cAliasAux)->RC_PERIODO == cAnoMes ) )
                    If aScan(aIrTrib, {|x| x[1] == (cAliasAux)->RC_FILIAL + (cAliasAux)->RC_MAT + (cAliasAux)->RC_PERIODO + (cAliasAux)->ROTEIRO }) == 0
                        aCodBenef := {}
                        cVerbDed  := ""
                        fBusCadBenef(@aCodBenef, (cAliasAux)->ROTEIRO)
                        fVerPDDed( @cVerbDed, If((cAliasAux)->ROTEIRO == cRotAut, cRotFOL, (cAliasAux)->ROTEIRO), aCodBenef, lResExt )
                        aAdd(aIrTrib, {(cAliasAux)->RC_FILIAL + (cAliasAux)->RC_MAT + (cAliasAux)->RC_PERIODO + (cAliasAux)->ROTEIRO,cVerbDed,.T.})
                    EndIf

                    //Subtrai deduções apenas se a tributação de IR do vínculo foi simplificada
                    If (cAliasAux)->RC_PD $ aCodFOl[15,1] + "/" + aCodFol[66,1] .and. (cAliasAux)->RC_TRIBIR <> "2" .and. !(SRA->RA_CATEFD $ "711|712|734")
                        AEval( aIrTrib, { |x| Iif( Right(x[1], 3 ) == (cAliasAux)->ROTEIRO, x[3] := .F., Nil ) } )
                    EndIf
                EndIf
				If ( (cAliasAux)->ROTEIRO $ cRotRes13 .or. ( cTipoRot == "1" .and. (cAliasAux)->ROTEIRO $ cRotAtu ) ) .and. (cAliasAux)->RC_PD $ aCodFol[19,1] + "/" + aCodFol[20,1] + "/" + aCodFol[27,1] + "/" + aCodFol[70,1] + "/" + aCodFol[71,1]
					If (cAliasAux)->RC_PD $ aCodFol[19,1] + "/" + aCodFol[20,1] .and. (cAliasAux)->RC_PERIODO == cPeriodo
						If lDissidio .And. (cAliasAux)->RC_SEQMV > CSEQMV
							nBasAuxD1 += (cAliasAux)->RC_VALOR
						Else
							nBsInss13 += (cAliasAux)->RC_VALOR
							If lDissidio .And. RHH->( dbSeek( (cAliasAux)->RC_FILIAL + (cAliasAux)->RC_MAT + cMesAnoCalc + (cAliasAux)->RC_PERIODO + (cAliasAux)->RC_PD + (cAliasAux)->RC_CC ) )
								nBsInss13 -= (cAliasAux)->RC_VALOR
								nBsInss13 += RHH->RHH_CALC
							EndIf
						EndIf
					ElseIf (cAliasAux)->RC_PD == aCodFol[70,1] .and. (cAliasAux)->RC_PERIODO == cPeriodo
						nInss13 += (cAliasAux)->RC_VALOR
						If lDissidio .And. RHH->( dbSeek( (cAliasAux)->RC_FILIAL + (cAliasAux)->RC_MAT + cMesAnoCalc + (cAliasAux)->RC_PERIODO + (cAliasAux)->RC_PD + (cAliasAux)->RC_CC ) )
							nInss13 -= (cAliasAux)->RC_VALOR
							nInss13 += RHH->RHH_CALC
						EndIf
					ElseIf (cAliasAux)->RC_PD == aCodFol[27,1] .and. (cAliasAux)->RC_PERIODO == cPeriodo .And. (cTipoRot <> '4' .Or. AnoMes((cAliasAux)->RC_DATA) == AnoMes(M->RG_DATAHOM))
						If P_TPAPUIR == "2"
							If (nPos := Ascan(aEstb, {|x| AllTrim(x[1]) == AllTrim((cAliasAux)->RC_FILIAL)})) > 0
								If SubStr(cCnpjAtu, 1, 8) == SubStr(aEstb[nPos][2], 1, 8)
									nBsIr13 += (cAliasAux)->RC_VALOR
								EndIf
							EndIf
						ElseIf P_TPAPUIR == "1"
							nBsIr13 += (cAliasAux)->RC_VALOR
						EndIf
						If lTemTribIR .and. (cAliasAux)->RC_TRIBIR == '1' //Tributação completa
							lTribComp13 := .T.
						EndIf
					ElseIf (cAliasAux)->RC_PD == aCodFol[71,1] .and. (cAliasAux)->RC_PERIODO == cPeriodo .And. (cTipoRot <> '4' .Or. AnoMes((cAliasAux)->RC_DATA) == AnoMes(M->RG_DATAHOM))
						If P_TPAPUIR == "2"
							If (nPos := Ascan(aEstb, {|x| AllTrim(x[1]) == AllTrim((cAliasAux)->RC_FILIAL)})) > 0
								If SubStr(cCnpjAtu, 1, 8) == SubStr(aEstb[nPos][2], 1, 8)
									nIr13 += (cAliasAux)->RC_VALOR
								EndIf
							EndIf
						ElseIf P_TPAPUIR == "1"
							nIr13 += (cAliasAux)->RC_VALOR
						EndIf
					EndIf
				ElseIf (cAliasAux)->TAB == "SRR"
					If Empty(cSEQMV)
						BeginSql alias cAliasAux2
							COLUMN RR_DATAPAG AS DATE
							SELECT RR_FILIAL, RR_MAT, RR_ROTEIR AS ROTEIRO, RR_PD, RR_CC, RR_DATAPAG, RR_VALOR, RR_PERIODO, "SRR" AS TAB, RR_SEQMV
							FROM %table:SRR% SRR
							INNER JOIN %Table:SRV% SRV
							ON %exp:cJoinSRR% AND %exp:cPdAuxSRR%  AND SRR.RR_PD = SRV.RV_COD AND SRV.%NotDel%
							WHERE %exp:cFilMatOri% AND
							( SRR.RR_DATAPAG BETWEEN %exp:cDataIni% AND %exp:cDataFim% OR SRR.RR_PERIODO = %exp:cPeriodo% ) AND
							SRR.%notDel%
							ORDER BY TAB, ROTEIRO
						EndSql
						If !(cAliasAux2)->(Eof())
							cSEQMV := (cAliasAux2)->RR_SEQMV
							If !Empty(CSEQMV) .And. (cAliasAux)->RC_SEQMV > CSEQMV
								(cAliasAux)->(dbSkip())
								Loop
							EndIf
						EndIf
						(cAliasAux2)->(dbCloseArea())
					EndIf

					//Apenas soma as verbas de férias/rescisão se elas não tiverem sido calculadas na folha.
					If !((cAliasAux)->RC_FILIAL + (cAliasAux)->RC_MAT + (cAliasAux)->RC_PERIODO $ cFilMatAux ) .And. ( CSEQMV > (cAliasAux)->RC_SEQMV .or. cTipoRot == "3" .or. (cAliasAux)->ROTEIRO == cRotRes )
						If (cAliasAux)->RC_PD $ aCodFol[13,1] + "/" + aCodFol[14,1] + "/" + aCodFol[221,1] + "/" + aCodFol[1384,1] .and. (cAliasAux)->RC_PERIODO == cPeriodo
							If lDissidio .And. (cAliasAux)->RC_SEQMV > CSEQMV
								nBasAuxD += (cAliasAux)->RC_VALOR
							Else
								nBsInssOut += (cAliasAux)->RC_VALOR
								If (cAliasAux)->ROTEIRO == cRotAut //Se for autonomo, deve incluir a verba 1847
									nBsAut += (cAliasAux)->RC_VALOR
								EndIf
							EndIf
						ElseIf 	(cAliasAux)->RC_PD $ aCodFol[64,1] + "/" + aCodFol[65,1] .and. (cAliasAux)->RC_PERIODO == cPeriodo
							If( (cAliasAux)->RC_PD == aCodFol[64,1], nInssOut += (cAliasAux)->RC_VALOR, nInssFOut += (cAliasAux)->RC_VALOR)
							If (cAliasAux)->ROTEIRO == cRotAut //Se for autonomo, deve incluir a verba no mnemonico nInssAOut
								nInssAOut += (cAliasAux)->RC_VALOR
							EndIf
						ElseIf (cAliasAux)->RC_PD $ aCodFol[15,1] + "/" +  aCodFol[16,1] + "/" + aCodFol[10,1] + "/" + aCodFol[106,1]  .and. (cAliasAux)->RC_PERIODO == cPeriodo .And.;
						       ( ( cTipoRot <> '4' .And. ( (cAliasAux)->ROTEIRO <> cRotRes .Or. AnoMes((cAliasAux)->RC_DATA) == cAnoMes ) ) .Or. ( cTipoRot == "4" .And. AnoMes((cAliasAux)->RC_DATA) == AnoMes(M->RG_DATAHOM) ) )
							If (cAliasAux)->RC_PD == aCodFol[106,1]
								If (cAliasAux)->ROTEIRO == cRotADI
									If P_TPAPUIR == "2"
										If (nPos := Ascan(aEstb, {|x| AllTrim(x[1]) == AllTrim((cAliasAux)->RC_FILIAL)})) > 0
											If SubStr(cCnpjAtu, 1, 8) == SubStr(aEstb[nPos][2], 1, 8)
												nBsIrOut -= (cAliasAux)->RC_VALOR
											EndIf
										EndIf
									ElseIf P_TPAPUIR == "1"
										nBsIrOut -= (cAliasAux)->RC_VALOR
									EndIf
								EndIf
							Else
								If (cAliasAux)->RC_PD == aCodFol[16,1] .and. (cAliasAux)->ROTEIRO == cRotRes
									If P_TPAPUIR == "2"
										If (nPos := Ascan(aEstb, {|x| AllTrim(x[1]) == AllTrim((cAliasAux)->RC_FILIAL)})) > 0
											If SubStr(cCnpjAtu, 1, 8) == SubStr(aEstb[nPos][2], 1, 8)
												nBsIrFOut += (cAliasAux)->RC_VALOR
											EndIf
										EndIf
									ElseIf P_TPAPUIR == "1"
										nBsIrFOut += (cAliasAux)->RC_VALOR
									EndIf
									If lTemTribIR .and. (cAliasAux)->RC_TRIBIR == '1' //Tributação completa
										lTribCompF := .T.
									EndIf
								Else
									If P_TPAPUIR == "2"
										If (nPos := Ascan(aEstb, {|x| AllTrim(x[1]) == AllTrim((cAliasAux)->RC_FILIAL)})) > 0
											If SubStr(cCnpjAtu, 1, 8) == SubStr(aEstb[nPos][2], 1, 8)
												nBsIrOut += (cAliasAux)->RC_VALOR
											EndIf
										EndIf
									ElseIf P_TPAPUIR == "1"
										nBsIrOut += (cAliasAux)->RC_VALOR
									EndIf
									If lTemTribIR .and. (cAliasAux)->ROTEIRO == cRotFER .and. (cAliasAux)->RC_PD == aCodFol[16,1] .and. (cAliasAux)->RC_TRIBIR == "1"
										lTribCompF := .T.
									EndIf
								EndIf
							EndIf
						ElseIf (cAliasAux)->RC_PD  $ aCodFol[66,1] + "/" + aCodFol[67,1] + "/" + aCodFol[9,1] .and. (cAliasAux)->RC_PERIODO == cPeriodo .And.;
								( ( cTipoRot <> '4' .And. ( (cAliasAux)->ROTEIRO <> cRotRes .Or. AnoMes((cAliasAux)->RC_DATA) == cAnoMes ) ) .Or. ( cTipoRot == "4" .And. AnoMes((cAliasAux)->RC_DATA) == AnoMes(M->RG_DATAHOM) ) )
							If (cAliasAux)->RC_PD == aCodFol[67,1] .and. (cAliasAux)->ROTEIRO == cRotRes
								If P_TPAPUIR == "2"
									If (nPos := Ascan(aEstb, {|x| AllTrim(x[1]) == AllTrim((cAliasAux)->RC_FILIAL)})) > 0
										If SubStr(cCnpjAtu, 1, 8) == SubStr(aEstb[nPos][2], 1, 8)
											nIrFOut += (cAliasAux)->RC_VALOR
										EndIf
									EndIf
								ElseIf P_TPAPUIR == "1"
									nIrFOut += (cAliasAux)->RC_VALOR
								EndIf
							Else
								If P_TPAPUIR == "2"
									If (nPos := Ascan(aEstb, {|x| AllTrim(x[1]) == AllTrim((cAliasAux)->RC_FILIAL)})) > 0
										If SubStr(cCnpjAtu, 1, 8) == SubStr(aEstb[nPos][2], 1, 8)
											nIrOut += (cAliasAux)->RC_VALOR
										EndIf
									EndIf
								ElseIf P_TPAPUIR == "1"
									nIrOut += (cAliasAux)->RC_VALOR
								EndIf
							EndIf
						ElseIf (cAliasAux)->RC_PD $ aPdFerMS[1] .And. (cAliasAux)->RC_PERIODO == cPeriodo

							nBsInssMs += (cAliasAux)->RC_VALOR

						ElseIf (cAliasAux)->RC_PD $ aCodFol[232,1] .and. (cAliasAux)->RC_PERIODO == cPeriodo

							nInssMsOut += (cAliasAux)->RC_VALOR

						EndIf
					EndIf
				Else
					//--INICIO Verbas de outras empresas lançadas--
					//Se foi lançado verbas de outras empresas (Fora do Protheus) em outro vínculo, carrega as verbas caso já não tenham sido lançadas no vínculo atual também
					If (cAliasAux)->RC_PD == aCodFol[288,1] .and. (cAliasAux)->RC_TIPO2 == "I" .and. ( nPos := (aScan(aPd, {|x| x[1] == aCodFolSav[288,1] .and. x[9] <> 'D' .and. x[7] == 'I' }))) == 0
						fMatriz(aCodFolSav[288,1],(cAliasAux)->RC_VALOR,,cSemana,,,"I",,,(cAliasAux)->RC_DATA)
					EndIf
					If (cAliasAux)->RC_PD == aCodFol[289,1] .and. (cAliasAux)->RC_TIPO2 == "I" .and. ( nPos := (aScan(aPd, {|x| x[1] == aCodFolSav[289,1] .and. x[9] <> 'D' .and. x[7] == 'I' }))) == 0
						fMatriz(aCodFolSav[289,1],(cAliasAux)->RC_VALOR,,cSemana,,,"I",,,(cAliasAux)->RC_DATA)
					EndIf
					If (cAliasAux)->RC_PD == aCodFol[992,1] .and. (cAliasAux)->RC_TIPO2 == "I" .and. ( nPos := (aScan(aPd, {|x| x[1] == aCodFolSav[992,1] .and. x[9] <> 'D' .and. x[7] == 'I' }))) == 0
						fMatriz(aCodFolSav[992,1],(cAliasAux)->RC_VALOR,,cSemana,,,"I",,,(cAliasAux)->RC_DATA)
					EndIf
					If (cAliasAux)->RC_PD == aCodFol[993,1] .and. (cAliasAux)->RC_TIPO2 == "I" .and. ( nPos := (aScan(aPd, {|x| x[1] == aCodFolSav[993,1] .and. x[9] <> 'D' .and. x[7] == 'I' }))) == 0
						fMatriz(aCodFolSav[993,1],(cAliasAux)->RC_VALOR,,cSemana,,,"I",,,(cAliasAux)->RC_DATA)
					EndIf
					//--FIM Verbas de outras empresas lançadas--

					lSomou := .F.
					If (cAliasAux)->RC_PD $ aCodFol[13,1] + "/" + aCodFol[14,1] + "/" + aCodFol[221,1] + "/" + aCodFol[1384,1] .and. (cAliasAux)->RC_PERIODO == cPeriodo
						If lDissidio .And. (cAliasAux)->RC_SEQMV > CSEQMV
							nBasAuxD += (cAliasAux)->RC_VALOR
						Else
							nBsInssOut += (cAliasAux)->RC_VALOR
							If lDissidio .And. RHH->( dbSeek( (cAliasAux)->RC_FILIAL + (cAliasAux)->RC_MAT + cMesAnoCalc + (cAliasAux)->RC_PERIODO + (cAliasAux)->RC_PD + (cAliasAux)->RC_CC ) )
								nBsInssOut -= (cAliasAux)->RC_VALOR
								nBsInssOut += RHH->RHH_CALC
							EndIf
						EndIf
						lSomou := .T.
						If (cAliasAux)->ROTEIRO == cRotAut //Se for autonomo, deve incluir a verba 1847
							nBsAut += (cAliasAux)->RC_VALOR
							If lDissidio .And. RHH->( dbSeek( (cAliasAux)->RC_FILIAL + (cAliasAux)->RC_MAT + cMesAnoCalc + (cAliasAux)->RC_PERIODO + (cAliasAux)->RC_PD + (cAliasAux)->RC_CC ) )
								nBsAut -= (cAliasAux)->RC_VALOR
								nBsAut += RHH->RHH_CALC
							EndIf
						EndIf
					ElseIf 	(cAliasAux)->RC_PD $ aCodFol[64,1] + "/" + aCodFol[65,1] .and. (cAliasAux)->RC_PERIODO == cPeriodo
						If( (cAliasAux)->RC_PD == aCodFol[64,1], nInssOut += (cAliasAux)->RC_VALOR, nInssFOut += (cAliasAux)->RC_VALOR)
						If lDissidio .And. RHH->( dbSeek( (cAliasAux)->RC_FILIAL + (cAliasAux)->RC_MAT + cMesAnoCalc + (cAliasAux)->RC_PERIODO + (cAliasAux)->RC_PD + (cAliasAux)->RC_CC ) )
							If( (cAliasAux)->RC_PD == aCodFol[64,1], nInssOut -= (cAliasAux)->RC_VALOR, nInssFOut -= (cAliasAux)->RC_VALOR)
							If( (cAliasAux)->RC_PD == aCodFol[64,1], nInssOut += RHH->RHH_CALC, nInssFOut += RHH->RHH_CALC)
						EndIf
						lSomou := .T.
						If (cAliasAux)->ROTEIRO == cRotAut //Se for autonomo, deve incluir a verba no mnemonico nInssAOut
							nInssAOut += (cAliasAux)->RC_VALOR
							If lDissidio .And. RHH->( dbSeek( (cAliasAux)->RC_FILIAL + (cAliasAux)->RC_MAT + cMesAnoCalc + (cAliasAux)->RC_PERIODO + (cAliasAux)->RC_PD + (cAliasAux)->RC_CC ) )
								nInssAOut -= (cAliasAux)->RC_VALOR
								nInssAOut += RHH->RHH_CALC
							EndIf
						EndIf
					ElseIf (cAliasAux)->RC_PD $ aCodFol[15,1] + "/" + aCodFol[16,1] + "/" + aCodFol[10,1] + "/" + aCodFol[106,1] .and. ( AnoMes((cAliasAux)->RC_DATA) == cAnoMes ) .and.;
						   ( cTipoRot <> '4' .or. AnoMes((cAliasAux)->RC_DATA) == AnoMes(M->RG_DATAHOM) )
						If (cAliasAux)->RC_PD == aCodFol[106,1]
							If (cAliasAux)->ROTEIRO == cRotADI
								If P_TPAPUIR == "2"
									If (nPos := Ascan(aEstb, {|x| AllTrim(x[1]) == AllTrim((cAliasAux)->RC_FILIAL)})) > 0
										If SubStr(cCnpjAtu, 1, 8) == SubStr(aEstb[nPos][2], 1, 8)
											nBsIrOut -= (cAliasAux)->RC_VALOR
										EndIf
									EndIf
								ElseIf P_TPAPUIR == "1"
									nBsIrOut -= (cAliasAux)->RC_VALOR
								EndIf
							ElseIf (cAliasAux)->ROTEIRO $ cRotAtu .and. (cAliasAux)->TAB == "SRC" .and. (cAliasAux)->RC_TIPO2 == "F" .and. AnoMes((cAliasAux)->RC_DATA) == AnoMes(DDATA_PGTO)
								If ( nPos := aScan( aFilMat, { |x| x[1]+x[2] == (cAliasAux)->RC_FILIAL + (cAliasAux)->RC_MAT }) ) > 0 .and. aFilMat[nPos,4] == "S"
									nBsIrOut -= (cAliasAux)->RC_VALOR
								EndIf
							EndIf
						ElseIf (cAliasAux)->RC_PD <> aCodFol[15,1] .or. cTipoRot <> '3' //Não soma IR de folha com IR de férias
							If P_TPAPUIR == "2"
								If (nPos := Ascan(aEstb, {|x| AllTrim(x[1]) == AllTrim((cAliasAux)->RC_FILIAL)})) > 0
									If SubStr(cCnpjAtu, 1, 8) == SubStr(aEstb[nPos][2], 1, 8)
										If( (cAliasAux)->RC_PD == aCodFol[16,1], nBsIrFOut += (cAliasAux)->RC_VALOR, nBsIrOut += (cAliasAux)->RC_VALOR)
										lSomou := .T.
									EndIf
								EndIf
							ElseIf P_TPAPUIR == "1" .And. (cAliasAux)->ROTEIRO == cRotAut .And. (cAliasAux)->RC_PERIODO == cPeriodo .And. SRA->RA_CATFUNC == "A" .And. !(SRA->RA_CATEG $ '15|16|18' .Or. SRA->RA_CATEFD $ "711|712|734")  
								If (cAliasAux)->RC_SEMANA >= cSemAux
									If (cAliasAux)->RC_SEMANA == cSemana
										If( (cAliasAux)->RC_PD == aCodFol[16,1], nBsIrFOut += (cAliasAux)->RC_VALOR, nBsIrOut += (cAliasAux)->RC_VALOR)
									Else
										If( (cAliasAux)->RC_PD == aCodFol[16,1], nBsIrFOut := (cAliasAux)->RC_VALOR, nBsIrOut := (cAliasAux)->RC_VALOR)
									EndIf
									lSomou  := .T.
									cSemAux := (cAliasAux)->RC_SEMANA
								EndIf
							ElseIf P_TPAPUIR == "1"
								If( (cAliasAux)->RC_PD == aCodFol[16,1], nBsIrFOut += (cAliasAux)->RC_VALOR, nBsIrOut += (cAliasAux)->RC_VALOR)
								lSomou := .T.
							EndIf
						EndIf
					ElseIf (cAliasAux)->RC_PD $ aCodFol[66,1] + "/" + aCodFol[67,1] + "/" + aCodFol[9,1] .and. ( AnoMes((cAliasAux)->RC_DATA) == cAnoMes ) .and.;
						   ( cTipoRot <> '4' .or. AnoMes((cAliasAux)->RC_DATA) == AnoMes(M->RG_DATAHOM) )
						If (cAliasAux)->RC_PD <> aCodFol[66,1] .or. cTipoRot <> '3' //Não soma IR de folha com IR de férias
							If P_TPAPUIR == "2"
								If (nPos := Ascan(aEstb, {|x| AllTrim(x[1]) == AllTrim((cAliasAux)->RC_FILIAL)})) > 0
									If SubStr(cCnpjAtu, 1, 8) == SubStr(aEstb[nPos][2], 1, 8)
										If( (cAliasAux)->RC_PD == aCodFol[67,1], nIrFOut += (cAliasAux)->RC_VALOR, nIrOut += (cAliasAux)->RC_VALOR)
										lSomou := .T.
									EndIf
								EndIf
							ElseIf P_TPAPUIR == "1"
								If( (cAliasAux)->RC_PD == aCodFol[67,1], nIrFOut += (cAliasAux)->RC_VALOR, nIrOut += (cAliasAux)->RC_VALOR)
								lSomou := .T.
							EndIf
						EndIf
					ElseIf (cAliasAux)->RC_PD $ aCodFol[1412,1] .and. (cAliasAux)->RC_PERIODO == cPeriodo //Devolucao Inss Ferias outra empresa
						nInssDevFe += (cAliasAux)->RC_VALOR
					EndIf
					If (cAliasAux)->TAB == "SRC" .and. (cAliasAux)->ROTEIRO <> cRotADI .and. lSomou
						//Indica que funcionário já teve a folha calculada no período
						cFilMatAux += (cAliasAux)->RC_FILIAL + (cAliasAux)->RC_MAT + (cAliasAux)->RC_PERIODO + "|"
					EndIf
				EndIf
				If  (cAliasAux)->ROTEIRO $ cRotAtu .and. (cAliasAux)->RC_SEQMV > cAuxSeqMv
					cAuxSeqMv := (cAliasAux)->RC_SEQMV
				EndIf
			EndIf

			(cAliasAux)->(dbSkip())
		EndDo

		//Recupera aCodFol da Filial Corrente
		aCodFol := Aclone(aCodFolSav)

		If Empty(CSEQMV)
			If cAuxSeqMv > "0"
				CSEQMV := Soma1(cAuxSeqMv)
			Else
				CSEQMV := "1"
			EndIf
		EndIf

		(cAliasAux)->(dbCloseArea())

		If nBsInssOut > 0 .And. cTipoRot != "2"
			cCodVerba := Iif( cTipoRot == "3", aCodFol[396, 1], aCodFol[288, 1] )		
            aAdd( aVerbasDel, cCodVerba )
            fMatriz(cCodVerba, nBsInssOut, Nil, cSemana, Nil, Nil, cTipo, Nil, Nil, Nil, Nil, "9")

			If nBsAut > 0 .and. !Empty(aCodFol[1847,1])
                aAdd( aVerbasDel, aCodFol[1847, 1] )
                fMatriz(aCodFol[1847,1],nBsAut,,cSemana,,,cTipo,,,,,"9")
			EndIf
		EndIf

		If nInssOut > 0 .And. cTipoRot != "2"
			cCodVerba := aCodFol[289, 1]
            aAdd( aVerbasDel, cCodVerba )
            fMatriz(cCodVerba, nInssOut, Nil, cSemana, Nil, Nil, cTipo, Nil, Nil, Nil, Nil, "9")            
		EndIf

		If nInssFOut > 0 .And. cTipoRot != "2"
			cCodVerba := aCodFol[397, 1]
            aAdd( aVerbasDel, cCodVerba )
			Aeval( aPd ,{ |X| If (x[1] $ aCodFol[0397,1] .And. X[3] = cSemana .And.  x[7] == "K" .And. X[9] # "D", x[9] := "D", "") })
            fMatriz(cCodVerba, nInssFOut, Nil, cSemana, Nil, Nil, cTipo, Nil, Nil, Nil, Nil, "9")            
		EndIf

		If nBsIrOut > 0
			nValAux := 0
			For nPos := 1 to Len(aIrTrib)
				If aIrTrib[nPos,3]
					nValAux += fBuscaDed(aIrTrib[nPos,1], aIrTrib[nPos,2])
				EndIf
			Next nPos
			If nValAux > 0
				fMatriz(aCodFol[1951,1],nValAux,,cSemana,,,cTipo,,,,,"9")
			EndIf

			cCodVerba := Iif( cTipoRot == "3", aCodFol[236, 1], aCodFol[992, 1] )
            nValVerba := Iif( cTipoRot == "3", (nBsIrOut + nBsIrFOut), nBsIrOut )
            aAdd( aVerbasDel, cCodVerba )
			fMatriz(cCodVerba, nValVerba, Nil, cSemana, Nil, Nil, cTipo, Nil, Nil, Nil, Nil, "9", Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Iif( cTipoRot == "3", Iif(!lTemTribIR,"", If(lTribCompF,"1","2")), Nil ) )

			If cTipoRot == "3" //Férias
				nBsIrFOut := 0
				nValAux := 0
				For nPos := 1 to Len(aIrTrib)
					If aIrTrib[nPos,3]
						nValAux += fBuscaDed(aIrTrib[nPos,1], aIrTrib[nPos,2],.T.)
					EndIf
				Next nPos
				If nValAux > 0
					fMatriz(aCodFol[1951,1],nValAux,,cSemana,,,cTipo,,,,,"9")
				EndIf
			EndIf
		EndIf

		If nBsIrFOut > 0
            aAdd( aVerbasDel, aCodFol[236, 1] )
			fMatriz(aCodFol[236,1],nBsIrFOut,,cSemana,,,cTipo,,,,,"9",,,,,,,,,,,,,,,,,,Iif(!lTemTribIR,"", If(lTribCompF,"1","2")))
			nValAux := 0
			For nPos := 1 to Len(aIrTrib)
				If aIrTrib[nPos,3]
					nValAux += fBuscaDed(aIrTrib[nPos,1], aIrTrib[nPos,2],.T.)
				EndIf
			Next nPos
			If nValAux > 0
				fMatriz(aCodFol[1951,1],nValAux,,cSemana,,,cTipo,,,,,"9")
			EndIf
		EndIf

		If nIrOut > 0
			cCodVerba := Iif( cTipoRot == "3", aCodFol[237, 1], aCodFol[993, 1] )
            nValVerba := Iif( cTipoRot == "3", (nIrOut + nIrFOut), nIrOut )
            aAdd( aVerbasDel, cCodVerba )
            fMatriz(cCodVerba, nValVerba, Nil, cSemana, Nil, Nil, cTipo, Nil, Nil, Nil, Nil, "9")

			If cTipoRot == "3" //Férias
				nIrFOut := 0
			EndIf
		EndIf

		If nIrFOut > 0
            aAdd( aVerbasDel, aCodFol[237, 1] )
			fMatriz(aCodFol[237,1],nIrFOut,,cSemana,,,cTipo,,,,,"9")
		EndIf

		If nBsInss13 > 0 .And. cTipoRot != "2"
            aAdd( aVerbasDel, aCodFol[290, 1] )
			fMatriz(aCodFol[290,1],nBsInss13,,cSemana,,,cTipo,,,,,"9")
		EndIf

		If nInss13 > 0  .And. cTipoRot != "2"
            aAdd( aVerbasDel, aCodFol[291, 1] )
			fMatriz(aCodFol[291,1],nInss13,,cSemana,,,cTipo,,,,,"9")
		EndIf

		If nBsIr13 > 0
			aAdd( aVerbasDel, aCodFol[994, 1] )
			fMatriz(aCodFol[994,1],nBsIr13,,cSemana,,,cTipo,,,,,"9",,,,,,,,,,,,,,,,,,Iif(!lTemTribIR,"", If(lTribComp13,"1","2")))
			nValAux := 0
			For nPos := 1 to Len(aIrTrib)
				If aIrTrib[nPos,3]
					nValAux += fBuscaDed(aIrTrib[nPos,1], aIrTrib[nPos,2])
				EndIf
			Next nPos
			If nValAux > 0
				fMatriz(aCodFol[1951,1],nValAux,,cSemana,,,cTipo,,,,,"9")
			EndIf
		EndIf

		If nIr13 > 0
            aAdd( aVerbasDel, aCodFol[995, 1] )
			fMatriz(aCodFol[995,1],nIr13,,cSemana,,,cTipo,,,,,"9",,,,,,,,,,,,,,,,,,Iif(!lTemTribIR,"", If(lTribComp13,"1","2")))
		EndIf

        If nBsInssMs > 0 .And. Len(aCodFol) > 1859 .And. cTipoRot != "2"
			aAdd( aVerbasDel, aCodFol[1860, 1] )
			fMatriz(aCodFol[1860,1],nBsInssMs,,cSemana,,,cTipo,,,,,"9")
		EndIf

        If nInssMsOut > 0 .And. Len(aCodFol) > 1859 .And. cTipoRot != "2"
            aAdd( aVerbasDel, aCodFol[1861, 1] )
			fMatriz(aCodFol[1861,1],nInssMsOut,,cSemana,,,cTipo,,,,,"9")
		EndIf

        If cSemana > "01"
            fMarcDelVbs( aVerbasDel )
        EndIf
	EndIf
EndIf

RestArea(aAreaRHH)
RestArea(aArea)

Return lMultv

/*/{Protheus.doc} fGerBasFer
Função que verifica a base do IR de férias sem deduções e gera o Id 1562
@author Allyson Mesashi
@since 22/08/2018
@version 1.0
@param aVb 	 - Array das verbas do roteiro FER
/*/
Function fGerBasFer( aVb )

Local aAux		:= {}
Local aAux2		:= {}
Local cTipo		:= ""
Local cVerba	:= ""
Local cVbContrP	:= ""
Local lAtuVb	:= (Len(aCodFol) >= 1723)
Local lAtuVb4	:= (Len(aCodFol) >= 1893)
Local leSocSimpl:= (GetMvRH( "MV_VLESOC", Nil, "" ) >= "S_01_00_00")
Local lRet		:= .T.
Local lVldCond1	:= .F.
Local lVldCond2	:= .F.
Local lVldCond3	:= .F.
Local lVldCond4	:= .F.
Local nCont 	:= 1
Local nPos		:= 0
Local lTemContrap	:= SRV->(ColumnPos("RV_CONTRAP"))

For nCont := 1 To Len(aVb)
	//Se for referente ferias e incide para IR
	lVldCond1	:= (RetValSrv( aVb[nCont, 1], SRA->RA_FILIAL, "RV_REFFER" ) == "S" .And. RetValSrv( aVb[nCont, 1], SRA->RA_FILIAL, "RV_IR" ) == "S" .And. RetValSrv( aVb[nCont, 1], SRA->RA_FILIAL, "RV_TIPOCOD" ) == "1")
	//Se for referente abono
	lVldCond2	:= (lAtuVb .And. RetValSrv( aVb[nCont, 1], SRA->RA_FILIAL, "RV_IR" ) == "N" .And. (RetValSrv( aVb[nCont, 1], SRA->RA_FILIAL, "RV_CODFOL" ) $ "0074/0079/0094/0095/0205/0206/0207/0208/0622/0623/0632/0633/0634/0635/1312/1313/1314/1315/1316/1317/1318/1319/1320/1321/1322/1323/1324/1325/1326/1327/1330/1331/1407/1408/1409/1410/1416/1417/1418/1419/1450/1451/" .Or. (lRefAbono .And. RetValSrv( aVb[nCont, 1], SRA->RA_FILIAL, "RV_REFABON" ) == "1") ) .And. RetValSrv( aVb[nCont, 1], SRA->RA_FILIAL, "RV_TIPOCOD" ) == "1" )
	//Se for referente Dedução INSS Base IR Ferias
	lVldCond3	:= (lAtuVb .And. RetValSrv( aVb[nCont, 1], SRA->RA_FILIAL, "RV_CODFOL" ) == "0168" .And. RetValSrv( aVb[nCont, 1], SRA->RA_FILIAL, "RV_INCIRF" ) == "43")
	//Se for referente Dedução IRRF Ferias
	lVldCond4	:= (lAtuVb4 .And. RetValSrv( aVb[nCont, 1], SRA->RA_FILIAL, "RV_INCIRF" ) == "33")

	If lVldCond1
		cTipo	:= "1"
	ElseIf lVldCond2
		cTipo	:= "2"
	ElseIf lVldCond3
		cTipo	:= "3"
	ElseIf lVldCond4
		cTipo	:= "4"
	EndIf

	If (lVldCond1 .Or. lVldCond2 .Or. lVldCond3 .Or. lVldCond4)
		If ( nPos := aScan( aAux, { |x| x[19] == cTipo } ) ) > 0
			aAux[ nPos, 5 ] += aVb[nCont, 5]
		Else
			aAdd( aAux, { "", aVb[nCont, 2], aVb[nCont, 3], 0, aVb[nCont, 5], "", "", 0, "", aVb[nCont, 10], aVb[nCont, 11], 0, "", "", "", .F., "", aVb[nCont, 18], cTipo} )
		EndIf
	EndIf

	//Caso exista verba de contrapartida no campo RV_CONTRAP
	If lTemContrap
		cVbContrP := RetValSrv( aVb[nCont, 1], SRA->RA_FILIAL, "RV_CONTRAP" )
		If !Empty(cVbContrP)
			If ( nPos := aScan( aAux2, { |x| x[19] == cVbContrP } ) ) > 0
				aAux2[ nPos, 5 ] += aVb[nCont, 5]
			Else
				aAdd( aAux2, { "", aVb[nCont, 2], aVb[nCont, 3], 0, aVb[nCont, 5], "", "", 0, "", aVb[nCont, 10], aVb[nCont, 11], 0, "", "", "", .F., "", aVb[nCont, 18], cVbContrP} )
			EndIf
		EndIf
	EndIf
Next nCont

If !Empty(aAux)
	For nCont := 1 To Len(aAux)
		If aAux[nCont, 19] == "1"
			cVerba	:= aCodFol[1562, 1]
		ElseIf aAux[nCont, 19] == "2"
			cVerba	:= aCodFol[1722, 1]
		ElseIf aAux[nCont, 19] == "3"
			cVerba	:= aCodFol[1723, 1]
		ElseIf aAux[nCont, 19] == "4"
			cVerba	:= aCodFol[1893, 1]
			lRet	:= !(leSocSimpl .And. Empty(cVerba))
		EndIf
		If !Empty(cVerba)
			FMatriz(cVerba, aAux[nCont, 5], 0, aAux[nCont, 3], aAux[nCont, 2], "V", "C", Nil, Nil, aAux[nCont, 10], Nil, aAux[nCont, 11], Nil, Nil, Nil, Nil, Nil, Nil, aVb[nCont, 18] )
		EndIf
	Next nCont
EndIf

If !Empty(aAux2)
	For nCont := 1 To Len(aAux2)
		FMatriz(aAux2[nCont, 19], aAux2[nCont, 5], 0, aAux2[nCont, 3], aAux2[nCont, 2], "V", "C", Nil, Nil, aAux2[nCont, 10], Nil, aAux2[nCont, 11], Nil, Nil, Nil, Nil, Nil, Nil, aAux2[nCont, 18] )
	Next nCont
EndIf

Return lRet


/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³GRAVACALC ºAutor  ³Microsiga           º Data ³  12/16/03   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Gravacao do Calculo da Folha                               º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Function GravaCalc()
Local cPergTmp 	:= "GP020VTR"
Local lDCTFWEB  := GetMvRH( "MV_RHDCTFW", , .F. )

If LNOVOCALCB //mnemonico que carrega parametro MV_CALCBEN
	cPergTmp := "GP021VTR"
EndIf

If Type("cPergEspec") != "U" .And. Alltrim(cPergEspec) == cPergTmp
	Return(.T.)
EndIf

Begin Transaction
	lDissidio 	:= If(Type("lDissidio") == "U",.F.,lDissidio)

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Ordena por Verba Deletada para, se existir Chave Duplicada no³
	//³ aPd, Primeiro Deletar para Depois Gravar					 ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

	aSort( aPd ,,, { |x,y| x[9] > y[9] } )

	If !lDissidio

		If ( GetRotExec() $ fGetCalcRot("1") + "*" + fGetCalcRot("9") + "*" + fGetCalcRot("N") + "*" + fGetCalcRot("O") ) //"FOL*AUT*RTF*BOP"

			//Efetua a gravação das tabelas RAZ/RAW para funcionários múltiplos vínculos
			If lGrvRAZRAW
				fGrvRAZRAW()
			EndIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Grava a matriz das verbas da Folha no Arquivo SRC			 ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			Aeval( aPD , { |X| Gravafol(X) } )

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Verificar se existe Campo Sal.Incorporado no cadastro      ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			dbSelectArea( "SRA" )
			If FieldPos( "RA_SALINCO" ) # 0
				RecLock("SRA",.F.)
				SRA->RA_SALINCO := SALMES
				MsUnLock()
			EndIf
		Else

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Grava a matriz das verbas da Folha no Arquivo SRC			 ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			Aeval( aPD , { |X| GravaAdt(X) } )

		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Grava as verbas de impostos reliquidados na tabela RGV       ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If cPaisLoc == "CHI" .And. !Empty( aImpRlq )

			cProcesso := SRA->RA_PROCES
			cRoteiro  := GetRotExec()

			dbSelectArea("RGV")
			dbSetOrder(1)

			If dbSeek( SRA->( RA_FILIAL + RA_MAT + MesAno(dDataAte) ) )
				While RGV->( !Eof() .And. SRA->( RA_FILIAL + RA_MAT ) == RGV_FILIAL + RGV_MAT )
					RecLock( "RGV", .F., .T. )
					RGV->( dbDelete() )
					RGV->( MsUnLock() )
					RGV->( dbSkip() )
				EndDo
			EndIf

			Aeval( aImpRlq , { |X| GrvReliq(X) } )
		EndIf
	EndIf
End Transaction

If ( GetRotExec() == fGetRotOrdinar() ) // Roteiro Folha de Pagamento - roteiro ordinario

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Se for recalculo, deletar o registro de "OK", indicando que  |
	//| devera ser gerado um novo SRZ.								 |
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If !lDissidio
		fDelRegSRZ(1,SRA->RA_TPCONTR)
	Else
		GravaDissidio(aPd,aPdOld,,aCodFol)
	EndIf

EndIf

If cTipoRot $ "1*9" .and. !lDissidio .And. lDCTFWEB
	fGrvDCTFWEB()
EndIf

Return(.T.)

/*/{Protheus.doc} fGrvDCTFWEB
Função para gravação das informações necessárias para a geração do relatório DCTFWEB
@author Tribe Proheus RH
@since 22/09/2022
/*/
Static Function fGrvDCTFWEB()

	Local lDCTFWeb 	:= ChkFile("RU0") .And. FindFunction("fGrauExp")
	Local cAgeNoci	:= ""
	Local cContVA	:= ""
	Local lNovo		:= .T.
	Local aPDCopy 	:= aClone(aPD)
	Local apdRU0	:= {}
	Local cCodCC	:= ""
	Local cCodCCAnt	:= ""
	Local nX		:= 0
	Local nPos		:= 1
	Local cCodLot 	:= ""
	Local cFPAS		:= ""
	Local cCodTerc	:= ""
	Local cPer		:= cPeriodo
	Local nPosRatA	:= 0
	Local lCpoPIS 	:= .F.

	Local nVlrSalFam 	:= 0
	Local nVlrSalMat 	:= 0
	Local nVlrPat 		:= 0
	Local nVlrINCRA 	:= 0
	Local nVlrSENAC 	:= 0
	Local nVlRSESC 		:= 0
	Local nVlrSEBRAE 	:= 0
	Local nVlrSEST 		:= 0
	Local nVlrSENAT		:= 0
	Local nVlrSalEdu 	:= 0
	Local nVlrTotBc		:= 0
	Local nVlrTotBcS	:= 0
	Local nPercFAP		:= 0
	Local nPercRAT		:= 0
	Local nPercRATA		:= 0
	Local nVlrSENAI		:= 0
	Local nVlrSESI		:= 0
	Local nVlrDPC		:= 0
	Local nVlrFAER		:= 0
	Local nVlrSENAR		:= 0
	Local nVlrSECONC	:= 0
	Local nVlrSECOOP	:= 0
	Local nVlrTerc		:= 0
	Local nVlrGILRAT	:= 0
	Local nVlrPIS		:= 0

	//Grava a tabela com os dados utilizados na geração do relatório DCTFWEB
	If lDCTFWeb
		cAgeNoci 	:= fGrauExp()
		cContVA		:= If(SRA->RA_CATEFD $ "107*108", "S", "N")
		lCpoPIS		:= RU0->( ColumnPos( "RU0_PIS" ) ) > 0

		//Ordena o array por centro de custo+verba
		aSort(aPDCopy,,,{ |x,y|  x[2]+x[1] < y[2]+y[1] })

		//Adiciona no array apdRU0 os valores por centro de custo:
		For nX := 1 to len(aPDCopy)
			cCodCC		:= aPDCopy[nX,2]

			If cCodCCAnt <> cCodCC
				aAdd( apdRU0, {cCodCC, {aPDCopy[nX]}} )
				nPos := Len(apdRU0)
			Else
				aAdd( apdRU0[nPos,2], aPDCopy[nX] )
			EndIf

			cCodCCAnt := cCodCC
		Next Nx

		//Para 13º Ajusta a informação do período, validação posterior
		If cTipoRot == "6"
			cPer := SubStr(cPeriodo,1,4) + space(2)
		EndIf

		//Varre o array aPdRU0 para gravação da tabela
		For nX := 1 To Len(apdRU0)

			//Zera as variáveis
			nVlrSalFam 	:= 0
			nVlrSalMat 	:= 0
			nVlrPat 	:= 0
			nVlrINCRA 	:= 0
			nVlrSENAC 	:= 0
			nVlRSESC 	:= 0
			nVlrSEBRAE 	:= 0
			nVlrSEST 	:= 0
			nVlrSENAT	:= 0
			nVlrSalEdu 	:= 0
			nVlrSENAI	:= 0
			nVlrSESI	:= 0
			nVlrDPC		:= 0
			nVlrFAER	:= 0
			nVlrSENAR	:= 0
			nVlrSECONC	:= 0
			nVlrSECOOP	:= 0
			nVlrTerc	:= 0
			nVlrGILRAT	:= 0
			nVlrTotBc	:= 0
			nVlrTotBcS	:= 0
			cCodTerc	:= ""
			nPercFAP	:= 0
			nPercRAT	:= 0
			nPercRATA	:= 0
			nVlrPIS		:= 0

			//Obtém os valores utilizados no relatório
			nVlrPat 	:= If(npos := aScan( apdRU0[nX, 2], { |x| x[1] == ACODFOL[148,1]} ), apdRU0[Nx, 2, nPos, 5], 0)
			nVlrINCRA 	:= If(npos := aScan( apdRU0[nX, 2], { |x| x[1] == ACODFOL[184,1]} ), apdRU0[Nx, 2, nPos, 5], 0)
			nVlrSENAC 	:= If(npos := aScan( apdRU0[nX, 2], { |x| x[1] == ACODFOL[187,1]} ), apdRU0[Nx, 2, nPos, 5], 0)
			nVlRSESC 	:= If(npos := aScan( apdRU0[nX, 2], { |x| x[1] == ACODFOL[188,1]} ), apdRU0[Nx, 2, nPos, 5], 0)
			nVlrSEBRAE 	:= If(npos := aScan( apdRU0[nX, 2], { |x| x[1] == ACODFOL[189,1]} ), apdRU0[Nx, 2, nPos, 5], 0)
			nVlrSEST 	:= If(npos := aScan( apdRU0[nX, 2], { |x| x[1] == ACODFOL[200,1]} ), apdRU0[Nx, 2, nPos, 5], 0)
			nVlrSENAT	:= If(npos := aScan( apdRU0[nX, 2], { |x| x[1] == ACODFOL[201,1]} ), apdRU0[Nx, 2, nPos, 5], 0)
			nVlrSalEdu 	:= If(npos := aScan( apdRU0[nX, 2], { |x| x[1] == ACODFOL[204,1]} ), apdRU0[Nx, 2, nPos, 5], 0)
			nVlrSENAI 	:= If(npos := aScan( apdRU0[nX, 2], { |x| x[1] == ACODFOL[185,1]} ), apdRU0[Nx, 2, nPos, 5], 0)
			nVlrSESI 	:= If(npos := aScan( apdRU0[nX, 2], { |x| x[1] == ACODFOL[186,1]} ), apdRU0[Nx, 2, nPos, 5], 0)
			nVlrDPC 	:= If(npos := aScan( apdRU0[nX, 2], { |x| x[1] == ACODFOL[190,1]} ), apdRU0[Nx, 2, nPos, 5], 0)
			nVlrFAER 	:= If(npos := aScan( apdRU0[nX, 2], { |x| x[1] == ACODFOL[191,1]} ), apdRU0[Nx, 2, nPos, 5], 0)
			nVlrSENAR 	:= If(npos := aScan( apdRU0[nX, 2], { |x| x[1] == ACODFOL[192,1]} ), apdRU0[Nx, 2, nPos, 5], 0)
			nVlrSECONC 	:= If(npos := aScan( apdRU0[nX, 2], { |x| x[1] == ACODFOL[193,1]} ), apdRU0[Nx, 2, nPos, 5], 0)
			nVlrSECOOP 	:= If(npos := aScan( apdRU0[nX, 2], { |x| x[1] == ACODFOL[782,1]} ), apdRU0[Nx, 2, nPos, 5], 0)
			nVlrTerc 	:= If(npos := aScan( apdRU0[nX, 2], { |x| x[1] == ACODFOL[149,1]} ), apdRU0[Nx, 2, nPos, 5], 0)
			nVlrGILRAT 	:= If(npos := aScan( apdRU0[nX, 2], { |x| x[1] == ACODFOL[150,1]} ), apdRU0[Nx, 2, nPos, 5], 0)

			If lCpoPIS
				nVlrPIS		:= If(npos := aScan( apdRU0[nX, 2], { |x| x[1] == ACODFOL[229,1]} ), apdRU0[Nx, 2, nPos, 5], 0)
			EndIf

			//salário-família
			aEval( apdRU0[nX, 2], { |x| If( RetValSRV(x[1], SRA->RA_FILIAL, "RV_INCCP") == "51", If( RetValSRV(x[1], SRA->RA_FILIAL,"RV_TIPOCOD") $ "1*3", nVlrSalFam += x[5], nVlrSalFam -= x[5]), Nil) } )
			
			//salário-maternidade
			aEval( apdRU0[nX, 2], { |x| If( RetValSRV(x[1], SRA->RA_FILIAL, "RV_INCCP") $ "21*22", If( RetValSRV(x[1], SRA->RA_FILIAL,"RV_TIPOCOD") $ "1*3", nVlrSalMat += x[5], nVlrSalMat -= x[5]), Nil) } )
			aEval( apdRU0[nX, 2], { |x| If( Left(RetValSRV(x[1], SRA->RA_FILIAL,"RV_INCCP"), 1) == "9" .And. RetValSRV(x[1], SRA->RA_FILIAL, "RV_NATUREZ") $ "4050*4051", If( RetValSRV(x[1], SRA->RA_FILIAL,"RV_TIPOCOD") $ "1*3", nVlrSalMat += x[5], nVlrSalMat -= x[5]), Nil) } )

			If cTipoRot $ "1*9"
				//Obtém o valor da base de cálculo de INSS
				aEval( apdRU0[nX, 2], { |x| If( RetValSRV(x[1], SRA->RA_FILIAL,"RV_INCCP") $ "11*15", If( RetValSRV(x[1], SRA->RA_FILIAL,"RV_TIPOCOD") $ "1*3", nVlrTotBc += x[5], nVlrTotBc -= x[5]), Nil) } )

				//Obtém o valor da base de cálculo de INSS Suspenso
				aEval( apdRU0[nX, 2], { |x| If( RetValSRV(x[1], SRA->RA_FILIAL,"RV_INCCP") $ "91*95", If( RetValSRV(x[1], SRA->RA_FILIAL,"RV_TIPOCOD") $ "1*3", nVlrTotBcS += x[5], nVlrTotBcS -= x[5]), Nil) } )
			EndIf

			//Os dados de FAP, RAT, RAT Reajustado e 13º serão tratados posteriormente.
			If cTipoRot == "6"
				//Obtém o valor da base de cálculo de INSS
				aEval( apdRU0[nX, 2], { |x| If( RetValSRV(x[1], SRA->RA_FILIAL,"RV_INCCP") $ "12*16", If( RetValSRV(x[1], SRA->RA_FILIAL,"RV_TIPOCOD") $ "1*3", nVlrTotBc += x[5], nVlrTotBc -= x[5]), Nil) } )

				//Obtém o valor da base de cálculo de INSS Suspenso
				aEval( apdRU0[nX, 2], { |x| If( RetValSRV(x[1], SRA->RA_FILIAL,"RV_INCCP") $ "92*96", If( RetValSRV(x[1], SRA->RA_FILIAL,"RV_TIPOCOD") $ "1*3", nVlrTotBcS += x[5], nVlrTotBcS -= x[5]), Nil) } )
			EndIf

			//Obtém o código Terceiro
			nPos := aScan( aEncDCTF, { |x| x[1] == "TER" })
			If nPos > 0
				cCodTerc := aEncDCTF[npos, 2]
			EndIf

			//Obtém o percentual RAT
			nPos := aScan( aEncDCTF, { |x| x[1] == "RAT" })
			If nPos > 0
				nPercRAT := aEncDCTF[npos, 2] * 100
			EndIf

			//Obtém o percentual RAT Ajustado utilizado no cálculo quando o campo SRA->RA_PERCSAT está vazio, 
			If Empty(SRA->RA_PERCSAT)
				nPos := aScan( aEncDCTF, { |x| x[1] == ACODFOL[150,1]} )
				If nPos > 0
					nPercRatA := aEncDCTF[npos, 2] * 100
				EndIf
			EndIf

			//Caso não tenha valor RAT Ajustado encontra o valor na tabela S037.
			If (!Empty(SRA->RA_PERCSAT) .Or. Empty(nPercRatA)) .And. ValType(ATAB_FOL) == "A" .And. Len(ATAB_FOL) > 0 
				//Procura o resgistro com filial e com o mês de referência
				If (nPosRatA := Ascan(ATAB_FOL,{ |x| x[1] == "S037" .And. x[2] == SRA->RA_FILIAL .And. x[3] == MesAno(dDataRef) })) > 0
					nPercRatA := ATAB_FOL[nPosRatA][7]
				//Procura o registro sem filial mas com o mesmo mês de referência
				ElseIf (nPosRatA := Ascan(ATAB_FOL,{ |x| x[1] == "S037" .And.x[2] == Space(Len(SRA->RA_FILIAL)) .And. x[3] == MesAno(dDataRef) })) > 0
					nPercRatA := ATAB_FOL[nPosRatA][7]
				//Procura o resgistro com filial e sem mês referência
				ElseIf (nPosRatA := Ascan(ATAB_FOL,{ |x| x[1] == "S037" .And. x[2] == SRA->RA_FILIAL})) > 0
					nPercRatA := ATAB_FOL[nPosRatA][7]
				//Procura o resgistro sem filial e sem mês referência
				ElseIf (nPosRatA := Ascan(ATAB_FOL,{ |x| x[1] == "S037" .And. x[2] == Space(Len(SRA->RA_FILIAL))})) > 0
					nPercRatA := ATAB_FOL[nPosRatA][7]
				EndIf
			EndIf

			//Obtém o percentual FAP
			nPercFAP :=  NoRound(nPercRatA / nPercRAT, 4)

			//Obtém o centro de custo
			cCodLot := apdRU0[Nx, 2, 1, 2]

			//Trava o registro na RU0 para edição
			dbSelectArea("RU0")
			RU0->( dbSetOrder(1) ) //Ordena a tabela RU0 pelo Índice 1 RU0_FILIAL+RU0_MAT+RU0_PERIOD+RU0_SEMANA+RU0_PROCES+RU0_LOTACA
			lNovo := RU0->( !dbSeek( SRA->RA_FILIAL + SRA->RA_MAT + cPer + apdRU0[Nx, 2, 1, 3] + SRA->RA_PROCES + cCodLot ))

			If RU0->( RecLock("RU0", lNovo) )
				RU0_FILIAL	:= SRA->RA_FILIAL
				RU0_MAT   	:= SRA->RA_MAT
				RU0_PERIOD	:= cPer
				RU0_CATEFD	:= SRA->RA_CATEFD
				RU0_EAGNOC	:= cAgeNoci
				RU0_CONVEA	:= cContVA
				RU0_TOTBSC	:= nVlrTotBc
				RU0_TOTBCS	:= nVlrTotBcS
				RU0_SEST	:= nVlrSEST
				RU0_SENAT	:= nVlrSENAT
				RU0_SALFAM	:= nVlrSalFam
				RU0_SALMAT	:= nVlrSalMat
				RU0_VLRPAT	:= nVlrPat
				RU0_SALEDU	:= nVlrSalEdu
				RU0_INCRA	:= nVlrINCRA
				RU0_SENAC	:= nVlrSENAC
				RU0_SESC	:= nVlrSESC
				RU0_SEBRAE	:= nVlrSEBRAE
				RU0_LOTACA	:= cCodLot
				RU0_FAP		:= nPercFAP
				RU0_RAT 	:= nPercRAT
				RU0_RAJU	:= nPercRATA
				RU0_FPAS 	:= cFPAS
				RU0_CODTER	:= cCodTerc
				RU0_CPF		:= SRA->RA_CIC
				RU0_CODUNIC	:= SRA->RA_CODUNIC
				RU0_PROCES 	:= SRA->RA_PROCES
				RU0_SEMANA	:= apdRU0[Nx, 2, 1, 3]
				RU0_SENAI	:= nVlrSENAI
				RU0_SESI	:= nVlrSESI
				RU0_DPC		:= nVlrDPC
				RU0_FAER	:= nVlrFAER
				RU0_SENAR	:= nVlrSENAR
				RU0_SECONC	:= nVlrSECONC
				RU0_SESCOO	:= nVlrSECOOP
				RU0_INSSTE	:= nVlrTerc
				RU0_GILRAT	:= nVlrGILRAT
				If lCpoPIS
					RU0_PIS		:= nVlrPIS
				EndIf

				//Libera o registro da RU0
				RU0->( MsUnlock() )
			EndIf
		Next Nx
	EndIf

Return Nil

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o	 ³ GravaFol ³ Autor ³ Mauro 			    ³ Data ³ 07.03.95 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Grava as Verbas da Matriz Calculadas no Adiantamento  	  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ GravaAdt(X)												  ³±±
±±³ 		 ³														  	  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ X =	Matriz Multi contendo						    	  ³±±
±±³	 		 ³ Codigo da Verba , C.Custo, cSemana, Horas , Valor , Tipo1,;³±±
±±³ 		 ³ Tipo2 , Parcela										  	  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso 	 ³ Generico 											  	  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Function GravaFol(aX)

Local lItemClVl   := GetMvRH( "MV_ITMCLVL", .F., "2" ) $ "1*3"

If SRA->RA_TPCONTR == "3" .And. !aConvocacao[6]
	If SRA->RA_TIPOPGT != "S" .Or. aX[22] == aConvocacao[1]
		aAdd(aPdConvoc,aClone(ax))
	EndIf
EndIf

If cTipoRot == "O"
	aAdd( aPdBenOp, aClone(aX) )
EndIf

If aX[3] = cSemana .Or. Empty( aX[3] )
    GravaSrc( SRA->RA_FILIAL, SRA->RA_MAT, aX[1], If(!Empty(aX[10]), aX[10], dData_Pgto), aX[2],;
    If(Empty(aX[3]), cSemana, aX[3] ), aX[6], aX[7], aX[4], aX[5], aX[8], aX[9], Nil,aX[11], aX[12], Iif(lItemClVl, aX[13], Nil), Iif(lItemClVl, aX[14], Nil), If(Len(aX)>= 17, aX[17], ''), aX[20], aX[21], aX[15], aX[18], aX[22], Nil, aX[23], aX[24], Iif(Len(aX) >= 26, aX[26], ""), Iif(Len(aX) >= 27, aX[27], ""), Iif(Len(aX) >= 28, aX[28], "") )
EndIf
Return( NIL )

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ GravaAdt ³ Autor ³ Mauro                 ³ Data ³ 07.03.95 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Grava as Verbas da Matriz Calculadas no Adiantamento       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ GravaAdt(aX)                                               ³±±
±±³          ³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ aX =  Matriz Multi contendo                                ³±±
±±³          ³ Codigo da Verba , C.Custo, Semana, Horas , Valor , Tipo1 ,;³±±
±±³          ³ Tipo2 , Parcela                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Static Function GravaAdt(aX)
Local lItemClVl   := GetMvRH( "MV_ITMCLVL", .F., "2" ) $ "1*3"
Local dDtPgt

If aX[7] == 'I' .And. Empty(ax[10]) .And. ax[1]$ aCodFol[007,1]+ aCodFol[012,1]+ aCodFol[010,1]
	dDtPgt := dData_Pgto
Else
	dDtPgt := If (Empty(Ax[10]), dData_Pgto, Ax[10])
Endif

If Empty( aX[3] ) .Or. aX[3] = cSemana
	GravaSrc(SRA->RA_FILIAL,SRA->RA_MAT,aX[1], dDtPgt ,aX[2],aX[3],aX[6],aX[7],aX[4],aX[5],aX[8],ax[9],,aX[11],,Iif(lItemClVl, aX[13], Nil), Iif(lItemClVl, aX[14], Nil),,aX[20],aX[21],aX[15],aX[18],Nil,Nil,aX[23],aX[24], Nil, Nil, Iif(Len(aX) >= 28, aX[28], ""))
EndIf

Return

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFuncao    ³fSomaAdic ºAutor  ³Ricardo Duarte Costaº Data ³  02/05/05   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDescricao ³Funcao devolver o valor dos adicionais a serem considerados º±±
±±º          ³para o calculo da 1a parcela do 13o salario nas ferias.     º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³ 															  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ SIGAGPE                                                    º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Function fSomaAdic()

Local nValRet	:= 0

If nAdtServ   > 0
	nValRet += nAdtServ
EndIf

If nPeric  > 0
	nValRet += nPeric
EndIf

If nInsalub > 0
	nValRet += nInsalub
EndIf

If nAdcConf > 0
	nValRet += nAdcConf
EndIf

If nAdcTrf > 0
	nValRet += nAdcTrf
EndIf

Return(nValRet)

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ fSalInc	  ³ autor ³ Mauro               ³ Data ³ 24/08/98 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Achar Salario Incorporado Usando Roteiro da Folha          ³±±
±±³ÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ³±±
±±³Parametro ³ fSalInc(Salario,SalMes,SalHora,SalDia,Comiss)              ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function fXSalInc(nXSal,nXSalM,nXSalH,nXSalD,lXRelGp,nXComiss,dDtXTarDe,dDtXTarAte)

Local cSvRotExec
Local nExecRot := 0
Local cRotCalc := ""

Static cPd0165
Static cPd0166
Static cPd0347

If cPaisLoc <> "MEX"

	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Carregar os Mnemonicos 	                                   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	SetMnemonicos(NIL,NIL,.T.)

	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Carregando variaveis para busca das tarefas			       ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	If dDtXTarDe # Nil .And. dDtTarXAte # Nil
		dDataDe  := dDtXTarDe
		dDataAte := dDtXTarAte
	EndIf

	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Execucao da Formula de Salario Incorporado		    	   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	cRotCalc := fGetCalcRot("1") //"FOL"
	nExecRot := ExecForm( SRA->RA_FILIAL, "SALINC", cRotCalc )

	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Atualizacao das Variaveis apos o Retorno da Execucao da for- ³
	³ mula. As variaveis sao tratadas como mnemonicos.             ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	cSvRotExec := SetRotExec( cRotCalc )
	If cPd0165 == Nil .Or. cPd0166 == Nil .Or. cPd0347 == Nil
		cPd0165 := fGetCodFol("0165")
		cPd0166 := fGetCodFol("0166")
		cPd0347 := fGetCodFol("0347")
	EndIf
	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Estava gerando erro na geracao do CAGED, checar e ajustar.   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	nXComiss := 0 // fbuscaPD( If(Empty(cPd0165),"",cPd0165)+","+If(Empty(cPd0166),"",cPd0166)+","+If(Empty(cPd0347),"",cPd0347))
	SetRotExec( cSvRotExec )
	nXSal    := Salario
	nXSalM   := SalMes
	nXSalH   := SalHora
	nXSalD   := SalDia

ElseIf cPaisLoc == "MEX"

	nXSal    := SRA->RA_SALARIO
	nXSalM   := SRA->RA_SALMES
	nXSalH   := SRA->RA_SALHOR
	nXSalD   := SRA->RA_SALDIA

EndIf

If lXRelGp
	Set Device to Print
Endif

Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³fRetTab   ºAutor  ³Tiago Malta         º Data ³  11/11/08   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Pociciona na condição correta e realiza o tratamento do    º±±
±±º          ³  filtro.                                                   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±³Parametro ³fRetTab(Array,Tabela,P.Sindic,P.Express,dDataRef,cSindica)  ³±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function fRetTab( aTab_Fol, cCodTab, npoSind, npoExpre, dDataRef, cSindica, lTabFull, cFilPar, lRecarga )

Local cFilTab    := ""
Local aNewTabFol := {}
Local lAchou     := .F.
Local nPosTab    := 0
Local nX         := 0

DEFAULT cFilPar	 	:= SRA->RA_FILIAL
DEFAULT lTabFull 	:= .F.
DEFAULT lRecarga	:= .F.
DEFAULT nTamSind    := TamSX3("RA_SINDICA")[1]

cFilTab  :=	xFilial("RCC", cFilPar)

//--Carrega Tabela
fCarrTab( @aTab_Fol, cCodTab, dDataRef, lRecarga, , lRecarga, cFilPar )

IF npoSind <> NIL .AND. !EMPTY(npoSind)
	npoSind	:= npoSind+1
ENDIF

IF npoExpre <> NIL .AND. !EMPTY(npoExpre)
	npoExpre:= npoExpre+1
ENDIF

//--Verifica se Existe a Tabela Cadastrada
If ( nPosTab :=    Ascan(aTab_Fol,{ |x| x[1] == cCodTab .And. x[2] == cFilTab 				.And. x[3] == MesAno(dDataRef) .And. IIF(npoSind<>NIL, x[npoSind]==(cSindica), .T.) })) > 0
	lAchou := .T.
Elseif( nPosTab := Ascan(aTab_Fol,{ |x| x[1] == cCodTab .And. x[2] == cFilTab 				.And. x[3] == MesAno(dDataRef) .And. IIF(npoSind<>NIL, x[npoSind]==Space(nTamSind)  , .T.) })) > 0
	lAchou := .T.
Elseif( nPosTab := Ascan(aTab_Fol,{ |x| x[1] == cCodTab .And. x[2] == Space(FwGetTamFilial) .And. x[3] == MesAno(dDataRef) .And. IIF(npoSind<>NIL, x[npoSind]==(cSindica), .T.) })) > 0
	lAchou := .T.
Elseif( nPosTab := Ascan(aTab_Fol,{ |x| x[1] == cCodTab .And. x[2] == Space(FwGetTamFilial) .And. x[3] == MesAno(dDataRef) .And. IIF(npoSind<>NIL, x[npoSind]==Space(nTamSind)  , .T.) })) > 0
	lAchou := .T.
Elseif( nPosTab := Ascan(aTab_Fol,{ |x| x[1] == cCodTab .And. x[2] == cFilTab 				.And. x[3] == Space(6)         .And. IIF(npoSind<>NIL, x[npoSind]==(cSindica), .T.) })) > 0 .AND. IIF( npoExpre<>NIL .AND. nPosTab>0 .AND. !EMPTY(aTab_Fol[nPosTab][npoExpre]), &(aTab_Fol[nPosTab][npoExpre]), .T.)
	lAchou := .T.
Elseif( nPosTab := Ascan(aTab_Fol,{ |x| x[1] == cCodTab .And. x[2] == cFilTab 				.And. x[3] == Space(6)         .And. IIF(npoSind<>NIL, x[npoSind]==Space(nTamSind)  , .T.) })) > 0 .AND. IIF( npoExpre<>NIL .AND. nPosTab>0 .AND. !EMPTY(aTab_Fol[nPosTab][npoExpre]), &(aTab_Fol[nPosTab][npoExpre]), .T.)
	lAchou := .T.
Elseif( nPosTab := Ascan(aTab_Fol,{ |x| x[1] == cCodTab .And. x[2] == Space(FwGetTamFilial) .And. x[3] == Space(6)         .And. IIF(npoSind<>NIL, x[npoSind]==(cSindica), .T.) })) > 0 .AND. IIF( npoExpre<>NIL .AND. nPosTab>0 .AND. !EMPTY(aTab_Fol[nPosTab][npoExpre]), &(aTab_Fol[nPosTab][npoExpre]), .T.)
	lAchou := .T.
Elseif( nPosTab := Ascan(aTab_Fol,{ |x| x[1] == cCodTab .And. x[2] == Space(FwGetTamFilial) .And. x[3] == Space(6)         .And. IIF(npoSind<>NIL, x[npoSind]==Space(nTamSind)  , .T.) })) > 0 .AND. IIF( npoExpre<>NIL .AND. nPosTab>0 .AND. !EMPTY(aTab_Fol[nPosTab][npoExpre]), &(aTab_Fol[nPosTab][npoExpre]), .T.)
	lAchou := .T.
Endif

//-Tratamento pra Gestao Corporativa
//.Combinacoes possiveis
//.Empr / UNeg / Fil
//.  E      E     E  (ja testado acima)
//.  E      E     C
//.  E      C     E
//.  E      C     C
//.  C      C     C  (ja testado acima)
//.  C      C     E
//.  C      E     C
//.  C      E     E

If !lAchou
	If ( nPosTab :=    Ascan(aTab_Fol,{ |x| x[1] == cCodTab .And. x[2] == FwCompany()+FwUnitBusiness()+FwFilial()						.And. x[3] == MesAno(dDataRef) .And. IIF(npoSind<>NIL, x[npoSind]==(cSindica), .T.) })) > 0
		lAchou := .T.
	ElseIf ( nPosTab :=    Ascan(aTab_Fol,{ |x| x[1] == cCodTab .And. x[2] == FwCompany()+FwUnitBusiness()+Space(Len(FwFilial()))			.And. x[3] == MesAno(dDataRef) .And. IIF(npoSind<>NIL, x[npoSind]==(cSindica), .T.) })) > 0
		lAchou := .T.
	ElseIf( nPosTab := Ascan(aTab_Fol,{ |x| x[1] == cCodTab .And. x[2] == FwCompany()+Space(Len(FwUnitBusiness()))+FwFilial()			.And. x[3] == MesAno(dDataRef) .And. IIF(npoSind<>NIL, x[npoSind]==(cSindica), .T.) })) > 0
		lAchou := .T.
	ElseIf( nPosTab := Ascan(aTab_Fol,{ |x| x[1] == cCodTab .And. x[2] == FwCompany()+Space(Len(FwUnitBusiness()))+Space(Len(FwFilial())).And. x[3] == MesAno(dDataRef) .And. IIF(npoSind<>NIL, x[npoSind]==(cSindica), .T.) })) > 0
		lAchou := .T.
	ElseIf( nPosTab := Ascan(aTab_Fol,{ |x| x[1] == cCodTab .And. x[2] == Space(Len(FwCompany()))+Space(Len(FwUnitBusiness()))+FwFilial().And. x[3] == MesAno(dDataRef) .And. IIF(npoSind<>NIL, x[npoSind]==(cSindica), .T.) })) > 0
		lAchou := .T.
	ElseIf( nPosTab := Ascan(aTab_Fol,{ |x| x[1] == cCodTab .And. x[2] == Space(Len(FwCompany()))+FwUnitBusiness()+Space(Len(FwFilial())).And. x[3] == MesAno(dDataRef) .And. IIF(npoSind<>NIL, x[npoSind]==(cSindica), .T.) })) > 0
		lAchou := .T.
	ElseIf( nPosTab := Ascan(aTab_Fol,{ |x| x[1] == cCodTab .And. x[2] == Space(Len(FwCompany()))+FwUnitBusiness()+FwFilial()			.And. x[3] == MesAno(dDataRef) .And. IIF(npoSind<>NIL, x[npoSind]==(cSindica), .T.) })) > 0
		lAchou := .T.

	ElseIf( nPosTab := Ascan(aTab_Fol,{ |x| x[1] == cCodTab .And. x[2] == FwCompany()+FwUnitBusiness()+FwFilial()						.And. x[3] == MesAno(dDataRef) .And. IIF(npoSind<>NIL, x[npoSind]==Space(nTamSind)  , .T.) })) > 0
		lAchou := .T.
	ElseIf( nPosTab := Ascan(aTab_Fol,{ |x| x[1] == cCodTab .And. x[2] == FwCompany()+FwUnitBusiness()+Space(Len(FwFilial()))			.And. x[3] == MesAno(dDataRef) .And. IIF(npoSind<>NIL, x[npoSind]==Space(nTamSind)  , .T.) })) > 0
		lAchou := .T.
	ElseIf( nPosTab := Ascan(aTab_Fol,{ |x| x[1] == cCodTab .And. x[2] == FwCompany()+Space(Len(FwUnitBusiness()))+FwFilial()			.And. x[3] == MesAno(dDataRef) .And. IIF(npoSind<>NIL, x[npoSind]==Space(nTamSind)  , .T.) })) > 0
		lAchou := .T.
	ElseIf( nPosTab := Ascan(aTab_Fol,{ |x| x[1] == cCodTab .And. x[2] == FwCompany()+Space(Len(FwUnitBusiness()))+Space(Len(FwFilial())).And. x[3] == MesAno(dDataRef) .And. IIF(npoSind<>NIL, x[npoSind]==Space(nTamSind)  , .T.) })) > 0
		lAchou := .T.
	ElseIf( nPosTab := Ascan(aTab_Fol,{ |x| x[1] == cCodTab .And. x[2] == Space(Len(FwCompany()))+Space(Len(FwUnitBusiness()))+FwFilial().And. x[3] == MesAno(dDataRef) .And. IIF(npoSind<>NIL, x[npoSind]==Space(nTamSind)  , .T.) })) > 0
		lAchou := .T.
	ElseIf( nPosTab := Ascan(aTab_Fol,{ |x| x[1] == cCodTab .And. x[2] == Space(Len(FwCompany()))+FwUnitBusiness()+Space(Len(FwFilial())).And. x[3] == MesAno(dDataRef) .And. IIF(npoSind<>NIL, x[npoSind]==Space(nTamSind)  , .T.) })) > 0
		lAchou := .T.
	ElseIf( nPosTab := Ascan(aTab_Fol,{ |x| x[1] == cCodTab .And. x[2] == Space(Len(FwCompany()))+FwUnitBusiness()+FwFilial()			.And. x[3] == MesAno(dDataRef) .And. IIF(npoSind<>NIL, x[npoSind]==Space(nTamSind)  , .T.) })) > 0
		lAchou := .T.
	//--
	Elseif( nPosTab := Ascan(aTab_Fol,{ |x| x[1] == cCodTab .And. x[2] == FwCompany()+FwUnitBusiness()+FwFilial()						.And. x[3] == Space(6) .And. IIF(npoSind<>NIL, x[npoSind]==(cSindica), .T.) })) > 0 .AND. IIF( npoExpre<>NIL .AND. nPosTab>0 .AND. !EMPTY(aTab_Fol[nPosTab][npoExpre]), &(aTab_Fol[nPosTab][npoExpre]), .T.)
		lAchou := .T.
	Elseif( nPosTab := Ascan(aTab_Fol,{ |x| x[1] == cCodTab .And. x[2] == FwCompany()+FwUnitBusiness()+Space(Len(FwFilial()))			.And. x[3] == Space(6) .And. IIF(npoSind<>NIL, x[npoSind]==(cSindica), .T.) })) > 0 .AND. IIF( npoExpre<>NIL .AND. nPosTab>0 .AND. !EMPTY(aTab_Fol[nPosTab][npoExpre]), &(aTab_Fol[nPosTab][npoExpre]), .T.)
		lAchou := .T.
	Elseif( nPosTab := Ascan(aTab_Fol,{ |x| x[1] == cCodTab .And. x[2] == FwCompany()+Space(Len(FwUnitBusiness()))+FwFilial()			.And. x[3] == Space(6) .And. IIF(npoSind<>NIL, x[npoSind]==(cSindica), .T.) })) > 0 .AND. IIF( npoExpre<>NIL .AND. nPosTab>0 .AND. !EMPTY(aTab_Fol[nPosTab][npoExpre]), &(aTab_Fol[nPosTab][npoExpre]), .T.)
		lAchou := .T.
	Elseif( nPosTab := Ascan(aTab_Fol,{ |x| x[1] == cCodTab .And. x[2] == FwCompany()+Space(Len(FwUnitBusiness()))+Space(Len(FwFilial())) .And. x[3] == Space(6) .And. IIF(npoSind<>NIL, x[npoSind]==(cSindica), .T.) })) > 0 .AND. IIF( npoExpre<>NIL .AND. nPosTab>0 .AND. !EMPTY(aTab_Fol[nPosTab][npoExpre]), &(aTab_Fol[nPosTab][npoExpre]), .T.)
		lAchou := .T.
	Elseif( nPosTab := Ascan(aTab_Fol,{ |x| x[1] == cCodTab .And. x[2] == Space(Len(FwCompany()))+Space(Len(FwUnitBusiness()))+FwFilial() .And. x[3] == Space(6) .And. IIF(npoSind<>NIL, x[npoSind]==(cSindica), .T.) })) > 0 .AND. IIF( npoExpre<>NIL .AND. nPosTab>0 .AND. !EMPTY(aTab_Fol[nPosTab][npoExpre]), &(aTab_Fol[nPosTab][npoExpre]), .T.)
		lAchou := .T.
	Elseif( nPosTab := Ascan(aTab_Fol,{ |x| x[1] == cCodTab .And. x[2] == Space(Len(FwCompany()))+FwUnitBusiness()+Space(Len(FwFilial())) .And. x[3] == Space(6) .And. IIF(npoSind<>NIL, x[npoSind]==(cSindica), .T.) })) > 0 .AND. IIF( npoExpre<>NIL .AND. nPosTab>0 .AND. !EMPTY(aTab_Fol[nPosTab][npoExpre]), &(aTab_Fol[nPosTab][npoExpre]), .T.)
		lAchou := .T.
	Elseif( nPosTab := Ascan(aTab_Fol,{ |x| x[1] == cCodTab .And. x[2] == Space(Len(FwCompany()))+FwUnitBusiness()+FwFilial()			.And. x[3] == Space(6) .And. IIF(npoSind<>NIL, x[npoSind]==(cSindica), .T.) })) > 0 .AND. IIF( npoExpre<>NIL .AND. nPosTab>0 .AND. !EMPTY(aTab_Fol[nPosTab][npoExpre]), &(aTab_Fol[nPosTab][npoExpre]), .T.)
		lAchou := .T.

	Elseif( nPosTab := Ascan(aTab_Fol,{ |x| x[1] == cCodTab .And. x[2] == FwCompany()+FwUnitBusiness()+FwFilial()						.And. x[3] == Space(6) .And. IIF(npoSind<>NIL, x[npoSind]==Space(nTamSind)  , .T.) })) > 0 .AND. IIF( npoExpre<>NIL .AND. nPosTab>0 .AND. !EMPTY(aTab_Fol[nPosTab][npoExpre]), &(aTab_Fol[nPosTab][npoExpre]), .T.)
		lAchou := .T.
	Elseif( nPosTab := Ascan(aTab_Fol,{ |x| x[1] == cCodTab .And. x[2] == FwCompany()+FwUnitBusiness()+Space(Len(FwFilial()))			.And. x[3] == Space(6) .And. IIF(npoSind<>NIL, x[npoSind]==Space(nTamSind)  , .T.) })) > 0 .AND. IIF( npoExpre<>NIL .AND. nPosTab>0 .AND. !EMPTY(aTab_Fol[nPosTab][npoExpre]), &(aTab_Fol[nPosTab][npoExpre]), .T.)
		lAchou := .T.
	Elseif( nPosTab := Ascan(aTab_Fol,{ |x| x[1] == cCodTab .And. x[2] == FwCompany()+Space(Len(FwUnitBusiness()))+FwFilial()			.And. x[3] == Space(6) .And. IIF(npoSind<>NIL, x[npoSind]==Space(nTamSind)  , .T.) })) > 0 .AND. IIF( npoExpre<>NIL .AND. nPosTab>0 .AND. !EMPTY(aTab_Fol[nPosTab][npoExpre]), &(aTab_Fol[nPosTab][npoExpre]), .T.)
		lAchou := .T.
	Elseif( nPosTab := Ascan(aTab_Fol,{ |x| x[1] == cCodTab .And. x[2] == FwCompany()+Space(Len(FwUnitBusiness()))+Space(Len(FwFilial())) .And. x[3] == Space(6) .And. IIF(npoSind<>NIL, x[npoSind]==Space(nTamSind)  , .T.) })) > 0 .AND. IIF( npoExpre<>NIL .AND. nPosTab>0 .AND. !EMPTY(aTab_Fol[nPosTab][npoExpre]), &(aTab_Fol[nPosTab][npoExpre]), .T.)
		lAchou := .T.
	Elseif( nPosTab := Ascan(aTab_Fol,{ |x| x[1] == cCodTab .And. x[2] == Space(Len(FwCompany()))+Space(Len(FwUnitBusiness()))+FwFilial() .And. x[3] == Space(6) .And. IIF(npoSind<>NIL, x[npoSind]==Space(nTamSind)  , .T.) })) > 0 .AND. IIF( npoExpre<>NIL .AND. nPosTab>0 .AND. !EMPTY(aTab_Fol[nPosTab][npoExpre]), &(aTab_Fol[nPosTab][npoExpre]), .T.)
		lAchou := .T.
	Elseif( nPosTab := Ascan(aTab_Fol,{ |x| x[1] == cCodTab .And. x[2] == Space(Len(FwCompany()))+FwUnitBusiness()+Space(Len(FwFilial())) .And. x[3] == Space(6) .And. IIF(npoSind<>NIL, x[npoSind]==Space(nTamSind)  , .T.) })) > 0 .AND. IIF( npoExpre<>NIL .AND. nPosTab>0 .AND. !EMPTY(aTab_Fol[nPosTab][npoExpre]), &(aTab_Fol[nPosTab][npoExpre]), .T.)
		lAchou := .T.
	Elseif( nPosTab := Ascan(aTab_Fol,{ |x| x[1] == cCodTab .And. x[2] == Space(Len(FwCompany()))+FwUnitBusiness()+FwFilial()			.And. x[3] == Space(6) .And. IIF(npoSind<>NIL, x[npoSind]==Space(nTamSind)  , .T.) })) > 0 .AND. IIF( npoExpre<>NIL .AND. nPosTab>0 .AND. !EMPTY(aTab_Fol[nPosTab][npoExpre]), &(aTab_Fol[nPosTab][npoExpre]), .T.)
		lAchou := .T.
	Endif
Endif

If lAchou
	If !lTabFull
		aTab_Fol := Aclone(aTab_Fol[nPosTab])
	Else
		//# Carrega a Tabela Toda
		For nX := nPosTab To Len( aTab_Fol )
			If aTab_Fol[nX, 1] == cCodTab
				aAdd( aNewTabFol, aClone( aTab_Fol[nX] ) )
			EndIf
		Next nX
		aTab_Fol := Aclone(aNewTabFol)
	EndIf
ELSE
	aTab_Fol := {}
ENDIF

Return

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÂÄÄÄÄÄÄÄÄÄ¿±±
±±³Função	 ³fCarPD    ³ Autor ³ MOHANAD ODEH ³Data³22/06/11 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÁÄÄÄÄÄÄÄÄÄ´±±
±±³Descrição ³ Carrega as variaveis p/cadastro de Verbas      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³ fCarPD()                                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ Vide Paramentros Formais                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso		 ³ Generico 									  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Function fCarPD()
Local aArea		:= GetArea()
Local aAreaSRV	:= SRV->(GetArea())
Local aAux		:= {}
Local aSRVHeader:= {}
Local bFunc		:= {|| NIL}
Local cCampo	:= ""
Local cFilSRV	:= xFilial("SRV")
Local cVerbas	:= ""
Local cFunction	:= ("GPPD" + cPaisLoc)
Local nFieldPos
Local nPosField
Local nPosVerba
Local nAux
Local nAuxs
Local nX
Local uCnt
Local cFiltro := 'SRV->RV_FILIAL == "' + cFilSRV + '"'
Local bFiltro := { || &(cFiltro) }

// Verifica a Existencia da Funcao do Pais Corrente
If FindFunction(cFunction)
	bFunc := __ExecMacro("{ ||  " + cFunction + "( @aAux , @aSRVHeader ) }")
	Eval(bFunc)
	DbSelectarea("SRV")
	DbSetOrder(1)
	SRV->(DbSetfilter( bFiltro, cFiltro ))
	SRV->(DbGoTop())

	//Verifica se Tabela de Verbas esta Vazia, para a filial em uso -- Se estiver realizar a carga
    If SRV->(Eof())
		nPosVerba := GdFieldPos("RV_COD" , aSRVHeader)
		nAuxs := Len(aAux)
		DbSelectarea("SRV")
		DbSetOrder(1)
		For nAux := 1 To nAuxs
			cVerbas := Padr(Upper(AllTrim(aAux[ nAux, nPosVerba ])),TamSX3("RV_COD")[1])
			If SRV->(dbSeek(cFilSRV + cVerbas))
				 RecLock("SRV",.F.,.T.)
			Else
				 RecLock("SRV",.T.,.T.)
			EndIf
			For nX := 1 To Len(aSRVHeader)
			   	cCampo := Upper(aSRVHeader[nX, 2])
				nFieldPos := SRV->(FieldPos(cCampo))
				If (nFieldPos > 0)
					If (aSRVHeader[nX, 2] == "RV_FILIAL")
						uCnt := cFilSRV
					Else
				    	nPosField := GdFieldPos(cCampo , aSRVHeader)
				    	If (nPosField == 0)
				    		Loop
				    	EndIF
				    	uCnt := aAux[nAux , nPosField]
					Endif
					SRV->(FieldPut(nFieldPos , uCnt))
				EndIF
			Next nX
			SRV->(MsUnlock())

		Next nAux
	EndIf
EndIf

RestArea(aAreaSRV)
RestArea(aArea)

Return(NIL)


/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³GpIniCrg  ºAutor  ³Leandro Drumond     º Data ³  12/09/12   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Controle de atualizacoes das informacoes das tabelas padraoº±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametro ³                                                            º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function GpIniCrg()
Local aArea
Local cFunc	:= ( "GpCrg" + cPaisLoc + "()" )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Verificar a existencia da formula padrao do pais corrente     ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
If FindFunction( cFunc )
	aArea	:= GetArea()
	__ExecMacro( cFunc )
	RestArea( aArea )
EndIf

Return Nil

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³fGravaCrg ºAutor  ³Leandro Drumond     º Data ³  12/09/12   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Grava as alteracoes nas tabelas padrao.                    º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametro ³                                                            º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function fGravaCrg(aRCCHeader, aRCCItens)
Local cCampo
Local cFilRCc 		:= xFilial( "RCC" )
Local nPosCod 		:= GdFieldPos( 'RCC_CODIGO'	, aRCCHeader )
Local nPosFil 		:= GdFieldPos( 'RCC_FIL' 	, aRCCHeader )
Local nPosChv 		:= GdFieldPos( 'RCC_CHAVE' 	, aRCCHeader )
Local nPosSeq 		:= GdFieldPos( 'RCC_SEQUEN'	, aRCCHeader )
Local nTamFil		:= TamSX3("RCC_FIL")[1]
Local nTamChv		:= TamSX3("RCC_CHAVE")[1]

Local nFieldPos
Local nX
Local nY

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Excluir os Itens da Tabela para Incluir posteriormente 	   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
DbSelectArea( "RCC" )
DbSetOrder( 1 )  //RCC_FILIAL + RCC_CODIGO + RCC_FIL + RCC_CHAVE  + RCC_SEQUEN

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Incluir os Itens da Definicao Tabelas                  	   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
For nX := 1 To Len( aRCCItens )

	If !(DbSeek(cFilRCC + aRCCItens[nX,nPosCod] + Padr(aRCCItens[nX,nPosFil],nTamFil) + Padr(aRCCItens[nX,nPosChv],nTamChv) + aRCCItens[nX,nPosSeq]))

		If RCC->( RecLock( "RCC" , .T. ) )

			// gravacao dos campos //
			For nY := 1 To Len(aRCCHeader)
				cCampo 		:= Upper(aRCCHeader[nY, 2])
				nFieldPos	:= RCC->( FieldPos( cCampo ) )
				IF ( nFieldPos > 0 )
					If ( cCampo != "RCC_FILIAL" )
				    	RCC->( FieldPut( nFieldPos , aRCCItens[nX, GdFieldPos ( cCampo , aRCCHeader )] ) )
				    Else
			    		RCC->( FieldPut( nFieldPos , cFilRCC ) )
				    EndIf
				EndIF
			Next nY
			RCC->( MsUnlock() )
		EndIF
	EndIf
Next nX

Return Nil

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFuncao    ³fPropGTar  ºAutor  ³Jonatas A. T. Alves º Data ³  11/04/08   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDescricao ³Funcao para proporcionalizar a garantia de tarefas           º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³ 															   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ SIGAGPE                                                     º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Function fPropGTar(cTipCalc,nGTarPro)

Local nQtdDias	:= nDiasP //RFC->RFC_DCALCM
Local nVlrPiso  := Max( Val_SalMin, RCE->RCE_PISO )

nGTarPro	:= nVlrPiso

If P_LGTARPRO
	Do Case
		Case cTipCalc == '2' // Folha / Rescisao
			nGTarPro := nGTarPro / nQtdDias * ( DiasTrab + DiasDsr + nDiasAc + nDiasAd + nDiasLRem )
		Case cTipCalc == '3' //13o. salario
			nGTarPro := If( lMedDir, nGTarPro, ( nGTarPro / 12 * nAvos ) )
	EndCase
EndIf

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ No caso de MV_DIASMES = 'S', podera ocorrer de a garantia de ³
³ tarefas ser maior que o salario-minimo.					   ³
³ Aqui limitamos o valor da garantia de tarefas ao valor do    ³
³ salario-minimo.                                              ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
nGTarPro := Min( nVlrPiso, nGTarPro )

Return

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFuncao    ³fPropGComisºAutor  ³Jonatas A. T. Alves º Data ³  26/07/07   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDescricao ³Funcao para proporcionalizar a garantia de comissao          º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³ 															   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ SIGAGPE                                                     º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Function fPropGComis(cTipCalc,nGComisPro)

nGComisPro	:= RCE->RCE_GCOMIS

If P_PROPCOMS
	If cTipCalc == '2' // Folha
		nGComisPro := nGComisPro / nDiasC * (DiasTrab + nDiasAc + nDiasAd + nDiasLRem)
	ElseIf cTipCalc == '1' // Adiantamento
		nGComisPro := nGComisPro / nDiasC * DiasTb
	ElseIf cTipCalc == '3' //13o. salario
		nGComisPro := nGComisPro / 12 * nAvos
	EndIf
EndIf

Return

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFuncao    ³GetSrySeqFilºAutor ³Leandro Drumond     º Data ³  07/12/12   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDescricao ³Funcao para gerar codigo unico para filia na SRY             º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³ 															   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ SIGAGPE                                                     º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Function GetSrySeqFil(cFil,lProximo)
Local aArea	:= GetArea()
Local cRet 	:= ""

DEFAULT lProximo := .T.

DbSelectArea('SRY')
If DbSeek(cFil)
	cRet := SRY->RY_SEQFIL
Else
	If lProximo
		cRet := "00"
		DbGoTop()
		While SRY->(!Eof())
			If SRY->RY_SEQFIL > cRet
				cRet := SRY->RY_SEQFIL
			EndIf
			SRY->(DbSkip())
		EndDo
		cRet := Soma1(cRet)
	EndIf
EndIf

RestArea(aArea)

Return cRet

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFuncao    ³fComp13FolºAutor ³Raquel Hager		     º Data ³  16/12/15   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDescricao ³Funcao que verifica se o periodo de 13 esta fechado ou nao   º±±
±±º			  ³ao executar Folha e mnemonico P_CCOMP13 configurado com S.   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³ 															   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ SIGAGPE                                                     º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Function fComp13Fol()
Local lRet		:= .T.
Local cRot132 	:= ""

If cPaisLoc == "BRA" .And. cSitFolh # "D" .And. cTipoRot == "1" .and. P_CCOMP13 == 'S' .And. !( Type("lSalInco") <> "U" .And. lSalInco )
 	// Paga Complemento 13 Salario na Folha de Pagamento
	cRot132 	:= fGetCalcRot('6')
	dbSelectArea("RCH")
	RCH->(dbSetOrder(RetOrdem("RCH", "RCH_FILIAL+RCH_PROCES+RCH_ROTEIR+RCH_PER+RCH_NUMPAG")))
	If RCH->(dbSeek(xFilial("RCH",SRA->RA_FILIAL)+CPROCESSO+cRot132+CPERIODO+CSEMANA))
		If Empty(RCH->RCH_DTFECH)
			// Se o roteiro de 13 do Periodo nao estiver fechado, nao calcula complementar
			lRet 	:= .F.
		Else
			lRet	:= .T.
		EndIf
	Else
		lRet := .T.
	EndIf
EndIf

Return (lRet)

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFuncao    ³fRetRCB  ºAutor ³Paulo Inzonha	      º Data ³  26/01/18   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDescricao ³Funcao pesquisa e retorna array com os valores da RCB        º±±
±±º			  ³a partir dos valores RCB_CAMPOS ou RCB_ORDEM informado      º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³ cFilRCB - Filial 										   º±±
±±º			 ³ cTab    - Codigo da Tabela								   º±±
±±º			 ³ Ordem   - valor do RCB_ORDEM a ser pesquisado 			   º±±
±±º			 ³ cCampos - valor do RCB_CAMPOS a ser pesquisado    		   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ SIGAGPE                                                     º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Function fRetRCB(cFilRCB,cTab,cOrdem, cCampos)
Local aRCB		:= {}
Local cAliasRCB	:= GetNextAlias()
Default cOrdem 	:= ""
Default cCampos := ""

BeginSql alias cAliasRCB
	SELECT RCB_ORDEM, RCB_CAMPOS, RCB_DESCPO, RCB_TIPO, RCB_TAMAN, RCB_DECIMA, RCB_PICTUR, RCB_VALID, RCB_PADRAO, RCB_VERSAO, RCB_PESQ, RCB_SHOWMA, RCB_MODULO, RCB_PROCES
	FROM %table:RCB% RCB
	WHERE RCB_FILIAL = %exp:xFilial("RCB",cFilRCB)%	AND RCB_CODIGO = %exp:cTab% AND
	( RCB_ORDEM = %exp:cOrdem% OR RCB_CAMPOS = %exp:cCampos% ) AND RCB.%notDel%
EndSql

While (cAliasRCB)->( !Eof() )
	aAdd(aRCB,{(cAliasRCB)->RCB_ORDEM, (cAliasRCB)->RCB_CAMPOS, (cAliasRCB)->RCB_DESCPO, (cAliasRCB)->RCB_TIPO, (cAliasRCB)->RCB_TAMAN,;
	    (cAliasRCB)->RCB_DECIMA, (cAliasRCB)->RCB_PICTUR, (cAliasRCB)->RCB_VALID, (cAliasRCB)->RCB_PADRAO, (cAliasRCB)->RCB_VERSAO, ;
	    (cAliasRCB)->RCB_PESQ, (cAliasRCB)->RCB_SHOWMA, (cAliasRCB)->RCB_MODULO, (cAliasRCB)->RCB_PROCES})
	(cAliasRCB)->(DbSkip())
EndDo

(cAliasRCB)->(dbCloseArea())

Return (aRCB)

/*/{Protheus.doc} fGrvRAZRAW
//Grava dados na RAW/RAZ
@author flavio.scorrea
@since 26/04/2019
/*/
Function fGrvRAZRAW(lCalcResc)

Local aArea		:= GetArea()
Local aAreaSRA	:= SRA->(GetArea())
Local aAreaSRC	:= SRC->(GetArea())
Local aCNPJ		:= {}
Local aFilMat	:= {}
Local lTemRAW	:= .F.
Local lTemResc  := .F.
Local nPos		:= 0
Local cCnpj		:= ""
Local cCnpjAtu	:= ""
Local cCpf		:= SRA->RA_CIC
Local cFilMat   := SRA->RA_FILIAL + SRA->RA_MAT
Local cIndFol	:= "1"
Local cIndMV	:= "1"
Local cPdTot	:= ""
Local nBase		:= 0
Local nBase2	:= 0
Local nBase4	:= 0
Local nCont		:= 0
Local nValAux	:= 0
Local nBase3	:= 0
Local nINSS3	:= 0
Local nFaixa1	:= 0
Local nFaixa2	:= 0

DEFAULT lGrvRAZRAW := .F.
DEFAULT lCalcResc  := .F.

Static nOrderSRR := RetOrder("SRR","RR_FILIAL+RR_MAT+RR_TIPO3+RR_PERIODO+RR_ROTEIR+RR_SEMANA+RR_PD+RR_CC+RR_ITEM+RR_CLVL+RR_SEQ+DtoS(RR_DATA)")

If cSeqMV > "1" .and. lGrvRAZRAW
	If (nPos := aScan(aEstb,{|x| AllTrim(x[1]) == AllTrim(SRA->RA_FILIAL)})) > 0
		cCnpjAtu := SubStr(aEstb[nPos][2], 1, 8)
	EndIf

	SRA->( dbSetOrder(nOrderMULTV) )
	SRA->( dbSeek(SRA->RA_CIC) )

	While SRA->( !Eof() .and. SRA->RA_CIC == cCpf )
		If SRA->RA_FILIAL + SRA->RA_MAT <> cFilMat .and. !(SRA->RA_RESCRAI $ "30/31")
			If (nPos := aScan(aEstb,{|x| AllTrim(x[1]) == AllTrim(SRA->RA_FILIAL)})) > 0
				cCnpj := SubStr(aEstb[nPos][2], 1, 8)
			EndIf
			SRC->( dbSetOrder(1) )//RC_FILIAL+RC_MAT+RC_PD+RC_CC+RC_SEMANA+RC_SEQ
			If SRC->( dbSeek(SRA->RA_FILIAL + SRA->RA_MAT) ) .And. SRC->RC_PERIODO == cPeriodo .And. SRC->RC_SEQMV < cSeqMV
				aAdd( aFilMat, {SRA->RA_FILIAL, SRA->RA_MAT, SRC->RC_SEQMV, cCnpj, SRA->RA_CATEFD} )
			ElseIf lCalcResc //Busca outra rescisão na SRR
				SRR->(DbSetOrder(nOrderSRR))
				If SRR->(DbSeek(SRA->RA_FILIAL + SRA->RA_MAT + "R"))
					lTemResc := .F.
					While SRR->(!Eof() .and. RR_FILIAL + RR_MAT + RR_TIPO3 == SRA->RA_FILIAL + SRA->RA_MAT + "R")
						If SRR->RR_PERIODO == cPeriodo
							If SRR->RR_PD $ ( aCodfol[13,1] + "/" + aCodfol[14,1] + "/" + aCodfol[221,1] )
								If ( nPos := aScan( aCNPJ, { |x| x[1]+x[3] == cCnpj + SRA->RA_CATEFD } ) ) == 0
									aAdd( aCNPJ, { cCnpj, SRR->RR_VALOR, SRA->RA_CATEFD } )
								Else
									aCNPJ[nPos, 2] += SRR->RR_VALOR
								EndIf
							EndIf
							lTemResc := .T.
						EndIf
						SRR->(DbSkip())
					EndDo
					If lTemResc
						aAdd( aFilMat, {SRA->RA_FILIAL, SRA->RA_MAT, "1", cCnpj, SRA->RA_CATEFD} )
					EndIf
				EndIf
			EndIf
		EndIf
		SRA->(DbSkip())
	EndDo

	RestArea(aAreaSRA)

	If aScan( aFilMat, { |x| x[4] != cCnpjAtu } ) > 0
		aSort( aFilMat,,, { |x,y| x[3] < y[3] } )
		//O trecho abaixo busca as bases de contribuição de outras raízes de CNPJ, separando por CNPJ e categoria
		For nCont := 1 To Len(aFilMat)
			nValAux	:= 0
			If (nPos := aScan(aEstb,{|x| AllTrim(x[1]) == AllTrim(aFilMat[nCont, 1])})) > 0
				cCnpj := SubStr(aEstb[nPos][2], 1, 8)
			EndIf
			If cCnpjAtu != cCnpj.And. SRC->( dbSeek( aFilMat[nCont, 1] + aFilMat[nCont, 2] ) )
				While SRC->( !EoF() ) .And. SRC->RC_FILIAL+SRC->RC_MAT == aFilMat[nCont, 1] + aFilMat[nCont, 2] .And. SRC->RC_PERIODO == cPeriodo
					If SRC->RC_PD $ (aCodfol[13,1] + "/" + aCodfol[14,1] + "/" + aCodfol[221,1]) .Or. (cTipoRot == "6" .And. SRC->RC_PD $ (aCodfol[19,1] + "/" + aCodfol[20,1]))
						nValAux	+= SRC->RC_VALOR
					EndIf
					SRC->( dbSkip() )
				EndDo
				If nValAux > 0
					If ( nPos := aScan( aCNPJ, { |x| x[1]+x[3] == aFilMat[nCont, 4]+aFilMat[nCont, 5] } ) ) == 0
						aAdd( aCNPJ, { aFilMat[nCont, 4], nValAux, aFilMat[nCont, 5] } )
					Else
						aCNPJ[nPos, 2] += nValAux
					EndIf
				EndIf
			EndIf
		Next nCont

		If cTipoRot == "6"
			cIndFol := "2"
			cPdTot  := aCodfol[019,1]
		Else
			cPdTot  := aCodfol[013,1] + aCodfol[221,1]
		EndIf

		aEval( aPd, { |x| If(x[1] $ cPdTot .And. x[9] != "D", nBase += x[5], Nil) } )
		aEval( aPd, { |x| If(x[1] $ aCodFol[14,1] + "/" + aCodFol[20,1] .And. x[9] != "D", nBase2 += x[5], Nil) } )
		aEval( aPd, { |x| If(x[1] $ aCodFol[13,1] + "/" + aCodFol[19,1] .And. x[9] != "D", nBase4 += x[5], Nil) } )

		If cTipoRot == "9"
			aEval( aPd, { |x| If(x[1] $ aCodFol[064,1] .And. x[9] != "D", nINSS3 += x[5], Nil) } )
			aEval( aPd, { |x| If(x[1] $ aCodFol[288,1] + "/" + aCodFol[1847,1] .And. x[9] != "D", nBase3 += x[5], Nil) } )
		Endif

		If nBase2 > 0 .and. nBase > 0 //Somou bases para chegar ao cálculo do INSS
			cIndMv  := "2"
		ElseIf nBase == 0  .and. nBase2 > 0 //Nâo houve desconto de INSS. INSS total descontado de outras empresas.
			cIndMV	:= "3"
		ElseIf nINSS3 == 0  .and. nBase3 > 0  .And. cTipoRot == "9" //TSV
			cIndMV	:= "3"
		ElseIf nBase2 == 0 .and. nBase > 0 .and. nBase4 > 0 .and. aTinss <> NIL .and. Len(aTinss) > 0 //Verifica se mudou de faixa
			for nFaixa1 := 1 to Len(aTinss)
				If nBase < aTinss[nFaixa1,1]
					Exit
				EndIf
			next nFaixa1
			nBase4 := nBase + nBase4
			for nFaixa2 := 1 to Len(aTinss)
				If nBase4 < aTinss[nFaixa2,1]
					Exit
				EndIf
			next nFaixa2
			If nFaixa1 <> nFaixa2
				cIndMv  := "2"
			Endif
		ElseIf nBase > 0 .and. nINSS3 > 0 .and. nBase3 > 0
			cIndMv  := "2"
		EndIf

		dbSelectArea("RAW")
		RAW->(dbSetOrder(1))//RAW_FILIAL, RAW_MAT, RAW_FOLMES, RAW_TPFOL, RAW_PROCES, RAW_ROTEIR, RAW_SEMANA

		dbSelectArea("RAZ")
		RAZ->(DbSetOrder(1))//RAZ_FILIAL+RAZ_MAT+RAZ_FOLMES+RAZ_TPFOL+RAZ_INSCR

		//O trecho abaixo faz exclusão da RAW/RAZ caso um vínculo de ordem anterior da mesma raiz de CNPJ possua dados para garantir que os dados gravados estejam corretos devido a possibilidade de alterar a ordem de cálculo
		For nCont := 1 To Len(aFilMat)
			If (nPos := aScan(aEstb,{|x| AllTrim(x[1]) == AllTrim(aFilMat[nCont, 1])})) > 0
				cCnpj := SubStr(aEstb[nPos][2], 1, 8)
			EndIf
			If cCnpjAtu == cCnpj .Or. cSeqMV == "2" 
				If RAW->( dbSeek(aFilMat[nCont, 1] + aFilMat[nCont, 2] + cPeriodo + cIndFol) )
					While RAW->( !EoF() ) .And. RAW->RAW_FILIAL+RAW->RAW_MAT+RAW->RAW_FOLMES+RAW->RAW_TPFOL == aFilMat[nCont, 1] + aFilMat[nCont, 2] + cPeriodo + cIndFol
						If RecLock("RAW", .F.)
							RAW->( dbDelete() )
							RAW->( MsUnlock() )
						EndIf
						RAW->( dbSkip() )
					EndDo
				EndIf
				If RAZ->( dbSeek(aFilMat[nCont, 1] + aFilMat[nCont, 2] + cPeriodo + cIndFol) )
					While RAZ->( !EoF() ) .And. RAZ->RAZ_FILIAL+RAZ->RAZ_MAT+RAZ->RAZ_FOLMES+RAZ->RAZ_TPFOL == aFilMat[nCont, 1] + aFilMat[nCont, 2] + cPeriodo + cIndFol
						If (nPos := Ascan(aEstb,{|x| AllTrim(x[2]) == AllTrim(RAZ->RAZ_INSCR)})) > 0
							If RecLock("RAZ", .F.)
								RAZ->( dbDelete() )
								RAZ->( MsUnlock() )
							EndIf
						EndIf
						RAZ->( dbSkip() )
					EndDo
				EndIf
			EndIf
		Next nCont

		lTemRAW := RAW->(dbSeek(SRA->RA_FILIAL + SRA->RA_MAT + cPeriodo + cIndFol))

		If !lTemRAW
			RecLock("RAW",.T.)
				RAW->RAW_FILIAL	:= SRA->RA_FILIAL
				RAW->RAW_MAT	:= SRA->RA_MAT
				RAW->RAW_FOLMES	:= cPeriodo
				RAW->RAW_TPFOL	:= cIndFol
				RAW->RAW_PROCES	:= cProcesso
				RAW->RAW_ROTEIR	:= cRot
				RAW->RAW_SEMANA	:= cNumPag
				RAW->RAW_TPREC	:= cIndMV
			RAW->(msUnlock())
		ElseIf lTemRAW .and. cCnpjAtu <> cCnpj
			RecLock("RAW",.F.)
				RAW->RAW_FILIAL	:= SRA->RA_FILIAL
				RAW->RAW_MAT	:= SRA->RA_MAT
				RAW->RAW_FOLMES	:= cPeriodo
				RAW->RAW_TPFOL	:= cIndFol
				RAW->RAW_PROCES	:= cProcesso
				RAW->RAW_ROTEIR	:= cRot
				RAW->RAW_SEMANA	:= cNumPag
				RAW->RAW_TPREC	:= cIndMV
			RAW->(msUnlock())
		EndIf

		//O trecho abaixo faz exclusão da RAZ da matrícula atual porque não tem o campo RAZ_CATEG no índice, então exclui tudo primeiro para depois gravar registro(s) novo(s)
		If RAZ->( dbSeek(SRA->RA_FILIAL+SRA->RA_MAT+cPeriodo+cIndFol) )
			While RAZ->( !EoF() ) .And. RAZ->RAZ_FILIAL+RAZ->RAZ_MAT+RAZ->RAZ_FOLMES+RAZ->RAZ_TPFOL == SRA->RA_FILIAL+SRA->RA_MAT+cPeriodo+cIndFol
				If (nPos := Ascan(aEstb,{|x| AllTrim(x[2]) == AllTrim(RAZ->RAZ_INSCR)})) > 0
					If RecLock("RAZ", .F.)
						RAZ->( dbDelete() )
						RAZ->( MsUnlock() )
					EndIf
				EndIf
				RAZ->( dbSkip() )
			EndDo
		EndIf

		For nCont := 1 To Len(aCNPJ)
			If (nPos := Ascan(aEstb,{|x| SubStr(AllTrim(x[2]), 1, 8) == AllTrim(aCNPJ[nCont, 1])})) > 0
				cCnpj := aEstb[nPos][2]
			EndIf

			RecLock("RAZ", .T.)
				RAZ->RAZ_VALOR	:= aCNPJ[nCont, 2]
				RAZ->RAZ_FILIAL	:= SRA->RA_FILIAL
				RAZ->RAZ_MAT	:= SRA->RA_MAT
				RAZ->RAZ_FOLMES	:= cPeriodo
				RAZ->RAZ_TPFOL	:= cIndFol
				RAZ->RAZ_INSCR	:= cCnpj
				RAZ->RAZ_CATEG	:= aCNPJ[nCont, 3]
				RAZ->RAZ_CIC	:= SRA->RA_CIC
				RAZ->RAZ_TPINS	:= Iif(Len(AllTrim(cCnpj)) >= 14,"1","2")
			RAZ->(msUnlock())
		Next nCont
	EndIf

	RestArea(aAreaSRA)
	RestArea(aAreaSRC)
	RestArea(aArea)
EndIf

Return .T.

/*/{Protheus.doc} GrvCalc132
//Gravacao do calculo do roteiro 132
@author julio.silva
@since 10/12/2021
/*/
Function GrvCalc132()

    Local lDCTFWEB  := GetMvRH( "MV_RHDCTFW", , .F. )

	If ( !lDissidio .And. !lCalcFol )

		If lGrvRAZRAW
			fGrvRAZRAW()
		EndIf

        aEval( aPd , { |X| Grava132(X) } )

		If cTipoRot == "6" .And. !lDissidio .And. lDCTFWEB
			fGrvDCTFWEB()
		EndIf

	EndIf


    If ( lDissidio .And. !lCalcFol )

        GravaDissidio(aPd,aPdOld,,aCodFol)

    EndIf

Return

/*/{Protheus.doc} RHAlphSeq
//Retorna a sequencia numérica correspondente de um alfanumérico
@author martins.marcio
@since 04/03/2022
/*/
Function RHAlphSeq(cAlfa)

	Local nSeqRet := 0
	Local cStrAux

	DEFAULT cAlfa := ""

	If !Empty(cAlfa)
		cStrAux := Replicate("0", Len(cAlfa))
		While !(cStrAux == cAlfa)
			cStrAux := Soma1(cStrAux)
			nSeqRet++
		EndDo
	EndIf

Return nSeqRet

/*/{Protheus.doc} fCarPdFMS
Carrega as verbas e ID´s de férias de mês seguinte
@author Allyson Luiz Mesashi
@since 06/04/2022
/*/
Function fCarPdFMS()

Local aRet		:= {}
Local cTmpAlias := GetNextAlias()
Local cVerbas	:= ""
Local cIds		:= ""
Local cWhere 	:= "% SRV.RV_INSSFER = '1' AND SRV.RV_CODMSEG <> '   '  %"

BeginSql alias cTmpAlias
	SELECT SRV.RV_COD, SRV.RV_CODFOL
	FROM %table:SRV% SRV
	WHERE SRV.RV_FILIAL = %xfilial:SRV%
		AND %exp:cWhere%
		AND SRV.%notDel%
EndSql

While !(cTmpAlias)->( Eof() )
	cVerbas += (cTmpAlias)->RV_COD + "/"
	cIds 	+= (cTmpAlias)->RV_CODFOL + "/"
	(cTmpAlias)->( dbSkip() )
EndDo

aRet := {cVerbas, cIds}
(cTmpAlias)->( dbCloseArea() )

Return aRet

/*/{Protheus.doc} MyRandon
Gera string aleatória
@author Leandro Drumond
@since 14/10/2022
/*/
Static Function MyRandon(nTamanho)

Local aChar := {"#","a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s","t","u","v","w","x","y","z","0","1","2","3","4","5","6","7","8","9"}
Local cRet  := ""
Local nX    := 1
Local nVar  := 0

For nX := 1 to nTamanho
	nVar := Randomize(1,Len(aChar)+1)
	cRet += aChar[nVar]
Next nX

Return cRet

/*/{Protheus.doc} fBuscaDed
Busca deduções de IR dos demais vínculos quando o cálculo de IR destes foi feito com dedução simplificada.
@author Leandro Drumond
@since 25/05/2023
/*/
Static Function fBuscaDed(cChave, cVerbas,lFer)
Local aArea 		:= GetArea()
Local aAreaSRC      := SRC->(GetArea())
Local aAreaSRD
Local aAreaSRR
Local cKeyAux
Local cRotAux 
Local nRet   		:= 0
Local nPos 			:= 0
Local nValAux       := 0
Local lSoma         := .T.

Static nOrderSRC := RetOrder("SRC","RC_FILIAL+RC_MAT+RC_PERIODO+RC_ROTEIR+RC_SEMANA+RC_PD")
Static nOrderSRD := RetOrder("SRD","RD_FILIAL+RD_MAT+RD_PERIODO+RD_DATARQ+RD_PD+RD_SEMANA+RD_SEQ+RD_CC")
Static nOrderFER := RetOrder("SRR","RR_FILIAL+RR_MAT+RR_PERIODO+RR_ROTEIR+RR_SEMANA+RR_PD")
Static __cRotOrd := fGetCalcRot("1") + "/" + fGetCalcRot("9")
Static __cRotFer := fGetCalcRot("3")
Static __cRot132 := fGetCalcRot("6")
Static __cRotRES := fGetCalcRot("4")

DEFAULT lFer     := .F.

SRC->(DbSetOrder(nOrderSRC))
If SRC->(DbSeek(cChave))
	While SRC->(!Eof() .and. RC_FILIAL+RC_MAT+RC_PERIODO+RC_ROTEIR == cChave)
		If SRC->RC_PD $ cVerbas
			nPos := Ascan(aPdv, { |x| x[1] == SRC->RC_PD })

			If nPos == 0
				fIncide(SRC->RC_PD)
				nPos := Len(aPdv)
			EndIf

			If ( (SRC->RC_ROTEIR $ __cRotOrd .and. aPdv[nPos,11] == "N" .and. aPdv[nPos,12] == "N" ) .Or. ;
					(SRC->RC_ROTEIR == __cRotFer .and. aPdv[nPos,11] == "S" ) .Or. ;
					(SRC->RC_ROTEIR == __cRot132 .and. aPdv[nPos,12] == "S" ) )

				nValAux += SRC->RC_VALOR
			EndIf
		EndIf

		//Se for fretista, e a tributação foi completa, não soma a dedução pois já abateu da base de IR
		If SRC->RC_PD == aCodFol[15,1] .and. SRC->RC_TRIBIR <> "2" .and. SRA->RA_CATEFD $ "711|712|734"
			lSoma := .F.
		EndIf

		SRC->(DbSkip())
	EndDo
	If lSoma
		nRet += nValAux 
	EndIf
ElseIf lFer .or. cTipoRot == "4"
	aAreaSRR := SRR->(GetArea())
	SRR->(DbSetOrder(nOrderFER))

	cKeyAux := If(lFer, cChave, SubStr(cChave,0,Len(cChave)-3) + __cRotRES)

	If SRR->(DbSeek(cKeyAux))
		While SRR->(!Eof() .and. RR_FILIAL+RR_MAT+RR_PERIODO+RR_ROTEIR == cKeyAux)
			If SRR->RR_PD $ cVerbas
				nPos := Ascan(aPdv, { |x| x[1] == SRR->RR_PD })

				If nPos == 0
					fIncide(SRR->RR_PD)
					nPos := Len(aPdv)
				EndIf

				If ( (SRR->RR_ROTEIR $ __cRotOrd + "/" + __cRotRES .and. aPdv[nPos,11] == "N" .and. aPdv[nPos,12] == "N" ) .Or. ;
						(SRR->RR_ROTEIR == __cRotFer .and. aPdv[nPos,11] == "S" ) .Or. ;
						(SRR->RR_ROTEIR == __cRot132 .and. aPdv[nPos,12] == "S" ) )

					nRet += SRR->RR_VALOR
				EndIf
			EndIf

			SRR->(DbSkip())
		EndDo
	EndIf

	RestArea(aAreaSRR)
EndIf 

If ( SRA->RA_TIPOPGT == "S" .and. cSemana > "01" ) .and. (nRet == 0 .or. SRA->RA_CATEFD $ "711|712|734" )

	aAreaSRD      := SRD->(GetArea())

	SRD->(DbSetOrder(nOrderSRD))

	cKeyAux := SubStr(cChave,1,Len(cChave)-3)
	cRotAux := SubStr(cChave,Len(cChave)-2)

	If SRD->(DbSeek(cKeyAux))
		While SRD->(!Eof() .and. RD_FILIAL+RD_MAT+RD_PERIODO == cKeyAux)
			If SRD->RD_ROTEIR == cRotAux  .and. SRD->RD_PD $ cVerbas
				nPos := Ascan(aPdv, { |x| x[1] == SRD->RD_PD })

				If nPos == 0
					fIncide(SRD->RD_PD)
					nPos := Len(aPdv)
				EndIf

				If ( (SRD->RD_ROTEIR $ __cRotOrd .and. aPdv[nPos,11] == "N" .and. aPdv[nPos,12] == "N" ) .Or. ;
						(SRD->RD_ROTEIR == __cRotFer .and. aPdv[nPos,11] == "S" ) .Or. ;
						(SRD->RD_ROTEIR == __cRot132 .and. aPdv[nPos,12] == "S" ) )

					If !(SRA->RA_CATEFD $ "711|712|734") .or. fVerTribIr(SRD->(RD_FILIAL+RD_MAT+RD_PERIODO+RD_DATARQ+aCodFol[15,1]+RD_SEMANA))
						nRet += SRD->RD_VALOR
					EndIf
				EndIf
			EndIf			

			SRD->(DbSkip())
		EndDo
	EndIf

	RestArea(aAreaSRD)

EndIf

RestArea(aAreaSRC)
RestArea(aArea)
Return nRet

/*/{Protheus.doc} fMDelVerba
Função para marcar verbas de múltiplos vínculos como deletadas no array aPd para semanalistas múltiplos vínculos
@author Allyson Luiz Mesashi
@since 20/12/2023
/*/
Static Function fMarcDelVbs( aVerbas )

Local nCont := 0
Local nPos  := 0

For nCont := 1 To Len(aPd)
    If ( nPos := aScan( aVerbas, { |x| x == aPd[nCont, 1] } ) ) > 0 .And. aPd[nCont, 9] != "D" .And. aPd[nCont, 11] == "9" .And. aPd[nCont, 3] < cSemana
        aPd[nCont, 9] := "D"
    EndIf
Next nCont

Return

/*/{Protheus.doc} fDelDepRU6
Exclui registro da RU6 caso folha tenha sido calculada antes da rescisão e agora esta sendo feito recalculo.
@author Leandro Drumond
@since 11/01/2024
/*/
Static Function fDelDepRU6()

DEFAULT lTemRU6 := AliasInDic("RU6") 

If lTemRU6
	TcSqlExec("DELETE FROM " + RetSqlName("RU6") + " WHERE RU6_FILIAL = '" + SRA->RA_FILIAL + "' AND RU6_MAT = '" + SRA->RA_MAT + "' AND RU6_DTPGTO = '" + DtoS(dData_Pgto) + "' AND RU6_TPREND = '1'")
EndIf

Return Nil

/*/{Protheus.doc} fVldS151
Atualiza campo CODBEN da tabela S151 quando tamanho de RN_COD/RFO_COD for maior que 3
@author Allyson Luiz Mesashi
@since 26/04/2024
/*/
Static Function fVldS151()

    Local aArea			:= GetArea()
    Local aAreaRCB		:= RCB->( GetArea() )
    Local aAreaRCC		:= {}
    Local nPosDados     := 0
    Local nTamAntig     := 0
    Local nTamCod       := 0

    Default nTamRFO_COD := TamSX3( "RFO_CODIGO" )[1]
    Default nTamRN_COD  := TamSX3( "RN_COD" )[1]

    nTamCod := Max( nTamRFO_COD, nTamRN_COD )

	RCB->( DBSetOrder( 3 ) )//RCB_FILIAL+RCB_CAMPOS+RCB_CODIGO
	If RCB->( DBSeek( xFilial("RCB")+"CODBEN    "+"S151" ) ) .And. RCB->RCB_TAMAN < nTamCod
        If RCB->( Reclock("RCB", .F.) )
            nTamAntig       := RCB->RCB_TAMAN
            RCB->RCB_TAMAN  := nTamCod
            RCB->( MsUnlock() )
        EndIf

        RCB->( DBSetOrder( 1 ) )//RCB_FILIAL+RCB_CODIGO
        If RCB->( DBSeek( xFilial("RCB")+"S151" ) )
            While RCB->( !Eof() ) .And. RCB->RCB_FILIAL+RCB->RCB_CODIGO == xFilial("RCB")+"S151"
                If AllTrim(RCB->RCB_CAMPOS) == "CODBEN"
                    Exit
                EndIf
                nPosDados += RCB->RCB_TAMAN
                RCB->( DBSkip() )
            End
        EndIf

        aAreaRCC := RCC->( GetArea() )
        RCC->( DBSetOrder( 1 ) )//RCC_FILIAL+RCC_CODIGO+RCC_FIL+RCC_CHAVE+RCC_SEQUEN

        If RCC->( DBSeek( xFilial("RCC") + "S151" ) )
            While RCC->( !Eof() ) .And. RCC->RCC_FILIAL + RCC->RCC_CODIGO == xFilial("RCC") + "S151"
                If RCC->( Reclock("RCC", .F.) )
                    RCC->RCC_CONTEU	:= SubStr( RCC->RCC_CONTEU, 1, nPosDados ) + SubStr( RCC->RCC_CONTEU, nPosDados+1, nTamAntig ) + Space(nTamCod - nTamAntig) + SubStr( RCC->RCC_CONTEU, nPosDados+1+nTamAntig )
                    RCC->( MsUnlock() )
                EndIf
                RCC->( DBSkip() )
            End
        EndIf

        RestArea( aAreaRCC )
	EndIf

    RestArea( aAreaRCB )
    RestArea( aArea )
	
Return

/*/{Protheus.doc} fVerTribIr
Verifica se a tributação foi completa no período
@author Leandro Drumond
@since 17/06/2024
/*/
Static Function fVerTribIr(cChave)
Local nRecSRD := SRD->(Recno())
Local lRet    := .F.

If SRD->(DbSeek(cChave))
	If SRD->RD_TRIBIR == "2"
		lRet := .T. 
	EndIf 
EndIf

SRD->(DbGoTo(nRecSRD))

Return lRet

/*/{Protheus.doc} fTemLanc
Verifica se há cadastro vigente de lançamentos fixos ou valores futuros
@author Marco Arcanjo
@since 18/09/2024
/*/
Static Function fTemLanc()

	Local cAlias := GetNextAlias()	
	Local cDIniPg := cAnoMes + STRZERO(F_ULTDIA(dDataRef),2)
	Local cDFimPg := cAnomes + '01'
	Local cRotOrd := If(cTipoRot=="4",fGetRotOrdinar(),cRot)
	Local lRet := .F.

	BeginSQL Alias cAlias
	
		SELECT
			COUNT(RG1_PD) TOTAL_VERBAS 
		FROM
			%table:RG1%
		WHERE
			RG1_FILIAL = %exp:SRA->RA_FILIAL%
			AND RG1_MAT = %exp:SRA->RA_MAT%
			AND RG1_AUTOM = '1'
			AND RG1_DINIPG <= %exp:cDIniPg% 		
			AND 
			(
				RG1_DFIMPG = '        ' 
				OR RG1_DFIMPG >= %exp:cDFimPg% 
			)
			AND 
			(
				RG1_ROT = %exp:cRot%
				OR RG1_ROT = %exp:cRotOrd% 
			)		
			AND %notDel%

		UNION ALL

		SELECT
			COUNT(RK_PD) TOTAL_VERBAS 
		FROM
			%table:SRK%
		WHERE
			RK_FILIAL = %exp:SRA->RA_FILIAL%
			AND RK_MAT = %exp:SRA->RA_MAT%
			AND RK_STATUS = '2'			
			AND %notDel%

	EndSQL

	While (cAlias)->(!Eof())

		If ( lRet := (cAlias)->TOTAL_VERBAS > 0 )
			Exit 
		EndIf
		(cAlias)->(DbSkip())
	EndDo

	(cAlias)->(DbCloseArea())

Return lRet

/*/{Protheus.doc} fChkeConsig
Verifica se a tabela RUO existe e se as verbas para provisão do eConsignado nas férias foram criadas
@author Leandro Drumond
@since 05/05/2025
/*/
Static Function fChkeConsig()
Local aArea := GetArea()
Local lRet  := .F.

If ChkFile("RUO")
	lRet := .T. 
	DbSelectArea("SRK")
	SRK->(DbSetOrder(1))

	DbSelectArea("RUO")
	RUO->(DbSetOrder(3))
EndIf

RestArea(aArea) 

Return lRet

/*/{Protheus.doc} fVldParCons
Verifica se consignado deve ser provisonado quando férias é calculada para o futuro
@author Leandro Drumond
@since 16/06/2025
/*/
Static Function fVldParCons()
Local aPerFol  := {}
Local cPerAux  := ""
Local nParc    := SRK->RK_PARCELA 
Local nPargPg  := SRK->RK_PARCPAG
Local nMeses   := 0
Local nX 	   := 0
Local lRet     := .F.

fGetPerAtual(@aPerFOL,xFilial( "RCH", SRA->RA_FILIAL), cProcesso, fGetCalcRot("1"))

nMeses := nParc - nPargPg

If Len(aPerFOL) > 0 .and. SRK->RK_DTVENC <= aPerFol[1,11] //Se a próxima parcela será paga no período atual da folha, subtrai um mês da verificação
	nMeses-- 
EndIf

cPerAux := If(Len(aPerFOL) > 0 .and. SRK->RK_DTVENC <= aPerFol[1,11], aPerFol[1,1], AnoMes(SRK->RK_DTVENC))

For nX := 1 to nMeses 
	cPerAux := SomaMesAno(cPerAux)
Next nX

lRet := cPerAux >= cPeriodo 

Return lRet

/*/{Protheus.doc} fBuscaProv
Busca provisonamento do eConsignado no ADI e Férias para não ultrapassar o valor da parcela
@author Bruno Costa
@since 08/07/2025
/*/
Static Function fBuscaProv(cPdProv, lFer)
Local aArea   := GetArea()
Local aPerADI := {}
Local cChave  := ""
Local nRet    := 0

DEFAULT nOrderSRC := RetOrder("SRC","RC_FILIAL+RC_MAT+RC_PERIODO+RC_ROTEIR+RC_SEMANA+RC_PD")
DEFAULT nOrderFER := RetOrder("SRR","RR_FILIAL+RR_MAT+RR_PERIODO+RR_ROTEIR+RR_SEMANA+RR_PD")
DEFAULT __cRotFer := fGetCalcRot("3")

Static nOrSRDProv := RetOrder("SRD","RD_FILIAL+RD_MAT+RD_PROCES+RD_ROTEIR+RD_PERIODO+RD_SEMANA+RD_PD")
Static __cRotADI  := fGetCalcRot("2")
Static __cOldProc := ""
Static __lNotAdi  := .F.
Static __lAdiSRD  

If !lFer .And. __cOldProc <> SRA->RA_FILIAL + SRA->RA_PROCES + cPeriodo
	__cOldProc := SRA->RA_FILIAL + SRA->RA_PROCES + cPeriodo
	__lNotAdi  := .F.
	If fGetPerAtual(@aPerADI, xFilial("RCH", SRA->RA_FILIAL), SRA->RA_PROCES, __cRotADI) 
		__lAdiSRD := aPerADI[1][1] > cPeriodo 
	Else 
		__lNotAdi := .T.
	EndIf
EndIf 

If !lFer .And. __lNotAdi
	Return nRet
EndIf 

If !lFer
	If !__lAdiSRD
		SRC->(DbSetOrder(nOrderSRC))
		cChave := SRA->RA_FILIAL + SRA->RA_MAT + cPeriodo + __cRotADI + cSemana + cPdProv 
		If SRC->(DbSeek(cChave))
			While SRC->(!Eof() .And. RC_FILIAL+RC_MAT+RC_PERIODO+RC_ROTEIR+RC_SEMANA+RC_PD == cChave)
				If SRC->RC_PD == cPdProv
					nRet += SRC->RC_VALOR
				EndIf
				SRC->(DbSkip())
			EndDo
		EndIf	
	Else
		SRD->(DbSetOrder(nOrSRDProv))
		cChave := SRA->RA_FILIAL + SRA->RA_MAT + SRA->RA_PROCES + __cRotADI + cPeriodo + cSemana + cPdProv 
		If SRD->(DbSeek(cChave))
			While SRD->(!Eof() .And. RD_FILIAL+RD_MAT+RD_PROCES+RD_ROTEIR+RD_PERIODO+RD_SEMANA+RD_PD == cChave)
				If SRD->RD_PD == cPdProv
					nRet += SRD->RD_VALOR
				EndIf			
				SRD->(DbSkip())
			EndDo
		EndIf
	EndIf	
Else
	SRR->(DbSetOrder(nOrderFER))
	cChave := SRA->RA_FILIAL + SRA->RA_MAT + cPeriodo + __cRotFer + cSemana 
	If SRR->(DbSeek(cChave))
		While SRR->(!Eof() .And. RR_FILIAL+RR_MAT+RR_PERIODO+RR_ROTEIR+RR_SEMANA == cChave)
			If SRR->RR_PD $ cPdProv
				nRet += SRR->RR_VALOR
			EndIf
			SRR->(DbSkip())
		EndDo
	EndIf
EndIf 

RestArea(aArea)

Return nRet
