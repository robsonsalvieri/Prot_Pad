#INCLUDE "PROTHEUS.CH"
#INCLUDE "HEADERGD.CH"
#INCLUDE "GPEXFOR1.CH"
#INCLUDE "GPEXOPER.CH"
#INCLUDE "PONCALEN.CH"

#DEFINE _TABLE_ 	01
#DEFINE _HEADER_	02
#DEFINE _KEY_	 	03

Static __aSvTables
Static __cLogFile
Static __aEtiquetas	:= {}
Static __aMnemError	:= {}
Static __aSeqPd		:= {} 
Static __aImpEstat	:= {}
Static __afHist__	:= {}
Static __aFiltro	:= {}
Static __nHandle	:= -1
Static __cPD		:= ""
Static __cCodFor	:= ""
Static __cQryRGB	:= ""
Static __cQrySRK	:= ""
Static __cQrySR8	:= ""
Static __cQrySRQ	:= ""
Static __cQryRG1	:= ""
Static __cQryTpAus	:= ""
Static __cQryDep	:= ""
Static __cDelete 	:= "%D_E_L_E_T_ = ' '%"
Static __lVldCalc	:= .F.

Static __cSRVtab	:= '%'+RetSqlName('SRV')+'%'	
Static __cSRQtab	:= '%'+RetSqlName('SRQ')+'%' 
Static __cRCMTab	:= '%'+RetSqlName('RCM')+'%'
Static __cSRBTab	:= '%'+RetSqlName('SRB')+'%' 
Static __cRG7Tab	:= '%'+RetSqlName('RG7')+'%'
Static __cRG1Tab	:= '%'+RetSqlName('RG1')+'%'
Static __cSR8Tab	:= '%'+RetSqlName('SR8')+'%'   
Static __cSRKTab	:= '%'+RetSqlName('SRK')+'%'   
Static __cRGBTab	:= '%'+RetSqlName('RGB')+'%'  
Static __cSRMTab	:= '%'+RetSqlName('SRM')+'%'  
Static __cRC3Tab	:= '%'+RetSqlName('RC3')+'%'  
Static __cSRFTab	:= '%'+RetSqlName('SRF')+'%'  
Static __cSR7Tab	:= '%'+RetSqlName('SR7')+'%'  
Static __cSRATab	:= '%'+RetSqlName('SRA')+'%'  
Static __cRCPTab	:= '%'+RetSqlName('RCP')+'%'  
Static __cRCATab	:= '%'+RetSqlName('RCA')+'%'  
Static __cSRCTab	:= RetSqlName('SRC')
Static __xFilSRV	:= xfilial("SRV")
Static __xFilRG9	:= xFilial("RG9")

Static __cItemClvl 	:= GetMvRH( "MV_ITMCLVL", .F., "2" ) $ "1*3"

Static __oSt01
Static __oSt02
Static oHash_Tab

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³GPEXFOR1  ³ Autor ³ Mauricio T. Takakura      ³ Data ³28/09/2007³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Biblioteca de Funcoes Genericas para uso em Formulas Mexico     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Uso      ³ Generico                                                       ³
ÃÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³             ATUALIZACOES SOFRIDAS DESDE A CONSTRU€AO INICIAL.             ³
ÃÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Programador ³ Data     ³ BOPS/FNC  ³Motivo da Alteracao                    ³
ÃÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Cecilia C.  ³20/05/2014³TPPCSB     ³Incluido o fonte da 11 para a 12 e efe-³
³            ³          ³           ³tuada a limpeza.                       ³
³M.Camargo   ³17/12/2015³PDR_SER_   ³Localización chile.                    ³
³M.Camargo   ³          ³MRH-1134   |Modificación a la funcioalidad         ³
³            ³          ³           ³del operador OP_DIAS_DERECHO para chile³
³            ³          ³           ³pero aplica a todos paises modelo 2.   ³
³Oscar G.    ³22/11/2019³DMINA-7678 ³Modif. en Fun. EvalForm para operadores³
³            ³          ³           ³PRIMER_REG_TRAY y ULTIMO_REG_TRAY.     ³
³Oscar G.    ³05/03/2020³DMINA-8597 ³Se retorna para Mex, el uso de la Fun. ³
³            ³          ³           ³PosSRV() en Fun. CalcProc().           ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
/*/
/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³RstNewCalc	  ³Autor ³Mauricio T. Takakura ³ Data ³01/10/2007³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Restaurar as variaveis Static do novo modelo de calculo.     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL                                                    	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico 													 ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function RstNewCalc(lAbreArqLog)

DEFAULT lAbreArqLog:= .T. 
/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Statics utilizadas no Processo de Calculo e Na Montagem de    ³
³Formulas e/ou Roteiros									       ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
__aSvTables		:= NIL
__aFormulas		:= {}
__aEtiquetas	:= {}
__aMnemError	:= {}
__aSeqPd		:= {}
__cPD			:= ""
__cCodFor		:= ""
__lVldCalc		:= .F.
__nHandle		:= -1
__aImpEstat		:= {}
__aFiltro		:= {}
__cDelete 		:= "%D_E_L_E_T_ = ' '%"
__oSt01			:= NIL
__oSt02			:= NIL

If lAbreArqLog 
	__cLogFile		:= NIL
Endif

If ValType(oHash_Tab) == "O"
	HMClean(oHash_Tab)
	FreeObj(oHash_Tab)
	oHash_Tab := Nil
EndIf

Return( NIL )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³RstCalFun	  ³Autor ³Mauricio T. Takakura ³ Data ³19/11/2007³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Restaurar as variaveis Static por Funcionario.               ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL                                                          ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                             ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico 													 ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function RstCalFun()

__aSeqPd		:= {}

Return( NIL )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³CalcProc	  ³Autor ³Mauricio T. Takakura ³ Data ³17/10/2007³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Executa o Calculo por Processo  							 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³nRet                                                   	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico 													  ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function CalcProc( aPd			,;	// Cadastro de verbas somente com os itens do Cadastro de Verbas por Processo
				   aRotPd		,;	// Verbas por Processo
				   aMnemonicos	,;	// Mnemonicos utilizados no Roteiro
				   aOperador	,;	// Operadores utilizados no Roteiro
				   aDefTab		,;	// Tabelas de Usuario utilizada no roteiro
				   aIncid		,;	// Incidencias cadastradas para o Funcionario
				   aValFut		,;	// Valores Futuros
				   aAfast		,;	// Afastamentos
				   aTables		,;	// Tabelas do Sistema
				   aAusent		,;	// Tipos de Ausencia
				   aBenef		,;	// Beneficiarios
				   lExecField	,;  // Execucao do campo atraves de um campo
				   cAliasTable	 ; 	// Alias da tabela de leitura das variaveis de campo
				  )
Local cType
Local cPrefVar

Local nRet		:= 0
Local nMnemo
Local nMnemos
Local nPosItem
Local nItens
Local nPosAlias
Local nPosField
Local nPosMnemo
Local nPosRetTabla
Local nPosTab
Local nPosCol
Local nPosLin
Local nTotItem
Local nPosRCM
Local nX
Local nPosSRKBen := 0

Local uVar
Local uCont
Local uValor

Local lEvaFor		:= .F.
Local lExecOk		:= .T.
Local bErro			:= ErrorBlock( { |oErr| ErroForm( oErr , @lExecOk  ) } )
Local lInic         := .T. 
Local nRecSRJ		:= SRJ->(RECNO())

Local cModSRJ		:= "" 
Local cFilTab		:= "" 
Local cTipoAfa		:= ""

DEFAULT	lExecField	:= .F.
DEFAULT	cAliasTable := ""

Private lPosSrv		:= .F.
Private nItemForm 	:= 1
Private cPd
Private cCodFor
Private cCritAcum
Private lTrace 		:= .F.
Private lSR8I
Private lLeeIncid
Private lLeeValFut
Private lLeeAcumul
Private lLeeAusenc
Private lLeeBenef    
Private lLeeLanFix
Private cFilAcum
Private cAnoAcuIni
Private cAnoAcuFim
Private cSuma_nPgIni 				// Variaveis vinculadas a Mnemonicos Reservados
Private cSuma_nPgFim				// Variaveis vinculadas a Mnemonicos Reservados
Private cSuma_Tipo_Nom				// Variaveis vinculadas a Mnemonicos Reservados

Private lItemClvl 	:= __cItemClvl
Private lFieldExec 	:= lExecField
Private cTableAlias	:= cAliasTable

//Variaveis para o calendario e transferencias do funcionario
Private __aGetSreFun := {}
Private __aTabCalFun := {}
Private __dDataIni 	 := CTOD("//")
Private __dDataFim   := CTOD("//")

Private cFiltro_Acum	:=""		//Variavel com string de filtro OP_FILTRO_ACUM
Private cFiltro_Movli	:=""		//Variavel com string de filtro OP_FILTRO_MOVLI

If Type("lHabTrace") == "U"
	Private lHabTrace := .F.
Endif

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Validar as Cargas no primeiro registro a Calcular			   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
If !(__lVldCalc)
	If Empty( aMnemonicos ) .Or. Empty(aOperador)
		AddMsgLog( OemToAnsi(STR0005) ) // "Mnemonicos e Operadores não foram carregados!"
		nRet := -1						// "Nao Consegui Carregar os Mnemonicos/Operadores"
	EndIf
	
	If Empty( aPd )
		AddMsgLog( OemToAnsi(STR0006) ) // "Não possui Verbas para a realizaçao do Calculo!"
		nRet := -2
	EndIf

	If Empty( aRotPd )
		AddMsgLog( OemToAnsi(STR0007) ) // "Não possui verbas por Processo para realizar o Cálculo!"
		nRet := -3
	EndIf	

	If Len( __aFormulas ) == 0
		AddMsgLog( OemToAnsi(STR0030) ) // "Não possui formulas para realizar o Cálculo!"
		nRet := -4 						// Erro na Carga das Formulas
	EndIf			
EndIf

Begin Sequence

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Execucao de Cada Item do Roteiro de Calculo para cada verba   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	lTrace 	:= lHabTrace
	__cPD	:= ""  
	
	If Empty( cModSRJ )
		Sx2ChkModo( "SRJ", NIL, .F., @cModSRJ, NIL )
	EndIf
	cFilTab	:= If( cModSRJ=="E", SRA->RA_FILIAL, xFilial("SRJ"))	
	
	nItens := Len(aRotPd)
	nMnemos := Len( aMnemonicos )

	If ValType(oHash_Tab) == "O"
		HMClean(oHash_Tab)
		FreeObj(oHash_Tab)
		oHash_Tab := Nil
	EndIf
	
	//Melhoria de performance, criação de hash
	oHash_Tab := AToHM(aMnemonicos, 4, 0)

	While nItemForm <= nItens

		lEvaFor := .F.
		cPD 		:= aRotPd[ nItemForm, __nSRMPd ]
		

		cCodFor		:= aRotPd[ nItemForm, __nSRMForm ]
		cCritAcum	:= aRotPd[ nItemForm, __nSRMCodCri ]

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Posiciona os Criterios de Acumulacao a cada Formula          ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ		
		If !Empty(cCritAcum)
		
			DbSelectArea( "RG9" )	// Criterios de Acumulacao
			DbSetOrder( nCalRg9Ord )
			DbSeek( __xFilRG9 + cCritAcum, .F. )			

		EndIf
		
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Inicializa os Mnemonicos 									   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		For nMnemo := 1 To nMnemos
			IF (;
					( aMnemonicos[ nMnemo , 02 ] == "F" );		//"F" -> Mnemonicos Tipo Arquivo - Nao sao declarados
				)
				
				/*/
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³Nao carrega a tabela RCM, pois posiciona no While da tabela   ³
				³SR8, conforme a verba localizada							   ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
				If ( aMnemonicos[ nMnemo , 03] == "RCM" )
					Loop
				EndIf				
				
				If !Empty(aMnemonicos[ nMnemo , 03])
	
					/*/
					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					³Para esses mnemonicos somente sera declarado a variavel. A car³
					³ga sera realizada no momento da execucao da formula.    	   ³
					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
					If aMnemonicos[ nMnemo , 03] $ "RGB*SR8*RG7*RCP*SRB*SRC*SR7*SR3*RG1" .Or. (aMnemonicos[ nMnemo , 03] $ "SRK" .and. !lFieldExec)
						uVar := aMnemonicos[ nMnemo , 06 ] // O Tipo do campo vem do SX3
						nPosAlias := aScan( aTables, { |x| x[1] = aMnemonicos[ nMnemo , 03 ] } )
						If nPosAlias > 0
							If aMnemonicos[ nMnemo , 07] == "D" 
								uVar := DTOC(uVar)
							EndIf
						endif
						If !(__lVldCalc)	// Executa1	 somente no primeiro funcionario
							_SetOwnerPrvt( aMnemonicos[ nMnemo , 01 ] , uVar )
						Elseif aMnemonicos[ nMnemo , 02 ] == "F" .or. lInic
							&(aMnemonicos[ nMnemo , 01 ]) := uVar
						EndIf
					Else
						cPrefVar := aMnemonicos[ nMnemo , 03 ]
						If lFieldExec .and. aMnemonicos[ nMnemo , 03 ] == cTableAlias
							cPrefVar := "M"	// Leitura das variaveis de memoria 
						EndIf
						uVar := cPrefVar + '->' + aMnemonicos[ nMnemo , 04 ]
						nPosAlias := aScan( aTables, { |x| x[1] = aMnemonicos[ nMnemo , 03 ] } )
						If nPosAlias > 0
							If aMnemonicos[ nMnemo , 07] == "D" 
								uVar := 'DTOC(' + uVar + ')'
							EndIf
						Endif
						If !(__lVldCalc)	// Executa1	 somente no primeiro funcionario
							_SetOwnerPrvt( aMnemonicos[ nMnemo , 01 ] , &uVar )
						Elseif aMnemonicos[ nMnemo , 02 ] == "R" .or. lInic
							&(aMnemonicos[ nMnemo , 01 ]) := &(uVar)
						EndIf
						If ( aMnemonicos[ nMnemo, 2 ] == "F" .and. aMnemonicos[ nMnemo , 03 ]=="SRV" .and. SubStr( aMnemonicos[ nMnemo, 4 ],1,2 ) == "RV" )// carregar mnemonicos com informações da SRV.
							If RetValSrv( cPd , __xFilSRV , "RV_COD") == cPd
								uValor:= RetValSrv( cPd , __xFilSRV , aMnemonicos[ nMnemo , 04 ])
								&(aMnemonicos[ nMnemo, 01 ]) := uValor
							EndIf
						EndIf
					EndIf
				EndIf
				Loop
			EndIF
	
			// "C"-Caracter/"N"-Numerico/"L"-Logico/"D"-Data  --> Reinicializados a cada funcionario
			IF ( !Empty( uVar := AllTrim( aMnemonicos[ nMnemo , 05 ] ) ) )
				IF (;
						( aMnemonicos[ nMnemo , 02 ] == "D" );
						.and.;
						( "/" $ uVar );
					)
					IF (;
							CheckExecForm( { || uVar := Ctod( uVar ) } , .F. );
							.and.;
							( ( cType := ValType( uVar ) ) == aMnemonicos[ nMnemo , 02 ] );
						)
						If !(__lVldCalc)	// Executa1	 somente no primeiro funcionario
							_SetOwnerPrvt( aMnemonicos[ nMnemo , 01 ] , uVar )
						Elseif aMnemonicos[ nMnemo , 02 ] == "R" .or. lInic
							&(aMnemonicos[ nMnemo , 01 ]) := uVar
						EndIf
					Else
						If !(__lVldCalc)	// Executa somente no primeiro funcionario
							_SetOwnerPrvt( aMnemonicos[ nMnemo , 01 ] , GetValType( aMnemonicos[ nMnemo , 02 ] ) )
						Elseif aMnemonicos[ nMnemo , 02 ] == "R" .or. lInic
							&(aMnemonicos[ nMnemo , 01 ]) := GetValType( aMnemonicos[ nMnemo , 02 ] )
						EndIf
					EndIF
				Else
					If !(__lVldCalc)	// Executa somente no primeiro funcionario
						IF CheckExecForm( @uVar , .F. )
							_SetOwnerPrvt( aMnemonicos[ nMnemo , 01 ] , uVar )
						ElseIf aMnemonicos[ nMnemo , 02 ] == "R" .or. lInic
							aAdd( __aMnemError, { aMnemonicos[ nMnemo , 01 ], GetValType( aMnemonicos[ nMnemo , 02 ] ), aMnemonicos[ nMnemo , 05 ], uVar } )
							_SetOwnerPrvt( aMnemonicos[ nMnemo , 01 ] , GetValType( aMnemonicos[ nMnemo , 02 ] ) )
						EndIf 
					Else
						If Empty(__aMnemError)
							If Empty(aMnemonicos[ nMnemo , 05 ])
								uCont := GetValType( aMnemonicos[ nMnemo , 02 ] )
							Else
								uCont := &(aMnemonicos[ nMnemo , 05 ])
							EndIf
						Else
							nPosItem := aScan( __aMnemError, { |x| x[1] == aMnemonicos[ nMnemo , 01 ] } )
							If nPosItem > 0
								uCont := __aMnemError[ nPosItem , 02 ]
							Else
								If Empty(aMnemonicos[ nMnemo , 05 ])
									uCont := GetValType( aMnemonicos[ nMnemo , 02 ] )
								Else
									uCont := &(aMnemonicos[ nMnemo , 05 ])
								EndIf
							EndIf
						EndIf
						If aMnemonicos[ nMnemo , 02 ] == "R" .or. lInic
							&(aMnemonicos[ nMnemo , 01 ]) := uCont
						EndIf
					EndIF
				EndIF
			Else
				If !(__lVldCalc)	// Executa somente no primeiro funcionario
					_SetOwnerPrvt( AllTrim(aMnemonicos[ nMnemo , 01 ]) , GetValType( aMnemonicos[ nMnemo , 02 ] ) )
				ElseIf aMnemonicos[ nMnemo , 02 ] == "R" .or. lInic
					&(aMnemonicos[ nMnemo , 01 ]) := GetValType( aMnemonicos[ nMnemo , 02 ] )
				EndIf
			EndIF
		Next nMnemo
		
		__lVldCalc := .T.
		lInic      := .F.
	
		lLeeIncid  := aRotPd[nItemForm, __nSRMIncid]  	== '1'
		lLeeValFut := aRotPd[nItemForm, __nSRMValFut]	== '1'
		lLeeAcumul := aRotPd[nItemForm, __nSRMAcumul]	== '1'
		lLeeAusenc := aRotPd[nItemForm, __nSRMAusenc]	== '1'
		If ( __nSRMBenef > 0 )
			lLeeBenef := aRotPd[nItemForm, __nSRMBenef ]	 == '1'
		Else
			lLeeBenef := .F.
		EndIf
		If ( __nSRMLanFix > 0 )
			lLeeLanFix := aRotPd[nItemForm, __nSRMLanFix ]	 == '1'
		Else
			lLeeLanFix := .F.
		EndIf		
		lSR8I 	  := .F.

		cCodFor		:= aRotPd[ nItemForm, __nSRMForm ]
		cCritAcum	:= aRotPd[ nItemForm, __nSRMCodCri ]

		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Se deve Ler Tabela de Incidencias                             ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		If lLeeIncid 
			nPosItem := aScan( aIncid, { |x| x[__nRGBPD] == cPD } )
			If nPosItem > 0
				nTotItem := Len( aIncid )
				While nPosItem <= nTotItem .and. aIncid[ nPosItem, __nRGBPD ] == cPD
					RstVarAux( aMnemonicos )
					
					If __nRGBFun > 0 .and. SRA->RA_CODFUNC != aIncid [ nPosItem, __nRGBFun ] //Verifica se a função do cadastro é diferente da função do RGB  
						DbSelectArea( "SRJ" )	// Cadastro de Funcoes
						DbSetOrder( nOrdRcj )
						DbSeek( cFilTab + aIncid [ nPosItem, __nRGBFun ], .F. )      
						
						//Carga dos Mnemonicos de Função - Utilizada para o lançamento da incidência                   
						nPosMnemo:= aScan( aMnemonicos, { |x,y| x[3] == "SRJ" } )
						If nPosMnemo > 0 
							While nPosMnemo > 0
								nPosAlias := aScan( aTables, { |x| x[1] = aMnemonicos[ nPosMnemo, 3 ] } )
								If nPosAlias > 0
									uValor := "SRJ->" + aMnemonicos[ nPosMnemo , 04 ]
									if aMnemonicos[ nPosMnemo, 7 ] == "D" .AND.;
									   ValType(uValor) == "C"
										uValor := StoD(uValor)
									EndIf
									&(aMnemonicos[ nPosMnemo, 01 ]) := &(uValor)
								EndIf
								nPosMnemo := aScan( aMnemonicos, { |x| x[3] == "SRJ" }, nPosMnemo+1 )
							EndDo
						EndIf						
					Endif
				
					/*/
					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					³Carga dos Mnemonicos de Incidencias                           ³
					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
					nPosMnemo:= aScan( aMnemonicos, { |x,y| x[3] == "RGB" } )
					If nPosMnemo > 0 
						While nPosMnemo > 0
							nPosAlias := aScan( aTables, { |x| x[1] = aMnemonicos[ nPosMnemo, 3 ] } )
							If nPosAlias > 0
								nPosField := GdFieldPos( aMnemonicos[ nPosMnemo, 4 ] , aTables[nPosAlias, _HEADER_] )
								If nPosField > 0
									uValor := aIncid[nPosItem, nPosField]
									if aTables[nPosAlias, _HEADER_, nPosfield, __AHEADER_TYPE__] == "D" .AND.;
									   ValType(uValor) == "C"
										uValor := StoD(uValor)
									EndIf
									&(aMnemonicos[ nPosMnemo, 01 ]) := uValor
								EndIf
							EndIf
							nPosMnemo := aScan( aMnemonicos, { |x| x[3] == "RGB" }, nPosMnemo+1 )
						EndDo
					EndIf
					
					/*/
					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					³Execucao da Formula                                           ³
					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
					nRet := EvalForm( nItemForm, aTables, aIncid[nPosItem] )

					/*/
					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					³Gravacao da Verba no Movimento                                ³
					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
					fGravaForm(aTables, cPD, lSR8I, .T.,,,aIncid[nPosItem])

					Importe 	:= 0
					Unidades 	:= 0
					No_Aplicado := 0
					Entidad := ""
					lEvaFor := .T.
					
					If __nRGBFun > 0 .and. SRA->RA_CODFUNC != aIncid [ nPosItem, __nRGBFun ] //Verifica se a função do cadastro é diferente da função do RGB 
						DbSelectArea( "SRJ" )	// Cadastro de Postos/Funcoes
						DbGoTo(nRecSRJ)   
						
						//Carga dos Mnemonicos de Função - Definida no cadastro de funcionários.
						nPosMnemo:= aScan( aMnemonicos, { |x,y| x[3] == "SRJ" } )
						If nPosMnemo > 0 
							While nPosMnemo > 0
								nPosAlias := aScan( aTables, { |x| x[1] = aMnemonicos[ nPosMnemo, 3 ] } )
								If nPosAlias > 0
									uValor := "SRJ->" + aMnemonicos[ nPosMnemo , 04 ]
									if aMnemonicos[ nPosMnemo , 07] == "D" .AND.;
									   ValType(uValor) == "C"
										uValor := StoD(uValor)
									EndIf
									&(aMnemonicos[ nPosMnemo, 01 ]) := &(uValor)
								EndIf
								nPosMnemo := aScan( aMnemonicos, { |x| x[3] == "SRJ" }, nPosMnemo+1 )
							EndDo
						EndIf						
					Endif			   
					nPosItem++  							
				EndDo
			else
				/*/
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³Reinicializacao dos Mnemonicos de Incidencias                 ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
				nPosMnemo:= aScan( aMnemonicos, { |x,y| x[3] == "RGB" } )
				If nPosMnemo > 0 
					While nPosMnemo > 0
						nPosAlias := aScan( aTables, { |x| x[1] = aMnemonicos[ nPosMnemo, 3 ] } )
						If nPosAlias > 0
							if aMnemonicos[ nPosMnemo, 7 ] == "C"
								uValor := ""
							elseif aMnemonicos[ nPosMnemo, 7 ] == "N"
								uValor := 0
							elseif aMnemonicos[ nPosMnemo, 7 ] == "D"
								uValor := CTOD("//")
							EndIf
							&(aMnemonicos[ nPosMnemo, 01 ]) := uValor
						EndIf
						nPosMnemo := aScan( aMnemonicos, { |x| x[3] == "RGB" }, nPosMnemo+1 )
					EndDo
				EndIf
			EndIf
		EndIf

		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Se deve Ler Tabela de Beneficiarios						   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/		
		If lLeeBenef 
			nPosItem := aScan( aBenef, { |x| x[__nSRQPD] == cPD } )
			If ( nPosItem > 0 )			
				nTotItem := Len( aBenef )
				/*/
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³Carga dos Mnemonicos de Beneficiarios				           ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
				nPosMnemo:= aScan( aMnemonicos, { |x,y| x[3] == "SRQ" } )
				If nPosMnemo > 0 
					While nPosMnemo > 0   
						RstVarAux( aMnemonicos )
						nPosAlias := aScan( aTables, { |x| x[1] = aMnemonicos[ nPosMnemo, 3 ] } )
						If nPosAlias > 0
							nPosField := GdFieldPos( aMnemonicos[ nPosMnemo, 4 ] , aTables[nPosAlias, _HEADER_] )
							If nPosField > 0
								uValor := aBenef[nPosItem, nPosField]
								If ValType(uValor) == "D"
									uValor := DtoS(uValor)
								EndIf
								&(aMnemonicos[ nPosMnemo, 01 ]) := uValor
							EndIf
						EndIf
						nPosMnemo := aScan( aMnemonicos, { |x| x[3] == "SRQ" }, nPosMnemo+1 )
					EndDo
							
				EndIf
				
				///-Tratamiento para Préstamos
				IF lLeeValFut
					nPosSRKBen := aScan( aValFut, { |x| x[__nSRKNuId] == aBenef[ nPosItem, __nSRQNuID ]} )
					If nPosSRKBen > 0

						RstVarAux( aMnemonicos )	
						/*/
						ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						³Carga dos Mnemonicos de Valores Futuros			              ³
						ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
						nPosMnemo:= aScan( aMnemonicos, { |x,y| x[3] == "SRK" } )
						If nPosMnemo > 0 
							While nPosMnemo > 0
								nPosAlias := aScan( aTables, { |x| x[1] = aMnemonicos[ nPosMnemo, 3 ] } )
								If nPosAlias > 0
									nPosField := GdFieldPos( aMnemonicos[ nPosMnemo, 4 ] , aTables[nPosAlias, _HEADER_] )
									If nPosField > 0
										uValor := aValFut[nPosSRKBen, nPosField]
										If ValType(uValor)  == "D"
											uValor := DtoS(uValor)
										EndIf
										&(aMnemonicos[ nPosMnemo, 01 ]) := uValor
									EndIf
								EndIf
								nPosMnemo := aScan( aMnemonicos, { |x| x[3] == "SRK" }, nPosMnemo+1 )
							EndDo
						EndIf

					EndIf
					
					// Indicamos que ya no lee préstamos para evitar se procese nuevamente el préstamo si es que leeben = 1 y leepre=1
					lLeeValFut := .F.
											
				EndIF 
				
				/// Termina tratamiento para préstamos
				/*/
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³Execucao da Formula                                           ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
				nRet := EvalForm( nItemForm, aTables,NIL,,,aBenef[nPosItem])
				/*/
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³Gravacao da Verba no Movimento                                ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
				//fGravaForm(aTables, cPD, lSR8I,,,,)
				fGravaForm(aTables, cPD, lSR8I,,IIF(nPosSRKBen > 0, .T.,.F.),,IIF(nPosSrkBen > 0,aValFut[nPosSRKBen],aBenef[nPosItem]))
				
				Importe 	:= 0
				Unidades 	:= 0
				No_Aplicado := 0
				
				
				lEvaFor := .T.

				nPosItem++
				
			Else
				/*/
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³Carga dos Mnemonicos de Beneficiarios				              ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
				nPosMnemo:= aScan( aMnemonicos, { |x,y| x[3] == "SRQ" } )
				If nPosMnemo > 0 
					While nPosMnemo > 0
						nPosAlias := aScan( aTables, { |x| x[1] = aMnemonicos[ nPosMnemo, 3 ] } )
						If nPosAlias > 0
							If aMnemonicos[ nPosMnemo, 7 ] == "C"
								uValor := ""
							ElseIf aMnemonicos[ nPosMnemo, 7 ] == "N"
								uValor := 0
							ElseIf aMnemonicos[ nPosMnemo, 7 ] == "D"
								uValor := CTOD("//")
							EndIf
							&(aMnemonicos[ nPosMnemo, 01 ]) := uValor
						EndIf
						nPosMnemo := aScan( aMnemonicos, { |x| x[3] == "SRQ" }, nPosMnemo+1 )
					EndDo

					lEvaFor := .T.

				EndIf
			EndIf			
		EndIf     
		


		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Se deve Ler Tabela de Valores Futuros                         ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		If lLeeValFut .and. !lFieldExec 
			nPosItem := aScan( aValFut, { |x| x[__nSRKPD] == cPD } )
			If nPosItem > 0
				nTotItem := Len( aValFut )
				While nPosItem <= nTotItem .and. aValFut[ nPosItem, __nSRKPD ] == cPD
					RstVarAux( aMnemonicos )	
					/*/
					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					³Carga dos Mnemonicos de Valores Futuros			           ³
					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
					nPosMnemo:= aScan( aMnemonicos, { |x,y| x[3] == "SRK" } )
					If nPosMnemo > 0 
						While nPosMnemo > 0
							nPosAlias := aScan( aTables, { |x| x[1] = aMnemonicos[ nPosMnemo, 3 ] } )
							If nPosAlias > 0
								nPosField := GdFieldPos( aMnemonicos[ nPosMnemo, 4 ] , aTables[nPosAlias, _HEADER_] )
								If nPosField > 0
									uValor := aValFut[nPosItem, nPosField]
									If ValType(uValor)  == "D"
										uValor := DtoS(uValor)
									EndIf
									&(aMnemonicos[ nPosMnemo, 01 ]) := uValor
								EndIf
							EndIf
							nPosMnemo := aScan( aMnemonicos, { |x| x[3] == "SRK" }, nPosMnemo+1 )
						EndDo
					EndIf

					/*/
					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					³Execucao da Formula                                           ³
					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
					nRet := EvalForm( nItemForm, aTables,NIL,aValFut[nPosItem])

					/*/
					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					³Gravacao da Verba no Movimento                                ³
					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
					fGravaForm(aTables, cPD, lSR8I,,.T.,,aValFut[nPosItem])
					
					Importe 	:= 0
					Unidades 	:= 0
					No_Aplicado := 0
							
					lEvaFor := .T.
					
					nPosItem++
				EndDo
			else
				/*/
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³Carga dos Mnemonicos de Valores Futuros			           ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
				nPosMnemo:= aScan( aMnemonicos, { |x,y| x[3] == "SRK" } )
				If nPosMnemo > 0 
					While nPosMnemo > 0 
						nPosAlias := aScan( aTables, { |x| x[1] = aMnemonicos[ nPosMnemo, 3 ] } )
						If nPosAlias > 0
							if aMnemonicos[ nPosMnemo, 7 ] == "C"
								uValor := ""
							elseif aMnemonicos[ nPosMnemo, 7 ] == "N"
								uValor := 0
							elseif aMnemonicos[ nPosMnemo, 7 ] == "D"
								uValor := CTOD("//")
							EndIf
							&(aMnemonicos[ nPosMnemo, 01 ]) := uValor
						EndIf
						nPosMnemo := aScan( aMnemonicos, { |x| x[3] == "SRK" }, nPosMnemo+1 )
					EndDo
				EndIf
			EndIf
		EndIf

		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Se deve Ler Tabela de Ausencias                               ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		If lLeeAusenc
			nPosItem := aScan( aAfast, { |x| x[__nSR8PD] == cPD } )
			If nPosItem > 0
				nTotItem := Len( aAfast )
				While nPosItem <= nTotItem .and. aAfast[ nPosItem, __nSR8PD ] == cPD
					RstVarAux( aMnemonicos )
					/*/
					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					³Carga dos Mnemonicos de Tipos de Ausencia			           ³
					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
					/// captura conteudo do tipo do afastamento
					cTipoAfa := aAfast[ nPosItem, __nSR8Tipo ]
					nPosMnemo:= aScan( aMnemonicos, { |x,y| x[3] == "RCM" } )
					nPosRCM  := aScan( aAusent, { |x| x[__nRCMPD] == cPD .and. x[__nRCMTipo] == cTipoAfa} )     
					If ( nPosMnemo > 0 )
						While nPosMnemo > 0
							nPosAlias := aScan( aTables, { |x| x[1] = aMnemonicos[ nPosMnemo, 3 ] } )
							If nPosAlias > 0
								nPosField := GdFieldPos( aMnemonicos[ nPosMnemo, 4 ] , aTables[nPosAlias, _HEADER_] )
								If ( nPosField > 0 .and. !Empty(nPosRCM) )
									uValor := aAusent[nPosRCM, nPosField]
									If ValType(uValor) == "D"
										uValor := DtoS(uValor)
									EndIf									
									&(aMnemonicos[ nPosMnemo, 01 ]) := uValor
								EndIf
							EndIf
							nPosMnemo := aScan( aMnemonicos, { |x| x[3] == "RCM" }, nPosMnemo+1 )
						EndDo
					EndIf
				
					/*/
					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					³Carga dos Mnemonicos de Ausencias 					           ³
					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
					nPosMnemo:= aScan( aMnemonicos, { |x,y| x[3] == "SR8" } )
					If nPosMnemo > 0 
						While nPosMnemo > 0 
							nPosAlias := aScan( aTables, { |x| x[1] = aMnemonicos[ nPosMnemo, 3 ] } )
							If nPosAlias > 0
								nPosField := GdFieldPos( aMnemonicos[ nPosMnemo, 4 ] , aTables[nPosAlias, _HEADER_] )
								If nPosField > 0
									uValor := aAfast[nPosItem, nPosField]
									If ValType(uValor) == "D"
										uValor := DtoS(uValor)
									EndIf
									&(aMnemonicos[ nPosMnemo, 01 ]) := uValor
								EndIf
							EndIf
							nPosMnemo := aScan( aMnemonicos, { |x| x[3] == "SR8" }, nPosMnemo+1 )
						EndDo
					EndIf

					/*/
					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					³Execucao da Formula                                           ³
					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
					nRet := EvalForm( nItemForm, aTables,NIL,,aAfast[nPosItem])

					/*/
					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					³Gravacao da Verba no Movimento                                ³
					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
					fGravaForm(aTables, cPD, lSR8I,,,.T.,aAfast[nPosItem])

					lEvaFor := .T.
					
					Importe 	:= 0
					Unidades 	:= 0
					No_Aplicado := 0

					nPosItem++
				EndDo
			Else

				/*/
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³Carga dos Mnemonicos de Tipos de Ausencia			           ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
				nPosMnemo:= aScan( aMnemonicos, { |x,y| x[3] == "RCM" } )
				nPosRCM  := aScan( aAusent, { |x| x[__nRCMPD] == cPD } )
				If ( nPosMnemo > 0 )
					While nPosMnemo > 0
						nPosAlias := aScan( aTables, { |x| x[1] = aMnemonicos[ nPosMnemo, 3 ] } )
						If nPosAlias > 0
							nPosField := GdFieldPos( aMnemonicos[ nPosMnemo, 4 ] , aTables[nPosAlias, _HEADER_] )
							If ( nPosField > 0 .and. !Empty(nPosRCM) )
								uValor := aAusent[nPosRCM, nPosField]
								If ValType(uValor) == "D"
									uValor := DtoS(uValor)
								EndIf									
								&(aMnemonicos[ nPosMnemo, 01 ]) := uValor
							EndIf
						EndIf
						nPosMnemo := aScan( aMnemonicos, { |x| x[3] == "RCM" }, nPosMnemo+1 )
					EndDo
				EndIf			
			
				/*/
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³Carga dos Mnemonicos de Ausencias 					           ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
				nPosMnemo:= aScan( aMnemonicos, { |x,y| x[3] == "SR8" } )
				If nPosMnemo > 0 
					While nPosMnemo > 0
						nPosAlias := aScan( aTables, { |x| x[1] = aMnemonicos[ nPosMnemo, 3 ] } )
						If nPosAlias > 0
							if aMnemonicos[ nPosMnemo, 7 ] == "C"
								uValor := ""
							elseif aMnemonicos[ nPosMnemo, 7 ] == "N"
								uValor := 0
							elseif aMnemonicos[ nPosMnemo, 7 ] == "D"
								uValor := CTOD("//")
							EndIf
							&(aMnemonicos[ nPosMnemo, 01 ]) := uValor
						EndIf
						nPosMnemo := aScan( aMnemonicos, { |x| x[3] == "SR8" }, nPosMnemo+1 )
					EndDo
				EndIf				
			EndIf
		EndIf
		
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Se deve Ler Lançamentos Fixos                                 ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		If lLeeLanFix 
			nPosItem := aScan( aLanFix, { |x| x[__nRG1PD] == cPD } )
			If nPosItem > 0
				nTotItem := Len( aLanFix )
				While nPosItem <= nTotItem .and. aLanFix[ nPosItem, __nRG1PD ] == cPD
					RstVarAux( aMnemonicos )
					/*/
					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					³Carga dos Mnemonicos de Incidencias                           ³
					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
					nPosMnemo    := aScan( aMnemonicos, { |x,y| x[3] == "RG1" } )
					If nPosMnemo > 0 
						While nPosMnemo > 0
							nPosAlias := aScan( aTables, { |x| x[1] = aMnemonicos[ nPosMnemo, 3 ] } )
							If nPosAlias > 0
								nPosField := GdFieldPos( aMnemonicos[ nPosMnemo, 4 ] , aTables[nPosAlias, _HEADER_] )
								If nPosField > 0

									uValor := aLanFix[nPosItem, nPosField]
									If aTables[nPosAlias, _HEADER_, nPosfield, __AHEADER_TYPE__] == "D" .AND.;
									   ValType(uValor) == "C"
										uValor := StoD(uValor)
									EndIf
									&(aMnemonicos[ nPosMnemo, 01 ]) := uValor

                                    If aMnemonicos[ nPosMnemo, 4 ] == 'RG1_TPCALC'
										nPosRetTabla := aScan( aMnemonicos, { |x,y| x[1] == ME_RET_TABLA } )
										If nPosRetTabla > 0 
					                       If aLanFix[nPosItem , nPosField] == "4" //Tipo Tabla
			   									nPosTab	:= GdFieldPos( "RG1_CODTAB"	, aTables[nPosAlias, _HEADER_] )
			   									nPosLin	:= GdFieldPos( "RG1_LINHA"	, aTables[nPosAlias, _HEADER_] )
			   									nPosCol	:= GdFieldPos( "RG1_COLUNA"	, aTables[nPosAlias, _HEADER_] )

												IF aLanFix[nPosItem,nPosLin] != 0 .and. aLanFix[nPosItem,nPosCol] != 0
													uValor := fTabela(aLanFix[nPosItem,nPosTab], aLanFix[nPosItem,nPosLin], aLanFix[nPosItem,nPosCol])
													&(aMnemonicos[ nPosRetTabla, 01 ]) := uValor
												EndIf	
											EndIf	
										EndIf
									EndIf

								EndIf
							EndIf
							nPosMnemo := aScan( aMnemonicos, { |x| x[3] == "RG1" }, nPosMnemo+1 )
						EndDo
					EndIf
					
					/*/
					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					³Execucao da Formula                                           ³
					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
					nRet := EvalForm( nItemForm, aTables,NIL,,,,aLanFix[nPosItem])

					/*/
					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					³Gravacao da Verba no Movimento                                ³
					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
					fGravaForm(aTables, cPD, lSR8I,,,,aLanFix[nPosItem])

					Importe 	:= 0
					Unidades 	:= 0
					No_Aplicado := 0
					
					lEvaFor := .T.
					
					nPosItem++
				EndDo
			Else
				/*/
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³Reinicializacao dos Mnemonicos de Lançamentos Fixos           ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
				nPosRetTabla := aScan( aMnemonicos, { |x,y| x[1] == ME_RET_TABLA } )
				&(aMnemonicos[ nPosRetTabla, 01 ]) := NIL

				nPosMnemo := aScan( aMnemonicos, { |x,y| x[3] == "RG1" } )
				If nPosMnemo > 0 
					While nPosMnemo > 0
						nPosAlias := aScan( aTables, { |x| x[1] = aMnemonicos[ nPosMnemo, 3 ] } )
						If nPosAlias > 0
							If aMnemonicos[ nPosMnemo, 7 ] == "C"
								uValor := ""
							Elseif aMnemonicos[ nPosMnemo, 7 ] == "N"
								uValor := 0
							Elseif aMnemonicos[ nPosMnemo, 7 ] == "D"
								uValor := CTOD("//")
							EndIf
							&(aMnemonicos[ nPosMnemo, 01 ]) := uValor
						EndIf
						nPosMnemo := aScan( aMnemonicos, { |x| x[3] == "RG1" }, nPosMnemo+1 )
					EndDo
				EndIf
			EndIf
		EndIf
				
                                  
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Executar Formulas que nao estao vinculados a nenhuma tabela   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		//If !lLeeIncid .and. !lLeeValFut .and. !lLeeAusenc
	   	if !lEvaFor 

			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³Execucao da Formula                                           ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			nRet := EvalForm( nItemForm, aTables )

			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³Gravacao da Verba no Movimento                                ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			If cPaisLoc == "DOM" .And. cPD == FGetCodFol("0072") .And. Len(aAfast) > 0 .And. ( FunName() == ("GPEM031") .Or. FunName() == ("GPEM032") )
				nPosItem := aScan( aAfast, { |x| x[__nSR8PD] == FGetCodFol("0786") .And. x[__nSR8DtIni] == dDataKey } )   
				
				If nPosItem > 0
					fGravaForm(aTables, cPD, lSR8I,,,.T.,aAfast[nPosItem])
				Else 
					fGravaForm(aTables, cPD, lSR8I)
				Endif
			Else
				fGravaForm(aTables, cPD, lSR8I)
			Endif
			
			Importe 	:= 0
			Unidades 	:= 0
			No_Aplicado := 0

		EndIf
		
		//-- Ocorreu erro na execucao da formula
		If nRet < 0
			Exit
		EndIf

		nItemForm++
	EndDo

End Sequence

ErrorBlock( bErro )

//-- Se gerou erro Fatal devera abortar todo o processo de calculo
If !lExecOk 
	nRet := -5
EndIf

Return( nRet )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³EvalForm    ³ Autor ³Mauricio Takakura     ³ Data ³22/10/2007³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Executa os itens da formula                          	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL															 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³SIGAGPE     												 ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function EvalForm( nItemFor	,;		// Item da Formula a executar
 						 aTables	,;		// Array de Tabelas
						 aIncid		,;		// Item de Incidencias a ser lido
						 aValFut	,;		// Item do Valor Futuro
						 aAfast		,;		// Item do Afastamento
						 aBenef		,;		// Item do Beneficiario
						 aLanFix	 ;		// Item de Lançamentos Fixos
					    )
Local aValores
Local aTrajLab
Local aDependiente

Local cOper1
Local cOper2
Local cCpyOper1
Local cCpyOper2
Local cExpFor
Local cOperador
Local cResult
Local cTab
Local cTabAux
Local cSeqFor
Local cOpBusProces
Local dDataIni
Local dDataFim
Local dDtIniTraj
Local dDtFimTraj
Local cErro

Local lGravaOK
Local lResult
Local lRound 

Local nZ
Local nY			:= 1
Local nRet 			:= 0
Local nPosEtiq		:= 0
Local nForItens		:= 0
Local nValEtiq 		:= 0
Local nPosTrajLab	:= 0
Local nPosDepend	:= 0
Local nTipoItem		:= 0
Local nQtdeEtiq		:= 0
Local nMnemo 		:= 0
Local nMnemos		:= 0
Local nPosAlias
Local nPosNew
Local nPosField
Local nPosSR8
Local nPosDataIni
Local nPosDataFim
Local _nPosTab		:= 0

Local nPosMnemo

Local uValor            
Local uResult            

Local cFilts:=""
Local cFilt1:=""
Local cFilt2:=""
Local cFilt:=""
Local nFilt:= 1  

Local cEmp:=""
Local FilAcum2:=""
Local cNEmp:=""


Local aFilAtu	:={}
Local aFiliais	:={}
Local aUnidades	:={}
Local x:=0,y:=0
Local cCampo
Local nNumLOOP		:= IIf(cPaisLoc=="CHI",500,98) 

Local nImporte		:=Nil
Local nUnidades		:=Nil
Local nNoAplicado	:=Nil
Local cEntidad	    :=""
Local _NDEFRHTB		:= 0
Local bTeste

Local aAstoFijos	:= {}	// Lista de conceptos RG1 de asientos fijos (RG1)
Local aFiltAsFij	:= {}	// Filtros de SRV para obtener conceptos de RG1
Local nPosAstFij	:= 0	// Posición de arreglo aAstoFijos - LEE_AF SIG_AF

DEFAULT aTables	:= {}
DEFAULT aIncid	:= {}
DEFAULT aValFut	:= {}
DEFAULT aAfast	:= {}
DEFAULT aBenef	:= {}
DEFAULT lHabTrace	:= .F.

Private nDiasTraj	:= 0
Private cAnoEmpBus

//Aqui se faz necessario para limpar o Filtro_acum e movli, BUSCA_SUCURSAL a cada formula
cFiltro_acum	:=""  
cFiltro_Movli	:=""
cFilAcum		:=Nil
     
//Inicializar o contador de etiquetas. Esse contador ira verificar se a formula esta em loop.
aEval( __aEtiquetas, { |x| x[3] := 0 } )

If lHabTrace
	lTrace := lHabTrace
Endif

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Execucao dos Itens da Formula                                 ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
bTeste := { || &(__aFormulas[ nItemFor, nY, 6])} 

nForItens := Len(__aFormulas[nItemFor])
While nY <= nForItens
	
	DbSelectArea("SRA")
	nPosEtiq	:= 0
	aValores	:= {}
	cExpFor		:= ""
	uVar		:= ""
	cOper1 		:= AllTrim( __aFormulas[nItemFor, nY, 2, 1] )
	cCpyOper1	:= AllTrim( __aFormulas[nItemFor, nY, 2, 2] )
	cOperador	:= AllTrim( __aFormulas[nItemFor, nY, 3])
	cOper2 		:= AllTrim( __aFormulas[nItemFor, nY, 4, 1])
	cCpyOper2 	:= AllTrim( __aFormulas[ nItemFor,nY, 4, 2] )
	cResult		:= AllTrim( __aFormulas[nItemFor, nY, 5])
	cSeqFor		:= AllTrim( __aFormulas[nItemFor, nY, 1])
	lGravaOK	:= .F.
	nTipoItem	:= __aFormulas[ nItemFor, nY, 7]
	lRound 		:= __aFormulas[nItemFor, nY, 8]
	
	//-- Nao executar a linha - Operadores: OP_BUSCA_PROCESO; OP_BUSCA;
	//-- OP_TRACE_ON e OP_ETIQUETA
	If nTipoItem == 9
		If lTrace
			aAdd( aValores, {cSeqFor, cCpyOper1, cOperador,cCpyOper2, cResult} )
			TraceLog( __aFormulas[nItemFor, nY] )
		EndIf
		
		//-- Seta a variavel Private lSR8I para utilizar na gravacao do campo NUMID
		If cOperador == OP_PAGA_DIA_DER
			lSR8I := .T.
		EndIf
		nY++
		Loop
	EndIf
	
	//-- Controle das Etiquetas - Ir para Etiqueta n
	If nValEtiq > 0
		nY := nValEtiq
		nValEtiq := 0
		Loop
	EndIf
	
	//-- Contar a quantidade de vezes que se passa pela mesma etiqueta - Sair do LOOP e avisar o usuario
	//-- Default 99 execucoes na mesma etiqueta - Mensurar essa quantidade
	nQtdeEtiq := aScan( __aEtiquetas, { |x| x[3] > nNumLOOP } )
	If nQtdeEtiq > 0
		AddMsgLog("")
		AddMsgLog(OemToAnsi( STR0021 ) + " " + AllTrim(cCodFor) + " - " + OemToAnsi( STR0015 )+ " " + SRA->RA_FILIAL + '-' + SRA->RA_MAT + " " + OemToAnsi( STR0022 ) + " " +  __aEtiquetas[nQtdeEtiq,1] ) //"A Formula "  ### "esta processando em Loop na Etiqueta " ###
		nRet := -9
		Exit
	EndIf
	
	If cOperador == OP_SALTA
		nPosEtiq := aScan( __aEtiquetas, { |x| x[1] == cResult .and. x[4] == cCodFor} )
		
		nValEtiq := __aEtiquetas[ nPosEtiq, 2]
		__aEtiquetas[nPosEtiq, 3] += 1
		If lTrace
			aAdd( aValores, {cSeqFor, cCpyOper1, cOperador,cCpyOper2, cResult} )
			TraceLog( __aFormulas[nItemFor, nY] )
		EndIf
		Loop
	ElseIf cOperador == OP_BUSCA
		_NDEFRHTB	:= 0
	EndIf
	
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Tipo Gerado na construcao das formulas - fGetForm             ³
	³0-Nao possui expressao / 1-Aritmeticos / 2-Condicao           ³
	³3-Ativa Trace / 4 - Desativa Trace                            ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	If nTipoItem > 0

		If nTipoItem == 3 .Or. (lHabTrace .And. nY == 1)	// Ativar Trace
			AddMsgLog(OemToansi(STR0008)) 	// "---------------------- TRACE ATIVADO ----------------------"
			TraceLog( __aFormulas[nItemFor, nY], NIL, NIL, .T. )
		EndIf
		
		//-- Foi necessario dividir a montagem do array de resultado para
		//-- o TRACE porque pode-se utilizar a mesma variavel dos operandos
		//-- para receber o resultado.
		If (lTrace .Or. cOperador == OP_TRACE_ON) .and. ;
			(cOperador <> OP_GRABA .And. cOperador <> OP_SUMA_DIAS )
			uOper1 := AllTrim(cCpyOper1)
			If !Empty(uOper1) .and. !(substr(uOper1,1,(Len(uOper1)-2)) == ME_ELEMENTO) .and. cOperador != OP_PUNTO_ENT
				fConvType(@uOper1, aMnemonicos,,aTables)
				uOper1 := &uOper1
			EndIf
			uOper2 := Alltrim(cCpyOper2)
			If !Empty(uOper2) .and. TYPE(cOper2)!= "U" .and.  !(substr(uOper2,1,(Len(uOper2)-2)) == ME_ELEMENTO) .And. ;
				(cOperador != OP_BUSCA_SUCURSAL)

				fConvType(@uOper2, aMnemonicos,,aTables)
				uOper2 := &uOper2
			EndIf
			If cOperador == OP_SIG_AST_FIJO
				uResult := Alltrim(cResult)
			EndIf
			aAdd( aValores, {cSeqFor, If( uOper1==NIL,"",uOper1), cOperador,If( uOper2==NIL, "",uOper2), If( uResult==NIL, "",uResult)} )
		EndIf
		//-- Verificar se os operandos estao no formato Data
		If cOperador == OP_DIAS_HABILES .Or. cOperador == OP_HORAS_HABILES .Or. cOperador == OP_DIAS_FERIADO .Or. cOperador == OP_TIPO_DIA
			If ValType( &cOper1 ) == "C"
				&cOper1 		:= Ctod( &cOper1 )
			ElseIf ValType( &cOper1 ) <> "D"
				&cOper1 		:= Ctod( "//" )
			EndIf
			If ValType( &cOper2 ) == "C"
				&cOper2 		:= Ctod( &cOper2 )
			ElseIf ValType( &cOper2 ) <> "D"
				&cOper2 		:= Ctod( "//" )
			EndIf
			&cResult := 0
		ElseIf cOperador == OP_DIAS_HAB_PROG
			&cResult := 0		
		Endif
		
		uVar := Eval( bTeste )
		
		If cResult == ME_ANO_INI_ACU
			cAnoAcuIni := &(ME_ANO_INI_ACU)
		ElseIf cResult == ME_ANO_FIM_ACU
			cAnoAcuFim := &(ME_ANO_FIM_ACU)
		ElseIf cResult == ME_SUMA_NPGINI
			cSuma_nPgIni := &(ME_SUMA_NPGINI)
		ElseIf cResult == ME_SUMA_NPGFIM
			cSuma_nPgFim := &(ME_SUMA_NPGFIM)
		ElseIf cResult == ME_SUMA_TIPO_NOM
			cSuma_Tipo_Nom := &(ME_SUMA_TIPO_NOM)
		ElseIf cResult == ME_ENTIDAD
			ENTIDAD := &(ME_ENTIDAD)
		EndIf
				
		// Quando estiver os mnemonicos IMPORTE e UNIDADES no campo de resultados devera aplicar o Round de 2, pois
		// esse eh o tamanho que os campos fisicos permitem a gravacao. Assim nao teremos diferencas de centavos.
		// Ajuste qdo o busca_tabla não retorno nenhuma linha
		If lRound
			If AllTrim(cResult) == ME_IMPORTE
			    nImporte	:=&(ME_IMPORTE)	
			    IMPORTE := iif (Valtype(nImporte)=="N",ROUND(nImporte,2),0)
			ElseIf AllTrim(cResult) == ME_UNIDADES
				nUnidades	:= &(ME_UNIDADES)
				UNIDADES := iif (Valtype(nUnidades)=="N",ROUND(nUnidades,2),0)
			ElseIf AllTrim(cResult) == ME_NO_APLICADO
				nNoAplicado	:=	&(ME_NO_APLICADO)
				NO_APLICADO := iif (Valtype(nNoAplicado)=="N",ROUND(nNoAplicado,2),0)
			EndIf
		EndIf
		
		If nTipoItem == 2	// Enviar para a Etiqueta
			If lTrace
				If valtype(aValores[1,2]) == "C"
					nTamCpo := (Len(alltrim(aValores[1,2]))-2)
					if substr(aValores[1,2],1,nTamCpo) == ME_ELEMENTO
						nPosArr := Val(Substr(aValores[1,2],(nTamCpo+1),2))+4
						aValores[1,2] := If(_NDEFRHTB>0, aDefTab[_NDEFRHTB,nPosArr], 0)
					endif
				Endif
				if valtype(aValores[1,4]) == "C"
					nTamCpo := (Len(alltrim(aValores[1,4]))-2)
					if substr(aValores[1,4],1,nTamCpo) == ME_ELEMENTO
						nPosArr := Val(Substr(aValores[1,4],(nTamCpo+1),2))+4
						aValores[1,4] := If(_NDEFRHTB>0, aDefTab[_NDEFRHTB,nPosArr], 0)
					endif
				endif
			endif
			
			If uVar
				nPosEtiq := aScan( __aEtiquetas, { |x| x[1] == cResult .and. x[4] == cCodFor } )
				If nPosEtiq > 0
					nValEtiq := __aEtiquetas[nPosEtiq, 2]
					__aEtiquetas[nPosEtiq, 3] += 1
				EndIf
				If lTrace
					aValores[1,5] := ".T."
					TraceLog( __aFormulas[nItemFor, nY], aValores)
				EndIf
			Else
				If lTrace
					aValores[1,5] := ".F."
					TraceLog( __aFormulas[nItemFor, nY], aValores)
				EndIf
				nY++
				Loop
			EndIf
			
		//-- Quando for OPERADOR LEE-TRAY e retornar vazio o array enviar para o item apos SIG-TRAY
		ElseIf cOperador == OP_LEE_TRAY
			If Empty(aTrajLab)
				nPosEtiq := aScan( __aEtiquetas, { |x| x[1] == OP_SIG_TRAY .and. x[4] == cCodFor } )
				If nPosEtiq > 0
					nValEtiq := __aEtiquetas[nPosEtiq, 2] + 1
					__aEtiquetas[nPosEtiq, 3] += 1
				EndIf
			Else
				//-- Eh necessario armazenar as datas da leitura para utilizar nos
				//-- Operadores Especiais (DIAS-TRAY-SIG, GEN-MOV)
				dDtIniTraj := cOper1
				If ValType(cOper1) == "C"
					If At( "/", cOper1 ) > 0
						dDtIniTraj := Ctod(cOper1)
					Else
						dDtIniTraj := &cOper1
					EndIf
				EndIf
				If Empty(dDtIniTraj)
					dDtIniTraj := Dtoc(RCH->RCH_DTINI)
				EndIf
				
				//Operador 2
				dDtFimTraj := cOper2
				If ValType(cOper1) == "C"
					If At( "/", cOper2 ) > 0
						dDtFimTraj := Ctod(cOper2)
					Else
						dDtFimTraj := &cOper2
					EndIf
				EndIf
				If Empty(dDtFimTraj)
					dDtFimTraj := Dtoc(RCH->RCH_DTFIM)
				EndIf
				nPosTrajLab := 1
			EndIf
		ElseIf cOperador == OP_LEE_DEPENDIENTE
			If Empty(aDependiente)
				nPosEtiq := aScan( __aEtiquetas, { |x| x[1] == OP_SIG_DEPENDIENTE .And. x[4] == cCodFor .and. x[2] >= ny } )
				If nPosEtiq > 0
					nValEtiq := __aEtiquetas[nPosEtiq, 2] + 1
					__aEtiquetas[nPosEtiq, 3] += 1
				EndIf
			Else
				nPosDepend := 1
			EndIf
		ElseIf cOperador == OP_SIG_TRAY
			If uVar <= Len(aTrajLab)
				nPosEtiq := aScan( __aEtiquetas, { |x| x[1] == OP_LEE_TRAY .and. x[4] == cCodFor } )
				If nPosEtiq > 0
					nValEtiq := __aEtiquetas[nPosEtiq, 2] + 1
					__aEtiquetas[nPosEtiq, 3] += 1
				EndIf
			EndIf
			
			//-- Mnemonico Reservado GEN_MOV que determina que deverá ser gerado uma verba no Movimento da Folha
			If cOper2 == ME_GEN_MOV
				fGravaForm(aTables, cPD, lSR8I)
				Importe 	:= 0
				Unidades 	:= 0
				No_Aplicado := 0
			EndIf
		ElseIf cOperador == OP_SIG_DEPENDIENTE .Or. cOperador == OP_PRIMER_REG_DEP .Or. cOperador == OP_ULTIMO_REG_DEP
			If uVar <= Len(aDependiente)
				nPosEtiq := aScan( __aEtiquetas, { |x| x[1] == OP_LEE_DEPENDIENTE .and. x[4] == cCodFor } )
				If nPosEtiq > 0
					nValEtiq := __aEtiquetas[nPosEtiq, 2] + 1
					__aEtiquetas[nPosEtiq, 3] += 1

					If lTrace 
						aAdd( aValores, {"", "", " "," ", " "} )
						TraceLog( __aFormulas[nItemFor, nY], aValores)
                    Endif
				EndIf
			EndIf
		ElseIf cOperador == OP_LEE_AST_FIJO
			If Empty(aAstoFijos)
				// Si no se encontraron asientos fijos, salta a la secuencua posterior al operador SIG_AF
				nPosEtiq := aScan( __aEtiquetas, { |x| x[1] == OP_SIG_AST_FIJO .And. x[4] == cCodFor .and. x[2] >= ny } )
				If nPosEtiq > 0
					nValEtiq := __aEtiquetas[nPosEtiq, 2] + 1
					__aEtiquetas[nPosEtiq, 3] += 1
				EndIf
			Else
				// Si se encuentran asientos fijos, se ubican en la posición 1
				nPosAstFij := 1
			EndIf
		ElseIf cOperador == OP_SIG_AST_FIJO
			If uVar <= Len(aAstoFijos)
				nPosEtiq := aScan( __aEtiquetas, { |x| x[1] == OP_LEE_AST_FIJO .and. x[4] == cCodFor } )
				If nPosEtiq > 0
					nValEtiq := __aEtiquetas[nPosEtiq, 2] + 1
					__aEtiquetas[nPosEtiq, 3] += 1
					If lTrace 
						aAdd( aValores, {"", "", " "," ", " "} )
						TraceLog( __aFormulas[nItemFor, nY], aValores)
					Endif
				EndIf
			EndIf
		EndIf
		If cOperador == OP_SIG_TRAY .Or. cOperador == OP_LEE_TRAY .Or. cOperador == OP_PRIMER_REG_TRAY .Or. cOperador == OP_ULTIMO_REG_TRAY
			
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³Carga dos Mnemonicos de Trajetora Laboral                     ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			If nPosTrajLab > 0 .and. nPosTrajLab <= Len(aTrajLab)
				
				nPosMnemo:= aScan( aMnemonicos, { |x,y| x[3] == "RCP" } )
				If nPosMnemo > 0
					While nPosMnemo > 0
						nPosAlias := aScan( aTables, { |x| x[1] = aMnemonicos[ nPosMnemo, 3 ] } )
						If nPosAlias > 0
							nPosField := GdFieldPos( aMnemonicos[ nPosMnemo, 4 ] , aTables[nPosAlias, _HEADER_] )
							If nPosField > 0
								uValor := aTrajLab[nPosTrajLab, nPosField]
								If aTables[nPosAlias, _HEADER_, nPosfield, __AHEADER_TYPE__] == "D" .AND.;
									ValType(uValor) == "C"
									uValor := StoD(uValor)
								EndIf
								&(aMnemonicos[ nPosMnemo, 01 ]) := uValor
							EndIf
						EndIf
						nPosMnemo := aScan( aMnemonicos, { |x| x[3] == "RCP" }, nPosMnemo+1 )
					EndDo
				EndIf
			EndIf
		EndIf
		
		If cOperador == OP_SIG_DEPENDIENTE .Or. cOperador == OP_LEE_DEPENDIENTE .Or. cOperador == OP_PRIMER_REG_DEP .Or. cOperador == OP_ULTIMO_REG_DEP
			
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³Carga dos Mnemonicos de Trajetora Laboral                     ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
			If nPosDepend > 0 .and. nPosDepend <= Len(aDependiente)
				
				nPosMnemo:= aScan( aMnemonicos, { |x,y| x[3] == "SRB" } )
				If nPosMnemo > 0
					While nPosMnemo > 0
						nPosAlias := aScan( aTables, { |x| x[1] = aMnemonicos[ nPosMnemo, 3 ] } )
						If nPosAlias > 0
							nPosField := GdFieldPos( aMnemonicos[ nPosMnemo, 4 ] , aTables[nPosAlias, _HEADER_] )
							If nPosField > 0
								uValor := aDependiente[nPosDepend, nPosField]
								If aTables[nPosAlias, _HEADER_, nPosfield, __AHEADER_TYPE__] == "D" .AND.;
									ValType(uValor) == "C"
									uValor := StoD(uValor)
								EndIf
								&(aMnemonicos[ nPosMnemo, 01 ]) := uValor
							EndIf
						EndIf
						nPosMnemo := aScan( aMnemonicos, { |x| x[3] == "SRB" }, nPosMnemo+1 )
					EndDo
				EndIf
			EndIf
		EndIf
		
		//Carga los mnemónicos de Asientos Fijos
		If cOperador == OP_LEE_AST_FIJO .Or. cOperador == OP_SIG_AST_FIJO .Or. cOperador == OP_PRIMER_REG_AF .Or. cOperador == OP_ULTIMO_REG_AF
			If nPosAstFij > 0 .and. nPosAstFij <= Len(aAstoFijos)
				nPosMnemo:= aScan( aMnemonicos, { |x,y| x[3] == "RG1" } )
				If nPosMnemo > 0
					While nPosMnemo > 0
						nPosAlias := aScan( aTables, { |x| x[1] = aMnemonicos[ nPosMnemo, 3 ] } )
						If nPosAlias > 0
							nPosField := GdFieldPos( aMnemonicos[ nPosMnemo, 4 ] , aTables[nPosAlias, _HEADER_] )
							If nPosField > 0
								uValor := aAstoFijos[nPosAstFij, nPosField]
								If aTables[nPosAlias, _HEADER_, nPosfield, __AHEADER_TYPE__] == "D" .And. ValType(uValor) == "C"
									uValor := StoD(uValor)
								EndIf
								&(aMnemonicos[ nPosMnemo, 01 ]) := uValor
							EndIf
						EndIf
						nPosMnemo := aScan( aMnemonicos, { |x| x[3] == "RG1" }, nPosMnemo + 1 )
					EndDo
				EndIf
			EndIf
		EndIf

		//-- Atualizar a variavel de Resultado apos a execucao para o Trace
		If lTrace .and. nValEtiq == 0 .and. ;
			(cOperador <> OP_GRABA .AND. cOperador <> OP_SUMA_DIAS)
			uResult := cResult
			If !Empty( uResult )
				uResult := &uResult
			EndIf
			aValores[1,5] := uResult
			
			// Tratamento para Dias Trajetorias porque nao se executa o mnemonico reservado
			If AllTrim(cCpyOper1) == ME_DIAS_TRAY_SIG
				uOper1 := Str(nDiasTraj,22,6)
				aValores[1,2] := uOper1
			EndIf
			If AllTrim(cCpyOper2) == ME_DIAS_TRAY_SIG
				uOper2 := Str(nDiasTraj,22,6)
				aValores[1,4] := uOper2
			EndIf
			if valtype(aValores[1,2]) == "C"
				nTamCpo := (Len(alltrim(aValores[1,2]))-2)
				if substr(aValores[1,2],1,nTamCpo) == ME_ELEMENTO
					nPosArr := Val(Substr(aValores[1,2],(nTamCpo+1),2))+4
					aValores[1,2] := If(_NDEFRHTB>0, aDefTab[_NDEFRHTB,nPosArr], 0)
				endif
			endif
			
			if valtype(aValores[1,4]) == "C"
				nTamCpo := (Len(alltrim(aValores[1,4]))-2)
				if substr(aValores[1,4],1,nTamCpo) == ME_ELEMENTO
					nPosArr := Val(Substr(aValores[1,4],(nTamCpo+1),2))+4
					aValores[1,4] := If(_NDEFRHTB>0, aDefTab[_NDEFRHTB,nPosArr], 0)
				endif
			endif
			
			TraceLog( __aFormulas[nItemFor, nY], aValores)
		ElseIf nValEtiq > 0
			Loop
		EndIf
		
		//-- Desabilitar o TRACE e enviar mensagem ao LOG.
		If nTipoItem == 4	// Desativar Trace
			AddMsgLog(OemToansi(STR0009)) 	// "---------------------- TRACE DESATIVADO ----------------------"
		EndIf
	EndIf
	
	//-- Interpretar Operadores em Tempo de Execucao
	If cOperador == OP_SUMA_DIAS
		cOper1 := If( Empty(cOper1), '1', cOper1 )
		cOper2 := If( Empty(cOper2), cOper1, cOper2 )
		uOper1 := &cOper1
		uOper2 := &cOper2
		
		uOper1 := If( ValType( uOper1 ) == "C", Val(uOper1), uOper1 )
		uOper2 := If( ValType( uOper2 ) == "C", Val(uOper2), uOper2 )
		If uOper1 < 1 .Or. uOper1 > 7
			uOper1 := 1
		EndIf
		If uOper2 < 1 .or. uOper2 > 7
			uOper2 := uOper1
		EndIf
		&cResult := 0
		For nZ := uOper1 To uOper2
			cVar := '{ || __nPosD' + StrZero(nZ,1) + '}'
			cExpFor := "{ || aIncid["+StrZero(Eval(&cVar), 2)+"] }"
			&cResult += Eval(&cExpFor)
		Next nZ
		
		If lTrace
			uOper1 := AllTrim(cCpyOper1)
			If !Empty(uOper1)
				uOper1 := &uOper1
			EndIf
			uOper2 := cCpyOper2
			If !Empty(uOper2)
				uOper2 := &uOper2
			EndIf
			uResult := cResult
			If !Empty( uResult )
				uResult := &uResult
			EndIf
			aAdd( aValores, {cSeqFor, If( Empty(uOper1), "",uOper1), cOperador,If( Empty(uOper2), "",uOper2), If( Empty(uResult), "",uResult)} )
			TraceLog( __aFormulas[nItemFor, nY], aValores)
		EndIf
	ElseIf cOperador == OP_GRABA
		If lHabGrab	// Esse parametro pertence a janela do calculo, definido pelo usuario
			
			cPrim := Substr(Alltrim(cOper2),1,1)
			cUlti := Substr(Alltrim(cOper2),len(Alltrim(cOper2)),1)
			If (cPrim == '"' .or. cPrim == "'") .and. (cUlti == '"' .or. cUlti == "'")
				cOper2 := substr(alltrim(cOper2),2,len(alltrim(cOper2))-2)
			EndIf
			
			cTab := cOper2
			cTabAux := If( cTab == "SR7/SR3", "SR7", cTab )
			DbSelectArea(cTabAux)
			If cTab $ "SRA"
				lGravaOK := .T.
			ElseIf (lGravaOK := (lLeeIncid .and. cTab == "RGB" .and. !Empty(aIncid)))
				DbGoTo(aIncid[Len(aIncid)])
			ElseIf (cTab == "SRK" .And. lLeeValFut)
				lGravaOK := .T.				
			ElseIf (lGravaOK := (lLeeAcumul .and. cTab == "RG7"))
				lGravaOK := .T.
			ElseIf cTab $ "RCP"
				lGravaOK := .T.
			ElseIf ( cTab $ "SR7/SR3" )
				lGravaOK := .T.
			ElseIf cTab $ "SR9"
				lGravaOK := .T.
			EndIf
			If lGravaOK
				lResult := fGravaTab(cTab, aTables, @cErro)
				if lTrace
					aAdd( aValores, {cSeqFor, "", "","", if(lResult, STR0023, STR0024 + cErro)} ) //"Gravacao efetuada."##"Gravacao nao efetuada - "
					TraceLog( __aFormulas[nItemFor, nY], aValores )
				endif
			EndIf
		Else
			// Atualizar as variaveis de Memoria do cadastro //
			If lFieldExec
				nMnemos := Len( aMnemonicos )
				For nMnemo := 1 To nMnemos
					nPosNew := aScan( aMnemonicos, { |x| x[3] ==  cTableAlias }, nMnemo )
					If nPosNew > 0
						nMnemo := nPosNew
						uVar := 'M->' + aMnemonicos[ nMnemo, 04 ]
						
						nPosAlias := aScan( aTables, { |x| x[1] = aMnemonicos[ nMnemo, 3 ] } )
						If aMnemonicos[ nMnemo, 7 ] == "D" .and. ValType(&(aMnemonicos[ nMnemo, 01 ])) == "C"
							&(uVar) := CTOD(&(aMnemonicos[ nMnemo, 01 ]))
						Else
							&(uVar) := &(aMnemonicos[ nMnemo, 01 ])
						EndIf
					Else
						nMnemo := nMnemos
					EndIf
				Next nMnemo
			EndIf
			
		EndIf
	//-- Seta o Codigo do Processo a utilizar nos Operadores de Acumuladores 
	ElseIf cOperador == OP_BUSCA_PROCESO
		cPrim := Substr(Alltrim(cOper2),1,1)
		cUlti := Substr(Alltrim(cOper2),len(Alltrim(cOper2)),1)
		If (cPrim == '"' .or. cPrim == "'") .and. (cUlti == '"' .or. cUlti == "'")
			cOper2 := substr(alltrim(cOper2),2,len(alltrim(cOper2))-2)
		EndIf
		
		cOpBusProces := cOper2
		If Empty(cOpBusProces)
			cOpBusProces := SRA->RA_PROCES
		EndIf
	ElseIf cOperador == OP_BUSCA_ANO_EMPRESA
		//Caso seja utilizado Mnemonico, valida o tipo (só poderá ser númerico)
		If ( ( nPosMnemo := aScan( aMnemonico, { |x|, x[1] == cOper1 } ) ) > 0 )
			If ( aMnemonico[ nPosMnemo, 2 ] == "R" .or. aMnemonico[ nPosMnemo, 2 ] == "N" )
				If ( SubStr( aMnemonico[ nPosMnemo, 1 ], 1,1) == "N" )
					cAnoEmpBus := &cOper1
				EndIf
			EndIf
		Else
			cAnoEmpBus := cOper1
		EndIf
		
		If Empty(cAnoEmpBus)
			cAnoEmpBus := RCH->RCH_ANO
		EndIf
	ElseIf cOperador == OP_BUSCA_SUCURSAL
		cFilAcum := cOper2
				
		If fIsCorpManage() .and. !empty(cOper1)
			cFilAcum:=""

			if ('1') $ cOper1 
				cEmp	:= len(FWSM0Layout(cEmpAnt,1))  						//Tamanho do layout da empresa
			else
				cEmp   := len(FWSM0Layout(cEmpAnt,1) + FWSM0Layout(cEmpAnt,2)) //Tamanho do Layout Empresa + unidade de negócio
			EndIf

			cFilAcum2:=	IIf (empty(cOper2),FWCodFil(),cOper2) 					//se 2.a expr estiver vazia
	
			While len(cFilAcum2) > 0											//fazer varredura entre virgulas de empresas
				cFilVal := alltrim(if(at(",",cFilAcum2) > 0, substr(cFilAcum2, 1, at(",",cFilAcum2)-1), cFilAcum2))
				nInic:= IIF( LEFT(cFilval,1) $ ("'") .or. LEFT(cFilval,1) $ ('"'),2,1)
				cNEmp:= SUBSTRING(cFilVal,nInic,cEmp)							//pegando a empresa ou unidade de negocio do oper2
				aFiliais:=FWAllFilial(,,,.F.)									//retorna todas a filiais do Grupo de Empresas Atual
			
				For x:=1 to len(aFiliais)
					if (SUBSTRING(aFiliais[x],1,cEmp) == cNEmp)
						IIF (empty(cFilAcum), cFilAcum:= "'"+aFiliais[x], cFilAcum:= cFilAcum+","+aFiliais[x])
					Endif
				Next

				cFilAcum2 := If(at(",", cFilAcum2)==0, "", substr(cFilAcum2, at(",", cFilAcum2) + 1))
			EndDo
			IIF (len(cFilAcum)>0,cFilAcum:=cFilAcum+"'",)
		EndIf
	ElseIf cOperador == OP_GEN_MOV
		fGenMov(aTables, cPD, lSR8I)
	EndIf
	nY++
EndDo
bTeste := Nil
		
Return(nRet)

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³fGravaForm	³ Autor ³Mauricio Takakura     ³ Data ³06/11/2007³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Funcao para gravacao das verbas do processo          	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL															 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³SIGAGPE     												 ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function fGravaForm(aTables, cPD, lSR8I, lIncidencia, lPrestamo, lAusencia, aValores)

Local cField
Local aRet

Local nX
Local nPosField		:= 0
Local nPosTable           
Local nPosAlias
Local lFerRes		:= .F.
Local cFuncNam := FunName()

DEFAULT aTables     := {}
DEFAULT lSR8I	    := .F.
DEFAULT lIncidencia := .F.
DEFAULT lPrestamo   := .F.
DEFAULT lAusencia   := .F.
DEFAULT aValores    := {}

//Nas Ferias ou Rescisao a Data de Referencia deve ser de acordo com a data do calculo e nao da origem do lancamento
lFerRes := cFuncNam $ "GPEM031*GPEM032*GPEM042*GPEM043" .or.  (cPaisLoc=="MEX" .and. cFuncNam == "GPEM040B")

If (Importe == 0 .And. Unidades == 0 .And. No_Aplicado == 0) .Or. lFieldExec
	Return
EndIf

If __nSRCTab == 0
	Return
EndIf                               

// Realizar a gravacao das informacoes //
Begin Transaction
	RecLock("SRC",.T.)
	For nX = 1 To Len( aTables[__nSRCTab, 2] )
		uValor := ""
		cField := aTables[__nSRCTab, 2, nX, __AHEADER_FIELD__]
		aRet   := {}
		If cField == "RC_VALOR"
			uValor := Round(Importe,2)
		ElseIf cField == "RC_HORAS"
			uValor := Round(Unidades,2)
		ElseIf cField == "RC_VNAOAPL"
			uValor := Round(No_Aplicado,2)
		ElseIf cField == "RC_PD"
			uValor := cPD
		ElseIf cField == "RC_PERIODO"
			uValor := cPeriodo
		ElseIf cField == "RC_ROTEIR"
			uValor := cRoteiro
		ElseIf cField == "RC_ENTIDAD"
			IF ValType( Entidad)  == "C"
				uValor := Entidad
			EndIf
		ElseIf cField == "RC_SEMANA"
			If lIncidencia .and. ( __nRGBTab > 0 )
				If __nRGBSem > 0
		    		if !Empty(aValores[__nRGBSem])
						uValor := aValores[__nRGBSem]
					Else
						uValor := cNumPag
					Endif
				Endif
			Else
				uValor := cNumPag			
			Endif
		ElseIf cField == "RC_DATA"
			uValor := RCH->RCH_DTPAGO
		ElseIf cField == "RC_NUMID"
			If lSR8I
				uValor := "SR8I"

				// Verificar se existe a verba em tipos de ausencias -> Quando nao existir
				// nao devera gerar o registro para que não gere problemas no fechamento
//				aAdd( aLogFunc, { '01', cPD,  } )

			Else
				If lPrestamo .and. ( __nSRKTab > 0 )
					nPosField := __nSRKNuId
				ElseIf lAusencia .and. ( __nSR8Tab > 0 )
					nPosField := __nSR8NuId
				ElseIf lIncidencia .and. ( __nRGBTab > 0 )
					nPosField := __nRGBNuId
				ElseIf lLeeLanFix .and. ( __nRG1Tab > 0)
					nPosField := __nRG1NuId
				endif
				If nPosField > 0 .and. len(aValores) > 0
	    			if !Empty(aValores[nPosField])
						uValor := aValores[nPosField]
					endif
				Endif
			EndIf
		ElseIf cField == "RC_SEQ"
		
			//-- Dificilmente o numero de lancamentos por verba ultrapassara 9 itens. Portanto, nesta fase
			//-- nao sera incluido o controle por data de referencia quando ultrapassar 10 itens
			//-- Caso essa quantidade venha a ultrapassar, incluir a sequencia de datas, iniciando pela data
			//-- de inicio do periodo e a cada item, adicionar 1 dia.
			dDtRefSRC := DTOS(SRC->RC_DTREF)
			nPosSeq := aScan( __aSeqPd, {|x,y| x[1]+x[2] = cPD + dDtRefSRC} )
			If nPosSeq > 0
				uValor := Strzero( __aSeqPd[nPosSeq, 3]+1, 1)
				__aSeqPd[nPosSeq, 3] := Val(uValor)
			Else
				uValor := '1'
				aAdd( __aSeqPd, { cPD, dDtRefSRC, Val(uValor) } )
			EndIf
		ElseIf cField == "RC_POSTO" 
			uValor := SRA->RA_POSTO 
			If lIncidencia .and. ( __nRGBTab > 0 )
				If __nRGBPos > 0
		    		if !Empty(aValores[__nRGBPos])
						uValor := aValores[__nRGBPos]
					endif
				EndIf
			Endif
		ElseIf cField == "RC_DEPTO"
			uValor := SRA->RA_DEPTO
			If lIncidencia .and. ( __nRGBTab > 0 )
				If __nRGBDept > 0 .And. !Empty(aValores[__nRGBDept])
					uValor := aValores[__nRGBDept]
				EndIf
			Endif    
		ElseIf !lItemClvl .and. (cField =="RC_ITEM" .or. cField == "RC_CLVL") 
			Loop			
		Else
			lAchou 		:= HMGet(oHash_Tab, cField, aRet) 
			nPosField 	:= 0
			If lAchou
				uValor := &(aRet[1,1])
			Else
				uValor := aTables[__nSRCTab, 5, nX]
				If lIncidencia
					If ( __nRGBTab > 0 )
						If cField == "RC_CC"
							nPosField := __nRGBCc
						ElseIf cField == "RC_TIPO3"
							nPosField := __nRGB3Tp
						ElseIf cField == "RC_TIPO2"
							nPosField := __nRGB2Tp
						ElseIf cField == "RC_TIPO1"
							nPosField := __nRGB1Tp
						ElseIf cField == "RC_QTDSEM"
							nPosField := __nRGBQtS
						ElseIf cField == "RC_PARCELA"
							nPosField := __nRGBParc
						ElseIf lItemClvl .And. cField == "RC_ITEM"
							nPosField := GdFieldPos( "RGB_ITEM" , aTables[__nRGBTab, _HEADER_] ) 
						ElseIf lItemClvl .And. cField == "RC_CLVL"
							nPosField := GdFieldPos( "RGB_CLVL" ,aTables[__nRGBTab, _HEADER_] )
						EndIf
						If nPosField > 0
							// Se o campo da RGB estiver em branco ira considerar o Inicializador 
							// padrao da tabela SRC
		    				If !Empty(aValores[nPosField])
								uValor := aValores[nPosField]
							Endif
						Endif
					EndIf
				Else
					If cField == "RC_TIPO2"
						uValor := "C"
					EndIf
				EndIf
			EndIf
		EndIf
		If cField == "RC_DTREF"			
			If lFerRes //Se ferias ou rescisao, grava como chave campo RHI_DTINI(ferias)ou RG_DTPAGO(rescisao)
				uValor:= dDataKey
			ElseIf Empty(uValor) .Or. ValType(uValor) == "C"
				uValor := RCH->RCH_DTFIM
			EndIf
			// Quando for Valores futuros devera considerar a data do emprestimo
			// Isso porque podera existir varios emprestimos e caso nao tenha esse 
			// controle esta gerando erro fatal
			If lPrestamo .And. !lFerRes
				If ( __nSRKTab > 0 )
					If __nSRKDtM > 0
		  				If !Empty(aValores[__nSRKDtM])
							uValor := STOD(aValores[__nSRKDtM])
						Endif
					EndIf
				EndIf
			EndIf
			
			if lIncidencia .And. !lFerRes
				If( __nRGBTab > 0 )
					If __nRGBDtR > 0
			    		if !Empty(aValores[__nRGBDtR])
							uValor := SToD(aValores[__nRGBDtR])
						endif
					Endif   				
				EndIf
			EndIf	
			
		EndIf
		uType := ValType( uValor )
		If uType <> aTables[__nSRCTab, _HEADER_, nX,__AHEADER_TYPE__]
			uValor := GetValType( aTables[__nSRCTab, _HEADER_, nX,  __AHEADER_TYPE__] )
			AddMsgLog( OemToAnsi(STR0018) + ' ' + aTables[__nSRCTab, _HEADER_, nX, __AHEADER_FIELD__] + ' ' + OemToAnsi(STR0019)  ) // "O Conteudo a ser gravado no campo "  ### "possui o tipo diferente da tabela."
			AddMsgLog( OemToAnsi(STR0020) + ' ' + AllToChar(uValor) ) // "Foi gravado no campo o valor: " ### 
		EndIf
		&cField := uValor
	Next nX  
	RC_FILIAL := SRA->RA_FILIAL
	MsUnlock()

	Importe     := 0
	Unidades    := 0 
	No_Aplicado := 0
	Entidad := ""
End Transaction

/*
//Caso ocorrer algum erro de banco e a transacao for
//abortada entao verifica a necessidade de disarmar a transacao
If InTransact()
	DisarmTransaction()
EndIf
*/

Return

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³fGravaTab	³ Autor ³Mauricio Takakura     ³ Data ³09/11/2007³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Funcao para inclusao ou alteracao nas tabelas definidas	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL															 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³SIGAGPE     												 ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function fGravaTab(cTable,;	// Tabela a ser gravado
						  aTables,;	// Array com as estruturas das tabelas
						  cErro)    // Mensagem que sera apresentada no log (qdo trace ativado) se nao conseguir alterar/incluir registro
Local aArea			:= GetArea()
Local aNotFields	:= {}
Local aChgFields	:= {}
Local aSRKHeader    := {}
Local aSRKCols    	:= {}
Local aMnemResult	:= {}
Local aAuxTables	:= {}

Local lInclui
Local lChg			:= .F.
Local lExist		:= .F.

Local cAliasTab	    := ""
Local cChave1		:= ""
Local cAux          := ""
Local cAuxPer       := ""
Local cAuxNumPag    := ""
Local cAuxRot       := ""
Local cAuxPD        := ""
Local cAuxDescPd	:= ""
Local cSeq          := ""
Local cAuxIni       := ""
Local cAuxFim       := ""
Local cFilFun       := ""
Local cMatr         := ""
Local cField        := ""
Local cType			:= ""
Local cAuxData		:= ""
Local cAuxTipo		:= ""
Local cAuxTipoPg	:= "" 
Local cAuxCatFun	:= ""
Local cAuxPosto		:= ""
Local cAuxDepto		:= ""
Local cAuxCargo		:= ""
Local cAuxDscCar	:= ""
Local cAuxFuncao	:= ""
Local cAuxDscFun	:= ""

Local cAuxTable		:= ""

Local nPosTable     := 0
Local nChave1       := 0
Local nParcela      := 0
Local nValor        := 0
Local nHoras        := 0
Local nField        := 0
Local nX            := 0
Local nY			:= 0
Local nPosField     := 0
Local nPosChgField  := 0
Local nCont			:= 0

Local uValor

Private n			:= 1
Private nUsado		:= 0       

DEFAULT cErro		:= ""

If Empty(cTable) .Or. Empty(aTables)
	Return .F. 
EndIf

If ( cTable $ "SR7/SR3" )

	cAuxTable := cTable

	For nCont := 1 To 2
				
		If ( nCont == 1 )
			cTable := "SR7"
			nPosTable := __nSR7Tab
		Else
			cTable := "SR3"
			nPosTable := __nSR3Tab
		EndIf
	
		If nPosTable == 0
			Return .F.
		EndIf
	
		//Separar somente os mnemonicos do Tipo Arquivo 
		//e que estão campo Resultado para a gravacao
		For nX = 1 To Len( __aFormulas )
			For nY = 1 To Len( __aFormulas[nX] )
				uValor := __aFormulas[nX, nY, 5]  // Campo Resultado
				If !Empty(Alltrim(uValor))
					nChave1 := aScan( aMnemonicos, { |x,y| AllTrim(x[3]) == AllTrim(cTable) .and. AllTrim(x[1]) == AllTrim(uValor) } )
					If nChave1 > 0
						aAdd( aMnemResult, aClone(aMnemonicos[nChave1]) )
					EndIf
				EndIf
			Next nY
		Next nX
	
	Next
	
	If ( cTable == "SR3" )
		nChave1 := aScan( aMnemonicos, { |x,y| AllTrim(x[3]) == "SR7" .and. AllTrim(x[4]) == "R7_DATA" } )
		If nChave1 > 0
			aAdd( aMnemResult, aClone(aMnemonicos[nChave1]) )
		EndIf	
	EndIf	
	
	cTable := cAuxTable

Else

	nPosTable := aScan( aTables, { |x| x[1] = cTable } )
	If nPosTable == 0
		Return .F.
	EndIf

	//Separar somente os mnemonicos do Tipo Arquivo 
	//e que estão campo Resultado para a gravacao
	For nX = 1 To Len( __aFormulas )
		For nY = 1 To Len( __aFormulas[nX] )
			uValor := __aFormulas[nX, nY, 5]  // Campo Resultado
			If !Empty(Alltrim(uValor))
				nChave1 := aScan( aMnemonicos, { |x,y| AllTrim(x[3]) == AllTrim(cTable) .and. AllTrim(x[1]) == AllTrim(uValor) } )
				If nChave1 > 0
					aAdd( aMnemResult, aClone(aMnemonicos[nChave1]) )
				EndIf
			EndIf
		Next nY
	Next nX
	
	If ( cTable == "SR3" )
		nChave1 := aScan( aMnemonicos, { |x,y| AllTrim(x[3]) == "SR7" .and. AllTrim(x[4]) == "R7_DATA" } )
		If nChave1 > 0
			aAdd( aMnemResult, aClone(aMnemonicos[nChave1]) )
		EndIf	
	EndIf

EndIf
uValor := NIL
nChave := 0
nY	   := 1

// Definir os campos chaves que nao podem ser alterados
If cTable == "SRA"
	cAuxTable := cTable
	aAdd( aNotFields, {'RA_FILIAL', 'RA_MAT', 'RA_PROCES', 'RA_DEPTO', 'RA_CODFUNC', 'RA_DEMISSA'} )
	IF Empty( __afHist__ )
		__afHist__	:= fHistOper()
	EndIF                                                                   
	
	For nx := 1 to Len(__afHist__)
		If (nChave1 := aScan( aMnemResult, { |x,y| AllTrim(x[4]) == __afHist__[nx]} )) > 0
			cAux := &(aMnemResult[ nChave1, 1])
			fGravaSr9( __afHist__[nx] , cAux , &("SRA->"+__afHist__[nx]))
		Endif
	Next
	lInclui := .F.                                                                                  
ElseIf cTable == "RCP"            
	aChgFields := {}                              
	
	//-- Tratamento para Data da movimentacao
	if (nChave1 := aScan( aMnemResult, { |x,y| AllTrim(x[4]) == "RCP_DTMOV" } )) > 0
		cAux := DTOS(&(aMnemResult[ nChave1, 1]))
	endif
	If Empty(cAux)       	
		cAux := DTOS(dDataBase)
	EndIf
	aAdd( aChgFields, { "RCP_DTMOV", STOD(cAux) } )
	cChave1 += cAux

	//-- Tratamento para Tipo de movimentacao IMSS
	if (nChave1 := aScan( aMnemResult, { |x,y| AllTrim(x[4]) == "RCP_TPMOV" } )) > 0
		cAux := &(aMnemResult[ nChave1, 1])
	else          
		cErro := STR0025 //"Tipo de Movimento IMSS nao informado"
		Return .F.
	EndIf
	aAdd( aChgFields, { "RCP_TPMOV", cAux } ) 
	cChave1 += cAux
	
	RCP->( DbSetOrder( nCalRcpOrd ) )
	if RCP->( DbSeek( SRA->RA_FILIAL + SRA->RA_MAT + cChave1, .F. ) )
		lInclui := .F.
		aAdd( aNotFields, { "RCP_FILIAL", "RCP_MAT", "RCP_DEPART", "RCP_PUESTO", "RCP_PLAZA", "RCP_DTMOV", "RCP_TPMOV" } )

		For nField := 1 to  len(aTables[nPosTable, _HEADER_])                    
			cField := AllTrim(aTables[nPosTable, _HEADER_, nField, __AHEADER_FIELD__])
			if aScan( aNotFields[1], { |x| x == cField } ) > 0
				Loop
			elseif (nChave1 := aScan( aMnemResult, { |x,y| AllTrim(x[4]) == cField } )) > 0
				cAux := &(aMnemResult[ nChave1, 1])
				if !(&("RCP->" + cField) == cAux)
					lChg := .T.
					exit
				endif
			endif
		next nCampo     
		if lChg
			aAdd( aChgFields, { "RCP_DTIMSS", STOD("") } )
			aAdd( aChgFields, { "RCP_HRIMSS", "" } )
		endif
	else              
		lInclui := .T.
	endif
	
ElseIf cTable == "RGB"               
	aChgFields := {}                              

	//-- Tratamento para Periodo
	if (nChave1 := aScan( aMnemResult, { |x,y| AllTrim(x[4]) == "RGB_PERIOD" } )) > 0
		cAuxPer := &(aMnemResult[ nChave1, 1])
	endif
	If Empty(cAuxPer)
		cAuxPer := cPeriodo
	EndIf
	aAdd( aChgFields, { "RGB_PERIOD" , cAuxPer } )

	//-- Tratamento para Numero Pagamento
	if (nChave1 := aScan( aMnemResult, { |x,y| AllTrim(x[4]) == "RGB_SEMANA" } )) > 0
		cAuxNumPag := &(aMnemResult[ nChave1, 1])
	endif
	If Empty(cAuxNumPag)
		cAuxNumPag := cNumPag
	EndIf
	aAdd( aChgFields, { "RGB_SEMANA" , cAuxNumPag } )

	//-- Tratamento para Roteiro
	if (nChave1 := aScan( aMnemResult, { |x,y| AllTrim(x[4]) == "RGB_ROTEIR" } )) > 0
		cAuxRot := &(aMnemResult[ nChave1, 1])
	endif
	If Empty(cAuxRot)
		cAuxRot := cRoteiro
	EndIf
	aAdd( aChgFields, { "RGB_ROTEIR" , cAuxRot } )

	//-- Tratamento para Verba
	if (nChave1 := aScan( aMnemResult, { |x,y| AllTrim(x[4]) == "RGB_PD" } )) > 0
		cAuxPD := &(aMnemResult[ nChave1, 1])
	endif
	If Empty(cAuxPD)
		cAuxPD := cPd
	EndIf
	aAdd( aChgFields, { "RGB_PD", cAuxPD } )
	    
	//-- Tratamento para Valor
	if (nChave1 := aScan( aMnemResult, { |x,y| AllTrim(x[4]) == "RGB_VALOR" } )) > 0
		nValor := &(aMnemResult[ nChave1, 1])
	endif
	aAdd( aChgFields, { "RGB_VALOR", nValor } )
	
	//-- Tratamento para Horas
	if (nChave1 := aScan( aMnemResult, { |x,y| AllTrim(x[4]) == "RGB_HORAS" } )) > 0
		nHoras := &(aMnemResult[ nChave1, 1])
	endif
	aAdd( aChgFields, { "RGB_HORAS", nHoras } )
	
	//Gravar apenas se valor ou horas for informado
	if nValor == 0 .and. nHoras == 0
		cErro := STR0026 //"Numero de horas lancadas e valor do lancamento nao informado."
		Return .F.
	Endif
		
	//-- Verificar se eh alteracao em Incidencias ou Inclusão em Dados Fixos.
	//   Para isso eh necessario verificar a parcela. Caso a parcela = '99', 
	//   devera ser incluido o registro em Dados Fixos. Caso contrario, devera
	//   alterar o registro em Incidencias.
	if (nChave1 := aScan( aMnemResult, { |x,y| AllTrim(x[4]) == "RGB_PARCEL" } )) > 0
		nParcela := &(aMnemResult[ nChave1, 1])
	else
		nParcela := 0
	endif             
	
	if nParcela == 99
		lInclui := .T.               

		//-- Localizar chave atraves da sequencia
		if (nChave1 := aScan( aMnemResult, { |x,y| AllTrim(x[4]) == 'RGB_SEQ' } )) > 0
			cSeq := &(aMnemResult[ nChave1, 1])
		endif		
		if !Empty(cSeq)
			RGB->( DbSetOrder( nCalRgbOrd ) ) // Ordem 5
			if RGB->( DbSeek( SRA->RA_FILIAL + cProces + cAuxPer + cAuxNumPag + cAuxRot + SRA->RA_MAT + cAuxPd + cSeq, .F. ) )
				lInclui := .F.
				cErro := STR0027 //"Registro existente."
				Return .F.
			EndIf
			aAdd( aChgFields, { "RGB_SEQ", cSeq } )
		else
			//-- Localizar o nova sequencia
	    	cFilFun	  := SRA->RA_FILIAL
			cMatr 	  := SRA->RA_MAT  
			cAliasTab := "QRGB"                     
				
			BeginSql alias cAliasTab
	
			SELECT MAX(RGB_SEQ) SEQ from %exp:__cRGBTab%
			 WHERE RGB_FILIAL = %exp:cFilFun%
			   AND RGB_PROCES = %exp:cProces%
			   AND RGB_PERIOD = %exp:cAuxPer%
			   AND RGB_SEMANA = %exp:cAuxNumPag%
			   AND RGB_ROTEIR = %exp:cAuxRot%
			   AND RGB_MAT 	  = %exp:cMatr%
			   AND RGB_PD     = %exp:cAuxPd%
	
			EndSql
			aAdd( aChgFields, { "RGB_SEQ", StrZero( Val( QRGB->SEQ ) + 1, GetSx3Cache( "RGB_SEQ", "X3_TAMANHO" ) ) } )
			QRGB->( DbCloseArea() )
		endif
	
	else           
		lInclui := .F.
		aAdd( aNotFields, { 'RGB_FILIAL', 'RGB_PROCES', 'RGB_PERIOD', 'RGB_SEMANA', 'RGB_ROTEIR', 'RGB_MAT', 'RGB_PD', 'RGB_SEQ' } )
	endif		

	If Empty(aChgFields)
		aChgFields := {}
	EndIf

ElseIf cTable == "SRK"
	aSRKHeader  := aTables[nPosTable, _HEADER_]
	aAdd(aSRKCols, aTables[nPosTable, 5])
	nUsado := len(aSRKCols[1]) - 1

	If !lItemClvl
		aAdd( aNotFields, { 'RK_FILIAL', 'RK_MAT', 'RK_PD', 'RK_DOCUMEN', 'RK_CC', 'RK_PROCES', 'RK_PERINI', 'RK_NUMPAGO'} )
	Else
		aAdd( aNotFields, { 'RK_FILIAL', 'RK_MAT', 'RK_PD', 'RK_DOCUMEN', 'RK_CC', 'RK_PROCES', 'RK_PERINI', 'RK_NUMPAGO','RK_ITEM','RK_CLVL'} )
	EndIf	
	aChgFields := {}
                     
	//-- Tratamento para Verba
	if (nChave1 := aScan( aMnemResult, { |x,y| AllTrim(x[4]) == 'RK_PD' } )) > 0
		cAuxPd := &(aMnemResult[ nChave1, 1])
	else
		cAuxPd := cPd
	EndIf
	aAdd( aChgFields, { 'RK_PD', cAuxPd } )
	
	//-- Tratamento para Valor Total
	if (nChave1 := aScan( aMnemResult, { |x,y| AllTrim(x[4]) == 'RK_VALORTO' } )) > 0
		nValor := &(aMnemResult[ nChave1, 1])
	else
		cErro := STR0028 //"Valor Principal nao informado."
		Return .F.
	EndIf
	aAdd( aChgFields, { "RK_VALORTO", nValor } )
	// Altera o aCols com o Valor Total informado para calcular valor da parcela
	nField   := GdFieldPos( 'RK_VALORTO' , aTables[nPosTable, _HEADER_] )
	aSRKCols[n, nField] := nValor
	
	//-- Tratamento para Parcela
	if (nChave1 := aScan( aMnemResult, { |x,y| AllTrim(x[4]) == 'RK_PARCELA' } )) > 0
		nParcela := &(aMnemResult[ nChave1, 1])
	else
		nParcela := 1	
	EndIf
	aAdd( aChgFields, { "RK_PARCELA", nParcela } )
	// Altera o aCols com a Parcela informada para calcular valor da parcela
	nField   := GdFieldPos( "RK_PARCELA" , aTables[nPosTable, _HEADER_] )
	aSRKCols[n, nField] := nParcela
	                                           
	//-- Tratamento para Juros Mes
	if (nChave1 := aScan( aMnemResult, { |x,y| AllTrim(x[4]) == "RK_JUROMES" } )) > 0
		nJuros := &(aMnemResult[ nChave1, 1])
		aAdd( aChgFields, { "RK_JUROMES", nParcela } )
		// Altera o aCols com o Juros Mes informado para calcular valor da parcela
		nField   := GdFieldPos( "RK_JUROMES" , aTables[nPosTable, _HEADER_] )
		aSRKCols[n, nField] := nJuros
	EndIf

	// Calcula o valor da parcela
	fCalcVrParc(nValor, nParcela,, aSRKHeader, aSRKCols)
	nField   := GdFieldPos( "RK_VALORPA" , aTables[nPosTable, _HEADER_] )
	aAdd( aChgFields, { "RK_VALORPA",  aSRKCols[n, nField]} )

	//-- Tratamento para Periodo
	if (nChave1 := aScan( aMnemResult, { |x,y| AllTrim(x[4]) == "RK_PERINI" } )) > 0
		cAuxPer := &(aMnemResult[ nChave1, 1])
	endif
	If Empty(cAuxPer)
		cAuxPer := cPeriodo
	EndIf
	aAdd( aChgFields, { "RK_PERINI",  cAuxPer } )
	
	//-- Tratamento para Numero Pagamento
	if (nChave1 := aScan( aMnemResult, { |x,y| AllTrim(x[4]) == "RK_NUMPAGO" } )) > 0
		cAuxNumPag := &(aMnemResult[ nChave1, 1])
	endif
	If Empty(cAuxNumPag)
		cAuxNumPag := cNumPag
	EndIf
	aAdd( aChgFields, { "RK_NUMPAGO", cAuxNumPag } )
	
	//-- Localizar chave atraves do numero do Documento
	if (nChave1 := aScan( aMnemResult, { |x,y| AllTrim(x[4]) == 'RK_DOCUMEN' } )) > 0
		cChave1 := &(aMnemResult[ nChave1, 1])
	EndIf
                  
	lInclui := .T.
	If !Empty(cChave1)
		SRK->( DbSetOrder( nCalSrkOrd ) ) // Ordem 4
		SRK->( DbSeek( SRA->RA_FILIAL + SRA->RA_MAT + cAuxPd, .F. ) )
		While SRK->( !Eof() ) .and. SRK->( RK_FILIAL + RK_MAT + RK_PD ) == SRA->RA_FILIAL + SRA->RA_MAT + cAuxPd
			If SRK->RK_DOCUMEN == cChave1
				lInclui := .F.
			EndIf
			SRK->(DbSkip())
		EndDo
		If !lInclui
			cErro := STR0027 //"Registro existente."
			Return .F.
		EndIf
		aAdd( aChgFields, { "RK_DOCUMEN", cChave1 } )
	Else
        
		//-- Localizar o novo numero de documento
    	cFilFun	  := SRA->RA_FILIAL
		cMatr 	  := SRA->RA_MAT
		cAliasTab := 'QSRK'
		BeginSql alias cAliasTab

			SELECT MAX(RK_DOCUMEN) DOCUMEN from %exp:__cSRKTab%
			 WHERE RK_FILIAL = %exp:cFilFun%
			   AND RK_MAT = %exp:cMatr%

		EndSql
		aAdd( aChgFields, { "RK_DOCUMEN", StrZero( Val( QSRK->DOCUMEN ) + 1, GetSx3Cache( "RK_DOCUMEN", "X3_TAMANHO" ) ) } )
		QSRK->( DbCloseArea() )
	EndIf
	If Empty(aChgFields)
		aChgFields := {}
	EndIf
	
ElseIf cTable == "RG7"
	//-- Tratamento para Verba
	if (nChave1 := aScan( aMnemResult, { |x,y| AllTrim(x[4]) == "RG7_PD" } )) > 0
		cAuxPd := &(aMnemResult[ nChave1, 1])
	endif
	If Empty(cAuxPd)
		cAuxPd := cPd
	EndIf
	aAdd( aChgFields, { "RG7_PD", cAuxPd } ) 

	//-- Tratamento para Roteiro
	if (nChave1 := aScan( aMnemResult, { |x,y| AllTrim(x[4]) == "RG7_ROTEIR" } )) > 0
		cAuxRot := &(aMnemResult[ nChave1, 1])
	endif
	If Empty(cAuxRot)
		cAuxRot := cRoteiro
	EndIf
	aAdd( aChgFields, { "RG7_ROTEIR", cAuxRot } ) 
	
	//-- Tratamento para Ano Fim
	if (nChave1 := aScan( aMnemResult, { |x,y| AllTrim(x[4]) == "RG7_ANOFIM" } )) > 0
		cAuxFim := &(aMnemResult[ nChave1, 1])
	endif
	If Empty(cAuxFim)
		cAuxFim := RCH->RCH_ANO
	EndIf
	aAdd( aChgFields, { "RG7_ANOFIM", cAuxFim } ) 

	//-- Tratamento para Ano Inicio
	if (nChave1 := aScan( aMnemResult, { |x,y| AllTrim(x[4]) == "RG7_ANOINI" } )) > 0
		cAuxIni := &(aMnemResult[ nChave1, 1])
	endif
	If Empty(cAuxIni)
		cAuxIni := RCH->RCH_ANO
	EndIf
	aAdd( aChgFields, { "RG7_ANOINI", cAuxIni } ) 
	                        
	//-- Tratamento para Criterio
	if (nChave1 := aScan( aMnemResult, { |x,y| AllTrim(x[4]) == "RG7_CODCRI" } )) > 0
		cAux := &(aMnemResult[ nChave1, 1])
	else
		cErro := STR0029 //"Codigo do criterio nao informado."
		Return .F.
	EndIf
	aAdd( aChgFields, { "RG7_CODCRI", cAux } ) 

	//-- Tratamento para Sequencia
	if (nChave1 := aScan( aMnemResult, { |x,y| AllTrim(x[4]) == "RG7_SEQACU" } )) > 0
		cSeq := &(aMnemResult[ nChave1, 1])
	endif

	lInclui := .T.          
	If !Empty(cSeq)
		RG7->( DbSetOrder( nCalRg7Ord ) )	// Ordem 2
		RG7->( DbSeek( SRA->RA_FILIAL + SRA->RA_MAT + cAuxPD + cProces + cAuxRot + cAuxFim + cAuxIni, .F. ) )
		while !RG7->( Eof() ) .and. (RG7_FILIAL + RG7_MAT + RG7_PD + RG7_PROCES + RG7_ROTEIR + RG7_ANOFIM + RG7_ANOINI = SRA->RA_FILIAL + SRA->RA_MAT + cAuxPD + cProces + cAuxRot + cAuxFim + cAuxIni)
			if Val(RG7->RG7_SEQACU) = Val(cSeq)
				lInclui := .F.  
				exit
			endif
			RG7->(DbSkip())
		EndDo
		if !lInclui
			aAdd( aNotFields, { "RG7_FILIAL", "RG7_MAT", "RG7_PROCES", "RG7_ROTEIR", "RG7_PD", "RG7_SEQACU", "RG7_ANOFIM", "RG7_ANOINI" } )
		endif  
		aAdd( aChgFields, { "RG7_SEQACU", cSeq} )
	Else
		//-- Localizar o novo numero de documento
    	cFilFun	  := SRA->RA_FILIAL
		cMatr 	  := SRA->RA_MAT
		cAliasTab := 'QRG7'
		BeginSql alias cAliasTab

			SELECT MAX(RG7_SEQACU) SEQ from %exp:__cRG7Tab%
			 WHERE RG7_FILIAL = %exp:cFilFun%
			   AND RG7_MAT    = %exp:cMatr%
			   AND RG7_PROCES = %exp:cProces%
			   AND RG7_ROTEIR = %exp:cAuxRot%
			   AND RG7_PD     = %exp:cAuxPD%
			   AND RG7_ANOINI = %exp:cAuxIni%
			   AND RG7_ANOFIM = %exp:cAuxFim%
		EndSql
		aAdd( aChgFields, { "RG7_SEQACU", StrZero( Val( QRG7->SEQ ) + 1, GetSx3Cache( "RG7_SEQACU", "X3_TAMANHO" ) ) } )
		QRG7->( DbCloseArea() )
	EndIf

//As tabelas deverao ser utilizadas em conjunto, pois nao podera gravar o SR3 sem registro no SR7
//ou devera apenas gravar o SR3, porem o registro no SR7 ja devera existir
ElseIf ( cTable $ "SR7/SR3" )

	nY	:= 2
	aAuxTables := aClone( aTables[ __nSR7Tab, _HEADER_ ] )	
	
	If (nChave1 := aScan( aMnemResult, { |x,y| AllTrim(x[4]) == "R7_DATA" } )) > 0
		cAuxData := &(aMnemResult[ nChave1, 1])
	ElseIf (nChave1 := aScan( aMnemResult, { |x,y| AllTrim(x[4]) == "R3_DATA" } )) > 0
		cAuxData := &(aMnemResult[ nChave1, 1])
	EndIf
	If	( ValType(cAuxData) != "D" )
		cErro := STR0036	//"Data invalida!"
		Return .F.
	ElseIf ( ValType(cAuxData) == "D" )
		cAuxData := Dtos(cAuxData)
	EndIf
	If Empty(cAuxData)
		cAuxData := dDataBase
	EndIf		
	
	aAdd( aChgFields, { "R7_MAT"   , SRA->RA_MAT    } )
	aAdd( aChgFields, { "R7_DATA", Stod(cAuxData) } ) 

	If (nChave1 := aScan( aMnemResult, { |x,y| AllTrim(x[4]) == "R7_TIPO" } )) > 0
		cAuxTipo := &(aMnemResult[ nChave1, 1])
	EndIf
	If Empty(cAuxTipo)
		cAuxTipo := aTables[__nSR7Tab, 5, aScan( aAuxTables, { |x| x[__AHEADER_FIELD__] == "R7_TIPO" } ) ]
	EndIf
	aAdd( aChgFields, { "R7_TIPO", cAuxTipo } )	
	
	If ( Empty(cAuxData) )
		cErro := STR0031 + " - SR7"  //"Data em Branco!"
		Return .F.
	ElseIf ( Empty(cAuxTipo) )
		cErro := STR0032 + " - SR7" //"Tipo em branco!"
		Return .F.
	ElseIf ( !ExistCpoRH( "SX5", "41"+cAuxTipo ) )	
		cErro := STR0034 + " - SR7"  //"Tipo inexistente!"
		Return .F.          
	EndIf

	//Tipo PAGAMENTO
	If (nChave1 := aScan( aMnemResult, { |x,y| AllTrim(x[4]) == "R7_TIPOPGT" } )) > 0
		cAuxTipoPg := &(aMnemResult[ nChave1, 1])
		
		If ( !ExistCpoRH( "SX5", "40"+cAuxTipoPg ) )	
			cErro := STR0037 + " - (SR7) R7_TIPOPGT"  //"Inexistente!"
			Return .F.          
		EndIf
	EndIf     
		
	If Empty(cAuxTipoPg)
		cAuxTipoPg := SRA->RA_TIPOPGT
	EndIf
	aAdd( aChgFields, { "R7_TIPOPGT", cAuxTipoPg } )
	
	//Tipo CATEGORIA FUNCIONAL
	If (nChave1 := aScan( aMnemResult, { |x,y| AllTrim(x[4]) == "R7_CATFUNC" } )) > 0
		cAuxCatFun := &(aMnemResult[ nChave1, 1])
		If ( !ExistCpoRH( "SX5", "28"+cAuxCatFun ) )	
			cErro := STR0037 + " - (SR7) R7_CATFUNC "  //"Inexistente!"
			Return .F.          
		EndIf
		
	EndIf
	If Empty(cAuxCatFun)
		cAuxCatFun := SRA->RA_CATFUNC
	EndIf
	aAdd( aChgFields, { "R7_CATFUNC", cAuxCatFun } )

	//Tipo DEPTO - SIGAORG
	If (nChave1 := aScan( aMnemResult, { |x,y| AllTrim(x[4]) == "R7_DEPTO" } )) > 0
		cAuxDepto := &(aMnemResult[ nChave1, 1])
	EndIf
	If Empty(cAuxDepto)
		cAuxDepto := SRA->RA_DEPTO
	EndIf
	aAdd( aChgFields, { "R7_DEPTO", cAuxDepto } )	
	
	//Tipo POSTO - SIGAORG
	If (nChave1 := aScan( aMnemResult, { |x,y| AllTrim(x[4]) == "R7_POSTO" } )) > 0
		cAuxPosto := &(aMnemResult[ nChave1, 1])
	EndIf

	If Empty(cAuxPosto)
		cAuxPosto := SRA->RA_POSTO
	EndIf
	aAdd( aChgFields, { "R7_POSTO", cAuxPosto } )	
	
	//CARGO e DESCRICAO - caso o usuário use na formula
	If (nChave1 := aScan( aMnemResult, { |x,y| AllTrim(x[4]) == "R7_CARGO" } )) > 0
		cAuxCargo 	:= &(aMnemResult[ nChave1, 1])
	Else
		cAuxCargo	:= SRA->RA_CARGO
	Endif
	
	If LEN(ALLTRIM(cAuxCargo)) <> 0
		cAuxDscCar 	:= ALLTRIM(fDesc( "SQ3" , cAuxCargo, "Q3_DESCSUM" , TamSX3("R7_DESCCAR")[1], FWxFilial("SR7"))) 		
		If len(cAuxDscCar) == 0	 
			cErro := OemtoAnsi(STR0037)+ " - (SR7) R7_CARGO" //"Inexistente!"
			Return .F.
		EndIf
	Else
		cAuxDscCar := ""
	Endif
		
	aAdd( aChgFields, { "R7_CARGO" , cAuxCargo } )
	aAdd( aChgFields, { "R7_DESCCAR", cAuxDscCar } )



	//FUNCAO e DESCRICAO - caso o usuário use na formula
	If (nChave1 := aScan( aMnemResult, { |x,y| AllTrim(x[4]) == "R7_FUNCAO" } )) > 0
		cAuxFuncao := &(aMnemResult[ nChave1, 1])
	Else
		cAuxFuncao := SRA->RA_CODFUNC
	EndIf
			
	If LEN(ALLTRIM(cAuxFuncao)) <> 0
	  	cAuxDscFun := ALLTRIM(fDesc ( "SRJ" , cAuxFuncao , "RJ_DESC" , TamSX3("R7_DESCFUN")[1] , SRA->RA_FILIAL , 01 ))		
	Else
		cAuxDscFun :=	""
	EndIf

	If len(cAuxDscFun) == 0	
		cErro := OemtoAnsi(STR0037)+ " - (SR7) R7_FUNCAO" //"Inexistente!"
		Return .F.

	//Esta condicao eh devida a rotina GPEA250, permitir alteração na descricao da funcao
	//e não ser um campo virtual
	ElseIf (nChave1 := aScan( aMnemResult, { |x,y| AllTrim(x[4]) == "R7_DESCFUN" } )) > 0
		cAuxDscFun := &(aMnemResult[ nChave1, 1])
	EndIf
			
	aAdd( aChgFields, { "R7_FUNCAO" , cAuxFuncao } )
	aAdd( aChgFields, { "R7_DESCFUN", cAuxDscFun } )
	
	SR7->( dbSetOrder( nCalSr7Ord ) )
	If	( SR7->( dbSeek( SRA->RA_FILIAL+SRA->RA_MAT+cAuxData+cAuxTipo ) ) )
		cSeq 	:= SR7->( R7_SEQ )
		lExist := .T.
	EndIf

	If !lExist		
		cAliasTab	:= GetNextAlias()

		BeginSql alias cAliasTab
			%NOPARSER%
			SELECT MAX(R7_SEQ) SEQ FROM %exp:__cSR7Tab%
					WHERE 	R7_FILIAL = %exp:SRA->RA_FILIAL%  AND
					R7_MAT 	  = %exp:SRA->RA_MAT% 	  AND 
					R7_DATA   = %exp:cAuxData%		  AND 
					D_E_L_E_T_ = ' ' 
			EndSql

			cSeq	:= AllTrim(Str(Val((cAliasTab)->(SEQ))+1))
			
			(cAliasTab)->(dbCloseArea())
	EndIf
		
	
	aAdd( aChgFields, { "R7_SEQ", cSeq } )
	
	// Tratamento na tabela SR3 - Itens das alteracoes //
	aAuxTables := aClone( aTables[ __nSR3Tab, _HEADER_ ] )
	
	aAdd( aChgFields, { "R3_FILIAL", SRA->RA_FILIAL } ) 
	aAdd( aChgFields, { "R3_MAT"   , SRA->RA_MAT    } ) 

	If (nChave1 := aScan( aMnemResult, { |x,y| AllTrim(x[4]) == "R3_VALOR" } )) > 0
		nValor := &(aMnemResult[ nChave1, 1])
	EndIf

	If ( nValor == 0 )
		cErro := STR0028 + " - " + cTable //"Valor Principal nao informado."
		Return .F.		
	EndIf

	aAdd( aChgFields, { "R3_VALOR", nValor } )		
	
	If (nChave1 := aScan( aMnemResult, { |x,y| AllTrim(x[4]) == "R3_PD" } )) > 0
		cAuxPd := &(aMnemResult[ nChave1, 1])
		cAuxDescPd := ALLTRIM(fDesc( "SRV" , cAuxPd, "RV_DESC" , TamSX3("R3_DESCPD")[1], FWxFilial("SRV"))) 		
		//para verificar se verba realmente existe, caso contrario sair
		If cAuxPd <> "000" .and. (len(cAuxDescPd) == 0)	
			cErro := OemtoAnsi(STR0035)+ " - SR3" //"Verba Inexistente!"
			Return .F.	
		EndIf

		//Neste o usuário poderá via formula, alterar R3_DESCPD 
		//mesmo com quebra de referencia, entre código e descrição - Regra igual GPEA250
		If	(nChave1 := aScan( aMnemResult, { |x,y| AllTrim(x[4]) == "R3_DESCPD" } )) > 0
	    	cAuxDescPd := &(aMnemResult[ nChave1, 1]) 
	    EndIf			
	    
   		//Aqui é a garantia que a descrição não está vazia
   		//pois poderá existir Verba="000" e não localizar no fdesc
   		If (len(cAuxDescPd) == 0)	
		   	cErro := OemtoAnsi(STR0035)+ " - SR3" //"Verba Inexistente!"
			Return .F.
		EndIf

	Else	
		//senão não encontrou mnemonico que use R3_PD - usará a verba que está em uso no roteiro
		cAuxPd		:= cPd
		nChave1 	:= aScan( aPd, { |x| x[1] == cAuxPd } )
		cAuxDescPd	:= aPd[ nChave1, 2 ]
	EndIf 
		
	aAdd( aChgFields, { "R3_PD"		, cAuxPD 	} )	
	aAdd( aChgFields, { "R3_DESCPD", cAuxDescPd } )
	
	If Empty(cAuxDepto)
		cAuxDepto := SRA->RA_DEPTO
	EndIf
	aAdd( aChgFields, { "R3_DEPTO", cAuxDepto } )	
	
	If Empty(cAuxPosto)
		cAuxPosto := SRA->RA_POSTO
	EndIf
	aAdd( aChgFields, { "R3_POSTO", cAuxPosto } )	
	
	aAdd( aChgFields, { "R3_DATA", Stod(cAuxData) } )
	aAdd( aChgFields, { "R3_TIPO", cAuxTipo } )		
	aAdd( aChgFields, { "R3_SEQ", cSeq } ) 		

	
	SR3->( dbSetOrder( nCalSr3Ord ) )
	If SR3->( dbSeek( SRA->RA_FILIAL+SRA->RA_MAT+cAuxData+cSeq+cAuxTipo+cAuxPd ) )
		cErro := STR0027 + " - " + cTable //"Registro existente."
		Return .F.
	EndIf
	
	lInclui := .T.
			
ElseIf ( cTable == "SR9" )
	aAdd( aNotFields, {'R9_FILIAL', 'R9_MAT', 'R9_POSTO', 'R9_DEPTO' } )
	lInclui := .F.                                                                                  
Else
	aAdd( aNotFields, {} )
EndIf

For nCont := 1 To nY

	If ( cAuxTable $ "SR7/SR3" .and. nCont == 1 )
		If lExist
			Loop
		Else
			cTable := "SR7"
			nPosTable := __nSR7Tab
		EndIf
	ElseIf ( cAuxTable $ "SR7/SR3" .and. nCont == 2 )
		cTable 	  := "SR3"
		nPosTable :=  __nSR3Tab
	EndIf

	// Realizar a gravacao das informacoes //
	DbSelectArea(cTable)
	Begin Transaction 
		RecLock(cTable,lInclui)
		if lInclui
			cField := PrefixoCpo(cTable)+ "_FILIAL"
			&cField := SRA->RA_FILIAL
		endif
		// Colocado campos fixos, pois nas tabelas SR7/SR3 os campos nao estao usados para o modulo SIGAGPE
		If ( cTable == "SR7" )
			(cTable)->R7_MAT	:= SRA->RA_MAT
		ElseIf ( cTable == "SR3" )
			(cTable)->R3_MAT	:= SRA->RA_MAT
			nPosField := aScan( aChgFields, { |x| AllTrim(x[1]) == "R3_DATA" } )
			(cTable)->R3_DATA	:= aChgFields[ nPosField, 2 ]
		EndIf
		For nX = 1 To Len( aTables[nPosTable, 2] )
			cField := AllTrim(aTables[nPosTable, 2, nX, __AHEADER_FIELD__])
	
			//-- Para a inclusao desconsiderar todas os campos de NotFields
			If !lInclui .and. aScan( aNotFields[1], { |x| x == cField } ) > 0
				Loop
			Else
				nPosChgField 	:= aScan( aChgFields, { |x| AllTrim(x[1]) == cField } ) 
				nPosField		:= 0
				If nPosChgField == 0
					nPosField 		:= aScan( aMnemResult, { |x,y| AllTrim(x[4]) == cField } )
				EndIf
				If nPosField > 0
					uValor := &(aMnemResult[ nPosField, 1])
				ElseIf nPosChgField > 0
					uValor := aChgFields[nPosChgField,2]
				Elseif lInclui
					// Inicializadores padrao
					uValor := aTables[nPosTable, 5, nX]
				else
					loop
				EndIf
				
				// Compatibilizar os tipos das variaveis com os do Campos //
				cType := ValType( uValor )
				If aTables[nPosTable, _HEADER_, nX, __AHEADER_TYPE__] == "D" 
					If cType == "C"
						uValor := CTOD(uValor)
					ElseIf cType <> "D"
						uValor := CTOD("//")
					EndIf
				ElseIf aTables[nPosTable, _HEADER_, nX, __AHEADER_TYPE__] == "N" 
					If cType == "C"
						uValor := Val(uValor)
					ElseIf cType <> "N"
						uValor := 0
					EndIf
				ElseIf aTables[nPosTable, _HEADER_, nX, __AHEADER_TYPE__] == "C" 
					If cType == "N"
						uValor := Str(uValor)
					ElseIf cType <> "C"
						uValor := ""
					EndIf
				EndIf
				&cField := uValor
			EndIf
		Next nX
		MsUnlock()
	End Transaction

Next

RestArea( aArea )

Return .T.

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³fGetForm	³ Autor ³Mauricio Takakura     ³ Data ³17/10/2007³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Gera a estrutura das formulas para realizar o calculo	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL															 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³SIGAGPE     												 ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function fGetForm(aRotPd, aTables)

Local aFormulas	:= {}

Local cAliasRC3	:= "QRC3"
Local cExpFor
Local cOper1
Local cOperador
Local cOper2
Local cResult
Local cDefTable
Local cPdFor
Local cQrySt	:= ""

Local lRound

Local nI, nX, nY
Local nPosFil
Local nItem
Local nSubItem
Local nForIt
Local nTipo		:= 0 // { No array das formulas existe uma posicao no array com a expressao a ser interpretada no 
					 // momento de execucao. Existe uma segunda posicao que indica o tipo que sera:
Local cPrim := ""
Local cUlti := ""

Local nCaixa := 0
Local lAchou := .F.  
Local lElem1 := .F.
Local lElem2 := .F.

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Posicao dos campos no array das tabelas                       ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
If __nSRMTab == 0

	__nSRMTab	  	:= aScan( aTables, { |x| x[1] = "SRM" } )
	__nRGBTab  		:= aScan( aTables, { |x| x[1] = "RGB" } )
	__nSRKTab		:= aScan( aTables, { |x| x[1] = "SRK" } )
	__nSR8Tab  		:= aScan( aTables, { |x| x[1] = "SR8" } )
	__nRCMTab		:= aScan( aTables, { |x| x[1] = "RCM" } )
	__nSRQTab  		:= aScan( aTables, { |x| x[1] = "SRQ" } )	
	__nRG1Tab		:= aScan( aTables, { |x| x[1] = "RG1" } )
	__nSRCTab 		:= aScan( aTables, { |x| x[1] = "SRC" } )
	__nSR7Tab 		:= aScan( aTables, { |x| x[1] = "SR7" } )
	__nSR3Tab 		:= aScan( aTables, { |x| x[1] = "SR3" } )

	__nSRMPd  		:= GdFieldPos( "RM_VERBA"	, aTables[__nSRMTab, _HEADER_] )
	__nSRMIncid 	:= GdFieldPos( "RM_LEEINC"	, aTables[__nSRMTab, _HEADER_] )
	__nSRMValFut	:= GdFieldPos( "RM_LEEPRE"	, aTables[__nSRMTab, _HEADER_] )
	__nSRMAcumul	:= GdFieldPos( "RM_LEEACU"	, aTables[__nSRMTab, _HEADER_] )
	__nSRMAusenc	:= GdFieldPos( "RM_LEEAUS"	, aTables[__nSRMTab, _HEADER_] )
	__nSRMForm		:= GdFieldPos( "RM_CODFOR"	, aTables[__nSRMTab, _HEADER_] )
	__nSRMCodCri	:= GdFieldPos( "RM_CODCRI"	, aTables[__nSRMTab, _HEADER_] )
	__nSRMBenef		:= GdFieldPos( "RM_LEEBEN"	, aTables[__nSRMTab, _HEADER_] )
	__nSRMLanFix	:= GdFieldPos( "RM_LEEFIX"	, aTables[__nSRMTab, _HEADER_] )

	__nRGBPD   		:= GdFieldPos( "RGB_PD"		, aTables[__nRGBTab, _HEADER_] )
	__nRGBFun  		:= GdFieldPos( "RGB_CODFUN"	, aTables[__nRGBTab, _HEADER_] )
	__nRGBDtR 		:= GdFieldPos( "RGB_DTREF"	, aTables[__nRGBTab, _HEADER_] )
	__nRGBCc 		:= GdFieldPos( "RGB_CC"		, aTables[__nRGBTab, _HEADER_] )
	__nRGB3Tp  		:= GdFieldPos( "RGB_TIPO3"	, aTables[__nRGBTab, _HEADER_] )
	__nRGB2Tp  		:= GdFieldPos( "RGB_TIPO2"	, aTables[__nRGBTab, _HEADER_] )
	__nRGB1Tp  		:= GdFieldPos( "RGB_TIPO1"	, aTables[__nRGBTab, _HEADER_] )
	__nRGBQtS  		:= GdFieldPos( "RGB_QTDSEM"	, aTables[__nRGBTab, _HEADER_] )
	__nRGBParc 		:= GdFieldPos( "RGB_PARCEL"	, aTables[__nRGBTab, _HEADER_] )
	__nRGBSem  		:= GdFieldPos( "RGB_SEMANA"	, aTables[__nRGBTab, _HEADER_] )
	__nRGBNuId 		:= GdFieldPos( "RGB_NUMID"	, aTables[__nRGBTab, _HEADER_] )
	__nRGBPos 		:= GdFieldPos( "RGB_POSTO"	, aTables[__nRGBTab, _HEADER_] )
	__nRGBDept		:= GdFieldPos( "RGB_DEPTO"	, aTables[__nRGBTab, _HEADER_] )
	__nPosD1		:= GdFieldPos( "RGB_DUM"	, aTables[__nRGBTab, _HEADER_] )
	__nPosD2		:= GdFieldPos( "RGB_DDOIS"	, aTables[__nRGBTab, _HEADER_] )
	__nPosD3		:= GdFieldPos( "RGB_DTRES"	, aTables[__nRGBTab, _HEADER_] )
	__nPosD4		:= GdFieldPos( "RGB_DQUATR"	, aTables[__nRGBTab, _HEADER_] )
	__nPosD5		:= GdFieldPos( "RGB_DCINCO"	, aTables[__nRGBTab, _HEADER_] )
	__nPosD6		:= GdFieldPos( "RGB_DSEIS"	, aTables[__nRGBTab, _HEADER_] )
	__nPosD7		:= GdFieldPos( "RGB_DSETE"	, aTables[__nRGBTab, _HEADER_] )

	__nSRKPD		:= GdFieldPos( "RK_PD"		, aTables[__nSRKTab, _HEADER_] )
	__nSRKDtM  		:= GdFieldPos( "RK_DTMOVI"	, aTables[__nSRKTab, _HEADER_] )
	__nSRKNuId		:= GdFieldPos( "RK_NUMID"	, aTables[__nSRKTab, _HEADER_] )

	__nSR8PD  		:= GdFieldPos( "R8_PD"		, aTables[__nSR8Tab, _HEADER_] )
	__nSR8Tipo	 	:= GdFieldPos( "R8_TIPOAFA"	, aTables[__nSR8Tab, _HEADER_] )
	__nSR8DtIni		:= GdFieldPos( "R8_DATAINI"	, aTables[__nSR8Tab, _HEADER_] )
	__nSR8NuId 		:= GdFieldPos( "R8_NUMID"	, aTables[__nSR8Tab, _HEADER_] )
	
	__nRCMPD		:= GdFieldPos( "RCM_PD"		, aTables[__nRCMTab, _HEADER_] )
	__nRCMTipo 		:= GdFieldPos( "RCM_TIPO"	, aTables[__nRCMTab, _HEADER_] )
	
	__nSRQPD   		:= GdFieldPos( "RQ_VERBFOL"	, aTables[__nSRQTab, _HEADER_] )
	
	__nRG1PD   		:= GdFieldPos( "RG1_PD"		, aTables[__nRG1Tab, _HEADER_] )

	__nRG1NuId := GdFieldPos( "RG1_NUMID"		, aTables[__nRG1Tab, _HEADER_] )
	__nSRQNuId := GdFieldPos( "RQ_NUMID"		, aTables[__nSRQTab, _HEADER_] )
EndIf

cFilFor := xFilial( "RC3" )
For nI := 1 To Len( aRotPd )
	cCodFor 	:= aRotPd[nI, __nSRMForm]
	cPdFor		:= aRotPd[nI, __nSRMPd]
	cCritAcum	:= aRotPd[nI, __nSRMCodCri]
	lRound	:= .T.

 	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Posiciona os Criterios de Acumulacao a cada Formula          ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ		
	If !Empty(cCritAcum)
	
		DbSelectArea( "RG9" )	// Criterios de Acumulacao
		DbSetOrder( nCalRg9Ord )
		DbSeek( __xFilRG9 + cCritAcum, .F. )

	EndIf

	If __oSt01 == Nil
		__oSt01 := FWPreparedStatement():New()
		cQrySt := "SELECT RC3_SEQFOR, RC3_FORM01, RC3_OPERA1, RC3_FORM02, RC3_RESULT FROM " + StrTran(__cRC3Tab, "%", "") + " "
		cQrySt += "WHERE RC3_FILIAL = ? AND "	
		cQrySt += "RC3_CODIGO = ? AND "	
		cQrySt += "D_E_L_E_T_ = ' '"	
		cQrySt += "ORDER BY RC3_SEQFOR "
		cQrySt := ChangeQuery(cQrySt)
		__oSt01:SetQuery(cQrySt)
	EndIf
	__oSt01:SetString(1, cFilFor)
	__oSt01:SetString(2, cCodFor)
	cQrySt := __oSt01:getFixQuery()
	dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQrySt),cAliasRC3,.T.,.T.)

	aAdd( aFormulas, {} )
	nForIt := Len( aFormulas )
	cDefTable := ""
	While (cAliasRC3)->( !Eof() )
		
		If Substr( AllTrim((cAliasRC3)->(RC3_FORM01)),1,1) == "#"
			(cAliasRC3)->( DbSkip() )
			Loop
		EndIf

		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Esturutra do array aFormulas 								   ³
		³1-Sequencia da Formula     								   ³
		³2-Conteudo Operando 1 ==> 1-Original / 2 - Interpretado	   ³
		³3-Operador                 								   ³
		³4-Conteudo Operando 2 ==> 1-Original / 2 - Interpretado	   ³
		³5-Resultado                				    			   ³
		³6-Expressao para interpretacao 		   					   ³
		³7-Tipo do Item / 0 - Nao possui expressao / 1-Tipo Aritmetico ³
		³			    / 2 - Condicao / 3 - Ativa Trace / 4 - Desativa³
		³               / Trace / 9 - Nao executar linha		       ³
		³8-Gerar arredondamento - Para Importes e Unidades gerar o     ³
		³                 arredondamento para 2 casas                  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		aAdd( aFormulas[nForIt], { AllTrim((cAliasRC3)->(RC3_SEQFOR)), { AllTrim((cAliasRC3)->(RC3_FORM01)), AllTrim((cAliasRC3)->(RC3_FORM01)) }, AllTrim((cAliasRC3)->(RC3_OPERA1)), { AllTrim((cAliasRC3)->(RC3_FORM02)), AllTrim((cAliasRC3)->(RC3_FORM02))}, AllTrim((cAliasRC3)->(RC3_RESULT)), "", 0, lRound } )
		nItem 	 := Len(aFormulas)
		nSubItem := Len(aFormulas[nItem])
		
		cExpFor		:= ""
		cOper1 		:= AllTrim((cAliasRC3)->(RC3_FORM01))
		cOperador	:= AllTrim((cAliasRC3)->(RC3_OPERA1))
		cOper2 		:= AllTrim((cAliasRC3)->(RC3_FORM02))
		cResult		:= AllTrim((cAliasRC3)->(RC3_RESULT))
		
		// Verificar se possui sinal de +/- no operando
		If Substr(cOper1,1,1) $ '-/+' 
			cOper1 := '('+cOper1+')'
		EndIf
		If Substr(cOper2,1,1) $ '-/+' 
			cOper2 := '('+cOper2+')'
		EndIf

		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Interpretacao dos Mnemonicos Reservados                       ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		If cOper1 == ME_HOY
			cOper1 := DTOC(dDataBase)
			aFormulas[nItem,nSubItem,2,2] := cOper1
		ElseIf cOper1 == ME_DIAS_TRAY_SIG
			cOper1 := 'fDiasTray( aTables, aTrajLab, nPosTrajLab, dDtIniTraj, dDtFimTraj )'
		ElseIf cOper1 == ME_VACIO
			cOper1 := 'CTOD("//")'
		EndIf
		
		If cOper2 == ME_HOY
			cOper2 := DTOC(dDataBase)
			aFormulas[nItem,nSubItem,4,2] := cOper2
		ElseIf cOper2 == ME_DIAS_TRAY_SIG
			cOper2 := 'fDiasTray( aTables, aTrajLab, nPosTrajLab, dDtIniTraj, dDtFimTraj )'
		ElseIf (Substr(cOper1,1,(Len(cOper1)-2)) == ME_ELEMENTO .Or. Substr(cOper2,1,(Len(cOper2)-2)) == ME_ELEMENTO ) .and. ;
				( cOperador <> OP_HASTA_IGUAL .and. cOperador <> OP_HASTA_MAYOR .and. cOperador <> OP_HASTA_MENOR .and. ;
				cOperador <> OP_HASTA_MAYOR_IGUAL .and. cOperador <> OP_HASTA_MENOR_IGUAL )
			nTamCpo1 := (Len(alltrim(cOper1))-2)
			If Substr(cOper1,1,nTamCpo1) == ME_ELEMENTO
				cPosArr := AllTrim(Str((Val(Substr(cOper1,(nTamCpo1+1),2))+4)))
				cOper1 := 'If(_NDEFRHTB>0, aDefTab[_NDEFRHTB, ' + cPosArr + '], If(ValType(' + cOper2 + ')="N", 0, If(ValType(' + cOper2 + ')= "D", CTOD("//"), "") ))'
				lElem1 := .T.
			EndIf
			nTamCpo2 := (Len(alltrim(cOper2))-2)
			If Substr(cOper2,1,nTamCpo2) == ME_ELEMENTO
				cPosArr := AllTrim(Str((Val(Substr(cOper2,(nTamCpo2+1),2))+4)))
				if !Empty(cOper1)
					cOper2 := 'If(_NDEFRHTB>0, aDefTab[_NDEFRHTB, ' + cPosArr + '], If(ValType(' + cOper1 + ')="N", 0, If(ValType(' + cOper1 + ')= "D", CTOD("//"), "") ))'
				Else
					cOper2 := 'If(_NDEFRHTB>0, aDefTab[_NDEFRHTB, ' + cPosArr + '], If(ValType(' + cResult + ')="N", 0, If(ValType(' + cResult + ')= "D", CTOD("//"), "") ))'				
				EndIF
				lElem2 := .T.
			EndIf
		ElseIf cOper2 == ME_VACIO
			cOper2 := 'CTOD("//")'
		EndIf
	
		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Interpretacao dos Operadores e Mnemonicos                     ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		nTipo := 1
		
		If cOperador == OP_SUMA // Suma
			fConvType(@cOper1, aMnemonicos,,aTables)
			cExpFor := cResult + ':=' + cOper1 + '+' + cOper2
		ElseIf cOperador == OP_RESTA
			fConvType(@cOper1, aMnemonicos,,aTables)
			fConvType(@cOper2, aMnemonicos,,aTables)
			cExpFor := cResult + ':=' + cOper1 + '-' + cOper2
		ElseIf cOperador == OP_MULTIPLICA
			cExpFor := cResult + ':=' + cOper1 + '*' + cOper2
		ElseIf cOperador == OP_DIVIDE
			cExpFor := cResult + ':=' + cOper1 + '/' + cOper2
		ElseIf cOperador == OP_RESIDUO
			cExpFor := cResult + ':=' + cOper1 + '%' + cOper2
		ElseIf cOperador == OP_EXPONENTE
			cExpFor := cResult + ':=' + cOper1 + '**' + cOper2
		ElseIf cOperador == OP_TRUNCA
			cExpFor := cResult + ':= NOROUND( ' + cOper2 + ',' + If( Empty(cOper1), '0', cOper1 ) + ' )'
		ElseIf cOperador == OP_REDONDEA
			cExpFor := cResult + ':= ROUND( ' + cOper2 + ',' + If( Empty(cOper1), '0', cOper1 ) + ' )'
		ElseIf cOperador == OP_MUEVE
			If cResult <> ME_SUMA_TIPO_NOM
				fConvType(@cOper2, aMnemonicos, .F.,aTables)
			EndIf
			cExpFor := cResult + ":=" + cOper2
		ElseIf cOperador == OP_MUEVE_STR
			If cResult <> ME_SUMA_TIPO_NOM
				fConvType(@cOper2, aMnemonicos, .F.,aTables,.F.)
			EndIf
			cExpFor := cResult + ":=" + cOper2
		ElseIf cOperador == OP_DIA
			fConvType(@cOper2, aMnemonicos, .F.,aTables)
			cExpFor := cResult + ":= Day(" + cOper2 + ")"
		ElseIf cOperador == OP_MES
			fConvType(@cOper2, aMnemonicos, .F.,aTables)
			cExpFor := cResult + ":= Month(" + cOper2 + ")"
		ElseIf cOperador == OP_ANO
			fConvType(@cOper2, aMnemonicos, .F.,aTables)
			cExpFor := cResult + ":= Year(" + cOper2 + ")"
		ElseIf cOperador == OP_DIA_SEMANA
			fConvType(@cOper2, aMnemonicos, .F.,aTables)
			cExpFor := cResult + ":= Dow(" + cOper2 + ")"
		ElseIf cOperador == OP_CONVIERTE_FECHA
			cExpFor := cResult + ":= Ctod(ConvData(" + cOper2 + "))"
		ElseIf cOperador == OP_ETIQUETA
			aAdd( __aEtiquetas, { cOper1, nSubItem, 0, cCodFor } )
			nTipo := 9
		ElseIf cOperador == OP_TRACE_ON 
			cExpFor := 'lTrace := .T.'
			nTipo := 3
		ElseIf cOperador == OP_TRACE_OFF
			cExpFor := 'lTrace := .F.'
			nTipo := 4
		ElseIf cOperador == OP_SI_IGUAL
			If lElem1 .Or. lElem2
				fConvType(@cOper1, aMnemonicos,,aTables,.F.)
				fConvType(@cOper2, aMnemonicos,,aTables,.F.)
			Else
				fConvType(@cOper1, aMnemonicos,,aTables)
				fConvType(@cOper2, aMnemonicos,,aTables)
			Endif				
			cExpFor := cOper1 + '=='+ cOper2
			nTipo := 2
		ElseIf cOperador == OP_SI_MAYOR
			fConvType(@cOper1, aMnemonicos,,aTables)
			fConvType(@cOper2, aMnemonicos,,aTables)
			cExpFor := cOper1 + '>'+ cOper2
			nTipo := 2
		ElseIf cOperador == OP_SI_MENOR
			fConvType(@cOper1, aMnemonicos,,aTables)
			fConvType(@cOper2, aMnemonicos,,aTables)
			cExpFor := cOper1 + '<'+ cOper2
			nTipo := 2
		ElseIf cOperador == OP_SI_DIFERENTE
			If lElem1 .Or. lElem2
				fConvType(@cOper1, aMnemonicos,,aTables,.F.)
				fConvType(@cOper2, aMnemonicos,,aTables,.F.)
			Else
				fConvType(@cOper1, aMnemonicos,,aTables)
				fConvType(@cOper2, aMnemonicos,,aTables)
			Endif				
			cExpFor := '!(' + cOper1 + '==' + cOper2 + ')'			
			nTipo := 2
		ElseIf cOperador == OP_BUSCA
			nTamCod := GetSx3Cache( "RCB_CODIGO", "X3_TAMANHO" )
			nTamCpo := (Len(Alltrim(cOper2))-4)
			If Substr(cOper2,1,nTamCpo) == ME_TABLA
				cDefTable := Substr(cOper2,(nTamCpo+1))
			Else
				cDefTable := cOper2
			EndIf
			cDefTable := AllTrim( cDefTable ) + Space( nTamCod - Len(AllTrim( cDefTable )))
			cExpFor := "_nPosTab := aScan( aDefTab, {|x| x[1] == '" + cDefTable + "'})"
		ElseIf cOperador == OP_HASTA_IGUAL
			nTamCpo1 := (Len(alltrim(cOper1))-2)
			nTamCpo2 := (Len(alltrim(cOper2))-2)
			If Substr(cOper1,1,nTamCpo1) == ME_ELEMENTO
				fConvType(@cOper2, aMnemonicos,,aTables,.F.)
				cExpFor := "(_NDEFRHTB := (fPosTab('" + cDefTable + "', " + cOper2 + ",'='," + Str((Val(Substr(cOper1,(nTamCpo1+1),2))+3),2) + ',,,,,_NDEFRHTB,,,,,,,,,aDefTab)),_NDEFRHTB+=If(_NDEFRHTB==0,0,(_nPosTab-1)))'
			ElseIf Substr(cOper2,1,nTamCpo2) == ME_ELEMENTO
				fConvType(@cOper1, aMnemonicos,,aTables,.F.)
				cExpFor := "(_NDEFRHTB := (fPosTab('" + cDefTable + "', " + cOper1 + ",'='," + Str((Val(Substr(cOper2,(nTamCpo2+1),2))+3),2) + ',,,,,_NDEFRHTB,,,,,,,,,aDefTab)),_NDEFRHTB+=If(_NDEFRHTB==0,0,(_nPosTab-1)))'
			EndIf
		ElseIf cOperador == OP_HASTA_MAYOR
			nTamCpo1 := (Len(alltrim(cOper1))-2)
			nTamCpo2 := (Len(alltrim(cOper2))-2)
			If Substr(cOper1,1,nTamCpo1) == ME_ELEMENTO
				fConvType(@cOper2, aMnemonicos,,aTables,.F.)
				cExpFor := "(_NDEFRHTB := (fPosTab('" + cDefTable + "'," + cOper2 + ",'<'," + Str((Val(Substr(cOper1,(nTamCpo1+1),2))+3),2) + ',,,,,_NDEFRHTB,,,,,,,,,aDefTab)),_NDEFRHTB+=If(_NDEFRHTB==0,0,(_nPosTab-1)))'
			ElseIf Substr(cOper2,1,nTamCpo2) == ME_ELEMENTO
				fConvType(@cOper1, aMnemonicos,,aTables,.F.)
				cExpFor := "(_NDEFRHTB := (fPosTab('" + cDefTable + "'," + cOper1 + ",'>'," + Str((Val(Substr(cOper2,(nTamCpo2+1),2))+3),2) + ',,,,,_NDEFRHTB,,,,,,,,,aDefTab)),_NDEFRHTB+=If(_NDEFRHTB==0,0,(_nPosTab-1)))'
			EndIf
		ElseIf cOperador == OP_HASTA_MENOR
			nTamCpo1 := (Len(alltrim(cOper1))-2)
			nTamCpo2 := (Len(alltrim(cOper2))-2)
			If Substr(cOper1,1,nTamCpo1) == ME_ELEMENTO
				fConvType(@cOper2, aMnemonicos,,aTables,.F.)
				cExpFor := "(_NDEFRHTB := (fPosTab('" + cDefTable + "'," + cOper2 + ",'>'," + Str((Val(Substr(cOper1,(nTamCpo1+1),2))+3),2) + ',,,,,_NDEFRHTB,,,,,,,,,aDefTab)),_NDEFRHTB+=If(_NDEFRHTB==0,0,(_nPosTab-1)))'
			ElseIf Substr(cOper2,1,nTamCpo2) == ME_ELEMENTO
				fConvType(@cOper1, aMnemonicos,,aTables,.F.)
				cExpFor := "(_NDEFRHTB := (fPosTab('" + cDefTable + "'," + cOper1 + ",'<'," + Str((Val(Substr(cOper2,(nTamCpo2+1),2))+3),2) + ',,,,,_NDEFRHTB,,,,,,,,,aDefTab)),_NDEFRHTB+=If(_NDEFRHTB==0,0,(_nPosTab-1)))'
			EndIf
		
		ElseIf cOperador == OP_HASTA_MAYOR_IGUAL
			nTamCpo1 := (Len(alltrim(cOper1))-2)
			nTamCpo2 := (Len(alltrim(cOper2))-2)
			If Substr(cOper1,1,nTamCpo1) == ME_ELEMENTO
				fConvType(@cOper2, aMnemonicos,,aTables,.F.)
				cExpFor := "(_NDEFRHTB := (fPosTab('" + cDefTable + "'," + cOper2 + ",'<='," + Str((Val(Substr(cOper1,(nTamCpo1+1),2))+3),2) + ',,,,,_NDEFRHTB,,,,,,,,,aDefTab)),_NDEFRHTB+=If(_NDEFRHTB==0,0,(_nPosTab-1)))'
			ElseIf Substr(cOper2,1,nTamCpo2) == ME_ELEMENTO
				fConvType(@cOper1, aMnemonicos,,aTables,.F.)
				cExpFor := "(_NDEFRHTB := (fPosTab('" + cDefTable + "'," + cOper1 + ",'>='," + Str((Val(Substr(cOper2,(nTamCpo2+1),2))+3),2) + ',,,,,_NDEFRHTB,,,,,,,,,aDefTab)),_NDEFRHTB+=If(_NDEFRHTB==0,0,(_nPosTab-1)))'
			EndIf
		ElseIf cOperador == OP_HASTA_MENOR_IGUAL
			nTamCpo1 := (Len(alltrim(cOper1))-2)
			nTamCpo2 := (Len(alltrim(cOper2))-2)
			If Substr(cOper1,1,nTamCpo1) == ME_ELEMENTO
				fConvType(@cOper2, aMnemonicos,,aTables,.F.)
				cExpFor := "(_NDEFRHTB := (fPosTab('" + cDefTable + "'," + cOper2 + ",'>='," + Str((Val(Substr(cOper1,(nTamCpo1+1),2))+3),2) + ',,,,,_NDEFRHTB,,,,,,,,,aDefTab)),_NDEFRHTB+=If(_NDEFRHTB==0,0,(_nPosTab-1)))'
			ElseIf Substr(cOper2,1,nTamCpo2) == ME_ELEMENTO
				fConvType(@cOper1, aMnemonicos,,aTables,.F.)
				cExpFor := "(_NDEFRHTB := (fPosTab('" + cDefTable + "'," + cOper1 + ",'<='," + Str((Val(Substr(cOper2,(nTamCpo2+1),2))+3),2) + ',,,,,_NDEFRHTB,,,,,,,,,aDefTab)),_NDEFRHTB+=If(_NDEFRHTB==0,0,(_nPosTab-1)))'
			EndIf
		ElseIf cOperador == OP_BUSCA_CRITERIO
			cPrim := Substr(Alltrim(cOper2),1,1)
			cUlti := Substr(Alltrim(cOper2),len(Alltrim(cOper2)),1)
			If (cPrim == '"' .or. cPrim == "'") .and. (cUlti == '"' .or. cUlti == "'")
				cOper2 := substr(alltrim(cOper2),2,len(alltrim(cOper2))-2)
			Else
				nPos1 := aScan( aMnemonico, { |x|, x[1] == cOper2 })
				If nPos1 > 0 .And. aMnemonico[nPos1,2] == "F"
					cOper2 := &(aMnemonico[nPos1,3]+"->"+aMnemonico[nPos1,4])
				EndIf
			EndIf
			
			cOpCrit := RG9->RG9_CODCRI
			nQtdSeq := RG9->RG9_QTDSEQ
			cMesIni := ALLTRIM(RG9->RG9_MESINI)
			
			nAux01 := 12 / nQtdSeq
			
			aRG7Caixas := {}
			For nX := 1 to nQtdSeq
			
				&("aCaixa"+Alltrim(Str(nX))) := {}
				For nY := 1 to nAux01
				
					//-aAdd( &("aCaixa"+Alltrim(Str(nX))), {cMesIni})
					aAdd( &("aCaixa"+Alltrim(Str(nX))), cMesIni)
					
					cMesIni := Soma1(cMesIni)
					cMesIni := IIf(cMesIni>="13", "01", cMesIni)
				Next nY
				
				aAdd(aRG7Caixas, &("aCaixa"+Alltrim(Str(nX))) )
			Next nX
			
			//-nPos := aScan( aRG7Caixas, { |x|, x[1,1] == cOper2 } )
			nCaixa := 0
			lAchou := .F.
			For nX := 1 to Len(aRG7Caixas)
				For nY := 1 to Len(aRG7Caixas[nX])
					
					nPos := aScan( aRG7Caixas[nX], { |x|, x == cOper2 } )
					If nPos > 0
						nCaixa := nX
						lAchou := .T.
						Exit
					EndIf
				Next nY
				If lAchou
					Exit
				EndIf
			Next nX
			
			If lAchou
				//-cExpFor := cResult + ' := __NoRound( Val( "' + Alltrim(Str(nPos)) + '" ))'
				cExpFor := cResult + ' := __NoRound( Val( "' + Alltrim(Str(nCaixa)) + '" ))'
			EndIf
		ElseIf cOperador == OP_LEE_TRAY
			cPrim := Substr(Alltrim(cResult),1,1)
			cUlti := Substr(Alltrim(cResult),len(Alltrim(cResult)),1)
			If (cPrim == '"' .or. cPrim == "'") .and. (cUlti == '"' .or. cUlti == "'")
				cResult	:= substr(alltrim(cResult),2,len(alltrim(cResult))-2)
			EndIf

			aAdd( __aEtiquetas, { cOperador, nSubItem, 0, cCodFor } )
			nAt := At("/", cOper1)
			If nAt > 0 
				cPrim := Substr(Alltrim(cOper1),1,1)
				If !(cPrim == "'") .and. !(cPrim == '"')
					cOper1 := "'" + cOper1 + "'"
				ElseIf cPrim == '"'
					cOper1 := StrTran( cOper1, '"', "'" )
			    EndIf
			EndIf
			nAt := At("/", cOper2)
			If nAt > 0 
				cPrim := Substr(Alltrim(cOper2),1,1)
				If !(cPrim == "'") .and. !(cPrim == '"')
					cOper2 := "'" + cOper2 + "'"
				ElseIf cPrim == '"'
					cOper2 := StrTran( cOper2, '"', "'" )
			    EndIf			    
			EndIf			
			cExpFor := "fGetTrajLab(@aTrajLab, SRA->RA_FILIAL, SRA->RA_MAT, " + cOper1 + ", " +  cOper2 + ", '" + cResult + "', aTables)"
		ElseIf cOperador == OP_SIG_TRAY
			aAdd( __aEtiquetas, { cOperador, nSubItem, 0, cCodFor } )
			cExpFor := "nPosTrajLab := nPosTrajLab+1"
		ElseIf cOperador == OP_PRIMER_REG_TRAY
			cExpFor := "nPosTrajLab:=1"
		ElseIf cOperador == OP_ULTIMO_REG_TRAY
			cExpFor := "nPosTrajLab:=Len(aTrajLab)"
		ElseIf cOperador == OP_LEE_DEPENDIENTE
			cPrim := Substr(Alltrim(cOper2),1,1)
			cUlti := Substr(Alltrim(cOper2),len(Alltrim(cOper2)),1)
			If (cPrim == '"' .or. cPrim == "'") .and. (cUlti == '"' .or. cUlti == "'")
				cOper2	:= substr(alltrim(cOper2),2,len(alltrim(cOper2))-2)
			EndIf
			aAdd( __aEtiquetas, { cOperador, nSubItem, 0, cCodFor } )
			cExpFor := "fGetDepend(@aDependiente, SRA->RA_FILIAL, SRA->RA_MAT, '" + cOper2 + "', aTables)"
		ElseIf cOperador == OP_SIG_DEPENDIENTE
			aAdd( __aEtiquetas, { cOperador, nSubItem, 0, cCodFor } )
			cExpFor := "nPosDepend := nPosDepend+1"
		ElseIf cOperador == OP_PRIMER_REG_DEP
			cExpFor := "nPosDepend:=1"
		ElseIf cOperador == OP_ULTIMO_REG_DEP
			cExpFor := "nPosDepend:=Len(aDependiente)"
		ElseIf cOperador == OP_DIAS_HABILES
			cExpFor := ' GpeCalend(SRA->RA_FILIAL, SRA->RA_MAT ,,,, ' + cOper1 + ', ' + cOper2 + ', @' + cResult + ', "D",,.F. ) '
		ElseIf cOperador == OP_HORAS_HABILES
			cExpFor := ' GpeCalend(SRA->RA_FILIAL, SRA->RA_MAT ,,,, ' + cOper1 + ', ' + cOper2 + ', @' + cResult + ', "H",,.F. ) '
		ElseIf cOperador == OP_DIAS_FERIADO
			fConvType(@cOper2, aMnemonicos,,aTables)
			cExpFor := ' GpeCalend(SRA->RA_FILIAL, SRA->RA_MAT ,,,, ' + cOper1 + ', ' + cOper2 + ', @' + cResult + ', "V",,.F. ) '
		ElseIf cOperador == OP_TIPO_DIA
			fConvType(@cOper2, aMnemonicos,,aTables)
			cExpFor := ' GpeCalend(SRA->RA_FILIAL, SRA->RA_MAT ,,,, ' + cOper2 + ', ' + cOper2 + ',,,,.F.,,,@' + cResult + ' ) '
		ElseIf cOperador == OP_DIAS_HAB_PROG
			fConvType(@cOper1, aMnemonicos,,aTables)
			fConvType(@cOper2, aMnemonicos,,aTables)
			cExpFor := ' GpDHabProg(SRA->RA_FILIAL, SRA->RA_MAT ,,,, ' + cOper1 + ', ' + cOper2 + ', @' + cResult + ',,cPD)'
		//DIAS_DERECHO: 1=TODOS_LOS_DIAS; 2=SIN_PROGRAMAR y 3=DIAS_PAGADOS --agregado 17072024
		ElseIf cOperador == OP_DIAS_DERECHO
			fConvType(@cOper2, aMnemonicos,,aTables)
			cExpFor := cResult + ':= GpeDiasDere( ' + If(cOper1==ME_TODOS_LOS_DIAS, '1', IIf(cOper1==ME_DIAS_PAGADOS, '3', '2')) + ', ' + cOper2 + ', cPD)'
		ElseIf cOperador == OP_PAGA_DIA_DER
			nTipo := 9
		ElseIf cOperador == OP_SUMA_IMPHIS .Or. cOperador == OP_SUMA_UNIHIS
			If cOperador == OP_SUMA_IMPHIS
				cExpFor := 'fBuscaAcmPer( cPd,,"V",@'+cResult+',, ' + cOper1 + ',' + cOper2 + ', cSuma_nPgIni, cSuma_nPgFim, cSuma_Tipo_Nom)'
			ElseIf cOperador == OP_SUMA_UNIHIS
				cExpFor := 'fBuscaAcmPer( cPd,,"H",,@'+cResult+', ' + cOper1 + ',' + cOper2 + ', cSuma_nPgIni, cSuma_nPgFim, cSuma_Tipo_Nom)'
			EndIf
		ElseIf cOperador == OP_BUSCA_PROCESO
			cExpFor := ''        
		ElseIf cOperador == OP_BUSCA_ANO_EMPRESA
			cExpFor := ''        
		ElseIf cOperador == OP_FILTRO_ACUM
			
			If 	( aScan( aMnemonico, { |x|, x[1] == cOper2 .and. x[2] == "C" } ) > 0 )
				cExpFor := 'fFiltroAcu ( , cOper2 , aMnemonico )'
			ElseIf ( aScan( aMnemonico, { |x|, x[1] == cOper2 .and. x[2] == "F" } ) > 0 )
				cExpFor := 'fFiltroAcu ( cOper1, cOper2, aMnemonico )'
			Else
				cExpFor := 'fFiltroAcu (,' + cOper2 + ')'
			Endif
		
		ElseIf cOperador == OP_SUMA_IMPORTES
			If AllTrim(cResult) <> ME_IMPORTE
				cExpFor := 'If(lLeeAcumul, ' + cResult + ' := fGetAcumul("1", cOpBusProces, cPD, cCritAcum, ' + cOper1 + ', ' + cOper2 + '), ' + cResult + ')'
			Else
				cExpFor := 'If(lLeeAcumul, ' + cResult + ' := Round(fGetAcumul("1", cOpBusProces, cPD, cCritAcum, ' + cOper1 + ', ' + cOper2 + '),2), ' + cResult + ')'
				lRound 	:= .F.
			EndIf
		ElseIf cOperador == OP_SUMA_UNIDADES
			If AllTrim(cResult) <> ME_IMPORTE
				cExpFor := 'If(lLeeAcumul, ' + cResult + ' := fGetAcumul("2", cOpBusProces, cPD, cCritAcum, ' + cOper1 + ', ' + cOper2 + '), ' + cResult + ')'
			Else
				cExpFor := 'If(lLeeAcumul, ' + cResult + ' := Round(fGetAcumul("2", cOpBusProces, cPD, cCritAcum, ' + cOper1 + ', ' + cOper2 + '),2), ' + cResult + ')'
				lRound 	:= .F.
			EndIf
		ElseIf AllTrim(cOperador) == OP_IMPORTE_EMPRESA
			If cResult <> ME_IMPORTE
				cExpFor := 'If(lLeeAcumul, ' + cResult + ' := fGetAcumul("3",, cPD, cCritAcum, ' + cOper1 + ', ' + cOper2 + ', cFilAcum,,cAnoEmpBus,cAnoEmpBus), ' + cResult + ')'
			Else 
				cExpFor := 'If(lLeeAcumul, ' + cResult + ' := Round(fGetAcumul("3",, cPD, cCritAcum, ' + cOper1 + ', ' + cOper2 + ', cFilAcum,,cAnoEmpBus,cAnoEmpBus),2), ' + cResult + ')'
				lRound 	:= .F.
			EndIf
		ElseIf cOperador == OP_UNIDADES_EMPRESA
			If AllTrim(cResult) <> ME_IMPORTE
				cExpFor := 'If(lLeeAcumul, ' + cResult + ' := fGetAcumul("4",, cPD, cCritAcum, ' + cOper1 + ', ' + cOper2 + ', cFilAcum,,cAnoEmpBus,cAnoEmpBus), ' + cResult + ')'
			Else
				cExpFor := 'If(lLeeAcumul, ' + cResult + ' := fGetAcumul("4",, cPD, cCritAcum, ' + cOper1 + ', ' + cOper2 + ', cFilAcum,,cAnoEmpBus,cAnoEmpBus),2), ' + cResult + ')'
				lRound 	:= .F.
			EndIf
		ElseIf cOperador == OP_IMPORTE_TOTAL
			If AllTrim(cResult) <> ME_IMPORTE
				cExpFor := 'If(lLeeAcumul, ' + cResult + ' := fGetAcumul("5",, cPD, cCritAcum, ' + cOper1 + ', ' + cOper2 + '), ' + cResult + ')'
			Else
				cExpFor := 'If(lLeeAcumul, ' + cResult + ' := Round(fGetAcumul("5",, cPD, cCritAcum, ' + cOper1 + ', ' + cOper2 + '),2), ' + cResult + ')'
				lRound 	:= .F.
			EndIf
		ElseIf cOperador == OP_UNIDADES_TOTAL
			If AllTrim(cResult) <> ME_IMPORTE
				cExpFor := 'If(lLeeAcumul, ' + cResult + ' := fGetAcumul("6",, cPD, cCritAcum, ' + cOper1 + ', ' + cOper2 + '), ' + cResult + ')'
			Else
				cExpFor := 'If(lLeeAcumul, ' + cResult + ' := Round(fGetAcumul("6",, cPD, cCritAcum, ' + cOper1 + ', ' + cOper2 + '),2), ' + cResult + ')'
				lRound 	:= .F.
			EndIf
		ElseIf cOperador == OP_STRTOVAL   
			cExpFor := cResult + ' := __NoRound( Val( StrTran(' + cOper1 + ',",","")),' + if(Empty(cOper2), '0', cOper2) + ')'
		ElseIf cOperador == OP_VALTOSTR
			cOper1   := "StrTran(Alltrim(Str(" + cOper1 + ")), ',', '')"
			If Empty(cOper2)
				cTamanho := "Len(" + cOper1 + ")"
			Else
				cTamanho := "If( Len(" + cOper1 + ") > " + cOper2 + ", Len(" + cOper1 + ") , " + cOper2 + ")"
			EndIf                                                           
			
			cDecimal := "If( "
			cDecimal += "    Int(Val(" + cOper1 + ")) == 0 .AND. (Empty(cOper2) .OR. Val(STR(" + cOper2 + ")) > 0), "
			cDecimal += "    0, "
			cDecimal += "    If( "
			cDecimal += "       Mod(Val(" + cOper1 + "), Int(Val(" + cOper1 + "))) > 0, "
			cDecimal += "       Len(" + cOper1 + ") - At('.', " + cOper1 + "), "
			cDecimal += "       0)" 
			cDecimal += "   )
				
			cExpFor := cResult + ' := StrZero(Val(' + cOper1 + '),' + cTamanho + ',' + cDecimal + ')'
		ElseIf cOperador == OP_FILTRO_MOVLI
			If 	( aScan( aMnemonico, { |x|, x[1] == cOper2 .and. x[2] == "C" } ) > 0 )
				cExpFor := 'fFiltroMov ( ,cOper2, cResult, aMnemonico )'
			ElseIf ( aScan( aMnemonico, { |x|, x[1] == cOper2 .and. x[2] == "F" } ) > 0 )
				cExpFor := 'fFiltroMov ( cOper1,cOper2, cResult, aMnemonico )'
			Endif
			
		ElseIf ( cOperador == OP_SUMA_MOVLI )
			If ( cOper2 == ME_BASE_PENSION )
				cExpFor := cResult + ':= fBaseMov( SRA->RA_FILIAL, SRA->RA_MAT, SRA->RA_PROCES, aBenef, aTables, cOper2 )'
			ElseIf ( aScan( aMnemonico, { |x|, x[1] == cOper2 .and. x[2] == "C" } ) > 0 )
				cExpFor := cResult + ':= fBaseMov( SRA->RA_FILIAL, SRA->RA_MAT, SRA->RA_PROCES, aBenef, aTables,' + cOper2  + ' )
			ElseIf ( aScan( aMnemonico, { |x|, x[1] == cOper2 .and. x[2] == "F" } ) > 0 )	
				cExpFor := cResult + ':= fBaseMov( SRA->RA_FILIAL, SRA->RA_MAT, SRA->RA_PROCES, aBenef, aTables, cOper2, aMnemonico, cOper1 )'
			Else
				cExpFor := cResult + ':= fBaseMov( SRA->RA_FILIAL, SRA->RA_MAT, SRA->RA_PROCES, aBenef, aTables,' + cOper2  + ' )
			EndIf			
		ElseIf ( cOperador == OP_IE_TOTAL_EMP )
			cExpFor := cResult + ':= fCalcImpEst( SRA->RA_FILIAL, "01", ' + cOper2 + ', "' + cPdFor + '", RCH->RCH_DTINI )'

		ElseIf ( cOperador == OP_IE_TOTAL_CON )
			cExpFor := cResult + ':= fCalcImpEst( SRA->RA_FILIAL, "02", ' + cOper2 + ', "' + cPdFor + '", RCH->RCH_DTINI )'
			
		ElseIf (cOperador == OP_GET_MONEDA)
			fConvType(@cOper1, aMnemonicos,,aTables)
			cExpFor:= cResult + ':= RecMoeda('+ cOper1 + ',' + cOper2+ ')'						
		ElseIf (cOperador == OP_PUNTO_ENT)
			cExpFor:= cResult + ':=ExecPunto(cOper1,cOper2)'
		ElseIf (cOperador == OP_AUS_CONTINUO)
			cExpFor:= cResult + ':= FGetAusCont('+ cOper1 + ',SRA->RA_FILIAL, SRA->RA_MAT,"' + cPdFor + '"  )'
		ElseIf (cOperador == OP_DIAS_360 )
			fConvType(@cOper1, aMnemonicos,,aTables)
			fConvType(@cOper2, aMnemonicos,,aTables)
			cExpFor:= cResult + ':= fDias360( '+ cOper1 + ',' + cOper2 + ', aMnemonicos  )'
		ElseIf (cOperador == OP_DIAS_AUSENCIA )
			fConvType(@cOper1, aMnemonicos,,aTables)
			fConvType(@cOper2, aMnemonicos,,aTables)
			cExpFor:= cResult + ':= fDiasAuse( '+ cOper1 + ',' + cOper2 + ',cPD )'
		ElseIf cOperador == OP_SUMA_IMPMOV 
			cExpFor := 'fBuscaMovPer( cPd,"V",@'+cResult+',, ' + cOper1 + ',' + cOper2 + ', cSuma_nPgIni, cSuma_nPgFim, cSuma_Tipo_Nom, lLeeAusenc, lLeeValFut)'
		Elseif cOperador == OP_SUMA_UNIMOV
			cExpFor := 'fBuscaMovPer( cPd,"H",,@'+cResult+', ' + cOper1 + ',' + cOper2 + ', cSuma_nPgIni, cSuma_nPgFim, cSuma_Tipo_Nom, lLeeAusenc, lLeeValFut)'
		ElseIf cOperador == OP_SUMA_GAN_ACU
			cExpFor := cResult + ' := fGetAcuIAG("1", SRA->RA_PROCES, cPD)'
		ElseIf cOperador == OP_FILTRO_AF
			cExpFor := "fFiltroAF( '" + cOper1 + "', '" + cOper2+ "', aMnemonico, aFiltAsFij )"
		ElseIf cOperador == OP_LEE_AST_FIJO
			aAdd( __aEtiquetas, { cOperador, nSubItem, 0, cCodFor } )
			cExpFor := "fGetAstFij(@aAstoFijos, SRA->RA_FILIAL, SRA->RA_MAT, aTables, aFiltAsFij, '" + cOper1 + "', '" + cOper2 + "')"
		ElseIf cOperador == OP_SIG_AST_FIJO
			aAdd( __aEtiquetas, { cOperador, nSubItem, 0, cCodFor } )
			cExpFor := "nPosAstFij := nPosAstFij+1"
		ElseIf cOperador == OP_PRIMER_REG_AF
			cExpFor := "nPosAstFij := 1"
		ElseIf cOperador == OP_ULTIMO_REG_AF
			cExpFor := "nPosAstFij := Len(aAstoFijos)"
		EndIf
        lElem1 := lElem2 := .F.
		aFormulas[nItem,nSubItem,6] := cExpFor
		aFormulas[nItem,nSubItem,7] := nTipo
		aFormulas[nItem,nSubItem,8] := lRound	// Para Importes e Unidades gerar o arredondamento para 2 casas

		(cAliasRC3)->( DbSkip() )
	EndDo

	(cAliasRC3)->( DbCloseArea() )

Next nI

Return(aClone( aFormulas ))

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o	   ³fListTable  ³ Autor ³Mauricio T. Takakura ³ Data ³03/10/2007³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Lista das tabelas permitidas no calculo                    	³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³                                                            ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Retorno  ³NIL															³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³< Vide Parametros Formais >									³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
Function fListTable( lCalculo )
Local aTables := {}

DEFAULT lCalculo := .F.

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Estrutura do Array:                                            ³
³1-Alias da Tabela              2-aHeader               	    ³
³3-Chave da tabela SX2          4-Se deve ou nao gerar aCols    ³
³5-Linha do acols - Inic. Padrao							    ³
³6-Se pode ser ou nao utilizado juntamente com o operador GRABA ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
aAdd( aTables, { "SRA", {}, {}, 1, {}, 1 } )	// Cadastro de funcionarios
aAdd( aTables, { "SRB", {}, {}, 1, {}, 2 } )	// Cadastro de Dependentes
aAdd( aTables, { "RCJ", {}, {}, 2, {}, 2 } )	// Cadastro de Processos
aAdd( aTables, { "RCH", {}, {}, 2, {}, 2 } )	// Cadastro de Periodos
aAdd( aTables, { "RGB", {}, {}, 1, {}, 1 } )	// Tabela de Incidencias 
aAdd( aTables, { "SRK", {}, {}, 1, {}, 1 } )	// Valores Futuros
aAdd( aTables, { "RG7", {}, {}, 1, {}, 1 } )	// Tabela de Acumuladores
If cPaisLoc $ ("MEX/COS/COL/PAR")
	aAdd( aTables, { "RCP", {}, {}, 1, {}, 1 } )	// Trajetoria Laboral 
Endif
aAdd( aTables, { "SQB", {}, {}, 2, {}, 2 } )	// Cadastro de Departamentos
aAdd( aTables, { "SRJ", {}, {}, 2, {}, 2 } )	// Cadastro de Funcoes
aAdd( aTables, { "SRV", {}, {}, 2, {}, 2 } )	// Cadastro de Verbas
aAdd( aTables, { "SR8", {}, {}, 2, {}, 2 } )	// Cadastro de Ausencias 
If cPaisLoc <> ("PAR") 
	aAdd( aTables, { "RCO", {}, {}, 2, {}, 2 } )	// Registro Patronal
Endif
aAdd( aTables, { "CTT", {}, {}, 2, {}, 2 } )	// Cadastro de Centro de Custos
aAdd( aTables, { "SRC", {}, {}, 1, {}, 2 } )	// Tabela de Movimentos - Calculo
aAdd( aTables, { "RGC", {}, {}, 1, {}, 2 } )	// Localidade de Pago
aAdd( aTables, { "RCL", {}, {}, 1, {}, 2 } )	// Postos
aAdd( aTables, { "RCE", {}, {}, 1, {}, 2 } )	// Sindicatos
aAdd( aTables, { "SR6", {}, {}, 1, {}, 2 } )	// Turnos
aAdd( aTables, { "RCM", {}, {}, 1, {}, 2 } )	// Tipos de Ausência
aAdd( aTables, { "SRQ", {}, {}, 1, {}, 2 } )	// Beneficiarios
aAdd( aTables, { "SR3", {}, {}, 1, {}, 1 } )	// Historico Valores Salariais
aAdd( aTables, { "SR7", {}, {}, 1, {}, 1 } )	// Historico Valores Salariais
aAdd( aTables, { "RG1", {}, {}, 1, {}, 2 } )	// Lançamentos Fixos
aAdd( aTables, { "SRG", {}, {}, 1, {}, 2 } )	// Cabecalho de Rescisao
aAdd( aTables, { "SQ3", {}, {}, 1, {}, 2 } )	// Cargos
//aAdd( aTables, { "SR9", {}, {}, 1, {}, 1 } )	// Historico de Funcionarios
If cPaisLoc $ ("DOM/ARG")
	aAdd( aTables, { "RHI", {}, {}, 1, {}, 2 } )	// Cabecalho de Ferias
	aAdd( aTables, { "RHJ", {}, {}, 1, {}, 2 } )	// Itens de Ferias
Endif

If !(cPaisLoc $ "BRA/RUS")
	aAdd( aTables, { "SRF", {}, {}, 1, {}, 2 } )	// Programacion de Vacaciones (Dias de Derecho)
	aAdd( aTables, { "RGM", {}, {}, 1, {}, 2 } )	// Convenios
Endif

If lCalculo
	aAdd( aTables, { "SM0", {}, {}, 2, {}, 2 } )	// Cadastro de Empresas / Filiais
	aAdd( aTables, { "RCA", {}, {}, 2, {}, 2 } )	// Cadastro de Mnemonicos 
	aAdd( aTables, { "SX5", {}, {}, 2, {}, 2 } )	// Tabela de Categorias
	aAdd( aTables, { "RC2", {}, {}, 2, {}, 2 } )	// Cabecalho de formulas
	aAdd( aTables, { "RC3", {}, {}, 2, {}, 2 } )	// Itens das formulas
	aAdd( aTables, { "SRM", {}, {}, 2, {}, 2 } )	// Verbas por Processos - Roteiro de Calculo 
	aAdd( aTables, { "RCK", {}, {}, 2, {}, 2 } )	// Conta Corrente de Valores Futuros
EndIf

ASort(aTables,,,{|x,y| x[01] < y[01] })

Return( aClone( aTables ) )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o	   ³GetTableCalc³ Autor ³Mauricio T. Takakura ³ Data ³27/09/2007³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Monta o Array de Tabela/Campos e chaves para o Calculo     	³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³cX3cBox - String para o Combo do SX3                        ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Retorno  ³NIL															³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³< Vide Parametros Formais >									³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
Function GetTableCalc( aTables )	// Retorna por Referencia as tabelas/Campos/Chaves do Calculo

Local aHeader
Local cKey

Local cAlias

Local nI    

Local lAllFields := .F.

DEFAULT aTables 	:= {}

If Empty(__aSvTables)

	aTables := fListTable( .T. )
	
	For nI := 1 To Len( aTables )
		cAlias := aTables[nI,1]
		//IF incluido para atender as necessidades do México. Posteriormente analisar os impactos
		// de colocar o campo R8_NUMID como campo usado.
		If cAlias $ "RCH*SR8"
			lAllFields := .T.
		Else 
			lAllFields := .F. 
		EndIf
		
		aHeader := GdMontaHeader(  	NIL				,;	//01 -> Por Referencia contera o numero de campos em Uso
				   				    NIL				,;	//02 -> Por Referencia contera os Campos do Cabecalho da GetDados que sao Virtuais
					    			NIL				,;	//03 -> Por Referencia contera os Campos do Cabecalho da GetDados que sao Visuais
					 				cAlias			,;	//04 -> Opcional, Alias do Arquivo Para Montagem do aHeader
									NIL				,;	//05 -> Opcional, Campos que nao Deverao constar no aHeader
									lAllFields   	,;	//06 -> Opcional, Carregar Todos os Campos
									.T.				,;	//07 -> Nao Carrega os Campos Virtuais
									NIL				,;	//08 -> Carregar Coluna Fantasma e/ou BitMap ( Logico ou Array )
									NIL				,;	//09 -> Inverte a Condicao de aNotFields carregando apenas os campos ai definidos
									.T.				,;	//10 -> Verifica se Deve Checar se o campo eh usado
									NIL				,;	//11 -> Verifica se Deve Checar o nivel do usuario
									NIL				,;	//12 -> Utiliza Numeracao na GhostCol
									.T.				 ;	//13 -> Carrega os Campos de Usuario
					   			)
		
		aTables[nI,2] := aClone( aHeader )

		cKey := GetSx2Unico( cAlias )
		If Empty(cKey)
			cKey := ""
		EndIf
		aTables[nI,3] := cKey

	Next nI

	__aSvTables := aClone(aTables)
Else
	aTables := aClone(__aSvTables)
EndIf

Return( .T. )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o	   ³GetTableCalc³ Autor ³Mauricio T. Takakura ³ Data ³27/09/2007³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Monta o Array de Tabela/Campos e chaves para o Calculo     	³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³cX3cBox - String para o Combo do SX3                        ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Retorno  ³NIL															³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³< Vide Parametros Formais >									³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
Function fTablesBox(nTipo	,; // 1-Tabelas; 2-Campos
					cAlias	 ; // Se o Tipo for = 2, devera informa o alias
					)

Local aArea 	:= SX2->( GetArea() )
Local aTables 	:= {}

Local cOpcBox	:= ""
Local cDescSx2	:= ""
Local cCampo    := ""

Local nI, nTables
Local nPos

DEFAULT cAlias := Alias()

aTables := fListTable( .F. )

nTables := Len( aTables )
If nTipo = 1
	For nI := 1 To nTables
		cAlias := aTables[nI,_TABLE_]
		SX2->( DbSeek( cAlias, .F. ) )
		cDescSx2 := ""
		If SX2->( !Eof() )
			cDescSx2 := AllTrim( X2Nome() )
		EndIF
		cOpcBox += cAlias + "=" + cDescSx2 + ";"
	Next nI
Else
	GetTableCalc( aTables )
	nPos 	:= aScan( aTables, { |x| x[1] = cAlias } )
	If nPos > 0    
		aSort( aTables[nPos][2],,,{ |x,y,z| x[02]+x[02] +x[02]< y[02]+y[02]+y[02]} ) // Ordena os campos da tabela selecionada
		nFields	:= Len(aTables[nPos,2])
		For nI := 1 To nFields
			cCampo := aTables[nPos,2,nI,__AHEADER_FIELD__]
			cOpcBox += cCampo + space(10-len(cCampo)) + "=" + aTables[nPos,2,nI,__AHEADER_TITLE__] + ";"
		Next nI
	Else
		cOpcBox := ";"
	EndIf
EndIf
cOpcBox := Substr(cOpcBox,1,Len(cOpcBox)-1)
if Empty(cOpcBox)
	if nTipo = 1
		cOpcBox := " =Tabelas"
	else
		cOpcBox := space(10) + "=Campos"
	endif
endif

RestArea( aArea )

Return( cOpcBox )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³GpeDiasDere	³ Autor ³Mauricio Takakura     ³ Data ³26/11/2007³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Retorna o Numero de Dias de Direito                          ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL															 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³SIGAGPE     												 ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function GpeDiasDere(nTipo	,;			// Tipo do Calculo: 1-Todos los dias / 2-Sin Programar / 3-Dias Pagados
					 dData	,;			// Data final do Periodo a calcular 
					 cPd	,;			// Verba a Retornar
					 lProp;				// Indica si debe tomar en cuenta los proporcionales o no
					 )

Local cAliasSRF		:= ""	
Local cAliasSR8		:= ""
Local cFil			:= SRA->RA_FILIAL
Local cMat			:= SRA->RA_MAT
Local nDias			:= 0
Local nProp			:= 0 //Proporcionales
Local dDatePresc	:= CTOD(" / / ")

Local nDiasProg		:= 0
Local nDiasVen		:= 0
Local nDiasDer		:= 0
Local nDiasPagos	:= 0
Local lTemFerPer	:= .F.
Local lObtConcep	:= cPaisLoc $ "MEX|COL|PAR|ARG"
Local nDiasProp		:= 0
Local cDataSRF		:= IIf(cPaisLoc $ "COL|PAR|ARG", "RF_DATAFIM","RF_DATABAS")
Local cWhereData	:= "%AND SRF." + cDataSRF + " <= '" + DToS(dData) + "'%"

DEFAULT nTipo	:= 1
DEFAULT lProp := .F.

If lObtConcep
	cPd := FGetCodFol("0072") //Se obtiene a partir del Id de Calculo, el concepto asignado.
EndIf

//-- Retornar os controles de dias de derecho do funcionario em aberto
cAliasSRF := geTNextAlias()//"QSRF"
BeginSql alias cAliasSRF
	Column R8_DATAINI as Date
	Column RF_DATABAS as Date
	Column RF_DATAFIM as Date 
	
	SELECT SRF.RF_FILIAL, SRF.RF_MAT, SRF.RF_DATABAS,
		SRF.RF_DATAFIM, SRF.RF_DIASDIR, SRF.RF_DFERANT, SRF.RF_DIASANT, 
		SRF.RF_DFERVAT, SRF.RF_DFERAAT, SRF.RF_STATUS
	FROM %exp:__cSRFTab% SRF
	WHERE SRF.RF_FILIAL  = %exp:cFil%
		AND SRF.RF_MAT	= %exp:cMat%
		AND SRF.RF_PD 	= %exp:cPd%
		AND SRF.RF_STATUS = '1' // Considera periodos ativos
		%exp:cWhereData%
		AND %exp:__cDelete%
    ORDER BY SRF.RF_DATABAS

EndSql

lTemFerPer := (cAliasSRF)->( !Eof() )

//-- Soma dos dias de derecho
While (cAliasSRF)->( !Eof() )

	If !(cPaisLoc $ "COL|PAR|ARG")
	
		nDiasDer 	:= (cAliasSRF)->( RF_DIASDIR )	// Dias derecho
		nDiasVen 	:= (cAliasSRF)->( RF_DFERVAT )	// Dias vencidos
		nDiasPagos 	:= (cAliasSRF)->( RF_DFERANT )	// Dias pagados
		
		If nDiasVen == 0 .and. dData >= (cAliasSRF)->( RF_DATAFIM)
			nDiasVen := nDiasDer
		Else
			// Calcular la fecha de caducidad?			
			dDatePresc :=  fDtPresc(RCJ->RCJ_VIGVAC,(cAliasSRF)->(RF_DATAFIM), RCH->RCH_DTFIM)		
			If dDatePresc <= dData
				nDiasPagos := nDiasDer
			EndIf
		EndIF

		nDias += (nDiasVen - nDiasPagos)
				
		If lProp .and. (dData >= (cAliasSRF)->RF_DATABAS .AND. dData <= (cAliasSRF)->RF_DATAFIM)
			nProp := (dData - (cAliasSRF)->RF_DATABAS + 1 )
			nProp := nProp / (CTOD("31/12/"+ STR(YEAR((cAliasSRF)->RF_DATAFIM))) - CTOD("01/01/"+ STR(YEAR((cAliasSRF)->RF_DATAFIM))) + 1)  
			nProp := nProp * nDiasDer
			
			nDias += nProp
		EndIf
		
		(cAliasSRF)->( DbSkip() )

	Else
		nDiasProp 	:= (cAliasSRF)->( RF_DFERAAT )	// Dias proporcionales
		nDiasVen 	:= (cAliasSRF)->( RF_DFERVAT )	// Dias vencidos
		nDiasPagos 	:= (cAliasSRF)->( RF_DFERANT )	// Dias pagados

		If nTipo == 3
			nDias += nDiasPagos
		Else
			nDias += (nDiasVen + nDiasProp) - nDiasPagos
		EndIf
		
		(cAliasSRF)->(DbSkip())
			
	EndIf
	
EndDo
(cAliasSRF)->(DbCloseArea())

//-- Retornar os dias de derecho programados - Para o Mexico
//-- a programacao de dias derecho ocorre na tabela de Afastamentos (SR8)
//-- Para TODOS-LOS-DIAS nao considerar os dias programados
//-- Para SIN_PROGRAMADOS considerar os dias programados
If nTipo == 2 .And. lTemFerPer
	cAliasSR8 := "QSR8"
	
	BeginSql alias cAliasSR8
		Column R8_DATAINI as Date
		SELECT SR8.R8_FILIAL, SR8.R8_MAT, SR8.R8_TIPOAFA, SR8.R8_PD,
			SR8.R8_DATAINI, SR8.R8_DATAFIM,	SR8.R8_SDPAGAR
		FROM %exp:__cSR8Tab% SR8
		INNER JOIN %exp:__cRCMTab% RCM
		   ON RCM.RCM_TIPOAF = '4'
 		  AND SR8.R8_FILIAL = %exp:cFil%
		  AND SR8.R8_MAT = %exp:cMat%
		  AND SR8.R8_PD = %exp:cPD%
 		  AND SR8.R8_TIPOAFA = RCM.RCM_TIPO
 		  AND SR8.R8_SDPAGAR > 0
 		  AND SR8.R8_DATAINI <= %exp:dData% //MLCM Se incluye condición
 		  AND SR8.%notDel%
	    ORDER BY SR8.R8_DATAINI
	EndSql
	
	While (cAliasSR8)->( !Eof() )
		nDiasProg += (cAliasSR8)->( R8_SDPAGAR )
		(cAliasSR8)->( DbSkip() )
	EndDo
	
	(cAliasSR8)->(DbCloseArea())
	nDias := nDias - nDiasProg
EndIf

Return(nDias)

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³fGetAcumul	³ Autor ³Mauricio Takakura     ³ Data ³30/11/2007³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Retorna o Total dos Acumuladores                             ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL															 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³SIGAGPE     												 ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function fGetAcumul( cTipo		,;  // Tipo que deseja apurar: 1-suma importes, 2-suma unidades / 3-importes empresa, 4-unidades empresa / 5-Importe Total, 6-Unidades Total
					 cProces	,;	// Codigo do Processo
					 cPd		,;	// Codigo da Verba
					 cCriterio	,;	// Criterio de acumulacao
					 cSeqIni	,;	// Sequencia Inicial da Busca
					 cSeqFim	,;	// Sequencia final da busca
					 cFilAcum	,;	// Filias a serem acumuladas
					 cFiltro    ,;  // Condicao das verbas (caso este parametro seja informado, nao eh necessario informar Codigo da Verba, nem criterio de Acumulacao).
					 cAnoIni    ,;  // Ano inicial para busca nos acumulados
					 cAnoFim  )  // Ano final para busca nos acumulados
					 
Local cAliasRG7 := "QRG7"
Local cFields
Local cExpFilter
Local cFil		:= SRA->RA_FILIAL
Local cMat		:= SRA->RA_MAT
Local cPrefix 	:= ""
Local cPrim
Local cUlti
Local cAux
Local cFilAtu
Local cTipoCod
Local lSoma		:= .T.
Local nResult	:= 0
Local nAuxSeqIni:= 0  
Local nPosIni   := 0
Local nPosFim   := 0
Local nQtdRG7   := 0
Local nPosAux	:= 0
Local cAuxAcum  := ""
Local cAuxParam :=cFiltro

DEFAULT cTipo 	:= '1'

//Evitar problemas de chamadas do fGetAcumul, fora do GPEXFOR1
If type("cFiltro_Acum") != "U" 
	cAuxAcum:=cFiltro_Acum		
EndIf

If cTipo $ '1/2'
	DEFAULT cProces := SRA->RA_PROCES
EndIf

//Valida Ano incial e final para avaliacao no RG7.
If !Empty(cAnoIni) 
	cAnoAcuIni:= cAnoInI
Endif
If !Empty(cAnoFim) 
	cAnoAcuFim:= cAnoFim
Endif
If Empty(cAnoAcuIni)
	cAnoAcuIni	:= RCH->RCH_ANO
ElseIf Valtype(cAnoAcuIni) == "N"
	cAnoAcuIni := AllTrim(Str(cAnoAcuIni))
Endif

If Empty(cAnoAcuFim)
	cAnoAcuFim	:= RCH->RCH_ANO
ElseIf Valtype(cAnoAcuFim) == "N"
	cAnoAcuFim := AllTrim(Str(cAnoAcuFim))
Endif    

If Val(cAnoAcuFim) < Val(cAnoAcuIni)
	cAnoAcuFim := cAnoAcuIni
EndIf

//Valida Sequencia caixas para avaliacao no RG7,
//caso a faixa de inicial e final seja diferente
//manter a sequencia escolhida no parametro. 
If Empty(cSeqIni)
	cSeqIni	:= '00'
EndIf
If Empty(cSeqFim)
	cSeqFim	:= '00'
EndIf
cSeqIni := Val(cSeqIni)
cSeqFim	:= Val(cSeqFim)

If Val(cAnoAcuFim) = Val(cAnoAcuIni)
	If cSeqFim < cSeqIni
		cSeqFim	:= cSeqIni
	EndIf
	If cSeqFim == 0
		Return( cSeqFim ) 
	EndIf
EndIf

// Validar se a Sequencia Inicial vem de valores fixos ou de mnemonicos
// Se eh mnemonicos, executar para identificar o valor das variaveis.
If cTipo $ '1/3/5'
	cPrefix := 'RG7_ACUM'
ElseIf cTipo $ '2/4/6'
	cPrefix := 'RG7_HRS'
EndIf

cFields 	:= "%"
nAuxSeqIni  := cSeqIni
If cAnoAcuIni == cAnoAcuFim
	For cSeqIni := nAuxSeqIni To cSeqFim
		cFields += cPrefix + StrZero(cSeqIni,2) + If(cSeqIni < cSeqFim, ', ', '')
	Next cSeqIni
Else
	For cSeqIni := 1 To 13
		cFields += cPrefix + StrZero(cSeqIni,2) + If(cSeqIni < 13, ', ', '')
	Next cSeqIni
EndIf
cFields += "%"

//-- Para os operadores IMPORTE_EMPRESA e UNIDADES_EMPRESA desprezar o Processo do Funcionario
If cTipo $ '5/6'
	cExpFilter := ''
ElseIf cTipo $ '3/4'
	// Verificar quais as filiais que deverá compor o filtro para soma dos valores
	DEFAULT cFilAcum := "'" + SRA->RA_FILIAL + "'"

	cPrim := Substr(Alltrim(cFilAcum),1,1)
	cUlti := Substr(Alltrim(cFilAcum),len(Alltrim(cFilAcum)),1)
	If (cPrim == '"' .or. cPrim == "'") .and. (cUlti == '"' .or. cUlti == "'")
		cFilAcum := substr(alltrim(cFilAcum),2,len(alltrim(cFilAcum))-2)
	EndIf
	cFilAtu := cFilAcum
	cFilAcum := ""
	While Len(cFilAtu) > 0
		cAux := alltrim(if(at(",",cFilAtu) > 0, substr(cFilAtu, 1, at(",",cFilAtu)-1), cFilAtu))
		cFilAcum += "'" + cAux + "',"
		cFilAtu := If(at(",", cFilAtu)==0, "", substr(cFilAtu, at(",", cFilAtu) + 1))
	Enddo
	cFilAcum := Substr(cFilAcum,1,Len( cFilAcum )-1)
	cExpFilter := "RG7_FILIAL IN ( " + cFilAcum + " ) AND "
Else
	cExpFilter := " RG7_PROCES = '" + cProces + "' AND "
EndIf                                    
 
//Garantia que a variável cFiltro não foi informada  na chamada de fGetAcumul
If Empty(cFiltro) .and. !empty(cAuxAcum) 
		cFiltro:= cAuxAcum 
EndIf
 
If !Empty(cFiltro)

	If ( nPosAux := aScan( __aFiltro, { |x|, x[1]+X[2]+x[3] == cFiltro + __xFilSRV + 'EXP' } ) ) > 0
		cExpFilter 	+= __aFiltro[nPosAux,4]
	Else
		cPd:= ""    
		dbSelectArea("SRV")
		SRV->(dbSetOrder( nOrdSrv ))
		SRV->(dbSeek( __xFilSRV, .F.) )  	 
		While SRV->(!Eof()) .And. SRV->RV_FILIAL == __xFilSRV
			If &cFiltro
				cPd+= "'" + SRV->RV_COD + "'," 
			Endif   
			SRV->(dbSkip())
		End   
		If cPd <> ""   
			cPd := Substr(cPd,1,Len( cPd )-1)
			cExpFilter += " RG7_PD IN ( " + cPd + " ) AND "	
			aAdd(__aFiltro,{cFiltro,__xFilSRV,'EXP'," RG7_PD IN ( " + cPd + " ) AND "	,''})
		Else
			cExpFilter += " RG7_PD IN ( '0' ) AND "  //Se a variavel cPd estiver vazia nao retornara nenhuma verba e o retorno será zero.
			aAdd(__aFiltro,{cFiltro,__xFilSRV,'EXP'," RG7_PD IN ( '0' ) AND "	,''})
		EndIf
	EndIf
EndIf

cExpFilter += "D_E_L_E_T_ = ' '"
cExpFilter := '%' + cExpFilter + '%'  
                                
If Empty(cAuxParam) .and. Empty(cAuxAcum) 
	BeginSql alias cAliasRG7
		SELECT RG7_PD, RG7_ANOINI, RG7_ANOFIM, %exp:cFields%   
		FROM %exp:__cRG7Tab% RG7
		WHERE RG7.RG7_MAT  = %exp:cMat%
		  AND RG7.RG7_PD = %exp:cPd%
		  AND RG7_ANOINI >= %exp:cAnoAcuIni%
		  AND RG7_ANOFIM <= %exp:cAnoAcuFim%
		  AND RG7_CODCRI = %exp:cCriterio%
		  AND %exp:cExpFilter%
	EndSql            
Else 
	
	If !Empty(cAuxAcum) //Se foi usado o operador FILTRO_ACUM
		
		BeginSql alias cAliasRG7
			SELECT RG7_PD, RG7_ANOINI, RG7_ANOFIM, %exp:cFields%    
			FROM %exp:__cRG7Tab% RG7
			WHERE RG7.RG7_MAT  = %exp:cMat%
			  AND RG7_ANOINI >= %exp:cAnoAcuIni%
			  AND RG7_ANOFIM <= %exp:cAnoAcuFim% 
			  AND RG7_CODCRI = %exp:cCriterio%
			  AND %exp:cExpFilter% 
		EndSql
	
	Else //na chamada da função usou-se o parametro "Filtro"
	
		BeginSql alias cAliasRG7
			SELECT RG7_PD, RG7_ANOINI, RG7_ANOFIM, %exp:cFields%    
			FROM %exp:__cRG7Tab% RG7
			WHERE RG7.RG7_MAT  = %exp:cMat%
			  AND RG7_ANOINI >= %exp:cAnoAcuIni%
			  AND RG7_ANOFIM <= %exp:cAnoAcuFim%
			  AND %exp:cExpFilter%
		EndSql    
	EndIf
	
Endif

If (cAliasRG7)->( !Eof() )
	nResult := 0
	Count to nQtdRG7

	(cAliasRG7)->( dbGoTop() )
	
	While (cAliasRG7)->( !Eof() )
		//# Posiciona a verba pra saber se eh Prov/Desc
		//--> Para o Mexico sempre devera somar tudo, pois utiliza somente para modelo 2 e sempre sera por verba por processo - lee-se sempre 1 verba
		If cPaisLoc == "MEX"
			cTipoCod := "1/2/3/4"
		Else
			cTipoCod := "1/3"
		EndIf
		
		lSoma := (RetValSrv((cAliasRG7)->RG7_PD, SRA->RA_FILIAL, "RV_TIPOCOD") $ cTipoCod )
		nPosIni := nPosFim := 0

		// Verifica se o RG7 trabalha com periodos diferentes para o mesmo registro
		// exemplo de Costa Rica, onde o acumulado do ano se inicia em outubro, ao
		// contrario do Mexico que cada linha do RG7 e um periodo inteiro de Jan-Dez.
		//CONOUT(AllTrim(Str(nQtdRG7)) + " registros localizados")
		If (cAliasRG7)->RG7_ANOINI == (cAliasRG7)->RG7_ANOFIM
			If cAnoAcuIni == cAnoAcuFim
				nPosIni := nAuxSeqIni
				nPosFim := cSeqFim
			EndIf	
        Else
	        If nQtdRG7 = 1
				if cSeqFim < nAuxSeqIni
					nPosIni := nAuxSeqIni
					nPosFim := 13
                else
					nPosIni := nAuxSeqIni
					nPosFim := cSeqFim
				EndIf	
			EndIf	
        EndIf

        If nPosIni = 0
			If (cAliasRG7)->RG7_ANOINI == cAnoAcuIni
				nPosIni := nAuxSeqIni
				nPosFim := 13
			ElseIf ((cAliasRG7)->RG7_ANOINI != cAnoAcuIni) .and. ((cAliasRG7)->RG7_ANOFIM != cAnoAcuFim)
				nPosIni := 1
				nPosFim := 13
			ElseIf (cAliasRG7)->RG7_ANOFIM == cAnoAcuFim
				nPosIni := 1
				nPosFim := cSeqFim
			EndIf			
        EndIf

		For cSeqIni := nPosIni To nPosFim
			cFields := cPrefix + StrZero(cSeqIni,2)
			If lSoma
				nResult += (cAliasRG7)->( &cFields )
			Else
				nResult -= (cAliasRG7)->( &cFields )
			EndIf
		Next cSeqIni
		
		(cAliasRG7)->( DbSkip() )
	EndDo
EndIf

(cAliasRG7)->( DbCloseArea() )

Return( nResult )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³ConvData	³ Autor ³Mauricio Takakura     ³ Data ³18/10/2007³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Converte uma data numerica (aaaammdd) Data Gregoriana        ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL															 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³SIGAGPE     												 ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function ConvData(cData)
     
if valtype(cData) == "N"
	cData := str(cData)
endif

cData := Alltrim( cData )
If Len( cData ) == 8
	cData := dtoc( stod( cData ) )
ElseIf Len( cData ) == 7
	cAno := Substr( cData, 1,4 )
	cMes := '0'+Substr( cData, 5,1 )
	cDia := Substr( cData, 6,2 )
	cData := dtoc( stod( cData ) )
Else
	cData := '//'
EndIf

Return( cData )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³fGetPdRot	³ Autor ³Mauricio Takakura     ³ Data ³02/10/2007³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Carrega em array as verbas e verbas por processo		     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL															 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³SIGAGPE     												 ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function fGetPdRot(aVerbas, aVerbaRot, aTables, cProces, cRoteiro, lRM_Habil)

Local aArea			:= GetArea()
Local aFields		:= {}

Local cFields 		:= ""
Local cFilSRM 		:= xFilial( "SRM" )
Local cFilSRV		:= xFilial( "SRV" )
Local cAliasSRM		:= "SRM"
Local cAliasSRV		:= "SRV"
Local cDelet		:= ""
Local cRM_Habilit   := ""

Local lRet 			:= .T.

Local nI, nX
Local nPos			:= 0
Local nFields		:= 0
Local nItens		:= 0
Local nFieldPos		:= 0

DEFAULT aVerbas		:= {}
DEFAULT aVerbaRot	:= {}
DEFAULT aTables 	:= {}
DEFAULT lRM_Habil   := .F.

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Geracao do Array de Verbas por Processo                       ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
nPos := aScan( aTables, { |x| x[1] = "SRM" } )
If nPos > 0
	aFields := aClone( aTables[ nPos, 2 ] )
Else
	aFields := GdMontaHeader(  	NIL				,;	//01 -> Por Referencia contera o numero de campos em Uso
	  		   				    NIL				,;	//02 -> Por Referencia contera os Campos do Cabecalho da GetDados que sao Virtuais
				    			NIL				,;	//03 -> Por Referencia contera os Campos do Cabecalho da GetDados que sao Visuais
				 				"SRM"			,;	//04 -> Opcional, Alias do Arquivo Para Montagem do aHeader
								NIL				,;	//05 -> Opcional, Campos que nao Deverao constar no aHeader
								NIL				,;	//06 -> Opcional, Carregar Todos os Campos	
								.T.				,;	//07 -> Nao Carrega os Campos Virtuais
								NIL				,;	//08 -> Carregar Coluna Fantasma e/ou BitMap ( Logico ou Array )
								NIL				,;	//09 -> Inverte a Condicao de aNotFields carregando apenas os campos ai definidos
								.T.				,;	//10 -> Verifica se Deve Checar se o campo eh usado
								NIL				,;	//11 -> Verifica se Deve Checar o nivel do usuario
								NIL				,;	//12 -> Utiliza Numeracao na GhostCol
								.T.				 ;	//13 -> Carrega os Campos de Usuario
				   			)
EndIf

nFields := Len( aFields )
cFields := ""
For nI := 1 To nFields
	cFields += aFields[nI, __AHEADER_FIELD__] + ", "
Next nI
cFields := "%" + Substr( cFields, 1, Len(cFields)-2) + "%"

If  lRM_Habil
	cRM_Habilit := "%D_E_L_E_T_ = ' ' AND SRM.RM_HABILIT = '1' %"
Else
	cRM_Habilit :=  __cDelete 
Endif
cAliasSRM := "QSRM"
BeginSql alias cAliasSRM
	SELECT SRM.RM_FILIAL, %exp:cFields%
	FROM %exp:__cSRMTab% SRM
	WHERE SRM.RM_FILIAL  = %exp:cFilSRM%
	  AND SRM.RM_PROCES  = %exp:cProces%
	  AND SRM.RM_CALCULO = %exp:cRoteiro%
	  AND %exp:cRM_Habilit%
	ORDER BY SRM.RM_SEQ
EndSql

While (cAliasSRM)->( !Eof() )

	aAdd( aVerbaRot, {} )
	nPos := Len( aVerbaRot )
	For nI := 1 To nFields
		cFields := aFields[nI, __AHEADER_FIELD__]
		aAdd( aVerbaRot[ nPos ], (cAliasSRM)->( &cFields ) )
	Next nI

	(cAliasSRM)->( DbSkip() )
EndDo
(cAliasSRM)->(DbCloseArea())

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Geracao do Array de Verbas que compoem o Verbas por Processo  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
nPos := aScan( aTables, { |x| x[1] = "SRV" } )
If nPos > 0
	aFields := aClone( aTables[ nPos, 2 ] )
Else
	aFields := GdMontaHeader(  	NIL				,;	//01 -> Por Referencia contera o numero de campos em Uso
	  		   				    NIL				,;	//02 -> Por Referencia contera os Campos do Cabecalho da GetDados que sao Virtuais
				    			NIL				,;	//03 -> Por Referencia contera os Campos do Cabecalho da GetDados que sao Visuais
				 				"SRV"			,;	//04 -> Opcional, Alias do Arquivo Para Montagem do aHeader
								NIL				,;	//05 -> Opcional, Campos que nao Deverao constar no aHeader
								NIL				,;	//06 -> Opcional, Carregar Todos os Campos	
								.T.				,;	//07 -> Nao Carrega os Campos Virtuais
								NIL				,;	//08 -> Carregar Coluna Fantasma e/ou BitMap ( Logico ou Array )
								NIL				,;	//09 -> Inverte a Condicao de aNotFields carregando apenas os campos ai definidos
								.T.				,;	//10 -> Verifica se Deve Checar se o campo eh usado
								NIL				,;	//11 -> Verifica se Deve Checar o nivel do usuario
								NIL				,;	//12 -> Utiliza Numeracao na GhostCol
								.T.				 ;	//13 -> Carrega os Campos de Usuario
				   			)
EndIf

nFields := Len( aFields )
cFields := ""
For nI := 1 To nFields
	cFields += aFields[nI, __AHEADER_FIELD__] + ", "
Next nI
cFields := "%" + Substr( cFields, 1, Len(cFields)-2) + "%"

cDelet := "% SRM.D_E_L_E_T_ = ' ' AND SRV.D_E_L_E_T_ = ' ' %"

cAliasSRV := "QSRV"
BeginSql alias cAliasSRV
	SELECT SRV.RV_FILIAL, %exp:cFields%
	FROM %exp:__cSRVTab% SRV
		INNER JOIN %exp:__cSRMTab% SRM 
		   ON SRM.RM_FILIAL = %exp:cFilSRM%
		  AND SRM.RM_CALCULO = %exp:cRoteiro%
		  AND SRM.RM_PROCES = %exp:cProces%
		  AND SRV.RV_FILIAL = %exp:cFilSRV%
		  AND SRV.RV_COD = SRM.RM_VERBA
		  AND %exp:cDelet%
EndSql

While (cAliasSRV)->( !Eof() )

	aAdd( aVerbas, {} )
	nPos := Len( aVerbas )
	For nI := 1 To nFields
		cFields := aFields[nI, __AHEADER_FIELD__]
		aAdd( aVerbas[ nPos ], (cAliasSRV)->( &cFields ) )
	Next nI

	(cAliasSRV)->( DbSkip() )
EndDo
(cAliasSRV)->(DbCloseArea())

If Empty(aVerbas) .and. Empty(aVerbaRot)
	lRet := .F.
EndIf

RestArea( aArea )

Return( lRet )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³fGetIncid	³ Autor ³Mauricio Takakura     ³ Data ³11/10/2007³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Carrega o array de Incidencias                  		     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL															 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³SIGAGPE     												 ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function fGetIncid(	aIncid	,;		// Array com as incidencias do funcionario do periodo selecionado
					cFil	,;		// Filial do Funcionario
					cMat	,;		// Matricula do Funcionario
					cProces	,;		// Processo a pesquisar 
					cRoteiro,;		// Roteiro de Calculo
					cPeriod	,;		// Periodo a processar
					NroPago	,;		// Numero de Pagamento
					aTables  ;		// Array das Tabelas 
				  )

Local aArea		:= GetArea()
Local aRGBTable

Local cField
Local cAliasRGB	:= "QRGB"

Local nX
Local nPos
Local nItem		:= 0
Local nCampos

DEFAULT aIncid := {}

If Empty( aTables )
	GetTableCalc( @aTables )
EndIf

If Empty( __cQryRGB )

	nPos 		:= aScan( aTables, { |x| x[_TABLE_] = "RGB" } )
	aRGBTable 	:= aClone(aTables[nPos])
	cFields		:= ""
	nCampos := Len( aRGBTable[_HEADER_] )

	For nX := 1 To nCampos
		cFields += aRGBTable[_HEADER_, nX, __AHEADER_FIELD__] + ","
	Next nX    
	
	cFields += "R_E_C_N_O_" + " RECNO,"
	
	__cQryRGB := "%" + Substr( cFields,1, Len(cFields)-1) + "%"

EndIf

BeginSql alias cAliasRGB
	SELECT %exp:__cQryRGB%
	FROM %exp:__cRGBTab%
	WHERE RGB_FILIAL = %exp:cFil%
	  AND RGB_MAT = %exp:cMat%
	  AND RGB_PROCES = %exp:cProces%
	  AND RGB_PERIOD = %exp:cPeriod%
	  AND RGB_ROTEIR = %exp:cRoteiro%
	  AND RGB_SEMANA = %exp:NroPago%
	  AND %exp:__cDelete%
    ORDER BY RGB_FILIAL, RGB_MAT, RGB_PD
EndSql

While (cAliasRGB)->(!Eof())

	nPos 		:= aScan( aTables, { |x| x[_TABLE_] = "RGB" } )
	aRGBTable 	:= aClone(aTables[nPos])
	nCampos 	:= Len( aRGBTable[_HEADER_] )

	Aadd( aIncid, Array(nCampos+1) )
	nItem++
	For nX := 1 To nCampos
		cField := aRGBTable[_HEADER_, nX, __AHEADER_FIELD__]
		If cField == "RGB_CODFUN" .and. Empty((cAliasRGB)->( &cField ))
			aIncid[nItem, nX] := SRA->RA_CODFUNC
		Else
			aIncid[nItem, nX] := (cAliasRGB)->( &cField )
		EndIf
	Next nX
	aIncid[nItem, nX] := (cAliasRGB)->( RECNO )

	(cAliasRGB)->(dbSkip())
EndDo

(cAliasRGB)->( DbCloseArea() )
RestArea(aArea)
Return( .T. )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³fGetValFut  ³ Autor ³Mauricio Takakura     ³ Data ³15/10/2007³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Carrega o array de Valores Futuros						     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL															 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³SIGAGPE     												 ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function fGetValFut(aValFut	,;		// Array com os Valores Futuros do Funcionario
					cFil	,;		// Filial do Funcionario
					cMat	,;		// Matricula do Funcionario
					cPeriod	,;		// Periodo que esta se calculando
					cNroPago,;		// Nro de Pagamento
					aTables ,;		// Array das Tabelas 
					cRoteiro ;		// Roteiro de Calculo
				   )

Local aArea		:= GetArea()
Local aSRKTable

Local cFields
Local cAliasSRK	:= "QSRK"

Local nX
Local nPos
Local nItem		:= 0
Local nCampos

Local bBlkCond	:= {||.T.}

DEFAULT aValFut := {}

If Empty( aTables )
	GetTableCalc( @aTables )
EndIf

If Empty( __cQrySRK )

	nPos 		:= aScan( aTables, { |x| x[_TABLE_] = "SRK" } )
	aSRKTable 	:= aClone(aTables[nPos])
	cFields		:= ""
	nCampos 	:= Len( aSRKTable[_HEADER_] )

	For nX := 1 To nCampos
		cFields += aSRKTable[_HEADER_, nX, __AHEADER_FIELD__] + ","
	Next nX
	
	cFields += "R_E_C_N_O_" + " RECNO,"
	
	__cQrySRK := "%" + Substr( cFields,1, Len(cFields)-1) + "%"

EndIf

BeginSql alias cAliasSRK
	SELECT %exp:__cQrySRK%
	FROM %exp:__cSRKTab%
	WHERE RK_FILIAL = %exp:cFil%
	  AND RK_MAT = %exp:cMat%
	  AND RK_VLSALDO <> 0 
	  AND RK_STATUS = '2'
	  AND %exp:__cDelete%
    ORDER BY RK_FILIAL, RK_MAT, RK_PD
EndSql

While (cAliasSRK)->(!Eof()) 
	nPos 		:= aScan( aTables, { |x| x[_TABLE_] = "SRK" } )
	aSRKTable 	:= aClone(aTables[nPos])
	nCampos 	:= Len( aSRKTable[_HEADER_] )
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Para o Mexico considera todos os Valores Futuros na Rescisao ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	If ( (cPaisLoc $ "MEX|CHI") .and. ( fGetTipoRot(cRoteiro) == "4" ) )
		bBlkCond := { || !Eof() }
	Else
		bBlkCond := { || (cAliasSRK)->(RK_PERINI + RK_NUMPAGO) <= (cPeriod + cNroPago) }
	EndIf

	If Eval(bBlkCond)
		Aadd( aValFut, Array(nCampos+1) )
		nItem++
		For nX := 1 To nCampos
			cField := aSRKTable[_HEADER_, nX, __AHEADER_FIELD__]
			aValFut[nItem, nX] := (cAliasSRK)->( &cField )
		Next nX
		aValFut[nItem, nX] := (cAliasSRK)->( RECNO )
	EndIf	
	(cAliasSRK)->(dbSkip())
EndDo

(cAliasSRK)->( DbCloseArea() )
RestArea(aArea)
Return( .T. )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³fGetAfast   ³ Autor ³Mauricio Takakura     ³ Data ³16/10/2007³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Carrega o array de Afastamentos   						     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL															 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³SIGAGPE     												 ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function fGetAfast(	aAfast  ,;		// Array com os Afastamentos
					cFil	,;		// Filial do Funcionario
					cMat	,;		// Matricula do Funcionario
					aTables  ;		// Array das Tabelas 
				   )

Local aArea		:= GetArea()
Local aSR8Table

Local cFields
Local cAliasSR8	:= "QSR8"

Local nX
Local nPos
Local nItem		:= 0
Local nCampos

DEFAULT aAfast := {}

If Empty( aTables )
	GetTableCalc( @aTables )
EndIf

If Empty( __cQrySR8 )

	nPos 		:= aScan( aTables, { |x| x[_TABLE_] = "SR8" } )
	aSR8Table 	:= aClone(aTables[nPos])         
	cFields		:= ""
	nCampos 	:= Len( aSR8Table[_HEADER_] )

	For nX := 1 To nCampos
		cFields += aSR8Table[_HEADER_, nX, __AHEADER_FIELD__] + ","
	Next nX
	
	cFields += "R_E_C_N_O_" + " RECNO,"
	
	__cQrySR8 := "%" + Substr( cFields,1, Len(cFields)-1) + "%"

EndIf

BeginSql alias cAliasSR8
	Column R8_DATAINI as Date
	Column R8_DATAFIM as Date
	SELECT %exp:__cQrySR8%
	FROM %table:SR8%
	WHERE R8_FILIAL = %exp:cFil%
	  AND R8_MAT = %exp:cMat%
	  AND ( R8_SDPAGAR <> 0 OR R8_DURACAO <> R8_DPAGOS OR R8_DATAFIM = ' ')
	  AND %NotDel%
	ORDER BY R8_FILIAL, R8_MAT, R8_PD, R8_DATAINI
EndSql

nPos 		:= aScan( aTables, { |x| x[_TABLE_] = "SR8" } )
aSR8Table 	:= aClone(aTables[nPos])
nCampos 	:= Len( aSR8Table[_HEADER_] )

While (cAliasSR8)->(!Eof())
	Aadd( aAfast, Array(nCampos+1) )
	nItem++
	For nX := 1 To nCampos
		cField := aSR8Table[_HEADER_, nX, __AHEADER_FIELD__]
		aAfast[nItem, nX] := (cAliasSR8)->( &cField )
	Next nX
	aAfast[nItem, nX] := (cAliasSR8)->( RECNO )
	
	(cAliasSR8)->(dbSkip())
EndDo

(cAliasSR8)->( DbCloseArea() )
RestArea(aArea)
Return( .T. )        


/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³fGetLanFix  ³ Autor ³Christiane Vieira     ³ Data ³01/07/2011³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Carrega o array de Lançamentos Fixos				     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL															 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³SIGAGPE     												 ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function fGetLanFix(aLanFix ,;		// Array com os Lançamentos Fixos
					cFil	,;		// Filial do Funcionario
					cMat	,;		// Matricula do Funcionario
					aTables  ;		// Array das Tabelas 
				   )

Local aArea		:= GetArea()
Local aRG1Table

Local cFields
Local cAliasRG1	:= "QRG1"

Local nX
Local nPos 		:= 0
Local nItem		:= 0
Local nCampos

DEFAULT aLanFix := {}

If Empty( aTables )
	GetTableCalc( @aTables )
EndIf

If Empty( __cQryRG1 )

	nPos 		:= aScan( aTables, { |x| x[_TABLE_] = "RG1" } )
	aRG1Table 	:= aClone(aTables[nPos])         
	cFields		:= ""
	nCampos 	:= Len( aRG1Table[_HEADER_] )

	For nX := 1 To nCampos
		cFields += aRG1Table[_HEADER_, nX, __AHEADER_FIELD__] + ","
	Next nX
	
	cFields += "R_E_C_N_O_" + " RECNO,"
		
	__cQryRG1 := "%" + Substr( cFields,1, Len(cFields)-1) + "%"

EndIf
	
BeginSql alias cAliasRG1
	SELECT %exp:__cQryRG1%
	FROM %exp:__cRG1Tab% RG1
	WHERE RG1_FILIAL = %exp:cFil%
	  AND RG1_MAT = %exp:cMat%
	  AND %exp:__cDelete%
	ORDER BY RG1_FILIAL, RG1_MAT, RG1_PD, RG1_DINIPG
EndSql
	
While (cAliasRG1)->(!Eof())

	nPos 		:= aScan( aTables, { |x| x[_TABLE_] = "RG1" } )
	aRG1Table 	:= aClone(aTables[nPos])         
	nCampos 	:= Len( aRG1Table[_HEADER_] )
	
	Aadd( aLanFix, Array(nCampos+1) )
	nItem++
	For nX := 1 To nCampos
		cField := aRG1Table[_HEADER_, nX, __AHEADER_FIELD__]
		aLanFix[nItem, nX] := (cAliasRG1)->( &cField )
	Next nX
	aLanFix[nItem, nX] := (cAliasRG1)->( RECNO )
		
	(cAliasRG1)->(dbSkip())
EndDo
	
(cAliasRG1)->( DbCloseArea() )
RestArea(aArea)

Return( .T. )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³fGetTrajLab ³ Autor ³Mauricio Takakura     ³ Data ³13/11/2007³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Carrega o array de Trajetoria Laboral					     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL															 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³SIGAGPE     												 ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function fGetTrajLab(	aTrajLab,;		// Array com a Trajetoria Laboral
	   							cFil	,;		// Filial do Funcionario
								cMat	,;		// Matricula do Funcionario
								dDataIni,;		// Data de Inicio da Trajetoria
								dDataFim,;		// Data Final da Trajetoria
								cTipos	,;		// Tipo da Trajetoria 
								aTables  ;		// Array das Tabelas
						    )

Local aArea		:= GetArea()
Local aRCPTable

Local cCodTip
Local cFields
Local cAliasRCP	:= "QRCP"

Local nX
Local nPos
Local nItem		:= 0
Local nCampos

DEFAULT cFil	 := SRA->RA_FILIAL
DEFAULT cMat 	 := SRA->RA_MAT

//- Nao foi utilizado DEFAULT porque vem no formato data com "  /  /  " e nao esta como NIL
If Empty(dDataIni) .Or. !(ValType(dDataIni) $ "C/D")
	dDataIni := RCH->RCH_DTINI
EndIf
If Empty(dDataFim) .Or. !(ValType(dDataFim) $ "C/D")
	dDataFim := RCH->RCH_DTFIM
EndIf

If ValType(dDataIni) == "C"
	dDataIni := Ctod( dDataIni )
EndIf
If ValType(dDataFim) == "C"
	dDataFim := Ctod( dDataFim )
EndIf

//- Carregar somente os itens gerados pelo select
aTrajLab := {}
If Empty( aTables )
	GetTableCalc( @aTables )
EndIf

If AllTrim(cTipos) == "*" .Or. Empty(AllTrim(cTipos))
	cTipos := "%%"
Else
	//- Separar os diversos Codigos para utilizar na instrucao IN
	nTam := Len(cTipos)
	cCodTip := ""
	While nTam > 0
		nPos := At(',', cTipos)
		If nPos > 0
			cCodTip += "'" + Substr(cTipos, 1, nPos-1) + "'"
			cTipos := Substr(cTipos, nPos+1)
			If !Empty(cTipos)
				cCodTip += "," 
			EndIf
		Else
			cCodTip += "'" + cTipos + "'"
			cTipos := ""
		EndIf
		nTam := Len(cTipos)
	EndDo
	cTipos := "% AND RCP_TPMOV IN (" + cCodTip + ")%" 
EndIf

nPos 		:= aScan( aTables, { |x| x[_TABLE_] = "RCP" } )
aRCPTable 	:= aClone(aTables[nPos])
cFields		:= ""
nCampos := Len( aRCPTable[_HEADER_] )

For nX := 1 To nCampos
	cFields += aRCPTable[_HEADER_, nX, __AHEADER_FIELD__] + ","
Next nX

cFields += "R_E_C_N_O_ RECNO,"
cFields := "%" + Substr( cFields,1, Len(cFields)-1) + "%"

//- Quando houver data de inicio, devera trazer um registro anterior a da data de inicio
//- Geracao de query para localizar qual a data do registro anterior a da data solicitada
BeginSql alias cAliasRCP
	SELECT MAX(RCP_DTMOV) RCP_DTMOV
	FROM %exp:__cRCPTab%
	WHERE RCP_FILIAL = %exp:cFil%
	  AND RCP_MAT = %exp:cMat%
  	  AND RCP_DTMOV <= %exp:dDataIni%
	  AND (%exp:__cDelete%)
EndSql

If !Empty((cAliasRCP)->(RCP_DTMOV))
	dDataIni := (cAliasRCP)->(RCP_DTMOV)
EndIf
(cAliasRCP)->(DbCloseArea())

//-- O Sistema ira ler os registros da data mais recente para a mais antiga
BeginSql alias cAliasRCP
	Column RCP_DTMOV as Date
	SELECT %exp:cFields%
	FROM %exp:__cRCPTab%
	WHERE RCP_FILIAL = %exp:cFil%
	  AND RCP_MAT = %exp:cMat%
	  AND RCP_DTMOV BETWEEN %exp:dDataIni% AND %exp:dDataFim%
	  AND (%exp:__cDelete%)
	  %exp:cTipos%
	  ORDER BY RCP_DTMOV DESC
EndSql

//-- Quando nao existir registros para os filtros selecionados, o sistema devera carrega o ultimo registro
If (cAliasRCP)->( Eof() )

	(cAliasRCP)->(DbCloseArea())
	
	//-- Buscar a maior data dos registros para retornar os registros
	BeginSql alias cAliasRCP
		SELECT MAX(RCP_DTMOV) RCP_DTMOV
		FROM %exp:__cRCPTab%
		WHERE RCP_FILIAL = %exp:cFil%
		  AND RCP_MAT = %exp:cMat%
		  AND %exp:__cDelete%
	EndSql
	dDataIni := (cAliasRCP)->RCP_DTMOV
	(cAliasRCP)->(DbCloseArea())
	
	//-- Buscar todos os registros com a data encontrada acima
	BeginSql alias cAliasRCP
		Column RCP_DTMOV as Date
		SELECT %exp:cFields%
		FROM %exp:__cRCPTab%
		WHERE RCP_FILIAL = %exp:cFil%
		  AND RCP_MAT = %exp:cMat%
		  AND RCP_DTMOV = %exp:dDataIni%
		  AND %exp:__cDelete%
	EndSql
EndIf

//-- Geracao das informacoes no array de Trajetoria Laboral do Funcionario
While (cAliasRCP)->(!Eof())
	Aadd( aTrajLab, Array(nCampos+1) )
	nItem++
	For nX := 1 To nCampos
		cField := aRCPTable[_HEADER_, nX, __AHEADER_FIELD__]
		aTrajLab[nItem, nX] := (cAliasRCP)->( &cField )
	Next nX
	aTrajLab[nItem, nX] := (cAliasRCP)->( RECNO )

	(cAliasRCP)->(dbSkip())
EndDo
(cAliasRCP)->( DbCloseArea() )

RestArea(aArea)

Return( .T. )
       
/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³fDiasTray	³ Autor ³Mauricio Takakura     ³ Data ³15/11/2007³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Retorna o dias De Trajetoria Laboral entre a posicionada e a ³
³          ³seguinte.                                                    ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL															 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³SIGAGPE     												 ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function fDiasTray( aTables, aTrajLab, nPosTrajLab, dDtIniTraj, dDtFimTraj )

Local nPosRCP 	:= aScan( aTables, { |x| x[1] = "RCP" } )
Local nPosField	:= GdFieldPos( "RCP_DTMOV"	, aTables[nPosRCP, _HEADER_] )
Local nQtTraj	:= Len( aTrajLab )

//Se determina si utilizará Días 360 para el cálculo de días entre dos fechas.
Local lDias360	:= (SuperGetMV("MV_DIAS360", .F., 2) == 1) //1 = 360 / 2 = 365

If ValType( dDtIniTraj ) == "C"
	dDtIniTraj := Ctod( dDtIniTraj )
EndIf
If ValType( dDtFimTraj ) == "C"
	dDtFimTraj := Ctod( dDtFimTraj )
EndIf

//-- Se for somente 1 registro ou quando retornar 1 registro antes da data de Inicio
If nPosTrajLab == 1 .Or. nQtTraj == 1
	// Quando o intervalo de datas (Inicio e Fim) estiver fora do ultimo registro da tabela RCP
	// a geracao sempre traz este ultimo. Nesse caso devera subtrair as datas que estao na 
	// formula. 
	If aTrajLab[nPosTrajLab, nPosField] > dDtIniTraj
		dDtIniTraj := aTrajLab[nPosTrajLab, nPosField]
	EndIf	
ElseIf nPosTrajLab == nQtTraj
	If aTrajLab[nPosTrajLab-1, nPosField] > dDtIniTraj
		dDtFimTraj := aTrajLab[nPosTrajLab-1, nPosField] - 1
	EndIf
Else
	If aTrajLab[nPosTrajLab, nPosField] > dDtIniTraj
		dDtIniTraj := aTrajLab[nPosTrajLab, nPosField]
	EndIf
	dDtFimTraj := aTrajLab[nPosTrajLab-1, nPosField] - 1
EndIf

If lDias360
	nDiasTraj := fDias360(dDtIniTraj, dDtFimTraj, aMnemonicos)
Else
	nDiasTraj := DateDiffDay(dDtFimTraj, dDtIniTraj) + 1
EndIf

If nDiasTraj < 0
	nDiasTraj := 0
EndIf

Return( nDiasTraj )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³fGetDepend  ³ Autor ³Mauricio Takakura     ³ Data ³13/11/2007³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Carrega o array de Dependentes       					     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL															 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³SIGAGPE     												 ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function fGetDepend(	aDependiente,;	// Array com os Dependentes  
	   						cFil	,;		// Filial do Funcionario
							cMat	,;		// Matricula do Funcionario
							cTipos	,;		// Tipo de Dependiente para Filtrar
							aTables  ;		// Array das Tabelas
						   )

Local aArea		:= GetArea()
Local aSRBTable

Local cCodTip
Local cFields
Local cAliasSRB	:= "QSRB"

Local nX
Local nPos
Local nItem		:= 0
Local nCampos

DEFAULT cFil	 := SRA->RA_FILIAL
DEFAULT cMat 	 := SRA->RA_MAT

//- Carregar somente os itens gerados pelo select
aDependiente := {}
If Empty( aTables )
	GetTableCalc( @aTables )
EndIf

If AllTrim(cTipos) == "*" .Or. Empty(AllTrim(cTipos))
	cTipos := "%%"
Else
	//- Separar os diversos Codigos para utilizar na instrucao IN
	nTam := Len(cTipos)
	cCodTip := ""
	While nTam > 0
		nPos := At(',', cTipos)
		If nPos > 0
			cCodTip += "'" + Substr(cTipos, 1, nPos-1) + "'"
			cTipos := Substr(cTipos, nPos+1)
			If !Empty(cTipos)
				cCodTip += "," 
			EndIf
		Else
			cCodTip += "'" + cTipos + "'"
			cTipos := ""
		EndIf
		nTam := Len(cTipos)
	EndDo
	cTipos := "% AND RB_GRAUPAR IN (" + cCodTip + ")%" 
EndIf

If Empty( __cQryDep )

	nPos 		:= aScan( aTables, { |x| x[_TABLE_] = "SRB" } )
	aSRBTable 	:= aClone(aTables[nPos])
	cFields		:= ""
	nCampos := Len( aSRBTable[_HEADER_] )

	For nX := 1 To nCampos
		cFields += aSRBTable[_HEADER_, nX, __AHEADER_FIELD__] + ","
	Next nX
    
	cFields += "R_E_C_N_O_" + " RECNO,"
	
	__cQryDep := "%" + Substr( cFields,1, Len(cFields)-1) + "%"

EndIf

//-- Leitura dos registros por ordem de Sequencia
BeginSql alias cAliasSRB
	SELECT %exp:__cQryDep%
	FROM %exp:__cSRBtab%
	WHERE RB_FILIAL = %exp:cFil%
	  AND RB_MAT = %exp:cMat%
	  AND (%exp:__cDelete%)
	  %exp:cTipos%
	  ORDER BY RB_COD
EndSql

//-- Geracao das informacoes no array de Trajetoria Laboral do Funcionario
While (cAliasSRB)->(!Eof())

	nPos 		:= aScan( aTables, { |x| x[_TABLE_] = "SRB" } )
	aSRBTable 	:= aClone(aTables[nPos])
	nCampos := Len( aSRBTable[_HEADER_] )

	Aadd( aDependiente, Array(nCampos+1) )
	nItem++
	For nX := 1 To nCampos
		cField := aSRBTable[_HEADER_, nX, __AHEADER_FIELD__]
		aDependiente[nItem, nX] := (cAliasSRB)->( &cField )
	Next nX
	aDependiente[nItem, nX] := (cAliasSRB)->( RECNO )

	(cAliasSRB)->(dbSkip())
EndDo
(cAliasSRB)->( DbCloseArea() )

RestArea(aArea)

Return( .T. )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³fDelMovSRC	³ Autor ³Mauricio Takakura     ³ Data ³16/10/2007³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Exclusao dos Registros da Tabela de Movimentos  		     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL															 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³SIGAGPE     												 ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function fDelMovSRC(cRoteiro, cPeriodo, cNumPag, cFilter)

Local cAliasSRC	:= "QSRC"
Local cDelet
Local cQuery
Local cNameDB
Local cSRCSqlName
Local cSRCSqlN2
Local cCpoRecno
Local cQueryDelet
Local cFilRecno
Local cFilterAux := ""

Local lRet 		:= .T.

Local nMinRec	:= 0
Local nMaxRec	:= 0

DEFAULT cFilter := ""

cSRCSqlName := __cSRCtab
cSRCSqlN2 	:= '%'+__cSRCtab+'%'

cDelet 		:= "% SRC.D_E_L_E_T_ = ' ' AND SRA.D_E_L_E_T_ = ' ' %"
cCpoRecno 	:= "R_E_C_N_O_"

cFilterAux := Substr( cFilter, 1, Len(cFilter)-1 )
cFilterAux := Substr( cFilterAux, 2, Len(cFilterAux)-1 )

cFilter := Substr( cFilter, 1, Len(cFilter)-1 )
cFilter += " AND SRC.RC_FILIAL = SRA.RA_FILIAL " 
cFilter += " AND SRC.RC_MAT = SRA.RA_MAT "
cFilter += " AND SRC.RC_PROCES = SRA.RA_PROCES"
cFilter += " AND SRC.RC_PERIODO = '" + cPeriodo + "'"
cFilter += " AND SRC.RC_SEMANA = '" + cNumPag + "'"
cFilter += " AND SRC.RC_ROTEIR = '" + cRoteiro + "'%"

BeginSql alias cAliasSRC
	SELECT MIN(SRC.R_E_C_N_O_) MINREC, MAX(SRC.R_E_C_N_O_) MAXREC
	FROM %exp:cSRCSqlN2% SRC
	INNER JOIN %exp:__cSRATab% SRA 
	   ON %exp:cFilter%
	  AND %exp:cDelet%
EndSql

nMinRec := (cAliasSRC)->( MINREC )
nMaxRec := (cAliasSRC)->( MAXREC )

(cAliasSRC)->( DbCloseArea() )

cFilter := Substr( cFilter, 2, (Len(cFilter)-2) )

cQuery := " DELETE "

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³O banco DB2 nao aceita o nome da tabela apos o comando DELETE			 ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
cNameDB	:= Upper(TcGetDb())

If !( cNameDB $ "DB2_ORACLE_INFORMIX_POSTGRES" )
	cQuery += cSRCSqlName
EndIf

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³O Informix precisa do nome da tabela ao inves do Alias no comando DELETE³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
If ( cNameDB $ "INFORMIX" )
	cQuery += " FROM " + cSRCSqlName
Else
	cQuery += " FROM " + cSRCSqlName + " SRC"
	cSRCSqlName := "SRC"
EndIf

cQuery += " WHERE " + cSRCSqlName + ".RC_MAT IN "
cQuery += " ( " 
cQuery += " 	SELECT DISTINCT(RA_MAT) FROM "+ InitSqlName("SRA") + " SRA " 
cQuery += " 	WHERE "+cFilterAux+" AND " + cSRCSqlName + ".RC_FILIAL = SRA.RA_FILIAL ) "
cQuery += " AND " + cSRCSqlName + ".RC_PERIODO = '" + cPeriodo + "'"
cQuery += " AND " + cSRCSqlName + ".RC_SEMANA = '"  + cNumPag  + "'"
cQuery += " AND " + cSRCSqlName + ".RC_ROTEIR = '"  + cRoteiro + "'"
                                                   
While ( nMinRec <= nMaxRec )

	cFilRecno := " AND "
	cFilRecno += "("
	cFilRecno += cSRCSqlName + "." + cCpoRecno + " >= " + AllTrim( Str( nMinRec , 18 , 0 ) )
	cFilRecno += " AND "
	cFilRecno += cSRCSqlName + "." + cCpoRecno + " <= " + AllTrim( Str( ( nMinRec += 1024 ) , 18 , 0 ) )
	cFilRecno += ")"
	cQueryDelet := ( cQuery +  cFilRecno )

	TcSqlExec( cQueryDelet )

End While

TcRefresh( cSRCSqlName )

Return( lRet )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³fGetMnem	³ Autor ³Mauricio Takakura     ³ Data ³02/10/2007³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Carrega em array as verbas e verbas por processo		     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL															 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³SIGAGPE     												 ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function fGetMnem(aMnemo	,;	//Por referencia retorna o array de mnemonicos - de usuario e Reservados
				  aOpera	,;	//Por referencia retorna o array de operadores
				  cProcesso	,;	//Processo do Periodo de Calculo
				  cRoteiro	,;	//Roteiro/Tipo de Calculo do Periodo
				  lMnemo	,;	//Se dever gerar o array de mnemonicos - Padrao = .T.
				  lOpera	,;  //Se dever gerar o array de operadores - Padrao = .T.
				  aTables	 ;  //Para o Tipo F-Files, identificar o tipo do campo
				 )

Local aArea 	:= GetArea()

Local cSRMDelet
Local cRCADelet
Local cTpField
Local cAliasRCA := "QRCA"
Local cFilSRM 	:= xFilial( "SRM" )
Local cFilRCA	:= xFilial( "RCA" )

Local lRet		:= .T.

Local nPosField
Local nPosAlias

Local cImporte	 := ME_IMPORTE
Local cUnidades	 := ME_UNIDADES
Local cNoAplicado:= ME_NO_APLICADO
Local cAnoIniAcu := ME_ANO_INI_ACU
Local cAnoFimAcu := ME_ANO_FIM_ACU
Local cTpSumaMovL:= ME_TP_SUMA_MOVLI
Local cRetTabla	 := ME_RET_TABLA
Local cTpFiltro	 := ME_TP_FILTRO
Local cEntidad 	 := ME_ENTIDAD 

DEFAULT aMnemo 		:= {}
DEFAULT aOpera 		:= {}
DEFAULT cProcesso	:= ""
DEFAULT cRoteiro	:= ""
DEFAULT lMnemo		:= .T.
DEFAULT lOpera		:= .T.

cSRMDelet := "% SRM.D_E_L_E_T_ = ' ' AND RC3.D_E_L_E_T_ = ' ' %"
cRCADelet := "% RCA.D_E_L_E_T_ = ' ' %"

cJoinRCA := "%"
cJoinRCA += FWJoinFilial( "RCA", "RC3" )
cJoinRCA += "%"

cJoinSRM := "%"
cJoinSRM += FWJoinFilial( "SRM", "RC3" )
cJoinSRM += "%"

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Geracao do Array de Mnemonicos                                ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
If lMnemo
	BeginSql alias cAliasRCA
	
		SELECT DISTINCT RCA_MNEMON, RCA_TIPO, RCA_ALIAS, RCA_CAMPO, RCA_CONTEU
		  FROM %exp:__cRCATab% RCA 
		 INNER JOIN %exp:__cRC3Tab% RC3
		    ON %exp:cJoinRCA%
	 	   AND RCA.RCA_MNEMON = RC3.RC3_RESULT
	 	   AND RCA.RCA_TIPO <> 'P'
	 	   AND %exp:cRCADelet%
		 INNER JOIN %exp:__cSRMTab% SRM
		    ON %exp:cJoinSRM% 
		   AND RC3.RC3_CODIGO = SRM.RM_CODFOR
		  AND SRM.RM_FILIAL = %exp:cFilSRM%
		  AND SRM.RM_PROCES = %exp:cProcesso%
		  AND SRM.RM_CALCULO = %exp:cRoteiro%
		  AND %exp:cSRMDelet%
	    UNION 
		SELECT DISTINCT RCA_MNEMON, RCA_TIPO, RCA_ALIAS, RCA_CAMPO, RCA_CONTEU
		  FROM %exp:__cRCATab% RCA 
		 INNER JOIN %exp:__cRC3Tab% RC3 
		    ON %exp:cJoinRCA% 
	 	   AND RCA.RCA_MNEMON = RC3.RC3_FORM01
	 	   AND RCA.RCA_TIPO <> 'P'
	 	   AND %exp:cRCADelet%
		 INNER JOIN %exp:__cSRMTab% SRM
		    ON %exp:cJoinSRM% 
		   AND RC3.RC3_CODIGO = SRM.RM_CODFOR
		   AND SRM.RM_FILIAL = %exp:cFilSRM%
		   AND SRM.RM_PROCES = %exp:cProcesso%
		   AND SRM.RM_CALCULO = %exp:cRoteiro%
		   AND %exp:cSRMDelet%
	    UNION 
		SELECT DISTINCT RCA_MNEMON, RCA_TIPO, RCA_ALIAS, RCA_CAMPO, RCA_CONTEU
		  FROM %exp:__cRCATab% RCA 
		 INNER JOIN %exp:__cRC3Tab% RC3 
		    ON %exp:cJoinRCA% 
	 	   AND RCA.RCA_MNEMON = RC3.RC3_FORM02
	 	   AND RCA.RCA_TIPO <> 'P' 
	 	   OR (RCA.RCA_MNEMON = %exp:cImporte%		Or RCA.RCA_MNEMON = %exp:cUnidades%
	 	    Or RCA.RCA_MNEMON = %exp:cNoAplicado%	Or RCA.RCA_MNEMON = %exp:cAnoIniAcu%
	 	    Or RCA.RCA_MNEMON = %exp:cAnoFimAcu%	Or RCA.RCA_MNEMON = %exp:cTpSumaMovL%
	 	    Or RCA.RCA_MNEMON = %exp:cRetTabla% 
	 	    or RCA.RCA_MNEMON = %EXP:cEntidad% 
	 	    Or RCA.RCA_MNEMON = %exp:cTpFiltro% )
	 	   AND %exp:cRCADelet%
		 INNER JOIN %exp:__cSRMTab% SRM 
		    ON %exp:cJoinSRM%
		   AND RC3.RC3_CODIGO = SRM.RM_CODFOR
		  AND SRM.RM_FILIAL = %exp:cFilSRM%
		  AND SRM.RM_PROCES = %exp:cProcesso%
		  AND SRM.RM_CALCULO = %exp:cRoteiro%
		  AND %exp:cSRMDelet%
	EndSql
    
	While (cAliasRCA)->( !Eof() )
	
		// Carregar no array o tipo para arquivos
		If (cAliasRCA)->RCA_TIPO == "F"
			nPosField := 0
			nPosAlias := aScan( aTables, { |x| x[1] = (cAliasRCA)->RCA_ALIAS } )
			If nPosAlias > 0 
				nPosField := GdFieldPos( (cAliasRCA)->RCA_CAMPO, aTables[nPosAlias, _HEADER_] )
			EndIf
			If nPosField > 0 
				cTpField := aTables[nPosAlias, _HEADER_, nPosField, __AHEADER_TYPE__]
			Else
				cTpField := GetSx3Cache( (cAliasRCA)->RCA_CAMPO, "X3_TIPO" )
			EndIf
		EndIf	
	
		(cAliasRCA)->( aAdd( aMnemo, { AllTrim(RCA_MNEMON), RCA_TIPO, AllTrim(RCA_ALIAS), AllTrim(RCA_CAMPO), AllTrim(RCA_CONTEU), GetValType(cTpField), cTpField } ) )
		(cAliasRCA)->( DbSkip() )
		
	EndDo
	
	(cAliasRCA)->( DbCloseArea())

EndIf

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Geracao do Array de Operadores                                ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
If lOpera
	BeginSql alias cAliasRCA
	
		SELECT DISTINCT RCA_MNEMON, RCA_TIPO, RCA_CONTEU
		  FROM %exp:__cRCATab% RCA 
		 INNER JOIN %exp:__cRC3Tab% RC3
		    ON %exp:cJoinRCA% 
	 	   AND RCA.RCA_MNEMON = RC3.RC3_OPERA1
	 	   AND RCA.RCA_TIPO = 'P'
	 	   AND %exp:cRCADelet%
		 INNER JOIN %exp:__cSRMTab% SRM 
		    ON %exp:cJoinSRM% 
		   AND RC3.RC3_CODIGO = SRM.RM_CODFOR
		  AND SRM.RM_FILIAL = %exp:cFilSRM%
		  AND SRM.RM_PROCES = %exp:cProcesso%
		  AND SRM.RM_CALCULO = %exp:cRoteiro%
		  AND %exp:cSRMDelet%
	EndSql

	While (cAliasRCA)->( !Eof() )
	
		(cAliasRCA)->( aAdd( aOpera, { AllTrim(RCA_MNEMON), RCA_TIPO, AllTrim(RCA_CONTEU) } ) )
		(cAliasRCA)->( DbSkip() )

	EndDo
	
	(cAliasRCA)->( DbCloseArea())
EndIf

If (lOpera .And. Empty(aOpera))
	lRet := .F.
EndIf

	//carrega o operador PUNTO_ENT
	aAdd(aOpera,{OP_PUNTO_ENT,"P",})
	
RestArea( aArea )

Return( lRet )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³fGetDefTab	³ Autor ³Mauricio Takakura     ³ Data ³04/10/2007³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Carrega em array Definicoes de Tabelas utilizado no Calculo  ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL															 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³SIGAGPE     												 ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function fGetDefTab(aDefTab		,;  //Por Referencia retorna com o conteudo das tabelas
					cProcesso	,;	//Processo a Calcular
					cRoteiro	,;	//Roteiro/Tipo de Nomina a Calcular
					dDataRef	,;	//Data de Referencia - Data de Inicio do periodo selecionado
					cMensagem    ;  //Mensagem de retorno - passado como referência
 				   )
Local cDelet
Local cCodTab
Local cAliasRC3	:= 'QRC3'
Local cFilSRM	:= xFilial("SRM")
Local cJoinRC3	:= ""

Local lRet := .T.

Local nTamRcbCod := GetSx3Cache( "RCB_CODIGO", "X3_TAMANHO" )
Local cBusca	 := OP_BUSCA

DEFAULT aDefTab	  := {}
DEFAULT cProcesso := ""
DEFAULT cRoteiro  := ""
DEFAULT cMensagem := ""

cDelet := "% SRM.D_E_L_E_T_ = ' ' AND RC3.D_E_L_E_T_ = ' ' %"

cJoinRC3 := "%"
cJoinRC3 += FwJoinFilial("SRM" , "RC3")
cJoinRC3 += "%"

BeginSql alias cAliasRC3

	SELECT DISTINCT RC3_FORM02
	FROM %exp:__cRC3Tab% RC3
	INNER JOIN %exp:__cSRMTab% SRM
       ON %exp:cJoinRC3%
      AND SRM.RM_PROCES  = %exp:cProcesso%
      AND SRM.RM_CALCULO = %exp:cRoteiro%
      and SRM.RM_FILIAL = %exp:cFilSRM%
      AND RC3.RC3_CODIGO = SRM.RM_CODFOR
      AND RC3.RC3_OPERA1 = %exp:cBusca%
      AND %exp:cDelet%

EndSql

If !Eof()
	While (cAliasRC3)->( !Eof() )

		cCodTab := AllTrim(Substr( Alltrim((cAliasRC3)->( RC3_FORM02 )), At( '_', Alltrim((cAliasRC3)->( RC3_FORM02 )))+1))
		cCodTab := cCodTab + Space(nTamRcbCod-Len(cCodTab))
		If !fCarrTab( @aDefTab, cCodTab, dDataRef )
			cMensagem := OemToAnsi(STR0038) + " (" + cCodTab + " )."      
			lRet := .F.
			Exit
		EndIf
		(cAliasRC3)->( DbSkip() )

	EndDo
	If Empty(aDefTab)
		lRet := .F.
	EndIf

EndIf

(cAliasRC3)->( DbCloseArea() )

Return( lRet )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³CreateLog()	³ Autor ³Mauricio Takakura     ³ Data ³01/10/2007³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Cria/Abre arquivo de LOG								     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL															 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³SIGAGPE     												 ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/  
Function CreateLog(cLogName, lCabec)

Local cLogPath	:= GetPvProfString( GetEnvServer() , "RootPath" , "" , GetAdv97() )
Local cLogDir 	:= "LOG_CALC\"
Local cPvCveUsu := __cUserID				//Usuario Logado no sistema
Local cPvIdePcc := GetComputerName() 		//Nome da estacao
Local cTime 	:= Time()

Local dDate 	:= dDataBase

Local lRet 		:= .F.

cLogPath	+= GetPvProfString( GetEnvServer() , "StartPath" , "" , GetAdv97() )

DEFAULT cLogName := "LOG_"+Alltrim(cPvCveUsu)+Alltrim(cPvIdePcc)+;
			Replicate("0",2-Len(AllTrim(Str(Day(dDate)))))+;
			AllTrim(Str(Day(dDate)))+;
			Replicate("0",2-Len(AllTrim(Str(Month(dDate)))))+;
			AllTrim(Str(Month(dDate)))+Alltrim(Str(Year(dDate)))+;
			Substr(cTime,1,2)+Substr(cTime,4,2)+SubStr(cTime,7)+".LOG"
DEFAULT lCabec := .T.

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Trocar as barras para evitar inconsistencia no Linux 				    ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
cLogPath := StrTran(cLogPath, "/", "\" )
IF ( SubStr( cLogPath, -1 ) <> "\" )
	cLogPath += "\"
EndIF
cLogPath += cLogDir

cLogPath := Lower( cLogPath )
IF !( lMakeOk := lIsSRVDir( cLogPath ) )

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Foi utilizado o parametro 1 no MakeDir para criar diretorio "fora" do  ³
	³servidor, pois esta se passando todo o caminho do path e nao a partir  ³
	³dele. Com esta funcionalidade sempre sera criado no server mesmo que   ³
	³C:\                                                                    ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	lMakeOk := ( MakeDir( cLogPath ,1) == 0 )

EndIF

cLogPath += cLogName
__nHandle := FCreate(cLogPath,0,1)

If lCabec
	If __nHandle != -1
		lRet := .T.
		__cLogFile := cLogPath
	
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Adicionar Informacoes de Controle do Calculode      				    ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		FWrite(__nHandle, Replicate( "-", 100) + CRLF)
		FWrite(__nHandle, OemToAnsi( STR0001 ) + ": " + cPvIdePcc + CRLF )									// "Terminal Utilizado"
		FWrite(__nHandle, OemToAnsi( STR0002 ) + ": " + cPvCveUsu + "-" + UsrRetName( cPvCveUsu ) + CRLF )	// "Usuario do Protheus" 
		FWrite(__nHandle, OemToAnsi( STR0003 ) + ": " + DTOC(MsDate()) + CRLF )								// "Data de Execucao"
		FWrite(__nHandle, OemToAnsi( STR0004 ) + ": " + Time() + CRLF )										// "Inicio de Execucao"
		FWrite(__nHandle, Replicate( "-", 100) + CRLF + CRLF)
	
	EndIf
EndIf

Return lRet       

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³CloseLog()	³ Autor ³Tatiane Vieira Matias ³ Data ³13/02/2008³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Finaliza o arquivo de LOG					                 ³ 
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL															 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³SIGAGPE     												 ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/  
Function CloseLogCalc()
	If __nHandle <> -1
		FClose(__nHandle)
		__nHandle := -1
	Endif
Return NIL

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³AddMsgLog	³ Autor ³Mauricio Takakura     ³ Data ³01/10/2007³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Cria/Abre arquivo de LOG								     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL															 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³SIGAGPE     												 ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function AddMsgLog(cMsg)

If __nHandle = -1
	Return( .F. )
Endif

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Incluir a mensagem no LOG.                           				    ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
FWrite(__nHandle, cMsg+CRLF)

Return
                          
/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³RetNameLog()³ Autor ³Tatiane Vieira Matias ³ Data ³26/12/2007³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Retorna o nome do log gerado.                    		     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL															 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³SIGAGPE     												 ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/  
Function RetNameLog()
Return __cLogFile

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³TraceLog()	³ Autor ³Mauricio Takakura     ³ Data ³19/10/2007³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Gera a String do TRACE atraves do item da Formula		     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL															 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³SIGAGPE     												 ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/  
Static Function TraceLog(aItemForm, aValores, cMsg, lCabec)

Local cString
Local cValItem

DEFAULT aItemForm 	:= {}
DEFAULT aValores	:= {}
DEFAULT cMsg 		:= ""
DEFAULT lCabec 		:= .F.

If !Empty(cMsg)
	AddMsgLog(cMsg)
EndIf

If lCabec
	AddMsgLog(Replicate("-", 80))
	cString := Substr(OemToAnsi(STR0010),1,08) + Replicate(" ",11-Len(Substr(OemToAnsi(STR0010),1,08))) + ;	// Linha
	           Substr(OemToAnsi(STR0011),1,16) + Replicate(" ",18-Len(Substr(OemToAnsi(STR0011),1,16))) + ;  // Operando 1
	           Substr(OemToAnsi(STR0012),1,16) + Replicate(" ",18-Len(Substr(OemToAnsi(STR0012),1,16))) + ;	// Operador
			   Substr(OemToAnsi(STR0013),1,16) + Replicate(" ",18-Len(Substr(OemToAnsi(STR0013),1,16))) + ;	// Operando 2
			   Substr(OemToAnsi(STR0014),1,16) + Replicate(" ",18-Len(Substr(OemToAnsi(STR0014),1,16)))		// Resultado
	AddMsgLog(cString)
	AddMsgLog(Replicate("-", 80))
	Return
EndIf

If cPD <> __cPD .Or. cCodFor <> __cCodFor
	AddMsgLog("")
	AddMsgLog(OemToAnsi(STR0015) + " " + SRA->RA_FILIAL + '-' + SRA->RA_MAT + "  "  +  OemToAnsi(STR0016) + " " + cPD + "   " + OemToAnsi(STR0017) + " " + cCodFor ) //"Funcionario:"###"Verba:"###"Formula:"
	__cPD	 := cPD
	__cCodFor:= cCodFor
	AddMsgLog("")
EndIf

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Item da Formula                                      				    ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
cValItem 	:= AllTrim(aItemForm[1])
cString 	:= cValItem + Replicate(" ",11-Len(cValItem))
cValItem 	:= AllTrim(aItemForm[2,1])
cString 	+= cValItem + Replicate(" ",18-Len(cValItem))
cValItem 	:= AllTrim(aItemForm[3])
cString 	+= cValItem + Replicate(" ",18-Len(cValItem))
cValItem 	:= AllTrim(aItemForm[4,1])
cString 	+= cValItem + Replicate(" ",18-Len(cValItem))
cValItem 	:= AllTrim(aItemForm[5])
cString 	+= cValItem + Replicate(" ",18-Len(cValItem))
AddMsgLog(cString)

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Imprimir os valores do item da formula               				    ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
If !Empty(aValores)
	cString 	:= Space(11)
	cValItem 	:= AllTrim(AllToChar(aValores[1,2], If(ValType(aValores[1,2])='N', '99999999999999.999999', NIL)))
	cString 	+= cValItem + Replicate(" ",18-Len(cValItem))
	cString 	+= Replicate(" ",18)
	cValItem 	:= AllTrim(AllToChar(aValores[1,4],If(ValType(aValores[1,4])='N', '99999999999999.999999', NIL)))
	cString 	+= cValItem + Replicate(" ",18-Len(cValItem))
	cValItem 	:= AllTrim(AllToChar(aValores[1,5], If(ValType(aValores[1,5])='N', '99999999999999.999999', NIL)))
	cString 	+= cValItem + Replicate(" ",18-Len(cValItem))
	AddMsgLog(cString)	
EndIf

Return( cString )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³ErroForm 		³Autor³Marinaldo de Jesus  ³ Data ³07/06/2002³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Verifica os Erros na Execucao da Formula                     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL                                                  	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico                                                     ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function ErroForm(	oErr	,;	//01 -> Objeto oErr
							lNotErro ;	//02 -> Se Ocorreu Erro ( Retorno Por Referencia )
						)

Local aErrorStack
Local cMsgHelp		:= ""
Local cDescVerba 	:= ""

DEFAULT lNotErro	:= .T.

IF !( lNotErro := !( oErr:GenCode > 0 ) )

	If Type("nItemForm") <> "U"
	   If ValType(nItemForm) == "N"
		    AddMsgLog("") 
			If !Empty(cPD)
		    	cDescVerba := OemToAnsi(STR0016) + " " + cPD + "   " + OemToAnsi(STR0017) + " " + cCodFor //"Verba:"###"Formula:"
		    Else
			    cDescVerba := ""
			EndIf
		    
			AddMsgLog(OemToAnsi(STR0015) + " " + SRA->RA_FILIAL + '-' + SRA->RA_MAT + "  "  +  cDescVerba ) //"Funcionario:"###
			AddMsgLog("")
	   EndIf
	EndIf
	
	cMsgHelp += "Error Description: "
	cMsgHelp += oErr:Description
	
	AddMsgLog(cMsgHelp)
	aErrorStack	:= Str2Arr( oErr:ErrorStack , Chr( 10 ) )
	aEval( aErrorStack , { |cStackError| AddMsgLog( cStackError ) } )
	//Caso ocorrer algum erro de banco e a transacao for
	//abortada entao verifica a necessidade de disarmar a transacao	
	If InTransact()
		DisarmTransaction()
	EndIf
EndIF

Break

Return( NIL )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³fConvType       ³Autor³Tatiane Vieira Matias³Data ³15/01/2008³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Converte para data, caso operando informado seja do tipo data³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL                                                  	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico                                                     ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function fConvType(cOper, aMnemonicos, lValMnem, aTables, lTrimCar)
Local nMnemo    := 0 
Local nPosAlias := 0      
Local nPosField := 0 

DEFAULT cOper       := ""                          
DEFAULT aMnemonicos := {}                             
DEFAULT lValMnem    := .T.   
DEFAULT aTables     := {}                                        
DEFAULT lTrimCar	:= .T.													//Em caso de falso, nao realiza o alltrim do campo enviado - Apenas p/ Caracteres

	if (nMnemo := aScan(aMnemonicos, {|x| x[1] == cOper})) == 0
		if !Empty(CTOD(cOper)) .and. len(cOper) >= 8
			if substr(cOper,1,1) = "'"
				cOper := "RhCToD(" + cOper + ")"
			else
				cOper := "RhCToD('" + cOper + "')"
			endif 
		endif
	else
		if aMnemonicos[nMnemo][2] == "F"
			nPosAlias := aScan( aTables, { |x| x[1] = aMnemonicos[ nMnemo , 03 ] } )
			if nPosAlias > 0
				If aMnemonicos[ nMnemo , 07 ] == "D"
					cOper := "RhCToD(" + cOper + ")"                                  
				ElseIf aMnemonicos[ nMnemo , 07 ] == "C" 
					If lTrimCar
						cOper := "ALLTRIM(" + cOper + ")"
					Else 
						cOper := "(" + cOper + ")"						
					EndIf
				endIf
			endif
		Endif
	endif

Return NIL

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³RhCTod	        ³Autor³Mauricio Takakura   ³Data  ³15/04/2008³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Funcao usada para o calculo para campos do tipo data         ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL                                                  	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico                                                     ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function RhCToD( uValor )
Local dValor := Ctod( "//" )
                        
// Essa funcao foi criada para solucionar o problema dos dados que trabalham com DATA
// Primeiro foi gerado a funcao fConvType, porem se utiliza um Mueve e em seguida outro Mueve
// ou qualquer operador que utiliza o fConvType gerava erro, pois a informacao ja esta em formato data.
If !Empty(uValor)
	If ValType( uValor ) == "C"
		If Empty(Ctod( uValor ))
			dValor := Stod( uValor )
		Else
			dValor := Ctod( uValor )
		EndIf
	ElseIf ValType( uValor ) == "D"
		dValor := uValor
	EndIf
EndIf

Return( dValor )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³fGetEtiquetas   ³Autor³Mauricio Takakura   ³Data  ³21/06/2008³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Retorna a variavel de Etiquetas utilizado no GRID            ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL                                                  	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico                                                     ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function fGetEtiquetas()
Return( aClone(__aEtiquetas))

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³fGetEtiquetas   ³Autor³Mauricio Takakura   ³Data  ³21/06/2008³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Retorna a variavel de Etiquetas utilizado no GRID            ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL                                                  	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico                                                     ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function fSetEtiquetas(aEtiquetas)
__aEtiquetas := aClone(aEtiquetas)
Return()

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³gpDHabProg        ³ Autor ³ Tatiane Matias       ³ Data ³27.08.2008³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Calcula os dias uteis das ausencias de uma verba                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ gpexfor1                                                           ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß */
Function gpDHabProg(cFil		,; //[,	<@>cFil			] -> Opcional, Filial do Funcionario Para Montagem do Calendario
					cMat		,; //[,	<@>cMat			] -> Opcional, Matricula do Funcionario Para Montagem do Calendario
					cTno		,; //[,	<@>cTno			] -> Opcional, Turno do Funcionario Para Montagem do Calendario
					cSeq		,; //[,	<@>cSeq			] -> Opcional, Sequencia do Funcionario Para Montagem do Calendario
					cCc			,; //[,	<@>cCc			] -> Opcional, Centro de Custo do Funcionario Para Montagem do Calendario
					dDataIni	,; //[	<@>dDataIni		] -> Opcional, Data Inicial Para Montagem do Calendario
					dDataFim	,; //[,	<@>dDataFim		] -> Opcional, Data Final Para Montagem do Calendario
					nDiasUteis  ,; //[,	<@>nDiasUteis	] -> Opcional, Dias Uteis Para Montagem do Calendario
					cAlias		,; // Alias da tabela SRA
					cPd          ) // Verba utilizada na busca das ausências

Local aArea			:= GetArea()
Local aRCHArea		:= RCH->(GetArea())
Local aTabCalend	:= {}
Local aAfast        := {}
Local cSR8Alias     := ""                      
Local cDataIni      := ""
Local cDataFim      := ""
Local cTipoDia		:= ""
Local cTipoOrig		:= ""
Local dStartDate	:= Ctod("//")
Local nStartDate	:= 0.00
Local nFinishDate	:= 0.00
Local nPosCalend	:= 0.00       
Local nTamOrdem 	:= GetSx3Cache( "P8_ORDEM", "X3_TAMANHO" )
Local lFeriado		:= .F.
Local lTrbFeriado	:= .F.
Local lAfast		:= .T.
Local lTabCalFun	:= .T.
Local bAscanOrdem	:= { |x| x[ CALEND_POS_ORDEM ] == StrZero( nStartDate , nTamOrdem ) .and. x[ CALEND_POS_TIPO_MARC ] == "1E" }

DEFAULT cAlias 			:= "SRA"
DEFAULT cFil			:= (cAlias)->RA_FILIAL
DEFAULT cMat			:= (cAlias)->RA_MAT
DEFAULT cTno			:= (cAlias)->RA_TNOTRAB
DEFAULT cSeq			:= (cAlias)->RA_SEQTURN
DEFAULT cCc				:= (cAlias)->RA_CC
DEFAULT dDataIni 		:= Ctod("01/"+StrZero(Month(dDataBase),02)+"/"+StrZero(Year(dDataBase),04),"DD/MM/YY")
DEFAULT dDataFim 		:= Ctod(StrZero(f_UltDia(dDataIni),02)+"/"+StrZero(Month(dDataBase),02)+"/"+StrZero(Year(dDataBase),04),"DD/MM/YY")
DEFAULT nDiasUteis 		:= 0   
DEFAULT cPd 		    := ""

	cDataIni      := DToS(dDataIni)
	cDataFim      := DToS(dDataFim)

	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Busca as ausencias da verba de acordo com a data inicial e final³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	cSR8Alias := 'QSR8'
	BeginSql alias cSR8Alias

		SELECT R8_DATAINI, R8_DATAFIM 
		FROM %exp:__cSR8Tab%
		WHERE R8_FILIAL = %exp:cFil% AND
		      R8_MAT    = %exp:cMat% AND
		      R8_PD     = %exp:cPd%  AND
		      D_E_L_E_T_= ' '        AND 
		      (
		       (R8_DATAINI BETWEEN %exp:cDataIni% AND %exp:cDataFim%) OR
		       (R8_DATAFIM BETWEEN %exp:cDataIni% AND %exp:cDataFim%) OR
		       (R8_DATAINI <= %exp:cDataIni% AND R8_DATAFIM >= %exp:cDataFim%)
		      )

	EndSql
                                                              
	If (cSR8Alias)->( Eof() )                              
		nDiasUteis := 0
		(cSR8Alias)->( dbCloseArea() )
	Else           
		While (cSR8Alias)->( !Eof() )
			aAdd(aAfast, {STOD((cSR8Alias)->(R8_DATAINI)), STOD((cSR8Alias)->(R8_DATAFIM))})
			(cSR8Alias)->( dbSkip() )
		EndDo                                                                 
		(cSR8Alias)->( dbCloseArea() )

		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Define o Periodo Para Carga das Informacoes em aInfoCalend    ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		dStartDate	:= dDataIni
		nFinishDate	:= ( ( dDataFim - dDataIni ) + 1 )
       
		If ( Type("oPeriodo") == "U" )
			_SetOwnerPrvt( 'oPeriodo', Nil )
			oPeriodo	 := RHPERIODO():New()
		EndIf
		RstCriaCalend()
		oPeriodo:cProcesso := (cAlias)->RA_PROCES
		oPeriodo:GetPer()
		oPeriodo:dDataIni := dDataIni
		oPeriodo:dDataFim := dDataFim

		//Recurso para nao carregar o mesmo calendario do funcionario diversas vezes durante a execucao dos operadores Modelo 2
		If( !Type("__aTabCalFun")=="U" )
			//Verifica se as datas correspondem ao ultimo calendario gerado para o funcionario
			If( __dDataIni == dDataIni .And. __dDataFim == dDataFim .And. !Empty(__aTabCalFun)	 )
				aTabCalend := aClone( __aTabCalFun )
				lTabCalFun := .F.
			EndIf	
		EndIf
	
		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Cria o Calendario de Marcacoes de Acordo com o Periodo Passado³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		If !lTabCalFun .Or. ;
			SRA->( CriaCalend(dDataIni	,; //01 -> Data Inicial do Periodo
		 				dDataFim		,; //02 -> Data Final do Periodo
						cTno			,; //03 -> Turno Para a Montagem do Calendario
						cSeq			,; //04 -> Sequencia Inicial para a Montagem Calendario
						NIL				,; //05 -> Array Tabela de Horario Padrao
						@aTabCalend		,; //06 -> Array com o Calendario de Marcacoes
						cFil			,; //07 -> Filial para a Montagem da Tabela de Horario
						cMat			,; //08 -> Matricula para a Montagem da Tabela de Horario
						cCc				,; //09 -> Centro de Custo para a Montagem da Tabela
						NIL      		,; //10 -> Array com as Trocas de Turno
						NIL				,; //11 -> Array com Todas as Excecoes do Periodo
						NIL	 			,; //12 -> Se executa Query para a Montagem da Tabela Padrao
						.F.				,; //13 -> Se executa a funcao se sincronismo do calendario
						.F.				,; //14 -> Se Forca a Criacao de Novo Calendario
						NIL  			,; //15 -> Array com marcacoes para tratamento de Turnos Opcionais
						.F.  			,; //16 -> .T. Determina a Criacao/Carga do Calendario Fisico
						NIL				,; //17 -> .T. Caso exista calendario fisico 
						NIL				,; //18 -> Data inicial do calendario fisico
						NIL				,; //19 -> Data final do calendario fisico 
						.F.				,; //20 -> .T. determina que o calendario sera gravado no caso de nao existir
						.F.		 	 	; //21 -> .T. determina que a rotina chamadora eh a Geracao de Calendarios (PONM400)
					);
				)
	
			For nStartDate := 1.00 To nFinishDate
				/*
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³A Pesquisa da Data em aTabCalend devera ser Feita Baseada   na³
				³Ordem                  									   ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
				IF ( nPosCalend := aScan( aTabCalend , bAscanOrdem ) ) == 0.00
					dStartDate++
				Else
					dStartDate := aTabCalend[ nPosCalend , CALEND_POS_DATA ]
				EndIF  
                                                
				If ( aScan( aAfast, {|x| dStartDate >= x[1] .and. dStartDate <= x[2] } ) > 0 .and.  ( dStartDate <= dDataFim ) )
				
						/*
						ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						³Retorna Conteudo de aTabCalend de Acordo com as Chaves Indices³
						ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/      
						lAfast		:= GetInfoPosTab( CALEND_POS_AFAST			, "1E" , dStartDate , aTabCalend )
						cTipoOrig   := GetInfoPosTab( CALEND_POS_TIPO_ORIG_DIA  , "1E" , dStartDate , aTabCalend )
						cTipoDia	:= GetInfoPosTab( CALEND_POS_TIPO_DIA 		, "1E" , dStartDate , aTabCalend )
						lFeriado	:= GetInfoPosTab( CALEND_POS_FERIADO		, "1E" , dStartDate , aTabCalend )
						lTrbFeriado	:= GetInfoPosTab( CALEND_POS_TRAB_FERIADO	, "1E" , dStartDate , aTabCalend )
						       
						If  ( (cTipoDia == "S") .and. (!lFeriado .or. (lFeriado .and. lTrbFeriado)) ) .or.;
							( lAfast .and. cTipoOrig == "S" .and. ( !lFeriado .or. (lFeriado .and. lTrbFeriado) ) )
							nDiasUteis ++
						EndIf
						
				EndIf
				
			Next nStartDate 
		Else
    		nDiasUteis := 0
		EndIF
    EndIf
    
	RestArea(aRCHArea)
	RestArea(aArea)

Return( NIL )         

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³fGetTypeAus ³ Autor ³Igor Franzoi		   ³ Data ³29/12/2008³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Carrega todos os Tipos de Ausencia							 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL															 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³SIGAGPE     												 ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function fGetTypeAus( aTipo, aTables )

Local aArea  := GetArea()

Local aRCMTable
Local cFields
Local cAliasRCM := "RCM"

Local nX
Local nPos
Local nItem		:= 0
Local nCampos

DEFAULT aTipo := {}

If Empty( aTables )
	GetTableCalc( @aTables )
EndIf

If Empty( __cQryTpAus )

	nPos 		:= aScan( aTables, { |x| x[_TABLE_] = "RCM" } )
	aRCMTable 	:= aClone(aTables[nPos])
	cFields		:= ""
	nCampos := Len( aRCMTable[_HEADER_] )
	For nX := 1 To nCampos
		cFields += aRCMTable[_HEADER_, nX, __AHEADER_FIELD__] + ","
	Next nX

	cFields += "R_E_C_N_O_" + " RECNO,"
	
	__cQryTpAus := "%" + Substr( cFields,1, Len(cFields)-1) + "%"

EndIf


cAliasRCM := GetNextAlias()

BeginSql alias cAliasRCM
	SELECT %exp:__cQryTpAus%
	FROM %exp:__cRCMTab%
	WHERE %exp:__cDelete%
	ORDER BY RCM_FILIAL, RCM_TIPO
EndSql	
	
While (cAliasRCM)->( !Eof() )

	nPos 		:= aScan( aTables, { |x| x[_TABLE_] = "RCM" } )
	aRCMTable 	:= aClone(aTables[nPos])
	nCampos := Len( aRCMTable[_HEADER_] )
	
	Aadd( aTipo, Array(nCampos+1) )
	nItem++

	For nX := 1 To nCampos
		cField := aRCMTable[_HEADER_, nX, __AHEADER_FIELD__]
		aTipo[nItem, nX] := (cAliasRCM)->( &cField )
	Next nX

	aTipo[nItem, nX] := (cAliasRCM)->( RECNO )
	
	(cAliasRCM)->(dbSkip())
		
EndDo

(cAliasRCM)->( DbCloseArea() )

RestArea(aArea)

Return (Nil)

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³fGetBenef   ³ Autor ³Igor Franzoi		   ³ Data ³30/12/2008³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Carrega os Beneficiarios									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL															 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³SIGAGPE     												 ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function fGetBenef( cFil, cMat, aBenef, aTables )

Local aArea  := GetArea()

Local aSRQTable

Local cFields
Local cAliasSRQ := "SRQ"

Local nX
Local nPos
Local nItem		:= 0
Local nCampos

DEFAULT aBenef := {}

If Empty( aTables )
	GetTableCalc( @aTables )
EndIf

If Empty( __cQrySRQ )

	nPos 		:= aScan( aTables, { |x| x[_TABLE_] = "SRQ" } )
	aSRQTable 	:= aClone(aTables[nPos])
	cFields		:= ""
	nCampos 	:= Len( aSRQTable[_HEADER_] )

	For nX := 1 To nCampos
		cFields += aSRQTable[_HEADER_, nX, __AHEADER_FIELD__] + ","
	Next nX

	cFields += "R_E_C_N_O_" + " RECNO,"

	__cQrySRQ := "%" + Substr( cFields,1, Len(cFields)-1) + "%"

EndIf

cAliasSRQ := GetNextAlias()

BeginSql alias cAliasSRQ
	SELECT %exp:__cQrySRQ%
	FROM 	%exp:__cSRQTab%
	WHERE RQ_FILIAL = %exp:cFil%
	AND RQ_MAT = %exp:cMat%
	AND %exp:__cDelete%
	ORDER BY RQ_FILIAL, RQ_MAT
EndSql	
	
While (cAliasSRQ)->( !Eof() )

	nPos 		:= aScan( aTables, { |x| x[_TABLE_] = "SRQ" } )
	aSRQTable 	:= aClone(aTables[nPos])
	nCampos 	:= Len( aSRQTable[_HEADER_] )
	
	Aadd( aBenef, Array(nCampos+1) )
	nItem++

	For nX := 1 To nCampos
		cField := aSRQTable[_HEADER_, nX, __AHEADER_FIELD__]
		aBenef[nItem, nX] := (cAliasSRQ)->( &cField )
	Next nX

	aBenef[nItem, nX] := (cAliasSRQ)->( RECNO )
		
	(cAliasSRQ)->(dbSkip())
		
EndDo

(cAliasSRQ)->( DbCloseArea() )

RestArea(aArea)

Return (Nil)

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³fBaseMov	³ Autor ³Igor Franzoi		   ³ Data ³09/01/2009³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Soma todas as verbas passadas na lista de parametros, que 	 ³
³		   ³estao na tabela SRC											 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL															 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³SIGAGPE     												 ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function fBaseMov( cFil, cMat, cProcesso, aBenef, aTables, cParam, aMnemonico, cOperador1 )

	Local cVerba	:= ""
	Local cVerbas	:= ""
	Local cNameTab	:= ""
	Local cAliasTab	:= ""
	Local cAliasSRC	:= "SRC"
	Local cWhereTab	:= ""
	Local cWhereSRC	:= ""
	Local cFilt		:= ""
	Local cFilts	:= ""
	Local cDelete	:= ""
	Local cSRCName	:="%" + __cSRCtab + "%"
	
	Local nValor	:= 0
	Local nVerbas	:= 1
	Local nPosPd	:= 0
	Local nPosSRQ	:= 0
 	Local nPosMne	:= 0
 	Local nFilt		:= 1
	
	Local lValid	:= .F.
	Local cFilMovTab := If( Len(Alltrim(__xFilSRV)) < FWGETTAMFILIAL, __xFilSRV, cFil )
	
	Local cVbProc		:= ""
	Local aVbProc		:= {}
	Local cQrySt		:= ""

	DEFAULT cNumPag		:= ""
	DEFAULT cPeriodo	:= ""
	DEFAULT cRoteiro	:= ""
	
	DEFAULT aTables		:= {}
	DEFAULT nItemForm	:= 0
	DEFAULT cOperador1	:= ""
	
	If (cOperador1=="" .AND. TYPE ("cParam")=="U") .and. !empty(cFiltro_Movli)
		cWhereTab		:= "%" + cFiltro_Movli +" %"	//Aqui averigua se o OP_FILTRO_MOVLI está com valores e ignorará o resto						
		cNameTab		:= __cSRVtab 					//Nome da Tabela Configurada no Mnemonico
		cAliasTab		:= GetNextAlias()
		cFiltro_Movli	:=""					
	EndIf

	If ( ValType(aMnemonico) == "A" .and. ( nPosMne := aScan( aMnemonico, { |x|, x[1] == cParam } ) ) > 0 )
	
			If ( aMnemonico[ nPosMne, 2 ] == "C" )
				lValid  := .T.
			ElseIf ( ValType(cParam) == "N" )
				cParam	:= Str(cParam)
				lValid	:= .T. 
			ElseIf ( aMnemonico[ nPosMne, 2 ] == "F" .and. aMnemonico[ nPosMne, 3 ] == "SRV" .and. SubStr( aMnemonico[ nPosMne, 4 ],1,2 ) == "RV" )
                    cNameTab	:= "%" + RetSqlName( aMnemonico[ nPosMne, 3 ] ) + "%"	//Nome da Tabela Configurada no Mnemonico
					cAliasTab	:= GetNextAlias()				
																			
					//Condição de busca Caso Operador esteja vazio
					If Empty(cOperador1)
																	
						If GetSx3Cache( aMnemonico[ nPosMne, 4 ], "X3_TIPO" ) == "N" //verifica se o campo no mnemonico de arquivo é numerico
							cWhereTab	:= "%" + aMnemonico[ nPosMne, 4 ] + " IN (0) %"	//Condicao de Busca - Campo
						ElseIf GetSx3Cache( aMnemonico[ nPosMne, 4 ], "X3_TIPO" ) == "C" //verifica se o campo no mnemonico de arquivo é caracter
							cWhereTab	:= "%" + aMnemonico[ nPosMne, 4 ] + " IN ('1','S') %"	//Condicao de Busca - Campo
						EndIf
					ElseIf GetSx3Cache( aMnemonico[ nPosMne, 4 ], "X3_TIPO" ) == "C"//verifica se o campo no mnemonico de arquivo é caracter
						If aScan( aMnemonico, { |x|, x[1] == cOperador1} ) > 0
							cOperador1:= AllTrim(&cOperador1)
						Else
							cOperador1:= AllTrim(cOperador1)
						EndIf	
					
						While ( nFilt <= Len(cOperador1) )
							If !( SubStr(cOperador1,nFilt,1) $ ",_.'" )
								If ( SubStr(cOperador1,nFilt,1)!= '"')
									cFilt := cFilt + SubStr(cOperador1,nFilt,1)
								EndIf	
							ElseIf ( SubStr(cOperador1,nFilt,1) $ ",_." )
								cFilt :="','"
							EndIf
							cFilts:=cFilts+cFilt
							cFilt:=""
							nFilt++
						EndDo 
						If (Substr(Alltrim(cFilts),len(Alltrim(cFilts)),1)!= "'") 
							cFilts:="'"+cFilts+"'"
						EndIf
						cWhereTab	:= "%" + aMnemonico[ nPosMne, 4 ] + " IN ("+cFilts+") %"						
					Else
						cWhereTab	:= "%" + aMnemonico[ nPosMne, 4 ] + " IN ("+cOperador1+") %"						
					EndIf
				
			Endif
	Endif
	
	If !empty(cWhereTab) .and. !empty(cNameTab) .and. !empty(cWhereTab)  .and. !empty(cAliasTab)			
			BeginSql alias cAliasTab
				SELECT RV_COD
				FROM %exp:cNameTab%
				WHERE %exp:cWhereTab%
			EndSql
			
			While (cAliasTab)->( !Eof() )
				If !Empty(cVerbas)
					cVerbas := cVerbas + ","
				EndIf
				cVerbas := cVerbas + (cAliasTab)->(RV_COD)
				(cAliasTab)->(dbSkip())
			EndDo
			
			(cAliasTab)->( DbCloseArea() )
			cParam	:= cVerbas
			lValid	:= .T.
							
			
	ElseIf ( cParam == ME_BASE_PENSION )
	
		//BASE_PENSION deve ser utilizado junto com o RM_LEEBEN - que identifica que deverao ser lidos
		//e calculadas as verbas conforme as verbas listadas no campo RQ_VERBAS			
		If !Empty(aBenef)
			nPosSRQ := aScan( aTables, { |x| x[1] == "SRQ" } )
			
			If ( nPosSRQ > 0 )
				nPosPd	:= GdFieldPos( "RQ_VERBAS"	, aTables[nPosSRQ, _HEADER_] )
				If ( nPosPd > 0 )
					cParam := aBenef[ nPosPd ]
					lValid := .T.
				EndIf
			EndIf
		EndIf
						
	ElseIf ( ValType(cParam) == "C" )
		//Caso seja utilizado um mnemonico do tipo caracter diretamente,
		//o parametro passado sera considerado como uma lista de verbas 
		lValid	:= .T.		
		
	ElseIf ( ValType(cParam) == "N" )
		cParam	:= Str(cParam)
		lValid	:= .T.
	EndIf
	
	If ( lValid )
		If ( !Empty(cParam) )
			cParam:= AllTrim(cParam)
			cVerbas := "'"
			While ( nVerbas <= Len(cParam) )
				If !( SubStr(cParam,nVerbas,1) $ ",_._'" )
					cVerba := cVerba + SubStr(cParam,nVerbas,1)
				Else
					If ( nVerbas == Len(cParam) )
						cVerbas += cVerba + "'"
					Else
						cVerbas += cVerba + "','"
					EndIf
					cVerba := ""
				EndIf
				nVerbas++
			EndDo
			
			cVerbas := cVerbas + If ( !Empty(cVerba), cVerba+"'", "" )
						
			cVbProc := StrTran(cVerbas, "'", "")
			aVbProc := StrTokArr(cVbProc, ",")

			cAliasSRC := GetNextAlias()
			If __oSt02 == Nil
				__oSt02 := FWPreparedStatement():New()
				cQrySt := "SELECT RC_VALOR,RC_HORAS,RC_PD "
				cQrySt += "FROM " + __cSRCtab + " SRC "
				cQrySt += "WHERE RC_FILIAL = ? AND "
				cQrySt += "RC_MAT = ? AND "
				cQrySt += "RC_PROCES = ? AND "
				cQrySt += "RC_PERIODO = ? AND "
				cQrySt += "RC_ROTEIR = ? AND "
				cQrySt += "RC_SEMANA = ? AND "
				cQrySt += "RC_PD IN ( ? ) AND "
				cQrySt += "D_E_L_E_T_ <> '*'"
				cQrySt := ChangeQuery(cQrySt)
				__oSt02:SetQuery(cQrySt)
			EndIf

			__oSt02:SetString(1, cFil)
			__oSt02:SetString(2, cMat)
			__oSt02:SetString(3, cProcesso)
			__oSt02:SetString(4, cPeriodo)
			__oSt02:SetString(5, cRoteiro)
			__oSt02:SetString(6, cNumPag)
			__oSt02:SetIn(7, aVbProc)

			cQrySt := __oSt02:getFixQuery()
			dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQrySt),cAliasSRC,.T.,.T.)

			//se o usuario informar H ou D o campo para calculo sera RC_HORAS SENÃO o campo para calculo sera RC_VALOR
			While (cAliasSRC)->( !Eof() )
				
				If RetValSrv( (cAliasSRC)->(RC_PD) , cFilMovTab , "RV_TIPOCOD")$ "2_4" 
					If (cValToChar(&(ME_TP_SUMA_MOVLI)) $ "H_D")	
						nValor -= (cAliasSRC)->(RC_HORAS)
					Else
						nValor -= (cAliasSRC)->(RC_VALOR)	
					EndIf	
				ElseIf RetValSrv( (cAliasSRC)->(RC_PD) , cFilMovTab , "RV_TIPOCOD")$ "1_3"  
					If (cValToChar(&(ME_TP_SUMA_MOVLI)) $ "H_D")	
						nValor += (cAliasSRC)->(RC_HORAS)
					Else 
						nValor += (cAliasSRC)->(RC_VALOR)
					EndIf
				EndIf				
				(cAliasSRC)->(dbSkip())
			EndDo	
			
			(cAliasSRC)->(dbCloseArea())
			
		EndIf
	EndIf
		
Return (nValor)

         
/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³fCalcImpEst ³ Autor ³Marcelo Silveira	   ³ Data ³04/12/2009³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Funcao para calculo do Imposto Estatal.                      ³
³		   ³Soma o valor da verba passada nos parametros, ou realiza a   ³           
³		   ³contagem de funcionarios que atendem ao criterio de          ³
³		   ³acumulacao.                                                  ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³ nIETotFun (Contagem de Funcionarios) ou                     ³
³          ³ nIETotCon (Soma das verbas)                                 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³SIGAGPE     												 ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function fCalcImpEst( cFil		,;  // Filial
					  cTpOper	,;  // Operador => '01'-Contagem de funcionarios, '02'-Soma das verbas
					  cCritAcm	,;	// Criterio de Acumulacao
					  cPd		,;	// Codigo da Verba
					  cDtIni  )  	// Usa apenas a Data de Inicio do periodo para definir o mes e ano

Local cAliasRG7 := "RG7" 
Local cCpoAcmM  := ""		//Mes do acumulador para procura na tabela RG7
Local cCpoAcmV  := ""		//Valor do campo acumulador deve ser maior que zero
Local cMes		:= ""		//Mes de referencia para busca nos Acumuladores
Local cAno		:= ""		//Ano de referencia para busca nos Acumuladores
Local cExpDel 	:= ""		//Expressao para filtrar registros validos
Local nPosIE	:= 0		//Posicao do imposto estatal ja calculado anteriormente
Local nIETotFun := 0
Local nIETotCon := 0

DEFAULT cCritAcm := ""

//Descarta funcionario sem criterio de acumulacao
If Empty( cCritAcm ) .Or. !( SRA->RA_FILIAL+SRA->RA_CRIACUM == cFil+cCritAcm )
	Return( 0 )
EndIf

//--Processa novamente apenas se mudar a Filial, Criterio ou Verba por processo
//--Composicao da estatica: Filial / Criterio / Verba / Quantidade de Funcionarios / Valores por verba
If ( nPosIE := Ascan(__aImpEstat,{|X| X[1]+X[2]+X[3] == SRA->RA_FILIAL+SRA->RA_CRIACUM+cPd}) ) > 0
	Return( If( cTpOper == "01", __aImpEstat[nPosIE,4], __aImpEstat[nPosIE,5] ) )	
Endif

cExpDel	:= "% SRA.D_E_L_E_T_ = ' ' AND RG7.D_E_L_E_T_ = ' ' %"

//Monta o campo da tabela dos Acumuladores conforme o mes do periodo selecionado.
cMes		:= Month( cDtIni )
cAno		:= cValToChar( Year( cDtIni ) )
cCpoAcmV	:= "%" + "RG7.RG7_ACUM" + If( cMes < 10, "0" + cValToChar(cMes), cValToChar(cMes) ) + " > 0%"
cCpoAcmM	:= "%" + "RG7.RG7_ACUM" + If( cMes < 10, "0" + cValToChar(cMes), cValToChar(cMes) ) + "%"

cAliasRG7 := GetNextAlias()    

//Totalizacao da Quantidade de Funcionarios e de Valores por Verba
BeginSql alias cAliasRG7
	SELECT COUNT( DISTINCT RG7.RG7_MAT ) QTDFUNC, SUM( %exp:(cCpoAcmM)% ) VLRVERBA 
	FROM %exp:__cRG7Tab% RG7 INNER JOIN %exp:__cSRATab% SRA   
	ON RG7.RG7_MAT=SRA.RA_MAT 
	AND SRA.RA_CRIACUM=%exp:(cCritAcm)%
	
	WHERE	RG7.RG7_FILIAL=%exp:(cFil)% 
		AND RG7.RG7_PD=%exp:(cPd)% 
		AND	RG7.RG7_ANOINI=%exp:(cAno)% 
		AND RG7.RG7_ANOFIM=%exp:(cAno)% 
		AND	%Exp:(cCpoAcmV)% 
		AND	%Exp:(cExpDel)%
	GROUP BY SRA.RA_FILIAL, SRA.RA_CRIACUM
EndSql		

nIETotFun := (cAliasRG7)->QTDFUNC	
nIETotCon := (cAliasRG7)->VLRVERBA	

(cAliasRG7)->( DbCloseArea() )

//-- Acumula o criterio ja calculado para utilizacao futura
Aadd( __aImpEstat , {SRA->RA_FILIAL, SRA->RA_CRIACUM, cPd, nIETotFun, nIETotCon} )

Return( If( cTpOper == "01", nIETotFun, nIETotCon ) )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³GPEXFOR1  ºAutor  ³Valdeci Lira        º Data ³  20/07/09   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Reinicializa as variaveis Auxiliares e reservadas           º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                        º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function RstVarAux(aMnemonicos)
Local nMnemo := 1
Local nMaxRow:= 0 

Default aMnemonicos := {}
nMaxMnemo := Len(aMnemonicos)

While nMnemo <= nMaxMnemo 
	//Se for um mnemonico auxiliar, verifica a reinicializacao
	If (( Substr(aMnemonicos[ nMnemo , 01 ],2,3) == "AUX" )  .AND. (aMnemonicos[ nMnemo , 02 ] == "R" ))	
		//Se contiver uma reinicilizacao especifica, entao preenche o conteudo de uVar
		If ( !Empty( uVar := AllTrim( aMnemonicos[ nMnemo , 05 ] ) ) )		
			If (( aMnemonicos[ nMnemo , 02 ] == "D" ).and.	( "/" $ uVar )	)
				//Se for do tipo data e contiver barras, executa o CToD
				If (CheckExecForm( { || uVar := Ctod( uVar ) } , .F. )	)
					&(aMnemonicos[ nMnemo , 01 ]) := uVar
				Else
					&(aMnemonicos[ nMnemo , 01 ]) := GetValType( aMnemonicos[ nMnemo , 02 ] )
				EndIf
			Else
				If Empty(__aMnemError)
					If Empty(aMnemonicos[ nMnemo , 05 ])
						uCont := GetValType( aMnemonicos[ nMnemo , 02 ] )
					Else
						uCont := &(aMnemonicos[ nMnemo , 05 ])
					EndIf
				Else
					nPosItem := aScan( __aMnemError, { |x| x[1] == aMnemonicos[ nMnemo , 01 ] } )
					If nPosItem > 0
						uCont := __aMnemError[ nPosItem , 02 ]
					Else
						If Empty(aMnemonicos[ nMnemo , 05 ])
							uCont := GetValType( aMnemonicos[ nMnemo , 02 ] )
						Else
							uCont := &(aMnemonicos[ nMnemo , 02 ])
						EndIf
					EndIf
				EndIf
				
				&(aMnemonicos[ nMnemo , 01 ]) := uCont
			EndIf
		Else
			&(aMnemonicos[ nMnemo , 01 ]) := GetValType( aMnemonicos[ nMnemo , 02 ] )
		EndIF
	EndIf
	nMnemo++
EndDo
Return Nil

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³GPEXFOR1  ºAutor  ³Christiane Vieira   º Data ³  12/03/10   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Executa ponto de entrada informado no operador PUNTO_ENT    º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function ExecPunto(cUFunc,cParam)

Local aArea			:= GetArea()

Default cParam		:= ""
Default cUFunc		:= "" 

	If SubStr(cUFunc,1,2)!= "U_"
    	cUFunc:= "U_" + cUFunc
   	EndIf
   	
   	cUFunc:=cUFunc+"("+cParam+")"
    
    cRet:= &cUFunc
    
	RestArea( aArea )

Return  (cRet)     
/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍËÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³GPEXFOR1  ºAutor  ºGlaucia C. Messina  º Data º  24/11/11   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÊÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Operador FILTRO_MOVLI	- Realiza filtro de verbas para o 	  º±±
±±º		     ³Operador SUMA_MOVLI										  º±±
±±ºDesc.     ³Oper1 = 1.Expressao 										  º±±
±±ºDesc.     ³Oper2 = 2.Expressao										  º±±
±±ºDesc.     ³cResult = Resultado										  º±±
±±ºDesc.     ³aMenemonico = Mnemonicos em uso na linha formula			  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ GPEM022                                                    º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function fFiltroMov(cOper1,cOper2,cResult, aMnemonico)
Local nFilt		:= 1
Local cFilts	:= ""
Local cFilt		:= ""
Local cFilt1	:= ""
Local cFilt2	:= ""
Local nPosAux	:= 0

DEFAULT cOper1	:= ""
DEFAULT cResult	:= ""

If ( nPosAux := aScan( __aFiltro, { |x|, x[1]+x[2]+x[3] == cOper1 + cOper2 + 'MOV'} ) ) > 0
	If Empty(cFiltro_Movli)
		cFiltro_Movli	:= __aFiltro[nPosAux,4]
	Else
		cFiltro_Movli	:= cFiltro_Movli + " AND " + __aFiltro[nPosAux,4]
	EndIf
ElseIf ( ValType(aMnemonico) == "A" .and. ( nPosMne := aScan( aMnemonico, { |x|, x[1] == cOper2 } ) ) > 0 )
		
	If ( aMnemonico[ nPosMne, 2 ] == "F" .and. aMnemonico[ nPosMne, 3 ] == "SRV" .and. SubStr( aMnemonico[ nPosMne, 4 ],1,2 ) == "RV" )
				
		If (GetSx3Cache( aMnemonico[ nPosMne, 4 ], "X3_TIPO" ) == "C" ) //verifica se o campo no mnemonico de arquivo é caracter
			If aScan( aMnemonico, { |x|, x[1] == cOper1} ) > 0
				cOper1:= AllTrim(&cOper1)
			Else
				cOper1:= AllTrim(cOper1)
			EndIf

			While (( nFilt <= Len(cOper1) ) )
				If !( SubStr(cOper1,nFilt,1) $ ",_.'" )
					If ( SubStr(cOper1,nFilt,1)!= '"')
						cFilt := cFilt + SubStr(cOper1,nFilt,1)
					EndIf	
				ElseIf ( SubStr(cOper1,nFilt,1) $ ",_." )
					cFilt :="','"
				EndIf
				cFilts:=cFilts+cFilt
				cFilt:=""
				nFilt++
			EndDo 
										 
			If (Substr(Alltrim(cFilts),len(Alltrim(cFilts)),1)!= "'" )
				cFilts:="'"+cFilts+"'"
			EndIf

			IIF ((cFilts == "''" ), cFilts:= " 'S','1' ",)
			
			cFilt1:=" IN ("
			cFilt2:=")"
			
			If empty(cFiltro_Movli)
				cFiltro_Movli	:= cFiltro_Movli + aMnemonico[ nPosMne, 4 ] + cFilt1 + cFilts + cFilt2
			Else
				cFiltro_Movli	:= cFiltro_Movli + " AND " +  aMnemonico[ nPosMne, 4 ] +  cFilt1 + cFilts + cFilt2
			Endif
		Endif
	Endif
EndIf

Return (NIL)
             
/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍËÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³GPEXFOR1  ºAutor  ºGlaucia C. Messina  º Data º  25/11/11   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÊÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Operador FILTRO_ACUM	- Realiza filtro de verbas para os 	  º±±
±±º		     ³Operadores:SUMA_UNIDADES, SUMA_IMPORTES, UNIDADES_EMPRESA	  º±±
±±º		     ³IMPORTE_EMPRESA, UNIDADES_TOTAL e IMPORTE_TOTAL			  º±±
±±ºDesc.     ³Oper1 = 1.Expressao 										  º±±
±±ºDesc.     ³Oper2 = 2.Expressao										  º±±
±±ºDesc.     ³aMenemonico = Mnemonicos em uso na linha formula			  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ GPEM022                                                    º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/   
Static Function fFiltroAcu(cOper1,cOper2, aMnemonico)
Local cParam	:= cOper2
Local cFilt1	:= " $ "
Local nFilt		:= 1
Local cFilts	:= ""
Local cFilt		:= ""
Local nVerbas	:= 1
Local lValid	:= .F.
Local cVerba	:= ""
Local nPosMne
Local cCampo 
Local cFiltro	:= Iif( ValType(&(ME_TP_FILTRO))=="U", "0", cValtoChar(&(ME_TP_FILTRO)) )	//- Tipo do Filtro (IN / LIKE)

DEFAULT cOper1:=""
		
If empty(cOper1) .and. empty(cOper2)
	cFiltro_Acum:=""
EndIf

If ( ValType(aMnemonico) == "A" .and. ( nPosMne := aScan( aMnemonico, { |x|, x[1] == cParam } ) ) > 0 )
	If ( aMnemonico[ nPosMne, 2 ] == "C" )
		cParam	:= aMnemonico[ nPosMne, 5 ]
		lValid  := .T.
						
	ElseIf ( aMnemonico[ nPosMne, 2 ] == "F" .and. aMnemonico[ nPosMne, 3 ] == "SRV" .and. SubStr( aMnemonico[ nPosMne, 4 ],1,2 ) == "RV" )

		If Empty(cOper1)
			cCampo:= aMnemonico[nPosMne][4]
			If GetSx3Cache(cCampo, "X3_TIPO") == "N" 						//verifica se o campo no mnemonico de arquivo é numerico
				if empty(cFiltro_Acum)
					cFiltro_Acum	:= "(" + cCampo + " == '0' )"
				Else
					cFiltro_Acum	:= cFiltro_Acum + " .AND. (" + cCampo + " == '0' )"
				Endif
			Else
				If GetSx3Cache(cCampo, "X3_TIPO") == "C" 					//verifica se o campo no mnemonico de arquivo é caracter
					If empty(cFiltro_Acum) 
						cFiltro_Acum	:= "( " + cCampo + " == '1' .or. " + cCampo + " == 'S' )" 
					Else
						cFiltro_Acum	:= cFiltro_Acum+ " .AND. ( " + cCampo + " == '1' .OR. " + cCampo + " == 'S' )" 
					EndIf
				Endif
			EndIf
		ElseIf GetSx3Cache( aMnemonico[ nPosMne, 4 ], "X3_TIPO" ) == "C"	//verifica se o campo no mnemonico de arquivo é caracter
			If aScan( aMnemonico, { |x|, x[1] == cOper1} ) > 0
				cOper1:= AllTrim(&cOper1)
			Else
				cOper1:= AllTrim(cOper1)
			EndIf	

			While ((cFiltro $ ('1/0')) .and. ( nFilt <= Len(cOper1) ))
				If !( SubStr(cOper1,nFilt,1) $ ",_.'" )
					If ( SubStr(cOper1,nFilt,1)!= '"')
						cFilt	:= cFilt + SubStr(cOper1,nFilt,1)
					EndIf	
				ElseIf ( SubStr(cOper1,nFilt,1) $ ",_." )
					cFilt	:="/"
				EndIf
				cFilts	:=cFilts+cFilt
				cFilt	:=""
				nFilt++
			EndDo 
			
			If ((Substr(Alltrim(cFilts),len(Alltrim(cFilts)),1)!= "'") )
				cFilts	:= "'"+cFilts+"'"
			Else
				cFilts	:= cOper1
			EndIf
			
			If Empty(cFiltro_Acum)
				cFiltro_Acum	:= cFiltro_Acum + aMnemonico[ nPosMne, 4 ] + cFilt1 + cFilts				
			Else
				cFiltro_Acum	:=	cFiltro_Acum + " .AND. " +  aMnemonico[ nPosMne, 4 ] + cFilt1 + cFilts
			EndIf
			aAdd(__aFiltro,{cOper1,cOper2,'ACU',aMnemonico[ nPosMne, 4 ] + cFilt1 + cFilts,''})
			
			nFilt:=1
			cFilts:=""
			cFilt:=""
		EndIf
    EndIf
	
//Caso seja utilizado um mnemonico do tipo caracter diretamente,
//o parametro passado sera considerado como uma lista de verbas 
ElseIf ( ValType(cParam) == "C" )
	lValid	:= .T.		
EndIf

//ATENCAO: o mnemonico reservado TP_FILTRO nao influenciará aqui
If ( lValid )
	If ( !Empty(cParam) )
		If ( nPosAux := aScan( __aFiltro, { |x|, x[1]+x[2]+x[3]+x[5] == cOper1 + cOper2 + 'ACU' + cParam} ) ) > 0
			cFiltro_Acum	:= IIF (Empty(cFiltro_Acum), __aFiltro[nPosAux,4], cFiltro_Acum+' .AND. ' + __aFiltro[nPosAux,4])
		Else
			cParam:= AllTrim(cParam)
			cVerbas := "'"
			While ( nVerbas <= Len(cParam) )
				If !( SubStr(cParam,nVerbas,1) $ ",_._'" )
					cVerba := cVerba + SubStr(cParam,nVerbas,1)
				Else
					IIf (( nVerbas == Len(cParam) ) ,cVerbas += cVerba + "'", cVerbas += cVerba + "/")
					cVerba := ""
				EndIf
				nVerbas++
			EndDo
					
			cVerbas 		:= cVerbas + If ( !Empty(cVerba), cVerba+"'", "" )
			cFiltro_Acum	:= IIF (empty(cFiltro_Acum), 'RV_COD $ ('+cVerbas+')', cFiltro_Acum+' .AND. RV_COD $ ('+cVerbas+')')
			aAdd(__aFiltro,{cOper1,cOper2,'ACU','RV_COD $ ('+cVerbas+')',cParam})
			nVerbas			:=1
			lValid			:=.F.
			cParam			:=""
			cVerba			:=""
			cVerbas			:="'"			
		EndIf
	EndIf
EndIf

Return(NIL)
/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³fHistOper ºAutor  ³Microsiga           º Data ³  02/22/12   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³fHistOper()                                                  º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                        º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/

Static Function fHistOper()

Local aAreaSX3	:= SX3->(GetArea())
Local aValid    := {}
Local cCampo 	:= ""
Local cValid
Local cVldUser
    
dbSelectArea("SX3")
SX3->( dbSetOrder(1) )
SX3->( dbSeek("SRA") ) 

While !Eof() .And. ( X3_ARQUIVO == "SRA" )
    cCampo  := SX3->X3_CAMPO
	cCampo	:= Upper( AllTrim( cCampo ) )
	cValid	:= GetSx3Cache( cCampo , "X3_VALID" )
	IF  cValid <> NIL .and. ( "FHIST" $ Upper( cValid ) )  
		AAdd(aValid, cCampo) 
	Else
		cVldUser	:= GetSx3Cache( cCampo , "X3_VLDUSER"	)
		If cVldUser <> NIL .and. ( "FHIST" $ Upper( cVldUser ) )	
			AAdd(aValid, cCampo)    
		Endif	
	EndIF
	SX3->( dbSkip() )
Enddo     

RestArea(aAreaSX3)

Return(aValid )
/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³fGenMov   ºAutor  ³mayra.camargo       º Data ³ 29/11/2013  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Genera movimiento en SRC. Es un duplicado de la función     º±±
±±º          ³fgravaform, sin embargo esta función no inicializa los      º±±
±±º          ³valores de importe, valor no aplicado, unidades y entidad.  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ Con el operador OP_GEN_MOV. SIGAGPE COL11.8_RH             º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function fGenMov(aTables, cPD, lSR8I, lIncidencia, lPrestamo, lAusencia, aValores)

Local cField

Local nX
Local nPosField
Local nPosTable           
Local nPosAlias
Local lFerRes		:= .F.
Local cFuncNam := FunName()

DEFAULT aTables     := {}
DEFAULT lSR8I	    := .F.
DEFAULT lIncidencia := .F.
DEFAULT lPrestamo   := .F.
DEFAULT lAusencia   := .F.
DEFAULT aValores    := {}

//Nas Ferias ou Rescisao a Data de Referencia deve ser de acordo com a data do calculo e nao da origem do lancamento
lFerRes := cFuncNam $ "GPEM031*GPEM032*GPEM042*GPEM043" .or.  (cPaisLoc=="MEX" .and. cFuncNam == "GPEM040B")

If (Importe == 0 .And. Unidades == 0 .And. No_Aplicado == 0) .Or. lFieldExec
	Return
EndIf

If __nSRCTab == 0
	Return
EndIf                               

// Realizar a gravacao das informacoes //

	RecLock("SRC",.T.)
	For nX = 1 To Len( aTables[__nSRCTab, 2] )
		uValor := ""
		cField := aTables[__nSRCTab, 2, nX, __AHEADER_FIELD__]
		If cField == "RC_VALOR"
			uValor := Round(Importe,2)
		ElseIf cField == "RC_HORAS"
			uValor := Round(Unidades,2)
		ElseIf cField == "RC_VNAOAPL"
			uValor := Round(No_Aplicado,2)
		ElseIf cField == "RC_PD"
			uValor := cPD
		ElseIf cField == "RC_PERIODO"
			uValor := cPeriodo
		ElseIf cField == "RC_ROTEIR"
			uValor := cRoteiro
		ElseIf cField == "RC_ENTIDAD"
			IF ValType( Entidad)  == "C"
				uValor := Entidad
			EndIf
		ElseIf cField == "RC_SEMANA"
			If lIncidencia .and. ( __nRGBTab > 0 )
				If __nRGBSem > 0
		    		if !Empty(aValores[__nRGBSem])
						uValor := aValores[__nRGBSem]
					Else
						uValor := cNumPag
					Endif
				Endif
			Else
				uValor := cNumPag			
			Endif
		ElseIf cField == "RC_DATA"
			uValor := RCH->RCH_DTPAGO
		ElseIf cField == "RC_NUMID"
			If lSR8I
				uValor := "SR8I"

				// Verificar se existe a verba em tipos de ausencias -> Quando nao existir
				// nao devera gerar o registro para que não gere problemas no fechamento
//				aAdd( aLogFunc, { '01', cPD,  } )

			Else
				If lPrestamo .and. ( __nSRKTab > 0 )
					nPosField := __nSRKNuId
				ElseIf lAusencia .and. ( __nSR8Tab > 0 )
					nPosField := __nSR8NuId
				ElseIf lIncidencia .and. ( __nRGBTab > 0 )
					nPosField := __nRGBNuId
				endif
				If nPosField > 0
	    			if !Empty(aValores[nPosField])
						uValor := aValores[nPosField]
					endif
				Endif
			EndIf
		ElseIf cField == "RC_SEQ"
		
			//-- Dificilmente o numero de lancamentos por verba ultrapassara 9 itens. Portanto, nesta fase
			//-- nao sera incluido o controle por data de referencia quando ultrapassar 10 itens
			//-- Caso essa quantidade venha a ultrapassar, incluir a sequencia de datas, iniciando pela data
			//-- de inicio do periodo e a cada item, adicionar 1 dia.
			dDtRefSRC := DTOS(SRC->RC_DTREF)
			nPosSeq := aScan( __aSeqPd, {|x,y| x[1]+x[2] = cPD + dDtRefSRC} )
			If nPosSeq > 0
				uValor := Strzero( __aSeqPd[nPosSeq, 3]+1, 1)
				__aSeqPd[nPosSeq, 3] := Val(uValor)
			Else
				uValor := '1'
				aAdd( __aSeqPd, { cPD, dDtRefSRC, Val(uValor) } )
			EndIf
		ElseIf cField == "RC_POSTO" 
			uValor := SRA->RA_POSTO 
			If lIncidencia .and. ( __nRGBTab > 0 )
				If __nRGBPos > 0
		    		if !Empty(aValores[__nRGBPos])
						uValor := aValores[__nRGBPos]
					endif
				EndIf
			Endif
		ElseIf cField == "RC_DEPTO"
			uValor := SRA->RA_DEPTO
			If lIncidencia .and. ( __nRGBTab > 0 )
				If __nRGBDept > 0 .And. !Empty(aValores[__nRGBDept])
					uValor := aValores[__nRGBDept]
				EndIf
			Endif    
		ElseIf !lItemClvl .and. (cField =="RC_ITEM" .or. cField == "RC_CLVL") 
			Loop			
		Else
			nPosField := aScan( aMnemonicos, { |x,y| AllTrim(x[4]) == AllTrim(cField) } )
			If nPosField > 0
				uValor := &(aMnemonicos[ nPosField, 1])
			Else
				uValor := aTables[__nSRCTab, 5, nX]
				If lIncidencia
					If ( __nRGBTab > 0 )
						If cField == "RC_CC"
							nPosField := __nRGBCc
						ElseIf cField == "RC_TIPO3"
							nPosField := __nRGB3Tp
						ElseIf cField == "RC_TIPO2"
							nPosField := __nRGB2Tp
						ElseIf cField == "RC_TIPO1"
							nPosField := __nRGB1Tp
						ElseIf cField == "RC_QTDSEM"
							nPosField := __nRGBQtS
						ElseIf cField == "RC_PARCELA"
							nPosField := __nRGBParc
						ElseIf lItemClvl .And. cField == "RC_ITEM"
							nPosField := GdFieldPos( "RGB_ITEM" , aTables[__nRGBTab, _HEADER_] ) 
						ElseIf lItemClvl .And. cField == "RC_CLVL"
							nPosField := GdFieldPos( "RGB_CLVL" ,aTables[__nRGBTab, _HEADER_] )
						EndIf
						If nPosField > 0
							// Se o campo da RGB estiver em branco ira considerar o Inicializador 
							// padrao da tabela SRC
		    				If !Empty(aValores[nPosField])
								uValor := aValores[nPosField]
							Endif
						Endif
					EndIf
				Else
					If cField == "RC_TIPO2"
						uValor := "C"
					EndIf
				EndIf
			EndIf
		EndIf
		If cField == "RC_DTREF"			
			If lFerRes //Se ferias ou rescisao, grava como chave campo RHI_DTINI(ferias)ou RG_DTPAGO(rescisao)
				uValor:= dDataKey
			ElseIf Empty(uValor) .Or. ValType(uValor) == "C"
				uValor := RCH->RCH_DTFIM
			EndIf
			// Quando for Valores futuros devera considerar a data do emprestimo
			// Isso porque podera existir varios emprestimos e caso nao tenha esse 
			// controle esta gerando erro fatal
			If lPrestamo .And. !lFerRes
				If ( __nSRKTab > 0 )
					If __nSRKDtM > 0
		  				If !Empty(aValores[__nSRKDtM])
							uValor := STOD(aValores[__nSRKDtM])
						Endif
					EndIf
				EndIf
			EndIf
			
			if lIncidencia .And. !lFerRes
				If( __nRGBTab > 0 )
					If __nRGBDtR > 0
			    		if !Empty(aValores[__nRGBDtR])
							uValor := SToD(aValores[__nRGBDtR])
						endif
					Endif   				
				EndIf
			EndIf	
			
		EndIf
		uType := ValType( uValor )
		If uType <> aTables[__nSRCTab, _HEADER_, nX,__AHEADER_TYPE__]
			uValor := GetValType( aTables[__nSRCTab, _HEADER_, nX,  __AHEADER_TYPE__] )
			AddMsgLog( OemToAnsi(STR0018) + ' ' + aTables[__nSRCTab, _HEADER_, nX, __AHEADER_FIELD__] + ' ' + OemToAnsi(STR0019)  ) // "O Conteudo a ser gravado no campo "  ### "possui o tipo diferente da tabela."
			AddMsgLog( OemToAnsi(STR0020) + ' ' + AllToChar(uValor) ) // "Foi gravado no campo o valor: " ### 
		EndIf
		&cField := uValor
	Next nX  
	RC_FILIAL := SRA->RA_FILIAL

Return
/*/{Protheus.doc} Dias360
Devuelve la cantidad de días entre dos fechas basándose en un año de 360 días (12 meses de 30 días)
@author Laura Medina
@since 20/01/2020
@version 12.1.25
@param 		dFchIni		Date		Fecha de Antiguedad (inicial).
@param 		dFchFin		Date		Fecha actual (final).
@param 		aMnemonicos	Array		Arreglo con los mnemonicos.   	   	
@return 	nDias360	Numerico	Numero de días entre las 2 fechas, en un año de 360 días.  
/*/
Function fDias360(dFchIni, dFchFin, aMnemonicos)  //01/10/2007, 13/01/2020 
	Local nDias360  := 0
	Local nAnoFcIni := 0
	Local nAnoFcFin := 0 
	Local nAnoTotal := 0
	Local nMesFcIni := 0
	Local nMesFcFin := 0
	Local nMesTotal := 0
	Local nDayFcIni := 0 
	Local nDayFcFin := 0 
	Local nDayTotal := 0
	Local nPosMnemo := 0

	Default dFchIni := CTOD("//")
	Default dFchFin := CTOD("//")
	Default aMnemonicos  := {}

	//Año 
	nAnoFcIni := YEAR(dFchIni)
	nAnoFcFin := YEAR(dFchFin)

	//Mes
	nMesFcIni := MONTH(dFchIni)
	nMesFcFin := MONTH(dFchFin)

	//Día 
	nDayFcIni := DAY(dFchIni)
	nDayFcFin := DAY(dFchFin)

	If nDayFcIni == 31 .Or. (nMesFcIni == 2 .and. nDayFcIni >=28)
		nDayFcIni := 30
	EndIf

	If nDayFcFin == 31 .Or. (nMesFcFin == 2 .and. nDayFcFin >=28)
		nDayFcFin := 30
	EndIf

	nDayTotal := (nDayFcFin - nDayFcIni) + 1  //13 - 01 = 12

	If nDayTotal < 0  //Días en negativo 
		nMesFcFin -= 1
		nDayTotal += 30
	Endif

	nMesTotal := nMesFcFin - nMesFcIni  //01 - 10 = -09

	If nMesTotal < 0  //Mes en negativo 
		nAnoFcFin -= 1
		nMesTotal += 12
	Endif

	nAnoTotal := nAnoFcFin - nAnoFcIni  //2020 - 2007 = 13

	nDias360 := nDayTotal + ( nMesTotal * 30) + (nAnoTotal * 360)

	//Mnemonicos: ME_DIAS_ANTIG, ME_MESES_ANTIG, ME_ANIOS_ANTIG
	If ( ValType(aMnemonicos) == "A" )
		nPosMnemo := aScan( aMnemonicos, { |x|, x[1] == "DIAS_ANTIG" } )
		If  nPosMnemo > 0
			&(aMnemonicos[ nPosMnemo , 01 ]) := nDayTotal
		Endif  
		nPosMnemo := aScan( aMnemonicos, { |x|, x[1] == "MESES_ANTIG" } )
		If  nPosMnemo > 0
			&(aMnemonicos[ nPosMnemo , 01 ]) := nMesTotal
		Endif 
		nPosMnemo := aScan( aMnemonicos, { |x|, x[1] == "ANIOS_ANTIG" } )
		If  nPosMnemo > 0
			&(aMnemonicos[ nPosMnemo , 01 ]) := nAnoTotal
		Endif 
	Endif

Return nDias360

/*/{Protheus.doc} fDiasAuse
Devuelve la cantidad de días entre dos fechas basándose en un concepto. 
@author Laura Medina
@since 21/01/2020
@version 12.1.25
@param 		dFchIni		Date		Fecha inicial.
@param 		dFchFin		Date		Fecha final.
@param 		cPd			Caracter	Concepto.   	   	
@return 	nDiasSR8	Numerico	Valor en días.  
/*/
Function fDiasAuse(dFchIni, dFchFin, cPd)  
Local cAliasSR8 := GetNextAlias()
Local cFilSRA	:= SRA->RA_FILIAL
Local cFilRCM   := xFilial("RCM")
Local cMatSRA	:= SRA->RA_MAT
Local cProSRA   := SRA->RA_PROCES
Local nDiasSR8  := 0
Local dFchIniT	:= CTOD("//")  
Local dFchFinT	:= CTOD("//")  
Local nDiasHab  := 0

Default dFchIni := CTOD("//")  
Default dFchFin := CTOD("//")  
Default cPd     := ""

BeginSql alias cAliasSR8
	Column R8_DATAINI as Date
	Column R8_DATAFIM as Date
	
	SELECT  SR8.R8_FILIAL, SR8.R8_MAT, SR8.R8_DURACAO,
			SR8.R8_DATAINI, SR8.R8_DATAFIM, RCM.RCM_TIPODI 
	FROM %exp:__cSR8Tab% SR8
	INNER JOIN %exp:__cRCMTab% RCM
	  ON  SR8.R8_FILIAL = %exp:cFilSRA%
	  AND SR8.R8_MAT	= %exp:cMatSRA%
	  AND SR8.R8_PD 	= %exp:cPd% 
	  AND SR8.R8_PROCES = %exp:cProSRA% 
	  AND SR8.R8_PD     = RCM.RCM_PD		
	  AND RCM.RCM_FILIAL = %exp:cFilRCM%			
	  AND (   (SR8.R8_DATAINI <= %exp:dFchIni% AND SR8.R8_DATAFIM >= %exp:dFchFin%) 
	       OR (SR8.R8_DATAINI >= %exp:dFchIni% AND SR8.R8_DATAFIM <= %exp:dFchFin%)
	       OR (SR8.R8_DATAINI >= %exp:dFchIni% AND SR8.R8_DATAINI <= %exp:dFchFin%) 
	       OR (SR8.R8_DATAFIM >= %exp:dFchIni% AND SR8.R8_DATAFIM <= %exp:dFchFin%) )
	  AND RCM.%notDel%
	  AND SR8.%notDel%
    ORDER BY SR8.R8_DATAINI
EndSql

While (cAliasSR8)->( !Eof() )
		//"COMPLETAMENTE" dentro del periodo
	If (cAliasSR8)->R8_DATAINI >= dFchIni .And.  (cAliasSR8)->R8_DATAFIM <= dFchFin
		nDiasSR8 += (cAliasSR8)->R8_DURACAO
	Else 
		//DIA INICIAL "FUERA" del periodo
		dFchIniT := (cAliasSR8)->R8_DATAINI
		If (cAliasSR8)->R8_DATAINI < dFchIni
			dFchIniT := dFchIni
		Endif
		//DIA FINAL "FUERA" del periodo
		dFchFinT := (cAliasSR8)->R8_DATAFIM		
		If (cAliasSR8)->R8_DATAFIM > dFchFin
			dFchFinT := dFchFin
		Endif
		
        If (cAliasSR8)->RCM_TIPODI == "1" 
        	nDiasHab := 0
        	GpeCalend((cAliasSR8)->R8_FILIAL, (cAliasSR8)->R8_MAT ,,,, dFchIniT , dFchFinT , @nDiasHab ,"D",,.F. )
        	nDiasSR8 += nDiasHab 
        Else
           nDiasSR8 += ( (dFchFinT - dFchIniT) + 1)
     	Endif
	Endif	
	(cAliasSR8)->( DbSkip() )		
EndDo
(cAliasSR8)->( DbCloseArea()) 
   
Return nDiasSR8


/*/{Protheus.doc} fBuscaMovPer
Lee movimientos y sumariza valores o unidades de otros Períodos (regresando el valor o unidad). 
@author Laura Medina
@since 12/02/2020
@version 12.1.27
@param 		cPd			Caracter	Concepto.   
@param 		cRetVH		Caracter	Tipo do Retorno (H-horas o V-valores).   
@param 		nValor		Numerico	Suma en valores (por referencia).
@param 		nQtd		Numerico	Suma en horas (por referencia).   
@param 		cPerIni		Caracter	Periodo inicial.
@param 		cPerFim		Caracter	Periodo final.
@param 		cNumPgtIni	Caracter	No.Pago inicial.
@param 		cNumPgtIni	Caracter	No.Pago final.
@param 		cRoteiro	Caracter	Nómina.
@param 		lEsAusencia	Logico		.T. Si es Ausencia.  
@param 		lEsPrestamo	Logico		.T. Si es Préstamo.     	   	
/*/
Function fBuscaMovPer(	cPd			,;	// Lista de Verbas a acumular
						cRetVH		,;	// Tipo do Retorno (em (H) horas ou em (V) valores)
						nValor		,;	// Retorno da soma em valores - por referencia
						nQtd		,;	// Retorno da soma em horas - por referencia
						cPerIni		,;	// Periodo Inicial
						cPerFim		,;	// Periodo Final
						cNumPgtIni  ,;	// Numero de Pagamento Inicial
						cNumPgtFim	,;	// Numero de Pagamento Final
						cRoteiro    ,;	// Lista de Roteiro de Execucao
						lEsAusencia ,;  // Es ausencia
						lEsPrestamo  ;  // Es préstamo
					  	)

local aArea      := GetArea()
Local aSRKArea	 := SRK->(GetArea())
Local aSR8Area	 := SR8->(GetArea())
Local cFilSRA    := SRA->RA_FILIAL
Local cMatSRA    := SRA->RA_MAT
Local cProcSRA   := SRA->RA_PROCES
Local cQuerySRC	 := ""
Local cOrdemSRC  := ""
Local nTamFilial := GetSx3Cache( "RC_FILIAL" , "X3_TAMANHO" )
Local nTamMat	 := GetSx3Cache( "RC_MAT" , "X3_TAMANHO" )
Local nX		 := 0
Local cDtArqFim  := ""
Local cAliasSRC  := GetNextAlias()
Local __cSRCTab	 := '%'+RetSqlName('SRC')+'%' 
Local cDelet     := ""
Local cFiltroID  := ""
Local lAcumula   := .F.

Default cPd     	:= ""
Default cRetVH		:= "V"
Default nValor 		:= 0
Default nQtd	    := 0 
Default cPerIni		:= Space( GetSx3Cache("RC_PERIODO", "X3_TAMANHO") )
Default cPerFim		:= Space( GetSx3Cache("RC_PERIODO", "X3_TAMANHO") )
Default cNumPgtIni 	:= Space( GetSx3Cache("RC_SEMANA", "X3_TAMANHO") )
Default cNumPgtFim	:= Space( GetSx3Cache("RC_SEMANA", "X3_TAMANHO") )
Default cRoteiro    := ""
Default lEsAusencia := .F.
Default lEsPrestamo := .F. 

Dbselectarea("SRK")
Dbselectarea("SR8")

Begin Sequence
	nValor	:= 0	
	nQtd	:= 0
	//Validaciones Periodo y No. Pago.
    If  ( (Empty(cPerIni) .Or. Empty(cPerFim)) .Or. (Empty(cNumPgtIni) .Or. Empty(cNumPgtFim)) .Or. Empty(cPd))
 		Return( 0 )
	EndIf
	
	cDelet	  := "% SRC.D_E_L_E_T_ = ' ' "
	
	cQuerySRC := "%	"
	cQuerySRC += "	SRC.RC_FILIAL	 = '"+ cFilSRA  + "' AND "
	cQuerySRC += " 	SRC.RC_MAT 		 = '"+ cMatSRA  + "' AND "
	cQuerySRC += "  SRC.RC_PROCES	 = '"+ cProcSRA + "' AND "
	cQuerySRC += "  SRC.RC_PERIODO	BETWEEN '"+ cPerIni  + "' AND  '"+ cPerFim  + "' AND "
	cQuerySRC += "  SRC.RC_SEMANA	BETWEEN '"+ cNumPgtIni + "' AND '"+ cNumPgtFim + "' AND "
	cQuerySRC += "  SRC.RC_PD = '" + cPd + "' "
	
	If !Empty(cRoteiro)
		cQuerySRC    += "AND SRC.RC_ROTEIR = '" + cRoteiro + "' "
	EndIf
	
	cQuerySRC += "  %"
	cOrdemSRC := "% 1,2 %"
	
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Geracao da Query com os Registros a serem processados        ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	BeginSql alias cAliasSRC
		SELECT	SRC.RC_FILIAL, SRC.RC_MAT, SRC.RC_VALOR, SRC.RC_HORAS, SRC.RC_NUMID, SRC.RC_PD
		FROM %table:SRC% SRC
		WHERE %exp:cQuerySRC%
		  AND SRC.%notDel%
		ORDER BY %exp:cOrdemSRC%
	EndSql

	While (cAliasSRC)->( !Eof() ) .And. cFilSRA + cMatSRA == (cAliasSRC)->RC_FILIAL + (cAliasSRC)->RC_MAT
		lAcumula := .F.
		If  (lEsAusencia ) 
			SR8->( DbSetOrder(5))  //R8_FILIAL + R8_NUMID  
			If  SR8->( MsSeek( (cAliasSRC)->RC_FILIAL + (cAliasSRC)->RC_NUMID ) )
				While SR8->( !Eof() ) 
					If  SR8->( R8_FILIAL + R8_MAT + R8_NUMID + R8_PD ) == (cAliasSRC)->RC_FILIAL + (cAliasSRC)->RC_MAT + (cAliasSRC)->RC_NUMID + (cAliasSRC)->RC_PD 
						lAcumula := .T.
						Exit
					Endif
				SR8->(DbSkip())
				EndDo				
			Endif
		Elseif (lEsPrestamo)
			SRK->( DbSetOrder(2))  //RK_FILIAL + RK_MAT + RK_NUMID  
			If  SRK->( MsSeek(  (cAliasSRC)->RC_FILIAL + (cAliasSRC)->RC_MAT + (cAliasSRC)->RC_NUMID ) )
				While SRK->( !Eof() ) 
					If  SRK->( RK_FILIAL + RK_MAT + RK_NUMID + RK_PD ) == (cAliasSRC)->RC_FILIAL + (cAliasSRC)->RC_MAT + (cAliasSRC)->RC_NUMID + (cAliasSRC)->RC_PD 
						lAcumula := .T.
						Exit
					Endif
				SRK->(DbSkip())
				EndDo 
			Endif
		Endif
		If  Iif(lEsAusencia .Or. lEsPrestamo, lAcumula, .T.)
			If  RetValSRV( (cAliasSRC)->RC_PD, (cAliasSRC)->RC_FILIAL, "RV_TIPOCOD") $ "13"
				nValor 	+= (cAliasSRC)->RC_VALOR
				nQtd	+= (cAliasSRC)->RC_HORAS
			ElseIf RetValSRV( (cAliasSRC)->RC_PD, (cAliasSRC)->RC_FILIAL, "RV_TIPOCOD") $ "24"
				nValor 	-= (cAliasSRC)->RC_VALOR
				nQtd	-= (cAliasSRC)->RC_HORAS
			EndIf
		Endif
		(cAliasSRC)->( DbSkip() )
	EndDo
	(cAliasSRC)->( DbCloseArea())
	

	If cRetVH # Nil .And. cRetVH = "H"
		Return( nQtd )
	EndIf
	
End Sequence


RestArea(aSRKArea)
RestArea(aSR8Area)
RestArea(aArea)

Return( nValor )

/*/{Protheus.doc} fGetAcuIAG
	Obtiene valor de acumulados apartir de tabla RT3 - Acumulados IAG.
	@type  Function
	@author oscar.lopez
	@since 23/10/2024
	@version 1.0
	@param cTipo, carácter, Tipo que desea realizar: 1-suma mes, 2-suma acumulados
	@param cProces, carácter, Codigo de Proceso
	@param cPd, carácter, Codigo de Concepto
	@return nResult, número, Suma de acumulados
	@example
		cResult := fGetAcuIAG(cTipo, cProces, cPd)
	/*/
Function fGetAcuIAG(cTipo, cProces, cPd)

	Local cMat		:= SRA->RA_MAT
	Local cTipoCod	:= "1/3" //Tipo de Cod. | 1 - Remuneración / 3 - Base (Remuneración)
	Local cCpoAcu1	:= ""
	Local cCpoAcu2	:= ""
	Local cAliasRT3	:= ""
	Local cQryRT3	:= ""
	Local cCpos		:= ""
	Local nResult	:= 0
	Local nItera	:= 0
	Local nMes		:= 0
	Local nSumRes	:= 1
	Local lSoma		:= .T.
	Local aInfQry	:= {}
	Local oConsRT3	:= Nil
	Local aArea		:= GetArea()

	Default cTipo	:= "1"
	Default cProces	:= ""
	Default cPd		:= ""

	If Empty(cAnoAcuIni)
		cAnoAcuIni	:= RCH->RCH_ANO
	ElseIf Valtype(cAnoAcuIni) == "N"
		cAnoAcuIni := AllTrim(Str(cAnoAcuIni))
	EndIf

	If Empty(cAnoAcuFim)
		cAnoAcuFim	:= RCH->RCH_ANO
	ElseIf Valtype(cAnoAcuFim) == "N"
		cAnoAcuFim := AllTrim(Str(cAnoAcuFim))
	EndIf

	If Val(cAnoAcuFim) < Val(cAnoAcuIni)
		cAnoAcuFim := cAnoAcuIni
	EndIf

	If RCH->(ColumnPos("RCH_FCHGAN")) > 0 .And. ChkFile("RT3")
		DbSelectArea( "RT3" )	// Posiciona en tabla RT3 - Acumulados IAG
		nMes := Month(RCH->RCH_FCHGAN)
		cCpoAcu1 += "RT3_ACUM" + StrZero(nMes, 2,0)
		cCpos += " ," + cCpoAcu1
		If nMes > 1
			cCpoAcu2 += "RT3_ACUM" + StrZero(nMes-1, 2,0)
			cCpos += " ," + cCpoAcu2
		EndIf
		cCpos += ", RT3_MES" + StrZero(nMes, 2,0)

		cQryRT3 += " SELECT RT3_PD, RT3_ANOINI, RT3_ANOFIM "
		cQryRT3 += cCpos
		cQryRT3 += " FROM ? RT3"
		cQryRT3 += " WHERE RT3_MAT = ?"
		cQryRT3 += " AND RT3_ANOINI >= ?"
		cQryRT3 += " AND RT3_ANOFIM <= ?"
		cQryRT3 += " AND RT3_PD = ?"
		cQryRT3 += " AND RT3_PROCES = ?"
		cQryRT3 += " AND D_E_L_E_T_ = ' '"
		cQryRT3 += " GROUP BY RT3_PD, RT3_ANOINI, RT3_ANOFIM"
		cQryRT3 += cCpos

		//1 - SeTUnsafe, 2 - SetString
		AAdd(aInfQry, {1, RetSqlName("RT3")})	// Filial
		AAdd(aInfQry, {2, cMat})				// Matricula
		AAdd(aInfQry, {2, cAnoAcuIni})			// Año acumulacion inicio
		AAdd(aInfQry, {2, cAnoAcuFim})			// Año acumulacion fin
		AAdd(aInfQry, {2, cPd})					// Concepto
		AAdd(aInfQry, {2, cProces})				// Proceso

		oConsRT3 := FwExecStatement():New(cQryRT3)

		For nItera := 1 To Len(aInfQry)
			If aInfQry[nItera][1] == 1
				oConsRT3:SetUnsafe(nItera, aInfQry[nItera][2])
			ElseIf aInfQry[nItera][1] == 2
				oConsRT3:SetString(nItera, aInfQry[nItera][2])
			EndIf
		Next nItera

		cAliasRT3 := oConsRT3:OpenAlias()
		(cAliasRT3)->( dbGoTop() )

		While (cAliasRT3)->( !Eof() )
			lSoma		:= (RetValSrv((cAliasRT3)->RT3_PD, SRA->RA_FILIAL, "RV_TIPOCOD") $ cTipoCod )
			nSumRes		:= -1

			If lSoma
				nSumRes := 1
			EndIf

			If nMes == 1 .Or. (cAliasRT3)->&(cCpoAcu1) > 0
				nResult += ((cAliasRT3)->&(cCpoAcu1) * nSumRes)
			Else
				nResult += ((cAliasRT3)->&(cCpoAcu2) * nSumRes)
			EndIf

			(cAliasRT3)->( DbSkip() )
		EndDo
		(cAliasRT3)->( DbCloseArea() )

		If oConsRT3 <> Nil
			oConsRT3:Destroy()
			oConsRT3:= nil
		EndIf
	EndIf
	RestArea( aArea )
Return( nResult )

/*/{Protheus.doc} fGetAstFij
	Obtiene registros de RG1 - Asientos Fijos para empleado
	@type  Static Function
	@author oscar.lopez
	@since 14/05/2025
	@version 1.0
	@param aAstoFijos, arreglo, Arreglo con los movimientos de Asientos Fijos
	@param cFil, caracter, Sucursal del Empleado
	@param cMat, caracter, Matrícula del Empleado
	@param aTables, arreglo, Arreglo de tablas
	@param aFiltAsFij, arreglo, arreglo con filtros de conceptos (SRV)
	@param cOper1, caracter, Operador o valor para informar mes inicial
	@param cOper2, caracter, Operador o valor para informar mes final
	@return .T.
	@example
		fGetAstFij(aAstoFijos, cFil, cMat, aTables, aFiltAsFij, cOper1, cOper2)
/*/
Static Function fGetAstFij(aAstoFijos, cFil, cMat, aTables, aFiltAsFij, cOper1, cOper2)

	Local aArea			:= GetArea()
	Local nPos			:= 0
	Local nItem			:= 0
	Local nCampos		:= 0
	Local cMesIni		:= ""
	Local cMesFin		:= ""
	Local dFchIniAF		:= CToD("  /  /    ")
	Local dFchFinAF		:= CToD("  /  /    ")

	Local oQrySRV		:= Nil
	Local nParamSRV		:= 1
	Local nItera		:= 1
	Local cAliasSRV		:= ""
	Local cQrySRV		:= ""
	Local aConcSRV		:= {}

	Local oQryRG1		:= Nil
	Local nParamRG1		:= 1
	Local cCposTab		:= ""
	Local cAliasRG1		:= ""
	Local cQryRG1		:= ""

	Default aAstoFijos	:= {}
	Default cFil		:= SRA->RA_FILIAL
	Default cMat 		:= SRA->RA_MAT
	Default aTables		:= {}
	Default aFiltAsFij	:= {}
	Default cOper1		:= ""
	Default cOper2		:= ""

	If Empty(cAnoAcuIni)
		cAnoAcuIni := RCH->RCH_ANO
	ElseIf Valtype(cAnoAcuIni) == "N"
		cAnoAcuIni := AllTrim(Str(cAnoAcuIni))
	EndIf

	If Empty(cAnoAcuFim)
		cAnoAcuFim	:= RCH->RCH_ANO
	ElseIf Valtype(cAnoAcuFim) == "N"
		cAnoAcuFim := AllTrim(Str(cAnoAcuFim))
	EndIf

	If Val(cAnoAcuFim) < Val(cAnoAcuIni)
		cAnoAcuFim := cAnoAcuIni
	EndIf

	If aScan( aMnemonico, { |x|, x[1] == cOper1} ) > 0 // Verifica que 1ra expresion sea un mnemonico para leer su contenido
		cMesIni :=  AllTrim(&cOper1)
	Else
		cMesIni := AllTrim(cOper1)
	EndIf
	cMesIni := StrZero(Val(cMesIni),2,0)

	If aScan( aMnemonico, { |x|, x[1] == cOper2} ) > 0 // Verifica que 1ra expresion sea un mnemonico para leer su contenido
		cMesFin := AllTrim(&cOper2)
	Else
		cMesFin := AllTrim(cOper2)
	EndIf
	cMesFin := StrZero(Val(cMesFin),2,0)

	If cMesIni <> "00"
		dFchIniAF := CToD("01/" + cMesIni + "/" + cAnoAcuIni)
	Else
		dFchIniAF := CToD("01/01/" + cAnoAcuIni)
	EndIf

	If cMesFin <> "00"
		dFchFinAF := LastDay(CToD("01/" + cMesFin + "/" + cAnoAcuFim))
	Else
		dFchFinAF := CToD("31/12/" + cAnoAcuFim)
	EndIf

	If !Empty(aFiltAsFij)
		cQrySRV := " SELECT RV_COD"
		cQrySRV += " FROM ? SRV"
		cQrySRV += " WHERE RV_FILIAL = ?"
		cQrySRV += " AND D_E_L_E_T_ = ?"
		For nItera := 1 To Len(aFiltAsFij)
			cQrySRV += " AND " + aFiltAsFij[nItera][1] + " IN ( ? )"
		Next nItera
		cQrySRV += " ORDER BY RV_FILIAL, RV_COD"

		cQrySRV := ChangeQuery(cQrySRV)

		oQrySRV := FwExecStatement():New(cQrySRV)

		oQrySRV:SetUnsafe(nParamSRV++, RetSqlName("SRV")	)
		oQrySRV:SetString(nParamSRV++, FWxFilial("SRV")		)
		oQrySRV:SetString(nParamSRV++, " "					)
		For nItera := 1 To Len(aFiltAsFij)
			oQrySRV:sETiN(nParamSRV++, aFiltAsFij[nItera][3])
		Next nItera

		cAliasSRV := oQrySRV:OpenAlias()

		While (cAliasSRV)->(!Eof())
			AAdd(aConcSRV, (cAliasSRV)->RV_COD)
			(cAliasSRV)->(DbSkip())
		EndDo
		(cAliasSRV)->(DbCloseArea())
	EndIf

	cCposTab := StrTran(__cQryRG1, "%", "")

	cQryRG1 := " SELECT ?"
	cQryRG1 += " FROM ? RG1"
	cQryRG1 += " WHERE RG1_FILIAL = ?"
	cQryRG1 += " AND RG1_MAT = ?"
	cQryRG1 += " AND D_E_L_E_T_ = ?"
	cQryRG1 += " AND ( RG1_DINIPG BETWEEN ? AND ? OR RG1_DFIMPG BETWEEN ? AND ? )"
	If !Empty(aConcSRV)
		cQryRG1 += " AND RG1_PD IN ( ? )"
	EndIf
	cQryRG1 += " ORDER BY RG1_FILIAL, RG1_MAT, RG1_PD, RG1_DINIPG"

	cQryRG1 := ChangeQuery(cQryRG1)

	oQryRG1 := FwExecStatement():New(cQryRG1)

	oQryRG1:SetUnsafe(nParamRG1++, cCposTab			)
	oQryRG1:SetUnsafe(nParamRG1++, RetSqlName("RG1"))
	oQryRG1:SetString(nParamRG1++, cFil				)
	oQryRG1:SetString(nParamRG1++, cMat				)
	oQryRG1:SetString(nParamRG1++, " "				)
	oQryRG1:SetString(nParamRG1++, DToS(dFchIniAF)	)
	oQryRG1:SetString(nParamRG1++, DToS(dFchFinAF)	)
	oQryRG1:SetString(nParamRG1++, DToS(dFchIniAF)	)
	oQryRG1:SetString(nParamRG1++, DToS(dFchFinAF)	)
	If !Empty(aConcSRV)
		oQryRG1:SetIn(nParamRG1++, aConcSRV			)
	EndIf

	cAliasRG1 := oQryRG1:OpenAlias()

	While (cAliasRG1)->(!Eof())

		nPos 		:= aScan( aTables, { |x| x[_TABLE_] = "RG1" } )
		aRG1Table 	:= aClone(aTables[nPos])
		nCampos 	:= Len( aRG1Table[_HEADER_] )

		Aadd( aAstoFijos, Array(nCampos+1) )
		nItem++
		For nItera := 1 To nCampos
			cField := aRG1Table[_HEADER_, nItera, __AHEADER_FIELD__]
			aAstoFijos[nItem, nItera] := (cAliasRG1)->( &cField )
		Next nItera
		aAstoFijos[nItem, nItera] := (cAliasRG1)->( RECNO )

		(cAliasRG1)->(DbSkip())
	EndDo

	(cAliasRG1)->( DbCloseArea() )

	FwFreeObj(oQrySRV)
	FwFreeObj(oQryRG1)

	RestArea(aArea)

Return( .T. )

/*/{Protheus.doc} fAstoFij
	Genera arreglo para aplicar filtros de SRV - Conceptos para obtener Asientos Fijos
	@type  Static Function
	@author oscar.lopez
	@since 16/05/2025
	@version 1.0
	@param cOper1, caracter, 1a Expresión
	@param cOper2, caracter, 2a Expresión
	@param aMnemonico, arreglo, Arreglo de mnemónicos
	@param aFiltAsFij, arreglo, Arreglo de filtros de asientos fijos
	@return Nil
	@example
		fFiltroAF(cOper1, cOper2, aMnemonico, aFiltAsFij)
/*/
Static Function fFiltroAF(cOper1, cOper2, aMnemonico, aFiltAsFij)

	Local cParam	:= cOper2
	Local lValid	:= .F.
	Local nPosMne	:= 0
	Local cContOper	:= ""
	Local cValFilt	:= ""
	Local cCaract	:= ""
	Local nPos		:= 1
	Local nTamConOpe:= 0

	Default cOper1 := ""
	Default cOper2 := ""
	Default aMnemonico := {}
	Default aFiltAsFij := {}

	If Empty(cOper1) .and. Empty(cOper2)
		aFiltAsFij := {}
	EndIf

	nPosMne := aScan( aMnemonico, { |x|, x[1] == cParam } )

	If ( ValType(aMnemonico) == "A" .and. nPosMne > 0 )
		If ( aMnemonico[ nPosMne, 2 ] == "F" .And. aMnemonico[ nPosMne, 3 ] == "SRV" .And. SubStr( aMnemonico[ nPosMne, 4 ], 1, 2 ) == "RV" )
			If GetSx3Cache( aMnemonico[ nPosMne, 4 ], "X3_TIPO" ) == "C" // Verifica que campo de mnemónico sea de tipo caracter
				If aScan( aMnemonico, { |x|, x[1] == cOper1} ) > 0 // Verifica que 1ra expresion sea un mnemonico para leer su contenido
					cOper1:= AllTrim(&cOper1)
				Else
					cOper1:= AllTrim(cOper1)
				EndIf

				cContOper	:= cOper1 + "," //Se añade divisor para operador con contenido de 1 caracter
				nTamConOpe	:= Len(cContOper)
				Aadd(aFiltAsFij, {aMnemonico[ nPosMne, 4], 'C', {}} )

				While nPos <= nTamConOpe
					cCaract := SubStr(cContOper,nPos,1)
					If cCaract $ ",_.'" .Or. cCaract == '"'
						If !Empty(cValFilt)
							Aadd(aFiltAsFij[Len(aFiltAsFij)][3], cValFilt)
						EndIf
						cValFilt := ""
						nPos++
						Loop
					EndIf
					cValFilt += cCaract
					nPos++
				EndDo
			EndIf
		EndIf
	EndIf

Return Nil
