#INCLUDE "PROTHEUS.CH"
#INCLUDE "GPEM070.CH"
#INCLUDE "TBICODE.CH"
#INCLUDE "TBICONN.CH"
#INCLUDE "FWLIBVERSION.CH"

Static lGpa070mn
Static lGp070Fim
Static lItemClVl
Static lProvavp
Static lMtdFal
Static lTmpParc
Static lGp070Ant
Static lProvFec
Static lProvResc
Static lGp070Ven
Static lGp070V13
Static lGp070VIF
Static lGp070PRO
Static lGp070P13
Static lGp070PIF
Static lGp070BIF
Static lGP090F13
Static lGP090B13
Static lGp070COD
Static lGp070Grv
Static lGp070CHK
Static lGp090DEC
Static lGp090DIF
Static lGp090BIF
Static lGp070FBX
Static cTrfAMES
Static lTrfAMES
Static _aCodFol		:= {}
Static _BkpFilial	:= ""
Static _lBkpTraTrf	:= .F.
Static oTmpProv
Static lLimpaMed	:= .F.
Static aLogPerg     := {}
Static lTemPostUmT
Static lVerMetrics

/*
‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±⁄ƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒø±±
±±≥Funcao    ≥ GPEM070  ≥ Autor ≥ Emerson Rosa de Souza          | Data ≥ 21.06.00  ≥±±
±±√ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒ¥±±
±±√Descricao ≥ Calculo da Provisao de Ferias                                        ≥±±
±±√ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¥±±
±±≥Sintaxe   ≥ GPEM070(void)                                                        ≥±±
±±√ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¥±±
±±≥Parametros≥                                                                      ≥±±
±±√ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¥±±
±±≥Uso       ≥ Generico                                                             ≥±±
±±√ƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¥±±
±±≥            ATUALIZACOES SOFRIDAS DESDE A CONSTRUÄAO INICIAL.		              ≥±±
±±√ƒƒƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¥±±
±±≥Programador ≥ Data     ≥CHAMADO/REQUISITO≥  MOTIVO DA ALTERACAO                  ≥±±
±±√ƒƒƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¥±±
±±≥LTrombini   ≥22/01/2014≥M12RH01/RQ1021   ≥UNIFICACAO DA FOLHA V12                ≥±±
±±≥Mohanad                                                                          ≥±±
±±≥Christiane V≥17/04/2014≥M12RH01/RQ1021   ≥UNIFICACAO DA FOLHA V12                ≥±±
±±≥Christiane V≥02/05/2014≥M12RH01/RQ1021   ≥Zerar nTDiasAfa a cada funcion·rio     ≥±±
±±≥Cecilia C.  ≥14/05/2014≥RHU210_01_12     ≥Ajuste na chamada da funcao fCarrTab ao≥±±
±±≥            ≥          ≥                 ≥carregar a tabela S033 (fPercEmp).     ≥±±
±±≥Claudinei S.≥03/06/2014≥           TPQVD1≥Remocao do excesso de aspas  fQryDetSRT≥±±
±±≥            ≥          ≥                 ≥e ajustada a declaracao do aCabProv qdo≥±±
±±≥            ≥          ≥                 ≥utilizar Item Contabil/Classe de Valor.≥±±
±±≥Flavio C.   ≥09/06/2014≥TPUOTR     	   ≥REPLICA V11 Ajuste p/ tratar nova opcao ≥±±
±±≥            ≥          ≥           	   ≥preenchimento do campo X14_RECFAT.		≥±±
±±≥Allyson M   ≥15/07/2014≥TPWOS3     	    ≥Ajuste na impressao do relatorio de    ≥±±
±±≥            ≥          ≥           	    ≥rateio de provisao.		            ≥±±
±±≥            ≥          ≥           	    ≥Ajustes diversos referente congelamento≥±±
±±≥            ≥          ≥           	    ≥Conceito do congelamento e' restrito p/≥±±
±±≥            ≥          ≥           	    ≥p periodo aquisitivo e nao deve ocorrer≥±±
±±≥            ≥          ≥           	    ≥p/ o dias proporcionais.               ≥±±
±±≥Allyson M   ≥24/07/2014≥TPZKBZ	        ≥Ajuste p/ ordenacao por CC, Item e     ≥±±
±±≥            ≥          ≥           	    ≥Classe.               					≥±±
±±≥Allyson M   ≥25/07/2014≥TQCPCK    	    ≥Ajustes p/ gravar o calculo com flag   ≥±±
±±≥            ≥          ≥           	    ≥de congelamento quando ha situacao do  ≥±±
±±≥            ≥          ≥           	    ≥congelamento do periodo aquisitivo. 	≥±±
±±≥Allyson M   ≥08/08/2014≥TQEYJ2     		≥Ajuste no calculo de ferias e para 	≥±±
±±≥            ≥          ≥           		≥considerar a data de demissao caso     ≥±±
±±≥            ≥          ≥           		≥funcionario esteja demitido.  			≥±±
±±≥Allyson M   ≥28/10/2014≥TQNPFS   	    ≥-Ajuste na msg exibida quando calculo  ≥±±
±±≥            ≥          ≥           	    ≥e' para mes que ja foi fechado. 		≥±±
±±≥            ≥          ≥           	    ≥-Ajuste p/ calculo em competencia      ≥±±
±±≥            ≥          ≥           	    ≥anterior a transferencia p/ considerar ≥±±
±±≥            ≥          ≥           	    ≥o afastamento e situacao folha da  	≥±±
±±≥            ≥          ≥           	    ≥competencia selecionada. 				≥±±
±±≥            ≥          ≥           	    ≥-Ajuste na verificacao dos dados da 	≥±±
±±≥            ≥          ≥           	    ≥transf. anterior com os dados da atual.≥±±
±±≥            ≥          ≥           	    ≥-Ajuste na validacao de transferencia  ≥±±
±±≥            ≥          ≥           	    ≥de funcionario demitido.			    ≥±±
±±≥Allyson M   ≥23/01/2015≥TRDH62  	    	≥-Ajuste p/ sempre calcular provisao    ≥±±
±±≥            ≥          ≥           	    ≥quando funcionario afastado pelos  	≥±±
±±≥            ≥          ≥           	    ≥motivos que nao sao tratados ao inves  ≥±±
±±≥            ≥          ≥           	    ≥de buscar os dados do mes anterior	    ≥±±
±±≥            ≥          ≥           	    ≥-Ajuste na montagem do temporario TPR  ≥±±
±±≥            ≥          ≥           	    ≥p/ validar corretamente o item e classe≥±±
±±≥            ≥          ≥           	    ≥da competencia de calculo.				≥±±
±±≥Renan Borges≥24/02/2015≥TRMUM7  	       ≥Ajuste p/ carregar filiais da empresa   ≥±±
±±≥            ≥          ≥           	   ≥corrente sem desposicionar de empresa e ≥±±
±±≥            ≥          ≥           	   ≥assim o tamanho do cFilAnt continua     ≥±±
±±≥            ≥          ≥           	   ≥igual ao da empresa logada, pois quando ≥±±
±±≥            ≥          ≥           	   ≥posicionava em uma empresa cujo tamanho ≥±±
±±≥            ≥          ≥           	   ≥da filial fosse diferente da empresa cor≥±±
±±≥            ≥          ≥           	   ≥rente, o cFilAnt tinha seu tamanho alte-≥±±
±±≥            ≥          ≥           	   ≥rado.                                   ≥±±
±±≥Allyson M   ≥04/03/2015≥TRRK24   	   ≥Ajuste no calculo de INSS da provisao de≥±±
±±≥            ≥          ≥           	   ≥13 quando ha diferenca de 13o na Folha. ≥±±
±±≥            ≥          ≥           	   ≥Ajuste no calculo de INSS da provisao de≥±±
±±≥            ≥          ≥           	   ≥13 quando ha diferenca de 13o na Folha e≥±±
±±≥            ≥          ≥           	   ≥desoneracao teve inicio durante o ano.	≥±±
±±≥Allyson M   ≥04/06/2015≥TSHGSB     	   ≥Ajuste p/ zerar os dias de ferias       ≥±±
±±≥            ≥          ≥           	   ≥vencidas no cabecalho quando nao tem    ≥±±
±±≥            ≥          ≥           	   ≥dias vencidas. 							≥±±
±±≥            ≥          ≥TSLWFQ   	   ≥Ajuste no congelamento de dias de ferias≥±±
±±≥            ≥          ≥           	   ≥de tipos de afastamentos nao tratados   ≥±±
±±≥            ≥          ≥           	   ≥para pegar os dias do calculo anterior  ≥±±
±±≥            ≥          ≥TSL439   	   ≥Ajuste no congelamento em situacao em   ≥±±
±±≥            ≥          ≥           	   ≥que o afastamento ocorre entre dois     ≥±±
±±≥            ≥          ≥           	   ≥periodos aquisitivos.  				    ≥±±
±±≥M. Silveira ≥07/06/2015≥TSJNSS 		   ≥Ajuste na fPercEmp p/ corrigir os campos≥±±
±±≥            ≥          ≥				   ≥da S033 usados na apuracao da aliquota. ≥±±
±±≥Allyson M   ≥24/06/2015≥TSODJL 		   ≥Ajuste na fGrvArrPrv() para arredondar o≥±±
±±≥            ≥          ≥				   ≥valor de baixa na rescisao, para nao    ≥±±
±±≥            ≥          ≥				   ≥gerar divergencia entre os valores 		≥±±
±±≥            ≥          ≥				   ≥provisionados							≥±±
±±≥M. Silveira ≥30/06/2015≥TSQWF2 		   ≥Ajuste para retornar os valores dos     ≥±±
±±≥            ≥          ≥				   ≥adicionais apos a execucao da fSalInc.  ≥±±
±±≥Allyson M   ≥12/08/2015≥TSXNVT   	   ≥Ajuste p/ proporcionalizacao das medias ≥±±
±±≥            ≥          ≥           	   ≥de 13o conforme os avos de direito a 13o≥±±
±±≥            ≥          ≥TT7633   	   ≥Ajuste p/ montagem correta do TPR quando≥±±
±±≥            ≥          ≥           	   ≥houve mais do que 1 transferencia e e'  ≥±±
±±≥            ≥          ≥           	   ≥feito busca dos dados da 1a. transf. 	≥±±
±±≥Allyson M   ≥14/10/2015≥TTLNPT     	   ≥Ajuste p/ gravar a receita bruta na S033≥±±
±±≥            ≥          ≥           	   ≥e gravar a diferenca entre a receita    ≥±±
±±≥            ≥          ≥           	   ≥bruta e liquida no novo campo da S033.	≥±±
±±≥            ≥          ≥           	   ≥Ajuste p/ gerar a baixa de antecipacao  ≥±±
±±≥            ≥          ≥           	   ≥de 14o. salario. 						≥±±
±±≥Matheus M.  ≥34/12/2015≥TTYIF0 		   ≥Ajuste para que seja possÌvel calcular  ≥±±
±±≥            ≥          ≥				   ≥a provis„o em grid sem gerar errorlog.  ≥±±
±±≥Renan Borges≥11/12/2015≥TTTRL1 		   ≥Ajuste para obter o valor dos adicionais≥±±
±±≥            ≥          ≥				   ≥pela fSalInc quando a pesquisa do valor ≥±±
±±≥            ≥          ≥				   ≥nos acumulados nao encontrar os valores.≥±±
±±≥            ≥          ≥      		   ≥Ajuste na fGeraSRT para nao gerar somen-≥±±
±±≥            ≥          ≥				   ≥te cabecalho sem valores de lancamentos.≥±±
±±≥            ≥          ≥        	       ≥Ajuste na verificacao dos dias de ferias≥±±
±±≥            ≥          ≥           	   ≥antecipadas no SRF   				    ≥±±
±±≥Flavio Corre≥16/02/2016≥TUN466   	   ≥Ajuste p/ sempre calcular provisao      ≥±±
±±≥            ≥          ≥           	   ≥quando funcionario afastado ao inves de ≥±±
±±≥            ≥          ≥           	   ≥buscar os dados do mes anterior.		≥±±
±±≥Renan Borges≥06/05/2016≥TVBMO5   	   ≥Ajuste p/ sempre gerar o cabeÁalho de   ≥±±
±±≥            ≥          ≥           	   ≥calculo, mesmo quando nao possuir lanca-≥±±
±±≥            ≥          ≥           	   ≥mentos p/ nao causar divergencia na con-≥±±
±±≥            ≥          ≥           	   ≥ferencia.                               ≥±±
±±≥Renan Borges≥09/05/2016≥TVARIT   	   ≥Ajuste p/ calcular adicionais de 13∞    ≥±±
±±≥            ≥          ≥           	   ≥corretamente quando MV_MEDDIRE est· com ≥±±
±±≥            ≥          ≥           	   ≥"S" em seu conte˙do.                    ≥±±
±±≥Renan Borges≥07/06/2016≥TVGMHH   	   ≥Ajuste para calcular provis„o corretamen≥±±
±±≥            ≥          ≥           	   ≥te quando funcion·rio possuir parte das ≥±±
±±≥            ≥          ≥           	   ≥fÈrias calculadas no mes.               ≥±±
±±≥            ≥          ≥           	   ≥Ajuste para calcular provis„o corretamen≥±±
±±≥            ≥          ≥           	   ≥te quando funcion·rio possuir parte das ≥±±
±±≥            ≥          ≥           	   ≥fÈrias pagas anteriormente e estiver pa-≥±±
±±≥            ≥          ≥           	   ≥gando o restante em outro mes.          ≥±±
±±≥Allyson M   ≥14/06/2016≥TVJDFU     	   ≥Ajuste p/ nao verificar incorporacao dos≥±±
±±≥            ≥          ≥           	   ≥adicionais pois nao existe esse conceito≥±±
±±≥            ≥          ≥           	   ≥na 12, uma vez que os adicionais sempre	≥±±
±±≥            ≥          ≥           	   ≥ser„o gerados separados das verbas de   ≥±±
±±≥            ≥          ≥           	   ≥ferias e de 13o salario   				≥±±
±±≥Renan Borges|21/06/2016|TVIPFA 	       |Ajuste para ao gerar a ContabilizaÁ„o da≥±±
±±≥            |          |                |provis„o seja gerada separadamente os va≥±±
±±≥            |          |                |lores para os tipos de contratos.       ≥±±
±±∫Renan Borges≥24/06/2016≥TVIRBJ          ≥Ajuste para ao incluir um funcion·rio   ∫±±
±±∫            ≥          ≥                ≥seja possÌvel calcular sua provis„o.    ∫±±
±±∫            ≥          ≥                ≥Ajuste para calcular na provis„o adicio-∫±±
±±∫            ≥          ≥                ≥nais de confianÁa e transferÍncia.      ∫±±
±±∫Renan Borges≥29/06/2016≥TVMFAN          ≥Ajuste para calcular provis„o com o para∫±±
±±∫            ≥          ≥                ≥metro MV_TPBXFER com 2 corretamente.    ∫±±
±±∫Claudinei S.≥29/06/2016≥TUTSTS          ≥Disponibilizado o calculo da provisao de∫±±
±±∫            ≥          ≥                ≥ferias para os estagiarios, (Recesso)   ∫±±
±±∫            ≥          ≥                ≥baixa, baixa por transferencia e baixa  ∫±±
±±∫            ≥          ≥                ≥por rescis„o.                           ∫±±
±±∫Claudinei S.≥06/07/2016≥TVMEN0          ≥IncluÌda verificaÁ„o de existÍncia para ∫±±
±±∫            ≥          ≥                ≥os novos identificadores de c·lculo de  ∫±±
±±∫            ≥          ≥                ≥provisao de recesso.                    ∫±±
±±≥Allyson M   ≥14/07/2016≥TVKSI3     	   ≥Ajuste p/ MV_CSALINC ativo quando baixa ≥±±
±±≥            ≥          ≥           	   ≥de transferencia p/ considerar o id 318 ≥±±
±±≥            ≥          ≥           	   ≥do c·lculo original e n„o o atual		≥±±
±±≥Allyson M   ≥15/07/2016≥TVLLNS     	   ≥Ajustes p/ calculo de provisao em Grid  ≥±±
±±≥Allyson M   ≥26/07/2016≥TVRNJ8     	   ≥Ajuste p/ efetuar a baixa corretamente  ≥±±
±±≥            ≥          ≥           	   ≥de ferias quando h· ferias partidas e   ≥±±
±±≥            ≥          ≥           	   ≥abono (par‚metro MV_TPBXFER com 2)		≥±±
±±∫Renan Borges≥29/08/2016≥TVWT57          ≥Ajuste para realizar calculo de provis„o∫±±
±±∫            ≥          ≥                ≥com GRID corretamente quando h· fÈrias  ∫±±
±±∫            ≥          ≥                ≥antecipadas no periodo.                 ∫±±
±±∫Claudinei S.≥27/09/2016≥TVQQXK          ≥Ajuste na provis„o para Jornada Variavel∫±±
±±∫            ≥          ≥                ≥para buscar as mÈdias de 13∫ e Ferias   ∫±±
±±∫            ≥          ≥                ≥vencidas e proporcionais.               ∫±±
±±∫CÌcero Alves≥04/10/2016≥TWCGW8          ≥Ajuste para considerar a data informada ∫±±
±±∫            ≥          ≥                ≥nos pr‚metros							∫±±
±±∫CÌcero Alves≥04/10/2016≥TWEPBC          ≥Ajuste para permitir executar a rotina  ∫±±
±±∫            ≥          ≥                ≥sem interface (testes automatizados)	∫±±
±±∫Renan Borges≥04/10/2016≥TWFOJV          ≥Ajuste p/ contabilizaÁ„o da provis„o    ∫±±
±±≥Allyson M   ≥11/11/2016≥TWEHXD     	   ≥-Ajuste p/ n„o passar data de referÍncia≥±±
±±∫            ≥          ≥                ≥p/ fSalInc() p/ c·lculo correto em  	∫±±
±±∫            ≥          ≥                ≥perÌodos diferentes do aberto na folha 	∫±±
±±∫            ≥          ≥                ≥perÌodos diferentes do aberto na folha 	∫±±
±±∫            ≥          ≥                ≥-Ajuste p/ validar fechamento do roteiro∫±±
±±∫            ≥          ≥                ≥131 p/ a geraÁ„o da antecipaÁ„o do 13∫ 	∫±±
±±∫            ≥          ≥                ≥-Retirada mensagem de perÌodo encerrado ∫±±
±±∫            ≥          ≥                ≥pois pode haver processos com o perÌodo	∫±±
±±∫            ≥          ≥                ≥fechado e outros em aberto, n„o sendo	∫±±
±±∫            ≥          ≥                ≥possÌvel a exibiÁ„o da mensagem de forma∫±±
±±∫            ≥          ≥                ≥genÈrica								∫±±
±±∫Eduardo K.  ≥29/11/2016≥TWKZWS          ≥Ajuste para n„o duplicar registros na   ∫±±
±±∫            ≥          ≥                ≥impress„o da provis„o					∫±±
±±|Claudinei S.|30/11/2016|MRH-1469        |IncluÌdos ajustes para empresas n„o s„o |±±
±±|            |          |TUQEAR          |para buscar as mÈdias de 13∫ e Ferias   |±±
±±|            |          |                |mais beneficiadas pela desoneraÁ„o.     |±±
±±∫Gabriel A.  ≥23/12/2016≥MRH-3521        ≥Ajuste no c·lcudo da provis„o de 13∫ do ∫±±
±±∫            ≥          ≥                ≥mÍs 12 para que as baixas sejam         ∫±±
±±∫            ≥          ≥                ≥calculadas corretamente;                ∫±±
±±∫            ≥          ≥                ≥Ajuste no c·lculo de provis„o de fÈrias ∫±±
±±∫            ≥          ≥                ≥proporcionais.                          ∫±±
±±∫Gabriel A.  ≥29/12/2016≥MRH-3785        ≥Ajuste no c·lcudo de provis„o retroativa∫±±
±±∫            ≥          ≥                ≥de fÈrias quando h· mais de dois        ∫±±
±±∫            ≥          ≥                ≥perÌodos aquisitivos na SRF.            ∫±±
±±∫Renan Borges≥02/01/2016≥MRH-3268        ≥Ajuste para calcular provis„o corretamen∫±±
±±∫            ≥          ≥                ≥te quando MV_CSALINC for branco, e fun- ∫±±
±±∫            ≥          ≥                ≥cion·rio for menor aprendiz com RA_CATEG∫±±
±±∫            ≥          ≥                ≥ = '07' e MV_MAPREND igual a .T..       ∫±±
±±≥            ≥          ≥MRH-2818        ≥Ajuste p/ n„o considerar os perÌodos em ≥±±
±±≥            ≥          ≥           	    ≥aberto em que a data do perÌodo seja   ≥±±
±±≥            ≥          ≥           	    ≥posterior ao do c·lculo	da provis„o	≥±±
±±∫Renan Borges≥03/01/2017≥MRH-3280        ≥Ajuste para imprimir relatorio Mensal   ∫±±
±±∫            ≥          ≥                ≥com rateio com os valores na linha certa∫±±
±±∫Gabriel A.  ≥03/01/2017≥MRH-4221        ≥Ajuste na busca de mÈdias do movimento. ∫±±
±±≥Renan Borges≥04/01/2017≥MRH-4116	 	   ≥Ajuste para quando calcular a prov. em  ≥±±
±±≥            ≥          ≥                ≥um mes que teve 13∞ fechado seja descon-≥±±
±±≥            ≥          ≥                ≥tado o que j· foi pago corretamente.    ≥±±
±±≥Isabel N.   ≥10/01/2017≥MRH-4577        ≥Ajuste no nome do campo RA_ADTPOSER para≥±±
±±≥            ≥          ≥                ≥RA_ADTPOSE conforme cadastrado no ATUSX.≥±±
±±∫Gabriel A.  ≥10/01/2017≥MRH-3785        ≥Ajuste no c·lcudo de provis„o de 13∫ e  ∫±±
±±∫            ≥          ≥                ≥de fÈrias vencidas quando a folha j· foi∫±±
±±∫            ≥          ≥                ≥fechada.                                ∫±±
±±≥Renan Borges≥12/01/2017≥MRH-4608	 	   ≥Ajuste para ao calcular provis„o com o  ≥±±
±±≥            ≥          ≥                ≥mes fechado, o sistema calcule correta- ≥±±
±±≥            ≥          ≥                ≥mente os dias que tinha na Època.       ≥±±
±±∫Gabriel A.  ≥16/01/2017≥MRH-5055        ≥Ajuste na busca de perÌodos quando a RCH∫±±
±±∫            ≥          ≥                ≥È exclusiva.                            ∫±±
±±≥Renan Borges≥27/01/2017≥MRH-5615	 	   ≥Ajuste para no calculo da provis„o quan-≥±±
±±≥            ≥          ≥                ≥do houver fÈrias e periculosidade paga  ≥±±
±±≥            ≥          ≥                ≥nas ferias e na folha, seja gerado a bai≥±±
±±≥            ≥          ≥                ≥xa de adicionais corretamente.          ≥±±
±±|Renan Borges|27/01/2017|        MRH-5827|Ajuste para no calculo da provis„o quan-|±±
±±|            |          |	               |do houver funcion·rio for demitido e hou|±±
±±|            |          |	               |ver avo de aviso de fÈrias, seja calcula|±±
±±|            |          |	               |do corretamente nas fÈrias tambÈm e n„o |±±
±±|            |          |	               |somente na rescis„o.                    |±±
±±∫Gabriel A.  ≥31/01/2017≥MRH-5954        ≥Ajuste na busca da data base quando h·  ∫±±
±±∫            ≥          ≥                ≥rescis„o posterior.                     ∫±±
±±|Renan Borges|01/02/2017|        MRH-4822|Ajuste para que ao utilizar o MV_CSALINC|±±
±±|            |          |	               | o sistema n„o incorpora ao sal·rio a   |±±
±±|            |          |	               |provis„o na os adicionais que j· est„o  |±±
±±|            |          |	               |sendo pagos nela e para nao calc. INSS  |±±
±±|            |          |	               |com verbas que nao incidem.             |±±
±±|Renan Borges|14/02/2017|        MRH-6546|Ajuste parar posicionar na filial corre-|±±
±±|            |          |	               |ta no calculo da provis„o mesmo quando  |±±
±±|            |          |	               |for executado o calculo para uma filial |±±
±±|            |          |	               |diferente da posicionada na tela.       |±±
±±|Renan Borges|23/02/2017|        MRH-7334|Ajuste para calcular medias corretamente|±±
±±|            |          |	               | de quando funcion·rio possuir menos de |±±
±±|            |          |	               |um ano trabalhado.                      |±±
±±|Gabriel A.  |17/03/2017|MRH-7902        |Ajuste para preencher a data base       |±±
±±|            |          |                |corretamente no c·lculo de 13∫.         |±±
±±|Renan Borges|21/03/2017|MRH-8053        |Ajuste para no c·lculo da provis„o calcu|±±
±±|            |          |	               |lar a baixa de Inss e FGTS corretamente |±±
±±|            |          |	               |quando houver abono nas fÈrias.         |±±
±±|Gabriel A.  |11/04/2017|DRHPAG-27       |Ajuste para quando o funcion·rio tira   |±±
±±|            |          |                |mais dias de fÈrias do que tem de       |±±
±±|            |          |                |direito.                                |±±
±±|Claudinei S.|19/04/2017|DRHPAG-773/     |Ajuste em fMonta_TPR() para gerar as    |±±
±±|            |          |DRHPAG-916      |baixas de transferÍncia e rescis„o      |±±
±±|            |          |                |corretamente.                           |±±
±±|Claudinei S.|28/04/2017|MRH-482         |Implementado o c·lculo para funcion·rios|±±
±±|            |          |                |com regime parcial.                     |±±
±±|Oswaldo L   |05/12/2017|DSERFAT-3491    |Tratar retorno apos funÁ„o RhInssPat    |±±
±±|            |          |                |ter sido adequada ao projeto soyuz      |±±
±±|Tiago B.    |04/01/2018|MPRIMESP-12539  |Ajuste p/ gravaÁ„o de linha em branco   |±±
±±|            |          |                |em caso de afastamento superior a 180   |±±
±±|            |          |                |dias e n„o existir fÈrias proporcionais |±±
±±|            |          |                |calculadas.							    |±±
±±¿ƒƒƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒŸ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂ*/
Function GPEM070()
Local aButtons   	:= {}
Local aParametros	:= Array(18)
Local nOpca      	:= 0
Local nSvRcSRA		:= SRA->(Recno())
Local cTextoProv 	:= ""
Local cSRAFilter	:= SRA->(dbFilter())
Local cCadastro
Local cGPEGrid		:= ""
Local cLink 		:= ""
Local cExpFiltro	:= ""
Local aAdvSize		:= {}
Local aInfoAdvSize	:= {}
Local aObjCoords	:= {}
Local aObjSize		:= {}
Private lAbortPrint := .F.
Private aLogFile 	:= {}
Private aLogTitle 	:= {}
Private aIdProvis   := {}
Private lDissidio	:= .F.
Private lFechou13  	:= .F.
Private lFechouMes  := .f.
Private nFec131   	:= 0
Private nVerFatFin 	:= 0
//PERIODOS ABERTOS / FECHADOS
Private cMes          := ""
Private cAno          := ""
Private aPerAberto    := {}
Private aPerAbAUT     := {}
Private aPerAb13      := {}
Private aPrAb131      := {}
Private aPrAb132      := {}
Private aPerFechado   := {}
Private aPerFeAUT     := {}
Private aPerFe13      := {}
Private aPrFe131      := {}
Private aPrFe132      := {}
Private lTemVenc	  := .F.
Private aPerAbPL      := {}
Private aPerFePL      := {}
Private cModFol 	  := GetMvRH( "MV_MODFOL", .F., "1" )

/*
‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹
							PROCESSAMENTO EM GRID
--> Quando declarar variaveis PRIVATES nas Funcoes ate o Nivel Gpm070Processa e
necessitar utiliza-los no roteiro de calculo, devera enviar no array aPARAMB  e
redeclarar na Preparacao do Ambiente com a funcao _SetOwnerPrvt.
--> Para as variaveis PRIVATES declaradas para o funcionario, enviar atraves  do ar-
ray aCall e redeclarar na GPM070GRD.
---> Vide Exemplos de ambas as situacoes
‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹*/

// Tratar GRID Somente para TOP Connect
Private lGrid		:= GetMvRH("MV_GRID",, .F.)// Se o parametro esta configurado para utilizacao do GRID
Private lAdicProp	:= .F.
Private nPergPro	

DEFAULT lGpa070mn	:= ExistBlock("GPA070MN")
DEFAULT lGp070Fim 	:= ExistBlock("GP070FIM")

If lGrid
	// Habilita GRID para rotinas selecionadas em MV_GPEGRID (1=Provisao 2=Calculo Folha/13o. em branco=Todas)
	cGPEGrid := GetMvRH("MV_GPEGRID",, " ")
	lGrid	 := If(Empty(cGPEGrid) .Or. "1"$cGPEGrid, .T., .F.)
EndIf

// Ponto de entrada para substituir
If (lGpa070mn)
	Execblock("GPA070MN",.F.,.F.)
	Return(Nil)
Endif

// Define o titulo do LOG de Ocorrencias
aLogTitle := { STR0011, STR0109 } //"PROVISAO DE FERIAS/13o SALARIO"//"Par‚metro MV_PROVFEC"
aAdd(aLogFile, {})
aAdd(aLogFile, {})

cCadastro := OemToAnsi(STR0002) // "Calculo das Provisoes de Ferias e 13o Salario"

// Carregar os Mnemonicos
SetMnemonicos(NIL,NIL,.T.)

//N„o permite prosseguir se o mnemonico P_MULTV estiver desabilitado.
If cPaisLoc == "BRA" .And. !P_MULTV .And. !(IsInCallStack("FwMyTestRunner") .Or. IsInCallStack("EXECSUITE") .Or. IsInCallStack("EXECSUITEBLIND") .Or. IsInCallStack("AUTJOBRUNCT"))
	cLink := "https://tdn.totvs.com/x/y6DvI"
	//AtenÁ„o ### "O c·lculo n„o ser· realizado pois o mnemnÙnico P_MULTV n„o est· ativo e obrigatoriamente deve estar ativo." ### "Verifique mais informaÁıes sobre o mnemÙnico na documentaÁ„o: https://tdn.totvs.com/x/y6DvI"
	Help( " ", 1, OemToAnsi(STR0015), Nil, OemToAnsi(STR0106), 1, 0, Nil, Nil, Nil, Nil, Nil, { OemToAnsi(STR0107 + CRLF + cLink) } )
	Return Nil
EndIf

Pergunte("GPM070",.F.)

//Monta as Dimensoes dos Objetos
aAdvSize		:= MsAdvSize(,.T.,280)
aInfoAdvSize	:= { aAdvSize[1] , aAdvSize[2] , aAdvSize[3] , aAdvSize[4] , 5 , 5 }
aAdd(aObjCoords , { 000 , 000 , .T. , .T. })
aObjSize := MsObjSize(aInfoAdvSize , aObjCoords)

If ! IsBlind()
	DEFINE FONT oFont NAME "Arial" SIZE 7,-11 BOLD
	DEFINE MSDIALOG oDlg TITLE cCadastro From aAdvSize[7],0 TO aAdvSize[6],aAdvSize[5] PIXEL
		@ aObjSize[1,1] , aObjSize[1,2] GROUP oGroup TO aObjSize[1,3], aObjSize[1,4] LABEL OemToAnsi("") OF oDlg PIXEL
		oGroup:oFont:= oFont
		@ aObjSize[1,1]+15	,aObjSize[1,2]+10 SAY   OemToAnsi(STR0003) Size  500,008 OF oDlg PIXEL FONT oFont
		@aObjSize[1,1]+25	,aObjSize[1,2]+10 SAY   OemToAnsi(STR0004) Size  500,008 OF oDlg PIXEL FONT oFont
		@aObjSize[1,1]+35	,aObjSize[1,2]+10 SAY   OemToAnsi(STR0005) Size  500,008 OF oDlg PIXEL FONT oFont
		@aObjSize[1,1]+45	,aObjSize[1,2]+10 SAY   OemToAnsi(STR0006) Size  500,008 OF oDlg PIXEL FONT oFont

		bParam := {|| Pergunte("GPM070",.T.) }
		AAdd(aButtons, {OemToAnsi(STR0079), bParam 				, OemToAnsi(STR0079), OemToAnsi(STR0079) }  )	//"Parametros"

		bFiltro := {|| GpFltBldExp( "SRA" , NIL , @cExpFiltro , NIL ) }
		AAdd(aButtons, {OemToAnsi(STR0108), bFiltro 			, OemToAnsi(STR0108), OemToAnsi(STR0108) }  )	//"Filtro"

		bSet15	:= {|o| nOpca := 1,If(GPM070OK(),oDlg:End(),nOpca:=0)}
		bSet24	:= {|o| oDlg:End() }
	ACTIVATE MSDIALOG oDlg ON INIT EnchoiceBar(oDlg, bSet15 , bSet24 , Nil , aButtons)  CENTERED
Else
	nOpca := 1
EndIf

If FindFunction("RetPergLog")
	aLogPerg := {}
	RetPergLog(aLogPerg, "GPM070")
EndIf

// Carregando variaveis mv_par?? para Variaveis do Sistema.
aParametros[01]	:=	lFerias     := (mv_par01==1.Or.mv_par01==3)		//  Tipo de Provisao 1 - Ferias 2 - 13o  3 - Ambas
aParametros[02]	:=	l13oSal     := Iif(cPaisLoc <> "CHI",(mv_par01==2.Or.mv_par01==3),.F.)		//  Tipo de Provisao 1 - Ferias 2 - 13o  3 - Ambas
aParametros[03]	:=	dDataRef   	:= mv_par02							    //  Data de Referencia para Calculo
aParametros[04]	:=	nOrdem  	:= mv_par03								//  Ordem de Calculo 1 - Matricula  2 - Centro de Custo
aParametros[05]	:=	cFilDe	   	:= mv_par04								//	Filial De
aParametros[06]	:=	cFilAte    	:= mv_par05								//	Filial Ate
aParametros[07]	:=	cCcDe	   	:= mv_par06								//	Centro de Custo De
aParametros[08]	:=	cCcAte	   	:= mv_par07								//	Centro de Custo Ate
aParametros[09]	:=	cMatDe	   	:= mv_par08								//	Matricula De
aParametros[10]	:=	cMatAte     := mv_par09								//	Matricula Ate
aParametros[11]	:=	nCorrecao   := (mv_par10 / 100)					    //	Indice de Correcao
aParametros[12]	:=	lDesc1parc  := If(mv_par11 == 1,.T.,.F.)          //  Desc. 1a Parc. 13o
aParametros[13]	:=	lIncluiDem  := If(mv_par12 == 1 .Or. lFerias,.T.,.F.) //  Incluir Demit. 13o
aParametros[14]	:=	n14Salario  := (mv_par13 / 100)                    //  Indice de 14o Sal.
aParametros[15]	:=	cCateg	    := mv_par14								//	Categorias
aParametros[16]	:=	nVerFatFin  := mv_par15 			    			//  Vericar Faturamento-Financeiro (1-Nao; 2-Faturamento; 3-Financeiro; 4-Ambos)
aParametros[17]	:=	mv_par01
aParametros[18]	:=	cFiltroSRA 	:= cExpFiltro

nPergPro	:= mv_par01
cMes        := StrZero(Month(dDataRef),2)
cAno        := StrZero(Year(dDataRef),4)


//Define se o texto da provisao sera de ferias, 13o ou ambos
cMesAnoProv := StrZero(Month(dDataRef),2)+StrZero(Year(dDataRef),4)
cTextoProv  := If(lFerias .And. l13oSal, STR0011, If(lFerias, STR0009, STR0010)) + " -  " + Transform(cMesAnoProv,"@R 99/9999") //"PROVISéO DE FERIAS "##"PROVISéO DE 13o SALARIO"##"PROVISéO DE FERIAS/13o SALARIO"

If nOpca == 1
	// Elimina filtro do SRA antes do calculo
	dbSelectArea("SRA")
	Set Filter To

	// Carrega variaveis privates comuns a GPEA070,GPER070 e GPEM070|
	GPEProvisao(cTextoProv,,,,4,aParametros)
EndIf


// Restaura filtro do SRA apos o calculos
dbSelectArea("SRA")
Set Filter To &(cSRAFilter)
dbGoTo(nSvRcSRA)

Return

/*
‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±⁄ƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒø±±
±±≥Funcao    ≥ GP070Proc≥ Autor ≥ R.H.                ≥ Data ≥ 26.06.00   ≥±±
±±√ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒ¥±±
±±≥Descricao ≥ Provisao de Ferias                                         ≥±±
±±√ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¥±±
±±≥Sintaxe   ≥ GPM070Processa()                                           ≥±±
±±√ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¥±±
±±≥Uso       ≥ Generico                                                   ≥±±
±±¿ƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒŸ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂ*/
Function GPM070Processa(aPar)
//PROVISAO DE FERIAS E 13o SALARIO
Local aAreaSRA     	:= SRA->(GetArea())
Local dDtCalIni		:= Dtoc(MsDate())
//- GRID
Local aCall			:= {}
Local nLoteGrid 	:= GetMvRH("MV_REGGRID",,20)
Local nCountReg		:= 0
Local nRegGrid  	:= 0
Local nRegsProc  	:= 0
Local nTrf			:= 0
Local nEleTrf		:= 0
Local cDtHrProc
Local cMsgLog
Local _cFilAnt		:= cFilAnt
Local cBkpBxFer 	:= ""
Local cDurTempo 	:= ""
Local cFunExec      := "GetSrvVersion"
Local lMsgGrid      := .F.
Local lIsBlind		:= IsBlind()
Local lSegPlan      := FwIsInCallStack("WFLAUNCHER") .or. FwIsInCallStack("FWBOSCHDEXECUTE")

Private dIniAfa	    := CtoD("")
Private cCongFER    := "1" // Indica se congela por Afastamento Acidente
Private cCong13     := "2" // Indica se congela por Afastamento Acidente 13 SALARIO
Private aFerVenc     := Array(_Linhas,_Colunas)
Private aFerProp     := Array(_Linhas,_Colunas)
Private aFerPropB    := Array(_Linhas,_Colunas)
Private aRecVenc     := Array(_Linhas,_Colunas)
Private aRecProp     := Array(_Linhas,_Colunas)
Private aTabFer      := {} 	// Tabela para calculo dos dias de ferias
Private aTabFer2     := {}  // Tabela para calculo dos dias de ferias para regime de tempo parcial
Private aPerFerias   := {}  // Periodos aquisitivos de ferias
Private aIndice		 := {}
Private nV_DFalFer   := 0
Private nP_DFalFer   := 0
Private nTFaltaV	 := 0
Private nTFaltaP	 := 0
Private nDFerAnt     := 0
Private nPerc1T      := 0
Private cCodFer	  	 := cCodAdFer   := cCodUmTer  := cCodFerMs := ""
Private cCodAdicMs   := cCodUmTerMs := cCodAbono  := cCodAboMs := ""
Private cCodAdiAbo	 := ""
Private cCodAdAMs	 := ""
Private cCodSalV     := cCodSalVMs := ""
Private dDtBasFer    := CTOD("")
Private dDtBasCal    := CTOD("")
Private cTpBxFer     := GetMvRH("MV_TPBXFER",, "1")			//-- Baixa Ferias Total ou Mes e Mes Seguinte
Private cTpCongAf    := "2"									//-- Trata congelamento por periodo Aquisitivo ou Por afastamento
//PROVISAO DE 13o SALARIO
Private a13Salar     := Array(_Linhas,_Colunas)
Private a14Salar     := Array(_Linhas,_Colunas)
Private aRec13Sl     := Array(_Linhas,_Colunas)
Private aRec14Sl     := Array(_Linhas,_Colunas)
Private cOneFol		 := If (Type("P_FDESFOL") # "U", P_FDESFOL, "")
Private cAnoMes		 := AnoMes( dDataRef )
Private lDif13Neg    := (GetMvRH("MV_DF13NEG",,"S")=="S") // Gerar diferenca de 13o. negativa S/N
Private cCod13o	  	 := cCodAd13o := ""
Private cCodPlr		 := ""
Private cInss13o	 := ""
Private lBx13Pgt     := .F.								    //-- Baixa 13o Salario pelo pagamento
Private lBx14Pgt	 := .F.									//-- Baixa 14o Sal·rio pelo pagamento
Private lBxPlrPgt    := .F.								    //-- Baixa PLR pelo pagamento
Private lDesAtiv     := .F.
Private lOneAtiv	 := .F.
Private nAvosAnt     := 0
Private nPercAnt     := 0
Private nSalario	 := nSalMes  := nSalDia     := nSalHora  := 0
Private nPercEmp	 := nPercTer := nPercAcTrab := nPercFgts := 0
Private nPerEmp13	 := 0
Private nPercPis	 := 0
Private aInfo	     := {}
Private aVerba       := {}
Private aTransf      := {}
Private aGPSPer      := {}
Private aCcEmpTra    := {}
Private lDemitido    := .F.
Private lINSSAut   	 := .F.
Private lTransfSai   := .F.
Private lSalInc    	 := .F.
Private lTrataTrf    := .F.
Private c__Roteiro   := "   "
Private cPerFeAc     := GetMvRH("MV_FERPAC",,"N")  				//-- Usada na Funcao FCalcFimAq-(GpexMed).
Private aInssEmp[23][2]
Private aVerbasFunc := {}
// POSICAO DOS CAMPOS NO ARRAY aVerbasFunc
Private nPosFil     := 01
Private nPosMat		:= 02
Private nPosPd		:= 03
Private nPosTipo	:= 04
Private nPosQtdSem	:= 05
Private nPosHoras	:= 06
Private nPosValor	:= 07
Private nPosSemana	:= 08
Private nPosParcela := 09
Private nPosPeriodo	:= 10
Private nPosRoteiro	:= 11
Private nPosCc		:= 12
Private nPosData	:= 13
Private nPosDtRef	:= 14
Private nPosSeq		:= 15
Private nPosTpo2	:= 17
Private cCalcSalInc := GetMvRH("MV_CSALINC",,Space(6))		//-- Ano/Mes para inicio da busca dos salarios e adicionais no acumulado, sem a utilizacao da fSalInc.
Private lCalcSalInc := If(Empty(cCalcSalInc) ,.T. , cCalcSalInc > MesAno(dDataRef)  )
Private Val_SalMin  := 0.00
Private lTrfSld		:= .F.
Private dDataDem1	:= Ctod("//")
Private lSabDom		:= If(GetMvRH("MV_SABDOM")=="S", .T., .F.) //Se pagara o sab e domingo qdo demissao na sexta
//Funcao fSalInc
Private aCodFol  	:= {}
Private aRoteiro 	:= {}
Private nAdtServ 	:= nPeric	:= nInsal := nAdcConf := nAdcTransf := nSalhInc := 0.00	  // Valores dos Adicionais
Private nOutros 	:= 0.00	  // Valores de outras verbas que incorporam
Private cCodAdt  	:= cCodIns  := Space(3) 		  // Codigos que Foram Gerados
Private nSalMin  	:= 0
//FUNCAO fMonta_TPR()
Private cNomeDe     := Replic("A", 30)
Private cNomeAte    := Replic("Z", 30)
//FUNCAO Calc_Fer()
Private nDiasProp   := nDiasVenc := 0
Private nTDiasAfa   := 0
Private cTipAfa     := " "
// QUANDO VIER DE OUTRO LOCAL DIFERENTE DO CALCULO DE PROVISAO NAO DEVERA UTILIZAR O GRID
If Type("lGrid") == "U"
	Private lGrid	:= .F.
EndIf
Private nIniTime	:= nTimeFim		:=	Seconds()	// Tempo de calculo para o GRID
Private cRecFatEmp	:= ""
Private cTipoPesq	:= "PRFE"
Private lSemSRF		:= .F.
Private l13Estag	:= .F.
Private aRateio		:= {}
Private lVerFat		:= .T.
Private nMinGrid 	:= GetMvRH("MV_MINGRID",, 0)
Private nRecCount   := 0

Private aFldRot 	:= {'RA_NOME'}
Private aOfusca	 	:= If(FindFunction('ChkOfusca'), ChkOfusca(), {.T.,.F.}) //[1] Acesso; [2]Ofusca
Private lOfuscaNom 	:= .F.
Private aFldOfusca 	:= {}
Private nSalInc		:= 0

If aOfusca[2]
	aFldOfusca := FwProtectedDataUtil():UsrNoAccessFieldsInList( aFldRot ) // CAMPOS SEM ACESSO
	IF aScan( aFldOfusca , { |x| x:CFIELD == "RA_NOME" } ) > 0
		lOfuscaNom := FwProtectedDataUtil():IsFieldInList( "RA_NOME" )
	ENDIF
EndIf

//PLR
Private aPLRSalar     := Array(_Linhas,_Colunas)
Private aRecPLRSl     := Array(_Linhas,_Colunas)

DEFAULT lItemClVl     := GetMvRH("MV_ITMCLVL", .F., "2") $ "13"
DEFAULT lProvResc     := (GetMvRH("MV_PROVRES",,"N") == "S") 	//-- Indica se devera provisionar no mes da rescisao
DEFAULT lVerMetrics	  := FwLibVersion() >= "20200727" .And. FindClass( "FWCustomMetrics" ) .And. FindFunction( cFunExec ) .And. &cFunExec.() >= "19.3.0.6"

//BUSCA O PERCENTUAL DA CONTRIBUICAO DO FGTS (APOS 01/10/2001
nPercFgC := 0
If MesAno(dDataRef) >= "200110" .And. MesAno(dDataRef) <= "200612"
	nPercFgC := GetMvRH("MV_PERCFGC",, 0) / 100  //Contribuicao do FGTS
EndIf

If !lGrid
	//Cria Arquivo de Medias Temporario
	Cria_TRP()
EndIf

//Monta o arquivo temporario "TPR" a partir do SRA e SRE
fMonta_TPR("","",nOrdem,dDataRef,@lSalInc,@lTrataTrf,@aTransf,lIncluiDem,,,,,cFiltroSRA)
dbSelectArea(cTBLXPROV)

nRecCount := ( cTBLXPROV )->( RecCount() ) // Contando quantos recnos tem na tabela
If lGrid .And. nMinGrid > 0 .And. nRecCount < nMinGrid // ValidaÁ„o para grid respeitar o parametro MV_MINGRID
	lGrid := .F.
	Cria_TRP()
EndIf

//Arquivo para Controle de LOG - Transacao
If lGrid
	Private cNameFile   := "M070"+FWGrpCompany("SRC")			// Tabela temporaria de log
	Private cFileTrf	:= Subst(CriaTrab(NIL,.f.),1,7) + "T"	// Tabela temporaria de transferencias
	Private cDbfLog 	:= "M070LOG"							// Alias de log
	Private cTrfDbf		:= "M070TBL"							// Alias de transferencia
	Private cChaveLog	:= DTOC(MsDate()) + "-" + Time()
	Private nTamTrf		:= Len(aTransf)						// No. de elementos total de aTransf

	Private nRetCalc	:= 0

	If !fOpenLog(@cDbfLog)
		 Aviso(STR0015, STR0027, { STR0016 }) // "Atencao" ## "Nao foi possivel abrir o arquivo de registro de ocorrencias." ## "Ok"
		 Return(.F.)
	EndIf

	IF Select(cDbfLog) > 0
		DbSelectArea(cDbfLog)
		If !Eof()
			cDtHrProc := AllTrim(Substr((cDbfLog)->CHAVE, 1)) + " " + OemToAnsi(STR0028) // "Horas"
			cMsgLog := OemToAnsi(STR0029) + " " + cDtHrProc + " " + OemToAnsi(STR0030) + CRLF // "O processamento realizado em:" ## "n„o foi concluÌdo com Sucesso."
			cMsgLog += OemToAnsi(STR0031) + CRLF + CRLF // "Os ˙ltimos funcion·rios processados foram: "

			cMsgLog += Substr(OemToAnsi(STR0032)	+ Space(5),1,16) // "Requisicao"
			cMsgLog += Substr(OemToAnsi(STR0033)	+ Space(5),1,12) // "Filial"
			cMsgLog += Substr(OemToAnsi(STR0034)	+ Space(5),1,15) // "Matricula"
			cMsgLog += OemToAnsi(STR0035)	+ CRLF // "Nome"
			cMsgLog += Replicate("-", 75) + CRLF

			lMsgGrid := .F.
			While (cDbfLog)->(!Eof())
				If (cDbfLog)->FILIAL >= cFilDe .and. (cDbfLog)->FILIAL <= cFilAte .and. (cDbfLog)->MAT >= cMatDe .and. (cDbfLog)->MAT <= cMatAte
					lMsgGrid := .T. //Exibe a mensagem apenas se existir registros do mesmo range. Pode estar sendo calculado a provis„o com outra parametrizaÁ„o em outra estaÁ„o.
				EndIf
				If (cDbfLog)->CONTROL = '1'
					cMsgLog += (cDbfLog)->REQUIS + Space(8)
					If !Empty((cDbfLog)->MAT)
						cMsgLog += (cDbfLog)->FILIAL + Space(10)
						cMsgLog += (cDbfLog)->MAT + Space(9)
						cMsgLog += Substr((cDbfLog)->NOME,1,36) + CRLF
					Else
						cMsgLog += OemToAnsi(STR0036) + CRLF //"Nenhum Funcion·rio Processado nessa RequisiÁ„o"
					EndIf
				EndIf
				(cDbfLog)->(Dbskip())
			EndDo
			If lMsgGrid
				cMsgLog += CRLF + CRLF + OemToAnsi(STR0037) //"Deseja Continuar com o Calculo?"
				If MsgYesNo(cMsgLog, OemToAnsi(STR0015))
					cQuery := " DELETE FROM "
					cQuery += " "+ cNameFile
					TcSqlExec(cQuery)
				Else
					Return
				EndIf
			EndIf
		EndIf
	EndIf

	// CRIACAO DA TABELA TEMPOARARIA PARA ARMAZENAMENTO DO ARRAY  ≥
	// ATRANSF. ISSO FAZ-SE NECESSARIO DEVIDO A GRANDE QUANTIDADE ≥
	// DE INFORMACOES QUE ESSE ARRAY PODE CONTER E QUE ASSIM NAO  ≥
	// HA COMO PASSA-LO VIA APARAMB NA PREPARACAO DO GRID, POIS   ≥
	// PODE ESTOURAR O LIMITE MAXIMO DE TAMANHO DE 1MB DA STRING  ≥
	// ENVIADA VIA RPC PARA PREPARACAO DO AMBIENTE.               ≥

	If !CriaTransf()
		 Aviso(STR0015, STR0063, { STR0016 }) // "Atencao" ## "N„o foi possÌvel abrir a tabela tempor·ria de transferÍncias." ## "Ok"
		 Return(.F.)
	EndIf

	IF Select(cTrfDbf) > 0
		DbSelectArea(cTrfDbf)
		For nTrf := 1 To nTamTrf
			For nEleTrf := 1 To 3
				Reclock((cTrfDbf), .T.)
				(cTrfDbf)->TRFPOS		:= nTrf	// Posicao no aTransf original
				(cTrfDbf)->TRFELE		:= nEleTrf	// Posicao no aTransf original
				(cTrfDbf)->TRFEMPP		:= aTransf[nTrf, nEleTrf, 1]
				(cTrfDbf)->TRFFILIALP	:= aTransf[nTrf, nEleTrf, 2]
				(cTrfDbf)->TRFCCP		:= aTransf[nTrf, nEleTrf, 3]
				(cTrfDbf)->TRFMATP		:= aTransf[nTrf, nEleTrf, 4]
				(cTrfDbf)->TRFDATE		:= aTransf[nTrf, nEleTrf, 5]
				(cTrfDbf)->TRFNLIDO		:= aTransf[nTrf, nEleTrf, 6]
				If lItemClVl
					(cTrfDbf)->TRFITMP		:= aTransf[nTrf, nEleTrf, 7]
					(cTrfDbf)->TRFCLVLP		:= aTransf[nTrf, nEleTrf, 8]
				EndIf
				(cTrfDbf)->(MsUnlock())
			Next nEleTrf
		Next nTrf
	EndIf
EndIf

//GARANTE ORDEM 1 PARA BUSCA DOS LANCAMENTOS NO MOVIMENTO
dbSelectArea("SRC")
dbSetOrder(1)

//GARANTE ORDEM 1 PARA BUSCA DOS FUNCIONARIOS
dbSelectArea("SRA")
dbSetOrder(1)

//POSICIONA NO INICIO DO ARQUIVO
dbSelectArea(cTBLXPROV)
dbGoTop()

If !lGrid 
	nRegsProc := RecCount()
    //CARREGA REGUA DE PROCESSAMENTO
	ProcRegua(nRegsProc)
EndIf

cFilialAnt := Replicate("!", FWGETTAMFILIAL)
cCcAnt	   := "!!!!!!!!!"

cBkpBxFer := cTpBxFer

While (cTBLXPROV)->(!Eof())
	// seta as vari·veis a cada novo funcion·rio.
	lZerouSal := .F. 
	cCongFER  := "1" 
	cCong13   := "2" 
	If lAbortPrint
		Exit
	Endif

	cTpBxFer := cBkpBxFer

	SALHOR := 0

	If lGrid
		If nCountReg == 0 .Or. nCountReg >= nLoteGrid
			Aadd(aCall, {})
			If(!lIsBlind,MsProcTxt(OemToAnsi(STR0044) + " " + Strzero(Len(aCall),6)),NIL) // "Numero de RequisiÁıes Geradas: "
			nRegGrid++
			nCountReg := 0
		EndIf
		nCountReg++
		//SE A ESTRUTURA DA TABELA TPR MUDAR, TEM QUE PASSAR OS NOVOS CAMPOS AQUI PARA QUE FUNCIONE CORRETAMENTE NO GRID
		Aadd(aCall[nRegGrid], { nRegGrid, (cTBLXPROV)->PR_FILIAL, (cTBLXPROV)->PR_MAT, (cTBLXPROV)->PR_CC, (cTBLXPROV)->PR_TIPMOVI,Alltrim((cTBLXPROV)->PR_NOME),;
								(cTBLXPROV)->PR_ADMISSA,(cTBLXPROV)->PR_DEMISSA,(cTBLXPROV)->PR_SITFOLH,(cTBLXPROV)->PR_AFASFGT,(cTBLXPROV)->PR_TPCONTR,;
								(cTBLXPROV)->PR_HRSMES,(cTBLXPROV)->PR_SALINCO,(cTBLXPROV)->PR_PERICUL,(cTBLXPROV)->PR_INSMIN,(cTBLXPROV)->PR_INSMED,(cTBLXPROV)->PR_INSMAX,;
								(cTBLXPROV)->PR_ADTPOSE,(cTBLXPROV)->PR_INSSAUT,(cTBLXPROV)->PR_CATFUNC, ;
								(cTBLXPROV)->PR_ITEM,(cTBLXPROV)->PR_CLVL,(cTBLXPROV)->PR_CCMVTO,(cTBLXPROV)->PR_ITMMVTO,(cTBLXPROV)->PR_CLVMVTO})
	Else
		If !lSegPlan
			// Apresenta o Funcionario que esta sendo calculado
			IncProc((cTBLXPROV)->PR_FILIAL+" - "+(cTBLXPROV)->PR_MAT+ If(lOfuscaNom,''," - "+(cTBLXPROV)->PR_NOME))
		EndIf
		// Garante o Posicionamento do Funcionario no SRA
		dbSelectArea("SRA")
		dbSeek((cTBLXPROV)->PR_FILIAL + (cTBLXPROV)->PR_MAT)
		dbSelectArea(cTBLXPROV)

		If !GPM070CALG()
			Exit
		EndIf
	EndIf

	DbSelectArea(cTBLXPROV)
	(cTBLXPROV)->(dbSkip())
Enddo

If (lGp070Fim)
	EXECBLOCK("GP070FIM",.F.,.F.)
Endif

If lGrid
	// EXECUCAO DO CALCULO DA PROVISAO ATRAVES DO GRID
	CalcGrid(aCall,aPar,aAreaSRA)
Else
	//Elimina arquivo tempor·rio de mÈdia
	fDelTMPMED()

	nTimeFim	:= Seconds()	// TEMPO DE CALCULO PARA O GRID
    cDurTempo   := SecsToTime(nTimeFim - nIniTime)

	// APRESENTA TELA COM LOG DE ERROS
	aLogFile[1] := { "" , "", "" }
	aLogFile[1, 1] += STR0057 + " " + SecsToTime(nIniTime) + " " + STR0046 + " " + dDtCalIni 			 // "Inicio do Processo de Calculo:" ## "de"
	aLogFile[1, 2] += STR0045 + " " + SecsToTime(nTimeFim) + " " + STR0046 + " " + Dtoc(MsDate())	 // "Final do Processo de Calculo:" ## "de"
	aLogFile[1, 3] += STR0047 + " " + cDurTempo  // "Duracao do Processo de Calculo:"
	If lSegPlan
		IncProc()
		GPESmartViewUtils():CreateLog(aLogFile, aLogTitle, "GPM070", .T.,,,,,,,aLogPerg)//(aLogFile, aLogTitle , "GPM070" , NIL , FunName())
	ElseIf !IsBlind()
		fMakeLog(aLogFile, aLogTitle, "GPM070", .T.,,,,,,,aLogPerg)
	EndIf
    If lVerMetrics .And. nRegsProc >= 100
        FwCustomMetrics():setAverageMetric( "PROVISAO", "totvs-rh-protheus_processamento-calculos_average", TimeToSeconds( cDurTempo )/60  )
    EndIf
	// RETORNA AREA ORIGINAL DO CADASTRO DE FUNCIONARIOS
	RestArea(aAreaSRA)
EndIf

//Elimina arquivo tempor·rio de provis„o
fDelTMPPRV()

cFilAnt := _cFilAnt

Return Nil

/*
‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±⁄ƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒø±±
±±≥Funcao    ≥fProvFer  ≥ Autor ≥ Emerson Rosa de Souza	≥ Data ≥ 26.06.00 ≥±±
±±√ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒ¥±±
±±≥Descricao ≥ Calcula provisao de ferias vencidas                        ≥±±
±±√ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¥±±
±±≥Sintaxe   ≥ fProvFer(cCongAci,cCongDoe,nTipoMovMes,dDtBasFer)          ≥±±
±±√ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¥±±
±±≥Uso       ≥ Generico                                                   ≥±±
±±¿ƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒŸ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂ*/
Static Function fProvFer(cCongFeR, nTipoMovMes, dDtBasFer, lCodMPA, dIniAdi, dFimAdi, cPerPag)
Local nAdtDia     := nInsDia   := nPerDia   := nNroFaltas := nPeriVenc := nAdcConDia := nAdcTrfDia := 0
Local nOutDia     := 0
Local nV_TotFer := 0
Local lCongelaFer := .F.
Local aDados      := {}
Local dRetFimOP   := Ctod("")
Local k			  := 0
Local nDsrHrsAtiv := 0
Local lEstagio	  := (cTBLXPROV)->PR_CATFUNC $ "E|G"
Local nValFerAviso := 0
Local nValFeAv 	  := 0
Local nDiasAvi	  := 0
Local cMedDir	  := P_MEDDIREN//GetMvRH("MV_MEDDIRE")
Local nDiasAnt	  := 0 //Dias de fÈrias antecipadas de cada perÌodo aquisitivo.
Local nDFerAntP	  := 0 //Dias de fÈrias antecipadas do perÌodo proporcional
Local nIntFer 	  := 0    
Local nPos        := 0

Local cPdResc	  := aCodFol[248,1] + "|" + aCodFol[086,1] + "|" + aCodFol[1424, 1]
Local cPdAvis	  := aCodFol[230,1]
Local cPdFProp	  := aCodFol[087,1] + "|" + aCodFol[1425, 1]
Local lDivAdi 	  := ( Len(aCodFol) >= 1721 ) .And. !Empty(aCodFol[1680,1])
Local lContrInt	  := If(SRC->(ColumnPos( 'RC_CONVOC' )) > 0,.T.,.F.)
Local nBx_Inss	  := 0
Local nBx_Fgts	  := 0
Local nBx_Pis	  := 0
Local nFalTmp	  := 0
Local nBkpDiasC	  := 0

//UTILIZADAS NOS PONTOS DE ENTRADA
Private nV_DSaldo := nV_Valor  := nV_Adic := nV_UmTer := nV_Inss := nV_Fgts := nV_Pis := nV_AdiFunc := 0
Private nP_DSaldo := nP_Valor  := nP_Adic := nP_UmTer := nP_Inss := nP_Fgts := nP_Pis := nP_AdiFunc := 0
Private nV_CSocial := nV_Bse := nP_CSocial := nP_Bse	:= 0
Private nV_ObraSoc := nV_Ley := nV_Jubil := nP_ObraSoc := nP_Ley  := nP_Jubil := 0
Private cProce := ""
Private nV_FerRes := 0
Private nP_FerRes := 0

DEFAULT lProvavp    := If( Type("P_PROVAVP") == "U" .Or. P_PROVAVP == "S",.T.,.F.)
DEFAULT lMtdFal	    := If( Type("lMetadeFal") == "U", .F. , lMetadeFal)
DEFAULT lTmpParc    := If( Type("lTempoParc") == "U", .F. , lTempoParc)
DEFAULT lGp070Ant   := ExistBlock("GP070ANT")
DEFAULT lProvResc   := (GetMvRH("MV_PROVRES",,"N") == "S") 	//-- Indica se devera provisionar no mes da rescisao
DEFAULT lGp070Ven   := ExistBlock("GP070VEN")
DEFAULT lGp070V13   := ExistBlock("GP070V13")
DEFAULT lGp070VIF   := ExistBlock("GP070VIF")
DEFAULT lGp070PRO   := ExistBlock("GP070PRO")
DEFAULT lGp070P13   := ExistBlock("GP070P13")
DEFAULT lGp070PIF   := ExistBlock("GP070PIF")
DEFAULT lCodMPA	    := .F.
DEFAULT dIniAdi	    := cToD("//")
DEFAULT dFimAdi	    := cToD("//")
DEFAULT cPerPag	    := ""
DEFAULT lTemPostUmT := SRH->( ColumnPos( "RH_POSTUMT" ) ) > 0

//Tratamento para P_MEDDIREN = "M" - Misto. Calcula como se fosse "S" para funcion·rio com menos de um ano de contrato por tempo determinado.
If cMedDir == "M"
	cMedDir := If(SRA->RA_TPCONTR == "2" .and. DateDiffYear( SRA->RA_DTFIMCT , SRA->RA_ADMISSA ) < 1, "S", "N")
EndIf

// PONTO DE ENTRADA P/ ALTERAR DATABASE FERIAS E DIAS FERIAS ANTECIPADAS
If lGp070Ant
	aDados	:=	ExecBLock('GP070ANT',.F.,.F.,{dDtBasFer,dDataRef,nDFerAnt})
	If ValType(aDados) == "A" .And. !Empty(aDados)
		If ValType(aDados[1]) == "N" .And. ValType(aDados[2]) == "D"
			nDFerAnt  := aDados[1]
			dDtBasFer := aDados[2]
		EndIf
	EndIf
Endif

If lHojorva
	cProce := "1" // Indicador de ferias vencidas, ser· usado na fMediaHora() do gpexcal3
	fSalHvar()
Endif

nDiasVenc += SRF->RF_DVENPEN // Soma os dias de ferias pendentes

If nDiasVenc > 0 .and. lDemitido
	fIncRes(SRA->RA_FILIAL,SRG->RG_TIPORES,aIncRes)
	If !Empty(aIncRes) .and. aIncRes[20] == "N" //Se tipo de rescis„o indicar que n„o deve calcular fÈrias vencidas, n„o provisiona fÈrias
		nDiasVenc := 0
	EndIf
EndIf

// Verifica se houve afastamento e se deve congelar
If (cTBLXPROV)->PR_SITFOLH == "A" .And. cCongFeR  == "2"
	//congela apos primeiro mes
	If !empty(dIniAfa) .And. (dDataRef - dIniAfa ) >= 30
		// Congela e mantem os dias de vencidas do mes anterior
		lCongelaFer := .T.
		// Congela e mantem os dias de proporcionais do mes anterior
		Aeval(aPerFerias,{|X| nFalTmp += X[16]})
		If nFalTmp == 0
			nDiasProp := Iif(aFerProp[_Anter,_Dias] > 0, aFerProp[_Anter,_Dias], nDiasProp)
		EndIf
		nDiasVenc := Iif( (cTBLXPROV)->PR_TIPMOVI != 6, aFerVenc[_Anter,_Dias], nDiasVenc )
	EndIf
Elseif (cCongFeR  == "3" )  .and. ((nTDiasAfa > 0) .and. (Empty(dRetFimOP) .or. (dRetFimOP >=dDataRef))) //-   array
	//Somente congelar se houver mais de 180 dias afastado
	If nTDiasAfa >= 180
		nDiasProp	:= 0
		lCongelaFer := .T.
	EndIf
Elseif (cCongFeR  == "1" .And. (cTBLXPROV)->PR_SITFOLH == "A" .And. (cTBLXPROV)->PR_AFASFGT $ "O") .Or.;
	   (cCongFeR  == "1" .And. (cTBLXPROV)->PR_SITFOLH == "A" .And. (cTBLXPROV)->PR_AFASFGT $ "P")
	// Congela e mantem os dias de vencidas do mes anterior
	lCongelaFer := .T.
Endif

// VERIFICA TIPO DE MOVIMENTACAO DO FUNCIONARIO
nTipoMovMes := If(lCongelaFer .And. !lDemitido, _Cong_Fer, nTipoMovMes) // Alterar Movimento p/2 (congela), qdo "lCongelaFer" for .T. e nao for demitido.

// VERIFICA SE DEVE PAGAR OS ADICIONAIS
nAdtDia 	:= (nAdtServ / 30)
nInsDia 	:= (nInsal / 30)
nPerDia 	:= (nPeric / 30)
nAdcConDia 	:= (nAdcConf / 30)
nAdcTrfDia 	:= (nAdcTransf / 30)
nOutDia 	:= (nOutros / 30)

// CALCULO DAS FERIAS VENCIDAS
If (!lDemitido .Or. lProvResc)
	If  nDiasVenc == 0
		aFerVenc[_Atual,_Dias] := 0
	Else
		If lHojorva
			If (!lDemitido .Or. lProvResc)// para jornada variavel a media deve ser feita neste momento
				If lLimpaMed
					dbSelectArea(cTBLXMED)
					Zap
					dRefMed		:= If(lProvResc .And. lDemitido,dDataDem1,dDataRef)
					nBkpDiasC	:= nDiasC
					GpexMed(dDtBasFer,,dRefMed,,dRefMed,nSalHora,nSalMin,aCodFol,.T.,(!lFechouMes),,,,,,,nSalhInc)
					nDiasC 		:= nBkpDiasC
					lLimpaMed 	:= .F.
				EndIf
			EndIf
		EndIf
		dbSelectArea(cTBLXMED)
		(cTBLXMED)->(dbGoTop())
		// VERIFICA NUMERO DE FALTAS EM CADA PERIODO DE FERIAS VENCIDAS
		For k := 1 To Len(aPerFerias)
			nNroFaltas := Iif(aPerFerias[k,3] == aTabFer[3] .And. !lFechouMes .And. aFerVenc[_Anter,_Dias] == 0 .And. aPerFerias[k,15] == 0, aPerFerias[k,16],aPerFerias[k,15])
			TabFaltas(@nNroFaltas, Nil, aClone(aPerFerias[k]))
			nV_DFalFer += If(!lMetadefal, If(!lTempoParc, nNroFaltas, 0), (nDiasVenc / 2  - nDFerAnt) )
			nTFaltaV   := nV_DFalFer
		Next k
		If lProvResc .And. ( (cTBLXPROV)->PR_TIPMOVI == _Demitido .or.  ((cTBLXPROV)->PR_TIPMOVI == _Trfe_Ent .and. lDemitido .and. AnoMes(SRA->RA_DEMISSA) == cAnoMes) )
			nDFerAnt  := 0
			nV_DSaldo := nDiasVenc := SRG->RG_DFERVEN
			nV_Valor  := NoRound(nSalDia * nV_DSaldo)

			DbSelectArea("SRR")
			DbSetOrder(1)
			If lDivAdi
				cPdResc +=  "|" + aCodFol[1680,1] + "|" + aCodFol[1686,1] + "|" + aCodFol[1692,1] + "|" + aCodFol[1698,1] + "|" + aCodFol[1704,1] + "|" + aCodFol[1710,1] + "|" + aCodFol[1716,1]
			EndIf
			If DbSeek((cTBLXPROV)->PR_FILIAL + (cTBLXPROV)->PR_MAT + 'R' + Dtos(SRG->RG_DTGERAR)) //+ aCodFol[086,1])//Ferias vencidas
				While SRR->( !EoF() ) .And. SRR->RR_FILIAL + SRR->RR_MAT + SRR->RR_TIPO3 + dToS(SRR->RR_DATA)  == (cTBLXPROV)->PR_FILIAL + (cTBLXPROV)->PR_MAT + 'R' + Dtos(SRG->RG_DTGERAR)
					If SRR->RR_PD $ cPdResc
						nV_FerRes += SRR->RR_VALOR
						If RetValSrv(SRR->RR_PD,SRA->RA_FILIAL,"RV_INSS") == "S"
							nBx_Inss += SRR->RR_VALOR
						EndIf
						If RetValSrv(SRR->RR_PD,SRA->RA_FILIAL,"RV_FGTS") == "S"
							nBx_Fgts += SRR->RR_VALOR
						EndIf
						If RetValSrv(SRR->RR_PD,SRA->RA_FILIAL,"RV_PIS") == "S"
							nBx_Pis += SRR->RR_VALOR
						EndIf
					EndIf
					SRR->( dbSkip() )
				EndDo
			EndIf

			nV_Adic := nV_FerRes - nV_Valor

		Else
			dbSelectArea("SRH")
			dbSetOrder(1)
			If !lMetadeFal// .And. !lTempoParc
				nV_DSaldo  := nDiasVenc - nDFerAnt - nV_DFalFer
			Else
				nV_DSaldo  := nDiasVenc / 2  - nDFerAnt
			Endif

			nV_Valor   := NoRound(nSalDia * nV_DSaldo)

			nV_AdiFunc := fCalAdcFun("PFER", dDataRef, nSalario)
			nV_AdiFunc := nV_AdiFunc / 30 * nV_DSaldo

			//Verificao de Intermitente para Indeterminado
			If (  lContrInt .and. SRA->RA_TPCONTR <> '3'.and. fTemInterm(.T., dDtBasFer) ) 
				nIntFer := 0    //-- FÈrias
							
				//Busca verbas de 13o. pagas no ano como contrato intermitente
				fAbtFerInterm(@nIntFer )
				nV_Valor -= nIntFer
			EndIf

			nV_Adic    := (nInsDia+nPerdia+nAdtDia+nAdcConDia+nAdcTrfDia+nOutDia) * nV_DSaldo
			// CALCULA ADICIONAIS PARA CADA PERIODO DE FERIAS VENCIDAS
			nPeriVenc  := Max(Int(nDiasVenc/aTabFer[3]), 1)
			For k := 1 To 6
				cTipMed	:= Str(If(k ==1, 1,k+3), 1)
				nDsrHrsAtiv := fDsrHrsAtiv(cTipMed,aCodFol) //Calculo do DSR / Horas Atividade de professores
				If nDsrHrsAtiv > 0
					fHistMed(dDataRef,,anomes(dDataRef),"01","PRV",{nSalInc,nSalDia,nSalHora,nPeric,nInsal,nAdcConf,nAdcTransf,nAdtServ,nSalario})
				ENDIF
				
				If (cTBLXMED)->(dbSeek((cTBLXPROV)->PR_FILIAL + (cTBLXPROV)->PR_MAT + cTipMed + "999" + If(cMedDir == "S", "9999" , "99MD")))
					If nV_DSaldo > 0
						// Tratativa abaixo para considerar as mÈdias de acordo com o perÌodo aquisitivo, caso o funcionario possua mais de um perÌodo vencido
						// Na vari·vel nDFerAnt contÈm a quantidade de dias de fÈrias antecipadas, de acordo com o data de referencia do c·lculo da provis„o
						// Caso essa vari·vel esteja com 0, quer dizer que na data do c·lculo da provis„o, n„o h· fÈrias antecipadas.
						// Contudo, se houver fÈrias antecipadas, a vari·vel n„o far· separaÁ„o sobre qual o perÌodo consiste as fÈrias antecipadas.
						// Por isso a validaÁ„o. Se houver fÈrias antecipadas, ou seja, nDFerAnt > 0, usa-se os dias de fÈrias antecipadas de cada perÌodo "aPerFerias[k][14"
						If nDFerAnt == 0 .Or. cTpBxFer == "2"
							nV_Adic += ((((cTBLXMED)->RP_VALATU + nDsrHrsAtiv)/aPerFerias[k][3]) * (aPerFerias[k][3]-nDFerAnt))
						Else
							//Se n„o fechou o mÍs, a variavel nDFerAnt n„o est· com todos os dias de fÈrias antecipadas.
							If !lFechouMes
								nDiasAnt := 0
								//Busca os registros de fÈrias na SRH de acordo com cada perÌodo aquisitivo.
								If dbSeek( (cTBLXMED)->RP_FILIAL + (cTBLXMED)->RP_MAT + dToS(aPerFerias[k][1]) )
									//Faz o While pois pode possuir mais de uma c·lculo de fÈrias para o mesmo perÌodo.
									While SRH->( !Eof() ) .And. SRH->RH_FILIAL + SRH->RH_MAT + dToS(SRH->RH_DATABAS) == (cTBLXMED)->RP_FILIAL + (cTBLXMED)->RP_MAT + dToS(aPerFerias[k][1])
										If AnoMes(dDataRef) >= SRH->RH_PERIODO
											nDiasAnt += (SRH->RH_DFERIAS + SRH->RH_DABONPE)
										EndIf
										SRH->(dbSkip())
									EndDo
									nV_Adic += ((( (cTBLXMED)->RP_VALATU + nDsrHrsAtiv ) / aPerFerias[k][3] ) * ( aPerFerias[k][3]-nDiasAnt ) )
								Else
									//Se n„o encontrar fÈrias, ent„o considera a quantidade gravada no array.
									nV_Adic += ((((cTBLXMED)->RP_VALATU + nDsrHrsAtiv)/aPerFerias[k][3]) * (aPerFerias[k][3] ))
								EndIf
							Else
								//Se o mÍs j· estiver fechado, ent„o o array aPerFÈrias j· contÈm os registros antecipados perÌodo a perÌodo.
								nV_Adic += ((((cTBLXMED)->RP_VALATU + nDsrHrsAtiv)/aPerFerias[k][3]) * (aPerFerias[k][3] - aPerFerias[k][14] ))
							EndIf
						EndIf

					Endif
					//CALCULA PERIC./INSALUB VERBA DE MEDIAS QUE TEM INCIDENCIA
					nMedPer := nMedIns := 0.00
					FMedPerIns(@nMedPer,@nMedIns,cTipMed,nSalHora,nSalMin,aCodFol,,,,P_ADISMED)
					If nDFerAnt == 0
						nV_Adic += If(nV_DSaldo > 0 ,((nMedPer+nMedIns)/aPerFerias[k][3])*(aPerFerias[k][3]-nDFerAnt) ,0)
					Else
						If nV_DSaldo == 0
							nV_Adic += 0
						Else
							If !lFechouMes
								nDiasAnt := 0
								If dbSeek( (cTBLXMED)->RP_FILIAL + (cTBLXMED)->RP_MAT + dToS(aPerFerias[k][1]) )
									While SRH->( !Eof() ) .And. SRH->RH_FILIAL + SRH->RH_MAT + dToS(SRH->RH_DATABAS) == (cTBLXMED)->RP_FILIAL + (cTBLXMED)->RP_MAT + dToS(aPerFerias[k][1])
										nDiasAnt += (SRH->RH_DFERIAS + SRH->RH_DABONPE)
										SRH->(dbSkip())
									EndDo
									nV_Adic += ( ( nMedPer+nMedIns ) / aPerFerias[k][3] ) * ( aPerFerias[k][3] - nDiasAnt )
								Else
									nV_Adic += ( (nMedPer+nMedIns) / aPerFerias[k][3] ) * (aPerFerias[k][3] )
								EndIf
							Else
								nV_Adic += ( (nMedPer+nMedIns) / aPerFerias[k][3] ) * ( aPerFerias[k][3] - aPerFerias[k][14] )
							EndIf
						EndIf
					EndIf
				Endif
			Next k
		EndIf
		// PONTO DE ENTRADA PARA ALTERAR VALORES DOS ADICIONAL VENCIDAS
		If lGp070Ven
			EXECBLOCK("GP070VEN",.F.,.F.)
		Endif

		// SO IRA CALCULAR 1/3 DE FERIAS SE N√O FOR ESTAGIARIO
		If !lEstagio
			nV_UmTer   := NoRound((nV_Valor+nV_Adic+nV_AdiFunc) * If (nPerc1T=0.00 .Or. nPerc1T=100.00, 1/3 ,nPerc1T / 100))
			If cPaisLoc == "BRA" .And. lProvResc .And. (cTBLXPROV)->PR_TIPMOVI == _Demitido
				If RetValSrv(aCodFol[125,1],SRA->RA_FILIAL,"RV_INSS") == "S"
					nBx_Inss   += NoRound((nBx_Inss) * If (nPerc1T=0.00 .Or. nPerc1T=100.00, 1/3 ,nPerc1T / 100))
				EndIf
				If RetValSrv(aCodFol[125,1],SRA->RA_FILIAL,"RV_FGTS") == "S"
					nBx_Fgts    += NoRound((nBx_Fgts) * If (nPerc1T=0.00 .Or. nPerc1T=100.00, 1/3 ,nPerc1T / 100))
				EndIf
				If RetValSrv(aCodFol[125,1],SRA->RA_FILIAL,"RV_PIS") == "S"
					nBx_Pis     += NoRound((nBx_Pis) * If (nPerc1T=0.00 .Or. nPerc1T=100.00, 1/3 ,nPerc1T / 100))
				EndIf
			EndIf
		Endif

		// PONTO DE ENTRADA PARA ALTERAR VALORES DE 1/3 FER.VENCIDAS
		If lGp070V13
			EXECBLOCK("GP070V13",.F.,.F.)
		EndIf
		nV_TotFer  := nV_Valor + nV_Adic + nV_UmTer + nV_AdiFunc

		// SO IRA CALCULAR OS ADICIONAIS SE N√O FOR ESTAGIARIO
		If !lEstagio
			If cPaisLoc == "BRA" .And. lProvResc .And. (cTBLXPROV)->PR_TIPMOVI == _Demitido
				nV_Inss    := NoRound(nBx_Inss * (nPercEmp+nPercTer+nPercAcTrab))
				nV_Fgts    := NoRound(nBx_Fgts * nPercFgts)
				nV_Pis	   := NoRound(nBx_Pis * nPercPis)
			Else
				nV_Inss    := NoRound(nV_TotFer * (nPercEmp+nPercTer+nPercAcTrab))
				nV_Fgts    := NoRound(nV_TotFer * nPercFgts)
				nV_Pis	   := NoRound(nV_TotFer * nPercPis)
			EndIf
		Endif

		// PONTO DE ENTRADA PARA ALTERAR VALORES DE INSS E FGTS VENCIDAS
		If lGp070VIF
			EXECBLOCK("GP070VIF",.F.,.F.)
		EndIf

		// GRAVA OS VALORES CALCULADOS NO ARRAY DE FERIAS VENCIDAS

		aFerVenc[_Atual,_Dias] := nV_DSaldo
		If nDFerAnt > 0 .And. cTpBxFer == "2"
			aFerVenc[_Atual,_Prov] := nV_Valor
			aFerVenc[_Atual,_Adic] := nV_Adic + nV_AdiFunc
			aFerVenc[_Atual,_1Ter] := nV_UmTer
			aFerVenc[_Atual,_INSS] := nV_Inss
			aFerVenc[_Atual,_FGTS] := nV_Fgts
			aFerVenc[_Atual,_PIS]  := nV_Pis
		Else
			aFerVenc[_Atual,_Prov] += nV_Valor
			aFerVenc[_Atual,_Adic] += nV_Adic + nV_AdiFunc
			aFerVenc[_Atual,_1Ter] += nV_UmTer
			aFerVenc[_Atual,_INSS] += nV_Inss
			aFerVenc[_Atual,_FGTS] += nV_Fgts
			aFerVenc[_Atual,_PIS]  += nV_Pis
		EndIf
	EndIf
	//Retorna os valores de 1/3 e/ou abono pecuni·rio para o saldo
	If lCodMPA .And. !Empty(dIniAdi) .And. !Empty(cPerPag) .And. cAnoMes >= AnoMes(dIniAdi) .And. cAnoMes <= cPerPag
		SRH->( dbSetOrder(1) ) // RH_FILIAL+RH_MAT+DTOS(RH_DATABAS)+DTOS(RH_DATAINI)
		SRR->( dbSetOrder(1) ) // RR_FILIAL+RR_MAT+RR_TIPO3+DTOS(RR_DATA)+RR_PD+RR_CC+RR_PROCES
		If SRH->( dbSeek( (cTBLXPROV)->PR_FILIAL + (cTBLXPROV)->PR_MAT ) )
			While SRH->( !Eof() ) .And. SRH->RH_FILIAL+SRH->RH_MAT == (cTBLXPROV)->PR_FILIAL+(cTBLXPROV)->PR_MAT
				If cAnoMes >= AnoMes(SRH->RH_DATAINI) .And. SRH->RH_DATAINI >= dIniAdi .And. SRH->RH_DATAINI <= dFimAdi
                    fVerAdiMP()
				EndIf
				SRH->( dbSkip() )
			EndDo
		EndIf
	EndIf

    If lTemPostUmT .And. SRA->RA_SEXO = "F"
		SRH->( dbSetOrder(1) )//RH_FILIAL+RH_MAT+DTOS(RH_DATABAS)+DTOS(RH_DATAINI)
		SRK->( dbSetOrder(2) )//RK_FILIAL+RK_MAT+RK_NUMID
		If SRH->( dbSeek( (cTBLXPROV)->PR_FILIAL+(cTBLXPROV)->PR_MAT ) )
			While SRH->( !Eof() ) .And. SRH->RH_FILIAL+SRH->RH_MAT == (cTBLXPROV)->PR_FILIAL+(cTBLXPROV)->PR_MAT
				If SRH->RH_DATAINI >= cToD("21/09/2022") .And. cValToChar( Year(SRH->RH_DATAINI) ) == SubStr( cAnoMes, 1, 4 ) .And. SRH->RH_POSTUMT == "3" .And. SRK->( dbSeek( (cTBLXPROV)->PR_FILIAL+(cTBLXPROV)->PR_MAT+"FER-"+cValToChar( SRH->( Recno() ) ) ) ) .And. cAnoMes < AnoMes(SRK->RK_DTVENC)
                    fAdi14457()
				EndIf
				SRH->( dbSkip() )
			EndDo
		EndIf
    EndIf
EndIf

// CALCULO DE FERIAS PROPORCIONAIS
If (!lDemitido .Or. lProvResc)
	nBx_Inss	:= 0
	nBx_Fgts	:= 0
	nBx_Pis		:= 0
	If lDemitido .And. lProvavp
		nDiasAvi := SRG->RG_DFERAVI
		DbSelectArea("SRR")
		DbSetOrder(1)
		If lDivAdi
			cPdAvis +=  "|" + aCodFol[1682,1] + "|" + aCodFol[1694,1] + "|" + aCodFol[1706,1] + "|" + aCodFol[1712,1] + "|" + aCodFol[1718,1]
		EndIf
		If DbSeek((cTBLXPROV)->PR_FILIAL + (cTBLXPROV)->PR_MAT + 'R' + Dtos(SRG->RG_DTGERAR) )
			While SRR->( !EoF() ) .And. SRR->RR_FILIAL + SRR->RR_MAT + SRR->RR_TIPO3 + dToS(SRR->RR_DATA) == (cTBLXPROV)->PR_FILIAL + (cTBLXPROV)->PR_MAT + 'R' + Dtos(SRG->RG_DTGERAR)
				If SRR->RR_PD $ cPdAvis
					nValFerAviso += SRR->RR_VALOR
					If RetValSrv(SRR->RR_PD,SRA->RA_FILIAL,"RV_INSS") == "S"
						nBx_Inss += SRR->RR_VALOR
					EndIf
					If RetValSrv(SRR->RR_PD,SRA->RA_FILIAL,"RV_FGTS") == "S"
						nBx_Fgts += SRR->RR_VALOR
					EndIf
					If RetValSrv(SRR->RR_PD,SRA->RA_FILIAL,"RV_PIS") == "S"
						nBx_Pis += SRR->RR_VALOR
					EndIf
				EndIf
				SRR->( dbSkip() )
			EndDo
		EndIf
		nValFeAv := nValFerAviso - Round(nSalDia * nDiasAvi, 2)
	EndIf
	If lHojorva
		cProce := "2"	// Indicador de ferias proporcionais, ser· usado na fMediaHora() do gpexcal3
		fSalHvar()
	Endif
	For k := 1 To Len(aPerFerias)
		nNroFaltas := aPerFerias[k,16] 	//Faltas
		If nAvosTot == 0
			nNroFaltas += fVerSusp(aPerFerias[k]) 	//Suspensao Disciplinar
		EndIf
		If nNroFaltas == 0 .And. aPerFerias[k, 15] > 0 .And. (cTBLXMED)->( dbSeek(SRA->RA_FILIAL+SRA->RA_MAT+"2"+"998"+"9698") )
			nNroFaltas := (cTBLXMED)->RP_HORAS
		EndIf
		TabFaltas(@nNroFaltas, Nil, aClone(aPerFerias[k]))
		nNroFaltas := ((nNroFaltas / 30) * nDiasProp)
		If !lMetadeFal .And. !lTempoParc
			nP_DFalFer += nNroFaltas			
		ElseIf lMetadeFal
			nP_DFalFer := nDiasProp / 2
		Else
			nP_DFalFer := 0
		Endif
		//Utiliza os dias antecipados do ˙ltimo perÌodo que ser· o proporcional
		nDFerAntP := aPerFerias[k,14]
	Next k
	If lProvResc .And. ( (cTBLXPROV)->PR_TIPMOVI == _Demitido .or. ((cTBLXPROV)->PR_TIPMOVI == _Trfe_Ent .and. lDemitido .and. AnoMes(SRA->RA_DEMISSA) == cAnoMes) )
		nDFerAnt  := 0
		nP_DSaldo := nDiasProp := SRG->RG_DFERPRO
		nP_Valor  := Round(nSalDia * nP_DSaldo,2)

		DbSelectArea("SRR")
		DbSetOrder(1)
		If lDivAdi
			cPdFProp +=  "|" + aCodFol[1681,1] + "|" + aCodFol[1693,1] + "|" + aCodFol[1705,1] + "|" + aCodFol[1711,1] + "|" + aCodFol[1717,1]
		EndIf
		If DbSeek((cTBLXPROV)->PR_FILIAL + (cTBLXPROV)->PR_MAT + 'R' + Dtos(SRG->RG_DTGERAR))//Ferias proporcionais rescisao
			While SRR->( !EoF() ) .And. SRR->RR_FILIAL + SRR->RR_MAT + SRR->RR_TIPO3 + dToS(SRR->RR_DATA) == (cTBLXPROV)->PR_FILIAL + (cTBLXPROV)->PR_MAT + 'R' + Dtos(SRG->RG_DTGERAR)
				If SRR->RR_PD $ cPdFProp
					nP_FerRes += SRR->RR_VALOR
					If RetValSrv(SRR->RR_PD,SRA->RA_FILIAL,"RV_INSS") == "S"
						nBx_Inss += SRR->RR_VALOR
					EndIf
					If RetValSrv(SRR->RR_PD,SRA->RA_FILIAL,"RV_FGTS") == "S"
						nBx_Fgts += SRR->RR_VALOR
					EndIf
					If RetValSrv(SRR->RR_PD,SRA->RA_FILIAL,"RV_PIS") == "S"
						nBx_Pis += SRR->RR_VALOR
					EndIf
				EndIf
				SRR->( dbSkip() )
			EndDo
		EndIf

		If nP_FerRes > 0
			nP_Adic  := nP_FerRes - nP_Valor
		Else
			nP_Valor := 0
		EndIf
		nP_Valor += (nValFerAviso - nValFeAv)

		If DbSeek((cTBLXPROV)->PR_FILIAL + (cTBLXPROV)->PR_MAT + 'R' + Dtos(SRG->RG_DTGERAR) + aCodFol[249,1])//Media ferias proporcionais rescisao
			While SRR->( !EoF() ) .And. SRR->RR_FILIAL + SRR->RR_MAT + SRR->RR_TIPO3 + dToS(SRR->RR_DATA) + SRR->RR_PD == (cTBLXPROV)->PR_FILIAL + (cTBLXPROV)->PR_MAT + 'R' + Dtos(SRG->RG_DTGERAR) + aCodFol[249,1]
				nP_Adic += SRR->RR_VALOR
				If RetValSrv(SRR->RR_PD,SRA->RA_FILIAL,"RV_INSS") == "S"
					nBx_Inss += SRR->RR_VALOR
				EndIf
				If RetValSrv(SRR->RR_PD,SRA->RA_FILIAL,"RV_FGTS") == "S"
					nBx_Fgts += SRR->RR_VALOR
				EndIf
				If RetValSrv(SRR->RR_PD,SRA->RA_FILIAL,"RV_PIS") == "S"
					nBx_Pis += SRR->RR_VALOR
				EndIf
				SRR->( dbSkip() )
			EndDo
		EndIf

		If lDivAdi
			If DbSeek((cTBLXPROV)->PR_FILIAL + (cTBLXPROV)->PR_MAT + 'R' + Dtos(SRG->RG_DTGERAR) + aCodFol[1687,1])//
				While SRR->( !EoF() ) .And. SRR->RR_FILIAL + SRR->RR_MAT + SRR->RR_TIPO3 + dToS(SRR->RR_DATA) + SRR->RR_PD == (cTBLXPROV)->PR_FILIAL + (cTBLXPROV)->PR_MAT + 'R' + Dtos(SRG->RG_DTGERAR) + aCodFol[1687,1]
					nP_Adic += SRR->RR_VALOR
					If RetValSrv(SRR->RR_PD,SRA->RA_FILIAL,"RV_INSS") == "S"
						nBx_Inss += SRR->RR_VALOR
					EndIf
					If RetValSrv(SRR->RR_PD,SRA->RA_FILIAL,"RV_FGTS") == "S"
						nBx_Fgts += SRR->RR_VALOR
					EndIf
					If RetValSrv(SRR->RR_PD,SRA->RA_FILIAL,"RV_PIS") == "S"
						nBx_Pis += SRR->RR_VALOR
					EndIf
					SRR->( dbSkip() )
				EndDo
			EndIf

			If DbSeek((cTBLXPROV)->PR_FILIAL + (cTBLXPROV)->PR_MAT + 'R' + Dtos(SRG->RG_DTGERAR) + aCodFol[1699,1])//
				While SRR->( !EoF() ) .And. SRR->RR_FILIAL + SRR->RR_MAT + SRR->RR_TIPO3 + dToS(SRR->RR_DATA) + SRR->RR_PD == (cTBLXPROV)->PR_FILIAL + (cTBLXPROV)->PR_MAT + 'R' + Dtos(SRG->RG_DTGERAR) + aCodFol[1699,1]
					nP_Adic += SRR->RR_VALOR
					If RetValSrv(SRR->RR_PD,SRA->RA_FILIAL,"RV_INSS") == "S"
						nBx_Inss += SRR->RR_VALOR
					EndIf
					If RetValSrv(SRR->RR_PD,SRA->RA_FILIAL,"RV_FGTS") == "S"
						nBx_Fgts += SRR->RR_VALOR
					EndIf
					If RetValSrv(SRR->RR_PD,SRA->RA_FILIAL,"RV_PIS") == "S"
						nBx_Pis += SRR->RR_VALOR
					EndIf
					SRR->( dbSkip() )
				EndDo
			EndIf
		EndIf
		If lProvavp
			If DbSeek((cTBLXPROV)->PR_FILIAL + (cTBLXPROV)->PR_MAT + 'R' + Dtos(SRG->RG_DTGERAR) + aCodFol[252,1])//Media ferias proporcionais rescisao aviso indenizado
				While SRR->( !EoF() ) .And. SRR->RR_FILIAL + SRR->RR_MAT + SRR->RR_TIPO3 + dToS(SRR->RR_DATA) + SRR->RR_PD == (cTBLXPROV)->PR_FILIAL + (cTBLXPROV)->PR_MAT + 'R' + Dtos(SRG->RG_DTGERAR) + aCodFol[252,1]
					nP_Adic += SRR->RR_VALOR
					If RetValSrv(SRR->RR_PD,SRA->RA_FILIAL,"RV_INSS") == "S"
						nBx_Inss += SRR->RR_VALOR
					EndIf
					If RetValSrv(SRR->RR_PD,SRA->RA_FILIAL,"RV_FGTS") == "S"
						nBx_Fgts += SRR->RR_VALOR
					EndIf
					If RetValSrv(SRR->RR_PD,SRA->RA_FILIAL,"RV_PIS") == "S"
						nBx_Pis += SRR->RR_VALOR
					EndIf
					SRR->( dbSkip() )
				EndDo
			EndIf

			If lDivAdi
				If DbSeek((cTBLXPROV)->PR_FILIAL + (cTBLXPROV)->PR_MAT + 'R' + Dtos(SRG->RG_DTGERAR) + aCodFol[1688,1])
					While SRR->( !EoF() ) .And. SRR->RR_FILIAL + SRR->RR_MAT + SRR->RR_TIPO3 + dToS(SRR->RR_DATA) + SRR->RR_PD == (cTBLXPROV)->PR_FILIAL + (cTBLXPROV)->PR_MAT + 'R' + Dtos(SRG->RG_DTGERAR) + aCodFol[1688,1]
						nP_Adic += SRR->RR_VALOR
						If RetValSrv(SRR->RR_PD,SRA->RA_FILIAL,"RV_INSS") == "S"
							nBx_Inss += SRR->RR_VALOR
						EndIf
						If RetValSrv(SRR->RR_PD,SRA->RA_FILIAL,"RV_FGTS") == "S"
							nBx_Fgts += SRR->RR_VALOR
						EndIf
						If RetValSrv(SRR->RR_PD,SRA->RA_FILIAL,"RV_PIS") == "S"
							nBx_Pis += SRR->RR_VALOR
						EndIf
						SRR->( dbSkip() )
					EndDo
				EndIf

				If DbSeek((cTBLXPROV)->PR_FILIAL + (cTBLXPROV)->PR_MAT + 'R' + Dtos(SRG->RG_DTGERAR) + aCodFol[1700,1])
					While SRR->( !EoF() ) .And. SRR->RR_FILIAL + SRR->RR_MAT + SRR->RR_TIPO3 + dToS(SRR->RR_DATA) + SRR->RR_PD == (cTBLXPROV)->PR_FILIAL + (cTBLXPROV)->PR_MAT + 'R' + Dtos(SRG->RG_DTGERAR) + aCodFol[1700,1]
						nP_Adic += SRR->RR_VALOR
						If RetValSrv(SRR->RR_PD,SRA->RA_FILIAL,"RV_INSS") == "S"
							nBx_Inss += SRR->RR_VALOR
						EndIf
						If RetValSrv(SRR->RR_PD,SRA->RA_FILIAL,"RV_FGTS") == "S"
							nBx_Fgts += SRR->RR_VALOR
						EndIf
						If RetValSrv(SRR->RR_PD,SRA->RA_FILIAL,"RV_PIS") == "S"
							nBx_Pis += SRR->RR_VALOR
						EndIf
						SRR->( dbSkip() )
					EndDo
				EndIf
			EndIf
		EndIf
		nP_Adic += nValFeAv
	Else
		nP_DSaldo  := Max(If(!lMetadeFal, nDiasProp - If(!lTempoParc, nP_DFalFer, 0), nDiasProp / 2) - If (nDiasVenc > 0 , 0,If(nDFerAnt > 0 .And. cTpBxFer == "2",nDFerAnt,nDFerAntP)),0)
		nP_Valor   := Round(nSalDia * nP_DSaldo,2) + nValFerAviso

		//Verificao de Intermitente para Indeterminado
		If (  lContrInt .and. SRA->RA_TPCONTR <> '3'.and. fTemInterm(.T., dDtBasFer) ) 
			nIntFer := 0    //-- FÈrias
						
			//Busca verbas de 13o. pagas no ano como contrato intermitente
			fAbtFerInterm(@nIntFer )
			nP_Valor -= nIntFer
		EndIf

		nP_AdiFunc := fCalAdcFun("PFER", dDataRef, nSalario)
		nP_AdiFunc := nP_AdiFunc / 30 * ( nP_DSaldo + nDiasAvi)

		If ( nPos := aScan(aAdicProv, {|x| x[1] == "2"}) ) > 0 //Busca adicionais considerando perÌodo de fÈrias proporcionais quando mÈdias de fÈrias compıe base de ATS e/ou periculosidade
			nAdtDia 	:= (aAdicProv[nPos,2] / 30)			
		EndIf

		nP_Adic    := Round(((nInsDia+nPerdia+nAdtDia+nAdcConDia+nAdcTrfDia+nOutDia) * nP_DSaldo) + nValFeAv,2)

		If lHojorva
			If (!lDemitido .Or. lProvResc)// para jornada variavel a media deve ser feita neste momento
				If lLimpaMed
					dbSelectArea(cTBLXMED)
					Zap
					dRefMed		:= If(lProvResc .And. lDemitido,dDataDem1,dDataRef)
					nBkpDiasC	:= nDiasC
					GpexMed(dDtBasFer,,dRefMed,,dRefMed,nSalHora,nSalMin,aCodFol,.T.,(!lFechouMes),,,,,,,nSalhInc)
					nDiasC 		:= nBkpDiasC
					lLimpaMed 	:= .F.
				EndIf
			EndIf
		EndIf
		dbSelectArea(cTBLXMED)
		(cTBLXMED)->(dbGoTop())
		If dbSeek((cTBLXPROV)->PR_FILIAL + (cTBLXPROV)->PR_MAT + "2" + "999" + If(cMedDir == "S" , "9999" , "99MD" ))
			If nDiasProp > 0
					nP_Adic += Round(((cTBLXMED)->RP_VALATU/nDiasProp) * nP_DSaldo,2)
			Endif

			nDsrHrsAtiv := fDsrHrsAtiv("2",aCodFol) //Calculo do DSR / Horas Atividade de professores

			If nDsrHrsAtiv > 0
				fHistMed(dDataRef,,anomes(dDataRef),"01","PRV",{nSalInc,nSalDia,nSalHora,nPeric,nInsal,nAdcConf,nAdcTransf,nAdtServ,nSalario})
			ENDIF
				
			// CALCULA PERIC./INSALUB VERBA DE MEDIAS QUE TEM INCIDENCIA
			nMedPer := nMedIns := 0.00
			FMedPerIns(@nMedPer,@nMedIns,'2',nSalHora,nSalMin,aCodFol,,,,P_ADISMED)
			If nDiasProp > 0
				nP_Adic += (nMedPer+nMedIns+nDsrHrsAtiv) / nDiasProp * nP_DSaldo
			EndIf
		Endif
	EndIf

	// PONTO DE ENTRADA PARA ALTERAR VALORES DOS ADICIONAIS PROPORCIONAIS
	If lGp070PRO
		EXECBLOCK("GP070PRO",.F.,.F.)
	Endif

	// SO IRA CALCULAR 1/3 DE FERIAS SE N√O FOR ESTAGIARIO
	If !lEstagio
		nP_UmTer   := Round((nP_Valor+nP_Adic) * If (nPerc1T=0.00 .Or. nPerc1T=100.00, 1/3 ,nPerc1T / 100),2)
		If cPaisLoc == "BRA" .And. lProvResc .And. (cTBLXPROV)->PR_TIPMOVI == _Demitido
			If RetValSrv(aCodFol[625,1],SRA->RA_FILIAL,"RV_INSS") == "S"
				nBx_Inss   += Round((nBx_Inss) * If (nPerc1T=0.00 .Or. nPerc1T=100.00, 1/3 ,nPerc1T / 100),2)
			EndIf
			If RetValSrv(aCodFol[625,1],SRA->RA_FILIAL,"RV_FGTS") == "S"
				nBx_Fgts   += Round((nBx_Fgts) * If (nPerc1T=0.00 .Or. nPerc1T=100.00, 1/3 ,nPerc1T / 100),2)
			EndIf
			If RetValSrv(aCodFol[625,1],SRA->RA_FILIAL,"RV_PIS") == "S"
				nBx_Pis    += Round((nBx_Pis) * If (nPerc1T=0.00 .Or. nPerc1T=100.00, 1/3 ,nPerc1T / 100),2)
			EndIf
		EndIf
	Endif

	// PONTO DE ENTRADA PARA ALTERAR VALORES DE 1/3 PROPORCIONAIS
	If lGp070P13
		EXECBLOCK("GP070P13",.F.,.F.)
	Endif

	nP_TotFer  := nP_Valor + nP_Adic + nP_UmTer + nP_AdiFunc

	// SO IRA CALCULAR 1/3 DE FERIAS SE N√O FOR ESTAGIARIO
	If !lEstagio
		If cPaisLoc == "BRA" .And. lProvResc .And. (cTBLXPROV)->PR_TIPMOVI == _Demitido
			nP_Inss    := NoRound(nBx_Inss * (nPercEmp+nPercTer+nPercAcTrab))
			nP_Fgts    := NoRound(nBx_Fgts * nPercFgts)
			nP_Pis	   := NoRound(nBx_Pis * nPercPis)
		Else
			nP_Inss    := NoRound(nP_TotFer * (nPercEmp+nPercTer+nPercAcTrab))
			nP_Fgts    := NoRound(nP_TotFer * nPercFgts)
			nP_Pis	   := NoRound(nP_TotFer * nPercPis)
		EndIf
	Endif

	// PONTO DE ENTRADA PARA ALTERAR VALORES DE INSS E FGTS PROPORCIONAIS
	If lGp070PIF
		EXECBLOCK("GP070PIF",.F.,.F.)
	Endif

	aFerPropB[ _BxFer,_Prov  ] := 0
	aFerPropB[ _BxFer,_Adic  ] := 0
	aFerPropB[ _BxFer,_1Ter  ] := 0
	aFerPropB[ _BxFer,_INSS  ] := 0
	aFerPropB[ _BxFer,_FGTS  ] := 0
	aFerPropB[ _BxFer,_PIS   ] := 0
	If nDiasVenc == 0 .And. !lTemVenc .And. aFerVenc[_Atual, _Prov] == 0 .And. aFerVenc[_BxFer, _Prov] > 0
		aFerPropB[_BxFer] := aClone( aFerVenc[_BxFer] )
		If nDFerAntP > 0 .and. nDFerAntP < 30 .and. Len(aPerFerias) <= 1//FÈrias proporcionaos antecipadas
			aFerProp[_BxFer] := aClone( aFerVenc[_BxFer] )
			For k := 1 to Len(aFerVenc[_BxFer])
				aFerVenc[_BxFer,k] := 0
			Next k
		EndIf
	EndIf

	//se estou bem no periodo de troca de periodo de ferias e uso baixa quebrada jogar os adicionais para as ferias vencidas
	If nP_DSaldo == 0 .And. cTpBxFer =='2' .And. lAdicProp
		aFerVenc[_Atual,_Adic] += aFerProp[_Atual,_Adic]
	EndIf

	// GRAVA OS VALORES CALCULADOS NO ARRAY DE FERIAS PROPORCIONAIS
	aFerProp[_Atual,_Dias] := nP_DSaldo
	aFerProp[_Atual,_Prov] := nP_Valor
	aFerProp[_Atual,_Adic] := nP_Adic + nP_AdiFunc
	aFerProp[_Atual,_1Ter] := nP_UmTer
	aFerProp[_Atual,_INSS] := nP_Inss
	aFerProp[_Atual,_FGTS] := nP_Fgts
	aFerProp[_Atual,_PIS]  := nP_Pis

EndIf

Return
/*
‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±⁄ƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒø±±
±±≥Funcao    ≥fBxaFerPro≥ Autor ≥ Emerson Rosa de Souza	≥ Data ≥ 26.06.00 ≥±±
±±√ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒ¥±±
±±≥Descricao ≥ Busca a Baixa de Ferias                                    ≥±±
±±√ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¥±±
±±≥Sintaxe   ≥ fBxaFerProv(dDtBasFer,nDFerAnt,cArqBxaPr,cFilBxaPr,...)    ≥±±
±±√ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¥±±
±±≥Uso       ≥ Generico                                                   ≥±±
±±¿ƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒŸ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂ*/
Static Function fBxaFerProv(dDtBasFer, nDFerAnt, lFerAberto, lBx2Per, lFer2PerAq, cPerPag)

Local aArea			:= SRF->(GetArea())
Local aFerMes		:= {}
Local aPerPagUmT	:= {}
Local nValABoInss 	:= nValABoFGTS := nValAboPis := 0
Local ddTpg0      	:= CTOD("")
Local lAchou		:= .F.
Local lFerMes		:= .F.
Local lPrimeira		:= .T.
Local lTrocouPer	:= .F.
Local cDataBusca	:= MesAno(dDataRef)
Local cBkpBxFer 	:= cTpBxFer
Local cFerPagUmT 	:= ""
Local nCnt1			:= 0
Local cRotP			:= ""
Local aPerA			:= {}
Local aPerf			:= {}
Local nPosFerias	:= 0
Local nTransf		:= 0

DEFAULT lFerAberto  := .F.
DEFAULT lBx2Per     := .F.
DEFAULT lFer2PerAq  := .F.
DEFAULT lProvResc   := (GetMvRH("MV_PROVRES",,"N") == "S") 	//-- Indica se devera provisionar no mes da rescisao
DEFAULT lGp070BIF   := ExistBlock("GP070BIF")
DEFAULT lGp070FBX   := ExistBlock("GP070FBX")
DEFAULT cPerPag	    := ""
DEFAULT lTemPostUmT := SRH->( ColumnPos( "RH_POSTUMT" ) ) > 0

// VARIAVEIS UTILIZADAS NOS PONTOS DE ENTRADA
Private nBx_Valor  := nBx_Adic := nBx_UmTer := nBx_Inss := nBx_Fgts := nBx_Pis := 0
Private nBx_SalVa := 0
Private __nDiasFer := 0 // vaiaval com o Total de Dias de Ferias do Mes para ser utilizada no Ponto de Entrada GP070BIF

// VARIAVEIS PARA PROVISIONAR FERIAS QUEBRADAS(MES/MES SEGUINTE)
Private nBx_ValMs := nBx_AdiMs := nBx_UmTMs := nBx_InsMs := nBx_InsAbMs := nBx_FgtMs := nBx_FgtAbMs := nBx_PisMs := nBx_PisAbMs := 0
Private nBx_SalVMs := 0

// VERIFICA SE ESTA DE FERIAS NO MES DA PROVISAO
dbSelectArea("SRH")
If dbSeek((cTBLXPROV)->PR_FILIAL + (cTBLXPROV)->PR_MAT)
	While ! Eof() .And. (cTBLXPROV)->PR_FILIAL+(cTBLXPROV)->PR_MAT == SRH->RH_FILIAL+SRH->RH_MAT
		If MesAno(SRH->RH_DATAINI) == cDataBusca
			If cTpBxFer == "2" .And. lBx2Per
				If SRH->RH_DATABAS <> aPerFerias[Len(aPerFerias)][1]
					dbSkip()
					Loop
				Else
					nDFerAnt := SRH->RH_DFERIAS + SRH->RH_DABONPE
					aPerFerias[Len(aPerFerias)][14] := (f_Ultdia(SRH->RH_DATAINI) - Day(SRH->RH_DATAINI)) + 1
				EndIf
			EndIf
			//se so mes seguinte sÛ tiver abono e parametro como 2, forÁar baixar tudo no primeiro mes
			If cTpBxFer =='2' .And. (MesAno(SRH->RH_DATAINI) == MesAno((SRH->RH_DATAINI + SRH->RH_DFERIAS) -1  )) .And. SRH->RH_DABONPE > 0
				cTpBxFer := '1'
			EndIf

			If !lTrocouPer
				If SRH->RH_DFERIAS + SRH->RH_DABONPE + SRH->RH_DFALTAS >= aTabFer[3]
					If cTpBxFer <> "2"
						lTemVenc  := .T.
					EndIf
				EndIf
			EndIf

			lTrocouPer	:= (!lFer2PerAq .And. SRH->RH_DATABAS <> dDtBasFer) .Or. (lFer2PerAq .And. SRH->RH_DATABAS > dDtBasFer)
			lAchou 		:= .T.
			aAdd( aFerMes, { SRH->RH_DTRECIB } )
			If lTrocouPer
				If cTpBxFer <> "2" .OR. !(MesAno(SRH->RH_DATAINI) <> MesAno(SRH->RH_DATAFIM))
					nDFerAnt  := Max(nDFerAnt-aTabFer[3],0)
					lTemVenc  := .T.
				Else
					nDFerAnt  -= (f_Ultdia(SRH->RH_DATAINI) - Day(SRH->RH_DATAINI)) + 1
				EndIf
			EndIf
			__nDiasFer += SRH->RH_DABONPE + SRH->RH_DFERIAS
			lFerMes := (If(!lFerMes, Month(SRH->RH_DATAINI) == Month(dDataRef), .T.))
			// SE TIPO DE BAIXA MES E MES SEGUINTE, ATUALIZA VARIAVEL LACHOU PARA FORCAR A BUSCA DAS FERIAS NO SEGUNDO MES
		ElseIf (cTpBxFer == "2" .And. MesAno(SRH->RH_DATAFIM) == cDataBusca)
			If lPrimeira
				lAchou := .T.
				lPrimeira := .F.
			Endif
			lFerMes := (If(!lFerMes, Month(SRH->RH_DATAINI) == Month(dDataRef), .T.))
		Elseif MesAno(SRH->RH_DATAFIM) == cDataBusca
			dDtPg0 := SRH->RH_DTRECIB
		Endif
		dbSkip()
	Enddo
ElseIf Len(aTransf) > 0
	For nTransf:= 1 to Len (aTransf)
		If aTransf[nTransf,_TAtual,_TFil]+aTransf[nTransf,_TAtual,_TMat] <> (cTBLXPROV)->PR_FILIAL+(cTBLXPROV)->PR_MAT
			Loop
		EndIf
		If dbSeek ((aTransf[nTransf,_TDest,_TFil]+aTransf[nTransf,_TDest,_TMat]) )
			While ! Eof() .And. (aTransf[nTransf,_TDest,_TFil]+aTransf[nTransf,_TDest,_TMat]) == SRH->RH_FILIAL+SRH->RH_MAT
				If MesAno(SRH->RH_DATAINI) == cDataBusca
					If cTpBxFer == "2" .And. lBx2Per
						If SRH->RH_DATABAS <> aPerFerias[Len(aPerFerias)][1]
							dbSkip()
							Loop
						Else
							nDFerAnt := SRH->RH_DFERIAS + SRH->RH_DABONPE
							aPerFerias[Len(aPerFerias)][14] := (f_Ultdia(SRH->RH_DATAINI) - Day(SRH->RH_DATAINI)) + 1
						EndIf
					EndIf
					//se so mes seguinte sÛ tiver abono e parametro como 2, forÁar baixar tudo no primeiro mes
					If cTpBxFer =='2' .And. (MesAno(SRH->RH_DATAINI) == MesAno((SRH->RH_DATAINI + SRH->RH_DFERIAS) -1  )) .And. SRH->RH_DABONPE > 0
						cTpBxFer := '1'
					EndIf

					If !lTrocouPer
						If SRH->RH_DFERIAS + SRH->RH_DABONPE + SRH->RH_DFALTAS >= aTabFer[3]
							If cTpBxFer <> "2"
								lTemVenc  := .T.
							EndIf
						EndIf
					EndIf

					lTrocouPer	:= (!lFer2PerAq .And. SRH->RH_DATABAS <> dDtBasFer) .Or. (lFer2PerAq .And. SRH->RH_DATABAS > dDtBasFer)
					lAchou 		:= .T.
					aAdd( aFerMes, { SRH->RH_DTRECIB } )
					If lTrocouPer
						If cTpBxFer <> "2" .OR. !(MesAno(SRH->RH_DATAINI) <> MesAno(SRH->RH_DATAFIM))
							nDFerAnt  := Max(nDFerAnt-aTabFer[3],0)
							lTemVenc  := .T.
						Else
							nDFerAnt  -= (f_Ultdia(SRH->RH_DATAINI) - Day(SRH->RH_DATAINI)) + 1
						EndIf
					EndIf
					__nDiasFer += SRH->RH_DABONPE + SRH->RH_DFERIAS
					lFerMes := (If(!lFerMes, Month(SRH->RH_DATAINI) == Month(dDataRef), .T.))
					// SE TIPO DE BAIXA MES E MES SEGUINTE, ATUALIZA VARIAVEL LACHOU PARA FORCAR A BUSCA DAS FERIAS NO SEGUNDO MES
				ElseIf (cTpBxFer == "2" .And. MesAno(SRH->RH_DATAFIM) == cDataBusca)
					If lPrimeira
						lAchou := .T.
						lPrimeira := .F.
					Endif
					lFerMes := (If(!lFerMes, Month(SRH->RH_DATAINI) == Month(dDataRef), .T.))
				Elseif MesAno(SRH->RH_DATAFIM) == cDataBusca
					dDtPg0 := SRH->RH_DTRECIB
				Endif
				dbSkip()
			Enddo
		EndIf
	Next nTransf
Endif

If cTpBxFer == "2" .And. (cTBLXPROV)->PR_TIPMOVI == _Demitido
    cTpBxFer := "1"
EndIf

If lGp070FBX .And. !lAchou
	lAchou := Execblock("GP070FBX",.F.,.F.)
EndIf

If lTemPostUmT .And. SRA->RA_SEXO == "F"
    fPag14457( @aPerPagUmT )
    cFerPagUmT := ArrTokStr(aPerPagUmT)
EndIf

If lAchou .Or.;
	(cTBLXPROV)->PR_CATFUNC $ "E|G" .Or.;
	(lDemitido .And. lProvResc) .Or.;
	cAnoMes == cPerPag .Or.;
    cAnoMes $ cFerPagUmT
	
	If (cTBLXPROV)->PR_CATFUNC $ "P|A"
		cRotP := fGetCalcRot("9")
		aPerA := aPerAbAUT
		aPerF := aPerFeAUT
	Else
		cRotP := fGetCalcRot('1')
		aPerA := aPerAberto
		aPerF := aPerFechado
	EndIf
	// RETORNA AS VERBAS DO FUNCIONARIO A PARTIR DO SRC E SRD
	aVerbasFunc	:= RetornaVerbasFunc(	(cTBLXPROV)->PR_FILIAL	,; // Filial do funcionario corrente
										(cTBLXPROV)->PR_MAT	  	,; // Matricula do funcionario corrente
										NIL						,; //
										cRotP					,; // Roteiro para busca das verbas
										NIL			  			,; // Array com as verbas que dever„o ser listadas. Se NIL retorna todas as verbas.
										aPerA	  				,; // Array com os Periodos e Numero de pagamento abertos
										aPerF	 	 			)  // Array com os Periodos e Numero de pagamento fechados

	// BAIXA PELO VALOR PAGO NO MES ATUAL
	For nCnt1 := 1 To Len(aVerbasFunc)
		If (cTpBxFer == "2" .And. (Empty(dDtPg0) .Or. (!Empty(dDtPg0) .And. !Empty(aVerbasFunc[nCnt1,nPosSeq])))) .Or. (cTpBxFer == "1" .And. (aVerbasFunc[nCnt1,nPosTpo2] != "F" .Or. (cBkpBxFer == "2" .And. AnoMes(aVerbasFunc[nCnt1, nPosDtRef]) != cDataBusca) ) ) .Or. (lGp070FBX .And. aVerbasFunc[nCnt1,nPosPd] $ cCodUmTer .And. !(aVerbasFunc[nCnt1,nPosPd] $ aCodFol[077,1]+"*"+aCodFol[079,1]+"*"+aCodFol[090,1]+"*"+aCodFol[095,1]))
		    If cTpBxFer == "1" .And. (cTBLXPROV)->PR_TIPMOVI == _Demitido .And. aVerbasFunc[nCnt1, nPosTpo2] == "G" .And. AnoMes(aVerbasFunc[nCnt1, nPosDtRef]) != cDataBusca .And. aScan( aFerMes, { |x| x[1] == aVerbasFunc[nCnt1, nPosDtRef] } ) == 0
				Loop
			EndIf
			If cTpBxFer == "2" 
				If ( aVerbasFunc[nCnt1,nPosPd] $ aCodFol[073,1] + "/" + aCodFol[205,1] ) .OR. ( (cTBLXPROV)->PR_CATFUNC == "C" .and. aVerbasFunc[nCnt1,nPosPd] $ aCodFol[76,1] + "/" + aCodFol[344,1] )
					nDFerAnt -= aVerbasFunc[nCnt1,nPosHoras]
		    	EndIf
			EndIf
			If !lFechouMes .And. (cTBLXPROV)->PR_CATFUNC $ "E|G" .And. aVerbasFunc[nCnt1, nPosPd] == aCodFol[891, 1]
				nDFerAnt := Min( aTabFer[3], nDFerAnt+aVerbasFunc[nCnt1, nPosHoras] )
			EndIf
			If aVerbasFunc[nCnt1,nPosPd] $ cCodFer .Or. aVerbasFunc[nCnt1,nPosPd] $ cCodFerMs
				//Se for verba de abono, verifica se foi calculado no mÍs anterior e se existe verba de fÈrias do mÍs anterior, do contr·rio, a baixa j· foi feita.
				If !( cTpBxFer == "2" .and. aVerbasFunc[nCnt1,nPosPd] == aCodFol[074,1] .and. aVerbasFunc[nCnt1,nPosTpo2] == "F" .and. ( aScan(aVerbasFunc, {|x| x[nPosPd] == aCodFol[072,1] .and. x[nPosTpo2] == "F"}) ) == 0 )
					nBx_Valor += aVerbasFunc[nCnt1,nPosValor]     //-- Baixa de Valor Ferias
				EndIf
				If aVerbasFunc[nCnt1,nPosPd] $ cCodFerMs
					nBx_ValMs += aVerbasFunc[nCnt1,nPosValor] //-- Ferias do Proximo Mes
				EndIf
			Endif
			If aVerbasFunc[nCnt1,nPosPd] $ cCodAdFer .Or. aVerbasFunc[nCnt1,nPosPd] $ cCodAdicMs .Or. aVerbasFunc[nCnt1,nPosPd] $ cCodAdiAbo
				If !( cTpBxFer == "2" .and. aVerbasFunc[nCnt1,nPosPd] $ cCodAdFer .and. aVerbasFunc[nCnt1,nPosTpo2] == "F" .and. ( aScan(aVerbasFunc, {|x| ( x[nPosPd] == aCodFol[072,1] .or. ( (cTBLXPROV)->PR_CATFUNC == "C" .and. x[nPosPd] $ aCodFol[75,1] + "/" + aCodFol[343,1] ) ) .and. x[nPosTpo2] == "F"}) ) == 0 )
					nBx_Adic += aVerbasFunc[nCnt1,nPosValor]       //-- Baixa de Adicionais
				EndIf
				If aVerbasFunc[nCnt1,nPosPd] $ cCodAdicMs
					nBx_AdiMs += aVerbasFunc[nCnt1,nPosValor]  //-- Adicionais do Proximo Mes
				EndIf
			Endif
			If aVerbasFunc[nCnt1,nPosPd] $ cCodUmTer .Or. aVerbasFunc[nCnt1,nPosPd] $ cCodUmTerMs
				If !( cTpBxFer == "2" .and. aVerbasFunc[nCnt1,nPosPd] $ cCodUmTer .and. aVerbasFunc[nCnt1,nPosTpo2] == "F" .and. ( aScan(aVerbasFunc, {|x| ( x[nPosPd] == aCodFol[072,1] .or. ( (cTBLXPROV)->PR_CATFUNC == "C" .and. x[nPosPd] $ aCodFol[75,1] + "/" + aCodFol[343,1] ) ) .and. x[nPosTpo2] == "F"}) ) == 0 )
					nBx_UmTer += aVerbasFunc[nCnt1,nPosValor]       //-- Baixa de Um Terco (1/3)
				EndIf
				If aVerbasFunc[nCnt1,nPosPd] $ cCodUmTerMs
					nBx_UmTMs += aVerbasFunc[nCnt1,nPosValor]   //-- Um Terco do Proximo Mes
				EndIf
			Endif
			If (aVerbasFunc[nCnt1,nPosPd] $ cCodFer .Or. aVerbasFunc[nCnt1,nPosPd] $ cCodAdFer .Or. If(cPaisLoc <> "URU",aVerbasFunc[nCnt1,nPosPd] $ cCodUmTer,.F.) .Or.;
   	           aVerbasFunc[nCnt1,nPosPd] $ cCodFerMs .Or. aVerbasFunc[nCnt1,nPosPd] $ cCodAdicMs .Or. aVerbasFunc[nCnt1,nPosPd] $ cCodUmTerMs .Or. ;
   	           aVerbasFunc[nCnt1,nPosPd] $ cCodAbono  .Or. aVerbasFunc[nCnt1,nPosPd] $ cCodAboMs .Or. aVerbasFunc[nCnt1,nPosPd] $ cCodAdiAbo  ) .And. ;
				!(cTBLXPROV)->PR_CATFUNC $ "E|G"

				If aVerbasFunc[nCnt1,nPosPd] $ cCodAbono .Or. aVerbasFunc[nCnt1,nPosPd] $ cCodAboMs .OR. ;
				   aVerbasFunc[nCnt1,nPosPd] $ cCodAdiAbo .Or. RetValSrv(aVerbasFunc[nCnt1,nPosPd],(cTBLXPROV)->PR_FILIAL,"RV_INSSFER") == "1"
					nBx_Inss += aVerbasFunc[nCnt1,nPosValor]      // I.N.S.S.
				EndIf

				If aVerbasFunc[nCnt1,nPosPd] $ cCodAbono .Or. aVerbasFunc[nCnt1,nPosPd] $ cCodAboMs .OR. ;
				   aVerbasFunc[nCnt1,nPosPd] $ cCodAdiAbo .Or. aVerbasFunc[nCnt1,nPosPd] $ cCodFerMs .Or.;
				   aVerbasFunc[nCnt1,nPosPd] $ cCodAdicMs .Or. aVerbasFunc[nCnt1,nPosPd] $ cCodUmTerMs .Or.;
				   RetValSrv(aVerbasFunc[nCnt1,nPosPd],(cTBLXPROV)->PR_FILIAL,"RV_FGTS") == "S"
					nBx_Fgts += aVerbasFunc[nCnt1,nPosValor]      // F.G.T.S.
				EndIf
				nBx_Pis  += aVerbasFunc[nCnt1,nPosValor]      // P.I.S.
				If aVerbasFunc[nCnt1,nPosPd] $ cCodFerMs .Or. aVerbasFunc[nCnt1,nPosPd] $ cCodAdicMs .Or. aVerbasFunc[nCnt1,nPosPd] $ cCodUmTerMs
					If aVerbasFunc[nCnt1,nPosPd] $ cCodAboMs .OR. aVerbasFunc[nCnt1,nPosPd] $ cCodAdAMs .OR. RetValSrv(aVerbasFunc[nCnt1,nPosPd],(cTBLXPROV)->PR_FILIAL,"RV_INSSFER") == "1"
						nBx_InsMs += aVerbasFunc[nCnt1,nPosValor]      // I.N.S.S. do Proximo Mes
					EndIf
					nBx_FgtMs += aVerbasFunc[nCnt1,nPosValor]      // F.G.T.S. do Proximo Mes
					nBx_PisMs  += aVerbasFunc[nCnt1,nPosValor]      // P.I.S.   do Proximo Mes
				EndIf
			Endif
			If aVerbasFunc[nCnt1,nPosPd] $ cCodSalV .Or. aVerbasFunc[nCnt1,nPosPd] $ cCodSalVMs
				nBx_SalVa += aVerbasFunc[nCnt1,nPosValor]       //-- Baixa Media Salario Vacacional
				If aVerbasFunc[nCnt1,nPosPd] $ cCodSalVMs
					nBx_SalVMs += aVerbasFunc[nCnt1,nPosValor]   //-- Media Sal. Vacac.Prox.Mes
				EndIf
			Endif
			// ABONO PECUNIARIO
			If aVerbasFunc[nCnt1,nPosPd] $ cCodAbono  .Or. aVerbasFunc[nCnt1,nPosPd] $ cCodAboMs .Or. aVerbasFunc[nCnt1,nPosPd] $ cCodAdiAbo
				If RetValSrv(aVerbasFunc[nCnt1,nPosPd],(cTBLXPROV)->PR_FILIAL,"RV_INSS") <> "S"
					nValAboInss += aVerbasFunc[nCnt1,nPosValor]
					If aVerbasFunc[nCnt1,nPosPd] $ cCodAboMs .Or. aVerbasFunc[nCnt1,nPosPd] $ cCodAdAMs
					    If cTpBxFer != "2"
							nBx_InsMs -= aVerbasFunc[nCnt1,nPosValor] // I.N.S.S. do Proximo Mes
						Else
							nBx_InsAbMs += aVerbasFunc[nCnt1,nPosValor] // I.N.S.S. de Abono do Proximo Mes
						EndIf
					EndIf
				Endif
				If RetValSrv(aVerbasFunc[nCnt1,nPosPd],(cTBLXPROV)->PR_FILIAL,"RV_FGTS") <> "S"
					nValAboFgts += aVerbasFunc[nCnt1,nPosValor]
					If aVerbasFunc[nCnt1,nPosPd] $ cCodAboMs .Or. aVerbasFunc[nCnt1,nPosPd] $ cCodAdAMs
					    If cTpBxFer != "2"
							nBx_FgtMs -= aVerbasFunc[nCnt1,nPosValor] // F.G.T.S. do Proximo Mes
						Else
							nBx_FgtAbMs += aVerbasFunc[nCnt1,nPosValor] // F.G.T.S. de Abono do Proximo Mes
						Endif
					EndIf
				Endif
				If RetValSrv(aVerbasFunc[nCnt1,nPosPd],(cTBLXPROV)->PR_FILIAL,"RV_PIS") <> "S"
					nValAboPis += aVerbasFunc[nCnt1,nPosValor]
					If aVerbasFunc[nCnt1,nPosPd] $ cCodAboMs .Or. aVerbasFunc[nCnt1,nPosPd] $ cCodAdAMs
					    If cTpBxFer != "2"
							nBx_PisMs -= aVerbasFunc[nCnt1,nPosValor] // P.I.S. do Proximo Mes
						Else
							nBx_PisAbMs += aVerbasFunc[nCnt1,nPosValor] // P.I.S. de Abono do Proximo Mes
						Endif
					EndIf
				Endif
			Endif
			//Outras verbas que incorporam
			If aVerbasFunc[nCnt1,nPosTpo2] $ 'K*I' .AND. ( !(aVerbasFunc[nCnt1,nPosPd] $ cCodFer .Or. aVerbasFunc[nCnt1,nPosPd] $ cCodFerMs) .And.;
				!(aVerbasFunc[nCnt1,nPosPd] $ cCodAdFer .Or. aVerbasFunc[nCnt1,nPosPd] $ cCodAdicMs) .And.;
				!(aVerbasFunc[nCnt1,nPosPd] $ cCodUmTer .Or. aVerbasFunc[nCnt1,nPosPd] $ cCodUmTerMs) .And.;
				!(aVerbasFunc[nCnt1,nPosPd] $ cCodAbono  .Or. aVerbasFunc[nCnt1,nPosPd] $ cCodAboMs) .And.;
				!(aVerbasFunc[nCnt1,nPosPd] $ cCodAdiAbo) .And. ;
				!(aVerbasFunc[nCnt1,nPosPd] $ cCodSalV .Or. aVerbasFunc[nCnt1,nPosPd] $ cCodSalVMs) .And.;
				RetValSrv(aVerbasFunc[nCnt1,nPosPd],(cTBLXPROV)->PR_FILIAL,"RV_REFFER") == "S" .And. RetValSrv(aVerbasFunc[nCnt1,nPosPd],(cTBLXPROV)->PR_FILIAL,"RV_INCORP") == "S" )
				nBx_Adic += aVerbasFunc[nCnt1,nPosValor]       //-- Baixa de Adicionais
				If RetValSrv(aVerbasFunc[nCnt1,nPosPd],(cTBLXPROV)->PR_FILIAL,"RV_INSS") == "S"
					nBx_Inss += aVerbasFunc[nCnt1,nPosValor]      // I.N.S.S.
				EndIf
				If RetValSrv(aVerbasFunc[nCnt1,nPosPd],(cTBLXPROV)->PR_FILIAL,"RV_FGTS") == "S"
					nBx_Fgts += aVerbasFunc[nCnt1,nPosValor]      // F.G.T.S.
				EndIf
				If RetValSrv(aVerbasFunc[nCnt1,nPosPd],(cTBLXPROV)->PR_FILIAL,"RV_PIS") == "S"
					nBx_Pis  += aVerbasFunc[nCnt1,nPosValor]      // P.I.S.
				EndIf
			EndIf
		Endif
	Next nCnt1

	nBx_Inss := NoRound((nBx_Inss - nValAboInss) * (nPercEmp+nPercTer+nPercAcTrab))
	nBx_Fgts := NoRound((nBx_Fgts - nValAboFgts) * nPercFgts)
	nBx_Pis  := NoRound((nBx_Pis  - nValAboPis)  * nPercPis)
	lAdicProp := .F.
	// VERIFICA SE DEVE BAIXAR PELAS FERIAS DO MES E MES SEGUINTE
	If cTpBxFer == "2"
		// CALCULO DO INSS E FGTS DO PROXIMO MES
		nBx_InsMs := NoRound(nBx_InsMs * (nPercEmp+nPercTer+nPercAcTrab))
		nBx_FgtMs := NoRound(nBx_FgtMs * nPercFgts)
		nBx_PisMs := NoRound(nBx_PisMs * nPercPis)
		nBx_InsAbMs:= NoRound(nBx_InsAbMs * (nPercEmp+nPercTer+nPercAcTrab))
		nBx_FgtAbMs:= NoRound(nBx_FgtAbMs * nPercFgts)
		nBx_PisAbMs:= NoRound(nBx_PisAbMs * nPercPis)
		// SUBTRAI OS VALORES DO PROXIMO MES DO TOTAL DO MES
		If lFerMes
			nBx_Valor -= nBx_ValMs
			nBx_Adic  -= nBx_AdiMs
			nBx_UmTer -= nBx_UmTMs
			nBx_Inss  -= nBx_InsMs
			nBx_Inss  += nBx_InsAbMs
			nBx_Fgts  -= nBx_FgtMs
			nBx_Fgts  += nBx_FgtAbMs
			nBx_Pis   -= nBx_PisMs
			nBx_Pis   += nBx_PisAbMs
			nBx_SalVa -= nBx_SalVMs
			// GRAVA A DIFERENCA QUE SERA BAIXADA NO PROXIMO MES
			If !lBx2Per .And. (aFerVenc[_Anter,_Prov] > 0 .Or. (aFerVenc[_Anter,_Dias] == 0 .And. lTrocouPer))
				aFerVenc[_Atual,_Prov] := nBx_ValMs
				aFerVenc[_Atual,_Adic] := nBx_AdiMs
				aFerVenc[_Atual,_1Ter] := nBx_UmTMs
				aFerVenc[_Atual,_INSS] := nBx_InsMs
				aFerVenc[_Atual,_FGTS] := nBx_FgtMs
				aFerVenc[_Atual,_PIS]  := nBx_PisMs
			Else
				aFerProp[_Atual,_Prov] := nBx_ValMs
				aFerProp[_Atual,_Adic] := nBx_AdiMs
				aFerProp[_Atual,_1Ter] := nBx_UmTMs
				aFerProp[_Atual,_INSS] := nBx_InsMs
				aFerProp[_Atual,_FGTS] := nBx_FgtMs
				aFerProp[_Atual,_PIS]  := nBx_PisMs
				lAdicProp := .T.
			EndIf
		EndIf
	EndIf

	// PONTO DE ENTRADA PARA ALTERAR VALORES DE INSS E FGTS BAIXAS
	If lGp070BIF
		EXECBLOCK("GP070BIF",.F.,.F.)
	EndIf

	// GRAVA NO ARRAY OS VALORES DE BAIXA
	aFerVenc[_BxFer,_Prov] := nBx_Valor
	aFerVenc[_BxFer,_Adic] := nBx_Adic
	aFerVenc[_BxFer,_1Ter] := nBx_UmTer
	aFerVenc[_BxFer,_INSS] := nBx_Inss
	aFerVenc[_BxFer,_FGTS] := nBx_Fgts
	aFerVenc[_BxFer,_PIS]  := nBx_Pis
EndIf

If !lFechouMes .And. (cTBLXPROV)->PR_CATFUNC $ "E|G" .And. nDFerAnt > 0 .And. nDFerAnt == aTabFer[3]
	If ( nPosFerias := aScan( aPerFerias, { |x| x[1] == dDtBasFer } ) ) > 0
		aPerFerias[nPosFerias, 8] 	:= "3"
		dDtBasFer					:= fCalcFimAq(dDtBasFer) + 1
		nDFerAnt					:= 0
		nDiasVenc					:= 0
	EndIf
EndIf

RestArea(aArea)

Return (nBx_Valor+nBx_Adic+nBx_UmTer > 0)

/*
‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±⁄ƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒø±±
±±≥Funcao   ≥fProv13o  ≥ Autor ≥ Emerson Rosa de Souza	≥ Data ≥ 26.06.00 ≥±±
±±√ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒ¥±±
±±≥Descricao≥ Calcula provisao de 13 Salario                              ≥±±
±±√ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¥±±
±±≥Sintaxe  ≥ fProv13o(cAbatAci,cAbatDoe,nTipoMovMes,cAbatAdo)            ≥±±
±±√ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¥±±
±±≥Uso      ≥ Generico                                                    ≥±±
±±¿ƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒŸ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂ*/
Static Function fProv13o(cCong13, nTipoMovMes, n13Fer)
Local lPropAvos	  := .F.
Local lCongela13  := .F.
Local lCongMat    := .F.
Local nAvosDed    := nAvosAf := nV_DFal13o := 0
Local dDtI13	  := CTOD("")
Local cTiposAfa   := ""
Local cTipoPesq   := "PR13"
Local nB_FGTS	  := 0
Local nB_PIS 	  := 0
Local aAfast      := {}
Local nX		  := 0
Local nAvos_OQ
Local nAvos_B
Local nFaltas13	  := 0
Local nVal13Aviso := 0
Local nVal13Av	  := 0
Local nV_FerRes	  := 0
Local nMeses	  := 0
Local nAvosFunc	  := nAvosAnt
Local nDiasAv13   := 0 // Dias de 13 Sobre Aviso Indenizado
Local nDias13In	  := 0 // Dias de 13 Rescis„o.
Local nDiasMat	  := 0
Local nValMatEmp  := 0
Local nValMatTer  := 0
Local nValMatAcid := 0
Local nAdcMatEmp  := 0
Local nAdcMatTer  := 0
Local nAdcMatAcid := 0
Local nVal1447    := 0
Local nValAux     := 0
Local nInt13o	  := 0
Local cVerb131	  := ""
Local cMedDir	  := P_MEDDIREN//GetMvRH("MV_MEDDIRE")
Local cRot131	  := fGetCalcRot("5")
Local cRotFol     := fGetCalcRot("1")
Local cTpAfast	  := "O*Q*B"
Local lVbs13o	  := (Len(aCodFol) >= 1628)
Local lVbs13o2	  := (Len(aCodFol) >= 1639)
Local lVbs13o3	  := (Len(aCodFol) >= 1649)
Local cPdAvis	  := aCodFol[115,1]
Local cPdInd	  := aCodFol[114,1]
Local lDivAdi	  := ( Len(aCodFol) >= 1721 ) .And. !Empty(aCodFol[1680,1])
Local lContrInt	  := If(SRC->(ColumnPos( 'RC_CONVOC' )) > 0,.T.,.F.)
Local nBx1par	  := 0
Local nBkpDiasC	  := 0
Local nPos 		  := 0
Local nAdtAux 	  := 0
Local nPerAux	  := 0
Local lAFCong13   := .F.

// VARIAVEIS UTILIZADAS NOS PONTOS DE ENTRADA
Private nV_Valor   := nV_Adic := nV_AdiFunc := nV_1Par13 := nV_Inss := nV_Fgts := nV_Pis := nTotMes := 0
Private nV_CSocial := nV_Bse := 0
Private nV_ObraSoc := nV_Ley := nV_Jubil := nP_ObraSoc := nP_Ley  := nP_Jubil := 0
Private cProce     := ""

DEFAULT lProvavp   := If(Type("P_PROVAVP") == "U" .Or. P_PROVAVP == "S",.T.,.F.)
DEFAULT lProvResc  := (GetMvRH("MV_PROVRES",,"N") == "S") 	//-- Indica se devera provisionar no mes da rescisao
DEFAULT lGP090F13  := ExistBlock("GP090F13")
DEFAULT lGp090DEC  := ExistBlock("GP090DEC")
DEFAULT lGp090DIF  := ExistBlock("GP090DIF")

//Tratamento para P_MEDDIREN = "M" - Misto. Calcula como se fosse "S" para funcion·rio com menos de um ano de contrato por tempo determinado.
If cMedDir == "M"
	cMedDir := If(SRA->RA_TPCONTR == "2" .and. DateDiffYear( SRA->RA_DTFIMCT , SRA->RA_ADMISSA ) < 1, "S", "N")
EndIf

fChkAfaMat(@nDiasMat)

// Indicador de 13∫ Sal·rio, ser· usado na fMediaHora() do gpexcal3
If lHojorva
	cProce := "3"
	fSalHvar ()
Endif

cTiposAfa := ""
ndiasaf := 0
nAvosAf := 0
dDtI13  := CTOD("01/01/"+Str(Year(dDataRef),4), "DDMMYY")
dDtDem	:= (cTBLXPROV)->PR_DEMISSA
If lHojorva
	If (!lDemitido .Or. lProvResc)// para jornada variavel a media deve ser feita neste momento
		If lLimpaMed
			dbSelectArea(cTBLXMED)
			Zap
			dRefMed		:= If(lProvResc .And. lDemitido,dDataDem1,dDataRef)
			nBkpDiasC	:= nDiasC
			GpexMed(dDtBasFer,,dRefMed,,dRefMed,nSalHora,nSalMin,aCodFol,.T.,(!lFechouMes),,,,,,,nSalhInc)
			nDiasC 		:= nBkpDiasC
			lLimpaMed 	:= .F.
		EndIf
	EndIf
EndIf
dbSelectArea(cTBLXMED)
(cTBLXMED)->(dbGoTop())
If !Empty(dDtDem) .And. dbSeek((cTBLXPROV)->PR_FILIAL + (cTBLXPROV)->PR_MAT + "3" + "998" + Alltrim(Str(Year(dDtDem), 4)) + Alltrim(Strzero(Month(dDtDem), 2)))
	nFaltas13 := (cTBLXMED)->RP_HORAS
EndIf
fRetAfas(dDtI13,  If(lDemitido .And. lProvResc,dDtDem,dDataRef),cTipoPesq,@nAvosAf,@nDiasaf,,@aAfast,,,,,lDemitido .And. lProvResc,nFaltas13)
nAvosDed += nAvosAf
For nX := 1 to Len(aAfast)
	cCong13  := aAfast[nX,10]
	lAFCong13 := cCong13 == "1" .And. aAfast[nX,21] > aAfast[nX,22]
	If aAfast[nX,5] == "F" //Ferias
		nAvosDed -= aAfast[nX,14] //Avos de fÈrais n„o devem ser descontados.
	EndIf
	If (cTBLXPROV)->PR_SITFOLH == "A" .And. aAfast[nX, 10] == "1" .And. SubStr(aAfast[nX, 16], 1, 1) == "Q"
		cTpAfast  	:= "O*B"
		lCongMat	:= .T.
	EndIf
Next nX

// VERIFICA SE HOUVE AFASTAMENTO E SE DEVE CONGELAR
If ((cTBLXPROV)->PR_SITFOLH == "A" .And. cCong13  == "1") .And. lAFCong13
	lCongela13 := .T.
EndIf

// VERIFICA TIPO DE MOVIMENTACAO DO FUNCIONARIO
nTipoMovMes := If(lCongela13, If(nTipoMovMes==_Cong_Fer,_Cong_F13,_Cong_13s), nTipoMovMes)

If ( !lDemitido .Or. lProvResc )
	dbSelectArea(cTBLXMED)
	// BUSCA O ADICIONAL MEDIAS
	If dbSeek((cTBLXPROV)->PR_FILIAL + (cTBLXPROV)->PR_MAT + "3" + "999" + If(cMedDir == "S", "9999" , "99MD")) .And. !lDemitido
		nV_Adic := (cTBLXMED)->RP_VALATU + fDsrHrsAtiv("3",aCodFol)
		// CALCULA PERIC./INSAL VERBA DE MEDIAS QUE TEM INCIDENCIA
		nMedPer := nMedIns := 0.00
		FMedPerIns(@nMedPer,@nMedIns,'3',nSalHora,nSalMin,aCodFol,,,,P_ADISMED)
		nV_Adic += (nMedPer+nMedIns)
	Endif

	// BUSCA A 1o PARCELA ANTECIPADA
	If lDesc1Parc .Or. (lDemitido .And. lProvResc .And. Month(dDataRef) <> 12)
		// PESQUISA ADIANTAMENTO DA 1¶ PARCELA 13o SALARIO NO ACUMULADO
		If dbSeek((cTBLXPROV)->PR_FILIAL + (cTBLXPROV)->PR_MAT + "3" + "997" + "9598")
			nV_1Par13 := (cTBLXMED)->RP_VALATU
		Endif
		// PESQUISA ADIANTAMENTO DA 1¶ PARCELA 13o SALARIO NO MOVIMENTO
		If !lFechou13 .Or. ( !lFechouMes .And. n13Fer > 0 )

			// PESQUISA A DIFERENCA DO ADIANTAMENTO DA 1¶ PARCELA 13o SALARIO
			cVerb131 := aCodFol[022,1] + "*" + aCodFol[163,1] + "*" + aCodFol[1288,1] + "*" + aCodFol[1289,1] + "*" + aCodFol[1290,1] + "*" +;
			 			aCodFol[1291,1] + "*" + aCodFol[1292,1] + "*" + aCodFol[1293,1] + "*" + aCodFol[1294,1] + "*" +;
			 			aCodFol[1295,1] + "*" + aCodFol[1434,1] + "*" + aCodFol[1438,1] + "*" + aCodFol[1439,1] + "*" +;
						aCodFol[1440,1] + "*" + aCodFol[1441,1] + "*" + aCodFol[1442,1] + "*" + aCodFol[1443,1] + "*" +;
						aCodFol[1444,1] + "*" + aCodFol[1445,1] + "*" + If( lVbs13o, aCodFol[1630,1] + "*" + aCodFol[1631,1] + "*" +;
						aCodFol[1632,1] + "*" + aCodFol[1633,1] + "*" + aCodFol[1634,1] + "*" + aCodFol[1635,1] + "*" +;
						aCodFol[1636,1] + "*" + aCodFol[1637,1] + "*" + aCodFol[1628,1] + "*" + aCodFol[1629,1] + "*", "" ) +;
						If( lVbs13o2, aCodFol[1639,1] + "*" + aCodFol[1640,1] + "*" + aCodFol[1641,1] + "*" + aCodFol[1642,1] + "*" + ;
						aCodFol[1643,1] + "*" + aCodFol[1644,1] + "*" + aCodFol[1645,1] + "*" + aCodFol[1646,1] + "*" + ;
						aCodFol[1647,1] + "*" + aCodFol[1648,1] + "*", "" ) + If( lVbs13o3, aCodFol[1649,1] + "*" + aCodFol[1650,1] + "*" + ;
						aCodFol[1651,1] + "*" + aCodFol[1652,1] + "*" + aCodFol[1653,1] + "*" + aCodFol[1654,1] + "*", "" )

			dbSelectArea("SRC")
			If SRC->(dbSeek((cTBLXPROV)->PR_FILIAL + (cTBLXPROV)->PR_MAT))
				While SRC->( !EoF() ) .And. SRC->RC_FILIAL + SRC->RC_MAT == (cTBLXPROV)->PR_FILIAL + (cTBLXPROV)->PR_MAT
					If SRC->RC_PD $ cVerb131 .and. SRC->RC_PERIODO == AnoMes(ddataref) .And. (SRC->RC_ROTEIR == cRot131 .Or. SRC->RC_ROTEIR == cRotFol)
						nV_1Par13 += SRC->RC_VALOR
					EndIf
					SRC->( dbSkip() )
				EndDo
			EndIf

			dbSelectArea(cTBLXMED)
		Endif
		If lDemitido .And. lProvResc .And. Month(dDataRef) <> 12
			nBx1par := nV_1Par13
			nV_1Par13 := 0
		EndIf
	Endif
	// BUSCA AS FALTAS EM AVOS
	If dbSeek((cTBLXPROV)->PR_FILIAL + (cTBLXPROV)->PR_MAT + "3" + "998" + "9998")
		nV_DFal13o := (cTBLXMED)->RP_HORAS
	Endif
	// CALCULA OS AVOS DO FUNCIONARIO
	fAvos13(@nTotMes,If(lProvResc .And. lDemitido,dDataDem1,dDataRef),nV_DFal13o,nFaltas13,,dDataRef)

	If lDemitido .and. RetValSrv(aCodFol[115,1],(cTBLXPROV)->PR_FILIAL,"RV_REF13") == "S" .And. lProvavp
		DbSelectArea("SRR")
		DbSetOrder(1)
		If lDivAdi
			cPdAvis	+= "|" + aCodFol[1685,1] + "|" + aCodFol[1687,1] + "|" + aCodFol[1697,1] + "|" + aCodFol[1709,1] + "|" + aCodFol[1715,1] + "|" + aCodFol[1721,1]
		EndIf
		If DbSeek((cTBLXPROV)->PR_FILIAL + (cTBLXPROV)->PR_MAT + 'R' + Dtos(SRG->RG_DTGERAR) )
			While SRR->( !EoF() ) .And. SRR->RR_FILIAL + SRR->RR_MAT + SRR->RR_TIPO3 + dToS(SRR->RR_DATA) == (cTBLXPROV)->PR_FILIAL + (cTBLXPROV)->PR_MAT + 'R' + Dtos(SRG->RG_DTGERAR)
				If SRR->RR_PD $ cPdAvis
					nVal13Aviso += SRR->RR_VALOR
					If SRR->RR_PD ==  aCodFol[115,1]
						nDiasAv13 += SRR->RR_HORAS
					EndIf
				EndIf

				SRR->( dbSkip() )
			EndDo
		EndIf
		nDiasAv13 := Int(nDiasAv13) * aTabFer[4]
		nVal13Av := nVal13Aviso - Round(nSalDia * nDiasAv13, 2)
	EndIf
	// ABATER AVOS AFASTADOS NO ANO
	nTotMes := If (nTotMes - nAvosDed > 0 , nTotMes - nAvosDed , 0)

	If nTotMes == 0 .And. nV_Adic > 0
		nV_Adic := 0
	EndIf

	// CALCULO DO MES
	If lProvResc .And. ( (cTBLXPROV)->PR_TIPMOVI == _Demitido .or.  ((cTBLXPROV)->PR_TIPMOVI == _Trfe_Ent .and. lDemitido .and. AnoMes(SRA->RA_DEMISSA) == cAnoMes) )
		DbSelectArea("SRR")
		DbSetOrder(1)
		If lDivAdi
			cPdInd	+= "|" + aCodFol[1684,1] + "|" + aCodFol[1696,1] + "|" + aCodFol[1708,1] + "|" + aCodFol[1714,1] + "|" + aCodFol[1720,1] + "|" + aCodFol[1446,1]
	    EndIf

		If DbSeek((cTBLXPROV)->PR_FILIAL + (cTBLXPROV)->PR_MAT + 'R' + Dtos(SRG->RG_DTGERAR))//13o. na Indenizacao Rescisao
			While SRR->( !EoF() ) .And. SRR->RR_FILIAL + SRR->RR_MAT + SRR->RR_TIPO3 + dToS(SRR->RR_DATA)  == (cTBLXPROV)->PR_FILIAL + (cTBLXPROV)->PR_MAT + 'R' + Dtos(SRG->RG_DTGERAR)
				If SRR->RR_PD $ cPdInd
					nV_Valor  += SRR->RR_VALOR
					If SRR->RR_PD $ (aCodFol[114,1] + "|" + aCodFol[1446,1])
						nDias13In += SRR->RR_HORAS
					EndIf
				EndIf
				SRR->( dbSkip() )
			EndDo
			nDias13In := Int(nDias13In) * aTabFer[4]
			If nDias13In >  0
				nV_FerRes += nV_Valor - Round(nSalDia * nDias13In, 2 )
			EndIf
		EndIf

		nV_Adic += nV_FerRes
		nV_Valor += nVal13Aviso - nVal13Av - nV_FerRes

		If DbSeek((cTBLXPROV)->PR_FILIAL + (cTBLXPROV)->PR_MAT + 'R' + Dtos(SRG->RG_DTGERAR) + aCodFol[251,1])//Media 13o. Salario Rescisao
			While SRR->( !EoF() ) .And. SRR->RR_FILIAL + SRR->RR_MAT + SRR->RR_TIPO3 + dToS(SRR->RR_DATA) + SRR->RR_PD == (cTBLXPROV)->PR_FILIAL + (cTBLXPROV)->PR_MAT + 'R' + Dtos(SRG->RG_DTGERAR) + aCodFol[251,1]
				nV_Adic += SRR->RR_VALOR
				SRR->( dbSkip() )
			EndDo
		EndIf

		If DbSeek((cTBLXPROV)->PR_FILIAL + (cTBLXPROV)->PR_MAT + 'R' + Dtos(SRG->RG_DTGERAR) + aCodFol[1447,1])//13∫ na Indenizacao Rescisao Maternidade
			While SRR->( !EoF() ) .And. SRR->RR_FILIAL + SRR->RR_MAT + SRR->RR_TIPO3 + dToS(SRR->RR_DATA) + SRR->RR_PD == (cTBLXPROV)->PR_FILIAL + (cTBLXPROV)->PR_MAT + 'R' + Dtos(SRG->RG_DTGERAR) + aCodFol[1447,1]
				nV_Adic  += SRR->RR_VALOR
				nVal1447 += SRR->RR_VALOR
				SRR->( dbSkip() )
			EndDo
		EndIf

		If lDivAdi
			If DbSeek((cTBLXPROV)->PR_FILIAL + (cTBLXPROV)->PR_MAT + 'R' + Dtos(SRG->RG_DTGERAR) + aCodFol[1690,1])
				While SRR->( !EoF() ) .And. SRR->RR_FILIAL + SRR->RR_MAT + SRR->RR_TIPO3 + dToS(SRR->RR_DATA) + SRR->RR_PD == (cTBLXPROV)->PR_FILIAL + (cTBLXPROV)->PR_MAT + 'R' + Dtos(SRG->RG_DTGERAR) + aCodFol[1690,1]
					nV_Adic += SRR->RR_VALOR
					SRR->( dbSkip() )
				EndDo
			EndIf

			If DbSeek((cTBLXPROV)->PR_FILIAL + (cTBLXPROV)->PR_MAT + 'R' + Dtos(SRG->RG_DTGERAR) + aCodFol[1702,1])
				While SRR->( !EoF() ) .And. SRR->RR_FILIAL + SRR->RR_MAT + SRR->RR_TIPO3 + dToS(SRR->RR_DATA) + SRR->RR_PD == (cTBLXPROV)->PR_FILIAL + (cTBLXPROV)->PR_MAT + 'R' + Dtos(SRG->RG_DTGERAR) + aCodFol[1702,1]
					nV_Adic += SRR->RR_VALOR
					SRR->( dbSkip() )
				EndDo
			EndIf
		EndIf

		If lProvavp
			If DbSeek((cTBLXPROV)->PR_FILIAL + (cTBLXPROV)->PR_MAT + 'R' + Dtos(SRG->RG_DTGERAR) + aCodFol[253,1])//Media 13o. Salario Rescisao aviso indenizado
				While SRR->( !EoF() ) .And. SRR->RR_FILIAL + SRR->RR_MAT + SRR->RR_TIPO3 + dToS(SRR->RR_DATA) + SRR->RR_PD == (cTBLXPROV)->PR_FILIAL + (cTBLXPROV)->PR_MAT + 'R' + Dtos(SRG->RG_DTGERAR) + aCodFol[253,1]
					nV_Adic += SRR->RR_VALOR
					SRR->( dbSkip() )
				EndDo
			EndIf
			If lDivAdi
				If DbSeek((cTBLXPROV)->PR_FILIAL + (cTBLXPROV)->PR_MAT + 'R' + Dtos(SRG->RG_DTGERAR) + aCodFol[1691,1])
					While SRR->( !EoF() ) .And. SRR->RR_FILIAL + SRR->RR_MAT + SRR->RR_TIPO3 + dToS(SRR->RR_DATA) + SRR->RR_PD == (cTBLXPROV)->PR_FILIAL + (cTBLXPROV)->PR_MAT + 'R' + Dtos(SRG->RG_DTGERAR) + aCodFol[1691,1]
						nV_Adic += SRR->RR_VALOR
						SRR->( dbSkip() )
					EndDo
				EndIf
				If DbSeek((cTBLXPROV)->PR_FILIAL + (cTBLXPROV)->PR_MAT + 'R' + Dtos(SRG->RG_DTGERAR) + aCodFol[1703,1])
					While SRR->( !EoF() ) .And. SRR->RR_FILIAL + SRR->RR_MAT + SRR->RR_TIPO3 + dToS(SRR->RR_DATA) + SRR->RR_PD == (cTBLXPROV)->PR_FILIAL + (cTBLXPROV)->PR_MAT + 'R' + Dtos(SRG->RG_DTGERAR) + aCodFol[1703,1]
						nV_Adic += SRR->RR_VALOR
						SRR->( dbSkip() )
					EndDo
				EndIf
			EndIf
		EndIf
		nV_Adic += nVal13Av
	Else
		nV_Valor  := Round(((nSalMes * nTotMes) / 12) + nVal13Aviso , 2)
	EndIf

	//Verificao de Intermitente para Indeterminado
	If (  lContrInt .and. SRA->RA_TPCONTR <> '3'.and. fTemInterm() ) 
		nInt13o := 0    //-- Baixa Valor do 13o Salario
				
		//Busca verbas de 13o. pagas no ano como contrato intermitente
		fAbt13Interm(@nInt13o)
		nV_Valor -= nInt13o
	EndIf

	If nDiasMat > 0 .And. !lCongMat 
		nValMatEmp	:= 0
		nValMatTer	:= 0
		nValMatAcid	:= 0
		nAdcMatEmp  := 0
		nAdcMatTer  := 0
		nAdcMatAcid := 0		

		//Obtem os valores de maternidade para desconto da base dos encargos de INSS
		If P_ENCEMP == "1" 
			 //mÈdias referente aos meses de dias de maternidade do calculo dos encargos patronais
			fVal13Mat(@nValMatEmp, @nAdcMatEmp, nDiasMat, nTotMes, nV_Adic, (lProvResc .And. (cTBLXPROV)->PR_TIPMOVI == _Demitido), nVal1447)
		Else
			If aCodFol[148,1] $ P_ENCEMP //% Empresa
				fVal13Mat(@nValMatEmp, @nAdcMatEmp, nDiasMat, nTotMes, nV_Adic, (lProvResc .And. (cTBLXPROV)->PR_TIPMOVI == _Demitido), nVal1447)
			EndIf
			If aCodFol[149,1] $ P_ENCEMP //% Terceiros
				fVal13Mat(@nValMatTer, @nAdcMatTer, nDiasMat, nTotMes)
			EndIf
			If aCodFol[150,1] $ P_ENCEMP //% Acid. Trabalho
				fVal13Mat(@nValMatAcid, @nAdcMatAcid, nDiasMat, nTotMes)
			EndIf
		EndIf
	EndIf
	If !(lProvResc .And. (cTBLXPROV)->PR_TIPMOVI == _Demitido)
		
		nPerAux := nPeric
		nAdtAux := nAdtServ
		
		If ( nPos := aScan(aAdicProv, {|x| x[1] == "3"}) ) > 0 //Busca adicionais considerando perÌodo de 13∫ quando mÈdias de fÈrias compıe base de ATS e/ou periculosidade
			nAdtAux 	:= aAdicProv[nPos,2]
		EndIf

		nV_Adic   += Round((((nPerAux+nAdtAux+nInsal+nAdcConf+nAdcTransf+nOutros) * nTotMes) / 12) + nVal13Av, 2)

		nV_AdiFunc := fCalAdcFun("P132", dDataRef, nSalario)
		nV_AdiFunc := ( nV_AdiFunc / 12 * nTotMes ) + ( ( nV_AdiFunc / 12 / 30 ) * nDiasAv13 )
	EndIf

	// PONTO DE ENTRADA PARA ALTERRAR VALORES 13o. E  ADICIONAL
	If lGp090DEC
		EXECBLOCK("GP090DEC",.F.,.F.)
	Endif

	// BASE PARA CALCULO DO FGTS E PIS
	nB_FGTS := nV_Valor + nV_Adic + nV_AdiFunc
	nB_PIS  := nV_Valor + nV_Adic + nV_AdiFunc

	// CALCULA FGTS COM BASE TOTAL SE AFAST. POR AUXILIO MATERNIDADE
	nAvos_OQ := 0
	nAvos_B	 := 0

    Aeval(aAfast ,{ |X| nAvos_OQ += If(substr(X[16],1,1) $ cTpAfast, X[1], 0) })
    Aeval(aAfast ,{ |X| nAvos_B += If(substr(X[16],1,1) $ "B", X[1], 0) })

	If nAvos_OQ > 0 .And. nTotMes > 0
		nB_FGTS := NoRound(fRetDec(@nB_FGTS) / nTotMes * (nTotMes + nAvos_OQ), 2)
	ElseIf nAvos_OQ > 0
		nB_FGTS := Round(((nSalMes * nAvos_OQ) / 12) + nVal13Aviso , 2)
		nB_FGTS	+= Round((((nPeric+nAdtServ+nInsal+nAdcConf+nAdcTransf+nOutros) * nAvos_OQ) / 12) + nVal13Av, 2)
	EndIf

	nV_Tot13  := (nV_Valor + nV_Adic + nV_AdiFunc)
	nV_Tot13o := (nV_Valor + nV_Adic + nV_AdiFunc) - nV_1Par13

	//Quando for recolhimento da contribuicao patronal sobre a receita bruta e ter que efetuar a
	//proporcionalizacao dos avos adquiridos antes e apos o inicio da desoneracao
	If cPaisLoc == "BRA"
		lPropAvos := (cRecFatEmp $ "S*M*C" .And. lDesAtiv) .Or. ( (cRecFatEmp == "oM" .Or. cRecFatEmp == "oS") .And. lOneAtiv)
	EndIf

	//Verifica os funcionarios admitidos no ano
	If lPropAvos .And. Year((cTBLXPROV)->PR_ADMISSA) == Year(dDataRef) .And. Month((cTBLXPROV)->PR_ADMISSA) > 1
		nMeses	  := Month(dDataRef) - nAvosAnt //Quantidade de meses sem desoneracao a partir do calculo atual
		//Subtrai os meses desonerados dos avos do funcionario caso este seja superior, senao fica zerado
		If nTotMes > 1 .And. nTotMes > nMeses
			nAvosFunc := nTotMes - nMeses
		Else
			nAvosFunc := 0
		EndIf
	EndIf

	If nAvos_B > 0
		//QUANDO FOR RECOLHIMENTO DA CONTRIBUICAO PATRONAL SOBRE A RECEITA BRUTA E TER QUE EFETUAR A
		//PROPORCIONALIZACAO DOS AVOS ADQUIRIDOS ANTES E APOS O INICIO DA DESONERACAO
		If lPropAvos
			nInssAnt  := NoRound(((nV_Tot13 / nTotMes * (nTotMes + nAvos_OQ)) / nTotMes ) * nAvosFunc)
			If Empty(P_ENCEMP) .or. nDiasMat == 0
				nInssAnt  := NoRound(nInssAnt * (nPercAnt + nPercTer + nPercAcTrab))
			ElseIf P_ENCEMP == "1"
				nInssAnt  := NoRound( (nInssAnt - nValMatEmp - nAdcMatEmp ) * (nPercAnt + nPercTer + nPercAcTrab))
			Else
				nValAux := nInssAnt
				nInssAnt := NoRound( (nValAux - nValMatEmp - nAdcMatEmp ) * nPercAnt)
				nInssAnt += NoRound( (nValAux - nValMatTer - nAdcMatTer ) * nPercTer)
				nInssAnt += NoRound( (nValAux - nValMatAcid - nAdcMatAcid ) * nPercAcTrab)
			EndIf 
			nInssDes  := NoRound(((nV_Tot13 / nTotMes * (nTotMes + nAvos_OQ)) / nTotMes ) * (nTotMes - nAvosFunc))
			If Empty(P_ENCEMP) .or. nDiasMat == 0
				nInssDes  := NoRound(nInssDes * (nPerEmp13 + nPercTer + nPercAcTrab))
			ElseIf P_ENCEMP == "1"
				nInssDes  := NoRound( (nInssDes - nValMatEmp - nAdcMatEmp ) * (nPerEmp13 + nPercTer + nPercAcTrab))
			Else
				nValAux := nInssDes
				nInssDes := NoRound( (nValAux - nValMatEmp - nAdcMatEmp ) * nPerEmp13)
				nInssDes += NoRound( (nValAux - nValMatTer - nAdcMatTer ) * nPercTer)
				nInssDes += NoRound( (nValAux - nValMatAcid - nAdcMatAcid ) * nPercAcTrab)
			EndIf
			nV_Inss   := NoRound(nInssAnt + nInssDes)
			//CASO CONTRARIO, APENAS APLICA O PERCENTUAL NO VALOR TOTAL DO 13o
		Else
			If Empty(P_ENCEMP) .or. nDiasMat == 0
				nV_Inss   := NoRound((nV_Tot13 / nTotMes * (nTotMes + nAvos_OQ))* (nPerEmp13 + nPercTer + nPercAcTrab))
			ElseIf P_ENCEMP == "1"
				nV_Inss  := NoRound((nV_Tot13 / nTotMes * (nTotMes + nAvos_OQ) - nValMatEmp - nAdcMatEmp ) * (nPerEmp13 + nPercTer + nPercAcTrab))
			Else
				nValAux := (nV_Tot13 / nTotMes * (nTotMes + nAvos_OQ))
				nV_Inss := NoRound( (nValAux - nValMatEmp - nAdcMatEmp ) * nPerEmp13)
				nV_Inss += NoRound( (nValAux - nValMatTer - nAdcMatTer ) * nPercTer)
				nV_Inss += NoRound( (nValAux - nValMatAcid - nAdcMatAcid ) * nPercAcTrab)
			EndIf
		EndIf
	Else
		//QUANDO FOR RECOLHIMENTO DA CONTRIBUICAO PATRONAL SOBRE A RECEITA BRUTA E TER QUE EFETUAR A
		//PROPORCIONALIZACAO DOS AVOS ADQUIRIDOS ANTES E APOS O INICIO DA DESONERACAO
		If lPropAvos
			nInssAnt  := NoRound((nV_Tot13 / nTotMes) * nAvosFunc)
			If Empty(P_ENCEMP) .or. nDiasMat == 0
				nInssAnt  := NoRound(nInssAnt * (nPercAnt + nPercTer + nPercAcTrab))
			ElseIf P_ENCEMP == "1"
				nInssAnt  := NoRound( (nInssAnt - nValMatEmp - nAdcMatEmp ) * (nPercAnt + nPercTer + nPercAcTrab))
			Else
				nValAux := nInssAnt
				nInssAnt := NoRound( (nValAux - nValMatEmp - nAdcMatEmp ) * nPercAnt)
				nInssAnt += NoRound( (nValAux - nValMatTer - nAdcMatTer ) * nPercTer)
				nInssAnt += NoRound( (nValAux - nValMatAcid - nAdcMatAcid ) * nPercAcTrab)
			EndIf
			nInssDes  := NoRound((nV_Tot13 / nTotMes) * (nTotMes - nAvosFunc))
			If Empty(P_ENCEMP) .or. nDiasMat == 0
				nInssDes  := NoRound(nInssDes * (nPerEmp13 + nPercTer + nPercAcTrab))
			ElseIf P_ENCEMP == "1"
				nInssDes  := NoRound( (nInssDes - nValMatEmp - nAdcMatEmp ) * (nPerEmp13 + nPercTer + nPercAcTrab))
			Else
				nValAux := nInssDes
				nInssDes := NoRound( (nValAux - nValMatEmp - nAdcMatEmp ) * nPerEmp13)
				nInssDes += NoRound( (nValAux - nValMatTer - nAdcMatTer ) * nPercTer)
				nInssDes += NoRound( (nValAux - nValMatAcid - nAdcMatAcid ) * nPercAcTrab)
			EndIf
			nV_Inss   := NoRound(nInssAnt + nInssDes)
			//CASO CONTRARIO, APENAS APLICA O PERCENTUAL NO VALOR TOTAL DO 13o
		Else
			If Empty(P_ENCEMP) .or. nDiasMat == 0
				nV_Inss   := NoRound(nV_Tot13 * (nPerEmp13 + nPercTer + nPercAcTrab))
			ElseIf P_ENCEMP == "1"
				If  !( !Empty(P_DEDMAT) .And. Dtos(SR8->R8_DATAINI) <= (AnoMes(dDataRef)+'01') .And. SR8->R8_DATAFIM >= dDataRef )
 					nV_Inss  := NoRound( (nV_Tot13 - nValMatEmp - nAdcMatEmp ) * (nPerEmp13 + nPercTer + nPercAcTrab))
				ElseIf Month(dDataRef) > 1
					//MantÈm o valor provisionado anteriormente
					nV_Inss  := a13Salar[_Anter,_INSS]
				EndIf
			Else
				nValAux := nV_Tot13
				nV_Inss := NoRound( (nValAux - nValMatEmp - nAdcMatEmp ) * nPerEmp13)
				nV_Inss += NoRound( (nValAux - nValMatTer - nAdcMatTer ) * nPercTer)
				nV_Inss += NoRound( (nValAux - nValMatAcid - nAdcMatAcid ) * nPercAcTrab)
			EndIf
		EndIf
	EndIf

	// VERIFICA SE O CODIGO DE 1o PARCELA ESTA COM INCIDENCIA	FGTS
	If RetValSrv(aCodFol[022,1],(cTBLXPROV)->PR_FILIAL,"RV_FGTS") == "S"
		If lDemitido .And. lProvResc .And. Month(dDataRef) <> 12
			nV_Fgts := Max( NoRound(((nB_FGTS) - nBx1par) * nPercFgts), 0 )
		Else
			nV_Fgts := NoRound(((nB_FGTS) - nV_1Par13) * nPercFgts)
		EndIf
	Else
		nV_Fgts := NoRound((nB_FGTS) * nPercFgts)
	EndIf

	// VERIFICA SE O CODIGO DE 1o PARCELA ESTA COM INCIDENCIA DE PIS
	If RetValSrv(aCodFol[022,1],(cTBLXPROV)->PR_FILIAL,"RV_PIS") == "S"
		nV_Pis := NoRound(((nB_PIS) - nV_1Par13) * nPercPis)
	Else
		nV_Pis := NoRound((nB_PIS) * nPercPis)
	EndIf

	// PONTO DE ENTRADA PARA ALTERAR VALORES DE INSS E FGTS DO 13o
	If lGp090DIF
		EXECBLOCK("GP090DIF",.F.,.F.)
	EndIf

	// GRAVA O VALOR DA BAIXA DA 1A. PARCELA SE HOUVER BAIXA DA 2™
	If a13Salar[_Bx13O,_Prov] + a13Salar[_Bx13O,_Adic] > 0
		a13Salar[_Bx13O,_1Par] := nV_1Par13
	EndIf

	// GRAVA O VALOR DA BAIXA DA 1A. PARCELA DO 14∫ SAL¡RIO SE HOUVER BAIXA DA 2™ DO 14∫ SAL¡RIO
	If a14Salar[_Bx14O,_Prov] + a14Salar[_Bx14O,_Adic] > 0
		a14Salar[_Bx14O,_1Par] := nV_1Par13
	EndIf

	// SE HOUVER IDENTIFCADORES DE BXA DE 13o, FOR MES 12 E FUNCIONARIO NAO FOR DEMITIDO, ZERAR
	// OS VALORES "ATUAL" PARA QUE O AJUSTE "NO MES" SEJA FEITO PELA BAIXA
	If lBx13Pgt .And. Month(dDataRef) == 12 .and. !lDemitido
		a13Salar[_Atual,_Avos] := 0
  		a13Salar[_Atual,_Prov] := 0
  		a13Salar[_Atual,_Adic] := 0
  		a13Salar[_Atual,_1Par] := 0
  		a13Salar[_Atual,_INSS] := 0
  		a13Salar[_Atual,_FGTS] := 0
  		a13Salar[_Atual,_PIS]  := 0
	Else
		// GRAVA OS VALORES CALCULADOS NO ARRAY (SUBTRAINDO AS BAIXAS)
		a13Salar[_Atual,_Avos] := nTotMes   - a13Salar[_Bx13O,_Avos]
		a13Salar[_Atual,_Prov] := Max(nV_Valor  - a13Salar[_Bx13O,_Prov],0)
		a13Salar[_Atual,_Adic] := (nV_Adic + nV_AdiFunc) - a13Salar[_Bx13O,_Adic]
		a13Salar[_Atual,_1Par] := nV_1Par13 - a13Salar[_Bx13O,_1Par]
		a13Salar[_Atual,_INSS] := nV_Inss 	- a13Salar[_Bx13O,_INSS]
		a13Salar[_Atual,_FGTS] := nV_Fgts 	- a13Salar[_Bx13O,_FGTS]
		a13Salar[_Atual,_PIS]  := nV_Pis	- a13Salar[_Bx13O,_PIS]
	EndIf

	If lDemitido .And. lProvResc .And. Month(dDataRef) <> 12 .And. nBx1par > 0
		a13Salar[_Bx13O,_1Par] := nBx1par
	EndIf

	// Calcula o 14o. salario a partir dos valores de 13o
	If n14Salario > 0
		If  lBx14Pgt .And. Month(dDataRef) == 12 .and. !lDemitido
			a14Salar[_Atual,_Avos] := 0
			a14Salar[_Atual,_Prov] := 0
			a14Salar[_Atual,_Adic] := 0
			a14Salar[_Atual,_1Par] := 0
			a14Salar[_Atual,_INSS] := 0
			a14Salar[_Atual,_FGTS] := 0
		Else
			a14Salar[_Atual,_Avos] := 0
			a14Salar[_Atual,_Prov] := (a13Salar[_Atual,_Prov] * n14Salario)
			a14Salar[_Atual,_Adic] := (a13Salar[_Atual,_Adic] * n14Salario)
			a14Salar[_Atual,_1Par] := (a13Salar[_Atual,_1Par] * n14Salario)
			a14Salar[_Atual,_INSS] := (a13Salar[_Atual,_INSS] * n14Salario)
			a14Salar[_Atual,_FGTS] := (a13Salar[_Atual,_FGTS] * n14Salario)
			a14Salar[_Atual,_PIS]  := (a13Salar[_Atual,_PIS]  * n14Salario)
		EndIf
	EndIf
//⁄ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒø
//≥ Ponto de entrada para alterar os valores finais do 14 sal·rio.
//¿ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒŸ
	If lGP090F13
		ExecBlock("GP090F13",.F.,.F.)
	EndIf
EndIf

Return

/*
‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±⁄ƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒø±±
±±≥Funcao    ≥fBxa13oPro≥ Autor ≥ Emerson Rosa de Souza	≥ Data ≥ 26.06.00 ≥±±
±±√ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒ¥±±
±±≥Descricao ≥ Busca a Baixa de 13o Salario                               ≥±±
±±√ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¥±±
±±≥Sintaxe   ≥ fBxa13oProv(cArqBxa13,cFilBxa13,cMatBxa13cDatBxa13,...)    ≥±±
±±√ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¥±±
±±≥Uso       ≥ Generico                                                   ≥±±
±±¿ƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒŸ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂ*/
Static Function fBxa13oProv(nDiasMat)

Local nDif13     := 0
Local nInssAnt   := 0
Local nInssDes   := 0
Local nTotMes    := 0
Local nV_Inss    := 0
Local nCnt1
Local cRot13Aux  := fGetCalcRot('6')
Local lSomaAdic
Local lPropAvos	 := .F.
Local nMeses	 := 0
Local nAvosAnt	 := 0
Local nAvosFunc  := 0
Local nValMatEmp := 0
Local nValMatTer := 0
Local nValMatAcid:= 0
Local nAdcMatEmp := 0
Local nAdcMatTer := 0
Local nAdcMatAcid:= 0
Local nPosTrf    := 0
Local nValAux    := 0
Local aAux       := {}

// Variaveis utilizadas nos pontos de entrada				     ≥
Private nBxa13o := nBxaAdi := nBxaIns := nBxaFgt := nBxaPis := 0

DEFAULT lGP090B13	:= ExistBlock("GP090B13")
DEFAULT lGp090BIF 	:= ExistBlock("GP090BIF")
DEFAULT nDiasMat    := 0

// RETORNA AS VERBAS DO FUNCIONARIO A PARTIR DO SRC E SRD
aVerbasFunc	:= RetornaVerbasFunc(	(cTBLXPROV)->PR_FILIAL			,; // Filial do funcionario corrente
									(cTBLXPROV)->PR_MAT	  			,; // Matricula do funcionario corrente
									NIL								,; //
									""								,; // Roteiro para busca das verbas
									NIL			  					,; // Array com as verbas que dever„o ser listadas. Se NIL retorna todas as verbas.
									aPerAb13	  					,; // Array com os Periodos e Numero de pagamento abertos
									aPerFe13	 	 				) // Array com os Periodos e Numero de pagamento fechados

//Se array esta vazio ou n„o existem verbas de 13∫, verifica se possui transferÍncia e busca verbas na outra filial
If ( Empty( aVerbasFunc ) .or. ( aScan( aVerbasFunc, { |x| x[11] == cRot13Aux}) ) == 0 ) .And. ( nPosTrf := aScan( aTransf, { |x| x[_TAtual, _TEmp]+x[_TAtual, _TFil]+x[_TAtual, _TMat]+x[_TAtual, _TDta] == cEmpAnt+(cTBLXPROV)->PR_FILIAL+(cTBLXPROV)->PR_MAT+cAnoMes .And. x[_TAnter, _TFil] != x[_TAtual, _TFil] } ) ) > 0
	aAux	:= RetornaVerbasFunc( aTransf[nPosTrf, _TAnter, _TFil], aTransf[nPosTrf, _TAnter, _TMat], Nil, "", Nil, aPerAb13, aPerFe13 )
	If !Empty(aAux)
		If Empty(aVerbasFunc)
			aVerbasFunc := aClone(aAux) 
		Else 
			aEval(aAux,{|x| aAdd(aVerbasFunc,x) } )
		EndIf
	EndIf
EndIf

If !lFechouMes
	// Adicionar a verba de Dif. de 13∫ no aVerbasFunc
	If (cTBLXPROV)->PR_CATFUNC $ "P|A"
		aAux := RetornaVerbasFunc( (cTBLXPROV)->PR_FILIAL, (cTBLXPROV)->PR_MAT , Nil, "", Nil, aPerAbAUT, aPerFeAUT)
	Else
		aAux := RetornaVerbasFunc( (cTBLXPROV)->PR_FILIAL, (cTBLXPROV)->PR_MAT , Nil, "", Nil, aPerAberto, aPerFechado)
	EndIf

	For nCnt1 := 1 To Len(aAux)
		If aAux[nCnt1,nPosPd] == aCodFol[028,1] .And. aScan( aVerbasFunc, { |x| x[nPosPd]+x[nPosPeriodo]+x[nPosSemana]+x[nPosRoteiro] == aAux[nCnt1, nPosPd]+aAux[nCnt1, nPosPeriodo]+aAux[nCnt1, nPosSemana]+aAux[nCnt1, nPosRoteiro] } ) == 0//Dif 13o. Sal
			Aadd(aVerbasFunc, aAux[nCnt1])
		EndIf
	Next nCnt1
EndIf

For nCnt1 := 1 To Len(aVerbasFunc)
	// VERIFICA SE DEVE CONSIDERAR DIFERENCA DE 13o SAL. NEGATIVA
	If aVerbasFunc[nCnt1,nPosPd] == aCodFol[028,1] .And. aVerbasFunc[nCnt1,nPosValor] < 0 .And. !lDif13Neg
		Loop
	EndIf
	If aVerbasFunc[nCnt1,nPosPd] $ cCod13o .and. aVerbasFunc[nCnt1,nPosRoteiro] == cRot13Aux
		nBxa13o += aVerbasFunc[nCnt1,nPosValor]  //-- Baixa Valor do 13o Salario
	EndIf
	If aVerbasFunc[nCnt1,nPosPd] == aCodFol[024,1] .and. aVerbasFunc[nCnt1,nPosRoteiro] == cRot13Aux//Parcela Final 13o. Sal
		nTotMes := aVerbasFunc[nCnt1,nPosHoras]
	EndIf
	If aVerbasFunc[nCnt1,nPosPd] == aCodFol[028,1]//Dif 13o. Sal
		nDif13 += aVerbasFunc[nCnt1,nPosValor]
	EndIf
	// SE A VERBA ATUAL NAO ESTIVER CONTIDA NOS CODIGOS DE ADICIONAIS VERIFICA SE E UM PROVENTO E SE
	//INCIDE MEDIA P/ QUE SEJA SOMADA NA COLUNA DE ADICIONAIS E UTILIZADA PARA EFETUAR A BAIXA
	lSomaAdic := .F.
	If !(aVerbasFunc[nCnt1,nPosPd] $ cCodAd13o) .and. aVerbasFunc[nCnt1,nPosRoteiro] == cRot13Aux
	    PosSrv(aVerbasFunc[nCnt1,nPosPd], (cTBLXPROV)->PR_FILIAL)
	    If SRV->RV_TIPOCOD == "1" .And. !Empty(SRV->RV_MED13) .And. SRV->RV_MED13 # "N "
			lSomaAdic := .T.
	    EndIf
	EndIf
	If ( aVerbasFunc[nCnt1,nPosPd] $ cCodAd13o .And. aVerbasFunc[nCnt1,nPosRoteiro] == cRot13Aux ) .Or. lSomaAdic
		nBxaAdi += aVerbasFunc[nCnt1,nPosValor]  //-- Baixa de Adicionais
	EndIf
	If ( (aVerbasFunc[nCnt1,nPosPd] $ cCod13o .Or. aVerbasFunc[nCnt1,nPosPd] $ cCodAd13o) .And. aVerbasFunc[nCnt1,nPosRoteiro] == cRot13Aux ) .Or. lSomaAdic
		If RetValSrv(aVerbasFunc[nCnt1,nPosPd],(cTBLXPROV)->PR_FILIAL,"RV_INSS") == "S"
			nBxaIns += aVerbasFunc[nCnt1,nPosValor]  //-- I.N.S.S.
		EndIf
		If RetValSrv(aVerbasFunc[nCnt1,nPosPd],(cTBLXPROV)->PR_FILIAL,"RV_FGTS") == "S"
			nBxaFgt += aVerbasFunc[nCnt1,nPosValor]  //-- F.G.T.S.
		EndIf
		If RetValSrv(aVerbasFunc[nCnt1,nPosPd],(cTBLXPROV)->PR_FILIAL,"RV_PIS") == "S"
			nBxaPis += aVerbasFunc[nCnt1,nPosValor]  //-- P.I.S.
		EndIf
	EndIf
	If aVerbasFunc[nCnt1,nPosPd] == aCodFol[183,1]
		nBxaFgt -= If(lDesc1Parc,aVerbasFunc[nCnt1,nPosValor],0.00)  //-- Subtrai 1a parcela
	EndIf

	If aVerbasFunc[nCnt1,nPosPd] == aCodFol[1730,1]
		nBxaFgt += aVerbasFunc[nCnt1,nPosValor]  //-- fgtrs acidente trabalho
	EndIf
	// BUSCA A DIFERENCA DE 13o NO MOVIMENTO MENSAL - SRC
	If aVerbasFunc[nCnt1,nPosPd] == aCodFol[028,1] .Or.;
	   aVerbasFunc[nCnt1,nPosPd] == aCodFol[348,1]
	   If aVerbasFunc[nCnt1,nPosValor] > 0 .Or. lDif13Neg
			nBxa13o += aVerbasFunc[nCnt1,nPosValor]    //-- Baixa Valor do 13o Salario
			nBxaIns += aVerbasFunc[nCnt1,nPosValor]    //-- I.N.S.S.
			nBxaFgt += aVerbasFunc[nCnt1,nPosValor]    //-- F.G.T.S.
			nBxaPis += aVerbasFunc[nCnt1,nPosValor]    //-- P.I.S.
		EndIf
	EndIf
	//Outras verbas que incorporam. Somente efetua baixa para verbas que constam no roteiro 132.
	If aVerbasFunc[nCnt1,nPosRoteiro] == cRot13Aux
		If aVerbasFunc[nCnt1,nPosTpo2] $ 'S*C*I' .and. (!(aVerbasFunc[nCnt1,nPosPd] $ cCod13o .Or. aVerbasFunc[nCnt1,nPosPd] == aCodFol[024,1]) .And.;
			!(aVerbasFunc[nCnt1,nPosPd] == aCodFol[028,1] .Or. aVerbasFunc[nCnt1,nPosPd] $ cCodAd13o) .And.;
			RetValSrv(aVerbasFunc[nCnt1,nPosPd],(cTBLXPROV)->PR_FILIAL,"RV_INCORP") == "S")
			nBxaAdi += aVerbasFunc[nCnt1,nPosValor]       //-- Baixa de Adicionais
			//Se a verba incorpora sal·rio, automaticamente deve ser considerada para a baixa de impostos.
			nBxaIns += aVerbasFunc[nCnt1,nPosValor]      // I.N.S.S.
			nBxaFgt += aVerbasFunc[nCnt1,nPosValor]      // F.G.T.S.
			nBxaPis  += aVerbasFunc[nCnt1,nPosValor]      // P.I.S.
		EndIf
	EndIf

Next nCnt1

// PONTO DE ENTRADA PARA ALTERAR VALORES DE INSS E FGTS BAIXAS
If lGp090BIF
	EXECBLOCK("GP090BIF",.F.,.F.)
EndIf

// GRAVA NO ARRAY OS VALORES DE BAIXA
a13Salar[_Bx13O,_Prov] := nBxa13o
a13Salar[_Bx13O,_Adic] := nBxaAdi
If n14Salario > 0
	a14Salar[_Bx14O,_Prov] := nBxa13o * n14Salario
	a14Salar[_Bx14O,_Adic] := nBxaAdi * n14Salario
EndIf

If nDiasMat == 0
	a13Salar[_Bx13O,_1Par] := 0.00 //-- Busca o valor da 1a.parcela atraves do GPEXMED
EndIf
If cPaisLoc == "BRA"
	lPropAvos := ( (cRecFatEmp $ "S*M*C" .And. lDesAtiv) .Or. ((cRecFatEmp == "oM" .Or. cRecFatEmp == "oS") .And. lOneAtiv) )
EndIf

//Verifica os funcionarios admitidos no ano
If lPropAvos .And. Year((cTBLXPROV)->PR_ADMISSA) == Year(dDataRef) .And. Month((cTBLXPROV)->PR_ADMISSA) > 1
	nMeses := Month(dDataRef) - nAvosAnt //Quantidade de meses sem desoneracao a partir do calculo atual
	//Subtrai os meses desonerados dos avos do funcionario caso este seja superior, senao fica zerado
	If nTotMes > 1 .And. nTotMes > nMeses
		nAvosFunc := nTotMes - nMeses
	Else
		nAvosFunc := 0
	EndIf
EndIf

If nDiasMat > 0
	nValMatEmp	:= 0
	nValMatTer	:= 0
	nValMatAcid	:= 0
	nAdcMatEmp  := 0
	nAdcMatTer  := 0
	nAdcMatAcid := 0		

	//Obtem os valores de maternidade para desconto da base dos encargos de INSS
	If P_ENCEMP == "1"
		fVal13Mat(@nValMatEmp, @nAdcMatEmp, nDiasMat, nTotMes)
	Else
		If aCodFol[148,1] $ P_ENCEMP //% Empresa
			fVal13Mat(@nValMatEmp, @nAdcMatEmp, nDiasMat, nTotMes)
		EndIf
		If aCodFol[149,1] $ P_ENCEMP //% Terceiros
			fVal13Mat(@nValMatTer, @nAdcMatTer, nDiasMat, nTotMes)
		EndIf
		If aCodFol[150,1] $ P_ENCEMP //% Acid. Trabalho
			fVal13Mat(@nValMatAcid, @nAdcMatAcid, nDiasMat, nTotMes)
		EndIf
	EndIf
EndIf

If lPropAvos
	nInssAnt  := NoRound( ( ( nBxaIns - nDif13 ) / nTotMes ) * nAvosFunc )
	If Empty(P_ENCEMP) .or. nDiasMat == 0
		nInssAnt  := NoRound( nInssAnt * ( nPercAnt + nPercTer + nPercAcTrab ) )
	ElseIf P_ENCEMP == "1"
		nInssAnt  := NoRound( (nInssAnt - nValMatEmp - nAdcMatEmp ) * (nPercAnt + nPercTer + nPercAcTrab))
	Else
		nValAux := nInssAnt
		nInssAnt := NoRound( (nValAux - nValMatEmp - nAdcMatEmp ) * nPercAnt)
		nInssAnt += NoRound( (nValAux - nValMatTer - nAdcMatTer ) * nPercTer)
		nInssAnt += NoRound( (nValAux - nValMatAcid - nAdcMatAcid ) * nPercAcTrab)
	EndIf 
	nInssDes  := NoRound( ( ( nBxaIns - nDif13 ) / nTotMes ) * ( nTotMes - nAvosFunc ) )
	If Empty(P_ENCEMP) .or. nDiasMat == 0
		nInssDes  := NoRound( ( nInssDes + nDif13 ) * ( nPerEmp13 + nPercTer + nPercAcTrab ) )
	ElseIf P_ENCEMP == "1"
		nInssDes  := NoRound( (nInssDes + nDif13 - nValMatEmp - nAdcMatEmp ) * (nPerEmp13 + nPercTer + nPercAcTrab))
	Else
		nValAux := nInssDes + nDif13
		nInssDes := NoRound( (nValAux - nValMatEmp - nAdcMatEmp ) * nPerEmp13)
		nInssDes += NoRound( (nValAux - nValMatTer - nAdcMatTer ) * nPercTer)
		nInssDes += NoRound( (nValAux - nValMatAcid - nAdcMatAcid ) * nPercAcTrab)
	EndIf
	nV_Inss   := NoRound( nInssAnt + nInssDes )
	a13Salar[_Bx13o,_INSS] := nV_Inss
	a14Salar[_Bx14o,_INSS] := nV_Inss
Else
	If Empty(P_ENCEMP) .or. nDiasMat == 0
		a13Salar[_Bx13O,_INSS] := NoRound(nBxaIns * (iif(cRecFatEmp = "M", nPerEmp13, nPercEmp)+nPercTer+nPercAcTrab))
		If n14Salario > 0
			a14Salar[_Bx14O,_INSS] := NoRound(nBxaIns * (nPercEmp+nPercTer+nPercAcTrab) * n14Salario)
		EndIf
	ElseIf P_ENCEMP == "1"
		a13Salar[_Bx13O,_INSS]  := NoRound((nBxaIns - nValMatEmp - nAdcMatEmp ) * (nPercEmp + nPercTer + nPercAcTrab))
		If n14Salario > 0
			a14Salar[_Bx14O,_INSS] := NoRound((nBxaIns - nValMatEmp - nAdcMatEmp ) * (nPercEmp+nPercTer+nPercAcTrab) * n14Salario)
		EndIf
	Else
		nValAux := nBxaIns
		a13Salar[_Bx13O,_INSS] := NoRound( (nValAux - nValMatEmp - nAdcMatEmp ) * nPercEmp)
		a13Salar[_Bx13O,_INSS] += NoRound( (nValAux - nValMatTer - nAdcMatTer ) * nPercTer)
		a13Salar[_Bx13O,_INSS] += NoRound( (nValAux - nValMatAcid - nAdcMatAcid ) * nPercAcTrab)
		If n14Salario > 0
			a14Salar[_Bx14O,_INSS] := NoRound( (nValAux - nValMatEmp - nAdcMatEmp ) * nPercEmp * n14Salario)
			a14Salar[_Bx14O,_INSS] += NoRound( (nValAux - nValMatTer - nAdcMatTer ) * nPercTer * n14Salario)
			a14Salar[_Bx14O,_INSS] += NoRound( (nValAux - nValMatAcid - nAdcMatAcid ) * nPercAcTrab * n14Salario)
		EndIf
	EndIf
EndIf

a13Salar[_Bx13O,_FGTS] := NoRound(nBxaFgt * nPercFgts)
a13Salar[_Bx13O,_PIS]  := NoRound(nBxaPis * nPercPis)
If n14Salario > 0
	a14Salar[_Bx14O,_FGTS] := NoRound(nBxaFgt * nPercFgts * n14Salario)
	a14Salar[_Bx14O,_PIS]  := NoRound(nBxaPis * nPercPis * n14Salario)
EndIf

//Ponto de entrada para alterar os valores finais da baixa de 13o e 14o sal·rios.
If lGP090B13
	ExecBLock("GP090B13",.F.,.F.)
EndIf

Return (nBxa13o + nBxaAdi + nBxaIns + nBxaFgt + nBxaPis > 0)

/*
‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±⁄ƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒø±±
±±≥Funcao    ≥ GPM070Ok ≥ Autor ≥ Emerson R. de Souza	≥ Data ≥ 26.06.00 ≥±±
±±√ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒ¥±±
±±≥Descricao ≥ Grava os valores da provisao no arquivo SRT                ≥±±
±±√ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¥±±
±±≥Sintaxe   ≥ GPM070Ok()                                                 ≥±±
±±√ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¥±±
±±≥Uso       ≥ Generico                                                   ≥±±
±±¿ƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒŸ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±± */
Static Function GPM070Ok()
Return (MsgYesNo(OemToAnsi(STR0013),OemToAnsi(STR0012))) //"Confirma configuraáÑo dos parÉmetros?"###"ATENCAO"

/*
‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±⁄ƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒø±±
±±≥Funcao    ≥fEncargEmp≥ Autor ≥ Emerson R. de Souza	≥ Data ≥ 26.06.00 ≥±±
±±√ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒ¥±±
±±≥Descricao ≥ Carrega variaveis para calculo dos encargos                ≥±±
±±√ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¥±±
±±≥Sintaxe   ≥ fEncargEmp(nPercEmp, nPercTer, nPercAcTrab, nPercFgts)     ≥±±
±±√ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¥±±
±±≥Parametros≥ nPercEmp      - Percentual da Empresa                      ≥±±
±±≥          ≥ nPerTerc      - Percentual de Terceiros                    ≥±±
±±≥          ≥ nPercAcTrab   - Percentual de Acidente de Trabalho         ≥±±
±±≥          ≥ nPercFgts     - Percentual para o FGTS funcionario  8%     ≥±±
±±≥          ≥ nPercFgC      - Percentual para o FGTS contribuicao 0.5%   ≥±±
±±≥          ≥ cRecFatEmp    - Recolhe contribuicao sobre faturamento     ≥±±
±±≥          ≥ nPerEmp13     - Percentual da Empresa p/ 13o. Salario      ≥±±
±±√ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¥±±
±±≥ Uso	 	 ≥ Generico 												  ≥±±
±±¿ƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒŸ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±± */
Static Function fEncargEmp(nPercEmp, nPercTer, nPercAcTrab, nPercFgts, nPercFgC, cRecFatEmp, nPerEmp13, lCttPerEmp)
//SE PAIS BRASIL, VERIFICA SE CALCULA INSS PARA O FUNCION¡RIO
If lINSSAut .And. (cTBLXPROV)->PR_INSSAUT == "N"
	nPercEmp 	:= 0.00
	nPerEmp13 	:= 0.00
	nPercTer    := 0.00
	nPercAcTrab := 0.00
Else
	// VERIFICAR TIPO DE CONTRATO PARA CALCULO DE ENCARGOS
	cRecFatEmp	:= If ((cTBLXPROV)->PR_TPCONTR$ " *1", aInssEmp[27, 1] , aInssEmp[27, 2])
	If cRecFatEmp $ "S*M*C" .Or. (cAnoMes > cOnefol .And. !Empty(cOneFol) .And. SubStr(cOneFol,1,4) == SubStr(cAnoMes,1,4) )
		fPercEmp(@cRecFatEmp, @nPercEmp, @nPerEmp13)
	Else
		nPercEmp	:= If ((cTBLXPROV)->PR_TPCONTR$ " *1", aInssEmp[01, 1] , aInssEmp[01, 2])
		nPerEmp13   := If ((cTBLXPROV)->PR_TPCONTR$ " *1", aInssEmp[01, 1] , aInssEmp[01, 2])
		If lCttPerEmp .And. CTT->( dbSeek( xFilial("CTT", SRA->RA_FILIAL) + SRA->RA_CC ) ) .And. CTT->CTT_PEREMP > 0
			nPercEmp    := CTT->CTT_PEREMP / 100
			nPerEmp13	:= CTT->CTT_PEREMP / 100
		EndIf
	EndIf
	nPercTer 	:= If ((cTBLXPROV)->PR_TPCONTR$ " *1", aInssEmp[02, 1] , aInssEmp[02, 2])
	nPercAcTrab := If ((cTBLXPROV)->PR_TPCONTR$ " *1", aInssEmp[03, 1] , aInssEmp[03, 2])
	// BUSCA O % ACID. TRAB. NO FUNCIONARIO/CENTRO CUSTO E TERCEIROS NO CENTRO DE CUSTO
	fBuscaAci(@nPercAcTrab,@nPercTer)
	//DEDUZIR O % DE TERCEIROS DEFINIDO NA TABELA AUXILIAR S035
	nPercTer -= fP15Terc((cTBLXPROV)->PR_CC,aGPSPer,"*")
EndIf
nPercFgts 	:= If ((cTBLXPROV)->PR_TPCONTR$ " *1", aInssEmp[04, 1] , aInssEmp[04, 2])

If SRA->RA_REGIME == '2'
	nPercFgts := 0
EndIf

// BUSCA O % DE FGTS DO CADASTRO DE FUNCIONARIOS
If SRA->RA_PERFGTS > 0.00
   nPercFgts := SRA->RA_PERFGTS / 100
Endif

// SOMA O % DE FGTS REFERENTE A CONTRIBUICAO DE 0.5
nPercFgts += nPercFgC

Return Nil

/*
‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±⁄ƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒø±±
±±≥Funcao    ≥fBusCodBx ≥ Autor ≥ Emerson R. de Souza	≥ Data ≥ 27.06.00 ≥±±
±±√ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒ¥±±
±±≥Descricao ≥ Carrega Codigos de Ferias Para Baixa da Provisao           ≥±±
±±√ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¥±±
±±≥Sintaxe   ≥ fBusCodBx()                                                ≥±±
±±√ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¥±±
±±≥Uso       ≥ Generico                                                   ≥±±
±±¿ƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒŸ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±± */
Static Function fBusCodBx(cFilProc)
Local cDifFerAux	:= aCodFol[088,1] + "/" + aCodFol[089,1]
Local cAliasTMP		:= GetNextAlias()

DEFAULT lGp070COD := ExistBlock("GP070COD")

// CODIGOS PARA BAIXA DA PROVISAO DE FERIAS
cCodFer 	:= aCodFol[072,1] + "*" + aCodFol[074,1] + "*" + aCodFol[088,1] + "*" + aCodFol[094,1] + "*" + aCodFol[0891,1] + "*"
cCodUmTer	:= aCodFol[077,1] + "*" + aCodFol[079,1] + "*" + aCodFol[090,1] + "*" + aCodFol[095,1] + "*"
cCodFerMs	:= aCodFol[073,1] + "*" + aCodFol[089,1] + "*" + aCodFol[205,1] + "*" + aCodFol[207,1] + "*"
cCodUmTerMs := aCodFol[078,1] + "*" + aCodFol[091,1] + "*" + aCodFol[206,1] + "*" + aCodFol[208,1] + "*"
cCodAbono	:= aCodFol[074,1] + "*" + aCodFol[079,1] + "*" + aCodFol[094,1] + "*" + aCodFol[095,1] + "*"
cCodAboMs	:= aCodFol[205,1] + "*" + aCodFol[207,1] + "*" + aCodFol[206,1] + "*" + aCodFol[208,1] + "*"
cCodAdicMs  := aCodFol[076,1] + "*" + aCodFol[081,1] + "*" + aCodFol[083,1] + "*" + aCodFol[085,1] + "*" +;
               aCodFol[093,1] + "*" + aCodFol[097,1] + "*" + aCodFol[099,1] + "*" + aCodFol[344,1] + "*" +;
			   aCodFol[346,1] + "*" + aCodFol[637,1] + "*" + aCodFol[1297,1] + "*" + aCodFol[1299,1] + "*" + aCodFol[1313,1];
			   + "*" + aCodFol[1315,1] + "*" + aCodFol[1301,1] + "*" + aCodFol[1303,1] + "*" + aCodFol[1317,1] + "*" + aCodFol[1319,1];
			   + "*" + aCodFol[1305,1] + "*" + aCodFol[1307,1] + "*" + aCodFol[1321,1] + "*" + aCodFol[1323,1] + "*" + aCodFol[1309,1];
			   + "*" + aCodFol[1325,1] + "*" + aCodFol[1311,1] + "*" + aCodFol[1327,1] + "*" + aCodFol[633,1] + "*" + aCodFol[634,1];
			   + "*" + aCodFol[1331,1] + "*" + aCodFol[839,1]  + "*" + aCodFol[1419,1] + "*" + aCodFol[1451,1]

cCodAdFer	:= aCodFol[075,1] + "*" + aCodFol[080,1] + "*" + aCodFol[082,1] + "*" + aCodFol[084,1] + "*" +;
			   aCodFol[092,1] + "*" + aCodFol[096,1] + "*" + aCodFol[098,1] + "*" + aCodFol[343,1] + "*" +;
			   aCodFol[345,1] + "*" + aCodFol[636,1] + "*" + aCodFol[1296,1] + "*" + aCodFol[1298,1] + "*" + aCodFol[1312,1];
			   + "*" + aCodFol[1314,1] + "*" + aCodFol[1300,1] + "*" + aCodFol[1302,1] + "*" + aCodFol[1316,1] + "*" + aCodFol[1318,1];
			   + "*" + aCodFol[1304,1] + "*" + aCodFol[1320,1] + "*" + aCodFol[1322,1] + "*" + aCodFol[1308,1] + "*" + aCodFol[1324,1];
			   + "*" + aCodFol[1306,1] + "*" + aCodFol[1310,1] + "*" + aCodFol[1326,1] + "*" + aCodFol[1330,1] + "*" + aCodFol[838,1] ;
			   + "*" + aCodFol[1418,1]
cCodSalV    := aCodFol[361,1]
cCodSalVMs  := aCodFol[362,1]
//CODIGOS PARA BAIXA DA PROVISAO DE 13o. SALARIO
cCod13o	  := aCodFol[024,1] + "*" + aCodFol[028,1] + "*" + aCodFol[348,1] + "*" + aCodFol[1435,1]
cCodAd13o := aCodFol[001,1] + "*" + aCodFol[002,1] + "*" + aCodFol[003,1] + "*" + aCodFol[004,1] + "*"+;
		     aCodFol[005,1] + "*" + aCodFol[036,1] + "*" + aCodFol[037,1] + "*" + aCodFol[038,1] + "*"+;
			 aCodFol[039,1] + "*" + aCodFol[123,1] + "*" + aCodFol[124,1] + "*" + aCodFol[181,1] + "*"+;
			 aCodFol[182,1] + "*" + aCodFol[1288,1] + "*" + aCodFol[1289,1] + "*" + aCodFol[1290,1] + "*" +;
			 aCodFol[1291,1] + "*" + aCodFol[1292,1] + "*" + aCodFol[1293,1] + "*" + aCodFol[1294,1] + "*" +;
			 aCodFol[1295,1] + "*" + aCodFol[1436,1] + "*" + aCodFol[1437,1] + "*" + aCodFol[1438,1] + "*" +;
			 aCodFol[1439,1] + "*" + aCodFol[1440,1] + "*" + aCodFol[1441,1] + "*" + aCodFol[1442,1] + "*" +;
			 aCodFol[1443,1] + "*" + aCodFol[1444,1] + "*" + aCodFol[1445,1] + "*" + aCodFol[1442,1] + "*" +;
			 aCodFol[1443,1]
cInss13o  := aCodFol[148,1]
cCodPLR	  := aCodFol[151,1]
cCodAdiAbo:= aCodFol[622,1] + "*" + aCodFol[623,1] + "*" + aCodFol[633,1] + "*" + aCodFol[634,1] + "*" + aCodFol[1312,1] + "*" + aCodFol[1313,1] + "*" +;
   			 aCodFol[1314,1] + "*" + aCodFol[1315,1] + "*" + aCodFol[1316,1] + "*" + aCodFol[1317,1] + "*" + aCodFol[1318,1] + "*" + aCodFol[1319,1] + "*" +;
   			 aCodFol[1320,1] + "*" + aCodFol[1321,1] + "*" + aCodFol[1322,1] + "*" + aCodFol[1323,1] + "*" + aCodFol[1324,1] + "*" + aCodFol[1325,1] + "*" +;
   			 aCodFol[1326,1] + "*" + aCodFol[1327,1] + "*" + aCodFol[1330,1] + "*" + aCodFol[1331,1] + "*" + aCodFol[1416,1] + "*" + aCodFol[1417,1] + "*" +;
			 aCodFol[1418,1] + "*" + aCodFol[1419,1] + "*" + aCodFol[1450,1] + "*" + aCodFol[1451,1]
cCodAdAMs:=  aCodFol[0633,1] + "*" + aCodFol[0634,1] + "*" + aCodFol[1313,1] + "*" + aCodFol[1315,1] + "*" +;
   			 aCodFol[1317,1] + "*" + aCodFol[1319,1] + "*" + aCodFol[1321,1] + "*" + aCodFol[1323,1] + "*" +;
   			 aCodFol[1325,1] + "*" + aCodFol[1327,1] + "*" + aCodFol[1331,1] + "*" + aCodFol[1418,1] + "*" +;
			 aCodFol[1419,1] + "*" + aCodFol[1451,1]

//Verifica se existem verbas sem identificador utilizadas para pagamento de diferenÁa de adicionais e as inclui para baixa.
BeginSql alias cAliasTMP
	SELECT RV_COD, RV_FERSEG
	FROM %table:SRV% SRV
	WHERE SRV.RV_FILIAL = %exp:(xFilial("SRV",cFilProc))% AND SRV.RV_FERSEG <> '' AND SRV.%notDel%
EndSql

While (cAliasTMP)->( !Eof() )
	If !((cAliasTMP)->RV_FERSEG $ cDifFerAux) .and. (cAliasTMP)->RV_COD $ cCodAdFer
		If Empty(RetValSrv((cAliasTMP)->RV_FERSEG,cFilProc,"RV_CODFOL"))
			cCodAdFer += "*" + (cAliasTMP)->RV_FERSEG
		EndIf
	ElseIf !((cAliasTMP)->RV_FERSEG $ cDifFerAux) .and. (cAliasTMP)->RV_COD $ cCodAdicMs
		If Empty(RetValSrv((cAliasTMP)->RV_FERSEG,cFilProc,"RV_CODFOL"))
			cCodAdicMs += "*" + (cAliasTMP)->RV_FERSEG
		EndIf
	EndIf
	(cAliasTMP)->( dbSkip() )
EndDo

(cAliasTMP)->( dbCloseArea() )

// PONTO DE ENTRADA PARA ACRESCENTAR VERBAS AOS CODIGOS PADRAO
If lGp070COD
	ExecBlock("GP070COD",.F.,.F.)
Endif

Return Nil

/*
‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±⁄ƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒø±±
±±≥Funcao    ≥fLimpaArra≥ Autor ≥ Emerson R. de Souza	≥ Data ≥ 27.06.00 ≥±±
±±√ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒ¥±±
±±≥Descricao ≥ Limpa o array de provisao para calculo                     ≥±±
±±√ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¥±±
±±≥Sintaxe   ≥ fLimpaArray(aProvisao)                                     ≥±±
±±√ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¥±±
±±≥Parametros≥ aProvisao  - Array que sera zerado                         ≥±±
±±≥          ≥ uConteudo  - Conteudo que sera gravado no array            ≥±±
±±√ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¥±±
±±≥Uso       ≥ Generico                                                   ≥±±
±±¿ƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒŸ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±*/
Function fLimpaArray(aProvisao,uConteudo,cNaoLimpar,nLinProv)
Local nCnt1, nCnt2

cNaoLimpar := If(cNaoLimpar == Nil, "", cNaoLimpar)

DEFAULT nLinProv := _Linhas

For nCnt1 := 1 To nLinProv
	If !Str(nCnt1,1) $ cNaoLimpar
		For nCnt2 := 1 To _Colunas
			aProvisao[nCnt1,nCnt2] := uConteudo
		Next nCnt2
	EndIf
Next nCnt1

Return Nil

/*
‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±⁄ƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒø±±
±±≥Funcao    ≥fIdentProv≥ Autor ≥ Emerson R. de Souza	≥ Data ≥ 27.06.00 ≥±±
±±√ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒ¥±±
±±≥Descricao ≥ Carrega Codigos de Provisao Para Lancamentos no SRT        ≥±±
±±√ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¥±±
±±≥Sintaxe   ≥ fIdentProv(aVerba,aCodFol)                                 ≥±±
±±√ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¥±±
±±≥Uso       ≥ Generico                                                   ≥±±
±±¿ƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒŸ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±± */
Function fIdentProv(aVerba,aCodFol)

aVerba := {}

Aadd(aVerba, { _FerVenc, _Atual, _Prov, aCodFol[130,1], "130" }) // Provisao de Ferias
Aadd(aVerba, { _FerVenc, _Atual, _Adic, aCodFol[254,1], "254" }) // Adicional Provisao de Ferias
Aadd(aVerba, { _FerVenc, _Atual, _1Ter, aCodFol[255,1], "255" }) // Um Terco Provisao de Ferias
Aadd(aVerba, { _FerVenc, _Atual, _INSS, aCodFol[131,1], "131" }) // INSS Provisao de Ferias
Aadd(aVerba, { _FerVenc, _Atual, _FGTS, aCodFol[132,1], "132" }) // FGTS Provisao de Ferias
Aadd(aVerba, { _FerVenc, _Atual, _PIS,  aCodFol[416,1], "416" }) // PIS Provisao de Ferias

Aadd(aVerba, { _FerVenc, _Corre, _Prov, aCodFol[133,1], "133" }) // Correcao Provisao de Ferias
Aadd(aVerba, { _FerVenc, _Corre, _Adic, aCodFol[256,1], "256" }) // Correcao Adicional Provisao de Ferias
Aadd(aVerba, { _FerVenc, _Corre, _1Ter, aCodFol[257,1], "257" }) // Correcao Um Terco Provisao de Ferias
Aadd(aVerba, { _FerVenc, _Corre, _INSS, aCodFol[134,1], "134" }) // Correcao INSS Provisao de Ferias
Aadd(aVerba, { _FerVenc, _Corre, _FGTS, aCodFol[135,1], "135" }) // Correcao FGTS Provisao de Ferias
Aadd(aVerba, { _FerVenc, _Corre, _PIS,  aCodFol[417,1], "417" }) // Correcao PIS Provisao de Ferias

Aadd(aVerba, { _FerVenc, _BxFer, _Prov, aCodFol[233,1], "233" }) // Baixa Provisao Ferias
Aadd(aVerba, { _FerVenc, _BxFer, _Adic, aCodFol[258,1], "258" }) // Baixa Adicional Provisao de Ferias
Aadd(aVerba, { _FerVenc, _BxFer, _1Ter, aCodFol[259,1], "259" }) // Baixa Um Terco Provisao de Ferias
Aadd(aVerba, { _FerVenc, _BxFer, _INSS, aCodFol[234,1], "234" }) // Baixa Inss Provisao Ferias
Aadd(aVerba, { _FerVenc, _BxFer, _FGTS, aCodFol[235,1], "235" }) // Baixa Fgts Provisao Ferias
Aadd(aVerba, { _FerVenc, _BxFer, _PIS,  aCodFol[418,1], "418" }) // Baixa PIS Provisao Ferias

Aadd(aVerba, { _FerVenc, _BxTrf, _Prov, aCodFol[239,1], "239" }) // Baixa Provisao Ferias Transferidos
Aadd(aVerba, { _FerVenc, _BxTrf, _Adic, aCodFol[260,1], "260" }) // Baixa Adicional Provisao de Ferias Transferidos
Aadd(aVerba, { _FerVenc, _BxTrf, _1Ter, aCodFol[261,1], "261" }) // Baixa Um Terco Provisao de Ferias Transferidos
Aadd(aVerba, { _FerVenc, _BxTrf, _INSS, aCodFol[240,1], "240" }) // Baixa Inss Provisao Ferias Transferidos
Aadd(aVerba, { _FerVenc, _BxTrf, _FGTS, aCodFol[241,1], "241" }) // Baixa Fgts Provisao Ferias Transferidos
Aadd(aVerba, { _FerVenc, _BxTrf, _PIS,  aCodFol[419,1], "419" }) // Baixa PIS Provisao Ferias Transferidos

Aadd(aVerba, { _FerVenc, _BxRes, _Prov, aCodFol[262,1], "262" }) // Baixa Provisao Ferias Rescisao
Aadd(aVerba, { _FerVenc, _BxRes, _Adic, aCodFol[263,1], "263" }) // Baixa Adicional Provisao de Ferias Rescisao
Aadd(aVerba, { _FerVenc, _BxRes, _1Ter, aCodFol[264,1], "264" }) // Baixa Um Terco Provisao de Ferias Rescisao
Aadd(aVerba, { _FerVenc, _BxRes, _INSS, aCodFol[265,1], "265" }) // Baixa Inss Provisao Ferias Rescisao
Aadd(aVerba, { _FerVenc, _BxRes, _FGTS, aCodFol[266,1], "266" }) // Baixa Fgts Provisao Ferias Rescisao
Aadd(aVerba, { _FerVenc, _BxRes, _PIS,  aCodFol[420,1], "420" }) // Baixa PIS Provisao Ferias Rescisao

Aadd(aVerba, { _FerVMes, _Atual, _Prov, aCodFol[960,1], "960" }) // Prov. MÍs FÈrias
Aadd(aVerba, { _FerVMes, _Atual, _Adic, aCodFol[962,1], "962" }) // Prov. MÍs Adicional de FÈrias
Aadd(aVerba, { _FerVMes, _Atual, _1Ter, aCodFol[961,1], "961" }) // Prov. MÍs 1/3 de FÈrias
Aadd(aVerba, { _FerVMes, _Atual, _INSS, aCodFol[963,1], "963" }) // Prov. MÍs INSS de FÈrias
Aadd(aVerba, { _FerVMes, _Atual, _FGTS, aCodFol[964,1], "964" }) // Prov. MÍs FGTS de FÈrias
Aadd(aVerba, { _FerVMes, _Atual, _PIS,  aCodFol[965,1], "965" }) // Prov. MÍs PIS de FÈrias

If Len(aCodFol) > 1399
	Aadd(aVerba, { _RecVenc, _Atual, _Prov, aCodFol[1400,1], "1400" }) // Provisao de Recesso
	Aadd(aVerba, { _RecVenc, _Corre, _Prov, aCodFol[1401,1], "1401" }) // Correcao Provisao de Recesso
	Aadd(aVerba, { _RecVenc, _BxFer, _Prov, aCodFol[1402,1], "1402" }) // Baixa Provisao Recesso
	Aadd(aVerba, { _RecVenc, _BxTrf, _Prov, aCodFol[1403,1], "1403" }) // Baixa Provisao Recesso Transferidos
	Aadd(aVerba, { _RecVenc, _BxRes, _Prov, aCodFol[1404,1], "1404" }) // Baixa Provisao Recesso Rescisao
Endif

Aadd(aVerba, { _13Salar, _Atual, _Prov, aCodFol[136,1], "136" }) // Provisao de 13o Salario
Aadd(aVerba, { _13Salar, _Atual, _Adic, aCodFol[267,1], "267" }) // Adicional Provisao de 13o Salario
Aadd(aVerba, { _13Salar, _Atual, _1Par, aCodFol[268,1], "268" }) // 1a. Parcela 13o Provisao
Aadd(aVerba, { _13Salar, _Atual, _INSS, aCodFol[137,1], "137" }) // INSS Provisao 13o Salario
Aadd(aVerba, { _13Salar, _Atual, _FGTS, aCodFol[138,1], "138" }) // FGTS Provisao 13o Salario
Aadd(aVerba, { _13Salar, _Atual, _PIS,  aCodFol[421,1], "421" }) // PIS Provisao 13o Salario

Aadd(aVerba, { _13Salar, _Corre, _Prov, aCodFol[139,1], "139" }) // Correcao Provisao 13o Salario
Aadd(aVerba, { _13Salar, _Corre, _Adic, aCodFol[269,1], "269" }) // Correcao Adicional Provisao de 13o Salario
Aadd(aVerba, { _13Salar, _Corre, _INSS, aCodFol[140,1], "140" }) // Correcao INSS Provisao 13o Salario
Aadd(aVerba, { _13Salar, _Corre, _FGTS, aCodFol[141,1], "141" }) // Correcao FGTS Provisao 13o Salario
Aadd(aVerba, { _13Salar, _Corre, _PIS,  aCodFol[422,1], "422" }) // Correcao PIS Provisao 13o Salario

Aadd(aVerba, { _13Salar, _Bx13O, _Prov, aCodFol[332,1], "332" }) // Baixa Provisao 13o Salario
Aadd(aVerba, { _13Salar, _Bx13O, _Adic, aCodFol[333,1], "333" }) // Baixa Adicional Provisao de 13o Salario
Aadd(aVerba, { _13Salar, _Bx13O, _1Par, aCodFol[334,1], "334" }) // Baixa Antecipacao 1a Parcela do 13o Salario
Aadd(aVerba, { _13Salar, _Bx13O, _INSS, aCodFol[335,1], "335" }) // Baixa Inss Provisao 13o Salario
Aadd(aVerba, { _13Salar, _Bx13O, _FGTS, aCodFol[336,1], "336" }) // Baixa Fgts Provisao 13o Salario
Aadd(aVerba, { _13Salar, _Bx13O, _PIS,  aCodFol[423,1], "423" }) // Baixa PIS Provisao 13o Salario

Aadd(aVerba, { _13Salar, _BxTrf, _Prov, aCodFol[270,1], "270" }) // Baixa Provisao 13o Salario Transferido
Aadd(aVerba, { _13Salar, _BxTrf, _Adic, aCodFol[271,1], "271" }) // Baixa Adicional Provisao de 13o Salario Transferido
If !Empty(aCodFol[1964,1]) //N„o ser· obrigatÛrio
	Aadd(aVerba, { _13Salar, _BxTrf, _1Par, aCodFol[1964,1],"1964"}) // Baixa Antecipacao 1a Parcela do 13o Salario Transferido
EndIf
Aadd(aVerba, { _13Salar, _BxTrf, _INSS, aCodFol[272,1], "272" }) // Baixa Inss Provisao 13o Salario Transferido
Aadd(aVerba, { _13Salar, _BxTrf, _FGTS, aCodFol[273,1], "273" }) // Baixa Fgts Provisao 13o Salario Transferido
Aadd(aVerba, { _13Salar, _BxTrf, _PIS,  aCodFol[424,1], "424" }) // Baixa PIS Provisao 13o Salario Transferido

Aadd(aVerba, { _13Salar, _BxRes, _Prov, aCodFol[274,1], "274" }) // Baixa Provisao 13o Salario Rescisao
Aadd(aVerba, { _13Salar, _BxRes, _Adic, aCodFol[275,1], "275" }) // Baixa Adicional Provisao de 13o Salario Rescisao
Aadd(aVerba, { _13Salar, _BxRes, _1Par, aCodFol[1854,1],"1854"}) // Baixa Antecipacao 1a Parcela do 13o Salario Rescisao
Aadd(aVerba, { _13Salar, _BxRes, _INSS, aCodFol[276,1], "276" }) // Baixa Inss Provisao 13o Salario Rescisao
Aadd(aVerba, { _13Salar, _BxRes, _FGTS, aCodFol[277,1], "277" }) // Baixa Fgts Provisao 13o Salario Rescisao
Aadd(aVerba, { _13Salar, _BxRes, _PIS,  aCodFol[425,1], "425" }) // Baixa PIS Provisao 13o Salario Rescisao

Aadd(aVerba, { _13SVMes, _Atual, _Prov, aCodFol[966,1], "966" }) // 966 - Prov. MÍs 13o Sal·rio
Aadd(aVerba, { _13SVMes, _Atual, _Adic, aCodFol[967,1], "967" }) // 967 - Prov. MÍs Adcional de 13o Sal·rio
Aadd(aVerba, { _13SVMes, _Atual, _1Par, aCodFol[968,1], "968" }) // 968 - 1a. Parcela 13o Provisao
Aadd(aVerba, { _13SVMes, _Atual, _INSS, aCodFol[969,1], "969" }) // 969 - Prov. MÍs INSS de 13o Sal·rio
Aadd(aVerba, { _13SVMes, _Atual, _FGTS, aCodFol[970,1], "970" }) // 970 - Prov. MÍs FGTS de 13o Sal·rio
Aadd(aVerba, { _13SVMes, _Atual, _PIS,  aCodFol[971,1], "971" }) // 971 - Prov. MÍs PIS de 13o Sal·rio

//14o Sal·rio
Aadd(aVerba, { _14Salar, _Atual, _Prov, aCodFol[142,1], "142" }) // Provisao de 14o Salario
Aadd(aVerba, { _14Salar, _Atual, _Adic, aCodFol[278,1], "278" }) // Adicional Provisao de 14o Salario
Aadd(aVerba, { _14Salar, _Atual, _INSS, aCodFol[143,1], "143" }) // INSS Provisao 14o Salario
Aadd(aVerba, { _14Salar, _Atual, _FGTS, aCodFol[144,1], "144" }) // FGTS Provisao 14o Salario
Aadd(aVerba, { _14Salar, _Atual, _PIS,  aCodFol[426,1], "426" }) // PIS Provisao 14o Salario
Aadd(aVerba, { _14Salar, _Atual, _1Par, aCodFol[268,1], "268" }) // 1a. Parcela 13o Provisao

Aadd(aVerba, { _14Salar, _Corre, _Prov, aCodFol[145,1], "145" }) // Correcao Provisao 14o Salario
Aadd(aVerba, { _14Salar, _Corre, _Adic, aCodFol[279,1], "279" }) // Correcao Adicional Provisao de 14o Salario
Aadd(aVerba, { _14Salar, _Corre, _INSS, aCodFol[146,1], "146" }) // Correcao INSS Provisao 14o Salario
Aadd(aVerba, { _14Salar, _Corre, _FGTS, aCodFol[147,1], "147" }) // Correcao FGTS Provisao 14o Salario
Aadd(aVerba, { _14Salar, _Corre, _PIS,  aCodFol[427,1], "427" }) // Correcao PIS Provisao 14o Salario

Aadd(aVerba, { _14Salar, _BxTrf, _Prov, aCodFol[280,1], "280" }) // Baixa Provisao 14o Salario Transferido
Aadd(aVerba, { _14Salar, _BxTrf, _Adic, aCodFol[281,1], "281" }) // Baixa Adicional Provisao de 14o Salario Transferido
Aadd(aVerba, { _14Salar, _BxTrf, _INSS, aCodFol[282,1], "282" }) // Baixa Inss Provisao 14o Salario Transferido
Aadd(aVerba, { _14Salar, _BxTrf, _FGTS, aCodFol[283,1], "283" }) // Baixa Fgts Provisao 14o Salario Transferido
Aadd(aVerba, { _14Salar, _BxTrf, _PIS,  aCodFol[428,1], "428" }) // Baixa PIS Provisao 14o Salario Transferido

Aadd(aVerba, { _14Salar, _BxRes, _Prov, aCodFol[284,1], "284" }) // Baixa Provisao 14o Salario Rescisao
Aadd(aVerba, { _14Salar, _BxRes, _Adic, aCodFol[285,1], "285" }) // Baixa Adicional Provisao de 14o Salario Rescisao
Aadd(aVerba, { _14Salar, _BxRes, _INSS, aCodFol[286,1], "286" }) // Baixa Inss Provisao 14o Salario Rescisao
Aadd(aVerba, { _14Salar, _BxRes, _FGTS, aCodFol[287,1], "287" }) // Baixa Fgts Provisao 14o Salario Rescisao
Aadd(aVerba, { _14Salar, _BxRes, _PIS,  aCodFol[429,1], "429" }) // Baixa PIS Provisao 14o Salario Rescisao

Aadd(aVerba, { _14Salar, _Bx14o, _Prov,  aCodFol[1666,1], "1666" }) // Baixa Provis„o 14o Sal·rio
Aadd(aVerba, { _14Salar, _Bx14o, _Adic,  aCodFol[1667,1], "1667" }) // Baixa Adicionais Provis„o 14o Sal·rio
Aadd(aVerba, { _14Salar, _Bx14o, _1Par,  aCodFol[1668,1], "1668" }) // Baixa AntecipaÁ„o 1a Parcela do 14o Sal·rio
Aadd(aVerba, { _14Salar, _Bx14o, _INSS,  aCodFol[1669,1], "1669" }) // Baixa INSS Provis„o 14o Sal·rio
Aadd(aVerba, { _14Salar, _Bx14o, _FGTS,  aCodFol[1670,1], "1670" }) // Baixa FGTS Provis„o 14o Sal·rio
Aadd(aVerba, { _14Salar, _Bx14o, _PIS ,  aCodFol[1671,1], "1671" }) // Baixa PIS Provis„o 14o Sal·rio



//PLR
Aadd(aVerba, { _PLRSalar, _Atual, _Prov, _cPDPLR, "PLR" }) // Provisao PLR
Aadd(aVerba, { _PLRSalar, _BxPLR, _Prov, _cPdBxPLR, "PLR" })
Aadd(aVerba, { _PLRSalar, _BxTrf, _Prov, _cPDTrfPLR, "PLR" })
Aadd(aVerba, { _PLRSalar, _BxRes, _Prov, _cPDResPLR, "PLR" })
Aadd(aVerba, { _PLRSVMes, _Atual, _Prov, _cPDMesPLR, "PLR" })

Return Nil

/*
‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±⁄ƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒø±±
±±≥Funcao    ≥fBusCabSRT≥ Autor ≥ Emerson R. de Souza	≥ Data ≥ 21.06.00 ≥±±
±±√ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒ¥±±
±±≥Descricao ≥ Busca informacoes de cabecalho no SRT                      ≥±±
±±√ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¥±±
±±≥Sintaxe   ≥ fBusCabSRT(dDtBusca,aCabProv)                              ≥±±
±±√ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¥±±
±±≥Parametros≥                                                            ≥±±
±±√ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¥±±
±±≥Uso       ≥ Generico                                                   ≥±±
±±¿ƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒŸ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂ*/
Function fBusCabSRT(dDtBusca,aCabProv)
Local lRet		:= .F.
Local aArea		:= GetArea()
Local cClvl		:= ""
Local cCusto	:= ""
Local cItem		:= ""
Local cQryRec	:= GetNextAlias()
Local cWhereRec	:= ""
Local nRecnoRHT := 0
Local cWhere 	:= "%%"

DEFAULT	lItemClVl   := GetMvRH( "MV_ITMCLVL", .F., "2" ) $ "13"

If !lItemCLVL
	aCabProv := Array(11)
Else
	aCabProv := Array(14)
EndIF

If !Empty(cTpRtProv)
	cWhereRec := "RHT.RHT_FILIAL = '" + (cTBLXPROV)->PR_FILIAL + "' AND RHT.RHT_MAT = '" + (cTBLXPROV)->PR_MAT + "' "
	cWhereRec := "%"+cWhereRec+"%
	BeginSql alias cQryRec
		SELECT MAX(R_E_C_N_O_) AS RECNO
		FROM %table:RHT% RHT
		WHERE %exp:cWhereRec% AND RHT.%notDel%
	EndSql

	If !(cQryRec)->(Eof())
		nRecnoRHT := (cQryRec)->RECNO
		lRet := .T.
	Else
		lRet := .F.
	EndIF

	(cQryRec)->(dbCloseArea())

	cCusto	:= (cTBLXPROV)->PR_CCMVTO
	If lItemClVl
		cItem	:= (cTBLXPROV)->PR_ITMMVTO
		cClvl	:= (cTBLXPROV)->PR_CLVMVTO
	EndIf
Else
	dbSelectArea("SRT")
	cCusto	:= (cTBLXPROV)->PR_CC
	If lItemClVl
		cItem	:= (cTBLXPROV)->PR_ITEM
		cClvl	:= (cTBLXPROV)->PR_CLVL
	EndIf
Endif

If !Empty(cTpRtProv)
	dbSelectArea("RHT")
	dbGoTo(nRecnoRHT)
Else
	If lItemClvl
		cWhere := "% SRT.RT_ITEM = '" + cItem + "' AND SRT.RT_CLVL = '" + cClvl + "' AND %"
	EndIf

	BeginSql alias cQryRec
		SELECT R_E_C_N_O_ AS RECNOSRT
		FROM %table:SRT% SRT
		WHERE SRT.RT_FILIAL = %exp:(cTBLXPROV)->PR_FILIAL%
		 	AND %exp:cWhere%
		 	SRT.RT_MAT = %exp:(cTBLXPROV)->PR_MAT%
			AND SRT.RT_CC = %exp:cCusto%
			AND SUBSTRING(SRT.RT_DATACAL,1,6) = %exp:MesAno(dDtBusca)%
			AND SRT.RT_DATABAS <> %exp:''%
			AND SRT.%notDel%
 	EndSql
 	If !(cQryRec)->(Eof())
 		dbSelectArea("SRT")
 		dbGoTo((cQryRec)->RECNOSRT)
 		lRet := .T.
 	Else
 		dbSelectArea("SRT")
	 	If lItemClvl
			SRT->(dbSetOrder(4))
			lRet := dbSeek( (cTBLXPROV)->PR_FILIAL + (cTBLXPROV)->PR_MAT + cCusto + cItem + cClvl + MesAno(dDtBusca) )
		Else
			SRT->(dbSetOrder(1))
			lRet := dbSeek( (cTBLXPROV)->PR_FILIAL + (cTBLXPROV)->PR_MAT + cCusto + MesAno(dDtBusca) )
		EndIf
	EndIf
	(cQryRec)->(dbCloseArea())
EndIf

aCabProv[_DatCalc] := If (!Empty(cTpRtProv), RHT->RHT_DTCALC, SRT->RT_DATACAL)
aCabProv[_CentroC] := If (!Empty(cTpRtProv), RHT->RHT_CC, SRT->RT_CC)
aCabProv[_DBsProv] := If (!Empty(cTpRtProv), RHT->RHT_DTBASE, SRT->RT_DATABAS)
aCabProv[_DFerVen] := If (!Empty(cTpRtProv), RHT->RHT_DFERVE, SRT->RT_DFERVEN)
aCabProv[_DFerPro] := If (!Empty(cTpRtProv), RHT->RHT_DFERPR, SRT->RT_DFERPRO)
aCabProv[_DFalVen] := If (!Empty(cTpRtProv), RHT->RHT_DFALVE, SRT->RT_DFALVEN)
aCabProv[_DFalPro] := If (!Empty(cTpRtProv), RHT->RHT_DFALPR, SRT->RT_DFALPRO)
aCabProv[_DFerAnt] := If (!Empty(cTpRtProv), RHT->RHT_DFERAN, SRT->RT_DFERANT)
aCabProv[_Avos13S] := If (!Empty(cTpRtProv), RHT->RHT_AVOS13, SRT->RT_AVOS13S)
aCabProv[_MovProv] := If (!Empty(cTpRtProv), RHT->RHT_TIPMOV, SRT->RT_TIPMOVI)
aCabProv[_SalProv] := If (!Empty(cTpRtProv), RHT->RHT_SALAR, SRT->RT_SALARIO)
If LItemCLVL
	aCabProv[_cItem] := If (!Empty(cTpRtProv), RHT->RHT_ITEM, SRT->RT_ITEM)
	aCabProv[_Clvl] := If (!Empty(cTpRtProv), RHT->RHT_CLVL, SRT->RT_CLVL)
EndIf

RestArea(aArea)

Return lRet
/*
‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±⁄ƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒø±±
±±≥Funcao    ≥fQryDetSRT| Autor ≥ Ricardo Duarte Costa  ≥ Data ≥ 22.01.07 ≥±±
±±√ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒ¥±±
±±≥Descricao ≥ Busca os valores da provisao no arquivo SRT                ≥±±
±±√ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¥±±
±±≥Sintaxe   ≥ < vide parametros abaixo >                                 ≥±±
±±√ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¥±±
±±≥Parametros≥ aVerba     - Verbas de Ferias / 13o Sal / 14o Sal          ≥±±
±±≥          ≥ aTransf    - Funcionarios Transferidos no mes              ≥±±
±±≥          ≥ dDataRef   - Data de referencia para busca dos valores     ≥±±
±±≥          ≥ nTipoProv  - Tipo de provisao a buscar (Venc,Prop,13o)     |±±
±±≥          ≥ lTrataTrf  - Indica se deve tratar os transferidos         |±±
±±≥          ≥ lCalcula   - Indica se deve calcular o valor do mes        |±±
±±≥          ≥ lFerias    - Indica se deve buscar as ferias               |±±
±±≥          ≥ l13oSal    - Indica se deve buscar o 13o salario           |±±
±±√ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¥±±
±±≥ Uso      ≥ Generico                                                   ≥±±
±±¿ƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒŸ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂ*/
Function fQryDetSRT(aVerba,aTransf,dDataRef,lTrataTrf,lCalcula,lFerias,l13oSal,lSoMes,lPlr,lMudouRat)
Local cBusMesAnt,cBusMesAtu,nCnt1
Local cFilQryAnt,cMatQryAnt,cCCQryAnt,cFilQryAtu,cMatQryAtu,cCCQryAtu,cDtIQryAnt,cDtFQryAnt,cDtIQryAtu,cDtFQryAtu
Local cItmQryAnt,cClvQryAnt,cItmQryAtu,cClvQryAtu
Local nTpMov      := 0
Local nPosTrf	  := 0
Local nPosVerba	  := 0
Local nreg		  := 0
Local nTipoProv   := 0
Local nCntSRT	  := 0
Local ndFvSRT	  := 0 // Dias de fÈrias Vencidas da SRT
Local ndFpSRT	  := 0 // Dias de FÈrias Proporcionais da SRT
Local nPosAux	  := 0
Local cAlias      := ALIAS()
Local cAnoMesAnt  := MesAno(dDataRef - Day(dDataRef))
Local cAnoMesAtu  := MesAno(dDataRef)
Local cOrdemAnt   := &("{ || (cAliasAnt)->RT_FILIAL + (cAliasAnt)->RT_MAT + (cAliasAnt)->RT_CC + MesAno((cAliasAnt)->RT_DATACAL) }")
Local cOrdemBusca := &("{ || (cAliasSRT)->RT_FILIAL + (cAliasSRT)->RT_MAT + (cAliasSRT)->RT_CC + MesAno((cAliasSRT)->RT_DATACAL) }")
Local cCposQuery  := ""
Local cCposAux	  := ""
Local aStruAux	  := {}
Local aProvisao   := {}
Local axFerVenc   := {}
Local axFerProp   := {}
Local ax13Salar   := {}
Local ax14Salar   := {}
Local axPLRSalar   := {}
Local lTrfEmpAmes := .F.
Local lAdiant13	  := .F.
Local cOrdemSRT   := ""
Local cAliasAnt   := "QSRT2"
Local cTpProvMes  := ""
Local cEmpQryAnt  := ""
Local cTabAnt     := ""
Local cIniDtBase  := ""
Local cQryDtBase  := "''"
Local cQuerySRT	  := ""
Local cCCSRT	  := ""
Local cWhereSRT	  := ""
Local cCompAnt	  := ""
Local nDiaAnt 	  := 0
Local lQryAnt	  := .F.
Local nYears		:= 0
Local cAliasRHT		:= "QRHT"
Local cAliasTMP		:= "QTMP"
Local dPerAqui 		:= CTOD("//")
Local d1NextPer 	:= CTOD("//")
Local dDtBsSRT		:= cToD("//")
Local dBkpRef		:= cToD("//")
Local lBxMesRat		:= .F.
Local lInicRat 		:= .F.
Local lAntecip		:= .F.
Local nRHTValor 	:= 0
Local nRHTAtuVlr	:= 0
Local aBkpArr		:= {}
Local nNovoVal      := 0
Local nX			:= 0
Local nZ			:= 0
Local cBuscaReg		:= ""
Local aRatBkp	    := {}
Local lSldIn  		:= .F.
// Vari·vel cCodBx com os identificadores de c·lculo para as baixas de provis„o.
Local cCodBx := "'"+aCodFol[233,1]+"','"+aCodFol[258,1]+"','"+aCodFol[259,1]+"','"+aCodFol[234,1]+"','";
+aCodFol[235,1]+"','"+aCodFol[418,1]+"','"+aCodFol[239,1]+"','"+aCodFol[260,1]+"','"+aCodFol[261,1]+"','";
+aCodFol[240,1]+"','"+aCodFol[241,1]+"','"+aCodFol[419,1]+"','"+aCodFol[262,1]+"','"+aCodFol[263,1]+"','";
+aCodFol[264,1]+"','"+aCodFol[265,1]+"','"+aCodFol[266,1]+"','"+aCodFol[420,1]+"','"+aCodFol[1402,1]+"','";
+aCodFol[1403,1]+"','"+aCodFol[1404,1]+"','"+aCodFol[332,1]+"','"+aCodFol[333,1]+"','"+aCodFol[334,1]+"','";
+aCodFol[335,1]+"','"+aCodFol[336,1]+"','"+aCodFol[423,1]+"','"+aCodFol[270,1]+"','"+aCodFol[271,1]+"','";
+aCodFol[272,1]+"','"+aCodFol[273,1]+"','"+aCodFol[424,1]+"','"+aCodFol[274,1]+"','"+aCodFol[275,1]+"','";
+aCodFol[276,1]+"','"+aCodFol[277,1]+"','"+aCodFol[425,1]+"','"+aCodFol[280,1]+"','"+aCodFol[281,1]+"','";
+aCodFol[282,1]+"','"+aCodFol[283,1]+"','"+aCodFol[428,1]+"','"+aCodFol[284,1]+"','"+aCodFol[285,1]+"','";
+aCodFol[286,1]+"','"+aCodFol[287,1]+"','"+aCodFol[429,1]+"'"

DEFAULT lSoMes		:= .F.
DEFAULT lPLR		:= .F.
DEFAULT lMudouRat	:= .F.
DEFAULT lProvResc := (GetMvRH("MV_PROVRES",,"N") == "S") //-- Indica se devera provisionar no mes da rescisao

DEFAULT	lItemClVl   := GetMvRH( "MV_ITMCLVL", .F., "2" ) $ "13"
DEFAULT	cTrfAMES    := (GetMvRH("MV_TRFAMES",, Space(6))) //-- Ano/Mes para inicio das demonstracoes de entrada e saida de transferencias no conceito 1 (transfere saldo origem p/ destino)
DEFAULT	lTrfAMES    := (!Empty(cTrfAMES) .And. MesAno(dDataRef) >= cTrfAMES)

lTrfSld := .F.

lCalcula   := If(lCalcula  == Nil, .F., lCalcula)
lFerias	   := If(lFerias   == Nil, .T., lFerias)
l13oSal    := If(l13oSal   == Nil, .T., l13oSal)
lPlr       := If(lPlr   == Nil, .F., lPlr)

If !Empty(cTpRtProv)
	If lItemClVl
		cOrdemAnt   := &("{ || (cAliasAnt)->RT_FILIAL + (cAliasAnt)->RT_MAT + (cAliasAnt)->RT_CC + (cAliasAnt)->RT_ITEM + (cAliasAnt)->RT_CLVL + MesAno((cAliasAnt)->RT_DATACAL) }")
		cOrdemBusca := &("{ || (cAliasSRT)->RHT_FILIAL + (cAliasSRT)->RHT_MAT + (cAliasSRT)->RHT_CC + (cAliasSRT)->RHT_ITEM + (cAliasSRT)->RHT_CLVL + MesAno((cAliasSRT)->RHT_DTCALC) }")
	Else
		cOrdemBusca := &("{ || (cAliasSRT)->RHT_FILIAL + (cAliasSRT)->RHT_MAT + (cAliasSRT)->RHT_CC + MesAno((cAliasSRT)->RHT_DTCALC) }")
	EndIf
	cTpProvMes := If(lFerias, "'1','2'", "'3'")
ElseIf lItemClVl
	cOrdemAnt   := &("{ || (cAliasAnt)->RT_FILIAL + (cAliasAnt)->RT_MAT + (cAliasAnt)->RT_CC + (cAliasAnt)->RT_ITEM + (cAliasAnt)->RT_CLVL + MesAno((cAliasAnt)->RT_DATACAL) }")
	cOrdemBusca := &("{ || (cAliasSRT)->RT_FILIAL + (cAliasSRT)->RT_MAT + (cAliasSRT)->RT_CC + (cAliasSRT)->RT_ITEM + (cAliasSRT)->RT_CLVL + MesAno((cAliasSRT)->RT_DATACAL) }")
Endif

If !lSoMes
	If !lProvResc .And. (cTBLXPROV)->PR_TIPMOVI == _Demitido
		nPosTrf		:= Ascan(aTransf, { |X| X[_TAtual,_TEmp]+X[_TAtual,_TFil]+X[_TAtual,_TCC]+X[_TAtual,_TMat] == cEmpAnt+(cTBLXPROV)->PR_FILIAL+(cTBLXPROV)->PR_CC+(cTBLXPROV)->PR_MAT })
		If nPosTrf > 0 .and. ;
			aTransf[nPosTrf,_TAnter,_TEmp]+aTransf[nPosTrf,_TAnter,_TFil]+aTransf[nPosTrf,_TAnter,_TCC]+aTransf[nPosTrf,_TAnter,_TMat]==;
			aTransf[nPosTrf,_TDest ,_TEmp]+aTransf[nPosTrf,_TDest ,_TFil]+aTransf[nPosTrf,_TDest ,_TCC]+aTransf[nPosTrf,_TDest ,_TMat]
			nPosTrf		:= 0
	  	EndIf
		lTrfSld		:= nPosTrf > 0
		nTpMov		:= (cTBLXPROV)->PR_TIPMOVI //Gravar tipo de movimento de demissao
	EndIf

	//	CHAVE DE BUSCA DO MES ANTERIOR E ATUAL
	If lItemClVl
		cBusMesAnt  := (cTBLXPROV)->PR_FILIAL + (cTBLXPROV)->PR_MAT + (cTBLXPROV)->PR_CC + (cTBLXPROV)->PR_ITEM + (cTBLXPROV)->PR_CLVL + cAnoMesAnt
	Else
		cBusMesAnt  := (cTBLXPROV)->PR_FILIAL + (cTBLXPROV)->PR_MAT + (cTBLXPROV)->PR_CC + cAnoMesAnt
	EndIf
	cFilQryAnt	:= "'"+(cTBLXPROV)->PR_FILIAL+"'"
	cMatQryAnt	:= "'"+(cTBLXPROV)->PR_MAT+"'"
	cCCQryAnt	:= "'"+(cTBLXPROV)->PR_CC+"'"
	cEmpQryAnt	:= cEmpAnt
	If lItemClVl
		cItmQryAnt	:= "'"+(cTBLXPROV)->PR_ITEM+"'"
		cClvQryAnt	:= "'"+(cTBLXPROV)->PR_CLVL+"'"
	EndIf

	If lItemClVl
		cBusMesAtu := (cTBLXPROV)->PR_FILIAL + (cTBLXPROV)->PR_MAT + (cTBLXPROV)->PR_CC + (cTBLXPROV)->PR_ITEM + (cTBLXPROV)->PR_CLVL + cAnoMesAtu
	Else
		cBusMesAtu := (cTBLXPROV)->PR_FILIAL + (cTBLXPROV)->PR_MAT + (cTBLXPROV)->PR_CC + cAnoMesAtu
	EndIf
	cFilQryAtu	:= "'"+(cTBLXPROV)->PR_FILIAL+"'"
	cMatQryAtu	:= "'"+(cTBLXPROV)->PR_MAT+"'"
	cCCQryAtu	:= "'"+(cTBLXPROV)->PR_CC+"'"
	If lItemClVl
		cItmQryAtu	:= "'"+(cTBLXPROV)->PR_ITEM+"'"
		cClvQryAtu	:= "'"+(cTBLXPROV)->PR_CLVL+"'"
	EndIf

	// SE NAO TRATA TRANSFERENCIA BUSCAR C. DE CUSTO DO MES ANTERIOR
	If !lTrataTrf .Or. lTrfAMES .Or. lTrfSld
		If !lTrfSld
            If lItemClVl
				nPosTrf := Ascan(aTransf, { |X| X[_TAtual,_TEmp]+X[_TAtual,_TFil]+X[_TAtual,_TCC]+X[_TAtual,_TMat]+X[_TAtual,_TItem]+X[_TAtual,_TClvl] == cEmpAnt+(cTBLXPROV)->PR_FILIAL+(cTBLXPROV)->PR_CC+(cTBLXPROV)->PR_MAT+(cTBLXPROV)->PR_ITEM+(cTBLXPROV)->PR_CLVL })
			Else
				nPosTrf := Ascan(aTransf, { |X| X[_TAtual,_TEmp]+X[_TAtual,_TFil]+X[_TAtual,_TCC]+X[_TAtual,_TMat] == cEmpAnt+(cTBLXPROV)->PR_FILIAL+(cTBLXPROV)->PR_CC+(cTBLXPROV)->PR_MAT })
			EndIf
		    //Se anterior igual a destino entao nao houve transferencia.
			If nPosTrf > 0 .and. ;
				( ( lItemClVl .And.;
				aTransf[nPosTrf,_TAnter,_TEmp]+aTransf[nPosTrf,_TAnter,_TFil]+aTransf[nPosTrf,_TAnter,_TCC]+aTransf[nPosTrf,_TAnter,_TMat]+aTransf[nPosTrf,_TAnter,_TDta]+aTransf[nPosTrf,_TAnter,_TItem]+aTransf[nPosTrf,_TAnter,_TClvl] == ;
				aTransf[nPosTrf,_TDest ,_TEmp]+aTransf[nPosTrf,_TDest ,_TFil]+aTransf[nPosTrf,_TDest ,_TCC]+aTransf[nPosTrf,_TDest ,_TMat]+aTransf[nPosTrf,_TDest ,_TDta]+aTransf[nPosTrf,_TDest ,_TItem]+aTransf[nPosTrf,_TDest ,_TClvl] ) .Or.;
				( !lItemClVl .And.;
				aTransf[nPosTrf,_TAnter,_TEmp]+aTransf[nPosTrf,_TAnter,_TFil]+aTransf[nPosTrf,_TAnter,_TCC]+aTransf[nPosTrf,_TAnter,_TMat]+aTransf[nPosTrf,_TAnter,_TDta] == ;
				aTransf[nPosTrf,_TDest ,_TEmp]+aTransf[nPosTrf,_TDest ,_TFil]+aTransf[nPosTrf,_TDest ,_TCC]+aTransf[nPosTrf,_TDest ,_TMat]+aTransf[nPosTrf,_TDest ,_TDta] ) )
				nPosTrf:=0
			EndIf
		EndIf
		If nPosTrf > 0
			If lItemClVl
				cBusMesAnt	:= aTransf[nPosTrf,_TAnter,_TFil]+aTransf[nPosTrf,_TAnter,_TMat]+aTransf[nPosTrf,_TAnter,_TCC]+aTransf[nPosTrf,_TAnter,_TItem]+aTransf[nPosTrf,_TAnter,_TClvl]+cAnoMesAnt
			Else
				cBusMesAnt	:= aTransf[nPosTrf,_TAnter,_TFil]+aTransf[nPosTrf,_TAnter,_TMat]+aTransf[nPosTrf,_TAnter,_TCC]+cAnoMesAnt
			EndIf
			cFilQryAnt	:= "'"+aTransf[nPosTrf,_TAnter,_TFil]+"'"
			cMatQryAnt	:= "'"+aTransf[nPosTrf,_TAnter,_TMat]+"'"
			cCCQryAnt	:= "'"+aTransf[nPosTrf,_TAnter,_TCC]+"'"
			cEmpQryAnt	:= aTransf[nPosTrf,_TAnter,_TEmp]
			If lItemClVl
				cItmQryAnt	:= "'"+aTransf[nPosTrf,_TAnter,_TItem]+"'"
				cClvQryAnt	:= "'"+aTransf[nPosTrf,_TAnter,_TClvl]+"'"
			EndIf
			// Se transferencia ocorreu apos mes atual preserva mes anterior|
			If aTransf[nPosTrf,_TAnter,_TDta] > cAnoMesAtu
				If lItemClVl
					cBusMesAtu	:= aTransf[nPosTrf,_TAnter,_TFil]+aTransf[nPosTrf,_TAnter,_TMat]+aTransf[nPosTrf,_TAnter,_TCC]+aTransf[nPosTrf,_TAnter,_TItem]+aTransf[nPosTrf,_TAnter,_TClvl]+cAnoMesAtu
				Else
					cBusMesAtu	:= aTransf[nPosTrf,_TAnter,_TFil]+aTransf[nPosTrf,_TAnter,_TMat]+aTransf[nPosTrf,_TAnter,_TCC]+cAnoMesAtu
				EndIf
				cFilQryAtu	:= "'"+aTransf[nPosTrf,_TAnter,_TFil]+"'"
				cMatQryAtu	:= "'"+aTransf[nPosTrf,_TAnter,_TMat]+"'"
				cCCQryAtu	:= "'"+aTransf[nPosTrf,_TAnter,_TCC]+"'"
				If lItemClVl
					cItmQryAtu	:= "'"+aTransf[nPosTrf,_TAnter,_TItem]+"'"
					cClvQryAtu	:= "'"+aTransf[nPosTrf,_TAnter,_TClvl]+"'"
				EndIf

				lTrfSld := .F.
			EndIf
			lTrfEmpAmes := aTransf[nPosTrf,_TAnter,_TEmp] <> aTransf[nPosTrf,_TAtual,_TEmp]
		ElseIf (cTBLXPROV)->PR_TIPMOVI == _Trfe_Sai
			If lItemClVl
				nPosTrfAmes	:= Ascan(aTransf, { |X| X[_TAnter,_TEmp]+X[_TAnter,_TFil]+X[_TAnter,_TCC]+X[_TAnter,_TMat]+X[_TAnter,_TItem]+X[_TAnter,_TClvl] == cEmpAnt+(cTBLXPROV)->PR_FILIAL+(cTBLXPROV)->PR_CC+(cTBLXPROV)->PR_MAT+(cTBLXPROV)->PR_ITEM+(cTBLXPROV)->PR_CLVL })
			Else
				nPosTrfAmes	:= Ascan(aTransf, { |X| X[_TAnter,_TEmp]+X[_TAnter,_TFil]+X[_TAnter,_TCC]+X[_TAnter,_TMat] == cEmpAnt+(cTBLXPROV)->PR_FILIAL+(cTBLXPROV)->PR_CC+(cTBLXPROV)->PR_MAT })
			EndIf
			If nPosTrfAmes > 0
				lTrfEmpAmes := aTransf[nPosTrfAmes,_TAnter,_TEmp] <> aTransf[nPosTrfAmes,_TAtual,_TEmp]
			Endif
		Endif
	EndIf

	cAliasSRT	:= "QSRT"

	aStruAux 	:= SRT->(dbStruct())

	If Empty(cTpRtProv)
		aStruSRT 	:= aClone(aStruAux)
	Else
		aStruSRT	:= RHT->(dbStruct())
		
		For nCntSRT := 1 To Len(aStruAux)
			If nCntSRT < Len(aStruAux)
				cCposAux	+= aStruAux[nCntSRT,1] + ", "
			Else
				cCposAux	+= aStruAux[nCntSRT,1]
			EndIf
		Next nCntSRT
	EndIf

	For nCntSRT := 1 To Len(aStruSRT)
		If nCntSRT < Len(aStruSRT)
			cCposQuery	+= aStruSRT[nCntSRT,1] + ", "
		Else
			cCposQuery	+= aStruSRT[nCntSRT,1]
		EndIf
	Next nCntSRT

	//MONTA A QUERY PARA SELECAO DOS DADOS
	cCposQuery	+=	", R_E_C_N_O_ AS RECNO_"

	cCposQuery	:=	"% "+cCposQuery+" %"

	If lItemClVl
		cOrdem		:= If (Empty(cTpRtProv), SqlOrder( SRT->( IndexKey(4) ) ), SqlOrder( RHT->( IndexKey(4) ) ) )
	Else
		cOrdem		:= If (Empty(cTpRtProv), SqlOrder( SRT->( IndexKey(1) ) ), SqlOrder( RHT->( IndexKey(1) ) ) )
	EndIf

	cOrdem		:= "% "+cOrdem+" %"
	cDtIQryAnt	:= "'"+cAnoMesAnt+"01'"
	cDtFQryAnt	:= "'"+Dtos(dDataRef-Day(dDataRef))+"'"
	cDtIQryAtu	:= "'"+cAnoMesAtu+"01'"
	cDtFQryAtu	:= "'"+cAnoMesAtu+strzero(f_Ultdia(dDataRef),2)+"'"

	If !Empty(cTpRtProv)
		If lItemClVl
			cWhere		:=	"(RHT.RHT_FILIAL = "+cFilQryAtu+" AND RHT.RHT_MAT = "+cMatQryAtu+;
							" AND RHT.RHT_DTCALC BETWEEN "+cDtIQryAtu+" AND "+cDtFQryAtu+" ) "
			cWhere		+= " AND RHT.RHT_CC = '"+(cTBLXPROV)->PR_CCMVTO+ "' AND RHT.RHT_ITEM = '"+(cTBLXPROV)->PR_ITMMVTO+ "' AND RHT.RHT_CLVL = '"+(cTBLXPROV)->PR_CLVMVTO+ "' AND RHT.RHT_TPPROV IN ("+ cTpProvMes+ " )"

			cWhereSRT		:=	"(SRT.RT_FILIAL = "+cFilQryAnt+" AND SRT.RT_MAT = "+cMatQryAnt+" AND "+;
							"SRT.RT_CC = "+cCCQryAnt+" AND SRT.RT_ITEM = "+cItmQryAnt+" AND SRT.RT_CLVL = "+cClvQryAnt+" AND SRT.RT_DATACAL BETWEEN "+cDtIQryAnt+" AND "+cDtFQryAnt+" )"
			cWhereSRT		:=	"( "+cWhereSRT+" OR (SRT.RT_FILIAL = "+cFilQryAtu+" AND SRT.RT_MAT = "+cMatQryAtu+" AND "+;
							"SRT.RT_CC = "+cCCQryAtu+" AND SRT.RT_ITEM = "+cItmQryAtu+" AND SRT.RT_CLVL = "+cClvQryAtu+" AND SRT.RT_DATACAL BETWEEN "+cDtIQryAtu+" AND "+cDtFQryAtu+" ) )"
		Else
			cWhere		:=	"(RHT.RHT_FILIAL = "+cFilQryAtu+" AND RHT.RHT_MAT = "+cMatQryAtu+;
							" AND RHT.RHT_DTCALC BETWEEN "+cDtIQryAtu+" AND "+cDtFQryAtu+" ) "
			cWhere		+= " AND RHT.RHT_CC = '"+(cTBLXPROV)->PR_CCMVTO+ "' AND RHT.RHT_TPPROV IN ("+ cTpProvMes+ " )"

			cWhereSRT		:=	"(SRT.RT_FILIAL = "+cFilQryAnt+" AND SRT.RT_MAT = "+cMatQryAnt+" AND "+;
							"SRT.RT_CC = "+cCCQryAnt+" AND SRT.RT_DATACAL BETWEEN "+cDtIQryAnt+" AND "+cDtFQryAnt+" )"
			cWhereSRT		:=	"( "+cWhereSRT+" OR (SRT.RT_FILIAL = "+cFilQryAtu+" AND SRT.RT_MAT = "+cMatQryAtu+" AND "+;
							"SRT.RT_CC = "+cCCQryAtu+" AND SRT.RT_DATACAL BETWEEN "+cDtIQryAtu+" AND "+cDtFQryAtu+" ) )"
		EndIf

		cWhereSRT		:= "%"+cWhereSRT+"%"
	Else
		If lItemClVl
			cWhere		:=	"(SRT.RT_FILIAL = "+cFilQryAnt+" AND SRT.RT_MAT = "+cMatQryAnt+" AND "+;
							"SRT.RT_CC = "+cCCQryAnt+" AND SRT.RT_ITEM = "+cItmQryAnt+" AND SRT.RT_CLVL = "+cClvQryAnt+" AND SRT.RT_DATACAL BETWEEN "+cDtIQryAnt+" AND "+cDtFQryAnt+" )"
			cWhere		:=	"( "+cWhere+" OR (SRT.RT_FILIAL = "+cFilQryAtu+" AND SRT.RT_MAT = "+cMatQryAtu+" AND "+;
							"SRT.RT_CC = "+cCCQryAtu+" AND SRT.RT_ITEM = "+cItmQryAtu+" AND SRT.RT_CLVL = "+cClvQryAtu+" AND SRT.RT_DATACAL BETWEEN "+cDtIQryAtu+" AND "+cDtFQryAtu+" ) )"
		Else
			cWhere		:=	"(SRT.RT_FILIAL = "+cFilQryAnt+" AND SRT.RT_MAT = "+cMatQryAnt+" AND "+;
							"SRT.RT_CC = "+cCCQryAnt+" AND SRT.RT_DATACAL BETWEEN "+cDtIQryAnt+" AND "+cDtFQryAnt+" )"
			cWhere		:=	"( "+cWhere+" OR (SRT.RT_FILIAL = "+cFilQryAtu+" AND SRT.RT_MAT = "+cMatQryAtu+" AND "+;
							"SRT.RT_CC = "+cCCQryAtu+" AND SRT.RT_DATACAL BETWEEN "+cDtIQryAtu+" AND "+cDtFQryAtu+" ) )"
		EndIf
	EndIf

	//FILTRA PELOS IDENTIFICADORES DE CALCULO DO RATEIO DE PROVISAO DE FERIAS OU 13 SALARIO
	//FERIAS: 960 - 961 - 962 - 963 - 964 - 965
	//13 SAL: 966 - 967 - 968 - 969 - 970
	If cTpRtProv == "RPF" //RPF - Rateio Provisao FÈrias
		cWhere		+= " AND RHT.RHT_VERBA IN ('"+aCodFol[960,1]+"','"+aCodFol[961,1]+"','"+aCodFol[962,1]+"','"+;
												  aCodFol[963,1]+"','"+aCodFol[964,1]+"','"+aCodFol[965,1]+"') "
		cWhere      += " AND RHT.RHT_SLDIN <> '1' " //N„o inclui saldo da provis„o rateada gerado no mes posterior
	ElseIf cTpRtProv == "RP13" //RP13 - Rateio Provisao 13 Salario
		cWhere		+= " AND RHT.RHT_VERBA IN ('"+aCodFol[966,1]+"','"+aCodFol[967,1]+"','"+aCodFol[968,1]+"','"+;
												  aCodFol[969,1]+"','"+aCodFol[970,1]+"','"+aCodFol[971,1]+"') "
	EndIf

	cWhere		:= "%"+cWhere+"%"

	If Empty(cTpRtProv)
		BeginSql alias cAliasSRT
			SELECT %exp:cCposQuery%
			FROM %table:SRT% SRT
			WHERE %exp:cWhere% AND SRT.%notDel%
			ORDER BY %exp:cOrdem%
		EndSql
		If cEmpQryAnt != cEmpAnt
			lQryAnt   := .T.
			cTabAnt   := "%" + RetFullName("SRT",cEmpQryAnt) + "%"
			BeginSql alias cAliasAnt
				SELECT %exp:cCposQuery%
				FROM %exp:cTabAnt% SRT
				WHERE %exp:cWhere% AND SRT.%notDel%
				ORDER BY %exp:cOrdem%
			EndSql
		EndIf
	Else
		BeginSql alias cAliasSRT
			SELECT %exp:cCposQuery%
			FROM %table:RHT% RHT
			WHERE %exp:cWhere% AND RHT.%notDel%
			ORDER BY %exp:cOrdem%
		EndSql
		If cEmpQryAnt != cEmpAnt
			lQryAnt   := .T.
			cTabAnt   := "%" + RetFullName("SRT",cEmpQryAnt) + "%"
			cOrdemSRT := If( lItemClVl, SqlOrder( SRT->( IndexKey(4) ) ), SqlOrder( SRT->( IndexKey(1) ) ))

			cOrdemSRT	:= "% "+cOrdemSRT+" %"

			cCposAux	+=	", R_E_C_N_O_ AS RECNO_"

			cCposAux	:=	"% "+cCposAux+" %"

			BeginSql alias cAliasAnt
				SELECT %exp:cCposAux%
				FROM %exp:cTabAnt% SRT
				WHERE %exp:cWhereSRT% AND SRT.%notDel%
				ORDER BY %exp:cOrdemSRT%
			EndSql
		EndIf
	Endif

	//AJUSTA A ESTRUTURA DOS CAMPOS
	For nReg := 1 To Len(aStruSRT)
		If (aStruSRT[nReg][2] <> "C")
			TcSetField(cAliasSRT,aStruSRT[nReg][1],aStruSRT[nReg][2],aStruSRT[nReg][3],aStruSRT[nReg][4])
		EndIf
	Next nReg

	If lQryAnt
		For nReg := 1 To Len(aStruAux)
			If (aStruAux[nReg][2] <> "C")
				TcSetField(cAliasAnt,aStruAux[nReg][1],aStruAux[nReg][2],aStruAux[nReg][3],aStruAux[nReg][4])
			EndIf
		Next nReg
	EndIf

	//	LIMPA OS ARRAYS DE PROVISAO
	If Type("aFerVenc") # "U"
		fLimpaArray(@aFerVenc, 0)
		fLimpaArray(@aFerProp, 0)
		If !lCalcula
			fLimpaArray(@aRecVenc, 0)
			fLimpaArray(@aRecProp, 0)
		Endif
	EndIf
	If Type("a13Salar") # "U"
		fLimpaArray(@a13Salar, 0)
		fLimpaArray(@a14Salar, 0)
		If !lCalcula
			fLimpaArray(@aRec13Sl, 0)
			fLimpaArray(@aRec14Sl, 0)
		Endif
	EndIf
	If Type("aPLRSalar") # "U"
		fLimpaArray( @aPLRSalar, 0 )
		If !lCalcula
			fLimpaArray( @aRecPLRSl, 0 )
		Endif
	EndIf

	//Verifica se est· configurado com S o MV_RATPROV e se existe a tabela RHQ.
	If lGeraPMes
		dbSelectArea("RHT")
		//Se n„o existir c·lculo, atualiza a vari·vel.
		If (cTBLXPROV)->PR_TIPMOVI != 6 .And. !dbSeek(SRA->RA_FILIAL + SRA->RA_MAT + (cTBLXPROV)->PR_CC)
			lInicRat := .T.
		EndIf
	EndIf


	dbSelectArea(cAliasSRT)
	//ENTRA NESTE BLOCO NA IMPRESSAO DO RELATORIO DE VALORES DO MES
	If !Empty(cTpRtProv)

			If cTpRtProv == 'RPF'
				While !(cAliasSRT)->(Eof())
					If (cAliasSRT)->RHT_TPPROV == '1' // FÈrias Vencidas
						If (cAliasSRT)->RHT_VERBA == aCodFol[960,1]
							aFerVenc[_NoMes,_Prov] := (cAliasSRT)->RHT_VALOR
							aFerVenc[_NoMes,_Avos] := 0
							aFerVenc[_NoMes,_SalV] := 0
						ElseIf (cAliasSRT)->RHT_VERBA == aCodFol[962,1]
							aFerVenc[_NoMes,_Adic] := (cAliasSRT)->RHT_VALOR
						ElseIf (cAliasSRT)->RHT_VERBA == aCodFol[961,1]
							aFerVenc[_NoMes,_1Ter] := (cAliasSRT)->RHT_VALOR
						ElseIf (cAliasSRT)->RHT_VERBA == aCodFol[963,1]
							aFerVenc[_NoMes,_INSS] := (cAliasSRT)->RHT_VALOR
						ElseIf (cAliasSRT)->RHT_VERBA == aCodFol[964,1]
							aFerVenc[_NoMes,_FGTS] := (cAliasSRT)->RHT_VALOR
						ElseIf (cAliasSRT)->RHT_VERBA == aCodFol[965,1]
							aFerVenc[_NoMes,_PIS] := (cAliasSRT)->RHT_VALOR
						EndIf
					Else
						If (cAliasSRT)->RHT_VERBA == aCodFol[960,1]
							aFerProp[_NoMes,_Prov] := (cAliasSRT)->RHT_VALOR
							aFerProp[_NoMes,_Avos] := 0
							aFerProp[_NoMes,_SalV] := 0
						ElseIf (cAliasSRT)->RHT_VERBA == aCodFol[962,1]
							aFerProp[_NoMes,_Adic] := (cAliasSRT)->RHT_VALOR
						ElseIf (cAliasSRT)->RHT_VERBA == aCodFol[961,1]
							aFerProp[_NoMes,_1Ter] := (cAliasSRT)->RHT_VALOR
						ElseIf (cAliasSRT)->RHT_VERBA == aCodFol[963,1]
							aFerProp[_NoMes,_INSS] := (cAliasSRT)->RHT_VALOR
						ElseIf (cAliasSRT)->RHT_VERBA == aCodFol[964,1]
							aFerProp[_NoMes,_FGTS] := (cAliasSRT)->RHT_VALOR
						ElseIf (cAliasSRT)->RHT_VERBA == aCodFol[965,1]
							aFerProp[_NoMes,_PIS] := (cAliasSRT)->RHT_VALOR
						EndIf
					Endif
					(cAliasSRT)->(dbSkip())
				EndDo
			Else
				While !(cAliasSRT)->(Eof())
					If (cAliasSRT)->RHT_VERBA == aCodFol[966,1]
						a13Salar[_NoMes,_Prov] := (cAliasSRT)->RHT_VALOR
						a13Salar[_NoMes,_Avos] := 0
						a13Salar[_NoMes,_SalV] := 0
					ElseIf (cAliasSRT)->RHT_VERBA == aCodFol[967,1]
						a13Salar[_NoMes,_Adic] := (cAliasSRT)->RHT_VALOR
					ElseIf (cAliasSRT)->RHT_VERBA == aCodFol[968,1]
						a13Salar[_NoMes,_1Par] := (cAliasSRT)->RHT_VALOR
					ElseIf (cAliasSRT)->RHT_VERBA == aCodFol[969,1]
						a13Salar[_NoMes,_INSS] := (cAliasSRT)->RHT_VALOR
					ElseIf (cAliasSRT)->RHT_VERBA == aCodFol[970,1]
						a13Salar[_NoMes,_FGTS] := (cAliasSRT)->RHT_VALOR
					ElseIf (cAliasSRT)->RHT_VERBA == aCodFol[971,1]
						a13Salar[_NoMes,_PIS] := (cAliasSRT)->RHT_VALOR
					EndIf
					(cAliasSRT)->(dbSkip())
				Enddo
			Endif
			// Totalizar o Saldo Anterior atravÈs de Query //
			If cTpRtProv == "RPF" //RPF - Rateio Provisao FÈrias
				
				// Busco perÌodo aquisitivo para buscar data que houve a Provis„o de FÈrias
				DbSelectArea("SRF")
				SRF->(DbSetOrder(1))
				If SRF->(DbSeek(SRA->RA_FILIAL+SRA->RA_MAT))
					While !EoF() .and. SRA->RA_FILIAL+SRA->RA_MAT == SRF->RF_FILIAL+SRF->RF_MAT
						If SRF->RF_STATUS == "1" //Ativo
							dBkpRef := SRF->RF_DATABAS
							Exit
						EndIf
						SRF->(DbSkip())
					EndDo

				EndIf

				dBkpRef		:= MonthSub( dBkpRef, 1 )
				cDtIniAnt	:= AnoMes(dBkpRef)+"01"
				cDtFimAnt	:= AnoMes(dBkpRef)+StrZero(f_Ultdia(dBkpRef),2)

				cWhere		:=	"RHT.RHT_FILIAL = "+cFilQryAtu+" AND RHT.RHT_MAT = "+cMatQryAtu
				cWhere		+= " AND RHT.RHT_DTCALC BETWEEN '" + cDtIniAnt + "' AND '" + cDtFimAnt + "'"
				
				If lItemClVl
					cWhere		+= " AND RHT.RHT_CC = '"+(cTBLXPROV)->PR_CCMVTO+ "' AND RHT.RHT_ITEM = '"+(cTBLXPROV)->PR_ITMMVTO+ "' AND RHT.RHT_CLVL = '"+(cTBLXPROV)->PR_CLVMVTO+ "' AND RHT.RHT_TPPROV IN ("+ cTpProvMes+ " )"
				Else                                                                  '
					cWhere		+= " AND RHT.RHT_CC = '"+(cTBLXPROV)->PR_CCMVTO+ "' AND RHT.RHT_TPPROV IN ("+ cTpProvMes+ " )"
				EndIf
				cWhere		+= " AND RHT.RHT_VERBA IN ('"+aCodFol[960,1]+"','"+aCodFol[961,1]+"','"+aCodFol[962,1]+"','"+aCodFol[963,1]+"','"+aCodFol[964,1]+"','"+aCodFol[965,1]+"','"+;
															aCodFol[233,1]+"','"+aCodFol[234,1]+"','"+aCodFol[235,1]+"','"+aCodFol[258,1]+"','"+aCodFol[259,1]+"','"+aCodFol[418,1]+"','"+;
															aCodFol[239,1]+"','"+aCodFol[240,1]+"','"+aCodFol[241,1]+"','"+aCodFol[260,1]+"','"+aCodFol[261,1]+"','"+aCodFol[419,1]+"','"+;
															aCodFol[262,1]+"','"+aCodFol[263,1]+"','"+aCodFol[264,1]+"','"+aCodFol[265,1]+"','"+aCodFol[266,1]+"','"+aCodFol[420,1]+"') "
				cWhere		+= " AND RHT.RHT_DTBASE IS NOT NULL "

				cWhere		:= "%"+cWhere+"%"

				BeginSql alias cAliasTMP
					SELECT RHT.RHT_DTBASE
					FROM %table:RHT% RHT
					WHERE %exp:cWhere% AND RHT.%notDel%
					GROUP BY RHT.RHT_DTBASE
				EndSql

				While (cAliasTMP)->( !Eof() )
					If !Empty((cAliasTMP)->RHT_DTBASE)
						cIniDtBase	:= (cAliasTMP)->RHT_DTBASE
						cQryDtBase	:= "'" + cIniDtBase + "'"
						nYears		:= DateDiffYear( sToD((cAliasTMP)->RHT_DTBASE), dDataRef  )
						nYears		:= If(nYears>0, nYears, 1)
					EndIf
					(cAliasTMP)->( dbSkip() )
				EndDo
				(cAliasTMP)->( dbCloseArea() )

				If Empty(cIniDtBase)

					cWhere		:=	"RHT.RHT_FILIAL = "+cFilQryAtu+" AND RHT.RHT_MAT = "+cMatQryAtu
					cWhere 		+= " AND RHT.RHT_DTCALC = '" + dTos(dDataRef) + "'"

					If lItemClVl
						cWhere		+= " AND RHT.RHT_CC = '"+(cTBLXPROV)->PR_CCMVTO+ "' AND RHT.RHT_ITEM = '"+(cTBLXPROV)->PR_ITMMVTO+ "' AND RHT.RHT_CLVL = '"+(cTBLXPROV)->PR_CLVMVTO+ "' AND RHT.RHT_TPPROV IN ("+ cTpProvMes+ " )"
					Else                                                                  '
						cWhere		+= " AND RHT.RHT_CC = '"+(cTBLXPROV)->PR_CCMVTO+ "' AND RHT.RHT_TPPROV IN ("+ cTpProvMes+ " )"
					EndIf
					cWhere		+= " AND RHT.RHT_VERBA IN ('"+aCodFol[960,1]+"','"+aCodFol[961,1]+"','"+aCodFol[962,1]+"','"+aCodFol[963,1]+"','"+aCodFol[964,1]+"','"+aCodFol[965,1]+"','"+;
																aCodFol[233,1]+"','"+aCodFol[234,1]+"','"+aCodFol[235,1]+"','"+aCodFol[258,1]+"','"+aCodFol[259,1]+"','"+aCodFol[418,1]+"','"+;
																aCodFol[239,1]+"','"+aCodFol[240,1]+"','"+aCodFol[241,1]+"','"+aCodFol[260,1]+"','"+aCodFol[261,1]+"','"+aCodFol[419,1]+"','"+;
																aCodFol[262,1]+"','"+aCodFol[263,1]+"','"+aCodFol[264,1]+"','"+aCodFol[265,1]+"','"+aCodFol[266,1]+"','"+aCodFol[420,1]+"') "
					cWhere		+= " AND RHT.RHT_DTBASE IS NOT NULL "

					cWhere		:= "%"+cWhere+"%"

					BeginSql alias cAliasTMP
						SELECT RHT.RHT_DTBASE
						FROM %table:RHT% RHT
						WHERE %exp:cWhere% AND RHT.%notDel%
						GROUP BY RHT.RHT_DTBASE
					EndSql

					While (cAliasTMP)->( !Eof() )
						If !Empty((cAliasTMP)->RHT_DTBASE)
							cIniDtBase	:= (cAliasTMP)->RHT_DTBASE
							If AnoMes( sToD(cIniDtBase) ) > AnoMes(dDataRef)
								cIniDtBase 	:= dToS( YearSub( sToD(cIniDtBase), 1 ) )
								lAntecip	:= .T.
							EndIf
							cQryDtBase	:= "'" + cIniDtBase + "'"
							nYears		:= DateDiffYear( sToD((cAliasTMP)->RHT_DTBASE), dDataRef  )
							nYears		:= If(nYears>0, nYears, 1)
						EndIf
						(cAliasTMP)->( dbSkip() )
					EndDo
					(cAliasTMP)->( dbCloseArea() )
				EndIf

				cWhere		:=	"RHT.RHT_FILIAL = "+cFilQryAtu+" AND RHT.RHT_MAT = "+cMatQryAtu
				cWhere		+= " AND RHT.RHT_DTCALC BETWEEN " + cQryDtBase + " AND " + cDtFQryAtu + " "

				If lItemClVl
					cWhere		+= " AND RHT.RHT_CC = '"+(cTBLXPROV)->PR_CCMVTO+ "' AND RHT.RHT_ITEM = '"+(cTBLXPROV)->PR_ITMMVTO+ "' AND RHT.RHT_CLVL = '"+(cTBLXPROV)->PR_CLVMVTO+ "' AND RHT.RHT_TPPROV IN ("+ cTpProvMes+ " )"
				Else
					cWhere		+= " AND RHT.RHT_CC = '"+(cTBLXPROV)->PR_CCMVTO+ "' AND RHT.RHT_TPPROV IN ("+ cTpProvMes+ " )"
				EndIf
				cWhere		+= " AND RHT.RHT_VERBA IN ('"+aCodFol[960,1]+"','"+aCodFol[961,1]+"','"+aCodFol[962,1]+"','"+aCodFol[963,1]+"','"+aCodFol[964,1]+"','"+aCodFol[965,1]+"','"+;
															aCodFol[233,1]+"','"+aCodFol[234,1]+"','"+aCodFol[235,1]+"','"+aCodFol[258,1]+"','"+aCodFol[259,1]+"','"+aCodFol[418,1]+"','"+;
															aCodFol[239,1]+"','"+aCodFol[240,1]+"','"+aCodFol[241,1]+"','"+aCodFol[260,1]+"','"+aCodFol[261,1]+"','"+aCodFol[419,1]+"','"+;
															aCodFol[262,1]+"','"+aCodFol[263,1]+"','"+aCodFol[264,1]+"','"+aCodFol[265,1]+"','"+aCodFol[266,1]+"','"+aCodFol[420,1]+"') "
				cWhere      += " AND RHT.RHT_SLDIN <> '1' "
			ElseIf cTpRtProv == "RP13" //RP13 - Rateio Provisao 13 Salario

				cDtIQryAtu	:= StrZero(Ano( dDataRef  ),4)+"0101"
				If lItemClVl
					cWhere		:=	"(RHT.RHT_FILIAL = "+cFilQryAtu+" AND RHT.RHT_MAT = "+cMatQryAtu+;
									" AND RHT.RHT_DTCALC BETWEEN " +  cDtIQryAtu + " AND " + cDtFQryAtu + " ) "
					cWhere		+= " AND RHT.RHT_CC = '"+(cTBLXPROV)->PR_CCMVTO+ "' AND RHT.RHT_ITEM = '"+(cTBLXPROV)->PR_ITMMVTO+ "' AND RHT.RHT_CLVL = '"+(cTBLXPROV)->PR_CLVMVTO+ "' AND RHT.RHT_TPPROV IN ("+ cTpProvMes+ " )"
				Else
					cWhere		:=	"(RHT.RHT_FILIAL = "+cFilQryAtu+" AND RHT.RHT_MAT = "+cMatQryAtu+;
									" AND RHT.RHT_DTCALC BETWEEN " +  cDtIQryAtu + " AND " + cDtFQryAtu + " ) "
					cWhere		+= " AND RHT.RHT_CC = '"+(cTBLXPROV)->PR_CCMVTO+ "' AND RHT.RHT_TPPROV IN ("+ cTpProvMes+ " )"
				EndIf

				cWhere		+= " AND RHT.RHT_VERBA IN ('"+aCodFol[966,1]+"','"+aCodFol[967,1]+"','"+aCodFol[968,1]+"','"+aCodFol[969,1]+"','"+aCodFol[970,1]+"','"+aCodFol[971,1]+"','"+;
															aCodFol[332,1]+"','"+aCodFol[333,1]+"','"+aCodFol[334,1]+"','"+aCodFol[335,1]+"','"+aCodFol[336,1]+"','"+aCodFol[423,1]+"','"+;
															aCodFol[270,1]+"','"+aCodFol[271,1]+"','"+aCodFol[272,1]+"','"+aCodFol[273,1]+"','"+aCodFol[424,1]+"','"+;
															aCodFol[274,1]+"','"+aCodFol[275,1]+"','"+aCodFol[276,1]+"','"+aCodFol[277,1]+"','"+aCodFol[425,1]+"') "
			EndIf
			cWhere		:= "%"+cWhere+"%"

			BeginSql alias cAliasRHT
				SELECT RHT.RHT_DTCALC, RHT.RHT_VERBA, RHT.RHT_TPPROV, SUM(RHT_VALOR) RHT_VALOR,RHT_DTBASE,RHT_DFERPR
				FROM %table:RHT% RHT
				WHERE %exp:cWhere% AND RHT.%notDel%
				GROUP BY RHT.RHT_DTCALC, RHT.RHT_VERBA, RHT.RHT_TPPROV,RHT_DTBASE,RHT_DFERPR
			EndSql

			If cTpRtProv == 'RPF'
				While  (cAliasRHT)->( !Eof() )

					If (cAliasRHT)->RHT_TPPROV == '1'// FÈrias Vencidas

						// Ignorar os valores do Mes corrente //
						nRHTValor 	:= (cAliasRHT)->RHT_VALOR
						nRHTAtuVlr 	:= nRHTValor
						nNovoVal	:= 0

						If AnoMes( STOD((cAliasRHT)->RHT_DTCALC) ) == AnoMes(dDataRef)
							nRHTValor := 0
						EndIf

						//⁄ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒø
						//≥Quando h· algum Id de baixa no perÌodo, tal valor deve ser     ≥
						//≥Abatido do saldo anterior, para que o saldo anterior fique ok  ≥
						//¿ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒŸ
						If (cAliasRHT)->RHT_VERBA $ cCodBx
							If AnoMes( STOD((cAliasRHT)->RHT_DTCALC) ) <> AnoMes(dDataRef)
								nNovoVal :=  nRHTAtuVlr * (-1)
								nRHTAtuVlr := 0
								nRHTValor  := 0
							Endif
						Endif

						If (cAliasRHT)->RHT_VERBA == aCodFol[960,1] .and. (!(lProvResc .And. (cTBLXPROV)->PR_TIPMOVI == _demitido) .Or. AnoMes( STOD((cAliasRHT)->RHT_DTCALC) ) <> AnoMes(dDataRef))//Prov. MÍs FÈrias
							aFerVenc[_Anter,_Prov] += nRHTValor
							aFerVenc[_Anter,_Avos] := 0
							aFerVenc[_Anter,_SalV] := 0

							// Anterior + Atual
							aFerVenc[_Atual,_Prov] +=  nRHTAtuVlr
							aFerVenc[_Anter,_Avos] := 0
							aFerVenc[_Anter,_SalV] := 0

						ElseIf (cAliasRHT)->RHT_VERBA == aCodFol[962,1] .and. (!(lProvResc .And. (cTBLXPROV)->PR_TIPMOVI == _demitido) .Or. AnoMes( STOD((cAliasRHT)->RHT_DTCALC) ) <> AnoMes(dDataRef))//Prov. MÍs Adicional de FÈrias
							aFerVenc[_Anter,_Adic] += nRHTValor
							aFerVenc[_Atual,_Adic] +=  nRHTAtuVlr
						ElseIf (cAliasRHT)->RHT_VERBA == aCodFol[961,1] .and. (!(lProvResc .And. (cTBLXPROV)->PR_TIPMOVI == _demitido) .Or. AnoMes( STOD((cAliasRHT)->RHT_DTCALC) ) <> AnoMes(dDataRef))//Prov. MÍs 1/3 de FÈrias
							aFerVenc[_Anter,_1Ter] += nRHTValor
							aFerVenc[_Atual,_1Ter] +=  nRHTAtuVlr
						ElseIf (cAliasRHT)->RHT_VERBA == aCodFol[963,1] .and. (!(lProvResc .And. (cTBLXPROV)->PR_TIPMOVI == _demitido) .Or. AnoMes( STOD((cAliasRHT)->RHT_DTCALC) ) <> AnoMes(dDataRef))//Prov. MÍs INSS de FÈrias
							aFerVenc[_Anter,_INSS] += nRHTValor
							aFerVenc[_Atual,_INSS] +=  nRHTAtuVlr
						ElseIf (cAliasRHT)->RHT_VERBA == aCodFol[964,1] .and. (!(lProvResc .And. (cTBLXPROV)->PR_TIPMOVI == _demitido) .Or. AnoMes( STOD((cAliasRHT)->RHT_DTCALC) ) <> AnoMes(dDataRef))//Prov. MÍs FGTS de FÈrias
							aFerVenc[_Anter,_FGTS] += nRHTValor
							aFerVenc[_Atual,_FGTS] +=  nRHTAtuVlr
						ElseIf (cAliasRHT)->RHT_VERBA == aCodFol[965,1] .and. (!(lProvResc .And. (cTBLXPROV)->PR_TIPMOVI == _demitido) .Or. AnoMes( STOD((cAliasRHT)->RHT_DTCALC) ) <> AnoMes(dDataRef))//Prov. MÍs PIS de FÈrias
							aFerVenc[_Anter,_PIS] += nRHTValor
							aFerVenc[_Atual,_PIS] +=  nRHTAtuVlr
						ElseIf (cAliasRHT)->RHT_VERBA == aCodFol[233,1]//Baixa Provisao Ferias
							aFerVenc[_BxFer,_Prov] += nRHTAtuVlr
							aFerVenc[_BxTot,_Prov] += nRHTAtuVlr
							aFerVenc[_Atual,_Prov] -= IIf(nNovoVal < 0 ,nNovoVal*(-1),nRHTAtuVlr)
							aFerVenc[_Anter,_Prov] += nNovoVal
						ElseIf (cAliasRHT)->RHT_VERBA == aCodFol[258,1]//Baixa Adicional Provisao de Ferias
							aFerVenc[_BxFer,_Adic] += nRHTAtuVlr
							aFerVenc[_BxTot,_Adic] += nRHTAtuVlr
							aFerVenc[_Atual,_Adic] -= IIf(nNovoVal < 0 ,nNovoVal*(-1),nRHTAtuVlr)
							aFerVenc[_Anter,_Adic] += nNovoVal
						ElseIf (cAliasRHT)->RHT_VERBA == aCodFol[259,1]//Baixa Um Terco Provisao de Ferias
							aFerVenc[_BxFer,_1Ter] += nRHTAtuVlr
							aFerVenc[_BxTot,_1Ter] += nRHTAtuVlr
							aFerVenc[_Atual,_1Ter] -= IIf(nNovoVal < 0 ,nNovoVal*(-1),nRHTAtuVlr)
							aFerVenc[_Anter,_1Ter] += nNovoVal
						ElseIf (cAliasRHT)->RHT_VERBA == aCodFol[234,1]//Baixa Inss Provisao Ferias
							aFerVenc[_BxFer,_INSS] += nRHTAtuVlr
							aFerVenc[_BxTot,_INSS] += nRHTAtuVlr
							aFerVenc[_Atual,_INSS] -= IIf(nNovoVal < 0 ,nNovoVal*(-1),nRHTAtuVlr)
							aFerVenc[_Anter,_INSS] += nNovoVal
						ElseIf (cAliasRHT)->RHT_VERBA == aCodFol[235,1]//Baixa Fgts Provisao Ferias
							aFerVenc[_BxFer,_FGTS] += nRHTAtuVlr
							aFerVenc[_BxTot,_FGTS] += nRHTAtuVlr
							aFerVenc[_Atual,_FGTS] -= IIf(nNovoVal < 0 ,nNovoVal*(-1),nRHTAtuVlr)
							aFerVenc[_Anter,_FGTS] += nNovoVal
						ElseIf (cAliasRHT)->RHT_VERBA == aCodFol[418,1]//Baixa PIS Provisao Ferias
							aFerVenc[_BxFer,_PIS] += nRHTAtuVlr
							aFerVenc[_BxTot,_PIS] += nRHTAtuVlr
							aFerVenc[_Atual,_PIS] -= IIf(nNovoVal < 0 ,nNovoVal*(-1),nRHTAtuVlr)
							aFerVenc[_Anter,_PIS] += nNovoVal
						ElseIf (cAliasRHT)->RHT_VERBA == aCodFol[239,1]//Baixa Provisao Ferias Transferidos
							aFerVenc[_BxTrf,_Prov] += nRHTAtuVlr
							aFerVenc[_BxTot,_Prov] += nRHTAtuVlr
							aFerVenc[_Atual,_Prov] -= IIf(nNovoVal < 0 ,nNovoVal*(-1),nRHTAtuVlr)
							aFerVenc[_Anter,_Prov] += nNovoVal
						ElseIf (cAliasRHT)->RHT_VERBA == aCodFol[260,1]//Baixa Adicional Provisao de Ferias Transferidos
							aFerVenc[_BxTrf,_Adic] += nRHTAtuVlr
							aFerVenc[_BxTot,_Adic] += nRHTAtuVlr
							aFerVenc[_Atual,_Adic] -= IIf(nNovoVal < 0 ,nNovoVal*(-1),nRHTAtuVlr)
							aFerVenc[_Anter,_Adic] += nNovoVal
						ElseIf (cAliasRHT)->RHT_VERBA == aCodFol[261,1]//Baixa Um Terco Provisao de Ferias Transferidos
							aFerVenc[_BxTrf,_1Ter] += nRHTAtuVlr
							aFerVenc[_BxTot,_1Ter] += nRHTAtuVlr
							aFerVenc[_Atual,_1Ter] -= IIf(nNovoVal < 0 ,nNovoVal*(-1),nRHTAtuVlr)
							aFerVenc[_Anter,_1Ter] += nNovoVal
						ElseIf (cAliasRHT)->RHT_VERBA == aCodFol[240,1]//Baixa Inss Provisao Ferias Transferidos
							aFerVenc[_BxTrf,_INSS] += nRHTAtuVlr
							aFerVenc[_BxTot,_INSS] += nRHTAtuVlr
							aFerVenc[_Atual,_INSS] -= IIf(nNovoVal < 0 ,nNovoVal*(-1),nRHTAtuVlr)
							aFerVenc[_Anter,_INSS] += nNovoVal
						ElseIf (cAliasRHT)->RHT_VERBA == aCodFol[241,1]//Baixa Fgts Provisao Ferias Transferidos
							aFerVenc[_BxTrf,_FGTS] += nRHTAtuVlr
							aFerVenc[_BxTot,_FGTS] += nRHTAtuVlr
							aFerVenc[_Atual,_FGTS] -= IIf(nNovoVal < 0 ,nNovoVal*(-1),nRHTAtuVlr)
							aFerVenc[_Anter,_FGTS] += nNovoVal
						ElseIf (cAliasRHT)->RHT_VERBA == aCodFol[419,1]//Baixa PIS Provisao Ferias Transferidos
							aFerVenc[_BxTrf,_PIS] += nRHTAtuVlr
							aFerVenc[_BxTot,_PIS] += nRHTAtuVlr
							aFerVenc[_Atual,_PIS] -= IIf(nNovoVal < 0 ,nNovoVal*(-1),nRHTAtuVlr)
							aFerVenc[_Anter,_PIS] += nNovoVal
						ElseIf (cAliasRHT)->RHT_VERBA == aCodFol[262,1]//Baixa Provisao de Ferias Rescis„o
							aFerVenc[_BxRes,_Prov] += nRHTAtuVlr
							aFerVenc[_BxTot,_Prov] += nRHTAtuVlr
						ElseIf (cAliasRHT)->RHT_VERBA == aCodFol[263,1]//Baixa Adicional Provisao de Ferias Rescis„o
							aFerVenc[_BxRes,_Adic] += nRHTAtuVlr
							aFerVenc[_BxTot,_Adic] += nRHTAtuVlr
						ElseIf (cAliasRHT)->RHT_VERBA == aCodFol[264,1]//Baixa 1/3 provis„o de Ferias Rescis„o
							aFerVenc[_BxRes,_1Ter] += nRHTAtuVlr
							aFerVenc[_BxTot,_1Ter] += nRHTAtuVlr
						ElseIf (cAliasRHT)->RHT_VERBA == aCodFol[265,1]//Baixa INSS provis„o de Ferias Rescis„o
							aFerVenc[_BxRes,_INSS] += nRHTAtuVlr
							aFerVenc[_BxTot,_INSS] += nRHTAtuVlr
						ElseIf (cAliasRHT)->RHT_VERBA == aCodFol[266,1]//Baixa FGTS provis„o de Ferias Rescis„o
							aFerVenc[_BxRes,_FGTS] += nRHTAtuVlr
							aFerVenc[_BxTot,_FGTS] += nRHTAtuVlr
						ElseIf (cAliasRHT)->RHT_VERBA == aCodFol[420,1]//Baixa PIS provis„o de Ferias Rescis„o
							aFerVenc[_BxRes,_PIS] += nRHTAtuVlr
							aFerVenc[_BxTot,_PIS] += nRHTAtuVlr
						EndIf
					Else

						// Tratar as ferias a vencer apenas no intervalo de datas do periodo aquisitivo com a data de provisao selecionada //
						// Considerando 3 periodos vencidos - Para Provisao a virada ocorre no 11o. Mes =
						If !Empty(cIniDtBase)
							If nYears <= 0
								dPerAqui 	:= STOD(cIniDtBase)
							EndIf
							d1NextPer := MonthSub( YearSum( STOD(cIniDtBase), 1 ),1)-1 // Proximo PerÌodo de FÈrias
						EndIf

						// Ocorrem baixas de fÈrias
						lBxMesRat := .F.
						If AnoMes( dDataRef ) > AnoMes( d1NextPer )
							lBxMesRat := .T.
						EndIf

						// Os dias pertencem ao 2o. perÌodo ou superior
						If dDataRef >  d1NextPer
							dPerAqui 	:= YearSum( dPerAqui , 1 )
							d1NextPer := YearSum( d1NextPer , 1 ) // Proximo PerÌodo de FÈrias

							// Ocorrem baixas de fÈrias
							If AnoMes( dDataRef ) == AnoMes( d1NextPer )
								lBxMesRat := .T.
							EndIf

							// Os dias pertencem ao 3o. perÌodo ou superior
							If dDataRef >  d1NextPer
								dPerAqui 	:= YearSum( dPerAqui , 1 )
								d1NextPer := YearSum( d1NextPer , 1 ) // Proximo PerÌodo de FÈrias
							EndIf

						EndIf

						nNovoVal := 0
						nRHTValor := 0

						// Ignorar os valores do Mes corrente //
						nRHTValor := (cAliasRHT)->RHT_VALOR
						nRHTAtuVlr := nRHTValor

						If AnoMes( STOD((cAliasRHT)->RHT_DTCALC) ) == AnoMes(dDataRef)
							nRHTValor := 0
						EndIf
						//⁄ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒø
						//≥Quando h· algum Id de baixa no perÌodo, tal valor deve ser     ≥
						//≥Abatido do saldo anterior, para que o saldo anterior fique ok  ≥
						//¿ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒŸ
						If (cAliasRHT)->RHT_VERBA $ cCodBx
							If AnoMes( STOD((cAliasRHT)->RHT_DTCALC) ) <> AnoMes(dDataRef)
								nNovoVal :=  nRHTAtuVlr * (-1)
								nRHTAtuVlr := 0
								nRHTValor  := 0
							Endif
						Endif

						//⁄ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒø
						//≥Quando o funcion·rio foi admitido apÛs o dia 15 de cada mes    ≥
						//≥Os dias proporcionais passam a ser do prÛximo perÌodo          ≥
						//≥Caso os valores abaixo n„o sejam zerados, a impress„o          ≥
						//≥Dos dias proporcionais ficar· incorreta quando o funcion·rio   ≥
						//≥Possui baixa de fÈrias.                                        ≥
						//¿ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒŸ

						If sTod(cIniDtBase) <> sTod((cAliasRHT)->RHT_DTBASE) .And. !Empty((cAliasRHT)->RHT_DTBASE) .And. (cAliasRHT)->RHT_DFERPR == 0 .And. !(lAntecip .And. (cAliasRHT)->RHT_VALOR < 0)
							nRHTAtuVlr := 0
							nRHTValor  := 0
						EndIf

						If (cAliasRHT)->RHT_VERBA == aCodFol[960,1] .and. (!(lProvResc .And. (cTBLXPROV)->PR_TIPMOVI == _demitido) .Or. AnoMes( STOD((cAliasRHT)->RHT_DTCALC) ) <> AnoMes(dDataRef))//Prov. MÍs FÈrias
							aFerProp[_Anter,_Prov] += nRHTValor
							aFerProp[_Anter,_Avos] := 0
							aFerProp[_Anter,_SalV] := 0

							aFerProp[_Atual,_Prov] += nRHTAtuVlr
							aFerProp[_Atual,_Avos] := 0
							aFerProp[_Atual,_SalV] := 0

						ElseIf (cAliasRHT)->RHT_VERBA == aCodFol[962,1] .and. (!(lProvResc .And. (cTBLXPROV)->PR_TIPMOVI == _demitido) .Or. AnoMes( STOD((cAliasRHT)->RHT_DTCALC) ) <> AnoMes(dDataRef))//Prov. MÍs Adicional de FÈrias
							aFerProp[_Anter,_Adic] += nRHTValor
							aFerProp[_Atual,_Adic] += nRHTAtuVlr
						ElseIf (cAliasRHT)->RHT_VERBA == aCodFol[961,1] .and. (!(lProvResc .And. (cTBLXPROV)->PR_TIPMOVI == _demitido) .Or. AnoMes( STOD((cAliasRHT)->RHT_DTCALC) ) <> AnoMes(dDataRef))//Prov. MÍs 1/3 de FÈrias
							aFerProp[_Anter,_1Ter] += nRHTValor
							aFerProp[_Atual,_1Ter] += nRHTAtuVlr
						ElseIf (cAliasRHT)->RHT_VERBA == aCodFol[963,1] .and. (!(lProvResc .And. (cTBLXPROV)->PR_TIPMOVI == _demitido) .Or. AnoMes( STOD((cAliasRHT)->RHT_DTCALC) ) <> AnoMes(dDataRef))//Prov. MÍs INSS de FÈrias
							aFerProp[_Anter,_INSS] += nRHTValor
							aFerProp[_Atual,_INSS] += nRHTAtuVlr
						ElseIf (cAliasRHT)->RHT_VERBA == aCodFol[964,1] .and. (!(lProvResc .And. (cTBLXPROV)->PR_TIPMOVI == _demitido) .Or. AnoMes( STOD((cAliasRHT)->RHT_DTCALC) ) <> AnoMes(dDataRef))//Prov. MÍs FGTS de FÈrias
							aFerProp[_Anter,_FGTS] += nRHTValor
							aFerProp[_Atual,_FGTS] += nRHTAtuVlr
						ElseIf (cAliasRHT)->RHT_VERBA == aCodFol[965,1] .and. (!(lProvResc .And. (cTBLXPROV)->PR_TIPMOVI == _demitido) .Or. AnoMes( STOD((cAliasRHT)->RHT_DTCALC) ) <> AnoMes(dDataRef))//Prov. MÍs PIS de FÈrias
							aFerProp[_Anter,_PIS] += nRHTValor
							aFerProp[_Atual,_PIS] += nRHTAtuVlr
						ElseIf (cAliasRHT)->RHT_VERBA == aCodFol[233,1]//Baixa Provisao Ferias
							aFerProp[_BxFer,_Prov] += nRHTAtuVlr
							aFerProp[_BxTot,_Prov] += nRHTAtuVlr
							aFerProp[_Atual,_Prov] -= IIf(nNovoVal < 0 ,nNovoVal*(-1),nRHTAtuVlr)
							aFerProp[_Anter,_Prov] += nNovoVal
						ElseIf (cAliasRHT)->RHT_VERBA == aCodFol[258,1]//Baixa Adicional Provisao de Ferias
							aFerProp[_BxFer,_Adic] += nRHTAtuVlr
							aFerProp[_BxTot,_Adic] += nRHTAtuVlr
							aFerProp[_Atual,_Adic] -= IIf(nNovoVal < 0 ,nNovoVal*(-1),nRHTAtuVlr)
							aFerProp[_Anter,_Adic] += nNovoVal
						ElseIf (cAliasRHT)->RHT_VERBA == aCodFol[259,1]//Baixa Um Terco Provisao de Ferias
							aFerProp[_BxFer,_1Ter] += nRHTAtuVlr
							aFerProp[_BxTot,_1Ter] += nRHTAtuVlr
							aFerProp[_Atual,_1Ter] -= IIf(nNovoVal < 0 ,nNovoVal*(-1),nRHTAtuVlr)
							aFerProp[_Anter,_1Ter] += nNovoVal
						ElseIf (cAliasRHT)->RHT_VERBA == aCodFol[234,1]//Baixa Inss Provisao Ferias
							aFerProp[_BxFer,_INSS] += nRHTAtuVlr
							aFerProp[_BxTot,_INSS] += nRHTAtuVlr
							aFerProp[_Atual,_INSS] -= IIf(nNovoVal < 0 ,nNovoVal*(-1),nRHTAtuVlr)
							aFerProp[_Anter,_INSS] += nNovoVal
						ElseIf (cAliasRHT)->RHT_VERBA == aCodFol[235,1]//Baixa Fgts Provisao Ferias
							aFerProp[_BxFer,_FGTS] += nRHTAtuVlr
							aFerProp[_BxTot,_FGTS] += nRHTAtuVlr
							aFerProp[_Atual,_FGTS] -= IIf(nNovoVal < 0 ,nNovoVal*(-1),nRHTAtuVlr)
							aFerProp[_Anter,_FGTS] += nNovoVal
						ElseIf (cAliasRHT)->RHT_VERBA == aCodFol[418,1]//Baixa PIS Provisao Ferias
							aFerProp[_BxFer,_PIS] += nRHTAtuVlr
							aFerProp[_BxTot,_PIS] += nRHTAtuVlr
							aFerProp[_Atual,_PIS] -= IIf(nNovoVal < 0 ,nNovoVal*(-1),nRHTAtuVlr)
							aFerProp[_Anter,_PIS] += nNovoVal
						ElseIf (cAliasRHT)->RHT_VERBA == aCodFol[239,1]//Baixa Provisao Ferias Transferidos
							aFerProp[_BxTrf,_Prov] += nRHTAtuVlr
							aFerProp[_BxTot,_Prov] += nRHTAtuVlr
							aFerProp[_Atual,_Prov] -= IIf(nNovoVal < 0 ,nNovoVal*(-1),nRHTAtuVlr)
							aFerProp[_Anter,_Prov] += nNovoVal
						ElseIf (cAliasRHT)->RHT_VERBA == aCodFol[260,1]//Baixa Adicional Provisao de Ferias Transferidos
							aFerProp[_BxTrf,_Adic] += nRHTAtuVlr
							aFerProp[_BxTot,_Adic] += nRHTAtuVlr
							aFerProp[_Atual,_Adic] -= IIf(nNovoVal < 0 ,nNovoVal*(-1),nRHTAtuVlr)
							aFerProp[_Anter,_Adic] += nNovoVal
						ElseIf (cAliasRHT)->RHT_VERBA == aCodFol[261,1]//Baixa Um Terco Provisao de Ferias Transferidos
							aFerProp[_BxTrf,_1Ter] += nRHTAtuVlr
							aFerProp[_BxTot,_1Ter] += nRHTAtuVlr
							aFerProp[_Atual,_1Ter] -= IIf(nNovoVal < 0 ,nNovoVal*(-1),nRHTAtuVlr)
							aFerProp[_Anter,_1Ter] += nNovoVal
						ElseIf (cAliasRHT)->RHT_VERBA == aCodFol[240,1]//Baixa Inss Provisao Ferias Transferidos
							aFerProp[_BxTrf,_INSS] += nRHTAtuVlr
							aFerProp[_BxTot,_INSS] += nRHTAtuVlr
							aFerProp[_Atual,_INSS] -= IIf(nNovoVal < 0 ,nNovoVal*(-1),nRHTAtuVlr)
							aFerProp[_Anter,_INSS] += nNovoVal
						ElseIf (cAliasRHT)->RHT_VERBA == aCodFol[241,1]//Baixa Fgts Provisao Ferias Transferidos
							aFerProp[_BxTrf,_FGTS] += nRHTAtuVlr
							aFerProp[_BxTot,_FGTS] += nRHTAtuVlr
							aFerProp[_Atual,_FGTS] -= IIf(nNovoVal < 0 ,nNovoVal*(-1),nRHTAtuVlr)
							aFerProp[_Anter,_FGTS] += nNovoVal
						ElseIf (cAliasRHT)->RHT_VERBA == aCodFol[419,1]//Baixa PIS Provisao Ferias Transferidos
							aFerProp[_BxTrf,_PIS] += nRHTAtuVlr
							aFerProp[_BxTot,_PIS] += nRHTAtuVlr
							aFerProp[_Atual,_PIS] -= IIf(nNovoVal < 0 ,nNovoVal*(-1),nRHTAtuVlr)
							aFerProp[_Anter,_PIS] += nNovoVal
						ElseIf (cAliasRHT)->RHT_VERBA == aCodFol[262,1]//Baixa Provisao de Ferias Rescis„o
							aFerProp[_BxRes,_Prov] += nRHTAtuVlr
							aFerProp[_BxTot,_Prov] += nRHTAtuVlr
						ElseIf (cAliasRHT)->RHT_VERBA == aCodFol[263,1]//Baixa Adicional Provisao de Ferias Rescis„o
							aFerProp[_BxRes,_Adic] += nRHTAtuVlr
							aFerProp[_BxTot,_Adic] += nRHTAtuVlr
						ElseIf (cAliasRHT)->RHT_VERBA == aCodFol[264,1]//Baixa 1/3 provis„o de Ferias Rescis„o
							aFerProp[_BxRes,_1Ter] += nRHTAtuVlr
							aFerProp[_BxTot,_1Ter] += nRHTAtuVlr
						ElseIf (cAliasRHT)->RHT_VERBA == aCodFol[265,1]//Baixa INSS provis„o de Ferias Rescis„o
							aFerProp[_BxRes,_INSS] += nRHTAtuVlr
							aFerProp[_BxTot,_INSS] += nRHTAtuVlr
						ElseIf (cAliasRHT)->RHT_VERBA == aCodFol[266,1]//Baixa FGTS provis„o de Ferias Rescis„o
							aFerProp[_BxRes,_FGTS] += nRHTAtuVlr
							aFerProp[_BxTot,_FGTS] += nRHTAtuVlr
						ElseIf (cAliasRHT)->RHT_VERBA == aCodFol[420,1]//Baixa PIS provis„o de Ferias Rescis„o
							aFerProp[_BxRes,_PIS] += nRHTAtuVlr
							aFerProp[_BxTot,_PIS] += nRHTAtuVlr
						EndIf

						// Se ocorrer no mes da baixa de ferias
						If lBxMesRat .and. dDataRef <= YearSub(d1NextPer,1)
							aFerProp[_Anter,_Prov]		:= aFerProp[_NoMes,_Prov]*-1
							aFerProp[_Atual,_Prov] 		:= 0
							aFerProp[_Anter,_1Ter] 		:= aFerProp[_NoMes,_1Ter]*-1
							aFerProp[_Atual,_1Ter] 		:= 0
							aFerProp[_Anter,_Adic] 		:= aFerProp[_NoMes,_Adic]*-1
							aFerProp[_Atual,_Adic] 		:= 0
							aFerProp[_Anter,_INSS] 	    := aFerProp[_NoMes,_INSS]*-1
							aFerProp[_Atual,_INSS]		:= 0
							aFerProp[_Anter,_FGTS] 	    := aFerProp[_NoMes,_FGTS]*-1
							aFerProp[_Atual,_FGTS]		:= 0
							aFerProp[_Anter,_PIS] 		:= aFerProp[_NoMes,_PIS]*-1
							aFerProp[_Atual,_PIS] 		:= 0
						EndIf

					Endif

					 (cAliasRHT)->( dbSkip() )
				EndDo
			Else
				While  (cAliasRHT)->( !Eof() )

					// Ignorar os valores do Mes corrente //
					nNovoVal := 0
					nRHTValor := (cAliasRHT)->RHT_VALOR
					nRHTAtuVlr := nRHTValor
					If AnoMes( STOD((cAliasRHT)->RHT_DTCALC) ) == AnoMes(dDataRef)
						nRHTValor := 0
					EndIf

					//⁄ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒø
					//≥Quando h· algum Id de baixa no perÌodo, tal valor deve ser     ≥
					//≥Abatido do saldo anterior, para que o saldo anterior fique ok  ≥
					//¿ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒŸ
					If (cAliasRHT)->RHT_VERBA $ cCodBx
						If AnoMes( STOD((cAliasRHT)->RHT_DTCALC) ) <> AnoMes(dDataRef)
							nNovoVal :=  nRHTAtuVlr * (-1)
							nRHTAtuVlr := 0
							nRHTValor  := 0
						Endif
					Endif

					If (cAliasRHT)->RHT_VERBA == aCodFol[966,1] .and. (!(lProvResc .And. (cTBLXPROV)->PR_TIPMOVI == _demitido) .Or. AnoMes( STOD((cAliasRHT)->RHT_DTCALC) ) <> AnoMes(dDataRef))//Prov. MÍs 13∫ Sal·rio
						a13Salar[_Anter,_Prov] += nRHTValor
						a13Salar[_Anter,_Avos] := 0
						a13Salar[_Anter,_SalV] := 0

						a13Salar[_Atual,_Prov] += nRHTAtuVlr
						a13Salar[_Atual,_Avos] := 0
						a13Salar[_Atual,_SalV] := 0

					ElseIf (cAliasRHT)->RHT_VERBA == aCodFol[967,1] .and. (!(lProvResc .And. (cTBLXPROV)->PR_TIPMOVI == _demitido) .Or. AnoMes( STOD((cAliasRHT)->RHT_DTCALC) ) <> AnoMes(dDataRef))//Prov. MÍs Adcional de 13∫ Sal·rio
						a13Salar[_Anter,_Adic] += nRHTValor
						a13Salar[_Atual,_Adic] += nRHTAtuVlr
					ElseIf (cAliasRHT)->RHT_VERBA == aCodFol[968,1] .and. (!(lProvResc .And. (cTBLXPROV)->PR_TIPMOVI == _demitido) .Or. AnoMes( STOD((cAliasRHT)->RHT_DTCALC) ) <> AnoMes(dDataRef))//Prov. MÍs 1™ Parc. de 13∫ Sal·rio
						a13Salar[_Anter,_1Par] += nRHTValor
						a13Salar[_Atual,_1Par] += nRHTAtuVlr
					ElseIf (cAliasRHT)->RHT_VERBA == aCodFol[969,1] .and. (!(lProvResc .And. (cTBLXPROV)->PR_TIPMOVI == _demitido) .Or. AnoMes( STOD((cAliasRHT)->RHT_DTCALC) ) <> AnoMes(dDataRef))//Prov. MÍs INSS de 13∫ Sal·rio
						a13Salar[_Anter,_INSS] += nRHTValor
						a13Salar[_Atual,_INSS] += nRHTAtuVlr
					ElseIf (cAliasRHT)->RHT_VERBA == aCodFol[970,1] .and. (!(lProvResc .And. (cTBLXPROV)->PR_TIPMOVI == _demitido) .Or. AnoMes( STOD((cAliasRHT)->RHT_DTCALC) ) <> AnoMes(dDataRef))//Prov. MÍs FGTS de 13∫ Sal·rio
						a13Salar[_Anter,_FGTS] += nRHTValor
						a13Salar[_Atual,_FGTS] += nRHTAtuVlr
					ElseIf (cAliasRHT)->RHT_VERBA == aCodFol[971,1] .and. (!(lProvResc .And. (cTBLXPROV)->PR_TIPMOVI == _demitido) .Or. AnoMes( STOD((cAliasRHT)->RHT_DTCALC) ) <> AnoMes(dDataRef))//Prov. MÍs PIS de 13∫ Sal·rio
						a13Salar[_Anter,_PIS] += nRHTValor
						a13Salar[_Atual,_PIS] += nRHTAtuVlr
					ElseIf (cAliasRHT)->RHT_VERBA == aCodFol[332,1]//Baixa Provisao 13o Salario
						a13Salar[_Bx13O,_Prov] += nRHTAtuVlr
						a13Salar[_BxTot,_Prov] += nRHTAtuVlr
						a13Salar[_Atual,_Prov] -= iif(nNovoVal < 0,nNovoVal*(-1),nRHTAtuVlr)
						a13Salar[_Anter,_Prov] += nNovoVal
					ElseIf (cAliasRHT)->RHT_VERBA == aCodFol[333,1]//Baixa Adicional Provisao de 13o Salario
						a13Salar[_Bx13O,_Adic] += nRHTAtuVlr
						a13Salar[_BxTot,_Adic] += nRHTAtuVlr
						a13Salar[_Atual,_Adic] -= iif(nNovoVal < 0,nNovoVal*(-1),nRHTAtuVlr)
						a13Salar[_Anter,_Adic] += nNovoVal
					ElseIf (cAliasRHT)->RHT_VERBA == aCodFol[334,1]//Baixa Antecipacao 1a Parcela do 13o Salario
						a13Salar[_Bx13O,_1Par] += nRHTAtuVlr
						a13Salar[_BxTot,_1Par] += nRHTAtuVlr
						a13Salar[_Atual,_1Par] -= iif(nNovoVal < 0,nNovoVal*(-1),nRHTAtuVlr)
						a13Salar[_Anter,_1Par] += nNovoVal
					ElseIf (cAliasRHT)->RHT_VERBA == aCodFol[335,1]//Baixa Inss Provisao 13o Salario
						a13Salar[_Bx13O,_INSS] += nRHTAtuVlr
						a13Salar[_BxTot,_INSS] += nRHTAtuVlr
						a13Salar[_Atual,_INSS] -= iif(nNovoVal < 0,nNovoVal*(-1),nRHTAtuVlr)
						a13Salar[_Anter,_INSS] += nNovoVal
					ElseIf (cAliasRHT)->RHT_VERBA == aCodFol[336,1]//Baixa Fgts Provisao 13o Salario
						a13Salar[_Bx13O,_FGTS] += nRHTAtuVlr
						a13Salar[_BxTot,_FGTS] += nRHTAtuVlr
						a13Salar[_Atual,_FGTS] -= iif(nNovoVal < 0,nNovoVal*(-1),nRHTAtuVlr)
						a13Salar[_Anter,_FGTS] += nNovoVal
					ElseIf (cAliasRHT)->RHT_VERBA == aCodFol[423,1]//Baixa PIS Provisao 13o Salario
						a13Salar[_Bx13O,_PIS] += nRHTAtuVlr
						a13Salar[_BxTot,_PIS] += nRHTAtuVlr
						a13Salar[_Atual,_PIS] -= iif(nNovoVal < 0,nNovoVal*(-1),nRHTAtuVlr)
						a13Salar[_Anter,_PIS] += nNovoVal
					ElseIf (cAliasRHT)->RHT_VERBA == aCodFol[270,1]//Baixa Provisao 13o Salario Transferido
						a13Salar[_BxTrf,_Prov] += nRHTAtuVlr
						a13Salar[_BxTot,_Prov] += nRHTAtuVlr
						a13Salar[_Atual,_Prov] -= iif(nNovoVal < 0,nNovoVal*(-1),nRHTAtuVlr)
						a13Salar[_Anter,_Prov] += nNovoVal
					ElseIf (cAliasRHT)->RHT_VERBA == aCodFol[271,1]//Baixa Adicional Provisao de 13o Salario Transferido
						a13Salar[_BxTrf,_Adic] += nRHTAtuVlr
						a13Salar[_BxTot,_Adic] += nRHTAtuVlr
						a13Salar[_Atual,_Adic] -= iif(nNovoVal < 0,nNovoVal*(-1),nRHTAtuVlr)
						a13Salar[_Anter,_Adic] += nNovoVal
					ElseIf (cAliasRHT)->RHT_VERBA == aCodFol[272,1]//Baixa Inss Provisao 13o Salario Transferido
						a13Salar[_BxTrf,_INSS] += nRHTAtuVlr
						a13Salar[_BxTot,_INSS] += nRHTAtuVlr
						a13Salar[_Atual,_INSS] -= iif(nNovoVal < 0,nNovoVal*(-1),nRHTAtuVlr)
						a13Salar[_Anter,_INSS] += nNovoVal
					ElseIf (cAliasRHT)->RHT_VERBA == aCodFol[273,1]//Baixa Fgts Provisao 13o Salario Transferido
						a13Salar[_BxTrf,_FGTS] += nRHTAtuVlr
						a13Salar[_BxTot,_FGTS] += nRHTAtuVlr
						a13Salar[_Atual,_FGTS] -= iif(nNovoVal < 0,nNovoVal*(-1),nRHTAtuVlr)
						a13Salar[_Anter,_FGTS] += nNovoVal
					ElseIf (cAliasRHT)->RHT_VERBA == aCodFol[424,1]//Baixa PIS Provisao 13o Salario Transferido
						a13Salar[_BxTrf,_PIS] += nRHTAtuVlr
						a13Salar[_BxTot,_PIS] += nRHTAtuVlr
						a13Salar[_Atual,_PIS] -= iif(nNovoVal < 0,nNovoVal*(-1),nRHTAtuVlr)
						a13Salar[_Anter,_PIS] += nNovoVal
					ElseIf (cAliasRHT)->RHT_VERBA == aCodFol[274,1]//Baixa Provisao 13o Salario Rescisao
						a13Salar[_BxRes,_Prov] += nRHTAtuVlr
						a13Salar[_BxTot,_Prov] += nRHTAtuVlr
					ElseIf (cAliasRHT)->RHT_VERBA == aCodFol[275,1]//Baixa Adicional Provisao de 13o Salario Rescisao
						a13Salar[_BxRes,_Adic] += nRHTAtuVlr
						a13Salar[_BxTot,_Adic] += nRHTAtuVlr
					ElseIf (cAliasRHT)->RHT_VERBA == aCodFol[276,1]//Baixa Inss Provisao 13o Salario Rescisao
						a13Salar[_BxRes,_INSS] += nRHTAtuVlr
						a13Salar[_BxTot,_INSS] += nRHTAtuVlr
					ElseIf (cAliasRHT)->RHT_VERBA == aCodFol[277,1]//Baixa Fgts Provisao 13o Salario Rescisao
						a13Salar[_BxRes,_FGTS] += nRHTAtuVlr
						a13Salar[_BxTot,_FGTS] += nRHTAtuVlr
					ElseIf (cAliasRHT)->RHT_VERBA == aCodFol[425,1]//Baixa PIS Provisao 13o Salario Rescisao
						a13Salar[_BxRes,_PIS] += nRHTAtuVlr
						a13Salar[_BxTot,_PIS] += nRHTAtuVlr
					EndIf
					 (cAliasRHT)->( dbSkip() )
				Enddo
			EndIf 

			(cAliasRHT)->(dbCloseArea())
			(cAliasSRT)->(dbCloseArea())
			dbSelectArea(cAlias)

			//Grava os valores do mÍs fora do While, pois, dependendo do cÛdigo das verbas do cliente, pode imprimir informaÁıes do mÍs sem possuir o mes anterior preenchido.
			If (cTBLXPROV)->PR_TIPMOVI == _demitido
				If cTpRtProv == "RPF" //RPF - Rateio Provisao FÈrias
					//FÈrias Vencidas
					aFerVenc[_NoMes,_Prov] := aFerVenc[_BxTot,_Prov]-aFerVenc[_Anter,_Prov]
					aFerVenc[_NoMes,_Adic] := aFerVenc[_BxTot,_Adic]-aFerVenc[_Anter,_Adic]
					aFerVenc[_NoMes,_1Ter] := aFerVenc[_BxTot,_1Ter]-aFerVenc[_Anter,_1Ter]
					aFerVenc[_NoMes,_INSS] := aFerVenc[_BxTot,_INSS]-aFerVenc[_Anter,_INSS]
					aFerVenc[_NoMes,_FGTS] := aFerVenc[_BxTot,_FGTS]-aFerVenc[_Anter,_FGTS]
					aFerVenc[_NoMes,_PIS]  := aFerVenc[_BxTot,_PIS]-aFerVenc[_Anter,_PIS]

					aFerVenc[_Atual,_Prov] := 0
					aFerVenc[_Atual,_Adic] := 0
					aFerVenc[_Atual,_1Ter] := 0
					aFerVenc[_Atual,_INSS] := 0
					aFerVenc[_Atual,_FGTS] := 0
					aFerVenc[_Atual,_PIS]  := 0

					//FÈrias Proporcionais.
					aFerProp[_NoMes,_Prov] := aFerProp[_BxTot,_Prov]-aFerProp[_Anter,_Prov]
					aFerProp[_NoMes,_Adic] := aFerProp[_BxTot,_Adic]-aFerProp[_Anter,_Adic]
					aFerProp[_NoMes,_1Ter] := aFerProp[_BxTot,_1Ter]-aFerProp[_Anter,_1Ter]
					aFerProp[_NoMes,_INSS] := aFerProp[_BxTot,_INSS]-aFerProp[_Anter,_INSS]
					aFerProp[_NoMes,_FGTS] := aFerProp[_BxTot,_FGTS]-aFerProp[_Anter,_FGTS]
					aFerProp[_NoMes,_PIS]  := aFerProp[_BxTot,_PIS]-aFerProp[_Anter,_PIS]

					aFerProp[_Atual,_Prov] := 0
					aFerProp[_Atual,_Adic] := 0
					aFerProp[_Atual,_1Ter] := 0
					aFerProp[_Atual,_INSS] := 0
					aFerProp[_Atual,_FGTS] := 0
					aFerProp[_Atual,_PIS]  := 0

				ElseIf cTpRtProv == "RP13" //RP13 - Rateio Provis„o 13 Sal·rio
					//13 Sal·rio
					a13Salar[_NoMes,_Prov] := a13Salar[_BxTot,_Prov]-a13Salar[_Anter,_Prov]
					a13Salar[_NoMes,_Adic] := a13Salar[_BxTot,_Adic]-a13Salar[_Anter,_Adic]
					a13Salar[_NoMes,_INSS] := a13Salar[_BxTot,_INSS]-a13Salar[_Anter,_INSS]
					a13Salar[_NoMes,_FGTS] := a13Salar[_BxTot,_FGTS]-a13Salar[_Anter,_FGTS]
					a13Salar[_NoMes,_PIS] := a13Salar[_BxTot,_PIS]-a13Salar[_Anter,_PIS]

					a13Salar[_Atual,_Prov] := 0
					a13Salar[_Atual,_Adic] := 0
					a13Salar[_Atual,_INSS] := 0
					a13Salar[_Atual,_FGTS] := 0
					a13Salar[_Atual,_PIS] := 0
				EndIf
			EndIf

	EndIf

	While !Eof() .and. Empty(cTpRtProv)
		// CARREGA O ARRAY COM OS VALORES DO MES ANTERIOR. NAO CARREGAR SE PROVISAO DE 13o SALARIO E MES DE REFERENCIA FOR JANEIRO
		If !lQryAnt .And. Eval(cOrdemBusca) == cBusMesAnt
			//SOMENTE PARA O REGISTRO DE CABECALHO
			If !lTrfSld
				If !((cAliasSRT)->RT_TIPPROV == str(_13Salar,1) .And. Month(dDataRef) == 1) .And. !Empty((cAliasSRT)->RT_DATABAS)
					If lFerias
						aFerVenc[_Anter,_Dias] := (cAliasSRT)->RT_DFERVEN
						aFerProp[_Anter,_Dias] := (cAliasSRT)->RT_DFERPRO
					Endif
					If l13oSal
						a13Salar[_Anter,_Avos] := (cAliasSRT)->RT_AVOS13S
					Endif

					If lPlr
						aPlrSalar[_Anter,_Avos] := (cAliasSRT)->RT_AVOS13S
					Endif
				Endif
			EndIf
		    nPosVerba := Ascan(aVerba, { |X| X[4] == (cAliasSRT)->RT_VERBA })
			lAdiant13 := (cAliasSRT)->RT_VERBA == aCodFol[268,1]   //1.Parcela 13.Sal
			// BUSCA O ATUAL DO MES ANTERIOR E GRAVA NO ANTERIOR DO MES
		    If nPosVerba > 0 .and. aVerba[nPosVerba,2] == _Atual
	   		    nPosCol := aVerba[nPosVerba,3]
				If lFerias
					If (cAliasSRT)->RT_TIPPROV == Str(_FerVenc,1) .Or. (cAliasSRT)->RT_TIPPROV == Str(_RecVenc,1)
						aFerVenc[_Anter,nPosCol] := (cAliasSRT)->RT_VALOR
					ElseIf (cAliasSRT)->RT_TIPPROV == Str(_FerProp,1) .Or. (cAliasSRT)->RT_TIPPROV == Str(_RecProp,1)
						aFerProp[_Anter,nPosCol] := (cAliasSRT)->RT_VALOR
					Endif
				Endif
				If l13oSal
					If (cAliasSRT)->RT_TIPPROV == Str(_13Salar,1) .and. !(Month(dDataRef) == 1)
						a13Salar[_Anter,nPosCol] := (cAliasSRT)->RT_VALOR
						//Se for demitido e tiver verba de 1Parcela, gerar movimento de baixa
						// de rescisao da 1.parcela
						If lAdiant13 .and. nTpMov == _Demitido
							a13Salar[_BxRes,nPosCol] := (cAliasSRT)->RT_VALOR
						EndIf
					ElseIf (cAliasSRT)->RT_TIPPROV == Str(_14Salar,1) .and. !(Month(dDataRef) == 1)
						a14Salar[_Anter,nPosCol] := (cAliasSRT)->RT_VALOR
						//Se for demitido e tiver verba de 1Parcela, gerar movimento de baixa
						// de rescisao da 1.parcela
						If lAdiant13 .and. nTpMov == _Demitido
							a14Salar[_BxRes,nPosCol] := (cAliasSRT)->RT_VALOR
						EndIf
					EndIf
				Endif
				If lPlr
					If (cAliasSRT)->RT_TIPPROV == Str(_PlrSalar,1)
						aPlrSalar[_Anter,nPosCol] := (cAliasSRT)->RT_VALOR
					Endif
				Endif
			EndIf
		EndIf
		//CARREGA O ARRAY COM OS VALORES DO MES ATUAL
		If Eval(cOrdemBusca) == cBusMesAtu
			//SOMENTE PARA O REGISTRO DE CABECALHO
			If !lTrfSld
				If !Empty((cAliasSRT)->RT_DATABAS)
					nTpMov := (cAliasSRT)->RT_TIPMOVI
					If lFerias .And. (cAliasSRT)->RT_TIPPROV $ Str(_FerProp,1)+"/"+Str(_FerVenc,1)+"/"+Str(_13Salar,1)+"/"+Str(_RecProp,1)+"/"+Str(_RecVenc,1)
						aFerVenc[_NoMes,_Dias] := (cAliasSRT)->RT_DFALVEN
						aFerVenc[_Atual,_Dias] := (cAliasSRT)->RT_DFERVEN-If( nTpMov != 1 .And. (cAliasSRT)->RT_DFERVEN > 0, (cAliasSRT)->RT_DFERANT,0)-(cAliasSRT)->RT_DFALVEN
						aFerProp[_NoMes,_Dias] := (cAliasSRT)->RT_DFALPRO
						aFerProp[_Atual,_Dias] := (cAliasSRT)->RT_DFERPRO-IIf(IsInCallStack("GPER070"),0,(cAliasSRT)->RT_DFALPRO)
					Endif
					If l13oSal
						a13Salar[_NoMes,_Avos] := (cAliasSRT)->RT_AVOS13S
					Endif

					If lPLR
						aPLRSalar[_NoMes,_Avos] := (cAliasSRT)->RT_AVOS13S
					Endif
				Endif
			EndIf

	    	nPosVerba := Ascan(aVerba, { |X| X[4] == (cAliasSRT)->RT_VERBA })
	    	lAdiant13 := (cAliasSRT)->RT_VERBA == aCodFol[268,1]  //1.Parcela 13.Sal

	    	If nPosVerba > 0
				nPosLin := aVerba[nPosVerba,2]
				nPosCol := aVerba[nPosVerba,3]
				If lFerias
					If (cAliasSRT)->RT_TIPPROV == Str(_FerVenc,1) .Or. (cAliasSRT)->RT_TIPPROV == Str(_RecVenc,1)
						If lCalcula
							aFerVenc[nPosLin,nPosCol] := (cAliasSRT)->RT_VALOR
						Else
							aRecVenc[nPosLin,nPosCol]   := (cAliasSRT)->RECNO_
						Endif
					ElseIf (cAliasSRT)->RT_TIPPROV == Str(_FerProp,1) .Or. (cAliasSRT)->RT_TIPPROV == Str(_RecProp,1)
						If lCalcula
							aFerProp[nPosLin,nPosCol] := (cAliasSRT)->RT_VALOR
						Else
							aRecProp[nPosLin,nPosCol]   := (cAliasSRT)->RECNO_
						Endif
					Endif
				Endif
				If l13oSal .And. (cAliasSRT)->RT_VERBA <> aCodFol[1964, 1]
	 				If (cAliasSRT)->RT_TIPPROV == Str(_13Salar,1)
						If lCalcula
							a13Salar[nPosLin,nPosCol] := (cAliasSRT)->RT_VALOR
							//SE FOR DEMITIDO E TIVER VERBA DE 1PARCELA, GERAR MOVIMENTO DE BAIXA DE RESCISAO DA 1.PARCELA
							If lAdiant13 .and. nTpMov == _Demitido
								a13Salar[_BxRes,nPosCol] := (cAliasSRT)->RT_VALOR
							EndIf
						Else
							aRec13Sl[nPosLin,nPosCol]   := (cAliasSRT)->RECNO_
						Endif
					ElseIf (cAliasSRT)->RT_TIPPROV == Str(_14Salar,1)
						If lCalcula
							a14Salar[nPosLin,nPosCol] := (cAliasSRT)->RT_VALOR
							//Se for demitido e tiver verba de 1Parcela, gerar movimento de baixa
							// de rescisao da 1.parcela
							If lAdiant13 .and. nTpMov == _Demitido
								a14Salar[_BxRes,nPosCol] := (cAliasSRT)->RT_VALOR
							EndIf
						Else
							aRec14Sl[nPosLin,nPosCol]   := (cAliasSRT)->RECNO_
						Endif
					EndIf
				Endif
				If lPlr
	 				If (cAliasSRT)->RT_TIPPROV == Str(_PLRSalar,1)
						If lCalcula
							aPLRSalar[nPosLin,nPosCol] := (cAliasSRT)->RT_VALOR
						Else
							aRecPLRSl[nPosLin,nPosCol]   := (cAliasSRT)->RECNO_
						Endif
					EndIf
				EndIf
			EndIf
		EndIf
		dbSkip()
	EndDo

	If lQryAnt
		dbSelectArea(cAliasAnt)
		While !Eof()
			// CARREGA O ARRAY COM OS VALORES DO MES ANTERIOR. NAO CARREGAR SE PROVISAO DE 13o SALARIO E MES DE REFERENCIA FOR JANEIRO
			nPosAux := If(!Empty(cTpRtProv) .and. lTrfAMES, _TrfEnt, _Anter)
			If Eval(cOrdemAnt) == cBusMesAnt
				//SOMENTE PARA O REGISTRO DE CABECALHO
				If !lTrfSld
					If !((cAliasAnt)->RT_TIPPROV == str(_13Salar,1) .And. Month(dDataRef) == 1) .And. !Empty((cAliasAnt)->RT_DATABAS)
						If lFerias
							aFerVenc[nPosAux,_Dias] := (cAliasAnt)->RT_DFERVEN
							aFerProp[nPosAux,_Dias] := (cAliasAnt)->RT_DFERPRO
						Endif
						If l13oSal
							a13Salar[nPosAux,_Avos] := (cAliasAnt)->RT_AVOS13S
						Endif
					Endif
				EndIf
				nPosVerba := Ascan(aVerba, { |X| X[4] == (cAliasAnt)->RT_VERBA })
				lAdiant13 := (cAliasAnt)->RT_VERBA == aCodFol[268,1]   //1.Parcela 13.Sal
				// BUSCA O ATUAL DO MES ANTERIOR E GRAVA NO ANTERIOR DO MES
			    If nPosVerba > 0 .And. aVerba[nPosVerba,2] == _Atual
		   		    nPosCol := aVerba[nPosVerba,3]
					If lFerias
						If (cAliasAnt)->RT_TIPPROV == Str(_FerVenc,1) .Or. (cAliasAnt)->RT_TIPPROV == Str(_RecVenc,1)
							aFerVenc[nPosAux,nPosCol] := (cAliasAnt)->RT_VALOR
						ElseIf (cAliasAnt)->RT_TIPPROV == Str(_FerProp,1) .Or. (cAliasAnt)->RT_TIPPROV == Str(_RecProp,1)
							aFerProp[nPosAux,nPosCol] := (cAliasAnt)->RT_VALOR
						Endif
					Endif
					If l13oSal
						If (cAliasAnt)->RT_TIPPROV == Str(_13Salar,1) .and. !(Month(dDataRef) == 1)
							a13Salar[nPosAux,nPosCol] := (cAliasAnt)->RT_VALOR
							//SE FOR DEMITIDO E TIVER VERBA DE 1PARCELA, GERAR MOVIMENTO DE BAIXA DE RESCISAO DA 1.PARCELA
							If lAdiant13 .and. nTpMov == _Demitido
								a13Salar[_BxRes,nPosCol] := (cAliasAnt)->RT_VALOR
							EndIf
						ElseIf (cAliasAnt)->RT_TIPPROV == Str(_14Salar,1) .and. !(Month(dDataRef) == 1)
							a14Salar[nPosAux,nPosCol] := (cAliasAnt)->RT_VALOR
							//Se for demitido e tiver verba de 1Parcela, gerar movimento de baixa
							// de rescisao da 1.parcela
							If lAdiant13 .and. nTpMov == _Demitido
								a14Salar[_BxRes,nPosCol] := (cAliasAnt)->RT_VALOR
							EndIf
						EndIf
					Endif
					If lPlr
						If (cAliasAnt)->RT_TIPPROV == Str(_PlrSalar,1)
							aPLRSalar[nPosAux,nPosCol] := (cAliasAnt)->RT_VALOR
						EndIf
					EndIf
				EndIf
			EndIf
			dbSkip()
		EndDo
	EndIf

	If !Empty(cTpRtProv)

		If lQryAnt
			(cAliasAnt)->(dbCloseArea())
		EndIf 
		//SE impress„o for rateada, retorna apÛs a verificaÁ„o das verabs dos transferidos de grupo de empresas
		Return
	EndIf
EndIf //Fim do IF lSoMes

//Trecho para a geraÁ„o do saldo anterior da provis„o rateada com base nos valores da SRT.
If lInicRat .And. lGeraPMes .And. !IsInCallStack("GPER070") .And. !IsInCallStack("GPER090") .And. !IsInCallStack("GPEM110")
	cCompAnt  := dToS(MonthSub(dDataRef,1))
	nDiaAnt   := f_Ultdia(MontHSub(dDataRef,1))
	cCompAnt  := SubStr(cCompAnt,1,6) + cValToChar(nDiaAnt)
	cQuerySRT := "QSRT3"
	cWhereSRT := "(SRT.RT_FILIAL = " + cFilQryAtu + " AND SRT.RT_MAT = " + cMatQryAtu
	cWhereSRT += "AND SRT.RT_DATACAL = '" + cCompAnt + "' AND SRT.RT_VERBA = '" + aCodFol[130,1] + "') "
	cWhereSRT := "%"+cWhereSRT+"%

	BeginSql Alias cQuerySRT
		SELECT SRT.RT_DATACAL, SRT.RT_DATABAS, SRT.RT_VERBA, SRT.RT_TIPPROV, SRT.RT_CC, SRT.RT_DATABAS, SRT.RT_DFERVEN, SRT.RT_DFERPRO
		FROM %table:SRT% SRT
		WHERE %exp:cWhereSRT% AND SRT.%notDel%
	EndSql

	If !Empty((cQuerySRT)->RT_CC)
    	cCCSRT:=(cQuerySRT)->RT_CC
    Else
    	cCCSRT:=(cTBLXPROV)->PR_CC
    Endif

	If !Empty((cQuerySRT)->RT_DATABAS)
		dDtBsSRT := StOd((cQuerySRT)->RT_DATABAS)
	Else
		dDtBsSRT := SRF->RF_DATABAS
	EndIf

	If (cQuerySRT)->RT_DFERVEN > 0
		ndFvSRT := (cQuerySRT)->RT_DFERVEN
	EndIf

	If (cQuerySRT)->RT_DFERPRO > 0
		ndFpSRT := (cQuerySRT)->RT_DFERPRO
	EndIf

	//Realiza Rateio.
	aRatBkp   := aClone(aRateio)
	aRateio   := {}
	fRateio({}, 2, SubStr(cCompAnt,1,6))
	If Len(aRateio) == 0
		lSldIn := .T.
		aAdd(aRateio, { cCCSRT, SRA->RA_ITEM, SRA->RA_CLVL, 1 })
	EndIf

	(cQuerySRT)->(dbCloseArea())

	If lItemClVl
		RHT->(dbSetOrder(RetOrdem("RHT","RHT_FILIAL+RHT_MAT+RHT_CC+RHT_ITEM+RHT_CLVL+DTOS(RHT_DTCALC)+RHT_TPPROV+RHT_VERBA")))
	Else
		RHT->(dbSetOrder(RetOrdem("RHT","RHT_FILIAL+RHT_MAT+RHT_CC+DTOS(RHT_DTCALC)+RHT_TPPROV+RHT_VERBA")))
	EndIf

	//FÈrias Vencidas.
	For nX := 2 to Len(aFerVenc[1])
		nPos := aScan(aVerba, {|x| x[1] == 5 .And. x[2] == 4 .And. x[3] == nX  })
		If nPos > 0 .And. !Empty(aVerba[nPos][4]) .And. aFerVenc[1][nX] > 0
			For nZ := 1 to Len(aRateio)
				If lItemClVl
					cBuscaReg := SRA->RA_FILIAL+SRA->RA_MAT+aRateio[nZ,1]+aRateio[nZ,2]+aRateio[nZ,3]+cCompAnt+"1"+aVerba[nPos][4]
				Else
					cBuscaReg := SRA->RA_FILIAL+SRA->RA_MAT+aRateio[nZ,1]+cCompAnt+"1"+aVerba[nPos][4]
				EndIf
				If !RHT->(dbSeek(cBuscaReg))
					RecLock('RHT',.T.)
					RHT->RHT_FILIAL	:= SRA->RA_FILIAL
					RHT->RHT_MAT	:= SRA->RA_MAT
					RHT->RHT_CC		:= aRateio[nZ][1]
					RHT->RHT_DTCALC := sToD(cCompAnt)
					RHT->RHT_TPPROV := '1'
					RHT->RHT_VERBA	:= aVerba[nPos][4]
					RHT->RHT_VALOR	:= Round(aFerVenc[1][nX] * aRateio[nZ][4], 2)
					RHT->RHT_SALAR	:= SRA->RA_SALARIO
					RHT->RHT_ITEM   := aRateio[nZ][2]
					RHT->RHT_CLVL	:= aRateio[nZ][3]
					RHT->RHT_DTBASE := dDtBsSRT
					RHT->RHT_SLDIN	:= If( lSldIn, "", "1")
					If aRateio[nZ][4] <= 1
						RHT->RHT_PERC   := aRateio[nZ][4] * 100
					EndIf
					RHT->RHT_DFERVE := ndFvSRT
					MsUnlock()
				EndIf
			Next nZ
		EndIf
	Next nX

	//FÈrias Proporcionais.
	For nX:=2 to Len(aFerProp[1])
		nPos:= aScan(aVerba,{|x|x[1] == 5 .And. x[2] == 4 .And. x[3] == nX})
	   	If nPos > 0 .And. !Empty(aVerba[nPos][4]) .And. aFerProp[1][nX] > 0
		   	For nZ := 1 to Len(aRateio)
				If lItemClVl
					cBuscaReg := SRA->RA_FILIAL+SRA->RA_MAT+aRateio[nZ,1]+aRateio[nZ,2]+aRateio[nZ,3]+cCompAnt+"2"+aVerba[nPos][4]
				Else
					cBuscaReg := SRA->RA_FILIAL+SRA->RA_MAT+aRateio[nZ,1]+cCompAnt+"2"+aVerba[nPos][4]
				EndIf
				If !RHT->(dbSeek(cBuscaReg))
					RecLock('RHT',.T.)
					RHT->RHT_FILIAL	:= SRA->RA_FILIAL
					RHT->RHT_MAT	:= SRA->RA_MAT
					RHT->RHT_CC		:= aRateio[nZ][1]
					RHT->RHT_DTCALC := sToD(cCompAnt)
					RHT->RHT_TPPROV := '2'
					RHT->RHT_VERBA	:= aVerba[nPos][4]
					RHT->RHT_VALOR	:= Round(aFerProp[1][nX] * aRateio[nZ][4], 2)
					RHT->RHT_SALAR  := SRA->RA_SALARIO
					RHT->RHT_ITEM   := aRateio[nZ][2]
					RHT->RHT_CLVL	:= aRateio[nZ][3]
					RHT->RHT_DTBASE := dDtBsSRT
					RHT->RHT_SLDIN	:= If( lSldIn, "", "1")
					If aRateio[nZ][4] <= 1
						RHT->RHT_PERC   := aRateio[nZ][4] * 100
					EndIf
					RHT->RHT_DFERPR := ndFpSRT
					MsUnlock()
				EndIf
			Next nZ
		Endif
	Next nX

	//13 Sal·rio.
	For nX:=2 to Len(a13Salar[1])
		nPos:= aScan(aVerba,{|x|x[1] == _13SVMes .And. x[2] == 4 .And. x[3] == nX})
		If nPos > 0 .And. !Empty(aVerba[nPos][4]) .And. a13Salar[1][nX] > 0
			For nZ := 1 to Len(aRateio)
				If lItemClVl
					cBuscaReg := SRA->RA_FILIAL+SRA->RA_MAT+aRateio[nZ,1]+aRateio[nZ,2]+aRateio[nZ,3]+cCompAnt+"3"+aVerba[nPos][4]
				Else
					cBuscaReg := SRA->RA_FILIAL+SRA->RA_MAT+aRateio[nZ,1]+cCompAnt+"3"+aVerba[nPos][4]
				EndIf
				If !RHT->(dbSeek(cBuscaReg))
					RecLock('RHT',.T.)
					RHT->RHT_FILIAL	:= SRA->RA_FILIAL
					RHT->RHT_MAT	:= SRA->RA_MAT
					RHT->RHT_CC		:= aRateio[nZ][1]
					RHT->RHT_DTCALC := sToD(cCompAnt)
					RHT->RHT_TPPROV := '3'
					RHT->RHT_VERBA	:= aVerba[nPos][4]
					RHT->RHT_VALOR	:= Round(a13Salar[1][nX] * aRateio[nZ][4], 2)
					RHT->RHT_SALAR  := SRA->RA_SALARIO
					RHT->RHT_ITEM   := aRateio[nZ][2]
					RHT->RHT_CLVL	:= aRateio[nZ][3]
					RHT->RHT_SLDIN	:= If( lSldIn, "", "1")
					If aRateio[nZ][4] <= 1
						RHT->RHT_PERC   := aRateio[nZ][4] * 100
					EndIf
					MsUnlock()
				EndIf
			Next nZ
		Endif
	Next nX
	aRateio := aClone(aRatBkp)
EndIf
// CALCULA OS VALORES DE BAIXA E O VALOR NO MES
If lCalcula
	//SALVA A INFORMACAO ANTES DE PROCESSAR O CALCULO DA PROVISAO NO MES
	If lFerias
		axFerVenc	:= aClone(aFerVenc)
		axFerProp	:= aClone(aFerProp)
	Endif
	If l13oSal
		ax13Salar	:= aClone(a13Salar)
		ax14Salar	:= aClone(a14Salar)
	Endif
	If lPlr
		axPlrSalar	:= aClone(aPlrSalar)
	Endif
	For nTipoProv := 1 to 5
		If (l13oSal .And. (nTipoProv == 3 .Or. nTipoProv == 4)) .Or.;
		   (lFerias .And. ( (nTipoProv == 1 .Or. nTipoProv == 2) .Or. (nTipoProv == 7 .Or. nTipoProv == 8) ) ) .Or.;
		   ( lPlr .And. (nTipoProv == 5 ) )
			//-- Verifica o tipo de provisao a ser processado
			If nTipoProv == 1 .Or. nTipoProv == 7
				aProvisao	:= aFerVenc
			ElseIf nTipoProv == 2 .Or. nTipoProv == 8
				aProvisao	:= aFerProp
			ElseIf nTipoProv == 3
				aProvisao	:= a13Salar
			ElseIf nTipoProv == 4
				aProvisao	:= a14Salar
			ElseIf nTipoProv == 5
				aProvisao	:= aPLRSalar
			Endif
			// GRAVAR VALORES COLUNA DE RESCISAO QUANDO NAO EXISTIR IDENTIF. DE RESCISAO POIS,NESTE CASO, A BAIXA ESTARA NA COLUNA FERIAS
			If nTpMov == _Demitido
				fChkDemit(aProvisao,aVerba,nTipoProv,_BxRes,_BxFer)
			EndIf
			//TOTAL DE BAIXAS
			aProvisao[_BxTot,_Prov] := aProvisao[_BxTrf,_Prov]+aProvisao[_BxFer,_Prov]+aProvisao[_BxRes,_Prov]
			aProvisao[_BxTot,_Adic] := aProvisao[_BxTrf,_Adic]+aProvisao[_BxFer,_Adic]+aProvisao[_BxRes,_Adic]
			aProvisao[_BxTot,_1Ter] := aProvisao[_BxTrf,_1Ter]+aProvisao[_BxFer,_1Ter]+aProvisao[_BxRes,_1Ter]
			aProvisao[_BxTot,_INSS] := aProvisao[_BxTrf,_INSS]+aProvisao[_BxFer,_INSS]+aProvisao[_BxRes,_INSS]
			aProvisao[_BxTot,_FGTS] := aProvisao[_BxTrf,_FGTS]+aProvisao[_BxFer,_FGTS]+aProvisao[_BxRes,_FGTS]
			aProvisao[_BxTot,_PIS]  := aProvisao[_BxTrf,_PIS] +aProvisao[_BxFer,_PIS] +aProvisao[_BxRes,_PIS]
			//Se alterou rateio, zera a posiÁ„o do saldo anterior para forÁar a geraÁ„o do saldo total no mÍs
			If lMudouRat
				aBkpArr := aClone(aProvisao[_Anter])
				aFill( aProvisao[_Anter], 0 )
			EndIf
			//PROVISAO DO MES
			//Se funcion·rio esta demitido e provis„o de fÈrias vencidas atual esta zerada, indica que as fÈrias foram pagas no mÍs anterior, nessa situaÁ„o, n„o deve incluir nada na provis„o do mÍs
			If !(nTipoProv == 1 .And. lProvResc .And. aProvisao[_Anter, _Prov] > 0 .And. aProvisao[_Atual, _Prov] == 0 .And. aProvisao[ _BxFer, _Prov ] == 0 .And. !(SRA->RA_RESCRAI $ "30/31") .And. !Empty( (cTBLXPROV)->PR_DEMISSA ) )
				If lGeraPMes .And. !IsInCallStack("GPER070") .And. !IsInCallStack("GPER090")
					If !( nTipoProv == 1 .And. (cTBLXPROV)->PR_TIPMOVI == _Trfe_Ent .And. aProvisao[_Atual, _Adic] < aProvisao[_Anter,_Adic] )
					    aProvisao[_NoMes,_Prov] := aProvisao[_Atual,_Prov]-aProvisao[_Anter,_Prov]+If((cTBLXPROV)->PR_TIPMOVI == _Demitido .And. lProvResc, 0, aProvisao[_BxTot,_Prov])
                        aProvisao[_NoMes,_Adic] := aProvisao[_Atual,_Adic]-aProvisao[_Anter,_Adic]+If((cTBLXPROV)->PR_TIPMOVI == _Demitido .And. lProvResc, 0, aProvisao[_BxTot,_Adic])
					    aProvisao[_NoMes,_1Ter] := aProvisao[_Atual,_1Ter]-aProvisao[_Anter,_1Ter]+If((cTBLXPROV)->PR_TIPMOVI == _Demitido .And. lProvResc, 0, aProvisao[_BxTot,_1Ter])
					    aProvisao[_NoMes,_INSS] := aProvisao[_Atual,_INSS]-aProvisao[_Anter,_INSS]+If((cTBLXPROV)->PR_TIPMOVI == _Demitido .And. lProvResc, 0, aProvisao[_BxTot,_INSS])
					    aProvisao[_NoMes,_FGTS] := aProvisao[_Atual,_FGTS]-aProvisao[_Anter,_FGTS]+If((cTBLXPROV)->PR_TIPMOVI == _Demitido .And. lProvResc, 0, aProvisao[_BxTot,_FGTS])
					    aProvisao[_NoMes,_PIS]  := aProvisao[_Atual,_PIS] -aProvisao[_Anter,_PIS] +If((cTBLXPROV)->PR_TIPMOVI == _Demitido .And. lProvResc, 0, aProvisao[_BxTot,_PIS] )
                    Else
                        aProvisao[_NoMes] := aClone( aProvisao[_Atual] )
                    EndIf
				Else

					aProvisao[_NoMes,_Prov] := aProvisao[_Atual,_Prov]-aProvisao[_Anter,_Prov]+If(nTpMov == _Demitido .And. lProvResc, aProvisao[_Bx13O,_Prov], aProvisao[_BxTot,_Prov])
					aProvisao[_NoMes,_Adic] := aProvisao[_Atual,_Adic]-aProvisao[_Anter,_Adic]+If(nTpMov == _Demitido .And. lProvResc, aProvisao[_Bx13O,_Adic], aProvisao[_BxTot,_Adic])
					aProvisao[_NoMes,_1Ter] := aProvisao[_Atual,_1Ter]-aProvisao[_Anter,_1Ter]+If(nTpMov == _Demitido .And. lProvResc, aProvisao[_Bx13O,_1Ter], aProvisao[_BxTot,_1Ter])
					aProvisao[_NoMes,_INSS] := aProvisao[_Atual,_INSS]-aProvisao[_Anter,_INSS]+If(nTpMov == _Demitido .And. lProvResc, aProvisao[_Bx13O,_INSS], aProvisao[_BxTot,_INSS])
					aProvisao[_NoMes,_FGTS] := aProvisao[_Atual,_FGTS]-aProvisao[_Anter,_FGTS]+If(nTpMov == _Demitido .And. lProvResc, aProvisao[_Bx13O,_FGTS], aProvisao[_BxTot,_FGTS])
					aProvisao[_NoMes,_PIS]  := aProvisao[_Atual,_PIS] -aProvisao[_Anter,_PIS] +If(nTpMov == _Demitido .And. lProvResc, aProvisao[_Bx13O,_PIS],  aProvisao[_BxTot,_PIS] )
					If lProvResc .And. nTpMov == _Demitido .And. nTipoProv == 3 .And. aProvisao[_Bx13O,_1Par] > 0 .and. aProvisao[_Bx13O,_Prov] == 0
						aProvisao[_BxRes,_1Par] := aProvisao[_Bx13O,_1Par]
						aProvisao[_Bx13O,_1Par] := 0
					EndIf
				EndIf
			EndIf

			If lMudouRat
				aProvisao[_Anter] := aClone(aBkpArr)
			EndIf
			If lProvResc .And. nTpMov == _Demitido
				// Zera a linha de provisao atual quando o funcionario estiver demitido e o parametro MV_PROVRES estiver configurado com "S"
				For nCnt1 := 2 To _Colunas
					aProvisao[_Atual,nCnt1]	:= 0
				Next nCnt1
			Endif
			If lTrfAMES
				//TRANSFERE O SALDO ANTERIOR PARA A COLUNA TRANSF. ENTRADA
				If (cTBLXPROV)->PR_TIPMOVI == _Trfe_Ent .Or. (((cTBLXPROV)->PR_TIPMOVI == _Anter) .And. (aProvisao[_BxRes,_Prov]+aProvisao[_BxRes,_Adic]+aProvisao[_Bx13O,_Prov]+aProvisao[_Bx13O,_Adic] <> 0) .And. (nPosTrf > 0))
					For nCnt1 := 1 To _Colunas
						aProvisao[_TrfEnt,nCnt1] := aProvisao[_Anter,nCnt1]
						aProvisao[_Anter,nCnt1]  := 0
					Next nCnt1

					If aProvisao[_Bx13O,_Prov]+aProvisao[_Bx13O,_Adic] > 0
						aProvisao[_BxRes,_1Par] := 0
					EndIf
				ElseIf  (nPosTrf > 0 .and. (nTipoProv == 2 .Or. nTipoProv == 3 .Or. nTipoProv == 8) .and. (cTBLXPROV)->PR_TIPMOVI == _Anter)
		   			For nCnt1 := 1 To _Colunas
						aProvisao[_TrfEnt,nCnt1] := aProvisao[_Anter,nCnt1]
						aProvisao[_Anter,nCnt1]  := 0
					Next nCnt1
				//TRANSFERE O SALDO DE BAIXA POR TRANSF. P/COLUNA TRANSF. SAIDA
				ElseIf (cTBLXPROV)->PR_TIPMOVI == _Trfe_Sai
					For nCnt1 := 1 To _Colunas
						aProvisao[_TrfSai,nCnt1] := aProvisao[_BxTrf,nCnt1]
						aProvisao[_BxTrf,nCnt1]  := 0
					Next nCnt1
				EndIf
			ElseIf ( nTipoProv == 2 .and. nTpMov == _Demitido .and. aProvisao[_BxRes,_Prov]+aProvisao[_BxRes,_Adic]+aProvisao[_Bx13O,_Prov]+aProvisao[_Bx13O,_Adic] == 0 .and. aProvisao[_NoMes,2] < 0 .and. aProvisao[_Anter,2] > 0 .And. nPostrf > 0 .And. lTrfSld)
				//Se for fÈrias proporcionais, funcion·rio demitido e n„o houver baixa, deve zerar a provis„o atual
				For nCnt1 := 1 To _Colunas
					aProvisao[_Anter,nCnt1]  := 0
				Next nCnt1
			EndIf

            If (cTBLXPROV)->PR_TIPMOVI == _Trfe_Sai
                //AJUSTA O VALOR DA BAIXA DA PRIMEIRA PARCELA NA LINHA DE TRANSFERENCIA DE SAIDA
                //DEVOLVE O VALOR PARA A LINHA NO MES
                //TRATAMENTO EXCLUSIVO PARA 13o SALARIO - 1A PARCELA
                If !lTrfEmpAmes .And. nTipoProv == _13Salar // NAO E TRANSFERENCIA ENTRE EMPRESAS
                    aProvisao[Iif( lTrfAMES, _TrfSai, _BxTrf ), _1Par]  := aProvisao[_Anter, _1Par]
                    aProvisao[_NoMes, _1Par]   += aProvisao[_Anter, _1Par]
                EndIf
            EndIf

		  	If lTrfSld .And. fChkIdent(aVerba,If(nTipoProv==2,1,If(nTipoProv==8, 7, nTipoProv)),{_BxRes},.F.) .and. fChkIdent(aVerba,If(nTipoProv==2,1,If(nTipoProv==8, 7, nTipoProv)),{_BxTrf},.F.)
				For nCnt1 := 1 To _Colunas
					aProvisao[_NoMes,nCnt1] := aProvisao[_Anter,nCnt1]
					aProvisao[_Anter,nCnt1]  := 0
				Next nCnt1
			EndIf
			//SALVA O ARRAY PROCESSADO
			If nTipoProv == 1
				axFerVenc	:= aClone(aProvisao)
			ElseIf nTipoProv == 2
				axFerProp	:= aClone(aProvisao)
			ElseIf nTipoProv == 3
				ax13Salar	:= aClone(aProvisao)
			ElseIf nTipoProv == 4
				ax14Salar	:= aClone(aProvisao)
			ElseIf nTipoProv == 5
				axPlrSalar	:= aClone(aProvisao)
			Endif
		Endif

	Next nTipoProv
	//DEVOLVE O ARRAY PARA O PROCESSO NORMAL
	If lFerias
		aFerVenc	:= aClone(axFerVenc)
		aFerProp	:= aClone(axFerProp)
	Endif
	If l13oSal
		a13Salar	:= aClone(ax13Salar)
		a14Salar	:= aClone(ax14Salar)
	Endif
	If lPlr
		aPlrSalar	:= aClone(axPlrSalar)
	Endif
Endif

If !lSoMes
	(cAliasSRT)->(dbCloseArea())
	If lQryAnt
		(cAliasAnt)->(dbCloseArea())
	EndIf
	dbSelectArea(cAlias)
Endif

Return Nil

/*
‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±⁄ƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒø±±
±±≥Funcao    ≥ fGeraSRT ≥ Autor ≥ Emerson R. de Souza	≥ Data ≥ 26.06.00 ≥±±
±±√ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒ¥±±
±±≥Descricao ≥ Grava os valores da provisao no arquivo SRT                ≥±±
±±√ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¥±±
±±≥Sintaxe   ≥ fGeraSRT(aProvisao,aVerba,dDataRef,nTipoMovMes,nSalMes...) ≥±±
±±√ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¥±±
±±≥Parametros≥ aProvisao   - Array que contera os valores da provisao	  ≥±±
±±≥          ≥ aVerba      - Verbas de Ferias / 13oSal / 14oSal           ≥±±
±±≥          ≥ aRecnos     - Indica os recnos que serao avaliados         ≥±±
±±≥          ≥ dDataRef    - Data de referencia p/ gravacao dos valores   ≥±±
±±≥          ≥ nTipoMovMes - Tipo de movimentacao no mes                  |±±
±±≥          ≥ nSalMes     - Valor do salario no mes                      ≥±±
±±≥          ≥ dDtBasFer   - Data base de ferias                          ≥±±
±±≥          ≥ nDiaFeAnt   - Dias de ferias antecipadas                   ≥±±
±±≥          ≥ nTipoProv   - Tipo de provisao a buscar (Venc,Prop,13o)    |±±
±±√ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¥±±
±±≥Uso       ≥ Generico                                                   ≥±±
±±¿ƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒŸ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂ*/
Static Function fGeraSRT(aProvisao,aRecnos,aVerba,dDataRef,nTipoMovMes,nSalMes,dDtBasFer,nDiaFeAnt,nTipoProv,lCabec)
Local aArea     := GetArea()
Local nTipo2	:= 0
Local nTipo3	:= 0
Local nProvBus  := If(nTipoProv == _FerProp, _FerVenc, If(nTipoProv == _RecProp, _RecVenc, nTipoProv))
Local cChave	:= ""
Local cFilAux   := cFilAnt
Local lCabProp  := .F.
Local lTemCab   := .F.

DEFAULT lCabec  	:= .F.
DEFAULT lItemClVl   := GetMvRH("MV_ITMCLVL", .F., "2") $ "13"
DEFAULT lGp070Grv   := ExistBlock("GP070GRV")
DEFAULT lGp070CHK   := ExistBlock("GP070CHK")

// POSICIONA CFILANT NA FILIAL CORRENTE P/ GARANTIR INTEGRIDADE
cFilAnt := (cTBLXPROV)->PR_FILIAL

// SE NAO EXISTIR IDENTIFICADORES DE BAIXA DE RESCISAO,SOMAR NA COLUNA DE BAIXA DE FERIAS E ZERAR COLUNA DE BAIXA DE RESCISAO
fChkDemit(aProvisao,aVerba,nTipoProv,_BxFer,_BxRes)

// PONTO DE ENTRADA PARA CHECAR REGISTROS PERDIDOS NO SRT
If lGp070CHK
	ExecBlock("GP070CHK",.F.,.F.)
Endif

// GRAVA O ARRAY PROVISAO NO ARQUIVO SRT
dbSelectArea("SRT")
If lItemClVl
	dbSetOrder(4)
Else
	dbSetOrder(1)
EndIf

For nTipo2 := 1 To _Linhas
	// LINHAS QUE NAO DEVERAO SER GRAVADAS NO ARQUIVO
	If nTipo2 == _Anter .Or. nTipo2 == _NoMes .Or. nTipo2 == _BxTot
		Loop
	EndIf
	// GRAVA AS COLUNAS DE VALORES NO ARQUIVO DETALHE
	For nTipo3 := 1 To _Colunas
		// BUSCA A VERBA E GRAVA OS LANCAMENTOS NO ARQUIVO DETALHE
        nPosVerba := Ascan(aVerba, { |X| X[1] == nProvBus .And. X[2] == nTipo2 .And. X[3] == nTipo3 })
        cCodVerba := If(nPosVerba > 0, aVerba[nPosVerba,4], Space(3))
        If !Empty(cCodVerba)
	        If ValType(aRecnos[nTipo2,nTipo3]) <> "U" .And. aRecnos[nTipo2,nTipo3] > 0
    	    	dbGoTo(aRecnos[nTipo2,nTipo3])
        		RecLock("SRT", .F.)
		    	If aProvisao[nTipo2,nTipo3] == 0
					dbDelete()
					MsUnlock()
					Loop
				EndIf
			Else
				If aProvisao[nTipo2,nTipo3] # 0
					RecLock("SRT", .T.)
				Else
					Loop
				EndIf
        	EndIf
			SRT->RT_FILIAL  := (cTBLXPROV)->PR_FILIAL
			SRT->RT_MAT     := (cTBLXPROV)->PR_MAT
			SRT->RT_CC      := (cTBLXPROV)->PR_CC
			If lItemClVl
				SRT->RT_ITEM    := (cTBLXPROV)->PR_ITEM
				SRT->RT_CLVL    := (cTBLXPROV)->PR_CLVL
	        EndIf
			SRT->RT_TIPPROV := If(nTipoProv == 10, "A", Str(nTipoProv,1))
			SRT->RT_VERBA   := cCodVerba
			SRT->RT_VALOR   := aProvisao[nTipo2,nTipo3]
			SRT->RT_DATACAL := dDataRef

			// PONTO DE ENTRADA PARA GRAVAR CAMPOS PERSONALIZADOS DO SRT
			If lGp070Grv
				ExecBlock("GP070GRV", .F., .F., {(cTBLXPROV)->PR_FILIAL, (cTBLXPROV)->PR_MAT, nTipoProv})
			Endif

			MsUnlock()
			//GravaÁ„o das baixas no arquivo de provis„o mensal - RHT
			If lGeraPmes .And. (nTipo2 == _BxFer .Or. nTipo2 == _Bx13O .Or. nTipo2 == _BxRes)
				fGeraBaixaMes(1)
			EndIf

		    //INTEGRACAO COM MODULO SIGAPCO
			PcoDetLan("000091","01","GPEA070")

		EndIf
	Next nTipo3
Next nTipo2
If lItemClVl
	cChave := (cTBLXPROV)->PR_FILIAL + (cTBLXPROV)->PR_MAT + (cTBLXPROV)->PR_CC + (cTBLXPROV)->PR_ITEM +  (cTBLXPROV)->PR_CLVL + MesAno(dDataRef)
Else
	cChave := (cTBLXPROV)->PR_FILIAL + (cTBLXPROV)->PR_MAT + (cTBLXPROV)->PR_CC + MesAno(dDataRef)
EndIf

lCabProp := ( ( nTipoProv == _FerProp .Or. nTipoProv == _RecProp .OR. nTipoProv == _13Salar ) .And. ( aProvisao[_Anter,_Dias] > 0 .Or. lCabec .Or. nTipoMovMes == _Cong_Fer .Or. ;
				( aProvisao[_Anter,_Dias] == 0 .And. nTipoMovMes == 4 .And. aProvisao[_Atual,_Dias] == 0  ) ) ) .Or.;
				( nTipoMovMes == 1 .And. aProvisao[_Anter,_Dias] > 0 .And. aProvisao[_Atual,_Dias] == 0 ) .Or.;
				( nTipoMovMes == 1 .And. lDemitido .And. lProvResc .And. nTipoProv >= 2 .And. aProvisao[_Atual,_Dias] == 0 .And. AnoMes(dDataRef) == AnoMes(SRA->RA_DEMISSA) ) //Quando demitido, mesmo que n„o possua verbas, cria linha de baixa na SRT)

// GRAVA AS INFORMACOES DE CABECALHO
If dbSeek( cChave )
	While SRT->(!EOF()) .AND. (SRT->RT_FILIAL + SRT->RT_MAT + SRT->RT_CC + MesAno(SRT->RT_DATACAL) ==   cChave)
		If !Empty(SRT->RT_DATABAS)
			lTemCab := .T.
			Exit
		EndIf
		DbSkip()
	EndDo
	If !lTemCab
		dbSeek( cChave )
	EndIf

	RecLock("SRT", .F.)
	SRT->RT_DATABAS := dDtBasFer

	IF Empty(SRT->RT_DFERANT)
		SRT->RT_DFERANT := nDiaFeAnt
	EndIf
	IF Empty(SRT->RT_DFALVEN)
		SRT->RT_DFALVEN := nV_DFalFer
	EndIf
	IF Empty(SRT->RT_DFALPRO)
		SRT->RT_DFALPRO := nP_DFalFer
	EndIf
	IF Empty(SRT->RT_TIPMOVI)
		SRT->RT_TIPMOVI := nTipoMovMes
	EndIf
	SRT->RT_SALARIO := nSalMes
	If Empty(SRT->RT_DFERVEN) .and. (nTipoProv == _FerVenc .Or. nTipoProv == _RecVenc)
		SRT->RT_DFERVEN := aProvisao[_Atual,_Dias]
	ElseIf Empty(SRT->RT_DFERPRO) .and. (nTipoProv == _FerProp .Or. nTipoProv == _RecProp)
	SRT->RT_DFERPRO := aProvisao[_Atual,_Dias]
	ElseIf Empty(SRT->RT_AVOS13S) .AND. nTipoProv == _13Salar
		SRT->RT_AVOS13S := aProvisao[_Atual,_Avos]
	EndIf
	MsUnLock()

ElseIf lCabProp
		RecLock("SRT", .T.)
		SRT->RT_FILIAL  := (cTBLXPROV)->PR_FILIAL
		SRT->RT_MAT     := (cTBLXPROV)->PR_MAT
		SRT->RT_CC      := (cTBLXPROV)->PR_CC
		If lItemClVl
			SRT->RT_ITEM    := (cTBLXPROV)->PR_ITEM
			SRT->RT_CLVL    := (cTBLXPROV)->PR_CLVL
        EndIf
		SRT->RT_TIPPROV := If(nTipoProv == 10, "A", Str(nTipoProv,1))
		SRT->RT_VERBA   := ""
		SRT->RT_VALOR   := 0.00
		SRT->RT_DATACAL := dDataRef

	SRT->RT_DATABAS := dDtBasFer
	SRT->RT_DFERANT := nDiaFeAnt
	SRT->RT_DFALVEN := nV_DFalFer
	SRT->RT_DFALPRO := nP_DFalFer
	SRT->RT_TIPMOVI := nTipoMovMes
	SRT->RT_SALARIO := nSalMes
	If nTipoProv == _FerVenc .Or. nTipoProv == _RecVenc
		SRT->RT_DFERVEN := aProvisao[_Atual,_Dias]
	ElseIf nTipoProv == _FerProp .Or. nTipoProv == _RecProp
		SRT->RT_DFERPRO := aProvisao[_Atual,_Dias]
	ElseIf nTipoProv == _13Salar
		SRT->RT_AVOS13S := aProvisao[_Atual,_Avos]
	EndIf
	MsUnLock()
EndIf

RestArea(aArea)

// RETORNA FILIAL ORIGINAL PARA O cFilAnt
cFilAnt := cFilAux

Return Nil

/*
‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±⁄ƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒø±±
±±≥Funcao	 ≥ fGeraMes ≥ Autor ≥ Kelly Soares       	≥ Data ≥ 15.06.12 ≥±±
±±√ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒ¥±±
±±≥Descricao ≥ Grava os valores mensais da provisao no arquivo SRT       ≥±±
±±√ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¥±±
±±≥Sintaxe	 ≥ fGeraMes(aProvisao,aVerba,dDataRef,nTipoMovMes,nSalMes...) ≥±±
±±√ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¥±±
±±≥Parametros≥ aProvisao	 - Array que contera os valores da provisao	  ≥±±
±±≥          ≥ aVerba   	 - Verbas de Ferias / 13oSal / 14oSal         ≥±±
±±≥          ≥ aRecnos   	 - Indica os recnos que serao avaliados       ≥±±
±±≥          ≥ dDataRef   	 - Data de referencia p/ gravacao dos valores ≥±±
±±≥          ≥ nTipoMovMes 	 - Tipo de movimentacao no mes                |±±
±±≥          ≥ nSalMes  	 - Valor do salario no mes                    ≥±±
±±≥          ≥ dDtBasFer  	 - Data base de ferias                        ≥±±
±±≥          ≥ nDiaFeAnt  	 - Dias de ferias antecipadas                 ≥±±
±±≥          ≥ nTipoProv	 - Tipo de provisao a buscar (Venc,Prop,13o)  |±±
±±√ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¥±±
±±≥ Uso	 	 ≥ Generico 												  ≥±±
±±¿ƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒŸ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂ*/
Static Function fGeraMes( aRecBxa )
Local cRatKey   := ""
Local cTpProvM  := ""
Local nX		:= 0
Local nC		:= 0
Local nPos		:= 0
Local nQtd		:= Len(aRateio)
Local nPerc		:= 0
Local nValDiv 	:= 0
Local nVlComp	:= 0
Local nValor  	:= 0
Local aArea		:= GetArea()

DEFAULT lItemClVl   := GetMvRH("MV_ITMCLVL", .F., "2") $ "13"

//Exclui eventuais registros de outros centros de custo que tenham sido gerados devido a mudanÁas no rateio.
RHT->(dbSetOrder(RetOrdem("RHT","RHT_FILIAL+RHT_MAT+DTOS(RHT_DTCALC)+RHT_TPPROV"))) //--Ordem 5
If RHT->(dbSeek((cTBLXPROV)->PR_FILIAL+(cTBLXPROV)->PR_MAT+DTOS(dDataRef)))
	aEval(aRateio,{|X| cRatKey += x[1]+x[2]+x[3] + "*" } )
	While RHT->(!Eof() .and. RHT_FILIAL+RHT_MAT+DTOS(RHT_DTCALC) == (cTBLXPROV)->PR_FILIAL+(cTBLXPROV)->PR_MAT+DTOS(dDataRef))
		If !( RHT->(RHT_CC + RHT_ITEM + RHT_CLVL) $ cRatKey ) .And. aScan( aRecBxa, { |x| x == RHT->( Recno() ) } ) == 0//Se n„o existir na confgiuraÁ„o de rateio, exclui.
			RecLock("RHT", .F.)
			DbDelete()
			MsUnlock()
		EndIf
		RHT->(DbSkip())
	EndDo
Else 
	cTpProvM := If(lFerias .And. l13oSal, "'1','2','3'", If(lFerias, "'1','2'", "'3'")) + If(lPlrPe, ",'4'", "")
	TcSqlExec("DELETE FROM " + RetSqlName("RHT") + " WHERE RHT_FILIAL = '" + (cTBLXPROV)->PR_FILIAL + "' AND RHT_MAT = '" + (cTBLXPROV)->PR_MAT +"'"+;
		"AND RHT_DTCALC BETWEEN '" + AnoMes(dDataRef)+"01" + "' AND '" + dToS(LastDate(dDataRef)) + "' AND RHT_TPPROV IN ("+ cTpProvM+ " )")	
EndIf

For nX := 2 to _Colunas
	// FERIAS VENCIDAS
	nPos := aScan(aVerba,{|X| X[1] = _FerVMes .and. X[2] = _Atual .and. X[3] = nX})
	If nPos > 0
		cCodVerba := aVerba[nPos,4]
		If !Empty(cCodVerba)
			//Rateio
			nValDiv := 0
			nVlComp := 0
			nValor  := aFerVenc[_NoMes,nX]
			If nValor == 0 .and. aFerVenc[_TrfEnt,nX] > 0 //FÈrias vencidas sem provisionamento no mÍs
				nValor := aFerVenc[_TrfEnt,nX]
			EndIf
			If !nValor == 0
				For nC := 1 to nQtd
					If nC # nQtd
						nValDiv := Round(nValor * aRateio[nC,4],2)
						nVlComp += nValDiv
					Else
						nValDiv := nValor-nVlComp
					Endif
					
					nPerc := aRateio[nC,4]
					If nPerc <= 1
						nPerc := nPerc * 100
					Endif
					// Ordem 4 - RHT_FILIAL+RHT_MAT+RHT_CC+RHT_ITEM+RHT_CLVL+DTOS(RHT_DTCALC)+RHT_TPPROV+RHT_VERBA
					RHT->(dbSetOrder(RetOrdem("RHT","RHT_FILIAL+RHT_MAT+RHT_CC+RHT_ITEM+RHT_CLVL+DTOS(RHT_DTCALC)+RHT_TPPROV+RHT_VERBA")))
					If !RHT->(dbSeek((cTBLXPROV)->PR_FILIAL+(cTBLXPROV)->PR_MAT+aRateio[nC,1]+aRateio[nC,2]+aRateio[nC,3]+DTOS(dDataRef)+"1"+cCodVerba))
						RecLock("RHT", .T.)
						RHT->RHT_FILIAL  := (cTBLXPROV)->PR_FILIAL
						RHT->RHT_MAT     := (cTBLXPROV)->PR_MAT
						RHT->RHT_CC      := aRateio[nC,1]
						If lItemClVl
							RHT->RHT_ITEM := aRateio[nC,2]
							RHT->RHT_CLVL := aRateio[nC,3]
						EndIf
						RHT->RHT_TPPROV := "1"
						RHT->RHT_VERBA   := cCodVerba
					Else
						RecLock("RHT", .F.)
					Endif
					RHT->RHT_SALAR  := nSalMes
					RHT->RHT_DTCALC := dDataRef
					RHT->RHT_VALOR  := nValDiv
					RHT->RHT_PERC	:= nPerc
					RHT->RHT_DTBASE := dDtBasFer // necess·rio gravar a database, pois ser· utilizada na correta montagem do relatÛrio.
					MsUnlock()
				Next nC
			Endif
		Endif
	Endif
	//FERIAS PROPORCIONAIS
	nPos := aScan(aVerba,{|X| X[1] = _FerVMes .and. X[2] = _Atual .and. X[3] = nX})
	If nPos > 0
		cCodVerba := aVerba[nPos,4]
		If !Empty(cCodVerba)
			//RATEIO
			nValDiv := 0
			nVlComp := 0
			nValor  := aFerProp[_NoMes,nX] + aFerProp[_TrfEnt,nX]
			If !nValor == 0
				For nC := 1 to nQtd
					If nC # nQtd
						nValDiv := Round(nValor * aRateio[nC,4],2)
						nVlComp += nValDiv
					Else
						nValDiv := nValor-nVlComp
					Endif
					nPerc := aRateio[nC,4]
					If nPerc <= 1
						nPerc := nPerc * 100
					Endif
					// Ordem 4 - RHT_FILIAL+RHT_MAT+RHT_CC+RHT_ITEM+RHT_CLVL+DTOS(RHT_DTCALC)+RHT_TPPROV+RHT_VERBA
					RHT->(dbSetOrder(RetOrdem("RHT","RHT_FILIAL+RHT_MAT+RHT_CC+RHT_ITEM+RHT_CLVL+DTOS(RHT_DTCALC)+RHT_TPPROV+RHT_VERBA")))
					If !RHT->(dbSeek((cTBLXPROV)->PR_FILIAL+(cTBLXPROV)->PR_MAT+aRateio[nC,1]+aRateio[nC,2]+aRateio[nC,3]+DTOS(dDataRef)+"2"+cCodVerba))
						RecLock("RHT", .T.)
						RHT->RHT_FILIAL  := (cTBLXPROV)->PR_FILIAL
						RHT->RHT_MAT     := (cTBLXPROV)->PR_MAT
						RHT->RHT_CC      := aRateio[nC,1]
						If lItemClVl
							RHT->RHT_ITEM := aRateio[nC,2]
							RHT->RHT_CLVL := aRateio[nC,3]
						EndIf
						RHT->RHT_TPPROV := "2"
						RHT->RHT_VERBA   := cCodVerba
					Else
						RecLock("RHT", .F.)
					Endif
					RHT->RHT_SALAR  := nSalMes
					RHT->RHT_DTCALC := dDataRef
					RHT->RHT_VALOR  := nValDiv
					RHT->RHT_PERC	:= nPerc
					RHT->RHT_DTBASE := dDtBasFer // necess·rio gravar a database, pois ser· utilizada na correta montagem do relatÛrio.
					RHT->RHT_DFERPR := aFerProp[_Atual,1] // Quantidade acumulada de fÈrias proporcionais.
					MsUnlock()
				Next nC
			Endif
		Endif
	Endif
	// 13 SALARIO
	nPos := aScan(aVerba,{|X| X[1] = _13SVMes .and. X[2] = _Atual .and. X[3] = nX})
	If nPos > 0
		cCodVerba := aVerba[nPos,4]
		If !Empty(cCodVerba)
			//RATEIO
			nValDiv := 0
			nVlComp := 0
			nValor  := a13Salar[_NoMes,nX] + a13Salar[_TrfEnt,nX]
			If !nValor == 0
				For nC := 1 to nQtd
					If nC # nQtd
						nValDiv := Round(nValor * aRateio[nC,4],2)
						nVlComp += nValDiv
					Else
						nValDiv := nValor-nVlComp
					Endif
					nPerc := aRateio[nC,4]
					If nPerc <= 1
						nPerc := nPerc * 100
					Endif
					// Ordem 4 - RHT_FILIAL+RHT_MAT+RHT_CC+RHT_ITEM+RHT_CLVL+DTOS(RHT_DTCALC)+RHT_TPPROV+RHT_VERBA
					RHT->(dbSetOrder(RetOrdem("RHT","RHT_FILIAL+RHT_MAT+RHT_CC+RHT_ITEM+RHT_CLVL+DTOS(RHT_DTCALC)+RHT_TPPROV+RHT_VERBA")))
					If !RHT->(dbSeek((cTBLXPROV)->PR_FILIAL+(cTBLXPROV)->PR_MAT+aRateio[nC,1]+aRateio[nC,2]+aRateio[nC,3]+DTOS(dDataRef)+"3"+cCodVerba))
						RecLock("RHT", .T.)
						RHT->RHT_FILIAL  := (cTBLXPROV)->PR_FILIAL
						RHT->RHT_MAT     := (cTBLXPROV)->PR_MAT
						RHT->RHT_CC      := aRateio[nC,1]
						If lItemClVl
							RHT->RHT_ITEM := aRateio[nC,2]
							RHT->RHT_CLVL := aRateio[nC,3]
						EndIf
						RHT->RHT_TPPROV := "3"
						RHT->RHT_VERBA   := cCodVerba
					Else
						RecLock("RHT", .F.)
					Endif
					RHT->RHT_SALAR  := nSalMes
					RHT->RHT_DTCALC := dDataRef
					RHT->RHT_VALOR  := nValDiv
					RHT->RHT_PERC	:= nPerc
					MsUnlock()
				Next nC
			Endif
		Endif
	Endif

	If lPlrPe

		nPos := aScan(aVerba,{|X| X[1] = _PlrSVMes .and. X[2] = _Atual .and. X[3] = nX})
		If nPos > 0
			cCodVerba := aVerba[nPos,4]
			If !Empty(cCodVerba)
				//Rateio
				nValDiv := 0
				nVlComp := 0
				nValor  := aPLRSalar[_NoMes,nX]
				If !nValor == 0
					For nC := 1 to nQtd
						If nC # nQtd
							nValDiv := Round( nValor * aRateio[nC,4],2)
							nVlComp += nValDiv
						Else
							nValDiv := nValor-nVlComp
						Endif

						nPerc := aRateio[nC,4]
						If nPerc <= 1
							nPerc := nPerc * 100
						Endif

						// Ordem 4 - RHT_FILIAL+RHT_MAT+RHT_CC+RHT_ITEM+RHT_CLVL+DTOS(RHT_DTCALC)+RHT_TPPROV+RHT_VERBA
						RHT->(dbSetOrder(RetOrdem("RHT","RHT_FILIAL+RHT_MAT+RHT_CC+RHT_ITEM+RHT_CLVL+DTOS(RHT_DTCALC)+RHT_TPPROV+RHT_VERBA" ) ) )
						If !RHT->(dbSeek((cTBLXPROV)->PR_FILIAL+(cTBLXPROV)->PR_MAT+aRateio[nC,1]+aRateio[nC,2]+aRateio[nC,3]+DTOS(dDataRef)+"4"+cCodVerba))
							RecLock( "RHT", .T. )
							RHT->RHT_FILIAL  := (cTBLXPROV)->PR_FILIAL
							RHT->RHT_MAT     := (cTBLXPROV)->PR_MAT
							RHT->RHT_CC      := aRateio[nC,1]
							If lItemClVl
								RHT->RHT_ITEM := aRateio[nC,2]
								RHT->RHT_CLVL := aRateio[nC,3]
							EndIf
							RHT->RHT_TPPROV := "4"
							RHT->RHT_VERBA   := cCodVerba
						Else
							RecLock( "RHT", .F. )
						Endif
						RHT->RHT_SALAR  	:= nSalMes
						RHT->RHT_DTCALC 	:= dDataRef
						RHT->RHT_VALOR  	:= nValDiv
						RHT->RHT_PERC		:= nPerc

						MsUnlock()
					Next nC
				Endif
			Endif
		EndIf
	Endif
Next nX

RestArea(aArea)

Return nil

/*
‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±⁄ƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒø±±
±±≥Funcao    ≥ fChkIdent   ≥ Autor ≥ Emerson R. de Souza≥ Data ≥ 15.07.00 ≥±±
±±√ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒ¥±±
±±≥Descricao ≥ Verifica a existencia de identificadores                   ≥±±
±±√ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¥±±
±±≥Sintaxe   ≥ fChkIdent(aVerba,nTipProv,aTipId,lGeraLog)                 ≥±±
±±√ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¥±±
±±≥Parametros≥  aVerba   -Array com os identificadores a ser pesquisado   ≥±±
±±≥          ≥  nTipProv -Tipo de provisao (Ferias,13o,14o)               ≥±±
±±≥          ≥  aTipId   -Identificadores pesquisados(Trf,Res,Correcao)   ≥±±
±±≥          ≥  lGeraLog -Indica se deve incluir o ident. em aIdProvis    ≥±±
±±√ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¥±±
±±≥Uso       ≥  Generico                                                  ≥±±
±±¿ƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒŸ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂ*/
Function fChkIdent(aVerba,nTipProv,aTipId,lGeraLog)
Local nCnt1, nCnt2, nPosElem, aElem := { _Prov, _Adic, _1Ter, _INSS, _FGTS }
Local lRet := .T.

// BUSCA O TIPO DE PROVISAO, TIPO DE IDENTIFICADOR E COLUNA DA PROVISAO. SE ENCONTROU, VERIFICA SE CADASTROU O IDENTIFICADOR
For nCnt1  := 1 To Len(aTipId)
	nTipId := aTipId[nCnt1]
	For nCnt2 := 1 To Len(aElem)
		nPosElem := Ascan(aVerba, { |X| X[1] == nTipProv .And. X[2] == nTipId .And. X[3] == aElem[nCnt2] })
		// ARRAY CONTENDO AS VERBAS NAO CADASTRADAS OU IDENT. DE TRANSF
		If nPosElem > 0
			If (Type("aIdProvis") == "A" .And. lGeraLog)
				Aadd(aIdProvis, { aVerba[nPosElem,4], aVerba[nPosElem,5], nTipProv, nTipId })
			EndIf
			If Empty(aVerba[nPosElem,4])
				lRet := .F.
			EndIf
		EndIf
	Next nCnt2
Next nCnt1

Return lRet

/*
‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±⁄ƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒø±±
±±≥Funcao    ≥fGrvArrPrv| Autor ≥ Emerson Rosa de Souza ≥ Data ≥ 15.07.00 ≥±±
±±√ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒ¥±±
±±≥Descricao ≥ Trata as baixas de transferencia e rescisao                ≥±±
±±√ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¥±±
±±≥Sintaxe   ≥ fGrvArrPrv(aProvisao, nElem1, nElem2, nIndice, aZerar)     ≥±±
±±√ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¥±±
±±≥Parametros≥ aProvisao - Array contendo os valores da provisao          ≥±±
±±≥          ≥ nElem1    - Elemento que recebera o conteudo de gravacao   |±±
±±≥          ≥ nElem2    - Elemento que sera gravado em nElem1            |±±
±±≥          ≥ nIndCorr  - Indice de correcao                             |±±
±±≥          ≥ aZerar    - Elementos que deverao ser zerados              |±±
±±√ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¥±±
±±≥Uso       ≥ Generico                                                   ≥±±
±±¿ƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒŸ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂ*/
Function fGrvArrPrv(aProvisao, nElem1, nElem2, nIndCorr, aZerar)
Local  nCnt1	:= 0

aProvisao[nElem1,_Dias] := Round( aProvisao[nElem2,_Dias] * nIndCorr, 2 )
aProvisao[nElem1,_Prov] := Round( aProvisao[nElem2,_Prov] * nIndCorr, 2 )
aProvisao[nElem1,_Adic] := Round( aProvisao[nElem2,_Adic] * nIndCorr, 2 )
aProvisao[nElem1,_1Ter] := Round( aProvisao[nElem2,_1Ter] * nIndCorr, 2 )
aProvisao[nElem1,_INSS] := Round( aProvisao[nElem2,_INSS] * nIndCorr, 2 )
aProvisao[nElem1,_FGTS] := Round( aProvisao[nElem2,_FGTS] * nIndCorr, 2 )
aProvisao[nElem1,_PIS]  := Round( aProvisao[nElem2,_PIS]  * nIndCorr, 2 )

For nCnt1 := 1 To Len(aZerar)
	aProvisao[nElem1,aZerar[nCnt1] ] := 0
Next nCnt1

Return Nil

/*
‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±⁄ƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒø±±
±±≥Funcao	 ≥fMonta_TPR≥ Autor ≥ Emerson Rosa de Souza	≥ Data ≥ 02.03.00 ≥±±
±±√ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒ¥±±
±±≥Descricao ≥ Monta Arquivo de Trabalho para impressao da provisao       ≥±±
±±√ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¥±±
±±≥Sintaxe	 ≥fMonta_TPR(cTPRDbf,cTPRNtx,nOrdem,dDataRef,lSalInc,lTrataTrf≥±±
±±√ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¥±±
±±≥Parametros≥ cTPRDbf   - Compatibilidade	                              ≥±±
±±≥          ≥ cTPRNtx   - Compatibilidade			                      ≥±±
±±≥          ≥ nOrdem    - Ordem de Calculo ou Impressao                  ≥±±
±±≥          ≥ dDataRef  - Data de referencia para Calculo ou Impressao   ≥±±
±±≥          ≥ lSalInc   - Indica se existe salario incorporado           ≥±±
±±≥          ≥ lTrataTrf - Indica se deve tratar transferidos             ≥±±
±±≥          ≥ aTransf   - Array que contera os transferidos no mes       ≥±±
±±≥          ≥ lIncDemit - Indica se deve incluir os demitidos            ≥±±
±±≥          ≥ cAcessaArq- Indica se tem dereito de acesso                ≥±±
±±≥          ≥ lIncTodos - Indica se deve incluir todos os funcionarios   ≥±±
±±√ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¥±±
±±≥Uso       ≥ Generico                                                   ≥±±
±±¿ƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒŸ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂ*/
Function fMonta_TPR(cTPRDbf,cTPRNtx,nOrdem,dDataRef,lSalInc,lTrataTrf,aTransf,lIncDemit,cAcessaArq,lIncTodos,lTodosCpos,cTpc,cFiltroRel)
Local aVerbaProv	:= {}
Local aCodFol 		:= {}
Local aStruSRA 		:= {}
Local aSRASRT		:= {}
Local aVerbasTPR	:= {}
Local bChkSRA
Local bChkSRE
Local cInicio
Local cFim
Local cSitFolh
Local cTipAfas
Local cCposQuery
Local cCusto
Local cCustoAtu
Local cClvl 		:= ""
Local cClvlAtu 		:= ""
Local cItem 		:= ""
Local cItemAtu 		:= ""
Local cAliasSRA		:= "SRA"
Local cOrdem		:= ""
Local cAccessaAux	:= ""
Local cAnoMesAtu
Local cDtIQryAtu
Local cDtFQryAtu
Local cLisVerbas
Local cCposGroup
Local cCposnOrd5
Local cVerbaRPF 	:= ""
Local cVerbaRP13	:= ""
Local cJnSRACTT		:= "% " + FWJoinFilial( "SRA", "CTT" ) + " %"
Local cExpTpc		:= ""
Local dAfaIni		:= CtoD("")
Local dAfaFim		:= CtoD("")
Local lTransfEmp	:= .F.
Local nK1
Local nK2
Local nTpMv
Local nPosFunc
Local nTrfProc
Local nPosFunc1
Local nReg			:= 0
Local nPR_TIPMOVI 	:= 0
Local nPosTransf    := 0
Local cCatefd		:= "% '' = '' %"
Local nPosFunc2 	:= 0
Local nPosFunc3		:= 0
Local nTPosCc       := 0
Local lTransfRet 	:= .F.
Local cWhereCC		:= ""
Local lGPEM070		:= IsInCallStack("GPEM070")
Local lGPEM110		:= IsInCallStack("GPEM110") .Or. IsInCallStack("GPEM110a")
Local lGPER070		:= IsInCallStack("GPER070")
Local lGPER090		:= IsInCallStack("GPER090")
Local lGProvSRV		:= IsInCallStack("fGeraProvSRZ")
Local lGP095IMP		:= IsInCallStack("GP095IMP")
Local lM110Proc		:= FwIsInCallStack("GPEM110PROCESSA") .Or. FwIsInCallStack("GPEM111PROCESSA") 
Local lTransCC		:= .F.
Local lSegPlan		:= FwIsInCallStack("WFLAUNCHER") .or. FwIsInCallStack("FWBOSCHDEXECUTE")

DEFAULT cTpc		:= ""
DEFAULT cFiltroRel	:= ""
DEFAULT lItemClVl   := GetMvRH("MV_ITMCLVL", .F., "2") $ "13"
DEFAULT aCcEmpTra   := {}

If Type("cFilConDe") != "U"
	cFilDe	:= If( !Empty(cFilDe), cFilDe, cFilConDe)
	cFilAte	:= If( !Empty(cFilAte), cFilAte, cFilConAte)
EndIf

DEFAULT lIncDemit  := .T.
DEFAULT lIncTodos  := .F.
DEFAULT lTodosCpos := .F.

// VERIFICA SE FOI PASSADO BLOCO, STRING OU NIL
If cAcessaArq == Nil .Or. Empty(cAcessaArq)
	bChkSRA := &("{ || .T.}")
	bChkSRE := &("{ || .T.}")
ElseIf ValType(cAcessaArq) == "B"
	cAcessaArq	:= StrTran(cAcessaArq, "SRA->","(cAliasSRA)->")
	bChkSRA 	:= cAcessaArq
	bChkSRE 	:= &("{ || .T.}")
ElseIf ValType(cAcessaArq) == "C"
	cAccessaAux	:= cAcessaArq
	cAcessaArq	:= StrTran(cAcessaArq, "SRA->","(cAliasSRA)->")
	bChkSRA 	:= &(cAcessaArq)
	// SE HOUVE C.CUSTO NO FILTRO TROCAR PELO ARRAY ATRANSF
	If AT("RA_CC", cAccessaAux) > 0
		cAccessaAux := STRTRAN( cAccessaAux, "SRA->RA_CC", "aTransf[nK1,nTrfProc,_TCC]")
	EndIf
	bChkSRE := &(cAccessaAux)
EndIf

// VERIFICA A EXISTENCIA DOS IDENTIFICADORES DE TRANSFERENCIA
If _BkpFilial != cFilAnt .or. Empty(_aCodFol)
	If Fp_CodFol(@aCodFol,cFilAnt)
		// CARREGA OS IDENTIFICADORES DA PROVISAO E TESTA SE EXISTEM
		fIdentProv(@aVerbaProv,aCodFol)
		// VERIFICA A EXISTENCIA DOS IDENTIFICADORES DE TRANSFERENCIA
		lTrataTrf := (fChkIdent(aVerbaProv,_FerVenc,{_BxTrf},.F.) .And. fChkIdent(aVerbaProv,_13Salar,{_BxTrf},.F.))
		// VERIFICA A EXISTENCIA DOS IDENTIFICADORES DA PROVISAO MES
		If lGeraPMes .And. lTrataTrf
			lTrataTrf := (	fChkIdent(aVerba,_FerVMes,{_Atual},.F.) .And.;
							fChkIdent(aVerba,_13SVMes,{_Atual},.F.) )
		Endif
	Endif
	_aCodFol	:= aClone(aCodFol)
	_BkpFilial	:= cFilAnt
	_lBkpTraTrf	:= lTrataTrf
EndIf

aCodFol		:= aClone(_aCodFol)
lTrataTrf	:= _lBkpTraTrf

// ATUALIZA VARIAVEIS COM OS CODIGOS DAS VERBAS DE RATEIO PROVISAO MES
If !Empty(cTpRtProv)
	cVerbaRPF 	:= "'"+aCodFol[960,1]+"','"+aCodFol[961,1]+"','"+aCodFol[962,1]+"','"+aCodFol[963,1]+"','"+aCodFol[964,1]+"','"+aCodFol[965,1]+"','"+aCodFol[233,1]+"','"+aCodFol[239,1]+"'"
	cVerbaRP13	:= "'"+aCodFol[966,1]+"','"+aCodFol[967,1]+"','"+aCodFol[968,1]+"','"+aCodFol[969,1]+"','"+aCodFol[970,1]+"','"+aCodFol[971,1]+"','"+aCodFol[332,1]+"','"+aCodFol[270,1]+"'"
Endif

// VERIFICAR SE EXISTE CAMPO SAL.INCORPORADO NO CADASTRO
dbSelectArea("SX3")
dbSetOrder(2)
If dbSeek("RA_SALINCO")
	lSalInc := .T.
EndIf
lINSSAut := dbSeek("RA_INSSAUT")
dbsetOrder(1)

//CAMPOS DA QUERY
If lTodosCpos
	cCposQuery	:= "% * %"
Else
	cCposQuery	:=	"RA_FILIAL, RA_MAT, RA_NOME, RA_CC, RA_CATFUNC, RA_ADMISSA, RA_SITFOLH, RA_AFASFGT, "+;
					"RA_DEMISSA, RA_TPCONTR, RA_HRSMES, RA_PERICUL, RA_ADTPOSE, RA_INSMAX"
	cCposQuery	+= If(lSalInc,", RA_SALINCO","")
	cCposQuery	+= If(lItemClVl,", RA_ITEM, RA_CLVL","")
	If !Empty(cTpRtProv) .And. lItemClVl
		cCposQuery	+= ", RHT_CC, RHT_ITEM, RHT_CLVL, RHT_DTCALC"
	ElseIf !Empty(cTpRtProv) .And. !lItemClVl
		cCposQuery	+= ", RHT_CC, RHT_DTCALC"
	EndIf
	cCposQuery	+= If(lINSSAut,", RA_INSSAUT","")
	cCposQuery  += ", SRA.R_E_C_N_O_"
	If !Empty(cTpRtProv)
		cCposnOrd5	:= If(nOrdem == 5 .AND. lItemClVl,", RHT_FILIAL, RHT_ITEM, RHT_CLVL, RHT_MAT, RHT_DTCALC",If(nOrdem == 5 .AND. !lItemClVl,", RHT_FILIAL, RHT_MAT, RHT_DTCALC",""))
	Else
		cCposnOrd5	:= If(nOrdem == 5 .AND. lItemClVl,", RT_FILIAL, RT_ITEM, RT_CLVL, RT_MAT",If(nOrdem == 5 .AND. !lItemClVl,", RT_FILIAL, RT_MAT",""))
	Endif
	cCposGroup	:=	"% "+cCposQuery+cCposnOrd5+" %"
	cCposQuery	:=	"% "+cCposQuery+" %"
EndIf
cAliasSRA	:= "QSRA"

If (Select(cAliasSRA) > 0)
	(cAliasSRA)->(dbCloseArea())
EndIf

aStruSRA 	:= SRA->(dbStruct())
If !Empty(cTpRtProv)
	cOrdem		:= sqlorder(;
		If(nOrdem == 5 .AND. lItemClVl, "RHT_FILIAL, RHT_CC, RHT_ITEM, RHT_CLVL, RHT_MAT, RHT_DTCALC";
		, If(nOrdem == 5 .AND. !lItemClVl, "RHT_FILIAL, RHT_CC, RHT_MAT, RHT_DTCALC";
		, SRA->(IndexKey(If(nOrdem==4,8,nOrdem)));
		);
		);
		)
Else
	cOrdem		:= sqlorder(;
		If(nOrdem == 5 .AND. lItemClVl, "RT_FILIAL, RT_CC, RT_ITEM, RT_CLVL, RT_MAT";
		, If(nOrdem == 5 .AND. !lItemClVl, "RT_FILIAL, RT_CC, RT_MAT";
		, SRA->(IndexKey(If(nOrdem==4,8,nOrdem)));
		);
		);
		)
EndIf

cOrdem		:= "% "+cOrdem+" %"
cCatQuery := ""

For nReg:=1 to Len(cCateg)
	cCatQuery += "'"+Subs(cCateg,nReg,1)+"'"
	If (nReg+1) <= Len(cCateg)
		cCatQuery += ","
	EndIf
Next nReg

cCatQuery	:= "%" + cCatQuery + "%"
cDemissa	:= "(SRA.RA_DEMISSA = '        ' OR SRA.RA_DEMISSA > '"+DTOS(dDataRef-day(dDataRef))+"')"
cDemissa	:= "% "+cDemissa+" %"

If cPaisloc == "BRA"
	cCatefd := "% SRA.RA_CATEFD NOT IN ('107','108') %"
EndIf

If cTpc == "1"
	cExpTpc := "% ' ', '1' %"
Else
	cExpTpc := "% '" + cTpc + "' %"
EndIf

If nOrdem == 5
	cWhereCC := "%RHT.RHT_CC >= '" + cCCDe + "' AND RHT.RHT_CC <= '" + cCCAte + "' AND%"
Else
	cWhereCC := "%SRA.RA_CC >= '" + cCCDe + "' AND SRA.RA_CC <= '" + cCCAte + "' AND%"
EndIf

If !Empty(cTpRtProv)
	cAnoMesAtu  := MesAno(dDataRef)
	cDtIQryAtu	:= cAnoMesAtu+"01"
	cDtFQryAtu	:= cAnoMesAtu+strzero(f_Ultdia(dDataRef),2)
	If cTpRtProv == 'RPF'
		cLisVerbas	:= "%"+cVerbaRPF+"%"
	ElseIf cTpRtProv == 'RP13'
		cLisVerbas	:= "%"+cVerbaRP13+"%"
	EndIf

	BeginSql alias cAliasSRA
		    SELECT %exp:cCposQuery%
		      FROM %table:SRA% SRA
		INNER JOIN %table:RHT% RHT
		        ON RHT.RHT_FILIAL = SRA.RA_FILIAL
  			   AND RHT.RHT_MAT = SRA.RA_MAT
		INNER JOIN %table:CTT% CTT
		        ON %exp:cJnSRACTT%
  			   AND CTT.CTT_CUSTO = SRA.RA_CC
		 WHERE SRA.RA_FILIAL >= %exp:cFilDe% AND SRA.RA_FILIAL <= %exp:cFilAte% AND
				   SRA.RA_MAT >= %exp:cMatDe% AND SRA.RA_MAT <= %exp:cMatAte% AND
				   %Exp:cWhereCC%
				   SRA.RA_NOME >= %exp:cNomeDe% AND SRA.RA_NOME <= %exp:cNomeAte% AND
			       SRA.RA_CATFUNC IN (%exp:Upper(cCatQuery)%) AND
			       SRA.RA_ADMISSA <= %exp:dtos(dDataRef)% AND
			       %exp:cDemissa% AND
     			   RHT.RHT_VERBA IN (%exp:cLisVerbas%) AND
     			   RHT.RHT_DTCALC = ( SELECT MAX(RHT01.RHT_DTCALC) FROM %table:RHT% RHT01
						WHERE RHT01.RHT_FILIAL = SRA.RA_FILIAL AND
							RHT01.RHT_MAT = SRA.RA_MAT AND
							RHT01.RHT_VERBA IN (%exp:cLisVerbas%) AND
							RHT01.RHT_DTCALC <= %exp:cDtFQryAtu% AND
							RHT01.%notDel%  ) AND
     			   SRA.RA_TPCONTR <> '3' AND
				   %exp:cCatefd% AND
				   SRA.%notDel% AND
				   RHT.%notDel% AND
				   CTT.%notDel%
		  GROUP BY %exp:cCposGroup%
	      ORDER BY %exp:cOrdem%
 	EndSql
Else
	If Empty(cTpc)
		BeginSql alias cAliasSRA
			SELECT %exp:cCposQuery%
			FROM %table:SRA% SRA
			INNER JOIN %table:CTT% CTT
			        ON %exp:cJnSRACTT%
	  			   AND CTT.CTT_CUSTO = SRA.RA_CC
			WHERE  SRA.RA_FILIAL >= %exp:cFilDe% AND SRA.RA_FILIAL <= %exp:cFilAte% AND
				   SRA.RA_MAT >= %exp:cMatDe% AND SRA.RA_MAT <= %exp:cMatAte% AND
				   SRA.RA_CC >= %exp:cCCDe% AND SRA.RA_CC <= %exp:cCCAte% AND
				   SRA.RA_NOME >= %exp:cNomeDe% AND SRA.RA_NOME <= %exp:cNomeAte% AND
			       SRA.RA_CATFUNC IN (%exp:Upper(cCatQuery)%) AND
			       SRA.RA_ADMISSA <= %exp:dtos(dDataRef)% AND
			       %exp:cDemissa% AND
			       SRA.RA_TPCONTR <> '3' AND
   				   %exp:cCatefd% AND
				   SRA.%notDel% AND
				   CTT.%notDel%
			ORDER BY %exp:cOrdem%
	 	EndSql
 	Else
		BeginSql alias cAliasSRA
			SELECT %exp:cCposQuery%
			FROM %table:SRA% SRA
			INNER JOIN %table:CTT% CTT
			        ON %exp:cJnSRACTT%
	  			   AND CTT.CTT_CUSTO = SRA.RA_CC
			WHERE  SRA.RA_FILIAL >= %exp:cFilDe% AND SRA.RA_FILIAL <= %exp:cFilAte% AND
				   SRA.RA_MAT >= %exp:cMatDe% AND SRA.RA_MAT <= %exp:cMatAte% AND
				   SRA.RA_CC >= %exp:cCCDe% AND SRA.RA_CC <= %exp:cCCAte% AND
				   SRA.RA_NOME >= %exp:cNomeDe% AND SRA.RA_NOME <= %exp:cNomeAte% AND
			       SRA.RA_CATFUNC IN (%exp:Upper(cCatQuery)%) AND
			       SRA.RA_ADMISSA <= %exp:dtos(dDataRef)% AND SRA.RA_TPCONTR IN (%exp:(cExpTpc)%) AND
			       SRA.RA_TPCONTR <> '3' AND
  				   %exp:cCatefd% AND
			       %exp:cDemissa% AND
				   SRA.%notDel% AND
				   CTT.%notDel%
			ORDER BY %exp:cOrdem%
	 	EndSql
 	EndIf
EndIf

//AJUSTA A ESTRUTURA DOS CAMPOS
For nReg := 1 To Len(aStruSRA)
	If (aStruSRA[nReg][2] <> "C") .And. If(!lTodosCpos,aStruSRA[nReg][1]$cCposQuery,.T.)
		TcSetField(cAliasSRA,aStruSRA[nReg][1],aStruSRA[nReg][2],aStruSRA[nReg][3],aStruSRA[nReg][4])
	EndIf
Next nReg

//ORDEM DO ARQUIVO TEMPORARIO
If nOrdem == 1
	cInicio  := (cAliasSRA)+"->RA_FILIAL+"+(cAliasSRA)+"->RA_MAT"
	cFim	 := cFilAte + cMatAte
	aIndice  := {"PR_FILIAL", "PR_MAT"}
ElseIf nOrdem == 2
	cInicio  := (cAliasSRA)+"->RA_FILIAL+"+(cAliasSRA)+"->RA_CC+"+(cAliasSRA)+"->RA_MAT"
	cFim	 := cFilAte + cCcAte + cMatAte
	aIndice  := {"PR_FILIAL", "PR_CC", "PR_MAT"}
ElseIf nOrdem == 3
	cInicio  := (cAliasSRA)+"->RA_FILIAL+"+(cAliasSRA)+"->RA_NOME+"+(cAliasSRA)+"->RA_MAT"
	cFim	 := cFilAte + cNomeAte + cMatAte
	aIndice  := {"PR_FILIAL","PR_NOME","PR_MAT"}
ElseIf nOrdem == 4
	cInicio  := (cAliasSRA)+"->RA_FILIAL+"+(cAliasSRA)+"->RA_CC+"+(cAliasSRA)+"->RA_NOME"
	cFim	 := cFilAte + cCcAte + cNomeAte
	aIndice  := {"PR_FILIAL","PR_CC","PR_NOME"}
ElseIf nOrdem == 5
	If !Empty(cTpRtProv)
		cInicio  :=  (cAliasSRA)+"->RA_FILIAL+"+(cAliasSRA)+"->RHT_CC+"+(cAliasSRA)+"->RA_MAT"
   	Else
   		cInicio  :=  (cAliasSRA)+"->RA_FILIAL+"+(cAliasSRA)+"->RT_CC+"+(cAliasSRA)+"->RA_MAT"
   	Endif
   	cFim	 :=  cFilAte + cCcAte + cMatAte
   	aIndice  :=	 {"PR_FILIAL","PR_CCMVTO","PR_MAT"}
ElseIf nOrdem == 6//"C.Custo + Item + Classe"
	cInicio  := (cAliasSRA)+"->RA_FILIAL+"+(cAliasSRA)+"->RA_CC+"+(cAliasSRA)+"->RA_MAT"
	cFim	 := cFilAte + cCcAte + cMatAte
	aIndice  := {"PR_FILIAL","PR_CC","PR_ITEM","PR_CLVL","PR_MAT"}
Endif

// MONTA MATRIZ COM OS FUNCIONARIOS TRANSFERIDOS NO MES CONTEUDO DA MATRIZ - EMPRESA + FILIAL + CC + MATRICULA
aTransf := {}
fSeleTransf(@aTransf, dDataRef,cTpc)

// CRIA O ARQUIVO TEMPORARIO "TPR" PARA IMPRESSAO DA PROVISAO
Cria_TPR(aIndice)

// SELECIONA O SRA PARA A MONTAGEM DO ARQUIVO TPR
dbSelectArea(cAliasSRA)

// CARREGA REGUA DE PROCESSAMENTO
If !lSegPlan 
	ProcRegua(RecCount())
Endif

While !Eof() .And. &cInicio <= cFim
	// MOVIMENTA REGUA DE PROCESSAMENTO
	If !lSegPlan 
		IncProc(STR0014) // "Selecionando Registros..."
	Endif

	// INDICA O TIPO DE MOVIMENTO DO FUNCIONARIO
	nTpMv 		:= 0
	lTransfEmp	:= .F.
	aSRASRT	:= {}
	aVerbasTPR	:= {}
	//Posiciona o SRA para a correta leitura dos afastamentos
	SRA->(DbGoTo((cAliasSRA)->R_E_C_N_O_))

	If ! Empty(cFiltroRel) .And. ! SRA->(&(cFiltroRel))
		(cAliasSRA)->(dbSkip())
		Loop
	EndIf

	If !Empty(cTpRtProv)
		// VERIFICA SE ESTA AFASTADO NA DATA DE REFERENCIA DO CALCULO
		cSitFolh := cTipAfas := ""
		dAfaIni  := dAfaFim	 := CtoD("")
		fChkAfas((cAliasSRA)->RA_FILIAL,(cAliasSRA)->RA_MAT,dDataRef,@dAfaIni,@dAfaFim,@cTipAfas)
		cSitFolh := If(!Empty(cTipAfas) .And. cTipAfas # "F" .and. ( Empty(dAfaFim) .or. dAfaFim >= dDataRef) , "A", cSitFolh)

		If lItemClVl
			aAdd(aSRASRT,{(cAliasSra)->RA_FILIAL,(cAliasSra)->RA_MAT,(cAliasSra)->RA_CC,(cAliasSra)->RA_NOME,;
			(cAliasSra)->RA_ADMISSA,(cAliasSra)->RA_DEMISSA,cSitFolh,cTipAfas,If( Empty( (cAliasSRA)->RA_TPCONTR ), "1", (cAliasSRA)->RA_TPCONTR ),;
			(cAliasSra)->RA_HRSMES,(cAliasSra)->RA_PERICUL,If (lSalInc,(cAliasSra)->RA_SALINCO,""),(cAliasSra)->RHT_CC,;
			(cAliasSra)->RA_INSMAX,(cAliasSra)->RA_ADTPOSE,(cAliasSra)->RHT_ITEM,(cAliasSra)->RHT_CLVL})
		Else
			aAdd(aSRASRT,{(cAliasSra)->RA_FILIAL,(cAliasSra)->RA_MAT,(cAliasSra)->RA_CC,(cAliasSra)->RA_NOME,;
			(cAliasSra)->RA_ADMISSA,(cAliasSra)->RA_DEMISSA,cSitFolh,cTipAfas,If( Empty( (cAliasSRA)->RA_TPCONTR ), "1", (cAliasSRA)->RA_TPCONTR ),;
			(cAliasSra)->RA_HRSMES,(cAliasSra)->RA_PERICUL,If (lSalInc,(cAliasSra)->RA_SALINCO,""),(cAliasSra)->RHT_CC,;
			(cAliasSra)->RA_INSMAX,(cAliasSra)->RA_ADTPOSE})
		EndIf
	EndIf

	If !lIncTodos
		cCusto 		:=  ""
		cCustoAtu	:=  ""
		cClvl 		:=  ""
		cClvlAtu 	:=  ""
		cItem 		:=  ""
		cItemAtu 	:=  ""

		// CONSISTE CONTROLE DE ACESSOS E FILIAIS VALIDAS
		If !((cAliasSRA)->RA_FILIAL $ fValidFil()) .Or. !Eval(bChkSRA)
			dbSkip()
			Loop
		EndIf

		// CONSISTE DEMISSAO E TRANSFERENCIA (SE FOR TRANSFERENCIA SAIDA DESPREZA O FUNCIONARIO POIS SERA TRATADO NO ARRAY aTransf
		If (cAliasSRA)->RA_SITFOLH == "D"
			//nPosFunc := Ascan(aTransf,{ |X| X[_TAnter,_TFil]+X[_TAnter,_TMat]+X[_TAnter,_TCC] == (cAliasSRA)->RA_FILIAL+(cAliasSRA)->RA_MAT+(cAliasSRA)->RA_CC })
			// SE TRANSF. SAIDA NO MES/ANO E NAO ENCONTRAR NO ARRAY OU O LTRANSFEMP FOR .T. (EMPRESA ANTERIOR E EMPRESA DESTINO
			// FOR DIFERENTE) INDICA QUE E UMA TRANSFERENCIA ENTRE EMPRESAS E DEVERA SER INCLUIDO MOV. SAIDA
	     	nPosFunc := Ascan(aTransf, { |X| X[_TAnter,_TEmp]+X[_TAnter,_TFil]+X[_TAnter,_TMat] == cEmpAnt+(cAliasSRA)->RA_FILIAL+(cAliasSRA)->RA_MAT })
  	  	  	If nPosFunc > 0
				lTransfEmp	:= aTransf[nPosFunc,_TAnter,_TEmp] <> aTransf[nPosFunc,_TDest,_TEmp] .And. aTransf[nPosFunc,_TAnter,_TEmp] <> aTransf[nPosFunc,_TAtual,_TEmp]
  				cCusto  	:= aTransf[nPosFunc,_TAnter,_TCC] // Centro de custo anterior
			    cCustoAtu	:= aTransf[nPosFunc,_TAtual,_TCC] // Centro de custo atual
  				If lItemClVl
					cItem  		:= aTransf[nPosFunc,_TAnter,_TItem]// Item anterior
					cItemAtu	:= aTransf[nPosFunc,_TAtual,_TItem]// Item atual
					cClvl   	:= aTransf[nPosFunc,_TAnter,_TClvl]// Classe anterior
					cClvlAtu	:= aTransf[nPosFunc,_TAtual,_TClvl]// Classe atual
				EndIf
 	 	  	Else
				lTransfEmp	:= .F.
				// SE NAO FOR TRANSFERENCIA EMPRESA, FILIAL+MATRICULA ANTERIOR IGUAL RA_FILIAL+RA_MAT,
				// EMPRESA + FILIAL ANTERIOR DIFERENTE DA EMPRESA + FILIAL DESTINO, E MES\ANO ATUAL
				//	IGUAL AO MES\ANO DESTINO,  UTILIZAR C.CUSTO DO ATRANSF  ANTERIOR, E MARCAR FUNCIONARIO
				// PARA QUE NAO SER INCLUIDO (ANALISE FEITA NA PARTE "INCLUI OS TRANSFERIDOS ENTRE CC
	 			//  NO ARQUIVO DE PROVISAO" - ANALISE DAS TRANSFERENCIAS)
				cCusto:= (cAliasSRA)->RA_CC
				If lItemClVl
					cItem := (cAliasSRA)->RA_ITEM
					cClvl := (cAliasSRA)->RA_CLVL
				EndIf
			EndIf
			// NAO GRAVAR MOVIMENTO SE FOR MES\ANO DA TRANSFERENCIA, NAO UTILIZA IDENTIFICADOR
			// DE BAIXA DE TRANSFERENCIA E NAO SEJA TRANSFERENCIA ENTRE EMPRESAS
			If !lTrataTrf .and. !lTransfEmp .and. ;
				MesAno((cAliasSRA)->RA_DEMISSA) == MesAno(dDataRef) .And. (AllTrim((cAliasSRA)->RA_AFASFGT) $ "5*N*N1*N2") .And. (nPosFunc == 0 .Or. (nPosFunc > 0 .And. lTransfEmp))
				dbSkip()
				Loop
			EndIf
			// NA TRANSFERENCIA POR EMPRESA, VERIFICAR SE MES\ANO TRANSF. E O MESMA QUE MES\ANO DE REF. PARA
			//GARANTIR NA EMPRESA ORIGEM A MOVIMENTACAO DE SAIDA, INDEPENDENTE DO DESTINO (ULTIMA TRANSF)
			If	(((nPosFunc > 0 .And.lTransfEmp).And. ;
						(aTransf[nPosFunc,_TAnter,_TDta] == aTransf[nPosFunc,_TAtual,_TDta]) .and. ;
						(aTransf[nPosFunc,_TAtual,_TDta] == MesAno(dDataRef))	);
					.Or. (MesAno((cAliasSRA)->RA_DEMISSA) == MesAno(dDataRef) .And. AllTrim((cAliasSRA)->RA_AFASFGT) $ "5*N*N1*N2" .And. (nPosFunc == 0 .Or.	(nPosFunc > 0 .And. lTransfEmp))))
				nTpMv := _Trfe_Sai
			ElseIf MesAno((cAliasSRA)->RA_DEMISSA) == MesAno(dDataRef) .And. !(AllTrim((cAliasSRA)->RA_AFASFGT) $ "5*N*N1*N2") .And. lIncDemit .And. (nPosFunc == 0 .Or. !Empty((cAliasSRA)->RA_AFASFGT))
				nTpMv := _Demitido
			ElseIf MesAno((cAliasSRA)->RA_DEMISSA) < MesAno(dDataRef) .Or. ((AllTrim((cAliasSRA)->RA_AFASFGT) $ "5*N*N1*N2" .Or. Empty((cAliasSRA)->RA_AFASFGT)) .And. nPosFunc > 0 .And. !lTransfEmp) .Or.;
				   (MesAno((cAliasSRA)->RA_DEMISSA) == MesAno(dDataRef) .And. !lIncDemit) .Or. (MesAno((cAliasSRA)->RA_DEMISSA) > MesAno(dDataRef) .And. AllTrim((cAliasSRA)->RA_AFASFGT) $ "5*N*N1*N2" .And. !lTransfEmp .And. nPosFunc == 0 .And. !fTransfExterna(cAliasSRA))
				dbSkip()
				Loop
			EndIf
		EndIf
	EndIf
	
	// VERIFICA SE FUNCIONARIO FOI TRANSFERIDO APOS DATA REFERENCIA
	If Empty(cTpRtProv)
		nPosFunc := Ascan(aTransf, { |X| X[_TDest,_TEmp]+X[_TDest,_TFil]+X[_TDest,_TCC]+X[_TDest,_TMat] == cEmpAnt+(cAliasSRA)->RA_FILIAL+(cAliasSRA)->RA_CC+(cAliasSRA)->RA_MAT })

		// Verifica se houve transferencia para Outra Empresa e depois retorna para a Mesma
		nPosFunc2 := Ascan(aTransf, { |X| X[_TAnter,_TEmp]+X[_TAnter,_TFil]+X[_TAnter,_TMat] == cEmpAnt+(cAliasSRA)->RA_FILIAL+(cAliasSRA)->RA_MAT .And. X[_TDest,_TEmp]+X[_TDest,_TFil]+X[_TDest,_TMat] <> cEmpAnt+(cAliasSRA)->RA_FILIAL+(cAliasSRA)->RA_MAT})
		lTransfRet := .F.
		If nPosFunc2 > 0 .And. nPosFunc > 0 .And. nPosFunc2 <> nPosFunc
			If lGPEM070
				lTransfRet := .T.
			EndIf
			// Apenas para Impressao
			If (lGPER070 .Or. lGPER090) .And. aTransf[nPosFunc2, _TAnter, _TEmp] <> aTransf[nPosFunc2, _TDest, _TEmp]
				aTransf[nPosFunc2][_TAtual] := aClone(aTransf[nPosFunc2][_TAnter])
				aTransf[nPosFunc2][_TAtual][_TInc] := .T.
			EndIf
		EndIf
		
		If lGPEM110
			// Verifica se houve transferencia para Outra Centro de custo e depois retorna para o Mesmo
			nPosFunc2 := Ascan(aTransf, { |X| X[_TAnter,_TEmp]+X[_TAnter,_TFil]+X[_TAnter,_TMat]+X[_TAnter,_TCC] == cEmpAnt+(cAliasSRA)->RA_FILIAL+(cAliasSRA)->RA_MAT+(cAliasSRA)->RA_CC})
			If nPosFunc2 > 0 .And. nPosFunc > 0 .And. nPosFunc2 <> nPosFunc
				aTransf[nPosFunc2][_TAtual][_TInc] := .T.
			EndIf
		EndIf
		
		If nPosFunc > 0
			nPosFunc3 := Ascan(aTransf, { |X| X[_TDest,_TEmp]+X[_TDest,_TFil]+X[_TDest,_TCC]+X[_TDest,_TMat] == aTransf[nPosFunc,_TAnter,_TEmp]+aTransf[nPosFunc,_TAnter,_TFil]+aTransf[nPosFunc,_TAnter,_TCC]+aTransf[nPosFunc,_TAnter,_TMat]})
			If (nPosFunc3 == 0 .Or. aTransf[nPosFunc3,_TDest,_TDta] < MesAno(dDataRef) .Or. aTransf[nPosFunc,_TDest,_TDta] > MesAno(dDataRef) .Or.;
				((lGPEM110 .Or. aTransf[nPosFunc,_TDest ,_TFil] <> aTransf[nPosFunc3,_TDest,_TFil]) .And. aTransf[nPosFunc,_TDest ,_TEmp]+aTransf[nPosFunc,_TDest ,_TFil]+aTransf[nPosFunc,_TDest ,_TCC]+aTransf[nPosFunc,_TDest ,_TMat] == aTransf[nPosFunc3,_TAnter,_TEmp]+aTransf[nPosFunc3,_TAnter,_TFil]+aTransf[nPosFunc3,_TAnter,_TCC]+aTransf[nPosFunc3,_TAnter,_TMat])) .And.; 
				!(	aTransf[nPosFunc,_TAtual,_TEmp]+aTransf[nPosFunc,_TAtual,_TFil]+aTransf[nPosFunc,_TAtual,_TCC]+aTransf[nPosFunc,_TAtual,_TMat] == ;
				  	aTransf[nPosFunc,_TDest ,_TEmp]+aTransf[nPosFunc,_TDest ,_TFil]+aTransf[nPosFunc,_TDest ,_TCC]+aTransf[nPosFunc,_TDest ,_TMat]  ;
				 )
				If aTransf[nPosFunc,_TDest,_TDta] > MesAno(dDataRef) // data de transferencia maior que data de processamento
					// Processa Transferencia de SaÌda para impress„o de dados de baixa
					lTransCC := aTransf[nPosFunc,_TAnter,_TEmp] == aTransf[nPosFunc,_TDest,_TEmp] .And. aTransf[nPosFunc,_TAnter,_TFil] == aTransf[nPosFunc,_TDest ,_TFil] .And. aTransf[nPosFunc,_TAnter,_TCC] <> aTransf[nPosFunc,_TDest ,_TCC]
					If ( lGProvSRV .And. ((aTransf[nPosFunc,_TAnter,_TEmp] <> aTransf[nPosFunc,_TDest,_TEmp]) .Or. (aTransf[nPosFunc,_TAnter,_TFil] <> aTransf[nPosFunc,_TDest,_TFil])) ) .Or.;
					( (lGPER070 .Or. lGPER090) .And. ;
					!((aTransf[nPosFunc,_TAnter,_TEmp] <> aTransf[nPosFunc,_TDest,_TEmp]) .And. (aTransf[nPosFunc,_TAnter,_TDta] == aTransf[nPosFunc,_TAtual,_TDta])) .And. !(lTransCC .And. nPosFunc3 == 0)) .Or. (lGPEM070 .And. !lTransfRet)
						aTransf[nPosFunc,_TDest,_TInc] := .T.  // Marca funcionario para que nao seja incluido
						dbSelectArea(cAliasSRA)
						dbSkip()
						Loop
					EndIf
				EndIf
			EndIf
			aTransf[nPosFunc,_TDest,_TInc] := .T.  // Marca funcionario para que nao seja incluido
		EndIf
	EndIf
	// VERIFICA SE E TRANSFERENCIA ENTRADA
	If nTpMv == 0 .And. Empty(cTpRtProv)
		nPosFunc := Ascan(aTransf, { |X| X[_TAtual,_TEmp]+X[_TAtual,_TFil]+X[_TAtual,_TCC]+X[_TAtual,_TMat] == cEmpAnt+((cAliasSRA)->RA_FILIAL)+(cAliasSRA)->RA_CC+(cAliasSRA)->RA_MAT })
		If nPosFunc == 0 .And. (lGP095IMP .Or. lGPER070 .Or. lGPER090)
			nPosFunc := Ascan(aTransf, { |X| X[_TAtual,_TEmp]+X[_TAtual,_TFil]+X[_TAtual,_TCC]+X[_TAtual,_TMat] == cEmpAnt+((cAliasSRA)->RA_FILIAL)+X[_TAnter,_TCC]+(cAliasSRA)->RA_MAT })
		Endif
		//SE TRANSFERIDO APOS DATA DE REFERENCIA, DESPREZA FUNCIONARIO, CASO CONTRARIO, MARCA TRANSF. ENTRADA PARA CALCULO/IMPRESSAO
		If nPosFunc > 0
			If !(;
				( lItemClVl .And.;
				aTransf[nPosFunc,_TAtual,_TEmp]+aTransf[nPosFunc,_TAtual,_TFil]+aTransf[nPosFunc,_TAtual,_TCC]+aTransf[nPosFunc,_TAtual,_TMat]+aTransf[nPosFunc,_TAtual,_TItem]+aTransf[nPosFunc,_TAtual,_TClvl] == ;
				aTransf[nPosFunc,_TAnter,_TEmp]+aTransf[nPosFunc,_TAnter,_TFil]+aTransf[nPosFunc,_TAnter,_TCC]+aTransf[nPosFunc,_TAnter,_TMat]+aTransf[nPosFunc,_TAnter,_TItem]+aTransf[nPosFunc,_TAnter,_TClvl] .And. ;
				aTransf[nPosFunc,_TAtual,_TEmp]+aTransf[nPosFunc,_TAtual,_TFil]+aTransf[nPosFunc,_TAtual,_TCC]+aTransf[nPosFunc,_TAtual,_TMat]+aTransf[nPosFunc,_TAtual,_TItem]+aTransf[nPosFunc,_TAtual,_TClvl] == ;
				aTransf[nPosFunc,_TDest ,_TEmp]+aTransf[nPosFunc,_TDest ,_TFil]+aTransf[nPosFunc,_TDest ,_TCC]+aTransf[nPosFunc,_TDest ,_TMat]+aTransf[nPosFunc,_TDest ,_TItem]+aTransf[nPosFunc,_TDest ,_TClvl]  ;
				);
				.Or.;
				( !lItemClVl .And.;
				aTransf[nPosFunc,_TAtual,_TEmp]+aTransf[nPosFunc,_TAtual,_TFil]+aTransf[nPosFunc,_TAtual,_TCC]+aTransf[nPosFunc,_TAtual,_TMat] == ;
				aTransf[nPosFunc,_TAnter,_TEmp]+aTransf[nPosFunc,_TAnter,_TFil]+aTransf[nPosFunc,_TAnter,_TCC]+aTransf[nPosFunc,_TAnter,_TMat] .And. ;
				aTransf[nPosFunc,_TAtual,_TEmp]+aTransf[nPosFunc,_TAtual,_TFil]+aTransf[nPosFunc,_TAtual,_TCC]+aTransf[nPosFunc,_TAtual,_TMat] == ;
				aTransf[nPosFunc,_TDest ,_TEmp]+aTransf[nPosFunc,_TDest ,_TFil]+aTransf[nPosFunc,_TDest ,_TCC]+aTransf[nPosFunc,_TDest ,_TMat]  ;
				);
				)
				If aTransf[nPosFunc,_TAtual,_TDta] == MesAno(dDataRef)
					nTpMv := _Trfe_Ent 						 // Transferencia Entrada
					aTransf[nPosFunc,_TAtual,_TInc] := .T.  // Marca funcionario para que nao seja incluido
				ElseIf !(aTransf[nPosFunc,_TAtual,_TEmp] <> aTransf[nPosFunc,_TDest,_TEmp])
					dbSelectArea( cAliasSRA )
					dbSkip()
					Loop
				EndIf
			EndIf
		EndIf
	EndIf
	If Empty(cTpRtProv)
		// VERIFICA SE ESTA AFASTADO NA DATA DE REFERENCIA DO CALCULO
		cSitFolh := cTipAfas := ""
		dAfaIni  := dAfaFim	 := CtoD("")
		fChkAfas((cAliasSRA)->RA_FILIAL,(cAliasSRA)->RA_MAT,dDataRef,@dAfaIni,@dAfaFim,@cTipAfas)
		cSitFolh := If(!Empty(cTipAfas) .And. cTipAfas # "F" .and. ( Empty(dAfaFim) .or. dAfaFim >= dDataRef) , "A", cSitFolh)
	Else
		If (nTpMv <> 6 .And. nTpMv <> 0 .And. AnoMes(dDataRef) > AnoMes(QSRA->RA_DEMISSA))   // Trans.Entrada ou Demissao
			dbSelectArea(cAliasSRA)
			dbSkip()
			Loop
		Endif
	EndIf

	If !Empty(cTpRtProv)
		nPosFunc := Ascan(aTransf, { |X| X[_TDest,_TEmp]+X[_TDest,_TFil]+X[_TDest,_TCC]+X[_TDest,_TMat] == cEmpAnt+(cAliasSRA)->RA_FILIAL+(cAliasSRA)->RA_CC+(cAliasSRA)->RA_MAT })
        If nPosFunc > 0
        	aTransf[nPosFunc,_TDest,_TInc] := .T.
        Endif
    Endif

	cCusto	:= ""
	cItem	:= ""
	cClvl	:= ""

	nPos	:= aScan(aTransf, { |X| X[_TAtual,_TEmp]+X[_TAtual,_TFil]+X[_TAtual,_TMat]+X[_TAtual,_TDta] == cEmpAnt+(cAliasSRA)->RA_FILIAL+(cAliasSRA)->RA_MAT+AnoMes(dDataRef) } )
	nTPosCc := If (!Empty(aCcEmpTra), aScan(aCcEmpTra, { |x| x[1,4] == SRA->RA_MAT .And. x[1,9] == .T.}),0)

	If nPos == 0
		nPos	:= aScan(aTransf, { |X| X[_TAtual,_TEmp]+X[_TAtual,_TFil]+X[_TAtual,_TMat] == cEmpAnt +(cAliasSRA)->RA_FILIAL+(cAliasSRA)->RA_MAT } )
		If nPos > 0
			cCusto:= aTransf[nPos][_TAtual][_TCC]
			If lItemClVl
				cItem	:= aTransf[nPos][_TAtual][_TItem]
				cClvl	:= aTransf[nPos][_TAtual][_TClvl]
			EndIf
		Endif
	Else
		cCusto:= aTransf[nPos][_TAtual][_TCC]
		If lItemClVl
			cItem	:= aTransf[nPos][_TAtual][_TItem]
			cClvl	:= aTransf[nPos][_TAtual][_TClvl]
		EndIf
	Endif

	dbSelectArea(cTBLXPROV)
    RecLock(cTBLXPROV, .T.)

	(cTBLXPROV)->PR_FILIAL  := (cAliasSRA)->RA_FILIAL
	(cTBLXPROV)->PR_MAT     := (cAliasSRA)->RA_MAT
	(cTBLXPROV)->PR_NOME    := (cAliasSRA)->RA_NOME

	If Empty(cCusto) .And. nTpMv != 6 .And. nTPosCc == 0
		(cTBLXPROV)->PR_CC	:= (cAliasSRA)->RA_CC
	ElseIf Empty(cCusto) .And. nTpMv != 6 .And. nTPosCc > 0 .And. !Empty(aCcEmpTra)
		(cTBLXPROV)->PR_CC	:= aCcEmpTra[nTPosCc,1,6]
	Else
		If nTpMv==6 .or. nTpMv==1   // Trans.Entrada ou Demissao
			(cTBLXPROV)->PR_CC	:= If(Empty(cCustoAtu), cCusto, cCustoAtu)  //Gravar c.custo atual
  		Else
			(cTBLXPROV)->PR_CC	:= cCusto     //Gravar c.custo da origem
		EndIf
	EndIf

	If lItemClVl
		If Empty(cItem) .And. nTpMv != 6
			(cTBLXPROV)->PR_ITEM    := (cAliasSRA)->RA_ITEM
		Else
			If nTpMv==6 .or. nTpMv==1   // Trans.Entrada ou Demissao
				(cTBLXPROV)->PR_ITEM	:= If(Empty(cItemAtu), cItem, cItemAtu)  //Gravar item atual
	  		Else
				(cTBLXPROV)->PR_ITEM	:= cItem     //Gravar item da origem
			EndIf
		EndIf
		If Empty(cClvl) .And. nTpMv != 6
			(cTBLXPROV)->PR_CLVL    := (cAliasSRA)->RA_CLVL
		Else
			If nTpMv==6 .or. nTpMv==1   // Trans.Entrada ou Demissao
				(cTBLXPROV)->PR_CLVL	:= If(Empty(cClvlAtu), cClvl, cClvlAtu)  //Gravar classe atual
	  		Else
				(cTBLXPROV)->PR_CLVL	:= cClvl     //Gravar classe da origem
			EndIf
		EndIf
	EndIf
	(cTBLXPROV)->PR_ADMISSA := (cAliasSRA)->RA_ADMISSA
	(cTBLXPROV)->PR_DEMISSA := If(mesano((cAliasSRA)->RA_DEMISSA) <= mesano(dDataRef) , (cAliasSRA)->RA_DEMISSA,cTod(" / / "))
	(cTBLXPROV)->PR_SITFOLH := cSitFolh
	(cTBLXPROV)->PR_AFASFGT := cTipAfas
	(cTBLXPROV)->PR_TPCONTR := If( Empty( (cAliasSRA)->RA_TPCONTR ), "1", (cAliasSRA)->RA_TPCONTR )
	(cTBLXPROV)->PR_HRSMES  := (cAliasSRA)->RA_HRSMES
	(cTBLXPROV)->PR_PERICUL := (cAliasSRA)->RA_PERICUL
	(cTBLXPROV)->PR_INSMAX	:= (cAliasSra)->RA_INSMAX
	(cTBLXPROV)->PR_ADTPOSE	:= (cAliasSra)->RA_ADTPOSE
	(cTBLXPROV)->PR_TIPMOVI := nTpMv  // Demitido, Transf. Saida ou Transf. Entrada
	(cTBLXPROV)->PR_CATFUNC := (cAliasSRA)->RA_CATFUNC
	If lSalInc
		(cTBLXPROV)->PR_SALINCO := (cAliasSRA)->RA_SALINCO
	EndIf
	If !Empty(cTpRtProv)
		(cTBLXPROV)->PR_CCMVTO := (cAliasSRA)->RHT_CC
		If lItemClVl
			(cTBLXPROV)->PR_ITMMVTO := (cAliasSRA)->RHT_ITEM
			(cTBLXPROV)->PR_CLVMVTO := (cAliasSRA)->RHT_CLVL
		EndIf
	EndIf
	If lINSSAut
		(cTBLXPROV)->PR_INSSAUT := (cAliasSRA)->RA_INSSAUT
	EndIf
	MsUnlock()

	dbSelectArea(cAliasSRA)
	dbSkip()
EndDo

// GARANTE ORDEM 1 PARA BUSCA DOS FUNCIONARIOS
(cAliasSRA)->( DbCloseArea() )
SRA->( DbCloseArea() )
DbSelectArea("SRA")
SRA->( DbSetOrder(1) )

// INCLUI OS TRANSFERIDOS ENTRE CC NO ARQUIVO DE PROVISAO
For nK1 := 1 To Len(aTransf)
	If (SRA->( DbSeek(aTransf[nK1,_TDest,_TFil] + aTransf[nK1,_TDest,_TMat]) ) .And. ;
			 aTransf[nK1,_TDest,_TEmp] == cEmpAnt) .OR. ;
			 (SRA->( DbSeek(aTransf[nK1,_TAtual,_TFil] + aTransf[nK1,_TAtual,_TMat]) ) .And. ;
			 aTransf[nK1,_TAtual,_TEmp] == cEmpAnt) 
		
		If (SRA->RA_SITFOLH == "D" .And. (MesAno(SRA->RA_DEMISSA) <= MesAno(dDataRef) .and.;
			MesAno(SRA->RA_DEMISSA) < aTransf[nK1,_TAtual,_TDta]) .and. !(AllTrim(SRA->RA_AFASFGT) $ "5*N*N1*N2"))
			Loop
		EndIf
		// CONSISTE CATEGORIA E DEMISSAO DO FUNCIONARIO
		If !(SRA->RA_CATFUNC $ cCateg) .Or. (SRA->RA_SITFOLH == "D" .And.;
		   MesAno(SRA->RA_DEMISSA) < MesAno(dDataRef))
			Loop
		EndIf

		If ! Empty(cFiltroRel) .And. ! SRA->(&(cFiltroRel))
			Loop
		EndIf

		For nK2 := 1 To 2
			nTrfProc := If(nK2 == 1, _TAnter, _TAtual)
			// VERIFICACAO DO ELEMENTO ANTERIOR DO array aTransf
			If nK2 == 1
				// SE NAO TRATA TRANSFERIDO, NAO INCLUIR TRANSFERENCIA ORIGEM EFETUADA NO MES DE PROCESSAMENTO. SOMENTE INCLUIR POSTERIORES
				If !lTrataTrf .And. aTransf[nK1,_TAnter,_TDta] == MesAno(dDataRef)
					Loop
				EndIf
				// VERIFICA SE OS ELEMENTOS ANTERIOR E ATUAL SAO IGUAIS OU SE A TRANSFERENCIA ANTERIOR PARA ATUAL FOI ENTRE FILIAL
				If ( ( lItemClVl .And. aTransf[nK1,_TAnter,_TFil]+aTransf[nK1,_TAnter,_TCC]+aTransf[nK1,_TAnter,_TMat]+aTransf[nK1,_TAnter,_TItem]+aTransf[nK1,_TAnter,_TClvl] ==;
				    aTransf[nK1,_TAtual,_TFil]+aTransf[nK1,_TAtual,_TCC]+aTransf[nK1,_TAtual,_TMat]+aTransf[nK1,_TAtual,_TItem]+aTransf[nK1,_TAtual,_TClvl] ) ;
					.Or.;
					( !lItemClVl .And. aTransf[nK1,_TAnter,_TFil]+aTransf[nK1,_TAnter,_TCC]+aTransf[nK1,_TAnter,_TMat]==;
				    aTransf[nK1,_TAtual,_TFil]+aTransf[nK1,_TAtual,_TCC]+aTransf[nK1,_TAtual,_TMat] ) ) .or. ;
				    aTransf[nK1,_TAnter,_TInc] .or. ;
				    aTransf[nK1,_TAnter,_TEmp] <> cEmpAnt
				    Loop
				EndIf
			Else
				// VERIFICA SE ATUAL == DESTINO E JA INCLUI DESTINO OU SE A EMPRESA ATUAL E DIFERENTE DA EMPRESA CORRENTE
				If (;
					( lItemClVl .And. aTransf[nK1,_TAtual,_TFil]+aTransf[nK1,_TAtual,_TCC]+aTransf[nK1,_TAtual,_TMat]+aTransf[nK1,_TAtual,_TItem]+aTransf[nK1,_TAtual,_TClvl]==;
				     aTransf[nK1,_TDest,_TFil]+aTransf[nK1,_TDest,_TCC]+aTransf[nK1,_TDest,_TMat]+aTransf[nK1,_TDest,_TItem]+aTransf[nK1,_TDest,_TClvl] .And. aTransf[nK1,_TDest,_TInc]) .Or. ;
					( !lItemClVl .And. aTransf[nK1,_TAtual,_TFil]+aTransf[nK1,_TAtual,_TCC]+aTransf[nK1,_TAtual,_TMat]==;
				     aTransf[nK1,_TDest,_TFil]+aTransf[nK1,_TDest,_TCC]+aTransf[nK1,_TDest,_TMat] .And. aTransf[nK1,_TDest,_TInc]) ) .Or. ;
				     ( aTransf[nK1,_TAtual,_TEmp] <> cEmpAnt )
				    Loop
				EndIf
			EndIf
			// CONSISTE PARAMETROS SELECIONADO PELO USUARIO
			If 	(aTransf[nK1,nTrfProc,_TFil]  < cFilDe) .Or. (aTransf[nK1,nTrfProc,_TFil] > cFilAte) .Or. ;
				(aTransf[nK1,nTrfProc,_TCC]  < cCcDe)	.Or. (aTransf[nK1,nTrfProc,_TCC]  > cCCAte)  .Or. ;
				(aTransf[nK1,nTrfProc,_TMat] < cMatDe)	.Or. (aTransf[nK1,nTrfProc,_TMat] > cMatAte) .Or. ;
				(SRA->RA_NOME < cNomeDe) .Or. (SRA->RA_NOME > cNomeAte)
				Loop
			EndIf
			// CONSISTE CONTROLE DE ACESSOS E FILIAIS VALIDAS
			If  !(aTransf[nK1,nTrfProc,_TFil] $ fValidFil()) .Or. !SRA->(Eval(bChkSRE))
				Loop
			EndIf

			nPosTransf := AScan(aTransf, { |X| X[_TDest,_TEmp]+X[_TDest,_TFil]+X[_TDest,_TMat] == aTransf[nK1,_TAnter,_TEmp]+aTransf[nK1,_TAnter,_TFil]+aTransf[nK1,_TAnter,_TMat] })


			If nPosTransf > 0 .And. aTransf[nK1,_TDest,_TDta] > AnoMes(dDataRef)
				If lM110Proc .And. aTransf[nK1,_TAtual,_TEmp]+aTransf[nK1,_TAtual,_TFil]+aTransf[nK1,_TAtual,_TCC]+aTransf[nK1,_TAtual,_TMat] != aTransf[nK1,_TDest,_TEmp]+aTransf[nK1,_TDest,_TFil]+aTransf[nK1,_TDest,_TCC]+aTransf[nK1,_TDest,_TMat] .And. (aTransf[nK1, _TDest, _TInc] .Or. aTransf[nPosTransf, _TAtual, _TInc])
					Loop
				Elseif (nPosTransf < nK1)
					Loop
				Endif
			EndIf

			// VERIFICA SE FUNCIONARIO JA FOI INCLUIDO
		   	dbSelectArea(cTBLXPROV)
			If !aTransf[nK1,nTrfProc,_TInc]
				nPR_TIPMOVI := 0
				// Se transferido no mes/ano da referencia, indica saida.≥
				If nK2 == 1 .And. aTransf[nK1,_TAnter,_TDta] == MesAno(dDataRef)
					nPR_TIPMOVI := _Trfe_Sai
				ElseIf nK2 == 2 .And. aTransf[nK1,_TAtual,_TDta] == MesAno(dDataRef) .And.;
				  aTransf[nK1,_TAnter,_TEmp] + aTransf[nK1,_TAnter,_TFil] + aTransf[nK1,_TAnter,_TCC] + aTransf[nK1,_TAnter,_TMat] #;
				  aTransf[nK1,_TAtual,_TEmp] + aTransf[nK1,_TAtual,_TFil] + aTransf[nK1,_TAtual,_TCC] + aTransf[nK1,_TAtual,_TMat]
					If nK1 == Len(aTransf) .or. aTransf[nK1+1,_TAtual,_TEmp] == aTransf[nK1,_TAnter,_TEmp]
						nPR_TIPMOVI := _Trfe_Ent
					Else
						Loop
					EndIf
				EndIf

				//Verifica a situacao folha e o tipo de afastamento na competencia de calculo
				cSitFolh := cTipAfas := ""
				dAfaIni  := dAfaFim	 := CtoD("")
				fChkAfas( aTransf[nK1,nTrfProc,_TFil], aTransf[nK1,nTrfProc,_TMat], dDataRef, @dAfaIni,@dAfaFim, @cTipAfas)
				cSitFolh := If(!Empty(cTipAfas) .And. cTipAfas # "F" .and. ( Empty(dAfaFim) .or. dAfaFim >= dDataRef) , "A", cSitFolh)

				If Empty(cTpRtProv)
			    	If lGPEM110 .And. nPR_TIPMOVI == _Trfe_Ent .And. (cTBLXPROV)->( dbSeek( aTransf[nK1,nTrfProc,_TFil] + aTransf[nK1,nTrfProc,_TCC] + Iif( lItemClVl, aTransf[nK1,nTrfProc,_TItem] + aTransf[nK1,nTrfProc,_TClvl], "" ) + aTransf[nK1,nTrfProc,_TMat] ) )
						RecLock(cTBLXPROV, .F.)
						(cTBLXPROV)->PR_TIPMOVI := nPR_TIPMOVI
					ElseIf (lGPEM110 .Or. lGPER070 .Or. lGPER090) .And. (nPR_TIPMOVI == _Trfe_Ent .Or. nPR_TIPMOVI == 0) .And.;
							(;
								(nOrdem == 1 .And. (cTBLXPROV)->( dbSeek( aTransf[nK1,nTrfProc,_TFil] + aTransf[nK1,nTrfProc,_TMat] ) ) ) .Or.;
								((nOrdem == 2 .Or. nOrdem == 5) .And. (cTBLXPROV)->( dbSeek( aTransf[nK1,nTrfProc,_TFil] + aTransf[nK1,nTrfProc,_TCC] + aTransf[nK1,nTrfProc,_TMat] ) ) ) .Or.;
								(nOrdem == 3 .And. (cTBLXPROV)->( dbSeek( aTransf[nK1,nTrfProc,_TFil] + SRA->RA_NOME + aTransf[nK1,nTrfProc,_TMat] ) ) ) .Or.;
								(nOrdem == 4 .And. (cTBLXPROV)->( dbSeek( aTransf[nK1,nTrfProc,_TFil] + aTransf[nK1,nTrfProc,_TCC] + SRA->RA_NOME ) ) ) .Or.;
								(cTBLXPROV)->( dbSeek( aTransf[nK1,nTrfProc,_TFil] + aTransf[nK1,nTrfProc,_TCC] + Iif( lItemClVl, aTransf[nK1,nTrfProc,_TItem] + aTransf[nK1,nTrfProc,_TClvl], "" ) + aTransf[nK1,nTrfProc,_TMat] ) );
							) .And. (cTBLXPROV)->PR_CC == aTransf[nK1,nTrfProc,_TCC] .And. Iif(lItemClVl, (cTBLXPROV)->PR_ITEM + (cTBLXPROV)->PR_CLVL == aTransf[nK1,nTrfProc,_TItem] + aTransf[nK1,nTrfProc,_TClvl], .T.)
						If nPR_TIPMOVI == _Trfe_Ent
							RecLock(cTBLXPROV, .F.)
							(cTBLXPROV)->PR_TIPMOVI := nPR_TIPMOVI
						Else
							Loop
						EndIf
					Else
						RecLock(cTBLXPROV, .T.)
						(cTBLXPROV)->PR_FILIAL  := aTransf[nK1,nTrfProc,_TFil] // Filial De
						(cTBLXPROV)->PR_MAT     := aTransf[nK1,nTrfProc,_TMat] // Matricula De
						(cTBLXPROV)->PR_CC      := aTransf[nK1,nTrfProc,_TCC]  // Centro de Custo De
						(cTBLXPROV)->PR_NOME    := SRA->RA_NOME
						(cTBLXPROV)->PR_ADMISSA := SRA->RA_ADMISSA
						(cTBLXPROV)->PR_DEMISSA := SRA->RA_DEMISSA
						(cTBLXPROV)->PR_SITFOLH := cSitFolh
						(cTBLXPROV)->PR_AFASFGT := cTipAfas
						(cTBLXPROV)->PR_TPCONTR := SRA->RA_TPCONTR
						(cTBLXPROV)->PR_HRSMES  := SRA->RA_HRSMES
						(cTBLXPROV)->PR_PERICUL := SRA->RA_PERICUL
						(cTBLXPROV)->PR_TIPMOVI := nPR_TIPMOVI
                        (cTBLXPROV)->PR_CATFUNC := SRA->RA_CATFUNC
						If lSalInc
							(cTBLXPROV)->PR_SALINCO := SRA->RA_SALINCO
						EndIf
						If lItemClVl
							(cTBLXPROV)->PR_ITEM    := aTransf[nK1,nTrfProc,_TItem] // Item Contabil
							(cTBLXPROV)->PR_CLVL    := aTransf[nK1,nTrfProc,_TClvl] // Classe de valor
						EndIf
					EndIf
					MsUnlock()
				EndIf
				aTransf[nK1,nTrfProc,_TInc] := .T.
			EndIf
		Next nK2
	EndIf
Next nK1

If !Empty(cTpRtProv)
	aSRASRT := {}
EndIf

Return
/*
‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±⁄ƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒø±±
±±≥Funcao    ≥ Cria_TPR ≥ Autor ≥ R.H.                ≥Data ≥  02.03.00   ≥±±
±±≥Vers„o 2.0≥          ≥       ≥ Leandro Drumond     ≥Data ≥  14.03.19   ≥±±
±±√ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒ¥±±
±±≥Descricao ≥ Cria  Arquivo de Trabalho para impressao da provisao       ≥±±
±±√ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¥±±
±±≥Sintaxe   ≥ CRIA_TPR(aIndice)                                ≥±±
±±√ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¥±±
±±≥Parametros≥ aIndice  - Chave do indice condicional                     ≥±±
±±√ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¥±±
±±≥Uso       ≥ Generico                                                   ≥±±
±±¿ƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒŸ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂ*/
Function Cria_TPR(aIndice, aInd2)
Local aFields
Local aTamCC	:= TamSX3("RA_CC")
Local aTamItem
Local aTamClVl
Local aTamCCMvto:= TamSX3("RT_CC")

If Type("lGrid") == "U"
	Private lGrid	:= .F.
EndIf

DEFAULT lItemClVl   := GetMvRH("MV_ITMCLVL", .F., "2") $ "13"
DEFAULT aInd2		:= {}

If lItemClVl
	aTamItem := TamSX3("RA_ITEM")
	aTamClVl := TamSX3("RA_CLVL")
Else
	aTamItem := TamSX3("RA_CC")
	aTamClVl := TamSX3("RA_CC")
EndIf

If Type("cTBLXPROV") == "U"
	Public cTBLXPROV := "TPR"
	If GetRpoRelease() >= "12.1.025"
		cTBLXPROV := "TBLXPROV"
	EndIf
EndIf

fDelTMPPRV()

aFields := {}

AADD(aFields, {"PR_FILIAL"	, "C", FWGETTAMFILIAL		, 0})
AADD(aFields, {"PR_MAT"		, "C", TamSx3("RA_MAT")[1]	, 0})
AADD(aFields, {"PR_CC"		, "C", aTamCC[1]			, 0})
AADD(aFields, {"PR_NOME"	, "C", 30					, 0})
AADD(aFields, {"PR_ADMISSA"	, "D", 08					, 0})
AADD(aFields, {"PR_DEMISSA"	, "D", 08					, 0})
AADD(aFields, {"PR_SITFOLH"	, "C", 01					, 0})
AADD(aFields, {"PR_AFASFGT"	, "C", 01					, 0})
AADD(aFields, {"PR_TPCONTR"	, "C", 01					, 0})
AADD(aFields, {"PR_HRSMES"	, "N", 06					, 2})
AADD(aFields, {"PR_SALINCO"	, "N", 12					, 2})
AADD(aFields, {"PR_PERICUL"	, "N", 06					, 2})
AADD(aFields, {"PR_INSMIN"	, "N", 06					, 2})
AADD(aFields, {"PR_INSMED"	, "N", 06					, 2})
AADD(aFields, {"PR_INSMAX"	, "N", 06					, 2})
AADD(aFields, {"PR_ADTPOSE"	, "C", 06					, 0})
AADD(aFields, {"PR_TIPMOVI"	, "N", 01					, 0})
AADD(aFields, {"PR_INSSAUT"	, "C", 01					, 0})
AADD(aFields, {"PR_CATFUNC"	, "C", 01					, 0})

//SE EXISTIR ITEM E CLASSE CRIA OS CAMPOS NA TABELA TEMPORARIA
AADD(aFields, {"PR_ITEM"   ,"C",aTamItem[1],0})
AADD(aFields, {"PR_CLVL"   ,"C",aTamClVl[1],0})
AADD(aFields, {"PR_CCMVTO"     ,"C",aTamCCMvto[1],0})
AADD(aFields, {"PR_ITMMVTO"    ,"C",aTamItem[1],0})
AADD(aFields, {"PR_CLVMVTO"    ,"C",aTamClVl[1],0})

/*
ATEN«√O : QUALQUER CAMPO CRIADO NESSA ESTRUTURA DEVE SER PASSADO NO ARRAY ACALL (GRID), E AO FAZER ISSO TESTAR O QUANTO AGUENTA O ARRAY ATE ESTOURAR A MEMORIA
*/

oTmpProv := FWTemporaryTable():New(cTBLXPROV,aFields)
oTmpProv:AddIndex( "TPRAUX1", aIndice )
If !Empty(aInd2)
	oTmpProv:AddIndex( "TPRAUX2", aInd2 )
EndIf
oTmpProv:Create()

Return Nil

/*/{Protheus.doc} fDelTMPPRV
//Fecha tabela temporaria e apaga
@author Leandro Drumond
@since 14/03/2019
/*/
Function fDelTMPPRV()

If Select(cTBLXPROV) > 0
	(cTBLXPROV)->(dbCloseArea())
EndIf

If oTmpProv <> Nil
	oTmpProv:Delete()
	oTmpProv := Nil
EndIf

Return Nil

/*/{Protheus.doc} fGetTMPPRV
//Retorna obje da tabela temporaria
@author Leandro Drumond
@since 14/03/2019
/*/
Function fGetTMPPRV()

Return oTmpProv

/*
‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±⁄ƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒø±±
±±≥Funcao	 ≥ fSeleTransf ≥ Autor ≥ Emerson R. de Souza≥ Data ≥ 17.09.99 ≥±±
±±√ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒ¥±±
±±≥DescriáÖo ≥ Seleciona Funcionarios Transferidos	no Mes			      ≥±±
±±√ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¥±±
±±≥Sintaxe	 ≥ fSeleTransf(aTransf,dDataProvisao)						  ≥±±
±±√ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¥±±
±±≥Parametros≥ aTransf       = Array que contera os transferido do mes    ≥±±
±±≥          ≥ dDataProvisao = Data Provisao P/ Selecao dos Transferidos  ≥±±
±±√ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¥±±
±±≥ Uso	 	 ≥ Generico   												  ≥±±
±±¿ƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒŸ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂ*/
Function fSeleTransf(aTransf, dDataProvisao, cTpc, cEmpOrig)
Local aArqSRE    	:= {}
Local aTrfAux    	:= {}
Local nPosTrf    	:= 0
Local cAlias     	:= ALIAS()
Local nTamRA_FILIAL := ""
Local cBusca     	:= ""
Local cAnoMesAux 	:= ""
Local cEmpTrf		:= ""
Local cChave
Local nSeqFor
Local nX
Local nLinAux		:= 0
Local aTipo         := {"A","B","C"}
Local aRetHash
Local nPos          := 0

Static oHash_SRE

DEFAULT cTpc		:= ""
DEFAULT lItemClVl   := GetMvRH("MV_ITMCLVL", .F., "2") $ "13"
DEFAULT cEmpOrig	:= ""
DEFAULT oHash_SRE	:= HMNew()
DEFAULT aCcEmpTra   := {}

cAnoMesR := MesAno(dDataProvisao)

dbSelectArea("SRE")
cIndCond:= "RE_DATA"
cFor:='Left(DTOS(RE_DATA),6) >= "'+cAnoMesR+'"'
cArqNtx1  := Subs(CriaTrab(NIL,.F.),1,7)+"A"
IndRegua("SRE",cArqNtx1,cIndCond,,cFor,STR0014)		//"Selecionando Registros..."
DbGoTop()

nTamRA_FILIAL := GetSx3Cache("RA_FILIAL", "X3_TAMANHO")

While SRE->(! Eof())
	cAnoMesAux := MesAno(SRE->RE_DATA)
	If (SRE->RE_EMPD == cEmpAnt .Or. SRE->RE_EMPP == cEmpAnt .Or. (!Empty(cEmpOrig) .And. SRE->RE_EMPD $ cEmpOrig)) .And.;
		(SRE->RE_EMPD != SRE->RE_EMPP .Or. Substr(SRE->RE_FILIALD,1,nTamRA_FILIAL) != Substr(SRE->RE_FILIALP,1,nTamRA_FILIAL) .Or. SRE->RE_CCD != SRE->RE_CCP .Or. SRE->RE_MATD != SRE->RE_MATP .Or. Iif(lItemClVl, SRE->RE_ITEMD != SRE->RE_ITEMP, .F.) .Or. Iif(lItemClVl, SRE->RE_CLVLD != SRE->RE_CLVLP, .F.))

		cChave := SRE->RE_EMPD + Substr(SRE->RE_FILIALD,1,nTamRA_FILIAL) + SRE->RE_CCD + SRE->RE_MATD + If(lItemClVl,SRE->RE_ITEMD+SRE->RE_CLVLD,"")

		If HMGet(oHash_SRE, cChave+"C", aRetHash) .and. Len(aArqSRE) >= aRetHash[10] .and. aArqSRE[aRetHash[10],_TDest,_TDta] == cAnoMesAux
			aArqSRE[aRetHash[10],_TDest,_TEmp] := SRE->RE_EMPP
			aArqSRE[aRetHash[10],_TDest,_TFil] := Substr(SRE->RE_FILIALP,1,nTamRA_FILIAL)
			aArqSRE[aRetHash[10],_TDest,_TCC] := SRE->RE_CCP
			aArqSRE[aRetHash[10],_TDest,_TMat] := SRE->RE_MATP
			aArqSRE[aRetHash[10],_TDest,_TInc] := .F.
			aArqSRE[aRetHash[10],_TDest,_TItem] := If(lItemClVl,SRE->RE_ITEMP,"")			
			aArqSRE[aRetHash[10],_TDest,_TClvl] := If(lItemClVl,SRE->RE_CLVLP,"")

			HMDel( oHash_SRE, cChave + "C" )

			cChave := SRE->RE_EMPP + Substr(SRE->RE_FILIALP,1,nTamRA_FILIAL) + SRE->RE_CCP + SRE->RE_MATP + If(lItemClVl,SRE->RE_ITEMP+SRE->RE_CLVLP,"")
			
			HMSet(oHash_SRE, cChave + "C", aClone(aArqSRE[aRetHash[10],_TDest]))
			
		Else
			nLinAux++
			
			aAdd( aArqSRE, { 	{ SRE->RE_EMPD, Substr(SRE->RE_FILIALD,1,nTamRA_FILIAL), SRE->RE_CCD, SRE->RE_MATD, cAnoMesAux, .F., If(lItemClVl,SRE->RE_ITEMD,""), If(lItemClVl,SRE->RE_CLVLD,""), "A", nLinAux },;
								{           "", 			   "",      "",           "", 	       "", .F., 	       "", 	       "", "B", nLinAux },;
								{ SRE->RE_EMPP, Substr(SRE->RE_FILIALP,1,nTamRA_FILIAL), SRE->RE_CCP, SRE->RE_MATP, cAnoMesAux, .F., If(lItemClVl,SRE->RE_ITEMP,""), If(lItemClVl,SRE->RE_CLVLP,""), "C", nLinAux } } )

			For nX := 1 to 3 step 2
				cChave := aArqSRE[nLinAux,nX,_TEmp] + aArqSRE[nLinAux,nX,_TFil] + aArqSRE[nLinAux,nX,_TCC] + aArqSRE[nLinAux,nX,_TMat] + aArqSRE[nLinAux,nX,_TItem] + aArqSRE[nLinAux,nX,_TClvl] + aTipo[nX]
				HMSet(oHash_SRE, cChave, aClone(aArqSRE[nLinAux,nX]))
			Next nX
		EndIf 

		If Empty(cEmpOrig) .And. SRE->RE_EMPD != cEmpAnt .And. SRE->RE_EMPP == cEmpAnt
			cEmpTrf += SRE->RE_EMPD+"/"
		EndIf
	EndIf
	//GUARDAR TRANSFERENCIA DE CENTRO DE CUSTO E EMPRESA PARA O MESMO PERIODO
	If 	AnoMes(SRE->RE_DATA) == cAnoMesAux .And. SRE->RE_EMPD == SRE->RE_EMPP .And. SRE->RE_FILIALD == SRE->RE_FILIALP .And. SRE->RE_MATD == SRE->RE_MATP .And. SRE->RE_CCD <> SRA->RA_CC
		aAdd(aCcEmpTra, { {SRE->RE_EMPD, Substr(SRE->RE_FILIALD,1,nTamRA_FILIAL),Substr(SRE->RE_FILIALP,1,nTamRA_FILIAL),SRE->RE_MATD, SRE->RE_MATP,SRE->RE_CCD,SRE->RE_CCP,SRE->RE_DATA,.F.}})
	EndiF	

	nPos := If(!EMPTY(aCcEmpTra), aScan(aCcEmpTra, {|x| x[1, 1] == SRE->RE_EMPD .And. x[1, 4] == SRE->RE_MATD}), NIL)

	If nPos > 0 .And. AnoMes(SRE->RE_DATA) == cAnoMesAux .And. SRE->RE_EMPD <> SRE->RE_EMPP 
		aCcEmpTra[nPos,1,9]:= .T.
	EndIf	
	SRE->(dbSkip())
EndDo

If Empty(cEmpTrf)
	dbSelectArea("SRE")
	dbSetOrder(1)
	RetIndex("SRE")
	dbClearFilter()
	fErase(cArqNtx1 + OrdBagExt())

	For nSeqFor := 1 To Len(aArqSRE)
		If !Empty(aArqSRE[nSeqFor,_TAnter,_TEmp])
			// SE A TRANSFERENCIA OCORREU NO MES DE CALCULO SIGNIFICA QUE O
			// FUNCIONARIO ESTA ATUALMENTE NO CENTRO DE CUSTO DESTINO, CASO
			// CONTRARIO, INDICA QUE FOI PROCESSADO NO C. DE CUSTO ORIGEM.
			Aadd(aTrfAux, { aClone(aArqSRE[nSeqFor,_TAnter]), If(aArqSRE[nSeqFor,_TAnter,_TDta] == cAnoMesR,;
							aClone(aArqSRE[nSeqFor,_TDest]), aClone(aArqSRE[nSeqFor,_TAnter])), aClone(aArqSRE[nSeqFor,_TDest]) })

			aArqSRE[nSeqFor,_TAnter] := { "", "", "", "", "", .F., "", "", "", 0 } // Nao deve ser lido novamente
	
			nPosTrf ++

			While .T.

				cBusca  := aTrfAux[nPosTrf,_TDest,_TEmp]+aTrfAux[nPosTrf,_TDest,_TFil]+aTrfAux[nPosTrf,_TDest,_TCC]+aTrfAux[nPosTrf,_TDest,_TMat]+If(lItemClVl,aTrfAux[nPosTrf,_TDest,_TItem]+aTrfAux[nPosTrf,_TDest,_TClvl],"")

				If HMGet(oHash_SRE, cBusca+"A", aRetHash) .and. aTrfAux[nPosTrf,_TDest,_TDta] == aArqSRE[aRetHash[10],_TDest,_TDta]
					nPosSre := aRetHash[10]

					If aArqSRE[nPosSre,_TAnter,_TDta] == cAnoMesR
						//Se houve troca de empresa, o anterior da empresa destino È o atual na empresa origem
						If aTrfAux[nPosTrf,_TAtual,_TEmp] <> aArqSRE[nPosSre,_TDest,_TEmp]
							Exit
						EndIf
						aTrfAux[nPosTrf,_TAtual] := aClone(aArqSRE[nPosSre,_TDest])
					EndIf				
					aTrfAux[nPosTrf,_TDest]  := aClone(aArqSRE[nPosSre,_TDest])
					HMDel(oHash_SRE, cBusca+"A") //Exclui do hash
				Else // SE ESTIVER FORA DO INTERVALO DE IMPRESSAO LIMPA MATRIZ
					If (((aTrfAux[nPosTrf,_TAnter,_TFil] < cFilDe .Or. aTrfAux[nPosTrf,_TAnter,_TFil] > cFilAte ) .Or.;
						(aTrfAux[nPosTrf,_TAnter,_TCC]  < cCcDe  .Or. aTrfAux[nPosTrf,_TAnter,_TCC]  > cCcAte )  .Or.;
						(aTrfAux[nPosTrf,_TAnter,_TMat] < cMatDe .Or. aTrfAux[nPosTrf,_TAnter,_TMat] > cMatAte)) .and. aTrfAux[nPosTrf,_TEmp,_TDta] > cAnoMesR);
						.And.;
						((aTrfAux[nPosTrf,_TAtual,_TFil] < cFilDe .Or. aTrfAux[nPosTrf,_TAtual,_TFil] > cFilAte ) .Or.;
						(aTrfAux[nPosTrf,_TAtual,_TCC]  < cCcDe  .Or. aTrfAux[nPosTrf,_TAtual,_TCC]  > cCcAte )  .Or.;
						(aTrfAux[nPosTrf,_TAtual,_TMat] < cMatDe .Or. aTrfAux[nPosTrf,_TAtual,_TMat] > cMatAte));
						.And.;
						((aTrfAux[nPosTrf,_TDest,_TFil] < cFilDe .Or. aTrfAux[nPosTrf,_TDest,_TFil] > cFilAte ) .Or.;
						(aTrfAux[nPosTrf,_TDest,_TCC]  < cCcDe  .Or. aTrfAux[nPosTrf,_TDest,_TCC]  > cCcAte )  .Or.;
						(aTrfAux[nPosTrf,_TDest,_TMat] < cMatDe .Or. aTrfAux[nPosTrf,_TDest,_TMat] > cMatAte) );
						.Or.;
						( If( Empty(cTpc),.F., fChkMatTpc( aTrfAux[nPosTrf,_TAtual,_TFil],aTrfAux[nPosTrf,_TAtual,_TMat],cTpc ) ) )
						If !lItemClvl
							aTrfAux[nPosTrf,_TAnter] := { "", "", "", "", "", .F. }
						Else
							aTrfAux[nPosTrf,_TAnter] := { "", "", "", "", "", .F., "", "" }
						EndIf
					EndIf
					Exit
				EndIf
			EndDo
		EndIf
	Next nSeqFor
	Aeval(aTrfAux,{ |x| If(!Empty(x[_TAnter,_TMat]), Aadd(aTransf, { x[_TAnter], x[_TAtual], x[_TDest] }), "") })
EndIf

dbSelectArea(cAlias)

If !Empty(cEmpTrf)
	fSeleTransf(@aTransf, dDataProvisao, cTpc, cEmpTrf)
EndIf

FreeObj(oHash_SRE)
oHash_SRE := Nil

Return Nil
/*
‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±⁄ƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒø±±
±±≥Funcao    ≥fGpeProvis≥ Autor ≥ Emerson Rosa de Souza ≥ Data ≥ 10.08.00 ≥±±
±±√ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒ¥±±
±±≥Descricao ≥ Cria constantes p/ utilizacao em GPEA070,GPER070 e GPEM070.≥±±
±±√ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¥±±
±±≥Sintaxe   ≥ GpeProvisao(uPar1,uPar2,uPar3,nPar4,uPar5)                 ≥±±
±±√ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¥±±
±±≥Uso       ≥ Generico                                                   ≥±±
±±¿ƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒŸ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂ*/
Function GpeProvisao(uPar1, uPar2, uPar3, uPar4, uPar5, aPar, cTpRtPr, cRetSqlName, cMatDe, cMatAte)
Local cIdPlr	:= GetMvRH("MV_PLRVER",,"XXX;XX1;XX2;XX3;XX4")
Local aPdPlr	:= {}
Local lSegPlan	:= FwIsInCallStack("WFLAUNCHER") .or. FwIsInCallStack("FWBOSCHDEXECUTE")

Default cRetSqlName := ""
Default cMatDe 		:= ""
Default cMatAte 	:= ""

uPar5 := If(uPar5 == Nil, 1, uPar5)

If !Empty(cIdPlr) .And. ";" $ cIdPlr
	aPdPlr := Separa(cIdPlr,";")
EndIf
//plr
Private lPLRPE	  	  := ExistBlock("GP070PLR")
Private _cPDPlr 	  := "XXX"
Private _cPdBxPLR 	  := "XX1"
Private _cPdMesPLR 	  := "XX2"
Private _cPDTrfPLR 	  := "XX3"
Private _cPDResPLR 	  := "XX4"
If Len(aPdPlr) == 5
	_cPDPlr 	  := aPdPlr[1]
	_cPdBxPLR 	  := aPdPlr[2]
	_cPdMesPLR 	  := aPdPlr[3]
	_cPDTrfPLR 	  := aPdPlr[4]
	_cPDResPLR 	  := aPdPlr[5]
EndIf

Private _cFechaPLR 	  := GetMvRH("MV_PLRPER",,"12")
Private _lVlrBaixa 	  := GetMvRH("MV_PLRVLBX",,.F.)

// INDICA O TIPO DE PROVISAO (SERA GRAVADO NO CAMPO RT_TIPPROV)
Private _FerVenc  := 1  // Ferias Vencidas
Private _FerProp  := 2  // Ferias Proporcionais
Private _13Salar  := 3  // 13o Salario
Private _14Salar  := 4  // 14o Salario
Private _FerVMes  := 5	// Ferias Provisao Mes
Private _13SVMes  := 6  // 13o Provisao Mes
Private _RecVenc  := 7	// Recesso Vencido
Private _RecProp  := 8	// Recesso Proporcional
Private _PlrSalar := 9  // PLR Provisao
Private _PlrSVMes := 10  //PLR Provisao Mes

// INDICA A LINHA NA ORDEM EM QUE SERA APRESENTADA NO RELATORIO
Private _Anter    := 01  // Mes Anterior
Private _Corre    := 02  // Correcao
Private _NoMes    := 03  // No Mes
Private _Atual    := 04  // Mes Atual
Private _BxTrf    := 05  // Baixa de Transferencia
Private _BxFer    := 06  // Baixa de Ferias
Private _BX13O    := 06  // Baixa de 13o Salario
Private _Bx14o    := 06  // Baixa de 14o Salario
Private _BxPLR    := 06  // Baixa de PLR
Private _BxRes    := 07  // Baixa de Rescisao
Private _TrfEnt   := 08  // Transferencia de Entrada
Private _TrfSai   := 09  // Transferencia de Saida
Private _BxTot    := 10  // Baixa Total
// INDICA A COLUNA NA ORDEM EM QUE SERA APRESENTADA NO RELATORIO
Private _Dias     := 1  // Dias de Ferias
Private _Avos     := 1  // Avos de 13o Salario
Private _Prov     := 2  // Valor da Provisao de Ferias ou Decimo Terceiro Salario
Private _Adic     := 3  // Adicionais
Private _1Ter     := 4  // Um Terco de Ferias
Private _1Par     := 4  // 1o Parcela do 13o Salario
Private _INSS     := 5  // INSS
Private _FGTS     := 6  // FGTS
Private _SalV	  := 7  // Media Salario Vac
Private _PIS      := 8  // PIS
// CONSTANTES QUE DEFINEM O NUMERO DE LINHAS E COLUNAS DO ARRAY
Private _Linhas   := 10  // Quantidade de Linhas ou Elementos
Private _Colunas  := 08  // Quantidade de colunas para cada Linha ou Elemento
// INDICA A POSICAO DAS INFORMACOES DE CABECALHO EM "aCabProv"
Private _DatCalc  :=  1  // Data do calculo
Private _CentroC  :=  2  // Data do calculo
Private _DBsProv  :=  3  // Data base de ferias
Private _DFerVen  :=  4  // Dias de ferias vencidas
Private _DFerPro  :=  5  // Dias de ferias proporcionais
Private _DFerAnt  :=  6  // Dias de ferias antecipadas
Private _DFalVen  :=  7  // Dias de faltas vencidas
Private _DFalPro  :=  8  // Dias de faltas proporcionais
Private _MovProv  :=  9  // Movimentacao no mes
Private _SalProv  := 10  // Salario da provisao no mes
Private _Avos13S  := 11  // Avos de 13o salario
Private _PStatus  := 12  // Status (Ativo/Excluido)
Private _CItem	  := 13  // Item Contabil
Private _Clvl	  := 14  // Classe de Valor
// INDICA OS TIPOS DE MOVIMENTACAO DO FUNCIONARIO NO MES
Private _Demitido := 1  // Demitido
Private _Cong_Fer := 2  // Congelado Ferias
Private _Cong_13s := 3  // Congelado 13 Salario
Private _Cong_F13 := 4  // Congelado Ferias e 13 Salario
Private _Trfe_Sai := 5  // Transferencia Saida
Private _Trfe_Ent := 6  // Transferencia Entrada
// INDICA AS POSICOES DENTRO DO ARRAY aTransf
Private _TAnter   := 1  // Centro de Custo Anterior
Private _TAtual   := 2  // Centro de Custo Atual
Private _TDest    := 3  // Centro de Custo Destino
Private _TEmp     := 1  // Empresa
Private _TFil     := 2  // Filial
Private _TCC      := 3  // Centro de Custo
Private _TMat     := 4  // Matricula
Private _TDta     := 5  // Data da Transferencia
Private _TInc     := 6  // Funcionario ja incluido no arquivo temporario
Private _TItem	  := 7  // Item Contabil
Private _TClvl	  := 8  // Classe de Valor
Private cTpRtProv
Private lGeraPMes := .F.

Private aFldRot 	:= {'RA_NOME'}
Private aOfusca	 	:= If(FindFunction('ChkOfusca'), ChkOfusca(), {.T.,.F.}) //[1] Acesso; [2]Ofusca
Private lOfuscaNom 	:= .F.
Private aFldOfusca	:= {}

If aOfusca[2]
	aFldOfusca := FwProtectedDataUtil():UsrNoAccessFieldsInList( aFldRot ) // CAMPOS SEM ACESSO
	IF aScan( aFldOfusca , { |x| x:CFIELD == "RA_NOME" } ) > 0
		lOfuscaNom := FwProtectedDataUtil():IsFieldInList( "RA_NOME" )
	ENDIF
ENDIF

If GetMvRH("MV_RATPROV",,"N") == "S"
	lGeraPMes	  := fChkRHQBase()	// Verifica a existencia da tabela RHQ
Endif

cTpRtProv	:= If( ValType(cTpRtPr) <> "U", cTpRtPr, Nil)

If uPar5 == 1 		// Cadastro
	gp070Atu(uPar1,uPar2,uPar3)
ElseIf uPar5 == 2  // Relatorio de Ferias
	RptStatus({|lEnd| GP070Imp(@lEnd,uPar1,uPar2)},uPar3)
ElseIf uPar5 == 3  // Relatorio de 13o Salario
	RptStatus({|lEnd| GP090Imp(@lEnd,uPar1,uPar2)},uPar3)
ElseIf uPar5 == 4  // Calculo
	// EM GRID HAVERA UMA BARRA DE PROCESSAMENTO DA LIB //
	If lGrid
		If (!IsBlind(), MsAguarde({|lEnd| GPM070Processa(aPar)}, OemToAnsi(STR0051), OemToAnsi(STR0052)), Processa({|| GPM070Processa(aPar)},uPar1,,.T.) ) //"Aguarde..."###"Preparando InformaÁıes para o GRID..."
	ElseIf !IsBlind()
		If !GPESmartViewUtils():ValidBackGExec("GPEM070", 7, {aPar})
			Processa({|| GPM070Processa(aPar)},uPar1,,.T.)	
		EndIf
	Else 
		Processa({|| GPM070Processa(aPar)},uPar1,,.T.)	
	EndIf
ElseIf uPar5 == 5  // Importacao do arquivo SRF para o novo SRT
//    Processa({|| fConvSRF()},uPar1)
ElseIf uPar5 == 6  // Geracao de lancamentos contabeis da provisao no arquivo SRZ
	If lSegPlan .AND. FwIsInCallStack("GPEM110")
		fGeraProvSRZ(uPar2, Nil, lPLRPE, cRetSqlName, cMatDe, cMatAte)
	Else
    	Processa({|| fGeraProvSRZ(uPar2, Nil, lPLRPE, cRetSqlName, cMatDe, cMatAte)},uPar1)
	Endif
ElseIf uPar5 == 7  // Processa a diferencas do calculo de provisa
	Processa({|| fProvProc()},uPar1)
ElseIf uPar5 == 8  // Relatorio de PLR
	RptStatus({|lEnd| GP095Imp(@lEnd,uPar1,uPar2)},uPar3)
EndIf

Return

/*
‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±⁄ƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒø±±
±±≥Funcao    ≥fChkDemit ≥ Autor ≥ Emerson Rosa de Souza ≥ Data ≥ 29.08.00 ≥±±
±±√ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒ¥±±
±±≥Descricao ≥ Se nao existir identif. de rescisao,acerta posicao no array≥±±
±±√ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¥±±
±±≥Sintaxe   ≥ fChkDemit(aProvisao,aVerba,nTipoProv,nGravar,nZerar)       ≥±±
±±√ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¥±±
±±≥Uso       ≥ Generico                                                   ≥±±
±±¿ƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒŸ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂ*/
Function fChkDemit(aProvisao,aVerba,nTipoProv,nGravar,nZerar)
Local aElem     := { _Prov, _Adic, _1Ter, _INSS, _FGTS, _PIS},nCnt
Local nProvBus  := If(nTipoProv == _FerProp,_FerVenc,nTipoProv)

If !fChkIdent(aVerba,nProvBus,{_BxRes},.F.)
   For nCnt := 1 To Len(aElem)
      aProvisao[nGravar,aElem[nCnt]] += aProvisao[nZerar,aElem[nCnt]]
      aProvisao[nZerar,aElem[nCnt]]  := 0
   Next nCnt
EndIf

Return Nil

/*
‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±⁄ƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒø±±
±±≥Funcao    ≥fProvProc ≥ Autor ≥ Equipe R.H.           ≥ Data ≥ 18/12/02 ≥±±
±±√ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒ¥±±
±±≥Decricao ≥ Processa as diferencas entre dois meses na provisao		  ≥±±
±±√ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¥±±
±±≥ Uso      ≥                                                            ≥±±
±±¿ƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒŸ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±*/
Static Function fProvProc()
Local aFields	  := {}
Local cTitulo
Local lSalInc     := .F.
Local lTrataTrf   := .F.
Local aTransf     := {}
Local aProvAux    := {}
Local aFer13o     := {}
Local lAchou
Local lProvOk
Local nCnt
Local nValProv
Local nValTot
Local nX
Local oTmpIni
Local oTmpFim

// MONTA O ARQUIVO TEMPORARIO "TPRINI"  DO MES INICIAL
Processa({ || fMonta_TPR("","",nOrdem,dDtRefIni,@lSalInc,@lTrataTrf,@aTransf,,,,,,cFiltroSRA)},OemToAnsi(STR0085) + Substr(DTOC(dDtRefIni),4,7)) //"GERANDO ARQUIVO DA PROVISAO - MES "
dbSelectArea(cTBLXPROV)

aFields := oTmpProv:GetStruct():aFields

oTmpIni := FWTemporaryTable():New("TPRINI",aFields)
oTmpIni:AddIndex( "TPRAUX1", {"PR_FILIAL","PR_CC","PR_MAT"} )
oTmpIni:Create()

While !(cTBLXPROV)->(Eof())
	RecLock("TPRINI",.T.)
	For nX := 1 to Len(aFields)
		TPRINI->(&aFields[nX,1]) := (cTBLXPROV)->(&aFields[nX,1])
	Next nX
	TPRINI->(MsUnLock())

	(cTBLXPROV)->(DbSkip())
EndDo

//Elimina arquivo tempor·rio de provis„o
fDelTMPPRV()

// MONTA O ARQUIVO TEMPORARIO "TPRFIM"  DO MES FINAL
Processa({ || fMonta_TPR("","",nOrdem,dDtRefFim,@lSalInc,@lTrataTrf,@aTransf,,,,,,cFiltroSRA)}, OemToAnsi(STR0085) + Substr(DTOC(dDtRefFim),4,7)) //"GERANDO ARQUIVO DA PROVISAO - MES "

oTmpFim := FWTemporaryTable():New("TPRFIM",aFields)
oTmpFim:AddIndex( "TPRAUX1", {"PR_FILIAL","PR_CC","PR_MAT"} )
oTmpFim:Create()

While !(cTBLXPROV)->(Eof())
	RecLock("TPRFIM",.T.)
	For nX := 1 to Len(aFields)
		TPRFIM->(&aFields[nX,1]) := (cTBLXPROV)->(&aFields[nX,1])
	Next nX
	TPRFIM->(MsUnLock())

	(cTBLXPROV)->(DbSkip())
EndDo

//Elimina arquivo tempor·rio de provis„o
fDelTMPPRV()

cFilialAnt := Replicate("!", FWGETTAMFILIAL)

dbSelectArea("SRT")
dbSetOrder(2)

dbSelectArea("TPRINI")
dbGoTop()

// CARREGA REGUA DE PROCESSAMENTO
ProcRegua(RecCount())
While !Eof()
	// MOVIMENTA REGUA DE PROCESSAMENTO
	IncProc(OemToAnsi(STR0087) + TPRINI->PR_FILIAL+OemToAnsi(STR0088)+AllTrim(TPRINI->PR_CC)+OemToAnsi(STR0089)+TPRINI->PR_MAT) //"Filial: " ### " - C.Custo: " ### " - Mat: "
	If TPRINI->PR_FILIAL # cFilialAnt
		If !Fp_CodFol(@aCodFol,TPRINI->PR_FILIAL)
			Exit
		Endif
		cFilialAnt := TPRINI->PR_FILIAL
		// MONTA ARRAY COM O TIPO DE PROVISAO A PROCESSAR
		aFer13o := {}
		If nTipProv == 1 .Or. nTipProv == 3
			aAdd(aFer13o, { "1", aCodFol[130,1] })
		EndIf
		If nTipProv == 2 .Or. nTipProv == 3
			aAdd(aFer13o, { "3", aCodFol[136,1] })
		EndIf
	EndIf

	For nCnt := 1 To Len(aFer13o)
		lProvOk   := .F.
		nValProv  := 0
		If aFer13o[nCnt,1] == "1"
			//Provisao de Ferias Vencidas
			If SRT->(dbSeek(TPRINI->PR_FILIAL+TPRINI->PR_CC+TPRINI->PR_MAT+DTOS(dDtRefIni)+"1"+aFer13o[nCnt,2]))
				nValProv += SRT->RT_VALOR
				lProvOk  := .T.
			EndIf
			//Provisao de Ferias Proporcionais
			If SRT->(dbSeek(TPRINI->PR_FILIAL+TPRINI->PR_CC+TPRINI->PR_MAT+DTOS(dDtRefIni)+"2"+aFer13o[nCnt,2]))
				nValProv += SRT->RT_VALOR
				lProvOk  := .T.
			EndIf
		Else 			                // Provisao de 13o Salario
			If SRT->(dbSeek(TPRINI->PR_FILIAL+TPRINI->PR_CC+TPRINI->PR_MAT+DTOS(dDtRefIni)+"3"+aFer13o[nCnt,2]))
				nValProv += SRT->RT_VALOR
				lProvOk  := .T.
			EndIf
		EndIf
		If lProvOk
			lAchou  := .T.
			If !TPRFIM->(dbSeek(TPRINI->PR_FILIAL+TPRINI->PR_CC+TPRINI->PR_MAT))
				If !(MesAno(TPRINI->PR_ADMISSA) == MesAno(dDtRefFim)) .Or.;
				   !(MesAno(TPRINI->PR_DEMISSA) == MesAno(dDtRefIni))
				   	lAchou := .F.
				EndIf
			Else
				If aFer13o[nCnt,1] == "1"
					//Provisao de Ferias Vencidas/Proporcionais
					If !(SRT->(dbSeek(TPRFIM->PR_FILIAL+TPRFIM->PR_CC+TPRFIM->PR_MAT+DTOS(dDtRefFim)+"1"))) .And.;
					   !(SRT->(dbSeek(TPRFIM->PR_FILIAL+TPRFIM->PR_CC+TPRFIM->PR_MAT+DTOS(dDtRefFim)+"2")))
						lAchou := .F.
					EndIf
				Else
					//Provisao de 13o. Salario
					If !(SRT->(dbSeek(TPRFIM->PR_FILIAL+TPRFIM->PR_CC+TPRFIM->PR_MAT+DTOS(dDtRefFim)+"3")))
						lAchou := .F.
					EndIf
				EndIf
			EndIf
			If !lAchou
				aAdd(aProvAux, { aFer13o[nCnt,1], nValProv,;
								 OemToAnsi(STR0087)	+ TPRINI->PR_FILIAL +; // "Filial: "
							     OemToAnsi(STR0088)	+ TPRINI->PR_CC +; // " - C.Custo: "
						         OemToAnsi(STR0089)	+ TPRINI->PR_MAT+; // " - Mat: "
						         OemToAnsi(STR0089)	+ DTOC(TPRINI->PR_ADMISSA)+; // " - Admissao: "
							     OemToAnsi(STR0090)	+ DTOC(TPRINI->PR_DEMISSA)+; // " - Demissao: "
		   					     OemToAnsi(STR0091)	+ Transform(nValProv,"@E 9,999,999.99") }) // " - Valor: "
			EndIf
		EndIf
	Next nCnt
	dbSelectArea("TPRINI")
	dbSkip()
EndDo
aLogTitle := { OemToAnsi(STR0093)+; // "LOG DE OCORRENCIAS DO CALCULO DE PROVISOES - Entre os meses "
				Substr(DTOC(dDtRefIni),4,7) +  OemToAnsi(STR0084) + Substr(DTOC(dDtRefFim),4,7) }

// MONTA LOG DA PROVISAO DE FERIAS
If nTipProv == 1 .Or. nTipProv == 3
	nValTot := 0
	Aeval(aProvAux, { |X| If(X[1] == "1", nValTot += X[2], "") })
	cTitulo := OemToAnsi(STR0094) + LTRIM(Transform(nValTot,"@E 9,999,999.99")) // "PROVISAO DE FERIAS - VALOR DA DIFERENCA: "
	aAdd(aLogFile, cTitulo)
	aAdd(aLogFile, Replicate("-", Len(cTitulo)))
	Aeval(aProvAux, { |X| If(X[1] == "1", aAdd(aLogFile, X[3]), "") })
	aAdd(aLogFile, "")
EndIf

// MONTA LOG DA PROVISAO DE 13o SALARIO
If nTipProv == 2 .Or. nTipProv == 3
	nValTot := 0
	Aeval(aProvAux, { |X| If(X[1] == "3", nValTot += X[2], "") })
	cTitulo := OemToAnsi(STR0095) + LTRIM(Transform(nValTot,"@E 9,999,999.99")) // "PROVISAO DE 13o. SALARIO - VALOR DA DIFERENCA: "
	aAdd(aLogFile, cTitulo)
	aAdd(aLogFile, Replicate("-", Len(cTitulo)))
	Aeval(aProvAux, { |X| If(X[1] == "3", aAdd(aLogFile, X[3]), "") })
	aAdd(aLogFile, "")
EndIf

// VERIFICA OS REGISTROS PERDIDOS DO SRT
Processa({|| fProcSRT()}, OemToAnsi(STR0096)) //"PROCURANDO REGISTROS PERDIDOS NO SRT..."

// APRESENTA TELA COM LOG DE ERROS
fMakeLog({aLogFile}, aLogTitle,, .T.)

// DELETA ARQUIVOS TEMPORARIOS
dbSelectArea("TPRINI")
dbCloseArea()

dbSelectArea("TPRFIM")
dbCloseArea()

oTmpIni:Delete()
oTmpIni := Nil

oTmpFim:Delete()
oTmpFim := Nil

dbSelectArea("SRT")
dbSetOrder(1)

Return Nil

/*
‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±⁄ƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒø±±
±±≥Funcao    ≥ fProcSRT ≥ Autor ≥ Equipe R.H.           ≥ Data ≥ 26/10/01 ≥±±
±±√ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒ¥±±
±±≥Descricao ≥ Verifica os registros perdidos no SRT                      ≥±±
±±√ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¥±±
±±≥ Uso      ≥                                                            ≥±±
±±¿ƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒŸ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±*/
Static Function fProcSRT()
Local cAlias   := ALIAS()
Local cTitPerd,cChavePerd

cTitPerd := OemToAnsi(STR0097) //"REGISTRO PERDIDOS ENCONTRADOS NO SRT - VERIFICAR CADA CASO"
aAdd(aLogFile, cTitPerd)
aAdd(aLogFile, Replicate("-", Len(cTitPerd)))

dbSelectArea("SRT")
dbSetOrder(1)

dbSelectArea("TPRFIM")
dbGoTop()

// CARREGA REGUA DE PROCESSAMENTO
ProcRegua(RecCount())

While !Eof()
	// MOVIMENTA REGUA DE PROCESSAMENTO
	IncProc(OemToAnsi(STR0087) + TPRFIM->PR_FILIAL+ OemToAnsi(STR0088)+AllTrim(TPRFIM->PR_CC)+OemToAnsi(STR0089)+TPRFIM->PR_MAT) //"Filial: " ### " - C.Custo: " ### " - Mat: " 
	// BUSCA FUNCIONARIOS TRANSFERENCIA ENTRADA NO MES ANTERIOR, SE  ENCONTRADOS, DEVERAO SER EXCLUIDOS
	If TPRFIM->PR_TIPMOVI == 6 // Transferencia Entrada
		cChavePerd := TPRFIM->PR_FILIAL+TPRFIM->PR_MAT+TPRFIM->PR_CC+Left(DTOS(dDtRefIni),6)
		dbSelectArea("SRT")
		If dbSeek(cChavePerd)
			While SRT->RT_FILIAL+SRT->RT_MAT+SRT->RT_CC+Left(DTOS(RT_DATACAL),6)==cChavePerd
				aAdd(aLogFile, 	OemToAnsi(STR0087) + SRT->RT_FILIAL +; //  "Filial: "
							    	OemToAnsi(STR0088) + SRT->RT_CC +; // " - C.Custo: "
						         	OemToAnsi(STR0089) + SRT->RT_MAT+; // " - Mat: "
						            OemToAnsi(STR0098) + DTOC(SRT->RT_DATACAL)+; //" - Dt.Calculo: "
	   						     	OemToAnsi(STR0099) + Transform(RECNO(),"@E 9,999,999")+; // " - Registro do SRT: "
	   						     	OemToAnsi(STR0100) + If(SRT->RT_TIPPROV $ "1*2*7*8", "FERIAS", "13.SAL")+; // " - Provisao: "
   	   						        OemToAnsi(STR0101) + Transform(SRT->RT_VERBA,"999")+; // " - Verba: "
   	   						     	OemToAnsi(STR0092) + Transform(SRT->RT_VALOR,"@E 9,999,999.99")) // " - Valor: "
		 		dbSkip()
			EndDo
		EndIf
	EndIf
	dbSelectArea("TPRFIM")
	dbSkip()
EndDo
dbSelectArea(cAlias)

Return Nil

/*
‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±⁄ƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒø±±
±±≥Funcao    ≥ fAdicLog ≥ Autor ≥ Emerson Rosa de Souza ≥ Data ≥ 03.05.02 ≥±±
±±√ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒ¥±±
±±≥Descricao ≥ Adiciona as ocorrencias do array aIdProvis no aLogFile     ≥±±
±±√ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¥±±
±±≥Sintaxe   ≥ fAdicLog(aIdProvis,cFilProc)                               ≥±±
±±√ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¥±±
±±≥Uso       ≥ Generico                                                   ≥±±
±±¿ƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒŸ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂ*/
Static Function fAdicLog(aIdProvis,cFilProc)
Local lRet := .F.
Local nCnt,lPriVez
Local aIdObr,aIdNObr
Local nTam := TamSX3("RCN_CODIGO")[1]

//TESTA A EXISTENCIA DO PARAMETRO MV_TRFAMES
//ESTA SITUACAO OCORRE SOMENTE NA IMPORTACAO DO SALDO ANTERIOR
DEFAULT	cTrfAMES     := (GetMvRH("MV_TRFAMES",, Space(6))) //-- Ano/Mes para inicio das demonstracoes de entrada e saida de transferencias no conceito 1 (transfere saldo origem p/ destino)
DEFAULT	lTrfAMES     := (!Empty(cTrfAMES) .And. MesAno(If(Type("dDataRef") == "U" , dDataBase , dDataRef)) >= cTrfAMES)

If lGrid
	AADD( aLogFile, {} )
EndIf

// VERIFICAR SE EXISTE AO MENOS UM IDENTIFICADOR NAO CADASTRADO
If Ascan(aIdProvis, { |X| Empty(X[1]) }) > 0
	// ADICIONA AVISO INFORMANDO A FILIAL CANCELADA
	aLogFile[1] := { STR0020 + " [" + cFilProc + "] " + STR0021, "" } //"CALCULO DA FILIAL [XX] CANCELADO !!!"
	// DEFINICAO DOS IDENTIFICADORES OBRIGATORIOS
	// SE UTILIZAR C¡LCULO DE 14 SAL¡RIO, ENT√O OS IDS DE BAIXA DO 14 S√O OBRIGAT”RIOS.
	If n14Salario > 0
   		aIdObr  := { { _FerVenc, _Atual }, { _13Salar, _Atual }, { _14Salar, _Atual },;
		           { _FerVenc, _Corre }, { _13Salar, _Corre }, { _14Salar, _Corre },;
	  	     	   { _FerVenc, _BxFer }, {_14Salar, _Bx14O}}
	Else
		aIdObr  := { { _FerVenc, _Atual }, { _13Salar, _Atual }, { _14Salar, _Atual },;
		           { _FerVenc, _Corre }, { _13Salar, _Corre }, { _14Salar, _Corre },;
	  	     	   { _FerVenc, _BxFer }}
	EndIf
	If lTrfAMES
		AADD(aIdObr, { 0, _BxTrf })
	EndIf
	// DEFINICAO DOS IDENTIFICADORES NAO OBRIGATORIOS. O ZERO INDICA QUE A BAIXA DE TRANSF. DEVERA SER AVALIADA PARA FERIAS/13o
	// SE UTILIZAR C¡LCULO DE 14 SAL¡RIO, ENT√O OS IDS DE BAIXA DO 14 S√O OBRIGAT”RIOS.
	If n14Salario > 0
		aIdNObr := { { 0, _BxTrf }, { _13Salar, _Bx13O } }
	Else
		aIdNObr := { { 0, _BxTrf }, { _13Salar, _Bx13O }, { _14Salar, _Bx14o } }
	EndIf
	// Adiciona Identificadores Obrigatorios no LOG de ocorrencias  ≥

	lPriVez  := .T.
	For nCnt := 1 To Len(aIdObr)
		If Ascan(aIdProvis, { |X| If(aIdObr[nCnt,1]==0,.T.,X[3]==aIdObr[nCnt,1]) .And. X[4]==aIdObr[nCnt,2] .And. Empty(X[1])}) > 0
			If lPriVez
				Aadd(aLogFile[1], "")
				Aadd(aLogFile[1], STR0022)          //"Cadastrar a verba correspondente para cada um dos identificadores relacionados abaixo"
				Aadd(aLogFile[1], "")
				If lTrfAMES
					Aadd(aLogFile[1], STR0026)       //"Os identificadores de transferencia devem obrigatoriamente ser criados pois o parametro MV_TRFAMES esta habilitado"
					Aadd(aLogFile[1], "")
				EndIf
				Aadd(aLogFile[1], "    " + STR0025) // "Verba   Ident   Descricao do Identificador"
				Aadd(aLogFile[1], "    -----   -----   --------------------------------------------------")
				lPriVez  := .F.
			EndIf
			Aeval(aIdProvis, { |X| If(If(aIdObr[nCnt,1]==0,.T.,X[3]==aIdObr[nCnt,1]) .And. X[4]==aIdObr[nCnt,2] .And. Empty(X[1]),;
   				   Aadd(aLogFile[1],Space(4)+X[1]+Space(5)+X[2]+Space(5)+fDesc("RCN",StrZero(Val(X[2]),nTam),"RCN_DESCRI",50)), "")})
		EndIf
	Next nCnt

	// IDENTIFICADORES NAO OBRIGATORIOS, O USUARIO DEVERA CADASTRAR
	// TODOS OU EXCLUIR TODOS, NAO PODE HAVER MEIO TERMO.

	For nCnt := 1 To Len(aIdNObr)
		If Ascan(aIdProvis, { |X| If(aIdNObr[nCnt,1]==0,.T.,X[3]==aIdNObr[nCnt,1]) .And. X[4]==aIdNObr[nCnt,2] .And.  Empty(X[1])}) > 0 .And.;
		   Ascan(aIdProvis, { |X| If(aIdNObr[nCnt,1]==0,.T.,X[3]==aIdNObr[nCnt,1]) .And. X[4]==aIdNObr[nCnt,2] .And. !Empty(X[1])}) > 0
			If lPriVez
				Aadd(aLogFile[1], "")
				Aadd(aLogFile[1], STR0023)          //"Para que seja efetuado o tratamento das baixas de transferencia, cadastre a verba correspondente para"
				Aadd(aLogFile[1], STR0024)          //"cada identificador. Para que nao seja efetuado tratamento das baixas, exclua as verbas ja cadastradas."
				Aadd(aLogFile[1], "")
				Aadd(aLogFile[1], "    " + STR0025) // "Verba   Ident   Descricao do Identificador"
				Aadd(aLogFile[1], "    -----   -----   --------------------------------------------------")
				lPriVez := .F.
			EndIf
			Aeval(aIdProvis, { |X| If(If(aIdNObr[nCnt,1]==0,.T.,X[3]==aIdNObr[nCnt,1]) .And. X[4]==aIdNObr[nCnt,2],;
				   Aadd(aLogFile[1],Space(4)+X[1]+Space(5)+X[2]+Space(5)+fDesc("RCN",StrZero(Val(x[2]),nTam),"RCN_DESCRI",50)), "")})
		EndIf
	Next nCnt
	// OS DOIS PRIMEIROS ELEMENTOS SE REFEREM AO SUBTITULO
	If Len(aLogFile[1]) > 2
		// SE FOR GRID ADICIONA O LOG E ABORTA O CALCULO
		If lGrid
			MsgLogGrid(aClone(aLogFile[1]), .T.)
		EndIf
		lRet := .T.
	Else
		aLogFile[1] := {}
	EndIf
EndIf

Return lRet

/*
‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±⁄ƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒø±±
±±≥Funcao    ≥ fQrySRD  ≥ Autor ≥ Ricardo Duarte Costa  ≥ Data ≥ 01.02.07 ≥±±
±±√ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒ¥±±
±±≥Descricao ≥ Executa query filtrando verbas de salario e adicionais.    ≥±±
±±√ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¥±±
±±≥Sintaxe   ≥ vide abaixo                                                ≥±±
±±√ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¥±±
±±≥Uso       ≥ Generico                                                   ≥±±
±±¿ƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒŸ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂ*/
Static Function fQrySRD(cFilProc , cMatProc , cMesAnoProc)
Local nReg	:= 0
Local lBaseConf := ( Len(aCodFol) >= 1421 )
Local lDivAdi 	:= ( Len(aCodFol) >= 1721 ) .And. !Empty(aCodFol[1680,1])

Local cCodAdFer	:= aCodFol[1296,1] + aCodFol[1298,1]; //ATS
			   + aCodFol[1300,1] + aCodFol[1302,1]; //PERICULOSIDADE
			   + aCodFol[1304,1] + aCodFol[1306,1];//INSALUBRIDADE
			   	+ aCodFol[1308,1]; // Adicional Cargo
			    + aCodFol[1310,1] //ADICIONAL TRANSFERENCIA

Local cCodAdFol	:= aCodFol[318,1] + aCodFol[671,1] + aCodFol[672,1] + aCodFol[673,1] + If(lBaseConf, aCodFol[1421,1] + aCodFol[1422,1],"") ; //BASE SAL MES
					 + aCodFol[001,1] + aCodFol[002,1] + aCodFol[003,1] + aCodFol[004,1] + aCodFol[005,1]; // ATS
					 + aCodFol[36,1]; // Pericul
					 + aCodFol[37,1] + aCodFol[38,1] + aCodFol[39,1];// Insalubridade
					 + aCodFol[984,1]; //Adcional Cargo
					 + aCodFol[988,1] ;//Adicional Transf
					  + aCodFol[1281,1];
			   		 + aCodFol[1282,1];
			   		 + aCodFol[1283,1];
			   		 + aCodFol[1284,1];
			   		 + aCodFol[1285,1];
			   		 + aCodFol[1286,1];
			   		 + aCodFol[1287,1];
					 + aCodFol[1340,1]

Local cCodComis := aCodFol[165,1] + aCodFol[166,1] + aCodFol[121,1] // Comiss„o folha + comiss„o rescis„o.
Local cAdResc	:= iif(lDivAdi,aCodFol[1680,1] + aCodFol[1681,1] + aCodFol[1682,1] + aCodFol[1684,1] + aCodFol[1685,1] + aCodFol[1686,1];
					+ aCodFol[1687,1] + aCodFol[1688,1] + aCodFol[1690,1] + aCodFol[1691,1] + aCodFol[1692,1] + aCodFol[1693,1];
					+ aCodFol[1694,1] + aCodFol[1696,1] + aCodFol[1697,1] + aCodFol[1698,1] + aCodFol[1699,1] + aCodFol[1700,1];
					+ aCodFol[1702,1] + aCodFol[1703,1] + aCodFol[1704,1] + aCodFol[1705,1] + aCodFol[1706,1] + aCodFol[1708,1];
					+ aCodFol[1709,1] + aCodFol[1710,1] + aCodFol[1711,1] + aCodFol[1712,1] + aCodFol[1714,1] + aCodFol[1715,1];
					+ aCodFol[1716,1] + aCodFol[1717,1] + aCodFol[1718,1] + aCodFol[1719,1] + aCodFol[1720,1] + aCodFol[1721,1],"")

Local cInAds	:= fSqlIN(StrTran(cCodAdFer + cCodAdFol + cCodComis + cAdResc ,Space(TamSX3("RV_COD")[1]),""),3)

//MONTA A QUERY PARA SELECAO DOS DADOS
If lFechouMes
	aStruSRD := SRD->(dbStruct())
	cWhere   := "SRD.RD_FILIAL = '"+cFilProc+"' AND SRD.RD_MAT = '"+cMatProc+"' AND "+;
				"SRD.RD_PD IN (" + cInAds + ") AND "+;
				"SRD.RD_ROTEIR <> 'VEX' AND "		+;
				"SRD.RD_DATARQ = '"+cMesAnoProc+"'"
	cWhere   := "%"+cWhere+"%"

	BeginSql alias cAliasPROC
		SELECT SRD.RD_FILIAL, SRD.RD_MAT, SRD.RD_PD, SRD.RD_DATARQ, SUM(SRD.RD_VALOR) AS RD_VALOR
		FROM %table:SRD% SRD
		WHERE %exp:cWhere% AND SRD.%notDel%
		GROUP BY RD_FILIAL, RD_MAT, RD_DATARQ, RD_PD
		ORDER BY RD_FILIAL, RD_MAT, RD_DATARQ, RD_PD
	EndSql

	//AJUSTA A ESTRUTURA DOS CAMPOS
	For nReg := 1 To Len(aStruSRD)
		If (aStruSRD[nReg][2] <> "C")
			TcSetField(cAliasPROC,aStruSRD[nReg][1],aStruSRD[nReg][2],aStruSRD[nReg][3],aStruSRD[nReg][4])
		EndIf
	Next nReg
Else
	aStruSRC := SRC->(dbStruct())
	cWhere   := "SRC.RC_FILIAL = '"+cFilProc+"' AND SRC.RC_MAT = '"+cMatProc+"' AND "+;
				"SRC.RC_PD IN (" + cInAds + ") AND "								 +;
				"SRC.RC_ROTEIR <> 'VEX' "
	cWhere   := "%"+cWhere+"%"

	BeginSql alias cAliasPROC
		SELECT SRC.RC_FILIAL, SRC.RC_MAT, SRC.RC_PD, SUM(SRC.RC_VALOR) AS RC_VALOR
		FROM %table:SRC% SRC
		WHERE %exp:cWhere% AND SRC.%notDel%
		GROUP BY RC_FILIAL, RC_MAT, RC_PD
		ORDER BY RC_FILIAL, RC_MAT, RC_PD
	EndSql

	//AJUSTA A ESTRUTURA DOS CAMPOS
	For nReg := 1 To Len(aStruSRC)
		If (aStruSRC[nReg][2] <> "C")
			TcSetField(cAliasPROC,aStruSRC[nReg][1],aStruSRC[nReg][2],aStruSRC[nReg][3],aStruSRC[nReg][4])
		EndIf
	Next nReg
Endif

return


/*
‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±⁄ƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒø±±
±±≥Funcao    ≥ fCarAdics≥ Autor ≥ Ricardo Duarte Costa  ≥ Data ≥ 04.04.07 ≥±±
±±√ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒ¥±±
±±≥Descricao ≥ Inicializa as variaveis de Adic.Tpo.Servico e Insalubridade≥±±
±±√ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¥±±
±±≥Sintaxe   ≥ vide abaixo                                                ≥±±
±±√ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¥±±
±±≥Uso       ≥ Generico                                                   ≥±±
±±¿ƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒŸ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂ*/
Static Function fCarAdics()
Local cAdtPoSer	:= SRA->RA_ADTPOSE
Local cCod		:= Space(3)
Local nx		:= 0

//TRATAMENTO DO ADICIONAL DE TEMPO DE SERVICO
cAdtPoSer	:= alltrim(cAdtPoSer)
cAdtPoSer	:= strtran(cAdtPoSer,"*","")
For nx := 1 to len(cAdtPoSer)
   If Substr(cAdtPoSer,nx,1) == "A"
		cCodAdt := aCodfol[1,1]
	ElseIf Substr(cAdtPoSer,nx,1) == "B"
		cCodAdt := aCodfol[2,1]
	ElseIf Substr(cAdtPoSer,nx,1) == "T"
		cCodAdt := aCodfol[3,1]
	ElseIf Substr(cAdtPoSer,nx,1) == "D"
		cCodAdt := aCodfol[4,1]
	ElseIf Substr(cAdtPoSer,nx,1) == "Q"
		cCodAdt := aCodfol[5,1]
	EndIf
Next nx

//TRATAMENTO DA INSALUBRIDADE
// INSAL. MINIMA
If SRA->RA_ADCINS == "2"
	cCod   := aCodfol[37,1]
EndIf
// INSAL. MEDIA
If SRA->RA_ADCINS == "3"
	cCod   := aCodfol[38,1]
EndIf
// INSAL. MAXIMA
If SRA->RA_ADCINS == "4"
	cCod   := aCodfol[39,1]
EndIf
// DEFINE O CODIGO DA INSALUBRIDADE UTILIZADA PELO FUNCIONARIO
If cCod # Space(3)
	cCodIns := cCod
Endif

Return

/*
‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±…ÕÕÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÀÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÀÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÕÕÕª±±
±±∫Programa  ≥ CalcGrid ∫Autor  ≥Jonatas A. T. Alves ∫ Data ≥  18/08/08   ∫±±
±±ÃÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕ ÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ ÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕÕÕÕπ±±
±±∫Desc.     ≥Inclusao do Calculo Atraves de GRID - Multiprocessamento    ∫±±
±±ÃÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕπ±±
±±∫Uso       ≥ Gpem070                                                    ∫±±
±±»ÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕº±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂ*/
Static Function CalcGrid(aCall,aParametros,aAreaSRA)

Local aParAmb			:= {}
Local lRet 			    := .T.
Local cDurTempo         := ""
Local cFunExec          := "GetSrvVersion"
Local cMsgGrid 		    := ''	// Variavel para retorno de Log
Local nI, nT, nX, nZ
Local nRegsProc         := 0
Local nTimeFim
Local nQtde
Local nIni
Local nTam
Local lNewGrid			:= FindFunction("GridCliVersion")
Local aProcessoTit  	:= {}
Local aProcessoLog  	:= {}
Local aGpem070TitLog	:= {}
Local aGpem070Log		:= {}
Local aLogErro 		    := {}
Local nLoop

//NO NOVO BUILD DO GRID, O TERCEIRO ELEMENTO DO ARRAY AINFOPROC E UM IDENTIFICADOR DO AGENTE
//UTILIZADO E O QUARTO ELEMENTO, CASO EXISTA, EH O VALOR CORRESPONDENTE AO RETORNO DO PROCESSO
Local nGridLog		:= If(lNewGrid, 4, 3) // Se for GRID antigo o log fica na posicao 3, senao fica na posicao 4
Private oGrid

DEFAULT lItemClVl   := GetMvRH("MV_ITMCLVL", .F., "2") $ "13"
DEFAULT lProvResc   := (GetMvRH("MV_PROVRES",,"N") == "S") //-- Indica se devera provisionar no mes da rescisao
DEFAULT lVerMetrics	:= FwLibVersion() >= "20200727" .And. FindClass( "FWCustomMetrics" ) .And. FindFunction( cFunExec ) .And. &cFunExec.() >= "19.3.0.6"

//ADICIONA INFORMACOES NO LOG DE PROCESSAMENTO PARA GRID
aAdd(aProcessoTit , STR0056) // "Informacoes do Processo de Calculo com GRID"
aAdd(aProcessoLog , STR0057 + " " + SecsToTime(nIniTime) + " " + STR0046 + " " + Dtoc(MsDate())) // "Inicio do Processo de Calculo:" ## "de"

// ARRAY DE LOG:
//  1-ERROS NA ROTINA DE PREPARACAO DO GRID
//  2-ERROS FATAIS DO GRID - METODO AERRORPROC
//  3-ERRO EM UM LOTE DO GRID - METODO ASENDPROC
//  4-ERROS NO LOTE DO GRID - TRATAMENTO FEITO NA FUNCAO
//	 GPM070GRD	- RETORNO PELO METODO AINFOPROC
aAdd(aLogErro, { STR0058, {} }) // "Erros na preparacao do GRID"
aAdd(aLogErro, { STR0059, {} }) // "Erros fatais no processamento do GRID"
aAdd(aLogErro, { STR0060, {} }) // "RequisiÁıes n„o processadas"
aAdd(aLogErro, { STR0061, {} }) // "Log dos registros processados"

//CRIACAO DO OBJETO GRID E PROCESSAMENTO
dbSelectArea(cTBLXPROV)
oGrid := GridClient():New()

If ValType(oGrid) == "U"
	aAdd(aLogErro[1,2], OemToAnsi(STR0038)) // "FALHA NA CRIACAO DO OBJETO GRIDCLIENT. IMPOSSIVEL EXECUTAR PROCESSO EM GRID."
	lRet := .F.
EndIf
aTransf := {} // LIMPA ARRAY ATRANSF, POIS SER¡ CARREGADO VIA TABELA TEMPORARIA ASSOCIADA
If lRet
	aParAmb	:=	{	FWGrpCompany("SRA"),;
					FwCodFil(),;
					dDataBase,;
					aEmpresas,;
					cUsuario,;																	// Parametros Public do Sistema
			  		{aParametros,lFechouMes,lItemClVl,Nil,nFec131,cFilialAnt,;
			  		cNameFile,cDbfLog,cChaveLog,aIdProvis,lGrid,cFileTrf,cTrfDbf,nTamTrf,lFechou13},; 								// Parametros Privates de GPEM070
			  		{aTabFer,aTabFer2,cTpBxFer,cTpCongAf,cTrfAMES,lTrfAMES,cAbatAfas,;
			  		cPgSalMat,lDif13Neg,aTransf,lSalInc,lTrataTrf,c__Roteiro,cPerFeAc,;
			  		lProvResc,,cCalcSalInc,lCalcSalInc,cNomeDe,cNomeAte,{},;
			  		aInssEmp,aCodFol,aInfo,aGPSPer,aVerba,nPerc1T,nPercPis,lTrfSld,dDataDem1,lGeraPMes,cTpRtProv,lSabDom,cOneFol,cAnoMes,;
			  		aPerFechado,cMes,cAno,lTemVenc,aPerAb13,aPrAb131,aPrAb132,aPerFe13,aPrFe131,aPrFe132,aPerAbPL,aPerFePL,cTBLXPROV,oTmpProv:GetRealName(),aIndice,lVerFat},}
	// CHAMA A EXECUCAO EM GRID. CASO ELA RETORNE .F., OU O GRID NAO PODE SER INICIADO,
	// OU ALGUM PROCESSO DEU ERRO, OU UM OU MAIS ITENS NAO FORAM PROCESSADOS.
	lRet := oGrid:BatchExec("GPM070AMB",aParAmb,"GPM070GRD",aCall,"GPM070END")

	// FECHA A AREA 'TPR' E EXCLUI OS ARQUIVOS TEMPORARIOS DE INDICE E DE DADOS A ELA ASSOCIADOS
	(cTBLXPROV)->(dbCloseArea())

	// EFETUA DROP TABLE DA TABELA TEMPORARIA DO aTransf
	(cTrfDbf)->(dbCloseArea())
	If TCCanOpen(cFileTrf)
		MsErase(cFileTrf)
	EndIf

	If !lRet
		If !Empty(oGrid:cErrorMsg)
			aAdd(aLogErro[1,2], oGrid:cErrorMsg) // CARREGA MENSAGENS GERADAS PELO GRID
		EndIf
		If !Empty(oGrid:aGridThreads)
			aAdd(aLogErro[1,2], OemToAnsi(STR0039)) // "NENHUM AGENTE DO GRID DISPONIVEL NO MOMENTO."
		EndIf
	EndIf

	// ERRO NO PROCESSAMENTO DO GRID - ERROS FATAIS
	If !Empty(oGrid:aErrorProc)
		// [1] : Numero sequencial da instrucao enviada que nao foi processada
		// [2] : Parametro enviado para processamento
		// [3] : String contendo informacoes do ERRO
		nT := len(oGrid:aErrorProc)
		For nI := 1 to nT
			aAdd(aLogErro[2,2], OemToAnsi(STR0040) + " " + Str(oGrid:aErrorProc[nI,1],5)) // "Requisicao: "
			cMsgGrid := oGrid:aErrorProc[nI][3]
			nTamanho := Len(cMsgGrid)
			If nTamanho > 225
	            nTam := nTamanho / 225
                nQtde 	:= Int(nTam) + If((nTam - Int(nTam)) > 0, 1, 0)
                nIni 	:= 1
				For nX := 1 To nQtde
					aAdd(aLogErro[2,2], Substr(oGrid:aErrorProc[nI][3],nIni,225))
					nIni := nIni + 225
				Next nX
			Else
				aAdd(aLogErro[2,2], oGrid:aErrorProc[nI][3])
			EndIf
		Next nI
	Endif

	// REQUISICOES QUE NAO FORAM PROCESSADAS
	If !Empty(oGrid:aSendProc)
		// [1] : NUMERO SEQUENCIAL DA INSTRUCAO ENVIADA QUE NAO FOI PROCESSADA
		// [2] : PARAMETRO ENVIADO PARA PROCESSAMENTO
		// [3] : RETORNO DA EXECU«AO
		nT := len(oGrid:aSendProc)
		For nI := 1 to nT
			aAdd(aLogErro[3,2], OemToAnsi(STR0040) + " " + Str(oGrid:aSendProc[nI,1],5)) // "RequisiÁ„o: "
			aAdd(aLogErro[3,2], Space(10) + OemToAnsi(STR0041) + " " +; // "Parametros De/Ate:"
			  					  OemToAnsi(STR0033) + " " + oGrid:aSendProc[nI,2,1,2] + " " + OemToAnsi(STR0042) + " " + oGrid:aSendProc[nI,2,Len(oGrid:aSendProc[nI,2]),2] + "   "+; // "Filial" ## "a"
			  					  OemToAnsi(STR0034) + " " + oGrid:aSendProc[nI,2,1,3] + " " + OemToAnsi(STR0042) + " " + oGrid:aSendProc[nI,2,Len(oGrid:aSendProc[nI,2]),3]) // "MatrÌcula" ## "a"
		Next nI
	EndIf

	// RECUPERA RETORNOS DAS CHAMADAS - MENSAGENS DE LOG DO CALCULO (RETORNO DIFERENTE DE NIL DA FUNCAO GPM070GRD)
	If !Empty(oGrid:aInfoProc)
		// [1] : NUMERO SEQUENCIAL DA INSTRUCAO ENVIADA QUE NAO FOI PROCESSADA
		// [2] : PARAMETRO ENVIADO PARA PROCESSAMENTO
		// [3] : RETORNO DA EXECU«AO
		nT := Len(oGrid:aInfoProc)
		For nI := 1 To nT
			aAdd(aLogErro[4,2], oGrid:aInfoProc[nI][nGridLog][1][1])	// GRAVACAO DO CABECALHO - FUNCIONARIO
			For nZ := 1 To Len(oGrid:aInfoProc[nI][nGridLog][1][2])
				aAdd(aLogErro[4,2], oGrid:aInfoProc[nI][nGridLog][1][2][nZ][1]) // LOG DO ERRO
			Next nZ
		Next nI
	EndIf
EndIf

//EXCLUIR OS PROCESSOS QUE TERMINARAM COM SUCESSO
cQuery := " DELETE FROM "
cQuery += " "+ cNameFile +" "
CQuery += " WHERE CHAVE = '" + cChaveLog + "'"
TcSqlExec(cQuery)

nTimeFim    := Seconds()
cDurTempo   := SecsToTime(nTimeFim - nIniTime)

aAdd(aProcessoLog , STR0045 + " " + SecsToTime(nTimeFim) + " " + STR0046 + " "  + Dtoc(MsDate())) // "Final do Processo de Calculo:" ## "de"
aAdd(aProcessoLog , STR0047 + " " + cDurTempo ) // "Duracao do Processo de Calculo:"
aAdd(aProcessoLog , "")
aAdd(aProcessoLog , STR0048 + " " + Str(oGrid:nSendSeq,5)) // "Nro de RequisiÁıes Enviadas para Processamento:"
aAdd(aProcessoLog , STR0049 + " " + Str(oGrid:nSendSeq-Len(oGrid:aSendProc),5)) // "Nro de RequisiÁıes Processadas:"
aAdd(aProcessoLog , STR0050 + " " + Str(Len(oGrid:aSendProc),5)) // "Nro de RequisiÁıes Nao Processadas:"

//ADICIONA INFORMACOES DO PROCESSAMENTO NO LOG GERAL
aAdd(aGpem070TitLog	, aProcessoTit[1])
aAdd(aGpem070Log		, aClone(aProcessoLog))

//CARREGANDO INFORMACOES PARA O LOG
For nLoop := 1 To Len(aLogErro)
	If Len(aLogErro[nLoop,2]) > 0
   		aAdd(aGpem070TitLog	, aLogErro[nLoop , 1])
   		aAdd(aGpem070Log		, aClone(aLogErro[nLoop , 2]))
	EndIf
Next nLoop

//MOSTRAR O LOG
fMakeLog(aGpem070Log, aGpem070TitLog, "GPM070", NIL, FunName(), STR0062, NIL, NIL, NIL, .F.,aLogPerg)

If lVerMetrics
    For nLoop := 1 To Len(aCall)
        nRegsProc += Len(aCall[nLoop])
    Next nLoop
    If nRegsProc >= 100
        FwCustomMetrics():setAverageMetric( "PROVISAO", "totvs-rh-protheus_processamento-calculos_average", TimeToSeconds( cDurTempo )/60 )
    EndIf
EndIf

RestArea(aAreaSRA)

Return
/*
‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±…ÕÕÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÀÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÀÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÕÕÕª±±
±±∫Programa  ≥GPM070AMB ∫Autor  ≥Jonatas A. T. Alves ∫ Data ≥  18/08/08   ∫±±
±±ÃÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕ ÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ ÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕÕÕÕπ±±
±±∫Desc.     ≥Preparacao do ambiente para GRID - Multiprocessamento       ∫±±
±±ÃÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕπ±±
±±∫Uso       ≥ Gpem070                                                    ∫±±
±±»ÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕº±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂ*/
Function GPM070AMB(aParms)
Local cEmpParm  	:= aParms[1]	// Empresa conectada 	--> cEmpAnt
Local cFilParm  	:= aParms[2]	// Filial conectada 	--> cFilAnt
Local dDataParm 	:= aParms[3]	// Data Base			--> dDataBase
Local aEmpParm		:= aParms[4]	// Array com empresas 	--> aEmpresas
Local cUsuaParm 	:= aParms[5]	// Usuario conectado	--> cUsuario
Local aMnemonicos	:= {}
Local lRet 		:= .T.
Local lShowErr	:= .F.
Local lSetDef
Local nMnemo
Local nMnemos
Local uVar
Local cIdPlr := ""
Local aPdPlr	:= {}

//PREPARACAO DE NOVO AMBIENTE - TABELAS E VARIAVEIS
RpcSetType(3)
PREPARE ENVIRONMENT EMPRESA (cEmpParm) FILIAL (cFilParm) MODULO "GPE" FUNNAME "GPEM070"

_SetOwnerPrvt( '__aMVLog', {} )

cIdPlr := GetMvRH("MV_PLRVER",,"XXX;XX1;XX2;XX3;XX4")

If (lRet := fMontaMnemo(cFilParm , @aMnemonicos))
	If (nMnemos:= Len(aMnemonicos)) > 0
		For nMnemo := 1 to nMnemos
			lSetDef := .F.
			//INICIALIZA E CARREGA OS VALORES PADROES DECLARANDO COMO PRIVATES NA FUNCAO QUE CHAMOU(1 NIVEL ACIMA)
			IF !Empty(uVar := AllTrim(aMnemonicos[nMnemo , 03]))
				IF (aMnemonicos[nMnemo , 04] == "D" .and. ("/" $ uVar))
					IF CheckExecForm({ || uVar := Ctod(uVar) },lShowErr)
						IF ((cType := ValType(uVar)) == aMnemonicos[nMnemo , 04])
							_SetOwnerPrvt(aMnemonicos[nMnemo , 01], uVar)
						Else
							lSetDef := .T.
						EndIF
					Else
						lSetDef := .T.
					EndIF
				ElseIF CheckExecForm(@uVar , lShowErr)
					_SetOwnerPrvt(aMnemonicos[nMnemo , 01], uVar)
				Else
					lSetDef := .T.
				EndIF
			Else
				lSetDef := .T.
			EndIF
			If lSetDef
				_SetOwnerPrvt(aMnemonicos[nMnemo , 01], GetValType(aMnemonicos[nMnemo , 04]))
			EndIf
		Next nMnemo
	Endif
	//VARIAVEIS PUBLICAS DO SISTEMA
	aEmpresas := aClone(aEmpParm)
	dDataBase := dDataParm
	cUsuario  := cUsuaParm
EndIf

// DECLARACAO DAS VARIAVEIS PRIVATE UTILIZADAS NA PREPARACAO DO AMBIENTE PARA PROCESSAMENTO EM GRID
//| CARREGANDO PARAMETROS MV_PAR DA ROTINA
_SetOwnerPrvt('lFerias'		, aParms[6,1,1])	//  Tipo de Provisao 1 - Ferias 2 - 13o  3 - Ambas
_SetOwnerPrvt('l13oSal'		, aParms[6,1,2])	//  Tipo de Provisao 1 - Ferias 2 - 13o  3 - Ambas
_SetOwnerPrvt('dDataRef'	, aParms[6,1,3])	//  Data de Referencia para Calculo
_SetOwnerPrvt('nOrdem'		, aParms[6,1,4])	//  Ordem de Calculo 1 - Matricula  2 - Centro de Custo
_SetOwnerPrvt('cFilDe'		, aParms[6,1,5])	//	Filial De
_SetOwnerPrvt('cFilAte'		, aParms[6,1,6])	//	Filial Ate
_SetOwnerPrvt('cCcDe'		, aParms[6,1,7])	//	Centro de Custo De
_SetOwnerPrvt('cCcAte'		, aParms[6,1,8])	//	Centro de Custo Ate
_SetOwnerPrvt('cMatDe'		, aParms[6,1,9])	//	Matricula De
_SetOwnerPrvt('cMatAte'		, aParms[6,1,10])	//	Matricula Ate
_SetOwnerPrvt('nCorrecao'	, aParms[6,1,11])	//	Indice de Correcao
_SetOwnerPrvt('lDesc1parc'	, aParms[6,1,12])	//	Indice de Correcao
_SetOwnerPrvt('lIncluiDem'	, aParms[6,1,13])	//  Incluir Demit. 13o
_SetOwnerPrvt('n14Salario'	, aParms[6,1,14])	//  Indice de 14o Sal.
_SetOwnerPrvt('cCateg'		, aParms[6,1,15])	//	Categorias
_SetOwnerPrvt('nVerFatFin'	, aParms[6,1,16])	//	Verifica integracao
_SetOwnerPrvt('nPergPro'	, aParms[6,1,17])	//	tipo provisao
_SetOwnerPrvt('cFiltroSRA'	, aParms[6,1,18])	//  Filtro SRA

//CARREGANDO VARIAVEIS PRIVATE GENERICAS
_SetOwnerPrvt('lFechouMes'	, aParms[6,2])	//	Verifica se esta calculando provisao com mes fechado
_SetOwnerPrvt('lItemClVl'	, aParms[6,3])	//	Verifica se utiliza item contabil
// Posicao 4 livre para utilizacao de outra variavel - controle de item e classe em uma unica variavel
_SetOwnerPrvt('nFec131'		, aParms[6,5])	//	Mes de pagamento da 1a. parcela do 13o. salario
_SetOwnerPrvt('cFilialAnt'	, aParms[6,6])	//
_SetOwnerPrvt('aIdProvis'	, aParms[6,10])	//
_SetOwnerPrvt('cFileTrf'	, aParms[6,12])	// Tabela temporaria de transferencias
_SetOwnerPrvt('cTrfDbf'		, aParms[6,13])	// Alias de transferencia
_SetOwnerPrvt('nTamTrf'		, aParms[6,14])	// No. de elementos total de aTransf
_SetOwnerPrvt('lFechou13'	, aParms[6,15])	//	Verifica se esta calculando provisao com mes fechado
//Indica o tipo de provisao (sera gravado no campo RT_TIPPROV)
_SetOwnerPrvt('_FerVenc'	, 1 ) // Ferias Vencidas
_SetOwnerPrvt('_FerProp'	, 2 ) // Ferias Proporcionais
_SetOwnerPrvt('_13Salar'	, 3 ) // 13o Salario
_SetOwnerPrvt('_14Salar'	, 4 ) // 14o Salario
_SetOwnerPrvt('_FerVMes'   	, 5	) // Ferias Provisao Mes
_SetOwnerPrvt('_13SVMes'   	, 6 ) // 13o Provisao Mes
_SetOwnerPrvt('_RecVenc'  	, 7	) // Recesso Vencido
_SetOwnerPrvt('_RecProp'  	, 8	) // Recesso Proporcional
_SetOwnerPrvt( '_PLRSalar'   , 9  ) // 13ß Provisao Mes
_SetOwnerPrvt( '_PLRSVMes'   , 10  ) // 13ß Provisao Mes

//INDICA A LINHA NA ORDEM EM QUE SERA APRESENTADA NO RELATORI
_SetOwnerPrvt('_Anter'		, 01) // Mes Anterior
_SetOwnerPrvt('_Corre'		, 02) // Correcao
_SetOwnerPrvt('_NoMes'		, 03) // No Mes
_SetOwnerPrvt('_Atual'		, 04) // Mes Atual
_SetOwnerPrvt('_BxTrf'		, 05) // Baixa de Transferencia
_SetOwnerPrvt('_BxFer'		, 06) // Baixa de Ferias
_SetOwnerPrvt('_Bx13O'		, 06) // Baixa de 13o Salario
_SetOwnerPrvt('_Bx14o'		, 06) // Baixa de 14o Salario
_SetOwnerPrvt( '_BxPLR'		, 06 )// Baixa de 13o Salario

_SetOwnerPrvt('_BxRes'		, 07) // Baixa de Rescisao
_SetOwnerPrvt('_TrfEnt'	, 08) // Transferencia de Entrada
_SetOwnerPrvt('_TrfSai'	, 09) // Transferencia de Saida
_SetOwnerPrvt('_BxTot'		, 10) // Baixa Total
//INDICA A COLUNA NA ORDEM EM QUE SERA APRESENTADA NO RELATORIO
_SetOwnerPrvt('_Dias'		, 1 ) // Dias de Ferias
_SetOwnerPrvt('_Avos'		, 1 ) // Avos de 13o Salario
_SetOwnerPrvt('_Prov'		, 2 ) // Valor da Provisao de Ferias ou Decimo Terceiro Salario
_SetOwnerPrvt('_Adic'		, 3 ) // Adicionais
_SetOwnerPrvt('_1Ter'		, 4 ) // Um Terco de Ferias
_SetOwnerPrvt('_1Par'		, 4 ) // 1o Parcela do 13o Salario
_SetOwnerPrvt('_INSS'		, 5 ) // INSS
_SetOwnerPrvt('_FGTS'		, 6 ) // FGTS
_SetOwnerPrvt('_SalV'		, 7 ) // Media Salario Vac
_SetOwnerPrvt('_PIS'		, 8 ) // PIS
//CONSTANTES QUE DEFINEM O NUMERO DE LINHAS E COLUNAS DO ARRAY
_SetOwnerPrvt('_Linhas'	, 10) // Quantidade de Linhas ou Elementos
_SetOwnerPrvt('_Colunas'	, 08) // Quantidade de colunas para cada Linha ou Elemento
//INDICA A POSICAO DAS INFORMACOES DE CABECALHO EM "aCabProv"
_SetOwnerPrvt('_DatCalc'	,  1) // Data do calculo
_SetOwnerPrvt('_CentroC'	,  2) // Data do calculo
_SetOwnerPrvt('_DBsProv'	,  3) // Data base de ferias
_SetOwnerPrvt('_DFerVen'	,  4) // Dias de ferias vencidas
_SetOwnerPrvt('_DFerPro'	,  5) // Dias de ferias proporcionais
_SetOwnerPrvt('_DFerAnt'	,  6) // Dias de ferias antecipadas
_SetOwnerPrvt('_DFalVen'	,  7) // Dias de faltas vencidas
_SetOwnerPrvt('_DFalPro'	,  8) // Dias de faltas proporcionais
_SetOwnerPrvt('_MovProv'	,  9) // Movimentacao no mes
_SetOwnerPrvt('_SalProv'	, 10) // Salario da provisao no mes
_SetOwnerPrvt('_Avos13S'	, 11) // Avos de 13o salario
_SetOwnerPrvt('_PStatus'	, 12) // Status (Ativo/Excluido)
_SetOwnerPrvt('_CItem'		, 13) // Item Contabil
_SetOwnerPrvt('_Clvl'		, 14) // Classe de Valor
//INDICA OS TIPOS DE MOVIMENTACAO DO FUNCIONARIO NO MES
_SetOwnerPrvt('_Demitido'	, 1 ) // Demitido
_SetOwnerPrvt('_Cong_Fer'	, 2 ) // Congelado Ferias
_SetOwnerPrvt('_Cong_13s'	, 3 ) // Congelado 13 Salario
_SetOwnerPrvt('_Cong_F13'	, 4 ) // Congelado Ferias e 13 Salario
_SetOwnerPrvt('_Trfe_Sai'	, 5 ) // Transferencia Saida
_SetOwnerPrvt('_Trfe_Ent'	, 6 ) // Transferencia Entrada
// INDICA AS POSICOES DENTRO DO ARRAY aTransf
_SetOwnerPrvt('_TAnter'		, 1 ) // Centro de Custo Anterior
_SetOwnerPrvt('_TAtual'		, 2 ) // Centro de Custo Atual
_SetOwnerPrvt('_TDest'		, 3 ) // Centro de Custo Destino
_SetOwnerPrvt('_TEmp'		, 1 ) // Empresa
_SetOwnerPrvt('_TFil'		, 2 ) // Filial
_SetOwnerPrvt('_TCC'		, 3 ) // Centro de Custo
_SetOwnerPrvt('_TMat'		, 4 ) // Matricula
_SetOwnerPrvt('_TDta'		, 5 ) // Data da Transferencia
_SetOwnerPrvt('_TInc'		, 6 ) // Funcionario ja incluido no arquivo temporario
_SetOwnerPrvt( '_TItem'		, 7  ) // Item Contabil
_SetOwnerPrvt( '_TClvl'		, 8  ) // Classe de valor
// VARIAVEIS PARA CRIACAO DOS ARQUIVOS TEMPORARIOS LOG/TRP/TPR
_SetOwnerPrvt('lGrid'		, aParms[6,11])	//	Mes de pagamento da 1a. parcela do 13o. salario
_SetOwnerPrvt('aLogFile'	, {}         )		// Nome do Arquivo de Log de identif. - fAdicLog()
_SetOwnerPrvt('cNameFile'	, aParms[6,7])		// Nome do Arquivo de Log
_SetOwnerPrvt('cDbfLog'		, aParms[6,8])		// Alias do Arquivo de Log
_SetOwnerPrvt('cChaveLog'	, aParms[6,9])		// Chave do Arquivo de Log
// VARIAVEIS PRIVATE DE GPM070PROCESSA
_SetOwnerPrvt('aTabFer'		, aParms[7, 1]) // Tabela para calculo dos dias de ferias
_SetOwnerPrvt('aTabFer2'	, aParms[7, 2]) // Tabela para calculo dos dias de ferias
_SetOwnerPrvt('cTpBxFer'	, aParms[7, 3]) // Baixa Ferias Total ou Mes e Mes Seguinte
_SetOwnerPrvt('cTpCongAf'	, "2") 			// Trata congelamento por periodo Aquisitivo ou Por afastamento
_SetOwnerPrvt('cTrfAMES'	, aParms[7, 5]) // Ano/Mes para inicio das demonstracoes de entrada e saida de transferencias no conceito 1 (transfere saldo origem p/ destino)
_SetOwnerPrvt('lTrfAMES'	, aParms[7, 6]) // Indica se utilizara se utilizara demonstracoes de entrada e saida de transferencias no conceito 1 (transfere saldo origem p/ destino)
_SetOwnerPrvt('cAbatAfas'	, aParms[7, 7]) // Indica se abate avos por Afast. no 13o Salario
_SetOwnerPrvt('cPgSalMat'	, aParms[7, 8]) // Abater Afastamento Auxilio Maternidade no 13o
_SetOwnerPrvt('lDif13Neg'	, aParms[7, 9]) // Gerar diferenca de 13o. negativa S/N
_SetOwnerPrvt('aTransf'  	, aParms[7,10]) // Array com as transferencias do funcionario
_SetOwnerPrvt('lSalInc'		, aParms[7,11]) // Utiliza salario incorporado
_SetOwnerPrvt('lTrataTrf'	, aParms[7,12]) // Utiliza conceito de transferencia de saldo demonstrando saida e entrada
_SetOwnerPrvt('c__Roteiro'	, aParms[7,13]) // Roteiro de calculo a ser processado
_SetOwnerPrvt('cPerFeAc'	, aParms[7,14]) // Usada na Funcao FCalcFimAq-(GpexMed).
_SetOwnerPrvt('lProvResc'	, aParms[7,15]) // Indica se devera provisionar no mes da rescisao
_SetOwnerPrvt('cCalcSalInc'	, aParms[7,17]) // Ano/Mes para inicio da busca dos salarios e adicionais no acumulado, sem a utilizacao da fSalInc.
_SetOwnerPrvt('lCalcSalInc'	, aParms[7,18]) // Define se busca os salarios e adicionais no acumulado, sem a utilizacao da fSalInc.
_SetOwnerPrvt('cNomeDe'		, aParms[7,19]) // Nome inicial para filtro na montagem do arquivo TPR
_SetOwnerPrvt('cNomeAte'	, aParms[7,20]) // Nome final para filtro na montagem do arquivo TPR
_SetOwnerPrvt('aInssEmp'	, aParms[7,22]) // Array com os percentuais e informacoes dos encargos da empresa
_SetOwnerPrvt('aCodFol'		, aParms[7,23]) // Array com os codigos de verbas que possuem identificador de calculo
_SetOwnerPrvt('aInfo'		, aParms[7,24]) // Arary com informacoes da empresa
_SetOwnerPrvt('aGPSPer'		, aParms[7,25]) //
_SetOwnerPrvt('aVerba'		, aParms[7,26]) //
_SetOwnerPrvt('nPerc1T'		, aParms[7,27]) //
_SetOwnerPrvt('nPercPis'	, aParms[7,28]) //
_SetOwnerPrvt('lTrfSld'		, aParms[7,29]) // Indica se eh demissao com transferencia e MV_PROVRES = N
_SetOwnerPrvt('dDataDem1'	, aParms[7,30]) // Data de demissao considerando MV_SABDOM
_SetOwnerPrvt('lGeraPmes'	, aParms[7,31]) // Gera rateio mensal
_SetOwnerPrvt('cTpRtProv'	, aParms[7,32]) // Determina Tipo de rateio / Alias a ser utilziado ("SRT*RHT")
_SetOwnerPrvt('lSabDom'		, aParms[7,33]) // Se pagara o sab e domingo qdo demissao na sexta
_SetOwnerPrvt('cOneFol'		, aParms[7,34] ) // Usada nas Funcoes fPercEmp, fEncargEmp e fProv13o
_SetOwnerPrvt('cAnoMes'		, aParms[7,35])
_SetOwnerPrvt('aPerFechado'	, aParms[7,36] 	) //
_SetOwnerPrvt('cMes'		, aParms[7,37] 	) //
_SetOwnerPrvt('cAno'		, aParms[7,38] 	) //
_SetOwnerPrvt('lTemVenc'	, aParms[7,39] 	) //
_SetOwnerPrvt('aPerAb13'	, aParms[7,40] 	) //
_SetOwnerPrvt('aPrAb131'	, aParms[7,41] 	) //
_SetOwnerPrvt('aPrAb132'	, aParms[7,42] 	) //
_SetOwnerPrvt('aPerFe13'	, aParms[7,43] 	) //
_SetOwnerPrvt('aPrFe131'	, aParms[7,44] 	) //
_SetOwnerPrvt('aPrFe132'	, aParms[7,45] 	) //
_SetOwnerPrvt('aPerAbPL'	, aParms[7,46] 	) //
_SetOwnerPrvt('aPerfePL'	, aParms[7,47] 	) //
_SetOwnerPrvt('cTBLXPROV'	, aParms[7,48] 	) //
_SetOwnerPrvt('cNOMETBPROV'	, aParms[7,49] 	) //
_SetOwnerPrvt('aIndice'		, aParms[7,50] 	) //
_SetOwnerPrvt('lVerFat'		, aParms[7,51] 	) //
// VARIAVEIS PRIVATE DE GPM070PROCESSA CARREGADAS POR IniVarGrd
_SetOwnerPrvt('aFerVenc'	, Array(_Linhas,_Colunas)	) //
_SetOwnerPrvt('aFerProp'	, Array(_Linhas,_Colunas)	) //
_SetOwnerPrvt('aFerPropB'	, Array(_Linhas,_Colunas)	) //
_SetOwnerPrvt('aRecVenc'	, Array(_Linhas,_Colunas)	) //
_SetOwnerPrvt('aRecProp'	, Array(_Linhas,_Colunas)	) //
_SetOwnerPrvt('nV_DFalFer'	, 0		) //
_SetOwnerPrvt('nP_DFalFer'	, 0		) //
_SetOwnerPrvt('nTFaltaV'	, 0		) //
_SetOwnerPrvt('nTFaltaP'	, 0		) //
_SetOwnerPrvt('nDFerAnt'	, 0		) //
_SetOwnerPrvt('cCodFer'		, ""	) //
_SetOwnerPrvt('cCodAdFer'	, ""	) //
_SetOwnerPrvt('cCodUmTer'	, ""	) //
_SetOwnerPrvt('cCodFerMs'	, ""	) //
_SetOwnerPrvt('cCodAdicMs'	, ""	) //
_SetOwnerPrvt('cCodUmTerMs'	, ""	) //
_SetOwnerPrvt('cCodAbono'	, ""	) //
_SetOwnerPrvt('cCodAboMs'	, ""	) //
_SetOwnerPrvt('cCodSalV'	, ""	) //
_SetOwnerPrvt('cCodSalVMs'	, ""	) //
_SetOwnerPrvt('dDtBasFer'	, CTOD("")	) //
_SetOwnerPrvt('a13Salar'	, Array(_Linhas,_Colunas)	) //
_SetOwnerPrvt('a14Salar'	, Array(_Linhas,_Colunas)	) //
_SetOwnerPrvt('aRec13Sl'	, Array(_Linhas,_Colunas)	) //
_SetOwnerPrvt('aRec14Sl'	, Array(_Linhas,_Colunas)	) //
_SetOwnerPrvt( 'aPLRSalar'	, Array(_Linhas,_Colunas)	) //
_SetOwnerPrvt( 'aRecPLRSl'	, Array(_Linhas,_Colunas)	) //
_SetOwnerPrvt('cCod13o'		, ""	) //
_SetOwnerPrvt('cCodPLR'		, ""	) //
_SetOwnerPrvt('cCodAd13o'	, ""	) //
_SetOwnerPrvt('cInss13o'	, ""	) //
_SetOwnerPrvt('lBx13Pgt'	, .F.	) //
_SetOwnerPrvt('lBx14Pgt'	, .F.	) //
_SetOwnerPrvt('lDesAtiv'	, .F.	) //
_SetOwnerPrvt('lOneAtiv'	, .F.   ) //
_SetOwnerPrvt('nAvosAnt'	, 0		) //
_SetOwnerPrvt('nPercAnt'	, 0		) //
_SetOwnerPrvt('nSalario'	, 0		) //
_SetOwnerPrvt('nSalMes'		, 0		) //
_SetOwnerPrvt('nSalDia'		, 0		) //
_SetOwnerPrvt('nSalHora'	, 0		) //
_SetOwnerPrvt('nPerEmp13'	, 0		) //
_SetOwnerPrvt('nPercEmp'	, 0		) //
_SetOwnerPrvt('nPercTer'	, 0		) //
_SetOwnerPrvt('nPercAcTrab'	, 0		) //
_SetOwnerPrvt('nPercFgts'	, 0		) //
_SetOwnerPrvt('lDemitido'	, .F.	) //
_SetOwnerPrvt('lTransfSai'	, .F.	) //
_SetOwnerPrvt('aRoteiro'	, {}	) //
_SetOwnerPrvt('nAdtServ'	, 0.00	) // Valor do Adicional por Tempo de Servico
_SetOwnerPrvt('nPeric'		, 0.00	) // Valor do Adicional de Periculosidade
_SetOwnerPrvt('nInsal'		, 0.00	) // Valor do Adicional de Insalubridade
_SetOwnerPrvt('nAdcConf'	, 0.00	) // Valor do Adicional de Cargo de ConfianÁa
_SetOwnerPrvt('nAdcTransf'	, 0.00	) // Valor do Adicional de TransferÍncia
_SetOwnerPrvt('nOutros'		, 0.00	) // Valor de outras verbas que incorporam
_SetOwnerPrvt('nSalHInc'	, 0.00  )
_SetOwnerPrvt('cCodAdt'		, Space(3)	) //
_SetOwnerPrvt('cCodIns'		, Space(3)	) //
_SetOwnerPrvt('nSalMin'		, 0		) //
_SetOwnerPrvt('cRecFatEmp'	, ""	) // X14_RECFAT
_SetOwnerPrvt('lDissidio'	, .F. 	) //
_SetOwnerPrvt('lINSSAut'	, .F. 	) //
_SetOwnerPrvt( '_cPdPLR'	, "XXX" 	) //
_SetOwnerPrvt( '_cPdBxPLR'	, "XX1"	) //
_SetOwnerPrvt( '_cPdMesPLR'	, "XX2"	) //
_SetOwnerPrvt( '_cPdtrfPLR'	, "XX3"	) //
_SetOwnerPrvt( '_cPdResPLR'	, "XX4"	) //
_SetOwnerPrvt( 'lPlrPE'		, ExistBlock("GP070PLR")	) //
_SetOwnerPrvt( '_cFechaPlr'	, GetMvRH("MV_PLRPER",,"12")	) //
_SetOwnerPrvt( '_lVlrBaixa'	, GetMvRH("MV_PLRVLBX",,.F.)	) //
_SetOwnerPrvt('nDiasProp'	, 0	) //
_SetOwnerPrvt('nDiasVenc'	, 0	) //
_SetOwnerPrvt('nTDiasAfa'	, 0	) //
_SetOwnerPrvt('lAdicProp'	,.F.) //
_SetOwnerPrvt( 'nPosFil'	, 01)
_SetOwnerPrvt( 'nPosMat'	, 02)
_SetOwnerPrvt( 'nPosPd'		, 03)
_SetOwnerPrvt( 'nPosTipo'	, 04)
_SetOwnerPrvt( 'nPosQtdSem'	, 05)
_SetOwnerPrvt( 'nPosHoras'	, 06)
_SetOwnerPrvt( 'nPosValor'	, 07)
_SetOwnerPrvt( 'nPosSemana'	, 08)
_SetOwnerPrvt( 'nPosParcela', 09)
_SetOwnerPrvt( 'nPosPeriodo', 10)
_SetOwnerPrvt( 'nPosRoteiro', 11)
_SetOwnerPrvt( 'nPosCc'		, 12)
_SetOwnerPrvt( 'nPosData'	, 13)
_SetOwnerPrvt( 'nPosDtRef'	, 14)
_SetOwnerPrvt( 'nPosSeq'	, 15)
_SetOwnerPrvt( 'nPosTpo2'	, 17)
_SetOwnerPrvt( 'cCodAdiAbo' ,"")
_SetOwnerPrvt( 'cCodAdAMs'  ,"")
_SetOwnerPrvt( 'cTipoPesq'  ,"PRFE")
_SetOwnerPrvt( 'l13Estag'   , .F.)
_SetOwnerPrvt('nSalInc'	    , 0.00)
_SetOwnerPrvt('aPerAbAUT'   ,{})
_SetOwnerPrvt('aPerFeAUT'   ,{})

If !Empty(cIdPlr) .And. ";" $ cIdPlr
	aPdPlr := Separa(cIdPlr,";")
EndIf

If Len(aPdPlr) == 5
	 _cPDPlr 	  := aPdPlr[1]
	 _cPdBxPLR 	  := aPdPlr[2]
	 _cPdMesPLR   := aPdPlr[3]
	 _cPDTrfPLR   := aPdPlr[4]
	 _cPDResPLR   := aPdPlr[5]
EndIf

//CRIA ARQUIVO DE MEDIAS TEMPORARIO
Cria_TRP()

Return(lRet)


/*
‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±…ÕÕÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÀÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÀÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÕÕÕª±±
±±∫Programa  ≥GPM070END ∫Autor  ≥Jonatas A. T. Alves ∫ Data ≥  18/08/08   ∫±±
±±ÃÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕ ÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ ÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕÕÕÕπ±±
±±∫Desc.     ≥Finalizacao da Thread na provisao                           ∫±±
±±ÃÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕπ±±
±±∫Uso       ≥ Gpem070                                                    ∫±±
±±»ÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕº±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂ*/
Function GPM070END()

// EXCLUSAO DOS ARQUIVOS TEMPORARIOS CRIADOS PARA MEDIA
fDelTMPMED()
Return(.T.)

/*
‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±…ÕÕÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÀÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÀÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÕÕÕª±±
±±∫Programa  ≥GPM070GRD ∫Autor  ≥Mauricio Takakura   ∫ Data ≥  31/01/07   ∫±±
±±ÃÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕ ÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ ÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕÕÕÕπ±±
±±∫Desc.     ≥Funcao para Encapsulamento de Multiprocessamento            ∫±±
±±ÃÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕπ±±
±±∫Uso       ≥ Gpem070                                                    ∫±±
±±»ÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕº±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂ*/
Function GPM070GRD(aCall)
Local aLog 			:= {} 	// Log por Lote enviado
Local aSvLog		:= {}
Local aFields		:= {}
Local aFieldsAux	:= {}
Local cFilCalc 			// Filial
Local cMatrCalc			// Matricula
Local cCCCalc			// C.Custo
Local cChave
Local cCond			:= If(nOrdem == 1, '(cTBLXPROV)->(PR_FILIAL + PR_MAT)', '(cTBLXPROV)->(PR_FILIAL + PR_CC + PR_MAT)')
Local cRequis
Local cQuery
Local cMsgLog
Local lRet			:= .T.
Local nX
Local nY
Local nT
Local nTotReg
Local nTpMvCalc			// Tipo do movimento
Local nTrf
Local nEleTrf
Local uRetCalc
Local cBkpBxFer

//TRATAMENTO PARA ARQUIVO DE LOG
If !(lRet := MsOpenDbf(.T. , "TOPCONN", cNameFile , cDbfLog , .T. , .F. , .F. , .F.))
	cMsgLog := CRLF + OemToAnsi(STR0043) // "Nao foi possivel abrir o Arquivo de Log de Registros"
	UserException(cMsgLog)		// Abortado o calculo pela execucao do Calculo
EndIf

If !(lRet := (Select(cDbfLog) > 0))
	cMsgLog := CRLF + OemToAnsi(STR0043) // "Nao foi possivel abrir o Arquivo de Log de Registros"
	UserException(cMsgLog)		// Abortado o calculo pela execucao do Calculo
EndIf

If oTMPProv == Nil
	Cria_TPR(aIndice) //Recria a tempor·ria utilizando fwtemporarytable
	aFieldsAux := oTMPProv:GetStruct():aFields
	aEval(aFieldsAux, {|x| aAdd(aFields,x[1])})
EndIf

nTotReg := Len(aCall)

For nX := 1 to nTotReg
	RecLock(cTBLXPROV, .T.)

	(cTBLXPROV)->PR_FILIAL  := aCall[nX][2]
	(cTBLXPROV)->PR_MAT     := aCall[nX][3]
	(cTBLXPROV)->PR_CC		:= aCall[nX][4]
	(cTBLXPROV)->PR_TIPMOVI := aCall[nX][5]
	(cTBLXPROV)->PR_NOME    := aCall[nX][6]
	(cTBLXPROV)->PR_ADMISSA := aCall[nX][7]
	(cTBLXPROV)->PR_DEMISSA := aCall[nX][8]
	(cTBLXPROV)->PR_SITFOLH := aCall[nX][9]
	(cTBLXPROV)->PR_AFASFGT := aCall[nX][10]
	(cTBLXPROV)->PR_TPCONTR := aCall[nX][11]
	(cTBLXPROV)->PR_HRSMES  := aCall[nX][12]
	(cTBLXPROV)->PR_SALINCO := aCall[nX][13]
	(cTBLXPROV)->PR_PERICUL := aCall[nX][14]
	(cTBLXPROV)->PR_INSMIN	:= aCall[nX][15]
	(cTBLXPROV)->PR_INSMED	:= aCall[nX][16]
	(cTBLXPROV)->PR_INSMAX	:= aCall[nX][17]
	(cTBLXPROV)->PR_ADTPOSE	:= aCall[nX][18]
	(cTBLXPROV)->PR_INSSAUT := aCall[nX][19]
	(cTBLXPROV)->PR_CATFUNC := aCall[nX][20]
	(cTBLXPROV)->PR_ITEM    := aCall[nX][21]
	(cTBLXPROV)->PR_CLVL    := aCall[nX][22]
	(cTBLXPROV)->PR_CCMVTO 	:= aCall[nX][23]
	(cTBLXPROV)->PR_ITMMVTO := aCall[nX][24]
	(cTBLXPROV)->PR_CLVMVTO := aCall[nX][25]
	MsUnlock()
Next nX

If !(Select(cTrfDbf) > 0) //So abre o alias no primeiro calculo da Thread
	If !(lRet := MsOpenDbf(.T. , "TOPCONN", cFileTrf , cTrfDbf , .T. , .F. , .F. , .F.))
		cMsgLog := CRLF + OemToAnsi(STR0063) // "Nao foi possivel abrir o Arquivo de Log de Registros"
		UserException(cMsgLog)		// Abortado o calculo pela execucao do Calculo
	EndIf
EndIf

//PREPARACAO DO ARRAY ATRANSF A PARTIR DA TABELA TEMPORARIA
If Empty(aTransf)

	DEFAULT lItemClVl   := GetMvRH( "MV_ITMCLVL", .F., "2" ) $ "13"

	aTransf := Array(nTamTrf, 3, If(lItemClVl,8,6))
	dbSelectArea(cTrfDbf)
	While !(cTrfDbf)->(Eof())
		nTrf 	:= (cTrfDbf)->TRFPOS	 // Posicao no aTransf original
		nEleTrf := (cTrfDbf)->TRFELE	 // Posicao no aTransf original
		aTransf[nTrf, nEleTrf, 1] := (cTrfDbf)->TRFEMPP
		aTransf[nTrf, nEleTrf, 2] := (cTrfDbf)->TRFFILIALP
		aTransf[nTrf, nEleTrf, 3] := (cTrfDbf)->TRFCCP
		aTransf[nTrf, nEleTrf, 4] := (cTrfDbf)->TRFMATP
		aTransf[nTrf, nEleTrf, 5] := (cTrfDbf)->TRFDATE
		aTransf[nTrf, nEleTrf, 6] := (cTrfDbf)->TRFNLIDO

		If lItemClVl
			aTransf[nTrf, nEleTrf, 7] := (cTrfDbf)->TRFITMP
			aTransf[nTrf, nEleTrf, 8] := (cTrfDbf)->TRFCLVLP
		EndIf

		(cTrfDbf)->(dbSkip())
	EndDo
EndIf

//INCLUIR O REGISTRO DA REQUISICAO NO LOG
DbSelectArea(cDbfLog)
cRequis := StrZero(aCall[1,1] , 8)
RecLock(cDbfLog , .T., .T.)
(cDbfLog)->CHAVE 	:= cChaveLog
(cDbfLog)->REQUIS 	:= cRequis
(cDbfLog)->(MsUnLock())

cBkpBxFer := cTpBxFer

For nX := 1 to nTotReg
	cTpBxFer := cBkpBxFer
	cFilCalc 	:= aCall[nX,2]	// Filial
	cMatrCalc	:= aCall[nX,3]	// Matricula
	cCCCalc		:= aCall[nX,4]	// C.Custo
	nTpMvCalc	:= aCall[nX,5]	// Tipo do movimento

	//GARANTE SELECAO DAS AREAS UTILIZADAS
	dbSelectArea("SRT")
	SRT->(dbGoTop())

	dbSelectArea("SRC")
	dbSetOrder(1)
	SRC->(dbGoTop())

	dbSelectArea("SRA")
	dbSetOrder(1)
	SRA->(dbGoTop())
	dbSeek(cFilCalc + cMatrCalc, .F.)

	dbSelectArea(cTBLXPROV)
	dbSetOrder(1)

	// O TPR PODE ESTAR NAS ORDENS 1 OU 2 NO CALCULO DA PROVISAO
	If nOrdem == 1
		cChave := cFilCalc + cMatrCalc
		dbSeek(cFilCalc + cMatrCalc, .F.)
	Else
		cChave := cFilCalc + cCCCalc + cMatrCalc
		dbSeek(cFilCalc + cCCCalc + cMatrCalc, .F.)
	EndIf

	//PODE HAVER MAIS DE UM REGISTRO DO FUNCIONARIO NO TPR, COM C.CUSTO E/OU TIPO DE MOVIMENTACAO DIFERENTES
	While !(cTBLXPROV)->(Eof()) .And. &(cCond) == cChave
		If	(cTBLXPROV)->(PR_CC == cCCCalc .And. PR_TIPMOVI	== nTpMvCalc)
			Exit
		Else
			(cTBLXPROV)->(dbSkip())
			Loop
		EndIf
	EndDo

	//EXECUTA O CALCULO DA PROVISAO
	uRetCalc := GPM070CALG()

	// VERIFICA SE EXISTE MENSAGEM PARA ENVIO AO FINAL DO PROCESSAMENTO
	aSvLog 		:= GetMsgLogGrid()		// Retorna o Log de Erros
	lBreakCalc 	:= AbortCalc()			// Verifica se foi solicitado o cancelamento do calculo no LOG

	//VERIFICA OCORRENCIA DE MENSAGENS DE LOG DE RETORNO DA GPM070CALG()
	If (ValType(uRetCalc) == "L" .And. !uRetCalc) .Or. lBreakCalc
		nX := nTotReg
		cMsgLog := CRLF + CRLF
		For nT := 1 To Len(aSvLog)
			For nY := 1 To Len(aSvLog[nT])
				cMsgLog += aSvLog[nT,nY] + CRLF
			Next nY
		Next nT
		If !lBreakCalc
			cMsgLog += CRLF + "Aborted by UserException" // Complemento da Mensagem que sera enviado pelo Gerenciamento do GRID
		Else
			cMsgLog += CRLF + "Calculate Process Aborted with UserException by" // Complemento da Mensagem que sera enviado pelo Gerenciamento do GRID
		EndIf
		UserException(cMsgLog)		// Abortado o calculo pela execucao do Calculo
	EndIf

	// OCORRENCIAS DE LOG QUE NAO ABORTARAM O CALCULO
	If !Empty(aSvLog)
		aAdd(aLog, { SRA->RA_FILIAL + "  " + SRA->RA_MAT + "  " + SRA->RA_NOME, aClone(aSvLog) })
		RstMsgLogGrid()
	EndIf

	//ATUALIZAR O LOG COM O ULTIMO FUNCION. PROCESSADO DA REQUISICAO
	cQuery := " UPDATE "
	cQuery += " "+ cNameFile +" "
	cQuery += " SET   CONTROL = '1',  "
	cQuery += " FILIAL = '" + SRA->RA_FILIAL + "', "
	cQuery += " MAT = '" + SRA->RA_MAT + "', "
	cQuery += " DT_GRAVA = '" + DTOC(MsDate()) + "', "
    cQuery += " HR_GRAVA = '" + Time() + "' "
    cQuery += " WHERE CHAVE = '" + cChaveLog + "'"
    cQuery += "   AND REQUIS = '" + cRequis + "'"
	TcSqlExec(cQuery)
Next nX

If Empty(aLog)
	aLog := NIL
EndIf

//ATUALIZAR O LOG COM O TIPO 3-FINALIZADO COM SUCESSO
cQuery := " UPDATE "
cQuery += " "+ cNameFile +" "
cQuery += " SET   CONTROL = '3' "
cQuery += " WHERE CHAVE = '" + cChaveLog + "'"
cQuery += "   AND REQUIS = '" + cRequis + "'"
TcSqlExec(cQuery)

(cDbfLog)->(DbCloseArea())

Return(aLog)

/*
‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±…ÕÕÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÀÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÀÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÕÕÕª±±
±±∫Programa  ≥GPM070CALG∫Autor  ≥Jonatas A. T. Alves ∫ Data ≥  18/08/08   ∫±±
±±ÃÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕ ÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ ÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕÕÕÕπ±±
±±∫Desc.     ≥Funcao para calculo da provisao Geral (Normal / GRID        ∫±±
±±ÃÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕπ±±
±±∫Uso       ≥ Gpem070                                                    ∫±±
±±»ÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕº±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂ*/
Static Function GPM070CALG()
Local cCongFeR 		:= "1" 						 		// Indica se congela por Afast. Acidente
Local cCong13		:= "2" 							 	// Indica se congela por Afast. Doenca
Local cProcMed		:= ""
Local cChaveSRF
Local nTipoMovMes  	:= 0
Local nPercFgC     	:= 0
Local aCabProv     	:= {}
Local aPerFerAux   	:= {}
Local aRecBxa   	:= {}
Local lTemCab		:= .F.
Local dRefMed		:= dDataRef
Local dBkpData		:= dDataRef
Local Nx            := 0
Local nA			:= 0
Local nPosAux		:= 0
Local nRecnoSRF		:= 0
Local nDiasAf		:= 0
Local lDiasAfAcum   := .T.
Local lPriVez       := .T.
Local lRCBExcl		:= !( Empty( xFilial("RCB") ) )
Local lRCHExcl      := !( Empty( xFilial("RCH") ) )
Local cPdAdic      	:= ""
Local nDiasFv
Local cPdResc		:= ""
Local cPdsAts		:= ""
Local cPdsPer		:= ""
Local cPdsIns		:= ""
Local cPdsAdC		:= ""
Local cPdsAdT		:= ""
Local cPdsComis     := ""
Local cFolAts		:= ""
Local cFolPer		:= ""
Local cFolIns		:= ""
Local cFolAdC		:= ""
Local cFolAdT		:= ""
Local lBaseConf		:= .F.
Local lCabec        := .F.
Local lDemMes		:= .F.
Local lDemfer		:= .F.
Local nDiasAux      := 0
Local nOrdAux       := 0
Local nPosTbFer		:= 0
Local nTempoParc	:= 0
Local dFerOpen		:= CtoD("")
Local aPLR			:= {}
Local nValPLR  		:= 0
Local nDFerPer		:= 0
Local n13Fer		:= 0
Local lFerAberto	:= .T.
Local lMesmoMes		:= .F.
Local lMudaData		:= .F.
Local lBx2Per		:= .F.
Local lFer2PerAq	:= .F.
Local lFer2Aux		:= .F.
Local lFirstSRF		:= .T.
Local dDtCalcFer
Local cTmpSRF		:= ""
Local cPd			:= ""
Local lMudouRat		:= .F.
Local lZerouSal     := .F.
Local lFerPaga 		:= SRF->(ColumnPos( "RF_FERPAGA" )) > 0
Local nBkpDiasC		:= 0
Local lFolAtsInc	:= .F.
Local cPdsPeNInc	:= ""
Local cCodPd		:= ""
Local nValor		:= 0
Local nSubATS		:= 0
Local nValPer		:= 0
Local lPerInc		:= .F.
Local lCodMPA 		:= SRV->(ColumnPos( "RV_CODMPA" )) > 0
Local lCttPerEmp	:= CTT->(ColumnPos( "CTT_PEREMP" )) > 0
Local lFerMesResc	:= .F.
Local nDiasMat		:= 0
Local nPos			:= 0
Local nAfastAux		:= 0
Local cFilPD  		:= ""
Local lCpoHrJova 	:= SRA->(ColumnPos( "RA_HOJORVA" )) > 0
Local lBxFerAnt		:= .F.
Local lSegPlan      := FwIsInCallStack("WFLAUNCHER") .or. FwIsInCallStack("FWBOSCHDEXECUTE")

Private aRateio		:= {}
Private aAdicProv	:= {}

Private aFldRot 	:= {'RA_NOME'}
Private aOfusca	 	:= If(FindFunction('ChkOfusca'), ChkOfusca(), {.T.,.F.}) //[1] Acesso; [2]Ofusca
Private lOfuscaNom 	:= .F.
Private aFldOfusca 	:= {}
Private lSemSRF		:= .F.

DEFAULT lProvFec    := GetMvRH("MV_PROVFEC", Nil, .F.)

If aOfusca[2]
	aFldOfusca := FwProtectedDataUtil():UsrNoAccessFieldsInList( aFldRot ) // CAMPOS SEM ACESSO
	IF aScan( aFldOfusca , { |x| x:CFIELD == "RA_NOME" } ) > 0
		lOfuscaNom := FwProtectedDataUtil():IsFieldInList( "RA_NOME" )
	ENDIF
EndIf

SetMnemonicos(xFilial("RCA"),NIL,.T.,"P_REGPARCI")
SetMnemonicos(xFilial("RCA"),NIL,.T.,"P_RECDES")
SetMnemonicos(xFilial("RCA"),NIL,.T.,"P_ADISMED")
SetMnemonicos(xFilial("RCA"),NIL,.T.,"P_LPROVEST")
SetMnemonicos(xFilial("RCA"),NIL,.T.,"P_DINIADI")
SetMnemonicos(xFilial("RCA"),NIL,.T.,"P_DFIMADI")
SetMnemonicos(xFilial("RCA"),NIL,.T.,"P_MP1046QUI")

P_REGPARCI			:= If( Type("P_REGPARCI") == "U", .F., P_REGPARCI)
P_RECDES			:= If (Type("P_RECDES") == "U", "A", P_RECDES)
P_ADISMED			:= If (Type("P_ADISMED") == "U", .T., P_ADISMED)
P_LPROVEST			:= If (Type("P_LPROVEST") == "U", .F., P_LPROVEST)
P_DINIADI			:= If (Type("P_ADISMED") == "U", cToD("//"), P_DINIADI)
P_DFIMADI			:= If (Type("P_DFIMADI") == "U", cToD("//"), P_DFIMADI)
P_MP1046QUI			:= If (Type("P_MP1046QUI") == "U", cToD("//"), P_MP1046QUI)

If lGrid
	IniVarGrd() // INICIALIZA VARIAVEIS PRIVATE COM CONTEUDOS PADROES
EndIf

// Inicializa a gravacao dos lancamentos do SIGAPCO
PcoIniLan("000091")

If lGeraPMes
	fVerRateio()
EndIf

// QUEBRA FILIAL PARA BUSCAR AS TABELAS
If (cTBLXPROV)->PR_FILIAL # cFilialAnt
	If lRCHExcl .Or. (!lRCHExcl .And. cFilialAnt == Replicate("!", FWGETTAMFILIAL) )
		// Carregar os periodos abertos (aPerAberto) e/ou fechados (aPerFechado), de acordo com a competencia de calculo
		fGetPer13(cAno, xFilial("RCH",(cTBLXPROV)->PR_FILIAL), Nil, fGetCalcRot("5"), @aPrAb131, @aPrFe131, Nil)//131
		fGetPer13(cAno, xFilial("RCH",(cTBLXPROV)->PR_FILIAL), Nil, fGetCalcRot("6"), @aPrAb132, @aPrFe132, Nil)//132
		aPerFe13 := aClone(aPrFe131)
		For nX := 1 to Len(aPrFe132)
			Aadd(aPerFe13,aClone(aPrFe132[nX]))
		Next nX

		aPerAb13 := aClone(aPrAb131)
		For nX := 1 to Len(aPrAb132)
			Aadd(aPerAb13,aClone(aPrAb132[nX]))
		Next nX

		fRetPerComp(cMes, cAno, xFilial("RCH",(cTBLXPROV)->PR_FILIAL), Nil, fGetRotOrdinar(), @aPerAberto, @aPerFechado)

		fRetPerComp(cMes, cAno, xFilial("RCH",(cTBLXPROV)->PR_FILIAL), Nil, fGetCalcRot("9"), @aPerAbAUT, @aPerFeAUT)

		fRetPerComp(cMes, cAno, xFilial("RCH",(cTBLXPROV)->PR_FILIAL), Nil, fGetCalcRot("F"), @aPerAbPL, @aPerFePL)

	EndIf

	If !Fp_CodFol(@aCodFol,(cTBLXPROV)->PR_FILIAL) .Or.;
	   !fInfo(@aInfo,(cTBLXPROV)->PR_FILIAL)
        Return(.F.)
	Endif
	If lRCBExcl
		RstGpexIni()
	EndIf
	If !fInssEmp((cTBLXPROV)->PR_FILIAL,@aInssEmp,.F.,MesAno(dDataRef))
		If lGrid
			MsgLogGrid(Ap5GetHelp("GR240SEMP"),.F.)
		ElseIf !lSegPlan
			Aviso(STR0015, STR0105, { STR0016 }) // "Atencao" ## "Tabelas S037 e S038 n„o est„o cadastradas para o perÌodo de c·lculo." ## "Ok"
		EndIf
		Return(.F.)		
	EndIf
	//-- Volta o conte˙do dDataRef que foi informado nos par‚metros
	dDataRef := dBkpData
	//RESGATA OS PERCENTUAIS DE TERCEIROS ARMAZENADOS NA TABELA AUXILIAR S035
	fGPSVal((cTBLXPROV)->PR_FILIAL,"999999",@aGPSPer,"1")
	// LIMPA ARRAY DE IDENTIFICADORES UTILIZADOS NA CADASTRADOS
	aIdProvis := {}
	// CARREGA CODIGOS DE FERIAS/13o SALARIO PARA BAIXA DA PROVISAO
	fBusCodBx((cTBLXPROV)->PR_FILIAL)
	// CARREGA OS IDENTIFICADORES DA PROVISAO
	fIdentProv(@aVerba,aCodFol)
	// VERIFICA A EXISTENCIA DOS IDENTIFICADORES DA PROVISAO
	If (cTBLXPROV)->PR_CATFUNC $ "E|G"
		fChkIdent(aVerba,_RecVenc,{_Atual,_BxFer,_BxTrf},.T.)
	Else
		fChkIdent(aVerba,_FerVenc,{_Atual,_BxFer,_BxTrf},.T.)
	Endif
	fChkIdent(aVerba,_13Salar,{_Atual,_BxTrf},.T.)
	// VERIFICA A EXISTENCIA DOS IDENTIFICADORES DA PROVISAO MES
	If lGeraPMes
		If (cTBLXPROV)->PR_CATFUNC $ "E|G"
			fChkIdent(aVerba,_RecVenc,{_Atual},.T.)
		Else
			fChkIdent(aVerba,_FerVMes,{_Atual},.T.)
		Endif
		fChkIdent(aVerba,_13SVMes,{_Atual},.T.)
		fChkIdent(aVerba,_PLRSVMes,{_Atual},.T.)
	Endif

	// VERIFICA A EXISTENCIA DOS IDENTIFICADORES DE BAIXA DE 13o
	lBx13Pgt  := fChkIdent(aVerba,_13Salar,{_Bx13O},.T.)
	lBxPlrPgt := fChkIdent(aVerba,_PlrSalar,{_BxPlr},.T.)
	If n14Salario > 0
		lBx14Pgt := fChkIdent(aVerba,_14Salar,{_Bx14O},.T.)
	EndIf

	// VERIFICA A EXISTENCIA DOS IDENTIFICADORES DE CORRECAO
	If nCorrecao > 0
		If (cTBLXPROV)->PR_CATFUNC $ "E|G"
			fChkIdent(aVerba,_RecVenc,{_Corre},.T.)
		Else
			fChkIdent(aVerba,_FerVenc,{_Corre},.T.)
		Endif
		fChkIdent(aVerba,_13Salar,{_Corre},.T.)
	EndIf

	// VERIFICA A EXISTENCIA DOS IDENTIFICADORES DA PROVISAO 14 SAL
	If n14Salario > 0
		fChkIdent(aVerba,_14Salar,{_Atual},.T.)
	EndIf

	// BUSCA PERCENTUAL DO IDENTIFICADOR DE 1/3 DE FERIAS
	dbSelectArea(cTBLXPROV)
	cFilAnt := cFilialAnt := (cTBLXPROV)->PR_FILIAL
	nPerc1T := RetValSrv(aCodFol[77,1],(cTBLXPROV)->PR_FILIAL,"RV_PERC")

	// BUSCA O PERCENTUAL DO IDENTIFICADOR DO PIS
	nPercPis := RetValSrv(aCodFol[229,1],(cTBLXPROV)->PR_FILIAL,"RV_PERC") / 100

	// SE GEROU OCORRENCIAS ABORTA PARA APRESENTACAO DO LOG
	If fAdicLog(aIdProvis,(cTBLXPROV)->PR_FILIAL)
		Return(.F.)
	EndIf

	cProcMed  := ""
EndIf

lBaseConf := ( Len(aCodFol) >= 1421 )

cProcesso := SRA->RA_PROCES
lHojorva  := SRA->RA_CATFUNC == "H" .And. lCpoHrJova .And. SRA->RA_HOJORVA == "1"

If cProcMed <> cProcesso
	cProcMed   := cProcesso
	lFechou13  := .F.
	lFechouMes := .F.
	For nX := 1 To Len(aPerFe13)
		If aPerFe13[nX,3] + aPerFe13[nX,4] == cMes + cAno .and. aPerFe13[nX,7] == cProcMed
			//Se existe roteiro 131 na semana "02" e naı foi fechado, trata como aberto.
			If ( aScan(aPerAb13, {|x| x[1]+x[7]+x[8] == aPerFe13[nX,1] + aPerFe13[nX,7] + aPerFe13[nX,8] .and. x[2] > aPerFe13[nX,2]}) ) == 0
				lFechou13 := .T.
			EndIf
		EndIf
	Next nX
	For nX := 1 To Len(aPerFechado)
		If aPerFechado[nX,3] + aPerFechado[nX,4] == cMes + cAno .and. aPerFechado[nX,7] == cProcMed
			lFechouMes := .T.
		EndIf
	Next nX
EndIf

If lProvFec .And. !lFechouMes
	Iif( !lGrid, aAdd(aLogFile[2], (cTBLXPROV)->PR_FILIAL + " - " + (cTBLXPROV)->PR_MAT + STR0110 ), MsgLogGrid( " - " + STR0110 ) )//" n„o foi calculada pois o perÌodo n„o foi fechado."	
	Return(.T.)
EndIf

//| CARREGA TABELA PARA APURACAO DOS DIAS DE FERIAS - ATABFER    |
//| 1-MESES PERIODO    2-NRO PERIODOS   3-DIAS DO MES    4-FATOR |
fTab_Fer(@aTabFer,,@aTabFer2)
dDataRef := dBkpData

//Se as horas semanais forem inferiores a 26, e o Mnemonico P_REGPARCI estiver ativo,
//utiliza os dias de fÈrias da tabela S065 - Tabela de fÈrias tempo parcial (Artigo 130A da CLT)
If cPaisLoc == "BRA"
	nTempoParc := SRA->RA_HRSEMAN
	If ( SRA->RA_HOPARC == "1" .And. nTempoParc <= 25 .And. nTempoParc  > 0 .And. Len(aTabFer2) > 0 .And. P_REGPARCI )
		nPosTbFer := Ascan(aTabFer2, { |X|  nTempoParc <= X[6] .And. nTempoParc > X[5] })
		If nPosTbFer > 0
			aTabFer := aClone(aTabFer2[nPosTbFer])
		Endif
	Endif
EndIf

// Carrega variaveis para calculo dos encargos
fEncargEmp(@nPercEmp, @nPercTer, @nPercAcTrab, @nPercFgts, nPercFgC, @cRecFatEmp, @nPerEmp13, lCttPerEmp)

nRecnoSRF := 0
nDFerAnt  := 0								  // Dias de ferias antecipadas
dDtBasFer := (cTBLXPROV)->PR_ADMISSA			      // Data Base Ferias Funcionario
dDtBasCal := dDtBasFer                        // Data Base utilizada no calculo (de acordo com data de referencia)

dbSelectArea("SRF")
SRF->(dbSetOrder(2))

If !SRF->(dbSeek((cTBLXPROV)->(PR_FILIAL + PR_MAT + aCodFol[72,1]))) .And. (SRA->RA_CATFUNC $ "E*G" .And. ((!SRF->(dbSeek((cTBLXPROV)->(PR_FILIAL + PR_MAT + aCodFol[891,1])))) .Or. ( (SRF->(dbSeek((cTBLXPROV)->(PR_FILIAL + PR_MAT + aCodFol[891,1])))) .And. nPergPro==2 .And. !P_LPROVEST)))
	//SE N√O ENCONTRAR AS VERBAS DE FERIAS OU RECESSO DE ESTAGIARIO EMITE LOG
	If !SRF->(dbSeek((cTBLXPROV)->(PR_FILIAL + PR_MAT + aCodFol[72,1]))) .And. (SRA->RA_CATFUNC $ "E*G" .And. ((!SRF->(dbSeek((cTBLXPROV)->(PR_FILIAL + PR_MAT + aCodFol[891,1]))))))
		lSemSRF := .T.
	//SE FOR ESTAGIARIO E SELECIONOU PROVISAO DE 13∫ SALARIO EMITE LOG
	ElseIf SRA->RA_CATFUNC $ "E*G" .And. ( (SRF->(dbSeek((cTBLXPROV)->(PR_FILIAL + PR_MAT + aCodFol[891,1]))) .And. nPergPro==2 .And. !P_LPROVEST) )
		l13Estag := .T.
	Endif
	// Adiciona aviso informando funcionario nao calculado
	If lPriVez
		Aadd(aLogFile, { OemToAnsi(STR0080), "" } ) //"FUNCIONARIOS NAO CALCULADOS!"
		If lSemSRF
			Aadd(aLogFile[1], OemToAnsi(STR0081)) //"Nao foi encontrado registro de periodo aquisitivo no Controle de Dias de Direito ( SRF )"
			lSemSRF := .F.
		Endif
		If l13Estag
			Aadd(aLogFile[1], OemToAnsi(STR0104)) //"Foi solicitada a Provis„o de 13∫ Sal·rio para Estagi·rio, o c·lculo n„o ser· efetuado."
			l13Estag := .F.
		Endif
		Aadd(aLogFile[1], "" )
		Aadd(aLogFile[1], OemToAnsi(STR0082)) // "Filial  Matricula   Nome                               Admissao"
		Aadd(aLogFile[1], "------  ---------   ---------------------------------  ----------" )
		lPriVez := .F.
	EndIf
	Aadd(aLogFile[1], (cTBLXPROV)->(PR_FILIAL + "      " + PR_MAT + "      " + If(lOfuscaNom,Replicate('*',15),PR_NOME) + "     " + DTOC((cTBLXPROV)->PR_ADMISSA)))
	Return(.T.)
Else
	// CARREGA PERIODOS AQUISITIVOS PARA CALCULO
	dDataAux := dDtBasFer
	dFerOpen := CtoD("")
	aPerFerAux := {}
	cChaveSRF := (cTBLXPROV)->PR_FILIAL + (cTBLXPROV)->PR_MAT + If((cTBLXPROV)->PR_CATFUNC $ "E|G" ,aCodFol[891,1], aCodFol[72,1])

	nRecnoSRF := 0
	lMudaData := .T.
	lBx2Per	  := .F.
	lFer2PerAq:= .F.
	lFirstSRF := .T.

	cTmpSRF := GetNextAlias()
	cPd := If((cTBLXPROV)->PR_CATFUNC $ "E|G" ,aCodFol[891,1], aCodFol[72,1])
	BeginSql alias cTmpSRF
		SELECT R_E_C_N_O_ AS RECNO
		FROM %table:SRF% SRF
		WHERE SRF.RF_FILIAL =  %exp:(cTBLXPROV)->PR_FILIAL%
		AND SRF.RF_MAT =  %exp:(cTBLXPROV)->PR_MAT%
		AND SRF.RF_PD =  %exp:cPd %
		AND SRF.RF_DATABAS <= %exp:Dtos(dDataRef)%
		AND SRF.RF_STATUS <> '2'
		AND SRF.%notDel%
		ORDER BY RF_DATABAS desc
	EndSql

	If !Empty(SRA->RA_DEMISSA) .And. AnoMes(dDataRef) <= AnoMes(SRA->RA_DEMISSA)
		dFerOpen := GetDferRes((cTmpSRF)->RECNO)
	EndIf

	While !(cTmpSRF)->(EOF())
		If nRecnoSRF == 0
			nRecnoSRF := (cTmpSRF)->RECNO
		EndIf
		SRF->(dbGoto((cTmpSRF)->RECNO))
		dDtCalcFer 	:= SRF->RF_DATABAS
		lFer2Aux	:= .F.
		nDFerPer  	:= GetDferAnt(SRF->RF_DATABAS, SRF->RF_DIASDIR, @lFerAberto, SRF->RF_STATUS, @lMesmoMes, dFerOpen, lFirstSRF, @n13Fer)
		lFirstSRF	:= .F.
		If cTpBxFer == "2" .And. nDFerPer > 0 .And. nDFerAnt > 0 .And. !lMesmoMes .And. lFerAberto
			lBx2Per	:= .T.
		EndIf
		If lFerAberto .Or. (lMesmoMes .And. nDFerAnt == 0)
			nDFerAnt += nDFerPer
			lFer2Aux := .T.
			If !lMesmoMes
				dDtBasFer := SRF->RF_DATABAS
				lMudaData := .F.
			Else
				dDtBasFer := fCalcFimAq(SRF->RF_DATABAS) + 1
			EndIf
		EndIf
		If lMesmoMes .And. nDFerAnt > 0 .And. !lFer2Aux
			lFer2PerAq	:= .T.
		EndIf

		If lFerAberto .Or. lMesmoMes
			aAdd(aPerFerAux,{	SRF->RF_DATABAS	,;										  		 			// 01 - Inicio Database de Ferias
								If(Empty(SRF->RF_DATAFIM),fCalcFimAq(SRF->RF_DATABAS),SRF->RF_DATAFIM),;    // 02 - Final Database de Ferias
								SRF->RF_DFERVAT	,;															// 03 - Dias de ferias vencidas
								SRF->RF_DFERAAT	,;															// 04 - Dias de ferias a vencer
								0.00			,;															// 05 - Dias totais de afastamento por periodo
								SRF->RF_OBSERVA	,;															// 06 - Descricao do tipo de afastamento do periodo
								CtoD("")		,;															// 07 - Data de original de termino do p.aquisitivo quando houver prorrogacao do mesmo RWX
								If((Empty(SRF->RF_STATUS) .Or. (!Empty((cTBLXPROV)->PR_DEMISSA) .And. lFechouMes) .Or. lFerAberto ) .and. !lMesmoMes,"1",If(!lFerAberto,'3',SRF->RF_STATUS)),;								// 08 - Status do periodo de ferias:  1-Ativo (Vencidos/A vencer)/2-Prescrito (Perdido)/3-Pago
								CtoD("")		,;															// 09 - Data de Inicio do Proximo periodo caso seja um periodo perdido.
								0				,;															// 10 - Quantidade dias de deducao para o direito apurado no periodo
								SRF->RF_DVENPEN ,;     														// 11 - Dias Vencidos Pendentes
								SRF->RF_IVENPEN ,;     														// 12 - Data Inicia Vencido Pendente
								SRF->RF_FVENPEN ,;															// 13 - Data Inicia Vencido Pendente
								If(lFerAberto, nDFerAnt, SRF->RF_DFERANT) ,;     							// 14 - Dias de Ferias Antecipadas
								SRF->RF_DFALVAT ,;     														// 15 - Dias de Faltas Vencidas
								SRF->RF_DFALAAT ,; 				    										// 16 - Dias de Faltas a Vencer
								If(cPaisLoc$"VEN|EQU",SRF->RF_DBONVAT,NIL),;				 				// 17 - Dias de bono vencido
								If(cPaisLoc$"VEN|EQU",SRF->RF_DBONAAT,NIL),; 								// 18 - Dias de bono a Vencer
								0				,;															// 19 - Total de dias de ferias
								0				,;															// 20 - Total de dias de bonificacao
								0				,;															// 21 - Dias de Faltas vencidas bonificacao
								0				,;															// 22 - Dias de ¶Faltas a Vencer bonificacao
								0				,;															// 23 - Dias de ausencia convertidos em ferias
								0				,;      													// 24 - Total de Dias de Ferias do Periodo
								SRF->RF_DIASANT ,;					      									// 25 - Dias Gozados Vencidos
								SRF->RF_DIASANT	,;	    													// 26 - Dias Gozados a Vencer
								0               ,;      													// 27 - Dias Subsid. Vencidos
								0               ,;   														// 28 - Dias Subsid. a Vencer
								0				,; 															// 29 - Dias de Pagto. Minimo na Adm/Dem (cpo. RF_PAGOFER desabilitado 08/2012)
								SRF->( RECNO() ),;															// 30 - Recno do aquivo
								Iif(lFerPaga,  SRF->RF_FERPAGA, 0) ,;										// 31 - Dias pagos em R$ na folha
								SRF->RF_DATAATU	,;															// 32 - Data de atualizacao
								0                ;                                                          // 33 - Dias de suspens„o do perÌodo
								})

		Else
			Exit
		EndIf
		(cTmpSRF)->(dbSkip())
	EndDo
	(cTmpSRF)->(dbCloseArea())

	SRF->(DbGoTo(nRecnoSRF))

	aPerFerias  := {}

	If Len(aPerFerAux) > 0
		aAdd(aPerFerias,aPerFerAux[1]) //Recalcula apenas do ˙ltimo periodo aquisitivo aberto em diante
		dDtCalcFer := aPerFerias[1][1]
	ElseIf AnoMes((cTBLXPROV)->PR_ADMISSA) == AnoMes(dDataRef) .or. !(Empty((cTBLXPROV)->PR_DEMISSA))//Se for no mes de admissao e n„o tiver dias de direito, forÁa calculo dos dias de direito desde o inicio do periodo aquisitivo.
		dDtCalcFer := dDataAux
	EndIf

	nTDiasAfa := 0
    Calc_Fer(aPerFerias,If(lProvResc .And. ( (cTBLXPROV)->PR_TIPMOVI == _Demitido .Or. ( (cTBLXPROV)->PR_TIPMOVI == _Trfe_Ent .And. !(SRA->RA_RESCRAI $ "30/31") .And. !Empty( (cTBLXPROV)->PR_DEMISSA ) ) ),(cTBLXPROV)->PR_DEMISSA,dDataRef),@nDiasVenc,@nDiasProp,@nTDiasAfa,,lDiasAfAcum,.T.,dDtCalcFer)

	If Len(aPerFerias) == 0 .And. !l13oSal
		Return(.T.)
	EndIf

	If Len(aPerFerAux) > 0
		For nPosAux := 1 to Len(aPerFerias)
			If nPosAux == 1
				aPerFerAux[1] := aClone(aPerFerias[nPosAux])
			Else
				aAdd(aPerFerAux, aPerFerias[nPosAux])
			EndIf
		Next nPosAux
		aPerFerias := aPerFerAux
	EndIf
	aSort(aPerFerias,,,{|x,y| x[1] < y[1]})

	//Verifica se h· periodo Ativo suspenso
	If Len(aPerFerias) > 1 
		For nx := 1 To Len(aPerFerias)
			If aPerFerias[nx,33] > 180 .And. Empty(aPerFerias[nx, 07]) 
				aPerFerias[nx,03] := 0
				aPerFerias[nx,04] := 0
			EndIf
		Next nx
	EndIf

	//Recalcula Dias Vencidos e proporcionais de incluindo os periodos que n„o foram enviados para calc_fer
	If lFerias
		nDiasVenc := 0
		nDiasProp := 0
		Aeval(aPerFerias,{|X| If(X[8] == "1",(nDiasVenc += X[3], nDiasProp += X[4]),nil)})

		//Verifica se o perÌodo aquisitivo em quest„o j· foi quitado, se sim, muda a data base de fÈrias para o prÛximo perÌodo
		nDiasAux  := 0
		nOrdAux   := SRH->( IndexOrd() )
		SRH->( DbSetOrder(1) )
		If nDiasVenc == 0 .And. nDiasProp > 0 .And. nDFerAnt >= nDiasProp .And. SRH->( DbSeek((cTBLXPROV)->PR_FILIAL + (cTBLXPROV)->PR_MAT + DToS(dDtBasFer) ) )
			While !( SRH->( Eof() ) ) .And. (cTBLXPROV)->PR_FILIAL + (cTBLXPROV)->PR_MAT + DToS(dDtBasFer) == SRH->RH_FILIAL + SRH->RH_MAT + DToS(SRH->RH_DATABAS)
				If AnoMes(dDataRef) >= SRH->RH_PERIODO
					nDiasAux += SRH->RH_DFERIAS + SRH->RH_DABONPE + SRH->RH_DFALTAS
					If dDtBasFer == dDtCalcFer .And. (!lBx2Per .Or. lBx2Per .And. SRH->RH_DFERIAS + SRH->RH_DABONPE > aTabFer[3])
						nDiasProp := 0
						lCabec    := .T.
					EndIf
				EndIf
				SRH->( DbSkip() )
			EndDo
			If nDiasAux >= nDiasProp
				SRH->( DbSkip(-1) )
				If nDiasAux == aTabFer[3] .and. SRH->RH_DFERIAS + SRH->RH_DABONPE == SRH->RH_DFERVEN
					dDtBasFer := SRH->RH_DBASEAT + 1
				EndIf
			EndIf
		ElseIF !lFerAberto .And. !lMesmoMes .And. nDiasVenc == 0 .And. nDiasProp > 0 .And. dDtBasFer == (cTBLXPROV)->PR_ADMISSA .And. Len(aPerFerias) > 1
			nPos := Ascan(aPerFerias,{|x| x[8] == "1" })
			If nPos > 0
				dDtBasFer := aPerFerias[nPos,1]
			EndIf
		EndIf
		SRH->( DbSetOrder(nOrdAux) )

		For nX := 1 To Len(aPerFerias)
			If dDataRef >= aPerferias[nX][1]
				//Verificar as ausÍncias no perÌodo
				fRetAfas(CTOD("01/01/"+Str(Year(dDataRef),4), "DDMMYY"),dDataRef,"PRFE",@nAvosAf,@nDiasAf,,@aAfast,,.F.)
				If Len(aAfast) > 0
					nAfastAux := 0
					For nA := 1 To Len(aAfast)
						If nAvosAf == 0
							dIniAfa := ctod("  / /  ")
						Else
							dIniAfa := aAfast[nA,3]
						EndIf
						If aAfast[nA, 9] == "3"
							nAfastAux += aAfast[nA, 2] 
						EndIf
						If ! ( nA > 1 .And. ( aAfast[nA,3] - aAfast[nA-1,4] == 1) )
							If (Empty(aAfast[nA,4]) .Or. aAfast[nA,4] >= CTOD("01/"+Str(Month(dDataRef),2)+"/"+Str(Year(dDataRef),4), "DDMMYY"))
								cCongFeR := If(aAfast[nA, 9] <> "3" .Or. Empty(aAfast[nA, 4]), aAfast[nA, 9], If(nAfastAux > 180, aAfast[nA, 9], cCongFeR))  
								cCong13  := aAfast[nA,10]
							EndIf
						EndIf
					Next nA	
				Endif
			Endif
		Next nX
	EndIf
Endif

dDtBasCal := dDtBasFer //Atualiza database de fÈrias para c·lculo de adicionais sobre mÈdias

SRF->(dbSetOrder(1))

dbSelectArea(cTBLXPROV)

// VERIFICA O TIPO DE MOVIMENTACAO DO FUNCIONARIO
nTipoMovMes := (cTBLXPROV)->PR_TIPMOVI
lTransfSai  := (nTipoMovMes == _Trfe_Sai)
lDemitido   := (nTipoMovMes == _Demitido) .Or. ( nTipoMovMes == _Trfe_Ent .And. !(SRA->RA_RESCRAI $ "30/31") .And. !Empty( (cTBLXPROV)->PR_DEMISSA ) .And. AnoMes(dDataRef) == AnoMes((cTBLXPROV)->PR_DEMISSA) )

// 1o ELEMENTO DO ARRAY - A N T E R I O R
fQryDetSRT(aVerba,aTransf,dDataRef,lTrataTrf,.F.,lFerias,l13oSal,,lPLRPE)

// 2o ELEMENTO DO ARRAY - C O R R E C A O
If nCorrecao > 0
	If lFerias
		fGrvArrPrv(aFerVenc, _Corre, _Anter, nCorrecao, { _Dias })
		fGrvArrPrv(aFerProp, _Corre, _Anter, nCorrecao, { _Dias })
	EndIf
	If l13oSal .And. (!(cTBLXPROV)->PR_CATFUNC $ "E|G" .Or. P_LPROVEST)
		fGrvArrPrv(a13Salar, _Corre, _Anter, nCorrecao, { _Avos,_1Par })
		If n14Salario > 0
			fGrvArrPrv(a14Salar, _Corre, _Anter, nCorrecao, { _Avos,_1Par })
		EndIf
	Endif

Endif

// ZERA VARIAVEIS PARA UMA NOVA BUSCA DE SALARIO E FERIAS
    nV_DFalFer := nP_DFalFer := nTFaltaV := nTFaltaP := 0
    nSalario   := nSalMes    := nSalDia  := nSalHora := 0
    nAdtServ   := nPeric     := nInsal 	 := nAdcConf := nAdcTransf   := 0.00
	nOutros    := nSalhInc	 := nSalInc  := 0.00
// SE MES ESTIVER FECHADO, CALCULAR COM VALORES DO SRT

If lFechouMes .And. fBusCabSRT(dDataRef,@aCabProv)
	dDtBasFer  := aCabProv[_DBsProv]
    nSalario   := aCabProv[_SalProv]
    nSalMes    := aCabProv[_SalProv]
    nSalDia    := aCabProv[_SalProv] / 30
    nSalHora   := aCabProv[_SalProv] / (cTBLXPROV)->PR_HRSMES
    lTemCab	:= .T.
EndIf

// 6o ELEMENTO DO ARRAY - B A I X A  D E  F E R I A S / PLR   ≥
If (!lDemitido .Or. lProvResc) .And. !lTransfSai
	If lFerias
		fBxaFerProv(@dDtBasFer, @nDFerAnt, lFerAberto, lBx2Per, lFer2PerAq, P_MP1046QUI)
	EndIf
	If l13oSal .And. lBx13Pgt .And. (Month(dDataRef) == 12) .And. (!(cTBLXPROV)->PR_CATFUNC $ "E|G" .Or. P_LPROVEST)
		fBxa13oProv()
	EndIf
	If lPLRPE .And. lBxPlrPgt
		fBxaPlrProv()
	EndIf
EndIf

// 4o ELEMENTO DO ARRAY - A T U A L
If lTransfSai .and. lCalcSalInc
	If nSalMes == 0
		// CALCULA SALARIO MES , DIA , HORA DO FUNCIONARIO
		fSalario(@nSalario,@nSalHora,@nSalDia,@nSalMes,"A",MesAno(dDataRef))
	EndIf
Else
	// CALCULA SALARIO INCORPORADO MES , DIA , HORA DO FUNCIONARIO
	If !lCalcSalInc .And. SRA->RA_CATFUNC <> "H"
		cAliasPROC	:= "QPROC"
		fQrySRD((cTBLXPROV)->PR_FILIAL , (cTBLXPROV)->PR_MAT , MesAno(dDataRef))
		//BUSCA O SALARIO MES, ADIC.TPO.SERVICO, INSALUBRIDADE E PERICULOSIDADE
		cPdsAts		:= aCodFol[1297,1] + "|" + aCodFol[1299,1] + "|" + aCodFol[1296,1] + "|" + aCodFol[1298,1]
		cPdsPer		:= aCodFol[1301,1] + "|" + aCodFol[1303,1] + "|" + aCodFol[1300,1] + "|" + aCodFol[1302,1] + "|" + aCodFol[1281,1]
		cPdsIns		:= aCodFol[1304,1] + "|" + aCodFol[1320,1] + "|" + aCodFol[1305,1] + "|" + aCodFol[1307,1] + "|" + aCodFol[1282,1]
		cPdsAdC		:= aCodFol[1308,1] + "|" + aCodFol[1309,1]
		cPdsAdT		:= aCodFol[1310,1] + "|" + aCodFol[1311,1]
		cPdsPeNInc 	:= aCodFol[1302,1] + "|" + aCodFol[1303,1]

		//BUSCA C”DIGOS DE COMISS√O E COMISS√O RESCIS√O.
		cPdsComis := aCodFol[165,1] + "|" + aCodFol[166,1] + "|" + aCodFol[121,1]

		cFolAts		:= aCodFol[001,1] + "|" + aCodFol[002,1] + "|" + aCodFol[003,1] + "|" + aCodFol[004,1] + "|" + aCodFol[005,1]+ "|" + aCodFol[1283,1] + "|" + aCodFol[1284,1] + "|" + aCodFol[1285,1] + "|" + aCodFol[1286,1] + "|" + aCodFol[1287,1] + "|" + aCodFol[1340,1]
		cFolPer		:= aCodFol[36,1]
		cFolIns		:= aCodFol[37,1] + "|" + aCodFol[38,1] + "|" + aCodFol[39,1]
		cFolAdC		:= aCodFol[984,1]
		cFolAdT		:= aCodFol[988,1]

		cCodAdFol	:= aCodFol[318,1]+ "|" + cFolAts + "|" + cFolPer + "|" + cFolIns + "|" + cFolAdC + "|" + cFolAdT
		If Len(aCodFol) >= 1721 .And. !Empty(aCodFol[1680,1])
			cPdResc := aCodFol[1680,1] + "|" + aCodFol[1681,1] + "|" + aCodFol[1682,1] + "|" + aCodFol[1684,1] + "|" + aCodFol[1685,1] + "|" + aCodFol[1686,1];
					+ "|" + aCodFol[1687,1] + "|" + aCodFol[1688,1] + "|" + aCodFol[1690,1] + "|" + aCodFol[1691,1] + "|" + aCodFol[1692,1] + "|" + aCodFol[1693,1];
					+ "|" + aCodFol[1694,1] + "|" + aCodFol[1696,1] + "|" + aCodFol[1697,1] + "|" + aCodFol[1698,1] + "|" + aCodFol[1699,1] + "|" + aCodFol[1700,1];
					+ "|" + aCodFol[1702,1] + "|" + aCodFol[1703,1] + "|" + aCodFol[1704,1] + "|" + aCodFol[1705,1] + "|" + aCodFol[1706,1] + "|" + aCodFol[1708,1];
					+ "|" + aCodFol[1709,1] + "|" + aCodFol[1710,1] + "|" + aCodFol[1711,1] + "|" + aCodFol[1712,1] + "|" + aCodFol[1714,1] + "|" + aCodFol[1715,1];
					+ "|" + aCodFol[1716,1] + "|" + aCodFol[1717,1] + "|" + aCodFol[1718,1] + "|" + aCodFol[1719,1] + "|" + aCodFol[1720,1] + "|" + aCodFol[1721,1]
		EndIf
		cPdAdic := cCodAdFol + "|" +  cPdsAts + "|" + cPdsPer + "|" + cPdsIns + "|" + cPdsAdC + "|" + cPdsAdT  + "|" + cPdResc

		nSubATS 	:= 0
		lFolAtsInc 	:= .F.
		lPerInc		:= .F.

		While !(cAliasPROC)->(eof())
			If lFechouMes
				cCodPd := (cAliasPROC)->RD_PD
				nValor := (cAliasPROC)->RD_VALOR
				cFilPD := (cAliasPROC)->RD_FILIAL
			Else
				cCodPd := (cAliasPROC)->RC_PD
				nValor := (cAliasPROC)->RC_VALOR
				cFilPD := (cAliasPROC)->RC_FILIAL
			EndIf

			If cCodPd $ cFolAts .And. RetValSrv(cCodPd,cFilPD,"RV_INCORP") == "S"
				lFolAtsInc := .T.
			EndIf
			If !lTemCab .And. cCodPd == aCodFol[318,1]
				nSalMes 	+= nValor
				nSalhInc 	+= nValor
				nSalInc 	+= nValor
			ElseIf cCodPd == aCodFol[671,1]
				nAdtServ += nValor
			ElseIf cCodPd == aCodFol[672,1]
				nInsal += nValor
			ElseIf cCodPd == aCodFol[673,1]
				nPeric += nValor
			ElseIf lBaseConf .And. cCodPd == aCodFol[1421,1]
				nAdcConf += nValor
			ElseIf lBaseConf .And. cCodPd == aCodFol[1422,1]
				nAdcTransf += nValor
			ElseIf !lTemCab .And. cCodPd $ cPdAdic
				If !(cCodPd $ cPdsPeNInc) .And. RetValSrv(cCodPd,(cTBLXPROV)->PR_FILIAL,"RV_INCORP") == "S"
					If cCodPd == aCodFol[36,1] .And. SRA->RA_SITFOLH == "D" .And. AnoMes(dDataRef) == AnoMes(SRA->RA_DEMISSA) .And. P_ADCINTEG # "1"
						lPerInc := .T.
					Else
						nSalMes -= nValor
						If cCodPd == aCodFol[36,1]
							nValPer := nValor
						EndIf
					Endif
				ElseIf (cCodPd $ cPdsAts)
					nSubATS += nValor
				EndIf
			ElseIf !lTemCab .And. cCodPd $ cPdsComis
				If RetValSrv(cCodPd,(cTBLXPROV)->PR_FILIAL,"RV_INCORP") == "S"
					nSalMes -= nValor
					If (RetValSrv( cCodPd,(cTBLXPROV)->PR_FILIAL,"RV_MEDFER") $ "N  ")
						nOutros += nValor
					EndIf
					lZerouSal := .T.
				EndIF
			ElseIf !lTemCab // Outras verbas com S para incorpora.
				If RetValSrv(cCodPd,(cTBLXPROV)->PR_FILIAL,"RV_INCORP") == "S"
					nSalMes -= nValor
					nOutros += nValor
				EndIf
			Endif

			(cAliasPROC)->(dbskip())
		Enddo
		(cAliasPROC)->(dbCloseArea())

		If lPerInc
			nSalMes -= nPeric
		Endif

		If nValPer > 0 .And. nPeric > nValPer 
			nSalmes -= nPeric - nValPer
		EndIf

		If lFolAtsInc
			nSalMes -= nSubATS
		EndIf

		If !lTemCab
			nSalario:= nSalMes
			nSalDia	:= nSalMes / 30
			nSalHora:= nSalMes / (cTBLXPROV)->PR_HRSMES
			nSalhInc := nSalhInc / (cTBLXPROV)->PR_HRSMES
		Endif
		//-- CARREGA OS CODIGOS DOS ADICIONAIS DE TEMPO DE SERVICO QUE SERAO UTILIZADOS
		//-- NOS CALCULOS DE PROVISOES DE FERIAS E 13o SALARIO.
		fCarAdics()
	Endif

	If !lTransfSai

		If lCalcSalInc .And. ( (SRA->RA_ADCINS $ "2|3|4" .And. Empty(cCodIns)) .Or. (SRA->RA_ADTPOSE # '***N**' .And. Empty(cCodAdt)) )
			fCarAdics()
		EndIf

		If (!lZerouSal .And. nSalMes == 0) .Or. !lTemCab
			If lCalcSalInc .Or. (nSalMes == 0 .And. !lZerouSal)
				fSalInc(@nSalario,@nSalMes,@nSalHora,@nSalDia,.T.,,,,dDataRef,,@nPeric,@nInsal,@nAdtServ,@nAdcConf,@nAdcTransf,@nOutros,@nSalhInc,,,,,@aAdicProv)
				nSalDia := nSalMes / 30
			Endif
			//UTILIZA O SAL.INCORP. DO CADASTRO
			If lSalInc .And. (cTBLXPROV)->PR_SALINCO > 0
				nSalMes  := (cTBLXPROV)->PR_SALINCO
				nSalDia  := (cTBLXPROV)->PR_SALINCO / 30
				nSalHora := (cTBLXPROV)->PR_SALINCO / (cTBLXPROV)->PR_HRSMES
			Endif
		Else
			// CHAMA FUNCAO PARA CARREGAR ADICIONAIS - ADTSERV/PERIC/INSAL
			If lCalcSalInc .Or. (SRA->RA_CATFUNC == "H" .And. lFechouMes)
				fSalInc(,,,,.T.,,,,dDataRef,,@nPeric,@nInsal,@nAdtServ,@nAdcConf,@nAdcTransf,@nOutros,@nSalhInc,,,,,@aAdicProv)
			EndIf
		EndIf

		If Len(aAdicProv) > 0
			aEval(aAdicProv, {|x| If(x[1] == "1" .and. x[2] > 0, nATSFerV := x[2], If(x[1] == "2" .and. x[2] > 0, nATSFerP := x[2], If(x[1] == "3" .and. x[2] > 0 , nATS13Sal := x[2],Nil)))})
		EndIf

		If lProvResc .And. lDemitido
			//VERIFICA DEMISSAO E SEXTA FEIRA OU SABADO E CONS. PARAMETRO PARA PAGAR SABADO E DOMINGO
			dDataDem1	:= (cTBLXPROV)->PR_DEMISSA
			dDataDem1	:= fDtSabDom()
		EndIf

		// CARREGANDO ARQUIVO TRP COM MONTA MEDIA
		If (!lDemitido .Or. lProvResc)
			dbSelectArea(cTBLXMED)
			Zap
			dRefMed		:= If(lProvResc .And. lDemitido,dDataDem1,dDataRef)
			nBkpDiasC	:= nDiasC
			GpexMed(dDtBasFer,,dRefMed,,dRefMed,nSalHora,nSalMin,aCodFol,.T.,!lFechouMes,,,,,,,nSalhInc,!lFechou13)
			nDiasC 		:= nBkpDiasC
			//grava historico de mÈdias
			fHistMed(dDataRef,,anomes(dDataRef),"01","PRV",{nSalInc,nSalDia,nSalHora,nPeric,nInsal,nAdcConf,nAdcTransf,nAdtServ,nSalario})
		Endif

		dbSelectArea(cTBLXPROV)
		// CALCULA FERIAS VENCIDAS E PROPORCIONAIS
		If lFerias
			fProvFer(cCongFeR, @nTipoMovMes, @dDtBasFer, lCodMPA, P_DINIADI, P_DFIMADI, P_MP1046QUI)
		EndIf

		// CALCULA O 13o SALARIO
		If l13oSal .And. (!lDemitido .Or. lProvResc)  .And. (!(cTBLXPROV)->PR_CATFUNC $ "E|G" .Or. P_LPROVEST)
			fProv13o(cCong13, @nTipoMovMes, n13Fer)
		EndIf

		If lPLRPE
			nValPLR 	:= 0
			aPLR	:=	ExecBLock('GP070PLR',.F.,.F.,{(cTBLXPROV)->PR_FILIAL,(cTBLXPROV)->PR_MAT,aPLRSalar[_Anter,_Prov],dDataRef})
			If ValType(aPLR) == "A" .And. !Empty(aPLR)
				If ValType(aPLR[1]) == "N"
					nValPLR 	:= aPLR[1]
					If (!lDemitido .Or. lProvResc)
						aPLRSalar[_Atual,_Prov] := nValPLR - aPLRSalar[_BxPLR,_Prov] + aPLRSalar[_Anter,_Prov]
					EndIf
					If (strzero(Month(dDataRef),2) $ _cFechaPLR)
						If _lVlrBaixa
							//n„o considera valor provisionado no mÍs para o saldo a ser baixado
							aPLRSalar[_Atual,_Prov] := nValPLR
							aPLRSalar[_BxPLR,_Prov] := aPLRSalar[_Anter,_Prov]
						Else
							aPLRSalar[_Atual,_Prov] := 0
							aPLRSalar[_BxPLR,_Prov] := (aPLRSalar[_Anter,_Prov] + nValPLR )
						EndIf
					EndIf
					If  aPLRSalar[_Atual,_Prov]  < 0
						aPLRSalar[_Atual,_Prov] := 0
					EndIf
				EndIf
			EndIf
		EndIf
	EndIf
EndIf

fChkAfaMat(@nDiasMat)

// 6o ELEMENTO DO ARRAY - B A I X A  D E  1 3 o   ≥
If (!lDemitido .Or. lProvResc) .And. !lTransfSai	//?-
	If l13oSal .And. lBx13Pgt .And. (Month(dDataRef) == 12) .And. (!(cTBLXPROV)->PR_CATFUNC $ "E|G" .Or. P_LPROVEST)
		If nDiasMat > 0 //Se houver dias de maternidade, recalcula baixa
			fBxa13oProv(nDiasMat)
		EndIf
	EndIf
EndIf

// 5o ELEMENTO DO ARRAY - B A I X A  T R A N S F E R E N C I A	 |
// 7o ELEMENTO DO ARRAY - B A I X A  R E S C I S A O			 |
If lTransfSai .Or. lDemitido
	If lDemitido .and. AnoMes(dDataRef) == AnoMes(SRA->RA_DEMISSA)
		GetDferRes( SRF->( Recno()) , @lDemMes ) //Posiciona na rescis„o
	EndIf
	fIncRes(SRA->RA_FILIAL,SRG->RG_TIPORES,aIncRes)
	If lFerias
		If lTransfSai
			fGrvArrPrv(@aFerVenc, _BxTrf, _Anter, 1, {})
			fGrvArrPrv(@aFerProp, _BxTrf, _Anter, 1, {})
		Else			
			If !lDemitido .or. !lDemMes .or. Empty(aIncRes) .or. aIncRes[20] <> 'N' //Apenas efetua a baixa se houve pagamento de fÈrias na rescis„o ou se demiss„o n„o foi calculada neste perÌodo
				If !lDemitido .Or. !lDemMes .Or. !( AnoMes(dDataRef) == AnoMes(SRA->RA_DEMISSA) .And. SRG->RG_DFERVEN == 0 ) .Or. (lBxFerAnt := lDemitido .And. lProvResc .And. aFerVenc[_Anter, _Prov] > 0 .And. aFerVenc[ _BxFer, _Prov ] == 0)
					fGrvArrPrv(@aFerVenc, _BxRes, If(lProvResc .And. (aFerVenc[_Atual][_Prov] > 0 .Or. !lBxFerAnt), _Atual, _Anter), 1, {})
				EndIf
			EndIf
			If !lDemitido .or. !lDemMes .or. Empty(aIncRes) .or. aIncRes[4] <> 'N' //Apenas efetua a baixa se houver pagamento de fÈrias na rescis„o ou se demiss„o n„o foi calculada neste perÌodo
				If !lDemitido .Or. !lDemMes .Or. !( AnoMes(dDataRef) == AnoMes(SRA->RA_DEMISSA) .And. SRG->RG_DFERVEN == 0 .And. SRG->RG_DFERPRO == 0 ) .Or. (lDemitido .And. lProvResc .And. lProvavp .And. SRG->RG_DFERAVI > 0)
					fGrvArrPrv(@aFerProp, _BxRes, If(lProvResc,_Atual,_Anter), 1, {})
				EndIf
			EndIf
			dbSelectArea("SRH")
			dbSetOrder(1)
			If dbSeek(xFilial("SRH") + SRA->RA_MAT)
				While ! Eof() .And. xFilial("SRH") + SRA->RA_MAT == SRH->RH_FILIAL+SRH->RH_MAT
					If SRH->RH_DATAINI <= SRA->RA_DEMISSA .and. SRH->RH_DATAFIM >= SRA->RA_DEMISSA
						lDemfer := .T.
					EndIf
					//Se houve pagamento de fÈrias no mesmo mÍs da rescis„o, lProvResc esta desativado e existe provis„o de fÈrias vencidas. Efetua a baixa.
					If !lProvResc .and. lDemMes .And. AnoMes(SRH->RH_DATAINI) == AnoMes(SRA->RA_DEMISSA) .And. aFerVenc[_Anter][_Prov] > 0
						lFerMesResc := .T.
					EndIf
					SRH->(Dbskip())
				EndDo
			EndIf
			If lFerMesResc
				fGrvArrPrv(@aFerVenc, _BxRes, _Anter, 1, {})
			EndIf
			If !lProvResc .and. lDemMes .and. lDemfer .and. SRG->RG_DFERPRO == 0 .and. SRG->RG_DFERVEN == 0 .and. aIncRes[4] == "S" //Efetua baixa das fÈrias no caso de rescisao no meio das ferias
				fGrvArrPrv(@aFerProp, _BxRes, If(lProvResc,_Atual,_Anter), 1, {})
			EndIf
		EndIf
	EndIf
	If l13oSal .And. (!(cTBLXPROV)->PR_CATFUNC $ "E|G" .Or. P_LPROVEST)
		If lTransfSai
			fGrvArrPrv(@a13Salar, _BxTrf, _Anter, 1, {})
			fGrvArrPrv(@a14Salar, _BxTrf, _Anter, 1, {})
		Else
			If !lDemMes .or. Empty(aIncRes) .or. aIncRes[3] <> 'N' //Apenas efetua a baixa se houver pagamento de 13∫ na rescis„o ou se demiss„o n„o foi calculada neste perÌodo
				fGrvArrPrv(@a13Salar, _BxRes, If(lProvResc,_Atual,_Anter), 1, {})
				fGrvArrPrv(@a14Salar, _BxRes, If(lProvResc,_Atual,_Anter), 1, {})
			EndIf
		EndIf
	EndIf
	If lPLRPE
		If lTransfSai
			fGrvArrPrv(@aPLRSalar, _BxTrf, _Anter, 1, {} )
		Else
			fGrvArrPrv(@aPLRSalar, _BxRes, If(lProvResc,_Atual,_Anter), 1, {} )
		EndIf
	EndIf
EndIf

Begin Transaction

	// ATUALIZA O ARQUIVO DE CABECALHO - SRF
	If (!lDemitido .Or. lProvResc) .And. !lTransfSai
		If lFerias
			nDiasFv := aFerVenc[_Atual,_Dias] + nV_DFalFer
			nDiasFv += If(aFerVenc[_Atual,_Dias] > 0, nDFerAnt, 0)
			nDiasFv -= SRF->RF_DVENPEN
			If nDiasFv = 0 .And. nDFerAnt > 0
				nDiasFv := nDFerAnt * (-1)
			Endif
			aFerVenc[_Atual,_Dias] := If (nDiasFv < 0 .Or. lTrfSld, 0 , nDiasFv) + SRF->RF_DVENPEN
		EndIf
	EndIf

	// PARA O NOVO CALCULO DE RATEIO, CHAMA NOVAMENTE A FUNCAO QUE APURA OS VALORES MENSAIS PARA POSTERIOR GERACAO NA TAB. SRT
	If lGeraPMes
		//⁄ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒø
		//≥Atualiza o lMudouRat para .F. para que, ao voltar no loop      ≥
		//≥O novo funcion·rio seja rateado tambÈm                         ≥
		//¿ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒŸ
		lMudouRat := .F.
		fGeraBaixaMes(2, @lMudouRat, @aRecBxa)
		fQryDetSRT(aVerba,aTransf,dDataRef,lTrataTrf,.T.,lFerias,l13oSal,.T.,lPLRPE,lMudouRat)
		If lTransfSai .Or. lDemitido
			If lDemitido .and. AnoMes(dDataRef) == AnoMes(SRA->RA_DEMISSA)
				GetDferRes( SRF->( Recno()) , @lDemMes ) //Posiciona na rescis„o
			EndIf
			fIncRes(SRA->RA_FILIAL,SRG->RG_TIPORES,aIncRes)
			If lFerias
				If lTransfSai
					fGrvArrPrv(@aFerVenc, _BxTrf, _Anter, 1, {})
					fGrvArrPrv(@aFerProp, _BxTrf, _Anter, 1, {})
				Else
					If !lDemitido .or. !lDemMes .or. Empty(aIncRes) .or. aIncRes[20] <> 'N' //Apenas efetua a baixa se houve pagamento de fÈrias na rescis„o ou se demiss„o n„o foi calculada neste perÌodo
						If !lDemitido .Or. !lDemMes .Or. !( AnoMes(dDataRef) == AnoMes(SRA->RA_DEMISSA) .And. SRG->RG_DFERVEN == 0 ) .Or. (lBxFerAnt := lDemitido .And. lProvResc .And. aFerVenc[_Anter, _Prov] > 0 .And. aFerVenc[ _BxFer, _Prov ] == 0)
							fGrvArrPrv(@aFerVenc, _BxRes, If(lProvResc .And. (aFerVenc[_Atual][_Prov] > 0 .Or. !lBxFerAnt), _Atual, _Anter), 1, {})
						EndIf
					EndIf
					If !lDemitido .or. !lDemMes .or. Empty(aIncRes) .or. aIncRes[4] <> 'N' //Apenas efetua a baixa se houver pagamento de fÈrias na rescis„o ou se demiss„o n„o foi calculada neste perÌodo
						If !lDemitido .or. !lDemMes  .or. !( AnoMes(dDataRef) == AnoMes(SRA->RA_DEMISSA) .and. SRG->RG_DFERVEN == 0 .and. SRG->RG_DFERPRO == 0 )
							fGrvArrPrv(@aFerProp, _BxRes, If(lProvResc,_Atual,_Anter), 1, {})
						EndIf
					EndIf				
				EndIf
			EndIf
			If l13oSal .And. (!(cTBLXPROV)->PR_CATFUNC $ "E|G" .Or. P_LPROVEST)
				If lTransfSai
					fGrvArrPrv(@a13Salar, _BxTrf, _Anter, 1, {})
					fGrvArrPrv(@a14Salar, _BxTrf, _Anter, 1, {})
				Else
					If !lDemMes .or. Empty(aIncRes) .or. aIncRes[3] <> 'N' //Apenas efetua a baixa se houver pagamento de 13∫ na rescis„o ou se demiss„o n„o foi calculada neste perÌodo
						fGrvArrPrv(@a13Salar, _BxRes, If(lProvResc,_Atual,_Anter), 1, {})
						fGrvArrPrv(@a14Salar, _BxRes, If(lProvResc,_Atual,_Anter), 1, {})
					EndIf
				EndIf
			EndIf
			If lPLRPE
				If lTransfSai
					fGrvArrPrv(@aPLRSalar, _BxTrf, _Anter, 1, {} )
				Else
					fGrvArrPrv(@aPLRSalar, _BxRes, If(lProvResc,_Atual,_Anter), 1, {} )
				EndIf
			EndIf
		EndIf
	Endif

	// GRAVA AS FERIAS VENCIDAS E PROPORCINAIS NO ARQUIVO DETALHE
	If lFerias
		If !(cTBLXPROV)->PR_CATFUNC $ "E|G"
			fGeraSRT(@aFerVenc,aRecVenc,aVerba,dDataRef,nTipoMovMes,nSalMes,dDtBasFer,nDFerAnt,_FerVenc)
			fGeraSRT(@aFerProp,aRecProp,aVerba,dDataRef,nTipoMovMes,nSalMes,dDtBasFer,nDFerAnt,_FerProp,lCabec)
		Else
			fGeraSRT(@aFerVenc,aRecVenc,aVerba,dDataRef,nTipoMovMes,nSalMes,dDtBasFer,nDFerAnt,_RecVenc)
			fGeraSRT(@aFerProp,aRecProp,aVerba,dDataRef,nTipoMovMes,nSalMes,dDtBasFer,nDFerAnt,_RecProp,lCabec)
		Endif
	EndIf

	// GRAVA O 13o E 14o SALARIO NO ARQUIVO DETALHE
	If l13oSal .And. (!(cTBLXPROV)->PR_CATFUNC $ "E|G" .Or. P_LPROVEST)
		fGeraSRT(@a13Salar,aRec13Sl,aVerba,dDataRef,nTipoMovMes,nSalMes,dDtBasFer,nDFerAnt,_13Salar)
		fGeraSRT(@a14Salar,aRec14Sl,aVerba,dDataRef,nTipoMovMes,nSalMes,dDtBasFer,nDFerAnt,_14Salar)
	EndIf

	If lPLRPE
		fGeraSRT(@aPLRSalar,aRecPLRSl,aVerba,dDataRef,nTipoMovMes,nSalMes,dDtBasFer,nDFerAnt,_PLRSalar)
	Endif

   	//Se for transferÍncia de saÌda, n„o h· valores mensais a serem gravados
   	If lGeraPMes .And. !lTransfSai
		fGeraMes( aRecBxa )
	Endif

	// SE FOR RECALCULO, DELETAR O REGISTRO DE "OK", INDICANDO QUE DEVERA SER GERADO UM NOVO SRZ NO MOMENTO DA CONTABILIZACAO
	fDelRegSRZ(3,"1",dDataRef)

End Transaction

dbSelectArea(cTBLXPROV)
// FINALIZA A GRAVACAO DOS LANCAMENTOS DO SIGAPCO
PcoFinLan("000091")

Return(.T.)

/*
‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±…ÕÕÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÀÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÀÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÕÕÕª±±
±±∫Programa  ≥IniVarGrd ∫Autor  ≥Jonatas A. T. Alves ∫ Data ≥  27/08/08   ∫±±
±±ÃÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕ ÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ ÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕÕÕÕπ±±
±±∫Desc.     ≥Funcao para inicializar variaveis Private da provisao.      ∫±±
±±ÃÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕπ±±
±±∫Uso       ≥ Gpem070                                                    ∫±±
±±»ÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕº±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂ*/
STATIC Function IniVarGrd()
aFerVenc     := Array(_Linhas,_Colunas)
aFerProp     := Array(_Linhas,_Colunas)
aRecVenc     := Array(_Linhas,_Colunas)
aRecProp     := Array(_Linhas,_Colunas)
nV_DFalFer   := 0
nP_DFalFer   := 0
nTFaltaV   	 := 0
nTFaltaP	 := 0
nDFerAnt     := 0
dDtBasFer    := CTOD("")
// VARIAVEIS PRIVATE - PROVISAO DE 13o SALARIO
a13Salar     := Array(_Linhas,_Colunas)
a14Salar     := Array(_Linhas,_Colunas)
aRec13Sl     := Array(_Linhas,_Colunas)
aRec14Sl     := Array(_Linhas,_Colunas)
// VARIAVEIS PRIVATE - PROVISAO DE FERIAS E 13o SALARIO
nSalario	 := nSalMes  := nSalDia     := nSalHora  := 0
nPercEmp	 := nPercTer := nPercAcTrab := nPercFgts := 0
nPerEmp13	 := nAvosAnt := nPercAnt    := 0
lDemitido    := .F.
lDesAtiv     := .F.
lTransfSai   := .F.
c__Roteiro   := "   "
// VARIAVEIS PARA FUNCAO FSALINC
aRoteiro 	:= {}
nAdtServ 	:= nPeric	:= nInsal :=  nAdcConf := nAdcTransf := 0.00	  // Valores dos Adicionais
nOutros 	:= 0.00	  // Valores de outras verbas que incorporam
cCodAdt  	:= cCodIns  := Space(3) 		  // Codigos que Foram Gerados
nSalMin  	:= 0

// AO PASSAR PELA fSalInc() O aPd DEVE SER ZERADO
aPd := {}

SALHOR := 0

Return

/*
‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±…ÕÕÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÀÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÀÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÕÕÕª±±
±±∫Programa  ≥fGeraBaixaMes() ∫Autor  ≥Christiane Vieira ∫ Data ≥ 04/09/12∫±±
±±ÃÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕ ÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ ÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕÕÕÕπ±±
±±∫Desc.     ≥ GravaÁ„o das baixas no arquivo de provis„o mensal - RHT    ∫±±
±±ÃÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕπ±±
±±∫Uso       ≥ Gpem070                                                    ∫±±
±±»ÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕº±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂ*/
Static Function fGeraBaixaMes( nOpcao, lMudouRat, aRecBxa )

Local aArea		:= GetArea()
Local aProvisao	:= {}
Local aBxaAnt	:= {}
Local aBxaAux	:= {}
Local aBxaTot	:= {}
Local aCCAnt	:= {}
Local aCCAtu 	:= {}
Local cAliasRHT	:= ""
Local cDtIniAnt	:= ""
Local cDtIniAtu	:= ""
Local cDtFimAnt	:= ""
Local cDtFimAtu	:= ""
Local cCodVerba	:= ""
Local nC		:= 0
Local nTpProv	:= 0
Local nQtd		:= Len(aRateio)
Local nQtdCCAnt := 0
Local nPerc		:= 0
Local nValDiv 	:= 0
Local nVlComp	:= 0
Local nValor  	:= 0
Local nAnter  	:= 0
Local nCont  	:= 0
Local nPosVerba	:= 0
Local nProvBus 	:= 0
Local dBkpRef	:= cToD("//")
Local cCodBx := "'"+aCodFol[233,1]+"','"+aCodFol[258,1]+"','"+aCodFol[259,1]+"','"+aCodFol[234,1]+"','";
+aCodFol[235,1]+"','"+aCodFol[418,1]+"','"+aCodFol[239,1]+"','"+aCodFol[260,1]+"','"+aCodFol[261,1]+"','";
+aCodFol[240,1]+"','"+aCodFol[241,1]+"','"+aCodFol[419,1]+"','"+aCodFol[262,1]+"','"+aCodFol[263,1]+"','";
+aCodFol[264,1]+"','"+aCodFol[265,1]+"','"+aCodFol[266,1]+"','"+aCodFol[420,1]+"','"+aCodFol[1402,1]+"','";
+aCodFol[1403,1]+"','"+aCodFol[1404,1]+"','"+aCodFol[332,1]+"','"+aCodFol[333,1]+"','"+aCodFol[334,1]+"','";
+aCodFol[335,1]+"','"+aCodFol[336,1]+"','"+aCodFol[423,1]+"','"+aCodFol[270,1]+"','"+aCodFol[271,1]+"','";
+aCodFol[272,1]+"','"+aCodFol[273,1]+"','"+aCodFol[424,1]+"','"+aCodFol[274,1]+"','"+aCodFol[275,1]+"','";
+aCodFol[276,1]+"','"+aCodFol[277,1]+"','"+aCodFol[425,1]+"','"+aCodFol[280,1]+"','"+aCodFol[281,1]+"','";
+aCodFol[282,1]+"','"+aCodFol[283,1]+"','"+aCodFol[428,1]+"','"+aCodFol[284,1]+"','"+aCodFol[285,1]+"','";
+aCodFol[286,1]+"','"+aCodFol[287,1]+"','"+aCodFol[429,1]+"'"
Local lSRVExcl	:= !( Empty( xFilial("SRV") ) )

Static __oSt1
Static __cEmpAux
Static __cFilAux

DEFAULT nOpcao 		:= 1
DEFAULT lItemClVl   := GetMvRH("MV_ITMCLVL", .F., "2") $ "13"

DbSelectArea("RHT")
DbSetOrder(1)

If nOpcao == 1
	nQtd := Len(aRateio)
	
	nValDiv := 0
	nVlComp := 0
	nValor	:= SRT->RT_VALOR
	
	For nC := 1 to nQtd
		If nC # nQtd
			nValDiv := Round(nValor * aRateio[nC,4],2)
			nVlComp += nValDiv
		Else
			nValDiv := nValor-nVlComp
		EndIf
		
		nPerc := aRateio[nC,4]
		If nPerc <= 1
			nPerc := nPerc * 100
		EndIf
		
		RHT->(dbSetOrder(RetOrdem("RHT","RHT_FILIAL+RHT_MAT+RHT_CC+RHT_ITEM+RHT_CLVL+DTOS(RHT_DTCALC)+RHT_TPPROV+RHT_VERBA")))
		If !RHT->(dbSeek(SRT->RT_FILIAL+SRT->RT_MAT+aRateio[nC,1]+aRateio[nC,2]+aRateio[nC,3]+DTOS(dDataRef)+SRT->RT_TIPPROV+SRT->RT_VERBA))
			RecLock("RHT", .T.)
			RHT->RHT_FILIAL  := SRT->RT_FILIAL
			RHT->RHT_MAT     := SRT->RT_MAT
			RHT->RHT_CC      := aRateio[nC,1]
			If lItemClVl
				RHT->RHT_ITEM := aRateio[nC,2]
				RHT->RHT_CLVL := aRateio[nC,3]
			EndIf
			RHT->RHT_TPPROV	 := SRT->RT_TIPPROV
			RHT->RHT_VERBA   := SRT->RT_VERBA
		Else
			RecLock("RHT", .F.)
		EndIf
		RHT->RHT_SALAR  := nSalMes
		RHT->RHT_DTCALC := dDataRef
		RHT->RHT_VALOR  := nValDiv
		RHT->RHT_PERC	:= nPerc
		If SRT->RT_VERBA $ aCodFol[960,1] + "*" + aCodFol[262,1]
			RHT->RHT_DTBASE := dDtBasFer
		EndIf
		RHT->( MsUnlock() )
	Next nC
ElseIf (cTBLXPROV)->PR_TIPMOVI != _Trfe_Ent
	//Verifica quais CC foram calculados no mÍs anterior
	aCCAnt		:= {}
	aCCAtu		:= {}
	aBxaAnt		:= {}
	aBxaAux		:= {}
	dBkpRef		:= MonthSub( dDataRef, 1 )
	cDtIniAnt	:= AnoMes(dBkpRef)+"01"
	cDtFimAnt	:= AnoMes(dBkpRef)+StrZero(f_Ultdia(dBkpRef),2)
	cDtIniAtu	:= AnoMes(dDataRef)+"01"
	cDtFimAtu	:= AnoMes(dDataRef)+StrZero(f_Ultdia(dDataRef),2)
	cAliasRHT	:= "QRHT"
	
	For nTpProv := 1 To 4
		aCCAnt 		:= {}
		aCCAtu 		:= {}
		aBxaAux		:= {}
		aBxaAnt		:= {}
		nProvBus  	:= If(nTpProv == _FerProp, _FerVenc, If(nTpProv == _RecProp, _RecVenc, nTpProv))
		
		If nTpProv == 1
			aProvisao := aClone(aFerVenc)
		ElseIf nTpProv == 2
			aProvisao := aClone(aFerProp)
		ElseIf nTpProv == 3
			aProvisao := aClone(a13Salar)
		Else
			aProvisao := aClone(a14Salar)
		EndIf
		
		//Verifica os CC calculados no mÍs anterior
		//⁄ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒø
		//≥SÛ deve ocorrer baixa no mÍs em casos de transferÍncias e/ou   ≥
		//≥MudanÁa no percentual de Rateio, por isso, foi incluida a      ≥
		//≥cCodBx na query                                                ≥
		//¿ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒŸ
		If __oSt1 == Nil .or. ( __cEmpAux == Nil .or. __cEmpAux <> cEmpAnt ) .or. (lSRVExcl .and. ( __cFilAux == Nil .or. __cFilAux <> cFilAnt ) )
			
			__cEmpAux := cEmpAnt
			__cFilAux := cFilAnt
			
			__oSt1 := FWPreparedStatement():New()
			
			cQuery := "SELECT DISTINCT RHT_CC, RHT_ITEM, RHT_CLVL, RHT_PERC FROM " + RetSqlName('RHT') + " WHERE "
			cQuery += "RHT_FILIAL = ? AND "
			cQuery += "RHT_MAT = ?  AND "
			cQuery += "RHT_VERBA NOT IN ("+cCodBx+") AND "
			cQuery += "RHT_DTCALC BETWEEN ? AND ? AND "
			cQuery += "RHT_SLDIN <> '1' AND " //N„o carrega verbas geradas no perÌodo anterior para baixa de rateios de meses anterior
			cQuery += "D_E_L_E_T_ = ' ' "
			cQuery := ChangeQuery(cQuery)
			
			__oSt1:SetQuery(cQuery)
			
		EndIf
		
		__oSt1:SetString(1,(cTBLXPROV)->PR_FILIAL)
		__oSt1:SetString(2,(cTBLXPROV)->PR_MAT)
		__oSt1:SetString(3,cDtIniAnt)
		__oSt1:SetString(4,cDtFimAnt)
		
		cQuery := __oSt1:getFixQuery()
		
		If Select(cAliasRHT) > 0
			(cAliasRHT)->( dbclosearea())
		EndIf
		
		dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasRHT)
		
		While (cAliasRHT)->( !EoF() )
			aAdd( aCCAnt, { (cAliasRHT)->RHT_CC, (cAliasRHT)->RHT_ITEM, (cAliasRHT)->RHT_CLVL, (cAliasRHT)->RHT_PERC/100, "S" } )
			(cAliasRHT)->( dbSkip() )
		EndDo
		
		(cAliasRHT)->( dbCloseArea() )
		
		//Verifica quais CC foram calculados no mÍs atual
		For nCont := 1 To Len(aRateio)
			aAdd( aCCAtu, { aRateio[nCont,1], aRateio[nCont,2], aRateio[nCont,3], aRateio[nCont,4], "S" } )
		Next nCont
		
		aSort( aCCAnt,,, { |x,y|  x[1]+x[2]+x[3] < y[1]+y[2]+y[3] } )
		aSort( aCCAtu,,, { |x,y|  x[1]+x[2]+x[3] < y[1]+y[2]+y[3] } )
		
		//Verifica se h· os mesmos CC calculados no mÍs anterior no c·lculo do mÍs atual
		If lTransfSai .Or. !ArrayCompare( aCCAnt , aCCAtu )
			aSort(aCCAnt, Nil, Nil, { |x,y| x[5] < y[5] } )
			nQtdCCAnt	:= Len(aCCAnt)
			For nCont := 1 To nQtdCCAnt
				aBxaAux := {}
				For nAnter := 1 To Len(aProvisao[_Anter])
					If nCont > 1
						If nCont < nQtdCCAnt
							aAdd( aBxaAux, Round(aProvisao[_Anter][nAnter] * aCCAnt[nCont][4], 2) )
							aBxaTot[nAnter] += aBxaAux[nAnter]
						Else
							aAdd( aBxaAux, aProvisao[_Anter][nAnter] - aBxaTot[nAnter] )
						EndIf
					Else
						aAdd( aBxaAux, Round(aProvisao[_Anter][nAnter] * aCCAnt[nCont][4], 2) )
						aBxaTot := aClone( aBxaAux )
					EndIf
				Next
				aAdd( aBxaAnt, { aClone(aBxaAux) } )
			Next nCont
		EndIf
		
		//Se houver baixa zera a posiÁ„o do saldo anterior para forÁar a geraÁ„o do saldo total no mÍs
		If !Empty(aBxaAnt) .AND. lTrataTrf
			aFill(aProvisao[_Anter],0)
			lMudouRat	:= .T.
		EndIf
		
		//Gera os valores de baixa na RHT dos CC que n„o foram calculados no mÍs atual
		For nC := 1 To Len(aBxaAnt)
			//Se centro de custo foi calculado no mÍs atual, n„o realiza a baixa.
			If ( aScan(aCCAtu, {|x| x[1]+x[2]+x[3] == aCCAnt[nC,1] + aCCAnt[nC,2] + aCCAnt[nC,3]}) > 0 ) .and. !lTransfSai
				//Loop
			EndIf
			For nCont := 1 To Len(aBxaAnt[nC][1])
				nPosVerba := Ascan(aVerba, { |X| X[1] == nProvBus .And. X[2] == _BxTrf .And. X[3] == nCont })
				cCodVerba := If(nPosVerba > 0, aVerba[nPosVerba,4], Space(3))
				If !Empty(cCodVerba) .And. !Empty(aBxaAnt[nC][1][nCont])
					RHT->(dbSetOrder(RetOrdem("RHT","RHT_FILIAL+RHT_MAT+RHT_CC+RHT_ITEM+RHT_CLVL+DTOS(RHT_DTCALC)+RHT_TPPROV+RHT_VERBA")))
					If !RHT->(dbSeek((cTBLXPROV)->PR_FILIAL+(cTBLXPROV)->PR_MAT+aCCAnt[nC,1]+aCCAnt[nC,2]+aCCAnt[nC,3]+DTOS(dDataRef)+If(nTpProv == 10, "A", Str(nTpProv,1))+cCodVerba))
						RecLock("RHT", .T.)
						RHT->RHT_FILIAL  := (cTBLXPROV)->PR_FILIAL
						RHT->RHT_MAT     := (cTBLXPROV)->PR_MAT
						RHT->RHT_CC      := aCCAnt[nC,1]
						If lItemClVl
							RHT->RHT_ITEM := aCCAnt[nC,2]
							RHT->RHT_CLVL := aCCAnt[nC,3]
						EndIf
						RHT->RHT_TPPROV	 := If(nTpProv == 10, "A", Str(nTpProv,1))
						RHT->RHT_VERBA   := cCodVerba
					Else
						RecLock("RHT", .F.)
					EndIf
					RHT->RHT_SALAR  := nSalMes
					RHT->RHT_DTCALC := dDataRef
					RHT->RHT_VALOR  := aBxaAnt[nC][1][nCont]
					RHT->RHT_PERC	:= (aCCAnt[nC,4]*100)
					If cCodVerba $ aCodFol[960,1] + "*" + aCodFol[262,1]
						RHT->RHT_DTBASE := dDtBasFer
					EndIf
					RHT->( MsUnlock() )
					aAdd( aRecBxa, RHT->( Recno() ) )
				EndIf
			Next nCont
		Next nC
		
		If nTpProv == 1
			aClone(aFerVenc) := aProvisao
		ElseIf nTpProv == 2
			aClone(aFerProp) := aProvisao
		ElseIf nTpProv == 3
			aClone(a13Salar) := aProvisao
		Else
			aClone(a14Salar) := aProvisao
		EndIf
	Next nTpProv
EndIf

RestArea(aArea)

Return
/*
‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±…ÕÕÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÕÀÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÀÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÕÕª±±
±±∫Programa  ≥fChkRHQBase∫Autor  ≥Aldo Marini         ∫ Data ≥  07/11/11  ∫±±
±±ÃÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÕ ÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ ÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕÕÕπ±±
±±∫Desc.     ≥Verifica a existencia da tabela RHQ-Programacao de Rateio   ∫±±
±±∫          ≥para poder gerar os lancamentos rateados no SRT/Contabilizar∫±±
±±ÃÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕπ±±
±±∫Uso       ≥ GPEM110/GPEM070                                            ∫±±
±±»ÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕº±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂ*/
Function fChkRHQBase()
Local lRet 		:= .F.
Local aArea		:= GetArea()
Local aSM0Area	:= SM0->(GetArea())
Local nOrdem

SX2->(dbSetOrder(1))
If SX2->(dbSeek("RHQ"))
	dbSelectArea("RHQ")
	If RHQ->(FieldPos("RHQ_MAT")) > 0
		lRet := .T.
	Endif
Endif

// CASO TENHA SIDO EXECUTADA A OPCAO DO COMPATIBILIZADOR QUE  |
// CRIA RATEIO POR MES DAS PROVISOES, VERIFICA A EXISTENCIA DE|
// VERBA ASSOCIADA AOS NOVOS IDS. CASO EXISTA PELO MENOS UM   |
// DOS IDENTIFICADORES ABAIXO ASSOCIADO, CONSIDERAMOS O RATEIO|
// 960 - F…RIAS, 966 - 13o., 968 - 1A PARCELA DO 13o.		   |

IF lRet
	lRet:= .F.
	//-- VERIFICA A AMARRACAO SRV X ID DE PROVISAO POR RATEIO
	//-- SE O ACODFOL JA TENHA SIDO CARREGADO, UTILIZA-O.
	IF Type("acodfol") <> "U" .AND. Len(aCodFol) > 0
	   IF   (;
			   	!Empty(aCodFol[0960]) .or.  	;
				!Empty(aCodFol[0961]) .or.  	;
				!Empty(aCodFol[0962]) 	.or.	;
			  	!Empty(aCodFol[0963]) .or.  	;
			  	!Empty(aCodFol[0964]) .or.  	;
			  	!Empty(aCodFol[0965]) .or.  	;
			  	!Empty(aCodFol[0966]) .or.  	;
				!Empty(aCodFol[0967]) .or.  	;
				!Empty(aCodFol[0968]) .or.  	;
				!Empty(aCodFol[0969]) .or.  	;
				!Empty(aCodFol[0970]) .or.  	;
			  	!Empty(aCodFol[0971]) 		 	;
			)
			lRet:= .T.
		Endif
	Else
		//-- CORRE TODAS AS FILIAIS EM BUSCA DE VERBA ASSOCIADA A ALGUM IDENTIFICADOR DE RATEIO
		//-- NA EXISTENCIA DE PELO MENOS UMA DAS ASSOCIACOES, O RATEIO EST¡ EFETIVADO
		//-- PALIATIVAMENTE CONSIDERAMOS QUE SE PELO MENOS UMA FILIAL ATENDE A CODICAO DE EFETIVACAO
		//-- AS DEMAIS OBRIGATORIAMENTE ESTARAO CONFIGURADAS PARA TAL.
		SM0->(dbGoTop())
		nOrdem	:= RetOrdem("SRV","RV_FILIAL+RV_CODFOL")
		While SM0->(!Eof())
		     IF 	(;
						(!Empty(RetValSrv("0960",  FWCodFil(), "RV_COD",nOrdem, .F.)) .or. ;
						  !Empty(RetValSrv("0961",  FWCodFil(), "RV_COD",nOrdem, .F.)) .or. ;
						  !Empty(RetValSrv("0962",  FWCodFil(), "RV_COD",nOrdem, .F.)) .or. ;
						  !Empty(RetValSrv("0963",  FWCodFil(), "RV_COD",nOrdem, .F.)) .or. ;
						  !Empty(RetValSrv("0964",  FWCodFil(), "RV_COD",nOrdem, .F.)) .or. ;
						  !Empty(RetValSrv("0965",  FWCodFil(), "RV_COD",nOrdem, .F.)) .or. ;
						  !Empty(RetValSrv("0966",  FWCodFil(), "RV_COD",nOrdem, .F.)) .or. ;
						  !Empty(RetValSrv("0967",  FWCodFil(), "RV_COD",nOrdem, .F.)) .or. ;
						  !Empty(RetValSrv("0968",  FWCodFil(), "RV_COD",nOrdem, .F.)) .or. ;
						  !Empty(RetValSrv("0969",  FWCodFil(), "RV_COD",nOrdem, .F.)) .or. ;
						  !Empty(RetValSrv("0970",  FWCodFil(), "RV_COD",nOrdem, .F.)) .or. ;
						  !Empty(RetValSrv("0971",  FWCodFil(), "RV_COD",nOrdem, .F.))  	 ;
						);
					)
					lRet:= .T.
					Exit
			Endif
			SM0->(dbSkip())
		EndDo
	Endif
Endif

RestArea(aSM0Area)
RestArea(aArea)

Return lRet
/*
‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±⁄ƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒø±±
±±≥Funcao    ≥fPercEmp  ≥ Autor ≥ Allyson M				≥ Data ≥ 29.11.12 ≥±±
±±√ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒ¥±±
±±≥Descricao ≥ Carrega variaveis para calculo dos encargos                ≥±±
±±√ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¥±±
±±≥Sintaxe   ≥ fPercEmp(cRecFatEmp, nPercEmp, nPerEmp13)                  ≥±±
±±√ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¥±±
±±≥Parametros≥ cRecFatEmp 	 - Empresa Mista ou Exclusiva s/ faturamento  ≥±±
±±≥          ≥ nPercEmp      - Percentual da Empresa                      ≥±±
±±≥          ≥ nPerEmp13 	 - Percentual da Empresa p/ 13o. Salario      ≥±±
±±√ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¥±±
±±≥Uso       ≥ GPEM070                                                    ≥±±
±±¿ƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒŸ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±*/
Static Function fPercEmp(cRecFatEmp, nPercEmp, nPerEmp13)
Local aTabOner	:= {}
Local aTabS033	:= {}
Local cAnoMes	:= AnoMes(dDataRef)
Local cDesFol	:= GetMvRH("MV_DESFOL",,"")
Local cLimRef	:= Str(Val(SubStr(cAnoMes, 1, 4)) - 1, 4) + "12"
Local cRefAux	:= cAnoMes
Local lContinua	:= .T.
Local nPosOnera	:= 0
Local nFatDes	:= 0
Local nFatFol	:= 0
Local nFatTot	:= 0
Local nTpc 		:= 0
Local nPercFol  := 0
Local aCalcDes  := {}
Local cReceitDes:= If (Type("P_RECDES") # "U", P_RECDES, "A")
Local nCoeficiente := 0

If cAnoMes < cDesFol
	lDesAtiv	:= .F.
	nPercEmp	:= If ((cTBLXPROV)->PR_TPCONTR$ " *1", aInssEmp[01, 1] , aInssEmp[01, 2])
	nPerEmp13	:= If ((cTBLXPROV)->PR_TPCONTR$ " *1", aInssEmp[01, 1] , aInssEmp[01, 2])
Else
	//SE O ANO DE REFERENCIA FOR MAIOR DO QUE O ANO DO MV_DESFOL OU SE O MES DE INICIO DA DESONERACAO
	//FOR '01' (JANEIRO), NAO E' NECESSARIO FAZER A  PROPORCIONALIZACAO DO INSS
	If ((SubStr(cAnoMes, 1, 4) > SubStr(cDesFol, 1, 4))) .Or. SubStr(cDesFol, 5, 2) == "01"
		lDesAtiv	:= .F.
	Else
		lDesAtiv	:= .T.
		nAvosAnt    := Val(SubStr(cDesFol, 5, 2)) - 1
		nPercAnt	:= If ((cTBLXPROV)->PR_TPCONTR$ " *1", aInssEmp[01, 1] , aInssEmp[01, 2])
	EndIf
	If cAnoMes > cOnefol .And. !Empty(cOneFol) .And. SubStr(cOneFol,1,4) == SubStr(cAnoMes,1,4)
		lOneAtiv	:= .T.
		lDesAtiv	:= .F.
		nAvosAnt    := Val( SubStr( cOneFol, 5, 2 ) )
		//Carrega a tabela S033 com a data do parametro MV_FDESFOL para encontrar o cRecFatEmp da epoca.
		fCarrTab( @aTabOner, "S033", ,.T., cOneFol )
		nPosOnera := Ascan(aTabOner, { |X| X[6] == "2" })
		If nPosOnera > 0
			cRecFatEmp := "oM"
		Else
			cRecFatEmp := "oS"
		Endif
	Else
		lOneAtiv := .F.
	Endif

	If cRecFatEmp == "oS"
		nPercEmp := If ((cTBLXPROV)->PR_TPCONTR$ " *1", aInssEmp[01, 1] , aInssEmp[01, 2])
		nPerEmp13	:= If ((cTBLXPROV)->PR_TPCONTR$ " *1", aInssEmp[01, 1] , aInssEmp[01, 2])
	Else
		nTpc := If( (cTBLXPROV)->PR_TPCONTR $ " *1",1,2)
		//FERIAS UTILIZA O FATURAMENTO DO MES DE CALCULO DA PROVISAO
		If lFerias
			//CHAMA FCARRTAB PARA RECARREGAR TABELA AUXILIAR S033
			fCarrTab(@aTabS033, "S033", dDataRef,.T., cAnoMes)
	    	aCalcDes := fPerFatEmp(cRecFatEmp, 0, aInssEmp[01, nTpc], aTabS033,dDataRef,,,, @nPercFol,,.F.)
			If cRecFatEmp == "S" 
			 	nPercEmp := nPercFol /100
			ElseIf nPercFol == 0
				nPercEmp := aCalcDes[1]
			Else 
				nCoeficiente := If(aCalcDes[1] <> aInssEmp[1, nTpc] .and. !(cRecFatEmp $ "S*oS") .and. aCalcDes[1] > 0, 1 - NoRound( aCalcDes[2]/aCalcDes[3], 4 ), 1)
				nPercEmp     := aCalcDes[1] + ( ( nPercFol * nCoeficiente) / 100)
			EndIf
	  	EndIf
	  	//13o. SALARIO UTILIZA O FATURAMENTO ACUMULADO DE DEZEMBRO/ANO ANTERIOR ATE O MES DE CALCULO DA PROVISAO
	  	//SE A DESONERACAO COMECOU NO MESMO ANO DO CALCULO EFETUADO NA PROVISAO
	  	If l13oSal .And. !(cTBLXPROV)->PR_CATFUNC $ "E|G"
			nPercFol := If(Empty(aInssEmp[32, nTpc]),0,aInssEmp[32, nTpc])
			If aInssEmp[34, nTpc] == "N" //N„o deve calcular encargos pra 13∫
				nPerEmp13 := 0
			Else
				If cRecFatEmp == "S" .and. nPercFol > 0
			 		nPerEmp13 := nPercFol / 100
				Else 
					//PRIMEIRO TENTA ENCONTRAR A REFERENCIA AAAA13 NA TABELA S033 E SE NAO ENCONTRAR,
					//FAZ OS PROCESSOS PARA ENCONTRAR O PERCENTUAL DE 13o.
					If Month(dDataRef) == 12
						aTabS033 := {}
						//CHAMA FCARRTAB PARA RECARREGAR TABELA AUXILIAR S033
						fCarrTab(@aTabS033, "S033", dDataRef,.T., Str(Year(dDataRef), 4) + "13")
						//SE ENCONTROU LANCAMENTOS
						If !Empty(aTabS033)
							//APURA A RECEITA BRUTA TOTAL DA EMPRESA
							aEval(aTabS033, {|aTabS033| nFatTot += aTabS033[10] })
							If cReceitDes $ "A|C"
								//Deduz as exclusoes da receita bruta total da empresa
								aEval(aTabS033, {|aTabS033| nFatTot -= aTabS033[11] } )
								//Deduz as exclusoes da receita bruta que e' sobre as atividades beneficiadas da Lei no. 12.546/2011
								aEval(aTabS033, {|aTabS033| If( aTabS033[6] == "1", nFatDes -= aTabS033[11], ) } )
								//Deduz as exclusoes da receita bruta que nao e' sobre as atividades beneficiadas da Lei no. 12.546/2011
								aEval(aTabS033, {|aTabS033| If( aTabS033[6] == "2", nFatFol -= aTabS033[11], ) } )
							Endif
							If cReceitDes $ "B|C"
								//Deduz as exportacoes da receita bruta total da empresa
								aEval(aTabS033, {|aTabS033| nFatTot -= aTabS033[12] } )
								//Deduz as exportacoes da receita bruta que e' sobre as atividades beneficiadas da Lei no. 12.546/2011
								aEval(aTabS033, {|aTabS033| If( aTabS033[6] == "1", nFatDes -= aTabS033[12], ) } )
								//Deduz as exportacoes da receita bruta que nao e' sobre as atividades beneficiadas da Lei no. 12.546/2011
								aEval(aTabS033, {|aTabS033| If( aTabS033[6] == "2", nFatFol -= aTabS033[12], ) } )
							Endif
							If Len(aTabS033) >= 1 .And. Len(aTabS033[1]) >= 13
								//Deduz os impostos  da receita bruta total da empresa
								aEval(aTabS033, {|aTabS033| nFatTot -= aTabS033[13] } )
							EndIf
							//APURA A RECEITA BRUTA QUE E' SOBRE AS ATIVIDADES BENEFICIADAS DA LEI NO. 12.546/2011
							aEval(aTabS033, {|aTabS033| If(aTabS033[6] == "1", nFatDes += aTabS033[10],) })
							If Len(aTabS033) >= 1 .And. Len(aTabS033[1]) >= 13
								//Deduz os impostos da receita bruta que e' sobre as atividades beneficiadas da Lei no. 12.546/2011
								aEval(aTabS033, {|aTabS033| If( aTabS033[6] == "1", nFatDes -= aTabS033[13], ) } )
							EndIf
							//APURA A RECEITA BRUTA QUE NAO E' SOBRE AS ATIVIDADES BENEFICIADAS DA LEI NO. 12.546/2011
							aEval(aTabS033, {|aTabS033| If(aTabS033[6] == "2", nFatFol += aTabS033[10],) })
							If Len(aTabS033) >= 1 .And. Len(aTabS033[1]) >= 13
								//Deduz os impostos da receita bruta que nao e' sobre as atividades beneficiadas da Lei no. 12.546/2011
								aEval(aTabS033, {|aTabS033| If( aTabS033[6] == "2", nFatFol -= aTabS033[13], ) } )
							EndIf
							lContinua := .F.
						Else
							cRefAux := SubMesAno(cRefAux)
						EndIf
					EndIf
					If lContinua
						If nVerFatFin != 1
							If lVerFat
								lVerFat := .F.
								fAtuS033(cRefAux, cLimRef)
							EndIf
						EndIf
						//ENQUANTO NAO ATINGIR A ANO/MES LIMITE PARA BUSCA DO FATURAMENTO FAZ A SOMA DO FATURAMENTO
						//OBTIDO NA COMEPTENCIA VERIFICADA
						While cRefAux >= cLimRef
							aTabS033 := {}
							//CHAMA FCARRTAB PARA RECARREGAR TABELA AUXILIAR S033
							fCarrTab(@aTabS033, "S033", dDataRef,.T., cRefAux)
							//APURA A RECEITA BRUTA TOTAL DA EMPRESA
							aEval(aTabS033, {|aTabS033| nFatTot += aTabS033[10] })
							If cReceitDes $ "A|C"
								//Deduz as exclusoes da receita bruta total da empresa
								aEval(aTabS033, {|aTabS033| nFatTot -= aTabS033[11] } )
								//Deduz as exclusoes da receita bruta que e' sobre as atividades beneficiadas da Lei no. 12.546/2011
								aEval(aTabS033, {|aTabS033| If( aTabS033[6] == "1", nFatDes -= aTabS033[11], ) } )
								//Deduz as exclusoes da receita bruta que nao e' sobre as atividades beneficiadas da Lei no. 12.546/2011
								aEval(aTabS033, {|aTabS033| If( aTabS033[6] == "2", nFatFol -= aTabS033[11], ) } )
							Endif
							If cReceitDes $ "B|C"
								//Deduz as exportacoes da receita bruta total da empresa
								aEval(aTabS033, {|aTabS033| nFatTot -= aTabS033[12] } )
								//Deduz as exportacoes da receita bruta que e' sobre as atividades beneficiadas da Lei no. 12.546/2011
								aEval(aTabS033, {|aTabS033| If( aTabS033[6] == "1", nFatDes -= aTabS033[12], ) } )
								//Deduz as exportacoes da receita bruta que nao e' sobre as atividades beneficiadas da Lei no. 12.546/2011
								aEval(aTabS033, {|aTabS033| If( aTabS033[6] == "2", nFatFol -= aTabS033[12], ) } )
							Endif
							If Len(aTabS033) >= 1 .And. Len(aTabS033[1]) >= 13
								//Deduz os impostos da receita bruta total da empresa
								aEval(aTabS033, {|aTabS033| nFatTot -= aTabS033[13] } )
							EndIf
							//APURA A RECEITA BRUTA QUE E' SOBRE AS ATIVIDADES BENEFICIADAS DA LEI NO. 12.546/2011
							aEval(aTabS033, {|aTabS033| If(aTabS033[6] == "1", nFatDes += aTabS033[10],) })
							If Len(aTabS033) >= 1 .And. Len(aTabS033[1]) >= 13
								//Deduz os impostos da receita bruta que e' sobre as atividades beneficiadas da Lei no. 12.546/2011
								aEval(aTabS033, {|aTabS033| If( aTabS033[6] == "1", nFatDes -= aTabS033[13], ) } )
							EndIf
							//APURA A RECEITA BRUTA QUE NAO E' SOBRE AS ATIVIDADES BENEFICIADAS DA LEI NO. 12.546/2011
							aEval(aTabS033, {|aTabS033| If(aTabS033[6] == "2", nFatFol += aTabS033[10],) })
							If Len(aTabS033) >= 1 .And. Len(aTabS033[1]) >= 13
								//Deduz os impostos da receita bruta que nao e' sobre as atividades beneficiadas da Lei no. 12.546/2011
								aEval(aTabS033, {|aTabS033| If( aTabS033[6] == "2", nFatFol -= aTabS033[13], ) } )
							EndIf
							//SUBTRAI UM MES DA VARIAVAL QUE CONTROLA A COMPETENCIA
							cRefAux := SubMesAno(cRefAux)
						EndDo
					EndIf
					//CALCULA A RAZAO ENTRE O FATURAMENTO DE ATIVIDADES DIVERSAS SOBRE O FATURAMENTO TOTAL
					nPerEmp13 	:= If(nPercFol > 0, NoRound(nFatFol / nFatTot, 4), nFatFol / nFatTot)
					//CALCULA O NOVO PERCENTUAL DE ACORDO COM A RAZAO ENCONTRADA E O PERCENTUAL DE RECOLHIMENTO ANTIGO

					//Receita nao Desonerada IGUAL/MAIOR que 95% do Total - Aplicacao da aliquota padrao
					If cRecFatEmp $ "M|oM" .And. nPerEmp13 >= 0.95
						nPerEmp13 := If ((cTBLXPROV)->PR_TPCONTR$ " *1", aInssEmp[01, 1] ,aInssEmp[01, 2] )

					//Receita nao Desonerada MAIOR que 5% e MENOR que 95% do Total - Aplicacao da aliquota reduzida
					ElseIf cRecFatEmp $ "M|oM" .And. ( nPerEmp13 > 0.05 .And. nPerEmp13 < 0.95 )
						nPerEmp13 := ( ( nPerEmp13 * If ((cTBLXPROV)->PR_TPCONTR$ " *1", aInssEmp[01, 1] ,aInssEmp[01, 2] ) ) )
					//Receita nao Desonerada MAIOR que 5% - Aplicacao da aliquota reduzida
					ElseIf cRecFatEmp == "C" .And. nPerEmp13 > 0.05
						nPerEmp13 := ( ( nPerEmp13 * If ((cTBLXPROV)->PR_TPCONTR$ " *1", aInssEmp[01, 1] ,aInssEmp[01, 2] ) ) )
					Else
						//A aliquota sera zerada
						If aInssEmp[27, 1] $ "S*M"
							nPerEmp13:=0
						Else
							nPerEmp13 := If ((cTBLXPROV)->PR_TPCONTR$ " *1", aInssEmp[01, 1] ,aInssEmp[01, 2])
						Endif
					EndIf
					If lOneAtiv
						nPercAnt := nPerEmp13
						nPerEmp13 := If ((cTBLXPROV)->PR_TPCONTR$ " *1", aInssEmp[01, 1] ,aInssEmp[01, 2] )
					EndIf 					
					If nPercFol > 0 .and. nPerEmp13 <> aInssEmp[01, nTpc] 
						nCoeficiente := 1 - If(nPerEmp13>0,NoRound( nFatFol/nFatTot, 4 ),0)
						nPerEmp13    += ( ( nPercFol * nCoeficiente) / 100)
					EndIf
				EndIf
			EndIf
	  	EndIf
	EndIf
EndIf

Return
/*
‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±⁄ƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒø±±
±±≥Funcao    ≥fAtuS033  ≥ Autor ≥ Allyson M				≥ Data ≥ 29.11.12 ≥±±
±±√ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒ¥±±
±±≥Descricao ≥ Alimenta tabela S033                                       ≥±±
±±√ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¥±±
±±≥Sintaxe   ≥ fAtuS033(cAnoMes, cLimRef)                                 ≥±±
±±√ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¥±±
±±≥Parametros≥ cRefAux	 - Ano/Mes inici                                  ≥±±
±±≥          ≥ cLimRef 	 - Ano/Mes limite para busca da receita           ≥±±
±±√ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¥±±
±±≥Uso       ≥ GPEM070                                                    ≥±±
±±¿ƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒŸ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±*/
Static Function fAtuS033(cRefAux, cLimRef)
Local aArea			:= GetArea()
Local aAreaSM0	 	:= SM0->(GetArea())
Local aFilProc		:= {}
Local aTabS033		:= {}
Local cCodEmp	 	:= SM0->M0_CODIGO
Local cSvFilAnt		:= ""
Local nAliq	 		:= 0
Local nContr		:= 0
Local nFatTot	 	:= 0
Local nFatTotDev	:= 0
Local nFatTotExp	:= 0
Local nFatTotLiq	:= 0
Local nFatRecB 		:= 0
Local nFatRecL 		:= 0
Local nFatRec 		:= 0
Local nFatExc 		:= 0
Local nFatExp 		:= 0
Local nFatBas		:= 0
Local nFatRecAux	:= 0
Local nFilial		:= 0
Local nTotCLiq		:= 0
Local nTotCont 		:= 0
Local nTotDev 		:= 0
Local nTotExp 		:= 0
Local nTotImp 		:= 0
Local nValDev 		:= 0
Local nValExp 		:= 0
Local nVlAux		:= 0
Local aCargFil	:= {}

//MONTA O ARRAY DAS FILIAIS A PROCESSAR
aCargFil := FwLoadSm0()

aEval(aCargFil,{|aCargFil| If(aCargFil[1] == cCodEmp, Aadd(aFilProc,{ aCargFil[2] }),Nil )} )

While cRefAux >= cLimRef
	//REINICIALIZA VARIAVEIS
	nAliq	 	:= 0
	nContr		:= 0
	nFatRecAux 	:= 0
	nFatTot	 	:= 0
	nFatTotDev	:= 0
	nFatTotExp	:= 0
	nFatTotLiq	:= 0
	nFatRecB 	:= 0
	nFatRecL 	:= 0
	nFatRec 	:= 0
	nFatExc 	:= 0
	nFatExp 	:= 0
	nFatBas		:= 0
	nTotCont 	:= 0
	nTotDev 	:= 0
	nTotExp 	:= 0
	nTotImp 	:= 0
	nTotCLiq 	:= 0
	nValDev 	:= 0
	nValExp 	:= 0
	nVlAux	 	:= 0
	aTabS033	:= {}
	//CHAMA FCARRTAB PARA RECARREGAR TABELA AUXILIAR S033
	fCarrTab(@aTabS033, "S033",,.T., cRefAux)
	//VERIFICA TODAS AS FILIAIS QUE FORAM SELECIONADAS NO PROCESSAMENTO,
	//PARA VALIDAR SE POSSUEM REGISTRO NA TABELA AUXILIAR S033
	For nFilial := 1 To Len(aFilProc)
		//SE NAO ENCONTRAR REGISTROS PARA A FILIAL, VERIFICAR AS FUNCOES DAS INTEGRACOES
		If (aScan(aTabS033, {|x| x[2] == aFilProc[nFilial, 1] }) == 0)
		   	//SE SOMENTE VERIFICA FINANCEIRO
		   	If nVerFatFin == 3
				//ENTRA NA FUNCAO DO FINANCEIRO PARA BUSCAR OS VALORES DOS TITULOS DE ACORDO
				//COM A FILIAL LOGADA. A FUNCAO NAO PERMITE PASSAR A FILIAL COMO PARAMETRO
				//ENTAO A VARIAVEL CFILANT SERA ALTERADA DE ACORDO COM A FILIAL EM PROCESSAMENTO.
				//A FUNCAO RETORNA O VALOR DAS RECEITAS FINANCEIRAS.
				cSvFilAnt := cFilAnt
				cFilAnt	  := aFilProc[nFilial, 1]
				nFatTot   := FTotF100(Val(SubStr(cRefAux, 5, 2)), Val(SubStr(cRefAux, 1, 4)))
				cFilAnt	  := cSvFilAnt
		        //GRAVA O REGISTRO DA RECEITO DE TIPO 2
				If nFatTot > 0
					fGravaS033(aFilProc[nFilial, 1], cRefAux, Nil, "2", nFatTot, 0.00, 0.00, nFatTot, 0.00, 0.00, aTabS033)
				EndIf
		   	//SE VERIFICA FATURAMENTO E/OU FINANCEIRO
		   	Else
				//ENTRA NA FUNCAO DO FATURAMENTO PARA BUSCAR OS VALORES DAS NOTAS FISCAIS DE SAIDA
				//NA TABELA SD2 PARA VERIFICAR O FATURAMENTO DA FILIAL NA COMPETENCIA. A FUNCAO
				//DO FATURAMENTO RETORNA OS DADOS GRAVADOS EM UM ALIAS TEMPORARIO
				cSvFilAnt := cFilAnt
				cFilAnt	  := aFilProc[nFilial, 1]
				cAliasFat := RhInssPat(SubStr(cRefAux, 5, 2) +  SubStr(cRefAux, 1, 4), aFilProc[nFilial, 1])
				cFilAnt	  := cSvFilAnt
				If !Empty(cAliasFat)
					dbSelectArea(cAliasFat)
					(cAliasFat)->(dbGoTop())
					While (cAliasFat)->(!EoF())
				        cCodAti		:= (cAliasFat)->CODATV
				        cTipFat 	:= "1"
				        nAliq		:= SpedPCCG1(cCodAti, dDataRef)
				        nFatTot 	:= (cAliasFat)->TOTAL 		// Total
		                nFatTotLiq 	:= (cAliasFat)->TOTALLIQ	// Total
				        nFatTotDev 	:= (cAliasFat)->TOTLIQDEV 	// Total devolucao
				        nFatTotExp 	:= (cAliasFat)->TOTLIQEXP  	// Total exportacao
				        nFatRecB	:= (cAliasFat)->TOTCODAT	// Total do codigo de atividade bruto
				        nFatRecL	:= (cAliasFat)->TCODATLQ	// Total do codigo de atividade liquido
				        nFatExc		:= (cAliasFat)->TCATVDEV	// Total devolucoes do codigo de atividade
				        nFatExp		:= (cAliasFat)->TLQCATVEXP	// Total exportacoes do codigo de atividade
				        nFatBas 	:= (cAliasFat)->TCDEVEXP 	// Total codigo de atividade - devolucoes - exportacoes (base calculo)
			            //CALCULA A CONTRIBUICAO COM BASE NA ALIQUOTA ENCONTRADA
				        If nAliq > 0
					        nContr	:= (nFatBas * (nAliq/100))
					  	EndIf
				        //GRAVA A INFORMACAO DO RECOLHIMENTO DEVIDO NA TABELA AUXILIAR S033.
						If nFatBas > 0
							fGravaS033( aFilProc[nFilial, 1], cRefAux, cCodAti, cTipFat, nFatBas, nAliq, nContr, nFatRecB, nFatExc, nFatExp, aTabS033, nFatRecB - nFatRecL )
							//CHAMA FCARRTAB PARA RECARREGAR TABELA AUXILIAR S033
							aTabS033 := {}
							fCarrTab(@aTabS033, "S033",dDataRef,, cRefAux)
						Else
							 //SENAO TIVER FATURAMENTO COM PRODUTOS COM COD ATIVIDADE, MAS TIVER ALGUM FATURAMENTO GRAVAR TABELA S033, COM TIPO 2 (PRODUTOS NAO DESONERADOS)
							If nFatTot > 0
								If Empty(cCodAti)
									cTipFat 	:= "2"
								Else
									cTipFat 	:= "1"
								EndIf
								fGravaS033( aFilProc[nFilial, 1], cRefAux, cCodAti, cTipFat, nFatBas, nAliq, nContr, nFatRecB, nFatExc, nFatExp, aTabS033, nFatRecB - nFatRecL )
								//CHAMA FCARRTAB PARA RECARREGAR TABELA AUXILIAR S033
								aTabS033 := {}
								fCarrTab(@aTabS033, "S033", dDataRef,, cRefAux)
							EndIf
						EndIf

						//Caso algum Codigo de Atividade fique com valor Base zerado devido exportacoes e devolucoes, ou no caso
						//de haver somente valores nao desonerados, o total da atividade processada sera atribuido a variavel
						//auxiliar nFatRecAux para posterior deducao do Total Geral para que o valor da Receita Tipo 2 saia correto
						nFatRecAux += If( nFatBas == 0, nFatTotLiq, 0 )

						(cAliasFat)->(dbSkip())
					EndDo
				EndIf

				//FAZ A TOTALIZACAO DA FATURAMENTO DA FILIAL GRAVADAS NA TABELA S033
				aEval(aTabS033, {|aTabS033| If(aTabS033[2] + aTabS033[6] == aFilProc[nFilial, 1] + "1", nTotCont += aTabS033[10], Nil) })
				aEval(aTabS033, {|aTabS033| If(aTabS033[2] + aTabS033[6] == aFilProc[nFilial, 1] + "1", nTotCLiq += aTabS033[7], Nil) })
				aEval(aTabS033, {|aTabS033| If(aTabS033[2] + aTabS033[6] == aFilProc[nFilial, 1] + "1", nTotDev += aTabS033[11], Nil) })
				aEval(aTabS033, {|aTabS033| If(aTabS033[2] + aTabS033[6] == aFilProc[nFilial, 1] + "1", nTotExp += aTabS033[12], Nil) })
				If Len(aTabS033) >= 1 .And. Len(aTabS033[1]) >= 13
					aEval(aTabS033, {|aTabS033| If(aTabS033[2] + aTabS033[6] == aFilProc[nFilial, 1] + "1", nTotImp += aTabS033[13], Nil ) } )
				EndIf
				//ENTRA NA FUNCAO DO FINANCEIRO PARA BUSCAR OS VALORES DOS TITULOS DE ACORDO
				//COM A FILIAL LOGADA. A FUNCAO NAO PERMITE PASSAR A FILIAL COMO PARAMETRO
				//ENTAO A VARIAVEL CFILANT SERA ALTERADA DE ACORDO COM A FILIAL EM PROCESSAMENTO.
				//A FUNCAO RETORNA O VALOR DA RECEITA TOTAL.
				If nVerFatFin == 4
					cSvFilAnt := cFilAnt
					cFilAnt	  := aFilProc[nFilial, 1]
					nVlAux    := FTotF100(Val(SubStr(cRefAux, 5, 2)), Val(SubStr(cRefAux, 1, 4)))
					nFatTot   += nVlAux
					nFatTotLiq+= nVlAux
					cFilAnt	  := cSvFilAnt
				EndIf
				//SE O TOTAL DE FATURAMENTO DA FILIAL FOR MAIOR DO QUE OS REGISTROS GRAVADOS
				//SIGNIFICA QUE HA FATURAMENTO DE ATIVIDADES QUE NAO ESTAO ENQUADRADAS NA LEI
				//ESSE REGISTRO DEVE SER GRAVADO NA TABELA AUXILIAR COM O TIPO DE RECEITA 2
				nValDev := If( nFatTotDev > nTotDev, nFatTotDev, nTotDev )
				nValExp := If( nFatTotExp > nTotExp, nFatTotExp, nTotExp )

				If nFatTotLiq - nValDev - nValExp >= nTotCLiq .And. ( ( nFatTotLiq - nTotCLiq - nFatRecAux - ( nValDev - nTotDev ) - ( nValExp - nTotExp ) ) > 0 .Or. ( nFatTot - nTotCont ) > 0 )
					fGravaS033( aFilProc[nFilial, 1], cRefAux, Nil, "2", ( nFatTotLiq - nTotCLiq - nValExp - nValDev ), 0.00, 0.00, ( nFatTot - nTotCont ), ( nValDev - nTotDev ), ( nValExp - nTotExp ), aTabS033, ( nFatTot - nFatTotLiq - nTotImp ) )
				EndIf
				If Select(cAliasFat) > 0
					(cAliasFat)->( dbCloseArea() )
				EndIf
			EndIf
		EndIf
	Next nFilial
	//SUBTRAI UM MES DA VARIAVAL QUE CONTROLA A COMPETENCIA
	cRefAux := SubMesAno(cRefAux)
EndDo

RestArea(aArea)
RestArea(aAreaSM0)

Return

/*/
⁄ƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒø
≥Funcao    ≥fOpenLog	≥ Autor ≥Mauricio Takakura     ≥ Data ≥05/07/2007≥
√ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒ¥
≥Decricao ≥Cria/Abre arquivo de LOG								     ≥
√ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¥
≥Sintaxe   ≥<Vide Parametros Formais>									 ≥
√ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¥
≥Parametros≥<Vide Parametros Formais>									 ≥
√ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¥
≥Retorno   ≥NIL															 ≥
√ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¥
≥ObservaáÑo≥                                                      	     ≥
√ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¥
≥Uso       ≥SIGAGPE     												 ≥
¿ƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒŸ/*/
Static Function fOpenLog(cDbfLog)
Local lRet			:= .T.
Local aFields		:= {}
Local cRdd			:= "TOPCONN"

Begin Sequence
	IF ( !MsFile( cNameFile , NIL , cRdd ) )
		AADD(aFields, { "CHAVE"		,"C",20							,0} )	// Chave do Processamento
		AADD(aFields, { "REQUIS"	,"C",8							,0} )	// Nro da Requisicao em Processamento
		AADD(aFields, { "CONTROL"	,"C",1							,0} )	// Codigo de Controle -> 1-Processando/2-Finalizado
		AADD(aFields, { "FILIAL"	,"C",TamSX3("RA_FILIAL")[1]		,0} )	// Filial do ultimo Funcionario processado
		AADD(aFields, { "MAT"		,"C",TamSX3("RA_MAT")[1]		,0} )	// Matricula do ultimo Funcionario Processado
		AADD(aFields, { "NOME"		,"C",TamSX3("RA_NOME")[1]		,0} )	// Nome do ultimo Funcionario
		AADD(aFields, { "ROTEIRO"	,"C",TamSX3("RY_CALCULO")[1]	,0} )  	// Roteiro do calculo
		AADD(aFields, { "DT_GRAVA"	,"C",8							,0} )	// Data da ultima gravacao
		AADD(aFields, { "HR_GRAVA"	,"C",8							,0} )	// Hora da ultima gravacao
		IF !( lRet := MsCreate( cNameFile , aFields , cRdd ) )
			Break
		EndIf
	EndIf

	IF !( lRet := MsOpenDbf( .T. , cRdd, cNameFile , cDbfLog , .T. , .F. , .F. , .F. ) )
		Break
	EndIf

	IF !( lRet := ( Select( cDbfLog ) > 0 ) )
		Break
	EndIf
End

Return (lRet)

/*
‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±…ÕÕÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÀÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÀÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÕÕÕ"±±
±±∫Programa  ≥fCriaMnemo∫Autor  ≥Microsiga           ∫ Data ≥  07/15/03   ∫±±
±±ÃÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕ ÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ ÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕÕÕÕπ±±
±±∫Desc.     ≥                                                            ∫±±
±±∫          ≥                                                            ∫±±
±±ÃÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕπ±±
±±∫Uso       ≥ AP                                                         ∫±±
±±»ÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕº±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂ*/
Function fMontaMnemo( cFil , aMnemonicos )
Local aArea			:= GetArea()
Local aAreaRCA		:= RCA->( GetArea() )
Local cFilRCA 		:= xFilial( "RCA" , cFil )
Local lSet				:= .T.
Static lDefautsMnemos
DEFAULT aMneMonicos        := {}
DEFAULT lDefautsMnemos     := .T.

//VERIFICA SE DEVE CARREGAR OS MNEMONICOS PADROES DO SISTEMA
IF  ( lDefautsMnemos )
       fCarMnemo(cFilRCA)
       lDefautsMnemos := .F.
EndIF

IF Empty(aMnemonicos)
       RCA->( dbSetOrder( 01 ) )
       IF ( lSet := RCA->( dbSeek( cFilRCA , .F. ) ) )
             While RCA->( !Eof() .and. ( RCA_FILIAL == cFilRCA ) )
                    RCA->( aAdd( aMneMonicos , { AllTrim( RCA->RCA_MNEMON ) , RCA_DESC , RCA_CONTEUDO , RCA_TIPO , Recno() ,RCA_ACUMUL } ) )
                    RCA->( dbSkip() )
             EndDo
       EndIF
       ( RestArea( aAreaRCA ) , RestArea( aArea ) )
EndIF

Return( lSet )


/*
‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±…ÕÕÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÀÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÀÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÕÕÕ"±±
±±∫Programa  ≥fSalHvar ∫Autor  ≥Marcia Moura         ∫ Data ≥  27/09/2016 ∫±±
±±ÃÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕ ÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ ÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕÕÕÕπ±±
±±∫Desc.     ≥                                                            ∫±±
±±∫          ≥                                                            ∫±±
±±ÃÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕπ±±
±±∫Uso       ≥ AP                                                         ∫±±
±±»ÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕº±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂ*/
Function fSalHvar()

Private dDataHorj := dDtBasFer

fSalInc(@nSalario,@nSalMes,@nSalHora,@nSalDia,.T.,,,,dDataRef,,@nPeric,@nInsal,@nAdtServ,@nAdcConf,@nAdcTransf,@nOutros,@nSalhInc)

Return

/*
‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±…ÕÕÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÀÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÀÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÕÕÕ"±±
±±∫Programa  ≥fChkMatTpc ∫Autor  ≥Renan Borges       ∫ Data ≥  07/10/2016 ∫±±
±±ÃÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕ ÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ ÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕÕÕÕπ±±
±±∫Desc.     ≥                                                            ∫±±
±±∫          ≥                                                            ∫±±
±±ÃÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕπ±±
±±∫Uso       ≥ AP                                                         ∫±±
±±»ÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕº±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂ*/

Static Function fChkMatTpc(cFil, cMat, cTpc)
Local lRet		:= .T.
Local aArea	:= GetArea()

DbSelectArea("SRA")
DbSetOrder(1)
If(dbSeek(cFil+cMat))
	If (Empty(SRA->RA_TPCONTR) .AND. cTpc == "1") .OR. SRA->RA_TPCONTR == cTpc
		lRet	:= .F.
	EndIf
EndIf

RestArea(aArea)
Return lRet

Function Rst070Cod()
	_aCodFol := {}
Return( Nil )

Static Function GetDferAnt(dBasFer, nDiasDir, lFerAberto, cStatus, lMudaDt, dFerOpen, lFirstSRF, n13Fer)

Local aArea		:= GetArea()
Local nDias		:= 0
Local nDiasProx	:= 0
Local nDFerVen  := 0
Local cPeriodo	:= ""
Local nFaltas	:= 0
Local lColetiva := .F.

//dDataRef -> data calculo provisao

lMudaDt := .F.

SRH->(DbSetOrder(RetOrder("SRH","RH_FILIAL+RH_MAT+DTOS(RH_DATABAS)")))
If SRH->(DbSeek(SRA->RA_FILIAL + SRA->RA_MAT+Dtos(dBasFer)))
	While SRH->( !EoF() ) .And. SRH->RH_FILIAL + SRH->RH_MAT == SRA->RA_FILIAL + SRA->RA_MAT .And. SRH->RH_DATABAS == dBasFer

		If SRH->RH_DATAINI <= dDataRef
			cPeriodo 	:= SRH->RH_PERIODO
			nDias 		+= SRH->RH_DFERIAS + SRH->RH_DABONPE
			nFaltas 	+= SRH->RH_DFALTAS
			If cTpBxFer == "2" .And. SRH->RH_DATAFIM > dDataRef
				nDiasProx := Day(SRH->RH_DATAFIM)
			EndIf
			If cAnoMes == AnoMes(SRH->RH_DATAINI)
				n13Fer += SRH->RH_PERC13S
			EndIf
		EndIf
		nDFerVen += SRH->RH_DFERVEN
		lColetiva := ( SRH->RH_TIPCAL == "C" ) .and. ( Empty(SRA->RA_DEMISSA) .or. AnoMes(SRA->RA_DEMISSA) > AnoMes(dDataRef) )
		SRH->( dbSkip() )
	EndDo
	If (lColetiva .And. SRF->RF_STATUS <> "1" .And. SRF->RF_DATAFIM < dDataRef)
		lFerAberto := .F.
	ElseIf lFirstSRF .And. ( ( SRF->RF_DFERANT > 0 .And. SRF->RF_STATUS == "3" .And. SRF->RF_DFERVAT == 0 ) .or. ( SRF->RF_STATUS == "1" .and. SRF->RF_DFERVAT == 0 .and. nDias > nDFerVen ) )//AntecipaÁ„o de fÈrias
		lFerAberto := .T.
		lMudaDt := .F.
	Else
		If nFaltas > 0
			TabFaltas(@nFaltas)
		EndIf
		nFaltas	    := Max( 0, nFaltas ) 
        lFerAberto  := ( (nDias + nFaltas - nDiasProx) < nDiasDir )
		If !lFerAberto .And. mesano(dDataRef) == cPeriodo
			lMudaDt := .T.
		EndIf
	EndIf
ElseIf !(SRA->RA_RESCRAI $ '30/31') .And. !Empty(SRA->RA_DEMISSA) .And. lFechouMes .And. AnoMes(dDataRef) <= AnoMes(SRA->RA_DEMISSA) .And. dBasFer >= dFerOpen
	 lFerAberto := .T.
	 lMudaDt := .F.
Else
	nDias := SRF->RF_DFERANT
	lFerAberto := (cStatus == "1" .or. Empty(cStatus))
	lMudaDt := .F.
EndIf

RestArea(aArea)
Return nDias

/*{Protheus.doc} GetDferRes

Funcao que verifica o perÌodo aquisitivo em aberto na Rescis„o quando for retroativo, ou seja, c·lculo de perÌodo fechado anterior ao perÌodo da Rescis„o

@author Allyson Mesashi
@since 19/10/2017
@version P12 R17
@Param nRecnoSRF Recno do ˙ltimo perÌodo aquisitivo cadastrado na SRF
@Return dDataPer Retorna a data do perÌodo aquisitivo em aberto
*/

Static Function GetDferRes( nRecnoSRF, lDemMes )

Local dDataPer := cToD("//")
Local nRecSRG  := 0

lDemMes := .F.

dbSelectArea("SRG")
SRG->( dbSetOrder(3) )
If SRG->( MsSeek((cTBLXPROV)->PR_FILIAL + (cTBLXPROV)->PR_MAT + DtoS(SRA->RA_DEMISSA) ) )
	While SRG->(!Eof() .and. RG_FILIAL + RG_MAT + DtoS(RG_DATADEM) == (cTBLXPROV)->PR_FILIAL + (cTBLXPROV)->PR_MAT + DtoS(SRA->RA_DEMISSA) )
		If SRG->RG_PERIODO <= cAnoMes .OR. nRecSRG == 0
			nRecSRG := SRG->(Recno())
		EndIf
		SRG->(DbSkip())
	EndDo
	If nRecSRG > 0
		SRG->(DbGoTo(nRecSRG))
		lDemMes := SRG->RG_PERIODO == cAnoMes
		dbSelectArea("SRR")
		SRR->( dbSetOrder(8) )
		If SRR->( MsSeek((cTBLXPROV)->PR_FILIAL + (cTBLXPROV)->PR_MAT + "R" + dToS(SRG->RG_DTGERAR) + aCodFol[86,1] ) )
			dDataPer := StoD( SubStr(SRR->RR_NUMID, 1, 8) )
		EndIf
		If Empty(dDataPer)
			SRF->( dbGoto( nRecnoSRF ) )
			dDataPer := SRF->RF_DATABAS
		EndIf
	EndIf
EndIf

Return dDataPer

/*
‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±⁄ƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒø±±
±±≥Funáao	 ≥fBxaPlrPro≥ Autor ≥ Emerson Rosa de Souza	≥ Data ≥ 26.06.00 ≥±±
±±√ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒ¥±±
±±≥Descriáao ≥ Busca a Baixa de 13o Salario								  ≥±±
±±√ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¥±±
±±≥Sintaxe	 ≥ fBxa13oProv(cArqBxa13,cFilBxa13,cMatBxa13cDatBxa13,...)	  ≥±±
±±√ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¥±±
±±≥ Uso	 	 ≥ Generico 												  ≥±±
±±¿ƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒŸ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂ*/
Static Function fBxaPlrProv()
Local nBxaPlr		:= 0
Local cRotPLR 	    := fGetCalcRot('F')
Local nCnt1
Local aVerbasFunc

// RETORNA AS VERBAS DO FUNCIONARIO A PARTIR DO SRC E SRD
aVerbasFunc	:= RetornaVerbasFunc(	(cTBLXPROV)->PR_FILIAL					,; // Filial do funcionario corrente
									(cTBLXPROV)->PR_MAT	  					,; // Matricula do funcionario corrente
									NIL								,; //
									cRotPLR								,; // Roteiro para busca das verbas
									NIL			  					,; // Array com as verbas que dever„o ser listadas. Se NIL retorna todas as verbas.
									aPerAbPL	  					,; // Array com os Periodos e Numero de pagamento abertos
									aPerFePL	 	 				) // Array com os Periodos e Numero de pagamento fechados

For nCnt1 := 1 To Len(aVerbasFunc)
	If aVerbasFunc[nCnt1,nPosPd] $ cCodPLR
		nBxaPlr += aVerbasFunc[nCnt1,nPosValor]
	EndIf
Next nCnt1

If nBxaPlr > 0
	aPLRSalar[_BxPlr,_Prov] := nBxaPlr
Endif

Return ( nBxaPlr > 0 )

/*{Protheus.doc} fVerRateio

FunÁ„o para buscar o rateio de CC no mÍs de c·lculo

@author Allyson Mesashi
@since 12/01/2018
@version P12 R17
*/
Static Function fVerRateio()

Local nC := 0

DEFAULT lItemClVl   := GetMvRH("MV_ITMCLVL", .F., "2") $ "13"

DbSelectArea("RHT")
DbSetOrder(1)

// CARREGA O RATEIO POR CENTRO DE CUSTO DA TABELA DE RATEIOS - RHQ
aRateio	:= {}

// CARREGA OS REGISTROS DA TABELA RHQ-PROGRAMACAO DE RATEIO PARA PEGAR OS PERCENTUAIS X CENTRO DE CUSTO
fRateio({},2, cAno+cMes)

// VERIFICA O TAMANHO DO RETORNO DO ARRAY PARA CRIAR AO MENOS UM REGISTRO PARA A GERACAO
nQtd := Len(aRateio)

If nQtd == 0
	If lItemClVl
	   	aAdd(aRateio,{(cTBLXPROV)->PR_CC, (cTBLXPROV)->PR_ITEM, (cTBLXPROV)->PR_CLVL, 1, "S", 0, ""})
	Else
	   	aAdd(aRateio,{(cTBLXPROV)->PR_CC, Space(GetSx3Cache("RHQ_ITEM","X3_TAMANHO")), Space(GetSx3Cache("RHQ_CLVL","X3_TAMANHO")), 1, "S", 0, ""})
	Endif
	nQtd := 1
Else
	// VERIFICA SE EXISTEM ORIGENS SISTEMAS (CAMPO RHQ_ORIGEM = 'S') E TAMBEM GERADAS PELO
	// USUARIO PARA CONSIDERAR APENAS OS REGISTROS DO TIPO USUARIO (CAMPOS RHQ_ORIGEM = 'U'),
	// CASO EXISTIR APENAS UM TIPO, IRA CONSIDERAR O QUE EXISTIR
    If aScan(aRateio, { |X| X[5] == "S" })	> 0 .And. aScan(aRateio, { |X| X[5] == "U" })	> 0
	    For nC := 1 to Len(aRateio)
			If  (nPosRateio := aScan(aRateio, { |X| X[5] == "S" })) > 0
				aDel(aRateio , nPosRateio)
				aSize(aRateio,Len(aRateio)-1)
			Endif
	    Next
		nQtd := Len(aRateio)
	Endif
Endif

Return

Static Function fGetPer13(cAno,cRCHFil	,cProcesso	,;
						cRoteiro	,;		//Opcional - Filtro por Roteiro
						aPerAberto	,;		//Por Referencia - Array com os periodos Abertos
						aPerFechado,;		//Por Referencia - Array com os periodos Fechados
						aPerTodos  ;		//Por Referencia - Array com os periodos Abertos e Fechados em Ordem Crescente
						 )
Local aArea	:= GetArea()

dbSelectArea("RCH")
RCH->(DbSetOrder(RetOrder("RCH", "RCH_FILIAL+RCH_ANO+RCH_MES")))	// Ordem 4
RCH->(DbSeek( cRCHFil+cAno, .F. ))
While RCH->( !Eof() ) .and. RCH->( RCH_FILIAL + RCH_ANO ) == cRCHFil + cAno

	If 	(!Empty(cProcesso) .And. RCH->RCH_PROCES <> cProcesso) .Or.;
		(!Empty(cRoteiro) .and. RCH->RCH_ROTEIR <> cRoteiro)
		RCH->( DbSkip() )
		Loop
	EndIf

	If Empty( RCH->RCH_DTFECH )
		aAdd(aPerAberto	, RCH->({RCH_PER, RCH_NUMPAG, RCH_MES, RCH_ANO, RCH_DTINI, RCH_DTFIM, RCH_PROCES, RCH_ROTEIR, RCH_DTPAGO, RCH_DTCORT, RCH_DTINTE }))
	Else
		aAdd(aPerFechado, RCH->({RCH_PER, RCH_NUMPAG, RCH_MES, RCH_ANO, RCH_DTINI, RCH_DTFIM, RCH_PROCES, RCH_ROTEIR, RCH_DTPAGO, RCH_DTCORT, RCH_DTINTE }))
	EndIf

	RCH->( DbSkip() )
EndDo

RestArea(aArea)

Return

/*
‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±…ÕÕÕÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÀÕÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÀÕÕÕÕÕÕ—ÕÕÕÕÕÕÕÕÕÕÕÕÕª±±
±±∫Programa  ≥CriaTransf∫Autor  ≥Jonatas A. T. Alves ∫ Data ≥  10/03/09   ∫±±
±±ÃÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕ ÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ ÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕÕÕÕπ±±
±±∫Desc.     ≥Cria tabela com replica das informacoes do array aTransf.   ∫±±
±±ÃÕÕÕÕÕÕÕÕÕÕÿÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕπ±±
±±∫Uso       ≥ Gpem070                                                    ∫±±
±±»ÕÕÕÕÕÕÕÕÕÕœÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕº±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂ*/
STATIC Function CriaTransf()
Local lRet			:= .T.
Local aFields		:= {}
Local cRdd			:= "TOPCONN"
Local cQuery		:= ""
Local nTamPos		:= Len(Alltrim(Str(nTamTrf)))

Begin Sequence
	If (!MsFile(cFileTrf , NIL , cRdd))
		AADD(aFields, {"TRFPOS"		,"N",nTamPos				,0})
		AADD(aFields, {"TRFELE"		,"N",01						,0})
		AADD(aFields, {"TRFEMPP"	,"C",02						,0})
		AADD(aFields, {"TRFFILIALP"	,"C",FWGETTAMFILIAL  		,0})
		AADD(aFields, {"TRFCCP"		,"C",TamSX3("RA_CC")[1]		,0})
		AADD(aFields, {"TRFMATP"	,"C",TamSX3("RA_MAT")[1]	,0})
		AADD(aFields, {"TRFDATE"	,"C",06						,0})
		AADD(aFields, {"TRFNLIDO"	,"L",01						,0})
		AADD(aFields, {"TRFITMP"	,"C",TamSX3("RA_ITEM")[1]	,0})
		AADD(aFields, {"TRFCLVLP"	,"C",TamSX3("RA_CLVL")[1]	,0})
		If !(lRet := MsCreate(cFileTrf , aFields , cRdd))
			Break
		EndIf
	Else
		cQuery := "DELETE FROM " + cFileTrf
		TcSqlExec(cQuery)
	Endif
	If !(lRet := MsOpenDbf(.T. , cRdd, cFileTrf , cTrfDbf , .T. , .F. , .F. , .F.))
		Break
	EndIf
	If !(lRet := (Select(cTrfDbf) > 0))
		Break
	EndIf
End Sequence

Return (lRet)

Function Gp070LimpaMed(lLimpa)
	DEFAULT lLimpa := .T.

	lLimpaMed := lLimpa

Return Nil

/*{Protheus.doc} fVal13Mat

FunÁ„o para obter os valores de maternidade sobre 13∫ do perÌodo para abater nos encargos da empresa

@author Leandro Drumond
@since 14/01/2021
@version P12
*/
Static Function fVal13Mat(nBaseMat, nBaseAdc, nDiasMat, nTotMes, nV_Adic, lBxaRes, nVl1447)

Local nValAux 	:= 0

Default nV_Adic := 0
Default lBxaRes := .F.
Default nVl1447 := 0

If nSalMes > 0 .and. aCodFol[1435,1] $ P_DEDMAT
	nBaseMat := ( nSalMes * nTotMes ) / 12 
	nBaseMat := Min(( nBaseMat / nTotMes / 30 ) * nDiasMat, nBaseMat)
EndIf

If nAdtServ > 0 .and. ( aCodFol[1438,1] $ P_DEDMAT .or. aCodFol[1439,1] $ P_DEDMAT )
	nValAux := ( nAdtServ * nTotMes ) / 12 
	nBaseAdc += Min(( nValAux / nTotMes / 30 ) * nDiasMat, nValAux)
EndIf

If nPeric > 0 .and. ( aCodFol[1440,1] $ P_DEDMAT .or. aCodFol[1441,1] $ P_DEDMAT )
	nValAux := ( nPeric * nTotMes ) / 12 
	nBaseAdc += Min(( nValAux / nTotMes / 30 ) * nDiasMat, nValAux)
EndIf

If nInsal > 0 .and. ( aCodFol[1442,1] $ P_DEDMAT .or. aCodFol[1443,1] $ P_DEDMAT )
	nValAux := ( nInsal * nTotMes ) / 12 
	nBaseAdc += Min(( nValAux / nTotMes / 30 ) * nDiasMat, nValAux)
EndIf

If nAdcConf > 0 .and. aCodFol[1444,1] $ P_DEDMAT
	nValAux := ( nAdcConf * nTotMes ) / 12 
	nBaseAdc += Min(( nValAux / nTotMes / 30 ) * nDiasMat, nValAux)
EndIf

If nAdcTransf > 0 .and. aCodFol[1445,1] $ P_DEDMAT
	nValAux := ( nAdcTransf * nTotMes ) / 12 
	nBaseAdc += Min(( nValAux / nTotMes / 30 ) * nDiasMat, nValAux)
EndIf

If nV_Adic > 0 .And. (aCodFol[1436,1] $ P_DEDMAT .Or. aCodFol[1437,1] $ P_DEDMAT)
	nBaseAdc += Iif( !lBxaRes, Min(( nV_Adic / nTotMes / 30 ) * nDiasMat, nV_Adic), nVl1447 )
EndIf

Return Nil

/*{Protheus.doc} fChkAfaMat

Verifica se existe afastamento por maternidade e se dever· deduzir valores dos encargos da empresa

@author Leandro Drumond
@since 18/01/2021
@version P12
*/
Static Function fChkAfaMat(nDiasMat)
Local cAux 	:= ""
Local cVerba:= ""
Local nX	:= 0

nDiasMat := 0

P_ENCEMP	:= If(Type("P_ENCEMP")=="U","", P_ENCEMP) //Define quais encargos ter„o as verbas de maternidade deduzidas. 1 = Todos
P_DEDMAT	:= If(!Empty(P_ENCEMP) .and. Type("P_DEDMAT")<>"U",P_DEDMAT,"") //Define quais verbas de maternidade ser„o deduzidas. 1 = Todos

If !Empty(P_ENCEMP) .and. !Empty(P_DEDMAT)
	nDiasMat := fDiasSm13(Str(Year(dDataRef)),,,,dDataRef)
EndIf

If nDiasMat > 0
	If !Empty(P_ENCEMP) .and. P_ENCEMP <> '1' .and. !("*" $ P_ENCEMP)
		cAux := ""
		For nX := 1 to Len(P_ENCEMP) step 3
			cAux += SubStr(P_ENCEMP,nX,3) + "*"
		Next nX
		P_ENCEMP := cAux	
	EndIf

	If !Empty(P_DEDMAT)
		cAux := ""
		If P_DEDMAT <> '1' .and. !("*" $ P_DEDMAT)
			For nX := 1 to Len(P_DEDMAT) step 3
				cVerba := SubStr(P_DEDMAT,nX,3)
				If RetValSrv( cVerba, SRA->RA_FILIAL, "RV_INSS" ) == "S"
					cAux += cVerba + "*"
				EndIf
			Next nX
			P_DEDMAT := cAux
		ElseIf P_DEDMAT == "1"
			aPdMat := fCarPdMat()
			For nX := 1 to Len(aPdMat)
				cAux += aPdMat[nX] + "*"
			Next nX
			P_DEDMAT := cAux
		EndIf 
	EndIf
EndIf

Return Nil

/*{Protheus.doc} fVerAdiMP
Verifica as verbas com postergaÁ„o do pagamento na MP 1.046/2021 e retorna ao saldo
@author Allyson Mesashi
@since 19/05/2021
@version P12
*/
Static Function fVerAdiMP()

Local cTpBxFer	:= GetMvRH("MV_TPBXFER",, "1")
Local cVbAbo	:= RetValSrv(aCodFol[74,1], (cTBLXPROV)->PR_FILIAL, "RV_CODMPA")+"/"
Local cVbAboMs	:= RetValSrv(aCodFol[205,1], (cTBLXPROV)->PR_FILIAL, "RV_CODMPA")+"/"
Local cVbAdic	:= (RetValSrv(aCodFol[622,1], (cTBLXPROV)->PR_FILIAL, "RV_CODMPA")+"/"+RetValSrv(aCodFol[623,1], (cTBLXPROV)->PR_FILIAL, "RV_CODMPA")+"/"+;
					RetValSrv(aCodFol[1312,1], (cTBLXPROV)->PR_FILIAL, "RV_CODMPA")+"/"+RetValSrv(aCodFol[1314,1], (cTBLXPROV)->PR_FILIAL, "RV_CODMPA")+"/"+;
					RetValSrv(aCodFol[1316,1], (cTBLXPROV)->PR_FILIAL, "RV_CODMPA")+"/"+RetValSrv(aCodFol[1318,1], (cTBLXPROV)->PR_FILIAL, "RV_CODMPA")+"/"+;
					RetValSrv(aCodFol[1320,1], (cTBLXPROV)->PR_FILIAL, "RV_CODMPA")+"/"+RetValSrv(aCodFol[1322,1], (cTBLXPROV)->PR_FILIAL, "RV_CODMPA")+"/"+;
					RetValSrv(aCodFol[1324,1], (cTBLXPROV)->PR_FILIAL, "RV_CODMPA")+"/"+RetValSrv(aCodFol[1326,1], (cTBLXPROV)->PR_FILIAL, "RV_CODMPA")+"/"+;
					RetValSrv(aCodFol[1330,1], (cTBLXPROV)->PR_FILIAL, "RV_CODMPA")+"/"+RetValSrv(aCodFol[1407,1], (cTBLXPROV)->PR_FILIAL, "RV_CODMPA")+"/"+;
					RetValSrv( aCodFol[1408,1], (cTBLXPROV)->PR_FILIAL, "RV_CODMPA")+"/")
Local cVbAdicMS	:= (RetValSrv(aCodFol[633,1], (cTBLXPROV)->PR_FILIAL, "RV_CODMPA")+"/"+RetValSrv(aCodFol[634,1], (cTBLXPROV)->PR_FILIAL, "RV_CODMPA")+"/"+;
					RetValSrv(aCodFol[1313,1], (cTBLXPROV)->PR_FILIAL, "RV_CODMPA")+"/"+RetValSrv(aCodFol[1315,1], (cTBLXPROV)->PR_FILIAL, "RV_CODMPA")+"/"+;
					RetValSrv(aCodFol[1317,1], (cTBLXPROV)->PR_FILIAL, "RV_CODMPA")+"/"+RetValSrv(aCodFol[1319,1], (cTBLXPROV)->PR_FILIAL, "RV_CODMPA")+"/"+;
					RetValSrv(aCodFol[1321,1], (cTBLXPROV)->PR_FILIAL, "RV_CODMPA")+"/"+RetValSrv(aCodFol[1323,1], (cTBLXPROV)->PR_FILIAL, "RV_CODMPA")+"/"+;
					RetValSrv(aCodFol[1325,1], (cTBLXPROV)->PR_FILIAL, "RV_CODMPA")+"/"+RetValSrv(aCodFol[1327,1], (cTBLXPROV)->PR_FILIAL, "RV_CODMPA")+"/"+;
					RetValSrv(aCodFol[1331,1], (cTBLXPROV)->PR_FILIAL, "RV_CODMPA")+"/"+RetValSrv(aCodFol[1409,1], (cTBLXPROV)->PR_FILIAL, "RV_CODMPA")+"/"+;
					RetValSrv( aCodFol[1410,1], (cTBLXPROV)->PR_FILIAL, "RV_CODMPA")+"/")
Local cVbUmT	:= (RetValSrv(aCodFol[77,1], (cTBLXPROV)->PR_FILIAL, "RV_CODMPA")+"/"+RetValSrv(aCodFol[79,1], (cTBLXPROV)->PR_FILIAL, "RV_CODMPA"))+"/"
Local cVbUmTMS	:= (RetValSrv(aCodFol[78,1], (cTBLXPROV)->PR_FILIAL, "RV_CODMPA")+"/"+RetValSrv(aCodFol[206,1], (cTBLXPROV)->PR_FILIAL, "RV_CODMPA"))+"/"
Local lFimFer	:= .F.

If cTpBxFer == "2" .And. (AnoMes(SRH->RH_DATAINI) == AnoMes( (SRH->RH_DATAINI + SRH->RH_DFERIAS)-1 )) .And. SRH->RH_DABONPE > 0
	cTpBxFer := "1"
EndIf

lFimFer	:= (cTpBxFer == "1" .Or. AnoMes(SRH->RH_DATAFIM) == cAnoMes)

If SRR->( dbSeek( (cTBLXPROV)->PR_FILIAL + (cTBLXPROV)->PR_MAT + "F" + dToS(SRH->RH_DATAINI) ) )
	While SRR->( !Eof() ) .And. SRR->RR_FILIAL+SRR->RR_MAT+SRR->RR_TIPO3+dToS(SRR->RR_DATA) == (cTBLXPROV)->PR_FILIAL+(cTBLXPROV)->PR_MAT+"F"+dToS(SRH->RH_DATAINI)
		If SRR->RR_PD $ (cVbAbo+cVbAboMs) .Or. SRR->RR_PD $ (cVbAdic+cVbAdicMS) .Or. SRR->RR_PD $ (cVbUmT+cVbUmTMS)
			If SRR->RR_PD $ cVbAbo .Or. (lFimFer .And. SRR->RR_PD $ cVbAboMs)
				aFerVenc[_Atual,_Prov] += SRR->RR_VALOR
			ElseIf SRR->RR_PD $ cVbAdic .Or. (lFimFer .And. SRR->RR_PD $ cVbAdicMS)
				aFerVenc[_Atual,_Adic] += SRR->RR_VALOR
			ElseIf SRR->RR_PD $ cVbUmT .Or. (lFimFer .And. SRR->RR_PD $ cVbUmTMS)
				aFerVenc[_Atual,_1Ter] += SRR->RR_VALOR
			EndIf
			aFerVenc[_Atual,_INSS] += NoRound(SRR->RR_VALOR * (nPercEmp+nPercTer+nPercAcTrab))
			aFerVenc[_Atual,_FGTS] += NoRound(SRR->RR_VALOR * nPercFgts)
			aFerVenc[_Atual,_PIS]  += NoRound(SRR->RR_VALOR * nPercPis)
		EndIf
		SRR->( dbSkip() )
	EndDo
EndIf

Return

/*/{Protheus.doc} fTemInterm
//Verifica se houve pagamento de contrato intermitente/verde e amarelo para o funcion·rio no ano
@author Emerson Grassi Rocha
@since 20/10/2021
/*/
Static Function fTemInterm(lFerias,dDtBasFer)

Local aAreaSRD  := {}
Local aSaveArea := GetArea()
Local cAno 		:= Str(Year(ddataref),4)
Local cRotFol	:= fGetCalcRot("1")
Local lRet		:= .F.

DEFAULT lFerias   := .F.

DbSelectArea("SV7")
DbSetOrder(1)
	
If DbSeek(SRA->RA_FILIAL + SRA->RA_MAT)
	While SV7->(!Eof() .and. V7_FILIAL + V7_MAT == SRA->RA_FILIAL + SRA->RA_MAT)
		If !lFerias .and. cValToChar(Year(SV7->V7_DTINI)) == cAno .Or. cValToChar(Year(SV7->V7_DTFIM)) == cAno
			lRet := .T.
			Exit
		EndIf
		If lFerias .and. SV7->V7_DTINI >= dDtBasFer .And. SV7->V7_DTFIM <= dDataRef
			lRet := .T.
			Exit
		EndIf
		SV7->(DbSkip())
	EndDo
EndIf

If !lRet
	aAreaSRD  := SRD->( GetArea() )
	SRD->( dbSetOrder(6) )//RD_FILIAL+RD_MAT+RD_PD+RD_ROTEIR+DTOS(RD_DATPGT)
	If SRD->( dbSeek( SRA->RA_FILIAL+SRA->RA_MAT+aCodFol[72, 1]+cRotFol+cAno ) ) .And. SRD->RD_TIPO2 == "C"
		lRet := .T.
	EndIf

	RestArea( aAreaSRD )
EndIf

RestArea(aSaveArea)

Return lRet

/*/{Protheus.doc} fAbtFerInterm
//Busca valores de FÈrias pagas de contrato intermitente para o funcion·rio no periodo
@author Emerson Grassi Rocha
@since 19/10/2021
/*/
Static Function fAbtFerInterm(nxValor, nxUmTer, nxInss)
Local aSaveArea := GetArea()
Local cAliasAux	:= GetNextAlias()
Local cPerIni 	:= ""
Local cPerFim 	:= ""
Local cWhere	:= ""
Local nX		:= 0

Default nxValor	:= 0
Default nxUmTer	:= 0 
Default nxInss 	:= 0

//Encontra o periodo
For nX := 1 To Len(aPerFerias)
	If dDataRef >= aPerferias[nX][1]
	 	cPerIni := Str(Year(aperferias[nX][1]),4)+Strzero(Month(aperferias[nX][1]),2)
 		cPerFim := Str(Year(aperferias[nX][2]),4)+Strzero(Month(aperferias[nX][2]),2)
	EndIf
Next nX

cAliasAux := GetNextAlias()
cWhere   := "SRD.RD_FILIAL = '"+SRA->RA_FILIAL+"' AND "+;
			"SRD.RD_MAT = '"+SRA->RA_MAT+"' AND "+;
			"(SRD.RD_PD = '"+aCodFol[72,1]+"' OR "+; 	// Ferias
			"SRD.RD_PD = '"+aCodFol[77,1]+"' OR "+; 	// 1/3 Ferias
			"SRD.RD_PD = '"+aCodFol[65,1]+"') AND "+; 	// INSS Ferias
			"SRD.RD_PERIODO >= '"+cPerIni+"' AND "+;
			"SRD.RD_PERIODO <= '"+cPerFim+"' AND "+;
			"SRD.RD_ROTEIR = '"+ fGetCalcRot("1") + "' "
cWhere   := "%"+cWhere+"%"

BeginSql alias cAliasAux
	SELECT RD_PD, RD_VALOR 
	FROM %table:SRD% SRD 
	WHERE %exp:cWhere% AND SRD.%notDel%  
EndSql

While !(cAliasAux)->(Eof())
	
	If (cAliasAux)->(RD_PD) == aCodFol[72,1]
		nxValor += (cAliasAux)->(RD_VALOR) 
	ElseIf (cAliasAux)->(RD_PD) == aCodFol[77,1] 
		nxUmTer += (cAliasAux)->(RD_VALOR) 
	ElseIf (cAliasAux)->(RD_PD) == aCodFol[65,1] 
		nxInss += (cAliasAux)->(RD_VALOR) 
	EndIf
	
	(cAliasAux)->(dbskip())
Enddo
(cAliasAux)->(dbCloseArea())

RestArea(aSaveArea)
Return Nil


/*/{Protheus.doc} fAbt13Interm
//Busca valores de 13o. Salario pagos de contrato intermitente para o funcion·rio no periodo
@author Emerson Grassi Rocha
@since 19/10/2021
/*/
Static Function fAbt13Interm(nxValor, nxInss, nxFgts)
Local aSaveArea := GetArea()
Local cAliasAux	:= ""
Local cAno 		:= Str(Year(dDataRef),4)
Local cWhere	:= ""

Default nxValor	:= 0
Default nxInss 	:= 0
Default nxFgts 	:= 0 

cAliasAux	:= GetNextAlias()
cWhere   := "SRD.RD_FILIAL = '"+SRA->RA_FILIAL+"' AND "+;
			"SRD.RD_MAT = '"+SRA->RA_MAT+"' AND "+;
			"(SRD.RD_PD = '"+aCodFol[24,1]+"' OR "+; 	// 2a. parc. 13o. Salario
			"SRD.RD_PD = '"+aCodFol[70,1]+"' OR "+; 	// INSS 13o. Salario
			"SRD.RD_PD = '"+aCodFol[109,1]+"') AND "+; 	// FGTS 13o. Salario
			"SRD.RD_PERIODO >= '"+cAno+"01' AND "+;
			"SRD.RD_PERIODO <= '"+cAno+"12' AND "+;
			"SRD.RD_ROTEIR = '"+ fGetCalcRot("1") + "' "
cWhere   := "%"+cWhere+"%"

	BeginSql alias cAliasAux
	SELECT RD_PD, RD_VALOR 
	FROM %table:SRD% SRD 
	WHERE %exp:cWhere% AND SRD.%notDel%  
EndSql

While !(cAliasAux)->(Eof())

		If (cAliasAux)->(RD_PD) == aCodFol[24,1]
			nxValor += (cAliasAux)->(RD_VALOR) 
		ElseIf (cAliasAux)->(RD_PD) == aCodFol[70,1] 
			nxInss += (cAliasAux)->(RD_VALOR) 
		ElseIf (cAliasAux)->(RD_PD) == aCodFol[109,1] 
			nxFGTS += (cAliasAux)->(RD_VALOR) 
		EndIf
	
	(cAliasAux)->(dbskip())
Enddo
(cAliasAux)->(dbCloseArea())

RestArea(aSaveArea)
Return Nil


/*/{Protheus.doc} fVerSusp
//Busca Suspens„o disciplinar no perÌodo 
@author Leandro Drumond
@since 10/06/2022
/*/

Static Function fVerSusp(aPerFerias)

Local aArea 	:= GetArea()
Local cAliasTit	:= GetNextAlias()
Local cQrySt	:= ""
Local nFaltas 	:= 0

Static __oStTit

If __oStTit == Nil
	__oStTit := FWPreparedStatement():New()
	cQrySt := "SELECT TIT_QTDDIA"
	cQrySt += "FROM " + RetSqlName('TIT') + " TIT "
	cQrySt += "WHERE TIT.TIT_FILIAL = ? AND "
	cQrySt += 		"TIT.TIT_MAT = ? AND "
	cQrySt += 		"TIT.TIT_TIPO = '1' AND "
	cQrySt += 		"TIT.TIT_AFASTA = '1' AND "
	cQrySt += 		"TIT.TIT_DATA >= ? AND "
	cQrySt += 		"TIT.TIT_DATA <= ? AND "
	cQrySt += 		"TIT.D_E_L_E_T_ = ' '"
	cQrySt := ChangeQuery(cQrySt)
	__oStTit:SetQuery(cQrySt)
EndIf

__oStTit:SetString(1, SRA->RA_FILIAL)
__oStTit:SetString(2, SRA->RA_MAT)
__oStTit:SetString(3, DtoS(aPerFerias[1]))
__oStTit:SetString(4, DtoS(aPerFerias[2]))

cQrySt := __oStTit:getFixQuery()

dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQrySt),cAliasTit,.T.,.T.)

While (cAliasTit)->( !EoF() )
	nFaltas += (cAliasTit)->TIT_QTDDIA
	(cAliasTit)->(DbSkip())	
EndDo

(cAliasTit)->(dbCloseArea())

RestArea(aArea)

Return(nFaltas)

/*{Protheus.doc} fAdi14457
Verifica as verbas de 1/3 com postergaÁ„o do pagamento na Lei 14.457/2022 e retorna ao saldo
@author Allyson Mesashi
@since 14/08/2023
*/
Static Function fAdi14457()

Local cTpBxFer	:= GetMvRH("MV_TPBXFER",, "1")
Local cVbUmT	:= aCodFol[77, 1]+"/"+aCodFol[79, 1]+"/"
Local cVbUmTMS	:= aCodFol[78, 1]+"/"+aCodFol[206, 1]+"/"
Local lFimFer	:= .F.

If cTpBxFer == "2" .And. (AnoMes(SRH->RH_DATAINI) == AnoMes( (SRH->RH_DATAINI + SRH->RH_DFERIAS)-1 )) .And. SRH->RH_DABONPE > 0
	cTpBxFer := "1"
EndIf

lFimFer	:= (cTpBxFer == "1" .Or. AnoMes(SRH->RH_DATAFIM) == cAnoMes)

While SRK->( !Eof() ) .And. SRK->RK_FILIAL+SRK->RK_MAT+RTrim(SRK->RK_NUMID) == (cTBLXPROV)->PR_FILIAL+(cTBLXPROV)->PR_MAT+"FER-"+cValToChar( SRH->( Recno() ) )
    If SRK->RK_PD $ cVbUmT .Or. (lFimFer .And. SRK->RK_PD $ cVbUmTMS)
        aFerVenc[_Atual,_1Ter] += SRK->RK_VALORTO
        aFerVenc[_Atual,_INSS] += NoRound(SRK->RK_VALORTO * (nPercEmp+nPercTer+nPercAcTrab))
        aFerVenc[_Atual,_FGTS] += NoRound(SRK->RK_VALORTO * nPercFgts)
        aFerVenc[_Atual,_PIS]  += NoRound(SRK->RK_VALORTO * nPercPis)
    EndIf
    SRK->( dbSkip() )
EndDo

Return

/*{Protheus.doc} fPag14457
Verifica os periodos em que h· o pagamento da postergaÁ„o do 1/3 da Lei 14.457/2022
@author Allyson Mesashi
@since 14/08/2023
*/
Static Function fPag14457( aPerPagUmT )

Local aAreaSRK  := SRK->( GetArea() )
Local aAreaSRH  := SRH->( GetArea() )
Local nRecno    := 0

SRK->( dbSetOrder(2) )//RK_FILIAL+RK_MAT+RK_NUMID
If SRK->( dbSeek( (cTBLXPROV)->PR_FILIAL+(cTBLXPROV)->PR_MAT ) ) 
    While SRK->( !EoF() ) .And. SRK->RK_FILIAL+SRK->RK_MAT == (cTBLXPROV)->PR_FILIAL+(cTBLXPROV)->PR_MAT
        If SubStr( SRK->RK_NUMID, 1, 4 ) == "FER-"
            If ( nRecno := Val( RTrim( SubStr(SRK->RK_NUMID, 5) ) ) ) > 0
                SRH->( dbGoTo( nRecno ) )
                If SRH->RH_POSTUMT == "3" .And. aScan( aPerPagUmT, { |x| x == AnoMes(SRK->RK_DTVENC) } ) == 0
                    aAdd( aPerPagUmT, AnoMes(SRK->RK_DTVENC) )
                EndIf
            EndIf
        EndIf
        SRK->( dbSkip() )
    End
EndIf

RestArea( aAreaSRK )
RestArea( aAreaSRH )

Return

/*{Protheus.doc} fTransfExterna
Verifica se existe SRE na data do desligamento por transferÍncia
@author Bruno Costa
@since 01/08/2024
*/
Static Function fTransfExterna(cAliasSRA)

Local aArea    := GetArea()
Local aAreaSRE := SRE->( GetArea() )
Local lRet     := .F.
Local nTam     := GetSx3Cache("RE_FILIALD", "X3_TAMANHO")

//TransferÍncia externa para o eSocial n„o existe SRE, apenas SRA
If SRE->( !dbSeek( cEmpAnt+Substr((cAliasSRA)->RA_FILIAL+Space(nTam), 1, nTam)+(cAliasSRA)->RA_MAT+Dtos((cAliasSRA)->RA_DEMISSA) )) 
    lRet := .T.
EndIf

RestArea(aAreaSRE)
RestArea(aArea)

Return lRet



/*/{Protheus.doc} SchedDef
DefiniÁ?es de agendamento do Schedule.
@author Maria LuÌsa de Souza Arcanjo Bastos
@since 06/12/2024
/*/
Static Function SchedDef()

    Local aParam As Array
    // InicializaÁ?o das vari·veis
    aParam := {}

    // Montagem da estrutura do vetor de retorno
    AAdd(aParam, "P")       // Tipo do agendamento: "P" = Processo | "R" = RelatÛrio
    AAdd(aParam, "GPEM070") // Pergunte (SX1) (usar "PARAMDEF" caso n?o tenha conjunto de perguntas)
    AAdd(aParam, "")        // Alias principal (exclusivo para relatÛrios)
    AAdd(aParam, {})        // Vetor de ordenaÁ?o (exclusivo para relatÛrios)
    AAdd(aParam, "")        // TÌtulo (exclusivo para relatÛrios)

Return aParam
