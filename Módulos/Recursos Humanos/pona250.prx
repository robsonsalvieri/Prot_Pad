#INCLUDE "PONA250.CH"
#INCLUDE "PROTHEUS.CH"

#DEFINE Confirma 1
#DEFINE Abandona 2                          

/*/


Ŀ
Funo     Pona250   Autor  Mauricio MR            Data  20.07.01 
Ĵ
Descrio  Cadastramento de Refeicoes                                 
Ĵ
 Uso       Generico                                                   
Ĵ
         ATUALIZACOES SOFRIDAS DESDE A CONSTRUAO INICIAL.             
Ĵ
Programador  Data    BOPS   Motivo da Alteracao                     
Ĵ
Cecilia C.  20/05/14TPQAN3Incluido o fonte da 11 para a 12 e efetu- 
                          ada a limpeza.                            
Isabel N. 01/02/17MRH-5793Alterao na chamada da funo FreeForUsed
                          p/FreeForUse, como descrita no sistema.   
ٱ

/*/
Function Pona250 
Local aArea			:= GetArea()
/*
Ŀ
 So Executa se os Modos de Acesso dos Arquivos Relacionados es
 tiverem OK.												   
*/
IF ValidArqPon() 
    Private cFiltraRh						//Variavel para filtro
	Private cFiltraRef                      //Variavel para filtro complementar
	Private aIndexSP1	:= {}	 	    	//Variavel Para Filtro
	Private bFiltraBrw 	:= {|| Nil}			//Variavel para Filtro
	//Ŀ
	// Define array contendo as Rotinas a executar do programa      
	// ----------- Elementos contidos por dimensao ------------     
	// 1. Nome a aparecer no cabecalho                              
	// 2. Nome da Rotina associada                                  
	// 3. Usado pela rotina                                         
	// 4. Tipo de Transao a ser efetuada                          
	//    1 - Pesquisa e Posiciona em um Banco de Dados             
	//    2 - Simplesmente Mostra os Campos                         
	//    3 - Inclui registros no Bancos de Dados                   
	//    4 - Altera o registro corrente                            
	//    5 - Remove o registro corrente do Banco de Dados          
	//
	PRIVATE aRotina := MenuDef()
	
	Private aRef:={}
	cCadastro := OemToAnsi(STR0009)  //"Cadastro de Refeicoes"
	
	
	fCargaRef(@aRef,xFilial("SP1"))   
	
	If Empty(Len(aRef))
	 	Help(" ",1,"PNA25001  ")  //"Tabela de Tipos de Refeicao Nao Cadastrada"   
	 	RestArea(aArea)
	   	Return .F.
	Endif
	
	//Ŀ
	// Inicializa o filtro utilizando a funcao FilBrowse                      
	//   
	
	//Lista Somente o Primeiro Registro dos CodRefs Cadastrados (P1_SEQ=="01")
	cFiltraRh 	:= CHKRH("PONA250","SRA","1") 
	cFiltraRef 	:= Alltrim(cFiltraRh)+If(!Empty(cFiltraRh)," .And. ","")+"SP1->P1_SEQ=='01'"
	
	bFiltraBrw 	:= {|| FilBrowse("SP1",@aIndexSP1,@cFiltraRef) }
	
	Eval(bFiltraBrw)
	
	
	//Ŀ
	// Endereca a funcao de BROWSE                                  
	//
	dbSelectArea("SP1")   
	mBrowse( 6, 1,22,45,"SP1")
	
	//Ŀ
	// Deleta o filtro utilizando a funcao FilBrowse                     	   
	//
	EndFilBrw("SP1",aIndexSP1) 
Endif 

RestArea(aArea)
Return

/*/


Ŀ
Funo    pn250Atu   Autor  Mauricio MR            Data  20.07.01 
Ĵ
Descrio  Programa de (Vis.,Inc.,Alt. e Del. de  Refeicao            
Ĵ
Sintaxe    pn250Atu(ExpC1,ExpN1,ExpN2)                                
Ĵ
Parametros ExpC1 = Alias do arquivo                                   
           ExpN1 = Numero do registro                                 
           ExpN2 = Numero da opcao selecionada                        
Ĵ
 Uso       pnEA250                                                    
ٱ

*/
Function pn250Atu(cAlias,nReg,nOpcx)

Local aArea		:= GetArea()
Local aAdvSize		:= {}
Local aInfoAdvSize	:= {}
Local aObjSize		:= {}
Local aObjCoords	:= {}
Local nCnt			:= 0.00		//Variavel Auxiliar para conter registros lidos
Local a250Field 	:= {"P1_FILIAL","P1_CODREF","P1_DESC","P1_SEQ"}   //Define os campos que nao serao mostrados no Cabec 
Local nSavRec   	:= RecNo()
Local oDlg			:= NIL
Local oGet			:= NIL
Local oFont			:= NIL
Local oGroup		:= NIL
                        
//Variaveis para tratamento da leitura dos registros
Private cCond			:=	"P1_FILIAL+P1_CODREF"
Private cChave			:=	''

//Inicializa Variaveis CodRef e Descricao 
Private cCodRef			:= CriaVar("P1_CODREF")        
Private cDesc  			:= CriaVar("P1_DESC")      

//Armazena campos que poderao ser deixados Vazios
Private a250VazioField 	:= {"P1_HORAINI","P1_HORAFIM","P1_RELOGIO"}
Private aColsRec 		:= {}   
Private aVirtual  		:= {}   

Private nOpc			:= nOpcx
dbSelectArea( cAlias )
//Para opcoes diferentes da inclusao recupera identificacao do grupo de refeicao escolhido      
//antes de desabilitar o filtro
If nOpcx#3
	Go nReg
	cCodRef		:=	SP1->P1_CODREF
	cDesc		:= 	SP1->P1_DESC
Endif

//Ŀ
// Deleta o filtro utilizando a funcao FilBrowse                     	   
//
EndFilBrw("SP1",aIndexSP1)      
dbSelectArea("SP1")
SP1->( dbSetorder( 1 ) ) //Quando Eliminar o Filtro deve retornar uma Ordem
aIndexSP1:={}

//Na inclusao Gera e Sugere o codigo do novo grupo de refeicao e possibilita a digitacao
//da respectiva descricao    
If nOpcx==3
	Dbseek(xFilial("SP1"))
	cCodRef		:=	GetSxENum("SP1","P1_CODREF")
	cDesc		:= 	CriaVAr("P1_DESC")
Endif 

//Inicializa variavel de pesquisa
cChave:=xFilial(cAlias)+cCodRef   
	
Begin Sequence

	//Ŀ
	// Bloqueia Registros									         
	//
	If ! Pona250Locks( nOpcX , cAlias, {}, {cCodRef } )  
	   If __lSX8
	   	  RollBackSX8()
	   EndIf
	   Break
	Endif
	/*
	Ŀ
	 Monta as Dimensoes dos Objetos         					   
	*/
	aAdvSize		:= MsAdvSize()
	aInfoAdvSize	:= { aAdvSize[1] , aAdvSize[2] , aAdvSize[3] , aAdvSize[4] , 5 , 5 }
	aAdd( aObjCoords , { 000 , 025 , .T. , .F. } )
	aAdd( aObjCoords , { 000 , 000 , .T. , .T. } )
	aObjSize		:= MsObjSize( aInfoAdvSize , aObjCoords )
	
	While .T.
	
		//Ŀ
		// Verifica se existe algum dado no arquivo                     
		//
	  
	   SP1->( dbSeek( cChave ) )
	   
	   nCnt := 0
	   While !EOF() .And. (&cCond == cChave)
			nCnt++
			dbSkip()
	   EndDo
	
	    If nCnt > 0  .And. nOpcx = 3    //--Quando Inclusao e existir Registro
			Help(" ",1,"PNA25002  ")     //"Tabela de Refeicao ja cadastrada"
			Exit
	    Elseif nCnt = 0 .And. nOpcx # 3  //--Quando Nao for Inclusao e nao existir Registro
		    Help(" ",1,"PNA25003  ")     // "Tabela de Refeicao Nao Cadastrada"
			Exit
		Endif
		
		//Ŀ
		// Monta a entrada de dados do arquivo                          
		//
		Private aTELA[0][0]
		Private aGETS[0]
		Private aHeader 	:= {}
		Private Continua	:= .F.
		Private nUsado		:= 0
		
		//Ŀ
		// Monta o cabecalho                                            
		//
	    aHeader := GdMontaHeader( @nUsado , @aVirtual , NIL , "SP1" , a250Field )
		
		//Armazena as Posicoes das Colunas dos campos mais referenciados
		Private nPosTipoRef		:= GdFieldPos( "P1_TIPOREF" 	) 
		Private nPosHrIn		:= GdFieldPos( "P1_HORAINI" 	) 
		Private nPosHrFm		:= GdFieldPos( "P1_HORAFIM" 	)  
		Private nPosDescRef		:= GdFieldPos( "P1_DESCREF"		)
	   	Private nPosRelogio		:= GdFieldPos( "P1_RELOGIO"		)
	
		//Bloco para reorganizar as linhas por Hora Final + Hora Inicio + Tipo Ref   
		Private bSort			:= { |x,y|	fDataHora(,x[nPosHrFm], x[nPosHrIn]) + ;
									 				If(nPosRelogio>0.00,x[nPosRelogio],'')+;
									 				x[nPosTipoRef]			< 	;
											fDataHora(,y[nPosHrFm], y[nPosHrIn]) + ;
									 				If(nPosRelogio>0.00,y[nPosRelogio],'')+;
													y[nPosTipoRef] }
															
		//Ŀ
	    // Gerar o array aCols com os horarios das refeicoes            
		//
	    Private aCols := {}
	    pn250Acols(a250Field,nOpcx)
	                                                                      
	   	//Ŀ
	    // Bloqueia Registros									         
		//
		If ! Pona250Locks( nOpcX , cAlias, aColsRec, {cCodRef } )  
		   If __lSX8
		   	  RollBackSX8()
		   EndIf
		   Exit
		Endif
		   
		Private aColsAnt :=	aClone(aCols)
		
		nOpca := 0
	   
		DEFINE FONT oFont		NAME "Arial" SIZE 0,-11 BOLD
		DEFINE MSDIALOG oDlg TITLE OemToAnsi(STR0010) From aAdvSize[7],0 TO aAdvSize[6],aAdvSize[5] OF oMainWnd PIXEL	//"Refeies"
			
		@ aObjSize[1,1] , aObjSize[1,2] GROUP oGroup TO aObjSize[1,3],aObjSize[1,4]*0.30  LABEL OemToAnsi(STR0011) OF oDlg PIXEL	//"Cdigo: "
		oGroup:oFont:= oFont
		@ aObjSize[1,1] , aObjSize[1,4]*0.305 GROUP oGroup TO aObjSize[1,3],aObjSize[1,4]  LABEL OemToAnsi(STR0012) OF oDlg PIXEL			//"Descrio:" 
		oGroup:oFont:= oFont
	
	    IF nOpcx != 3
			@ aObjSize[1,1]+10, aObjSize[1,2]*2.5		SAY cCodRef		SIZE 010,10 OF oDlg PIXEL FONT oFont
			@ aObjSize[1,1]+10, aObjSize[1,4]*0.32		SAY cDesc		SIZE 265,10 OF oDlg PIXEL FONT oFont
	    Else
		    @ aObjSize[1,1]+10, aObjSize[1,2]*2.5  	MSGET cCodRef	PICTURE PesqPict("SP1","P1_CODREF")	SIZE 010,10	OF oDlg PIXEL FONT oFont VALID  Pn250AVAL(cCodRef) .AND. FreeForUse('SP1',cCodRef)
			@ aObjSize[1,1]+10, aObjSize[1,4]*0.32		MSGET cDesc 	PICTURE "@!S40"						SIZE 265,10 OF oDlg PIXEL FONT oFont VALID  NaoVazio()
	    EndIF
	
	    oGet:= MSGetDados():New(aObjSize[2,1],aObjSize[2,2],aObjSize[2,3],aObjSize[2,4],nOpcx,"pn250LinOk","pn250TudOk",,If(nOpcx=2.Or.nOpcx=5,Nil,.T.),,1)
	   
	    ACTIVATE MSDIALOG oDlg ON INIT (EnchoiceBar(oDlg,{|| nOpca:=1 ,If(oGet:TudoOk(),oDlg:End(),nOpca:=0)},{||nOpca := 2,oDlg:End()}))
	
	    //--Se Confirma
	    If nOpca == 1
			If nOpcx # 5 .And. nOpcx # 2	// Se nao for Exclusao e Visualizacao
				Begin Transaction
					If nOpcx == 3			// Inclusao
						If __lSX8
							ConfirmSX8()
						EndIf
					EndIf	
					Pn250Grava(cAlias)
					EvalTrigger()
				End Transaction
			ElseIf nOpcx = 5
				Begin Transaction
					Pn250Dele(cAlias,cChave, nReg , nOpcx )
				End Transaction
			EndIf
		Else
			If __lSX8
				RollBackSX8()
			EndIf		
		EndIf   
	    
		Exit
	EndDo
	
End
FreeLocks( 'SP1' , NIL , .T. )

//Ŀ
// Restaura a integridade da janela                             
//

cAlias := "SP1"
dbSelectArea(cAlias)

//Reinicializa Filtro
Eval(bFiltraBrw)
Go nSavRec      

RETURN(.T.)

/*/

Ŀ
Funo    pn250Dele  Autor  Mauricio MR            Data  20.07.01 
Ĵ
Descrio  Deleta os Registro de  Refeicoes                           
Ĵ
 Uso       pn250Dele                                                  
ٱ

*/
Static Function pn250Dele(cAlias,cChave, nReg , nOpcx )

Local lRet	:= .T.
Local nX	:= 0
Local cMsgErr

//Checa se Grupo de Refeicao esta em uso na Tabela de Refeicao
//Retorna .F. se positivo
If PnVerDele( cAlias , nReg , nOpcx )

	nCnt := 0
	For nx = 1 to Len(aCols)
	    dbSeek(cChave)
	    IF !RecLock(cAlias,.F.,.T.)
	    	Loop
	    EndIF
	    IF !FkDelete( @cMsgErr )
	    	RollBackDelTran( cMsgErr )
	    Else
	    	nCnt++
	    EndIF
	    MsUnlock()
	    
	Next nx     
Endif

Return lRet            


/*/

Ŀ
Funo    pnVerDele  Autor  Mauricio MR            Data  03.03.04 
Ĵ
Descrio  Verifica se pode Deletar o Registro de  Refeicoes          
Ĵ
 Uso       pn250Dele                                                  
ٱ

*/
Static Function PnVerDele( cAlias , nReg , nOpcx )

Local aArea			:= GetArea()
Local aAreas		:= {}
Local cFilSP1		:= xFilial( "SP1" )
Local lDelOk		:= .T.
Local nAreas		:= 0    
Local cChave		:= ''

DEFAULT cAlias		:= 'SP1'
DEFAULT nReg  		:= SP1->(Recno())
DEFAULT nOpcx	    := nOpc

Begin Sequence

	//SP5
	aAdd( aAreas , Array( 03 ) )
	nAreas := Len( aAreas )
	aAreas[nAreas,01] := SP5->( GetArea() )
	aAreas[nAreas,02] := Array( 3 )
					aAreas[nAreas,02,01] := "P5_FILIAL"
					aAreas[nAreas,02,02] := "P5_CODREF"
	aAreas[nAreas,03] := RetOrdem( "SP5" , "P5_FILIAL+P5_CODREF" , .T. )
	
	//SPJ
	aAdd( aAreas , Array( 03 ) )
	nAreas := Len( aAreas )
	aAreas[nAreas,01] := SPJ->( GetArea() )
	aAreas[nAreas,02] := Array( 2 )
					aAreas[nAreas,02,01] := "PJ_FILIAL"
					aAreas[nAreas,02,02] := "PJ_CODREF"
	aAreas[nAreas,03] := RetOrdem( "SPJ" , "PJ_FILIAL+PJ_CODREF" , .T. )

	( cAlias )->( MsGoto( nReg ) )
    cChave		:= SP1->(P1_CODREF)

	lDelOk := ChkDelRegs(	cAlias			,;	//01 -> Alias do Arquivo Principal
							nReg			,;	//02 -> Registro do Arquivo Principal
							nOpcx			,;	//03 -> Opcao para a AxDeleta
							cFilSP1			,;	//04 -> Filial do Arquivo principal para Delecao
							cChave		    ,;	//05 -> Chave do Arquivo Principal para Delecao
							aAreas			,;	//06 -> Array contendo informacoes dos arquivos a serem pesquisados
							NIL				,;	//07 -> Mensagem para MsgYesNo
							NIL				,;	//08 -> Titulo do Log de Delecao
							NIL				,;	//09 -> Mensagem para o corpo do Log
							.F.				,;	//10 -> Se executa AxDeleta
							.T.				,;	//11 -> Se deve Mostrar o Log
							NIL				,;	//12 -> Array com o Log de Exclusao
							NIL				,;	//13 -> Array com o Titulo do Log
							NIL				,;	//14 -> Bloco para Posicionamento no Arquivo
							NIL				,;	//15 -> Bloco para a Condicao While
							NIL				 ;	//16 -> Bloco para Skip/Loop no While
						)

End Sequence

RestArea(aArea)

Return( lDelOk )

/*/


Ŀ
Funo    g250aCols  Autor Equipe Advanced RH      Data  20.07.01 
Ĵ
Descrio  Criar os Arrays Aheader e aCols de refeicoes               
Ĵ
 Uso       PONA250                                                    
ٱ

*/
Static Function pn250aCols(a250Field,nOpcx)

Local bAsc		:= { || NIL }
Local nAux		:= 0.00
Local nPos		:= 0.00
Local nRecnos	:= 0.00

cChave	:= ( xFilial("SP1")+cCodRef )
aCols	:= GDMontaCols( @aHeader , @nUsado , aVirtual , NIL , "SP1" , a250Field , @aColsRec , "SP1" , cChave )
IF ( ( nRecnos := Len( aColsRec ) ) > 0.00 )
	bAsc := { |xRef| Alltrim( xRef[1] ) == Alltrim( aCols[ nAux , nPosTipoRef ] ) }
	For nAux := 1 To nRecnos
		IF ( ( nPos := aScan( aRef , bAsc  ) ) > 0.00 )
			aCols[ nAux , nPosDescRef ] := aRef[ nPos , 2 ]
		Else                                     
			aCols[ nAux , nPosDescRef ] := STR0013 //Nao Cadastrada
		EndIF
	Next nAux
Else
    //Forca a inclusao do Tipo de Refeicao "ZZ"
    aCols[ 1 , nPosTipoRef ] :=	"ZZ"
   	bAsc := { |xRef| Alltrim( xRef[1] ) == "ZZ" }
   	IF ( ( nPos := aScan( aRef , bAsc ) ) > 0.00 )
		aCols[ 1 , nPosDescRef ] := aRef[ nPos , 2 ]
	Else                                     
		aCols[ 1 , nPosDescRef ] := STR0013 //Nao Cadastrada
	EndIF
EndIF

Return( NIL )

/*/


Ŀ
                   ROTINAS DE CRITICA DE CAMPOS                        
ٱ



Ŀ
Funo    pn250Grava Autor  Mauricio MR            Data  20.07.01 
Ĵ
Descrio  Grava no arquivo de Refeicoes                              
Ĵ
 Uso       pn250Grava                                                 
ٱ

/*/
Function pn250Grava(cAlias)

Local ny		:=	0,nMaxArray:=Len(aHeader)
Local nX		:=	0
Local nSeq  	:= 	0
Local naCols 	:=	Len(aCols)
Local aArea		:= GetArea()
Local cMsgErr

dbSelectArea(cAlias)

//-- Ordena os Horarios das Refeicoes para consistencia
aSort(aCols,,, bSort )

For nX:=1 TO Len(aCols)

    If nX <= Len(aColsRec)
        dbGoto(aColsRec[nX])
        IF !RecLock(cAlias,.F.,.T.)
        	Loop
        EndIF
        //--Verifica se esta deletado
        If aCols[nX,nUsado+1]  # .F.
	    	IF !FkDelete( @cMsgErr )
	    		RollBackDelTran( cMsgErr )
            EndIF
            Loop
        Endif
    Else
       //--Verifica se Nao esta Deletado no aCols
       If aCols[nX,nUsado+1]  = .F.      
           
            IF !RecLock(cAlias,.T.,.T.)   
				Loop
            EndIF
            Replace SP1->P1_Filial	WITH xFilial("SP1")
            Replace SP1->P1_CodRef 	WITH cCodRef   
            Replace SP1->P1_Desc 	WITH cDesc  
            
       Else
            Loop
       Endif
    Endif 
    
    //Grava Dados
    For ny := 1 To nMaxArray
        
        cCampo    := UPPER(Trim(aHeader[ny][2]))
        xConteudo := aCols[nX,ny]
        
        //Forca que horarios para Tipo REfe. "ZZ" sejam "Zerados"
        If aCols[nX][nPosTipoRef] == "ZZ"
	        If cCampo$"P1_HORAINI.P1_HORAFIM.P1_RELOGIO"
		       xConteudo:=Criavar(cCampo)
		    Endif   
	    Endif
	    
	    Replace &cCampo With xConteudo
     Next ny
    
    //Gera Sequencia
    nSeq  ++
    Replace SP1->P1_Seq 	WITH STRZERO(nSeq,2)  
    MsUnlock()
Next nX                      

RestArea(aArea)
Return

/*/


Ŀ
Funo    pn250LinOk Autor  Mauricio MR            Data  20.07.01 
Ĵ
Descrio Critica linha digitada                                      
Ĵ
 Uso       Generico                                                   
ٱ

/*/
Function pn250LinOk(o)
Local lRet 	:= .T.

//-- Nao pode haver nenhum campo vazio

If ! aCols[n,nUsado+1]  
    
	//-- Consiste Linha 
	lREt:=fConsiste(.T.)
Else	
	If aCols[n,nPosTipoRef] == "ZZ" 
       HELP(' ',1,'Pna25009') //-- Refeicao com Tipo 'ZZ' Reservado ao Sistema.	Nao pode... 
       lRet	:=	.F.	
    Endif    
Endif

Return lRet



/*/


Ŀ
Funo    pn250TudOk Autor  Mauricio MR            Data  20.07.01 
Ĵ
Descrio                                                             
Ĵ
 Uso       Generico                                                   
ٱ

/*/
Function pn250TudOk(o)

Local lRet      := 	.T.   
//Realiza as Consistencias sobre todas as Linhas
lRet:=fConsiste(.F.)
Return lRet 

/*/


Ŀ
Funo    fConsiste  Autor  Mauricio MR            Data  20.07.01 
Ĵ
Descrio Realiza a Consistencia das Linhas Digitadas                 
Ĵ
 Uso       Generico                                                    
Ĵ
 Parametro lConsidera =  .T. Realiza a Consistencia para a Atual       
                         linha (ver linhaOK)                          
                         .F. Realiza a Consistencia p/ Todas as Linhas
ٱ

/*/
Static Function fConsiste(lConsidera)

Local lRet      := 	.T.   

Local nX        := 	0
Local nY        := 	1
Local nW        := 	0

Local cHelp		:=	''

Local naColsCopy:= 	0
Local naHeader
Local nTotDel	:= 	0	
Local aColsCopy :=	Aclone(aCols)
Local nPosRecNo:= aScan(aHeader , { |aColumns| IsHeadRec(aColumns[2]) } )

If nPosRecNo > 0
	naHeader:= nPosRecNo - 2
else
	naHeader:= Len(aHeader)
Endif


Default	lConsidera	:=	.F.

naColsCopy		:=	Len(aColsCopy)

//-- Ordena os Horarios das Refeicoes para consistencia
aSort(aColsCopy,,, bSort )

//-- Consiste existencia de horarios em uma mesma faixa horaria
For nX := 1 To naColsCopy
	
	//nY := If(nX==1 .Or. aCols[nX-1,nUsado+1],nX,nX-1)
    //-- Atualiza Variaveis Auxiliares para Confrontar Linhas Anterior e Atual
    nY := If(nX==1 ,nX,nY)
	
	//-- Qdo a linha estiver marcada para delecao nao a valida
	If aColsCopy[nX,nUsado+1] 
	    nTotDel++   
	    
		Loop
	Endif
     
	//-- Realiza as Consistencias abaixo para a linha atual ou todas as linhas
	//-- Nao pode haver nenhum campo vazio
	For nW := 1 To naHeader
		If Empty(aColsCopy[nX,nW]) 				.AND. 	;
		    ! ASCAN(a250VazioField,ALLTRIM(aHeader[nW][2])) > 0   
		    cHelp:=aHeader[nW][1]
   			Help( ' ' , 1 , 'NVAZIO' , , OemToAnsi( cHelp ),5,0)
			lRet := .F.
			Exit
		Endif
	Next nW 
    
    If !lRet
       Exit
    Endif   
    
	//-- Nao Permite que Tipo Refeicao diferente de "ZZ" tenha horas "Zeradas"
	If aColsCopy[nX,nPosTipoRef] <> "ZZ" 
		If Empty(aColsCopy[nX,nPosHrIn] ) .AND. 	Empty( aColsCopy[nX,nPosHrFm] )
		   cHelp:=aHeader[nPosHrIn][1]
		   Help( ' ' , 1 , 'NVAZIO' ,,  OemToAnsi( cHelp ),5,0)
		   lRet := .F.	
		   Exit
	    Endif 
	Endif
    
    If ( nPosRelogio > 0.00 )
		If ( (aColsCopy[nX, nPosTipoRef] == 'ZZ') .AND. !Empty(aColsCopy[nX, nPosRelogio]) )
	     	cHelp := Space(01) + OEMTOANSI(STR0015) + CRLF //'O campo Relogio Para o Tipo de Refeicao "ZZ" 
			cHelp += Space(01) + OEMTOANSI(STR0016) + CRLF //'Nao Deve Ser Informado'
			Help( ' ' , 1 , OEMTOANSI(STR0017), ,cHelp, 1 , 0 )//  Atencao 
			lRet:= (.F.) 
			Exit
		Endif	
    Endif
		
	//-- Transforma Horarios em Numeros Seriais considerando uma data ficticia
	nSerHrAntI := fDhToNs(dDatabase, aColsCopy[nY,nPosHrIn])
	nSerHrAntF := fDhToNs(dDatabase, aColsCopy[nY,nPosHrFm])

	nSerHrAtuI := fDhToNs(dDatabase,	aColsCopy[nX,nPosHrIn])
	nSerHrAtuF := fDhToNs(dDatabase,	aColsCopy[nX,nPosHrFm]) 
   
	//-- Recalcula Horas se passa de um dia para outro                                                       
	//---- Trata Horario Anterior
	If	nSerHrAntF <nSerHrAntI 
		nSerHrAntF := fDhToNs(dDatabase + 1, aColsCopy[nY,nPosHrFm])
	Endif
	//---- Trata Horario Atual
	If  nSerHrAtuF < nSerHrAtuI 
	   	nSerHrAtuF := fDhToNs(dDatabase + 1, aColsCopy[nX,nPosHrFm]) 
    Endif


	//-- Implementa consistencia de horarios das refeicoes em relacao aos 
	//-- demais de horarios.    
	    
    
   	If aColsCopy[ny,nPosTipoRef] <> "ZZ"  .AND. !aColsCopy[nY,nUsado+1] 
		If nSerHrAtuI >= nSerHrAntI .And. nSerHrAtuI < nSerHrAntF .And. nX # nY ;
		    .AND. If(nPosRelogio>0.00,aColsCopy[ny,nPosRelogio] == aColsCopy[nx,nPosRelogio],.T.) 
			Help('',1,'PNA25005')
			lRet := .F.
			Exit
		ElseIf nSerHrAtuF > nSerHrAntI .And. nSerHrAtuF <= nSerHrAntF .And. nX # nY ;
	    	.AND. If(nPosRelogio>0.00,aColsCopy[ny,nPosRelogio] == aColsCopy[nx,nPosRelogio],.T.) 
			Help('',1,'PNA25005')
			lRet := .F.
			Exit
		ElseIf nSerHrAtuI >= nSerHrAntI .AND. nSerHrAtuF == nSerHrAntF .And. nX # nY ;
		    .AND. If(nPosRelogio>0.00,aColsCopy[ny,nPosRelogio] == aColsCopy[nx,nPosRelogio],.T.) 
			Help('',1,'PNA25005')
			lRet := .F.  
			Exit
		ElseIf nSerHrAtuI < nSerHrAntF .And. nX # nY ;
			.AND. If(nPosRelogio>0.00,aColsCopy[ny,nPosRelogio] == aColsCopy[nx,nPosRelogio],.T.) 
			Help('',1,'PNA25005')
			lRet	:= .F.  
			Exit
		ElseIf nSerHrAntI>=nSerHrAtuI .AND. nSerHrAntI<=nSerHrAtuF  .And. nX # nY	;
			.AND. If(nPosRelogio>0.00,aColsCopy[ny,nPosRelogio] == aColsCopy[nx,nPosRelogio],.T.) 		
			Help('',1,'PNA25005')
			lRet := .F. 
			Exit
		Endif
	 Endif
	    
    nY:=nX
Next nX

If !lConsidera
	If !Empty(nTotDel) .AND. lRet 
	    //--Se Todas as Refeicoes do Grupo foram marcadas para Delecao
	    //--Verifica se o Grupo de Refeicao esta em uso pela Tabela de Horario Padrao 
	    If nTotDel == naColsCopy 
		   lRet:=	PnVerDele( cAlias , nReg , nOpcx )
		Endif    
	Endif
Endif 

Return lRet
**********************************************      





/*

Ŀ
Funo     fCargaRef  Autor  Mauricio MR            Data  20.07.01 
Ĵ
Descrio  Carregar Array com as Descricoes dos Tipos de Refeicao      
Ĵ
Sintaxe    fCargaRef(aRef,cFil)                                        
Ĵ
Parametros aRef = Array com os Tipos de Refeicao                       
           cFil = Filial a ser Pesquisada                              
Ĵ
 Uso       Generico                                                    
ٱ

*/
Function fCargaRef( aRef, cFil)

Local aArea		:= GetArea()
Local aAreaSPM  := {}
Local cFilSPM   := ''
Local lRet      := .T.

dbSelectArea('SPM')
aAreaSPM	:= GetArea()
cFilSPM		:= IF(cFil == NIL .or. cFil # NIL .and. Len(AllTrim(cFil)) < FwGetTamFilial , cFilial , cFil )
IF !( lRet := SPM->( dbSeek( cFilSPM ) ) )
	Help( ' ',1,'PNA25001  ' )
	lRet:=.F.
EndIF

If lRet
	While (cFilSPM) == (SPM->PM_Filial)  .AND. !(SPM->(EOf()))
		aAdd( aRef , {SPM->PM_TIPOREF,SPM->PM_DESCREF,SPM->PM_VALREF})
		SPM->(dbSkip())
	Enddo
Endif

RestArea( aAreaSPM)
RestArea( aArea )

Return( lRet )    

/*


Ŀ
Funo    Pna250rdem Autor  Maurico MR             Data  20.07.01 
Ĵ
Descrio  Coloca os Refeicoes em Branco nas ultimas linhas do browse 
Ĵ
 Uso       PonA250                                                    
Ĵ
Retorno   aCols 													  
ٱ

*/
Function Pna250Ordem(aCols)

Local nX		:=	0
Local nY		:=	0
Local nW		:=	0
Local aSavCols	:=	{}
Local aColsCopy :=	{}

Local naCols	:= Len(aCols)							 
//-- Coloca Linhas em Branco nas ultimas linhas 
If naCols > 1                  

   //Identifica e Armazena Linhas em Branco para posterior uso
	For nX:=1 To naCols  
		If Empty(aCols[nX,nPosHrIn])  .Or. Empty(aCols[nX,nPosHrFm]) 
	       AADD(aSavCols,Aclone(aCols[nX])) 
	    Else
           AADD(aColsCopy,Aclone(aCols[nX])) 	       
	    Endif
	Next nX   

	//Ordena Matriz deixando as linhas DELETADAS em primeiro Lugar
	aSort(aSavCols,,, { |x,y|	x[Len(x)]	> y[Len(y)] } ) 
   
	//Ordena Horarios Preenchidos     
	aSort(aColsCopy,,, bSort )             
	
	   
	//Joga Como ultimas linhas  em Branco salvas anteriormente  
	aCols:=Aclone(aColsCopy)
	nW:=Len(aSavCols)
	For nX:=1 To nW 
	    AADD(aCols,Aclone(aSavCols[nX])) 	                 
    Next nX
    
Endif
oGet:ForceRefresh()
Return aCols


/*


Ŀ
Funo    Pna250Dtp  Autor  Maurico MR             Data  20.07.01 
Ĵ
Descrio  Alimenta a Descricao do Tipo de Refeicao					  
Ĵ
 Uso       PonA250                                                    
Ĵ
Retorno   .T.	 													  
ٱ

*/
Function Pna250Dtp()
Local cVar			:= 	&(ReadVar())
Local nElem			:=	0 
Local nTotElem		:= Len(aCols)
Local lRet			:=	.T.  
Private Inclui		:=	.F.


//--Alimenta a Descricao do Tipo de Refeicao
aCols[ n , nPosDescRef] := fDesc("SPM",cVar,"PM_DESCREF")

Return lRet       


 
/*


Ŀ
Funo     Pn250Chk  Autor  Mauricio MR            Data  21.07.01 
Ĵ
Descrio  Verifica se o CodRef a ser deletado ainda esta cadastrado  
           no arquivo de Tabela Hor. Padrao                           
Ĵ
Sintaxe    Pn250Chk()                                                 
Ĵ
Parametros                                                            
Ĵ
Retorno    .F. se o CodRef existir e .T. se o CodRef no existir      
Ĵ
 Uso       PONA250                                                    
ٱ

*/
Function fPn250Chk()

Local lRet      	:= .T.
Local cAlias    	:= Alias()
Local aArea			:= GetArea()
Local aAreaSPJ		:= SPJ->(GetArea())
Local aAreaSP1  	:= SP1->(GetArea())
Local nRecords  	:= 0
Local cArqInd   	:= ''
Local cSP1Fil   	:= xFilial('SP1')
Local cChaveInd 	:= 'PJ_FILIAL + PJ_CODREF'
Local cCond     	:= ""


If Empty(cSP1Fil)
   cCond := 'PJ_CODREF == "'+cCodRef+'"'
Else
	cCond := 'PJ_FILIAL == "'+cSP1Fil+'" .And. PJ_CODREF == "'+cCodRef+'"'
Endif


Begin Sequence
	//-- SPJ-TABELA DE HORARIO PADRAO
	nRecords := 0
	cArqInd  := CriaTrab('', .F.)

	dbSelectArea('SPJ')	
	IndRegua('SPJ', cArqInd, cChaveInd,, cCond, STR0014) // 'Consistindo SPJ...'
	Count to nRecords
	RetIndex('SPJ')
	If File(cArqInd+OrdBagExt())
		fErase(cArqInd+OrdBagExt())		
	EndIf
	If nRecords > 0
		Help(' ', 1, 'PNA25004  ')  //Grupo de Refeicao em Uso pela Tabela de Hor. Padrao....
		lRet := .F.
		Break
	EndIf	

End Sequence

RestArea(aAreaSPJ)
RestArea(aAreaSP1)

RestArea(aArea)
Return lRet

/*/

Ŀ
Funo    Pn250AVAL   Autor  Mauricio MR           Data  31.07.01 
Ĵ
Descrio Valida o codigo do Grupo de Refeicao                        
Ĵ
Sintaxe   Pn250Aval(ExpC1)                                            
Ĵ
Parametro ExpC1 - codigo do grupo de refeicao                         
Ĵ
 Uso      Pna250                                                      
ٱ

/*/
Function Pn250Aval(cCod)

Local aArea	:= 	GetArea()
Local lRet 	:=	.T.

Begin Sequence 
	If Val(cCod) <= 0
		Help("",1,"PNA25008  ")		
		lRet:= .F.
		Break
	Else
	
		dbSelectArea("SP1")
		dbSetOrder(1)
		If dbSeek(xFilial("SP1")+cCod)
			Help("",1,"PNA25002  ")
			lRet:= .F.
			Break
		EndIf
	Endif
      
End

RestArea(aArea)

Return lRet        


  



/*


Ŀ
Funo    Pna250ZZ   Autor  Maurico MR             Data  15.08.01 
Ĵ
Descrio  Nao Permite Alteracao de campo se Tipo de Refeicao "ZZ" 	  
Ĵ
 Uso       Pna250ZZ                                                   
Ĵ
Retorno   .T./.F.													  
ٱ

*/

Function Pna250ZZ()
Local lRet	:=	.T.

If aCols[n,nPosTipoRef] ==  "ZZ"
   lRet := .F.
Endif
   
Return lRet       

/*


Ŀ
Funo    fDataHora  Autor  Maurico MR             Data  15.08.01 
Ĵ
Descrio  Nao Permite Alteracao de campo se Tipo de Refeicao "ZZ" 	  
Ĵ
 Uso       fDataHora(data,horafim,horaini)                            
Ĵ
Retorno   .T./.F.													  
ٱ

*/
Static Function fDataHora(dData,nHoraF,nHoraI)
Local cTexto	:=	''                           
Local nSerIni   := 	0
Local nSerFim	:=	0

Default dData	:=	dDataBase


//-- Transforma Data e Horas em Numeros Seriais
nSerIni := fDhToNs(dData , nHoraI)
nSerFim := fDhToNs(dData , nHoraF)

//-- Caso o intervalo abrange de um dia a outro soma mais um na data da hora fim
If nSerFim<nSerIni
   nSerFim := fDhToNs(dData+1 , nHoraF)
Endif
   
//-- Gera String  
cTexto:=STR(nSerFim)+STR(nSerIni)    
Return cTexto 

/*


Ŀ
Funo    Pn250VREL  Autor  Maurico MR             Data  04.03.04 
Ĵ
Descrio  Valida Campo Relogio									 	  
Ĵ
 Uso       Pona250                                                    
Ĵ
Retorno   .T./.F.													  
ٱ

*/

Function Pn250VREL()
Local lRet	:=	.T.

lRet:= ( EXISTCPO('SP0') .or. Vazio() )
   
Return lRet  


/*
Ŀ
Funo    Pona250Locks    AutorMauricio MR          Data 09/03/2004
Ĵ
Descrio Bloqueia Lancamentos de Refeicoes							 
Ĵ
Sintaxe   <Vide parametros formais>									 
Ĵ
Parametros<Vide parametros formais>									 
Ĵ
Retorno   NIL		                                               	     
Ĵ
Observao                                                      	     
Ĵ
Uso       PONA250                                                      
*/
Static Function Pona250Locks( nOpc , cAlias, aRecnos, aKeysCode  )

Local lLocks	:= .T.
Local aRecAux	:= {}

/*
Ŀ
Se nao For Visualizacao nem Inclusao	 					   
*/
IF ( nOpc <> 2 ) 

	aEval( aRecnos , {|x| If( !Empty(x) , aADD( aRecAux , x ) , NIL ) } )

	lLocks := WhileNoLock( cAlias , aRecAux , aKeysCode  , 1 , 1 , .T. , NIL ) 

EndIF

Return( lLocks )    

/*
Ŀ
Funo     MenuDef		Autor  Luiz Gustavo      Data 29/11/2006
Ĵ
Descrio Isola opcoes de menu para que as opcoes da rotina possam    
          ser lidas pelas bibliotecas Framework da Versao 9.12 .      
Ĵ
Sintaxe   < Vide Parametros Formais >									
Ĵ
 Uso      PONA250                                                     
Ĵ
 Retorno  aRotina														
Ĵ
Parametros< Vide Parametros Formais >									
*/

Static Function MenuDef()

Local  aRotina := {      { STR0004 , "PesqBrw", 0 , 1, ,.F.},;  //"Pesquisar"
                         { STR0005 , "pn250atu", 0 , 2},;  //"Visualizar"
	                     { STR0006 , "pn250Atu", 0 , 3},;  //"Incluir"   
	                     { STR0007 , "pn250Atu", 0 , 4},;  //"Alterar"  
	                     { STR0008 , "pn250Atu", 0 , 5} }  //"Excluir"  
	                     
Return aRotina