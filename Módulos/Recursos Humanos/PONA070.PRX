#INCLUDE "PONA070.CH"
#INCLUDE "PROTHEUS.CH"
#INCLUDE "PONCALEN.CH"

Static lPort1510 	:= Port1510() 	//Verifica se Portaria 1510/2009 esta em vigor. 
Static lCpoCCT		:= NIL
Static lCpoPer		:= NIL
/*


Ŀ
Funo     Pona070   Autor  Wiliam R. Bertoncini   Data  23/02/96 
Ĵ
Descrio  Cadastro de Tipos de Hora Extra                            
Ĵ
Sintaxe    Pona070                                                    
Ĵ
Parametros                                                            
Ĵ
 Uso       Generico                                                   
Ĵ
         ATUALIZACOES SOFRIDAS DESDE A CONSTRUAO INICIAL.             
Ĵ
Programador  Data    BOPS   Motivo da Alteracao                     
Ĵ
Leandro Dr. 14/04/14      Retirada de ajustes, database e FieldPos  
                          que nao serao utilizados na P12.		  
ٱ

*/
Function Pona070(aAutoCab, xAutoItens, xOpcAuto)

Local aArea			:= GetArea()
Local bFilterOk		:= { || .F. }
Local cFiltraRh		:= ""
Local nPos			:= 0
Local nPosTurno		:= 0
Local nPosTipo		:= 0

Private aIndexSP4	:= {}
Private bSeekWhile	:= { ||  SP4->P4_FILIAL+SP4->P4_TURNO+SP4->P4_TIPO }
Private cCadastro	:= OemToAnsi(STR0004 )	// "Tipos de Hora Extra"

DEFAULT aAutoCab	:= {}
DEFAULT xAutoItens	:= {}
DEFAULT xOpcAuto	:= 0

Private l070Auto	:= !Empty(aAutoCab) .And. xOpcAuto > 0
Private aAutoItens	:= xAutoItens
Private nOpcAuto	:= xOpcAuto

lCpoCCT := SP4->(ColumnPos("P4_CODCCT") > 0)
/*
Ŀ
 So Executa se os Modos de Acesso dos Arquivos Relacionados es
 tiverm OK 												   
*/
IF ValidArqPon()
	
	Private bFiltraBrw	:= { || NIL }
	
	/*
	Ŀ
	 Define Array contendo as Rotinas a executar do programa      
	 ----------- Elementos contidos por dimensao ------------     
	 1. Nome a aparecer no cabecalho                              
	 2. Nome da Rotina associada                                  
	 3. Usado pela rotina                                         
	 4. Tipo de Transao a ser efetuada                          
	    1 - Pesquisa e Posiciona em um Banco de Dados             
	    2 - Simplesmente Mostra os Campos                         
	    3 - Inclui registros no Bancos de Dados                   
	    4 - Altera o registro corrente                            
	    5 - Remove o registro corrente do Banco de Dados          
	*/
	Private aRotina := MenuDef()
	
	Private aHeader := {}
	Private cTnoHe  := Space( Len( SP4->P4_TURNO ) )
	Private cTipoHE := Space( Len( SP4->P4_TIPO  ) )
	Private cPerApu := Space(1)
	Private nTolHE  := 0
	
	/*
	Ŀ
	 Inicializa o filtro utilizando a funcao FilBrowse                      
	*/
	cFiltraRh	:= CHKRH( "PONA070" , "SP4" , "1" )
	If lCpoCCT
		cFiltraRh += If(Empty(cFiltraRh),"" , " .And. ")
		cFiltraRh += "Empty(P4_CODCCT)"
	EndIf
	bFiltraBrw	:= { || FilBrowse( "SP4" , @aIndexSP4 , @cFiltraRh ) }
	Eval( bFiltraBrw )
	
	If !l070Auto
		mBrowse( 6, 1, 22, 75, "SP4" )
	Else
		nPos := Ascan(aRotina, {|x| x[4] == nOpcAuto})
		If nPos != 0
			
			nPosTurno := Ascan(aAutoCab, {|x| Alltrim(x[1]) $ "P4_TURNO" })
			nPosTipo := Ascan(aAutoCab, {|x| Alltrim(x[1]) $ "P4_TIPO"})
			
			// Perodo de apurao
			If (nPosPer := Ascan(aAutoCab, {|x| Alltrim(x[1]) == "P4_PERHEXT"})) > 0
				cPerApu := aAutoCab[nPosPer][2]
			EndIf
			
			// Tolerncia
			If (nPosTol := Ascan(aAutoCab, {|x| Alltrim(x[1]) == "P4_TOLHEPE"})) > 0
				nTolHE := aAutoCab[nPosTol][2]
			EndIf
			
			If nPosTurno > 0 .And. nPosTipo > 0 
				cTnoHe := aAutoCab[nPosTurno][2]
				cTipoHE := aAutoCab[nPosTipo][2]
				bBlock := &( "{ |x, y, z| " + aRotina[ nPos, 2 ] + "(x, y, z) }" )
				Eval( bBlock, Alias(), SP4->(Recno()), nOpcAuto)
			Else
				// "Turno ou Tipo da Hora extra no informados"
				Help(,, "Help",, STR0028, 1, 0,,,,,.T., {STR0029}) // "Para executar a rotina automtica  necessrio informar os campos P4_TURNO e P4_TIPO"
			EndIf
			
		EndIf
	EndIf
	
	/*
	Ŀ
	 Deleta o filtro utilizando a funcao FilBrowse                     	 
	*/
	EndFilBrw("SP4",aIndexSP4)    
	
EndIF

RestArea( aArea )
	
Return( NIL )

/*


Ŀ
Funo    Pona070Vis Autor  J. Ricardo             Data  06.03.96 
Ĵ
Descrio Programa de visualizacao tipos de hora extra                
Ĵ
Sintaxe   Pona070Vis(ExpC1,ExpN1,ExpN2)                               
Ĵ
ParametrosExpC1 = Alias do arquivo                                    
          ExpN1 = Numero do registro                                  
          ExpN2 = Numero da opcao selecionada                         
Ĵ
Uso       pona070                                                     
ٱ

*/
Function Pona070Vis( cAlias , nReg , nOpcx )

Local aAdvSize		:= {}
Local aInfoAdvSize	:= {}
Local aObjSize		:= {}
Local aObjCoords	:= {}

Local aAdv1Size		:= {}
Local aInfo1AdvSize	:= {}
Local aObj1Size		:= {}
Local aObj1Coords	:= {}

Local bSet15		:= { || .T. }
Local bSet24		:= { || .T. }
Local cDesc			:= Space(20)	
Local nCnt			:= 0
Local nSavRec		:= SP4->( RecNo() )
Local oDlg
Local oGet
Local oFont
Local oGroup
Local aComboPer		:= {}

lCpoPer := If(lCpoPer != NIL, lCpoPer, SP4->(ColumnPos("P4_PERHEXT") > 0))

cTnoHE  := SP4->P4_TURNO
cTipoHE := SP4->P4_TIPO

If lCpoPer
	cPerApu  := SP4->P4_PERHEXT
	nTolHE := SP4->P4_TOLHEPE
	aComboPer := Sx3Box2Arr( "P4_PERHEXT" )
EndIf 

If !ChkVazio(cAlias)
	Return(.F.)
Endif

fTipoExtra( cTipoHE , @cDesc , .F. )

//Ŀ
// Monta a entrada de dados do arquivo                          
//
Private aHeader[0]
Private nUsado := 0

//-- Verifica se existem horas extra cadastradas.
If !dbSeek(xFilial('SP4')+cTnoHE+cTipoHE, .F.)
	Help(' ',1,'A070SLANC')
	Return(.F.)
EndIf

//-- Define a quantidade de registros
If !lCpoCCT
	nCnt := FDefQtdReg(cAlias,(xFilial("SP4")+cTnoHE+cTipoHE),"SP4->P4_FILIAL+SP4->P4_Turno+SP4->P4_Tipo == '"+xFilial("SP4")+cTnoHE+cTipoHE+"'")
Else
	nCnt := FDefQtdReg(cAlias, ;
						(xFilial("SP4") + cTnoHE + cTipoHE), ; // Chave para busca
						"SP4->P4_FILIAL + SP4->P4_TURNO + SP4->P4_TIPO == '" + xFilial("SP4") + cTnoHE + cTipoHE + "'", ; // Condio do while
						"!Empty(SP4->P4_CODCCT)") // Condio para skip
EndIf

If nCnt == 0
	Help(' ',1,'A070SLANC')
	Return(.F.)
Endif

Private aCols := {}

//Monta aHeader e aCols com campos do WT
Pona070MntGd(cAlias,nOpcx,@aHeader,@aCols)

nUsado := Len(aHeader)

nOpca := 0

/*
Ŀ
 Monta as Dimensoes dos Objetos         					   
*/
aAdvSize		:= MsAdvSize()
aInfoAdvSize	:= { aAdvSize[1] , aAdvSize[2] , aAdvSize[3] , aAdvSize[4] , 5 , 5 }
aAdd( aObjCoords , { 000 , 033 , .T. , .F. } ) 		//1-Cabecalho 
aAdd( aObjCoords , { 000 , 000 , .T. , .T. } )  		//2-MsGetDados
aObjSize		:= MsObjSize( aInfoAdvSize , aObjCoords )

//Divisao 1. linha - Cabecalho
aObj1Coords := {}
aAdv1Size    := aClone(aObjSize[1])

aInfo1AdvSize    := { aAdv1Size[2] , aAdv1Size[1] , aAdv1Size[4] , aAdv1Size[3] , 2 , 2 }
aAdd( aObj1Coords , { 060 , 000 , .F. , .T. } )	//1-Turno
aAdd( aObj1Coords , { 060 , 000 , .F. , .T. } )	//2-Tipo
aAdd( aObj1Coords , { 100 , 000 , .T. , .T. } )	//3-Descricao
If lCpoPer
	aAdd( aObj1Coords , { 100 , 000 , .T. , .T. } )	//4-Perodo de apurao
	aAdd( aObj1Coords , { 060 , 000 , .T. , .T. } )	//5-Tolerncia
EndIf
aObj1Size := MsObjSize( aInfo1AdvSize , aObj1Coords,,.T.)

SetaPilha()
	DEFINE FONT oFont NAME "Arial" SIZE 0,-11 BOLD
	DEFINE MSDIALOG oDlg TITLE OemToAnsi(STR0016) From aAdvSize[7],0 TO aAdvSize[6],aAdvSize[5] OF oMainWnd PIXEL	// 'Tipos de Hora Extra'
	
	@ aObj1Size[1,1] , aObj1Size[1,2] GROUP oGroup TO aObj1Size[1,3] , aObj1Size[1,4]	LABEL OemToAnsi(STR0017) OF oDlg PIXEL	// "Turno:"
	oGroup:oFont:= oFont
	@ aObj1Size[2,1] , aObj1Size[2,2] GROUP oGroup TO aObj1Size[2,3] , aObj1Size[2,4]	LABEL OemToAnsi(STR0018) OF oDlg PIXEL	// 'Tipo:'
	oGroup:oFont:= oFont
	@ aObj1Size[3,1] , aObj1Size[3,2] GROUP oGroup TO aObj1Size[3,3] , aObj1Size[3,4]	LABEL OemToAnsi(STR0025) OF oDlg PIXEL	// "Descrio:"
	oGroup:oFont:= oFont
	
	If lCpoPer
		@ aObj1Size[4,1] , aObj1Size[4,2] GROUP oGroup TO aObj1Size[4,3] , aObj1Size[4,4]	LABEL OemToAnsi(STR0030) OF oDlg PIXEL	// Perodo de Apurao
		oGroup:oFont:= oFont
		@ aObj1Size[5,1] , aObj1Size[5,2] GROUP oGroup TO aObj1Size[5,3] , aObj1Size[5,4]	LABEL OemToAnsi(STR0031) OF oDlg PIXEL	// Tolerncia
		oGroup:oFont:= oFont
	EndIf
	
	@ aObj1Size[1,1]+10 , aObj1Size[1,2]+5	SAY cTnoHe	PICTURE PesqPict("SP4","P4_TURNO")	SIZE 050,10 OF oDlg PIXEL FONT oFont
	@ aObj1Size[2,1]+10 , aObj1Size[2,2]+5	SAY cTipoHE	PICTURE PesqPict("SP4","P4_TIPO")	SIZE 146,10 OF oDlg PIXEL FONT oFont
	@ aObj1Size[3,1]+10 , aObj1Size[3,2]+5	SAY cDesc	PICTURE "@!"						SIZE 146,10 OF oDlg PIXEL FONT oFont
	
	If lCpoPer
		@ aObj1Size[4,1]+10, aObj1Size[4,2]+5 COMBOBOX cPerApu ITEMS aComboPer VALID Pertence(" DSQM") SIZE 146,10 WHEN .F. OF oDlg PIXEL FONT oFont
		@ aObj1Size[5,1]+10, aObj1Size[5,2]+5 MSGET nTolHE PICTURE PesqPict("SP4","P4_TOLHEPE") SIZE 050,10 WHEN .F. OF oDlg PIXEL FONT oFont HASBUTTON
	EndIf
	
	oGet := MSGetDados():New(aObjSize[2,1],aObjSize[2,2],aObjSize[2,3],aObjSize[2,4],nOpcx,,,"",.F.)
	
	bSet15 := { || nopca := 1 , oDlg:End() }
	bSet24 := { || oDlg:End() }
	
	ACTIVATE MSDIALOG oDlg ON INIT ( EnchoiceBar( oDlg , bSet15 , bSet24 )) CENTERED
	
SetaPilha()	
	
//Ŀ
// Restaura a integridade da janela                             
//
DbSelectArea('SR6')
DbGoTo(nSavRec)

Return Nil

/*


Ŀ
Funo    Pona070Inc Autor  J. Ricardo             Data  06.03.96 
Ĵ
Descrio Programa de Inclusao dos tipos de hora extra                
Ĵ
Sintaxe   Pona070Inc(ExpC1,ExpN1,ExpN2)                               
Ĵ
ParametrosExpC1 = Alias do arquivo                                    
          ExpN1 = Numero do registro                                  
          ExpN2 = Numero da opcao selecionada                         
Ĵ
Uso       pona070                                                     
ٱ

*/
Function Pona070Inc( cAlias , nReg , nOpcx )

Local aAdvSize		:= {}
Local aInfoAdvSize	:= {}
Local aObjSize		:= {}
Local aObjCoords	:= {}

Local aAdv1Size		:= {}
Local aInfo1AdvSize	:= {}
Local aObj1Size		:= {}
Local aObj1Coords	:= {}

Local aCombo		:= Sx3Box2Arr( "P4_TIPO" )
Local aComboPer		:= {}
Local bSet15		:= { || .T. }
Local bSet24		:= { || .T. }
Local nCnt			:= 0
Local nSavRec		:= SP4->(RecNo())
Local oDlg
Local oGet
Local oFont
Local oGroup

lCpoPer := If(lCpoPer != NIL, lCpoPer, SP4->(ColumnPos("P4_PERHEXT") > 0))

If lCpoPer
	aComboPer := Sx3Box2Arr( "P4_PERHEXT" )
EndIf

If !l070Auto
	cTnoHe  := Space(Len(SP4->P4_Turno))
	cTipoHE := Space(Len(SP4->P4_Tipo))
	cPerApu := Space(1)
	nTolHE	:= 0
EndIf

//Ŀ
// Monta a entrada de dados do arquivo                          
//
Private aHeader[0]
Private nUsado  := 0

//-- Define a quantidade de registros ( Inclusao = 1 )
nCnt := 1

Private aCols := {}

//Monta aHeader e aCols com campos do WT
Pona070MntGd(cAlias,nOpcx,@aHeader,@aCols)

nUsado := Len(aHeader)

nOpca := 0

/*
Ŀ
 Monta as Dimensoes dos Objetos         					   
*/

aAdvSize		:= MsAdvSize()
aInfoAdvSize	:= { aAdvSize[1] , aAdvSize[2] , aAdvSize[3] , aAdvSize[4] , 5 , 5 }
aAdd( aObjCoords , { 000 , 032 , .T. , .F. } ) 		//1-Cabecalho 
aAdd( aObjCoords , { 000 , 000 , .T. , .T. } )  	//2-MsGetDados
aObjSize		:= MsObjSize( aInfoAdvSize , aObjCoords )

//Divisao 1. linha - Cabecalho
aObj1Coords := {}
aAdv1Size    := aClone(aObjSize[1])

aInfo1AdvSize    := { aAdv1Size[2] , aAdv1Size[1] , aAdv1Size[4] , aAdv1Size[3] , 2 , 2 }
aAdd( aObj1Coords , { 060 , 000 , .F. , .T. } )	//1-Turno
aAdd( aObj1Coords , { 100 , 000 , .T. , .T. } )	//2-Tipo
If lCpoPer
	aAdd( aObj1Coords , { 100 , 000 , .T. , .T. } )	//3-Perodo de Apurao
	aAdd( aObj1Coords , { 060 , 000 , .T. , .T. } )	//4-Tolerncia
EndIf
aObj1Size := MsObjSize( aInfo1AdvSize , aObj1Coords,,.T.)


If !l070Auto
	SetaPilha()
		DEFINE FONT oFont NAME "Arial" SIZE 0,-11 BOLD
		DEFINE MSDIALOG oDlg TITLE OemToAnsi(STR0016) From aAdvSize[7],0 TO aAdvSize[6],aAdvSize[5] 					OF oMainWnd PIXEL // "Incluir - Arredondamentos"
		
		@ aObj1Size[1,1] , aObj1Size[1,2] GROUP oGroup TO aObj1Size[1,3] , aObj1Size[1,4]	LABEL OemToAnsi(STR0017)	OF oDlg PIXEL	// "Turno:"
		oGroup:oFont:= oFont
		@ aObj1Size[2,1] , aObj1Size[2,2] GROUP oGroup TO aObj1Size[2,3] , aObj1Size[2,4]	LABEL OemToAnsi(STR0018)	OF oDlg PIXEL	// 'Tipo:'
		oGroup:oFont:= oFont
		If lCpoPer
			@ aObj1Size[3,1] , aObj1Size[3,2] GROUP oGroup TO aObj1Size[3,3] , aObj1Size[3,4]	LABEL OemToAnsi(STR0030)	OF oDlg PIXEL	// "Perodo Para Escalonamento"
			oGroup:oFont:= oFont
			@ aObj1Size[4,1] , aObj1Size[4,2] GROUP oGroup TO aObj1Size[4,3] , aObj1Size[4,4]	LABEL OemToAnsi(STR0031)	OF oDlg PIXEL	// "Tolerncia por Perodo"
			oGroup:oFont:= oFont
		EndIf
		
		@ aObj1Size[1,1]+10, aObj1Size[1,2]+5	MSGET cTnoHE F3 "SR6" 				VALID ( fTno070(cTnoHe) .and. CheckSX3("P4_TURNO") ) SIZE 050,10 OF oDlg PIXEL FONT oFont HASBUTTON
		@ aObj1Size[2,1]+10, aObj1Size[2,2]+5	COMBOBOX cTipoHE ITEMS aCombo 		VALID ( ExistTipo( Subst( cTipoHE , 1 , 1 ) ) .and. fTipoExtra( Subst( cTipoHE , 1 , 1 ) ) ) SIZE 146,10 OF oDlg PIXEL FONT oFont
		If lCpoPer
			@ aObj1Size[3,1]+10, aObj1Size[3,2]+5	COMBOBOX oGetPer VAR cPerApu ITEMS aComboPer VALID Vazio() .Or. Pertence("SQM") ON CHANGE If(Empty(cPerApu), nTolHE := 0,) SIZE 146,10 OF oDlg PIXEL FONT oFont
			//Help do campo
			// "Define o perodo para escalonamento das horas extras no clculo mensal."
			// "Caso no seja informado ser utilizado o perodo definido na regra de apontamento."
			oGetPer:bHelp := {|| ShowHelpCpo("P4_PERHEXT", {STR0032 + CRLF + STR0033}, 2, {'Vazio() .Or. Pertence("SQM")'}, 2)}
			@ aObj1Size[4,1]+10, aObj1Size[4,2]+5	MSGET oGetTol VAR nTolHE PICTURE "@E 999.99" VALID Positivo() WHEN !Empty(cPerApu)  SIZE 050,10 OF oDlg PIXEL FONT oFont HASBUTTON
			//Help do campo 
			//"Tolerncia utilizada no clculo mensal das horas extras, aplicada de acordo com o perodo selecionado."
			oGetTol:bHelp := {|| ShowHelpCpo("P4_TOLHEPE", {STR0034}, 2, {"Positivo()"}, 2)}
		EndIf
		
		oGet := MSGetDados():New(aObjSize[2,1],aObjSize[2,2],aObjSize[2,3],aObjSize[2,4],nOpcx,'Pn070LinOk' ,'Pn070TudOk' ,'',.T.)
		
		bSet15	:= {|| IF(oGet:TudoOk(), If( Pona070Locks( nOpcX , cAlias, {}, {cTnoHE + cTipoHE } ),( nOpca := 1 , oDlg:End() ), Nil) , ( nOpca := 0 , .T. ) ) }
		bSet24	:= {|| nOpca := 0 , oDlg:End() }
		
		ACTIVATE MSDIALOG oDlg ON INIT ( EnchoiceBar(oDlg, bSet15  , bSet24 )) VALID ( ExistTipo( Subst( cTipoHE , 1 , 1 ) ) .and. fTipoExtra( Subst( cTipoHE , 1 , 1 ) ) ) CENTERED
		
	SetaPilha()
Else
	If MsGetDAuto(aAutoItens, "Pn070LinOk", "Pn070TudOk",, nOpcx)
		nOpcA := 1
	EndIf
EndIf

If nOpcA == 1
	Begin Transaction
		Pn070Grava(cAlias)
		//-- Processa Gatilhos
		EvalTrigger()
	End Transaction
Endif

FreeLocks( 'SP4' , NIL , .T. )

//Ŀ
// Restaura a integridade da janela                             
//
DbSelectArea(cAlias)
DbGoTo(nSavRec)
Return Nil

/*


Ŀ
Funo    Pona070Alt Autor  J. Ricardo             Data  06.03.96 
Ĵ
Descrio Programa de Alteracao dos tipos de hora extra               
Ĵ
Sintaxe   Pona070Alt(ExpC1,ExpN1,ExpN2)                               
Ĵ
ParametrosExpC1 = Alias do arquivo                                    
          ExpN1 = Numero do registro                                  
          ExpN2 = Numero da opcao selecionada                         
Ĵ
Uso       pona070                                                     
ٱ

*/
Function Pona070Alt( cAlias, nReg, nOpcx )

Local aAdvSize		:= {}
Local aInfoAdvSize	:= {}
Local aObjSize		:= {}
Local aObjCoords	:= {}

Local aAdv1Size		:= {}
Local aInfo1AdvSize	:= {}
Local aObj1Size		:= {}
Local aObj1Coords	:= {}

Local aRegAltera	:= {}
Local bSet15		:= { || .T. }
Local bSet24		:= { || .T. }
Local cDesc		 	:= Space( 20 )
Local nX			:= 0
Local nCnt       	:= 0
Local nSavRec    	:= SP4->(RecNo())
Local oDlg
Local oGet
Local oFont
Local oGroup
Local aComboPer		:= {}

Private cPerAnt		:= ""
Private nTolAnt		:= 0

lCpoPer := If(lCpoPer != NIL, lCpoPer, SP4->(ColumnPos("P4_PERHEXT") > 0))

If !l070Auto
	Private cTipoHE := SP4->P4_Tipo
	Private cTnoHE  := SP4->P4_Turno
	If lCpoPer
		cPerAnt := cPerApu := SP4->P4_PERHEXT
		nTolAnt := nTolHE := SP4->P4_TOLHEPE
		aComboPer := Sx3Box2Arr( "P4_PERHEXT" )
	EndIf
EndIf

//-- Verifica se o arquivo esta vazio

If !ChkVazio('SP4')
	
	Return(.F.)
	
Endif

If !( Pona070Locks( nOpcX , cAlias, {}, {cTnoHE + cTipoHE } ) )
	
	Return(.F.)
	
Endif

fTipoExtra( cTipoHE , @cDesc , .F. )

//Ŀ
// Monta a entrada de dados do arquivo                          
//
Private aHeader[0]
Private nUsado   := 0
Private aColsAnt := {}

//-- Define a quantidade de registros
If !lCpoCCT
	nCnt := FDefQtdReg(cAlias,(xFilial("SP4")+cTnoHE+cTipoHE),"SP4->P4_FILIAL+SP4->P4_Turno+SP4->P4_Tipo == '"+xFilial("SP4")+cTnoHE+cTipoHE+"'")
Else 
	nCnt := FDefQtdReg(cAlias, ;
						(xFilial("SP4") + cTnoHE + cTipoHE), ; // Chave para busca
						"SP4->P4_FILIAL + SP4->P4_TURNO + SP4->P4_TIPO == '" + xFilial("SP4") + cTnoHE + cTipoHE + "'", ; // Condio do while
						"!Empty(SP4->P4_CODCCT)") // Condio para skip
EndIf

If nCnt == 0
	Help(' ',1,'A070SLANC')
	Return(.F.)
Endif


//-- Cursor Underline.
SetCursor(1)

Private aCols := {}

//Monta aHeader e aCols com campos do WT
Pona070MntGd(cAlias,nOpcx,@aHeader,@aCols)

//-- Faz uma copia do vetor Acols
aColsAnt := Aclone(aCols)

nUsado := Len(aHeader)

For nX := 1 To nCnt
	Aadd(aRegAltera,aCols[nX,nUsado])
Next nX

nOpca := 0

/*
Ŀ
 Monta as Dimensoes dos Objetos         					   
*/
aAdvSize		:= MsAdvSize()
aInfoAdvSize	:= { aAdvSize[1] , aAdvSize[2] , aAdvSize[3] , aAdvSize[4] , 5 , 5 }
aAdd( aObjCoords , { 000 , 032 , .T. , .F. } ) 		//1-Cabecalho 
aAdd( aObjCoords , { 000 , 000 , .T. , .T. } )  	//2-MsGetDados
aObjSize		:= MsObjSize( aInfoAdvSize , aObjCoords )

//Divisao 1. linha - Cabecalho
aObj1Coords := {}
aAdv1Size    := aClone(aObjSize[1])

aInfo1AdvSize    := { aAdv1Size[2] , aAdv1Size[1] , aAdv1Size[4] , aAdv1Size[3] , 2 , 2 }
aAdd( aObj1Coords , { 060 , 000 , .F. , .T. } )	//1-Turno
aAdd( aObj1Coords , { 060 , 000 , .F. , .T. } )	//2-Tipo
aAdd( aObj1Coords , { 100 , 000 , .T. , .T. } )	//3-Descricao
If lCpoPer
	aAdd( aObj1Coords , { 100 , 000 , .T. , .T. } )	//3-Perodo de Apurao
	aAdd( aObj1Coords , { 060 , 000 , .T. , .T. } )	//4-Tolerncia
EndIf
aObj1Size := MsObjSize( aInfo1AdvSize , aObj1Coords,,.T.)

If !l070Auto
	SetaPilha()
		DEFINE FONT oFont NAME "Arial" SIZE 0,-11 BOLD
		DEFINE MSDIALOG oDlg TITLE OemToAnsi(STR0016) From aAdvSize[7],0 TO aAdvSize[6],aAdvSize[5] OF oMainWnd PIXEL	// 'Tipos de Hora Extra'
		
		@ aObj1Size[1,1] , aObj1Size[1,2] GROUP oGroup TO aObj1Size[1,3], aObj1Size[1,4]		LABEL OemToAnsi(STR0017) OF oDlg PIXEL	// "Turno:"
		oGroup:oFont:= oFont
		@ aObj1Size[2,1] , aObj1Size[2,2] GROUP oGroup TO aObj1Size[2,3], aObj1Size[2,4]		LABEL OemToAnsi(STR0018) OF oDlg PIXEL	// 'Tipo:'
		oGroup:oFont:= oFont
		@ aObj1Size[3,1] , aObj1Size[3,2] GROUP oGroup TO aObj1Size[3,3], aObj1Size[3,4]		LABEL OemToAnsi(STR0025) OF oDlg PIXEL	// "Descrio:"
		oGroup:oFont:= oFont
		
		If lCpoPer
			@ aObj1Size[4,1] , aObj1Size[4,2] GROUP oGroup TO aObj1Size[4,3] , aObj1Size[4,4]	LABEL OemToAnsi(STR0030)	OF oDlg PIXEL	// Perodo de Apurao
			oGroup:oFont:= oFont
			@ aObj1Size[5,1] , aObj1Size[5,2] GROUP oGroup TO aObj1Size[5,3] , aObj1Size[5,4]	LABEL OemToAnsi(STR0031)	OF oDlg PIXEL	// "Tolerncia por Perodo"
			oGroup:oFont:= oFont
		EndIf 
		
		@ aObj1Size[1,1]+10 , aObj1Size[1,2]+5	SAY cTnoHe	PICTURE PesqPict("SP4","P4_TURNO")	SIZE 050,10 OF oDlg PIXEL FONT oFont
		@ aObj1Size[2,1]+10 , aObj1Size[2,2]+5	SAY cTipoHE	PICTURE PesqPict("SP4","P4_TIPO")	SIZE 146,10 OF oDlg PIXEL FONT oFont
		@ aObj1Size[3,1]+10 , aObj1Size[3,2]+5	SAY cDesc		PICTURE "@!"					SIZE 146,10 OF oDlg PIXEL FONT oFont
		
		If lCpoPer
			@ aObj1Size[4,1]+10, aObj1Size[4,2]+5	COMBOBOX oGetPer VAR cPerApu ITEMS aComboPer VALID Vazio() .Or. Pertence("SQM") ON CHANGE If(Empty(cPerApu), nTolHE := 0,) SIZE 146,10 OF oDlg PIXEL FONT oFont
			//Help do campo
			// "Define o perodo para escalonamento das horas extras no clculo mensal."
			// "Caso no seja informado ser utilizado o perodo definido na regra de apontamento."
			oGetPer:bHelp := {|| ShowHelpCpo("P4_PERHEXT", {STR0032 + CRLF + STR0033}, 2, {'Vazio() .Or. Pertence("SQM")'}, 2)}
			@ aObj1Size[5,1]+10, aObj1Size[5,2]+5	MSGET oGetTol VAR nTolHE PICTURE "@E 999.99" VALID Positivo() WHEN !Empty(cPerApu)  SIZE 050,10 OF oDlg PIXEL FONT oFont HASBUTTON
			//Help do campo 
			//"Tolerncia utilizada no clculo mensal das horas extras, aplicada de acordo com o perodo selecionado."
			oGetTol:bHelp := {|| ShowHelpCpo("P4_TOLHEPE", {STR0034}, 2, {"Positivo()"}, 2)}
		EndIf
		
		oGet := MSGetDados():New(aObjSize[2,1],aObjSize[2,2],aObjSize[2,3],aObjSize[2,4],nOpcx,'Pn070LinOk' ,'Pn070TudOk' ,'',.T.)
		
		bSet15 := { || IF( oGet:TudoOk() , ( nOpca := 1 , oDlg:End() ) , ( nOpca := 0 , .T. ) ) }
		bSet24 := { || nOpca := 0 , oDlg:End() }
		
		ACTIVATE MSDIALOG oDlg ON INIT ( EnchoiceBar( oDlg , bSet15 , bSet24 )) CENTERED
		
	SetaPilha()
Else
	If MsGetDAuto(aAutoItens, "Pn070LinOk", "Pn070TudOk",, nOpcx)
		nOpcA := 1
	EndIf
EndIf


If nOpcA == 1
	Begin Transaction
		Pn070Grava(cAlias,aRegAltera)
		//-- Processa Gatilhos
		EvalTrigger()
	End Transaction
Endif

FreeLocks( 'SP4' , NIL , .T. )

//Ŀ
// Restaura a integridade da janela                             
//
DbSelectArea(cAlias)
DbGoTo(nSavRec)
Return Nil

/*


Ŀ
Funo    Pona070Del Autor  J. Ricardo             Data  06.03.96 
Ĵ
Descrio Programa de Delecao   dos tipos de hora extra               
Ĵ
Sintaxe   Pona070Del(ExpC1,ExpN1,ExpN2)                               
Ĵ
ParametrosExpC1 = Alias do arquivo                                    
          ExpN1 = Numero do registro                                  
          ExpN2 = Numero da opcao selecionada                         
Ĵ
Uso       pona070                                                     
ٱ

*/
Function Pona070Del( cAlias, nReg, nOpcx )

Local aAdvSize		:= {}
Local aInfoAdvSize	:= {}
Local aObjSize		:= {}
Local aObjCoords	:= {}
Local bSet15		:= { || .T. }
Local bSet24		:= { || .T. }
Local cDesc		 	:= Space( 20 )
Local cMsgErr		:= ""
Local nCnt			:= 0
Local nSavRec		:= SP4->(RecNo())
Local oDlg
Local oGet
Local oFont
Local oGroup
Local aComboPer		:= {}

lCpoPer := If(lCpoPer != NIL, lCpoPer, SP4->(ColumnPos("P4_PERHEXT") > 0))

If !l070Auto
	Private cTipoHE := SP4->P4_Tipo
	Private cTnoHE  := SP4->P4_Turno
	If lCpoPer
		cPerApu := SP4->P4_PERHEXT
		nTolHE := SP4->P4_TOLHEPE
		aComboPer := Sx3Box2Arr( "P4_PERHEXT" )
	EndIf
EndIf

If !ChkVazio(cAlias)
	Return(.F.)
Endif

If !( Pona070Locks( nOpcX , cAlias, {}, {cTnoHE + cTipoHE } ) )
	Return(.F.)
Endif

fTipoExtra( cTipoHE, @cDesc, .F. )

//Ŀ
// Monta a entrada de dados do arquivo                          
//
Private aHeader[0]
Private nUsado := 0

//-- Define a quantidade de registros
If !lCpoCCT
	nCnt := FDefQtdReg(cAlias,(xFilial("SP4")+cTnoHE+cTipoHE),"SP4->P4_FILIAL+SP4->P4_Turno+SP4->P4_Tipo == '"+xFilial("SP4")+cTnoHE+cTipoHE+"'")
Else
	nCnt := FDefQtdReg(cAlias, ;
						(xFilial("SP4") + cTnoHE + cTipoHE), ; // Chave para busca
						"SP4->P4_FILIAL + SP4->P4_TURNO + SP4->P4_TIPO == '" + xFilial("SP4") + cTnoHE + cTipoHE + "'", ; // Condio do while
						"!Empty(SP4->P4_CODCCT)") // Condio para skip
EndIf

If nCnt == 0
	Help(' ',1,'A070SLANC')
	Return(.F.)
Endif

Private aCols := {}

//Monta aHeader e aCols com campos do WT
Pona070MntGd(cAlias,nOpcx,@aHeader,@aCols)

nUsado := Len(aHeader)

nOpca := 0

/*
Ŀ
 Monta as Dimensoes dos Objetos         					   
*/

aAdvSize		:= MsAdvSize()
aInfoAdvSize	:= { aAdvSize[1] , aAdvSize[2] , aAdvSize[3] , aAdvSize[4] , 5 , 5 }
aAdd( aObjCoords , { 000 , 033 , .T. , .F. } ) 			//1-Cabecalho 
aAdd( aObjCoords , { 000 , 000 , .T. , .T. } )  		//2-MsGetDados
aObjSize		:= MsObjSize( aInfoAdvSize , aObjCoords )

//Divisao 1. linha - Cabecalho
aObj1Coords := {}
aAdv1Size    := aClone(aObjSize[1])

aInfo1AdvSize    := { aAdv1Size[2] , aAdv1Size[1] , aAdv1Size[4] , aAdv1Size[3] , 2 , 2 }
aAdd( aObj1Coords , { 060 , 000 , .F. , .T. } )	//1-Turno
aAdd( aObj1Coords , { 060 , 000 , .F. , .T. } )	//2-Tipo
aAdd( aObj1Coords , { 100 , 000 , .T. , .T. } )	//3-Descricao
If lCpoPer
	aAdd( aObj1Coords , { 100 , 000 , .T. , .T. } )	//4-Perodo de apurao
	aAdd( aObj1Coords , { 060 , 000 , .T. , .T. } )	//5-Tolerncia
EndIf
aObj1Size := MsObjSize( aInfo1AdvSize , aObj1Coords,,.T.)

If !l070Auto
	SetaPilha()
		DEFINE FONT oFont NAME "Arial" SIZE 0,-11 BOLD
		DEFINE MSDIALOG oDlg TITLE OemToAnsi(STR0016) From aAdvSize[7],0 TO aAdvSize[6],aAdvSize[5] OF oMainWnd PIXEL	// 'Tipos de Hora Extra'
		
		@ aObj1Size[1,1] , aObj1Size[1,2] GROUP oGroup TO aObj1Size[1,3] , aObj1Size[1,4]	LABEL OemToAnsi(STR0017) OF oDlg PIXEL	// "Turno:"
		oGroup:oFont:= oFont
		@ aObj1Size[2,1] , aObj1Size[2,2] GROUP oGroup TO aObj1Size[2,3] , aObj1Size[2,4]	LABEL OemToAnsi(STR0018) OF oDlg PIXEL	// 'Tipo:'
		oGroup:oFont:= oFont
		@ aObj1Size[3,1] , aObj1Size[3,2] GROUP oGroup TO aObj1Size[3,3] , aObj1Size[3,4]	LABEL OemToAnsi(STR0025) OF oDlg PIXEL	// "Descrio:"
		oGroup:oFont:= oFont
		
		If lCpoPer
			@ aObj1Size[4,1] , aObj1Size[4,2] GROUP oGroup TO aObj1Size[4,3] , aObj1Size[4,4]	LABEL OemToAnsi(STR0030) OF oDlg PIXEL	// Perodo de Apurao
			oGroup:oFont:= oFont
			@ aObj1Size[5,1] , aObj1Size[5,2] GROUP oGroup TO aObj1Size[5,3] , aObj1Size[5,4]	LABEL OemToAnsi(STR0031) OF oDlg PIXEL	// Tolerncia
			oGroup:oFont:= oFont
		EndIf
		
		@ aObj1Size[1,1]+10 , aObj1Size[1,2]+5	SAY cTnoHe	PICTURE PesqPict("SP4","P4_TURNO")	SIZE 050,10 OF oDlg PIXEL FONT oFont
		@ aObj1Size[2,1]+10 , aObj1Size[2,2]+5	SAY cTipoHE	PICTURE PesqPict("SP4","P4_TIPO")	SIZE 146,10 OF oDlg PIXEL FONT oFont
		@ aObj1Size[3,1]+10 , aObj1Size[3,2]+5	SAY cDesc	PICTURE "@!"						SIZE 146,10 OF oDlg PIXEL FONT oFont
		
		If lCpoPer
			@ aObj1Size[4,1]+10, aObj1Size[4,2]+5 COMBOBOX cPerApu ITEMS aComboPer VALID Pertence(" DSQM") SIZE 146,10 WHEN .F. OF oDlg PIXEL FONT oFont
			@ aObj1Size[5,1]+10, aObj1Size[5,2]+5 MSGET nTolHE PICTURE PesqPict("SP4","P4_TOLHEPE") SIZE 050,10 WHEN .F. OF oDlg PIXEL FONT oFont HASBUTTON
		EndIf
		
		oGet := MSGetDados():New(aObjSize[2,1],aObjSize[2,2],aObjSize[2,3],aObjSize[2,4],nOpcx,,,'',.F.)
		
		bSet15	:= { || nOpcA:=2 , oDlg:End() }
		bSet24	:= { || nOpcA:=0 , oDlg:End() }
		
		ACTIVATE MSDIALOG oDlg ON INIT ( EnchoiceBar( oDlg , bSet15  , bSet24 )) CENTERED 
		
	SetaPilha()
Else
	If MsGetDAuto(aAutoItens, "Pn070LinOk", "Pn070TudOk",, nOpcx)
		nOpcA := 2
	EndIf
EndIf

//Ŀ
// Procede com a Deleo dos Registros                          
//
If nOpcA == 2
	nCnt := 0
	dbSelectArea(cAlias)
	If SP4->(dbSeek( xFilial('SP4') + cTnoHe + cTipoHE, .F.))
		Begin Transaction
			Do While !SP4->(Eof()) .And. SP4->P4_Filial + SP4->P4_Turno + SP4->P4_Tipo == xFilial('SP4') + cTnoHe + cTipoHE
				IF RecLock(cAlias,.F.,.T.)
					IF !( cAlias )->( FkDelete( @cMsgErr ) )
						( cAlias )->( RollBackDelTran( cMsgErr ) )
					Else
						nCnt++
					EndIF
					( cAlias )->( MsUnlock() )
				EndIF	
				dbSkip()
			EndDo
		End Transaction	
		WriteSX2(cAlias,nCnt)
	EndIf	
Endif

FreeLocks( 'SP4' , NIL , .T. )

//Ŀ
// Restaura a integridade da janela                             
//
DbSelectArea(cAlias)
DbGoTo(nSavRec)
Return Nil

/*


Ŀ
Funo    gp070LinOk Autor  J. Ricardo             Data  20.02.95 
Ĵ
Descrio Critica linha digitada                                      
Ĵ
 Uso       Generico                                                   
ٱ

*/
Function Pn070LinOk(o)
Local nx, lRet  := .T.
	
Begin Sequence
	//Ŀ
	// Desconsidera Faixas deletadas                                
	//
	If aCols[n,nUsado+1] == .F.
	
		//-- Nao permite campos em branco
		If  fVazio(nX)
			lRet := .F.
			Break
		Endif
		
		//-- Nao permite Valor final maior ou igual a valor inicial
		If ( GDFIELDGET('P4_DE') >= GDFIELDGET('P4_ATE') )
			Help(' ',1,'PNFXIMAIOR') //O Limite Inicial EH Maior ou Igual ao Limite Final da Faixa.     
			lRet := .F.
			Break
		Endif
	Endif
End

Return lRet

/*


Ŀ
Funo    gp090TudOk Autor  J. Ricardo             Data  20.02/95 
Ĵ
Descrio                                                             
Ĵ
 Uso       Generico                                                   
ٱ

*/
Function Pn070TudOk(o)
	
	Local nx   := 0
	Local lRet := .T.
	
	Continua   := .F.
	aCopyCols  := aClone(aCols)
	
	If l070Auto .And. nOpcAuto == 3 
		lRet := fTno070(cTnoHe) .And. CheckSX3("P4_TURNO")
		
		If lRet
			lRet := ExistTipo( Subst( cTipoHE , 1 , 1 ) ) .And. fTipoExtra( Subst( cTipoHE, 1, 1 ) )
		EndIf
		
	EndIf
	
	If lRet
		aSort(aCopyCols,,,{|x,y| x[2] < y[2] })
		
		For nx := 1 To Len(aCopyCols)
			If aCopyCols[nx,nUsado+1] == .F.
				
				//-- Nao permite campos em branco
				If  fVazio(nX)
					lRet := .F.
					Break
				Endif
				
				//-- Nao Permite Valor Inicial Maior ou Igual Valor Final
				If aCopyCols[nx,1] >= aCopyCols[nx,2]
					Help(' ',1,'PNFXIMAIOR') //O Limite Inicial  Maior ou Igual ao Limite Final da Faixa.     
					lRet := .F.
					Exit
				Endif
				
				//-- Nao Permite valor final ANTERIOR maior que valor inicial ATUAL
				If nx > 1 .And. aCopyCols[nx-1,nUsado+1] == .F.
					If aCopyCols[nx,1] <= aCopyCols[nx-1,2]
						Help(' ',1,'PNFXSOBREP') //Ocorreu Sobreposio dos Limites das Faixas Informadas
						lRet := .F.
						Exit
					Endif
				Endif	  
				
			Endif
		Next Nx
	EndIf
	
Return lRet

/*


Ŀ
Funo    fVazio     Autor  Mauricio MR            Data  18/06/04 
Ĵ
Descrio  Valida Colunas em Branco                                   
Ĵ
 Uso       Generico                                                   
ٱ

*/
Static Function fVazio(nline)      
Local lRet	:= .F.
If  !GDNOEMPTY({'P4_DE','P4_ATE','P4_PERCENT','P4_CODAUT','P4_CODNAUT'},nline)
    lRet:= .T.
Endif     

Return lRet     	

/*

Ŀ
Funo    Pn070Grava Autor  J. Ricardo             Data  20.02.95 
Ĵ
Descrio  Grava no arquivo de Valores Variaveis                      
Ĵ
 Uso       Pn070Grava                                                 
ٱ

*/
Function Pn070Grava(cAlias,aRegAltera)

Local nCntDel 	:= 0

Local cMsgErr
Local nX
Local nY
Local lTudoIgual

lCpoPer := If(lCpoPer != NIL, lCpoPer, SP4->(ColumnPos("P4_PERHEXT") > 0))

aSort(aCols,,,{|x,y| x[2] < y[2] })

Begin Transaction	
	dbSelectArea(cAlias)
	If aRegAltera # Nil
		For nX := 1 to Len(aRegAltera)
			lTudoIgual := .T.
			
			If lCpoPer .And. (nTolAnt != nTolHE .Or. cPerAnt != cPerApu)
				lTudoIgual := .F.
			Else 
				For nY := 1 To Len(aHeader)
					If aCols[nX,nY] # aColsAnt[nX,nY]
						lTudoIgual := .F.
						Exit
					Endif
				Next nY
			EndIf 
			
			If lTudoIgual .And. aCols[nX,nUsado+1] = .F.
				Loop
			Endif
			Go aRegAltera[nX]
			IF !RecLock(cAlias,.F.,.T.)
				Loop
			EndIF
			
			If aCols[nX,nUsado+1] = .T.
				IF !( cAlias )->( FkDelete( @cMsgErr ) )
					( cAlias )->( RollBackDelTran( cMsgErr ) )
				Else
					nCntDel ++
				EndIF
			Else
				Replace SP4->P4_FILIAL With xFilial("SP4")
				Replace SP4->P4_TURNO  With cTnoHe
				Replace SP4->P4_TIPO   With Subst( cTipoHE , 1 , 1 )
				If lCpoPer
					Replace SP4->P4_PERHEXT  With cPerApu
					Replace SP4->P4_TOLHEPE  With nTolHE
				EndIf
				For nY := 1 To Len(aHeader)
					cCampo := Trim(aHeader[nY,2])
					xConteudo := aCols[nX,nY]
					Replace &cCampo With xConteudo
				Next nY
			Endif
			
			msUnlock()
			
		Next nX
		If Len(aCols) > Len(aRegAltera)  //-- Se Trata de Inclusao de Itens
			Pn070GRINC ( cAlias , Len(aRegAltera)+1 )
		Endif
	Else
		Pn070GRINC ( cAlias , 1 )
	Endif
	
	If nCntDel > 0
		WRITESX2(cAlias,nCntDel)
	Endif
	
End Transaction

Return .T.

/*


Ŀ
Funo    Pn070GRINC Autor  J. Ricardo             Data  24.05.95 
Ĵ
Descrio  Grava os registros Incluidos na GetDados                   
Ĵ
 Uso       PnA070GRAVA                                                
ٱ

*/
Static Function Pn070GRINC ( cAlias , nIniciar )
Local nX	:=	0
Local nY	:= 	0

lCpoPer := If(lCpoPer != NIL, lCpoPer, SP4->(ColumnPos("P4_PERHEXT") > 0))

aSort(aCols,,,{|x,y| x[2] < y[2] })

Begin Transaction
	
	For nX := nIniciar to Len(aCols)
		If aCols[nX,nUsado+1] == .F.
			IF !RecLock(cAlias,.T.)
				Loop
			EndIF
			Replace SP4->P4_FILIAL With xFilial("SP4")
			Replace SP4->P4_TURNO  With cTnoHe
			Replace SP4->P4_TIPO   With Subst( cTipoHE , 1 , 1 )
			If lCpoPer
				Replace SP4->P4_PERHEXT  With cPerApu
				Replace SP4->P4_TOLHEPE  With nTolHE
			EndIf
			For nY := 1 To Len(aHeader)
				cCampo := Trim(aHeader[nY,2])
				xConteudo := aCols[nX,nY]
				Replace &cCampo With xConteudo
			Next nY
			msUnlock()
		Endif
	Next nX

End Transaction

Return Nil

/*


Ŀ
Funo    FDefQtdReg  Autor  J. Ricardo            Data  24.05.95 
Ĵ
Descrio  Define a Quantidade de Registros.                          
Ĵ
 Uso       PONA070                                                    
ٱ

*/
Function FDefQtdReg(cAlias, cChave, cCompara, cSkip)
	
	Local nReg
	
	nCnt := 0
	DbSelectArea( cAlias )
	nReg := Recno()
	DbSeek( cChave )
	
	Default cSkip := ".F."
	
	Do While !Eof() .And. &cCompara
		If !(&cSkip)
			nCnt ++
		EndIf
		DbSkip()
	EndDo
	
	DbGoto(nReg)
Return (nCnt)

/*


Ŀ
Funo      fTno070   Autor  Fernando Joly         Data  11.11.96 
Ĵ
Descrio  Verifica a existencia do turno de trabalho.                
Ĵ
 Uso       PONA070                                                    
ٱ

*/
Static Function fTno070(cTno)

Local lRet := .T.

If !Empty(cTno) .And. !SR6->(dbSeek(xFilial('SR6')+cTno,.F.))
	Help(" ",1,"A070TNONC")
	lRet := .F.
EndIf	

Return lRet

/*


Ŀ
Funo    ExistTipo   Autor  Fernando Joly         Data  22.05.97 
Ĵ
Descrio  Consiste a digitao dos tipos de Horas Extras             
Ĵ
 Uso       PONA070                                                    
ٱ

*/
Static Function ExistTipo(cTip)

Local lRet   := .T.
Local nRecno := SP4->(Recno())

//-- Verifica se o tipo ja esta cadastrado
If ( SP4->( dbSeek( xFilial('SP4') + cTnoHE + cTip , .F. ) ) .and. MayIUseCode("SP4"+xFilial("SP4")+cTnoHE+cTip) )
	Help(' ',1,'PNA070JACA')
	lRet := .F.
EndIf
SP4->(dbGoto(nRecno))

Return( lRet )

/*


Ŀ
Funo    PN070VATE() Autor  MauricioMR            Data  25.02.04 
Ĵ
Descrio  Consiste limitacao de intervalo P4_ATE			          
Ĵ
 Uso       PONA070                                                    
ٱ

*/
Function PN070VATE()
Local lRet		:= .T.
Local nPosDe	:= GdFieldPos( "P4_DE" 	)

If !(M->P4_ATE >= aCols[n, nPosDe] )
   lRet:= .F.
Endif   

Return (lRet)

/*


Ŀ
Funo    PN070lOCKS  Autor  MauricioMR            Data  16.03.04 
Ĵ
Descrio  Bloqueia Acesso.									          
Ĵ
 Uso       PONA070                                                    
ٱ

*/
Static Function Pona070Locks( nOpc , cAlias, aRecnos, aKeysCode )

Local lLocks	:= .T.
Local aRecAux	:= {}

/*
Ŀ
Se nao For Visualizacao nem Inclusao	 					   
*/
IF ( nOpc <> 2 ) 

	aEval(aRecnos, {|x| If( !Empty(x),aADD(aRecAux,x), Nil) } )

	/*
	Ŀ
	IMPORTANTE: a chave de Bloqueio devera ser a mesma da opcao   
	            coletivas.                                        
	*/
	lLocks := WhileNoLock( cAlias , aRecAux , aKeysCode  , 1 , 1 , .T. , NIL ) 

EndIF

Return( lLocks )

/*
Ŀ
Funo    Pona070Opc	 Autor Marinaldo de Jesus     Data 02/10/2002
Ĵ
Descrio Limpa o Filtro de Browse e Chama a Funcao Correspondente	 
Ĵ
Sintaxe                               								 
Ĵ
Parametros															 
Ĵ
Retorno                                                          	     
Ĵ
Observao                                                      	     
Ĵ
 Uso      PONA070                                                      
*/
Function Pona070Opc( cAlias , nReg , nOpcX )

Local nOpc 	 := 0

EndFilBrw( "SP4" , aIndexSP4 )

aIndexSP4 := {}

(cAlias)->( MsGoto( nReg ) )

IF ( nOpcX == 2 )
	nOpc := Pona070Vis( cAlias , nReg , nOpcX )
ElseIF ( nOpcX == 3 )
	nOpc := Pona070Inc( cAlias , nReg , nOpcX )
ElseIF ( nOpcX == 4 )
	nOpc := Pona070Alt( cAlias , nReg , nOpcX )
ElseIF ( nOpcX == 5 )
	nOpc := Pona070Del( cAlias , nReg , nOpcX )
EndIF

Eval( bFiltraBrw )

IF ( nOpcX <> 3 )
	( cAlias )->( MsGoto( nReg ) )
EndIF	

Return( nOpc )


/*
Ŀ
Funo    Pona070MntGd Autor Leandro Drumond        Data 16/06/2008
Ĵ
Descrio Monta aHeader e aCols com os campos do Walk Thrue			 
Ĵ
Sintaxe                               								 
Ĵ
Parametros															 
Ĵ
Retorno                                                          	     
Ĵ
Observao                                                      	     
Ĵ
 Uso      PONA070                                                      
*/
Static Function Pona070MntGd(cAlias,nOpcx,aHeader,aCols)

Local cSeekKey 	:= xFilial("SP4")+cTnoHe+cTipoHE
Local aNoFields	:= {'P4_TIPO'}
Local cQuery	:= NIL

lCpoCCT := If(lCpoCCT != NIL, lCpoCCT, SP4->(ColumnPos("P4_CODCCT") > 0))
lCpoPer := If(lCpoPer != NIL, lCpoPer, SP4->(ColumnPos("P4_PERHEXT") > 0))

If lCpoCCT
	aAdd(aNoFields, 'P4_TURNO' )
	aAdd(aNoFields, 'P4_FILCCT')
	aAdd(aNoFields, 'P4_CODCCT')
	cQuery := "SELECT * FROM " + RetSqlName("SP4") + " WHERE P4_FILIAL = '" + xFilial("SP4") + "'"
	cQuery += "AND P4_TURNO = '" + cTnoHe + "' AND P4_TIPO = '" + cTipoHE + "' AND P4_CODCCT = ''"
	cQuery += "AND D_E_L_E_T_ = '' "
	cQuery := ChangeQuery(cQuery)
EndIf

If lCpoPer
	aAdd(aNoFields, 'P4_PERHEXT')
	aAdd(aNoFields, 'P4_TOLHEPE')
EndIf

FillGetDados(nOpcx					 ,; //1-nOpcx - nmero correspondente  operao a ser executada, exemplo: 3 - incluso, 4 alterao e etc;
			 cAlias				 	 ,; //2-cAlias - area a ser utilizada;
			 NIL    				 ,; //3-nOrder - ordem correspondente a chave de indice para preencher o  acols;
			 cSeekKey                ,; //4-cSeekKey - chave utilizada no posicionamento da area para preencher o acols;
			 bSeekWhile	    		 ,; //5-bSeekWhile - bloco contendo a expresso a ser comparada com cSeekKey na condio  do While.
			 NIL    		 		 ,; //6-uSeekFor - pode ser utilizados de duas maneiras:1- bloco-de-cdigo, condio a ser utilizado para executar o Loop no While;2 - array bi-dimensional contendo N.. condies, em que o 1 elemento  o bloco condicional, o 2  bloco a ser executado se verdadeiro e o 3  bloco a ser executado se falso, exemplo {{bCondicao1, bTrue1, bFalse1}, {bCondicao2, bTrue2, bFalse2}.. bCondicaoN, bTrueN, bFalseN};
			 aNoFields				 ,; //7-aNoFields - array contendo os campos que no estaro no aHeader;
			 NIL					 ,; //8-aYesFields - array contendo somente os campos que estaro no aHeader;
			 NIL					 ,; //9-lOnlyYes - se verdadeiro, exibe apenas os campos de usurio;
			 cQuery					 ,; //10-cQuery - query a ser executada para preencher o acols(Obs. Nao pode haver MEMO);
			 NIL			      	 ,; //11-bMontCols - bloco contendo funo especifica para preencher o aCols; Exmplo:{|| MontaAcols(cAlias)}
			 If(nOpcx=3,.t.,.f.)   	 ,; // NIL	12-lEmpty
			 @aHeader	      	     ;  //13-aHeaderAux
		)
		
Return(Nil)

/*
Ŀ
Funo    P4EventVld	 Autor Leandro Drumond        Data 14/10/2009
Ĵ
Descrio Valida se o evento digitado e de Hora Extra                  
Ĵ
Sintaxe                               								 
Ĵ
Parametros															 
Ĵ
Retorno                                                          	     
Ĵ
Observao                                                      	     
Ĵ
 Uso      PONA070                                                      
*/
Function P4EventVld()

Local aArea	  := GetArea()
Local lRet 	  := .T.
Local cEvento := ""

If lPort1510
	cEvento := &(Alltrim( ReadVar() ))
	dbSelectArea("SP9")
	If dbSeek(xFilial( "SP9" )+cEvento)
		If !(SP9->P9_CLASEV == "01") //--Se evento nao for classificado como HE, retorna falso
			cMsgInfo := STR0027  //"Este evento no foi classificado como Hora Extra"
			MsgInfo( OemToAnsi( cMsgInfo ) , OemToAnsi( STR0026 ) ) //"Ateno!"
			lRet := .F.
		EndIf
	EndIf
EndIf

RestArea( aArea )

Return( lRet )

/*
Ŀ
Funo     MenuDef		Autor  Luiz Almeida      Data 21/11/2006
Ĵ
Descrio Isola opcoes de menu para que as opcoes da rotina possam    
          ser lidas pelas blibliotecas Framework da Versao 9.12 .     
Ĵ
Sintaxe   < Vide Parametros Formais >									
Ĵ
 Uso      PONA070                                                     
Ĵ
 Retorno  aRotina														
Ĵ
Parametros< Vide Parametros Formais >									
*/

Static Function MenuDef()

Local aRotina :=       {	{ STR0005 ,	"PesqBrw"		, 0 , 1, ,.F. },; // "Pesquisar"
						 	{ STR0006 , "Pona070Opc"	, 0 , 2 },; // "Visualizar"
							{ STR0008 , "Pona070Opc"	, 0 , 3 },; // "Incluir"
							{ STR0010 , "Pona070Opc"	, 0 , 4 },; // "Alterar"
							{ STR0012 , "Pona070Opc"	, 0 , 5 };	// "Excluir"
						 }	   
						 
Return aRotina						              	
