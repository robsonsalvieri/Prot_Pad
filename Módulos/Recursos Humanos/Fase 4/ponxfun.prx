#INCLUDE "PONX1FUN.CH"
#INCLUDE "PONCALEN.CH"
#INCLUDE "PROTHEUS.CH"  
   
#DEFINE DPORT1510  "25/11/09"



/*
ээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©╠╠
╠╠Ё              ATUALIZACOES SOFRIDAS DESDE A CONSTRU─AO INICIAL.             Ё╠╠
╠╠цддддддддддддбддддддддбдддддддддддбдддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁProgramador Ё Data   Ё BOPS/FNC  Ё  Motivo da Alteracao                     Ё╠╠
╠╠цддддддддддддеддддддддедддддддддддедддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁIgor FranzoiЁ16/10/08Ё           ЁTratamento para Continuacao de Sequencia  Ё╠╠
╠╠Ё            Ё        Ё           Ёdo Calendario do Funcionario              Ё╠╠
╠╠ЁLeandro Dr. Ё01/10/09Ё           ЁTratamento para que ordem do calendario   Ё╠╠
╠╠Ё            Ё        Ё           Ёseja gravada corretamente quando parte do Ё╠╠
╠╠Ё            Ё        Ё           Ёperiodo estiver previamente gravado.      Ё╠╠
╠╠ЁFrancisco JrЁ17/11/09Ё           ЁCompatibilizacao fonte para uso na Versao Ё╠╠
╠╠Ё            Ё        Ё           ЁCorporativa - Utilizando tb com FWCODEMP- Ё╠╠
╠╠Ё            Ё        Ё           Ё              FWGETTAMFILIAL.             Ё╠╠
╠╠ЁNatie       Ё19/03/10Ё006184     ЁInclusao do tratamento para a Portaria    Ё╠╠
╠╠Ё            Ё        Ё           Ё1510 - fc Port1510()                      Ё╠╠
╠╠ц============================================================================╢╠╠ 
╠╠Ё                             *** Versao 11.5 ***                            Ё╠╠ 
╠╠ц============================================================================╢╠╠ 
╠╠ЁEmerson     Ё31/12/10Ё29618/     ЁAjuste para nova interface 11. Com a      Ё╠╠
╠╠ЁCampos      Ё        Ё  2010     ЁaplicaГЦo do parametro MV_ECMFTPP que     Ё╠╠
╠╠Ё            Ё        Ё           Ёafirma ser a versЦo 11.5 do Protheus      Ё╠╠
╠╠цддддддддддддеддддддддедддддддддддедддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁAdemar Jr.  Ё01/02/11Ё002358/2011Ё-PTG-Ajuste da funcao fFeriado() para tra-Ё╠╠
╠╠Ё            Ё        Ё           Ё tar os novos campos do Novo Modelo de Ca-Ё╠╠
╠╠Ё            Ё        Ё           Ё dastro de Feriados.                      Ё╠╠
╠╠ЁErika K.    Ё28/06/11Ё013131/2011ЁAleracao da funcao GetInfoPosTab (criacao Ё╠╠
╠╠Ё            Ё        Ё           Ёdo operador HORAS_HABILES).               Ё╠╠
╠╠ЁTiago Malta Ё05/07/11Ё014521/2011ЁAlterado telas para a versao p11.5.       Ё╠╠    
╠╠ЁClaudinei S.Ё07/03/12Ё005717/2012ЁAjuste para que seja feita a marcacao cor-Ё╠╠
╠╠Ё            Ё        Ё     TEQGXIЁreta quando existirem excecoes BOL.       Ё╠╠ 
╠╠ЁClaudinei S.Ё21/05/12Ё     TEWMB1ЁAjuste na CalendCria para que seja feita  Ё╠╠
╠╠Ё            Ё        Ё           Ёtroca de turno corret. quando ja existir. Ё╠╠
╠╠ЁGustavo M.  Ё24/05/12Ё     TEWMB1ЁAjuste para verificar a sequencia.		   Ё╠╠
╠╠ЁR.Berti     Ё17/09/12Ё		 	ЁAjuste da funcao fFeriado() ref. error logЁ╠╠
╠╠Ё            Ё        Ё           Ё"SetOrder - Index not found. on FFERIADO" Ё╠╠
╠╠ЁLuis Artuso Ё22/10/13Ё	  THUDOCЁAjuste na funcao fBuscaDia() para verifi- Ё╠╠
╠╠Ё            Ё        Ё           Ёcar o retorno do codigo da funcao.  	   Ё╠╠
╠╠ЁM. Silveira Ё24/10/13Ё     THVXOFЁAjuste na GetInfoPosTab p/ fazer a carga  Ё╠╠
╠╠Ё            Ё        Ё           Ёdo Inic.Padrao mais rapida na troca turno.Ё╠╠
╠╠ЁClaudinei S.Ё08/11/13Ё028259/2013ЁAjuste na funcao PerAponta() para evitar  Ё╠╠
╠╠Ё            Ё        Ё     THZEVWЁmsg. solicitando MV_PAPONTA nas Ausencias.Ё╠╠
╠╠ЁLuis Artuso Ё17/03/14Ё005748/2014ЁAjuste em fGeraExtra para nao gerar error Ё╠╠
╠╠Ё            Ё        Ё     TIJVXOЁlog.                                      Ё╠╠
╠╠ЁClaudinei S.Ё22/04/14|     TPDNQ3ЁAjuste na PonRelationFile() para incluir aЁ╠╠
╠╠Ё            Ё        Ё           Ёvalidacao do modo de acesso entre as      Ё╠╠
╠╠Ё            Ё        Ё           Ёtabelas SR6 e RF8.                        Ё╠╠
╠╠ЁLuis Artuso Ё20/08/14|     TQFJ11ЁAjuste para corrigir errorlog na rotina deЁ╠╠
╠╠Ё            Ё        Ё           Ёfaixa de HE autorizada, devido a nao ini- Ё╠╠
╠╠Ё            Ё        Ё           Ёcializacao da variavel 'oPeriodo'.        Ё╠╠
╠╠юддддддддддддаддддддддадддддддддддадддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ
*/


/*/
здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Static Utilizadas na CriaCalend()  						   Ё
юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static __dPerCalIni
Static __dPerCalFim                               
Static __aProcesso   
Static __cProcesso 
Static __nPosProcesso
Static __lPGenerico  
Static __nOrdIni

/*/                                          	
здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Static Utilizadas na CalendCria()  						   Ё
юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static __aLstTabCal	:= {}
Static __aLstTabTno	:= {}	
Static __cKeyBldCal	:= "__cKeyBldCal"
Static __nFilTabTno	:= 0

/*/
здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Static Utilizadas na fTabPadrao()  						   Ё
юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static __nLstTabPadPos

/*/
здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Static Utilizadas na fTabMarc()    						   Ё
юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static __aLstTbMarc

/*/
здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Static Utilizadas na ToScheduleOverTime()					   Ё
юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static __aHeLastGera__
Static __cHeLastKey__

/*/
здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Static Utilizadas na GetTabArred()					   	   Ё
юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static __aTabArr
Static __aTabFilArr

/*/
здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Static Utilizadas na GetTabExtra()					   	   Ё
юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static __aTabEx
Static __lEscalonamento 
Static cFilStatic		//Para uso em DEFAULTFIL

/*/
здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Static Utilizadas na fFeriado()   					   	   Ё
юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static __aFeriadoStatic

/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
ЁDefine o Numero Maximo de Ordens para o P8_ORDEM             Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static __nTamP8Ordem	:= InitP8PgOrdSize(1)

/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
ЁDefine o Numero Maximo de Ordens para o PG_ORDEM             Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static __nTamPGOrdem	:= InitP8PgOrdSize(2)

/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
ЁStatic com as Eventos carregados pela fEventos()             Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static __aEvefEve__	:= {}

/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
ЁStatic para a fCargaId										  Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static aCargaIdCache 	:= {}

/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
ЁStatic para a PutMarcAuto()								  Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static _aSpaHeader
Static _aSr6Header

Static _cSr6LastTno
Static _cSpaLastReg
Static _cSpceFuncao
Static _cSpceGiro
Static _cSpceRelogi

Static _nSpaHeader
Static _nSr6Header

/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
ЁVerifica se a Execucao eh no AS/400                          Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
#IFDEF TOP
	Static lExInAs400 := ExeInAs400()
#ENDIF

/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
ЁVerifica a Existencia do Arquivo de Pre-Abonos.  ( Nao deveraЁ
Ёconstar em versoes Futuras )								  Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static lRF0ChkTable 

/*/
здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Static Utilizadas na Calendcria e Turnos Opcionais	   	   Ё
юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static __aAllTnoOpc
Static __lChkTnoOpc := If( IsInCallStack("RHUPDMOD"), "", IF( ( ( SuperGetMv("MV_TNOOPC",NIL,"N") == "S" ) ) ,.T. , .F. ) )
                                       
/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
ЁVariavel para uso em Query para preencher em branco		  Ё
Ёo campo Motivo do Abono 								  	  Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static __cLimpaMotAbo	

/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
ЁVariavel para uso da Geracao Automatica de Marcacoes		  Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static lPnMcAut01	:= ExistBlock( "PNMCAUT01" )

/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
ЁVariavel para manipulacao do calendario apos sua montagem	  Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static lPnmTabCalen := ExistBlock( "PNMTABC01" )

/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
ЁVariavel para manipulacao do calendario durante a geracao do dia	  Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static lPnmTab01 := ExistBlock( "PNMTAB01" )  

/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
ЁVariavel para Geracao/Carga do Calendario Fisico                     Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static lUseCalFisico :=  If( IsInCallStack("RHUPDMOD"), "", ( SuperGetMv("MV_CALFIS",NIL,"0")  == "0" ) )

/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
ЁVariavel para utilizacao ou nao dos limites superiores informados - Mexico Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static lMVLimSup	 := If( IsInCallStack("RHUPDMOD"), "", (If( cPaisLoc <> 'MEX' , .T. , (SuperGetMv("MV_LIMSUP",NIL,"1") == "1" ) ) ) )

/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
ЁVariavel para Controle de Uso do SPJ 								  Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static lUseSPJ := If( IsInCallStack("RHUPDMOD"), "", ( SuperGetMv("MV_USESPJ",NIL,"0")  == "1" ) )

/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
ЁVariavel para Verificar se deve gravar o calendario			      Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static lCalDem := If( IsInCallStack("RHUPDMOD"), "", ( SuperGetMv("MV_CALDEM",NIL,"0")  == "1" ) )

/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
ЁStatic dos campos do calendario - Estrutura do RF6/RF7				  Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static aStcStrRF6 := {}
Static aStcStrRF7 := {}

/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
ЁStatic dos campos do calendario p/ tabela RF6 - Apenas Gravacao	  Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static aStcRF6 := { {	"FILIAL",;
					   	"DATA"  ,;
						"ORDEM ",;
						"MAT   ",;
						"TURNO ",;
						"SEQ   ",;
						"TIPOD ",;
						"MOTIVO",;
						"P2ID  ",;
						"JORN  ",;
						"HRMENO",;
						"HRMAIS",;
						"HRINTV",;
						"HRTRAB",;
						"CODREF",;
						"TPEXT ",;
						"TPEXTN",;
						"NONAHR",;
						"INIHNT",;
						"FIMHNT",;
						"MINHNT",;
						"HNTTAB",;
						"HNTTBI",;
						"REGRA ",;
						"NUMARC",;
						"DORIG ",;
						"R8ID  ",;
						"FLAG  ",;
						"CHKTNO",;
						"PROCES",;
						"PERIOD",;
						"ROTEIR",;
						"NUMPAG",;
						"TPEXCE";
					};
				}
	
/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
ЁStatic dos campos do calendario p/ tabela RF7 - Apenas Gravacao	  Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static aStcRF7 := { { "FILIAL"  ,;
					   "DATA"    ,;
					   "MAT" 	 ,;
					   "LIE"	 ,;
					   "DATAE"   ,;
					   "ENTRA"   ,;
					   "LSE"	 ,;
					   "LIS"	 ,;
					   "DATAS"	 ,;
					   "SAIDA"   ,;
					   "LSS"	 ,;
					   "INTERV"  ,;
					   "JNDCO"   ,;
					   "HRINTV"  ,;
					   "HRTRAB"  ,;
					   "CC"      ,;
					   "DEPTO"   ,;
					   "POSTO"   ,;
					   "CODFUN"  ,;
					   "FLAG"     ;
				 };
			 }

Static 	cSX3ProcTit 

/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
ЁVerifica se Portaria 1510/2009 esta em vigor.				  Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static lPort1510 := Port1510()    

/*           
зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁPonxFun   Ё Autor Ё *EQUIPE RH ADVANCED*  Ё Data Ё02/02/1996Ё
цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o Ё Biblioteca de Fun┤■es Utilizadas no M╒dulo SigaPon         Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё Void                                                       Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       Ё Gen┌rico                                                   Ё
цддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
Ё                     ATUALIZACOES SOFRIDAS DESDE A CONSTRU─AO INICIAL. Ё
цддддддддддддбддддддддбддддддбдддддддддддддддддддддддддддддддддддддддддд╢
ЁProgramador Ё Data   Ё BOPS Ё  Motivo da Alteracao                     Ё
цддддддддддддеддддддддеддддддедддддддддддддддддддддддддддддддддддддддддд╢
ЁErika K.    Ё02/06/08Ё------ЁAlteracao de CH para integracao de diciona|
Ё            Ё        Ё      Ёrios Mexico e R 1.2.                      Ё
ЁIgor FranzoiЁ08/08/08Ё151614ЁVer. de Base - Estrutura SPI(VerSPIStruct)Ё
юддддддддддддаддддддддаддддддадддддддддддддддддддддддддддддддддддддддддды
*/
/*
зддддддддддбдддддддддддддбдддддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁInPonxFunExecЁ Autor ЁMarinaldo de Jesus   Ё Data Ё14/05/2003Ё
цддддддддддедддддддддддддадддддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁExecutar Funcoes Dentro de PONXFUN                           Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   ЁInPonxFunExec( cExecIn , aFormParam )						 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁuRet                                                 	     Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁObserva┤└oЁ                                                      	     Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGenerico 													 Ё
юддддддддддаддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
*/
Function InPonxFunExec( cExecIn , aFormParam )
         
Local uRet

DEFAULT cExecIn		:= ""
DEFAULT aFormParam	:= {}

IF !Empty( cExecIn )
	cExecIn	:= BldcExecInFun( cExecIn , aFormParam )
	uRet	:= &( cExecIn )
EndIF

Return( uRet )

/*/
эээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤┘o    ЁAbreArqRelЁ Autor Ё Equipe Advanced RH    Ё Data Ё29/02/1996Ё╠╠
╠╠цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤┘o Ё Abre o arquivo gerado pelo rel╒gio.                        Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁSintaxe   Ё                                                            Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ/*/
Function AbreArqRel(	cTipoArq	,;	//01 -> Tipo do Arquivo a ser Aberto. "T"ext File, "D"ata File
						cArquivo	,;	//02 -> Caminho completo do arquivo
						nHandle		,;	//03 -> Handle do Arquivo ( Quando Tipo = "T" )
						lEnchoice	,;	//04 -> Se esta sendo Executado aa partir da Enchoice
						lStop		,;	//05 -> Se deve Emitir Mensagens
						cArqSrv		,;	//06 -> Nome do arquivo no server
						lCpyT2Srv	,;	//07 -> Se o arquivo foi copiado para o server
						lForceCopy	 ;	//08 -> Forca copia do arquivo para o server
					 )
Local aAuxRelo		:= {}
Local cSvAlias		:= Alias()
Local cExt			:= ""
Local cRdd			:= "DBFCDX"
Local cMsgAlert		:= ""
Local cPathSrv		:= Upper(GetPvProfString( GetEnvServer() , "StartPath" , "" , GetAdv97() ) )
Local lRet			:= .T.
Local nPos			:= 0
Local cPonArq		:= If( !Empty( SuperGetMv("MV_POARQ",.F.,"N") ), SuperGetMv("MV_POARQ",.F.,"N"), "2" )
Local cArqAux		:= ""

DEFAULT cTipoArq	:= "T"
DEFAULT cArquivo	:= ""
DEFAULT nHandle		:= 0
DEFAULT lEnchoice	:= .F.
DEFAULT lStop	  	:= .T.
DEFAULT cArqSrv		:= "" 
DEFAULT lCpyT2Srv	:= .F. 
DEFAULT lForceCopy	:= .F.

cArquivo			:= Upper( AllTrim( cArquivo ) )
nHandle				:= 0
cArqSrv				:= ""
lCpyT2Srv			:= .F.

/*/
здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Array com os alias dos arquivos abertos (s╒ para o PONA030)  Ё
юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
IF ( lEnchoice .and. cTipoArq == "D" )
	IF ( Type( "aAliasRelo" ) == "U" )
		_SetOwnerPrvt( "aAliasRelo" , {} )
	EndIF
	DEFAULT aAliasRelo := {}
EndIF

/*/
здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Inicializa cTxtAlias uma Estancia Acima					   Ё
юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
IF ( Type( "cTxtAlias" ) == "U" )
	_SetOwnerPrvt( "cTxtAlias" )
EndIF

/*/
здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Obtem o Nome Real do Arquivo Sem Path e nem Extenso		   Ё
юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
cTxtAlias := cArquivo


/*/
здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Alteracao solcitada pelo Andre Gentil para contornar a situa Ё
Ё cao de nao gravacao de arquivo do remote para o servidor.    Ё
юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
/*
IF ( ( nPos := At( ":" , cTxtAlias ) ) > 0 )
	cTxtAlias := SubStr( cTxtAlias , ++nPos )
EndIF
*/

While ( At( "\" , cTxtAlias ) > 0 )
	IF ( ( nPos := At( "\" , cTxtAlias ) ) > 0 )
		cTxtAlias := SubStr( cTxtAlias , ++nPos )
	EndIF
End While

While ( At( "/" , cTxtAlias ) > 0 )
	IF ( ( nPos := At( "/" , cTxtAlias ) ) > 0 )
		cTxtAlias := SubStr( cTxtAlias , ++nPos )
	EndIF
End While
While ( At( "." , cTxtAlias ) > 0 )
	IF ( ( nPos := At( "." , cTxtAlias ) ) > 0 )
		cTxtAlias := Left( cTxtAlias , --nPos )
	EndIF
End While

/*/
здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Obtem a Extensao do Arquivo								   Ё
юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
IF ( ( nPos := At( "." , cArquivo ) ) > 0 )
	cExt := Upper( AllTrim( SubStr( cArquivo , nPos ) ) )
EndIF

/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
ЁVerifica a Existencia de "\" ou "/" barras separadoras de diretorio  Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
IF !( Subst( cPathSrv , 1 , 1 ) $ "\/" )
	cPathSrv := "\"+cPathSrv
EndIF
IF !( Subst( cPathSrv , -1	) $ "\/" )
	cPathSrv+= "\"
EndIF  

/*/
здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
ЁObtem o Nome do arquivo no Server 							   Ё
юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
cArqSrv := Upper( AllTrim( ( cPathSrv + ( cTxtAlias + cExt ) ) ) )

                         
If lEnchoice
    If !Empty(aAliasRelo)   
       nPos:=0   
       For nPos:=1 To Len(aAliasRelo)
           fCloseArqRel(	aAliasRelo, nPos, 	aAliasRelo[nPos,01 ],  aAliasRelo[nPos,02 ], aAliasRelo[nPos,03 ],;
           										aAliasRelo[nPos,04 ],  aAliasRelo[nPos,05 ], aAliasRelo[nPos,06 ],;
           										cTxtAlias, cArquivo ;
           				)
       Next nPos                    
       aAuxRelo		:= Aclone(aAliasRelo)
       aAliasRelo	:= {}             
       //-- Nao considera arquivo marcados para delecao
       Aeval(aAuxRelo, {|x| If ( x[1] == "DEL", NIL, AADD(aAliasRelo,aClone(x)) ) } )
      				 
	   lCpyT2Srv	:= ( aScan( aAliasRelo , {|x| x[1] == cTxtAlias .AND. x[02] .and.    x[04 ]  == cTipoArq .and. x[06 ]  == cArquivo  } ) > 0 ) 
	Endif   
Endif		
	    
/*/
здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
ЁcPonArq - indica que sС copia o arquivo para o StartPath caso Ё
Ёo parametro MV_POARQ esteja com valor NцO					   Ё
юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
If (cPonArq != "1")
	If !lCpyT2Srv  .or. lForceCopy
		/*/
		здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		ЁCopia o arquivo para o Servidor							   Ё
		юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		IF ( lCpyT2Srv := !(;
								( cArquivo == StrTran( cArqSrv , "/" , "\" ) ) .and.;
								( cArquivo == StrTran( cArqSrv , "\" , "/" ) );
							);
			)  
			
			/*/
			здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			ЁQuando o Arquivo Nao Estiver no Server     				   Ё
			юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			IF ( lCpyT2Srv := !( Upper( StrTran( cArquivo , " " , "" ) ) == Upper( StrTran( cArqSrv , " " , "" ) ) ) )
		
				/*/
				здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				ЁCopia-o                                    				   Ё
				юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			    //lCpyT2Srv := __CopyFile( cArquivo , cArqSrv ) //__CopyFile() Recomendacao do Fernando Ramalho ao Inves do CpyT2S() 14/10/2002 16:38h. Naldo.
		
				/*/
				здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				Ё Alteracao solcitada pelo Andre Gentil para contornar a situa Ё
				Ё cao de nao gravacao de arquivo do remote para o servidor.    Ё
				юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		       
				IF ( ( At( ":" , cArquivo ) ) > 0 )
					lCpyT2Srv := CpyT2S( cArquivo , cPathSrv ) //CpyT2S() Recomendacao do Andre Gentil 13/12/2005 11:55h. Mauricio.
				Else
					cArquivo  := cPathSrv + cArquivo
					lCpyT2Srv := __CopyFile( cArquivo , cArqSrv ) //__CopyFile() Recomendacao do Fernando Ramalho ao Inves do CpyT2S() 14/10/2002 16:38h. Naldo.
				Endif
		        
				/*/
				здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				Ё No Ap7 Existe uma Nao  Conformidade com o Retorno da 	 funcaoЁ
				Ё __CopyFile(). Esta retornando NIL Quando deveria Retornar .T.Ё
				Ё ou .F. Caso Tenha Conseguido ou Nao Copiar o Arquivo. Ate queЁ
				Ё a Nao Conformidade Seja corrigida o valor DEFAULT da variavelЁ
				Ё de Retorno da __CopyFile ( lCpyT2Srv ) sera False (.F.)  CasoЁ
				Ё Contrario sera o Proprio retorno da Funcao				   Ё
				юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
				DEFAULT lCpyT2Srv := .F.
		
			EndIF
		Endif
	EndIF
EndIf


/*/
здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
ЁTratamento de acordo com o Tipo de Arquivo					   Ё
юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
IF ( cTipoArq == "D" )
	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	ЁAbre o arquivo no padr└o DBASE								   Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	IF ( !Empty( cTxtAlias ) .and. Select( cTxtAlias ) > 0 )
		( cTxtAlias )->( dbCloseArea() )
		IF ( Select( cSvAlias ) > 0 )
			dbSelectArea( cSvAlias )
		EndIF	
	EndIF
	IF ( lRet := MsFile( cArqSrv , NIL , cRdd ) )
		IF (;
				!( CheckExecForm( { || lRet := MsOpenDbf( .T. , cRdd , cArqSrv , cTxtAlias , .T. , .F. ) } , lStop , "NODBFFILE" ) );
				.or.;
				!( lRet );
			 )
			lRet		:= .F.
			cMsgAlert	:= ( STR0156 + " " + cArqSrv )	//'Nao foi possivel abrir o arquivo:'
		EndIF
	Else
		cMsgAlert := ( STR0058 + cArqSrv ) 				//"Arquivo do Relogio nao Encontrado no Servidor: "
	EndIF
	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	ЁInclui o Alias aberto para posterior fechamento			   Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	IF ( lEnchoice .and. Select( cTxtAlias ) > 0 )
		IF  ( ( nPos := aScan( aAliasRelo , {|x| x[1] == cTxtAlias  .and.  x[04 ]  == cTipoArq .and. 	x[06] == cArquivo } )) == 0 )
			aAdd( aAliasRelo , { cTxtAlias , lCpyT2Srv , cArqSrv , cTipoArq , nHandle, cArquivo } )
		Else
			aAliasRelo[ nPos , 02 ] := lCpyT2Srv
			aAliasRelo[ nPos , 03 ]	:= cArqSrv
			aAliasRelo[ nPos , 04 ]	:= cTipoArq
			aAliasRelo[ nPos , 05 ]	:= nHandle
			aAliasRelo[ nPos , 06 ]	:= cArquivo
		EndIF
	EndIF
Else
	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	ЁAbre o arquivo no padr└o ASCII								   Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	IF ( lRet := File( cArqSrv ) ) 
	   	nPos	:= 0 
   		IF ( Type( "aAliasRelo" ) <> "U" )
		   	//-- Verifica a necessidade de abrir o arquivo caso o mesmo nЦo esteja aberto.
		    nPos := aScan( aAliasRelo , {|x| x[1] == cTxtAlias  .and.  x[04 ]  == cTipoArq .and. 	x[06] == cArquivo } )
		Endif
		If nPos == 0
			nHandle := fOpen( cArqSrv )
			IF ( fError() # 0 .or. nHandle < 0 )
				cMsgAlert := ( STR0156 + " " + cArqSrv )	//'Nao foi possivel abrir o arquivo:'
				lRet := .F.
			EndIF
		Endif	
	Else
		cMsgAlert := ( STR0058 + cArqSrv )				//"Arquivo do Relogio nao Encontrado no Servidor:
	EndIF
	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	ЁInclui o Alias aberto para posterior fechamento			   Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	IF ( lEnchoice .and. nHandle > 0 )
		IF  ( ( nPos := aScan( aAliasRelo , {|x| x[1] == cTxtAlias  .and.  x[04 ]  == cTipoArq .and. 	x[06] == cArquivo } )) == 0 )
			aAdd( aAliasRelo , { ALLTRIM(cTxtAlias) , lCpyT2Srv , cArqSrv , cTipoArq , nHandle, cArquivo } )
		Else
			aAliasRelo[ nPos , 02 ] := lCpyT2Srv
			aAliasRelo[ nPos , 03 ]	:= cArqSrv
			aAliasRelo[ nPos , 04 ]	:= cTipoArq
			aAliasRelo[ nPos , 05 ]	:= nHandle
			aAliasRelo[ nPos , 06 ]	:= cArquivo
		EndIF
	EndIF
EndIF

/*/
здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
ЁMensagens de Nao Abertura dos Arquivos             		   Ё
юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
IF ( lStop .and. !lRet )
	IF !Empty( cMsgAlert )
		MsgAlert( cMsgAlert , STR0059 ) //"Alerta"
	Else
		Help( "" , 1 , "A030NOPEN" )
	EndIF
EndIF

Return( lRet )


/*/
эээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддддбдддддддбдддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤┘o    ЁfCloseArqRelЁ Autor Ё Equipe Advanced RH  Ё Data Ё29/02/1996Ё╠╠
╠╠цддддддддддеддддддддддддадддддддадддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤┘o Ё Fecha o arquivo gerado pelo rel╒gio.                       Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁSintaxe   Ё                                                            Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ/*/

Static Function fCloseArqRel(aAliasRelo, nFile, cTxtAlias, lCpyT2Srv, cArqSrv, cTipoArq, nHandle, cArq, cTxt, cArquivo)

//-- Quando o arquivo a ser consultado possuir o mesmo nome de algum arquivo anteriormente lido
//-- Fecha e elimina o arquivo anterior 
If ( cTxtAlias == cTxt)  .and. ( cArq  <> cArquivo ) 
	 
	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Fecha os Arquivos Abertos em AbreArqRel()					 			 Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	IF ( cTipoArq == "D" )
		TxtAliasClose( cTxtAlias )
		/*/
		здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Se copiou para o server, Exclui                           			 Ё
		юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		IF ( lCpyT2Srv )
			If ( fErase(Lower( cArqSrv ) ) < 0 )
					MsgAlert( fError() , STR0059 ) //"Alerta"
			Endif   
		EndIF
	ElseIF (;
				( cTipoArq == "T" );
				.and.;
				( nHandle > 0 );
			)	
		fClose( nHandle ) 
		If ( fErase(Lower( cArqSrv ) ) < 0 )
			MsgAlert( fError() , STR0059 ) //"Alerta"
		Endif   
	EndIF
	aAliasRelo[nFile, 1] := "DEL"
Endif
Return (NIL)

/*/
эээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤┘o    ЁProcForm  Ё Autor Ё Wiliam                Ё Data Ё 29.02.96 Ё╠╠
╠╠цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤┘o Ё Rotina para tratamento da formula                          Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁUso       Ё Generico                                                   Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ/*/
Function ProcForm( cFormula )

Local bErro       := ErrorBlock( { |e| ErrorForm( e ) } )
Local lResult     := .T.

IF ( ValType( cFormula ) == "C" )
	cFormula := AllTrim( cFormula )
	IF Len(cFormula) > 0
		lResult := ExecForm( cFormula )
	EndIF
Else
	lResult := ExecForm( cFormula )
EndIF	

ErrorBlock( bErro )

Return( lResult )

/*/
эээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤┘o    ЁExecForm	Ё Autor Ё Wiliam                Ё Data Ё 29.02.96 Ё╠╠
╠╠цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤┘o Ё Executa a formula e retorna o resultado                    Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁUso       Ё Generico                                                   Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ/*/
Static Function ExecForm( cFormula )

Local xRet
Begin Sequence
	xRet := &(cFormula)
	If !ValType( xRet ) == "C"
		Help(" ",1,"FNOCHAR" )
		xRet := .F.
	Else
		xRet := .T.
	Endif
	RECOVER
	Help(" ",1,"FORMINVAL" , , OemToAnsi( GetTitulo() ) , 5 , 0 )
	xRet := .F.
End Sequence

Return( xRet )
/*/
эээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤┘o    ЁGetTitulo Ё Autor Ё Mauricio MR           Ё Data Ё 16.09.02 Ё╠╠
╠╠цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤┘o Ё Obtem o Titulo em SX3 correspondente a variavel lida       Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁUso       Ё Generico                                                   Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ/*/
Static Function GetTitulo()

Local aArea			:= GetArea()
Local aAreaSX3 		:= SX3->( GetArea() )   
Local aAreaSXA 		:= SXA->( GetArea() )   
Local cCampo		:= UPPER(StrTran(ReadVar(),"M->",""))
Local cTitulo		:= ''          
Local cAlias      	:= ''
Local cFolder   	:= ''

SX3->( dbSetOrder( 02 ) ) 

//-- Obtem informacoes sobre o campo 
IF SX3->(dbSeek(cCampo))
   cTitulo		:=  STR0154 + X3Titulo()
   cAlias		:= GetSx3Cache(cCampo, "X3_ARQUIVO")
   cFolder		:= GetSx3Cache(cCampo, "X3_FOLDER")
    //-- Obtem Informacoes sobre o nome da Pasta se Existir
	If !Empty(cFolder)               
		IF SXA->( dbSeek(cAlias+cFolder) )
		   cTitulo:= STR0153+ALLTRIM(XADESCRIC()) + ' / ' +cTitulo
		Endif	
	Endif
Endif	

RestArea( aAreaSXA )
RestArea( aAreaSX3 ) 
RestArea( aArea) 

Return( cTitulo )

/*/
эээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤┘o    ЁErrorForm Ё Autor Ё Wiliam                Ё Data Ё 29.02.96 Ё╠╠
╠╠цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤┘o Ё Rotina para tratamento de erros da formula                 Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁUso       Ё Generico                                                   Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ/*/
Static Function ErrorForm( oError )

IF ( oError:gencode > 0 )
	Break
ENDIF

Return( NIL )

/*/
зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁfTabPadraoЁ Autor Ё Equipe Advanced RH    Ё Data Ё 15/03/96 Ё
Ё		   Ё		  Ё 	  Ё Ver. II - Igor FranzoiЁ Data Ё 12/11/07 Ё
цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁRetorna um array com a tabela de hor═rio padr└o do turno.   Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   ЁfTabPadrao( aTabTno , cFil , cTurno )						Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁaTab   - Array com os Dados da Tabela                       Ё
Ё          ЁcFil   - Filial Para Pesquisa                               Ё
Ё          ЁcTurno - Turno para Pesquisa                                Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   Ё lRet                                                       Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       Ё Generico                                                   Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function fTabPadrao( aTabTno , cFil , cTurno , lExecQryTop , bCond )

Local aArray		:= {}
Local aCpos			:= Array(2,53)
Local aRet			:= {}
Local aLin		    := {}
Local cPrefixo		:= If( lUseSPJ, "PJ", "RF2" )
Local cAlias		:= If( lUseSPJ, "SPJ", "RF2" )
Local cAliasQuery	:= cAlias

Local cCustoSpace   := Space( GetSx3Cache( "RA_CC" 		, "X3_TAMANHO" ) )
Local cFuncaoSpace  := Space( GetSx3Cache( "RA_CODFUNC" , "X3_TAMANHO" ) )
Local cDeptoSpace	:= Space( GetSx3Cache( "RA_DEPTO" 	, "X3_TAMANHO" ) )
Local cPostoSpace	:= Space( GetSx3Cache( "RA_POSTO" 	, "X3_TAMANHO" ) )
Local cPerSpace		:= Space( GetSx3Cache( "RCH_PER" 	, "X3_TAMANHO" ) )
Local cRotSpace		:= Space( GetSx3Cache( "RCH_ROTEIR" , "X3_TAMANHO" ) )
Local cProcesSpace	:= Space( GetSx3Cache( "RCH_PROCES" , "X3_TAMANHO" ) )
Local cNumPgSpace	:= Space( GetSx3Cache( "RCH_NUMPAG" , "X3_TAMANHO" ) )
Local cCodJorn		:= Space( GetSx3Cache( "RF3_JORN" 	, "X3_TAMANHO" ) )
Local cLI1ESpace	:= Space( GetSx3Cache( "RF3_LI1E" 	, "X3_TAMANHO" ) )
Local cLS1ESpace	:= Space( GetSx3Cache( "RF3_LS1E" 	, "X3_TAMANHO" ) )
Local cLI1SSpace	:= Space( GetSx3Cache( "RF3_LI1S" 	, "X3_TAMANHO" ) )
Local cLS1SSpace	:= Space( GetSx3Cache( "RF3_LS1S" 	, "X3_TAMANHO" ) )
Local cLI2ESpace	:= Space( GetSx3Cache( "RF3_LI2E" 	, "X3_TAMANHO" ) )
Local cLS2ESpace	:= Space( GetSx3Cache( "RF3_LS2E" 	, "X3_TAMANHO" ) )
Local cLI2SSpace	:= Space( GetSx3Cache( "RF3_LI2S" 	, "X3_TAMANHO" ) )
Local cLS2SSpace	:= Space( GetSx3Cache( "RF3_LS2S" 	, "X3_TAMANHO" ) )
Local cLI3ESpace	:= Space( GetSx3Cache( "RF3_LI3E" 	, "X3_TAMANHO" ) )
Local cLS3ESpace	:= Space( GetSx3Cache( "RF3_LS3E" 	, "X3_TAMANHO" ) )
Local cLI3SSpace	:= Space( GetSx3Cache( "RF3_LI3S" 	, "X3_TAMANHO" ) )
Local cLS3SSpace	:= Space( GetSx3Cache( "RF3_LS3S" 	, "X3_TAMANHO" ) )
Local cLI4ESpace	:= Space( GetSx3Cache( "RF3_LI4E" 	, "X3_TAMANHO" ) )
Local cLS4ESpace	:= Space( GetSx3Cache( "RF3_LS4E" 	, "X3_TAMANHO" ) )
Local cLI4SSpace	:= Space( GetSx3Cache( "RF3_LI4S" 	, "X3_TAMANHO" ) )
Local cLS4SSpace	:= Space( GetSx3Cache( "RF3_LS4S" 	, "X3_TAMANHO" ) )
Local cIdExce		:= Space( GetSx3Cache( "P2_ID" 		, "X3_TAMANHO" ) )
Local cTpExce		:= Space( GetSx3Cache( "P2_TPEXCE"	, "X3_TAMANHO" ) )

Local cFilTno		:= ""
Local lRet      	:= .T.
Local nPos			:= 0
Local nLenTab		:= 0
Local nRecno		:= 0
Local nFieldTot		:= 0

Local cQuery	 		:= ""
Local cJoin				:= ""
Local cWhere			:= ""
Local cSvAlias			:= Alias()
Local cCpoRecno 		:= ""
Local lQueryOpened		:= .F.
Local nX				:= 0

Static aSpjFields

Static cQrySpjFields
Static nSpjFields

DEFAULT lExecQryTop	:= .T.

aFill( aCpos[1], Space(1) )

aCpos[1]	:= { 	{||PJ_ENTRA1}	,;	// 01 - Primeira Entrada
					{||PJ_SAIDA1}	,;	// 02 - Primeira Saida
					{||PJ_ENTRA2}	,;	// 03 - Segunda Entrada
					{||PJ_SAIDA2}	,;	// 04 - Segunda Saida
					{||PJ_ENTRA3}	,;	// 05 - Terceira Entrada
					{||PJ_SAIDA3}	,;	// 06 - Terceira Saida
					{||PJ_ENTRA4}	,;	// 07 - Quarta Entrada
					{||PJ_SAIDA4}	,;	// 08 - Quarta Saida
					{||PJ_HRSTRAB}	,;	// 09 - Numero de Horas Trabalhadas 1a. Jornada
					{||PJ_HRSTRA2}	,;	// 10 - Numero de Horas Trabalhadas	2a. Jornada
					{||PJ_HRSTRA3}	,;	// 11 - Numero de Horas Trabalhadas 3a. Jornada
					{||PJ_HRSTRA4}	,;	// 12 - Numero de Horas Trabalhadas 4a. Jornada
					{||PJ_HRSINT1}	,;	// 13 - Numero de Horas 1o. Intervalo
					{||PJ_HRSINT2}	,;	// 14 - Numero de Horas 2o. Intervalo
					{||PJ_HRSINT3}	,;	// 15 - Numero de Horas 3o. Intervalo
					{||""}			,;	// 16 - Marcacao Refere-se ao Proximo Dia
					{||0}			,;	// 17 - TabMarc("SPJ")	Numero de Marcacoes da Tabela
					{||PJ_TPDIA}	,;  // 18 - Tipo do Dia
					{||PJ_SEMANA}	,;	// 19 - Sequencia da Marcacao
					{||Val(PJ_DIA)}	,;  // 20 - Numero Correspondente ao Dia da Semana
					{||"N"}			,;  // 21 - Refere-se a Excecao
					{||""}			,;  // 22 - Motivo da Excecao
					{||PJ_TPEXT}	,;  // 23 - Tipo de Extra Normal
					{||PJ_TPEXTN}	,;	// 24 - Tipo de Extra Noturna
					{||cCustoSpace} ,;	// 25 - Centro de Custo Periodo 1
					{||cCustoSpace} ,;  // 26 - Centro de Custo Periodo 2
					{||cCustoSpace} ,;	// 27 - Centro de Custo Periodo 3
					{||cCustoSpace} ,;	// 28 - Centro de Custo Periodo 4
					{||PJ_NONAHOR} 	,;	// 29 - Aponta Nona Hora
					{||PJ_HORMENO}	,;	// 30 - Limite de Horario Inicial
					{||PJ_HORMAIS}	,;	// 31 - Limite de Horario Final
					{||PJ_JND1CON}	,;	// 32 - 1a. Jornada Continua
					{||PJ_JND2CON}	,;	// 33 - 2a. Jornada Continua
					{||PJ_JND3CON}	,;	// 34 - 3a. Jornada Continua
					{||PJ_JND4CON}	,;	// 35 - 4a. Jornada Continua
					{||PJ_CODREF} 	,;	// 36 - Codigo da Refeicao
					{||nRecno}		,;	// 37 - Recno
					{||cFuncaoSpace},;  // 38 - Codigo de funcao Periodo 1
					{||cFuncaoSpace},;  // 39 - Codigo de funcao Periodo 2
					{||cFuncaoSpace},;  // 40 - Codigo de funcao Periodo 3
					{||cFuncaoSpace},;  // 41 - Codigo de funcao Periodo 4
					{||cLI1ESpace}  ,;  // 42 - Limite inferior 1E
					{||cLS1ESpace}  ,;  // 43 - Limite superior 1E
					{||cLI1SSpace}  ,;  // 44 - Limite inferior 1S
					{||cLS1SSpace}  ,;  // 45 - Limite superior 1S
					{||cLI2ESpace}  ,;  // 46 - Limite inferior 2E
					{||cLS2ESpace}  ,;  // 47 - Limite superior 2E
					{||cLI2SSpace}  ,;  // 48 - Limite inferior 2S
					{||cLS2SSpace}  ,;  // 49 - Limite superior 2S
					{||cLI3ESpace}  ,;  // 50 - Limite inferior 3E
					{||cLS3ESpace}  ,;  // 51 - Limite superior 3E
					{||cLI3SSpace}  ,;  // 52 - Limite inferior 3S
					{||cLS3SSpace}  ,;  // 53 - Limite superior 3S
					{||cLI4ESpace}  ,;  // 54 - Limite inferior 4E
					{||cLS4ESpace}  ,;  // 55 - Limite superior 4E
					{||cLI4SSpace}  ,;  // 56 - Limite inferior 4S
					{||cLS4SSpace}	,;  // 57 - Limite superior 4S
					{||cDeptoSpace} ,;  // 58 - Codigo de departamento Periodo 1
					{||cDeptoSpace} ,;  // 59 - Codigo de departamento Periodo 2
					{||cDeptoSpace} ,;  // 60 - Codigo de departamento Periodo 3
					{||cDeptoSpace} ,;  // 61 - Codigo de departamento Periodo 4
					{||cPostoSpace} ,;  // 62 - Codigo de posto Periodo 1
					{||cPostoSpace} ,;  // 63 - Codigo de posto Periodo 2
					{||cPostoSpace} ,;  // 64 - Codigo de posto Periodo 3
					{||cPostoSpace} ,;  // 65 - Codigo de posto Periodo 4
					{||cProcesSpace},;  // 66 - Codigo de processo
					{||cNumPgSpace} ,;  // 67 - Numero de Pagamento
					{||cPerSpace}   ,;  // 68 - Codigo de Periodo
					{||cRotSpace}   ,;  // 69 - Roteiro de calculo da folhalculo da folha
					{||cCodJorn} 	,;  // 70 - Codigo de Jornada
					{||cIdExce}	    ,;  // 71 - Id da excecao
					{||cTpExce}      ;	// 72 - Tipo de excecao
         }
			
#IFDEF TOP

	IF ( lExInAs400 )
		lExecQryTop	:= .F.
	EndIF	

	IF ( lExecQryTop )
		
		DEFAULT aSpjFields	:= fStructPad()
		DEFAULT nSpjFields 	:= Len( aSpjFields )

		IF ( cQrySpjFields == NIL )
			cQrySpjFields := ""
			For nX := 1 To nSpjFields
				cQrySpjFields += aSpjFields[ nX , 01 ] + ", "
			Next nX
	    EndIF
	EndIF

#ENDIF

DEFAULT aTabTno			:= {}
DEFAULT cTurno			:= Space( GetSx3Cache( "RA_TNOTRAB" , "X3_TAMANHO" ) )
DEFAULT bCond			:= { || .T. }
DEFAULT __nLstTabPadPos	:= 0
                                       
cFil	:= xFilial( cAlias , cFil )
cFilTno := ( cFil + cTurno )

IF ( ( ( nLenTab := Len( aTabTno ) ) == 0 ) .or. ( __nLstTabPadPos > nLenTab ) )
	__nLstTabPadPos := 0
EndIF

IF ( ( __nLstTabPadPos == 0 ) .or. !( ( aTabTno[ __nLstTabPadPos , 01 ] + aTabTno[ __nLstTabPadPos , 02 ] ) == cFilTno ) )
	IF ( ( nPos := aScan( aTabTno , { |x| x[1]+x[2] == cFilTno } ) ) == 0 ) .AND. !Empty(cTurno) 
		( aAdd( aTabTno, { cFil , cTurno , aArray } ) , ( __nLstTabPadPos := ( nLenTab := Len( aTabTno ) ) ) )
		#IFDEF TOP
			IF ( lExecQryTop )
				cCpoRecno	:= IF( lExInAs400 , "RRN("+InitSqlName( cAlias )+")", "R_E_C_N_O_" )
				cAliasQuery := ( "__Q" + cAliasQuery + "QRY" )
				cQuery := "SELECT "
				cQuery += cQrySpjFields
				If lUseSPJ
					cQuery += cCpoRecno + " RECNO "
				Else
					cQuery += cAlias+"."+cCpoRecno + " RECNO "
				EndIf
				cQuery += " FROM "
				If lUseSPJ
					cQuery += InitSqlName( cAlias )
					cWhere += " WHERE "
					cWhere += "PJ_FILIAL='"+cFil+"'"
					cWhere += " AND "
					cWhere += "PJ_TURNO='"+cTurno+"'"
					cWhere += " AND "
					cWhere += "D_E_L_E_T_=' ' "
				Else
					cJoin += InitSqlName("RF2") + " RF2 "
					cJoin += " INNER JOIN " + InitSqlName("RF4") + " RF4 ON RF2.RF2_HOR = RF4.RF4_HOR "
					cJoin += " INNER JOIN " + InitSqlName("RF5") + " RF5 ON RF2.RF2_TIPOD = RF5.RF5_TIPO AND RF5.RF5_DIA  = RF4.RF4_DIA "
					cJoin += " INNER JOIN " + InitSqlName("RF3") + " RF3 ON RF4.RF4_JORN = RF3.RF3_JORN "
					cWhere += " WHERE "
					cWhere += " RF2.RF2_FILIAL = '"+cFil+"'"
					cWhere += " AND RF3.RF3_FILIAL = '"+cFil+"'"
					cWhere += " AND RF4.RF4_FILIAL = '"+cFil+"'"
					cWhere += " AND RF5.RF5_FILIAL = '"+cFil+"'"
					cWhere += " AND RF2.RF2_TURNO = '"+cTurno+"'"
					cWhere += " AND RF2.D_E_L_E_T_=' '"
					cWhere += " AND RF3.D_E_L_E_T_=' '"
				EndIf
				cQuery += cJoin + cWhere
				cQuery += " ORDER BY " + SqlOrder( (cAlias)->( IndexKey() ) )
				cQuery := ChangeQuery( cQuery )
				IF ( lQueryOpened := MsOpenDbf(.T.,"TOPCONN",TcGenQry(NIL,NIL,cQuery),cAliasQuery,.F.,.T.) )
					For nX := 1 To nSpjFields
						IF !( aSpjFields[ nX , 02 ] == "C" )
							TcSetField(cAliasQuery,aSpjFields[nX,01],aSpjFields[nX,02],aSpjFields[nX,03],aSpjFields[nX,04])
						EndIF
					Next nX
					lRet := ( cAliasQuery )->( !Eof() )
				Else
					cAliasQuery	:= cAlias
					lRet := ( cAliasQuery )->( dbSeek( cFilTno ) )
				EndIF
			Else
				cAliasQuery	:= cAlias
				lRet := ( cAliasQuery )->( dbSeek( cFilTno ) )
			EndIF
		#ELSE
			lRet := ( cAliasQuery )->( dbSeek( cFilTno ) )
		#ENDIF
			IF ( lRet )
				While ( cAliasQuery )->( !Eof() .and. ( cFilTno == (&(cPrefixo+"_FILIAL")+&(cPrefixo+"_TURNO")) ) )
					IF !( cAliasQuery )->( Eval( bCond ) )
						( cAliasQuery )->( dbSkip() )
						Loop
					EndIF
					#IFNDEF TOP
						nRecno := ( cAliasQuery )->( Recno() )
						If !lUseSpj
							fMntTabPad( cFil,;
										(cAliasQuery)->(RF2_HOR),;
										(cAliasQuery)->(RF2_TIPOD),;
										(cAliasQuery)->(RF2_SEMANA),;
										@aRet,;
										nRecno,;
										lExecQryTop,;
										lQueryOpened,;
										cAliasQuery )
							aTabTno[nLenTab,3 ] := aClone( aRet )
						Else  
						     aLin := {}
							aEval( aCpos[1], { |x| aAdd( aTabTno[nLenTab,3 ], ( cAliasQuery )->(Eval(x) )) } )						
							( cAliasQuery )->( aAdd( aTabTno[nLenTab,3 ] , aClone(aLin)  ) )
						EndIf						
					#ELSE
						IF ( ( lExecQryTop ) .and. ( lQueryOpened ) )
							nRecno := ( cAliasQuery )->( RECNO )
						Else           
							nRecno := ( cAliasQuery )->( Recno() )
						EndIF
						/*/
						зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
						ЁMonta os registros a partir das tabelas RF3/RF4/RF5		  Ё
						ЁCaso nao esteja utilizando SPJ								  Ё						
						юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
						If !lUseSpj
							fMntTabPad( cFil,;
										(cAliasQuery)->(RF2_HOR),;
										(cAliasQuery)->(RF2_TIPOD),;
										(cAliasQuery)->(RF2_SEMANA),;
										@aRet,;
										nRecno,;
										lExecQryTop,;
										lQueryOpened,;
										cAliasQuery )
							aTabTno[nLenTab,3 ] := aClone( aRet )
						Else
						    aLin := {}
							aEval( aCpos[1], { |x| aAdd( aLin, ( cAliasQuery )->(Eval(x) )) } )
							( cAliasQuery )->( aAdd( aTabTno[nLenTab,3 ] , aClone(aLin)  ) )
						EndIf
					#EndIF
					( cAliasQuery )->( dbSkip() )	                                                            
				End While
			EndIF
		#IFDEF TOP
			IF ( ( lQueryOpened ) .and. ( Select( cAliasQuery ) > 0 ) )
				( cAliasQuery )->( dbCloseArea() )
				dbSelectArea( cAlias )
				If ( !Empty(cSvAlias) .And. Select( cSvAlias ) > 0 )
					dbSelectArea( cSvAlias )
				EndIf
			EndIF
		#ENDIF
	Else
	   	If nPos > 0
			__nLstTabPadPos := nPos
		Endif
	EndIF
EndIF

Return( lRet )

/*/
зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁfStructPadЁ Autor Ё Igor Franzoi	      Ё Data Ё 13/11/07 Ё
цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁRetorna um array com a estrutura(s) tabela de hor═rio padr└oЁ
Ё		   Ёpara utilizar na query										Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   ЁfStructPad()												Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ															Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   Ё aStruct - Array que contem os campos da query              Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       Ё Generico                                                   Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
#IFDEF TOP
Static Function fStructPad()

Local aStruct := {}

Local cAlias 	:= ""
Local cAliasSPJ := "SPJ"

Local nCont
Local nFields
Local aAuxStruct := {}

If lUseSPJ
	aStruct := (cAliasSPJ)->(dbStruct())
Else
	For nCont := 1 To 4
		If( nCont == 1, cAlias := "RF2", If( nCont == 2, cAlias := "RF3", If( nCont == 3, cAlias := "RF4", cAlias := "RF5" ) ) )
		aAuxStruct := (cAlias)->(dbStruct())
		For nFields := 1 To Len(aAuxStruct)
			aAdd(aStruct, aAuxStruct[nFields])
		Next
	Next
EndIf

Return ( aStruct )
#ENDIF

/*/
зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁfMntTabPadЁ Autor Ё Igor Franzoi	      Ё Data Ё 14/11/07 Ё
цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁSeleciona os dados do RF4/RF5/RF3							Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   ЁfMntTabPad()												Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ cFil = filial												Ё
Ё		   Ё cHor = codigo do horario									Ё
Ё		   Ё cDia = codigo do tipo de dia								Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   Ё aRet														Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       Ё Generico                                                   Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function fMntTabPad( cFil, cHor, cDia, cSem, aRet, nRecno, lExecQryTop, lQueryOpened, cAliasQuery)

Local aCpos	  := {}
Local nCont	  := 0
Local aArea   := GetArea()

Local cAliasRF3	 := "RF3"
Local cAliasRF4  := "RF4"

Local nOrderRf4 := 0

Local aRetRF5 	 := {}

DEFAULT aRet := {}

If ( lExecQryTop .and. lQueryOpened )

	(cAliasQuery)->( aAdd( aRet,{  RF3_ENTRA1		,; // 01 - Primeira Entrada
								   RF3_SAIDA1		,; // 02 - Primeira Saida
								   RF3_ENTRA2		,; // 03 - Segunda Entrada
								   RF3_SAIDA2		,; // 04 - Segunda Saida
								   RF3_ENTRA3		,; // 05 - Terceira Entrada
								   RF3_SAIDA3		,; // 06 - Terceira Saida
								   RF3_ENTRA4		,; // 07 - Quarta Entrada
								   RF3_SAIDA4		,; // 08 - Quarta Saida
								   RF3_HRTRAB	    ,; // 09 - Numero de Horas Trabalhadas 1a. Jornada
								   RF3_HRTRA2		,; // 10 - Numero de Horas Trabalhadas	2a. Jornada
								   RF3_HRTRA3		,; // 11 - Numero de Horas Trabalhadas 3a. Jornada
								   RF3_HRTRA4		,; // 12 - Numero de Horas Trabalhadas 4a. Jornada
								   RF3_HRINT1  		,; // 13 - Numero de Horas 1o. Intervalo
								   RF3_HRINT2		,; // 14 - Numero de Horas 2o. Intervalo
								   RF3_HRINT3		,; // 15 - Numero de Horas 3o. Intervalo
								   ""       		,; // 16 - Marcacao Refere-se ao Proximo Dia
								   0				,; // 17 - TabMarc("SPJ")	Numero de Marcacoes da Tabela
								   RF5_TPDIA		,; // 18 - Tipo do Dia
								   RF2_SEMANA		,; // 19 - Sequencia da Marcacao
								   Val(RF5_DIA)		,;  // 20 - Numero Correspondente ao Dia da Semana
								   "N"				,; // 21 - Refere-se a Excecao
								   ""				,; // 22 - Motivo da Excecao
								   RF5_TPEXT		,; // 23 - Tipo de Extra Normal
								   RF5_TPEXTN		,; // 24 - Tipo de Extra Noturna
								   ""    			,; // 25 - Centro de Custo Periodo 1
								   ""    			,; // 26 - Centro de Custo Periodo 2
								   ""    			,; // 27 - Centro de Custo Periodo 3
								   ""    			,; // 28 - Centro de Custo Periodo 4
								   RF5_NONAHR   	,; // 29 - Aponta Nona Hora
								   RF3_HRMENO    	,; // 30 - Limite de Horario Inicial
								   RF3_HRMAIS    	,; // 31 - Limite de Horario Final
								   RF3_JND1CO     	,; // 32 - 1a. Jornada Continua
								   RF3_JND2CO     	,; // 33 - 2a. Jornada Continua
								   RF3_JND3CO     	,; // 34 - 3a. Jornada Continua
								   RF3_JND4CO     	,; // 35 - 4a. Jornada Continua
								   RF5_CODREF   	,; // 36 - Codigo da Refeicao
	 							   Recno			,; // 37 - Recno
								   ""				,; // 38 - Codigo de funcao Periodo 1
								   ""				,; // 39 - Codigo de funcao Periodo 1
								   ""				,; // 40 - Codigo de funcao Periodo 1
								   ""				,; // 41 - Codigo de funcao Periodo 1
								   RF3_LI1E     	,; // 42 - Limite inferior 1E
								   RF3_LS1E     	,; // 43 - Limite superior 1E
								   RF3_LI1S     	,; // 44 - Limite inferior 1S
								   RF3_LS1S     	,; // 45 - Limite superior 1S
								   RF3_LI2E     	,; // 46 - Limite inferior 2E
								   RF3_LS2E     	,; // 47 - Limite superior 2E
								   RF3_LI2S     	,; // 48 - Limite inferior 2S
								   RF3_LS2S     	,; // 49 - Limite superior 2S
								   RF3_LI3E     	,; // 50 - Limite inferior 3E
								   RF3_LS3E     	,; // 51 - Limite superior 3E
								   RF3_LI3S     	,; // 52 - Limite inferior 3S
								   RF3_LS3S     	,; // 53 - Limite superior 3S
								   RF3_LI4E     	,; // 54 - Limite inferior 4E
								   RF3_LS4E     	,; // 55 - Limite superior 4E
								   RF3_LI4S     	,; // 56 - Limite inferior 4S
								   RF3_LS4S			,; // 57 - Limite superior 4S
								   ""    			,; // 58 - Codigo de departamento Periodo 1
								   ""    			,; // 59 - Codigo de departamento Periodo 2
								   ""    			,; // 60 - Codigo de departamento Periodo 3
								   ""    			,; // 61 - Codigo de departamento Periodo 4
								   ""    			,; // 62 - Codigo de posto Periodo 1
								   ""    			,; // 63 - Codigo de posto Periodo 2
								   ""    			,; // 64 - Codigo de posto Periodo 3
								   ""    			,; // 65 - Codigo de posto Periodo 4
								   ""   			,; // 66 - Codigo de processo
								   ""     			,; // 67 - Numero de Pagamento
								   ""       		,; // 68 - Codigo de Periodo
								   ""       		,; // 69 - Roteiro de calculo da folhalculo da folha
								   RF3_JORN			,; // 70 - Codigo de Jornada
								   ""				,; // 71 - Id da excecao
								   ""				 ; // 72 - Tipo de Excecao
								};
			 			);
				)
					 			
Else

	nOrderRf4 := (cAliasRF4)->(RetOrder("RF4", "RF4_FILIAL+RF4_HOR+RF4_DIA"))
	
	(cAliasRF4)->(dbSetOrder(nOrderRf4))
	            
	aCpos		:= { 	  "RF3_ENTRA1"	,;	// 01 - Primeira Entrada
						  "RF3_SAIDA1" 	,;	// 02 - Primeira Saida
						  "RF3_ENTRA2" 	,;	// 03 - Segunda Entrada
						  "RF3_SAIDA2" 	,;	// 04 - Segunda Saida
						  "RF3_ENTRA3" 	,;	// 05 - Terceira Entrada
						  "RF3_SAIDA3" 	,;	// 06 - Terceira Saida
						  "RF3_ENTRA4" 	,;	// 07 - Quarta Entrada
						  "RF3_SAIDA4" 	,;	// 08 - Quarta Saida
						  "RF3_HRTRAB" 	,;	// 09 - Numero de Horas Trabalhadas 1a. Jornada
						  "RF3_HRTRA2" 	,;	// 10 - Numero de Horas Trabalhadas	2a. Jornada
						  "RF3_HRTRA3" 	,;	// 11 - Numero de Horas Trabalhadas 3a. Jornada
						  "RF3_HRTRA4" 	,;	// 12 - Numero de Horas Trabalhadas 4a. Jornada
						  "RF3_HRINT1" 	,;	// 13 - Numero de Horas 1o. Intervalo
						  "RF3_HRINT2" 	,;	// 14 - Numero de Horas 2o. Intervalo
						  "RF3_HRINT3" 	,;	// 15 - Numero de Horas 3o. Intervalo
						  "RF3_HRMENO"	,;	// 16 - Limite de Horario Inicial
						  "RF3_HRMAIS"	,;	// 17 - Limite de Horario Final
						  "RF3_JND1CO" 	,;	// 18 - 1a. Jornada Continua
						  "RF3_JND2CO" 	,;	// 19 - 2a. Jornada Continua
						  "RF3_JND3CO" 	,;	// 20 - 3a. Jornada Continua
						  "RF3_JND4CO" 	,;	// 21 - 4a. Jornada Continua
						  "RF3_LI1E"    ,; 	// 22 - Limite inferior 1E
						  "RF3_LS1E"    ,; 	// 23 - Limite superior 1E
						  "RF3_LI1S"    ,; 	// 24 - Limite inferior 1S
						  "RF3_LS1S"    ,; 	// 25 - Limite superior 1S
						  "RF3_LI2E"    ,; 	// 26 - Limite inferior 2E
						  "RF3_LS2E"    ,; 	// 27 - Limite superior 2E
						  "RF3_LI2S"    ,; 	// 28 - Limite inferior 2S
						  "RF3_LS2S"    ,; 	// 29 - Limite superior 2S
						  "RF3_LI3E"    ,; 	// 30 - Limite inferior 3E
						  "RF3_LS3E"    ,; 	// 31 - Limite superior 3E
						  "RF3_LI3S"    ,; 	// 32 - Limite inferior 3S
						  "RF3_LS3S"    ,; 	// 33 - Limite superior 3S
						  "RF3_LI4E"    ,; 	// 34 - Limite inferior 4E
						  "RF3_LS4E"    ,; 	// 35 - Limite superior 4E
						  "RF3_LI4S"    ,; 	// 36 - Limite inferior 4S
						  "RF3_LS4S"	,;  // 37 - Limite superior 4S   
	  					  "RF3_JORN"	 ;  // 38 - Jornada
				}
	For nCont := 1 To 7
		If ( (cAliasRF4)->( dbSeek(cFil+cHor+AllTrim(Str(nCont)))))
			
			aRetRF5 := fFindRF5( cFil, cDia, (cAliasRF4)->(RF4_DIA) )
			
			If (cAliasRF3)->( dbSeek(cFil+(cAliasRF4)->(RF4_JORN)) )
				/*/
				зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				ЁConverte campos de jornada em variaveis para calculo de horasЁ
				Ёtrabalhadas conforme Turno associado a jornada lida.		  Ё			
				юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
				aEval( aCpos,{ |x| &( "M->" + x ):= (cAliasRF3)->&(x)  } )
				
				M->RF3_HRSTOT:= fHrsTrabGat("T","RF3","MB")
				M->RF3_HRTRA2:= fHrsTrabGat("H","RF3","MB","2")
				M->RF3_HRTRA3:= fHrsTrabGat("H","RF3","MB","3")
				M->RF3_HRTRA4:= fHrsTrabGat("H","RF3","MB","4")
				M->RF3_HRTRAB:= fHrsTrabGat("H","RF3","MB","1")
				(cAliasRF3)->( aAdd( aRet,{  M->RF3_ENTRA1		,; // 01 - Primeira Entrada
											 M->RF3_SAIDA1		,; // 02 - Primeira Saida
											 M->RF3_ENTRA2		,; // 03 - Segunda Entrada
											 M->RF3_SAIDA2		,; // 04 - Segunda Saida
											 M->RF3_ENTRA3		,; // 05 - Terceira Entrada
											 M->RF3_SAIDA3		,; // 06 - Terceira Saida
											 M->RF3_ENTRA4		,; // 07 - Quarta Entrada
											 M->RF3_SAIDA4		,; // 08 - Quarta Saida
											 M->RF3_HRTRAB	    ,; // 09 - Numero de Horas Trabalhadas 1a. Jornada
											 M->RF3_HRTRA2		,; // 10 - Numero de Horas Trabalhadas	2a. Jornada
											 M->RF3_HRTRA3		,; // 11 - Numero de Horas Trabalhadas 3a. Jornada
											 M->RF3_HRTRA4		,; // 12 - Numero de Horas Trabalhadas 4a. Jornada
											 M->RF3_HRINT1  	,; // 13 - Numero de Horas 1o. Intervalo
											 M->RF3_HRINT2		,; // 14 - Numero de Horas 2o. Intervalo
											 M->RF3_HRINT3		,; // 15 - Numero de Horas 3o. Intervalo
											 ""       			,; // 16 - Marcacao Refere-se ao Proximo Dia
											 0					,; // 17 - TabMarc("SPJ")	Numero de Marcacoes da Tabela
											 aRetRF5[1,2]		,; // 18 - Tipo do Dia
											 cSem				,; // 19 - Sequencia da Marcacao
											 Val(aRetRF5[1,1])	,;  // 20 - Numero Correspondente ao Dia da Semana
											 "N"				,; // 21 - Refere-se a Excecao
											 ""					,; // 22 - Motivo da Excecao
											 aRetRF5[1,4]		,; // 23 - Tipo de Extra Normal
											 aRetRF5[1,5]		,; // 24 - Tipo de Extra Noturna
											 ""    				,; // 25 - Centro de Custo Periodo 1
											 ""    				,; // 26 - Centro de Custo Periodo 2
											 ""    				,; // 27 - Centro de Custo Periodo 3
											 ""    				,; // 28 - Centro de Custo Periodo 4
											 aRetRF5[1,6]   	,; // 29 - Aponta Nona Hora
											 M->RF3_HRMENO    	,; // 30 - Limite de Horario Inicial
											 M->RF3_HRMAIS    	,; // 31 - Limite de Horario Final
											 M->RF3_JND1CO     	,; // 32 - 1a. Jornada Continua
											 M->RF3_JND2CO     	,; // 33 - 2a. Jornada Continua
											 M->RF3_JND3CO     	,; // 34 - 3a. Jornada Continua
											 M->RF3_JND4CO     	,; // 35 - 4a. Jornada Continua
											 aRetRF5[1,3]   	,; // 36 - Codigo da Refeicao
	 										 nRecno				,; // 37 - Recno
											 ""					,; // 38 - Codigo de funcao Periodo 1
											 ""					,; // 39 - Codigo de funcao Periodo 1
											 ""					,; // 40 - Codigo de funcao Periodo 1
											 ""					,; // 41 - Codigo de funcao Periodo 1
											 M->RF3_LI1E     	,; // 42 - Limite inferior 1E
											 M->RF3_LS1E     	,; // 43 - Limite superior 1E
											 M->RF3_LI1S     	,; // 44 - Limite inferior 1S
											 M->RF3_LS1S     	,; // 45 - Limite superior 1S
											 M->RF3_LI2E     	,; // 46 - Limite inferior 2E
											 M->RF3_LS2E     	,; // 47 - Limite superior 2E
											 M->RF3_LI2S     	,; // 48 - Limite inferior 2S
											 M->RF3_LS2S     	,; // 49 - Limite superior 2S
											 M->RF3_LI3E     	,; // 50 - Limite inferior 3E
											 M->RF3_LS3E     	,; // 51 - Limite superior 3E
											 M->RF3_LI3S     	,; // 52 - Limite inferior 3S
											 M->RF3_LS3S     	,; // 53 - Limite superior 3S
											 M->RF3_LI4E     	,; // 54 - Limite inferior 4E
											 M->RF3_LS4E     	,; // 55 - Limite superior 4E
											 M->RF3_LI4S     	,; // 56 - Limite inferior 4S
											 M->RF3_LS4S		,; // 57 - Limite superior 4S
											 ""    				,; // 58 - Codigo de departamento Periodo 1
											 ""    				,; // 59 - Codigo de departamento Periodo 2
											 ""    				,; // 60 - Codigo de departamento Periodo 3
											 ""    				,; // 61 - Codigo de departamento Periodo 4
											 ""    				,; // 62 - Codigo de posto Periodo 1
											 ""    				,; // 63 - Codigo de posto Periodo 2
											 ""    				,; // 64 - Codigo de posto Periodo 3
											 ""    				,; // 65 - Codigo de posto Periodo 4
											 ""   				,; // 66 - Codigo de processo
											 ""     			,; // 67 - Numero de Pagamento
											 ""       			,; // 68 - Codigo de Periodo
											 ""       			,; // 69 - Roteiro de calculo da folhalculo da folha
											 M->RF3_JORN		,; // 70 - Codigo de Jornada
											 ""					,; // 71 - Id da excecao
											 ""				 	; // 72 - Tipo de Excecao
									};
			 					);
					 		)
			EndIF
		EndIf
	Next

EndIf

RestArea( aArea )
	
Return aRet

/*/
зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁfFindRf5  Ё Autor Ё Igor Franzoi		  Ё Data Ё 14/11/07 Ё
цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁSeleciona os dados dos RF4									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   ЁfFindRf5()													Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ cFil = filial												Ё
Ё		   Ё cDia = codigo do tipo de dia								Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   Ё aResRF5													Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       Ё Generico                                                   Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function fFindRf5( cFil, cDia, cSeq )

Local cKey	    := cFil+cDia+cSeq
Local cAlias    := "RF5"
Local aArea		:= GetArea()
Local aResRF5   := {}
Local nOrderRf5 := (cAlias)->(RetOrder("RF5", "RF5_FILIAL+RF5_TIPO+RF5_DIA"))

(cAlias)->(dbSetOrder(nOrderRf5))
(cAlias)->(dbSeek(cKey))

aAdd( aResRF5, { (cAlias)->( RF5_DIA    ),;
				 (cAlias)->( RF5_TPDIA  ),;
				 (cAlias)->( RF5_CODREF ),;
				 (cAlias)->( RF5_TPEXT  ),;
				 (cAlias)->( RF5_TPEXTN ),;
				 (cAlias)->( RF5_NONAHR ); 
				};
	)
	
RestArea(aArea)

Return aResRF5

/*/
зддддддддддбдддддддддддддбдддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁGetInfoPosTabЁAutorЁ Marinaldo de Jesus   Ё Data Ё17/10/2001Ё
цддддддддддедддддддддддддадддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁRetorna o Conteudo da Tabela de Horario Padrao Conforme   osЁ
Ё          ЁParametros Passados											Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁPonto Eletronico                                            Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁnSerFim                            							Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function GetInfoPosTab(	nPosTip 	,;	//01 -> Posicao em aTabCalend para Obtencao da Informacao
						cFlagMarc	,;	//02 -> Flag da Marcacao "1E,1S,..."
						dData		,;	//03 -> Data em aTabCalend
						aTabCalend	,;	//04 -> Calendario de Marcacoes
						aTabPadrao	,;	//05 -> Tabela de Horario Padrao
						dPerIni		,;	//06 -> Periodo Inicial de Apontamento
						dPerFim		,;	//07 -> Periodo Final de Apontamento	
						lFunc		,;	//08 -> Informacao Referente a Funcionario
						cTno		,;	//09 -> Turno de Trabalho
						cSeq		,;	//10 -> Sequencia
						cFil		,;	//11 -> Filial
						lExce		,;  //12 -> Carrega Excecoes 
						bAscan		,;	//13 -> Bloco para Pesquisa em aTabCalend
						nRetPosTab  ,;	//14 -> Retorno da Posicao do aTabCalend 	
					    lSearchAll )    //15 -> Se soma todos os elementos do aTabCalend referentes a dData passada

Local aSvTabsCal	:= {}
Local dDataApo		:= ""
Local lContinua		:= .T.
Local lLastMarc		:= .F.
Local lAddInfo		:= .F.
Local nPosTab		:= 0
Local nPosTpIni		:= 0
Local nLenCalend	:= 0
Local uRet			:= NIL

IF ( ( Type("aTnoGetInfoTab") == "U" ) .or. ( Type("aTnoGetInfoTab") != "A" ) )
	Private aTnoGetInfoTab := {}
EndIF	

DEFAULT nPosTip		:= CALEND_POS_TURNO
DEFAULT cFlagMarc	:= "1E"
DEFAULT dData		:= dDataBase
DEFAULT aTabCalend	:= {}
DEFAULT aTabPadrao	:= {}
DEFAULT dPerIni		:= Ctod("//")
DEFAULT dPerFim		:= Ctod("//")
DEFAULT lFunc		:= .T.
DEFAULT cTno		:= SRA->RA_TNOTRAB
DEFAULT cSeq		:= SRA->RA_SEQTURN
DEFAULT cFil		:= SRA->RA_FILIAL
DEFAULT lExce		:= .F.
DEFAULT bAscan		:= { |x| x[CALEND_POS_DATA] == dData .and. x[CALEND_POS_TIPO_MARC] == cFlagMarc }
DEFAULT lSearchAll  := .F.

IF ( lLastMarc := ( ( cFlagMarc := Upper( AllTrim( cFlagMarc ) ) ) == "__LASTMARC__" ) )
	cFlagMarc := "1E"
EndIF

/*/
здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
ЁRecurso para tornar a carga dos inicializadores mais rapida na troca de turno Ё
юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
If lAddInfo := Type("aIniPadFun") <> "U" .And. IsInCallStack("INITPAD")
	If Len(aIniPadFun) > 0
		nPosTpIni := Ascan( aIniPadFun, {|x| x[1]+x[2]+x[5] == SRA->RA_FILIAL + SRA->RA_MAT + cValToChar(nPosTip) } )
		If nPosTpIni > 0
			Return( aIniPadFun[nPosTpIni,6] )	
		EndIf
	EndIf
EndIf

/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
ЁVerifica se o Calendario foi passado como parametro		  Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
IF Empty( aTabCalend )                                                    
	/*/
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Somente considera a tabela SPO qdo for montar o Calendario  Ё
	Ё por Turno e para um funcionario							  Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
    IF !lFunc
		IF ( Empty( dPerIni ) .or. Empty( dPerFim ) )
			lContinua := PerAponta( @dPerIni , @dPerFim , dData , NIL , cFil )
		EndIF
	Else

		If Type("oPeriodo") == "U"
			SetMemVar("oPeriodo" , RHPERIODO():New() , .T. , .T. )
		EndIf
		oPeriodo:cProcesso := SRA->RA_PROCES
		oPeriodo:GetPer() 
			
		If ( Empty( dPerIni ) .or. Empty( dPerFim ) )
			lContinua := PerAponta( @dPerIni , @dPerFim , dData , NIL , cFil )
		EndIF	
	Endif
	IF ( lContinua )
        /*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Salva o Conteudo do Calendario por Turno        			  Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		aSvTabsCal := GetTabCal()
        /*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Cria o Calendario de Marcacoes                  			  Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		lContinua := CriaCalend(	dPerIni									,; //01 -> Data Inicial do Periodo
					 				Min( dPerFim , dData )					,; //02 -> Data Final do Periodo
									cTno									,; //03 -> Turno Para a Montagem do Calendario
									cSeq									,; //04 -> Sequencia Inicial para a Montagem Calendario
									@aTabPadrao								,; //05 -> Array Tabela de Horario Padrao
									@aTabCalend								,; //06 -> Array com o Calendario de Marcacoes
									cFil									,; //07 -> Filial para a Montagem da Tabela de Horario
									IF(lFunc,SRA->RA_MAT,NIL)				,; //08 -> Matricula para a Montagem da Tabela de Horario
									IF(lFunc .and. lExce,SRA->RA_CC,NIL)	,; //09 -> Centro de Custo para a Montagem da Tabela
									IF(lFunc,@aTnoGetInfoTab,NIL)			,; //10 -> Array com as Trocas de Turno
									NIL										,; //11 -> Array com Todas as Excecoes do Periodo
									NIL 									,; //12 -> Se executa Query para a Montagem da Tabela Padrao
									.F.										,; //13 -> Se executa a funcao se sincronismo do calendario
									NIL										,; //14 -> Se Forca a Criacao de Novo Calendario
									NIL  									,; //15 -> Array com marcacoes para tratamento de Turnos Opcionais
									.F.  									,; //16 -> .T. Determina a Criacao/Carga do Calendario Fisico
									NIL										,; //17 -> .T. Caso exista calendario fisico 
									NIL										,; //18 -> Data inicial do calendario fisico
									NIL										,; //19 -> Data final do calendario fisico 
									.F. 									; //20 -> .T. determina que o calendario sera gravado no caso de nao existir						
								)
	EndIF
EndIF

/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
ЁEfetua a Pesquisa e Retorna o Conteudo do Elemento Desejado  Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
IF ( lContinua )
	IF ( ( nPosTab := aScan( aTabCalend , bAscan ) ) > 0 )
		IF ( ( nPosTip > 0 ) .and. nPosTip <= Len( aTabCalend[ nPosTab ] ) )
			If lSearchAll   
				If Valtype(aTabCalend[ nPosTab, nPosTip ]) == "N" 
					uRet:= 0
					While nPosTab <= len(aTabCalend) .And. aTabCalend[ nPosTab,CALEND_POS_DATA ] == dData
						uRet += aTabCalend[ nPosTab, nPosTip ]
						++nPosTab
					End 
				Endif
			Else
				IF ( lLastMarc )
					dDataApo		:= aTabCalend[ nPosTab , CALEND_POS_DATA_APO ]
					nLenCalend	:= Len( aTabCalend )
					While ( nPosTab <= nLenCalend )
						IF !( dDataApo == aTabCalend[ nPosTab , CALEND_POS_DATA_APO ] )
							--nPosTab
							Exit
						EndIF
						IF ( nPosTab < nLenCalend )
							++nPosTab
						Else
							Exit
						EndIF
					End While	
				EndIF
				IF ( ValType( aTabCalend[ nPosTab , nPosTip ] ) == "A" )
					uRet := aClone( aTabCalend[ nPosTab , nPosTip ] )
				Else
					uRet := aTabCalend[ nPosTab , nPosTip ]
				EndIF	      
			Endif
		EndIF
	EndIF    
EndIF

If uRet # NIL .And. lAddInfo
	If Len(aIniPadFun) > 0 .And. ( nPosTpIni := Ascan( aIniPadFun, {|x| x[1]+x[2]+x[5] == SRA->RA_FILIAL + SRA->RA_MAT + cValToChar(nPosTip) } ) ) > 0
		aIniPadFun[nPosTpIni, 6] := aTabCalend[ nPosTab , nPosTip ]
	Else
		aAdd( aIniPadFun, { SRA->RA_FILIAL, SRA->RA_MAT, SRA->RA_TNOTRAB, SRA->RA_SEQTURN, "14", aTabCalend[ nPosTab , 14 ]} )
		aAdd( aIniPadFun, { SRA->RA_FILIAL, SRA->RA_MAT, SRA->RA_TNOTRAB, SRA->RA_SEQTURN,  "8", aTabCalend[ nPosTab , 08 ]} )
		aAdd( aIniPadFun, { SRA->RA_FILIAL, SRA->RA_MAT, SRA->RA_TNOTRAB, SRA->RA_SEQTURN, "23", aTabCalend[ nPosTab , 23 ]} )
	EndIf
EndIf

/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
ЁSe nao Obteve retorno Carrega valores DEFAULT                Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
IF ( ( uRet == NIL ) .and. ( nPosTip > 0 ) )

	nRetPosTab	:= 0

	Do Case 
		Case nPosTip == CALEND_POS_DATA			; uRet := Ctod("//")
		Case nPosTip == CALEND_POS_ORDEM		; uRet := ""
		Case nPosTip == CALEND_POS_HORA			; uRet := 0
		Case nPosTip == CALEND_POS_TIPO_MARC	; uRet := ""
		Case nPosTip == CALEND_POS_NUM_MARC 	; uRet := 0
		Case nPosTip == CALEND_POS_TIPO_DIA 	; uRet := ""
		Case nPosTip == CALEND_POS_HRS_TRABA	; uRet := 0
		Case nPosTip == CALEND_POS_SEQ_TURNO	; uRet := ""
		Case nPosTip == CALEND_POS_HRS_INTER	; uRet := 0
		Case nPosTip == CALEND_POS_EXCECAO		; uRet := ""
		Case nPosTip == CALEND_POS_MOT_EXECAO	; uRet := ""
		Case nPosTip == CALEND_POS_TIPO_HE_NOR	; uRet := ""
		Case nPosTip == CALEND_POS_TIPO_HE_NOT	; uRet := ""
		Case nPosTip == CALEND_POS_TURNO		; uRet := ""
		Case nPosTip == CALEND_POS_CC			; uRet := ""
		Case nPosTip == CALEND_POS_PG_NONA_HORA	; uRet := ""
		Case nPosTip == CALEND_POS_LIM_MARCACAO	; uRet := { Ctod("//") , 0 }
		Case nPosTip == CALEND_POS_COD_REFEICAO	; uRet := ""
		Case nPosTip == CALEND_POS_FERIADO		; uRet := .F.
		Case nPosTip == CALEND_POS_TP_HE_FER_NR	; uRet := ""
		Case nPosTip == CALEND_POS_TP_HE_FER_NT	; uRet := ""
		Case nPosTip == CALEND_POS_DESC_FERIADO ; uRet := ""
		Case nPosTip == CALEND_POS_REGRA		; uRet := ""
		Case nPosTip == CALEND_POS_AFAST		; uRet := .F.
		Case nPosTip == CALEND_POS_TIP_AFAST	; uRet := ""
		Case nPosTip == CALEND_POS_INI_AFAST	; uRet := Ctod("//")
		Case nPosTip == CALEND_POS_FIM_AFAST	; uRet := Ctod("//")
		Case nPosTip == CALEND_POS_INI_H_NOT	; uRet := 0
		Case nPosTip == CALEND_POS_FIM_H_NOT	; uRet := 0
		Case nPosTip == CALEND_POS_MIN_H_NOT	; uRet := 0
		Case nPosTip == CALEND_POS_TRAB_FERIADO	; uRet := .F.
		Case nPosTip == CALEND_POS_APON_FERIAS  ; uRet := .F.
		Case nPosTip == CALEND_POS_TP_HE_NR_FER ; uRet := ""
		Case nPosTip == CALEND_POS_TP_HE_NT_FER ; uRet := ""
		Case nPosTip == CALEND_POS_PAGINT		; uRet := ""
		Case nPosTip ==	CALEND_POS_TIPO_ORIG_DIA; uRet := "" 
		Case nPosTip ==	CALEND_POS_HE_AUTO_FER  ; uRet := .T.  
		Case nPosTip ==	CALEND_POS_CODFUNC		; uRet := "" 
		Case nPosTip ==	CALEND_POS_DEPTO		; uRet := "" 
		Case nPosTip ==	CALEND_POS_POSTO		; uRet := "" 
		Case nPosTip ==	CALEND_POS_PERIODO		; uRet := "" 
		Case nPosTip ==	CALEND_POS_ROTEIRO		; uRet := "" 
		Case nPosTip ==	CALEND_POS_PROCESSO		; uRet := "" 
		Case nPosTip ==	CALEND_POS_NUM_PAGTO	; uRet := "" 
		Case nPosTip ==	CALEND_POS_JORN			; uRet := "" 
		Case nPosTip ==	CALEND_POS_P2ID			; uRet := "" 
		Case nPosTip ==	CALEND_POS_R8ID			; uRet := "" 
		Case nPosTip ==	CALEND_POS_DATA_APO		; uRet := "" 
		Case nPosTip ==	CALEND_POS_JND_CON		; uRet := "" 
		Case nPosTip ==	CALEND_POS_LIE			; uRet := "" 
		Case nPosTip ==	CALEND_POS_LSE			; uRet := "" 
		Case nPosTip ==	CALEND_POS_LIS			; uRet := "" 
		Case nPosTip ==	CALEND_POS_LSS			; uRet := "" 

	EndCase
Else
	nRetPosTab := nPosTab
EndIF

/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Restaura o Conteudo do Calendario por Turno        		  Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
IF !Empty( aSvTabsCal )
	SetTabCal( aSvTabsCal )
EndIF	

Return( uRet )

/*/
зддддддддддбддддддддддддддддбдддддбдддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁRstTabPadrao	ЁAutorЁMarinaldo de Jesus Ё Data Ё11/03/2003Ё
цддддддддддеддддддддддддддддадддддадддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁReinicializa as Staticas utilizadas em fTabPadrao()        	Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGenerico													Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function RstTabPadrao()
Return( ( __nLstTabPadPos := NIL ) )

/*/
зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁCriaCalendЁ Autor Ё Marinaldo de Jesus    Ё Data Ё15/12/2003Ё
Ё          Ё          Ё Ver.02Ё Mauricio MR           Ё      Ё30/10/2007Ё
цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁAlimenta um Array com o Calend═rio de um Per║odo.           Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё< Vide Parametros Formais >								    Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ< Vide Parametros Formais >									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       Ё Generico                                                   Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function CriaCalend(	dDataIni	,; //01 -> Data Inicial do Periodo
		 				dDataFim	,; //02 -> Data Final do Periodo
						cTno		,; //03 -> Turno Para a Montagem do Calendario
						cSeq		,; //04 -> Sequencia Inicial para a Montagem Calendario
						aTabPadrao	,; //05 -> Array Tabela de Horario Padrao
						aTabCalend	,; //06 -> Array com o Calendario de Marcacoes
						cFil		,; //07 -> Filial para a Montagem da Tabela de Horario
						cMat		,; //08 -> Matricula para a Montagem da Tabela de Horario
						cCc			,; //09 -> Centro de Custo para a Montagem da Tabela
						aTurnos		,; //10 -> Array com as Trocas de Turno
						aExcePer	,; //11 -> Array com Todas as Excecoes do Periodo
						lExecQryTop ,; //12 -> Se executa Query para a Montagem da Tabela Padrao
						lSncMaMe	,; //13 -> Se executa a funcao se sincronismo do calendario
						lForceNew	,; //14 -> Se Forca a Criacao de Novo Calendario
						aMarcacoes  ,; //15 -> Array com marcacoes para tratamento de Turnos Opcionais
						lCalFisico  ,; //16 -> .T. Determina a Criacao/Carga do Calendario Fisico
						lDtaCal		,; //17 -> .T. Caso exista calendario fisico 
						dIniCal		,; //18 -> Data inicial do calendario fisico
						dFimCal		,; //19 -> Data final do calendario fisico 
						lGravaCalend,; //20 -> .T. determina que o calendario sera gravado no caso de nao existir
						lRotGer		 ; //21 -> .T. determina que a rotina chamadora eh a Geracao de Calendarios (PONM400)						
					)   
/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё lChkMat: .T.  - Determina a montagem do calendario do funcioЁ
Ё                 nario.               					  	  Ё
Ё          .F.  - Determina a montagem do calendario do Turno Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Local lChkMat		:= ( cMat <> NIL )	
Local lCriaCalOk	:= .T.  

/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
ЁVerifica se usa Periodo Generico na montagem do calendario   Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Local lPGenerico	:= .F.


/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё nRetorno: 												  Ё
Ё            0 - Nao Carregou o Calendario					  Ё
Ё            1 - Gerar Calendario Virtual e Carrega-lo		  Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Local nRetorno		:= 0   

/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
ЁComplemento de mensagem para erro do calendario, na datas	  Ё
Ёrecebidas													  Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Local cMsgCal		:= ""

DEFAULT lPnmTabCalen	:= ExistBlock( "PNMTABC01" )
DEFAULT lCalFisico		:= lUseCalFisico			 //.T. - Deve existir calendario fisico / .F. - Utiliza calendario Virtual
DEFAULT lGravaCalend	:= lCalDem                   //.T. - Grava Calendario / .F. Nao Grava Calendario
DEFAULT lRotGer			:= .F.

/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Objeto de controle de erros do calendario					  Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/ 
If( Type("oCalendError") == "U" ) 
	oCalendError	:=SetMemVar("oCalendError" , PONERROR():New() , .T. , .T. )
	oCalendError:InitLogErrors(LoadCalError()) //Carrega tabela de erros
Endif

aTurnos     := If( ValType(aTurnos) == "U", {}, aTurnos )
aExcePer	:= If( ValType(aExcePer) == "U", {}, aExcePer )
aTabPadrao	:= If( ValType(aTabPadrao) == "U", {}, aTabPadrao )
aTabCalend  := If( ValType(aTabCalend) == "U", {}, aTabCalend )
aMarcacoes  := If( ValType(aMarcacoes) == "U", {}, aMarcacoes )

/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Somente permite a criacao/carga de calendario fisico se o   Ё
Ё parametro "MV_CALFIS" estiver setado para tanto.            Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
lCalFisico := If( lUseSPJ, .F., lCalFisico)

/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
ЁCaso seja recebida datas em branco, retorna um erro		  Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
If ( Empty(dDataIni) .or. Empty(dDataFim) )
	If ( Type("oPeriodo") != "U" )
		cMsgCal	:= CRLF + CRLF 
		cMsgCal += OemToAnsi(STR0226) + " = " + oPeriodo:cProcesso + CRLF
		cMsgCal += OemToAnsi(STR0227) + " = " + oPeriodo:cPeriodo	+ CRLF
		cMsgCal += OemToAnsi(STR0228) + " = " + oPeriodo:cRoteiro	+ CRLF
		cMsgCal += OemToAnsi(STR0229) + " = " + oPeriodo:cNumPagto + CRLF
		cMsgCal += OemToAnsi(STR0230) + " = " + If ( oPeriodo:lPerSel, STR0125, STR0126 ) 
	EndIf
	oCalendError:SendError('04',cMsgCal, .T.) 			//"Periodo nao encontrado "
	lCriaCalOk	:= .F.
Else

	If lChkMat
		If lCalFisico 
		   /*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Verifica se utiliza Periodo Generico (MV_PAPONTA)			  Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			IF !( lPGenerico := fVerPGenerico(SRA->RA_PROCES) )
				nRetorno :=	CalendFisico(	dDataIni	,; //01 -> Data Inicial do Periodo
							 				dDataFim	,; //02 -> Data Final do Periodo
											cTno		,; //03 -> Turno Para a Montagem do Calendario
											cSeq		,; //04 -> Sequencia Inicial para a Montagem Calendario
											@aTabPadrao	,; //05 -> Array Tabela de Horario Padrao
											@aTabCalend	,; //06 -> Array com o Calendario de Marcacoes
											cFil		,; //07 -> Filial para a Montagem da Tabela de Horario
											cMat		,; //08 -> Matricula para a Montagem da Tabela de Horario
											cCc			,; //09 -> Centro de Custo para a Montagem da Tabela
											@aTurnos	,; //10 -> Array com as Trocas de Turno
											@aExcePer	,; //11 -> Array com Todas as Excecoes do Periodo
											lExecQryTop ,; //12 -> Se executa Query para a Montagem da Tabela Padrao
											lSncMaMe	,; //13 -> Se executa a funcao se sincronismo do calendario
											lForceNew	,; //14 -> Se Forca a Criacao de Novo Calendario
											@aMarcacoes ,; //15 -> Array com marcacoes para tratamento de Turnos Opcionais  
											lDtaCal		,; //16 -> .T. Caso exista calendario fisico 
											dIniCal		,; //17 -> Data inicial do calendario fisico
											dFimCal		,; //18 -> Data final do calendario fisico 
											lGravaCalend,; //19 -> .T. determina que o calendario sera gravado no caso de nao existir
											lRotGer		 ; //20 -> .T. determina que a rotina chamadora eh a Geracao de Calendarios (PONM400)
										)							 
				lCriaCalOk := If( Empty(nRetorno), .F., .T. )
			Else             
				lCalFisico := .F.
			Endif	
		Else
			lCalFisico := .F.
		EndIf
	Else
		lCalFisico := .F.
	EndIf
	
	If !lCalFisico
		lCriaCalOk:= CalendVirtual(	dDataIni	,; //01 -> Data Inicial do Periodo
					 				dDataFim	,; //02 -> Data Final do Periodo
									cTno		,; //03 -> Turno Para a Montagem do Calendario
									cSeq		,; //04 -> Sequencia Inicial para a Montagem Calendario
									@aTabPadrao	,; //05 -> Array Tabela de Horario Padrao
									@aTabCalend	,; //06 -> Array com o Calendario de Marcacoes
									cFil		,; //07 -> Filial para a Montagem da Tabela de Horario
									cMat		,; //08 -> Matricula para a Montagem da Tabela de Horario
									cCc			,; //09 -> Centro de Custo para a Montagem da Tabela
									@aTurnos	,; //10 -> Array com as Trocas de Turno
									@aExcePer	,; //11 -> Array com Todas as Excecoes do Periodo
									lExecQryTop ,; //12 -> Se executa Query para a Montagem da Tabela Padrao
									lSncMaMe	,; //13 -> Se executa a funcao se sincronismo do calendario
									lForceNew	,; //14 -> Se Forca a Criacao de Novo Calendario
									@aMarcacoes  ;  //15 -> Array com marcacoes para tratamento de Turnos Opcionais
								)
	Endif
	
	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Ponto de Entrada para edicao do array aTabCalend             Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	IF ( lPnmTabCalen )
		IF ( ValType( uRet := ExecBlock("PNMTABC01",.F.,.F., { aTabCalend, lCriaCalOk }) ) == "A" )	
			aTabCalend := aClone(uRet)
			uRet	   := NIL
		EndIF
	EndIF

EndIf

Return(lCriaCalOk)

/*/
зддддддддддбддддддддддддддбдддддддбдддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁCalendFisico  Ё Autor Ё Mauricio MR       Ё Data Ё30/10/2007Ё
цддддддддддеддддддддддддддадддддддадддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁCria Calendario Fisico.                                     Ё
Ё          ЁAlimenta  um Array com o Calend═rio de um Per║odo.          Ё
Ё          ЁValida o calendario fisico, e se nao existir p/ o periodo	Ё
Ё          Ёcria o calendario											Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё< Vide Parametros Formais >								    Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ< Vide Parametros Formais >									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       Ё Generico                                                   Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function CalendFisico(	dDataIni	,; //01 -> Data Inicial do Periodo
		 				dDataFim	,; //02 -> Data Final do Periodo
						cTno		,; //03 -> Turno Para a Montagem do Calendario
						cSeq		,; //04 -> Sequencia Inicial para a Montagem Calendario
						aTabPadrao	,; //05 -> Array Tabela de Horario Padrao
						aTabCalend	,; //06 -> Array com o Calendario de Marcacoes
						cFil		,; //07 -> Filial para a Montagem da Tabela de Horario
						cMat		,; //08 -> Matricula para a Montagem da Tabela de Horario
						cCc			,; //09 -> Centro de Custo para a Montagem da Tabela
						aTurnos		,; //10 -> Array com as Trocas de Turno
						aExcePer	,; //11 -> Array com Todas as Excecoes do Periodo
						lExecQryTop ,; //12 -> Se executa Query para a Montagem da Tabela Padrao
						lSncMaMe	,; //13 -> Se executa a funcao se sincronismo do calendario
						lForceNew	,; //14 -> Se Forca a Criacao de Novo Calendario
						aMarcacoes  ,; //15 -> Array com marcacoes para tratamento de Turnos Opcionais  
						lDtaCal		,; //16 -> .T. Caso exista calendario fisico 
						dIniCal		,; //17 -> Data inicial do calendario fisico
						dFimCal		,; //18 -> Data final do calendario fisico 
						lGravaCalend,; //19 -> .T. determina que o calendario sera gravado no caso de nao existir
						lRotGer		 ; //20 -> .T. determina que a rotina chamadora eh a Geracao de Calendarios (PONM400)
					)

Local nRetorno		:= 1
Local cMsgError		:= ""

DEFAULT lDtaCal		:= .F.
DEFAULT dIniCal		:= Ctod("//")
DEFAULT dFimCal		:= Ctod("//")   
DEFAULT lRotGer		:= .F.

//Zera static. Devera ser usada apenas se existir calendario fisico previamente gravado.
__nOrdIni :=  NIL

/*/
здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Verifica se existe calendario fisico, se a data fim nao eh   Ё
Ё vazia														   Ё
юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/ 
If !lDtaCal
	lDtaCal := fDatMaxCal( cFil, cMat, @dFimCal, @dIniCal )
EndIf

//Se existe calendario fisico carrega
If (lDtaCal)
    
	//Caso ja exista dias previamente gravados, guarda a quantidade de ordens existentes
	//para que o trecho a ser montado comece pela ordem correta.
	If !( dDataIni > dFimCal )
		__nOrdIni :=  (dFimCal+1) - dDataIni
	EndIf
	
   	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	ЁNao permite geracao de calendario futuro, de modo a provocar  Ё
	Ёlacunas entre os calendarios existentes					   Ё
	ЁEx: Novo Calendario De: 01/02/07 Ate: 28/02/07				   Ё
	Ё	 Calendario Existente De: 01/01/07 Ate: 25/01/07		   Ё
	ЁNao gera calendario para o periodo							   Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	If ((dFimCal + 1 ) < dDataIni ) .or. ( (dIniCal-1) > dDataFim )
	    cMsgError := DtoC(dDataIni) + STR0067 + DtoC(dDataFim)
		oCalendError:SendError('07',cMsgError, .T.)  // Nao foi possivel gerar o calendario para o periodo de: dDataIni ate dDataFim
		oCalendError:SendError('08',Nil, .T.)  // Somente e possivel gerar calendario para periodos consecutivos.
		Return(0)
	EndIf
   
	//Verifica se podera gerar calendario por demanda (lCalDem), ou, se forca geracao e gravacao
	//do calendario independente do parametro lCalDem
	If (lCalDem .or. lGravaCalend)
		
		If Empty(aTurnos)
			//Monta todas as trocas de turno para o periodo informado.
			fTrocaTno( dDataIni , dDataFim , @aTurnos , NIL , cSeq )
		EndIf
		
		If ( dDataFim > dFimCal )		
						
				//Gera o periodo posterior ao calendario				
				If !( GeraCalend(   If ( dDataIni > dFimCal, dDataIni, dFimCal+1) ,; //01 -> Data Final do Calendario
									dDataFim									  ,; //02 -> Data Final do Periodo
					 				cTno		                                  ,; //03 -> Turno Para a Montagem do Calendario
									cSeq		                                  ,; //04 -> Sequencia Inicial para a Montagem Calendario
									@aTabPadrao	                                  ,; //05 -> Array Tabela de Horario Padrao
									@aTabCalend	                                  ,; //06 -> Array com o Calendario de Marcacoes
									cFil		                                  ,; //07 -> Filial para a Montagem da Tabela de Horario
									cMat		                                  ,; //08 -> Matricula para a Montagem da Tabela de Horario
									cCc		                                 	  ,; //09 -> Centro de Custo para a Montagem da Tabela
									@aTurnos	                                  ,; //10 -> Array com as Trocas de Turno
									@aExcePer	                                  ,; //11 -> Array com Todas as Excecoes do Periodo
									lExecQryTop 	                              ,; //12 -> Se executa Query para a Montagem da Tabela Padrao
									lSncMaMe	                                  ,; //13 -> Se executa a funcao se sincronismo do calendario
									.F.		                                 	  ,; //14 -> Se Forca a Criacao de Novo Calendario (forГa .F. para montar o calendario com as datas passadas
									@aMarcacoes 	                              ,; //15 -> Array com marcacoes para tratamento de Turnos Opcionais
									.F.		                                 	  ,; //16 -> Gerar calendario a partir do dia Maximo do cal. Fisico - Nao zera o array TabCalend
									lGravaCalend                                   ; //17 -> .T. determina que o calendario sera gravado no caso de nao existir
					  			);
                   )
                   nRetorno := 0
                EndIf              
                
    	EndIf
		If ( dDataIni < dIniCal )
			aTabCalend := {}
			//Gera o periodo anterior ao calendario
			If !( GeraCalend(   dDataIni 										,; //01 -> Data Final do Calendario
  							    If ( dDataFim > dIniCal, dIniCal-1, dDataFim)  ,; //02 -> Data Final do Periodo
								cTno		                                 	,; //03 -> Turno Para a Montagem do Calendario
  			   					cSeq		                                 	,; //04 -> Sequencia Inicial para a Montagem Calendario
				  				@aTabPadrao	                                 	,; //05 -> Array Tabela de Horario Padrao
								@aTabCalend	                                 	,; //06 -> Array com o Calendario de Marcacoes
								cFil		                                 	,; //07 -> Filial para a Montagem da Tabela de Horario
								cMat		                                 	,; //08 -> Matricula para a Montagem da Tabela de Horario
								cCc		                                 		,; //09 -> Centro de Custo para a Montagem da Tabela
								@aTurnos	                                 	,; //10 -> Array com as Trocas de Turno
								@aExcePer	                                 	,; //11 -> Array com Todas as Excecoes do Periodo
								lExecQryTop 	                                ,; //12 -> Se executa Query para a Montagem da Tabela Padrao
								lSncMaMe	                                 	,; //13 -> Se executa a funcao se sincronismo do calendario
								.F.		                                 		,; //14 -> Se Forca a Criacao de Novo Calendario (forГa .F. para montar o calendario com as datas passadas
								@aMarcacoes 	                                ,; //15 -> Array com marcacoes para tratamento de Turnos Opcionais
								.F.		                                 		,; //16 -> Gerar calendario a partir do dia Maximo do cal. Fisico - Nao zera o array TabCalend
								lGravaCalend                                     ; //17 -> .T. determina que o calendario sera gravado no caso de nao existir
							);
				)
				nRetorno := 0
			EndIf
		EndIf
	ElseIf ( ( dDataIni < dIniCal ) .or. ( dDataFim > dFimCal ) )
		oCalendError:SendError('05',Nil, .T.) // Nao e possivel gerar calendario por demanda, verificar parametro MV_CALDEM
		nRetorno := 0
	EndIf

	If ( nRetorno == 1 .and. !lRotGer )
		//Carrega o calendario
		aTabCalend := {}
		CarregaCalend(	dDataIni	,; //01 -> Data Inicial do Periodo
						dDataFim	,; //02 -> Data Final do Periodo
						cTno		,; //03 -> Turno Para a Montagem do Calendario
						cSeq		,; //04 -> Sequencia Inicial para a Montagem Calendario
						@aTabPadrao	,; //05 -> Array Tabela de Horario Padrao
						@aTabCalend	,; //06 -> Array com o Calendario de Marcacoes
						cFil		,; //07 -> Filial para a Montagem da Tabela de Horario
						cMat		,; //08 -> Matricula para a Montagem da Tabela de Horario
						cCc			,; //09 -> Centro de Custo para a Montagem da Tabela
						@aTurnos	,; //10 -> Array com as Trocas de Turno
						@aExcePer	,; //11 -> Array com Todas as Excecoes do Periodo
						lExecQryTop ,; //12 -> Se executa Query para a Montagem da Tabela Padrao
						lSncMaMe	,; //13 -> Se executa a funcao se sincronismo do calendario
						lForceNew	,; //14 -> Se Forca a Criacao de Novo Calendario
						@aMarcacoes ,; //15 -> Array com marcacoes para tratamento de Turnos Opcionais
						NIL	         ; //16 -> Identifica se o periodo esta fechado(.F.)/aberto(.T.)
         )
   EndIf

Else
	//Verifica se podera gerar calendario por demanda (lCalDem), ou, se forca geracao e gravacao
	//do calendario independente do parametro lCalDem
	If (lCalDem .or. lGravaCalend)
		//Gera o periodo completo do calendario
		If !( GeraCalend( 	dDataIni     	,; //01 -> Data Final do Calendario
							dDataFim	 	,; //02 -> Data Final do Periodo
							cTno	    	,; //03 -> Turno Para a Montagem do Calendario
							cSeq	    	,; //04 -> Sequencia Inicial para a Montagem Calendario
							@aTabPadrao     ,; //05 -> Array Tabela de Horario Padrao
							@aTabCalend     ,; //06 -> Array com o Calendario de Marcacoes
							cFil	    	,; //07 -> Filial para a Montagem da Tabela de Horario
							cMat	    	,; //08 -> Matricula para a Montagem da Tabela de Horario
							cCc	    		,; //09 -> Centro de Custo para a Montagem da Tabela
							@aTurnos	    ,; //10 -> Array com as Trocas de Turno
							@aExcePer    	,; //11 -> Array com Todas as Excecoes do Periodo
							lExecQryTop  	,; //12 -> Se executa Query para a Montagem da Tabela Padrao
							lSncMaMe	    ,; //13 -> Se executa a funcao se sincronismo do calendario
							.F.	    		,; //14 -> Se Forca a Criacao de Novo Calendario (forГa .F. para montar o calendario com as datas passadas
							@aMarcacoes  	,; //15 -> Array com marcacoes para tratamento de Turnos Opcionais
							.F.	    		,; //16 -> Gerar calendario a partir do dia Maximo do cal. Fisico - Nao zera o array TabCalend
							lGravaCalend  	 ; //17 -> .T. determina que o calendario sera gravado no caso de nao existir
						);
			)
			nRetorno := 0
		EndIf
	Else
		oCalendError:SendError('05',Nil, .T.) // Nao e possivel gerar calendario por demanda, verificar parametro MV_CALDEM
		nRetorno := 0
	EndIf
EndIf

Return ( nRetorno )

/*/
зддддддддддбддддддддддддддбдддддддбдддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁGeraCalend    Ё Autor Ё Igor Franzoi      Ё Data Ё14/11/2007Ё
цддддддддддеддддддддддддддадддддддадддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁGera o calendario na tabela fisica						    Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё< Vide Parametros Formais >								    Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ< Vide Parametros Formais >									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       Ё Generico                                                   Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function GeraCalend( dDataIni	,; //01 -> Data Final do Calendario
					 		dDataFim	,; //02 -> Data Final do Periodo
							cTno		,; //03 -> Turno Para a Montagem do Calendario
							cSeq		,; //04 -> Sequencia Inicial para a Montagem Calendario
							aTabPadrao	,; //05 -> Array Tabela de Horario Padrao
							aTabCalend	,; //06 -> Array com o Calendario de Marcacoes
							cFil		,; //07 -> Filial para a Montagem da Tabela de Horario
							cMat		,; //08 -> Matricula para a Montagem da Tabela de Horario
							cCc			,; //09 -> Centro de Custo para a Montagem da Tabela
							aTurnos		,; //10 -> Array com as Trocas de Turno
							aExcePer	,; //11 -> Array com Todas as Excecoes do Periodo
							lExecQryTop ,; //12 -> Se executa Query para a Montagem da Tabela Padrao
							lSncMaMe	,; //13 -> Se executa a funcao se sincronismo do calendario
							lForceNew	,; //14 -> Se Forca a Criacao de Novo Calendario
							aMarcacoes  ,; //15 -> Array com marcacoes para tratamento de Turnos Opcionais
							lTabCalen	,; //16 -> Nao zerar o array aTabCalend - Calendario Complementar
						    lGravaCalend ; //17 -> .T. determina que o calendario sera gravado no caso de nao existir																											
				)
		
Local lRet	  := .T.
Local lVrtGer := .F.

DEFAULT lTabCalen := .F.

/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Se nPosIni estiver preenchido, o inicio da gravacao do cal. Ё
Ё sera feito apos esta posicao, pois o inicio do calendario	  Ё
Ё fisico ja existe, e foi gravado anteriormente				  Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
If ( Empty(aTabCalend), nPosIni := 0 , nPosIni := (Len(aTabCalend)+1)  )

	lVrtGer := CalendVirtual(	dDataIni	,; //01 -> Data Inicial do Periodo
				 				dDataFim	,; //02 -> Data Final do Periodo
								cTno		,; //03 -> Turno Para a Montagem do Calendario
								cSeq		,; //04 -> Sequencia Inicial para a Montagem Calendario
								@aTabPadrao	,; //05 -> Array Tabela de Horario Padrao
								@aTabCalend	,; //06 -> Array com o Calendario de Marcacoes
								cFil		,; //07 -> Filial para a Montagem da Tabela de Horario
								cMat		,; //08 -> Matricula para a Montagem da Tabela de Horario
								cCc			,; //09 -> Centro de Custo para a Montagem da Tabela
								@aTurnos	,; //10 -> Array com as Trocas de Turno
								@aExcePer	,; //11 -> Array com Todas as Excecoes do Periodo
								lExecQryTop ,; //12 -> Se executa Query para a Montagem da Tabela Padrao
								lSncMaMe	,; //13 -> Se executa a funcao se sincronismo do calendario
								lForceNew	,; //14 -> Se Forca a Criacao de Novo Calendario
								@aMarcacoes ,; //15 -> Array com marcacoes para tratamento de Turnos Opcionais
								lTabCalen	;  //16 -> Nao zerar o array aTabCalend - Calendario Complementar
				)
				
	//-- Verifica se grava calendario			
	If lVrtGer
		If lGravaCalend
			If !(lRet := GravaCalend( cFil		,; //01 -> Filial para a Montagem da Tabela de Horario
				    				 cMat		,; //02 -> Matricula para a Montagem da Tabela de Horario
									 aTabCalend	,; //03 -> Array com o Calendario de Marcacoes
									 nPosIni	 ; //04 -> Posicao inicial do array aTabCalend
				   				    );
			    )
				oCalendError:SendError('06',Nil, .T.)//Nao foi possivel gravar calendario
			EndIF
		EndIf
	Else
		//Ocorreu alguma inconsistencia na montagem do calendario virtual. Ver mensagem de erro na funcao CalendCria.
		lRet := .F.
	EndIf

Return lRet

/*/
зддддддддддбддддддддддддддбдддддддбдддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁGravaCalend   Ё Autor Ё Igor Franzoi      Ё Data Ё14/11/2007Ё
цддддддддддеддддддддддддддадддддддадддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁGrava os dados do calendario virtual nas tabelas 			Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё< Vide Parametros Formais >								    Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ< Vide Parametros Formais >									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       Ё Generico                                                   Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function GravaCalend(	cFil		,; //01 -> Filial para a Montagem da Tabela de Horario
								cMat		,; //02 -> Matricula para a Montagem da Tabela de Horario
								aTabCalend	;  //03 -> Array com o Calendario
   				)

Local lRet 		:= .F.
Local nElem  	:= 0
Local aArea  	:= GetArea()
Local cAliasRF6 := "RF6"

Local nRecnoRF6
Local nRecnoRF7

Local cPreRF6  := cAliasRF6+"_"

Local dDataApoAnt
Local dDtaApo
Local dDtaMai	:= CtoD('')
Local dDtaMen	:= CtoD('')
Local cTurno
Local cDepto
Local cPosto

Local nHorMai   := 0
Local nHorMen   := 0
Local nNumMarc  := 0
Local nTotHrInt := 0
Local nTotHrTra := 0
Local nX		:= 0

#DEFINE CABEC_  01

#DEFINE FILIAL_ 01
#DEFINE DATA_   02
#DEFINE ORDEM_  03
#DEFINE	MAT_    04
#DEFINE TURNO_  05
#DEFINE SEQ_    06
#DEFINE TIPOD_  07
#DEFINE	MOTIVO_ 08
#DEFINE	P2ID_	09
#DEFINE JORN_	10
#DEFINE HRMENO_ 11
#DEFINE HRMAIS_ 12
#DEFINE HRINTV_ 13
#DEFINE HRTRAB_ 14
#DEFINE CODREF_ 15
#DEFINE TPEXT_  16
#DEFINE TPEXTN_ 17
#DEFINE NONAHR_ 18
#DEFINE INIHNT_ 19
#DEFINE FIMHNT_ 20
#DEFINE MINHNT_ 21
#DEFINE HNTTAB_ 22
#DEFINE HNTTBI_ 23
#DEFINE REGRA_  24
#DEFINE NUMARC_ 25
#DEFINE DORIG_  26
#DEFINE R8ID_	27
#DEFINE	FLAG_   28
#DEFINE CHKTNO_ 29
#DEFINE PROCES_ 30
#DEFINE PERIOD_ 31
#DEFINE ROTEIR_ 32
#DEFINE NUMPAG_ 33
#DEFINE TPEXCE_	34

Begin Transaction

	For nElem := 1 To Len(aTabCalend)
	
		If dDataApoAnt != aTabCalend[ nElem, CALEND_POS_DATA_APO ]

			dDataApoAnt := aTabCalend[ nElem, CALEND_POS_DATA_APO ]
			dDtaApo   	:= aTabCalend[ nElem, CALEND_POS_DATA_APO ]
			cTurno    	:= aTabCalend[ nElem, CALEND_POS_TURNO    ]
			
			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Conta o numero de marcacoes								  Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			If Empty(aTabCalend[nElem,CALEND_POS_NUM_MARC])
				nNumMarc := 1
			Else
				nNumMarc := aTabCalend[ nElem, CALEND_POS_NUM_MARC ]
			EndIf		
			
			nTotHrInt := aTabCalend[ nElem, CALEND_POS_HRS_INTER ]
			nTotHrTra := aTabCalend[ nElem, CALEND_POS_HRS_TRABA ]
	
			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			ЁInsere o HorMais para o primeiro registro da ordem, depois   Ё
			Ёinsere vazio ate o ultimo registro da ordem para inserir o   |
			|HorMenos													  |
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			
			If Empty(nHorMen)
				nHorMen := aTabCalend[ nElem, CALEND_POS_LIM_MARCACAO, 2 ]
			Else
				nHorMen := nHorMen
			EndIf

			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			ЁVerifica o ultimo elemento do dia para pegar a data limite   Ё
			Ёsuperior.                                                    |
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/			
			If !( ( nX := aScan( aTabCalend , { |x| x[CALEND_POS_DATA_APO] == dDataApoAnt + 1 } ) ) > 0 )
				nX := Len(aTabCalend)
			Else
				nX--
			EndIf
            //Data limite inferior
			dDtaMen		:= aTabCalend[ nElem, CALEND_POS_LIM_MARCACAO, 1 ]
			//Data Limite superior
			dDtaMai		:= aTabCalend[ nX   , CALEND_POS_LIM_MARCACAO, 1 ]

			RecLock(cAliasRF6, .T., .F.)
				(cAliasRF6)->&(cPreRF6+aStcRF6[CABEC_,FILIAL_]) := cFil
				(cAliasRF6)->&(cPreRF6+aStcRF6[CABEC_,DATA_  ]) := dDtaApo
				(cAliasRF6)->&(cPreRF6+aStcRF6[CABEC_,ORDEM_ ]) := aTabCalend[ nElem, CALEND_POS_ORDEM         ]
				(cAliasRF6)->&(cPreRF6+aStcRF6[CABEC_,MAT_   ]) := cMat
				(cAliasRF6)->&(cPreRF6+aStcRF6[CABEC_,TURNO_ ]) := aTabCalend[ nElem, CALEND_POS_TURNO         ]
				(cAliasRF6)->&(cPreRF6+aStcRF6[CABEC_,SEQ_   ]) := aTabCalend[ nElem, CALEND_POS_SEQ_TURNO     ]
				(cAliasRF6)->&(cPreRF6+aStcRF6[CABEC_,TIPOD_ ]) := aTabCalend[ nElem, CALEND_POS_TIPO_DIA      ]
				(cAliasRF6)->&(cPreRF6+aStcRF6[CABEC_,MOTIVO_]) := aTabCalend[ nElem, CALEND_POS_MOT_EXECAO    ]
				(cAliasRF6)->&(cPreRF6+aStcRF6[CABEC_,JORN_  ]) := aTabCalend[ nElem, CALEND_POS_JORN          ]
				(cAliasRF6)->&(cPreRF6+aStcRF6[CABEC_,CODREF_]) := aTabCalend[ nElem, CALEND_POS_COD_REFEICAO  ]
				(cAliasRF6)->&(cPreRF6+aStcRF6[CABEC_,TPEXT_ ]) := aTabCalend[ nElem, CALEND_POS_TIPO_HE_NOR   ]
				(cAliasRF6)->&(cPreRF6+aStcRF6[CABEC_,TPEXTN_]) := aTabCalend[ nElem, CALEND_POS_TIPO_HE_NOT   ]
				(cAliasRF6)->&(cPreRF6+aStcRF6[CABEC_,NONAHR_]) := aTabCalend[ nElem, CALEND_POS_PG_NONA_HORA  ]
				(cAliasRF6)->&(cPreRF6+aStcRF6[CABEC_,INIHNT_]) := aTabCalend[ nElem, CALEND_POS_INI_H_NOT     ]
				(cAliasRF6)->&(cPreRF6+aStcRF6[CABEC_,FIMHNT_]) := aTabCalend[ nElem, CALEND_POS_FIM_H_NOT     ]
				(cAliasRF6)->&(cPreRF6+aStcRF6[CABEC_,MINHNT_]) := aTabCalend[ nElem, CALEND_POS_MIN_H_NOT     ]
				(cAliasRF6)->&(cPreRF6+aStcRF6[CABEC_,HNTTAB_]) := ""
				(cAliasRF6)->&(cPreRF6+aStcRF6[CABEC_,HNTTBI_]) := ""
				(cAliasRF6)->&(cPreRF6+aStcRF6[CABEC_,REGRA_ ]) := aTabCalend[ nElem, CALEND_POS_REGRA         ]
				(cAliasRF6)->&(cPreRF6+aStcRF6[CABEC_,DORIG_ ]) := aTabCalend[ nElem, CALEND_POS_TIPO_ORIG_DIA ]
				(cAliasRF6)->&(cPreRF6+aStcRF6[CABEC_,P2ID_  ]) := aTabCalend[ nElem, CALEND_POS_P2ID		   ]
				(cAliasRF6)->&(cPreRF6+aStcRF6[CABEC_,TPEXCE_]) := aTabCalend[ nElem, CALEND_POS_TPEXCE		   ]				
				(cAliasRF6)->&(cPreRF6+aStcRF6[CABEC_,R8ID_  ]) := aTabCalend[ nElem, CALEND_POS_R8ID		   ]
				(cAliasRF6)->&(cPreRF6+aStcRF6[CABEC_,HRMENO_]) := nHorMen
				(cAliasRF6)->&(cPreRf6+aStcRF6[CABEC_,CHKTNO_]) := "N"
				(cAliasRF6)->&(cPreRf6+aStcRF6[CABEC_,PROCES_]) := aTabCalend[ nElem, CALEND_POS_PROCESSO      ]
				(cAliasRF6)->&(cPreRf6+aStcRF6[CABEC_,PERIOD_]) := aTabCalend[ nElem, CALEND_POS_PERIODO       ]
				(cAliasRF6)->&(cPreRf6+aStcRF6[CABEC_,ROTEIR_]) := aTabCalend[ nElem, CALEND_POS_ROTEIRO       ]
				(cAliasRF6)->&(cPreRf6+aStcRF6[CABEC_,NUMPAG_]) := aTabCalend[ nElem, CALEND_POS_NUM_PAGTO     ]
				(cAliasRF6)->&(cPreRF6+aStcRF6[CABEC_,FLAG_  ]) := "I"
			( cAliasRF6 )->( MsUnlock() )

			( cAliasRF6 )->( fkCommit() )
			nRecnoRF6 := ( cAliasRF6 )->( Recno() )
			RecLock(cAliasRF6, .F., .F.)

				/*/
				зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				Ё Grava o item do calendario - Entrada						  Ё
				юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
				GrvItem( cFil, cMat, nElem, aTabCalend, @nRecnoRF7, dDtaMen, dDtaMai )

		Else

			dDataApoAnt := aTabCalend[ nElem, CALEND_POS_DATA_APO 	]
			cTurno    	:= aTabCalend[ nElem, CALEND_POS_TURNO   	]
			
			If Empty(aTabCalend[ nElem, CALEND_POS_NUM_MARC])
				nNumMarc++
			Else
				nNumMarc := aTabCalend[ nElem, CALEND_POS_NUM_MARC]
			EndIf

             nTotHrInt := SomaHoras( nTotHrInt, aTabCalend[ nElem, CALEND_POS_HRS_INTER ] )
             nTotHrTra := SomaHoras( nTotHrTra, aTabCalend[ nElem, CALEND_POS_HRS_TRABA ] )

			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Grava o item do calendario - Saida						  Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			GrvItem( cFil, cMat, nElem, aTabCalend, @nRecnoRF7, dDtaMen, dDtaMai )

			nHorMai := If( Empty(nHorMai), aTabCalend[ nElem, CALEND_POS_LIM_MARCACAO, 2 ], nHorMai )
			
			If !Empty(nHorMai)
				(cAliasRF6)->( dbGoTo( nRecnoRF6 ) )
				(cAliasRF6)->&(cPreRF6+aStcRF6[CABEC_,HRMAIS_]) := nHorMai
				(cAliasRF6)->&(cPreRF6+aStcRF6[CABEC_,HRINTV_]) := nTotHrInt
				(cAliasRF6)->&(cPreRF6+aStcRF6[CABEC_,HRTRAB_]) := nTotHrTra
				(cAliasRF6)->&(cPreRF6+aStcRF6[CABEC_,NUMARC_]) := nNumMarc

				(cAliasRF6 )->(MsUnlock())
				(cAliasRF6 )->(fkCommit())
				nHorMai := 0
				nHorMen := 0
			EndIf

		EndIf
	
	Next
	
	lRet := .T.

End Transaction

RestArea( aArea )

Return ( lRet )

/*/
зддддддддддбддддддддддддддбдддддддбдддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁGrvItem		  Ё Autor Ё Igor Franzoi      Ё Data Ё14/11/2007Ё
цддддддддддеддддддддддддддадддддддадддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁGrava os itens do Calendario							    Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё< Vide Parametros Formais >								    Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ aTabCalend = Array do Calendario							Ё
Ё		   Ё nPos 	    = Posicao atual no array aTabCalend 			Ё
Ё		   Ё aTabCalend = Array do Calendario							Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       Ё Generico                                                   Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function GrvItem( cFil, cMat, nPos, aTabCalend, nRecnoRF7, dDtaMen, dDtaMai )

Local lRet 		:= .F.
Local cAliasRF7 := "RF7"
Local cPrefRF7	:= cAliasRF7+"_"
Local cPagInt	:= "0"

#DEFINE ITEM_	01

#DEFINE FILIAL_ 01
#DEFINE DATA_   02
#DEFINE MAT_    03
#DEFINE LIE_    04
#DEFINE DATAE_  05
#DEFINE ENTRA_  06
#DEFINE LSE_    07
#DEFINE LIS_    08
#DEFINE DATAS_  09
#DEFINE SAIDA_  10
#DEFINE LSS_    11
#DEFINE INTERV_ 12
#DEFINE JNDCO_  13
#DEFINE HRINTV_ 14
#DEFINE HRTRAB_ 15
#DEFINE CC_     16
#DEFINE DEPTO_  17
#DEFINE POSTO_  18
#DEFINE CODFUN_ 19
#DEFINE FLAG_   20

If ( "I" $ aTabCalend[ nPos, CALEND_POS_PAGINT    ] )
	cPagInt := "1"
EndIf	

If ( SubStr( aTabCalend[ nPos, CALEND_POS_TIPO_MARC ],2,1 ) == "E" )

	RecLock(cAliasRF7, .T., .F.)
	
		(cAliasRF7)->&(cPrefRF7+aStcRF7[ITEM_,FILIAL_]) := cFil
		(cAliasRF7)->&(cPrefRF7+aStcRF7[ITEM_,DATA_  ]) := aTabCalend[ nPos, CALEND_POS_DATA_APO  ]  //Data apontamento
		(cAliasRF7)->&(cPrefRF7+aStcRF7[ITEM_,MAT_   ]) := cMat

		(cAliasRF7)->&(cPrefRF7+aStcRF7[ITEM_,LIE_   ]) := aTabCalend[ nPos, CALEND_POS_LIE  ]
		(cAliasRF7)->&(cPrefRF7+aStcRF7[ITEM_,DATAE_ ]) := aTabCalend[ nPos, CALEND_POS_DATA ]  	//Data da marcacao
		(cAliasRF7)->&(cPrefRF7+aStcRF7[ITEM_,ENTRA_ ]) := aTabCalend[ nPos, CALEND_POS_HORA ]
		(cAliasRF7)->&(cPrefRF7+aStcRF7[ITEM_,LSE_   ]) := aTabCalend[ nPos, CALEND_POS_LSE  ]

		(cAliasRF7)->&(cPrefRF7+aStcRF7[ITEM_,INTERV_]) := cPagInt
		(cAliasRF7)->&(cPrefRF7+aStcRF7[ITEM_,JNDCO_ ]) := aTabCalend[ nPos, CALEND_POS_JND_CON   ]
	
		(cAliasRF7)->&(cPrefRF7+aStcRF7[ITEM_,HRTRAB_]) := aTabCalend[ nPos, CALEND_POS_HRS_TRABA ]
		(cAliasRF7)->&(cPrefRF7+aStcRF7[ITEM_,CC_    ]) := aTabCalend[ nPos, CALEND_POS_CC    	  ]
		(cAliasRF7)->&(cPrefRF7+aStcRF7[ITEM_,DEPTO_ ]) := aTabCalend[ nPos, CALEND_POS_DEPTO 	  ]
		(cAliasRF7)->&(cPrefRF7+aStcRF7[ITEM_,POSTO_ ]) := aTabCalend[ nPos, CALEND_POS_POSTO 	  ]
		(cAliasRF7)->&(cPrefRF7+aStcRF7[ITEM_,CODFUN_]) := aTabCalend[ nPos, CALEND_POS_CODFUNC  ]
		(cAliasRF7)->&(cPrefRF7+aStcRF7[ITEM_,FLAG_  ]) := "I"
		
	(cAliasRF7)->(MsUnlock())
	(cAliasRF7)->(fkCommit())
	
	nRecnoRF7 := (cAliasRF7)->(Recno())

	RecLock(cAliasRF7, .F., .F.)
	
	lRet := .T.

Else

	(cAliasRF7)->(dbGoTo( nRecnoRF7 ))	
		(cAliasRF7)->&(cPrefRF7+aStcRF7[ITEM_,LIS_   ]) := aTabCalend[ nPos, CALEND_POS_LIS  ]
		(cAliasRF7)->&(cPrefRF7+aStcRF7[ITEM_,DATAS_ ]) := aTabCalend[ nPos, CALEND_POS_DATA ]
		(cAliasRF7)->&(cPrefRF7+aStcRF7[ITEM_,SAIDA_ ]) := aTabCalend[ nPos, CALEND_POS_HORA ]
		(cAliasRF7)->&(cPrefRF7+aStcRF7[ITEM_,LSS_   ]) := aTabCalend[ nPos, CALEND_POS_LSS  ]
		(cAliasRF7)->&(cPrefRF7+aStcRF7[ITEM_,HRINTV_]) := aTabCalend[ nPos, CALEND_POS_HRS_INTER ]
	( cAliasRF7 )->( MsUnlock() )
	
	lRet := .T.

EndIf

Return lRet

/*/
зддддддддддбддддддддддддддбдддддддбдддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁCarregaCalend Ё Autor Ё Igor Franzoi	  Ё Data Ё19/11/2007Ё
цддддддддддеддддддддддддддадддддддадддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁCarrega o calendario fisico para o array					Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё< Vide Parametros Formais >								    Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ< Vide Parametros Formais >									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       Ё Generico                                                   Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function CarregaCalend(	dDataIni	,; //01 -> Data Inicial do Periodo
								dDataFim	,; //02 -> Data Final do Periodo
								cTno		,; //03 -> Turno Para a Montagem do Calendario
								cSeq		,; //04 -> Sequencia Inicial para a Montagem Calendario
								aTabPadrao	,; //05 -> Array Tabela de Horario Padrao
								aTabCalend	,; //06 -> Array com o Calendario de Marcacoes
								cFil		,; //07 -> Filial para a Montagem da Tabela de Horario
								cMat		,; //08 -> Matricula para a Montagem da Tabela de Horario
								cCc			,; //09 -> Centro de Custo para a Montagem da Tabela
								aTurnos		,; //10 -> Array com as Trocas de Turno
								aExcePer	,; //11 -> Array com Todas as Excecoes do Periodo
								lExecQryTop ,; //12 -> Se executa Query para a Montagem da Tabela Padrao
								lSncMaMe	,; //13 -> Se executa a funcao se sincronismo do calendario
								lForceNew	,; //14 -> Se Forca a Criacao de Novo Calendario
								aMarcacoes  ,; //15 -> Array com marcacoes para tratamento de Turnos Opcionais
								lAcumulado	 ; //16 -> Identifica se o periodo esta fechado(.F.)/aberto(.T.)
				)

Local aArea   := GetArea()
Local nRet    := 0
Local nCal    := 0 
Local nReg	  := 0
Local nPos	  := 0
Local nExc	  := 0
Local nMaxReg := 0
Local nRegAux := 0

Local cKey 	  := ""
Local cKeyRf7 := ""

Local nOrderRf6 := ""
Local nOrderRf7 := ""

Local nHora		:= 0
Local nTrcTno	:= 0
Local nTno		:= 0
Local nSeq		:= 0
Local nHorMen	:= 0
Local nHorMai	:= 0
Local nIniHnt 	:= 0
Local nFimHnt 	:= 0
Local nMinHnt 	:= 0
Local nLimMarc	:= 0
Local nLimInfE 	:= 0
Local nLimSupE 	:= 0
Local nLimInfS	:= 0
Local nLimSupS	:= 0
Local nTipMarc	:= 0
Local nNumMarc	:= 0
Local nHrTrab	:= 0
Local nHrInte	:= 0
Local nSerial   := 0

 /*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Obtem a Filial Para a Montagem do Calendario                Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Local cFilSPJ 	  := xFilial( If (lUseSPJ,"SPJ","RF2") , cFil )
Local cRegra	  := ""
Local cTurno	  := ""
Local cCcCal	  := ""
Local cDepto      := ""
Local cPosto	  := ""
Local cCodRef	  := ""
Local cPagInt     := ""
Local cP3Desc	  := ""
Local cIdAfas	  := ""
Local cTipoDia	  := ""
Local cIdExce	  := ""
Local cTpExce	  := ""
Local cTpExt	  := ""
Local cTpExtN	  := ""
Local cNonaHr     := ""
Local cCodPro 	  := ""
Local cNumPag 	  := ""
Local cCodPer 	  := ""
Local cCodRot 	  := ""
Local cCodJor 	  := ""
Local cMotExc 	  := ""
Local cNewReg	  := ""
Local cRegOrig	  := ""
Local cFuncCal	  := ""
Local cJndCont	  := ""
Local cP3TpExt	  := ""
Local cTipAfast	  := ""
Local cTipDorig   := ""
Local cP3TpExtN	  := ""
Local cTpExNorFer := ""
Local cTpExNotFer := ""

Local nFimHnot	  := 23.59

Local lRet			 := .F.
Local lAfast	     := .F.
Local lFeriado	     := .F.
Local lAponFer       := .F.
Local lExceData	     := .F.
Local lAfastaPer     := .F.
Local lHeAutoFer     := .F.
Local lAllTnoOpc     := .F.
Local lTrbFeriado    := .F.
Local lTnoSubstituto := .F.
Local lTrocaTno      := .F.

Local dDataCal	:= Ctod("//")
Local dDataApo	:= Ctod("//")
Local dIniAfas	:= Ctod("//")
Local dFimAfas	:= Ctod("//")
Local dDataLimE := Ctod("//")
Local dDataLimS := Ctod("//")
Local dData		:= Ctod("//")

Local cAliasRF6 := "RF6"
Local cAliasRF7 := "RF7"

Local cOrdem   := ""
Local dDataAnt := Ctod("//")

Local cCpos	   := ""
Local lSrvType := NIL

Local aTabTno	:= {}
Local aCpos	    := {}
Local aSP6Cache := {}
Local aSpAux	:= {}
Local aSPACpo	:= {}
Local aSr6Cpo   := {}
Local aTrcTno   := {}
Local aAuxTno   := {}
Local aAllExc   := {}
Local aDataApo 	:= {}
Local aSpaInfo  := {}
Local aSr6Info  := {}
Local aTabOrig	:= {}
Local aExcecoes := {}
Local aTabTurno := {}
Local aDiaTurnoOk := {}

Local aAfasta
Local nFields
Local cJoin
Local cWhere
Local cOrder

Local cAliasQry

DEFAULT aTabCalend   := {}
DEFAULT __aAllTnoOpc := {}

cKey 	 := cFil+cMat
lSrvType := If( Type("lSrvType") == "U", lExInAs400, lSrvType )

/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Obtem as Informacoes em Cache do Turno de Trabalho          Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
aSr6Cpo := {;
		"R6_INIHNOT"	,;	//01
		"R6_FIMHNOT"	,;	//02
		"R6_MINHNOT"	,;	//03
		"R6_APODFER"	,;	//04
		"R6_TPEXFER"	,;	//05
		"R6_TPEXFEN"	,;	//06
		"R6_AUTOHEF"	,;	//07
		"R6_TNOOPC"  	;	//08
}

/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Campos recuperados do SPA - Paga intervalo / Trab. Feriado  Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
aSPACpo := { "PA_PAGINT", "PA_FERIADO" }

/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Monta os campos da Query									  Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
If Empty(aStcStrRF6)
	aStcStrRF6 := RF6->(dbStruct())
EndIf

For nFields := 1 To Len(aStcStrRF6)
	cCpos += aStcStrRF6[ nFields, 01 ] + ", "
	aAdd( aCpos, aStcStrRF6[ nFields, 01 ] )
Next 

If Empty(aStcStrRF7)
	aStcStrRF7 := RF7->(dbStruct())
EndIf

For nFields := 1 To Len(aStcStrRF7)
	cCpos += aStcStrRF7[ nFields, 01 ] + If( nFields != Len(aStcStrRF7), ", ", "" )
	aAdd( aCpos, aStcStrRF7[ nFields, 01 ] )
Next

#IFDEF TOP
	
	cAliasQry := GetNextAlias()
	cCpos += ", RF6.R_E_C_N_O_ RF6RECNO, RF7.R_E_C_N_O_ "
	cCpos := "%"+cCpos+"%"
	
 	cJoin := "% RF6.RF6_FILIAL  = RF7.RF7_FILIAL "
	cJoin += " AND RF6.RF6_MAT = RF7.RF7_MAT	%"

	cWhere := "% RF6.RF6_FILIAL = '"+cFil+"' "
	cWhere += " AND RF6.RF6_MAT = '"+cMat+"' "
	cWhere += " AND RF6.RF6_DATA >= '"+Dtos(dDataIni)+"' "
	cWhere += " AND RF6.RF6_DATA <= '"+Dtos(dDataFim)+"' "
	cWhere += " AND RF6.RF6_DATA = RF7.RF7_DATA %"
	
	cOrder := "% RF6.RF6_FILIAL, RF6.RF6_MAT, RF6.RF6_DATA, RF6.RF6_TURNO %"
	
	/*/
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	ЁSeleciona os dados do cabecalho e item do calendario		  Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/	
	BeginSql alias cAliasQry
		column RF6_DATA as Date, RF7_DATA as Date, RF7_DATAE as Date, RF7_DATAS as Date
		SELECT 		%exp:cCpos%
		FROM 		%table:RF6% RF6
		INNER JOIN  %table:RF7% RF7
		ON 			%exp:cJoin%
		WHERE 		%exp:cWhere% AND
					RF6.%NotDel% AND
					RF7.%NotDel%
		ORDER BY    %exp:cOrder%				
	EndSql
	
	IF Empty( aTurnos )
		/*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Carrega as Trocas de Turno/Regra do Periodo				  Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		DEFAULT aTurnos := {}
		lTrocaTno := fTrocaTno( dDataIni , dDataFim , @aTurnos , NIL , cSeq )
	Else
		lTrocaTno := .T.
	EndIF
	//Verifica se for MENOR ou igual, nЦo existindo assume SRA
	IF ( ( nPos := aScan( aTurnos , { |x| x[2] == dDataIni } ) ) > 0 )
		cTno 	:= aTurnos[ nPos , 01 ]
		cSeq	:= aTurnos[ nPos , 03 ]
		cRegra 	:= aTurnos[ nPos , 05 ]
	Else
		If ( ( nPos := aScan( aTurnos , { |x| x[2] < dDataIni } ) ) > 0 )
			cTno 	:= aTurnos[ nPos , 01 ]
			cSeq	:= aTurnos[ nPos , 03 ]
			cRegra 	:= aTurnos[ nPos , 05 ]
		Else
			cRegra	:= SRA->RA_REGRA
		EndIf
	EndIF	

	fTabPadrao( @aTabPadrao , @cFilSPJ , cTno , lExecQryTop )
	
	/*
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Obtem todos os Turnos Opcionais			                   Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/    
	lAllTnoOpc := .F.
	If __lChkTnoOpc
		If lTrocaTno                     
			For nTno:= 1 To Len(aTurnos)               
				//-- Carrega todos os horarios opcionais do turno
		    	If LoadTnoOpc(cFilSPJ, aTurnos[nTno, 1],__aAllTnoOpc, @aTabPadrao)
		    	   lAllTnoOpc := .T.
		    	Endif   
		    Next
		Else
			//-- Carrega todos os horarios opcionais do turno
		    If LoadTnoOpc(cFilSPJ, cNewTno,__aAllTnoOpc, @aTabPadrao)
	    	   lAllTnoOpc := .T.
	    	Endif   
		Endif  
    Endif
        
	/*/
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Carrega as Marcacoes do Funcionario para Ajustar os Turnos  Ё
	Ё em funcao da existencia de turnos opcionais				  Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/	        
	If lAllTnoOpc 
		If Empty(aMarcacoes) 
			GetMarcOpc(	@aMarcacoes						,;	//01 -> Marcacoes dos Funcionarios
						dDataIni						,;	//02 -> Periodo Inicial
						dDataFim						,;	//03 -> Periodo Final
						cFil							,;	//04 -> Filial
						cMat							,;	//05 -> Matricula
						cTno							,;	//06 -> Turno
						cSeq							,;	//07 -> Sequencia de Turno
						cCc								,;	//08 -> Centro de Custo 
						If(lAcumulado, "SPG", "SP8")     ; //09 -> Obtem as marcacoes do Alias conforme o periodo considerado.
					  )         
		Endif  		  
    Endif  

	
	/*/
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	ЁMonta array aTabCalend com os dados da tabela				  Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	While (cAliasQry)->( !Eof() .and. RF6_FILIAL+RF6_MAT == cKey .and. ;
		  					RF6_DATA >= dDataIni .and. RF6_DATA <= dDataFim )
	
		dDataApo := (cAliasQry)->(RF6_DATA)
				
		If ( dDataAnt == dDataApo )
			If ( lExceData .and. !( aExcecoes[nExc,46] <> "S" ) ) 
				(cAliasQry)->(dbSkip())
				Loop
			Else
				If ( lExceData )
					nRegAux := nMaxReg + 1
					nTipMarc:= nRegAux
					nMaxReg := nMaxReg + 2
				Else
					nRegAux := 1
					nMaxReg := 2
				EndIf
			EndIf
		Else
			nMaxReg	 := 2
			nRegAux	 := 1
			
			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Calcula Limite de Saida do Dia ANTERIOR baseado no HorMais  Ё
			Ё NAO MUDAR essa Linha										  Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/	
			If( Len(aTabCalend) > 0)
				aTabCalend[ Len(aTabCalend), CALEND_POS_LIM_MARCACAO ] := { dDataLimS, nHorMai }
			EndIf
		
	   		/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Obtem as informacoes o dia de apontamento					  Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/	
			dDataAnt := dDataApo
			nTipMarc := 1

			nHorMai := (cAliasQry)->(RF6_HRMAIS)
			nHorMen := (cAliasQry)->(RF6_HRMENO)

			cRegra	 := (cAliasQry)->(RF6_REGRA )		
			cCodRef  := (cAliasQry)->(RF6_CODREF)
			cCodJor	 := (cAliasQry)->(RF6_JORN  )
			cNonaHr	 := (cAliasQry)->(RF6_NONAHR)
			cTipoDia := (cAliasQry)->(RF6_TIPOD)
			cIdExce  := (cAliasQry)->(RF6_P2ID  )
			cTpExce  := (cAliasQry)->(RF6_TPEXCE)
			nNumMarc := (cAliasQry)->(RF6_NUMARC)
			
			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Calcula Limite de Entrada do Dia baseado no HorMenos		  Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			nLimMarc	:= nHorMen
			dDataLimE 	:= (cAliasQry)->(RF7_DATAE)
			
			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Se Houve Alteracao na Tabela Padrao/Regra em Funcao das ExceЁ
			Ё coes, Restaura os Padroes								      Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			IF ( !Empty( aTabOrig ) )
				aTabTno		:= aClone( aTabOrig )
				aTabOrig	:= {}
				cNewReg		:= cRegOrig
				cRegOrig	:= ""
			EndIF
			
			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Se houver Sincronismo, adiciona a Data de Apontamento  	  Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			IF ( lSncMaMe )
				aAdd( aDataApo, dDataApo)
			EndIF			
			

			If ( cTurno+cSeq != (cAliasQry)->(RF6_TURNO)+(cAliasQry)->(RF6_SEQ) )
				cTurno   := (cAliasQry)->(RF6_TURNO )
				cSeq     := (cAliasQry)->(RF6_SEQ   )
			
				/*/
				зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				Ё Verifica se houve troca de turno, e adiciona no array para  Ё
				Ё formar os elementos do aTurnos - permanencia do legado 	  Ё
				юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
				nPos := aScan( aTurnos, { |x| x[1] == cTurno } ) 
				
				If (nPos == 0)				
					aAdd( aTurnos , { cTurno , dDataIni , cSeq , 0 , cRegra } )
				EndIf

				/*
				здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				Ё Carrega tabela de horario padrao 							   Ё
				юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
				fTabPadrao( @aTabPadrao , cFil, cTurno , lExecQryTop )
					
				If ( nPos := aScan( aSP6Cache, { |x| x[1] == cTurno } ) ) == 0
					aSpAux   := aClone(aSr6Cpo)
					aSr6Info := PosSR6( cTurno , cFil , @aSr6Cpo , 01 , .F. )
					aSr6Cpo  := aClone(aSpAux)
					aAdd( aSp6cache, {cTurno,aSr6Info} )					
	            Else
	                aSr6Info := aClone(aSP6Cache[nPos])
	            Endif
            
    		EndIf
            
			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Pesquisa e Carrega a Tabela do Turno Corrente				  Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			IF ( ( nPos := aScan( aTabPadrao, { |x| x[2] == cTurno .and. ( x[1] == cFilSPJ .or. Empty( x[1] ) ) } ) ) > 0 )
				aTabTno := aClone( aTabPadrao[ nPos , 3 ] )
			EndIF            
			/*
			здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Carrega as Excecoes para o dia se nao estiver carregada	   Ё
			юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			If !( lExceData := RetExcId( cFil, cIdExce, dDataApo, cRegra, aAllExc, aExcecoes ) )
				If lAllTnoOpc
				   	/*/
					зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
					Ё Salva a Tabela Padrao/Regra da Semana Que Serao  ModificadosЁ
					Ё em Funcao de Excecoes										  Ё
					юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
					aTabOrig  := aClone( aTabTno )
					cRegOrig  := cNewReg
				   ( lTnoOpcData:=GetTnoOpc( cNewTno, dData, @aDiaTurnoOK, aTabPadrao, @aTabTno[nPos], cFilSPJ, @aMarcacoes))
				Else
					If lPnmTab01 
						If ( ValType( uRet 	:= ExecBlock("PNMTAB01",.F.,.F., { cFil, cMat , dDataApo, cTurno, aClone(aTabTno[nPos]) }) ) == "A" )
							If (lTnoSubstituto  := !Empty(uRet) )
								 /*/
							    здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
							    Ё Troca a tabela de horario do turno do dia pela do Ponto de Entrada           Ё
							    юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/    
								aTabTno[nPos] 	:= aClone(uRet)
							Endif	
							uRet := NIL
						EndIf
					EndIf				
			    EndIf
			Else
				/*/
				зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				Ё Salva a Tabela Padrao/Regra da Semana Que Serao  ModificadosЁ
				Ё em Funcao de Excecoes										  Ё
				юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
				nExc := aScan( aExcecoes, { |x|  x[59] == cIdExce } )
				aTabOrig  := aClone( aTabTno )
				cRegOrig  := cNewReg
			EndIf
		EndIf						

		If (cAliasQry)->(RF6_CHKTNO) == "S" .and. lAllTnoOpc
			(cAliasQry)->(dbSkip())
			Loop
		EndIf
		
		/*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Obtem as Informacoes em Cache da Regra de Apontamento       Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		aSpAux  := aClone(aSPACpo)
		aSPAInfo := PosSPA( (cAliasQry)->(RF6_REGRA) , cFil , @aSPACpo, 01 , .F. )
		aSPACpo  := aClone(aSpAux)
		
		/*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Verifica Quais Intervalos Sao Pagos             			  Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		cPagInt := aSPAInfo[1]

		/*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Verifica Se o Dia em Questao eh um Feriado				  Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		lTrbFeriado := .F.
		If ( lFeriado := fFeriado( cFil , (cAliasQry)->(RF6_DATA) ) )
			cP3TpExt		:= SP3->P3_TPEXT
			cP3TpExtN		:= SP3->P3_TPEXTN
			cP3Desc			:= SP3->P3_DESC
			lTrbFeriado := ( aSpaInfo[2] == "S" )
		Else
			cP3TpExt	:= ""
			cP3TpExtN	:= ""
			cP3Desc		:= ""
		EndIF
		
		/*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Verificar se o Funcionario Esta Afastado na Data			  Ё
		Ё atraves do R8_NUMID - Identificador unico de afastamento	  Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/ 
		If ( (cAliasQry)->(RF6_R8ID) != cIdAfas )

			lAfast := fAfasta( cFil,;
							   cMat,;
							   (cAliasQry)->(RF7_DATA),;
							   @dIniAfas,;
							   @dFimAfas,;
							   @cTipAfast,;
							   aAfasta,;
							   @cIdAfas )
			
			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Se estiver Afastado Define o Dia como Nao Trabalhado        Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			If ( lAfast )
				cTipoDia := "N"	//Nao Trabalhado
			EndIF
			
			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Verifica se Aponta para Funcionario em Ferias            	  Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			If ( cTipAfast == "F" )
				If ( lAponFer := ( aSr6Info[4] == "S" ) )
	
					/*/
					зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
					Ё Se funcionario em Ferias com Direito a Apontamento       	  Ё
					юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
					cTpExNorFer	:= aSr6Info[5]	//Normal Ferias
					cTpExNotFer	:= aSr6Info[6]	//Noturna Ferias
	
					/*/
					зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
					Ё Verifica se horas extras sao autorizadas para funcionario   Ё
					Ё em ferias.												  Ё
					юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
					lHeAutoFer := If ( aSr6Info[7] == "1" .or. Empty( aSr6Info[7] ), .T. , .F. )	 // 1 ou branco - Autorizadas (Padrao) , 2- Nao Autorizadas
	
				EndIf
			Else
				/*/
				зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				Ё Se funcionario nao Trabalha em Feriado e dia For Feriado 	  Ё
				юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
				If (;
				 		( lFeriado );			//Dia eh Feriado
				 		.and.;
				 		!( lTrbFeriado );		//Funcionario Nao Trabalha em Feriado
				 	)
					cTipoDia := "F" //Feriado
				EndIF
			EndIf
	    EndIf
	    
	    nSeq := Val( (cAliasQry)->(RF6_SEQ) )
	    		
     	cCodPro	 := (cAliasQry)->(RF6_PROCES)
		cCodPer	 := (cAliasQry)->(RF6_PERIOD)
		cCodRot	 := (cAliasQry)->(RF6_ROTEIR) 
		cNumPag	 := (cAliasQry)->(RF6_NUMPAG)
		
		/*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		ЁVerifica se o Dia da Semana da Sequencia e equivalente ao DiaЁ
		Ёda Data a Ser Pesquisada. Pesquisa a Sequencia  Primeiro  comЁ
		Ёo StrZero( n , 1 ) "0" e Depois com o StrZero( n , 2 ) "00"  Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		bAsc := { |x| (	AllTrim( x[19] ) == StrZero( nSeq , IF( nSeq < 10 , 1 , 2 ) ) .or. AllTrim( x[19] ) == StrZero( nSeq , 2 ) ) }
		IF !( lCriaCalOk := ( nPos := aScan( aTabTno , bAsc ) ) > 0 )
			Break
		EndIF

		If !( lExceData := !Empty( (cAliasQry)->(RF6_P2ID) ) )
		
			/*/
		   здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		   Ё Checa a Existencia de Turnos Opcionais				          Ё
		   юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/    
		 	If lAllTnoOpc

		 		aDiaTurnoOk := {}
				AADD( aDiaTurnoOK, {dDataApo, SPACE(1) } )
		 		
			   	/*/
				зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				Ё Salva a Tabela Padrao/Regra da Semana Que Serao  ModificadosЁ
				Ё em Funcao de Excecoes										  Ё
				юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
				aTabOrig  := aClone( aTabTno )
				cRegOrig  := cNewReg
				aTabTno := Clone( aTabPadrao )
			    GetTnoOpc( cTurno, dDataApo, @aDiaTurnoOK, aTabPadrao, @aTabTno[nPos], cFil, @aMarcacoes)
			 EndIf
				 
		Else
			
			If ( aExcecoes[nExc,46] <> "S" )	
			
				nMaxReg	 := 0
				nNumMarc := 0
																
				aTabTno[nPos,01] 	:= aExcecoes[nExc,05]		// 01 - 1a Entrada
				aTabTno[nPos,02] 	:= aExcecoes[nExc,06]		// 02 - 1a Saida
				aTabTno[nPos,03] 	:= aExcecoes[nExc,07]		// 03 - 2a Entrada
				aTabTno[nPos,04] 	:= aExcecoes[nExc,08]		// 04 - 2a Saida
				aTabTno[nPos,05] 	:= aExcecoes[nExc,09]		// 05 - 3a Entrada
				aTabTno[nPos,06] 	:= aExcecoes[nExc,10]		// 06 - 3a Saida
				aTabTno[nPos,07] 	:= aExcecoes[nExc,11]		// 07 - 4a Entrada
				aTabTno[nPos,08] 	:= aExcecoes[nExc,12]		// 08 - 4a Saida
				aTabTno[nPos,09] 	:= aExcecoes[nExc,16]		// 09 - Horas Trabalhadas 1a. Jornada
				aTabTno[nPos,10] 	:= aExcecoes[nExc,17]		// 10 - Horas Trabalhadas 2a. Jornada
				aTabTno[nPos,11] 	:= aExcecoes[nExc,18]		// 11 - Horas Trabalhadas 3a. Jornada
				aTabTno[nPos,12] 	:= aExcecoes[nExc,19]		// 12 - Horas Trabalhadas 4a. Jornada
				aTabTno[nPos,13] 	:= aExcecoes[nExc,26]		// 13 - Horas de Intervalo 1S
				aTabTno[nPos,14] 	:= aExcecoes[nExc,27]		// 14 - Horas de Intervalo 2S
				aTabTno[nPos,15] 	:= aExcecoes[nExc,28]		// 15 - Horas de Intervalo 3S
				aTabTno[nPos,16] 	:= ""						// 16 - Marcacao e do dia seguinte ?
				aTabTno[nPos,17] 	:= aExcecoes[nExc,20]		// 17 - Numero de Marcacoes					
				aTabTno[nPos,29] 	:= aExcecoes[nExc,34]		// 29 - Aponta Nona Hora
				aTabTno[nPos,30] 	:= aExcecoes[nExc,35]		// 30 - Limite de Horario Inicial
				aTabTno[nPos,31] 	:= aExcecoes[nExc,36]		// 31 - Limite de Horario Final
				aTabTno[nPos,32] 	:= aExcecoes[nExc,37]		// 32 - 1a. Jornada Continua
				aTabTno[nPos,33] 	:= aExcecoes[nExc,38]		// 33 - 2a. Jornada Continua
				aTabTno[nPos,34]	:= aExcecoes[nExc,39]		// 34 - 3a. Jornada Continua
				aTabTno[nPos,35]	:= aExcecoes[nExc,40]		// 35 - 4a. Jornada Continua
				aTabTno[nPos,36]	:= aExcecoes[nExc,41]		// 36 - Codigo da Refeicao
				
				For nReg := 5 To 11 Step 2
					If ( aExcecoes[nExc,23] == "S" )
						If ( !Empty(aExcecoes[nExc,nReg]) )
							nMaxReg := nMaxReg + 2
							nNumMarc++															
						EndIf
					Else
						nReg	:= 11
						nAuxReg := 1
						nMaxReg := 2
						nNumMarc:= 2
					EndIf
				Next
			Else
				nMaxReg := If ( Empty(nNumMarc), 2, nNumMarc )
		    EndIf
				
			aTabTno[nPos,18] 	:= aExcecoes[nExc,23]			// 18 - Tipo do Dia
			aTabTno[nPos,19] 	:= aTabTno[nPos,19]             // 19 - Sequencia da Marcacao
			aTabTno[nPos,20] 	:= Dow( dDataApo )     			// 20 - Numero Correspondente ao Dia da Semana
			aTabTno[nPos,21] 	:= "E"							// 21 - Flag Indicador de Excecao
			aTabTno[nPos,22] 	:= aExcecoes[nExc,21]			// 22 - Motivo da Excecao
			aTabTno[nPos,23] 	:= aExcecoes[nExc,22]			// 23 - Codigo Hora Extra Normal
			aTabTno[nPos,24] 	:= aExcecoes[nExc,24]			// 24 - Codigo Hora Extra Noturna
			aTabTno[nPos,25] 	:= If ( !Empty(aExcecoes[nExc,29]), aExcecoes[nExc,29], cCCcal )			// 25 - Centro de Custo Periodo 1 (1a.E-1a.S)
			aTabTno[nPos,26] 	:= If ( !Empty(aExcecoes[nExc,30]), aExcecoes[nExc,30], cCCcal )			// 26 - Centro de Custo Periodo 2 (2a.E-2a.S)
			aTabTno[nPos,27] 	:= If ( !Empty(aExcecoes[nExc,31]), aExcecoes[nExc,31], cCCcal )			// 27 - Centro de Custo Periodo 3 (3a.E-3a.S)
			aTabTno[nPos,28] 	:= If ( !Empty(aExcecoes[nExc,32]), aExcecoes[nExc,32], cCCcal )			// 28 - Centro de Custo Periodo 4 (4a.E-4a.S)		
			aTabTno[nPos,38] 	:= If ( !Empty(aExcecoes[nExc,47]), aExcecoes[nExc,47], cFuncCal )			// 38 - Funcoes Periodo 1 (1a.E-1a.S)
			aTabTno[nPos,39] 	:= If ( !Empty(aExcecoes[nExc,48]), aExcecoes[nExc,48], cFuncCal )			// 39 - Funcoes Periodo 2 (2a.E-2a.S)
			aTabTno[nPos,40] 	:= If ( !Empty(aExcecoes[nExc,49]), aExcecoes[nExc,49], cFuncCal )			// 40 - Funcoes Periodo 3 (3a.E-3a.S)
			aTabTno[nPos,41] 	:= If ( !Empty(aExcecoes[nExc,50]), aExcecoes[nExc,50], cFuncCal )			// 41 - Funcoes Periodo 4 (4a.E-4a.S)				
			aTabTno[nPos,58] 	:= If ( !Empty(aExcecoes[nExc,55]), aExcecoes[nExc,55], cDepto )			// 58 - Depto Periodo 1 (1a.E-1a.S)
			aTabTno[nPos,59] 	:= If ( !Empty(aExcecoes[nExc,56]), aExcecoes[nExc,56], cDepto )			// 59 - Depto Periodo 2 (2a.E-2a.S)
			aTabTno[nPos,60] 	:= If ( !Empty(aExcecoes[nExc,57]), aExcecoes[nExc,57], cDepto )			// 60 - Depto Periodo 3 (3a.E-3a.S)
			aTabTno[nPos,61] 	:= If ( !Empty(aExcecoes[nExc,58]), aExcecoes[nExc,58], cDepto )			// 61 - Depto Periodo 4 (4a.E-4a.S)
			aTabTno[nPos,62] 	:= If ( !Empty(aExcecoes[nExc,51]), aExcecoes[nExc,51], cPosto )			// 62 - Posto Periodo 1 (1a.E-1a.S)
			aTabTno[nPos,63] 	:= If ( !Empty(aExcecoes[nExc,52]), aExcecoes[nExc,52], cPosto )			// 63 - Posto Periodo 2 (2a.E-2a.S)
			aTabTno[nPos,64] 	:= If ( !Empty(aExcecoes[nExc,53]), aExcecoes[nExc,53], cPosto )			// 64 - Posto Periodo 3 (3a.E-3a.S)
			aTabTno[nPos,65] 	:= If ( !Empty(aExcecoes[nExc,54]), aExcecoes[nExc,54], cPosto )			// 65 - Posto Periodo 4 (4a.E-4a.S)								

        EndIf            
            
        If ( lExceData .or. lAllTnoOpc ) .AND. nRegAux <= nMaxReg
            
            cTipoDia	:= aTabTno[ nPos , 18 ]
            cSeq		:= aTabTno[ nPos , 19 ]
            cMotExc		:= aTabTno[ nPos , 22 ]
            cNonaHr		:= aTabTno[ nPos , 29 ]
			nHorMen		:= aTabTno[ nPos , 30 ]
			nHorMai		:= aTabTno[ nPos , 31 ]
		    cCodRef		:= aTabTno[ nPos , 36 ]
			cCodJor		:= aTabTno[ nPos , 70 ]
			
			nLimMarc	:= nHorMai
			
		Endif				
			
		/*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		ЁPara cada um registro, carrega dois elementos no array		  Ё
		ЁPq para cada linha do calendario fisico existe uma entrada e |
		Ёuma saida, tabela RF7 										  Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		For nReg := nRegAux To nMaxReg
		
			nHrTrab	 := (cAliasQry)->(RF7_HRTRAB)
			nHrInte	 := (cAliasQry)->(RF7_HRINTV)			
			cCcCal 	 := (cAliasQry)->(RF7_CC)
			cFuncCal := (cAliasQry)->(RF7_CODFUN)
			cJndCont := (cAliasQry)->(RF7_JNDCO)
			cDepto	 := (cAliasQry)->(RF7_DEPTO)
			cPosto	 := (cAliasQry)->(RF7_POSTO)
			
			If AllTrim(Str(nReg)) $ "1_3_5_7"
				dData    := (cAliasQry)->(RF7_DATAE)
			Else
				dData    := (cAliasQry)->(RF7_DATAS)
			EndIf			
           
            If ( lExceData .or. lAllTnoOpc )
            
				/*/
				здддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				Ё Incrementa dData Quando Marcacao for do Dia Seguinte Ё
				юдддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
				If ( aTabTno[ nPos , nReg ] <  aTabTno[ nPos , IF( nReg == 1 , nReg , nReg-1 ) ] )
					If !( dData+1 > (cAliasQry)->(RF7_DATAS) ) 
						dData++
						nSerial		:= ( __fDhToNS( dData , aTabTno[ nPos , nReg ] ) - __fDhToNS( NIL , aTabTno[ nPos , 30 ] ) )
						dDataLimE	:= __fNsToDh( nSerial , "D" )
						nLimMarc	:= __fNsToDh( nSerial , "H" )					
					EndIf					
				EndIf
				
				Do Case
					Case ( AllTrim(Str( nTipMarc )) $ "1" )
						cCcCal 		:= aTabTno[ nPos , 25 ] 
						cFuncCal 	:= aTabTno[ nPos , 38 ]
						cJndCont	:= aTabTno[ nPos , 32 ]
						cDepto		:= aTabTno[ nPos , 58 ]
						cPosto		:= aTabTno[ nPos , 62 ]
						IF ( nReg == 1 )
							nHora	 := aTabTno[ nPos , 01 ]
							nHrTrab  := aTabTno[ nPos , 09 ]
							nLimInfE := aTabTno[ nPos , 42 ]
							nLimSupE := aTabTno[ nPos , 43 ]
						Else
							nHora	 := aTabTno[ nPos , 02 ]
							nHrInte  := aTabTno[ nPos , 13 ]
							nLimInfS := aTabTno[ nPos , 44 ]
							nLimSupS := aTabTno[ nPos , 45 ]
						EndIF
					Case ( AllTrim(Str( nTipMarc )) $ "2" )
						cCcCal 		:= aTabTno[ nPos , 26 ]
						cFuncCal 	:= aTabTno[ nPos , 39 ]
						cJndCont	:= aTabTno[ nPos , 33 ]
						cDepto		:= aTabTno[ nPos , 59 ]
						cPosto		:= aTabTno[ nPos , 63 ]				
						IF ( nReg == 3 )
							nHora	 := aTabTno[ nPos , 03 ]
							nHrTrab  := aTabTno[ nPos , 10 ]
							nLimInfE := aTabTno[ nPos , 46 ]
							nLimSupE := aTabTno[ nPos , 47 ]
						Else
							nHora	 := aTabTno[ nPos , 04 ]
							nHrInte  := aTabTno[ nPos , 14 ]
							nLimInfS := aTabTno[ nPos , 48 ]
							nLimSupS := aTabTno[ nPos , 49 ]
						EndIF
					Case ( AllTrim(Str( nTipMarc )) $ "3" )
						cCcCal 		:= aTabTno[ nPos , 27 ]
						cFuncCal 	:= aTabTno[ nPos , 40 ]
						cJndCont	:= aTabTno[ nPos , 34 ]
						cDepto		:= aTabTno[ nPos , 60 ]
						cPosto		:= aTabTno[ nPos , 64 ]
					
						IF ( nReg == 5 )
							nHora	 := aTabTno[ nPos , 05 ]
							nHrTrab  := aTabTno[ nPos , 11 ]
							nLimInfE := aTabTno[ nPos , 50 ]
							nLimSupE := aTabTno[ nPos , 51 ]
						Else
							nHora	 := aTabTno[ nPos , 06 ]
							nHrInte  := aTabTno[ nPos , 15 ]
							nLimInfS := aTabTno[ nPos , 52 ]
							nLimSupS := aTabTno[ nPos , 53 ]
						EndIF
					Case ( AllTrim(Str( nTipMarc )) $ "4" )
						nHrTrab		:= aTabTno[ nPos , 12 ]					
						cCcCal 		:= aTabTno[ nPos , 28 ]
						cFuncCal 	:= aTabTno[ nPos , 41 ]
						cJndCont	:= aTabTno[ nPos , 35 ]
						cDepto		:= aTabTno[ nPos , 61 ]
						cPosto		:= aTabTno[ nPos , 65 ]					
						IF ( nReg == 7 )
							nHora	 := aTabTno[ nPos , 07 ]
							nHrTrab  := aTabTno[ nPos , 12 ]
							nLimInfE := aTabTno[ nPos , 54 ]
							nLimSupE := aTabTno[ nPos , 55 ]
						Else
							nHora	 := aTabTno[ nPos , 08 ]
							nLimInfS := aTabTno[ nPos , 56 ]
							nLimSupS := aTabTno[ nPos , 57 ]
						EndIF
				EndCase
				
			Else
				If AllTrim(Str(nReg)) $ "1_3_5_7"
					nHora    := (cAliasQry)->(RF7_ENTRA)
					nLimInfE := (cAliasQry)->(RF7_LIE  )
					nLimSupE := (cAliasQry)->(RF7_LSE  )
				Else
					nHora    := (cAliasQry)->(RF7_SAIDA)
					nLimInfS := (cAliasQry)->(RF7_LIS  )
					nLimSupS := (cAliasQry)->(RF7_LSS  )
				EndIf
				
				If dDataLimE == dData .and. nLimMarc > nHora
					dDataLimE -= 1
				EndIf
            EndIf
                
			aAdd( aTabCalend, Array( ELEMENTOS_ATABCALEND ) )		
			nCal := Len(aTabCalend)
			
			aTabCalend[	nCal,	CALEND_POS_DATA		 ] := dData														// 01 - Data
			aTabCalend[	nCal,	CALEND_POS_ORDEM	 ] := (cAliasQry)->(RF6_ORDEM)									// 02 - Ordem
			aTabCalend[	nCal,	CALEND_POS_HORA		 ] := nHora														// 03 - Hora
			
			If AllTrim(Str(nReg)) $ "1_3_5_7"
				aTabCalend[	nCal, CALEND_POS_TIPO_MARC ] := AllTrim(Str(nTipMarc)+"E")								// 04 - Tipo Marc
			Else
				aTabCalend[	nCal, CALEND_POS_TIPO_MARC ] := AllTrim(Str(nTipMarc)+"S")								// 04 - Tipo Marc
				nTipMarc++
			EndIf
			
			aTabCalend[	nCal,	CALEND_POS_NUM_MARC	 ] := nNumMarc    												// 05 - No Marc.
			aTabCalend[	nCal,	CALEND_POS_TIPO_DIA	 ] := cTipoDia													// 06 - Tipo Dia						
			aTabCalend[	nCal,	CALEND_POS_HRS_TRABA ] := nHrTrab													// 07 - Horas Trabalhada no Periodo						
			aTabCalend[	nCal,	CALEND_POS_SEQ_TURNO ] := (cAliasQry)->(RF6_SEQ)									// 08 - Sequ┬ncia de Turno
			aTabCalend[	nCal,	CALEND_POS_HRS_INTER ] := nHrInte													// 09 - Horas de Intervalo			

			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			ЁMonta excecao												  Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			aTabCalend[	nCal,	CALEND_POS_EXCECAO			] := If( !Empty(cMotExc), "E", "" )						// 10 - Excecao ( E-Excecao, # E - nao e excecao )
			aTabCalend[	nCal,	CALEND_POS_MOT_EXECAO		] := cMotExc											// 11 - Motivo da Excecao

			aTabCalend[	nCal,	CALEND_POS_TIPO_HE_NOR		] := (cAliasQry)->(RF6_TPEXT)							// 12 - Tipo de hora extra normal
			aTabCalend[	nCal,	CALEND_POS_TIPO_HE_NOT		] := (cAliasQry)->(RF6_TPEXTN)							// 13 - Tipo de hora extra noturna
			aTabCalend[	nCal,	CALEND_POS_TURNO			] := cTurno												// 14 - Turno de Trabalho
			aTabCalend[	nCal,	CALEND_POS_CC				] := cCCcal												// 15 - Centro de Custo do Periodo
			aTabCalend[	nCal,	CALEND_POS_PG_NONA_HORA		] := cNonaHr											// 16 - Pagamento de Nona Hora
			aTabCalend[	nCal,	CALEND_POS_LIM_MARCACAO		] := { dDataLimE, nLimMarc }							// 17 - Limite de Marcacao Inicial
			aTabCalend[	nCal,	CALEND_POS_COD_REFEICAO		] := cCodRef										   	// 18 - Codigo da Refeicao
			aTabCalend[	nCal,	CALEND_POS_FERIADO			] := lFeriado											// 19 - Dia e Feriado
			aTabCalend[	nCal,	CALEND_POS_TP_HE_FER_NR		] := cP3TpExt											// 20 - Tipo de Hora Extra Feriado Normal
			aTabCalend[	nCal,	CALEND_POS_TP_HE_FER_NT 	] := cP3TpExtN											// 21 - Tipo de Hora Extra Feriado Noturna
			aTabCalend[	nCal,	CALEND_POS_DESC_FERIADO		] := cP3Desc											// 22 - Descricao do Feriado	
			aTabCalend[	nCal,	CALEND_POS_REGRA			] := (cAliasQry)->(RF6_REGRA) 							// 23 - Regra de Apontamento
			aTabCalend[	nCal,	CALEND_POS_AFAST			] := lAfast												// 24 - Funcionario Afastado
			aTabCalend[	nCal,	CALEND_POS_TIP_AFAST		] := cTipAfast											// 25 - Tipo de Afastamento
			aTabCalend[	nCal,	CALEND_POS_INI_AFAST		] := dIniAfas 											// 26 - Data Inicial do Afastamento
			aTabCalend[	nCal,	CALEND_POS_FIM_AFAST		] := dFimAfas											// 27 - Data Final do Afastamento	
			aTabCalend[	nCal,	CALEND_POS_INI_H_NOT		] := (cAliasQry)->(RF6_INIHNT)							// 28 - Inicio da Hora Noturna
			aTabCalend[	nCal,	CALEND_POS_FIM_H_NOT		] := (cAliasQry)->(RF6_FIMHNT)							// 29 - Final da Hora Noturna
			aTabCalend[	nCal,	CALEND_POS_MIN_H_NOT		] := (cAliasQry)->(RF6_MINHNT)							// 30 - Minutos da Hora Noturna				
			aTabCalend[	nCal,	CALEND_POS_TRAB_FERIADO		] := lTrbFeriado										// 31 - Se funcionario Trabalha em Dias Feriados
			aTabCalend[	nCal,	CALEND_POS_APON_FERIAS		] := lAponFer											// 32 - Se Aponta Quando Afastamento em Ferias
			aTabCalend[	nCal,	CALEND_POS_TP_HE_NR_FER		] := cTpExNorFer										// 33 - Tipo de hora extra normal (Ferias)
			aTabCalend[	nCal,	CALEND_POS_TP_HE_NT_FER		] := cTpExNotFer										// 34 - Tipo de hora extra noturna (Ferias)
			aTabCalend[	nCal,	CALEND_POS_PAGINT			] := cPagInt											// 35 - Tipos de Intervalos Que sao Pagos conforme Regra
			aTabCalend[ nCal,   CALEND_POS_TIPO_ORIG_DIA    ] := (cAliasQry)->(RF6_DORIG)							// 36 - Tipo Original do Dia conforme excecao mas sem considerar a regra e/ou afastamentos			
			aTabCalend[ nCal,   CALEND_POS_HE_AUTO_FER      ] := lHeAutoFer											// 37 - Se H.Extras sЦo autorizadas para funcionario em ferias					
			aTabCalend[ nCal,   CALEND_POS_CODFUNC 		    ] := cFuncCal											// 38 - Codigo de funcao
			aTabCalend[ nCal,   CALEND_POS_DEPTO  		    ] := cDepto												// 39 - Codigo de Depto. do funcionario
			aTabCalend[ nCal,   CALEND_POS_POSTO  		    ] := cPosto												// 40 - Codigo do Posto do funcionario
			aTabCalend[ nCal,   CALEND_POS_PERIODO 		    ] := cCodPer											// 41 - Periodo
			aTabCalend[ nCal,   CALEND_POS_ROTEIRO 		    ] := cCodRot											// 42 - Roterio
			aTabCalend[ nCal,   CALEND_POS_PROCESSO		    ] := cCodPro											// 44 - Num. de Pagamento
			aTabCalend[ nCal,   CALEND_POS_NUM_PAGTO	    ] := cNumPag											// 43 - Processo
			aTabCalend[ nCal,   CALEND_POS_JORN			    ] := cCodJor											// 45 - Cod. da Jornada
			aTabCalend[ nCal,   CALEND_POS_P2ID				] := cIdExce 				   							// 46 - Lote da excecao
			aTabCalend[ nCal,   CALEND_POS_R8ID				] := cIdAfas											// 47 - Identificacao afastamento
			aTabCalend[ nCal,   CALEND_POS_DATA_APO			] := dDataApo											// 48 - Data de apontamento					
			aTabCalend[ nCal,   CALEND_POS_JND_CON			] := cJndCont											// 49 - Jornada continua						
			aTabCalend[ nCal,   CALEND_POS_LIE				] := nLimInfE 											// 50 - Limite inferior da entrada
			aTabCalend[ nCal,   CALEND_POS_LSE				] := nLimSupE											// 51 - Limite superior da entrada
			aTabCalend[ nCal,   CALEND_POS_LIS				] := nLimInfS											// 52 - Limite inferior da saida
			aTabCalend[ nCal,   CALEND_POS_LSS				] := nLimSupS 											// 53 - Limite inferior da saida
			aTabCalend[ nCal, 	CALEND_POS_TPEXCE			] := cTpExce											// 54 - Tipo de Excecao "F" - Funcionario / "P" - Periodo
			
			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			ЁZera o limite, pois so vai inserir no primeiro registro e no Ё
			Ёultimo registro da ordem existente no calendario			  Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			nLimMarc  := 0
					
			//-- Se Entrada
			If AllTrim(Str(nReg)) $ "1_3_5_7"
				dDataLimE := Ctod("//") 	
			Else//-- Se Saida
				If ( lExceData .or. lAllTnoOpc )
					nSerial		:= ( __fDhToNS( aTabCalend[ nCal , CALEND_POS_DATA ] , aTabCalend[ nCal , CALEND_POS_HORA ] ) + __fDhToNS( NIL ,aTabTno[ nPos , 31 ]) )
					dDataLimS	:= __fNsToDh( nSerial , "D" )
					nHorMai  	:= __fNsToDh( nSerial , "H" )
				Else
					If ( DataHora2Str( aTabCalend[1][1], aTabCalend[1][3] ) < DataHora2Str( aTabCalend[nCal][1], (aTabCalend[nCal][3] + SR6->R6_HORMAIS) ) ) .AND. (aTabCalend[nCal][3] + SR6->R6_HORMAIS) > nFimHnot
						dDataLimS := (cAliasQry)->(RF7_DATAS) + 1		
					Else
						dDataLimS := (cAliasQry)->(RF7_DATAS)
					EndIf
				EndIF				
			Endif
			
		Next

		cIdExce	  := ""
		cTpExce	  := ""
		cMotExc	  := ""

		/*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		ЁGrava as alteracoes do calendario em funcao da troca de hor. Ё
		Ёpelo turno opcional										  Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/		
		If lAllTnoOpc
			GravaTnoOpc( nCal, (cAliasQry)->(Recno()), (cAliasRF7)->(Recno()), If( nReg == 1, 1, 2), aTabCalend )
		EndIf
				
		(cAliasQry)->(dbSkip())
			
	EndDo
	
	If !Empty(aTabCalend)
		aTabCalend[ Len(aTabCalend), CALEND_POS_LIM_MARCACAO ] := { dDataLimS, nHorMai }
		lRet := .T.	
	EndIf
	
#ELSE
	
	nOrderRf6 := RetOrdem(cAliasRf6,"RF6_FILIAL+RF6_MAT+DTOS(RF6_DATA)+RF6_TURNO")
	nOrderRf7 := RetOrdem(cAliasRf7,"RF7_FILIAL+RF7_MAT+DTOS(RF7_DATA)+RF7_DEPTO+RF7_POSTO")
	
	cKey := cFil+cMat+Dtos(dDataIni)

	dbSelectArea(cAliasRF6)
	(cAliasRF6)->(dbSetOrder(nOrderRf6))
	
	(cAliasRF6)->(dbSeek(cFil+cMat+Dtos(dDataIni)))
	
	IF Empty( aTurnos )
		/*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Carrega as Trocas de Turno/Regra do Periodo				  Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		DEFAULT aTurnos := {}
		lTrocaTno := fTrocaTno( dDataIni , dDataFim , @aTurnos , NIL , cSeq )
	Else
		lTrocaTno := .T.
	EndIF
	
	IF ( ( nPos := aScan( aTurnos , { |x| x[2] == dDataIni } ) ) > 0 )
		cTno 	:= aTurnos[ nPos , 01 ]
		cSeq	:= aTurnos[ nPos , 03 ]
		cRegra 	:= aTurnos[ nPos , 05 ]
	Else
		If ( ( nPos := aScan( aTurnos , { |x| x[2] < dDataIni } ) ) > 0 )
			cTno 	:= aTurnos[ nPos , 01 ]
			cSeq	:= aTurnos[ nPos , 03 ]
			cRegra 	:= aTurnos[ nPos , 05 ]
		Else
			cRegra	:= SRA->RA_REGRA
		EndIf
	EndIF	

	fTabPadrao( @aTabPadrao , @cFilSPJ , cTno , lExecQryTop )
	
	/*
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Obtem todos os Turnos Opcionais			                   Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/    
	lAllTnoOpc := .F.
	If __lChkTnoOpc
		If lTrocaTno                     
			For nTno:= 1 To Len(aTurnos)               
				//-- Carrega todos os horarios opcionais do turno
		    	If LoadTnoOpc(cFilSPJ, aTurnos[nTno, 1],__aAllTnoOpc, @aTabPadrao)
		    	   lAllTnoOpc := .T.
		    	Endif   
		    Next
		Else
			//-- Carrega todos os horarios opcionais do turno
		    If LoadTnoOpc(cFilSPJ, cNewTno,__aAllTnoOpc, @aTabPadrao)
	    	   lAllTnoOpc := .T.
	    	Endif   
		Endif  
    Endif
        
	/*/
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Carrega as Marcacoes do Funcionario para Ajustar os Turnos  Ё
	Ё em funcao da existencia de turnos opcionais				  Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/	        
	If lAllTnoOpc 
		If Empty(aMarcacoes) 
			GetMarcOpc(	@aMarcacoes						,;	//01 -> Marcacoes dos Funcionarios
						dDataIni - 7					,;	//02 -> Periodo Inicial
						dDataFim + 7					,;	//03 -> Periodo Final
						cFil							,;	//04 -> Filial
						cMat							,;	//05 -> Matricula
						cTno							,;	//06 -> Turno
						cSeq							,;	//07 -> Sequencia de Turno
						cCc								,;	//08 -> Centro de Custo 
						If(lAcumulado, "SPG", "SP8")     ; //09 -> Obtem as marcacoes do Alias conforme o periodo considerado.
					  )         
		Endif  		  
    Endif  	
	
	If Found()
		While (cAliasRF6)->( !Eof() .and. RF6_FILIAL+RF6_MAT == cFil+cMat .and.   ;
							RF6_DATA >= dDataIni .and. RF6_DATA <= dDataFim )
												
			cRegra   := (cAliasRF6)->(RF6_REGRA )			
			cOrdem   := (cAliasRF6)->(RF6_ORDEM )						
			dDataApo := (cAliasRF6)->(RF6_DATA  )
			cCodRef  := (cAliasRF6)->(RF6_CODREF)
			cIdExce  := (cAliasQry)->(RF6_P2ID  )
			cCodJor	 := (cAliasRF6)->(RF6_JORN  )
			cTpExt	 := (cAliasRF6)->(RF6_TPEXT )
			cTpExtN	 := (cAliasRF6)->(RF6_TPEXTN)
			cNonaHr  := (cAliasRF6)->(RF6_NONAHR)
		    nNumMarc := (cAliasRF6)->(RF6_NUMARC)			
		    nIniHnt  := (cAliasRF6)->(RF6_INIHNT)
			nFimHnt  := (cAliasRF6)->(RF6_FIMHNT)
			nMinHnt  := (cAliasRF6)->(RF6_MINHNT)
			cTipDorig:= (cAliasRF6)->(RF6_DORIG )
			cCodPro	 := (cAliasRF6)->(RF6_PROCES)
			cNumPag	 := (cAliasRF6)->(RF6_NUMPAG)
			cCodPer	 := (cAliasRF6)->(RF6_PERIOD)
			cCodRot	 := (cAliasRF6)->(RF6_ROTEIR)			
			cTipoDia := (cAliasRF6)->(RF6_TIPOD)
			cPgNhr	 := (cAliasRF6)->(RF6_NONAHR)						
			cTpExce	 := (cAliasRF6)->(RF6_TPEXCE)
				
			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Guarda os limites da tabela padrao						  Ё
			Ё O limite superior nHorMai e utilizado no primeiro registro  Ё		
			Ё da Data, o nHorMin e utilizado no ultimo registro, os reg.  Ё				
			Ё contidos entre estes sao adicionados em branco			  Ё						
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			nHorMai := (cAliasRF6)->(RF6_HRMAIS)
			nHorMen := (cAliasRF6)->(RF6_HRMENO)
					
			If dDataAnt == dDataApo
				If ( lExceData .and. !( aExcecoes[nExc,46] <> "S" ) ) 
					(cAliasQry)->(dbSkip())
					Loop
				Else
					If ( lExceData )
						nRegAux := nMaxReg + 1
						nTipMarc:= nRegAux
						nMaxReg := nMaxReg + 2
					Else
						nRegAux := 1
						nMaxReg := 2
					EndIf
				EndIf				
			Else
				If( Len(aTabCalend) > 0)
					aTabCalend[ Len(aTabCalend), CALEND_POS_LIM_MARCACAO ] := { dDataLimS, nHorMai }
				EndIf
				cOrdAnt   := (cAliasRF6)->(RF6_ORDEM)
				nTipMarc  := 1
				nLimMarc  := nHorMen
				dDataLimE := (cAliasRF6)->(RF6_MAIS)
				nMaxReg	 := 2
				nRegAux	 := 1
				
				/*/
				зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				Ё Se Houve Alteracao na Tabela Padrao/Regra em Funcao das ExceЁ
				Ё coes, Restaura os Padroes								      Ё
				юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
				IF ( !Empty( aTabOrig ) )
					aTabTno		:= aClone( aTabOrig )
					aTabOrig	:= {}
					cNewReg		:= cRegOrig
					cRegOrig	:= ""
				EndIF
				
				/*/
				зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				Ё Se houver Sincronismo, adiciona a Data de Apontamento  	  Ё
				юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
				IF ( lSncMaMe )
					aAdd( aDataApo, dDataApo)
				EndIF				

				If ( cTurno+cSeq != (cAliasRF6)->(RF6_TURNO)+(cAliasRF6)->(RF6_SEQ) )
					cTurno   := (cAliasRF6)->(RF6_TURNO )
					cSeq     := (cAliasRF6)->(RF6_SEQ   )
				
					/*/
					зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
					Ё Verifica se houve troca de turno, e adiciona no array para  Ё
					Ё formar os elementos do aTurnos - permanencia do legado 	  Ё
					юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
					nPos := aScan( aTurnos, { |x| x[1] == cTurno } ) 
					
					If (nPos == 0)				
						aAdd( aTurnos , { cTurno , dDataIni , cSeq , 0 , cRegra } )
					EndIf
	
					/*
					здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
					Ё Carrega tabela de horario padrao 							   Ё
					юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
					fTabPadrao( @aTabPadrao , cFil, cTurno , lExecQryTop )
						
					If ( nPos := aScan( aSP6Cache, { |x| x[1] == cTurno } ) ) == 0
						aSpAux   := aClone(aSr6Cpo)
						aSr6Info := PosSR6( cTurno , cFil , @aSr6Cpo , 01 , .F. )
						aSr6Cpo  := aClone(aSpAux)
						aAdd( aSp6cache, {cTurno,aSr6Info} )					
		            Else
		                aSr6Info := aClone(aSP6Cache[nPos])
		            Endif
	            
	    		EndIf 
	            
       			/*/
				зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				Ё Pesquisa e Carrega a Tabela do Turno Corrente				  Ё
				юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
				IF ( ( nPos := aScan( aTabPadrao, { |x| x[2] == cTurno .and. ( x[1] == cFilSPJ .or. Empty( x[1] ) ) } ) ) > 0 )
					aTabTno := aClone( aTabPadrao[ nPos , 3 ] )
				EndIF 
				/*
				здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				Ё Carrega as Excecoes para o dia se nao estiver carregada	   Ё
				юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
				If !( lExceData := RetExcId( cFil, cIdExce, dDataApo, cRegra, aAllExc, aExcecoes ) )
					If lAllTnoOpc
					   	/*/
						зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
						Ё Salva a Tabela Padrao/Regra da Semana Que Serao  ModificadosЁ
						Ё em Funcao de Excecoes										  Ё
						юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
						aTabOrig  := aClone( aTabTno )
						cRegOrig  := cNewReg
					   ( lTnoOpcData:=GetTnoOpc( cNewTno, dData, @aDiaTurnoOK, aTabPadrao, @aTabTno[nPos], cFilSPJ, @aMarcacoes))
					Else
						If lPnmTab01 
							If ( ValType( uRet 	:= ExecBlock("PNMTAB01",.F.,.F., { cFil, cMat , dDataApo, cTurno, aClone(aTabTno[nPos]) }) ) == "A" )
								If (lTnoSubstituto  := !Empty(uRet) )
									 /*/
								    здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
								    Ё Troca a tabela de horario do turno do dia pela do Ponto de Entrada           Ё
								    юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/    
									aTabTno[nPos] 	:= aClone(uRet)
								Endif	
								uRet := NIL
							EndIf
						EndIf				
				    EndIf
				Else
					/*/
					зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
					Ё Salva a Tabela Padrao/Regra da Semana Que Serao  ModificadosЁ
					Ё em Funcao de Excecoes										  Ё
					юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
					nExc := aScan( aExcecoes, { |x|  x[59] == cIdExce } )
					aTabOrig  := aClone( aTabTno )
					cRegOrig  := cNewReg
				EndIf
				
			EndIf						
	
			If (cAliasRF6)->(RF6_CHKTNO) == "S" .and. lAllTnoOpc
				(cAliasRF6)->( dbSkip() )
				Loop
			EndIf
			
			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Obtem as Informacoes em Cache da Regra de Apontamento       Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			aSpaInfo := PosSPA( (cAliasRF6)->(RF6_REGRA) , cFil , @aSpaInfo , 01 , .F. )
			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Verifica Quais Intervalos Sao Pagos             			  Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			cPagInt := aSpaInfo[1]
	
			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Verifica Se o Dia em Questao eh um Feriado				  Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			lTrbFeriado := .F.
			If ( lFeriado := fFeriado( cFil , (cAliasRF6)->(RF6_DATA) ) )
				cP3TpExt		:= SP3->P3_TPEXT
				cP3TpExtN		:= SP3->P3_TPEXTN
				cP3Desc			:= SP3->P3_DESC
				lTrbFeriado := ( aSpaInfo[2] == "S" )
			Else
				cP3TpExt	:= ""
				cP3TpExtN	:= ""
				cP3Desc		:= ""
			EndIF
			
			cCodPro	 := (cAliasRF6)->(RF6_PROCES)
			cNumPag	 := (cAliasRF6)->(RF6_NUMPAG)
			cCodPer	 := (cAliasRF6)->(RF6_PERIOD)
			cCodRot	 := (cAliasRF6)->(RF6_ROTEIR)			
			
			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Verificar se o Funcionario Esta Afastado na Data			  Ё
			Ё atraves do R8_NUMID - Identificador unico de afastamento	  Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/ 
			If ( (cAliasRF6)->(RF6_R8ID) != cIdAfas )
				lAfast := fAfasta( cFil, cMat, aTabCalend[ nCal, CALEND_POS_DATA ], @dIniAfas, @dFimAfas, @cTipAfast, aAfasta, @cIdAfas )
				
				/*/
				зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				Ё Se estiver Afastado Define o Dia como Nao Trabalhado        Ё
				юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
				If ( lAfast )
					cTipoDia := "N"	//Nao Trabalhado
				EndIF
				
				/*/
				зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				Ё Verifica se Aponta para Funcionario em Ferias            	  Ё
				юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
				If ( cTipAfast == "F" )
					If ( lAponFer := ( aSr6Info[4] == "S" ) )
		
						/*/
						зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
						Ё Se funcionario em Ferias com Direito a Apontamento       	  Ё
						юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
						cTpExNorFer	:= aSr6Info[5]	//Normal Ferias
						cTpExNotFer	:= aSr6Info[6]	//Noturna Ferias
		
						/*/
						зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
						Ё Verifica se horas extras sao autorizadas para funcionario   Ё
						Ё em ferias.												  Ё
						юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
						lHeAutoFer := If ( aSr6Info[7] == "1" .or. Empty( aSr6Info[7] ), .T. , .F. )	 // 1 ou branco - Autorizadas (Padrao) , 2- Nao Autorizadas
		
					EndIf
				Else
					/*/
					зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
					Ё Se funcionario nao Trabalha em Feriado e dia For Feriado 	  Ё
					юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
					If (;
					 		( lFeriado );			//Dia eh Feriado
					 		.and.;
					 		!( lTrbFeriado );		//Funcionario Nao Trabalha em Feriado
					 	)
						cTipoDia := "F" //Feriado
					EndIF
				EndIf
		    EndIf
		    
    	    nSeq := Val( (cAliasQry)->(RF6_SEQ) )
    	    
			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			ЁVerifica se o Dia da Semana da Sequencia e equivalente ao DiaЁ
			Ёda Data a Ser Pesquisada. Pesquisa a Sequencia  Primeiro  comЁ
			Ёo StrZero( n , 1 ) "0" e Depois com o StrZero( n , 2 ) "00"  Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			bAsc := { |x| (	AllTrim( x[19] ) == StrZero( nSeq , IF( nSeq < 10 , 1 , 2 ) ) .or. AllTrim( x[19] ) == StrZero( nSeq , 2 ) ) }
			IF !( lCriaCalOk := ( nPos := aScan( aTabTno , bAsc ) ) > 0 )
				Break
			EndIF    	    
	    		      		    
		    (cAliasRF7)->(dbSetOrder(nOrderRf7))		    
			cKeyRf7 := cFil+cMat+Dtos(dDataApo)		    
		    (cAliasRF7)->(dbSeek(cKeyRf7))
		    
		    While (cAliasRF7)->( !Eof() .and. RF7_FILIAL+RF7_MAT == cFil+cMat .and.	RF7_DATA == dDataApo )

					
					If !( lExceData := Empty( (cAliasRF6)->(RF6_P2ID) ) )
		
						/*/
					   здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
					   Ё Checa a Existencia de Turnos Opcionais				          Ё
					   юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/    
					 	If lAllTnoOpc
		
					 		aDiaTurnoOk := {}
							AADD( aDiaTurnoOK, {dDataApo, SPACE(1) } )
					 		
						   	/*/
							зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
							Ё Salva a Tabela Padrao/Regra da Semana Que Serao  ModificadosЁ
							Ё em Funcao de Excecoes										  Ё
							юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
							aTabOrig  := aClone( aTabTno )
							cRegOrig  := cNewReg
							aTabTno := Clone( aTabPadrao )
						    GetTnoOpc( cTurno, dDataApo, @aDiaTurnoOK, aTabPadrao, @aTabTno[nPos], cFil, @aMarcacoes)
						 EndIf
					Else
								
						IF ( aExcecoes[nExc,46] <> "S" )	
						
							nNumMarc := 0
																
							aTabTno[nPos,01] 	:= aExcecoes[nExc,05]		// 01 - 1a Entrada
							aTabTno[nPos,02] 	:= aExcecoes[nExc,06]		// 02 - 1a Saida
							aTabTno[nPos,03] 	:= aExcecoes[nExc,07]		// 03 - 2a Entrada
							aTabTno[nPos,04] 	:= aExcecoes[nExc,08]		// 04 - 2a Saida
							aTabTno[nPos,05] 	:= aExcecoes[nExc,09]		// 05 - 3a Entrada
							aTabTno[nPos,06] 	:= aExcecoes[nExc,10]		// 06 - 3a Saida
							aTabTno[nPos,07] 	:= aExcecoes[nExc,11]		// 07 - 4a Entrada
							aTabTno[nPos,08] 	:= aExcecoes[nExc,12]		// 08 - 4a Saida
							aTabTno[nPos,09] 	:= aExcecoes[nExc,16]		// 09 - Horas Trabalhadas 1a. Jornada
							aTabTno[nPos,10] 	:= aExcecoes[nExc,17]		// 10 - Horas Trabalhadas 2a. Jornada
							aTabTno[nPos,11] 	:= aExcecoes[nExc,18]		// 11 - Horas Trabalhadas 3a. Jornada
							aTabTno[nPos,12] 	:= aExcecoes[nExc,19]		// 12 - Horas Trabalhadas 4a. Jornada
							aTabTno[nPos,13] 	:= aExcecoes[nExc,26]		// 13 - Horas de Intervalo 1S
							aTabTno[nPos,14] 	:= aExcecoes[nExc,27]		// 14 - Horas de Intervalo 2S
							aTabTno[nPos,15] 	:= aExcecoes[nExc,28]		// 15 - Horas de Intervalo 3S
							aTabTno[nPos,16] 	:= ""						// 16 - Marcacao e do dia seguinte ?
							aTabTno[nPos,17] 	:= aExcecoes[nExc,20]		// 17 - Numero de Marcacoes					
							aTabTno[nPos,29] 	:= aExcecoes[nExc,34]		// 29 - Aponta Nona Hora
							aTabTno[nPos,30] 	:= aExcecoes[nExc,35]		// 30 - Limite de Horario Inicial
							aTabTno[nPos,31] 	:= aExcecoes[nExc,36]		// 31 - Limite de Horario Final
							aTabTno[nPos,32] 	:= aExcecoes[nExc,37]		// 32 - 1a. Jornada Continua
							aTabTno[nPos,33] 	:= aExcecoes[nExc,38]		// 33 - 2a. Jornada Continua
							aTabTno[nPos,34]	:= aExcecoes[nExc,39]		// 34 - 3a. Jornada Continua
							aTabTno[nPos,35]	:= aExcecoes[nExc,40]		// 35 - 4a. Jornada Continua
							aTabTno[nPos,36]	:= aExcecoes[nExc,41]		// 36 - Codigo da Refeicao
							
							For nReg := 5 To 11 Step 2
								If ( aExcecoes[nExc,23] == "S" )
									If ( !Empty(aExcecoes[nExc,nReg]) )
										nMaxReg := nMaxReg + 2
										nNumMarc++															
									EndIf
								Else
									nReg	:= 11
									nAuxReg := 1
									nMaxReg := 2
									nNumMarc:= 2
								EndIf
							Next
						Else
							nMaxReg := nNumMarc					
					    EndIf
				
						aTabTno[nPos,18] 	:= aExcecoes[nExc,23]			// 18 - Tipo do Dia
						aTabTno[nPos,19] 	:= aExcecoes[nExc,19]	   		// 19 - Sequencia da Marcacao
						aTabTno[nPos,20] 	:= Dow( dDataApo )     			// 20 - Numero Correspondente ao Dia da Semana
						aTabTno[nPos,21] 	:= "E"							// 21 - Flag Indicador de Excecao
						aTabTno[nPos,22] 	:= aExcecoes[nExc,21]			// 22 - Motivo da Excecao
						aTabTno[nPos,23] 	:= aExcecoes[nExc,22]			// 23 - Codigo Hora Extra Normal
						aTabTno[nPos,24] 	:= aExcecoes[nExc,24]			// 24 - Codigo Hora Extra Noturna
						aTabTno[nPos,25] 	:= aExcecoes[nExc,29]			// 25 - Centro de Custo Periodo 1 (1a.E-1a.S)
						aTabTno[nPos,26] 	:= aExcecoes[nExc,30]			// 26 - Centro de Custo Periodo 2 (2a.E-2a.S)
						aTabTno[nPos,27] 	:= aExcecoes[nExc,31]			// 27 - Centro de Custo Periodo 3 (3a.E-3a.S)
						aTabTno[nPos,28] 	:= aExcecoes[nExc,32]			// 28 - Centro de Custo Periodo 4 (4a.E-4a.S)		
						aTabTno[nPos,38] 	:= aExcecoes[nExc,47]			// 38 - Funcoes Periodo 1 (1a.E-1a.S)
						aTabTno[nPos,39] 	:= aExcecoes[nExc,48]			// 39 - Funcoes Periodo 2 (2a.E-2a.S)
						aTabTno[nPos,40] 	:= aExcecoes[nExc,49]			// 40 - Funcoes Periodo 3 (3a.E-3a.S)
						aTabTno[nPos,41] 	:= aExcecoes[nExc,50]			// 41 - Funcoes Periodo 4 (4a.E-4a.S)				
						aTabTno[nPos,58] 	:= aExcecoes[nExc,55]			// 58 - Depto Periodo 1 (1a.E-1a.S)
						aTabTno[nPos,59] 	:= aExcecoes[nExc,56]			// 59 - Depto Periodo 2 (2a.E-2a.S)
						aTabTno[nPos,60] 	:= aExcecoes[nExc,57]			// 60 - Depto Periodo 3 (3a.E-3a.S)
						aTabTno[nPos,61] 	:= aExcecoes[nExc,58]			// 61 - Depto Periodo 4 (4a.E-4a.S)
						aTabTno[nPos,62] 	:= aExcecoes[nExc,51]			// 62 - Posto Periodo 1 (1a.E-1a.S)
						aTabTno[nPos,63] 	:= aExcecoes[nExc,52]			// 63 - Posto Periodo 2 (2a.E-2a.S)
						aTabTno[nPos,64] 	:= aExcecoes[nExc,53]			// 64 - Posto Periodo 3 (3a.E-3a.S)
						aTabTno[nPos,65] 	:= aExcecoes[nExc,54]			// 65 - Posto Periodo 4 (4a.E-4a.S)								

		            EndIf
            
		            If ( lExceData .or. lAllTnoOpc )  
			            cTipoDia	:= aTabTno[ nPos , 18 ]
						cSeq		:= aTabTno[ nPos , 19 ]			            
			            cMotExc		:= aTabTno[ nPos , 22 ]
			            cNonaHr		:= aTabTno[ nPos , 29 ]
						nHorMen		:= aTabTno[ nPos , 30 ]
						nHorMai		:= aTabTno[ nPos , 31 ]
			            cCodRef		:= aTabTno[ nPos , 36 ]
						cCodJor		:= aTabTno[ nPos , 70 ]
						
						nLimMarc	:= nHorMai
					Endif		    
				/*/
				зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				ЁPara cada um registro, carrega dois elementos no array		  Ё
				ЁPq para cada linha do calendario fisico existe uma entrada e |
				Ёuma saida, tabela RF7 										  Ё
				юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
				For nReg := 1 To nMaxReg
				
					nHrTrab	 := (cAliasRF7)->(RF7_HRTRAB)
					nHrInte	 := (cAliasRF7)->(RF7_HRINTV)
					cCcCal 	 := (cAliasRF7)->(RF7_CC )
					cFuncCal := (cAliasRF7)->(RF7_CODFUN )
					cJndCont := (cAliasRF7)->(RF7_JNDCO )
					cDepto	 := (cAliasRF7)->(RF7_DEPTO )
					cPosto	 := (cAliasRF7)->(RF7_POSTO )
									
					If AllTrim(Str(nReg)) $ "1_3_5_7"
						nHora    := (cAliasRF7)->(RF7_ENTRA)
						nLimInfE := (cAliasRF7)->(RF7_LIE  )
						nLimSupE := (cAliasRF7)->(RF7_LSE  )			
					Else
						nHora    := (cAliasRF7)->(RF7_SAIDA)
						nLimInfS := (cAliasRF7)->(RF7_LIS  )
						nLimSupS := (cAliasRF7)->(RF7_LSS  )
					EndIf

					If AllTrim(Str(nReg)) $ "1_3_5_7"
						dData    := (cAliasQry)->(RF7_DATAE)
					Else
						dData    := (cAliasQry)->(RF7_DATAS)
					EndIf
           
            		If ( lExceData .or. lAllTnoOpc )

						/*/
						здддддддддддддддддддддддддддддддддддддддддддддддддддддд©
						Ё Incrementa dData Quando Marcacao for do Dia Seguinte Ё
						юдддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
						IF ( aTabTno[ nPos , nReg ] <  aTabTno[ nPos , IF( nReg == 1 , nReg , nReg-1 ) ] )
							++dData
							nSerial		:= ( __fDhToNS( dData , aTabTno[ nPos , nReg ] ) - __fDhToNS( NIL , aTabTno[ nPos , 30 ] ) )
							dDataLimE	:= __fNsToDh( nSerial , "D" )
							nLimMarc	:= __fNsToDh( nSerial , "H" )					
						EndIF		

						Do Case
							Case ( Str( nTipMarc ) $ "1" )
								cCcCal 		:= aTabTno[ nPos , 25 ] 
								cFuncCal 	:= aTabTno[ nPos , 38 ]
								cJndCont	:= aTabTno[ nPos , 32 ]
								cDepto		:= aTabTno[ nPos , 58 ]
								cPosto		:= aTabTno[ nPos , 62 ]
								IF ( nReg == 1 )
									nHora	 := aTabTno[ nPos , 01 ]
									nHrTrab  := aTabTno[ nPos , 09 ]
									nLimInfE := aTabTno[ nPos , 42 ]
									nLimSupE := aTabTno[ nPos , 43 ]
								Else
									nHora	 := aTabTno[ nPos , 02 ]
									nHrInte  := aTabTno[ nPos , 13 ]
									nLimInfS := aTabTno[ nPos , 44 ]
									nLimSupS := aTabTno[ nPos , 45 ]
								EndIF
							Case ( Str( nTipMarc ) $ "2" )
								cCcCal 		:= aTabTno[ nPos , 26 ]
								cFuncCal 	:= aTabTno[ nPos , 39 ]
								cJndCont	:= aTabTno[ nPos , 33 ]
								cDepto		:= aTabTno[ nPos , 59 ]
								cPosto		:= aTabTno[ nPos , 63 ]
								IF ( nReg == 3 )
									nHora	 := aTabTno[ nPos , 03 ]
									nHrTrab  := aTabTno[ nPos , 10 ]
									nLimInfE := aTabTno[ nPos , 46 ]
									nLimSupE := aTabTno[ nPos , 47 ]
								Else
									nHora	 := aTabTno[ nPos , 04 ]
									nHrInte  := aTabTno[ nPos , 14 ]
									nLimInfS := aTabTno[ nPos , 48 ]
									nLimSupS := aTabTno[ nPos , 49 ]
								EndIF
							Case ( Str( nTipMarc ) $ "3" )
								cCcCal 		:= aTabTno[ nPos , 27 ]
								cFuncCal 	:= aTabTno[ nPos , 40 ]
								cJndCont	:= aTabTno[ nPos , 34 ]
								cDepto		:= aTabTno[ nPos , 60 ]
								cPosto		:= aTabTno[ nPos , 64 ]
								IF ( nReg == 5 )
									nHora	 := aTabTno[ nPos , 05 ]
									nHrTrab  := aTabTno[ nPos , 11 ]
									nLimInfE := aTabTno[ nPos , 50 ]
									nLimSupE := aTabTno[ nPos , 51 ]
								Else
									nHora	 := aTabTno[ nPos , 06 ]
									nHrInte  := aTabTno[ nPos , 15 ]
									nLimInfS := aTabTno[ nPos , 52 ]
									nLimSupS := aTabTno[ nPos , 53 ]
								EndIF
							Case ( Str( nTipMarc ) $ "4" )
								cCcCal 		:= aTabTno[ nPos , 28 ]
								cFuncCal 	:= aTabTno[ nPos , 41 ]
								cJndCont	:= aTabTno[ nPos , 35 ]
								cDepto		:= aTabTno[ nPos , 61 ]
								cPosto		:= aTabTno[ nPos , 65 ]
								IF ( nReg == 7 )
									nHora	 := aTabTno[ nPos , 07 ]
									nHrTrab  := aTabTno[ nPos , 12 ]
									nLimInfE := aTabTno[ nPos , 54 ]
									nLimSupE := aTabTno[ nPos , 55 ]
								Else
									nHora	 := aTabTno[ nPos , 08 ]
									nLimInfS := aTabTno[ nPos , 56 ]
									nLimSupS := aTabTno[ nPos , 57 ]
								EndIF
						EndCase
		            EndIf
		                
					aAdd( aTabCalend, Array( ELEMENTOS_ATABCALEND ) )		
					nCal := Len(aTabCalend)
			
					aTabCalend[	nCal,	CALEND_POS_DATA		 ] := dData														// 01 - Data
					aTabCalend[	nCal,	CALEND_POS_ORDEM	 ] := cOrdem 													// 02 - Ordem
					aTabCalend[	nCal,	CALEND_POS_HORA		 ] := nHora														// 03 - Hora			
					
					If AllTrim(Str(nReg)) $ "1_3_5_7"
						aTabCalend[	nCal, CALEND_POS_TIPO_MARC ] := AllTrim(Str(nTipMarc)+"E")								// 04 - Tipo Marc
					Else
						aTabCalend[	nCal, CALEND_POS_TIPO_MARC ] := AllTrim(Str(nTipMarc)+"S")								// 04 - Tipo Marc
						nTipMarc++
					EndIf					
					
					aTabCalend[	nCal,	CALEND_POS_NUM_MARC	 		] := nNumMarc		    								// 05 - No Marc.
					aTabCalend[	nCal,	CALEND_POS_TIPO_DIA	 		] := cTipoDia											// 06 - Tipo Dia						
					aTabCalend[	nCal,	CALEND_POS_HRS_TRABA 		] := nHrTrab											// 07 - Horas Trabalhada no Periodo							
					aTabCalend[	nCal,	CALEND_POS_SEQ_TURNO 		] := cSeq												// 08 - Sequ┬ncia de Turno
					aTabCalend[	nCal,	CALEND_POS_HRS_INTER 		] := nHrInte											// 09 - Horas de Intervalo			
		
					aTabCalend[	nCal,	CALEND_POS_EXCECAO			] := If( !Empty(cMotExc), "E", "" )						// 10 - Excecao ( E-Excecao, # E - nao e excecao )
					aTabCalend[	nCal,	CALEND_POS_MOT_EXECAO		] := cMotExc											// 11 - Motivo da Excecao		
					aTabCalend[	nCal,	CALEND_POS_TIPO_HE_NOR		] := cTpExt												// 12 - Tipo de hora extra normal
					aTabCalend[	nCal,	CALEND_POS_TIPO_HE_NOT		] := cTpExtN											// 13 - Tipo de hora extra noturna
					aTabCalend[	nCal,	CALEND_POS_TURNO			] := cTurno												// 14 - Turno de Trabalho
					aTabCalend[	nCal,	CALEND_POS_CC				] := cCCcal												// 15 - Centro de Custo do Periodo
					aTabCalend[	nCal,	CALEND_POS_PG_NONA_HORA		] := cNonaHr											// 16 - Pagamento de Nona Hora
					aTabCalend[	nCal,	CALEND_POS_LIM_MARCACAO		] := { dDataLimE, nLimMarc }							// 17 - Limite de Marcacao Inicial					
					aTabCalend[	nCal,	CALEND_POS_COD_REFEICAO		] := cCodRef										   	// 18 - Codigo da Refeicao
					aTabCalend[	nCal,	CALEND_POS_FERIADO			] := lFeriado											// 19 - Dia e Feriado
					aTabCalend[	nCal,	CALEND_POS_TP_HE_FER_NR		] := cP3TpExt											// 20 - Tipo de Hora Extra Feriado Normal
					aTabCalend[	nCal,	CALEND_POS_TP_HE_FER_NT 	] := cP3TpExtN											// 21 - Tipo de Hora Extra Feriado Noturna
					aTabCalend[	nCal,	CALEND_POS_DESC_FERIADO		] := cP3Desc											// 22 - Descricao do Feriado	
					aTabCalend[	nCal,	CALEND_POS_REGRA			] := cRegra 					   						// 23 - Regra de Apontamento
					aTabCalend[	nCal,	CALEND_POS_AFAST			] := lAfast												// 24 - Funcionario Afastado
					aTabCalend[	nCal,	CALEND_POS_TIP_AFAST		] := cTipAfast											// 25 - Tipo de Afastamento
					aTabCalend[	nCal,	CALEND_POS_INI_AFAST		] := dIniAfas 											// 26 - Data Inicial do Afastamento
					aTabCalend[	nCal,	CALEND_POS_FIM_AFAST		] := dFimAfas											// 27 - Data Final do Afastamento	
					aTabCalend[	nCal,	CALEND_POS_INI_H_NOT		] := nIniHnt 											// 28 - Inicio da Hora Noturna
					aTabCalend[	nCal,	CALEND_POS_FIM_H_NOT		] := nFimHnt 											// 29 - Final da Hora Noturna
					aTabCalend[	nCal,	CALEND_POS_MIN_H_NOT		] := nMinHnt 											// 30 - Minutos da Hora Noturna				
					aTabCalend[	nCal,	CALEND_POS_TRAB_FERIADO		] := lTrbFeriado										// 31 - Se funcionario Trabalha em Dias Feriados
					aTabCalend[	nCal,	CALEND_POS_APON_FERIAS		] := lAponFer											// 32 - Se Aponta Quando Afastamento em Ferias
					aTabCalend[	nCal,	CALEND_POS_TP_HE_NR_FER		] := cTpExNorFer										// 33 - Tipo de hora extra normal (Ferias)
					aTabCalend[	nCal,	CALEND_POS_TP_HE_NT_FER		] := cTpExNotFer										// 34 - Tipo de hora extra noturna (Ferias)
					aTabCalend[	nCal,	CALEND_POS_PAGINT			] := cPagInt											// 35 - Tipos de Intervalos Que sao Pagos conforme Regra
					aTabCalend[ nCal,   CALEND_POS_TIPO_ORIG_DIA    ] := cTipDorig											// 36 - Tipo Original do Dia conforme excecao mas sem considerar a regra e/ou afastamentos			
					aTabCalend[ nCal,   CALEND_POS_HE_AUTO_FER      ] := lHeAutoFer											// 37 - Se H.Extras sЦo autorizadas para funcionario em ferias					
					aTabCalend[ nCal,   CALEND_POS_CODFUNC 		    ] := cFuncCal											// 38 - Codigo de funcao
					aTabCalend[ nCal,   CALEND_POS_DEPTO  		    ] := cDepto												// 39 - Codigo de Depto. do funcionario
					aTabCalend[ nCal,   CALEND_POS_POSTO  		    ] := cPosto												// 40 - Codigo do Posto do funcionario
					aTabCalend[ nCal,   CALEND_POS_PERIODO 		    ] := cCodPer											// 41 - Periodo
					aTabCalend[ nCal,   CALEND_POS_ROTEIRO 		    ] := cCodRot											// 42 - Roterio
					aTabCalend[ nCal,   CALEND_POS_PROCESSO		    ] := cCodPro											// 44 - Num. de Pagamento
					aTabCalend[ nCal,   CALEND_POS_NUM_PAGTO	    ] := cNumPag											// 43 - Processo
					aTabCalend[ nCal,   CALEND_POS_JORN			    ] := cCodJor											// 45 - Cod. da Jornada
					aTabCalend[ nCal,   CALEND_POS_P2ID				] := cIdExce 				   							// 46 - Lote da excecao
					aTabCalend[ nCal,   CALEND_POS_R8ID				] := cIdAfas											// 47 - Identificacao afastamento
					aTabCalend[ nCal,   CALEND_POS_DATA_APO			] := dDataApo											// 48 - Data de apontamento					
					aTabCalend[ nCal,   CALEND_POS_JND_CON			] := cJndCont											// 49 - Jornada continua						
					aTabCalend[ nCal,   CALEND_POS_LIE				] := nLimInfE 											// 50 - Limite inferior da entrada
					aTabCalend[ nCal,   CALEND_POS_LSE				] := nLimSupE											// 51 - Limite superior da entrada
					aTabCalend[ nCal,   CALEND_POS_LIS				] := nLimInfS											// 52 - Limite inferior da saida
					aTabCalend[ nCal,   CALEND_POS_LSS				] := nLimSupS 											// 53 - Limite inferior da saida
					aTabCalend[ nCal,   CALEND_POS_TPEXCE			] := cTpExce											// 54 - Tipo de Excecao "F" - Funcionario / "P" - Periodo
					
					/*/
					зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
					ЁZera o limite, pois so vai inserir no primeiro registro e no Ё
					Ёultimo registro da ordem existente no calendario			  Ё
					юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
					nLimMarc  := 0
					dDataLimS := (cAliasRF7)->(RF7_DATAS)
					dDataLimE := Ctod("//")				
					
					//-- Se Entrada
					If AllTrim(Str(nReg)) $ "1_3_5_7"
						dDataLimE := Ctod("//") 	
					Else//-- Se Saida
						If ( lExceData .or. lAllTnoOpc )
							nSerial		:= ( __fDhToNS( aTabCalend[ nCal , CALEND_POS_DATA ] , aTabCalend[ nCal , CALEND_POS_HORA ] ) + __fDhToNS( NIL ,aTabTno[ nPos , 31 ]) )
							dDataLimS	:= __fNsToDh( nSerial , "D" )
							nHorMai  	:= __fNsToDh( nSerial , "H" )
						Else
							dDataLimS := (cAliasQry)->(RF7_DATAS)				
						EndIF				
					Endif

				Next

				cIdExce	  := ""
				cTpExce	  := ""
				cMotExc	  := ""
		
				/*/
				зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				ЁGrava as alteracoes do calendario em funcao da troca de hor. Ё
				Ёpelo turno opcional										  Ё
				юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/		
				If lAllTnoOpc
					GravaTnoOpc( nCal, (cAliasRF6)->(Recno()), (cAliasRF7)->(Recno()), If( nReg == 1, 1, 2), aTabCalend )
				EndIf		    						    							    					
				
				cIdExce	  := ""
				cTpExce	  := ""
				cMotExc	  := ""
		    
		    EndDo    
		    
		    (cAliasRF7)->(dbSkip())
		    (cAliasRF6)->(dbSkip())
			
		EndDo
			
		If !Empty(aTabCalend)
			aTabCalend[ Len(aTabCalend), CALEND_POS_LIM_MARCACAO ] := { dDataLimS, nHorMai }
			lRet := .T.	
		EndIf		
		
	Else
		lRet := .F.	
	EndIf
	
#ENDIF

/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
ЁArray aTabCalend carregado 								  Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
If lRet
	nRet := 1
	
	/*/
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	ЁSincroniza horarios iniciais da tabela para evitar intervalosЁ
	Ёentre os limites inicial do dia corrente e final do dia  anteЁ
	Ёrior.														  Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	IF ( lSncMaMe )
		CalSncMaMe(	@aTabCalend	,;	//01 -> Calendario de Marcacoes
					@aTabPadrao	,;	//02 -> Tabela de Horario Padrao
					aDataApo	,;	//03 -> Array com as Datas de Apontamento do Calendario
					dDataIni	,;	//04 -> Inicio do Periodo de Apontamento
					dDataFim	,; 	//05 -> Final do Periodo de Apontamento
					cTno		,;	//06 -> Turno de Trabalho
					cSeq		,;	//07 -> Sequencia de Turno
					cFil     	,;	//08 -> Filial do Funcionario
					cMat   		,;	//09 -> Matricula do Funcionario
					cCC   		,;	//10 -> Centro de Custo do Funcionario
					.F.			,;	//11 -> Marcacoes Sendo carregadas pela Ordem
					.T.			 ;	//12 -> Se o Calendario esta sendo Montado por Funcionario
		   		   )
	EndIf
	
EndIf
              
#IFDEF TOP                           
	(cAliasQry)->(DbCloseArea())
#ENDIF         

RestArea(aArea)

Return ( nRet )

/*/
зддддддддддбддддддддддддддбдддддддбдддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁGravaTnoOpc	  Ё Autor Ё Igor Franzoi	  Ё Data Ё26/11/2007Ё
цддддддддддеддддддддддддддадддддддадддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁGrava os elementos alterados no aTabCalend pelo turno 		Ё
Ё		   Ёopcional													Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё< Vide Parametros Formais >								    Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ< Vide Parametros Formais >									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       Ё Generico                                                   Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function GravaTnoOpc( nPos, nRecnoRf6, RecnoRf7, nTip, aTabCalend )

Local cAliasRf6   := "RF6"
Local cAliasRf7	  := "RF7"

If nTip == 1

	(cAliasRf6)->(dbGoTo(nRecnoRf6))
	Reclock( "RF6", .T., .F. )
		(cAliasRf6)->( "RF6_CHKTNO" ) := "S"
	(cAliasRf6)->( MsUnlock() )
	
	(cAliasRf7)->(dbGoto(nRecnoRf7))
	RecLock( "RF7", .T., .F. )
				
				(cAliasRf7)->( "RF7_ENTRA" ) := aTabCalend[ nPos,   CALEND_POS_HORA]
				(cAliasRf7)->( "RF7_LIE" ) := aTabCalend[ nPos,   CALEND_POS_LIE ] 
				(cAliasRf7)->( "RF7_LSE" ) := aTabCalend[ nPos,   CALEND_POS_LSE ] 
				
	(cAliasRf7)->( MsUnlock() )
Else

	RF6->(dbGoTo(nRecnoRf6))
	Reclock( "RF6", .T., .F. )
		(cAliasRf6)->( "RF6_CHKTNO" ) := "S"				
	(cAliasRf6)->( MsUnlock() )
	
	RF7->(dbGoto(nRecnoRf7))
	RecLock( "RF7", .T., .F. )
				
				(cAliasRf7)->( "RF7_SAIDA" ) := aTabCalend[ nPos,   CALEND_POS_HORA]
				(cAliasRf7)->( "RF7_LIS" ) := aTabCalend[ nPos,   CALEND_POS_LIS ] 
				(cAliasRf7)->( "RF7_LSS" ) := aTabCalend[ nPos,   CALEND_POS_LSS ] 	
				
	(cAliasRf7)->( MsUnlock() )

EndIf

Return ( NIL )
                             
/*/
зддддддддддбддддддддддддддбдддддддбдддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁCalendVirtual Ё Autor Ё Marinaldo de JesusЁ Data Ё15/12/2003Ё
Ё          Ё			  Ё Ver.02| Igor Franzoi	  Ё Data Ё23/11/2007Ё
цддддддддддеддддддддддддддадддддддадддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁCria Calendario Virtual.                                    Ё
Ё          ЁAlimenta  um Array com o Calend═rio de um Per║odo.          Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё< Vide Parametros Formais >								    Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ< Vide Parametros Formais >									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       Ё Generico                                                   Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function CalendVirtual(	dDataIni	,; //01 -> Data Inicial do Periodo
		 				dDataFim	,; //02 -> Data Final do Periodo
						cTno		,; //03 -> Turno Para a Montagem do Calendario
						cSeq		,; //04 -> Sequencia Inicial para a Montagem Calendario
						aTabPadrao	,; //05 -> Array Tabela de Horario Padrao
						aTabCalend	,; //06 -> Array com o Calendario de Marcacoes
						cFil		,; //07 -> Filial para a Montagem da Tabela de Horario
						cMat		,; //08 -> Matricula para a Montagem da Tabela de Horario
						cCc			,; //09 -> Centro de Custo para a Montagem da Tabela
						aTurnos		,; //10 -> Array com as Trocas de Turno
						aExcePer	,; //11 -> Array com Todas as Excecoes do Periodo
						lExecQryTop ,; //12 -> Se executa Query para a Montagem da Tabela Padrao
						lSncMaMe	,; //13 -> Se executa a funcao se sincronismo do calendario
						lForceNew	,; //14 -> Se Forca a Criacao de Novo Calendario
						aMarcacoes  ,; //15 -> Array com marcacoes para tratamento de Turnos Opcionais
						lTabCalen	;  //16 -> Nao zerar o array aTabCalend - Calendario Complementar						
					)

Local lCriaCalOk	:= .T.
Local lNewCalend	:= .F.
Local lChkMat		:= ( cMat <> NIL )
Local lAcumulado	:= .F.
Local aTipo
Local dDataAux                                       
Local dPerIni
Local dPerFim
Local dPerAuxIni
Local dPerAuxFim
Local dIniCalend
Local dFimCalend
Local bQualSeq
Local nPosTrcT
Local nLoop
Local nLoops
Local lError	:= ( Type("oCalendError") <> "U" )

DEFAULT lSncMaMe	:= .F.
DEFAULT lForceNew	:= .T.
DEFAULT aMarcacoes	:= {}
DEFAULT __lChkTnoOpc	:= IF( ( ( SR6->(FIELDPOS( "R6_TNOOPC" )) != 0) .and.  ( SuperGetMv("MV_TNOOPC",NIL,"N") == "S" ) ) ,.T. , .F. )   // ATENCAO ALTERAR ESSA LINHA ANTES de SUBIR
DEFAULT lPnmTab01		:= ExistBlock( "PNMTAB01" )
DEFAULT lTabCalen	:= .T.

Begin Sequence

	/*/
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Garanto que dDataFim nunca sera menor que dDataIni          Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	IF ( dDataFim < dDataIni )
		dDataAux := dDataIni
		dDataIni := dDataFim
		dDataFim := dDataAux	
	EndIF
   
   	/*/
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Verifica se Devera Criar Novo Calendario                    Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	IF ( ( lChkMat ) .and. ( lForceNew ) )
		IF ( ( __dPerCalIni == NIL ) .Or. ( __dPerCalFim == NIL ) ) .Or. Type("oPeriodo") == "U"
				SetMemVar("oPeriodo" , RHPERIODO():New() , .T. , .T. )
				oPeriodo:cProcesso := SRA->RA_PROCES
				oPeriodo:GetPer()
				IF !( lCriaCalOk := oPeriodo:lFound)
					If lError
						oCalendError:SendError('04',Nil, .T.)
					EndIf
					Break
				EndIF
			__dPerCalIni := oPeriodo:dDataIni
			__dPerCalFim := oPeriodo:dDataFim
			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Garanto que __dPerCalFim nunca sera menor que __dPerCalIni  Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			IF ( __dPerCalFim < __dPerCalIni )
				dDataAux 		:= __dPerCalIni
				__dPerCalIni	:= __dPerCalFim
				__dPerCalFim	:= dDataAux	
			EndIF
		EndIF	
		dPerIni := __dPerCalIni
		dPerFim := __dPerCalFim
		/*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Forca a Criacao de um novo Calendario sempre que o   PeriodoЁ
		Ё for Diferente do Periodo Atual para que Busquemos o Turno	 eЁ
		Ё a Sequencia Referentes a Data Inicial de Geracao do  CalendaЁ
		Ё rio														  Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		lNewCalend := ( dDataIni <> dPerIni )	
	Else
		dPerIni := dDataIni
		dPerFim := dDataFim
	EndIF
   
	/*/
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Para Periodos Anteriores Criar novo Calendario apenas QuandoЁ
	Ё nao Existir Troca de Turno para o Inicio do Periodo         Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	IF ( ( lChkMat ) .and. ( lForceNew ) )
		IF !( lNewCalend ) 
			IF ( dDataFim < dPerIni )
				/*/
				зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				Ё Remonta o Calendario Apenas se Nao Existir Troca de Turno paЁ
				Ё ra o Primeiro dia da Montagem do Calendario                 Ё
				юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
				fTrocaTno( Min( dPerIni , dDataIni ) , Max( dPerFim , dDataFim ) , @aTurnos , NIL , NIL , .F. )
				IF ( lNewCalend := ( ( nPosTrcT := aScan( aTurnos , { |x| x[2] == dDataIni } ) ) == 0 ) )
					/*/
					зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
					Ё Para Periodos Anteriores Criar novo Calendario apenas QuandoЁ
					Ё nao Existir Troca de Turno para o Inicio do Periodo         Ё
					юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
					IF ( Len( aTurnos ) > 0 )
						dPerIni	:= aTurnos[ 01 , 02 ]
						dPerFim := ( dPerIni + ( ( dDataFim - dDataIni ) + 1 ) )
						cTno	:= aTurnos[ 01 , 01 ]
						cSeq	:= aTurnos[ 01 , 03 ]
					EndIF
				Else
					/*/
					зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
					Ё Se Tiver Troca de Turno, os Turnos e Sequencias Serao  RetorЁ
					Ё nados pelo Proprio Calendario                               Ё
					юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
					dPerIni := dDataIni
					dPerFim := dDataFim
					cTno	:= aTurnos[ nPosTrcT , 01 ]
					cSeq	:= aTurnos[ nPosTrcT , 03 ]
				EndIF
			EndIF	
		Else
			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Remonta o Calendario Apenas se Nao Existir Troca de Turno paЁ
			Ё ra o Primeiro dia da Montagem do Calendario                 Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			fTrocaTno( Min( dPerIni , dDataIni ) , Max( dPerFim , dDataFim ) , @aTurnos , NIL , NIL , .F. )
			IF !( lNewCalend := ( ( nPosTrcT := aScan( aTurnos , { |x| x[2] == dDataIni } ) ) == 0 ) )
				dPerIni	:= dDataIni
				dPerFim	:= dDataFim
				cTno	:= aTurnos[ nPosTrcT , 01 ]
				cSeq	:= aTurnos[ nPosTrcT , 03 ]
			EndIF
		EndIF
	EndIF

	/*/
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Verifica a Data para a Montagem do 1o Calendario			  Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	IF ( lNewCalend )
		IF ( dDataIni > dPerFim )
			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Inicio do Periodo Solicitado Posterior ao Periodo em Aberto Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			IF ( aScan( aTurnos , { |x| x[2] > dPerFim .and. x[2] <= dDataFim } ) > 0 )
				/*/
				зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				Ё Se Houver Troca de Turno, considera a Menor e a Maior   DataЁ
				Ё para a Montagem do Calendario para que sejam Consideradas asЁ
				Ё Trocas de Turno											  Ё
				юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
				dIniCalend	:= Min( dPerIni , dDataIni )
				dFimCalend	:= Max( dPerFim , dDataFim )
			Else
				/*/
				зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				Ё Caso Contrario o Turno e a Sequencia serao retornados   pelaЁ
				Ё fQualSeq()												  Ё
				юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
				dIniCalend	:= dPerIni
				dFimCalend	:= dPerFim
			EndIF
		ElseIF ( dDataFim < dPerIni )
			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Final do Periodo Solicitado Anterior ao Periodo em Aberto   Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			dIniCalend	:= dPerIni
			dFimCalend	:= dPerFim
		ElseIF ( dDataIni <> dPerIni )
			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Periodo Solicitado Diferente do Periodo em Aberto			  Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			dIniCalend	:= Min( dPerIni , dDataIni )
			dFimCalend	:= Max( dPerFim , dDataFim )
			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Se Nao Tiver Troca de Turno no Inicio do Periodo para a GeraЁ
			Ё cao do Primeiro Calendario, Verifica o Periodo Anterior	  Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			IF ( aScan( aTurnos , { |x| x[2] == dIniCalend } ) == 0 )
				
				/*/
				зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				Ё Localiza o periodo o qual a data inicial compreende		  Ё
				юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
				oPeriodo:dDataIni := dPerIni   
			
			   	/*/
				зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				Ё Cria o Calendario do Periodo Anterior                       Ё
				юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
				dPerAuxIni := oPeriodo:dDataIni
				dPerAuxFim := oPeriodo:dDataFim 

				IF !( lCriaCalOk := PerAponta( @dPerAuxIni , @dPerAuxFim , ( dPerIni - 1 ) , .F. , cFil , .T. , NIL , .F. , .T. ) )
					Break
				EndIF
		
				/*/
				зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				Ё Carrega as Trocas de Turno a Partir do Inicio do Periodo  AnЁ
				Ё Terior													  Ё
				юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
				fTrocaTno( dPerAuxIni , dFimCalend , @aTurnos , NIL , NIL , .F. )
				/*/
				зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				Ё Busca a Primeira Troca inferior ao Periodo para a Geracao doЁ
				Ё Calendario          										  Ё
				юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
				IF ( ( nPosTrcT := aScan( aTurnos , { |x| x[2] <= dIniCalend } ) ) > 0 )
					/*/
					зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
					Ё Busca a Troca mais Proxima                                  Ё
					юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
					nLoops := ( nPosTrcT + 1 )
					While ( ( nLoops := aScan( aTurnos , { |x| x[2] <= dIniCalend } , nLoops ) ) > 0 )
						nPosTrcT := nLoops
						++nLoops
					End While
					/*/
					зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
					Ё Adiciona a Troca de Turno para o Inicio do Periodo para a GeЁ
					Ё racao do Calendario										  Ё
					юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
					IF ( nPosTrcT > 0 )
						aAdd( aTurnos , aClone( aTurnos[ nPosTrcT ] ) )
						aTurnos[ Len( aTurnos ) , 02 ] := dIniCalend
						/*/
						зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
						Ё Ordena as Trocas por Ordem de Data						  Ё
						юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
						aSort( @aTurnos , NIL , NIL , { |x,y| ( x[2] < y[2] ) } )
					EndIF
				EndIF
			EndIF
		EndIF
	Else
		/*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Neste Caso o Periodo Solicitado eh Equivalente ao Periodo emЁ
		Ё Aberto													  Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		dIniCalend	:= dPerIni
		dFimCalend	:= dPerFim
	EndIF     	
    
	/*/
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Verifica Se Calendario e do Periodo Anterior			  	  Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
    lAcumulado := ( dFimCalend < dPerIni )
	
	/*/
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Cria o Calendario do Periodo Atual       				  	  Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	IF !( lCriaCalOk := CalendCria(	dIniCalend								,; //01 -> Data Inicial do Periodo
		 		  					dFimCalend								,; //02 -> Data Final do Periodo
				  					cTno									,; //03 -> Turno Para a Montagem do Calendario
				  					cSeq									,; //04 -> Sequencia Inicial para a Montagem Calendario
					  				@aTabPadrao								,; //05 -> Array Tabela de Horario Padrao
					  				@aTabCalend								,; //06 -> Array com o Calendario de Marcacoes
					  				cFil									,; //07 -> Filial para a Montagem da Tabela de Horario
					  				cMat									,; //08 -> Matricula para a Montagem da Tabela de Horario
					  				cCc										,; //09 -> Centro de Custo para a Montagem da Tabela
				  					@aTurnos								,; //10 -> Array com as Trocas de Turno
				  					@aExcePer								,; //11 -> Array com Todas as Excecoes do Periodo
				  					lExecQryTop 							,; //12 -> Se executa Query para a Montagem da Tabela Padrao
				  					( ( lSncMaMe ) .and. !( lNewCalend ) )	,; //13 -> Se executa a funcao se sincronismo do calendario
				  					lAcumulado								,; //14 -> Se o Calendario eh do periodo anterior
				  					aMarcacoes								,; //15 -> Array de Marcacoes para tratamento de Turnos Opcionais
									lTabCalen								 ; //16 -> Nao zerar o array aTabCalend - Calendario Complementar
					  			);
		 )				  			
		Break
	EndIF

	/*/
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Se nao for Criar novo Calendario, Abandona				  Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	IF !( lNewCalend )
		Break
	EndIF

	/*/
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Obtem o Turno para o Novo Calendario       			  	  Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	cTno	:= GetInfoPosTab(	CALEND_POS_TURNO	,;	//01 -> Posicao em aTabCalend para Obtencao da Informacao
								"1E"				,;	//02 -> Flag da Marcacao "1E,1S,..."
								dDataIni			,;	//03 -> Data em aTabCalend
								aTabCalend			 ;	//04 -> Calendario de Marcacoes
				   		 	)
	IF Empty( cTno )
		IF ( dDataFim < dPerIni )
			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Pode Ocorrer Turno em Branco para Periodo Anterior		  Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			cTno := GetInfoPosTab(	CALEND_POS_TURNO	,;	//01 -> Posicao em aTabCalend para Obtencao da Informacao
									"1E"				,;	//02 -> Flag da Marcacao "1E,1S,..."
									dIniCalend			,;	//03 -> Data em aTabCalend
									aTabCalend			 ;	//04 -> Calendario de Marcacoes
					   		 	 )
		Else
			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Ou Quando a Existe Jornada Continua e a Data Inicial nao corЁ
			Ё responte ao Inicio da Jornada								  Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			aTipo	:= { "1E" , "1S" , "2E" , "2S" , "3E" , "3S" , "4E" , "4S" }
			nLoops	:= Len( aTipo )
			For nLoop := 2 To nLoops
				cTno := GetInfoPosTab(	CALEND_POS_TURNO	,;	//01 -> Posicao em aTabCalend para Obtencao da Informacao
										aTipo[ nLoop ]		,;	//02 -> Flag da Marcacao "1E,1S,..."
										dDataIni			,;	//03 -> Data em aTabCalend
										aTabCalend			 ;	//04 -> Calendario de Marcacoes
					 	 			  )
				IF !Empty( cTno )
					Exit
				EndIF
			Next nLoop
			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Se ainda assim nao achou o turno, procura a Partir do  PerioЁ
			Ё do Final do Periodo em Aberto                               Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			IF Empty( cTno )
				dPerIni := ( dPerFim - 1 )
				While ( Empty( cTno ) .and. ( ( ++dPerIni ) < dDataFim ) )
					For nLoop := 1 To nLoops
						cTno := GetInfoPosTab(	CALEND_POS_TURNO	,;	//01 -> Posicao em aTabCalend para Obtencao da Informacao
												aTipo[ nLoop ]		,;	//02 -> Flag da Marcacao "1E,1S,..."
												dPerIni				,;	//03 -> Data em aTabCalend
												aTabCalend			 ;	//04 -> Calendario de Marcacoes
							 	 			  )
						IF !Empty( cTno )
							Exit
						EndIF
					Next nLoop
				End While
			EndIF
		EndIF
	EndIF					   		 	

	/*/
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Obtem a Sequencia para o Novo Calendario       			  Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	cSeq	:= GetInfoPosTab(	CALEND_POS_SEQ_TURNO	,;	//01 -> Posicao em aTabCalend para Obtencao da Informacao
								"1E"					,;	//02 -> Flag da Marcacao "1E,1S,..."
								dDataIni				,;	//03 -> Data em aTabCalend
								aTabCalend				 ;	//04 -> Calendario de Marcacoes
				   		 	)

	/*/
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Retorna a Sequencia do Proximo Periodo 					  Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	bQualSeq	:= { || IF( Empty( cSeq ) , fQualSeq( aClone( aTabCalend ) , @aTabPadrao , dDataIni , cTno ) , cSeq ) }

	/*/
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Cria o Calendario do Periodo Selecionado					  Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	IF !( lCriaCalOk := CalendCria(	dDataIni			,; //01 -> Data Inicial do Periodo
		 		  					dDataFim			,; //02 -> Data Final do Periodo
					  				cTno				,; //03 -> Turno Para a Montagem do Calendario
					  				Eval( bQualSeq )	,; //04 -> Sequencia Inicial para a Montagem Calendario
					  				@aTabPadrao			,; //05 -> Array Tabela de Horario Padrao
					  				@aTabCalend			,; //06 -> Array com o Calendario de Marcacoes
					  				cFil				,; //07 -> Filial para a Montagem da Tabela de Horario
				  					cMat				,; //08 -> Matricula para a Montagem da Tabela de Horario
				  					cCc					,; //09 -> Centro de Custo para a Montagem da Tabela
				  					@aTurnos			,; //10 -> Array com as Trocas de Turno
					  				@aExcePer			,; //11 -> Array com Todas as Excecoes do Periodo
					  				lExecQryTop 		,; //12 -> Se executa Query para a Montagem da Tabela Padrao
					  				lSncMaMe			,; //13 -> Se executa a funcao se sincronismo do calendario
					  				,;
					  				,;
									lTabCalen	;  //16 -> Nao zerar o array aTabCalend - Calendario Complementar
					  			);
		 )				  			
		Break
	EndIF			  			
	
End Sequence

Return( lCriaCalOk )



/*/
зддддддддддбддддддддддддддддбдддддбдддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁRstCriaCalend	ЁAutorЁMarinaldo de Jesus Ё Data Ё11/03/2003Ё
цддддддддддеддддддддддддддддадддддадддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁReinicializa as Staticas utilizadas em CriaCalend()        	Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGenerico													Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function RstCriaCalend()

__dPerCalIni	:= NIL
__dPerCalFim	:= NIL  
__aProcesso		:= NIL 
__cProcesso		:= NIL
__nPosProcesso	:= NIL
__lPGenerico	:= NIL
__nOrdIni       := NIL

Return( NIL )

/*/
зддддддддддбддддддддддддддбдддддддбдддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁRetExcID 	  Ё Autor Ё Igor Franzoi	  Ё Data Ё26/11/2007Ё
цддддддддддеддддддддддддддадддддддадддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁRetorna os campos da excecao conforme o ID passado			Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё< Vide Parametros Formais >								    Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ< Vide Parametros Formais >									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       Ё Generico                                                   Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function RetExcId( cFil, cIdExce, dData, cRegra, aAllExc, aExcecoes )

Local lRet
Local nPos
Local cKey  := cFil+cIdExce

Local nRecno
Local cAlias := "SP2"
Local nOrder := RetOrdem( "SP2" , "P2_FILIAL+P2_ID" )

Local aArea := GetArea()

DEFAULT dData 	  := Ctod("//")
DEFAULT aExcecoes := {}

/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Verifica se a excecao ja se encontra no array				  Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
If ( ( nPos := aScan( aAllExc, { |X| X[57] == cIdExce  } ) ) != 0 )
	fAddExce( @aExcecoes , .T. , @aAllExc , nPos , dData , cRegra , nRecno )
	lRet := .T.
Else
	dbSelectArea(cAlias)
	dbSetOrder(nOrder)
	(cAlias)->( dbSeek(cKey) )
	If Found()
		nRecno := (cAlias)->( Recno() )
		fAddExce( @aExcecoes , .F. , @aAllExc , nPos , dData , cRegra , nRecno )
		lRet := .T.
	Else
		lRet := .F.	
	EndIf
EndIf

RestArea( aArea )

Return lRet

/*/
зддддддддддбддддддддддбддддддддддбддддддддддддддддддддддбддддбдддддддддд©
ЁFun┤└o    ЁCalendCriaЁAutores   Ё                      Ё    Ё          Ё
Ё          Ё          ЁVersao I  ЁEquipe Advanced RH    ЁDataЁ24/11/1997Ё
Ё          Ё          ЁVersao II ЁMarinaldo de Jesus    ЁDataЁ18/09/2003Ё
Ё          Ё          ЁVersao IIIЁIgor Franzoi			ЁDataЁ23/11/2007Ё
цддддддддддеддддддддддаддддддддддаддддддддддддддддддддддаддддадддддддддд╢
ЁDescri┤└o ЁAlimenta um Array com o Calend═rio de um Per║odo.           Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё< Vide Parametros Formais >								    Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ< Vide Parametros Formais >									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGenerico                                                    Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function CalendCria(	dDataIni	,; //01 -> Data Inicial do Periodo
		 				dDataFim	,; //02 -> Data Final do Periodo
						cTno		,; //03 -> Turno Para a Montagem do Calendario
						cSeq		,; //04 -> Sequencia Inicial para a Montagem Calendario
						aTabPadrao	,; //05 -> Array Tabela de Horario Padrao
						aTabCalend	,; //06 -> Array com o Calendario de Marcacoes
						cFil		,; //07 -> Filial para a Montagem da Tabela de Horario
						cMat		,; //08 -> Matricula para a Montagem da Tabela de Horario
						cCc			,; //09 -> Centro de Custo para a Montagem da Tabela
						aTurnos		,; //10 -> Array com as Trocas de Turno
						aExcePer	,; //11 -> Array com Todas as Excecoes do Periodo
						lExecQryTop ,; //12 -> Se executa Query para a Montagem da Tabela Padrao
						lSncMaMe	,; //13 -> Se executa a funcao se sincronismo do calendario
						lAcumulado	,; //14 -> Se o Calendario eh do Periodo anterior 
						aMarcacoes  ,; //15 -> Array de marcacoes para tratamento de Turnos Opcionais
						lTabCalen	;  //16 -> Nao zerar o array aTabCalend - Calendario Complementar						
					)

/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Variaveis de Inicializacao Obrigatoria					  Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Local aMarcId	 		:= { NIL , NIL }
Local aTipo				:= { "1E" , "1S" , "2E" , "2S" , "3E" , "3S" , "4E" , "4S" }
Local aDataApo			:= {}
Local cOrdem			:= ""
Local dDataApo			:= Ctod("")
Local lCriaCalOk		:= .T.
Local lForceSinc		:= .F.
Local lExistTrcTno 		:= .F.
Local lBldNewOrd		:= .F. 
Local lPerAcum			:= .F.
Local nDias				:= 0 
Local nSeq				:= 0
Local nFornY			:= Len( aTipo )
Local nOrdem			:= 0                                          

/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Variaveis que serao inicializadas para Turnos Opcionais	  Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/     
Local aDiaTurnoOK
/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Variaveis que serao inicializadas no Corpo da Funcao		  Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/     
Local aSr6Info
Local aSr6Cpo
Local aSpaInfo
Local aExcecoes
Local aTabTno
Local aTabOrig
Local aAfasta   
Local aTransf

Local bAsc

Local cReg
Local cCcCal
Local cDepto
Local cPosto
Local cFilSP3
Local cFilSRA
Local cFilSPJ
Local cFilSR6
Local cFilSPA
Local cIdAfas
Local cIdExce
Local cTpExce
Local cTnoOpc
Local cPagInt
Local cKeyAtu
Local cNewTno
Local cNewReg
Local cCodPer	:= ""
Local cCodRot	:= ""
Local cCodPro	:= ""
Local cNumPag	:= ""
Local cCodJor
Local cRegOrig
Local cTipoDia
Local cTipAfas 
Local cFuncCal
Local cJndCont
Local cTpExNorFer
Local cTpExNotFer

Local dData
Local dIniAfas
Local dFimAfas

Local lExce
Local lExceData
Local lJndC
Local lFeriado
Local lIncrementa	:= .F.  //Incremento do dia de apontamento para jornada continua
Local lChkMat
Local lChkCc
Local lAfastper
Local lAfast
Local lAponFer
Local lTrbFeriado 
Local lHeAutoFer
Local lTrocaTno  
Local lTnoOpcData
Local lTnoSubstituto
Local lAllTnoOpc
Local lBldCalTnoSeq
Local lNewTno
Local lNewReg

Local nX
Local nY  
Local nPos
Local nPos1
Local nPos2
Local nTno
Local nFornX
Local nLenCalend
Local nPosDataApo
Local nSerial
Local nIniHnot
Local nFimHnot
Local nMinHNot	 
Local nHrTrab
Local nHrInte
Local nLimInfE 
Local nLimSupE 
Local nLimInfS
Local nLimSupS  
Local nLenRecria := 0

Local lError	:= ( Type("oCalendError") <> "U" )

DEFAULT cTno			:= IF( Type( "SRA->RA_TNOTRAB" ) != "U" , SRA->RA_TNOTRAB	,  "" )
DEFAULT cSeq			:= IF( Type( "SRA->RA_SEQTURN" ) != "U" , SRA->RA_SEQTURN	,  "" )
DEFAULT aTabPadrao		:= {}
DEFAULT cFil			:= IF( Type( "SRA->RA_FILIAL" ) != "U" , SRA->RA_FILIAL		,  "" )
DEFAULT lSncMaMe		:= .F.
DEFAULT lAcumulado		:= .F. 
DEFAULT aMarcacoes		:= {}
DEFAULT lTabCalen		:= .T.

/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Obtem as Informacoes em Cache do Turno de Trabalho          Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
aSr6Cpo := {;
		"R6_INIHNOT"	,;	//01
		"R6_FIMHNOT"	,;	//02
		"R6_MINHNOT"	,;	//03
		"R6_APODFER"	,;	//04
		"R6_TPEXFER"	,;	//05
		"R6_TPEXFEN"	,;	//06
		"R6_AUTOHEF"	,;	//07
		"R6_TNOOPC"  	;	//08
}

aLogErr030 	:= If ( Type("aLogErr030") == "U" , aLogErr030 := {}, aLogErr030 )

/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Obtem a Filial Para a Pesquisa das Excecoes                 Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
cFilSRA := cFil

/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Obtem a Filial Para a Pesquisa dos Feriados                 Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
cFilSP3	:= xFilial( "SP3" , cFil )

/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Obtem a Filial Para a Montagem do Calendario                Ё
Ё Case o parametro lUseSPJ = .T. utiliza filial do SPJ, senao Ё
Ё utiliza a tabela de horario RF2							  Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
If ( lUseSPJ )
	cFilSPJ := xFilial( "SPJ" , cFil )
Else
	cFilSpj := xFilial( "RF2" , cFil )
EndIf
/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Obtem a Filial do SR6                                       Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
cFilSR6 := xFilial( "SR6" , cFil )

/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Obtem a Filial do SPA                                       Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
cFilSPA	:= xFilial( "SPA" , cFil )

/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Verifica se Passou Centro de Custo e Matricula              Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
lChkMat := !( cMat == NIL )
lChkCc	:= !( cCc  == NIL )

/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Se passou a Matricula Carrega as Trocas de Tuno do Periodo  Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
IF ( lChkMat )
	IF Empty( aTurnos )
		/*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Carrega as Trocas de Turno/Regra do Periodo				  Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		DEFAULT aTurnos := {}
		//Se for para desconsiderar o limite superior, verifica se existe troca de turno do dia posterior ao ultimo do periodo para montagem do limite superior do ultimo dia
		If lMVLimSup
			lTrocaTno := fTrocaTno( dDataIni , dDataFim , @aTurnos , NIL , cSeq )
		Else
			lTrocaTno := fTrocaTno( dDataIni , dDataFim+1 , @aTurnos , NIL , cSeq )
		EndIf
	Else
		lTrocaTno := .T.
	EndIF
	//Verifica se for MENOR ou igual, nЦo existindo assume SRA
	IF ( ( nPos := aScan( aTurnos , { |x| x[2] == dDataIni } ) ) > 0 )
		cTno 	:= aTurnos[ nPos , 01 ]
		cSeq	:= aTurnos[ nPos , 03 ]
		cReg 	:= aTurnos[ nPos , 05 ]
	Else
		aSort( @aTurnos , NIL , NIL , { |x,y| ( x[2] > y[2] ) } )
		If ( ( nPos := aScan( aTurnos , { |x| x[2] < dDataIni } ) ) > 0 )
			cTno 	:= aTurnos[ nPos , 01 ]
			cSeq	:= aTurnos[ nPos , 03 ]
			cReg 	:= aTurnos[ nPos , 05 ]
		Else
			cReg	:= SRA->RA_REGRA
		EndIf
		aSort( @aTurnos , NIL , NIL , { |x,y| ( x[2] < y[2] ) } )
	EndIF	
Else
	cReg	:= IF( Type( "SRA->RA_REGRA" ) != "U" , SRA->RA_REGRA , cReg )
EndIF

/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Salva Turno, Sequencia e Regra Iniciais                     Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
cNewTno	:= cTno
cNewReg	:= cReg

/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Verifica qual a sequencia correta para o Periodo enviado    Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
fFindSeq( 	@cSeq			,; 
			@aTabPadrao		,; 
			@cFilSPJ		,; 
			cNewTno			,; 
			lExecQryTop		,; 
			aTurnos			,; 
			SRA->RA_ADMISSA	,; 
			dDataIni		,; 
			dDataFim		,;
			cMat	 )

/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Obtem a Sequencia Inicial do Turno                          Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
nSeq := Val( cSeq )

#IFDEF TOP
	IF !( lExInAs400 )
		aExcePer := {}
		IF ( lExce := ( lChkCc .and. lChkMat ) )
			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Carrega Todas as Excecoes do Periodo Quando o RDD for TOP   Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			lExce := GetExceTop( cFilSRA , cMat , cCc , aTurnos , dDataIni , dDataFim , @aExcePer )
		EndIF
	Else
		/*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Neste Caso o Array aExcePer foi Passado como Parametro      Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		IF ( lExce := ( lChkCc .and. lChkMat ) )
			lExce := !( ( ValType( aExcePer ) == "A" ) .and. Empty( aExceper ) )
		EndIF
	EndIF
#ELSE
	/*/
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Neste Caso o Array aExcePer foi Passado como Parametro      Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	IF ( lExce := ( lChkCc .and. lChkMat ) )
		lExce := !( ( ValType( aExcePer ) == "A" ) .and. Empty( aExceper ) )
	EndIF	
#ENDIF

/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Carrega os Afastamentos Referente ao Periodo                Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
IF ( lAfastper := ( lChkMat ) )
	lAfastper := fAfastaPer( @aAfasta , dDataIni , dDataFim , cFilSRA , cMat )
EndIF	

Begin Sequence

	/*/
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Monta a Chave Atual                                         Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	DEFAULT cNewReg := "__cNewReg__" 
	cKeyAtu := ( FWCODEMP("RCH") + cFilAnt + Dtos( dDataIni ) + Dtos( dDataFim ) + cNewTno + cSeq + cNewReg + AllToChar( lSncMaMe ) )
	/*/
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Verifica se Houve alteracao ou se o Calendario para o  TurnoЁ
	Ё esta vazio e Recria										  Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	
	IF ( lBldCalTnoSeq := ( !( cKeyAtu == __cKeyBldCal ) .or. Empty( __aLstTabCal ) ) )
		If lTabCalen
			aTabCalend		:= {}	
			aTabTno			:= {}
			__aLstTabCal	:= {}
			__aLstTabTno	:= {}
			__cKeyBldCal	:= cKeyAtu
		EndIf
		/*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Monta o Calendario de Marcacoes padrao para o   Turno/SequenЁ
		Ё cia Corrente												  Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		IF !( lCriaCalOk := BldCalTnoSeq(	dDataIni		,;	//01 -> Data Inicial do Periodo
											dDataFim		,;	//02 -> Data Final do Periodo
											aTipo			,;	//03 -> Tipos de Marcacoes Possiveis
											cNewTno			,;	//04 -> Turno Para a Montagem do Calendario
											cSeq			,;	//05 -> Sequencia Inicial para a Montagem Calendario
											cNewReg			,;	//06 -> Regra do Funcionario
											@aTabPadrao		,;	//07 -> Array Tabela de Horario Padrao
											@aTabCalend		,;	//08 -> Array com o Calendario de Marcacoes
											@aTabTno		,;	//09 -> Tabela do Turno Corrente
											cFil			,;	//10 -> Filial para a Montagem da Tabela de Horario
											lExecQryTop 	,;	//11 -> Se executa Query para a Montagem da Tabela Padrao
											lSncMaMe		,;	//12 -> Se executa a funcao se sincronismo do calendario 
											lTabCalen		 ;  //13 -> Nao zerar o array aTabCalend - Calendario Complementar	
										);
			)							 	
			Break
		EndIF
		__aLstTabCal	:= aClone( aTabCalend )
		__aLstTabTno	:= aClone( aTabTno )
	EndIF

	/*/
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Inicializa o Array aTabCalend ( Calendario das Marcacoes )  Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	aTabCalend := aClone( __aLstTabCal )

	/*/
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Carrega Informacoes Especificas do Funcionario              Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	IF ( lChkMat )
	
		/*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		ЁTransfere informacoes necessarias para gravacao do calendarioЁ
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/   
		aTransf := {}

		/*
		здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Carregar as Transferencias do Funcionario				       Ё
		юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды*/		    
		fLoadTransf(aTransf)
	
		fFilIdTabela( aTabCalend,, aTransf )
									 
		/*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Carrega a Tabela do Turno Corrente				  		  Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		aTabTno := aClone( __aLstTabTno )    
		
		/*
		здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Obtem todos os Turnos Opcionais			                   Ё
		юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/    
		lAllTnoOpc := .F.
		If __lChkTnoOpc
			If lTrocaTno                     
				For nTno:= 1 To Len(aTurnos)               
					//-- Carrega todos os horarios opcionais do turno
			    	If LoadTnoOpc(cFilSPJ, aTurnos[nTno, 1],__aAllTnoOpc, @aTabPadrao, aSr6Cpo, aSr6Info )
			    	   lAllTnoOpc := .T.
			    	Endif   
			    Next
			Else
				//-- Carrega todos os horarios opcionais do turno
			    If LoadTnoOpc(cFilSPJ, cNewTno,__aAllTnoOpc, @aTabPadrao, aSr6Cpo, aSr6Info )
		    	   lAllTnoOpc := .T.
		    	Endif   
			Endif  
        Endif
        
		/*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Carrega as Marcacoes do Funcionario para Ajustar os Turnos  Ё
		Ё em funcao da existencia de turnos opcionais				  Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/	        
		If lAllTnoOpc 
			If Empty(aMarcacoes) 
				GetMarcOpc(	@aMarcacoes						,;	//01 -> Marcacoes dos Funcionarios
							dDataIni - 7					,;	//02 -> Periodo Inicial
							dDataFim + 7					,;	//03 -> Periodo Final
							cFil							,;	//04 -> Filial
							cMat							,;	//05 -> Matricula
							cTno							,;	//06 -> Turno
							cSeq							,;	//07 -> Sequencia de Turno
							cCc								,;	//08 -> Centro de Custo 
							If(lAcumulado, "SPG", "SP8")     ; //09 -> Obtem as marcacoes do Alias conforme o periodo considerado.
						  )         
			Endif  		  
	    Endif    

	    /*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Loop For/Next para a Carga das Marcacoes do Periodo         Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		aDiaTurnoOk:= {}
		nFornX := ( dDataFim - dDataIni )

		//Caso ja exista dias do periodo gravados no calendario, inicia ordem a partir do ultimo registro existente.
		If !( __nOrdIni == NIL )
			nOrdem := __nOrdIni
		EndIf
		
		For nX := 0 To nFornX
		
			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Data a ser verificada										  Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			dData := ( dDataIni + nX )
			
			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Salva a Data de Apontamento								  Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/  
			dDataApo	:= dData
		
			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё A Sequencia eh incrementada a Cada Segunda Feira			  Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			IF ( ( nX != 0 ) .and. ( Dow( dData ) == 2 ) )
				nSeq++
			EndIF 
			
			IF ( lIncrementa ) 
				/*/
				зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				Ё Verifica se a Sequ┬ncia atual est═ cadastrada na Tabela. PesЁ
				Ё quisa a Sequencia Primeiro com o StrZero( n , 1 ) "0" e   DeЁ
				Ё pois com StrZero( n , 2 ) "00"						      Ё
				юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
				bAsc := { |x| AllTrim( x[19] ) == StrZero( nSeq , IF( nSeq < 10 , 1 , 2 ) ) .or. AllTrim( x[19] ) == StrZero( nSeq , 2 ) }
				nSeq := IF( aScan( aTabTno , bAsc ) == 0 , 1 , nSeq )

				/*/
				зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				Ё Para Jornada Continua corre todas as datas para que seja    Ё
				Ё verificada se alguma segunda-feira ocorre durante a jornada Ё
				Ё e, assim, incrementarmos a sequencia.						  Ё
				юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			    If nDias > 0
			      --nDias 
			      Loop
			    Endif   
			    lIncrementa := .F.
			EndIF 
			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Ordem da Marcacao     									  Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			nOrdem++
			cOrdem		:= StrZero( nOrdem , Max( __nTamP8Ordem , Len( AllTrim( Str( nOrdem ) ) ) ) )

			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Procura a Data de Apontamento no Calendario Generico					  Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			IF (; 
					(;
						nPosDataApo := aScan( __aLstTabCal , { |x|;
																( x[ CALEND_POS_DATA_APO ] == dDataApo ) ;
														    };
							     		  );
					) == 0 ;
				)
				Loop
			EndIF													     		  

			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Se houver Sincronismo, adiciona a Data de Apontamento  	  Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			IF ( lSncMaMe )
				aAdd( aDataApo, dDataApo)
			EndIF	

			//-- Prepara tabela de verificacao de turnos
			If lAllTnoOpc
				AADD(aDiaTurnoOK, {dData, SPACE(1) })
			Endif

			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Pesquisa as Trocas de Turno/Sequencia/Regra Durante o  PerioЁ
			Ё do														  Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			IF (;
					( lTrocaTno );
					.and.;                                       
					( dDataIni != dData );
					.and.;
					( ( nPos := aScan( aTurnos , { |x| x[2] == dData } ) ) > 0 );
				)	
				lExistTrcTno	:= .T.
				cNewTno 		:= aTurnos[ nPos , 01 ]
				cSeq	 		:= aTurnos[ nPos , 03 ]
				cNewReg 		:= aTurnos[ nPos , 05 ]
				nSeq			:= Val( cSeq )
				/*/
				зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				Ё Carrega a Tabela Para o Novo Turno de Acordo com as Trocas  Ё
				юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
				fTabPadrao( @aTabPadrao , @cFilSPJ , cNewTno , lExecQryTop )
				/*/
				зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				Ё Pesquisa e Carrega a Tabela do Turno Corrente				  Ё
				юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
				IF ( lCriaCalOk := ( nPos := aScan( aTabPadrao, { |x| x[2] == cNewTno .and. ( x[1] == cFilSPJ .or. Empty( x[1] ) ) } ) ) > 0 )
					aTabTno := aClone( aTabPadrao[ nPos , 3 ] )
				Else
					Break
				EndIF
			EndIF
	
			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Verifica se a Sequ┬ncia atual est═ cadastrada na Tabela. PesЁ
			Ё quisa a Sequencia Primeiro com o StrZero( n , 1 ) "0" e   DeЁ
			Ё pois com StrZero( n , 2 ) "00"						      Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			bAsc := { |x| AllTrim( x[19] ) == StrZero( nSeq , IF( nSeq < 10 , 1 , 2 ) ) .or. AllTrim( x[19] ) == StrZero( nSeq , 2 ) }
			nSeq := IF( aScan( aTabTno , bAsc ) == 0 , 1 , nSeq )
	
			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			ЁVerifica se o Dia da Semana da Sequencia e equivalente ao DiaЁ
			Ёda Data a Ser Pesquisada. Pesquisa a Sequencia  Primeiro  comЁ
			Ёo StrZero( n , 1 ) "0" e Depois com o StrZero( n , 2 ) "00"  Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			bAsc := { |x| (	AllTrim( x[19] ) == StrZero( nSeq , IF( nSeq < 10 , 1 , 2 ) ) .or. AllTrim( x[19] ) == StrZero( nSeq , 2 ) ) ;
						  .and. x[20] == Dow(dData);
					 }
			IF !( lCriaCalOk := ( nPos := aScan( aTabTno , bAsc ) ) > 0 )
				If lError
					oCalendError:SendError('01',Dtoc(dData), .T.)		//Nao foi encontrado sequencia para a data XX/XX/XX
				Endif 				
				Break
			EndIF

			/*/                                                             
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Verifica se na Data Houve Excecao e Substitui os Horarios daЁ
			Ё Tabela      												  Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			lExceData := .F.
			IF ( lExce .and. lChkCc )

				aExcecoes := {}
				cTipoDia  := aTabTno[nPos,18]
				IF ( lExce .and.;
					 GetExcecoes( @aExcecoes , cNewTno , cCC , cFilSRA , cMat , dData , @cTipoDia , aExcePer );
				   )
					/*/
					зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
					Ё Salva a Tabela Padrao/Regra da Semana Que Serao  ModificadosЁ
					Ё em Funcao de Excecoes										  Ё
					юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
					aTabOrig  := aClone( aTabTno )
					cRegOrig  := cNewReg
					/*/
					зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
					Ё Se Houver Excecoes na Data Substitui os Horarios/Regra pelosЁ
					Ё da Excecao  												  Ё
					юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
					IF (;
							lExceData := (;
											!Empty( aExcecoes ) .and. ;
											(;
												Empty( aExcecoes[ 01 , 33 ] ) .or.;
												( aExcecoes[ 01 , 33 ] == cTipoDia );
											);
										);
						)
						/*/
						зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
						ЁNao carrega excecao caso o calendario fisico				  Ё
						юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
						
						
						IF ( aExcecoes[01,46] <> "S" )					// Assume o Horario das Excecooes
							aTabTno[nPos,01] 	:= aExcecoes[01,05]		// 01 - 1a Entrada
							aTabTno[nPos,02] 	:= aExcecoes[01,06]		// 02 - 1a Saida
							aTabTno[nPos,03] 	:= aExcecoes[01,07]		// 03 - 2a Entrada
							aTabTno[nPos,04] 	:= aExcecoes[01,08]		// 04 - 2a Saida
							aTabTno[nPos,05] 	:= aExcecoes[01,09]		// 05 - 3a Entrada
							aTabTno[nPos,06] 	:= aExcecoes[01,10]		// 06 - 3a Saida
							aTabTno[nPos,07] 	:= aExcecoes[01,11]		// 07 - 4a Entrada
							aTabTno[nPos,08] 	:= aExcecoes[01,12]		// 08 - 4a Saida
							aTabTno[nPos,09] 	:= aExcecoes[01,16]		// 09 - Horas Trabalhadas 1a. Jornada
							aTabTno[nPos,10] 	:= aExcecoes[01,17]		// 10 - Horas Trabalhadas 2a. Jornada
							aTabTno[nPos,11] 	:= aExcecoes[01,18]		// 11 - Horas Trabalhadas 3a. Jornada
							aTabTno[nPos,12] 	:= aExcecoes[01,19]		// 12 - Horas Trabalhadas 4a. Jornada
							aTabTno[nPos,13] 	:= aExcecoes[01,26]		// 13 - Horas de Intervalo 1S
							aTabTno[nPos,14] 	:= aExcecoes[01,27]		// 14 - Horas de Intervalo 2S
							aTabTno[nPos,15] 	:= aExcecoes[01,28]		// 15 - Horas de Intervalo 3S
							aTabTno[nPos,16] 	:= ""					// 16 - Marcacao e do dia seguinte ?
							aTabTno[nPos,17] 	:= aExcecoes[01,20]		// 17 - Numero de Marcacoes
							aTabTno[nPos,29] 	:= aExcecoes[01,34]		// 29 - Aponta Nona Hora
							aTabTno[nPos,30] 	:= aExcecoes[01,35]		// 30 - Limite de Horario Inicial
							aTabTno[nPos,31] 	:= aExcecoes[01,36]		// 31 - Limite de Horario Final
							aTabTno[nPos,32] 	:= aExcecoes[01,37]		// 32 - 1a. Jornada Continua
							aTabTno[nPos,33] 	:= aExcecoes[01,38]		// 33 - 2a. Jornada Continua
							aTabTno[nPos,34]	:= aExcecoes[01,39]		// 34 - 3a. Jornada Continua
							aTabTno[nPos,35]	:= aExcecoes[01,40]		// 35 - 4a. Jornada Continua
							aTabTno[nPos,36]	:= aExcecoes[01,41]		// 36 - Codigo da Refeicao
						EndIF  
															
						aTabTno[nPos,18] 	:= aExcecoes[01,23]		// 18 - Tipo do Dia
						aTabTno[nPos,19] 	:= aTabTno[ nPos, 19 ]	// 19 - Sequencia da Marcacao
						aTabTno[nPos,20] 	:= Dow( dData )      	// 20 - Numero Correspondente ao Dia da Semana
						aTabTno[nPos,21] 	:= "E"					// 21 - Flag Indicador de Excecao
						aTabTno[nPos,22] 	:= aExcecoes[01,21]		// 22 - Motivo da Excecao
						aTabTno[nPos,23] 	:= aExcecoes[01,22]		// 23 - Codigo Hora Extra Normal
						aTabTno[nPos,24] 	:= aExcecoes[01,24]		// 24 - Codigo Hora Extra Noturna
						aTabTno[nPos,25] 	:= aExcecoes[01,29]		// 25 - Centro de Custo Periodo 1 (1a.E-1a.S)
						aTabTno[nPos,26] 	:= aExcecoes[01,30]		// 26 - Centro de Custo Periodo 2 (2a.E-2a.S)
						aTabTno[nPos,27] 	:= aExcecoes[01,31]		// 27 - Centro de Custo Periodo 3 (3a.E-3a.S)
						aTabTno[nPos,28] 	:= aExcecoes[01,32]		// 28 - Centro de Custo Periodo 4 (4a.E-4a.S)						
						aTabTno[nPos,38] 	:= aExcecoes[01,47]		// 29 - Funcao Periodo 1 (1a.E-1a.S)
						aTabTno[nPos,39] 	:= aExcecoes[01,48]		// 26 - Funcao Periodo 2 (2a.E-2a.S)
						aTabTno[nPos,40] 	:= aExcecoes[01,49]		// 27 - Funcao Periodo 3 (3a.E-3a.S)
						aTabTno[nPos,41] 	:= aExcecoes[01,50]		// 28 - Funcao Periodo 4 (4a.E-4a.S)					
						aTabTno[nPos,58] 	:= aExcecoes[01,55]		// 55 - Depto Periodo 1 (1a.E-1a.S)
						aTabTno[nPos,59] 	:= aExcecoes[01,56]		// 56 - Depto Periodo 2 (2a.E-2a.S)
						aTabTno[nPos,60] 	:= aExcecoes[01,57]		// 57 - Depto Periodo 3 (3a.E-3a.S)
						aTabTno[nPos,61] 	:= aExcecoes[01,59]		// 58 - Depto Periodo 4 (4a.E-4a.S)
						aTabTno[nPos,62] 	:= aExcecoes[01,51]		// 51 - Posto Periodo 1 (1a.E-1a.S)
						aTabTno[nPos,63] 	:= aExcecoes[01,52]		// 52 - Posto Periodo 2 (2a.E-2a.S)
						aTabTno[nPos,64] 	:= aExcecoes[01,53]		// 53 - Posto Periodo 3 (3a.E-3a.S)
						aTabTno[nPos,65] 	:= aExcecoes[01,54]		// 54 - Posto Periodo 4 (4a.E-4a.S)
						aTabTno[nPos,71] 	:= aExcecoes[01,59]		// 59 - Id de excecao
						
						cNewReg		  	 	:= aExcecoes[01,42]		// Regra de Apontamento
						nIniHnot	  	 	:= aExcecoes[01,43]		// Inicio da Hora Noturna
						nFimHnot	  	 	:= aExcecoes[01,44]		// Final da Hora Noturna
						nMinHnot	  		:= aExcecoes[01,45]		// Minutos da Hora Noturna							
							
					
						If lUseCalFisico
							/*/
						   здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
						   Ё Carregar apenas o ID/Tipo da excecao caso calendario fisico  Ё
						   юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/			
							cIdExce 	:= aExcecoes[01,59]		// 59 - Id de excecao
							cTpExce		:= aExcecoes[01,60]		// 60 - Tipo de Excecao

						EndIf
						
					EndIF
				EndIF 
			Endif
			      
		   /*/
		   здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		   Ё Checa a Existencia de Turnos diferentes do Padrao:	          Ё
		   Ё Pode ser Turno Alternativo ou Turno Substituto               Ё 
		   юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/    
			lTnoOpcData 	:= .F.
			lTnoSubstituto  := .F.
			If ! lExceData                                                       
				/*/
			   здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			   Ё Checa a Existencia de Turnos Opcionais				          Ё
			   юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			 	If lAllTnoOpc
				   	/*/
					зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
					Ё Salva a Tabela Padrao/Regra da Semana Que Serao  ModificadosЁ
					Ё em Funcao de Excecoes										  Ё
					юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
					aTabOrig  := aClone( aTabTno )
					cRegOrig  := cNewReg
				   ( lTnoOpcData:=GetTnoOpc( cNewTno, dData, @aDiaTurnoOK, aTabPadrao, @aTabTno[nPos], cFilSPJ, @aMarcacoes))
                Else
	                /*/
				   здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				   Ё Checa a Existencia de Turno Substituto	para a data           Ё
				   юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/    
					/*/
					здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
					Ё Ponto de Entrada para edicao do array aTabCalend             Ё
					юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
					IF lPnmTab01 
						IF ( ValType( uRet 	:= ExecBlock("PNMTAB01",.F.,.F., { cFilSRA , cMat , dData, cNewTno, aClone(aTabTno[nPos]) }) ) == "A" )	
							IF (lTnoSubstituto  := !Empty(uRet) )
								/*/
								зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
								Ё Salva a Tabela Padrao/Regra da Semana Que Serao  ModificadosЁ
								Ё em Funcao de Excecoes										  Ё
								юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
								aTabOrig  		:= aClone( aTabTno )
								cRegOrig  		:= cNewReg
	
								 /*/
							    здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
							    Ё Troca a tabela de horario do turno do dia pela do Ponto de Entrada           Ё
							    юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/    
								aTabTno[nPos] 	:= aClone(uRet)
							Endif	
							uRet	   		:= NIL
						EndIF
					EndIF
                Endif
			EndIF

			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Verificar se o Funcionario Esta Afastado na Data			  Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			dIniAfas	:= Ctod("//")
			dFimAfas	:= Ctod("//")
			cTipAfas	:= __aLstTabCal[ nPosDataApo , CALEND_POS_TIP_AFAST ]
			IF ( lAfast := ( lAfastper ) )
				lAfast := fAfasta( cFilSRA , cMat , dData , @dIniAfas , @dFimAfas , @cTipAfas , aAfasta, @cIdAfas )
			EndIF			

			IF !( lBldNewOrd )
				/*/
				зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				Ё Verifica se Teve Alguma Alteracao                		  	  Ё
				юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
				IF ( lBldNewOrd := (;
										( lExistTrcTno )  .or. ;	//Troca de Turno na Data
										( lExceData	   )  .or. ;	//Excecao na Data
										( lTnoOpcData  )  .or. ;	//Turno Opcional
										( lTnoSubstituto) .or. ; 	//Turno substituto
										( lAfast	   )  	   ;	//Afastamento na Data
									 );
					)
					/*/
					зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
					Ё Verifica se Deve Re-Sincronizar o Calendario     		  	  Ё
					юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
					lForceSinc := lBldNewOrd
				
				Else
					Loop
				EndIF
			EndIF        
	
			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Carrega os Valores DEFAULT para o Dia            		  	  Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			lAponFer	:= __aLstTabCal[ nPosDataApo	,	CALEND_POS_APON_FERIAS	]
			cTpExNorFer	:= __aLstTabCal[ nPosDataApo	,	CALEND_POS_TP_HE_NR_FER	]
			cTpExNotFer	:= __aLstTabCal[ nPosDataApo	,	CALEND_POS_TP_HE_NT_FER	]
			cPagInt 	:= __aLstTabCal[ nPosDataApo	,	CALEND_POS_PAGINT		]
			lFeriado 	:= __aLstTabCal[ nPosDataApo	, 	CALEND_POS_FERIADO		]
       		lTrbFeriado	:= __aLstTabCal[ nPosDataApo	,	CALEND_POS_TRAB_FERIADO	] 
       		lHeAutoFer	:= __aLstTabCal[ nPosDataApo	,	CALEND_POS_HE_AUTO_FER	] 
       		

			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Define o Tipo do Dia                                    	  Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			cTipoDia := aTabTno[ nPos , 18 ]

			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Verifica se Teve Alteracao no Turno              		  	  Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			IF( lNewTno	:= ( cNewTno <> cTno ) )
				cTno := cNewTno
			EndIF

			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Verifica se Teve Alteracao na Regra              		  	  Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			IF( lNewReg	:= ( cNewReg <> cReg ) )
				cReg := cNewReg
			EndIF

			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Verifica se a Regra de Apontamento eh Valida                Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			IF !( lCriaCalOk := PosSPA( cNewReg , cFilSPA , NIL , 01 , .F. ) )
				If lError
					oCalendError:SendError('03',cNewReg, .T.)  //"No se encontro la regla "
				EndIf
				Break
			EndIF

			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Obtem as Informacoes em Cache da Regra de Apontamento       Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			aSpaInfo := {;
							"PA_PAGINT"		,;	//01
							"PA_FERIADO"	 ;	//02
						}
			aSpaInfo := PosSPA( cNewReg , cFilSPA , aSpaInfo , 01 , .F. )

			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Verifica Quais Intervalos Sao Pagos             			  Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			cPagInt := aSpaInfo[1]

			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Verifica Se o Dia em Questao eh um Feriado				  Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			lTrbFeriado := .F.
			IF ( lFeriado := __aLstTabCal[ nPosDataApo , CALEND_POS_FERIADO ] )
				lTrbFeriado := ( aSpaInfo[2] == "S" )
       		EndIF

			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё As horas extras para funcionario em ferias sao por padrao	  Ё
			Ё autorizadas.												  Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/			
			lHeAutoFer	:= .T.
			
			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Se nao Existir Excecao na Data Redefine o Tipo do Dia   	  Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			IF !( lExceData )

				/*/
				зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				Ё Verifica se o Turno de Trabalho eh valido                   Ё
				юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
				IF !( lCriaCalOk := PosSR6( cTno , cFilSPJ , NIL , 01 , .F. ) )
					If lError
						oCalendError:SendError('02',cTno, .T.)		//Nao foi encontrado Turno XXX
					Endif									
					Break
				EndIF
				
				aSr6Info := PosSR6( cNewTno , cFilSPJ , aSr6Cpo , 01 , .F. )             
				
				/*/
				зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				Ё Obtem a Hora Noturna de Acordo com o Turno                  Ё
				юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
				nIniHnot := aSr6Info[1]	// Inicio da Hora Noturna
				nFimHnot := aSr6Info[2]	// Final da Hora Noturna
				nMinHnot := aSr6Info[3]	// Minutos da Hora Noturna

				/*/
				зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				Ё Se estiver Afastado Define o Dia como Nao Trabalhado        Ё
				юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
				IF ( lAfast )
					cTipoDia := "N"	//Nao Trabalhado
				EndIF

				/*/
				зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				Ё Verifica se Aponta para Funcionario em Ferias            	  Ё
				юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
				IF ( cTipAfas == "F" )
					IF ( lAponFer := ( aSr6Info[4] == "S" ) )
					
						/*/
						зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
						Ё Se funcionario em Ferias com Direito a Apontamento       	  Ё
						юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
						cTpExNorFer	:= aSr6Info[5]	//Normal Ferias
						cTpExNotFer	:= aSr6Info[6]	//Noturna Ferias      
						
						/*/
						зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
						Ё Verifica se horas extras sao autorizadas para funcionario   Ё
						Ё em ferias.												  Ё
						юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
						lHeAutoFer := If ( aSr6Info[7] == "1" .or. Empty( aSr6Info[7] ), .T. , .F. )	 // 1 ou branco - Autorizadas (Padrao) , 2- Nao Autorizadas
						
					EndIF
				Else
					/*/
					зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
					Ё Se funcionario nao Trabalha em Feriado e dia For Feriado 	  Ё
					юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
					IF (;
					 		( lFeriado );			//Dia eh Feriado	
					 		.and.;
					 		!( lTrbFeriado );		//Funcionario Nao Trabalha em Feriado
					 	)
						cTipoDia := "F" //Feriado
					EndIF
				EndIF
			
			EndIF

			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Garante que os Minutos da Hora Nunca Sera Menor que Zero	  Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			nMinHnot := IF( nMinHnot <= 0 , 60 , nMinHNot )	// Minutos da Hora Noturna

			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Carrega Informacoes do Feriado                          	  Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			cP3TpExt	:= __aLstTabCal[ nPosDataApo	,	CALEND_POS_TP_HE_FER_NR	]
			cP3TpExtN	:= __aLstTabCal[ nPosDataApo	,	CALEND_POS_TP_HE_FER_NT	]
			cP3Desc		:= __aLstTabCal[ nPosDataApo	,	CALEND_POS_DESC_FERIADO	]

			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Exclui a Data de Apontamento Existente para Inclusao de NovaЁ
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			IF ( ( nY := nPosDataApo ) > 0 )
				nLenCalend := Len( aTabCalend )
				While (;
							( nY <= nLenCalend )  .and. ;
							( nLenCalend > 0 )	  .and.	;
							( aTabCalend[ nY , CALEND_POS_DATA_APO ] >= __aLstTabCal[ nPosDataApo , CALEND_POS_DATA_APO ] );
					   )
					aDel( aTabCalend , nY )
					aSize( aTabCalend , --nLenCalend )
				End While
			EndIF
            
           	/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Posicao da primeira recriacao								  Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/  
			nLenRecria := If ( Empty(nLenRecria), Len(aTabCalend)+1,nLenRecria )

			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Loop For/Next para a Carga das Marcacoes do Dia             Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/  
			For nY := 1 To nFornY

				/*/
				зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				Ё Abandona Quando as Marcacoes estiverem Vazias e Nao For  JorЁ
				Ё nada Continua												  Ё
				юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
				IF (;
						( ( nY == 3 ) .and. ( ( aTabTno[ nPos , 03 ] + aTabTno[ nPos , 04 ] ) == 0 ) .and. ( aTabTno[ nPos , 33 ] != "S" ) ) .or. ;
				   		( ( nY == 5 ) .and. ( ( aTabTno[ nPos , 05 ] + aTabTno[ nPos , 06 ] ) == 0 ) .and. ( aTabTno[ nPos , 34 ] != "S" ) ) .or. ;
				   		( ( nY == 7 ) .and. ( ( aTabTno[ nPos , 07 ] + aTabTno[ nPos , 08 ] ) == 0 ) .and. ( aTabTno[ nPos , 35 ] != "S" ) )      ;
				   	)	
					Exit
				EndIF
		
				/*/
				зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				Ё Carrega Informacoes Especificas para a Nova Data de Apont.  Ё
				юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
				IF ( lBldNewOrd )
			
					/*/
					зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
					Ё Incrementa dData e nDias Quando Marcacao for do Dia SeguinteЁ
					юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
					IF ( aTabTno[ nPos , nY ] <  aTabTno[ nPos , IF( nY == 1 , nY , nY-1 ) ] )
						++dData
						++nDias
					EndIF
			
					/*/
					зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
					Ё Incrementa dData e nDias Caso Jornada Continua			  Ё
					юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
					IF (;
							lJndC := (;
										( ( nY == 2 ) .and. ( aTabTno[ nPos , 32 ] == "S" ) ) .or. ;
					   		  	    	( ( nY == 4 ) .and. ( aTabTno[ nPos , 33 ] == "S" ) ) .or. ;
					   			    	( ( nY == 6 ) .and. ( aTabTno[ nPos , 34 ] == "S" ) ) .or. ;
					   			    	( ( nY == 8 ) .and. ( aTabTno[ nPos , 35 ] == "S" ) )	   ;
					   			 	 );
					   	)
					   	lIncrementa	:= .T.
						++dData
						++nDias
					EndIF

					/*/
					зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
					ЁVerifica Centro de Custo, Horas Trabalhadas e Horas de  InterЁ
					ЁValo														  Ё
					юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
					cCcCal	:= ""
					cFuncCal:= ""
					nHrTrab := 0
					nHrInte := 0
					Do Case
						Case ( aTipo[ nY ] $ "1E*1S" )
							cCcCal 		:= aTabTno[ nPos , 25 ] 
							cFuncCal 	:= aTabTno[ nPos , 38 ]
							cJndCont	:= aTabTno[ nPos , 32 ]
							cDepto		:= aTabTno[ nPos , 58 ]
							cPosto		:= aTabTno[ nPos , 62 ]
							cCodJor		:= aTabTno[ nPos , 70 ]
							IF ( aTipo[ nY ] == "1E" )
								nHrTrab  := aTabTno[ nPos , 09 ]
								nLimInfE := aTabTno[ nPos , 42 ]
								nLimSupE := aTabTno[ nPos , 43 ]
							Else
								nHrInte  := aTabTno[ nPos , 13 ]
								nLimInfS := aTabTno[ nPos , 44 ]
								nLimSupS := aTabTno[ nPos , 45 ]
							EndIF
						Case ( aTipo[ nY ] $ "2E*2S" )
							cCcCal 		:= aTabTno[ nPos , 26 ]
							cFuncCal 	:= aTabTno[ nPos , 39 ]
							cJndCont	:= aTabTno[ nPos , 33 ]
							cDepto		:= aTabTno[ nPos , 59 ]
							cPosto		:= aTabTno[ nPos , 63 ]
							cCodJor		:= aTabTno[ nPos , 70 ]
							IF ( aTipo[ nY ] == "2E" )
								nHrTrab  := aTabTno[ nPos , 10 ]
								nLimInfE := aTabTno[ nPos , 46 ]
								nLimSupE := aTabTno[ nPos , 47 ]
							Else
								nHrInte  := aTabTno[ nPos , 14 ]
								nLimInfS := aTabTno[ nPos , 48 ]
								nLimSupS := aTabTno[ nPos , 49 ]
							EndIF
						Case ( aTipo[ nY ] $ "3E*3S" )
							cCcCal 		:= aTabTno[ nPos , 27 ]
							cFuncCal 	:= aTabTno[ nPos , 40 ]
							cJndCont	:= aTabTno[ nPos , 34 ]
							cDepto		:= aTabTno[ nPos , 60 ]
							cPosto		:= aTabTno[ nPos , 64 ]
							cCodJor		:= aTabTno[ nPos , 70 ]
							IF ( aTipo[ nY ] == "3E" )
								nHrTrab  := aTabTno[ nPos , 11 ]
								nLimInfE := aTabTno[ nPos , 50 ]
								nLimSupE := aTabTno[ nPos , 51 ]
							Else
								nHrInte  := aTabTno[ nPos , 15 ]
								nLimInfS := aTabTno[ nPos , 52 ]
								nLimSupS := aTabTno[ nPos , 53 ]
							EndIF
						Case ( aTipo[ nY ] $ "4E*4S" )
							cCcCal 		:= aTabTno[ nPos , 28 ]
							cFuncCal 	:= aTabTno[ nPos , 41 ]
							cJndCont	:= aTabTno[ nPos , 35 ]
							cDepto		:= aTabTno[ nPos , 61 ]
							cPosto		:= aTabTno[ nPos , 65 ]
							cCodJor		:= aTabTno[ nPos , 70 ]
							IF ( aTipo[ nY ] == "4E" )
								nHrTrab  := aTabTno[ nPos , 12 ]
								nLimInfE := aTabTno[ nPos , 54 ]
								nLimSupE := aTabTno[ nPos , 55 ]
							Else
								nLimInfS := aTabTno[ nPos , 52 ]
								nLimSupS := aTabTno[ nPos , 53 ]
							EndIF
					EndCase
					
   					 
					/*/
					зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
					Ё Carrega Novo Elemento no Calendario   					  Ё
					юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
					aAdd( aTabCalend, Array( ELEMENTOS_ATABCALEND ) )
					nLenCalend := Len( aTabCalend )
					aTabCalend[	nLenCalend	,	CALEND_POS_DATA				] := dData																					// 01 - Data
					aTabCalend[	nLenCalend	,	CALEND_POS_ORDEM			] := cOrdem																					// 02 - Ordem
					aTabCalend[	nLenCalend	,	CALEND_POS_HORA				] := aTabTno[ nPos , nY ]      																// 03 - Hora
					aTabCalend[	nLenCalend	,	CALEND_POS_TIPO_MARC		] := aTipo[ nY ]          																	// 04 - Tipo Marc
					aTabCalend[	nLenCalend	,	CALEND_POS_NUM_MARC			] := aTabTno[ nPos , 17 ]     																// 05 - No Marc.
					aTabCalend[	nLenCalend	,	CALEND_POS_TIPO_DIA			] := cTipoDia     																			// 06 - Tipo Dia
					aTabCalend[	nLenCalend	,	CALEND_POS_HRS_TRABA		] := nHrTrab																				// 07 - Horas Trabalhada no Periodo
					aTabCalend[	nLenCalend	,	CALEND_POS_SEQ_TURNO		] := aTabTno[ nPos , 19 ]   																// 08 - Sequ┬ncia de Turno
					aTabCalend[	nLenCalend	,	CALEND_POS_HRS_INTER		] := nHrInte																				// 09 - Horas de Intervalo
					aTabCalend[	nLenCalend	,	CALEND_POS_EXCECAO			] := aTabTno[ nPos , 21 ]																	// 10 - Excecao ( E-Excecao, # E - nao e excecao )
					aTabCalend[	nLenCalend	,	CALEND_POS_MOT_EXECAO		] := aTabTno[ nPos , 22 ]																	// 11 - Motivo da Excecao
					aTabCalend[	nLenCalend	,	CALEND_POS_TIPO_HE_NOR		] := aTabTno[ nPos , 23 ]																	// 12 - Tipo de hora extra normal
					aTabCalend[	nLenCalend	,	CALEND_POS_TIPO_HE_NOT		] := aTabTno[ nPos , 24 ]																	// 13 - Tipo de hora extra noturna
					aTabCalend[	nLenCalend	,	CALEND_POS_TURNO			] := cNewTno																				// 14 - Turno de Trabalho
					aTabCalend[	nLenCalend	,	CALEND_POS_CC				] := cCcCal																					// 15 - Centro de Custo do Periodo 
					aTabCalend[	nLenCalend	,	CALEND_POS_PG_NONA_HORA		] := aTabTno[ nPos , 29 ]																	// 16 - Pagamento de Nona Hora
					IF ( nY == 1 )
						If !lMVLimSup .and. nLenCalend > 1
							//O limite superior do dia anterior serА o limite inferior do dia atual menos um minuto
							nSerial		:= ( __fDhToNS( dData , aTabTno[ nPos , nY ] ) - __fDhToNS( NIL , aTabTno[ nPos , 30 ] ) )
							aMarcId[1]	:= __fNsToDh( nSerial , "D" )
							aMarcId[2]	:= __fNsToDh( nSerial , "H" )
							
							If aMarcId[2] > 0
								aMarcId[2]	:= SubHoras(aMarcId[2],0.01) 
							Else
								aMarcId[2] := 23.59
								aMarcId[1] := aMarcId[1] - 1
							EndIf
							
							aTabCalend[	nLenCalend-1	,	CALEND_POS_LIM_MARCACAO	] := aClone( aMarcId )
						EndIf					
						nSerial		:= ( __fDhToNS( dData , aTabTno[ nPos , nY ] ) - __fDhToNS( NIL , aTabTno[ nPos , 30 ] ) )
						aMarcId[1]	:= __fNsToDh( nSerial , "D" )
						aMarcId[2]	:= __fNsToDh( nSerial , "H" )
					Else
						aMarcId[1] := Ctod("//")
						aMarcId[2] := 0
					EndIF
					aTabCalend[	nLenCalend	,	CALEND_POS_LIM_MARCACAO		] := aClone( aMarcId )																		// 17 - Limite de Marcacao Inicial
					aTabCalend[	nLenCalend	,	CALEND_POS_COD_REFEICAO		] := IF(Empty(aTabTno[nPos,36]).and.!Empty(aTabOrig),aTabOrig[nPos,36],aTabTno[nPos,36])	// 18 - Codigo da Refeicao
					aTabCalend[	nLenCalend	,	CALEND_POS_FERIADO			] := lFeriado																				// 19 - Dia e Feriado
					aTabCalend[	nLenCalend	,	CALEND_POS_TP_HE_FER_NR		] := cP3TpExt																				// 20 - Tipo de Hora Extra Feriado Normal
					aTabCalend[	nLenCalend	,	CALEND_POS_TP_HE_FER_NT 	] := cP3TpExtN																				// 21 - Tipo de Hora Extra Feriado Noturna
					aTabCalend[	nLenCalend	,	CALEND_POS_DESC_FERIADO		] := cP3Desc																				// 22 - Descricao do Feriado
					aTabCalend[	nLenCalend	,	CALEND_POS_REGRA			] := cNewReg																				// 23 - Regra de Apontamento
					aTabCalend[	nLenCalend	,	CALEND_POS_AFAST			] := lAfast																					// 24 - Funcionario Afastado
					aTabCalend[	nLenCalend	,	CALEND_POS_TIP_AFAST		] := cTipAfas																				// 25 - Tipo de Afastamento
					aTabCalend[	nLenCalend	,	CALEND_POS_INI_AFAST		] := dIniAfas																				// 26 - Data Inicial do Afastamento
					aTabCalend[	nLenCalend	,	CALEND_POS_FIM_AFAST		] := dFimAfas																				// 27 - Data Final do Afastamento
					aTabCalend[	nLenCalend	,	CALEND_POS_INI_H_NOT		] := nIniHnot																				// 28 - Inicio da Hora Noturna
					aTabCalend[	nLenCalend	,	CALEND_POS_FIM_H_NOT		] := nFimHnot																				// 29 - Final da Hora Noturna
					aTabCalend[	nLenCalend	,	CALEND_POS_MIN_H_NOT		] := nMinHnot																				// 30 - Minutos da Hora Noturna
					aTabCalend[	nLenCalend	,	CALEND_POS_TRAB_FERIADO		] := lTrbFeriado																			// 31 - Se funcionario Trabalha em Dias Feriados
					aTabCalend[	nLenCalend	,	CALEND_POS_APON_FERIAS		] := lAponFer																				// 32 - Se Aponta Quando Afastamento em Ferias
					aTabCalend[	nLenCalend	,	CALEND_POS_TP_HE_NR_FER		] := cTpExNorFer																			// 33 - Tipo de hora extra normal (Ferias)
					aTabCalend[	nLenCalend	,	CALEND_POS_TP_HE_NT_FER		] := cTpExNotFer																			// 34 - Tipo de hora extra noturna (Ferias)	
					aTabCalend[	nLenCalend	,	CALEND_POS_PAGINT			] := cPagInt																				// 35 - Tipos de Intervalos Que sao Pagos conforme Regra
					aTabCalend[ nLenCalend	,   CALEND_POS_TIPO_ORIG_DIA    ] := aTabTno[nPos,18]																		// 36 - Tipo Original do Dia conforme excecao mas sem considerar a regra e/ou afastamentos
					aTabCalend[ nLenCalend	,   CALEND_POS_HE_AUTO_FER      ] := lHeAutoFer																				// 37 - Se H.Extras sЦo autorizadas para funcionario em ferias				
					aTabCalend[ nLenCalend	,   CALEND_POS_CODFUNC 		    ] := cFuncCal																				// 38 - Codigo de funcao
					aTabCalend[ nLenCalend  , 	CALEND_POS_DEPTO			] := cDepto																					// 39 - Codigo de Depto. do funcionario
					aTabCalend[ nLenCalend  , 	CALEND_POS_POSTO			] := cPosto																					// 40 - Codigo do Posto do funcionario
					aTabCalend[ nLenCalend  , 	CALEND_POS_PERIODO	   		] := cCodPer  																				// 41 - Periodo
					aTabCalend[ nLenCalend  , 	CALEND_POS_ROTEIRO			] := cCodRot  																				// 42 - Roterio
					aTabCalend[ nLenCalend  , 	CALEND_POS_PROCESSO			] := cCodPro  																	   			// 43 - Processo
					aTabCalend[ nLenCalend  , 	CALEND_POS_NUM_PAGTO		] := cNumPag  																				// 44 - Num. de Pagamento
					aTabCalend[ nLenCalend  , 	CALEND_POS_JORN		   		] := cCodJor 																				// 45 - Cod. da Jornada
					aTabCalend[ nLenCalend  , 	CALEND_POS_P2ID				] := cIdExce 				   																// 46 - Lote da excecao
					aTabCalend[ nLenCalend	,   CALEND_POS_R8ID				] := cIdAfas																	   			// 47 - Identificacao afastamento
					aTabCalend[ nLenCalend	,   CALEND_POS_DATA_APO		    ] := dDataApo																				// 48 - Data de apontamento					
					aTabCalend[ nLenCalend	, 	CALEND_POS_JND_CON			] := cJndCont																				// 49 - Jornada continua						
					aTabCalend[ nLenCalend  , 	CALEND_POS_LIE				] := nLimInfE 																				// 50 - Limite inferior da entrada
					aTabCalend[ nLenCalend  , 	CALEND_POS_LSE				] := nLimSupE																				// 51 - Limite superior da entrada
					aTabCalend[ nLenCalend  , 	CALEND_POS_LIS				] := nLimInfS																				// 52 - Limite inferior da saida
					aTabCalend[ nLenCalend  ,   CALEND_POS_LSS				] := nLimSupS 
					aTabCalend[ nLenCalend  , 	CALEND_POS_TPEXCE			] := cTpExce

				EndIF

				/*/
				зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				Ё Define a Posicao do Calendario quando nao Remontar Ordem    Ё
				юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/  
				IF !( lBldNewOrd )
					IF ( ( ++nLenCalend ) > Len( aTabCalend )  )
						Exit
					EndIF
				EndIF

			Next nY

			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Quando inserir nova data de apontamento verifica o Sincronismo  Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/  
			IF ( lBldNewOrd )
				nSerial		:= ( __fDhToNS( aTabCalend[ nLenCalend , CALEND_POS_DATA ] , aTabCalend[ nLenCalend , CALEND_POS_HORA ] ) + __fDhToNS( NIL ,aTabTno[ nPos , 31 ]) )
				aMarcId[1]	:= __fNsToDh( nSerial , "D" )
				aMarcId[2]	:= __fNsToDh( nSerial , "H" )
				
				If !lMVLimSup
					//Limite superior do ultimo dia deve ser igual o limite inferior da proxima jornada menos um
					
					If ( ( nPos := aScan( aTurnos , { |x| x[2] == dData+1 } ) ) > 0 )
						nSeq	:= Val(aTurnos[ nPos , 03 ])
					ElseIf Dow( dData+1 ) == 2
						nSeq++
					EndIf
										
					bAsc := { |x| (	AllTrim( x[19] ) == StrZero( nSeq , IF( nSeq < 10 , 1 , 2 ) ) .or. AllTrim( x[19] ) == StrZero( nSeq , 2 ) ) ;
							  .and. x[20] == Dow(dData+1);
							 }
							 
					If ( ( nPos := aScan( aTabTno , bAsc ) ) > 0 )
						nSerial		:= ( __fDhToNS( dData+1 , aTabTno[ nPos , 1 ] ) - __fDhToNS( NIL , aTabTno[ nPos , 30 ] ) )
						aMarcId[1]	:= __fNsToDh( nSerial , "D" )
						aMarcId[2]	:= __fNsToDh( nSerial , "H" )
			
						If aMarcId[2] > 0
							aMarcId[2]	:= SubHoras(aMarcId[2],0.01) 
						Else
							aMarcId[2] := 23.59
							aMarcId[1] := aMarcId[1] - 1
						EndIf
					EndIf
				EndIf				 
								
				aTabCalend[	nLenCalend	,	CALEND_POS_LIM_MARCACAO	] := aClone( aMarcId )																		// 17 - Limite de Marcacao Final
			EndIF				
			
			//Se existir excecao na data, alimenta aMarcacoes para que nao seja classificado como turno opcional
			If lExceData
				If (nPos1:= Ascan(aMarcacoes, {|x| EMPTY( x[AMARC_TNOPC] )  } ) )  >   0
	
				    //-- Corre todas as marcacoes a partir da primeira marcacao nao classificada
					For nPos2 := nPos1 To Len(aMarcacoes)
	
					   	If ( EMPTY( aMarcacoes[nPos2, AMARC_TNOPC] ) .and. (aMarcacoes[nPos2, AMARC_ORDEM] == cOrdem) )
							aMarcacoes[nPos2, AMARC_TNOPC] := aTabTno[ nPos , 19 ]
				 	   	Endif
	 	   			Next nPos2
				EndIf
			EndIf			
			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Se Houve Alteracao na Tabela Padrao/Regra em Funcao das ExceЁ
			Ё coes, Restaura os Padroes								      Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			IF ( !Empty( aTabOrig ) )
				aTabTno		:= aClone( aTabOrig )
				aTabOrig	:= {}
				cNewReg		:= cRegOrig
				cRegOrig	:= ""
				cIdExce		:= ""
				cTpExce		:= ""
			EndIF
	
			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Se Nao eh jornada continua, os dias acrescidos no dia de    Ё
			Ё apontamento nao serao considerados.					      Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		    If !lIncrementa
		       nDias	:= 0
			Else
			   //-- Desconsidera o ultimo incremento para considerar a ultima data incrementada
			   -- nDias
		    Endif
	
		Next nX                  
        
    	/*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		ЁRenomeia chaves de identificacao Processo/Periodo			  Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/ 
		If !Empty(nLenRecria)
			fFilIdTabela( aTabCalend, nLenRecria, aTransf )
		EndIf
       
		/*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		ЁReordena Calendario conforme a Data de Apontamento			  Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		IF ( lForceSinc )
			aSort( aTabCalend , NIL , NIL , { |x,y|	;
														(;
															Dtos(x[ CALEND_POS_DATA_APO 	]) + ;
															x[ CALEND_POS_TIPO_MARC	]			 ;
														) < ;
														(;
															Dtos(y[ CALEND_POS_DATA_APO 	]) + ;
															y[ CALEND_POS_TIPO_MARC	]			;
														);
											 };
				  )
		EndIF
        	
	EndIF
	
	/*/
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	ЁSincroniza horarios iniciais da tabela para evitar intervalosЁ
	Ёentre os limites inicial do dia corrente e final do dia  anteЁ
	Ёrior.														  Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	IF ( ( lSncMaMe ) .and. ( lForceSinc ) )
		CalSncMaMe(	@aTabCalend	,;	//01 -> Calendario de Marcacoes
					@aTabPadrao	,;	//02 -> Tabela de Horario Padrao
					aDataApo	,;	//03 -> Array com as Datas de Apontamento do Calendario
					dDataIni	,;	//04 -> Inicio do Periodo de Apontamento
					dDataFim	,; 	//05 -> Final do Periodo de Apontamento
					cTno		,;	//06 -> Turno de Trabalho
					cSeq		,;	//07 -> Sequencia de Turno
					cFil     	,;	//08 -> Filial do Funcionario
					cMat   		,;	//09 -> Matricula do Funcionario
					cCc   		,;	//10 -> Centro de Custo do Funcionario
					.F.			,;	//11 -> Marcacoes Sendo carregadas pela Ordem
					lChkMat		,;	//12 -> Se o Calendario esta sendo Montado por Funcionario
					lTabCalen	 ;
		   		   )
	EndIF	   		   

End Sequence

Return( lCriaCalOk )

/*/
зддддддддддбддддддддддддддддбдддддбдддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁBldCalTnoSeq	ЁAutorЁMarinaldo de Jesus Ё Data Ё17/09/2003Ё
|    	   |		     	Ё     ЁIgor Franzoi	      Ё      Ё23/11/2007Ё
цддддддддддеддддддддддддддддадддддадддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁCria Calendario de Marcacoes Padrao Para o Turno/Sequencia  Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGenerico													Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function BldCalTnoSeq(	dDataIni		,;	//01 -> Data Inicial do Periodo
								dDataFim		,;	//02 -> Data Final do Periodo
								aTipo			,;	//03 -> Tipos de Marcacoes Possiveis
								cTno			,;	//04 -> Turno Para a Montagem do Calendario
								cSeq			,;	//05 -> Sequencia Inicial para a Montagem Calendario
								cReg			,;	//06 -> Regra do Funcionario
								aTabPadrao		,;	//07 -> Array Tabela de Horario Padrao
								aTabCalend		,;	//08 -> Array com o Calendario de Marcacoes
								aLstTabTno		,;	//09 -> Tabela do Turno Corrente
								cFil			,;	//10 -> Filial para a Montagem da Tabela de Horario
								lExecQryTop 	,;	//11 -> Se executa Query para a Montagem da Tabela Padrao
								lSncMaMe		,;	//12 -> Se executa a funcao se sincronismo do calendario
								lTabCalen		 ;  //13 -> Nao zerar o array aTabCalend - Calendario Complementar	
							)
/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Variaveis de Inicializacao Obrigatoria					  Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Local aMarcId	 	:= { NIL , NIL }
Local aTabTno		:= {}
Local aDataApo		:= {}
Local lCriaCalOk	:= .T.
Local lAponFer		:= .F.
Local nOrdem		:= 0
Local nFornY		:= Len( aTipo )
Local nSeq			:= Val( cSeq )
Local nDias			:= 0
Local lChkReg		:= ( !Empty( cReg ) .and. ( cReg <> "__cNewReg__" ) )
Local lHeAutoFer	:= .T.

/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Variaveis que serao inicializadas no Corpo da Funcao		  Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Local aSr6Info
Local aSpaInfo

Local bAsc

Local cOrdem
Local cFilSP3
Local cFilSPJ
Local cFilSR6
Local cFilSPA
Local cPagInt
Local cP3TpExt
Local cP3TpExtN
Local cP3Desc

Local dData
Local cCcCal
Local cDepto
Local cPosto
Local cCodPer	:= ""
Local cCodRot	:= ""
Local cCodPro	:= ""
Local cNumPag	:= ""
Local cCodJor
Local cIdAfas
Local dDataApo
Local cFuncCal
Local cJndCont

Local lJndC
Local lFeriado 
Local lIncrementa	:= .F. //Incrementa dia de periodo de apontamento para jornada continua
Local lTrbFeriado

Local nIniHnot
Local nFimHnot
Local nMinHNot
Local nLimInfE
Local nLimSupE
Local nLimInfS
Local nLimSupS
Local nSerial
Local nLenTabPad
Local nLenCalend
Local nX
Local nY
Local nFornX
Local nPos
Local nHrTrab
Local nHrInte   

Local lError	:= ( Type("oCalendError") <> "U" )

aLogErr030 	:= If ( Type("aLogErr030") == "U" , aLogErr030 := {}, aLogErr030 )
/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Obtem a Filial Para a Pesquisa dos Feriados                 Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
cFilSP3	:= xFilial( "SP3" , cFil )

/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Obtem a Filial Para a Montagem do Calendario                Ё
Ё Case o parametro lUseSPJ = .T. utiliza filial do SPJ, senao Ё
Ё utiliza a tabela de horario RF2			      Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
If( lUseSPJ, cFilSPJ := xFilial( "SPJ" , cFil ), cFilSpj := xFilial( "RF2" , cFil ) )

/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Obtem a Filial do SR6                                       Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
cFilSR6 := xFilial( "SR6" , cFil )

/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Obtem a Filial do SPA                                       Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
cFilSPA	:= xFilial( "SPA" , cFil )

/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Carrega as Tabelas de Horario Padrao da Filial/Turno        Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
fTabPadrao( @aTabPadrao , @cFilSPJ , cTno , lExecQryTop )
IF ( ( ( nLenTabPad := Len( aTabPadrao ) ) == 0 ) .or. ( __nFilTabTno > nLenTabPad ) )
	__nFilTabTno := 0
EndIF	

/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Se nao Verificar a Regra carrega os Espacos correspondentes Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
IF !( lChkReg )
	cReg := Space( GetSx3Cache( "PA_CODIGO" , "X3_TAMANHO" ) )
EndIF

Begin Sequence

	/*/
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Pesquisa e Carrega a Tabela do Turno Corrente				  Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	IF ( ( __nFilTabTno > 0 ) .and. ( __nFilTabTno <= nLenTabPad ) .and. ( ( cFilSPJ + cTno ) == ( aTabPadrao[ __nFilTabTno , 01 ] + aTabPadrao[ __nFilTabTno , 02 ] ) ) )
		aTabTno := aClone( aTabPadrao[ __nFilTabTno , 3 ] )
	Else
		IF ( lCriaCalOk := ( ( nPos := aScan( aTabPadrao , { |x| x[1] == cFilSPJ .and. x[2] == cTno } ) ) > 0 ) )
			aTabTno := aClone( aTabPadrao[ nPos , 3 ] )
			__nFilTabTno := nPos
		Else
			AADD( aLogErr030, "04" ) //04 = Problema ao Carregar Turno da Tabela PadrЦo!   
			If lError
				oCalendError:SendError('02',cTno, .T.)		//Nao foi encontrado Turno XXX
			Endif
			Break
		EndIF
	EndIF	

	/*/
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Salva a Tabela do Turno Corrente              			  Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	aLstTabTno := aClone( aTabTno )
	
	If !lTabCalen
		/*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Inicializa o Array aTabCalend ( Calendario das Marcacoes )  Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		aTabCalend := {}
	EndIf

	/*/
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Loop For/Next para a Carga das Marcacoes do Periodo         Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	If	!Empty(aTabCalend)
		nX 	   := (Len(aTabCalend)+1)
		nOrdem := aTabCalend[ Len(aTabCalend), CALEND_POS_ORDEM ]
	Else
		nX := 0	
		//Caso ja exista dias do periodo gravados no calendario, inicia ordem a partir do ultimo registro existente.
		If !( __nOrdIni == NIL )
			nOrdem := __nOrdIni
		EndIf		
	EndIf


	nFornX := ( dDataFim - dDataIni )
	For nX := nX To nFornX
		
		/*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Data a ser verificada										  Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		dData := ( dDataIni + nX )
        
		/*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Salva a Data de Apontamento								  Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/  
		dDataApo	:= dData
	
		/*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё A Sequencia eh incrementada a Cada Segunda Feira			  Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		IF ( ( nX != 0 ) .and. ( Dow( dData ) == 2 ) )
			nSeq++
		EndIF

		IF ( lIncrementa ) 
			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Verifica se a Sequ┬ncia atual est═ cadastrada na Tabela. PesЁ
			Ё quisa a Sequencia Primeiro com o StrZero( n , 1 ) "0" e   DeЁ
			Ё pois com StrZero( n , 2 ) "00"						      Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			bAsc := { |x| AllTrim( x[19] ) == StrZero( nSeq , IF( nSeq < 10 , 1 , 2 ) ) .or. AllTrim( x[19] ) == StrZero( nSeq , 2 ) }
			nSeq := IF( aScan( aTabTno , bAsc ) == 0 , 1 , nSeq )

			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Para Jornada Continua corre todas as datas para que seja    Ё
			Ё verificada se alguma segunda-feira ocorre durante a jornada Ё
			Ё e, assim, incrementarmos a sequencia.						  Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		    If nDias > 0
		      --nDias 
		      Loop
		    Endif   
		    lIncrementa := .F.
		EndIF
	
		/*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Ordem da Marcacao     									  Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		nOrdem++
		cOrdem := StrZero( nOrdem , Max( __nTamP8Ordem , Len( AllTrim( Str( nOrdem ) ) ) ) )

		/*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Se houver Sincronismo, adiciona a Data de Apontamento  	  Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		IF ( lSncMaMe )
			aAdd( aDataApo, dDataApo)
		EndIF

		/*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Verifica se a Sequ┬ncia atual est═ cadastrada na Tabela. PesЁ
		Ё quisa a Sequencia Primeiro com o StrZero( n , 1 ) "0" e   DeЁ
		Ё pois com StrZero( n , 2 ) "00"						      Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		bAsc := { |x| AllTrim( x[19] ) == StrZero( nSeq , IF( nSeq < 10 , 1 , 2 ) ) .or. AllTrim( x[19] ) == StrZero( nSeq , 2 ) }
		nSeq := IF( aScan( aTabTno , bAsc ) == 0 , 1 , nSeq )

		/*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		ЁVerifica se o Dia da Semana da Sequencia e equivalente ao DiaЁ
		Ёda Data a Ser Pesquisada. Pesquisa a Sequencia  Primeiro  comЁ
		Ёo StrZero( n , 1 ) "0" e Depois com o StrZero( n , 2 ) "00"  Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		bAsc := { |x| (	AllTrim( x[19] ) == StrZero( nSeq , IF( nSeq < 10 , 1 , 2 ) ) .or. AllTrim( x[19] ) == StrZero( nSeq , 2 ) ) ;
					  .and. x[20] == Dow(dData);
				 }
		IF !( lCriaCalOk := ( nPos := aScan( aTabTno, bAsc ) ) > 0 )
			AADD( aLogErr030, "04" ) //04 = Problema ao Carregar Turno da Tabela PadrЦo!
			If lError
				oCalendError:SendError('02',cTno, .T.)		//Nao foi encontrado Turno XXX
			Endif
			Break
		EndIF

		/*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Verifica se o Turno de Trabalho eh valido                   Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		IF !( lCriaCalOk := PosSR6( cTno , cFilSPJ , NIL , 01 , .F. ) )
			AADD( aLogErr030, "05" ) //05 = Turno de Trabalho InvАlido!   
			If lError
				oCalendError:SendError('02',cTno, .T.)		//Nao foi encontrado Turno XXX
			Endif									
			Break
		EndIF
				
		/*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Obtem as Informacoes em Cache do Turno de Trabalho          Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		aSr6Info := {;
						"R6_INIHNOT"	,;	//01
						"R6_FIMHNOT"	,;	//02
						"R6_MINHNOT"	;	//03   
					}
		aSr6Info := PosSR6( cTno , cFilSPJ , aSr6Info , 01 , .F. )

		/*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Obtem a Hora Noturna de Acordo com o Turno                  Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		nIniHnot := aSr6Info[1]	// Inicio da Hora Noturna
		nFimHnot := aSr6Info[2]	// Final da Hora Noturna
		nMinHnot := aSr6Info[3]	// Minutos da Hora Noturna

		/*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Garante que os Minutos da Hora Nunca Sera Menor que Zero	  Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		nMinHnot := IF( nMinHnot <= 0 , 60 , nMinHNot )				// Minutos da Hora Noturna

		/*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Verifica Quais Intervalos Sao Pagos             			  Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		cPagInt := ""
		IF ( lChkReg )
			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Verifica se a Regra de Apontamento eh Valida                Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			IF !( lCriaCalOk := PosSPA( cReg , cFilSPA , NIL , 01 , .F. ) )
				AADD( aLogErr030, "06" ) //06 = Regra de Apontamento InvАlida!
				If lError
					oCalendError:SendError('03',cReg, .T.)		//Nao foi encontrado a Regra XXX				
				Endif
				Break
			EndIF
			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Obtem as Informacoes em Cache da Regra de Apontamento       Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			aSpaInfo := {;
							"PA_PAGINT"		,;	//01
							"PA_FERIADO"	 ;	//02
						}
			aSpaInfo := PosSPA( cReg , cFilSPA , aSpaInfo , 01 , .F. )
			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Verifica Quais Intervalos Sao Pagos             			  Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			cPagInt := aSpaInfo[1]
		EndIF

		/*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Verifica Se o Dia em Questao eh um Feriado				  Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		lTrbFeriado := .F.
		IF ( lFeriado := fFeriado( cFilSP3 , dData ) )
			cP3TpExt		:= SP3->P3_TPEXT
			cP3TpExtN		:= SP3->P3_TPEXTN
			cP3Desc			:= SP3->P3_DESC
			IF ( lChkReg )
				lTrbFeriado := ( aSpaInfo[2] == "S" )
			EndIF
		Else
			cP3TpExt	:= ""
			cP3TpExtN	:= ""
			cP3Desc		:= ""
		EndIF		

		/*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Define o Tipo do Dia                                    	  Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		cTipoDia := aTabTno[ nPos , 18 ]

		/*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Se funcionario nao Trabalha em Feriado e dia For Feriado 	  Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		IF ( ( lFeriado ) .and. !( lTrbFeriado ) )
			cTipoDia := "F" //Feriado
		EndIF 

		/*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Loop For/Next para a Carga das Marcacoes do Dia             Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/  
		For nY := 1 To nFornY

			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Abandona Quando as Marcacoes estiverem Vazias e Nao For  JorЁ
			Ё nada Continua												  Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			IF (;
					( ( nY == 3 ) .and. ( ( aTabTno[ nPos , 03 ] + aTabTno[ nPos , 04 ] ) == 0 ) .and. ( aTabTno[ nPos , 33 ] != "S" ) ) .or. ;
			   		( ( nY == 5 ) .and. ( ( aTabTno[ nPos , 05 ] + aTabTno[ nPos , 06 ] ) == 0 ) .and. ( aTabTno[ nPos , 34 ] != "S" ) ) .or. ;
			   		( ( nY == 7 ) .and. ( ( aTabTno[ nPos , 07 ] + aTabTno[ nPos , 08 ] ) == 0 ) .and. ( aTabTno[ nPos , 35 ] != "S" ) )      ;
			   	)	
				Exit
			EndIF

			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Incrementa dData e nDias Quando Marcacao for do Dia SeguinteЁ
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			IF ( aTabTno[ nPos , nY ] <  aTabTno[ nPos , IF( nY == 1 , nY , nY-1 ) ] )
				++dData
				++nDias
			EndIF

			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Incrementa dData e nDias Caso Jornada Continua			  Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			IF (;
					lJndC := (;
								( ( nY == 2 ) .and. ( aTabTno[ nPos , 32 ] == "S" ) ) .or. ;
			   		  	    	( ( nY == 4 ) .and. ( aTabTno[ nPos , 33 ] == "S" ) ) .or. ;
			   			    	( ( nY == 6 ) .and. ( aTabTno[ nPos , 34 ] == "S" ) ) .or. ;
			   			    	( ( nY == 8 ) .and. ( aTabTno[ nPos , 35 ] == "S" ) )	   ;
			   			 	 );
			   	)
				++dData
				++nDias
				lIncrementa	:= .T.
			EndIF

			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			ЁVerifica Centro de Custo, Funcao, Horas Trabalhadas e Horas  Ё
			Ёde  Intervalo												  Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			cCcCal	:= ""
			cFuncCal:= ""
			nHrTrab := 0
			nHrInte := 0
			Do Case
				Case ( aTipo[ nY ] $ "1E*1S" )
					cCcCal 		:= aTabTno[ nPos , 25 ] 
					cFuncCal 	:= aTabTno[ nPos , 38 ]
					cJndCont	:= aTabTno[ nPos , 32 ]
					cDepto		:= aTabTno[ nPos , 58 ]
					cPosto		:= aTabTno[ nPos , 62 ]
					cCodPro		:= aTabTno[ nPos , 66 ]
					cNumPag		:= aTabTno[ nPos , 67 ]
					cCodPer		:= aTabTno[ nPos , 68 ]
					cCodRot		:= aTabTno[ nPos , 69 ]
					cCodJor		:= aTabTno[ nPos , 70 ]
					IF ( aTipo[ nY ] == "1E" )
						nHrTrab  := aTabTno[ nPos , 09 ]
						nLimInfE := aTabTno[ nPos , 42 ]
						nLimSupE := aTabTno[ nPos , 43 ]
					Else
						nHrInte  := aTabTno[ nPos , 13 ]
						nLimInfS := aTabTno[ nPos , 44 ]
						nLimSupS := aTabTno[ nPos , 45 ]
					EndIF					
				Case ( aTipo[ nY ] $ "2E*2S" )
					cCcCal 		:= aTabTno[ nPos , 26 ]
					cFuncCal 	:= aTabTno[ nPos , 39 ]
					cJndCont	:= aTabTno[ nPos , 33 ]
					cDepto		:= aTabTno[ nPos , 59 ]
					cPosto		:= aTabTno[ nPos , 63 ]
					cCodPro		:= aTabTno[ nPos , 66 ]
					cNumPag		:= aTabTno[ nPos , 67 ]
					cCodPer		:= aTabTno[ nPos , 68 ]
					cCodRot		:= aTabTno[ nPos , 69 ]
					cCodJor		:= aTabTno[ nPos , 70 ]
					IF ( aTipo[ nY ] == "2E" )
						nHrTrab  := aTabTno[ nPos , 10 ]
						nLimInfE := aTabTno[ nPos , 46 ]
						nLimSupE := aTabTno[ nPos , 47 ]
					Else
						nHrInte  := aTabTno[ nPos , 14 ]
						nLimInfS := aTabTno[ nPos , 48 ]
						nLimSupS := aTabTno[ nPos , 49 ]
					EndIF
				Case ( aTipo[ nY ] $ "3E*3S" )
					cCcCal 		:= aTabTno[ nPos , 27 ]
					cFuncCal 	:= aTabTno[ nPos , 40 ]
					cJndCont	:= aTabTno[ nPos , 34 ]
					cDepto		:= aTabTno[ nPos , 60 ]
					cPosto		:= aTabTno[ nPos , 64 ]
					cCodPro		:= aTabTno[ nPos , 66 ]
					cNumPag		:= aTabTno[ nPos , 67 ]
					cCodPer		:= aTabTno[ nPos , 68 ]
					cCodRot		:= aTabTno[ nPos , 69 ]
					cCodJor		:= aTabTno[ nPos , 70 ]
					IF ( aTipo[ nY ] == "3E" )
						nHrTrab  := aTabTno[ nPos , 11 ]
						nLimInfE := aTabTno[ nPos , 50 ]
						nLimSupE := aTabTno[ nPos , 51 ]
					Else
						nHrInte  := aTabTno[ nPos , 15 ]
						nLimInfS := aTabTno[ nPos , 52 ]
						nLimSupS := aTabTno[ nPos , 53 ]
					EndIF	
				Case ( aTipo[ nY ] $ "4E*4S" )
					cCcCal 		:= aTabTno[ nPos , 28 ]
					cFuncCal 	:= aTabTno[ nPos , 41 ]
					cJndCont	:= aTabTno[ nPos , 35 ]
					cDepto		:= aTabTno[ nPos , 61 ]
					cPosto		:= aTabTno[ nPos , 65 ]
					cCodPro		:= aTabTno[ nPos , 66 ]
					cNumPag		:= aTabTno[ nPos , 67 ]
					cCodPer		:= aTabTno[ nPos , 68 ]
					cCodRot		:= aTabTno[ nPos , 69 ]
					cCodJor		:= aTabTno[ nPos , 70 ]
					IF ( aTipo[ nY ] == "4E" )
						nHrTrab  := aTabTno[ nPos , 12 ]
						nLimInfE := aTabTno[ nPos , 54 ]
						nLimSupE := aTabTno[ nPos , 55 ]
					Else
						nLimInfS := aTabTno[ nPos , 52 ]
						nLimSupS := aTabTno[ nPos , 53 ]
					EndIF	
			EndCase			

			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Carrega Novo Elemento no Calendario   					  Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			aAdd( aTabCalend, Array( ELEMENTOS_ATABCALEND ) )
			nLenCalend := Len( aTabCalend )
			aTabCalend[	nLenCalend	,	CALEND_POS_DATA				] := dData																			// 01 - Data
			aTabCalend[	nLenCalend	,	CALEND_POS_ORDEM			] := cOrdem																			// 02 - Ordem
			aTabCalend[	nLenCalend	,	CALEND_POS_HORA				] := aTabTno[ nPos , nY ]      														// 03 - Hora
			aTabCalend[	nLenCalend	,	CALEND_POS_TIPO_MARC		] := aTipo[ nY ]          															// 04 - Tipo Marc
			aTabCalend[	nLenCalend	,	CALEND_POS_NUM_MARC			] := aTabTno[ nPos , 17 ]     														// 05 - No Marc.
			aTabCalend[	nLenCalend	,	CALEND_POS_TIPO_DIA			] := cTipoDia     																	// 06 - Tipo Dia
			aTabCalend[	nLenCalend	,	CALEND_POS_HRS_TRABA		] := nHrTrab									 							 		// 07 - Horas Trabalhada no Periodo
			aTabCalend[	nLenCalend	,	CALEND_POS_SEQ_TURNO		] := aTabTno[ nPos , 19 ]   														// 08 - Sequ┬ncia de Turno
			aTabCalend[	nLenCalend	,	CALEND_POS_HRS_INTER		] := nHrInte																		// 09 - Horas de Intervalo
			aTabCalend[	nLenCalend	,	CALEND_POS_EXCECAO			] := aTabTno[ nPos , 21 ]															// 10 - Excecao ( E-Excecao, # E - nao e excecao )
			aTabCalend[	nLenCalend	,	CALEND_POS_MOT_EXECAO		] := aTabTno[ nPos , 22 ]															// 11 - Motivo da Excecao
			aTabCalend[	nLenCalend	,	CALEND_POS_TIPO_HE_NOR		] := aTabTno[ nPos , 23 ]															// 12 - Tipo de hora extra normal
			aTabCalend[	nLenCalend	,	CALEND_POS_TIPO_HE_NOT		] := aTabTno[ nPos , 24 ]															// 13 - Tipo de hora extra noturna
			aTabCalend[	nLenCalend	,	CALEND_POS_TURNO			] := cTno																			// 14 - Turno de Trabalho
			aTabCalend[	nLenCalend	,	CALEND_POS_CC				] := cCcCal										 							 		// 15 - Centro de Custo do Periodo 
			aTabCalend[	nLenCalend	,	CALEND_POS_PG_NONA_HORA		] := aTabTno[ nPos , 29 ]															// 16 - Pagamento de Nona Hora
			IF ( nY == 1 )
				If !lMVLimSup .and. nLenCalend > 1
					//O limite superior do dia anterior serА o limite inferior do dia atual menos um minuto
					nSerial		:= ( __fDhToNS( dData , aTabTno[ nPos , nY ] ) - __fDhToNS( NIL , aTabTno[ nPos , 30 ] ) )
					aMarcId[1]	:= __fNsToDh( nSerial , "D" )
					aMarcId[2]	:= __fNsToDh( nSerial , "H" )
					
					If aMarcId[2] > 0
						aMarcId[2]	:= SubHoras(aMarcId[2],0.01) 
					Else
						aMarcId[2] := 23.59
						aMarcId[1] := aMarcId[1] - 1
					EndIf
					
					aTabCalend[	nLenCalend-1	,	CALEND_POS_LIM_MARCACAO	] := aClone( aMarcId )
				EndIf
				nSerial		:= ( __fDhToNS( dData , aTabTno[ nPos , nY ] ) - __fDhToNS( NIL , aTabTno[ nPos , 30 ] ) )
				aMarcId[1]	:= __fNsToDh( nSerial , "D" )
				aMarcId[2]	:= __fNsToDh( nSerial , "H" )
			Else
				aMarcId[1] := Ctod("//")
				aMarcId[2] := 0
			EndIF
			aTabCalend[	nLenCalend	,	CALEND_POS_LIM_MARCACAO		] := aClone( aMarcId )																// 17 - Limite de Marcacao Inicial
			aTabCalend[	nLenCalend	,	CALEND_POS_COD_REFEICAO		] := aTabTno[ nPos , 36 ]															// 18 - Codigo da Refeicao
			aTabCalend[	nLenCalend	,	CALEND_POS_FERIADO			] := lFeriado																		// 19 - Dia e Feriado
			aTabCalend[	nLenCalend	,	CALEND_POS_TP_HE_FER_NR		] := cP3TpExt																		// 20 - Tipo de Hora Extra Feriado Normal
			aTabCalend[	nLenCalend	,	CALEND_POS_TP_HE_FER_NT 	] := cP3TpExtN																		// 21 - Tipo de Hora Extra Feriado Noturna
			aTabCalend[	nLenCalend	,	CALEND_POS_DESC_FERIADO		] := cP3Desc																		// 22 - Descricao do Feriado
			aTabCalend[	nLenCalend	,	CALEND_POS_REGRA			] := cReg																			// 23 - Regra de Apontamento
			aTabCalend[	nLenCalend	,	CALEND_POS_AFAST			] := .F.																			// 24 - Funcionario Afastado
			aTabCalend[	nLenCalend	,	CALEND_POS_TIP_AFAST		] := ""																				// 25 - Tipo de Afastamento
			aTabCalend[	nLenCalend	,	CALEND_POS_INI_AFAST		] := Ctod("//")																		// 26 - Data Inicial do Afastamento
			aTabCalend[	nLenCalend	,	CALEND_POS_FIM_AFAST		] := Ctod("//")																		// 27 - Data Final do Afastamento
			aTabCalend[	nLenCalend	,	CALEND_POS_INI_H_NOT		] := nIniHnot																		// 28 - Inicio da Hora Noturna
			aTabCalend[	nLenCalend	,	CALEND_POS_FIM_H_NOT		] := nFimHnot																		// 29 - Final da Hora Noturna
			aTabCalend[	nLenCalend	,	CALEND_POS_MIN_H_NOT		] := nMinHnot																		// 30 - Minutos da Hora Noturna
			aTabCalend[	nLenCalend	,	CALEND_POS_TRAB_FERIADO		] := lTrbFeriado																	// 31 - Se funcionario Trabalha em Dias Feriados
			aTabCalend[	nLenCalend	,	CALEND_POS_APON_FERIAS		] := lAponFer																		// 32 - Se Aponta Quando Afastamento em Ferias
			aTabCalend[	nLenCalend	,	CALEND_POS_TP_HE_NR_FER		] := ""																				// 33 - Tipo de hora extra normal (Ferias)
			aTabCalend[	nLenCalend	,	CALEND_POS_TP_HE_NT_FER		] := ""																				// 34 - Tipo de hora extra noturna (Ferias)	
			aTabCalend[	nLenCalend	,	CALEND_POS_PAGINT			] := cPagInt																		// 35 - Tipos de Intervalos Que sao Pagos conforme Regra
			aTabCalend[ nLenCalend	,   CALEND_POS_TIPO_ORIG_DIA    ] := aTabTno[nPos,18]																// 36 - Tipo Original do Dia conforme excecao mas sem considerar a regra e/ou afastamentos
			aTabCalend[ nLenCalend	,   CALEND_POS_HE_AUTO_FER      ] := lHeAutoFer																		// 37 - Se H.Extras sЦo autorizadas para funcionario em ferias				
			aTabCalend[ nLenCalend	,   CALEND_POS_CODFUNC 		    ] := cFuncCal																		// 38 - Cod. de Funcao			
			aTabCalend[ nLenCalend  , 	CALEND_POS_DEPTO			] := cDepto																			// 39 - Codigo de Depto. do funcionario
			aTabCalend[ nLenCalend  , 	CALEND_POS_POSTO			] := cPosto																			// 40 - Codigo do Posto do funcionario
			aTabCalend[ nLenCalend  , 	CALEND_POS_PERIODO	   		] := cCodPer  																		// 41 - Periodo
			aTabCalend[ nLenCalend  , 	CALEND_POS_ROTEIRO			] := cCodRot  																		// 42 - Roterio
			aTabCalend[ nLenCalend  , 	CALEND_POS_PROCESSO			] := cCodPro  																		// 43 - Processo
			aTabCalend[ nLenCalend  , 	CALEND_POS_NUM_PAGTO		] := cNumPag  																		// 44 - Num. de Pagamento
			aTabCalend[ nLenCalend  , 	CALEND_POS_JORN		   		] := cCodJor 																		// 45 - Cod. da Jornada
			aTabCalend[ nLenCalend  , 	CALEND_POS_P2ID				] := "" 				   															// 46 - Lote da excecao
			aTabCalend[ nLenCalend	,   CALEND_POS_R8ID				] := cIdAfas																		// 47 - Identificacao afastamento
			aTabCalend[ nLenCalend	,   CALEND_POS_DATA_APO		    ] := dDataApo  																		// 48 - Data de apontamento					
			aTabCalend[ nLenCalend	, 	CALEND_POS_JND_CON			] := cJndCont																		// 49 - Jornada continua						
			aTabCalend[ nLenCalend  , 	CALEND_POS_LIE				] := nLimInfE 																		// 50 - Limite inferior da entrada
			aTabCalend[ nLenCalend  , 	CALEND_POS_LSE				] := nLimSupE																		// 51 - Limite superior da entrada
			aTabCalend[ nLenCalend  , 	CALEND_POS_LIS				] := nLimInfS																		// 52 - Limite inferior da saida
			aTabCalend[ nLenCalend  ,   CALEND_POS_LSS				] := nLimSupS 																		// 53 - Limite superior da saida			
			aTabCalend[ nLenCalend  , 	CALEND_POS_TPEXCE			] := ""
			
		Next nY

		nSerial		:= ( __fDhToNS( aTabCalend[ nLenCalend , CALEND_POS_DATA ] , aTabCalend[ nLenCalend , CALEND_POS_HORA ] ) + __fDhToNS( NIL ,aTabTno[ nPos , 31] ) )
		aMarcId[1]	:= __fNsToDh( nSerial , "D" )
		aMarcId[2]	:= __fNsToDh( nSerial , "H" )

		aTabCalend[	nLenCalend	,	CALEND_POS_LIM_MARCACAO	] := aClone( aMarcId )																		// 17 - Limite de Marcacao Final

		If !lMVLimSup .and. nX == nFornX
			//Limite superior do ultimo dia deve ser igual o limite inferior da proxima jornada menos um
			If Dow( dData+1 ) == 2
				nSeq++
			EndIf
			
			bAsc := { |x| AllTrim( x[19] ) == StrZero( nSeq , IF( nSeq < 10 , 1 , 2 ) ) .or. AllTrim( x[19] ) == StrZero( nSeq , 2 ) }
			nSeq := IF( aScan( aTabTno , bAsc ) == 0 , 1 , nSeq )

			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			ЁVerifica se o Dia da Semana da Sequencia e equivalente ao DiaЁ
			Ёda Data a Ser Pesquisada. Pesquisa a Sequencia  Primeiro  comЁ
			Ёo StrZero( n , 1 ) "0" e Depois com o StrZero( n , 2 ) "00"  Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			bAsc := { |x| (	AllTrim( x[19] ) == StrZero( nSeq , IF( nSeq < 10 , 1 , 2 ) ) .or. AllTrim( x[19] ) == StrZero( nSeq , 2 ) ) ;
						  .and. x[20] == Dow(dData+1);
					 }
			If ( ( nPos := aScan( aTabTno, bAsc ) ) > 0 )
				nSerial		:= ( __fDhToNS( dData+1 , aTabTno[ nPos , 1 ] ) - __fDhToNS( NIL , aTabTno[ nPos , 30 ] ) )
				aMarcId[1]	:= __fNsToDh( nSerial , "D" )
				aMarcId[2]	:= __fNsToDh( nSerial , "H" )
			
				If aMarcId[2] > 0
					aMarcId[2]	:= SubHoras(aMarcId[2],0.01) 
				Else
					aMarcId[2] := 23.59
					aMarcId[1] := aMarcId[1] - 1
				EndIf				 
			
				aTabCalend[	nLenCalend	,	CALEND_POS_LIM_MARCACAO	] := aClone( aMarcId )
			EndIf
		EndIf				

		/*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Se Nao eh jornada continua, os dias acrescidos no dia de    Ё
		Ё apontamento nao serao considerados.					      Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	    If !lIncrementa
	       nDias	:= 0
		Else
		   //-- Desconsidera o ultimo incremento para considerar a ultima data incrementada
		   -- nDias
	    Endif

	Next nX                  

	/*/
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	ЁSincroniza horarios iniciais da tabela para evitar intervalosЁ
	Ёentre os limites inicial do dia corrente e final do dia  anteЁ
	Ёrior.														  Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	IF ( lSncMaMe )
		CalSncMaMe(	@aTabCalend	,;	//01 -> Calendario de Marcacoes
					@aTabPadrao	,;	//02 -> Tabela de Horario Padrao
					aDataApo	,;	//03 -> Array com as Datas de Apontamento do Calendario
					dDataIni	,;	//04 -> Inicio do Periodo de Apontamento
					dDataFim	,; 	//05 -> Final do Periodo de Apontamento
					cTno		,;	//06 -> Turno de Trabalho
					cSeq		,;	//07 -> Sequencia de Turno
					cFil     	,;	//08 -> Filial do Funcionario
					NIL   		,;	//09 -> Matricula do Funcionario
					NIL   		,;	//10 -> Centro de Custo do Funcionario
					.F.			,;	//11 -> Marcacoes Sendo carregadas pela Ordem
					.F.			 ;	//12 -> Se o Calendario esta sendo Montado por Funcionario
		   		   )
	EndIF	   		   

End Sequence

Return( lCriaCalOk )

/*/
зддддддддддбддддддддддддддддбдддддбдддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁRstCalendCria	ЁAutorЁMarinaldo de Jesus Ё Data Ё11/03/2003Ё
цддддддддддеддддддддддддддддадддддадддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁReinicializa as Staticas utilizadas em CalendCria()        	Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGenerico													Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function RstCalendCria()

__aLstTabCal	:= {}
__aLstTabTno	:= {}
__cKeyBldCal	:= "__cKeyBldCal"
__nFilTabTno	:= 0  
__aAllTnoOpc	:= {} 

Return( NIL )

/*/
зддддддддддбддддддддддддддддбдддддбдддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁGetTabCal		ЁAutorЁMarinaldo de Jesus Ё Data Ё18/09/2003Ё
цддддддддддеддддддддддддддддадддддадддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁRetorna Array contendo __aLstTabCal e __aLstTabTno			Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGenerico													Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function GetTabCal()

Local aTabsCal := Array( 03 )

aTabsCal[ 01 ] := aClone( __aLstTabCal )
aTabsCal[ 02 ] := aClone( __aLstTabTno )
aTabsCal[ 03 ] := __cKeyBldCal

Return( aClone( aTabsCal ) )

/*/
зддддддддддбддддддддддддддддбдддддбдддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁSetTabCal		ЁAutorЁMarinaldo de Jesus Ё Data Ё18/09/2003Ё
цддддддддддеддддддддддддддддадддддадддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁRestaura  __aLstTabCal e __aLstTabTno que foram salvos  pelaЁ
Ё          ЁGetTabCal()													Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGenerico													Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function SetTabCal( aTabsCal )

__aLstTabCal	:= aClone( aTabsCal[ 01 ] )
__aLstTabTno	:= aClone( aTabsCal[ 02 ] )
__cKeyBldCal	:= aTabsCal[ 03 ]

Return( NIL )

/*/
зддддддддддбддддддддддддбдддддбдддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁCalSncMaMe  ЁAutorЁ Marinaldo de Jesus    Ё Data Ё28/08/2003Ё
цддддддддддеддддддддддддадддддадддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁSincroniza o HorMais e HorMenos do Calendario de Marcacoes  Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>	                                Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>	                                Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGenerico                                                    Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function CalSncMaMe(	aTabCalend	,;	//01 -> Calendario de Marcacoes
							aTabPadrao	,;	//02 -> Tabela de Horario Padrao
							aDataApo	,;	//03 -> Array com as Datas de Apontamento do Calendario
							dPerIni		,;	//04 -> Inicio do Periodo de Apontamento
							dPerFim		,; 	//05 -> Final do Periodo de Apontamento
							cTno		,;	//06 -> Turno de Trabalho
							cSeq		,;	//07 -> Sequencia de Turno
							cFil     	,;	//08 -> Filial do Funcionario
							cMat   		,;	//09 -> Matricula do Funcionario
							cCc   		,;	//10 -> Centro de Custo do Funcionario
							lMarcOrder	,;	//11 -> Marcacoes Sendo carregadas pela Ordem
							lCalendFunc	 ;	//12 -> Se o Calendario esta sendo Montado por Funcionario
				   		   )

Local aMarcId		:= {}
Local bHrsAtu		:= { |x| NIL }
Local bHrsAnt		:= { |x| NIL }
Local dDataAtu		:= ""
Local dDataAnt		:= ""
Local nPosCalAtu	:= 0
Local nPosCalAnt	:= 0
Local nPosCalUlt	:= 0
Local nLoop			:= 0
Local nLoops		:= Len( aDataApo )
Local nSerial		:= 0
Local nHrsAtu		:= 0
Local nHrsAnt		:= 0
Local nDifHrs		:= 0
Local nHorMeno		:= 0
Local nHorMais		:= 0
Local nFator		:= 0

IF ( nLoops >= 2.00 )
	bHrsAtu		:= { |x| IF(;
								( x[ CALEND_POS_DATA_APO ] == dDataAtu ) ,;
								nHrsAtu := SomaHoras( nHrsAtu , x[ CALEND_POS_HRS_TRABA ] ),;
								NIL;
							);
					}
	bHrsAnt		:= { |x| IF(;
								( x[ CALEND_POS_DATA_APO ] == dDataAnt ) ,;
								nHrsAnt := SomaHoras( nHrsAnt , x[ CALEND_POS_HRS_TRABA ] ),;
								NIL;
							);
					}
	For nLoop := 1 To nLoops
		dDataAtu	:= aDataApo[ nLoop ]
		nPosCalAtu	:= aScan( aTabCalend , { |x|;
													( x[ CALEND_POS_DATA_APO ] == dDataAtu ) .and.;
													( x[ CALEND_POS_TIPO_MARC ] == "1E" );
											},;
							  ++nPosCalAtu;
							)
		IF ( nLoop == 1 )
			IF ( nPosCalAtu > 0 )
				nSerial := RetSerIni(	aClone( aTabCalend )	,;	//01 -> Copia do Calendario de Marcacoes
										@aTabPadrao				,;	//02 -> Tabela de Horario Padrao
										dPerIni					,;	//03 -> Inicio do Periodo de Apontamento
										dPerFim					,; 	//04 -> Final do Periodo de Apontamento
										cTno					,;	//05 -> Turno de Trabalho
										cSeq					,;	//06 -> Sequencia de Turno
										cFil     				,;	//07 -> Filial do Funcionario
										cMat   					,;	//08 -> Matricula do Funcionario
										cCc   					,;	//09 -> Centro de Custo do Funcionario
										lMarcOrder				,;	//10 -> Marcacoes Sendo carregadas pela Ordem
										lCalendFunc	 			 ;	//11 -> Se o Calendario esta sendo Montado por Funcionario
					   				 )
		  		aTabCalend[	nPosCalAtu , CALEND_POS_LIM_MARCACAO , 01	] := __fNsToDh( nSerial , "D" )
				aTabCalend[	nPosCalAtu , CALEND_POS_LIM_MARCACAO , 02	] := __fNsToDh( nSerial , "H" )
			EndIF	
		ElseIF ( nLoop == nLoops )
			IF (;
					(;
						nPosCalUlt := aScan(;
												aTabCalend , { |x|;
																	( x[ CALEND_POS_DATA_APO ] == dDataAtu ) .and.;
																	!Empty( x[ CALEND_POS_LIM_MARCACAO , 01 ] ) .and.;
																	( x[ CALEND_POS_TIPO_MARC ] <> "1E" );
														 	  },;
												++nPosCalAtu;
									 		);
					) > 0;
				)	
				dDataAnt	:= aDataApo[ nLoop-1]
		   		nPosCalAnt	:= aScan( aTabCalend , { |x| ( x[ CALEND_POS_DATA_APO ] == dDataAnt ) .and.;
													 !Empty( x[ CALEND_POS_LIM_MARCACAO , 01 ] ) .and.;
													 ( x[ CALEND_POS_TIPO_MARC ] <> "1E" );
											   },;
								  ++nPosCalAnt;
								 )
				nHrsAnt		:= 0
				aEval( aTabCalend , bHrsAnt )
				IF ( nHrsAnt > 0 )
					nSerial := (;
									__fDhToNS(;
												aTabCalend[ nPosCalAnt , CALEND_POS_LIM_MARCACAO , 01 ] ,;
												aTabCalend[ nPosCalAnt , CALEND_POS_LIM_MARCACAO , 02 ]	;
											  ) + ;
								   __fDhToNS( NIL , 0.01  );
								)         
				
					If ( __fDhToNS( aTabCalend[ nPosCalAtu, CALEND_POS_LIM_MARCACAO , 01 ] + aTabCalend[ nPosCalAtu, CALEND_POS_LIM_MARCACAO, 02 ], "D" ) < nSerial )
						nPosCalAnt := aScan(;
													aTabCalend , { |x|;
																		( x[ CALEND_POS_DATA_APO ] == dDataAtu ) .and.;
																		!Empty( x[ CALEND_POS_LIM_MARCACAO , 01 ] ) .and.;
																		( x[ CALEND_POS_TIPO_MARC ] == "1E" );
															 	  },;
													++nPosCalAnt;
										 		)
						aTabCalend[	nPosCalAnt , CALEND_POS_LIM_MARCACAO , 01	] := __fNsToDh( nSerial , "D" )
						aTabCalend[	nPosCalAnt , CALEND_POS_LIM_MARCACAO , 02	] := __fNsToDh( nSerial , "H" )
					EndIf
				Endif		
				nSerial := RetSerFim(	aClone( aTabCalend )	,;	//01 -> Copia do Calendario de Marcacoes
										@aTabPadrao				,;	//02 -> Tabela de Horario Padrao
										dPerIni					,;	//03 -> Inicio do Periodo de Apontamento
										dPerFim					,; 	//04 -> Final do Periodo de Apontamento
										cTno					,;	//05 -> Turno de Trabalho
										cSeq					,;	//06 -> Sequencia de Turno
										cFil     				,;	//07 -> Filial do Funcionario
										cMat   					,;	//08 -> Matricula do Funcionario
										cCc   					,;	//09 -> Centro de Custo do Funcionario
										lMarcOrder				,;	//10 -> Marcacoes Sendo carregadas pela Ordem
										lCalendFunc	 			 ;	//11 -> Se o Calendario esta sendo Montado por Funcionario
					   				 )
		  		aTabCalend[	nPosCalUlt , CALEND_POS_LIM_MARCACAO , 01	] := __fNsToDh( nSerial , "D" )
				aTabCalend[	nPosCalUlt , CALEND_POS_LIM_MARCACAO , 02	] := __fNsToDh( nSerial , "H" )
			EndIF
		Else
			dDataAnt	:= aDataApo[ nLoop - 1 ]
			nPosCalAnt	:= aScan( aTabCalend , { |x| ( x[ CALEND_POS_DATA_APO ] == dDataAnt ) .and.;
													 !Empty( x[ CALEND_POS_LIM_MARCACAO , 01 ] ) .and.;
													 ( x[ CALEND_POS_TIPO_MARC ] <> "1E" );
											   },;
								  ++nPosCalAnt;
								 )
			IF ( ( nPosCalAtu > 0 ) .and. ( nPosCalAnt > 0 ) )
				nHrsAtu		:= 0
				nHrsAnt		:= 0
				aEval( aTabCalend , bHrsAtu )
				aEval( aTabCalend , bHrsAnt )
				IF ( nHrsAnt > 0 )
					nSerial := (;
									__fDhToNS(;
												aTabCalend[ nPosCalAnt , CALEND_POS_LIM_MARCACAO , 01 ] ,;
												aTabCalend[ nPosCalAnt , CALEND_POS_LIM_MARCACAO , 02 ]	;
											  ) + ;
								   __fDhToNS( NIL , 0.01  );
								)
					If ( __fDhToNS( aTabCalend[ nPosCalAtu, CALEND_POS_LIM_MARCACAO , 01 ] + aTabCalend[ nPosCalAtu, CALEND_POS_LIM_MARCACAO, 02 ], "D" ) < nSerial )
						aTabCalend[	nPosCalAtu , CALEND_POS_LIM_MARCACAO , 01	] := __fNsToDh( nSerial , "D" )
						aTabCalend[	nPosCalAtu , CALEND_POS_LIM_MARCACAO , 02	] := __fNsToDh( nSerial , "H" )
					EndIf
				ElseIF ( ( nHrsAnt == 0 ) .and. ( nHrsAtu == 0 ) )
					nHorMais	:= DataHora2Val(;
												aTabCalend[ nPosCalAnt , CALEND_POS_DATA ],;
												aTabCalend[ nPosCalAnt , CALEND_POS_HORA ],;
												aTabCalend[	nPosCalAnt , CALEND_POS_LIM_MARCACAO , 01 ],;
												aTabCalend[	nPosCalAnt , CALEND_POS_LIM_MARCACAO , 02 ],;
												"H";
											)
					nHorMeno	:= DataHora2Val(;
												aTabCalend[ nPosCalAtu , CALEND_POS_DATA ],;
												aTabCalend[ nPosCalAtu , CALEND_POS_HORA ],;
												aTabCalend[	nPosCalAtu , CALEND_POS_LIM_MARCACAO , 01 ],;
												aTabCalend[	nPosCalAtu , CALEND_POS_LIM_MARCACAO , 02 ],;
												"H";
											)
					nDifHrs := DataHora2Val(;
												aTabCalend[	nPosCalAnt , CALEND_POS_LIM_MARCACAO , 01 ],;
												aTabCalend[	nPosCalAnt , CALEND_POS_LIM_MARCACAO , 02 ],;
												aTabCalend[	nPosCalAtu , CALEND_POS_LIM_MARCACAO , 01 ],;
												aTabCalend[	nPosCalAtu , CALEND_POS_LIM_MARCACAO , 02 ] ;
											)
					nFator	:= ( nHorMais / ( nHorMais + nHorMeno ) )
					nDifHrs *= nFator
					nDifHrs := __NoRound( nDifHrs , 0 )
					nDifHrs := __Min2Hrs( nDifHrs )
					aMarcId := RetFimTab(	aTabCalend[	nPosCalAnt , CALEND_POS_LIM_MARCACAO , 01 ]	,;	//01 -> Data da Primeira Marcacao
											aTabCalend[	nPosCalAnt , CALEND_POS_LIM_MARCACAO , 02 ]	,;	//02 -> Hora da Primeira Marcacao
											nDifHrs									 				 ;	//03 -> Total de Horas a Trabalhar
										)										
					aTabCalend[	nPosCalAnt , CALEND_POS_LIM_MARCACAO , 01 ] := aMarcId[1]
					aTabCalend[	nPosCalAnt , CALEND_POS_LIM_MARCACAO , 02 ] := aMarcId[2]
					aMarcId := RetFimTab(	aMarcId[1]	,;	//01 -> Data da Primeira Marcacao
											aMarcId[2]	,;	//02 -> Hora da Primeira Marcacao
											0.01		 ;	//03 -> Total de Horas a Trabalhar
										)										
					aTabCalend[	nPosCalAtu , CALEND_POS_LIM_MARCACAO , 01 ] := aMarcId[1]
					aTabCalend[	nPosCalAtu , CALEND_POS_LIM_MARCACAO , 02 ] := aMarcId[2]
				Else
					nSerial := (;
									__fDhToNS(;
												aTabCalend[ nPosCalAtu , CALEND_POS_LIM_MARCACAO , 01 ] ,;
												aTabCalend[ nPosCalAtu , CALEND_POS_LIM_MARCACAO , 02 ]	;
											  ) - ;
								   __fDhToNS( NIL , 0.01  );
								)
					aTabCalend[	nPosCalAnt , CALEND_POS_LIM_MARCACAO , 01 ] := __fNsToDh( nSerial , "D" )
					aTabCalend[	nPosCalAnt , CALEND_POS_LIM_MARCACAO , 02 ] := __fNsToDh( nSerial , "H" )
				EndIF
			EndIF
		EndIF
	Next nLoop
EndIF

Return( NIL )


/*/
зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁTabMarc   Ё Autor Ё Marinaldo de Jesus    Ё Data Ё12/03/2003Ё
цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁRetorna numero de Elementos Permitidos para o Calendario    Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>	                                Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>	                                Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGenerico                                                    Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function TabMarc( cAlias , aMarcs )

Local cCampo  	:= ""
Local cCampoE 	:= ""
Local cCampoS 	:= ""
Local cPrefixo	:= ""
Local nX      	:= 0
Local nCtaMarc	:= 0
Local nCampos 	:= 0

DEFAULT cAlias			:= Alias()
DEFAULT __aLstTbMarc	:= {}

cAlias	:= Upper( AllTrim( cAlias ) )
aMarcs	:= {}

IF ( ( nX := aScan( __aLstTbMarc , { |x| x[1] == cAlias } ) ) > 0 )

	aMarcs		:= aClone( __aLstTbMarc[ nX , 02 ] )
	nCtaMarc	:= __aLstTbMarc[ nX , 03 ]

Else

	cPrefixo := PrefixoCpo( cAlias )

	cCampoE := ( cPrefixo + "_ENTRA" )
	cCampoS := ( cPrefixo + "_SAIDA" )

	nCampos := ( cAlias )->( fCount() )
	For nX := 1 To nCampos
		cCampo := ( cAlias )->( FieldName( nX ) )
		IF ( SubStr( cCampo , 1 , 8 ) == cCampoE ) .or. ( SubStr( cCampo , 1 , 8 ) == cCampoS )
			aAdd( aMarcs , SubStr( cCampo , 9 , 1 ) + SubStr( cCampo , 4 , 1 ) )
		EndIF
	Next nX

	aSort( @aMarcs )
	aAdd( __aLstTbMarc , { cAlias , aClone( aMarcs ) , ( nCtaMarc := Len( aMarcs ) ) } )

EndIF

Return( nCtaMarc )

/*/
зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    Ё GravaSPC Ё Autor Ё Equipe Advanced RH    Ё Data Ё10/04/1996Ё
цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o Ё Grava o resultado no SPC.                                  Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё GravaSPC()                                                 Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ                                                            Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       Ё Generico                                                   Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function GravaSPC(	aResult		,;	//01 -> Array com os Resultados a serem Gravados
					cFil		,;	//02 -> Filial do Funcionario
					cMat		,;	//03 -> Matricula do Funcionario
					cEveMesA	,;	//04 -> Eventos do Mes Anterior que nao poderao ser apagados
					dPerIni		,;	//05 -> Periodo Inicial
					dPerFim		,;	//06 -> Periodo Final
					aAbonosPer	 ;	//07 -> Array com Todos os Abonos no Periodo
				)

Local aSPC			:= {}
Local cFilMat		:= ( cFil + cMat )
Local cAlias		:= "SPC"
Local cAliasQuery	:= cAlias
Local cSvFilAnt		:= cFilAnt
Local nOrder		:= RetOrdem( "SPC" , "PC_FILIAL+PC_MAT+PC_PD+DTOS(PC_DATA)+PC_TPMARCA+PC_CC+PC_DEPTO+PC_POSTO+PC_CODFUNC" )
Local nSvOrder		:= SPC->( IndexOrd() )

Local aAbonos
Local aInfAbonos
Local aPreAbonos
Local aNewAbonos
Local cCodAbono
Local cMsgErr
Local nPos
Local nX
Local nFornX
Local nLenSPC
Local nHrsAbono
Local nHrsPreAbono


#IFDEF TOP

	Local aTamQuantC		:= {}
	Local aTamAbonos		:= {}
	Local cIniData	 		:= ""
	Local cFimData			:= ""
	Local cQuery	 		:= ""
	Local cSvAlias			:= Alias()
	Local cTableName		:= ""
	Local cCpoRecno			:= ""
	Local lQueryOpened		:= .F.

	Static aSpcFields
	Static cQrySpcFields
	Static nSpcFields

	IF !( lExInAs400 )
	
		DEFAULT aSpcFields := ( cAlias )->( dbStruct() )
		DEFAULT nSpcFields := Len( aSpcFields )

		IF ( cQrySpcFields == NIL )
			cQrySpcFields := ""
			For nX := 1 To nSpcFields
				cQrySpcFields += aSpcFields[ nX , 01 ] + ", "
			Next nX
	    EndIF

	EndIF	    

#ENDIF

DEFAULT cEveMesA		:= ""
DEFAULT lRF0ChkTable	:= fVerTabRF0()  	//Verifica a Existencia da Tabela de Pre-Abonos e se a mesm possui registro
DEFAULT __cLimpaMotAbo	:= Space( TamSx3("PC_ABONO")[1] )	//Variavel auxiliar para preencher em branco o campo Motivo do Abono

cFilAnt	:= IF( !Empty( cFil ) , cFil , cFilAnt )

bAsc   := { |x|	x[1] == aResult[ nX , ARESULT_DATA		];
				.and.;
				x[2] == aResult[ nX , ARESULT_EVENTO	];
				.and.;
				x[5] == aResult[ nX , ARESULT_CC		];
				.and.;
				x[6] == aResult[ nX , ARESULT_TPMARCA	];
				.and.;
				x[10] == aResult[ nX , ARESULT_FUNCAO	];		
				.and.;
				x[11] == aResult[ nX , ARESULT_DEPTO 	];	
   				.and.;
				x[12] == aResult[ nX , ARESULT_POSTO 	];	
				.and.;
				x[13] == aResult[ nX , ARESULT_PROCESSO];	
				.and.;
				x[14] == aResult[ nX , ARESULT_PERIODO	];	
				.and.;
				x[15] == aResult[ nX , ARESULT_ROTEIRO	];																				
				.and.;
				x[16] == aResult[ nX , ARESULT_NUM_PAGTO	];	  
		  } 

IF !( nSvOrder == nOrder )
	( cAlias )->( dbSetOrder( nOrder ) )
EndIF


#IFNDEF TOP

	IF SPC->( dbSeek( cFilMat  , .F. ) )

#ELSE

	IF ( lExInAs400 )

		SPC->( dbSeek( cFilMat  , .F. ) )

	Else

		aTamQuantC	:= TamSx3("PC_QUANTC")
		aTamAbonos	:= TamSx3("PC_QTABONO")
		cTableName	:= InitSqlName( cAlias )
		cCpoRecno	:= IF( lExInAs400 , "RRN("+cTableName+")", "R_E_C_N_O_" )
		cIniData	:= Dtos( dPerIni )
		cFimData	:= Dtos( dPerFim )
		cAliasQuery := ( "__Q" + cAliasQuery + "QRY" )
		cQuery := "SELECT "
		cQuery += cQrySpcFields
		cQuery += "R_E_C_N_O_ RECNO"
		cQuery += " FROM "
		cQuery += cTableName
		cQuery += " WHERE "
		cQuery += "PC_FILIAL='"+cFil+"'"
		cQuery += " AND "
		cQuery += "PC_MAT='"+cMat+"'"
		cQuery += " AND "
		cQuery += "( "
		cQuery += 		"PC_DATA>='"+cIniData+"' AND "
		cQuery += 		"PC_DATA<='"+cFimData+"'"
		cQuery += " )"
		cQuery += " AND "
		cQuery += "D_E_L_E_T_=' ' "
		cQuery += "ORDER BY " + SqlOrder( (cAlias)->( IndexKey() ) )
		cQuery := ChangeQuery( cQuery )
		IF ( lQueryOpened := MsOpenDbf(.T.,"TOPCONN",TcGenQry(NIL,NIL,cQuery),cAliasQuery,.F.,.T.) )
			For nX := 1 To nSpcFields
				IF !( aSpcFields[ nX , 02 ] == "C" )
					TcSetField(cAliasQuery,aSpcFields[nX,01],aSpcFields[nX,02],aSpcFields[nX,03],aSpcFields[nX,04])
				EndIF
			Next nX
			cQuery := ""
		Else
			cAliasQuery	:= cAlias
			( cAliasQuery )->( dbSeek( cFilMat  , .F. ) )
		EndIF
	
    EndIF

#ENDIF

		While ( cAliasQuery )->( !Eof() .and. ( PC_FILIAL + PC_MAT ) == cFilMat )
			IF ( cAliasQuery )->( ( PC_DATA >= dPerIni ) .and. ( PC_DATA <= dPerFim ) )
				aAdd( aSPC , Array( 16 ) )
				nLenSPC := Len( aSPC )
				aSPC[ nLenSPC , 01 ] := ( cAliasQuery )->( PC_DATA		)
				aSPC[ nLenSPC , 02 ] := ( cAliasQuery )->( PC_PD		)
				aSPC[ nLenSPC , 03 ] := ( cAliasQuery )->( PC_QUANTC	)
				aSPC[ nLenSPC , 04 ] := ( cAliasQuery )->( PC_QUANTI	)
				aSPC[ nLenSPC , 05 ] := ( cAliasQuery )->( PC_CC		)
				aSPC[ nLenSPC , 06 ] := ( cAliasQuery )->( PC_TPMARCA	)
				#IFNDEF TOP
					aSPC[ nLenSPC , 07 ] := ( cAliasQuery )->( Recno() )
				#ELSE
					IF !( lQueryOpened )
						aSPC[ nLenSPC , 07 ] := ( cAliasQuery )->( Recno() )
					Else
						aSPC[ nLenSPC , 07 ] := ( cAliasQuery )->( RECNO )
					EndIF
				#ENDIF
				aSPC[ nLenSPC , 08 ] := ( cAliasQuery )->( PC_ABONO		)
				aSPC[ nLenSPC , 09 ] := ( cAliasQuery )->( PC_QTABONO 	)
				aSPC[ nLenSPC , 10 ] := ( cAliasQuery )->( PC_CODFUNC	)				
				aSPC[ nLenSPC , 11 ] := ( cAliasQuery )->( PC_DEPTO  	)				
				aSPC[ nLenSPC , 12 ] := ( cAliasQuery )->( PC_POSTO  	)				
				aSPC[ nLenSPC , 13 ] := ( cAliasQuery )->( PC_PROCES	)				
				aSPC[ nLenSPC , 14 ] := ( cAliasQuery )->( PC_PERIODO	)				
				aSPC[ nLenSPC , 15 ] := ( cAliasQuery )->( PC_ROTEIR	)				
				aSPC[ nLenSPC , 16 ] := ( cAliasQuery )->( PC_NUMPAG	)				

			EndIF
			( cAliasQuery )->( dbSkip() )
		End While

#IFNDEF TOP

	EndIF

#ELSE

	IF ( ( lQueryOpened ) .and. ( Select( cAliasQuery ) > 0 ) )
		( cAliasQuery )->( dbCloseArea() )
		dbSelectArea( cSvAlias )
	EndIF	

#ENDIF	

nLenSPC := Len( aSPC )

nFornX := Len( aResult )
For nX := 1 To nFornX

	IF ( ( aResult[ nX , ARESULT_DATA ] >= dPerIni ) .and. ( aResult[ nX , ARESULT_DATA ] <= dPerFim ) )

		nHrsAbono	:= fAbonos( aResult[ nX , ARESULT_DATA 		] , aResult[ nX , ARESULT_EVENTO ] , NIL , @aAbonos , aResult[ nX , ARESULT_TPMARCA ] , ;
								aResult[ nX , ARESULT_CC 		] , aAbonosPer, aResult[ nX , ARESULT_FUNCAO	] ,;
								aResult[ nX , ARESULT_DEPTO 	] , aResult[ nX , ARESULT_POSTO 	] ,;								
								aResult[ nX , ARESULT_PROCESSO	] , aResult[ nX , ARESULT_PERIODO 	] ,;								
								aResult[ nX , ARESULT_ROTEIRO	] , aResult[ nX , ARESULT_NUM_PAGTO	] ;																
								)
		fFiltAbo( aAbonos , { |x| x[ AABONOS_FLAG ] == "P" } , { |x| x[ AABONOS_FLAG ] <> "P" } , @aInfAbonos )
		cCodAbono	:= IF( !Empty( aInfAbonos ) , aInfAbonos[ 01 , AABONOS_CODIGO ] , __cLimpaMotAbo )
        aNewAbonos	:= {}

	    IF ( ( lRF0ChkTable ) .and. Empty( aInfAbonos ) )

			aNewAbonos	:= aResult[ nX , ARESULT_RESULT_APO ]
			nHrsPreAbono := fFiltAbo( aAbonos , { |x| x[ AABONOS_FLAG ] <> "P"} , { |x| x[ AABONOS_FLAG ] == "P"} , @aPreAbonos )
		    
		    nHrsAbono	:= SubHoras( nHrsAbono , nHrsPreAbono )
		    nHrsAbono	:= SomaHoras( nHrsAbono ,  aResult[ nX , ARESULT_NUM_ABO_HRS]) //01 -> Array com as Horas Abonadas para o Evento do Dia (Evento + Tipo Marc + C.Custo)
			
			cCodAbono	:= IF( !Empty( aInfAbonos ) , aInfAbonos[ 01 , AABONOS_CODIGO ] , IF( !Empty( aNewAbonos ) , aNewAbonos[ 01 , AABONOS_CODIGO ] , __cLimpaMotAbo ) )

        EndIF
		
       	cCodAbono	:= IF( !Empty( cCodAbono ) , cCodAbono , __cLimpaMotAbo )
		IF ( ( nPos := aScan( aSPC , bAsc ) ) > 0 )
			IF ( aSPC[ nPos , 7 ] == 0 ) //Eof()
				Loop //Existem Apontamentos Duplicados.... Isso nao Pode Ocorrer....
			EndIF
			IF (;
					( aSPC[ nPos , 3 ] <> aResult[ nX , ARESULT_HORAS ] );
					.or.;
					( aSPC[ nPos , 8 ] <> cCodAbono );
					.or.;
					( aSPC[ nPos , 9 ] <> nHrsAbono );
				)	
				( cAlias )->( dbGoTo( aSPC[ nPos , 7 ] ) )
				#IFNDEF TOP
					IF RecLock( cAlias , .F. , .F. )
						( cAlias )->( PC_QUANTC		)	:= aResult[ nX , ARESULT_HORAS		]
						( cAlias )->( PC_CC			)	:= aResult[ nX , ARESULT_CC			]
						( cAlias )->( PC_TPMARCA	)	:= aResult[ nX , ARESULT_TPMARCA	]
						( cAlias )->( PC_QTABONO	)	:= nHrsAbono
						( cAlias )->( PC_ABONO		)	:= cCodAbono
						( cAlias )->( PC_CODFUNC	)	:= aResult[ nX , ARESULT_FUNCAO		] 
						( cAlias )->( PC_DEPTO		)	:= aResult[ nX , ARESULT_DEPTO		]	
						( cAlias )->( PC_POSTO		)	:= aResult[ nX , ARESULT_POSTO		]				
						( cAlias )->( PC_PROCES		)	:= aResult[ nX , ARESULT_PROCESSO	]										
						( cAlias )->( PC_PERIODO	)	:= aResult[ nX , ARESULT_PERIODO	]				
						( cAlias )->( PC_ROTEIR		)	:= aResult[ nX , ARESULT_ROTEIRO	]	
						( cAlias )->( PC_NUMPAG		)	:= aResult[ nX , ARESULT_NUM_PAGTO	]							
						( cAlias )->( MsUnLock() )
					EndIF	
				#ELSE
					IF ( lExInAs400 )
						IF RecLock( cAlias , .F. , .F. )
							( cAlias )->( PC_QUANTC		)	:= aResult[ nX , ARESULT_HORAS 		]
							( cAlias )->( PC_CC			)	:= aResult[ nX , ARESULT_CC 		]
							( cAlias )->( PC_TPMARCA	)	:= aResult[ nX , ARESULT_TPMARCA	]
							( cAlias )->( PC_QTABONO	)	:= nHrsAbono
							( cAlias )->( PC_ABONO		)	:= cCodAbono  
							( cAlias )->( PC_CODFUNC	)	:= aResult[ nX , ARESULT_FUNCAO		]	  
							( cAlias )->( PC_DEPTO		)	:= aResult[ nX , ARESULT_DEPTO		]	
							( cAlias )->( PC_POSTO		)	:= aResult[ nX , ARESULT_POSTO		]				
							( cAlias )->( PC_PROCES		)	:= aResult[ nX , ARESULT_PROCESSO	]										
							( cAlias )->( PC_PERIODO	)	:= aResult[ nX , ARESULT_PERIODO	]				
							( cAlias )->( PC_ROTEIR		)	:= aResult[ nX , ARESULT_ROTEIRO	]	
							( cAlias )->( PC_NUMPAG		)	:= aResult[ nX , ARESULT_NUM_PAGTO	]														
							( cAlias )->( MsUnLock() )
						EndIF
					Else
						cQuery := "UPDATE "
						IF ( lExInAs400 )
							cQuery += _cDataBase+"/"+cTableName
						Else
							cQuery += cTableName
						EndIF	
						cQuery += " SET "
						cQuery += "PC_QUANTC="		+ Str( aResult[ nX , ARESULT_HORAS ] , aTamQuantC[1] , aTamQuantC[2] )
						cQuery += ", "
						cQuery += "PC_CC='"			+ aResult[ nX , ARESULT_CC ] + "'"
						cQuery += ", "
						cQuery += "PC_TPMARCA='"	+ aResult[ nX , ARESULT_TPMARCA ] + "'"
						cQuery += ", "
						cQuery += "PC_QTABONO="		+ Str( nHrsAbono , aTamAbonos[1] , aTamAbonos[2] )
						cQuery += ", "
						cQuery += "PC_CODFUNC='"	+ aResult[ nX , ARESULT_FUNCAO ] + "'"						
						cQuery += ", " 
						cQuery += "PC_DEPTO='"		+ aResult[ nX , ARESULT_DEPTO ] + "'"						
						cQuery += ", "
						cQuery += "PC_POSTO='"		+ aResult[ nX , ARESULT_POSTO ] + "'"						
						cQuery += ", "
						cQuery += "PC_PROCES='"		+ aResult[ nX , ARESULT_PROCESSO] + "'"						
						cQuery += ", "
						cQuery += "PC_PERIODO='"	+ aResult[ nX , ARESULT_PERIODO ] + "'"						
						cQuery += ", "
						cQuery += "PC_ROTEIR ='"	+ aResult[ nX , ARESULT_ROTEIRO ] + "'"						
						cQuery += ", "
						cQuery += "PC_NUMPAG='"		+ aResult[ nX , ARESULT_NUM_PAGTO] + "'"						
						cQuery += ", "																																				
						cQuery += "PC_ABONO='"		+ cCodAbono + "'"
						cQuery += " WHERE " 
						cQuery += cCpoRecno + "=" + Str( aSPC[ nPos , 7 ] , 10 , 0 )
						TcSqlExec( cQuery )
						cQuery := ""
					EndIF
				#ENDIF
			EndIF
			aSPC[ nPos , 7 ] := 0
		Else
			IF RecLock( cAlias , .T. , .F. )
				( cAlias )->( PC_FILIAL		)	:= cFil
				( cAlias )->( PC_MAT		)	:= cMat
				( cAlias )->( PC_DATA		)	:= aResult[ nX , ARESULT_DATA		]
				( cAlias )->( PC_PD			)	:= aResult[ nX , ARESULT_EVENTO 	]
				( cAlias )->( PC_QUANTC		)	:= aResult[ nX , ARESULT_HORAS  	]
				( cAlias )->( PC_CC			)	:= aResult[ nX , ARESULT_CC			]
				( cAlias )->( PC_TPMARCA	)	:= aResult[ nX , ARESULT_TPMARCA	]
				( cAlias )->( PC_QTABONO	)	:= nHrsAbono
				( cAlias )->( PC_ABONO		)	:= cCodAbono                        
				( cAlias )->( PC_CODFUNC	)	:= aResult[ nX , ARESULT_FUNCAO		]				
				( cAlias )->( PC_DEPTO		)	:= aResult[ nX , ARESULT_DEPTO		]	
				( cAlias )->( PC_POSTO		)	:= aResult[ nX , ARESULT_POSTO		]				
				( cAlias )->( PC_PROCES		)	:= aResult[ nX , ARESULT_PROCESSO	]										
				( cAlias )->( PC_PERIODO	)	:= aResult[ nX , ARESULT_PERIODO	]				
				( cAlias )->( PC_ROTEIR		)	:= aResult[ nX , ARESULT_ROTEIRO	]	
				( cAlias )->( PC_NUMPAG		)	:= aResult[ nX , ARESULT_NUM_PAGTO	]				
				( cAlias )->( MsUnLock() )
			EndIF
		EndIF

		DelAbo( aPreAbonos )

		IF !Empty( aNewAbonos )

			GravaAbo( 	cFil								,;	//01 -> Filial do Funcionario
						cMat								,;	//02 -> Matricula do Funcionario
						aNewAbonos				    		,;	//03 -> Horarios do Apontamento Abonado
						aResult[ nX , ARESULT_DATA		]	,;	//04 -> Data da Geracao
						aResult[ nX , ARESULT_EVENTO	]	,;	//05 -> Codigo do Evento
						aResult[ nX , ARESULT_CC		]	,;	//06 -> Centro de Custo a ser Gravado
						aResult[ nX , ARESULT_TPMARCA	]	,;	//07 -> Tipo de Marcacao   
						aResult[ nX , ARESULT_FUNCAO	]	,;	//08 -> Funcao a ser Gravado
						aResult[ nX , ARESULT_DEPTO		]	,;	//09 -> Depto a ser Gravado						
						aResult[ nX , ARESULT_POSTO 	]	,;	//10 -> Posto a ser Gravado
						aResult[ nX , ARESULT_PROCESSO	]	,;	//11 -> Processo a ser Gravado										
						aResult[ nX , ARESULT_PERIODO	]	,;	//12 -> Periodo a ser Gravado
						aResult[ nX , ARESULT_ROTEIRO	]	,;	//13 -> Roteiro a ser Gravado											
						aResult[ nX , ARESULT_NUM_PAGTO	]	;	//14 -> Numero de Pagamamento (Semana)a ser Gravado
					) 
		EndIF
		
	EndIF

Next nX

For nX := 1 To nLenSPC
	IF (;
			( aSPC[ nX , 7 ] > 0 );
			.and.;
			( aSPC[ nX , 4 ] == 0 );
			.and.;
			!( aSPC[ nX , 02 ] $ cEveMesA );
		 )
		( cAlias )->( dbGoTo( aSPC[ nX , 7 ] ) )
		IF RecLock( cAlias , .F. , .F. )
			IF !( cAlias )->( FkDelete( @cMsgErr ) )
				( cAlias )->( RollBackDelTran( cMsgErr ) )
			EndIF
			( cAlias )->( MsUnLock() )
		EndIF
		fAbonos( ;
					aSPC[ nX , 01 ] ,;
					aSPC[ nX , 2 ] 	,;
					NIL 			,;
					@aAbonos 		,;
					aSPC[ nX , 6 ] 	,;
					aSPC[ nX , 5 ] 	,;
					aAbonosPer		,;
					aSPC[ nX , 10 ] ,;    
					aSPC[ nX , 11 ] ,;
					aSPC[ nX , 12 ] ,;
					aSPC[ nX , 13 ] ,;
					aSPC[ nX , 14 ] ,;
					aSPC[ nX , 15 ] ,;
					aSPC[ nX , 16 ] ;
				)
		fFiltAbo( aAbonos , { |x| x[ AABONOS_FLAG ] <> "P" } , { |x| x[ AABONOS_FLAG ] == "P" } , @aPreAbonos )
		DelAbo( aPreAbonos )
	EndIF
Next nX

IF !( nSvOrder == nOrder )
	( cAlias )->( dbSetOrder( nSvOrder ) )
EndIF

cFilAnt	:= cSvFilAnt

Return( NIL )

/*/
зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁGravaAbo  Ё Autor Ё Mauricio MR           Ё Data Ё10/05/2004Ё
цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁGrava o Abonos no SPK.		                                Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>                                   Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>                                   Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGravacao dos Pre-Abonos no SPK                              Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function GravaAbo(	cFil						,;	//01 -> Filial do Funcionario
							cMat						,;	//02 -> Matricula do Funcionario
							aHorarios				    ,;	//03 -> Horarios do Apontamento Abonado
							dDtGer						,;	//04 -> Data da Geracao
							cEvento						,;	//05 -> Codigo do Evento
							cCusto   					,;	//06 -> Centro de Custo a ser Gravado
							cTpMarc						,;	//07 -> Tipo de Marcacao  
							cFuncao						,;   //08 -> Funcao
							cDepto						,;   //09 -> Depto 
							cPosto 						,;   //10 -> Posto  
							cProcesso					,;   //11 -> Processo					
							cPeriodo					,;   //12 -> Periodo
							cRoteiro					,;   //13 -> Roteiro
							cNumPagto					;   //14 -> NumPagto
						 ) 

Local lPkTpMarca	:= ( Type( "SPK->PK_TPMARCA" ) == "C" )

Local nLoop
Local nLoops

nLoops := Len( aHorarios )
For nLoop := 1 To nLoops
	
	IF SPK->( RecLock( "SPK" , .T. , .F. ) )
		SPK->PK_FILIAL	:= cFil
		SPK->PK_MAT		:= cMat
		SPK->PK_CODABO	:= aHorarios[ nLoop , AABONOS_CODIGO ] 
		SPK->PK_CODEVE	:= cEvento
	    SPK->PK_DATA	:= dDtGer
		SPK->PK_CC		:= cCusto
		SPK->PK_HRSABO	:= aHorarios[ nLoop , AABONOS_HORAS_ABO	] 
		SPK->PK_HORINI	:= aHorarios[ nLoop , AABONOS_HORAS_INI	]
		SPK->PK_HORFIM	:= aHorarios[ nLoop , AABONOS_HORAS_FIM	] 
		IF ( lPkTpMarca )
			SPK->PK_TPMARCA	:= cTpMarc
		EndIF
		SPK->PK_FLAG		:= "P"
		SPK->PK_CODFUNC		:= cFuncao
		SPK->PK_DEPTO   	:= cDepto
		SPK->PK_POSTO  		:= cPosto		
		SPK->PK_PROCES  	:= cProcesso
		SPK->PK_PERIODO 	:= cPeriodo
		SPK->PK_ROTEIR		:= cRoteiro 
		SPK->PK_NUMPAG		:= cNumPagto
	SPK->( MsUnLock() )
	EndIF        

	/*
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Altera Flag da Faixa de Pre-Abono							  Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды*/	
	RF0->( dbgoto( aHorarios[ nLoop , ELEMENTOS_AABONOS + 1 ] ) )
	
	If	RF0->RF0_ABONA <> 'S'
		IF RecLock( 'RF0' , .F. , .F. )
		   RF0->RF0_ABONA := 'S' 
		   RF0->( MsUnLock() )	
        Endif
	Endif 

Next nLoop

aHorarios := {}

Return( NIL )

/*/
зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    Ё DelAbo   Ё Autor Ё Mauricio MR           Ё Data Ё13/05/2004Ё
цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o Ё Deleta Abonos no SPK.		                                Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё Vide Parametros                                            Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ                                                            Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       Ё Generico                                                   Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function DelAbo( aPreAbonos ) //01 -> Array de Abonos Pre-Abonados

Local cMsgErr
Local nLoop
Local nLoops

DEFAULT aPreAbonos := {}

nLoops := Len( aPreAbonos )
For nLoop := 1 To nLoops
	SPK->( dbGoto( aPreAbonos[ nLoop , AABONOS_RECNO ] ) )
	IF ( SPK->( Recno() ) == aPreAbonos[ nLoop , AABONOS_RECNO ] )
		IF RecLock( "SPK" , .F. , .F. )
			IF !SPK->( FkDelete( @cMsgErr ) )
				SPK->( RollBackDelTran( cMsgErr ) )
			EndIF
			SPK->( MsUnLock() )
		EndIF
	EndIF	
Next nLoop

aPreAbonos := {}

Return( NIL )




/*/
зддддддддддбддддддддддддддддбдддддбдддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁfFiltAbo		ЁAutorЁMauricio MR		  Ё Data Ё12/05/2004Ё
цддддддддддеддддддддддддддддадддддадддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁFiltra Abonos											    Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGenerico                  	                                Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function fFiltAbo( aAbonos , bSkip , bCondRet , aRetorno )

Local nHrsAbo	:= 0

Local nLoop
Local nLoops

DEFAULT aAbonos		:= {}
DEFAULT bSkip 		:= { || .F. }
DEFAULT bCondRet 	:= { || .T. }

aRetorno := {}

nLoops := Len( aAbonos )
For nLoop := 1 To nLoops
    IF Eval( bSkip , aAbonos[ nLoop ] )
       Loop
    EndIF
	IF Eval( bCondRet , aAbonos[ nLoop ] )
	   aAdd( aRetorno , aAbonos[ nLoop ] )
	EndIF
	nHrsAbo := SomaHoras( nHrsAbo , aAbonos[ nLoop , AABONOS_HORAS_ABO	] )
Next nLoop

Return( nHrsAbo )

/*/
зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁPerAponta Ё Autor Ё Equipe Advanced RH    Ё Data Ё14/04/1997Ё
цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁRetorna a data inicio e fim para apontamento das marcacoes. Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
Ё          ЁObs.:Quando a Data Inicial e Maior que a Data Final a fun┤└oЁ
Ё          Ёir═ considerar que o apontamento ┌ feito de um mes para   ouЁ
Ё          Ёtro, e quando a Data Final for maior que a Data Inicial,   aЁ
Ё          Ёfun┤└o ir═ considerar que o apontamento ┌ feito no m┬s.     Ё
Ё          ЁCaso a dData nao for passado assume a dDataBase do Sistema. Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGenerico                                                    Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function PerAponta(		dPerIni			,;	//Data Inicial passada como referencia
						dPerFim 		,;	//Data Final   passada como referencia
						dData			,;	//Data Base
						lShowHelp		,;	//Mostrar o Help
						cFil			,;	//Filial para GetMv
						lNewPer			,;	//Se eh para gerar um novo periodo
						lPerCompleto	,;	//Se o periodo esta preenchido com AAAAMMDD/AAAAMMDD ou AAAAMMDDAAAAMMDD (por referencia)
						lIncDate		,;	//Se Quando lNewPer Incrementa Data, caso contrario Decrementa
						lUseParamPer	 ;	//Se quando periodo completo considerar dPerIni e dPerFim passados como parametro
				 )

Local cSvFilAnt			:= cFilAnt
Local lPerNotOk			:= .F.

Local cDiaIni
Local cDiaFim
Local cMesIni
Local cMesFim
Local cAnoIni
Local cAnoFim
Local cPerAponta
Local nDiaIni
Local nDiaFim

DEFAULT dPerIni			:= Ctod("//")
DEFAULT dPerFim			:= Ctod("//")
DEFAULT dData			:= dDataBase
DEFAULT lShowHelp		:= .T.
DEFAULT cFil			:= cSvFilAnt
DEFAULT lNewPer			:= .F.
DEFAULT lIncDate		:= .T.
DEFAULT lUseParamPer	:= .F.

lPerCompleto		:= .F.

cFilAnt := IF( !Empty( cFil ) , cFil , cFilAnt )

Begin Sequence

	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	ЁVerifica o Modo de Acesso do Cadastro de Periodos de ApontamenЁ
	Ёto															   Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	IF !( lPerNotOk := CheckModSPO() )
		Break
	EndIF

	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	ЁVerifica se o Conteudo do  MV_PAPONTA esta OK  			   Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	IF ( lPerNotOk := !PapontaOk( @cPerAponta , @nDiaIni , @nDiaFim , cFil ) )
		Break
	EndIF
	
	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Para Possibilitar que o periodo seja definido pelo    usuarioЁ
	Ё Este devera ser preenchido com a String de Data da   SeguinteЁ
	Ё te forma AAAAMMDD/AAAAMMDD ou AAAAMMDDAAAAMMDD. Onde AAAA corЁ
	Ё responde ao ano com 4 digitos, MM ao mes com 2 digitos e   DDЁ
	Ё corresponde ao dia com 2 Digitos. A barra (/) separadora   seЁ
	Ё servira apenas para facilitar a leitura do periodo pelo  usuaЁ
	Ё rio. Essa forma de Preenchimento do Parametro ira   facilitarЁ
	Ё as Empresas que reduzem ou aumentam o periodo em  determinadoЁ
	Ё mes. Obs.: Essa forma de preenchimento devera ser   utilizadaЁ
	Ё apenas para os meses em que o periodo for diferente do padraoЁ
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	IF ( lPerCompleto := PerCompleto( @cPerAponta ) )

		/*/
		здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		ЁQuando Nao Considerar as Datas Passadas Redefine-as   confermeЁ
		Ёconteudo de MV_PAPONTA										   Ё
		юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		IF !( lUseParamPer )
			dPerIni := Stod( Left(	cPerAponta , 08 ) )
			dPerFim := Stod( Right(	cPerAponta , 08 ) )
		EndIF	

		/*/
		здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		ЁQuando for um novo Periodo Incrementa ou Decrementa		   Ё
		юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		IF ( lNewPer )
			/*/
			здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			ЁApura o Novo periodo baseado no numero de dias do periodo anteЁ
			Ёrior														   Ё
			юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			IF ( lIncDate )
				PonIncDate( @dPerIni , @dPerFim )
			Else
				PonDecDate( @dPerIni , @dPerFim )
			EndIF	
		EndIF

		Break

	EndIF

	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	ЁA Principio, Inicio ┌ no mes corrente.						   Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	IF ( nDiaIni > nDiaFim )

		cMesIni := Month2Str( dData )
		cAnoIni := Year2Str( dData )
		cDiaIni := Day2Str( Min( nDiaIni , f_UltDia( Ctod( "01/" + cMesIni + "/" + cAnoIni , "DDMMYYYY" ) ) ) )
		dPerIni := Ctod( cDiaIni + "/" + cMesIni + "/" + cAnoIni , "DDMMYYYY" )

		/*/
		здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		ЁAcrescenta um dia ao Periodo Inicial se Inicio do Periodo for Ё
		Ё>= 29 e Mes Fev.											   Ё
		юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		IF (;
				(;
					( Month( dPerIni ) == 2 );
					.or.;
					( ( Month( dPerIni ) - 1 )  == 2 );
				);
				.and.;
				( nDiaIni >= 29 );
			)	
			IF ( Day( dPerIni ) != nDiaIni )
				dPerIni++
			EndIF
		EndIF

		/*/
		здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		ЁSe Inicio for Apos Data-Base, Retrocede 1 mes.				   Ё
		юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		IF ( dPerIni > dData )
			cMesIni := Month2Str( IF( Month( dData ) - 1 == 0 , 12 , Month( dData ) -1 ) )
			cAnoIni := Year2Str( IF( cMesIni == "12" , Year(dData) - 1 , Year( dData ) ) )
			cDiaIni := Day2Str( Min( nDiaIni , f_UltDia( Ctod( "01/" + cMesIni + "/" + cAnoIni , "DDMMYYYY" ) ) ) )
			dPerIni := Ctod( cDiaIni + "/" + cMesIni + "/" + cAnoIni , "DDMMYYYY" )
		EndIF

		/*/
		здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		ЁA Principio, Data Final ┌ 1 mes apos a data Inicial.		   Ё
		юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		cMesFim := Month2Str( IF( Month( dPerIni ) + 1 == 13 , 1 , Month( dPerIni ) + 1 ) )
		cAnoFim := Year2Str( IF( cMesFim == "01" , Year( dPerIni ) + 1 , Year( dPerIni ) ) )
		cDiaFim := Day2Str( Min( nDiaFim , f_UltDia( Ctod( "01/" + cMesFim + "/" + cAnoFim , "DDMMYYYY" ) ) ) )
		dPerFim := Ctod( cDiaFim + "/" + cMesFim + "/" + cAnoFim , "DDMMYYYY" )

		/*/
		здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		ЁA Data Final ┌ no mesmo mes da Data Inicio.				   Ё
		юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		IF ( ( dPerFim - dPerIni ) > 50 )
			cDiaFim := Day2Str( Min( nDiaFim , f_UltDia( Ctod( "01/" + cMesIni + "/" + cAnoIni , "DDMMYYYY" ) ) ) )
			dPerFim := Ctod( cDiaFim + "/" + cMesIni + "/" + cAnoIni , "DDMMYYYY" )
		EndIF

		/*/
		здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		ЁAcrescenta um dia ao Periodo Inicial quando o dia deste    forЁ
		Ёigual ao do Periodo Final									   Ё
		юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		IF (;
				(;
					( Day( dPerIni ) == Day( dPerFim ) );
					.or.;
					( Day( dPerIni ) < Day( dPerFim ) );
		    	);
		    	.and.;
		    	( AnoMes( dPerIni ) != AnoMes( dPerFim ) );
		   ) 
			dPerIni++
		EndIF

		Break

	EndIF

	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	ЁA Principio, Final ┌ no mes corrente.						   Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	cMesFim := Month2Str( dData )
	cAnoFim := Year2Str( dData )
	cDiaFim := Day2Str( Min( nDiaFim , f_UltDia( Ctod( "01/" + cMesFim + "/" + cAnoFim , "DDMMYYYY" ) ) ) )
	dPerFim := Ctod( cDiaFim + "/" + cMesFim + "/" + cAnoFim , "DDMMYYYY" )

	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	ЁSe Final for Antes da Data-Base, Avan┤a 1 mes.				   Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	IF ( dPerFim < dData )
		cMesFim := Month2Str( IF( Month( dData ) + 1 == 13 , 1 , Month( dData ) +1 ) )
		cAnoFim := Year2Str( IF( cMesFim == "01" , Year( dData ) + 1 , Year( dData ) ) )
		cDiaFim := Day2Str( Min( nDiaFim , f_UltDia( Ctod( "01/" + cMesFim +"/" + cAnoFim , "DDMMYYYY" ) ) ) )
		dPerFim := Ctod( cDiaFim + "/" + cMesFim + "/" + cAnoFim , "DDMMYYYY" )
	EndIF

	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	ЁA Principio, Data Inicial ┌ 1 mes anterior a data Final.	   Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	cMesIni := Month2Str( IF( Month( dPerFim ) - 1 == 0 , 12 , Month( dPerFim ) -1 ) )
	cAnoIni := Year2Str( IF( cMesIni == "12" , Year(dPerFim) - 1 , Year( dPerFim ) ) )
	cDiaIni := Day2Str( Min( nDiaIni , f_UltDia( Ctod( "01/" + cMesIni + "/" + cAnoIni , "DDMMYYYY" ) ) ) )
	dPerIni := Ctod( cDiaIni + "/" + cMesIni + "/" + cAnoIni , "DDMMYYYY" )

	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	ЁA Data Inicial ┌ no mesmo mes da Data Final.				   Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	IF ( ( dPerFim - dPerIni ) > 50 ) 
		cDiaIni := Day2Str( Min( nDiaIni , f_UltDia( Ctod( "01/" + cMesFim + "/" + cAnoFim , "DDMMYYYY" ) ) ) )
		dPerIni := Ctod( cDiaIni + "/" + cMesFim + "/" + cAnoFim , "DDMMYYYY" )
	EndIF

End Sequence

/*/
здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Se ocorreu alguma Inconsistencia Verifica se Deve Mostrar   oЁ
Ё Help														   Ё
юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
IF ( lPerNotOk )
	IF ( lShowHelp ) .AND. !IsInCallStack("GPEA240")
		Help("" , 1 , "PERNCAD" )
	EndIF	
EndIF

/*/
здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Restaura cFilAnt											   Ё
юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
cFilAnt := cSvFilAnt
	
Return( !( lPerNotOk ) )

 
/*/
зддддддддддбддддддддддддддддбдддддбдддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁGetPerAtu		ЁAutorЁMarinaldo de Jesus Ё Data Ё25/08/2003Ё
цддддддддддеддддддддддддддддадддддадддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁDisponibilizar Dialogo para Alteracao do Periodo 			Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>     								Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁPona080Calend												Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
Ё Retorno  ЁNIL															Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ< Vide Parametros Formais >									Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function GetPerAtu( dDataIni , dDataFim , oDataIni , oDataFim )

GetPonMesDat( @dDataIni , @dDataFim  , xFilial("SRA") )
IF ( ValType( oDataIni ) == "O" )
	oDataIni:Refresh()
EndIF	
IF ( ValType( oDataFim ) == "O" )
	oDataFim:Refresh()
EndIF	

Return( NIL )

/*/
зддддддддддбддддддддддддддддбдддддбдддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁGetPerPrev		ЁAutorЁMarinaldo de Jesus Ё Data Ё25/08/2003Ё
цддддддддддеддддддддддддддддадддддадддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁDisponibilizar Dialogo para Alteracao do Periodo 			Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>     								Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁPona080Calend												Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
Ё Retorno  ЁNIL															Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ< Vide Parametros Formais >									Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function GetPerPrev(	dDataIni	,;
						dDataFim	,;
						oDataIni	,;
						oDataFim	,;
						lShowHelp	,;
						lGetNewPer	,;
						lIncDate	,;
						lUseParamPer ;
					)

Local dData := ( dDataIni - 1 )

Local nFimPer
Local nDay

DEFAULT lShowHelp		:= .T.
DEFAULT lGetNewPer		:= .T.
DEFAULT lIncDate		:= .F.
DEFAULT lUseParamPer	:= .T.

IF PapontaOk( NIL , NIL , @nFimPer )
	IF ( nFimPer <> NIL )
		nDay := Day( dData )
		IF ( nDay > nFimPer )
			While ( Day( dData ) <> nFimPer )
				--dData	
			End While
		EndIF	
	EndIF
EndIF

PerAponta(	@dDataIni 		,;	//Data Inicial passada como referencia
			@dDataFim 		,;	//Data Final   passada como referencia
			dData			,;	//Data Base
			lShowHelp		,;	//Mostrar o Help
			xFilial("SRA")	,;	//Filial para GetMv
			lGetNewPer		,;	//Se eh para gerar um novo periodo
			NIL				,;	//Se o periodo esta preenchido com AAAAMMDD/AAAAMMDD ou AAAAMMDDAAAAMMDD (por referencia)
			lIncDate		,;  //Se Quando lNewPer Incrementa Data, caso contrario Decrementa
			lUseParamPer  	 ;	//Se quando periodo completo considerar dPerIni e dPerFim passados como parametro
		  )

IF ( ValType( oDataIni ) == "O" )
	oDataIni:Refresh()
EndIF	
IF ( ValType( oDataFim ) == "O" )
	oDataFim:Refresh()
EndIF	

Return( NIL )

/*/
зддддддддддбддддддддддддддддбдддддбдддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁGetPerNext		ЁAutorЁMarinaldo de Jesus Ё Data Ё25/08/2003Ё
цддддддддддеддддддддддддддддадддддадддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁDisponibilizar Dialogo para Alteracao do Periodo 			Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>     								Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁPona080Calend												Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
Ё Retorno  ЁNIL															Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ< Vide Parametros Formais >									Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function GetPerNext(	dDataIni 	,;
						dDataFim 	,;
						oDataIni 	,;
						oDataFim 	,;
						lShowHelp	,;
						lGetNewPer	,;
						lIncDate	,;
						lUseParamPer ;
					)

Local dData := ( dDataFim + 1 )

Local nIniPer
Local nDay

DEFAULT lShowHelp		:= .T.
DEFAULT lGetNewPer		:= .T.
DEFAULT lIncDate		:= .T.
DEFAULT lUseParamPer    := .T.

IF PapontaOk( NIL , @nIniPer )
	IF ( nIniPer <> NIL )
		nDay := Day( dData )
		IF ( nDay < nIniPer )
			While ( Day( dData ) <> nIniPer )
				++dData	
			End While
		EndIF	
	EndIF
EndIF

PerAponta(	@dDataIni 		,;	//Data Inicial passada como referencia
			@dDataFim 		,;	//Data Final   passada como referencia
			dData			,;	//Data Base
			lShowHelp		,;	//Mostrar o Help
			xFilial("SRA")	,;	//Filial para GetMv
			lGetNewPer		,;	//Se eh para gerar um novo periodo 
			NIL				,;	//Se o periodo esta preenchido com AAAAMMDD/AAAAMMDD ou AAAAMMDDAAAAMMDD (por referencia)
			lIncDate		,;  //Se Quando lNewPer Incrementa Data, caso contrario Decrementa
			lUseParamPer 	 ;	//Se quando periodo completo considerar dPerIni e dPerFim passados como parametro
		  )

IF ( ValType( oDataIni ) == "O" )
	oDataIni:Refresh()
EndIF	
IF ( ValType( oDataFim ) == "O" )
	oDataFim:Refresh()
EndIF	

Return( NIL )

/*/
зддддддддддбддддддддддддддддбдддддбдддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁGetPerSPO		ЁAutorЁMarinaldo de Jesus Ё Data Ё29/08/2003Ё
цддддддддддеддддддддддддддддадддддадддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁRetorna consulta SXB ao RPO                      			Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>     								Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁPona080Calend												Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
Ё Retorno  ЁNIL															Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ< Vide Parametros Formais >									Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function GetPerSPO( dDataIni , dDataFim , oDataIni , oDataFim )

IF ( PerApoConPad() )
	dDataIni := SPO->PO_DATAINI
	dDataFim := SPO->PO_DATAFIM
	IF ( ValType( oDataIni ) == "O" )
		oDataIni:Refresh()
	EndIF	
	IF ( ValType( oDataFim ) == "O" )
		oDataFim:Refresh()
	EndIF	
EndIF

Return( NIL )

/*/
зддддддддддбдддддддддддбдддддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁGetPaponta Ё Autor Ё Marinaldo de Jesus   Ё Data Ё30/06/2004Ё
цддддддддддедддддддддддадддддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁObtem o Conteudo do parametro MV_PAPONTA                    Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGenerico                                                    Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function GetPaponta( cFil )

Local cSvFilAnt		:= cFilAnt

Local cPerAponta

DEFAULT cFil		:= cFilAnt

cFilAnt		:= IF( !Empty( cFil ) , cFil , cFilAnt )
cPerAponta	:= AllTrim( StrTran( GetMv( "MV_PAPONTA" , NIL , "" ) , " " , "" ) )
cFilAnt		:= cSvFilAnt

Return( cPerAponta )

/*/
зддддддддддбдддддддддддбдддддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁPapontaOk  Ё Autor Ё Marinaldo de Jesus   Ё Data Ё30/06/2004Ё
цддддддддддедддддддддддадддддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁVerifica se o parametro MV_PAPONTA este com o Conteudo OK   Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGenerico                                                    Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function PapontaOk( cPerAponta , nIniPer , nFimPer , cFil )

Local lPapontaOk := .T.

DEFAULT cPerAponta := GetPaponta( cFil )

Begin Sequence

	IF !( lPapontaOk := !Empty( cPerAponta ) )
		Break
	EndIF
	
	IF PerCompleto( @cPerAponta )
		Break
	EndIF

	nIniPer	:= Val( Left( cPerAponta , 2 ) )
	IF !( lPapontaOk := ( nIniPer > 0 ) )
		Break
	EndIF

	nFimPer := Val( Right( cPerAponta , 2 ) )
	IF !( lPapontaOk := ( nFimPer > 0 ) )
		Break
	EndIF

	IF !( lPapontaOk := ( nIniPer <= 31 ) )
		Break
	EndIF

	IF !( lPapontaOk := ( nFimPer <= 31 ) )
		Break
	EndIF

	IF !( lPapontaOk := ( nIniPer <> nFimPer ) )
		Break
	EndIF

End Sequence

Return( lPapontaOk )

/*/
зддддддддддбдддддддддддбдддддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁPerCompletoЁ Autor Ё Marinaldo de Jesus   Ё Data Ё30/06/2004Ё
цддддддддддедддддддддддадддддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁVerifica se o parametro MV_PAPONTA este Preenchido com o conЁ
Ё          Ёteudo equivalente a "AAAAMMDD/AAAAMMDD"                     Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGenerico                                                    Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function PerCompleto( cPerAponta , cFil )
DEFAULT cPerAponta := GetPaponta( cFil )
Return( ( ( Len( cPerAponta ) == 17 ) .or. ( Len( cPerAponta ) == 16 ) ) )

/*/
зддддддддддбдддддддддддбдддддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁGetPonMes  Ё Autor Ё Marinaldo de Jesus   Ё Data Ё01/07/2004Ё
цддддддддддедддддддддддадддддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁObtem o Conteudo do parametro MV_PONMES                     Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGenerico                                                    Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function GetPonMes( cFil )

Local cSvFilAnt		:= cFilAnt

Local cPonMes

DEFAULT cFil		:= cFilAnt

cFilAnt	:= IF( !Empty( cFil ) , cFil , cFilAnt )
cPonMes	:= AllTrim( StrTran( GetMv( "MV_PONMES" , NIL , "" ) , " " , "" ) )
cFilAnt	:= cSvFilAnt

Return( cPonMes )

/*/
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤┘o    ЁDescAbono Ё Autor Ё Equipe Advanced RH    Ё Data Ё11/03/2002Ё╠╠
╠╠цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤┘o Ё Verifica a existencia do codigo de abono e retorna a Desc. Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁUso       Ё Generico                                                   Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ/*/
Function DescAbono( cCodigo , cTipoRet , cCampo , cFil , nSize )

Local uRet			:= ""

Local nPoscCampo
Local nPosQtdAbo
Local nPosQtdCal
Local cCpoQtdAbo
Local cCpoQtdCal

DEFAULT cTipoRet	:= ""
DEFAULT cCodigo 	:= ""
DEFAULT cCampo		:= ""
DEFAULT nSize		:= GetSx3Cache( "P6_DESC" , "X3_TAMANHO" )

cTipoRet	:= Upper( AllTrim( cTipoRet ) )
cCampo		:= Upper( AllTrim( cCampo ) )
cFil		:= xFilial( "SP6" , cFil )
cCodigo		:= IF( Empty( cCodigo ) .and. cTipoRet == "L" , &(ReadVar()) , cCodigo )

IF SP6->( MsSeek( cFil + cCodigo ) )
	uRet 		:= IF( ( cTipoRet == "L" ) , .T. , Padr( SP6->P6_DESC , nSize ) )
	cCpoQtdAbo	:= IF( cCampo == "PC_DESCABO" , "PC_QTABONO" ,"PH_QTABONO" )
	cCpoQtdCal	:= IF( cCampo == "PC_DESCABO" , "PC_QUANTC"  ,"PH_QUANTC"  )
	IF IsInGetDados( { cCampo , cCpoQtdAbo , cCpoQtdCal } )
	    IF ( ( nPoscCampo := GdFieldPos( cCampo ) ) > 0 )
			aCols[n,nPoscCampo] := SP6->P6_DESC
    	EndIF
		IF ( ( cTipoRet == "L" ) .and. ( cCampo $ "PC_DESCABO*PH_DESCABO" ) )
			nPosQtdAbo := GdFieldPos( cCpoQtdAbo )
			nPosQtdCal := GdFieldPos( cCpoQtdCal )
			IF nPosQtdAbo > 0 .and. nPosQtdCal > 0
				IF aCols[n,nPosQtdAbo] == 0
					aCols[n,nPosQtdAbo] := aCols[n,nPosQtdCal] // Calculado
				EndIF
			EndIF
		EndIF
	EndIF
Else
	uRet := IF( ( cTipoRet == "L" ) , .F. , Space( nSize ) )
EndIF

Return( uRet )

/*/
зддддддддддбддддддддбдддддбддддддддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁfCargaIdЁAutorЁMauro     1a. Versao  	   Ё Data Ё18/12/1996Ё
Ё          Ё        ЁAutorЁMarinaldo 2a. Versao  	   Ё Data Ё04/08/2004Ё
цддддддддддеддддддддадддддаддддддддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁCarregar Array com os Identificadores e Verbas               Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>                                    Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>                                    Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGenerico                                                     Ё
юддддддддддаддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function fCargaId( aCodigos , cFil , lStop )

Local lRet			:= .T.
Local lShowHelp		:= .T.

Local cFilSX5
Local cFilSP9
Local nOrderSP9
Local nSvSp9Ord
Local nPosEmpFil
Local nLenaCod

aCodigos			:= {}

DEFAULT cFil		:= xFilial( "SP9" , IF( Type( "SRA->RA_FILIAL" ) == "C" , SRA->RA_FILIAL , NIL ) )
DEFAULT lStop		:= .T.

Begin Sequence

	DEFAULT aCargaIdCache	:= {}
	
	cFilSP9	:= xFilial( "SP9" , cFil )
	IF ( ( nPosEmpFil := aScan( aCargaIdCache , { |x| ( x[1] == FWCODEMP("SP9") ) .and. ( x[2] == cFilSp9 ) } ) ) > 0 )
		Break
	EndIF

	cFilSX5	:= xFilial( "SX5" , cFil )
	IF !( lRet := SX5->( MsSeek( cFilSX5 + "20" , .F. ) ) )
		IF ( lStop )
			lShowHelp := .F.
			Help( "" , 1 , "EVENTNCAD" )
		EndIF
		Break
	EndIF

	nOrderSP9	:= RetOrdem( "SP9" , "P9_FILIAL+P9_IDPON+P9_CODIGO" )
	nSvSp9Ord	:= SP9->( IndexOrd() )
	IF !( nOrderSP9 == nSvSp9Ord )
		SP9->( dbSetOrder( nOrderSP9 ) )
	EndIF
	SP9->( dbSeek( cFilSP9 , .F. ) )
	While SP9->( !Eof() .and. ( P9_FILIAL == cFilSP9 ) )
		IF SP9->( !Empty( P9_IDPON ) .or. !Empty( P9_CODFOL ) )
			aAdd( aCodigos , Array( 04 ) )
			nLenaCod := Len( aCodigos )
			aCodigos[nLenaCod,01] := SP9->P9_CODIGO
			aCodigos[nLenaCod,02] := SP9->P9_IDPON
			aCodigos[nLenaCod,03] := SP9->P9_DESCDSR
			aCodigos[nLenaCod,04] := SP9->P9_CODFOL
		EndIF
		SP9->(dbSkip())
	End While
	SP9->( dbSetOrder( nSvSp9Ord ) )
	aAdd( aCargaIdCache , { FWCODEMP("SP9") , cFilSP9 , aClone( aCodigos ) } )
	nPosEmpFil	:= Len( aCargaIdCache )
	aCodigos	:= {}

End Sequence

IF !Empty( nPosEmpFil )
	aCodigos := aClone( aCargaIdCache[ nPosEmpFil , 3 ] )
EndIF

IF !( lRet := !Empty( aCodigos ) )
	IF ( ( lStop ) .and. ( lShowHelp ) )
		Help( " ",1,"EVENTNCAD" )
	EndIF	
EndIF

Return( lRet )

/*/
зддддддддддбддддддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁRstfCargaId   Ё Autor ЁMarinaldo de Jesus     Ё Data Ё04/08/2004Ё
цддддддддддеддддддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁReinicializa as Statics em fCargaId()                       	Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ																Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁNIL																Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function RstfCargaId()

aCargaIdCache := {}

Return( NIL )

/*/
зддддддддддбддддддддддддддбдддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o	   ЁGetEveIdPon   ЁAutorЁ Marinaldo de Jesus  Ё Data Ё15/08/2002Ё
цддддддддддеддддддддддддддадддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁRetorna Array com Identificadores de Ponto x Eventos de acorЁ
Ё          Ёdo com o SX5                                				Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais> 									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais> 									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso	   ЁGenerico 												    Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function GetEveIdPon( aCodigos , cFil , aLogFile, lChkEve )

Local aEveIds		:= {}
Local aArea			:= GetArea()
Local aAreaSX5		:= SX5->( GetArea() )
Local aLastLog		:= {}
Local aSX5			:= {}
Local cTabId		:= "20"
Local cChaveId		:= ""
Local cIdPon		:= "" 
Local nEveId 		:= 0
Local nPosId		:= 0
Local nEvesSX5		:= 0
Local nTotIdPonto	:= 0
Local nI			:= 0
Local nLenSX5		:= 0

DEFAULT aCodigos	:= {}
DEFAULT cFil		:= cFilSX5
DEFAULT aLogfile	:= {}  
DEFAULT lChkEve		:= .F.

IF Empty( aCodigos )
	aCodigos := {}
	fCargaId( @aCodigos , cFil , .F. )
EndIF

aLastLog := aClone( aLogFile )

cFil 		:= xFilial( "SX5" , cFil )
cChaveId	:= ( cFil + cTabId )

IF SX5->( dbSeek( cChaveId , .F. ) ) 
	aSX5 := FWGetSX5("20")

	If !Empty(aSX5)
		nLenSX5 := Len(aSX5)	

	For nI := 1 To nLenSX5
	If aSX5[nI,1] == cFil
		aAdd( aEveIds , Array( 3 ) )
		cIdPon						:= Upper( AllTrim( aSX5[nI,3] ) )
		aEveIds[ ++nEveId , 01 ]	:= cIdPon
		IF ( nPosId := aScan( aCodigos , { |x| Upper( AllTrim( x[2] ) ) == cIdPon } ) ) == 0
			aEveIds[ nEveId , 02 ]	:= ""
		Else
			aEveIds[ nEveId , 02 ]	:= aCodigos[ nPosId , 01 ]
		EndIF
		aEveIds[ nEveId , 03 ]		:= SX5->( x5Descri() )   
		IF lChkEve
			IF Empty( aEveIds[ nEveId , 02 ] ) 
				aAdd( aLogFile , ( STR0117 + aEveIds[ nEveId , 01 ] + " - " + aEveIds[ nEveId , 03 ] ) ) //'Nao Foi Encontrado Evento para o Id. de Ponto: '
			EndIF
		EndIF
	EndIf
	Next
EndIf
EndIF               

nTotIdPonto:= 46
	
nEvesSX5 := Len( aEveIds )
IF ( !( ArrayCompare( aLastLog , aLogFile ) ) .or. ( nEvesSX5 < nTotIdPonto ) .or. ( nEvesSX5 > nTotIdPonto ) )
	aAdd( aLogFile , "" )
	aAdd( aLogFile , STR0118 )									//'- O Apontamento nao foi Efetuado porque Foram Encontradas Inconsitencias nos Eventos. ' 
	IF ( ( nEvesSX5 < nTotIdPonto ) .or. ( nEvesSX5 > nTotIdPonto ) )
		IF ( nEvesSX5 < nTotIdPonto )
			aAdd( aLogFile , STR0180 )							//'- Estao faltado codigos de Identificadores de Ponto na Tabela 20 do Configurador. '
 	 	ElseIF ( nEvesSX5 > nTotIdPonto )
			aAdd( aLogFile , STR0183 )							//'- Existem Identificadores do Ponto Duplicados na Tabela 20 do Condigurador.'
		EndIF
 	 	aAdd( aLogFile , STR0181 + StrZero( nTotIdPonto , 2 ) )			//'- Numero de Identificadores requeridos: '
 	 	aAdd( aLogFile , STR0182 + StrZero( nEvesSX5 , 2 ) )	//'- Numero de Identificadores Existentes: '
	Else
		IF lChkEve
			aAdd( aLogFile , STR0119 )								//'- Esta Faltando Vincular os Identificadores de Ponto Acima a Eventos. '
		EndIF
	EndIF
EndIF

( RestArea( aAreaSX5 ) , RestArea( aArea ) )

Return( aClone( aEveIds ) )  

/*/
зддддддддддбддддддддддддддбдддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o	   ЁObtemEveNoDeleЁAutorЁ Marinaldo de Jesus  Ё Data Ё15/08/2002Ё
цддддддддддеддддддддддддддадддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁObtem Eventos que nao Podem ser Deletados pela GravaSPC()   Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais> 									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais> 									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso	   ЁGenerico 												    Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function ObtemEveNoDele( aCodigos )

Local cEvesNoDele	:= ""
Local nPos			:= 0

DEFAULT aCodigos := {}

//-- Evento de Faltas/Antrasos Meses Anteriores Autorizado
IF ( nPos := aScan( aCodigos , { |x| x[2] == "022A" } ) ) > 0
	cEvesNoDele += aCodigos[ nPos , 01 ]
EndIF

//-- Evento de Faltas/Antrasos Meses Anteriores Nao Autorizado
IF ( nPos := aScan( aCodigos , { |x| x[2] == "021N" } ) )  > 0
	cEvesNoDele += ( "/" + aCodigos[ nPos , 01 ] )
EndIF

//-- Evento de DSR Ultima Semana Periodo Anterior
IF ( nPos := aScan( aCodigos , { |x| x[2] == "036N" } ) ) > 0
	cEvesNoDele += ( "/" + aCodigos[ nPos , 01 ] )
EndIF

Return( cEvesNoDele )    


/*/
зддддддддддбдддддддддддддбддддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁObtemIdPon   ЁAutor ЁMauricio MR          Ё Data Ё25/03/2005Ё
цддддддддддедддддддддддддаддддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁVerifica a Existencia do Id.Ponto e Evento correspondente   Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё< Vide Parametros Formais >								  	Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ< Vide Parametros Formais >								  	Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function ObtemIdPon( aEvesIds, cId, lOnlyId )
Local lRet	:= .F.
Local nPos	:= 0   

DEFAULT lOnlyId:= .F.

If lOnlyId
	lRet:= !Empty( (nPos:= Ascan(aEvesIds,{|aId| SUBSTR(aId[1],1,4) == cId  } ) ))
Else
	lRet:= !Empty( (nPos:= Ascan(aEvesIds,{|aId| SUBSTR(aId[1],1,4) == cId .AND. !Empty(aId[2]) } ) ))
Endif
Return lRet
                
/*/
эээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤┘o    ЁfTotaliza Ё Autor Ё Mauro                 Ё Data Ё 10/12/96 Ё╠╠
╠╠цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤┘o Ё Totalizar as Verbas do SPC                                 Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁUso       Ё Generico                                                   Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ/*/
Function fTotaliza( aTotaliza , cFil , cMat , bAcessaSPC )

Local cFilMat		:= ""
Local dDataIni		:= Ctod("//")
Local dDataFim		:= dDataIni

DEFAULT cFil 		:= SRA->RA_FILIAL
DEFAULT cMat 		:= SRA->RA_MAT
DEFAULT aTotaliza	:= {}
DEFAULT bAcessaSPC	:= { || .T. }

IF PerAponta( @dDataIni , @dDataFim , NIL , NIL , cFil )

	cFilMat	:= ( cFil + cMat )
	IF SPC->( dbSeek( cFilMat , .F.  ) )
	
		While SPC->( !Eof() .and. cFilMat == PC_FILIAL + PC_MAT )
	
			IF SPC->( PC_DATA < dDataIni .or. PC_DATA > dDataFim )
				SPC->( dbSkip() )
				Loop
			EndIF
	
			IF !Eval( bAcessaSPC )
				SPC->( dbSkip() )
				Loop
			EndIF
	
			IF SPC->( ( nPos := aScan( aTotaliza , { |x| x[1] = IF( !Empty( PC_PDI ) , PC_PDI , PC_PD ) } ) ) > 0 )
				aTotaliza[nPos,2] := SomaHoras( aTotaliza[nPos,2] , SPC->( IF( PC_QUANTI > 0 , 0 , SubHoras( PC_QUANTC , PC_QTABONO ) ) ) )
				aTotaliza[nPos,3] := SomaHoras( aTotaliza[nPos,3] , SPC->PC_QUANTI  )
				aTotaliza[nPos,4] := SomaHoras( aTotaliza[nPos,4] , SPC->PC_QTABONO )
			Else
				SPC->( aAdd( aTotaliza , { IF( !Empty( PC_PDI ) , PC_PDI , PC_PD ) , IF( PC_QUANTI > 0 , 0 , SubHoras( PC_QUANTC , PC_QTABONO ) ) , PC_QUANTI , PC_QTABONO } ) )
			EndIF
			
			SPC->( dbSkip() )

		End While
	
	EndIF

EndIF
	
Return( NIL )

/*/
зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁfTabTurno Ё Autor Ё Equipe Advanced RH    Ё Data Ё18/11/1997Ё
цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o Ё Preenche um Array com a Tabela de Hor═rios dos Turnos      Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё fTabTurno( aTabTno , cFil )                                Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁPar┐metrosЁ aTabTno = Array a ser alimentado com as Tabelas            Ё
Ё          Ё cFil    = Filial para Pesquisa                             Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   Ё lRet                                                       Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       Ё Gen┌rico                                                   Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function fTabTurno( aTabTno , cFil , lExecQryTop , bCond )

Local lRet		:= .T.
Local nSR6Rec	:= SR6->( Recno() )

DEFAULT aTabTno	:= {}

IF ( lRet := xRetModo("SR6","SPJ") )
	IF cFil == NIL
		SR6->( dbGoTop() )
	Else
		cFil := xFilial( "SR6" , cFil )
		SR6->( MsSeek( cFil , .T. ) )
	EndIF
	While SR6->( !Eof() .and. IF( cFil == NIL , .T. , cFil <= R6_FILIAL  ) )
		fTabPadrao( @aTabTno , SR6->R6_FILIAL , SR6->R6_TURNO , lExecQryTop , bCond )
		SR6->( dbSkip() )
	End While
	IF !( lRet := !Empty( aTabTno ) )
		Help(' ',1,'TPADNCAD')
	EndIF
EndIF

IF ( SR6->( Recno() ) != nSR6Rec )
	SR6->( dbGoto( nSR6Rec ) )
EndIF

Return( lRet )

/*/
эээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤└o    ЁfTrocaTno Ё Autor ЁEquipe Advanced RH     Ё Data Ё03/09/1998Ё╠╠
╠╠цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤└o ЁAdiciona os Turnos pelos quais o funcionario passou durante Ё╠╠
╠╠Ё          Ёo periodo.                                                  Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁSintaxe   ЁfTrocaTno(dPerIni,dPerFim,aTurnos,aSPF)		              Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁPar┐metrosЁdPerIni = Periodo Inicial a ser pesquizado                  Ё╠╠
╠╠Ё          ЁdPerFim = Periodo Final a ser pesquizado                    Ё╠╠
╠╠Ё          ЁaTurnos = Array a ser alimentado com as trocas de turno     Ё╠╠
╠╠Ё          ЁaSPF    = Array com as Trocas de Turno do SPF               Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁUso       Ё Gen┌rico                                                   Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ/*/
Function fTrocaTno( dPerIni , dPerFim , aTurnos , aSPF , cSeq , lAddTrcIniPer )

Local aTnoAnt		:= {}
Local aTnoProx		:= {}
Local cFil			:= SRA->RA_FILIAL
Local cMat			:= SRA->RA_MAT
Local cFilMat		:= ( cFil + cMat )
Local cRegra		:= SRA->RA_REGRA
Local cTurno		:= SRA->RA_TNOTRAB
Local cSeqTurn		:= SRA->RA_SEQTURN
Local cAlias		:= "SPF"
Local cAliasQuery	:= cAlias
Local dData     	:= Ctod("//")
Local lTrocaTno		:= .F.
Local lVazio		:= .T.
Local nX        	:= 0
Local nFornX		:= 0
Local nY        	:= 0
Local nFornY		:= 0

#IFDEF TOP

	Local cIniData	 		:= ""
	Local cFimData			:= ""
	Local cQuery	 		:= ""
	Local cPrefixo			:= ( PrefixoCpo( cAlias ) + "_" )
	Local cSvAlias			:= Alias()
	Local lQueryOpened		:= .F.

	Static aSpfFields
	Static cQrySpfFields
	Static nSpfFields

	IF !( lExInAs400 )

		DEFAULT aSpfFields := ( cAlias )->( dbStruct() )
		DEFAULT nSpfFields := Len( aSpfFields )
	
		IF ( cQrySpfFields == NIL )
			cQrySpfFields := ""
			For nX := 1 To nSpfFields
				cQrySpfFields += aSpfFields[ nX , 01 ] + ", "
			Next nX
		EndIF

	EndIF
	
#ENDIF

DEFAULT dPerIni 		:= Ctod("//")
DEFAULT dPerFim			:= Ctod("//")
DEFAULT aTurnos			:= {}
DEFAULT aSPF			:= {}
DEFAULT lAddTrcIniPer	:= .T.

IF Empty( dPerIni ) .or. Empty( dPerFim )
	PerAponta( @dPerIni , @dPerFim , NIL , NIL , cFil )
EndIF
aTurnos := {}


IF  ExistBlock( "PONAPO11" )     
	aSPF:=ExecBlock( "PONAPO11" , .F. , .F. , { dPerIni , dPerFim, cSeq } ) 
EndIF

IF Empty( aSPF ) 

	#IFDEF TOP

		IF ( lExInAs400 )
			( cAliasQuery )->( dbSeek( cFilMat , .F. ) )
		Else
			cIniData	:= Dtos( dPerIni )
			cFimData	:= Dtos( dPerFim )
			cAliasQuery := ( "__Q" + cAliasQuery + "QRY" )
			cQuery := "SELECT "
			cQuery += cQrySpfFields
			cQuery += "R_E_C_N_O_ RECNO "
			cQuery += " FROM "
			cQuery += InitSqlName( cAlias )
			cQuery += " WHERE "
			cQuery += cPrefixo + "FILIAL='"+cFil+"'"
			cQuery += " AND "
			cQuery += cPrefixo + "MAT='"+cMat+"'"
			cQuery += " AND "
			cQuery += cPrefixo + "DATA>='"+cIniData+"'"
			cQuery += " AND "
			cQuery += cPrefixo + "DATA<='"+cFimData+"'"
			cQuery += " AND "
			cQuery += "D_E_L_E_T_=' ' "
			cQuery += "ORDER BY " + SqlOrder( (cAlias)->( IndexKey() ) )
			cQuery := ChangeQuery( cQuery )
			IF ( lQueryOpened := MsOpenDbf(.T.,"TOPCONN",TcGenQry(NIL,NIL,cQuery),cAliasQuery,.F.,.T.) )
				For nX := 1 To nSpfFields
					IF !( aSpfFields[ nX , 02 ] == "C" )
						TcSetField(cAliasQuery,aSpfFields[nX,01],aSpfFields[nX,02],aSpfFields[nX,03],aSpfFields[nX,04])
					EndIF
				Next nX
			Else
				cAliasQuery := cAlias
				( cAliasQuery )->( dbSeek( cFilMat , .F. ) )
			EndIF	
		EndIF
	#ELSE
		IF ( cAliasQuery )->( dbSeek( cFilMat , .F. ) )
	#ENDIF
			While ( cAliasQuery )->( !Eof() .and. cFilMat == PF_FILIAL + PF_MAT )
				#IFNDEF TOP
					IF ( cAliasQuery )->( PF_DATA < dPerIni .or. PF_DATA > dPerFim )
						If ( cAliasQuery )->( PF_DATA < dPerIni )
							//Ao final sobrara apenas a primeira troca anterior a data inicial
							aTnoAnt := {}
							( cAliasQuery )->( aAdd(	aTnoAnt , {	PF_TURNODE									,;	//01 - Turno De
																	PF_TURNOPA									,;	//02 - Turno Para
																	PF_DATA										,;	//03 - Data
																	PF_SEQUEDE									,;	//04 - Sequencia De
																	PF_SEQUEPA									,;	//05 - Sequencia Para
																	IF(!Empty(PF_REGRADE),PF_REGRADE,cRegra)	,;	//06 - Regra De
																	IF(!Empty(PF_REGRAPA),PF_REGRAPA,cRegra)	 ;	//07 - Regra Para
								      		   					};
							    					);
								  			 )
						EndIf
						If ( cAliasQuery )->( PF_DATA > dPerFim )
							( cAliasQuery )->( aAdd(	aTnoProx, {	PF_TURNODE									,;	//01 - Turno De
																	PF_TURNOPA									,;	//02 - Turno Para
																	PF_DATA										,;	//03 - Data
																	PF_SEQUEDE									,;	//04 - Sequencia De
																	PF_SEQUEPA									,;	//05 - Sequencia Para
																	IF(!Empty(PF_REGRADE),PF_REGRADE,cRegra)	,;	//06 - Regra De
																	IF(!Empty(PF_REGRAPA),PF_REGRAPA,cRegra)	 ;	//07 - Regra Para
								      		   					};
							    					);
								  			 )
							//Adicionara somente a primeira troca apos a data final do periodo
							Exit
						EndIf
						( cAliasQuery )->( dbSkip() )
						Loop
					EndIF
				#ELSE
					IF !( lQueryOpened )
						IF ( cAliasQuery )->( PF_DATA < dPerIni .or. PF_DATA > dPerFim )
							If ( cAliasQuery )->( PF_DATA < dPerIni )
								//Ao final sobrara apenas a primeira troca anterior a data inicial
								aTnoAnt := {}							
								( cAliasQuery )->( aAdd(	aTnoAnt , {	PF_TURNODE									,;	//01 - Turno De
																		PF_TURNOPA									,;	//02 - Turno Para
																		PF_DATA										,;	//03 - Data
																		PF_SEQUEDE									,;	//04 - Sequencia De
																		PF_SEQUEPA									,;	//05 - Sequencia Para
																		IF(!Empty(PF_REGRADE),PF_REGRADE,cRegra)	,;	//06 - Regra De
																		IF(!Empty(PF_REGRAPA),PF_REGRAPA,cRegra)	 ;	//07 - Regra Para
									      		   					};
								    					);
									  			 )
							EndIf
							If ( cAliasQuery )->( PF_DATA > dPerFim )
								( cAliasQuery )->( aAdd(	aTnoProx, {	PF_TURNODE									,;	//01 - Turno De
																		PF_TURNOPA									,;	//02 - Turno Para
																		PF_DATA										,;	//03 - Data
																		PF_SEQUEDE									,;	//04 - Sequencia De
																		PF_SEQUEPA									,;	//05 - Sequencia Para
																		IF(!Empty(PF_REGRADE),PF_REGRADE,cRegra)	,;	//06 - Regra De
																		IF(!Empty(PF_REGRAPA),PF_REGRAPA,cRegra)	 ;	//07 - Regra Para
									      		   					};
								    					);
									  			 )
								//Adicionara somente a primeira troca apos a data final do periodo
								Exit
							EndIf
							( cAliasQuery )->( dbSkip() )
							Loop
						EndIF
					EndIF
				#ENDIF
				( cAliasQuery )->( aAdd(	aSPF , {	PF_TURNODE									,;	//01 - Turno De
														PF_TURNOPA									,;	//02 - Turno Para
														PF_DATA										,;	//03 - Data
														PF_SEQUEDE									,;	//04 - Sequencia De
														PF_SEQUEPA									,;	//05 - Sequencia Para
														IF(!Empty(PF_REGRADE),PF_REGRADE,cRegra)	,;	//06 - Regra De
														IF(!Empty(PF_REGRAPA),PF_REGRAPA,cRegra)	 ;	//07 - Regra Para
					      		   					};
				    					);
					  			 )
				lVazio := .F.
				( cAliasQuery )->( dbSkip() )
			End While
	#IFNDEF TOP
		EndIF
	#ELSE
		IF ( ( lQueryOpened ) .and. ( Select( cAliasQuery ) > 0 ) )
			( cAliasQuery )->( dbCloseArea() )
			dbSelectArea( cSvAlias )
		EndIF	
	#ENDIF	
EndIF
	
	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	| Caso nao encontre nenhuma troca de turno para o periodo, 	   |
	| procura uma troca na primeira data maior que dPerFim.        |
	| Se encontrar monta aTurnos com os dados desta troca, caso    |
	| contrario ira assumir dados da SRA - Leandro 14/05/08        |
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
If lVazio
	#IFDEF TOP
			cAliasQuery := ( "__Q" + cAliasQuery + "QRY" )
			cQuery := "SELECT "
			cQuery += cQrySpfFields
			cQuery += "R_E_C_N_O_ RECNO "
			cQuery += " FROM "
			cQuery += InitSqlName( cAlias )
			cQuery += " WHERE "
			cQuery += cPrefixo + "FILIAL='"+cFil+"'"
			cQuery += " AND "
			cQuery += cPrefixo + "MAT='"+cMat+"'"
			cQuery += " AND "
			cQuery += "D_E_L_E_T_=' '"
			cQuery += " AND ( "
			cQuery += cPrefixo + "DATA>'"+cFimData+"'"
			cQuery += " OR "
			cQuery += cPrefixo + "DATA<'"+cIniData+"' ) "
			cQuery += "ORDER BY " + SqlOrder( (cAlias)->( IndexKey() ) )
			cQuery := ChangeQuery( cQuery )
			IF ( lQueryOpened := MsOpenDbf(.T.,"TOPCONN",TcGenQry(NIL,NIL,cQuery),cAliasQuery,.F.,.T.) )
				For nX := 1 To nSpfFields
					IF !( aSpfFields[ nX , 02 ] == "C" )
						TcSetField(cAliasQuery,aSpfFields[nX,01],aSpfFields[nX,02],aSpfFields[nX,03],aSpfFields[nX,04])
					EndIF
				Next nX
			Else
				cAliasQuery := cAlias
				( cAliasQuery )->( dbSeek( cFilMat , .F. ) )
			EndIF
	#ELSE
		IF ( cAliasQuery )->( dbSeek( cFilMat , .F. ) )
	#ENDIF
           	/*/
			здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			ЁGrava as trocas menores e maiores que o periodo informado				   Ё
			юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			While ( cAliasQuery )->( !Eof() .and. cFilMat == PF_FILIAL + PF_MAT )
						If ( cAliasQuery )->( PF_DATA < dPerIni )
							//Ao final sobrara apenas a primeira troca anterior a data inicial
							aTnoAnt := {}
							( cAliasQuery )->( aAdd(	aTnoAnt , {	PF_TURNODE									,;	//01 - Turno De
																	PF_TURNOPA									,;	//02 - Turno Para
																	PF_DATA										,;	//03 - Data
																	PF_SEQUEDE									,;	//04 - Sequencia De
																	PF_SEQUEPA									,;	//05 - Sequencia Para
																	IF(!Empty(PF_REGRADE),PF_REGRADE,cRegra)	,;	//06 - Regra De
																	IF(!Empty(PF_REGRAPA),PF_REGRAPA,cRegra)	 ;	//07 - Regra Para
								      		   					};
							    					);
								  			 )
						EndIf
						If ( cAliasQuery )->( PF_DATA > dPerFim )
							( cAliasQuery )->( aAdd(	aTnoProx, {	PF_TURNODE									,;	//01 - Turno De
																	PF_TURNOPA									,;	//02 - Turno Para
																	PF_DATA										,;	//03 - Data
																	PF_SEQUEDE									,;	//04 - Sequencia De
																	PF_SEQUEPA									,;	//05 - Sequencia Para
																	IF(!Empty(PF_REGRADE),PF_REGRADE,cRegra)	,;	//06 - Regra De
																	IF(!Empty(PF_REGRAPA),PF_REGRAPA,cRegra)	 ;	//07 - Regra Para
								      		   					};
							    					);
								  			 )
							//Adicionara somente a primeira troca apos a data final do periodo
							Exit
						EndIf
						( cAliasQuery )->( dbSkip() )
			End While
	#IFNDEF TOP
		EndIF
	#ELSE
		IF ( ( lQueryOpened ) .and. ( Select( cAliasQuery ) > 0 ) )
			( cAliasQuery )->( dbCloseArea() )
			dbSelectArea( cSvAlias )
		EndIF	
	#ENDIF
    
	//Adiciona o ultimo turno anterior ao periodo selecionado
	If !Empty(aTnoAnt)
		aAdd( aSPF , aTnoAnt[1] )
		lVazio := .F.
	EndIf
	//Adiciona o primeiro turno posterior ao periodo selecionado
	If !Empty(aTnoProx)
		aAdd( aSPF , aTnoProx[1] )
		lVazio := .F.
	EndIf
EndIf
IF ( Len(aSPF) > 0 )
	aSort( @aSPF , NIL , NIL , { |x,y| ( x[3] < y[3] ) } )
	nFornX := ( dPerFim - dPerIni )
	For nX := 0 To nFornX
		dData := dPerIni + nX
		nFornY := Len(aSPF)
		For nY := 1 To nFornY
			IF aSPF[nY,3] >= dData .And. nY < Len(aSPF) .And. dData <= aSPF[nY+1,3] .Or. ;
				aSPF[nY,3] >= dData .And. nY == Len(aSPF) .Or. ;
				( nX == 0 .And. nFornY == 1 .And. lVazio ) //Caso nao exista troca para o periodo informado, gravara a troca anterior/posterior encontrada
				//-- Inclui o 1o. "TURNO DE" como 1o. do periodo
				//-- qdo nao houver troca no primeiro dia do periodo
				IF Len(aTurnos)==0 .And. aSPF[nY,3] # dPerIni .and. lAddTrcIniPer
					//Se a Data da troca de turno for maior que a data inicial do periodo, grava as informacoes DE
					If aSPF[nY,3] > dPerIni
						aAdd(aTurnos, {	aSPF[nY, 1],;								//01 - Turno De
										dPerIni,;									//02 - Data
										IF(Empty(aSPF[nY,4]),cSeqTurn,aSPF[nY,4]),;	//03 - Sequencia De
										0,;											//04 - Numero Serial
										IF(Empty(aSPF[nY,6]),cRegra,aSPF[nY,6]),;	//05 - Regra De
										.T.;										//06 - Troca Turno
								      };
							 )
					//Se a Data da troca de turno for menor que a data inicial do periodo, grava as informacoes PARA
					Else
						aAdd(aTurnos, {	aSPF[nY, 2],;								//01 - Turno Para
										dPerIni,;									//02 - Data
										IF(Empty(aSPF[nY,5]),cSeqTurn,aSPF[nY,5]),;	//03 - Sequencia Para
										0,;											//04 - Numero Serial
										IF(Empty(aSPF[nY,7]),cRegra,aSPF[nY,7]),;	//05 - Regra Para
										.T.;										//06 - Troca Turno
								      };
							 )
					EndIf
				EndIF
				//-- Inclui os "TURNO PARA" do periodo
				IF aScan(aTurnos, {|x| x[1] == aSPf[nY,2] .And. x[2] == aSPF[nY,3]}) == 0
					aAdd(aTurnos, {	aSPF[nY, 2],;								//01 - Turno Para
									aSPF[nY, 3],;								//02 - Data
									IF(Empty(aSPF[nY,5]),cSeqTurn,aSPF[nY,5]),;	//03 - Sequencia Para
									0,;											//04 - Numero Serial
									IF(Empty(aSPF[nY,7]),cRegra,aSPF[nY,7]),;	//05 - Regra Para
									.T.,;										//06 - Troca Turno
								  };
						 )
				EndIF
				Exit
			EndIF
		Next nY
	Next nX
EndIF

IF !( lTrocaTno := !Empty( aTurnos ) )
	DEFAULT cSeq := cSeqTurn
	IF ( lAddTrcIniPer )
		If ( Len(aSPF) > 0 )
			aAdd( aTurnos , { aSPF[ Len(aSPF), 02 ] , aSPF[ Len(aSPF), 03 ] , aSPF[ Len(aSPF), 05 ] , 0 , aSPF[ Len(aSPF), 07 ], .F. } )			
		Else
			aAdd( aTurnos , { cTurno , dPerIni , cSeq , 0 , cRegra, .F. } )
		EndIf
	EndIF	
EndIF

Return( lTrocaTno )

/*/
эээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤└o    ЁfDepuraSP2Ё Autor Ё Fernando Joly Siquini Ё Data Ё 27.08.98 Ё╠╠
╠╠цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤└o Ё Filtra SP2 deixando somente excecoes do Per║odo            Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁSintaxe   Ё fDepuraSP2(cArqInd, dPerIni, dPerFim)                      Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁParametrosЁ cArqInd = Nome do Arquivo de Indice (passar com "@")       Ё╠╠
╠╠Ё          Ё dPerIni = Inicio do Periodo de Depura┤└o                   Ё╠╠
╠╠Ё          Ё dPerFim = Final do Periodo de Depura┤└o                    Ё╠╠
╠╠Ё          Ё lShowDialog = Mostrar Dialogo na IndRegua                  Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁUso       Ё Generico                                                   Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ/*/
Function fDepuraSP2( cArqInd , dPerIni , dPerFim , lShowDialog )

Local cChave		:= "P2_FILIAL+P2_MAT+P2_CC+P2_TURNO+DtoS(P2_DATA)+P2_TIPODIA"
Local cPerIni		:= ""
Local cPerFim		:= ""
Local cQuery		:= ""

DEFAULT cArqInd		:= ""
DEFAULT dPerIni		:= dDataBase
DEFAULT dPerFim		:= dDataBase
DEFAULT lShowDialog := .T.

IF !Empty( cArqInd )
	RetIndex( "SP2" )
	SP2->( dbSetOrder( RetOrdem( "SP2" , cChave ) ) )
	fErase( cArqInd + OrdBagExt() )
	cArqInd := ""
EndIF

cPerIni	:= Dtos( dPerIni )
cPerFim := Dtos( dPerFim )

cArqInd	:= CriaTrab("",.F.)
cQuery  += '(((DtoS(P2_DATAATE)>="'+cPerIni+'".AND.DtoS(P2_DATAATE)<="'+cPerFim+'").OR.'
cQuery  += '(DtoS(P2_DATAATE)>="'+cPerFim+'".AND.DtoS(P2_DATA)<="'+cPerIni+'")).OR.'
cQuery  += '(DtoS(P2_DATA)>="'+cPerIni+'".AND.DtoS(P2_DATA)<="'+cPerFim+'"))'

IndRegua( "SP2" , cArqInd , cChave ,, cQuery , STR0056 , lShowDialog ) // 'Depurando Excecoes...'

Return( NIL )

/*/
эээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤└o    Ё fTabSP4  Ё Autor Ё Aldo Marini Junior    Ё Data Ё 15/10/99 Ё╠╠
╠╠цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤└o Ё Carrega tabela de Eventos do Tipo de Hora Extra            Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁUso       Ё Generico                                                   Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ/*/
Function fTabSP4(aCodAut)

Local nLenCodAut := 0

//-- Preenche o Array aCodAut com as Horas Extras
SP4->( dbGoTop() )
While SP4->( !Eof() )
	IF (;
			SP4->(;
					aScan(aCodAut, {|x| x[1] == P4_FILIAL .and. ;
									  	x[2] == P4_TURNO  .and. ;
									  	x[3] == P4_CODAUT		;
									};
					  	) == 0;
				  );
		)		  	  	
		aAdd( aCodAut , Array( 04 ) )
		nLenCodAut := Len( aCodAut )
		aCodAut[nLenCodAut,01] := SP4->P4_FILIAL
		aCodAut[nLenCodAut,02] := SP4->P4_TURNO
		aCodAut[nLenCodAut,03] := SP4->P4_CODAUT
		aCodAut[nLenCodAut,04] := "A"
	EndIF
	IF (;
			SP4->(;
					aScan(aCodAut, {|x| x[1] == P4_FILIAL .and. ;
								  		x[2] == P4_TURNO  .and. ;
								  		x[3] == P4_CODNAUT		;
								  	};
						  ) == 0;
				);
		)										  
		aAdd( aCodAut , Array( 04 ) )
		nLenCodAut := Len( aCodAut )
		aCodAut[nLenCodAut,01] := SP4->P4_FILIAL
		aCodAut[nLenCodAut,02] := SP4->P4_TURNO
		aCodAut[nLenCodAut,03] := SP4->P4_CODNAUT
		aCodAut[nLenCodAut,04] := "N"
	EndIF
	SP4->( dbSkip() )
End While

aCodAut := aSort( @aCodAut , NIL , NIL , { |x,y| x[2]+x[3] > y[2]+y[3] } )

Return( NIL )

/*/
эээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤┘o    ЁfBscEven  Ё Autor Ё Aldo Marini Junior    Ё Data Ё 28.12.98 Ё╠╠
╠╠цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤┘o Ё Retorna % ou Efetua validacao do Evento                    Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁSintaxe   Ё fBscEven(cEvento,nTipo,nTpEvento)                          Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁParametrosЁ cEvento  = Codigo do Evento a ser pesquisado               Ё╠╠
╠╠Ё          Ё nTipo    = 1-Percentual Evento 2-Validacao do Evento       Ё╠╠
╠╠Ё          Ё nTpEvento= 1-Autorizado 2-Nao Autorizado 3-Ambos           Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁUso       Ё Generico                                                   Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠*/
Function fBscEven( cEvento , nTipo , nTpEvento )

Local nPerc		:= 100
Local cCodFol	:= ""
Local lRet		:= .T.

IF nTipo == 1
	IF ( nPerc := PosSP9(cEvento,SRA->RA_FILIAL,"P9_BHPERC") ) <= 0
		nPerc := 100
	EndIF
Else
	cCodFol := PosSP9(cEvento,SRA->RA_FILIAL,"P9_CODFOL")
	IF ( Empty(cCodFol) .and. nTpEvento == 1 ) .or. ( !Empty(cCodFol) .and. nTpEvento == 2 )
		lRet := .F.
	EndIF
EndIF

Return( IF( nTipo == 1 , nPerc ,  lRet ) )

/*/
зддддддддддбддддддддддддбдддддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁfValidMarc	Ё Autor ЁEquipe Advanced RH    Ё Data Ё11/07/2001Ё
цддддддддддеддддддддддддадддддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁValidar a multipla escolha do tipo de marcacao 1E/1S ..		 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   ЁfValidMarc( l1Elem , cTipo )								 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ                                                     		 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   Ё.T.                                                  	     Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁObserva┤└oЁ                                                      	     Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁApontamento                                                  Ё
юддддддддддаддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function fValidMarc( l1Elem , cTipo )

Local cAlias := ""
Local cPref_ := ""
Local cConte := ""
Local aMarc		:= {}
Local aStruct	:= {} 
Local bSort		:= { || NIL }
Local cMarc		:= ""
Local cTitulo	:= ""
Local cMvParDef	:= ""
Local cMvPar	:= &( Alltrim( ReadVar() ) )
Local nX		:= 0
Local nCampos	:= 0
Local nTamCon	:= 0
Local nTamTip	:= 0
Local nPosTip	:= 0

Private uMvRet	:= Alltrim( ReadVar() )

If ( Type("lUseSpj") == "U" )
	lUseSPJ := ( SuperGetMv("MV_USESPJ",NIL,"0")  == "1" )
EndIf

If lUseSpj
   cAlias := "SPJ"
   cPref_ := "PJ"
   nTamCon:= 8
   nTamTip:= 9
   nPosTip:= 4
Else
   cAlias := "RF3"
   cPref_ := "RF3"
   nTamCon:= 9
   nTamTip:= 10
   nPosTip:= 5
EndIf

aStruct := (cAlias)->(dbStruct())
nCampos := Len(aStruct)
cConte  := cPref_+"_ENTRA_"+cPref_+"_SAIDA"

l1Elem			:= IF( l1Elem == NIL .and. ValType( l1Elem ) != "L" , .F. , .T. )

bSort := { |x,y| ( SubStr( x[1] , nTamTip , 1 ) + SubStr( x[1] , nPosTip , 1 ) );
				 <;
				 ( SubStr( y[1] , nTamTip , 1 ) + SubStr( y[1] , nPosTip , 1 ) );
		 }

CursorWait()

	aSort( @aStruct , NIL , NIL , bSort )
	
	IF ( cTipo != "I" )
		For nX := 1 To nCampos
			cCampo := Upper( AllTrim( aStruct[ nX , 01 ] ) )
			If Subs(cCampo,1,nTamCon) $ cConte
				cMarc := SubStr( cCampo , nTamTip , 1 ) + SubStr( cCampo , nPosTip , 1 )
				cMvParDef += ( cMarc + "-" )
				aAdd( aMarc , cMarc += ( "-" + GetDescMarc( cMarc  ) ) )
			EndIF
		Next nX
	Else
		aAdd( aMarc , "I1-" + GetDescMarc( "I1" ) )
		aAdd( aMarc , "I2-" + GetDescMarc( "I2" ) )
		aAdd( aMarc , "I3-" + GetDescMarc( "I3" ) )
		cMvParDef := "I1-I2-I3-"
	EndIF

CursorArrow()
	
IF ( cMvPar != NIL )
	IF f_Opcoes(@cMvPar,cTitulo,aMarc,cMvParDef,12,49,l1Elem,3)
		&(uMvRet) := cMvPar
	EndIF	
EndIF	

Return( .T. )

/*/
зддддддддддбдддддддддддбдддддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o	   ЁfToleranciaЁ Autor ЁEquipe Advanced RH    Ё Data Ё22/03/2001Ё
цддддддддддедддддддддддадддддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o Ё Extrai a tolerancia da regra de apontamento.               Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё fTolerancia(cString, nMarc)								Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ cString - String contendo as tolerancias separadas por '-' Ё
Ё          Ё nMarc   - Numero sequencial da marcacao referente a tol. 	Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso	   Ё Generico 													Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function fTolerancia( cString , nMarc )

Local nTolera := 0				//-- Retorno da tolerancia
Local nY      := 0				//-- Contador da quantidade de tolerancias
Local nPos    := 1				//-- Posicao para extracao de cString
Local nLenStr := Len(cString)	//-- Tamanho da String

While ( nPos <= nLenStr )
	nY++
	IF ( nY > nMarc )
		Exit
	ElseIF ( nY == nMarc )
		nTolera := __Min2Hrs( Val( Subs( cString , nPos , 2 ) ) )
		Exit
	EndIF
	nPos += 3
End While

Return( nTolera )
/*/
зддддддддддбддддддддддбдддддбдддддддддддддддддддддддддбддддддбдддддддддд©
ЁFuncao	   ЁfAbonos   ЁAutorЁEquipe Advanced RH Ver. IЁ Data Ё04/04/2001Ё
Ё          Ё          Ё     ЁMarinaldo de Jesus Ver.IIЁ Data Ё27/04/2004Ё
цддддддддддеддддддддддадддддадддддддддддддддддддддддддаддддддадддддддддд╢
ЁDescricao ЁVerifica a existencia de abonos.                            Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso	   ЁGenerico 												  	Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function fAbonos(	dData		,;	//01 - Data do Abono
					cPD			,;	//02 - Evento do Abono
					nHora		,;	//03 - Hora Inicial do Abono
					aAbonos		,;	//04 - Array onde serao carregados os Abonos
					cTpMarca	,;	//05 - Tipo de Marcacao
					cCC			,;	//06 - Centro de Custo
					aAbonosPer	,;	//07 - Array com Todos os Abonos do Periodo
					cFuncao		,;	//08 - Funcao
					cDepto		,;	//09 - Depto 
					cPosto		,;	//10 - Posto  
					cProcesso	,;	//11 - Processo
					cPeriodo	,;	//12 - Periodo
					cRoteiro	,;	//13 - Roteiro
					cNumPagto	;	//14 - NumPagto								
				)

Local lPassTpMarca		:= !( cTpMarca == NIL )
Local lPassCC			:= !( cCC == NIL )
Local lPassFuncao		:= !( cFuncao == NIL )
Local lPassDepto 		:= !( cDepto == NIL )
Local lPassPosto 		:= !( cPosto == NIL )
Local lPassProcesso		:= !( cProcesso == NIL )
Local lPassPeriodo		:= !( cPeriodo == NIL )
Local lPassRoteiro		:= !( cRoteiro == NIL )
Local lPassNumPagto		:= !( cNumpagto == NIL )

Local nHrsAbo			:= 0

Local aTamSx3
Local bEval
Local bFiltro
Local cFilSPK
Local cCond_01
Local cCond_02
Local cbCond
Local lAbonosPer
Local nLenAbo
Local nSvOrder
Local nOrder

DEFAULT cTpMarca		:= Space( GetSx3Cache( "PK_TPMARCA" , "X3_TAMANHO" ) )

IF ( Type( "lMemoria" ) <> "L" )
	Private lMemoria := .F.
EndIF

aAbonos	 := {}

IF !( lMemoria )

	lAbonosPer := ( ValType( aAbonosPer ) == "A" )

	IF !( lAbonosPer )

		aTamSx3		:= TamSx3( "PK_HORINI" )
		bEval		:= { |e1 , e2 | e1 == &(e2) }
		cFilSPK		:= SRA->RA_FILIAL
		nSvOrder	:= SPK->( IndexOrd() )
		nOrder		:= RetOrdem( "SPK" , "PK_FILIAL+PK_MAT+DTOS(PK_DATA)+PK_CODEVE+STR(PK_HORINI,"+AllTrim(Str(aTamSx3[1]))+","+AllTrim(Str(aTamSx3[2]))+")+PK_TPMARCA+PK_CC+PK_DEPTO+PK_POSTO+PK_CODFUNC" )

		IF ( lPassTpMarca )
		   cbCond	:=	"SPK->PK_TPMARCA $ cTpMarca"
		EndIF
		IF ( lPassCC )
		   cbCond	:= IF( !Empty( cbCond ) , cbCond + " .and. " , "" ) + "SPK->PK_CC==cCC"
		EndIF
		IF ( lPassFuncao)
		   cbCond	:= IF( !Empty( cbCond ) , cbCond + " .and. " , "" ) + "SPK->PK_CODFUNC==cFuncao"
		EndIF 
		IF ( lPassDepto)
		   cbCond	:= IF( !Empty( cbCond ) , cbCond + " .and. " , "" ) + "SPK->PK_DEPTO==cDepto"
		EndIF
		IF ( lPassPosto)
		   cbCond	:= IF( !Empty( cbCond ) , cbCond + " .and. " , "" ) + "SPK->PK_POSTO==cPosto"
		EndIF
		IF ( lPassProcesso)
		   cbCond	:= IF( !Empty( cbCond ) , cbCond + " .and. " , "" ) + "SPK->PK_PROCES==cProcesso"
		EndIF
		IF ( lPassPeriodo)
		   cbCond	:= IF( !Empty( cbCond ) , cbCond + " .and. " , "" ) + "SPK->PK_PERIODO==cPeriodo"
		EndIF				
		IF ( lPassRoteiro)
		   cbCond	:= IF( !Empty( cbCond ) , cbCond + " .and. " , "" ) + "SPK->PK_ROTEIR==cRoteiro"
		EndIF
		IF ( lPassNumpagto)
		   cbCond	:= IF( !Empty( cbCond ) , cbCond + " .and. " , "" ) + "SPK->PK_NUMPAG==cNumPagto"
		EndIF	
		IF Empty( cbCond )
		   cbCond	:=	".T."
		EndIF
		bFiltro  := &( "{ ||" + cbCond + " }" )
		IF ( ( nHora == NIL ) .and. ( cPD # NIL ) )
			cCond_01	:= ( cFilSPK +  SRA->RA_MAT + Dtos( dData ) + cPD )
			cCond_02	:= "PK_FILIAL+PK_MAT+Dtos(PK_DATA)+PK_CODEVE"
		ElseIF ( nHora == NIL .and. cPD == NIL )
			cCond_01	:= ( cFilSPK + SRA->RA_MAT + Dtos( dData ) )
			cCond_02	:= "PK_FILIAL+PK_MAT+Dtos(PK_DATA)"
		Else
			cCond_01	:= ( cFilSPK + SRA->RA_MAT + Dtos(dData) + cPD + Str( nHora , aTamSx3[1] , aTamSx3[2] ) )
			cCond_02	:= "PK_FILIAL+PK_MAT+Dtos(PK_DATA)+PK_CODEVE+Str(PK_HORINI,"+AllTrim(Str(aTamSx3[1]))+","+AllTrim(Str(aTamSx3[2]))+")"
		EndIF

		IF !( nSvOrder == nOrder )
			SPK->( dbSetOrder( nOrder ) )
		EndIF

		IF SPK->( MsSeek( cCond_01 ) )
			While SPK->( !Eof() .and. Eval( bEval , cCond_01 , cCond_02 ) )
		        IF Eval( bFiltro )
					aAdd( aAbonos , Array( ELEMENTOS_AABONOS ) )
					nLenAbo := Len( aAbonos )
					aAbonos[ nLenAbo , AABONOS_CODIGO 		] := SPK->PK_CODABO
					aAbonos[ nLenAbo , AABONOS_HORAS_ABO	] := SPK->PK_HRSABO
					aAbonos[ nLenAbo , AABONOS_HORAS_INI	] := SPK->PK_HORINI
					aAbonos[ nLenAbo , AABONOS_HORAS_FIM	] := SPK->PK_HORFIM
					aAbonos[ nLenAbo , AABONOS_DATA			] := SPK->PK_DATA
					aAbonos[ nLenAbo , AABONOS_CC			] := SPK->PK_CC
					aAbonos[ nLenAbo , AABONOS_TPMARCA		] := SPK->PK_TPMARCA
					aAbonos[ nLenAbo , AABONOS_CODEVE		] := SPK->PK_CODEVE
					aAbonos[ nLenAbo , AABONOS_RECNO		] := SPK->( Recno() )
					aAbonos[ nLenAbo , AABONOS_FLAG			] := SPK->PK_FLAG
		 			aAbonos[ nLenAbo , AABONOS_FUNCAO		] := SPK->PK_CODFUNC
					aAbonos[ nLenAbo , AABONOS_DEPTO		] := SPK->PK_DEPTO   	 			
					aAbonos[ nLenAbo , AABONOS_POSTO 		] := SPK->PK_POSTO   
					aAbonos[ nLenAbo , AABONOS_PROCESSO     ] := SPK->PK_PROCES   	
					aAbonos[ nLenAbo , AABONOS_PERIODO		] := SPK->PK_PERIODO 
		   			aAbonos[ nLenAbo , AABONOS_ROTEIRO		] := SPK->PK_ROTEIR  		
					aAbonos[ nLenAbo , AABONOS_NUM_PAGTO		] := SPK->PK_NUMPAG 
				   	
				   	nHrsAbo := SomaHoras( nHrsAbo , SPK->PK_HRSABO )
				   	
				EndIF
				SPK->( dbSkip() )
			End While
		EndIF
		
		IF !( nSvOrder == nOrder )
			SPK->( dbSetOrder( nSvOrder ) )
		EndIF

	Else

		nHrsAbo := GetAbonosPer( dData , cPD , nHora , @aAbonos , cTpMarca , cCC , aAbonosPer , lPassTpMarca , lPassCC, cFuncao, ;
							     cDepto, cPosto,cProcesso,cPeriodo,cRoteiro,cNumPagto,lPassFuncao,lPassDepto, lPassPosto, lPassProcesso, lPassPeriodo, lPassRoteiro, lPassNumpagto;
							   )
			
	EndIF
	
Else

	nHrsAbo := fAbonosMem( dData , cPD , nHora , @aAbonos , cTpMarca , cCC , lPassTpMarca , lPassCC, cFuncao,;
					       cDepto, cPosto, cProcesso, cPeriodo, cRoteiro, cNumPagto, lPassFuncao, lPassDepto, lPassPosto, lPassProcesso, lPassPeriodo, lPassRoteiro, lPassNumpagto;
					     )

EndIF

Return( nHrsAbo )

/*/
зддддддддддбддддддддддддбддддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFuncao	   ЁGetAbonosPerЁAutor ЁMarinaldo de Jesus    Ё Data Ё20/01/2003Ё
цддддддддддеддддддддддддаддддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescricao ЁCarrega aAbonos a Partir do Conteudo de aAbonosPer			Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso	   ЁfAbonos()													Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function GetAbonosPer(	dData			,;	//Data do Abono
								cPD				,;	//Evento do Abono
								nHora			,;	//Hora Inicial do Abono
								aAbonos			,;	//Array onde serao carregados os Abonos
								cTpMarca		,;	//Tipo de Marcacao
								cCC				,;	//Centro de Custo
								aAbonosPer		,;	//Array com Todos os Abonos do Periodo
								lPassTpMarca	,;	//Se passou o Tipo da Marcacao em fAbonos
								lPassCC			,;	//Se passou o Centro de Custo em fAbonos  
								cFuncao			,;  //Codigo da Funcao
							    cDepto			,;  //Codigo do Depto
 							    cPosto			,;  //Codigo do Posto
 							    cProcesso		,;  //Codigo do Processo
 							    cPeriodo		,;  //Codigo do Periodo
 							    cRoteiro		,;  //Codigo do Roteiro
 							    cNumPagto		,;  //Codigo do NumPagto
 								lPassFuncao     ,;  //Se passou funcao   
 							    lPassDepto		,;  //Se passou Depto
 							    lPassPosto		,;  //Se passou Posto
 							    lPassProcesso	,;  //Se passou Processo
 							    lPassPeriodo	,;  //Se passou Periodo
 							    lPassRoteiro	,;  //Se passou Roteiro   
 							    lPassNumpagto	 ;  //Se passou NumPagto   
							)
                
Local aTamSx3	:= TamSx3( "PK_HORINI" )
Local nHrsAbo	:= 0

Local bEval
Local bFiltro
Local bCond_01
Local bCond_02
Local cbCond
Local nLenAbo
Local nAbonosPer
Local nPosAbono

aAbonos	 := {}

IF ( lPassTpMarca )
   cbCond	:=	"aAbonosPer[ nPosAbono ," + AllTrim( Str( AABONOS_TPMARCA ) ) + "] $ cTpMarca"
EndIF
IF ( lPassCC )
   cbCond := IF( !Empty( cbCond ) , cbCond + " .and. " , "" ) + "aAbonosPer[ nPosAbono ," + Str( AABONOS_CC ) + "] == cCC"
EndIF
IF ( lPassFuncao )
   cbCond := IF( !Empty( cbCond ) , cbCond + " .and. " , "" ) + "aAbonosPer[ nPosAbono ," + Str( AABONOS_FUNCAO ) + "] == cFuncao"
EndIF 
IF ( lPassDepto )
   cbCond := IF( !Empty( cbCond ) , cbCond + " .and. " , "" ) + "aAbonosPer[ nPosAbono ," + Str( AABONOS_DEPTO ) + "] == cDepto"
EndIF
IF ( lPassPosto )
   cbCond := IF( !Empty( cbCond ) , cbCond + " .and. " , "" ) + "aAbonosPer[ nPosAbono ," + Str( AABONOS_POSTO ) + "] == cPosto"
EndIF
If ( lPassProcesso )
   cbCond := IF( !Empty( cbCond ) , cbCond + " .and. " , "" ) + "aAbonosPer[ nPosAbono ," + Str( AABONOS_PROCESSO ) + "] == cProcesso"
EndIF	
If ( lPassPeriodo )
   cbCond := IF( !Empty( cbCond ) , cbCond + " .and. " , "" ) + "aAbonosPer[ nPosAbono ," + Str( AABONOS_PERIODO ) + "] == cPeriodo"
EndIF
If ( lPassRoteiro )
   cbCond := IF( !Empty( cbCond ) , cbCond + " .and. " , "" ) + "aAbonosPer[ nPosAbono ," + Str( AABONOS_ROTEIRO ) + "] == cRoteiro"
EndIF
If ( lPassNumPagto )
   cbCond := IF( !Empty( cbCond ) , cbCond + " .and. " , "" ) + "aAbonosPer[ nPosAbono ," + Str( AABONOS_NUM_PAGTO ) + "] == cNumPagto"
EndIF

IF Empty( cbCond )
   cbCond	:= ".T."
EndIF
bFiltro		:= &( "{ || " + cbCond + " } " )
IF ( ( nHora == NIL ) .and. ( cPD # NIL ) )
	bCond_01	:= { || Dtos( dData ) + cPD }
	bCond_02	:= { || Dtos( aAbonosPer[ nPosAbono , AABONOS_DATA ] ) + aAbonosPer[ nPosAbono , AABONOS_CODEVE ] }
ElseIF ( ( nHora == NIL ) .and. ( cPD == NIL ) )
	bCond_01	:= { || Dtos( dData ) }
	bCond_02	:= { || Dtos( aAbonosPer[ nPosAbono , AABONOS_DATA ] ) }
Else
	bCond_01	:= { || Dtos( dData ) + cPD + Str( nHora , aTamSx3[1] , aTamSx3[2] ) }
	bCond_02	:= { || Dtos( aAbonosPer[ nPosAbono , AABONOS_DATA ] ) + aAbonosPer[ nPosAbono , AABONOS_CODEVE ] + Str( aAbonosPer[ nPosAbono , AABONOS_HORAS_INI ] , aTamSx3[1] , aTamSx3[2] ) }
EndIF

nAbonosPer	:= Len( aAbonosPer )
IF ( ( nPosAbono := aScan( aAbonosPer , { |x| x[ AABONOS_DATA ] == dData } ) ) > 0 )
	bEval := { | b1 , b2 | Eval( b1 ) == Eval( b2 ) }
	For nPosAbono := nPosAbono To nAbonosPer
		IF ( !Eval( bEval , bCond_01 , bCond_02 ) .or. !Eval( bFiltro ) )
			Loop
		EndIF   
		IF !Empty(aAbonosPer[ nPosAbono , AABONOS_CODIGO 	])
			aAdd( aAbonos , Array( ELEMENTOS_AABONOS ) )
			nLenAbo := Len( aAbonos )
			aAbonos[ nLenAbo , AABONOS_CODIGO 		] := aAbonosPer[ nPosAbono , AABONOS_CODIGO 	]
			aAbonos[ nLenAbo , AABONOS_HORAS_ABO	] := aAbonosPer[ nPosAbono , AABONOS_HORAS_ABO	]
			aAbonos[ nLenAbo , AABONOS_HORAS_INI	] := aAbonosPer[ nPosAbono , AABONOS_HORAS_INI	]
			aAbonos[ nLenAbo , AABONOS_HORAS_FIM	] := aAbonosPer[ nPosAbono , AABONOS_HORAS_FIM	]
			aAbonos[ nLenAbo , AABONOS_DATA			] := aAbonosPer[ nPosAbono , AABONOS_DATA		]
			aAbonos[ nLenAbo , AABONOS_CC			] := aAbonosPer[ nPosAbono , AABONOS_CC			]
			aAbonos[ nLenAbo , AABONOS_TPMARCA		] := aAbonosPer[ nPosAbono , AABONOS_TPMARCA	]
			aAbonos[ nLenAbo , AABONOS_CODEVE		] := aAbonosPer[ nPosAbono , AABONOS_CODEVE		]
			aAbonos[ nLenAbo , AABONOS_RECNO		] := aAbonosPer[ nPosAbono , AABONOS_RECNO		]
			aAbonos[ nLenAbo , AABONOS_FLAG			] := aAbonosPer[ nPosAbono , AABONOS_FLAG		]
			aAbonos[ nLenAbo , AABONOS_FUNCAO		] := aAbonosPer[ nPosAbono , AABONOS_FUNCAO		]		
			aAbonos[ nLenAbo , AABONOS_DEPTO		] := aAbonosPer[ nPosAbono , AABONOS_DEPTO		]		
			aAbonos[ nLenAbo , AABONOS_POSTO		] := aAbonosPer[ nPosAbono , AABONOS_POSTO		]								
			aAbonos[ nLenAbo , AABONOS_PROCESSO		] := aAbonosPer[ nPosAbono , AABONOS_PROCESSO	]	
			aAbonos[ nLenAbo , AABONOS_PERIODO		] := aAbonosPer[ nPosAbono , AABONOS_PERIODO	]	
			aAbonos[ nLenAbo , AABONOS_ROTEIRO		] := aAbonosPer[ nPosAbono , AABONOS_ROTEIRO	]	
			aAbonos[ nLenAbo , AABONOS_NUM_PAGTO		] := aAbonosPer[ nPosAbono , AABONOS_NUM_PAGTO	]													
			nHrsAbo := SomaHoras( nHrsAbo , aAbonosPer[ nPosAbono , AABONOS_HORAS_ABO	] )
		Endif
	Next nPosAbono
EndIF

Return( nHrsAbo )

/*/
зддддддддддбддддддддддбдддддбдддддддддддддддддддддддддбддддддбдддддддддд©
ЁFuncao	   ЁfAbonosMemЁAutorЁMauricio MR        Ver. IЁ Data Ё04/04/2001Ё
Ё          Ё          Ё     ЁMarinaldo de Jesus Ver.IIЁ Data Ё27/04/2004Ё
цддддддддддеддддддддддадддддадддддддддддддддддддддддддаддддддадддддддддд╢
ЁDescricao ЁVerifica a existencia de abonos (Trabalha com a Memoria)	Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso	   ЁfAbonos()													Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function fAbonosMem(	dData			,;	//Data do Abono
							cPD				,;	//Evento do Abono
							nHora			,;	//Hora Inicial do Abono
							aAbonos			,;	//Array onde serao carregados os Abonos
							cTpMarca		,;	//Tipo de Marcacao
							cCC				,;	//Centro de Custo
							lPassTpMarca	,;	//Se passou o Tipo da Marcacao em fAbonos
							lPassCC			,;	//Se passou o Centro de Custo em fAbonos   
							cFuncao         ,;  //Codigo da Funcao
						  	cDepto			,;  //Codigo do Depto
						    cPosto			,;  //Codigo do Posto
						    cProcesso		,;  //Codigo do Processo
						    cPeriodo		,;  //Codigo do Periodo
						    cRoteiro		,;  //Codigo do Roteiro
						    cNumPagto		,;  //Codigo do NumPagto
							lPassFuncao     ,;  //Se passou a Funcao
						    lPassDepto		,;  //Se passou Depto
						    lPassPosto		,;  //Se passou Posto
						    lPassProcesso	,;  //Se passou Processo
						    lPassPeriodo	,;  //Se passou Periodo
						    lPassRoteiro	,;  //Se passou Roteiro   
						    lPassNumpagto	 ;  //Se passou NumPagto   
						   )								

Local nHrsAbo	:= 0

Local aAboCols
Local aTamSx3
Local bFiltro
Local cCond_01
Local cCond_02
Local cbCond
Local nLenAbo
Local nX
Local nLenX
Local nPkCodAbo
Local nPkHorIni
Local nPkHorFim
Local nPkHrsAbo
Local nPkCodEve
Local nPkTpMarca
Local nPkCc
Local nPkFlag
Local nPkFuncao
Local nPkDepto
Local nPkPosto
Local nPkProcesso
Local nPkPeriodo
Local nPkRoteiro
Local nPkNumPagto

/*/
здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Se Existir a Variavel bAboCols ( e for um bloco )   utilizadaЁ
Ё para a Montagem do aAboCols, Executa						   Ё
юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
IF ( Type( "bAboCols" ) == "B" )

	aTamSx3		:= TamSx3( "PK_HORINI" )
	nPkData		:= GdFieldPos( "PK_DATA"    , aAboHeader )
	nPkCodAbo	:= GdFieldPos( "PK_CODABO" 	, aAboHeader )
	nPkHorIni	:= GdFieldPos( "PK_HORINI" 	, aAboHeader )
	nPkHorFim	:= GdFieldPos( "PK_HORFIM" 	, aAboHeader )
	nPkHrsAbo	:= GdFieldPos( "PK_HRSABO" 	, aAboHeader )
	nPkCodEve	:= GdFieldPos( "PK_CODEVE" 	, aAboHeader ) 
	nPkTpMarca	:= GdFieldPos( "PK_TPMARCA"	, aAboHeader )            
	nPkCc 		:= GdFieldPos( "PK_CC"		, aAboHeader ) 
	nPkFlag		:= GdFieldPos( "PK_FLAG"	, aAboHeader ) 
	nPkFuncao	:= GdFieldPos( "PK_CODFUNC"	, aAboHeader ) 
	nPkDepto	:= GdFieldPos( "PK_DEPTO"	, aAboHeader ) 
	nPkPosto	:= GdFieldPos( "PK_POSTO"	, aAboHeader ) 
	nPkProcesso	:= GdFieldPos( "PK_PROCES"	, aAboHeader ) 
	nPkPeriodo	:= GdFieldPos( "PK_PERIODO"	, aAboHeader ) 
	nPkRoteiro	:= GdFieldPos( "PK_ROTEIR"	, aAboHeader ) 
	nPkNumPagto := GdFieldPos( "PK_NUMPAG"	, aAboHeader ) 					

	aAboCols	:= Eval( bAboCols )

	IF ( lPassTpMarca )
	   cbCond := 'aAboCols[nX, nPkTpMarca]$cTpMarca'
	EndIF
	IF ( lPassCC )
	   cbCond := IF( !Empty(cbCond) , cbCond + ' .and. ','') + 'aAboCols[nX, nPkCc]==cCC'
	EndIF
	IF ( lPassFuncao )
	   cbCond := IF( !Empty(cbCond) , cbCond + ' .and. ','') + 'aAboCols[nX, nPkFuncao]==cFuncao'
	EndIF	
	IF ( lPassDepto )
	   cbCond := IF( !Empty( cbCond ) , cbCond + ' .and. ' , '' ) + 'aAboCols[ nX, nPkDepto ] == cDepto'
	EndIF
	IF ( lPassPosto )
	   cbCond := IF( !Empty( cbCond ) , cbCond + ' .and. ' , '' ) + 'aAboCols[ nX, nPkPosto] == cPosto'
	EndIF
	IF ( lPassProcesso )
	   cbCond := IF( !Empty( cbCond ) , cbCond + ' .and. ' , '' ) + 'aAboCols[ nX, nPkProcesso] == cProcesso'
	EndIF
	IF ( lPassPeriodo )
	   cbCond := IF( !Empty( cbCond ) , cbCond + ' .and. ' , '' ) + 'aAboCols[ nX, nPkPeriodo] == cPeriodo'
	EndIF
	IF ( lPassRoteiro )
	   cbCond := IF( !Empty( cbCond ) , cbCond + ' .and. ' , '' ) + 'aAboCols[ nX, nPkRoteiro] == cRoteiro'
	EndIF
	IF ( lPassNumPagto )
	   cbCond := IF( !Empty( cbCond ) , cbCond + ' .and. ' , '' ) + 'aAboCols[ nX, nPkNumPagto] == cNumPagto'
	EndIF
	IF Empty(cbCond)
	   cbCond := '.T.'
	EndIF

	bFiltro  := &("{||"+cbCond+" }") 
	
	IF ( ( nHora == NIL ) .and. ( cPD # NIL ) )
		cCond_01	:= ( Dtos( dData ) + cPD )
		cCond_02	:= { |nElem| Dtos( aAboCols[ nElem , nPkData ] ) + aAboCols[ nElem , nPkCodEve ] }
	ElseIF ( ( nHora == NIL ) .and. ( cPD == NIL ) )
		cCond_01	:= ( Dtos( dData ) )
		cCond_02	:= { |nElem| Dtos( aAboCols[ nElem , nPkData ] ) }
	Else
		cCond_01	:= ( Dtos(dData) + cPD + Str( nHora , aTamSx3[1] , aTamSx3[2] ) )
		cCond_02	:= { |nElem| Dtos( aAboCols[ nElem, nPkData ] ) + aAboCols[ nElem , nPkCodEve ] + Str( aAboCols[ nElem , nPkHorIni ] , aTamSx3[1] , aTamSx3[2] ) }
	EndIF
	               
	nLenX := Len( aAboCols )
	For nX := 1 To nLenX
		IF ( cCond_01 == Eval( cCond_02 , nX ) )
			IF Eval( bFiltro )
				IF !Empty(aAboCols[nX, nPkCodAbo]) .AND. !aAboCols[ nX, Len( aAboCols[nX] ) ]
					aAdd( aAbonos , Array( ELEMENTOS_AABONOS ) )
					nLenAbo := Len( aAbonos )
					aAbonos[ nLenAbo , AABONOS_CODIGO 		] := aAboCols[ nX , nPkCodAbo 	]
					aAbonos[ nLenAbo , AABONOS_HORAS_ABO	] := aAboCols[ nX , nPkHrsAbo 	]
					aAbonos[ nLenAbo , AABONOS_HORAS_INI	] := aAboCols[ nX , nPkHorIni 	]
					aAbonos[ nLenAbo , AABONOS_HORAS_FIM	] := aAboCols[ nX , nPkHorFim 	]
					aAbonos[ nLenAbo , AABONOS_DATA			] := aAboCols[ nX , nPkData 	]
					aAbonos[ nLenAbo , AABONOS_CC			] := aAboCols[ nX , nPkCc	 	]
					aAbonos[ nLenAbo , AABONOS_TPMARCA		] := aAboCols[ nX , nPkTpMarca	]
					aAbonos[ nLenAbo , AABONOS_CODEVE		] := aAboCols[ nX , nPkCodEve	]
					aAbonos[ nLenAbo , AABONOS_RECNO		] := nX
					aAbonos[ nLenAbo , AABONOS_FLAG			] := aAboCols[ nX , nPkFlag		]   
					aAbonos[ nLenAbo , AABONOS_FUNCAO		] := aAboCols[ nX , nPkFuncao	]   					
					aAbonos[ nLenAbo , AABONOS_DEPTO		] := aAboCols[ nX , nPkDepto	]   					
					aAbonos[ nLenAbo , AABONOS_POSTO		] := aAboCols[ nX , nPkPosto	]   												
					aAbonos[ nLenAbo , AABONOS_PROCESSO		] := aAboCols[ nX , nPkProcesso	]   												
					aAbonos[ nLenAbo , AABONOS_PERIODO		] := aAboCols[ nX , nPkPeriodo	]   												
					aAbonos[ nLenAbo , AABONOS_ROTEIRO		] := aAboCols[ nX , nPkRoteiro	]   												
					aAbonos[ nLenAbo , AABONOS_NUM_PAGTO	] := aAboCols[ nX , nPkNumpagto	]   																																
				EndIF
				IF !Empty( aAboCols[ nX , nPkCodAbo ] ) .and. !aAboCols[ nX, Len( aAboCols[nX] ) ]
					nHrsAbo := SomaHoras( nHrsAbo , aAboCols[ nX , nPkHrsAbo ] )
				EndIF
			EndIF
		EndIF
	Next nX

EndIF
	
Return( nHrsAbo )

/*/
зддддддддддбдддддддддддбдддддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFuncao	   ЁfAbonosPer Ё Autor ЁMarinaldo de Jesus    Ё Data Ё20/01/2003Ё
цддддддддддедддддддддддадддддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescricao ЁCarrega no Array aAbonos    Todos os Abonos do Periodo		Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso	   ЁGenerico 												  	Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function fAbonosPer( aAbonos , dPerIni , dPerFim , cFil , cMat )

Local aTamSx3		:= TamSx3( "PK_HORINI" )
Local cAlias		:= "SPK"
Local cAliasQuery	:= cAlias
Local nOrder		:= RetOrdem( "SPK" , "PK_FILIAL+PK_MAT+DTOS(PK_DATA)+PK_CODEVE+STR(PK_HORINI,"+AllTrim(Str(aTamSx3[1]))+","+AllTrim(Str(aTamSx3[2]))+")+PK_CC+PK_DEPTO+PK_POSTO+PK_CODFUNC" )
Local nOrdSPK		:= ( cAlias )->( IndexOrd() )

Local cFilMat
Local lExistAbo
Local nLenAbo

#IFDEF TOP

	Local cOldAlias			:= Alias()
	Local cPrefixo			:= ( PrefixoCpo( cAlias ) + "_" )
	Local cIniData	 		:= ""
	Local cFimData			:= ""
	Local cQuery	 		:= ""
	Local lQueryOpened		:= .F.
	Local nX				:= 0

	Static aSpkFields
	Static cQrySpkFields
	Static nSpkFields

	IF !( lExInAs400 )
	
		DEFAULT aSpkFields := ( cAlias )->( dbStruct() )
		DEFAULT nSpkFields := Len( aSpkFields )

		IF ( cQrySpkFields == NIL )
			cQrySpkFields := ""	
			For nX := 1 To nSpkFields
				cQrySpkFields += aSpkFields[ nX , 01 ] + ", "
			Next nX
		EndIF
	
	EndIF		

#ENDIF

aAbonos := {}
DEFAULT dPerIni := Ctod("//")
DEFAULT dPerFim := Ctod("//")
DEFAULT cFil	:= SRA->RA_FILIAL
DEFAULT cMat	:= SRA->RA_MAT

IF !( nOrdSPK == nOrder )
	( cAliasQuery )->( dbSetOrder( nOrder ) )
EndIF

cFilMat := ( cFil + cMat )

#IFDEF TOP

	IF !( lExInAs400 )
		
		cIniData	:= Dtos( dPerIni )
		cFimData	:= Dtos( dPerFim )
		cAliasQuery := ( "__Q" + cAliasQuery + "QRY" )
		cQuery := "SELECT "
		cQuery += cQrySpkFields
		cQuery += "R_E_C_N_O_ RECNO "
		cQuery += " FROM "
		cQuery += InitSqlName( cAlias )
		cQuery += " WHERE "
		cQuery += cPrefixo + "FILIAL='"+cFil+"'"
		cQuery += " AND "
		cQuery += cPrefixo + "MAT='"+cMat+"'"
		cQuery += " AND "
		cQuery += cPrefixo + "DATA>='"+cIniData+"'"
		cQuery += " AND "
		cQuery += cPrefixo + "DATA<='"+cFimData+"'"
		cQuery += " AND "
		cQuery += "D_E_L_E_T_=' ' "
		cQuery += "ORDER BY " + SqlOrder( (cAlias)->( IndexKey() ) )
		cQuery := ChangeQuery( cQuery )
		IF ( lQueryOpened := MsOpenDbf(.T.,"TOPCONN",TcGenQry(NIL,NIL,cQuery),cAliasQuery,.F.,.T.) )
			For nX := 1 To nSpkFields
				IF !( aSpkFields[ nX , 02 ] == "C" )
					TcSetField(cAliasQuery,aSpkFields[nX,01],aSpkFields[nX,02],aSpkFields[nX,03],aSpkFields[nX,04])
				EndIF
			Next nX
		Else
			cAliasQuery := cAlias
		EndIF	

	EndIF
				
#ENDIF

#IFNDEF TOP
	( cAliasQuery )->( MsSeek( cFilMat + Dtos( dPerIni ) , .T. ) )
#ELSE
	IF !( lQueryOpened )
		( cAliasQuery )->( MsSeek( cFilMat + Dtos( dPerIni ) , .T. ) )
	EndIF
#ENDIF

While ( cAliasQuery )->( !Eof() .and. ( ( PK_FILIAL + PK_MAT ) == cFilMat ) )
	#IFNDEF TOP
		IF ( cAliasQuery )->( ( PK_DATA < dPerIni ) .or. ( PK_DATA > dPerFim ) )
			( cAliasQuery )->( dbSkip() )
			Loop
		EndIF
	#ELSE
		IF !( lQueryOpened )
			IF ( cAliasQuery )->( ( PK_DATA < dPerIni ) .or. ( PK_DATA > dPerFim ) )
				( cAliasQuery )->( dbSkip() )
				Loop
			EndIF
	    EndIF
	#ENDIF
	aAdd( aAbonos , Array( ELEMENTOS_AABONOS ) )
	nLenAbo := Len( aAbonos )
	aAbonos[ nLenAbo , AABONOS_CODIGO 		] := ( cAliasQuery )->( PK_CODABO	)
	aAbonos[ nLenAbo , AABONOS_HORAS_ABO	] := ( cAliasQuery )->( PK_HRSABO	)
	aAbonos[ nLenAbo , AABONOS_HORAS_INI	] := ( cAliasQuery )->( PK_HORINI	)
	aAbonos[ nLenAbo , AABONOS_HORAS_FIM	] := ( cAliasQuery )->( PK_HORFIM	)
	aAbonos[ nLenAbo , AABONOS_DATA			] := ( cAliasQuery )->( PK_DATA		)
	aAbonos[ nLenAbo , AABONOS_CC			] := ( cAliasQuery )->( PK_CC		)
	aAbonos[ nLenAbo , AABONOS_TPMARCA		] := ( cAliasQuery )->( PK_TPMARCA	)
	aAbonos[ nLenAbo , AABONOS_CODEVE		] := ( cAliasQuery )->( PK_CODEVE	)
	#IFNDEF TOP	
		aAbonos[ nLenAbo , AABONOS_RECNO	] := ( cAliasQuery )->( Recno() )
	#ELSE
		IF !( lQueryOpened )
			aAbonos[ nLenAbo , AABONOS_RECNO	] := ( cAliasQuery )->( Recno() )
		Else
			aAbonos[ nLenAbo , AABONOS_RECNO	] := ( cAliasQuery )->( RECNO 	)
		EndIF
	#EndIF
	aAbonos[ nLenAbo , AABONOS_FLAG			] := ( cAliasQuery )->( PK_FLAG			)
	aAbonos[ nLenAbo , AABONOS_FUNCAO		] := AllTrim(( cAliasQuery )->( PK_CODFUNC		))
	aAbonos[ nLenAbo , AABONOS_DEPTO		] := ( cAliasQuery )->( PK_DEPTO		)
	aAbonos[ nLenAbo , AABONOS_POSTO		] := ( cAliasQuery )->( PK_POSTO		)
	aAbonos[ nLenAbo , AABONOS_PROCESSO		] := AllTrim(( cAliasQuery )->( PK_PROCES		))
	aAbonos[ nLenAbo , AABONOS_PERIODO		] := ( cAliasQuery )->( PK_PERIODO		)
	aAbonos[ nLenAbo , AABONOS_ROTEIRO		] := ( cAliasQuery )->( PK_ROTEIR		)
	aAbonos[ nLenAbo , AABONOS_NUM_PAGTO	] := ( cAliasQuery )->( PK_NUMPAG		)				
	( cAliasQuery )->(  dbSkip() )
End While

#IFDEF TOP
	IF ( ( lQueryOpened ) .and. ( Select( cAliasQuery ) > 0 ) )
    	( cAliasQuery )->( dbCloseArea() )
    	dbSelectArea( cOldAlias )
   	EndIF
#ENDIF

lExistAbo := ( Len( aAbonos ) > 0 )

IF !( nOrdSPK == nOrder )
	SPK->( dbSetOrder( nOrdSPK ) )
EndIF

Return( lExistAbo )

/*/
эээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤└o    Ё RetSeq   Ё Autor Ё Alexsandro Pereira    Ё Data Ё 25/08/00 Ё╠╠
╠╠цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤└o Ё Retorna a sequencia inicial do turno de um periodo qualquerЁ╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁSintaxe   Ё RetSeq(cSeqAtual,cTurno,dPerIni,dPerFim,dData,aTabPadrao)  Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁParametrosЁ cSeqAtual  - Sequencia do periodo atual                    Ё╠╠
╠╠Ё          Ё cTurno     - Turno de trabalho atual                       Ё╠╠
╠╠Ё          Ё dPerIni    - Data inicio do periodo a se calcular sequenciaЁ╠╠
╠╠Ё          Ё dPerFim    - Data fim do periodo a se calcular sequencia   Ё╠╠
╠╠Ё          Ё dData      - Data referente ao periodo para calculo sequencЁ╠╠
╠╠Ё          Ё aTabPadrao - Tabela de horario padrao                      Ё╠╠
╠╠Ё          Ё cSeqAnt    - Sequencia anterior calculada (retornado p/fun)Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁUso       Ё Gen┌rico                                                   Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠*/
Function RetSeq(cSeqAtual,cTurno,dPerIni,dPerFim,dData,aTabPadrao,cSeqAnt,cFil)

//-- Calcula a sequencia inicial do periodo retroativo
//-- funcao chamada quando nao houver troca de turno.
Local dPerAntIni := Ctod('  /  /  ')	//-- Data inicial do periodo anterior
Local dPerAntFim := Ctod('  /  /  ')	//-- Data final do periodo anterior
Local dDataSeg   := Ctod('  /  /  ')	//-- Data da ultima segunda-feira
Local nSemanas   := 0					//-- Numero de semanas
Local nQtdSeq    := 0					//-- Quantidade de sequencias da tabela de horario padrao
Local nPosTab    := 0					//-- Posicao do turno na tabela de horario padrao
Local cFilSPF    := SRA->RA_FILIAL		//-- Codigo da filial do arquivo SPF

DEFAULT cFil := cFilAnt

//-- Quando a sequencia nao for informada, assume-se "01"
cSeqAtual := If(cSeqAtual==Nil .Or. Val(cSeqAtual)=0,'01',cSeqAtual)

//-- Obtem o total de sequencias da tabela
If (nPosTab := aScan(aTabPadrao, { |x| x[1] == fFilFunc('SPJ') .And. x[2] == cTurno })) > 0
	nQtdSeq := Val(aTabPadrao[nPosTab,3,Len(aTabPadrao[nPosTab,3]),16])
	//nQtdSeq := Val(aTabPadrao[nPosTab,3,Len(aTabPadrao[nPosTab,3]),19])
Endif

//-- Carrega o periodo de apontamento.
If !PerAponta(@dPerAntIni,@dPerAntFim,dData,NIL,cFil)
	Return .F.
Endif

//-- verifica as trocas de turno a partir do periodo escolhido ate a data atual
If SPF->(dbSeek(cFilSPF+SRA->RA_MAT+DTos(dPerIni),.T.))
	If SPF->PF_FILIAL+SPF->PF_MAT == cFilSPF+SRA->RA_MAT .And. SPF->PF_DATA <= dPerAntIni-1
		//-- Carrega o periodo de apontamento.
		cSeqAtual := SPF->PF_SEQUEDE
		cTurno    := SPF->PF_TURNODE
		//-- Carrega o periodo de apontamento.
		If !PerAponta(@dPerAntIni,@dPerAntFim,SPF->PF_DATA,NIL,cFil)
			Return .F.
		Endif
	Endif
Endif

//-- Se a data fim do antepenultimo periodo nao for na segunda-feira
If Dow(dPerAntIni-1) # 2
	//-- Obtem a data da segunda-feira do antepenultimo periodo.
	dDataSeg := (dPerAntIni-1) - (Dow(dPerAntIni-1) - 2)
	Else
	dDataSeg := dPerAntIni-1
Endif

//-- Calcula o numero de semanas decorridas desde a data inicial do periodo a obter a sequencia.
nSemanas  := If((nSemanas:=(dDataSeg-dPerIni)/7) > Int(nSemanas),Int(nSemanas := nSemanas + 1),nSemanas)
cSeqAnt   := Val(cSeqAtual)-nSemanas
cSeqAnt   := If(cSeqAnt<=1,nQtdSeq + cSeqAnt ,cSeqAnt)
cSeqAnt   := StrZero(ABS(cSeqAnt),2)

Return (cSeqAnt<>cSeqAtual)

/*/
зддддддддддбдддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    Ё fGeraExtraЁ Autor Ё Mauro Sergio          Ё Data Ё 07/11/96 Ё
цддддддддддедддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o Ё Gerar a Verba de Horas Extras                               Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё< Vide Parametros Formais >								   	 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ< Vide Parametros Formais >								   	 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGeracao de Horas Extras                                      Ё
юддддддддддаддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function fGeraExtra(	aTabExtra	,;	//01 -> Array contendo os Tipos de Horas Extras
						cTpExtra	,;	//02 -> Tipo de Hora Extra a ser Gerado
						nThoras		,;	//03 -> Numero de Horas Extras Autorizadas	
						nTNhoras	,;	//04 -> Numero de Horas Extras Nao Autorizadas	
						aResult		,;	//05 -> Array com os Resultados do Apontamento do Dia
						aTotais		,;	//06 -> Array com os Totais Apontados por Evento do Dia 
						dData		,;	//07 -> Data da Gravacao
						cRotina		,;	//08 -> Rotina Chamadora da Funcao
						cPeriodo	,;	//09 -> Periodo de Apuracao 
						lSoma		,;	//10 -> Soma ao Valor Existente
						cCusto		,;	//11 -> Centro de Custo Para Gravacao
						cTpMarc		,;	//12 -> Tipo de Marcacao
						lMvAcmHExt	,;	//13 -> Considerar Todas as Horas Extras do Dia Para o Escalonamento
						lSubstitui	,;	//14 -> Se Substitui as Horas Existentes
						cFuncao		,;  //15 -> Funcao para gravacao
						cDepto		,;  //16 -> Depto para gravacao
						cPosto		,;  //17 -> Posto para gravacao  
						cProcesso   ,;  //18 -> Processo para Gravacao								
						cRoteiro	,;  //19 -> Roteiro para Gravacao
						cPeriodo	,;  //20 -> Periodo para Gravacao								
						cNumPagto	;   //21 -> NumPagto para Gravacao												
					)

Local aExTipo

Local bEvalSomaA
Local bEvalSomaN

Local cEvento

Local lRotFec

Local nResto
Local nHoras
Local nPos
Local nX
Local nFornX
Local nN

DEFAULT nThoras		:= 0
DEFAULT nTNhoras	:= 0

IF (;
		( nThoras > 0 );
		.or.;
		( nTNhoras > 0 );
	)

	aExTipo := {}
	nResto  := 0

	DEFAULT lSoma			:= .F.
	DEFAULT cCusto			:= Space( GetSx3Cache( "PC_CC" 			, "X3_TAMANHO" ) )
	DEFAULT cTpMarc 		:= Space( GetSx3Cache( "PC_TPMARCA"		, "X3_TAMANHO" ) )
	DEFAULT cFuncao 		:= Space( GetSx3Cache( "PC_CODFUNC"		, "X3_TAMANHO" ) )
	DEFAULT cDepto 			:= Space( GetSx3Cache( "PC_DEPTO"		, "X3_TAMANHO" ) )
	DEFAULT cPosto 			:= Space( GetSx3Cache( "PC_POSTO"		, "X3_TAMANHO" ) )
	DEFAULT cProcesso 		:= Space( GetSx3Cache( "PC_PROCES"		, "X3_TAMANHO" ) )
	DEFAULT cPeriodo 		:= Space( GetSx3Cache( "PC_PERIODO"		, "X3_TAMANHO" ) )
	DEFAULT cRoteiro 		:= Space( GetSx3Cache( "PC_ROTEIR"		, "X3_TAMANHO" ) )
	DEFAULT cNumPagto 		:= Space( GetSx3Cache( "PC_NUMPAG"		, "X3_TAMANHO" ) )	
	DEFAULT lMvAcmHExt		:= .F.
	
	//-- 'APO' para Apontamento e 'FEC' para Fechamento
	cRotina  := IF( Empty( cRotina )  , "APO" , Upper( cRotina  ) )
	cPeriodo := IF( Empty( cPeriodo ) , "D"   , Upper( cPeriodo ) )

	lRotFec  := ( cRotina == "FEC" )

	Begin Sequence
	
		IF ( lMvAcmHExt )
			ToScheduleOverTime(	aTabExtra	,;	//Array contendo os Tipos de Horas Extras
								cTpExtra	,;	//Tipo de Hora Extra a ser Gerado
								nThoras		,;	//Numero de Horas Extras Autorizadas
								nTNhoras	,;	//Numero de Horas Extras Nao Autorizadas
								aResult		,;	//Array com os Resultados do Apontamento do Dia
								aTotais		,;	//Array com os Totais Apontados por Evento do Dia
								dData		,;	//Data da Gravacao
								cRotina		,;	//Rotina Chamadora da Funcao
								cPeriodo	,;	//Periodo de Apuracao
								lSoma		,;	//Soma ao Valor Existente
								cCusto		,;	//Centro de Custo Para Gravacao
								cTpMarc		,;	//Tipo de Marcacao
								lSubstitui	,;	//Se Substitui as Horas Existentes 
								cFuncao		,;  //Funcao para Gravacao
								cDepto		,;  //Depto para Gravacao
								cPosto		,;  //Posto para Gravacao
								cProcesso	,;  //Processo para Gravacao																								
								cPeriodo	,;  //Periodo para Gravacao
								cRoteiro	,;  //Processo para Gravacao								
								cNumPagto	;   //NumPagto para Gravacao
							)
			Break
	    EndIF
		
		//--Gerar Array do Tipo Desejado
		aExTipo := GetExTipo( aTabExtra , @cTpExtra )

		IF ( lSoma )
			IF !( lRotFec )
				bEvalSomaA	:= { |x| IF(;
											(;
												( x[ ARESULT_DATA ] == dData );
												.and.;
												( x[ ARESULT_EVENTO ] == aExTipo[ nX , 4 ] );
												.and.;
												( x[ ARESULT_CC ] == cCusto );
												.and.;
												( x[ ARESULT_TPMARCA ] == cTpMarc );  
												.and.;
												( x[ ARESULT_FUNCAO	] == cFuncao);		
												.and.;
												( x[ ARESULT_DEPTO	] == cDepto );		
												.and.;
												( x[ ARESULT_POSTO	] == cPosto );																										
												.and.;
												( x[ ARESULT_PROCESSO	] == cProcesso);	
												.and.;
												( x[ ARESULT_PERIODO	] == cPeriodo);	
												.and.;
												( x[ ARESULT_ROTEIRO	] == cRoteiro);	
												.and.;
												( x[ ARESULT_NUM_PAGTO	] == cNumPagto);																																																			
											),;
											(;
												nThoras := SomaHoras( nThoras , x[ ARESULT_HORAS ] ),;
												x[ ARESULT_HORAS ] := 0;
											),;
											NIL;
										);
								}
				bEvalSomaN	:= { |x| IF(;
											(;
												( x[ ARESULT_DATA ] == dData );
												.and.;
												( x[ ARESULT_EVENTO ] == aExTipo[ nX , 5 ] );
												.and.;
												( x[ ARESULT_CC ] == cCusto );
												.and.;
												( x[ ARESULT_TPMARCA ] == cTpMarc );
												.and.;
												( x[ ARESULT_FUNCAO	] == cFuncao);
	  									  		.and.;
												( x[ ARESULT_DEPTO	] == cDepto );		
												.and.;
												( x[ ARESULT_POSTO	] == cPosto );																										
												.and.;
												( x[ ARESULT_PROCESSO	] == cProcesso);	
												.and.;
												( x[ ARESULT_PERIODO	] == cPeriodo);	
												.and.;
												( x[ ARESULT_ROTEIRO	] == cRoteiro);	
												.and.;
												( x[ ARESULT_NUM_PAGTO	] == cNumPagto);																												
											),;
											(;
												nTNhoras := SomaHoras( nTNhoras , x[ ARESULT_HORAS ] ),;
												x[ ARESULT_HORAS ] := 0;
											),;
											NIL;
										);
								}
			Else
				bEvalSomaA	:= { |x| IF(;
											(;
												( x[ ATOTAIS_DATA ] == dData );
												.and.;
												( x[ ATOTAIS_EVENTO_PONTO ] == aExTipo[ nX , 4 ] );
												.and.;
												( x[ ATOTAIS_CENTRO_DE_CUSTO ] == cCusto );
												.and.;
												( x[ ARESULT_FUNCAO	] == cFuncao);
								  				.and.;
												( x[ ARESULT_DEPTO	] == cDepto );		
												.and.;
												( x[ ARESULT_POSTO	] == cPosto );																										
												.and.;
												( x[ ARESULT_PROCESSO	] == cProcesso);	
												.and.;
												( x[ ARESULT_PERIODO	] == cPeriodo);	
												.and.;
												( x[ ARESULT_ROTEIRO	] == cRoteiro);	
												.and.;
												( x[ ARESULT_NUM_PAGTO	] == cNumPagto);																
											),;
											(;
												nThoras := SomaHoras( nThoras , x[ ATOTAIS_HORAS ] ),;
												x[ ATOTAIS_HORAS ] := 0;
											),;
											NIL;
										);
								}
				bEvalSomaN	:= { |x| IF(;
											(;
												( x[ ATOTAIS_DATA ] == dData );
												.and.;
												( x[ ATOTAIS_EVENTO_PONTO ] == aExTipo[ nX , 5 ] );
												.and.;
												( x[ ATOTAIS_CENTRO_DE_CUSTO ] == cCusto ); 
												.and.;
												( x[ ARESULT_FUNCAO	] == cFuncao); 
												.and.;
												( x[ ARESULT_PROCESSO	] == cProcesso);	
												.and.;
												( x[ ARESULT_PERIODO	] == cPeriodo);	
												.and.;
												( x[ ARESULT_ROTEIRO	] == cRoteiro);	
												.and.;
												( x[ ARESULT_NUM_PAGTO	] == cNumPagto);																												
											),;
											(;
												nTNhoras := SomaHoras( nTNhoras , x[ ATOTAIS_HORAS ] ),;
												x[ ATOTAIS_HORAS ] := 0;
											),;
											NIL;
										);
								}
			EndIF
			//--Soma Horas Quando Existir mais de uma Geracao para o mesmo dia
			nFornX	:= Len( aExTipo )
			For nX := 1 To nFornX
				IF !Empty( nThoras )
					IF ( lRotFec )
						aEval( aTotais , bEvalSomaA )
					Else
						aEval( aResult , bEvalSomaA )
					EndIF	
				EndIF
				IF !Empty( nTNhoras )
					IF ( lRotFec )
						aEval( aTotais , bEvalSomaN )
					Else
						aEval( aResult , bEvalSomaN )
					EndIF	
				EndIF
			Next nX
		EndIF

		//-- 1o. para Autorizado e 2o. para Nao Autorizada
		For nN := 1 To 2
			nResto := IF( nN == 1 , nThoras , nTNhoras )
			//-- Aplicar a Tabela de Horas Extras		
			While ( nResto > 0 )
				//--Procura a faixa de horas
				IF ( ( nPos := aScan( aExTipo , { |x| nResto >= x[2] .And. nResto <= x[3] } ) ) > 0 )
					cEvento := aExTipo[ nPos , IF( nN == 1 , 4 , 5 ) ]
					nHoras  := SubHoras( nResto , SubHoras( aExTipo[ nPos , 2 ] , 0.01 ) )
					//--Gerar no Array de Resultado e Totais
					IF !( lRotFec )
						fGeraRes(	@aResult	,; //01 -> Array com os Resultados
									dData		,; //02 -> Data da Gravacao	
									nHoras		,; //03 -> Valor a Ser Gravado	
									cEvento		,; //04 -> Codigo onde Gravar
									cCusto		,; //05 -> Centro de Custo Onde Gravar
									cTpMarc		,; //06 -> Tipo da Marcacao
									lSoma		,; //07 -> Se soma a valor ja Existente
									cPeriodo	,; //08 -> Periodo para a Tolerancia
									0			,; //09 -> Tolerancia
									"H"			,; //10 -> Tipo de Arredondamento a Ser considerado
									lSubstitui	,; //11 -> Substitui a(s) Hora(s) Existente(s) em aResult
									cFuncao		,; //12 -> Funcao
									cDepto		,; //13 -> Depto para gravacao     
									cPosto		,; //14 -> Posto para gravacao									
									cProcesso	,; //15 -> Processo para Gravacao
									cRoteiro	,; //16 -> Roteiro para Gravacao								
									cPeriodo	,; //17 -> Periodo para Gravacao
									cNumPagto	;  //18 -> NumPagto para Gravacao								
								 )
					Else
						IF ( lSubstitui == NIL )
							lSubstitui := !( lSoma )
						EndIF
						fGeraTot(	@aTotais 		,;	//01 -> Array com os Totais do Ponto
									dData			,;	//02 -> Data para Pesquisa e Gravacao no aTotais
									nHoras			,;	//03 -> Horas para Soma ou Geracao
									0   			,;	//04 -> Valor para Soma ou Geracao
									cEvento			,;	//05 -> Evento do Ponto para Pesquisa
									cCusto			,;	//06 -> Centro de Custo para Comparacao
									SRA->RA_FILIAL	,;	//07 -> Filial para Pesquisa no SP9									
									NIL				,;	//08 -> Verba da Folha
									lSubstitui	 	,;	//09 -> Substitui a(s) Hora(s) Existente(s) em aTotais
									cFuncao			,;	//10 -> funcao para Comparacao   
									cDepto			,;  //11 -> Depto para gravacao
									cPosto			,;  //12 -> Posto para gravacao
									cProcesso		,;  //13 -> Processo para Gravacao
									cRoteiro		,;  //14 -> Roteiro para Gravacao								
									cPeriodo		,;  //15 -> Periodo para Gravacao
									cNumPagto		;   //16 -> NumPagto para Gravacao								
								)
					EndIF
					nResto  := SubHoras( nResto , SubHoras( nResto , SubHoras( aExTipo[ nPos , 2 ] , 0.01 ) ) )
				Else
					Exit
				EndIF
			End While
		
		Next nN

	End Sequence
	
EndIF
	
Return( NIL )

/*/
зддддддддддбддддддддддддддддддбддддддбдддддддддддддддддддбддддбдддддддддд©
ЁFun┤┘o    ЁToScheduleOverTimeЁAutor ЁMarinaldo de Jesus ЁDataЁ11/07/2002Ё
цддддддддддеддддддддддддддддддаддддддадддддддддддддддддддаддддадддддддддд╢
ЁDescri┤┘o ЁGerar Horas Extras Escalonads                                Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё< Vide Parametros Formais >									 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ< Vide Parametros Formais >								   	 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGeracao de Horas Extras                                      Ё
юддддддддддаддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function ToScheduleOverTime(	aTabExtra	,;	//01 -> Array contendo os Tipos de Horas Extras
								cTpExtra	,;	//02 -> Tipo de Hora Extra a ser Gerado
								nThoras		,;	//03 -> Numero de Horas Extras Autorizadas
								nTNhoras	,;	//04 -> Numero de Horas Extras Nao Autorizadas
								aResult		,;	//05 -> Array com os Resultados do Apontamento do Dia
								aTotais		,;	//06 -> Array com os Totais Apontados por Evento do Dia
								dData		,;	//07 -> Data da Gravacao
								cRotina		,;	//08 -> Rotina Chamadora da Funcao
								cPeriodo	,;	//09 -> Periodo de Apuracao
								lSoma		,;	//10 -> Soma ao Valor Existente
								cCusto		,;	//11 -> Centro de Custo Para Gravacao
								cTpMarc		,;	//12 -> Tipo de Marcacao
								lSubstitui	,;	//13 -> Se Substitui as Horas Existentes 
								cFuncao		,;  //14 -> Funcao para Gravacao
								cDepto		,;  //15 -> Depto para Gravacao
								cPosto		,;  //16 -> Posto para Gravacao
								cProcesso	,;  //17 -> Processo para Gravacao																								
								cPeriodo	,;  //18 -> Periodo para Gravacao
								cRoteiro	,;  //19 -> Processo para Gravacao								
								cNumPagto	;   //20 -> NumPagto para Gravacao
							)

Local aExTipo		:= {}
Local lAutoriza		:= .F.
Local lRotFec		:= ( cRotina == "FEC" )

Local cEvento
Local cHeKeyAtu
Local cTipoDia

Local nResto
Local nHoras
Local nPos
Local nPosPlus1
Local nPos1
Local nN
Local nLenExt
Local nLenGer
Local nPosTpDia

DEFAULT nThoras			:= 0
DEFAULT nTNhoras		:= 0
DEFAULT __aHeLastGera__	:= {}
DEFAULT __cHeLastKey__	:= "__cHeLastKey__"

//--Gerar Array do Tipo Desejado
aExTipo 	:= GetExTipo( aTabExtra , @cTpExtra )
nLenExt 	:= Len( aExTipo )
cTipoDia	:= GetDiaToEx( cTpExtra )

cHeKeyAtu	:= ( FWCODEMP("SPC") + cFilAnt + SRA->RA_MAT + Dtos( dData ) )
IF !( cHeKeyAtu == __cHeLastKey__ )
	__aHeLastGera__	:= {}
	__cHeLastKey__	:= cHeKeyAtu
	aAdd( __aHeLastGera__ , { cTipoDia , nThoras , nTNhoras , {} } )
	nPosTpDia := Len( __aHeLastGera__ )
Else
	IF ( ( nPosTpDia := aScan( __aHeLastGera__ , { |x| x[1] == cTipoDia } ) ) == 0 )
		aAdd( __aHeLastGera__ , { cTipoDia , 0 , 0 , {} } )
		nPosTpDia := Len( __aHeLastGera__ )
	EndIF
	__aHeLastGera__[ nPosTpDia , 02 ] := SomaHoras( __aHeLastGera__[ nPosTpDia , 02 ] , nThoras	 )
	__aHeLastGera__[ nPosTpDia , 03 ] := SomaHoras( __aHeLastGera__[ nPosTpDia , 03 ] , nTNhoras )
EndIF

//-- 1o. para Autorizado e 2o. para Nao Autorizada
For nN := 1 To 2
	lAutoriza := ( nN == 1 )
	nResto := IF( ( lAutoriza ) , __aHeLastGera__[ nPosTpDia , 02 ] , __aHeLastGera__[ nPosTpDia , 03 ] )
	nPos := 0
	While ( nResto > 0 ) .and. ( ++nPos <= nLenExt )
		//-- Aplicar a Tabela de Horas Extras
		nPosPlus1	:= Min( nPos + 1 , nLenExt )
		nHoras  	:= Min( nResto , SubHoras( aExTipo[ Min( nPosPlus1 , nLenExt ) , 02 ] , aExTipo[ nPos , 02 ] ) )
		nHoras 		:= IF( nHoras == 0 , nResto , nHoras )
		nResto		:= SubHoras( nResto , nHoras )
		cEvento 	:= aExTipo[ nPos , IF( ( lAutoriza ) , 04 , 05 ) ]
		nPos1 		:= 0
		nLenGer 	:= Len( __aHeLastGera__[ nPosTpDia , 04 ] )
		//-- Subtrai da quantidade de Horas remanescentes o total de horas ja enviadas para 
		//-- o aResult
		While ( ++nPos1 <= nLenGer )
			IF ( ;
					__aHeLastGera__[ nPosTpDia , 04 , nPos1 , 01 ] == nPos;
					.and.;
					__aHeLastGera__[ nPosTpDia , 04 , nPos1 , 04 ] == lAutoriza;
					.and.;
					(;
						__aHeLastGera__[ nPosTpDia , 04 , nPos1 , 03 ] <> cEvento;
						.or.;
						__aHeLastGera__[ nPosTpDia , 04 , nPos1 , 05 ] <> cTpMarc;
						.or.;
						__aHeLastGera__[ nPosTpDia , 04 , nPos1 , 06 ] <> cCusto;
						.or.;
						__aHeLastGera__[ nPosTpDia , 04 , nPos1 , 07 ] <> cFuncao;
						.or.;
						__aHeLastGera__[ nPosTpDia , 04 , nPos1 , 08 ] <> cProcesso;
						.or.;
						__aHeLastGera__[ nPosTpDia , 04 , nPos1 , 09 ] <> cPeriodo;
						.or.;
						__aHeLastGera__[ nPosTpDia , 04 , nPos1 , 10 ] <> cRoteiro;
						.or.;
						__aHeLastGera__[ nPosTpDia , 04 , nPos1 , 11 ] <> cNumpagto;																								
					);
				)
				nHoras  := SubHoras( nHoras , __aHeLastGera__[ nPosTpDia , 04 , nPos1 , 02 ] )
			EndIF
		End While  
		//-- Substitui o total de horas da faixa para o evento pelo total de horas calculadas
		IF ( nPos1 := aScan( __aHeLastGera__[ nPosTpDia , 04 ]	, { |x|	x[1] == nPos;
																		.and.;
																		x[3] == cEvento;
																		.and.;
																		x[4] == lAutoriza;
																		.and.;
																		x[5] == cTpMarc;
																		.and.;
																		x[6] == cCusto;
																		.and.;
																		x[7] == cFuncao;
																		.and.;
																		x[8] == cProcesso;
																		.and.;
																		x[9] == cPeriodo;
																		.and.;
																		x[10] == cRoteiro;
																		.and.;
																		x[11] == cNumPagto;																																																																								
												  	   			  };
							);
			 ) > 0
			__aHeLastGera__[ nPosTpDia , 04 , nPos1 , 02 ] := nHoras
		Else
			aAdd( __aHeLastGera__[ nPosTpDia , 04 ] , { nPos , nHoras , cEvento , lAutoriza , cTpMarc , cCusto, cFuncao, cProcesso, cPeriodo, cRoteiro, cNumPagto } )
		EndIF
		//--Gerar no Array de Resultado e Totais
		IF !Empty( nHoras )
			IF !( lRotFec )
				DEFAULT lSubstitui		:= .T.
				fGeraRes(	@aResult			,; //01 -> Array com os Resultados
							dData				,; //02 -> Data da Gravacao	
							nHoras				,; //03 -> Valor a Ser Gravado	
							cEvento				,; //04 -> Codigo onde Gravar
							cCusto				,; //05 -> Centro de Custo Onde Gravar
							cTpMarc				,; //06 -> Tipo da Marcacao
							lSoma				,; //07 -> Se soma a valor ja Existente
							cPeriodo			,; //08 -> Periodo para a Tolerancia
							0   				,; //09 -> Tolerancia
							"H" 				,; //10 -> Tipo de Arredondamento a ser Considerado
							lSubstitui			,; //11 -> Substitui a(s) Hora(s) Existente(s) em aResult
							cFuncao	 			,; //12 -> Funcao
							cDepto				,; //13 -> Depto para gravacao
							cPosto				,; //14 -> Posto para gravacao
							cProcesso			,; //15 -> Processo para Gravacao
							cRoteiro			,; //16 -> Roteiro para Gravacao								
							cPeriodo			,; //17 -> Periodo para Gravacao
							cNumPagto	 		;  //18 -> NumPagto para Gravacao								
						 )
			Else
				IF ( lSubstitui == NIL )
					lSubstitui := !( lSoma )
				EndIF
				fGeraTot(	@aTotais 		,;	//01 -> Array com os Totais do Ponto
							dData			,;	//02 -> Data para Pesquisa e Gravacao no aTotais
							nHoras			,;	//03 -> Horas para Soma ou Geracao
							0   			,;	//04 -> Valor para Soma ou Geracao
							cEvento			,;	//05 -> Evento do Ponto para Pesquisa
							cCusto			,;	//06 -> Centro de Custo para Comparacao
							SRA->RA_FILIAL	,;	//07 -> Filial para Pesquisa no SP9
							NIL				,;	//08 -> Verba da Folha
							lSubstitui	 	,;	//09 -> Substitui a(s) Hora(s) Existente(s) em aTotais
							cFuncao			,;	//10 -> funcao para Comparacao   
							cDepto			,;  //11 -> Depto para gravacao
							cPosto			,;  //12 -> Posto para gravacao
							cPeriodo		,;  //13 -> Periodo para Gravacao
							cRoteiro		,;  //14 -> Processo para Gravacao								
							cNumPagto		;   //15 -> NumPagto para Gravacao
						)
			EndIF
		EndIF
	End While	
Next nN

Return( NIL )

/*/
зддддддддддбдддддддддддддддддддддбдддбддддддддддддддддддбддддбдддддддддд©
ЁFun┤┘o    ЁRstToScheduleOverTimeЁAutЁMarinaldo de JesusЁDataЁ11/03/2003Ё
цддддддддддедддддддддддддддддддддадддаддддддддддддддддддаддддадддддддддд╢
ЁDescri┤┘o ЁReinicializa as Staticas utilizadas em ToScheduleOverTime() Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGenerico													Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function RstToScheduleOverTime()

__aHeLastGera__ := NIL
__cHeLastKey__	:= "__cHeLastKey__"

Return( NIL )

/*/
зддддддддддбддддддддддддддддддбддддддбдддддддддддддддддддбддддбдддддддддд©
ЁFun┤┘o    ЁGetExTipo		  ЁAutor ЁMarinaldo de Jesus ЁDataЁ28/08/2002Ё
цддддддддддеддддддддддддддддддаддддддадддддддддддддддддддаддддадддддддддд╢
ЁDescri┤┘o ЁRetorna Array com o Tipo de Hora Extra a ser utilizado       Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё< Vide Parametros Formais >									 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ< Vide Parametros Formais >								   	 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGeracao de Horas Extras                                      Ё
юддддддддддаддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function GetExTipo( aTabExtra , cTpExtra )

Local aExTipo	:= {}
Local bEval		:= { |x| IF( x[1] == cTpExtra , aAdd( aExTipo , x ) , NIL ) }

aEval( aTabExtra , bEval )

//-- Quando nao Encotrar o Tipo de Hora Extra Exato, Procura o Tipo Correspondente
//-- 5=1;6=2;7=3;8=4	//HE Noturnas/Normais	
//-- B=A;D=C;F=E;H=G	//HE Intervalos Noturnas/Normais
IF Empty( aExTipo )
	Do Case
		Case ( cTpExtra $ "H_G" )			//Tipos de Intervalo Feriado
			IF ( cTpExtra == "H" )			//Hora Extra Intervalo Noturna Feriado
				cTpExtra	:= "8"			//Hora Extra Feriado Noturna
				aEval( aTabExtra , bEval )
				IF Empty( aExTipo )
					cTpExtra	:= "G"    	//Hora Extra Intervalo Diurna Feriado
					aEval( aTabExtra , bEval )
				EndIF
				IF Empty( aExTipo )
					cTpExtra	:= "4"		//Hora Extra Feriado Diurna
					aEval( aTabExtra , bEval )
				EndIF
			ElseIF ( cTpExtra == "G" )		//Hora Extra Intervalo Diurna Feriado
				cTpExtra	:= "4"			//Hora Extra Feriado Diurna
				aEval( aTabExtra , bEval )
			EndIF
		Case ( cTpExtra $ "F_E" )			//Tipos de Intervalo Compensado
			IF ( cTpExtra == "F" )			//Hora Extra Intervalo Noturna Compensado
				cTpExtra	:= "7"			//Hora Extra Compensado Noturna
				aEval( aTabExtra , bEval )
				IF Empty( aExTipo )
					cTpExtra	:= "E"	    //Hora Extra Intervalo Diurna Compensado
					aEval( aTabExtra , bEval )
				EndIF
				IF Empty( aExTipo )
					cTpExtra	:= "3"		//Hora Extra Compensado Diurna
					aEval( aTabExtra , bEval )
				EndIF
			ElseIF ( cTpExtra == "E" )		//Hora Extra Intervalo Diurna Compensado
				cTpExtra := "3"				//Hora Extra Compensado Diurna
				aEval( aTabExtra , bEval )
			EndIF
		Case ( cTpExtra $ "D_C" )			//Tipos de Intervalo DSR
			IF ( cTpExtra == "D" )			//Hora Extra Intervalo Noturna DSR
				cTpExtra	:= "6"			//Hora Extra DSR Noturna
				aEval( aTabExtra , bEval )
				IF Empty( aExTipo )
					cTpExtra := "C"			//Hora Extra Intervalo Diurna DSR
					aEval( aTabExtra , bEval )
				EndIF
				IF Empty( aExTipo )
					cTpExtra := "2"			//Hora Extra DSR Diurna
					aEval( aTabExtra , bEval )
				EndIF
			ElseIF ( cTpExtra == "C" )		//Hora Extra Intervalo Diurna DSR
				cTpExtra := "2"				//Hora Extra DSR Diurna
				aEval( aTabExtra , bEval )
			EndIF
		Case ( cTpExtra $ "B_A" )			//Tipos de Intervalo Normal
			IF ( cTpExtra == "B" )			//Hora Extra Intervalo Noturna Normal
				cTpExtra	:= "5"			//Hora Extra Noturna Normal
				aEval( aTabExtra , bEval )
				IF Empty( aExTipo )
					cTpExtra	:= "A"		//Hora Extra Intervalo Normal
					aEval( aTabExtra , bEval )
				EndIF
				IF Empty( aExTipo )
					cTpExtra := "1"			//Hora Extra Normal
					aEval( aTabExtra , bEval )
				EndIF
			ElseIF ( cTpExtra == "A" )		//Hora Extra Intervalo Normal
				cTpExtra := "1"				//Hora Extra Normal
				aEval( aTabExtra , bEval )
			EndIF	
		OtherWise							//Tipos de Horas Extras
			cTpExtra := IF( Val( cTpExtra ) > 4 , StrZero( Val( cTpExtra ) - 4 , 1 ) , cTpExtra )
			aEval( aTabExtra , bEval )
	EndCase
EndIF

Return( aExTipo )

/*/
зддддддддддбддддддддддддддддддбддддддбдддддддддддддддддддбддддбдддддддддд©
ЁFun┤┘o    ЁGetTpExInt		  ЁAutor ЁMarinaldo de Jesus ЁDataЁ10/09/2003Ё
цддддддддддеддддддддддддддддддаддддддадддддддддддддддддддаддддадддддддддд╢
ЁDescri┤┘o ЁRetorna Tipo de Hora Extra de Intervalo Conforme Tipo do Dia Ё
Ё          Ёou Tipo de Hora Extra										 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё< Vide Parametros Formais >									 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ< Vide Parametros Formais >								   	 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGenerico                                                     Ё
юддддддддддаддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function GetTpExInt( cTpDiaExt , lNoturna )

Local cTpExtInt		:= "A"

DEFAULT cTpDiaExt	:= "S"
DEFAULT lNoturna	:= .F.

Do Case
	Case ( cTpDiaExt $ "F_8_4" ) ; ( cTpExtInt := IF( lNoturna , "H" , "G" ) )	//Feriado
	Case ( cTpDiaExt $ "C_7_3" ) ; ( cTpExtInt := IF( lNoturna , "F" , "E" ) )	//Compensado
	Case ( cTpDiaExt $ "D_6_2" ) ; ( cTpExtInt := IF( lNoturna , "D" , "C" ) )	//DSR
	Case ( cTpDiaExt $ "S_5_1" ) ; ( cTpExtInt := IF( lNoturna , "B" , "A" ) )	//Normal
End Case

Return( cTpExtInt )

/*/
зддддддддддбддддддддддддддддддбддддддбдддддддддддддддддддбддддбдддддддддд©
ЁFun┤┘o    ЁGetDiaToEx		  ЁAutor ЁMarinaldo de Jesus ЁDataЁ22/09/2003Ё
цддддддддддеддддддддддддддддддаддддддадддддддддддддддддддаддддадддддддддд╢
ЁDescri┤┘o ЁRetorna Tipo do Dia de Acordo com o Tipo de Horas Extras     Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё< Vide Parametros Formais >									 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ< Vide Parametros Formais >								   	 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGenerico                                                     Ё
юддддддддддаддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function GetDiaToEx( cTpExtra )

Local cTipoDia	:= ""

DEFAULT cTpExtra := "S"

Do Case
	Case ( cTpExtra $ "F_8_4" ) ; ( cTipoDia := "F" )	//Feriado
	Case ( cTpExtra $ "C_7_3" ) ; ( cTipoDia := "C" )	//Compensado
	Case ( cTpExtra $ "D_6_2" ) ; ( cTipoDia := "D" )	//DSR
	Case ( cTpExtra $ "S_5_1" ) ; ( cTipoDia := "S" )	//Normal
End Case

Return( cTipoDia )

/*/
зддддддддддбдддддддддддддбддддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁfGeraRes     ЁAutor ЁEquipe Advanced RH   Ё Data Ё01/04/1997Ё
цддддддддддедддддддддддддаддддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁGerar no Array a Result os Resultados do Apontamento        Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё< Vide Parametros Formais >								  	Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ< Vide Parametros Formais >								  	Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/  
Function fGeraRes(	aResult		,; //01 -> Array com os Resultados do Dia
					dDtGer		,; //02 -> Data da Geracao
					nHoras		,; //03 -> Numero de Horas Resultantes
					cEvento		,; //04 -> Codigo do Evento
					cCusto		,; //05 -> Centro de Custo a ser Gravado
					cTpMarc		,; //06 -> Tipo de Marcacao
					lSoma		,; //07 -> True para Acumular as Horas
					cPeriodo	,; //08 -> Periodo de Apuracao
					nTole		,; //09 -> Tolerancia
					cArred		,; //10 -> Tipo de Arredondamento a Ser Utilizado
					lSubstitui	,; //11 -> Substitui a(s) Hora(s) Existente(s)
					cFuncao		,; //12 -> Funcao  
  					cDepto		,; //13 -> Depto para gravacao
					cPosto		,; //14 -> Posto para gravacao
					cProcesso	,; //15 -> Periodo para Gravacao
					cRoteiro	,; //16 -> Processo para Gravacao
					cPerApo		,; //17 -> Periodo para Gravacao
					cNumPagto	 ; //18 -> NumPagto para Gravacao								
				  )

Local bAsc
Local nRes

DEFAULT cEvento 	:= ""
DEFAULT nHoras		:= 0
DEFAULT cPeriodo	:= ""
DEFAULT nTole		:= 0

IF !Empty( cEvento ) .and. ( nHoras > 0 ) .and. IF( cPeriodo == "D" , IF( ( nTole > 0 ) , ( nHoras > nTole ) , .T. ) , .T. )
 
	DEFAULT aResult 	:= {}
	DEFAULT dDtGer  	:= dDataBase
	DEFAULT cCusto  	:= Space( GetSx3Cache( "PC_CC"		, "X3_TAMANHO" ) )
	DEFAULT cTpMarc		:= Space( GetSx3Cache( "PC_TPMARCA"	, "X3_TAMANHO" ) )
	DEFAULT lSoma   	:= .F.
	DEFAULT cArred		:= ""
	DEFAULT lSubstitui	:= .F.
	DEFAULT cFuncao  	:= Space( GetSx3Cache( "PC_CODFUNC"	, "X3_TAMANHO" ) )
	DEFAULT cDepto   	:= Space( GetSx3Cache( "PC_DEPTO"	, "X3_TAMANHO" ) )
	DEFAULT cPosto   	:= Space( GetSx3Cache( "PC_POSTO"	, "X3_TAMANHO" ) )
	DEFAULT cProcesso	:= Space( GetSx3Cache( "PC_PROCES"  , "X3_TAMANHO" ) )
	DEFAULT cPerApo 	:= Space( GetSx3Cache( "PC_PERIODO"	, "X3_TAMANHO" ) )
	DEFAULT cRoteiro 	:= Space( GetSx3Cache( "PC_ROTEIR"	, "X3_TAMANHO" ) )
	DEFAULT cNumPagto 	:= Space( GetSx3Cache( "PC_NUMPAG"  , "X3_TAMANHO" ) )

	
	bAsc	:= { |x| 	x[ARESULT_DATA] 	== dDtGer 		.and. ;
						x[ARESULT_EVENTO] 	== cEvento 		.and. ;
						x[ARESULT_CC] 		== cCusto 		.and. ;
						x[ARESULT_TPMARCA] 	== cTpMarc 		.and. ;
						x[ARESULT_FUNCAO] 	== cFuncao  	.and. ;
						x[ARESULT_DEPTO] 	== cDepto   	.and. ;						
						x[ARESULT_POSTO] 	== cPosto   	.and. ;
						x[ARESULT_PROCESSO]	== cProcesso	.and. ;
						x[ARESULT_PERIODO] 	== cPerApo  	.and. ;
						x[ARESULT_ROTEIRO] 	== cRoteiro  	.and. ;																								
						x[ARESULT_NUM_PAGTO] == cNumPagto   		  ;																														
				}

	nRes	:= 0

	lSoma := IF( lSoma .and. lSubstitui , !( lSubstitui ) , lSoma )
	IF ( ( lSoma .or. lSubstitui ) .and. ( nRes := aScan( aResult , bAsc  ) ) > 0 )
		IF ( lSoma )
			aResult[ nRes , ARESULT_HORAS ] := SomaHoras( aResult[ nRes , ARESULT_HORAS ] , nHoras )
		ElseIF ( lSubstitui )
			aResult[ nRes , ARESULT_HORAS ] := nHoras
		EndIF
	Else
		aAdd( aResult , Array( ELEMENTOS_ARESULT ) )
		nRes := Len( aResult )
		aResult[ nRes , ARESULT_DATA 		] := dDtGer			//01 - Data da Geracao
		aResult[ nRes , ARESULT_EVENTO		] := cEvento		//02 - Codigo do Evento
		aResult[ nRes , ARESULT_HORAS		] := nHoras			//03 - Horas
		aResult[ nRes , ARESULT_CC			] := cCusto			//04 - Centro de Custo
		aResult[ nRes , ARESULT_TPMARCA		] := cTpMarc		//05 - Tipo da Marcacao
		aResult[ nRes , ARESULT_ARRED		] := cArred			//06 - Tipo de Arredondamento a Ser Utilizado
		aResult[ nRes , ARESULT_DTOS_DATA	] := Dtos( dDtGer )	//07 - String de Data
		aResult[ nRes , ARESULT_NUM_ABO_HRS	] := 0				//08 - Qtde Horas Abonadas do Evento
		aResult[ nRes , ARESULT_RESULT_APO	] := {}				//09 - Array de Horarios Abonados para o Evento
		aResult[ nRes , ARESULT_FUNCAO	    ] := cFuncao		//10 - Funcao
		aResult[ nRes , ARESULT_DEPTO	    ] := cDepto			//15 - Depto 
		aResult[ nRes , ARESULT_POSTO	    ] := cPosto			//16 - Posto 
		aResult[ nRes , ARESULT_PROCESSO    ] := cProcesso		//11 - Processo
		aResult[ nRes , ARESULT_PERIODO	    ] := cPerApo 		//12 - Periodo
		aResult[ nRes , ARESULT_ROTEIRO	    ] := cRoteiro		//13 - Roteiro 	
		aResult[ nRes , ARESULT_NUM_PAGTO   ] := cNumPagto		//14 - NumPagto			
	EndIF

EndIF

Return( NIL )

/*/
зддддддддддбдддддддддддддбддддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁAjustaResult ЁAutor ЁMarinaldo de Jesus   Ё Data Ё18/07/2004Ё
цддддддддддедддддддддддддаддддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁAjustar as Horas em aResult os Resultados do Apontamento    Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё< Vide Parametros Formais >								  	Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ< Vide Parametros Formais >								  	Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function AjustaResult( aResult )

Local aResAux
Local nRes
Local nResults

/*
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Acertando as Horas                                          Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды*/
IF ( ( nResults := Len( aResult ) ) > 0 )
	For nRes := 1 To nResults
		/*
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Nao Mexer no Calculo abaixo. Ele eh utilizado para   efetuarЁ
		Ё a correta conversao das horas que ateh este ponto estao  comЁ
		Ё mais de 2 casas decimais ( Necessario para que o calculo dasЁ
		Ё Horas de Adicional Noturno Fiquem Ok )                      Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды*/
		aResult[ nRes , ARESULT_HORAS ] := __TimeSum( __TimeSum( aResult[ nRes , ARESULT_HORAS ] , 0 ) , 0 )
	Next nRes
	/*
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Remonta o aResult Eliminaldo Apontamentos Zerados           Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды*/
	IF ( aScan( aResult , { |x| x[ ARESULT_HORAS ] == 0 } ) > 0 )
		aResAux := aClone( aResult )
		aResult	:= {}
		For nRes := 1 To nResults
			IF !Empty( aResAux[ nRes , ARESULT_HORAS ] )
				aAdd( aResult , aClone( aResAux[ nRes ] ) )
			EndIF
		Next nRes
	EndIF
EndIF	

Return( NIL )

/*/
зддддддддддбдддддддддддддбддддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁfGeraTot     ЁAutor ЁMarinaldo de Jesus   Ё Data Ё24/09/2002Ё
цддддддддддедддддддддддддаддддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁGerar no Array aTotais os Totais Apontado					Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё< Vide Parametros Formais >								  	Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ< Vide Parametros Formais >								  	Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function fGeraTot(	aTotais 	,;	//01 -> Array com os Totais do Ponto
					dData		,;	//02 -> Data para Pesquisa e Gravacao no aTotais
					nHoras		,;	//03 -> Horas para Soma ou Geracao
					nValor		,;	//04 -> Valor para Soma ou Geracao
					cEvento		,;	//05 -> Evento do Ponto para Pesquisa
					cCusto		,;	//06 -> Centro de Custo para Comparacao
					cFil		,;	//07 -> Filial para Pesquisa no SP9
					cVerba		,;	//08 -> Verba da Folha
					lSubstitui	,;	//09 -> Substitui a(s) Hora(s) Existente(s) em aTotais  
					cFuncao		,;	//10 -> funcao para Comparacao   
					cDepto		,;	//11 -> Depto  para Comparacao   
					cPosto 		,;	//12 -> Posto  para Comparacao   
					cProcesso	,;	//13 -> Processo para Comparacao  
					cRoteiro	,;	//14 -> Roteiro para Comparacao   					 
					cPeriodo	,;	//15 -> Periodo para Comparacao   
					cNumPagto	 ;	//16 -> NumPagto para Comparacao   
				  )

Local bAsc		:= { || .F. }
Local nPos		:= 0

DEFAULT aTotais		:= {}
DEFAULT dData		:= Ctod("//")
DEFAULT nHoras		:= 0
DEFAULT nValor		:= 0
DEFAULT cEvento		:= Space( GetSx3Cache( "PB_PD"	, "X3_TAMANHO" ) )
DEFAULT cCusto		:= Space( GetSx3Cache( "PB_CC"	, "X3_TAMANHO" ) )
DEFAULT cFil		:= fFilFunc( "SP9" )
DEFAULT cVerba		:= PosSP9( cEvento , cFil , "P9_CODFOL" , 1 )
DEFAULT lSubstitui	:= .F.
DEFAULT cFuncao		:= Space( GetSx3Cache( "PB_CODFUNC"	, "X3_TAMANHO" ) )
DEFAULT cDepto   	:= Space( GetSx3Cache( "PC_DEPTO"	, "X3_TAMANHO" ) )
DEFAULT cPosto   	:= Space( GetSx3Cache( "PC_POSTO"	, "X3_TAMANHO" ) )
DEFAULT cProcesso	:= Space( GetSx3Cache( "PC_PROCES"  , "X3_TAMANHO" ) )
DEFAULT cPeriodo 	:= Space( GetSx3Cache( "PC_PERIODO"	, "X3_TAMANHO" ) )
DEFAULT cRoteiro 	:= Space( GetSx3Cache( "PC_ROTEIR"	, "X3_TAMANHO" ) )
DEFAULT cNumPagto 	:= Space( GetSx3Cache( "PC_NUMPAG"  , "X3_TAMANHO" ) )

bAsc := { |x|	(;
					( x[ATOTAIS_EVENTO_PONTO 		] 	== cEvento 		);
					.and.;
					( x[ATOTAIS_DATA				]	== dData 		);
					.and.;
					( x[ATOTAIS_CENTRO_DE_CUSTO 	]	== cCusto		);
					.and.;
					( x[ATOTAIS_FUNCAO				]	== cFuncao 		);
					.and.;
					( x[ATOTAIS_DEPTO				] 	== cDepto 		);		
					.and.;
					( x[ATOTAIS_POSTO				] 	== cPosto		);																										
					.and.;
					( x[ATOTAIS_PROCESSO			] 	== cProcesso	);	
					.and.;
					( x[ATOTAIS_PERIODO				] 	== cPeriodo		);	
					.and.;
					( x[ATOTAIS_ROTEIRO	   			] 	== cRoteiro		);	
					.and.;
					( x[ATOTAIS_NUM_PAGTO  			] 	== cNumPagto	);
				);
		}

IF ( ( nPos := aScan( aTotais , bAsc ) ) > 0 )
	IF ( lSubstitui )
		aTotais[ nPos , ATOTAIS_HORAS ] := nHoras
		aTotais[ nPos , ATOTAIS_VALOR ] := nValor
	Else
	    //aTotais[ nPos , ATOTAIS_HORAS ] := SomaHoras( aTotais[ nPos , ATOTAIS_HORAS] , nHoras )
	    aTotais[ nPos , ATOTAIS_HORAS ] := aTotais[ nPos , ATOTAIS_HORAS] + nHoras
		aTotais[ nPos , ATOTAIS_VALOR ] += nValor
	EndIF
Else
	aAdd( aTotais , Array( ELEMENTOS_DO_ATOTAIS ) )
	nPos := Len( aTotais )
	aTotais[ nPos , ATOTAIS_DATA			] := dData				//01 - Data do Evento
	aTotais[ nPos , ATOTAIS_EVENTO_PONTO	] := cEvento			//02 - Codigo do Evento
	aTotais[ nPos , ATOTAIS_HORAS			] := nHoras				//03 - Quantidade do Evento
	aTotais[ nPos , ATOTAIS_CODIGO_FOLHA	] := cVerba				//04 - Codigo para a Folha
	aTotais[ nPos , ATOTAIS_CENTRO_DE_CUSTO	] := cCusto				//05 - Centro de Custo do Evento
	aTotais[ nPos , ATOTAIS_VALOR			] := nValor				//06 - Valor do Evento
	aTotais[ nPos , ATOTAIS_DTOS_DATA		] := Dtos( dData )		//07 - String de Data
	aTotais[ nPos , ATOTAIS_FUNCAO			] := cFuncao			//08 - Funcao do Evento
	aTotais[ nPos , ATOTAIS_DEPTO 			] := cDepto 			//09 - Depto  do Evento
	aTotais[ nPos , ATOTAIS_POSTO 			] := cPosto 			//10 - Posto  do Evento
	aTotais[ nPos , ATOTAIS_PROCESSO 		] := cProcesso			//11 - Processo do Evento
	aTotais[ nPos , ATOTAIS_PERIODO	 		] := cPeriodo 			//12 - Periodo do Evento
	aTotais[ nPos , ATOTAIS_ROTEIRO			] := cRoteiro 			//13 - Roteiro do Evento	
	aTotais[ nPos , ATOTAIS_NUM_PAGTO		] := cNumPagto			//14 - NumPagto do Evento
			
EndIF

Return( nPos )

/*/
зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁfDiasFolgaЁ Autor ЁEquipe Advanced RH     Ё Data Ё11/02/1999Ё
цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁAltera aTabCalend de Forma a Transformar o Dia em DSR       Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   ЁfDiasFolga(aMarcacoes,aTabCalend,dPerIni,dPerFim...)		Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGenerico                                                    Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function fDiasFolga(	aMarcacoes		,;	//01 -> Array padrao contendo as marcacoes           
						aTabCalend		,;	//02 -> Array padrao contendo o calendario do func.  
						dPerIni			,;	//03 -> Inicio do Periodo de Apontamento             
						dPerFim			,;	//04 -> Final do Periodo de Apontamento              
						cCodDsrAutPa	,;	//05 -> Codigo do DSR Ult. Semana do Periodo Anterior
						lAcumulado		,;	//06 -> Se a Pesquisa deve ser Feita nos Acumulados  
						lGrava			 ;	//07 -> Nao Gravar o Evento
					)

Local aFaltas		:= {}
Local aDomingo		:= {}
Local dDataApo		:= ""
Local cGeraDSR		:= "N"
Local cUltDataApo	:= ""
Local cUltDtaDom	:= ""
Local cAliasPesq	:= "SPC"
Local cFilSRA		:= NIL 
Local cMatSRA		:= NIL 
Local cPrefixo		:= ""
Local cTipAfas		:= ""
Local cMsgErr		:= ""
Local dData			:= Ctod("//")
Local dUltDiaTab	:= dData
Local dIniAfas		:= dData
Local dFimAfas		:= dData
Local lCodDSRAutPa	:= .F.
Local lGerDSRAutPa	:= .F.
Local lRet			:= .F.
Local lLock			:= .F.
Local nDias			:= 0
Local nCount		:= 0
Local nX			:= 0
Local nPos			:= 0
Local nPos2			:= 0
Local nProxD		:= 0
Local nCt			:= 0	
Local nFornCt		:= 0
Local nLenTab		:= 0
Local nRecDSRAutPa	:= 0

DEFAULT aMarcacoes	:= {}
DEFAULT aTabCalend	:= {}
DEFAULT dPerIni		:= dDataBase
DEFAULT dPerFim		:= dDataBase
DEFAULT cCodDsrAutPa:= ""
DEFAULT lAcumulado	:= .F.
DEFAULT lGrava		:= .T.
DEFAULT cFilSRA		:= SRA->RA_FILIAL
DEFAULT cMatSRA		:= SRA->RA_MAT

IF lAcumulado
	cAliasPesq	:= "SPH"
EndIF

cAliasPesq		:= Upper( AllTrim( cAliasPesq ) )
cPrefixo		:= ( PrefixoCpo( cAliasPesq ) + "_" )
nLenTab			:= Len(aTabCalend)
nDias			:= ( ( dPerFim - dPerIni ) + 1 )
dData			:= dPerIni
lCodDSRAutPa	:= !( cCodDsrAutPa == "@" .or. Empty(cCodDsrAutPa) )
cUltDataApo		:= aTabCalend[nLenTab,CALEND_POS_DATA_APO]


dUltDiaTab	:= aTabCalend[ Len(aTabCalend) , CALEND_POS_DATA ]

aEval( aTabCalend , {;
						 |x,y|;
						 		 IF( x[CALEND_POS_TIPO_MARC]=="1E" .and. Dow(x[CALEND_POS_DATA]) == 1 ,;
						 		 	 cUltOrdDom := aTabCalend[y,CALEND_POS_ORDEM] ,;
						 		 	 NIL;
						 		 	);
					 };
	  )

For nCount := 1 To nDias

	/*/
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Guarda a Data de Apontamento da Tabela					  Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	IF (nPos := aScan(aTabCalend, {|x| x[CALEND_POS_DATA_APO] == dData})) > 0
		dData := aTabCalend[nPos,CALEND_POS_DATA]
	Else
		dData++
		Loop
	EndIF
    
	dDataApo	:= dData
	
	IF Dow(dUltDiaTab) != 1
		IF lCodDSRAutPa
			IF ( cAliasPesq )->( MsSeek( cFilSRA + cMatSRA + cCodDsrAutPa + Dtos(dPerFim+1) ) )
				nRecDSRAutPa := ( cAliasPesq )->( Recno() )
			EndIF
		EndIF
	EndIF

	/*/
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Verifica as Trocas de Turno								  Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	IF ( fBscTnoFolga(cFilSRA,aTabCalend[nPos,CALEND_POS_TURNO]) # "S" )

		/*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Se a semana iniciou-se com um turno com DSR automatico,iden Ё
		Ё tifica-se a parte da semana com DSR automatico ate a data	  Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		IF	 cGeraDSR == "S"   
		    //-- Calcula a segunda-feira que antecedeu a data atual
		    aAdd( aDomingo,{ dData , If( Dow(dData) == 1, (dData-6), dData -( Dow(dData) - 2 )  ) } )
		EndIF
		cGeraDSR := "N"
		dData++
		Loop
	EndIF

	cGeraDSR := "S"

	/*/
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Obtem o Inicio e Fim de Cada Semana para Verifica se a FaltaЁ
	Ё Esta ou Nao Dentro da Mesma								  Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	IF ( Dow(dData) == 1 )
		aAdd(aDomingo,{dData,dData-6})
	ElseIF ( dData == dPerFim )
		/*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Verifica qual o Proximo Domingo							  Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		While ( Dow( dData ) != 1 )
			++dData
		End While
		aAdd(aDomingo,{dData,dData-6})
		dData := dPerFim
	EndIF

	/*/
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Marca┤└o anterior a Admiss└o.                               Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	IF SRA->(;
				( RA_SITFOLH == Space( GetSx3Cache( "RA_SITFOLH" , "X3_TAMANHO" ) ) );
				.and.;
				( dData < fDtaAdmis() );
			)
		dData++
		Loop
	EndIF

	/*/
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Marca┤└o posterior a Demiss└o ou Transferencia              Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	IF SRA->( RA_SITFOLH $ "DЗT" .and. !Empty(RA_DEMISSA) .and. dData > RA_DEMISSA )
		dData ++
		Loop
	EndIF

	/*/
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Marca┤└o dentro de intervalo de Afastamento.                Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	cTipAfas	:=	aTabCalend[ nPos , CALEND_POS_TIP_AFAST ]
	dIniAfas	:=	aTabCalend[ nPos , CALEND_POS_INI_AFAST ]
	dFimAfas	:=	aTabCalend[ nPos , CALEND_POS_FIM_AFAST ]
	IF aTabCalend[ nPos , CALEND_POS_AFAST ] .and. ;
		( dData >= dIniAfas .And. dData <= IF( Empty( dFimAfas ) , dData , dFimAfas ) )
		IF ( ( SR6->R6_APODFER == "S" ) .And. ( cTipAfas == "F" ) )
			dData := dData
		Else
			dData ++
			Loop
		EndIF
	EndIF

	/*
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Verifica quais os dias sao faltas, caso este dia nao tenha  Ё
	| lancamento e o mesmo seja um feriado, ele nao e considerado |
	| uma falta.												  |
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды	
	*/
	If !aTabCalend[ nPos, CALEND_POS_FERIADO]
		IF ( nPos := aScan( aMarcacoes, { |x| x[AMARC_DATAAPO] == dDataApo } ) ) == 0 
				aAdd(aFaltas, dData )
		EndIF
	EndIf	
	
Next nCount

nFornCt := Len(aDomingo)
For nCt := 1 To nFornCt

	dData := aDomingo[nCt,1]

	/*/
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Verifica a Qual Semana a Falta Pertence                     Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	IF ( nPos := aScan( aFaltas, {|x| x <= aDomingo[nCt,1] .and. x >= aDomingo[nCt,2] } ) ) > 0
		dData := aFaltas[nPos]
	EndIF

	/*/
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Se for a Primeira Semana Verifica se Ja Teve DSR na   UltimaЁ
	Ё Semana do Periodo de Apontamento Anterior e Nao Gera o   DSRЁ
	Ё Automatico para a Semana.									  Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	IF ( ( nCt == 1 ) .and. ( lCodDSRAutPa ) )
		IF ( cAliasPesq )->( MsSeek( cFilSRA + cMatSRa + cCodDsrAutPa + Dtos(dPerIni) ) )
			Loop
		EndIF
	EndIF

	/*/
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Se ja houver excecao para a data em questao nao altera o  HoЁ
	Ё rario														  Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	IF ( nPos2 := aScan(aTabCalend, { |x| x[CALEND_POS_DATA_APO] == dData } ) ) > 0 .and.;
	   ( fBscTnoFolga(cFilSRA,aTabCalend[nPos2,CALEND_POS_TURNO]) == "S" )
		nX		:= nPos2
		lRet	:= .T.
		While ( ( nX <= nLenTab ) .and. aTabCalend[nPos2,CALEND_POS_DATA_APO] == aTabCalend[nX,CALEND_POS_DATA_APO] )
			IF aTabCalend[nX,CALEND_POS_EXCECAO] # "E"
				/*/
				зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				Ё Atualiza a folga diretamente em aTabCalend				  Ё
				юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
				IF ( ( nX - nPos2 ) < 2 )
					aTabCalend[ nX , CALEND_POS_HORA        ] := 0											//Hora
					aTabCalend[ nX , CALEND_POS_TIPO_DIA    ] := "D"										//Tipo do Dia
					aTabCalend[ nX , CALEND_POS_HRS_INTER   ] := 0											//Intervalo
					aTabCalend[ nX , CALEND_POS_MOT_EXECAO  ] := STR0101									//*/** DSR Automatico ***
					aTabCalend[ nX , CALEND_POS_TIPO_HE_NOR ] := SR6->(IF(Empty(R6_TPEXT),"2",R6_TPEXT))	//Tipo de Horas Extras Normais
					aTabCalend[ nX , CALEND_POS_TIPO_HE_NOT ] := SR6->(IF(Empty(R6_TPEXTN),"6",R6_TPEXTN))	//Tipo de Horas Extras Noturnas
				Else
					/*/
					зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
					Ё Elimina os Elementos que Nao serao Utilizados em aTabCalend Ё
					юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
					aDel(aTabCalend,nX)
					aSize(aTabCalend,--nLenTab)
					--nX
				EndIF	
			EndIF
			nX++
		End While
		/*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Quando For a Ultima Semana e o Dia Nao For um Domingo e   TiЁ
		Ёver Sido Gerado um DSR Grava o Evento de DSR Automatico   MesЁ
		ЁAnterior Para o Proximo Mes								  Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		IF ( ( Dow(dUltDiaTab) != 1 ) .and. !( lAcumulado ) .and. ( lGrava ) )
			IF ( ( lCodDSRAutPa ) .and. ( aTabCalend[ nPos2 , CALEND_POS_DATA_APO ] >= cUltDtaDom ) .and. ( aTabCalend[ nPos2 , CALEND_POS_DATA_APO ] <= cUltDataApo ) )
				lGerDSRAutPa := .T.
				IF(  Dow( aTabCalend[ nPos2 , CALEND_POS_DATA ] ) == 1 )
					IF ( ( nProxD := aScan( aTabCalend , { |x| x[CALEND_POS_DATA] == ( aTabCalend[ nPos2 , CALEND_POS_DATA ] + 1 ) .and. x[CALEND_POS_TIPO_MARC] == "1E" } ) ) > 0 )
						/*/
						зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
						Ё Nao Gera quando for o Domingo da Penultima Semana		      Ё
						юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
						lGerDSRAutPa := !( Dow( aTabCalend[ nProxD , CALEND_POS_DATA ] ) == 2 ) 
					EndIF
				EndIF	
				IF ( lGerDSRAutPa )
					IF !Empty( nRecDSRAutPa )
						( cAliasPesq )->( dbGoto( nRecDSRAutPa ) )
						lLock := ( cAliasPesq )->( RecLock( cAliasPesq , .F. , .F. ) )
					Else
						lLock := RecLock( cAliasPesq , .T. , .F. )
					EndIF
					IF ( lLock )
						( cAliasPesq )->( &(cPrefixo+"FILIAL")	)	:= cFilSRA
						( cAliasPesq )->( &(cPrefixo+"MAT")		)	:= cMatSRA
						( cAliasPesq )->( &(cPrefixo+"DATA")	)	:= ( dPerFim + 1 )
						( cAliasPesq )->( &(cPrefixo+"PD")		)	:= cCodDsrAutPa
						( cAliasPesq )->( &(cPrefixo+"CC")		)	:= aTabCalend[ Len(aTabCalend), CALEND_POS_CC 		]
						( cAliasPesq )->( &(cPrefixo+"CODFUNC")	)	:= aTabCalend[ Len(aTabCalend), CALEND_POS_CODFUNC  ]
						( cAliasPesq )->( &(cPrefixo+"DEPTO")	)	:= aTabCalend[ Len(aTabCalend), CALEND_POS_DEPTO	]
						( cAliasPesq )->( &(cPrefixo+"POSTO")	)	:= aTabCalend[ Len(aTabCalend), CALEND_POS_POSTO 	]
						( cAliasPesq )->( &(cPrefixo+"PROCES")	)	:= aTabCalend[ Len(aTabCalend), CALEND_POS_PROCESSO ]
						( cAliasPesq )->( &(cPrefixo+"PERIODO")	)	:= aTabCalend[ Len(aTabCalend), CALEND_POS_PERIODO  ]
						( cAliasPesq )->( &(cPrefixo+"ROTEIR")	)	:= aTabCalend[ Len(aTabCalend), CALEND_POS_ROTEIRO 	]
						( cAliasPesq )->( &(cPrefixo+"NUMPAG")	)	:= aTabCalend[ Len(aTabCalend), CALEND_POS_NUM_PAGTO]
						( cAliasPesq )->( &(cPrefixo+"QUANTC")	)	:= 0.01
						( cAliasPesq )->( MsUnLock() )
					EndIF
				EndIF
			EndIF
		EndIF
	EndIF
Next

/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
ЁQuando nao Houver DSR Automatico a Ser Gerado e Ja Existir  oЁ
ЁEvento, Exclui.											  Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
IF ( !( lAcumulado ) .and. ( lGrava ) )
	IF ( !( lGerDSRAutPa ) .and. !Empty( nRecDSRAutPa ) )
		( cAliasPesq )->( dbGoto( nRecDSRAutPa ) )
		IF ( cAliasPesq )->( RecLock( cAliasPesq , .F. , .F. ) )
			IF !( cAliasPesq )->( FkDelete( @cMsgErr ) )
				( cAliasPesq )->( RollBackDelTran( cMsgErr ) )
			EndIF
			( cAliasPesq )->( MsUnLock() )
		EndIF	
	EndIF
EndIF

Return( lRet )

/*/
зддддддддддбдддддддддддддбдддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁfBscTnoFolga ЁAutorЁ Equipe Advanced RH   Ё Data Ё10/02/1999Ё
цддддддддддедддддддддддддадддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o Ё Retorna (S/N) parametro do Turno - 1a.Falta da Semana=FolgaЁ
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   ЁfBscTnoFolga( cFil , cTno )                                 Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       Ё fDiasFolga()	                                            Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function fBscTnoFolga( cFil , cTno )
Return( PosSR6( cTno , cFil , "R6_ASFOLGA" , 01 ) )

/*/
зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o	   ЁPosSP9	  Ё Autor Ё Marinaldo de Jesus	  Ё Data Ё17/01/2003Ё
цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢
ЁSintaxe   Ё< vide parametros formais >									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ< vide parametros formais >									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁcCompKey	= Chave Complementar para Pesquisa			  	Ё
Ё          ЁcFil    	= Filial do Evento que deseja 	 			  	Ё
Ё          ЁcCampo  	= Campo  do Evento que Deseja Pesquisar 		Ё
Ё          ЁnOrdem  	= Ordem  da Pesquisa                    		Ё
Ё          ЁlMsGoto 	= Se Deve Reposicionar Recno            		Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso	   Ё Generico 													Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function PosSP9( cCompKey , cFil , uCampo , nOrdem , lMsGoto )
DEFAULT lMsGoto := .T.
Return( PosAlias( "SP9" , cCompKey , cFil , uCampo , nOrdem , lMsGoto ) )

/*/
зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o	   ЁPosSPA	  Ё Autor Ё Marinaldo de Jesus	  Ё Data Ё17/01/2003Ё
цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁPosiciona no Evento Desejado no SPA							Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё< vide parametros formais >									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ< vide parametros formais >									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso	   ЁGenerico 													Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function PosSPA( cCompKey , cFil , uCampo , nOrdem , lMsGoto )
DEFAULT lMsGoto := .T.
Return( PosAlias( "SPA" , cCompKey , cFil , uCampo , nOrdem , lMsGoto ) )

/*/
зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o	   ЁPosSR6	  Ё Autor Ё Marinaldo de Jesus	  Ё Data Ё17/01/2003Ё
цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁPosiciona no Turno Desejado no SR6							Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё< vide parametros formais >									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ< vide parametros formais >									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso	   ЁGenerico 													Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function PosSR6( cCompKey , cFil , uCampo , nOrdem , lMsGoto )
DEFAULT lMsGoto := .T.
Return( PosAlias( "SR6" , cCompKey , cFil , uCampo , nOrdem , lMsGoto ) )

/*/
зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o	   ЁPosSP6	  Ё Autor Ё Marinaldo de Jesus	  Ё Data Ё17/01/2003Ё
цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁPosiciona no Abono Desejado no SP6						    Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё< vide parametros formais >									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ< vide parametros formais >									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso	   ЁGenerico 													Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function PosSP6( cCompKey , cFil , uCampo , nOrdem , lMsGoto )
DEFAULT lMsGoto := .T.
Return( PosAlias( "SP6" , cCompKey , cFil , uCampo , nOrdem , lMsGoto ) )

/*/
зддддддддддбддддддддддддбдддддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁfQualSeq    Ё Autor ЁMarinaldo de Jesus    Ё Data Ё26/10/2000Ё
цддддддддддеддддддддддддадддддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁRetorna o numero da Seq do Turno de Acordo com a Data InicialЁ
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   ЁfQualSeq( aTabCalend , aTabPadrao , dPerIni , cTurno )		 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁaTabCalend -> Calendario do Periodo Atual          		     Ё
Ё          ЁaTabPadrao -> Calendario Padrao                    		     Ё
Ё          ЁdPerIni    -> Data do Periodo Inicial para achar a Seq.		 Ё
Ё          ЁcTurno     -> Turno Atual do Funcionario           		     Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁcSeq - Sequencia Inicial da Tabela de Horario Padrao		 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁObserva┤└oЁ                                                      	     Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGenerico                                                     Ё
юддддддддддаддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function fQualSeq( aTabCalend , aTabPadrao , dPerIni , cTurno )

Local aSeq		:= {}
Local cSeq		:= ""
Local cFil		:= xFilial( "SPJ" , SRA->RA_FILIAL )
Local dQualSeg  := dPerIni
Local dSegAtu   := Ctod('//')
Local dSvSegAt  := Ctod('//')
Local nPosTab	:= 0
Local nSegund   := 0
Local nSvPosT	:= 0
Local nX		:= 0
Local nFornX	:= 0

cTurno := IF( cTurno == NIL , SRA->RA_TNOTRAB , cTurno )

nPosTab := aScan( aTabCalend , { |x| x[CALEND_POS_TIPO_MARC] == "1E" } )

IF ( nPosTab > 0 )
	dSegAtu := aTabCalend[ nPosTab , CALEND_POS_DATA 		]
	cSeq	:= aTabCalend[ nPosTab , CALEND_POS_SEQ_TURNO	]
	cTurno	:= aTabCalend[ nPosTab , CALEND_POS_TURNO		]
Else
	cSeq	:= SRA->RA_SEQTURN
	dSegAtu := dPerIni
EndIF

IF ( ( nPosTab := aScan( aTabPadrao , { |x| x[1] == cFil .and. x[ 2 ] == cTurno } ) ) > 0 )
	nFornX := Len( aTabPadrao[ nPosTab , 3 ] )
	For nX := 1 To nFornX
		IF ( aScan( aSeq , { |x| x[ 1 ] == aTabPadrao[ nPosTab , 3 , nX , 19 ] } ) == 0 )
			aAdd( aSeq , { aTabPadrao[ nPosTab , 3 , nX , 19 ] , '' } )
		EndIF
	Next nX
EndIF

IF ( Dow( dQualSeg ) != 2 )
	While ( Dow( --dQualSeg ) != 2 )
	End While
EndIF

IF ( Dow( dSegAtu ) != 2 )
	While ( Dow( --dSegAtu ) != 2 )
	End While
EndIF

IF ( !Empty( aSeq ) .and. ( Len( aSeq ) > 1 ) )
	IF ( ( nPosTab := aScan( aSeq, { |x| x[ 1 ] == cSeq } ) ) > 0 )
       	aSeq[ nPosTab , 2 ] := dSegAtu
		nSvPosT	 := nPosTab
        dSvSegAt := dSegAtu
		While ( ++nPosTab <= Len( aSeq ) )
			aSeq[ nPosTab , 2 ] := ( dSegAtu := ( dSegAtu + 7 ) )
		End While
		nPosTab := nSvPosT
        dSegAtu := dSvSegAt
		While ( --nPosTab >= 1 )
        	aSeq[ nPosTab , 2 ] := ( dSegAtu := ( dSegAtu - 7 ) )
		End While
		dSegAtu := dSvSegAt
		IF ( ( nTotSeq := Len( aSeq ) ) > 1 )
			nPosTab := nSvPosT
            IF ( dSegAtu > dQualSeg )
	            nSegund := ( dSegAtu - dQualSeg ) / 7
       			While ( --nSegund >= 0 )
					IF ( nPosTab == 1 )
						nPosTab := nTotSeq
					Else
						--nPosTab
					EndIF
				End While
			Else
                nSegund := ( dQualSeg - dSegAtu ) / 7
                While ( --nSegund >= 0 )
					IF ( nPosTab == nTotSeq )
						nPosTab := 1
					Else
						++nPosTab
					EndIF
				End While
			EndIF
            cSeq := aSeq[ nPosTab , 1 ]
        Else
			cSeq := aSeq[ 1 , 1 ]
		EndIF
	EndIF
EndIF

Return( cSeq )

/*/
зддддддддддбддддддддддддбдддддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁfHrsTrabGat Ё Autor ЁMarinaldo de Jesus    Ё Data Ё24/10/2000Ё
цддддддддддеддддддддддддадддддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁCalcula Total de Horas da Tabela de Horario Padrao		     Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   ЁfHrsTrabGat()												 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁcTipo  -> "H"oras, "I"ntervalo, "T"otal de Horas			 Ё
Ё          ЁcAlias -> "SPJ" Tabela de Horario Padrao ou "SP2" Excecoes	 Ё
Ё          ЁcObj   -> "GD" GetDatos, "MB" mBrowse ou "DB" Arquivo		 Ё
Ё          ЁcInt   -> Quando cTipo = "I", qual Intervalo "1", "2" ou "3" Ё
Ё          Ё          Quando cTipo = "H", qual Periodo "1","2","3" ou "4"Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁnHoras									                     Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁObserva┤└oЁ                                                      	     Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGatilho                                                      Ё
юддддддддддаддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function 		fHrsTrabGat( cTipo , cAlias , cObj , cInt, lSR6 )

Local nHoras		:= 0
Local cVar			:= IF( cObj == "DB" , "" , Upper( AllTrim( ReadVar() ) ) )
Local cPrefixo		:= ""
Local dE1			:= dDataBase
Local dS1			:= Ctod('//')
Local dE2			:= Ctod('//')
Local dS2			:= Ctod('//')
Local dE3			:= Ctod('//')
Local dS3			:= Ctod('//')
Local dE4			:= Ctod('//')
Local dS4			:= Ctod('//')
Local lHnotTab		:= .F.
Local lHnotTbI		:= .F.
Local lNoExecGat	:= ( Type( "lHrsTrbGat" ) == "L" .and. !( lHrsTrbGat ) )

Local nIniHnot		:= 0
Local nFimHnot		:= 23.59
Local nMinHnot		:= 60  
Local nObj             
Local nAlias         
Local aCpos			:=Array(3)
Local bGet			:=Array(3)  

DEFAULT lSR6		:= .F. //Para forcar o uso dos campos do turno ao calcular as horas de jornadas associadas a ele.
			
#DEFINE ENTRA1_  	01
#DEFINE SAIDA1_  	02
#DEFINE ENTRA2_  	03
#DEFINE SAIDA2_  	04
#DEFINE ENTRA3_  	05
#DEFINE SAIDA3_  	06
#DEFINE ENTRA4_  	07
#DEFINE SAIDA4_  	08			
#DEFINE INTERV1_	09
#DEFINE INTERV2_ 	10
#DEFINE INTERV3_ 	11  
#DEFINE HRSINT1_    12
#DEFINE HRSINT2_    13
#DEFINE HRSINT3_    14
#DEFINE HRSTRAB_ 	15
#DEFINE HRSTRA2_ 	16
#DEFINE HRSTRA3_ 	17
#DEFINE HRSTRA4_ 	18
#DEFINE JND1CON_ 	19
#DEFINE JND2CON_ 	20
#DEFINE JND3CON_ 	21
#DEFINE JND4CON_ 	22 
#DEFINE HNTTAB_  	23
#DEFINE HNTTBI_  	24
#DEFINE INIHNT_  	25
#DEFINE FIMHNT_  	26
#DEFINE MINHNT_  	27



#DEFINE PONSPJ_		01   
#DEFINE PONSP2_		02
#DEFINE PONOUT_		03 

#DEFINE PONGD_		01   
#DEFINE PONMB_		02
#DEFINE PONDB_		03 

aCpos[PONOUT_]:= {;
					"ENTRA1"	,; //01 - 1E
					"SAIDA1"    ,; //02 - 1S
					"ENTRA2"	,; //03 - 2E
					"SAIDA2"    ,; //04 - 2S
					"ENTRA3"	,; //05 - 3E
					"SAIDA3"    ,; //06 - 3S
					"ENTRA4"	,; //07 - 4E
					"SAIDA4"    ,; //08 - 4S
					"INTER1"	,; //09 - 1a.S.Interv
					"INTER2"	,; //10 - 2a.S.Interv.
					"INTER3"	,; //11 - 3a.S.Interv.
					"HRINT1"	,; //12 - Hrs 1o.Int.
					"HRINT2"	,; //13 - Hrs 2o.Int.
					"HRINT3"	,; //14 - Hrs 3o.Int.
					"HRTRAB"	,; //15 - Hrs.Trb.1a.J
					"HRTRA2"	,; //16 - Hrs.Trb.2a.J
					"HRTRA3"	,; //17 - Hrs.Trb.3a.J
					"HRTRA4"	,; //18 - Hrs.Trb.4a.J
					"JND1CO" 	,; //19 - 1a.Jor.Cont.
					"JND2CO" 	,; //20 - 2a.Jor.Cont.
					"JND3CO" 	,; //21 - 3a.Jor.Cont.
					"JND4CO" 	,; //22 - 4a.Jor.Cont.
					"HNTTAB"    ,; //23 - 
					"HNTTBI"    ,; //24 -
					"INIHNT"    ,; //25 -
					"FIMHNT"    ,; //26 -
					"MINHNT"    ;  //27 -
                  }

aCpos[PONSPJ_]:= {;
					"ENTRA1"    ,; //01 - 1a Entrada
					"SAIDA1"    ,; //02 - 1a Saida
					"ENTRA2"	,; //03 - 2a Entrada
					"SAIDA2"    ,; //04 - 2a Saida
					"ENTRA3"	,; //05 - 3a Entrada
					"SAIDA3"    ,; //06 - 3a Saida
					"ENTRA4"	,; //07 - 4a Entrada
					"SAIDA4"    ,; //08 - 4a Saida
					"INTERV1"	,; //09 - 1a Saida Int
					"INTERV2"	,; //10 - 2a Saida Int          
					"INTERV3"	,; //11 - 3a Saida Int            
					"HRSINT1"  	,; //12 - Horas 1o.Int          
					"HRSINT2"  	,; //13 - Horas 2o.Int          
					"HRSINT3"  	,; //14 - Horas 3o.Int          
					"HRSTRAB"  	,; //15 - Hrs.Trb.1a.J          
					"HRSTRA2"  	,; //16 - Hrs.Trb.2a.J          
					"HRSTRA3"  	,; //17 - Hrs.Trb.3a.J          
					"HRSTRA4"  	,; //18 - Hrs.Trb.4a.J          
					"JND1CON"  	,; //19 - 1a.Jor.Cont.          
					"JND2CON"  	,; //20 - 2a.Jor.Cont.          
					"JND3CON"  	,; //21 - 3a.Jor.Cont.          
					"JND4CON"  	,; //22 - 4a.Jor.Cont. 
					"HNOTTAB"  	,; //23 - Horas Total
					"HNOTTBI"  	,; //24 - 
					"INIHNOT"  	,; //25 - 
					"FIMHNOT"  	,; //26 - 
					"MINHNOT"	;  //27 - 
					}

aCpos[PONSP2_]:={;
					"ENTRA1"	,; //01 - 1a Entrada
					"SAIDA1"    ,; //02 - 1a Saida
					"ENTRA2"	,; //03 - 2a Entrada
					"SAIDA2"    ,; //04 - 2a Saida
					"ENTRA3"	,; //05 - 3a Entrada
					"SAIDA3"    ,; //06 - 3a Saida
					"ENTRA4"	,; //07 - 4a Entrada
					"SAIDA4"    ,; //08 - 4a Saida
					"INTERV1"  	,; //09 - 1a.S.Interv
					"INTERV2"  	,; //10 - 2a.S.Interv.
					"INTERV3"  	,; //11 - 3a.S.Interv.
					"HRINTV1"  	,; //12 - Hrs 1o.Int.
					"HRINTV2"  	,; //13 - Hrs 2o.Int.
					"HRINTV3"  	,; //14 - Hrs 3o.Int.
					"HRSTRAB"  	,; //15 - Hrs.Trb.1a.J
					"HRSTRA2"  	,; //16 - Hrs.Trb.2a.J
					"HRSTRA3"  	,; //17 - Hrs.Trb.3a.J
					"HRSTRA4"  	,; //18 - Hrs.Trb.4a.J
					"JND1CON"  	,; //19 - 1a.Jor.Cont. 
					"JND2CON"  	,; //20 - 2a.Jor.Cont.
					"JND3CON"  	,; //21 - 3a.Jor.Cont.
					"JND4CON"  	,; //22 - 4a.Jor.Cont. 
					"HNOTTAB"  	,; //23 - Horas Total
					"HNOTTBI"  	,; //24 - Horario
					"INIHNOT"  	,; //25 - 
					"FIMHNOT"  	,; //26 - 
					"MINHNOT"	;  //27 - 
					}   

bGet[PONGD_]:={|x| 	 GdFieldGet( cPrefixo+ x ) }
bGet[PONMB_]:={|x| 	 GetMemVar( cPrefixo+ x ) }	
bGet[PONDB_]:={|x| 	 (cAlias)->( &( cPrefixo+ x )) }

cTipo		:= IF(cTipo == NIL .or. ValType(cTipo) != "C", "H"  ,IF(!(Upper(AllTrim(cTipo ))$"I_H_T"),"H",Upper(AllTrim(cTipo))))
cAlias		:= IF(cAlias == NIL .or. ValType(cTipo)!= "C", "SPJ" , Upper( AllTrim( cAlias ) ) )
cObj		:= IF(cObj == NIL .or. ValType(cTipo) != "C", "GD" ,IF(!(Upper(AllTrim(cObj ))$"GD_MB_DB"),"GD",Upper(AllTrim(cObj))))
cObj		:= IF(cAlias == "SP2" .and. Type("lGatForceGd") == "L" .and. cObj != "DB" , IF( lGatForceGd , "GD" , cObj ) , cObj )
cInt		:= IF(cInt == NIL .or. ValType(cInt) != "C", ""  ,IF(!(Upper(AllTrim(cInt ))$"1_2_3_4"),"",AllTrim(cInt)))
cPrefixo	:= ( PrefixoCpo( cAlias ) + "_" )

Begin Sequence

	IF ( lNoExecGat )
		Break
	EndIF
    
    nObj	:= If(cObj == "GD", 1, If (cObj == "MB",2,3))
    nAlias  := If(cAlias == "SPJ",1, If(cAlias == "SP2",2,3))

	IF ( cAlias == "SPJ" )
		lHnotTab	:= ( SR6->R6_HNOTTAB == "S" )
		lHnotTbI	:= ( SR6->R6_HNOTTBI == "S" )
		nIniHnot	:= SR6->R6_INIHNOT
		nFimHnot	:= SR6->R6_FIMHNOT
		nMinHnot	:= SR6->R6_MINHNOT  
		
	ElseIF ( cAlias == "RF3" )  
	    IF lSR6                         
			lHnotTab	:= ( SR6->R6_HNOTTAB == "S" )
			lHnotTbI	:= ( SR6->R6_HNOTTBI == "S" )
			nIniHnot	:= SR6->R6_INIHNOT
			nFimHnot	:= SR6->R6_FIMHNOT
			nMinHnot	:= SR6->R6_MINHNOT  	                           
	    Else
			lHnotTab	:= (GETMV('MV_HNOTTAB'	,,'S') == "S" )
			lHnotTbI	:= (GETMV('MV_HNOTTBI'	,,'S') == "S" )
			nIniHnot	:= 	GETMV('MV_INIHNOT')	
			nFimHnot	:= 	GETMV('MV_FIMHNOT')
			nMinHnot	:= 	GETMV('MV_MINHNOT')
		Endif			
	Else
		lHnotTab	:= ( Eval( bGet[nObj] , aCpos[nAlias,HNTTAB_]) == "S" )
		lHnotTbI	:= ( Eval( bGet[nObj] , aCpos[nAlias,HNTTBI_]) == "S" )
		nIniHnot	:=   Eval( bGet[nObj] , aCpos[nAlias,INIHNT_])
		nFimHnot	:=   Eval( bGet[nObj] , aCpos[nAlias,FIMHNT_])
		nMinHnot	:=   Eval( bGet[nObj] , aCpos[nAlias,MINHNT_])
	EndIF
	    
	dS1		:= IF( ( Eval( bGet[nObj] , aCpos[nAlias, SAIDA1_ ] ) >= Eval( bGet[nObj] , aCpos[nAlias, ENTRA1_ ]) ) , dE1 , dE1 + 1 )
	dS1		:= IF( ( Eval( bGet[nObj] , aCpos[nAlias, SAIDA1_ ] ) >= Eval( bGet[nObj] , aCpos[nAlias, ENTRA1_ ]) ) .and. ( Eval( bGet[nObj] , aCpos[nAlias, JND1CON_ ]) == "S" ), dS1 + 1 , dS1 )
	dE2		:= IF( ( Eval( bGet[nObj] , aCpos[nAlias, ENTRA2_ ] ) >= Eval( bGet[nObj] , aCpos[nAlias, SAIDA1_ ]) ) , dS1 , dS1 + 1 )
	dS2		:= IF( ( Eval( bGet[nObj] , aCpos[nAlias, SAIDA2_ ] ) >= Eval( bGet[nObj] , aCpos[nAlias, ENTRA2_ ]) ) , dE2 , dE2 + 1 )
	dS2		:= IF( ( Eval( bGet[nObj] , aCpos[nAlias, SAIDA2_ ] ) >= Eval( bGet[nObj] , aCpos[nAlias, ENTRA2_ ]) ) .and. ( Eval( bGet[nObj] , aCpos[nAlias, JND2CON_ ]) == "S" ), dS2 + 1 , dS2 )
	dE3		:= IF( ( Eval( bGet[nObj] , aCpos[nAlias, ENTRA3_ ] ) >= Eval( bGet[nObj] , aCpos[nAlias, SAIDA2_ ]) ) , dS2 , dS2 + 1 )
	dS3		:= IF( ( Eval( bGet[nObj] , aCpos[nAlias, SAIDA3_ ] ) >= Eval( bGet[nObj] , aCpos[nAlias, ENTRA3_ ]) ) , dE3 , dE3 + 1 )
	dS3		:= IF( ( Eval( bGet[nObj] , aCpos[nAlias, SAIDA3_ ] ) >= Eval( bGet[nObj] , aCpos[nAlias, ENTRA3_ ]) ) .and. ( Eval( bGet[nObj] , aCpos[nAlias, JND3CON_ ]) == "S" ), dS3 + 1 , dS3 )
	dE4		:= IF( ( Eval( bGet[nObj] , aCpos[nAlias, ENTRA4_ ] ) >= Eval( bGet[nObj] , aCpos[nAlias, SAIDA3_ ]) ) , dS3 , dS3 + 1 )
	dS4		:= IF( ( Eval( bGet[nObj] , aCpos[nAlias, SAIDA4_ ] ) >= Eval( bGet[nObj] , aCpos[nAlias, ENTRA4_ ]) ) , dE4 , dE4 + 1 )
	dS4		:= IF( ( Eval( bGet[nObj] , aCpos[nAlias, SAIDA4_ ] ) >= Eval( bGet[nObj] , aCpos[nAlias, ENTRA4_ ]) ) .and. ( Eval( bGet[nObj] , aCpos[nAlias, JND4CON_ ]) == "S" ), dS4 + 1 , dS4 )

	//-- Calcula as Horas entre Jornadas
	IF cTipo == "H"
			IF cInt == "1"
				nHoras := fCalHoras( dE1 , Eval( bGet[nObj] , aCpos[nAlias, ENTRA1_ ]) , dS1 , Eval( bGet[nObj] , aCpos[nAlias, SAIDA1_ ]) , NIL , NIL , lHnotTab , dE1 , NIL , nIniHnot , nFimHnot , nMinHnot )
			ElseIF cInt == "2"
				nHoras := fCalHoras( dE2 , Eval( bGet[nObj] , aCpos[nAlias, ENTRA2_ ]) , dS2 , Eval( bGet[nObj] , aCpos[nAlias, SAIDA2_ ]) , NIL , NIL , lHnotTab , dE2 , NIL , nIniHnot , nFimHnot , nMinHnot )
			ElseIF cInt == "3"
				nHoras := fCalHoras( dE3 , Eval( bGet[nObj] , aCpos[nAlias, ENTRA3_ ]) , dS3 , Eval( bGet[nObj] , aCpos[nAlias, SAIDA3_ ]) , NIL , NIL , lHnotTab , dE3 , NIL , nIniHnot , nFimHnot , nMinHnot )
			ElseIF cInt == "4"
				nHoras := fCalHoras( dE4 , Eval( bGet[nObj] , aCpos[nAlias, ENTRA4_ ]) , dS4 , Eval( bGet[nObj] , aCpos[nAlias, SAIDA4_ ]) , NIL , NIL , lHnotTab , dE4 , NIL , nIniHnot , nFimHnot , nMinHnot )
			EndIF	

	//-- Calcula as Horas de Intervalos
	ElseIF cTipo == "I"
		IF cInt == "1" .or. cVar $ aCpos[nAlias,INTERV1_]
			IF  Eval( bGet[nObj] , aCpos[nAlias,INTERV1_]) == "S"
				nHoras := fCalHoras( dS1 , Eval( bGet[nObj] , aCpos[nAlias, SAIDA1_ ]) , dE2 ,  Eval( bGet[nObj] , aCpos[nAlias, ENTRA2_ ]) , NIL , NIL , lHnotTbI , dE1 , NIL , nIniHnot , nFimHnot , nMinHnot )
			EndIF
		
		ElseIF cInt == "2" .or. cVar $  aCpos[nAlias,INTERV2_]
				IF Eval( bGet[nObj] , aCpos[nAlias,INTERV2_]) == "S"
					nHoras := fCalHoras( dS2 , Eval( bGet[nObj] , aCpos[nAlias, SAIDA2_ ]), dE3 ,  Eval( bGet[nObj] , aCpos[nAlias, ENTRA3_ ]) , 0 , 0 , lHnotTbI , dE2 , NIL , nIniHnot , nFimHnot , nMinHnot )
				EndIF
		
		ElseIF cInt == "3" .or. cVar $ aCpos[nAlias,INTERV3_]
				IF Eval( bGet[nObj] , aCpos[nAlias,INTERV3_]) == "S"
					nHoras := fCalHoras( dS3 , Eval( bGet[nObj] , aCpos[nAlias, SAIDA3_ ]) , dE4 ,  Eval( bGet[nObj] , aCpos[nAlias, ENTRA4_ ])  , NIL , NIL , lHnotTbI , dE3 , NIL , nIniHnot , nFimHnot , nMinHnot )
				EndIF	
		EndIF
    
	//-- Calcula o Total de Horas
	ElseIF cTipo == "T"
	 		nHoras := SomaHoras( nHoras , Eval( bGet[nObj] , aCpos[nAlias,HRSINT1_]) )
			nHoras := SomaHoras( nHoras , Eval( bGet[nObj] , aCpos[nAlias,HRSINT2_]) )
			nHoras := SomaHoras( nHoras , Eval( bGet[nObj] , aCpos[nAlias,HRSINT3_]) )
			nHoras := SomaHoras( nHoras , Eval( bGet[nObj] , aCpos[nAlias,HRSTRAB_]) )
			nHoras := SomaHoras( nHoras , Eval( bGet[nObj] , aCpos[nAlias,HRSTRA2_]) )
			nHoras := SomaHoras( nHoras , Eval( bGet[nObj] , aCpos[nAlias,HRSTRA3_]) )
			nHoras := SomaHoras( nHoras , Eval( bGet[nObj] , aCpos[nAlias,HRSTRA4_]) )
	EndIF

End Sequence
	
Return(__TimeSum(__TimeSum( nHoras, 0 ), 0) )

/*/
зддддддддддбдддддддддддбддддддбдддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    Ё__Excecoes ЁAutor Ё Equipe Advanced RH    Ё Data Ё19/04/2001Ё
цддддддддддедддддддддддаддддддадддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁCarrega a Tabela de Exce┤■es                	            Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё__Excecoes(aArray,cTurno,cCC,cMat,dData,nRecno,aExcePer)	Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁPar┐metrosЁ< Vide Parametros Formais >							        Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁObs.:     ЁMatida a Funcao Apenas Para Compatibilidade com os ProgramasЁ
Ё          ЁEspecificos que ja Estao Sendo Utilizados nos Cliente.  RecoЁ
Ё          Ёmendado o uso da GetExcecoes()								Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁSIGAPON                                                     Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function __Excecoes(aArray,cTurno,cCC,cMat,dData,nRecno,aExcePer)

Local cFil 		:= SRA->RA_MAT
Local lExcecao	:= .F.

DEFAULT aArray		:= {}
DEFAULT cTurno		:= SRA->RA_TNOTRAB
DEFAULT cCC			:= SRA->RA_CC
DEFAULT cMat		:= SRA->RA_MAT
DEFAULT dData		:= dDataBase
DEFAULT nRecno		:= 0
DEFAULT aExceper	:= {}	

lExcecao := GetExcecoes(	@aArray		,; // 01 - Array a ser Carregado com as Exce┤oes
							cTno		,; // 02 - Turno de Trabalho do Funcion═rio
							cCC			,; // 03 - Centro de Custo do Funcion═rio
							cFil		,; // 04 - Filial do Funcionario
							cMat		,; // 05 - Matricula do Funcion═rio
							dData		,; // 06 - Data a ser pesquisada
							""			,; // 07 - Tipo do Dia Para a Excecao
							aExcePer	,; // 08 - Array com Todas as Exce┤oes do Periodo
							NIL			,; // 09 - Periodo Inicial Para Carga de aExcePer
							NIL			,; // 10 - Periodo Final   Para Carga de aExcePer
							.F.			,; // 11 - True para Carregar Todas as Excecoes do Periodo
							.F.			 ; // 12 - Mostrar Dialogo na IndRegua
						)

Return( lExcecao )

/*/
зддддддддддбдддддддддддбддддддбдддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁGetExcecoesЁAutor Ё Marinaldo de Jesus    Ё Data Ё19/04/2001Ё
цддддддддддедддддддддддаддддддадддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁCarrega a Tabela de Exce┤■es                	            Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   ЁGetExcecoes()												Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁPar┐metrosЁ< Vide Parametros Formais >							        Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁObs.:     ЁQuando a procura For Feita em Arquivo (SP2) ira posicionar oЁ
Ё          ЁRecno Correspondente `a Excecao.                            Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁSIGAPON                                                     Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function GetExcecoes(	aArray		,; // 01 - Array a ser Carregado com as Exce┤oes
						cTno		,; // 02 - Turno de Trabalho do Funcion═rio
						cCC			,; // 03 - Centro de Custo do Funcion═rio
						cFil		,; // 04 - Filial do Funcionario
						cMat		,; // 05 - Matricula do Funcion═rio
						dData		,; // 06 - Data a ser pesquisada
						cTipoDia 	,; // 07 - Tipo do Dia Para a Excecao             					
						aExcePer	,; // 08 - Array com Todas as Exce┤oes do Periodo
						dPerIni		,; // 09 - Periodo Inicial Para Carga de aExcePer
						dPerFim		,; // 10 - Periodo Final   Para Carga de aExcePer 
						lPeriodo	,; // 11 - True para Carregar Todas as Excecoes do Periodo
						lShowDialog ,; // 12 - Mostrar Dialogo na IndRegua
						lForceGoto	 ; // 13 - Se, quando pesquisa em array, forca o posicionamento no SP2	
					 )

/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Variaveis de Inicializacao Obrigatoria					  Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Local aExceTip		:= {}
Local cRegra		:= SRA->RA_REGRA
Local cSpcTipoDia	:= Space( GetSx3Cache( "P2_TIPODIA" , "X3_TAMANHO" ) ) 
Local lExcecao		:= .F.
Local lArray		:= .F.
Local nFornY		:= RetCondExce()

/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Variaveis que serao inicializadas no Corpo da Funcao		  Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Local aString
Local baScan
Local bCond
Local bLoop
Local bExce
Local cArqInd
Local nFornX
Local nX
Local nY
Local nPos
Local nRecno

Static	cIndKeyExc
Static	nOrderExce

DEFAULT aArray		:= {}
DEFAULT cTno		:= SRA->RA_TNOTRAB
DEFAULT cCC			:= SRA->RA_CC
DEFAULT cFil		:= SRA->RA_FILIAL
DEFAULT cMat		:= SRA->RA_MAT
DEFAULT dData		:= dDataBase       
DEFAULT cTipoDia	:= cSpcTipoDia
DEFAULT aExcePer	:= {}
DEFAULT dPerIni		:= dDataBase
DEFAULT dPerFim		:= dDataBase
DEFAULT lPeriodo	:= .F.
DEFAULT lShowDialog := .F.
DEFAULT lForceGoto	:= .F.

Begin Sequence
	
	IF ( ( ValType( aExcePer ) == "A" ) .and. ( lArray := ( Len(aExcePer) > 0 ) ) )  //Pesquizando em Array

		baScan := { |x| x[2] + Dtos( x[3] ) + Dtos( x[4] ) == aExcePer[ nX , 35 ] + Dtos( aExceper[ nX , 02 ] ) + Dtos( aExceper[ nX , 03 ] ) }
		
		bCond := { |x| ( x[1] + x[6] + x[5] + x[4] + Dtos( x[2] ) ) == aString[1]  .or. ;
					   ( x[1] + x[6] + x[5] + x[4]                ) == aString[2]     	;
				 }

		bExce := { |e| dData >= aExcePer[e,2] .and. dData <= IF(!Empty(aExcePer[e,3]),aExcePer[e,3],aExcePer[e,2]) }

	   	bLoop := { |e,f| IF( f == "L" , aExcePer[e,1] + aExcePer[e,6] + aExcePer[e,5] + aExcePer[e,4] != aString[2] ,;
						   			    aExcePer[e,1] + aExcePer[e,6] + aExcePer[e,5] + aExcePer[e,4] == aString[2]  ;
							)																						 ;
	   			 }
		
		For nY := 1 To nFornY
			
			aString  := RetCondExce( cFil , cMat , cTno , cCC , dData , nY )
			
			IF ( ( nPos := aScan( aExcePer, bCond ) ) > 0 )
				nFornX  := ( nFornX := Len( aExcePer ) )
				For nX := nPos To nFornX
					IF ( nX > nFornX )
						Exit
					EndIF	
					IF Eval( bLoop , nX , "L" ) 
						IF Eval( bLoop , nFornX , "F" ) .and. Eval( bExce , nFornX )
							lExcecao := .T.
							IF ( Empty( aExceTip ) .or. ( aScan( aExceTip , baScan ) == 0 ) )
								aAdd( aExceTip , {   			   			 ;
													nFornX		   			,;	//01 -> Indice da Excecao em aExcePer
													aExcePer[ nFornX , 35 ]	,;	//02 -> Tipo do Dia Para Excecao
													aExceper[ nFornX , 02 ]	,;	//03 -> Data Inicial da Excecao
													aExceper[ nFornX , 03 ] ,;	//04 -> Data Final da Excecao
													aExceper[ nFornX , 01 ] ,;	//05 -> Filial
													aExceper[ nFornX , 06 ] ,;	//06 -> Matricula do Funcionario
													aExceper[ nFornX , 05 ] ,;	//07 -> Centro de Custo
													aExceper[ nFornX , 04 ]	,;	//08 -> Turno 
													aExcePer[ nFornX , 27 ]  ;	//09 -> Recno
												  };
									 )
								--nFornX	 
							EndIF
						Else
							--nFornX
						EndIF
						Loop
					EndIF
					IF Eval( bExce , nX )
						lExcecao := .T.
						IF ( Empty( aExceTip ) .or. ( aScan( aExceTip , baScan ) == 0 ) )
							aAdd( aExceTip , {   					 ;
												nX					,;	//01 -> Indice da Excecao em aExcePer
												aExcePer[ nX , 35 ]	,;	//02 -> Tipo do Dia Para Excecao
												aExceper[ nX , 02 ]	,;	//03 -> Data Inicial da Excecao
												aExceper[ nX , 03 ] ,;	//04 -> Data Final da Excecao
												aExceper[ nX , 01 ] ,;	//05 -> Filial
												aExceper[ nX , 06 ] ,;	//06 -> Matricula do Funcionario
												aExceper[ nX , 05 ] ,;	//07 -> Centro de Custo
												aExceper[ nX , 04 ]	,;	//08 -> Turno 
												aExcePer[ nX , 27 ]  ;	//09 -> Recno
											   };
								 )
						EndIF
					EndIF
					IF Eval( bLoop , nFornX , "F" )  .and. Eval( bExce , nFornX )
						lExcecao := .T.
						IF ( Empty( aExceTip ) .or. ( aScan( aExceTip , baScan ) == 0 ) )
							aAdd( aExceTip , {   			   			 ;
												nFornX		   			,;	//01 -> Indice da Excecao em aExcePer
												aExcePer[ nFornX , 35 ]	,;	//02 -> Tipo do Dia Para Excecao
												aExceper[ nFornX , 02 ]	,;	//03 -> Data Inicial da Excecao
												aExceper[ nFornX , 03 ] ,;	//04 -> Data Final da Excecao
												aExceper[ nFornX , 01 ] ,;	//05 -> Filial
												aExceper[ nFornX , 06 ] ,;	//06 -> Matricula do Funcionario
												aExceper[ nFornX , 05 ] ,;	//07 -> Centro de Custo
												aExceper[ nFornX , 04 ]	,;	//08 -> Turno 
												aExcePer[ nFornX , 27 ]  ;	//09 -> Recno
											   };
								 )
							--nFornX	 
						EndIF
					Else
						--nFornX
					EndIF
				Next nX
			EndIF
	    
	    Next nY

	ElseIF !( lPeriodo ) //Pesquizando em Arquivo

		DEFAULT cIndKeyExc	:= "P2_FILIAL+P2_MAT+P2_CC+P2_TURNO+DtoS(P2_DATA)+P2_TIPODIA"
		DEFAULT nOrderExce	:= RetOrdem( "SP2" , cIndKeyExc )

		IF SP2->( IndexOrd() <> nOrderExce )
			IF !fContemStr( cIndKeyExc , SP2->( IndexKey() ) )
				SP2->( dbSetOrder( nOrderExce ) )
			EndIF
		EndIF

		baScan := { |x| x[2] + Dtos( x[3] ) + Dtos( x[4] ) == P2_TIPODIA + Dtos( P2_DATA ) + Dtos( P2_DATAATE ) }
		bExce  := { || dData >= P2_DATA .and. dData <= IF(!Empty(P2_DATAATE),P2_DATAATE,P2_DATA) }
		bLoop  := { || P2_FILIAL + P2_MAT + P2_CC + P2_TURNO == aString[1]  .or.	;
					   P2_FILIAL + P2_MAT + P2_CC + P2_TURNO == aString[2]  		;
				   }

		For nY := 1 To nFornY

			aString := RetCondExce( cFil , cMat , cTno , cCC , dData , nY )

			IF SP2->(dbSeek( aString[1] , .F.) .or. dbSeek( aString[2] , .F.) ) 
				While SP2->( !Eof() .and. Eval( bLoop ) )
					IF ( lExcecao := SP2->( Eval( bExce ) ) ) 
						While SP2->( !Eof() .and. Eval( bLoop ) )
							IF SP2->( Eval( bExce ) )
								IF Empty( aExceTip ) .or. SP2->( aScan( aExceTip , baScan ) ) == 0
									++nX
									SP2->( aAdd( aExceTip , {				 ;
																nX			,;	//01 -> Indice da Excecao em aExcePer
																P2_TIPODIA	,;	//02 -> Tipo do Dia para a Excecao
																P2_DATA		,;	//03 -> Data Inicial da Excecao
																P2_DATAATE	,;	//04 -> Data Final da Excecao
																P2_FILIAL   ,;	//05 -> Filial
																P2_MAT      ,;	//06 -> Matricula do Funcionario
																P2_CC		,;	//07 -> Centro de Custo
																P2_TURNO    ,;	//08 -> Turno
																Recno()		 ;	//09 -> Recno
															 };
												);
										  )
								EndIF
								SP2->( dbSkip() )
							Else
								Break
							EndIF
						End While
					Else
						SP2->( dbSkip() )
					EndIF
				End While
			EndIF
	
		Next nY
		
	EndIF

End Sequence

lExcecao := .F.
IF !( lPeriodo )

	nPos := 0
	IF !Empty( aExceTip )

		/*/
		здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Procura Excecao sem o Tipo do Dia                            Ё
		юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	   	baScan	:= { |e| (;
	   						(;
	   							e[5] +			;	//Filial
	   							e[6] +			;	//Matricula
	   							e[7] +			;	//Centro de Custo
	   							e[8] + 			;	//Turno
	   							e[2]			;	//Tipo do Dia
	   						);	
	   						==					;
							(;
								aString[2] +	;
								cSpcTipoDia		;
							);	
	   					 );
		   			 }
	
		For nY := 1 To nFornY
	
			aString := RetCondExce( cFil , cMat , cTno , cCC , dData , nY )
			IF ( ( nPos := aScan( aExceTip , baScan ) ) > 0 )
	        	Exit
	        EndIF
	
		Next nY
	
		/*/
		здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Procura Excecao Expecifica para o Tipo do Dia                Ё
		юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		IF ( ( nPos == 0 ) )
	    
		   	baScan	:= { |e| (;
		   						(;
		   							e[5] +			;	//Filial
		   							e[6] +			;	//Matricula
		   							e[7] +			;	//Centro de Custo
		   							e[8] +			;	//Turno
		   							e[2]			;	//Tipo do Dia
		   						);	
		   						==					;
		   						(;
		   							aString[2] +	;
		   							cTipoDia		;
		   						);	
		   					 );
			   			 }
		
			For nY := 1 To nFornY
		
				aString := RetCondExce( cFil , cMat , cTno , cCC , dData , nY )
				IF ( ( nPos := aScan( aExceTip , baScan ) ) > 0 )
		        	Exit
		        EndIF
		
			Next nY
	
		EndIF
		
	EndIF

	IF ( lExcecao := ( nPos > 0 ) )
	
		cTipoDia	:= aExceTip[ nPos , 02 ]
		nRecno      := aExceTip[ nPos , 09 ]
	
		IF !( lArray )
			IF ( SP2->( Recno() ) != nRecno )
				SP2->( dbGoto( nRecno ) )
			EndIF
		Else
			IF ( lForceGoto )
				IF ( SP2->( Recno() ) != nRecno )
					SP2->( dbGoto( nRecno ) )
				EndIF
			EndIF
			nPos := aExceTip[ nPos , 01 ]
		EndIF
	
		SP2->( fAddExce( @aArray , lArray , aExceper , nPos , dData , cRegra , nRecno ) )

	EndIF
	
ElseIF ( lPeriodo )

	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Neste Ponto a Chamada devera ser Feita Pela Processa()       Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	SP2->( ProcRegua( RecCount() ) , dbGoTop() )

	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	ЁDepura o Arquivo de Excecoes Carregando as Excecoes do PeriodoЁ
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	fDepuraSP2( @cArqInd , dPerIni , dPerFim , lShowDialog )

	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Carrega as Excecoes do Periodo                             Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	aExcePer := {}
	While SP2->( !Eof() )
		IncProc(OemToAnsi(STR0060))	// 'Carregando as Exce┤■es do Per║odo...'
		SP2->( fAddExce( @aExcePer , NIL , NIL , NIL , NIL , cRegra , Recno() ) )
		SP2->( dbSkip() )
	End While

	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Restaura Indices do SP2 e Apaga Indice Temporario          Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	IF !Empty( cArqInd )
		RetIndex("SP2")
		SP2->( dbSetOrder( nOrderExce ) )
		fErase( cArqInd + OrdBagExt() )
	EndIF

	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Carrega o Retorno da Funcao                                Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	lExcecao := ( Len( aExcePer ) > 0 )

EndIF

Return( lExcecao )

/*/
зддддддддддбддддддддддддддбдддддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁRetCondExce	  Ё Autor ЁMarinaldo de Jesus    Ё Data Ё19/04/2001Ё
цддддддддддеддддддддддддддадддддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁRetorna Array com Chaves para a Pesquisa das Excecoes          Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   ЁRetCondExce( cFil , cMat , cTno , cCC , dData , nInd )		   Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ                                         					   Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁxRet ->	Qdo PCount() = 0 , Numero de Condicoes Existentes, casoЁ
Ё          Ё       	Contrario, Array de 2 Posicoes contendo as Chaves  paraЁ
Ё          Ё       	a Pesquisa das Excecoes.                               Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁObserva┤└oЁ                                                      	       Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGetExcecoes()												   Ё
юддддддддддаддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function RetCondExce( cFil , cMat , cTno , cCC , dData , nInd )

Local cSpcP2Mat	:= Space( GetSx3Cache( "P2_MAT    " , "X3_TAMANHO" ) ) 
Local cSpcP2Cc	:= Space( GetSx3Cache( "P2_CC     " , "X3_TAMANHO" ) ) 
Local cSpcP2Tno	:= Space( GetSx3Cache( "P2_TURNO  " , "X3_TAMANHO" ) ) 
Local xRet		:= NIL

IF Empty( PCount() )
	xRet := 8.00
Else
	xRet := Array( 02 )
	IF nInd == 1		//Pesquisando Mat + CC + Turno
		xRet[1]		:=  ( cFil + cMat + cCC + cTno + Dtos( dData ) )
		xRet[2]		:=  ( cFil + cMat + cCC + cTno )
	ElseIF nInd == 2	//Pesquisando Mat + CC + ЧЧЧЧЧ
		xRet[1]		:=	( cFil + cMat + cCC + cSpcP2Tno + Dtos( dData ) )
		xRet[2]		:=  ( cFil + cMat + cCC + cSpcP2Tno )
	ElseIF nInd == 3	//Pesquisando Mat + ЧЧ + Turno
		xRet[1]		:=	( cFil + cMat + cSpcP2Cc + cTno + Dtos( dData ) )
		xRet[2]		:=  ( cFil + cMat + cSpcP2Cc + cTno )
	ElseIF nInd == 4	//Pesquisando Mat + ЧЧ + ЧЧЧЧЧ
		xRet[1]		:=	( cFil + cMat + cSpcP2Cc + cSpcP2Tno + Dtos( dData ) )
		xRet[2]		:=  ( cFil + cMat + cSpcP2Cc + cSpcP2Tno )
	ElseIF nInd == 5	//Pesquisando ЧЧЧ + CC + Turno
		xRet[1]		:=  ( cFil + cSpcP2Mat + cCC + cTno + Dtos( dData ) )
		xRet[2]		:=  ( cFil + cSpcP2Mat + cCC + cTno )
	ElseIF nInd == 6	//Pesquisando ЧЧЧ + ЧЧ + Turno
		xRet[1]		:=  ( cFil + cSpcP2Mat + cSpcP2Cc + cTno + Dtos( dData ) )
	    xRet[2]		:=  ( cFil + cSpcP2Mat + cSpcP2Cc + cTno )
	ElseIF nInd == 7	//Pesquisando ЧЧЧ + CC + ЧЧЧЧЧ
		xRet[1]		:=  ( cFil + cSpcP2Mat + cCC + cSpcP2Tno + Dtos( dData ) ) 
	    xRet[2]		:=  ( cFil + cSpcP2Mat + cCC + cSpcP2Tno )
	ElseIF nInd == 8	//Pesquisando ЧЧЧ + ЧЧ + ЧЧЧЧЧ
		xRet[1]		:=  ( cFil + cSpcP2Mat + cSpcP2Cc + cSpcP2Tno + Dtos( dData ) )
		xRet[2]		:=  ( cFil + cSpcP2Mat + cSpcP2Cc + cSpcP2Tno )
	EndIF
EndIF
	
Return( xRet )

/*/
зддддддддддбдддддддддддбддддддбдддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁGetExceTop ЁAutor Ё Marinaldo de Jesus    Ё Data Ё07/06/2001Ё
цддддддддддедддддддддддаддддддадддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁCarrega a Tabela de Exce┤■es                	            Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   ЁGetExcecoes()												Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁPar┐metrosЁ< Vide Parametros Formais >							        Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁPonto Eletronico RDD TOPCONNECT                             Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function GetExceTop( cFil		,; //01 -> Filial
					 cMat 		,; //02 -> Matricula
					 cCc		,; //03 -> Centro de Custo
					 aTurnos	,; //04 -> Array com os Turnos do Funcionario
					 dPerIni	,; //05 -> Periodo Inicial
					 dPerFim	,; //06 -> Periodo Final
					 aArray  	 ; //07 -> Array a ser carregado com as Excecoes
					)

Local cSvAlias	:= Alias()
Local lRet		:= .F.

#IFDEF TOP

	Local baScan		:= { || NIL }
	Local cPerIni		:= Dtos( dPerIni )
	Local cPerFim		:= Dtos( dPerFim )
	Local cRegra		:= SRA->RA_REGRA
	Local cSpaceMat		:= Space( GetSx3Cache( "RA_MAT    " , "X3_TAMANHO" ) )
	Local cSpaceCus 	:= Space( GetSx3Cache( "RA_CC     " , "X3_TAMANHO" ) )
	Local cSpaceTur 	:= Space( GetSx3Cache( "RA_TNOTRAB" , "X3_TAMANHO" ) )
	Local cQuery		:= ""
	Local cTno			:= ""
	Local cAliasQuery	:= "__QSP2QRY"
	Local cInitSqlName	:= InitSqlName("SP2")
	Local lQueryOpened	:= .F.
	Local nLenTurno		:= 0
	Local nX			:= 0
	Local nY			:= 0
	Local nSvOrder		:= SP2->( IndexOrd() )
	
	Static aStruSP2
	Static cIndKeyExc
	Static cQrySp2Fields
	Static nOrderExce
	Static nFieldsSP2
	
	DEFAULT cIndKeyExc	:= "P2_FILIAL+P2_MAT+P2_CC+P2_TURNO+DtoS(P2_DATA)+P2_TIPODIA"
	DEFAULT nOrderExce	:= RetOrdem( "SP2" , cIndKeyExc )

	IF ( aStruSP2	== NIL )
		aStruSP2	:= SP2->( dbStruct() )
		nFieldsSP2	:= Len( aStruSP2 )
	EndIF	

 	IF ( cQrySp2Fields == NIL )
		cQrySp2Fields := ""
		For nX := 1 To nFieldsSP2
			cQrySp2Fields += aStruSP2[ nX , 01 ] + ", "
		Next nX
    EndIF

	aArray := {}
	
	IF ( nOrderExce == nSvOrder )
		SP2->( dbSetOrder( nOrderExce ) )
	EndIF    

	baScan	:= { |x| x[ 01 ] == ( cAliasQuery )->( P2_FILIAL	)	.and. ; //Filial
			  		 x[ 02 ] == ( cAliasQuery )->( P2_DATA		)	.and. ; //Data De
					 x[ 03 ] == ( cAliasQuery )->( P2_DATAATE	)	.and. ; //Data Ate
					 x[ 04 ] == ( cAliasQuery )->( P2_TURNO		)	.and. ; //Turno
					 x[ 05 ] == ( cAliasQuery )->( P2_CC		)	.and. ; //Centro de Custo
					 x[ 06 ] == ( cAliasQuery )->( P2_MAT		)	.and. ; //Matricula
					 x[ 35 ] == ( cAliasQuery )->( P2_TIPODIA	)		  ; //Tipo do Dia Para Excecao
	            }
	
	nLenTurno := Len( aTurnos )
	For nY := 1 To nLenTurno

		cTno	:= aTurnos[ nY , 01 ]
		cQuery	:= "SELECT "
		cQuery  += cQrySp2Fields
		cQuery	+= "R_E_C_N_O_ RECNO"
		cQuery	+= " FROM "
		cQuery	+= cInitSqlName
		cQuery	+= " WHERE "
		cQuery	+= "("
		cQuery	+=	"("
		cQuery	+= 		"("
		cQuery	+= 			"P2_FILIAL='"+cFil+"' AND P2_MAT='"+cMat+"' AND P2_CC='"+cCc+"' AND P2_TURNO='"+cTno+"'"
		cQuery	+= 		")"
		cQuery	+= 		" OR "
		cQuery	+= 		"("
		cQuery	+= 			"P2_FILIAL='"+cFil+"' AND P2_MAT='"+cMat+"' AND P2_CC='"+cCc+"' AND P2_TURNO='"+cSpaceTur+"'"
		cQuery	+= 		")"
		cQuery	+= 		" OR "
		cQuery	+= 		"("
		cQuery	+= 			"P2_FILIAL='"+cFil+"' AND P2_MAT='"+cMat+"' AND P2_CC='"+cSpaceCus+"' AND P2_TURNO='"+cTno+"'"
		cQuery	+=		")"
		cQuery	+=		" OR "
		cQuery	+= 		"("
		cQuery	+= 			"P2_FILIAL='"+cFil+"' AND P2_MAT='"+cMat+"' AND P2_CC='"+cSpaceCus+"' AND P2_TURNO='"+cSpaceTur+"'"
		cQuery	+=		")"
		cQuery	+=		" OR "
		cQuery	+= 		"("
		cQuery	+= 			"P2_FILIAL='"+cFil+"' AND P2_MAT='"+cSpaceMat+"' AND P2_CC='"+cCc+"' AND P2_TURNO='"+cTno+"'"
		cQuery	+= 		")"
		cQuery	+= 		" OR "
		cQuery	+= 		"("
		cQuery	+= 			"P2_FILIAL='"+cFil+"' AND P2_MAT='"+cSpaceMat+"' AND P2_CC='"+cSpaceCus+"' AND P2_TURNO='"+cTno+"'"
		cQuery	+= 		")"
		cQuery	+= 		" OR "
		cQuery	+= 		"("
		cQuery	+= 			"P2_FILIAL='"+cFil+"' AND P2_MAT='"+cSpaceMat+"' AND P2_CC='"+cCc+"' AND P2_TURNO='"+cSpaceTur+"'"
		cQuery	+= 		")"
		cQuery	+= 		" OR "
		cQuery	+= 		"("
		cQuery	+= 			"P2_FILIAL='"+cFil+"' AND P2_MAT='"+cSpaceMat+"' AND P2_CC='"+cSpaceCus+"' AND P2_TURNO='"+cSpaceTur+"'"
		cQuery	+=		")"
		cQuery	+=		" AND "
		cQuery	+= 		"("
		cQuery	+= 			"("
		cQuery	+= 			 	"P2_DATAATE BETWEEN '"+cPerIni+"' AND '"+cPerFim+"'" 
		cQuery	+= 			")"
		cQuery	+= 			" OR "
		cQuery	+= 			"("
		cQuery	+= 				"P2_DATA BETWEEN '"+cPerIni+"' AND '"+cPerFim+"'"
		cQuery	+= 			")"
		cQuery	+= 			" OR "
		cQuery	+= 			"("
		cQuery	+= 				"P2_DATAATE >='"+cPerFim+"' AND P2_DATA<='"+cPerIni+"'"
		cQuery	+= 			")"
		cQuery	+= 		")"
		cQuery	+=	")"
		cQuery	+=	" AND D_E_L_E_T_=' '"
		cQuery	+= ")"
		cQuery	+= " ORDER BY "+SqlOrder( SP2->( IndexKey() ) )
		cQuery	:= ChangeQuery( cQuery )
		
		IF ( lQueryOpened := MsOpenDbf(.T.,"TOPCONN",TcGenQry(NIL,NIL,cQuery),cAliasQuery,.F.,.T.) )

			For nX := 1 To nFieldsSP2
				IF ( aStruSP2[nX,02] <> "C" )
					TcSetField(cAliasQuery,aStruSP2[nX,01],aStruSP2[nX,02],aStruSP2[nX,03],aStruSP2[nX,04])
				EndIF
			Next nX
	
			While ( cAliasQuery )->( !Eof() )
	
				IF aScan( aArray , baScan ) == 0
					( cAliasQuery )->( fAddExce( @aArray , NIL , NIL , NIL , NIL , cRegra , RECNO ) )
				EndIF
				
				( cAliasQuery )->( dbSkip() )
			
			End While
			
			( cAliasQuery )->( dbCloseArea() )

		EndIF
			
	Next nY	

	IF ( nOrderExce == nSvOrder )
		SP2->( dbSetOrder( nSvOrder ) )
	EndIF

	lRet := !( Empty( aArray ) )

#ENDIF

IF ( Select( cSvAlias ) > 0 )
	dbSelectArea( cSvAlias )
EndIF
	
Return( lRet )

/*/
зддддддддддбддддддддддддддбдддддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁfAddExce      Ё Autor ЁMarinaldo de Jesus    Ё Data Ё18/07/2001Ё
цддддддддддеддддддддддддддадддддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁCarregar o Array de Excecoes com Informacoes do SP2            Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   ЁSP2>->( fAddExce( @aArray ) )                          		   Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ                                         					   Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁaArray   -> Array que contera as Excecoes do SP2               Ё
Ё          ЁlArray   -> Quando True Carrega Excecao de aExcePer            Ё
Ё          ЁaExcePer -> Array com as Excecoes por Periodo                  Ё
Ё          ЁnPos     -> Posicao da Excecao em aExcePer                     Ё
Ё          ЁdData    -> Data da Excecao                                    Ё
Ё          ЁcRegra   -> Regra de Apontamento do Cadastro de Funcionarios   Ё
Ё          ЁnRecno   -> Recno Correspondente a Excecao                     Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁObserva┤└oЁ                                                      	       Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGetExcecoes() e GetExceTop()								   Ё
юддддддддддаддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function fAddExce( aArray , lArray , aExceper , nPos , dData , cRegra , nRecno )

Local nLenArray := 0
Local cHerdHor	:= "N"

IF !( lArray )
	cRegra		:=	IF( Empty( P2_REGRA ) , cRegra , P2_REGRA )
	cHerdHor	:=	IF( ( P2_HERDHOR == "S" ) , "S", "N" )
EndIF

IF ( dData == NIL ) //Carrega as Excecoes Por Periodo

	aAdd(aArray, Array( 62 ) )
	nLenArray := Len( aArray )
	aArray[nLenArray,01] := P2_FILIAL	//01 - Filial
	aArray[nLenArray,02] := P2_DATA		//02 - Data da Excecao
	aArray[nLenArray,03] := P2_DATAATE	//03 - Data Final da Excecao
	aArray[nLenArray,04] := P2_TURNO	//04 - Turno para a Excecao
	aArray[nLenArray,05] := P2_CC		//05 - Centro de Custo para a Excecao
	aArray[nLenArray,06] := P2_MAT		//06 - Matricula para a Excecao
	aArray[nLenArray,07] := P2_ENTRA1	//07 - 1a. Entrada
	aArray[nLenArray,08] := P2_SAIDA1	//08 - 1a. Saida
	aArray[nLenArray,09] := P2_ENTRA2	//09 - 2a. Entrada
	aArray[nLenArray,10] := P2_SAIDA2	//10 - 2a. Saida
	aArray[nLenArray,11] := P2_ENTRA3	//11 - 3a. Entrada
	aArray[nLenArray,12] := P2_SAIDA3	//12 - 3a. Saida
	aArray[nLenArray,13] := P2_ENTRA4	//13 - 4a. Entrada
	aArray[nLenArray,14] := P2_SAIDA4	//14 - 4a. Saida
	aArray[nLenArray,15] := P2_INTERV1	//15 - Primeira Saida Intervalo
	aArray[nLenArray,16] := P2_INTERV2	//16 - Segunda Saida Intervalo
	aArray[nLenArray,17] := P2_INTERV3	//17 - Terceira Saida Intervalo
	aArray[nLenArray,18] := P2_HRSTRAB	//18 - Horas Trabalhadas 1a. Jornada
	aArray[nLenArray,19] := P2_HRSTRA2	//19 - Horas Trabalhadas 2a. Jornada
	aArray[nLenArray,20] := P2_HRSTRA3	//20 - Horas Trabalhadas 3a. Jornada
	aArray[nLenArray,21] := P2_HRSTRA4	//21 - Horas Trabalhadas 4a. Jornada
	aArray[nLenArray,22] := 0			//22 - Numero de Marcacoes da Tabela (Nao usado)
	aArray[nLenArray,23] := P2_MOTIVO	//23 - Motivo da Excecao
	aArray[nLenArray,24] := P2_CODHEXT	//24 - Codigo da Hora Extra Normal
	aArray[nLenArray,25] := P2_TRABA	//25 - Dia Trabalhado
	aArray[nLenArray,26] := P2_CODHNOT	//26 - Codigo da Hora Extra Noturna
	aArray[nLenArray,27] := nRecno		//27 - Registro da Excecao
	aArray[nLenArray,28] := P2_HRINTV1	//28 - Horas do Primeiro Intervalo
	aArray[nLenArray,29] := P2_HRINTV2	//29 - Horas do Segundo Intervalo
	aArray[nLenArray,30] := P2_HRINTV3	//30 - Horas do Terceiro Intervalo
	aArray[nLenArray,31] := P2_CCPER01	//31 - Centro de Custo da 1a. Jornada
	aArray[nLenArray,32] := P2_CCPER02	//32 - Centro de Custo da 2a. Jornada
	aArray[nLenArray,33] := P2_CCPER03	//33 - Centro de Custo da 3a. Jornada
	aArray[nLenArray,34] := P2_CCPER04	//34 - Centro de Custo da 4a. Jornada
	aArray[nLenArray,35] := P2_TIPODIA	//35 - Tipo do Dia para a Excecao
	aArray[nLenArray,36] := P2_NONAHOR	//36 - Aponta Nona Hora
	aArray[nLenArray,37] := P2_HORMENO	//37 - Limite de Horario Inicial
	aArray[nLenArray,38] := P2_HORMAIS	//38 - Limite de Horario Final
	aArray[nLenArray,39] := P2_JND1CON	//39 - 1a. Jornada Continua
	aArray[nLenArray,40] := P2_JND2CON	//40 - 2a. Jornada Continua
	aArray[nLenArray,41] := P2_JND3CON	//41 - 2a. Jornada Continua
	aArray[nLenArray,42] := P2_JND4CON	//42 - 2a. Jornada Continua
	aArray[nLenArray,43] := P2_CODREF	//43 - Codigo da Refeicao
	aArray[nLenArray,44] := cRegra		//44 - Regra de Apontamento
	aArray[nLenArray,45] := P2_INIHNOT	//45 - Inicio da Hora Noturna
	aArray[nLenArray,46] := P2_FIMHNOT	//46 - Final da Hora Noturna
	aArray[nLenArray,47] := P2_MINHNOT	//47 - Minutos da Hora Noturna 
	aArray[nLenArray,48] := cHerdHor	//48 - Herda Hora (Mantem o Horario do Calendario)
	aArray[nLenArray,49] := P2_CODFUN1	//49 - Funcao 1a. Jornada
	aArray[nLenArray,50] := P2_CODFUN2	//50 - Funcao 2a. Jornada
	aArray[nLenArray,51] := P2_CODFUN3	//51 - Funcao 3a. Jornada
	aArray[nLenArray,52] := P2_CODFUN4	//52 - Funcao 4a. Jornada  
  	aArray[nLenArray,53] := P2_POSTO1	//53 - Posto 1a. Jornada
	aArray[nLenArray,54] := P2_POSTO2	//54 - Posto 2a. Jornada
	aArray[nLenArray,55] := P2_POSTO3	//55 - Posto 3a. Jornada
	aArray[nLenArray,56] := P2_POSTO4	//56 - Posto 4a. Jornada
	aArray[nLenArray,57] := P2_DEPTO1	//57 - Depto 1a. Jornada
	aArray[nLenArray,58] := P2_DEPTO2	//58 - Depto 2a. Jornada
	aArray[nLenArray,59] := P2_DEPTO3	//59 - Depto 3a. Jornada
	aArray[nLenArray,60] := P2_DEPTO4	//60 - Depto 4a. Jornada    
	aArray[nLenArray,61] := P2_ID		//61 - Id da excecao
	aArray[nLenArray,62] := P2_TPEXCE	//62 - Tipo de Excecao 'F' = Funcionario / 'P' = Periodo
	
Else //Carrega as Excecoes na Data
	aAdd( aArray , Array( 60 ) )
	nLenArray := Len( aArray )
	aArray[nLenArray,01] := dData					//01 - Data
	IF ( lArray )
	
		aArray[nLenArray,02] := aExcePer[nPos,04]	//02 - Turno
		aArray[nLenArray,03] := aExcePer[nPos,05]	//03 - CC
		aArray[nLenArray,04] := aExcePer[nPos,06]	//04 - Mat
		aArray[nLenArray,05] := aExcePer[nPos,07]	//05 - Entra1
		aArray[nLenArray,06] := aExcePer[nPos,08]	//06 - Saida1
		aArray[nLenArray,07] := aExcePer[nPos,09]	//07 - Entra2
		aArray[nLenArray,08] := aExcePer[nPos,10]	//08 - Saida2
		aArray[nLenArray,09] := aExcePer[nPos,11]	//09 - Entra3
		aArray[nLenArray,10] := aExcePer[nPos,12]	//10 - Saida3
		aArray[nLenArray,11] := aExcePer[nPos,13]	//11 - Entra4
		aArray[nLenArray,12] := aExcePer[nPos,14]	//12 - Saida4
		aArray[nLenArray,13] := aExcePer[nPos,15]	//13 - Intervalo1
		aArray[nLenArray,14] := aExcePer[nPos,16]	//14 - Intervalo2
		aArray[nLenArray,15] := aExcePer[nPos,17]	//15 - Intervalo3
		aArray[nLenArray,16] := aExcePer[nPos,18]	//16 - Horas Trabalhadas 1a. Jornada
		aArray[nLenArray,17] := aExcePer[nPos,19]	//17 - Horas Trabalhadas 2a. Jornada
		aArray[nLenArray,18] := aExcePer[nPos,20]	//18 - Horas Trabalhadas 3a. Jornada
		aArray[nLenArray,19] := aExcePer[nPos,21]	//19 - Horas Trabalhadas 4a. Jornada
		aArray[nLenArray,20] := aExcePer[nPos,22]	//20 - TabMarc("SP2") Numero de Marcacoes da Tabela
		aArray[nLenArray,21] := aExcePer[nPos,23]	//21 - Motivo
		aArray[nLenArray,22] := aExcePer[nPos,24]	//22 - HExt
		aArray[nLenArray,23] := aExcePer[nPos,25]	//23 - Traba
		aArray[nLenArray,24] := aExcePer[nPos,26]	//24 - HENot
		aArray[nLenArray,25] := aExcePer[nPos,27]	//25 - Recno
		aArray[nLenArray,26] := aExcePer[nPos,28]	//26 - Horas do 1o. Intervalo	
		aArray[nLenArray,27] := aExcePer[nPos,29]	//27 - Horas do 2o. Intervalo
		aArray[nLenArray,28] := aExcePer[nPos,30]	//28 - Horas do 3o. Intervalo
		aArray[nLenArray,29] := aExcePer[nPos,31]	//29 - Centro de Custo Periodo 1 (1a.E-1a.S)
		aArray[nLenArray,30] := aExcePer[nPos,32]	//30 - Centro de Custo Periodo 2 (2a.E-2a.S)
		aArray[nLenArray,31] := aExcePer[nPos,33]	//31 - Centro de Custo Periodo 3 (3a.E-3a.S)
		aArray[nLenArray,32] := aExcePer[nPos,34]	//32 - Centro de Custo Periodo 4 (4a.E-4a.S)
		aArray[nLenArray,33] := aExcePer[nPos,35]	//33 - Tipo do Dia para a Excecao
		aArray[nLenArray,34] := aExcePer[nPos,36]	//34 - Aponta Nona Hora
		aArray[nLenArray,35] := aExcePer[nPos,37]	//35 - Limite de Horario Inicial
		aArray[nLenArray,36] := aExcePer[nPos,38]	//36 - Limite de Horario Inicial
		aArray[nLenArray,37] := aExcePer[nPos,39]	//37 - 1a. Jornada Continua
		aArray[nLenArray,38] := aExcePer[nPos,40]	//38 - 2a. Jornada Continua
		aArray[nLenArray,39] := aExcePer[nPos,41]	//39 - 2a. Jornada Continua
		aArray[nLenArray,40] := aExcePer[nPos,42]	//40 - 2a. Jornada Continua
		aArray[nLenArray,41] := aExcePer[nPos,43]	//41 - Codigo da Refeicao
		aArray[nLenArray,42] := aExcePer[nPos,44]	//42 - Regra de Apontamento
		aArray[nLenArray,43] := aExcePer[nPos,45]	//43 - Inicio da Hora Noturna
		aArray[nLenArray,44] := aExcePer[nPos,46]	//44 - Final da Hora Noturna
		aArray[nLenArray,45] := aExcePer[nPos,47]	//45 - Minutos da Hora Noturna  
		aArray[nLenArray,46] := aExcePer[nPos,48]	//46 - Herda Hora (Mantem o Horario do Calendario) 
		aArray[nLenArray,47] := aExcePer[nPos,49]	//47 - Funcoes Periodo 1 (1a.E-1a.S)
		aArray[nLenArray,48] := aExcePer[nPos,50]	//48 - Funcoes Periodo 2 (2a.E-2a.S)
		aArray[nLenArray,49] := aExcePer[nPos,51]	//49 - Funcoes Periodo 3 (3a.E-3a.S)
		aArray[nLenArray,50] := aExcePer[nPos,52]	//50 - Funcoes Periodo 4 (4a.E-4a.S)
		aArray[nLenArray,51] := aExcePer[nPos,53]	//51 - Posto Periodo 1 (1a.E-1a.S)
		aArray[nLenArray,52] := aExcePer[nPos,54]	//52 - Posto Periodo 2 (2a.E-2a.S)
		aArray[nLenArray,53] := aExcePer[nPos,55]	//53 - Posto Periodo 3 (3a.E-3a.S)
		aArray[nLenArray,54] := aExcePer[nPos,56]	//54 - Posto Periodo 4 (4a.E-4a.S)
		aArray[nLenArray,55] := aExcePer[nPos,57]	//55 - Depto Periodo 1 (1a.E-1a.S)
		aArray[nLenArray,56] := aExcePer[nPos,58]	//56 - Depto Periodo 2 (2a.E-2a.S)
		aArray[nLenArray,57] := aExcePer[nPos,59]	//57 - Depto Periodo 3 (3a.E-3a.S)
		aArray[nLenArray,58] := aExcePer[nPos,60]	//58 - Depto Periodo 4 (4a.E-4a.S)		
		aArray[nLenArray,59] := aExcePer[nPos,61]	//59 - Id de excecao
		aArray[nLenArray,60] := aExcePer[nPos,62]	//60 - Tipo de Excecao 'F' = Funcionario / 'P' = Periodo
				
	Else
	
		aArray[nLenArray,02] :=	P2_TURNO			//02 - Turno
		aArray[nLenArray,03] := P2_CC				//03 - CC
		aArray[nLenArray,04] := P2_MAT				//04 - Mat
		aArray[nLenArray,05] := P2_ENTRA1			//05 - Entra1
		aArray[nLenArray,06] := P2_SAIDA1			//06 - Saida1
		aArray[nLenArray,07] := P2_ENTRA2			//07 - Entra2
		aArray[nLenArray,08] := P2_SAIDA2			//08 - Saida2
		aArray[nLenArray,09] := P2_ENTRA3			//09 - Entra3
		aArray[nLenArray,10] := P2_SAIDA3			//10 - Saida3
		aArray[nLenArray,11] := P2_ENTRA4			//11 - Entra4
		aArray[nLenArray,12] := P2_SAIDA4			//12 - Saida4
		aArray[nLenArray,13] := P2_INTERV1			//13 - Intervalo1
		aArray[nLenArray,14] := P2_INTERV2			//14 - Intervalo2
		aArray[nLenArray,15] := P2_INTERV3			//15 - Intervalo3
		aArray[nLenArray,16] := P2_HRSTRAB			//16 - Horas Trabalhadas 1a. Jornada
		aArray[nLenArray,17] := P2_HRSTRA2			//17 - Horas Trabalhadas 2a. Jornada
		aArray[nLenArray,18] := P2_HRSTRA3			//18 - Horas Trabalhadas 3a. Jornada
		aArray[nLenArray,19] := P2_HRSTRA4			//19 - Horas Trabalhadas 4a. Jornada
		aArray[nLenArray,20] := 0					//20 - TabMarc("SP2") Numero de Marcacoes da Tabela
		aArray[nLenArray,21] := P2_MOTIVO			//21 - Motivo
		aArray[nLenArray,22] := P2_CODHEXT			//22 - HExt
		aArray[nLenArray,23] := P2_TRABA			//23 - Traba
		aArray[nLenArray,24] := P2_CODHNOT			//24 - HENot
		aArray[nLenArray,25] := nRecno				//25 - Recno
		aArray[nLenArray,26] := P2_HRINTV1			//26 - Horas do 1o. Intervalo	
		aArray[nLenArray,27] := P2_HRINTV2			//27 - Horas do 2o. Intervalo
		aArray[nLenArray,28] := P2_HRINTV3			//28 - Horas do 3o. Intervalo
		aArray[nLenArray,29] := P2_CCPER01			//29 - Centro de Custo Periodo 1 (1a.E-1a.S)
		aArray[nLenArray,30] := P2_CCPER02			//30 - Centro de Custo Periodo 2 (2a.E-2a.S)
		aArray[nLenArray,31] := P2_CCPER03			//31 - Centro de Custo Periodo 3 (3a.E-3a.S)
		aArray[nLenArray,32] := P2_CCPER04			//32 - Centro de Custo Periodo 4 (4a.E-4a.S)
		aArray[nLenArray,33] := P2_TIPODIA			//33 - Tipo do Dia para a Excecao
		aArray[nLenArray,34] := P2_NONAHOR			//34 - Aponta Nona Hora
		aArray[nLenArray,35] := P2_HORMENO			//35 - Limite de Horario Inicial
		aArray[nLenArray,36] := P2_HORMAIS			//36 - Limite de Horario Inicial
		aArray[nLenArray,37] := P2_JND1CON			//37 - 1a. Jornada Continua
		aArray[nLenArray,38] := P2_JND2CON			//38 - 2a. Jornada Continua
		aArray[nLenArray,39] := P2_JND3CON			//39 - 2a. Jornada Continua
		aArray[nLenArray,40] := P2_JND4CON			//40 - 2a. Jornada Continua
		aArray[nLenArray,41] := P2_CODREF			//41 - Codigo da Refeicao
		aArray[nLenArray,42] := cRegra				//42 - Regra de Apontamento
		aArray[nLenArray,43] := P2_INIHNOT			//43 - Inicio da Hora Noturna
		aArray[nLenArray,44] := P2_FIMHNOT			//44 - Final da Hora Noturna
		aArray[nLenArray,45] := P2_MINHNOT			//45 - Minutos da Hora Noturna
		aArray[nLenArray,46] := cHerdHor			//46 - Herda Hora (Mantem o Horario do Calendario)
	    aArray[nLenArray,47] := P2_CODFUN1			//47 - Funcao Periodo 1 (1a.E-1a.S)
		aArray[nLenArray,48] := P2_CODFUN2			//48 - Funcao Periodo 2 (2a.E-2a.S)
		aArray[nLenArray,49] := P2_CODFUN3			//49 - Funcao Periodo 3 (3a.E-3a.S)
		aArray[nLenArray,50] := P2_CODFUN4			//50 - Funcao Periodo 4 (4a.E-4a.S)	 
	    aArray[nLenArray,51] := P2_POSTO1			//51 - Posto Periodo 1 (1a.E-1a.S)
		aArray[nLenArray,52] := P2_POSTO2			//52 - Posto Periodo 2 (2a.E-2a.S)
		aArray[nLenArray,53] := P2_POSTO3			//53 - Posto Periodo 3 (3a.E-3a.S)
		aArray[nLenArray,54] := P2_POSTO4			//54 - Posto Periodo 4 (4a.E-4a.S)	
	    aArray[nLenArray,55] := P2_DEPTO1			//55 - Depto Periodo 1 (1a.E-1a.S)
		aArray[nLenArray,56] := P2_DEPTO2			//56 - Depto Periodo 2 (2a.E-2a.S)
		aArray[nLenArray,57] := P2_DEPTO3			//57 - Depto Periodo 3 (3a.E-3a.S)
		aArray[nLenArray,58] := P2_DEPTO4			//58 - Depto Periodo 4 (4a.E-4a.S)
		aArray[nLenArray,59] := P2_ID				//59 - Id de excecao		
		aArray[nLenArray,60] := P2_TPEXCE			//60 - Tipo de Excecao 'F' = Funcionario / 'P' = Periodo

	EndIF
EndIF
	
Return( NIL )

/*/
зддддддддддбдддддддддддбддддддбдддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁPutHrsTab  ЁAutor Ё Marinaldo de Jesus    Ё Data Ё27/04/2001Ё
цддддддддддедддддддддддаддддддадддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁAtualiza as Horas da Tabela de Horario/Excecoes		        Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   ЁPutHrsTab( cAlias , lProcess )								Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁPar┐metrosЁcAlias   -> Alias da Tabela a Ser Atualizada                Ё
Ё          Ё            "SP2" -> Excecoes                               Ё
Ё          Ё            "SPJ" -> Tabela de Horario Padrao               Ё
Ё          ЁlProcess -> False Executa via Processa()                    Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       Ё                                                            Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function PutHrsTab( cAlias , lProcess )
Local aArea			:= GetArea()
Local bEval			:= { |e| &(e) }
Local cCond			:= ""
Local cPerg			:= ""
Local cPref			:= ""
Local cSeek			:= ""
Local nHoras		:= 0

Private lAbortPrint := .F.

DEFAULT cAlias	 := IF (lUseSPJ,"SPJ","RF3")
DEFAULT lProcess := .F.

cAlias	:= Upper( AllTrim( cAlias ) )
cPerg	:= IF( cAlias <> "SP2" , "PNCAPJ" , "PNCAP2" )
cPref	:= ( PrefixoCpo( cAlias ) + "_" )

If cAlias == "SPJ"
	cCond := "PJ_FILIAL+PJ_TURNO"
ElseIf ( cAlias == "RF3" .or. cAlias == "RF2" )
	cAlias	 := "RF2"
	cCond    := "RF2_FILIAL+RF2_TURNO"
Else
	cCond := "P2_FILIAL+DTOS(P2_DATA)"
EndIf	

IF !( lProcess )
	IF Pergunte( cPerg , .T. )
		Processa( { || PutHrsTab( cAlias , .T. ) } , IF( cAlias <> "SP2" , STR0061 , STR0062 ) ,, .T. )
		Return( NIL )
	EndIF
Else
	Pergunte( cPerg , .F. )
	dbSelectArea( cAlias )
	( cAlias )->( ProcRegua( RecCount() ) , dbGotop() , dbSetOrder( RetOrdem( cAlias , cCond ) ) )
	IF !Empty( xFilial( cAlias ) )
		cSeek := ( mv_par01 + IF( cAlias <> "SP2"  , mv_par03 , Dtos( mv_par03 ) ) )
	Else
		cSeek := ( Space(FWGETTAMFILIAL) + IF( cAlias <> "SP2"  , mv_par03 , Dtos( mv_par03 ) ) )
	EndIF
	( cAlias )->( dbSeek( cSeek , .T. ) )
	While ( cAlias )->( !Eof() .and. Eval( bEval , cCond ) <= mv_par02 + IF(cAlias <> "SP2" , mv_par04 , Dtos( mv_par04 ) ) )
	    IncProc( STR0063 )
	    IF ( lAbortPrint )
	    	Exit
	    EndIF	

		If cAlias == "RF2"
			fHorasRF2(cAlias)
		Else
	    	If RecLock( cAlias , .F. , .F. )
				nHoras := 0
				nHoras := __TimeSum(SomaHoras( nHoras , ( ( cAlias )->( IF( cAlias == "SPJ" , PJ_HRSINT1 , P2_HRINTV1 ) )	:= fHrsTrabGat( "I" , cAlias , "DB" , "1" ) ) ), 0 )
				nHoras := __TimeSum(SomaHoras( nHoras , ( ( cAlias )->( IF( cAlias == "SPJ" , PJ_HRSINT2 , P2_HRINTV2 ) ) := fHrsTrabGat( "I" , cAlias , "DB" , "2" ) ) ), 0 )
				nHoras := __TimeSum(SomaHoras( nHoras , ( ( cAlias )->( IF( cAlias == "SPJ" , PJ_HRSINT3 , P2_HRINTV3 ) ) := fHrsTrabGat( "I" , cAlias , "DB" , "3" ) ) ), 0 )
				nHoras := __TimeSum(SomaHoras( nHoras , ( ( cAlias )->( &(cPref+"HRSTRAB") ) := fHrsTrabGat( "H" , cAlias , "DB" , "1" ) ) ) ,0 )
				nHoras := __TimeSum(SomaHoras( nHoras , ( ( cAlias )->( &(cPref+"HRSTRA2") ) := fHrsTrabGat( "H" , cAlias , "DB" , "2" ) ) ) ,0 )
				nHoras := __TimeSum(SomaHoras( nHoras , ( ( cAlias )->( &(cPref+"HRSTRA3") ) := fHrsTrabGat( "H" , cAlias , "DB" , "3" ) ) ) ,0 )
				nHoras := __TimeSum(SomaHoras( nHoras , ( ( cAlias )->( &(cPref+"HRSTRA4") ) := fHrsTrabGat( "H" , cAlias , "DB" , "4" ) ) ) ,0 )
				( cAlias )->( IF( cAlias == "SPJ" , PJ_HRTOTAL , P2_TOTHORA ) ) := nHoras
						
			Endif
		
			( cAlias )->( MsUnLock() )
		EndIF	
		( cAlias )->( dbSkip() ) 
	End While
	RestArea(aArea)
EndIf
	
Return( NIL )

/*/
зддддддддддбдддддддддддбддддддбдддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁfHorasRF2  ЁAutor Ё Leandro Drummond	  Ё Data Ё03/06/2008Ё
цддддддддддедддддддддддаддддддадддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁAtualiza as Horas da Tabela de Horario/Excecoes				|
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   ЁfHorasRF2( cAlias )											Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁPar┐metrosЁcAlias   -> Alias da Tabela a Ser Atualizada                Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       Ё                                                            Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function fHorasRF2(cAlias)

Local aArea			:= GetArea()
Local cCondRF3		:= "RF3_FILIAL+RF3_JORN"
Local cCondRF4		:= "RF4_FILIAL+RF4_HOR"
Local cAliasRF3		:= "RF3"
Local cAliasRF4		:= "RF4"
Local cSeekRF3		:= ""
Local cSeekRF4		:= ""
Local nHoras		:= 0

dbSelectArea( cAliasRF4 )
dbGotop()
dbSetOrder( RetOrdem( cAliasRF4 , cCondRF4 ) )
cSeekRF4 := (cAlias)->( RF2_FILIAL + RF2_HOR )
( cAliasRF4 )->( dbSeek( cSeekRF4 ) )
While ( cAliasRF4 )->( !Eof() .and. RF4_FILIAL + RF4_HOR == cSeekRF4 )
	IF ( lAbortPrint )
    	Exit
    EndIF
    dbSelectArea( cAliasRF3 )
	dbGotop()
	dbSetOrder( RetOrdem( cAliasRF3 , cCondRF3 ) )			    
    cSeekRF3 := (cAliasRF4)->( RF4_FILIAL + RF4_JORN )
    ( cAliasRF3 )->( dbSeek( cSeekRF3 ) )
	While ( cAliasRF3 )->( !Eof() .and. RF3_FILIAL + RF3_JORN == cSeekRF3 )
    	IF ( lAbortPrint )
      		Exit
    	EndIF			    
	    IF RecLock( cAliasRF3 , .F. , .F. )
			nHoras := 0
			nHoras := __TimeSum(SomaHoras( nHoras , ( ( cAliasRF3 )->RF3_HRINT1	:= fHrsTrabGat( "I" , cAliasRF3 , "DB" , "1" ) ) ), 0 )
			nHoras := __TimeSum(SomaHoras( nHoras , ( ( cAliasRF3 )->RF3_HRINT2	:= fHrsTrabGat( "I" , cAliasRF3 , "DB" , "2" ) ) ), 0 )
			nHoras := __TimeSum(SomaHoras( nHoras , ( ( cAliasRF3 )->RF3_HRINT3 := fHrsTrabGat( "I" , cAliasRF3 , "DB" , "3" ) ) ), 0 )
			nHoras := __TimeSum(SomaHoras( nHoras , ( ( cAliasRF3 )->RF3_HRTRAB := fHrsTrabGat( "H" , cAliasRF3 , "DB" , "1" ) ) ) ,0 )
			nHoras := __TimeSum(SomaHoras( nHoras , ( ( cAliasRF3 )->RF3_HRTRA2 := fHrsTrabGat( "H" , cAliasRF3 , "DB" , "2" ) ) ) ,0 )
			nHoras := __TimeSum(SomaHoras( nHoras , ( ( cAliasRF3 )->RF3_HRTRA3	:= fHrsTrabGat( "H" , cAliasRF3 , "DB" , "3" ) ) ) ,0 )
			nHoras := __TimeSum(SomaHoras( nHoras , ( ( cAliasRF3 )->RF3_HRTRA4 := fHrsTrabGat( "H" , cAliasRF3 , "DB" , "4" ) ) ) ,0 )
			( cAliasRF3 )->RF3_HRSTOT:= nHoras
			( cAliasRF3 )->( MsUnLock() )
		EndIf
		( cAliasRF3 )->( dbSkip() )
	End While
    ( cAliasRF4 )->( dbSkip() )
End While

RestArea(aArea)

Return Nil
/*/
зддддддддддбддддддддддддддбдддддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁCheckPonMes   Ё Autor ЁMarinaldo de Jesus    Ё Data Ё14/05/2001Ё
цддддддддддеддддддддддддддадддддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁValida o Parametro de Fechamento do Ponto em Relacao ao PeriodoЁ
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide parametros Formais>									   Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide parametros Formais>									   Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁlRet -> Se a Competencia e' Valida                             Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁObserva┤└oЁ                                                      	       Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGenerica                                                       Ё
юддддддддддаддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function CheckPonMes(	dPerIni			,;	//Periodo Inicial de Apontamento
						dPerFim 		,;	//Periodo Final   de Apontamento
						lPut			,;	//Se True Grava Novo Periodo no Parametro do SX6
						lContinua		,;	//Se True Mesmo que o Periodo Nao For Valido ira contornar True.
						lShowHelp		,;	//Se False Nao Mostra o Help. DEFAULT True
						cFil			,;	//Filial para PerAponta()
						lNewPer			,;	//Se eh para gerar novo periodo (Para PerAponta())
						lPerCompleto	 ;	//Se o periodo esta preenchido com AAAAMMDD/AAAAMMDD ou AAAAMMDDAAAAMMDD (por referencia)
					 )

Local cHelp			:= ""
Local cPerg			:= "PONMES"
Local dIniFec		:= Ctod("//")
Local dFimFec		:= Ctod("//")
Local lRet			:= .T.
Local lExistPonMes	:= .T.
Local lModPer		:= .T.
Local uSaveMvPar	:= IF( Type("mv_par01") != "U" , mv_par01 , NIL )

DEFAULT	dPerIni		:= Ctod("//")
DEFAULT	dPerFim 	:= Ctod("//")
DEFAULT lPut		:= .F.
DEFAULT lContinua	:= .F.
DEFAULT lShowHelp	:= .T.
DEFAULT cFil		:= cFilAnt
DEFAULT lNewPer		:= .F.

IF ( lRet := CheckModSPO() )
	IF ( lRet := ( GetPonMesDat( @dIniFec , @dFimFec , cFil ) .and. !lPut ) )
		IF ( lRet := PerAponta( @dPerIni , @dPerFim , NIL , lShowHelp , cFil , NIL , @lPerCompleto ) )
			lRet := ( ( dIniFec == dPerIni ) .and. ( dFimFec <= dPerFim ) )
			IF ( !lRet .and. !lContinua .and. lShowHelp )
				cHelp += ( STR0064 + Dtoc( dIniFec ) + Chr(13) )					//'Data Inicial: '
				cHelp += ( STR0065 + Dtoc( dFimFec ) )								//'Data Final  : '
				Help( " " , 1 , "PERIIVALID" , , cHelp , 4 , 0 )
			ElseIF ( lContinua .and. !lRet )
				cHelp += STR0066													//'O Periodo de Apontamento: '
				cHelp += Dtoc( dIniFec )
				cHelp += STR0067													//' a '
				cHelp += Dtoc( dFimFec )                                        	
				cHelp += STR0068													//'ainda n└o foi Fechado. Deseja Continuar?'
				IF ( lShowHelp )
					lRet := MsgNoYes( OemToAnsi( cHelp ) , OemToAnsi( STR0069 ) )	//"Aten┤└o"
				Else
					lRet := .T.
				EndIF
			EndIF
		EndIF
	Else
		IF !( lPut )
			IF ( lShowHelp )
				SetMVValue(cPerg,"MV_PAR01",cTod("//"))
                If Pergunte( cPerg , .T.)
                    Pergunte( cPerg , .F.) // Acerto para atualizar o MV_PAR01
                Else
                    MV_PAR01    := cTod("//")
                EndIf
			EndIF
		EndIF
		IF ( lRet := PerAponta( @dPerIni , @dPerFim , IF( lPut , ( ++dPerFim ) , IF( Empty( mv_par01 ) .or. !( ValType( mv_par01 ) == "D" ) , dDataBase , mv_par01 ) ) , lShowHelp , cFil , lNewPer , @lPerCompleto ) )
			IF ( lPut .or. ( !lPut .and. !Empty( mv_par01 ) ) )
				IF !( lExistPonMes := PutMvFil( "MV_PONMES" , ( Dtos( dPerIni ) + "/" + Dtos( dPerFim ) ) , cFil ) )
					cHelp := OemToAnsi( STR0115 )										//'N└o Existe o Parametro MV_PONMES Para a Filial : '
					cHelp += CRLF
					cHelp += OemToAnsi( STR0116 )										//'Deseja Inclui-lo?'
					IF ( lShowHelp )
						IF MsgNoYes( OemToAnsi( cHelp ) , OemToAnsi( STR0069 ) )		//"Aten┤└o"
							IF ( lExistPonMes := CheckModSPO() )
								IF ( lExistPonMes := PutMvFil( "MV_PONMES" , ( Dtos( dPerIni ) + "/" + Dtos( dPerFim ) ) , cFil ) )
									lPut := .T.
								EndIF
							EndIF	
						EndIF
					EndIF
				Else
					lPut := .T.
				EndIF
		    EndIF
		    IF ( !( lPut ) .and. lExistPonMes )
			    IF ( lShowHelp )
			    	lRet := CheckPonMes( @dPerIni , @dPerFim , .F. , lContinua , lShowHelp , cFil , lNewPer )
	    		EndIF
	    	ElseIF !( lExistPonMes )
	    		IF ( lShowHelp )
	    			Help( " " , 1 , "NOMVPONMES" , , ( STR0114 + cFil ) , 4 , 0 ) //"Filial: "
	    		EndIF	
	    	EndIF                
	    Else
			IF ( lModPer )
				IF ( lShowHelp )
					lModPer := PonModPer( lModPer , cFil )
					lRet	:= CheckPonMes( @dPerIni , @dPerFim , .F. , .F. , .F. , cFil , .F. )
				EndIF
			EndIF
	    EndIF
	EndIF
EndIF
	
IF !Empty( uSaveMvPar )
	mv_par01 := uSaveMvPar
EndIF

Return( lRet )

/*/
зддддддддддбддддддддддддддбдддддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁValidArqPon   Ё Autor ЁMarinaldo de Jesus    Ё Data Ё14/05/2001Ё
цддддддддддеддддддддддддддадддддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁValida o Relacionamentos dos Arquivos do Ponto Eletronico      Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   ЁValidArqPon( lShowHelp )                           			   Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ                                         					   Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁlRet -> Se todos os Arquivos Estao com o Relacionamento CorretoЁ
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁObserva┤└oЁ                                                      	       Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGenerica                                                       Ё
юддддддддддаддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function ValidArqPon( lShowHelp )
Return( PonRelationFile( lShowHelp ) )

/*/
зддддддддддбдддддддддддддддбдддддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁPonRelationFileЁ Autor ЁMarinaldo de Jesus   Ё Data Ё14/05/2001Ё
цддддддддддедддддддддддддддадддддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁValida o Relacionamentos dos Arquivos do Ponto Eletronico      Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   ЁPonRelationFile( void )                            			   Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ                                         					   Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁlRet -> Se todos os Arquivos Estao com o Relacionamento CorretoЁ
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁObserva┤└oЁ                                                      	       Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGenerica                                                       Ё
юддддддддддаддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function PonRelationFile( lShowHelp )

Local cMsg			:= ""
Local lRetModo		:= .T.

Static lPonChkRel
Static cLastEmpChk

DEFAULT lShowHelp	:= .T.

DEFAULT lRF0ChkTable	:= fVerTabRF0()  	//Verifica a Existencia da Tabela de Pre-Abonos e se a mesm possui registro

/*/
здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Coloca o Ponteiro do Mouse em Estado de Espera               Ё
юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
IF ( lShowHelp )
	CursorWait()
EndIF	

/*/
здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Consiste o Modo de Acesso dos Arquivos                       Ё
юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Begin Sequence
	DEFAULT lPonChkRel 	:= .T.
	DEFAULT cLastEmpChk	:= FWCODEMP("SRA")
	IF ( cLastEmpChk <> FWCODEMP("SRA") )
		lPonChkRel := .T.
	EndIF
	IF !( lPonChkRel )
		Break
	EndIF
	IF !( lRetModo := xRetModo("SRA","SP2",lShowHelp) )
		Break
	EndIF
	IF !( lRetModo := xRetModo("SRA","SP5",lShowHelp) )
		Break
	EndIF
	IF !( lRetModo := xRetModo("SRA","SP8",lShowHelp) )
		Break
	EndIF
	IF !( lRetModo := xRetModo("SRA","SPB",lShowHelp) )
		Break
	EndIF
	IF !( lRetModo := xRetModo("SRA","SPC",lShowHelp) )
		Break
	EndIF
	IF !( lRetModo := xRetModo("SRA","SPF",lShowHelp) )
		Break
	EndIF
	IF !( lRetModo := xRetModo("SRA","SPG",lShowHelp) )
		Break
	EndIF
	IF !( lRetModo := xRetModo("SRA","SPH",lShowHelp) )
		Break
	EndIF
	IF !( lRetModo := xRetModo("SRA","SPI",lShowHelp) )
		Break
	EndIF
	IF !( lRetModo := xRetModo("SRA","SPK",lShowHelp) )
		Break
	EndIF
	IF !( lRetModo := xRetModo("SRA","SPL",lShowHelp) )
		Break
	EndIF
	IF !( lRetModo := xRetModo("SRA","SPN",lShowHelp) )
		Break
	EndIF
	IF !( lRetModo := xRetModo("SRA","SPS",lShowHelp) )
		Break
	EndIF	
	IF !( lRetModo := xRetModo("SRA","SPT",lShowHelp) )
		Break
	EndIF	
	
	//-- Se Existir a tabela de Pre-abonos, checa modo de acesso compativel
	IF lRF0ChkTable
		IF !( lRetModo := xRetModo("SRA","RF0",lShowHelp) )
			Break
		EndIF	
	Endif

	IF !( lRetModo := xRetModo("SR6","SPJ",lShowHelp) )
		Break
	EndIF
	IF !( lRetModo := xRetModo("SR6","RF8",lShowHelp) )
 		Break
 	EndIF
	IF !Empty( xFilial( "SP9" ) )
		IF !( lRetModo := xRetModo("SP9","SP4",lShowHelp) )
			Break
		EndIF
	EndIF	
	IF !( lRetModo := xRetModo("SP1","SPM",lShowHelp) )
		Break
	EndIF  
	
	IF ( GetMv( "MV_SP0SPEM" , NIL , "S" ) == "S" )
		IF !( lRetModo := xRetModo("SPE","SP0",lShowHelp) )
			Break
		EndIF
	EndIF
	IF !( lRetModo := xRetModo("SPU","SPV",lShowHelp) )
		Break
	EndIF
	IF !( lRetModo := xRetModo("SPU","SPX",lShowHelp) )
		Break
	EndIF
	IF !( lRetModo := xRetModo("SPY","SPZ",lShowHelp) )
		Break
	EndIF
	IF !( lRetModo := xRetModo("RF8","RF4",lShowHelp) )
		Break
	EndIF	
	IF !( lRetModo := xRetModo("RF4","RF3",lShowHelp) )
		Break
	EndIF		
	IF !( lRetModo := xRetModo("RF9","RF5",lShowHelp) )
		Break
	EndIF		
	IF !( lRetModo := xRetModo("RF6","RF7",lShowHelp) )
		Break
	EndIF		
	IF !( lRetModo := xRetModo("SR6","RF2",lShowHelp) )
		Break
	EndIF				                 
	IF !( lRetModo := ( __nTamP8Ordem == __nTamPGOrdem  ) )
		cMsg := STR0157	//'O Tamanho do Campo P8_ORDEM e diferente do Tamanho do Campo PG_ORDEM'
		cMsg += CRLF
		cMsg += STR0158 //'Contacte o Administrador do Sistema para compatibilizar os campos'
		Break
	EndIF
	lPonChkRel := .F.
End Sequence

/*/
здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Restaura o Ponteiro do Mouse                                 Ё
юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
IF ( lShowHelp )
	CursorArrow()
EndIF	

/*/
здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Se estiver Tudo Ok nao verifica Novamente					   Ё
юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
IF ( ( lPonChkRel := !( lRetModo ) ) .and. !Empty( cMsg ) )
	IF ( lShowHelp )
		MsgInfo( OemToAnsi( cMsg ) , OemToAnsi( STR0158 ) )	//  'Aten┤└o!'
	EndIF
EndIF

Return( lRetModo )

/*/Apenas para Compatibilizacao com Versoes Anterior*/
Function Classifica( aMarcacoes , aTabCalend  )       
Return( PutOrdMarc( aMarcacoes , aTabCalend ) )

/*/
зддддддддддбддддддддддддбдддддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁPutOrdMarc  Ё Autor ЁMarinaldo de Jesus    Ё Data Ё23/05/2001Ё
цддддддддддеддддддддддддадддддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁCarrega as Ordens no Array a Marcacoes de Acordo com o  CalenЁ
Ё          Ёdario de Marcacoes.                                          Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   ЁPutOrdMarc( @aMarcacoes , aTabCalend )						 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁaMarcacoes -> Array com as Marcacoes do Periodo    		     Ё
Ё          ЁaTabCalend -> Calendario de Marcacoes do Periodo   		     Ё
Ё          ЁlNotFlag   -> Exclui os Flags de Marcacao forcando o ReapontaЁ
Ё          Ё              mento.										 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁNIL                                                  	     Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁObserva┤└oЁ                                                      	     Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁApontamento                                                  Ё
юддддддддддаддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function PutOrdMarc( aMarcacoes , aTabCalend , lNotFlag, lAjustMarc, dPerIni, dPerFim, cFil, cMat )

Local aJaProc		:= {} 
Local aMarNextPer   := {}
Local aTabClone		:= {}
Local aDataApo		:= {}
Local cSpaceOrd		:= Space( __nTamP8Ordem )

Local bSemOrdem
Local bNoFlag
Local cOrd 
Local dDataApo 
Local dDataAnt  := Ctod("")
Local dUltData
Local cOrdAnt	:= ""  
Local cTurnoAnt	:= ""
Local cMarc
Local cTno
Local cSpacePer
Local cPerAponta  
Local cPerAnt
Local dDataOrd	:=Ctod(Space(8))
Local nTab
Local nVezTab
Local nMar 
Local nMar1 
Local nPrimMarc
Local nMarcSemOrdem	:= 0  
Local nOrd			:= 0
Local nVezMar
Local nVezMar1
Local nSvTab
Local nQtde
Local nHours      
Local nHoursTot	:= 0      
Local nPosDt
Local nTamPer

DEFAULT lNotFlag		:= .F.   
DEFAULT lAjustMarc   	:= .F.
DEFAULT dPerIni			:= Ctod("//")
DEFAULT dPerFim			:= Ctod("//")
DEFAULT cFil			:= SRA->RA_FILIAL
DEFAULT cMat			:= SRA->RA_MAT

/*/
здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Obtem o Tamanho do campo P8_PAPONTA						   Ё
юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
nTamPer := GetSx3Cache( "P8_PAPONTA" , "X3_TAMANHO" )
DEFAULT nTamPer := 16
cSpacePer := Space( nTamPer )

/*/
здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Limpa o Flag de Marcacoes Nao Ordenadas 					   Ё
юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
bSemOrdem := 	{ 	|x| ;
						IF(;
								( x[AMARC_ORDEM] == "__NaoOrdenada__" ),;			//Se Marcacao nao Ordenada
									(;
										( x[AMARC_ORDEM] 		:= cSpaceOrd ),;	//Preenche a Ordem com Brancos
										( x[AMARC_APONTA]		:= "N" ),;			//Desflega Apontamento
										( x[AMARC_PERAPONTA]	:= cSpacePer ),;	//Limpa Periodo de Apontamento
										( x[AMARC_DATAAPO]	    := Ctod("") ),;		//Limpa Data de Apontamento										
									),;
								x[AMARC_PERAPONTA] := cPerAponta;					//Carrega Periodo de Apontamento
						  );
		  		} 
/*/
здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Desflega  Marcacoes Apontados conforme lNotFlag			   Ё
юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/		  
bNoFlag :=	 { 	|x|   IF( lNotFlag , ( x[AMARC_APONTA] := "N" ) , NIL );		//Desflega Apontamento conforme lNotFlag
		 	 }

Begin Sequence

	IF ( Empty( aMarcacoes ) .or. Empty( aTabCalend ) )
		Break
	EndIF
	
	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	ЁObtem o Numero de Elementos do Calendario de Marcacoes        Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	nVezTab := Len( aTabCalend )

	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	ЁObtem o Periodo de Apontamento Conforme Calenario de MarcacoesЁ
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	cPerAponta		:= Dtos( aTabCalend[ 01 , CALEND_POS_DATA ] )
	cUltOrdem		:= aTabCalend[ nVezTab	, CALEND_POS_ORDEM	] 
	dUltData		:= aTabCalend[ nVezTab	, CALEND_POS_DATA_APO	] 
	cPerAponta		+= Dtos( dUltData )

	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Obtem o HorMais e HorMenos                                   Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	For nTab := 1 To nVezTab
		IF ( Empty( cOrd ) .or. ( cOrd != aTabCalend[ nTab , CALEND_POS_ORDEM ] ) )
			cOrd := aTabCalend[ nTab , CALEND_POS_ORDEM ]
		EndIF
		IF ( Empty( cTno ) .or. ( cTno != aTabCalend[ nTab , CALEND_POS_TURNO ] ) )
			cTno := aTabCalend[ nTab , CALEND_POS_TURNO ]
		EndIF	
		IF ( Empty( dDataApo) .or. ( dDataApo != aTabCalend[ nTab , CALEND_POS_DATA_APO ] ) )
			dDataApo := aTabCalend[ nTab , CALEND_POS_DATA_APO ]
		EndIF		
		IF !Empty( aTabCalend[ nTab , CALEND_POS_LIM_MARCACAO , 1 ] )
			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Se a Data de Apontamento for Diferente da Data Lida Anteriormente   Ё
			Ё recalcula as Horas Trabalhadas para a Data de Apontamento		      Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			If (dDataAnt <> dDataApo)
			  dDataAnt	:= dDataApo
			  nHours := 0 
			  aEval( aTabCalend , { |x| IF( x[CALEND_POS_DATA_APO] == dDataApo , nHours := SomaHoras( nHours , x[CALEND_POS_HRS_TRABA] ) , NIL ) }, nTab )
			Endif
			cMarc := DataHora2Str( aTabCalend[ nTab , CALEND_POS_LIM_MARCACAO , 1 ] , aTabCalend[ nTab , CALEND_POS_LIM_MARCACAO , 2 ] )
			aAdd( aDataApo ,  {	cOrd									,;	//01 - Ordem da Marcacao
						    	cTno									,; 	//02 - Turno da Marcacao
							    IF( Empty( nHours ) , "" , cMarc )		,; 	//03 - String para Comparacao correspondente ao HorMeno/HorMais para Dias Com Horas na Tabela
								aTabCalend[ nTab , CALEND_POS_DATA ] 	,; 	//04 - Data de Referencia da Ordem
								cMarc									,;	//05 - String para Comparacao correspondente ao HorMeno/HorMais para Marcacoes Nao Ordenadas
								dDataApo								;	//06 - Data de Apontamento da Marcacao
						      };
				 )
		EndIF	
		nHoursTot := SomaHoras( nHoursTot , aTabCalend[nTab, CALEND_POS_HRS_TRABA] ) 
	Next nTab
	
	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Corre Todas as Marcacoes 									   Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	nVezMar := Len( aMarcacoes )
	nVezTab := Len( aDataApo )
	nSvTab	:= 1

	For nMar := 1 To nVezMar  
		/*/
		здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Limpa Todas as Ordens de Marcacoes nao Infomadas/Modificadas Ё
		юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	    IF !aMarcacoes[nMar, AMARC_L_ORIGEM] 
	         aMarcacoes[nMar, AMARC_ORDEM] := cSpaceOrd 
	    Endif
    	/*/
		здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Ordena as Marcacoes com Horario no Calendario de Marcacoes   Ё
		юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/   	
		IF !Empty( nHoursTot )
			IF Empty( cMarc := aMarcacoes[ nMar , AMARC_DTHR2STR ] )
				cMarc	:= DataHora2Str( aMarcacoes[ nMar , AMARC_DATA ] , aMarcacoes[ nMar , AMARC_HORA ] )
			EndIF	
			For nTab := nSvTab To nVezTab Step 2
				IF ( ( cMarc >= aDataApo[ nTab , 3 ] ) .and. ( cMarc <= aDataApo[ nTab + 1 , 3 ] ) )
					IF !( aMarcacoes[ nMar , AMARC_L_ORIGEM ] )
						aMarcacoes[ nMar , AMARC_ORDEM ]:= aDataApo[ nTab , 1 ]
					EndIF
					aMarcacoes[ nMar , AMARC_TURNO ] 	:= aDataApo[ nTab , 2 ]
					aMarcacoes[ nMar , AMARC_DATAAPO ] 	:= aDataApo[ nTab , 6 ]					
					aMarcacoes[ nMar , AMARC_DTHR2STR ]	:= cMarc
					nSvTab := nTab
					Exit
				EndIF	
			Next nTab
		Endif
		
		/*/
		здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Obtem a Primeira Marcacao sem Ordem						   Ё
		юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/   	
		If Empty( nMarcSemOrdem ) 
		   If Empty( aMarcacoes[nMar, AMARC_ORDEM] )
		      nMarcSemOrdem:= nMar
		   Endif
		Endif
   		/*/
		здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Refaz Status da Marcacao para Reapontar ou Nao			   Ё
		юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		Eval(bNoFlag, aMarcacoes[nMar])
		
	Next nMar

	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Ordena as Marcacoes sem Horario no Calendario de Marcacoes   Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	IF ( !Empty(nMarcSemOrdem) )
	    nMar	:= nMarcSemOrdem
		For nMar := nMarcSemOrdem To nVezMar
			cOrd 		:= ""
			cTno 		:= "" 
			dDataApo	:= Ctod("")
			IF ( ( nMar := aScan( aMarcacoes , { |x| Empty( x[AMARC_ORDEM] ) } ) ) == 0 )
				Exit
			EndIF
			IF ( aScan( aJaProc , { |x| x == nMar } ) == 0 )
				aAdd( aJaProc , nMar )
			Else
				Exit
			EndIF	
			For nSvTab := nMar To nVezMar
				IF ( Empty( cOrd ) .and. ( ( nTab := aScan( aDataApo , { |x| Empty( x[3] ) .and. x[6] == aMarcacoes[ nMar , AMARC_DATAAPO ] } ) ) > 0 ) )
					IF Empty( cMarc := aMarcacoes[ nMar , AMARC_DTHR2STR ] )
						cMarc := DataHora2Str( aMarcacoes[ nMar , AMARC_DATA ] , aMarcacoes[ nMar , AMARC_HORA ] )
					EndIF	
					cOrd  	:= aDataApo[ nTab , 01 ]
					cTno  	:= aDataApo[ nTab , 02 ] 
					dDataApo:= aDataApo[ nTab , 06 ] 
					aDataApo[ nTab , 03 ] := aDataApo[ nTab + 1 , 03 ] := cMarc
				EndIF
				IF Empty( cOrd )
					cOrd := "__NaoOrdenada__"	//Ordem Nao Encontrada
					IF ( ( nPosDt := aScan( aMarcacoes , { |x| x[ AMARC_DATA ] == aMarcacoes[ nSvTab , AMARC_DATA ] .and. !Empty( x[AMARC_ORDEM] ) } ) ) > 0 )
						IF (;
								(;
									nQtde := 0 ,;
									aEval( aMarcacoes, { |x| IF( x[AMARC_DATAAPO] == aMarcacoes[ nPosDt , AMARC_DATAAPO ] , nQtde++ , NIL ) } ),;
									( nQtde % 2 > 0 );
								 );
							 )
							cOrd 	:= aMarcacoes[ nPosDt , AMARC_ORDEM ]
							cTno 	:= aMarcacoes[ nPosDt , AMARC_TURNO ]
							dDataApo:= aMarcacoes[ nPosDt , AMARC_DATAAPO ]
						EndIF
					EndIF
				EndIF
				IF (;
						Empty( aMarcacoes[ nSvTab , AMARC_ORDEM ] ) .and.;
						(;
						 	( aMarcacoes[ nSvTab , AMARC_DATA ] == aMarcacoes[ nMar , AMARC_DATA ] ) .or.;
							(;
								nQtde := 0 ,;
								aEval( aMarcacoes, { |x| IF( x[AMARC_DATAAPO] == dDataApo , nQtde++ , NIL ) } ),;
								( nQtde % 2 > 0 );
							);
						  );
					 )
					aMarcacoes[ nSvTab , AMARC_ORDEM ] 	:= cOrd
					aMarcacoes[ nSvTab , AMARC_TURNO ] 	:= cTno
					aMarcacoes[ nSvTab , AMARC_DATAAPO] := dDataApo
				Else
					Exit
				EndIF    
				/*/
				здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				Ё Refaz Status da Marcacao para Reapontar ou Nao			   Ё
				юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
				Eval(bNoFlag, aMarcacoes[nMar] )
			Next nSvTab
		Next nMar
		/*/
		здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Encaixa as Marcacoes Perdidas                                Ё
		юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		IF ( ( nMar := aScan( aMarcacoes , { |x| ( x[AMARC_ORDEM] == "__NaoOrdenada__" ) } ) ) > 0 )
			For nMar := nMar To nVezMar
				/*/
				здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				Ё Despreza Marcacoes ja Ordenadas                              Ё
				юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
				IF !( aMarcacoes[ nMar , AMARC_ORDEM ] == "__NaoOrdenada__" )
					Loop
				EndIF
				IF Empty( cMarc := aMarcacoes[ nMar , AMARC_DTHR2STR ] )
					cMarc := DataHora2Str( aMarcacoes[ nMar , AMARC_DATA ] , aMarcacoes[ nMar , AMARC_HORA ] )
				EndIF
				For nTab := 1 To nVezTab Step 2
					IF ( cMarc >= aDataApo[ nTab , 5 ] ) .and. ( cMarc <= aDataApo[ nTab + 1 , 5 ] )
						IF !( aMarcacoes[ nMar , AMARC_L_ORIGEM ] )
							aMarcacoes[ nMar , AMARC_ORDEM ]:= aDataApo[ nTab , 1 ]
						EndIF
						aMarcacoes[ nMar , AMARC_TURNO ] 	:= aDataApo[ nTab , 2 ]  
						aMarcacoes[ nMar , AMARC_DATAAPO ] 	:= aDataApo[ nTab , 6 ]  						
						aMarcacoes[ nMar , AMARC_DTHR2STR ]	:= cMarc
						Exit
					EndIF
				Next nTab             
 
			Next nMar
		EndIF
	EndIF
	
	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Tratamento  de modo a ajustar as marcacoes de saida de jorna Ё
	Ё da que devido a horas extras recairam na ordem seguinte.     Ё
	Ё (Inicialmente para tratamento de extras em jornada continua) Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	If lAjustMarc
	 	/*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		ЁReordena Calendario conforme a Data de Apontamento			  Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		aSort( @aMarcacoes , NIL , NIL , { |x,y|	(Dtos(x[AMARC_DATAAPO]) + x[AMARC_DTHR2STR] );
									 				<;
									     			(Dtos(y[AMARC_DATAAPO]) + y[AMARC_DTHR2STR] );
							     		  };
	 		  )

		/*/
		здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Corre Todas as Marcacoes 									   Ё
		юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		nNumMar	:= 0
		cOrdAnt	:= "!!" 
		For nMar := 1 To nVezMar
		  	
		  	cOrd	:= aMarcacoes[ nMar , AMARC_ORDEM ] 
		  	dDataApo:= aMarcacoes[ nMar , AMARC_DATAAPO ] 
		  	//-- Se a data da primeira marcacao da Data de Apontamento for maior ou igual a data final do periodo nЦo considera a 
		  	//-- marcacao pois provavelmente nao foram lidas todas as marcacoes do dia.
		  	If nNumMar == 0 
		  	   	dDataOrd:= aMarcacoes[nMar, AMARC_DATAAPO]
		  	   	If dDataOrd	> dPerFim
		  	   		Loop
		  	   	Endif  
		  	   	
		  	Endif
		  	
			//- Se a Data de Apontamento mudou  ou se for a Ultima Marcacao
			If ( dDataApo <> dDataAnt ) .or. ( nMar == nVezMar  .and. dDataOrd == dUltData)
			   //-- Verifica se houve marcacoes em quantidade impar  para o dia 
			   If (nNumMar % 2) > 0 .or. (  nMar == nVezMar )
			       
			       //-- Obtem as informacoes da Data de Apontamento anterior a quebra de Data de Apontamento
		           If ( nMar == nVezMar )
						/*/
						зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
						Ё Cria array com as marca┤■es do Proximo Periodo 		  	  Ё
						юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			            aMarNextPer	:= {}  
			            aTabClone	:= {}
						GetMarcacoes(	@aMarNextPer				,;	//01 -> Marcacoes dos Funcionarios
										@aTabClone					,;	//02 -> Calendario de Marcacoes
										NIL							,;  //03 -> Tabela Padrao
										NIL							,;  //04 -> Turnos de Trabalho  
										dPerFim+1					,;  //05 -> Periodo Inicial
										dPerFim+7					,;  //06 -> Periodo Final
										cFil						,;  //07 -> Filial
										cMat						,;  //08 -> Matricula 
										NIL							,;	//09 -> Turno
										NIL							,;	//10 -> Sequencia de Turno
										NIL							,;	//11 -> Centro de Custo
										NIL							,;	//12 -> Alias para Carga das Marcacoes
										NIL							,;	//13 -> Se carrega Recno em aMarcacoes
										NIL							,;	//14 -> Se considera Apenas Ordenadas
										NIL							,;  //15 -> Verifica as Folgas Automaticas
										NIL							,;  //16 -> Se Grava Evento de Folga Mes Anterior
										NIL							,;	//17 -> Se Carrega as Marcacoes Automaticas
										NIL							,;	//18 -> Registros de Marcacoes Automaticas que deverao ser Deletados
										NIL							,;	//19 -> Bloco para avaliar as Marcacoes Automaticas que deverao ser Desprezadas
										.F.							,;	//20 -> Se Considera o Periodo de Apontamento das Marcacoes
										.F.							 ;	//21 -> Se Efetua o Sincronismo dos Horarios na Criacao do Calendario
								 	)  

						 /*/
						зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
						Ё Ordena as marca┤■es                                         Ё
						юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
						PutOrdMarc( @aMarNextPer , aTabClone , .T. )   
				  
					    //-- Inicializa contador de quantidade de marcacoes para a ordem
				        nNumMar:= 0 
				        dDataAnt:=dDataApo  
				        nVezMar1:= Len(aMarNextPer)
					      
			            //-- Obtem as marcacoes para a primeira Data de Apontamento do periodo seguinte
			            dDataApo := Ctod("//")
			            For nMar1 := 1 To nVezMar1        
			                //-- Conta a quantidade de marcacoes para a proxima Data de Apontamento
			                If ( aMarNextPer[ nMar1 , AMARC_RECNO ] <> aMarcacoes[nMar,AMARC_RECNO])

							    If Empty(dDataApo) ///dDataApo == "!!"
			                    	dDataApo	:= aMarNextPer[ nMar1 , AMARC_DATAAPO ] 
			                    	nPrimMarc  	:= nMar1 
			                    Endif
			                    
			                	If aMarNextPer[nMar1, AMARC_DATAAPO] == dDataApo  
			                   		nNumMar++
			                	Else
			                		Exit
				                Endif
							Endif
			            Next nMar1   
			            
			            //-- Se a quantidade de marcacoes da Data de Apontamento seguinte for impar
			            //-- Ajusta a primeira marcacao da Data de Apontamento para a Data de Apontamento anterior
			            If (nNumMar % 2) > 0  
			                AADD(aMarcacoes, aClone( aMarNextPer[nPrimMarc] ) )
			                //Aeval(aMarNextPer, {|x|  AADD( aMarcacoes[ Len( aMarcacoes ) ], aClone( a ) ) } )
						    //-- Seta aMar
	                        nMar := Len(aMarcacoes)
					    Else
					    	Exit
					    Endif                  

		           Else
					    //-- Inicializa contador de quantidade de marcacoes para a Data de Apontamento
				        nNumMar:= 0  
			            For nMar1 := nMar To nVezMar        
			                //-- Conta a quantidade de marcacoes para a proxima Data de Apontamento
			                If aMarcacoes[nMar1, AMARC_DATAAPO] == dDataApo
			                   nNumMar++
			                Else
			                	  Exit
			                Endif
			            Next nMar1    
                   Endif 
                   
   			       
   			       //-- Se a quantidade de marcacoes da Data de Apontamento seguinte for impar
		           //-- Ajusta a primeira marcacao da Data de Apontamento para a ordem anterior
		           If ( (nNumMar % 2) > 0 .and. !(nNumMar == 1) )
				  	   aMarcacoes[ nMar , AMARC_ORDEM 		] := cOrdAnt
				  	   aMarcacoes[ nMar , AMARC_TURNO 		] := cTurnoAnt
					   aMarcacoes[ nMar , AMARC_DATAAPO 	] := dDataAnt				  	     
				  	   aMarcacoes[ nMar , AMARC_PERAPONTA 	] := cPerAnt
				  	   	/*/
						здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
						Ё Refaz Status da Marcacao para Reapontar ou Nao			   Ё
						юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
						Eval(bNoFlag, aMarcacoes[nMar])
					    nNumMar		:= 0    			       
					    cOrdAnt		:= "!!"
						Loop
				   Endif 
			   Endif    
		       dDataAnt		:= aMarcacoes[ nMar , AMARC_DATAAPO		]  
		       cOrdAnt		:= aMarcacoes[ nMar , AMARC_ORDEM 		]   
		       cTurnoAnt	:= aMarcacoes[ nMar , AMARC_TURNO 		]   
		       cPerAnt		:= aMarcacoes[ nMar , AMARC_PERAPONTA 	]   
		        
			   nNumMar		:= 0    			       
			Endif
			
			nNumMar++
		Next nMar

    Endif
    

	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Refaz Status da Marcacao em funcao de estar ou nao ordenada  Ё
	Ё e atualiza o periodo de apontamento						   Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	aEval( @aMarcacoes , bSemOrdem )                               

    
End Sequence
	
Return( NIL )

/*/
зддддддддддбддддддддддддбдддддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁfTipoExtra  Ё Autor ЁMarinaldo de Jesus    Ё Data Ё31/03/2001Ё
цддддддддддеддддддддддддадддддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁValida os Tipos de Horas Extras                              Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   ЁfTipoExtra( cTipo , @cDescr )              			 		 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁcTipo     -> Tipo das Horas Extras                     		 Ё
Ё          ЁcDescr 	  -> Descriacao das Horas Extras               		 Ё
Ё          ЁlShowHelp -> Mostrar o Help                            		 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁlRet                                                 	     Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁObserva┤└oЁ                                                      	     Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁApontamento                                                  Ё
юддддддддддаддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function fTipoExtra( cTipo , cDescr , lShowHelp )

Local aTipos 		:= Array( 16 , 2 )
Local lRet	 		:= .T.
Local nPos	 		:= 0

DEFAULT cTipo		:= ""
DEFAULT cDescr		:= ""
DEFAULT lShowHelp	:= .T.

aTipos[ 01 , 01 ] :=  "1" ; aTipos[ 01 , 02 ] := STR0070 //'Normal'
aTipos[ 02 , 01 ] :=  "2" ; aTipos[ 02 , 02 ] := STR0071 //'D.S.R.'
aTipos[ 03 , 01 ] :=  "3" ; aTipos[ 03 , 02 ] := STR0072 //'Compensado'
aTipos[ 04 , 01 ] :=  "4" ; aTipos[ 04 , 02 ] := STR0073 //'Feriado'
aTipos[ 05 , 01 ] :=  "5" ; aTipos[ 05 , 02 ] := STR0074 //'Normal Noturna'
aTipos[ 06 , 01 ] :=  "6" ; aTipos[ 06 , 02 ] := STR0075 //'D.S.R. Noturna'
aTipos[ 07 , 01 ] :=  "7" ; aTipos[ 07 , 02 ] := STR0076 //'Compensada Noturna'
aTipos[ 08 , 01 ] :=  "8" ; aTipos[ 08 , 02 ] := STR0077 //'Feriado Noturna'
aTipos[ 09 , 01 ] :=  "A" ; aTipos[ 09 , 02 ] := STR0078 //'Intervalo'
aTipos[ 10 , 01 ] :=  "B" ; aTipos[ 10 , 02 ] := STR0079 //'Intervalo Noturna'
aTipos[ 11 , 01 ] :=  "C" ; aTipos[ 11 , 02 ] := STR0195 //'Intervalo DSR'
aTipos[ 12 , 01 ] :=  "D" ; aTipos[ 12 , 02 ] := STR0196 //'Intervalo Noturna DSR'
aTipos[ 13 , 01 ] :=  "E" ; aTipos[ 13 , 02 ] := STR0197 //'Intervalo Compensado'
aTipos[ 14 , 01 ] :=  "F" ; aTipos[ 14 , 02 ] := STR0198 //'Intervalo Noturna Compensado'
aTipos[ 15 , 01 ] :=  "G" ; aTipos[ 15 , 02 ] := STR0199 //'Intervalo Feriado'
aTipos[ 16 , 01 ] :=  "H" ; aTipos[ 16 , 02 ] := STR0200 //'Intervalo Noturna Feriado'

IF ( lRet := ( ( nPos := aScan( aTipos , { |x| x[1] == cTipo } ) ) > 0 ) )
	cDescr := aTipos[ nPos , 2 ]
ElseIF lShowHelp
	Help(" ",1,"CTIPOHE")
EndIF

Return( lRet )

/*/
зддддддддддбддддддддддддбдддддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁGetTabArred	Ё Autor ЁMarinaldo de Jesus    Ё Data Ё12/04/2001Ё
цддддддддддеддддддддддддадддддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁCarrega as Tabelas de Arredondamentos do SPD                 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   ЁGetTabArred( cFil , cTno , cTip )							 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁcFil -> Filial Para a Pesquisa no SP5              		     Ё
Ё          ЁcTno -> Turno  Para a Pesquisa no SP5              		     Ё
Ё          ЁcTip -> Tipo do Arredondamento a Ser Carregado     		     Ё
Ё          Ё        "A" -> Atrasos                             		     Ё
Ё          Ё        "D" -> DSR                                 		     Ё
Ё          Ё        "F" -> Faltas                              		     Ё
Ё          Ё        "H" -> Horas Extras                        		     Ё
Ё          Ё        "N" -> Horas Noturnas                      		     Ё
Ё          Ё        "S" -> Saidas Antecipadas                  		     Ё
Ё          Ё        "9" -> Nona Hora                           		     Ё
Ё          ЁlFullTable -> .T. -> Carrega toda a tabela de Arredondamento Ё
Ё          Ё               para a Filial informada  	       		     Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁaCloneTabArr <=> Array Contendo as Tabelas de ArredondamentosЁ
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁApontamento                                                  Ё
юддддддддддаддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function GetTabArred( cFil , cTno , cTip, lFullTable )

Local bAscan		:= { || .T. }
Local cKey			:= ""
Local cKeyPesq		:= ""
Local cLenTno		:= ""
Local cTipo			:= ""
Local cAlias		:= "SPD"
Local cAliasQuery	:= cAlias
Local cChave		:= ""
Local lTnoOrFil		:= .T.
Local lAtu			:= .T.    
Local lQueryOpened	:= .F.
Local nArreds		:= 0
Local nTabs			:= 0
Local nPos			:= 0
Local nOrder		:= RetOrdem( "SPD" , "PD_FILIAL+PD_TIPO+PD_TURNO" )
Local nSvOrder		:= SPD->( IndexOrd() ) 

#IFDEF TOP
	Local cPrefixo		:= ( PrefixoCpo( cAlias ) + "_" )
	Local cQuery		:= ""
	Local cSvQuery		:= ""
	Local cSvAlias		:= Alias()
	Local nX			:= 0

	Static aSpdFields
	Static cQrySpdFields
	Static nSpdFields
#ENDIF

DEFAULT cTip		:= "ADFHNS9"
DEFAULT cFil		:= SRA->RA_FILIAL
DEFAULT cTno		:= SRA->RA_TNOTRAB
DEFAULT lFullTable	:= .F.  

#IFDEF TOP

	IF !( lExInAs400 )

		cAliasQuery := ( "__Q" + cAliasQuery + "QRY" )

		DEFAULT aSpdFields := ( cAlias )->( dbStruct() )
		DEFAULT nSpdFields := Len( aSpdFields )
	
		IF ( cQrySpdFields == NIL )
			cQrySpdFields := ""
			For nX := 1 To nSpdFields
				cQrySpdFields += aSpdFields[ nX , 01 ] + ", "
			Next nX
		EndIF
		
	EndIF

#ENDIF
                               
cLenTno		:= Space( GetSx3Cache( "PD_TURNO  " , "X3_TAMANHO" ) ) 
cTip		:= StrTran( cTip , " " , "" )
cTipo		:= cTip
cFil		:= xFilial( cAlias , cFil )

/*/
здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Monta Bloco para Pesquisa dos Tipos de Arredondamento.       Ё
юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
baScan		:= { |x| If(  !lFullTable,;
										 ( ( x[1] == cFil ) .or. Empty( x[1] ) )   	;
									  	  .and.								 	   		;
									     ( ( x[2] == cTno ) .or. Empty( x[2] ) )   	;
									     .and.								 	   		;
									     ( x[3] == cTipo ) 						   		,;
								     	 ( ( x[1] == cFil ) .or. Empty( x[1] ) )   	;
						) ;		     	 
		   		}



DEFAULT	__aTabArr	:= {}
DEFAULT	__aTabFilArr:= {}


/*/
здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Se foi Selecionado apenas um Determinado Tipo                Ё
юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
IF !lFullTable 
	IF ( nTabs := Len( cTipo ) ) == 1
		IF !Empty( __aTabArr )
			lAtu := ( ( nPos := aScan( __aTabArr , bAscan ) ) == 0 .or. ( nPos > 0 .and. Empty( __aTabArr[nPos , 2] ) ) )
		EndIF
	Else
		/*/
		здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Caso contrario Considera Todos os Tipos Validos              Ё
		юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		cTip := "ADFHNS9"
	EndIF
Else           
    /*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Forca Carregar Todas as Tabelas de Arredondamento da Filial  Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	IF !Empty( __aTabArr )
			lAtu 	:= ( ( nPos := aScan( __aTabArr , bAscan ) ) == 0  )  
	Endif		
	nTabs	:= 1 
	cTip 	:= "ADFHNS9" 
	cTno	:=  cLenTno  
EndIF

/*/
здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Se a Tabela de Arredondamento Estiver Vazia ou se for forcadaЁ
Ё uma Atualizacao											   Ё
юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
IF ( Empty( __aTabArr ) .or. ( lAtu ) )
	
	IF !Empty( nTabs )

		/*/
		здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Seta a Ordem para Pesquisa                                   Ё
		юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		IF !( nSvOrder == nOrder )
			SPD->( dbSetOrder( nOrder ) )
		EndIF

		/*/
		здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Verifica os Tipos de Arredondamento                          Ё
		юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		For nArreds := 1 To nTabs
		    
		

			/*/
			здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			ЁVerifica se o Tipo em Questao ja foi Carregado e se possui conЁ
			Ёteudo														   Ё
			юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/  
			IF !lFullTable 
				cTipo := SubStr( cTip , nArreds , 1 )
				lAtu:= ( ( ( nPos := aScan( __aTabArr , bAscan ) ) == 0 )  .or. ( nPos > 0 .and. Empty( __aTabArr[nPos , 2] ) ) )
			Else	                                 
				cTipo := SPACE(1)
				lAtu:= ( ( nPos := aScan( __aTabArr , bAscan ) ) == 0 )
			Endif
			
			If 	lAtu
				/*/
				здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				ЁSe For TOP						                               Ё
				юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
				#IFDEF TOP
					IF !( lExInAs400 )
						/*/
						здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
						ЁMonta Query para pesquisa do Turno Especifico                 Ё
						юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
						cQuery		:= "SELECT "
						cQuery		+= cQrySpdFields
						cQuery		:= SubStr( cQuery , 1 , Len( cQuery ) - 2 )
						cQuery		+= " FROM "
						cQuery		+= InitSqlName( cAlias )
						cQuery		+= " WHERE "
						cQuery		+= cPrefixo+"FILIAL='"+cFil+"'"
						cQuery		+= " AND " 
						If !lFullTable
							cQuery		+= cPrefixo+"TIPO='"+cTipo+"'"
							cQuery		+= " AND "
							cQuery		+= cPrefixo+"TURNO='"+cTno+"'"
							cQuery		+= " AND "
						Endif	
						cQuery		+= "D_E_L_E_T_=' ' "
						cQuery		+= "ORDER BY " + SqlOrder( (cAlias)->( IndexKey() ) )
						cSvQuery	:= cQuery
						cQuery		:= ChangeQuery( cQuery )
						/*/
						здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
						ЁVerifica se conseguiu Montar a Query                          Ё
						юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
						IF ( lQueryOpened := MsOpenDbf(.T.,"TOPCONN",TcGenQry(NIL,NIL,cQuery),cAliasQuery,.F.,.T.) )
							For nX := 1 To nSpdFields
								IF !( aSpdFields[ nX , 02 ] == "C" )
									TcSetField(cAliasQuery,aSpdFields[nX,01],aSpdFields[nX,02],aSpdFields[nX,03],aSpdFields[nX,04])
								EndIF
							Next nX
							
							/*/
							здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
							ЁSe nao achou o Turno Especifico	                           Ё
							юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
							lTnoOrFil := ( cAliasQuery )->( !Eof() )  
							
							IF !( lTnoOrFil )
								( cAliasQuery )->( dbCloseArea() )	
								IF !lFullTable
									/*/
									здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
									ЁMonta Query para pesquisa do Turno Generico ( Em Branco )     Ё
									юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
									cQuery := StrTran( cSvQuery , ( "TURNO='"+cTno+"'" ) , ( "TURNO='"+cLenTno+"'" ) )
									cQuery := ChangeQuery( cQuery )
									/*/
									здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
									ЁVerifica se conseguiu Montar a Query para o Turno Generico    Ё
									юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
									IF ( lQueryOpened := MsOpenDbf(.T.,"TOPCONN",TcGenQry(NIL,NIL,cQuery),cAliasQuery,.F.,.T.) )
										For nX := 1 To nSpdFields
											IF !( aSpdFields[ nX , 02 ] == "C" )
												TcSetField(cAliasQuery,aSpdFields[nX,01],aSpdFields[nX,02],aSpdFields[nX,03],aSpdFields[nX,04])
											EndIF
										Next nX
										/*/
										здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
										ЁSe nao Existia o Tipo para o Turno Generico (Em Branco)       Ё
										юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
										IF ( nPos == 0 )
											/*/
											здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
											ЁPesquisa o Turno Generico ( Em Branco )                       Ё
											юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
											IF ( cAliasQuery )->( Eof() )
												/*/
												здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
												ЁSe nao Encontrou o Turno Generico, carrega Tabela Vazia       Ё
												юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
												aAdd( __aTabArr , { cFil , cLenTno , cTipo , {} } )
												( cAliasQuery )->( dbCloseArea() )
												Loop
											EndIF
										EndIF
									Else
										/*/
										здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
										ЁCaso contrario Pesquisa Direto no Arquivo                     Ё
										юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
										cAliasQuery := cAlias
									EndIF
								Else
									/*/
									здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
									ЁSe nao Existia o Tipo para o Turno Generico (Em Branco)       Ё
									юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
									IF ( nPos == 0 )
										/*/
										здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
										ЁSe nao Encontrou a Filial, carrega Tabela Vazia       		   Ё
										юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
										aAdd( __aTabArr , { cFil , cLenTno , cTipo , {} } )
										Loop                                                                       
									Endif	
								Endif	
							Endif	
						Else
							/*/
							здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
							ЁCaso contrario Pesquisa Direto no Arquivo                     Ё
							юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
							cAliasQuery := cAlias
						EndIF
					EndIF
				#ENDIF

				IF !( lQueryOpened )
					/*/
					здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
					ЁProcura pelo Turno Especifico	 		                       Ё
					юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/ 
					IF !lFullTable
						cKeyPesq 	:=  cFil + cTipo + cTno 
					Else                                       
						cKeyPesq 	:=  cFil 
					Endif
					
					lTnoOrFil := ( cAliasQuery )->( dbSeek( cKeyPesq ) ) 

					/*/
					здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
					ЁSe nao Existe o Turno Especifico procura pelo Generico        Ё
					юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/ 
					IF !( lTnoOrFil )
						IF !lFullTable
							/*/
							здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
							ЁSe nao Existia o Tipo para o Turno Generico (Em Branco)       Ё
							юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
							IF ( nPos == 0 )
								/*/
								здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
								ЁPesquisa o Turno Generico ( Em Branco )                       Ё
								юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
								IF ( cAliasQuery )->( !dbSeek( cFil + cTipo + cLenTno ) )
									/*/
									здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
									ЁSe nao Encontrou o Turno Generico, carrega Tabela Vazia       Ё
									юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
									aAdd( __aTabArr , ( cAliasQuery )->( { cFil , PD_TURNO , PD_TIPO , {} } ) )
									Loop
								EndIF
							Endif	
						Else
							If ( nPos == 0 )
								/*/
								здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
								ЁSe nao Encontrou a Filial, carrega Tabela Vazia       		   Ё
								юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
								aAdd( __aTabArr , { cFil , cLenTno , cTipo , {} } )
								Loop
							Endif	
						EndIF
					Endif	
                EndIF
				
				/*/
				здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				Ё Se Encontrou o Turno e Este ainda nao Esta Carregado         Ё
				юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
				IF ( ( lTnoOrFil ) .or. ( nPos == 0 ) )
				
					If !lFullTable
						/*/
						здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
						Ё Carrega as Informacoes para o Turno						   Ё
						юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
						aAdd( __aTabArr , { cFil , IF( lTnoOrFil , cTno , cLenTno ) , cTipo , {} } )
						nPos := Len( __aTabArr )
	
						/*/
						здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
						Ё Carrega os Itens para o Turno      						   Ё
						юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
						cKey := ( cFil + cTipo + IF( lTnoOrFil , cTno , cLenTno ) )
						While ( cAliasQuery )->( !Eof() .and. PD_FILIAL+PD_TIPO+PD_TURNO == cKey )
						    ( cAliasQuery )->( aAdd( __aTabArr[ nPos , 4 ] , { PD_DE , PD_ATE , PD_HORAS } ) )
							( cAliasQuery )->( dbSkip() )
						End While
                    Else 
						/*/
						здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
						Ё Carrega todos Itens para Filial      						   Ё
						юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/  
						cKey:= ""
						While ( cAliasQuery )->( !Eof() .and. ( PD_FILIAL == cFil ) )
							If ( cKey <> ( cAliasQuery )->( cFil + PD_TIPO + PD_TURNO )  )
							     cKey := ( cAliasQuery )->( cFil + PD_TIPO + PD_TURNO )  
								/*/
								здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
								Ё Carrega as Informacoes para a Filial + Tipo + Turno		   Ё
								юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
								aAdd( __aTabArr , ( cAliasQuery )->( { cFil , PD_TURNO , PD_TIPO , {} } ) )
								nPos := Len( __aTabArr )								
							Endif	                    
					    	( cAliasQuery )->( aAdd( __aTabArr[ nPos , 4 ] , { PD_DE , PD_ATE , PD_HORAS } ) )
							( cAliasQuery )->( dbSkip() )
						End While
                    Endif
				EndIF

				#IFDEF TOP
					/*/
					здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
					ЁSe Montou a Query, Fecha-a                                    Ё
					юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
					IF ( ( lQueryOpened ) .and. ( Select( cAliasQuery ) > 0 ) )
						( cAliasQuery )->( dbCloseArea() )
					EndIF
				#ENDIF
				
			EndIF
	
		Next nArreds

		/*/
		здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Restaura a Ordem de Entrada         					   	   Ё
		юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		IF !( nSvOrder == nOrder )
			SPD->( dbSetOrder( nSvOrder ) )
		EndIF

	Else

		/*/
		здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Neste Caso nao Foi passado Nenhum Tipo de Arredondamento 	   Ё
		юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		aAdd( __aTabArr , { "" , "" , "" , {} } )

	EndIF
	
EndIF

#IFDEF TOP
	/*/
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	ЁGarante o Fechamento da Query no retorno da funcao           Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	IF ( Select( cAliasQuery ) > 0 )
		( cAliasQuery )->( dbCloseArea() )
	EndIF
	/*/
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	ЁRestaura dados de Entrada                                    Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	IF ( Select( cSvAlias ) > 0 )
		dbSelectArea( cSvAlias )
	EndIF
#EndIF
	
Return( aClone( __aTabArr ) )

/*/
зддддддддддбддддддддддддддддбдддддбдддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁRstGetTabArred	ЁAutorЁMarinaldo de Jesus Ё Data Ё11/03/2003Ё
цддддддддддеддддддддддддддддадддддадддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁReinicializa as Staticas utilizadas em GetTabArred()       	Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGenerico													Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function RstGetTabArred() 
__aTabArr 		:= 	NIL 
__aTabFilArr	:=  NIL
Return( NIL )

/*/
зддддддддддбддддддддддддбдддддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁRetTabArred	Ё Autor ЁMarinaldo de Jesus    Ё Data Ё10/04/2002Ё
цддддддддддеддддддддддддадддддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁRetorna Tabela de Arredondamento Especifica baseada no  ArrayЁ
Ё          ЁCarregado Atraves de GetTabArred()							 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   ЁRetTabArred( aArreds , cFil , cTno , cTip )					 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁaArreds -> Array com todos as Tabelas de Arredondamentos	 Ё
Ё          ЁcFil 	-> Filial para Procura								 Ё
Ё          ЁcTno	-> Turno  Para a Pesquisa no SP5              		 Ё
Ё          ЁcTipo	-> Tipo do Arredondamento a Ser Carregado     		 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁaArred  -> Tabela com Arredondamento Especifico				 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁApontamento                                                  Ё
юддддддддддаддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function RetTabArred( aArreds , cFil , cTno , cTipo )

Local aArred := {}
Local bAscan := { || .T. }
Local nPosAr := 0

baScan	:= { |x| ( ( x[1] == cFil ) .or. Empty( x[1] ) ) ;
			  	 .and.								 	 ;
			      ( x[2] == cTno )						 ;
			     .and.								 	 ;
			     ( x[3] == cTipo )						 ;
			}

IF ( ( nPosAr := aScan( aArreds , bAscan ) ) == 0 )
	baScan	:= { |x| ( ( x[1] == cFil ) .or. Empty( x[1] ) ) ;
				  	 .and.								 	 ;
				     Empty( x[2] )							 ;
				     .and.								 	 ;
			    	 ( x[3] == cTipo )						 ;
				}
	nPosAr := aScan( aArreds , bAscan )
EndIF

IF ( nPosAr > 0 )
	aArred := aClone( aArreds[ nPosAr , 4 ] )
EndIF

Return( aClone( aArred ) )

/*/
зддддддддддбддддддддддддбдддддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁfArredHoras	Ё Autor ЁMarinaldo de Jesus    Ё Data Ё12/04/2001Ё
цддддддддддеддддддддддддадддддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁEfetua o Arredondamento de Horas de Acordo com o Array       Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁnHrs   -> Horas Arredondadas                                 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁApontamento                                                  Ё
юддддддддддаддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function fArredHoras(	nHrs		,;	//01 -> Horas a Serem Arredondadas
						aArrs		,;	//02 -> Array com os Arredondamentos
						cTip		,;	//03 ->	Tipo de Horas a Arredondar:"A"trasos ; "D"SR ; "F"altas ; "H"oras Extras ; "N"Horas Noturnas ; "S"aidas Antecipadas
						cFil		,;	//04 -> Filial Para a Pesquisa no SP5
						cTno		,;	//05 -> Turno  Para a Pesquisa no SP5
						lArrdIntegr	 ;	//06 -> Se Arredonda as Horas Integralmente	
					 )
                                                          
Local nArrVal		:= 0
Local nArre			:= 0
Local nLenArre		:= 0

DEFAULT nHrs		:= 0
DEFAULT aArrs		:= {}
DEFAULT cTip		:= ""
DEFAULT cFil		:= SRA->RA_FILIAL
DEFAULT cTno		:= SRA->RA_TNOTRAB
DEFAULT lArrdIntegr	:= .F.

IF ( !Empty( cTip ) .and. Empty( aArrs ) )
	aArrs := ( GetTabArred( cTip , cFil , cTno  )[ 1 , 3 ] )
EndIF

nLenArre := Len( aArrs )
For nArre := 1 To nLenArre
	nArrVal := IF( !( lArrdIntegr ) , SubHoras( nHrs , __NoRound( nHrs , 0 ) ) , nHrs )
	IF (;
			( __NoRound( nArrVal , 2 ) >= __NoRound( aArrs[ nArre , 1 ] , 2 ) );
			.and.;
  	   		( __NoRound( nArrVal , 2 ) <= __NoRound( aArrs[ nArre , 2 ] , 2 ) );
  	   	)	
		IF !( lArrdIntegr )
			nHrs := SomaHoras( __NoRound( nHrs , 0 ) , aArrs[ nArre , 3 ] )
		Else
			nHrs := aArrs[ nArre , 3 ]
		EndIF
		Exit
	EndIF
Next nArre

Return( nHrs )

/*/
зддддддддддбддддддддддддбдддддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁGetTabExtra	Ё Autor ЁMarinaldo de Jesus    Ё Data Ё16/04/2001Ё
цддддддддддеддддддддддддадддддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁCarrega Array com os Tipos de Horas Extras                   Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁlRet      -> True se Conseguir Carregar os Tipos de H.E.     Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁApontamento                                                  Ё
юддддддддддаддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function GetTabExtra(	aTabExtra		,;	//01 -> Array a ser Carregado com os Tipos de H.E.
						cFil			,;	//02 -> Filial para Pesquisa no SP4
						cTno			,;	//03 -> Turno para Pesquisa no SP4
						lTodas			,;	//04 -> Atualizar as Tabelas de Horas Extras
						lShowHelp		,;	//05 -> Mostrar o Help
						lEscalonar		,;	//06 -> Se trata o escalonamento
						nErrorNumber	,;	//07 -> Numero de retorno de erro. 1 - Tabela de HE nao encontrada 2 - Tabela de HE nao configurada corretamente
						cHelp			 ;	//08 -> Mensagem Complementar ao Help ( Retorno por Referencia )
					 )

Local aEscala		:= {}
Local baScan		:= { || .T. }
Local cAlias		:= "SP4"
Local cAliasQuery	:= cAlias
Local lRet			:= .F.
Local lModFil		:= .F. 
Local lQueryOpened	:= .F.
Local nPos			:= 0
Local nOrder		:= RetOrdem( "SP4" , "P4_FILIAL+P4_TURNO+P4_TIPO" )
Local nSvOrder		:= SP4->( IndexOrd() ) 

#IFDEF TOP
	Local cPrefixo		:= ( PrefixoCpo( cAlias ) + "_" )
	Local cQuery		:= ""
	Local cSvQuery		:= ""
	Local cSvTno		:= ""	
	Local cSvAlias		:= Alias()
	Local nX			:= 0

	Static aSp4Fields
	Static cQrySp4Fields
	Static nSp4Fields
#ENDIF

DEFAULT cFil			:= SRA->RA_FILIAL
DEFAULT cTno			:= SRA->RA_TNOTRAB
DEFAULT nErrorNumber	:= 0   
DEFAULT lTodas			:= .F.
DEFAULT lShowHelp		:= .F.
DEFAULT __aTabEx		:= {}

#IFDEF TOP

	IF !( lExInAs400 )
	
		cAliasQuery := ( "__Q" + cAliasQuery + "QRY" )

		DEFAULT aSp4Fields := ( cAlias )->( dbStruct() )
		DEFAULT nSp4Fields := Len( aSp4Fields )

		IF ( cQrySp4Fields == NIL )
			cQrySp4Fields := ""
			For nX := 1 To nSp4Fields
				cQrySp4Fields += aSp4Fields[ nX , 01 ] + ", "
			Next nX
		EndIF
		
	EndIF		

#ENDIF

/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Se o parametro de escalonamento foi passado				  Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
IF !( lEscalonar == NIL )
   __lEscalonamento	:= lEscalonar
Else
	/*/
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	ЁSe eh a primeira vez ou ocorreu quebra de filial E NAO    foiЁ
	Ёpara escalonar Obtem o parametro de escalonamento			  Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	IF ( lModFil := ( ( cFilStatic == NIL )  .or. ( cFilStatic != cFil    ) ) )
		__lEscalonamento	:=	NIL
		cFilStatic			:= 	cFil
		/*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		ЁConsiderar Todas as Horas Extras do Dia Para o Escalonamento Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
    	DEFAULTFIL __lEscalonamento := ( SuperGetMv("MV_ACMHEXT",,"N",cFil) == "S" )      	
	EndIF
EndIF

aTabExtra	:= {}
baScan		:= { |x| ( x[1] == cFil .or. Empty( x[1] ) )	;
					  .and.									;
					 ( x[2] == cTno .or. Empty( x[2] ) )    ;
			   }

cFil := xFilial( cAlias , cFil )

IF ( Empty( __aTabEx ) .or. ( !lTodas .and. ( nPos := aScan( __aTabEx , baScan ) ) == 0 .or. ( nPos > 0 .and. Empty( __aTabEx[ nPos , 2 ] ) ) ) )


	IF !( nOrder == nSvOrder )
		( cAlias )->( dbSetOrder( nOrder ) )
	EndIF

	#IFDEF TOP
		IF !( lExInAs400 )
			cQuery := "SELECT "
			cQuery += cQrySp4Fields
			cQuery := SubStr( cQuery , 1 , Len( cQuery ) - 2 )
			cQuery += " FROM "
			cQuery += InitSqlName( cAlias )
			cQuery += " WHERE "
			cQuery += cPrefixo+"FILIAL='"+cFil+"'"
			cQuery += " AND "
			IF !( lTodas )
				cQuery += cPrefixo+"TURNO='"+cTno+"'"
				cQuery += " AND "
				cSvTno := cTno
			EndIF
			cQuery += "D_E_L_E_T_=' ' "
			cQuery += "ORDER BY " + SqlOrder( (cAlias)->( IndexKey() ) )
			cSvQuery	:= cQuery
			cQuery		:= ChangeQuery( cQuery )
			IF ( lQueryOpened := MsOpenDbf(.T.,"TOPCONN",TcGenQry(NIL,NIL,cQuery),cAliasQuery,.F.,.T.) )
				For nX := 1 To nSp4Fields
					IF !( aSp4Fields[ nX , 02 ] == "C" )
						TcSetField(cAliasQuery,aSp4Fields[nX,01],aSp4Fields[nX,02],aSp4Fields[nX,03],aSp4Fields[nX,04])
					EndIF
				Next nX
				IF !( lRet := ( cAliasQuery )->( !Eof() ) )
					IF !( lTodas )
						( cAliasQuery )->( dbCloseArea() )
						cTno	:= Space( GetSx3Cache( "P4_TURNO  " , "X3_TAMANHO" ) )
						cQuery	:= StrTran( cSvQuery , ( "TURNO='"+cSvTno+"'" ) , ( "TURNO='"+cTno+"'" ) )
						cQuery	:= ChangeQuery( cQuery )
						IF ( lQueryOpened := MsOpenDbf(.T.,"TOPCONN",TcGenQry(NIL,NIL,cQuery),cAliasQuery,.F.,.T.) )
							For nX := 1 To nSp4Fields
								IF !( aSp4Fields[ nX , 02 ] == "C" )
									TcSetField(cAliasQuery,aSp4Fields[nX,01],aSp4Fields[nX,02],aSp4Fields[nX,03],aSp4Fields[nX,04])
								EndIF
							Next nX 
							IF ( nPos == 0 )
								IF !( lRet := ( cAliasQuery )->( !Eof() ) )
									( cAliasQuery )->( dbCloseArea() )
								EndIF
							EndIF
						EndIF
					EndIF
				EndIF
	        EndIF
		EndIF	        
	#ENDIF
	
	IF !( lQueryOpened )
	
		cAliasQuery := cAlias
		IF ( lTodas )
			lRet := ( cAliasQuery )->( dbSeek( cFil , .F. ) )
		Else
			IF !( lRet := ( cAliasQuery )->( dbSeek( cFil + cTno ) ) )
				IF ( nPos == 0 )
					lRet := ( cAliasQuery )->( dbSeek( cFil + ( cTno := Space( GetSx3Cache( "P4_TURNO  " , "X3_TAMANHO" ) ) ) ) )
				EndIF
			EndIF
		EndIF
	
	EndIF

	IF ( ( lRet ) .and. ( Select( cAliasQuery ) > 0 ) )
		aAdd( __aTabEx , { cFil , IF( lTodas , "TODAS" , cTno ) , {} } )
		While ( cAliasQuery )->( !Eof() .and. cFil == P4_FILIAL .and. IF( lTodas , lTodas , cTno == P4_TURNO ) )
			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			ЁAdiciona a Informacao da Tabela de Hora Extras em Array  auxiЁ
			Ёliar para verificar consistencia da mesma para uso do  escaloЁ
			Ёnamento de horas											  Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			( cAliasQuery )->( aAdd( aEscala , { P4_TIPO , P4_DE , P4_ATE ,P4_CODAUT , P4_CODNAUT }  ) )
			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			ЁCarrega a Tabela de Horas Extras							  Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			( cAliasQuery )->( aAdd( __aTabEx[ Len( __aTabEx ) , 3 ] , { P4_TIPO , P4_DE , P4_ATE ,P4_CODAUT , P4_CODNAUT } ) )
			( cAliasQuery )->( dbSkip() )
		End While

		/*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		ЁSe foi solicitada a interrupcao do processamento ao   ocorrerЁ
		Ёalguma inconsistencia, procedemos com a verificacao da  inconЁ
		Ёsistencia para efeito de escalonamento					      Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		IF ( lShowHelp .and. __lEscalonamento )
			IF !( lRet := fVerEscala( aEscala ) )
        		cHelp			:= STR0155	//-- "Tabela de Horas Extras Nao Configurada para Escalonamento"
        		nErrorNumber	:= 2.00		//-- Retorno de erro para a funcao chamadora
	   		EndIF
		EndIF

		/*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		ЁSe Estiver Ok Monta a Tabela de Horas Extras				  Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		IF ( lRet )
			IF !( lTodas ) 
				baScan := { |x| ( x[1] == cFil .or. Empty( x[1] ) )	;
						  		.and.								;
						 		( x[2] == cTno )					;
				   		  }
				IF ( ( nPos := aScan( __aTabEx , baScan ) ) == 0 )
					baScan := { |x| ( x[1] == cFil .or. Empty( x[1] ) )	;
							  		.and.								;
							 		Empty( x[2] )						;
					   		  }
					nPos := aScan( __aTabEx , baScan )
					
				EndIF		
			EndIF
		EndIF
	EndIF

	#IFDEF TOP
		IF ( ( lQueryOpened ) .and. ( Select( cAliasQuery ) > 0 ) )
			( cAliasQuery )->( dbCloseArea() )
		EndIF	
	#EndIF

	IF !( nOrder == nSvOrder )
		( cAlias )->( dbSetOrder( nSvOrder ) )
	EndIF

EndIF

IF ( lTodas .and. ( lRet := !Empty( __aTabEx ) ) )
	aEval( __aTabEx , { |x,y| IF( __aTabEx[y,1] == cFil , aAdd( aTabExtra , aClone( __aTabEx[y,3] ) ) , NIL ) } )
ElseIF ( lRet := ( nPos > 0 ) )
	aTabExtra := aClone( __aTabEx[ nPos , 3 ] )
EndIF

IF ( ( lShowHelp ) .and. !( lRet ) )
    IF !Empty( cHelp )
		HELP(" ",1,"TABHENCAD", , OemToAnsi( cHelp ) , 5 , 0 ) 
	Else
		HELP(" ",1,"TABHENCAD" )
	EndIF
EndIF

/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
ЁFornece o numero de erro ao executar a funcao  ( considerandoЁ
Ёque nao ocorreu algum ainda) se nao foi encontrada a   tabelaЁ
Ёde He para a chave de pesquisa (filial e/ou turno).		  Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
IF Empty(nErrorNumber)
   nErrorNumber := IF( !( lRet ) , 1 , 0 )
EndIF

#IFDEF TOP
	/*/
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	ЁGarante o Fechamento da Query no retorno da funcao           Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	IF ( Select( cAliasQuery ) > 0 )
		( cAliasQuery )->( dbCloseArea() )
	EndIF	
	/*/
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	ЁRestaura dados de Entrada                                    Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	IF ( Select( cSvAlias ) > 0 )
		dbSelectArea( cSvAlias )
	EndIF
#EndIF

Return( lRet )

/*/
зддддддддддбддддддддддддддддбдддддбдддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁRstGetTabExtra	ЁAutorЁMarinaldo de Jesus Ё Data Ё11/03/2003Ё
цддддддддддеддддддддддддддддадддддадддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁReinicializa as Staticas utilizadas em GetTabExtra()		Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGenerico													Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function RstGetTabExtra()

__aTabEx			:= NIL
__lEscalonamento	:= NIL	
cFilStatic			:= NIL

Return( NIL )

/*/
зддддддддддбддддддддддддбдддддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁfTpoExtra   Ё Autor ЁMarinaldo de Jesus   Ё Data Ё28/09/2000Ё
цддддддддддеддддддддддддадддддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁRetorna o Tipo de Horas Extras de Acordo com o Dia          Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁTipo de Hora Extra                                    	    Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁObserva┤└oЁ                                                      		Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
Ё Uso      ЁApontamento                                                 Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function fTpoExtra(	dData		,;	//Data para pesquisa do Tipo de Hora Extra
					aTabClone	,;	//Copia do Array com o Calendario de Marcacoes
					nPosCalend	 ;	//Indice em aTabCalend
				  )

Local aSvTabsCal
Local cTpExtra
Local nPos

DEFAULT dData		:= Ctod("//")
DEFAULT aTabClone	:= {}
DEFAULT nPosCalend	:= 0

Begin Sequence

	IF !Empty( aTabClone ) .and. IF( Empty( nPosCalend ) , ( nPos := aScan( aTabClone, { |x| x[ CALEND_POS_DATA ] == dData .and. x[ CALEND_POS_TIPO_MARC ] == "1E" } ) ) > 0 ,( nPos:= nPosCalend, .T. ) )
		nPosCalend := nPos
	Else
		aTabClone	:= {}
        /*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Salva o Conteudo do Calendario por Turno        			  Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		aSvTabsCal	:= GetTabCal()
        /*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Cria o Calendario para a Data                   			  Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		IF ( SRA->( CriaCalend(	dData		,;	//01 -> Data Inicial do Periodo
								dData		,;	//02 -> Data Final do Periodo
								RA_TNOTRAB	,;	//03 -> Turno Para a Montagem do Calendario
								RA_SEQTURN	,;	//04 -> Sequencia Inicial para a Montagem Calendario
								aTabPadrao	,;	//05 -> Array Tabela de Horario Padrao
								@aTabClone	,;	//06 -> Array com o Calendario de Marcacoes
								RA_FILIAL	,;	//07 -> Filial para a Montagem da Tabela de Horario
								RA_MAT		,;	//08 -> Matricula para a Montagem da Tabela de Horario
								RA_CC		,;	//09 -> Centro de Custo para a Montagem da Tabela
								NIL    		,;	//10 -> Array com as Trocas de Turno
								NIL     	,;	//11 -> Array com Todas as Excecoes do Periodo
								NIL         ,;	//12 -> Se executa Query para a Montagem da Tabela Padrao
								.F.			,;	//13 -> Se executa a funcao se sincronismo do calendario
								NIL      	 ;	//14 -> Se Forca a Criacao de Novo Calendario
							 );
					);
			)
			IF ( ( nPos := aScan( aTabClone, { |x| x[ CALEND_POS_DATA ] == dData .and. x[ CALEND_POS_TIPO_MARC ] == "1E" } ) ) > 0 )
				nPosCalend := nPos
			EndIF
		EndIF
	EndIF
	
	IF ( nPosCalend > 0 )
		IF ( aTabClone[ nPosCalend , CALEND_POS_APON_FERIAS ] )
			cTpExtra := aTabClone[nPosCalend,CALEND_POS_TP_HE_NT_FER]+"-"+aTabClone[nPosCalend,CALEND_POS_TP_HE_NR_FER]
		Else
			IF ( aTabClone[ nPosCalend , CALEND_POS_FERIADO ] )				//Dia Corresponde a Feriado
				IF ( aTabClone[ nPosCalend , CALEND_POS_EXCECAO ] == "E" )	//Dia Corresponde a Excecao em Feriado
					cTpExtra := aTabClone[nPosCalend,CALEND_POS_TIPO_HE_NOT]+"-"+aTabClone[nPosCalend,CALEND_POS_TIPO_HE_NOR]
				Else
					IF !( aTabClone[ nPosCalend , CALEND_POS_TRAB_FERIADO ] )	//Se nao Trabalha em Feriado
						cTpExtra	:= IF(Empty(aTabClone[ nPosCalend , CALEND_POS_TP_HE_FER_NT ]),"8",aTabClone[ nPosCalend , CALEND_POS_TP_HE_FER_NT ])
						cTpExtra	+= "-"
						cTpExtra	+= IF(Empty(aTabClone[ nPosCalend , CALEND_POS_TP_HE_FER_NR ]),"4",aTabClone[ nPosCalend , CALEND_POS_TP_HE_FER_NR ])
					Else                        //Trabalha em Feriado
						cTpExtra := aTabClone[ nPosCalend , CALEND_POS_TIPO_HE_NOT ] + "-" + aTabClone[ nPosCalend , CALEND_POS_TIPO_HE_NOR ]
					EndIF
				EndIF
			Else
				cTpExtra := aTabClone[ nPosCalend , CALEND_POS_TIPO_HE_NOT ]+"-"+aTabClone[ nPosCalend , CALEND_POS_TIPO_HE_NOR ]
			EndIF
		EndIF
	EndIF

End Sequence
	
cTpExtra := IF( Empty( cTpExtra ) , "5-1" , cTpExtra ) //DEFAULT

/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Restaura o Conteudo do Calendario por Turno        		  Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
IF ( aSvTabsCal <> NIL )
	SetTabCal( aSvTabsCal )
EndIF

Return( cTpExtra )

/*/
зддддддддддбддддддддддддбдддддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁfVerEscala	Ё Autor ЁMauricio MR           Ё Data Ё12/11/2002Ё
цддддддддддеддддддддддддадддддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁConsiste a Tabela de HE para uso com Escalonamento de Horas  Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   ЁfVerEscala( aTabHE )									     Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁaTabHE   -> Array de um Turno/Filial a Ser Consistido.		 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁlRet     -> True se OK ou .F. se houver inconsistencia       Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁFuncao GetTabExtra()                                         Ё
юддддддддддаддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function fVerEscala(aTabHE)  

Local aCompara	:= {'1-5','2-6','3-7','4-8','A-B','C-D','E-F','G-H'}  
Local aDiurno	:= {}
Local aNoturno	:= {}
Local cTipo		:= ''
Local cTipoPar	:= ''
Local lRet		:= .T.
Local nLenaTab  := Len(aTabHE)     
Local cTipoAnt	:= ''
Local nDiurno	:= 0
Local nNoturno	:= 0
Local nPos		:= 0
Local nFaixas	:= 0

//-- Percorre todos os tipos de HE
For nFaixas := 1 To nLenaTab
       
    //-- Para cada Tipo lido procura o seu Tipo "Noturno" correspondente     
    cTipo:=aTabHE[nFaixas, 1] 
    
    //-- Despreza Faixas de Tipos ja lidos e Despreza noturnos
    If  (cTipoAnt == cTipo) .OR. (cTipo >'4' .AND. !(cTipo $'ACEG'))
       Loop
    Endif
  
    //-- Se nao encontrou o correspondente Noturno
    If Empty( nPos:= Ascan( aCompara, {|cPar| cTipo == Substr(cPar,1,1) } ) )
       //-- Obtem o proximo
       Loop
    Endif      

    //-- Extrai o noturno correspondente
    cTipoPar:=Substr(aCompara[nPos],-1,1)
    
    //-- Iguala variavel auxiliar que mantera o ultimo tipo lido para evitar processamento desnecessario
    cTipoAnt:=cTipo

    //-- Monta array com as faixas do tipo diurno     
    aDiurno:={}
    nDiurno:=0  
    aEval(aTabHE,{|aTipo| If( aTipo[1] == cTipo, (nDiurno++, aAdd( aDiurno, aTipo )) , Nil ) })
     
    //-- Monta array com as faixas do tipo noturno correspondente
    aNoturno:= {}  
    nNoturno:= 0
    aEval(aTabHE,{|aTipo| If( aTipo[1] == cTipoPar,(nNoturno++, aAdd( aNoturno, aTipo )) , Nil ) })
    
    //-- Verificar se qtde de faixas de valores diurnas e noturnas diferem entre si
    If nDiurno <> nNoturno
       lRet:=.F.
       Exit
    Endif   
                                 
    //-- Percorre Cada uma das faixas do Noturno correspondente
    nPos:=nDiurno
    Do While nPos >0                                          
       //-- Verifica Se existem diferenca entre os Limites Inicial e final em cada faixas correspondente
       If aDiurno[nPos,2] <> aNoturno[nPos,2] .OR. aDiurno[nPos,3] <> aNoturno[nPos,3]
          lRet:=.F.
          Exit
       Endif   
       nPos--
    End While
    
    //-- Se houve diferenca de faixas abandona rotina
    IF ! lRet
       Exit
    Endif
Next nFaixas

Return( lRet )

/*/
зддддддддддбдддддддддддбдддддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁfFeriado() Ё Autor Ё Marinaldo de Jesus   Ё Data Ё01/06/2001Ё
цддддддддддедддддддддддадддддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o Ё Verifica se a Data passada eh ou nao um Feriado            Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё fFeriado( cFil, dDate, cDesc, cTipo, cTipCod )			    Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       Ё SIGAPON                                                    Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   Ё lRet <=> True se Data Feriado, False se n└o                Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ cFil  = Variavel com a Filial do Funcionario.              Ё
Ё          Ё dDate = Data a Ser Verificada no SP3                       Ё
Ё          Ё cDesc = Descricao do Feriado                               Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
/*/
Function fFeriado( cFil, dDate, cDesc, cTipo, cTipCod )

Local aArea		:= GetArea()
Local aSP3Area	:= SP3->( GetArea() )
Local cMesDia	:= ""
Local cAno		:= ""
Local lFeriado	:= .F.
Local cMyChave	:= ""
Local nPosFer	:= 0
Local nOrderDt	:= 0
Local nOrderMd	:= 0
Local nMyRecno	:= 0
Local lMyCnt	:= .T.

Local cAlias	:= "SP3"
Local cQuery	:= ""
Local cGcGrpE	:= FwCompany()
Local cGcUneg	:= FwUnitBusiness()
Local cGcFil	:= FwFilial()

DEFAULT __aFeriadoStatic	:= {}
DEFAULT cFil				:= xFilial( "SP3" )
DEFAULT dDate				:= dDataBase
DEFAULT cDesc				:= ""
DEFAULT cTipo				:= ""
DEFAULT cTipCod				:= ""

lGestaoCorp := Iif( FWSizeFilial() > 2, .T., .F.)	//-Indica se esta configurado como Gestao Corporativa na P11
lNewFields  := Iif( SP3->( Type("P3_GCGRPE")#"U" .And. Type("P3_GCUNEG")#"U" .And. Type("P3_GCFIL")#"U" ), .T., .F.)	//-Indica se foram criados os campos novos do SP3

dbSelectArea("SQB")
dbSetOrder(4)	//-QB_FILIAL+QB_CC+QB_DEPTO
dbSelectArea("SP3")

If lGestaoCorp .And. lNewFields
	
	cMyChave	:= (fAjusTam(cGcGrpE,SP3->P3_GCGRPE) + fAjusTam(cGcUneg,SP3->P3_GCUNEG)+ fAjusTam(cGcFil,SP3->P3_GCFIL)) + DtoS(dDate) + cTipo + cTipCod
	nOrderDt	:= RetOrdem( "SP3" , "P3_GCGRPE+P3_GCUNEG+P3_GCFIL+DTOS(P3_DATA)+P3_TIPO+P3_TIPCOD" )
	nPosFer		:= aScan( __aFeriadoStatic , { |x| x[01]+DtoS(x[02])+x[06]+x[07] == cMyChave } )
	
	dbSetOrder( nOrderDt )
	
	cAlias := "QSP3"
	cQuery := "SELECT DISTINCT RA_FILIAL,RA_MAT,RA_CC,RA_DEPTO,QB_CESTAB,P3.* "
	cQuery += "FROM "+RetSqlName("SRA")+" RA "
	
	cQuery += "INNER JOIN "+RetSqlName("SQB")+" QB ON "
	If TcSrvType() == "AS/400"
		cQuery += "QB.@DELETED@ = ' ' "
	Else
		cQuery += "QB.D_E_L_E_T_ = ' ' "
	Endif 
	cQuery += "AND QB_DEPTO=RA_DEPTO "
	
	cQuery += "INNER JOIN "+RetSqlName("SP3")+" P3 ON "
	If TcSrvType() == "AS/400"
		cQuery += "P3.@DELETED@ = ' ' "
	Else
		cQuery += "P3.D_E_L_E_T_ = ' ' "
	Endif 
	cQuery += "AND P3_DATA='"+DTOS(dDate)+"' "
	cQuery += "AND ( (P3_GCGRPE='"+fAjusTam(cGcGrpE,SP3->P3_GCGRPE)+"' OR P3_GCGRPE='"+fAjusTam(" ",SP3->P3_GCGRPE)+"') "
	cQuery += "  AND (P3_GCUNEG='"+fAjusTam(cGcUneg,SP3->P3_GCUNEG)+"' OR P3_GCUNEG='"+fAjusTam(" ",SP3->P3_GCUNEG)+"') "
	cQuery += "  AND (P3_GCFIL='"+fAjusTam(cGcFil,SP3->P3_GCFIL)+"' OR P3_GCFIL='"+fAjusTam(" ",SP3->P3_GCFIL)+"') "
	cQuery += "    ) WHERE "
	If TcSrvType() == "AS/400"
		cQuery += "RA.@DELETED@ = ' ' "
	Else
		cQuery += "RA.D_E_L_E_T_ = ' ' "
	Endif 
	cQuery += "AND RA_FILIAL='"+SRA->RA_FILIAL+"' AND RA_MAT='"+SRA->RA_MAT+"' "
	cQuery += "ORDER BY P3_GCGRPE,P3_GCUNEG,P3_GCFIL,P3_DATA,P3_TIPO,P3_TIPCOD "
	cQuery := ChangeQuery(cQuery)
	If Select(cAlias) > 0
		(cAlias)->(dbCloseArea())
	Endif
	
	dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAlias,.T.,.T.)
	//Count To nTReg	//# Conta os registros retornados
	aEval( (cAlias)->(dbStruct()), {|x| Iif(x[2] != "C",TcSetField(cAlias,x[1],x[2],x[3],x[4]),Nil)} )	//# Corrige a forma das Datas e Numeros
	(cAlias)->(dbGotop())
	
Else
	cMyChave	:= cFil + DtoS(dDate)
	nOrderDt	:= RetOrdem( "SP3" , "P3_FILIAL+DTOS(P3_DATA)" )
	nPosFer		:= aScan( __aFeriadoStatic , { |x| x[01]+DtoS(x[02]) == cMyChave } )
	
EndIf
nOrderMd	:= RetOrdem( "SP3" , "P3_FILIAL+P3_MESDIA+P3_FIXO" )

If nPosFer == 0
	
	If lGestaoCorp .And. lNewFields	//-Tratamaneto Novo
		
		If Eof()
			lMyCnt := .F.
		Else
			//-QB_FILIAL+QB_CC+QB_DEPTO
			SQB->(xFilial("SQB")+SRA->RA_CC,.F.)
		EndIf
		
		While !Eof()
			
			cMyChv :=	fAjusTam(cGcGrpE,SP3->P3_GCGRPE) + ;
						fAjusTam(cGcUneg,SP3->P3_GCUNEG) + ;
						fAjusTam(cGcFil,SP3->P3_GCFIL)
				
			If P3_TIPO == "1" .And. Alltrim(P3_TIPCOD) == Alltrim(SRA->RA_CC)
				cDesc	:= SP3->P3_DESC
				cTipo   := SP3->P3_TIPO
				cTipCod := SP3->P3_TIPCOD
				lFeriado := .T.
				nMyRecno := QSP3->R_E_C_N_O_
				Exit
				
			ElseIf P3_TIPO == "2" .And. Alltrim(P3_TIPCOD) == Alltrim(SRA->RA_DEPTO)
				cDesc	:= SP3->P3_DESC
				cTipo   := SP3->P3_TIPO
				cTipCod := SP3->P3_TIPCOD
				lFeriado := .T.
				nMyRecno := QSP3->R_E_C_N_O_
				Exit
				
			ElseIf P3_TIPO == "3" .And. Alltrim(P3_TIPCOD) == Alltrim(SQB->QB_CESTAB)
				cDesc	:= SP3->P3_DESC
				cTipo   := SP3->P3_TIPO
				cTipCod := SP3->P3_TIPCOD
				lFeriado := .T.
				nMyRecno := QSP3->R_E_C_N_O_
				Exit
				
			ElseIf P3_GCGRPE + P3_GCUNEG + P3_GCFIL == cMyChv
				cDesc	:= SP3->P3_DESC
				cTipo   := SP3->P3_TIPO
				cTipCod := SP3->P3_TIPCOD
				lFeriado := .T.
				nMyRecno := QSP3->R_E_C_N_O_
				Exit
				
			EndIf
				
			dbSkip()
		EndDo
		
	Else	//-Tratamaneto Antigo
		
		SP3->( dbSetOrder( nOrderDt ) )
		IF ( lFeriado := SP3->( MsSeek(cFil+DtoS(dDate),.F.) ) )
			nMyRecno := SP3->( Recno() )
			cDesc := SP3->P3_DESC
			SP3->( dbSetOrder( aSP3Area[ 02 ] ) )
/*
		Else
			SP3->( dbSetOrder( nOrderMd ) )
			cMesDia := MesDia( dDate )
			cAno	:= SubStr( AllTrim( Dtos( dDate ) ) , 1 , 4  )
			
			IF ( lFeriado := SP3->( MsSeek( ( cFil + cMesDia + "S" ) , .F. ) ) )
				cDesc := SP3->P3_DESC
				dDate := Stod( ( cAno + cMesDia ) )
				
				If cPaisLoc $ "PTG" .And. lNewFields
					cTipo   := SP3->P3_TIPO
					cTipCod := SP3->P3_TIPCOD
				EndIf
					
				nMyRecno := SP3->( Recno() )
			EndIF
*/
		EndIF
	EndIF

	If !lFeriado
	
		SP3->( dbSetOrder( nOrderMd ) )
		cMesDia := MesDia( dDate )
		cAno	:= SubStr( AllTrim( Dtos( dDate ) ) , 1 , 4  )
		
		IF ( lFeriado := SP3->( MsSeek( ( cFil + cMesDia + "S" ) , .F. ) ) )
			cDesc := SP3->P3_DESC
			dDate := Stod( ( cAno + cMesDia ) )
			
			If cPaisLoc $ "PTG" .And. lNewFields
				cTipo   := SP3->P3_TIPO
				cTipCod := SP3->P3_TIPCOD
			EndIf
			
			nMyRecno := SP3->( Recno() )
		Else
			lMyCnt := .F.
		EndIF
	EndIF

	If lMyCnt
		aAdd( __aFeriadoStatic, {	cFil,;									//-01
									dDate,;									//-02
									cDesc,;									//-03
									Iif( lFeriado, nMyRecno, 0 ),;			//-04
									lFeriado,;								//-05
									cTipo,;									//-06
									cTipCod ;								//-07
								} )
	EndIf
Else
	IF ( lFeriado := __aFeriadoStatic[ nPosFer , 05 ] )
		SP3->( MsGoto( __aFeriadoStatic[ nPosFer , 04 ] ) )
		cDesc := __aFeriadoStatic[ nPosFer , 03 ]
	EndIF
EndIF

If !lFeriado
	RestArea(aSP3Area)
EndIf

If !ArrayCompare( aArea , aSP3Area )
	RestArea(aArea)
EndIf

Return( lFeriado )

/*/
зддддддддддбддддддддддддддддбдддддбдддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁfAjusTam		ЁAutorЁAdemar Fernandes   Ё Data Ё11/02/2011Ё
цддддддддддеддддддддддддддддадддддадддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁAjusta o tamanho do campo retornando-o de acordo com o tama-Ё
Ё          Ёnho do campo do segundo parametro desta funcao.             Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁuConteudo - conteudo a ser redimencionado                   Ё
Ё          ЁcNomeCpo  - Alias+Campo usado como padrao de tamanho        Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGenerico													Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function fAjusTam(uConteudo,cNomeCpo)
//cGcFil,SP3->P3_GCFIL
Local cRet := uConteudo + Space( Len(cNomeCpo)-Len(uConteudo) )
Return(cRet)

/*/
зддддддддддбддддддддддддддддбдддддбдддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁRstfFeriado		ЁAutorЁMarinaldo de Jesus Ё Data Ё11/03/2003Ё
цддддддддддеддддддддддддддддадддддадддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁReinicializa as Staticas utilizadas em fFeriado()        	Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGenerico													Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function RstfFeriado()
Return( ( __aFeriadoStatic := NIL ) )

/*/
зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁfDescTno  Ё Autor Ё Marinaldo de Jesus    Ё Data Ё07/06/2001Ё
цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o Ё Retorna uma descri┤└o do Turno de Trabalho Solicitado      Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   ЁfDescTno(cFil,cTno)                                         Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁcFil - Filial para Pesquisa                                 Ё
Ё          ЁcTno - Turno para Pesquisa                                  Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGenerico                                                    Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function fDescTno( cFil , cTno, nTam )

Local cString := Space(50)

DEFAULT nTam	:= 50
cString := Left( fDesc( "SR6" , cTno , "R6_DESC" , nTam , cFil , NIL , .F. ) , nTam )

Return( cString )

/*/
зддддддддддбддддддддддддбдддддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁGetDescMarc Ё Autor ЁMarinaldo de Jesus    Ё Data Ё12/06/2001Ё
цддддддддддеддддддддддддадддддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁRetorna a Descricao dos Tipos de Marcacoes                   Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   ЁGetDescMarc( cMarca )			              			 	 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁcMarca  -> Tipo de Marcacao                          		 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁcDesc                                                	     Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁObserva┤└oЁ                                                      	     Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGenerico                                                     Ё
юддддддддддаддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function GetDescMarc( cMarca )

Local aMarca := Array( 11 , 2 )
Local cDescr := ""
Local nPos	 := 0

DEFAULT cMarca	:= ""

cMarca := StrTran( Upper( Alltrim( cMarca  ) ) , " " , "" )

aMarca[ 01 , 01 ] :=  "1E" ; aMarca[ 01 , 02 ] := STR0080 //'1a. Entrada'
aMarca[ 02 , 01 ] :=  "1S" ; aMarca[ 02 , 02 ] := STR0081 //'1a. Saida  '
aMarca[ 03 , 01 ] :=  "2E" ; aMarca[ 03 , 02 ] := STR0082 //'2a. Entrada'
aMarca[ 04 , 01 ] :=  "2S" ; aMarca[ 04 , 02 ] := STR0083 //'2a. Saida  '
aMarca[ 05 , 01 ] :=  "3E" ; aMarca[ 05 , 02 ] := STR0084 //'3a. Entrada'
aMarca[ 06 , 01 ] :=  "3S" ; aMarca[ 06 , 02 ] := STR0085 //'3a. Saida  '
aMarca[ 07 , 01 ] :=  "4E" ; aMarca[ 07 , 02 ] := STR0086 //'4a. Entrada'
aMarca[ 08 , 01 ] :=  "4S" ; aMarca[ 08 , 02 ] := STR0087 //'4a. Saida  '
aMarca[ 09 , 01 ] :=  "I1" ; aMarca[ 09 , 02 ] := STR0088 //'1o. Intervalo '
aMarca[ 10 , 01 ] :=  "I2" ; aMarca[ 10 , 02 ] := STR0089 //'2o. Intervalo '
aMarca[ 11 , 01 ] :=  "I3" ; aMarca[ 11 , 02 ] := STR0090 //'3o. Intervalo '

IF ( ( nPos := aScan( aMarca , { |x| x[1] == cMarca } ) ) > 0 )
	cDescr := aMarca[ nPos , 2 ]
EndIF

Return( cDescr )

/*/
зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁChk_IdPon Ё Autor ЁMarinaldo de Jesus     Ё Data Ё10/07/2001Ё
цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o Ё Consiste os Identificadores de Ponto                       Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   ЁChk_IdPon( Codigo )                                         Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ codigo = codigos da folha                                  Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       Ё SP9                                                        Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function Chk_IdPon()

Local aArea		:= GetArea()
Local aAreaSP9	:= {}
Local cSpaceIdP := Space( GetSx3Cache( "P9_IDPON  " , "X3_TAMANHO" ) ) 
Local cId		:= GetMemVar( "P9_IDPON" )
Local lRet		:= .F.
Local nOrder	:= RetOrdem( "SP9" , "P9_FILIAL+P9_IDPON+P9_CODIGO" )

aAreaSP9 := SP9->( GetArea() )
IF !( aAreaSP9[2] == nOrder )
	SP9->( dbSetOrder( nOrder ) )
EndIF	

IF lRet := SP9->( dbSeek( xFilial("SP9") + cId ) .and. IF( Altera , Recno() # aAreaSP9[3] , .T. ) .and. cId # cSpaceIdP )
	Help(" ",1,"XREPCODFOL")
EndIF

RestArea( aAreaSP9 )
RestArea( aArea	   )

Return( !lRet )

/*/
зддддддддддбддддддддддддбдддддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁGetLastApo  Ё Autor ЁMarinaldo de Jesus    Ё Data Ё27/07/2001Ё
цддддддддддеддддддддддддадддддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁRetornar array com os Resultados dos Apontamentos            Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   ЁGetLastApo( [ dPerIni ],[ dPerFim ],[ cAlias ],[ aCpos ] )	 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁdPerIni 	-> Periodo Inicial de Apontamento            	 Ё
Ё          ЁdPerFim 	-> Periodo Final   de Apontamento            	 Ё
Ё          ЁcAlias  	-> Alias Para Pesquisa ("SPC" ou "SPH")      	 Ё
Ё          ЁaCpos   	-> Campos Para a Montagem da Query           	 Ё
Ё          ЁlInformado	-> Se considera os Dados Informados    	 		 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁaResult                                              	     Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁObserva┤└oЁ                                                      	     Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGenerico                                                     Ё
юддддддддддаддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function GetLastApo( dPerIni , dPerFim , cAlias , aCpos , lInformado )

Local aAreaSPC		:= {}
Local aResult		:= {}
Local bSort			:= { || NIL }
Local cFil	    	:= SRA->RA_FILIAL
Local cMat			:= SRA->RA_MAT
Local cFilMat		:= ( cFil + cMat )
Local cAliasQuery	:= ""
Local cPrefixo		:= ""
Local cSvAlias		:= Alias()
Local cCpoPD		:= "PD"
Local cCpoQtd		:= "QUANTC"
Local cOrdem		:= ""
Local lSPC			:= .F.
Local lSort			:= .F.
Local lQueryOpened	:= .F.
Local nOrdem		:= 1

#IFDEF TOP
	
	Local aStru			:= {}
	Local cIniData		:= ""
	Local cFimData		:= ""
	Local cQuery		:= ""
	Local cQryStru		:= ""
	Local nCpos			:= 0
	Local nX			:= 0
    
	Static aSPCStruct
	Static aSPHStruct
	Static cQrySPCStruct
	Static cQrySPHStruct

	DEFAULT aCpos	:= {}

#ENDIF

DEFAULT dPerIni 	:= Ctod("//")
DEFAULT dPerFim 	:= Ctod("//")
DEFAULT cAlias		:= "SPC"
DEFAULT lInformado	:= .F.

cAlias		:= Upper( AllTrim( cAlias ) )
cPrefixo 	:= ( PrefixoCpo( cAlias ) + "_" )
lSPC		:= ( cAlias == "SPC" )
cAliasQuery	:= cAlias
aAreaSPC	:= ( cAlias )->( GetArea() )

/*/
здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
ЁDefine a Ordem para Pesquisa								   Ё
юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
cOrdem	:= ( cPrefixo+'FILIAL+' )
cOrdem	+= ( cPrefixo+'MAT+' )
cOrdem	+= ( 'Dtos('+cPrefixo+'DATA'+')+' )
cOrdem	+= ( cPrefixo+'PD+' )
cOrdem	+= ( cPrefixo+'TPMARCA+' )
cOrdem	+= ( cPrefixo+'CC' )
cOrdem	+= ( cPrefixo+'DEPTO' )
cOrdem	+= ( cPrefixo+'POSTO' )
cOrdem	+= ( cPrefixo+'CODFUNC' )

/*/
здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
ЁVerifica a Existencia de Indice Fil+Mat+Data... e utiliza-o.  Ё
юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
nOrdem	:= RetOrdem( cAlias , cOrdem )

IF ( nOrdem > 1 )
	( cAlias )->( dbSetOrder( nOrdem ) )
Else
	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	ЁNa Ausencia do Indice forca a ordenacao					   Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	lSort	:= .T.  
	bSort	:= { |x,y|	(;
							x[ARESULT_DTOS_DATA]	+ ;
							x[ARESULT_EVENTO] 		+ ;
							x[ARESULT_TPMARCA] 		+ ;
							x[ARESULT_CC] 			+ ;
							x[ARESULT_FUNCAO] 		+ ;
							x[ARESULT_DEPTO] 		+ ;
							x[ARESULT_POSTO] 		  ;														
						);
							 < 					  	  ;
						(;
							y[ARESULT_DTOS_DATA]	+ ;
							y[ARESULT_EVENTO] 		+ ;
							y[ARESULT_TPMARCA] 		+ ;
							y[ARESULT_CC] 		 	+ ;
							y[ARESULT_FUNCAO] 		+ ;
							y[ARESULT_DEPTO] 		+ ;
							y[ARESULT_POSTO] 		  ;														
						);
				};

EndIF

IF Empty( dPerIni ) .or. Empty( dPerFim )
	PerAponta( @dPerIni , @dPerFim , NIL , NIL , cFil )
EndIF

#IFDEF TOP

	IF !( lExInAs400 )
	
		DEFAULT aSPCStruct := SPC->( dbStruct() )
		DEFAULT aSPHStruct := SPH->( dbStruct() )
	
		cIniData := Dtos( dPerIni )
		cFimData := Dtos( dPerFim )
		
		/*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Seta apenas os Campos do SPC/SPH que serao Utilizados       Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		aAdd( aCpos , cPrefixo + "FILIAL"  )
		aAdd( aCpos , cPrefixo + "MAT" 	   )
		aAdd( aCpos , cPrefixo + "PD"	   )
		aAdd( aCpos , cPrefixo + "DATA"	   )
		aAdd( aCpos , cPrefixo + "QUANTC"  )
		aAdd( aCpos , cPrefixo + "CC"	   )
		aAdd( aCpos , cPrefixo + "TPMARCA" )
		aAdd( aCpos , cPrefixo + "CODFUNC" )
		aAdd( aCpos , cPrefixo + "POSTO"   )
		aAdd( aCpos , cPrefixo + "DEPTO"   )
		aAdd( aCpos , cPrefixo + "PROCES"  )
		aAdd( aCpos , cPrefixo + "ROTEIR"  )
		aAdd( aCpos , cPrefixo + "PERIODO" )
		aAdd( aCpos , cPrefixo + "NUMPAG"  )								
		/*/
		здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Quando forcar a carga dos dados Informados				   Ё
		юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		IF ( lInformado )
			aAdd( aCpos , cPrefixo + "PDI"	   )
			aAdd( aCpos , cPrefixo + "QUANTI"  )
		EndIF
		
		nCpos := IF( lSPC , Len( aSPCStruct ) , Len( aSPHStruct ) )
		For nX := 1 To nCpos
			IF aScan( aCpos , { |x| x == AllTrim( IF( lSPC , aSPCStruct[ nX , 1 ] , aSPHStruct[ nX , 1 ] ) ) } ) > 0
				aAdd( aStru , aClone( IF( lSPC , aSPCStruct[ nX ] , aSPHStruct[ nX ] ) ) )
				IF ( ( lSPC ) .and. !( cQrySPCStruct == NIL ) ) 
					IF !( aSPCStruct[ nX , 1 ] $ cQrySPCStruct )
						cQrySPCStruct := NIL
					EndIF
				ElseIF !( cQrySPHStruct == NIL )
					IF !( aSPHStruct[ nX , 1 ] $ cQrySPHStruct )
						cQrySPHStruct := NIL
					EndIF
				EndIF
			EndIF
		Next nX
	
		aCpos	:= NIL
		nCpos	:= Len( aStru )
	
		IF ( lSPC )
			IF ( cQrySPCStruct == NIL )
				cQrySPCStruct := ""
				For nX := 1 To nCpos
					cQrySPCStruct += aStru[ nX , 1 ] + ", "
				Next nX
			EndIF
			cQryStru := cQrySPCStruct
		Else
			IF ( cQrySPHStruct == NIL )
				cQrySPHStruct := ""
				For nX := 1 To nCpos
					cQrySPHStruct += aStru[ nX , 1 ] + ", "
				Next nX
			EndIF
			cQryStru := cQrySPHStruct
		EndIF
		
		cQuery	:= "SELECT "
		cQuery	+= cQryStru
		cQuery	:= SubStr( cQuery , 1 , Len( cQuery ) - 2 )
		cQuery	+= " FROM "
		cQuery	+= InitSqlName( cAlias )
		cQuery	+= " WHERE "
		cQuery	+= cPrefixo + "FILIAL='"+cFil+"'"
		cQuery	+= " AND "
		cQuery	+= cPrefixo + "MAT='"+cMat+"'"
		cQuery	+= " AND "
		cQuery	+= cPrefixo + "DATA>='"+cIniData+"'"
		cQuery	+= " AND "
		cQuery	+= cPrefixo + "DATA<='"+cFimData+"'"
		cQuery	+= " AND "
		cQuery	+= "D_E_L_E_T_=' ' "
		cQuery	+= "ORDER BY " + SqlOrder( ( cAlias )->( IndexKey() ) )
		cQuery	:= ChangeQuery(cQuery)
		cAliasQuery += "QRY"
		IF ( lQueryOpened := MsOpenDbf(.T.,"TOPCONN",TcGenQry(NIL,NIL,cQuery),cAliasQuery,.F.,.T.) )
			For nX := 1 To nCpos
				IF ( aStru[nX,2] <> "C" )
					TcSetField(cAliasQuery,aStru[nX,1],aStru[nX,2],aStru[nX,3],aStru[nX,4])
				EndIF
			Next nX
		EndIF

	EndIF
	
#ENDIF

IF !( lQueryOpened )
	cAliasQuery := cAlias
	( cAliasQuery )->( dbSeek( cFilMat , .F. ) )
EndIF	

While ( cAliasQuery )->( !Eof() .and. ( ( &(cPrefixo+"FILIAL") + &(cPrefixo+"MAT") ) == cFilMat ) )
		
	#IFNDEF TOP
		IF ( cAliasQuery )->( &(cPrefixo+"DATA") < dPerIni .or. &(cPrefixo+"DATA") > dPerFim )
			( cAliasQuery )->( dbSkip() )
			Loop
		EndIF
	#ELSE
		IF !( lQueryOpened )
			IF ( cAliasQuery )->( &(cPrefixo+"DATA") < dPerIni .or. &(cPrefixo+"DATA") > dPerFim )
				( cAliasQuery )->( dbSkip() )
				Loop
			EndIF
		EndIF
	#ENDIF

	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Quando forcar a carga dos dados Informados				   Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	IF ( lInformado )
		/*/
		здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Altera o Nome do Campo correspondente ao Evento a ser consideЁ
		Ё rado														   Ё
		юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		IF !Empty( ( cAliasQuery )->( &(cPrefixo+"PDI") ) )
			cCpoPD := "PDI"
		Else
			cCpoPD := "PD"
		EndIF
		/*/
		здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Altera o Nome do Campo correspondente a Quantidade a ser  conЁ
		Ё siderada													   Ё
		юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		IF !Empty( ( cAliasQuery )->( &(cPrefixo+"QUANTI") ) )
			cCpoQtd := "QUANTI"
		Else
			cCpoQtd := "QUANTC"
		EndIF	
	EndIF
			
	( cAliasQuery )->( fGeraRes(	@aResult				,; //01 -> Array com os Resultados do Dia
			   						&(cPrefixo+"DATA")		,; //02 -> Data da Geracao
									&(cPrefixo+cCpoQtd)		,; //03 -> Numero de Horas Resultantes
									&(cPrefixo+cCpoPD)		,; //04 -> Codigo do Evento
									&(cPrefixo+"CC")		,; //05 -> Centro de Custo a ser Gravado
									&(cPrefixo+"TPMARCA")	,; //06 -> Tipo de Marcacao
									.F.						,; //07 -> True para Acumular as Horas
									NIL						,; //08 -> Periodo de Apuracao
									NIL						,; //09 -> Tolerancia
									NIL						,; //10 -> Tipo de Arredondamento a Ser Utilizado
									.T.			 			,; //11 -> Substitui a(s) Hora(s) Existente(s) ( Garanto Apenas 1 DSR por Data )
									&(cPrefixo+"CODFUNC")	,; //12 -> Funcao a ser Gravada	
									&(cPrefixo+"DEPTO"	)	,; //13 -> Depto para gravacao     
									&(cPrefixo+"POSTO"	)	,; //14 -> Posto para gravacao									
									&(cPrefixo+"PROCES")	,; //15 -> Processo para Gravacao
									&(cPrefixo+"ROTEIR")	,; //16 -> Roteiro para Gravacao								
									&(cPrefixo+"PERIODO")	,; //17 -> Periodo para Gravacao
									&(cPrefixo+"NUMPAG")	;  //18 -> NumPagto para Gravacao								
							    );
				  	 )

	( cAliasQuery )->( dbSkip() )

End While

IF ( ( lQueryOpened ) .and. ( Select( cAliasQuery ) > 0 ) )
	( cAliasQuery )->( dbCloseArea() )
	dbSelectArea( cAlias )				//Restaura Arquivo Original
EndIF	

( cAlias )->( dbSetOrder( aAreaSPC[ 02 ] ) )

dbSelectArea( cSvAlias )

/*/
здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Ordena aResult para Acumulados pois nao Existe o Indice 02   Ё
юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
IF ( lSort )
	aSort( @aResult , NIL , NIL , bSort ) 
EndIF
		
Return( aResult )

/*/
зддддддддддбдддддддддддбдддддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁfEventos   Ё Autor Ё Marinaldo de Jesus   Ё Data Ё23/08/2001Ё
цддддддддддедддддддддддадддддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁListBox com a Selecao dos Eventos do Ponto                  Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   ЁfEventos( cCampo , l1Elem )			    					Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGenerico                                                    Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   Ё.T. por ser Utilizado em Validacao                          Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ cCampo 	- Campo Chave                                   Ё
Ё          Ё l1Elem 	- Se deve Mostrar Apenas 1 Elemento             Ё
Ё          Ё cPreSelect	- Eventos que ja foram Selecionados             Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function fEventos( cCampo , l1Elem , cPreSelect )

Local aPreSelect	:= {}
Local aEventos		:= {}
Local cTitulo		:= ""
Local cFilSP9		:= xFilial( "SP9" )
Local cFilSRV		:= xFilial( "SRV" )
Local cMvPar		:= &( Alltrim( ReadVar() ) )
Local cMvParDef		:= ""
Local cMvRetor		:= ""
Local cMvParam		:= ""
Local cReplicate	:= ""
Local nFor			:= 0
Local nLenFor		:= Len( AllTrim( cMvPar ) )
Local nTamCpo		:= 0

DEFAULT l1Elem 			:= .F.
DEFAULT cCampo 			:= "P9_CODIGO"
DEFAULT cPreSelect		:= ""

cCampo		:= Upper( AllTrim( cCampo ) )
nTamCpo		:= GetSx3Cache( cCampo , "X3_TAMANHO" )
cReplicate  := Replicate( "*" , nTamCpo )

CursorWait()

	IF !( l1Elem )
		nLenFor := Len( AllTrim( cMvPar ) )
		For nFor := 1 To nLenFor
			cMvParam += SubStr( cMvPar , nFor , nTamCpo )
			cMvParam += cReplicate
		Next nFor
	EndIF
	cMvPar := cMvParam
	
	IF ( Empty( __aEvefEve__ ) )
		SP9->( dbSetOrder( RetOrdem( "SP9" , "P9_FILIAL+" + cCampo ) ) )
		__aEvefEve__	:= BldafEventos( cFilSP9 , cCampo , cFilSRV )
	EndIF	
	
	nLenFor := Len( cPreSelect )
	For nFor := 1 To Len( cPreSelect ) Step nTamCpo
		aAdd( aPreSelect , SubStr( cPreSelect , nFor , nTamCpo ) )
	Next nFor
	
	nLenFor := Len( __aEvefEve__ )
	For nFor := 1 To nLenFor
		IF ( aScan( aPreSelect , SubStr( __aEvefEve__[ nFor ] , 1 , nTamCpo ) ) == 0 )
			cMvParDef += SubStr( __aEvefEve__[ nFor ] , 1 , nTamCpo )
			aAdd( aEventos , __aEvefEve__[ nFor ] )
		EndIF
	Next nFor

CursorArrow()
	
IF f_Opcoes( @cMvPar , cTitulo , aEventos , cMvParDef , 12 , 49 , l1Elem , nTamCpo , 10 )

	CursorWait()

		nLenFor := Len( cMvPar )
		For nFor := 1 To nLenFor Step nTamCpo
			IF ( SubStr( cMvpar , nFor , nTamCpo ) # cReplicate )
				cMvRetor += SubStr( cMvPar , nFor , nTamCpo )
			EndIF
		Next nFor

		&( Alltrim( ReadVar() ) ) := AllTrim( cMvRetor )

	CursorArrow()

EndIF
	
Return( .T. )

/*/
зддддддддддбддддддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁBldafEventos  Ё Autor ЁMarinaldo de Jesus     Ё Data Ё12/09/2003Ё
цддддддддддеддддддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁCarregar os Eventos do SP9 conforme Filial                    	Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁcFilSP9 - Filial do SP9											Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁaEventos - Array com a String de Codigo + Descricao do Evento   Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function BldafEventos( cFilSP9 , cCampo , cFilSRV )

Local aArea		:= GetArea()
Local aQuery	:= {}
Local aEventos	:= {}
Local bAscan	:= { |x| ( x == cCpoDes ) } 
Local bSkip		:= { || .F. }
Local cCntCpo	:= ""
Local cCpoDes	:= ""
Local nOrdSrv	:= 0

Begin Sequence

	IF ( SP9->( FieldPos( cCampo ) ) == 0 )
		Break
	EndIF

	IF ( cCampo == "P9_CODFOL" )
		nOrdSrv := RetOrdem( "SRV" , "RV_FILIAL+RV_COD" )
		bSkip	:= { || (;
							cCpoDes := (;
											( cCntCpo := &( cCampo ) )	+ ;
											" - "						+ ;
											PosSRV( cCntCpo , cFilSRV , "RV_DESC" , nOrdSrv , .F. );
									    );
						),;
						IF( aScan( aEventos , bAscan ) == 0 .and. !Empty( cCntCpo ),;
							aAdd( aEventos , cCpoDes ),;
							NIL;
						  ),;
						 (;
						 	cCntCpo	:= "" ,;
						 	.F.;
						 );
				  }
	Else
		bSkip	:= { || (;
							cCpoDes := (;
											( cCntCpo := &( cCampo ) )	+ ;
											" - "						+ ;
											P9_DESC						  ;
										);
						 ),;
						 IF( aScan( aEventos , bAscan ) == 0 .and. !Empty( cCntCpo ),;
						 	 aAdd( aEventos , cCpoDes ),;
						 	 NIL;
						 	),;
						 (;
						 	cCntCpo	:= "" ,;
						 	.F.;
						 );	
					}
	EndIF

	#IFDEF TOP
		aQuery		:= Array( 03 )
		aQuery[01]	:= "P9_FILIAL='"+cFilSP9+"'"
		aQuery[02]	:= " AND "
		aQuery[03]	:= "D_E_L_E_T_=' ' "
	#ENDIF

	SP9->( GdBuildCols(	NIL				,;	//01 -> Array com os Campos do Cabecalho da GetDados
						NIL				,;	//02 -> Numero de Campos em Uso
						NIL				,;	//03 -> [@]Array com os Campos Virtuais
						NIL				,;	//04 -> [@]Array com os Campos Visuais
						NIL				,;	//05 -> Opcional, Alias do Arquivo Carga dos Itens do aCols
						{				 ;
							"P9_FILIAL"	,;
							cCampo		,;
							"P9_DESC"	 ;
						}				,;	//06 -> Opcional, Campos que nao Deverao constar no aHeader
						NIL				,;	//07 -> [@]Array unidimensional contendo os Recnos
						"SP9"			,;	//08 -> Alias do Arquivo Pai
						cFilSP9			,;	//09 -> Chave para o Posicionamento no Alias Filho
						NIL				,;	//10 -> Bloco para condicao de Loop While
						bSkip			,;	//11 -> Bloco para Skip no Loop While
						.F.				,;	//12 -> Se Havera o Elemento de Delecao no aCols 
						.F.				,;	//13 -> Se Sera considerado o Inicializador Padrao
						.F.				,;	//14 -> Opcional, Carregar Todos os Campos
						.F.				,;	//15 -> Opcional, Nao Carregar os Campos Virtuais
						aQuery			,;	//16 -> Opcional, Utilizacao de Query para Selecao de Dados
						.F.				,;	//17 -> Opcional, Se deve Executar bKey  ( Apenas Quando TOP )
						.T.				,;	//18 -> Opcional, Se deve Executar bSkip ( Apenas Quando TOP )
						.F.				,;	//19 -> Carregar Coluna Fantasma e/ou BitMap ( Logico ou Array )
						.T.				,;	//20 -> Inverte a Condicao de aNotFields carregando apenas os campos ai definidos
						.F.				,;	//21 -> Verifica se Deve Checar se o campo eh usado
						.F.				,;	//22 -> Verifica se Deve Checar o nivel do usuario
						.F.				 ;	//23 -> Verifica se Deve Carregar o Elemento Vazio no aCols
					   );
		  )

End Sequence

RestArea( aArea )

Return( aClone( aEventos ) )

/*/
зддддддддддбддддддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁRstfEventos   Ё Autor ЁMarinaldo de Jesus     Ё Data Ё11/09/2003Ё
цддддддддддеддддддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁReinicializa as Statics em RstfEventos()                       	Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ																Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁNIL																Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function RstfEventos()
Return( ( __aEvefEve__ := {} ) )

/*/
зддддддддддбддддддддддддбддддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁGetMarcacoesЁAutor Ё Marinaldo de Jesus   Ё Data Ё25/08/2001Ё
цддддддддддеддддддддддддаддддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁRetornar Array aMarcacoes com as Marcacoes do Periodo       Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   ЁGetMarcacoes(@aMarcacoes,[@]aTabCalend...)					Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁPonto Eletronico                                            Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁlGetMarcOk                         							Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ < Vide Parametros Formais >								Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function GetMarcacoes(	aMarcacoes			,;	//01 -> Marcacoes dos Funcionarios
						aTabCalend			,;	//02 -> Calendario de Marcacoes
						aTabPadrao			,;	//03 -> Tabela Padrao
						aTurnos				,;	//04 -> Turnos de Trabalho
						dPerIni 			,;	//05 -> Periodo Inicial
						dPerFim				,;	//06 -> Periodo Final
						cFil				,;	//07 -> Filial
						cMat				,;	//08 -> Matricula
						cTno				,;	//09 -> Turno
						cSeq				,;	//10 -> Sequencia de Turno
						cCc					,;	//11 -> Centro de Custo
						cAlias				,;	//12 -> Alias para Carga das Marcacoes
						lRecno				,;	//13 -> Se carrega Recno em aMarcacoes
						lOrdem				,;	//14 -> Se considera Apenas Ordenadas
						lDiasFolga			,;  //15 -> Verifica as Folgas Automaticas
						lGrvFolgPa  		,;  //16 -> Se Grava Evento de Folga Mes Anterior
						lGetMarcAuto		,;	//17 -> Se Carrega as Marcacoes Automaticas
						aRecsMarcAut	    ,;	//18 -> Registros de Marcacoes Automaticas que deverao ser Desprezadas
						bCondMarcAut		,;	//19 -> Bloco para avaliar as Marcacoes Automaticas que deverao ser Desprezadas
						lChkPerAponta		,;	//20 -> Se Considera o Periodo de Apontamento das Marcacoes
						lSncMaMe			,;	//21 -> Se Efetua o Sincronismo dos Horarios na Criacao do Calendario
						lDataApo			,;	//22 -> Se Considera a data de apontamento 
						lDataIni			;	//23 -> Se Deve verificar se a data de apontamento da marcacao eh maior ou igual a data inicial do periodo (somente se Considera a data de apontamento) 						
					  )

/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Variaveis de Inicializacao Obrigatoria					  Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Local cSvAlias			:= Alias()
Local lGetMarcOk 		:= .T.
Local lQueryOpened		:= .F.

Local cFilter	  		:= ""
Local cAliasQuery 		:= cAlias
Local nOrderSP8  

/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Variaveis que serao inicializadas no Corpo da Funcao		  Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/      
Local aAreaDtMin 		:= GetArea()
Local cFilMat
Local cFilSPJ	:=xFilial("SPJ")
Local cPrefixo
Local cCod036N
Local cPriOrdem
Local cUltOrdem	
Local cAtuOrdem    
Local cAtuDataApo
Local cPerAponta
Local cAntOrdem
Local cPrxOrdem
Local cDtHrAntOrd
Local cDtHrPrxOrd
Local cDtHrLimIni
Local cDtHrLimFim
Local cDtHrAtu
Local cSetOrdem
Local lNotOrdena    
Local nLenMarc
Local nSerMarc
Local nSerIni
Local nSerFim
Local nSvIndexOrd
Local nPosUltOrdem
Local nLenTabCal
Local nPosPrxOrd
Local nPosAntOrd
Local nSetOrder

Local cIniData
Local cFimData   


#IFDEF TOP

	/*/
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Variaveis de Inicializacao Obrigatoria					  Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	Local aGetMarcFields	:= {}

	/*/
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Variaveis que serao inicializadas no Corpo da Funcao		  Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	Local cQryMarcFields
	Local cQuery
	Local nGetMarcFields
	Local nX

	Static aGetSP8Fields
	Static cQrySP8Fields
	Static cQrySPGFields
	Static nGetSP8Fields
	Static aGetSPGFields
	Static nGetSPGFields

#ENDIF

DEFAULT cFil				:= SRA->RA_FILIAL
DEFAULT cMat				:= SRA->RA_MAT
DEFAULT cTno				:= SRA->RA_TNOTRAB
DEFAULT cSeq				:= SRA->RA_SEQTURN
DEFAULT dPerIni				:= Ctod("//")
DEFAULT dPerFim				:= Ctod("//")
DEFAULT aTabPadrao			:= {}
DEFAULT aTabCalend			:= {}
DEFAULT aTurnos				:= {}
DEFAULT cAlias				:= "SP8"
DEFAULT lDataApo			:= .T.
//DEFAULT lDataIni			:= .T.
DEFAULT lRecno				:= .T.
DEFAULT lOrdem				:= .F.
DEFAULT lDiasFolga			:= .F.
DEFAULT lGrvFolgPa			:= .F.
DEFAULT lGetMarcAuto		:= .T.
DEFAULT bCondMarcAut		:= { || .T. }
DEFAULT lChkPerAponta		:= .T.
DEFAULT lSncMaMe			:= .T.        

aRecsMarcAut				:= {}

	/*/
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	ЁA Data de Apontamento sobrepoe a Ordem            			  Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
    lDataApo	:= IF( lOrdem, .T., IF(Valtype(lDataApo) <> "U",lDataApo, .F.))
    lOrdem:= IF(lDataApo, .F., lOrdem)       
   
   	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	ЁSomente verifica a Data de Apontamento da marcacao se considera a Data de Apontamento         Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
    lDataIni	:= If(lDataApo, IF(Valtype(lDataIni) <> "U",lDataIni, .F.),.F.)
    
    /* Caso esteja carregabdo marcacoes da tabela SP8, a data inicial devera  ser a menor data existente nas marcacoes */

    If cAlias == "SP8"
    	If !lDataIni
			#IFDEF TOP
	
				cAliasQuery := GetNextAlias()
						
				cFilter := " P8_FILIAL = '"+cFil+"'"
				cFilter += " AND P8_MAT = '"+cMat+"'"
	
				If !lExInAs400
					cFilter    += " AND D_E_L_E_T_ = ' ' "
				Else
					cFilter    += " AND @DELETED@ = ' ' "
				EndIf
				
				cFilter := "%"+cFilter+"%"
			
				If lDataApo
					BeginSql alias cAliasQuery
						column MINDTA as Date
						%NoParser%
						SELECT 
							MIN(cAliasQuery.P8_DATAAPO) MINDTA
						FROM 
							%Table:SP8% cAliasQuery
						WHERE 
							%Exp:cFilter%
					EndSql
				Else
					BeginSql alias cAliasQuery
						column MINDTA as Date
						%NoParser%
						SELECT 
							MIN(cAliasQuery.P8_DATA) MINDTA
						FROM 
							%Table:SP8% cAliasQuery
						WHERE 
							%Exp:cFilter%
					EndSql
				EndIf
								
				If !Empty((cAliasQuery)->(MINDTA)) .and. (cAliasQuery)->(MINDTA) < dPerIni
					dPerIni := (cAliasQuery)->(MINDTA)
				EndIf
				
				(cAliasQuery)->(dbCloseArea())
				
			#ELSE
			
				cFilter := cFil
				cFilter += cMat
				
				If lDataApo
					nOrderSP8 := (cAlias)->(dbSetOrder(RetOrder("P8_FILIAL+P8_MAT+DTOS(P8_DATAAPO)+DTOS(P8_DATA)+P8_HORA")))
				Else
					nOrderSP8 := (cAlias)->(dbSetOrder(RetOrder("P8_FILIAL+P8_MAT+DTOS(P8_DATA)+P8_HORA")))
				EndIf
			
				dbSelectArea(cAlias)
				dbSetOrder(nOrderSP8)
				
				(cAlias)->(dbSeek( cFilter, .F. ))
				
				If Found()
					If lDataApo 
						If (cAliasQuery)->(P8_DATAAPO) < dPerIni
							dPerIni := (cAliasQuery)->(P8_DATAAPO)
						EndIf
					Else
						If (cAliasQuery)->(P8_DATA) < dPerIni
							dPerIni := (cAliasQuery)->(P8_DATA)
						EndIf
					EndIf
				EndIf
			#ENDIF
			
			RestArea( aAreaDtMin )
			If Type("oPeriodo") <> "U"
				oPeriodo:dDataIni := dPerIni
			EndIf
		EndIf
	EndIf    		
    
Begin Sequence

	/*/
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	ЁCarrega o Calendario do Periodo Caso Esteja Vazio            Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	IF Empty( aTabCalend )
		IF ( Empty( dPerIni ) .or. Empty( dPerFim ) )
			If Type("oPeriodo") == "U"
				SetMemVar("oPeriodo" , RHPERIODO():New() , .T. , .T. )
			EndIf
			oPeriodo:cProcesso := SRA->RA_PROCES
			oPeriodo:GetPer()
			IF !( lGetMarcOk :=oPeriodo:lFound)
				Break
			EndIF
			
			dPerFim := oPeriodo:dDataFim
		EndIF 
		
		/*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		ЁInicio do Periodo e a menor data entre as marcacoes e o PeriodoЁ
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/		
	    dPerIni := Min(oPeriodo:dDataIni,dPerIni)
	    
		IF !( lGetMarcOk := CriaCalend(	dPerIni 	,;	//01 -> Data Inicial do Periodo
			  			   			   	dPerFim		,;	//02 -> Data Final do Periodo
								   		cTno		,;	//03 -> Turno Para a Montagem do Calendario
								   		cSeq		,;	//04 -> Sequencia Inicial para a Montagem Calendario
								   		@aTabPadrao	,;	//05 -> Array Tabela de Horario Padrao
								   		@aTabCalend	,;	//06 -> Array com o Calendario de Marcacoes
								   		cFil     	,;	//07 -> Filial para a Montagem da Tabela de Horario
								   		cMat   		,;	//08 -> Matricula para a Montagem da Tabela de Horario
								   		cCc   		,;	//09 -> Centro de Custo para a Montagem da Tabela
								   		@aTurnos	,;	//10 -> Array com as Trocas de Turno
										NIL			,;	//11 -> Array com Todas as Excecoes do Periodo
										NIL			,;	//12 -> Se executa Query para a Montagem da Tabela Padrao
										lSncMaMe	,;	//13 -> Se executa a funcao se sincronismo do calendario
										NIL			 ;	//14 -> Se Forca a Criacao de Novo Calendario
							  		  );
			)
			Break
		EndIF
	ElseIF ( Empty( dPerIni ) .or. Empty( dPerFim ) )

		nLenTabCal		:= Len( aTabCalend )
		If !lDataApo
			cPriOrdem		:= aTabCalend[ 01 , CALEND_POS_ORDEM	]
			dPerIni			:= aTabCalend[ 01 , CALEND_POS_DATA		]
			cUltOrdem		:= aTabCalend[ nLenTabCal , CALEND_POS_ORDEM ]
			nPosUltOrdem    := aScan( aTabCalend , { |x| ( x[ CALEND_POS_ORDEM ] == cUltOrdem  ) .and. ( x[CALEND_POS_TIPO_MARC] == "1E" ) } )
			IF ( nPosUltOrdem > 0 )
				dPerFim := aTabCalend[ nPosUltOrdem , CALEND_POS_DATA ]
			Else
				If Type("oPeriodo") == "U"
					SetMemVar("oPeriodo" , RHPERIODO():New() , .T. , .T. )
				EndIf
				oPeriodo:cProcesso := SRA->RA_PROCES
				oPeriodo:GetPer()
				IF !( lGetMarcOk :=oPeriodo:lFound)
					Break
				EndIF
	
				dPerIni := oPeriodo:dDataIni
				dPerFim := oPeriodo:dDataFim
	
			EndIF
		Else
			dPerIni := aTabCalend[ 01 				, CALEND_POS_DATA_APO ]
			dPerFim := aTabCalend[ nLenTabCal 		, CALEND_POS_DATA_APO ]
		Endif	
	EndIF	
	
	cAlias			:= Upper( AllTrim( cAlias ) )
	cAliasQuery 	:= cAlias
	cPrefixo		:= ( PrefixoCpo( cAliasQuery ) + "_" )
	aMarcacoes  	:= {}
	nLenTabCal		:= Len( aTabCalend )
	cPriOrdem		:= aTabCalend[ 01			, CALEND_POS_ORDEM	]
	cUltOrdem		:= aTabCalend[ nLenTabCal	, CALEND_POS_ORDEM	]
	IF ( lChkPerAponta )
		cPerAponta		:= Dtos( aTabCalend[ 01 , CALEND_POS_DATA ] )
		If !lDataApo
			nPosUltOrdem    := aScan( aTabCalend , { |x| ( x[ CALEND_POS_ORDEM ] == cUltOrdem  ) .and. ( x[CALEND_POS_TIPO_MARC] == "1E" ) } )
			cPerAponta		+= Dtos( aTabCalend[ nPosUltOrdem , CALEND_POS_DATA ] )
		Else                                                                       
			cPerAponta		+= Dtos( aTabCalend[ nLenTabCal , CALEND_POS_DATA_APO ] )
		Endif	
	EndIF
	
	
	cDtHrLimIni		:= DataHora2Str(;
										aTabCalend[ 01 , CALEND_POS_LIM_MARCACAO , 01 ],;
										aTabCalend[ 01 , CALEND_POS_LIM_MARCACAO , 02 ];
									)
	cDtHrLimFim		:= DataHora2Str(;
										aTabCalend[ nLenTabCal , CALEND_POS_LIM_MARCACAO , 01 ],;
										aTabCalend[ nLenTabCal , CALEND_POS_LIM_MARCACAO , 02 ];
									)
	/*/
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	ЁVerifica os Seriais Apenas Quando Marcacoes nao ordenadas	  Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
    IF !( lOrdem )  .AND. !(lDataApo)
		/*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		ЁDefine Numero Serial para o Inicio do Periodo        		  Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		nSerIni	:= RetSerIni(	aClone( aTabCalend )	,;	//01 -> Copia do Calendario de Marcacoes
								@aTabPadrao				,;	//02 -> Tabela de Horario Padrao
								dPerIni					,;	//03 -> Inicio do Periodo de Apontamento
								dPerFim					,; 	//04 -> Final do Periodo de Apontamento
								cTno					,;	//05 -> Turno de Trabalho
								cSeq					,;	//06 -> Sequencia de Turno
								cFil     				,;	//07 -> Filial do Funcionario
								cMat   					,;	//08 -> Matricula do Funcionario
								cCc   					,;	//09 -> Centro de Custo do Funcionario
								lOrdem	.or. 	lDataApo ;	//10 -> Marcacoes Sendo carregadas pela Ordem
					   		)
		/*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		ЁDefine Numero Serial para o Final do Periodo        		  Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		nSerFim	:= RetSerFim(	aClone( aTabCalend )	,;	//01 -> Copia do Calendario de Marcacoes
								@aTabPadrao				,;	//02 -> Tabela de Horario Padrao
								dPerIni					,;	//03 -> Inicio do Periodo de Apontamento
								dPerFim					,; 	//04 -> Final do Periodo de Apontamento
								cTno					,;	//05 -> Turno de Trabalho
								cSeq					,;	//06 -> Sequencia de Turno
								cFil     				,;	//07 -> Filial do Funcionario
								cMat   					,;	//08 -> Matricula do Funcionario
								cCc   		 			,;	//09 -> Centro de Custo do Funcionario
								lOrdem .or. lDataApo	 ;	//10 -> Marcacoes Sendo carregadas pela Ordem
					         )
	EndIF
	
	/*/
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Seleciona o Arquivo de Marca┤■es e Seta a Ordem correspondenЁ
	Ё te:														  Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	nSvIndexOrd := ( cAlias )->( IndexOrd() )
	cSetOrdem	:= ""
	IF ( lOrdem )
		/*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		ЁOrdem <=> _FILIAL+_MAT+_ORDEM+_DTOS(_DATA)+STR(_HORA,5,2)	  Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		cSetOrdem += cPrefixo+"FILIAL+"
		cSetOrdem += cPrefixo+"MAT+"
		cSetOrdem += cPrefixo+"ORDEM+"
		cSetOrdem += "DTOS("+cPrefixo+"DATA)+"
		cSetOrdem += "STR("+cPrefixo+"HORA,5,2)" 
	ElseIF (lDataApo)                                             
		/*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		ЁData  <=> 	P8_FILIAL+P8_MAT+ DTOS(P8_DATAAPO) +DTOS(P8_DATA)+STR(P8_HORA,5,2)   	  	  Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		cSetOrdem += cPrefixo+"FILIAL+"
		cSetOrdem += cPrefixo+"MAT+"
		cSetOrdem += "DTOS("+cPrefixo+"DATAAPO)+"
		cSetOrdem += "STR("+cPrefixo+"HORA,5,2)" 
	Else                                                                                                                    
		/*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		ЁData  <=> _FILIAL+_MAT+_DTOS(_DATA)+STR(_HORA,5,2)    	  	  Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		cSetOrdem += cPrefixo+"FILIAL+"
		cSetOrdem += cPrefixo+"MAT+"
		cSetOrdem += "DTOS("+cPrefixo+"DATA)+"
		cSetOrdem += "STR("+cPrefixo+"HORA,5,2)" 
	EndIF
	nSetOrder	:= RetOrdem( cAlias , cSetOrdem )
	IF !( nSvIndexOrd == nSetOrder )
		( cAlias )->( dbSetOrder( nSetOrder ) )
	EndIF
                        
 	//-- Se Nao for carregar as marcacoe  pela data de apontamento aumenta a amplitude do periodo
	IF !(lDataApo)
		cIniData	:= Dtos( aTabCalend[ 01			, CALEND_POS_DATA ] - 7 )
		cFimData	:= Dtos( aTabCalend[ nLenTabCal , CALEND_POS_DATA ] + 7 )
	Else
	     //-- Se for carregar as marcacoe pela data de apontamento Nao aumenta a amplitude do periodo                                                                                                           
		cIniData	:= Dtos( aTabCalend[ 01			, CALEND_POS_DATA_APO ] - 7 )
		cFimData	:= Dtos( aTabCalend[ nLenTabCal , CALEND_POS_DATA_APO ] + 7 )
	Endif	    
	
	/*/
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Cria array com as marca┤■es do Periodo para o funcion═rio.  Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	#IFDEF TOP

		IF !( lExInAs400 )

			/*/
			здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Monta Query para Carga das Marcacoes                         Ё
			юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			IF ( cAlias == "SP8" )
				IF ( aGetSP8Fields == NIL )
					aGetSP8Fields	:= (cAlias)->( dbStruct() )
					nGetSP8Fields	:= Len( aGetSP8Fields )
					cQrySP8Fields	:= ""
					For nX := 1 To nGetSP8Fields
		        		cQrySP8Fields += aGetSP8Fields[ nX , 01 ] + ", "
					Next nX
				EndIF
				aGetMarcFields	:= aClone( aGetSP8Fields )
				cQryMarcFields	:= cQrySP8Fields
				nGetMarcFields	:= nGetSP8Fields
			ElseIF ( cAlias == "SPG" )
				IF ( aGetSPGFields == NIL )
					aGetSPGFields	:= (cAlias)->( dbStruct() )
					nGetSPGFields	:= Len( aGetSPGFields )
					cQrySPGFields	:= ""
					For nX := 1 To nGetSPGFields
		        		cQrySPGFields += aGetSPGFields[ nX , 01 ] + ", "
					Next nX
				EndIF	
				aGetMarcFields	:= aClone( aGetSPGFields )
				cQryMarcFields	:= cQrySPGFields
				nGetMarcFields	:= nGetSPGFields
			EndIF 
					
			cAliasQuery := ( "__Q" + cAliasQuery + "QRY" )
			cQuery := "SELECT "
			cQuery += cQryMarcFields
			cQuery += "R_E_C_N_O_ RECNO "
			cQuery += " FROM "
			cQuery += InitSqlName(cAlias)
			cQuery += " WHERE "
			cQuery += cPrefixo + "FILIAL='"+cFil+"'"
			cQuery += " AND "
			cQuery += cPrefixo + "MAT='"+cMat+"'"  
			
			// Verifica a Data Inicial se nao considera a data de apontamento ou 
			// se a considera e foi solicitada a verificacao da data inicial
			IF !(lDataApo) .or. (lDataApo .and. lDataIni)
				cQuery += " AND "
				cQuery += cPrefixo + "DATA>='"+cIniData+"'"
			Endif
			
			cQuery += " AND "
			cQuery += cPrefixo + "DATA<='"+cFimData+"'"
			IF ( lChkPerAponta )
				cQuery += " AND "
				cQuery += " ( "
				cQuery +=		cPrefixo + "PAPONTA='"+cPerAponta+"'"
				cQuery += 		" OR "
				cQuery +=		cPrefixo + "PAPONTA='"+Space(Len(cPerAponta))+"'"
				cQuery += " ) "
			EndIF
			cQuery += " AND "
			cQuery += "D_E_L_E_T_=' ' "
			cQuery += "ORDER BY " + SqlOrder( (cAlias)->( IndexKey() ) )
			cQuery := ChangeQuery(cQuery)
			IF ( lQueryOpened := MsOpenDbf(.T.,"TOPCONN",TcGenQry(NIL,NIL,cQuery),cAliasQuery,.F.,.T.) )
				For nX := 1 To nGetMarcFields
					IF ( aGetMarcFields[ nX , 02 ] <> "C" )
						TcSetField(cAliasQuery,aGetMarcFields[nX,01],aGetMarcFields[nX,02],aGetMarcFields[nX,03],aGetMarcFields[nX,04])
					EndIF
				Next nX
			Else
				cAliasQuery := cAlias
			EndIF	

		EndIF
			
	#ENDIF

	cFilMat := ( cFil + cMat )

	IF !( lQueryOpened )
		cAliasQuery := cAlias
		( cAliasQuery )->( dbSeek( cFilMat , .F. ) )
	EndIF		


        
	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Obtem as Marcacoes validas para o Periodo                    Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	While ( cAliasQuery )->( !Eof() .and. ( &( cPrefixo+"FILIAL+"+cPrefixo+"MAT" ) == cFilMat ) )

		/*/
		здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Verificando a Ordem das Marcacoes                            Ё
		юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		IF ( lOrdem )
			/*/
			здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Ignora Marcacoes nao Ordenadas                               Ё
			юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			IF Empty( cAtuOrdem := ( cAliasQuery )->( &( cPrefixo+"ORDEM" ) ) )
				( cAliasQuery )->( dbSkip() )
				Loop
			EndIF	
			/*/
			здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Obtem String de Data Hora da Marcacao Referente a Ordem AtualЁ
			юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			cDtHrAtu 	:= ( cAliasQuery )->( DataHora2Str( &( cPrefixo+"DATA" ) , &( cPrefixo+"HORA" ) ) )
			/*/
			здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Ignora Marcacoes Fora dos Limites Considerando a Ordem 	   Ё
			юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/     
			//-- Verifica a ordem se nao for checar o periodo de apontamento ou
			//-- se for para checar, mas o periodo de apontamento estah vazio (ou seja verifico a ordem pois a 
			//-- checagem do periodo nao consiguirah verificar se a marcacao se encontra entre os limites do periodo)
			IF !( lChkPerAponta ) .OR. ( lChkPerAponta .and. Empty( (cAliasQuery)->( &(cPrefixo+"PAPONTA") ) ) )
				IF (;
						(;
							( cAtuOrdem >= cPriOrdem   ) .and. ( cDtHrAtu < cDtHrLimIni );	//Marcacao de Periodo Posterior
						 ) .or. ;
						 (;
							( cAtuOrdem <= cUltOrdem   ) .and. ( cDtHrAtu > cDtHrLimFim );	//Marcacao de Periodo Anterior
						 );
					)		
					( cAliasQuery )->( dbSkip() )
					Loop
				EndIF
			
				/*/
				здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				ЁSe for a Primeira Ordem, compara Horarios em Relacao ao LimiteЁ
				ЁFinal da Proxima Ordem									   	   Ё
				юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
				IF ( cAtuOrdem == cPriOrdem )
					IF Empty( nPosPrxOrd )
						cPrxOrdem	:= StrZero( ( Val( cAtuOrdem ) + 1 ) , __nTamP8Ordem )
						nPosPrxOrd	:= aScan(;
												aTabCalend , { |x|;
																	( x[ CALEND_POS_ORDEM ] == cPrxOrdem ) .and.;
																	!Empty( x[ CALEND_POS_LIM_MARCACAO , 01 ] ) .and.;
																	( x[ CALEND_POS_TIPO_MARC ] <> "1E" );
														 	  };
									 		)
	                   	IF ( nPosPrxOrd > 0 )
							cDtHrPrxOrd := DataHora2Str(;
															aTabCalend[ nPosPrxOrd , CALEND_POS_LIM_MARCACAO , 01 ],;
															aTabCalend[ nPosPrxOrd , CALEND_POS_LIM_MARCACAO , 02 ];
														)
	    				EndIF
					EndIF
					IF ( nPosPrxOrd > 0 )
						IF ( cDtHrAtu > cDtHrPrxOrd )
							( cAliasQuery )->( dbSkip() )
							Loop
						EndIF
					EndIF	
				EndIF
				/*/
				здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				ЁSe for a Ultima Ordem, compara Horarios em Relacao ao   LimiteЁ
				ЁInicial da Ordem Anterior       							   Ё
				юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
				IF ( cAtuOrdem == cUltOrdem )
					IF Empty( nPosAntOrd )
						cAntOrdem	:= StrZero( ( Val( cAtuOrdem ) - 1 ) , __nTamP8Ordem )
						nPosAntOrd	:= aScan(;
												aTabCalend , { |x|;
																	( x[ CALEND_POS_ORDEM ] == cAntOrdem ).and.; 
																	( x[ CALEND_POS_TIPO_MARC ] == "1E" );
														 	  };
									 		)
						IF ( nPosAntOrd > 0 )
							cDtHrAntOrd := DataHora2Str(;
															aTabCalend[ nPosAntOrd , CALEND_POS_LIM_MARCACAO , 01 ],;
															aTabCalend[ nPosAntOrd , CALEND_POS_LIM_MARCACAO , 02 ];
														)
						EndIF
					EndIF
					IF ( nPosAntOrd > 0 )
						IF ( cDtHrAtu <= cDtHrAntOrd )
							( cAliasQuery )->( dbSkip() )
							Loop
						EndIF
					EndIF	
				EndIF
			Endif	    
			   
		/*/
		здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Verificando a Data de Apontamento das Marcacoes              Ё
		юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/			
		ElseIF (lDataApo)
			/*/
			здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Ignora Marcacoes Sem Data de Apontamento                     Ё
			юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			IF Empty(  cAtuDataApo := Dtos(( cAliasQuery )->( &( cPrefixo+"DATAAPO" ) )) )
				( cAliasQuery )->( dbSkip() )
				Loop
			EndIF	
		
			/*/
			здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Ignora Marcacoes Fora dos Limites Considerando a Data de Apontamento Ё
			юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/     
		       IF lDataIni
					IF (	( cAtuDataApo < cIniData  ) .or. ( cAtuDataApo > cFimData ) )	//Marcacao fora do Periodo de Apontamento
						( cAliasQuery )->( dbSkip() )
						Loop
					EndIF
			   Else        
			   		IF (	( cAtuDataApo > cFimData ) )	//Marcacao fora do Periodo de Apontamento
						( cAliasQuery )->( dbSkip() )
						Loop
					EndIF
			   Endif
			   
			
		Else
			/*/
			здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Ignora Marcacoes Fora dos Limites Considerando o Serial      Ё
			юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			IF (;
					( cAliasQuery )->(;
										(;
											nSerMarc := __fDHtoNS( &( cPrefixo+"DATA" ),&( cPrefixo+"HORA" ) );
										);
									  ) < nSerIni;
					.or.;
					( nSerMarc > nSerFim );
				 )
					/*/
					здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
					Ё Ignora Marcacoes Fora dos Limites Considerando o Serial      Ё
					юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
					( cAliasQuery )->( dbSkip() )
					Loop
			EndIF
		EndIF

		/*/
		здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Ignora Marcacoes Fora do Periodo de Apontamento              Ё
		юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		IF ( lChkPerAponta )
			IF ( !Empty( (cAliasQuery)->( &(cPrefixo+"PAPONTA") ) ) .and. ( (cAliasQuery)->( &(cPrefixo+"PAPONTA") ) <> cPerAponta ) )
				( cAliasQuery )->( dbSkip() )
				Loop
			EndIF	
		EndIF

		/*/
		здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Verifica se Deve Carregar as Marcacoes Automaticas           Ё
		юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		IF ( !( lGetMarcAuto ) .and. ( cAliasQuery )->( &( cPrefixo+"FLAG" ) == "A" .and. Eval( bCondMarcAut ) ) )
			#IFNDEF TOP
				aAdd( aRecsMarcAut , ( cAliasQuery )->( Recno() ) )
			#ELSE
				IF !( lQueryOpened )
					aAdd( aRecsMarcAut , ( cAliasQuery )->( Recno() ) )
				Else
					aAdd( aRecsMarcAut , ( cAliasQuery )->( RECNO ) )
				EndIF
			#ENDIF
			( cAliasQuery )->( dbSkip() )
			Loop
		EndIF

		/*/
		здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Carrega as Marcacoes do Funcionario                          Ё
		юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		aAdd( aMarcacoes , Array( ELEMENTOS_AMARC ) )
		nLenMarc := Len( aMarcacoes )
		( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_DATA   ] := &(cPrefixo+"DATA")	)					//01 - Data
		( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_HORA   ] := &(cPrefixo+"HORA")	)					//02 - Hora
		( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_ORDEM  ] := &(cPrefixo+"ORDEM")	)					//03 - Ordem
		( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_FLAG   ] := &(cPrefixo+"FLAG")	)					//04 - Flag
		IF ( lRecno )
			#IFNDEF TOP
				( cAliasQuery )->(aMarcacoes[ nLenMarc , AMARC_RECNO ] := Recno()  		)					//05 - Recno 
			#ELSE
				IF !( lQueryOpened )
					( cAliasQuery )->(aMarcacoes[ nLenMarc , AMARC_RECNO ] := Recno() 	)					//05 - Recno 
				Else                                                                                	
					( cAliasQuery )->(aMarcacoes[ nLenMarc , AMARC_RECNO ] := RECNO		)					//05 - Recno 
				EndIF
			#ENDIF
		Else
			aMarcacoes[ nLenMarc , AMARC_RECNO ] := 0														//05 - Recno
		EndIF
		( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_TURNO		] := &(cPrefixo+"TURNO")	)			//06 - Turno
		( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_FUNCAO		] := &(cPrefixo+"FUNCAO")	)			//07 - Funcao 
		( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_GIRO		] := &(cPrefixo+"GIRO") 	)			//08 - Giro
		( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_CC			] := &(cPrefixo+"CC")		)			//09 - Centro de Custo
		( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_APONTA		] := &(cPrefixo+"APONTA")	)			//10 - Flag de Apontamento
		( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_RELOGIO		] := &(cPrefixo+"RELOGIO")	)			//11 - Relogio
		( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_TIPOMARC	] := &(cPrefixo+"TPMARCA")	)			//12 - Tipo da Marcacao
		( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_PROCESSO	] := &(cPrefixo+"PROCES")	)			//18 - Processo
		( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_ROTEIRO		] := &(cPrefixo+"ROTEIR")	)			//19 - Roteiro
		( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_PERIODO		] := &(cPrefixo+"PERIODO")	)			//20 - Periodo
		( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_NUM_PAGTO	] := &(cPrefixo+"NUMPAG")	)			//21 - NumPag
		( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_DEPTO		] := &(cPrefixo+"DEPTO")	)			//22 - Depto
		( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_POSTO		] := &(cPrefixo+"POSTO")	)			//23 - Posto
		( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_CODFUNC		] := &(cPrefixo+"CODFUNC")	)			//24 - Cod. Func.                
		( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_DATAAPO		] := &(cPrefixo+"DATAAPO")	)			//25 - Data de Apontamento.   
		
		/*/
		здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Verifica se a Marcacao sera ordenada                         Ё
		юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		lNotOrdena := (;
							( aMarcacoes[ nLenMarc , AMARC_FLAG ] $ "M,I" ) .and.;
							!Empty( aMarcacoes[ nLenMarc , AMARC_ORDEM  ] );
					   )		
		aMarcacoes[ nLenMarc , AMARC_L_ORIGEM ] := lNotOrdena												//13 - Logico Origem 
		aMarcacoes[ nLenMarc , AMARC_DTHR2STR ] := DataHora2Str(;                                           
																	aMarcacoes[ nLenMarc , AMARC_DATA ] ,;
																	aMarcacoes[ nLenMarc , AMARC_HORA ]  ;
																)                                           //14 - String de Data/Hora para aSort
		( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_PERAPONTA	] := &(cPrefixo+"PAPONTA")	)		//15 - Periodo de Apontamento
		( cAliasQuery )->( dbSkip() )
	End While

	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Fecha a Query e Seta a Area do Arquivo Original              Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
    IF ( ( lQueryOpened ) .and. ( Select( cAliasQuery ) > 0 ) )
    	( cAliasQuery )->( dbCloseArea() )
    	dbSelectArea( cAlias )
    EndIF	

	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Restaura a Ordem de Entrada                                  Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	IF !( nSvIndexOrd == IF( lOrdem , 1 , 2 ) )
		( cAlias )->( dbSetOrder( nSvIndexOrd ) )
	EndIF	

	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Verifica as Folgas Automaticas apenas Quando Marcacoes ja  tiЁ
	Ё verem Sido Ordenadas										   Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	IF ( ( lDiasFolga ) .and. ( lOrdem ) )
		cCod036N := PosSP9("036N",cFil,"P9_CODIGO",2)
		fDiasFolga(aClone(aMarcacoes),@aTabCalend,dPerIni,dPerFim,cCod036N,( cAlias == "SPG" ) , lGrvFolgPa )
	EndIF
	
End Sequence

/*/
здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Restaura a Area de Entrada                                   Ё
юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
IF !Empty( cSvAlias ) 
	dbSelectArea( cSvAlias )
EndIF

Return( lGetMarcOk )  


/*/
зддддддддддбддддддддддддбддддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁGetMarcOPC  ЁAutor Ё Mauricio MR		  Ё Data Ё12/08/2005Ё
цддддддддддеддддддддддддаддддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁRetornar Array aMarcacoes com as Marcacoes do Periodo       Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   ЁGetMarcOpc(@aMarcacoes,...)									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁPonto Eletronico                                            Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁlGetMarcOk                         							Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ < Vide Parametros Formais >								Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function GetMarcOpc(	aMarcacoes			,;	//01 -> Marcacoes dos Funcionarios
						dPerIni 			,;	//02 -> Periodo Inicial
						dPerFim				,;	//03 -> Periodo Final
						cFil				,;	//04 -> Filial
						cMat				,;	//05 -> Matricula
						cTno				,;	//06 -> Turno
						cSeq				,;	//07 -> Sequencia de Turno
						cCc					,;	//08 -> Centro de Custo
						cAlias				,;	//09 -> Alias para Carga das Marcacoes
						lRecno				,;	//10 -> Se carrega Recno em aMarcacoes
						lGetMarcAuto		,;	//11 -> Se Carrega as Marcacoes Automaticas
						aRecsMarcAut	    ,;	//12 -> Registros de Marcacoes Automaticas que deverao ser Desprezadas
						bCondMarcAut		;	//13 -> Bloco para avaliar as Marcacoes Automaticas que deverao ser Desprezadas
					  )

   
/*
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Variaveis de Inicializacao Obrigatoria					  Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/

Local cSvAlias			:= Alias()
Local lGetMarcOk 		:= .T.
Local lQueryOpened		:= .F.


/*
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Variaveis que serao inicializadas no Corpo da Funcao		  Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/      

Local cFilMat
Local cAliasQuery  
Local cPrefixo
Local cDtHrLimIni
Local cDtHrLimFim
Local cDtHrAtu
Local cSetOrdem
Local lNotOrdena    
Local nI
Local nLenMarc
Local nSerMarc
Local nSerIni
Local nSerFim
Local nSvIndexOrd
Local nSetOrder

#IFDEF TOP

	/*/

	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Variaveis de Inicializacao Obrigatoria					  Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/

	Local aGetMarcFields	:= {}

	/*/

	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Variaveis que serao inicializadas no Corpo da Funcao		  Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/

	Local cQryMarcFields
	Local cIniData
	Local cFimData
	Local cQuery
	Local nGetMarcFields
	Local nX

	Static aGetSP8Fields
	Static cQrySP8Fields
	Static cQrySPGFields
	Static nGetSP8Fields
	Static aGetSPGFields
	Static nGetSPGFields

#ENDIF

DEFAULT cFil				:= SRA->RA_FILIAL
DEFAULT cMat				:= SRA->RA_MAT
DEFAULT cTno				:= SRA->RA_TNOTRAB
DEFAULT cSeq				:= SRA->RA_SEQTURN
DEFAULT dPerIni				:= Ctod("//")
DEFAULT dPerFim				:= Ctod("//")
DEFAULT cAlias				:= "SP8"
DEFAULT lRecno				:= .T.
DEFAULT lGetMarcAuto		:= .T.
DEFAULT bCondMarcAut		:= { || .T. }

aRecsMarcAut				:= {}

nSerIni := __fDHtoNS( dPerIni-7,00.00 )
nSerFim := __fDHtoNS( dPerFim+7,23.59 )
	
Begin Sequence

	
	cAlias			:= Upper( AllTrim( cAlias ) )
	cAliasQuery 	:= cAlias
	cPrefixo		:= ( PrefixoCpo( cAliasQuery ) + "_" )
	aMarcacoes  	:= {}


	/*/

	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Seleciona o Arquivo de Marca┤■es e Seta a Ordem correspondenЁ
	Ё te:														  Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/

	nSvIndexOrd := ( cAlias )->( IndexOrd() )
	cSetOrdem	:= ""
	/*/

	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	ЁData  <=> _FILIAL+_MAT+_DTOS(_DATA)+STR(_HORA,5,2)    	  	  Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/

	cSetOrdem += cPrefixo+"FILIAL+"
	cSetOrdem += cPrefixo+"MAT+"
	cSetOrdem += "DTOS("+cPrefixo+"DATA)+"
	cSetOrdem += "STR("+cPrefixo+"HORA,5,2)" 

	nSetOrder	:= RetOrdem( cAlias , cSetOrdem )
	IF !( nSvIndexOrd == nSetOrder )
		( cAlias )->( dbSetOrder( nSetOrder ) )
	EndIF

	/*/

	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Cria array com as marca┤■es do Periodo para o funcion═rio.  Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/

	#IFDEF TOP

		IF !( lExInAs400 )

			/*/
		
			здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Monta Query para Carga das Marcacoes                         Ё
			юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		
			IF ( cAlias == "SP8" )
				IF ( aGetSP8Fields == NIL )
					aGetSP8Fields	:= (cAlias)->( dbStruct() )
					nGetSP8Fields	:= Len( aGetSP8Fields )
					cQrySP8Fields	:= ""
					For nX := 1 To nGetSP8Fields
		        		cQrySP8Fields += aGetSP8Fields[ nX , 01 ] + ", "
					Next nX
				EndIF
				aGetMarcFields	:= aClone( aGetSP8Fields )
				cQryMarcFields	:= cQrySP8Fields
				nGetMarcFields	:= nGetSP8Fields
			ElseIF ( cAlias == "SPG" )
				IF ( aGetSPGFields == NIL )
					aGetSPGFields	:= (cAlias)->( dbStruct() )
					nGetSPGFields	:= Len( aGetSPGFields )
					cQrySPGFields	:= ""
					For nX := 1 To nGetSPGFields
		        		cQrySPGFields += aGetSPGFields[ nX , 01 ] + ", "
					Next nX
				EndIF	
				aGetMarcFields	:= aClone( aGetSPGFields )
				cQryMarcFields	:= cQrySPGFields
				nGetMarcFields	:= nGetSPGFields
			EndIF
			cIniData	:= Dtos( dPerIni-7 )
			cFimData	:= Dtos( dPerFim+7 )
			cAliasQuery := ( "__Q" + cAliasQuery + "QRY" )
			cQuery := "SELECT "
			cQuery += cQryMarcFields
			cQuery += "R_E_C_N_O_ RECNO "
			cQuery += " FROM "
			cQuery += InitSqlName(cAlias)
			cQuery += " WHERE "
			cQuery += cPrefixo + "FILIAL='"+cFil+"'"
			cQuery += " AND "
			cQuery += cPrefixo + "MAT='"+cMat+"'"
			cQuery += " AND "
			cQuery += cPrefixo + "DATA>='"+cIniData+"'"
			cQuery += " AND "
			cQuery += cPrefixo + "DATA<='"+cFimData+"'"
			cQuery += " AND "
			cQuery += "D_E_L_E_T_=' ' "
			cQuery += "ORDER BY " + SqlOrder( (cAlias)->( IndexKey() ) )
			cQuery := ChangeQuery(cQuery)
			IF ( lQueryOpened := MsOpenDbf(.T.,"TOPCONN",TcGenQry(NIL,NIL,cQuery),cAliasQuery,.F.,.T.) )
				For nX := 1 To nGetMarcFields
					IF ( aGetMarcFields[ nX , 02 ] <> "C" )
						TcSetField(cAliasQuery,aGetMarcFields[nX,01],aGetMarcFields[nX,02],aGetMarcFields[nX,03],aGetMarcFields[nX,04])
					EndIF
				Next nX
			Else
				cAliasQuery := cAlias
			EndIF	

		EndIF
			
	#ENDIF

	cFilMat := ( cFil + cMat )

	IF !( lQueryOpened )
		cAliasQuery := cAlias
		( cAliasQuery )->( dbSeek( cFilMat , .F. ) )
	EndIF		

        
	/*/       

	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Obtem as Marcacoes validas para o Periodo                    Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/

	While ( cAliasQuery )->( !Eof() .and. ( &( cPrefixo+"FILIAL+"+cPrefixo+"MAT" ) == cFilMat ) )


		/*/
	
		здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Ignora Marcacoes Fora dos Limites Considerando o Serial      Ё
		юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	
		IF (;
				( cAliasQuery )->(;
									(;
										nSerMarc := __fDHtoNS( &( cPrefixo+"DATA" ),&( cPrefixo+"HORA" ) );
									);
								  ) < nSerIni;
				.or.;
				( nSerMarc > nSerFim );
			 )
			/*/
		
			здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Ignora Marcacoes Fora dos Limites Considerando o Serial      Ё
			юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		
			( cAliasQuery )->( dbSkip() )
			Loop
		EndIF
	

		/*/   
	
		здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Verifica se Deve Carregar as Marcacoes Automaticas           Ё
		юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	
		IF ( !( lGetMarcAuto ) .and. ( cAliasQuery )->( &( cPrefixo+"FLAG" ) == "A" .and. Eval( bCondMarcAut ) ) )
			#IFNDEF TOP
				aAdd( aRecsMarcAut , ( cAliasQuery )->( Recno() ) )
			#ELSE
				IF !( lQueryOpened )
					aAdd( aRecsMarcAut , ( cAliasQuery )->( Recno() ) )
				Else
					aAdd( aRecsMarcAut , ( cAliasQuery )->( RECNO ) )
				EndIF
			#ENDIF
			( cAliasQuery )->( dbSkip() )
			Loop
		EndIF

		/*/
	
		здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Carrega as Marcacoes do Funcionario                          Ё
		юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	
		aAdd( aMarcacoes , Array( ELEMENTOS_AMARC ) )
		nLenMarc := Len( aMarcacoes )
		( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_DATA   ] := &(cPrefixo+"DATA")	)					//01 - Data
		( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_HORA   ] := &(cPrefixo+"HORA")	)					//02 - Hora
		( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_ORDEM  ] := &(cPrefixo+"ORDEM")	)					//03 - Ordem
		( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_FLAG   ] := &(cPrefixo+"FLAG")	)					//04 - Flag
		IF ( lRecno )
			#IFNDEF TOP
				( cAliasQuery )->(aMarcacoes[ nLenMarc , AMARC_RECNO ] := Recno()  		)					//05 - Recno 
			#ELSE
				IF !( lQueryOpened )
					( cAliasQuery )->(aMarcacoes[ nLenMarc , AMARC_RECNO ] := Recno() 	)					//05 - Recno 
				Else                                                                                	
					( cAliasQuery )->(aMarcacoes[ nLenMarc , AMARC_RECNO ] := RECNO		)					//05 - Recno 
				EndIF
			#ENDIF
		Else
			aMarcacoes[ nLenMarc , AMARC_RECNO ] := 0														//05 - Recno
		EndIF
		( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_TURNO		] := &(cPrefixo+"TURNO")	)			//06 - Turno
		( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_FUNCAO		] := &(cPrefixo+"FUNCAO")	)			//07 - Funcao 
		( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_GIRO		] := &(cPrefixo+"GIRO") 	)			//08 - Giro
		( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_CC			] := &(cPrefixo+"CC")		)			//09 - Centro de Custo
		( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_APONTA		] := &(cPrefixo+"APONTA")	)			//10 - Flag de Apontamento
		( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_RELOGIO		] := &(cPrefixo+"RELOGIO")	)			//11 - Relogio
		( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_TIPOMARC	] := &(cPrefixo+"TPMARCA")	)			//12 - Tipo da Marcacao
		( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_PROCESSO	] := &(cPrefixo+"PROCES")	)			//18 - Processo
		( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_ROTEIRO		] := &(cPrefixo+"ROTEIR")	)			//19 - Roteiro
		( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_PERIODO		] := &(cPrefixo+"PERIODO")	)			//20 - Periodo
		( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_NUM_PAGTO	] := &(cPrefixo+"NUMPAG")	)			//21 - NumPag
		( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_DEPTO		] := &(cPrefixo+"DEPTO")	)			//22 - Depto
		( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_POSTO		] := &(cPrefixo+"POSTO")	)			//23 - Posto
		( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_CODFUNC		] := &(cPrefixo+"CODFUNC")	)			//24 - Cod. Func.
		( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_DATAAPO		] := &(cPrefixo+"DATAAPO")	)			//25 - Data de Apontamento .   


		/*/
	
		здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Verifica se a Marcacao sera ordenada                         Ё
		юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	
		lNotOrdena := (;
							( aMarcacoes[ nLenMarc , AMARC_FLAG ] $ "M,I" ) .and.;
							!Empty( aMarcacoes[ nLenMarc , AMARC_ORDEM  ] );
					   )		
		aMarcacoes[ nLenMarc , AMARC_L_ORIGEM ] := lNotOrdena												//13 - Logico Origem 
		aMarcacoes[ nLenMarc , AMARC_DTHR2STR ] := DataHora2Str(;                                           
																	aMarcacoes[ nLenMarc , AMARC_DATA ] ,;
																	aMarcacoes[ nLenMarc , AMARC_HORA ]  ;
																)                                           //14 - String de Data/Hora para aSort
		( cAliasQuery )->( aMarcacoes[ nLenMarc , AMARC_PERAPONTA	    ] := &(cPrefixo+"PAPONTA")	)		//15 - Periodo de Apontamento
		aMarcacoes[ nLenMarc , AMARC_SEQ	] := SPACE(2)											//16 - Sequencia da Tabela de Horario Padrao (turno opcional) ja identificado
		aMarcacoes[ nLenMarc , AMARC_DIA	] := SPACE(2)											//17 - Dia da semana da Tabela de Horario Padrao (turno opcional) ja identificado
		( cAliasQuery )->( dbSkip() )
	End While

	/*/   

	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Fecha a Query e Seta a Area do Arquivo Original              Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
   
    IF ( ( lQueryOpened ) .and. ( Select( cAliasQuery ) > 0 ) )
    	( cAliasQuery )->( dbCloseArea() )
    	dbSelectArea( cAlias )
    EndIF	

	/*/

	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Restaura a Ordem de Entrada                                  Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/

	IF !( nSvIndexOrd ==  2  )
		( cAlias )->( dbSetOrder( nSvIndexOrd ) )
	EndIF	

End Sequence

/*/   

здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Restaura a Area de Entrada                                   Ё
юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/

IF !Empty( cSvAlias ) 
	dbSelectArea( cSvAlias )
EndIF
	
Return( lGetMarcOk )  


/*/
зддддддддддбддддддддддддбддддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁGetTnoOpc   ЁAutor Ё Mauricio MR		  Ё Data Ё12/08/2005Ё
цддддддддддеддддддддддддаддддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁRetornar Array com Horario para substituicao do pre-esta-   Ё
Ё          Ёbelecido em funcao da marcacao realiazada.                  Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   ЁGetTnoOpc(cTurno,...)									    Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁPonto Eletronico                                            Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁlRet	                         							Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ < Vide Parametros Formais >								Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function GetTnoOpc( cTurno,  dData, aDiaTurnoOK, aTabPadrao, aTabTno, cFilSPJ, aMarcacoes)
                
Local aHorOpc
Local aSerial
Local aTemp
Local aTnoSeqDia
Local cOrdem
Local cSeq         
Local nDia  
Local lRet	:= .F.  
Local nHorOpc		 
Local nPos1
Local nPos2
Local nPosTnoOpc		
Local nPosTnoEscolhido 
Local nHora
Local nSerIniTno
Local nSerFimTno 
Local uHora        
Local nSerIni
Local nSerFim
Local nSerMeiaJorn

Begin Sequence 
    nHora	:= aTabTno[01]                                                                   
    cSeq	:= aTabTno[19]
    nDia	:= aTabTno[20]
    
   	//-- Obtem Todos os Horarios para Filial + Turno + Dia
	If (nPosTnoOpc:=Ascan(__aAllTnoOpc,{|x| ( x[1] + x[2] ) == (cFilSPJ + cTurno ) }) ) >  0
    	aHorOpc:=aClone(__aAllTnoOpc[nPosTnoOpc, 3, nDia])
    	AADD(aHorOpc, aTabTno)
		aSort( @aHorOpc , NIL , NIL , { |x,y| ( x[1] < y[1] ) } )    	 
	Else    
	   Break
	Endif
	
	//-- Verifica se existe horario para o turno opcional
    If Empty(aHorOpc)                     
       Break
    Endif   
                                               
	//Obtem os limites maximos possiveis para o dia  
	aSerial		:= fLimitTnoOpc(dData, aHorOpc[ 1 ] )
	nSerIniTno 	:= aSerial[1]                     
	aSerial		:= fLimitTnoOpc(dData, aHorOpc[ Len(aHorOpc) ] )
	nSerFimTno 	:= aSerial[2]
	
	//-- Procura pela primeira marcacao ainda nao verificada
	If (nPos1:= Ascan(aMarcacoes, {|x| EMPTY( x[AMARC_SEQ] )  } ) )  ==   0
	   Break
	Endif   
	nSerIni:=nSerFim:=0
    
    //-- Corre todas as marcacoes a partir da primeira marcacao nao classificada
	For nPos2:= nPos1 To Len(aMarcacoes)

	   	If (! EMPTY( aMarcacoes[nPos2, AMARC_TNOPC] ) )
 	   		Loop
 	   	Endif
 	   	
	    uHora	:= aMarcacoes[nPos2, AMARC_HORA]
	    uHora	:= If( ValType( uHora ) = "C", Val(uHora), uHora )
	    nSerMarc:= __fDHtoNS(aMarcacoes[nPos2, AMARC_DATA], uHora )

	    //-- Verifica se Marcacao esta fora dos limites maximos do turno
	    If nSerMarc < nSerIniTno
	       	Loop

	    ElseIf 	nSerMarc > nSerFimTno
        	Exit
	    Endif
	    
	    //-- Verifica se Marcacao esta entre os limites do turno ja verificado  (se ja foi identificado)
	    If !Empty(nSerIni)
	        If (nSerMarc < nSerIni)
	            Loop
	        ElseIf nSerMarc > nSerFim  .and. aMarcacoes[nPos2, AMARC_ORDEM] <> aMarcacoes[nPos1, AMARC_ORDEM]
	            Exit
	        Else
           		aMarcacoes[nPos2, AMARC_TURNO]	:= cTurno
		        aMarcacoes[nPos2, AMARC_SEQ] 	:= aHorOpc[ nPosTnoEscolhido, 19 ]
		   		aMarcacoes[nPos2, AMARC_DIA] 	:= aHorOpc[ nPosTnoEscolhido, 20 ]
		   		aMarcacoes[nPos2, AMARC_TNOPC] 	:= aHorOpc[ nPosTnoEscolhido, 19 ]
		        Loop
	        Endif
	    Endif
	    
   	    //-- Verifica a qual das entradas possiveis para o turno a marcacao mais se aproxima
    	aTemp := {} 
    	For nHorOpc  := 1 To Len(aHorOpc)   
	    	aAdd( aTemp , { nHorOpc , DataHora2Val( 	aMarcacoes[nPos2, AMARC_DATA]	,;
													 	uHora							,;
													 	dData							,;
													 	aHorOpc[ nHorOpc , 01 ]	    	,;
													 	"H"							 	;
												  );
							};											  
			 	)
		Next nHorOpc
		
		aSort( aTemp , NIL , NIL , { |x,y| x[2] < y[2] } )		
                            
        //--Gera o Limite do Turno Selecionado para o Dia
		nPosTnoEscolhido 	:= aTemp[1,1]
		aSerial				:= fLimitTnoOpc(dData, aHorOpc[ nPosTnoEscolhido], .T. )
	    nSerIni				:= aSerial[1]
	    nSerFim				:= aSerial[2]  
        nSerMeiaJorn		:= aSerial[3]  
        
   		//-- Verifica se a Marcacao esta fora dos limites do turno (Entre o HorMenos e a MeiaJornada)
	    If ( nSerMarc < nSerIni .or.  nSerMarc > nSerMeiaJorn )
	       Loop                                                                     
	    Endif   
   		
   		aMarcacoes[nPos2, AMARC_TURNO]	:= cTurno 	    
        aMarcacoes[nPos2, AMARC_SEQ] 	:= aHorOpc[ nPosTnoEscolhido, 19 ]
   		aMarcacoes[nPos2, AMARC_DIA] 	:= aHorOpc[ nPosTnoEscolhido, 20 ]
   		
        aDiaTurnoOK[ Len(aDiaTurnoOK), 2 ]  	:= {cTurno, aHorOpc[ nPosTnoEscolhido, 19 ], aHorOpc[ nPosTnoEscolhido, 20 ] }
	    
	    aTabTno[01] 	:=aHorOpc[ nPosTnoEscolhido][01]		// 01 - 1a Entrada
		aTabTno[02] 	:=aHorOpc[ nPosTnoEscolhido][02]		// 02 - 1a Saida
		aTabTno[03] 	:=aHorOpc[ nPosTnoEscolhido][03]		// 03 - 2a Entrada
		aTabTno[04] 	:=aHorOpc[ nPosTnoEscolhido][04]		// 04 - 2a Saida
		aTabTno[05] 	:=aHorOpc[ nPosTnoEscolhido][05]		// 05 - 3a Entrada
		aTabTno[06] 	:=aHorOpc[ nPosTnoEscolhido][06]		// 06 - 3a Saida
		aTabTno[07] 	:=aHorOpc[ nPosTnoEscolhido][07]		// 07 - 4a Entrada
		aTabTno[08] 	:=aHorOpc[ nPosTnoEscolhido][08]		// 08 - 4a Saida
		aTabTno[09] 	:=aHorOpc[ nPosTnoEscolhido][09]		// 09 - Horas Trabalhadas 1a. Jornada
		aTabTno[10] 	:=aHorOpc[ nPosTnoEscolhido][10]		// 10 - Horas Trabalhadas 2a. Jornada
		aTabTno[11] 	:=aHorOpc[ nPosTnoEscolhido][11]		// 11 - Horas Trabalhadas 3a. Jornada
		aTabTno[12] 	:=aHorOpc[ nPosTnoEscolhido][12]		// 12 - Horas Trabalhadas 4a. Jornada
		aTabTno[13] 	:=aHorOpc[ nPosTnoEscolhido][13]		// 13 - Horas de Intervalo 1S
		aTabTno[14] 	:=aHorOpc[ nPosTnoEscolhido][14]		// 14 - Horas de Intervalo 2S
		aTabTno[15] 	:=aHorOpc[ nPosTnoEscolhido][15]		// 15 - Horas de Intervalo 3S
		aTabTno[16] 	:= ""									// 16 - Marcacao e do dia seguinte ?
		aTabTno[17] 	:=aHorOpc[ nPosTnoEscolhido][17]		// 17 - Numero de Marcacoes
		aTabTno[29] 	:=aHorOpc[ nPosTnoEscolhido][29]		// 29 - Aponta Nona Hora
		aTabTno[30] 	:=aHorOpc[ nPosTnoEscolhido][30]		// 30 - Limite de Horario Inicial
		aTabTno[31] 	:=aHorOpc[ nPosTnoEscolhido][31]		// 31 - Limite de Horario Final
		aTabTno[32] 	:=aHorOpc[ nPosTnoEscolhido][32]		// 32 - 1a. Jornada Continua
		aTabTno[33] 	:=aHorOpc[ nPosTnoEscolhido][33]		// 33 - 2a. Jornada Continua
		aTabTno[34]		:=aHorOpc[ nPosTnoEscolhido][34]		// 34 - 3a. Jornada Continua
		aTabTno[35]		:=aHorOpc[ nPosTnoEscolhido][35]		// 35 - 4a. Jornada Continua
		aTabTno[36]		:=aHorOpc[ nPosTnoEscolhido][36]		// 36 - Codigo da Refeicao
	  
	    lRet	:= .T.
	Next nPos2
End

Return (lRet)   

/*/
зддддддддддбддддддддддддбддддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁfLimitTnoOpcЁAutor Ё Mauricio MR		  Ё Data Ё12/08/2005Ё
цддддддддддеддддддддддддаддддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁRetornar Array com os limites do dia para a identificacao   Ё
Ё          Ёde horario para Turnos Opcionais do funcionario.            Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   ЁfLimitTnoOpc(dDataTno, aTabTno)							    Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁPonto Eletronico                                            Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁArray  com os limites {nSerialIni, nSerialFim}	 			Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ < Vide Parametros Formais >								Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function fLimitTnoOpc(dDataTno, aTabTno, lMeiaJorn)

Local dData		:=	dDataTno
Local dDataI		
Local dDataF			
Local nY
Local nFornY    := 8 // 1E, 1S...4E,4S.
Local nSerialIni
Local nSerialFim    
Local nSeriaMeiaJorn
Local nHoraI			
Local nHoraF			
Local nDifHrs 		

Local aMeiaJorn		
Local aRetorno		
   
DEFAULT lMeiaJorn	:= .F.

    /*/
    
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Loop For/Next para a Carga das Marcacoes do Dia             Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/  
	
	For nY := 1 To nFornY

		/*/
		
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Abandona Quando as Marcacoes estiverem Vazias e Nao For  JorЁ
		Ё nada Continua												  Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	
		IF (;
				( ( nY == 3 ) .and. ( ( aTabTno[ 03 ] + aTabTno[  04 ] ) == 0 ) .and. ( aTabTno[ 33 ] != "S" ) ) .or. ;
		   		( ( nY == 5 ) .and. ( ( aTabTno[ 05 ] + aTabTno[  06 ] ) == 0 ) .and. ( aTabTno[ 34 ] != "S" ) ) .or. ;
		   		( ( nY == 7 ) .and. ( ( aTabTno[ 07 ] + aTabTno[  08 ] ) == 0 ) .and. ( aTabTno[ 35 ] != "S" ) )      ;
		   	)	
			Exit
		EndIF

		/*/
	
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Incrementa dData e nDias Quando Marcacao for do Dia SeguinteЁ
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	
		IF ( aTabTno[ nY ] <  aTabTno[ IF( nY == 1 , nY , nY-1 ) ] )
			++dData
		EndIF

		/*/
		
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Incrementa dData e nDias Caso Jornada Continua			  Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	
		IF (;
				 (;
							( ( nY == 2 ) .and. ( aTabTno[ 32 ] == "S" ) ) .or. ;
		   		  	    	( ( nY == 4 ) .and. ( aTabTno[ 33 ] == "S" ) ) .or. ;
		   			    	( ( nY == 6 ) .and. ( aTabTno[ 34 ] == "S" ) ) .or. ;
		   			    	( ( nY == 8 ) .and. ( aTabTno[ 35 ] == "S" ) )	   ;
		   		 );
		   	)
			++dData
		EndIF

		IF ( nY == 1 )
			nSerialIni		:= ( __fDhToNS( dData , aTabTno[ nY ] ) - __fDhToNS( NIL , aTabTno[ 30 ] ) )
			If lMeiaJorn
				dDataI		:= dData
				nHoraI		:= aTabTno[ nY ]
			Endif	
		EndIF
	Next nY
	nSerialFim		:= ( __fDhToNS( dData , aTabTno[ Min(nY-1, nFornY) ] ) + __fDhToNS( NIL ,aTabTno[ 31 ] ) )

	If lMeiaJorn
		dDataF			:= dData
		nHoraF			:= aTabTno[ Min(nY-1, nFornY) ]	
		
		nDifHrs 		:= DataHora2Val(dDataI,	nHoraI,	dDataF, nHoraF)
		nDifHrs 		:= __NoRound( nDifHrs/2 , 0 )
		nDifHrs 		:= __Min2Hrs( nDifHrs )
	
		aMeiaJorn		:= RetFimTab(dDataI, nHoraI, nDifHrs )										
		nSeriaMeiaJorn	:= __fDhToNS( aMeiaJorn[1] , aMeiaJorn[2] )
	    aRetorno		:= {nSerialIni, nSerialFim, nSeriaMeiaJorn }
    Else
	    aRetorno		:= {nSerialIni, nSerialFim, Nil } 
    Endif
    
Return( aRetorno )


/*/
зддддддддддбддддддддддддбддддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁLoadTnoOpc  ЁAutor Ё Mauricio MR		  Ё Data Ё12/08/2005Ё
цддддддддддеддддддддддддаддддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁRetornar Array com os horarios dos turnos opcionais de um   Ё
Ё          Ёturno.												        Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   ЁLoadTnoOpc(cFilSPJ, ...)								    Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁPonto Eletronico                                            Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁlRet											 			Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ < Vide Parametros Formais >								Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/       
 
Static Function LoadTnoOpc(cFilSPJ, cTurno,__aAllTnoOpc, aTabPadrao) 
Local aSeq			:= {}
Local aSR6Info		:= {"R6_TNOOPC"} //01 -> Turno Opcional
Local cTnoOpc		:= ""
Local lRet			:= .F.
Local nPosAllTnoOpc
Local nPosSeq
Local nPosTabPad


Begin Sequence
	//-- Verifica se Turno ainda nao foi carregado
	If (nPosAllTnoOpc	:= Ascan(__aAllTnoOpc, {|x| x[1] == cFilSPJ .And. x[2] == cTurno } ) ) ==  0
	    //-- Verifica se trata de um turno opcional
	    aSr6Info:= PosSR6( cTurno , cFilSPJ , aSr6Info , 01 , .F. )
	    cTnoOpc:= aSr6Info[1]
	    If !Empty( cTnoOpc )
		    If (nPosTabPad	:= aScan(aTabPadrao, { |x| x[1] == cFilSPJ .And. x[2] == cTnoOpc })) == 0  
		   	   	/*/   
				зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				Ё Carrega a Tabela Para o turno ainda nao carregado           Ё
				юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
				fTabPadrao( @aTabPadrao , cFilSPJ , cTnoOpc, .T. ) 
			    If (nPosTabPad:= aScan(aTabPadrao, { |x| x[1] == cFilSPJ .And. x[2] == cTnoOpc })) == 0
			       Break
			    Endif
			Endif
		
			//-- Monta Tabela de Horarios Opcionais para o turno lido
			AADD(__aAllTnoOpc, {cFilSPJ, cTurno, Array(7,1) } )  
			nPosAllTnoOpc	:= Len(__aAllTnoOpc)
 		    Aeval(__aAllTnoOpc[ nPosAllTnoOpc,3 ], { |x| x:= {} } )
		   	aSeq		:= aClone( aTabPadrao[ nPosTabPad, 3 ] )
		   	For nPosSeq := 1 To Len(aSeq)  
		   	  	AADD(__aAllTnoOpc[nPosAllTnoOpc, 3, aSeq[nPosSeq, 20] ],  aClone( aSeq[nPosSeq] )  )	   		
		   	Next  
		    lRet:= .T.		   	
		Endif   	
	Else                        
	    lRet:= .T.		   	
	Endif       
End

Return( lRet )

/*/
зддддддддддбддддддддддддбддддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁPutMarcacoesЁAutor Ё Marinaldo de Jesus   Ё Data Ё03/04/2002Ё
цддддддддддеддддддддддддаддддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁGravar o Array aMarcacoes                                   Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁPonto Eletronico                                            Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁNIL                                							Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды*/

Function PutMarcacoes(	aMarcacoes	,;	//01 -> Array contendo as Marcacoes do Funcionario
						cFil		,;	//02 -> Filial do Funcionario
						cMat		,;	//03 -> Matricula do Funcionario
						cAlias		,;	//04 -> Arquivo para Gravacao ( "SP8" ou "SPG" )
						lNewRec		,;	//05 -> Se Forca a Inclusao de Novo Registro
						lSubsDtHr	,;	//06 -> Se Forca a Substituicao da Data/Hora
						nPosIni		,;	//07 -> Posicao Inicial para o aMarcacoes
						lSubsAll	 ;	//08 -> Se Forca a Substituicao de Tudo
					 )

Local cSvFilAnt := cFilAnt

Local aArea
Local cChave
Local cPrefixo
Local cSetOrdem
Local lGoto
Local lAddNew
Local lLock
Local nCount
Local nLenMarc
Local nOrder

#IFDEF TOP
	Local aCposChar
	Local aTamHora
	Local cTableName
	Local cCpoRecno
	Local cQryUpdate	
	Local nCpoChar
	Local nCposChar
#ENDIF

DEFAULT aMarcacoes	:= {}
DEFAULT cFil		:= SRA->RA_FILIAL
DEFAULT cMat		:= SRA->RA_MAT
DEFAULT cAlias		:= "SP8"
DEFAULT lNewRec		:= .F.
DEFAULT lSubsDtHr	:= .F.
DEFAULT nPosIni		:= 1
DEFAULT lSubsAll	:= .F.

cAlias	    := Upper( AllTrim( cAlias ) )
cPrefixo	:= ( PrefixoCpo( cAlias ) + "_" )
cFilAnt		:= IF( !Empty( cFil ) , cFil , cFilAnt )

#IFDEF TOP

	IF !( lExInAs400 )

		aTamHora	:= TamSx3( cPrefixo+"HORA" )
		cTableName	:= InitSqlName( cAlias )
		cCpoRecno	:= IF( lExInAs400 , "RRN("+cTableName+")", "R_E_C_N_O_" )
		cQryUpdate	:= ""

	EndIF

	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	ЁGaranto que Filial e Matricula nao Terao Strings Nulas de  forЁ
	Ёma a Evitar erro no UpDate quando Base em TOP                 Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	cFil	:= Padr( cFil	, GetSx3Cache( cPrefixo+"FILIAL"	, "X3_TAMANHO" ) )
	cMat	:= Padr( cMat	, GetSx3Cache( cPrefixo+"MAT"		, "X3_TAMANHO" ) )

	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	ЁObtenho o Tamanho dos Campos Char para garantir que no  UpdateЁ
	Ёnao Ocorra erro de NULLL quando Base em TOP                   Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	aCposChar := {}
	aAdd( aCposChar , { AMARC_FLAG		, GetSx3Cache( cPrefixo+"FLAG"		, "X3_TAMANHO" ) } )
	aAdd( aCposChar , { AMARC_FUNCAO	, GetSx3Cache( cPrefixo+"FUNCAO"	, "X3_TAMANHO" ) } )
	aAdd( aCposChar , { AMARC_GIRO		, GetSx3Cache( cPrefixo+"GIRO"		, "X3_TAMANHO" ) } )
	aAdd( aCposChar , { AMARC_CC		, GetSx3Cache( cPrefixo+"CC" 		, "X3_TAMANHO" ) } )
	aAdd( aCposChar , { AMARC_RELOGIO	, GetSx3Cache( cPrefixo+"RELOGIO"	, "X3_TAMANHO" ) } )
	aAdd( aCposChar , { AMARC_ORDEM		, GetSx3Cache( cPrefixo+"ORDEM" 	, "X3_TAMANHO" ) } )
	aAdd( aCposChar , { AMARC_TURNO		, GetSx3Cache( cPrefixo+"TURNO" 	, "X3_TAMANHO" ) } )
	aAdd( aCposChar , { AMARC_APONTA	, GetSx3Cache( cPrefixo+"APONTA"	, "X3_TAMANHO" ) } )
	aAdd( aCposChar , { AMARC_TIPOMARC	, GetSx3Cache( cPrefixo+"TPMARCA"	, "X3_TAMANHO" ) } )
	aAdd( aCposChar , { AMARC_PROCESSO	, GetSx3Cache( cPrefixo+"PROCES"	, "X3_TAMANHO" ) } )
	aAdd( aCposChar , { AMARC_ROTEIRO	, GetSx3Cache( cPrefixo+"ROTEIR"	, "X3_TAMANHO" ) } )
	aAdd( aCposChar , { AMARC_PERIODO	, GetSx3Cache( cPrefixo+"PERIODO"	, "X3_TAMANHO" ) } )
	aAdd( aCposChar , { AMARC_NUM_PAGTO	, GetSx3Cache( cPrefixo+"NUMPAG"	, "X3_TAMANHO" ) } )
	aAdd( aCposChar , { AMARC_DEPTO		, GetSx3Cache( cPrefixo+"DEPTO"		, "X3_TAMANHO" ) } )
	aAdd( aCposChar , { AMARC_POSTO		, GetSx3Cache( cPrefixo+"POSTO"		, "X3_TAMANHO" ) } )
	aAdd( aCposChar , { AMARC_CODFUNC	, GetSx3Cache( cPrefixo+"CODFUNC"	, "X3_TAMANHO" ) } )	     
	
	nCposChar := Len( aCposChar )

#ENDIF

aArea 		:= ( cAlias )->( GetArea() )

/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Seleciona o Arquivo de Marca┤■es e Seta a Ordem correspondenЁ
Ёte: _FILIAL+_MAT+_DTOS(_DATA)+STR(_HORA,5,2)    	  		  Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
cSetOrdem	:= cPrefixo+"FILIAL+"
cSetOrdem	+= cPrefixo+"MAT+"
cSetOrdem	+= "DTOS("+cPrefixo+"DATA)+"
cSetOrdem	+= "STR("+cPrefixo+"HORA,5,2)" 

nOrder		:= RetOrdem( cAlias , cSetOrdem )	

IF !( aArea[2] == nOrder )
	( cAlias )->( dbSetOrder( nOrder ) )
EndIF	

nLenMarc := Len( aMarcacoes )
For nCount := nPosIni To nLenMarc
	#IFDEF TOP
		/*/
		здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		ЁGaranto que os Campos Char nao Terao Strings Nulas de forma  aЁ
		Ёma a Evitar erro no UpDate quando Base em TOP                 Ё
		юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		For nCpoChar := 1 To nCposChar
			aMarcacoes[ nCount , aCposChar[ nCpoChar , 1 ] ] := Padr( aMarcacoes[ nCount , aCposChar[ nCpoChar , 1 ] ] , aCposChar[ nCpoChar , 2 ] )
		Next nCpoChar
	#ENDIF
	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	ЁSe nao estiver forcando a Inclusao de um Novo Registro		   Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	IF !( lNewRec )
		/*/
		здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		ЁPosiciona no Registro a ser Alteradao e seta a Inclusao   comoЁ
		ЁFalse (.F.)												   Ё
		юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		IF ( lGoto := ( ValType( aMarcacoes[ nCount , AMARC_RECNO ] ) == "N" .and. !Empty( aMarcacoes[ nCount , AMARC_RECNO ] ) ) )
			#IFNDEF TOP
				( cAlias )->( dbGoto( aMarcacoes[ nCount , AMARC_RECNO ] ) )
			#ELSE
				IF ( lExInAs400 )
					( cAlias )->( dbGoto( aMarcacoes[ nCount , AMARC_RECNO ] ) )
				EndIF
			#ENDIF
			lAddNew	:= .F.
		Else
			cChave	:= ( cFil + cMat + Dtos( aMarcacoes[ nCount , AMARC_DATA ] ) + Str( aMarcacoes[ nCount , AMARC_HORA ] , 5 , 2 ) )
			lAddNew := !( ( cAlias )->( dbSeek( cChave , .F. ) ) )
		EndIF
	Else
		/*/
		здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		ЁForca a Inclusao de um novo Registro						   Ё
		юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		lAddNew := .T.
	EndIF
	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	ЁTrava o Registro conforme lAddNew   						   Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	#IFNDEF TOP
		lLock := ( cAlias )->( RecLock( cAlias , lAddNew , .F. ) )
	#ELSE
		IF (;
				( lAddNew );
				.or.;
				( lExInAs400 );
			)
			lLock := ( cAlias )->( RecLock( cAlias , lAddNew , .F. ) )
		Else
			lLock := .T.
		EndIF
	#ENDIF	

	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	ЁSe nao Consegui o Lock Tenta o Proximo						   Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	IF !( lLock )
		Loop
	EndIF

	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	ЁGrava as Informacoes                						   Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	IF (;
			( lAddNew );
			.or.;
			( lSubsAll  );
		)
		#IFNDEF TOP
			( cAlias )->( &( cPrefixo+"FILIAL"  ) )	:= cFil
			( cAlias )->( &( cPrefixo+"MAT"	    ) )	:= cMat
			( cAlias )->( &( cPrefixo+"DATA"    ) )	:= aMarcacoes[ nCount , AMARC_DATA    	]	//01 - Data da Marcacao
			( cAlias )->( &( cPrefixo+"HORA"    ) )	:= aMarcacoes[ nCount , AMARC_HORA    	]	//02 - Hora da Marcacao
			( cAlias )->( &( cPrefixo+"FLAG"    ) )	:= aMarcacoes[ nCount , AMARC_FLAG    	]	//04 - Flag (Origem) da Marcacao
			( cAlias )->( &( cPrefixo+"FUNCAO"  ) )	:= aMarcacoes[ nCount , AMARC_FUNCAO	]	//07 - Funcao do Relogio
			( cAlias )->( &( cPrefixo+"GIRO"    ) )	:= aMarcacoes[ nCount , AMARC_GIRO    	]	//08 - Giro do Relogio
			( cAlias )->( &( cPrefixo+"CC"      ) )	:= aMarcacoes[ nCount , AMARC_CC      	]	//09 - Centro de Custo da Marcacao
			( cAlias )->( &( cPrefixo+"RELOGIO" ) )	:= aMarcacoes[ nCount , AMARC_RELOGIO 	]	//11 - Relogio da Marcacao
			( cAlias )->( &( cPrefixo+"PROCES"	) )	:= aMarcacoes[ nCount , AMARC_PROCESSO	] 	//18 - Processo
			( cAlias )->( &( cPrefixo+"ROTEIR"  ) )	:= aMarcacoes[ nCount , AMARC_ROTEIRO	] 	//19 - Roteiro
			( cAlias )->( &( cPrefixo+"PERIODO" ) )	:= aMarcacoes[ nCount , AMARC_PERIODO	] 	//20 - Periodo
			( cAlias )->( &( cPrefixo+"NUMPAG"  ) )	:= aMarcacoes[ nCount , AMARC_NUM_PAGTO	] 	//21 - NumPag
			( cAlias )->( &( cPrefixo+"DEPTO"   ) )	:= aMarcacoes[ nCount , AMARC_DEPTO		] 	//22 - Depto
			( cAlias )->( &( cPrefixo+"POSTO"   ) )	:= aMarcacoes[ nCount , AMARC_POSTO		] 	//23 - Posto
			( cAlias )->( &( cPrefixo+"CODFUNC" ) )	:= aMarcacoes[ nCount , AMARC_CODFUNC	] 	//24 - Cod. Func.
			( cAlias )->( &( cPrefixo+"DATAAPO" ) )	:= aMarcacoes[ nCount , AMARC_DATAAPO	] 	//25 - Data de Apontamento
						
		#ELSE
			IF (;
					( lAddNew );
					.or.;
					( lExInAs400 );
				)
				( cAlias )->( &( cPrefixo+"FILIAL"  ) )	:= cFil
				( cAlias )->( &( cPrefixo+"MAT"	    ) )	:= cMat
				( cAlias )->( &( cPrefixo+"DATA"    ) )	:= aMarcacoes[ nCount , AMARC_DATA    	]	//01 - Data da Marcacao
				( cAlias )->( &( cPrefixo+"HORA"    ) )	:= aMarcacoes[ nCount , AMARC_HORA    	]	//02 - Hora da Marcacao
				( cAlias )->( &( cPrefixo+"FLAG"    ) )	:= aMarcacoes[ nCount , AMARC_FLAG    	]	//04 - Flag (Origem) da Marcacao
				( cAlias )->( &( cPrefixo+"FUNCAO"  ) )	:= aMarcacoes[ nCount , AMARC_FUNCAO	]	//07 - Funcao do Relogio
				( cAlias )->( &( cPrefixo+"GIRO"    ) )	:= aMarcacoes[ nCount , AMARC_GIRO    	]	//08 - Giro do Relogio
				( cAlias )->( &( cPrefixo+"CC"      ) )	:= aMarcacoes[ nCount , AMARC_CC      	]	//09 - Centro de Custo da Marcacao
				( cAlias )->( &( cPrefixo+"RELOGIO" ) )	:= aMarcacoes[ nCount , AMARC_RELOGIO 	]	//11 - Relogio da Marcacao
				( cAlias )->( &( cPrefixo+"PROCES"	) )	:= aMarcacoes[ nCount , AMARC_PROCESSO  ] 	//18 - Processo
				( cAlias )->( &( cPrefixo+"ROTEIR"  ) )	:= aMarcacoes[ nCount , AMARC_ROTEIRO	] 	//19 - Roteiro
				( cAlias )->( &( cPrefixo+"PERIODO" ) )	:= aMarcacoes[ nCount , AMARC_PERIODO	] 	//20 - Periodo
				( cAlias )->( &( cPrefixo+"NUMPAG"  ) )	:= aMarcacoes[ nCount , AMARC_NUM_PAGTO	] 	//21 - NumPag
				( cAlias )->( &( cPrefixo+"DEPTO"   ) )	:= aMarcacoes[ nCount , AMARC_DEPTO		] 	//22 - Depto
				( cAlias )->( &( cPrefixo+"POSTO"   ) )	:= aMarcacoes[ nCount , AMARC_POSTO		] 	//23 - Posto
				( cAlias )->( &( cPrefixo+"CODFUNC" ) )	:= aMarcacoes[ nCount , AMARC_CODFUNC	] 	//24 - Cod. Func. 
				( cAlias )->( &( cPrefixo+"DATAAPO" ) )	:= aMarcacoes[ nCount , AMARC_DATAAPO	] 	//25 - Data de Apontamento
			
							
			Else
				cQryUpdate := "UPDATE "
				IF ( lExInAs400 )
					cQryUpdate += _cDataBase+"/"+cTableName
				Else
					cQryUpdate += cTableName
				EndIF	
				cQryUpdate += " SET "
				cQryUpdate += cPrefixo +"FILIAL='"	+ cFil + "'"
				cQryUpdate += ", "
				cQryUpdate += cPrefixo +"MAT='"		+ cMat + "'"
				cQryUpdate += ", "
				cQryUpdate += cPrefixo +"DATA='"	+ Dtos( aMarcacoes[ nCount , AMARC_DATA ] ) + "'"
				cQryUpdate += ", "
				cQryUpdate += cPrefixo +"HORA="		+ Str(  aMarcacoes[ nCount , AMARC_HORA ] , aTamHora[1] , aTamHora[2] )
				cQryUpdate += ", "
				cQryUpdate += cPrefixo +"FLAG='"	+ aMarcacoes[ nCount , AMARC_FLAG    	] + "'"
				cQryUpdate += ", "
				cQryUpdate += cPrefixo +"FUNCAO='"	+ aMarcacoes[ nCount , AMARC_FUNCAO		] + "'"
				cQryUpdate += ", "
				cQryUpdate += cPrefixo +"GIRO='"	+ aMarcacoes[ nCount , AMARC_GIRO   	] + "'"
				cQryUpdate += ", "
				cQryUpdate += cPrefixo +"CC='"		+ aMarcacoes[ nCount , AMARC_CC      	] + "'"
				cQryUpdate += ", "
				cQryUpdate += cPrefixo +"RELOGIO='"	+ aMarcacoes[ nCount , AMARC_RELOGIO	] + "'"
				cQryUpdate += ", "				
				cQryUpdate += cPrefixo+"PROCES"		+ aMarcacoes[ nCount , AMARC_PROCESSO	] + "'"	
				cQryUpdate += ", "				
				cQryUpdate += cPrefixo+"ROTEIR"     + aMarcacoes[ nCount , AMARC_ROTEIRO	] + "'"
				cQryUpdate += ", "				
				cQryUpdate += cPrefixo+"PERIODO"    + aMarcacoes[ nCount , AMARC_PERIODO	] + "'"
				cQryUpdate += ", "				
				cQryUpdate += cPrefixo+"NUMPAG"     + aMarcacoes[ nCount , AMARC_NUM_PAGTO	] + "'"
				cQryUpdate += ", "				
				cQryUpdate += cPrefixo+"DEPTO"      + aMarcacoes[ nCount , AMARC_DEPTO		] + "'"
				cQryUpdate += ", "				
				cQryUpdate += cPrefixo+"POSTO"      + aMarcacoes[ nCount , AMARC_POSTO		] + "'"
				cQryUpdate += ", "				
				cQryUpdate += cPrefixo+"CODFUNC"    + aMarcacoes[ nCount , AMARC_CODFUNC	] + "'"            
				cQryUpdate += ", "				
				cQryUpdate += cPrefixo+"DATAAPO"    + aMarcacoes[ nCount , AMARC_DATAAPO	] + "'"
				
		
			EndIF
		#ENDIF
	ElseIF ( lSubsDtHr )
		#IFNDEF TOP
			( cAlias )->( &( cPrefixo+"DATA"    ) )	:= aMarcacoes[ nCount , AMARC_DATA    	]	//01 - Data da Marcacao
			( cAlias )->( &( cPrefixo+"HORA"    ) )	:= aMarcacoes[ nCount , AMARC_HORA    	]	//02 - Hora da Marcacao
		#ELSE
			IF ( lExInAs400 )
				( cAlias )->( &( cPrefixo+"DATA"    ) )	:= aMarcacoes[ nCount , AMARC_DATA    	]	//01 - Data da Marcacao
				( cAlias )->( &( cPrefixo+"HORA"    ) )	:= aMarcacoes[ nCount , AMARC_HORA    	]	//02 - Hora da Marcacao
			Else
				cQryUpdate := "UPDATE "
				IF ( lExInAs400 )
					cQryUpdate += _cDataBase+"/"+cTableName
				Else
					cQryUpdate += cTableName
				EndIF	
				cQryUpdate += " SET "
				cQryUpdate += cPrefixo +"DATA='"	+ Dtos( aMarcacoes[ nCount , AMARC_DATA ] ) + "'"
				cQryUpdate += ", "
				cQryUpdate += cPrefixo +"HORA="		+ Str(  aMarcacoes[ nCount , AMARC_HORA ] , aTamHora[1] , aTamHora[2] )
			EndIF
		#ENDIF
	EndIF
	#IFNDEF TOP
		( cAlias )->( &( cPrefixo+"ORDEM"   ) )	:= aMarcacoes[ nCount , AMARC_ORDEM   	]	//03 - Ordem da Marcacao
		( cAlias )->( &( cPrefixo+"TURNO"   ) )	:= aMarcacoes[ nCount , AMARC_TURNO		]	//06 - Turno da Marcacao
		( cAlias )->( &( cPrefixo+"APONTA"  ) )	:= aMarcacoes[ nCount , AMARC_APONTA  	]	//10 - Flag de Marcacao Apontada
		( cAlias )->( &( cPrefixo+"TPMARCA" ) )	:= aMarcacoes[ nCount , AMARC_TIPOMARC	]	//12 - Tipo da Marcacao
		( cAlias )->( &( cPrefixo+"PAPONTA" ) )	:= aMarcacoes[ nCount , AMARC_PERAPONTA	]	//15 - String de Data com o Periodo de Apontamento
		( cAlias )->( &( cPrefixo+"FLAG"    ) )	:= aMarcacoes[ nCount , AMARC_FLAG    	]	//04 - Flag (Origem) da Marcacao 
		( cAlias )->( &( cPrefixo+"DATAAPO" ) )	:= aMarcacoes[ nCount , AMARC_DATAAPO	] 	//25 - Data de Apontamento			
		
	#ELSE
		IF (;
				( lAddNew );
				.or.;
				( lExInAs400 );
			)
			( cAlias )->( &( cPrefixo+"ORDEM"   ) )	:= aMarcacoes[ nCount , AMARC_ORDEM   	]	//03 - Ordem da Marcacao
			( cAlias )->( &( cPrefixo+"TURNO"   ) )	:= aMarcacoes[ nCount , AMARC_TURNO		]	//06 - Turno da Marcacao
			( cAlias )->( &( cPrefixo+"APONTA"  ) )	:= aMarcacoes[ nCount , AMARC_APONTA  	]	//10 - Flag de Marcacao Apontada
			( cAlias )->( &( cPrefixo+"TPMARCA" ) )	:= aMarcacoes[ nCount , AMARC_TIPOMARC	]	//12 - Tipo da Marcacao
			( cAlias )->( &( cPrefixo+"PAPONTA" ) )	:= aMarcacoes[ nCount , AMARC_PERAPONTA	]	//15 - String de Data com o Periodo de Apontamento
			( cAlias )->( &( cPrefixo+"FLAG"    ) )	:= aMarcacoes[ nCount , AMARC_FLAG    	]	//04 - Flag (Origem) da Marcacao  
			( cAlias )->( &( cPrefixo+"DATAAPO" ) )	:= aMarcacoes[ nCount , AMARC_DATAAPO	] 	//25 - Data de Apontamento
							
		Else
			IF Empty( cQryUpdate )
				cQryUpdate := "UPDATE "
				IF ( lExInAs400 )
					cQryUpdate += _cDataBase+"/"+cTableName
				Else
					cQryUpdate += cTableName
				EndIF
				cQryUpdate += " SET "
			Else
				cQryUpdate += ", "
			EndIF
			cQryUpdate += cPrefixo +"ORDEM = '"	+ aMarcacoes[ nCount , AMARC_ORDEM   	] + "'"
			cQryUpdate += ", "
			cQryUpdate += cPrefixo +"TURNO= '"	+ aMarcacoes[ nCount , AMARC_TURNO		] + "'"
			cQryUpdate += ", "
			cQryUpdate += cPrefixo +"APONTA = '"	+ aMarcacoes[ nCount , AMARC_APONTA  	] + "'"
			cQryUpdate += ", "
			cQryUpdate += cPrefixo +"TPMARCA = '"	+ aMarcacoes[ nCount , AMARC_TIPOMARC	] + "'"
			cQryUpdate += ", "
			cQryUpdate += cPrefixo +"PAPONTA = '"	+ aMarcacoes[ nCount , AMARC_PERAPONTA	] + "'"
			cQryUpdate += ", "
			cQryUpdate += cPrefixo +"FLAG = '"	+ aMarcacoes[ nCount , AMARC_FLAG    	] + "'"     
			cQryUpdate += ", "				
			cQryUpdate += cPrefixo+"DATAAPO = '"    + Dtos(aMarcacoes[ nCount , AMARC_DATAAPO	]) + "'"
			
		EndIF
	#ENDIF
	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	ЁDestrava o Registro                 						   Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	#IFNDEF TOP
		( cAlias )->( MsUnlock() )
	#ELSE
		IF (;
				( lAddNew );
				.or.;
				( lExInAs400 );
			)
			( cAlias )->( MsUnlock() )
		Else
			/*/
			здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			ЁSubstitui os valores                						   Ё
			юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			IF !Empty( cQryUpdate )
				cQryUpdate += " WHERE " 
				cQryUpdate += cCpoRecno + "=" + Str( aMarcacoes[ nCount , AMARC_RECNO ] , 10 , 0 )
				TcSqlExec( cQryUpdate )
				cQryUpdate := ""
			EndIF
		EndIF
	#ENDIF
	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	ЁGrava o Recno no aMarcacoes         						   Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	IF (;
			( lAddNew );
			.or.;
			Empty( aMarcacoes[ nCount , AMARC_RECNO ] );
		)
		aMarcacoes[ nCount , AMARC_RECNO ] := ( cAlias )->( Recno() )						//05 - Recno
	EndIF
	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	ЁlAddNew eh Setada como .F.          						   Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	lAddNew := .F.
Next nCount
( cAlias )->( dbSetOrder( aArea[ 02 ] ) )

cFilAnt := cSvFilAnt

Return( NIL )

/*/
зддддддддддбддддддддддддбдддддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁGetPerApontaЁ Autor Ё Marinaldo de Jesus  Ё Data Ё27/09/2001Ё
цддддддддддеддддддддддддадддддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁListBox com a Selecao dos Periodos de Apontamento           Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   ЁGetPerAponta( nNumPerAnt , cFil , cMat , lReturn , uMvPar )	Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGenerico                                                    Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁSe Validacao .T. c.c. Array com os Periodos de Apontamento  Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁnNumPerAnt	- Numero de Periodos a Serem Listados			Ё
Ё          ЁcFil		- Filial do Funcionario							Ё
Ё          ЁcMat		- Matricula do Funcionario						Ё
Ё          ЁlReturn		- Retorno Logico Quando Validacao				Ё
Ё          ЁuMvPar	    - Opcional.Variavel Receptora do Valor da Opcao Ё  
Ё          Ё              Escolhida.                                    Ё  
Ё          ЁaPerSPO     - Periodos do SPO                       		Ё  
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function GetPerAponta( nNumPerAnt , cFil , cMat , lReturn , lSelectOne , uMvPar , aPerSPO )

Local aAreaSRA		:= {}
Local aPeriodos		:= {}
Local aShowPer		:= {}
Local bAscPer		:= { |x| x[1] == dPerIni .and. x[2] == dPerFim }
Local cMvParDef		:= ""
Local dAdmissa		:= Ctod("//")
Local dPerIni		:= Ctod("//")
Local dPerFim		:= Ctod("//")
Local lItera		:= .T.
Local lFunc			:= .T.
Local lMvPar		:= !( uMvPar == NIL )
Local lPerCompleto	:= .F.
Local nPer			:= 0
Local nPerSPO		:= 0
Local nItera		:= 0

DEFAULT nNumPerAnt	:= 12
DEFAULT lReturn		:= .T.
DEFAULT lSelectOne	:= .T.
DEFAULT aPerSPO		:= {}

uMvPar	:= IF( lReturn , IF( !lMvPar , &( Alltrim( ReadVar() ) ) , uMvPar ) , "" )

IF ( lReturn )
	CursorWait()
EndIF	

IF ( lFunc := ( cFil != NIL .and. cMat != NIL ) )
	aAreaSRA := SRA->( GetArea() )
	IF !( SRA->( RA_FILIAL+RA_MAT == cFil+cMat ) )
		SRA->( dbSetOrder( RetOrdem("SRA") ) )
		SRA->( dbSeek( cFil + cMat ) )
	EndIF
	dAdmissa := fDtaAdmis()
	SRA->( dbSetOrder( aAreaSRA[ 02 ] ) )
EndIF		

IF ( lMvPar )
	aAdd( aPeriodos, { Stod( SubStr( uMvPar , 1 , 8 ) ) , Stod( SubStr( uMvPar , 9 , 8 ) ) } )
EndIF

IF !GetPonMesDat( @dPerIni , @dPerFim , cFil )
	PerAponta( @dPerIni , @dPerFim , NIL , NIL , cFil ,  .F. , @lPerCompleto )
EndIF

IF ( aScan( aPeriodos , bAscPer ) == 0 )
	aAdd( aPeriodos, { dPerIni , dPerFim } )
EndIF

IF ( ( nPerSPO := Len( aPerSPO ) ) > 0 )
	aSort( aPerSPO , NIL , NIL , { |x,y| Dtos(x[1])+Dtos(x[2]) > Dtos(y[1])+Dtos(y[2]) } )
EndIF
	
While ( lItera )

	++nItera
    
	IF ( lItera := ( --nNumPerAnt > 0 ) )
		IF ( nPerSPO == 0 )
			IF !( lItera := !( IF( lFunc , --dPerIni < dAdmissa , ( --dPerIni , .F. ) ) ) )
				Exit
			EndIF
			IF ( !( lPerCompleto ) .and. ( nItera == 1 ) )
				PerAponta( dPerIni , dPerFim , dPerIni , NIL , cFil , .F. , @lPerCompleto )
			EndIF
			IF ( lPerCompleto )
				PonIncDate( @dPerIni , @dPerFim )
			Else
				PerAponta( @dPerIni , @dPerFim , dPerIni , NIL , cFil , .T. , NIL )
			EndIF
		Else
			IF !( lItera := ( ++nPer <= nPerSPO ) )
				Exit
			EndIF	
			dPerIni := aPerSPO[ nPer , 01 ]
			dPerFim := aPerSPO[ nPer , 02 ]
			IF !( lItera := !( IF( lFunc , dPerIni < dAdmissa , .F. ) ) )
				Exit
			EndIF
		EndIF
		IF ( aScan( aPeriodos , bAscPer ) == 0 )
			aAdd( aPeriodos, { dPerIni , dPerFim } )
		EndIF
	EndIF

End While

IF !Empty( aPeriodos )
	aSort( aPeriodos , NIL , NIL , { |x,y| Dtos(x[1])+Dtos(x[2]) < Dtos(y[1])+Dtos(y[2]) } )
	aEval( aPeriodos , { |x| aAdd( aShowPer , Dtoc(x[1])+ STR0067 + Dtoc(x[2]) ) , ( cMvParDef += Dtos(x[1])+Dtos(x[2]) ) } )
EndIF

IF ( lReturn )
	CursorArrow()
	IF f_Opcoes( @uMvPar , STR0100 , aShowPer , cMvParDef , 12 , 49 , lSelectOne , 16 , ( 16 * nNumPerAnt ) ) //Periodos de Apontamento
		IF ( !Empty( uMvPar := StrTran( uMvPar , "*" , "" ) ) .and. !( lMvPar ) )
			&( ReadVar() ) := uMvPar
		EndIF
	EndIF	
EndIF

Return( IF( lReturn , lReturn , aPeriodos ) )

/*/
зддддддддддбддддддддддддбддддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁRetSerIni   ЁAutor Ё Marinaldo de Jesus   Ё Data Ё26/06/2003Ё
цддддддддддеддддддддддддаддддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁRetorna Numero Serial p/ o Inicio do Periodo de Apontamento Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>                   				Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁPonto Eletronico                                            Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁnSerIni                            							Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function RetSerIni(	aTabCalend	,;	//01 -> Copia do Calendario de Marcacoes
					aTabPadrao	,;	//02 -> Tabela de Horario Padrao
					dPerIni		,;	//03 -> Inicio do Periodo de Apontamento
					dPerFim		,; 	//04 -> Final do Periodo de Apontamento
					cTno		,;	//05 -> Turno de Trabalho
					cSeq		,;	//06 -> Sequencia de Turno
					cFil     	,;	//07 -> Filial do Funcionario
					cMat   		,;	//08 -> Matricula do Funcionario
					cCc   		,;	//09 -> Centro de Custo do Funcionario
					lMarcOrder	,;	//10 -> Marcacoes Sendo carregadas pela Ordem
					lCalendFunc  ;	//11 -> Se o Calendario Esta Sendo Montado por funcionario
				   )

Local nHoursDay	:= 0
Local nHoursTab := 0

Local aSvTabsCal
Local dPriDataApo
Local nSerIni
Local nDays
Local nLenCalend

DEFAULT aTabCalend		:= {}
DEFAULT aTabPadrao		:= {}
DEFAULT dPerIni			:= Ctod("//")
DEFAULT dPerFim			:= Ctod("//")
DEFAULT lCalendFunc		:= .T.
IF ( lCalendFunc )
	DEFAULT cFil		:= SRA->RA_FILIAL
	DEFAULT cMat		:= SRA->RA_MAT
	DEFAULT cTno		:= SRA->RA_TNOTRAB
	DEFAULT cSeq		:= SRA->RA_SEQTURN
	DEFAULT cCc			:= SRA->RA_CC
EndIF	
DEFAULT lMarcOrder	:= .F.

Begin Sequence

	/*/
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	ЁVerifica se o Calendario foi passado como parametro		  Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	IF Empty( aTabCalend )
		IF ( Empty( dPerIni ) .or. Empty( dPerFim ) )
		    //-- Para periodo de funcionario considera o cadastro de periodos (RCH)
			IF ( lCalendFunc )
				If Type("oPeriodo") == "U"
					SetMemVar("oPeriodo" , RHPERIODO():New() , .T. , .T. )
				EndIf
				oPeriodo:cProcesso := SRA->RA_PROCES
				oPeriodo:GetPer()
				IF !( lGetMarcOk :=oPeriodo:lFound)
					Break
				EndIF
	
				dPerIni := oPeriodo:dDataIni
				dPerFim := oPeriodo:dDataFim
	
            Else
                //-- Para periodo de turno considera o cadastro de periodos (SPO)
				IF !( PerAponta( @dPerIni , @dPerFim , NIL , NIL , cFil ) )
					Break
				EndIF
			EndIF				
		EndIF
        
        
        /*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Salva o Conteudo do Calendario por Turno        			  Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		aSvTabsCal := GetTabCal()
		IF !(;
				CriaCalend(	dPerIni 	,;	//01 -> Data Inicial do Calendario
						   	dPerFim		,;	//02 -> Data Final do Calendario
					   		cTno		,;	//03 -> Turno de Trabalho
					   		cSeq		,;	//04 -> Sequencia de Turno
					   		@aTabPadrao	,;	//05 -> Tabela de Horario Padrao
					   		@aTabCalend	,;	//06 -> Calendario de Marcacoes
					   		cFil     	,;	//07 -> Filial do Funcionario
					   		cMat   		,;	//08 -> Matricula do Funcionario
					   		cCc   		,;	//09 -> Centro de Custo do Funcionario
							NIL			,;	//10 -> Array com as Trocas de Turno
							NIL			,;	//11 -> Array com Todas as Excecoes do Periodo
							NIL			,;	//12 -> Se executa Query para a Montagem da Tabela Padrao
							.F.			,;	//13 -> Se executa a funcao se sincronismo do calendario
							NIL			 ;	//14 -> Se Forca a Criacao de Novo Calendario
					  	  );
			)					  	  
			Break
		EndIF					  	  
	ElseIF ( Empty( dPerIni ) .or. Empty( dPerFim ) )
		dPerIni			:= aTabCalend[ 01 , CALEND_POS_DATA ]
		dPerFim 		:= aTabCalend[  Len( aTabCalend ) , CALEND_POS_DATA_APO ]
	EndIF
	
	/*/
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	ЁDefine o Numero Serial correspondente ao primeiro dia do PeriЁ
	Ёodo de Apontamento											  Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	nSerIni := __fDHtoNS(aTabCalend[ 01 , CALEND_POS_LIM_MARCACAO , 01 ], aTabCalend[ 01, CALEND_POS_LIM_MARCACAO , 02 ] )
	
	/*/
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	ЁQuando Primeiro Dia da Tabela Tiver o Horario Zerado DecremenЁ
	Ёta um Dia													  Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	dPriDataApo := aTabCalend[ 01 , CALEND_POS_DATA_APO ]
	aEval( aTabCalend ,{ |x|;
					 	 	 IF( x[CALEND_POS_DATA_APO] == dPriDataApo ,;
					 	 	 		 nHoursDay := SomaHoras( nHoursDay , x[CALEND_POS_HRS_TRABA] ),;
					 	 	 		 nHoursTab := SomaHoras( nHoursTab , x[CALEND_POS_HRS_TRABA] );
					 	 	 	);
					  };
		  )
	IF ( Empty( nHoursDay ) .and. !Empty( nHoursTab := SomaHoras( nHoursDay , nHoursTab ) ) )
		/*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		ЁMonta Novo Periodo de Apontamento                   	  	  Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		nDays	:= ( ( dPerFim - dPerIni ) + 1 )
		dPerFim	:= ( aTabCalend[ 01 , CALEND_POS_DATA ] - 1 )
		dPerIni := ( dPerFim - nDays )
        /*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Salva o Conteudo do Calendario por Turno        			  Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		IF Empty( aSvTabsCal )
			aSvTabsCal := GetTabCal()
		EndIF
		/*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		ЁCria Calendario com o Ultimo dia do Periodo Anterior         Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		IF CriaCalend(	dPerFim		,;	//01 -> Data Inicial do Calendario
		   		   		dPerFim		,;	//02 -> Data Final do Calendario
						cTno		,;	//03 -> Turno de Trabalho
						cSeq		,;	//04 -> Sequencia de Turno
						@aTabPadrao	,;	//05 -> Tabela de Horario Padrao
						@aTabCalend	,;	//06 -> Calendario de Marcacoes
						cFil     	,;	//07 -> Filial do Funcionario
						cMat   		,;	//08 -> Matricula do Funcionario
						cCc   		,;	//09 -> Centro de Custo do Funcionario
						NIL			,;	//10 -> Array com as Trocas de Turno
						NIL			,;	//11 -> Array com Todas as Excecoes do Periodo
						NIL			,;	//12 -> Se executa Query para a Montagem da Tabela Padrao
						.F.			,;	//13 -> Se executa a funcao se sincronismo do calendario
						NIL			 ;	//14 -> Se Forca a Criacao de Novo Calendario
					  )
			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			ЁProcura o Proximo Dia com Horario na Tabela         	  	  Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			While ( nHoursDay := 0 , aEval( aTabCalend , { |x| nHoursDay := SomaHoras( nHoursDay , x[CALEND_POS_HRS_TRABA] ) } ) , nHoursDay == 0 )
				IF ( ( --dPerFim ) < dPerIni )
					Exit
				EndIF
				aTabCalend := {}
				IF !CriaCalend(	dPerFim		,;	//01 -> Data Inicial do Calendario
		   		    			dPerFim		,;	//02 -> Data Final do Calendario
					  			cTno		,;	//03 -> Turno de Trabalho
								cSeq		,;	//04 -> Sequencia de Turno
								@aTabPadrao	,;	//05 -> Tabela de Horario Padrao
								@aTabCalend	,;	//06 -> Calendario de Marcacoes
								cFil     	,;	//07 -> Filial do Funcionario
								cMat   		,;	//08 -> Matricula do Funcionario
								cCc   		,;	//09 -> Centro de Custo do Funcionario
								NIL			,;	//10 -> Array com as Trocas de Turno
								NIL			,;	//11 -> Array com Todas as Excecoes do Periodo
								NIL			,;	//12 -> Se executa Query para a Montagem da Tabela Padrao
								.F.			,;	//13 -> Se executa a funcao se sincronismo do calendario
								NIL			 ;	//14 -> Se Forca a Criacao de Novo Calendario
					  		)
					Exit
				EndIF					  		
			End While
			IF Empty( nHoursDay )
				/*/
				зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				ЁSe nao Achou Horas na Tabela Decrementa o Primeiro Serial	  Ё
				юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
				--nSerIni
			Else
				/*/
				зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				ЁCaso Contrario Considera como Primeira Marcacao a ultima  MarЁ
				Ёcacao do Dia Anterior(Respeitando o HorMais) somado de um  miЁ
				Ёnuto.  													  Ё
				юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
				nLenCalend	:= Len( aTabCalend )
				nSerIni 	:= __fDHtoNS( aTabCalend[ nLenCalend , CALEND_POS_LIM_MARCACAO , 01 ] , SomaHoras( aTabCalend[ nLenCalend , CALEND_POS_LIM_MARCACAO , 02 ] , 0.01 ) )
			EndIF
		Else
			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			ЁSe nao Achou Horas na Tabela Decrementa o Primeiro Serial	  Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			--nSerIni
		EndIF	
	ElseIF Empty( nHoursTab )
		/*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		ЁNeste Caso a Tabela nao Tem Horario e o Serial deve ser DecreЁ
		Ёmentado													  Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		--nSerIni
	EndIF

End Sequence

/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Restaura o Conteudo do Calendario por Turno        		  Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
IF !Empty( aSvTabsCal )
	SetTabCal( aSvTabsCal )
EndIF

/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
ЁVerifica se Deve Decrementar o Serial Obtido				  Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Return( IF( lMarcOrder ,  --nSerIni , nSerIni ) )

/*/
зддддддддддбддддддддддддбддддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁRetSerFim   ЁAutor Ё Marinaldo de Jesus   Ё Data Ё11/10/2001Ё
цддддддддддеддддддддддддаддддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁRetorna Numero Serial para o Fim do Periodo de Apontamento  Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>                   				Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁPonto Eletronico                                            Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁnSerFim                            							Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function RetSerFim(	aTabCalend	,;	//01 -> Copia do Calendario de Marcacoes
					aTabPadrao	,;	//02 -> Tabela de Horario Padrao
					dPerIni		,;	//03 -> Inicio do Periodo de Apontamento
					dPerFim		,; 	//04 -> Final do Periodo de Apontamento
					cTno		,;	//05 -> Turno de Trabalho
					cSeq		,;	//06 -> Sequencia de Turno
					cFil     	,;	//07 -> Filial do Funcionario
					cMat   		,;	//08 -> Matricula do Funcionario
					cCc   		,;	//09 -> Centro de Custo do Funcionario
					lMarcOrder	,;	//10 -> Marcacoes Sendo carregadas pela Ordem
					lCalendFunc  ;	//11 -> Se o Calendario Esta Sendo Montado por funcionario
				   )

Local nHoursDay	:= 0
Local nHoursTab := 0

Local aSvTabsCal
Local dUltDataApo
Local nSerFim
Local nDays

DEFAULT aTabCalend	:= {}
DEFAULT aTabPadrao	:= {}
DEFAULT dPerIni		:= Ctod("//")
DEFAULT dPerFim		:= Ctod("//")
DEFAULT cFil		:= SRA->RA_FILIAL
DEFAULT lCalendFunc	:= .T.
IF ( lCalendFunc )
	DEFAULT cMat		:= SRA->RA_MAT
	DEFAULT cTno		:= SRA->RA_TNOTRAB
	DEFAULT cSeq		:= SRA->RA_SEQTURN
	DEFAULT cCc			:= SRA->RA_CC
EndIF
DEFAULT lMarcOrder	:= .F.

Begin Sequence

	/*/
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	ЁVerifica se o Calendario foi passado como parametro		  Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	IF Empty( aTabCalend )
	 		//-- Para periodo de funcionario considera o cadastro de periodos (RCH)
			IF ( lCalendFunc )
				If Type("oPeriodo") == "U"
					SetMemVar("oPeriodo" , RHPERIODO():New() , .T. , .T. )
				EndIf
				oPeriodo:cProcesso := SRA->RA_PROCES
				oPeriodo:GetPer()
				IF !( lGetMarcOk :=oPeriodo:lFound)
					Break
				EndIF
	
				dPerIni := oPeriodo:dDataIni
				dPerFim := oPeriodo:dDataFim
	
            Else
                //-- Para periodo de turno considera o cadastro de periodos (SPO)
				IF !( PerAponta( @dPerIni , @dPerFim , NIL , NIL , cFil ) )
					Break
				EndIF
			EndIF
        /*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Salva o Conteudo do Calendario por Turno        			  Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		aSvTabsCal := GetTabCal()
		IF !(;
				CriaCalend(	dPerIni 	,;	//01 -> Data Inicial do Calendario
						   	dPerFim		,;	//02 -> Data Final do Calendario
				   			cTno		,;	//03 -> Turno de Trabalho
					   		cSeq		,;	//04 -> Sequencia de Turno
					   		@aTabPadrao	,;	//05 -> Tabela de Horario Padrao
					   		@aTabCalend	,;	//06 -> Calendario de Marcacoes
					   		cFil     	,;	//07 -> Filial do Funcionario
					   		cMat   		,;	//08 -> Matricula do Funcionario
				   			cCc   		,;	//09 -> Centro de Custo do Funcionario
							NIL			,;	//10 -> Array com as Trocas de Turno
							NIL			,;	//11 -> Array com Todas as Excecoes do Periodo
							NIL			,;	//12 -> Se executa Query para a Montagem da Tabela Padrao
							.F.			,;	//13 -> Se executa a funcao se sincronismo do calendario
							NIL			 ;	//14 -> Se Forca a Criacao de Novo Calendario
					  	  );
			)
			Break					  	  
		EndIF
	ElseIF ( Empty( dPerIni ) .or. Empty( dPerFim ) )
		dPerIni			:= aTabCalend[ 01 , CALEND_POS_DATA ]
		dPerFim			:= aTabCalend[ Len( aTabCalend ) , CALEND_POS_DATA_APO ]
	EndIF
	
	/*/
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	ЁDefine o Numero Serial correspondente ao ultimo dia do  PerioЁ
	Ёdo de Apontamento											  Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	nSerFim := __fDHtoNS(aTabCalend[Len(aTabCalend),CALEND_POS_LIM_MARCACAO,1] , aTabCalend[Len(aTabCalend),CALEND_POS_LIM_MARCACAO,2] )
	
	/*/
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	ЁQuando ultimo Dia da Tabela Tiver o Horario Zerado Soma  MaisЁ
	Ёum Dia														  Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	dUltDataApo := aTabCalend[Len(aTabCalend),CALEND_POS_DATA_APO]
	aEval( aTabCalend ,{ |x|;
					 	 	 IF( x[CALEND_POS_DATA_APO] == dUltDataApo ,;
					 	 	 		 nHoursDay := SomaHoras( nHoursDay , x[CALEND_POS_HRS_TRABA] ),;
					 	 	 		 nHoursTab := SomaHoras( nHoursTab , x[CALEND_POS_HRS_TRABA] );
					 	 	 	);
					  };
		  )
	IF ( Empty( nHoursDay ) .and. !Empty( nHoursTab := SomaHoras( nHoursDay , nHoursTab ) ) )
		/*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		ЁMonta Novo Periodo de Apontamento                   	  	  Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		nDays	:= ( ( dPerFim - dPerIni ) + 1 )
		dPerIni := ( aTabCalend[ Len(aTabCalend) , CALEND_POS_DATA ]  + 1 )
		dPerFim := ( dPerIni + nDays )
        /*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Salva o Conteudo do Calendario por Turno        			  Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		IF Empty( aSvTabsCal )
			aSvTabsCal := GetTabCal()
		EndIF	
		/*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		ЁCria Calendario com o Primeiro dia do Proximo Periodo de AponЁ
		Ёtamento													  Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		IF CriaCalend(	dPerIni		,;	//01 -> Data Inicial do Calendario
		   		   		dPerIni		,;	//02 -> Data Final do Calendario
						cTno		,;	//03 -> Turno de Trabalho
						cSeq		,;	//04 -> Sequencia de Turno
						@aTabPadrao	,;	//05 -> Tabela de Horario Padrao
						@aTabCalend	,;	//06 -> Calendario de Marcacoes
						cFil     	,;	//07 -> Filial do Funcionario
						cMat   		,;	//08 -> Matricula do Funcionario
						cCc   		,;	//09 -> Centro de Custo do Funcionario
						NIL			,;	//10 -> Array com as Trocas de Turno
						NIL			,;	//11 -> Array com Todas as Excecoes do Periodo
						NIL			,;	//12 -> Se executa Query para a Montagem da Tabela Padrao
						.F.			,;	//13 -> Se executa a funcao se sincronismo do calendario
						NIL			 ;	//14 -> Se Forca a Criacao de Novo Calendario
					  )
			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			ЁProcura o Proximo Dia com Horario na Tabela         	  	  Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			While ( nHoursDay := 0 , aEval( aTabCalend , { |x| nHoursDay := SomaHoras( nHoursDay , x[CALEND_POS_HRS_TRABA] ) } ) , nHoursDay == 0 )
				IF ( ( ++dPerIni ) > dPerFim )
					Exit
				EndIF
				aTabCalend := {}
				IF !CriaCalend(	dPerIni		,;	//01 -> Data Inicial do Calendario
		   		    			dPerIni		,;	//02 -> Data Final do Calendario
					  			cTno		,;	//03 -> Turno de Trabalho
								cSeq		,;	//04 -> Sequencia de Turno
								@aTabPadrao	,;	//05 -> Tabela de Horario Padrao
								@aTabCalend	,;	//06 -> Calendario de Marcacoes
								cFil     	,;	//07 -> Filial do Funcionario
								cMat   		,;	//08 -> Matricula do Funcionario
								cCc   		,;	//09 -> Centro de Custo do Funcionario
								NIL			,;	//10 -> Array com as Trocas de Turno
								NIL			,;	//11 -> Array com Todas as Excecoes do Periodo
								NIL			,;	//12 -> Se executa Query para a Montagem da Tabela Padrao
								.F.			,;	//13 -> Se executa a funcao se sincronismo do calendario
								NIL			 ;	//14 -> Se Forca a Criacao de Novo Calendario
					  		)
					Exit
				EndIF					  		
			End While
			IF Empty( nHoursDay )
				/*/
				зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				ЁSe nao Achou Horas na Tabela Incremente o Ultimo Serial	  Ё
				юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
				++nSerFim
			Else
				/*/
				зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				ЁCaso Contrario Considera como Ultima Marcacao a Primeira  MarЁ
				Ёcacao do Proximo Dia (Respeitando o HorMenos) subtraido de umЁ
				Ёminuto.													  Ё
				юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
				nSerFim := __fDHtoNS( aTabCalend[ 01 , CALEND_POS_LIM_MARCACAO , 01 ] , SubHoras( aTabCalend[ 01 , CALEND_POS_LIM_MARCACAO , 02 ] , 0.01 ) )
			EndIF
		Else
			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			ЁSe nao Achou Horas na Tabela Incremente o Ultimo Serial	  Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			++nSerFim
		EndIF	
	ElseIF Empty( nHoursTab )
		/*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		ЁNeste Caso a Tabela nao Tem Horario e o Serial deve ser increЁ
		Ёmentado													  Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		++nSerFim
	EndIF

End Sequence

/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Restaura o Conteudo do Calendario por Turno        		  Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
IF !Empty( aSvTabsCal )
	SetTabCal( aSvTabsCal )
EndIF
	
/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
ЁVerifica se Deve Incrementar o Serial Obtido				  Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Return( IF( lMarcOrder , ++nSerFim , nSerFim ) )

/*/
зддддддддддбдддддддддддддбдддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁPutMarcAuto  ЁAutorЁ Marinaldo de Jesus   Ё Data Ё13/08/2001Ё
цддддддддддедддддддддддддадддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁGerar Marcacoes Automaticas no Array aMarcacoes             Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<vide parametros formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGenerico                                                    Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁlAuto														Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<vide parametros formais>									Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function PutMarcAuto(	aTabCalend	,;
						aMarcacoes	,;
						dPerIni		,;
						dPerFim		,;
						cFil		,;
						lChkTables	,;
						lSobrepoe	,;
						aMarcNoGer   ;
					)
                    	
Local aCloneMarc	:= aClone( aMarcacoes )
Local aMAuto		:= {}
Local cCusto		:= SRA->RA_CC 
Local lSpaIsMemVar	:= .F.
Local lSr6IsMemVar	:= .F.

Local aTDia
Local aMDia
Local aTab_Marc
Local aFields  
Local aMarcGer  
Local aMarcDia		:= {}

Local cOrdem 
Local dDataApo
Local cMarcAut  
Local cNewMarcAut
Local cMarc 
Local cUltmarc
Local cTipMarcDia
Local cMarcsObriga
Local cMarcsEfe
Local cFilRegra
Local cFilTurno
Local cTpMarc
Local cPerAponta
Local cAutoSai
Local cUltOrdem 
Local dUltDataApo

Local dDtMarc 

Local lAuto
Local lInterv
Local lAleat
Local lAutomSM
Local lTrabFer
Local lMarcsObriga
Local lAutoSai
Local lCompletaMar

Local nY
Local nFornY
Local nTab
Local nLenTab
Local nMarc
Local nLenMarc
Local nOrdem
Local nDataApo
Local nForOrdem
Local nForDataApo
Local nField
Local nMarcsGer
Local nMarcsEfe
Local nLenMAuto
Local nMarcAut
Local nPosUltOrd 
Local nPosUltDataApo
Local nInterv
Local nHrTrab
Local nAleato
Local nPos
Local nMinuto
Local nSvRecno
 
DEFAULT aTabCalend	:= {}
DEFAULT aMarcacoes	:= {}   
DEFAULT aMarcNoGer	:= {}
DEFAULT dPerIni		:= Ctod("//")
DEFAULT dPerFim		:= Ctod("//")
DEFAULT cFil		:= cFilAnt 
DEFAULT lChkTables	:= .T.
DEFAULT lSobrepoe	:= .F.
DEFAULT lPnMcAut01	:= ExistBlock( "PNMCAUT01" )

IF ( Empty( dPerIni ) .or. Empty( dPerFim ) )
	If Type("oPeriodo") == "U"
		SetMemVar("oPeriodo" , RHPERIODO():New() , .T. , .T. )
	EndIf
	oPeriodo:cProcesso := SRA->RA_PROCES
	oPeriodo:GetPer()
	dPerIni := oPeriodo:dDataIni
	dPerFim := oPeriodo:dDataFim
EndIF

DEFAULT	_aSpaHeader		:= GdMontaHeader( @_nSpaHeader , NIL , NIL , "SPA" , NIL , .T. , .T. , .F. , .F. , .F. , .F. , .F. , .F. )
DEFAULT	_aSr6Header		:= GdMontaHeader( @_nSr6Header , NIL , NIL , "SR6" , NIL , .T. , .T. , .F. , .F. , .F. , .F. , .F. , .F. )

DEFAULT	_cSpaLastReg	:= "_cSpaLastReg"
DEFAULT _cSr6LastTno	:= "_cSr6LastTno"

DEFAULT _cSpceFuncao	:= Space( GetSx3Cache( "P8_FUNCAO " , "X3_TAMANHO" ) )
DEFAULT _cSpceGiro		:= Space( GetSx3Cache( "P8_GIRO   " , "X3_TAMANHO" ) )
DEFAULT _cSpceRelogi	:= Space( GetSx3Cache( "P8_RELOGIO" , "X3_TAMANHO" ) )

dUltDataApo	:= aTabCalend[ Len( aTabcalend ) , CALEND_POS_DATA_APO ]
nForDataApo	:= (dPerFim-dPerIni)
nLenTab		:= Len( aTabCalend )
nLenMarc	:= Len( aMarcacoes )
cFilRegra	:= xFilial( "SPA" , cFil )
cFilTurno	:= xFilial( "SR6" , cFil )
cPerAponta	:= Dtos( aTabCalend[ 01 , CALEND_POS_DATA ] )
cPerAponta	+= Dtos(dUltDataApo)
dDataApo	:= dPerIni
IF !( lChkTables )
	/*/
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Carrega Informacoes da Regra de Apontamento          	      Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	cMarcAut := StrTran( GetMemVar( "PA_MARCAUT" ) , "*" , "" )
	cMarcAut += IF( SubStr(cMarcAut,-1) != "-" .and. !Empty(cMarcAut) , "-" , "" )
	/*/
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Carrega Informacoes da Regra de Apontamento          	      Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	lAleat	  		:= ( GetMemVar( "PA_ALEATOR" ) == "S" )
	lAutomSM    	:= ( GetMemVar( "PA_AUTOMSM" ) == "S" )
	lCompletaMar	:= ( GetMemVar( "PA_COMPMAR" ) == "S" )
	nMinuto			:= Abs( GetMemVar( "PA_MINALEA" ) )
	/*/
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Verifica se Devera Gerar Marcacoes em Dias Nao Trabalhados  Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	lAutoSai := !Empty( cAutoSai := AllTrim( StrTran( GetMemVar( "R6_AUTOSAI" ) , "*" , "" ) ) )
EndIF

/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Garante que as marcacoes de um dia nao interfiram no proximoЁ
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
aMarcNoGer	:= {}

/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Processa para Todas as Ordens da Tabela de Horario		  Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
For nDataApo := 0 To nForDataApo //leandro nfordataapo nЦo tem valor

	/*/
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Inicializa as Variaveis									  Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
    cTipMarcDia		:= ""
    cMarcsObriga	:= ""
    lMarcsObriga	:= .F.
	 
	dDataApo	    :=  dPerIni + nDataApo
	/*/
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Procura a Data de Apontamento em aTabCalend.                Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	
	IF ( nTab := aScan( aTabCalend, { |x| x[CALEND_POS_DATA_APO] == dDataApo } ) ) > 0
	
		/*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Verifica se Esta Dentro do Periodo de Apontamento           Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		IF ( aTabCalend[ nTab , CALEND_POS_DATA_APO ] < dPerIni .or. aTabCalend[ nTab , CALEND_POS_DATA_APO ] > dPerFim )
			Loop
		EndIF

		aMarcGer	:= {}

		/*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Posiciona na Regra do Calendario							  Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		IF !PosSPA( aTabCalend[ nTab , CALEND_POS_REGRA ] , cFilRegra , NIL , 1 , .F. )
			Loop
		EndIF

	
		/*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		ЁSeta os Campos da Regra									  Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		IF (;
				( lChkTables );
				.and.;
				(;
					( _cSpaLastReg <> ( cFilRegra + aTabCalend[ nTab , CALEND_POS_REGRA ] ) );
					.or.;
					!( lSpaIsMemVar );
				);
			)

			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Armazena Filial e Regra Anterior                     	      Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			_cSpaLastReg := ( cFilRegra + aTabCalend[ nTab , CALEND_POS_REGRA ] )

			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Obtem as informacoes em Cache do SPA                        Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			aFields	:= {}
			For nField := 1 To _nSpaHeader
				aAdd( aFields , _aSpaHeader[ nField , __AHEADER_FIELD__ ] )
			Next nField
			aFields := PosSPA( aTabCalend[ nTab , CALEND_POS_REGRA ] , cFilRegra , aFields , 1 , .F. )

			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Carrega e Alimenta as Variaveis de Memoria para o SPA	      Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			For nField := 1 To _nSpaHeader
				SetMemVar( _aSpaHeader[ nField , __AHEADER_FIELD__ ] , aFields[ nField ] , .T. )
			Next nField

			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Verifica se as Variaveis de Memoria foram Carregadas 	      Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			lSpaIsMemVar := IsMemVar( "PA_MARCAUT" )

			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Carrega Informacoes da Regra de Apontamento          	      Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			cMarcAut := StrTran( GetMemVar( "PA_MARCAUT" ) , "*" , "" )
			cMarcAut += IF( SubStr(cMarcAut,-1) != "-" .and. !Empty(cMarcAut) ,"-" , "" )

			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Carrega Informacoes da Regra de Apontamento          	      Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			lAleat	  		:= ( GetMemVar( "PA_ALEATOR" ) == "S" )
			lAutomSM    	:= ( GetMemVar( "PA_AUTOMSM" ) == "S" )
			lCompletaMar	:= ( GetMemVar( "PA_COMPMAR" ) == "S" )
			nMinuto			:= Abs( GetMemVar( "PA_MINALEA" ) )
			
			DEFAULT lCompletaMar	:= .F.

		EndIF

		/*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Se nao Tiver Marcacoes a Gerar Vai Para o Proximo Dia	      Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		IF Empty( nMarcAut := Len( cMarcAut ) )
			Loop
		EndIF

		/*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Verifica se Funcionario Trabalha em Dias Feriado     	      Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		lTrabFer	:= (;
							aTabCalend[	nTab , CALEND_POS_FERIADO		];
							.and.;
							aTabCalend[	nTab , CALEND_POS_TRAB_FERIADO	];
						)	

		/*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Posiciona no Turno do Calendario							  Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		IF !PosSR6( aTabCalend[ nTab , CALEND_POS_TURNO ] , cFilTurno , NIL , 1 , .F. )
			Loop
		EndIF

		/*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		ЁSeta os Campos do Turno									  Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		IF (;
				( lChkTables );
				.and.;
				(;
					( _cSr6LastTno <> ( cFilTurno + aTabCalend[ nTab , CALEND_POS_TURNO ] ) );
					.or.;
					!( lSr6IsMemVar );
				);	
			)	

			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Armazena Filial e Turno Anterior                     	      Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			_cSr6LastTno := ( cFilTurno + aTabCalend[ nTab , CALEND_POS_TURNO ] )

			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Obtem as informacoes em Cache do SR6                        Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			aFields	:= {}
			For nField := 1 To _nSr6Header
				aAdd( aFields , _aSr6Header[ nField , __AHEADER_FIELD__ ] )
			Next nSpaHeader
			aFields := PosSR6( aTabCalend[ nTab , CALEND_POS_TURNO ] , cFilTurno , aFields , 1 , .F. )

			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Carrega e Alimenta as Variaveis de Memoria para o SR6	      Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			For nField := 1 To _nSr6Header
				SetMemVar( _aSr6Header[ nField , __AHEADER_FIELD__ ] , aFields[ nField ] , .T. )
			Next nField

			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Verifica se as Variaveis de Memoria foram Carregadas 	      Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			lSr6IsMemVar := IsMemVar( "R6_AUTOSAI" )

			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Verifica se Devera Gerar Marcacoes em Dias Nao Trabalhados  Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			lAutoSai := !Empty( cAutoSai := AllTrim( StrTran( GetMemVar( "R6_AUTOSAI" ) , "*" , "" ) ) )

		EndIF

		/*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Verifica os Tipos de Marcacoes para o Dia                   Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		For nMarc := nTab To nLenTab
			IF ( aTabCalend[ nMarc , CALEND_POS_DATA_APO ] == dDataApo )
				cUltmarc	:=  ( aTabCalend[ nMarc , CALEND_POS_TIPO_MARC ] + "-" ) 
				cTipMarcDia += cUltmarc
			Else
				Exit
			EndIF	
		Next nMarc  
		
    	/*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		ЁLimita as Marcacoes automaticas a maior marcacao da Tabela   Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/ 
		cNewMarcAut	:= "" 
		IF !empty(cUltmarc)        	
	       	For nMarc := 1 To Len(cMarcAut) Step 3
			
	       		cMarc:= SubStr( cMarcAut , nMarc , 3 )
	       		If cMarc <= cUltmarc
		       		cNewMarcAut+= cMarc
		       	Endif
	
	       	Next nX
        Else 
	        cNewMarcAut:= cMarcAut
        Endif          
        
    	/*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Verifica novamente a existencia de marcacoes a gerar	      Ё
		Ё Se nao Tiver Marcacoes a Gerar Vai Para o Proximo Dia	      Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		IF Empty( nMarcAut := Len( cNewMarcAut ) )
			Loop
		EndIF    
	
		/*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Verifica Quais Marcacoes sao Obrigatorias                   Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
       	cMarcsObriga	:= cTipMarcDia
       	nMarcsGer	 	:= 0
       	For nMarc := 1 To nMarcAut Step 3
			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Apura o Numero de Marcacoes a Gerar						  Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			nMarcsGer++
			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			ЁSe Todas as Marcacoes Obrigatorias Foram Efetuadas sai do ForЁ
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
       		IF Empty( cMarcsObriga := StrTran( cMarcsObriga , SubStr( cNewMarcAut , nMarc , 3 ) , "" ) )
       			Exit
       		EndIF
       	Next nX

		/*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Reinicializa as Variaveis Tabela e Marcacoes                Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		aTDia := {}
		aMDia := {}


		/*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё N└o gera Marca┤oes Autom═ticas em Feriados e Dias Nao Traba Ё
		Ё lhados                                                      Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		IF (;
					aTabCalend[ nTab , CALEND_POS_FERIADO ];
					.and.;
					!( lTrabFer );
					.and.;
					!( lAutosai );
			)		
			Loop
		EndIF

		/*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё N└o gera Marca┤oes Autom═ticas Para Funcionarios Afastados  Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		IF ( aTabCalend[ nTab , CALEND_POS_AFAST ] )
			IF (;
					(;
						( aTabCalend[nTab,CALEND_POS_DATA] >= aTabCalend[ nTab , CALEND_POS_INI_AFAST ] );
						.and.;
						( aTabCalend[nTab,CALEND_POS_DATA] <= aTabCalend[ nTab , CALEND_POS_FIM_AFAST ] );
					);	
					.or.;
					(;
						( aTabCalend[nTab,CALEND_POS_DATA] >= aTabCalend[ nTab , CALEND_POS_INI_AFAST ] );
						.and.;
						Empty( aTabCalend[ nTab , CALEND_POS_FIM_AFAST ] );
					);
				)	
				Loop
			EndIF
		EndIF

		While (;
					( nTab <= nLenTab );
					.and.;
					( dDataApo == aTabCalend[ nTab , CALEND_POS_DATA_APO ] );
			  )
			aAdd( aTDia,;
							{;
								aTabCalend[ nTab , CALEND_POS_DATA		]	,;	//01 - Data
						   		aTabcalend[ nTab , CALEND_POS_HORA		]	,;	//02 - Hora
						   		aTabCalend[ nTab , CALEND_POS_TIPO_MARC	]	,;	//03 - Tipo Marcacao
						   		aTabCalend[ nTab , CALEND_POS_TIPO_DIA	]	,;	//04 - Tipo do Dia
						   		aTabCalend[ nTab , CALEND_POS_HRS_INTER	]	,;	//05 - Horas de Intervalo
						   		aTabCalend[ nTab , CALEND_POS_TURNO		]	,;	//06 - Turno de Trabalho
						   		aTabCalend[ nTab , CALEND_POS_CC		]	,;	//07 - Centro de Cuto
						   		aTabCalend[ nTab , CALEND_POS_FERIADO	]	,;	//08 - Dia Corresponde a Feriado
						   		aTabCalend[ nTab , CALEND_POS_HRS_TRABA	]	,;	//09 - Horas Trabalhadas 
								aTabCalend[ nTab , CALEND_POS_CODFUNC	]	,;	//10 - Codigo da Funcao do funcionario
								aTabCalend[ nTab , CALEND_POS_DEPTO	]		,;	//11 - Codigo de Depto. do funcionario
								aTabCalend[ nTab , CALEND_POS_POSTO	]		,;	//12 - Codigo do Posto do funcionario
								aTabCalend[ nTab , CALEND_POS_PERIODO	]	,;	//13 - Periodo
								aTabCalend[ nTab , CALEND_POS_ROTEIRO	]	,;	//14 - Roterio 
								aTabCalend[ nTab , CALEND_POS_PROCESSO	]	,;	//15 - Processo
								aTabCalend[ nTab , CALEND_POS_NUM_PAGTO	]	,;	//16 - Num. de Pagamento 
								aTabCalend[ nTab , CALEND_POS_DATA_APO	]	,;	//17 - Data de Apontamento
								aTabCalend[ nTab , CALEND_POS_ORDEM  	]	 ;	//18 - Ordem
							};
				 )
			nTab++
		End While
		nTab := 0
		aEval( aTDia , { |x| nTab := SomaHoras( nTab , x[9] ) } )
	
	Else

		/*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Nao Encontrou a Ordem no Calendario                         Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		Loop

	EndIF

	/*/
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Procura a Ordem em aMarcacoes.                              Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	IF ( ( nMarc := aScan( aMarcacoes, { |x| x[AMARC_DATAAPO] == dDataApo } ) ) > 0 )
		While (;
					( nMarc <= nLenMarc );
					.and.;
					( dDataApo == aMarcacoes[ nMarc , AMARC_DATAAPO ] );
			   )
			aAdd( aMDia , { aMarcacoes[ nMarc , 1 ] , aMarcacoes[ nMarc , 2 ], nMarc, aMarcacoes[ nMarc ,AMARC_FLAG] } )
			nMarc++
		End While
		nMarc := 0
	EndIF

	/*/
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё So Gerar Marcacoes nos Dias em Que Existirem Marcacoes ou seЁ
	Ё Tiver Horas Trabalhadas no Calendario de Marcacoes          Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	IF (;
			( nTab == 0 );
			.or.;
			(;
				Empty( aMDia );
				.and.;
				!( lAutomSM );  
			 );
		)
		Loop
	EndIF

	/*/
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё S╒ gera Marca┤oes Autom═ticas se o tipo do dia for "S"im.   Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	IF !( aTDia[1,4] == "S" )
	    IF ( lAutoSai ) 
			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё S╒ gera Marca┤oes Autom═ticas se o tipo do dia for "C"-Compensado Ё
			Ё ou "D" - Descanso ou Dia marcacao for Feriado					    Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			IF !(;
					( aTDia[1,4] $ cAutoSai ))
/*					.or.;
					( aTDia[1,8] );
				 )  */
				Loop
			EndIF
		Else
			Loop
		EndIF			
	EndIF

	/*/
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Verifica Qual Horario da Tabela Esta Sem Marcacao           Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	aTab_Marc := StuffMarcTab( aTDia , aMDia )

	/*/
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Inverte Marcacao de Entrada de Intervalo com Marcacao de  EnЁ
	Ё trada Quando Marcacao de Intervalo for Menor que Marcacao daЁ
	Ё tabela													  Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	AjustMarc( aTDia , NIL , aTab_Marc , NIL , cNewMarcAut , .T. , aClone( aMDia ) , lAutoSai )
	
	/*/
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Insere a marcacao lida e nao incluida no aTab_Marc qdo. se  Ё
	Ё tratar da ultima saida (situacao nao contemplada na aproxim.Ё
	Ё de horarios de StuffMarcTab).								  Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	nTab_Marc := Len( aTab_Marc )
	
	For nMarc := 1 To Len( aMDia )
		/*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Verifica se a marcacao ja foi incluida em aTabMarc.         Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		IF ( aScan( aTab_Marc, { |x| If( !Empty( x[ 2 ] ), x[ 2, 1 ] == aMDia[ nMarc , 1 ] .And. x[ 2 , 2 ] == aMDia[ nMarc , 2 ], .F. ) } ) == 0 )
			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Nao encontrou ultima saida e a marcacao nao lida e nao      Ё
			Ё incluida eh maior que a ultima saida prevista no calendario,Ё
			Ё entao assume como sendo a ultima saida.                     Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			IF Empty( aTab_Marc[ nTab_Marc , 2 ] ) .And. DataHora2Str( aMDia[ nMarc , 1 ] , aMDia[ nMarc , 2 ] ) > aTab_Marc[ nTab_Marc , 4 ]
				aTab_Marc[ nTab_Marc , 2 ] := { aMDia[ nMarc , 1 ], aMDia[ nMarc , 2 ] }
				aTab_Marc[ nTab_Marc , 3 ] := nMarc
				aTab_Marc[ nTab_Marc , 4 ] := DataHora2Str( aTab_Marc[ nTab_Marc , 1 , 1 ] , aTab_Marc[ nTab_Marc , 1 , 2 ] )
				aTab_Marc[ nTab_Marc , 5 ] := aMDia[ nMarc , 3 ]
			EndIF
		EndIF
	Next nMarc

	/*/
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Ponto de Entrada para Remanejamento dos Horarios de         Ё
	Ё Tabela X Marcacoes realizadas.						      Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	If lPnMcAut01                                                     
		If ( ValType( uRet := ExecBlock("PNMCAUT01" , .F. , .F. , {aTab_Marc, aTDia, aMdia,  cNewMarcAut  } ) ) == "A" )
		   aTab_Marc:= aClone(uRet)
		Endif
	Endif
	

	/*/
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Totaliza o Numero de Marcacoes ja Efetuadas                 Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	nMarcsEfe := 0
	cMarcsEfe := ""
	MarcEfetuadas(aTab_Marc, lSobrepoe,  cTipMarcDia,  cMarcsObriga, @nMarcsEfe, @cMarcsEfe) 
	        
	/*/
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Verifica se as Marcacoes Obrigatorias foram efetuadas       Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
    IF !( lMarcsObriga := ( Empty( cMarcsObriga ) .and. Empty( cMarcsEfe ) ) )
		/*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё So verifica as Marcacoes Obrigatorias se nao for   CompletarЁ
		Ё as Marcacoes que Faltam 									  Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
    	IF !( lCompletaMar )
    		For nMarc := 1 To Len( cMarcsObriga ) Step 3
       			IF !( lMarcsObriga := ( SubStr( cMarcsObriga , nMarc , 3 ) $ cMarcsEfe ) )
       				Exit
				EndIF
       		Next nX
       	EndIF	
    ElseIF (;
    			( lCompletaMar );
    			.and.;
    			( lAutomSM );
    		 )
		/*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Deixar a Carga de Todas as Marcacoes, quando estas nao  exisЁ
		Ё tirem, para lAutomSM     									  Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
    	lCompletaMar := .F.
    EndIF

	/*/
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Gera as Marcacoes Automaticas                               Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	IF (;
			(;
				( lMarcsObriga );
				.or.;
				( lCompletaMar );
			);
			.and.;
			( ( nFornY := Len( aTab_Marc ) ) > 0 );
		 )            
		 
		 If !( lSobrepoe )
			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			ЁRecalcula as marcacoes a serem geradas subtraindo as marca-  Ё
			Ёcoes efetuadas.											  Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			For nMarc := 1 To Len(cMarcsEfe) Step 3
				
				/*/
				зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				ЁDiminue as marcacoes geradas a cada marcacao ja efetuada     Ё
				юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	       		IF SubStr( cMarcsEfe , nMarc , 3 )$ cNewMarcAut
					nMarcsGer--
	       		EndIF
	       	Next nX
	
			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Se todas as marcacoes a gerar ja foram efetuadas vai para a Ё
			Ё proxima ordem.											  Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/		       	
			If Empty(nMarcsGer)
			   Loop
			Endif
		Endif
		
		//-- Inicializa todas as marcacoes do dia (Antigas e Geradas)
		aMarcDia	:= aclone(aMDia)
			
		For nY := 1 To nFornY

			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё So Gera Quando Nao Existir Marcacoes ou se Sobrescreve      Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			IF (;
					!Empty( aTab_Marc[ nY , 02 ] );
					.and.;
					!( lSobrepoe );
				) 
				 //-- Altera o estado do flag para nao demonstra-lo como automatico ("A") no caso de log de
                 //-- geracao de marcacoes impares. 
                 If !Empty(aMarcDia)
                    If !Empty(aTab_Marc[nY, 03])
		                 aMarcDia[aTab_Marc[nY, 03],4] := "E"				
		            Endif
		         Endif        
				Loop
			EndIF

			IF ( nPos := aScan( aTDia , { |x|	x[1] == aTab_Marc[ nY , 01 , 01 ] .and. ;
			   									x[2] == aTab_Marc[ nY , 01 , 02 ]		;
									    };
						      );
				) > 0 
				/*/
				зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				ЁVerifica se Devera Gerar a Marcacao Automatica para o Tipo deЁ
				ЁMarcacao em questao. Se o Tipo Nao Estiver Selecionado e a DiЁ
				Ёferenca de Horas Entre o Tipo Selecionado e um Tipo  ImediataЁ
				Ёmente Anterior ou Posterior Que Tenha Sido Selecionado    forЁ
				Ёigual, tambem Gera a Marcacao Automatica. Pois Neste caso naoЁ
				Ёda Para Identificar a Quem Pertence a Marcacao Efetuada.     Ё
				юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
				IF (;
						(;
							AjustMarc( aTDia , nPos , aTab_Marc , nY , cNewMarcAut );
							.or.;
							( aTDia[nPos,3] $ cNewMarcAut );
						 );
						.and.;
				   		( Len( aTDia ) - nMarcsGer >= nMarcsEfe );
				   	)	
                Else
                    //-- Altera o estado do flag para nao demonstra-lo como automatico ("A") no caso de log de
                    //-- geracao de marcacoes impares.
                    If !Empty(aMarcDia)
	                    If !Empty(aTab_Marc[nY, 03])
			                 aMarcDia[aTab_Marc[nY, 03],4] := "E"				
			            Endif
			        Endif   
                	Loop
                EndIF
			Else
					 //-- Altera o estado do flag para nao demonstra-lo como automatico ("A") no caso de log de
                    //-- geracao de marcacoes impares.
                    If !Empty(aMarcDia)
	                    If !Empty(aTab_Marc[nY, 03])
			                 aMarcDia[aTab_Marc[nY, 03],4] := "E"				
			            Endif
			        Endif  
				Loop
			EndIF

			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			ЁRetorna as Horas Maximas Para a Geracao Aleatoria. Os MinutosЁ
			ЁAleatorios nao  podem Exceder `a metada da Jornada.		  Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			IF ( lAleat ) //Marcacao Aleatoria
				IF ( nTab := aScan( aTabCalend, { |x| x[CALEND_POS_TIPO_MARC] == aTDia[nPos,3] .and. x[CALEND_POS_DATA] == aTDia[nPos,1] } ) ) > 0
					IF ( aTabCalend[ nTab , CALEND_POS_HRS_INTER ] > 0 .or. SubStr(aTDia[nPos,3],-1) == "E" )
						IF ( lInterv := ( aTabCalend[ nTab , CALEND_POS_HRS_INTER ] > 0 ) )
						    nInterv := Min( ( __Hrs2Min( aTabCalend[ nTab , CALEND_POS_HRS_INTER ] ) / 2 ) , nMinuto )
						ElseIF ( lInterv := ( aTabCalend[ Max( 1 , nTab - 1 ) , CALEND_POS_HRS_INTER ] > 0 ) )
							nInterv := Min( ( __Hrs2Min( aTabCalend[ Max( 1 , nTab - 1  ) , CALEND_POS_HRS_INTER ] ) / 2 ) , nMinuto )
						EndIF
					EndIF
					IF ( aTabCalend[ nTab , CALEND_POS_HRS_TRABA ] > 0 .or. SubStr(aTDia[nPos,3],-1) == "S" )
						IF ( aTabCalend[ nTab , CALEND_POS_HRS_TRABA ] > 0 )
						    nHrTrab := Min( ( __Hrs2Min( aTabCalend[ nTab , CALEND_POS_HRS_TRABA ] ) / 2 ) , nMinuto )
						ElseIF ( aTabCalend[ Max( 1 , nTab - 1 ) , CALEND_POS_HRS_TRABA ] > 0 )
							nHrTrab := Min( ( __Hrs2Min( aTabCalend[ nTab - 1 , CALEND_POS_HRS_TRABA ] ) / 2 ) , nMinuto )
						EndIF
					EndIF	
				EndIF
				dDtMarc	:= aTDia[nPos,1]
				nMarc	:= aTDia[nPos,2]
				/*/
				зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				Ё Gera minutos aleatorios									  Ё
				юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
				IF ( SubStr(aTDia[nPos,3],-1) == "E" ) //-- Marcacoes de entrada
					IF lInterv
						nMarc := DataHora2Ale(@dDtMarc,nMarc,nInterv,@nAleato,"E")						
					Else
						nMarc := DataHora2Ale(@dDtMarc,nMarc,nHrTrab,@nAleato,"E")
					EndIF	
				Else //-- Marcacoes de saida
					IF lInterv
						nMarc := DataHora2Ale(@dDtMarc,nMarc,nInterv,@nAleato,"S")
					Else
						nMarc := DataHora2Ale(@dDtMarc,nMarc,nHrTrab,@nAleato,"S")
					EndIF	
				EndIF
      			lInterv := .F.
      		Else
      			dDtMarc	:= aTDia[nPos,1]
      			nMarc	:= aTDia[nPos,2]
      		EndIF	
            
			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Obtem o Tipo de Marcacao a Ser Gerada						  Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			cTpMarc := aTDia[nPos,3]

			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Carrega as Marcacoes Automaticas							  Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			aAdd( aMarcGer , Array( ELEMENTOS_AMARC + 1 ) )
			nLenMAuto := Len( aMarcGer )
			aMarcGer[ nLenMAuto , AMARC_DATA		] := dDtMarc											// 01 - Data
			aMarcGer[ nLenMAuto , AMARC_HORA		] := nMarc												// 02 - Hora
			aMarcGer[ nLenMAuto , AMARC_ORDEM		] := aTDia[nPos,18]											// 03 - Ordem
			aMarcGer[ nLenMAuto , AMARC_FLAG		] := "A"												// 04 - Flag
			aMarcGer[ nLenMAuto , AMARC_RECNO		] := 0													// 05 - Recno
			aMarcGer[ nLenMAuto , AMARC_TURNO		] := aTDia[nPos,6]										// 06 - Turno
			aMarcGer[ nLenMAuto , AMARC_FUNCAO		] := _cSpceFuncao              							// 07 - Funcao
			aMarcGer[ nLenMAuto , AMARC_GIRO		] := _cSpceGiro               							// 08 - Giro
			aMarcGer[ nLenMAuto , AMARC_CC			] := IF(!Empty(aTDia[nPos,7]),aTDia[nPos,7],cCusto )	// 09 - Centro Custo
			aMarcGer[ nLenMAuto , AMARC_APONTA		] := "N"												// 10 - Flag de Apontamento
			aMarcGer[ nLenMAuto , AMARC_RELOGIO		] := _cSpceRelogi               						// 11 - Relogio
			aMarcGer[ nLenMAuto , AMARC_TIPOMARC	] := cTpMarc											// 12 - Tipo da Marcacao
			aMarcGer[ nLenMAuto , AMARC_L_ORIGEM	] := .F.												// 13 - Logico
			aMarcGer[ nLenMAuto , AMARC_DTHR2STR	] := DataHora2Str(;                                          
																	aMarcGer[ nLenMAuto , AMARC_DATA ] ,;
																	aMarcGer[ nLenMAuto , AMARC_HORA ]  ;
																  )                                    	//14 - String de Data/Hora para aSort
			aMarcGer[ nLenMAuto , AMARC_PERAPONTA	] := cPerAponta											//15 - String de Data com o Periodo de Apontamento	

			aMarcGer[ nLenMAuto , AMARC_PROCESSO] 	  := aTDia[nPos,15]   	//15 - Processo
			aMarcGer[ nLenMAuto , AMARC_ROTEIRO] 	  := aTDia[nPos,14]		//14 - Roterio 
			aMarcGer[ nLenMAuto , AMARC_PERIODO] 	  := aTDia[nPos,13]		//13 - Periodo
			aMarcGer[ nLenMAuto , AMARC_NUM_PAGTO] 	  := aTDia[nPos,16]		//16 - Num. de Pagamento 
			aMarcGer[ nLenMAuto , AMARC_DEPTO] 		  := aTDia[nPos,11]		//11 - Codigo de Depto. do funcionario
			aMarcGer[ nLenMAuto , AMARC_POSTO] 		  := aTDia[nPos,12]		//12 - Codigo do Posto do funcionari
			aMarcGer[ nLenMAuto , AMARC_CODFUNC]	  := aTDia[nPos,10]	  	//10 - Codigo da Funcao do funcionario
			aMarcGer[ nLenMAuto , AMARC_DATAAPO] 	  := aTDia[nPos,17]		//17 - Data de Apontamento		

			aMarcGer[ nLenMAuto , ELEMENTOS_AMARC  + 1 ] := If( !EMPTY( aTab_Marc[ nY, 02 ] ), aTab_Marc[ nY , 05 ], 0 ) //16 - Ponteiro para a marcacao a ser subsituida (se possuir hora correspondente) ou incluida (o trabalhador nao realizou a marcacao)

			//-- Marcacoes do dia (Antigas e Geradas)
			 If !EMPTY( aTab_Marc[ nY, 02 ] ) 
			 	If !Empty(aMarcDia)
				    If !Empty(aTab_Marc[nY, 03]) 
					    aMarcDia[ aTab_Marc[ nY , 03 ],1 ]:= dDtMarc
					    aMarcDia[ aTab_Marc[ nY , 03 ],2 ]:= nMarc
					    aMarcDia[ aTab_Marc[ nY , 03 ],4 ]:= "A"
				    Endif
				Endif    
			 Else
			    aAdd(aMarcDia, { dDtMarc, nMarc,0, "A"	}  )
			 Endif
			    
		Next nY
        
        //-- Verifica se serao geradas marcacoes em quantidade impar
        If ( Len(aMarcDia) % 2 ) > 0                                         
       		aSort( @aMarcDia , NIL , NIL , { |x,y| ( Dtoc(x[1]) + StrZero( x[2] , 5 , 2 ) ) <  ( Dtoc(y[1]) + StrZero( y[2] , 5 , 2 ) ) } )
            AADD(aMarcNoGer, {dDataApo, aClone( aMarcDia ), "IMPAR" } )
        Else                                        
            //-- Adiciona cada uma das marcaГУes geradas para a ordem lida
            Aeval(aMarcGer, {|x| AADD(aMAuto, aClone(x) ) } )
        Endif
        
	EndIF

Next nDataApo

/*/                  
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё As Marca┤oes Autom═ticas s└o Transferidas para o aMarcacoes.Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
IF ( ( nLenMarc := Len( aMAuto ) ) > 0 )

	For nMarc := 1 To nLenMarc
        If Empty( aMAuto[ nMarc , ELEMENTOS_AMARC  + 1 ] ) 
		    nPos := aScan(	aMarcacoes, { |x|;
		    									x[ AMARC_DATAAPO 	] == aMAuto[ nMarc , AMARC_DATAAPO  	];
		    									.and.;
												x[ AMARC_TIPOMARC 	] == aMAuto[ nMarc , AMARC_TIPOMARC 	];
								  		};
					 	  )
        Else 
        	nPos :=  aMAuto[ nMarc , ELEMENTOS_AMARC  + 1 ] 
        Endif
		IF ( nPos > 0 )

			IF !( lSobrepoe )
		    	Loop
		    EndIF

			nSvRecno := aMarcacoes[ nPos , AMARC_RECNO ]
			aMarcacoes[ nPos ]				:= aClone( aMAuto[ nMarc ] ) 
			aMarcacoes[ nPos , AMARC_RECNO]	:= nSvRecno

		Else

			aAdd( aMarcacoes , aClone( aMAuto[ nMarc ] ) )

		EndIF

	Next nMarc

EndIF

/*/	
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё O Array aMarcacoes ┌ indexado por Ordem + Data + Hora.      Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
IF ( lAuto := !ArrayCompare( aMarcacoes , aCloneMarc ) )
	aSort( @aMarcacoes , NIL , NIL , { |x,y|	(DtoS(x[AMARC_DATAAPO])+x[AMARC_DTHR2STR]);
								 				<;
								     			(DtoS(y[AMARC_DATAAPO])+y[AMARC_DTHR2STR]);
						     		  };
		  )
EndIF

Return( lAuto )

/*/
зддддддддддбддддддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁMarcEfetuadas Ё Autor ЁMauricio MR			  Ё Data Ё17/06/2005Ё
цддддддддддеддддддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁCalcula o numero de marcacoes efetuadas	                       	Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ																Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁNIL																Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function MarcEfetuadas(aTab_Marc, lSobrepoe,  cTipMarcDia,  cMarcsObriga, nMarcsEfe, cMarcsEfe)
Local cTipMarc	:= ""
Local nX		:= 0     
Local nFor 		:= Len(aTab_Marc)

For nX:=1 to nFor
    //-- Se Existir marcacao 
	If !Empty( aTab_Marc[ nX, 2 ] ) 
		If !lSobrepoe
		    //-- Acumula todas as marcacoes efetuadas
		    nMarcsEfe++
		    cMarcsEfe+= SubStr(cTipMarcDia, Getfxy( 3, nX ), 3 ) 	
		Else                                               
		    //-- Acumula como efetuadas apenas as marcacoes que devem existir (as nao selecionadas para gerar)
		    cTipMarc := SubStr(cTipMarcDia, Getfxy( 3, nX ), 3 )
		    If cTipMarc  $ cMarcsObriga
				cMarcsEfe+= cTipMarc
			    nMarcsEfe++
			Endif 
		Endif		 	
	Endif 
Next nX 		 
REturn ( NIL )

/*/
зддддддддддбддддддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁRstMarcAuto	  Ё Autor ЁMarinaldo de Jesus     Ё Data Ё05/10/2004Ё
цддддддддддеддддддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁReinicializa as Statics em PutMarcAuto()                       	Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ																Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁNIL																Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function RstMarcAuto()

_aSpaHeader		:= NIL
_aSr6Header		:= NIL

_cSr6LastTno	:= NIL
_cSpaLastReg	:= NIL
_cSpceFuncao	:= NIL
_cSpceGiro		:= NIL
_cSpceRelogi	:= NIL

lPa_CompMar		:= NIL

_nSpaHeader		:= NIL
_nSr6Header		:= NIL

Return( NIL )

/*/
зддддддддддбдддддддддддддбдддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁStuffMarcTab ЁAutorЁ Marinaldo de Jesus   Ё Data Ё13/08/2001Ё
цддддддддддедддддддддддддадддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁUnir Array de Marcacoes x Tabela para verificar a Marcacao  Ё
Ё          Ёque falta.													Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   ЁStuffMarcTab( aTab , aMarc )     						    Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁPutMarcAuto()                                               Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁArray com os Respectivos pares Marcacoes x Tabela           Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ aTab  = Array com os Horarios da Tabela                    Ё
Ё          Ё aMarc = Array com as Marcacoes do Funcionario              Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function StuffMarcTab( aTab , aMarc )

Local aUnion		:= {}
Local aTemp			:= {}
Local aTemp1		:= {}
Local cDtHr1		:= ""
Local cDtHr2		:= ""
Local nHora1		:= 0
Local nHora2		:= 0
Local nTab   		:= 0
Local nForTab		:= Len( aTab )
Local nMarc	 		:= 0
Local nForMarc		:= Len( aMarc )

For nTab  := 1 To nForTab
	aTemp := {}
	For nMarc := 1 To nForMarc
		aAdd( aTemp , { nMarc , DataHora2Val(	aTab[  nTab , 01  ]		,;
											 	aTab[  nTab , 02  ]		,;
											 	aMarc[ nMarc , 01 ]		,;
											 	aMarc[ nMarc , 02 ]		,;
											 	"H"						 ;
											  ),;
											 	aMarc[ nMarc , 03 ]     ;
						};											  
			 )
	Next nMarc
	aSort( @aTemp , NIL , NIL , { |x,y| x[2] < y[2] } )
	IF !Empty( aTemp )
		aAdd( aUnion , { { aTab[ nTab , 01 ] , aTab[ nTab , 02 ] }							 ,;
						 { aMarc[ aTemp[ 01 , 01 ] , 01 ] , aMarc[ aTemp[ 01 , 01 ] , 02 ] } ,;
						 aTemp[ 01 , 01 ],;
						 DataHora2Str( aTab[ nTab , 01 ] , aTab[ nTab , 02 ] ),;
						 aTemp[01,03];
					    };
	     	)
	Else
		aAdd( aUnion , { { aTab[ nTab , 01 ] , aTab[ nTab , 02 ] }	 ,;
						 {}											 ,;
						 0,;
						 DataHora2Str( aTab[ nTab , 01 ] , aTab[ nTab , 02 ] ),;
						 0;
					    };
	     	)
	EndIF	
Next nTab

IF !Empty( aUnion )
	aSort( @aUnion , NIL , NIL , { |x,y| x[4] < y[4] } )
EndIF

IF !Empty( aMarc )

	aTemp := {}
	
	nForTab := Len( aUnion )
	For nTab := 1 To nForTab
		For nMarc := 1 To nForTab
			IF ( ( aUnion[ nTab , 3 ] == aUnion[ nMarc , 3 ] ) .and. !ArrayCompare( aUnion[ nTab ] , aUnion[ nMarc ] ) )
				IF ( aScan( aTemp , { |x| x[4] == aUnion[ nTab , 4 ] } ) == 0 )
					aAdd( aTemp , aClone( aUnion[ nTab ] ) )
					aTemp[ Len( aTemp ) , 03 ] := nTab
				EndIF	
			EndIF   
		Next nMarc
	Next nTab
	
	IF !Empty( aTemp )
	
		aSort( @aTemp , NIL , NIL , { |x,y| x[4] < y[4] } )
	
		nForTab := Len( aTemp )
		For nTab := 1 To nForTab
			cDtHr1 := DataHora2Str( aTemp[ nTab , 02 , 01 ] , aTemp[ nTab , 02 , 02 ] )
			nHora1 := DataHora2Val( aTemp[ nTab , 01 , 01 ] ,;
									aTemp[ nTab , 01 , 02 ] ,;
									aTemp[ nTab , 02 , 01 ] ,;
									aTemp[ nTab , 02 , 02 ] ,;
									"H";
								   )
			IF ( aScan( aTemp1 , { |x| x[1] == cDtHr1 .and. x[2] == aTemp[ nTab , 03 ] .and. x[3] == nHora1 } ) == 0 )
				aAdd( aTemp1 , { cDtHr1 , aTemp[ nTab , 03 ] , nHora1, aTemp[ nTab, 04 ] } )
			EndIF
			For nMarc := nTab + 1 To nForTab
				IF ( cDtHr2 := DataHora2Str( aTemp[ nMarc , 02 , 01 ] , aTemp[ nMarc , 02 , 02 ] ) ) == cDtHr1
					nHora2 := DataHora2Val( aTemp[ nMarc , 01 , 01 ] ,;
											aTemp[ nMarc , 01 , 02 ] ,;
											aTemp[ nMarc , 02 , 01 ] ,;
											aTemp[ nMarc , 02 , 02 ] ,;
											"H";
										   )
					IF ( aScan( aTemp1 , { |x| x[1] == cDtHr2 .and. x[2] == aTemp[ nMarc , 03 ] .and. x[3] == nHora2 } ) == 0 )
						aAdd( aTemp1 , { cDtHr2 , aTemp[ nMarc , 03 ] , nHora2, aTemp[ nMarc, 04 ] } )
					EndIF
					nTab := nMarc
				Else
					Exit
				EndIF
			Next nMarc
		Next nTab
		
		aSort( @aTemp1 , NIL , NIL , { |x,y| x[1] + StrZero( x[3] , 5 , 2 ) < y[1] + StrZero( y[3] , 5 , 2 ) } )
		
		nForTab := Len( aTemp1 )
		For nTab := 1 To nForTab
			For nMarc := nTab + 1 To nForTab
				IF aTemp1[ nMarc , 1 ] == aTemp1[ nTab , 1 ]
					aUnion[ aTemp1[ nMarc , 2 ] , 02 ] := {}
					nTab := nMarc
				Else
					Exit
				EndIF	
			Next nMarc	
		Next nTab
	
	EndIF

EndIF

Return( aUnion )

/*/
зддддддддддбдддддддддддддбдддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁAjustMarc()  ЁAutorЁ Marinaldo de Jesus   Ё Data Ё14/08/2001Ё
цддддддддддедддддддддддддадддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁAjustMarc()													Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   ЁAjustMarc(aTDia,nPos,<@>aTab_Marc,nY,cMarcAut,lInverte)		Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁPutMarcAuto()                                               Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁTrue se a Diferenca for Igual                               Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ aTDia    	= Array com as Marcacoes da Tabela de Horario	Ё
Ё          Ё nPos     	= Indice de aTDia								Ё
Ё          Ё aTab_Marc	= Array com Horarios da Tabela x Marcacoes 		Ё
Ё          Ё nY       	= Indice para aTab_Marc                    		Ё
Ё          Ё cMarcaut	= Marcacoes a Serem Geradas						Ё
Ё          Ё lInverte	= Inverter Marcacao de Entrada de Intervalo  comЁ
Ё          Ё              Entrada do Expediente							Ё
Ё          Ё aMDia      = Array com as Reais Marcacoes do Dia			Ё
Ё          Ё lAutoSai   = Se Gera Marcacoes de Intervalo Para Dias N.T. Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function AjustMarc( aTDia , nPos , aTab_Marc , nY , cMarcAut , lInverte , aMDia , lAutoSai )

Local cTipMarc		:= ""
Local dDtTab		:= Ctod("//")
Local dDtMar		:= Ctod("//")
Local lRet			:= .F.
Local nHrTab		:= 0
Local nHrMar		:= 0
Local nLenDia		:= Len( aTDia )
Local nLenTma		:= Len( aTab_Marc )
Local nHora1		:= 0
Local nHora2		:= 0.01
Local nMarcs		:= 0
Local nMarc			:= 0
Local nLenMarcs		:= 0

DEFAULT nPos		:= 0
DEFAULT nY			:= 0
DEFAULT lInverte	:= .F.
DEFAULT aMDia		:= {}

lInverte := IF( lInverte , ( Len( cMarcAut ) == 6 .and. SubStr( cMarcAut , 2 , 1 ) == "S" .and. SubStr( cMarcAut , 5 , 1 ) == "E" ) , lInverte )

IF ( nLenDia > 0 )

	IF !( lInverte ) .and. Len( cMarcAut ) == 3.00 .and. !Empty( nPos ) .and. !( aTDia[ nPos , 3 ] $ cMarcAut )

		/*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		ЁVerifica se Devera Gerar a Marcacao Automatica para o Tipo deЁ
		ЁMarcacao em questao. Se o Tipo Nao Estiver Selecionado e a DiЁ
		Ёferenca de Horas Entre o Tipo Selecionado e um Tipo  ImediataЁ
		Ёmente Anterior ou Posterior Que Tenha Sido Selecionado    forЁ
		Ёigual, tambem Gera a Marcacao Automatica. Pois Neste caso naoЁ
		Ёda Para Identificar a Quem Pertence a Marcacao Efetuada.     Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		IF ( "E" $ aTDia[ nPos , 3 ] )
			cTipMarc := StrZero( Val( SubStr( aTDia[ nPos , 3 ] , 1 , 1 ) ) - 1 , 1 ) + SubStr( aTDia[ nPos , 3 ] , -1 )
		ElseIF ( "S" $ aTDia[ nPos , 3 ] )
			cTipMarc := StrZero( Val( SubStr( aTDia[ nPos , 3 ] , 1 , 1 ) ) + 1 , 1 ) + SubStr( aTDia[ nPos , 3 ] , -1 )
		EndIF
	
		IF ( SubStr( cTipMarc , 1 , 1 ) + SubStr( cMarcAut , 2 , 1 ) ) $ cMarcAut
	
			IF ( "E" $ aTDia[ nPos , 3 ] )
	
				IF !Empty( aTab_Marc[ Max( 1 , nY - 1 ) , 2 ] ) .and. !Empty( aTDia[ Max( 1 , nPos - 1 ) ] )
				
					dDtMar := aTab_Marc[ Max( 1 , nY - 1 ) , 2 , 1 ]
					nHrMar := aTab_Marc[ Max( 1 , nY - 1 ) , 2 , 2 ]
		
					dDtTab := aTDia[ nPos , 1 ]
					nHrTab := aTDia[ nPos , 2 ]
					nHora1 := DataHora2Val( dDtTab , nHrTab , dDtMar , nHrMar , "H" )
		
					dDtTab := aTDia[ Max( 1 , nPos - 1 ) , 1 ]
					nHrTab := aTDia[ Max( 1 , nPos - 1 ) , 2 ]
					nHora2 := DataHora2Val( dDtTab , nHrTab , dDtMar , nHrMar , "H" )
				
				EndIF
	
			ElseIF ( "S" $ aTDia[ nPos , 3 ] )
	
				IF !Empty( aTab_Marc[ Min( nLenTma , nY  + 1 ) , 2 ] ) .and. !Empty( aTDia[ Min( nLenDia , nPos + 1 ) ] )
	
					dDtMar := aTab_Marc[ Min( nLenTma , nY  + 1 ) , 2 , 1 ]
					nHrMar := aTab_Marc[ Min( nLenTma , nY  + 1 ) , 2 , 2 ]
		
					dDtTab := aTDia[ nPos , 1 ]
					nHrTab := aTDia[ nPos , 2 ]
					nHora1 := DataHora2Str( dDtTab , nHrTab , dDtMar , nHrMar )
		
					dDtTab := aTDia[ Min( nLenDia , nPos + 1 ) , 1 ]
					nHrTab := aTDia[ Min( nLenDia , nPos + 1 ) , 2 ]
					nHora2 := DataHora2Str( dDtTab , nHrTab , dDtMar , nHrMar )
	
				EndIF	
		
			EndIF
	
			lRet := ( nHora1 == nHora2 )
	
		EndIF
	
	ElseIF ( lInverte )

		/*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Apenas Quando Existirem Marcacoes Efetivas 				  Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		IF ( nLenMarcs := Len( aMDia ) ) > 0 
		
			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Ajusta a Saida  ( Quando nao for a ultima )				  Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			For nY := 1 To nLenTma
	
				IF ( Empty( aTab_Marc[ nY , 02 ] ) .or. ( nY == nLenTma )  )
					Loop
				EndIF
				
				IF ( nPos := aScan( aTDia , { |x|	x[1] == aTab_Marc[ nY , 01 , 01 ] .and. ;
					   								x[2] == aTab_Marc[ nY , 01 , 02 ]		;
										    };
								   );
					) > 0 .and. aTDia[nPos,3] $ cMarcAut .and. SubStr( aTDia[nPos,3] , -1 ) == "S"
					
					/*/
					зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
					Ё Se Marcacao de Encaixe for menor que marcacao da Tabela ZeraЁ
					Ё a Marcacao de Encaixe										  Ё
					юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
					IF Empty( aTab_Marc[ nY - 1 , 02 ] ) .and. ;
					   DataHora2Str(aTab_Marc[nY,02,01],aTab_Marc[nY,02,02]) < DataHora2Str(aTab_Marc[nY,01,01],aTab_Marc[nY,01,02])
						aTab_Marc[ nY - 1 , 02 ]	:= aClone( aTab_Marc[ nY , 02 ] )
						aTab_Marc[ nY , 02 ]		:= {}
						Exit
					Else
						Loop
					EndIF
	        	
	        	EndIF
			
			Next nY

			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Ajusta a Saida  ( Quando for a Ultima e Numero de  MarcacoesЁ
			Ё da Tabela for igual a 2 )									  Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
            IF ( ( nLenTma == 2 ) .and. ( nLenMarcs == nLenTma ) )
            	IF ( Empty( aTab_Marc[ nLenTma , 02 ] ) .and. !Empty( aTab_Marc[ nLenTma - 1 , 02 ] ) )
            		aTab_Marc[ nLenTma , 02 ]		:= aClone( aTab_Marc[ nLenTma - 1 , 02 ] )
            		aTab_Marc[ nLenTma , 02 , 01 ]	:= aMDia[ nLenMarcs , 01 ]
            		aTab_Marc[ nLenTma , 02 , 02 ]	:= aMDia[ nLenMarcs , 02 ]
            	EndIF
            EndIF
	
			/*/
			зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Ajusta a Entrada ( Quando nao for a Primeira ) 			  Ё
			юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			For nY := 1 To nLenTma
	
				IF ( Empty( aTab_Marc[ nY , 02 ] ) .or. ( nY == 1 )  )
					Loop
				EndIF
				
				IF ( nPos := aScan( aTDia , { |x|	x[1] == aTab_Marc[ nY , 01 , 01 ] .and. ;
					   								x[2] == aTab_Marc[ nY , 01 , 02 ]		;
										    };
								   );
					) > 0 .and. aTDia[nPos,3] $ cMarcAut .and. SubStr( aTDia[nPos,3] , -1 ) == "E"
					
					/*/
					зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
					Ё Se Marcacao de Encaixe for maior que marcacao da Tabela ZeraЁ
					Ё a Marcacao de Encaixe										  Ё
					юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
					IF DataHora2Str(aTab_Marc[nY,02,01],aTab_Marc[nY,02,02]) > DataHora2Str(aTab_Marc[nY,01,01],aTab_Marc[nY,01,02])
						/*/
						зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
						Ё Apenas Quando for formar Pares de Marcacoes ou Quando o Dia Ё
						Ё Nao For Trabalhado e Gerar Marcacoes para Dias Nao Trabalha Ё
						Ё dos ( lAutoSai ) ou Ainda Quando a Marcacao de Entrada  for Ё
						Ё a Ultima Marcacao do Dia.									  Ё
						юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			    		IF ( nMarc := aScan( aMDia , { |x| x[1] == aTab_Marc[nY,02,01] .and. x[2] == aTab_Marc[nY,02,02] } ) ) > 0
					        IF ( ( nMarcs := ( nLenMarcs - ( nMarc + 1 ) ) % 2 ) > 0 .or. ( nMarc == nLenMarcs ) )
								IF ( nMarc == nLenMarcs )
									IF ( nY + 1 ) <= Len( aTab_Marc )
										aTab_Marc[ nY + 1 , 02 ]	:= aClone( aTab_Marc[ nY , 02 ] )
										aTab_Marc[ nY , 02 ]		:= {}
									EndIF
								Else
									aTab_Marc[ nY , 02 ] := {}
								EndIF
							ElseIF ( lAutoSai .and. ( aTDia[ nPos , 04 ] != "S" ) )
								IF ( nY + 1 ) <= Len( aTab_Marc )
									aTab_Marc[ nY + 1 , 02 ]	:= aClone( aTab_Marc[ nY , 02 ] )
									aTab_Marc[ nY , 02 ]		:= {}
								EndIF
							EndIF	
						EndIF	
						Exit
					/*/
					зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
					ЁNeste Caso a Marcacao foi Encaixada como Entrada de IntervaloЁ
					ЁSimula a Saida no Expediente para Poder Gerar a Saida do   InЁ
					Ёtervalo													  Ё
					юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
					ElseIF ( nY + 1 ) <= Len( aTab_Marc ) .and. Empty( aTab_Marc[ nY + 1 , 02 ] )
						aTab_Marc[ nY + 1 , 02 ] := aClone( aTab_Marc[ nY , 02 ] )
						Exit
					Else
						Loop
					EndIF
	        	
	        	EndIF
			
			Next nY
		
		EndIF
	
	EndIF
	
EndIF

Return( lRet )

/*/
зддддддддддбддддддддддддддддбдддддбдддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁPonDestroyStaticЁAutorЁMarinaldo de Jesus Ё Data Ё26/11/2001Ё
цддддддддддеддддддддддддддддадддддадддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁReinicializar as Variaveis Staticas do SIGAPON    			Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   ЁPonDestroyStatic( <aDestroy> )								Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁSIGAPON                                                     Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁNIL															Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ aDestroy -> Pilha com as Funcoes que terao Statics ReiniciaЁ
Ё          Ё 			 lizadas       									Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function PonDestroyStatic( aDestroy )

Begin Sequence

	DEFAULT aDestroy := {}
	IF ( Empty( aDestroy ) .or. ( ValType( aDestroy ) != "A" ) )
		aDestroy := Array( 21 )
		aDestroy[01] := "RstAponta()"
		aDestroy[02] := "RstfFeriado()"
		aDestroy[03] := "RstGetTabExtra()"
		aDestroy[04] := "RstGetTabArred()"
		aDestroy[05] := "SuperGetMv()"
		aDestroy[06] := "RstToScheduleOverTime()"
		aDestroy[07] := "RstTimeRemaining()"
		aDestroy[08] := "RstPosAlias()"
		aDestroy[09] := "ResetSqlName()"
		aDestroy[10] := "RstCalendCria()"
		aDestroy[11] := "RstCriaCalend()"
		aDestroy[12] := "RstTabPadrao()"
		aDestroy[13] := "RstEnchoVlds()"
		aDestroy[14] := "RstfEventos()"
		aDestroy[15] := "RstCheckSx9()"
		aDestroy[16] := "RstfCargaId()"
		aDestroy[17] := "RstMarcAuto()"
		aDestroy[18] := "RstExistField()"
		aDestroy[19] := "RstFilExistField()"
		aDestroy[20] := "RstGetCache()"
		aDestroy[21] := "RstGetAdsLckRec()"
		aEval( aDestroy , { |x| IF( !Empty(x) .and. FindFunction(x) , &(x) , NIL ) } )
	ElseIF ( ValType( aDestroy ) == "A" )
		aEval( aDestroy , { |x| IF( !Empty(x) .and. FindFunction(x) , IF( SubStr( ( x := StrTran( x ," ","") ) , -2 )!="()",&(x+"()"),&(x)) , NIL ) } )
	EndIF

    //-- Descarta Variavel para uso em Query
	__cLimpaMotAbo := NIL    
	
End Sequence
	
Return( NIL )

/*/
зддддддддддбддддддддддддддддбдддддбдддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁGetPonMesDat    ЁAutorЁMarinaldo de Jesus Ё Data Ё10/12/2001Ё
цддддддддддеддддддддддддддддадддддадддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁRetorna a Data Inicial e Final do Parametro MV_PONMES		Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   ЁGetPonMes( @dPerIni , @dPerFim , cFil )						Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁSIGAPON                                                     Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁNIL															Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁdPerIni  -> Data Inicial do Periodo de Apontamento em AbertoЁ
Ё          ЁdPerFim  -> Data Final   do Periodo de Apontamento em AbertoЁ
Ё          ЁcFil     -> Filial para GetMv()								Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function GetPonMesDat( dPerIni , dPerFim , cFil )
         
Local cPonMes		:= ""
Local cPerAponta	:= ""
Local cSvFilAnt		:= cFilAnt
Local lRet			:= .T.

DEFAULT dPerIni		:= Ctod("//")
DEFAULT dPerFim		:= Ctod("//")
DEFAULT cFil		:= cSvFilAnt

aLogErr030 	:= If ( Type("aLogErr030") == "U" , aLogErr030 := {}, aLogErr030 )

cFilAnt := IF( !Empty( cFil ) , cFil , cFilAnt )

Begin Sequence

	IF !( lRet := CheckModSPO() )
		AADD( aLogErr030, "01" ) //01 = Problema no modo de acesso do cadastro de perМodos (SPO).
		Break
	EndIF
	
	IF Empty( cPonMes := GetPonMes( cFil ) )
		cPerAponta := GetPaponta( cFil )
		IF ( PerCompleto( cPerAponta ) )
	    	cPonMes := cPerAponta
    		PutMvFil( "MV_PONMES" , cPonMes , cFilAnt )
	    EndIF
	EndIF

	IF !( lRet := !Empty( dPerIni := Stod( Left( cPonMes , 08 ) ) ) )
		AADD( aLogErr030, "02" ) //02 = PerМodo incorreto!
		Break
	EndIF
	
	IF !( lRet := !Empty( dPerFim := Stod( Right( cPonMes , 08 ) ) ) )
		AADD( aLogErr030, "02" ) //02 = PerМodo ncorreto!
		Break
    EndIF

	IF !( lRet := MaxP8PGOrdVld( dPerIni , dPerFim ) )
		AADD( aLogErr030, "03" ) //03 = NЗmero de ordens superior ao permitido.
		Break
	EndIF

End Sequence

cFilAnt := cSvFilAnt

Return( lRet )

/*/
зддддддддддбддддддддддддддддбдддддбдддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁValidPonData    ЁAutorЁMarinaldo de Jesus Ё Data Ё10/12/2001Ё
цддддддддддеддддддддддддддддадддддадддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁValida as Datas Digitadas nos Lancamentos do SIGAPON		Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁSIGAPON                                                     Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁNIL															Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ< Vide Parametros Formais 									Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function ValidPonData(	dData		,;	//01 -> Data a Ser Validada
						cTipValid	,;	//02 -> Tipo da Validacao "G" - GetDados (Periodo) ; "P" - Validar o MV_PONMES
						dPerIni		,;	//03 -> Periodo Inicial
						dPerFim		,;	//04 -> Periodo Final
						lAcumulado	,;	//05 -> Se Informacao de Arquivo Acumulado
						lShowHelp	,;  //06 -> Mostrar ou Nao o Help
						cFil		 ;	//07 -> Filial para PerAponta
					  )

Local cHelp	:= ""
Local lRet	:= .T.

DEFAULT dData		:= Ctod("//")
DEFAULT cTipValid	:= "G"
DEFAULT dPerIni 	:= Ctod("//")
DEFAULT dPerFim		:= Ctod("//")
DEFAULT lAcumulado	:= .F.
DEFAULT lShowHelp	:= .T.
DEFAULT cFil		:= cFilAnt

cTipValid := Upper( AllTrim( cTipValid ) )

Begin Sequence

	IF ( Empty( dPerIni ) .or. Empty( dPerFim ) )
		IF !( lRet := PerAponta( @dPerIni , @dPerFim , NIL , lShowHelp , cFil ) )
			Break
		EndIF
	EndIF

	IF ( cTipValid == "G" )
		/*/
		здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Nao Podem Haver Lancamentos Fora do Periodo em Aberto		   Ё
		юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		IF ( ( dData < dPerIni ) .or. ( dData > dPerFim ) )
			lRet := .F.
			cHelp += ( OemToAnsi( STR0108 ) + Space(50) + Chr(13) )								//'A Data Informada e Invalida.'
			cHelp += OemToAnsi( STR0106 )														//'Per║odo em Aberto: '
			cHelp += ( Dtoc( dPerIni ) + STR0104 +  Dtoc( dPerFim )  ) + Space(50) + Chr(13)	//' a '
			cHelp += Space(50) + Chr(13)
			cHelp += Space(50) + Chr(13)
		EndIF
		Break
	EndIF

	IF ( cTipValid == "P" )
		IF ( lAcumulado )
			/*/
			здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Nao Podem Haver Lancamentos para Periodos Posteriores ao PeriЁ
			Ё odo de Apontamento em Aberto.						   		   Ё
			юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			lRet := !( dData >= dPerIni )
			cHelp += ( OemToAnsi( STR0105 ) + Space(50) + Chr(13) )								//'N└o Podem Haver Lan┤amentos Acumulados'
			cHelp += ( OemToAnsi( STR0107 ) + Space(50) + Chr(13) )								//'Para Este Per║odo: '
			cHelp += OemToAnsi( STR0106 )														//'Per║odo em Aberto: '
			cHelp += ( Dtoc( dPerIni ) + STR0104 +  Dtoc( dPerFim )  ) + Space(50) + Chr(13)	//' a '
			cHelp += Space(50) + Chr(13)
			cHelp += Space(50) + Chr(13)
		Else
			/*/
			здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Nao Podem Haver Lancamentos para Periodo Anteriores ao  PerioЁ
			Ё do de Apontamento em Aberto.							   	   Ё
			юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			lRet := !( dData < dPerIni )
			cHelp += ( OemToAnsi( STR0102 ) + Space(50) + Chr(13) )								//'N└o Podem Haver Lan┤amentos para Per║odo'
			cHelp += ( OemToAnsi( STR0103 ) + Space(50) + Chr(13) )								//'Posterior ao Periodo em Aberto: '
			cHelp += OemToAnsi( STR0106 )														//'Per║odo em Aberto: '
			cHelp += ( Dtoc( dPerIni ) + STR0104 +  Dtoc( dPerFim )  ) + Space(50) + Chr(13)	//' a '
		EndIF	
		Break
	EndIF
	
End Sequence
	
IF ( !( lRet ) .and. ( lShowHelp ) )
	IF !Empty( cHelp )
		Help( " " , 1 , "NOVALIDPER" , , cHelp , 1 , 0 )
	EndIF	
EndIF

Return( lRet )

/*/
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤└o    ЁDescPdPon Ё Autor Ё Equipe Advanced RH    Ё Data Ё23/02/1995Ё╠╠
╠╠цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤└o Ё Retorna a Descricao do Codigo de Provento / Desconto       Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁUso       Ё Generico                                                   Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ/*/
Function DescPdPon( cEvento , cFil , nBytes )

Local cRet		:= ""
Local nSvOrder	:= SP9->( IndexOrd() )
Local nOrder	:= RetOrdem( "SP9" , "P9_FILIAL+P9_CODIGO" )

DEFAULT nBytes := 20

IF ( nBytes > 20 )
	nBytes := 20
EndIF

cFil := xFilial( "SP9" , cFil )

IF !( nOrder == nSvOrder )
	SP9->( dbSetOrder( nOrder ) )
EndIF
	
IF SP9->( MsSeek( cFil + cEvento ) )
	cRet := Left( SP9->P9_DESC + Space( nBytes ) , nBytes )
Else
	cRet := Left( STR0001 + Space( nBytes ) , nBytes ) // '** Nao Cadastrado **'
EndIF

SP9->( dbSetOrder( nSvOrder ) )

Return( cRet )

/*/
зддддддддддбддддддддддддбдддддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁShowTipoDia Ё Autor ЁMarinaldo de Jesus    Ё Data Ё19/07/2002Ё
цддддддддддеддддддддддддадддддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁValidar a multipla escolha de tipo de Dia              		 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   ЁShowTipoDia( cTipo , l1Elem )								 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ                                                     		 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   Ё.T.                                                  	     Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁObserva┤└oЁ                                                      	     Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁApontamento                                                  Ё
юддддддддддаддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function ShowTipoDia( cTipoDia , l1Elem , lDisplay )

Local aTpDia		:= {}
Local aOpc			:= {}
Local cTitulo		:= ""
Local cMvParDef		:= ""
Local cMvPar		:= ""
Local nTpDia		:= 0
Local nTpDias		:= 0
Local nPosTpDia		:= 0
Local uRet			:= NIL

DEFAULT cTipoDia	:= "CDFNS"
DEFAULT l1Elem		:= .F.
DEFAULT lDisplay	:= .T.

aAdd( aTpDia , { "C" , STR0109	} )	//"Compensado"
aAdd( aTpDia , { "D" , STR0110	} )	//"DSR"
aAdd( aTpDia , { "F" , STR0111	} )	//"Feriado"
aAdd( aTpDia , { "N" , STR0112	} )	//"Nao Trabalhado"
aAdd( aTpDia , { "S" , STR0113 	} )	//"Trabalhado"

IF ( lDisplay )  

	CursorWait()

	    cMvPar				:= &( Alltrim( ReadVar() ) )
		cTipoDia			:= Upper( AllTrim( cTipoDia ) )
		l1Elem				:= IF( ValType( l1Elem ) != "L" , .F. , l1Elem )
		MvRet				:= Alltrim( ReadVar() )

		nTpDias := Len( cTipoDia )
		For nTpDia := 1 To nTpDias
			IF ( nPosTpDia := aScan( aTpDia , { |x| x[1] == SubStr( cTipoDia , nTpDia , 1 ) } ) ) > 0
				cMvParDef += aTpDia[ nPosTpDia , 01 ]
				aAdd( aOpc , aTpDia[ nPosTpDia , 01 ] += ( "-" + aTpDia[ nPosTpDia , 02 ] ) )
			EndIF
		Next nX

	CursorArrow()

	IF ( uRet := ( cMvPar != NIL ) )
		IF f_Opcoes(@cMvPar,cTitulo,aOpc,cMvParDef,12,49,l1Elem,1)
			&(MvRet) := cMvPar
		EndIF	
	EndIF

Else

	IF ( nPosTpDia := aScan( aTpDia , { |x| x[1] == cTipoDia } ) ) > 0
		uRet := aTpDia[ nPosTpDia , 02 ]
	EndIF

EndIF
	
Return( uRet )

/*/
зддддддддддбддддддддддддбдддддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁValidPerSPO Ё Autor ЁMarinaldo de Jesus    Ё Data Ё29/07/2002Ё
цддддддддддеддддддддддддадддддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁValidar as Datas no Cadastro de Periodos de Apontamento		 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais >									 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais >									 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁlRet                                                 	     Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁObserva┤└oЁ                                                      	     Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGenerico                                                     Ё
юддддддддддаддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function ValidPerSPO(	cFil		,;	//Filial de Referencia Para Pesquisa no SPO
						dPerIni 	,;	//Periodo Inicial para Valiadacao
						dPerFim		,;	//Periodo Final Para Validacao
						lNotInclui	,;	//Quando Inclui nao Estiver Definido, qual sera o seu valor
						lShowHelp	,;	//Se deve Mostrar Help
						aPeriodos	,;	//Periodos que foram carregados
						lValidPer	 ;	//Se deve validar os Periodos
					)

Local aAreaSPO		:= SPO->( GetArea() )
Local cAlias		:= "SPO"
Local lRet			:= .T.
Local nPosDataIni	:= ( cAlias )->( FieldPos( "PO_DATAINI" ) )
Local nPosDataFim	:= ( cAlias )->( FieldPos( "PO_DATAFIM" ) )

Local dPoDataIni
Local dPoDataFim
Local dFirstDate
Local dLastDate
Local nRecno

DEFAULT dPerIni		:= IF( IsMemVar("PO_DATAINI") , GetMemVar( "PO_DATAINI" ) , Ctod("//") )
DEFAULT dPerFim		:= IF( IsMemVar("PO_DATAFIM") , GetMemVar( "PO_DATAFIM" ) , Ctod("//") )
DEFAULT lNotInclui	:= .F.
DEFAULT lShowHelp	:= .T.
DEFAULT lValidPer	:= .T.

aPeriodos := {}

Begin Sequence

	IF !( lRet := MaxP8PGOrdVld( dPerIni , dPerFim , lShowHelp ) )
		Break
	EndIF

	IF !( lRet := ( nPosDataIni > 0 ) )
		Break
	EndIF

	IF !( lRet := ( nPosDataFim > 0 ) )
		Break
	EndIF

	Inclui	:= IF( ( Type( "Inclui" ) == "U" ) , lNotInclui , Inclui )
	cFil	:= xFilial( cAlias , cFil )

	SPO->( dbSetOrder( RetOrdem( "SPO" , "PO_FILIAL+DTOS(PO_DATAINI)" ) ) )
	IF ( cAlias )->( dbSeek( cFil , .F. ) )
		While ( cAlias )->( !Eof() .and. PO_FILIAL == cFil )
			IF IF( Inclui , Inclui , !( nRecno := ( cAlias )->( Recno() ) == aAreaSPO[ 3 ] ) )
				dPoDataIni	:= ( cAlias )->( FieldGet( nPosDataIni ) )
				IF Empty( dFirstDate )
					dFirstDate	:= dPoDataIni
				EndIF
				dPoDataFim	:= ( cAlias )->( FieldGet( nPosDataFim ) )
				dLastDate	:= dPoDataFim
				IF ( lValidPer )
					IF ConflictDate( dPerIni , dPerFim , dPoDataIni , dPoDataFim )
						lRet := .F.
						Break
					EndIF
				EndIF
				aAdd( aPeriodos , { dPoDataIni , dPoDataFim , nRecno } )
			EndIF
			( cAlias )->( dbSkip() )
		End While
	EndIF

	IF ( lValidPer )

		IF ( !Empty( dFirstDate ) .and. !Empty( dLastDate ) )
			IF ConflictDate( dPerIni , dPerFim , dFirstDate , dLastDate )
				lRet := .F.
				Break
			EndIF
		EndIF	

	EndIF

End Sequence

IF ( ( lShowHelp ) .and. !( lRet ) )
	Help(" ",1,"PONA290PER")
EndIF

Return( lRet )

/*/
зддддддддддбддддддддддддддбдддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o	   ЁPutPerSPO	  ЁAutorЁ Marinaldo de Jesus  Ё Data Ё09/08/2002Ё
цддддддддддеддддддддддддддадддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁGravar Periodo de Apontamento na Tabela de Periodos de  AponЁ
Ё          ЁTamento														Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais> 									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>                                   Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso	   Ё Generico 												    Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function PutPerSPO( cFil , dPerIni , dPerFim , cFlag , cRespon )

Local aArea		:= GetArea()
Local cAlias	:= "SPO"
Local lRet		:= .F.

DEFAULT cFil	:= ""
DEFAULT dPerIni	:= Ctod("//")
DEFAULT dPerFim	:= Ctod("//")
DEFAULT cFlag	:= "0"
DEFAULT cRespon	:= "S"

IF !( cFlag $ "01" )
	cFlag := "0"
EndIF

IF !( cRespon $ "US" )
	cRespon := "U"
EndIF

IF ( lRet := ValidPerSPO( @cFil , dPerIni , dPerFim , .T. , .F. ) )
	IF ( lRet := ( cAlias )->( RecLock( cAlias , .T. , .F. ) ) )
		( cAlias )->( FieldPut( FieldPos( "PO_FILIAL"  ) , cFil		) )
		( cAlias )->( FieldPut( FieldPos( "PO_DATAINI" ) , dPerIni	) )
		( cAlias )->( FieldPut( FieldPos( "PO_DATAFIM" ) , dPerFim	) )
		( cAlias )->( FieldPut( FieldPos( "PO_FLAGFEC" ) , cFlag   	) )
		( cAlias )->( FieldPut( FieldPos( "PO_RESPONS" ) , cRespon 	) )
		( cAlias )->( MsUnLock() )
	EndIF
EndIF

RestArea( aArea )

Return( lRet )

/*/
зддддддддддбддддддддддддддбдддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o	   ЁRetPerSPO	  ЁAutorЁ Marinaldo de Jesus  Ё Data Ё29/08/2002Ё
цддддддддддеддддддддддддддадддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁRetornar Periodos de Apontamento do SPO                     Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais> 									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>                                   Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso	   Ё Generico 												    Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function RetPerSPO( cFil )

Local aArea		:= GetArea()
Local aAreaSPO	:= SPO->( GetArea() )
Local aPerSPO	:= {}

cFil := xFilial( "SPO" , cFil )

While SPO->( !Eof() .and. cFil == PO_FILIAL )
	SPO->( aAdd( aPerSPO , { PO_DATAINI , PO_DATAFIM } ) , dbSkip() )
End While

( RestArea( aAreaSPO ) , RestArea( aArea ) )

Return( aPerSPO )

/*/
зддддддддддбддддддддддддддбдддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o	   ЁCheckModSPO   ЁAutorЁ Marinaldo de Jesus  Ё Data Ё09/08/2002Ё
цддддддддддеддддддддддддддадддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁVerifica o Modo de Acesso do SPO e,se nao for compartilhado,Ё
Ё          ЁDuplica os Parametros MV_PONMES e MV_PAPONTA				Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais> 									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>                                   Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso	   Ё Generico 												    Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function CheckModSPO()

Local aArea		:= GetArea()
Local aAreaSMO	:= SM0->( GetArea() )
Local lRet		:= .T.

Begin Sequence

	IF ( lRet := Empty( xFilial( "SPO" ) ) )
		Break
	EndIF
	
	IF ( lRet := SM0->( dbSeek( cEmpant , .F. ) ) )
		While SM0->( !Eof() .and. M0_CODIGO == cEmpAnt )
			IF ( lRet := DuplicaMv( FWGETCODFILIAL , "MV_PONMES" ) )
				IF !( lRet := DuplicaMv( FWGETCODFILIAL , "MV_PAPONTA" ) )
					Break
				EndIF
			Else
				Break
			EndIF
			SM0->( dbSkip() )
		End While
	EndIF

End Sequence

IF !( lRet )
	Help( "" , 1 , "NOEXISTMVS" )
EndIF

( RestArea(  aAreaSMO ) , RestArea(  aArea ) )

Return( lRet )

/*/
зддддддддддбддддддддддддддбдддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o	   ЁPerApoConPad  ЁAutorЁ Marinaldo de Jesus  Ё Data Ё12/08/2002Ё
цддддддддддеддддддддддддддадддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁMonta Consulta Padrao para o Periodo de Apontamento  baseadaЁ
Ё          Ёno SPO                                      				Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais> 									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<void>                                                      Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso	   ЁGenerico 												    Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function PerApoConPad()
Return( ConPad1( NIL , NIL , NIL , "SPO" , NIL , NIL , .F. ) ) 

/*/
зддддддддддбддддддддддддддбдддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o	   ЁPutPerMvPar	  ЁAutorЁ Marinaldo de Jesus  Ё Data Ё26/08/2002Ё
цддддддддддеддддддддддддддадддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁCarregar o Periodo de Apontamento nas Variaveis dos   ParameЁ
Ё          Ёtros                                        				Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais> 									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais> 									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso	   ЁGenerico 												    Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function PutPerMvPar(cParGroup, cParDt1, cParDt2)
Local lRet			:= .T.
Local lConPad		:= .T.
Local cMvPar1		:= ""
Local cMvPar2		:= ""
Local oSX1			:= FWSX1Util():New()

DEFAULT cParGroup	:= ""
DEFAULT cParDt1		:= ""
DEFAULT cParDt2 	:= ""

If !Empty(cParGroup) .And. !Empty(cParDt1) .And. !Empty(cParDt2) .And. (lConPad := PerApoConPad())
	oSX1:AddGroup(cParGroup)
	oSX1:SearchGroup()

	cMvPar1 := "mv_par" + cParDt1
	cMvPar2 := "mv_par" + cParDt2

	If Len(oSX1:aGrupo) > 0 .And. Len(oSX1:aGrupo[1][2]) > 0
		If aScan(oSX1:aGrupo[1, 2], {|x| AllTrim(Lower(x:CX1_VAR01)) == cMvPar1 .And. x:CX1_TIPO == "D"}) > 0
			SetMVValue(cParGroup, cMvPar1, SPO->PO_DATAINI,.T.)
		EndIf
		If aScan(oSX1:aGrupo[1, 2], {|x| AllTrim(Lower(x:CX1_VAR01)) == cMvPar2 .And. x:CX1_TIPO == "D"}) > 0
			SetMVValue(cParGroup, cMvPar2, SPO->PO_DATAFIM,.T.)
		EndIf
		
	EndIf
EndIf
Return( lRet )

/*/
зддддддддддбддддддддддддддбдддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o	   ЁPonRetOpcBox  ЁAutorЁ Marinaldo de Jesus  Ё Data Ё10/09/2002Ё
цддддддддддеддддддддддддддадддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁRetornar as Opcoes para o X3_BOX                            Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё#PonRetOpcBox( nOpcBox )									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais> 									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso	   ЁSX3->X3_BOX   												Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function PonRetOpcBox( nOpcBox )

Local cOpcBox	:= ""

DEFAULT nOpcBox	:= 0

IF ( nOpcBox == 01 )
	cOpcBox += ( "S=" + STR0113 + ";"	)	//"Trabalhado"
	cOpcBox += ( "C=" + STR0109	+ ";"	)	//"Compensado"
	cOpcBox	+= ( "D=" + STR0110 + ";"	)	//"D.S.R"
	cOpcBox += ( "N=" + STR0112	     	)	//"Nao Trabalhado"
ElseIF ( nOpcBox == 02 )
	cOpcBox += ( "S=" + STR0113 + ";"	)	//"Trabalhado"
	cOpcBox += ( "C=" + STR0109	+ ";"	)	//"Compensado"
	cOpcBox	+= ( "D=" + STR0110 + ";"	)	//"D.S.R"
	cOpcBox += ( "N=" + STR0112	+ ";"	)	//"Nao Trabalhado"
	cOpcBox += ( "F=" + STR0111	   		)	//"Feriado"	
ElseIF ( nOpcBox == 03 )
	cOpcBox += ( "1=" + STR0120 + ";"	)	//"Normal"
	cOpcBox += ( "2=" + STR0110	+ ";"	)	//"D.S.R"
	cOpcBox	+= ( "3=" + STR0109 + ";"	)	//"Compensada"
	cOpcBox += ( "4=" + STR0111	+ ";"	)	//"Feriado"
	cOpcBox += ( "5=" + STR0121	+ ";"	)	//"Noturna Normal"
	cOpcBox += ( "6=" + STR0122	+ ";"	)	//"Noturna D.S.R"
	cOpcBox += ( "7=" + STR0123	+ ";"	)	//"Noturna Compensada"
	cOpcBox += ( "8=" + STR0124	     	)	//"Noturna Feriado"
ElseIF ( nOpcBox == 04 )
	cOpcBox += ( "1=" + STR0120 + ";"	)	//"Normal"
	cOpcBox += ( "2=" + STR0110	+ ";"	)	//"D.S.R"
	cOpcBox	+= ( "3=" + STR0109 + ";"	)	//"Compensada"
	cOpcBox += ( "4=" + STR0111	+ ";"	)	//"Feriado"
	cOpcBox += ( "5=" + STR0121	+ ";"	)	//"Noturna Normal"
	cOpcBox += ( "6=" + STR0122	+ ";"	)	//"Noturna D.S.R"
	cOpcBox += ( "7=" + STR0123	+ ";"	)	//"Noturna Compensada"
	cOpcBox += ( "8=" + STR0124	+ ";"  	)	//"Noturna Feriado"
	cOpcBox += ( "A=" + STR0078	+ ";"	)	//"Intervalo Normal"
	cOpcBox += ( "B=" + STR0079	+ ";"   )	//"Intervalo Noturna"
	cOpcBox += ( "C=" + STR0195	+ ";"   )	//"Intervalo DSR"
	cOpcBox += ( "D=" + STR0196	+ ";"   )	//"Intervalo Noturna DSR"
	cOpcBox += ( "E=" + STR0197	+ ";"   )	//"Intervalo Compensado"
	cOpcBox += ( "F=" + STR0198	+ ";"   )	//"Intervalo Noturna Compensado"
	cOpcBox += ( "G=" + STR0199	+ ";"   )	//"Intervalo Feriado"
	cOpcBox += ( "H=" + STR0200         )	//"Intervalo Noturna Feriado"
ElseIF ( nOpcBox == 05 )
	cOpcBox += ( "S=" + STR0125 + ";"	)	//'Sim'
	cOpcBox += ( "N=" + STR0126      	)	//'Nao'
ElseIF ( nOpcBox == 06 )
	cOpcBox += ( "1E=" + STR0080 + ";"	)	//'1a. Entrada'
	cOpcBox += ( "1S=" + STR0081 + ";"	)	//'1a. Saida  '
	cOpcBox += ( "2E=" + STR0082 + ";"	)	//'2a. Entrada'
	cOpcBox += ( "2S=" + STR0083 + ";"	)	//'2a. Saida  '
	cOpcBox += ( "3E=" + STR0084 + ";"	)	//'3a. Entrada'
	cOpcBox += ( "3S=" + STR0085 + ";"	)	//'3a. Saida  '
	cOpcBox += ( "4E=" + STR0086 + ";"	)	//'4a. Entrada'
	cOpcBox += ( "4S=" + STR0087      	)	//'4a. Saida  '
ElseIF ( nOpcBox == 07 )
	 cOpcBox += ( "1I=" + STR0088 + ";"	)	//'1o. Intervalo '
	 cOpcBox += ( "2I=" + STR0089 + ";"	)	//'2o. Intervalo '
	 cOpcBox += ( "3I=" + STR0090       )	//'3o. Intervalo '
ElseIF ( nOpcBox == 08 )
	 cOpcBox += ( "S=" + STR0125 + ";"	)	//'Sim'
	 cOpcBox += ( "N=" + STR0126 + ";" 	)	//'Nao'
	 cOpcBox += ( "D=" + STR0110 + ";"	)	//"D.S.R"
	 cOpcBox += ( "C=" + STR0109      	)	//"Compensado"
ElseIF ( nOpcBox == 09 )
	 cOpcBox += ( "T=" + STR0127 + ";"	)	//"Total"
	 cOpcBox += ( "P=" + STR0128      	)	//"Parcial"
ElseIF ( nOpcBox == 10 )
	 cOpcBox += ( "1=" + STR0129 + ";"	)	//"Provento"
	 cOpcBox += ( "2=" + STR0130 + ";"	)	//"Desconto"
	 cOpcBox += ( "3=" + STR0131      	)	//"Base"
ElseIF ( nOpcBox == 11 )
	 cOpcBox += ( "S=" + STR0132 + ";"	)	//"Semanal"
	 cOpcBox += ( "Q=" + STR0133 + ";"	)	//"Quinzenal"
	 cOpcBox += ( "M=" + STR0134      	)	//"Mensal"
ElseIF ( nOpcBox == 12 )
	 cOpcBox += ( "D=" + STR0135 + ";"	)	//"Diario"	 
	 cOpcBox += ( "S=" + STR0132 + ";"	)	//"Semanal"
	 cOpcBox += ( "Q=" + STR0133 + ";"	)	//"Quinzenal"
	 cOpcBox += ( "M=" + STR0134      	)	//"Mensal"
ElseIF ( nOpcBox == 13 )
	 cOpcBox += ( "A=" + STR0136 + ";"	)	//"Anterior"	 
	 cOpcBox += ( "P=" + STR0137 + ";"	)	//"Posteior"
	 cOpcBox += ( "T=" + STR0138		)	//"Todos"
ElseIF ( nOpcBox == 14 )
	 cOpcBox += ( "H=" + STR0139 + ";"	)	//"Horas"	 
	 cOpcBox += ( "V=" + STR0140 + ";"	)	//"Valor"
	 cOpcBox += ( "D=" + STR0141		)	//"Dias"
ElseIF ( nOpcBox == 15 )
	 cOpcBox += ( "A=" + STR0142 + ";"	)	//"Atrasos"	 
	 cOpcBox += ( "S=" + STR0143 + ";"	)	//"Saidas Antecipadas"
	 cOpcBox += ( "H=" + STR0144 + ";"	)	//"Horas Extras"
	 cOpcBox += ( "D=" + STR0145 + ";"	)	//"Descanso Semanal Remunerado"
	 cOpcBox += ( "F=" + STR0146 + ";"	)	//"Faltas"
	 cOpcBox += ( "N=" + STR0147 + ";"	)	//"Adicional Noturno"
	 cOpcBox += ( "9=" + STR0148      	)	//"Nona Hora"
ElseIF ( nOpcBox == 16 )
	 cOpcBox += ( "0=" + STR0149 + ";"	)	//"Fechado"
	 cOpcBox += ( "1=" + STR0150      	)	//"Aberto"
ElseIF ( nOpcBox == 17 )
	 cOpcBox += ( "S=" + STR0151 + ";"	)	//"Sistema"
	 cOpcBox += ( "U=" + STR0152     	)	//"Usuario"
ElseIF ( nOpcBox == 18 )
	 cOpcBox += ( "1=" + STR0129 + ";"	)	//"Provento"
	 cOpcBox += ( "2=" + STR0130 + ";"	)	//"Desconto"
	 cOpcBox += ( "3=" + STR0216 + ";"	)	//"Base ( Provento )"
	 cOpcBox += ( "4=" + STR0217        )	//"Base ( Desconto )"
ElseIf ( nOpcBox == 19 )
	 cOpcBox += ( "2=" + STR0016 + ";"	)	//"lunes"
	 cOpcBox += ( "3=" + STR0017 + ";"	)	//"martes"
	 cOpcBox += ( "4=" + STR0018 + ";"	)	//"miercoles"
	 cOpcBox += ( "5=" + STR0019 + ";"	)	//"jueves"	 
	 cOpcBox += ( "6=" + STR0020 + ";"	)	//"viernes" 
 	 cOpcBox += ( "7=" + STR0021 + ";"	)	//"sabado"	 
	 cOpcBox += ( "1=" + STR0015 + ";"	)	//"domingo"	  
EndIF

Return( cOpcBox )

/*/
зддддддддддбддддддддддддддддбдддддбдддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁMaxP8PGOrdVld	ЁAutorЁMarinaldo de Jesus Ё Data Ё24/01/2003Ё
цддддддддддеддддддддддддддддадддддадддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁValidar o Numero de Ordens possiveis para o SP8 e SPG conforЁ
Ё          Ёme Periodo de Apontamento									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGenerico													Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function MaxP8PGOrdVld( dPerIni , dPerFim , lShowHelp , nOrdens )
         
Local cMsg			:= ""
Local lOrdensOk		:= .F.
Local nDias			:= 0

DEFAULT dPerIni		:= Ctod("//")
DEFAULT dPerFim		:= Ctod("//")
DEFAULT lShowHelp	:= .T.

nDias 	:= ( ( dPerFim - dPerIni ) + 1 )
nOrdens	:= Val( Replicate( "9" , __nTamP8Ordem ) )
Begin Sequence
	IF !( lOrdensOk := ( nDias <= nOrdens ) )
		cMsg := STR0160 //"O numero de dias do periodo ultrapassou o numero de ordens permitidas para o SP8"
		Break
	EndIF
	nOrdens	:= Val( Replicate( "9" , __nTamPGOrdem ) )
	IF !( lOrdensOk := ( nDias <= nOrdens ) )
		cMsg := STR0161 //"O numero de dias do periodo ultrapassou o numero de ordens permitidas para o SPG"
		Break
	EndIF
End Sequence	

IF ( lShowHelp )
	IF ( !( lOrdensOk ) .and. !Empty( cMsg ) )
		cMsg += CRLF
		cMsg += STR0162 + AllTrim( Str( nDias ) )	//'Numero de dias do Periodo:'
	 	cMsg += CRLF
	 	cMsg += STR0163 + AllTrim( Str( nOrdens ) )	//'Numero Maximo de Ordens:
		MsgInfo( OemToAnsi( cMsg ) , OemToAnsi( STR0159 ) ) //"Aten┤└o!"
	EndIF
EndIF

Return( lOrdensOk  )

/*/
зддддддддддбддддддддддддддддбдддддбдддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁPonIncDate		ЁAutorЁMarinaldo de Jesus Ё Data Ё28/01/2003Ё
цддддддддддеддддддддддддддддадддддадддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁIncrementa Periodo de Acordo com os dias do Periodo AnteriorЁ
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGenerico													Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function PonIncDate( dPerIni , dPerFim  )

Local dDateAux
Local nDias

DEFAULT dPerIni	:= Ctod("//")
DEFAULT dPerFim	:= Ctod("//")

IF ( dPerFim < dPerIni )
	dDateAux	:= dPerIni
	dPerIni		:= dPerFim
	dPerFim		:= dDateAux
EndIF

nDias		:= ( dPerFim - dPerIni )
dPerIni 	:= ( dPerFim + 1  )
dPerFim 	:= ( dPerIni + nDias )

Return( nDias )

/*/
зддддддддддбддддддддддддддддбдддддбдддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁPonDecDate		ЁAutorЁMarinaldo de Jesus Ё Data Ё22/01/2004Ё
цддддддддддеддддддддддддддддадддддадддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁDecrementa Periodo de Acordo com os dias do Periodo AnteriorЁ
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGenerico													Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function PonDecDate( dPerIni , dPerFim  )

Local dDateAux
Local nDias

DEFAULT dPerIni	:= Ctod("//")
DEFAULT dPerFim	:= Ctod("//")

IF ( dPerFim < dPerIni )
	dDateAux	:= dPerIni
	dPerIni		:= dPerFim
	dPerFim		:= dDateAux
EndIF

nDias		:= ( dPerFim - dPerIni )
dPerFim 	:= ( dPerIni - 1 )
dPerIni 	:= ( dPerFim - nDias )

Return( nDias )

/*/
зддддддддддбддддддддддддддддбдддддбдддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁPonDelRecnos	ЁAutorЁMarinaldo de Jesus Ё Data Ё12/03/2003Ё
цддддддддддеддддддддддддддддадддддадддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁDeletar Registros conforme Alias e Array aRecnos            Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGenerico													Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function PonDelRecnos(	cAlias			,;	//01 -> Alias
						aRecnos 		,;	//02 -> Array com os Recnos
						bCondDele		,;	//03 -> Bloco com a Condicao para Delecao
						uParbCondDele	,;	//04 -> Parametro para o Bloco 
						aMsMmCpos		,;	//05 -> Array com os campos Memo para Delecao
						cAliasMsMm		 ;	//06 -> Alias para a MsMm
					)
Return(DelRecnos(@cAlias,@aRecnos,@bCondDele,@uParbCondDele,@aMsMmCpos,@cAliasMsMm))

/*/
зддддддддддбддддддддддддбдддддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁPonModPer	Ё Autor ЁMarinaldo de Jesus    Ё Data Ё06/09/2002Ё
цддддддддддеддддддддддддадддддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁPossibilitar a Alteracao do parametro MV_PERAPONTA e a  conseЁ
Ё          Ёsequente atualizacao do MV_PONMES							 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁNIL															 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁObserva┤└oЁ                                                      	     Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGenerico													 Ё
юддддддддддаддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function PonModPer( lModPer , cFil )

DEFAULT lModPer := .T.

IF ( lModPer )
	lModPer := PonActModPer( cFil )
EndIF

Return( MbrChgLoop( .F. ) )

/*/
зддддддддддбддддддддддддбдддддддбддддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁPonActModPerЁ Autor ЁMarinaldo de Jesus    Ё Data Ё06/09/2002Ё
цддддддддддеддддддддддддадддддддаддддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁPossibilitar a Alteracao do parametro MV_PERAPONTA e a  conseЁ
Ё          Ёsequente atualizacao do MV_PONMES							 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁNIL															 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁObserva┤└oЁ                                                      	     Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁSIGAPON     												 Ё
юддддддддддаддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function PonActModPer( cFil )

Local aSvKeys		:= GetKeys()
Local bSet15		:= { || NIL }
Local bSet24		:= { || NIL }
Local cAntDiaIniFim	:= Space( 05 )
Local cAtuDiaIniFim	:= Space( 05 )
Local cNewPerPutMv	:= ""
Local cSvFilAnt		:= cFilAnt
Local cMsgPaponta	:= ""
Local dAntIniPer	:= Ctod("//")
Local dAntFimPer	:= Ctod("//")
Local dAtuIniPer	:= Ctod("//")
Local dAtuFimPer	:= Ctod("//")
Local dIniPonMes	:= Ctod("//")
Local dFimPonMes	:= Ctod("//")
Local lModPerOk		:= .F.
Local lModPonMes	:= .F.
Local lPapontaPer	:= .F.
Local lVisualizar	:= .F.
Local nOpcModPer	:= 0
Local oDlg 			:= NIL
Local oFont			:= NIL
Local oGroup1		:= NIL
Local oGroup2		:= NIL
Local oGroup3		:= NIL
//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
//Ё DeclaraГЦo de arrays para dimensionar tela		             Ё
//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
Local aAdvSize		:= {}
Local aInfoAdvSize	:= {}
Local aObjSize		:= {}
Local aObjCoords	:= {}

DEFAULT cFil		:= cSvFilAnt

cFilAnt := IF( !Empty( cFil ) , cFil , cFilAnt )
       
IF ( Type( "Inclui" ) == "L" )
	Inclui := .F.
EndIF

IF !( Type( "cCadastro" ) == "C" )
	Private cCadastro := ""
EndIF

IF !( ( nOpcModPer := PonOpcModPer() ) == 0 )

	cAntDiaIniFim := GetPaponta( cFil )

	GetPonMesDat( @dIniPonMes , @dFimPonMes , cFilAnt )

	lModPonMes	:= ( nOpcModPer == 2 )
	lVisualizar	:= ( nOpcModPer == 3 )

	IF ( lPapontaPer := PerCompleto( cAntDiaIniFim ) )
		dAntIniPer		:= Stod( Left(	cAntDiaIniFim , 08 ) )
		dAntFimPer		:= Stod( Right( cAntDiaIniFim , 08 ) )
		cAntDiaIniFim	:= Space( 05 )
	Else
		cAntDiaIniFim	:= Left( cAntDiaIniFim, 02 ) + '/' + Right( cAntDiaIniFim , 02 )
	EndIF
	
	/*
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Monta as Dimensoes dos Objetos         					   Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды*/
	aAdvSize			:= MsAdvSize()
	aAdvSize[5]			:=	420 //horizontal
	aAdvSize[3]			:=	210 // LARGURA
	aAdvSize[4]			:=	90  // ALTURA
	aAdvSize[6]			:=  230 //Vertical
	aInfoAdvSize	:= { aAdvSize[1] , aAdvSize[2] , aAdvSize[3] , aAdvSize[4] , 2 , 2 }
	aAdd( aObjCoords , { 000 , 30 , .T. , .F.  } )
	aAdd( aObjCoords , { 000 , 30 , .T. , .F.  } )
	aAdd( aObjCoords , { 000 , 30 , .T. , .F.  } )
	aObjSize			:= MsObjSize( aInfoAdvSize , aObjCoords )
	
	DEFINE FONT oFont NAME "Arial" SIZE 0,-11 BOLD
	DEFINE MSDIALOG oDlg TITLE OemToAnsi( cCadastro + " - " + STR0167 ) From aAdvSize[7],0 TO aAdvSize[6],aAdvSize[5] OF GetWndDefault() PIXEL	//"Modificar Periodo de Apontamento"
	
		@ aObjSize[1][1],aObjSize[1][2] GROUP oGroup1 TO aObjSize[1][3],aObjSize[1][4] LABEL OemToAnsi(STR0168) OF oDlg PIXEL		//""Periodo Anterior do Parametro MV_PAPONTA"
		oGroup1:oFont:=oFont

		IF !( lPapontaPer )
			@ aObjSize[1][1]+10,aObjSize[1][2]+10 SAY OemToAnsi( STR0164 )	SIZE	50,10 OF oDlg PIXEL FONT oFont	//"Dia Inicial/Final"
			@ aObjSize[1][1]+10,aObjSize[1][2]+55 MSGET cAntDiaIniFim		SIZE	50,10 OF oDlg PIXEL FONT oFont WHEN ( .F. ) PICTURE "99/99" 
	    Else
			@ aObjSize[1][1]+10,aObjSize[1][2]+10 SAY OemToAnsi( STR0165 )	SIZE	50,10 OF oDlg PIXEL FONT oFont	//"Anterior"
			@ aObjSize[1][1]+10,aObjSize[1][2]+55 MSGET dAntIniPer			SIZE	50,10 OF oDlg PIXEL FONT oFont	WHEN ( .F. )  HASBUTTON
			@ aObjSize[1][1]+10,aObjSize[1][2]+120 MSGET dAntFimPer			SIZE	50,10 OF oDlg PIXEL FONT oFont	WHEN ( .F. ) HASBUTTON
	    EndIF
	    
		IF !( lVisualizar )

			@ aObjSize[2][1],aObjSize[2][2] GROUP oGroup2 TO aObjSize[2][3],aObjSize[2][4] LABEL OemToAnsi(STR0169) OF oDlg PIXEL			//"Novo Periodo para o Parametro MV_PAPONTA"
			oGroup2:oFont:=oFont
		
			IF !( lModPonMes )
				@ aObjSize[2][1]+10,aObjSize[2][2]+10 	SAY OemToAnsi( STR0164 )	SIZE	50,10 OF oDlg PIXEL FONT oFont	//"Dia Inicial/Final"
				@ aObjSize[2][1]+10,aObjSize[2][2]+55 	MSGET cAtuDiaIniFim			SIZE	50,10 OF oDlg PIXEL FONT oFont	WHEN( IF( !( lModPonMes ) , IF( lVisualizar , !( lVisualizar ) , !( lModPonMes ) ) , .F. ) ) PICTURE "99/99"
			Else
				@ aObjSize[2][1]+10,aObjSize[2][2]+10  SAY OemToAnsi( STR0165 )	SIZE	50,10 OF oDlg PIXEL FONT oFont	//"Periodo"
				@ aObjSize[2][1]+10,aObjSize[2][2]+55  MSGET dAtuIniPer		   		SIZE	50,10 OF oDlg PIXEL FONT oFont	WHEN( IF( lModPonMes , IF( lVisualizar , !( lVisualizar ) , lModPonMes ) , .F. ) )	 HASBUTTON
				@ aObjSize[2][1]+10,aObjSize[2][2]+120 MSGET dAtuFimPer				SIZE	50,10 OF oDlg PIXEL FONT oFont	WHEN( IF( lModPonMes , IF( lVisualizar , !( lVisualizar ) , lModPonMes ) , .F. ) )	 HASBUTTON
			EndIF
        
		ELSE
			aObjSize[3] := aClone(aObjSize[2])
		EndIF
	
		@ aObjSize[3][1],aObjSize[3][2] GROUP oGroup3 TO aObjSize[3][3],aObjSize[3][4] LABEL OemToAnsi(STR0178) OF oDlg PIXEL			//"Periodo Atual do parametro MV_PONMES"
		oGroup3:oFont:=oFont

		@ aObjSize[3][1]+10,aObjSize[3][2]+10  MSGET dIniPonMes	SIZE	50,10 OF oDlg PIXEL FONT oFont	WHEN( .F. )	 HASBUTTON
		@ aObjSize[3][1]+10,aObjSize[3][2]+75 MSGET dFimPonMes	SIZE	50,10 OF oDlg PIXEL FONT oFont	WHEN( .F. )	 HASBUTTON
			
		IF ( lVisualizar )
			bSet15	:= { || oDlg:End() }
		Else
			bSet15	:= { || IF( lModPerOk := PonOkModPer( StrTran( cAtuDiaIniFim , "/" , "" ) , dAtuIniPer , dAtuFimPer , lModPonMes ) , oDlg:End() , lModPerOk ) }
		EndIF
		bSet24		:= { || oDlg:End() }
	
	ACTIVATE MSDIALOG oDlg ON INIT EnchoiceBar( oDlg , bSet15 , bSet24  ) CENTERED  
	
	IF ( ( lModPerOk ) .and. !( lVisualizar ) )
	    IF ( lModPonMes )
			cNewPerPutMv := ( Dtos( dAtuIniPer ) + "/" + Dtos( dAtuFimPer ) )
			PutMvFil( "MV_PAPONTA"	, cNewPerPutMv  , cFilAnt )
			PutMvFil( "MV_PONMES"	, cNewPerPutMv  , cFilAnt )
	    Else
	    	cNewPerPutMv := cAtuDiaIniFim
	    	PutMvFil( "MV_PAPONTA"	, cNewPerPutMv  , cFilAnt )
	    	PutMvFil( "MV_PONMES"	, "" , cFilAnt )
			lModPerOk := CheckPonMes( @dAtuIniPer , @dAtuFimPer , .F. , .F. , .T. , cFilAnt , .F. , NIL )
	    	IF ( lModPerOk )
	    		cMsgPaponta := MsgPaponta( cNewPerPutMv , dAtuIniPer , dAtuFimPer , cFilAnt )
	    	EndIF
	    EndIF
		//"Caso as Marca┤■es j═ tenham sido apontadas, ser═ necess═rio for┤ar o Reapontamento para ajust═-las ao novo periodo."
		IF Empty( cMsgPaponta )
			cMsgPaponta := ( Dtoc( dAtuIniPer ) + " - " + Dtoc( dAtuFimPer ) + CRLF + CRLF + STR0177 )
		Else
			cMsgPaponta := ( Dtoc( dAtuIniPer ) + " - " + Dtoc( dAtuFimPer ) + CRLF + CRLF + STR0177 + CRLF + CRLF + cMsgPaponta )
		EndIF
		MsgInfo( OemToAnsi( cMsgPaponta ) , OemToAnsi( STR0176 ) )	//"Novo Periodo do Ponto em Aberto"
	EndIF
	
	IF ( Type( "Inclui" ) == "L" )
		Inclui := .F.
	EndIF

EndIF

RestKeys( aSvKeys , .T. )

cFilAnt := cSvFilAnt

Return( lModPerOk )

/*/
зддддддддддбддддддддддддддддбдддддбдддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o	   ЁPonOpcModPer 	ЁAutorЁMarinaldo de Jesus Ё Data Ё04/03/2002Ё
цддддддддддеддддддддддддддддадддддадддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁDialogo com as Opcoes para Modificacao do Periodo 			Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   ЁPonOpcModPer()												Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ 															Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁNumero da Opcao da Mudanca do Periodo:1 -> Dia Inicial/FinalЁ
Ё          Ё                                      2 -> Periodo          Ё
Ё          Ё                                      3 -> Visualizar		Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso	   ЁPonModPer()											    	Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function PonOpcModPer()

Local aSvKeys		:= GetKeys()
Local bSet15		:= { || lOpcOk := .T. , RestKeys( aSvKeys , .T. ) ,  oDlg:End() }
Local bSet24		:= { || RestKeys( aSvKeys , .T. ) , oDlg:End() }
Local nOpcModPer	:= 1
Local lOpcOk		:= .F.
Local oRadio		:= NIL
Local oDlg			:= NIL
Local oGroup		:= NIL
Local oFont			:= NIL
//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
//Ё DeclaraГЦo de arrays para dimensionar tela		             Ё
//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
Local aAdvSize		:= {}
Local aInfoAdvSize	:= {}
Local aObjSize		:= {}
Local aObjCoords	:= {}

/*
здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Monta as Dimensoes dos Objetos         					   Ё
юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды*/
aAdvSize			:= MsAdvSize()
aAdvSize[5]			:=	420 //horizontal
aAdvSize[3]			:=	212 // LARGURA
aAdvSize[4]			:=	62  // ALTURA
aAdvSize[6]			:=  150 //Vertical
aInfoAdvSize	:= { aAdvSize[1] , aAdvSize[2] , aAdvSize[3] , aAdvSize[4] , 2 , 2 }
aAdd( aObjCoords , { 000 , 000 , .T. , .T.  } )
aObjSize			:= MsObjSize( aInfoAdvSize , aObjCoords )

DEFINE FONT oFont NAME "Arial" SIZE 0,-11 BOLD
DEFINE MSDIALOG oDlg FROM  aAdvSize[7],0 TO aAdvSize[6],aAdvSize[5] TITLE OemToAnsi( STR0167 ) OF GetWndDefault() PIXEL	//"Modificar Periodo de Apontamento"

	@ aObjSize[1][1],aObjSize[1][2]	GROUP oGroup TO aObjSize[1][3],aObjSize[1][4] LABEL OemToAnsi(STR0166) OF oDlg PIXEL	//"Escolha a Op┤└o para a Modifica┤└o do Parametro:"
	oGroup:oFont:=oFont
	
	@ aObjSize[1][1]+10,aObjSize[1][2]+10	RADIO oRadio VAR nOpcModPer ITEMS;
					 	OemToAnsi(STR0164)	,;			//"Dia Inicial/Final"
						OemToAnsi(STR0165)	,;			//"Periodo"
						OemToAnsi(STR0179)	 ;			//'Apenas Visualizar'
						SIZE 115,010 OF oDlg PIXEL
	
	oDlg:lEscClose := .F. //Nao permite sair ao se pressionar a tecla ESC.	

ACTIVATE MSDIALOG oDlg ON INIT EnchoiceBar( oDlg , bSet15 , bSet24 ) CENTERED 
RestKeys( aSvKeys , .T. )

IF !( lOpcOk )
	nOpcModPer := 0
EndIF

Return( nOpcModPer )

/*/
зддддддддддбддддддддддддддддбдддддбдддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o	   ЁPonOkModPer  	ЁAutorЁMarinaldo de Jesus Ё Data Ё04/03/2002Ё
цддддддддддеддддддддддддддддадддддадддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁValidar o Novo Periodo de Apontamento             			Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   ЁPonOkModPer()												Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso	   ЁPonModPer()											    	Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function PonOkModPer( cPeriodo , dPerIni , dPerFim , lPeriodo )

Local cMsg			:= ""
Local lOK			:= .F.

Begin Sequence

	IF ( lPeriodo )
		IF !( lOk := ( !Empty( dPerIni ) .and. !Empty( dPerFim ) ) )
			cMsg := STR0173	// "Data Inicial ou Data Final em Branco"
			Break
		EndIF
		IF !( lOk := ( dPerFim >= dPerIni ) )
			cMsg := STR0172 //"Data Inicial maior que Data Final"
			Break
		EndIF
		IF !( lOk := MaxP8PGOrdVld( dPerIni , dPerFim ) )
			cMsg := ""
			Break
		EndIF
		IF !( lOk := ValidPerSPO( cFilAnt , dPerIni , dPerFim , .T. , .F. ) )
			cMsg := STR0171	//"Periodo Ja Cadastrado no SPO ( Cadastro de Periodos )"
			Break
		EndIF
	Else
		IF !( lOk := ( !Empty( cPeriodo ) ) )
			cMsg := STR0170	//"O Periodo nao pode ficar em Branco"
			Break
		EndIF
	EndIF

End Sequence

IF ( !( lOk ) .and. !Empty( cMsg ) )
	MsgInfo( OemToAnsi( cMsg ) , OemToAnsi( STR0174 + " - " + STR0175  ) ) //"Aten┤└o!"###"Existem Inconsistencias a serem verificadas."
EndIF

Return( lOk )

/*/
зддддддддддбддддддддддддддддбдддддбдддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o	   ЁMsgPaponta  	ЁAutorЁMarinaldo de Jesus Ё Data Ё01/07/2004Ё
цддддддддддеддддддддддддддддадддддадддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁVerifica se Existe Alguma Inconsistencia no preenchimento doЁ
Ё          ЁMV_PAPONTA e Emite Mensagem correspondente				    Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<vide parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso	   ЁPonModPer()											    	Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function MsgPaponta( cPerAponta , dAtuIniPer , dAtuFimPer , cFil )

Local cMsgPaponta	:= ""
Local lMaisDias		:= .F.

Local cMsgIniPer
Local cMsgFimPer
Local cMesAux
Local cAnoAux
Local dDataAux
Local nDiaAux
Local nMesAux
Local nAnoAux
Local nUltDiaMes
Local nDiaIni
Local nDiaFim
Local nIniDif
Local nFimDif

Begin Sequence

	IF PerCompleto( @cPerAponta , cFil )
		Break
	EndIF

	IF !PapontaOk( cPerAponta , NIL , NIL , cFil )
		Help( "" , 1 , "PERNCAD" )
		Break
	EndIF

	nDiaIni := Day( dAtuIniPer )
	nDiaFim := Day( dAtuFimPer )

	IF ( AnoMes( dAtuIniPer ) == AnoMes( dAtuFimPer ) )

 		IF ( nDiaIni > 1 )
			nIniDif := ( nDiaIni - 1 )
			IF ( nIniDif > 0 )
				cMsgIniPer	:= Day2Str( nIniDif )
				cMsgIniPer	+= " "
				cMsgIniPer	+= STR0210	//"dia(s), no Inicio do perМodo,"
			EndIF
		EndIF

 		nUltDiaMes := f_UltDia( Ctod( "01/" + Month2Str( dAtuFimPer ) + "/" + Year2Str( dAtuFimPer ) , "DDMMYYYY" ) )
 		IF ( nDiaFim < nUltDiaMes )
			nFimDif := ( nUltDiaMes - nDiaFim )
			IF ( nFimDif > 0 )
				IF !Empty( cMsgIniPer )
					cMsgIniPer += " "
					cMsgIniPer += STR0211 //"e"
					cMsgIniPer += " "
				EndIF
				cMsgFimPer := Day2Str( nFimDif )
				cMsgFimPer += " "
				cMsgFimPer += STR0212	//"dia(s), no Final do perМodo,"
			EndIF
		EndIF

 		Break

 	EndIF

	IF ( nDiaIni > nDiaFim )

		nFimDif := ( ( nDiaIni - nDiaFim ) - 1 )
		IF ( nFimDif > 0 )
			cMsgFimPer := Day2Str( nFimDif )
			cMsgFimPer += " "
			cMsgFimPer += STR0212	//"dia(s), no Final do perМodo,"
		EndIF
		
		Break

	EndIF

	IF ( nDiaIni < nDiaFim )

		nUltDiaMes	:= f_UltDia( Ctod( "01/" + Month2Str( dAtuIniPer ) + "/" + Year2Str( dAtuIniPer ) , "DDMMYYYY" ) )
		nIniDif		:= ( ( nUltDiaMes - nDiaIni ) + 1 )
		nFimDif		:= nDiaFim
		IF ( lMaisDias := ( ( nIniDif + nFimDif ) > nUltDiaMes ) )
			nFimDif := ( ( nIniDif + nFimDif ) - nUltDiaMes )
			cMsgFimPer := STR0214 //"mais"
			cMsgFimPer += " "
			cMsgFimPer += Day2Str( nFimDif )
			cMsgFimPer += " "
			cMsgFimPer += STR0212	//"dia(s), no Final do perМodo,"
			Break
		EndIF

		nDiaAux		:= ( nDiaIni - 1 )
		nMesAux		:= ( Month( dAtuFimPer ) + 1 )
		nAnoAux		:= Year( dAtuFimPer )
		IF ( nMesAux > 12 )
			nMesAux := 1
			++nAnoAux
		EndIF
		cMesAux		:= Month2Str( nMesAux )
		cAnoAux		:= Year2Str( nAnoAux )
		dDataAux	:= Ctod( Day2Str( nDiaAux ) + "/" + cMesAux + "/" + cAnoAux , "DDMMYYYY" )
		While Empty( dDataAux )
			dDataAux := Ctod( Day2Str( --nDiaAux ) + "/" + cMesAux + "/" + cAnoAux , "DDMMYYYY" )
		End While
		nUltDiaMes	:= f_UltDia( Ctod( "01/" + Month2Str( dAtuFimPer ) + "/" + Year2Str( dAtuFimPer ) , "DDMMYYYY" ) )
		nFimDif		:= ( nUltDiaMes - nDiaFim )
		nFimDif		+= Day( dDataAux )
		IF ( nFimDif > 0 )
			cMsgFimPer := Day2Str( nFimDif )
			cMsgFimPer += " "
			cMsgFimPer += STR0212	//"dia(s), no Final do perМodo,"
		EndIF
		
		Break

	EndIF

End Sequence

IF !Empty( cMsgIniPer ) .or. !Empty( cMsgFimPer )
	cMsgPaponta := STR0209	//"A ConfiguraГЦo Atual do MV_PAPONTA farА com que"
	cMsgPaponta += " "
	IF !Empty( cMsgIniPer )
		cMsgPaponta += cMsgIniPer
	EndIF	
	IF !Empty( cMsgFimPer )
		cMsgPaponta += cMsgFimPer
	EndIF	
	cMsgPaponta += " "
	IF !( lMaisDias )
		cMsgPaponta += STR0213	//"seja(m) desconsiderado(s) pelo sistema."
	Else
		cMsgPaponta += STR0215	//"seja(m) considerados(s) pelo sistema."
	EndIF	
	cMsgPaponta := ( STR0208 + CRLF + CRLF + cMsgPaponta ) //"AtenГЦo!!!!"
EndIF	

Return( cMsgPaponta )

/*/
зддддддддддбдддддддддддддддбдддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁInitP8PgOrdSizeЁAutorЁMarinaldo de Jesus   Ё Data Ё03/06/2002Ё
цддддддддддедддддддддддддддадддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁInicializa as Statics __nTamP8PgOrdSize e __nTamP8PgOrdSize  Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁNIL                                                  	     Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁObserva┤└oЁ                                                      	     Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGenerico 													 Ё
юддддддддддаддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function InitP8PgOrdSize(nOpc)

Local nTam

DEFAULT nOpc := 1

IF ( Select("SX3") > 0 )
	IF ( nOpc == 1 )
		nTam := GetSx3Cache( "P8_ORDEM" , "X3_TAMANHO" )
	Else
		nTam := GetSx3Cache( "PG_ORDEM" , "X3_TAMANHO" )
	EndIF
EndIF
DEFAULT nTam := 2

Return( nTam )

/*/
зддддддддддбддддддддддддддддбдддддбдддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o	   ЁPonLockRegs		ЁAutorЁMarinaldo de Jesus Ё Data Ё11/06/2003Ё
цддддддддддеддддддддддддддддадддддадддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁTentativa de Lock em Varios Registros             			Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁlLocked                  									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso	   ЁGenerico   											    	Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function PonLockRegs(	cAlias			,;	//01 -> Alias onde os Registros devera haver Lock dos Registros
						aRegsLock		,;	//02 -> Array com os Recnos para Lock
						aKeysCode		,;	//03 -> Array com as Chaves para MayIUseCode
						nTentaLocks		,;	//04 -> Numero de Tentativas de Lock
						nSecondsWait	,;	//05 -> Segundos a aguardar para nova tentativa
						lMayIUseCode	,;	//06 -> Se ira utilizar MayIUseCode
						nMaxLocks		 ;	//07 -> Numero maximo de Locks
					)
Return(LockRegsCode(@cAlias,@aRegsLock,@aKeysCode,@nTentaLocks,@nSecondsWait,@lMayIUseCode,@nMaxLocks))

/*/
зддддддддддбддддддддддддддддбдддддбдддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o	   ЁPonFreeLocks    ЁAutorЁMarinaldo de Jesus Ё Data Ё11/06/2003Ё
цддддддддддеддддддддддддддддадддддадддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁChamada da FreeLocks                                        Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁNIL                        									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso	   ЁGenerico   											    	Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function PonFreeLocks( cAlias , nReg , lFreeUseCode , cUseCode )
Return( FreeLocks( cAlias , nReg , lFreeUseCode , cUseCode ) )
/*/
зддддддддддбддддддддддддддддбдддддбдддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o	   ЁfDemissao       ЁAutorЁMauricio MR        Ё Data Ё27/01/2005Ё
цддддддддддеддддддддддддддддадддддадддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁVerifica a Situacao de Demissao do Funcionario              Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁNIL                        									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso	   ЁSIGAPON   											    	Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function fDemissao(cSituacao, cRescRais)
Local cRet    
If cRescRais$'30/31'
	cRet:= 'T'
Else 
	cRet:= cSituacao
Endif   
Return( cRet )

/*/
зддддддддддбдддддддддддддбддддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁfVerTabRF0   ЁAutor ЁMauricio MR          Ё Data Ё05/10/05  Ё
цддддддддддедддддддддддддаддддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁVerifica a Existencia da tabela de Pre-abonos e se a mesma  Ё
Ё          Ёpossui registros.                                           Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё< Vide Parametros Formais >								  	Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ< Vide Parametros Formais >								  	Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
function  fVerTabRF0()
Local lRet		:= .F.
Local lVazio	:= .T.

/*/
здддддддддддддддддддддддддддддддддддддддддддддддддд©
ЁVerifica a Existencia da Tabela RF0 e se a mesma  Ё
Ёpossui conteudo. Somente nessas condicoes sera	   Ё
Ёverficada a existencia de pre-abonos.			   Ё
юдддддддддддддддддддддддддддддддддддддддддддддддддды/*/
lRet:= Sx2ChkTable( "RF0",, @lVazio) 	

lRet:= ( lRet .AND. !lVazio)

Return ( lRet )

/*/
зддддддддддбддддддддддддддбдддддддбдддддддддддддддддддбддддддбдддддддддд©
ЁMetodo    ЁLoadCalError  Ё Autor Ё Mauricio MR       Ё Data Ё05/02/2008Ё
цддддддддддеддддддддддддддадддддддадддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁCarrega tabelas de erros para a rotina do calendario        Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁPar┐metrosЁ															Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   ЁLoadCalError()				 								Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁEm cada rotina em que se deseja manter controle de erros    Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/ 
Function LoadCalError()  

Local aMsg  := {}

aAdd(aMsg, { "01", STR0007 } ) //"No se encontro la secuencia para la fecha "
aAdd(aMsg, { "02", STR0008 } ) //"No se encontro el turno "   
aAdd(aMsg, { "03", STR0009 } ) //"No se encontro la regla "
aAdd(aMsg, { "04", STR0219 } ) //"Periodo nao encontrado "
aAdd(aMsg, { "05", STR0220 } ) //"Nao e possivel gerar calendario por demanda, verificar parametro MV_CALDEM "
aAdd(aMsg, { "06", STR0221 } ) //"Nao foi possivel gravar calendario "
aAdd(aMsg, { "07", STR0223 } ) //"NЦo foi possМvel gerar o calendАrio para o perМodo de: "
aAdd(aMsg, { "08", STR0224 } ) //"Somente И possМvel gerar calendАrio para perМodos consecutivos."

Return(aClone(aMsg))
/*/
эээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤┘o	 ЁfPnVldProcЁ Autor Ё Igor Franzoi		    Ё Data Ё17/04/2008Ё╠╠
╠╠цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤┘o ЁValidacao do processo digitado nos perguntes utilizados nos Ё╠╠
╠╠|			 |nos relatorios											  Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁSintaxe	 Ё fPnVldProc												  Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠Ё Uso		 Ё Generico   												  Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ/*/
Function fPnVldProc( cTip )

Local lRet := .F.

If ( cTip == "A" )
	lRet := ( ExistCpo("RCJ") .and. NaoVazio() )
Else
    lRet := ExistCpo("RCJ")
EndIf

Return lRet

/*/
эээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤┘o	 ЁfPnVldPer Ё Autor Ё Igor Franzoi		    Ё Data Ё17/04/2008Ё╠╠
╠╠цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤┘o ЁValidacao do processo digitado nos perguntes utilizados nos Ё╠╠
╠╠|			 |nos relatorios											  Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁSintaxe	 Ё fPnVldPer												  Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠Ё Uso		 Ё Generico   												  Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ/*/
Function fPnVldPer( cTip )

Local cOldAlias := Alias()
Local cFilRCH	:= xFilial("RCH")
Local cMsg

Local lRet 		:= .T.

If ( cTip == 'A' )

	Begin Sequence
	
		IF !( lRet := NaoVazio() )
			Break
		EndIF
	
		DbSelectArea( "RCH" )
		RCH->( dbsetOrder( Retorder( "RCH", "RCH_FILIAL+RCH_PROCES+RCH_PER+DTOS(RCH_DTFECH)" ) ) )
		RCH->( dbSeek( cFilRCH + MV_PAR01 + MV_PAR02 + SPACE(6) , .F. ) )
	
		If RCH->( Eof() )
			lRet := .F.
			cMsg := STR0218	// "Periodo nao Cadastrado!"
			MsgInfo( cMsg )
		EndIf
	
	End Sequence
	
EndIf

DbSelectArea(cOldAlias)

Return( lRet )

/*/
эээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤┘o	 ЁfPnVldRot Ё Autor Ё Igor Franzoi		    Ё Data Ё17/04/2008Ё╠╠
╠╠цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤┘o ЁValidacao do processo digitado nos perguntes utilizados nos Ё╠╠
╠╠|			 |nos relatorios											  Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁSintaxe	 Ё fPnVldRot												  Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠Ё Uso		 Ё Generico   												  Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ/*/
Function fPnVldRot( cTip )

Local lRet := .F.

If ( cTip == "A" )
	lRet := ( ExistCpo("SRY") .and. NaoVazio() )
EndIf

Return lRet

/*/
эээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤┘o	 ЁfPnVldNPagЁ Autor Ё Igor Franzoi		    Ё Data Ё17/04/2008Ё╠╠
╠╠цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤┘o ЁValidacao do processo digitado nos perguntes utilizados nos Ё╠╠
╠╠|			 |nos relatorios											  Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁSintaxe	 Ё fPnVldNPag												  Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠Ё Uso		 Ё Generico   												  Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ/*/
Function fPnVldNPag( cTip )

Local lRet := .F.

If ( cTip == "A" )
	lRet := NaoVazio()
EndIf

Return lRet
/*
эээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддд©╠╠
╠╠ЁFun┤└o	 Ё PonX1Valid Ё Autor Ё Leandro Drumond       Ё Data Ё23/04/08Ё╠╠
╠╠цддддддддддеддддддддддддадддддддадддддддддддддддддддддддаддддддадддддддд╢╠╠
╠╠ЁDescri┤└o Ё Valida os campos periodo e numero de	pagamento da pergunte.Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁParametrosЁ cChave 	- Chave de pesquisa (RCH)  						  Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠Ё Uso		 Ё Pergunte GPR040 - campos Processo (MV_PAR01), 			  Ё╠╠
╠╠Ё    		 Ё                   Roteiro (MV_PAR02), Periodo (MV_PAR03) e Ё╠╠
╠╠Ё    		 Ё                   Numero de Pagamento (MV_PAR04).          Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ */
Function PonX1Valid(cChave)

Local cReadVar	:= Upper( AllTrim( ReadVar() ) )
Local cRoteiro 
Local lTipoAut
Local lRet 		:= .T.                   
Local nPerNumPg
Local nFilProces
Local nTamRoteiro

If Substr(cReadVar, 1, 3) == "M->"
	cReadVar := Substr(cReadVar,4)
EndIf

If cReadVar == "MV_PAR01"
	lRet 	  := ExistCpo("RCJ", cChave)
	cProcesso := cChave
ElseIf !(cReadVar == "MV_PAR04" .AND. mv_par04 == "99")
	If Substr(cChave, 6, 3) <> "EXT"
		DbSelectArea( "RCH" )
		DbSetOrder( 4 ) // RCH_FILIAL + RCH_PROCESSO + RCH_ROTEIRO + RCH_PERIODO + RCH_NUMPAG
		cChave := xFilial( "RCH" ) + cChave
		DbSeek( cChave, .F. ) 
		If Eof()
			
			/*
			здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Tratamento de Autonomos - Permite Nro. Pagto nao cadastrado  Ё
			юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды*/
			nFilProces 	:= GetSx3Cache( "RCH_FILIAL", "X3_TAMANHO" ) + GetSx3Cache( "RCH_PROCES", "X3_TAMANHO" )
			nTamRoteiro	:= GetSx3Cache( "RCH_ROTEIR", "X3_TAMANHO" )
			cRoteiro 	:= Substr(cChave, nFilProces+1, nTamRoteiro)
			nPerNumPg 	:= nFilProces + Len( cRoteiro ) + 1
			lTipoAut 	:= ( fGetTipoRot( cRoteiro ) == "9" )
			DbSelectArea("RCH")
			If lTipoAut
				DbSeek( Substr( cChave, 1, nFilProces ) + cRoteiro + Substr( cChave, nPerNumPg ) , .F. )
			EndIf
			If Eof()

				/*
				здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				Ё Pesquisar Periodo sem roteiro de calculo.                    Ё
				юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды*/
				cRoteiro := Space( nTamRoteiro )
				cChave := Substr( cChave, 1, nFilProces ) + cRoteiro + Substr( cChave, nPerNumPg )
				DbSeek( cChave, .F. )
				If Eof()
					/*
					здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
					Ё Tratamento de Autonomos - Permite Nro. Pagto nao cadastrado  Ё
					юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды*/
					If lTipoAut
						cChave := Substr( cChave, 1, nFilProces ) + cRoteiro
						DbSeek( cChave, .F. )
						If Eof()
							lTipoAut := .F.
						EndIf
					EndIf
					If !lTipoAut
						Help( " ", 1, "REGNOIS" )
						lRet 	 := .F.
					EndIf
				EndIf
			EndIf
		EndIf
	EndIf
EndIf

Return ( lRet )
/*/
зддддддддддбдддддддддддбдддддбдддддддддддддддддддддддддддбддддбдддддддддд©
ЁFun┤┘o    ЁPnRCHFiltroЁAutorЁLeandro Drumond            ЁDataЁ08/05/2008Ё
цддддддддддедддддддддддадддддадддддддддддддддддддддддддддаддддадддддддддд╢
ЁDescri┤┘o ЁFiltro da Consulta Padrao RCH06								 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁConsulta Padrao (SXB)	 			                  	   	 Ё
юддддддддддаддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function PnRCHFiltro(cCond)

Local cFiltro	:= "(RCH->RCH_FILIAL == '" + xFilial("RCH") + "')"
Local lPn090	:= IsInCallStack("PONM090")

/*/
здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Criar as variaveis DEFAULT 								   Ё
юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды*/
DEFAULT cCond := If( lPn090,"1","3")

If Type( "cProcesso" ) == "U"
	cProcesso := ""
EndIf

If Type( "cPeriodo" ) == "U"
	cPeriodo := ""
EndIf

If Type( "cRoteiro" ) == "U" .or. Empty(AllTrim(cRoteiro))
	cRoteiro := "PON"
EndIf

DEFAULT cRoteiro := "PON"

/*/
здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Documentacao das Variaveis 								   Ё
Ё															   Ё
ЁcCond == 1 -> Periodos Abertos 							   Ё
Ё      == 2 -> Periodos Fechados							   Ё
Ё      == 3 -> Ambos	         							   Ё
юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды*/
If cCond == "1" .OR. cCond == "2" // Periodo aberto ou fechado
	If !Empty(cFiltro)
		cFiltro	+= " .AND. "
	EndIf
	If cCond == "2" // Periodo fechado
		cFiltro := "!"
	EndIf
	cFiltro	+= "EMPTY(RCH->RCH_DTFECH)" 
EndIf
	
If !Empty(cPeriodo) .and. !lPn090
	If !Empty(cFiltro)
		cFiltro	+= " .AND. "
	EndIf
	cFiltro += " (RCH->RCH_PER == '" + cPeriodo + "')"
EndIf

If !Empty(cProcesso)
	If !Empty(cFiltro)
		cFiltro	+= " .AND. "
	EndIf
	cFiltro	+= " (RCH->RCH_PROCES == '" + cProcesso + "')" 
EndIf

If !Empty(cRoteiro)
	If !Empty(cFiltro)
		cFiltro	+= " .AND. "
	EndIf
	cFiltro	+= " (RCH->RCH_ROTEIR == '" + cRoteiro + "'"
	cFiltro += ")"
EndIf

cFiltro := "@#" + cFiltro + "@#"

Return ( cFiltro )

/*
эээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддддбдддддддбдддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤└o    ЁfSetPerData Ё Autor Ё Leandro Drumond     Ё Data Ё 09/05/08 Ё╠╠
╠╠цддддддддддеддддддддддддадддддддадддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤└o Ё Monta dialogo para selecao de periodo ou Data, no caso de  Ё╠╠
╠╠Ё			 Ё data abrira outra tela para definir data inicial e final   Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠Ё Uso      Ё Manutencoes                                                Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠*/
Function fSetPerData(nOpcRadio, cTitJan, cTitBox, cTitRad1, cTitRad2)

Local nOpcAux
Local oRadio
Local oDlg
Local oDlg2
Local oGroup
Local oFont
Local oDtIni
Local oDtFim
Local dDataIni := CtoD("//")
Local dDataFim := CtoD("//")
Local bSet15A
Local bSet24A
Local bSet15B
Local bSet24B
//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
//Ё DeclaraГЦo de arrays para dimensionar tela		         Ё
//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
Local aAdvSize		:= {}
Local aInfoAdvSize	:= {}
Local aObjSize		:= {}
Local aObjCoords	:= {}
Local aGDCoord		:= {}

DEFAULT cTitBox  := STR0222 //"Visualizar por"
DEFAULT cTitRad1 := STR0165 //"Periodo"
DEFAULT cTitRad2 := STR0164 //"Dia Inicial/Final"

nOpcAux   := nOpcRadio
nOpcRadio := 0

/*
здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Monta as Dimensoes dos Objetos         					   Ё
юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды*/
aAdvSize		:= MsAdvSize( ,.T.,30)
aInfoAdvSize	:= { aAdvSize[1] , aAdvSize[2] , aAdvSize[3] , aAdvSize[4] , 2 , 2 }
aAdd( aObjCoords , { 000 , 060 , .T. , .F.  } )
aObjSize			:= MsObjSize( aInfoAdvSize , aObjCoords )

DEFINE FONT oFont NAME "Arial" SIZE 0,-11 BOLD
DEFINE MSDIALOG oDlg FROM  aAdvSize[7],0 TO aAdvSize[6]*0.8,aAdvSize[5] TITLE OemToAnsi(cTitJan) PIXEL

@ aObjSize[1][1],aObjSize[1][2] GROUP oGroup TO aObjSize[1][3],aObjSize[1][4] LABEL OemToAnsi(cTitBox) OF oDlg PIXEL
oGroup:oFont:=oFont

@ aObjSize[1][1]+10,aObjSize[1][2]+10 RADIO oRadio VAR nOpcAux ITEMS 	OemToAnsi(cTitRad1), OemToAnsi(cTitRad2);
          SIZE 115,010 OF oDlg PIXEL

bSet15A := {|| nOpcRadio := nOpcAux, oDlg:End()}
bSet24A := {|| nOpcRadio := 0,       oDlg:End()}
ACTIVATE MSDIALOG oDlg ON INIT EnchoiceBar(oDlg, bSet15A, bSet24A, Nil, Nil) CENTERED

If ( nOpcRadio == 2 )
	nOpcRadio := 0    
     
	aObjCoords 			:= {}
	aInfoAdvSize		:= { aAdvSize[1] , aAdvSize[2] , aAdvSize[3] , aAdvSize[4] , 2 , 2 }
	aAdd( aObjCoords , { 000 , 30 , .T. , .F.  } )
	aAdd( aObjCoords , { 000 , 30 , .T. , .F.  } )
	aObjSize			:= MsObjSize( aInfoAdvSize , aObjCoords )

	DEFINE FONT oFont NAME "Arial" SIZE 0,-11 BOLD
	DEFINE MSDIALOG oDlg2 FROM  aAdvSize[7],0 TO aAdvSize[6]*0.8,aAdvSize[5] TITLE OemToAnsi(cTitJan) PIXEL
	
	@ aObjSize[1][1],aObjSize[1][2] GROUP oGroup TO aObjSize[1][3],aObjSize[1][4] LABEL OemToAnsi(STR0064) OF oDlg2 PIXEL  //Data Inicial
	
	@ aObjSize[1][1]+10,aObjSize[1][2]+10 MSGET oDtIni Var dDataIni SIZE 050,10 OF oDlg2 PIXEL VALID !Empty( dDataIni )

	@ aObjSize[2][1],aObjSize[2][2] GROUP oGroup TO aObjSize[2][3],aObjSize[2][4] LABEL OemToAnsi(STR0065) OF oDlg2 PIXEL  //Data Final

	@ aObjSize[2][1]+10,aObjSize[2][2]+10 MSGET oDtFim Var dDataFim SIZE 050,10 OF oDlg2 PIXEL VALID ( !Empty( dDataFim ) .and. ( dDataIni <= dDataFim ) )
	
	bSet15B := {|| nOpcRadio := 2, oDlg2:End() }
	bSet24B := {|| nOpcRadio := 0, oDlg2:End() }
	
	ACTIVATE MSDIALOG oDlg2 ON INIT EnchoiceBar(oDlg2, bSet15B, bSet24B, Nil, Nil) CENTERED
	
	oPeriodo:dDataIni := dDataIni
	oPeriodo:dDataFim := dDataFim

EndIf

Return( nOpcRadio )

/*
эээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддддбдддддддбдддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤└o    ЁfDtaAdmis   Ё Autor Ё Leandro Drumond     Ё Data Ё 10/06/08 Ё╠╠
╠╠цддддддддддеддддддддддддадддддддадддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤└o Ё Instancia data de admissao ou readmissao do funcionario    Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠Ё Uso      Ё Generico                                                   Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠*/
Function fDtaAdmis()

Local dDataAdmis := CtoD('')

If cPaisLoc == "MEX"
	If !Empty(SRA->RA_FECREI)
		dDataAdmis := SRA->RA_FECREI
	Else
		dDataAdmis := SRA->RA_ADMISSA
	EndIf
Else
	dDataAdmis := SRA->RA_ADMISSA
EndIf

Return ( dDataAdmis )

/*
эээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддддбдддддддбдддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤└o    ЁfFilIdTabelaЁ Autor Ё Igor Franzoi	    Ё Data Ё 25/06/08 Ё╠╠
╠╠цддддддддддеддддддддддддадддддддадддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤└o Ё 															  Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠Ё Uso      Ё Generico                                                   Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠*/
Static Function fFilIdTabela( aTabCalend, nPosIni, aTransf )
Local aArea		:= GetArea()
Local aSX3Area	

Local cFilRCH	:= xFilial('RCH') 
Local nPos		:= 0
Local nCont 	:= 0
Local cFilProc	:=	''
Local cProcesso	:=	''
Local cPeriodo 	:=	''
Local cRoteiro 	:=	''
Local cNumPagto	:=	''
Local dPerIni	:=	''
Local dPerFim	:=	''

Local dData		:= aTabCalend[ 1,CALEND_POS_DATA_APO ] 
Local dDataAnt	:= Ctod('')

Local aElmTransf:= {}	

Local lTransf	:= .F.

Local cCC 		:= SRA->RA_CC	 	  
Local cCodFunc  := SRA->RA_CODFUNC   
Local cDepto	:= SRA->RA_DEPTO     
Local cPosto	:= SRA->RA_POSTO

If Type("oPeriodo") == "U"
	SetMemVar("oPeriodo" , RHPERIODO():New() , .T. , .T. )
EndIf

cFilProc	:= oPeriodo:cFilRCH
cProcesso	:= oPeriodo:cProcesso	//Processo
cPeriodo 	:= oPeriodo:cPeriodo  	//Periodo
cRoteiro 	:= oPeriodo:cRoteiro	//Roteiro
cNumPagto	:= oPeriodo:cNumPagto	//Numero de Pagamento
dPerIni		:= oPeriodo:dDataIni  	//Data Inicio do Periodo Atual
dPerFim		:= oPeriodo:dDataFim  	//Data Fim do Periodo Atual  

If cSX3ProcTit == Nil 
	aSX3Area	:= SX3->(GetArea() )
	SX3->( dbSetOrder( 02 ) )
	SX3->( dbSeek('RCH_PROCES') )
	cSX3ProcTit     := Alltrim(SX3->(X3TITULO()))
	RestArea(aSX3Area)
Endif
		
DEFAULT nPosIni := 1  


For nCont := nPosIni To Len(aTabCalend)  
	
	dData		:= aTabCalend[ nCont , CALEND_POS_DATA_APO ] 		  
	
	//-- Carrega transferencias referentes ao Processo 
	aElmTransf := fBuscaProc( aTransf, dData, /*cProcesso*/, /*cDescProc*/, /*uData*/, /*lNoRept*/ , /*lOrigem*/  )
        
	//-- Se nЦo encontrou transferencia        
	//-- Busca  no disco as informacoes do processo atual se o funcionario nao apresentou transferencia na data
	IF Empty(aElmTransf)
	   cProcesso	:= oPeriodo:cProcesso 
	Else
	   cProcesso	:= aElmTransf[2]  	   
	Endif
	
	If ( ( nPos := aScan( oPeriodo:aPeriodos, { |x| ( x[1]== cFilRCH ) 	.and. ;
													 ( x[2] == cProcesso ) 	.and. ;
													 ( ( dData >= x[6] ) 		.and. ( dData <= x[7] ) );
											    } ;
				   	     ) ;
		   ) = 0 ;
		) 
		   
		
	
		fFileRCH( 	dData					,;
				  	cProcesso				,; //-- Processo na Data
				  	@nPos 					;
					)                                  
	
		//-- Se nao encontrou o processo  valido na data de apontamento lida avisa ao usuario
		If Empty(nPos)
			oCalendError:SendError('07',OemToAnsi(STR0064) +  " " +Dtoc(dData) + CRLF +;
									cSX3ProcTit + ": " + cProcesso, .T.)  //"NЦo foi possМvel gerar o calendАrio para o perМodo de: "
			Loop
		EndIf
    Endif
    
	//-- Carrega informacoes do Processo
	cProcesso:= oPeriodo:aPeriodos[ nPos, 02 ]	//Processo
	cPeriodo := oPeriodo:aPeriodos[ nPos, 03 ]  //Periodo
	cRoteiro := oPeriodo:aPeriodos[ nPos, 04 ]  //Roteiro		
	cNumPagto:= oPeriodo:aPeriodos[ nPos, 05 ]  //Numero de Pagamento
     
	dPerIni  := oPeriodo:aPeriodos[ nPos, 06 ]  //Data Inicio do Periodo Atual
	dPerFim  := oPeriodo:aPeriodos[ nPos, 07 ]  //Data Fim do Periodo Atual

	If dData <> dDataAnt
		fBuscaDia( aTransf, dData, @cDepto, @cPosto, @cCC, @cCodFunc)
		dDataAnt:= dData
	Endif
	
	//-- Alimenta o calendario com as informacoes do processo na data de apontamento
	aTabCalend[ nCont, CALEND_POS_PERIODO  	] := cPeriodo	//Periodo
	aTabCalend[ nCont, CALEND_POS_ROTEIRO  	] := cRoteiro	//Roteiro
	aTabCalend[ nCont, CALEND_POS_PROCESSO 	] := cProcesso	//Processo
	aTabCalend[ nCont, CALEND_POS_NUM_PAGTO	] := cNumPagto	//Numero de Pagamento 
    

	aTabCalend[ nCont, CALEND_POS_DEPTO		] := If(	Empty(aTabCalend[ nCont, CALEND_POS_DEPTO		]),;
														cDepto		,;
														aTabCalend[ nCont, CALEND_POS_DEPTO				] ;
													)	//Depto
	aTabCalend[ nCont, CALEND_POS_CC		] := If(	Empty(aTabCalend[ nCont, CALEND_POS_CC			]),;
														cCC			,;
														aTabCalend[ nCont, CALEND_POS_CC				];
													)	//Centro de Custo
	aTabCalend[ nCont, CALEND_POS_CODFUNC	] := If(	Empty(aTabCalend[ nCont, CALEND_POS_CODFUNC		]),;
														cCodFunc	,;
														aTabCalend[ nCont, CALEND_POS_CODFUNC			];
													)	//Codigo da Funcao
	aTabCalend[ nCont, CALEND_POS_POSTO		] := If(	Empty(aTabCalend[ nCont, CALEND_POS_POSTO		]),;
														cPosto		,;
														aTabCalend[ nCont, CALEND_POS_POSTO				];
													)	//Posto

Next

Return (NIl)  

/*/
зддддддддддбддддддддддддддддбдддддбдддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o	   ЁfFileRCH	 	ЁAutorЁ  				  Ё Data Ё08/05/2008Ё
цддддддддддеддддддддддддддддадддддадддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁCarregar no array de periodos (no objeto oPeriodo), conformeЁ
|		   |Data e Processo												|
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁNIL                      									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso	   ЁGenerica      										    	Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function fFileRCH( dData, cProcesso, nPos )

Local aArea		:= GetArea()


Local cAliasQry := ""

#IFDEF TOP
	Local cWhere	:= "" 
#ELSE	
	Local cAlias	:= "RCH"
#ENDIF
	
DEFAULT nPos	:= 0

#IFDEF TOP

	cAliasQry := GetNextAlias()
		
	cWhere += "%"
	cWhere += " RCH_PROCES = '"+cProcesso+"' AND "
	cWhere += " RCH_ROTEIR = 'PON' AND "
	cWhere += " RCH_DTINI <= '"+Dtos(dData)+"' AND "
	cWhere += " RCH_DTFIM >= '"+Dtos(dData)+"' AND "
	cWhere += "%"
	
	BeginSql Alias cAliasQry
		column RCH_DTINI as Date, RCH_DTFIM as Date, RCH_DTFECH as Date
	   	%NoParser%
	   	SELECT 
				RCH_FILIAL,
				RCH_PROCES,	
				RCH_PER,		
				RCH_ROTEIR,	
				RCH_NUMPAG,	
				RCH_DTINI,	
				RCH_DTFIM,	
				RCH_DTFECH,	
				RCH_ANO,		
				RCH_MES	 	
		FROM
			%Table:RCH% RCH
		WHERE
			%Exp:cWhere%
			RCH.%NotDel%
		ORDER BY 
			%Order:RCH%
	EndSql
	
	
	If !( (cAliasQry)->(Eof()) )
		oPeriodo:aADDPer(	{{	(cAliasQry)->RCH_FILIAL	,;		//01
								(cAliasQry)->RCH_PROCES	,;      //02
								(cAliasQry)->RCH_PER 	,;		//03
								(cAliasQry)->RCH_ROTEIR	,;		//04
								(cAliasQry)->RCH_NUMPAG	,;		//05
								(cAliasQry)->RCH_DTINI	,;		//06
								(cAliasQry)->RCH_DTFIM	,;		//07
								(cAliasQry)->RCH_DTFECH	,;		//08
								(cAliasQry)->RCH_ANO	,;		//09
								(cAliasQry)->RCH_MES	;		//10
							}},;
							@nPos;
						 )
	EndIf
	
	(cAliasQry)->(dbCloseArea())

#ELSE

	

	DbSelectArea( cAlias )
	(cAlias)->(RetOrder("RCH", "RCH_FILIAL+RCH_PROCES+RCH_ROTEIR+RCH_DTFECH+RCH_PER+RCH_NUMPAG"))
	(cAlias)->(DbSeek( xFilial("RCH")+cProcesso+"PON" ))

	While (cAlias)->( !Eof() .and. xFilial("RCH")+cProcesso+"PON" == RCH_FILIAL+RCH_PROCES+RCH_ROTEIR )

		If (cAlias)->(RCH_DTINI <= dData .and. RCH_DTFIM >= dData)

				oPeriodo:aADDPer(	{{	(cAliasQry)->(RCH_FILIAL)	,;		//01
										(cAliasQry)->(RCH_PROCES)	,;      //02
										(cAliasQry)->(RCH_PER)		,;		//03
										(cAliasQry)->(RCH_ROTEIR)	,;		//04
										(cAliasQry)->(RCH_NUMPAG)	,;		//05
										(cAliasQry)->(RCH_DTINI)	,;		//06
										(cAliasQry)->(RCH_DTFIM)	,;		//07
										(cAliasQry)->(RCH_DTFECH)	,;		//08
										(cAliasQry)->(RCH_ANO)		,;		//09
										(cAliasQry)->(RCH_MES)	 	;		//10
									}},;
									@nPos;
								 ) 
				EXIT
		EndIf
		
		(cAlias)->(dbSkip())
		
	EndDo

#ENDIF
	
RestArea(aArea)
	
Return (Nil)
	
/*/
зддддддддддбддддддддддддддддбдддддбдддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o	   ЁfLoadTransf	 	ЁAutorЁMauricio MR		  Ё Data Ё26/06/2008Ё
цддддддддддеддддддддддддддддадддддадддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁCarrega as transferencias do Funcionario 				    Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁNIL                      									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso	   ЁGenerica      										    	Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function fLoadTransf(aTransf)

Local nX		:= 0
Local aRet		:= {}
Local cFilMat	:= SRA->(RA_FILIAL + RA_MAT )
Local aAux		:= {}
          
//-- Variaveis para obter as transferencias do funcionario
Local lOrigem := .T.			//Executar a Pesquisa pela Tambem pela Origem
Local lNoRept := .F.			//Nao Armazena Itens Iguais

//-- Carrega todas as transferencias
fTransfAll( aAux , , lNoRept , lOrigem )

/*
здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Filtrar as Transferencias do Funcionario				       Ё
юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды*/	
If !Empty(aAux)
	For nX := 1 to Len(aAux)  
	    //-- Se Transf DE e Transf PARA for diferente ( FWCODEMP("SRA") + cFilAnt + cMat ) desconsidera
	    If ( ( FWCODEMP("SRA") + cFilMat ) <> (aAux[ nX , 04 ] + aAux[ nX , 10 ] + aAux[ nX , 11 ] )) .AND.;
	       ( ( FWCODEMP("SRA") + cFilMat ) <> (aAux[ nX , 01 ] + aAux[ nX , 08 ] + aAux[ nX , 09 ] ) ) 
	       Loop
        Endif
		
		//Posicao anterior a Transferencia 
		//{ dDataTrf-1, cProcesso, cDepto, cPosto, cCC, cEmpresa, cFilial, cMat, nRecno  } )			
		aAdd( aRet, { aAux[ nX, 07 ]-1, aAux[ nX , 14 ], aAux[ nX , 16 ], aAux[ nX , 18 ], aAux[ nX , 03 ], aAux[ nX , 02 ], aAux[ nX , 08 ], aAux[ nX , 09 ], aAux[ nX , 13 ]  } )			

		//Posicao na data da Transferencia 	
		//{ dDataTrf, cProcesso, cDepto, cPosto, cCC, cEmpresa, cFilial, cMat, nRecno  } )					
		aAdd( aRet, { aAux[ nX, 07 ], aAux[ nX , 15 ], aAux[ nX , 17 ], aAux[ nX , 19 ], aAux[ nX , 06 ], aAux[ nX , 04 ], aAux[ nX , 10 ], aAux[ nX , 11 ], aAux[ nX , 13 ]  } )						
	Next  
Endif                  
           
//-- Transfere as transferencias filtradas para o parametro de entrada
aTransf := aClone(aRet)

Return (Nil) 

/*/
зддддддддддбддддддддддддддддбдддддбдддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o	   ЁfBuscaProc	 	ЁAutorЁIgor Franzoi		  Ё Data Ё26/06/2008Ё
цддддддддддеддддддддддддддддадддддадддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁLocaliza o Processo do Funcionario se ocorreu Transferencia Ё
|		   |na data														|
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁNIL                      									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso	   ЁGenerica      										    	Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function fBuscaProc( aTransf, dData)

Local nX		:= 0
Local aRet		:= {}
For nX := 1 to Len(aTransf)  

		If aTransf[ nX, 01 ] <= dData
			//{ dData, cProcesso, cDepto, cPosto, cCC, cEmpresa, cFilial, cMat, nRecno  } 			
			aRet :=  { dData, aTransf[ nX , 02 ], aTransf[ nX , 03 ], aTransf[ nX , 04 ], aTransf[ nX , 05 ], aTransf[ nX , 06 ], aTransf[ nX , 07 ], aTransf[ nX , 08 ], aTransf[ nX , 09 ]  } 			
		Endif	
Next  

Return (aRet) 



/*/
зддддддддддбддддддддддддддддбдддддбдддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o	   ЁfBuscaDia	 	ЁAutorЁMauricio MR		  Ё Data Ё28/06/2008Ё
цддддддддддеддддддддддддддддадддддадддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁLocaliza o Depto, Posto e Centro de Custo numa Data			Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁNIL                      									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso	   ЁGenerica      										    	Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function fBuscaDia( aTransf, dData, cDepto, cPosto, cCC, cCodFunc)

Local nX	:= 0
Local lCpo	:= .F.


For nX := 1 to Len(aTransf)  
    
	If ( aTransf[ nX, 01 ] >= dData ) 
		cDepto		:= aTransf[ nX , 03 ]	// Dept
		cPosto		:= aTransf[ nX , 04 ]	// Posto
		cCC			:= aTransf[ nX , 05 ]	// CC
        Exit
	EndIf   
Next  

fBuscaFunc(dData, @cCodFunc, , , lCpo)
Return ( NIL )

	
/*/
зддддддддддбддддддддддддддддбдддддбдддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o	   ЁfVerPGenerico 	ЁAutorЁMauricio MR		  Ё Data Ё28/06/2008Ё
цддддддддддеддддддддддддддддадддддадддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁLocaliza informacoes do Periodo conforme o Processo			Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   ЁfVerPGenerico(cProcesso)	 								Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁNIL                      									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso	   ЁGenerica      										    	Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/           
Static Function fVerPGenerico(cProcesso)
Local aRCHArea 	
Local aArea			:= GetArea()
Local lGenerico		:= .F.
Local lUsaPGenerico	:= .F.
Local laProcVazio	:= ( __aProcesso	== NIL )
Local lRet			:= .F.
/*
здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Para o Modulo SIGAPON todos os funcionarios devem estar num  Ё
Ё Processo com Periodo										   Ё
юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды*/		                      
If  ( Alltrim( Upper( cModulo ) ) <> "PON" )
	//Verifica se Processo jah foi verificado (se igual ao ultimo)
	If ( __cProcesso <> cProcesso )
	   __cProcesso := cProcesso              
	   
	   //-- Se nao for a primeira vez
	   IF !laProcVazio
	   		If ( __nPosProcesso:= Ascan( __aProcesso, { |x| x[1] == cProcesso } )  > 0 )
	   			lRet	:= __aProcesso[__nPosProcesso, 2]
	   		Endif	
	   Endif	
	
	   //-- Se o processo nao foi verificado, procura em disco
	   If  ( laProcVazio .or.  Empty( __nPosProcesso ) )
	    	aRCHArea 	:= RCH->(GetArea())
		    __aProcesso	:= {} 
		   
		    //-- Procura as informacoes do processo no disco
		    RCH->(DbSetOrder( RetOrder( "RCH", "RCH_FILIAL+RCH_PROCES+RCH_ROTEIR+RCH_PER+RCH_NUMPAG" )))        
	        lGenerico		:= !( RCH->( Dbseek( xFilial("RCH") + cProcesso  + "PON" ) ) )
	        
	       //-- Adiciona o Processo verificado
	       AADD( __aProcesso, {cProcesso, lGenerico } ) 
	       __nPosProcesso:=	Len( __aProcesso )
	       
	       RCH->(RestArea(aRCHArea))
	   Endif                              
	
	Endif
	lRet	:= __aProcesso[__nPosProcesso, 2]
Endif   

RestArea(aArea)
Return (lRet)


/*
эээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддддбдддддддбдддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤└o    ЁfRecCalAfa  Ё Autor Ё Leandro Drumond     Ё Data Ё 27/06/08 Ё╠╠
╠╠цддддддддддеддддддддддддадддддддадддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤└o Ё Recria o Calendario Fisico levando em consideracao o ultimoЁ╠╠
╠╠Ё			 | afastamento incluido.									  Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠Ё Uso      Ё GPEA240                                                    Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠*/
/*
эээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддддбдддддддбдддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤└o    ЁfRecCalAfa  Ё Autor Ё Leandro Drumond     Ё Data Ё 27/06/08 Ё╠╠
╠╠цддддддддддеддддддддддддадддддддадддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤└o Ё Recria o Calendario Fisico levando em consideracao o ultimoЁ╠╠
╠╠Ё			 | afastamento incluido.									  Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠Ё Uso      Ё GPEA240                                                    Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠*/
Function fRecCalAfa(oGrid,aSR8ID,nOpcx)
/*
aSR8ID[x,1] := Referencia o numero da linha no ASR8Cols
aSR8ID[x,2] := NUMID
aSR8ID[x,3] := Indica se campo foi deletado
*/
Local cMat		  := SRA->RA_MAT
Local cFil		  := SRA->RA_FILIAL
Local cNumId	  := ''
Local dDtaIni     := CtoD('')
Local dDtaFim     := CtoD('')
Local dIniCal     := CtoD('')
Local dFimCal     := CtoD('')
Local dMinIniCal  := CtoD('')
Local dMaxFimCal  := CtoD('')
Local nLenID	  := Len(aSR8ID)
Local nX          := 0
Local oPerFch	  := RHPERIODO():New()

If lUseCalFisico

	//Monta ultimo periodo fechado do funcionario
	oPerFch:cProcesso 	:= SRA->(RA_PRCFCH)
	oPerFch:cPeriodo	:= SRA->(RA_PERFCH)
	oPerFch:cRoteiro	:= SRA->(RA_ROTFCH)
	oPerFch:cNumPagto	:= SRA->(RA_NUPFCH)
	
	oPerFch:GetPer("!EMPTY(RCH_DTFECH)")
	
	//Obtem a data inicial e final do calendario
	fDatMaxCal( cFil, cMat, @dFimCal, @dIniCal )
	
	dMinIniCal := If( dIniCal > oPerFch:dDataFim , dIniCal , (oPerFch:dDataFim + 1) )
	
	dMaxFimCal := dFimCal
	
	//Apaga todos os afastamento do periodo se datas forem maiores que data final do ultimo periodo fechado
	If dMaxFimCal > oPerFch:dDataFim
		fUpdCal( cFil							 ,; //Filial do funcionario
				 cMat				 			 ,; //Matricula
				 ""		 			   			 ,; //Processo para o qual o funcionario sera transf.
				 ""		 			   			 ,; //Centro de Custo
				 ""		 			   			 ,; //Roteiro
				 ""		 			   			 ,; //Periodo
				 ""		 			   			 ,; //Num. de Pagamento
				 ""		 			   			 ,; //Departamento
				 ""		 			   			 ,; //Posto
				 ""		 			   			 ,; //Cod. da Funcao
				 Dtos(dMinIniCal)				 ,; //Data inicio do calendario ja existente
				 Dtos(dMaxFimCal)				 ,; //Data fim do calendario existente
				 .T.	 			   			 ,; //Efetua Update no RF6 com os campos/dados passados
				 .F.	 		 	   			 ,; //Efetua Update no RF7 com os campos/dados passados
				 {"","S"}				 		 ,; //Dados para update, na mesma ordem dos campos RF6
				 {}		 			   			 ,; //Dados para update, na mesma ordem dos campos RF7
				 {"R8ID","TIPOD"}	   	 		 ,; //Campos utilizados para Update RF6
				 {} 	  	 					  ) //Campos utilizados para Update RF7
	EndIf
	
	//Se nao for exclusao reconstroi os afastamentos do calendario
	If nOpcx != 5
		For nX := 1 to nLenID
			oGrid:GoLine(aSR8ID[nX,1])
			//Se data final estiver vazia, utiliza ultima data do calendario
			If Empty(oGrid:GetValue("R8_DATAFIM"))
				dDtaFim := dFimCal
			Else
				dDtaFim := If(oGrid:GetValue("R8_DATAFIM") <= dFimCal , oGrid:GetValue("R8_DATAFIM") , dFimCal)
			EndIf
	        //Data Inicial devera ser maior que data final do ultimo periodo fechado
			dDtaIni := If(oGrid:GetValue("R8_DATAINI") > oPerFch:dDataFim , oGrid:GetValue("R8_DATAINI") , (oPerFch:dDataFim + 1))
	
	        //Se deletado
			If aSR8ID[nX,3]
				cNumId  := ''
			Else
				cNumId := aSR8ID[nX,2]
			EndIf
	        
	        //Somente executa update se datas forem maiores que data final do ultimo periodo fechado
			If dDtaFim > oPerFch:dDataFim
				fUpdCal( cFil							 ,; //Filial do funcionario
						 cMat				 			 ,; //Matricula
						 ""		 			   			 ,; //Processo para o qual o funcionario sera transf.
						 ""		 			   			 ,; //Centro de Custo
						 ""		 			   			 ,; //Roteiro
						 ""		 			   			 ,; //Periodo
						 ""		 			   			 ,; //Num. de Pagamento
						 ""		 			   			 ,; //Departamento
						 ""		 			   			 ,; //Posto
						 ""		 			   			 ,; //Cod. da Funcao
						 Dtos(dDtaIni)					 ,; //Data inicio do calendario ja existente
						 Dtos(dDtaFim)					 ,; //Data fim do calendario existente
						 .T.	 			   			 ,; //Efetua Update no RF6 com os campos/dados passados
						 .F.	 		 	   			 ,; //Efetua Update no RF7 com os campos/dados passados
						 {cNumId,"N"}				 	 ,; //Dados para update, na mesma ordem dos campos RF6
						 {}		 			   			 ,; //Dados para update, na mesma ordem dos campos RF7
						 {"R8ID","TIPOD"}	   	 		 ,; //Campos utilizados para Update RF6
						 {} 	  	 					  ) //Campos utilizados para Update RF7
			EndIf
			
		Next nX
	
	EndIf
	
EndIf

Return(Nil)

/*/
зддддддддддбддддддддддддддддбдддддбдддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o	   ЁfFindSeq 		ЁAutorЁIgor Franzoi	  	  Ё Data Ё07/10/2008Ё
цддддддддддеддддддддддддддддадддддадддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁProcura a Sequencia inicial correta para o calendario		Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   ЁfFindSeq()				 									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁNIL                      									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso	   ЁGenerica      										    	Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function fFindSeq( 	cSeq		,;
							aTabPadrao	,; 
							cFilSPJ		,; 
							cNewTno		,;
							lExecQryTop	,; 
							aTurnos		,; 
							dDataAdm	,; 
							dDataIni	,; 
							dDataFim	,;
							cMat	)


Local nCont		:= 0
Local nPosTno	:= 0
Local nPosTab	:= 0
Local nLstSeq	:= 0

Local dIniPer	:= Ctod("//")	//Variavel auxiliar para calculo da sequencia a partir da Data de Admissao
Local dFimPer	:= Ctod("//")	//Variavel auxiliar para calculo da sequencia, primeiro dia do Periodo Solicitado

Local aSeq		:= {}

/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Procura a Sequencia do Turno do Primeiro dia do Periodo	  Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
If !Empty( aTurnos )
	nPosTno := aScan( aTurnos, { |x| x[2] >= dDataIni .and. x[2] <= dDataIni } )
EndIf

If ( nPosTno > 0 )
		
    If !( aTurnos[ nPosTno, 06 ] )
    
		/*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Carrega tabela de horario padrao                     		  Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		fTabPadrao( @aTabPadrao , @cFilSPJ , cNewTno , lExecQryTop )
			
		/*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Carrega todas as sequencias da tabela no array aSeq		  |
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		If ( ( nPosTab := aScan( aTabPadrao , { |x| x[1] == cFilSPJ .and. x[2] == cNewTno } ) ) > 0 )
			For nCont := 1 To Len(aTabPadrao[ nPosTab , 03 ])
				If ( aScan( aSeq , { |x| x == aTabPadrao[ nPosTab , 03 , nCont , 19 ] } ) == 0 )
					aAdd( aSeq , aTabPadrao[ nPosTab , 03 , nCont , 19 ] )
					nLstSeq	:= Val(aTabPadrao[ nPosTab , 03 , nCont , 19 ])
				EndIf
			Next
		EndIf
		
		/*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Carrega a data da Primeira Segunda-Feira, da Data Admissao  |
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
    	dIniPer := fFindDay( dDataAdm )
    	dFimPer := fFindDay( dDataIni )
    	
		/*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Localiza a Sequencia correta para a Data Inicio do Periodo  |
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		If ( nLstSeq > 0 )
	    	cSeq := fContSeq( dIniPer, dFimPer, aSeq, nLstSeq )
    	EndIf
		
	EndIf

Else

	If !( ValType(cMat) == "U" )
	
		/*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Carrega tabela de horario padrao                     		  Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		fTabPadrao( @aTabPadrao , @cFilSPJ , cNewTno , lExecQryTop )
			
		/*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Carrega todas as sequencias da tabela no array aSeq		  |
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		If ( ( nPosTab := aScan( aTabPadrao , { |x| x[1] == cFilSPJ .and. x[2] == cNewTno } ) ) > 0 )
			For nCont := 1 To Len(aTabPadrao[ nPosTab , 03 ])
				If ( aScan( aSeq , { |x| x == aTabPadrao[ nPosTab , 03 , nCont , 19 ] } ) == 0 )
					aAdd( aSeq , aTabPadrao[ nPosTab , 03 , nCont , 19 ] )
					nLstSeq	:= Val(aTabPadrao[ nPosTab , 03 , nCont , 19 ])
				EndIf
			Next
		EndIf	
		
		/*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Carrega a data da Primeira Segunda-Feira, da Data Admissao  |
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		dIniPer := fFindDay( aTurnos[ Len(aTurnos), 02 ] )
		dFimPer := fFindDay( dDataIni )	
		
		/*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Localiza a Sequencia correta para a Data Inicio do Periodo  |
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		If ( nLstSeq > 0 )
	    	cSeq := fContSeq( dIniPer, dFimPer, aSeq, nLstSeq, Val(cSeq) )
	   	EndIf	
   	
   	EndIf

EndIf
										
Return ( Nil )

/*/
зддддддддддбддддддддддддддддбдддддбдддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o	   ЁfFindDay 		ЁAutorЁIgor Franzoi	  	  Ё Data Ё07/10/2008Ё
цддддддддддеддддддддддддддддадддддадддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁLocaliza primeira Segunda-Feira da Data Solicitada			Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   ЁfFindDay				 									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁNIL                      									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso	   ЁGenerica      										    	Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function fFindDay( dData )

While (Dow(dData) != 2)
	dData--
EndDo

Return ( dData )

/*/
зддддддддддбддддддддддддддддбдддддбдддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o	   ЁfFindDay 		ЁAutorЁIgor Franzoi	  	  Ё Data Ё07/10/2008Ё
цддддддддддеддддддддддддддддадддддадддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁLocaliza primeira Segunda-Feira da Data Solicitada			Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   ЁfFindDay				 									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁNIL                      									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso	   ЁGenerica      										    	Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function fContSeq( dIniPer, dFimPer, aSeq, nLstSeq, nSeqIni )

Local cSeq		:= ""

Local nWeek		:= 1

DEFAULT nSeqIni := 0

//Se houver mais de uma Sequencia cadastrada, conta as sequencias do periodo senao retorna a primeira sequencia
If ( nLstSeq > 1 )

	If ( nSeqIni > 0 )
		nWeek := nSeqIni
	EndIf

	While ( dIniPer < dFimPer )
		dIniPer := (dIniPer + 7)		
		If ( nWeek < nLstSeq )
			nWeek++
		Else
			nWeek := 1
		EndIf
	EndDo
	
	nLstSeq := nWeek
	
EndIf

cSeq := aSeq[ nLstSeq ]

Return ( cSeq )

/*/
зддддддддддбддддддддддддддддбдддддбдддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o	   ЁPonStruct() 	ЁAutorЁMauricio MR		  Ё Data Ё11/07/2008Ё
цддддддддддеддддддддддддддддадддддадддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁVerifica a integridade das estruturas das bases SIGAPON		Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   ЁPonStruct()				 									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁNIL                      									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso	   ЁGenerica      										    	Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/           
Function PonStruct(lWorkFlow, aLogFile, bCond )   

Local cAviso	:=  STR0159 // "AtenГДo!"
Local cMsg		:=  STR0225 // "Para Acessar esta rotina, execute o programa RHUPDR12."

Local lRet		:= .T.

DEFAULT		lWorkFlow	:= .F.

//-- Executa a condicao de verificacao de integridade da base
IF !Eval(bCond)
   lRet := .F.
   
   //-- Exibe mensagem na tela se nao WokFlow
   If !lWorkFlow
      	//"AtenГДo!" ## "Para Acessar esta rotina, execute o programa RHUPDR12."
		 Aviso( OEMTOANSI(cAviso),oemtoansi(cMsg),{"OK"}) 
   Endif
   
   //-- Adiciona ao Log se WorkFlow
   IF aLogFile <> Nil
      AADD( aLogFile, cMsg )
   Endif
  
Endif   

Return (lRet)

/*/
зддддддддддбддддддддддддддддбдддддбдддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o	   ЁVerSP5Struct() 	ЁAutorЁMauricio MR		  Ё Data Ё11/07/2008Ё
цддддддддддеддддддддддддддддадддддадддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁVerifica a estrutura da base SP5							Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   ЁVerSP5Struct()				 								Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁNIL                      									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso	   ЁGenerica      										    	Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/           
Function  VerSP5Struct()
Local aArea		:= GetArea()
Local aSX3Area  := SX3->(GetArea())
Local lRet		:= .F.

SX3->(DbSetOrder(2))

If SX3->(dbSeek("P5_DATAAPO"))
	lRet := Upper(AllTrim(GetSx3Cache("P5_DATAAPO", "X3_TIPO"))) == 'D'
EndIf

If lRet
	If SX3->(dbSeek("P5_POSTO"))
		lRet := GetSx3Cache("P5_POSTO", "X3_TAMANHO") == 9
	EndIf
EndIf

RestArea(aSX3Area)
RestArea(aArea)

Return (lRet)

/*/
зддддддддддбддддддддддддддддбдддддбдддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o	   ЁVerSPLStruct() 	ЁAutorЁLeandro Drumond    Ё Data Ё18/08/2008Ё
цддддддддддеддддддддддддддддадддддадддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁVerifica a estrutura da base SPL							Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   ЁVerSPLStruct()				 								Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁNIL                      									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso	   ЁGenerica      										    	Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/    
Function  VerSPLStruct()
Local aArea		:= GetArea()
Local aSX3Area  := SX3->(GetArea())
Local lRet		:= .T.
Local cUsado    := ""

SX3->(DbSetOrder(2))

If SX3->(dbSeek("PL_D4"))
	cUsado := GetSx3Cache("PL_D4", "X3_USADO")

	If SX3->(dbSeek("PL_D5"))
		If !( GetSx3Cache("PL_D5", "X3_USADO") == cUsado ) .Or. !(GetSx3Cache("PL_D5", "X3_BROWSE") == "S")
	      	//"AtenГДo!" ## "Para Acessar esta rotina, execute o programa RHUPDR12."
			 Aviso( OEMTOANSI(STR0159),oemtoansi(STR0225),{"OK"}) 
			lRet := .F.			
		EndIf
	EndIf

EndIf

RestArea(aSX3Area)
RestArea(aArea)

Return (lRet)

/*/
зддддддддддбддддддддддддддддбдддддбдддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o	   ЁVerRFAStruct() 	ЁAutorЁMauricio MR		  Ё Data Ё11/07/2008Ё
цддддддддддеддддддддддддддддадддддадддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁVerifica a estrutura da base RFA							Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   ЁVerRFAStruct()				 								Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁNIL                      									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso	   ЁGenerica      										    	Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/           
Function  VerRFAStruct()

Local lRet		:= .F.

lRet	:= 	!Empty(RetOrder('RFA', 'RFA_FILIAL+RFA_CRACHA+DTOS(RFA_DATA)+STR(RFA_HORA,5,2)',.T.))  .and. ;
			!Empty(RetOrder('RFA', 'RFA_ORIG+RFA_CRACHA+DTOS(RFA_DATA)+STR(RFA_HORA,5,2)',.T.)) 


Return (lRet)

/*
зддддддддддбддддддддддддддддбдддддбдддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    Ё AjustSX3		ЁAutorЁ  Luiz Almeida     Ё Data Ё09/01/2007Ё
цддддддддддеддддддддддддддддадддддадддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o Ё															Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё< Vide Parametros Formais >									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
Ё Uso      ЁPONA230                                                     Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
Ё Retorno  ЁaRotina														Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ< Vide Parametros Formais >									Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды*/
Function VerSPIStruct()
Local aArea		:= GetArea()
Local aSX3Area  := SX3->(GetArea())
Local lRet		:= .F.

SX3->(DbSetOrder(2))

If SX3->(dbSeek("PI_NUMPAG")) .and. SX3->(dbSeek("PI_ROTEIR"))
	lRet := .T.
EndIf

If lRet
	If SX3->(dbSeek("PI_PROCES"))
		If (AllTrim(GetSx3Cache("PI_PROCES", "X3_VALID")) != 'PIProcesVld()')
			lRet := .F.
		EndIf
	EndIf
EndIf

RestArea(aSX3Area)
RestArea(aArea)

Return (lRet)

/*                                	
зддддддддддбддддддддддддддддбдддддбдддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    Ё PONLoadExec	ЁAutorЁ  Igor Franzoi     Ё Data Ё29/06/2009Ё
цддддддддддеддддддддддддддддадддддадддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁFuncao executada a cada rotina (menu) chamado pelo PON		Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   ЁPONLoadExec													Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
Ё Uso      ЁGenerico													Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
Ё Retorno  Ё															Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ< Vide Parametros Formais >									Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды*/
Function PONLoadExec()

If FindFunction("SPFLoadExec()")
	SPFLoadExec()
EndIf

Return (Nil)
/*/
зддддддддддбдддддддддддддбддддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤┘o    ЁPort1510     ЁAutor ЁLeandro Drumond      Ё Data Ё02/10/09  Ё
цддддддддддедддддддддддддаддддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤┘o ЁVerifica se Portaria 1510/2009 esta em vigor.               Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё< Vide Parametros Formais >								  	Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ< Vide Parametros Formais >								  	Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function Port1510()
Local lRet := .F.

If DPORT1510 == "25/11/09" .and. cPaisLoc == "BRA"
	lRet := .T.
EndIf

Return lRet
