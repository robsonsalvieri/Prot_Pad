#INCLUDE "PONM040.CH"
#INCLUDE "PROTHEUS.CH"
#INCLUDE "PONCALEN.CH"


Static lPnm040CposBlock
Static lPnm040SplBlock
Static lPnm040Sr8Block
Static lPnm040SrfBlock
 
/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Verifica se a Execucao eh no AS/400                          ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
#IFDEF TOP
	Static lExInAs400 := ExeInAs400()
#ENDIF

Static __lIntAllP := IF( ( ( SuperGetMv("MV_INTALLP",NIL,"0") == "0" ) ) ,.F. , .T. ) 

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³ PONM040  ³ Autor ³ Marinaldo de Jesus    ³ Data ³11/05/2001³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Integracao com a Folha de Pagamento                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso  	 ³ SIGAPON							   						  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³         ATUALIZACOES SOFRIDAS DESDE A CONSTRU€AO INICIAL.             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Programador ³ Data   ³ BOPS ³  Motivo da Alteracao                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Marinaldo   ³13/02/02³Melhor³Inclusao das Perguntas Data De/Date Ate pa³±±
±±³            ³        ³      ³ra Definir o Periodo Para Integracao com a³±±
±±³            ³        ³      ³Folha de Pagamento						  ³±±
±±³Marinaldo   ³14/02/02³Melhor³Inclusao de Pergunta  para Verificar se re³±±
±±³            ³        ³      ³grava ou Nao Lancamento do Ponto.		  ³±±
±±³            ³        ³      ³Verificar a Quantidade Maxima de  Lancamen³±±
±±³            ³        ³      ³tos Permitidos para a Verba				  ³±±
±±³            ³        ³      ³Verificar se a verba permite lancamento	  ³±±
±±³Marinaldo   ³15/02/02³Melhor³Quando nao Houverem Verbas a serem integra³±±
±±³            ³        ³      ³das com a Folha mas existirem verbas    no³±±
±±³            ³        ³      ³SRC que correspondem a Integracao do Ponto³±±
±±³            ³        ³      ³essas serao excluidas do SRC              ³±±
±±³Marinaldo   ³21/02/02³Acerto³Exclusao da ValidPerg() que carregava   No³±±
±±³            ³        ³      ³vas perguntas no SX1. Para a versao   7.10³±±
±±³            ³        ³      ³o SX1 foi atualizado atraves do ATUSX     ³±±
±±³Marinaldo   ³15/02/02³Melhor³Inclusao de Coluna para Demonstrar a Incon³±±
±±³            ³        ³      ³sistencia no Relatorio de Inconsitencia na³±±
±±³            ³        ³      ³Integracao com a Folha de Pagamento		  ³±±
±±³Marinaldo   ³18/04/02³Melhor³Utilizacao da Funcao fMakeLog() para gerar³±±
±±³            ³        ³      ³o Log de Inconsistencias				  ³±±
±±³Marinaldo   ³06/01/03³Melhor³Nao Mostrar mais o nome do funcionario mas³±±
±±³            ³        ³      ³a Evolucao percentual da geracao das marca³±±
±±³            ³        ³      ³cacoes para ganho de performance          ³±±
±±³            ³        ³      ³Substituicao da processa com uma barra  de³±±
±±³            ³        ³      ³Gauge pela com duas barras				  ³±±
±±³MauricioMR  ³06/05/03³Melhor³Desdobramento de lancamentos do Ponto para³±±
±±³&           ³        ³      ³"n" lancamentos de verbas da Folha confor-³±±
±±³Marinaldo   ³        ³      ³me limite do tamanho do campo. Reformula- ³±±
±±³            ³        ³      ³cao do programa para tratamento de blo-   ³±±
±±³            ³        ³      ³queios, otimizacao de codigo e geracao de ³±±
±±³            ³        ³      ³logs adicionais.                          ³±±
±±|Marinaldo   ³21/04/04³Melhor³Tratamento nos Lock dos Registros e Delete|±± 
±±|Mauricio MR ³28/04/04³Melhor³Tratamento de cFilAnt para Integridade	  |±±
±±|Kelly S.    ³13/07/06³Melhor³Integracao por processo, periodo, numero  |±±
±±|            ³        ³      ³de pagto e roteiro.                       |±±
±±|Leandro DR  ³28/01/08³Melhor³Adequacao para utilizar tabela de inciden-|±±
±±|            ³        ³      ³cia RGB e gravar ausentismos na tabela SR8|±±
±±|Leandro DR  ³20/08/08³152351³Ajuste na gravacao das verbas na rgb e sr8|±±
±±|Leandro DR  ³20/01/09³MELHOR³Correcao do CH para o periodo n cadastrado|±±
±±|Mauricio T. ³06/04/09³005638³Ajuste para traducao de Pergunte.         |±±
±±|Leandro DR  ³15/05/09³011767³Ajuste para verificar se a gravacao e na  |±±
±±|            ³        ³      ³RGB ou SRC.                               |±±
±±|Marcia Moura³22/01/10³      ³Ajuste para controle de ITEM e Classe Val |±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Programador ³ Data   ³FNC             ³  Motivo da Alteracao           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±|Alceu P.    ³29/04/10³00000007689/2010³Feito ajuste para atualizar cor ³±±
±±|			   ³		³				 ³retamente o campo PL_INTEGRA.	  ³±±
±±|Alex Fagunde³14/03/11³00000006086/2011³Inclusao de 3 novos Pontos de   ³±±
±±|			   ³		³				 ³Entradas: PNM40SPL, PNM40SR8  e ³±±
±±|			   ³		³				 ³PNM40SRF, utilizados no Mexico. ³±±
±±|Alex Fagunde³16/05/11³00000011186/2011³Ajuste na geracao do campo ID.  ³±±
±±|			   ³		³				 ³utilizados no Mexico.           ³±±
±±|R.Berti     ³09/09/11³TDQ049³Ajust.sit.func.qdo.ha AUSENCIA -Atual.leg.³±±
±±|Leandro Dr. ³07/12/11³TDSKP3³Ajuste no Seek da RG8.                    ³±±    
±±|Claudinei S.³12/09/12³TFSEGJ³Ajuste Pnm040Processa p/ corrigir a grava-³±± 
±±|            ³        ³      ³cao do lancto respeitando qtd limite verba³±± 
±±|M. Silveira ³06/09/13³THPZIV³Ajuste na Cria_Temp() p/montar a estrutura³±±
±±|            ³        ³      ³dos campos conforme a tabela correta.     ³±±
±±|Cícero Alves³02/03/15³      ³Retirada da função AjustaSX1 para         ³±±
±±|            ³        ³      ³ficar de acordo com a versão 12           ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß */
Function PONM040

Local aArea					:= GetArea()
Local aSays					:= {}
Local aButtons				:= {}
Local cPerg					:= "PONM040"
Local cSvFilAnt				:= cFilAnt
Local lBarG1ShowTm 			:= .F.
Local lBarG2ShowTm 			:= .F.
Local lRet					:= 0
Local nOpcA					:= 0

Private lAbortPrint			:= .F.
Private cCadastro   		:= OemToAnsi(STR0001 )	//"Integra‡„o com a Folha de Pagamento"

Private cProcesso			:= ""
Private cRot 				:= "PON"
Private cPeriodo			:= ""
Private cNumPagto			:= ""
Private cCond				:= "2"
Private dFecPag 			:= Ctod("//")
Private dtFim				:= Ctod("//")
Private cdtFim				:= ""
Private nPosRegRCH			:= 0  
Private oPeriodo		    := RHPERIODO():New()
Private oPerFol			    := RHPERIODO():New()

DEFAULT lPnm040CposBlock	:= ExistBlock( "PNM040CPOS"	) 
DEFAULT lPnm040SplBlock		:= ExistBlock( "PNM40SPL" ) 
DEFAULT lPnm040Sr8Block		:= ExistBlock( "PNM40SR8" ) 
DEFAULT lPnm040SrfBlock		:= ExistBlock( "PNM40SRF" ) 

Private lItemCLVL := SuperGetMv( "MV_ITMCLVL", .F., "2" ) == "1"  // Verificar contabilizacao por item contabil e classe de valor

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Inicializa propriedades do objeto Periodo					   ³
³ O RCH deverah sempre ser compartilhado.					   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
oPeriodo:cRoteiro	:= "PON"
oPeriodo:cFilRCH	:= 	xFilial('RCH')

Pnm040Load()

IF ( ValidArqPon() )
	
	aAdd(aSays,OemToAnsi( STR0002 ) )	// "Este programa ira efetuar a Gera‡„o dos Resultados"
		
	aAdd(aButtons, { 5,.T.,{|| Pergunte( cPerg , .T. ) } } )
	aAdd(aButtons, { 1,.T.,{|o| nOpcA := 1,IF(GpConfOK(),FechaBatch(),nOpcA:=0 ) } } )
	aAdd(aButtons, { 2,.T.,{|o| FechaBatch() } } )
		
	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Monta e Disponibiliza Tela para Selecao das Perguntas 			 ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	FormBatch( cCadastro , aSays , aButtons )
	
	IF ( nOpcA == 1 )
		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Verifica se deve Mostrar Calculo de Tempo nas BarGauge			 ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		lBarG1ShowTm := ( SuperGetMv("MV_PNSWTG1",NIL,"N") == "S" )
		lBarG2ShowTm := ( SuperGetMv("MV_PNSWTG2",NIL,"S") == "S" )
		/*                               
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Executa o Processo de Integracao com a Folha de Pagamento			 ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		Proc2BarGauge( {|| Pnm040Processa( cPerg ) } , cCadastro , NIL , NIL , .T. , lBarG1ShowTm , lBarG2ShowTm )
	EndIF	

EndIF	
cFilAnt := cSvFilAnt

RestArea( aArea )

Return( NIL )

/*
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³PONM040Processa³ Autor ³Marinaldo de Jesus³ Data ³11/05/2001³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³ Processa a Integra‡„o Integra‡„o com a Folha de Pagamento  ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Uso  	   ³ SIGAPON							             			³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³                                                            ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
Static Function Pnm040Processa( cPerg )

Local aLog			:= {} 
Local aLogPer		:= {}  
Local aLogSemVerba  := { STR0040 } //"Filial   Verbas"		
Local aLogAusencia  := { STR0038 } //"Filial   Matr.   Nome                            Dt.Ausencia"		}
Local aLogSemLcto   := { STR0039 } //"Filial   Matr.   Nome	"
Local aLogProcesso  := { STR0043 } //"Filial   Matr.   Nome                            Processo   Periodo   Roteiro   Num. Pagto."
Local aSemVerba		:= {}
Local aColsGRV		:= {}
Local bBlkSortSPL 	:= 	{ |x,y|	(  DtoS(x[ nPosSPLDATA ]) + x[ nPosSPLPD ] + x[ nPosSPLCC ] + x[ nPosSPLFUNC ] + x[ nPosSPLPOSTO ] + x[ nPosSPLDEPTO ] );
	 									<;
	 											(  DtoS(y[ nPosSPLDATA ]) + y[ nPosSPLPD ] + y[ nPosSPLCC ] + y[ nPosSPLFUNC ] + y[ nPosSPLPOSTO ] + y[ nPosSPLDEPTO ]);
	 			  						}

Local aAfast 		:= {}
Local nPosAfast		:= 0

Local aGRVColEmpty	:= {}
Local aResultRCH	:= {}
Local aColsSPL		:= {}
Local aSPLQCond		:= {}
Local aGRVQCond		:= {}
Local aGRVVirtual	:= {}
Local aSPLVirtual	:= {}
Local aAreaSPL		:= SPL->( GetArea() )
Local aAreaSRA		:= SRA->( GetArea() )
Local aAreaGRV		:= {}
Local aInfo			:= {} 
Local aItensSPL		:= {}   
Local aRecnoGRV		:= {}    
Local aSeqGRV		:= {}  
Local aHeaderSPL	:= {}
Local aHeaderGRV	:= {}  
Local aRecsBarG		:= {}  
Local aSitFun		:= {}  
Local aVerbas		:= {{},{},{}}
Local bEval			:= { |e| &(e) }

Local bCondSrv		:= { |e| If (ValType(e) = "C",&(e),If (ValType(e) = "B",Eval(e),.F.)) } 		
Local cCondSrv 		

Local cMens			:= ""
Local cTimeIni		:= Time()
Local cAlias		:= ""    
Local cExclui		:= "" 
Local cFilRCM		:= ""
Local cFilSRV		:= ""
Local cFilSRA		:= ""
Local cFilSR8		:= ""
Local cMatSRA		:= ""   
Local cNomeSRA		:= ""
Local cItemSRA      := ""
Local cCLVLSRA      := ""
Local cInicio		:= ""
Local cFim			:= ""
Local cAcessaSRA	:= IF( Empty( cAcessaSRA := ChkRH( "PONM040" , "SRA" , "2" ) ) , ".T." , cAcessaSRA )
Local cArqDbf		:= ""
Local cArqInd		:= ""
Local cNomeArq		:= ""
Local cChaveFilMat	:= ""
Local cLastFil		:= "__LastFil__"  
Local cMsgBarG1		:= ""
Local cSRALock		:= "SRA"	

Local  cTipoAfa		:= ""

Local cSRAIndexKey	:= ""
Local cPerIni		:= "" 
  
Local cMvModFol		:= "1"                  
 
Local cIncidencias	:= ""
Local cAusencias	:= ""
Local cHorasExtras	:= ""
Local dPerIni		:= Ctod("//")
Local dPerFim		:= Ctod("//")
Local lIntegra		:= .T.
Local lAdmMes		:= .T.
Local lSobrepoe		:= .F.
Local lLancaPd		:= .T. 
Local lLctoDia		:= .T.
Local lSRVComp		:= Empty( xFilial( "SRV" ) )  
Local lPrimVez		:= .T.
Local lObtemRecDel	:= .T.


Local nIndice		:= 0
Local nNumSeq		:= 0.00
Local nSeq			:= 1

Local naColsSPL		:= 0.00   
Local naColsGRV		:= 0.00
Local nLastRec		:= 0.00
Local nIncPercG1	:= 0.00
Local nIncPercG2	:= 0.00
Local nLenaItens	:= 0.00
Local nLenaRecGRV 	:= 0.00   
Local nLenGRVaCols 	:= 0.00  
Local nLenSPLaCols 	:= 0.00  
Local nLimHoras		:= Val( Replicate( "9", ( TamSx3("RC_HORAS")[1] - ( TamSx3("RC_HORAS")[2] + 1 ) ) ) + "." + Replicate("9",TamSx3("RC_HORAS")[2]))
Local nLimValor		:= Val( Replicate( "9", ( TamSx3("RC_VALOR")[1] - ( TamSx3("RC_VALOR")[2] + 1 ) ) ) + "." + Replicate("9",TamSx3("RC_VALOR")[2]))
Local nPosVerbas	:= 0
Local nPosGRV		:= 0.00
Local nRecnoSRA		:= 0.00
Local bBlkSorPD
Local cKeyVerba		:= ""
Local nIdVerba		:= ""
Local cKeyGRV		:= ""
Local cKeyRG8		:= ""
Local cPDAnt		:= ""
Local cProcAnt		:= ""
Local cPerAnt		:= ""
Local cNPagAnt		:= ""
Local nX

#IFDEF TOP
   	Local aStruSRA		:= {}
	Local aCposSRA		:= {}
	Local aParamDat		:= {}
	Local aTempSRA		:= SRA->( dbStruct() )
	Local aRchFields	:= RCH->( dbStruct() )
	Local cIniData		:= ""
	Local cFimData		:= ""
	Local cQuery	 	:= ""
	Local cWhere		:= ""	
	Local cFixQuery		:= ""
	Local cRchFields	:= ""
	Local cRCHFilter	:= ""
	Local cOrderSRA		:= ""
	Local nPosPer		:= 0
	Local nPosProc 		:= 0
	Local nPosDtIni 	:= 0
	Local nPosDtFim 	:= 0
	Local nPosDtFec 	:= 0
	Local nPosRchFil	:= 0
	Local nProcRch		:= 0
	Local nPosNumPag	:= 0	
	Local lSraQryOpened	:= .F.
	Local nContField	:= Len( aTempSRA	)
	Local uRet			:= NIL
#ENDIF

Private aSPLRec			:= {}
Private aSPLRecEfe		:= {}
Private aGRVRec			:= {} 
Private aGRVRecDel		:= {}
Private aProcesso		:= {}

Private	cFilDe			:= ""
Private cFilAte			:= ""
Private cCcDe			:= ""
Private cCcAte			:= ""
Private cTnoDe			:= ""
Private cTnoAte			:= ""
Private cRegDe			:= ""               
Private cRegAte     	:= ""
Private cMatDe			:= ""
Private cMatAte			:= ""
Private cNomeDe			:= ""
Private cNomeAte		:= ""
Private cSituacao		:= ""
Private cSqlSitua		:= ""
Private cCategoria		:= ""   
Private cSqlCateg		:= ""
Private cPrefixo		:= ""
Private cProcRG8		:= ""
Private cRotRG8			:= ""
Private cPerRG8			:= ""
Private cNPagRG8		:= ""

Private cPerBranco    	:= Space( TamSX3(   "PL_PERIODO" 	)[1] ) 
Private cProcesBranco 	:= Space( TamSX3(   "PL_PROCES" 	)[1] ) 
Private cFilBranco		:= Space( TamSx3(	"RA_FILIAL"		)[1] )
Private cMatBranco 		:= Space( TamSx3(	"RA_MAT"		)[1] )
Private cNomeBranco		:= Space( TamSx3(	"RA_NOME"		)[1] )  

Private nCountGRV		:= 0.0

Private nPosSPLCC  		:= 0.00
Private nPosSPLPD		:= 0.00
Private nPosSPLHORAS	:= 0.00
Private nPosSPLVALOR	:= 0.00
Private nPosSPLT1   	:= 0.00
Private nPosSPLT2   	:= 0.00
Private nPosSPLDATA		:= 0.00   
Private nPosSPLFUNC		:= 0.00   
Private nPosSPLLin 		:= 0.00
Private	nPosSPLRec  	:= 0.00
Private nPosSPLD1		:= 0.00
Private nPosSPLD2		:= 0.00
Private nPosSPLD3		:= 0.00
Private nPosSPLD4		:= 0.00
Private nPosSPLD5		:= 0.00
Private nPosSPLD6		:= 0.00
Private nPosSPLD7		:= 0.00
Private nPosSPLPosto	:= 0.00
Private nPosSPLDepto	:= 0.00
Private nPosSPLProc		:= 0.00
Private nPosSPLRot		:= 0.00
Private nPosSPLPer		:= 0.00
Private nPosSPLNPag		:= 0.00
	
Private nPosGRVCC  		:= 0.00
Private nPosGRVPD		:= 0.00
Private nPosGRVSEQ		:= 0.00
Private nPosGRVT2   	:= 0.00
Private nPosGRVT1   	:= 0.00
Private nPosGRVHINFO	:= 0.00
Private nPosGRVHCALC	:= 0.00
Private nPosGRVVINFO	:= 0.00   
Private nPosGRVVCALC	:= 0.00
Private nPosGRVPOSTO	:= 0.00
Private nPosGRVDEPTO	:= 0.00
Private nPosGRVSEMANA	:= 0.00 
Private nPosGRVPROCES	:= 0.00
Private nPosGRVPERIODO	:= 0.00
Private nPosGRVROTEIRO	:= 0.00
Private nPosGRVDATAREF	:= 0.00
Private nPosGRVFUNC		:= 0.00
Private nPosGRVD1		:= 0.00
Private nPosGRVD2		:= 0.00
Private nPosGRVD3		:= 0.00
Private nPosGRVD4		:= 0.00
Private nPosGRVD5		:= 0.00
Private nPosGRVD6		:= 0.00
Private nPosGRVD7		:= 0.00
Private nPosGRVSR8		:= 0.00
Private nPosGRVR8QTD	:= 0.00

Private nPosdataGRV		:= 0.00
Private nPosGRVNUMID	:= 0.00
Private nPosGRVDeleted	:= 0.00   


Private lItemCLVL := SuperGetMv( "MV_ITMCLVL", .F., "2" ) == "1"  // Verificar contabilizacao por item contabil e classe de valor


//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Carregando as Perguntas                                      ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Pergunte( cPerg , .F. )

#IFDEF TOP
	MakeSqlExpr( "PONM040" )
#ELSE
	MakeAdvplExpr( "PONM040" )
#ENDIF

aNotGRV := {}

If FindFunction("SPFilterOff")                   //   Alteracao referente ao projeto: SuperFiltro
   SPFilterOff( { "SRA","SRC","RGB","RCH" } )	 //   Desabilita filtro no alias - SRA, SRC, RGB, RCH.
EndIf

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Verifica o Modelo de folha pagto usado no Mexico			   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/   
If cPaisLoc = "MEX"
 	cMvModFol		:= SuperGetMv("MV_MODFOL",NIL,"1")
Endif 

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Grava no SRC para TODOS os paises menos para os paises nas  ³
³ nas  condicoes abaixo										  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/                               
If ( ( cPaisLoc == 'MEX' .and. cMvModFol == "1" ) .or. ( cPaisLoc == 'BRA' ) .or. ( cPaisLoc == 'BOL' ) )

	cAlias 		:= "SRC"
	aAreaGRV	:= SRC->( GetArea() )
	aAdd( aNotGRV , "RC_FILIAL" )
	aAdd( aNotGRV , "RC_MAT"	)              
	If !lItemCLVL
		aAdd( aNotGRV , "RC_ITEM" )
		aAdd( aNotGRV , "RC_CLVL"	)
	endif
	
	cPrefixo := "RC"
	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Carrega a Estrutura do SRC		        								³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/              
	aHeaderGRV 	:= SRC->( GdMontaHeader(NIL,@aGRVVirtual,NIL,NIL,aNotGRV,NIL,NIL,.F.,.F.,.F.,.F.) )	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Obtem o Posicionamento dos Campos do GRV								³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	nPosGRVCC  		:= GdFieldPos( "RC_CC"		, aHeaderGRV )	//[01] C.Custo
	nPosGRVPD		:= GdFieldPos( "RC_PD"		, aHeaderGRV )	//[02] PD
	nPosGRVSEQ		:= GdFieldPos( "RC_SEQ"		, aHeaderGRV )	//[03] Sequencia
	nPosGRVT1   	:= GdFieldPos( "RC_TIPO1"	, aHeaderGRV )	//[04] Tipo1			
	nPosGRVT2   	:= GdFieldPos( "RC_TIPO2"	, aHeaderGRV )	//[05] Tipo2	
	nPosGRVHCALC	:= GdFieldPos( "RC_HORAS"	, aHeaderGRV )	//[06] Horas Calculadas
	nPosGRVHINFO	:= GdFieldPos( "RC_HORINFO"	, aHeaderGRV )	//[07] Horas Informadas
	nPosGRVVCALC	:= GdFieldPos( "RC_VALOR"	, aHeaderGRV )	//[08] Valor Calculado
	nPosGRVVINFO	:= GdFieldPos( "RC_VALINFO"	, aHeaderGRV )	//[09] Valor Informado                         
	nPosGRVSEMANA	:= GdFieldPos( "RC_SEMANA"	, aHeaderGRV )	//[10] Semana
	nPosGRVPROCES	:= GdFieldPos( "RC_PROCES"	, aHeaderGRV )	//[12] Processo
	nPosGRVPERIODO	:= GdFieldPos( "RC_PERIODO"	, aHeaderGRV )	//[13] Periodo
	nPosGRVROTEIRO	:= GdFieldPos( "RC_ROTEIR"	, aHeaderGRV )	//[14] Roteiro
	nPosGRVDATAREF	:= GdFieldPos( "RC_DTREF"	, aHeaderGRV )	//[15] Data de Referencia
	nPosGRVFunc     := GdFieldPos( "RC_CODFUNC"	, aHeaderGRV )	//[16] Clve del puesto 
	nPosDataGRV		:= GdFieldPos( "RC_DATA"	, aHeaderGRV )	//[17] Data de Pagto 
	nPosGRVNumID	:= GdFieldPos( "RC_NUMID"	, aHeaderGRV )	//[18] Numero de Identicacao
	nPosGRVPOSTO	:= GdFieldPos( "RC_POSTO"	, aHeaderGRV ) 	//[19] Posto
	nPosGRVDEPTO	:= GdFieldPos( "RC_DEPTO"	, aHeaderGRV ) 	//[20] Depto	
	nPosGRVDeleted	:= Len(aHeaderGRV)+1	//GdFieldPos( "GDDELETED"	, aHeaderGRV )	//[9] Posicao de Deletado no aCols	


//ElseIf ( ( cPaisLoc == 'MEX' .and. cMvModFol == "2" ) .or. ( cPaisLoc == 'PTG' ) )
Else

	cAlias 			:= "RGB"
	aAreaGRV		:= RGB->( GetArea() )	
	aAdd( aNotGRV , "RGB_FILIAL" )
	aAdd( aNotGRV , "RGB_MAT"    )
	If !lItemCLVL
		aAdd( aNotGRV , "RGB_ITEM" )
		aAdd( aNotGRV , "RGB_CLVL"	)
	endif
		
	cPrefixo 		:= "RGB"
	
	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Carrega a Estrutura do RGB		        								³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/              
	aHeaderGRV 	:= RGB->( GdMontaHeader(NIL,@aGRVVirtual,NIL,NIL,aNotGRV,NIL,NIL,.F.,.F.,.F.,.F.) )
	nPosGRVCC  		:= GdFieldPos( "RGB_CC"		, aHeaderGRV )	//[01] C.Custo
	nPosGRVPD		:= GdFieldPos( "RGB_PD"		, aHeaderGRV )	//[02] PD
	nPosGRVSEQ		:= GdFieldPos( "RGB_SEQ"	, aHeaderGRV )	//[03] Sequencia
	nPosGRVT1   	:= GdFieldPos( "RGB_TIPO1"	, aHeaderGRV )	//[04] Tipo1			
	nPosGRVT2   	:= GdFieldPos( "RGB_TIPO2"	, aHeaderGRV )	//[05] Tipo2	
	nPosGRVHCALC	:= GdFieldPos( "RGB_HORAS"	, aHeaderGRV )	//[06] Horas Calculadas
	nPosGRVHINFO	:= GdFieldPos( "RGB_HORINFO", aHeaderGRV )	//[07] Horas Informadas
	nPosGRVVCALC	:= GdFieldPos( "RGB_VALOR"	, aHeaderGRV )	//[08] Valor Calculado
	nPosGRVVINFO	:= GdFieldPos( "RGB_VALINFO", aHeaderGRV )	//[09] Valor Informado                         
	nPosGRVSEMANA	:= GdFieldPos( "RGB_SEMANA"	, aHeaderGRV )	//[10] Semana
	nPosGRVPOSTO	:= GdFieldPos( "RGB_POSTO"	, aHeaderGRV ) 	//[11] Posto
	nPosGRVDEPTO	:= GdFieldPos( "RGB_DEPTO"	, aHeaderGRV ) 	//[12] Depto	
	nPosGRVPROCES	:= GdFieldPos( "RGB_PROCES"	, aHeaderGRV )	//[13] Processo
	nPosGRVPERIODO	:= GdFieldPos( "RGB_PERIOD"	, aHeaderGRV )	//[14] Periodo
	nPosGRVROTEIRO	:= GdFieldPos( "RGB_ROTEIR"	, aHeaderGRV )	//[15] Roteiro
	nPosGRVDATAREF	:= GdFieldPos( "RGB_DTREF"	, aHeaderGRV )	//[16] Data de Referencia
	nPosGRVFunc     := GdFieldPos( "RGB_CODFUN"	, aHeaderGRV )	//[17] Clve del puesto 
	nPosDataGRV		:= GdFieldPos( "RGB_DATA"	, aHeaderGRV )	//[18] Data de Pagto 
	nPosGRVNumID	:= GdFieldPos( "RGB_NUMID"	, aHeaderGRV )	//[19] Numero de Identicacao	
	nPosGRVD1		:= GdFieldPos( "RGB_DUM"	, aHeaderGRV ) 	//[20] PD 1
	nPosGRVD2		:= GdFieldPos( "RGB_DDOIS"	, aHeaderGRV ) 	//[21] PD 2
	nPosGRVD3		:= GdFieldPos( "RGB_DTRES"	, aHeaderGRV ) 	//[22] PD 3
	nPosGRVD4		:= GdFieldPos( "RGB_DQUATR"	, aHeaderGRV ) 	//[23] PD 4
	nPosGRVD5		:= GdFieldPos( "RGB_DCINCO"	, aHeaderGRV ) 	//[24] PD 5
	nPosGRVD6		:= GdFieldPos( "RGB_DSEIS"	, aHeaderGRV ) 	//[25] PD 6
	nPosGRVD7		:= GdFieldPos( "RGB_DSETE"	, aHeaderGRV ) 	//[26] PD 7
		
	ADHeadRec(cAlias,aHeaderGRV) // acrescentar devido os 2 elementos do WT
	nPosGRVDeleted	:= Len(aHeaderGRV)+1	//GdFieldPos( "GDDELETED"	, aHeaderGRV )	//[9] Posicao de Deletado no aCols	
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Carregando MV_PAR nas Variaveis do Sistema                   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
cFilDe		:= mv_par01				//Filial De
cFilAte		:= mv_par02				//Filial Ate
cCcDe		:= mv_par03				//Centro de Custo De
cCcAte		:= mv_par04				//Centro de Custo Ate
cTnoDe		:= mv_par05             //Turno De
cTnoAte		:= mv_par06             //Turno Ate
cRegDe		:= mv_par07				//Regra Ate
cRegAte     := mv_par08             //Regra Ate
cMatDe		:= mv_par09				//Matricula De
cMatAte		:= mv_par10				//Matricula Ate
cNomeDe		:= mv_par11				//Nome De
cNomeAte	:= mv_par12				//Nome Ate
cSituacao	:= mv_par13				//Situacaoes
cCategoria	:= mv_par14				//Categorias
lIntegra	:= ( mv_par15 == 1 )	//Integracao ou Geracao
cNomeArq	:= mv_par16				//Nome do Arquivo Para Geracao do TXT
lAdmMes  	:= ( mv_par17 == 1 )	//Gera Para Admitidos no Mes
dMvPerIni	:= mv_par18				//Data Inicial do Processamento
dMvPerFim	:= mv_par19				//Data Final do Processamento
lSobrepoe	:= ( mv_par20 == 1 )	//Sobrepoe Marcacoes Existentes 
cProcesso	:= mv_par21				//Processo
cPeriodo	:= mv_par22				//Periodo da folha
cNumPagto   := mv_par23				//Num. Pagto
cRot		:= mv_par24             //Roteiro

cOrderSRA := SqlOrder( SRA->( IndexKey() ) )

Begin Sequence

	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Recupera informacoes do Periodo							   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	oPeriodo:cProcesso 	:=	cProcesso
	oPeriodo:cRoteiro	:=  cRot
	oPeriodo:cPeriodo 	:=	cPeriodo
	oPeriodo:cNumPagto	:= 	cNumPagto
	
	oPeriodo:GetPer()
	nPosRegRCH := oPeriodo:nRecno
	dPerIni	:= oPeriodo:dDataIni
	dPerFim	:= oPeriodo:dDataFim
	cdtFim  := DtoS(dPerFim)

    cKeyRG8 := "PON" + oPeriodo:cPeriodo + oPeriodo:cNumPagto + oPeriodo:cProcesso + oPeriodo:cRoteiro

	RG8->( dbsetOrder( Retorder( "RG8" , "RG8_FILIAL+RG8_MODORI+RG8_PERORI+RG8_NPGORI+RG8_PRCORI+RG8_ROTORI" ) ) )
    
	//PROCURA CHAVE CORRESPONDENTE DA FOLHA
	If RG8->( dbSeek( xFilial("RG8") + cKeyRG8 ) )
		cProcRG8	:= 	RG8->RG8_PROCOR
		cRotRG8		:=	RG8->RG8_ROTCOR
		cPerRG8		:=	RG8->RG8_PERCOR
		cNPagRG8	:= 	RG8->RG8_NPGCOR
				
		oPerFol:cProcesso 	:=	cProcRG8
		oPerFol:cRoteiro	:=  cRotRG8
		oPerFol:cPeriodo 	:=	cPerRG8
		oPerFol:cNumPagto	:= 	cNPagRG8
		
		oPerFol:GetPer()
		
		If oPerFol:lFechado
			MsgInfo( OemToAnsi( STR0044 ) +;
					 " " + CRLF + OemToAnsi( STR0045) )    //"Período Correspondente Fechado!" "Selecione outro período em Corrêspondência de Períodos."
			Break
		EndIf
	Else
		MsgInfo( OemToAnsi( STR0041 ) )    //"Período da folha (RG8) não encontrado"
		Break
	EndIf
	
	aCposSRA	:= {}
	
	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Inicializa Filial/Turno De/Ate							   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	cFilTnoDe	:= ( cFilDe + cTnoDe )
	cFilTnoAte	:= ( cFilAte + cTnoAte )	

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Bloco que definira a Consistencia da Parametrizacao dos Intervalos sele³
	//³cionados nas Perguntas De? Ate?.                                       ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	cExclui += "(RA_FILIAL   < cFilDe     .or. RA_FILIAL  > cFilAte    ) .or."
	cExclui += "(RA_CC       < cCcDe      .or. RA_CC      > cCCAte     ) .or." 
	cExclui += "(RA_TNOTRAB  < cTnoDe     .or. RA_TNOTRAB > cTnoAte    ) .or." 
	cExclui += "(RA_TNOTRAB  < cTnoDe     .or. RA_TNOTRAB > cTnoAte    ) .or." 
	cExclui += "(RA_REGRA    < cRegDe     .or. RA_REGRA   > cRegAte    ) .or." 
	cExclui += "(RA_MAT      < cMatDe     .or. RA_MAT     > cMatAte    ) .or." 
	cExclui += "(RA_NOME     < cNomeDe    .or. RA_NOME    > cNomeAte   ) .or." 
	cExclui += "!(RA_PROCES  = oPeriodo:cProcesso) .or." 
	cExclui += "!(RA_SITFOLH $ cSituacao) .or. "
	cExclui += "!(RA_CATFUNC $ cCategoria)"
	
	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Cria Arquivo Temporario Quando for Exportacao.                         ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	IF !( lIntegra )
		cAlias := "PONM040TMP"
		IF !Cria_Temp( @cArqDbf , @cArqInd )
			Help(" ",1,"PN040NOARQ")
			Return( NIL )
		EndIF
	EndIF
	
	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Seta as Ordens dos Arquivos que serao utilizadas no Processamento    ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	SR8->( DbSetOrder( RetOrdem("SR8","R8_FILIAL+R8_MAT+DTOS(R8_DATAINI)+R8_TIPOAFA+STR(R8_DIASEMP)" ) ) ) 
	SPL->( dbSetOrder( RetOrdem("SPL") ) )
	SRA->( dbSetOrder( RetOrdem("SRA") ) )
	cSRAIndexKey := SRA->( IndexKey() )
	(cAlias)->( dbSetOrder( RetOrdem(cAlias) ) )


	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Atualiza a Mensagem para a IncProcG1() (Cadastro de Empresas)³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	CREATE SCOPE aInfo FOR ( M0_CODIGO == cEmpAnt )
	BarGauge1Set( ( nRecsBarG := SM0->( ScopeCount( aInfo ) ) ) )
	
	#IFNDEF TOP
		
	//	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//	³ Posiciona no Primeiro Registro Selecionado nos Parametros De/Ate     ³
	//	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		SRA->( dbSeek( cFilDe + cMatDe , .T. ) )
		
	//	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//	³ Verifica o Total de Registros a Serem Processados            ³
	//	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		aRecsBarG := {}
		CREATE SCOPE aRecsBarG FOR !Eval( bEval , cExclui )
		nLastRec := SRA->( ScopeCount( aRecsBarG ) )
	#ELSE
		
	//	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//	³ Seta apenas os Campos do SRA que serao Utilizados           ³
	//	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		aAdd( aCposSRA , "RA_FILIAL"	)
		aAdd( aCposSRA , "RA_MAT" 		)
		aAdd( aCposSRA , "RA_NOME"		)
		aAdd( aCposSRA , "RA_CC"		)
		aAdd( aCposSRA , "RA_TNOTRAB"	)
		aAdd( aCposSRA , "RA_REGRA"  	)
		aAdd( aCposSRA , "RA_ADMISSA"  	)
		
		If cPaisLoc == "MEX"
			aAdd( aCposSRA , "RA_FECREI"  	)
		EndIf
		aAdd( aCposSRA , "RA_CATFUNC"  	)
		aAdd( aCposSRA , "RA_SITFOLH"  	)
		aAdd( aCposSRA , "RA_TIPOPGT"  	)
		aAdd( aCposSRA , "RA_PROCES"  	)   
		aAdd( aCposSRA , "RA_CODRPAT"   ) 
		aAdd( aCposSRA , "RA_AFASFGT"   ) 		
		aAdd( aCposSRA , "RA_RESCRAI"   ) 
        aAdd( aCposSRA , "RA_DEMISSA"   ) 			
		if lItemCLVL
			aAdd( aCposSRA , "RA_ITEM" 	)   
			aAdd( aCposSRA , "RA_CLVL"  ) 
		Endif		
		
		
	//	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//	³ Ponto de Entrada para Campos do Usuario                      ³
	//	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		IF ( lPnm040CposBlock )
			IF ( ValType( uRet := ExecBlock("PNM040CPOS",.F.,.F.,aCposSRA) ) == "A" )
				IF Len( uRet ) >= Len( aCposSRA )
					aCposSRA := aClone(uRet)
					uRet	 := NIL
				EndIF
			EndIF
		EndIF
		For nX := 1 To nContField
			
	//		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//		³ Carrega os Campos do SRA para a Montagem da Query			   ³
	//		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			IF aScan( aCposSRA , { |x| Upper(AllTrim(x)) == Upper( AllTrim( aTempSRA[ nX , 1 ] ) ) } ) > 0.00
				aAdd( aStruSRA , aClone( aTempSRA[ nX ] ) )
			EndIF
		Next nX
		aCposSRA	:= aTempSRA := NIL
		
		
	//	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//	³ Monta string de categorias e situacoes para query			   ³
	//	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		cSqlCateg := "("
		For nX := 1 to len(cCategoria)
			If SubStr(cCategoria,nX,1) != "*"
				If Len(cSqlCateg) > 1
					cSqlCateg += ","
				Endif
				cSqlCateg += "'" + SubStr(cCategoria,nX,1) + "'"
			Endif
		Next nX
		cSqlCateg += ")"
	   
		cSqlSitua := "("
		For nX := 1 to len(cSituacao)
			If SubStr(cSituacao,nX,1) != "*"
				If Len(cSqlSitua) > 1
					cSqlSitua += ","
				Endif
				cSqlSitua += "'" + SubStr(cSituacao,nX,1) + "'"
			Endif		
		Next nX
		cSqlSitua += ")"
		
	//	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//	³ Monta a Query Condicional             					   ³
	//	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		cFixQuery := "SRA.RA_FILIAL>='"+cFilDe+"'"
		cFixQuery += " AND "
		cFixQuery += "SRA.RA_FILIAL<='"+cFilAte+"'"
		cFixQuery += " AND "
		cFixQuery += "SRA.RA_TNOTRAB>='"+cTnoDe+"'"	
		cFixQuery += " AND "
		cFixQuery += "SRA.RA_TNOTRAB<='"+cTnoAte+"'"
		cFixQuery += " AND "
		cFixQuery += "SRA.RA_MAT>='"+cMatDe+"'"	
		cFixQuery += " AND "
		cFixQuery += "SRA.RA_MAT<='"+cMatAte+"'"
		cFixQuery += " AND "
		cFixQuery += "SRA.RA_NOME>='"+cNomeDe+"'"	
		cFixQuery += " AND "
		cFixQuery += "SRA.RA_NOME<='"+cNomeAte+"'"
		cFixQuery += " AND "
		cFixQuery += "SRA.RA_REGRA>='"+cRegDe+"'"	
		cFixQuery += " AND "
		cFixQuery += "SRA.RA_REGRA<='"+cRegAte+"'"
		cFixQuery += " AND "
		cFixQuery += "SRA.RA_CC>='"+cCCDe+"'"	
		cFixQuery += " AND "
		cFixQuery += "SRA.RA_CC<='"+cCCAte+"'"
		cFixQuery += " AND "                        
		cFixQuery += "SRA.RA_PROCES = '" + oPeriodo:cProcesso+"'"
		cFixQuery += " AND "
		cFixQuery += "SRA.RA_SITFOLH IN " + cSqlSitua
		cFixQuery += " AND "
		cFixQuery += "SRA.RA_CATFUNC IN " + cSqlCateg
		cFixQuery += " AND "
		cFixQuery += "SRA.D_E_L_E_T_=' ' "
	
		
	//	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//	³ Monta a Query Para Selecao das Informacoes no SRA			   ³
	//	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		nContField	:= Len( aStruSRA ) 
		cQuery := "SELECT "
		For nX := 1 To nContField
			
	//		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//		³ Inclui os Campos na Montagem da Query						   ³
	//		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			cQuery += aStruSRA[ nX , 1 ] + ", "
		Next nX
		cQuery += "R_E_C_N_O_ RECNO "
		cQuery += "FROM "+InitSqlName("SRA")+" SRA "
		cQuery += "WHERE "
		cQuery += cFixQuery
		cQuery += "ORDER BY "+SqlOrder( cSRAIndexKey )
		cQuery := ChangeQuery(cQuery)
		
	//	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//	³ Abandona o Processamento									   ³
	//	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		SRA->( dbCloseArea() ) //Fecha o SRA para uso da Query
		
	//	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//	³ Monta e Abre a Query    									   ³
	//	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		IF ( lSraQryOpened := MsOpenDbf(.T.,"TOPCONN",TcGenQry(,,cQuery),"SRA",.T.,.T.) )
			
	//		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//		³Abre o SRA com outro alias para posterior bloqueio de    regis³
	//		³tros														   ³
	//		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			ChkFile("SRA", .F., "__SRALOCK")
			
	//		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//		³Define qual o Alias para o SRA padrao						   ³
	//		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			cSRALock:= "__SRALOCK"  
			
			
	//		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//		³Seta os Campos que nao Sao Caracteres						   ³
	//		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			For nX := 1 To nContField
				IF ( aStruSRA[nX,2] <> "C" )
					TcSetField("SRA",aStruSRA[nX,1],aStruSRA[nX,2],aStruSRA[nX,3],aStruSRA[nX,4])
				EndIF
			Next nX
			
	//		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//		³ Verifica o Total de Registros a Serem Processados            ³
	//		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			cQuery := "SELECT COUNT(*) NLASTREC "
			cQuery += "FROM "+InitSqlName("SRA")+" SRA "
			cQuery += "WHERE "
			cQuery += cFixQuery
			cQuery := ChangeQuery(cQuery)
	        IF ( MsOpenDbf(.T.,"TOPCONN",TcGenQry(,,cQuery),"__QRYCOUNT",.T.,.T.) )
				nLastRec := __QRYCOUNT->NLASTREC
				__QRYCOUNT->( dbCloseArea() )
	        Else
				MsAguarde( { || SRA->( dbEval( { || ++nLastRec } ) ) } , STR0021 + STR0022 )	//'Aguarde...'###'Selecionaldo Funcionarios'
				SRA->( dbGotop() )
			EndIF
			cFixQuery := ""	
		Else
			
	//		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//		³ Restaura Arquivo Padrao e Ordem                             ³
	//		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			ChkFile( "SRA" )
			SRA->( dbSetOrder( RetOrdem("SRA") ) )
			
	//		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//		³ Posiciona no Primeiro Registro Selecionado nos Parametros De/Ate     ³
	//		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			SRA->( dbSeek( cFilDe + cMatDe , .T. ) )
			
	//		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//		³ Verifica o Total de Registros a Serem Processados            ³
	//		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			aRecsBarG := {}
			CREATE SCOPE aRecsBarG FOR !Eval( bEval , cExclui )
			nLastRec := SRA->( ScopeCount( aRecsBarG ) )
		EndIF
	#ENDIF
	
	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Inicializa a Mensagem para a IncProcG2() ( Funcionarios )	   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	IncProcG2( OemToAnsi( STR0003 ) , .F. )	//"Processando..."
	
	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Inicia regua de processamento.                               ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	BarGauge2Set( nLastRec )
	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Carrega a Estrutura do SPL              								³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	aHeaderSPL 	:= SPL->( GdMontaHeader(NIL,@aSPLVirtual,NIL,NIL,NIL,NIL,.T.,.F.,.F.,.F.) )
	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Obtem o Posicionamento dos Campos do SPL								³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	nPosSPLCC  		:= GdFieldPos( "PL_CC"		, aHeaderSPL )	//[01] C.Custo
	nPosSPLPD		:= GdFieldPos( "PL_PD"		, aHeaderSPL )	//[02] PD
	nPosSPLHORAS	:= GdFieldPos( "PL_HORAS"	, aHeaderSPL ) 	//[03] Horas
	nPosSPLVALOR	:= GdFieldPos( "PL_VALOR"	, aHeaderSPL ) 	//[04] Valor
	nPosSPLT1   	:= GdFieldPos( "PL_TIPO1"	, aHeaderSPL ) 	//[05] Tipo1 
	nPosSPLDATA		:= GdFieldPos( "PL_DATA"	, aHeaderSPL ) 	//[06] Data 
	nPosSPLT2   	:= GdFieldPos( "PL_TIPO2"	, aHeaderSPL ) 	//[07] Tipo2 			  
	nPosSPLFUNC   	:= GdFieldPos( "PL_CODFUNC"	, aHeaderSPL ) 	//[08] Funcao
	nPosSPLPosto	:= GdFieldPos( "PL_POSTO"	, aHeaderSPL ) 	//[09] Posto
	nPosSPLDepto	:= GdFieldPos( "PL_DEPTO"	, aHeaderSPL ) 	//[10] Depto
	nPosSPLD1		:= GdFieldPos( "PL_D1"		, aHeaderSPL ) 	//[11] PD 1
	nPosSPLD2       := GdFieldPos( "PL_D2"		, aHeaderSPL ) 	//[12] PD 2
	nPosSPLD3       := GdFieldPos( "PL_D3"		, aHeaderSPL ) 	//[13] PD 3
	nPosSPLD4       := GdFieldPos( "PL_D4"		, aHeaderSPL ) 	//[14] PD 4
	nPosSPLD5       := GdFieldPos( "PL_D5"		, aHeaderSPL ) 	//[15] PD 5
	nPosSPLD6       := GdFieldPos( "PL_D6"		, aHeaderSPL ) 	//[16] PD 6
	nPosSPLD7       := GdFieldPos( "PL_D7"		, aHeaderSPL ) 	//[17] PD 7
	nPosSPLProc		:= GdFieldPos( "PL_PROCES"	, aHeaderSPL ) 	//[18] PROCESSO
	nPosSPLRot		:= GdFieldPos( "PL_ROTEIR"	, aHeaderSPL ) 	//[19] ROTEIRO
	nPosSPLPer		:= GdFieldPos( "PL_PERIODO"	, aHeaderSPL ) 	//[20] PERIODO
	nPosSPLNPag		:= GdFieldPos( "PL_SEMANA"	, aHeaderSPL ) 	//[21] NUM PAGTO
	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Cria um Elemento Vazio com Base na Estrutura do GRV					³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	aGRVColEmpty := GdRmkaCols( aHeaderGRV , .F. )
	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Monta Expressao para Avaliar Inicio e Final do Processamento         ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	cInicio		:= ( "RA_FILIAL + RA_MAT" )
	cFim		:= ( cFilAte + cMatAte )     
	
	        	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Executa enquanto atender aos Parametros                       ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	
	While SRA->( !Eof() .and. Eval( bEval , cInicio ) <= cFim )
	        		
	//		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//		³Consiste Intervalo das Perguntas De? Ate?                              ³
	//		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			IF SRA->( Eval( bEval , cExclui ) )
				SRA->( dbSkip() )
				Loop
			EndIF
	
			
	//		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//		³ Aborta o Processamento                            ³
	//		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			IF ( lAbortPrint )
				Exit
			EndIF                                                                
			
			
	//		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//		³Variaveis auxiliares para preencher arrays em logs e comparacoes		³
	//		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			cFilSRA		 := SRA->RA_FILIAL
			cMatSRA		 := SRA->RA_MAT  
			cNomeSRA	 := SRA->RA_NOME  		
			cProcesSRA	 := SRA->RA_PROCES
			If lItemCLVL
				cItemSRA := SRA->RA_ITEM    
				cClvlSRA := SRA->RA_CLVL
			endif

			//		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//		³Zera as sequencias utilizadas por funcionário							³
			//		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ			
			nSeq	:= 1
			aSeqGRV	:= {}
	
	//		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//		³Inicializa afastamento do Funcionario									³
	//		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			aAfast 		:= {}
			
	//		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//		³Carrega o Periodo de Apontamento por Filial                            ³
	//		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			
			IF !( cLastFil == cFilSRA )
			
	//			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//			³Atualiza cLastFil														³
	//			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				cLastFil	:= cFilSRA  
				
	//			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//			³ Obtem o % de Incremento da 2a. BarGauge					   ³
	//			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				nIncPercG1 := SuperGetMv( "MV_PONINC1" , NIL , 5 , cLastFil )
				
	//			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//			³ Obtem o % de Incremento da 2a. BarGauge					   ³
	//			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				nIncPercG2 := SuperGetMv( "MV_PONINCP" , NIL , 5 , cLastFil )

				cFilSRV := fFilFunc("SRV")
				cFilRCM	:= fFilFunc("RCM") 
				cFilSR8	:= fFilFunc("SR8")
	
	//			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//			³ Reinicializa Verbas										   ³
	//			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				IF !( lSRVComp )
					cIncidencias	:= ""
					cAusencias		:= ""
					cHorasExtras	:= ""  
					aVerbas			:= { {} , {}, {} }
				EndIF                                                        
	
				
	//			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//			³ Carrega Informacoes das Verbas 					     	   ³
	//			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				IF Empty( cIncidencias + cAusencias + cHorasExtras )
				

	//				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//				³ Preenche String de Verbas para Integrar com GRV e SR8       ³
	//				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ					
					RCM->( dbSeek( cFilRCM ) ) 
					nIndice	:= 2
					While ( RCM->( !Eof() .and. ( cFilRCM == RCM_FILIAL ) ) )
					    //-- Gera Lista de Verbas de Ausencias
	                    cAusencias+=RCM->RCM_PD+"." 
						cTipoAfa:= RCM->RCM_TIPO
		                //-- Localiza a verba de Ausencias no Cadastro de Verbas  
       					IF SRV->( dbSeek( cFilSRV + RCM->RCM_PD ) )            
       					    //-- Alimenta Array de codigos de verbas a serem integradas
	                    	SRV->(AADD( aVerbas[nIndice] , { RV_COD , RV_LCTODIA == "S", Val(RV_QTDLANC) , RV_CODFOL , cTipoAfa } ))
	                    Endif
	                     
						RCM->(dbSkip())
					End While
					
	//				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//				³ Preenche String de Verbas para Integrar com GRV e SR8       ³
	//				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					SRV->( dbSeek( cFilSRV  ) )
					
					//-- Para alias SRC verifica campo INTEGRA para saber onde alocar a verba
					//-- Para alias RGB assume que todas as verbas que nao sejam Ausencias
					//-- serao alocadas no primeiro (1) elemento do array aVerbas
					nIndice	:= 1
					While ( SRV->( !Eof() .and. ( cFilSRV == RV_FILIAL ) ) ) 
					    //-- Trata verbas que NAO sao AUSENCIAS
	                   	IF Empty( ( nPosVerbas:= Ascan( aVerbas[ 2 ],{ |x| x[ 1 ] == SRV->RV_COD})))  
							//Assume que toda verba eh de incidencia se nao for especificado outro tipo
							If cAlias = 'SRC'
								nIndice	:= If(SRV->RV_HE=='S',3,1)
							Endif
							
							cTipoAfa	:=" "
							If (nIndice == 1)
		                       cIncidencias+=SRV->RV_COD+"."
			                	                    							 
							ELSEIf (nIndice == 3)
							   cHorasExtras+=SRV->RV_COD+"."                      
			                  
		                    Endif
		                     
		                    SRV->(AADD( aVerbas[nIndice] , { RV_COD , RV_LCTODIA == "S", Val(RV_QTDLANC) , RV_CODFOL , cTipoAfa } ))
	                    Endif
	                     
						SRV->(dbSkip())
					End While
		        Endif
	
							
	
	//			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//			³ Atualiza cPerINi                       					   ³
	//			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				cPerIni := Dtos( dPerIni )
				
	//			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//			³ Atualiza a Mensagem para a IncProcG1() ( Turnos )			   ³
	//			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				fInfo( @aInfo , cLastFil )
				cMsgBarG1 := ( STR0016 + " " + cLastFil + " - " + AllTrim( aInfo[3] ) ) ////"Filial:"
				
	//			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//			³ Inicializa Mensagem na 1a BarGauge                           ³
	//			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				IncProcG1( cMsgBarG1 , .F.  )
				
	//			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//			³Incrementa a Barra de Gauge referente a Filial				   ³
	//			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				IncPrcG1Time( cMsgBarG1 , nRecsBarG , cTimeIni , .F. , 1 , nIncPercG1 )
			EndIF
	
			
	//		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//		³ Movimenta a R‚gua de Processamento                           ³
	//		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			IncPrcG2Time( OemToAnsi( STR0020 ) , nLastRec , cTimeIni , .T. , 2 , nIncPercG2 )	//"Integrados:"
	
	
	        
			
	//		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//		³Consiste Filiais e Acessos                                             ³
	//		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			IF SRA->( !( cFilSRA $ fValidFil() ) .or. !Eval( bEval , cAcessaSRA ) )
		      	SRA->( dbSkip() )
		       	Loop
			EndIF
	
			
	//		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//		³Verifica Admissao no Mes                                               ³
	//		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			IF ( !( lAdmMes ) .and. Dtos(fDtaAdmis()) >= cPerIni )
		      	SRA->( dbSkip() )
		       	Loop
			EndIF
			
		    
	//		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//		³Posiciona no funcionario do arquivo SRA Padrao						    ³
	//		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			#IFDEF TOP
				IF ( lSraQryOpened )
					nRecnoSRA := SRA->RECNO
					( cSRALock )->( dbGoto( nRecnoSRA ) ) 	
				EndIF
			#ELSE
				nRecnoSRA := ( cSRALock )->( Recno() )
			#ENDIF
	
			
	//		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//		³ Monta Chave com a Filial + Matricula do Funcionario          ³
	//		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			cChaveFilMat := ( cFilSRA + cMatSRA )
	        
		    
	//		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//		³Bloqueia o Funcionario no SRA verdadeiro e nao na query de alias SRA   ³
	//		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	       	IF !MyLockReg( cSRALock , { nRecnoSRA } , { cChaveFilMat } )
				aAdd( aLog								,;
				 			{					 		 ;
						 		cFilSRA					,; // 01 - Filial
				 				cMatSRA					,; // 02 - Matricula
				 				cNomeSRA				,; // 03 - Nome	
								STR0026					,; // 04 - 'Cadastro do Funcionario (SRA) em Uso por Outro Usuario.'
								0.00					,; // 05 - Reservado CC
								0.00					,; // 06 - Reservado Funcao
								0.00            		,; // 07 - Horas Calc. (Folha)
								0.00            		,; // 08 - Horas Infor.(Folha)
								"LOCK"					,; // 09 - Numero Maximo de Lancamentos para a verba
								0.00 					 ; // 10 - Horas(Ponto)
							};
					)
				
	//			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//			³Desbloqueia Registros e Arquivos										³
	//			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				FreeMyLock()
				
	//			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//			³Procua o Proximo Funcionario    										³
	//			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				SRA->( dbSkip() )
				Loop
			EndIF
	        
	        		
	//		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//		³Reinicializa Variaveis a Cada Funcionario								³
	//		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			aSPLRec  		:= {}
			aColsSPL		:= {} 
			aSPLRecEfe		:= {}

	//		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//		³Ponto de Entrada - PNM40SPL - Atualização da Tabela SPL                ³
	//		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			IF ( lPnm040SplBlock )
				aParamDat := {}
				Aadd(aParamDat, { cFilSRA, cMatSRA, oPeriodo:cProcesso, oPeriodo:cNumPagto, oPeriodo:cRoteiro, dtos(dMvPerIni), dtos(dMvPerFim)})
				ExecBlock("PNM40SPL",.F.,.F.,aParamDat)
			EndIF

	//		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//		³Carrega os Lancamentos de Resultados  do Funcionario				    ³
	//		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			fCarregaSPL("SPL" , cFilSRA, cMatSRA, oPeriodo:cProcesso , oPeriodo:cPeriodo, oPeriodo:cNumPagto, oPeriodo:cRoteiro, aHeaderSPL, @aColsSPL, @aSPLRec)
			 
			
    //		aSort( aColsSPL 	, NIL , NIL , bBlkSortSPL )
	
	//		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//		³Bloqueia Todos os Lancamentos de Resultados do Funcionario		        ³
	//		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			IF !Empty( aSPLRec )
				IF !MyLockReg( "SPL" , aSPLRec , { cChaveFilMat } ) //Funcao Static para tratamento de filial
					aAdd( aLog								,;
					 			{					 		 ;
							 		cFilSRA					,; // 01 - Filial
					 				cMatSRA					,; // 02 - Matricula
					 				cNomeSRA				,; // 03 - Nome	  
					 				STR0028					,; // 04 - 'Lancamentos de Resultados (SPL) em Uso por Outro Usuario.'
									0.00					,; // 05 - Reservado CC
									0.00					,; // 06 - Reservado Funcao 
									0.00            		,; // 07 - Horas Calc. (Folha)
									0.00            		,; // 08 - Horas Infor.(Folha)
									"LOCK"					,; // 09 - Numero Maximo de Lancamentos para a verba
									0.00 					 ; // 10 - Horas(Ponto)
								};
						)               
					
	//				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//				³Desbloqueia Registros e Arquivos										³
	//				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					FreeMyLock()
					
	//				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//				³Interrompe o Processo e Segue para o proximo tratamento ou Procura o Proximo Funcionario ³
	//				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					SRA->(DbSkip())
					Loop
							
				EndIF
		    EndIF
		    
			
	//		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//		³Soma Eventos de Periodos Distintos antes da Integracao					³
	//		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			//A T E N C A O ***********************************************************
			//NAO SE DEVE SOMAR POIS NAO SERA POSSIVEL GERAR DADOS SOBRE A INTEGRACAO
			//(PROCESSO, PERIODO, ETC) NOS REGISTROS DE ORIGEM.
			***************************************************************************
			//aColsSPL:= FSomaSPL(	aColsSPL	) //01 -> Array de Lancamentos do Resultado do Ponto 
			
			//Obtem o Numero de Elementos do aColsSPL 
	        nLenSPLaCols	:= Len(aColsSPL)
		    
		    
			
	//		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//		³Inicializa Arrays Referente ao GRV a Cada Funcionario   	        	³
	//		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	    	aGRVRec 	:= {}
		    aColsGRV	:= {}
	        
			
	//		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//		³Se for Integracao														³
	//		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		    IF ( lIntegra )
				
	//			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//			³Carrega Todos os Itens do GRV do Funcionario           		        ³
	//			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				fCarregaGRV(cAlias,cFilSRA, cMatSRA, oPeriodo:cProcesso, oPeriodo:cPeriodo, oPeriodo:cNumPagto, "PON" , aHeaderGRV, aColsGRV, aGRVRec)
				
				
	//			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//			³Obtem o Numero de Elementos do aColsGRV                    	        ³
	//			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				nLenGRVaCols	:= Len(aColsGRV)																										
				
	//			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//			³Bloqueia Todos os Lancamentos de Verbas  do Funcionario		        ³
	//			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ  
	            
				IF !Empty(aGRVRec) 
					IF !MyLockReg( cAlias , aGRVRec , { cChaveFilMat } ) //Funcao Static para tratamento de filial
						
						aAdd( aLog								,;
						 			{					 		 ;
								 		cFilSRA					,; // 01 - Filial
						 				cMatSRA					,; // 02 - Matricula
						 				cNomeSRA				,; // 03 - Nome	
										STR0027					,; // 04 - 'Lancamentos do Movimento Mensal (GRV) em Uso por Outro Usuario.'				
										0.00					,; // 05 - Reservado CC
										0.00					,; // 06 - Reservado Funcao 
										0.00            		,; // 07 - Horas Calc. (Folha)
										0.00            		,; // 08 - Horas Infor.(Folha)
										"LOCK"					,; // 09 - Numero Maximo de Lancamentos para a verba
										0.00 					 ; // 10 - Horas(Ponto)
									};
							)              
	  					 
	//					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//					³Desbloqueia Registros e Arquivos										³
	//					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						FreeMyLock()
						
	//					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//					³Interrompe o Processo e Segue para o proximo tratamento ou Procura o Proximo Funcionario ³
	//					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						SRA->(DbSkip())
						Loop	
					EndIF
				EndIF
				
			Else                                                                       
				
	//			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//			³Arquivo Temporario Requer apenas a criacao de um array limpo           ³
	//			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				aColsGRV	 := aClone( aGRVColEmpty )
	   			nLenGRVaCols := 1
			EndIF
			
	//		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//		³Verifica se o Funcionario Tem Apontamentos a Serem Integrados          ³
	//		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			
			IF !Empty( aSPLRec )  
				For naColsSPL := 1 To nLenSPLaCols
	
					
	//				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//				³                             *** FIM ATENCAO ***						³
	//				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ  
	
	   				
	//				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//				³Reinicializando Variaveis  											³
	//				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					aItensSPL	:= {}  
					
	//             	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//				³Verifica o Tipo de Verba e carrega as informacoes da mesma				³
	//				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 
	                If cKeyVerba <> aColsSPL[ naColsSPL, nPosSPLPD ]
	                	nIdVerba	:= 0
	                	If aColsSPL[naColsSPL, nPosSPLPD	]  $ cAusencias
	                   		nIdVerba	:= 2
	                   	ElseIF aColsSPL[naColsSPL, nPosSPLPD	]  $ cHorasExtras
	                    		nIdVerba	:= 3
	                   	ElseIF aColsSPL[naColsSPL, nPosSPLPD	]  $ cIncidencias
	  						nIdVerba	:= 1
	                   	Endif               
	                      	
	                   	cKeyVerba := aColsSPL[ naColsSPL, nPosSPLPD ]
	                   	IF !Empty(nIdVerba)
	                   	
		                   	IF Empty( ( nPosVerbas:= Ascan( aVerbas[ nIdVerba ],{ |x| x[ 1 ] == cKeyVerba}))) 
		                   	   //ATENCAO ***********************************************************************
		                   	   // Gera Log de Verba sem classificacao 
		                   	   //********************************************************************************
		                   	   If Empty(Ascan(aSemVerba,{|x| x[1] == cFilSRV .and. x[2] == cKeyVerba}))
			                   	   AADD( aLogSemVerba, cFilSRV + SPACE(9-Len(cFilSRV)) + cKeyVerba + " " + PosSRV( cKeyVerba , cFilSRV , "RV_DESC" ) )
		                   	       AADD( aSemVerba, {cFilSRV, cKeyVerba} )  
		                   	   Endif
		                   	   Loop
		                   	Endif
	                   	Else   
	                   	    //ATENCAO ***********************************************************************
	                   	    // Gera Log de Verba sem classificacao 
	                   	    //********************************************************************************
	                   	    If Empty(Ascan(aSemVerba,{|x| x[1] == cFilSRV .and. x[2] == cKeyVerba}))
		                   	   AADD( aLogSemVerba, cFilSRV + SPACE(9-Len(cFilSRV)) + cKeyVerba + " " + PosSRV( cKeyVerba , cFilSRV , "RV_DESC" ) )
	                   	       AADD( aSemVerba, {cFilSRV, cKeyVerba} )  
	                   	    Endif
	                   	    Loop
	                   	Endif
	                    	
	                    	
	                   	nNumSeq		:= aVerbas[nIdVerba, nPosVerbas, 3 ]
						lLctoDia	:= IF(	aVerbas[nIdVerba, nPosVerbas, 2 ] == NIL,;
					                 	(	aVerbas[ nidverba, nposverbas, 1 ],.T.),;
					                 	aVerbas[nIdVerba, nPosVerbas, 2 ])
					
					
	                Endif
	   				
	//				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//				³Integra Lancamentos SIGAGPE											³
	//				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					IF ( lIntegra )

				        // Se for para integrar somente lancamentos gerados para o processo escolhido do funcionario
				        // informa no log que Processo/Periodo/Semana e Roteiro não foram integrados
						If !__lIntAllP   
							IF aColsSPL[naColsSPL, nPosSPLProc	] <> oPeriodo:cProcesso
								If aScan(aProcesso, {|x|  	( x[1] + x[2] + x[3] + x[4] == aColsSPL[naColsSPL, nPosSPLProc] + aColsSPL[naColsSPL, nPosSPLPer] + aColsSPL[naColsSPL, nPosSPLRot] + aColsSPL[naColsSPL, nPosSPLNPag] );
									 				 	 	   };
				                                     ) = 0
									aAdd(aProcesso , { aColsSPL[naColsSPL, nPosSPLProc] , aColsSPL[naColsSPL, nPosSPLPer] , aColsSPL[naColsSPL, nPosSPLRot] , aColsSPL[naColsSPL, nPosSPLNPag] } )
													   //"Filial   Matr.   Nome                            Processo   Periodo   Roteiro   Num. Pagto."									
									aAdd(aLogProcesso, cFilSRA  + Space(7)	+ ;						   // Filial
										 			   cMatSRA  + Space(2)	+ ;						   // Matricula
									 				   cNomeSRA + Space(2)  + ;      				   // Nome
									 				   aColsSPL[naColsSPL, nPosSPLProc] + Space(6) + ; // Processo
													   aColsSPL[naColsSPL, nPosSPLPer]  + Space(4) + ; // Periodo
  													   aColsSPL[naColsSPL, nPosSPLRot]  + Space(7) + ; // Roteiro
													   aColsSPL[naColsSPL, nPosSPLNPag] ;			   // Num. Pagto.
										)
								EndIf
								Loop
							EndIf
						Endif

						
	//					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//					³Verifica se a Verba e de Ausencia										³
	//					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						IF nIdVerba == 2                                             
						     nPosAfast	:= 0
		                     //R8_FILIAL + R8_MAT+DTOS(R8_DATAINI)+R8_TIPOAFA+STR(R8_DIASEMP)
							 //If SR8->( MSSeek( cFilSRA + cMatSRA + Dtos( aColsSPL[ naColsSPL, nPosSPLDATA ] ) ) )	
	                         //Primeiro procura Ausencia em Array
	                         IF Empty(nPosAfast:= Ascan(aAfast,{|x| (! x[1] > (aColsSPL[ naColsSPL, nPosSPLDATA ])) .and. (!x[2]<  (aColsSPL[ naColsSPL, nPosSPLDATA ]))}))
	                         	 //Se nao encontrou procura em disco e acrescenta em array o afastamento caso exista
	               				 If	fBuscaAfast(cFilSRA, cFilSRA, cMatSRA, aColsSPL[ naColsSPL, nPosSPLDATA ] , @aAfast)
	                             	nPosAfast:=1
	                             Endif
	                         Endif		
	                         		
	                         //Se ja existir uma ausencia adiciona ocorrencia em Log  
	                         IF (nPosAfast > 0)
									//ATENCAO***********************************************************
	                         		//Gerar Log de Ausencia jah registrada
	                         		//******************************************************************
	                                AADD(aLogAusencia, cFilSRA + SPACE(7)+ cMatSRA + space(2)+ cNomeSRA + space(2)+ dtoc( aColsSPL[ naColsSPL, nPosSPLDATA ] ) )
	                         Else                                                                  
	//							ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//							³Gera Registro de Ausencia												³
	//							ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						
		                         Begin Transaction 
			                         RecLock("SR8",.T.,.T.)
									 SR8->R8_FILIAL 	:= cFilSRA
									 SR8->R8_MAT   		:= cMatSRA
									 SR8->R8_DATA   	:= dDataBase   
									 SR8->R8_TIPOAFA	:= aVerbas[2,nPosVerbas,5]
									 SR8->R8_TIPO     	:= "Y"  
									 SR8->R8_PD		 	:= aColsSPL[naColsSPL, nPosSPLPD	]
									 SR8->R8_DATAINI  	:= aColsSPL[ naColsSPL, nPosSPLDATA ]
									 SR8->R8_DURACAO	:= 1
									 SR8->R8_DATAFIM  	:= aColsSPL[ naColsSPL, nPosSPLDATA ]               
									 SR8->R8_CONTINU    := "2"
									 //SR8->R8_VALOR      := 0.00
									 SR8->R8_PER        := cPerRG8
									 //SR8->R8_QTDE       := 0
									 SR8->R8_NUMPAGO    := cNPagRG8
									 //SR8->R8_SDODIAS    := 1
									 If !cPaisLoc == "PAR"
									 	SR8->R8_DNAPLIC    := 0
									 EndIf
									 SR8->R8_DIASEMP    := 999
									 SR8->R8_DPAGAR     := 1
									 SR8->R8_SDPAGAR    := 1
									 SR8->R8_DPAGOS     := 0
									 If (cPaisLoc == "MEX")
										 SR8->R8_CODRPAT    := SRA->RA_CODRPAT
										 SR8->R8_DIASREV    := 0
									 EndIf
									 SR8->R8_PROCES     := cProcRG8
						             SR8->R8_NUMID      := "SR8" + ;
									 						cMatSRA + ;
									 						aColsSPL[naColsSPL, nPosSPLPD	] + ;
									 						STRZERO(YEAR(aColsSPL[ naColsSPL, nPosSPLDATA ]),4) + ;
									 						STRZERO(MONTH(aColsSPL[ naColsSPL, nPosSPLDATA ]),2) + ;
									 						STRZERO(DAY(aColsSPL[ naColsSPL, nPosSPLDATA ]),2)
									 SR8->( MsUnlock() ) 
								
	 //							ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	 //							³Complementar registros de origem (Acum.Resultados) com dados da Integracao	   ³
	 //							ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ							                
									 SPL->( MsGOTO(aColsSPL[naColsSPL,nPosSPLRec]))  
									 RecLock("SPL",.F.,.T.)
									 
									 SPL->PL_PROCES 	:= oPeriodo:cProcesso
									 SPL->PL_PERIODO	:= oPeriodo:cPeriodo
									 SPL->PL_SEMANA 	:= oPeriodo:cNumPagto
									 SPL->PL_ROTEIR 	:= oPeriodo:cRoteiro
									 SPL->PL_INTEGRA    :=  "1" 
									 SPL->(MsUnlock(aColsSPL[naColsSPL,nPosSPLRec]))					 
									 
								 End Transaction   

								 //ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
								 //³ Ponto de Entrada --  para actualizar la SR8
								 //ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
								 IF ( lPnm040Sr8Block )
									aParamDat:= {}   
																				                                                                                                                                                                                    
								    Aadd(aParamDat,{ cFilSRA, cMatSRA,dtos(dDataBase), aColsSPL[naColsSPL, nPosSPLPD],cPerRG8,cNPagRG8, cProcRG8,Dtos(aColsSPL[ naColsSPL, nPosSPLDATA ])  } )
								    ExecBlock("PNM40SR8",.F.,.F.,aParamDat)
								 EndIf
								 
    						     // Houve ausencia
								 Aadd(aSitFun,{ cFilSRA, cMatSRA } )

	                         Endif 
	                         
	                         Loop
						Else                                                                          
	 //						ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	 //						³Tratamento de verbas de Incidencias ou de Tiempo Extra (Horas Extras). ³
	 //						ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
							
							
	//						ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//						³Verifica se a Verba Pode Receber Lancamentos no GRV                    ³
	//						ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
							IF lLancaPd
					            
	//							ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//							³SubDivide o Lancamento se a quantidade de horas ultrapassar o limite   ³
	//							³permitido pelo campo destino (Ex.:999.99)  							³
	//							ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					            fDividLanc( aColsSPL[naColsSPL], nLimHoras, nLimValor, @aItensSPL)
						    	
	//							ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//							³Verifica se a quantidade de lancamentos desdobrados supera a qtde de se	  ³ 
	//							³quencias permitidas (somente para verbas que nao possuem lancamentos diarios ³
	//							ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
								nLenaItens	:= Len(aItensSPL)
							    IF ( nLenaItens > nNumSeq ) .and. !lLctoDia
							    	
	//								ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//								³Emite Log com os lancamentos a serem integrados que irao superar o     ³ 
	//								³de sequencias permitidas pela verba. 								    ³
	//								ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
									aAdd( aLog												,;
									 			{					 						 ;
											 		cFilSRA									,; // 01 - Filial
									 				cMatSRA									,; // 02 - Matricula
									 				cNomeSRA								,; // 03 - Nome	
													aColsSPL[naColsSPL, nPosSPLPD		]	,; // 04 - Verba
													aColsSPL[naColsSPL, nPosSPLCC		]	,; // 05 - Centro de Custo
													aColsSPL[naColsSPL, nPosSPLFUNC		]	,; // 06 - Funcao
													0.00            						,; // 07 - Horas Calc. (Folha)
													0.00            						,; // 08 - Horas Infor.(Folha)
													"MAXLANC"								,; // 09 - Numero Maximo de Lancamentos para a verba
													aColsSPL[naColsSPL, nPosSPLHORAS	]	 ; // 10 - Horas(Ponto)
												};
										)  
									
	//								ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//								³Informacoes sobre Verba vs Lancamento									³
	//								ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
									aAdd( aLog 			 									,;
							 					{				 							; 	
					 								cFilSRA									,; // 01 - Filial
									 				cMatSRA									,; // 02 - Matricula
									 				cNomeSRA								,; // 03 - Nome	
													aColsSPL[naColsSPL, nPosSPLPD		]	,; // 04 - Verba
													aColsSPL[naColsSPL, nPosSPLCC		]	,; // 05 - Centro de Custo
													aColsSPL[naColsSPL, nPosSPLFUNC		]	,; // 06 - Funcao
									 				0.00									,; // 07 - Horas Calc. (Folha)
									 				0.00									,; // 08 - Horas Infor.(Folha)
									 				"QTDEREQ"								,; // 09 - Identificador de Qtde de Lancamentos Requerida pela Verba
								 					0.00									,; // 10 - Horas(Ponto)
								 					nNumSeq 								,; // 11 - Qtde Lactos Verba
								 					nLenaItens	 							; // 12 -  Qtde Lactos Exigida						
												};  
										)	
									Loop
								EndIF
						    	
						    	
	//							ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//							³Procura pelos Movimentos Mensais  do arquivo SPL				  						 	  ³ 		
	//							ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
								IF cKeyGRV <>  (	aColsSPL[ naColsSPL , nPosSPLPD   ] + ;
													aColsSPL[ naColsSPL , nPosSPLCC   ] + ;
													aColsSPL[ naColsSPL , nPosSPLFUNC ] + ;
													aColsSPL[ naColsSPL , nPosSPLPosto] + ;
													aColsSPL[ naColsSPL , nPosSPLDepto] + ;
													aColsSPL[ naColsSPL , nPosSPLProc ] + ;
													aColsSPL[ naColsSPL , nPosSPLRot  ] + ;
													aColsSPL[ naColsSPL , nPosSPLPer  ] + ;
													aColsSPL[ naColsSPL , nPosSPLNPag ] + ;
													DtoS(aColsSPL[ naColsSPL , nPosSPLDATA ])   ;
												)
												
									If ( aColsSPL[ naColsSPL , nPosSPLPD   ] <> cPDAnt   .or. ;
									     aColsSPL[ naColsSPL , nPosSPLProc ] <> cProcAnt .or. ;
									     aColsSPL[ naColsSPL , nPosSPLPer  ] <> cPerAnt  .or. ;
									     aColsSPL[ naColsSPL , nPosSPLNPag ] <> cNPagAnt      ;
									   )
										aRecnoGRV	:= {}
										aSeqGRV		:= {}
										nSeq        := 1
										lObtemRecDel:=.T.
										cPDAnt		:= aColsSPL[ naColsSPL , nPosSPLPD   ]
										cProcAnt	:= aColsSPL[ naColsSPL , nPosSPLProc ]
										cPerAnt		:= aColsSPL[ naColsSPL , nPosSPLPer  ]
										cNPagAnt	:= aColsSPL[ naColsSPL , nPosSPLNPag ]
									EndIf
									
	//								ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//								³Inicializa Contador                                                    ³
	//								ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
									nCountGRV	:= 0.00
									
									If ( nPosGRVFunc > 0 )
									
										cKeyGRV :=  (	aColsSPL[ naColsSPL , nPosSPLPD   ] + ;
														aColsSPL[ naColsSPL , nPosSPLCC   ] + ;
														aColsSPL[ naColsSPL , nPosSPLFUNC ] + ;
														aColsSPL[ naColsSPL , nPosSPLPosto] + ;
														aColsSPL[ naColsSPL , nPosSPLDepto] + ;
														aColsSPL[ naColsSPL , nPosSPLProc ] + ;
														aColsSPL[ naColsSPL , nPosSPLRot  ] + ;
														aColsSPL[ naColsSPL , nPosSPLPer  ] + ;
														aColsSPL[ naColsSPL , nPosSPLNPag ] + ;
														DtoS(aColsSPL[ naColsSPL , nPosSPLDATA ])   ;
													)
									Else

										cKeyGRV :=  (	aColsSPL[ naColsSPL , nPosSPLPD   ] + ;
														aColsSPL[ naColsSPL , nPosSPLCC   ] + ;
														aColsSPL[ naColsSPL , nPosSPLPosto] + ;
														aColsSPL[ naColsSPL , nPosSPLDepto] + ;
														aColsSPL[ naColsSPL , nPosSPLProc ] + ;
														aColsSPL[ naColsSPL , nPosSPLRot  ] + ;
														aColsSPL[ naColsSPL , nPosSPLPer  ] + ;
														aColsSPL[ naColsSPL , nPosSPLNPag ] + ;
														DtoS(aColsSPL[ naColsSPL , nPosSPLDATA ])   ;
													)
									
									EndIf
								    lPrimVez	:= .T.
								Endif 
								
								If ( nPosGRVFunc > 0 )
								
									nPosGRV := aScan(aColsGRV, {|x|  	( x[ nPosGRVPD     ] + x[ nPosGRVCC     ] + ;
																		  x[ nPosGRVFUNC   ] + x[ nPosGRVPosto  ] + ;
																		  x[ nPosGRVDepto  ] + x[ nPosGRVPROCES ] + ;
																		  x[ nPosGRVROTEIRO] + x[ nPosGRVPERIODO] + ;
																		  x[ nPosGRVSEMANA ] + DtoS(x[ nPosGRVDATAREF]) ;
																		) == cKeyGRV ;
										 				 	 	   };		
					                                     )
					             Else

									nPosGRV := aScan(aColsGRV, {|x|  	( x[ nPosGRVPD     ] + x[ nPosGRVCC     ] + ;
																		  x[ nPosGRVPosto  ] + ;
																		  x[ nPosGRVDepto  ] + x[ nPosGRVPROCES ] + ;
																		  x[ nPosGRVROTEIRO] + x[ nPosGRVPERIODO] + ;
																		  x[ nPosGRVSEMANA ] + DtoS(x[ nPosGRVDATAREF]) ;
																		) == cKeyGRV ;
										 				 	 	   };		
					                                     )					             
					             
					             EndIf

									If lPrimvez .AND. !Empty( nPosGRV )
		//								ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//								³ATENCAO: 													  ³
		//								³Nao devemos ordenar o array de modo que teremos que  corre-lo³
		//								³todo														  ³
		//								ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
										For naColsGRV := nPosGRV To nLenGRVaCols
											
		//									ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//									³So Grava no GRV as Verbas que Podem Receber Lancamentos                ³
		//									ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			
											IF (	aColsGRV[ naColsGRV , nPosGRVPD     ] == aColsSPL[naColsSPL, nPosSPLPD	  ] .and. ;	//01 - Verba
				                    				aColsGRV[ naColsGRV , nPosGRVCC     ] == aColsSPL[naColsSPL, nPosSPLCC	  ] .and. ;	//02 - Centro de Custo
				                    				If ( (nPosGRVFUNC > 0) ,aColsGRV[ naColsGRV , nPosGRVFUNC   ] == aColsSPL[naColsSPL, nPosSPLFUNC ], .T. )  .and. ;	//03 - Funcao
				                    				aColsGRV[ naColsGRV , nPosGRVPOSTO  ] == aColsSPL[naColsSPL, nPosSPLPosto] .and. ;	//04 - Posto
				                    				aColsGRV[ naColsGRV , nPosGRVDEPTO  ] == aColsSPL[naColsSPL, nPosSPLDepto] .and. ;	//05 - Depto
				                    				aColsGRV[ naColsGRV , nPosGRVPROCES ] == aColsSPL[naColsSPL, nPosSPLProc ] .and. ;	//06 - Processo
				                    				aColsGRV[ naColsGRV , nPosGRVPERIODO] == aColsSPL[naColsSPL, nPosSPLPer  ] .and. ;	//07 - Periodo
				                    				aColsGRV[ naColsGRV , nPosGRVROTEIRO] == aColsSPL[naColsSPL, nPosSPLRot  ] .and. ;	//08 - Roteiro
				                    				aColsGRV[ naColsGRV , nPosGRVSEMANA ] == aColsSPL[naColsSPL, nPosSPLNPag ] .and. ;	//09 - Numero de Pagamento
				                    				DtoS(aColsGRV[ naColsGRV , nPosGRVDATAREF]) == DtoS(aColsSPL[naColsSPL, nPosSPLDATA ]) ;	//05 - Data de Referencia
				                                 )
												
		//										ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//										³Verifica Quantas Vezes ja Existe a Verba para verificar se nao estourou³
		//										³o Numero Maximo de Sequencias Permitidas para a Verba					³
		//										ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
												++nCountGRV
												
		//										ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//										³Verifica Apenas as Verbas que foram Geradas Pelo Ponto: RC_TIPO2 == "E"³
		//										ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
												IF ( aColsGRV[naColsGRV, nPosGRVT2   ] == "E" )
													IF !( lSobrepoe )
														aAdd( aLog												,;
												 					{					 		 				 ; 	
												 						cFilSRA									,; // 01 - Filial
												 						cMatSRA									,; // 02 - Matricula
												 						cNomeSRA								,; // 03 - Nome	
													 					aColsGRV[naColsGRV, nPosGRVPD		]	,; // 04 - Verba
														 				aColsGRV[naColsGRV, nPosGRVCC		]	,; // 05 - Centro de Custo
														 				If ( (nPosGRVFUNC > 0), aColsGRV[naColsGRV, nPosGRVFUNC		],"" ) ,; // 06 - Funcao
														 				aColsGRV[naColsGRV, nPosGRVHCALC	]	,; // 07 - Horas Calc. (Folha)
														 				aColsGRV[naColsGRV, nPosGRVHINFO	]	,; // 08 - Horas Infor.(Folha)
														 				aColsGRV[naColsGRV, nPosGRVT2   	]	,; // 09 - Tipo (G,I,E...)
													 					aColsSPL[naColsSPL, nPosSPLHORAS	]	 ; // 10 - Horas(Ponto)
																	};
															)
													EndIF
													
		//											ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//											³Armazena os registros referentes ao Ponto Eletronico					³
		//											³Adiciona o No.Reg (0.00 se nao existir), a Sequencia e a linha do array³
		//											³principal																³
		//											ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
													aAdd( aRecnoGRV, { aGRVRec[naColsGRV], naColsGRV, .F., aColsGRV[ naColsGRV , nPosGRVSEQ	] } )
												   
												EndIF
												
		//										ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//										³Armazena as Sequencias das Verbas independente da origem para posterior³
		//										³reutilizacao de "janelas" entre as sequencias.							³
		//										³Salvamos o no.registro(0.00 se nao existir fisicamente), a  sequencia e³
		//										³o flag																    ³
		//										ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
												aAdd( aSeqGRV ,{ aColsGRV[ naColsGRV , nPosGRVSEQ	], aColsGRV[ naColsGRV , nPosGRVT2 ], naColsGRV } )
												
											EndIF
										Next naColsGRV
		//		                        ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//								³Calcula o numero total de lancamentos para mesma verba com os novos    ³
		//								³lancamentos.															³
		//								ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ								                           
										//-- Obtem o numero de sequencias do lancamento do ponto para a verba
										nLenaRecGRV := Len(aRecnoGRV)	
										aSort( aSeqGRV 	, NIL , NIL , { |x,y| x[1] < y[1] } )                        
			                        Endif
									
									lPrimVez	:= .F.
									
	//								ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//								³ Acrescenta as novas sequencias ao total existente 					³
	//								ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
									IF ( lSobrepoe )                  
										
	//									ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//									³Se sobrepoe, subtrai os lancamentos anteriores e acrescenta os novos	³
	//									ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
										nCountGRV := ( ( nCountGRV - nLenaRecGRV) + nLenaItens )
									Else
										
	//									ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//									³Se nao sobrepoe, acrescenta os novos lancamentos						³
	//									ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
										nCountGRV += nLenaItens
									EndIF
			
									IF ( nLenaRecGRV > 0.00 )   
										
	//									ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//									³Grava apenas se Estiver dentro da Quantidade Maxima de Lancamentos  per³
	//									³mitidos para a Verba (somente para verbas com controle de lancamentos)	³
	//									ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
										IF ( lSobrepoe )  .and. (  !( nCountGRV > nNumSeq ) .or. lLctoDia  ) 
											fMontaGRV( @aColsGRV , aItensSPL , aRecnoGRV , aSeqGRV , aGRVColEmpty, lLctoDia, @aGRVRecDel, @nSeq ,@lObtemRecDel )
										Else                                             
										   	
	//										ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//										³Emite Log com o numero de sequencias que extrapola o limite de lancamen³ 
	//										³tos permitidos a verba. 								    			³
	//										ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
											IF ( nSeq > nNumSeq)
													
	//												ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//												³Emite Log com os lancamentos a serem integrados que irao superar o     ³ 
	//												³de sequencias permitidas pela verba. 								    ³
	//												ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
													aAdd( aLog										,;
											 			{					 						 ;
													 		cFilSRA									,; // 01 - Filial
											 				cMatSRA									,; // 02 - Matricula
											 				cNomeSRA								,; // 03 - Nome	
															aColsSPL[naColsSPL, nPosSPLPD		]	,; // 04 - Verba
															aColsSPL[naColsSPL, nPosSPLCC		]	,; // 05 - Centro de Custo
															aColsSPL[naColsSPL, nPosSPLFUNC		]	,; // 06 - Funcao
															0.00            						,; // 07 - Horas Calc. (Folha)
															0.00            						,; // 08 - Horas Infor.(Folha)
															"MAXLANC"								,; // 09 - Numero Maximo de Lancamentos para a verba
															aColsSPL[naColsSPL, nPosSPLHORAS	]	 ; // 10 - Horas(Ponto)
														};
													)	
													
	//												ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//												³Informacoes sobre Verba vs Lancamento									³
	//												ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
													aAdd( aLog 											,;
									 					{				 								; 	
										 						cFilSRA									,; // 01 - Filial
												 				cMatSRA									,; // 02 - Matricula
												 				cNomeSRA								,; // 03 - Nome	
																aColsSPL[naColsSPL, nPosSPLPD		]	,; // 04 - Verba
																aColsSPL[naColsSPL, nPosSPLCC		]	,; // 05 - Centro de Custo
																aColsSPL[naColsSPL, nPosSPLFUNC		]	,; // 06 - Funcao
																0.00            						,; // 07 - Horas Calc. (Folha)
																0.00            						,; // 08 - Horas Infor.(Folha)
											 					"QTDEREQ"								,; // 09 - Identificador de Qtde de Lancamentos Requerida pela Verba
										 						0.00									,; // 10 - Horas(Ponto)
										 						nNumSeq 								,; // 11 - Qtde Lactos Verba
										 						nCountGRV	 							; // 12 - Qtde Lactos Exigida						
														};
													)
											EndIF
										EndIF	
									ElseIF ( nSeq <= nNumSeq ) .Or. lLctoDia
											fMontaGRV( @aColsGRV , aItensSPL , NIL , aSeqGRV , aGRVColEmpty, lLctoDia, @aGRVRecDel, @nSeq,@lObtemRecDel )
									ElseIF ( nSeq > nNumSeq )
											
	//										ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//										³Carrega no aLog Informacao correspondente ao Extrapolamento no   numero³
	//										³de Lancamentos Permitidos para a verba									³
	//										ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
										    aAdd( aLog												,;
											 			{					 						 ;
													 		cFilSRA									,; // 01 - Filial
									 						cMatSRA									,; // 02 - Matricula
									 						cNomeSRA								,; // 03 - Nome	
															aColsSPL[naColsSPL, nPosSPLPD		]	,; // 04 - Verba
															aColsSPL[naColsSPL, nPosSPLCC		]	,; // 05 - Centro de Custo
															aColsSPL[naColsSPL, nPosSPLFUNC		]	,; // 06 - Funcao          
															0.00            						,; // 07 - Horas Calc. (Folha)
															0.00            						,; // 08 - Horas Infor.(Folha)
															"MAXLANC"								,; // 09 - Numero Maximo de Lancamentos para a verba
															aColsSPL[naColsSPL, nPosSPLHORAS	]	 ; // 10 - Horas(Ponto)
														};
												)	
											
	//										ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//										³Informacoes sobre Verba vs Lancamento									³
	//										ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
											aAdd( aLog 					,;
									 					{				 ; 	
								 							cFilSRA									,; // 01 - Filial
									 						cMatSRA									,; // 02 - Matricula
									 						cNomeSRA								,; // 03 - Nome	
															aColsSPL[naColsSPL, nPosSPLPD		]	,; // 04 - Verba
															aColsSPL[naColsSPL, nPosSPLCC		]	,; // 05 - Centro de Custo
															aColsSPL[naColsSPL, nPosSPLFUNC		]	,; // 06 - Funcao          
															0.00            						,; // 07 - Horas Calc. (Folha)
															0.00            						,; // 08 - Horas Infor.(Folha)
											 				"QTDEREQ"								,; // 09 - Identificador de Qtde de Lancamentos Requerida pela Verba
										 					0.00									,; // 10 - Horas(Ponto)
										 					nNumSeq 								,; // 11 - Qtde Lactos Verba
										 					nCountGRV	 							; // 12 -  Qtde Lactos Exigida						
														} ;
												)		
									EndIF	
							Else
								
	//							ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//							³Carrega no aLog Informacao de que a verba nao Permite Lancamento       ³
	//							ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
								 aAdd( aLog												,;
								 			{					 						 ;
										 		cFilSRA									,; // 01 - Filial
						 						cMatSRA									,; // 02 - Matricula
						 						cNomeSRA								,; // 03 - Nome	
												aColsSPL[naColsSPL, nPosSPLPD		]	,; // 04 - Verba
												aColsSPL[naColsSPL, nPosSPLCC		]	,; // 05 - Centro de Custo
												aColsSPL[naColsSPL, nPosSPLFUNC		]	,; // 06 - Funcao         
												0.00            						,; // 07 - Horas Calc. (Folha)
												0.00            						,; // 08 - Horas Infor.(Folha)
												"NOLANC"								,; // 09 - Nao eh permitido lancamentos para a verba
												aColsSPL[naColsSPL, nPosSPLHORAS	]	 ; // 10 - Horas(Ponto)
											};
									)		
							EndIF
					    Endif
					Else 
						
	//					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//					³EXPORTA Lancamentos													³
	//					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						
	//					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//					³SubDivide o Lancamento se a quantidade de horas ultrapassar o limite   ³
	//					³permitido pelo campo destino (Ex.:999.99)  							³
	//					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						fDividLanc( aColsSPL[naColsSPL], nLimHoras, nLimValor, @aItensSPL)
					
	                	
	//					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//					³Procura pelos Movimentos Mensais  do arquivo SPL				  						 	  ³ 		
	//					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						IF cKeyGRV <>  (	aColsSPL[ naColsSPL , nPosSPLPD   ] + ;
											aColsSPL[ naColsSPL , nPosSPLCC   ] + ;
											aColsSPL[ naColsSPL , nPosSPLFUNC ] + ;
											aColsSPL[ naColsSPL , nPosSPLPosto] + ;
											aColsSPL[ naColsSPL , nPosSPLDepto] + ;
											aColsSPL[ naColsSPL , nPosSPLProc ] + ;
											aColsSPL[ naColsSPL , nPosSPLRot  ] + ;
											aColsSPL[ naColsSPL , nPosSPLPer  ] + ;
											aColsSPL[ naColsSPL , nPosSPLNPag ] + ;
											DtoS(aColsSPL[ naColsSPL , nPosSPLDATA ])   ;
										)

								If ( aColsSPL[ naColsSPL , nPosSPLPD   ] <> cPDAnt   .or. ;
								     aColsSPL[ naColsSPL , nPosSPLProc ] <> cProcAnt .or. ;
								     aColsSPL[ naColsSPL , nPosSPLPer  ] <> cPerAnt  .or. ;
								     aColsSPL[ naColsSPL , nPosSPLNPag ] <> cNPagAnt      ;
								   )
									aRecnoGRV	:= {}
									aSeqGRV		:= {}
									nSeq        := 1
									lObtemRecDel:=.T.
									cPDAnt		:= aColsSPL[ naColsSPL , nPosSPLPD   ]
									cProcAnt	:= aColsSPL[ naColsSPL , nPosSPLProc ]
									cPerAnt		:= aColsSPL[ naColsSPL , nPosSPLPer  ]
									cNPagAnt	:= aColsSPL[ naColsSPL , nPosSPLNPag ]
								EndIf
								
								If ( nPosGRVFUNC > 0 )

									cKeyGRV :=  (	aColsSPL[ naColsSPL , nPosSPLPD   ] + ;
													aColsSPL[ naColsSPL , nPosSPLCC   ] + ;
													aColsSPL[ naColsSPL , nPosSPLFUNC ] + ;
													aColsSPL[ naColsSPL , nPosSPLPosto] + ;
													aColsSPL[ naColsSPL , nPosSPLDepto] + ;
													aColsSPL[ naColsSPL , nPosSPLProc ] + ;
													aColsSPL[ naColsSPL , nPosSPLRot  ] + ;
													aColsSPL[ naColsSPL , nPosSPLPer  ] + ;
													aColsSPL[ naColsSPL , nPosSPLNPag ] + ;
													DtoS(aColsSPL[ naColsSPL , nPosSPLDATA ])   ;
												)
												
								Else

									cKeyGRV :=  (	aColsSPL[ naColsSPL , nPosSPLPD   ] + ;
													aColsSPL[ naColsSPL , nPosSPLCC   ] + ;
													aColsSPL[ naColsSPL , nPosSPLPosto] + ;
													aColsSPL[ naColsSPL , nPosSPLDepto] + ;
													aColsSPL[ naColsSPL , nPosSPLProc ] + ;
													aColsSPL[ naColsSPL , nPosSPLRot  ] + ;
													aColsSPL[ naColsSPL , nPosSPLPer  ] + ;
													aColsSPL[ naColsSPL , nPosSPLNPag ] + ;
													DtoS(aColsSPL[ naColsSPL , nPosSPLDATA ])   ;
												)								
								
								EndIf
												
							    lPrimVez	:= .T.
						Endif
						
						If ( nPosGRVFUNC > 0 )
				               
							nPosGRV := aScan(aColsGRV, {|x|  	( x[ nPosGRVPD     ] + x[ nPosGRVCC     ] + ;
																  x[ nPosGRVFUNC   ] + x[ nPosGRVPosto  ] + ;
																  x[ nPosGRVDepto  ] + x[ nPosGRVPROCES ] + ;
																  x[ nPosGRVROTEIRO] + x[ nPosGRVPERIODO] + ;
																  x[ nPosGRVSEMANA ] + DtoS(x[ nPosGRVDATAREF]) ;
																) == cKeyGRV ;
								 				 	 	   };		
			                                     )
		                 Else
		                 
							nPosGRV := aScan(aColsGRV, {|x|  	( x[ nPosGRVPD     ] + x[ nPosGRVCC     ] + ;
																  x[ nPosGRVPosto  ] + ;
																  x[ nPosGRVDepto  ] + x[ nPosGRVPROCES ] + ;
																  x[ nPosGRVROTEIRO] + x[ nPosGRVPERIODO] + ;
																  x[ nPosGRVSEMANA ] + DtoS(x[ nPosGRVDATAREF]) ;
																) == cKeyGRV ;
								 				 	 	   };		
			                                     )		                 
		                 
		                 EndIf

						If lPrimvez .AND. !Empty( nPosGRV )
		//						ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//						³Grava no Arquivo Temporario que Sera Utilizado Para Exportacao         ³
		//						ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
								For naColsGRV := nPosGRV To nLenGRVaCols 
									
		//							ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//							³ATENCAO: 													  ³
		//							³Nao devemos ordenar o array de modo que teremos que  corre-lo³
		//							³todo														  ³
		//							ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
									IF (	aColsGRV[ naColsGRV , nPosGRVPD     ] == aColsSPL[naColsSPL, nPosSPLPD	  ] .and. ;	//01 - Verba
		                    				aColsGRV[ naColsGRV , nPosGRVCC     ] == aColsSPL[naColsSPL, nPosSPLCC	  ] .and. ;	//02 - Centro de Custo
		                    				If ( ( nPosGRVFUNC > 0 ),aColsGRV[ naColsGRV , nPosGRVFUNC   ] == aColsSPL[naColsSPL, nPosSPLFUNC ], .T. ) .and. ;	//03 - Funcao
		                    				aColsGRV[ naColsGRV , nPosGRVPOSTO  ] == aColsSPL[naColsSPL, nPosSPLPosto] .and. ;	//04 - Posto
		                    				aColsGRV[ naColsGRV , nPosGRVDEPTO  ] == aColsSPL[naColsSPL, nPosSPLDepto] .and. ;	//05 - Depto
		                    				aColsGRV[ naColsGRV , nPosGRVPROCES ] == aColsSPL[naColsSPL, nPosSPLProc ] .and. ;	//06 - Processo
		                    				aColsGRV[ naColsGRV , nPosGRVPERIODO] == aColsSPL[naColsSPL, nPosSPLPer  ] .and. ;	//07 - Periodo
		                    				aColsGRV[ naColsGRV , nPosGRVROTEIRO] == aColsSPL[naColsSPL, nPosSPLRot  ] .and. ;	//08 - Roteiro
		                    				aColsGRV[ naColsGRV , nPosGRVSEMANA ] == aColsSPL[naColsSPL, nPosSPLNPag ] .and. ;	//09 - Numero de Pagamento
		                    				DtoS(aColsGRV[ naColsGRV , nPosGRVDATAREF]) == DtoS(aColsSPL[naColsSPL, nPosSPLDATA ]) 	  ;	//05 - Data de Referencia
		                                 )

		//								ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//								³Adiciona o No.Reg(0.00 se nao existir), a Sequencia e a linha³
		//								³do array principal											  ³
		//								ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
										aAdd( aRecnoGRV , { aGRVRec[ naColsGRV ], naColsGRV, .F., aColsGRV[ naColsGRV , nPosGRVSEQ	]} )
									EndIF
								Next naColsGRV
							Endif
							lPrimVez	:= .F.
	//						ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//						³ Atualiza o array de movimentos mensais e de nrs.de registro ³
	//						ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
							fMontaGRV( @aColsGRV , aItensSPL , aRecnoGRV , aSeqGRV , aGRVColEmpty, lLctoDia, @aGRVRecDel, @nSeq ,@lObtemRecDel )
					EndIF
				Next naColsSPL
			Else                                         
			    //ATENCAO******************************************
				//Gerar Log de Funcionario sem lancamento          
				//*************************************************
				AADD(aLogSemLcto	, cFilSRA + SPACE(7) + cMatSRA + SPACE(2) +  cNomeSRA )
	
			EndIF
		
		
	//		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//		³Verifica as Integracoes Feitas no SIGAGPE ( GRV )                      ³
	//		³ELIMINA Verbas Anteriores na Ausencia de Resultados a Integrar         ³
	//		³GRAVA   Resultados integrados										    ³
	//		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			IF !Empty(aSPLRecEfe) 
				fGravaGRV( cAlias , cFilSRA , cMatSRA , aHeaderGRV , aColsGRV , aColsSPL , aGRVRecDel, lIntegra, lSobrepoe, cItemSRA, cCLVLSRA )
	        EndIF

			//ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Ponto de Entrada -- Utilizado para actualizar las horas en la SRF
			//ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			IF !Empty(aSPLRecEfe)
				If lPnm040SrfBlock
			 		private nTotCon:=   len(aColsSPL)
					ExecBlock("PNM40SRF",.F.,.F.,aColsSPL)
				EndIf
        	EndIF 
	       
	//		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//		³ Desbloqueia Registros e Arquivos							  ³
	//		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			FreeMyLock()
	
	//		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//		³ Proximo Funcionario              							  ³
	//		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			SRA->( dbSkip() )
        
	End While
End Sequence

  
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Garante que todos os Registros Estarao Desbloqueados        ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
FreeMyLock()

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Fecha a Query do SRA e Restaura o Padrao                    ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
#IFDEF TOP
	IF ( lSraQryOpened )
		SRA->( dbCloseArea() )
		( cSRALock )->( dbCloseArea() )
		ChkFile( "SRA" )
	EndIF	
#ENDIF
	
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Atualiza o Cadastro de Funcionario "SRA" 					          ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If Len(aSitFun) > 0 
	SRA->( dbSetOrder( RetOrdem("SRA") ) )
	For nX := 1 To Len(aSitFun)
		If SRA->( dbSeek( aSitFun[nX,1] + aSitFun[nX,2] ) )
			RetSituacao( aSitFun[nX,1] , aSitFun[nX,2] , .T. )
		EndIf
	Next
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Gerar o TXT utilizado na Exportacao dos Dados                          ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
IF !( lIntegra )
	IF !Empty( Select( "PONM040TMP" ) )
		dbSelectArea( "PONM040TMP" )
		COPY TO &(cNomeArq) SDF
	    PONM040TMP->( dbCloseArea() )
	    fErase( cArqDbf + GetDBExtension() )
	    fErase( cArqInd + OrdBagExt() )
	EndIF
EndIF


//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Mostrar o Log de Ocorrencias                                           ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
IF !Empty( aLog ) .or. !Empty( aLogPer ) .or. (Len( aLogSemVerba ) > 1) .or. (Len( aLogAusencia ) > 1) .or. (Len( aLogSemLcto ) > 1) .or. (Len( aLogProcesso ) > 1)
	IF MsgYesNo( OemToAnsi( STR0005 ) , OemToAnsi( STR0006 ) ) //"Foram encontradas Inconsistencias na Integra‡„o. Deseja Gerar o Log?"###"Aten‡„o"	
		GeraLog( aLog , cPerg , aLogPer, aLogSemVerba, aLogAusencia, aLogSemLcto, aLogProcesso )
	EndIF
EndIF

If nPosRegRCH > 0 
	RCH->(dbgoto(nPosRegRCH))
	Reclock("RCH",.F.)
	RCH->RCH_DTINTE := dDatabase
	RCH->(MSUNLOCK())
EndIf	

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Restaura os Dados de Entrada dos Arquivos Utilizados no Processamento ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
( RestArea( aAreaSPL ) , RestArea( aAreaSRA ) , RestArea( aAreaGRV ) )

If FindFunction("SPFilterOff")						//   Alteracao referente ao projeto: SuperFiltro
   SPFilterOff( { "SRA","SRC","RGB","RCH" },.F. )  //   Habilita filtro no alias - SRA, SRC, RGB, RCH.
EndIf
  
Return( NIL )  


/*
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³fMontaGRV ³ Autor ³ MauricioMR 		      ³ Data ³05/05/2003³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Gerencia a Montagem em Memoria do aCols de Lancamentos      ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Uso      ³ PONM040                                                    ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ */
Static Function fMontaGRV( aColsGRV , aItensSPL , aRecnoGRV , aSeqGRV , aGRVColEmpty, lLctoDia, aGRVRecDel, nSeq ,lObtemRecDel )

Local nI			:=		0.00
Local naItensSPL	:=		0.00
Local nNewRecno		:=  	0.00
Local dDataRef   
Local lGrava		:= .T.
Local xSeq			:= ""

DEFAULT aRecnoGRV	:= {}
DEFAULT aSeqGRV		:= {}

naItensSPL 	:= Len( aItensSPL )

//Sem um lancamento da verba pode ser integrado
//Entao considera que todos os lancamentos no GRV referente
//a verba e que sao gerados pelo Ponto deverao ser eliminados 
//antes da gravacao para evitar chave duplicada.
If lObtemRecDel
	//Obtem  registros que deverao ser deletados
	Aeval( aRecnoGRV , { |x| AADD( aGRVRecDel, x[1] ), aColsGRV[ x[2], nPosGRVDeleted ]:= .T. } )
	lObtemRecDel	:= .F.
Endif

//Obtem registro fisico do SPL que foi considerado para a gravacao
//Para registrar no Ponto as informacoes de Processo, periodo, semana,etc da Folha
AADD(aSPLRecEfe, aItensSPL[ 1, Len( aItensSPL[1] ) - 1 ] )

//Lancamentos diarios  preservam a data de geracao
If lLctoDia
	dDataRef	:= aItensSPL[1,nPosSPLDATA	]
Else                                              
	//Lancamentos Nao diarios Possuem uma data Fixa
	dDataRef	:= oPeriodo:dDataFim  
Endif                   

//-- Corre Todos os Lancamentos desdobrados de um lancamento do SPL para 
//-- realizar a gravacao
For nI :=1.00 To naItensSPL	
    
    //Cria um novo elemento o GRV para posterior gravacao
	aAdd( aColsGRV, aClone( aGRVColEmpty[1] ) )
 
   	lGrava	:= .T.   
  	
   	//Lancamentos Nao diarios incrementam a Sequencia
//   	If !lLctoDia
   		// Se o incremento de Sequencia nao estourou a quantidade maxima de sequencias permitidas
   		If lGrava := fIncrSeq( aSeqGRV, @nSeq, aRecnoGRV)
   			//-- Adiciona nova sequencia para posterior comparacao
			xSeq	:= StrZero( nSeq ,TamSx3("RC_SEQ")[1] )
		Endif	
//   	Endif
   	
   	If lGrava
	   	//--Obtem o Ultimo Elemento do array
	 	naColsGRV	:= Len( aColsGRV)
	 	//Gera Lancamento
		aColsGRV[naColsGRV, nPosGRVPD		]   := aItensSPL[ nI,	nPosSPLPD		] 	// PD
		aColsGRV[naColsGRV, nPosGRVT1   	]  	:= aItensSPL[ nI,	nPosSPLT1   	] 	// TIPO1
		aColsGRV[naColsGRV, nPosGRVHCALC	] 	:= aItensSPL[ nI,	nPosSPLHORAS	] 	// HORAS CALC.
		aColsGRV[naColsGRV, nPosGRVVCALC	]  	:= aItensSPL[ nI,	nPosSPLVALOR	] 	// VALOR CALC.
		aColsGRV[naColsGRV, nPosGRVDATAREF	]   := dDataRef   		            		// DATA DE REFERENCIA
		aColsGRV[naColsGRV, nPosGRVSEMANA	]   := cNPagRG8								// NUMERO DE PAGTO
		aColsGRV[naColsGRV, nPosGRVCC		]   := aItensSPL[ nI,	nPosSPLCC		] 	// CC
		aColsGRV[naColsGRV, nPosGRVT2   	]  	:= "E"                         			// TIPO2
		aColsGRV[naColsGRV, nPosGRVSEQ		]  	:= xSeq 								// SEQUENCIA									
		aColsGRV[naColsGRV, nPosGRVPROCES	]   := cProcRG8					 	   		// PROCESSO
		aColsGRV[naColsGRV, nPosGRVPERIODO	]   := cPerRG8					 			// PERIODO
		aColsGRV[naColsGRV, nPosGRVROTEIRO	]   := cRotRG8								// ROTEIRO
		If ( nPosGRVFUNC > 0 )
			aColsGRV[naColsGRV, nPosGRVFUNC	    ]  	:= aItensSPL[ nI,	nPosSPLFUNC	] 		// FUNCAO
		EndIf
		aColsGRV[naColsGRV, nPosGRVNUMID	]  	:= DTOS(aItensSPL[ nI,	nPosSPLDATA	] ) // NUMERO DE IDENTIFICACAO
		aColsGRV[naColsGRV, nPosGRVPOSTO    ]  	:= aItensSPL[ nI,	nPosSPLPosto	] 	// POSTO
		aColsGRV[naColsGRV, nPosGRVDEPTO	]  	:= aItensSPL[ nI,	nPosSPLDepto	]   // DEPTO
		If !Empty(nPosGRVHINFO)
			aColsGRV[naColsGRV, nPosGRVHINFO	] 	:= aItensSPL[ nI,	nPosSPLHORAS	] 	// HORAS INFOR.
			aColsGRV[naColsGRV, nPosGRVVINFO	]  	:= aItensSPL[ nI,	nPosSPLVALOR	] 	// VALOR INFOR.
			aColsGRV[naColsGRV, nPosDataGRV	]       := dFecPag								// DATA DE PAGAMENTO
		EndIf		
		If !Empty(nPosGRVD1)
			aColsGRV[naColsGRV, nPosGRVD1	]	:= aItensSPL[ nI, nPosSPLD1	]	//PD 1
			aColsGRV[naColsGRV, nPosGRVD2	]	:= aItensSPL[ nI, nPosSPLD2	]	//PD 2
			aColsGRV[naColsGRV, nPosGRVD3	]	:= aItensSPL[ nI, nPosSPLD3	]	//PD 3
			aColsGRV[naColsGRV, nPosGRVD4	]	:= aItensSPL[ nI, nPosSPLD4	]	//PD 4
			aColsGRV[naColsGRV, nPosGRVD5	]	:= aItensSPL[ nI, nPosSPLD5	]	//PD 5
			aColsGRV[naColsGRV, nPosGRVD6	]	:= aItensSPL[ nI, nPosSPLD6	]	//PD 6
			aColsGRV[naColsGRV, nPosGRVD7	]	:= aItensSPL[ nI, nPosSPLD7	]	//PD 7
		EndIf		
	Endif	
Next nI

Return( NIL )


/*
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³fIncrSeq  ³ Autor ³ MauricioMR            ³ Data ³06/05/2003³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Incrementa a Sequencia "aproveitando janelas" Ex.(1-X-3-X-X)³
³          ³em virutde de delecao de sequencias.                        ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Uso      ³ PONM040                                                    ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ */
Static Function fIncrSeq(aSeqGRV, nSeq, aRecnoGRV)

Local lRet		:= .T.  
Local nSeqOld 
Local nLenSeq	:= Len(aSeqGRV)  
Local nPosSeq	:= 0

DEFAULT aSeqGRV	:= {}

//Verifica a possibilidade de se reutilizar sequencias de lancamentos do Ponto integrados anteriormente
//Se Existirem registros ja integrados
If !Empty(aRecnoGRV)                  
    //Porcura por uma sequencia disponivel
	nPosSeq	:= aScan( aRecnoGRV,{|x| !X[3] } ) 
Endif
//Se existir sequencia disponivel
If !Empty(nPosSeq)
   //Reutilize-a
   nSeq	:=Val(aRecnoGRV[nPosSeq,4]) 
   //E ponha como nao disponivel
   aRecnoGRV[nPosSeq,3]	:= .T. 
Else         
   //Se nao existirem sequencias disponiveis, incrementa contador de sequencias
   nSeq	:=IF( Empty(aSeqGRV), 1, Val(aSeqGRV[Len(aSeqGRV),1]) + 1 )
   If ( nSeq > 9.00 )
	  lRet	:= .F.
   Else
      //-- Adiciona nova sequencia para posterior comparacao
      aAdd(aSeqGRV,{StrZero( nSeq ,TamSx3("RC_SEQ")[1] ),'E',0} )

   Endif
	
Endif
   

Return ( lRet )

 /*
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³fGravaGRV ³ Autor ³ MauricioMR            ³ Data ³13/05/2003³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Grava as Informacoes do acols para o arquivo GRV			³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Uso      ³ PONM040                                                    ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ */

Static Function fGravaGRV( cAlias , cFil , cMat , aHeader , aColsGRV , aColsSPL , aGRVRecDel, lIntegra, lSobrepoe, cItem, cCLVL )

Local aArea			:= GetArea()
Local cSvFilAnt		:= cFilAnt
Local cMsgErr		:= ""
Local nArray		:= 0
Local nForArray 	:= Len(aColsGRV)
Local nForHeader	:= Len(aHeader)
Local nHeader		:= 0      

Begin Transaction

	//Elimina Registros Anteriores do Ponto e que foram integrados
	//Assim, garantimos que va ocorrer error de chave duplicada
	//Como a reintegracao nesse novo processo eh um caso raro de
	//ocorrer, o acumulo de lancamentos nao eh um fator de atencao
	IF lIntegra
		For nArray	:= 1 to Len(aGRVRecDel)
			IF !( Empty( aGRVRecDel[ nArray ] ) )
				( cAlias )->( dbGoto( aGRVRecDel[ nArray ] ) )
			
				IF !RecLock( cAlias, .F. )
					Loop
				EndIF
			
				IF !( cAlias )->( FkDelete( @cMsgErr ) )
					( cAlias )->( RollBackDelTran( cMsgErr ) )
				EndIF
				( cAlias )->( MsUnLock() )
		    Endif
		Next nArray
	Endif


	//-- Troca Filial de Entrada para Integridade
	cFilAnt := IF( !Empty( cFil ) , cFil , cFilAnt )              

	//RGB->( dbsetOrder(Retorder( "RGB" , "RGB_FILIAL+RGB_PROCES+RGB_MAT+RGB_PERIOD+RGB_SEMANA+RGB_PD+RGB_SEQ" ) ) ) 
	If ( cAlias == "RGB" )
		RGB->( dbSetOrder(RetOrder( "RGB" , "RGB_FILIAL+RGB_PROCES+RGB_MAT+RGB_PERIOD+RGB_SEMANA+RGB_ROTEIR+RGB_PD+RGB_CC+RGB_SEQ+DTOS(RGB_DTREF)" ) ) ) 
	Else
		SRC->( dbSetOrder( RetOrder( "SRC" , "RC_FILIAL+RC_PROCES+RC_MAT+RC_PERIODO+RC_SEMANA+RC_ROTEIR+RC_PD+RC_CC+RC_SEQ+DTOS(RC_DTREF)" ) ))
	EndIf		

	//Realiza a gravacao dos lancamentos do Ponto
	For nArray := 1 To nForArray   
		If !(aColsGRV[ nArray, nPosGRVT2   ] == "E" ) .or. aColsGRV[ nArray, nPosGRVDeletedT   ]
		   Loop
		EndIf
	   	If (cAlias)->(dbSeek( cFil + aColsGRV[ nArray, nPosGRVPROCES ] + cMat + aColsGRV[ nArray, nPosGRVPERIODO] +;
	   								 aColsGRV[ nArray,nPosGRVSEMANA ] + aColsGRV[ nArray,nPosGRVROTEIRO]+;
	   								 aColsGRV[ nArray,nPosGRVPD ] + aColsGRV[ nArray,nPosGRVCC] +;
	   								 aColsGrv[ nArray,nPosGRVSEQ ] + Dtos(aColsGrv[ nArray, nPosGRVDATAREF ]) ))
	  	 	IF lSobrepoe
		  	 	IF !RecLock( cAlias, .F. )   
					Loop
				EndIF
			Else
				Loop
			EndIf
		Else
	  	 	IF !RecLock( cAlias, .T. )   
				Loop
			EndIF
		EndIf
	
		//-- Salva Campos que Nao fizeram parte do aHeader
		( cAlias )->(&(cPrefixo+"_FILIAL"))	:= cFil
		( cAlias )->(&(cPrefixo+"_MAT"))	:= cMat       
		If lItemCLVL
			( cAlias )->(&(cPrefixo+"_ITEM"))	:= cITEM
			( cAlias )->(&(cPrefixo+"_CLVL"))	:= cCLVL
		Endif
		
		//-- Corre todos os campos do aHeader
		For nHeader := 1 To nForHeader      
		    //-- Se o campo foi encontrado (Nao virtual, por exemplo)
		    //-- Grava seu novo conteudo 
			IF ( cAlias )->( FieldPos ( aHeader[ nHeader , 2 ] ) > 0 )			    
				( cAlias )->( FieldPut( FieldPos ( aHeader[ nHeader , 2 ] ) , aColsGRV[ nArray , nHeader ] ) )
			EndIF
		Next nHeader                  
		             
		//-- Desbloqueia Novo Registro
	   ( cAlias)->( MsUnlock())

	Next nArray    


	//	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//	³Complementar registros de origem (Acum.Resultados) com dados da Integracao	   ³
	//	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ							                

	If lIntegra   
		For nArray:= 1 to Len(aSPLRecEfe)   
	
			 SPL->( MsGOTO(aSPLRecEfe[nArray]))  
			 RecLock("SPL",.F.,.T.)
	/* Verificar se iremos gravar em campos adicionais o processo/periodo/etc destino dos lancamentos			 
			 SPL->PL_PROCES 	:= oPeriodo:cProcesso
			 SPL->PL_PERIODO	:= oPeriodo:cPeriodo
			 SPL->PL_SEMANA 	:= oPeriodo:cNumPagto
			 SPL->PL_ROTEIR 	:= oPeriodo:cRoteiro
	*/
			 SPL->PL_INTEGRA	:= "1"
			
			 SPL->( MsUnlock( aSPLRecEfe[nArray] ) )
		Next nArray	 					 
	Endif              
	
End Transaction

cFilAnt	:= cSvFilAnt

RestArea(aArea)

Return( NIL )


 /*
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³GeraLog   ³ Autor ³Marinaldo de Jesus     ³ Data ³11/05/2001³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Emissao do Log de Ocorrencias   	                        ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³aLog -> Log com as Ocorrencias Encontradas                  ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
Static Function GeraLog( aLog , cPerg , aLogPer, aLogSemVerba, aLogAusencia, aLogSemLcto , aLogProcesso)
Local aSX3Area		:= SX3->(GetArea())
Local aReturn		:= {STR0008, 1, STR0009, 2, 2, 1, "",1 }	//"Zebrado"###"Administra‡„o"
Local aTitLog		:= {}
Local aAuxLog		:= {}
Local aNewLog		:= {}
Local cTamanho		:= "M"
Local cTitulo		:= ( STR0007 + STR0011 )					//"Log de Ocorrencias"###" na Integracao com a Folha de Pagamento ( Geracao dos Resultados )"
Local cDet			:= ""
Local nX			:= 0.00
Local nTamLog		:= Len( aLog )
Local cPitRV_Qtde	:= ""
Local cFil			:= ""
Local cVerba		:= "" 
Local cCusto		:= ""
Local cFuncao		:= ""
Local lTemOutroLcto	:= .F.   
Local nPos			:=  0 
Local nPonto		:= 0
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Mascara do Relatorio                                         ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ           
//        10        20        30        40        50        60        70        80        90       100       110       120
//123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890
//Filial   Matricula Nome                            Verba    Centro de Custo  Funcao  Horas(Folha) Horas(Ponto)  Tipo Inconsistencia
//Sucursal matricula nombre                          Concepto centro de costo  Funcion Horas(Plan.) Horas(Reloj)  Tipo inconsistencia"
//XX       XXXXXX    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX  XXX      XXXXXXXXXXXXXXX  99999   999.99          999999.99  X    XXXXXXXXXXXXXX
//                                                 Qtde.Lancamentos =>    Permitida: 9   Exigida: 9                                  


//Trata ausencia de Picture no SX3
SX3->(DbSetOrder(2))
SX3->(Msseek("RV_QTDLANC"))
IF !SX3->(Empty(X3_PICTURE))
   cPitRV_Qtde:= Alltrim(X3Picture("RV_QTDLANC"))
Else           
	cPitRV_Qtde	:= Replicate('9',TamSX3("RV_QTDLANC")[1] ) + Replicate('9',TamSX3("RV_QTDLANC")[2])
Endif
RestArea(aSX3Area)
   
For nX := 1 To nTamLog  
	cTipo := AllTrim( aLog[ nX , 9 ] )
	cDet := aLog[ nX , 1 ] 	 + Space( 07 ) 								//Filial
	cDet += aLog[ nX , 2 ] 	 + Space( 02 ) 								//Matricula
	cDet += aLog[ nX , 3 ] 	 + Space( 02 ) 								//Nome
	If ( cTipo == "LOCK" )                        
		cDet += aLog[nX, 4] + Space(02) 								//Mensagens de Nao Integracao
	ElseIF ( cTipo == "QTDEREQ" )                  
	       cFil		:= aLog[nX, 1]
	       cVerba	:= aLog[nX, 4]
	       cCusto	:= aLog[nX, 5]
	       cFuncao	:= aLog[nX, 6]
	       nPos		:=	nX
	       lTemOutroLcto	:= .F.
	 	   Aeval(aLog,{|X|nPos++, If(x[1] == cFil .and. x[9] == cTipo .and. x[4] == cVerba  .and.;
	 	   							x[5] == cCusto .and.x[6] == cFuncao  ,;
							 	   (lTemOutroLcto:=.T.,nPonto:=nPos), lTemOutroLcto:=lTemOutroLcto)},nX+1)
	 	   If (!lTemOutroLcto)
			 	cDet += STR0025	+ Space(02)																	//"Qtde Lancamentos: =>"
			 	cDet += STR0023	+ Space(01)																	//"Permitida:"
				cDet += Transform( aLog[ nX , 11 ] , cPitRV_Qtde ) + Space(03)
			 	cDet += STR0024	+ Space(01)																	//"Exigida:"
				cDet += Transform( aLog[ nX , 12 ] , cPitRV_Qtde )					
		   Else
		        Loop
		   Endif		
	Else
		cDet += aLog[ nX , 4 ] 							  	+ Space( 12 ) 							//Verba 
		cDet += aLog[ nX , 5 ] 								+ Space( 11 - Len( aLog[ nX , 5 ] ) )	//Centro de Custo
		cDet += aLog[ nX , 6 ] 								+ Space( 13 - Len( aLog[ nX , 6 ] ) )	//Funcao                    
		cDet += Transform( aLog[ nX , 7 ] , "@R 999.99" )	+ Space( 04 ) 							//Horas(Folha)
		cDet += Transform( aLog[ nX , 10 ] , "@R 9999.99" )			 							    //Horas Ponto
		IF ( Len( cTipo ) <= 1 )
			cDet +=	Space( 02 )+aLog[ nX , 9 ] + Space(1)											//Tipo
		Else
			cDet +=Space( 05 )																		//Tipo
		EndIF
		cDet += Space(01)
		IF ( Len( cTipo ) > 1 )
			IF ( cTipo == "MAXLANC" )
				cDet += STR0012																		//"No.Max.Lancamentos Exced."
			ElseIF ( cTipo == "NOLANC" )
				cDet += STR0013																		//"Verba Nao Recebe Lancto."
			EndIF																		
		Else
			cDet += STR0014																			//"Ja Existe Lancamento"
		EndIF
	Endif	
	aAdd( aNewLog , cDet )
Next nX

aLog := {}

IF Len( aLogSemVerba ) > 1
	aAdd( aTitLog , STR0035 ) // "Verbas nao configuradas para a integracao:"
	aAdd( aLog , aClone( aLogSemVerba ) )
EndIF

IF Len( aLogSemLcto ) > 1
	aAdd( aTitLog , STR0037 ) // "Funcionarios Sem Lancamentos para Integrar: "				
	aAdd( aLog , aClone( aLogSemLcto ) )
EndIF 

IF Len( aLogAusencia ) > 1
	aAdd( aTitLog , STR0036 ) // "Ausencias ja existentes:" 
	aSort( aLogAusencia 	, 02 , NIL , { |x,y| x < y } )                        
	aAdd( aLog , aClone( aLogAusencia ) )
EndIF

If Len( aLogProcesso ) > 1
	aAdd( aTitLog , STR0042 ) // "Os seguintes itens nao foram integrados: "
	aAdd( aLog , aClone( aLogProcesso ) )
EndIF

IF !Empty( aNewLog )
	aAdd( aTitLog , STR0010 ) //Filial   Matricula Nome                            Verba    Centro de Custo  Funcao  Horas(Folha) Horas(Ponto)  Tipo Inconsistencia
	aAdd( aLog , aClone( aNewLog ) )
EndIF	
IF !Empty( aLogPer )
	aAdd( aLog , aClone( aLogPer ) )
EndIF	

fMakeLog( aLog , aTitLog , cPerg , .T. , FunName() , cTitulo , cTamanho , "L" , aReturn )

Return( NIL )

/*
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³ Cria_Temp ³ Autor ³Equipe Advanced RH    ³ Data ³21/11/1996³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³ Cria arquivo tempor rio para exporta‡„o de Dados.          ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Uso  	   ³ SIGAPON							   						³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Retorno  ³ NIL                                                        ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³ cArqDbf = Nome do Arquivo     a ser criado.                ³
³          ³ cArqInd = Nome do Indice a ser criado.                     ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ */
Static Function Cria_Temp( cArqDbf , cArqInd )

Local aFields	:= {}
Local lRet		:= .T.
Local cTAB		:= If( "RC" $ cPrefixo, "SRC", "RGB" )

cArqDBF  := CriaTrab(NIL,.F.)
aFields  := ( cTAB )->( dbStruct() )
MsCreate( cArqDbf , aFields , __LocalDriver )
MsOpenDbf( .T. , __LocalDriver , cArqDbf , "PONM040TMP" , .T. , .F. )

IF ( lRet := ( Select( "PONM040TMP" ) > 0.00 ) )
	cIndCond := (cPrefixo+"_FILIAL + ") + (cPrefixo+"_MAT + ") + (cPrefixo+"_PD")
	cArqInd  := FileNoExt(cArqDBF)
	IndRegua("PONM040TMP",cArqInd,cIndCond,,,STR0004 ) // 'Selecionando Registros...'
	PONM040TMP->( dbGotop() )
EndIF	

Return( lRet )


/*
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³fDividLanc³ Autor ³ MauricioMR            ³ Data ³05/05/2003³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Divide um lancamento em n lancamentos                       ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Uso      ³ PONM040                                                    ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ  */
Static Function fDividLanc( aLancSPL, nLimHoras, nLimValor, aItensSPL)

Local lParaHoras	:= .F.
Local lParaValor	:= .F.  

DEFAULT nLimHoras	:= Val( Replicate( '9', ( TamSx3((&(cPrefixo+"_HORAS")))[1] - ( TamSx3((&(cPrefixo+"_HORAS")))[2] + 1 ) ) ) + '.' + Replicate('9',TamSx3((&(cPrefixo+"_HORAS")))[2]))
DEFAULT nLimValor	:= Val( Replicate( '9', ( TamSx3((&(cPrefixo+"_VALOR")))[1] - ( TamSx3((&(cPrefixo+"_VALOR")))[2] + 1 ) ) ) + '.' + Replicate('9',TamSx3((&(cPrefixo+"_VALOR")))[2]))						               	 
DEFAULT aItensSPL	:= {}

//-- Carrega qtdes originais do lancamento de resultados       
nHoras := aLancSPL[nPosSPLHORAS] // Horas
nValor := aLancSPL[nPosSPLVALOR] // Valor

//-- Se a Quantidade ou o Valor ultrapassou o limite correspondente
If ( (nHoras-nLimhoras) >  0.00 ) 	.or. ( (nValor-nLimValor) > 0.00 )            
    //-- Cria tantos lancamentos quantas vezes a quantidade ultrapassar o limite 
	While ( !( lParaHoras ) .or. !( lParaValor ) )
	    //-- Calcula nova Qtde de Horas
	   	If (nHoras-nLimhoras) >  0.00  
	   		nHoras:= nHoras-nLimHoras 
	   	Else
	   	    lParaHoras	:=	.T.	
	   	    nLimHoras	:=	nHoras
 	   	Endif            
		//-- Calcula novo Valor
		If (nValor-nLimValor) >  0.00  
	   		nValor:= nValor-nLimValor
	   	Else
	   		lParaValor	:= .T.	
	   		nLimValor	:= nValor
	   	Endif 
	   	//-- Cria Lancamento Complementar       	   	
	   	aAdd(aItensSPL,aClone(aLancSPL))    	   	
	   	aItensSPL[Len(aItensSPL), nPosSPLHORAS]:= nLimHoras    
	   	aItensSPL[Len(aItensSPL), nPosSPLVALOR]:= nLimValor  
	   	//-- Zera o Saldo restante se criado o lancamento do mesmo
	   	nHoras := if(lParaHoras, 0.00, nHoras)
	   	nValor := if(lParaValor, 0.00, nValor)
	Enddo  
Else
	//-- Armazena  lancamento original se nao foi subdividido
	aAdd(aItensSPL,aClone(aLancSPL))    
Endif

Return( NIL )

/*
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³MyLockReg ³ Autor ³MauricioMR / Marinaldo ³ Data ³28/05/2003³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Trata Bloqueio de Registros com Uso de MayIUseCode.			³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Uso      ³ PONM040                                                    ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ */
Static Function MyLockReg( cAlias , aRegsLock , aKeysLock )

Local nTentaLocks	:= 5
Local nSecondsWait	:= 5

Return( PonLockRegs( cAlias , aRegsLock , aKeysLock , nTentaLocks , nSecondsWait ) )

/*
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³FreeMyLock³ Autor ³MauricioMR / Marinaldo ³ Data ³28/05/2003³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Libera Lock gerado pela MyLockReg.							³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Uso      ³ PONM040                                                    ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
Static Function FreeMyLock( cAlias , nReg )
Return( PonFreeLocks( cAlias , nReg ) )

/*
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³gpFilPon  ³Autor³Kelly Soares               ³Data³12/07/2006³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Filtro da Consulta Padrao RCHPON							³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³PONM040                  			                  	   	³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ  */
Function gpRCHFilPon(cMvProc,cMvPer)

Local cProces := &cMvProc
Local cPeriod := &cMvPer
Local cFiltro := "(RCH->RCH_FILIAL == '" + xFilial("RCH") + "') .AND. !EMPTY(RCH->RCH_DTFECH) .AND. RCH->RCH_ROTEIR = 'PON' " 

If !Empty(cProces)
	cFiltro	+= " .AND. (RCH->RCH_PROCES == '" + cProces + "')" 
EndIf
If !Empty(cPeriod)
	cFiltro	+= " .AND. (RCH->RCH_PER == '" + cPeriod + "')" 
Endif

cFiltro := "@#" + cFiltro + "@#"

Return ( cFiltro )


 /*
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³Ponm040Per³Autor³Kelly Soares               ³Data³12/07/2006³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Validar o Periodo digitado na Consulta Padrao				³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Consulta Padrao (SXB)				                  	   	³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
Function Ponm040Per( nTipo , cProces, cPer, cNPag , cReturn )

Local cOldAlias := Alias()
Local cFilRCH	:= xFilial("RCH")
Local cMsg

Local lRet 		:= .T.

Begin Sequence

	If ( nTipo == 1 )
		If !( lRet := NaoVazio() )
			Break
		EndIF
	Endif

	DbSelectArea("RCH")
	If ( nTipo == 1 )
		RCH->( dbsetOrder( Retorder( "RCH" , "RCH_FILIAL+RCH_PROCES+RCH_PER+DTOS(RCH_DTFECH)" ) ) )
		RCH->( dbSeek( cFilRCH + cProces + cPer + SPACE(6) , .F. ) )
	Else
		RCH->( dbsetOrder( Retorder( "RCH" , "RCH_FILIAL+RCH_PROCES+RCH_PER+RCH_NUMPAG+RCH_ROTEIR" ) ) )
		RCH->( dbSeek( cFilRCH + cProces + cPer + cNPag, .F. ) )
		While RCH->( !Eof() .and. ( ( RCH_FILIAL + RCH_PROCES + RCH_PER + RCH_NUMPAG ) == ( cFilRCH + cProces + cPer + cNPag ) ) )
			If Empty(RCH->RCH_DtFech)
				Exit
			EndIf
			RCH->( dbSkip() )	
		Enddo			
		If RCH->( !Empty( RCH_DTFECH ) .and. ( ( RCH_FILIAL + RCH_PROCES + RCH_PER + RCH_NUMPAG ) == ( cFilRCH + cProcesso + cPeriodo + cNumPag ) ) )
			RCH->(DbGoBottom())
			RCH->(dbSkip())
		EndIf		
	Endif	
	If RCH->( Eof() )                             `
		lRet := .F.
		If ( nTipo == 1 )
			cMsg := STR0029	// "Periodo nao Cadastrado!"
		Else
			cMsg := STR0030	// "No. Pagamento nao Cadastrado para este Periodo!"
		EndIf
		MsgInfo( cMsg, STR0006)	
	Else
		If ( nTipo == 1 )
			&cReturn := cPer
		Else
			&cReturn := cNPag
		EndIf
	EndIf

End Sequence

DbSelectArea(cOldAlias)

Return( lRet )

   
/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³fCarregaSPL	³ Autor ³Mauricio MR		   ³ Data ³06/08/2007³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Obtem dados de eventos do Ponto p/a Integracao 				 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL															 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³SIGAPON     												 ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function fCarregaSPL(cAlias, cFil   , cMat   , cProcesso , cPeriodo, cNumPagto, cRoteiro, aHeader, aCols, aRec)

Local aSPL			:= {}

Local cFilMat		:= ( cFil + cMat )
Local cAliasQuery	:= cAlias
Local cSvFilAnt		:= cFilAnt   
Local cQuery

Local nOrder		:= RetOrdem( "SPL" , "PL_FILIAL+PL_MAT+PL_PD+DTOS(PL_DATA)+PL_CC+PL_DEPTO+PL_POSTO+PL_CODFUNC")
										  
Local nSvOrder		:= (cAlias)->( IndexOrd() )

Local nRec			:=0
Local nForHeader	:= Len(aHeader)
Local nHeader		:= 0  
Local nPosCPO 			
Local nX
Local nFornX
Local nLenSPL
Local lQueryOpened		:= .F.
Local cWhereQuery
	
Local bCondWhile	:= {||.T.}
Local bCondSkip		:= {||.T.}


#IFDEF TOP

	Local cSvAlias			:= Alias()
	Local cTableName		:= ""
	Local cCpoRecno			:= ""

	Static aSPLFields
	Static cQrySPLFields
	Static nSPLFields

	IF !( lExInAs400 )
	
		aSPLFields := ( cAlias )->( dbStruct() )
		nSPLFields := Len( aSPLFields )

		IF ( cQrySPLFields == NIL )
			cQrySPLFields := ""
			For nX := 1 To nSPLFields
				cQrySPLFields += aSPLFields[ nX , 01 ] + ", "
			Next nX
	    EndIF

	EndIF	    

#ENDIF

cFilAnt	:= IF( !Empty( cFil ) , cFil , cFilAnt )


IF !( nSvOrder == nOrder )
	( cAlias )->( dbSetOrder( nOrder ) )
EndIF

#IFDEF TOP

	IF !( lExInAs400 )
     		
		cTableName	:= InitSqlName( cAlias )
		cCpoRecno	:= IF( lExInAs400 , "RRN("+cTableName+")", "R_E_C_N_O_" )
		
		cAliasQuery := ( "__Q" + cAliasQuery + "QRY" )
		cQuery := "SELECT "
		cQuery += cQrySPLFields
		cQuery += cCpoRecno + " RECNO "
		cQuery += " FROM "
		cQuery += cTableName
		
		cQuery += " WHERE "
		cQuery += "PL_FILIAL='"+cFil+"'"
		cQuery += " AND "
		cQuery += "PL_MAT='"+cMat+"'"    
		cQuery += " AND "            
		cQuery += "PL_DATA<='"+cDtFim+"'"
		cQuery += " AND " 
		cQuery += " ( PL_INTEGRA<>'1') "
		cQuery += " AND "
		cQuery += " ( "
		cQuery +=		" ( "
		cQuery += 			"PL_TIPO1='H'"
		cQuery += 			" AND "
		cQuery += 			"PL_HORAS<>0"
		cQuery += 		 " ) "
		cQuery += 		" OR "
		cQuery +=		" ( "
		cQuery += 			"PL_TIPO1='D'"
		cQuery += 			" AND "
		cQuery += 			"PL_HORAS<>0"
		cQuery += 		 " ) "
		cQuery += 		" OR "
		cQuery +=		" ( "
		cQuery += 			"PL_TIPO1='V'"
		cQuery += 			" AND "
		cQuery += 			"PL_VALOR<>0"
		cQuery += 		 " ) "
		cQuery += " ) "
		cQuery += " AND " 
		cQuery += "D_E_L_E_T_=' ' "

		
		cQuery += "ORDER BY " + SqlOrder( (cAlias)->( IndexKey() ) )
		cQuery := ChangeQuery( cQuery )
		IF ( lQueryOpened := MsOpenDbf(.T.,"TOPCONN",TcGenQry(NIL,NIL,cQuery),cAliasQuery,.F.,.T.) )
			For nX := 1 To nSPLFields
				IF !( aSPLFields[ nX , 02 ] == "C" )
					TcSetField(cAliasQuery,aSPLFields[nX,01],aSPLFields[nX,02],aSPLFields[nX,03],aSPLFields[nX,04])
				EndIF
			Next nX
			cQuery := ""
		Else
			cAliasQuery	:= cAlias
			( cAliasQuery )->( dbSeek( cFilMat  , .F. ) )
		EndIF
	
    EndIF
#ENDIF  
    
//Define a Condicao de Loop
IF !( lQueryOpened )                                
	(cAlias)->( dbSeek( cFilMat  , .F. ) )
	bCondWhile	:=	{|| ( ( PL_FILIAL + PL_MAT ) == cFilMat )  }
	bCondSkip	:=	{|| ( DTOS(PL_DATA) > cDtFim ) .or. ;
						( ( PL_TIPO1 == "H" ) .and. ( PL_HORAS == 0.00 ) ) .or.	;
						( ( PL_TIPO1 == "D" ) .and. ( PL_HORAS == 0.00 ) ) .or. ;
						( ( PL_TIPO1 == "V" ) .and. ( PL_VALOR == 0.00 ) )		;
			   		}               


Endif
        
While ( cAliasQuery )->( !Eof() .and. Eval(bCondWhile) )

	//Verifica se Lacto pertence ao Periodo da Folha))
	IF !( lQueryOpened )
      	If ( cAliasQuery )->(Eval(bCondSkip))
      		( cAliasQuery )->( dbSkip() )
      		Loop
      	Endif
    Endif  		
    //Carrega cada Registro na memoria para processamento
    aAdd( aCols , Array( nForHeader + 1 ) )
	//-- Corre todos os campos do aHeader
	For nHeader := 1 To nForHeader      
	    //-- Se o campo foi encontrado (Nao virtual, por exemplo)
	    //-- Recupera conteudo
		IF ( cAliasQuery )->( (nPosCPO:=FieldPos ( aHeader[ nHeader , 2 ] ) ) ) > 0 			    
		    aCols[ Len(aCols), GdFieldPos( aHeader[ nHeader , 2 ]	, aHeader ) ]:= ( cAliasQuery )->( FieldGet( nPosCPO) )
		EndIF
	Next nHeader 
	

	
	//Alimenta Vetor de Numero do Registro Fisico
	#IFNDEF TOP
		nRec:=  (cAliasQuery )->( Recno() )
	#ELSE
		IF !( lQueryOpened )
			nRec:=  (cAliasQuery )->( Recno() )
		Else
			nRec:=  (cAliasQuery )->( RECNO )  
		EndIF
	#ENDIF
    
	AADD(aRec, nRec )
	                                
	//Adiciona novas colunas: Numero do Registro fisico e linha virtual para
	//manter a ordem de entrada num asort
    AADD(aCols[Len(aCols)],nRec)
    If nPosSPLRec == 0 
   		nPosSPLRec := Len(aCols[1])
   	Endif   
	AADD(aCols[Len(aCols)],Len(aCols))
	nPosSPLLin := Len(aCols[1])
		
	( cAliasQuery )->( dbSkip() )

End While

IF ( ( lQueryOpened ) .and. ( Select( cAliasQuery ) > 0 ) )
	( cAliasQuery )->( dbCloseArea() )
	dbSelectArea( cSvAlias )
EndIF	

	    
IF !( nSvOrder == nOrder )
	( cAlias )->( dbSetOrder( nSvOrder ) )
EndIF

cFilAnt	:= cSvFilAnt

Return( NIL )		


/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³fCarregaGRV	³ Autor ³Mauricio MR		   ³ Data ³06/08/2007³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Obtem dados de verbas da Folha de Pagamento p/a Integracao   ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL															 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³SIGAPON     												 ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/

Function fCarregaGRV(cAlias, cFil   , cMat   , cProcesso, cPeriodo, cNumPagto, cRoteiro, aHeader   , aCols   , aRec)

Local cFilMat		:= ( cFil + cMat )
Local cAliasQuery	:= cAlias
Local cSvFilAnt		:= cFilAnt
Local cKey			:= ""
Local cIndexKey     := ""       
Local cQuery
Local nOrder		:= 0
Local nSvOrder		:= 0

Local nRec			:= 0
Local nForHeader	:= Len(aHeader)
Local nHeader		:= 0  
Local nPosCPO 			
Local nX
Local nFornX
Local nLenGRV
Local lQueryOpened		:= .F.
Local cWhereQuery
	
Local bCondWhile		:= {||.T.}
Local bCondSkip		:= {||.T.}

#IFDEF TOP
	Local cSvAlias			:= Alias()
	Local cTableName		:= ""
	Local cCpoRecno			:= ""
#ENDIF

#IFDEF TOP
	Static cQryGRVFields
	Static aGRVFields
	Static nGRVFields

	IF !( lExInAs400 )
	
	    aGRVFields := ( cAlias )->( dbStruct() )
		nGRVFields := Len( aGRVFields )

		IF ( cQryGRVFields == NIL )
			cQryGRVFields := ""
			For nX := 1 To nGRVFields
				cQryGRVFields += aGRVFields[ nX , 01 ] + ", "
			Next nX
	    EndIF

	EndIF	    

#ENDIF

If cAlias == "RGB"
	nOrder		:= RetOrdem( "RGB" , "RGB_FILIAL+RGB_PROCES+RGB_MAT+RGB_PERIOD+RGB_SEMANA+RGB_PD+RGB_SEQ")
	nSvOrder	:= (cAlias)->( IndexOrd() )
	cKey		:= cFil + cProcesso + cMat + cPeriodo + cNumPagto
ElseIf cAlias == "SRC"
	nOrder		:= RetOrdem( "SRC" , "RC_FILIAL+RC_MAT+RC_PROCES+RC_ROTEIR+RC_PERIODO+RC_SEMANA")
	nSvOrder	:= (cAlias)->( IndexOrd() )
 	cKey		:= cFil + cMat + cProcesso + cRoteiro + cPeriodo + cNumPagto  
EndIf

cFilAnt	:= IF( !Empty( cFil ) , cFil , cFilAnt )


IF !( nSvOrder == nOrder )
	( cAlias )->( dbSetOrder( nOrder ) )
EndIF


#IFDEF TOP

	IF !( lExInAs400 )
     		
		cTableName	:= InitSqlName( cAlias )
		cCpoRecno	:= IF( lExInAs400 , "RRN("+cTableName+")", "R_E_C_N_O_" )
		
		cAliasQuery := ( "__Q" + cAliasQuery + "QRY" )
		cQuery := "SELECT "
		cQuery += cQryGRVFields
		cQuery += cCpoRecno + " RECNO "
		cQuery += " FROM "
		cQuery += cTableName
		cQuery += " WHERE "
		cQuery += (cPrefixo+"_FILIAL='")+cFil+"'"
		cQuery += " AND "
		cQuery += (cPrefixo+"_MAT='")+cMat+"'"    
		cQuery += " AND "            
		cQuery += (cPrefixo+"_DTREF<='")+cDtFim+"'"
		cQuery += " AND " 
		cQuery += " ( "
		If cAlias == "RGB"
			cQuery += 		(cPrefixo+"_PERIOD='")+cPeriodo+"'"
		Else
			cQuery += 		(cPrefixo+"_PERIODO='")+cPeriodo+"'"		
		EndIf
		cQuery += 		" AND "    
		cQuery += 		(cPrefixo+"_PROCES='")+cProcesso+"'" 
		cQuery += 		" AND "    				
		cQuery += 		(cPrefixo+"_SEMANA='")+cNumPagto+"'" 
		cQuery += 		" AND "    				    
		cQuery += 		(cPrefixo+"_ROTEIR='")+cRoteiro+"'" 				
		cQuery += 	" ) "  					
		cQuery += " AND " 
		cQuery += "D_E_L_E_T_=' ' "
		
		cQuery += "ORDER BY " + SqlOrder( (cAlias)->( IndexKey() ) )
		cQuery := ChangeQuery( cQuery )
		IF ( lQueryOpened := MsOpenDbf(.T.,"TOPCONN",TcGenQry(NIL,NIL,cQuery),cAliasQuery,.F.,.T.) )
			For nX := 1 To nGRVFields
				IF !( aGRVFields[ nX , 02 ] == "C" )
					TcSetField(cAliasQuery,aGRVFields[nX,01],aGRVFields[nX,02],aGRVFields[nX,03],aGRVFields[nX,04])
				EndIF
			Next nX
			cQuery := ""
		Else
			cAliasQuery	:= cAlias
			( cAliasQuery )->( dbSeek( cFilMat  , .F. ) )
		EndIF
	
    EndIF

#ENDIF  
    
    
//Define a Condicao de Loop
IF !( lQueryOpened )                                
	(cAlias)->( dbSeek( cKey  , .F. ) )
	bCondSkip	:=	{|| Dtos((&(cPrefixo+"_DTREF"))) > cDtFim }
Endif

cIndexKey		:= Upper( AllTrim( ( cAlias )->( IndexKey() ) ) )
bCondWhile		:= { |cKey| SubStr( __ExecMacro( cIndexKey ) , 1 , Len( cKey ) ) == cKey }
        
While ( cAliasQuery )->( !Eof() .and. Eval( bCondWhile , cKey ) )
	//Verifica se Lacto pertence ao Periodo da Folha))
	IF !( lQueryOpened )
      	If ( cAliasQuery )->(Eval(bCondSkip))
      		( cAliasQuery )->( dbSkip() )
      		Loop
      	Endif
    Endif  		

    //Carrega cada Registro na memoria para processamento
        
    //Carrega cada Registro na memoria para processamento
    aAdd( aCols , Array( nForHeader + 1 ) )
	//-- Corre todos os campos do aHeader
	For nHeader := 1 To nForHeader      
	    //-- Se o campo foi encontrado (Nao virtual, por exemplo)
	    //-- Recupera conteudo
		IF ( cAliasQuery )->( (nPosCPO:=FieldPos ( aHeader[ nHeader , 2 ] ) ) ) > 0 			    
		    aCols[ Len(aCols), GdFieldPos( aHeader[ nHeader , 2 ]	, aHeader ) ]:= ( cAliasQuery )->( FieldGet( nPosCPO) )
		EndIF
	Next nHeader 
	 
	//--Inicializa aCols com delecao para Falso.
	aCols[Len(aCols),nForHeader + 1]:=.F.
	
	//Alimenta Vetor de Numero do Registro Fisico
	#IFNDEF TOP
		AADD(aRec, (cAliasQuery )->( Recno() ) )
	#ELSE
		IF !( lQueryOpened )
			AADD(aRec, (cAliasQuery )->( Recno() ) )
		Else
			AADD(aRec, ( cAliasQuery )->( RECNO )  )
		EndIF
	#ENDIF

	( cAliasQuery )->( dbSkip() )

End While

IF ( ( lQueryOpened ) .and. ( Select( cAliasQuery ) > 0 ) )
	( cAliasQuery )->( dbCloseArea() )
	dbSelectArea( cSvAlias )
EndIF	

	    
IF !( nSvOrder == nOrder )
	( cAlias )->( dbSetOrder( nSvOrder ) )
EndIF

cFilAnt	:= cSvFilAnt
 
Return( NIL )		
                                                              

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡ao	 ³fBuscaAfast³ Autor ³ Mauricio T. Takakura ³ Data ³ 04.08.05 ³±±
±±³          ³      v.II ³ Autor ³ Mauricio MR          ³      ³ 13.08.07 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Retorna todos os afastamentos e ferias do funcionario	  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³                                    					 	  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³ fBuscaAfast												  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso		 ³ Gen‚rico 												  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Static Function fBuscaAfast(cFil,cFilSRA,cMatSRA, dDtPesq1,aAfast)
Local cAliasQry := 'SR8'
Local cAliasAnt  := Alias()
Local lQuery	 := .F.
Local lAs400	 := ( TcSrvType() == "AS/400" )
Local cSvFilAnt	 := cFilAnt
Local cDataFim	 := ""
Local lFound	 := .F.

Local cQuery	 := ""
Local nX		 := 0

Static aStruSr8	

DEFAULT aStruSr8 := {}

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Verifica se foram passados os parametros se nao cria vazio ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/	
dDtPesq1 := If(dDtPesq1 = Nil , dDataBase , dDtPesq1)

cFilAnt	:= IF( !Empty( cFil ) , cFil , cFilAnt )

#IFDEF TOP
	If !lAs400

		cDataAfast			:= "% '"+ Dtos(dDtPesq1) + "' %"         
		
		cEmptyData			:= "% '"+ Dtos(dDataBase) + "' %" 
				     		
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Horas de Afastamentos e Ferias							 		  ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/    
		cAliasQry := GetNextAlias()
		cOrdem	:= SqlOrder( SR8->( IndexKey() ) )
	   /*
		cOrdem	:= '%'+SqlOrder( SR8->( IndexKey() ) )+ '%'
	  
		BeginSql Alias cAliasQry	
			SELECT  SR8.R8_FILIAL, SR8.R8_MAT, SR8.R8_DATA, SR8.R8_TIPO, SR8.R8_DATAINI, 
				CASE SR8.R8_DATAFIM WHEN '        ' THEN %exp:cEmptyData% ELSE SR8.R8_DATAFIM END AS R8_DATAFIM
			FROM  %table:SR8% SR8 
			WHERE 
				%exp:cFilSRA% 	= SR8.R8_FILIAL AND
				%exp:cMatSRA% 	= SR8.R8_MAT    AND
				CASE SR8.R8_DATAFIM WHEN '        ' THEN %exp:cEmptyData% ELSE SR8.R8_DATAFIM END   >=  %exp:cDataAfast%
		
			ORDER BY 
				%exp:cOrdem%				
		EndSql
	*/
		lQuery := .T.
	
		aStruSR8  := If(Empty(aStruSR8),SR8->(dbStruct()),aStruSR8)
		cQuery := "SELECT * "
		cQuery += "FROM "+RetSqlName("SR8")+" SR8 "
		cQuery += "WHERE SR8.R8_FILIAL='"+cFilSRA+"' AND "
		cQuery += "SR8.R8_MAT='"+cMatSRA+"' AND "
		cQuery += "SR8.D_E_L_E_T_ = ' ' "
		cQuery += "ORDER BY " + cOrdem
		cQuery := ChangeQuery(cQuery)
		dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasQry,.T.,.T.)
	
		For nX := 1 To Len(aStruSR8)
			If ( aStruSR8[nX][2] <> "C" )
				TcSetField(cAliasQry,aStruSR8[nX][1],aStruSR8[nX][2],aStruSR8[nX][3],aStruSR8[nX][4])
			EndIf
		Next nX
		lQuery	:= .T.	 
		
	Else
		(cAliasQry)->(dbSeek( cFilSRA + cMatSRA))
	EndIf
	
#ENDIF

#IFNDEF TOP
	(cAliasQry)->(dbSeek( cFilSRA + cMatSRA))
#ENDIF

While !Eof() .And. (cAliasQry)->( R8_FILIAL + R8_MAT ) = (cFilSRA + cMatSRA)
    /*
	#IFNDEF TOP
    	cDataFim	:= Dtos(IF ( Empty( (cAliasQry)->R8_DATAFIM ) ,dDataBase , (cAliasQry)->R8_DATAFIM  ) )
		If !( Dtos( (cAliasQry)->R8_DATAINI ) > Dtos( dDtPesq1 ) )  .and. ;
		   !( cDataFim  < Dtos( dDtPesq1 ) ) 
		
			Aadd(aAfast,{	(cAliasQry)->R8_DATAINI	,(cAliasQry)->R8_DATAFIM	})
			lFound	:=.T.
		EndIf
	#ELSE 
		If !lAs400
			cDataFim	:= IF ( Empty( (cAliasQry)->R8_DATAFIM ), Dtos(dDataBase), (cAliasQry)->R8_DATAFIM  ) 	
			If !(  (cAliasQry)->R8_DATAINI  >  Dtos(dDtPesq1)  )  .and. ;
			   !( cDataFim  <  Dtos(dDtPesq1)  ) 
			
				Aadd(aAfast,{	(cAliasQry)->R8_DATAINI	,(cAliasQry)->R8_DATAFIM	})
				lFound	:=.T.
			EndIf
		Else 
			cDataFim	:= Dtos(IF ( Empty( (cAliasQry)->R8_DATAFIM ) ,dDataBase , (cAliasQry)->R8_DATAFIM  ) )
			If !( Dtos( (cAliasQry)->R8_DATAINI ) > Dtos( dDtPesq1 ) )  .and. ;
			   !( cDataFim  < Dtos( dDtPesq1 ) ) 
			
				Aadd(aAfast,{	(cAliasQry)->R8_DATAINI	,(cAliasQry)->R8_DATAFIM	})
				lFound	:=.T.
			EndIf
		Endif	
	#ENDIF    
	*/
	
	cDataFim	:= IF ( Empty( (cAliasQry)->R8_DATAFIM ), Dtos(dDataBase), (cAliasQry)->R8_DATAFIM  ) 	
	If !(  (cAliasQry)->R8_DATAINI  >  (dDtPesq1)  )  .and. ;
	   !( cDataFim  <  (dDtPesq1)  ) 
	
		Aadd(aAfast,{	(cAliasQry)->R8_DATAINI	,(cAliasQry)->R8_DATAFIM	})
		lFound	:=.T.
	EndIf

	(cAliasQry)->(dbSkip())

Enddo

If ( lQuery )
	(cAliasQry)->(dbCloseArea())
	dbSelectArea("SR8")
EndIf               

dbSelectArea(cAliasAnt)

cFilAnt	:= cSvFilAnt

Return(lFound)

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o	   ³ Pnm040TrnP 	³Autor³  Igor Franzoi	  ³ Data ³20/06/2008³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Transferir o parametro MV_PAR01 para variavel private		³
|		   |cProcesso    											    |
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL                      									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso	   ³Generica      										    	³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function Pnm040TrnP()

Local lRet := .T.

If ( lRet := ExistCpo('RCJ') )
	cProcesso := &( ReadVar() )
EndIf

Return( lRet )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³Pnm040VP  ³Autor³Igor Franzoi               ³Data³20/06/2008³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Validar o Periodo digitado na Consulta Padrao				³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Consulta Padrao (SXB)				                  	   	³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function Pnm040VP()

Local cOldAlias := Alias()
Local cFilRCH	:= xFilial("RCH")
Local cMsg

Local lRet 		:= .T.

Begin Sequence

	IF !( lRet := NaoVazio() )
		Break
	EndIF

	DbSelectArea( "RCH" )
	RCH->( dbSetOrder( Retorder( "RCH", "RCH_FILIAL+RCH_PROCES+RCH_PER+DTOS(RCH_DTFECH)" ) ) )
	RCH->( dbSeek( cFilRCH + MV_PAR21 + MV_PAR22, .F. ) )

	If RCH->( Eof() )
		lRet := .F.
		cMsg := STR0029	// "Periodo nao Cadastrado!"
		MsgInfo( cMsg )
	Else
		cPeriodo := MV_PAR22
		cRot	 := "PON"
	EndIf

End Sequence
	
DbSelectArea(cOldAlias)                     

Return( lRet )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³Pnm040Rot ³Autor³Igor Franzoi               ³Data³20/06/2008³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Validar o Periodo digitado na Consulta Padrao				³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Consulta Padrao (SXB)				                  	   	³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function Pnm040Rot()

Local lRet := .T.

lRet := ExistCpo("SRY", MV_PAR24)

If lRet
	cRot := MV_PAR24
	If cRot != "PON"
		lRet := .F.
	EndIf
EndIf

Return ( lRet )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³Pnm040Load³Autor³Igor Franzoi               ³Data³20/06/2008³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Carrega os MV_ para as consultas padroes					³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Consulta Padrao (SXB)				                  	   	³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function Pnm040Load()

Pergunte( "PONM040" , .F. )

cProcesso	:= If ( !Empty(mv_par21), mv_par21, cProcesso)				//Processo
cPeriodo	:= If ( !Empty(mv_par22), mv_par22, cPeriodo )				//Periodo da folha
cNumPagto   := If ( !Empty(mv_par23), mv_par23, cNumPagto)				//Num. Pagto
cRot		:= If ( !Empty(mv_par24), mv_par24, "PON"	 )            	//Roteiro

Return (Nil)
