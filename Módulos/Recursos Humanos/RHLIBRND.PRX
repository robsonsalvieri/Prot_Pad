#INCLUDE "PROTHEUS.CH"

/*/
旼컴컴컴컴컫컴컴컴컴컴컴컴쩡컴컴컫컴컴컴컴컴컴컴컴컴컴컫컴컴컴쩡컴컴컴컴커
쿑un뇙o    쿔nRhLibRndExec쿌utor 쿘arinaldo de Jesus    Data 14/05/2003
쳐컴컴컴컴컵컴컴컴컴컴컴컴좔컴컴컨컴컴컴컴컴컴컴컴컴컴컨컴컴컴좔컴컴컴컴캑
쿏escri뇙o 쿐xecutar Funcoes Dentro de RHLIBRND                          
쳐컴컴컴컴컵컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴캑
쿞intaxe   쿔nRhLibRndExec( cExecIn , aFormParam )						 
쳐컴컴컴컴컵컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴캑
쿛arametros<Vide Parametros Formais>									 
쳐컴컴컴컴컵컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴캑
쿝etorno   퀅Ret                                                 	     
쳐컴컴컴컴컵컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴캑
쿚bserva뇙o                                                      	     
쳐컴컴컴컴컵컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴캑
쿢so       쿒enerico 													 
읕컴컴컴컴컨컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴켸/*/
Function InRhLibRndExec( cExecIn , aFormParam )
         
Local uRet

DEFAULT cExecIn		:= ""
DEFAULT aFormParam	:= {}

IF !Empty( cExecIn )
	cExecIn	:= BldcExecInFun( cExecIn , aFormParam )
	uRet	:= __ExecMacro( cExecIn )
EndIF

Return( uRet )

/*/
旼컴컴컴컴컫컴컴컴컴컴컴컴컴컴쩡컴컴쩡컴컴컴컴컴컴컴컴컫컴컴컴쩡컴컴컴컴커
쿑un뇙o    쿝oundingDistribute쿌utor쿘arinaldo de Jesus Data 01/10/2002
쳐컴컴컴컴컵컴컴컴컴컴컴컴컴컴좔컴컴좔컴컴컴컴컴컴컴컴컨컴컴컴좔컴컴컴컴캑
쿏escri뇙o 쿏istribui o Arredondamento em n Partes               	 	 
쳐컴컴컴컴컵컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴캑
쿞intaxe   <vide parametros formais>									 
쳐컴컴컴컴컵컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴캑
쿛arametros<vide parametros formais>									 
쳐컴컴컴컴컵컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴캑
쿝etorno   쿪Distribution -> Array com nParts elementos contendo os  valo
                           res que foram Distribuidos					 
쳐컴컴컴컴컵컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴캑
쿚bserva뇙o                                                      	     
쳐컴컴컴컴컵컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴캑
쿢so       쿒enerico                    								 
읕컴컴컴컴컨컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴켸/*/
Function RoundingDistribute( nParts , nValParts , lHoursDistribute )

Local aDistribution	:= {}
Local nDistribution := 0
Local nAux			:= 0

Local bTot
Local bPlus
Local bRemaining
Local nRemaining

DEFAULT nParts				:= 1
DEFAULT nValParts			:= 0
DEFAULT lHoursDistribute	:= .T.

aDistribution := Array( nParts )
aFill( aDistribution , nDistribution )

IF (;
			( nParts == 1 );
			.or.;
			( ( nDistribution := __NoRound( nValParts / nParts , 2 ) ) == 0 );
	)
	aDistribution[ nParts ] := nValParts
Else
	aFill( aDistribution , nDistribution )
	IF ( lHoursDistribute )
		bTot		:= { |x| ( nAux := SomaHoras( nAux , x ) ) }
		bPlus		:= { |x,y| ( aDistribution[y] := SomaHoras( aDistribution[y] , nDistribution ) ) }
		bRemaining	:= { || ( nRemaining := SubHoras( nValParts , nAux ) ) }
	Else
		bTot		:= { |x| ( nAux += x ) }
		bPlus		:= { |x,y| ( aDistribution[y] += nDistribution ) }
		bRemaining	:= { || ( nRemaining := ( nValParts - nAux ) ) } 
	EndIF	
	While !( aEval( aDistribution , bTot ) , ( nAux == nValParts ) )
		IF ( Eval( bRemaining ) <= 0.01 )
			IF ( lHoursDistribute )
				aDistribution[ nParts ] := SomaHoras( aDistribution[ nParts ] , nRemaining )
			Else
				aDistribution[ nParts ] += nRemaining
			EndIF
			Exit
		Else
			nDistribution := Round( nRemaining / nParts , 2 )
			aEval( @aDistribution , bPlus )
			IF ( ( nDistribution * nParts ) > nRemaining )
				IF ( lHoursDistribute )
					aDistribution[ nParts ] := SubHoras( aDistribution[ nParts ] , nDistribution )
				Else
					aDistribution[ nParts ] -= nDistribution
				EndIF
			EndIF
		EndIF
		nAux := 0
	End While
EndIF

Return( aDistribution )