#INCLUDE "PROTHEUS.CH"
#INCLUDE "GPEM550.CH"
#INCLUDE "shell.ch"

Static lGPE550ICD 	:= ExistBlock( "GPE550ICD" )
Static lGPE550GRV 	:= ExistBlock( "GPE550GRV" )
Static aTabS073   	:= {}
Static lAutomato	:= IsBlind()

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ GPEM550  ³ Autor  ³ J. Ricardo                        ³ Data ³ 12/06/95 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ GERA ARQUIVO DA DIRF (SR4)                                              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³         ATUALIZACOES SOFRIDAS DESDE A CONSTRU€AO INICIAL.                          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Programador ³ Data   ³ Requisito         ³  Motivo da Alteracao                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Bruno Nunes ³20/01/14³ M12RH01_001943_01 ³ Unificacao da DIRF da versao 11 com      ³±±
±±³            ³        ³                   ³ a fase 4                                 ³±±
±±³Christiane V³29/04/14³        TPJZJ8     ³ Réplicas P11 para P12                    ³±±
±±³Allyson M   ³25/07/14³        TQEGD2     ³Ajuste p/ na geracao dos lanctos de PLR   ³±±
±±³            ³        ³         			³verificar o tipo da verba.				   ³±±
±±³Esther V.   ³24/09/14³        TQQXB6     ³Ajuste na funcao f550MontaDados() para    ³±±
±±³            ³        ³         			³buscar campo RR_DATA ao inves de RC_DATA  ³±±
±±³            ³        ³         			³quando for chamada passando o Alias SRR.  ³±±
±±³Wag Mobile  ³14/01/15³ TRKAQ7            ³Ajuste em FGravaInf() para gravar todos os³±±
±±³            ³        ³                   ³fornecedores quando houver troca no ano.  ³±±
±±³            ³        ³                   ³Emissao de mensagem informando o valor dos³±±
±±³            ³        ³                   ³Mnemonicos NVLLIMDIRF e NVLLIMOUT antes da³±±
±±³            ³        ³                   ³geracao da DIRF.                          ³±±
±±³Mariana M   ³04/02/15³        TRLLE2     ³Ajustado valor da Assistencia medica para ³±±
±±³            ³        ³                   ³agregado quando há mudança de fornecedor  ³±±
±±³            ³        ³                   ³do plano. 								   ³±±
±±³Henrique V. ³25/02/15³        TRRMKB     ³Réplica do chamado TRQAU0.                ³±±
±±³            ³        ³                   ³Ajuste para que seja impresso as informaçõ³±±
±±³            ³        ³                   ³es complementares no quadro 7 para Verbas ³±±
±±³            ³        ³                   ³ com identificador "M" para DIRF          ³±±
±±³Allyson M   ³11/03/15³TRTBLY				³Ajuste na geracao da verba de reembolso p/³±±
±±³            ³        ³         			³considerar o CNPJ do fornecedor do plano  ³±±
±±³Thiago Y.M.N³09/04/15³TRVKJG             ³Ajuste para considerar o adiantamento pago³±±
±±³            ³        ³                   ³no mes da demissao do funcionario.		   ³±±
±±³L.Trombini  ³15/05/15³TSBLDW				³Ajuste quando utilizado o parametro 	   ³±±
±±³            ³        ³        			³MV_DINSSFM conteudo "S" e a data de paga- ³±±
±±³            ³        ³         			³mento ocorre no mês 10 e as ferias são    ³±±
±±³            ³        ³         			³partidas nos meses novembro e Dezembro    ³±±
±±³            ³        ³         			³para descontar INSS Ferias da remuneraçao ³±±
±±³            ³22/05/15³TSBLDW	 			³Nova Carga devido problema TFS  		   ³±±
±±³Allyson M   ³15/10/15³TTOYD9				³Ajuste no filtro de exclusao dos dados p/ ³±±
±±³            ³        ³         			³verificar a categoria do funcionario	   ³±±
±±³Allyson M   ³28/11/15³TTQMCY				³Ajuste na deducao do valor de adiantamento³±±
±±³            ³        ³         			³p/ evitar deducao incorreta  			   ³±±
±±³Marcia Moura³14/01/15³TUEPM6 			³Ajuste para que o roteiro de autonomos    ³±±
±±³            ³        ³         			³seja considerado na geracao    		   ³±±
±±³Claudinei S.³22/01/15³TTXLIX 			³Ajustado na GravaSR4() a gravacao do campo³±±
±±³            ³        ³                   ³RL_PAIS quando Residente no Exterior e    ³±±
±±³            ³        ³                   ³possuia PLR os valores não estavam sendo  ³±±
±±³            ³        ³                   ³apresentados na manutencao do arquivo.    ³±±
±±³Claudinei S.³27/01/16³TUIFD8        	    ³Ajustada a geração do PLR para Residentes ³±±
±±³            ³        ³         			³no exterior, não estava levando os valores³±±
±±³            ³        ³         			³Incluída informacao no log para identifi- ³±±
±±³            ³        ³         			³car quais funcionarios possuem dependentes³±±
±±³            ³        ³         			³acima de 13 anos sem CPF cadastrado.      ³±±
±±³Claudinei S.³28/01/16³TUIFD8				³Ajustada apuracao dos valores do desconto ³±±
±±³            ³        ³         			³do adiantamento de Dezembro na DIRF       ³±±
±±³Leandro Dr. ³23/02/16³TUODCY 			³Ajuste no desconto do adiantamento quando ³±±
±±³            ³        ³         			³se tem metade dos dados convertidos P11 e ³±±
±±³            ³        ³         			³outra metade não foi convertida.          ³±±
±±³Joao Balbino³22/02/16³TURXIR				³Alterado a  validação dos dependentes	   ³±±
±±³            ³        ³         			³a serem levados. (AMED e AODO)		       ³±±
±±³Esther V.   ³25/05/16³     TVFY37        ³Ajustado filtro de filial de acordo com   ³±±
±±³            ³        ³         			³acesso do usuario.						   ³±±
±±³Claudinei S.³08/07/16³TVP136/TUQEKD      ³Incluido tratamento para duplicidade de   ³±±
±±³            ³        ³                   ³registros quando possui historico de      ³±±
±±³            ³        ³                   ³contratos preenchido, Merge 12.1.12.      ³±±
±±³Claudinei S.³08/11/16³TWLEW6             ³Ajuste em GPM550Processa(), não estava    ³±±
±±³            ³        ³                   ³gerando os valores da primeira filial ao  ³±±
±±³            ³        ³                   ³informar 2 filiais nos parâmetros e as    ³±±
±±³            ³        ³                   ³filiais possuem gestão corporativa.       ³±±
±±³Jônatas A.  ³18/01/17³     MRH-4752      ³Compatibilização fontes DIRF P118->P12114 ³±±
±±³            ³        ³                   ³Para DIRF 2016 em diante não gravar mais a³±±
±±³            ³        ³                   ³pensao nas tabelas RCS e SR4 e sim na SM8 ³±±
±±³            ³        ³                   ³códigos C/C1/C2/C3/8/81 e Prev. Privada   ³±±
±±³            ³        ³                   ³Alteração no parametro do botão "Diagn."  ³±±
±±³            ³        ³                   ³p/ não ocasionar error.log na geração do  ³±±
±±³            ³        ³                   ³arquivo da DIRF.                          ³±±
±±³Jônatas A.  ³23/01/17³MRH-5183           ³Passagem de parâmetro para forçar a carga ³±±
±±³            ³        ³                   ³da tabela S073 na troca de filial.        ³±±
±±³Jônatas A.  ³26/01/17³MRH-5183           ³Ajuste p/ não duplicar ou abater o abono  ³±±
±±³            ³        ³                   ³pec. indevidamente em casos onde há férias³±±
±±³            ³        ³                   ³mês anterior e abono dentro do mesmo pagto³±±
±±³Jônatas A.  ³26/01/17³MRH-5183           ³Ajuste nos parãmetros da fRetTab().       ³±±
±±³Jônatas A.  ³31/01/17³MRH-5979           ³Ajuste p/ não duplicar ou abater a dif. de³±±
±±³            ³        ³                   ³abono pec. indevidamente quando  há dif.  ³±±
±±³            ³        ³                   ³sobre abono mês seguinte.                 ³±±
±±³Marcia Moura³        ³                   ³Inclusão de log c/ msg p/  beneficiários  ³±±
±±³            ³        ³                   ³s/ CPF e s/ data de nascimento.           ³±±
±±³Claudinei S.³        ³                   ³Ajuste no tratamento da verba de pagto de ³±±
±±³            ³        ³                   ³adto na DIRF, inclusive rescisão e bases  ³±±
±±³            ³        ³                   ³migradas da versão 11.8.                  ³±±
±±³Marcia Moura³        ³                   ³Inclusão de log c/ msg p/ alertar forn.   ³±±
±±³            ³        ³                   ³plano de saúde c/ dados faltantes.        ³±±
±±³Claudinei S.³03/02/17³MRH-6204 			³Ajuste em FGravaInf()para que aglutine os ³±±
±±³            ³        ³         			³registros de um mesmo beneficiário na tab.³±±
±±³            ³        ³         			³SM8, evitando duplicidade no TXT da DIRF. ³±±
±±³Marcia Moura³06/02/17³MRH-5979    		³Ajuste log para Reembolso e Beneficiarios ³±±
±±³Jônatas A.  ³07/02/17³MRH-6309           ³Alteração de índice da tabela RCS p/ ficar ±±
±±³            ³        ³                   ³de acordo à chave única da mesma.          ±±
±±³Jônatas A.  ³08/02/17³MRH-6473	        ³Ajuste na busca de férias de Janeiro pagas ±±
±±³            ³        ³                   ³em Dezembro p/ considerar na DIRF.         ±±
±±³Claudinei S.³03/02/17³MRH-6613 			³Ajuste em f550MontaDados() para que não   ³±±
±±³            ³        ³         			³duplique valores da dedução de dependentes³±±
±±³            ³        ³         			³de IR, na P12 essas verbas são gravadas na³±±
±±³            ³        ³         			³SRD como FOL e ADI gerando a duplicidade  ³±±
±±³Jônatas A.  ³10/02/17³MRH-6623           ³Ajuste na busca de verbas adicionais sobre ±±
±±³            ³        ³                   ³abono mês seguinte p/ tratar corretamente  ±±
±±³            ³        ³                   ³nas incidências "A" e "0" da DIRF.         ±±
±±³            ³        ³                   ³Validação da existência da associação das  ±±
±±³            ³        ³                   ³verbas mês->mês seguinte, e da verba de    ±±
±±³            ³        ³                   ³férias pagas mês anterior.                 ±±
±±³Jônatas A.  ³17/02/17³MRH-7222           ³Inclusão de tratamento p/ verbas de dif.   ±±
±±³            ³        ³                   ³férias sobre adicionais de abono pecuniário±±
±±³            ³        ³                   ³mês seguinte que não possuem id. cálculo.  ±±
±±³Jônatas A.  ³20/02/17³MRH-7231           ³Restringir mensagem de preenchimento dos   ±±
±±³            ³        ³                   ³campos RCS_NOMED e RCS_INMED p/ lançamentos±±
±±³            ³        ³                   ³do tipo reembolso.                         ±±
±±³Claudinei S.³03/02/17³MRH-7643 		    ³Ajuste para considerar o valor da pensao  ³±±
±±³            ³        ³         		    ³de 13º primeira parcela                   ³±±
±±³Evandro P.  ³09/10/17³MPRIMESP-9776 		³Ajuste para carregar valores de pensão    ³±±
±±³            ³        ³(Replica)		    ³alimentícia no arquivo magnético da DIRF  ³±±
±±³            ³        ³         			³quando funcionário foi demitido e depois  ³±±
±±³            ³        ³         			³readmitido com uma nova matricula .       ³±±
±±³Oswaldo L   ³30/10/17³DRHPAG-7555    	³Conforme solicitado, removido carga de    ³±±
±±³            ³        ³         			³dados de rateio ass.médica.               ³±±
±±³WinstonCosta³05/12/18³			    	³Preparando fonte para Automação (Robô)    ³±±
±±³WinstonCosta³03/01/19³			    	³Retirada do trecho que trata AS/400       ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function GPEM550()

Local aButtons	:= {}
Local bProcesso	:= {|oSelf| GPM550Processa(oSelf)}
Local nLimDirf	:= 0
Local nLDirf 	:= 0
Local nLimOut 	:= 0
Local nLOut		:= 0

Private cCadastro   := OemToAnsi(STR0001) //"Gera‡„o do Arquivo da D. I. R. F."
Private cSraFilter	:= ""
Private aRetFiltro	:= {}
Private aFilterExp	:= {}
Private lGestPubl 	:= IIF(ExistFunc("fUsaGFP"), fUsaGFP(), .F.)		//Verifica se utiliza o modulo de Gestao de Folha Publica - SIGAGFP

aRegs := {}

//Comunicado sobre a não disponibilização da Rais e Dirf para releases inferiores à 12.1.25
If GetRpoRelease() < "12.1.023" .AND. FindFunction("DirfRaisMsg") .AND. !lAutomato
	DirfRaisMsg()
EndIf

If FindFunction("GpProcVld")
	aAdd(aButtons,{STR0104,{|oSelf| GpProcVld(oSelf, .T.)}, "NG_ICO_VIS_ASP.PNG"}) //"Diagnóstico"
EndIf

Aadd(aButtons, { STR0152, {|| OpenTDN()}, "NORMAS.PNG" }) //"Documentação"

dbSelectArea("RCS")
If RCS->( ColumnPos("RCS_NOMED"))== 0
	Aviso(STR0015,STR0020,{"OK"})// "Atencao"#"Tabelas desatualizadas. Execute o atualizador"
	Return
EndIf

Pergunte("GPM550",.F.)

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Variaveis utilizadas para parametros                         ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ mv_par01 - Filial de                                         ³
//³ mv_par02 - Filial Ate                                        ³
//³ mv_par03 - Matricula de                                      ³
//³ mv_par04 - Matricula Ate                                     ³
//³ mv_par05 - Centralizar na Filial                             ³
//³ mv_par06 - Ano Base                                          ³
//³ mv_par07 - Gerar CPMF em outros rend. nao tributaveis        ³
//³ mv_par08 - Categorias a Gerar        						 ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
BEGIN SEQUENCE
	If (!lAutomato)
		// Pergunta para o usuário se ele deseja executar o diagnóstico da DIRF
		If (FuncAux())
			GpProcVld(NIL, .F.)
		EndIf

		// Inicializa os mnemônicos
		SetMnemonicos(NIL, NIL, .T.)
		nLimDirf := cValToChar(Int(P_VlLimDIRF))
		nLDirf   := Len(nLimDirf) + 3
		nLimOut  := cValToChar(Int(P_VlLimOut))
		nLOut    := Len(nLimOut) + 3

		// Informa ao usuário os valores dos mnemônicos P_VLLIMDIRF e P_VLLIMOUT e pergunta se ele deseja continuar a execução
		If (!MsgYesNo(OemToAnsi(STR0095) + CRLF; 																			// Mnemonicos
				+ OemToAnsi(StrTran(STR0090, "NVLLIMDIRF", "P_VLLIMDIRF")) + Left(STR(P_VlLimDIRF, nLDIRF, 2), 30) + CRLF;	// NVLLIMDIRF Limite Anual Decl. IRPF preenchido com R$
				+ OemToAnsi(StrTran(STR0091, "NVLLIMOUT", "P_VLLIMOUT"))   + Left(STR(P_VlLimOut,  nLOUT,  2), 30) + CRLF;	// NVLLIMOUT Limite Anual Outras Categorias preenchido com R$
				+ CRLF + OemToAnsi(STR0092) + CRLF; 																		// Estes 2 MnemOnicos definem o valor minimo dos rendimentos, a ser considerado para a geracao do arquivo da DIRF.
				+ OemToAnsi(STR0093) + CRLF; 																				// O primeiro para beneficiários de trabalho assalariado e o segundo para rendimentos sem vínculo empregatício.
				+ CRLF + OemToAnsi(STR0096); 																				// Caso queira modificar os valores, clique em Nao, e em seguida
				+ CRLF + OemToAnsi(STR0097) + CRLF;																			// va em Atualizacoes > Definicoes de Calculo > Mnemonicos
				+ CRLF + OemToAnsi(STR0094); 																				// Deseja Continuar?
				, OemToAnsi(STR0015))) 																						// Atencao
			BREAK
		EndIf
	EndIf

	If !lAutomato .or. FwIsInCallStack("FwBoSchdExecute")
		tNewProcess():New( "GPEM550", cCadastro, bProcesso , STR0002, "GPM550", aButtons, .T., , , .T., .T., .T.)
	Else
		Eval(bProcesso)
	Endif
END SEQUENCE
Return(Nil)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFuncao    ³GPM550ProcessaºAutor  ³Andreia Santos    º Data ³  09/01/06  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³                                                             º±±
±±º          ³                                                             º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                          º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function GPM550Processa(oSelf)
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Define Variaveis LOCAIS DO PROGRAMA                          ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Local cFilAnterior  := ''
Local cVerifAdt 	:= ''
Local cArqSRH		:= ''
Local cArqRCS		:= ''
Local cArqRHP		:= ''
Local cQueryAlias	:= ''
Local AliasPLS		:= ''
Local cPutFilAnt	:= cFilAnt
Local dDtpgRes 		:= CtoD('')
Local aAdt			:= {}
Local aDedDpSem 	:= {}
Local aDedDp13o 	:= {}
Local aDedDepend13 	:= {}
Local lLimpaTudo	:= .F.
Local nIndexRCS	    := 0
Local nPosPer 		:= 0
Local nX			:= 0
Local nLog			:= 0
Local lGpm550Gr		:= ExistBlock("GPM550GR")
Local aOldArea		:= GetArea()
Local cRpoRel		:= GetRpoRelease()
Local nRotFol		:= 0
Local nRot113		:= 0
Local nRot213		:= 0
Local nRot7			:= 0
Local aOfusca		:= If(FindFunction('ChkOfusca'), ChkOfusca(), { .T., .F. })//[2]Ofuscamento
Local aFldRel		:= Iif( aOfusca[2], FwProtectedDataUtil():UsrNoAccessFieldsInList( {"RA_NOME"} ), {} )
Local lOfusca		:= Len(aFldRel) > 0
Local cPdPLS		:= ""
Local cAnoMV6		:= cValToChar(Val(StrZero(MV_PAR06, 4))+1)
Local lSched        := FwIsInCallStack("FwBoSchdExecute")

// Variáveis para Controle de Dedução Simplificada
Private cPdBSADI010	:= ""
Private cPdBSFer016	:= ""
Private cPdBSFer100	:= ""

Private aTotRegs	:= Array(14)
Private aInfo		:= {}
Private aCodFol		:= {}   // Matriz com Codigo da folha
Private aBenef		:= {}
Private aPensao		:= {}
Private aPrevi		:= {}
Private aDependentes:= {}
Private aLog		:= {}
Private aLog2		:= {}
Private aLog3		:= {}
Private aTitle		:= {}
Private aVerba		:= {}
Private cInfOut		:= ''
Private cAliasRHS	:= "RHS"
Private cAliasRHP	:= "RHP"
Private cAliasSRD	:= GetNextAlias()
Private nOrdRGE		:= RetOrdem( "RGE", "RGE_FILIAL+RGE_MAT+DTOS(RGE_DATAIN)+RGE_TIPOCO" )	// Define ordem da tab. RGE (Hist. contrato)
Private nPRca1 		:= 0
Private nPRca2 		:= 0
Private nTotR		:= 0
Private cValidFil		:= fValidFil()
Private aValidFil		:= StrToArray(cValidFil,"/")

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Define Variaveis PRIVADAS BASICAS                            ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Private aCRA 	    := { STR0008,STR0009,STR0010 } //"Confirma"###"Redigita"###"Abandona"

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Define Variaveis PRIVADAS DO PROGRAMA                        ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Private cDescri		:= ""
Private cCodRet		:= ""
Private cCodRetRes	:= ""		// Qdo ha Historico de Contrato (RGE) para o Funcionario deve utilizar o CodRet do Contrato
Private aStruSRD  	:= SRD->( dbStruct() )
Private aRhsFields 	:= RHS->( dbStruct() )
Private aRhpFields  := RHP->( dbStruct() )
Private aRGE		:= {}
Private aFunc		:= {}
Private aInssFol	:= {}
Private aInssFer	:= {}
Private aAbono		:= {}
Private aDedInssF	:= {}
Private aCmplRRA 	:= {}
Private aPerAtual 	:= {}
Private aCodAboPec	:= {}
Private aAbMesSeg	:= {}
Private cChaveSRD	:= GetSx2Unico("SRD")
Private cFieldsSRD	:= ""
Private cFieldsRHS	:= ""
Private cFieldsRHP	:= ""
Private cOrderSRD   := "% " + SqlOrder(SRD->(IndexKey(RetOrdem( "SRD" , cChaveSRD )))) + " %"
Private cFilDe		:= mv_par01
Private cFilAte		:= mv_par02
Private cMatDe		:= mv_par03
Private cMatAte		:= mv_par04
Private cCentra		:= mv_par05
Private cAno		:= StrZero(MV_PAR06,4)
Private cDtPesqI    := StrZero(MV_PAR06 - 1 , 4 )+ "1201" //Usada na funcao CarSRD()
Private cDtPesqF    := Strzero(MV_PAR06 + 1 , 4 )+ "0131" //Usada na funcao CarSRD()
Private cDtPesIHist	:= StrZero(MV_PAR06     , 4) + "0101" //Usada na funcao BuscaAssBen(), BuscaCoRemb(), CarRHS(), CarRHP()
Private cDtPesFHist	:= StrZero(MV_PAR06     , 4) + "1231" //Usada na funcao BuscaAssBen(), BuscaCoRemb(), CarRHS(), CarRHP()
Private lCPMF		:= If( mv_par07== 1,.T.,.F.)
Private cCateg		:= mv_par08
Private nTamCpf		:= TamSX3("RA_CIC")[1]
Private nDel 		:= 0
Private lRedutor13	:= .F.
Private cAliasRAS	:= "SRDRHS"+cEmpAnt	// Variavel para armazenar o nome do arquivo de Rateio de Assistencia Medica
Private cAnoMesAb 	:= MesAno(dDataBase)
Private cRot132		:= ""

Private dPagBenef	:= CTOD("//")
Private	lDtIniPg   :=  SRQ->( FieldPos("RQ_DTINIPG" ) # 0 )
Private lTemCpoDFE  := SRQ->( FieldPos( "RQ_VERBDFE" ) # 0 )

Private aRotFol		:= fGetRotTipo("1")
Private aRot113		:= fGetRotTipo("5")
Private aRot213		:= fGetRotTipo("6")
Private cRotFol1	:= ""
Private cRot113 	:= ""
Private cRot213 	:= ""

Private aTransf	:= {}
Private cDescInsFer  	:= SuperGetMV("MV_DINSSFM", Nil, "S")
Private lDedSimplFer  	:= SuperGetMV("MV_DEDSMFE", Nil, .F.) // Considera Data de Pagamento das Férias na Dedução Simplificada
Private lSomSimplFer  	:= SuperGetMV("MV_SOMDEFE", Nil, .F.)  // Soma Dedução das Férias no valor da Dedução Simplifiada
Private aTabForn	:= {}
fCarrTab( @aTabForn, "S016", Nil)
fCarrTab( @aTabForn, "S017", Nil)

For nRotFol := 1 To Len(aRotFol)
	cRotFol1 += aRotFol[nRotFol]+ "/"
Next nRotFol

For nRot113 := 1 To Len(aRot113)
	cRot113  += aRot113[nRot113]+ "/"
Next nRot113

For nRot213 := 1 To Len(aRot213)
	cRot213  += aRot213[nRot213]+ "/"
Next nRot213

/*
For nRot7 := 1 To Len(aRot7)
	cRotFol7+=  aRot7[nRot7]
Next nRot7
*/


Default lGPE550GRV  := ExistBlock( "GPE550GRV" )

SM0->( dbSeek( cEmpant + cFilAnt ) )
If StrZero( MV_PAR06, 4 ) >= "2017" .And. cRpoRel < "12.1.016" .And. ( !ExistFunc( "RhContExt" ) .Or. !RhContExt( SM0->M0_CGC ) )
	Aviso( STR0015, STR0157, { "Ok" }, , )
	RestArea( aOldArea )
	Return
EndIf

aEval(aStruSRD	, { |aField| cFieldsSRD += aField[01] + ", "})
aEval(aRhsFields, { |aField| cFieldsRHS += aField[01] + ", "})
aEval(aRhpFields, { |aField| cFieldsRHP += aField[01] + ", "})

cFieldsSRD += "SRD.R_E_C_N_O_ "
cFieldsSRD := "% " + cFieldsSRD + " %"
cFieldsRHS += "RHS.R_E_C_N_O_ "
cFieldsRHS := "% " + cFieldsRHS + " %"
cFieldsRHP += "RHP.R_E_C_N_O_ "
cFieldsRHP := "% " + cFieldsRHP + " %"

SetMnemonicos(NIL,NIL,.T.)
aTotRegs 	:= {}
aTotRegs	:= Array(14)

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Eliminar na proxima versao.³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Private cArqCompl	:= "GPCMPL"+FwCodEmp("SRA")

nTempo := Seconds()

aFill(@aTotRegs, 0 )


//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³PE criado p/ alterar a gravacao dos registros gravados.                            ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lGPE550GRV
	ExecBlock( "GPE550GRV", .F., .F., { 0 } )
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Limpar o arquivo da DIRF                                     ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
LimpaDIRF(@lLimpaTudo)

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Filiais devem ser centralizadas na filial                    ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If cCentra # Space(FWGETTAMFILIAL)
	If !fInfo(@aInfo,cCentra)
		Return()
	Endif
	cCgc := aInfo[8]
Endif

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Cria indice para pesquisar ferias³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
CriaIndFer(@cArqSRH)

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Cria indice para pesquisar os registros das informacoes complementares ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
CriaIndComp(@cArqRCS, @nIndexRCS)

dbSelectArea( "SRA" )
dbSetOrder(1)

//Query para listagem dos funcionários
cQueryAlias := GetNextAlias()

cCatQuery := ""
For nX:=1 to Len(cCateg)
	cCatQuery += "'"+Subs(cCateg,nX,1)+"'"
	If ( nX+1 ) <= Len(cCateg)
		cCatQuery += ","
	EndIf
Next nX
cCatQuery := If(Empty(cCatQuery),"' '",cCatQuery)

cWhere := "%"
cWhere += " RA_FILIAL >= '" + cFilDe + "' AND "
cWhere += " RA_FILIAL <= '" + cFilAte + "' AND "
//insere filtro de acordo com direito de acesso do usuario

If Len(cValidFil) <= 2000
	cWhere += " RA_FILIAL IN ('' "
Else
	aValidFil := {}
	aValidFil	:= StrToArray(fValidFil(,.T.),"/")
	cWhere += " RA_FILIAL NOT IN ('' "
EndIf
For nX := 1 to Len(aValidFil)
	If aValidFil[nX] >= Alltrim(cFilDe) .AND. aValidFil[nX] <= Alltrim(cFilAte)
		cWhere += ", '" + aValidFil[nX] + "' "
	ElseIf aValidFil[nX] > AllTrim(cFilAte)
		Exit
	EndIf
Next nX

cWhere += ") AND "
cWhere += " RA_MAT >= '" + cMatDe + "' AND "
cWhere += " RA_MAT <= '" + cMatAte + "' AND "
cWhere += " RA_CATFUNC IN (" + Upper(cCatQuery) + ") "
cWhere += "%"

BeginSQL ALIAS cQueryAlias
	SELECT COUNT(*) AS CONTADOR FROM
	(SELECT RA_FILIAL, RA_MAT
	FROM %Table:SRA% SRA
	INNER JOIN %Table:SRD% SRD ON RD_FILIAL = RA_FILIAL AND RD_MAT = RA_MAT AND RD_DATPGT BETWEEN %exp:cDtPesqI% AND %exp:cDtPesqF% AND SRA.%NotDel%
	WHERE %exp:cWhere% AND SRA.%NotDel%
	UNION
	SELECT RA_FILIAL, RA_MAT
	FROM %Table:SRA% SRA
	INNER JOIN %Table:SRH% SRH ON RH_FILIAL = RA_FILIAL AND RH_MAT = RA_MAT AND RH_DTRECIB BETWEEN %exp:cDtPesqI% AND %exp:cDtPesqF% AND SRH.%NotDel%
	WHERE %exp:cWhere% AND SRA.%NotDel%
	GROUP BY RA_FILIAL, RA_MAT ) CONTADORA
EndSQL

If !lAutomato .or. lSched
If (cQueryAlias)->(!Eof())
	oSelf:SaveLog( STR0001+" - "+STR0036) //#"Início do processamento"
	oSelf:SetRegua1((cQueryAlias)->(CONTADOR))
EndIf
Endif

DbSelectArea(cQueryAlias)
DbCloseArea()

cQueryAlias := GetNextAlias()

BeginSQL ALIAS cQueryAlias
	SELECT RA_FILIAL, RA_MAT
	FROM %Table:SRA% SRA
	INNER JOIN %Table:SRD% SRD ON RD_FILIAL = RA_FILIAL AND RD_MAT = RA_MAT AND RD_DATPGT BETWEEN %exp:cDtPesqI% AND %exp:cDtPesqF% AND SRA.%NotDel%
	WHERE %exp:cWhere% AND SRA.%NotDel%
	UNION
	SELECT RA_FILIAL, RA_MAT
	FROM %Table:SRA% SRA
	INNER JOIN %Table:SRH% SRH ON RH_FILIAL = RA_FILIAL AND RH_MAT = RA_MAT AND RH_DTRECIB BETWEEN %exp:cDtPesqI% AND %exp:cDtPesqF% AND SRH.%NotDel%
	WHERE %exp:cWhere% AND SRA.%NotDel%
	GROUP BY RA_FILIAL, RA_MAT
	ORDER BY RA_FILIAL, RA_MAT
EndSQL

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Carrega os Filtros                                 	 	     ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
cSraFilter	  := GpFltAlsGet( aRetFiltro , "SRA" )
cFilAnterior  := Replicate("!", FWGETTAMFILIAL)

While (cQueryAlias)->(!Eof())

	SRA->(DbSeek((cQueryAlias)->(RA_FILIAL+RA_MAT))) //Posiciona no funcionário na SRA

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Movimenta cursor para movimentacao da barra                  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If !lAutomato .or. lSched
	oSelf:IncRegua1(STR0035+" : "+SRA->RA_FILIAL+" - "+SRA->RA_MAT+ If(lOfusca, "", " - "+SRA->RA_NOME) )//"Funcionário"
	Endif

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Aplicação do filtro na tabela SRA.       ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If !Empty( cSraFilter )
 		If !( &( cSraFilter ) )
			(cQueryAlias)->(dbSkip())
			Loop
 		EndIf
 	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Busca o periodo aberto atual                                 ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If aScan( aPerAtual, { |X| X[8] == SRA->RA_PROCES } ) == 0
		fGetPerAtual( aPerAtual,, SRA->RA_PROCES, fGetCalcRot('1'),lGestPubl )
		If ( nPosPer := aScan( aPerAtual, { |X| X[8] == SRA->RA_PROCES } ) ) > 0
			cAnoMesAb := aPerAtual[nPosPer,5] + aPerAtual[nPosPer,4]
		EndIf
	EndIf

	aCmplRRA := {}

	If SRA->RA_FILIAL # cFilAnterior
		cFilAnterior := SRA->RA_FILIAL
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Carrega Variaveis CODIGOS DA FOLHA                           ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If !FP_CODFOL(@aCodFol, xFilial('SRV', cFilAnterior))
			Exit
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Carrega Tabela de Fornecedores de Prev. Compl.
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		aTabS073 := {}
		fRetTab( @aTabS073, "S073", , , , , .T., , .T. )

		// Captura código Base IRRF Férias
		cPdBSFer016	:= Possrv(aCodFol[0016,1], xFilial('SRV', cFilAnterior), "RV_COD")
		cPdBSFer100 := Possrv(aCodFol[0100,1], xFilial('SRV', cFilAnterior), "RV_COD")
		// Captura código Base IRRF Adiantamento
		cPdBSADI010	:= Possrv(aCodFol[0010,1], xFilial('SRV', cFilAnterior), "RV_COD")

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Tratamento do Adto. Para Quem Paga Fora do Mes               ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		cVerifAdt := ""
		If POSSRV(aCodFol[006,1], xFilial('SRV', cFilAnterior), "RV_DIRF") == "A " .Or.;
		   POSSRV(aCodFol[007,1], xFilial('SRV', cFilAnterior), "RV_DIRF") == "A "
			cVerifAdt := "S"
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Carrega codigos de Abonos³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		BusCodAbo()

		If cCentra == Space(FWGETTAMFILIAL)
			If !fInfo(@aInfo,cFilAnterior)
				Exit
			EndIf
			cCgc := aInfo[8]
		Endif
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Faz leitura do RCA      ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		fLeRca()

		cRot132 := If(!lGestPubl,fGetCalcRot("6"), cRot213 )
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Limpa variaveis                                              ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	nDel 		:= 0
	cInfOut 	:= ''
	cCodRet 	:= If (SRA->RA_CODRET # Space(4), SRA->RA_CODRET, "0561")
	aRGE   		:= {}
	aFunc   	:= {}
	aInssFol	:= {}
	aInssFer	:= {}
	aDedDpSem 	:= {}
	aDedDp13o	:= {}
	aDedDepend13:= {}
	aAbono  	:= {}
	aDedInssF	:= {}
	lGravouAlgum:= .F.

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Delecao caso exista                                          ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	LimpaSR4(lLimpaTudo)

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Busca os dependentes do funcionario no SRB para ³
	//³montar o log com os maiores de 13 anos sem CPF  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	BuscaDepen(cAno)

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Busca os beneficiarios do funcionario no SRQ     ³
	//³para montar o array de Informacoes Complementares³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	BuscaBenef()

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Monta arrays de pensao e previdencia para gravar ³
	//³nas tabelas SM8 e SM9                            ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	aPensao	:= aClone(aBenef)
	aPrevi	:= MontaPrevi()

	If aTotRegs[7] > 0
		Exit
	EndIf

	AliasPLS := GetNextAlias()

	BeginSQL Alias AliasPLS
		SELECT DISTINCT RHS.RHS_PD
		FROM %Table:RHS% RHS
		WHERE RHS.RHS_FILIAL = %Exp:SRA->RA_FILIAL% AND
		RHS.RHS_MAT = %Exp:SRA->RA_MAT% AND
		(SUBSTRING(RHS.RHS_DATPGT,1,4) = %Exp:StrZero(MV_PAR06, 4)% OR
		(SUBSTRING(RHS.RHS_DATPGT,5,2) = '12' AND 	SUBSTRING(RHS.RHS_DATPGT,1,4) = %Exp:cAnoMV6% )) AND
		RHS.%NotDel%
		UNION
		SELECT DISTINCT RHP.RHP_PD
		FROM %Table:RHP% RHP
		WHERE RHP.RHP_FILIAL = %Exp:SRA->RA_FILIAL% AND
		RHP.RHP_MAT = %Exp:SRA->RA_MAT% AND
		(SUBSTRING(RHP.RHP_DATPGT, 1, 4) = %Exp:StrZero(MV_PAR06, 4)% OR
		(SUBSTRING(RHP.RHP_DATPGT, 5, 2) = '12' AND SUBSTRING(RHP.RHP_DATPGT, 1, 4) = %Exp:cAnoMV6% )) AND
		RHP.%NotDel%
	EndSQL

	If !(AliasPLS)->(Eof())
		(AliasPLS)->(dbEval({|| cPdPLS += (AliasPLS)->RHS_PD + "/" }))
	Else
		cPdPLS := "*"
	EndIf

	(AliasPLS)->(dbCloseArea())

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Buscar Valores no Acumulado "SRD"                          ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	BuscaAcuma(@aDedInssF, @aInssFol, @aInssFer, @aAdt, @aDedDpSem, @aDedDp13o, @aDedDepend13, @dDtPgRes, cVerifAdt, cPdPLS)

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Carrega tabela de rateio de plano de saude                  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	CarRHS()

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Realiza busca na tabela de historico RHS dos planos         ³
	//³de assistencia medica/odontologica			               ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	BuscaAssBen()

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Carrega tabela de co-participacao/reembolso dos planos      ³
	//³de assistencia medica/odontologica                          ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	CarRHP()

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Realiza busca na tabela de historico RHP de co-participacao ³
	//³/reembolso dos planos de assistencia medica/odontologica    ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	BuscaCoRemb()

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Verifica se tem algum funcionario de ferias em dezembro,    ³
	//³cujas férias serão pagas na folha de janeiro,  e a folha de ³
	//³janeiro ainda esta em aberto.                               ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	dbSelectArea("SRH")
	If SRH->( dbSeek( SRA->RA_FILIAL + SRA->RA_MAT ) )
		While SRH->( !Eof() ) .And. SRH->RH_FILIAL + SRH->RH_MAT == SRA->RA_FILIAL + SRA->RA_MAT
			If Year( SRH->RH_DTRECIB ) == MV_PAR06
				fBuscaFer_Res("F",,cPdPLS)
			EndIf
			SRH->( dbSkip() )
		EndDo
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Se o mês/Ano da demissão for igual a competência em aberto,     ³
	//³buscar nas tabelas de rescisão os valores para a DIRF.          ³
	//³Desta forma será possível gerar o informe de rendimentos para   ³
	//³funcionário demitido no mês, antes de fazer o fechamento mensal.³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If MesAno(SRA->RA_DEMISSA) >= cAnoMesAb
		fBuscaFer_Res("R",,cPdPLS)
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ABONO MES\MES SEGUINTE - TOTAL ISENTO (cod "0").	  		    ³
	//³Qdo funcionario tiver abono mes seguinte (id 074/079),  e  no³
	//³mesmo mes possuir a verba id 164 (ferias pagas), indica que  ³
	//³seu vlr foi considerado atraves das verbas id 205 e 206.     ³
	//³Sendo assim, deduzir seu vlr do total de isentos para nao    ³
	//³entrar em duplicidade e acresentar este valor no total de    ³
	//³rendimentos.												    ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	AbonoMesSeg( aAbono )

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Tratamento do Adiantamento gravando no mes de pagamento e deduzindo no mes          ³
	//³posterior quando a verba de adiantamento incide para IR, significando que a empresa ³
	//³paga a folha no mes seguinte ao mes de processamento.                               ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	GravaAdianta(aAdt, dDtPgRes)

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³GRAVACAO DA CPMF NA LETRA "I", OUTROS³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	GravaCPMF(aInssFol)

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Ponto de Entrada Informacoes Complementares DIRF³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If ( lGPE550ICD )
		/*/
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³O Ponto de Entrada GPE550ICD recebera como parametro o ParamIxb que eh um  ³
		³Array com um elemento,sendo um Clone do Array aBenef.                      ³
		³													  						³
		³Para Visualiza-lo no Ponto de Entrada proceder da seguinte forma:			³
		³															  				³
		³User Function GPE550ICD()									  				³
		³															  				³
		³Local __aBenef := aClone( ParamIxb[1] )				  			        ³
		³...															  			³
		³Return( aClone( __aBenef ) )				  				  	     		³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
		uRetBlock := ExecBlock( "GPE550ICD", .F., .F., { aClone(aBenef) } )
		If ( ValType( uRetBlock ) == "A" )
			aBenef := aClone( uRetBlock )
		EndIf
	EndIf

    aAdt	 := {}
    dDtpgRes := CtoD("")
	If lGravouAlgum
		cFilAnt	:= SRA->RA_FILIAL
		If !Empty( SRA->RA_CIC ) .Or.;
		 (Empty( SRA->RA_CIC )  .And. SRA->RA_NATURAL == 'EX' .And. SRA->RA_CATFUNC == "A")
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Gravar Cabe‡alho da Dirf/informe³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			FGravaSRL(aInfo)

			If Len(aCmplRRA) > 0
				fGravaRFI(aInfo)
			EndIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Gravar Valores por mes de pagamento³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			GravaSR4(SRA->RA_FILIAL, SRA->RA_MAT, SRA->RA_CIC, cCodRet, aFunc, cAno, aInfo)

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Gravar Beneficiarios e informacoes complementares³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			FGravaInf( SRA->RA_FILIAL, SRA->RA_MAT, SRA->RA_CIC, If(Empty(cCodRetRes),cCodRet,cCodRetRes), cAno, aBenef, nIndexRCS, aPensao)
			cInfOut 	:= ''

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Gravar outros valores na DIRF      ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If lGpm550Gr
				ExecBlock("GPM550GR",.F.,.F.)
			EndIf
	    Else
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Funcionário sem CPF cadastrado.    ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If aTotRegs[1] == 0
				aAdd(aTitle, STR0026) //"Funcionário sem CPF cadastrado."
				aAdd(aLog,{})
				aTotRegs[1] := Len(aLog)
			EndIf
			aAdd(aLog[aTotRegs[1]], SRA->RA_FILIAL+"-"+SRA->RA_MAT+ Space(02)+ If(lOfusca, Replicate('*',15), SRA->RA_NOME) )
		EndIf
		cFilAnt := cPutFilAnt
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Fecha Temporários                                           ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	dbSelectArea(cAliasSRD)
	dbCloseArea()

	DbSelectArea(cAliasRHS)
	DbCloseArea()

	DbSelectArea(cAliasRHP)
	DbCloseArea()

	(cQueryAlias)->(DbSkip())
EndDo

DbSelectArea(cQueryAlias)
DbCloseArea()

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Arquivo gerado com sucesso!        ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If aTotRegs[1] == 0 .and. aTotRegs[2] == 0 .and. aTotRegs[4] == 0 .and. aTotRegs[05]==0 .and. ;
   aTotRegs[6] == 0 .and. aTotRegs[7] == 0 .and. aTotRegs[8] == 0 .and. aTotRegs[10]==0	 .and. aTotRegs[14]==0
	If aTotRegs[9] == 0
		aAdd(aTitle, STR0027) //"Arquivo gerado com sucesso!"
		aAdd(aLog,{})
		aTotRegs[9] := Len(aLog)
	EndIf
	aAdd(aLog[aTotRegs[9]], STR0028 ) //"Não foi encontrada nenhuma inconsistência durante a geração."
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Informações para gerar a DIRF      ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If aTotRegs[3] == 0
	aAdd(aTitle, STR0029) //"Informações para gerar a DIRF."
	aAdd(aLog,{})
	aTotRegs[3] := Len(aLog)
EndIf

aAdd(aLog[aTotRegs[3]], STR0030 )//"Para obter informações detalhadas de como proceder para configurar a DIRF, consulte"
aAdd(aLog[aTotRegs[3]], STR0031 )//"o Boletim Técnico que se encontra no Portal do Cliente para download."

Aadd(aLog,{})
nTotR := Len(aLog)
For nLog = 1 To Len(aLog2)
	Aadd(aLog,{})
	Aadd(aLog[len(aLog)],aLog2[nLog,1])
Next nLog

For nLog = 1 To Len(aLog3)
	Aadd(aLog[len(aLog)],aLog3[nLog])
Next nLog

If Len(aLog3) > 0
	Aadd(aLog[Len(aLog)],STR0158) // # Verifique boletim: http://tdn.totvs.com/x/aq_cEw (Atualizações e Pacotes Disponíveis DIRF). #
Endif

If !lAutomato .or. lSched
oSelf:SaveLog( STR0001+" - "+STR0037)// #"Termino do processamento"
Endif

fMakeLog(aLog,aTitle,,,"DIRF"+cAno,STR0032,"M","P",,.F.) //"Log de ocorrências da DIRF"

If File(cArqSRH+OrdBagExt())
   fErase(cArqSRH+OrdBagExt())
EndIf
SRH->( retIndex() )
RHP->( 1 )
RCS->( 1 )

Return(Nil)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFuncao    ³GravaSR4  ºAutor  ³Microsiga           º Data ³  01/19/05   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³                                                            º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function GravaSR4( cFil, cMat, cCic, cRet, aFunc, cAno )
Local aArea		:= GetArea()
Local aAreaSRL	:= SRL->( GetArea() )
Local nf		:= 1
Local cChave	:= ""
Local cChaveAux	:= ""
Local cAteMes	:= ""
Local cCodPLR	:= "3562"
Local cMesAnt	:= ""
Local cPais		:= ""
Local cNif		:= ""
Local cTipoFJ	:= ""
Local lPagouPLR := .F.
Local aDedApos	:= aClone(aFunc) //GFP
Local nPos		:= 0			//GFP
Local nMesesRRA := 0

Default lGPE550GRV := ExistBlock( "GPE550GRV" )

DbSelectArea('RFC')
DbSetOrder(RetOrder('RFC','RFC_FILIAL+RFC_MAT+RFC_IDCMPL+RFC_PD+RFC_CC+RFC_DATARQ+RFC_SEQ'))

cChaveAux := cFil + cMat + cCic + If(nTamCpf == 11,Space(3)+ cRet + cAno, cRet + cAno )

If Len(aFunc) > 0
	For nf	:= 1 To Len(aFunc)
		If !Empty(aFunc[nf,2])
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Antes de gravar verifica a existencia do contrato.			 ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If Type("SRL->RL_NEMPR") # 'U' .and. cMesAnt # aFunc[nf,1]

				cMesAnt := aFunc[nf,1]				// Atualiza mes anterior para evitar pesquisas do mesmo mes varias vezes
				RGE->( dbSetOrder( nOrdRGE ) )		// RGE_FILIAL+RGE_MAT+DTOS(RGE_DATAIN)+RGE_TIPOCO
				If RGE->( dbSeek( xFilial( "RGE" ) + SRA->RA_MAT ) )	// Verifica se ha algum contrato para o funcionario
					If Empty( cCodRetRes ) .or. aFunc[nf,1] > cAteMes
						cCodRetRes	:= ""
						cPais		:= ""
						cNif		:= ""
						While RGE->(!Eof()) .and. (RGE->(RGE_FILIAL+RGE_MAT) == SRA->(RA_FILIAL+RA_MAT))

							// Verifica Data do Contrato em relacao ao mes de pagamento
							If ( AnoMes( RGE->RGE_DATAIN ) > aFunc[nf,7] ) .or.;
							   ( ! Empty( RGE->RGE_DATAFI ) .and. AnoMes( RGE->RGE_DATAFI ) < aFunc[nf,7] )
								RGE->( dbSkip() )
								Loop
							EndIf

							If Empty(RGE->RGE_CODRET)
								RGE->( DbSkip() )
								Loop
							Endif

							//Guarda os dados do contrato para posterior utilizacao na geracao de informacoes complementares
							aAdd( aRGE, { RGE->RGE_CODRET, AnoMes( RGE->RGE_DATAIN ), AnoMes(RGE->RGE_DATAFI) } )

							cCodRetRes	:= RGE->RGE_CODRET
							cAteMes		:= If(Empty(RGE->RGE_DATAFI),"12",If( Month(RGE->RGE_DATAFI)==1,StrZero(Month(RGE->RGE_DATAFI),2),StrZero(Month(MonthSub(RGE->RGE_DATAFI,1)),2)))
							cPais		:= RGE->RGE_CODPAI
							cNif		:= RGE->RGE_CODNIF
							RGE->( dbSkip() )
						EndDo
					EndIf
				Else
					cCodRetRes	:= ""
					cAteMes		:= ""
					cPais		:= ""
					cNif		:= ""
				EndIf
			EndIf

			If aFunc[nf,2] $ "C3*O1*Q1"
				cChaveAux	:= cFil + cMat + cCic + If(nTamCpf == 11,Space(3) + cCodPLR + cAno, cCodPLR + cAno)
				cChave		:= cChaveAux + aFunc[nf,1] + aFunc[nf,2] + cPais + cNif
			Else
				cChaveAux	:= cFil + cMat + cCic + If(nTamCpf == 11,Space(3) + If(Empty(cCodRetRes),cRet,cCodRetRes) + cAno,;
									If(Empty(cCodRetRes),cRet,cCodRetRes) + cAno)
				cChave		:= cChaveAux + aFunc[nf,1] + aFunc[nf,2] + cPais + cNif
			EndIf

			// Trata abatimento das verbas configuradas como F - GFP
			If lGestPubl .AND. aFunc[nf,2] $ "A "
				nPos :=  ASCAN(aDedApos,{|x| x[1] == aFunc[nf,1] .And.  x[2] == "F "  })
				If nPos > 0
					aFunc[nf,3] -= aDedApos[nPos,3]
				EndIf
			EndIf

			dbSelectArea("SR4")
			SR4->( dbSetOrder( 1 ) )		// R4_FILIAL+R4_MAT+R4_CPFCGC+R4_CODRET+R4_ANO+R4_MES+R4_TIPOREN+R4_PAIS+R4_NIFEX
			If SR4->( dbSeek( cChave ) )
				RecLock("SR4",.F.)
			Else
				RecLock("SR4",.T.)
			Endif

			SR4->R4_FILIAL  := cFil
			SR4->R4_MAT     := cMat
			SR4->R4_CPFCGC  := cCic
			SR4->R4_MES     := aFunc[nf,1]
			SR4->R4_TIPOREN := aFunc[nf,2]
			If aFunc[nf,2] $ "C3*O1*Q1"
				lPagouPLR		:= .T.
				SR4->R4_CODRET 	:= cCodPLR
			Else
				SR4->R4_CODRET  := If( Empty( cCodRetRes ), cRet, cCodRetRes )
			EndIf
			SR4->R4_VALOR   := Max( aFunc[nf,3], 0 )
			SR4->R4_ANO		:= cAno
			SR4->R4_ORIGEM := "1"
			If SR4->R4_CODRET <> cCodPLR
				SR4->R4_PAIS := cPais
			Endif
			SR4->R4_NIFEX := cNif
			SR4->R4_DTPGT := aFunc[nf,4]

			If !Empty(aFunc[nF,5])
				SR4->R4_IDCMPL := aFunc[nF,5]
				If RFC->(DbSeek(cFil+cMat+aFunc[nF,5]+aFunc[nF,6]))
					nMesesRRA := fMesesRRA(RFC->RFC_FILIAL, RFC->RFC_MAT, RFC->RFC_IDCMPL, RFC->RFC_DATARQ)
					SR4->R4_MESES := nMesesRRA
				EndIf
			EndIf

			SR4->( MsUnLock() )
		EndIf
	Next nf

	//PE criado p/ alterar a gravacao dos registros gravados.
	If lGPE550GRV
		ExecBlock( "GPE550GRV", .F., .F., { 2 } )
	EndIf

Endif

If lPagouPLR
	cTipoFJ	:= If( Len(AllTrim(cCic)) > 11, "2","1")
	cChave	:= cFil + cMat + cTipoFJ + cCic + If( nTamCPF == 11, space(03) + cCodPLR, cCodPLR )

	dbSelectArea("SRL")
	SRL->( dbSetOrder( 1 ) )	// RL_FILIAL+RL_MAT+RL_TIPOFJ+RL_CPFCGC+RL_CODRET+RL_PAIS+RL_NIFEX

	If SRL->( dbSeek( cChave ) )
		RecLock("SRL",.F.)
	Else
		RecLock("SRL",.T.)
	Endif

	SRL->RL_FILIAL	:= cFil
	SRL->RL_MAT		:= cMat
	SRL->RL_TIPOFJ	:= cTipoFJ
	SRL->RL_CGCFONT	:= aInfo[8]
	SRL->RL_CODRET	:= cCodPLR
	SRL->RL_CPFCGC	:= cCic

	If !Empty(SRA->RA_NOMECMP) .And. Len(AllTrim(SRA->RA_NOMECMP)) <= 60
		SRL->RL_BENEFIC	:= SRA->RA_NOMECMP
	Else
		SRL->RL_BENEFIC	:= SRA->RA_NOME
	EndIf

	SRL->RL_NOMFONT	:= aInfo[3]
	SRL->RL_ENDBENE	:= SRA->RA_ENDEREC
	SRL->RL_UFBENEF	:= SRA->RA_ESTADO
	SRL->RL_CC	:= SRA->RA_CC
	SRL->RL_ORIGEM := "1"
	SRL->RL_DEPTO := SRA->RA_DEPTO
	SRL->( MsUnlock() )
EndIf

RestArea( aArea )
RestArea( aAreaSRL )

Return(Nil)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFuncao    ³FGravaSRL ºAutor  ³Microsiga           º Data ³  01/19/05   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Grava no Arquivo de Cabecalho da DIRF/INFORME			  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function FGravaSRL(aInfo)
Local cTipoFJ	:= ""
Local cChave	:= ""
Local aArea		:= GetArea()

Default lGPE550GRV := ExistBlock( "GPE550GRV" )

cTipoFJ	:= If( Len(AllTrim(SRA->RA_CIC)) > 11, "2","1")
cChave	:= SRA->(RA_FILIAL+RA_MAT) + cTipoFJ + SRA->RA_CIC + If( nTamCPF == 11, space(03) + cCodRet, cCodRet )

Begin Transaction
	// Grava Cabecalho da DIRF/INFORME
	dbSelectArea("SRL")
	SRL->( DbSetOrder( 1 ) )	// RL_FILIAL+RL_MAT+RL_TIPOFJ+RL_CPFCGC+RL_CODRET+RL_PAIS+RL_NIFEX

	If SRL->( dbSeek( cChave ) )
		RecLock("SRL",.F.)
	Else
		RecLock("SRL",.T.)
	Endif

	SRL->RL_FILIAL	:= SRA->RA_FILIAL
	SRL->RL_MAT		:= SRA->RA_MAT
	SRL->RL_TIPOFJ	:= cTipoFJ
	SRL->RL_CGCFONT	:= aInfo[8]
	SRL->RL_CODRET	:= cCodRet
	SRL->RL_CPFCGC	:= SRA->RA_CIC

	If !Empty(SRA->RA_NOMECMP) .And. Len(AllTrim(SRA->RA_NOMECMP)) <= 60
		SRL->RL_BENEFIC	:= SRA->RA_NOMECMP
	Else
		SRL->RL_BENEFIC	:= SRA->RA_NOME
	EndIf

	SRL->RL_NOMFONT	:= aInfo[3]
	SRL->RL_ENDBENE	:= SRA->RA_ENDEREC
	SRL->RL_UFBENEF	:= SRA->RA_ESTADO
	SRL->RL_CC	:= SRA->RA_CC
	SRL->RL_ORIGEM := "1"
	SRL->RL_DEPTO := SRA->RA_DEPTO
	SRL->RL_PAIS	:= ""

	SRL->( MsUnlock() )

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica a existencia do primeiro campo de Residente Exterior ³
	//³ Caso exista, pesquisar se ha contrato para o funcionario e ve-³
	//³ rificar data inicio e fim do contrato para definir a gravacao.³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If Type("SRL->RL_NEMPR") # 'U'
		DbSelectArea( "RGE" )
		RGE->( DbSetOrder( nOrdRGE ) )						// RGE_FILIAL+RGE_MAT+DTOS(RGE_DATAIN)+RGE_TIPOCO
		RGE->( DbSeek( xFilial( "RGE" ) + SRA->RA_MAT ) )	// Verifica se ha algum contrato para o funcionario
		While RGE->( ! Eof() ) .and. ( RGE->(RGE_FILIAL + RGE_MAT) == SRA->(RA_FILIAL + RA_MAT) )

			// Despreza se o Contrato for anterior ao Ano da Dirf
			If ! Empty( RGE->RGE_DATAFI ) .and. StrZero( Year( RGE->RGE_DATAFI ), 4 ) < cAno
				RGE->( DbSkip() )
				Loop
			EndIf

			// Se o funcionario estiver fora o ano todo APAGA o registro gravado acima e cria um novo com os dados do contrato
			If AnoMes( RGE->RGE_DATAIN ) <= cAno + "01" .and. ( Empty( RGE->RGE_DATAFI ) .or. ;
															   ( ! Empty( RGE->RGE_DATAFI ) .and. AnoMes( RGE->RGE_DATAFI ) >= cAno+"12") );
															   .and. !Empty(RGE->RGE_CODRET)
				SRL->( RecLock( "SRL", .F., .T. ) )
				SRL->( dbDelete() )
				SRL->( MsUnlock() )
			EndIf

			If Empty(RGE->RGE_CODRET)
				RGE->( DbSkip() )
				Loop
			Endif

			// Carrega a Var referente ao CodRet do Funcionario com Historico de Contrato
			cCodRetRes := RGE->RGE_CODRET

			cChave := SRA->(RA_FILIAL+RA_MAT) + cTipoFJ + SRA->RA_CIC + If(nTamCPF==11,space(03) + RGE->(RGE_CODRET+RGE_CODPAI+RGE_CODNIF),;
						RGE->(RGE_CODRET+RGE_CODPAI+RGE_CODNIF))

			dbSelectArea("SRL")
			SRL->( DbSetOrder( 1 ) )		// RL_FILIAL+RL_MAT+RL_TIPOFJ+RL_CPFCGC+RL_CODRET+RL_PAIS+RL_NIFEX

			If SRL->( dbSeek( cChave ) )
				RecLock( "SRL", .F. )		// Caso as informacoes sejam compativeis apenas completa o registro
			Else
				RecLock( "SRL", .T. )		// Se nao forem compativeis deve ser gravado um novo registro completo

				SRL->RL_FILIAL	:= SRA->RA_FILIAL
				SRL->RL_MAT		:= SRA->RA_MAT
				SRL->RL_TIPOFJ	:= cTipoFJ
				SRL->RL_CGCFONT	:= aInfo[8]
				SRL->RL_CPFCGC	:= SRA->RA_CIC

				If !Empty(SRA->RA_NOMECMP) .And. Len(AllTrim(SRA->RA_NOMECMP)) <= 60
					SRL->RL_BENEFIC	:= SRA->RA_NOMECMP
				Else
					SRL->RL_BENEFIC	:= SRA->RA_NOME
				EndIf

				SRL->RL_NOMFONT	:= aInfo[3]
				SRL->RL_ENDBENE	:= SRA->RA_ENDEREC
				SRL->RL_UFBENEF	:= SRA->RA_ESTADO
				SRL->RL_CC	    := SRA->RA_CC
				SRL->RL_ORIGEM := "1"
			Endif

			SRL->RL_CODRET	:= RGE->RGE_CODRET
			SRL->RL_CGCEX	:= RGE->RGE_CNPJ
			SRL->RL_NEMPR	:= RGE->RGE_NOMEMP
			SRL->RL_TPCON	:= RGE->RGE_TIPOCO
			SRL->RL_DTINI	:= RGE->RGE_DATAIN
			SRL->RL_DTFIM	:= RGE->RGE_DATAFI
			SRL->RL_PAIS	:= RGE->RGE_CODPAI
			SRL->RL_NIFEX	:= RGE->RGE_CODNIF
			SRL->RL_LOGEX	:= RGE->RGE_LOGRAD
			SRL->RL_NUMEX	:= RGE->RGE_NUMERO
			SRL->RL_COMPL	:= RGE->RGE_COMPL
			SRL->RL_BAIEX	:= RGE->RGE_BAIRRO
			SRL->RL_POSEX	:= RGE->RGE_CODPOS
			SRL->RL_CIDEX	:= RGE->RGE_CIDADE
			SRL->RL_ESTEX	:= RGE->RGE_ESTPRO
			SRL->RL_TELEX	:= RGE->RGE_TELEFO
			SRL->RL_BREEX	:= RGE->RGE_BENREN
			SRL->RL_TPREX	:= RGE->RGE_TIPREN
			SRL->RL_TRBEX	:= RGE->RGE_FRMTRB
			SRL->RL_BEDINI	:= RGE->RGE_BEDINI
			SRL->RL_PAEXNI	:= RGE->RGE_PAEXNI

			SRL->( MsUnLock() )

			DbSelectArea( "RGE" )
			RGE->( DbSkip() )
		EndDo
	Endif

End Transaction

RestArea( aArea )
Return(Nil)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFuncao    ³FGravaRFI ºAutor  ³Leandro Drumond     º Data ³  06/07/12   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Grava no Arquivo de Cabecalho da DIRF/RRA    			  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ GPEM050                                                    º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function FGravaRFI(aInfo)
Local aArea		:= GetArea()
Local cTipoFJ	:= ""
Local cChave	:= ""
Local nX		:= 0

cTipoFJ	:= If( Len(AllTrim(SRA->RA_CIC)) > 11, "2","1")

For nX := 1 to Len(aCmplRRA)

	cChave	:= SRA->(RA_FILIAL+RA_MAT) + aCmplRRA[nX]

	Begin Transaction
		// Grava Cabecalho da DIRF/INFORME
		dbSelectArea("RFI")
		RFI->( dbSetOrder( 1 ) )	// RFI_FILIAL+RFI_MAT+RFI_IDCMPL

		If RFI->( dbSeek( cChave ) )
			RecLock("RFI",.F.)
		Else
			RecLock("RFI",.T.)
		Endif

		RFI->RFI_FILIAL	:= SRA->RA_FILIAL
		RFI->RFI_MAT	:= SRA->RA_MAT
		RFI->RFI_TIPOFJ	:= cTipoFJ
		RFI->RFI_CODRET	:= cCodRet
		RFI->RFI_CPFCGC	:= SRA->RA_CIC
		RFI->RFI_RETRRA	:= "1889"
		RFI->RFI_ORIGEM := "1"
		RFI->RFI_IDCMPL	:= aCmplRRA[nX]
		RFI->RFI_DESCRR	:= Posicione("RF1",1,xFilial("RF1")+aCmplRRA[nX],"RF1_DESC")

		SRL->( MsUnlock() )

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Verifica a existencia do primeiro campo de Residente Exterior ³
		//³ Caso exista, pesquisar se ha contrato para o funcionario e ve-³
		//³ rificar data inicio e fim do contrato para definir a gravacao.³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If Type("SRL->RL_NEMPR") # 'U'
			dbSelectArea( "RGE" )
			RGE->( dbSetOrder( nOrdRGE ) )						// RGE_FILIAL+RGE_MAT+DTOS(RGE_DATAIN)+RGE_TIPOCO
			RGE->( dbSeek( xFilial( "RGE" ) + SRA->RA_MAT ) )	// Verifica se ha algum contrato para o funcionario
			While RGE->( ! Eof() ) .and. ( RGE->(RGE_FILIAL + RGE_MAT) == SRA->(RA_FILIAL + RA_MAT) )

				// Despreza se o Contrato for anterior ao Ano da Dirf
				If ! Empty( RGE->RGE_DATAFI ) .and. StrZero( Year( RGE->RGE_DATAFI ), 4 ) < cAno
					RGE->( DbSkip() )
					Loop
				EndIf

				// Se o funcionario estiver fora o ano todo APAGA o registro gravado acima e cria um novo com os dados do contrato
				If AnoMes( RGE->RGE_DATAIN ) <= cAno + "01" .and. ( Empty( RGE->RGE_DATAFI ) .or. ;
																   ( ! Empty( RGE->RGE_DATAFI ) .and. AnoMes( RGE->RGE_DATAFI ) >= cAno+"12") )
					RFI->( RecLock( "RFI", .F., .T. ) )
					RFI->( dbDelete() )
					RFI->( MsUnlock() )
				EndIf

				// Carrega a Var referente ao CodRet do Funcionario com Historico de Contrato
				cCodRetRes := RGE->RGE_CODRET

				cChave := SRA->(RA_FILIAL+RA_MAT) + aCmplRRA[nX]

				dbSelectArea("RFI")
				RFI->( dbSetOrder( 1 ) )		// RFI_FILIAL+RFI_MAT+RFI_IDCMPL

				If RFI->( dbSeek( cChave ) )
					RecLock( "RFI", .F. )		// Caso as informacoes sejam compativeis apenas completa o registro
				Else
					RecLock( "RFI", .T. )		// Se nao forem compativeis deve ser gravado um novo registro completo

					RFI->RFI_FILIAL	:= SRA->RA_FILIAL
					RFI->RFI_MAT	:= SRA->RA_MAT
					RFI->RFI_TIPOFJ	:= cTipoFJ
					RFI->RFI_CPFCGC	:= SRA->RA_CIC
					RFI->RFI_RETRRA	:= "1889"
					RFI->RFI_ORIGEM := "1"
				EndIf

				RFI->RFI_CODRET	:= RGE->RGE_CODRET
				RFI->RFI_PAIS	:= RGE->RGE_CODPAI
				RFI->RFI_NIFEX	:= RGE->RGE_CODNIF
				RFI->RFI_IDCMPL	:= aCmplRRA[nX]
				RFI->RFI_DESCRR	:= Posicione("RF1",1,xFilial("RF1")+aCmplRRA[nX],"RF1_DESC")

				RFI->( MsUnLock() )

				DbSelectArea( "RGE" )
				RGE->( DbSkip() )
			EndDo
		EndIf

	End Transaction
Next nX

RestArea( aArea )

Return(Nil)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFuncao    ³GravaFun  ºAutor  ³Microsiga           º Data ³  01/19/05   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Guarda os valores dos funcionarios, com suas incidencias,  º±±
±±º          ³ no array afunc, para posterior gravação no SR4.            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function GravaFun( cMesPag, cTipDirf, nVal, dDtPagto, cIdCmpl, cPd, cCompet)
Local nPos		:= 0

DEFAULT cIdCmpl := ''
DEFAULT cPd		:= ''
DEFAULT cCompet := ''

If !Empty(cIdCmpl) .and. aScan(aCmplRRA,{ |x| x == cIdCmpl } ) == 0
	aAdd(aCmplRRA , cIdCmpl)
EndIf

If cAno < "2016" .Or. (cAno >= "2016" .and. !(Padr(cTipDirf,2) $ "C xC1xC2xC3x8 x81xM2xM5xM xM1x9Dx9Ax9 x91xM6xM7x9Ex9Fx9Bx9CxM3xM4" ))
	nPos := Ascan(aFunc,{ |x| x[1] = cMespag .And. x[2] == PADR(cTipDirf,2)})

	If nPos > 0
		If cAno >= "2023" .And. Padr(cTipDirf,2) $ "B4"
			// Sempre mantenho o registro do tipo B4 com a maior data de pagamento
			If dDtPagto >= aFunc[nPos][4]
				aFunc[nPos][4] := dDtPagto
			EndIf
		Else
			// Garante que só irá existir o conteúdo de 1 verba do tipo B5
			If !(cAno >= "2023" .And. Padr(cTipDirf,2) $ "B5")
				aFunc[nPos,3] += nVal
			EndIf
		EndIf
	Else
		Aadd( aFunc, { cMesPag, PADR( cTipDirf, 2 ), nVal, dDtPagto, cIdCmpl, cPd, cCompet} )
	Endif
EndIf

Return()

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFuncao    ³FGravaInf ºAutor  ³Andreia dos Santos  º Data ³  01/23/02   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Grava as informacoes complementares e os beneficiarios no   º±±
±±º          ³arquivo GPECOMPL                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP5                                                        º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function FGravaInf( cFil, cMatricula, cCPF, cCodRet, cAno, aBenef, nIndexRCS, aPensao )
Local aOldArea 	:= GetArea()
Local aPenSM8	:= {}
Local cChave	:= ""
local cChaveM8	:= ""
Local cCNPJFAss	:= ""
Local cDescri	:= ""
Local cNomeForn	:= ""
Local cOutros	:= ""
Local cTipDirf 	:= ""
Local cTipoFj	:= ""
Local cVerba	:= ""
Local cNewCodRet:= ""
Local lGrvOutr	:= .F.
Local lIncluir	:= .T.
Local lRec 		:= .T.
Local lCodBen	:= .F.
Local nPos		:= 0
Local nX 		:= 1
Local nY		:= 1
Local nPosPens	:= 0
Local cCodPLR	:= "3562"
Local cCPFCGC	:= ""
Local cCPFBen	:= ""
Local cCodRGE	:= ""
Local nLimDesc	:= TamSX3("RCS_DESCRI")[1] - 27

Default lGPE550GRV := ExistBlock( "GPE550GRV" )

cTipoFJ := If( Len(AllTrim(SRA->RA_CIC)) > 11, "2","1")

//Tratamento para quando houver desconto de plano de saude para dependentes e nao houver desconto do titular
//adiciona um registro para o titular com o valor zerado referente o plano de saude.
For nX  := 1 to len(aBenef)
	If aBenef[nX, 11] == "R"
		If SubStr( aBenef[nX, 16], 1, 4 ) $ "CMED*FMED*EMED*PMED*OMED*AMED" .Or. SubStr( aBenef[nX, 16], 1, 13 ) == "TMEDREEMBOLSO"
			If aScan(aBenef,{ |x| x[16] == "TMED" .And. x[2] == aBenef[nX, 2] .And. x[11] == "R" } ) == 0
				cCNPJFAss := aBenef[nX,02]
				cNomeForn := AllTrim( fPosTab( "S016",cCNPJFAss,"=",6,,,,5 ) )
				cDescri := "ASSISTENCIA MEDICA"
				cDescri += Space( 30 - Len( "ASSISTENCIA MEDICA" ) ) + " - TITULAR - "
				cDescri += cNomeForn
				cDescri := If( Len(cDescri) > nLimDesc, PadR(cDescri, nLimDesc), cDescri ) + " - CNPJ: " + Transform(cCNPJFAss, "@R ##.###.###/####-##")
				aAdd(aBenef,{cDescri,cCNPJFAss,"","","","","","",0.00,"MED","R","",.F.,"","","TMED"})
			EndIf
		ElseIf SubStr( aBenef[nX, 16], 1, 4 ) $ "CODO*FODO*EODO*PODO*OODO*AODO" .Or. SubStr( aBenef[nX, 16], 1, 13 ) == "TODOREEMBOLSO"
			If aScan(aBenef,{ |x| x[16] == "TODO" .And. x[2] == aBenef[nX, 2] .And. x[11] == "R" } ) == 0
				cCNPJFAss := aBenef[nX,02]
				cNomeForn := AllTrim( fPosTab( "S017",cCNPJFAss,"=",6,,,,5 ) )
				cDescri := "ASSISTENCIA ODONTOLOGICA"
				cDescri += Space( 30 - Len( "ASSISTENCIA ODONTOLOGICA" ) ) + " - TITULAR - "
				cDescri += cNomeForn
				cDescri := If( Len(cDescri) > nLimDesc, PadR(cDescri, nLimDesc), cDescri ) + " - CNPJ: " + Transform(cCNPJFAss, "@R ##.###.###/####-##")
				aAdd(aBenef,{cDescri,cCNPJFAss,"","","","","","",0.00,"ODO","R","",.F.,"","","TODO"})
			EndIf
		EndIf
	EndIf
Next

dbSelectArea("RCS")
dbSetOrder( nIndexRCS )

For nX  := 1 to len(aBenef)
	If (aBenef[nX,09] <> 0  .OR. aBenef[nX,11] =="I" )  .or. ;
		( aBenef[nX,09] == 0  .AND. aBenef[nX,11] =="R")

		If empty(aBenef[nX,3])	.and. empty(aBenef[nX,4]) .and. 	;
			empty(aBenef[nX,5])	.and. empty(aBenef[nX,6]) .and.	;
			empty(aBenef[nX,7])	.and. empty(aBenef[nX,8]) .and. 	;
			empty(aBenef[nX,10]).and. empty(aBenef[nX,12])
			lGrvOutr := .T.
		EndIf

		cVerba := aBenef[nX,10]

		If empty( cVerba )
			If !empty(aBenef[nX,3]) .and. aBenef[nX,11] != "C1"
				cVerba := aBenef[nX,3]
			ElseIf !empty(aBenef[nX,4]) .and. aBenef[nX,11] != "C1"
				cVerba := aBenef[nX,4]
			ElseIf !empty(aBenef[nX,5])	.and. aBenef[nX,11] != "C1"
				cVerba := aBenef[nX,5]
			ElseIf !empty(aBenef[nX,6])
				cVerba := aBenef[nX,6]
			ElseIf !empty(aBenef[nX,7])	.and. aBenef[nX,11] != "C1"
				cVerba := aBenef[nX,7]
			ElseIf !empty(aBenef[nX,8]) .and. aBenef[nX,11] != "C1"
				cVerba := aBenef[nX,8]
			ElseIf !empty(aBenef[nX,12])
				cVerba := aBenef[nX,12]
			ElseIf Len(aBenef[nX]) > 17 .and. !empty(aBenef[nX,18])
				cVerba := aBenef[nX,18]
			EndIf
		EndIf

		If Empty( aBenef[nX,11] )
			cTipDirf :=  AllTrim(RetValSrv(cVerba, xFilial("SRV",cFIL) ,"RV_DIRF"))
		Else
			cTipDirf := PadR( aBenef[nX,11], 2 )
		EndIf

		If cAno < "2016" .Or. (cAno >= "2016" .and. !(Padr(cTipDirf,2) $ "C xC1xC2xC3x8 x81xM2xM5xM xM1x9Dx9Ax9 x91xM6xM7x9Ex9Fx9Bx9CxM3xM4" ))

			cOutros 	:= If( lGrvOutr, cInfOut, If( ( !Empty( aBenef[nX,16] ) .And. cTipDirf <> "C" ), aBenef[nX,16], "" ) )
			cNewCodRet	:= If(cVerba $ aCodFol[976,01] + "*" + aCodFol[981,01],'1889',cCodRet)
			cVerba		:= If( Empty( cVerba ), Space( 3 ), cVerba )
			cCPFBen		:= cCPF + If( nTamCPF == 11, Space( 3 ), "" )
			cCodRGE		:= ""

			//Avalia o historico de contratos para geracao das informacoes
			For nY := 1 To Len( aRGE )
				If len(aBenef[nX])> 18 .And. aRGE[nY,2] <= aBenef[nX,19] .And. ( Empty(aRGE[nY,3]) .Or. aRGE[nY,3] > aBenef[nX,19] )
					cCodRGE := aRGE[nY,1]
				EndIf
			Next nY

			cNewCodRet := If( !Empty(cCodRGE), cCodRGE, cNewCodRet )

			If lGrvOutr
				cCPFCGC := If(aBenef[nX,11]=="I", Strzero(0,14), Space(14))
			Else
				cCPFCGC := aBenef[nX,02] + Space( 14 - Len( aBenef[nX,02] ) )
			EndIf

			cChave 		:= cFil + cMatricula + cTipoFJ + cCPFBen + cNewCodRet + cAno + cVerba + cTipDirf + cCPFCGC + cOutros

			If dbSeek( cChave )
				RecLock("RCS",.F.)
		    Else
				RecLock("RCS",.T.)
				RCS->RCS_FILIAL		:= cFIL
				RCS->RCS_MAT 		:= cMATRICULA
				RCS->RCS_TIPOFJ		:= cTipoFJ
				RCS->RCS_CPFBEN		:= cCPF
				RCS->RCS_CODRET		:= cNewCodRet
				RCS->RCS_ANO		:= cAno
				RCS->RCS_VERBA		:= cVerba
				RCS->RCS_TIPORE		:= cTipDirf
				RCS->RCS_CPFCGC		:= If( lGrvOutr, cCPFCGC, aBenef[nX,02])
				RCS->RCS_OUTROS		:= cOutros
				RCS->RCS_INMED      := If(len(aBenef[nX]) > 19, aBenef[nX,20],"")
				RCS->RCS_NOMED      := If(len(aBenef[nX]) > 19, aBenef[nX,21],"")
			EndIf

			RCS->RCS_NOME		:= aBenef[nX,01]
			RCS->RCS_VALOR		+= If( lGrvOutr,0 , aBenef[nX,09] )
			RCS->RCS_DESCRI		:= If( lGrvOutr,"", aBenef[nX,01] )
			RCS->RCS_ORIGEM		:= "1"

		   	MsUnlock()
		EndIf
	EndIf

	lGrvOutr := .F.

Next

//grava nova tabela de pensao de beneficiarios
If cAno >= "2016"
	dbSelectArea("SM8")
	SM8->(dbSetOrder(1))
	For nX := 1 To Len(aPensao)
		IF !empty(aPensao[nX,1]) .and. empty(aPensao[nX,02]) .and. empty(aPensao[nX,23])

		  If aTotRegs[14] == 0
				cLog := OemToAnsi(STR0148)+ CRLF
				Aadd(aTitle,cLog)
				Aadd(aLog,{})
				aTotRegs[14] := len(aLog)
			EndIf
			Aadd(aLog[aTotRegs[14]], OemToAnsi(STR0115) + ": " + cMATRICULA + " " + OemToAnsi(STR0149) + ": " + Alltrim(aPensao[nX, 1]))
		Endif
		//Verifica se já foi gravado o beneficiário, se sim só altera o registro, se não incluí o registro na SM8.
		nPosPens := Ascan(aPenSM8, {|x|x[1] == aPensao[nx, 1] .And. x[2] == aPensao[nx, 2] .And. x[3] == aPensao[nx, 3]})
		If nPosPens == 0
			lInclui := .T.
			Aadd(aPenSM8,{aPensao[nX, 1], aPensao[nX, 2], aPensao[nX, 16]})
		Else
			lInclui := .F.
		Endif
		For ny := 1 To Len(aPensao[nX][21])
			If aPensao[nX][21][nY][1] =="C3"
				cNewCodRet := cCodPLR
			Else
				cNewCodRet := cCodRet
			EndIf
			If lInclui
				lRec := .T.
				lCodBen := .F.
			Else
				//Indice(1) M8_FILIAL    +M8_MAT     +M8_CPFBEN     +M8_CODBEN           +M8_CODRET +M8_ANO+M8_MES              +M8_TIPOREN
				cChaveM8	:= SRA->RA_FILIAL + SRA->RA_MAT + aPensao[nX, 02] + aPensao[nPosPens, 16] + cNewCodRet + cAno+aPensao[nX][21][nY][2] + aPensao[nX][21][nY][1]
				lRec		:= !SM8->(dbSeek( cChaveM8 ))
				lCodBen		:= .T.
			EndIf
				Reclock("SM8",lRec)
					SM8->M8_FILIAL	:= cFIL
					SM8->M8_MAT 	:= cMATRICULA
					SM8->M8_CPFBEN	:= aPensao[nX,02]
					SM8->M8_CODBEN	:= If(lCodBen, aPensao[nPosPens, 16], aPensao[nX, 16])
					SM8->M8_CODRET	:= cNewCodRet
					SM8->M8_ANO		:= cAno
					SM8->M8_TIPOREN	:= aPensao[nX][21][nY][1]
					SM8->M8_MES		:= aPensao[nX][21][nY][2]
					SM8->M8_VALOR	+= aPensao[nX][21][nY][3]
					SM8->M8_DTPGTO	:= aPensao[nX][21][nY][4]

					If ColumnPos( 'M8_CPFCGC' ) > 0
						SM8->M8_CPFCGC	:= cCpf
					EndIf

				SM8->(msunlock())
		Next nY
	Next nX

	For nX := 1 To Len(aPrevi)
		For ny := 1 To Len(aPrevi[nX][5])
			Reclock("SM9",.T.)
				SM9->M9_FILIAL	:= cFIL
				SM9->M9_MAT 	:= cMATRICULA
				SM9->M9_CODFOR	:= aPrevi[nX,1]
				SM9->M9_CNPJ	:= aPrevi[nX,6]
				SM9->M9_NOMEEMP	:= aPrevi[nX,7]
				SM9->M9_CODRET	:= cCodRet
				SM9->M9_ANO		:= cAno
				SM9->M9_TIPOREN	:= aPrevi[nX][5][nY][1]
				SM9->M9_MES		:= aPrevi[nX][5][nY][2]
				SM9->M9_VALOR	:= aPrevi[nX][5][nY][3]
				SM9->M9_DTPGTO	:= aPrevi[nX][5][nY][4]

				If ColumnPos( 'M9_CPFCGC' ) > 0
					SM9->M9_CPFCGC	:= cCpf
				EndIf

			SM9->(msunlock())
		Next nY
	Next nX
EndIf

//PE criado p/ alterar a gravacao dos registros gravados.
If lGPE550GRV
	ExecBlock( "GPE550GRV", .F., .F., { 3 } )
EndIf

RestArea(aOldArea)
Return(Nil)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFuncao ³fBuscaFer_ResºAutor  ³Andreia dos Santos  º Data ³  11/11/06   º±±
±±ÌÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.  ³-Verifica se tem algum funcionario de ferias em dezembro, cujasº±±
±±º       ³férias serão pagas na folha de janeiro,  e a folha de janeiro  º±±
±±º       ³ainda esta em aberto.                               			  º±±
±±º       ³- Se o mês/Ano da demissão for igual a competência em aberto,  º±±
±±º       ³buscar nas tabelas de rescisão os valores para a DIRF.         º±±
±±º       ³Desta forma será possível gerar o informe de rendimentos para  º±±
±±º       ³funcionário demitido no mês, antes de fazer o fechamento mensalº±±
±±ÌÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso    ³ GPEM550                                                       º±±
±±ÈÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function fBuscaFer_Res(cTipoBusca, cFolMes, cPdPLS)

	Local cPerBusca     := ""
	Local aArea			:= GetArea()
	Local nX			:= 0
	Local lRegTrans		:= .F.
	Local lFerDtPg		:= .F.

	Default cFolMes		:= cAnoMesAb
	DEFAULT cPdPLS		:= ""

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Se a busca for de rescisoes e o ano pedido for diferente do ano   ³
	//³em aberto, significa que o mes em que foi feita a rescisao ja esta³
	//³fechado, entao nao ha necessidade de pesquisar no SRR pois        ³
	//³as verbas ja estao no SRD.                                        ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If cAno # SubStr(cFolmes,1,4) .And. cTipoBusca=="R"
		Return()
	EndIf

	dbSelectArea("SRR")
	If cTipoBusca == "F" //Ferias
		cPerBusca := DTOS(SRH->RH_DTRECIB)
		dbsetOrder(5) // RR_FILIAL+RR_MAT+DTOS(RR_DATAPAG)+RR_PD

		// FOI REMOVIDO DO SEEK A VERBA (fGetCodFol(cCodFolFer)), POIS O CODFOL VINCULADO A ELA PODE VARIAR DE ACORDO COM A CATEGORIA DO FUNCIONARIO
		// E CADASTRO DA VERBA. EX: O CODFOL PARA FERIAS DE COMISSÃO PODE SER 0075/0343/0072/0345...
		SRR->(dbSeek (SRA->(RA_FILIAL+RA_MAT) +  cPerBusca, If(cTipoBusca =="R", .T., .F.)))
		// Tratamento para quando funcionário possui mais de férias no período com a mesma data de pagamento
		While SRR->( !EOF()) .And. SRR->(RR_FILIAL+RR_MAT) == SRA->(RA_FILIAL+RA_MAT) .And. DTOS(RR_DATAPAG) == cPerBusca	.And. !lFerDtPg
			If SRR->RR_DATA == SRH->RH_DATAINI
				lFerDtPg	:= .T.
				Exit
			EndIf
			SRR->( dbSkip() )
		EndDo

	ElseIf cTipoBusca == "R" //Rescisao
		cPerBusca := cFolMes + "01"
		SRR->(dbsetOrder(1)) // RR_FILIAL+RR_MAT+RR_TIPO3+DTOS(RR_DATA)+RR_PD+RR_CC+RR_PROCES
		SRR->(dbSeek ( SRA->(RA_FILIAL+RA_MAT) + cTipoBusca + cPerBusca,If(cTipoBusca=="R",.T.,.F. )))
	EndIf

	If SRR->(Eof())
		Return()
	EndIf

	If cTipoBusca == "F"
		If Len(aTransf) > 0
			For nX := 1 To Len(aTransf)
				If !lRegTrans
					// Período de Transferência, Filial  + Matrícula Destino
					If aTransf[nX][8] <> aTransf[nX][10] .And. AnoMes(SRR->RR_DATAPAG) <= aTransf[nX, 12] .And. SRR->RR_FILIAL + SRR->RR_MAT == aTransf[nX, 10] +  aTransf[nX, 11]
						lRegTrans := .T.
					EndIf
				EndIf
			Next nX
		EndIf

		// Na transferência os dados das tabelas SRH/SRR são migrados para a Filial + Matrícula corrrente (utilizado no INNER JOIN da SRD)
		// Caso o usuário tenha sido transferido APÓS o pagamento das férias, os seus dados não devem ser considerados
		If lRegTrans
			Return()
		Else
			If (SRH->(RH_FILIAL + RH_MAT)  + dTos(SRH->RH_DATAINI )) == (SRR->(RR_FILIAL+RR_MAT)  + dTos(SRR->RR_DATA))
				If (MesAno(SRH->RH_DATAINI) # STRZERO(MV_PAR06 + 1, 4) + "01" )
					Return()
				EndIf
			EndIf
		EndIf
	EndIf

	If cTipoBusca == "R"
		SRC->( dbSeek( SRA->(RA_FILIAL+RA_MAT ) ))
		While SRC->( !EOF()) .and. SRC->(RC_FILIAL+RC_MAT) == SRA->(RA_FILIAL+RA_MAT)

			f550MontaDados(SRC->RC_PD, SRC->RC_FILIAL, "13", "SRC",,,cPdPLS)

			SRC->( dbSkip() )
		EndDo
	EndIf

	While SRR->(!EoF()) .And. SRR->(RR_FILIAL+RR_MAT) == SRA->(RA_FILIAL+RA_MAT).And. MesAno(SRR->RR_DATAPAG) == substr(cPerBusca,1,6)

		If SRR->(RR_FILIAL+RR_MAT+RR_TIPO3) <> SRA->(RA_FILIAL+RA_MAT)+cTipoBusca
			SRR->(dbSkip())
			Loop
		Endif

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Se encontrar a verba no SRD signfica que o fechamento ja ³
		//³ foi feito nao havendo necessidade de ler a verda no SRR.³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If cTipoBusca == "F"
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Férias pagas em dezembro e gozadas em janeiro. O IR só entrara na folha    ³
			//³de janeiro com data de pagamento em dezembro.                              ³
			//³Como a folha ainda está aberta os valores de ferias não estão no acumulado.³
			//³Esta busca so sera usada se a DIRF tiver que ser entregue em janeiro, pois ³
			//³os dados das ferias estarao na folha de janeiro( que ainda estara aberta), ³
			//³mas a data de pagamento sera em dezembro, tendo que ser informada neste ano³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If SRD->(dbSeek(SRA->(RA_FILIAL + RA_MAT) + STRZERO(MV_PAR06 + 1, 4) + "01" + SRR->RR_PD)) .Or. SRA->RA_RESCRAI == '31'
				SRR->(dbSkip())
				Loop
			EndIf

			//Se o período existente no lançamento da verba de férias for em dezembro significa que os valores já estão no acumulado
			If SRR->RR_PERIODO == cValToChar(MV_PAR06) + "12"
				SRR->(dbSkip())
				Loop
			EndIf

		ElseIf cTipoBusca == "R"
			If SRD->(dbSeek(SRA->(RA_FILIAL + RA_MAT) + MesAno(SRR->RR_DATA) + SRR->RR_PD))
				SRR->(dbSkip())
				Loop
			EndIf
		Endif

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Busca os valores das verbas no acumulado e suas incidências, ³
		//³e as guardará no array afun, para gravar posteriormente nas  ³
		//³tabelas SR4 e SRL.                                           ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		f550MontaDados(SRR->RR_PD, SRR->RR_FILIAL, cTipoBusca, "SRR", SRR->RR_IDCMPL,, cPdPLS)

		SRR->(dbSkip())
	EndDo

	RestArea( aArea )

Return()

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFuncao    ³f550MontaDadosºAutor  ³Microsiga       º Data ³  28/11/06   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Busca os valores das verbas no acumulado e suas incidências,º±±
±±º          ³e as guardará no array afun, para gravar posteriormente nas º±±
±±º          ³tabelas SR4 e SRL.                                          º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³ cPd       = Codigo da verba                                º±±
±±º          ³ cCodFil   = Codigo da Filial                               º±±
±±º          ³ cTipoCalc = "Normal","Rescisao", "Ferias"                  º±±
±±º          ³ cAliasDirf= Alias que esta sendo usado no momento          º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function f550MontaDados( cPD, cCodFil, cTipoCalc, cAliasDirf, cIdCmpl, lPulaAdt, cPdPLS, cFilSRV)

	Local aArea			:= GetArea()
	Local cCNPJCompl	:= ""
	Local cCNPJFAss		:= ""
	Local cCodAsSau 	:= ""
	Local cCodFAss		:= ""
	Local cDescri		:= ""
	Local cGraupar      := ""
	Local cIdCalVb		:= ""
	Local cMesPag		:= ''
	Local cNomeForn 	:= ""
	Local cTabForn  	:= ""
	Local cTabPlano 	:= ""
	Local cTipDirf		:= ""
	Local cVbOdoT	    := ""
	Local cDatArq		:= ""
	Local cDataDep		:= ""
	Local cOrigem		:= ""
	Local cCodFol		:= ""
	Local cTpCod		:= ""
	Local cIr			:= ""
	Local cCpoVerba		:= ""
	Local dDtPgtAb		:= CtoD( "  /  /  " )
	Local lCondicao		:= .F.
	Local lOdoSodp		:= .F.
	Local lSeekRatAM	:= .F.							// Variavel para controlar se encontrou informacoes de Rateio no arquivo
	Local nPos			:= 0
	Local nPos1			:= 0
	Local cVerbaAb		:= 0
	Local nValorAb		:= 0
	Local aAreaAux		:= (cAliasSRD)->( GetArea() )
	Local lVerbPlSau	:= .F.
	Local nPerc1        := 0.40
	Local nPerc2        := 0.60
	Local cChvRateio	:= ""
	Local lAbatAbon		:= .F.
	Local cChaveSRR		:= ""
	Local lRegTrans		:= .F.
	Local nX			:= 0
	Local cCompet		:= ""
	Local nValDedSim	:= 0
	Local lExtFer		:= .F.
	Local lProxFer 		:= .F.


	DEFAULT cIdCmpl := ''
	DEFAULT lPulaAdt := .F.
	DEFAULT cPdPLS	:= ""

	DEFAULT cFilSRV := xFilial("SRV",cCodFil)

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Posiciona a Verba no SRV³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	cTipDirf	:= AllTrim(RetValSrv(cPd, cFilSRV ,"RV_DIRF"))
	cDescri		:= Alltrim(RetValSrv(cPd, cFilSRV ,"RV_DESC"))
	cCodFol		:= Alltrim(RetValSrv(cPd, cFilSRV ,"RV_CODFOL"))
	cTpCod		:= Alltrim(RetValSrv(cPd, cFilSRV ,"RV_TIPOCOD"))
	cIr			:= Alltrim(RetValSrv(cPd, cFilSRV ,"RV_IR"))

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Se o funcionário tiver multiplos vinculos, garante que o valor³
	//³da dedução de dependentes foi utilizado somente em uma        ³
	//³das matriculas.                                               ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If cPd $ aCodFol[059, 1] + "*" + aCodFol[060, 1] + "*" + aCodFol[061, 1] + "*" + aCodFol[062, 1]
		cDataDep	:= If(cTipoCalc $ "R#F", (cAliasDirf)->RR_DATA, StoD((cAliasSRD)->RD_DATPGT))
		cAnoMesDep	:= MesAno(cDataDep)
		cChvRateio	:= (cAliasSRD)->(RD_CC + RD_ITEM + RD_CLVL)
		cOrigem		:= (cAliasSRD)->RD_TIPO2
		If ( Ascan(aDependentes,{|x|X[1]==SRA->RA_CIC .And. X[2]==cAnoMesDep .And. X[3]==cPd .And. X[4]==SRA->RA_FILIAL+SRA->RA_MAT .And. X[5]==cChvRateio .And. (X[6] == cDataDep .Or. (X[6] != cDataDep .And. X[7] == cOrigem))} ) # 0 ) .Or. (cAliasSRD)->RD_ROTEIR $ "ADI"
			RestArea( aArea )
			Return()
		Else
			AaDd(aDependentes, {SRA->RA_CIC, cAnoMesDep, cPd, SRA->(RA_FILIAL + RA_MAT), cChvRateio, cDataDep, cOrigem})
		EndIf
	EndIf

	If cTipoCalc $ "N"
		If SRV->( EoF() ) .And. !Empty( cPd )
			If aTotRegs[7] == 0
				cLog := STR0033 //"Verba consta nos acumulados, mas nao consta no cadastro de verbas.   Verba    Competencia             Valor"
				Aadd(aTitle,cLog)
				Aadd(aLog,{})
				aTotRegs[7] := len(aLog)
			EndIf
			Aadd(aLog[aTotRegs[7]],space(70)+cPd+space(06)+substr((cAliasSRD)->RD_DATARQ,5,2)+"/"+substr((cAliasSRD)->RD_DATARQ,1,4) +space(04)+transform((cAliasSRD)->RD_VALOR,"@E 99,999,999,999.99") )
			RestArea( aArea )
			Return()
		EndIf
	EndIf

	If cIr =="S" .And. Empty(cTipDirf)
		If aTotRegs[2] == 0
			cLog := STR0034 //"Verba com incidência para IR, mas sem configuração para DIRF."
			Aadd(aTitle,cLog)
			Aadd(aLog,{})
			aTotRegs[2] := len(aLog)
		EndIf

		If ascan(aVerba,cPD)== 0
			Aadd(aLog[aTotRegs[2]], cPD+"-"+cDescri )
			Aadd(aVerba,cPD)
		EndIf
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Quando for codigo de Desc. de Adiantamento e estiver Incid. p/ ³
	//³Rend. Tributavel ja considerado no tratamento de adiantamento. ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If cPd == aCodFol[007,1] .And. AllTrim(cTipDirf) == "A" .and. !lPulaADT .Or. ;
		(cPd == aCodFol[1397,1] .And. AllTrim(cTipDirf) == "A" .And. (cAliasSRD)->RD_TIPO2 == "A")
		RestArea( aArea )
		Return()
	Endif

	If cTipoCalc == "N"
		lCondicao	:= .T.
	ElseIf cTipoCalc $ "F"
	   	lCondicao	:= YEAR(SRH->RH_DTRECIB) == MV_PAR06

	ElseIf cTipoCalc $ "R"
		lCondicao	:= YEAR(SRR->RR_DATA) == MV_PAR06

	ElseIf cTipoCalc $ "13"
		lCondicao	:= YEAR(SRC->RC_DATA) == MV_PAR06
	EndIf

	If lCondicao

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Mes de Pagamento para gravacao SR4³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If cTipoCalc $ "N"
			cMesPag := STRZERO(MONTH(StoD((cAliasSRD)->RD_DATPGT)),2)

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Antecipacao no mes 12 indica que e uma rescisao e deve entrar na DIRF³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Para rescisao antes da 2a parcela, esta gerando verba com id. 183, ³
			//³e nao pode ser abatido na DIRF.                                    ³
			//³So podera ter abatimento apos calculo da 2a parcela.               ³
			//³O abatimento será apenas no roteiro da FOLHA.                      ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If cCodFol == "0183" .And. Right((cAliasSRD)->RD_DATARQ,2) = "12" .And. cMesPag $ "12/01" .And. cTipDirf == "N" .AND. (cAliasSRD)->RD_ROTEIR == fGetCalcRot("1") //FOLHA
		   		nOldRec := (cAliasSRD)->(Recno())

			    cChave	:= (cAliasSRD)->(RD_FILIAL+RD_MAT+RD_DATARQ)+aCodfol[247,1]

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Por nao poder utilizar o comando DbSeek quando utiliza-se uma query³
				//³estamos fazendo a busca diretamente na tabela.                     ³
				//³POR FAVOR NAO ALTERAR ESTE ALIAS.                                  ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			    SRD->(dbSetOrder(1))

			    If SRD->(dbSeek(cChave))
					cTipDirf := "J"
				EndIf

				(cAliasSRD)->(dbGoTo(nOldRec))
			EndIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Quando o parâmetro MV_DINSSFM estiver com "Sim", o sistema  gera o                 ³
			//³valor do desconto do INSS ferias mes seguinte( Id. 232), quando as férias          ³
			//³são gozadas em mais de um mês.                                                     ³
			//³O tratamento abaixo foi feito para deduzir o valor do Inss férias no mês seguinte, ³
			//³para que os rendimento tributável fique correto.                                   ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If (cAliasSRD)->RD_PD == aCodFol[164,1] // Férias Pagas Mês Anterior
		   		nOldRec :=	(cAliasSRD)->( Recno() )

				nMes := val(substr( (cAliasSRD)->RD_DATARQ, 5,2)) -1

				If nMes < 1
					cMesAno := strzero(val(substr( (cAliasSRD)->RD_DATARQ, 1,4))-1,4)+"12"
				Else
					cMesAno := substr( (cAliasSRD)->RD_DATARQ, 1,4)+strzero(nMes,2)
				EndIf

				cChave	:= (cAliasSRD)->(RD_FILIAL+RD_MAT) + cMesAno + aCodfol[232, 1]
				SRD->( dbSetOrder(1) )
			    If SRD->( dbSeek(cChave))
		     		// Month(SRD->RD_DATPGT)==11 .or. Month(SRD->RD_DATPGT)==12) .and. Year(SRD->RD_DATPGT)==(MV_PAR06-1) )
			     	// Data de pagamento das Férias em outubro e partidas em novembro e dezembro
			     	// Mês de pagamento da verba de INSS Férias Mês Seguinte (ID 232) deverá ser igual ao mês de pagamento da verba de Férias Pagas Mês Anterior (ID 164)
					// para subtrair dos Rendimentos Tributáveis pois a verda de Férias Pagas Mês Anterior pode ter um novo RD_DATARQ mas assume a Data de Pagamento quando foi realizado
			    	If  ( Year(SRD->RD_DATPGT) == MV_PAR06  .or. ((Month(SRD->RD_DATPGT)>=10 .and. Year(SRD->RD_DATPGT)==(MV_PAR06-1))) )
						cMesPag2 := STRZERO(MONTH(SRD->RD_DATPGT),2)
						If cMesPag == cMesPag2 .And. Empty((cAliasSRD)->RD_SEQ)
							GravaFun( cMesPag, "A", SRD->RD_VALOR*(-1), StoD((cAliasSRD)->RD_DATPGT), cIdCmpl, SRD->RD_PD, SRD->RD_PERIODO)
						EndIf
					EndIf
				EndIf

				// A cada leitura de  FER PAG MES ANT 164 é excluído INSS FER MES SEG 232
				// Porém quando existe Férias entre 3 meses, resta excluir o INSS de Férias do mês de pagamento das Férias
				// Exemplo - Férias 31/01 à 01/03
				// ID    RD_DATARQ  RD_DATPGT
				// 232 - 20xx02     20xx0131 - Exclui 164 20xx02 - Neste ponto também excluir 0065 20xx01
				// 232 - 20xx03     20xx0131 - Exclui 164 20xx03
				If cDescInsFer == "R" .And. f3MesesFer((cAliasSRD)->(RD_FILIAL), (cAliasSRD)->(RD_MAT), (cAliasSRD)->RD_DATPGT, (cAliasSRD)->RD_SEQ)
					cChave	:= (cAliasSRD)->(RD_FILIAL+RD_MAT) + (cAliasSRD)->RD_DATPGT + aCodfol[65, 1]
					SRD->( dbSetOrder(4) ) //RD_FILIAL+RD_MAT+DTOS(RD_DATPGT)+RD_PD+RD_SEMANA+RD_SEQ+RD_CC
					If SRD->( dbSeek(cChave))
						If SRD->RD_TIPO2 == "K"
							cMesPag2 := SubStr((cAliasSRD)->RD_DATARQ,5,2)
							If Val(cMesPag2) - Val(cMesPag) == 1
								GravaFun( cMesPag, "A", SRD->RD_VALOR*(-1), DtoS(SRD->RD_DATPGT), cIdCmpl, SRD->RD_PD, SRD->RD_PERIODO)
							EndIf
						EndIf
					EndIf
				EndIf

				// Realiza busca na tabela SRR somente para funcionários que tiveram Transferência de FILIAL
				// Pois na transferência os dados das tabelas SRH/SRR são migrados para a Filial + Matrícula corrrente (utilizado no INNER JOIN da SRD)
				If Len(aTransf) > 0
					For nX := 1 To Len(aTransf)
						If !lRegTrans
							// Período de Transferência, Filial  + Matrícula Destino
							If aTransf[nX][8] <> aTransf[nX][10] .And. AnoMes(StoD((cAliasSRD)->RD_DATPGT)) <= aTransf[nX, 12] .And. (cAliasSRD)->(RD_FILIAL+RD_MAT) == aTransf[nX, 10] +  aTransf[nX, 11]
								lRegTrans := .T.
							EndIf
						EndIf
					Next nX

					If lRegTrans
						cChaveSRR := (cAliasSRD)->(RD_FILIAL + RD_MAT) + (cAliasSRD)->RD_DATPGT + aCodfol[232, 1]
						SRR->(dbSetOrder(5)) // RR_FILIAL+RR_MAT+DTOS(RR_DATAPAG)+RR_PD
						If SRR->(dbSeek(cChaveSRR))
							If Year(SRR->RR_DATAPAG) == MV_PAR06 .Or. ((Month(SRR->RR_DATAPAG) >= 10 .And. Year(SRR->RR_DATAPAG) == (MV_PAR06 - 1)))
								GravaFun(cMesPag, "A", SRR->RR_VALOR * ( - 1),  sToD((cAliasSRD)->RD_DATPGT), cIdCmpl, SRR->RR_PD)
							EndIf
						EndIf
					EndIf
				EndIf

				(cAliasSRD)->( dbGoTo( nOldRec ) )
			EndIf

	  	ElseIf cTipoCalc $ "R#F"
			cMesPag := STRZERO(MONTH(If(cTipoCalc $ "R",SRR->RR_DATAPAG,SRH->RH_DTRECIB) ),2)

			If cTipoCalc $ "R" .AND. cCodFol == "0183" .And. STRZERO(MONTH(SRR->RR_DATAPAG),2)=="12" .And.;
			   cMesPag $ "12/01" .And. cTipDirf == "N"

		    	nOldRec :=	SRR->( Recno() )

			    cChave	:= SRR->(RR_FILIAL+RR_MAT)+"R"+dTos(SRR->RR_DATAPAG)+aCodfol[247,1]
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Por nao poder utilizar o comando DbSeek quando utiliza-se uma query³
				//³estamos fazendo a busca diretamente na tabela.                     ³
				//³POR FAVOR NAO ALTERAR ESTE ALIAS.                                  ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			    SRR->( dbSetOrder(1) )
			    If SRR->( dbSeek(cChave))
					cTipDirf := "J"
				EndIf
				SRR->( dbGoTo( nOldRec ) )
			EndIf

	  	ElseIf cTipoCalc $ "13"
			cMesPag := STRZERO(MONTH(SRC->RC_DATA),2)
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Armazenar valor das verbas relacionadas a abono pec. qdo a verba   ³
		//³estiver com codigo dirf = a "0"                                    ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If (cCodFol == "0164"  .Or. ((cTipDirf == "0" .And. aScan(aCodAboPec, { |x| x[2] == cPd .Or. x [4] == cPd .Or. x [5] == cPd}) > 0)))
			cVerbaAb	:= cPd
	        nValorAb	:= If(cTipoCalc $ "R#F", SRR->RR_VALOR		, If(cTipoCalc $ "13", SRI->RI_VALOR		,(cAliasSRD)->RD_VALOR))
			dDtPgtAb	:= If(cTipoCalc $ "R#F", SRR->RR_DATAPAG		, If(cTipoCalc $ "13", SRI->RI_DATA			,StoD((cAliasSRD)->RD_DATPGT)))
			cDatArq 	:= If(cTipoCalc $ "R#F", AnoMes(SRR->RR_DATA)	, If(cTipoCalc $ "13", AnoMes(SRI->RI_DATA)	,(cAliasSRD)->RD_DATARQ))

			aAdd(aAbono, {cMesPag, cVerbaAb, nValorAb, cTipDirf, dDtPgtAb, cDatArq, .T. } )
	   	EndIf

		If !cTipDirf$ "Nx "
			If cTipoCalc $ "N"
				nVal		:= (cAliasSRD)->RD_VALOR
				dDtPagto	:= StoD((cAliasSRD)->RD_DATPGT)
				cDatArq		:= (cAliasSRD)->RD_DATARQ
				cCpoVerba	:= (cAliasSRD)->RD_PD
				cCompet		:= (cAliasSRD)->RD_PERIODO
			ElseIf cTipoCalc $ "R#F"
				nVal		:= SRR->RR_VALOR
				dDtPagto	:= SRR->RR_DATAPAG
				cDatArq		:= AnoMes(SRR->RR_DATA)
				cCpoVerba	:= SRR->RR_PD
		  	ElseIf cTipoCalc $ "13"
				nVal		:= SRC->RC_VALOR
				dDtPagto	:= SRC->RC_DATA
				cDatArq		:= AnoMes(SRC->RC_DTREF)
				cCpoVerba	:= SRC->RC_PD
			EndIf

			//ID de Abono pago mes anterior
			If cAno >= "2018" .And. cCodFol == "1449" .And. cTipDirf == "0"
				cTipDirf := "A"
			EndIf

			If cTipoCalc $ "N"
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Verifica Mes Para Saber Se e 13o  Muda a Letra               ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If (cAliasSRD)->RD_ROTEIR $ cRot132 .And. cTipDirf == "A"
					cTipDirf := "J"

				ElseIf (cAliasSRD)->RD_ROTEIR $ cRot132 .And. cTipDirf$ "B"
					cTipDirf := "B1"

				ElseIf (cAliasSRD)->RD_ROTEIR $ cRot132 .And. cTipDirf$ "C"
					cTipDirf := "C1"

				ElseIf (cAliasSRD)->RD_ROTEIR $ cRot132 .And. cTipDirf$ "T"
					cTipDirf := "T1"

				ElseIf (cAliasSRD)->RD_ROTEIR $ cRot132 .And. cTipDirf$ "D"
					cTipDirf := "L"
				Endif

			    //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Desprezar verbas do complemento do 13o ano base anterior³
				//³ ou posterior ao ano de processamento                   ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If ( If(Len(cTipDirf)==1,cTipDirf$ "JxKxL",cTipDirf$ "B1xT1xC1xM1x81x91xM6xM7x9Ex9F" )) .And. ;
					(;
					(Val(Subs((cAliasSRD)->RD_DATARQ,1,4)) < MV_PAR06 .And. Val(Subs((cAliasSRD)->RD_DATARQ,1,4)) <= 2005) .Or. ;
					(Year(StoD((cAliasSRD)->RD_DATPGT)) > MV_PAR06 .And. Val(Subs((cAliasSRD)->RD_DATARQ,1,4)) # MV_PAR06);
					)
					RestArea( aArea )
					Return()
				Endif

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Despreza Complemento 13o. pago em janeiro do ano seguinte³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If ( If(Len(cTipDirf)==1,cTipDirf$ "JxKxL",cTipDirf$ "B1xT1xC1xM1x81x91xM6xM7x9Ex9F") ) .And. Year(StoD((cAliasSRD)->RD_DATPGT)) > MV_PAR06
					RestArea( aArea )
					Return()
				Endif
			EndIf
			If cTipDirf $ 'AxExFxGxHxIxJxOxPxTxU'
	        	If cTpCod == "2" //Desconto
					nVal *= -1
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Rendimento Tributavel sera 60 % decorrente do transporte de Passageiro. ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				ElseIf cTpCod == "1" .and. cTipDirf$ "A" .and. cPd $ p_TranspAP

	                nPerc2 := 0.60
					if year(dDTpagto) > 2012
		                nPerc2 := nPRca2
					endif

					// Antes de mudar a base, deve lancar a diferenca como Rendimento Isento e Nao Tributavel (letra I)
					GravaFun( cMesPag, "I", (nVal-(nVal * nPerc2)), dDtPagto, cIdCmpl )

					cDescri   := STR0044	// "Prest.Serv.Transp.Passag."
					If at(cDescri, cInfOut) == 0
						cInfOut += If( Len( cInfOut ) > 0, ", ", "" ) + cDescri
					Endif

					nVal := nVal * nPerc2
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Rendimento Tributavel para freteiro sera 40 % decorrente do transporte de carga. ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				ElseIf cTpCod == "1" .and. cTipDirf$ "A" .and. SRA->RA_CATEG == "15"
					If cCodFol == "1564" // Valor do Frete - Incidencia IRRF (Para o eSocial foi separado o Id 0218)
						nVal := nVal
					ElseIf cCodFol == "0218" // Autonomo
						nPerc1 := 0.40

						If year(dDTpagto) > 2012
							nPerc1 := nPRca1
						EndIf

						// Antes de mudar a base, deve lancar a diferenca como Rendimento Isento e Nao Tributavel (letra I)
						GravaFun( cMesPag, "I", (nVal-(nVal * nPerc1)), dDtPagto, cIdCmpl )

						cDescri   := STR0045	// "Prest.Serv.Transp.Carga"
						If at(cDescri,cInfOut) == 0
							cInfOut += If( Len( cInfOut ) > 0, ", ", "" ) + cDescri
						EndIf

						nVal := nVal * nPerc1
					EndIf
				EndIf
	   		Elseif cTipDirf$ 'D'
		    	If cTpCod == "1" //Provento
	            	nVal *= -1
				Endif

			Elseif cTipDirf$ 'BxCxKxLxQ'
		    	If cTpCod $ "1*3" //Provento ou Base
					If !cTipDirf$ "KxBxC"
						nVal *= -1
					Endif
					If cTipDirf == "C" .And. cTpCod == "1" //Provento
						nVal *= -1
					Endif
				Endif
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Implementa informacoes referente aos Beneficiarios³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Informacoes referentes a 13o³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If cTipDirf $ "K"
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³Pesquisa as verbas de 13 e acrescenta uma linha se elas existirem. ³
					//³Se encontrar mais alguma de 13 acumula os valores ( cTipDirf = K)  ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				 	cVerba := cPD
				 	nPos := Ascan(aBenef,{|x| (x[6]=cVerba	.or. x[7] = cVerba)})
					If nPos > 0
						If ! aBenef[nPos,13]
							aadd(aBenef,{	aBenef[nPos,01]+" Ref. a 13o"	,;  //1
											aBenef[nPos,02]					,;	//2
											aBenef[nPos,03]					,;	//3
											aBenef[nPos,04]					,;	//4
											aBenef[nPos,05]					,;	//5
											aBenef[nPos,06]					,;	//6
											aBenef[nPos,07]					,;	//7
											aBenef[nPos,08]					,;	//8
											nVal							,;	//9
											""								,; 	//10 VERBA
											cTipDirf						,; 	//11 TIPO RENDIMENTO
											aBenef[nPos,12]					,;	//12
											.T.  							,;	//13
											""                              ,;  //14
											""                              ,;  //15
											""								,;  //16 Grau Parentesco
											""								,; 	//17 Mes Pagto - utilizado na assit medica qdo tem rateio
											""								}) 	//18 Verba RRA
						Else
							aBenef[nPos,09]	+= nVal
							aBenef[nPos,11] := cTipDirf
						EndIF
					EndIF
				EndIF

				If cAno < "2016" .And. cTipDirf $ "C"
				 	cVerba	:= cPd
				 	nPos	:= Ascan(aBenef, {|x|(	x[3] = cVerba .Or. x[4] = cVerba .Or.;
				 									x[5] = cVerba .Or. x[6]	= cVerba .Or.;
				 									x[7] = cVerba .Or. x[8]	= cVerba .Or.;
				 									x[12] = cVerba .Or. x[14] = cVerba .Or.;
				 									x[15] = cVerba) .And. !(Year(dDtPagto) # MV_PAR06)})
					If nPos > 0
						aBenef[nPos,09]	+= nVal
						aBenef[nPos,11] := cTipDirf
						aBenef[nPos,01] += If("Pensão" $ aBenef[nPos,01],""," Pensão")
					EndIF
				EndIF

			ElseIf ( cAno < "2016" .And. cTipDirf $ 'B1xC1xT1xM1') .Or. ( cAno >= "2016" .And. cTipDirf $ 'B1xT1')
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Implementa informacoes referente aos Beneficiarios³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Informacoes referentes a 13o³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Pesquisa as verbas de 13 e acrescenta uma linha se elas existirem. ³
				//³Se encontrar mais alguma de 13 acumula os valores ( cTipDirf = K)  ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			 	cVerba := cPD
			 	nPos := Ascan(aBenef,{|x| ((x[6]=cVerba	.or. x[7] = cVerba) .And. !(Year(dDtPagto) # MV_PAR06))})
				If nPos > 0
					If ! aBenef[nPos,13]
						aadd(aBenef,{	aBenef[nPos,01]+" Ref. a 13o"	,;  //1 Descricao
										aBenef[nPos,02]					,;	//2 CPF
										aBenef[nPos,03]					,;	//3 Vb Adiantamento
										aBenef[nPos,04]					,;	//4 Vb Folha
										aBenef[nPos,05]					,;	//5 Vb Ferias
										aBenef[nPos,06]					,;	//6 Vb 13 1a parc
										aBenef[nPos,07]					,;	//7 vb 13 2a Parc
										aBenef[nPos,08]					,;	//8 Vb PLR
										nVal							,;	//9 Valor
										""								,; 	//10 VERBA
										cTipDirf						,; 	//11 TIPO RENDIMENTO
										aBenef[nPos,12]					,;	//12
										.T.  							,;	//13
										""                              ,;  //14
										""                              ,;  //15
										aBenef[nPos,16]				,;  //16 Grau Parentesco
										""								,; 	//17 Mes Pagto - utilizado na assit medica qdo tem rateio
										cVerba							}) 	//18 Verba RRA
					Else
						aBenef[nPos,09]	+= nVal
						aBenef[nPos,11] := cTipDirf
					EndIF
				EndIF
			Endif

			If cAno < "2016" .And. cTipDirf == 'C2' //Pensao RRA

			 	cVerba := cPD
			 	nPos := Ascan(aBenef,{|x| (x[10] $ aCodFol[981,01] + "*" + aCodFol[976,01] )})
			 	If nPos == 0
			 		nPos := Ascan(aBenef,{|x| (x[17] == cVerba .or. x[17] $ aCodFol[981,01] + "*" + aCodFol[976,01] )})
			 	EndIf
				If nPos > 0
					If !(aBenef[nPos,10] $ aCodFol[981,01] + "*" + aCodFol[976,01])
						aadd(aBenef,{	aBenef[nPos,01]+If("Pensão" $ aBenef[nPos,01]," RRA"," Pensão RRA")		,;  //1 Descricao
										aBenef[nPos,02]					,;	//2 CPF
										aBenef[nPos,03]					,;	//3 Vb Adiantamento
										aBenef[nPos,04]					,;	//4 Vb Folha
										aBenef[nPos,05]					,;	//5 Vb Ferias
										aBenef[nPos,06]					,;	//6 Vb 13 1a parc
										aBenef[nPos,07]					,;	//7 vb 13 2a Parc
										aBenef[nPos,08]					,;	//8 Vb PLR
										nVal							,;	//9 Valor
										cVerba							,; 	//10 VERBA
										cTipDirf						,; 	//11 TIPO RENDIMENTO
										aBenef[nPos,12]					,;	//12
										.T.  							,;	//13
										""                              ,;  //14
										""                              ,;  //15
										""								,;	//16 Grau Parentesco
										""								,; 	//17 Mes Pagto - utilizado na assit medica qdo tem rateio
										cVerba							}) 	//18 Verba RRA
					Else
						aBenef[nPos,09]	+= nVal
						aBenef[nPos,11]	:= cTipDirf
					EndIF
				EndIF
			Endif

			If ( cAno < "2016" .And. cTipDirf $"W#2#Z#5#R#M") .Or. ( cAno >= "2016" .And. cTipDirf $"W#2#Z#5#R")	//Informacoes complementares

				// Salva Area Oficial
				aAreaAux := (cAliasSRD)->( GetArea() )

				lVerbPlSau := cCpoVerba $ cPdPLS


				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Desconsiderar neste processamento:																		³
				//³	As Verbas encontradas nos historicos de assist. med./odontol., copartic. e reembolso (RHS e RHP)     	³
				//³ Pois as mesmas serao tratadas posteriormente em processamento especifico.								³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If ! lVerbPlSau

					If ( nPos := Ascan( aBenef, {|x| x[10] == cPD .And. AnoMes(dDtPagto) == x[19] } ) ) == 0
						If cTipDirf $ "R|M"	// Completa Descricao com CNPJ e Razao Social da Empresa Logada quando nao eh Assist. Med. ou Odontol.
							cDescri := cDescri + Space( 30 - Len( cDescri ) )
							cDescri += " / RAZAO SOCIAL: " + AllTrim( aInfo[3] ) + " / CNPJ: " + Transform(Left(aInfo[8],14),'@R ##.###.###/####-##')
							aadd(aBenef, { cDescri, aInfo[8]	, "", "", "", "", "", "", nVal, cPD, cTipDirf, "", .F., "", "", cGraupar, "", "", AnoMes(dDtPagto) } )
						Else
							aadd(aBenef, { cDescri, cCNPJCompl	, "", "", "", "", "", "", nVal, cPD, cTipDirf, "", .F., "", "", cGraupar, "", "", AnoMes(dDtPagto) } )
						EndIf
					Else
						aBenef[nPos,09] += nVal
					EndIf

				EndIf

				// Retorna para Area Oficial
				RestArea( aAreaAux )

			Endif

			If cAno >= "2016" .And. Padr(cTipDirf,2) $ 'C xC1xC2xC3x8 x81'
				cVerba	:= cPD
			 	nPos	:= Ascan(aPensao, {|x|(	x[3] = cVerba .Or.	;
			 									x[4] = cVerba .Or.	;
			 									x[5] = cVerba .Or.	;
			 									x[6] = cVerba .Or.	;
			 									x[7] = cVerba .Or.	;
			 									x[8] = cVerba .Or.	;
			 									x[12] = cVerba .Or.	;
			 									x[14] = cVerba .Or.	;
			 									x[15] = cVerba .Or. ;
			 									x[18] = cVerba .Or. ;
			 									x[22] = cVerba)     ;
			 									.AND. (Empty(x[20]) .OR. AnoMes(x[20]) >= cDatArq); //nao possui data final ou data final maior igual ao ano da DIRF
			 									.And. !(Year(dDtPagto) # MV_PAR06)})


			    If nPos > 0
			    	nPos1 := Ascan(aPensao[nPos][21],{|x| x[1]+x[2] == Padr(cTipDirf, 2) + cMesPag})
			    	If nPos1 > 0
			    		aPensao[nPos][21][nPos1][3] += nVal
			    		aPensao[nPos][21][nPos1][4] := dDtPagto
			    	Else
			    	   	Aadd(aPensao[nPos][21], {Padr(cTipDirf, 2), cMesPag, nVal, dDtPagto})
			    	EndIf
				EndIF
			EndIf

			If cAno >= "2016" .And. Padr(cTipDirf,2) $ 'M2xM5xM xM1x9Dx9Ax9 x91xM6xM7x9Ex9Fx9Bx9CxM3xM4x'
				cVerba := cPD
			 	nPos := Ascan(aPrevi,{|x| cVerba $ x[4] .And. (empty(x[3]) .or. (MesAno(dDtPagto) >= MesAno(x[2]) .And. MesAno(dDtPagto) <= MesAno(x[3])) ) 	})

			    If nPos > 0
			    	nPos1 := Ascan(aPrevi[nPos][5],{|x| alltrim(x[1])+x[2] == alltrim(cTipDirf)+cMesPag })
			    	If nPos1 > 0
			    		aPrevi[nPos][5][nPos1][3] += nVal
			    	Else
			    	   	Aadd(aPrevi[nPos][5],{cTipDirf,cMesPag,nVal,dDtPagto})
			    	EndIf
				EndIF
			EndIf

			If cTipDirf == "I" //Rendimentos isentos e nao tributaveis
				If at( cDescri, cInfOut ) == 0
					cInfOut += If( Len( cInfOut ) > 0, ", ", "" ) + cDescri
				Endif
			Endif

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Deduz redutor da Base de IR.							³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If cCodFol $ "0408/0410/0411"
				GravaFun( cMesPag, "A", nVal*(-1), dDtPagto, cIdCmpl )
			ElseIf cCodFol == "0409"
				If !lRedutor13
					GravaFun( cMesPag, "J", nVal*(-1), dDtPagto, cIdCmpl )
					lRedutor13 := .T.
				Else
					dbSelectArea( cAliasDirf )
					RestArea( aArea )
					Return()
				EndIf
			EndIf

			// Quando ocorre Ded. Dependente (ID 0059) na Rescisão, o pagamento é integrado à Folha e caso seja regime caixa, os valores de Ded. Dependentes ficarão duplicados
			// Pois teremos a dedução com a Dt. de Pagamento da Rescisão na Folha de Pagamento (tipo G) e a dedução paga com a Dt. de Pagamento da Folha de Pagamento (tipo C),
			// neste caso, devemos desconsiderar o pagamento dessa verba pois o seu valor estará contemplado na dedução da Rescisão
			// Devemos desconsiderar também o pagamento do adiantamento caso ele existir pois na ocorrência de várias deduções no mesmo período
			// deverá ser levada apenas 1x para DIRF
			// Por Exemplo:
			// Folha de Pagamento, 05/05, tipo C - desconsiderar
			// Adiantamento, 20/25, tipo A - desconsiderar
			// Rescisão, 25/05, tipo G (gerado na Folha)
			If !Empty(SRA->RA_DEMISSA) .And. !(SRA->RA_AFASFGT $ 'N1*N2') .And.cCodFol $ "0059" .and. cTipDirf == "T"   .And.;
				  (((cAliasSRD)->RD_PERIODO == SubMesAno(SRA->RA_DEMISSA) .And. (cAliasSRD)->RD_TIPO2 = 'C' .And. (cAliasSRD)->RD_PERIODO < AnoMes(StoD((cAliasSRD)->RD_DATPGT)))  .Or.;
				  ((cAliasSRD)->RD_PERIODO == AnoMes(SRA->RA_DEMISSA) .And. (cAliasSRD)->RD_TIPO2 = 'A' .And. (cAliasSRD)->RD_PERIODO = AnoMes(StoD((cAliasSRD)->RD_DATPGT)))) .And. fDepRes(AnoMes(SRA->RA_DEMISSA), (cAliasSRD)->RD_PD)
				dbSelectArea( cAliasDirf )
				RestArea( aArea )
				Return()
			EndIf

			// VALIDA SE HOUVE MUDANÇA DE FILIAL PARA O FUNCIONARIO E SE A VERBA DO LANÇAMENTO
			// TRATA-SE DE ABONO, RESULTANDO NO ABATIMENTO DO VALOR.
			If Len(aTransf) > 0
				nx := Len(aTransf)
				If  aTransf[nX][8] <> aTransf[nX][10] .And. AnoMes(StoD((cAliasSRD)->RD_DATPGT)) <= aTransf[nx, 12] .And. (cAliasSRD)->RD_PERIODO <= aTransf[nx, 12]
					If aTransf[nx, 8] <> (cAliasSRD)->RD_FILIAL .And. cTipDirf == "0" .And. (cAliasSRD)->RD_TIPO2 == 'F'
						lAbatAbon := .T.
					Endif
				Endif
			EndIf

			// Grava no Arquivo de Movimento da DIRF SR4
			// O1 = Outros Rendimentos | 2 = Desconto
			If cTipDirf == "O1" .And. cTpCod == "2"  .or. lAbatAbon
				GravaFun(cMesPag, cTipDirf, nVal*(-1), dDtPagto, cIdCmpl, ,cCompet)
			Else
				If !(cTipDirf == "B4" .Or. cTipDirf == "B5")
					GravaFun(cMesPag, cTipDirf, nVal, dDtPagto, cIdCmpl, ,cCompet)
				Else
					nValDedSim := nVal
				EndIf
			EndIf

			//Diferenças de Abono Mes e Mes Seguinte que foram abatidas pelo ID 1449
			If cCodFol $ "0207/0208/1418/1419" .And. StrZero(Month(dDtPagto),2)== cMesPag .And. cTipDirf== "0" .And. ANOMES(dDtPagto) <> cDatArq
				GravaFun( cMesPag, "A", nVal, dDtPagto, cIdCmpl )
			Endif

			lGravouAlgum := .T.
		Else

			If cAno >= "2023"
				If cCodFol $ "0010/0015/0016/0027/0100"
					If nValDedSim == 0
						nValDedSim	:= fBscVlDed(SubStr((cAliasSRD)->RD_DATPGT,5,2), Substr((cAliasSRD)->RD_DATPGT,1,4))
					EndIf

					// 0027 - Identificador Base IRRF 13º Salário
					If cCodFol == "0027" .And. (cAliasSRD)->RD_TRIBIR == "2"
						GravaFun( cMesPag, "B5", nValDedSim, StoD((cAliasSRD)->RD_DATPGT), cIdCmpl )
					EndIf

					// Parâmetro MV_DEDSMFE - .T. (considera férias) ou .F. (não considera Férias)
					// 0010 - Identificador Base IRRF Adiantamento
					// 0015 - Identificador Base IRRF Folha
					// 0016 - Identificador Base IRRF Férias
					// 0100 - Identificador Base DIF IRRF Férias
					If cCodFol $ "0010/0015" .Or. (lDedSimplFer .And. cCodFol $ '0016/0100')
						nPosB4 := Ascan(aFunc,{ |x| x[1] = cMesPag .And. x[2] == "B4"})
						If nPosB4 > 0
							If  StoD((cAliasSRD)->RD_DATPGT) >= aFunc[nPosB4][4]
								If (cAliasSRD)->RD_TRIBIR == "2"  // Simplificada
									// Se já existe Dedução das Férias
									lExtFer 	:= aFunc[nPosB4][6] == cPdBSFer016 .Or. aFunc[nPosB4][6] == cPdBSFer100
									// Se o próximo é Dedução das Férias
									lProxFer	:= cCodFol $ '0016/0100'

									// Realizo a soma das Deduções
									If lDedSimplFer .And. lSomSimplFer .And. (lExtFer .Or. lProxFer )
										aFunc[nPosB4][3] += nValDedSim
									EndIf

									// Atualiza registro B4
									GravaFun( cMesPag, "B4", nValDedSim, StoD((cAliasSRD)->RD_DATPGT), cIdCmpl, (cAliasSRD)->RD_PD )
								ElseIf (cAliasSRD)->RD_TRIBIR == "1"
									// Se o registro B4 gravado for de Férias e possuir a mesma data de pagamento
									// do registro lido, eu NÃO EXCLUO o registro B4 de Férias
									// Como o parâmetro lDedSimplFer está .T., o modelo a ser seguido é o das Férias
									// Caso ocorra base irrf com mesma data de pagamento

									//Se o registro B4 gravado for de férias e o registro lido for de Adiantamento
									//eu NÃO Excluo o registro B4 de férias

									// Se o registro B4 gravado for de Adiantamento e possuir a mesma data de pagamento
									// do registro lido, eu EXCLUO o registro B4 de Adiantamento
									If !(StoD((cAliasSRD)->RD_DATPGT) >= aFunc[nPosB4][4] .And. (aFunc[nPosB4][6] == cPdBSFer016 .Or. aFunc[nPosB4][6] == cPdBSFer100 )) .Or.;
										(StoD((cAliasSRD)->RD_DATPGT) == aFunc[nPosB4][4] .And. aFunc[nPosB4][6] == cPdBSADI010)
										// Remove registro B4
										aDel( aFunc , nPosB4 )
										aSize( aFunc , ( Len( aFunc ) - 1 ) )
									EndIf
								EndIf
							Else
								If lDedSimplFer .And. lSomSimplFer .And. (cAliasSRD)->RD_TRIBIR == "2"  // Simplificada
									// Se já existe Dedução das Férias
									lExtFer 	:= aFunc[nPosB4][6] == cPdBSFer016 .Or. aFunc[nPosB4][6] == cPdBSFer100
									// Se o próximo é Dedução das Férias
									lProxFer	:= cCodFol $ '0016/0100'

									// Realizo a soma das Deduções
									If  lExtFer .Or. lProxFer
										aFunc[nPosB4][3] += nValDedSim
									EndIf

									// Atualiza registro B4
									GravaFun( cMesPag, "B4", nValDedSim, StoD((cAliasSRD)->RD_DATPGT), cIdCmpl, (cAliasSRD)->RD_PD )
								EndIf
							EndIf
						Else
							// Primeira gravação B4
							If (cAliasSRD)->RD_TRIBIR == "2"
								GravaFun( cMesPag, "B4", nValDedSim, StoD((cAliasSRD)->RD_DATPGT), cIdCmpl , (cAliasSRD)->RD_PD)
							EndIf
						EndIf
					EndIf
				EndIf
			EndIf
		Endif
	Endif

	RestArea( aArea )

Return()

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFuncao    ³f550DescrAss  ºAutor  ³Adrianne Furtadoº Data ³  16/12/10   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Monta a descricao da informação complementar de cada depen- º±±
±±º          ³dente de Assistencia Médica.                                º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³ cDescri   = Descrição passada por referencia.              º±±
±±º          ³ cCNPJFAss = CNPJ Complementar passado por referencia para  º±±
±±º          ³             pegar o CNPJ do fornecedor de Assist. de Saude.º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function f550DescrAss(cDescri,cCNPJFAss,lTemRateio,cAliasRAS,cVbaRAS,cGraupar,lOdoSodp,cAliasHist,lReembolso)
Local cAliasPla := ""
Local cChave	:= ""
Local cCodForn	:= ""
Local cCompAMAO := ""
Local cCompDesc := ""
Local cCPFDeAg	:= ""
Local cNomeDeAg	:= ""
Local cNomeForn := ""
Local cPrefix	:= ""
Local cTabPlano := ""
Local cTabForn  := ""
Local lAchou 	:= .F.
Local lAltDescr := .F.
Local nTamCPl	:= TamSX3("RHN_PLANO")[1]
Local nTamTPl	:= TamSX3("RHN_TPPLAN")[1]
Local nLimDesc	:= TamSX3("RCS_DESCRI")[1] - 27
Local cOriRHN := RHN->RHN_OPERAC
Local lOk		:= .T.
Local cRotFol	:= ""
Local nPosForn	:= 0
Local cFilForn	:= ""

Default cAliasHist 	:= "SRDRHS"+cEmpAnt
Default lReembolso  := .F.
Default lTemRateio	:= .F.

cAliasPla := cAliasHist

//Monta o prefixo do campo pois o processo e' executado para as tabelas RHS e RHP
If cAliasHist == "SRDRHS"+cEmpAnt
	cPrefix	:= "RHS_"
ElseIf cAliasHist == "QRHS"
	cPrefix	:= "RHS_"
ElseIf cAliasHist == "QRHP"
	cPrefix	:= "RHP_"
Else
	cPrefix	:= cAliasPla + "_"
EndIf

//Verifica o tipo de fornecedor da assistencia/odonto
If (cAliasPla)->( &(cPrefix+"TPFORN") ) == "1"//Assistencia Medica
	cCompAMAO	:= "MED"
	cCompDesc	:= " - Ass.Medica - "
	cTabForn 	:= "S016"//Tabela do Fornecedor de Assistencia Medica
Else//Assistencia Odontologica
	cCompAMAO	:= "ODO"
	cCompDesc	:= " - Ass.Odontol. - "
	cTabForn 	:= "S017"//Tabela do Fornecedor de Assistencia Odontologica
EndIf

//Verifica a origem do lancamento da assistencia medica/odonto
If (cAliasPla)->( &(cPrefix+"ORIGEM") ) == "1"//E' o funcionario
	cCodForn	:= (cAliasPla)->( &(cPrefix+"CODFOR") )
	cGraupar 	:= "T" + cCompAMAO
ElseIf (cAliasPla)->( &(cPrefix+"ORIGEM") ) == "2"//E' o dependente
	//primeiro verifica se existe o dependente no cadastro de dependente
	DbSelectArea("SRB")
	SRB->(DBSetOrder(1))
	SRB->(MsSeek((cAliasPla)->( ( &(cPrefix+"FILIAL") ) + ( &(cPrefix+"MAT") ) )))

	// posiciona no primeiro dependente desse funcionario
	While SRB->(RB_FILIAL+RB_MAT) == (cAliasPla)->( ( &(cPrefix+"FILIAL") ) + ( &(cPrefix+"MAT") ) )  .and. !lAchou
		If SRB->RB_COD == (cAliasPla)->( &(cPrefix+"CODIGO") )
			cCodForn	:= (cAliasPla)->( &(cPrefix+"CODFOR") )
			cCPFDeAg	:= SRB->RB_CIC
			cGraupar    := AllTrim(SRB->RB_GRAUPAR) + cCompAMAO
			cGraupar    += SRB->RB_COD
			cNomeDeAg	:= SRB->RB_NOME
			cVbaRAS		:= (cAliasPla)->( &(cPrefix+"PD") )
			lAchou 		:= .T.
			lAltDescr	:= .T.
		Else
			SRB->(DbSkip())
		EndIf
	EndDo
ElseIf (cAliasPla)->( &(cPrefix+"ORIGEM") ) == "3"// E' o agregado
	//primeiro verifica se existe no cadastro novo de plano de saude
	DbSelectArea("RHM")
	DbSetOrder( RetOrdem( "RHM", "RHM_FILIAL+RHM_MAT+RHM_TPFORN+RHM_CODFOR+RHM_CODIGO" ) )
	If MsSeek( (cAliasPla)->( ( &(cPrefix+"FILIAL") ) + ( &(cPrefix+"MAT") ) + ( &(cPrefix+"TPFORN") ) + ( &(cPrefix+"CODFOR") ) + ( &(cPrefix+"CODIGO") ) ), .F. )
		cCodForn	:= (cAliasPla)->( &(cPrefix+"CODFOR") )
		cCPFDeAg	:= RHM->RHM_CPF
		cGraupar    := "A" + cCompAMAO
		cGraupar    += RHM->RHM_CODIGO
		cNomeDeAg	:= RHM->RHM_NOME
		cVbaRAS		:= (cAliasPla)->( &(cPrefix+"PD") )
		lAchou 		:= .T.
		lAltDescr	:= .T.
	EndIf

	//se nao encontrar, procura o agregado no historico
	If !lAchou
		DbSelectArea("RHN")
		RHN->(DBSeek((cAliasPla)->( ( &(cPrefix+"FILIAL") ) + ( &(cPrefix+"MAT") ) )))
		If cAliasPla $ "QRHS*RHS"
			If cOriRHN == "1"
				cChave :=  "1" + "3" + (cAliasPla)->( &(cPrefix+"CODIGO") ) + (cAliasPla)->( &(cPrefix+"TPFORN") ) + (cAliasPla)->( &(cPrefix+"TPPLAN") ) + (cAliasPla)->( &(cPrefix+"PLANO") )
			Else
				cChave :=  "2" + "3" + (cAliasPla)->( &(cPrefix+"CODIGO") ) + (cAliasPla)->( &(cPrefix+"TPFORN") ) + (cAliasPla)->( &(cPrefix+"TPPLAN") ) + (cAliasPla)->( &(cPrefix+"PLANO") )
			Endif
       ElseIf cAliasPla $ "QRHP*RHP"
			If cOriRHN == "1"
				cChave :=  "1" + "3" + (cAliasPla)->( &(cPrefix+"CODIGO") ) + (cAliasPla)->( &(cPrefix+"TPFORN") ) + Space(nTamTPl) + Space(nTamCPl)
			Else
				cChave :=  "2" + "3" + (cAliasPla)->( &(cPrefix+"CODIGO") ) + (cAliasPla)->( &(cPrefix+"TPFORN") ) + Space(nTamTPl) + Space(nTamCPl)
			Endif
       EndIf
		While RHN->(RHN_FILIAL+RHN_MAT) == (cAliasPla)->( ( &(cPrefix+"FILIAL") ) + ( &(cPrefix+"MAT") ) ) .and. !lAchou
			If RHN->RHN_OPERAC + RHN->RHN_ORIGEM + RHN->RHN_CODIGO + RHN->RHN_TPFORN + RHN->RHN_TPPLAN + RHN->RHN_PLANO == cChave
				cCodForn	:= (cAliasPla)->( &(cPrefix+"CODFOR") )
				cGraupar    := "A" + cCompAMAO
				cGraupar    += RHN->RHN_CODIGO
				cNomeDeAg	:= RHN->RHN_NOME
				cVbaRAS		:= (cAliasPla)->( &(cPrefix+"PD") )
				lAchou 		:= .T.
				lAltDescr	:= .T.
			Else
				RHN->(DbSkip())
			EndIf
		EndDo
	EndIf

	//se nao encontrar, procura o agregado no cadastro de dependente
	If !lAchou
		DbSelectArea("SRB")
		SRB->(DBSetOrder(1))
		SRB->(DBSeek((cAliasPla)->( ( &(cPrefix+"FILIAL") ) + ( &(cPrefix+"MAT") ) )))

		// posiciona no primeiro dependente desse funcionario
		While SRB->(RB_FILIAL+RB_MAT) == (cAliasPla)->( ( &(cPrefix+"FILIAL") ) + ( &(cPrefix+"MAT") ) ) .and. !lAchou
			//verifica dependente com mesmo codigo do lancamento e que seja de grau de parentesto 'O'
			If SRB->RB_COD == (cAliasPla)->( &(cPrefix+"CODIGO") ) .And. AllTrim(SRB->RB_GRAUPAR) == "O"
				cCodForn	:= (cAliasPla)->( &(cPrefix+"CODFOR") )
				cCPFDeAg	:= SRB->RB_CIC
				cGraupar    := AllTrim(SRB->RB_GRAUPAR) + cCompAMAO
				cGraupar    += SRB->RB_COD
				cNomeDeAg	:= SRB->RB_NOME
				cVbaRAS		:= (cAliasPla)->( &(cPrefix+"PD") )
				lAchou 		:= .T.
				lAltDescr	:= .T.
			Else
				SRB->(DbSkip())
			EndIf
		EndDo
	EndIf
EndIf

If !Empty(cCodForn)

	// Valida se pagamento não foi realizado em Folha em outro período
	lOk := fVldFol((cAliasPla)->(&(cPrefix+"COMPPG")) , (cAliasPla)->( &(cPrefix+"PD")), cAno)

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Busca os dados do Fornecedor de Assistencia Medica/Odonto³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lOk
		cFilForn	:= (cAliasPla)->( &(cPrefix+"FILIAL"))
		nPosForn	:= Ascan(aTabForn,{ |x| AllTrim(x[1]) == cTabForn .And. AllTrim(x[2]) == AllTrim(cFilForn) .And. x[5] == cCodForn })
		If nPosForn == 0 // Se não encontrou na filial do funcionário, busca fornecedor com a filial em branco
			nPosForn	:= Ascan(aTabForn,{ |x| AllTrim(x[1]) == cTabForn .And. Empty(x[2]) .And. x[5] == cCodForn })
		EndIf
		If nPosForn > 0
			cNomeForn 	:= AllTrim( aTabForn[nPosForn][6] )
			cCNPJFAss 	:= aTabForn[nPosForn][7]
		EndIf
		cNomeDeAg	:= AllTrim(cNomeDeAg)

		If lAltDescr// Se verdadeiro indica assistencia medica/odonto de DEPENDENTE/AGREGADO
			cDescri := cDescri + " / " + cNomeDeAg + " / CPF: " + Transform(cCPFDeAg, "@R ###.###.###-##")
			cDescri += cCompDesc
		Else// Caso contrario indica assistencia medica/odonto do TITULAR
			cDescri += Space( 30 - Len( cDescri ) ) + " - TITULAR - "
		EndIf

		// Completa a informacao da assistencia medica/odonto
		cDescri += cNomeForn
		cDescri := If( Len(cDescri) > nLimDesc, PadR(cDescri, nLimDesc), cDescri )
		cDescri += " - CNPJ: " + Transform(cCNPJFAss, "@R ##.###.###/####-##")
		If lReembolso
			cGraupar += "REEMBOLSO"
		EndIf
	EndIf
EndIf

Return(lOk)


/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFuncao    ³fImpHistRat    ºAutor  ³Allyson M 	 º Data ³  28/01/12   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Realiza importacao do historico do plano de saude para as   º±±
±±º          ³tabelas RHS e EHP.                                          º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³                                                            º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function fImpHistRat()

Local cAliasArq 	:= cAliasRAS
Local aArea			:= GetArea()
Local cDataAux 		:= ""
Local cDtHrGrv		:= ""
Local cFilSRV		:= ""
Local cHoraAux		:= ""
Local cOrigem		:= ""
Local cTextoLog		:= ""
Local lAchou		:= .F.
Local lGrava		:= .T.
Local lRet			:= .T.
Local nContGrv0		:= 0		// Contador de Registros Gravados Plano
Local nContGrv1		:= 0		// Contador de Registros Gravados Co-Part/Reembolso  Plano
Local nContLidT		:= 0		// Contador de Registros Lidos Total
Local nContGrvT		:= 0		// Contador de Registros Gravados Total

// Valida se deseja efetuar importacao do SRDRHS.dbf para o RHs/RHP
If MsgYesNo( OemToAnsi(STR0048)+ CRLF + ;//"Existem informações do rateio do plano de assistência médica e odontológica."
			 OemToAnsi(STR0049) )//"Deseja efetuar a importação dos dados para o histórico?"
	(cAliasArq)->( dbGoTop() )

	aAdd( aTitle, OemToAnsi(STR0050) )//"Log da Importação do Rateio dos Planos de Saude das Empresas para o Histórico"
	aAdd( aLog, {} )
	aTotRegs[11] := Len(aLog)

	aAdd( aTitle, OemToAnsi(STR0051) )//"Registros processados da Importação do Rateio dos Planos de Saude das Empresas para o Histórico"
	aAdd( aLog, {} )
	aTotRegs[12] := Len(aLog)

	While (cAliasArq)->( !EoF() )

		nContLidT++
		aAdd(aLog[aTotRegs[12]], "" )
        cTextoLog := OemToAnsi(STR0052) + (cAliasArq)->RHS_FILIAL + OemToAnsi(STR0053) + (cAliasArq)->RHS_MAT + OemToAnsi(STR0054) + (cAliasArq)->RHS_PD + OemToAnsi(STR0055) + DtoC( (cAliasArq)->RHS_DATA ) + OemToAnsi(STR0056) + Transform( (cAliasArq)->RHS_VLRFUN, "@E 999,999.99" ) + ')'//"- Registro lido (Fil: "##" Matr: "##" Verba: "##" Data Pagto: "##" Valor: R$ "
		aAdd(aLog[aTotRegs[12]], cTextoLog )
		lAchou 	:= .F.
		lGrava	:= .T.
		lRet 	:= .T.

		//Tratamento para corrigir campo RHS_ORIGEM do arquivo temporario que foi gerado incorretamente quando
		//lancamento refere-se a dependente.
		If !Empty( (cAliasArq)->RHS_CODIGO ) .And. (cAliasArq)->RHS_ORIGEM == "1"
			DbSelectArea( "SRB" )
			DbSetOrder( 1 )
			If DbSeek( (cAliasArq)->(RHS_FILIAL + RHS_MAT), .F. )
				While SRB->( !EOF() ) .and. SRB->(RB_FILIAL + RB_MAT) == (cAliasArq)->(RHS_FILIAL + RHS_MAT)
					If SRB->RB_COD == (cAliasArq)->RHS_CODIGO
						lAchou := .T.
						Exit
					EndIf
					SRB->( DbSkip() )
				EndDo
            EndIf
            If lAchou
            	If (cAliasArq)->RHS_TPFORN == "1"//Medica
	            	cOrigem := SRB->RB_TPDEPAM
            	Else//Odonto
               		cOrigem := SRB->RB_TPDPODO
            	EndIf

            	(cAliasArq)->( RecLock( (cAliasArq), .F. ) )
            	(cAliasArq)->RHS_ORIGEM := If(cOrigem == '1', '2', '3')//2=Dependente; 3=Agregado
            	(cAliasArq)->( MsUnLock() )
            EndIf
		EndIf

		//--Realiza validacao na importacao dos registros
		Begin Sequence
			//--Validacao da existencia do funcionario no cadastro de funcionarios
			DbSelectArea( 'SRA' )
			DbSetOrder( 1 )			// RA_FILIAL+RA_MAT
			If !DbSeek( (cAliasArq)->(RHS_FILIAL+RHS_MAT) )
	            cTextoLog := OemToAnsi(STR0085) + OemToAnsi(STR0057) + (cAliasArq)->RHS_FILIAL  + OemToAnsi(STR0058) + (cAliasArq)->RHS_MAT  + OemToAnsi(STR0059)//"  -> Não Gravado."##" Filial: "##" Matrícula: "##" não encontrada no Cad. de Funcionário."
				aAdd(aLog[aTotRegs[12]], cTextoLog )
				lRet := .F.
				Break
			EndIf
			//--Validacao de lancto de dependente e campo origem igual a 1 (titular)
			If !Empty( (cAliasArq)->RHS_CODIGO ) .And. (cAliasArq)->RHS_ORIGEM == "1"
	            cTextoLog := OemToAnsi(STR0085) + OemToAnsi(STR0086) + CRLF//" Campo Código do Dep/Agr. preenchido porém campo Origem igual a 1 (titular)."
	            cTextoLog += OemToAnsi(STR0087)//"     Campo Origem dever ser preenchido com 2 (Dependente) ou 3 (Agregado)."
				aAdd(aLog[aTotRegs[12]], cTextoLog )
				lRet := .F.
				Break
			EndIf
			//--Validacao da existencia do dependente
			If !Empty( (cAliasArq)->RHS_CODIGO )
				lRet := .F.
				DbSelectArea( "SRB" )
				DbSetOrder( 1 )
				If DbSeek( (cAliasArq)->(RHS_FILIAL + RHS_MAT), .F. )
					While SRB->( !EOF() ) .and. SRB->(RB_FILIAL + RB_MAT) == (cAliasArq)->(RHS_FILIAL + RHS_MAT)
						If SRB->RB_COD == (cAliasArq)->RHS_CODIGO
							lRet := .T.
							Exit
						EndIf
						SRB->( DbSkip() )
					EndDo
	            EndIf
	            If !lRet
		            cTextoLog := OemToAnsi(STR0085) + OemToAnsi(STR0057) + (cAliasArq)->RHS_FILIAL  + OemToAnsi(STR0058) + (cAliasArq)->RHS_MAT  + OemToAnsi(STR0060) + (cAliasArq)->RHS_CODIGO  + OemToAnsi(STR0061)//"  -> Não Gravado."##" Filial: "##" Matrícula: "##". Dependente: "##" não encontrado."
					aAdd(aLog[aTotRegs[12]], cTextoLog )
					Break
				EndIf
			EndIf
			//--Validacao da origem do lancto do plano de saude
			If !((cAliasArq)->RHS_ORIGEM $ "1*2*3")
	            cTextoLog := OemToAnsi(STR0085) + OemToAnsi(STR0062) + (cAliasArq)->RHS_ORIGEM  + OemToAnsi(STR0063)//"  -> Não Gravado."##" Origem: "". Origem inválida. Deve ser dos tipos 1 (Titular), 2 (Dependente) ou 3 (Agregado)."##
				aAdd(aLog[aTotRegs[12]], cTextoLog )
				lRet := .F.
				Break
			EndIf
			//--Validacao do tipo de assistencia
			If !((cAliasArq)->RHS_TPLAN $ "1*2*3")
	            cTextoLog := OemToAnsi(STR0085) + OemToAnsi(STR0064) + (cAliasArq)->RHS_TPLAN + OemToAnsi(STR0065) + AllTrim(OemToAnsi(STR0066))//"  -> Não Gravado."##" Tp Assist.: "##". Tipo de assistência inválida. Deve ser dos tipos 1 (Plano), 2 (Co-participação)"##"     ou 3 (Reembolso)."
				aAdd(aLog[aTotRegs[12]], cTextoLog )
				lRet := .F.
				Break
			EndIf
			//--Validacao do tipo do fornecedor do plano
			If !((cAliasArq)->RHS_TPFORN $ "1*2")
	            cTextoLog := OemToAnsi(STR0085) + OemToAnsi(STR0067) + (cAliasArq)->RHS_TPFORN  +OemToAnsi(STR0068) //"  -> Não Gravado."##" Tp Fornecedor: "##". Tipo do fornecedor inválido. Deve ser dos tipos 1 (Médica) ou 2 (Odonto.)."
				aAdd(aLog[aTotRegs[12]], cTextoLog )
				lRet := .F.
				Break
			EndIf
			//--Validacao do tipo do plano
			If !((cAliasArq)->RHS_TPPLAN $ "1*2*3*4")
	            cTextoLog := OemToAnsi(STR0085) + OemToAnsi(STR0069) + (cAliasArq)->RHS_TPPLAN  + OemToAnsi(STR0070) + CRLF//"  -> Não Gravado."##" Tp Plano: "##". Tipo do plano inválido. Deve ser dos tipos 1 (Fx. Salarial), 2 (Fx. Etária), 3 (Vl. Fixo)"
	            cTextoLog += OemToAnsi(STR0071)//"     ou 4 (% S/ Salário)."
				aAdd(aLog[aTotRegs[12]], cTextoLog )
				lRet := .F.
				Break
			EndIf
			//--Validacao da verba
			If !Empty( (cAliasArq)->RHS_PD )
				cFilSRV := xFilial( "SRV", (cAliasArq)->RHS_FILIAL  )
				DbSelectArea( 'SRV' )
				DbSetOrder( 1 )			// RV_FILIAL+RV_COD
				If !dbSeek( cFilSRV + (cAliasArq)->RHS_PD )
		            cTextoLog := OemToAnsi(STR0085) + OemToAnsi(STR0072) + (cAliasArq)->RHS_PD  + OemToAnsi(STR0073)//"  -> Não Gravado."##". Verba: "##" não encontrada."
					aAdd(aLog[aTotRegs[12]], cTextoLog )
					lRet := .F.
					Break
				EndIf
			EndIf
			//--Validacao do fornecedor
			If !fValForRHS( (cAliasArq)->RHS_CODFOR, (cAliasArq)->RHS_FILIAL, (cAliasArq)->RHS_TPFORN )
	            cTextoLog := OemToAnsi(STR0085) + OemToAnsi(STR0074) + (cAliasArq)->RHS_TPFORN + OemToAnsi(STR0075) + (cAliasArq)->RHS_CODFOR  + '.'//"  -> Não Gravado."##". Código do Fornecedor não encontrado. Tp Fornecedor: "##" Fornecedor: "
				aAdd(aLog[aTotRegs[12]], cTextoLog )
				lRet := .F.
				Break
			EndIf
			//--Validacao do codigo do plano
			If !fValPlaRHS( (cAliasArq)->RHS_TPFORN, (cAliasArq)->RHS_CODFOR, (cAliasArq)->RHS_TPPLAN, (cAliasArq)->RHS_PLANO )
	            cTextoLog := OemToAnsi(STR0085) + OemToAnsi(STR0076) + (cAliasArq)->RHS_TPFORN + OemToAnsi(STR0077) + (cAliasArq)->RHS_CODFOR  + OemToAnsi(STR0078) + (cAliasArq)->RHS_TPPLAN + OemToAnsi(STR0079) + (cAliasArq)->RHS_PLANO + '.'///"  -> Não Gravado."##". Código do Plano não encontrado. Tp Fornecedor: "##" Fornecedor: "##" Tp. Plano: "##" Cod. Plano: "
				aAdd(aLog[aTotRegs[12]], cTextoLog )
				lRet := .F.
				Break
			EndIf
		End Sequence

		If lRet
			If (cAliasArq)->RHS_TPLAN == "1"//Plano
				DbSelectArea( "RHS" )
		 		If !RHS->( dbSeek( (cAliasArq)->(RHS_FILIAL+RHS_MAT+RHS_COMPPG+RHS_ORIGEM+RHS_CODIGO+RHS_TPLAN+RHS_TPFORN+RHS_CODFOR+RHS_TPPLAN+RHS_PLANO+RHS_PD) ) )
	 				RHS->( RecLock( "RHS", .T. ) )	// Cria novo registro se nao existir
	 			Else
	 				If !Empty(RHS->RHS_DTHRGR)
		 				RHS->( RecLock( "RHS", .F. ) )	// Atualiza registro se existir
		 			Else
		 				lGrava := .F.
		 			EndIf
	 			EndIf

				If lGrava
					cDataAux := DtoS(MsDate())
					cHoraAux := Time()
					cDtHrGrv := SUBSTR(cDataAux,3,2) + SUBSTR(cDataAux,5,2) + SUBSTR(cDataAux,7,2) + SUBSTR(cHoraAux,1,2) + SUBSTR(cHoraAux,4,2) //-- AAMMDDHHMM
					RHS->RHS_DTHRGR		:= cDtHrGrv
					RHS->RHS_FILIAL		:= (cAliasArq)->RHS_FILIAL
					RHS->RHS_MAT		:= (cAliasArq)->RHS_MAT
					RHS->RHS_DATA		:= (cAliasArq)->RHS_DATA
					RHS->RHS_DATPGT		:= (cAliasArq)->RHS_DATA
					RHS->RHS_ORIGEM		:= (cAliasArq)->RHS_ORIGEM			// 1 = Titular; 2 = Dependente; 3 = Agregado
					RHS->RHS_CODIGO		:= (cAliasArq)->RHS_CODIGO
					RHS->RHS_TPLAN		:= (cAliasArq)->RHS_TPLAN			// 1-Plano, 2-Co-Partic., 3-Reembolso
					RHS->RHS_TPFORN		:= (cAliasArq)->RHS_TPFORN	   		// 1-Assist. Medica, 2-Assist. Odontologica
					RHS->RHS_CODFOR 	:= (cAliasArq)->RHS_CODFOR
					RHS->RHS_TPPLAN		:= (cAliasArq)->RHS_TPPLAN			// 1 - Salarial, 2 - Etaria, 3 - Vlr. Fixo, 4 - % sobre saláro
					RHS->RHS_PLANO		:= (cAliasArq)->RHS_PLANO
					RHS->RHS_PD			:= (cAliasArq)->RHS_PD
					RHS->RHS_VLRFUN		:= (cAliasArq)->RHS_VLRFUN
					RHS->RHS_VLREMP		:= (cAliasArq)->RHS_VLREMP
					RHS->RHS_COMPPG		:= (cAliasArq)->RHS_COMPPG

					RHS->( MsUnLock() )

					nContGrv0++
					nContGrvT++
			        cTextoLog := OemToAnsi(STR0080) + (cAliasArq)->RHS_FILIAL + OemToAnsi(STR0053) + (cAliasArq)->RHS_MAT + OemToAnsi(STR0054) + (cAliasArq)->RHS_PD + OemToAnsi(STR0055) + DtoC( (cAliasArq)->RHS_DATA ) + OemToAnsi(STR0056) + Transform( (cAliasArq)->RHS_VLRFUN, "@E 999,999.99" ) + ")"//"  -> Registro gravado (Fil: "##" Matr: "##" Verba: "##" Data Pagto: "##" Valor: R$ "
					aAdd( aLog[aTotRegs[12]], cTextoLog )
				Else
			        cTextoLog := OemToAnsi(STR0085) + OemToAnsi(STR0088)///"  -> Não Gravado."##" Registro foi originado do cálculo do plano de saúde."
					aAdd( aLog[aTotRegs[12]], cTextoLog )
				EndIf
		 	Else//Co-participacao / reembolso
				DbSelectArea( "RHP" )
				DbSetOrder( 2 )

	 			If !RHP->( dbSeek( (cAliasArq)->(RHS_FILIAL+RHS_MAT+RHS_COMPPG+RHS_ORIGEM+RHS_CODIGO+RHS_TPLAN+RHS_TPFORN+RHS_CODFOR+RHS_PD) ) )
	 				RHP->( RecLock( "RHP", .T. ) )	// Cria novo registro se nao existir
	 			Else
	 				If !Empty(RHP->RHP_DTHRGR)
		 				RHP->( RecLock( "RHP", .F. ) )	// Atualiza registro se existir
		 			Else
		 				lGrava := .F.
		 			EndIf
	 			EndIf

				If lGrava
					cDataAux := DtoS(MsDate())
					cHoraAux := Time()
					cDtHrGrv := SUBSTR(cDataAux,3,2) + SUBSTR(cDataAux,5,2) + SUBSTR(cDataAux,7,2) + SUBSTR(cHoraAux,1,2) + SUBSTR(cHoraAux,4,2) //-- AAMMDDHHMM
					RHP->RHP_DTHRGR		:= cDtHrGrv
					RHP->RHP_FILIAL		:= (cAliasArq)->RHS_FILIAL
					RHP->RHP_MAT		:= (cAliasArq)->RHS_MAT
					RHP->RHP_DTOCOR		:= (cAliasArq)->RHS_DATA
					RHP->RHP_DATPGT		:= (cAliasArq)->RHS_DATA
					RHP->RHP_ORIGEM		:= (cAliasArq)->RHS_ORIGEM			// 1 = Titular; 2 = Dependente; 3 = Agregado
					RHP->RHP_TPFORN		:= (cAliasArq)->RHS_TPFORN	   		// 1-Assist. Medica, 2-Assist. Odontologica
					RHP->RHP_CODFOR		:= (cAliasArq)->RHS_CODFOR
					RHP->RHP_CODIGO		:= (cAliasArq)->RHS_CODIGO
					RHP->RHP_TPLAN		:= (cAliasArq)->RHS_TPLAN			// 1-Plano, 2-Co-Partic., 3-Reembolso
					RHP->RHP_PD			:= (cAliasArq)->RHS_PD
					RHP->RHP_VLRFUN		:= (cAliasArq)->RHS_VLRFUN
					RHP->RHP_VLREMP		:= (cAliasArq)->RHS_VLREMP
					RHP->RHP_COMPPG		:= (cAliasArq)->RHS_COMPPG
					RHP->RHP_OBSERV		:= ""

					RHP->( MsUnLock() )

					nContGrv1++
					nContGrvT++
			        cTextoLog := OemToAnsi(STR0080) + (cAliasArq)->RHS_FILIAL + OemToAnsi(STR0053) + (cAliasArq)->RHS_MAT + OemToAnsi(STR0054) + (cAliasArq)->RHS_PD + OemToAnsi(STR0055) + DtoC( (cAliasArq)->RHS_DATA ) + OemToAnsi(STR0056) + Transform( (cAliasArq)->RHS_VLRFUN, "@E 999,999.99" ) + ")"//"  -> Registro gravado (Fil: "##" Matr: "##" Verba: "##" Data Pagto: "##" Valor: R$ "
					aAdd( aLog[aTotRegs[12]], cTextoLog )
				Else
			        cTextoLog := OemToAnsi(STR0085) + OemToAnsi(STR0088)///"  -> Não Gravado."##" Registro foi originado do cálculo do plano de saúde."
					aAdd( aLog[aTotRegs[12]], cTextoLog )
				EndIf
		 	EndIf
        EndIf

	 	(cAliasArq)->( dbSkip() )

	EndDo

	aAdd(aLog[aTotRegs[11]], OemToAnsi(STR0081) + cValToChar(nContLidT) )//"- Total de registros lidos - Total : "
	aAdd(aLog[aTotRegs[11]], OemToAnsi(STR0082) + cValToChar(nContGrvT) )//"- Total de registros gravados - Total : "
	aAdd(aLog[aTotRegs[11]], OemToAnsi(STR0083) + cValToChar(nContGrv0) )//"- Total de registros gravados - Plano de Saúde : "
	aAdd(aLog[aTotRegs[11]], OemToAnsi(STR0084) + cValToChar(nContGrv1) )//"- Total de registros gravados - Co-Part./Reembolso de Plano de Saúde : "

EndIf

RestArea(aArea)

Return(Nil)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³ fValForRHS º Autor ³ TOTVS			 º Data ³ 02/02/2012  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Validacao de Fornecedores de Assist. Medica / Odontol.	  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ GPEM550                                                 	  º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function fValForRHS( cConteudo, cFilOrigem, cTpForn )

Local aArea		:= GetArea()
Local lRet		:= .F.
Local nPosIni	:= 1
Local nLenCod
Local nOrdem
Local nX		:= 1
Local cCodTab	:= ""

If cTpForn == "1"
	cCodTab := "S016"
ElseIf cTpForn == "2"
	cCodTab := "S017"
EndIf

RCB->( dbSetOrder( 3 ) )
RCB->( dbSeek( xFilial( "RCB" ) + "CODIGO    " + cCodTab ) )

nLenCod	:= RCB->RCB_TAMAN
nOrdem	:= Val( RCB->RCB_ORDEM )

RCB->( dbSetOrder( 1 ) )
RCB->( dbSeek( xFilial( "RCB" ) + cCodTab ) )

While nX < nOrdem .and. RCB->RCB_CODIGO == cCodTab

	If Val( RCB->RCB_ORDEM ) < nOrdem
		nPosIni += RCB->RCB_TAMAN
		nX ++
	EndIf
	RCB->( DbSkip() )
EndDo

RCC->( dbSetOrder( 1 ) )

If RCC->( dbSeek( xFilial( "RCC" ) + cCodTab ) )
	While RCC->RCC_CODIGO == cCodTab .and. ! lRet
		If cConteudo == SubStr( RCC->RCC_CONTEU, nPosIni, nLenCod ) .and. ( Empty( RCC->RCC_FIL ) .or. RCC->RCC_FIL == cFilOrigem )
			lRet := .T.
		EndIf
		RCC->( DbSkip() )
	EndDo
EndIf

RestARea( aArea )

Return(lRet)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³ fValPlaRHS º Autor ³ TOTVS			   º Data ³ 02/02/2012	º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDescricao ³ Validacao do Plano de Saude.									º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ GPEM550                                                      º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function fValPlaRHS( cTpForn, cCodFor, cTpPlano, cCodPlano )

Local cCodTab := ""
Local lRet 	  := .T.
Local nColFor := 0
Local nPosTab

If cTpForn == "1"
	If cTpPlano == "1"
		cCodTab := "S008"
		nColFor := 13
	ElseIf cTpPlano == "2"
		cCodTab := "S009"
		nColFor := 13
	ElseIf cTpPlano == "3"
		cCodTab := "S028"
		nColFor := 12
	ElseIf cTpPlano == "4"
		cCodTab := "S029"
		nColFor := 15
	EndIf
ElseIf cTpForn == "2"
	If cTpPlano == "1"
		nColFor := 13
		cCodTab := "S013"
	ElseIf cTpPlano == "2"
		cCodTab := "S014"
		nColFor := 13
	ElseIf cTpPlano == "3"
		cCodTab := "S030"
		nColFor := 12
	ElseIf cTpPlano == "4"
		cCodTab := "S031"
		nColFor := 15
	EndIf
EndIf

nPosTab := fPosTab( cCodTab, cCodFor, "=", nColFor, cCodPlano, "=", 4 )

If nPosTab <= 0
	lRet := .F.
EndIf

Return( lRet )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFuncao    ³fCorHistDat    ºAutor  ³Allyson M 	 º Data ³  04/02/12   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Realiza correcao da data de pagamento do historico de plano º±±
±±º          ³e co-parti/reembolso, com a data de pagamento do SRD.       º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³                                                            º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function fCorHistDat()

Local cAliasRHS := GetNextAlias()
Local cAliasRHP := GetNextAlias()

 /*RHS*/

cQuery := "SELECT RHS.R_E_C_N_O_ RHSRECNO, RD_DATPGT "
cQuery += "FROM " + RetSqlName("RHS") + " RHS "
cQuery += "join " + RetSqlName("SRD") + " SRD ON "
cQuery += "RHS.RHS_FILIAL = SRD.RD_FILIAL AND "
cQuery += "RHS.RHS_MAT = SRD.RD_MAT AND "
cQuery += "RHS.RHS_COMPPG = SRD.RD_DATARQ AND "
cQuery += "RHS.RHS_PD = SRD.RD_PD"
cQuery += "WHERE RHS.RHS_DATPGT= '        ' AND "
cQuery += "RHS.D_E_L_E_T_=' ' AND SRD.D_E_L_E_T_=' '"

cQuery := ChangeQuery(cQuery)

dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasRHS,.T.,.T.)
TcSetField( cAliasRHS, "RHSRECNO", "N", 10, 0 )
dbSelectArea(cAliasRHS)

While (cAliasRHS)->(!Eof())

	dbSelectArea("RHS")
	dbGoto((cAliasRHS)->RHSRECNO)

	RHS->( RecLock( "RHS", .F. ) )
	RHS->RHS_DATPGT := (cAliasRHS)->RD_DATPGT
	RHS->( MsUnLock() )

	(cAliasRHS)->( dbSkip() )

EndDo

/*RHP*/

cQuery := "SELECT RHP.R_E_C_N_O_ RHPRECNO, RD_DATPGT "
cQuery += "FROM " + RetSqlName("RHP") + " RHP "
cQuery += "join " + RetSqlName("SRD") + " SRD ON "
cQuery += "RHP.RHP_FILIAL = SRD.RD_FILIAL AND "
cQuery += "RHP.RHP_MAT = SRD.RD_MAT AND "
cQuery += "RHP.RHP_COMPPG = SRD.RD_DATARQ AND "
cQuery += "RHP.RHP_PD = SRD.RD_PD"
cQuery += "WHERE RHP.RHP_DATPGT= '        ' AND "
cQuery += "RHP.D_E_L_E_T_=' ' AND SRD.D_E_L_E_T_=' '"

cQuery := ChangeQuery(cQuery)

dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasRHP,.T.,.T.)
TcSetField( cAliasRHP, "RHPRECNO", "N", 10, 0 )

dbSelectArea(cAliasRHP)

While (cAliasRHP)->(!Eof())

	dbSelectArea("RHP")
	dbGoto((cAliasRHP)->RHPRECNO)

	RHP->( RecLock( "RHP", .F. ) )
	RHP->RHP_DATPGT := Stod((cAliasRHP)->RD_DATPGT)
	RHP->( MsUnLock() )

	(cAliasRHP)->( dbSkip() )

EndDo

Return(Nil)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFuncao    ³fLeRCA         ºAutor  ³Marcia M 	     º Data ³  18/12/12   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Leitura dos mnemonicos                                      º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³                                                            º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function fLeRCA()

Local aAreaRCA 	:= RCA->( GetArea() )

RCA->( dbSetOrder( 1 ) )

nPRca1 := 0.10
If RCA->( dbSeek(xfilial("RCA", SRA->RA_FILIAL) + AllTrim('NPERBCIR1') ) )
	If Val(RCA->RCA_CONTEU) <>0
		nPRca1 := Val(RCA->RCA_CONTEU)
	EndIf
EndIf

nPRca2 := 0.60
If RCA->( dbSeek(xfilial("RCA", SRA->RA_FILIAL) + AllTrim('NPERBCIR2') ) )
	If Val(RCA->RCA_CONTEU) <>0
		nPRca2 := Val(RCA->RCA_CONTEU)
	EndIf
EndIf

RestArea( aAreaRCA )

Return( nPRca1,nPRca2)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFuncao    ³LimpaDIRF      ºAutor  ³Microsiga      º Data ³  15/01/14   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Limpar o arquivo da DIRF                                    º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³                                                            º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function LimpaDIRF(lLimpaTudo)
Local cQuery 		:= ''
Local cQueryAlias 	:= ''
Local cChave 		:= ''
Local cDBName		:= ''
local cJoinAdic		:= ''
Local nMax   		:= 0
Local nMin   		:= 0
Local nPont 		:= 0
Local nx            := 0

//Verifica o tipo de banco
cDBName	:= Upper(TcGetDb())

If cDBName $ "INFORMIX"
	cJoinAdic	:= "% R4_CODRET = NVL(RA_CODRET,'0561') %"
Else
	cJoinAdic	:= "% R4_CODRET = COALESCE(RA_CODRET,'0561') %"
EndIf

cQueryAlias := GetNextAlias()

BeginSQL ALIAS cQueryAlias
	SELECT
		COUNT(*) AS TOTALREG
	FROM
		%Table:SR4% SR4
	INNER JOIN %Table:SRA% SRA
	ON 	R4_FILIAL = RA_FILIAL AND
		R4_MAT = RA_MAT AND
		R4_CPFCGC = RA_CIC AND
		%exp:cJoinAdic%
	WHERE
		SR4.%NotDel% AND
		RA_FILIAL >= %exp:cFilDe% AND
		RA_FILIAL <= %exp:cFilAte% AND
		RA_MAT >= %exp:cMatDe% AND
		RA_MAT <= %exp:cMatAte% AND
		R4_ANO = %exp:''%
EndSQL

lLimpaTudo := (cQueryAlias)->TOTALREG > 0

(cQueryAlias)->(DBCloseArea())

If lLimpaTudo
	dbSelectArea( "SRL" )
	If RecCount() > 0

		Aviso(STR0015,STR0021,{"OK"}) //"Atencao"#"As tabelas SRL e SR4 serao limpas para que a partir de agora o historico possa ser armazenado."

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Verifica qual eh o maior e o menor³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		cQuery := "SELECT MIN(R_E_C_N_O_) MINRECNO, MAX(R_E_C_N_O_) MAXRECNO "
		cQuery += "  FROM " + RetSqlName("SRL") + " SRL "

		cQuery := ChangeQuery(cQuery)

		dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),"SRL550DELE")

		nMax := SRL550DELE->MAXRECNO
		nMin := SRL550DELE->MINRECNO
		dbCloseArea()
		dbSelectArea("SRL")

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Monta a string de execucao no banco³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		cQuery := "DELETE FROM "+RetSqlName("SRL")+" "
		cQuery += "WHERE "

		If Type("SRL->RL_ORIGEM") # "U"
	    	cQuery +=  "RL_ORIGEM = '1'"
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Executa a string de execucao no banco para os proximos 1024 registro³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		For nPont := nMin To nMax STEP 1024
			cChave := "R_E_C_N_O_>="+Str(nPont,10,0)+" AND R_E_C_N_O_<="+Str(nPont+1023,10,0)+""
			TcSqlExec(cQuery+cChave)
		Next nPont

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³A tabela eh fechada para restaurar o buffer da aplicacao³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		dbSelectArea("SRL")
		dbCloseArea()
		ChkFile("SRL",.F.)

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Verifica qual eh o maior e o menor³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		cQuery := "SELECT MIN(R_E_C_N_O_) MINRECNO, MAX(R_E_C_N_O_) MAXRECNO "
		cQuery += "FROM " + RetSqlName("SR4") +" SR4 "

		cQuery := ChangeQuery(cQuery)

		dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),"SR4550DELE")

		nMax := SR4550DELE->MAXRECNO
		nMin := SR4550DELE->MINRECNO
		dbCloseArea()
		dbSelectArea("SR4")

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Monta a string de execucao no banco³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		cQuery := "DELETE FROM "+RetSqlName("SR4")+" "
		cQuery += "WHERE "
		If Type("SR4->R4_ORIGEM") # "U"
	    	cQuery +=  "R4_ORIGEM = '1'"
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Executa a string de execucao no banco para os proximos 1024 registro³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		For nPont := nMin To nMax STEP 1024
			cChave := "R_E_C_N_O_>="+Str(nPont,10,0)+" AND R_E_C_N_O_<="+Str(nPont+1023,10,0)+""
			TcSqlExec(cQuery+cChave)
		Next nPont

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³A tabela eh fechada para restaurar o buffer da aplicacao³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		dbSelectArea("SR4")
		dbCloseArea()
		ChkFile("SR4",.F.)

		If File(cArqCompl+getDbExtension())
			fErase(cArqCompl+getDbExtension())
		EndIf
		If File(cArqCompl+retIndExt())
			fErase(cArqCompl+retIndExt())
		EndIf
	Endif
Else
//Filtra filiais de acesso do usuario
	cValidFil	:= ""
	For nX := 1 to Len(aValidFil)
		cValidFil += "'" + aValidFil[nX]+ "'"
		If (nX + 1) <= Len(aValidFil)
			cValidFil += ","
		Endif
	Next nX
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Limpar SR4 e RCS se forem encontrados no SR4 informacoes dos funcionarios solicitados.³
	//³Apenas serao limpos os dados dos funcionario selecionados para geracao.               ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

	cQuery := " DELETE FROM " + RetSqlName("SR4") + " "
	cQuery += " WHERE (R4_FILIAL		>=	'"	+ cFilDe 	+ "'"
	cQuery += "   AND R4_FILIAL		<= 	'"	+ cFilAte 	+ "'"
	cQuery += "   AND R4_FILIAL IN (" + cValidFil + "))"
	cQuery += "   AND R4_MAT 		>= 	'" 	+ cMatDe 	+ "'"
	cQuery += "   AND R4_MAT 		<= 	'" 	+ cMatAte 	+ "'"
	cQuery += "   AND R4_ANO 		=  	'" 	+ cAno 		+ "'"
    cQuery += "   AND R4_ORIGEM 	= '1'"
	cQuery += "   AND EXISTS("
	cQuery += "SELECT R_E_C_N_O_ FROM " + RetSqlName("SRA") + " "
	cQuery += " WHERE RA_FILIAL = R4_FILIAL "
	cQuery += "   AND RA_MAT = R4_MAT "
	cQuery += "   AND RA_CATFUNC IN (" + fSqlIN( cCateg, 1 ) + ")"
	cQuery += "   AND D_E_L_E_T_ = ' ')"

	TcSqlExec(cQuery)
	dbSelectArea("SR4")
	dbCloseArea()
	ChkFile("SR4",.F.)

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Limpa dados do RCS³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	cQuery := "DELETE FROM "+RetSqlName("RCS")+" "
	cQuery += " WHERE RCS_FILIAL >=	'"	+ cFilDe 	+ "'"
	cQuery += "   AND RCS_FILIAL <=   '"	+ cFilAte 	+ "'"
	cQuery += "   AND RCS_FILIAL IN (" + cValidFil + ") "
	cQuery += "   AND RCS_MAT 		>= 	'" 	+ cMatDe 	+ "'"
	cQuery += "   AND RCS_MAT 		<= 	'" 	+ cMatAte 	+ "'"
	cQuery += "   AND RCS_ANO 		=  	'" 	+ cAno 		+ "'"

	If Type("RCS->RCS_ORIGEM") # "U"
	   	cQuery +=  "AND RCS_ORIGEM = '1'"
	EndIf

	cQuery += "   AND EXISTS("
	cQuery += "SELECT R_E_C_N_O_ FROM " + RetSqlName("SRA") +""
	cQuery += " WHERE RA_FILIAL = RCS_FILIAL "
	cQuery += "   AND RA_MAT = RCS_MAT "
	cQuery += "   AND RA_CATFUNC IN (" + fSqlIN( cCateg, 1 ) + ")"
	cQuery += "   AND D_E_L_E_T_ = ' ')"
	TcSqlExec(cQuery)

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³A tabela eh fechada para restaurar o buffer da aplicacao³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	dbSelectArea("RCS")
	dbCloseArea()
	ChkFile("RCS",.F.)

	If cAno >= "2016"
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Limpa dados do SM8³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		cQuery := " DELETE FROM "+RetSqlName("SM8")+" "
		cQuery += " WHERE (M8_FILIAL>=	'"	+ cFilDe 	+ "'"
		cQuery += "   AND M8_FILIAL<= 	'"	+ cFilAte 	+ "'"
		cQuery += "   AND M8_FILIAL IN (" + cValidFil + "))"
	 	cQuery += "	  AND M8_MAT 		>= 	'" 	+ cMatDe 	+ "'"
	 	cQuery += "	  AND M8_MAT 		<= 	'" 	+ cMatAte 	+ "'"
	    cQuery += "	  AND M8_ANO 		=  	'" 	+ cAno 		+ "'"
		cQuery += "	  AND EXISTS("
		cQuery += "SELECT R_E_C_N_O_ FROM " + RetSqlName("SRA") +""
		cQuery += " WHERE RA_FILIAL = M8_FILIAL "
		cQuery += "   AND RA_MAT 	= M8_MAT "
		cQuery += "   AND RA_CATFUNC IN (" + fSqlIN( cCateg, 1 ) + ")"
		cQuery += "   AND D_E_L_E_T_ = ' ')"
		TcSqlExec(cQuery)

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³A tabela eh fechada para restaurar o buffer da aplicacao³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		dbSelectArea("SM8")
		dbCloseArea()
		ChkFile("SM8",.F.)

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Limpa dados do SM9³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		cQuery := "DELETE FROM "+RetSqlName("SM9")+" "
		cQuery += " WHERE (M9_FILIAL>=	'"	+ cFilDe 	+ "'"
		cQuery += "   AND M9_FILIAL<= 	'"	+ cFilAte 	+ "'"
		cQuery += "   AND M9_FILIAL IN (" + cValidFil + "))"
	 	cQuery += "   AND M9_MAT 		>= 	'" 	+ cMatDe 	+ "'"
	 	cQuery += "   AND M9_MAT 		<= 	'" 	+ cMatAte 	+ "'"
	    cQuery += "   AND M9_ANO 		=  	'" 	+ cAno 		+ "'"
		cQuery += "   AND EXISTS("
		cQuery += "SELECT R_E_C_N_O_ FROM " + RetSqlName("SRA") +""
		cQuery += " WHERE RA_FILIAL = M9_FILIAL "
		cQuery += "   AND RA_MAT 	= M9_MAT "
		cQuery += "   AND RA_CATFUNC IN (" + fSqlIN( cCateg, 1 ) + ")"
		cQuery += "   AND D_E_L_E_T_ = ' ')"
		TcSqlExec(cQuery)

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³A tabela eh fechada para restaurar o buffer da aplicacao³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		dbSelectArea("SM9")
		dbCloseArea()
		ChkFile("SM9",.F.)
	EndIf
EndIf

Return()

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFuncao    ³LimpaSR4       ºAutor  ³Microsiga      º Data ³  15/01/14   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Limpar o a tabela SR4                                       º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³                                                            º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function LimpaSR4(lLimpaTudo)
Local cChave := ''
Local cValidFilSR4	:= fValidFil()

If lLimpaTudo
	dbSelectArea("SR4")
	cChave	:= If( nTamCpf == 11, SRA->(RA_FILIAL+RA_MAT+RA_CIC) + Space(3) + cCodRet ,;
								  SRA->(RA_FILIAL+RA_MAT+RA_CIC) + cCodRet )
	dbSeek( cChave )
	While SR4->( !Eof()) .AND.  SR4->(R4_FILIAL+R4_MAT+R4_CPFCGC+R4_CODRET) == cChave

		If !(SR4->R4_FILIAL $ cValidFilSR4 )
			SR4->(dbSkip())
			Loop
		Else
			RecLock("SR4",.F.,.T.)
			dbDelete()
			MsUnlock()
			nDel ++
			SR4->(dbSkip())
		EndIf
	Enddo
EndIf
Return()

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFuncao    ³CriaIndFer     ºAutor  ³Microsiga      º Data ³  15/01/14   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Cria indice para pesquisar ferias                           º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³                                                            º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function CriaIndFer(cArqSRH)
Local cIndCond := ''
dbSelectArea( "SRH" )
cIndCond	:=	"RH_FILIAL + RH_MAT + dTos(RH_DTRECIB)"
cArqSRH  	:= CriaTrab(NIL,.f.)
IndRegua("SRH",cArqSRH,cIndCond,,,"Selecionando Registros")
Return()

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFuncao    ³CriaIndComp    ºAutor  ³Microsiga      º Data ³  15/01/14   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Cria indice para pesquisar os registros das informacoes     º±±
±±º          ³complementares                                              º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³                                                            º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function CriaIndComp(cArqRCS, nIndexRCS)
Local cIndKeyRCS := ''
dbSelectArea( "RCS" )
dbSetOrder( 1 )
cIndKeyRCS := "RCS_FILIAL+RCS_MAT+RCS_TIPOFJ+RCS_CPFBEN+RCS_CODRET+RCS_ANO+RCS_VERBA+RCS_TIPORE+RCS_CPFCGC+RCS_OUTROS"
cArqRCS	   := CriaTrab( Nil, .F. )
IndRegua( "RCS", cArqRCS, cIndKeyRCS, , , 'Criando índice temporário. Aguarde...', .T. )
nIndexRCS  := RCS->( RetIndex() + 1)
Return()

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFuncao    ³BuscaBenef     ºAutor  ³Microsiga      º Data ³  15/01/14   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Busca os beneficiarios do funcionario no SRQ                º±±
±±º          ³para montar o array de Informacoes Complementares           º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³                                                            º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function BuscaBenef()
Local cVbPensao		:= ""
Local cVbPFol   	:= ""

aBenef 	:= {}
aPensao := {}
aPrevi	:= {}

If SRQ->(dbSeek(SRA->(RA_FILIAL+RA_MAT)))
	dbSelectArea( "SRQ" )
	While SRQ->(!EOF()) .AND. SRQ->(RQ_FILIAL+RQ_MAT) == SRA->(RA_FILIAL+RA_MAT)
		cVbPensao:= ""
		If !Empty(SRQ->RQ_VERBPLR)
			cVbPensao := PosSrv(SRQ->RQ_VERBPLR, xFilial('SRV', SRQ->RQ_FILIAL), "RV_CODCOM_")
		EndIf
		cVbPFol := ""
		If !Empty(SRQ->RQ_VERBFOL)
			cVbPFol   := PosSrv(SRQ->RQ_VERBFOL, xFilial('SRV', SRQ->RQ_FILIAL), "RV_CODCOM_")
		EndIf

		If (lDtIniPg .AND. (( Str(Year(SRQ->RQ_DTINIPG),4) <= cAno) .AND. ( Empty(Str(Year(SRQ->RQ_DTFIMPG),4)) .OR.;
		   Str(Year(SRQ->RQ_DTFIMPG),4) >= cAno))) .OR.	!lDtIniPg

			aAdd(aBenef,{	SRQ->RQ_NOME	,;	//01
							SRQ->RQ_CIC		,;	//02
							SRQ->RQ_VERBADT	,;	//03
							SRQ->RQ_VERBFOL	,;	//04
							SRQ->RQ_VERBFER	,;	//05
							SRQ->RQ_VERB131	,;	//06
							SRQ->RQ_VERB132	,;	//07
							SRQ->RQ_VERBPLR	,;	//08
							0				,;	//09
							""				,; 	//10 Verba
							""				,; 	//11 Tipo Rendimento
							If(lTemCpoDFE,SRQ->RQ_VERBDFE,""),; //12
							.F.				,;	//13 Referente a 13o
							cVbPensao   	,; 	//14 Verba de dif. de dissidio para PLR
							cVbPFol         ,; 	//15
							SRQ->RQ_ORDEM	,; 	//16 Grau Parentesco
							""    		    ,; 	//17 Mes Pagto - utilizado p assit. medica
							aCodFol[976,01] ,;  //18)Verba RRA
							SRQ->RQ_DTINI	,;  //19 Data de inicio do beneficiario
							SRQ->RQ_DTFIM	,;  //20)Data final do beneficiario
							{}				,;  //21)Array{cTipDirf,cMesPag,nVal,dDtPagto}
							aCodFol[981,01]	,;  //22)Id. Pensão Alim. 13o. RRA
							SRQ->RQ_NASC	;	//23)Data Nasc. Benef.
							})
		EndIf
		SRQ->(dbSkip())
	EndDo
EndIf
Return()

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFuncao    ³CarSRD         ºAutor  ³Microsiga      º Data ³  15/01/14   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Carrega movimento acumulado SRD                             º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³                                                            º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function CarSRD()

Local cQuery 		:= ''
Local cPD131		:= ''
Local nX 	 		:= 0
Local nB			:= 0
Local lCPd131		:= .F.

For nB := 1 to Len(aBenef)
	If !Empty(aBenef[nB,6]) .AND. ( Empty(abenef[nb,20]) .Or. STR(YEAR(aBenef[nB,20]),4) >= cAno)
		cPD131 += IIF(!Empty(cPD131),",","")+ "'"+ aBenef[nB,6] + "'"
	EndIf

	If Empty(cPD131)
		lCPd131 := .F.
	Else
		lCPd131 := .T.
	Endif
Next nb

dbSelectArea("SRD")

cAliasSRD 	:= "m550MontSRD"

cWhere := "%"
cWhere += " RD_FILIAL 	= '" + SRA->RA_FILIAL + "' AND "
cWhere += " RD_MAT 		= '" + SRA->RA_MAT 	  + "' AND "

If !lGestPubl	//Se nao for GFP/MP
	If !lCPd131
		cWhere += " RD_ROTEIR IN ('" + fGetCalcRot('1') + "','" + fGetCalcRot('6')  + "','" + fGetCalcRot('9') + "','" + fGetCalcRot('F') + "','" + fGetCalcRot('2') + "') AND "
	Else
		cWhere += " (RD_ROTEIR IN ('" + fGetCalcRot('1') + "','" + fGetCalcRot('6')  + "','" + fGetCalcRot('9') + "','" + fGetCalcRot('F') + "','" + fGetCalcRot('2') + "') OR "
		cWhere += " ( RD_ROTEIR = '" + fGetCalcRot('5') + "' AND RD_PD IN (" + cPD131 + ") )) AND "
	Endif
EndIf

cWhere += " RD_DATPGT BETWEEN '" + cDtPesqI + "' AND '" + cDtPesqF + "'"
cWhere += "%"

BeginSql alias cAliasSRD
	SELECT
		%exp:cFieldsSRD%
	FROM
		%table:SRD% SRD
	WHERE
	 	%exp:cWhere% AND
	 	SRD.%NotDel%
	ORDER BY
		%exp:cOrderSRD%
EndSql

For nX := 1 To Len(aStruSRD)
	If aStruSRD[nX][2] <> "C" .And. FieldPos(aStruSRD[nX][1])<>0
		TcSetField(cAliasSRD, aStruSRD[nX][1], aStruSRD[nX][2], aStruSRD[nX][3], aStruSRD[nX][4])
	EndIf
Next nX

Return()

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFuncao    ³ValidVbAcu     ºAutor  ³Microsiga      º Data ³  15/01/14   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Valida verbas acumuladas                                    º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³                                                            º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function ValidVbAcu()
Local nPos1	:= 0
Local aVerbaDupl := {}

If (cAliasSRD)->RD_PD == aCodFol[168,1] .Or. (cAliasSRD)->RD_PD == aCodFol[060,1]
	nPos1 := Ascan(aDedInssF,{ |x| x[1] == (cAliasSRD)->RD_PERIODO .And. x[2] == aCodFol[164,1]})
	If !( (cAliasSRD)->RD_TIPO2 $ "K*R*I*G*C" )  .or. ( cDescInsFer != 'N' .And. nPos1 > 0 .and. ( (cAliasSRD)->RD_TIPO2 $ "R#I#G#C" ) )
		Return(.F.)
	EndIf
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Lancamento com verba em branco no acumulado. ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If Empty((cAliasSRD)->RD_PD)
	If aTotRegs[4] == 0
		aAdd(aTitle, STR0022) //"Lancamento com verba em branco no acumulado.    Filial/Matricula  Competencia            Valor "
		aAdd(aLog,{})
		aTotRegs[4] := Len(aLog)
	EndIf
	aAdd(aLog[aTotRegs[4]],Space(49)+(cAliasSRD)->RD_FILIAL+"-"+(cAliasSRD)->RD_MAT+Space(08)+SubStr((cAliasSRD)->RD_DATARQ,5,2)+"/"+SubStr((cAliasSRD)->RD_DATARQ,1,4) +Space(04)+Transform((cAliasSRD)->RD_VALOR,"@E 99,999,999,999.99") )
	Return(.F.)
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Lancamento com verba em branco no acumulado. ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If Empty((cAliasSRD)->RD_DATARQ)
	If aTotRegs[5] == 0
		aAdd(aTitle, STR0023) //"Lancamento com competencia em branco no acumulado.   Filial/Matricula  Verba             Valor"
		aAdd(aLog,{})
		aTotRegs[5] := Len(aLog)
	EndIf
	aAdd(aLog[aTotRegs[5]],Space(54)+(cAliasSRD)->RD_FILIAL+"-"+(cAliasSRD)->RD_MAT+Space(09)+(cAliasSRD)->RD_PD+Space(03)+Transform((cAliasSRD)->RD_VALOR,"@E 99,999,999,999.99") )
	Return(.F.)
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Lancamento com data de pagamento em branco no acumulado. ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If Empty(StoD((cAliasSRD)->RD_DATPGT))
	If aTotRegs[6] == 0
		aAdd(aTitle, STR0024) //"Lancamento com data de pagamento em branco no acumulado."
		aAdd(aLog,{})
		aTotRegs[6] := Len(aLog)
	EndIf
	aAdd(aLog[aTotRegs[6]],(cAliasSRD)->RD_FILIAL+"-"+(cAliasSRD)->RD_MAT+"-"+(cAliasSRD)->RD_PD+"-" +transform((cAliasSRD)->RD_VALOR,"@E 99,999,999,999.99") )
	Return(.F.)
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Verba duplicada nos acumulados.              ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If Ascan( aVerbaDupl,(cAliasSRD)->(RD_FILIAL+RD_MAT+RD_CC+RD_ITEM+RD_CLVL+RD_DATARQ+RD_PD+RD_SEQ+RD_PERIODO+RD_SEMANA+RD_ROTEIR+RD_DTREF+RD_CONVOC)) == 0
	Aadd(aVerbaDupl,(cAliasSRD)->(RD_FILIAL+RD_MAT+RD_CC+RD_ITEM+RD_CLVL+RD_DATARQ+RD_PD+RD_SEQ+RD_PERIODO+RD_SEMANA+RD_ROTEIR+RD_DTREF+RD_CONVOC))
Else
	If aTotRegs[8] == 0
		aAdd(aTitle, STR0025) //"Verba duplicada nos acumulados.    Filial/Matricula   Verba   Competencia             Valor"
		aAdd(aLog,{})
		aTotRegs[8] := Len(aLog)
	EndIf
	aAdd(aLog[aTotRegs[8]],Space(35)+(cAliasSRD)->RD_FILIAL+"-"+(cAliasSRD)->RD_MAT+Space(10)+(cAliasSRD)->RD_PD+Space(05)+SubStr((cAliasSRD)->RD_DATARQ,5,2)+"/"+SubStr((cAliasSRD)->RD_DATARQ,1,4)+Space(5)+Transform((cAliasSRD)->RD_VALOR,"@E 99,999,999,999.99") )
EndIf
Return(.T.)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFuncao    ³CarRHS         ºAutor  ³Microsiga      º Data ³  15/01/14   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Trata a geracao das informacoes complementares referente    º±±
±±º          ³rateio do plano de saude.                                   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³                                                            º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function CarRHS()

Local cWhere        := ''
Local nField        := 1
Local nRhsFields	:= Len( aRhsFields )

cAliasRHS 	:= "QRHS"

If ( Select( cAliasRHS ) > 0 )
	( cAliasRHS )->( dbCloseArea() )
EndIf

cWhere		:=	" RHS.RHS_FILIAL = '" + SRA->RA_FILIAL + "' AND RHS.RHS_MAT = '" + SRA->RA_MAT + "' AND " +;
				" RHS.RHS_TPLAN = '1' AND RHS.RHS_DATPGT >= '" + cDtPesIHist + "' AND RHS.RHS_DATPGT <= '" + cDtPesFHist + "' AND RHS.RHS_VLRFUN > 0 "
cWhere		:= "%" + cWhere + "%"

BeginSql alias cAliasRHS
	SELECT %exp:cFieldsRHS%
	FROM   %table:RHS% RHS
	WHERE  %exp:cWhere%
	AND RHS.%notDel%
	ORDER BY RHS.RHS_FILIAL, RHS.RHS_MAT
EndSql

For nField := 1 To nRhsFields
	IF !( aRhsFields[ nField , 02 ] == "C" )
		TcSetField(cAliasRHS,aRhsFields[nField,01],aRhsFields[nField,02],aRhsFields[nField,03],aRhsFields[nField,04])
	EndIF
Next nField

Return()

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFuncao    ³BuscaAssBen    ºAutor  ³Microsiga      º Data ³  15/01/14   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Realiza busca na tabela de historico RHS dos planos         º±±
±±º          ³de assistencia medica/odontologica                          º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³                                                            º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function BuscaAssBen()
Local aArea		 := GetArea()
Local cDescri    := ''
Local cTipDirf   := ''
Local cGraupar	 := ''
Local cCNPJCompl := ''
Local cFilSRVAss	:= xFilial("SRV",SRA->RA_FILIAL)

While (cAliasRHS)->(RHS_FILIAL + RHS_MAT) == SRA->(RA_FILIAL + RA_MAT)
	If (cAliasRHS)->RHS_TPLAN == "1" .And. DtoS( (cAliasRHS)->RHS_DATPGT ) >= cDtPesIHist .And. ;
	   (cAliasRHS)->RHS_VLRFUN > 0   .And. DtoS( (cAliasRHS)->RHS_DATPGT ) <= cDtPesFHist
	    cDescri		:= Alltrim(RetValSrv((cAliasRHS)->RHS_PD, cFilSRVAss ,"RV_DESC"))
		cTipDirf	:= AllTrim(RetValSrv((cAliasRHS)->RHS_PD, cFilSRVAss ,"RV_DIRF"))

		If cTipDirf == 'R'
			If f550DescrAss(@cDescri,@cCNPJCompl,.T.,cAliasRAS,(cAliasRHS)->RHS_PD,@cGraupar, Nil, cAliasRHS)
			   aAdd(aBenef,{cDescri,cCNPJCompl,"","","","","","",(cAliasRHS)->RHS_VLRFUN,(cAliasRHS)->RHS_PD,cTipDirf,"",.F.,"","",cGraupar,"","",AnoMes((cAliasRHS)->RHS_DATPGT)})
			EndIf
		EndIf
        cCNPJCompl	:= ''
        cGraupar	:= ''
	EndIf
	(cAliasRHS)->(dbSkip())
EndDo

RestArea(aArea)

Return()

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFuncao    ³CarRHP         ºAutor  ³Microsiga      º Data ³  15/01/14   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Realiza busca na tabela de historico RHP de co-participacao º±±
±±º          ³/reembolso dos planos de assistencia medica/odontologica    º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³                                                            º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function CarRHP()

Local cWhere     := ''
Local nField     := 1
Local nRhpFields := Len( aRhpFields )

cAliasRHP 	:= "QRHP"

If ( Select( cAliasRHP ) > 0 )
	( cAliasRHP )->( dbCloseArea() )
EndIf

cWhere	:=	" RHP.RHP_FILIAL = '" + SRA->RA_FILIAL + "' AND RHP.RHP_MAT = '" + SRA->RA_MAT + "' AND " +;
			" RHP.RHP_DATPGT >= '" + cDtPesIHist + "' AND RHP.RHP_DATPGT <= '" + cDtPesFHist + "' AND RHP.RHP_VLRFUN > 0 "
cWhere	:= "%" + cWhere + "%"

BeginSql alias cAliasRHP
	SELECT %exp:cFieldsRHP%
	FROM %table:RHP% RHP
	WHERE  %exp:cWhere%
	AND RHP.%notDel%
	ORDER BY RHP.RHP_FILIAL, RHP.RHP_MAT
EndSql

For nField := 1 To nRhpFields
	If !( aRhpFields[ nField , 02 ] == "C" )
		TcSetField(cAliasRHP,aRhpFields[nField,01],aRhpFields[nField,02],aRhpFields[nField,03],aRhpFields[nField,04])
	EndIF
Next nField

Return()

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFuncao    ³BuscaCoRemb    ºAutor  ³Microsiga      º Data ³  15/01/14   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Realiza busca na tabela de historico RHP de co-participacao º±±
±±º          ³/reembolso dos planos de assistencia medica/odontologica    º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³                                                            º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function BuscaCoRemb()
Local cCNPJCompl  := ''
Local cGraupar	  := ''
Local cDescri     := ''
Local cTipDirf    := ''
Local cText3      := ""
Local lReemb      := .F.

While (cAliasRHP)->(RHP_FILIAL + RHP_MAT) == SRA->(RA_FILIAL + RA_MAT)
	If (cAliasRHP)->RHP_VLRFUN > 0 .And. DtoS( (cAliasRHP)->RHP_DATPGT ) >= cDtPesIHist .And. ;
										 DtoS( (cAliasRHP)->RHP_DATPGT ) <= cDtPesFHist
		cDescri		:= Alltrim(RetValSrv((cAliasRHP)->RHP_PD, xFilial("SRV",SRA->RA_FILIAL) ,"RV_DESC"))
		cTipDirf	:= AllTrim(RetValSrv((cAliasRHP)->RHP_PD, xFilial("SRV",SRA->RA_FILIAL) ,"RV_DIRF"))

		If cTipDirf == 'R'
			If Len(cText3) == 0 .And. (cAliasRHP)->RHP_TPLAN == "2"
        		cText3 := OemToAnsi(STR0035) + ": "+SRA->RA_FILIAL + "-"+ SRA->RA_MAT+ " - " +OemToAnsi(STR0151) // # Consta reembolso para Titular/Dep., necessário informar dados do prestador de serviços. #
        	EndIf
			lReemb := If((cAliasRHP)->RHP_TPLAN == "2", .T., .F.)

			f550DescrAss(@cDescri,@cCNPJCompl,.T.,cAliasRAS,(cAliasRHP)->RHP_PD,@cGraupar, Nil, cAliasRHP,If((cAliasRHP)->RHP_TPLAN == "1",.F.,.T.))
			aAdd(aBenef,{cDescri,cCNPJCompl,"","","","","","",(cAliasRHP)->RHP_VLRFUN,(cAliasRHP)->RHP_PD,cTipDirf,"",.F.,"","",cGraupar,"","",AnoMes((cAliasRHP)->RHP_DATPGT),If(lReemb,(cAliasRHP)->RHP_INMED,""),If(lReemb,(cAliasRHP)->RHP_NOMED,"")})

			/*
			//Nao sera somado para que o valor possa ser demonstrado separadamente para cada codigo de retencao quando houver expatriado
			If ( nPos := aScan( aBenef, { |aBenef| aBenef[16] == cGraupar .And. aBenef[10] == (cAliasRHP)->RHP_PD .And. aBenef[1] == cDescri } ) ) == 0
				aAdd(aBenef,{cDescri,cCNPJCompl,"","","","","","",(cAliasRHP)->RHP_VLRFUN,(cAliasRHP)->RHP_PD,cTipDirf,"",.F.,"","",cGraupar,"","",AnoMes((cAliasRHP)->RHP_DATPGT)})
			Else
				aBenef[nPos, 9] += (cAliasRHP)->RHP_VLRFUN
			EndIf
			*/
		EndIf
        cCNPJCompl	:= ''
        cGraupar	:= ''
	EndIf
	(cAliasRHP)->(DBSkip())
EndDo

If Len(cText3) <> 0
	Aadd(aLog3,cText3)
	cText3 := ""
EndIf

Return()

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFuncao    ³BuscaCoRemb    ºAutor  ³Microsiga      º Data ³  15/01/14   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Tratamento do Adiantamento gravando no mes de pagamento     º±±
±±º          ³e deduzindo no mes posterior quando a verba de adiantamento º±±
±±º          ³incide para IR, significando que a empresa paga a folha no  º±±
±±º          ³mes seguinte ao mes de processamento. 				      º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³                                                            º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function GravaAdianta(aAdt, dDtPgRes)
Local nA    := 1
Local nVal  := 0
Local cMes  := ''
Local cMes1 := ''
Local cChave:= ''
Local nPosAdt := 0
Local lAdtP12 := .F.
Local lTemSaldo	:= .T.
Local lSSaldoRes:= .F.
Local lPgResSeg  := .F.

//Tratamento para bases migradas da P11, quando o adiantamento
//do mes da demissão foi calculado na P12.
If Len(aAdt) > 0
	nPosAdt:= aScan( aAdt, { |X| X[2] == MesAno(dDtpgRes) } )
	If nPosAdt > 0
		lAdtP12 := (aAdt[nPosAdt,5] == .T.)
	Endif
Endif

// Verifica se funcionário demitido que não possui saldo de salário possui lançamentos
// de Proventos de Rendimentos Tributáveis
If Empty(dDtpgRes) .And. !Empty(SRA->RA_DEMISSA)
	lSSaldoRes := fBscRend()  // Não possui saldo no mês da Rescisão mas possui Rendimentos Tributáveis
EndIf

If Empty(dDtpgRes) .And.  !Empty(SRA->RA_DEMISSA) .And. lSSaldoRes
   dbSelectArea("SRG")
   SRG->( dbSetOrder(1) )
   If SRG->( dbSeek( xFilial("SRG",SRA->RA_FILIAL) + SRA->RA_MAT ) )
        While SRG->( !EOF() ) .And. (SRG->RG_FILIAL+SRG->RG_MAT == SRA->RA_FILIAL+SRA->RA_MAT)
            If Year(SRG->RG_DATAHOM) == MV_PAR06+1
                lPgResSeg := .T.
                Exit
            Endif
            SRG->(dbSkip())
        EndDo
    EndIf
Endif

For nA := 1 To Len(aAdt)
	If Val(SubStr(aAdt[nA,2],1,4)) == MV_PAR06 .And. ( MesAno(dDtpgRes) # aAdt[nA,2];
	.Or. ( MesAno(dDtpgRes) == aAdt[nA,2] .And. !aAdt[Na,5]) .Or. ( MesAno(dDtpgRes) == aAdt[nA,2] .And. (aAdt[nA,5] .Or. lAdtP12) ))
		cMes  := SubStr(aAdt[nA,2],5,2) //Mes de referencia
		lTemSaldo	:= If(MesAno(SRA->RA_DEMISSA) == aAdt[nA,2] .And. lSSaldoRes, .F., .T.)

		If lTemSaldo
			cMes1 := StrZero(Val(SubStr(aAdt[nA,2],5,2))+1,2) //Mes de abtatimento da base
		Else
			cMes1 := StrZero(Val(SubStr(MesAno(SRA->RA_DEMISSA),5,2)),2) // Mês da Rescisao, abater do rendimentos tributáveis gerados no período da rescisão
		EndIf

		If cMes1 <= "12"
			cMAAdt := SubStr(aAdt[nA,2],1,4) + cMes1
		Else
			cMAAdt := StrZero(Val(SubStr(aAdt[nA,2],1,4))+1,4) + cMes1
		EndIf

		nVal  := aAdt[Na,3]

		If !aAdt[nA,5] .And. !aAdt[nA,6]
			GravaFun( cMes, "A", nVal, aAdt[Na,4] )	// Soma na Data do Mes do Pagto.
		Endif

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Nao Abater o Adiantamento no Mes seguinte quando data demissao    ³
		//³for igual a dt. rescisao porque no mes seguinte nao tera base.    ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If cMes1 <= "12"
			If Empty(SRA->RA_DEMISSA) .Or. ( cMAAdt < MesAno(SRA->RA_DEMISSA) .Or. ( MesAno(dDtpgRes) >= MesAno(SRA->RA_DEMISSA) ;
				.And. MesAno(aAdt[na,4]) <= MesAno(dDtpgRes) .And. aAdt[nA,5]  ) .Or. ( MesAno(dDtpgRes) == MesAno(SRA->RA_DEMISSA) ;
				.And. (aAdt[nA,5] .Or. lAdtP12) ) .OR. ( !Empty(SRA->RA_DEMISSA) .AND. empty(dDtpgRes) ) ); // Transferido tem data de demissao mas nao tem data de pgto. de rescisao.
				.Or. (aAdt[nA,4] < SRA->RA_DEMISSA .And. !aAdt[nA,5])
			   	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Data Para Desconto Mes Seguinte                              ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				nVal := aAdt[nA,3]
				If (MesAno(dDtpgRes) == aAdt[nA,2] .And. (aAdt[nA,5] .Or. lAdtP12))
					//Nao abater adi no mes de rescisão (Regime caixa) quando o adiantamento foi pago no mesmo mes da rescisao Regime Caixa
				    If MesAno(dDtpgRes) == aAdt[nA,2] .And. dDtpgRes <= aAdt[nA,4] .And. (aAdt[nA,5] .Or. lAdtP12)
						GravaFun( cMes, "A", nVal*-1, aAdt[nA,4] )   // Subtrai da Base do Mes
					Endif
				Else
					//Quando o pagamento da rescisão for no mes seguinte, mas existe calculo de adiantamento no mes, nao abater o ADI nos Rend.Trib
                   If !(lPgResSeg .And. Empty(dDtpgRes) .And. aAdt[nA,2] == MesAno(SRA->RA_DEMISSA))
                        GravaFun( cMes1, "A", nVal*(-1), aAdt[nA,4],,, aAdt[nA,2] ) // Subtrai da Base do Mes Seguinte
					Endif
				Endif
			EndIf
			//Funcionario demitido em dezembro, com pagamento em dezembro.
		ElseIf cMes1 == "13" .AND. ( !Empty(SRA->RA_DEMISSA) .AND. MesAno(dDtpgRes) == MesAno(SRA->RA_DEMISSA) .And. MesAno(aAdt[na,4]) == MesAno(dDtpgRes) .And. aAdt[nA,5] )
			nVal := aAdt[nA,3]
			cChave	:= SRA->RA_FILIAL+SRA->RA_MAT+aAdt[nA,1]+fGetCalcRot("1")+cAno
			SRD->( dbSetOrder(6) ) //FILIAL+MATRICULA+VERBA+ROTEIRO+DATAPAGTO
			If SRD->( dbSeek(cChave)) .AND. !(SRD->RD_DATARQ == MesAno(SRD->RD_DATPGT)) .AND. (MesAno(dDtpgRes) == aAdt[nA,2])
				GravaFun( cMes, "A", nVal*-1, aAdt[nA,4] )   // Subtrai da Base do Mes
			EndIf
		EndIf
		//apenas considera o valor de Dezembro do ano anterior caso a Data de Pagamento for do ano da DIRF (regime caixa)
	ElseIf Year(aAdt[nA,4]) == MV_PAR06 .AND. Val(SubStr(aAdt[Na,2],1,4)) == MV_PAR06-1 .And. Val(SubStr(aAdt[nA,2],5,2)) = 12 .And. ( Empty(dDtpgRes) .or. (!Empty(dDtpgRes) .and. MesAno(dDtpgRes) # aAdt[Na,2]) )
		nVal := aAdt[nA,3]
		GravaFun( "01", "A", nVal*(-1), aAdt[nA,4],,, aAdt[nA,2])  // subtrai da base do mes seguinte
	EndIf
Next nA

Return()

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFuncao    ³BuscaCoRemb    ºAutor  ³Microsiga      º Data ³  15/01/14   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Gravacao da CPMF na letra 'I', outros                       º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³                                                            º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function GravaCPMF(aInssFol)
Local nVal      := 0
Local nI        := 1
Local cMes      := ''
Local cDescri   := ''

If lCPMF
	nVal := 0
	For nI := 1 to Len(aInssFol)
		If ( aInssFol[nI,3] - aInssFol[nI,2] ) > 0
			cMes := SubStr(aInssFol[nI,1],5,2)
			GravaFun( cMes, "I", aInssFol[nI,3] - aInssFol[nI,2], aInssFol[nI,4] )  //CPMF DO MES

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Gravar Descrição de Outros rend. nao trib.³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			nVal += (aInssFol[nI,3] - aInssFol[nI,2])

			cDescri   := "CPMF"
			If at(cDescri, cInfOut) == 0
				cInfOut += If( Len( cInfOut ) > 0, ", ", "" ) + cDescri
			Endif
		Endif
	Next nI

	For nI := 1 to Len(aInssFer)
		If ( aInssFer[nI,3] - aInssFer[nI,2] ) > 0
			cMes := Subs(aInssFer[nI,1],5,2)
			GravaFun( cMes, "I", aInssFer[nI,3] - aInssFer[nI,2], aInssFer[nI,4] )  //CPMF DO MES
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Gravar Descrição de Outros rend. nao trib.³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			nVal += (aInssFer[nI,3] - aInssFer[nI,2])

			cDescri   := "CPMF"
			If at(cDescri, cInfOut) = 0
				cInfOut += If( Len( cInfOut ) > 0, ", ", "" ) + cDescri
			Endif
		Endif
	Next nI

	If nVal > 0 .or. "CPMF" $ cInfOut
		cDescri := If(nVal == 0,cInfOut,cDescri)
		aAdd(aBenef,{cDescri,aInfo[8],"","","","","","",nVal,"","I","",.F.,"","","","",""})
	Endif
Else
	If !Empty(cInfOut)
		aAdd(aBenef,{cInfOut,aInfo[8],"","","","","","",0,"","I","",.F.,"","","","",""})
	EndIf
Endif

Return()

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFuncao    ³AbonoMesSeg    ºAutor  ³Microsiga      º Data ³  16/01/14   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ABONO MES\MES SEGUINTE - TOTAL ISENTO (cod "0").	  		  º±±
±±º          ³Qdo funcionario tiver abono mes seguinte (id 074/079), e  noº±±
±±º          ³mesmo mes possuir a verba id 164 (ferias pagas), indica que º±±
±±º          ³seu vlr foi considerado atraves das verbas id 205 e 206.    º±±
±±º          ³Sendo assim, deduzir seu vlr do total de isentos para nao   º±±
±±º          ³entrar em duplicidade e acresentar este valor no total de   º±±
±±º          ³rendimentos. Para não ocorrer conflitos com mais de uma     º±±
±±º          ³férias calculadas cm datas de pagamentos dentro da mesma    º±±
±±º          ³competência de pagto, verificamos se existem a verba de     º±±
±±º          ³férias pagas mês anterior e abono pec. lançadas no mesmo mêsº±±
±±º          ³(competência), e ainda se existe o abono mês seguinte no mêsº±±
±±º          ³anterior a essa competência p/ certificar o abatimento.     º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³                                                            º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function AbonoMesSeg( aAbono	)

Local nAb    	:= 1
Local nVal   	:= 0
Local nPosFerPg := 0
Local nPosAb	:= 0
Local nPosAbMS  := 0
Local nPosFPg	:= 0
Local nPosMSeg	:= 0
Local nI		:= 0
Local nP		:= 0
Local cCodAb 	:= ""
Local cMesAb 	:= ""
Local cCodAbMS	:= ""  // Código da verba "Mês Seguinte" padrão gerada no mês anterior, dentro do array aCodAboPec
Local cDatArq	:= ""
Local cCodFPg	:= ""  // Código da verba de id. 0164
Local cCodMSeg	:= ""  // Código de verba informado no campo RV_CODMSEG
Local cCodMAnt	:= ""  // Código da verba "Mês Seguinte" padrão gerada no mês anterior dentro do array aAbMesSeg
Local lProcAbo	:= .T. // Lançamento do Abono deve ser processado(.T.) ou já foi processado(.F.)
Local aVrbMS	:= {"0164","1449"}
Local nVrbMS	:= 0

// Se não existirem associações de verbas mês seguinte->mês, finaliza.
If Empty( aAbMesSeg )
	Return
EndIf

// Localiza verba de férias pagas mês anterior(id. 0164) e verba de abono pagas mês anterior(id. 1449)
For nVrbMS := 1 To Len( aVrbMS )
	If (( nPosFPg := aScan( aCodAboPec, { |x| x[ 1 ] == aVrbMS[nVrbMS] } ) ) > 0)
		cCodFPg += aCodAboPec[ nPosFPg, 2 ] + "*"
	EndIf
Next nVrbMS

// Varre array aAbonos para posicionar nas verbas de mês
For nAb := 1 To Len( aAbono )

	cMesAb 		:= aAbono[ nAb, 1 ] // Mês de pagamento do abono
	cCodAb 		:= aAbono[ nAb, 2 ] // Código da verba de abono
	cDatArq		:= aAbono[ nAb ,6 ] // RD_DATARQ da competência do abono
	lProcAbo	:= aAbono[ nAb, 7 ] // Abono(aAbono) deve ser processado(.T.) ou já foi processado(.F.)

	// Despreza verba de férias pagas mês anterior (id. 0164, está no array apenas para identificar férias partidas) ou abonos já processados.
	If ( cCodAb $ cCodFPg ) .Or. !lProcAbo
		Loop
	EndIf

	// Posiciona na verba, e associa verbas mês seguinte correspondente à mesma
	If ( nPosAB := aScan( aCodAboPec, { |x| x[ 5 ] == cCodAb } ) ) > 0
		cCodAbMS := aCodAboPec[ nPosAB, 4 ]
		cCodMSeg := cCodAb
	EndIf


	// Se for verba de abono do mês corrente(RV_CODMSEG), tiver férias partidas e abono 'mês seguinte' no mês anterior
	If nPosAB > 0 .And. ( nPosFerPg := aScan( aAbono, { |x| x[ 2 ] $ cCodFPg .And. cDatArq == x[ 6 ] } ) ) > 0 .And.;
	( Ascan( aAbono,{ |x| x[ 2 ] == cCodAbMS .And. x[ 6 ] == SubMesAno( aAbono[ nPosFerPg, 6 ] ) } ) ) > 0
		// Calcula mês anterior à competência do abono, que é a competência a ser processada
		cMesAnt := SubMesAno( aAbono[ nPosFerPg, 6 ] )
		// Localiza a verba RV_CODMSEG no array
		If ( nPosMSeg := aScan( aAbMesSeg, { |x| x[ 1 ] == cCodMSeg } ) ) > 0
			// Varre todas as verbas associadas ao codigo RV_CODMSEG do abono processado
			For nI := 1 To Len ( aAbMesSeg[ nPosMSeg, 2 ] )
				// Varre todos os lançamentos mês seguinte vinculados ao RV_CODMSEG posicionado
				cCodMAnt := aAbMesSeg[ nPosMSeg, 2, nI ]
				For nP := 1 To Len ( aAbono )
				  	// Verifica se é o cód. desejado, se está no mês anterior e se já não foi processado
					If cCodMAnt == aAbono[ nP, 2 ] .And. cMesAnt == aAbono[ nP, 6 ] .And. aAbono[ nP, 7 ]
						// Pega valor do mês anterior, pois no mês(RD_DATARQ) do id.164 podem ter ocorrido mais de uma férias e aglutinação de abonos(mesma competência e dt. pagto.)
						nVal := aAbono[ nP, 3 ]
						GravaFun( aAbono[ nP, 1 ], "0", nVal * ( -1 )	, aAbono[ nP, 5 ] ) // Abate da coluna "Abono Pec.", pois já somou pela verba de 'mês atual' o valor no mês anterior
						If cMesAnt == aAbono[ nP, 6 ] .And. (AnoMes(aAbono[ nP, 5 ]) == cMesAnt .Or. AnoMes(aAbono[ nP, 5 ]) == SubMesAno( cMesAnt ))
							GravaFun( aAbono[ nPosFerPg, 1 ], "A", nVal		, aAbono[ nPosFerPg, 5 ] ) // Soma nos "Rend. Trib.", pois o abono foi abatido através da verba de id. 164 no mês seguinte
						Endif
						aAbono[ nP, 7 ] := .F. // Abono processado
					EndIf
				Next nP
			Next nI
		EndIf
	EndIf

Next nAb
Return()

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFuncao    ³AbonoMesSeg    ºAutor  ³Microsiga      º Data ³  16/01/14   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Buscar Valores no Acumulado "SRD"             	  		  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³                                                            º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function BuscaAcuma(aDedInssF, aInssFol, aInssFer, aAdt, aDedDpSem, aDedDp13o, aDedDepend13, dDtPgRes, cVerifAdt, cPdPLS)

	Local cCalcAux  := ''
	Local nPercCpmf	:= 0
	Local nPos      := 0
	Local nTamAdt	:= 0
	Local nB		:= 0
	Local nFor		:= 0
	Local cDiaBenef	:= ""
	Local cMesBenef	:= ""
	Local cAnoBenef	:= ""
	Local cPD131	:= ""
	Local dDtBenef	:= Ctod("//")
	Local dDtPgt	:= CtoD("//")
	Local lTemADI	:= .F.
	Local lPulaADI	:= .F.
	Local cDtArqAux	:= ""
	Local lTem006	:= .F.
	Local lTem007	:= .F.
	Local lCPd131	:= .F.
	Local lRegTrans	:= .F.
	Local aRot1		:= {}
	Local cRot131   := fGetCalcRot('5')
	Local nX
	Local cJoinRVxRD:= "% " + FWJoinFilial( "SRD", "SRV" ) + " %"
	Local cAnoMV6	:= cValToChar(MV_PAR06)
	Local cChvRateio	:= ""
	Local cRots		:= "%"
	Local cFilSRV	:= xFilial("SRV",SRA->RA_FILIAL)
	Local lAdiFilOr := .F.

	DEFAULT cPdPLS := ""

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Controle para que seja utilizado apenas um redutor de 13o. no ano.³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	lRedutor13 := .F.
	dDtPgt := StoD(cDtPesqF)

	For nB := 1 to Len(aBenef)
		If !Empty(aBenef[nB,6]) .AND. ( Empty(abenef[nb,20]) .Or. STR(YEAR(aBenef[nB,20]),4) >= cAno)
			cPD131 += IIF(!Empty(cPD131),",","")+ "'"+ aBenef[nB,6] + "'"
		EndIf

		If Empty(cPD131)
			lCPd131 := .F.
		Else
			lCPd131 := .T.
		Endif
	Next nb
	If !lGestPubl
		cCalcAux := fGetCalcRot('1') +"/"+ fGetCalcRot('2') + "/" + fGetCalcRot('6') + "/" + fGetCalcRot('9') + "/" + fGetCalcRot('5')

		aRot1 := fGetRotTipo('F')
		For nB := 1 to Len(aRot1)
			cCalcAux += "/" + aRot1[nB]
		Next nB

	Else
		cCalcAux := cRotFol1 + cRot213 + fGetCalcRot('2') + "/" + fGetCalcRot('9') + "/"

		aRot1 := fGetRotTipo('7')
		For nB := 1 to Len(aRot1)
			cCalcAux += aRot1[nB] + "/"
		Next nB
		aRot1 := fGetRotTipo('F')
		For nB := 1 to Len(aRot1)
			cCalcAux += aRot1[nB] + "/"
		Next nB
		cRot131	:= cRot113

		//Remove ultima barra
		cCalcAux := SubString(cCalcAux, 1, Len(cCalcAux)-1)
	EndIf

	For nFor := 1 To Len(AllTrim(cCalcAux)) Step 4
		cRots+= "'"+Subs(cCalcAux,nFor,3)+"'"
		If Len(AllTrim(cCalcAux)) > ( nFor+4 )
			cRots += ","
		EndIf
	Next nFor
	cRots += "%"

	// Zero transferências do funcionário anterior para carregar transferências do funcionário atual
	aTransf	:= {}
	fTransf(@aTransf)

	BeginSql alias cAliasSRD
		SELECT 		*
		FROM 		%table:SRD% SRD
		INNER JOIN %Table:SRV% SRV ON %exp:cJoinRVxRD% AND RV_COD = RD_PD AND SRV.%NotDel%
		WHERE  SRD.RD_FILIAL = %exp:SRA->RA_FILIAL%  AND
		SRD.RD_MAT = %exp:SRA->RA_MAT% AND
		SRD.RD_DATPGT < %exp:dDtPgt% AND
		SRD.RD_ROTEIR IN  (%exp:cRots%) AND
		( SUBSTRING(SRD.RD_DATPGT,1,4) = %exp:cAnoMV6%  OR
			(( SRV.RV_DIRF IN ('J','K','L','B1','B5','T1','C1','M1','81','91','M6','M7','9E','9F') OR SRV.RV_CODFOL = "0183") AND SUBSTRING(SRD.RD_DATPGT,1,4) > %exp:cAnoMV6% AND SUBSTRING(SRD.RD_DATPGT,5,2) = "01")
		) AND
		SRD.%NotDel%
		ORDER BY SRD.RD_FILIAL,SRD.RD_MAT, SRD.RD_DATARQ, SRD.RD_PD, SRD.RD_DATPGT
	EndSql

	While (cAliasSRD)->(!Eof()) .And. SRA->(RA_FILIAL+RA_MAT) == (cAliasSRD)->(RD_FILIAL+RD_MAT)
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Despreza os tipos de roteiros diferentes de FOL.  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If !( (cAliasSRD)->RD_ROTEIR  $ cCalcAux ) .and. (!lCPd131 .or. !( (cAliasSRD)->RD_ROTEIR $ cRot131 .and. (cAliasSRD)->RD_PD $ cPD131 ) )
			(cAliasSRD)->( dbSkip() )
			Loop
		EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Despreza os lanctos de transferencias de outras empresas³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If Len(aTransf) > 0 .And. (!Empty((cAliasSRD)->RD_EMPRESA) .Or. (cAliasSRD)->RD_TIPO2 == 'F')
			// Empresa Externa - registro deve ser ignorado
			If (cAliasSRD)->RD_EMPRESA # FWGrpCompany() .And. !Empty((cAliasSRD)->RD_EMPRESA)
				lRegTrans := .T.
			Else
				For nX := 1 To Len(aTransf)
					If !lRegTrans
						If ( aTransf[nX][1] <> aTransf[nX][4] .Or. aTransf[nX][2] <> aTransf[nX][5]) .And. AnoMes(StoD((cAliasSRD)->RD_DATPGT)) <= aTransf[nX, 12]
							// Foi Transferido de Empresa
							// Condicao 01 - Se o registro pertencer a empresa de origem
							// Condição 02 - Se a empresa de origem é a empresa atual
							If  aTransf[nX, 01] == (cAliasSRD)->RD_EMPRESA .Or. aTransf[nX, 01] == FWGrpCompany() .Or. (cAliasSRD)->RD_TIPO2 == 'F'
								lRegTrans := .T.
							EndIf
						EndIf
					EndIf
				Next nX
			EndIf
			If lRegTrans
				lRegTrans := .F.
				(cAliasSRD)->( dbSkip() )
				Loop
			EndIf
		// Empresa Externa - registro deve ser ignorado
		ElseIf (cAliasSRD)->RD_EMPRESA # FWGrpCompany() .And. !Empty((cAliasSRD)->RD_EMPRESA)
			(cAliasSRD)->( dbSkip() )
			Loop
		Endif

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Desprezar a deducao do INSS IR ferias gerada na folha, pois nas³
	//³ferias este valor ja foi gerado sobre a base total.			  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Nas DIRF 2011/2012 realizar testes qto a ded. inss ferias, p/nao entrar dobrado.³
	//³ Apos ajutes dirf 2011/2012, excluir comentario.                                ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If (cAliasSRD)->RD_PD == aCodFol[164,1] .and. ( (cAliasSRD)->RD_TIPO2 $ "R*I*G*V*F" )
			aAdd( aDedInssF, {(cAliasSRD)->RD_PERIODO, (cAliasSRD)->RD_PD } )
		EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Valida verbas acumuladas  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If !ValidVbAcu()
			(cAliasSRD)->( dbSkip() )
			loop
		EndIf

		If cDtArqAux <> (cAliasSRD)->RD_DATARQ //Mudou o mês
			cDtArqAux := (cAliasSRD)->RD_DATARQ
			lTemADI := .F.
			lPulaADI := .F.
		EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Armazena valores de Inss Para Achar valor da CPMF ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lCPMF .and. Year(StoD((cAliasSRD)->RD_DATPGT)) == MV_PAR06
		If (cAliasSRD)->RD_PD$ aCodFol[064,1]+"/"+aCodFol[065,1]
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Calcula a CPMF utilizando o percentual de desconto do inss³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If (cAliasSRD)->RD_PD == aCodFol[064,1]
					nPos := aScan(aInssFol, { |x| x[1] == MesAno(StoD((cAliasSRD)->RD_DATPGT)) })
					If ( nPercCpmf := 1 - (cAliasSRD)->RD_HORAS % Int((cAliasSRD)->RD_HORAS) ) <> 0 .And. nPercCpmf <> 1
						If nPos == 0
							aAdd(aInssFol,{ MesAno(StoD((cAliasSRD)->RD_DATPGT)), 0.00 ,Round((cAliasSRD)->RD_VALOR/(cAliasSRD)->RD_HORAS*nPercCpmf,2), StoD((cAliasSRD)->RD_DATPGT)})
						Else
							aInssFol[nPos,3] += Round((cAliasSRD)->RD_VALOR/(cAliasSRD)->RD_HORAS*nPercCpmf,2)
						Endif
					Endif
				Else
					If ( nPercCpmf := 1 - (cAliasSRD)->RD_HORAS % Int((cAliasSRD)->RD_HORAS) ) <> 0 .And. nPercCpmf <> 1
						nPos := Ascan(aInssFer, { |x| x[1] == MesAno(StoD((cAliasSRD)->RD_DATPGT)) })
						If nPos == 0
							Aadd(aInssFer,{ MesAno(StoD((cAliasSRD)->RD_DATPGT)), 0.00, Round((cAliasSRD)->RD_VALOR/(cAliasSRD)->RD_HORAS*nPercCpmf,2), StoD((cAliasSRD)->RD_DATPGT) })
						Else
							aInssFer[nPos,3] += Round((cAliasSRD)->RD_VALOR/(cAliasSRD)->RD_HORAS*nPercCpmf,2)
						EndIf
					EndIf
				EndIf
			EndIf
		EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
    //³Verba 0006 só existe após a conversão para P12, enquanto   ³
    //³a verba não existir, o tratamento deve continuar ocorrendo ³
    //³da mesma forma que na P11									   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
    If !lTem006
    	lTem006 := If(cVerifAdt == "S" .And. (cAliasSRD)->RD_PD == aCodFol[006,1],.T.,.F. )
    EndIf

	If !lTem007
    	lTem007 := (cAliasSRD)->RD_PD == aCodFol[007,1] .And. Year(StoD((cAliasSRD)->RD_DATPGT)) == MV_PAR06 .AND. Val(SubStr((cAliasSRD)->RD_DATARQ,1,4)) == MV_PAR06-1 .And. Val(SubStr((cAliasSRD)->RD_DATARQ,5,2)) = 12
    EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Verifica se deve tratar adiantamento e grava no array para ³
	//³tratamento posterior                                       ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If (cVerifAdt == "S" .And. (cAliasSRD)->RD_PD == aCodFol[007,1]) .Or. lTem007
			// Regime Caixa
			// Caso o funcionário tenha sido transferido de Filial e o desconto Adiantamento (ID 0007) transita pela Filial de Destino
			// Verificar pela Data de Referência se ela for anterior à Data de Transferência, não deve ser considerada
			If Len(aTransf) > 0
				lAdiFilOr := .F.
				For nX := 1 To Len(aTransf)
					If  !lAdiFilOr .And.;
						aTransf[nX][8] <> aTransf[nX][10] .And.; // Transferência de Filial
						 StoD((cAliasSRD)->RD_DTREF) <= aTransf[nx, 07] .And.; // Data de Referência é anterior a Data da Transferência
						 AnoMes(StoD((cAliasSRD)->RD_DTREF)) == aTransf[nX, 12] // AnoMês da Referência é o mesmo da Transferência
						lAdiFilOr := .T.
					EndIf
				Next nX
			EndIf
			If lTem006 .Or. lTem007 .Or. aScan( aAdt, { |x| x[1]==(cAliasSRD)->RD_PD .And. x[2]==(cAliasSRD)->RD_DATARQ .And. x[4]==StoD((cAliasSRD)->RD_DATPGT) .And. x[5]==.T.} ) > 0 //Considera verbas de adiantamento rateadas
				aAdd( aAdt, { (cAliasSRD)->RD_PD, (cAliasSRD)->RD_DATARQ, (cAliasSRD)->RD_VALOR, StoD((cAliasSRD)->RD_DATPGT),.T., lAdiFilOr} )
				lTem006 := .F.
				lTem007 := .F.
			Else
				aAdd( aAdt, { (cAliasSRD)->RD_PD, (cAliasSRD)->RD_DATARQ, (cAliasSRD)->RD_VALOR, StoD((cAliasSRD)->RD_DATPGT),.F., lAdiFilOr} )
			Endif
    EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Verifica para que seja utilizada apenas uma verba ³
	//³de Deducao de Dependentes no Mes/Ano              ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Semanalistas ou Pagamento Semanal                 ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If ( SRA->RA_CATFUNC == "S" .Or. SRA->RA_TIPOPGT == "S" ) .And. (cAliasSRD)->RD_PD == aCodFol[059,1]
			If aScan(aDedDpSem,{ |x| x[1] == (cAliasSRD)->RD_PD .And. MesAno(x[2]) == MesAno(StoD((cAliasSRD)->RD_DATPGT)) }) > 0
				(cAliasSRD)->( dbSkip() )
				Loop
			EndIf
			aAdd(aDedDpSem, { (cAliasSRD)->RD_PD, StoD((cAliasSRD)->RD_DATPGT), (cAliasSRD)->RD_VALOR, (cAliasSRD)->RD_SEMANA })
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Deducao de dependentes e Inss para 13o salario                                                     ³
		//³Pode ocorrer uma rescisao de contrato apos o pagamento da 2a parcela do 13o salario                ³
		//³Neste caso nao devo considerar a mesma verba duas vezes, logo considero somente a ultima ocorrencia³
		//³da verba, que neste caso esta na folha do mes em que ocorreu a rescisao de trabalho.               ³
		//³A verba será considerada apenas em condição de Programação de Rateio.				              ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If !( SRA->RA_CATFUNC == "S" .Or. SRA->RA_TIPOPGT == "S" ) .And. ;
			( (cAliasSRD)->RD_PD == aCodFol[062,1] .Or. (cAliasSRD)->RD_PD == aCodFol[169,1] )
			If !( (cAliasSRD)->RD_PD == aCodFol[169,1] .And. (cAliasSRD)->RD_TIPO2 $"C*I" )
				cChvRateio	:= (cAliasSRD)->(RD_CC + RD_ITEM + RD_CLVL)
				If aScan(aDedDp13o,{ |x| x[1] == (cAliasSRD)->RD_PD .And. x[2] == MesAno(StoD((cAliasSRD)->RD_DATPGT)) .And. X[3]==cChvRateio }) > 0
					(cAliasSRD)->( dbSkip() )
					Loop
				EndIf
				aAdd(aDedDp13o, { (cAliasSRD)->RD_PD, MesAno(StoD((cAliasSRD)->RD_DATPGT)), cChvRateio })
			EndIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Deducao de dependente quando teve uma rescisao em um mes e a rescisao complementar foi em outro mes,³
			//³do mesmo ano. Considera somente uma deducao.                                                        ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If (cAliasSRD)->RD_PD == aCodFol[062,1]  .and. !( (cAliasSRD)->RD_TIPO2 $"C*I" )
				If Ascan(aDedDepend13,{ |x| x[1] == (cAliasSRD)->RD_PD  .And. x[2] == Year(StoD((cAliasSRD)->RD_DATPGT)) }) > 0
					(cAliasSRD)->( dbSkip() )
					Loop
				Endif
				Aadd(aDedDepend13, { (cAliasSRD)->RD_PD, Year(StoD((cAliasSRD)->RD_DATPGT)) })
			EndIf
	EndIf

	// Verifica se recebeu saldo de salario e gerada a data de pagamento
	If Empty(dDtPgRes) .And. (cAliasSRD)->RD_PD == aCodFol[048,1]
		dDtPgRes := StoD((cAliasSRD)->RD_DATPGT)
	Endif

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Monta a variavel dPagBenef que sera utilziada na comparacao dos  ³
		//³valores de pensao alimenticia quando se tem 2 beneficiarios.     ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If Right((cAliasSRD)->RD_DATARQ,2) == "13"
			cMesBenef := "12"
		Else
			cMesBenef := SUBSTR( (cAliasSRD)->RD_DATARQ ,5,2)
		Endif
		cAnoBenef := SUBSTR( (cAliasSRD)->RD_DATARQ ,1,4)
		dDtBenef  := CTOD("01/"+cMesBenef+"/"+cAnoBenef)
		If !Empty(dDtBenef)
			cDiaBenef := Alltrim(STR(F_ULTDIA(dDtBenef)))
		Endif
		dPagBenef := CTOD(cDiaBenef+"/"+cMesBenef+"/"+cAnoBenef)

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Esta função buscará os valores das verbas no acumulado,      ³
		//³e suas incidências, e as guardará no array afun, para gravar ³
		//³posteriormente nas tabelas SR4 e SRL.                        ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		f550MontaDados((cAliasSRD)->RD_PD, (cAliasSRD)->RD_FILIAL, "N", cAliasSRD, (cAliasSRD)->RD_IDCMPL, lPulaADI, cPdPLS, cFilSRV)

		(cAliasSRD)->( dbSkip())
	Enddo
Return()

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFuncao    ³BuscaDepen     ºAutor  ³Claudinei Soares º Data ³27/01/2016 º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Busca os Dependentes do funcionario no SRB para montar o    º±±
±±º          ³log com os maiores de 13 anos que não possuem CPF informado º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³                                                            º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ GPEM550                                                    º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function BuscaDepen(cAno)
Local cTextoLog	:= ""
Local nIdade		:= 0

DbSelectArea( "SRB" )
	DbSetOrder( 1 )
	If SRB->(dbSeek(SRA->RA_FILIAL+SRA->RA_MAT))
		While SRB->( !EOF() ) .and. SRB->RB_FILIAL + SRB->RB_MAT == SRA->RA_FILIAL+SRA->RA_MAT
			nIdade := CALC_IDADE(stod(cAno+"1231"),SRB->RB_DTNASC)
			If nIdade >= 18 .And. Empty(SRB->RB_CIC) .And. SRB->RB_TIPIR $ "123"
	        	cTextoLog := OemToAnsi(STR0101) + SRA->RA_MAT + OemToAnsi(STR0102) + Alltrim(SRB->RB_NOME) + OemToAnsi(STR0103) //"A matricula: "+ SRA->RA_MAT + " - Tem o Dependente: " + Alltrim(SRB->RB_NOME) + ", maior que 18 anos que não possui CPF cadastrado.
				Aadd(aLog2,{})
				aTotRegs[13] := Len(aLog2)
				aAdd(aLog2[aTotRegs[13]], cTextoLog )
			EndIf
			SRB->( DbSkip() )
		EndDo
    EndIf
Return()

Static Function MontaPrevi()
Local aRet		:= {}
Local aArea		:= GetArea()
Local nPos		:= 0
Local nI		:= 8
Local cVerba	:= ""
Local cPd		:= ""

dbSelectArea("SMU")
SMU->(dbSetOrder(1))
If SMU->(dbSeek(SRA->RA_FILIAL+SRA->RA_MAT))
	While !SMU->(Eof()) .And. SMU->(MU_FILIAL+MU_MAT)==SRA->RA_FILIAL+SRA->RA_MAT
		nPos 	:= aScan(aTabS073,{|x| x[5] == SMU->MU_CODFOR })
		cVerba 	:= ""
		If nPos > 0
			For nI := 8 To 23
				cPd	:= aTabS073[nPos][nI]
				If !Empty(cPd)
					If SRV->(DbSeek(xFilial('SRV')+cPd)) .And. SRV->RV_TIPOCOD = '1'
						loop
					Else
						If SRV->( EoF() )
							If aTotRegs[7] == 0
								cLog := STR0106 //"Avaliar inconsistências na SRV (Cadastro de Verbas)"
								Aadd(aTitle,cLog)
								Aadd(aLog,{})
								aTotRegs[7] := len(aLog)
							EndIf
							Aadd(aLog[aTotRegs[7]],STR0054 + cPd) // Verba:
						EndIf
					EndIf
				EndIf
				cVerba += aTabS073[nPos][nI] +"/"
			Next nI
			aadd(aRet,{	SMU->MU_CODFOR	,; 	//1)
						ctod("01/" + substr(SMU->MU_PERINI,1,2) +"/"+ substr(SMU->MU_PERINI,3,4))	,;	//2)
						If(!Empty(SMU->MU_PERFIM),lastday(ctod("01/" + substr(SMU->MU_PERFIM,1,2) +"/"+ substr(SMU->MU_PERFIM,3,4))),CtoD("//"))	,;	//3)
						cVerba			,;	//4)
						{},				 ;  //5)
						aTabS073[nPos][6]	,			 ;  //6)
						aTabS073[nPos][7]				 ;  //7)
						})
		EndIf
		SMU->(dbSkip())
	EndDo
EndIf

If aTotRegs[7] > 0
	RestArea( aArea )
	Return()
EndIf

RestArea(aArea)
Return aRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFuncao    ³BusCodAbo      ºAutor  ³Jônatas A. T. A. º Data ³09/02/2016 º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Determina todos os identificadores de cálculo referentes ao º±±
±±º          ³abono ´pecuniário (inclusive diferenças sobre abono) que    º±±
±±º          ³incidem p/ DIRF "0", e suas respectivas verbas mês seguinte.º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³                                                            º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ GPEM550                                                    º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function BusCodAbo()

Local cCodAbo		:= ""
Local cCodAboMS		:= ""
Local cCodMSeg		:= ""
Local cFilSRV		:= xFilial( "SRV", SRA->RA_FILIAL )
local cPdDif		:= ""
Local cPdDifMS		:= ""
Local cPdDifMSeg	:= ""
Local cIdCalc		:= ""
Local nElem			:= 0
Local nCodAB		:= 0
Local nPosMS		:= 0

aCodAboPec	:= {}
aAbMesSeg	:= {}

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Alimenta identificadores 'mês' de abono pecuniario           ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
//                |Id Mês |Vb Mês |Id Mês Seg |Vb Mês Seg |RV_CODMSEG|
aAdd( aCodAboPec, { "0074", 	"", 	"0205",			"",			"" } ) // Abono Pecun. Ferias
aAdd( aCodAboPec, { "0079", 	"", 	"0206", 		"",			"" } ) // Adic. 1/3 Sobre Abono Pecun.
aAdd( aCodAboPec, { "0094", 	"", 	"0207", 		"", 		"" } ) // Dif Abono Pecun Ferias
aAdd( aCodAboPec, { "0095", 	"", 	"0208", 		"", 		"" } ) // Dif 1/3 sobre Abono Ferias
aAdd( aCodAboPec, { "0622", 	"", 	"0633", 		"", 		"" } ) // Media Horas sobre Abono
aAdd( aCodAboPec, { "0623", 	"", 	"0634", 		"", 		"" } ) // Media Valor sobre Abono
aAdd( aCodAboPec, { "0632", 	"", 	"0635", 		"", 		"" } ) // Adicionais sobre Abono Pecuniario
aAdd( aCodAboPec, { "1312", 	"", 	"1313", 		"", 		"" } ) // ATS Abono Mes
aAdd( aCodAboPec, { "1314", 	"", 	"1315", 		"", 		"" } ) // ATS Abono Mês s/verbas
aAdd( aCodAboPec, { "1316", 	"", 	"1317", 		"", 		"" } ) // Periculosidade Abono Mês
aAdd( aCodAboPec, { "1318", 	"", 	"1319", 		"", 		"" } ) // Periculosidade Abono Mês s/verbas
aAdd( aCodAboPec, { "1320", 	"", 	"1321", 		"", 		"" } ) // Insalubridade Abono Mês
aAdd( aCodAboPec, { "1322", 	"", 	"1323", 		"", 		"" } ) // Insalubridade Abono Mês s/verbas
aAdd( aCodAboPec, { "1324", 	"", 	"1325", 		"", 		"" } ) // Adic. Cargo Confiança Abonos Mes
aAdd( aCodAboPec, { "1326", 	"", 	"1327", 		"", 		"" } ) // Adic. Transferencia Abono Mes
aAdd( aCodAboPec, { "1330", 	"", 	"1331", 		"", 		"" } ) // DSR sobre Medias Abono

If Len( aCodFol ) > 1409
	aAdd( aCodAboPec, { "1407", 	"", 	"1409", 		"", 		"" } ) // Pagto Peric. Sobre Medias Abono
	aAdd( aCodAboPec, { "1408", 	"", 	"1410", 		"", 		"" } ) // Pagto Insalub. Sobre Medias Abono
EndIf

aAdd( aCodAboPec, { "0164", 	"", 		"", 		"", 		"" } ) // Férias Pagas Mês Anterior
aAdd( aCodAboPec, { "1449", 	"", 		"", 		"", 		"" } ) // Abonos Pagos Mes Anterior

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Carrega codigos das verbas referentes a abono de férias do   ³
//³ mês atual, do mês seguinte (incidência "0" p/ DIRF) e a verba³
//³ RV_CODMSEG de cada uma, inclusive para as diferenças quando  ³
//³ geradas em verbas distintas para cada adicional.             ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
nTotAbo := Len( aCodAboPec )
For nElem := 1 To nTotAbo

	cIdCalc := aCodAboPec[ nElem, 1 ]
	If LEN(aCodFol) >= VAL(cIdCalc)
	 	cCodAbo := aCodFol[ &( cIdCalc ), 1 ]

		If !Empty( cCodAbo ) .And. ( cIdCalc == "0164" .or. cIdCalc == "1449" .Or. ( Alltrim( PosSRV( cCodAbo, cFilSRV, "RV_DIRF" ) ) == "0" ) )

			aCodAboPec[ nElem, 2 ] := cCodAbo
			cPdDif	:= PosSRV( cCodAbo, cFilSRV, "RV_FERSEG" )

			If (cIdCalc != "0164" .and. cIdCalc != "1449" )
				If !Empty( cCodAboMS := aCodFol[ &( aCodAboPec[ nElem, 3 ] ), 1 ] ) .And. ( Alltrim( PosSRV( cCodAboMS, cFilSRV, "RV_DIRF" ) ) == "0" )

					aCodAboPec[ nElem, 4 ] := cCodAboMS
					If !Empty( cCodMSeg := PosSRV( aCodAboPec[ nElem, 4 ], cFilSRV, "RV_CODMSEG" ) ) .And. ( Alltrim( PosSRV( cCodMSeg, cFilSRV, "RV_DIRF" ) ) == "0" )

						aCodAboPec[ nElem, 5 ] := cCodMSeg
						If !Empty( cPdDif ) .And. Alltrim( PosSRV( cPdDif, cFilSRV, "RV_DIRF" ) ) == "0"

							cPdDifMS := PosSRV( cCodAboMS, cFilSRV, "RV_FERSEG" )
							If !Empty( cPdDifMS ) .And. Alltrim( PosSRV( cPdDifMS, cFilSRV, "RV_DIRF" ) ) == "0"
								If !Empty( cPdDifMSeg := PosSRV( cPdDifMS, cFilSRV, "RV_CODMSEG" ) ) .And. Alltrim( PosSRV( cPdDifMSeg, cFilSRV, "RV_DIRF" ) ) == "0"
									aAdd( aCodAboPec, { "", 	cPdDif, 	"", 		cPdDifMS, 		cPdDifMSeg } ) // Adiciona verbas de diferenças de abono
								EndIf
							EndIf
						EndIf
					EndIf
				EndIf
			EndIf
		EndIf
	EndIf
Next nElem

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Array aAbMesSeg: Cód. Verba Mês seguinte(RV_CODMSEG) + Array ³
//³ com todos os códigos das verbas que a associam.              ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
For nCodAB := 1 To Len( aCodAboPec )
	If !Empty( aCodAboPec[ nCodAB, 5 ] )
		If Empty( aAbMesSeg ) .Or. ( nPosMS := aScan( aAbMesSeg, { |x| x[ 1 ] == aCodAboPec[ nCodAB, 5 ] } ) ) == 0
			aAdd( aAbMesSeg, { aCodAboPec[ nCodAB, 5 ], { aCodAboPec[ nCodAB, 4 ] } } )
		ElseIf ( aScan( aAbMesSeg[ nPosMS, 2 ], { |x| x == aCodAboPec[ nCodAB, 4 ] } ) ) == 0
			aAdd( aAbMesSeg[ nPosMS, 2 ], aCodAboPec[ nCodAB, 4 ] )
		EndIf
	EndIf
Next

Return

/*/{Protheus.doc} OpenTDN
Abre o navegador padrão com a página centralizadora sobre a DIRF no TDN
@author cicero.pereira
@since 11/01/2018
@version 12.1.17
/*/
Static Function OpenTDN()

	cURL := "http://tdn.totvs.com/x/aq_cEw"

	shellExecute("Open", cURL, "", "", SW_NORMAL)

Return

/*/{Protheus.doc} FuncAux
Função auxiliar para a chamada do diagnóstico
@author cicero.pereira
@since 19/01/2018
@version 12.1.17
@return lRet, .T. Realiza a rotina de diagnóstico, .F. Executa a geração da DIRF
/*/
Static Function FuncAux()

	Local lRet := .F.

	IF !lAutomato
		If ! MsgNoYes( STR0153 + CRLF + STR0154, STR0155 )
			If MsgYesNo(STR0156, STR0155)	// "Deseja executar o diagnóstico agora?"
				lRet := .T.
			EndIf
		EndIf
	Endif

Return lRet

/*/{Protheus.doc} fBscRend()
Função auxiliar  verificar se existem lançamentos de Rendimentos Tributáveis na Rescisão Sem Saldo
@author raquel.andrade
@since 02/12/2022
@return lRet, .T. possui lançamentos
/*/
Static Function fBscRend()
Local aArea			:= GetArea()
Local cQueryAlias 	:= GetNextAlias()
Local lResult 		:= .F.
Local cFilPd		:= xFilial("SRV", SRA->RA_FILIAL)
Local cMesAnoRes	:= SubString(DtoS(SRA->RA_DEMISSA),1,6)

	BeginSql alias cQueryAlias
		Select SUM(SOMA) AS TOTAL From(
		Select COUNT(*) AS SOMA
		From %Table:SRR% SRR
		INNER JOIN %Table:SRV% SRV ON SRV.RV_FILIAL = %exp:cFilPd% AND
									  SRV.RV_COD = SRR.RR_PD AND
								      SRV.RV_DIRF = 'A' AND
									  SRV.RV_TIPOCOD = '1'
		Where SRR.RR_FILIAL = %Exp: SRA->RA_FILIAL%  AND
			  SRR.RR_MAT = %Exp: SRA->RA_MAT% AND
			  SUBSTRING(SRR.RR_DATA,1,6) >= %Exp: cMesAnoRes% AND
			  SRR.%NotDel% AND
			  SRV.%NotDel%
		) RESULTADO
	EndSql

	lResult := (cQueryAlias)->TOTAL > 0

	(cQueryAlias)->(DbCloseArea())

	RestArea(aArea)


Return lResult

/*/{Protheus.doc} fVldFol()
Função auxiliar  para verificar se foi realizado cálculo de Plano de Saúde (integrado em Folha) em outros período
@author raquel.andrade
@since 15/02/2022
@return lRet, .T. Não possui lançamentos
/*/
Static Function fVldFol(cCompPg, cPd, cAno)
Local aArea			:= GetArea()
Local cQueryAlias 	:= GetNextAlias()
Local lResult 		:= .F.
Local cRotFol		:= If(SRA->RA_CATFUNC $ "A*P" , "AUT" , "FOL" )

	BeginSql alias cQueryAlias
		Select SUM(SOMA) AS TOTAL From(
		Select COUNT(*) AS SOMA
		From %Table:SRD% SRD
		Where SRD.RD_FILIAL = %Exp: SRA->RA_FILIAL%  AND
			  SRD.RD_MAT = %Exp: SRA->RA_MAT% AND
			  SRD.RD_ROTEIR = %Exp: cRotFol% AND
			  SRD.RD_DATARQ = %Exp: cCompPg% AND
			  SRD.RD_PD = %Exp: cPd% AND
			  SUBSTRING(SRD.RD_DATPGT,1,4) > %Exp: cAno% AND
			  SRD.%NotDel%
		) RESULTADO
	EndSql

	lResult := (cQueryAlias)->TOTAL = 0

	(cQueryAlias)->(DbCloseArea())

	RestArea(aArea)


Return lResult

/*/{Protheus.doc} fBscVlDed
Busca valor de Dedução Simplificada
@author raquel.andrade
@since 12/01/2024
@return nValDed
/*/
Static Function fBscVlDed(cMes,cAno)
Local aArea		:= GetArea()
Local aTabIR 	 := {}
Local aTabIRRF 	:= {}
Local nX		:= 0
Local nValDed	:= 0

Default cMes	:= ""
Default cAno	:= ""

fCarrTab( @aTabIRRF, "S002",  )
For nX := 1 To Len(aTabIRRF)
	If aTabIRRF[nX][1] == "S002"
		If aTabIRRF[nX][5] <= cAno+cMes .And. aTabIRRF[nX][6] >= cAno+cMes
			nValDed	:= aTabIRRF[nX][23]
		EndIf
	EndIf
Next nX

RestArea(aArea)

Return nValDed

/*/{Protheus.doc} fDepRes()
Função auxiliar  para verificar se Dedução Depedente foi Paga no mês da Rescisão
@author raquel.andrade
@since 14/02/2022
@return lRet, .T. Não possui lançamentos
/*/
Static Function fDepRes(cCompPg, cPd)
Local aArea			:= GetArea()
Local cQueryAlias 	:= GetNextAlias()
Local lResult 		:= .F.
Local cRotFol		:= If(SRA->RA_CATFUNC $ "A*P" , "AUT" , "FOL" )

Default cCompPg	:= ""
Default cPd		:= ""


	BeginSql alias cQueryAlias
		Select SUM(SOMA) AS TOTAL From(
		Select COUNT(*) AS SOMA
		From %Table:SRD% SRD
		Where SRD.RD_FILIAL = %Exp: SRA->RA_FILIAL%  AND
			  SRD.RD_MAT = %Exp: SRA->RA_MAT% AND
			  SRD.RD_ROTEIR= %Exp: cRotFol% AND
			  SRD.RD_PD = %Exp: cPd% AND
			  SUBSTRING(SRD.RD_DATPGT,1,6) = %Exp: cCompPg% AND
			  SRD.RD_TIPO2 = 'G' AND
			  SRD.%NotDel%
		) RESULTADO
	EndSql

	lResult := (cQueryAlias)->TOTAL > 0

	(cQueryAlias)->(DbCloseArea())

	RestArea(aArea)


Return lResult

/*/{Protheus.doc} fMesesRRA()
Função que retorna a quantidade de meses referente ao RRA
@author Silvia Taguti
@since 24/04/2024
@return nMesRRA
@param cFilRHH, characters, Filial
@param cMatRHH, characters, Matricula
@param cIdCmpl, characters, Complemento
@param cAnoMesRHH, characters, Competencia
/*/
Static Function fMesesRRA(cFilRHH,cMatRHH,cIdCmpl,cAnoMesRHH)

Local aArea			:= GetArea()
Local cAliasRHH		:= "QRHH"
Local cQuery    	:= ""
Local nMesRRA   	:= 0
Local cRRAData  	:= ""

Default cIdCmpl 	:= ""
Default cAnoMesRHH  := ""
Default cFilRHH 	:= ""
Default cMatRHH    	:= ""

	cQuery := "SELECT RHH_FILIAL,RHH_DATA,RHH_MAT,RHH_MESANO,RHH_VB,RHH_CC,RHH_ITEM,RHH_CLVL,RHH_RRA,RHH_IDCMPL,RHH_GRRA,RHH_VERBA,RHH_VALOR,RHH_PROCES,RHH_ROTEIR,RHH_COMPL_, R_E_C_N_O_ AS RECNUM "
	cQuery += "  FROM " + RetSqlName( "RHH" ) + " RHH "
    cQuery += "	WHERE "
    cQuery += " RHH.RHH_FILIAL = '"	+ cFilRHH	+ "' AND  "
	cQuery += "	RHH.RHH_MAT = '"	+ cMatRHH	+ "' AND  "
	cQuery += " RHH.RHH_MESANO = '" +cAnoMesRHH+ " 'AND "
    cQuery += "	RHH.RHH_IDCMPL = '"	+ cIdCmpl	+ "' AND  "
	cQuery += " RHH.RHH_COMPL_ = 'S' AND "
	cQuery += "	RHH.RHH_GRRA = '1' AND  "
	cQuery += " RHH.D_E_L_E_T_ = ' ' "
    cQuery += "	ORDER BY RHH_FILIAL,RHH_MAT,RHH_IDCMPL,RHH_DATA "

	cQuery := ChangeQuery( cQuery )
	dbUseArea( .T., "TOPCONN", TcGenQry( ,,cQuery ), cAliasRHH )

	If (cAliasRHH)->(!Eof())
		While((cAliasRHH)->(!Eof()))
			If cRRAData <> (cAliasRHH)->RHH_DATA .And. (cAliasRHH)->RHH_MESANO > (cAliasRHH)->RHH_DATA
				cRRAData 	:= (cAliasRHH)->RHH_DATA
				nMesRRA		+= 1
			EndIf
			(cAliasRHH)->(dbSkip())
		EndDo
	Endif

( cAliasRHH )->( dbCloseArea() )

RestArea(aArea)

Return nMesRRA

/*/{Protheus.doc} SchedDef
    Definições de agendamento do Schedule.
    @type Function
    @version 12.1.2310
    @author arthur.sales
    @since 04/06/2024
    @return Array, Definições do agendamento
/*/
Static Function SchedDef() As Array
    // Declaração das variáveis locais
    Local aParam As Array

    // Inicialização das variáveis
    aParam := {}

    // Montagem da estrutura do vetor de retorno
    AAdd(aParam, "P")      // Tipo do agendamento: "P" = Processo | "R" = Relatório
    AAdd(aParam, "GPM550") // Pergunte (SX1) (usar "PARAMDEF" caso não tenha conjunto de perguntas)
    AAdd(aParam, "")       // Alias principal (exclusivo para relatórios)
    AAdd(aParam, {})       // Vetor de ordenação (exclusivo para relatórios)
    AAdd(aParam, "")       // Título (exclusivo para relatórios)
Return aParam

/*/{Protheus.doc} f3MesesFer()
Função que verifica se as férias abrange 3 meses
@author lidio.oliveira
@since 04/12/2024
@param cFilSRH, characters, Filial
@param cMatSRH, characters, Matricula
@param cDtRcboPgt, characters, Data de Pagamento das férias
@param cSeqSRD, characters, Sequencia de Pagamento das férias
@return lRet
/*/
Static Function f3MesesFer(cFilSRH, cMatSRH, cDtRcboPgt, cSeqSRD)

	Local aArea			:= GetArea()
	Local aAreaSRH		:= SRH->( GetArea() )
	Local lRet			:= .F.
	Local nSeqSRH		:= 0

	Default cFilSRH 	:= ""
	Default cMatSRH  	:= ""
	Default cDtRcboPgt 	:= ""
	Default cSeqSRD    	:= ""

	dbSelectArea("SRH")
	dbSetOrder(3) //RH_FILIAL+RH_MAT+RH_ROTEIR+DTOS(RH_DTRECIB)
	If SRH->(DBSeek(cFilSRH + cMatSRH + "FER" + cDtRcboPgt))
		While SRH->( !EOF() ) .And. SRH->RH_FILIAL + SRH->RH_MAT + SRH->RH_ROTEIR + DTOS(SRH->RH_DTRECIB) == cFilSRH + cMatSRH + "FER" + cDtRcboPgt
			If Month2Str(SRH->RH_DATAINI) == "01" .And. Month2Str(SRH->RH_DATAFIM) == "03"
				lRet := .T.
			EndIf
			If Empty(cSeqSRD) .Or. Val(cSeqSRD) == nSeqSRH
				Exit
			EndIf
			nSeqSRH ++
		EndDo
	EndIf

	RestArea(aAreaSRH)
	RestArea(aArea)

Return lRet
