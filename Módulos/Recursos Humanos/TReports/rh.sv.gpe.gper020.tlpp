#Include "totvs.framework.treports.integratedprovider.th"
#Include "tlpp-core.th"
#Include "tlpp-rest.th"
#Include "rh.sv.gpe.gper020.ch"

namespace totvs.protheus.rh.treportsintegratedprovider

/*/{Protheus.doc} GPER020TReportsBusinessObject:new()
    Classe do objeto de negÛcio do RelatÛrio RelaÁ„o de LÌquidos - vers„o BRA.
    @type Class
    @version 12.1.2310
    @author arthur.sales
    @since 08/11/2023
/*/
@totvsFrameworkTReportsIntegratedProvider(active=.T., team="SIGAGPE", tables="SRA, CTT, SRG, SRY, SRC, SRD, SRH, SRR, SRQ, SRV", customTables="SRA, CTT", name="RelatÛrio RelaÁ„o de LÌquidos", country="ALL", initialRelease="12.1.2310")
Class GPER020TReportsBusinessObject From totvs.framework.treports.integratedprovider.IntegratedProvider
    // Define os mÈtodos da classe
    Public Method new()            As Object
    Public Method getDescription() As Character
    Public Method getData()        As Object
    Public Method getSchema()      As Object
EndClass

/*/{Protheus.doc} GPER020TReportsBusinessObject:new()
    Instancia a classe do objeto de negÛcio.
    @type Method
    @version 12.1.2310
    @author arthur.sales
    @since 08/11/2023
    @return Object, Inst‚ncia do objeto de negÛcio
/*/
Method new() As Object Class GPER020TReportsBusinessObject
    _Super:new()

    // Define a ¡rea
    self:appendArea(STR0001) // "RH"

    // Define o nome do objeto de negÛcio
    self:setDisplayName(STR0002) // "RelaÁ„o de LÌquidos - vers„o BRA"
Return self

/*/{Protheus.doc} GPER020TReportsBusinessObject:getDescription()
    Retorna a descriÁ„o do objeto de negÛcio.
    @type Method
    @version 12.1.2310
    @author arthur.sales
    @since 08/11/2023
    @return Character, DescriÁ„o do objeto de negÛcio
/*/
Method getDescription() As Character Class GPER020TReportsBusinessObject
Return STR0003 // "RelatÛrio RelaÁ„o de LÌquidos."

/*/{Protheus.doc} GPER020TReportsBusinessObject:getData()
    Captura os dados do objeto de negÛcio.
    @type Method
    @version 12.1.2310
    @author arthur.sales
    @since 08/11/2023
    @return Object, Dados do objeto de negÛcio
/*/
Method getData(nPage As Numeric, oFilter As Object) As Object Class GPER020TReportsBusinessObject
    // DeclaraÁ„o das vari·veis locais
    Local cQuery          As Character // Query para busca dos registros
    Local cAlias          As Character // Alias do arquivo tempor·rio principal
    Local cFiltro         As Character // Filtro do objeto de negÛcio
    Local cFilExec        As Character // Nome da filial de execuÁ„o
    Local cEmpExec        As Character // Nome da empresa de execuÁ„o
    Local cProcedimentos  As Character // Par‚metro Procedimentos (roteiros de c·lculo)
    Local cFunContaCorr   As Character // Par‚metro Qto. a Conta Corrente (funcion·rios com ou sem conta corrente)
    Local cDtPagamentoDe  As Character // Par‚metro Data AlteraÁ„o De
    Local cDtPagamentoAte As Character // Par‚metro Data AlteraÁ„o AtÈ
    Local cFilialDe       As Character // Par‚metro Filial De
    Local cFilialAte      As Character // Par‚metro Filial AtÈ
    Local cCCDe           As Character // Par‚metro C.C. De
    Local cCCAte          As Character // Par‚metro C.C. AtÈ
    Local cMatriculaDe    As Character // Par‚metro MatrÌcula De
    Local cMatriculaAte   As Character // Par‚metro MatrÌcula AtÈ
    Local cNomeDe         As Character // Par‚metro Nome De
    Local cNomeAte        As Character // Par‚metro Nome AtÈ
    Local cContaCorrDe    As Character // Par‚metro Conta Corrente De
    Local cContaCorrAte   As Character // Par‚metro Conta Corrente AtÈ
    Local cBancoAgencDe   As Character // Par‚metro Banco/AgÍncia De
    Local cBancoAgencAte  As Character // Par‚metro Banco/AgÍncia AtÈ
    Local cNomeFun        As Character // Par‚metro Nomes Funcion·rios (imprime ou n„o os nomes dos funcion·rios)
    Local cImprimir       As Character // Par‚metro Imprimir (imprime funcion·rios, benefici·rios ou ambos)
    Local cFilSRACTT      As Character // Express„o SQL do join dos campos de filial das tabelas SRA e CTT
    Local cAcessaSRA      As Character // Bloco para verificar acesso
    Local cParBanco       As Character // Filtro de busca de Banco para os benefici·rios
    Local cParConta       As Character // Filtro de busca de Conta para os benefici·rios
    Local cValidFil       As Character // Filiais v·lidas
    Local cCustomFields   As Character // Campos customizados no formato SQL
    Local cName           As Character // Nome real do campo
    Local JParams         As JSON      // Par‚metros do objeto de negÛcio
    Local aRoteiros       As Array     // Roteiros de c·lculo
    Local aValBenef       As Array     // InformaÁıes dos benefici·rios
    Local aBenefCop       As Array     // Vetor auxiliar de informaÁıes dos benefici·rios
    Local aProcedimentos  As Array     // Vetor de procedimentos (roteiros)
    Local aCategorias     As Array     // Vetor de categorias
    Local aSituacoes      As Array     // Vetor de situaÁıes
    Local aProcessos      As Array     // Vetor de processos
    Local aPDFields       As Array     // Campos que podem ser exibidos de acordo com a LGPD
    Local aAllFields      As Array     // Estrutura de todos os campos do ON
    Local nAux            As Numeric   // Contador auxiliar
    Local nValor          As Numeric   // Valor lÌquido do funcion·rio
    Local nProcedimentos  As Numeric   // Tamanho do campo RY_CALCULO
    Local nProcessos      As Numeric   // Tamanho do campo RCJ_CODIGO
    Local nParamOrder     As Numeric   // Contador auxiliar para definiÁ„o de valor dos bind parameters
    Local nFields         As Numeric
    Local lImprFunci      As Logical   // Flag de impress„o de funcion·rio
    Local lImprBenef      As Logical   // Flag de impress„o de benefici·rio
    Local lFuncTrf        As Logical   // Flag de funcion·rio transferido
    Local lObfuscated     As Logical   // Flag que indica se tem algum campo para ofuscar
    Local dDataDe         AS Date      // Par‚metro Data De no tipo data
    Local dDataAte        AS Date      // Par‚metro Data AtÈ no tipo data
    Local oStatement      As Object    // Inst‚ncia da classe FwExecStatement
    Local jData           As JSON      // InformaÁıes a serem adicionadas no ON
    Local jLGPD           As JSON      // Indica quais campos devem ser ofuscados

    // InicializaÁ„o das vari·veis locais
    cQuery          := ""
    cAlias          := ""
    cFiltro         := IIf(oFilter:hasFilter(), "AND " + oFilter:getSQLExpression(), "")
    cFilExec        := AllTrim(FwFilialName())
    cEmpExec        := AllTrim(FwEmpName(cEmpAnt))
    cProcedimentos  := ""
    cFunContaCorr   := ""
    cDtPagamentoDe  := ""
    cDtPagamentoAte := ""
    cFilialDe       := ""
    cFilialAte      := ""
    cCCDe           := ""
    cCCAte          := ""
    cMatriculaDe    := ""
    cMatriculaAte   := ""
    cNomeDe         := ""
    cNomeAte        := ""
    cContaCorrDe    := ""
    cContaCorrAte   := ""
    cBancoAgencDe   := ""
    cBancoAgencAte  := ""
    cNomeFun        := ""
    cImprimir       := ""
    cFilSRACTT      := FwJoinFilial("SRA", "CTT")
    cAcessaSRA      := &(" {|| " + ChkRH("GPER020", "SRA", "2") + "} ")
    cParBanco       := ""
    cParConta       := ""
    cValidFil       := fValidFil()
    cCustomFields   := ""
    cName           := ""
    jParams         := oFilter:getParameters()
    aRoteiros       := {}
    aValBenef       := {}
    aBenefCop       := {}
    aProcedimentos  := {}
    aCategorias     := {}
    aSituacoes      := {}
    aProcessos      := {}
    aPDFields       := {}
    aAllFields      := {}
    nAux            := 1
    nValor          := 0
    nParamOrder     := 1
    nProcedimentos  := GetSX3Cache("RY_CALCULO", "X3_TAMANHO")
    nProcessos      := GetSX3Cache("RCJ_CODIGO", "X3_TAMANHO")
    nFields         := 1
    lImprFunci      := .T.
    lImprBenef      := .T.
    lFuncTrf        := .F.
    lObfuscated     := .F.
    oStatement      := NIL
    jData           := NIL
    jLGPD           := JSONObject():New()

    // Verifica se precisa fazer o tratamento para LGPD
    aPDFields   := FwProtectedDataUtil():UsrAccessPDField(__cUserID, self:getArrayFields())
    lObfuscated := Len(aPDFields) != Len(self:getArrayFields())
    aAllFields  := self:getStructFields()

    // Adiciona no JSON todos os campos como atributos e com o conte˙do sendo uma flag que indica se o campo deve ser ofuscado
    For nFields := 1 To Len(aAllFields)
        cName        := Trim(aAllFields[nFields]:getName())
        jLGPD[cName] := AScan(aPDFields, {|x| Trim(x) == cName}) <= 0
    Next nFields

    // Captura o valor dos par‚metros
    If (jParams != NIL)
        cFunContaCorr   := IIf(jParams:hasProperty("PAR_FUNCONTACORR")   .and. Len(jParams["PAR_FUNCONTACORR"])   > 0 .and.!Empty(jParams["PAR_FUNCONTACORR"][1]),   jParams["PAR_FUNCONTACORR"][1],   "3")
        cDtPagamentoDe  := IIf(jParams:hasProperty("PAR_DTPAGAMENTODE")  .and. Len(jParams["PAR_DTPAGAMENTODE"])  > 0 .and.!Empty(jParams["PAR_DTPAGAMENTODE"][1]),  jParams["PAR_DTPAGAMENTODE"][1],  FwTimeStamp(6, CToD("")))
        cDtPagamentoAte := IIf(jParams:hasProperty("PAR_DTPAGAMENTOATE") .and. Len(jParams["PAR_DTPAGAMENTOATE"]) > 0 .and.!Empty(jParams["PAR_DTPAGAMENTOATE"][1]), jParams["PAR_DTPAGAMENTOATE"][1], FwTimeStamp(6, CToD("")))
        cFilialDe       := IIf(jParams:hasProperty("PAR_FILIALDE")       .and. Len(jParams["PAR_FILIALDE"])       > 0 .and.!Empty(jParams["PAR_FILIALDE"][1]),       jParams["PAR_FILIALDE"][1],       "")
        cFilialAte      := IIf(jParams:hasProperty("PAR_FILIALATE")      .and. Len(jParams["PAR_FILIALATE"])      > 0 .and.!Empty(jParams["PAR_FILIALATE"][1]),      jParams["PAR_FILIALATE"][1],      Replicate("Z", GetSX3Cache("RA_FILIAL", "X3_TAMANHO")))
        cCCDe           := IIf(jParams:hasProperty("PAR_CENTROCUSTODE")  .and. Len(jParams["PAR_CENTROCUSTODE"])  > 0 .and.!Empty(jParams["PAR_CENTROCUSTODE"][1]),  jParams["PAR_CENTROCUSTODE"][1],  "")
        cCCAte          := IIf(jParams:hasProperty("PAR_CENTROCUSTOATE") .and. Len(jParams["PAR_CENTROCUSTOATE"]) > 0 .and.!Empty(jParams["PAR_CENTROCUSTOATE"][1]), jParams["PAR_CENTROCUSTOATE"][1], Replicate("Z", GetSX3Cache("RA_CC", "X3_TAMANHO")))
        cMatriculaDe    := IIf(jParams:hasProperty("PAR_MATRICULADE")    .and. Len(jParams["PAR_MATRICULADE"])    > 0 .and.!Empty(jParams["PAR_MATRICULADE"][1]),    jParams["PAR_MATRICULADE"][1],    "")
        cMatriculaAte   := IIf(jParams:hasProperty("PAR_MATRICULAATE")   .and. Len(jParams["PAR_MATRICULAATE"])   > 0 .and.!Empty(jParams["PAR_MATRICULAATE"][1]),   jParams["PAR_MATRICULAATE"][1],   Replicate("Z", GetSX3Cache("RA_MAT", "X3_TAMANHO")))
        cNomeDe         := IIf(jParams:hasProperty("PAR_NOMEDE")         .and. Len(jParams["PAR_NOMEDE"])         > 0 .and.!Empty(jParams["PAR_NOMEDE"][1]),         jParams["PAR_NOMEDE"][1],         "")
        cNomeAte        := IIf(jParams:hasProperty("PAR_NOMEATE")        .and. Len(jParams["PAR_NOMEATE"])        > 0 .and.!Empty(jParams["PAR_NOMEATE"][1]),        jParams["PAR_NOMEATE"][1],        Replicate("Z", GetSX3Cache("RA_NOME", "X3_TAMANHO")))
        cContaCorrDe    := IIf(jParams:hasProperty("PAR_CONTACORRDE")    .and. Len(jParams["PAR_CONTACORRDE"])    > 0 .and.!Empty(jParams["PAR_CONTACORRDE"][1]),    jParams["PAR_CONTACORRDE"][1],    "")
        cContaCorrAte   := IIf(jParams:hasProperty("PAR_CONTACORRATE")   .and. Len(jParams["PAR_CONTACORRATE"])   > 0 .and.!Empty(jParams["PAR_CONTACORRATE"][1]),   jParams["PAR_CONTACORRATE"][1],   Replicate("Z", GetSX3Cache("RA_CTDEPSA", "X3_TAMANHO")))
        cBancoAgencDe   := IIf(jParams:hasProperty("PAR_BANCOAGENCDE")   .and. Len(jParams["PAR_BANCOAGENCDE"])   > 0 .and.!Empty(jParams["PAR_BANCOAGENCDE"][1]),   jParams["PAR_BANCOAGENCDE"][1],   "")
        cBancoAgencAte  := IIf(jParams:hasProperty("PAR_BANCOAGENCATE")  .and. Len(jParams["PAR_BANCOAGENCATE"])  > 0 .and.!Empty(jParams["PAR_BANCOAGENCATE"][1]),  jParams["PAR_BANCOAGENCATE"][1],  Replicate("Z", GetSX3Cache("RA_BCDEPSA", "X3_TAMANHO")))
        cNomeFun        := IIf(jParams:hasProperty("PAR_NOMEFUN")        .and. Len(jParams["PAR_NOMEFUN"])        > 0 .and.!Empty(jParams["PAR_NOMEFUN"][1]),        jParams["PAR_NOMEFUN"][1],        "1")
        cImprimir       := IIf(jParams:hasProperty("PAR_IMPRIMIR")       .and. Len(jParams["PAR_IMPRIMIR"])       > 0 .and.!Empty(jParams["PAR_IMPRIMIR"][1]),       jParams["PAR_IMPRIMIR"][1],       "3")
        aProcedimentos  := IIf(jParams:hasProperty("PAR_PROCEDIMENTOS"), jParams["PAR_PROCEDIMENTOS"], {})
        aSituacoes      := IIf(jParams:hasProperty("PAR_SITUACOES"),     jParams["PAR_SITUACOES"],     {})
        aCategorias     := IIf(jParams:hasProperty("PAR_CATEGORIAS"),    jParams["PAR_CATEGORIAS"],    {})
        aProcessos      := IIf(jParams:hasProperty("PAR_PROCESSOS"),     jParams["PAR_PROCESSOS"],     {})
    EndIf

    // Define o valor das flags de impress„o
    lImprFunci := AllTrim(cImprimir) $ "1|3"
    lImprBenef := AllTrim(cImprimir) $ "2|3"

    // Percorre as situaÁıes para tratar registro nulo ou em branco (caso n„o tratar d· erro no banco)
    For nAux := 1 To Len(aSituacoes)
        aSituacoes[nAux] := IIf(aSituacoes[nAux] == NIL .or. Empty(aSituacoes[nAux]), " ", aSituacoes[nAux])
    Next nAux

    // Percorre as categorias para tratar registro nulo ou em branco (caso n„o tratar d· erro no banco)
    For nAux := 1 To Len(aCategorias)
        aCategorias[nAux] := IIf(aCategorias[nAux] == NIL .or. Empty(aCategorias[nAux]), " ", aCategorias[nAux])
    Next nAux

    // Percorre os processos para tratar registro nulo ou em branco (caso n„o tratar d· erro no banco)
    For nAux := 1 To Len(aProcessos)
        aProcessos[nAux] := IIf(aProcessos[nAux] == NIL .or. Empty(aProcessos[nAux]), "", PadR(aProcessos[nAux], nProcessos))
    Next nAux

    // Passa os procedimentos no vetor para uma string
    If (Len(aProcedimentos) > 0)
        cProcedimentos := ""
        AEval(aProcedimentos, {|x| cProcedimentos += IIf(x == NIL .or. Empty(x), "", PadR(x, nProcedimentos))})
    EndIf

    // Carrega o vetor de roteiros
    If (!Empty(cProcedimentos))
        aRoteiros := SelecRoteiros(cProcedimentos)
    EndIf

    // Trata as vari·veis de data para ficarem no formato do banco
    cDtPagamentoDe  := StrTran(SubStr(cDtPagamentoDe,  1, 10), "-", "")
    cDtPagamentoAte := StrTran(SubStr(cDtPagamentoAte, 1, 10), "-", "")

    // Captura o intervalo de datas
    dDataDe  := SToD(cDtPagamentoDe)
    dDataAte := SToD(cDtPagamentoAte)

    // Montagem da query de busca
    cQuery += "SELECT "
    cQuery +=     "RA_FILIAL, "
    cQuery +=     "RA_SITFOLH, "
    cQuery +=     "RA_MAT, "
    cQuery +=     "RA_AFASFGT, "
    cQuery +=     "RA_RESCRAI, "
    cQuery +=     "RA_CTDEPSA, "
    cQuery +=     "RA_BCDEPSA, "
    cQuery +=     "RA_BCDPFGT, "
    cQuery +=     "RA_CTDPFGT, "
    cQuery +=     "RA_CC, "
    cQuery +=     "RA_NOME, "
    cQuery +=     "RA_PROCES, "
    cQuery +=     "RA_CIC, "
    cQuery +=     "RA_CATFUNC, "
    cQuery +=     "CTT_DESC01, "
    cQuery +=     "SRA.R_E_C_N_O_ RECNO_SRA "
    cQuery +=     "? " // 1
    cQuery += "FROM "
    cQuery +=     RetSQLName("SRA") + " SRA "
    cQuery +=     "INNER JOIN "
    cQuery +=         RetSQLName("CTT") + " CTT "
    cQuery +=         "ON "
    cQuery +=             cFilSRACTT + " "
    cQuery +=             "AND CTT_CUSTO = RA_CC "
    cQuery +=             "AND CTT.D_E_L_E_T_ = ? " // 2
    cQuery += "WHERE "
    cQuery +=     "RA_FILIAL   BETWEEN ? AND ? " // 3 e 4
    cQuery +=     "AND RA_CC   BETWEEN ? AND ? " // 5 e 6
    cQuery +=     "AND RA_MAT  BETWEEN ? AND ? " // 7 e 8
    cQuery +=     "AND RA_NOME BETWEEN ? AND ? " // 9 e 10

    // Monta o filtro da conta corrente para o funcion·rio caso a impress„o seja somente por funcion·rios
    // e o par‚metro "Qto. a Conta Corrente" n„o for ambos
    // (Caso contr·rio, o funcion·rio e o benefici·rio ser„o filtrados depois)
    If (cImprimir == "1" .and. cFunContaCorr != "3")
        cQuery += "AND RA_CTDEPSA " + IIf(cFunContaCorr == "1", "!=", "=") + " ? " // 11
    EndIf

    // Filtra pela conta e banco/agÍncia do funcion·rio caso a impress„o seja somente por funcion·rios
    // (Caso contr·rio, o funcion·rio e o benefici·rio ser„o filtrados depois)
    If (cImprimir == "1")
        cQuery += "AND RA_CTDEPSA BETWEEN ? AND ? " // 12 e 13
        cQuery += "AND RA_BCDEPSA BETWEEN ? AND ? " // 14 e 15
    EndIf

    cQuery +=     IIf(Len(aSituacoes)  > 0, " AND RA_SITFOLH IN (?) ", " ") // 16
    cQuery +=     IIf(Len(aCategorias) > 0, " AND RA_CATFUNC IN (?) ", " ") // 17
    cQuery +=     IIf(Len(aProcessos)  > 0, " AND RA_PROCES  IN (?) ", " ") // 18
    cQuery +=     "? "                                                      // 19
    cQuery +=     "AND SRA.D_E_L_E_T_ = ? " // 20
    cQuery := ChangeQuery(cQuery)

    // Instancia a classe
    oStatement := FwExecStatement():New(cQuery)

    // Captura e define os campos personalizados das tabelas SRA e CTT
    cCustomFields := GPESmartViewUtils():GetCustomFields(self:getCustomFields(), {"SRA", "CTT"})
    oStatement:SetUnsafe(nParamOrder++, IIf(!Empty(cCustomFields), "," + cCustomFields, "")) // 1

    // Define o valor dos bind parameters
    oStatement:SetString(nParamOrder++, " ")                // 2
    oStatement:SetString(nParamOrder++, cFilialDe)          // 3
    oStatement:SetString(nParamOrder++, cFilialAte)         // 4
    oStatement:SetString(nParamOrder++, cCCDe)              // 5
    oStatement:SetString(nParamOrder++, cCCAte)             // 6
    oStatement:SetString(nParamOrder++, cMatriculaDe)       // 7
    oStatement:SetString(nParamOrder++, cMatriculaAte)      // 8
    oStatement:SetString(nParamOrder++, cNomeDe)            // 9
    oStatement:SetString(nParamOrder++, cNomeAte)           // 10

    If (cImprimir == "1" .and. cFunContaCorr != "3")
        oStatement:SetString(nParamOrder++, " ")            // 11
    EndIf

    If (cImprimir == "1")
        oStatement:SetString(nParamOrder++, cContaCorrDe)   // 12
        oStatement:SetString(nParamOrder++, cContaCorrAte)  // 13
        oStatement:SetString(nParamOrder++, cBancoAgencDe)  // 14
        oStatement:SetString(nParamOrder++, cBancoAgencAte) // 15
    EndIf

    If (Len(aSituacoes) > 0)
        oStatement:SetIn(nParamOrder++, aSituacoes)         // 16
    EndIf

    If (Len(aCategorias) > 0)
        oStatement:SetIn(nParamOrder++, aCategorias)        // 17
    EndIf

    If (Len(aProcessos) > 0)
        oStatement:SetIn(nParamOrder++, aProcessos)         // 18
    EndIf

    oStatement:SetUnsafe(nParamOrder++, cFiltro)            // 19
    oStatement:SetString(nParamOrder++, " ")                // 20

    // Executa a query e retorna o alias criado
    cAlias := oStatement:OpenAlias()

    // Percorre todos os registros
    While (!(cAlias)->(EOF()))
        // Consiste controle de acessos e filiais v·lidas
        If ((cAlias)->RA_FILIAL $ cValidFil .and. Eval(cAcessaSRA))
            // Posiciona no registro do funcion·rio
            SRA->(DBGoTo((cAlias)->RECNO_SRA))

            // Reinicia o valor das vari·veis
            nValor    := 0
            aValBenef := {}

            lFuncTrf := .F.
            // Verif. se Demitido esta dentro da Data de Pagamento do Parametro
            If (cAlias)->RA_SITFOLH <> "T" // Se estiver como "T", busca os valores, se n„o, verifica se na transferÍncia foi gravado como "D"
                If ((cAlias)->RA_SITFOLH == "D")
                    DBSelectArea("SRG")
                    If (MsSeek((cAlias)->(RA_FILIAL + RA_MAT)))
                        While (!(SRG->(EOF())) .and. (cAlias)->(RA_FILIAL + RA_MAT) ==  SRG->(RG_FILIAL + RG_MAT))
                            lRescis„o := IIf(SRG->RG_DATAHOM >= dDataDe .and. SRG->RG_DATAHOM <= dDataAte, .T., .F.)

                            SRG->(DBSkip())
                        End
                    ElseIf !((cAlias)->RA_CATFUNC $ "A/P") // Se n„o for autÙnomo ou prÛ-labore
                        // Antes de ir para o prÛximo funcion·rio, verifica se n„o È transferÍncia
                        If ((cAlias)->RA_AFASFGT $ "N1/N2/N3")
                            lFuncTrf := .T.
                        ElseIf ((cAlias)->RA_RESCRAI $ "31/32")
                            lFuncTrf := .T.
                        EndIf

                        If (!lFuncTrf)
                            (cAlias)->(DBSkip())
                            LOOP
                        EndIf
                    EndIf
                EndIf
            EndIf

            // Busca os valores de lÌquido e as informaÁıes dos benefici·rios
            Gp020BuscaLiq(@nValor, @aValBenef, aRoteiros, lImprFunci, lImprBenef, dDataDe, dDataAte)

            // Ponto de Entrada para despresar funcion·rio caso retorne .F.
            // IdÍntico ao ponto de entrada GP450DES de geraÁ„o dos lÌquidos
            If (!ExistBlock("GP020DES") .or. ExecBlock("GP020DES", .F., .F.))
                // Se cImprimir == 2 (imprime apenas benefici·rios), apenas ser· testado o banco e conta do beneficario
                // Se n„o for benefici·rio, testa banco e conta do funcion·rio
                If (cImprimir == "2" .or.;
                    (cFunContaCorr == "1" .and. (cAlias)->RA_CTDEPSA == Space(Len((cAlias)->RA_CTDEPSA))) .or.;
                    (cFunContaCorr == "2" .and. (cAlias)->RA_CTDEPSA != Space(Len((cAlias)->RA_CTDEPSA))))
                    nValor := 0
                EndIf

                // aValBenef: 1-Nome 2-Banco 3-Conta 4-Verba 5-Valor 6-CPF
                If (Len(aValBenef) > 0)
                    aBenefCop := AClone(aValBenef)
                    aValBenef := {}

                    If (cImprimir == "2" .or. cImprimir == "3")
                        If (Empty(jParams["PAR_BANCOAGENCDE"][1]) .and. Empty(jParams["PAR_BANCOAGENCATE"][1]) .and. Empty(jParams["PAR_CONTACORRDE"][1]) .and. Empty(jParams["PAR_CONTACORRATE"][1])) // Com benef filtrar ambos
                            aValBenef := AClone(aBenefCop)
                        Else
                            // Como as perguntas banco e conta s„o do tipo range, para fazer o aEval no
                            // array aBenefCop, foi preciso substituir os campos da expressao (pergunte range)
                            // por X[2] ou X[3]
                            cParBanco := "X[2] >= '" + cBancoAgencDe + "' .and. X[2] <= '" + cBancoAgencAte + "'"
                            cParConta := "X[3] >= '" + cContaCorrDe  + "' .and. X[3] <= '" + cContaCorrAte  + "'"

                            If (cFunContaCorr == "1") // Benefici·rio e com conta, testo a conta
                                &('AEval(aBenefCop, {|X| IIf(  (' + cParBanco + ') .and. (' + cParConta + ' .and. !Empty(X[3])) , AAdd(aValBenef,X), "")})')
                            ElseIf (cFunContaCorr == "2") // Se for benefici·rio, sem conta
                                &('AEval(aBenefCop, {|X| IIf(  (' + cParBanco + ') .and.  (X[3] == Space(TamSX3("RQ_CTDEPBE")[1])) , AAdd(aValBenef,X), "" ) })')
                            ElseIf (cFunContaCorr == "3")
                                &('AEval(aBenefCop, {|X| IIf(  (  (' + cParBanco + ') .and. (' + cParConta + ')) .or. ( (' + cParBanco + ') .and.  (X[3] == Space(TamSX3("RQ_CTDEPBE")[1]))), AAdd(aValBenef,X), "" ) })')
                            EndIf
                        EndIf
                    EndIf
                EndIf

                // 1- Testa com conta
                // 2- Testa sem conta
                // 3- Testa se valor == 0
                // 4- Testa se benefici·rio
                If  (nValor == 0 .and. Len(aValBenef) == 0) .or. ;
                    (cImprimir == "2" .and. Len(aValBenef) == 0)
                    (cAlias)->(DBSkip())
                    LOOP
                EndIf

                // Para imprimir o funcion·rio valida o valor do funcion·rio, a flag de impress„o de funcion·rio,
                // o banco/agÍncia e conta corrente
                If (nValor > 0 .and. lImprFunci .and. ;
                Trim((cAlias)->RA_BCDEPSA) >= cBancoAgencDe .and. Trim((cAlias)->RA_BCDEPSA) <= cBancoAgencAte .and.;
                Trim((cAlias)->RA_CTDEPSA) >= cContaCorrDe  .and. Trim((cAlias)->RA_CTDEPSA) <= cContaCorrAte)
                    // Monta o JSON com as informaÁıes da linha
                    jData := {;
                        "FilialExec":  cFilExec,;
                        "EmpresaExec": cEmpExec,;
                        "RA_FILIAL":   Trim(IIf(jLGPD["RA_FILIAL"],  FwProtectedDataUtil():ValueAsteriskToAnonymize((cAlias)->RA_FILIAL),  (cAlias)->RA_FILIAL)),;
                        "RA_CC":       Trim(IIf(jLGPD["RA_CC"],      FwProtectedDataUtil():ValueAsteriskToAnonymize((cAlias)->RA_CC),      (cAlias)->RA_CC)),;
                        "CTT_DESC01":  Trim(IIf(jLGPD["CTT_DESC01"], FwProtectedDataUtil():ValueAsteriskToAnonymize((cAlias)->CTT_DESC01), (cAlias)->CTT_DESC01)),;
                        "RA_MAT":      Trim(IIf(jLGPD["RA_MAT"],     FwProtectedDataUtil():ValueAsteriskToAnonymize((cAlias)->RA_MAT),     (cAlias)->RA_MAT)),;
                        "RA_NOME":     Trim(IIf(jLGPD["RA_NOME"],    FwProtectedDataUtil():ValueAsteriskToAnonymize((cAlias)->RA_NOME),    IIf(cNomeFun == "1", (cAlias)->RA_NOME, STR0006))),;
                        "RA_CTDEPSA":  Trim(IIf(jLGPD["RA_CTDEPSA"], FwProtectedDataUtil():ValueAsteriskToAnonymize((cAlias)->RA_CTDEPSA), (cAlias)->RA_CTDEPSA)),;
                        "RA_BCDEPSA":  Trim(IIf(jLGPD["RA_BCDEPSA"], FwProtectedDataUtil():ValueAsteriskToAnonymize((cAlias)->RA_BCDEPSA), Transform((cAlias)->RA_BCDEPSA, "@R XXX/XXXXX"))),;
                        "RA_CIC":      Trim(IIf(jLGPD["RA_CIC"],     FwProtectedDataUtil():ValueAsteriskToAnonymize((cAlias)->RA_CIC),     Transform((cAlias)->RA_CIC,     "@R 999.999.999-99"))),;
                        "VALOR":       nValor,;
                        "FUNCBENEF":   STR0004;
                    } // STR0004 - "Funcion·rio" | STR0006 - "*** Nome Oculto ***"

                    // Adiciona os campos customizados no JSON
                    GPESmartViewUtils():SetCustomFields(aAllFields, jData, cAlias, aPDFields, lObfuscated)

                    // Adiciona as informaÁıes da linha
                    self:oData:appendData(jData)
                EndIf

                // Impress„o dos benefici·rios
                For nAux := 1 To Len(aValBenef)
                    If (!Empty(aValBenef[nAux][1]) .and. aValBenef[nAux][5] > 0)
                        // Monta o JSON com as informaÁıes da linha
                        jData := {;
                            "FilialExec":  cFilExec,;
                            "EmpresaExec": cEmpExec,;
                            "RA_FILIAL":   Trim(IIf(jLGPD["RA_FILIAL"],  FwProtectedDataUtil():ValueAsteriskToAnonymize((cAlias)->RA_FILIAL),  (cAlias)->RA_FILIAL)),;
                            "RA_CC":       Trim(IIf(jLGPD["RA_FILIAL"],  FwProtectedDataUtil():ValueAsteriskToAnonymize((cAlias)->RA_CC),      (cAlias)->RA_CC)),;
                            "CTT_DESC01":  Trim(IIf(jLGPD["RA_FILIAL"],  FwProtectedDataUtil():ValueAsteriskToAnonymize((cAlias)->CTT_DESC01), (cAlias)->CTT_DESC01)),;
                            "RA_MAT":      Trim(IIf(jLGPD["RA_FILIAL"],  FwProtectedDataUtil():ValueAsteriskToAnonymize((cAlias)->RA_MAT),     (cAlias)->RA_MAT)),;
                            "RA_NOME":     Trim(IIf(jLGPD["RA_FILIAL"],  FwProtectedDataUtil():ValueAsteriskToAnonymize(aValBenef[nAux][1]),   IIf(cNomeFun == "1", aValBenef[nAux][1], STR0006))),;
                            "RA_CTDEPSA":  Trim(IIf(jLGPD["RA_FILIAL"],  FwProtectedDataUtil():ValueAsteriskToAnonymize(aValBenef[nAux][3]),   aValBenef[nAux][3])),;
                            "RA_BCDEPSA":  Trim(IIf(jLGPD["RA_FILIAL"],  FwProtectedDataUtil():ValueAsteriskToAnonymize(aValBenef[nAux][2]),   Transform(aValBenef[nAux][2], "@R XXX/XXXXX"))),;
                            "RA_CIC":      Trim(IIf(jLGPD["RA_FILIAL"],  FwProtectedDataUtil():ValueAsteriskToAnonymize(aValBenef[nAux][6]),   Transform(aValBenef[nAux][6], "@R 999.999.999-99"))),;
                            "VALOR":       aValBenef[nAux][5],;
                            "FUNCBENEF":   STR0005;
                        } // STR0005 - "Benefici·rio" | STR0006 - "*** Nome Oculto ***"

                        // Adiciona os campos customizados no JSON
                        GPESmartViewUtils():SetCustomFields(aAllFields, jData, cAlias, aPDFields, lObfuscated)

                        // Adiciona as informaÁıes da linha
                        self:oData:appendData(jData)
                    EndIf
                Next nAux
            EndIf
        EndIf

        // Pula para o prÛximo registro
        (cAlias)->(DBSkip())
    End

    // Fecha a ·rea da tabela tempor·ria
    (cAlias)->(DBCloseArea())

    // Limpa os objetos da memÛria
    jData := NIL
    FwFreeObj(jData)
    FwFreeObj(JParams)
    FwFreeObj(jLGPD)
    FwFreeObj(oStatement)
    FwFreeArray(aRoteiros)
    FwFreeArray(aValBenef)
    FwFreeArray(aBenefCop)
    FwFreeArray(aProcedimentos)
    FwFreeArray(aCategorias)
    FwFreeArray(aSituacoes)
    FwFreeArray(aProcessos)
    FwFreeArray(aAllFields)
    FwFreeArray(aPDFields)
Return self:oData

/*/{Protheus.doc} GPER020TReportsBusinessObject:getSchema()
    Define o schema do objeto de negÛcio.
    @type Method
    @version 12.1.2310
    @author arthur.sales
    @since 08/11/2023
    @return Object, Schema do objeto de negÛcio
/*/
Method getSchema() As Object Class GPER020TReportsBusinessObject
    // Define os par‚metros do relatÛrio
    self:oSchema:addParameter("PAR_PROCEDIMENTOS",  STR0007,        "string", .T.)
    self:oSchema:addParameter("PAR_FUNCONTACORR",   STR0008,        "string", .F.)
    self:oSchema:addParameter("PAR_DTPAGAMENTODE",  STR0009,        "date",   .F.)
    self:oSchema:addParameter("PAR_DTPAGAMENTOATE", STR0010,        "date",   .F.)
    self:oSchema:addParameter("PAR_FILIALDE",       STR0011,        "string", .F.)
    self:oSchema:addParameter("PAR_FILIALATE",      STR0012,        "string", .F.)
    self:oSchema:addParameter("PAR_CENTROCUSTODE",  STR0013,        "string", .F.)
    self:oSchema:addParameter("PAR_CENTROCUSTOATE", STR0014,        "string", .F.)
    self:oSchema:addParameter("PAR_MATRICULADE",    STR0015,        "string", .F.)
    self:oSchema:addParameter("PAR_MATRICULAATE",   STR0016,        "string", .F.)
    self:oSchema:addParameter("PAR_NOMEDE",         STR0017,        "string", .F.)
    self:oSchema:addParameter("PAR_NOMEATE",        STR0018,        "string", .F.)
    self:oSchema:addParameter("PAR_CONTACORRDE",    STR0019,        "string", .F.)
    self:oSchema:addParameter("PAR_CONTACORRATE",   STR0020,        "string", .F.)
    self:oSchema:addParameter("PAR_BANCOAGENCDE",   STR0021,        "string", .F.)
    self:oSchema:addParameter("PAR_BANCOAGENCATE",  STR0022,        "string", .F.)
    self:oSchema:addParameter("PAR_SITUACOES",      STR0023,        "string", .T.)
    self:oSchema:addParameter("PAR_CATEGORIAS",     STR0024,        "string", .T.)
    self:oSchema:addParameter("PAR_NOMEFUN",        STR0025,        "string", .F.)
    self:oSchema:addParameter("PAR_IMPRIMIR",       STR0026,        "string", .F.)
    self:oSchema:addParameter("PAR_PROCESSOS",      STR0027,        "string", .T.)
    self:oSchema:addParameter("PAR_TOTAG",          STR0028,        "string", .F.)
    self:oSchema:addParameter("PAR_TOTBANCO",       STR0029,        "string", .F.)
    self:oSchema:addParameter("PAR_QUEBRA",         STR0030,        "string", .F.)
    self:oSchema:addParameter("PAR_TIPO",           STR0031,        "string", .F.)

    // Define endpoints dos par‚metros de tipo lookup/combobox
    self:setCustomURL("PAR_PROCEDIMENTOS",  "/api/framework/v1/genericLookupService/smartview/SRY",  2)
    self:setCustomURL("PAR_FILIALDE",       "/api/rh/smartview/v1/options/GPEParams/getBranches",    2)
    self:setCustomURL("PAR_FILIALATE",      "/api/rh/smartview/v1/options/GPEParams/getBranches",    2)
    self:setCustomURL("PAR_MATRICULADE",    "/api/framework/v1/genericLookupService/smartview/SRA",  2)
    self:setCustomURL("PAR_MATRICULAATE",   "/api/framework/v1/genericLookupService/smartview/SRA",  2)
    self:setCustomURL("PAR_CENTROCUSTODE",  "/api/framework/v1/genericLookupService/smartview/CTT",  2)
    self:setCustomURL("PAR_CENTROCUSTOATE", "/api/framework/v1/genericLookupService/smartview/CTT",  2)
    self:setCustomURL("PAR_BANCOAGENCDE",   "/api/rh/smartview/v1/options/GPER020/getBankAgency",    2)
    self:setCustomURL("PAR_BANCOAGENCATE",  "/api/rh/smartview/v1/options/GPER020/getBankAgency",    2)
    self:setCustomURL("PAR_CATEGORIAS",     "/api/rh/smartview/v1/options/GPEParams/getSX5/28",      2)
    self:setCustomURL("PAR_SITUACOES",      "/api/rh/smartview/v1/options/GPEParams/getSX5/31",      2)
    self:setCustomURL("PAR_PROCESSOS",      "/api/framework/v1/genericLookupService/smartview/RCJ",  2)
    self:setCustomURL("PAR_FUNCONTACORR",   "/api/rh/smartview/v1/options/GPER020/PAR_FUNCONTACORR", 1)
    self:setCustomURL("PAR_NOMEFUN",        "/api/rh/smartview/v1/options/GPER020/PAR_NOMEFUN",      1)
    self:setCustomURL("PAR_IMPRIMIR",       "/api/rh/smartview/v1/options/GPER020/PAR_IMPRIMIR",     1)
    self:setCustomURL("PAR_TOTAG",          "/api/rh/smartview/v1/options/GPER020/PAR_TOTAG",        1)
    self:setCustomURL("PAR_TOTBANCO",       "/api/rh/smartview/v1/options/GPER020/PAR_TOTBANCO",     1)
    self:setCustomURL("PAR_QUEBRA",         "/api/rh/smartview/v1/options/GPER020/PAR_QUEBRA",       1)
    self:setCustomURL("PAR_TIPO",           "/api/rh/smartview/v1/options/GPER020/PAR_TIPO",         1)

    // Adiciona as propriedades do objeto de negÛcio
    self:oSchema:addProperty("FilialExec",  "Filial de ExecuÁ„o",  "string",  STR0032,     "FilialExec",  NIL, NIL, NIL, .F.)
    self:oSchema:addProperty("EmpresaExec", "Empresa de ExecuÁ„o", "string",  STR0033,     "EmpresaExec", NIL, NIL, NIL, .F.)
    self:oSchema:addProperty("RA_FILIAL",   "RA_FILIAL",           "string",  STR0034,     "RA_FILIAL",   NIL, NIL, NIL, .T.)
    self:oSchema:addProperty("RA_CC",       "RA_CC",               "string",  STR0035,     "RA_CC",       NIL, NIL, NIL, .T.)
    self:oSchema:addProperty("CTT_DESC01",  "CTT_DESC01",          "string",  STR0036,     "CTT_DESC01",  NIL, NIL, NIL, .T.)
    self:oSchema:addProperty("RA_MAT",      "RA_MAT",              "string",  STR0037,     "RA_MAT",      NIL, NIL, NIL, .T.)
    self:oSchema:addProperty("RA_NOME",     "RA_NOME",             "string",  STR0038,     "RA_NOME",     NIL, NIL, NIL, .T.)
    self:oSchema:addProperty("RA_CTDEPSA",  "RA_CTDEPSA",          "string",  STR0039,     "RA_CTDEPSA",  NIL, NIL, NIL, .T.)
    self:oSchema:addProperty("RA_BCDEPSA",  "RA_BCDEPSA",          "string",  STR0040,     "RA_BCDEPSA",  NIL, NIL, NIL, .T.)
    self:oSchema:addProperty("RA_CIC",      "RA_CIC",              "string",  STR0041,     "RA_CIC",      NIL, NIL, NIL, .T.)
    self:oSchema:addProperty("VALOR",       "VALOR",               "number",  STR0042,     "VALOR",       NIL, NIL, NIL, .F.)
    self:oSchema:addProperty("FUNCBENEF",   "FUNCBENEF",           "string",  STR0043,     "FUNCBENEF",   NIL, NIL, NIL, .F.)
Return self:oSchema

/*/
    ‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹
    ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
    ±±⁄ƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒø±±
    ±±≥Funcao    ≥ SelecRoteiros ≥ Autor ≥ Tatiane Matias       ≥ Data ≥ 23/03/05 ≥±±
    ±±√ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒ¥±±
    ±±≥Descricao ≥ Carregar no array aRoteiros os roteiros selecionados em        ≥±±
    ±±≥          ≥ mv_par01, mv_par02 e mv_par03.                                 ≥±±
    ±±¿ƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒŸ±±
    ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
    ﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂ
/*/
Static Function SelecRoteiros(cVarRot As Character) As Array
    // DeclaraÁ„o das vari·veis locais
    Local nPos      As Numeric
    Local nPrior    As Numeric
    Local cAuxRot   As Character
    Local cAddVerba As Character
    Local cTipoCalc As Character
    Local cFilSRY   As Character
    Local aRoteiros As Array

    // InicializaÁ„o das vari·veis
    nPos      := 1
    nPrior    := 0
    cAuxRot   := ""
    cAddVerba := ""
    cTipoCalc := ""
    cFilSRY   := FwXFilial("SRY")
    aRoteiros := {}

    DBSelectArea("SRY")
    // Incluir cada roteiro selecionado com o tipo de roteiro e a verba
    While (nPos <= Len(cVarRot))
        cAuxRot := SubStr(cVarRot, nPos, 3)
        If (MsSeek(cFilSRY + cAuxRot))
            cTipoCalc := SRY->RY_TIPO

            If (AScan(aRoteiros, {|x| x[1] == cAuxRot}) == 0)
                Do Case
                    Case (cTipoCalc $ "1/9/7")                    // Folha de Pagto
                        cAddVerba := fGetCodFol("0047", .T.)
                        nPrior    := 8
                    Case (cTipoCalc == "2")                       // Adiantamento
                        cAddVerba := fGetCodFol("0546", .T.)
                        nPrior    := 1
                    Case (cTipoCalc == "3")                       // FÈrias
                        cAddVerba := fGetCodFol("0102", .T.)
                        nPrior    := 2
                    Case (cTipoCalc == "4")                       // Rescis„o
                        cAddVerba := fGetCodFol("0126", .T.)
                        nPrior    := 3
                    Case (cTipoCalc == "5")                       // 1a parcela 13o sal·rio
                        cAddVerba := fGetCodFol("0678", .T.)
                        nPrior    := 4
                    Case (cTipoCalc == "6" .or. cTipoCalc == "5") // 2a parcela 13o sal·rio
                        cAddVerba := fGetCodFol("0021", .T.)
                        nPrior    := 5
                    // Case (cTipoCalc == "A")                       // AplicaÁ„o de rescis„o - Mex
                    //    cAddVerba := fGetCodFol("0126", .T.)
                    //    nPrior    := 9
                    Case (cTipoCalc == "F")                       // PLR
                        cAddVerba := fGetCodFol("0836", .T.)
                        nPrior    := 6
                    Case (cTipoCalc == "K")                       // Valores extras
                        cAddVerba := fGetCodFol("1411", .T.)
                        nPrior    := 7
                    Case (cTipoCalc $ "L/M")                      // FÈrias servidores; FÈrias indenizadas (GFP)
                        cAddVerba := fGetCodFol("0047", .T.)
                        nPrior    := 2
                EndCase

                AAdd(aRoteiros, {cAuxRot, cTipoCalc, cAddVerba, nPrior})
            EndIf

        // Valores extras
        ElseIf (cAuxRot == "EXT" .and. (AScan(aRoteiros, {|x| x[1] == cAuxRot}) == 0))
            AAdd(aRoteiros, {cAuxRot, "E", "", 7})
        EndIf

        nPos += 3
    End

    If (!Empty(aRoteiros))
        ASort(aRoteiros, NIL, NIL, {|x, y| x[4] < y[4]})
    EndIf
Return aRoteiros

/*
    ‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹‹
    ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
    ±±⁄ƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒø±±
    ±±≥Funcao    ≥ Gp020BuscaLiq ≥ Autor ≥ Tatiane Matias       ≥ Data ≥ 23/03/05 ≥±±
    ±±√ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒ¥±±
    ±±≥Descricao ≥ Busca os valores de lÌquido e benefÌcios                       ≥±±
    ±±√ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¥±±
    ±±≥Sintaxe   ≥ Gp020BuscaLiq(nValLiq,aValBenef)                               ≥±±
    ±±√ƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¥±±
    ±±≥Parametros≥ nValLiq     - Valor do lÌquido a receber                       ≥±±
    ±±≥          ≥ aValBenef   - 1-Nome/2-Banco/3-Conta/4-Verba/5-Valor Benef     ≥±±
    ±±¿ƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒŸ±±
    ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
    ﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂ
*/
Static Function Gp020BuscaLiq(nValLiq, aValBenef, aRoteiros, lImprFunci, lImprBenef, dDataDe, dDataAte)
    // DeclaraÁ„o das vari·veis locais
    Local aAreaSRA     As Array
    Local aChaveBusca  As Array
    Local aCodBenef    As Array
    Local aCodBenefAux As Array
    Local cCodPdBenef  As Array
    Local aPensPd      As Array
    Local cAcessaSRC   As Character
    Local cAcessaSRD   As Character
    Local cAcessaSRG   As Character
    Local cAcessaSRH   As Character
    Local cAcessaSRR   As Character
    Local cDataPg      As Character
    Local cFilFun      As Character
    Local cMatFun      As Character
    Local cNumPag      As Character
    Local cRoteiro     As Character
    Local cVerba       As Character
    Local cVerbaBusca  As Character
    Local cVerbaDis    As Character
    Local cCodVerba    As Character
    Local lRatItm      As Logical
    Local nBenef       As Numeric
    Local nCntP        As Numeric
    Local nCntP2       As Numeric
    Local nPosBenef    As Numeric
    Local nRoteiro     As Numeric
    Local nValBenef    As Numeric
    Local nValVrb      As Numeric
    Local nx           As Numeric
    Local nBusca       As Numeric
    Local dDtBusFer    As Date

    // DeclaraÁ„o das vari·veis privadas
    Private nLiqAux  As Numeric   // Vari·vel para acumular outros valores de lÌquidos para utilizaÁ„o no ponto de entrada
    Private cTipoRot As Character // Tipo de roteiro

    // InicializaÁ„o das vari·veis
    aAreaSRA     := SRA->(FwGetArea())
    aChaveBusca  := {}
    aCodBenef    := {}
    aCodBenefAux := {}
    cCodPdBenef  := {}
    aPensPd      := {} // {cRoteiro, PERIODO, SEMANA, ORIGEM, DATAPAG, DTREF, PD}
    cAcessaSRC   := &(" {|| " + ChkRH("GPER020" , "SRC" , "2") + "} ")
    cAcessaSRD   := &(" {|| " + ChkRH("GPER020" , "SRD" , "2") + "} ")
    cAcessaSRG   := &(" {|| " + ChkRH("GPER020" , "SRG" , "2") + "} ")
    cAcessaSRH   := &(" {|| " + ChkRH("GPER020" , "SRH" , "2") + "} ")
    cAcessaSRR   := &(" {|| " + ChkRH("GPER020" , "SRR" , "2") + "} ")
    cDataPg      := ""
    cFilFun      := SRA->RA_FILIAL
    cMatFun      := SRA->RA_MAT
    cNumPag      := ""
    cRoteiro     := ""
    cTipoRot     := ""
    cVerba       := ""
    cVerbaBusca  := ""
    cVerbaDis    := ""
    cCodVerba    := ""
    lRatItm      := SuperGetMV("MV_RATITM", .F., .F.)
    nBenef       := 0
    nCntP        := 0
    nCntP2       := 0
    nLiqAux      := 0
    nPosBenef    := 0
    nRoteiro     := 0
    nValBenef    := 0
    nValVrb      := 0
    nx           := 0
    nBusca       := 0
    dDtBusFer    := CToD("")

    // Ponto de Entrada para alterar as vari·veis de lÌquido. Ex. lAdianta
    // Impress„o/GeraÁ„o de lÌquidos : A partir da 7.10, a rotina passou a
    // listar valor lÌquido da rescis„o contratual dos funcion·rios demitidos
    // de acordo com  as faixas de datas de pagamento selecionadas.
    // No entanto, algumas empresas lanÁam o Id47 (Liq. a receber) no SRC e
    // neste caso, n„o deveria pegar o Liq.Rescis„o, duplicando o Vlr. Liq. ge-
    // rado no Relat./Gerac„o Liq.
    If (ExistBlock("GPCHKLIQ"))
        ExecBlock("GPCHKLIQ", .F., .F.)
        nValLiq += nLiqAux
    EndIf

    For nRoteiro := 1 To Len(aRoteiros)
        cRoteiro    := aRoteiros[nRoteiro, 1]
        cTipoRot    := aRoteiros[nRoteiro, 2]
        cVerbaBusca := IIf(Empty(cVerba), aRoteiros[nRoteiro, 3], cVerba)

        // Busca lÌquido e benefÌcios das fÈrias
        If (cTipoRot == "3")
            DBSelectArea("SRH")
            SRH->(DBSetOrder(3))
            If (lImprFunci) // Busca lÌquido
                If (MsSeek(cFilFun + cMatFun + cRoteiro) .and. Eval(cAcessaSRH))
                    While (!EOF() .and. AllTrim(cFilFun + cMatFun + cRoteiro) == AllTrim(SRH->RH_FILIAL + SRH->RH_MAT + SRH->RH_ROTEIR))
                        If (SRH->RH_DTRECIB >= dDataDe .and. SRH->RH_DTRECIB <= dDataAte)
                            dDtBusFer := SRH->RH_DATAINI
                            DBSelectArea("SRR")
                            DBSetOrder(3)
                            If (MsSeek(cFilFun + cMatFun + "F" + DToS(dDtBusFer) + cVerbaBusca + cRoteiro))
                                nValLiq += SRR->RR_VALOR
                                nValVrb += IIf(!Empty(cVerba), SRR->RR_VALOR, 0)
                            EndIf
                        EndIf

                        DBSelectArea("SRH")
                        SRH->(DBSkip())
                    End
                EndIf
            EndIf

            If (lImprBenef) // Busca benefÌcios
                aRot:= {"131", "132", "FER"}
                For nx:= 1 to Len (aRot)
                    cRoteiro:= aRot[nx]
                    fBusCadBenef(@aCodBenefAux, cRoteiro,,.T., cFilFun, cMatFun)
                    AEval(aCodBenefAux, {|x| IIf(!Empty(x), AAdd(aCodBenef, x), "")})
                Next

                If (MsSeek(cFilFun + cMatFun + cRoteiro) .and. Eval(cAcessaSRH))
                    While (!EOF() .and. AllTrim(cFilFun + cMatFun + cRoteiro) == AllTrim(SRH->RH_FILIAL + SRH->RH_MAT + SRH->RH_ROTEIR))
                        If (SRH->RH_DTRECIB >= dDataDe .and. SRH->RH_DTRECIB <= dDataAte)
                            dDtBusFer := SRH->RH_DATAINI
                            DBSelectArea("SRR")
                            DBSetOrder(3)
                            For nCntP := 1 To Len(aCodBenef)
                                If (MsSeek(cFilFun + cMatFun + "F" + DToS(dDtBusFer) + aCodBenef[nCntP,1] + cRoteiro))
                                    nPosBenef := Ascan(aValBenef, {|x| x[2] + x[3] + x[6] + x[4] == aCodBenef[nCntP,10] + aCodBenef[nCntP,11] + aCodBenef[nCntP,12] + aCodBenef[nCntP,01]})
                                    If (nPosBenef == 0)
                                        AAdd(aValBenef, {aCodBenef[nCntP,09],  aCodBenef[nCntP,10], aCodBenef[nCntP,11], SRR->RR_PD, SRR->RR_VALOR,aCodBenef[nCntP,12],aCodBenef[nCntP,19],"SRQ", If(Len(aCodBenef[nCntP]) >= 22, aCodBenef[nCntP,22], ""),aCodBenef[nCntP,23],aCodBenef[nCntP,24]})
                                    Else
                                        aValBenef[nPosBenef,5] += SRR->RR_VALOR
                                    EndIf

                                    If (Empty(aPensPd) .or. AScan(aPensPd, {|x| x[1] == cRoteiro .and. x[2] == SRR->RR_PERIODO .and. x[3] == SRR->RR_SEMANA .and. x[4] == SRR->RR_TIPO3 .and. x[5] == SRR->RR_DATAPAG .and. x[6] == SRR->RR_DTREF .and. x[7] == SRR->RR_PD}) == 0)
                                        AAdd(aPensPd, {cRoteiro, SRR->RR_PERIODO, SRR->RR_SEMANA, SRR->RR_TIPO3, SRR->RR_DATAPAG, SRR->RR_DTREF, SRR->RR_PD})
                                    EndIf
                                EndIf
                            Next nCntP
                        EndIf

                        DBSelectArea("SRH")
                        SRH->(DBSkip())
                    End
                EndIf
            EndIf
        ElseIf (cTipoRot $ "4*A") // Busca lÌquido e benefÌcios da rescis„o
            // Verifica todos os registros do funcionario na SRG
            DBSelectArea("SRG")
            DBSetOrder(2)
            If (MsSeek(cFilFun + cMatFun + cRoteiro) .and. Eval(cAcessaSRG))
                aChaveBusca := {}
                While (!EOF() .and. (AllTrim(cFilFun + cMatFun + cRoteiro)) == (AllTrim(SRG->RG_FILIAL + SRG->RG_MAT + SRG->RG_ROTEIR)))
                    If (SRG->RG_DATAHOM >= dDataDe .and. SRG->RG_DATAHOM <= dDataAte .and. SRG->RG_EFETIVA == "S") // Rescis„o efetivada como "S"
                        AAdd(aChaveBusca, SRG->RG_FILIAL + SRG->RG_MAT + "R" + DToS(SRG->RG_DTGERAR))
                    EndIf

                    DBSkip()
                End

                // Verifica qual registro deve buscar na SRR
                nBusca := Len(aChaveBusca)
                If (nBusca > 0)
                    For nX := 1 To nBusca
                        // Busca lÌquido
                        If (lImprFunci)
                            DBSelectArea("SRR")
                            SRR->(DBSetOrder(RetOrdem("SRR", "SRR->RR_FILIAL + SRR->RR_MAT + SRR->RR_TIPO3 + DToS(SRR->RR_DATA) + SRR->RR_PD")))
                            SRR->(DBGoTop())

                            If (MsSeek(aChaveBusca[nX] + cVerbaBusca) .and. Eval(cAcessaSRR))
                                While (SRR->(!EOF()) .and. SRR->RR_FILIAL + SRR->RR_MAT + SRR->RR_TIPO3 + DToS(SRR->RR_DATA) + SRR->RR_PD == aChaveBusca[nX] + cVerbaBusca)
                                    // Armazena o valor encontrado na SRR
                                    nValLiq += SRR->RR_VALOR

                                    SRR->(DBSkip())
                                End
                            EndIf
                        EndIf

                        // Busca os benefÌcios definidos no cadastro benefici·rios
                        nValBenef := 0
                        If lImprBenef // Busca benefÌcios
                            fBusCadBenef(@aCodBenef, cRoteiro,,.T., cFilFun, cMatFun)
                            For nCntP := 1 To Len(aCodBenef)
                                cCodPdBenef := aCodBenef[nCntP, 16 ] // Todas as verbas dos benefici·rios
                                // Busca todas a verbas de pensao da rescisao
                                For nCntP2:= 1 To Len(cCodPdBenef) Step 6

                                    cCodVerba   := substr(cCodPdBenef,nCntP2+3,3)
                                    DBSelectArea("SRR")

                                    If (MsSeek(aChaveBusca[nX] + cCodVerba) .and. Eval(cAcessaSRR))
                                        While (!EOF() .and. SRR->RR_FILIAL+SRR->RR_MAT+SRR->RR_TIPO3+DToS(SRR->RR_DATA)+SRR->RR_PD == aChaveBusca[nX] + cCodVerba .and. Eval(cAcessaSRR))
                                            nValBenef   += SRR->RR_VALOR

                                            If (Empty(aPensPd) .or. AScan(aPensPd, {|x| x[1] == cRoteiro .and. x[2] == SRR->RR_PERIODO .and. x[3] == SRR->RR_SEMANA .and. x[4] == SRR->RR_TIPO3 .and. x[5] == SRR->RR_DATAPAG .and. x[6] == SRR->RR_DTREF .and. x[7] == SRR->RR_PD}) == 0)
                                                AAdd(aPensPd, {cRoteiro, SRR->RR_PERIODO, SRR->RR_SEMANA, SRR->RR_TIPO3, SRR->RR_DATAPAG, SRR->RR_DTREF, SRR->RR_PD})
                                            EndIf

                                            DBSkip()
                                        End
                                    EndIf
                                Next nPd

                                nPosBenef := AScan(aValBenef, {|x| x[2] + x[3] + x[4] == aCodBenef[nCntP,10] + aCodBenef[nCntP,11] + aCodBenef[nCntP,01]})
                                If (nPosBenef == 0)
                                    AAdd(aValBenef, {aCodBenef[nCntP,09], aCodBenef[nCntP,10], aCodBenef[nCntP,11], SRR->RR_PD, nValBenef, aCodBenef[nCntP,12], aCodBenef[nCntP,19],"SRQ",If(Len(aCodBenef[nCntP]) >= 22, aCodBenef[nCntP,22], ""), aCodBenef[nCntP,23], aCodBenef[nCntP,24]})
                                Else
                                    aValBenef[nPosBenef,5] += nValBenef
                                EndIf

                                nValBenef := 0
                            Next nCntP

                            DBSelectArea("SRG")
                        EndIf
                    Next nX
                EndIf
            EndIf
        Else
            // Movimento aberto
            DBSelectArea("SRC")
            DBSetOrder(8)
            If (lImprFunci) // Busca lÌquido
                If (SRC->(MsSeek(cFilFun + cMatFun + cVerbaBusca + cRoteiro)) .and. Eval(cAcessaSRC))
                    While (!EOF() .and. (AllTrim(cFilFun + cMatFun + cVerbaBusca + cRoteiro) == AllTrim(SRC->RC_FILIAL + SRC->RC_MAT + SRC->RC_PD + SRC->RC_ROTEIR)))
                        If (SRC->RC_DATA >= dDataDe .and. SRC->RC_DATA <= dDataAte) .and. IIf(!Empty(cNumPag), SRC->RC_SEMANA == cNumPag, .T.)
                            nValLiq += SRC->RC_VALOR
                            nValVrb += IIf(!Empty(cVerba), SRC->RC_VALOR, 0)
                        EndIf

                        DBSkip()
                    End
                EndIf
            EndIf

            If (lImprBenef) // Busca benefÌcios
                fBusCadBenef(@aCodBenef, cRoteiro,,.T., cFilFun, cMatFun)
                If (cTipoRot $ "1/2/5/6/9/F")  // FOL/ADI/131/132/PLR (Roteiros que tÍm pens„o)
                    For nCntP := 1 To Len(aCodBenef)
                        For nCntP2 := 1 To 4
                            nPosVb := IIf(nCntP2 == 1, 1, IIf(nCntP2 == 2, 8, If(nCntP2 == 4, 13, 7))) // 1-Pensao Folha 2-Pensao PLR  3-Pensao DIf.13sal. 4-DIf. Pensao Fer.
                            If (MsSeek(cFilFun + cMatFun + aCodBenef[nCntP,nPosVb] + cRoteiro) .and. Eval(cAcessaSRC))
                                While (!EOF() .and. (AllTrim(cFilFun + cMatFun + aCodBenef[nCntP,nPosVb] + cRoteiro) == ;
                                    AllTrim(SRC->RC_FILIAL + SRC->RC_MAT + SRC->RC_PD + SRC->RC_ROTEIR)))

                                    cVerbaDis := PosSrv(aCodBenef[nCntP,nPosVb], FwXFilial("SRV"), "RV_CODCOM_")

                                    If (SRC->RC_DATA >= dDataDe .and. SRC->RC_DATA <= dDataAte) .and. PosSrv(SRC->RC_PD,SRC->RC_FILIAL,"RV_TIPOCOD") == "2"
                                        If (Empty(aPensPd) .or. SRC->RC_TIPO2 # "G" .or. AScan(aPensPd, {|x| x[2] == SRC->RC_PERIODO .and. x[3] == SRC->RC_SEMANA .and. x[5] == SRC->RC_DATA .and. x[7] == SRC->RC_PD}) == 0)
                                            nPosBenef := AScan(aValBenef, {|x| x[2] + x[3] + x[6] + x[4] == aCodBenef[nCntP,10] + aCodBenef[nCntP,11] + aCodBenef[nCntP,12] + aCodBenef[nCntP,01]})
                                            If (nPosBenef == 0)
                                                AAdd(aValBenef, {aCodBenef[nCntP,09],  aCodBenef[nCntP,10], aCodBenef[nCntP,11], SRC->RC_PD, SRC->RC_VALOR,aCodBenef[nCntP,12],aCodBenef[nCntP,19],"SRQ", IIf(Len(aCodBenef[nCntP]) >= 22, aCodBenef[nCntP,22], ""),aCodBenef[nCntP,23],aCodBenef[nCntP,24] })
                                            Else
                                                aValBenef[nPosBenef,5] += SRC->RC_VALOR
                                            EndIf
                                        EndIf
                                    EndIf

                                    DBSkip()
                                End
                            EndIf
                        Next nCntP2
                    Next nCntP

                    If (Len(aValBenef) > 0)
                        If (MsSeek(cFilFun + cMatFun + cVerbaDis + cRoteiro) .and. Eval(cAcessaSRC))
                            If ((SRC->RC_DATA >= dDataDe .and. SRC->RC_DATA <= dDataAte) .and.;
                                    PosSrv(SRC->RC_PD,SRC->RC_FILIAL,"RV_TIPOCOD") == "2")
                                nBenef := AScan(aValBenef, {|x| PosSrv(x[4], cFilFun, "RV_CODCOM_") == cVerbaDis})
                                If (nBenef > 0)
                                    AAdd(aValBenef, {aValBenef[nBenef,01], aValBenef[nBenef,02], aValBenef[nBenef,03], SRC->RC_PD, SRC->RC_VALOR, aValBenef[nBenef,06], "", "SRC","",aValBenef[1][10],aValBenef[1][11], "",""})
                                EndIf
                            EndIf
                        EndIf
                    EndIf
                Else
                    For nCntP := 1 To Len(aCodBenef)
                        If (MsSeek(cFilFun + cMatFun + aCodBenef[nCntP,1] + cRoteiro) .and. Eval(cAcessaSRC))
                            While (!EOF() .and. (AllTrim(cFilFun + cMatFun + aCodBenef[nCntP,1] + cRoteiro) == ;
                                AllTrim(SRC->RC_FILIAL + SRC->RC_MAT + SRC->RC_PD + SRC->RC_ROTEIR)))
                                If ((SRC->RC_DATA >= dDataDe .and. SRC->RC_DATA <= dDataAte) .and.;
                                    PosSrv(SRC->RC_PD,SRC->RC_FILIAL,"RV_TIPOCOD") == "2")

                                    If (Empty(aPensPd) .or. SRC->RC_TIPO2 # "G" .or. AScan(aPensPd, {|x| x[2] == SRC->RC_PERIODO .and. x[3] == SRC->RC_SEMANA .and. x[5] == SRC->RC_DATA .and. x[7] == SRC->RC_PD}) == 0)
                                        nPosBenef := AScan(aValBenef, {|x| x[2] + x[3] + x[6] + x[4] == aCodBenef[nCntP,10] + aCodBenef[nCntP,11] + aCodBenef[nCntp,12] + aCodBenef[nCntp,01]})
                                        If nPosBenef == 0
                                            AAdd(aValBenef, {aCodBenef[nCntP,09],  aCodBenef[nCntP,10], aCodBenef[nCntP,11], SRC->RC_PD, SRC->RC_VALOR,aCodBenef[nCntP,12],aCodBenef[nCntP,19],"SRQ", If(Len(aCodBenef[nCntP]) >= 22, aCodBenef[nCntP,22], "")})
                                        Else
                                            aValBenef[nPosBenef,5] += SRC->RC_VALOR
                                        EndIf
                                    EndIf
                                EndIf
                                DBSkip()
                            End
                        EndIf
                    Next nCntP
                EndIf
            EndIf

            // Movimento fechado
            DBSelectArea("SRD")
            DBSetOrder(6)
            If (lImprFunci) // Busca lÌquido
                If (MsSeek(cFilFun + cMatFun + cVerbaBusca + cRoteiro) .and. Eval(cAcessaSRD))
                    While (!EOF() .and. (AllTrim(cFilFun + cMatFun + cVerbaBusca + cRoteiro) == AllTrim(SRD->RD_FILIAL + SRD->RD_MAT + SRD->RD_PD + SRD->RD_ROTEIR)))
                        If (SRD->RD_DATPGT >= dDataDe .and. SRD->RD_DATPGT <= dDataAte) .and. IIf(!Empty(cNumPag), SRD->RD_SEMANA == cNumPag, .T.)
                            nValLiq += SRD->RD_VALOR
                            nValVrb += IIf(!Empty(cVerba), SRD->RD_VALOR, 0)
                        EndIf
                        DBSkip()
                    End
                EndIf
            EndIf

            If (lImprBenef) // Busca benefÌcios
                fBusCadBenef(@aCodBenef, cRoteiro,,.T., cFilFun, cMatFun)
                For nCntP := 1 To Len(aCodBenef)
                    For nCntP2 := 1 To 4
                        nPosVb := IIf(nCntP2 == 1, 1, IIf(nCntP2 == 2, 8, IIf(nCntP2 == 4, 13, 7))) // 1-Pensao Folha 2-Pensao PLR  3-Pensao DIf.13sal. 4-DIf. Pensao Fer.
                        DBSelectArea("SRD")
                        DBSetOrder(6)
                        If (MsSeek(cFilFun + cMatFun + aCodBenef[nCntP,nPosVb] + cRoteiro) .and. Eval(cAcessaSRD))
                            While (!EOF() .and. (AllTrim(cFilFun + cMatFun + aCodBenef[nCntP,nPosVb] + cRoteiro) == ;
                                AllTrim(SRD->RD_FILIAL + SRD->RD_MAT + SRD->RD_PD + SRD->RD_ROTEIR)))
                                cVerbaDis := PosSrv(aCodBenef[nCntP,nPosVb], FwXFilial("SRV"), "RV_CODCOM_")

                                If ((SRD->RD_DATPGT >= dDataDe .and. SRD->RD_DATPGT <= dDataAte) .and.;
                                    PosSrv(SRD->RD_PD,SRD->RD_FILIAL,"RV_TIPOCOD") == "2")
                                    cDataPg := DToS(SRD->RD_DATPGT)

                                    If (Empty(aPensPd) .or. SRD->RD_TIPO2 # "G" .or. AScan(aPensPd, {|x| x[2] == SRD->RD_PERIODO .and. x[3] == SRD->RD_SEMANA .and. x[5] == SRD->RD_DATPGT .and. x[7] == SRD->RD_PD}) == 0)
                                        nPosBenef := AScan(aValBenef, {|x| x[2] + x[3] + x[6] + x[4] == aCodBenef[nCntP,10] + aCodBenef[nCntP,11] + aCodBenef[nCntp,12] + aCodBenef[nCntp,01]})
                                        If (nPosBenef == 0)
                                            AAdd(aValBenef, {aCodBenef[nCntP,09],  aCodBenef[nCntP,10], aCodBenef[nCntP,11], SRD->RD_PD, SRD->RD_VALOR,aCodBenef[nCntP,12],aCodBenef[nCntP,19],"SRQ", If(Len(aCodBenef[nCntP]) >= 22, aCodBenef[nCntP,22], ""),aCodBenef[nCntP,23],aCodBenef[nCntP,24]})
                                        Else
                                            aValBenef[nPosBenef,5] += SRD->RD_VALOR
                                        EndIf
                                    EndIf
                                EndIf
                                DBSkip()
                            End
                        EndIf
                    Next nCntP2
                Next nCntP

                If (Len(aValBenef) > 0)
                    If (MsSeek(cFilFun + cMatFun + cVerbaDis + cRoteiro + cDataPg) .and. Eval(cAcessaSRD))
                        If ((SRD->RD_DATPGT >= dDataDe .and. SRD->RD_DATPGT <= dDataAte) .and.;
                            PosSrv(SRD->RD_PD,SRD->RD_FILIAL,"RV_TIPOCOD") == "2")
                            nBenef := AScan(aValBenef, {|x| PosSrv(x[4],cFilFun ,"RV_CODCOM_") == cVerbaDis})
                            If (nBenef > 0)
                                AAdd(aValBenef, {aValBenef[nBenef,01],  aValBenef[nBenef,02], aValBenef[nBenef,03], SRD->RD_PD, SRD->RD_VALOR,aValBenef[nBenef,06],"","SRD","","",""})
                            EndIf
                        EndIf
                    EndIf
                EndIf
            EndIf
        EndIf
    Next nRoteiro

    // If (nValVrb > 0)
    //     nValLiq := nValVrb
    // EndIf

    // Restaura a ·rea e libera os vetores da memÛria
    FwRestArea(aAreaSRA)
    FwFreeArray(aAreaSRA)
    FwFreeArray(aChaveBusca)
    FwFreeArray(aCodBenef)
    FwFreeArray(aCodBenefAux)
    FwFreeArray(cCodPdBenef)
    FwFreeArray(aPensPd)
Return NIL
