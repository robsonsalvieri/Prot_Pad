#Include "TOTVS.FRAMEWORK.TREPORTS.INTEGRATEDPROVIDER.th"
#Include "TLPP-CORE.th"
#Include "TLPP-REST.th"
#Include "PONCALEN.ch"
#Include "FWLIBVERSION.ch"
#Include "RH.SV.PON.PONR010.ch"

namespace totvs.protheus.rh.treportsintegratedprovider
using namespace totvs.framework.treports.integratedprovider

/*/{Protheus.doc} PONR010TReportsBusinessObject:new()
    Classe do objeto de negócio do Relatório Espelho de Ponto.
    @type Class
    @version 12.1.2310
    @author arthur.sales
    @since 23/04/2024
/*/
@totvsFrameworkTReportsIntegratedProvider(active=.T., team="SIGAPON", tables="SRA, SRJ, SR6, SP4, SP6, SP8, SP9, SPC, SPI, SPG, SPH", customTables="SRA, SRJ, SR6", name="Relatório Espelho de Ponto", country="ALL", initialRelease="12.1.2310")
Class PONR010TReportsBusinessObject From IntegratedProvider
    // Define os métodos da classe
    Public Method new()       As Object
    Public Method getData()   As Object
    Public Method getSchema() As Object

    @Get("/api/rh/smartview/v1/options/PONR010/:param")
    Public Method getComboBox() As Variant
EndClass

/*/{Protheus.doc} PONR010TReportsBusinessObject:new()
    Instancia a classe do objeto de negócio.
    @type Method
    @version 12.1.2310
    @author arthur.sales
    @since 23/04/2024
    @return Object, Instância do objeto de negócio
/*/
Method new() As Object Class PONR010TReportsBusinessObject
    // Chama o construtor da classe super
    _Super:new()

    // Define a área
    self:appendArea(STR0001) // "RH"

    // Define o nome e descrição do objeto de negócio
    self:setDisplayName(STR0002) // "Espelho de Ponto"
    self:setDescription(STR0003) // "Este objeto de negócio traz as informações do Relatório Espelho de Ponto."
Return self

/*/{Protheus.doc} PONR010TReportsBusinessObject:getData()
    Captura os dados do objeto de negócio.
    @type Method
    @version 12.1.2310
    @author arthur.sales
    @since 23/04/2024
    @return Object, Dados do objeto de negócio
/*/
Method getData(nPage As Numeric, oFilter As Object) As Object Class PONR010TReportsBusinessObject
    // Declaração das variáveis locais
    Local cQuery              As Character // Query para busca dos registros
    Local cAlias              As Character // Alias do arquivo temporário
    Local cFilter             As Character // Filtro do objeto de negócio
    Local cDateFrom           As Character // Parâmetro Data De
    Local cDateTo             As Character // Parâmetro Data Até
    Local cBranchCodeFrom     As Character // Parâmetro Filial De
    Local cBranchCodeTo       As Character // Parâmetro Filial Até
    Local cCostCenterCodeFrom As Character // Parâmetro Centro de Custo De
    Local cCostCenterCodeTo   As Character // Parâmetro Centro de Custo Até
    Local cShiftCodeFrom      As Character // Parâmetro Turno De
    Local cShiftCodeTo        As Character // Parâmetro Turno Até
    Local cEmployeeCodeFrom   As Character // Parâmetro Matrícula De
    Local cEmployeeCodeTo     As Character // Parâmetro Matrícula Até
    Local cNameFrom           As Character // Parâmetro Nome De
    Local cNameTo             As Character // Parâmetro Nome Até
    Local cDepartmentFrom     As Character // Parâmetro Departamento De
    Local cDepartmentTo       As Character // Parâmetro Departamento Até
    Local cEmployeeRuleFrom   As Character // Parâmetro Regra De
    Local cEmployeeRuleTo     As Character // Parâmetro Regra Até
    Local cCustomFields       As Character // Campos customizados no formato SQL
    Local cLastFil            As Character // Armazena a última filial
    Local cAcessaSRA          As Character // Bloco de código para verificar acesso à SRA
    Local cSeq                As Character // Sequência do turno
    Local cTurno              As Character // Turno do funcionário
    Local cFile               As Character // Nome do arquivo para enviar ao TAE
    Local cCodeBar            As Character // Código de barras gerado
    Local cNoctDiffType       As Character // Tipo de adicional noturno
    Local cValidFil           As Character // Filiais válidas
    Local cName               As Character // Nome real do campo
    Local jParams             As JSON      // Parâmetros do objeto de negócio
    Local jData               As JSON      // Informações de uma linha do ON
    Local jLGPD               As JSON      // Indica quais campos devem ser ofuscados
    Local oStatement          As Object    // Instância da classe FwExecStatement
    Local oSign               As Object    // Objeto para integração com o TAE
    Local nParamOrder         As Numeric   // Ordem dos bind parameters da query
    Local nAux                As Numeric   // Contador auxiliar para percorrer vetores
    Local nPeriodos           As Numeric   // Contador auxiliar para percorrer os períodos
    Local nSaldoAnt           As Numeric   // Saldo anterior do banco de horas
    Local nSaldoAtu           As Numeric   // Saldo atual do banco de horas
    Local nCredito            As Numeric   // Crédito do banco de horas
    Local nDebito             As Numeric   // Débito do banco de horas
    Local nTotHrVal           As Numeric   // Total de horas valorizadas
    Local nImpHrs             As Numeric   // Parâmetro Imprime horas
    Local nTamRAMAT           As Numeric   // Tamanho do campo RA_MAT
    Local nImpAut             As Numeric   // Parâmetro Demonstra Horas
    Local nPos                As Numeric   // Auxiliar para busca de registro em vetores
    Local nFields             As Numeric   // Contador de campos
    Local aEmployeeSituation  As Array     // Parâmetro Situações
    Local aEmployeeCategory   As Array     // Parâmetro Categorias
    Local aAbonosPer          As Array     // Abonos do período
    Local aImp                As Array     // Informações para impressão
    Local aTotais             As Array     // Totalizadores das marcações
    Local aAbonados           As Array     // Informações dos abonos
    Local aAfast              As Array     // Informações dos afastamentos
    Local aInfo               As Array     // Informações da filial do funcionário
    Local aTurnos             As Array     // Informações dos turnos
    Local aPrtTurn            As Array     // Turnos ativos dentro do período informado
    Local aMarcacoes          As Array     // Marcações do funcionário no período informado
    Local aMarcDes            As Array     // Marcações desconsideradas
    Local aTabPadrao          As Array     // Tabela padrão do funcionário
    Local aTabCalend          As Array     // Tabela do calendário do funcionário
    Local aPeriodos           As Array     // Informações dos períodos do intervalo de datas informado
    Local aId                 As Array     // Ids dos eventos da filial
    Local aResult             As Array     // Resultado das horas apontadas do funcionário
    Local aBoxSPC             As Array     // Opções do combobox do campo PC_TPMARCA
    Local aCodAut             As Array     // Eventos autorizados da filial
    Local aPDFields           As Array     // Campos que podem ser exibidos de acordo com a LGPD
    Local aAllFields          As Array     // Estrutura de todos os campos do ON
    Local lObfuscated         As Logical   // Flag que indica se tem algum campo para ofuscar
    Local lSPJExclu           As Logical   // Verifica se a tabela SPJ existe
    Local lSP9Exclu           As Logical   // Verifica se a tabela SP9 existe
    Local lMvAbosEve          As Logical   // Conteúdo do parâmetro MV_ABOSEVE
    Local lMvSubAbAp          As Logical   // Conteúdo do parâmetro MV_SUBABAP
    Local lTAE                As Logical   // Se integra com o TAE
    Local lPrintDisreg        As Logical   // Se imprime as marcações desconsideradas
    Local lImpMarc            As Logical   // Parâmetro Imprime marcações
    Local lImpHrVal           As Logical   // Parâmetro Imprime horas valorizadas
    Local lCodeBar            As Logical   // Se imprime código de barras
    Local lImpTroca           As Logical   // Se imprime troca de turnos
    Local lPort671            As Logical   // Conteúdo do parâmetro MV_PORT671
    Local lMRHTae             As Logical   // Conteúdo do parâmetro MV_MRHTAE
    Local lImpAcum            As Logical   // Se imprime acumulado
    Local lSemMarc            As Logical   // Parâmetro Func. sem marc.
    Local lSexagenal          As Logical   // Se imprime horas em sexagesimal
    Local lImpRes             As Logical   // Parâmetro Eventos do result.
    Local lImpBh              As Logical   // Parâmetro Imp. banco de horas
    Local lRetSeq             As Logical   // Flag de retorno da função RetSeq()
    Local dPerIni             As Date      // Data inicial do período
    Local dPerFim             As Date      // Data final do período
    Local dIniCale            As Date      // Data inicial a considerar para o calendário
    Local dFimCale            As Date      // Data final a considerar para o calendário
    Local dMarcIni            As Date      // Data inicial a considerar para recuperar as marcações
    Local dMarcFim            As Date      // Data final a considerar para recuperar as marcações
    Local dIniPonMes          As Date      // Data inicial do período em aberto
    Local dFimPonMes          As Date      // Data final do período em aberto
    Local dCurrent            As Date      // Data auxiliar para percorrer os dias

    Private lImpExcecao       As Logical   // Parâmetro Desc. Exceção afast.

    // Inicialização das variáveis
    cQuery              := ""
    cAlias              := ""
    cFilter             := IIf(oFilter:hasFilter(), " AND " + oFilter:getSQLExpression(), "")
    cDateFrom           := ""
    cDateTo             := ""
    cBranchCodeFrom     := ""
    cBranchCodeTo       := ""
    cCostCenterCodeFrom := ""
    cCostCenterCodeTo   := ""
    cShiftCodeFrom      := ""
    cShiftCodeTo        := ""
    cEmployeeCodeFrom   := ""
    cEmployeeCodeTo     := ""
    cNameFrom           := ""
    cNameTo             := ""
    cCustomFields       := ""
    cLastFil            := "__cLastFil__"
    cAcessaSRA          := &("{|| " + ChkRH("PONR010","SRA","2") + "}")
    cSeq                := ""
    cTurno              := ""
    cFile               := ""
    cCodeBar            := ""
    cNoctDiffType       := ""
    cValidFil           := fValidFil()
    cName               := ""
    jParams             := oFilter:getParameters()
    jData               := NIL
    jLGPD               := JSONObject():New()
    oStatement          := NIL
    oSign               := NIL
    aEmployeeSituation  := {}
    aEmployeeCategory   := {}
    aAbonosPer          := {}
    aImp                := {}
    aTotais             := {}
    aAbonados           := {}
    aAfast              := {}
    aInfo               := {}
    aTurnos             := {}
    aPrtTurn            := {}
    aMarcacoes          := {}
    aMarcDes            := {}
    aTabPadrao          := {}
    aTabCalend          := {}
    aPeriodos           := {}
    aId                 := {}
    aResult             := {}
    aBoxSPC             := LoadX3Box("PC_TPMARCA")
    aCodAut             := {}
    aPDFields           := FwProtectedDataUtil():UsrAccessPDField(__cUserID, self:getArrayFields())
    lObfuscated         := Len(aPDFields) != Len(self:getArrayFields())
    aAllFields          := self:getStructFields()
    lSPJExclu           := !Empty(FwXFilial("SPJ"))
    lSP9Exclu           := !Empty(FwXFilial("SP9"))
    lMvAbosEve          := .F.
    lMvSubAbAp          := .F.
    lTAE                := .F.
    lPrintDisreg        := .F.
    lImpMarc            := .T.
    lImpHrVal           := .T.
    lCodeBar            := .T.                                // Fixo como verdadeiro para retornar sempre no ON
    lImpTroca           := .T.                                // Fixo como verdadeiro para retornar sempre no ON
    lPort671            := SuperGetMV("MV_PORT671", NIL, .F.)
    lMRHTae             := SuperGetMV("MV_MRHTAE",  NIL, .F.) // Método de assinatura do TAE caso o cliente utilize o MeuRH
    lImpAcum            := .F.
    lSemMarc            := .F.
    lSexagenal          := .F.
    lImpRes             := .F.
    lImpExcecao         := .F.
    lImpBh              := .F.
    lRetSeq             := .F.
    nParamOrder         := 1
    nAux                := 0
    nPeriodos           := 0.00
    nSaldoAnt           := 0.00
    nSaldoAtu           := 0.00
    nCredito            := 0.00
    nDebito             := 0.00
    nTotHrVal           := 0.00
    nImpHrs             := 0.00
    nTamRAMAT           := GetSX3Cache("RA_MAT", "X3_TAMANHO")
    nImpAut             := 0
    nPos                := 0
    nFields             := 1
    dPerIni             := CToD("")
    dPerFim             := CToD("")
    dIniCale            := CToD("")
    dFimCale            := CToD("")
    dMarcIni            := CToD("")
    dMarcFim            := CToD("")
    dIniPonMes          := CToD("")
    dFimPonMes          := CToD("")
    dCurrent            := CToD("")

    // Adiciona no JSON todos os campos como atributos e com o conteúdo sendo uma flag que indica se o campo deve ser ofuscado
    For nFields := 1 To Len(aAllFields)
        cName        := Trim(aAllFields[nFields]:getRealName())
        jLGPD[cName] := AScan(aPDFields, {|x| Trim(x) == cName}) <= 0
    Next nFields

    // Captura o valor dos parâmetros
    If (jParams != NIL)
		cDateFrom			:= IIf(jParams:hasProperty("DateFrom")				.And. Len(jParams["DateFrom"])				> 0 .And.	!Empty(jParams["DateFrom"][1]),					jParams["DateFrom"][1],           FwTimeStamp(6, CToD("")))
		cDateTo				:= IIf(jParams:hasProperty("DateTo")				.And. Len(jParams["DateTo"])				> 0 .And.	!Empty(jParams["DateTo"][1]),					jParams["DateTo"][1],             FwTimeStamp(6, CToD("")))
		cBranchCodeFrom		:= IIf(jParams:hasProperty("BranchCodeFrom")		.And. Len(jParams["BranchCodeFrom"])		> 0 .And.	!Empty(jParams["BranchCodeFrom"][1]),			jParams["BranchCodeFrom"][1],     "")
		cBranchCodeTo		:= IIf(jParams:hasProperty("BranchCodeTo")			.And. Len(jParams["BranchCodeTo"])			> 0 .And.	!Empty(jParams["BranchCodeTo"][1]),				jParams["BranchCodeTo"][1],       Replicate("Z", GetSX3Cache("RA_FILIAL", "X3_TAMANHO")))
		cCostCenterCodeFrom	:= IIf(jParams:hasProperty("CostCenterCodeFrom")	.And. Len(jParams["CostCenterCodeFrom"])	> 0 .And.	!Empty(jParams["CostCenterCodeFrom"][1]),		jParams["CostCenterCodeFrom"][1], "")
		cCostCenterCodeTo	:= IIf(jParams:hasProperty("CostCenterCodeTo")		.And. Len(jParams["CostCenterCodeTo"])		> 0 .And.	!Empty(jParams["CostCenterCodeTo"][1]),			jParams["CostCenterCodeTo"][1],   Replicate("Z", GetSX3Cache("RA_CC", "X3_TAMANHO")))
		cShiftCodeFrom		:= IIf(jParams:hasProperty("ShiftCodeFrom")			.And. Len(jParams["ShiftCodeFrom"])			> 0 .And.	!Empty(jParams["ShiftCodeFrom"][1]),			jParams["ShiftCodeFrom"][1],      "")
		cShiftCodeTo		:= IIf(jParams:hasProperty("ShiftCodeTo")			.And. Len(jParams["ShiftCodeTo"])			> 0 .And.	!Empty(jParams["ShiftCodeTo"][1]),				jParams["ShiftCodeTo"][1],        Replicate("Z", GetSX3Cache("RA_TNOTRAB", "X3_TAMANHO")))
		cEmployeeCodeFrom	:= IIf(jParams:hasProperty("EmployeeCodeFrom")		.And. Len(jParams["EmployeeCodeFrom"])		> 0 .And.	!Empty(jParams["EmployeeCodeFrom"][1]),			jParams["EmployeeCodeFrom"][1],   "")
		cEmployeeCodeTo		:= IIf(jParams:hasProperty("EmployeeCodeTo")		.And. Len(jParams["EmployeeCodeTo"])		> 0 .And.	!Empty(jParams["EmployeeCodeTo"][1]),			jParams["EmployeeCodeTo"][1],     Replicate("Z", GetSX3Cache("RA_MAT", "X3_TAMANHO")))
		cDepartmentFrom		:= IIf(jParams:hasProperty("DepartmentFrom")		.And. Len(jParams["DepartmentFrom"])		> 0 .And.	!Empty(jParams["DepartmentFrom"][1]),			jParams["DepartmentFrom"][1],     "")
		cDepartmentTo		:= IIf(jParams:hasProperty("DepartmentTo")			.And. Len(jParams["DepartmentTo"])			> 0 .And.	!Empty(jParams["DepartmentTo"][1]),				jParams["DepartmentTo"][1],       Replicate("Z", GetSX3Cache("RA_DEPTO", "X3_TAMANHO")))
		cEmployeeRuleFrom	:= IIf(jParams:hasProperty("EmployeeRuleFrom")		.And. Len(jParams["EmployeeRuleFrom"])		> 0 .And.	!Empty(jParams["EmployeeRuleFrom"][1]),			jParams["EmployeeRuleFrom"][1],   "")
		cEmployeeRuleTo		:= IIf(jParams:hasProperty("EmployeeRuleTo")		.And. Len(jParams["EmployeeRuleTo"])		> 0 .And.	!Empty(jParams["EmployeeRuleTo"][1]),			jParams["EmployeeRuleTo"][1],     Replicate("Z", GetSX3Cache("RA_REGRA", "X3_TAMANHO")))
		cNameFrom			:= IIf(jParams:hasProperty("NameFrom")				.And. Len(jParams["NameFrom"])				> 0 .And.	!Empty(jParams["NameFrom"][1]),					jParams["NameFrom"][1],           "")
		cNameTo				:= IIf(jParams:hasProperty("NameTo")				.And. Len(jParams["NameTo"])				> 0 .And.	!Empty(jParams["NameTo"][1]),					jParams["NameTo"][1],             Replicate("Z", GetSX3Cache("RA_NOME", "X3_TAMANHO")))
		nImpHrs				:= IIf(jParams:hasProperty("PrintHours")			.And. Len(jParams["PrintHours"])			> 0 .And.	!Empty(jParams["PrintHours"][1]),				Val(jParams["PrintHours"][1]),    3)   // Calculadas | Informadas | Ambas | N/A
		nImpAut				:= IIf(jParams:hasProperty("ShowHours")				.And. Len(jParams["ShowHours"])				> 0 .And.	!Empty(jParams["ShowHours"][1]),				Val(jParams["ShowHours"][1]),     3)   // Autorizadas | Não autorizadas | Ambas
		lSexagenal			:= IIf(jParams:hasProperty("HoursType")				.And. Len(jParams["HoursType"])				> 0 .And.	!Empty(jParams["HoursType"][1]),				jParams["HoursType"][1] == "1",   .T.) // Sexagesimal | Centesimal
		
		If jParams:hasProperty("WithoutPunch") .And. Len(jParams["WithoutPunch"]) > 0 .And. !Empty(jParams["WithoutPunch"][1])
			If ValType(jParams["WithoutPunch"][1]) == "L"
				lSemMarc := jParams["WithoutPunch"][1]
			Else
				lSemMarc := If(jParams["PrintEvents"][1] == "true", .T., .F.)
			EndIf
		EndIf
		
		If jParams:hasProperty("PrintEvents") .And. Len(jParams["PrintEvents"]) > 0 .And. !Empty(jParams["PrintEvents"][1])
			If ValType(jParams["PrintEvents"][1]) == "L"
				lImpRes := jParams["PrintEvents"][1]
			Else
				lImpRes := If(jParams["PrintEvents"][1] == "true", .T., .F.)
			EndIf
		EndIf
		
		If jParams:hasProperty("PrintException") .And. Len(jParams["PrintException"]) > 0 .And. !Empty(jParams["PrintException"][1])
			If ValType(jParams["PrintException"][1]) == "L"
				lImpExcecao := jParams["PrintException"][1]
			Else
				lImpExcecao := If(jParams["PrintException"][1] == "true", .T., .F.)
			EndIf
		EndIf
		
		If jParams:hasProperty("PrintHoursBank") .And. Len(jParams["PrintHoursBank"]) > 0 .And. !Empty(jParams["PrintHoursBank"][1])
			If ValType(jParams["PrintHoursBank"][1]) == "L"
				lImpBh := jParams["PrintHoursBank"][1]
			Else
				lImpBh := If(jParams["PrintHoursBank"][1] == "true", .T., .F.)
			EndIf
		EndIf
		
		If jParams:hasProperty("TAEIntegration") .And. Len(jParams["TAEIntegration"]) > 0 .And. !Empty(jParams["TAEIntegration"][1])
			If ValType(jParams["TAEIntegration"][1]) == "L"
				lTAE := jParams["TAEIntegration"][1]
			Else
				lTAE := If(jParams["TAEIntegration"][1] == "true", .T., .F.)
			EndIf
		EndIf
		
		If jParams:hasProperty("PrintDisreg") .And. Len(jParams["PrintDisreg"]) > 0 .And. !Empty(jParams["PrintDisreg"][1])
			If ValType(jParams["PrintDisreg"][1]) == "L"
				lPrintDisreg := jParams["PrintDisreg"][1]
			Else
				lPrintDisreg := If(jParams["PrintDisreg"][1] == "true", .T., .F.)
			EndIf
		EndIf		
		
		aEmployeeSituation	:= IIf(jParams:hasProperty("EmployeeSituation"), jParams["EmployeeSituation"], {})
		aEmployeeCategory	:= IIf(jParams:hasProperty("EmployeeCategory"),  jParams["EmployeeCategory"],  {})
    EndIf

    // Percorre as situações para tratar registro nulo ou em branco (caso não tratar dá erro no banco)
    For nAux := 1 To Len(aEmployeeSituation)
        aEmployeeSituation[nAux] := IIf(aEmployeeSituation[nAux] == NIL .or. Empty(aEmployeeSituation[nAux]), " ", aEmployeeSituation[nAux])
    Next nAux

    // Percorre as categorias para tratar registro nulo ou em branco (caso não tratar dá erro no banco)
    For nAux := 1 To Len(aEmployeeCategory)
        aEmployeeCategory[nAux] := IIf(aEmployeeCategory[nAux] == NIL .or. Empty(aEmployeeCategory[nAux]), " ", aEmployeeCategory[nAux])
    Next nAux

    // Trata as variáveis de data para ficarem no formato do banco
    dPerIni := SToD(StrTran(SubStr(cDateFrom, 1, 10), "-", ""))
    dPerFim := SToD(StrTran(SubStr(cDateTo,   1, 10), "-", ""))

    // Como a cada período lido reinicializamos as datas inicial e final preservamos-as nas variáveis: dIniCale e dFimCale
    dIniCale := dPerIni // Data inicial a considerar para o calendário
    dFimCale := dPerFim // Data final a considerar para o calendário

    BEGIN SEQUENCE
        // Valida a autenticação com TAE
        If (lTAE .and. !SetUpSign(@oSign))
            self:setErrorStatus(400, STR0004, STR0005)                 // "Erro na autenticação com o TAE." | "Não foi possível se autenticar com o TAE (TOTVS Assinatura Eletrônica)."
            FwLogMsg("WARN", NIL, "SmartView", NIL, NIL, NIL, STR0005) // "Não foi possível se autenticar com o TAE (TOTVS Assinatura Eletrônica)."
            BREAK
        EndIf

        // Inicializa variáveis estáticas
        (CarExtAut(), RstGetTabExtra())

        cQuery += "SELECT "
        cQuery +=     "RA_FILIAL, "
        cQuery +=     "RA_MAT, "
        cQuery +=     "RA_NOME, "
        cQuery +=     "RA_NSOCIAL, "
        cQuery +=     "RA_CC, "
        cQuery +=     "RA_TNOTRAB, "
        cQuery +=     "RJ_DESC, "
        cQuery +=     "SRA.R_E_C_N_O_ AS SRA_RECNO "
        cQuery +=     "? " // 1
        cQuery += "FROM "
        cQuery +=     RetSQLName("SRA") + " SRA "
        cQuery +=     "LEFT JOIN "
        cQuery +=         RetSQLName("SRJ") + " SRJ "
        cQuery +=         "ON "
        cQuery +=             FwJoinFilial("SRJ", "SRA") + " "
        cQuery +=             "AND RJ_FUNCAO      = RA_CODFUNC "
        cQuery +=             "AND SRJ.D_E_L_E_T_ = ? " // 2
        cQuery +=     "WHERE "
        cQuery +=         "RA_FILIAL      BETWEEN ? AND ? " // 3 e 4
        cQuery +=         "AND RA_CC      BETWEEN ? AND ? " // 5 e 6
        cQuery +=         "AND RA_MAT     BETWEEN ? AND ? " // 7 e 8
        cQuery +=         "AND RA_DEPTO   BETWEEN ? AND ? " // 9 e 10
        cQuery +=         "AND RA_NOME    BETWEEN ? AND ? " // 11 e 12
        cQuery +=         "AND RA_TNOTRAB BETWEEN ? AND ? " // 13 e 14
        cQuery +=         "AND RA_REGRA   BETWEEN ? AND ? " // 15 e 16
        cQuery +=         "AND RA_SITFOLH IN (?) "          // 17
        cQuery +=         "AND RA_CATFUNC IN (?) "          // 18
        cQuery +=         "AND SRA.D_E_L_E_T_ = ? "         // 19
        cQuery +=         "? "                              // 20
        cQuery += "ORDER BY "
        cQuery +=     "RA_FILIAL, "
        cQuery +=     "RA_MAT "
        cQuery := ChangeQuery(cQuery)

        // Instancia a classe
        oStatement := FwExecStatement():New(cQuery)

        // Captura e define os campos personalizados das tabelas CTT, SR6 e SPM
        cCustomFields := GPESmartViewUtils():GetCustomFields(self:getCustomFields(), {"SRA", "SRJ", "SR6"})
        oStatement:SetUnsafe(nParamOrder++, IIf(!Empty(cCustomFields), "," + cCustomFields, "")) // 1

        oStatement:SetString(nParamOrder++, " ")                                                    // 2
        oStatement:SetString(nParamOrder++, cBranchCodeFrom)                                        // 3
        oStatement:SetString(nParamOrder++, cBranchCodeTo)                                          // 4
        oStatement:SetString(nParamOrder++, cCostCenterCodeFrom)                                    // 5
        oStatement:SetString(nParamOrder++, cCostCenterCodeTo)                                      // 6
        oStatement:SetString(nParamOrder++, cEmployeeCodeFrom)                                      // 7
        oStatement:SetString(nParamOrder++, cEmployeeCodeTo)                                        // 8
        oStatement:SetString(nParamOrder++, cDepartmentFrom)                                        // 9
        oStatement:SetString(nParamOrder++, cDepartmentTo)                                          // 10
        oStatement:SetString(nParamOrder++, cNameFrom)                                              // 11
        oStatement:SetString(nParamOrder++, cNameTo)                                                // 12
        oStatement:SetString(nParamOrder++, cShiftCodeFrom)                                         // 13
        oStatement:SetString(nParamOrder++, cShiftCodeTo)                                           // 14
        oStatement:SetString(nParamOrder++, cEmployeeRuleFrom)                                      // 15
        oStatement:SetString(nParamOrder++, cEmployeeRuleTo)                                        // 16

        If (Len(aEmployeeSituation) > 0)
            oStatement:SetIn(nParamOrder++, aEmployeeSituation)                                     // 17
        Else
            oStatement:SetUnsafe(nParamOrder++, GPESmartViewUtils():GetSQLIN(fSituacao(NIL, .F.)))  // 17
        EndIf

        If (Len(aEmployeeCategory) > 0)
            oStatement:SetIn(nParamOrder++, aEmployeeCategory)                                      // 18
        Else
            oStatement:SetUnsafe(nParamOrder++, GPESmartViewUtils():GetSQLIN(fCategoria(NIL, .F.))) // 18
        EndIf

        oStatement:SetString(nParamOrder++, " ")                                                    // 19
        oStatement:SetUnsafe(nParamOrder++, cFilter)                                                // 20

        // Executa a query e retorna o alias criado
        cAlias := oStatement:OpenAlias()

        If (lCodeBar .or. lTAE)
            DBSelectArea("RS4")
            DBSetOrder(1)
        EndIf

        // Seleciona a área da SRA para posicionar no registro do funcionário
        DBSelectArea("SRA")
        DBSetOrder(1) // RA_FILIAL + RA_MAT + RA_NOME

        // Percorre funcionários
        While (cAlias)->(!EOF())
            // Posiciona no funcionário atual
            SRA->(MsSeek((cAlias)->(RA_FILIAL + RA_MAT + RA_NOME)))

            // Consiste controle de acessos, filiais válidas e data de demissão (ae o funcionário foi demitido anteriormente ao inicio do período solicitado desconsidera-o)
            If (SRA->(!(RA_FILIAL $ cValidFil) .or. !Eval(cAcessaSRA) .or. (!Empty(RA_DEMISSA) .and. (RA_DEMISSA < dIniCale))))
                (cAlias)->(DBSkip())
                Loop
            EndIf

            // Verifica a troca de filial
            If (!(SRA->RA_FILIAL == cLastFil))
                // Alimenta as variáveis com o conteúdo dos MV_'S correspondentes
                lMvAbosEve := (Upper(AllTrim(SuperGetMv("MV_ABOSEVE", NIL, "N", cLastFil))) == "S") // Verifica se deduz as horas abonadas das horas do evento sem a necessidade de informa o codigo do evento no motivo de abono que abona horas
                lMvSubAbAp := (Upper(AllTrim(SuperGetMv("MV_SUBABAP", NIL, "N", cLastFil))) == "S") // Verifica se quando abono nao abonar horas e possuir código de evento, se devera gera-lo em outro evento e abater suas horas das horas calculadas

                // Atualiza a filial corrente
                cLastFil := SRA->RA_FILIAL

                // Carrega período de apontamento aberto
                If (!CheckPonMes(@dPerIni, @dPerFim, .F., .T., .F., cLastFil))
                    Exit
                EndIf

                // Obtém datas do período em aberto
                GetPonMesDat(@dIniPonMes, @dFimPonMes, cLastFil)

                // Atualiza o vetor de informações sobre a empresa
                aInfo := {}
                fInfo(@aInfo, cLastFil)

                // Carrega as tabelas de horário padrão
                If (lSPJExclu .or. Empty(aTabPadrao))
                    aTabPadrao := {}
                    fTabTurno(@aTabPadrao, If(lSPJExclu, cLastFil, NIL),,, SRA->RA_TNOTRAB)
                EndIf

                // Carrega TODOS os eventos da filial
                If (Empty(aId) .or. (lSP9Exclu))
                    aId := {}
                    CarId(fFilFunc("SP9"), @aId, "*")
                EndIf

                aCodAut := {}
                fTabSP4(@aCodAut, FwXFilial("SP4", cLastFil))
            EndIf

            aPeriodos := Monta_Per(dIniCale, dFimCale, cLastFil, SRA->RA_MAT, dIniPonMes, dFimPonMes)

            // Percorre todos os períodos
            For nPeriodos := 1 To Len(aPeriodos)
                // Reinicializa as datas inicial e final a cada período lido
                // Os valores de dPeriIi e dPerFim foram preservados nas variáveis: dCaleIni e dCaleFim
                dPerIni := aPeriodos[nPeriodos, 1]
                dPerFim := aPeriodos[nPeriodos, 2]

                // Obtém as datas para recuperação das marcações
                dMarcIni := aPeriodos[nPeriodos, 3]
                dMarcFim := aPeriodos[nPeriodos, 4]

                // Verifica se impressão é de acumulado
                lImpAcum := (dPerFim < dIniPonMes)

                // Retorna turno/sequência das marcações acumuladas
                If (lImpAcum)
                    If SPF->(DBSeek(SRA->(RA_FILIAL + RA_MAT) + DToS(dPerIni))) .and. !Empty(SPF->PF_SEQUEPA)
                        cTurno := SPF->PF_TURNOPA
                        cSeq   := SPF->PF_SEQUEPA
                    Else
                        // Tenta achar a sequência inicial utilizando RetSeq()
                        lRetSeq := RetSeq(cSeq, @cTurno, dPerIni, dPerFim, dDataBase, aTabPadrao, @cSeq)

                        // Tenta achar a sequência inicial utilizando fQualSeq()
                        cSeq := IIf(!lRetSeq .or. Empty(cSeq), fQualSeq(NIL, aTabPadrao, dPerIni, @cTurno), cSeq)
                    EndIf

                    If (Empty(cTurno))
                        SPF->(DBSeek(SRA->(RA_FILIAL + RA_MAT)))
                        While (!EOF()) .and. (SRA->RA_FILIAL + SRA->RA_MAT == SPF->PF_FILIAL + SPF->PF_MAT)
                            If (SPF->PF_DATA >= dPerIni .and. SPF->PF_DATA <= dPerFim)
                                cTurno := SPF->PF_TURNOPA
                                cSeq   := SPF->PF_SEQUEPA
                                Exit
                            Else
                                SPF->(DBSkip())
                            EndIf
                        End
                    EndIf
                Else
                    //Considera a Sequencia e Turno do Cadastro
                    cTurno := SRA->RA_TNOTRAB
                    cSeq   := SRA->RA_SEQTURN
                EndIf

                (aMarcacoes := {}, aTabCalend := {}, aTurnos := {}, aMarcDes := {})

                If lImpMarc .or. lImpTroca
                    // Carrega Arrays com as marcações do período (aMarcacoes), com o Calendário de marcações do período (aTabCalend) e com as Trocas de Turno do funcionário (aTurnos)
                    If !GetMarcacoes(;
                            @aMarcacoes,;               // Marcacoes dos funcionários
                            @aTabCalend,;               // Calendário de Marcacoes
                            @aTabPadrao,;               // Tabela Padrao
                            @aTurnos,;                  // Turnos de Trabalho
                            dPerIni,;                   // período Inicial
                            dPerFim,;                   // período Final
                            SRA->RA_FILIAL,;            // Filial
                            SRA->RA_MAT,;               // Matricula
                            cTurno,;                    // Turno
                            cSeq,;                      // Sequencia de Turno
                            SRA->RA_CC,;                // Centro de Custo
                            IIf(lImpAcum,"SPG","SP8"),; // Alias para Carga das Marcacoes
                            NIL,;                       // Se carrega Recno em aMarcacoes
                            .T.,;                       // Se considera Apenas Ordenadas
                            .T.,;                       // Se Verifica as Folgas Automáticas
                            .F.,;                       // Se Grava Evento de Folga Automatica período Anterior
                            NIL,;                       //17 -> Se Carrega as Marcacoes Automáticas
                            NIL,;                       //18 -> Registros de Marcacoes Automáticas que deverao ser Desprezadas
                            NIL,;                       //19 -> Bloco para avaliar as Marcacoes Automáticas que deverao ser Desprezadas
                            NIL,;                       //20 -> Se Considera o período de Apontamento das Marcacoes
                            NIL,;                       //21 -> Se Efetua o Sincronismo dos Horarios na Criacao do Calendario
                            .T.,;                       //22 -> Se carrega as marcacoes desconsideradas (Uso com lPort1510)
                            NIL;                        //23 -> Se carrega as marcacoes das duas tabelas SP8 e SPG
                    )
                        Loop
                    EndIf

                    If lImpMarc
                        // Carrega as marcações desconsideradas no aMarcDes e as excluí do aMarcacoes
                        GetMarcDes(@aMarcacoes, @aMarcDes)
                    EndIf
                EndIf

                aPrtTurn:={}
                AEval(aTurnos, {|x| IIf(x[2] >= dPerIni .and. x[2] <= dPerFim, AAdd(aPrtTurn, x), NIL)})

                // Reinicializa os vetores
                aTotais   := {}
                aAbonados := {}
                aAfast    := {}

                // Carrega os abonos conforme período
                If lImpMarc
                    fAbonosPer(@aAbonosPer, dPerIni, dPerFim, cLastFil, SRA->RA_MAT)
                EndIf

                // Carrega os totais de horas e abonos
                If lImpMarc
                    CarAboTot(@aTotais, @aAbonados, aAbonosPer, lMvAbosEve, lMvSubAbAp, aID, aBoxSPC, dMarcIni, dMarcFim, lImpAcum, nImpHrs, nImpAut, aTabCalend, lImpRes, lSexagenal)
                EndIf

                /* Carrega o array a ser utilizado na impressao
                aPeriodos[nPeriodos,3] --> Inicio do período para considerar as marcacoes e tabela
                aPeriodos[nPeriodos,4] --> Fim do período para considerar as marcacoes e tabela */
                If (!fMontaAimp(aTabCalend, aMarcacoes, @aImp, dMarcIni, dMarcFim, lImpAcum, lImpMarc, lPort671, @aResult, aAbonados, nImpAut, aCodAut) .and. !(lSemMarc))
                    Loop
                EndIf

                // Carrega a situacao e os afastamentos
                Pnr010Afas(dMarcIni, dMarcFim, @aAfast)

                // Quando integração com o TAE verifica se o funcionário tem email no cadastro
                If lTAE .and. Empty(SRA->RA_EMAIL)
                    Loop
                EndIf

                If lTAE
                    cFile := "PON_" + SRA->RA_FILIAL + SRA->RA_MAT + "_" + AnoMes(dPerIni)
                EndIf

                If lCodeBar .or. lTAE
                    cCodeBar := cEmpAnt + SRA->RA_FILIAL + PadL(AllTrim(SRA->RA_MAT), nTamRAMAT,"0") + DToS(dPerIni) + DToS(dPerFim) + DToS(dDataBase) + StrTran(Time(), ":", "")
                EndIf

                If lCodeBar .and. !lTAE // Grava o código de barras gerado na tabela RS4
                    GravaSR4("", "", lTAE, dPerIni, dPerFim, cCodeBar, oSign)
                EndIf

                // Montagem das informações do registro do ON
                jData := {;
                    "companyname":        Trim(aInfo[2]),;
                    "companycnpj":        IIf(Len(aInfo[8]) == 14, Transform(aInfo[8], "@!R NN.NNN.NNN/NNNN-99"), IIf(Len(aInfo[8]) == 11, Transform(aInfo[8], "@R 999.999.999-99"), "")),;
                    "branchname":         Trim(aInfo[1]),;
                    "socialname":         Trim(IIf(jLGPD["RA_NSOCIAL"], FwProtectedDataUtil():ValueAsteriskToAnonymize(SRA->RA_NSOCIAL),       SRA->RA_NSOCIAL)),;
                    "employeename":       Trim(IIf(jLGPD["RA_NOME"],    FwProtectedDataUtil():ValueAsteriskToAnonymize(SRA->RA_NOME),          SRA->RA_NOME)),;
                    "employeecpf":        IIf(jLGPD["RA_CIC"],          FwProtectedDataUtil():ValueAsteriskToAnonymize(SRA->RA_CIC),           IIf(!Empty(SRA->RA_CIC), Transform(SRA->RA_CIC, "@R 999.999.999-99"), "")),;
                    "employeecode":       Trim(IIf(jLGPD["RA_MAT"],     FwProtectedDataUtil():ValueAsteriskToAnonymize(SRA->RA_MAT),           SRA->RA_MAT)),;
                    "office":             Trim(IIf(jLGPD["RJ_DESC"],    FwProtectedDataUtil():ValueAsteriskToAnonymize(SRA->RJ_DESC),          (cAlias)->RJ_DESC)),;
                    "admissiondate":      IIf(jLGPD["RA_ADMISSA"],      FwProtectedDataUtil():ValueAsteriskToAnonymize(totvs.framework.treports.date.dateToTimeStamp(SRA->RA_ADMISSA)), totvs.framework.treports.date.dateToTimeStamp(SRA->RA_ADMISSA)),;
                    "contractualjourney": "",;
                    "perioddate":         Trim(DToC(dPerIni) + " a " + DToC(dPerFim)),;
                    "barcode":            cCodeBar;
                }

                // Cria os vetores no JSON
                jData["timebanksummary"]     := {}
                jData["detailsofhours"]      := {}
                jData["registeredmarks"]     := {}
                jData["shiftchange"]         := {}
                jData["detailsofextrahours"] := {}
                jData["periodtotals"]        := {}
                jData["unregisteredmarks"]   := {}

                // Preenche as marcações
                For nAux := 1 To Len(aImp)
                    nPos := AScan(aResult, {|x| SToD(x[1]) == aImp[nAux][1] .and. x[2] == "4"})
                    AAdd(jData["registeredmarks"], {;
                        "date":          totvs.framework.treports.date.dateToTimeStamp(aImp[nAux][1]),;
                        "day":           SubStr(DiaSemana(aImp[nAux][1]), 1, 3),;
                        "justification": aImp[nAux][2],;
                        "entrytime_1":   IIf(Len(aImp[nAux]) >= 3,  IIf(ValType(aImp[nAux][3]) == "A", aImp[nAux][3][1], aImp[nAux][3]), "-"),;
                        "exittime_1":    IIf(Len(aImp[nAux]) >= 4,  aImp[nAux][4],  "-"),;
                        "entrytime_2":   IIf(Len(aImp[nAux]) >= 5,  aImp[nAux][5],  "-"),;
                        "exittime_2":    IIf(Len(aImp[nAux]) >= 6,  aImp[nAux][6],  "-"),;
                        "entrytime_3":   IIf(Len(aImp[nAux]) >= 7,  aImp[nAux][7],  "-"),;
                        "exittime_3":    IIf(Len(aImp[nAux]) >= 8,  aImp[nAux][8],  "-"),;
                        "entrytime_4":   IIf(Len(aImp[nAux]) >= 9,  aImp[nAux][9],  "-"),;
                        "exittime_4":    IIf(Len(aImp[nAux]) >= 10, aImp[nAux][10], "-"),;
                        "entrytime_5":   IIf(Len(aImp[nAux]) >= 11, aImp[nAux][11], "-"),;
                        "exittime_5":    IIf(Len(aImp[nAux]) >= 12, aImp[nAux][12], "-"),;
                        "total":         Replace(StrZero(IIf(nPos > 0, IIf(!lSexagenal, Round(fConvHr(aResult[nPos][3], "D", NIL, 5, .T.), 2), aResult[nPos][3]), 0), 5, 2), ".", ":");
                    })
                Next nAux

                // Imprime as marcações desconsideradas
                If (lPrintDisreg)
                    For nAux := 1 To Len(aMarcDes)
                        AAdd(jData["unregisteredmarks"], {;
                                "date":   totvs.framework.treports.date.dateToTimeStamp(aMarcDes[nAux][1]),;
                                "day":    SubStr(DiaSemana(aMarcDes[nAux][1]), 1, 3),;
                                "time":   aMarcDes[nAux][2],;
                                "motive": aMarcDes[nAux][3];
                            })
                    Next nAux
                EndIf

                // Preenche o detalhamento de horas por dia
                // aResult: [1] = Data | [2] = P9_CLASEV/Tipo/AdicNot | [3] = QUANTI | [4] = QUANTV | [5] = P9_DESC | [6] = TIPOHE | [7] = PERCENT
                For nAux := 1 To Len(aResult)
                    dCurrent := SToD(aResult[nAux][1])

                    // Valida se a data atual estpá fora do intervalo de datas escolhido pelo usuário nos parâmetros
                    If (dCurrent < dIniCale .or. dCurrent > dFimCale)
                        Loop
                    EndIf

                    nPos  := AScan(jData["detailsofhours"], {|x| x["date"] == totvs.framework.treports.date.dateToTimeStamp(dCurrent)})
                    If (nPos > 0)
                        jData["detailsofhours"][nPos]["delayhour"]         := __TimeSum(jData["detailsofhours"][nPos]["delayhour"],         IIf(aResult[nAux][2] == "03",      aResult[nAux][3], 0))
                        jData["detailsofhours"][nPos]["absencehours"]      := __TimeSum(jData["detailsofhours"][nPos]["absencehours"],      IIf(aResult[nAux][2] == "02",      aResult[nAux][3], 0))
                        jData["detailsofhours"][nPos]["extrahour"]         := __TimeSum(jData["detailsofhours"][nPos]["extrahour"],         IIf(aResult[nAux][2] == "01",      aResult[nAux][3], 0))
                        jData["detailsofhours"][nPos]["nightdifferential"] := __TimeSum(jData["detailsofhours"][nPos]["nightdifferential"], IIf("AdicNot" $ aResult[nAux][2],  aResult[nAux][3], 0))
                        jData["detailsofhours"][nPos]["justification"]     += IIf(aResult[nAux][2] != "4" .and. !AllTrim(aResult[nAux][5]) $ jData["detailsofhours"][nPos]["justification"], IIf(!Empty(jData["detailsofhours"][nPos]["justification"]), " | ", "") + aResult[nAux][5], "")
                    Else
                        // Calcula as horas positivas e negativas do banco para o dia atual
                        Pnr010ImpBh(@nSaldoAnt, @nSaldoAtu, @nCredito, @nDebito, @nTotHrVal, lImpHrVal, dCurrent, dCurrent, lSexagenal)

                        AAdd(jData["detailsofhours"], {;
                            "date":              totvs.framework.treports.date.dateToTimeStamp(dCurrent),;
                            "day":               SubStr(DiaSemana(dCurrent), 1, 3),;
                            "paidhours":         fAbonos(dCurrent),;
                            "delayhour":         IIf(aResult[nAux][2] == "03",     aResult[nAux][3], 0),;
                            "absencehours":      IIf(aResult[nAux][2] == "02",     aResult[nAux][3], 0),;
                            "extrahour":         IIf(aResult[nAux][2] == "01",     aResult[nAux][3], 0),;
                            "nightdifferential": IIf("AdicNot" $ aResult[nAux][2], aResult[nAux][3], 0),;
                            "positivehours":     Round(nCredito, 2),;
                            "negativehours":     Round(nDebito,  2),;
                            "justification":     AllTrim(aResult[nAux][5]);
                        })
                    EndIf

                    // Verifica se é uma hora extra ou um adicional noturno para montar o resumo de horas extras
                    // Tipos HE: 1: Normal | 2: D.S.R. | 3: Compensado | 4: Feriado | 5: Normal Noturna | 6: D.S.R. Noturna
                    // 7: Compensada Noturna | 8: Feriado Noturna | A: Intervalo | B: Intervalo Noturna | C: Intervalo DSR
                    // D: Intervalo Noturna DSR | E: Intervalo Compensado | F: Intervalo Noturna Compensado | G: Intervalo Feriado | H: Intervalo Noturna Feriado
                    If (!Empty(aResult[nAux][6]))
                        // Separa as horas extras em HE normais, HE feriado, HE descanso/folga
                        // e HE noturna conforme o tipo de HE

                        // Horas normais
                        If (aResult[nAux][6] $ "1|A")
                            // Procura um registro que tenha o mesmo percentual que o atual
                            nPos := AScan(jData["detailsofextrahours"], {|x| x["businessdayperc"] == aResult[nAux][7]})

                            // Se achar soma-se as horas
                            If (nPos > 0)
                                jData["detailsofextrahours"][nPos]["businessdayhours"] := __TimeSum(jData["detailsofextrahours"][nPos]["businessdayhours"], aResult[nAux][3])

                            // Caso contrário, procura um registro existente, mas com percentual e horas vazios
                            Else
                                nPos := AScan(jData["detailsofextrahours"], {|x| Empty(x["businessdayperc"]) .and. Empty(x["businessdayhours"])})
                                If (nPos > 0)
                                    jData["detailsofextrahours"][nPos]["businessdayhours"] := aResult[nAux][3]
                                    jData["detailsofextrahours"][nPos]["businessdayperc"]  := aResult[nAux][7]
                                // Senão encontrar o registro, cria um novo
                                Else
                                    AAdd(jData["detailsofextrahours"], {;
                                        "businessdayhours": aResult[nAux][3],;
                                        "businessdayperc":  aResult[nAux][7],;
                                        "holydayhours":     0,;
                                        "timeoffhours":     0,;
                                        "nightdiffhours":   0,;
                                        "holydayperc":      0,;
                                        "timeoffperc":      0,;
                                        "nightdiffperc":    0;
                                    })
                                EndIf
                            EndIf

                        // Horas Feriado
                        ElseIf (aResult[nAux][6] $ "4|G")
                            // Procura um registro que tenha o mesmo percentual que o atual
                            nPos := AScan(jData["detailsofextrahours"], {|x| x["holydayperc"] == aResult[nAux][7]})

                            // Se achar soma-se as horas
                            If (nPos > 0)
                                jData["detailsofextrahours"][nPos]["holydayhours"] := __TimeSum(jData["detailsofextrahours"][nPos]["holydayhours"], aResult[nAux][3])

                            // Caso contrário, procura um registro existente, mas com percentual e horas vazios
                            Else
                                nPos := AScan(jData["detailsofextrahours"], {|x| Empty(x["holydayperc"]) .and. Empty(x["holydayhours"])})
                                If (nPos > 0)
                                    jData["detailsofextrahours"][nPos]["holydayhours"] := aResult[nAux][3]
                                    jData["detailsofextrahours"][nPos]["holydayperc"]  := aResult[nAux][7]
                                // Senão encontrar o registro, cria um novo
                                Else
                                    AAdd(jData["detailsofextrahours"], {;
                                        "businessdayhours": 0,;
                                        "businessdayperc":  0,;
                                        "holydayhours":     aResult[nAux][3],;
                                        "holydayperc":      aResult[nAux][7],;
                                        "timeoffhours":     0,;
                                        "nightdiffhours":   0,;
                                        "timeoffperc":      0,;
                                        "nightdiffperc":    0;
                                    })
                                EndIf
                            EndIf

                        // Horas Descanso/Folga
                        ElseIf (aResult[nAux][6] $ "2|3|C|E")
                            // Procura um registro que tenha o mesmo percentual que o atual
                            nPos := AScan(jData["detailsofextrahours"], {|x| x["timeoffperc"] == aResult[nAux][7]})

                            // Se achar soma-se as horas
                            If (nPos > 0)
                                jData["detailsofextrahours"][nPos]["timeoffhours"] := __TimeSum(jData["detailsofextrahours"][nPos]["timeoffhours"], aResult[nAux][3])

                            // Caso contrário, procura um registro existente, mas com percentual e horas vazios
                            Else
                                nPos := AScan(jData["detailsofextrahours"], {|x| Empty(x["timeoffperc"]) .and. Empty(x["timeoffhours"])})
                                If (nPos > 0)
                                    jData["detailsofextrahours"][nPos]["timeoffhours"] := aResult[nAux][3]
                                    jData["detailsofextrahours"][nPos]["timeoffperc"]  := aResult[nAux][7]
                                // Senão encontrar o registro, cria um novo
                                Else
                                    AAdd(jData["detailsofextrahours"], {;
                                        "businessdayhours": 0,;
                                        "businessdayperc":  0,;
                                        "holydayhours":     0,;
                                        "timeoffhours":     aResult[nAux][3],;
                                        "timeoffperc":      aResult[nAux][7],;
                                        "nightdiffhours":   0,;
                                        "holydayperc":      0,;
                                        "nightdiffperc":    0;
                                    })
                                EndIf
                            EndIf

                        // Horas Adic. Noturno
                        ElseIf (aResult[nAux][6] $ "5|6|7|8|B|D|F|H")
                            // Procura um registro que tenha o mesmo percentual que o atual
                            nPos := AScan(jData["detailsofextrahours"], {|x| x["nightdiffperc"] == aResult[nAux][7]})

                            // Se achar soma-se as horas
                            If (nPos > 0)
                                jData["detailsofextrahours"][nPos]["nightdiffhours"] := __TimeSum(jData["detailsofextrahours"][nPos]["nightdiffhours"], aResult[nAux][3])

                            // Caso contrário, procura um registro existente, mas com percentual e horas vazios
                            Else
                                nPos := AScan(jData["detailsofextrahours"], {|x| Empty(x["nightdiffperc"]) .and. Empty(x["nightdiffhours"])})
                                If (nPos > 0)
                                    jData["detailsofextrahours"][nPos]["nightdiffhours"] := aResult[nAux][3]
                                    jData["detailsofextrahours"][nPos]["nightdiffperc"]  := aResult[nAux][7]
                                // Senão encontrar o registro, cria um novo
                                Else
                                    AAdd(jData["detailsofextrahours"], {;
                                        "businessdayhours": 0,;
                                        "businessdayperc":  0,;
                                        "holydayhours":     0,;
                                        "timeoffhours":     0,;
                                        "nightdiffhours":   aResult[nAux][3],;
                                        "nightdiffperc":    aResult[nAux][7],;
                                        "holydayperc":      0,;
                                        "timeoffperc":      0;
                                    })
                                EndIf
                            EndIf
                        EndIf
                    EndIf
                Next nAux

                // Percorre o detalhamento de horas para conversão de hora
                For nAux := 1 To Len(jData["detailsofhours"])
                    jData["detailsofhours"][nAux]["paidhours"]         := IIf(jData["detailsofhours"][nAux]["paidhours"]         == 0, "0", Replace(StrZero(IIf(!lSexagenal, Round(fConvHr(jData["detailsofhours"][nAux]["paidhours"],         "D", NIL, 5, .T.), 2), jData["detailsofhours"][nAux]["paidhours"]),         5, 2), ".", ":"))
                    jData["detailsofhours"][nAux]["delayhour"]         := IIf(jData["detailsofhours"][nAux]["delayhour"]         == 0, "0", Replace(StrZero(IIf(!lSexagenal, Round(fConvHr(jData["detailsofhours"][nAux]["delayhour"],         "D", NIL, 5, .T.), 2), jData["detailsofhours"][nAux]["delayhour"]),         5, 2), ".", ":"))
                    jData["detailsofhours"][nAux]["absencehours"]      := IIf(jData["detailsofhours"][nAux]["absencehours"]      == 0, "0", Replace(StrZero(IIf(!lSexagenal, Round(fConvHr(jData["detailsofhours"][nAux]["absencehours"],      "D", NIL, 5, .T.), 2), jData["detailsofhours"][nAux]["absencehours"]),      5, 2), ".", ":"))
                    jData["detailsofhours"][nAux]["extrahour"]         := IIf(jData["detailsofhours"][nAux]["extrahour"]         == 0, "0", Replace(StrZero(IIf(!lSexagenal, Round(fConvHr(jData["detailsofhours"][nAux]["extrahour"],         "D", NIL, 5, .T.), 2), jData["detailsofhours"][nAux]["extrahour"]),         5, 2), ".", ":"))
                    jData["detailsofhours"][nAux]["nightdifferential"] := IIf(jData["detailsofhours"][nAux]["nightdifferential"] == 0, "0", Replace(StrZero(IIf(!lSexagenal, Round(fConvHr(jData["detailsofhours"][nAux]["nightdifferential"], "D", NIL, 5, .T.), 2), jData["detailsofhours"][nAux]["nightdifferential"]), 5, 2), ".", ":"))
                    jData["detailsofhours"][nAux]["positivehours"]     := IIf(jData["detailsofhours"][nAux]["positivehours"]     == 0, "0", Replace(StrZero(IIf(!lSexagenal, Round(fConvHr(jData["detailsofhours"][nAux]["positivehours"],     "D", NIL, 5, .T.), 2), jData["detailsofhours"][nAux]["positivehours"]),     5, 2), ".", ":"))
                    jData["detailsofhours"][nAux]["negativehours"]     := IIf(jData["detailsofhours"][nAux]["negativehours"]     == 0, "0", Replace(StrZero(IIf(!lSexagenal, Round(fConvHr(jData["detailsofhours"][nAux]["negativehours"],     "D", NIL, 5, .T.), 2), jData["detailsofhours"][nAux]["negativehours"]),     5, 2), ".", ":"))
                Next nAux

                // Percorre o detalhamento de horas extra para conversão de hora
                For nAux := 1 To Len(jData["detailsofextrahours"])
                    jData["detailsofextrahours"][nAux]["businessdayhours"] := IIf(jData["detailsofextrahours"][nAux]["businessdayhours"] == 0, "0", Replace(StrZero(IIf(!lSexagenal, Round(fConvHr(jData["detailsofextrahours"][nAux]["businessdayhours"], "D", NIL, 5, .T.), 2), jData["detailsofextrahours"][nAux]["businessdayhours"]), 5, 2), ".", ":"))
                    jData["detailsofextrahours"][nAux]["holydayhours"]     := IIf(jData["detailsofextrahours"][nAux]["holydayhours"]     == 0, "0", Replace(StrZero(IIf(!lSexagenal, Round(fConvHr(jData["detailsofextrahours"][nAux]["holydayhours"],     "D", NIL, 5, .T.), 2), jData["detailsofextrahours"][nAux]["holydayhours"]),     5, 2), ".", ":"))
                    jData["detailsofextrahours"][nAux]["timeoffhours"]     := IIf(jData["detailsofextrahours"][nAux]["timeoffhours"]     == 0, "0", Replace(StrZero(IIf(!lSexagenal, Round(fConvHr(jData["detailsofextrahours"][nAux]["timeoffhours"],     "D", NIL, 5, .T.), 2), jData["detailsofextrahours"][nAux]["timeoffhours"]),     5, 2), ".", ":"))
                    jData["detailsofextrahours"][nAux]["nightdiffhours"]   := IIf(jData["detailsofextrahours"][nAux]["nightdiffhours"]   == 0, "0", Replace(StrZero(IIf(!lSexagenal, Round(fConvHr(jData["detailsofextrahours"][nAux]["nightdiffhours"],   "D", NIL, 5, .T.), 2), jData["detailsofextrahours"][nAux]["nightdiffhours"]),   5, 2), ".", ":"))
                Next nAux

                // Adiciona as informações totalizadores do banco de horas
                If (lImpBh .and. Pnr010ImpBh(@nSaldoAnt, @nSaldoAtu, @nCredito, @nDebito, @nTotHrVal, lImpHrVal, dPerIni, dPerFim, lSexagenal))
                    AAdd(jData["timebanksummary"], {;
                        "previousbalancehoursbank": Replace(StrZero(Round(nSaldoAnt, 2), 5, 2),                    ".", ":"),;
                        "periodtimebank":           Replace(StrZero(Round(__TimeSub(nCredito, nDebito), 2), 5, 2), ".", ":"),;
                        "currentbalancehoursbank":  Replace(StrZero(Round(nSaldoAtu, 2), 5, 2),                    ".", ":");
                    })
                EndIf

                // Captura os horários para preencher as trocas de turnos
                aHorarios := GetHorarios(aTabCalend)
                For nAux := 1 To Len(aHorarios)
                    AAdd(jData["shiftchange"], {;
                        "date":        totvs.framework.treports.date.dateToTimeStamp(aHorarios[nAux][1]),;
                        "entrytime_1": IIf(Len(aHorarios[nAux]) >= 3 .and. Len(aHorarios[nAux][3]) >= 1,  cValToChar(aHorarios[nAux][3][1]),  ""),;
                        "exittime_1":  IIf(Len(aHorarios[nAux]) >= 3 .and. Len(aHorarios[nAux][3]) >= 2,  cValToChar(aHorarios[nAux][3][2]),  ""),;
                        "entrytime_2": IIf(Len(aHorarios[nAux]) >= 3 .and. Len(aHorarios[nAux][3]) >= 3,  cValToChar(aHorarios[nAux][3][3]),  ""),;
                        "exittime_2":  IIf(Len(aHorarios[nAux]) >= 3 .and. Len(aHorarios[nAux][3]) >= 4,  cValToChar(aHorarios[nAux][3][4]),  ""),;
                        "entrytime_3": IIf(Len(aHorarios[nAux]) >= 3 .and. Len(aHorarios[nAux][3]) >= 5,  cValToChar(aHorarios[nAux][3][5]),  ""),;
                        "exittime_3":  IIf(Len(aHorarios[nAux]) >= 3 .and. Len(aHorarios[nAux][3]) >= 6,  cValToChar(aHorarios[nAux][3][6]),  ""),;
                        "entrytime_4": IIf(Len(aHorarios[nAux]) >= 3 .and. Len(aHorarios[nAux][3]) >= 7,  cValToChar(aHorarios[nAux][3][7]),  ""),;
                        "exittime_4":  IIf(Len(aHorarios[nAux]) >= 3 .and. Len(aHorarios[nAux][3]) >= 8,  cValToChar(aHorarios[nAux][3][8]),  ""),;
                        "entrytime_5": IIf(Len(aHorarios[nAux]) >= 3 .and. Len(aHorarios[nAux][3]) >= 9,  cValToChar(aHorarios[nAux][3][9]),  ""),;
                        "exittime_5":  IIf(Len(aHorarios[nAux]) >= 3 .and. Len(aHorarios[nAux][3]) >= 10, cValToChar(aHorarios[nAux][3][10]), ""),;
                        "shift":       Trim(aHorarios[nAux][2]);
                    })

                    // Se for o último registro monta a jornada contratual do funcionário com base nele
                    If (nAux == Len(aHorarios))
                        jData["contractualjourney"] += IIf(!Empty(jData["shiftchange"][nAux]["entrytime_1"]) .and. !Empty(jData["shiftchange"][nAux]["exittime_1"]),;
                            AllTrim(Replace(StrZero(Val(jData["shiftchange"][nAux]["entrytime_1"]), 5, 2), ".", ":")) + " a " + AllTrim(Replace(StrZero(Val(jData["shiftchange"][nAux]["exittime_1"]),  5,2), ".", ":")),;
                            "")

                        jData["contractualjourney"] += IIf(!Empty(jData["shiftchange"][nAux]["entrytime_2"]) .and. !Empty(jData["shiftchange"][nAux]["exittime_2"]),;
                            " - " + AllTrim(Replace(StrZero(Val(jData["shiftchange"][nAux]["entrytime_2"]), 5, 2), ".", ":")) + " a " + AllTrim(Replace(StrZero(Val(jData["shiftchange"][nAux]["exittime_2"]),  5,2), ".", ":")),;
                            "")

                        jData["contractualjourney"] += IIf(!Empty(jData["shiftchange"][nAux]["entrytime_3"]) .and. !Empty(jData["shiftchange"][nAux]["exittime_3"]),;
                            " - " + AllTrim(Replace(StrZero(Val(jData["shiftchange"][nAux]["entrytime_3"]), 5, 2), ".", ":")) + " a " + AllTrim(Replace(StrZero(Val(jData["shiftchange"][nAux]["exittime_3"]),  5,2), ".", ":")),;
                            "")

                        jData["contractualjourney"] += IIf(!Empty(jData["shiftchange"][nAux]["entrytime_4"]) .and. !Empty(jData["shiftchange"][nAux]["exittime_4"]),;
                            " - " + AllTrim(Replace(StrZero(Val(jData["shiftchange"][nAux]["entrytime_4"]), 5, 2), ".", ":")) + " a " + AllTrim(Replace(StrZero(Val(jData["shiftchange"][nAux]["exittime_4"]),  5,2), ".", ":")),;
                            "")

                        jData["contractualjourney"] += IIf(!Empty(jData["shiftchange"][nAux]["entrytime_5"]) .and. !Empty(jData["shiftchange"][nAux]["exittime_5"]),;
                            " - " + AllTrim(Replace(StrZero(Val(jData["shiftchange"][nAux]["entrytime_5"]), 5, 2), ".", ":")) + " a " + AllTrim(Replace(Round(Val(jData["shiftchange"][nAux]["exittime_5"]), 2), ".", ":")),;
                            "")
                    EndIf
                Next nAux

                // Preenche os dados de totais do período
                For nAux := 1 To Len(aTotais)
                    AAdd(jData["periodtotals"], {;
                        "code":          aTotais[nAux][1],;
                        "description":   aTotais[nAux][2],;
                        "calculedhours": AllTrim(Replace(Str(Val(Replace(aTotais[nAux][3], ",", ".")), 10, 2), ".", ":")),;
                        "informedhours": AllTrim(Replace(Str(Val(Replace(aTotais[nAux][4], ",", ".")), 10, 2), ".", ":"));
                    })
                Next nAux

                // Adiciona os campos customizados no JSON
                GPESmartViewUtils():SetCustomFields(aAllFields, jData, cAlias, aPDFields, lObfuscated)

                // Adiciona o registro no vetor de registros do objeto de negócio
                self:oData:appendData(jData)

                // Realiza a integração com o TAE
                If (lTAE)
                    IntegTAE(jParams, cFile, lMRHTae, dPerIni, dPerFim, cCodeBar, dMarcIni, dMarcFim)
                EndIf

                // Reinicializa as variáveis
                aImp      := {}
                aTotais   := {}
                aAbonados := {}
            Next nPeriodos

            (cAlias)->(DBSkip())
        End

        // Fecha a área do alias temporário
        (cAlias)->(DBCloseArea())
    END SEQUENCE

    // Limpa os objetos e vetores da 
    jData := NIL
    FwFreeObj(jData)
    FwFreeObj(jLGPD)
    FwFreeObj(jParams)
    FwFreeObj(oStatement)
    FwFreeObj(oSign)
    FwFreeArray(aEmployeeSituation)
    FwFreeArray(aEmployeeCategory)
    FwFreeArray(aAbonosPer)
    FwFreeArray(aImp)
    FwFreeArray(aTotais)
    FwFreeArray(aAbonados)
    FwFreeArray(aAfast)
    FwFreeArray(aInfo)
    FwFreeArray(aTurnos)
    FwFreeArray(aPrtTurn)
    FwFreeArray(aMarcacoes)
    FwFreeArray(aMarcDes)
    FwFreeArray(aTabPadrao)
    FwFreeArray(aTabCalend)
    FwFreeArray(aPeriodos)
    FwFreeArray(aId)
    FwFreeArray(aResult)
    FwFreeArray(aBoxSPC)
    FwFreeArray(aCodAut)
    FwFreeArray(aAllFields)
    FwFreeArray(aPDFields)
Return self:oData

/*/{Protheus.doc} PONR010TReportsBusinessObject:getSchema()
    Define o schema do objeto de negócio.
    @type Method
    @version 12.1.2310
    @author arthur.sales
    @since 23/04/2024
    @return Object, Schema do objeto de negócio
/*/
Method getSchema() As Object Class PONR010TReportsBusinessObject
    // Declaração das variáveis locais
    Local aFields As Array // Campos da nested property

    // Inicialização das variáveis
    aFields := {}

    // Define os parâmetros do relatório
    self:oSchema:addParameter("DateFrom",           STR0006, "date",    .F.) // "Data De"
    self:oSchema:addParameter("DateTo",             STR0007, "date",    .F.) // "Data Até"
    self:oSchema:addParameter("BranchCodeFrom",     STR0008, "string",  .F.) // "Filial De"
    self:oSchema:addParameter("BranchCodeTo",       STR0009, "string",  .F.) // "Filial Até"
    self:oSchema:addParameter("CostCenterCodeFrom", STR0010, "string",  .F.) // "C.C. De"
    self:oSchema:addParameter("CostCenterCodeTo",   STR0011, "string",  .F.) // "C.C. Até"
    self:oSchema:addParameter("ShiftCodeFrom",      STR0012, "string",  .F.) // "Turno De"
    self:oSchema:addParameter("ShiftCodeTo",        STR0013, "string",  .F.) // "Turno Até"
    self:oSchema:addParameter("EmployeeCodeFrom",   STR0014, "string",  .F.) // "Matrícula De"
    self:oSchema:addParameter("EmployeeCodeTo",     STR0015, "string",  .F.) // "Matrícula Até"
    self:oSchema:addParameter("NameFrom",           STR0016, "string",  .F.) // "Nome De"
    self:oSchema:addParameter("NameTo",             STR0017, "string",  .F.) // "Nome Até"
    self:oSchema:addParameter("DepartmentFrom",     STR0018, "string",  .F.) // "Departamento De"
    self:oSchema:addParameter("DepartmentTo",       STR0019, "string",  .F.) // "Departamento Até"
    self:oSchema:addParameter("EmployeeRuleFrom",   STR0020, "string",  .F.) // "Regra De"
    self:oSchema:addParameter("EmployeeRuleTo",     STR0021, "string",  .F.) // "Regra Até"
    self:oSchema:addParameter("EmployeeSituation",  STR0022, "string",  .T.) // "Situações"
    self:oSchema:addParameter("EmployeeCategory",   STR0023, "string",  .T.) // "Categorias"
    self:oSchema:addParameter("PrintHours",         STR0024, "string",  .F.) // "Imprime Horas" | Opções: Calculadas | Informadas | Ambas | N/A
    self:oSchema:addParameter("ShowHours",          STR0025, "string",  .F.) // "Demonstra Horas" | Opções: Autorizadas | Não autorizadas | Ambas
    self:oSchema:addParameter("WithoutPunch",       STR0026, "boolean", .F.) // "Func. sem marc."
    self:oSchema:addParameter("HoursType",          STR0027, "string",  .F.) // "Horas em" | Opções: Sexagesimal | Centesimal
    self:oSchema:addParameter("PrintEvents",        STR0028, "boolean", .F.) // "Eventos do result."
    self:oSchema:addParameter("PrintException",     STR0029, "boolean", .F.) // "Desc. Exceção afast."
    self:oSchema:addParameter("PrintHoursBank",     STR0030, "boolean", .F.) // "Imp. banco horas"
    self:oSchema:addParameter("PrintExtraHour",     STR0031, "boolean", .F.) // "Imp. horas extras"
    self:oSchema:addParameter("PrintDisreg",        STR0100, "boolean", .F.) // "Imp. marc. desconsideradas"
    self:oSchema:addParameter("TAEIntegration",     STR0032, "boolean", .F.) // "Integra c/ TAE"

    // Define endpoints dos parâmetros de tipo lookup/combobox
    self:setCustomURL("BranchCodeFrom",     "/api/rh/smartview/v1/options/GPEParams/getBranches",   2)
    self:setCustomURL("BranchCodeTo",       "/api/rh/smartview/v1/options/GPEParams/getBranches",   2)
    self:setCustomURL("CostCenterCodeFrom", "/api/framework/v1/genericLookupService/smartview/CTT", 2)
    self:setCustomURL("CostCenterCodeTo",   "/api/framework/v1/genericLookupService/smartview/CTT", 2)
    self:setCustomURL("ShiftCodeFrom",      "/api/framework/v1/genericLookupService/smartview/SR6", 2)
    self:setCustomURL("ShiftCodeTo",        "/api/framework/v1/genericLookupService/smartview/SR6", 2)
    self:setCustomURL("EmployeeCodeFrom",   "/api/framework/v1/genericLookupService/smartview/SRA", 2)
    self:setCustomURL("EmployeeCodeTo",     "/api/framework/v1/genericLookupService/smartview/SRA", 2)
    self:setCustomURL("DepartmentFrom",     "/api/framework/v1/genericLookupService/smartview/SQB", 2)
    self:setCustomURL("DepartmentTo",       "/api/framework/v1/genericLookupService/smartview/SQB", 2)
    self:setCustomURL("EmployeeRuleFrom",   "/api/framework/v1/genericLookupService/smartview/SPA", 2)
    self:setCustomURL("EmployeeRuleTo",     "/api/framework/v1/genericLookupService/smartview/SPA", 2)
    self:setCustomURL("EmployeeSituation",  "/api/rh/smartview/v1/options/GPEParams/getSX5/31",     2)
    self:setCustomURL("EmployeeCategory",   "/api/rh/smartview/v1/options/GPEParams/getSX5/28",     2)
    self:setCustomURL("PrintHours",         "/api/rh/smartview/v1/options/PONR010/PrintHours",      1)
    self:setCustomURL("ShowHours",          "/api/rh/smartview/v1/options/PONR010/ShowHours",       1)
    self:setCustomURL("HoursType",          "/api/rh/smartview/v1/options/PONR010/HoursType",       1)

    // Adiciona as propriedades do objeto de negócio
    self:oSchema:addProperty("companyname",        STR0033, "string", STR0033, "companyname",  NIL, NIL, NIL, .F.) // "Nome da Empresa"
    self:oSchema:addProperty("companycnpj",        STR0034, "string", STR0034, "companycnpj",  NIL, NIL, NIL, .F.) // "CNPJ/CPF da Empresa"
    self:oSchema:addProperty("branchname",         STR0035, "string", STR0035, "branchname",   NIL, NIL, NIL, .F.) // "Estabelecimento (Filial)"
    self:oSchema:addProperty("socialname",         STR0036, "string", STR0036, "RA_NSOCIAL",   NIL, NIL, NIL, .F.) // "Nome Social"
    self:oSchema:addProperty("employeename",       STR0037, "string", STR0037, "RA_NOME",      NIL, NIL, NIL, .F.) // "Nome da Pessoa Colaboradora"
    self:oSchema:addProperty("employeecpf",        STR0038, "string", STR0038, "RA_CIC",       NIL, NIL, NIL, .F.) // "CPF da Pessoa Colaboradora"
    self:oSchema:addProperty("employeecode",       STR0039, "string", STR0039, "RA_MAT",       NIL, NIL, NIL, .F.) // "Matrícula da Pessoa Colaboradora"
    self:oSchema:addProperty("office",             STR0040, "string", STR0040, "RA_FUNCAO",    NIL, NIL, NIL, .F.) // "Cargo da Pessoa Colaboradora"
    self:oSchema:addProperty("admissiondate",      STR0041, "date",   STR0041, "RA_ADMISSA",   NIL, NIL, NIL, .F.) // "Dt. Admis. da Pessoa Colaboradora"
    self:oSchema:addProperty("contractualjourney", STR0042, "string", STR0042, "RA_HRSMES",    NIL, NIL, NIL, .F.) // "Jornada da Pessoa Colaboradora"
    self:oSchema:addProperty("perioddate",         STR0043, "string", STR0043, "perioddate",   NIL, NIL, NIL, .F.) // "Período do ponto"
    self:oSchema:addProperty("barcode",            STR0044, "string", STR0044, "barcode",      NIL, NIL, NIL, .F.) // "Código de barras"

    // Adiciona a nested property timebanksummary
    AAdd(aFields, {"previousbalancehoursbank", STR0045, "string", STR0045})   // "Saldo anterior banco de horas"
    AAdd(aFields, {"periodtimebank",           STR0046, "string", STR0046})   // "Banco de horas do período"
    AAdd(aFields, {"currentbalancehoursbank",  STR0047, "string", STR0047})   // "Saldo atual do banco de horas"
    self:addNestedProperty("timebanksummary", STR0048, STR0048, NIL, aFields) // "Resumo do banco de horas"

    // Adiciona a nested property registeredmarks
    aFields := {}
    AAdd(aFields, {"date",          STR0049,        "date",   STR0049})        // "Data"
    AAdd(aFields, {"day",           STR0050,        "string", STR0050})        // "Dia"
    AAdd(aFields, {"entrytime_1",   STR0051 + " 1", "string", STR0051 + " 1"}) // "Entrada 1"
    AAdd(aFields, {"exittime_1",    STR0052 + " 1", "string", STR0052 + " 1"}) // "Saída 1"
    AAdd(aFields, {"entrytime_2",   STR0051 + " 2", "string", STR0051 + " 2"}) // "Entrada 2"
    AAdd(aFields, {"exittime_2",    STR0052 + " 2", "string", STR0052 + " 2"}) // "Saída 2"
    AAdd(aFields, {"entrytime_3",   STR0051 + " 3", "string", STR0051 + " 3"}) // "Entrada 3"
    AAdd(aFields, {"exittime_3",    STR0052 + " 3", "string", STR0052 + " 3"}) // "Saída 3"
    AAdd(aFields, {"entrytime_4",   STR0051 + " 4", "string", STR0051 + " 4"}) // "Entrada 4"
    AAdd(aFields, {"exittime_4",    STR0052 + " 4", "string", STR0052 + " 4"}) // "Saída 4"
    AAdd(aFields, {"entrytime_5",   STR0051 + " 5", "string", STR0051 + " 5"}) // "Entrada 5"
    AAdd(aFields, {"exittime_5",    STR0052 + " 5", "string", STR0052 + " 5"}) // "Saída 5"
    AAdd(aFields, {"total",         STR0053,        "string", STR0053})        // "T. horas"
    AAdd(aFields, {"justification", STR0054,        "string", STR0054})        // "Justificativa"
    self:addNestedProperty("registeredmarks", STR0056, STR0056, NIL, aFields)  // "Marcações registradas"

    // Adiciona a nested property detailsofhours
    aFields := {}
    AAdd(aFields, {"date",              STR0049, "date",   STR0049})         // "Data"
    AAdd(aFields, {"day",               STR0050, "string", STR0050})         // "Dia"
    AAdd(aFields, {"paidhours",         STR0057, "string", STR0057})         // "Horas abonadas"
    AAdd(aFields, {"delayhour",         STR0058, "string", STR0058})         // "Horas de atraso"
    AAdd(aFields, {"absencehours",      STR0059, "string", STR0059})         // "Horas de falta"
    AAdd(aFields, {"extrahour",         STR0060, "string", STR0060})         // "Horas extras"
    AAdd(aFields, {"nightdifferential", STR0061, "string", STR0061})         // "Horas adic. not."
    AAdd(aFields, {"positivehours",     STR0062, "string", STR0062})         // "B. de Horas (+)"
    AAdd(aFields, {"negativehours",     STR0063, "string", STR0063})         // "B. de Horas (-)"
    AAdd(aFields, {"justification",     STR0054, "string", STR0054})         // "Justificativa"
    self:addNestedProperty("detailsofhours", STR0064, STR0064, NIL, aFields) // "Detalhamento de horas"

    // Adiciona a nested property shiftchange
    aFields := {}
    AAdd(aFields, {"date",          STR0049,        "date",   STR0049})
    AAdd(aFields, {"entrytime_1",   STR0051 + " 1", "string", STR0051 + " 1"}) // "Entrada 1"
    AAdd(aFields, {"exittime_1",    STR0052 + " 1", "string", STR0052 + " 1"}) // "Saída 1"
    AAdd(aFields, {"entrytime_2",   STR0051 + " 2", "string", STR0051 + " 2"}) // "Entrada 2"
    AAdd(aFields, {"exittime_2",    STR0052 + " 2", "string", STR0052 + " 2"}) // "Saída 2"
    AAdd(aFields, {"entrytime_3",   STR0051 + " 3", "string", STR0051 + " 3"}) // "Entrada 3"
    AAdd(aFields, {"exittime_3",    STR0052 + " 3", "string", STR0052 + " 3"}) // "Saída 3"
    AAdd(aFields, {"entrytime_4",   STR0051 + " 4", "string", STR0051 + " 4"}) // "Entrada 4"
    AAdd(aFields, {"exittime_4",    STR0052 + " 4", "string", STR0052 + " 4"}) // "Saída 4"
    AAdd(aFields, {"entrytime_5",   STR0051 + " 5", "string", STR0051 + " 5"}) // "Entrada 5"
    AAdd(aFields, {"exittime_5",    STR0052 + " 5", "string", STR0052 + " 5"}) // "Saída 5"
    AAdd(aFields, {"shift",         STR0065,         "string", STR0065})       // "Turno"
    self:addNestedProperty("shiftchange", STR0066, STR0066, NIL, aFields)      // "Trocas de Turnos"

    // Adiciona a nested property detailsofextrahours
    aFields := {}
    AAdd(aFields, {"businessdayhours",  STR0067, "string", STR0067})              // "Horas de dias úteis"
    AAdd(aFields, {"holydayhours",      STR0068, "string", STR0068})              // "Horas de feriado"
    AAdd(aFields, {"timeoffhours",      STR0069, "string", STR0069})              // "Horas de descanso"
    AAdd(aFields, {"nightdiffhours",    STR0070, "string", STR0070})              // "Horas adic. not."
    AAdd(aFields, {"businessdayperc",   STR0071, "number", STR0071})              // "Perc. de dias úteis"
    AAdd(aFields, {"holydayperc",       STR0072, "number", STR0072})              // "Perc. de feriado"
    AAdd(aFields, {"timeoffperc",       STR0073, "number", STR0073})              // "Perc. de descanso"
    AAdd(aFields, {"nightdiffperc",     STR0074, "number", STR0074})              // "Perc. adic. not."
    self:addNestedProperty("detailsofextrahours", STR0075, STR0075, NIL, aFields) // "Detalhamento de horas extra"

    // Adiciona a nested property periodtotals
    aFields := {}
    AAdd(aFields, {"code",          STR0101,  "string", STR0101})          // "Código"
    AAdd(aFields, {"description",   STR0102,  "string", STR0102})          // "Descrição"
    AAdd(aFields, {"informedhours", STR0103,  "string", STR0103})          // "Horas Informadas"
    AAdd(aFields, {"calculedhours", STR0104,  "string", STR0104})          // "Horas Calculadas"
    self:addNestedProperty("periodtotals", STR0105, STR0105, NIL, aFields) // "Totais do Período"

    // Adiciona a nested property unregisteredmarks
    aFields := {}
    AAdd(aFields, {"date",   STR0049, "date",   STR0049})                       // "Data"
    AAdd(aFields, {"day",    STR0050, "string", STR0050})                       // "Dia"
    AAdd(aFields, {"time",   STR0106, "string", STR0106})                       // "Hora da marcação"
    AAdd(aFields, {"motive", STR0107, "string", STR0107})                       // "Motivo"
    self:addNestedProperty("unregisteredmarks", STR0108, STR0108, NIL, aFields) // "Marcações desconsideradas"
Return self:oSchema

/*
    ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
    ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
    ±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
    ±±³Funo    ³ CarId    ³ Autor ³ Mauricio MR           ³ Data ³ 24/05/02 ³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³Descrio ³ Retorna Relacao de Eventos da Filial                       ³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³Parametros³ cFil       --> Codigo da Filial desejada                   ³±±
    ±±³          ³ aId        --> Array com a Relacao                         ³±±
    ±±³          ³ cAutoriza  --> "*" Horas Autorizadas/Nao Autorizadas       ³±±
    ±±³          ³                "A" Horas Autorizadas                       ³±±
    ±±³          ³                "N" Horas Nao Autorizadas                   ³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³ Uso      ³ PONM010                                                    ³±±
    ±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
    ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
    ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function CarId(cFil, aId, cAutoriza)
    Local nPos := 0

    // Preenche o Array aCodAut com os Eventos (Menos DSR Mes Ant.)
    SP9->(MsSeek(cFil, .T.))
    While SP9->(!EOF() .and. cFil == P9_FILIAL)
        If ((Right(SP9->P9_IDPON,1) == cAutoriza) .or. (cAutoriza == "*"))
            AAdd(aId, Array(04))
            nPos := Len(aId)
            aId[nPos, 01] := SP9->P9_CODIGO  // Codigo do Evento
            aId[nPos, 02] := SP9->P9_IDPON   // Identificador do Ponto
            aId[nPos, 03] := SP9->P9_CODFOL  // Codigo do da Verba Folha
            aId[nPos, 04] := SP9->P9_BHORAS  // Evento para B.Horas
        EndIf

        SP9->(DBSkip())
    End
Return NIL

/*/
    ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
    ±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
    ±±³Funo    ³fGetApo   ³ Autor ³ Leandro Dr.           ³ Data ³ 23.03.15 ³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³Descrio ³ Retorna Apontamentos do funcionario.                       ³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³ Uso      ³ Ponr010                                                    ³±±
    ±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
    ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
    ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/
*/
Static Function fGetApo(aResult,dInicio,dFim,lImpAcum, aTabCalend, aMarcacoes, lPort671, nImpAut, aCodAut)
    Local aArea       := GetArea()
    Local cQuery      := ""
    Local cAliasQry   := ""
    Local cWhere      := ""
    Local cPrefixo    := If(lImpAcum,"PH_","PC_")
    Local cJoinFil    := ""
    Local cJoinSPI    := ""
    Local cJoinSP6    := ""
    Local cAutoriza   := If(nImpAut == 1, "A", If(nImpAut == 2, "N", "*"))
    Local aEvtDesc    := {}
    Local aEvtHe      := {}
    Local lSomaValo   := .T.
    Local nCont       := 0
    Local nParamOrder := 1
    Local nPos        := 0
    Local dLastApo    := CToD("//")
    Local oStatement  := NIL

    //Carrega tabela de Eventos do Tipo de Hora Extra
    cWhere += cPrefixo + "FILIAL =  ? AND " // 6
    cWhere += cPrefixo + "MAT    =  ? AND " // 7
    cWhere += cPrefixo + "DATA   >= ? AND " // 8
    cWhere += cPrefixo + "DATA   <= ? "     // 9

    If lImpAcum
        cJoinFil := FwJoinFilial("SPH", "SP9")
        cJoinSPI := FwJoinFilial("SPH", "SPI")
        cJoinSP6 := FwJoinFilial("SPH", "SP6")

        cQuery += "SELECT "
        cQuery +=     "PH_DATA, "
        cQuery +=     "PH_PD, "
        cQuery +=     "PH_TPMARCA, "
        cQuery +=     "PH_PDI, "
        cQuery +=     "PH_QUANTC, "
        cQuery +=     "PH_QUANTI, "
        cQuery +=     "P9_CLASEV, "
        cQuery +=     "P9_IDPON, "
        cQuery +=     "P6_CODIGO, "
        cQuery +=     "P6_EVENTO, "
        cQuery +=     "PI_QUANTV, "
        cQuery +=     "P9_DESC, "
        cQuery +=     "PH_PERCENT, "
        cQuery +=     "PH_TIPOHE "
        cQuery += "FROM "
        cQuery +=     RetSQLName("SPH") + " SPH "
        cQuery +=     "INNER JOIN "
        cQuery +=         RetSQLName("SP9") + " SP9 "
        cQuery +=         "ON "
        cQuery +=             cJoinFil + " "
        cQuery +=             "AND P9_CODIGO = (CASE WHEN PH_PDI <> ? THEN PH_PDI ELSE PH_PD END) " // 1
        cQuery +=             "AND SP9.D_E_L_E_T_ = ? " // 2
        cQuery +=     "LEFT JOIN "
        cQuery +=         RetSQLName("SP6") + " SP6 "
        cQuery +=         "ON "
        cQuery +=             cJoinSP6 + " "
        cQuery +=             "AND P6_CODIGO = PH_ABONO "
        cQuery +=             "AND SP6.D_E_L_E_T_ = ? " // 3
        cQuery +=     "LEFT JOIN "
        cQuery +=         RetSQLName("SPI") + " SPI "
        cQuery +=         "ON "
        cQuery +=             cJoinSPI + " "
        cQuery +=             "AND PH_MAT = PI_MAT "
        cQuery +=             "AND (
        cQuery +=                      "PI_PD = (CASE WHEN PH_PDI <> ? THEN PH_PDI ELSE PH_PD END) " // 4
        cQuery +=                      "OR PI_PD = P6_EVENTO "
        cQuery +=                  ") "
        cQuery +=             "AND PI_DATA = PH_DATA "
        cQuery +=             "AND SPI.D_E_L_E_T_ = ? " // 5
        cQuery += "WHERE "
        cQuery +=     cWhere + " "
        cQuery +=     "AND SPH.D_E_L_E_T_ = ? " // 10
        cQuery += "ORDER BY "
        cQuery +=     "PH_DATA, "
        cQuery +=     "PH_PD "
    Else
        cJoinFil := FwJoinFilial("SPC", "SP9")
        cJoinSPI := FwJoinFilial("SPC", "SPI")
        cJoinSP6 := FwJoinFilial("SPC", "SP6")

        cQuery += "SELECT "
        cQuery +=     "PC_DATA, "
        cQuery +=     "PC_PD, "
        cQuery +=     "PC_TPMARCA, "
        cQuery +=     "PC_PDI, "
        cQuery +=     "PC_QUANTC, "
        cQuery +=     "PC_QUANTI, "
        cQuery +=     "P9_CLASEV, "
        cQuery +=     "P9_IDPON, "
        cQuery +=     "P6_CODIGO, "
        cQuery +=     "P6_EVENTO, "
        cQuery +=     "PI_QUANTV, "
        cQuery +=     "P9_DESC, "
        cQuery +=     "PC_PERCENT, "
        cQuery +=     "PC_TIPOHE "
        cQuery += "FROM "
        cQuery +=     RetSQLName("SPC") + " SPC "
        cQuery +=     "INNER JOIN "
        cQuery +=         RetSQLName("SP9") + " SP9 "
        cQuery +=         "ON "
        cQuery +=             cJoinFil + " "
        cQuery +=             "AND P9_CODIGO = (CASE WHEN PC_PDI <> ? THEN PC_PDI ELSE PC_PD END) " // 1
        cQuery +=             "AND SP9.D_E_L_E_T_ = ? " // 2
        cQuery +=     "LEFT JOIN "
        cQuery +=         RetSQLName("SP6") + " SP6 "
        cQuery +=         "ON "
        cQuery +=             cJoinSP6 + " "
        cQuery +=             "AND P6_CODIGO = PC_ABONO "
        cQuery +=             "AND SP6.D_E_L_E_T_ = ? " // 3
        cQuery +=     "LEFT JOIN "
        cQuery +=         RetSQLName("SPI") + " SPI "
        cQuery +=         "ON "
        cQuery +=             cJoinSPI + " "
        cQuery +=             "AND PC_MAT = PI_MAT "
        cQuery +=             "AND (
        cQuery +=                      "PI_PD = (CASE WHEN PC_PDI <> ? THEN PC_PDI ELSE PC_PD END) " // 4
        cQuery +=                      "OR PI_PD = P6_EVENTO "
        cQuery +=                  ") "
        cQuery +=             "AND PI_DATA = PC_DATA "
        cQuery +=             "AND SPI.D_E_L_E_T_ = ? " // 5
        cQuery += "WHERE "
        cQuery +=     cWhere + " "
        cQuery +=     "AND SPC.D_E_L_E_T_ = ? " // 10
        cQuery += "ORDER BY "
        cQuery +=     "PC_DATA, "
        cQuery +=     "PC_PD "
    EndIf

    cQuery := ChangeQuery(cQuery)
    oStatement := FwExecStatement():New(cQuery)

    // Define o valor dos bind parameters
    oStatement:SetString(nParamOrder++, " ")            // 1
    oStatement:SetString(nParamOrder++, " ")            // 2
    oStatement:SetString(nParamOrder++, " ")            // 3
    oStatement:SetString(nParamOrder++, " ")            // 4
    oStatement:SetString(nParamOrder++, " ")            // 5
    oStatement:SetString(nParamOrder++, SRA->RA_FILIAL) // 6
    oStatement:SetString(nParamOrder++, SRA->RA_MAT)    // 7
    oStatement:SetDate(nParamOrder++,   dInicio)        // 8
    oStatement:SetDate(nParamOrder++,   dFim)           // 9
    oStatement:SetString(nParamOrder++, " ")            // 10

    // Executa a query e retorna o alias criado
    cAliasQry := oStatement:OpenAlias()

    While !(cAliasQry)->(EOF())
        // Hora Extra
        If (cAliasQry)->P9_CLASEV == "01"
            // Busca o tipo de hora extra
            nPos    := (cAliasQry)->(AScan(aCodAut, {|x| x[3] == IIf(Empty((&(cPrefixo + "PDI"))), (&(cPrefixo + "PD")), (&(cPrefixo + "PDI")))}))
            cHEType := IIf(nPos > 0 .and. Len(aCodAut[nPos]) >= 5, Trim(aCodAut[nPos][5]), "")

            If (cAliasQry)->PI_QUANTV > 0
                (cAliasQry)->(lSomaValo := AScan(aEvtHe, {|x| x[1] == &(cPrefixo + "DATA") .and. x[4] == &(cPrefixo + "PD")}) == 0) // Mesmo evento no mesmo dia
            EndIf

            // Filtra hora extra de acordo com tipo selecionado no parâmetro MV_PAR14 (Autorizada/Não autorizada)
            If cAutoriza == '*' .or. (cAutoriza != 'N' .and. (cAliasQry)->P9_IDPON == "029A")  // Tratamento incluido para considerar InterJornada no Relatório.
                If (cAliasQry)->(AScan(aEvtHe, {|x| x[1] == &(cPrefixo + "DATA") .and. x[2] == IIf(&(cPrefixo + "QUANTI") > 0, &(cPrefixo + "QUANTI"), &(cPrefixo + "QUANTC")) .and. x[3] == &(cPrefixo + "TPMARCA") .and. x[4] == &(cPrefixo + "PD")}) > 0)
                    (cAliasQry)->(AAdd(aResult, {&(cPrefixo + "DATA"), P9_CLASEV, 0, IIf(PI_QUANTV > 0 .and. lSomaValo, PI_QUANTV, ""), AllTrim(P9_DESC), &(cPrefixo + "TIPOHE"), &(cPrefixo + "PERCENT")}))
                Else
                    (cAliasQry)->(AAdd(aResult, {&(cPrefixo + "DATA"), P9_CLASEV, IIf(&(cPrefixo + "QUANTI") > 0, &(cPrefixo + "QUANTI"), &(cPrefixo + "QUANTC")), IIf(PI_QUANTV > 0 .and. lSomaValo, PI_QUANTV, ""), AllTrim(P9_DESC), &(cPrefixo + "TIPOHE"), &(cPrefixo + "PERCENT")}))
                    (cAliasQry)->(AAdd(aEvtHe, {&(cPrefixo + "DATA"), IIf(&(cPrefixo + "QUANTI") > 0, &(cPrefixo + "QUANTI"), &(cPrefixo + "QUANTC")), &(cPrefixo + "TPMARCA"), &(cPrefixo + "PD")}))
                EndIf
            ElseIf (cAliasQry)->(AScan(aCodAut, {|x| x[3] == IIf(Empty((&(cPrefixo + "PDI"))), (&(cPrefixo + "PD")), (&(cPrefixo + "PDI"))) .and. x[4] == cAutoriza}) > 0)
                If (cAliasQry)->(AScan(aEvtHe, {|x| x[1] == &(cPrefixo + "DATA") .and. x[2] == IIf(&(cPrefixo + "QUANTI") > 0, &(cPrefixo + "QUANTI"), &(cPrefixo + "QUANTC")) .and. x[3] == &(cPrefixo + "TPMARCA") .and. x[4] == &(cPrefixo + "PD")}) > 0)
                    (cAliasQry)->(AAdd(aResult, {&(cPrefixo + "DATA"), "1", 0, IIf(PI_QUANTV > 0 .and. lSomaValo, PI_QUANTV, ""), AllTrim(P9_DESC), &(cPrefixo + "TIPOHE"), &(cPrefixo + "PERCENT")}))
                Else
                    (cAliasQry)->(AAdd(aResult, {&(cPrefixo + "DATA"), P9_CLASEV, IIf(&(cPrefixo + "QUANTI") > 0, &(cPrefixo + "QUANTI"), &(cPrefixo + "QUANTC")), IIf(PI_QUANTV > 0 .and. lSomaValo, PI_QUANTV, ""), AllTrim(P9_DESC), &(cPrefixo + "TIPOHE"), &(cPrefixo + "PERCENT")}))
                    (cAliasQry)->(AAdd(aEvtHe, {&(cPrefixo + "DATA"), IIf(&(cPrefixo + "QUANTI") > 0, &(cPrefixo + "QUANTI"), &(cPrefixo + "QUANTC")), &(cPrefixo + "TPMARCA"), &(cPrefixo + "PD")}))
                EndIf
            EndIf

        // Faltas/Atrasos/Saida antecipada
        ElseIf (cAliasQry)->P9_CLASEV $ "02*03*04*05"
            If (cAliasQry)->(cAutoriza == '*' .or. Empty(P9_IDPON) .or. Right(P9_IDPON, 1) == cAutoriza)
                If (cAliasQry)->(AScan(aEvtDesc, {|x| x[1] == &(cPrefixo + "DATA") .and. x[2] == IIf(&(cPrefixo + "QUANTI") > 0, &(cPrefixo + "QUANTI"), &(cPrefixo + "QUANTC")) .and. x[3] == &(cPrefixo + "TPMARCA") .and. x[6] == &(cPrefixo + "PD")}) > 0)
                    (cAliasQry)->(AAdd(aResult, {&(cPrefixo + "DATA"), P9_CLASEV,0, IIf(PI_QUANTV > 0, PI_QUANTV, ""), AllTrim(P9_DESC), "", 0}))
                Else
                    If (cAliasQry)->PI_QUANTV > 0
                        (cAliasQry)->(lSomaValo := AScan(aEvtDesc, {|x| x[1] == &(cPrefixo + "DATA") .and. x[4] == &("P6_EVENTO") .and. x[5] == PI_QUANTV}) == 0)
                    EndIf

                    (cAliasQry)->(AAdd(aResult, {&(cPrefixo + "DATA"), P9_CLASEV, IIf(&(cPrefixo + "QUANTI") > 0, &(cPrefixo + "QUANTI"), &(cPrefixo + "QUANTC")), IIf(PI_QUANTV > 0 .and. lSomaValo, PI_QUANTV, ""), AllTrim(P9_DESC), "", 0}))
                    (cAliasQry)->(AAdd(aEvtDesc, {&(cPrefixo + "DATA"), IIf(&(cPrefixo + "QUANTI") > 0, &(cPrefixo + "QUANTI"), &(cPrefixo + "QUANTC")), &(cPrefixo + "TPMARCA"), &("P6_EVENTO"), PI_QUANTV, &(cPrefixo + "PD")}))
                EndIf
            EndIf

        // Adicional Noturno
        ElseIf (cAliasQry)->(P9_IDPON $ "003N*004A*027N*028A*045A*046A" .or. P9_CLASEV == "06")
            // Filtra adicional noturno de acordo com tipo selecionado no parâmetro MV_PAR14 (Autorizada/ Não autorizada)
            If cAutoriza == '*'
                (cAliasQry)->(AAdd(aResult, {&(cPrefixo + "DATA"), "AdicNot" + AllTrim(P9_IDPON), IIf(&(cPrefixo + "QUANTI") > 0, &(cPrefixo + "QUANTI"), &(cPrefixo + "QUANTC")), IIf(PI_QUANTV > 0, PI_QUANTV, ""), AllTrim(P9_DESC), "", 0}))
            ElseIf cAutoriza == 'A'
                If (cAliasQry)->(P9_IDPON $ "004A*028A" .or. (Empty(P9_IDPON) .and. P9_CLASEV == "06"))
                    (cAliasQry)->(AAdd(aResult, {&(cPrefixo + "DATA"), "AdicNot" + AllTrim(P9_IDPON), IIf(&(cPrefixo + "QUANTI") > 0, &(cPrefixo + "QUANTI"), &(cPrefixo + "QUANTC")), IIf(PI_QUANTV > 0, PI_QUANTV, ""), AllTrim(P9_DESC), "", 0}))
                EndIf
            Else
                If (cAliasQry)->(P9_IDPON $ "003N*027N" .or. (Empty(P9_IDPON) .and. P9_CLASEV == "06"))
                    (cAliasQry)->(AAdd(aResult, {&(cPrefixo + "DATA"), "AdicNot" + AllTrim(P9_IDPON), IIf(&(cPrefixo + "QUANTI") > 0, &(cPrefixo + "QUANTI"), &(cPrefixo + "QUANTC")), IIf(PI_QUANTV > 0, PI_QUANTV, ""), AllTrim(P9_DESC), "", 0}))
                EndIf
            EndIf
        EndIf

        (cAliasQry)->(DBSkip())
    End

    (cAliasQry)->(DBCloseArea())
    RestArea(aArea)

    If lPort671
        // Obtem a duração da jornada realizada
        For nCont := 1 To Len(aMarcacoes)
            If aMarcacoes[nCont][AMARC_DATAAPO] != dLastApo
                dLastApo  := aMarcacoes[nCont][AMARC_DATAAPO]
                nHorasJor := CalcHoraJor(dLastApo, nCont, aMarcacoes, aTabCalend)
                If nHorasJor > 0
                    AAdd(aResult, {DToS(dLastApo), "4", nHorasJor, "", "", "", 0})
                EndIf
            EndIf
        Next nCont
    EndIf
Return NIL

/*/{Protheus.doc} CalcHoraJor
    Calcula a duração da jornada de acordo com as marcações, considerando também as Horas extras e o Horário noturno
    @type Function
    @author Cícero Alves
    @since 24/06/2022
    @param dDataApo, Date, Dia que será avaliado
    @param nPosMarc, Numeric, Posição no aMarcacoes da primeira marcação do dia
    @param aMarcacoes, Array, Marcações realizadas no período
    @param aTabCalend, Array, Calendário do ponto
    @return Numeric, Duração da jornada realizada, incluindo as horas extras e considerado o horário noturno reduzido
/*/
Static Function CalcHoraJor(dDataApo, nPosMarc, aMarcacoes, aTabCalend)
    Local nCont      := 0
    Local nHoras     := 0
    Local nHorasTot  := 0
    Local nHorasNTot := 0
    Local nHorasNot  := 0
    Local nHorasJor  := 0
    Local nLenMarc   := Len(aMarcacoes)
    Local nTab       := AScan(aTabCalend, {|x| x[CALEND_POS_DATA_APO] == dDataApo})

    If nTab > 0 .and. aTabCalend[nTab][CALEND_POS_TIPO_DIA] == "S" // Apenas para dias trabalhados
        For nCont := nPosMarc To nLenMarc Step 2
            If nCont == nLenMarc .or. aMarcacoes[nCont][AMARC_DATAAPO] != dDataApo .or. aMarcacoes[nCont + 1][AMARC_DATAAPO] != dDataApo
                Exit
            EndIf

            If "E" $ aMarcacoes[nCont][AMARC_TIPOMARC]
                fCalHoras(aMarcacoes[nCont][AMARC_DATA]          ,;
                            aMarcacoes[nCont][AMARC_HORA]          ,;
                            aMarcacoes[nCont + 1][AMARC_DATA]      ,;
                            aMarcacoes[nCont + 1][AMARC_HORA]      ,;
                            @nHoras                                ,;  //05 -> <@>Horas Normais Apontadas
                            @nHorasNot                             ,;  //06 -> <@>Horas Noturnas Apontadas
                            .T.                                    ,;  //07 -> Apontar Horas Noturnas
                            aMarcacoes[nCont][AMARC_DATA]          ,;  //08 -> Data Inicial Para a Hora Noturna
                            NIL                                    ,;  //09 -> <@>Horas de Acrescimo Noturno
                            aTabCalend[nTab][CALEND_POS_INI_H_NOT] ,;  //10 -> Inicio do Horario Noturno
                            aTabCalend[nTab][CALEND_POS_FIM_H_NOT] ,;  //11 -> Final do Horario Noturno
                            aTabCalend[nTab][CALEND_POS_MIN_H_NOT] ,;  //12 -> Minutos do Horario Noturno (Não deve reduzir as horas noturnas)
                            NIL                                    ,;  //13 -> Apenas Acrescimo Noturno
                            NIL                                     ;  //14 -> Periodo da Hora Noturna
                )

                nHorasTot  := SomaHoras(nHorasTot, nHoras)
                nHorasNTot := SomaHoras(nHorasNTot, nHorasNot)
                nHoras     := 0
                nHorasNot  := 0
            EndIf
        Next

        nHorasJor := SomaHoras(nHorasTot, Round(nHorasNTot,2))
    EndIf
Return nHorasJor

/*/{Protheus.doc} Pnr010ImpBh
    Calcula os saldos de banco de hora.
    @type   function
    @author EQUIPE DE RH
    @since  09/04/1996
/*/
Static Function Pnr010ImpBh(nSaldoAnt, nSaldoAtu, nCredito, nDebito, nTotHrVal, lImpHrVal, dPerIni, dPerFim, lSexagenal)
    Local aArea     := GetArea()
    Local nValor    := 0
    Local nHrValori := 0
    Local lRet      := .F.

    nSaldoAnt := 0
    nDebito   := 0
    nCredito  := 0
    nSaldoAtu := 0
    nTotHrVal := 0

    DBSelectArea("SPI")
    DBSetOrder(2)
    MsSeek(SRA->RA_FILIAL + SRA->RA_MAT)
    While SPI->(!EOF() .and. PI_FILIAL + PI_MAT == SRA->(RA_FILIAL + RA_MAT))
        PosSP9(SPI->PI_PD, SRA->RA_FILIAL, "P9_TIPOCOD")

        // Totaliza Saldo Anterior
        If SPI->PI_DATA < dPerIni
            If !(SPI->PI_STATUS == 'B' .and. SPI->PI_DTBAIX < dPerIni)
                If (SPI->PI_STATUS == 'B' .and. SPI->PI_DTBAIX <= dPerFim)
                    If SP9->P9_TIPOCOD $ "1*3"
                        nValor := SPI->PI_QUANT
                        If lSexagenal
                            nSaldoAnt := __TimeSum(nSaldoAnt,nValor)
                            nSaldoAtu := __TimeSub(nSaldoAtu,nValor)
                        Else
                            nSaldoAnt := nSaldoAnt + fConvhR(nValor,"D",,5)
                            nSaldoAtu := nSaldoAtu - fConvhR(nValor,"D",,5)
                        EndIf
                    Else
                        nValor := SPI->PI_QUANT
                        If lSexagenal
                            nSaldoAnt := __TimeSub(nSaldoAnt,nValor)
                            nSaldoAtu := __TimeSum(nSaldoAtu,nValor)
                        Else
                            nSaldoAnt := nSaldoAnt - fConvhR(nValor,"D",,5)
                            nSaldoAtu := nSaldoAtu + fConvhR(nValor,"D",,5)
                        EndIf
                    EndIf
                Else
                    If SP9->P9_TIPOCOD $  "1*3"
                        nValor := SPI->PI_QUANT
                        If lSexagenal
                            nSaldoAnt := __TimeSum(nSaldoAnt,nValor)
                        Else
                            nSaldoAnt := nSaldoAnt + fConvhR(nValor,"D",,5)
                        EndIf
                    Else
                        nValor := SPI->PI_QUANT
                        If lSexagenal
                            nSaldoAnt := __TimeSub(nSaldoAnt,nValor)
                        Else
                            nSaldoAnt := nSaldoAnt - fConvhR(nValor,"D",,5)
                        EndIf
                    EndIf
                EndIf
            EndIf
        ElseIf SPI->PI_DATA <= dPerFim
            If !(SPI->PI_STATUS == 'B' .and. SPI->PI_DTBAIX <= dPerFim)
                If SP9->P9_TIPOCOD $  "1*3"
                    nValor    := SPI->PI_QUANT
                    nHrValori := SPI->PI_QUANTV
                    If lSexagenal
                        nCredito := __TimeSum(nCredito,nValor)
                        If lImpHrVal
                            nTotHrVal := __TimeSum(nTotHrVal,nHrValori)
                        EndIf
                    Else
                        nCredito := nCredito + fConvhR(nValor,"D",,5)
                        If lImpHrVal
                            nTotHrVal += fConvhR(nHrValori,"D",,5)
                        EndIf
                    EndIf
                Else
                    nValor    := SPI->PI_QUANT
                    nHrValori := SPI->PI_QUANTV
                    If lSexagenal
                        nDebito := __TimeSum(nDebito,nValor)
                        If lImpHrVal
                            nTotHrVal := __TimeSub(nTotHrVal,nHrValori)
                        EndIf
                    Else
                        nDebito := nDebito + fConvhR(nValor,"D",,5)
                        If lImpHrVal
                            nTotHrVal -= fConvhR(nHrValori,"D",,5)
                        EndIf
                    EndIf
                EndIf
            EndIf
        Else
            Exit
        EndIf

        SPI->(DBSkip())
    End

    If nSaldoAnt <> 0 .or. nCredito > 0 .or. nDebito > 0
        lRet := .T.
        If lSexagenal
            nSaldoAtu := __TimeSum(nSaldoAtu, __TimeSub(__TimeSum(nSaldoAnt, nCredito), nDebito))
        Else
            nSaldoAtu := (nSaldoAtu + nSaldoAnt + nCredito) - nDebito
        EndIf
    EndIf

    RestArea(aArea)
Return lRet

/*/{Protheus.doc} Pnr010Afas
    Busca a situacao e afastamentos do funcionario.
    @type   function
    @author M. Silveira
    @since  09/02/2017
    @history 21/03/2019, Cícero Alves, DRHPONTP-3178 - Aloteração para mostrar apenas a situação atual do funcionário e o período correto do afastamento
    /*/
Static Function Pnr010Afas(dDtIniP, dDtFimP, aAfast)
    Local nX        := 0
    Local nReg      := 0
    Local cSitu     := ""
    Local aAux      := {}
    Local aArea     := GetArea()
    Local aSitFunc  := RetSituacao(SRA->RA_FILIAL, SRA->RA_MAT, .F., dDtFimP,,,, dDtIniP)

    If Len(aSitFunc) > 0
        cSitu := IIf(aSitFunc[1] == "A", STR0076,; // "AFASTADO"
            IIf(aSitFunc[1] == "F", STR0077,;      // "FÉRIAS"
            IIf(aSitFunc[1] == "T", STR0078,;      // "TRANSFERIDO"
            IIf(aSitFunc[1] == "D", STR0079,;      // "DEMITIDO"
            STR0080))))                            // "NORMAL"

        If aSitFunc[1] $ "A/F"
            aAfast  := {}
            fRetAfas(dDtIniP, dDtFimP,,,,, @aAux)
            nReg := Len(aAux)
            ASort(aAux,,, {|x| x[3] > x[3]}) // Ordena do mais rescente para o mais antigo
            If nReg > 0
                For nX := 1 To nReg
                    //Considera somente os afastamentos contidos, que começam ou terminam no periodo de apontamento
                    If (dDtIniP >= aAux[nX][3] .and. dDtFimP <= aAux[nX][4]) .or.;
                        (aAux[nX][4] >= dDtIniP .and. aAux[nX][4] <= dDtFimP) .or.;
                        (aAux[nX][3] >= dDtIniP .and. aAux[nX][3] <= dDtFimP) .or.;
                        (Empty(aAux[nX][4])     .and. aAux[nX][3] <= dDtFimP)

                        // Atualiza a situação para o afastamento que será utilizado
                        cSitu := IIf(aAux[nX][5] == "A", STR0076,; // "AFASTADO"
                            IIf(aAux[nX][5] == "F", STR0077,;      // "FÉRIAS"
                            cSitu))

                        // Exibe apenas o afastamento mais recente, para coicidir com a situação atual do funcionário
                        AAdd(aAfast, {STR0081 + cSitu + " - " + STR0082 + dToC(aAux[nX][3]) + STR0083 + dToC(aAux[nX][4])}) // "Sit...: "#" Período: "

                        EXIT
                    EndIf
                Next nX

                If Empty(aAfast)
                    cSitu := STR0080 // "NORMAL"
                    AAdd(aAfast, {STR0081 + cSitu})
                EndIf
            EndIf
        Else
            AAdd(aAfast, {STR0081 + cSitu})
        EndIf
    EndIf

    RestArea(aArea)
Return NIL

/*/{Protheus.doc} GetHorarios
    Retorna os horários previstos para o funcionário de acordo com o calendário
    @type Function
    @author Cícero Alves
    @since 27/06/2022
    @return Array, Array com a data, turno e horários
/*/
Static Function GetHorarios(aTabCalend)
    Local aHorarios := {}
    Local nI        := 0
    Local cOrdem    := ""
    Local aAux      := {}
    Local nSum      := 0
    Local aLastAux  := {}
    Local dDataAlt  := CToD("//")

    For nI := 1 To Len(aTabCalend)
        nSum := 0
        aAux := {}
        cOrdem := aTabCalend[nI][CALEND_POS_ORDEM]
        dDataAlt := aTabCalend[nI][CALEND_POS_DATA]

        While nI <= Len(aTabCalend) .and. aTabCalend[nI][CALEND_POS_ORDEM] == cOrdem
            AAdd(aAux, aTabCalend[nI][CALEND_POS_HORA])
            nSum += aTabCalend[nI][CALEND_POS_HORA]
            nI++
        End

        //Retorna para a sequência anterior
        nI--

        //Se tiver horário cadastrado para o dia e for diferente do horário anterior
        If nSum > 0  .and. !ArrayCompare(aAux, aLastAux)
            aLastAux := aAux

            AAdd(aHorarios, {})
            AAdd(ATail(aHorarios), dDataAlt)
            AAdd(ATail(aHorarios), aTabCalend[nI][CALEND_POS_TURNO] + " - " + fDescTno(SRA->RA_FILIAL, aTabCalend[nI][CALEND_POS_TURNO]))
            AAdd(ATail(aHorarios), aAux)
        EndIf
    Next nI
Return aHorarios

/*/{Protheus.doc} GetMarcDes
    Carrega as marcações desconsideradas no aMarcDes e as excluí do aMarcacoes
    @type Function
    @author Cícero Alves
    @since 06/10/2022
/*/
Static Function GetMarcDes(aMarcacoes, aMarcDes)
    Local nI      := 1
    Local nNewTam := Len(aMarcacoes)

    While nI <= nNewTam
        If aMarcacoes[nI, 27] == "D"
            AAdd(aMarcDes, {aMarcacoes[nI, 1], StrTran(StrZero(aMarcacoes[nI,2],5,2),'.',':'), aMarcacoes[nI, 29]})
            ADel(aMarcacoes, nI)
            nNewTam--
        Else
            nI++
        EndIf
    End

    ASize(aMarcacoes, nNewTam)
Return NIL

/*
    ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
    ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
    ±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
    ±±³Funo    ³FMontaaIMP³ aUTOR ³ EQUIPE DE RH          ³ dATA ³ 09/04/96 ³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³Descrio ³ Monta o Vetor aImp, utilizado na impressao do espelho      ³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³Sintaxe   ³                                                            ³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³ Uso      ³ POR010IMP                                                  ³±±
    ±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
    ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
    ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function FMontaAimp(aTabCalend, aMarcacoes, aImp,dInicio,dFim, lImpAcum, lImpMarc, lPort671, aResult, aAbonados, nImpAut, aCodAut)
    Local aDescAbono := {}
    Local cTipAfas   := ""
    Local cDescAfas  := ""
    Local cOcorr     := ""
    Local cOrdem     := ""
    Local cTipDia    := ""
    Local lIsento    := .F.
    Local dData      := CToD("//")
    Local dDtBase    := dFim
    Local lRet       := .T.
    Local lFeriado   := .T.
    Local lTrabaFer  := .F.
    Local lAfasta    := .T.
    Local nX         := 0
    Local nDia       := 0
    Local nMarc      := 0
    Local nLenMarc   := Len(aMarcacoes)
    Local nLenDescAb := Len(aDescAbono)
    Local nTab       := 0
    Local nContMarc  := 0
    Local nDias      := 0
    Local cOriMarc   := ""

    // Variáveis ja inicializadas.
    aImp := {}

    nDias := (dDtBase - dInicio)
    For nDia := 0 To nDias
        // Reinicializa Variáveis
        dData      := dInicio + nDia
        aDescAbono := {}
        cOcorr     := ""
        cTipAfas   := ""
        cDescAfas  := ""
        cOcorr     := ""

        // O Array aTabcalend setado para a 1a Entrada do dia em questão
        If (nTab := AScan(aTabCalend, {|x| x[48] == dData .and. x[4] == '1E'})) == 0.00
            Loop
        EndIf

        // O Array aMarcacoe setado para a 1a Marcação do dia em questão
        nMarc := AScan(aMarcacoes, {|x| x[3] == aTabCalend[nTab, 2]})

        // Consiste Afastamentos, Demissoes ou Transferencias
        If ((lAfasta := aTabCalend[nTab, 24]) .or. SRA->(RA_SITFOLH $ 'DúT' .and. dData > RA_DEMISSA))
            lAfasta   := .T.
            cTipAfas  := IIf(!Empty(aTabCalend[nTab, 25]),aTabCalend[nTab, 25],fDemissao(SRA->RA_SITFOLH, SRA->RA_RESCRAI))
            cDescAfas := Alltrim(fDescAfast(cTipAfas, TamSx3("RCM_DESCRI")[1], NIL, SRA->(RA_SITFOLH == 'D' .and. dData > RA_DEMISSA), aTabCalend[nTab, 47], SRA->RA_FILIAL))
        EndIf

        //Verifica Regra de Apontamento (Trabalha Feriado ?)
        lTrabaFer := (PosSPA(aTabCalend[nTab, 23], FwXFilial("SPA", SRA->RA_FILIAL), "PA_FERIADO", 01) == "S")

        // Consiste Feriados
        lFeriado := aTabCalend[nTab, 19]
        cOcorr   := IIf(lFeriado .and. !lTrabaFer, aTabCalend[nTab, 22], cOcorr)

        // Carrega Array aDescAbono com os Abonos ocorridos no Dia
        nLenDescAb := Len(aAbonados)
        For nX := 1 To nLenDescAb
            If aAbonados[nX,1] == dData
                AAdd(aDescAbono, {aAbonados[nX,2], aAbonados[nX,3], aAbonados[nX,4]})
            EndIf
        Next nX

        // Ordem e Tipo do dia em questão
        cOrdem  := aTabCalend[nTab, CALEND_POS_ORDEM]
        cTipDia := aTabCalend[nTab, CALEND_POS_TIPO_DIA]
        lIsento := aTabCalend[nTab, CALEND_POS_ISENTMARC]

        // Se a data da marcação for posterior à admissão
        If dData >= SRA->RA_ADMISSA
            // Se Afastado
            If (lAfasta  .and. aTabCalend[nTab,10] <> "E") .or. (lAfasta  .and. aTabCalend[nTab,10] == "E" .and. (!lImpExcecao .or. !aTabCalend[nTab,32]))
                cOcorr := cDescAfas
            // Se nao for Afastado
            Else
                // Verifica se o funcionário é isento de marcação naquele dia
                If cTipDia == "S" .and. lIsento
                    cOcorr := STR0084 // "Isento de Marcação"
                // Se tiver EXCECAO para o Dia
                ElseIf aTabCalend[nTab,10] == "E"
                    // Se excecao trabalhada
                    If cTipDia == "S"
                        // Motivo da Marcacao
                        cOcorr := IIf(Empty(nMarc), STR0085,; // "Ausente"
                            IIf(!Empty(aTabCalend[nTab,11]), AllTrim(aTabCalend[nTab,11]), STR0086)) // "Exceção nao Trabalhada"
                    // Se excecao outros dias (DSR/Compensado/Nao Trabalhado)
                    Else
                        // Motivo da Marcacao
                        cOcorr := IIf(!Empty(aTabCalend[nTab,11]), AllTrim(aTabCalend[nTab,11]), STR0086) // "Exceção nao Trabalhada"
                    EndIf
                // Se nao Tiver Excecao no Dia
                Else
                    // Se feriado
                    If lFeriado
                        // Se nao trabalha no Feriado
                        If !lTrabaFer
                            cOcorr := IIf(!Empty(cOcorr), cOcorr, STR0087) // "Feriado"
                        // Se trabalha no Feriado
                        Else
                            // Se Dia Trabalhado
                            cOcorr := IIf(cTipDia == "S" .and. Empty(nMarc), STR0085,; // "Ausente"
                                IIf(cTipDia == "D", STR0088,;                          // "D.S.R."
                                IIf(cTipDia == "C", STR0089,;                          // "Compensado"
                                IIf(cTipDia == "N", STR0090, cOcorr))))                // "Não Trabalhado"
                        EndIf
                    Else
                        // Se Dia Trabalhado
                        cOcorr := IIf(cTipDia == "S" .and. Empty(nMarc), STR0085,; // "Ausente"
                            IIf(cTipDia == "D", STR0088,;                          // "D.S.R."
                            IIf(cTipDia == "C", STR0089,;                          // "Compensado"
                            IIf(cTipDia == "N", STR0090, cOcorr))))                // "Não Trabalhado"
                    EndIf
                EndIf
            EndIf
        EndIf

        nLenDescAb  := Len(aDescAbono)

        // Adiciona Nova Data a ser impressa
        AAdd(aImp, {})
        AAdd(aImp[Len(aImp)], aTabCalend[nTab,48])
        AAdd(aImp[Len(aImp)], cOcorr)

        // Abono na data
        For nX := 1 To nLenDescAb
            aImp[Len(aImp)][2] += IIf(!Empty(aImp[Len(aImp)][2]), " | ", "") + Trim(aDescAbono[nX][1])
        Next nX

        // Marcacoes ocorridas na data
        If nMarc > 0
            While nMarc <= nLenMarc .and. cOrdem == aMarcacoes[nMarc,3]
                nContMarc++

                // Se nao for original, inclui asterisco na frente da marcacao
                cOriMarc := " " + IIf(lPort671, aMarcacoes[nMarc, 28],;
                    IIf(aMarcacoes[nMarc, 28] != "O", "*", ""))

                AAdd(aImp[Len(aImp)], StrTran(StrZero(aMarcacoes[nMarc,2],5,2),".",":") + cOriMarc)
                nMarc ++
            End
        EndIf
    Next nDia

    If lImpMarc //Carrega o array aResult para exibicao das HE, faltas e adc. noturno
        aResult := {}
        fGetApo(@aResult, dInicio, dFim, lImpAcum, aTabCalend, aMarcacoes, lPort671, nImpAut, aCodAut)
    EndIf

    lRet := IIf(nContMarc >= 1,.T.,.F.)
Return lRet

/*
    ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
    ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
    ±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
    ±±³Funo    ³CarAboTot ³ Autor ³ EQUIPE DE RH          ³ Data ³ 08/08/96 ³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³Descrio ³ Carrega os totais do SPC e os abonos                       ³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³Sintaxe   ³                                                            ³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³ Uso      ³ POR010IMP                                                  ³±±
    ±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
    ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
    ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function CarAboTot(aTotais, aAbonados, aAbonosPer, lMvAbosEve, lMvSubAbAp, aID, aBoxSPC, dMarcIni, dMarcFim, lImpAcum, nImpHrs, nImpAut, aTabCalend, lImpRes, lSexagenal)
    Local aTotSpc    := {} // 1-SPC->PC_PD/2-SPC->PC_QUANTC/3-SPC->PC_QUANTI/4-SPC->PC_QTABONO
    Local aCodAbono  := {}
    Local cFilSP9    := FwXFilial("SP9", SRA->RA_FILIAL)
    Local cFilSRV    := FwXFilial("SRV", SRA->RA_FILIAL)
    Local cImpHoras  := IIf(nImpHrs == 1, "C", IIf(nImpHrs == 2, "I", "*")) // Calc/Info/Ambas
    Local cAutoriza  := IIf(nImpAut == 1, "A", IIf(nImpAut == 2, "N", "*")) // Aut./N.Aut./Ambas
    Local cAliasRes  := IIf(lImpAcum, "SPL", "SPB")
    Local cAliasApo  := IIf(lImpAcum, "SPH", "SPC")
    Local bAcessaSPC := &("{|| " + ChkRH("PONR010", "SPC", "2") + "}")
    Local bAcessaSPH := &("{|| " + ChkRH("PONR010", "SPH", "2") + "}")
    Local bAcessaSPB := &("{|| " + ChkRH("PONR010", "SPB", "2") + "}")
    Local bAcessaSPL := &("{|| " + ChkRH("PONR010", "SPL", "2") + "}")
    Local bAcessRes  := IIf(lImpAcum, bAcessaSPH, bAcessaSPC)
    Local bAcessApo  := IIf(lImpAcum, bAcessaSPL, bAcessaSPB)
    Local nColSpc    := 0.00
    Local nCtSpc     := 0.00
    Local nPass      := 0.00
    Local nHorasCal  := 0.00
    Local nHorasInf  := 0.00
    Local nX         := 0.00

    If (lImpRes)
        //Totaliza Codigos a partir do Resultado
        fTotalSPB(;
                    @aTotSpc       ,;
                    SRA->RA_FILIAL ,;
                    SRA->RA_MAT    ,;
                    dMarcIni       ,;
                    dMarcFim       ,;
                    bAcessRes      ,;
                    cAliasRes       ;
        )

        // Converte as horas para sexagenal quando impressao for a partir do resultado
        If (lSexagenal) // Sexagenal
            For nCtSpc := 1 To Len(aTotSpc)
                For nColSpc := 2 To 4
                    aTotSpc[nCtSpc,nColSpc] := fConvHr(aTotSpc[nCtSpc,nColSpc],"H")
                Next nColSpc
            Next nCtSpc
        EndIf
    EndIf

    //Totaliza Codigos a partir do Movimento
    fTotaliza(@aTotSpc, SRA->RA_FILIAL, SRA->RA_MAT, bAcessApo, cAliasApo, cAutoriza, @aCodAbono, aAbonosPer, lMvAbosEve, lMvSubAbAp, aID, aBoxSPC, dMarcIni, dMarcFim, aAbonados, aTabCalend, lImpRes, lSexagenal)

    // Converte as horas para Centesimal quando impressao for a partir do apontamento
    If !(lImpRes) .and. !(lSexagenal) // Centesimal
        For nCtSpc := 1 To Len(aTotSpc)
            For nColSpc := 2 To 4
                aTotSpc[nCtSpc,nColSpc] := fConvHr(aTotSpc[nCtSpc,nColSpc],"D",,5)
            Next nColSpc
        Next nCtSpc
    EndIf

    // Monta Array com Totais de Horas
    If nImpHrs # 4  // Se solicitado para Listar Totais de Horas
        For nPass := 1 To Len(aTotSpc)
            If (lImpRes) // Impressao dos Resultados
                // Se encontrar o Codigo da Verba ou For um codigo de hora extra valido de acordo com o solicitado
                If PosSrv(aTotSpc[nPass,1], cFilSRV, NIL, 01)
                    nHorasCal := aTotSpc[nPass,2] // Calculado - Abonado
                    nHorasInf := aTotSpc[nPass,3] // Informado
                    If nHorasCal > 0 .and. cImpHoras $ "Cú*" .or. nHorasInf > 0 .and. cImpHoras $ "Iú*"
                        cHorCal := IIf(cImpHoras $ "Cú*",Transform(nHorasCal, "@E 999.99"), Space(9)) + Space(1)
                        cHorInf := IIf(cImpHoras $ "Iú*",Transform(nHorasInf, "@E 999.99"), Space(9))
                        AAdd(aTotais, {aTotSpc[nPass,1], SRV->RV_DESC, cHorCal, cHorInf})
                    EndIf
                EndIf
            ElseIf PosSP9(aTotSpc[nPass,1], cFilSP9, NIL, 01)
                // Impressao a Partir do Movimento
                nHorasCal := aTotSpc[nPass,2] // Calculado - Abonado
                nHorasInf := aTotSpc[nPass,3] // Informado
                If nHorasCal > 0 .and. cImpHoras $ "Cú*" .or. nHorasInf > 0 .and. cImpHoras $ "Iú*"
                    cHorCal := IIf(cImpHoras$"Cú*",Transform(nHorasCal, "@E 999.99"),Space(9)) + Space(1)
                    cHorInf := IIf(cImpHoras$"Iú*",Transform(nHorasInf, "@E 999.99"),Space(9))
                    AAdd(aTotais, {aTotSpc[nPass,1], DescPDPon(aTotSpc[nPass,1], cFilSP9), cHorCal, cHorInf})
                EndIf
            EndIf
        Next nPass

        // Acrescenta as informacoes referentes aos eventos associados aos motivos de abono
        // Condicoes: Se nao For Impressao de Resultados
        //            e Se For para Imprimir Horas Calculadas ou Ambas
        If !(lImpRes) .and. (nImpHrs == 1 .or. nImpHrs == 3)
            For nX := 1 To Len(aCodAbono)
                // Converte as horas para Centesimal
                If !(lSexagenal) // Centesimal
                    aCodAbono[nX,2] := fConvHr(aCodAbono[nX,2],"D",,5)
                EndIf

                AAdd(aTotais, {aCodAbono[nX,1], DescPDPon(aCodAbono[nX,1], cFilSP9), "  0,00" , Transform(aCodAbono[nX,2],"@E 999.99")})
            Next nX
        EndIf
    EndIf
Return NIL

/*/
    ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
    ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
    ±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
    ±±³Funo    ³fTotaliza ³ Autor ³ Mauricio MR           ³ Data ³ 27/05/02 ³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³Descrio ³ Totalizar as Verbas do SPC (Apontamentos) /SPH (Acumulado) ³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³ Uso      ³ Generico                                                   ³±±
    ±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
    ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
    ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/
*/
Static Function fTotaliza(aTotais, cFil, cMat, bAcessa, cAlias, cAutoriza, aCodAbono, aAbonosPer, lMvAbosEve, lMvSubAbAp, aID, aBoxSPC, dMarcIni, dMarcFim, aAbonados, aTabCalend, lImpRes, lSexagenal)
    Local aJustifica := {}
    Local cCodigo    := ""
    Local cPrefix    := SubStr(cAlias,-2)
    Local cTno       := ""
    Local cCodExtras := ""
    Local cEvento    := ""
    Local cPD        := ""
    Local cPDI       := ""
    Local cCC        := ""
    Local cTPMARCA   := ""
    Local lExtra     := .T.
    Local lShow      := .F.
    Local lAbHoras   := .T.
    Local nQuaSpc    := 0.00
    Local nX         := 0.00
    Local nEfetAbono := 0.00
    Local nQUANTC    := 0.00
    Local nQuanti    := 0.00
    Local nQTABONO   := 0.00
    Local lRemonta   := .F.
    Local lContinua  := .F.
    Local cDSRMS     := ""

    IIf((nPos := AScan(aID, {|x| x[2] == "022A"})) > 0, cDSRMS := aID[nPos, 1],)
    IIf((nPos := AScan(aID, {|x| x[2] == "021N"})) > 0, cDSRMS += "*" + aID[nPos, 1],)

    If (cAlias)->(MsSeek(cFil + cMat))
        While (cAlias)->(!EOF() .and. cFil+cMat == &(cPrefix+"_FILIAL")+&(cPrefix+"_MAT"))
            dData    := (cAlias)->(&(cPrefix+"_DATA"))       // Data do Apontamento
            cPD      := (cAlias)->(&(cPrefix+"_PD"))         // Codigo do Evento
            cPDI     := (cAlias)->(&(cPrefix+"_PDI"))        // Codigo do Evento Informado
            nQUANTC  := (cAlias)->(&(cPrefix+"_QUANTC"))     // Quantidade Calculada pelo Apontamento
            nQuanti  := (cAlias)->(&(cPrefix+"_QUANTI"))     // Quantidade Informada
            nQTABONO := (cAlias)->(&(cPrefix+"_QTABONO"))    // Quantidade Abonada
            cTPMARCA := (cAlias)->(&(cPrefix+"_TPMARCA"))    // Tipo da Marcacao
            cCC      := (cAlias)->(&(cPrefix+"_CC"))         // Centro de Custos

            If ((cAlias)->(!Eval(bAcessa)) .or. (dData < dMarcIni .or. dDATA > dMarcFim) .or. cPD $ cDSRMS)
                (cAlias)->(DBSkip())
                Loop
            EndIf

            // Obtem TODOS os ABONOS do Evento
            // Trata a Qtde de Abonos
            aJustifica := {} // Reinicializa aJustifica
            nEfetAbono := 0.00
            If nQuanti == 0 .and. fAbonos(dData, cPD, NIL, @aJustifica, cTPMARCA, cCC, aAbonosPer) > 0
                // Corre Todos os Abonos
                For nX := 1 To Len(aJustifica)
                    // Cria Array Analitico de Abonos com horas Convertidas.
                    // Obtem a Quantidade de Horas Abonadas
                    nQuaSpc := aJustifica[nX,2] //_QtAbono

                    // Converte as horas Abonadas para Centesimal
                    If !(lSexagenal) // Centesimal
                        nQuaSpc := fConvHr(nQuaSpc,'D',,5)
                    EndIf

                    // Cria Novo Elemento no array ANALITICO de Abonos
                    AAdd(aAbonados, {})
                    AAdd(aAbonados[Len(aAbonados)], dData)
                    AAdd(aAbonados[Len(aAbonados)], DescAbono(aJustifica[nX,1],'C', NIL, SRA->RA_FILIAL))

                    AAdd(aAbonados[Len(aAbonados)], StrTran(StrZero(nQuaSpc,5,2),'.',':'))
                    AAdd(aAbonados[Len(aAbonados)], DescTpMarca(aBoxSPC,cTPMARCA))

                    If !(lImpRes)
                        /*
                        ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
                        ³ Trata das Informacoes sobre o Evento Associado ao Motivo corrente ³
                        ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
                        // Obtem Evento Associado
                        cEvento := PosSP6(aJustifica[nX,1], SRA->RA_FILIAL, "P6_EVENTO", 01)
                        If (lAbHoras := (PosSP6(aJustifica[nX,1], SRA->RA_FILIAL, "P6_ABHORAS", 01) $ " S"))
                            // Se o motivo abona Horas
                            If (lAbHoras)
                                If !Empty(cEvento)
                                    If (nPos := AScan(aCodAbono, {|x| x[1] == cEvento})) > 0
                                        aCodAbono[nPos,2] := __TimeSum(aCodAbono[nPos,2], aJustifica[nX,2]) //_QtAbono
                                    Else
                                        AAdd(aCodAbono, {cEvento,  aJustifica[nX,2]}) // Codigo do Evento e Qtde Abonada
                                    EndIf
                                Else
                                    /*
                                    ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
                                    ³ A T E N C A O: Neste Ponto deveriamos tratar o paramentro MV_ABOSEVE  ³
                                    ³                no entanto, como ja havia a deducao abaixo e caso al-  ³
                                    ³                guem migra-se da versao 609 com o cadastro de motivo   ³
                                    ³                de abonos abonando horas mas sem o codigo, deixariamos ³
                                    ³                de tratar como antes e o cliente argumentaria alteracao³
                                    ³                de conceito.                                           ³
                                    ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
                                    // Se o motivo  nao possui abono associado
                                    // Calcula o total de horas a abonar efetivamente
                                    nEfetAbono := __TimeSum(nEfetAbono, aJustifica[nX,2]) //_QtAbono
                                EndIf
                            EndIf
                        Else
                            /*
                            ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
                            ³Se Motivo de Abono Nao Abona Horas e o Codigo do Evento Relaci³
                            ³onado ao Abono nao Estiver Vazio, Eh como se fosse uma  altera³
                            ³racao do Codigo de Evento. Ou seja, Vai para os Totais      as³
                            ³Horas do Abono que serao subtraidas das Horas Calculadas (Po³
                            ³deriamos Chamar esta operacao de "Informados via Abono").    ³
                            ³Para que esse processo seja feito o Parametro MV_SUBABAP  deve³
                            ³ra ter o Conteudo igual a "S"                                 ³
                            ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
                            If ((lMvSubAbAp) .and. !Empty(cEvento))
                                // Se o motivo  nao possui abono associado
                                // Calcula o total de horas a abonar efetivamente
                                If (nPos := AScan(aCodAbono, {|x| x[1] == cEvento})) > 0
                                    aCodAbono[nPos,2] := __TimeSum(aCodAbono[nPos,2], aJustifica[nX,2]) //_QtAbono
                                Else
                                    AAdd(aCodAbono, {cEvento,  aJustifica[nX,2]}) // Codigo do Evento e Qtde Abonada
                                EndIf
                                // O total de horas acumulado em nEfetAbono sera deduzido do
                                // total de horas apontadas.
                                nEfetAbono := __TimeSum(nEfetAbono, aJustifica[nX,2]) //_QtAbono
                            EndIf
                        EndIf
                    EndIf
                Next nX
            EndIf

            If !(lImpRes)
                // Obtem o Codigo do Evento  (Informado ou Calculado)
                cCodigo:= IIf(!Empty(cPDI), cPDI, cPD)

                // Obtem a posicao no Calendario para a Data
                If (nPos := AScan(aTabCalend, {|x| x[1] == dDATA .and. x[4] == '1E'})) > 0
                    // Obtem o Turno vigente na Data
                    cTno :=  aTabCalend[nPos,14]

                    // Carrega ou recupera os codigos correspondentes a horas extras na Data
                    cCodExtras := ''
                    lRemonta   := IIf(cAutoriza $ "A|N" .and. !Empty(ALLTRIM(cPdi)), .T., .F.)

                    CarExtAut(@cCodExtras, cTno, "*", lRemonta)

                    lExtra := .F.
                    lShow  := .F.

                    If cCodigo $ cCodExtras
                        lExtra := .T.
                        If cAutoriza != "*"
                            cCodExtras := ""
                            CarExtAut(@cCodExtras, cTno, cAutoriza, lRemonta)
                            lShow := IIf(cCodigo $ cCodExtras, .T., lShow)
                        EndIf
                    EndIf
                EndIf

                // Se o Evento for Alguma HE Solicitada (Autorizada ou Nao Autorizada)
                // Ou  Valido Qquer Evento (Autorizado e Nao Autorizado)
                // OU  Evento possui um identificador correspondente a Evento Autorizado ou Nao Autorizado.
                // Ou  Evento e' referente a banco de horas
                lContinua := .F.

                If (cAutoriza == '*' .or. (lExtra .and. lShow) .or. (!lExtra .and. AScan(aId, {|aEvento| (aEvento[1] == cCodigo .and. Right(aEvento[2],1) == cAutoriza) .or. (aEvento[1] == cCodigo .and. cAutoriza == 'A' .and. Empty(aEvento[2]) .and. aEvento[4] == "S")}) > 0.00))
                    lContinua := .T.
                EndIf

                If (lContinua)
                    // Procura em aTotais pelo acumulado do Evento Lido
                    If (nPos := AScan(aTotais,{|x| x[1] = cCodigo })) > 0
                        // Subtrai do evento a qtde de horas que efetivamente abona horas conforme motivo de abono
                        aTotais[nPos,2] := __TimeSum(aTotais[nPos,2],If(nQuanti>0, 0, __TimeSub(nQUANTC,nEfetAbono)))
                        aTotais[nPos,3] := __TimeSum(aTotais[nPos,3],nQuanti)
                        aTotais[nPos,4] := __TimeSum(aTotais[nPos,4],nQTABONO)
                    Else
                        // Adiciona Evento em Acumulados
                        // Subtrai do evento a qtde de horas que efetivamente abona horas conforme motivo de abono
                        AAdd(aTotais,{cCodigo,If(nQuanti > 0, 0, __TimeSub(nQUANTC,nEfetAbono)), nQuanti,nQTABONO,lExtra})
                    EndIf
                EndIf
            EndIf

            (cAlias)->(DBSkip())
        End
    EndIf
Return NIL

/*/
    ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
    ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
    ±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
    ±±³Funo    ³fTotalSPB ³ Autor ³ EQUIPE DE RH          ³ Data ³ 05/06/00 ³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³Descrio ³ Totaliza eventos a partir do SPB.                          ³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³ Uso      ³ Generico                                                   ³±±
    ±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
    ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
    ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/
*/
Static Function fTotalSPB(aTotais,cFil,cMat,dDataIni,dDataFim,bAcessa,cAlias)
    Local cPrefix := ""

    cPrefix := PrefixoCpo(cAlias)

    If (cAlias)->(DBSeek(cFil + cMat))
        While (cAlias)->(!EOF() .and. cFil+cMat == &(cPrefix+"_FILIAL")+&(cPrefix+"_MAT"))
            If ((cAlias)->(&(cPrefix+"_DATA") < dDataIni .or. &(cPrefix+"_DATA") > dDataFim) .or. (cAlias)->(!Eval(bAcessa)))
                (cAlias)->(DBSkip())
                Loop
            EndIf

            If (nPos := AScan(aTotais,{|x| x[1] == (cAlias)->(&(cPrefix+"_PD"))})) > 0
                aTotais[nPos,2] := aTotais[nPos,2] + (cAlias)->(&(cPrefix+"_HORAS"))
            Else
                AAdd(aTotais,{(cAlias)->(&(cPrefix+"_PD")), (cAlias)->(&(cPrefix+"_HORAS")),0,0})
            EndIf

            (cAlias)->(DBSkip())
        End
    EndIf
Return NIL

/*
    ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
    ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
    ±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
    ±±³Funo    ³ CarExtAut³ Autor ³ Mauricio MR           ³ Data ³ 24/05/02 ³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³Descrio ³ Retorna Relacao de Horas Extras por Filial/Turno           ³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³Parametros³ cCodExtras --> String que Contem ou Contera os Codigos     ³±±
    ±±³          ³ cTnoCad    --> Turno conforme o Dia                        ³±±
    ±±³          ³ cAutoriza  --> "*" Horas Autorizadas/Nao Autorizadas       ³±±
    ±±³          ³                "A" Horas Autorizadas                       ³±±
    ±±³          ³                "N" Horas Nao Autorizadas                   ³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³ Uso      ³ PONM010                                                    ³±±
    ±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
    ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
    ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function CarExtAut(cCodExtras, cTnoCad, cAutoriza, lRemonta)
    Local aTabExtra  := {}
    Local cFilSP4    := fFilFunc("SP4")
    Local cTno       := ""
    Local lFound     := .F.
    Local lRet       := .T.
    Local nX         := 0
    Local naTabExtra := 0
    Local ncTurno    := 0.00

    Static aExtrasTno

    If (PCount() == 0.00)
        aExtrasTno := NIL
    Else
        DEFAULT aExtrasTno := {}

        // Procura Tabela (Filial + Turno corrente)
        If (lFound := (SP4->(MsSeek(cFilSP4 + cTnoCad, .F.))))
            cTno   := cTnoCad
            lFound := .T.
        Else
            // Procura Tabela (Filial)
            cTno   := Space(Len(SP4->P4_TURNO))
            lFound := SP4->(MsSeek(cFilSP4 + cTno, .F.))
        EndIf

        // Se Existe Tabela de HE
        If (lFound)
            // Verifica se a Tabela de HE para o Turno ainda nao foi carregada
            If (lRemonta) .or. (ncTurno := AScan(aExtrasTno,{|aTurno| aTurno[1]  == cFilSP4 .and. aTurno[2] == cTno .and. aTurno[4] == cAutoriza})) == 0.00
                // Se nao Encontrou Carrega Tabela para Filial e Turno especificos
                GetTabExtra(@aTabExtra, cFilSP4, cTno, .F., .F.)

                // Posiciona no inicio da Tabela de HE da Filial Solicitada
                If !Empty(aTabExtra)
                    naTabExtra := Len(aTabExtra)
                    // Corre Códigos de Hora Extra da Filial
                    For nX := 1 To naTabExtra
                        // Se Ambos os Tipos de Eventos ou Autorizados
                        If cAutoriza == '*' .or. (cAutoriza == 'A' .and. !Empty(aTabExtra[nX,4]))
                            cCodExtras += aTabExtra[nX,4] + 'A' // Cod Autorizado
                        EndIf

                        // Se Ambos os Tipos de Eventos ou Nao Autorizados
                        If cAutoriza == '*' .or. (cAutoriza == 'N' .and. !Empty(aTabExtra[nX,5]))
                            cCodExtras += aTabExtra[nX,5] + 'N' // Cod Nao Autorizado
                        EndIf
                    Next nX
                EndIf

                // Cria Nova Relacao de Codigos Extras para o Turno Lido
                AAdd(aExtrasTno, {cFilSP4, cTno, cCodExtras, cAutoriza})
            Else
                // Recupera Tabela Anteriormente Lida
                cCodExtras := aExtrasTno[ncTurno,3]
            EndIf
        EndIf
    EndIf
Return(lRet)

/*/
    ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
    ±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
    ±±³Funo    ³LoadX3Box ³ Autor ³ Mauricio MR           ³ Data ³ 10.12.01 ³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³Descrio ³ Retorna array da ComboBox                                  ³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³Parametros³ cCampo - Nome do Campo                                     ³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³ Uso      ³ Generico                                                   ³±±
    ±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
    ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
    ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function LoadX3Box(cCampo)
    Local aRet := {}, nCont, nIgual
    Local cCbox, cString
    Local aSvArea := SX3->(GetArea())

    SX3->(DBSetOrder(2))
    SX3->(DBSeek(cCampo))

    cCbox := SX3->(X3Cbox())
    // Opcao 1   |Opcao 2 |Opcao 3|Opcao 4
    // 01=Amarelo;02=Preto;03=Azul;04=Vermelho
    //   | À->nIgual        À->nCont
    //   À->cString: 01=Amarelo
    //aRet:={{01,Amarelo},{02.Preto},...}

    While !Empty(cCbox)
        nCont   := AT(";",cCbox)
        nIgual  := AT("=",cCbox)
        cString := AllTrim(SubStr(cCbox, 1, nCont - 1)) //Opcao

        If nCont == 0
            AAdd(aRet, {SubStr(cString, 1, nIgual - 1),SubStr(cString, nIgual + 1)})
            Exit
        Else
            AAdd(aRet, {SubStr(cString, 1, nIgual - 1),SubStr(cString, nIgual + 1)})
        EndIf

        cCbox := SubStr(cCbox,nCont+1)
    End

    RestArea(aSvArea)
Return aRet

/*/
    ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
    ±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
    ±±³Funo    ³DescTPMarc³ Autor ³ Mauricio MR           ³ Data ³ 10.12.01 ³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³Descrio ³ Retorna Descricao do Tipo da Marcacao                      ³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³Parametros³ aBox     - Array Contendo as Opcoes do Combox Ja Carregadas³±±
    ±±³          ³ cTpMarca - Tipo da Marcacao                                ³±±
    ±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
    ±±³ Uso      ³ Ponr010                                                    ³±±
    ±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
    ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
    ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function DescTpMarca(aBox,cTpMarca)
    Local cRet:= "", nTpMarca := 0

    // Se existirem opções realiza a busca da marcacao
    nTpmarca := IIf(Len(aBox) > 0, AScan(aBox,{|xtp| xTp[1] == cTpMarca}), 0)
    cRet     := IIf(Len(aBox) > 0, IIf(nTpMarca>0,aBox[nTpmarca,2], ""),   "")
Return cRet

/*/{Protheus.doc} GravaSR4
    Grava na tabela SR4 o controle dos arquivos gerados com código de barras ou que foram enviados para o TAE
    @type Function
    @author Cícero Alves
    @since 23/02/2022
    @param cNomeDoc, Character, Nome do arquivo
    @param cId, Character, ID do arquivo no TAE
/*/
Static Function GravaSR4(cNomeDoc, cId, lTAE, dPerIni, dPerFim, cCodeBar, oSign)
    Local aRS4Area  := GetArea()
    Local lAtualiza := .F.
    Local cPerIni   := DToS(dPerIni)
    Local cPerFim   := DToS(dPerFim)
    Local cFilRS4   := xFilial("RS4", SRA->RA_FILIAL)
    Local lCpoRS4   := RS4->(ColumnPos("RS4_TPDOC")) > 0
    Local lOk       := .F.

    Static lAtuTae  := .T.

    Default cNomeDoc := ""
    Default cId := 0

    If lAtuTae .and. lTAE .and. lCpoRS4
        fStatusTAE(cFilRS4, SRA->RA_MAT, .F., @oSign) // Atualiza o status dos documentos na RS4
        lAtuTae := .F.
    EndIf

    If RS4->(DBSeek(cFilRS4 + SRA->RA_MAT + cPerIni + cPerFim))
        While RS4->(RS4_FILIAL + RS4_MAT + RS4_PER) == SRA->(RA_FILIAL + RA_MAT + cPerIni + cPerFim)
            If RS4->RS4_STATUS == "2" //Pendente
                If !lCpoRS4 .Or. (lCpoRS4 .and. RS4->RS4_TPDOC == "2")
                    lAtualiza := .T.
                    EXIT
                ElseIf lTAE .and. lCpoRS4 .and. RS4->RS4_TPDOC == "1"
                    // Verifica o Status do documento no TAE
                    lOk       := oSign:documentStatus(RS4->RS4_ID)
                    jResponse := oSign:getResponse()
                    If lOk .and. jResponse["data"]["status"] == 0 // Rascunho
                        If oSign:deleteDocument(RS4->RS4_ID) // Exclui o documento
                            lAtualiza := .T.
                            EXIT
                        EndIf
                    EndIf
                EndIf
            EndIf
            RS4->(DBSkip())
        EndDo
    EndIf

    RecLock("RS4", !lAtualiza)
        RS4->RS4_FILIAL := SRA->RA_FILIAL
        RS4->RS4_MAT    := SRA->RA_MAT
        RS4->RS4_PER    := cPerIni + cPerFim
        RS4->RS4_DATAI  := dPerIni
        RS4->RS4_DATAF  := dPerFim
        RS4->RS4_CODEBA := cCodeBar
        RS4->RS4_STATUS := "2" //Pendente
        If lCpoRS4
            RS4->RS4_TPDOC  := If(lTAE, "1", "2")
            If lTAE
                RS4->RS4_NDOC   := cNomeDoc
                RS4->RS4_ID     := cId
                RS4->RS4_DTINTE := Date()
            EndIf
        EndIf
    MsUnLock()

    RestArea(aRS4Area)
Return

/*/{Protheus.doc} SendTAE
    Realiza o envio de um arquivo para o TAE e solicita a assinatura
    @type Function
    @author Cícero Alves
    @since 02/02/2022
    @param cPathFile, Character, diretório e nome do arquivo que será enviado
    @param cNameFile, Character, Nome do arquivo enviado para o TAE
    @param lMRHTae, logical, Método de assinatura do TAE caso o cliente utilize o MeuRH
    @param oSign, Object, Instância da classe FwTotvsSign()
    @param lTAE, Logical, Se integra com TAE
    @param dPerIni, Date, Período inicial
    @param dPerFim, Date, Período final
    @param cCodeBar, Character, Código de barras
    @return Variant, Retorno nulo pré-fixado
/*/
Function SendTAE(cPathFile As Character, cNameFile As Character, lMRHTae As Logical, oSign As Object, lTAE As Logical, dPerIni As Date, dPerFim As Date, cCodeBar As Character) As Variant
    Local lOk       As Logical
    local nId       As Numeric
    Local cMsg      As Character
    Local oMRH      As Object
    Local jResponse As JSON

    lOk       := .F.
    nId       := 0
    cMsg      := ""
    oMRH      := NIL
    jResponse := NIL

    DEFAULT cPathFile := ""
    DEFAULT cNameFile := ""

    lOk       := oSign:uploadDocument(cPathFile)
    jResponse := oSign:getResponse()

    If lOk
        nId := jResponse["data"]

        // Envia solicitação para o usuário assinar
        If !lMRHTae
            lOk       := oSign:requestAction(jResponse["data"], {{SRA->RA_EMAIL, "0"}})
            jResponse := oSign:getResponse()
        Else
            oMRH := JsonObject():New()
            oMRH["tipoIdentificacao"] := 1 // Identificação Brasil (CPF/CNPJ)
            oMRH["tipoAutenticacao"]  := 2 // Autenticação por email
            oMRH["nomeCompleto"]      := AllTrim(SRA->RA_NOME)
            oMRH["identificacao"]     := Alltrim(SRA->RA_CIC)
            lOk                       := oSign:requestAction(jResponse["data"], {{Lower(Alltrim(SRA->RA_EMAIL)), "0", oMRH}})
            jResponse                 := oSign:getResponse()
        EndIf

        // Atualiza a tabela RS4
        GravaSR4(cNameFile, nId, lTAE, dPerIni, dPerFim, cCodeBar, oSign)
    EndIf
Return NIL

/*/{Protheus.doc} IntegTAE
    Realiza a geração do relatório e o integra com o TAE.
    @type Function
    @version 12.1.2310
    @author arthur.sales
    @since 10/05/2024
    @param jParam, JSON, Parâmetros do ON
    @param cFile, Character, Nome do arquivo do relatório
    @param lMRHTae, Logical, Método de assinatura do TAE caso o cliente utilize o MeuRH
    @param dPerIni, Date, Período inicial
    @param dPerFim, Date, Período final
    @param cCodeBar, Character, Código de barras
    @param dMarcIni, Date, Data de marcação inicial
    @param dMarcFim, Date, Data de marcação final
    @return Variant, Retorno nulo pré-fixado
/*/
Static Function IntegTAE(jParams As JSON, cFile As Character, lMRHTae As Logical, dPerIni As Date, dPerFim As Date, cCodeBar As Character, dMarcIni As Date, dMarcFim As Date) As Variant
    // Declaração das variáveis locais
    Local aMVParams As Array // Parâmetros para a createTask()

    // Inicialização das variáveis
    aMVParams := {}

    // Monta o vetor de parâmetros
    AAdd(aMVParams, dMarcIni)                                // Data De ?                    01
    AAdd(aMVParams, dMarcFim)                                // Data Até ?                   02
    AAdd(aMVParams, SRA->RA_FILIAL)                          // Filial  ?                    03
    AAdd(aMVParams, SRA->RA_MAT)                             // Matrícula ?                  04
    AAdd(aMVParams, Val(jParams["PrintHours"][1]))           // Imprime Horas ?              05 (Calculadas|Informadas|Ambas|N/A)
    AAdd(aMVParams, Val(jParams["ShowHours"][1]))            // Demonstra Horas ?            06 (Autorizadas|Não Autorizadas|Ambas)
    AAdd(aMVParams, IIf(jParams["WithoutPunch"][1],   1, 2)) // Func. sem marc. ?            07
    AAdd(aMVParams, Val(jParams["HoursType"][1]))            // Horas em ?                   08 (Sexagesimal|Centesimal)
    AAdd(aMVParams, IIf(jParams["PrintEvents"][1],    1, 2)) // Eventos do result. ?         09
    AAdd(aMVParams, IIf(jParams["PrintException"][1], 1, 2)) // Desc. Exceção afast. ?       10
    AAdd(aMVParams, IIf(jParams["PrintHoursBank"][1], 1, 2)) // Imp. banco horas ?           11
    AAdd(aMVParams, IIf(jParams["PrintExtraHour"][1], 1, 2)) // Imp. horas extras ?          12
    AAdd(aMVParams, IIf(jParams["PrintDisreg"][1],    1, 2)) // Imp. marc. desconsideradas ? 13
    AAdd(aMVParams, cFile)                                   // Nome do arquivo ?            14
    AAdd(aMVParams, lMRHTae)                                 // Método de assinatura TAE ?   15
    AAdd(aMVParams, dPerIni)                                 // Período inicial ?            16
    AAdd(aMVParams, dPerFim)                                 // Período final ?              17
    AAdd(aMVParams, cCodeBar)                                // Código de barras ?           18

    // Verifica se o ambiente está preparado para a execução em segundo plano e envio de notificações pelo EventViewer
    If (FwLibVersion() >= "20240408" .and. totvs.framework.smartschedule.startSchedule.smartSchedIsRunning() .and. totvs.framework.eventviewer.checkNewEventViewer())
        // Cria a tarefa para ser executada em segundo plano
        totvs.framework.schedule.utils.createTask(GetEnvServer(), cEmpAnt, cFilAnt, "PONA490", 16, RetCodUsr(), NIL, aMVParams)
    EndIf

    // Libera o vetor da memória
    FwFreeArray(aMVParams)
Return NIL

/*/{Protheus.doc} PONR010TReportsBusinessObject::getComboBox
    Retorna os valores de ComboBox do parâmetro requisitado.
    @type Method
    @version 12.1.2310
    @author arthur.sales
    @since 06/05/2024
    @return Variant, Retorno nulo pré-fixado
    @obs Path parameters: param (nome do parâmetro solicitado)
/*/
Method getComboBox() As Variant Class PONR010TReportsBusinessObject
    // Declaração das variáveis locais
    Local jPath     As JSON    // Path parameters da requisição
    Local jResponse As JSON    // Resposta da requisição
    Local jItem     As JSON    // Item do valor do parâmetro
    Local nValues   As Numeric // Contador dos valores do parâmetro
    Local aValues   As Array   // Valores do parâmetro

    // Inicialização das variáveis
    jPath     := oRest:getPathParamsRequest()
    jResponse := JSONObject():New()
    jItem     := NIL
    nValues   := 0
    aValues   := {}

    // Captura os path parameters da requisição
    If (jPath != NIL)
        cParam := jPath["param"]
    EndIf

    // Cria o atributo data e nextPageUrl no JSON de resposta
    jResponse["data"]        := {}
    jResponse["nextPageUrl"] := NIL

    // Verifica qual parâmetro foi solicitado
    If (cParam == "PrintHours")
        // Monta o vetor de valores do parâmetro
        AAdd(aValues, FwHTTPEncode(STR0091)) // "Calculadas"
        AAdd(aValues, FwHTTPEncode(STR0092)) // "Informadas"
        AAdd(aValues, FwHTTPEncode(STR0093)) // "Ambas"
        AAdd(aValues, FwHTTPEncode(STR0094)) // "N/A"
    ElseIf (cParam == "ShowHours")
        AAdd(aValues, FwHTTPEncode(STR0095)) // "Autorizadas"
        AAdd(aValues, FwHTTPEncode(STR0096)) // "Não Autorizadas"
        AAdd(aValues, FwHTTPEncode(STR0097)) // "Ambas"
    ElseIf (cParam == "HoursType")
        AAdd(aValues, FwHTTPEncode(STR0098)) // "Sexagesimal"
        AAdd(aValues, FwHTTPEncode(STR0099)) // "Centesimal"
    EndIf

    If (Len(aValues) > 0)
        // Percorre os valores adicionando cada item no JSON de resposta
        For nValues := 1 To Len(aValues)
            jItem := {;
                "key":   CValToChar(nValues),;
                "label": aValues[nValues];
            }
            AAdd(jResponse["data"], jItem)
        Next nValues
    EndIf

    // Define a resposta da requisição
    oRest:setResponse(jResponse)
    oRest:setStatusCode(200)
    oRest:setKeyHeaderResponse("Content-Type", "application/json; charset=utf-8")
    oRest:setKeyHeaderResponse("Accept-Encoding", "UTF-8")

    // Libera os objetos da memória
    FwFreeObj(jPath)
    FwFreeObj(jResponse)
    FwFreeObj(jItem)
    FwFreeArray(aValues)
Return NIL
