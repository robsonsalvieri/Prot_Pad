#Include "TOTVS.FRAMEWORK.TREPORTS.INTEGRATEDPROVIDER.th"
#Include "TLPP-CORE.th"
#Include "TLPP-REST.th"
#Include "rh.sv.gpe.gper200.ch"

namespace totvs.protheus.rh.treportsintegratedprovider

@totvsFrameworkTReportsIntegratedProvider(active=.T., team="SIGAGPE", tables="SRA", name="Relatório Aumento Salarial", country="ALL", initialRelease="12.1.2410")
class GPER200TReportsBusinessObject from totvs.framework.treports.integratedprovider.IntegratedProvider
    public method new() as object
    public method getData() as object
    public method getSchema() as object

    @Get("/api/rh/smartview/v1/options/GPER200/:param")
    public method getComboBox() as Variant
endclass

method new() class GPER200TReportsBusinessObject
    _Super:new()
    self:appendArea(STR0001)
    self:setDisplayName(STR0002)
    self:setDescription(STR0003)
return self

method getData(nPage as numeric, oFilter as object) as object class GPER200TReportsBusinessObject
    Local cFilExec              As Character
    Local cEmpExec              As Character
    Local cName                 As Character
    Local nPosFAtu              As Numeric
    Local jParams               As JSON
    Local aPDFields             As Array
    Local aAllFields            As Array
    Local nI                    As Numeric
    Local cInicio               As Character
    Local cFim                  As Character
    Local aInfo                 As Array
    Local cFilialAnt            As Character
    Local cFunAnt               As Character
    Local lProAdm               As Logical
    Local cCatMensal            As Character
    Local cAnoMesProp           As Character
    Local nPisoMes              As Numeric
    Local nPisoHora             As Numeric
    Local nPisoDia              As Numeric
    Local cAcessaSRA            As Character
    Local nSalario              As Numeric
    Local nSalHora              As Numeric
    Local nSalDia               As Numeric
    Local nSalMes               As Numeric
    Local nSalBase              As Numeric
    Local nBaseDis              As Numeric
    Local nNovoSal              As Numeric
    Local nNovoDis              As Numeric
    Local nReajSal              As Numeric
    Local nReajDis              As Numeric
    Local nBaseMes              As Numeric
    Local nDiaAux               As Numeric
    Local cMesAux               As Character
    Local nValArre              As Numeric
    Local nPerProp              As Numeric
    Local nSalAux               As Numeric
    Local nSalFaixa             As Numeric
    Local nPos                  As Numeric
    Local lPiso                 As Logical
    Local cAnoMes               As Character
    Local lIntegDef             As Logical
    Local cCodCCT               As Character
    Local cSindicato            As Character
    Local nCriterio             As Numeric
    Local nMesProp              As Numeric
    Local nAplAument            As Numeric
    Local cTipAum               As Character
    Local nTipAum               As Numeric
    Local dDatAum               As Date
    Local nAtuCad               As Numeric
    Local nAtuDiss              As Numeric
    Local cMatDe                As Character
    Local cMatAte               As Character
    Local cCcDe                 As Character
    Local cCcAte                As Character
    Local nNewHourSalary        As Numeric
    Local nArredondamento       As Numeric
    Local nValFaixa             As Numeric
    Local nReajuste             As Numeric
    Local jEmp                  As JSON
    Local aFuncoesNaoAtrib      As Array
    Local aFuncoes              As Array
    Local lAumento              As Logical
    Local lGravaAum             As Logical
    Local nOldHourSalary        As Numeric
    Local nPos8                 As Numeric
    Local nPos9                 As Numeric
    Local cCodFunc              As Character
    Local aFunctionGroups       As Array    // Array para agrupar por função
    Local jFunction             As JSON
    Local nFuncPos              As Numeric
    Local aBranchGroups         As Array    // Array para agrupar por filial
    Local jBranch               As JSON
    Local nBranchPos            As Numeric
    Local nAvgPercentual        As Numeric
    Local nTotalOldSalary       As Numeric
    Local nTotalOldHourSalary   As Numeric
    Local nTotalPercentual      As Numeric
    Local nTotalAdditionalValue As Numeric
    Local nTotalAdjustment      As Numeric
    Local nTotalNewSalary       As Numeric
    Local nTotalNewHourSalary   As Numeric
    Local nTotalRounding        As Numeric
    Local nTotalEmployees       As Numeric
    Local lAltFunc              As Logical
    Local cRaCodFunc            As Character
    Local jLGPD                 As JSON
    Local lOfuscaNom            As Logical
    Local lTemCCT               As Logical
    Local lCcInformado          As Logical
    Local lAtuSalAux            As Logical

    Private aFaixas             As Array
    Private cCategoria          As Character
    Private cFilDe              As Character  
    Private cFilAte             As Character   
    Private cFunDe              As Character  
    Private cFunAte             As Character  
    Private nPercDif            As Numeric    
    Private nValAum             As Numeric    
    Private nArredonda          As Numeric    
    Private nVlPiso             As Numeric     
    Private nUpdFuncao          As Numeric  
    Private nOrdem              As Numeric 
    Private lSalCCT             As Logical
    Private lUsaRI4             As Logical
    Private lGestPubl           As Logical

    cFilExec            := AllTrim(FwFilialName())
    cEmpExec            := AllTrim(FwEmpName(cEmpAnt))
    cName               := ""
    nUpdFuncao          := 0
    cCategoria          := "M*C*P*A*E*S*I" // Padrão
    jParams             := oFilter:getParameters()
    nI                  := 1
    nOrdem              := 1
    cInicio             := ""
    cFim                := ""
    aInfo               := {}
    cFilialAnt          := ""
    cFunAnt             := ""
    lProAdm             := .F.
    cCatMensal          := "M*C*P*A*E*S*I"
    lGestPubl           := if(ExistFunc("fUsaGFP"),fUsaGFP(),.f.)
    cAnoMesProp         := ""
    nPisoMes            := 0
    nPisoHora           := 0
    nPisoDia            := 0
    cAcessaSRA          := ""
    nSalario            := 0
    nSalHora            := 0
    nSalDia             := 0
    nSalMes             := 0
    nSalBase            := 0
    nBaseDis            := 0
    nNovoSal            := 0
    nNovoDis            := 0
    nReajSal            := 0
    nReajDis            := 0
    nBaseMes            := 0
    nDiaAux             := 0
    cMesAux             := ""
    nValArre            := 0
    nPerProp            := 0
    nSalAux             := 0
    nSalFaixa           := 0
    nPos                := 0
    lPiso               := .F.
    nPercDif            := 0
    nValAum             := 0
    cAnoMes             := ""
    lIntegDef           := .F.
    lSalCCT             := .F.
    lTemCCT             := .F.
    lUsaRI4             := .F.
    cCodCCT             := ""
    cSindicato          := ""
    nCriterio           := 0
    nArredonda          := 0
    nMesProp            := 0
    nAplAument          := 0
    nVlPiso             := 0
    cTipAum             := ""
    nTipAum             := 0
    dDatAum             := CtoD("//")
    nAtuCad             := 0
    nAtuDiss            := 0
    cMatDe              := ""
    cMatAte             := ""
    cCcDe               := ""
    cCcAte              := ""
    cFunDe              := ""
    cFunAte             := ""
    cFilDe              := ""
    cFilAte             := ""
    lAltFunc            := .T.
    cRaCodFunc          := ""
    jLGPD               := JSONObject():New()
    lOfuscaNom          := .F.
    aFaixas             := {}
    aFuncoes            := {}
    lAumento            := .F.
    lGravaAum           := .F.
    aFuncoesNaoAtrib    := {}
    aFunctionGroups     := {}
    aBranchGroups       := {}
    nTotalOldSalary     := 0
    nTotalOldHourSalary := 0
    nTotalPercentual    := 0
    nTotalAdditionalValue := 0
    nTotalAdjustment    := 0
    nTotalNewSalary     := 0
    nTotalNewHourSalary := 0
    nTotalRounding      := 0
    nTotalEmployees     := 0
    cCcAnt              := ""
    cFuAnt              := ""
    nPosFAtu            := 0
    lIntegDef           := FindFunction("GETROTINTEG") .And. FindFunction("FWHASEAI")
    lSalCCT             := .F.
    lTemCCT             := cPaisLoc == "BRA" .and. RCE->(ColumnPos("RCE_CCT")) > 0
    lUsaRI4             := cPaisLoc == "BRA" .and. AliasInDic("RI4") .and. RI4->(ColumnPos( "RI4_SALARI" )) > 0
    cName               := ""
    aPDFields           := {}
    aAllFields          := {}
    jLGPD               := JSONObject():New()
    aPDFields           := FwProtectedDataUtil():UsrAccessPDField(__cUserID, self:getArrayFields())
    aAllFields          := self:getStructFields()
    lAtuSalAux          := .T.

    // Adiciona no JSON todos os campos como atributos
    For nI := 1 To Len(aAllFields)
        cName        := Trim(aAllFields[nI]:getName())
        jLGPD[cName] := AScan(aPDFields, {|x| Trim(x) == cName}) <= 0
    Next nI

    // Gestão Pública
    IF lGestPubl
        cCatMensal += "*0*1*2*3*4*5*6*7*8*9"
    EndIf

    // Parâmetros
    If (jParams != NIL)
        cFilDe              := PADR(IIf(jParams:hasProperty("BranchCodeFrom")     .AND. Len(jParams["BranchCodeFrom"])     > 0 .AND. !Empty(jParams["BranchCodeFrom"][1]),     jParams["BranchCodeFrom"][1], ""), TAMSX3("RA_FILIAL")[1])
        cFilAte             := PADR(IIf(jParams:hasProperty("BranchCodeTo")       .AND. Len(jParams["BranchCodeTo"])       > 0 .AND. !Empty(jParams["BranchCodeTo"][1]),       jParams["BranchCodeTo"][1], Replicate("Z", GetSX3Cache("RA_FILIAL", "X3_TAMANHO"))), TAMSX3("RA_FILIAL")[1])
        
        cCcDe               := IIf(jParams:hasProperty("CostCenterCodeFrom") .AND. Len(jParams["CostCenterCodeFrom"]) > 0 .AND. !Empty(jParams["CostCenterCodeFrom"][1]), jParams["CostCenterCodeFrom"][1], "")
        cCcAte              := IIf(jParams:hasProperty("CostCenterCodeTo")   .AND. Len(jParams["CostCenterCodeTo"])   > 0 .AND. !Empty(jParams["CostCenterCodeTo"][1]),   jParams["CostCenterCodeTo"][1], Replicate("Z", GetSX3Cache("RA_CC", "X3_TAMANHO")))
        
        cMatDe              := IIf(jParams:hasProperty("EmployeeCodeFrom")   .AND. Len(jParams["EmployeeCodeFrom"])   > 0 .AND. !Empty(jParams["EmployeeCodeFrom"][1]),   jParams["EmployeeCodeFrom"][1], "")
        cMatAte             := IIf(jParams:hasProperty("EmployeeCodeTo")     .AND. Len(jParams["EmployeeCodeTo"])     > 0 .AND. !Empty(jParams["EmployeeCodeTo"][1]),     jParams["EmployeeCodeTo"][1], Replicate("Z", GetSX3Cache("RA_MAT", "X3_TAMANHO")))
        
        cFunDe              := IIf(jParams:hasProperty("FunctionCodeFrom")   .AND. Len(jParams["FunctionCodeFrom"])   > 0 .AND. !Empty(jParams["FunctionCodeFrom"][1]),   jParams["FunctionCodeFrom"][1], "")
        cFunAte             := IIf(jParams:hasProperty("FunctionCodeTo")     .AND. Len(jParams["FunctionCodeTo"])     > 0 .AND. !Empty(jParams["FunctionCodeTo"][1]),     jParams["FunctionCodeTo"][1], Replicate("Z", GetSX3Cache("RA_CODFUNC", "X3_TAMANHO")))
        
        nTipAum             := IIf(jParams:hasProperty("IncreaseBase")       .AND. Len(jParams["IncreaseBase"])       > 0 .AND. !Empty(jParams["IncreaseBase"][1]),       Val(jParams["IncreaseBase"][1])   , 1)
        cTipAum             := IIf(jParams:hasProperty("IncreaseType")       .AND. Len(jParams["IncreaseType"])       > 0 .AND. !Empty(jParams["IncreaseType"][1]),       jParams["IncreaseType"][1]        , "1")
        dDatAum             := IIf(jParams:hasProperty("IncreaseDate")       .AND. Len(jParams["IncreaseDate"])       > 0 .AND. !Empty(jParams["IncreaseDate"][1]),       fConvertIsoToDate(jParams["IncreaseDate"][1]), dDataBase)

        nAtuCad             := IIf(jParams:hasProperty("UpdateRegister")     .AND. Len(jParams["UpdateRegister"])     > 0 .AND. !Empty(jParams["UpdateRegister"][1]),     Val(jParams["UpdateRegister"][1]), 1)
        nUpdFuncao          := IIf(jParams:hasProperty("UpdateFunc")         .AND. Len(jParams["UpdateFunc"])         > 0 .AND. !Empty(jParams["UpdateFunc"][1]),         Val(jParams["UpdateFunc"][1]), 3)
        nAtuDiss            := IIf(jParams:hasProperty("UpdateDissidio")     .AND. Len(jParams["UpdateDissidio"])     > 0 .AND. !Empty(jParams["UpdateDissidio"][1]),     Val(jParams["UpdateDissidio"][1]), 1)
        lProAdm             := IIf(jParams:hasProperty("Proportional")       .AND. Len(jParams["Proportional"])       > 0 .AND. !Empty(jParams["Proportional"][1]),       Val(jParams["Proportional"][1]) == 2, .F.)
        cCodCCT             := IIf(jParams:hasProperty("CollectiveAgreement").AND. Len(jParams["CollectiveAgreement"]) > 0 .AND. !Empty(jParams["CollectiveAgreement"][1]), jParams["CollectiveAgreement"][1], "")
        cSindicato          := IIf(jParams:hasProperty("Union")              .AND. Len(jParams["Union"])              > 0 .AND. !Empty(jParams["Union"][1]),              jParams["Union"][1], "")
        nCriterio           := IIf(jParams:hasProperty("RoundingType")       .AND. Len(jParams["RoundingType"])       > 0 .AND. !Empty(jParams["RoundingType"][1]),       Val(jParams["RoundingType"][1]), 1)
        nArredonda          := IIf(jParams:hasProperty("RoundingValue")      .AND. Len(jParams["RoundingValue"])      > 0 .AND. !Empty(jParams["RoundingValue"][1]),      jParams["RoundingValue"][1], 0)
        nMesProp            := IIf(jParams:hasProperty("MonthsProp")         .AND. Len(jParams["MonthsProp"])         > 0 .AND. !Empty(jParams["MonthsProp"][1]),         jParams["MonthsProp"][1], 12)
        nAplAument          := IIf(jParams:hasProperty("ApplyIncrease")      .AND. Len(jParams["ApplyIncrease"])      > 0 .AND. !Empty(jParams["ApplyIncrease"][1]),      Val(jParams["ApplyIncrease"][1]), 3)

        fGetFaixasFromTable() // Preenche os campos aFaixas e cCategoria
    EndIf

    lCcInformado := !Empty(cCcDe) .or. cCcAte != Replicate("Z", GetSX3Cache("RA_CC", "X3_TAMANHO"))

    //Captura pisos salariais
    fGetPisoFromTable(@nPisoMes, @nPisoHora, @nPisoDia)
    
    // Configuração do mês proporcional
    If Month(dDatAum) == 1
        cAnoMesProp := strzero(Year(dDatAum)-1, 4) + "12"
    Else
        cAnoMesProp := Strzero(Year(dDatAum), 4) + strzero(month(dDatAum)-1, 2)
    EndIf
    
    Do Case
        Case nUpdFuncao == 1 .or. nUpdFuncao == 2 .or. nUpdFuncao == 3
            nOrdem := 3  // Por função 
        Case lCcInformado
            nOrdem := 2  // Por centro de custo
        Otherwise
            nOrdem := 1  // Por matrícula
    EndCase
    
    // Configuração do acesso ao SRA
    cAcessaSRA := &("{ || " + ChkRH("GPER200", "SRA", "2") + " }")
    
    // Seleciona a área SRA
    dbSelectArea("SRA")

    If nOrdem == 1
        SRA->(dbSetOrder(1))
    ElseIf nOrdem == 2
        SRA->(dbSetOrder(2))
    ElseIf nOrdem == 3
        SRA->(dbSetOrder(7))
    Endif

    SRA->(dbGoTop())
    
    If nOrdem == 1
        SRA->(dbSeek(cFilDe + cMatDe, .T.))
        cInicio := "SRA->RA_FILIAL + SRA->RA_MAT"
        cFim    := cFilAte + cMatAte
    ElseIf nOrdem == 2
        SRA->(dbSeek(cFilDe + cCcDe + cMatDe, .T.))
        cInicio := "SRA->RA_FILIAL + SRA->RA_CC + SRA->RA_MAT"
        cFim    := cFilAte + cCcAte + cMatAte
    ElseIf nOrdem == 3
        SRA->(dbSeek(cFilDe + cFunDe, .T.))
        cInicio := "SRA->RA_FILIAL + SRA->RA_CODFUNC"
        cFim    := cFilAte + cFunAte
    Endif
    
    If Len(aFaixas) == 0
        Return self:oData
    EndIf
    
    // Inicialização das variáveis de controle
    cFilialAnt := Replicate("!", FwSizeFilial())
    cfunAnt    := Space(4)
    
    While !EOF() .And. &cInicio <= cFim
        
        // Nao permite Dt. Alteracao Salarial menor que Dt.Admissao
        If !Empty(dDatAum) .And. dDatAum < SRA->RA_ADMISSA
            dbSkip()
            Loop
        EndIf
        
        If SRA->RA_FILIAL != cFilialAnt
            If !fInfo(@aInfo, SRA->RA_FILIAL)
                Exit
            Endif
            dbSelectArea("SRA")
            cFilialAnt := SRA->RA_FILIAL
        Endif
        
        If cFunAnt != SRA->RA_CODFUNC
            lAumento  := .F.
            lGravaAum := .F.
            cFunAnt   := SRA->RA_CODFUNC
        Endif
        
        // Consiste Parametrizacao do Intervalo de Impressao
        If  (SRA->RA_MAT     < cMatDe) .Or. (SRA->RA_MAT     > cMatAte) .Or. ;
            (SRA->RA_CC      < cCcDe)  .Or. (SRA->RA_CC      > cCcAte)  .Or. ;
            (SRA->RA_CODFUNC < cFunDe) .Or. (SRA->RA_CODFUNC > cFunAte) .Or. ;
            (SRA->RA_FILIAL  < cFilDe) .Or. (SRA->RA_FILIAL  > cFilAte)
            dbSkip()
            Loop
        EndIf
        
        // Se Gestao de Folha Publica - SIGAGFP, nao permite reajuste quando ha tabela no SRA
        If lGestPubl .and. !empty(SRA->RA_TABELA)
            dbSkip()
            Loop
        EndIf
        
        // Consiste Filiais e Acessos
        IF !(SRA->RA_FILIAL $ fValidFil()) .or. !Eval(cAcessaSRA)
            dbSkip()
            Loop
        EndIF
        
        // Verifica a Categoria e Situacao do Funcionario
        If !(SRA->RA_CATFUNC $ cCategoria) .Or. !(SRA->RA_SITFOLH $ " *F*A*I")
            dbSkip()
            Loop
        Endif

        // Ponto de Entrada para não considerar o funcionario
        If ExistBlock("GPVLDFUN")
            If Execblock("GPVLDFUN", .F., .F.,)
                dbSkip()
                Loop
            EndIf
        Endif
        
        // Verifica CCT se informado
        If !Empty(cCodCCT) .AND. lTemCCT
            If Empty(SRA->RA_SINDICA) .or. (RCE->(DbSeek(xFilial("RCE", SRA->RA_FILIAL) + SRA->RA_SINDICA)) .and. RCE->RCE_CCT <> cCodCCT)
                dbSkip()
                Loop
            EndIf
        EndIf
        
        // Verifica sindicato
        If !Empty(cSindicato)
            If SRA->RA_SINDICA <> cSindicato
                dbSkip()
                Loop
            EndIf
        EndIf
        
        // Verifica se o funcionario ja foi reajustado nesta data
        If SR7->(dbSeek(SRA->RA_FILIAL + SRA->RA_MAT + Dtos(dDatAum)))
            If nAplAument == 1  // Nao reajustados
                dbSkip()
                Loop
            EndIF
        Else
            If nAplAument == 2  // Reajustados
                dbSkip()
                Loop
            EndIF
        EndIf
        
        cAnoMes := MesAno(dDatAum)
        // Calcula Salario Mes, Dia, Hora do Funcionario
        fSalario(@nSalario, @nSalHora, @nSalDia, @nSalMes, "A", cAnoMes, , SRA->RA_CATFUNC)
        
        // Verifica a Faixa em Que o Salario Vai Entrar
        If nOrdem != 3
            IF nTipAum == 1 //Dissidio
                nSalFaixa := 0
                fSalBase(@nSalFaixa, cAnoMes, , SRA->RA_CATFUNC)
            else
                nSalFaixa := nSalMes
            EndIf

            nPos := Ascan(aFaixas, { |X| (nSalFaixa >= X[1] .And. nSalFaixa <= X[2]) .AND.;
                                           IF(!empty(x[5]),(SRA->RA_ADMISSA >=X[5] .AND. SRA->RA_ADMISSA <=X[6]),.T.)})	
        Else
            // Seleciona área SRJ para buscar informações da função
            dbSelectArea("SRJ")
            If SRJ->(dbSeek(xFilial("SRJ", SRA->RA_FILIAL) + SRA->RA_CODFUNC))
                cFuncCCT := ""
                If (lAtuSalAux == .T.) .OR. (cRaCodFunc != SRA->RA_CODFUNC) .OR. lUsaRI4
                    nSalAux 	:= fGetSalFunc(@cFuncCCT, lUsaRI4)
                EndIf 
                
                nPos := Ascan(aFaixas, { |X| (nSalAux >= X[1] .And. nSalAux <= X[2] ) .AND. If(!Empty(x[5]),(SRA->RA_ADMISSA >=X[5] .AND. SRA->RA_ADMISSA <=X[6]),.T.)})
                
                // Armazena as funções que sofrerão aumentos dentro dos intervalos escolhidos
                nPos8 := Ascan(aFaixas, { |X| (nSalAux >= X[1] .And. nSalAux <= X[2] ) })
                nPos9 := AScan(aFuncoes, {|X| X[1]+X[2]+X[4] == SRJ->(RJ_FILIAL+RJ_FUNCAO)+cFuncCCT})
                If nPos8 > 0 .and. nPos9 <= 0
                    AAdd(aFuncoes, {SRJ->RJ_FILIAL, SRJ->RJ_FUNCAO, nSalAux, cFuncCCT})
                EndIf
            EndIf
            dbSelectArea("SRA")
        Endif
        
        // Se o salário não entrar nas faixas, ler o próximo funcionário
        If nPos == 0
            dbSkip()
            Loop
        Endif
        
        // Inicialização das variáveis de cálculo
        nPerProp := 0
        nSalBase := 0
        nBaseDis := 0
        nNovoSal := 0
        nNovoDis := 0
        nPercDif := 0
        nValAum  := 0
        
        // Ponto de Entrada para alterar percentual ou valor
        If ExistBlock("GPM690PERC")
            ExecBlock("GPM690PERC", .F., .F.)
        Endif
        
        // Calculo do Reajuste e Salario Novo
        If nUpdFuncao != 2
            If nOrdem != 3 //nao e por funcao
                If nTipAum == 1  //Dissidio
                    IF SRA->RA_CATFUNC $ cCatMensal
                        nSalBase := nSalMes
                    ElseIf SRA->RA_CATFUNC == "D"
                        nSalBase := nSalDia
                    Else
                        nSalBase := nSalHora
                    EndIf
                    
                    nBaseDis := SRA->RA_ANTEAUM
                    nNovoDis := nBaseDis
                    nNovoSal := nSalBase
                    nNovoDis := nBaseDis * (1 + (IIF(nPercDif > 0, nPercDif, aFaixas[nPos,3]) / 100))
                    nNovoDis := nNovoDis + IIF(nValAum > 0, nValAum, aFaixas[nPos,4])
                ElseIf nTipAum == 2 //Antecipacao
                    IF SRA->RA_CATFUNC $ cCatMensal
                        nSalBase := nSalMes
                    ElseIf SRA->RA_CATFUNC == "D"
                        nSalBase := nSalDia
                    Else
                        nSalBase := nSalHora
                    EndIf
                    
                    nBaseDis := SRA->RA_ANTEAUM
                    nNovoDis := nBaseDis
                    nNovoSal := nSalBase
                    nNovoSal := nSalBase * (1 + (IIF(nPercDif > 0, nPercDif, aFaixas[nPos,3]) / 100))
                    nNovoSal := nNovoSal + IIF(nValAum > 0, nValAum, aFaixas[nPos,4])
                ElseIf nTipAum == 3 // Aumento Real
                    IF SRA->RA_CATFUNC $ cCatMensal
                        nSalBase := nSalMes
                    ElseIf SRA->RA_CATFUNC == "D"
                        nSalBase := nSalDia
                    Else
                        nSalBase := nSalHora
                    EndIf
                    nNovoSal := nSalBase * (1 + (IIF(nPercDif > 0, nPercDif, aFaixas[nPos,3]) / 100))
                    nNovoSal := nNovoSal + IIF(nValAum > 0, nValAum, aFaixas[nPos,4])
                    nNovoDis := nNovoSal
                    nBaseDis := Max(SRA->RA_ANTEAUM, nSalBase)
                Endif
            Else
                // Para outros tipos de nUpdFuncao, usa a lógica original
                If (nPosFAtu := aScan(aFuncoes, {|X| X[1]+X[2]+X[4] == SRJ->(RJ_FILIAL + RJ_FUNCAO)+cFuncCCT})) > 0
                    nSalBase := aFuncoes[nPosFAtu, 3]
                    nNovoSal := aFuncoes[nPosFAtu, 3]
                Else
                    nSalBase := fGetSalFunc("", lUsaRI4)
                    nNovoSal := fGetSalFunc("", lUsaRI4)				
                EndIf
                
                fCalcNewSal(nSalBase, aFaixas, nPos, lAumento, @nNovoSal, @nBaseDis, @nNovoDis, nTipAum, nPercDif, nValAum, nUpdFuncao)
            Endif

            // Calculo Proporcional do Aumento Salario
            If lProAdm .And. nOrdem != 3
                nBaseMes  := ((Val(SubStr(cAnoMesProp,1,4)) * 12) + Val(SubStr(cAnoMesProp,5,2))) - ((Year(SRA->RA_ADMISSA) * 12) + Month(SRA->RA_ADMISSA))
                nBaseMes  := If(nBaseMes < 0,0, nBaseMes)
                cMesAux   := StrZero(Month(SRA->RA_ADMISSA),2)
                If cMesAux $ "01*03*05*07*08*10*12"
                    nDiaAux = 31
                ElseIf cMesAux $ "04*06*09*11"
                    nDiaAux = 30
                Else
                    If Mod(Year(SRA->RA_ADMISSA), 4) = 0
                        nDiaAux = 29
                    Else
                        nDiaAux = 28
                    Endif
                Endif
                If nDiaAux - Day(SRA->RA_ADMISSA) + 1 >= 15
                    nBaseMes := nBaseMes + 1
                Endif

                // P.E. para alterar os meses proporcionais
                If ExistBlock("GPREAJPROP")
                    ExecBlock("GPREAJPROP", .F., .F.)
                Endif
            Else
                nBaseMes := 12
            Endif

            If nBaseMes < nMesProp
                nReajSal := ((nNovoSal - nSalBase) * nBaseMes) / nMesProp
                nReajDis := ((nNovoDis - nBaseDis) * nBaseMes) / nMesProp
                nNovoSal := (nSalBase + nReajSal)
                nNovoDis := (nBaseDis + nReajDis)
                nPerProp := (IIF(nPercDif > 0, nPercDif, aFaixas[nPos,3]) * nBaseMes) / nMesProp
            Else
                nReajSal := nNovoSal - nSalBase
                nReajDis := nNovoDis - nBaseDis
            Endif
            
            // Calcula com os Criterios de Arredondamento
            If nOrdem != 3
                If nCriterio == 1
                    nNovoDis := NoRound(nNovoDis)
                    nReajDis := NoRound(nReajDis)
                    nNovoSal := NoRound(nNovoSal)
                    nReajSal := NoRound(nReajSal)
                ElseIf nCriterio == 2
                    nNovoDis := Round(nNovoDis, MsDecimais(1))
                    nReajDis := Round(nReajDis, MsDecimais(1))
                    nNovoSal := Round(nNovoSal, MsDecimais(1))
                    nReajSal := Round(nReajSal, MsDecimais(1))
                Else
                    If nNovoDis - Round(nNovoDis, MsDecimais(1)) > 0.00
                        nNovoDis := NoRound((nNovoDis + .01), MsDecimais(1))
                    Else
                        nNovoDis := Round(nNovoDis, MsDecimais(1))
                        nReajDis := Round(nReajDis, MsDecimais(1))
                    Endif
                    If nNovoSal - Round(nNovoSal, MsDecimais(1)) > 0.00
                        nNovoSal := NoRound((nNovoSal + .01), MsDecimais(1))
                    Else
                        nNovoSal := Round(nNovoSal, MsDecimais(1))
                        nReajSal := Round(nReajSal, MsDecimais(1))
                    Endif
                Endif
                
                If nArredonda != 0
                    nValArre := 0
                    CalcArre(@nNovoDis, nArredonda, @nValArre)
                    CalcArre(@nNovoSal, nArredonda, @nValArre)
                Endif
            Else
                If nArredonda != 0
                    nValArre := 0
                    CalcArre(@nNovoDis, nArredonda, @nValArre)
                    CalcArre(@nNovoSal, nArredonda, @nValArre)
                Else
                    If nCriterio == 1
						nNovoDis := NoRound(nNovoDis)
						nReajDis := NoRound(nReajDis)
						nNovoSal := NoRound(nNovoSal)
						nReajSal := NoRound(nReajSal)
					ElseIf nCriterio == 2
						nNovoDis := Round(nNovoDis,MsDecimais(1))
						nReajDis := Round(nReajDis,MsDecimais(1))
						nNovoSal := Round(nNovoSal,MsDecimais(1))
						nReajSal := Round(nReajSal,MsDecimais(1))
					Else	
						If nNovoDis - Round(nNovoDis,MsDecimais(1)) > 0.00
							nNovoDis := NoRound((nNovoDis + .01),MsDecimais(1))
						Else
							nNovoDis := Round(nNovoDis,MsDecimais(1))
							nReajDis := Round(nReajDis,MsDecimais(1))
						Endif
						If nNovoSal - Round(nNovoSal,MsDecimais(1)) > 0.00
							nNovoSal := NoRound((nNovoSal + .01),MsDecimais(1))
						Else
							nNovoSal := Round(nNovoSal,MsDecimais(1))
							nReajSal := Round(nReajSal,MsDecimais(1))
						Endif
					Endif
                Endif
            Endif
            
            // APLICAÇÃO DO PISO SALARIAL
            If SRA->RA_CATFUNC $ cCatMensal
                lPiso := (nNovoSal > 0 .and. nPisoMes > nNovoSal)
                nNovoSal := If(lPiso, nPisoMes, nNovoSal)
                nNovoDis := If(nNovoDis > 0 .and. nPisoMes > nNovoDis, nPisoMes, nNovoDis)
                nReajSal := If(nNovoSal == nPisoMes, nNovoSal - nSalBase, nReajSal)
                nReajDis := If(nNovoDis == nPisoMes, nNovoDis - nBaseDis, nReajDis)
            ElseIf SRA->RA_CATFUNC $ "D"
                lPiso := (nNovoSal > 0 .and. nPisoDia > nNovoSal)
                nNovoSal := If(lPiso, nPisoDia, nNovoSal)
                nNovoDis := If(nNovoDis > 0 .and. nPisoDia > nNovoDis, nPisoDia, nNovoDis)
                nReajSal := If(nNovoSal == nPisoDia, nNovoSal - nSalBase, nReajSal)
                nReajDis := If(nNovoDis == nPisoDia, nNovoDis - nBaseDis, nReajDis)
            Else
                lPiso := (nNovoSal > 0 .and. nPisoHora > nNovoSal)
                nNovoSal := If(lPiso, nPisoHora, nNovoSal)
                nNovoDis := If(nNovoDis > 0 .and. nPisoHora > nNovoDis, nPisoHora, nNovoDis)
                nReajSal := If(nNovoSal == nPisoHora, nNovoSal - nSalBase, nReajSal)
                nReajDis := If(nNovoDis == nPisoHora, nNovoDis - nBaseDis, nReajDis)
            EndIf
            
            // Quando o Tipo de Pagamento For Semanal
            IF SRA->(RA_TIPOPGT = "S" .and. RA_CATFUNC $ "S*T")
                nNovoSal := ((nNovoSal / 30) * 7)
                nNovoDis := ((nNovoDis / 30) * 7)
            EndIF
            
            // Calcula percentual proporcional
            nPerProp := If(nPerProp > 0, nPerProp, IIF(nPercDif > 0, nPercDif, aFaixas[nPos,3]))
            
            // Ponto de Entrada para alterar percentual ou valor do aumento aplicado
            If ExistBlock("GPALTSAL")
                Execblock("GPALTSAL", .F., .F.,)
            Endif

            // Declaração das variáveis para o JSON do funcionário
            nNewHourSalary  := 0
            nArredondamento := nValArre
            nValFaixa       := IIF(nValAum > 0, nValAum, IIf(aFaixas[nPos,4] != NIL .And. ValType(aFaixas[nPos,4]) == "C", Val(aFaixas[nPos,4]), IIf(aFaixas[nPos,4] != NIL .And. ValType(aFaixas[nPos,4]) == "N", aFaixas[nPos,4], 0)))
            nReajuste       := 0
            nOldHourSalary  := 0
    
            // Cálculo dos valores baseado no tipo de aumento
            If nTipAum != 1 .Or. nUpdFuncao == 1 // diferente de dissidio
                nReajuste := nReajSal
                
                If SRA->RA_CATFUNC $ "H*T*G*J"
                    nNewHourSalary := nNovoSal
                    nOldHourSalary := nSalBase
                ElseIf SRA->RA_CATFUNC $ "D"
                    nNewHourSalary := (nNovoSal * 30) / SRA->RA_HRSMES
                    nOldHourSalary := (nSalBase * 30) / SRA->RA_HRSMES
                Else
                    nNewHourSalary := nNovoSal / SRA->RA_HRSMES
                    nOldHourSalary := nSalBase / SRA->RA_HRSMES
                EndIf
            Else // dissidio
                nReajuste := nReajDis
                
                If SRA->RA_CATFUNC $ "H*T*G*J"
                    nNewHourSalary := nNovoDis
                    nOldHourSalary := nBaseDis
                ElseIf SRA->RA_CATFUNC $ "D"
                    nNewHourSalary := (nNovoDis * 30) / SRA->RA_HRSMES
                    nOldHourSalary := (nBaseDis * 30) / SRA->RA_HRSMES
                Else
                    nNewHourSalary := nNovoDis / SRA->RA_HRSMES
                    nOldHourSalary := nBaseDis / SRA->RA_HRSMES
                EndIf
                
                // Para dissídio, usar valores do dissídio
                nSalBase := nBaseDis
                nNovoSal := nNovoDis
            Endif

            // Adicionar acumulação dos totais
            nTotalOldSalary       += nSalBase
            nTotalOldHourSalary   += nOldHourSalary
            nTotalPercentual      += IIF(nPercDif > 0, nPercDif, aFaixas[nPos,3]) 
            nTotalAdditionalValue += nValFaixa
            nTotalAdjustment      += nReajuste
            nTotalNewSalary       += nNovoSal
            nTotalNewHourSalary   += nNewHourSalary
            nTotalRounding        += nArredondamento
            nTotalEmployees       += 1
    
            If nAtuCad == 2
                
                // Verifica se deve alterar função
                If nTipAum == 3 .And. (nUpdFuncao == 1 .Or. nUpdFuncao == 3) .And. nAtuCad == 2
                    nPosAux  := 0
                    lAltFunc := (nPosAux := Ascan(aFaixas, {|X| (nSalMes >= X[1] .And. nSalMes <= X[2] ) .AND. If(!Empty(x[5]), (SRA->RA_ADMISSA >= X[5] .AND. SRA->RA_ADMISSA <= X[6]), .T.)})) > 0
                    nPos     := If(nPos == 0, nPosAux, nPos)
                EndIf

                If lAltFunc 
                    // Variaveis de memoria para uso em fGravaSr3()
                    M->RA_CC      := SRA->RA_CC
                    M->RA_CARGO   := SRA->RA_CARGO              
                    M->RA_ANTEAUM := SRA->RA_ANTEAUM
                    M->RA_SALARIO := SRA->RA_SALARIO
                    
                    // Desativa restricao de acesso para garantir a gravação correta das tabelas
                    If FindFunction("SPFilTerOff")
                        SPFilTerOff( { "SR3", "SR7" } )
                    Endif

                    // Grava as Informacoes no SR3 e SR7 - USA A FUNÇÃO DO SISTEMA
                    fGravaSr3(dDatAum, cTipAum, If(nTipAum != 1, If(nNovoDis > nNovoSal, nNovoDis, nNovoSal), nNovoDis), nAtuCad,, nAtuDiss)
                    
                    // Ativa novamente a restrição de acesso
                    If FindFunction("SPFilTerOff")
                        SPFilTerOff( { "SR3", "SR7" }, .F. )
                    Endif

                    // Ponto de Entrada para atualizar tabela personalizada
                    If ExistBlock("GPALTSAL")
                        Execblock("GPALTSAL", .F., .F.,)
                    Endif

                    // Atualizando SRA - EXATAMENTE IGUAL AO RELATÓRIO ANTIGO
                    dbSelectArea("SRA")
                    RecLock("SRA", .F.)
                    SRA->RA_SALARIO := If(nNovoDis > nNovoSal, nNovoDis, nNovoSal)
                    
                    If lGestPubl  // Se Gestao de Folha Publica - SIGAGFP
                        SRA->RA_SUBCARR := If(nNovoDis > nNovoSal, nNovoDis, nNovoSal)
                        SRA->RA_ANTEAUM := nNovoDis
                    EndIf
                    
                    If nAtuDiss == 2 
                        SRA->RA_ANTEAUM := If(!Empty(nNovoDis), nNovoDis, SRA->RA_SALARIO)
                    Endif
                    
                    MsUnlock()
                    
                    // Ponto de Entrada executado apos atualizacao dos cadastros
                    If ExistBlock("GPR200ATU")
                        Execblock("GPR200ATU", .F., .F.,)
                    Endif
                EndIf

                // Atualizando SRJ se necessário
                If (nUpdFuncao == 1 .or. nUpdFuncao == 3) .and. nNovoSal > 0
                    fGravaSRJ(@lGravaAum,@lAumento, nNovoSal, SRA->RA_CODFUNC )
                    cRaCodFunc 	:= SRA->RA_CODFUNC
                    lAtuSalAux 	:= .F. 
                    lGravaAum 	:= .F.
                    lAumento  	:= .F.
                Endif
            EndIf

            If nUpdFuncao == 1 .OR. nUpdFuncao == 3 
                // Agrupa por função
                nFuncPos := AScan(aFunctionGroups, {|x| x["BranchCodePerFunc"] + x["FunctionCodePerFunc"] == AllTrim(SRA->RA_FILIAL) + AllTrim(SRA->RA_CODFUNC)})
                
                If nFuncPos == 0
                    // Cria novo grupo de função
                    jFunction := JSONObject():New()
                    jFunction["BranchCodePerFunc"]          := AllTrim(SRA->RA_FILIAL)
                    jFunction["BranchNamePerFunc"]          := IIf(Len(aInfo) > 0, AllTrim(aInfo[1]), "")
                    jFunction["FunctionCodePerFunc"]        := AllTrim(SRA->RA_CODFUNC)
                    jFunction["FunctionNamePerFunc"]        := AllTrim(Posicione("SRJ", 1, xFilial("SRJ", SRA->RA_FILIAL) + SRA->RA_CODFUNC, "RJ_DESC"))
                    jFunction["OldSalaryPerFunc"]           := nSalBase
                    jFunction["OldHourSalaryPerFunc"]       := nSalBase / 220
                    jFunction["PercentualPerFunc"]          := IIF(nPercDif > 0, nPercDif, aFaixas[nPos,3])
                    jFunction["AdditionalValuePerFunc"]     := nValFaixa
                    jFunction["AdjustmentPerFunc"]          := nReajuste
                    jFunction["NewSalaryPerFunc"]           := nNovoSal
                    jFunction["NewHourSalaryPerFunc"]       := nNovoSal / 220
                    jFunction["RoundingPerFunc"]            := nArredondamento
                    jFunction["EmployeesFunc"]              := {}
                    jFunction["EmployeesCountPerFunc"]      := 0
                    jFunction["TotalOldSalaryPerFunc"]      := 0
                    jFunction["TotalOldHourSalaryPerFunc"]  := 0
                    jFunction["TotalAdditionalValuePerFunc"]:= 0
                    jFunction["TotalAdjustmentPerFunc"]     := 0
                    jFunction["TotalNewSalaryPerFunc"]      := 0
                    jFunction["TotalNewHourSalaryPerFunc"]  := 0
                    jFunction["TotalRoundingPerFunc"]       := 0

                    AAdd(aFunctionGroups, jFunction)
                    nFuncPos := Len(aFunctionGroups)
                EndIf
                
                // Adiciona o funcionário ao grupo da função
                jEmp := JSONObject():New()
                jEmp["BranchCodeFunc"]          := AllTrim(SRA->RA_FILIAL)
                jEmp["BranchNameFunc"]          := IIf(Len(aInfo) > 0, AllTrim(aInfo[1]), "")
                jEmp["EmployeeCodeFunc"]        := AllTrim(SRA->RA_MAT)
                jEmp["EmployeeNameFunc"]        := IIf(lOfuscaNom, Replicate('*', 15), AllTrim(SRA->RA_NOME))
                jEmp["CostCenterCodeFunc"]      := AllTrim(SRA->RA_CC)
                jEmp["CategoryFunc"]            := AllTrim(SRA->RA_CATFUNC)
                jEmp["UnionFunc"]               := AllTrim(SRA->RA_SINDICA)
                jEmp["AdmissionDateFunc"]       := totvs.framework.treports.date.stringToTimeStamp(DtoS(SRA->RA_ADMISSA))
                jEmp["OldSalaryFunc"]           := nSalBase
                jEmp["OldHourSalaryFunc"]       := nOldHourSalary
                jEmp["PercentualFunc"]          := IIF(nPercDif > 0, nPercDif, aFaixas[nPos,3])
                jEmp["AdditionalValueFunc"]     := nValFaixa
                jEmp["AdjustmentFunc"]          := nReajuste
                jEmp["NewSalaryFunc"]           := nNovoSal
                jEmp["NewHourSalaryFunc"]       := nNewHourSalary
                jEmp["RoundingFunc"]            := nArredondamento

                // Adiciona o funcionário ao array de funcionários da função
                AAdd(aFunctionGroups[nFuncPos]["EmployeesFunc"], jEmp)

                // Atualiza totalizadores do grupo de função
                aFunctionGroups[nFuncPos]["TotalOldSalaryPerFunc"]       += nSalBase
                aFunctionGroups[nFuncPos]["TotalOldHourSalaryPerFunc"]   += nOldHourSalary
                aFunctionGroups[nFuncPos]["TotalAdditionalValuePerFunc"] += nValFaixa
                aFunctionGroups[nFuncPos]["TotalAdjustmentPerFunc"]      += nReajuste
                aFunctionGroups[nFuncPos]["TotalNewSalaryPerFunc"]       += nNovoSal
                aFunctionGroups[nFuncPos]["TotalNewHourSalaryPerFunc"]   += nNewHourSalary
                aFunctionGroups[nFuncPos]["TotalRoundingPerFunc"]        += nArredondamento
                aFunctionGroups[nFuncPos]["EmployeesCountPerFunc"]       += 1

            ElseIf nUpdFuncao == 4 // Não
                // Agrupa por filial quando Atualiza Função = Não
                nBranchPos := AScan(aBranchGroups, {|x| x["BranchCode"] == AllTrim(SRA->RA_FILIAL)})
                If nBranchPos == 0
                    jBranch := JSONObject():New()
                    jBranch["BranchCodePerBranch"]          := AllTrim(SRA->RA_FILIAL)
                    jBranch["BranchNamePerBranch"]          := IIf(Len(aInfo) > 0, AllTrim(aInfo[1]), "")
                    jBranch["EmployeesBranch"]              := {}
                    jBranch["EmployeesCountPerBranch"]      := 0
                    jBranch["TotalOldSalaryPerBranch"]      := 0
                    jBranch["TotalOldHourSalaryPerBranch"]  := 0
                    jBranch["TotalAdditionalValuePerBranch"]:= 0
                    jBranch["TotalAdjustmentPerBranch"]     := 0
                    jBranch["TotalNewSalaryPerBranch"]      := 0
                    jBranch["TotalNewHourSalaryPerBranch"]  := 0
                    jBranch["TotalRoundingPerBranch"]       := 0
                    
                    AAdd(aBranchGroups, jBranch)
                    nBranchPos := Len(aBranchGroups)
                EndIf

                // Adiciona o funcionário ao grupo da filial
                jEmp := JSONObject():New()
                jEmp["BranchCodeBranch"]          := AllTrim(SRA->RA_FILIAL)
                jEmp["BranchNameBranch"]          := IIf(Len(aInfo) > 0, AllTrim(aInfo[1]), "")
                jEmp["EmployeeCodeBranch"]        := AllTrim(SRA->RA_MAT)
                jEmp["EmployeeNameBranch"]        := IIf(lOfuscaNom, Replicate('*', 15), AllTrim(SRA->RA_NOME))
                jEmp["CostCenterCodeBranch"]      := AllTrim(SRA->RA_CC)
                jEmp["CategoryBranch"]            := AllTrim(SRA->RA_CATFUNC)
                jEmp["UnionBranch"]               := AllTrim(SRA->RA_SINDICA)
                jEmp["AdmissionDateBranch"]       := totvs.framework.treports.date.stringToTimeStamp(DtoS(SRA->RA_ADMISSA))
                jEmp["OldSalaryBranch"]           := nSalBase
                jEmp["OldHourSalaryBranch"]       := nOldHourSalary
                jEmp["PercentualBranch"]          := IIF(nPercDif > 0, nPercDif, aFaixas[nPos,3])
                jEmp["AdditionalValueBranch"]     := nValFaixa
                jEmp["AdjustmentBranch"]          := nReajuste
                jEmp["NewSalaryBranch"]           := nNovoSal
                jEmp["NewHourSalaryBranch"]       := nNewHourSalary
                jEmp["RoundingBranch"]            := nArredondamento

                AAdd(aBranchGroups[nBranchPos]["EmployeesBranch"], jEmp)

                // Atualiza totalizadores da filial
                aBranchGroups[nBranchPos]["EmployeesCountPerBranch"]       += 1
                aBranchGroups[nBranchPos]["TotalOldSalaryPerBranch"]       += nSalBase
                aBranchGroups[nBranchPos]["TotalOldHourSalaryPerBranch"]   += nOldHourSalary
                aBranchGroups[nBranchPos]["TotalAdditionalValuePerBranch"] += nValFaixa
                aBranchGroups[nBranchPos]["TotalAdjustmentPerBranch"]      += nReajuste
                aBranchGroups[nBranchPos]["TotalNewSalaryPerBranch"]       += nNovoSal
                aBranchGroups[nBranchPos]["TotalNewHourSalaryPerBranch"]   += nNewHourSalary
                aBranchGroups[nBranchPos]["TotalRoundingPerBranch"]        += nArredondamento
            EndIf
        EndIf

        // Atualização da função se necessário
        If (nUpdFuncao == 1 .or. nUpdFuncao == 3) .and. nNovoSal > 0
            lAumento  := .T.
            lGravaAum := .T.
        Endif
        
        // Integração com outros sistemas
        If lIntegDef
            FwIntegDef("GPEA250")
        EndIf
        
        dbSkip()
    Enddo

    // Processa funções não atribuídas se necessário (nUpdFuncao == 2 ou 3)
    If nUpdFuncao == 2 .OR. nUpdFuncao == 3
        aFuncoesNaoAtrib := fProcessFuncoesNaoAtribuidas(aFuncoes, aFaixas, cFilExec, cEmpExec, nTipAum)
    EndIf

    // Calcula média do percentual
    nAvgPercentual := IIf(nTotalEmployees > 0, nTotalPercentual / nTotalEmployees, 0)

    // Adiciona totalizador no final - SOMENTE se UpdateFunc for diferente de 2
    jData := JSONObject():New()
    jData["Enterprise"]             := AllTrim(cEmpExec)
    jData["Branch"]                 := AllTrim(cFilExec)
    jData["Percentual"]             := nAvgPercentual
    jData["TotalAdditionalValue"]   := nTotalAdditionalValue
    jData["TotalAdjustment"]        := nTotalAdjustment
    jData["TotalNewHourSalary"]     := nTotalNewHourSalary
    jData["TotalRounding"]          := nTotalRounding
    jData["EmployeesCount"]         := nTotalEmployees
    jData["TotalOldSalary"]         := nTotalOldSalary
    jData["TotalOldHourSalary"]     := nTotalOldHourSalary
    jData["TotalNewSalary"]         := nTotalNewSalary
    jData["Functions"]              := aFuncoesNaoAtrib
    jData["EmployeesPerFunc"]       := aFunctionGroups
    jData["EmployeesPerBranch"]     := aBranchGroups

    // Adiciona o totalizador aos dados
    self:oData:appendData(jData)
        
    // Limpa os objetos da memória
    FwFreeObj(jData)
    FwFreeObj(jParams)

return self:oData

/*/{Protheus.doc} fGetPisoFromTable
    Busca os valores do piso salarial da tabela RUG
    @type Static Function
    @param nPisoMes, numeric, Piso mensal (por referência)
    @param nPisoHora, numeric, Piso por hora (por referência)  
    @param nPisoDia, numeric, Piso diário (por referência)
    @author guilherme.suttanni
    @since 28/07/2025
/*/
Static Function fGetPisoFromTable(nPisoMes, nPisoHora, nPisoDia)
    Local cCodigo := ""
    
    // Inicializa com zero
    nPisoMes  := 0
    nPisoHora := 0
    nPisoDia  := 0
    
    // Busca o último código inserido pelo usuário atual  
    cCodigo := PADR(fGetLastUserCodeSV(), TAMSX3("RUG_CODIGO")[1])
    
    If !Empty(cCodigo)
        DbSelectArea("RUG")
        RUG->(DbSetOrder(1)) // RUG_FILIAL + RUG_CODIGO + RUG_ITEM
        
        If RUG->(DbSeek(xFilial("RUG") + cCodigo))
            While RUG->(!Eof()) .And. RUG->RUG_FILIAL == xFilial("RUG") .And. ;
                  RUG->RUG_CODIGO == cCodigo .And. RUG->RUG_ORIGEM == "1"
                
                // Busca os valores do piso - pega o primeiro registro encontrado
                If RUG->(FieldPos("RUG_PISOM")) > 0 .And. RUG->RUG_PISOM > 0
                    nPisoMes := RUG->RUG_PISOM
                EndIf
                
                If RUG->(FieldPos("RUG_PISOH")) > 0 .And. RUG->RUG_PISOH > 0  
                    nPisoHora := RUG->RUG_PISOH
                EndIf
                
                If RUG->(FieldPos("RUG_PISOD")) > 0 .And. RUG->RUG_PISOD > 0
                    nPisoDia := RUG->RUG_PISOD
                EndIf
                
                // Se encontrou pelo menos um valor, sai do loop
                If nPisoMes > 0 .Or. nPisoHora > 0 .Or. nPisoDia > 0
                    Exit
                EndIf
                
                RUG->(DbSkip())
            EndDo
        EndIf
    EndIf
    
Return

/*/{Protheus.doc} fGravaSRJ
    Efetua a gravacao do aumento no Cadastro de Funcoes - BASEADO NO RELATÓRIO ANTIGO
    @type Static Function
    @param lGravaAum Controle de gravação
    @param lAumento Controle de aumento
    @param nNovoSal Novo salário
    @param cCodFunc Código da função
    @param cFilialAnt Filial anterior
    @author guilherme.suttanni
    @since 28/07/2025
/*/
Static Function fGravaSRJ(lGravaAum, lAumento, nNovoSal, cCodFunc, cFilialAnt)
    Local aArea     := GetArea()
    Local cFilSRJ   := xFilial("SRJ", cFilialAnt)
    Local cSindic   := SRA->RA_SINDICA

    If nOrdem == 3 .And. !lGravaAum .and. ;
       (nUpdFuncao == 1 .or. nUpdFuncao == 2 .or. nUpdFuncao == 3)
        
        lAumento  := .T.
        lGravaAum := .T.
        
        dbSelectArea("SRJ")
        If dbSeek(cFilSRJ + cCodFunc)
            If !lSalCCT
                RecLock("SRJ", .F.)
                SRJ->RJ_SALARIO := nNovoSal
                MsUnlock()
            Else 
                RCE->(DbSeek(xFilial("RCE", cFilialAnt) + cSindic))
                RI4->(DbSetOrder(2)) //RI4_FILSRJ + RI4_CODSRJ
                
                If RI4->(DbSeek(cFilSRJ + cCodFunc))
                    While RI4->(!Eof() .And. RI4_FILSRJ + RI4_CODSRJ == cFilSRJ + cCodFunc)
                        If RI4->RI4_CODCCT == RCE->RCE_CCT
                            RecLock("RI4", .F.)
                            RI4->RI4_SALARI := nNovoSal 
                            MsUnLock()
                            Exit
                        EndIf
                        RI4->(DbSkip())
                    EndDo 
                EndIf
            EndIf
        EndIf
    EndIf
    
    RestArea(aArea)
Return

/*/{Protheus.doc} fProcessFuncoesNaoAtribuidas
    Processa as funções que não estão atribuídas a funcionários
    @type Static Function
    @param aFuncoes Array com as funções já processadas
    @param aFaixas Array com as faixas salariais
    @param cFilExec Filial executante
    @param cEmpExec Empresa executante
    @param nTipAum Tipo de aumento (1=Dissídio, 2=Antecipação, 3=Aumento Real)
    @return Array, Array com os objetos JSON das funções não atribuídas
    @author guilherme.suttanni
    @since 28/07/2025
/*/
Static Function fProcessFuncoesNaoAtribuidas(aFuncoes, aFaixas, cFilExec, cEmpExec, nTipAum)
    Local cFilDeSRJ := xFilial("SRJ", cFilDe)
    Local cFilAteSRJ := xFilial("SRJ", cFilAte)
    Local cInicio := "SRJ->RJ_FILIAL + SRJ->RJ_FUNCAO"
    Local cFim := cFilAteSRJ + cFunAte
    Local nPos := 0
    Local nSalBase := 0
    Local nNovoSal := 0
    Local nReajSal := 0
    Local nValArre := 0
    Local nPerProp := 0
    Local jEmp := NIL
    Local aRetorno := {}
    Local nTotalHoras       := 0
    Local nOldHourSalary     := 0
    Local nNewHourSalary     := 0

    dbSelectArea("SRJ")
    SRJ->(dbSetOrder(1)) // RJ_FILIAL + RJ_FUNCAO
    SRJ->(dbSeek(cFilDeSRJ + cFunDe, .T.))
    
    While !SRJ->(Eof()) .And. &cInicio <= cFim
        
        // Verifica se a função não foi processada (não atribuída)
        If AScan(aFuncoes, {|x| SRJ->(RJ_FILIAL + RJ_FUNCAO) == x[1] + x[2]}) <= 0
            
            nSalBase := SRJ->RJ_SALARIO
            nPos := AScan(aFaixas, {|X| (nSalBase >= X[1] .And. nSalBase <= X[2])})
            
            If nPos > 0
                // Calcula o novo salário
                nNovoSal := nSalBase * (1 + (IIF(nPercDif > 0, nPercDif, aFaixas[nPos,3]) / 100))
                nNovoSal := nNovoSal + IIF(nValAum > 0, nValAum, aFaixas[nPos,4])
                
                // Aplica piso salarial se necessário
                nNovoSal := If((nNovoSal > 0 .and. nVlPiso > nNovoSal), nVlPiso, nNovoSal)
                
                nReajSal := nNovoSal - nSalBase
                nPerProp := IIF(nPercDif > 0, nPercDif, aFaixas[nPos,3])
                
                // Calcula arredondamento se necessário
                If nArredonda != 0
                    nValArre := 0
                    CalcArre(@nNovoSal, nArredonda, @nValArre)
                EndIf

                // Cálculo do salário hora antigo e novo
                nTotalHoras       := IIf(SRJ->(FieldPos("RJ_HRSMES")) > 0 .And. SRJ->RJ_HRSMES > 0, SRJ->RJ_HRSMES, 220)
                nOldHourSalary    := nSalBase / nTotalHoras
                nNewHourSalary    := nNovoSal / nTotalHoras

                // Cria registro para função não atribuída
                jEmp := JSONObject():New()
                jEmp["BranchCode"]      := SRJ->RJ_FILIAL
                jEmp["BranchName"]      := AllTrim(Posicione("SM0", 1, cEmpAnt + SRJ->RJ_FILIAL, "M0_FILIAL"))
                jEmp["FunctionCode"]    := SRJ->RJ_FUNCAO
                jEmp["FunctionName"]    := AllTrim(SRJ->RJ_DESC)
                jEmp["OldSalary"]       := nSalBase
                jEmp["OldHourSalary"]   := nOldHourSalary
                jEmp["Percentual"]      := nPerProp
                jEmp["AdditionalValue"] := IIF(nValAum > 0, nValAum, aFaixas[nPos,4])
                jEmp["Adjustment"]      := nReajSal
                jEmp["NewSalary"]       := nNovoSal
                jEmp["NewHourSalary"]   := nNewHourSalary
                jEmp["Rounding"]        := nValArre
                
                // Adiciona ao array de retorno
                AAdd(aRetorno, jEmp)
                
                // Atualiza a função se necessário
                If nUpdFuncao == 2
                    RecLock("SRJ", .F.)
                    SRJ->RJ_SALARIO := nNovoSal
                    MsUnlock()
                EndIf
            EndIf
        EndIf
        
        SRJ->(dbSkip())
    EndDo
    
Return aRetorno

/*/{Protheus.doc} fGetFaixasFromTable
    Busca as faixas salariais da tabela RUG
    @type Static Function
    @return Array, Array com as faixas configuradas
    @author guilherme.suttanni
    @since 28/07/2025
/*/
Static Function fGetFaixasFromTable()
    Local cCodigo   := ""
    
    // Busca o último código inserido pelo usuário atual  
    cCodigo := PADR(fGetLastUserCodeSV() , TAMSX3("RUG_CODIGO")[1])
    
    If !Empty(cCodigo)
        DbSelectArea("RUG")
        RUG->(DbSetOrder(1)) // RUG_FILIAL + RUG_CODIGO + RUG_ITEM
        
        If RUG->(DbSeek(xFilial("RUG") + cCodigo))
            While RUG->(!Eof()) .And. RUG->RUG_FILIAL == xFilial("RUG") .And. ;
                  RUG->RUG_CODIGO == cCodigo .And. RUG->RUG_ORIGEM == "1"
                
                // Adiciona a faixa ao array
                If RUG->RUG_FAIXAD > 0 .Or. RUG->RUG_FAIXAA > 0 .Or. RUG->RUG_PERCEN > 0 .Or. RUG->RUG_VALOR > 0
                    AAdd(aFaixas, {RUG->RUG_FAIXAD, RUG->RUG_FAIXAA, RUG->RUG_PERCEN, RUG->RUG_VALOR, ;
                                   RUG->RUG_ADMDE, RUG->RUG_ADMATE, .F.})
                EndIf

                cCategoria := RUG->RUG_CATEG
                
                // Se for gestão pública, adiciona as categorias específicas
                If lGestPubl .And. !(RUG->RUG_CATEG $ "*0*1*2*3*4*5*6*7*8*9")
                    cCategoria += "*0*1*2*3*4*5*6*7*8*9"
                EndIf
                
                RUG->(DbSkip())
            EndDo
        EndIf
    EndIf
    
Return

/*/{Protheus.doc} fGetLastUserCodeSV
    Busca o último código de faixa salarial inserido pelo usuário atual
    @type Static Function
    @return Character, Último código UUID utilizado pelo usuário
    @author guilherme.suttanni
    @since 28/07/2025
/*/
Static Function fGetLastUserCodeSV()
    Local cQuery      As Character
    Local cCodigo     As Character
    Local cAlias      As Character
    Local oStatement  As Object
    Local nParamOrder As Numeric
    
    cCodigo     := ""
    nParamOrder := 1
    
    cQuery := " SELECT RUG_CODIGO "
    cQuery += " FROM " + RetSqlName("RUG") + " RUG "
    cQuery += " WHERE RUG.RUG_FILIAL = ? "
    cQuery += "   AND RUG.RUG_USER = ? "
    cQuery += "   AND RUG.RUG_ORIGEM = ? "
    cQuery += "   AND RUG.D_E_L_E_T_ = ? "
    cQuery += " ORDER BY RUG.RUG_DATA DESC, RUG.RUG_HORA DESC "
    
    // Instancia a classe
    oStatement := FwExecStatement():New(cQuery)
    
    // Define o valor dos bind parameters
    oStatement:SetString(nParamOrder++, xFilial("RUG"))
    oStatement:SetString(nParamOrder++, __cUserID)
    oStatement:SetString(nParamOrder++, "1")
    oStatement:SetString(nParamOrder++, " ")
    
    // Executa a query e retorna o alias criado
    cAlias := oStatement:OpenAlias()
    
    If (cAlias)->(!Eof())
        cCodigo := AllTrim((cAlias)->RUG_CODIGO)
    EndIf
    
    // Fecha a área do alias temporário
    (cAlias)->(DBCloseArea())
    
    // Limpa o objeto da memória
    FwFreeObj(oStatement)

Return cCodigo

/*/{Protheus.doc} fCalcNewSal
    Aplica o Valor percentual e/ou acrescenta o valor do aumento informado
    @type Static Function
    @param nSalBase, numeric, Salário base
    @param aFaixas, array, Array das faixas
    @param nPos, numeric, Posição da faixa
    @param lAumento, logical, Se houve aumento
    @param nNovoSal, numeric, Novo salário (por referência)
    @param nBaseDis, numeric, Base dissídio (por referência)
    @param nNovoDis, numeric, Novo dissídio (por referência)
    @param nTipAum, numeric, Tipo de aumento
    @param nPercDif, numeric, Percentual diferenciado
    @param nValAum, numeric, Valor do aumento
    @param nUpdFuncao, numeric, Atualiza função
    @author guilherme.suttanni
    @since 28/07/2025
/*/
Static Function fCalcNewSal(nSalBase, aFaixas, nPos, lAumento, nNovoSal, nBaseDis, nNovoDis, nTipAum, nPercDif, nValAum, nUpdFuncao)
    If nTipAum != 2 // diferente de antecipacao
        nBaseDis := SRA->RA_ANTEAUM
        nNovoDis := nBaseDis * ( 1 + ( IIF (nPercDif > 0 , nPercDif, aFaixas[nPos,3])  / 100 ) ) 
        nNovoDis := nNovoDis + IIF (nValAum > 0 , nValAum , aFaixas[nPos,4])
    EndIf

    // Calcular aumento apenas uma vez p/ atualizacao no Cad.Funcoes
    If !lAumento .Or. nUpdFuncao == 4
        nNovoSal := nSalBase * (1 + (IIF(nPercDif > 0, nPercDif, aFaixas[nPos,3]) / 100))
        nNovoSal := nNovoSal + IIF(nValAum > 0, nValAum, aFaixas[nPos,4])
    Endif
Return 

/*/{Protheus.doc} fGetSalFunc
    Obtém o salário da função de acordo com CCT, se houver
    @type Static Function
    @param cFuncCCT, character, Código CCT da função (por referência)
    @return numeric, Salário da função
    @author guilherme.suttanni
    @since 28/07/2025
/*/
Static Function fGetSalFunc(cFuncCCT, lUsaRI4)
    Local nRet := SRJ->RJ_SALARIO

    Static __cFilFunc
    Static __nValSal

    DEFAULT cFuncCCT := ""

    If lUsaRI4
        If __cFilFunc == SRA->RA_FILIAL + SRA->RA_MAT
            nRet := __nValSal
        Else
            lSalCCT := .F.
            If !Empty(SRA->RA_SINDICA) .and. RCE->(DbSeek(xFilial("RCE",SRA->RA_FILIAL) + SRA->RA_SINDICA)) .and. !Empty(RCE->RCE_CCT)
                RI4->(DbSetOrder(2)) //RI4_FILSRJ + RI4_CODSRJ
                If RI4->(DbSeek(SRJ->RJ_FILIAL + SRJ->RJ_FUNCAO))
                    While RI4->(!Eof() .And. RI4_FILSRJ + RI4_CODSRJ == SRJ->RJ_FILIAL + SRJ->RJ_FUNCAO)
                        If RI4->RI4_CODCCT == RCE->RCE_CCT
                            If RI4->RI4_SALARI > 0
                                nRet     := RI4->RI4_SALARI
                                cFuncCCT := RCE->RCE_CCT
                                lSalCCT  := .T.
                            EndIf
                            Exit
                        EndIf
                        RI4->(DbSkip())
                    EndDo
                EndIf
            EndIf

            __cFilFunc := SRA->RA_FILIAL + SRA->RA_MAT
            __nValSal  := nRet
        EndIf
    EndIf

Return nRet

Static Function fSalBase(SalMes, cAnMes, cNroPagto, cCatMensal)
    Local aArea         := GetArea()
    Local cKeySeek      := ""
    Local dData         := CtoD("//")
    Local lMAprendiz    := GetMvRH("MV_MAPREND",,.F.)
    Local nDiasCalc     := 0
    Local nHrsCalc      := 0
    Local nValor        := 0
    Local cMes          := ""
    Local cAno          := ""
    Local nNumSemana    := 0
    Local nDiasSem      := 7
    Local nUltDia       := 0

    DEFAULT cCatMensal  := "M"
    DEFAULT cAnMes      := If(Empty(cAnMes),(If(Type("cAnoMes") != "U", cAnoMes, MesAno(dDataBase))), cAnMes)
    DEFAULT cNroPagto   := If(Empty(cNroPagto),(If(Type("cSemana") != "U", cSemana, "01")), cNroPagto)

    cCatMensal += IIf(ExistFunc("fUsaGFP") .and. fUsaGFP(), "*0*1*2*3*4*5*6*7*8*9", "")

    If cPaisLoc == "BRA" .And. SRA->RA_CATFUNC == "S"
        SetMnemonicos(xFilial("RCA"),NIL,.T.,"P_NTOTDIAS")
        nDiasSem := P_NTOTDIAS
    EndIf

    cMes    := SubStr(cAnMes,5,2)
    cAno    := SubStr(cAnMes,1,4)
    dData   := CtoD("01/" + cMes + "/" + cAno)

    dbSelectArea("RCF")
    dbSetOrder(5)
    cKeySeek := cAnMes + cNroPagto + cAno + cMes + SRA->RA_PROCES
    If RCF->(dbSeek(xFilial("RCF") + cKeySeek))
        nDiasCalc := RCF->RCF_DCALCM
    EndIf

    nHrsCalc := IIf(nDiasCalc > 0 .And. SRA->RA_HRSDIA > 0, Round((SRA->RA_HRSDIA * nDiasCalc),2), IIf(SRA->RA_HRSMES > 0, SRA->RA_HRSMES, 0))

    // Menor Aprendiz
    If SRA->RA_CATEG = '07' .And. lMAprendiz
        nHrsCalc    := IIf(nDiasCalc > 0 .And. SRA->RA_HRSMES > 0, SRA->RA_HRSMES, nHrsCalc)
        nUltDia     := F_ULTDIA(dData)
        nNumSemana  := IIf(nUltDia == 31, 4.428571, IIf(nUltDia == 30, 4.285714, IIf(nUltDia == 29, 4.142857, 4)))

        If SRA->RA_CATFUNC = "H"
            nValor := nHrsCalc / 5
            nValor := (nValor * nNumSemana) * SRA->RA_ANTEAUM
            SalMes := (nValor * 7) / 6
        ElseIf SRA->RA_CATFUNC $ cCatMensal
            Salmes := SRA->RA_ANTEAUM
        EndIf
    Else
        SalMes := IIf(SRA->RA_CATFUNC $ cCatMensal, SRA->RA_ANTEAUM,;
                  IIf(SRA->RA_CATFUNC $ "C*P*A*E" .And. SRA->RA_TIPOPGT == "S", (SRA->RA_ANTEAUM / 7) * nDiasCalc,;
                  IIf(SRA->RA_CATFUNC $ "C*P*A*E" .And. SRA->RA_TIPOPGT == "M", SRA->RA_ANTEAUM,;
                  IIf(SRA->RA_CATFUNC $ "H*G*T", SRA->RA_ANTEAUM * nHrsCalc,;
                  IIf(SRA->RA_CATFUNC == "D", SRA->RA_ANTEAUM * nDiasCalc,;
                  IIf(SRA->RA_CATFUNC == "S", (SRA->RA_ANTEAUM / nDiasSem) * nDiasCalc, SalMes))))))
    EndIf
    
    RestArea(aArea)
Return

Static Function CalcArre(nValor, nArred, nValArred)
    Local nResto := 0

    nResto := Mod(nValor, nArred)

    If Round(nResto, MsDecimais(1)) > 0.00
        nValArred := nArred - nResto
        nValor    := nValor + nValArred
    Else
        nValArred := 0.00
    Endif
Return

/*/{Protheus.doc} fConvertIsoToDate
    Converte uma string de data no formato ISO para tipo Date
    @param cIsoDate String no formato ISO (ex: "1900-01-01T01:00:00Z")
    @return Date Data convertida
    @author Guilherme Suttanni
    @since 28/07/2025
/*/
Static Function fConvertIsoToDate(cIsoDate)
    Local dRetDate := CtoD("//")
    Local cDatePart := ""
    Local cYear := ""
    Local cMonth := ""
    Local cDay := ""
    
    // Remove a parte do timestamp, ficando apenas com a data
    If !Empty(cIsoDate) .And. "T" $ cIsoDate
        cDatePart := SubStr(cIsoDate, 1, At("T", cIsoDate) - 1)
        
        // Extrai ano, mês e dia
        cYear  := SubStr(cDatePart, 1, 4)
        cMonth := SubStr(cDatePart, 6, 2)
        cDay   := SubStr(cDatePart, 9, 2)
        
        // Converte para Date no formato DD/MM/YYYY
        dRetDate := CtoD(cDay + "/" + cMonth + "/" + cYear)
    EndIf
    
Return dRetDate

/*/{Protheus.doc} GPER200TReportsBusinessObject::getComboBox
    Retorna os valores de ComboBox do parâmetro requisitado.
    @type Method
    @version 12.1.2410
    @author Guilherme Suttanni
    @since 28/07/2025
    @return Variant, Retorno nulo pré-fixado
    @obs Path parameters: param (nome do parâmetro solicitado)
/*/
Method getComboBox() As Variant Class GPER200TReportsBusinessObject
    // Declaração das variáveis locais
    Local jPath     As JSON    // Path parameters da requisição
    Local jResponse As JSON    // Resposta da requisição
    Local jItem     As JSON    // Item do valor do parâmetro
    Local nValues   As Numeric // Contador dos valores do parâmetro
    Local aValues   As Array   // Valores do parâmetro
    Local cParam    As Character // Parâmetro requisitado
    Local cQuery    As Character // Query para buscar dados
    Local cAlias    As Character // Alias temporário
    Local cKey      As Character // Chave do item
    Local cLabel    As Character // Label do item

    // Inicialização das variáveis
    jPath     := oRest:getPathParamsRequest()
    jResponse := JSONObject():New()
    jItem     := NIL
    nValues   := 0
    aValues   := {}
    cParam    := ""
    cQuery    := ""
    cAlias    := ""
    cKey      := ""
    cLabel    := ""

    // Captura os path parameters da requisição
    If (jPath != NIL)
        cParam := jPath["param"]
    EndIf

    // Cria o atributo data e nextPageUrl no JSON de resposta
    jResponse["data"]        := {}
    jResponse["nextPageUrl"] := NIL

    // Verifica qual parâmetro foi solicitado
    If cParam == "getIncreaseBase"
        // Aumento Sobre
        AAdd(aValues, FwHTTPEncode(STR0006))
        AAdd(aValues, FwHTTPEncode(STR0007))
        AAdd(aValues, FwHTTPEncode(STR0008))
    ElseIf cParam == "getIncreaseType"
        // Tipo de Aumento - busca da tabela SX5 (tabela 41)
        cQuery := " SELECT X5_CHAVE, X5_DESCRI "
        cQuery += " FROM " + RetSqlName("SX5") + " SX5 "
        cQuery += " WHERE SX5.X5_FILIAL = ? "
        cQuery += "   AND SX5.X5_TABELA = ? "
        cQuery += "   AND SX5.D_E_L_E_T_ = ? "
        cQuery += " ORDER BY SX5.X5_CHAVE "
        
        // Instancia a classe FwExecStatement
        oStatement := FwExecStatement():New(cQuery)
        
        // Define o valor dos bind parameters
        oStatement:SetString(1, xFilial("SX5"))
        oStatement:SetString(2, "41")
        oStatement:SetString(3, " ")
        
        // Executa a query e retorna o alias criado
        cAlias := oStatement:OpenAlias()
        
        While (cAlias)->(!Eof())
            cKey   := AllTrim((cAlias)->X5_CHAVE)
            cLabel := AllTrim((cAlias)->X5_DESCRI)
            
            If !Empty(cKey) .And. !Empty(cLabel)
                jItem := {;
                    "key":   cKey,;
                    "label": FwHTTPEncode(cLabel);
                }
                AAdd(jResponse["data"], jItem)
            EndIf
            
            (cAlias)->(DbSkip())
        EndDo
        
        (cAlias)->(DbCloseArea())
        
        // Limpa o objeto da memória
        FwFreeObj(oStatement)
    ElseIf cParam == "getSNOptions"
        // Sim/Não para vários parâmetros
        AAdd(aValues, FwHTTPEncode(STR0009))
        AAdd(aValues, FwHTTPEncode(STR0010))
    ElseIf cParam == "getUpdateFunc"
        // Atualiza Função
        AAdd(aValues, FwHTTPEncode(STR0011))
        AAdd(aValues, FwHTTPEncode(STR0012))
        AAdd(aValues, FwHTTPEncode(STR0017)) // Não é necessario a principio
        AAdd(aValues, FwHTTPEncode(STR0009))
    ElseIf cParam == "getRoundingType"
        // Critério de Arredondamento
        AAdd(aValues, FwHTTPEncode(STR0009))
        AAdd(aValues, FwHTTPEncode(STR0013))
        AAdd(aValues, FwHTTPEncode(STR0014))
    ElseIf cParam == "getApplyIncrease"
        // Aplicar Aumento Para
        AAdd(aValues, FwHTTPEncode(STR0015))
        AAdd(aValues, FwHTTPEncode(STR0016))
        AAdd(aValues, FwHTTPEncode(STR0017))
    EndIf

    // Para parâmetros que usam aValues 
    If (Len(aValues) > 0)
        // Percorre os valores adicionando cada item no JSON de resposta
        For nValues := 1 To Len(aValues)
            jItem := {;
                "key":   CValToChar(nValues),;
                "label": aValues[nValues];
            }
            AAdd(jResponse["data"], jItem)
        Next nValues
    EndIf

    oRest:setResponse(jResponse)
    oRest:setStatusCode(200)
    oRest:setKeyHeaderResponse("Content-Type", "application/json; charset=utf-8")
    oRest:setKeyHeaderResponse("Accept-Encoding", "UTF-8")

    FwFreeObj(jPath)
    FwFreeObj(jResponse)
    FwFreeObj(jItem)
    FwFreeArray(aValues)
Return NIL

method getSchema() as object class GPER200TReportsBusinessObject
    Local aFields As Array
    
    // Propriedades do retorno (mantém as existentes e adiciona:)
    self:oSchema:addProperty("Enterprise",              STR0018, "string",   STR0018)
    self:oSchema:addProperty("Branch",                  STR0018, "string",   STR0018)
    self:oSchema:addProperty("EmployeesCount",          STR0040, "number",   STR0040)
    self:oSchema:addProperty("TotalOldSalary",          STR0041, "number",   STR0041)
    self:oSchema:addProperty("TotalOldHourSalary",      STR0042, "number",   STR0042)
    self:oSchema:addProperty("TotalAdditionalValue",    STR0043, "number",   STR0043)
    self:oSchema:addProperty("TotalAdjustment",         STR0044, "number",   STR0044)
    self:oSchema:addProperty("TotalNewSalary",          STR0045, "number",   STR0045)
    self:oSchema:addProperty("TotalNewHourSalary",      STR0046, "number",   STR0046)
    self:oSchema:addProperty("TotalRounding",           STR0047, "number",   STR0047)

    // Adiciona a nested property para funcionários (quando for por função)
    // Caso não for por função o funcionario é o array principal do retorno
    aFields := {}
    AAdd(aFields, {"BranchCode",         STR0048, "string", STR0048})
    AAdd(aFields, {"BranchName",         STR0049, "string", STR0049})
    AAdd(aFields, {"FunctionCode",       STR0025, "string", STR0025})
    AAdd(aFields, {"FunctionName",       STR0026, "string", STR0026})
    AAdd(aFields, {"OldSalary",          STR0056, "number", STR0056})
    AAdd(aFields, {"OldHourSalary",      STR0057, "number", STR0057})
    AAdd(aFields, {"Percentual",         STR0058, "number", STR0058})
    AAdd(aFields, {"AdditionalValue",    STR0059, "number", STR0059})
    AAdd(aFields, {"Adjustment",         STR0060, "number", STR0060})
    AAdd(aFields, {"NewSalary",          STR0061, "number", STR0061})
    AAdd(aFields, {"NewHourSalary",      STR0062, "number", STR0062})
    AAdd(aFields, {"Rounding",           STR0063, "number", STR0063})
    
    self:addNestedProperty("Functions", "Funcões Não Atrib", "Funcões Não Atrib", NIL, aFields)

    // Adiciona a nested property para funcionários (quando for por função)
    // Caso não for por função o funcionario é o array principal do retorno
    aFields := {}
    AAdd(aFields, {"BranchCodePerFunc",              STR0048 + ' ' + STR0098, "string", STR0048 + ' ' + STR0098})
    AAdd(aFields, {"BranchNamePerFunc",              STR0049 + ' ' + STR0098, "string", STR0049 + ' ' + STR0098})
    AAdd(aFields, {"FunctionCodePerFunc",            STR0025 + ' ' + STR0098, "string", STR0025 + ' ' + STR0098})
    AAdd(aFields, {"FunctionNamePerFunc",            STR0026 + ' ' + STR0098, "string", STR0026 + ' ' + STR0098})
    AAdd(aFields, {"OldSalaryPerFunc",               STR0056 + ' ' + STR0098, "number", STR0056 + ' ' + STR0098})
    AAdd(aFields, {"OldHourSalaryPerFunc",           STR0057 + ' ' + STR0098, "number", STR0057 + ' ' + STR0098})
    AAdd(aFields, {"PercentualPerFunc",              STR0058 + ' ' + STR0098, "number", STR0058 + ' ' + STR0098})
    AAdd(aFields, {"AdditionalValuePerFunc",         STR0059 + ' ' + STR0098, "number", STR0059 + ' ' + STR0098})
    AAdd(aFields, {"AdjustmentPerFunc",              STR0060 + ' ' + STR0098, "number", STR0060 + ' ' + STR0098})
    AAdd(aFields, {"NewSalaryPerFunc",               STR0061 + ' ' + STR0098, "number", STR0061 + ' ' + STR0098})
    AAdd(aFields, {"NewHourSalaryPerFunc",           STR0062 + ' ' + STR0098, "number", STR0062 + ' ' + STR0098})
    AAdd(aFields, {"RoundingPerFunc",                STR0063 + ' ' + STR0098, "number", STR0063 + ' ' + STR0098})
    AAdd(aFields, {"EmployeesCountPerFunc",          STR0040 + ' ' + STR0098, "number", STR0040 + ' ' + STR0098})
    AAdd(aFields, {"TotalOldSalaryPerFunc",          STR0041 + ' ' + STR0098, "number", STR0041 + ' ' + STR0098})
    AAdd(aFields, {"TotalOldHourSalaryPerFunc",      STR0042 + ' ' + STR0098, "number", STR0042 + ' ' + STR0098})
    AAdd(aFields, {"TotalAdditionalValuePerFunc",    STR0043 + ' ' + STR0098, "number", STR0043 + ' ' + STR0098})
    AAdd(aFields, {"TotalAdjustmentPerFunc",         STR0044 + ' ' + STR0098, "number", STR0044 + ' ' + STR0098})
    AAdd(aFields, {"TotalNewSalaryPerFunc",          STR0045 + ' ' + STR0098, "number", STR0045 + ' ' + STR0098})
    AAdd(aFields, {"TotalNewHourSalaryPerFunc",      STR0046 + ' ' + STR0098, "number", STR0046 + ' ' + STR0098})
    AAdd(aFields, {"TotalRoundingPerFunc",           STR0047 + ' ' + STR0098, "number", STR0047 + ' ' + STR0098})
    AAdd(aFields, {"EmployeesFunc",                  STR0100, "string", STR0100})
    self:addNestedProperty("EmployeesPerFunc", STR0101, STR0101, NIL, aFields)

    // Adiciona a nested property no segundo nível do objeto
    aFields := {}
    AAdd(aFields, {"BranchCodeFunc",         STR0048 + ' ' + STR0099, "string", STR0048 + ' ' + STR0099})
    AAdd(aFields, {"BranchNameFunc",         STR0049 + ' ' + STR0099, "string", STR0049 + ' ' + STR0099})
    AAdd(aFields, {"EmployeeCodeFunc",       STR0050 + ' ' + STR0099, "string", STR0050 + ' ' + STR0099})
    AAdd(aFields, {"EmployeeNameFunc",       STR0051 + ' ' + STR0099, "string", STR0051 + ' ' + STR0099})
    AAdd(aFields, {"CostCenterCodeFunc",     STR0052 + ' ' + STR0099, "string", STR0052 + ' ' + STR0099})
    AAdd(aFields, {"CategoryFunc",           STR0053 + ' ' + STR0099, "string", STR0053 + ' ' + STR0099})
    AAdd(aFields, {"UnionFunc",              STR0054 + ' ' + STR0099, "string", STR0054 + ' ' + STR0099})
    AAdd(aFields, {"AdmissionDateFunc",      STR0055 + ' ' + STR0099, "date",   STR0055 + ' ' + STR0099})
    AAdd(aFields, {"OldSalaryFunc",          STR0056 + ' ' + STR0099, "number", STR0056 + ' ' + STR0099})
    AAdd(aFields, {"OldHourSalaryFunc",      STR0057 + ' ' + STR0099, "number", STR0057 + ' ' + STR0099})
    AAdd(aFields, {"PercentualFunc",         STR0058 + ' ' + STR0099, "number", STR0058 + ' ' + STR0099})
    AAdd(aFields, {"AdditionalValueFunc",    STR0059 + ' ' + STR0099, "number", STR0059 + ' ' + STR0099})
    AAdd(aFields, {"AdjustmentFunc",         STR0060 + ' ' + STR0099, "number", STR0060 + ' ' + STR0099})
    AAdd(aFields, {"NewSalaryFunc",          STR0061 + ' ' + STR0099, "number", STR0061 + ' ' + STR0099})
    AAdd(aFields, {"NewHourSalaryFunc",      STR0062 + ' ' + STR0099, "number", STR0062 + ' ' + STR0099})
    AAdd(aFields, {"RoundingFunc",           STR0063 + ' ' + STR0099, "number", STR0063 + ' ' + STR0099})
    self:transformInNested("EmployeesFunc", NIL, aFields)

    // Adiciona a nested property para funcionários (quando for por função)
    // Caso não for por função o funcionario é o array principal do retorno
    aFields := {}
    AAdd(aFields, {"BranchCodePerBranch",              STR0048 + ' ' + STR0096, "string", STR0048 + ' ' + STR0096})
    AAdd(aFields, {"BranchNamePerBranch",              STR0049 + ' ' + STR0096, "string", STR0049 + ' ' + STR0096})
    AAdd(aFields, {"EmployeesCountPerBranch",          STR0040 + ' ' + STR0096, "number", STR0040 + ' ' + STR0096})
    AAdd(aFields, {"TotalOldSalaryPerBranch",          STR0041 + ' ' + STR0096, "number", STR0041 + ' ' + STR0096})
    AAdd(aFields, {"TotalOldHourSalaryPerBranch",      STR0042 + ' ' + STR0096, "number", STR0042 + ' ' + STR0096})
    AAdd(aFields, {"TotalAdditionalValuePerBranch",    STR0043 + ' ' + STR0096, "number", STR0043 + ' ' + STR0096})
    AAdd(aFields, {"TotalAdjustmentPerBranch",         STR0044 + ' ' + STR0096, "number", STR0044 + ' ' + STR0096})
    AAdd(aFields, {"TotalNewSalaryPerBranch",          STR0045 + ' ' + STR0096, "number", STR0045 + ' ' + STR0096})
    AAdd(aFields, {"TotalNewHourSalaryPerBranch",      STR0046 + ' ' + STR0096, "number", STR0046 + ' ' + STR0096})
    AAdd(aFields, {"TotalRoundingPerBranch",           STR0047 + ' ' + STR0096, "number", STR0047 + ' ' + STR0096})
    AAdd(aFields, {"EmployeesBranch",                  STR0102, "string", STR0102})
    self:addNestedProperty("EmployeesPerBranch", STR0103, STR0103, NIL, aFields)

    // Adiciona a nested property no segundo nível do objeto
    aFields := {}
    AAdd(aFields, {"BranchCodeBranch",         STR0048 + ' ' + STR0097, "string", STR0048 + ' ' + STR0097})
    AAdd(aFields, {"BranchNameBranch",         STR0049 + ' ' + STR0097, "string", STR0049 + ' ' + STR0097})
    AAdd(aFields, {"EmployeeCodeBranch",       STR0050 + ' ' + STR0097, "string", STR0050 + ' ' + STR0097})
    AAdd(aFields, {"EmployeeNameBranch",       STR0051 + ' ' + STR0097, "string", STR0051 + ' ' + STR0097})
    AAdd(aFields, {"CostCenterCodeBranch",     STR0052 + ' ' + STR0097, "string", STR0052 + ' ' + STR0097})
    AAdd(aFields, {"CategoryBranch",           STR0053 + ' ' + STR0097, "string", STR0053 + ' ' + STR0097})
    AAdd(aFields, {"UnionBranch",              STR0054 + ' ' + STR0097, "string", STR0054 + ' ' + STR0097})
    AAdd(aFields, {"AdmissionDateBranch",      STR0055 + ' ' + STR0097, "date",   STR0055 + ' ' + STR0097})
    AAdd(aFields, {"OldSalaryBranch",          STR0056 + ' ' + STR0097, "number", STR0056 + ' ' + STR0097})
    AAdd(aFields, {"OldHourSalaryBranch",      STR0057 + ' ' + STR0097, "number", STR0057 + ' ' + STR0097})
    AAdd(aFields, {"PercentualBranch",         STR0058 + ' ' + STR0097, "number", STR0058 + ' ' + STR0097})
    AAdd(aFields, {"AdditionalValueBranch",    STR0059 + ' ' + STR0097, "number", STR0059 + ' ' + STR0097})
    AAdd(aFields, {"AdjustmentBranch",         STR0060 + ' ' + STR0097, "number", STR0060 + ' ' + STR0097})
    AAdd(aFields, {"NewSalaryBranch",          STR0061 + ' ' + STR0097, "number", STR0061 + ' ' + STR0097})
    AAdd(aFields, {"NewHourSalaryBranch",      STR0062 + ' ' + STR0097, "number", STR0062 + ' ' + STR0097})
    AAdd(aFields, {"RoundingBranch",           STR0063 + ' ' + STR0097, "number", STR0063 + ' ' + STR0097})
    self:transformInNested("EmployeesBranch", NIL, aFields)

    // Parâmetros do relatório
    self:oSchema:addParameter("BranchCodeFrom",         STR0065, "string", .F.)
    self:oSchema:addParameter("BranchCodeTo",           STR0066, "string", .F.)
    self:oSchema:addParameter("EmployeeCodeFrom",       STR0067, "string", .F.)
    self:oSchema:addParameter("EmployeeCodeTo",         STR0068, "string", .F.)
    self:oSchema:addParameter("CostCenterCodeFrom",     STR0069, "string", .F.)
    self:oSchema:addParameter("CostCenterCodeTo",       STR0070, "string", .F.)
    self:oSchema:addParameter("FunctionCodeFrom",       STR0071, "string", .F.)
    self:oSchema:addParameter("FunctionCodeTo",         STR0072, "string", .F.)
    self:oSchema:addParameter("IncreaseBase",           STR0073, "string", .F.)
    self:oSchema:addParameter("IncreaseType",           STR0074, "string", .F.)
    self:oSchema:addParameter("IncreaseDate",           STR0075, "date",   .F.)
    self:oSchema:addParameter("UpdateRegister",         STR0076, "string", .F.)
    self:oSchema:addParameter("UpdateFunc",             STR0077, "string", .F.)
    self:oSchema:addParameter("UpdateDissidio",         STR0078, "string", .F.)
    self:oSchema:addParameter("Proportional",           STR0079, "string", .F.)
    self:oSchema:addParameter("CollectiveAgreement",    STR0080, "string", .F.)
    self:oSchema:addParameter("Union",                  STR0081, "string", .F.)
    self:oSchema:addParameter("RoundingType",           STR0082, "string", .F.)
    self:oSchema:addParameter("RoundingValue",          STR0083, "number", .F.)
    self:oSchema:addParameter("MonthsProp",             STR0084, "number", .F.)
    self:oSchema:addParameter("ApplyIncrease",          STR0085, "string", .F.)

    // Endpoints para lookup
    self:setCustomURL("BranchCodeFrom",         "/api/rh/smartview/v1/options/GPEParams/getBranches",               2)
    self:setCustomURL("BranchCodeTo",           "/api/rh/smartview/v1/options/GPEParams/getBranches",               2)
    self:setCustomURL("EmployeeCodeFrom",       "/api/framework/v1/genericLookupService/smartview/SRA",             2)
    self:setCustomURL("EmployeeCodeTo",         "/api/framework/v1/genericLookupService/smartview/SRA",             2)
    self:setCustomURL("CostCenterCodeFrom",     "/api/framework/v1/genericLookupService/smartview/CTT",             2)
    self:setCustomURL("CostCenterCodeTo",       "/api/framework/v1/genericLookupService/smartview/CTT",             2)
    self:setCustomURL("FunctionCodeFrom",       "/api/framework/v1/genericLookupService/smartview/SRJ",             2)
    self:setCustomURL("FunctionCodeTo",         "/api/framework/v1/genericLookupService/smartview/SRJ",             2)
    self:setCustomURL("CollectiveAgreement",    "/api/framework/v1/genericLookupService/smartview/SWY",             2)
    self:setCustomURL("Union",                  "/api/framework/v1/genericLookupService/smartview/RCE",             2)
    self:setCustomURL("IncreaseBase",           "/api/rh/smartview/v1/options/GPER200/getIncreaseBase",             1)
    self:setCustomURL("UpdateRegister",         "/api/rh/smartview/v1/options/GPER200/getSNOptions",                1)
    self:setCustomURL("UpdateFunc",             "/api/rh/smartview/v1/options/GPER200/getUpdateFunc",               1)
    self:setCustomURL("UpdateDissidio",         "/api/rh/smartview/v1/options/GPER200/getSNOptions",                1)
    self:setCustomURL("Proportional",           "/api/rh/smartview/v1/options/GPER200/getSNOptions",                1)
    self:setCustomURL("RoundingType",           "/api/rh/smartview/v1/options/GPER200/getRoundingType",             1)
    self:setCustomURL("ApplyIncrease",          "/api/rh/smartview/v1/options/GPER200/getApplyIncrease",            1)
    self:setCustomURL("IncreaseType",           "/api/rh/smartview/v1/options/GPER200/getIncreaseType",             1)

return self:oSchema
