#INCLUDE "PROTHEUS.CH"
#INCLUDE "FILEIO.CH"
#INCLUDE "GPEA1180.CH"
#INCLUDE "PONCALEN.CH"
#INCLUDE "HEADERGD.CH"
#INCLUDE "FWADAPTEREAI.CH"
#INCLUDE "FWLIBVERSION.CH"

Static lGp180Tra		:= ExistBlock("GP180TRA")
Static lGpe180Menu		:= ExistBlock("GP180MEN")
Static lGpe180Fit		:= ExistBlock("GP18FILT")
Static __cEmpAnt		:= ""
Static __cFilAnt		:= ""
Static __cArqTab
Static __cLastEmp
Static __cLastData
Static __cFil
Static __aMrkRecnos__	:= {}
Static __aMrkKeys__		:= {}
Static xNopc			:= 0
Static lIntegDef 		:= FindFunction("GETROTINTEG") .And. FindFunction("FWHASEAI")
Static cAA1Fil			:= ""
Static lInteRHAA1		:= IIf(FindFunction("IntegRHAA1"),IntegRHAA1(),.F.)
Static lIntTAF			:= ((SuperGetMv("MV_RHTAF",, .F.) == .T.) .AND. Val(SuperGetMv("MV_FASESOC",/*lHelp*/,' ')) >= 1 )
Static lMiddleware		:= If( cPaisLoc == 'BRA' .AND. Findfunction("fVerMW"), fVerMW(), .F. )
Static cVersEnvio		:= ""
Static cVersGPE			:= ""
Static lFuncTransf		:= .F.
Static cFiltroRet		:= ""
Static lGestPubl		:= if(ExistFunc("fUsaGFP"),fUsaGFP(),.F.)
Static cNTSV			:= SuperGetMv("MV_NTSV",,"701|711|712|741")
STATIC _RETTIT			:= 0
STATIC _SUBTIT			:= 0
Static lParcial			:= .F.
Static lTemRU1
Static lVerRJ5
Static cEmpSel			:= ""
Static oStaSPF
Static oStaRH3

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³ GPEA180  ³ Autor      ³ Equipe Advanced RH	 	  ³ Data ³12/07/1999³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descricao ³ Transferencias              				                       	    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ GPEA180()                                                       		³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³         ATUALIZACOES SOFRIDAS DESDE A CONSTRU€AO INICIAL.                  		³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Programador ³ Data   ³ BOPS      	    ³  Motivo da Alteracao                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Cecilia Carv³05/11/13³RHU210_01_24    ³Unificacao da Folha de Pagamento-         ³±±
±±³            ³        ³                ³Transferencia                             ³±±
±±³Emerson Camp³14/03/14³M_RH001/196101  ³Necessário setar a tabela do CC quando  	³±±
±±³            ³        ³                ³proveniente do portal protheus 			³±±
±±³Cecilia Carv³09/04/14³RHU210_01_24    ³Ajuste na transferencia entre matriculas. ³±±
±±³Cecilia Carv³07/05/14³TPIII1          ³Ajuste para nao mostrar opcao 'Manutencao'³±±
±±³            ³        ³                ³pois so pode ser utilizada pela Gestao Pu-³±±
±±³            ³        ³                ³blica.                                    ³±±
±±³            ³        ³TPLXLJ          ³Replica dos chamados TIIQ16, TIEPIJ e     ³±±
±±³            ³        ³                ³TPAZ80 versao 11.                         ³±±
±±³            ³        ³                ³Obs: por enquanto, nao serao retirados os ³±±
±±³            ³        ³                ³fieldpos da funcao Gpea180Trf devido a    ³±±
±±³            ³        ³                ³verificacao da tabela RI6 (base do MT/MP).³±±
±±³Flavio C.   ³21/07/14³TQDCUY          ³Ajuste na funcao ConsCC para mostrar a   '³±±
±±³            ³        ³                ³Descricao correta do C.C. quando troca    ³±±
±±³            ³        ³                ³empresa                                   ³±±
±±³Flavio C.   ³10/09/14³TQNIUG          ³Ajuste na transferencia quando MV_ORGCFG=1'³±±
±±³Renan Borges³22/09/14³TQKRZY          ³Ajuste para manter SQB corrente após rea- ³±±
±±³            ³        ³                ³lizar a busca da responsabilidade do fun- ³±±
±±³            ³        ³                ³cionário sob o departamento.              ³±±
±±³Alberto M.  ³18/11/14³TQYYEA          ³Ajustes para que campos nao usados nao    ³±±
±±³            ³        ³                ³aparecam na tela de Config.Campos         ³±±
±±³Christiane V³22/10/14³M_RH006/296902  ³Criação da função IntegDef.               ³±±
±±³Wag Mobile  ³15/01/15³TRCAK5      	 ³Ajuste na integracao Protheus x TSA, para ³±±
±±³            ³        ³                ³gravar no TSA o registro referente a trans³±±
±±³            ³        ³                ³ferencia.                                 ³±±
±±³Renan Borges³27/02/15³TRRAKF      	 ³Ajuste para não permitir transferência da ³±±
±±³            ³        ³        		 ³tabela de Acumulados de Pré-Leitura.      ³±±
±±³Henrique V. ³25/06/15³TSMVJR          ³Ajuste para que o campo RA_OBSDEFI tenha  ³±±
±±³            ³        ³                ³seu conteúdo transferido corretamente para³±±
±±³            ³        ³                ³o destino                                 ³±±
±±³Flavio C.   ³28/07/15³TSUNJ1          ³Verificar alteração salarial somente se   ³±±
±±³            ³        ³                ³o campo estiver selecionado para alteção  ³±±
±±³Cícero Alves³29/07/15³TSWCKS          ³Adicionado campos de descrição para filial³±±
±±³            ³        ³                ³empresa, CC ...							³±±
±±³Flavio C.   ³30/07/15³TSZJFL          ³Alterada a checagem de Periodo/Data de Ref³±±
±±³            ³        ³                ³no momento da seleção pois é possivel     ³±±
±±³            ³        ³                ³ter processos com periodos diferentes     ³±±
±±³GSantacruz  ³18/08/15³REQ-5930        ³Se modifico la validacion del Depto en la ³±±
±±³            ³        ³                ³funcion GP180LinOk para que lo haga sobre ³±±
±±³            ³        ³                ³la empresa destino.                       ³±±
±±³Marcelo F.  ³22/09/15³PCREQ-5351      ³Produtização da Gestão Pública V12        ³±±
±±³Allyson M.  ³16/10/15³TTPMJ1          ³Ajuste p/ integracao com TSA p/ guardar o ³±±
±±³            ³        ³                ³valor do cracha antes da exclusao para    ³±±
±±³            ³        ³                ³uso no TSA.								³±±
±±³Matheus M.  ³04/12/15³TTRKWH          ³Ajuste para apresentar a descrição do     ³±±
±±³            ³        ³                ³Centro de Custo Origem/Destino.  			³±±
±±³Marcos Perei³04/12/15³PCDEF-86831     ³-Ajuste inicializacao lGestPubl e dDataTra³±±
±±³            ³        ³                ³-Retirada opcao Excluir. Futuramente sera	³±±
±±³            ³        ³                ³ reavalidada p/manter integridade na SRE 	³±±
±±³Matheus M.  ³11/12/15³TTNSV7	   		 ³Tratativas na rotina de transfêrencia     ³±±
±±³            ³        ³        		 ³para os chamados TTNSV7 e TTSJVI          ³±±
±±³            ³        ³        		 ³TTNSV7 - Levar os abonos para filial dest.³±±
±±³            ³        ³        		 ³TTSJVI - Levar os calc VT para a  filial  ³±±
±±³            ³        ³        		 ³destino.								    ³±±
±±|Allyson M   |05/01/16|TUCYNQ      	 |Ajuste na transferência quando funcionario³±±
±±|            |        |        		 |esta no processo 000003					³±±
±±|Marcelo M.  |04/02/16|TUKDXF     	 |Integração com o modulo gestao de servicos ³±±
±±|            |        |        		 |para integracao Funcionario x Atendente  	³±±
±±|Renan Borges|20/04/16|TUU133      	 |Ajuste para realizar a transferencia, pos-³±±
±±|            |        |        		 |suindo um departamento com Centro de Custo³±±
±±|            |        |        		 |sem gerar a mensagem de que o Centro de   ³±±
±±|            |        |        		 |Custo do Departamento é diferente do Cen- ³±±
±±|            |        |        		 |tro de Custo do funcionario, mesmo quando ³±±
±±|            |        |        		 |ele não foi alterado.                     ³±±
±±|Renan Borges|10/05/16|TUUGR8      	 |Ajuste para que ao ser realizada a transfe³±±
±±|            |        |        		 |rência entre Filiais, seja gravado correta³±±
±±|            |        |        		 |mente o campo RA_AFASFGT.Ajuste para visua³±±
±±|            |        |        		 |lização de funcionários demitidos, sem per³±±
±±|            |        |        		 |mitir transferi-los.                      ³±±
±±|Gabriel A.  |06/06/16|TVGKFO          |Correção na transferência de processos.   ³±±
±±|Gabriel A.  |10/06/16|TVJK57          |Retirada a opção de "selecionar todos",   ³±±
±±|            |        |                |pois só é possível transferir 50.         ³±±
±±|Allyson M   |01/07/16|TVDTO8      	 |Ajuste p/ guardar data correta de transfe-³±±
±±|            |        |        		 |rencia anterior p/ integração TSA			³±±
±±|Raquel Hager|06/07/16|TVKMV1      	 |Reativação do uso do parâmetro MV_REUTMAT.³±±
±±|            |07/07/16|      	         |Incluida validação no uso da var. nTpPgt. ³±±
±±|            |08/07/16|          	     |Ajuste na validação da gravação da transfe³±±
±±|            |        |          	     |ao realizar troca de Processo/Tp.Pagamento³±±
±±|            |        |          	     |usando o mesmo código de matrícula.       ³±±
±±|Renan Borges|23/08/16|TVPPIQ     	 |Ajuste para ao transferir um funcionário  ³±±
±±|            |        |        		 |de filial, não sejam apagados seus valores³±±
±±|            |        |        		 | de férias da filial de origem.           ³±±
±±|Raquel Hager|30/08/16|TVW525     	 |Ajuste para ao transferir um funcionário  ³±±
±±|            |        |        		 |via rotina automática, tela não seja fecha³±±
±±|            |        |        		 |da.										³±±
±±|Raquel Hager|31/08/16|TVW525     	 |Remoção de ajuste indevido.				³±±
±±|Raquel Hager|14/09/16|TVSSUQ     	 |Ajuste para transferência de dados quando ³±±
±±|            |        |        		 |ocorre apenas trans. de Matrícula.        ³±±
±±|M. Silveira |07/11/16|TWLDZ8          |Incluida fGp180Ok para exibir mensagem de ³±±
±±|            |        |                |confirmacao antes de fazer a transferencia³±±
±±|Renan Borges|13/12/16|MRH-1191        |Ajuste para ao transferir funcionário de  ³±±
±±|            |        |                |centro de custo, se houverem verbas ratea-³±±
±±|            |        |                |das, e alguma delas for do centro de custo³±±
±±|            |        |                |origem, esta verba será acumulada na verba³±±
±±|            |        |                |do centro de custo destino.               ³±±
±±|Marcos Cout.|21/12/16|MRH-879         |Ajustes para a rotina de transferência de ³±±
±±|            |        |                |funcionários não gerar error.log caso     ³±±
±±|            |        |                |exista campos customizados com nomes seme-³±±
±±|            |        |                |lhantes posicionados antes dos campos ofi-³±±
±±|            |        |                |ciais do sistema.                         ³±±
±±|Allyson M   |10/01/17|MRH-4023    	 |Ajuste p/ transferir a RI1, RIQ e RIR	 	³±±
±±|Marcelo F.  |09/01/17|MRH-4506        |Melhoria para tratar o controle automatico³±±
±±|            |        |                |de matricula por grupo de empresas.     	³±±
±±|Renan Borges|17/01/17|MRH-1190        |Ajuste para quando funcionário possuir    ³±±
±±|            |        |                |departamento seja permitido sua transferên³±±
±±|            |        |                |cia para nenhum depart.                   ³±±
±±|Renan Borges|23/01/17|MRH-4702        |Ajuste para quando não confirmar a transfe³±±
±±|            |        |                |rência não seja gerado error.log.         ³±±
±±|Paulo       |20/02/17|MRH-6707        |Adicionado o campo RC_SEQ na comparação de³±±
±±|Inzonha     |        |463256          |campos alterados, evitando a duplicação   ³±±
±±|            |        |                |da sequencia e erro de duplicidade de     ³±±
±±|            |        |                |chave unica.								³±±
±±|Renan Borges|26/04/17|DRHPONTP-301    |Ajuste para ao aprovar uma solicitação de ³±±
±±|            |        |                |Transferência, o sistema trazer o posto   ³±±
±±|            |        |                |que foi informado na solicitação.         ³±±
±±|Paulo  O.   |18/05/17|DRHPAG-915      |Correção na transferencia entre empresas  ³±±
±±|Inzonha     |        |                |pois estava validando se a matricula      ³±±
±±|            |        |                |existia na empresa origem e não na destino³±±
±±|Marcelo F.  |21/05/17|DRHPONTP-604    |Ajuste na chamada para transf. de postos  ³±±
±±|Claudinei S.|31/05/17|DRHESOCP-323	 |Tratamento para envio do registro S-2206, ³±±
±±|            |  	    |           	 |Alteração Contratual Individual.          ³±±
±±|Claudinei S.|02/06/17|DRHESOCP-334	 |Alteração somente para subir no pacote.   ³±±
±±|Cícero Alves|09/06/17|DRHPAG-1818     |Ajuste para acrescentar a sequência do lan³±±
±±|            |        |                |çamento na chave da RGB					³±±
±±|Cícero Alves|16/06/17|DRHPAG-2593     |Ajuste na transferência de posto 			³±±
±±|Paulo O. I. |22/06/17|DRHPAG-3441     |Ajuste para atualizar vinculo funcional   ³±±
±±|Oswaldo L   |03/08/17|DRHESOCP-755    |Merge e-social 11.80 e 12.1.17            ³±±
±±|Isabel N.   |01/09/17|DRHPAG-5512     |Ajustes: controle automático de matrículas³±±
±±|Eduardo K.  |18/09/17|MPRIMESP-11461  |Ajuste na chamada das variaveis cDeptoDe e³±±
±±|            |        |                |cDeptoAte na função GRAVA_SRE.            ³±±
±±|E.Moskovkina|27/09/17|MA3A-714		 |New condition for filter-string in 		³±±
±±|            |        |                |function GPFILSQB for RUS localization	³±±
±±|Oswaldo L   |21/12/17|DRHPAG-9991     |Tratar acessos diretos na SX2, pontuados  ³±±
±±|            |        |                |pelo sonarqube                            ³±±
±±|Jaqueline L |29/12/17|DRHPAG-10653    |Comentado o ponto que fecha a SRD, pois   ³±±
±±|            |        |                |quando existe trans. em lote gerava proble³±±
±±|            |        |                |ma ao transferir o segundo funcionário    ³±±
±±|Cecília Carv|08/01/18|DRHESOCP-2682   |Ajuste para geração de contrato intermiten³±±
±±|            |        |                |te - evento S-2200.                       ³±±
±±|Eduardo K.  |07/02/18|MPRIMESP-12593  |Ajuste para restaurar o código da filial  ³±±
±±|            |        |                |ao executar a integração (EAI).           ³±±
±±|João Balbino|16/04/18|MPRIMESP-14673  |Ajuste para corrigir as consultas padrões ³±±
±±|            |        |                |de filial de destino.                     ³±±
±±|João Balbino|17/04/18|MPRIMESP-14673  |Ajuste para gerar a numeração automatica  ³±±
±±|            |        |                |na troca de empresa.                      ³±±
±±|Eduardo P.  |26/02/20|DMINA-8529      |Ajuste  en función gp180LinOk para cuando ³±±
±±|            |        |                |es rutina automatica. (MEX)               ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function GPEA180( nOpcAuto, xAutoItens, dDataTransf, lAutomato, lAddAux )

Local aArea			:= GetArea()
Local aAreaSRA		:= SRA->( GetArea() )
Local aOfusca		:= If(FindFunction('ChkOfusca'), ChkOfusca(), { .T., .F., {"",""} }) //[1]Acesso; [2]Ofusca; [3]Mensagem
Local lBlqAcesso	:= .F.
Local cSvArqTab 	:= cArqTab
Local nSvSetMaxCod	:= SetMaxCodes( 9999 )
Local bBlock
Local nPos
Local lAceRCJ		:= .T.  //Variavel utilizada para validar se o modo de acesso a tabela RCJ esta compartilhado
Local lAceRCH		:= .T.  //Variavel utilizada para validar se o modo de acesso a tabela RCH esta compartilhado

Private cArmCodRd0	:= ""			// Armazena o Cod RD0 da pessoa antes de inciar a cópia
Private dDataTra	:= If( Empty(dDataTransf), firstDay(dDataBase), dDataTransf )
Private dDataTAF	:= CTOD("//")
Private lGestPubl	:= if(ExistFunc("fUsaGFP"),fUsaGFP(),.f.)	//Verifica se utiliza o modulo de Gestao de Folha Publica - SIGAGFP
Private aAutoItens	:= xAutoItens
Private lRobo 		:= .F.
Private lAdd 		:= .F.
Private lCorpManage := fIsCorpManage()
Private cConCTT		:= .F.
Private cConDept	:= .F.
Private cConProc	:= .F.
Private cConPosto	:= .F.
Private cConPeriod	:= .F.
Private cConNrPag	:= .F.
Private cConTurn	:= .F.
Private cConFunc	:= .F.
Private cConRegr	:= .F.
Private cConSeq		:= .F.
Private cConSM0		:= .F.

Default lAutomato 	:= .F.
Default lAddAux 	:= .F.

	If lAutomato
		lRobo 	:= .T.
		lAdd	:= lAddAux
	Else
		lBlqAcesso := aOfusca[2] .And. !Empty( FwProtectedDataUtil():UsrNoAccessFieldsInList( {"RA_NOME"} ) )
	Endif

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Reinicializa __aUniqueKey__ das consultas via Tecla <F3> que sao  monta³
	//³ das com Chave Unica ("SMO" para Empresas e "CTT" para C. C.			   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	UniqueKey()

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Funcao verifica se existe alguma restrição de acesso para o³
	//³usuário que impeça a execução da rotina.                   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If !( fValidFun({"SRB","SRC","SRD","SRF","SRG","SRH","SRK","SRO","SRR","SRS","SRQ","SRT","SR0","SR7","SR3","SR8","SR9","RG1","RCP","RCR","RGB","RIA","RFX"}, ,.T. ))
		Return
	Endif

	Private lUsadoGP		:= .F.
	Private aRotina			:= MenuDef()
	Private aTpAlt			:= {.F.,.F.,.F.}
	Private cFiltraRh		:= ""
	Private bFiltraBrw		:= { || NIL }	//Variavel para Filtro
	Private aIndexSRA		:= {}

	Private cCPFDe			:= ""
	Private cCPFAte			:= ""

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Define o cabecalho da tela de atualizacoes                  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	Private cCadastro	:= ""
	Private lGpea180Flt := .F.					//Verifica se havera filtro de Browse para o GPEA180
	Private lCtrAutoMat	:= .F.					//Checa se o controle Automatico de Matricula esta ativado e se havera transferencia de matricula
	Private aAutoMat  	:= {}					//Array com a matricula gerada quando o controle Automatico esta ativado

	Private cOrgCfg		:= SuperGetMv("MV_ORGCFG", NIL, "0" )	//-- Controlde de Postos : 0-não usa Sigaorg;1-Tem controle de postos; 2- não tem  controle de postos

	Private _CITEM
	Private _CCLVL

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Verifica se eh Gestao Publica                                 ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If GetMv( "MV_GSPUBL",, "1" ) == "2" .and. !lGestPubl // Gestao Publica 1=Nao; 2=Sim  (modelo antigo, não aplicado ao SIGAGFP Gestão de Folha Publica)
		lUsadoGP := .T.
	EndIf

	If lGestPubl
		cCadastro	:= OemToAnsi( STR0251 )
	Else
		cCadastro	:= OemToAnsi( STR0008 )
	EndIf

	Private cModuloFlt	:= cModulo  				// Variavel para o filtro do Periodo por modulo
	Private cPeriodo 	:= "" 						// Variavel para o filtro dos dias de pagto conform periodo
	Private cItemClvl	:= SuperGetMv( "MV_ITMCLVL", .F., "2" )
	Private lItemClvl   := cItemClvl $ "1*3"
	Private cContrMat	:= StrTran(SuperGetMv("MV_MATRICU",NIL,"0"),'"','')
	Private lTpDesl		:= (lIntTAF .Or. lMiddleware) .And. X3USADO('RE_DESL')
	Private lRfzCmp    	:= X3USADO('RFZ_DTTRA')
	Private lGeraDem	:= .F.

	If lMiddleware .And. !ChkFile("RJE")
		Help( " ", 1, OemToAnsi(STR0047),, OemToAnsi(STR0289), 1, 0 )//"Tabela RJE não encontrada. Execute o UPDDISTR - atualizador de dicionário e base de dados."
		Return
	EndIf

	// REALIZA A VALIDAÇÃO DA VERSÃO DO ESOCIAL.
	If lIntTaf .Or. lMiddleware
		If FindFunction("fVersEsoc")
			fVersEsoc("S1030", .F.,,, @cVersEnvio, @cVersGPE)
		EndIf
		If FindFunction("ESocMsgVer") .And. !lMiddleware .And. cVersGPE <> cVersEnvio .And. (cVersGPE >= "9.0" .Or. cVersEnvio >= "9.0")
			//"Atenção! A versão do leiaute GPE é xxx e a do TAF é xxx, sendo assim, estão divergentes. O Evento xxx não será integrado com o TAF, e consequentemente, não será enviado ao RET.
			//Caso prossiga a informação será atualizada somente na base do GPE. Deseja continuar?"
			If ESocMsgVer(.F.,/*cEvento*/, cVersGPE, cVersEnvio)
				lIntTaf := .F.
			Else
				Return
			EndIf
		EndIf
	EndIf

	//Tratamento de acesso a Dados Sensíveis
	If lBlqAcesso
		//"Dados Protegidos- Acesso Restrito: Este usuário não possui permissão de acesso aos dados dessa rotina. Saiba mais em {link documentação centralizadora}"
		Help(" ",1,aOfusca[3,1],,aOfusca[3,2],1,0)
		Return
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Quando nao usa SIGAORG adequar a posicao dos campos: processo/descricao³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If Empty(cContrMat)
		cContrMat := "0"
	EndIf

	If lItemClvl
		If (cOrgCfg == "1")
			_CITEM:= _DPOSTO+1
		Else
			_CITEM:= _DPROCE+1
		Endif
		_CCLVL:= _CITEM+1
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Aviso caso o modo de acesso das tabelas RCJ e RCH seja exclusivo³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If cPaisLoc == "MEX"

		If FWModeAccess( "RCJ", 3)  == "E"
			lAceRCJ := .F.
		EndIf

		If FWModeAccess( "RCH", 3)  == "E"
			lAceRCH := .F.
		EndIf

		If lAceRCJ == .F. .OR. lAceRCH == .F.
			Aviso(OemToAnsi(STR0047), OemToAnsi(STR0167) + CRLF + OemToAnsi(STR0168) + CRLF+ OemToAnsi(STR0091) ,{"OK"}) //"Atenção"#"A tabelas 'RCH/RCJ' estao em Modo de Acesso Exclusivo"#"Altere o Modo de Acesso Atraves do Configurador."#"Consulte o Administrador do Sistema".
			Return(Nil)
		Endif
	Endif

	existF3New(@cConCTT, @cConDept, @cConProc, @cConPosto, @cConPeriod, @cConNrPag,@cConTurn,@cConFunc,@cConRegr,@cConSeq,@cConSM0)

	//Guarda a filial da AA1 para replicar a transferencia
	cAA1Fil := xFilial("AA1")

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Rotina Automatica                                                      ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	IF ( nOpcAuto <> NIL )
		nPos := aScan( aRotina , { |x| x[4] == nOpcAuto } )
		IF ( nPos <> 0 )
			dbSelectArea("SRA")
			bBlock := &( "{ |a,b,c,d| " + aRotina[ nPos,2 ] + "(a,b,c,d) }" )
			Eval( bBlock, "SRA" , SRA->( Recno() ) , nPos )
		EndIF

	Else
		If !lGestPubl //Folha Padrão
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Inicializa o filtro utilizando a funcao FilBrowse                      ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		Fil180Browse()
		lGpea180Flt := .T. //Existe Filtro

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Endereca a funcao de BROWSE                                  ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		dbSelectArea( "SRA" )
		SRA->( dbGoTop() )
		mBrowse( 6 , 1 , 22 , 75 , "SRA" , NIL , NIL , NIL , NIL , NIL , fCriaCor() )

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Deleta o filtro utilizando a funcao FilBrowse                     	   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		EndFilBrw("SRA",aIndexSra)
		Else
			oBrowse := FWMBrowse():New()
			oBrowse:SetAlias('SRA')
			oBrowse:SetDescription(cCadastro)//Transferencias
			GpLegend(@oBrowse,.T.) //Cria legenda
			oBrowse:SetMenuDef( 'GPEA180' )
			oBrowse:SetChgAll(.F.)

			//------------------------------------------
			//Busca o filtro a ser utilizado no Browse
			//------------------------------------------
			cFiltraRh 	:= CHKRH("GPEA180","SRA","1")

			//Filtro padrao do Browse
			oBrowse:SetFilterDefault(cFiltraRh)
			oBrowse:Activate()
		EndIF

		//Restaura as variaveis de entrada
		cArqTab	:= cSvArqTab
		SetMaxCodes( nSvSetMaxCod )
		RestArea( aAreaSRA )
		RestArea( aArea )
	EndIf
Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³Gpea180Mat³ Autor ³ Kleber Dias Gomes     ³ Data ³12/07/99  ³±±
±±³          ³          ³       ³ Natie Sugahara        ³      ³22/02/08  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Programa Para Transferir os dados do Funcionario           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ Gpea180Mat(cAlias,nReg,nOpc)                               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ cAlias = Alias do arquivo                                  ³±±
±±³          ³ nReg   = Numero do registro                                ³±±
±±³          ³ nOpc   = Numero da opcao selecionada                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ GPEA180                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function Gpea180Mat(cAlias,nReg,nOpc,lAuto,aCpoAuxSRA )

	Local aArea				:= GetArea()
	Local aAreaSRA			:= SRA->( GetArea() )
	Local aFilesTransf		:= {}
	Local bGpea180Prc		:= { || Gpea180Prc() }
	Local bChkEmpAte		:= { || .T. }
	Local bChkFilAte		:= { || .T. }
	Local bChkCcAte			:= { || .T. }
	Local bChkDeptoAte		:= { || .T. }
	Local bChkProces		:= { || .T. }
	Local bChkPostoAte		:= { || .T. }
	Local bMsDialogVld		:= { || .T. }
	Local bMakeLog			:= { || NIL }
	Local bSet15			:= { || .T. }
	Local bSet24			:= { || .T. }
	Local bChkItemAte		:= { || .T. }
	Local bChkClvlAte		:= { || .T. }
	Local bChkQuality		:= { || .T. }

	Local bAgenda
	Local bLegenda
	Local bTransf
	Local bPosto
	Local bLogPreview
	Local bFiltSRA

	Local aButtons			:= {}

	Local cCcXb				:= ""
	Local cDptoXb			:= ""
	Local cFiltSRA			:= ""
	Local lSraLock			:= .F.
	Local lNaoTemPosto		:= .F.
	Local nOpcA				:= 2
	Local nSavRecT			:= 0
	Local nSavRec			:= 0
	Local nOpcNewGd			:= IF( nOpc == 2 , 0 ,GD_UPDATE + GD_DELETE )
	Local nPosRec			:= 0
	Local nPosRec1			:= 0
	Local nPos				:= 0
	Local nX				:= 0
	Local oDlg
	Local oFont
	Local oGroup
	Local oGroup1
	Local oGroup2
	Local oGroup11
	Local oGroup21
	Local cMsg				:= ""
	Local cProc				:= ""
	Local cTpRot			:= "3"
	Local cRot				:= ""
	Local cSem				:= ""

	Local oGet
	Local oGet1

	Local oFolder1

	//-- Variaveis da configuração do dialogo principal
	Local aAdvSize			:= {}
	Local aInfoAdvSize		:= {}
	Local aObjCoords		:= {}

	Local aAdv1Size			:= {}
	Local aObj1Coords		:= {}

	Local aParTela			:= {}
	Local lPortal			:= IsInCallStack( "TCFA040Atende" )
	Local aFilP				:= {}
	Local cDescEmpr			:= ""
	Local cDescFil			:= ""
	Local nY				:= 0
	//Robo
	Local nPosFil			:= 0
	Local nPosMat			:= 0
	Local nPosCpo			:= 0
	Local nCampo			:= 0
	Local nFunc				:= 0
	Local nPosTr			:= 0
	Local nSalSRJ			:= 0
	Local nPosSal			:= 0
	Local cDescSRJ			:= ""
	Local nPosDesc			:= 0

	Default lAuto			:= .F.
	Default aCpoAuxSRA		:= {}

	//Inicializa as Statics
	__cArqTab := cArqTab
	__cFilAnt := cFilAnt
	__cEmpAnt := cEmpAnt
	__cLastEmp := cEmpAnt+cFilAnt
	__cLastData:= ""

	//Monta Array para o Relacionamento das Entidades
	Private aRelation		:= {}
	Private lSraRelation	:= .F.

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Define Variaveis Privadas                                    ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	Private aInfo			:= {}
	Private lTemCpoCompl	:= .F.
	Private aKeyCcFilter	:= {}
	Private cAliasCc		:= "CTT"
	Private cAliasDpto		:= "SQB"
	Private cAliasIt		:= "CTD"
	Private cAliasCL		:= "CTH"
	Private cFilMat			:= " "
	Private cCcusto			:= " "
	Private __cSvFilAnt		:= cFilAnt	//Salva a Filial Corrente
	Private __cSvEmpAnt		:= cEmpAnt	//Salva a Empresa Corrente
	Private cObsTra			:= Space(30)
	Private cFilDe			:= ""
	Private cMatDe			:= ""
	Private cCcDe			:= ""
	Private cProcesDe		:= ""
	private cDeptoDe		:= ""
	Private cPostoDe		:= ""
	Private cModoRCJ		:= "C"
	Private uAliasNewEmp
	Private cItemde			:= ""
	Private cClvlDe			:= ""
	Private cItem			:= ""
	Private cClasse 		:= ""
	Private cPer			:= ""
	Private cCodDesl		:= ""
	Private cMsgErr			:= ""

	Private lIntGPE			:= If(GetMv("MV_QGINT",.F.,"N") == "S",.T.,.F.)
	Private lReutMat		:= SuperGetMv("MV_REUTMAT",.F.,.F.)  //Se .t. nao permitira alterar o numero da matricula destino e ira sobrepor caso seja por Lote e ja exista a matricula destino

	Private aSvTransfCols	:= {}
	Private aSv1TransfCols	:= {}
	Private aSRAVirtual		:= {}
	Private aSRAVisual		:= {}
	Private aRecnosSRA		:= {}
	Private aKeys			:= {}
	Private aFields			:= {}
	Private aSRAHeader		:= {}
	Private aSRACols		:= {}
	Private aFields1		:= {}
	Private aSvSraCols		:= {}
	Private aRecnosAll		:= {}
	Private aAllHeader		:= {}
	Private aTransfHeader	:= {}
	Private aTransf1Header	:= {}
	Private aFuncTran		:= {}
	Private aTabCompany	:= {}	// Array para controlar abertura das tabelas de outras empresas

	Private oGetSRA1
	Private oGetSRA2
	Private oGetSRA11
	Private oGetSRA21

	Private nOpcaoA180		:= nOpc
	Private	lPreview		:= .F.
	Private cRtFol			:= ""
	Private cRtAut			:= ""

	xNopc := nOpc

	BldArrRdZRel( @aRelation )
	lSraRelation := ( aScan( aRelation , { |x| Upper(AllTrim(x[1])) == "SRA" } ) > 0 )

	lCorpManage		:= fIsCorpManage()

	//--Utilizacao do modulo SIGAGFP (gestao de folha publica)
	lGestPubl 	:= If( type("lGestPubl")=="U", if(ExistFunc("fUsaGFP"),fUsaGFP(),.f.) ,lGestPubl)

	//Quando Portal, a dDataTra ainda nao foi inicializada
	dDataTra	:= If( type("dDataTra")=="U", dDataBase, dDataTra )

	Begin Sequence

		Sx2ChkModo( "RCJ", NIL, .F., @cModoRCJ )	// Verificar o modo da tabela RCJ
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Define Qual a Consulta Padrao para o Cadastro de Centros   de³
		//³ Custo e a Chave de Filtro									         ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		cCcXb			:= "XTT"

		aKeyCcFilter	:= { PrefixoCpo( cAliasCc ) + "_FILIAL" , PrefixoCpo( cAliasCc ) + "_CUSTO" }

		If lItemClVl
			cItXb		:= "CTD"
			cClXb		:= "CTH"
		EndIf

		cDptoXb		:= "SQB"
		cPostoXb	:= "RCLOR1"

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Nao Permitir que Funcionario de Outra Filial seja Transferido³
		//³ em Funcao de estar sendo Monstrado na mBrowse()              ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		IF ( SRA->RA_FILIAL != xFilial( "SRA" ) )
			Break
		EndIF

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Posiciona no proximo Funcionario apos MarkBrowse e retorna p/³
		//³ para o recno                                                 ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		nSavRecT := SRA->( Recno() )
		SRA->( dbSkip() )
		If SRA->( !Eof() )
			nSavRec  := SRA->( Recno() )
			SRA->( dbGoTo(nSavRecT) )
		Else
			SRA->( dbGoTo(nSavRecT) )
			nSavRec := nSavRecT
		Endif

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Variaveis de Gets da Transferencia                           ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		Private cEmpAte		:= __cSvEmpAnt
		Private cFilAte		:= __cSvFilAnt
		Private cCcuAte		:= Space( TamSx3( "RA_CC" )[1] )
		Private cMatAte		:= SRA->RA_MAT
		Private cDeptoAte	:= Space( TamSx3( "RA_DEPTO" )[1] )
		Private cPostoAte	:= Space( TamSx3( "RA_POSTO" )[1] )
		Private cItemAte	:= ""
		Private cClvlAte	:= ""
		Private cCc			:= ""
		Private cDepto		:= ""

		Private cCgcDe		:= ""
		Private cCgcPara	:= ""
		Private cTpInscPara	:= ""
		Private cProces		:= Space( TamSx3( "RA_PROCES" )[1] )
		Private cDescProc	:= ""

		Private lMatDif		:= .F.
		Private lProcDif	:= .F.
		Private lCcDif		:= .F.
		Private lFilDif		:= .F.
		Private lEmpDif		:= .F.
		Private lTrfEmpES	:= .F.
		Private lCgcDif		:= .F.
		Private lDeptoDif	:= .F.
		Private lPostoDif	:= .F.
		Private lDelNovo 	:= .F.
		Private lGravaNovo	:= .F.
		Private lDelAntigo	:= .F.
		Private lRegrava	:= .F.
		Private lMudaSra	:= .F.
		Private lItemDif	:= .F.
		Private lClvlDif	:= .F.
		Private lCpfDif		:= .F.

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Obtem a Filial de Origem                                     ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		cFilDe 		:= SRA->RA_FILIAL
		cMatDe 		:= SRA->RA_MAT
		cCPFDe		:= SRA->RA_CIC

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Monta aheader e aCols com todos os campos do SRA             ³
		//³ Sera utilizada para gerar as todas as var.Memoria dos campos ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		aSRAHeader	:= {}
		aSRACols	:= {}

		If lItemClvl .And. type("_CITEM")=="U"
			If (cOrgCfg == "1")
				_CITEM:= _DPOSTO+1
			Else
				_CITEM:= _DPROCE+1
			Endif
			_CCLVL:= _CITEM+1
		EndIf

		If lItemClvl
			cItemAte	:= Space( TamSx3( "RA_ITEM" )[1] )
			cClvlAte	:= Space( TamSx3( "RA_CLVL" )[1] )
		EndIf

 		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Montagem do aHeader com os campos da transferencia e cpos    ³
		//³ complementares                                               ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		lFuncTransf := .F.

		cRtFol		:= fGetCalcRot("1")
		cRtAut		:= fGetCalcRot("9")

		aAllHeader	   := fMontaHeader(.T.)
		aTransfHeader  := aAllHeader[1]
		aTransf1Header := aAllHeader[2]

		If Len(aSRACols) <= 0
			Break
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Salva SRA  em  Var.de memoria                                ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		For nX := 1 To Len(aSRAHeader)
			Private &( "M->"+ aSRAHeader[ nX , 02 ] ) := aSRACols[ 01 , nX ]
		Next nX

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Monta aCols                                                  ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		fMontaCols(.T., @lNaoTemPosto)
		aSvTransfCols  := aClone(aTransfCols)
		aSv1TransfCols := aClone(aTransf1Cols)

		uAliasNewEmp := fGetAlias(aTransfHeader,aTransf1Header)

		If lNaoTemPosto
			MsgAlert( OemToAnsi(STR0140) + CRLF +       ;	// "O parametro MV_ORGCFG esta configurado para utilizar o Controle de Postos"
					  OemToAnsi(STR0141) + CRLF +       ;	// "Funcionarios sem informacao de ocupacao de Posto "
					  OemToAnsi(STR0142)               ,;	// "nao poderao ser transferidos "
					  OemToAnsi(STR0047) ) 					// "Atencao"
		Endif

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Monta Bloco para Validacao da Empresa Ate                    ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		bChkEmpAte	:= { || Ch_Emp() .and. CheckSX3("RE_EMPP") }

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Monta Bloco para Validacao da Filial Ate                     ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		bChkFilAte	:= { || Ch_Fil() .and. CheckSX3("RE_FILIALP") }

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Monta Bloco para Validacao do Centro de Custo Ate            ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		bChkCcAte	:= { || ConsCc() .and. CheckSX3("RE_CCP") }

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Monta Bloco para Validacao do Centro de Custo Ate            ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		bChkDeptoAte	:= { || ConsDepto() .and. CheckSX3("RE_DEPTOP") }

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Monta Bloco para Validacao do Centro de Custo Ate            ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If (cOrgCfg == "1")
			bChkPostoAte	:= { || ConsPosto() .and. CheckSX3("RE_POSTOP") }
		Endif

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Monta Bloco para Validacao do Processo          	            ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		bChkProces	:= { || ConsProc() .and. CheckSX3("RE_PROCESP") }

		If lItemClvl
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Monta Bloco para Validacao do Item Contabil Ate              ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			bChkItemAte	:= { || ConsItem() .and. CheckSX3("RE_ITEMP") }
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Monta Bloco para Validacao do Classe de Valor Ate            ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			bChkClvlAte	:= { || ConsClvl() .and. CheckSX3("RE_CLVLP") }
		EndIf
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Monta Bloco Salvar dados do Acols    em Var.Memoria          ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		bSvColsToMem:= {|nLinObj| fSvColsToMem(nLinObj) }

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Monta Bloco para Validacao do bloqueio do PCO                ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		bChkPCO   		:= { || PcoVldBlq()  }

	    //Verifica se tem integracao com o Quality e se o usuario tem movimentacao nos ambientes de qualidade...
		If lIntGPE .and. GetMv("MV_QVLUSAR",.T.,"2") == "1"
			bChkQuality := { || QA_VLUSA(cFilAte,cMatAte,cEmpAte)}
		Endif

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Monta Bloco para Validacao do Dialog                         ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If lItemClVl

			bMsDialogVld	:= { || IF( nOpca == 1 ,;
									(	Eval( bChkEmpAte );
										.and.;
									   	Eval( bChkFilAte );
									   	.and.;
									  	Eval( bChkCcAte );
									  	.and.;
										Eval( bChkProces );
									   	.and.;
									  	Eval( bChkDeptoAte );
									  	.and.;
										Eval( bChkPostoAte );
										.and.;
									  	Eval( bChkItemAte );
									  	.and.;
									  	Eval( bChkClvlAte );
									  	.and.;
									  	Eval( bChkPCO );
										.and.;
										Eval( bChkQuality );
									),;
									.T.;
									)}

		Else
			bMsDialogVld	:= { || IF( nOpca == 1 ,;
									(	Eval( bChkEmpAte );
										.and.;
									   	Eval( bChkFilAte );
									   	.and.;
									  	Eval( bChkCcAte );
									  	.and.;
										Eval( bChkProces );
									   	.and.;
									  	Eval( bChkDeptoAte );
									  	.and.;
										Eval( bChkPostoAte );
										.and.;
									  	Eval( bChkPCO );
										.and.;
										Eval( bChkQuality );
									),;
									.T.;
									)}

		EndIf
		PcoIniLan('000086')

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Monta dimensoes da Tela                                      ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		aAdvSize		:= MsAdvSize()
		aInfoAdvSize	:= { aAdvSize[1] , aAdvSize[2] , aAdvSize[3] , aAdvSize[4] , 5 , 5 }
		aAdd(aObjCoords, { 000, 028, .T., .F.} )
		aAdd(aObjCoords, { 000, 000, .T., .T. , .T. } )
		aObjSize		:= MsObjSize(aInfoAdvSize , aObjCoords)

		aAdv1Size		:= aclone(aObjSize[2])
		aInfo1AdvSize	:= { 0 , 0 , aAdv1Size[3] , aAdv1Size[4] , 5 , 2 }
		aAdd( aObj1Coords , { 000 , 000 , .T. , .T. } )
		aAdd( aObj1Coords , { 000 , 000 , .T. , .T. } )
		aObj1Size		:= MsObjSize( aInfo1AdvSize , aObj1Coords )

		If !lRobo
			DEFINE FONT oFont NAME "Arial" SIZE 0,-11 BOLD
			If lGestPubl
				DEFINE MSDIALOG oDlg TITLE OemToAnsi(STR0251) FROM aAdvSize[7], 0 TO aAdvSize[6], aAdvSize[5] OF oMainWnd PIXEL
			Else
				DEFINE MSDIALOG oDlg TITLE OemToAnsi(STR0008) FROM aAdvSize[7], 0 TO aAdvSize[6], aAdvSize[5] OF oMainWnd PIXEL
			EndIf

			@ aObjSize[1,1] , aObjSize[1,2]  GROUP oGroup 	TO aObjSize[1,3], aObjSize[1,4]  LABEL OemToAnsi(STR0176) OF oDlg PIXEL 	//"Observacao"
			cObsTra := Space(TAMSX3("RE_TRFOBS")[1])
			@ aObjSize[1,1]+11 , aObjSize[1,2]+5 MSGET oGet1 VAR cObsTra	SIZE 220,10 OF oDlg PIXEL HASBUTTON
			oGroup:oFont:= oFont

			If lGestPubl
				@ aObjSize[2][1] , aObjSize[2][2] FOLDER oFolder1 SIZE aObjSize[2][3], aObjSize[2][4] OF oDlg ITEMS STR0252,STR0170 PIXEL	// "Dados Relotação" ### "Dados Cadastrais"
			Else
				@ aObjSize[2][1] , aObjSize[2][2] FOLDER oFolder1 SIZE aObjSize[2][3], aObjSize[2][4] OF oDlg ITEMS STR0169,STR0170 PIXEL	// "Dados Transferencia" ### "Dados Cadastrais"
			Endif
		Endif

		// Dados Transferencia
		If lPortal

			cObsTra := If( type("cObsTcfa040")=="U", "", cObsTcfa040 )
			For nY := 1 To Len(aTransfHeader)
				If AllTrim(aTransfHeader[nY, 2]) == "M_EMPRESA" .And. ! Empty(M->RE_EMPP) .And. ! Empty(M->RE_FILIALP)
					aTransfCols[1, nY] := M->RE_EMPP

					fInfo( @aFilP , M->RE_FILIALP )
					cDescEmpr := PadR(aFilP[2],35)
					cDescFil  := PadR(aFilP[1],35)
				ElseIf AllTrim(aTransfHeader[nY, 2]) == "M_NEMPRESA"
					aTransfCols[1, nY] := cDescEmpr
				ElseIf AllTrim(aTransfHeader[nY, 2]) == "RA_FILIAL" .And. ! Empty(M->RE_FILIALP)
					aTransfCols[1, nY] := M->RE_FILIALP
				ElseIf AllTrim(aTransfHeader[nY, 2]) == "M_NFILIAL"
					aTransfCols[1, nY] := cDescFil
				ElseIf AllTrim(aTransfHeader[nY, 2]) == "RA_MAT" .And. ! Empty(M->RE_MATP)
					aTransfCols[1, nY] := M->RE_MATP
				ElseIf AllTrim(aTransfHeader[nY, 2]) == "RA_CC" .And. ! Empty(M->RE_CCP)
					aTransfCols[1, nY] := M->RE_CCP
				ElseIf AllTrim(aTransfHeader[nY, 2]) == "RA_DESCCC" .And. ! Empty(M->RE_CCP)
					aTransfCols[1, nY] := DescCc( M->RE_CCP, M->RE_FILIALP, NIL , M->RE_EMPP <> cEmpAnt )
				ElseIf AllTrim(aTransfHeader[nY, 2]) == "RA_DEPTO" .And. ! Empty(M->RE_DEPTOP)
					aTransfCols[1, nY] := M->RE_DEPTOP
				ElseIf AllTrim(aTransfHeader[nY, 2]) == "RA_DDEPTO" .And. ! Empty(M->RE_DEPTOP)
					aTransfCols[1, nY] := fDesc("SQB", M->RE_DEPTOP, "QB_DESCRIC")
				ElseIf AllTrim(aTransfHeader[nY, 2]) == "RA_PROCES" .And. ! Empty(M->RE_PROCESS)
					aTransfCols[1, nY] := M->RE_PROCESS
				ElseIf AllTrim(aTransfHeader[nY, 2]) == "M_DPROCES" .And. ! Empty(M->RE_PROCESS)
					aTransfCols[1,nY] := fDesc("RCJ", M->RE_PROCESS, 'RCJ_DESCRI' )
				ElseIf AllTrim(aTransfHeader[nY, 2]) == "RA_POSTO" .And. ! Empty(M->RE_POSTOP)
					aTransfCols[1, nY] := M->RE_POSTOP
				ElseIf AllTrim(aTransfHeader[nY, 2]) == "M_DPOSTO" .And. ! Empty(M->RE_POSTOP)
					RCL->( dbSetOrder(2) )
					If RCL->( dbSeek(xFilial("RCL",M->RE_FILIALP) + M->RE_POSTOP) )
						aTransfCols[1, nY] := fdesc("SQ3", RCL->RCL_CARGO , 'Q3_DESCSUM' )
					EndIf
					RCL->( dbSetOrder(1) )
				ElseIf AllTrim(aTransfHeader[nY, 2]) == "RE_DESL" .And. M->RE_FILIALD != M->RE_FILIALP
					aTransfCols[1, nY] := Space( TamSx3( "RE_DESL" )[1] )
				Endif
			Next

			For nY := 1 To Len(aTransf1Header)
				If AllTrim(aTransf1Header[nY, 2]) == "RA_CODFUNC"
					nPosTr := aScan( aCpoAuxSRA, { |x| Upper(AllTrim(x[1])) == "TMP_FUNCAO" })
					If nPosTr > 0
						aTransf1Cols[1, nY] := aCpoAuxSRA[nPosTr,2]
						nSalSRJ := ( Posicione("SRJ",1,xFilial("SRJ", M->RE_FILIALP)+ aCpoAuxSRA[nPosTr,2],"RJ_SALARIO") )
						cDescSRJ := ( Posicione("SRJ",1,xFilial("SRJ", M->RE_FILIALP)+ aCpoAuxSRA[nPosTr,2],"RJ_DESC") )
					Endif
				ElseIf AllTrim(aTransf1Header[nY, 2]) == "RA_TIPOALT"
					nPosTr := aScan( aCpoAuxSRA, { |x| Upper(AllTrim(x[1])) == "TMP_TPALT" })
					If nPosTr > 0
						aTransf1Cols[1, nY] := aCpoAuxSRA[nPosTr,2]
					Endif
				ElseIf AllTrim(aTransf1Header[nY, 2]) == "RA_DATAALT"
					aTransf1Cols[1, nY] := dDataTra
				Endif
			Next

			If nSalSRJ > 0
				nPosSal := aScan( aTransf1Header, { |x| Upper(AllTrim(x[2])) == "RA_SALARIO" })
				If nPosSal > 0
					aTransf1Cols[1, nPosSal] := nSalSRJ
					nSalSRJ := 0
				Endif
			Endif
			If !Empty(cDescSRJ)
				nPosDesc := aScan( aTransf1Header, { |x| Upper(AllTrim(x[2])) == "RA_DESCFUN" })
				If nPosDesc > 0
					aTransf1Cols[1, nPosDesc] := Alltrim(cDescSRJ)
					nPosDesc := 0
				Endif
			Endif
		EndIf

		If !lRobo
			@ aObj1Size[1,1] , aObj1Size[1,2]  GROUP oGroup1 TO aObj1Size[1,3]-10, aObj1Size[1,4]-2 LABEL OemToAnsi( STR0145) OF oFolder1:aDialogs[01] PIXEL	//"Dados origem
			oGroup1:oFont:= oFont

			oGetSRA1:= MsNewGetDados():New(		aObj1Size[1,1]+8,;		// 1-nTop
												aObj1Size[1,2]+5,;		// 2-nLeft
												aObj1Size[1,3]-15,;		// 3-nBottom
												aObj1Size[1,4]-7,;		// 4-nRight
												0,; 					// 5-controle do que podera ser realizado na GetDado - nstyle
												.T.,;					// 6-funcao para validar a edicao da linha - ulinhaOK
												.T.,;					// 7-funcao para validar todos os registros da GetDados - uTudoOK
												NIL,;					// 8-cIniCPOS
												NIL,;					// 9-aAlter
												0,;						// 10-nfreeze
												99999,;					// 11-nMax
												NIL,;					// 12-cFieldOK
												NIL,;					// 13-usuperdel
												NIL,;					// 14-bloco com funcao para validar registros deletados (Gp400DelOk())
												IIF(!lRobo , oFolder1:aDialogs[01], ) ,;	// 15-objeto de dialogo - oWnd
												aTransfHeader,;			// 16-Vetor com Header - AparHeader
												aSvTransfCols;			// 17-Vetor com Colunas - AparCols
											)

			@ aObj1Size[2,1]-10 , aObj1Size[2,2]  GROUP oGroup2 TO aObj1Size[2,3]-15, aObj1Size[2,4]-2 LABEL OemToAnsi( STR0146) OF oFolder1:aDialogs[01] PIXEL
			oGroup2:oFont:= oFont

			oGetSRA2:= MsNewGetDados():New(		aObj1Size[2,1],;		// 1-nTop
												aObj1Size[2,2]+5,;		// 2-nLelft
												aObj1Size[2,3]-20,;		// 3-nBottom
												aObj1Size[2,4]-7,;		// 4-nRright
												nOpcNewGd,;				// 5-controle do que podera ser realizado na GetDado - nstyle
												"GP180LinOk", ;			// 6-funcao para validar a edicao da linha - ulinhaOK
												"GP180TudoOk", ;		// 7-funcao para validar todos os registros da GetDados - uTudoOK
												"", ;					// 8-cIniCPOS
												NIL,;					// 9-aAlter
												0,  ;					// 10-nfreeze
												99999,;					// 11-nMax
												NIL	,;					// 12-cFieldOK
												NIL,;					// 13-usuperdel
												{|| GP180DelOk()} ,;	// 14-bloco com funcao para validar registros deletados (Gp400DelOk())
												IIF (!lRobo , oFolder1:aDialogs[01] , ),;	// 15-objeto de dialogo - oWnd
												aTransfHeader,;			// 16-Vetor com Header - AparHeader
												aTransfCols;			// 17-Vetor com Colunas - AparCols
											)


			oGetSRA2:oBrowse:blDblClick := { ||fSvVarMemo(), If( oGetSRA2:oBrowse:nColpos = _COLBMP , fA180ChangeBMP(@oGetSRA1,@oGetSRA2),oGetSRA2:EDITCELL() )  }

			// Dados Cadastrais
			@ aObj1Size[1,1] , aObj1Size[1,2]  GROUP oGroup11 TO aObj1Size[1,3]-10, aObj1Size[1,4]-2 LABEL OemToAnsi( STR0145) OF oFolder1:aDialogs[02] PIXEL	//"Dados origem
			oGroup11:oFont:= oFont

			oGetSRA11:= MsNewGetDados():New(	aObj1Size[1,1]+8,;		// 1-nTop
												aObj1Size[1,2]+5,;		// 2-nLeft
												aObj1Size[1,3]-15,;		// 3-nBottom
												aObj1Size[1,4]-7,;		// 4-nRight
												0,;						// 5-controle do que podera ser realizado na GetDado - nstyle
												.T.,;					// 6-funcao para validar a edicao da linha - ulinhaOK
												.T.,;					// 7-funcao para validar todos os registros da GetDados - uTudoOK
												NIL,;					// 8-cIniCPOS
												NIL,;					// 9-aAlter
												0,;						// 10-nfreeze
												99999,;					// 11-nMax
												NIL,;					// 12-cFieldOK
												NIL,;					// 13-usuperdel
												NIL,;					// 14-bloco com funcao para validar registros deletados (Gp400DelOk())
												IIF(!lRobo , oFolder1:aDialogs[02] , )	,;	// 15-objeto de dialogo - oWnd
												aTransf1Header,;		// 16-Vetor com Header - AparHeader
												aSv1TransfCols;			// 17-Vetor com Colunas - AparCols
											)

			@ aObj1Size[2,1]-10 , aObj1Size[2,2]  GROUP oGroup21 TO aObj1Size[2,3]-15, aObj1Size[2,4]-2 LABEL OemToAnsi( STR0146) OF oFolder1:aDialogs[02] PIXEL
			oGroup21:oFont:= oFont

			oGetSRA21:= MsNewGetDados():New(	aObj1Size[2,1],;		// 1-nTop
												aObj1Size[2,2]+5,;		// 2-nLelft
												aObj1Size[2,3]-20,;		// 3-nBottom
												aObj1Size[2,4]-7,;		// 4-nRright
												nOpcNewGd,;				// 5-controle do que podera ser realizado na GetDado - nstyle
												"GP1801LinOk", ;		// 6-funcao para validar a edicao da linha - ulinhaOK
												.T., ;					// 7-funcao para validar todos os registros da GetDados - uTudoOK
												"", ;					// 8-cIniCPOS
												NIL,;					// 9-aAlter
												0,  ;					// 10-nfreeze
												99999,;					// 11-nMax
												NIL	,;					// 12-cFieldOK
												NIL,;					// 13-usuperdel
												{|| GP1801DelOk()} ,;	// 14-bloco com funcao para validar registros deletados (Gp400DelOk())
												IIF(!lRobo , oFolder1:aDialogs[02] , ),;	// 15-objeto de dialogo - oWnd
												aTransf1Header,;		// 16-Vetor com Header - AparHeader
												aTransf1Cols;			// 17-Vetor com Colunas - AparCols
											)


			oGetSRA21:oBrowse:blDblClick := { ||fSvVarMemo(),oGetSRA21:EDITCELL()}

			oGetSRA11:bChange := { |lChange| ( oGetSRA1:oBrowse:nAT := oGetSRA11:oBrowse:nAT, oGetSRA1:Refresh() )}

			oGetSRA21:bChange := { |lChange| ( oGetSRA2:oBrowse:nAT := oGetSRA21:oBrowse:nAT, oGetSRA2:Refresh(), Eval( bSvColsToMem,oGetSRA21:oBrowse:nAT ))}

			oGetSRA1:bChange  := { |lChange| ( oGetSRA11:oBrowse:nAT := oGetSRA1:oBrowse:nAT, oGetSRA11:Refresh() )}

			oGetSRA2:bChange  := { |lChange|;
											ChangeNew(uAliasNewEmp, oGetSRA2:acols[oGetSRA2:nAt, 02], oGetSRA2:acols[oGetSRA2:nAt,04] ),;
											Eval( bSvColsToMem, oGetSRA2:oBrowse:nAT ) ,;
											oGetSRA21:oBrowse:nAT := oGetSRA2:oBrowse:nAT,;
											oGetSRA21:Refresh() ;
								  }

			oGetSRA2:oBrowse:bLostFocus		:= {|| GP180LinOk(oGetSRA2) }

			oGetSRA21:oBrowse:bLostFocus	:= {|| GP1801LinOk(oGetSRA21) }

			nPosRec		:= GdfieldPos("RA_REC_WT",oGetSRA2:aHeader)

		Endif

		// ---------------------------------------
		If !lAuto

			bSet15		:= {|| nOpcA:= (IF(nOpc=5,2,1)), IF(oGetSRA2:TudoOk() .And. fVldTrf() .And. Gp180EmpTAF(),oDlg:End(),nOpcA:=0)}
			bSet24		:= {|| nOpcA:=2 , oDlg:End(), ChangeNew( {"CTT","SQB","RCJ","SRA"}, __cEmpAnt, __cFilAnt )}
			bAgenda		:= {|| Agenda() }
			bLegenda	:= {|| fTransfLegen() }
			bTransf		:= {|| fTransfUnico() }
			bLogPreview	:= {|| fLogPreview() }

			AAdd(aButtons, {"S4WB009N",	bAgenda,	OemToAnsi(STR0114), OemToAnsi(STR0114) }  )	//"Agenda..."
			AAdd(aButtons, {"BEND",		bLegenda,	OemToAnsi(STR0021), OemToAnsi(STR0021) }  )	//"Legenda"

			If lGestPubl
				AAdd(aButtons, {"DESTINOS",	bTransf,	OemToAnsi(STR0251), OemToAnsi(STR0253) }  )	//"Relotacao" //"Relot."
				AAdd(aButtons, {"ANALITICO",	bLogPreview,OemToAnsi(STR0254), OemToAnsi(STR0178) }  )	//"Previsão de Relotação" ### "Logs."
			Else
				AAdd(aButtons, {"DESTINOS",	bTransf,	OemToAnsi(STR0008), OemToAnsi(STR0124) }  )	//"Transferencias" //"Transf."
				AAdd(aButtons, {"ANALITICO",	bLogPreview,OemToAnsi(STR0177), OemToAnsi(STR0178) }  )	//"Previsão de Transferências" ### "Logs."
			Endif

			If FindFunction("TecConfAlo") .AND. SuperGetMV("MV_TECXRH", NIL, .F. ) .AND. !IsBlind()
	    		TecConfAlo( /*oModel*/ )
	    	EndIf

			ACTIVATE MSDIALOG oDlg ON INIT (If(lPortal, Eval(oGetSRA2:oBrowse:blDblClick), .F.), EnchoiceBar(oDlg, bSet15, bSet24, NIL, aButtons)) CENTERED

		Else

			nPosFil := IIF(!lRobo , GdfieldPos("RA_FILIAL", oGetSRA2:aHeader) , GdfieldPos("RA_FILIAL", aTransfHeader))
			nPosMat := IIF(!lRobo , GdfieldPos("RA_MAT"   , oGetSRA2:aHeader) , GdfieldPos("RA_MAT"   , aTransfHeader))

			If !lRobo
				For nX := 1 to Len(oGetSRA2:aCols)
					nFunc := aScan( aAutoItens, { |x| x[1] == oGetSRA2:aCols[nX][nPosFil] .And. x[2] == oGetSRA2:aCols[nX][nPosMat] } )
					If nFunc > 0
						For nCampo := 1 to Len(aAutoItens[nFunc][3])
							nPosCpo := GdFieldPos( aAutoItens[nFunc][3][nCampo][1], oGetSRA2:aHeader )
							If nPosCpo > 0
								oGetSRA2:aCols[nX][nPosCpo] := aAutoItens[nFunc][3][nCampo][2]
							EndIf
						Next nCampo
					EndIf
				Next nX
				nOpcA := If( oGetSRA2:TudoOk() .And. fVldTrf() .And. Gp180EmpTAF(), 1, 0 )
			Else
				For nX := 1 to Len(aTransfCols)
					nFunc := aScan( aAutoItens, { |x| x[1] == aTransfCols[nX][nPosFil] .And. x[2] == aTransfCols[nX][nPosMat] } )
					If nFunc > 0
						For nCampo := 1 to Len(aAutoItens[nFunc][3])
							nPosCpo := GdFieldPos( aAutoItens[nFunc][3][nCampo][1], aTransfHeader )
							If nPosCpo > 0
								aTransfCols[nX][nPosCpo] := aAutoItens[nFunc][3][nCampo][2]
							EndIf
						Next nCampo

						If lAdd
							For nCampo := 1 to Len(aAutoItens[nFunc][3])  // Winston - Buscando no aTransf1Cols (campos completamentares)
								nPosCpo := GdFieldPos( aAutoItens[nFunc][3][nCampo][1], aTransf1Header )
								If nPosCpo > 0
									aTransf1Cols[nX][nPosCpo] := aAutoItens[nFunc][3][nCampo][2]
								EndIf
							Next nCampo
						End

					EndIf
				Next nX
				nOpcA := If( GP180TudoOk() .And. fVldTrf() .And. Gp180EmpTAF(), 1, 0 )
			Endif

		EndIf

		IF ( nOpcA == 2 )
			If lCtrAutoMat
				RollBackSX8()
			EndIf
			Break
		EndIF

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Ponto de entrada para apresentacao de mensagem antes da Trf. ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If ExistBlock("GP180MSG")
			If !( ExecBlock("GP180MSG",.F.,.F.) )
				Break
			EndIf
		Endif

		//"Transferencia em Lote"
		If !lRobo
			Proc2BarGauge( bGpea180Prc , OemToAnsi( cCadastro + " - " + STR0042 ) , NIL , NIL , .F. , .T. , .F. , .T. )
		Else
			If nOpcA > 0 .Or. Len(aTransfCols) > 1
				GPEA180PRC()
			Else
				lMsErroAuto := .T.
			EndIf
		Endif

		PcoFinLan('000086')
		PcoFreeBlq('000086')
	End Sequence

	IF !lAuto .And. !Empty( aLogTransf )
		// "Log de Ocorrencias"
		bMakeLog := { || fMakeLog({aLogTransf} , {STR0073 + " - " + STR0015 + " " +DTOC(dDataTra) + " - " + STR0175 + ": " + AllTrim(Str(SRE->RE_TRFUNID)) + " - " + STR0176 + ": " + SRE->RE_TRFOBS} ,;
					NIL , .T. , FunName() , NIL , "G" , "L" , NIL , NIL ) }
		MsAguarde( bMakeLog , OemToAnsi( STR0073 ) )
	EndIF

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Restaura Empresa e Filial de Entrada                         ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	aAutoMat:= {}

	cAlias := "SRA"
	dbSelectArea( cAlias )
	( cAlias )->( MsUnlock() )

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Fechar as tabelas abertas para outra empresa                 ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If !Empty(aTabCompany)
		For nX := 1 To Len(aTabCompany)
			(aTabCompany[nX])->( DbCloseArea() )
		Next nX
	EndIf

	If  lGestPubl .AND. cModulo $ "GFP*VDF" //Se Gestao de Folha Publica - SIGAGFP
		If !Empty(aFuncTran)
			dbSelectArea( "SRA")
			cFiltSRA	:= SRA->(DbFilter()) //carrega filtro aplicado
			SRA->(DbClearFilter()) //limpa filtro aplicado na SRA a fim de buscar funcionarios transferidos
			aSort(aFuncTran,,, { |x, y| x[4] < y[4] } )
			QrySRETra(aFuncTran)
			While TRBSRE->(!EOF())
				/* Passar paramentros obrigatorios!
				aParametro[1] Fonte 	Fonte que chamou.
				aParametro[2] RA_MAT 	Matricula do Funcionario.
				aParametro[3] CatFunc 	Categoria do Funcionario.
				aParametro[4] Chave     para gravação do Historioco RI6
				aParametro[5] Filial    Filial do funcionario transferido
				aParametro[6] CPF       CPF do funcionario transferido
				aParametro[7] Data      Data de Efeito
				aParametro[8] Indice    Indice da tabela
				aParametro[9] Tabela    Alias da tabela */
				dbSelectArea( "SRA" )
				SRA->(DbSetOrder(1))
				SRA->( dbGoTop() )
				SRA->(DbSeek(SUbSTR(TRBSRE->RE_FILIALD,01,TAMSX3("RA_FILIAL")[1])+TRBSRE->RE_MATD))
				If SRA->RA_REGIME == "2" .AND. (aScan(aFuncTran, {|x| x[4] == SRA->RA_MAT}) > 0) //Publicação apenas para Estatutários e que foram
					aParTela :={'GPEA180', TRBSRE->RE_MATP,;
								Posicione('SRA',1,SUbSTR(TRBSRE->RE_FILIALD,01,TAMSX3("RA_FILIAL")[1])+TRBSRE->RE_MATD,'RA_CATFUNC'),;
								TRBSRE->RE_EMPP+TRBSRE->RE_FILIALP+TRBSRE->RE_MATP+TRBSRE->RE_DATA,;
								SUbSTR(TRBSRE->RE_FILIALP,01,TAMSX3("RA_FILIAL")[1]),;
								Posicione('SRA',1,SUbSTR(TRBSRE->RE_FILIALP,01,TAMSX3("RA_FILIAL")[1])+TRBSRE->RE_MATP,'RA_CIC'),;
								STOD(TRBSRE->RE_DATA),'2','SRE'}
					VDFA060(aParTela)
				EndIf
				TRBSRE->(DbSkip())
			EndDo
			TRBSRE->(DbCloseArea())
			dbSelectArea("SRA")
			If !(Empty(cFiltSRA))
				bFiltSRA := { || &(cFiltSRA) }
				SRA->(DbSetfilter( bFiltSRA, cFiltSRA )) //inclui filtro para retornar para GPEM060
		EndIf
		EndIf
	Endif

	RestArea( aArea )
	RestArea( aAreaSRA )

	oGetSRA1	:= Nil
	oGetSRA2	:= Nil
	oGetSRA11	:= Nil
	oGetSRA21	:= Nil

Return( nOpcA )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³fSvVarMemoºAutor  ³Microsiga           º Data ³  05/09/08   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Gera var.de memoria para os campos da getdados              º±±
±±º          ³Necessario qdo se executou um gatilho e este atualizou um   º±±
±±º          ³outro e q era utilizado em alguma validacao                 º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function fSvVarMemo()

	Local nX	:= 0

	For nX := 1 To len(aTransfHeader)
		SetMemVar( aTransfHeader[ nX , 02 ] , oGetSRA2:aCols[ oGetSRA2:nAT, nX ]  , .T. )
	Next nX

	For nX := 1 To len(aTransf1Header)
		SetMemVar( aTransf1Header[ nX , 02 ] , oGetSRA21:aCols[ oGetSRA21:nAT, nX ]  , .T. )
	Next nX

	If !IsBlind()
		OGetSRA2:oBrowse:Refresh()
		OGetSRA21:oBrowse:Refresh()
	EndIf

Return(.t.)

/*
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³Gpea180Prc	 ³ Autor ³Equipe Advanced RH     ³ Data ³09/02/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Processamento das Transferencias                                ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<void>                                 							    ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³<void>                      									          ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³GEPA180                    										       ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
Static Function Gpea180Prc()

	Local aFilesTransf	:= {}
	Local aFilesOpen	:= {}
	Local aScopeCount	:= {}
	Local aSraUpdRelRd0	:= {}
	Local aSvSRA_Aux   	:= {}
	Local aSRA_Aux		:= {}
	Local aCGC			:= {}
	Local aTransf		:= {}
	Local aFileReg		:= {}
	Local bGpea180Tra	:= { || Gpea180Tra(aFilesTransf,cFilMat,lDelNovo,lGravaNovo,lDelAntigo,lRegrava,@aFileReg) }
	Local bSraUpdRelRd0 := { || NIL }
	Local cSraFilter	:= SRA->( dbFilter() )
	Local cFilSRA		:= xFilial( "SRA" , __cFilAnt )
	Local cErXML		:= ""
	Local cMsgLogXML	:= ""
	Local cCodUnic		:= ""
	Local lFilesTransf	:= .F.
	Local lFirst		:= .T.
	Local lRetOK		:= .T.
	Local lIncRFZ		:= .F.
	Local nProcRegua	:= SRA->( RecCount() )
	Local nSraNextRecno
	Local nSraOrder
	Local nLoop			:= 0
	Local nLoops		:= 0
	Local nX			:= 0
	Local nY			:= 0
	Local nPos 			:= 0
	Local nPosUnico		:= 0
	Local nPosRec		:= IIF(!lRobo , GdFieldPos("RA_REC_WT", oGetSRA2:aHeader) , GdFieldPos("RA_REC_WT", aTransfHeader))
	Local nPosRec1		:= IIF(!lRobo , GdFieldPos("RA_REC_WT", oGetSRA21:aHeader), GdFieldPos("RA_REC_WT", aTransf1Header))
	Local nTamHead		:= Len(aTransfHeader)+ 1
	Local nTransfSolicitada := 0
	Local nTransfEfetuada 	:= 0
	Local lTSREP		:= SuperGetMv( "MV_TSREP" , NIL , .F. )
	Local lMdtAdic 		:= SuperGetMv("MV_MDTADIC",,.F.)
	Local lMdtGPE 		:= SuperGetMv("MV_MDTGPE",,"N") == "S"
	Local lIntTMS		:= SuperGetMv("MV_INTTMS",,.F.)
	Local lErroTaf		:= .F.
	Local lGerouXml		:= .T.
	Local cTrabVincu	:= fCatTrabEFD("TCV") //"101|102|103|104|105|106|111|301|302|303|306|309" //Trabalhador com vinculo
	Local cAliasRFZ		:= "RFZ"
	Local cMsgLogErr	:= ""
	Local cArqSR6		:= ""
	Local cArqSRJ		:= ""
	Local cArqSQ3		:= ""
	Local cSR6Fil		:= ""
	Local cSRJFil		:= ""
	Local cSQ3Fil		:= ""
	Local __cEmpAnte	:= ""
	Local __cFilAnte
	Local lIntTAFok		:= .F.
	Local lGer2240	    := .F.
	Local nPosDesl		:= 0
	Local nPosEmp		:= IIF(!lRobo , GdFieldPos("M_EMPRESA"	, oGetSRA2:aHeader) , GdFieldPos("M_EMPRESA"	, aTransfHeader))
	Local nPosFil		:= IIF(!lRobo , GdFieldPos("RA_FILIAL"	, oGetSRA2:aHeader) , GdFieldPos("RA_FILIAL"	, aTransfHeader))
	Local nPosCC		:= IIF(!lRobo , GdFieldPos("RA_CC"		, oGetSRA2:aHeader) , GdFieldPos("RA_CC"		, aTransfHeader))
	Local nPosMat		:= IIF(!lRobo , GdFieldPos("RA_MAT"		, oGetSRA2:aHeader) , GdFieldPos("RA_MAT"		, aTransfHeader))
	Local nPosProc		:= IIF(!lRobo , GdFieldPos("RA_PROCES"	, oGetSRA2:aHeader) , GdFieldPos("RA_PROCES"	, aTransfHeader))
	Local nPosDepto		:= IIF(!lRobo , GdFieldPos("RA_DEPTO"	, oGetSRA2:aHeader) , GdFieldPos("RA_DEPTO"		, aTransfHeader))
	Local nPosPosto		:= IIF(!lRobo , GdFieldPos("RA_POSTO"	, oGetSRA2:aHeader) , GdFieldPos("RA_POSTO"		, aTransfHeader))
	Local nPosItem		:= IIF(!lRobo , GdFieldPos("RA_ITEM"	, oGetSRA2:aHeader) , GdFieldPos("RA_ITEM"		, aTransfHeader))
	Local nPosClvl		:= IIF(!lRobo , GdFieldPos("RA_CLVL"	, oGetSRA2:aHeader) , GdFieldPos("RA_CLVL"	  	, aTransfHeader))
	Local nPosSalAlt	:= IIF(!lRobo , GdFieldPos("RA_SALARIO"	, oGetSra21:aHeader) , GdFieldPos("RA_SALARIO"	, aTransf1Header))
	Local nPosTpAlt		:= IIF(!lRobo , GdFieldPos("RA_TIPOALT"	, oGetSra21:aHeader) , GdFieldPos("RA_TIPOALT"	, aTransf1Header))
	Local nPosDtAlt		:= IIF(!lRobo , GdFieldPos("RA_DATAALT"	, oGetSra21:aHeader) , GdFieldPos("RA_DATAALT"	, aTransf1Header))
	Local nPosTurno		:= IIF(!lRobo , GdFieldPos("RA_TNOTRAB"	, oGetSra21:aHeader) , GdFieldPos("RA_TNOTRAB"	, aTransf1Header))
	Local nPosFuncao	:= IIF(!lRobo , GdFieldPos("RA_CODFUNC"	, oGetSra21:aHeader) , GdFieldPos("RA_CODFUNC"	, aTransf1Header))
	Local nPosCargo		:= IIF(!lRobo , GdFieldPos("RA_CARGO"	, oGetSra21:aHeader) , GdFieldPos("RA_CARGO"	, aTransf1Header))
	Local nOrdSRE		:= SRE->(IndexOrd())
	Local lIntegTSV		:= .T.
	Local nPosLog		:= 0
	Local nColuna		:= 0
	Local nLogHeader	:= IIF(!lRobo , Len(oGetSRA1:aHeader)	, Len(aTransfHeader))
	Local nLogAcols		:= IIF(!lRobo , Len(oGetSRA1:aCols)		, Len(aSvTransfCols))
	Local nLog1Header	:= IIF(!lRobo , Len(oGetSRA11:aHeader)	, Len(aTransf1Header))
	Local aFunc			:= {}
	Local aRet			:= {}
	Local aVinc			:= {}
	Local aErr2206		:= {}
	Local aErr2200		:= {}
	Local aErr2306		:= {}
	Local lGP180VALID	:= ExistBlock("GP180VALID")
	Local laModTraj		:= Type("aModTraj") == "A"
	Local cEmpProc		:= ""
	Local lObraTot		:= .F.
	Local cMsgErro		:= ""
	Local nControl		:= 0
	Local nPosRecSRA	:= aScan( aSRAHeader , { |x| x[2] == 'RA_REC_WT' } )
	Local nPosEmpSRA	:= aScan( aSRAHeader , { |x| x[2] == 'M_EMPRESA' } )
	Local lShowSelPer	:= .F.
	Local aOperCC		:= {.F., .F., .F., .F.}
	Local cOrigInsc		:= ""
	Local cDestNInsc	:= ""
	Local nTamCod		:= TamSx3("RA_CODUNIC")[1]
	Local cBkpFil		:= ""
	Local lS2300		:= .F.
	Local lGeraInt		:= .F.
	Local cStatDesl		:= "-1"
	Local cStat2298		:= "-1"
	Local cArqSRV		:= ""
	Local lCompSRV		:= .F.
	Local cFilEnv		:= ""
	Local aRH5Filt	 	:= {}
	Local cFilS2200		:= ""
	Local lDifDtSPF		:= .F.
	Local aAreaSR6		:= {}
	Local aAreaSPF		:= {}
	Local lSolicPend	:= .F.
	Local lArqRH3		:= .F.
	Local aInfMDT		:= {}
	Local cLogMDT		:= ""
	Local cFuncAte		:= ""
	Local cCargoAte		:= ""
	Local lMatTSV		:= SRA->(ColumnPos("RA_DESCEP")) > 0
	Local lGeraMat		:= .F.
	Local cGeraMat		:= ""
	Local cCodUniMDT	:= ""
	Local leSocMDT		:= IIf( FindFunction( "MDTVldEsoc" ), MDTVldEsoc(), .F. )
	Local lTAFTransf	:= .F.
	Local lTAFDest		:= .F.
	Local oFilAux
	Local oBrwAux
	Local lGpe10InNG	:= SUPERGETMV('MV_RHNG', .F., .F.)
	Local lAhgora	    := SUPERGETMV('MV_RHAHGOR', .F., .F.) .And. ChkFile("RUM")
	Local lTemRUM       := .T.
	Local lGerouRUM 	:= .T.
	Local cAliasRJ5		:= "RJ5"
	Local cFilRJ5At		:= ""
	Local lIntESoc		:= .T.
	Local cFilRCHDe		:= ""
	Local cFilRCHAt		:= ""
	Local cFilRCJDe		:= ""
	Local cFilRCJAt		:= ""
	Local cFilACBAt		:= ""
	Local cFilAC9At		:= ""
	Local cPathACB		:= ""

	Private lDifEmp		:= .F.
	Private cTimeIni	:= Time()
	Private nPosAtu		:= 0
	Private oObjREP		:= Nil
	Private	nNumTRF		:= 0
	Private	cBkpAdcIns	:= ""
	Private cBkpInsMax	:= ""
	Private cBkpAdcPeri	:= ""
	Private cBkpPericul	:= ""

	Default lVerRJ5		:= FindFunction("fVldObraRJ") .And. (fVldObraRJ(@lParcial, .F.) .And. !lParcial) //prc e envtaf180

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Gera a numeracao sequencial do lote de transferencia                               ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	nNumTRF := Val(DTOS(Date())+SubStr(Time(),1,2)+SubStr(Time(),4,2)+SubStr(Time(),7,2))	// 99:99:99
	SRE->( dbSetOrder(5) ) // RetOrdem( "SRE" , "RE_TRFUNID" ) // Débito técnico
	While SRE->(dbSeek(nNumTRF))
		nNumTRF := Val(DTOS(Date())+SubStr(Time(),1,2)+SubStr(Time(),4,2)+StrZero(Val(SubStr(Time(),7,2))+1,2) )	// AAAAMMDDHHMMSS
	Enddo
	SRE->(dbSetOrder(1))

	If !lRobo
		aTransfCols := aclone(oGetSra2:aCols)
	Endif

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Aglutina os arrays de campos de transferencia com campos de cadastros - tabela SRA ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If !lRobo
		aTransf1Cols := aclone(oGetSra21:aCols)
	Endif

	For nX := 1 to Len(aTransf1Cols)
		For nY := 3 to ( Len(aTransf1Cols[nX] )-2 )
			aAdd( aTransfCols [ nX ] , aTransf1Cols [ nX, nY ] )
		Next
	Next

	Begin Sequence
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Verifica se houve transf.entre Emp/fil/cc/Mat/Proc/Depto/Posto   ³
		//³ Nao serao consideradas as alteracoes dos cpos complementares caso³
		//³ nao tenha havido alguma trasf. acima                             ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If cOrgCfg == "1"
			If !lItemClvl
				aEval(aSvTransfCols , {|x| aadd(aSvSRA_Aux, {x[nPosEmp], x[nPosFil], x[nPosCC], x[nPosMat], x[nPosProc], x[nPosDepto], x[nPosPosto]})  } )
				aEval(aTransfCols   , {|x| aadd(aSRA_Aux  , {x[nPosEmp], x[nPosFil], x[nPosCC], x[nPosMat], x[nPosProc], x[nPosDepto], x[nPosPosto]})  } )
			Else
				aEval(aSvTransfCols , {|x| aadd(aSvSRA_Aux, {x[nPosEmp], x[nPosFil], x[nPosCC], x[nPosItem], x[nPosClvl], x[nPosMat], x[nPosProc], x[nPosDepto], x[nPosPosto]})  } )
				aEval(aTransfCols   , {|x| aadd(aSRA_Aux  , {x[nPosEmp], x[nPosFil], x[nPosCC], x[nPosItem], x[nPosClvl], x[nPosMat], x[nPosProc], x[nPosDepto], x[nPosPosto]})  } )
			EndIf
		Else	//-If cOrgCfg == "2"
			If !lItemClvl
				aEval(aSvTransfCols , {|x| aadd(aSvSRA_Aux, {x[nPosEmp], x[nPosFil], x[nPosCC], x[nPosMat], x[nPosProc], x[nPosDepto]})  } )
				aEval(aTransfCols   , {|x| aadd(aSRA_Aux  , {x[nPosEmp], x[nPosFil], x[nPosCC], x[nPosMat], x[nPosProc], x[nPosDepto]})  } )
			Else
				aEval(aSvTransfCols , {|x| aadd(aSvSRA_Aux, {x[nPosEmp], x[nPosFil], x[nPosCC], x[nPosItem], x[nPosClvl], x[nPosMat], x[nPosProc], x[nPosDepto]})  } )
				aEval(aTransfCols   , {|x| aadd(aSRA_Aux  , {x[nPosEmp], x[nPosFil], x[nPosCC], x[nPosItem], x[nPosClvl], x[nPosMat], x[nPosProc], x[nPosDepto]})  } )
			EndIf
		EndIf

		If(	lRetOk := fCompArray( aSvSRA_Aux , aSRA_Aux ) )
			Help(" ",1,"A180IGUAL")        		//-- Registro de origem é igual ao registro  de destino, não será efetuada a transferência.
			Return(.F.)
		Endif

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Verifica os CGC das Filiais                                  ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		aCGC	:= Check_Cgc( aSRA_Aux, aSvSRA_Aux )
		lRetOk	:= .T.
		For nX:= 1 to Len(aCGC)
			If Empty( aCGC[nX, 3] ) .or. Empty( aCGC[nX, 6] )
				aAdd( aLogTransf , If( Empty( aCGC[nX, 3]) , aCGC[nX,1]+ " " +aCGC[nX,2]  ,  aCGC[nX,4]+ " " +aCGC[nX,5] ) )
				aAdd( aLogTransf , space(5) + OemToAnsi(STR0139) ) 	// C.N.P.J. de origem / destino não cadastrado.
				lRetOK	:= .F.
			Endif
		Next nx

		If !lRetOK
			Help(" ",1,"A180SCGC") // C.N.P.J. de origem / destino não cadastrado.
			Return(.F.)
		Endif

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³  Limpar as variaveis statics da transferencia de Processos   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		RstTransf()
		lRetOk	 := .T.

		For nX := 1 to Len(aTransfCols)

			cFilDe		:= aSvTransfCols[nx,_FILIAL]
			cCcDe		:= aSvTransfCols[nx,_CCUSTO]
			cMatDe		:= aSvTransfCols[nx,_MATRIC]
			cDeptoDe	:= aSvTransfCols[nx,_DEPTO ]
			cProcesDe	:= aSvTransfCols[nx,_PROCES]

			If lItemClvl
				cItemDe := aSvTransfCols[nx,_CITEM]
				cClvlDe := aSvTransfCols[nx,_CCLVL]
			EndIf

			If (cOrgCfg == "1")
				cPostoDe := aSvTransfCols[nx,_POSTO]
			Endif

			cCcusto 	:= cCcDe
			cEmpAte   	:= aTransfCols[nx,_EMPRES]
			cFilAte   	:= aTransfCols[nx,_FILIAL]
			cCcuAte   	:= aTransfCols[nx,_CCUSTO]
			cMatAte		:= aTransfCols[nx,_MATRIC]
			cDeptoAte	:= aTransfCols[nx,_DEPTO ]

			If lItemClvl
				cItemAte := aTransfCols[nx,_CITEM]
				cClvlAte := aTransfCols[nx,_CCLVL]
			EndIf

			If (cOrgCfg == "1")
				cPostoAte := aTransfCols[nx,_POSTO]
			Endif

			cProces 	:= aTransfCols[nx,_PROCES]
			nRecno		:= aTransfCols[nx,nPosRec]

			lEmpDif		:= ( __cSvEmpAnt # cEmpAte  )
			lDifEmp		:= If( lEmpDif, lEmpDif, lDifEmp )
			lFilDif		:= ( cFilDe      # cFilAte  )
			lCcDif		:= ( cCcDe       # cCcuAte  )
			lMatDif		:= ( cMatDe      # cMatAte  )
			lProcDif	:= If(lEmpDif .Or. lFilDif, .T. , cProcesDe # cProces)
			lDeptoDif	:= ( cDeptoDe    # cDeptoAte)

			If lEmpDif
				cFilRCHDe	:= xFilial("RCH",cFilDe)
				cFilRCJDe	:= xFilial("RCJ",cFilDe)
				fOpenSx2(cEmpAte)
				cArqSRV 	:= FWSX2Util():GetFile("SRV")
				cFilRCHAt	:=  totvs.framework.company.xEmpFil("RCH", cEmpAte, cFilAte)
				cFilRCJAt 	:=  totvs.framework.company.xEmpFil("RCJ", cEmpAte, cFilAte)
				cFilACBAt	:=  totvs.framework.company.xEmpFil("ACB", cEmpAte, cFilAte)
				cFilAC9At 	:=  totvs.framework.company.xEmpFil("AC9", cEmpAte, cFilAte)
				cPathACB	:= Upper(x2path("ACB"))
				fOpenSx2(__cSvEmpAnt)
				lCompSRV := FWSX2Util():GetFile("SRV") == cArqSRV
			EndIf

			If lTpDesl
				nPosDesl := aScan( aFields, "RE_DESL" )
				If nPosDesl > 0
					cCodDesl := aTransfCols[nx,nPosDesl]
				EndIf
			EndIf

			If lItemClvl
				lItemDif	:= ( cItemDe     # cItemAte )
				lClvlDif	:= ( cClvlDe     # cClvlAte)
			Else
				lItemDif	:= .F.
				lClvlDif	:= .F.
			EndIf
			If (cOrgCfg == "1")
				lPostoDif	:= ( cPostoDe    # cPostoAte)
			Else
				lPostoDif	:= .F.
			Endif

			If lEmpDif .or. lFilDif .or. lCcDif .or. lMatDif .or. lProcDif .or. lDeptoDif .or. lPostoDif .or. lItemDif .or. lClvlDif .Or. lTpDesl

				// Transferencia de CC/Matricula/Dpto/Posto Trab nao Mostra Interface
				If !lShowSelPer
					If lProcDif
						lShowSelPer := .T.
					ElseIf lEmpDif .or. lFilDif
						// Tabelas PROCESSO/PERIODO com compartilhamento diferente
						If If(lEmpDif, cFilRCHDe # cFilRCHAt .Or. cFilRCJDe # cFilRCJAt, xFilial("RCH",cFilDe) # xFilial("RCH",cFilAte) .Or. xFilial("RCJ",cFilDe) # xFilial("RCJ",cFilAte))
							lShowSelPer := .T.
						EndIf
					EndIf
				EndIf

				If ( lEmpDif ) .Or. ( lFilDif ) .Or. ( lTpDesl )

					Aeval(aCGC, {|x| cCgcDe	 	:= If( x[1]== __cSvEmpAnt + cFilDe ,x[3] , " " ) } )
					Aeval(aCGC, {|x| cCgcPara	:= If( x[4]==  cEmpAte    + cFilAte,x[6] , " " ) } )
					Aeval(aCGC, {|x| cTpInscPara:= If( x[4]==  cEmpAte 	  + cFilAte,x[7] , " " ) } )

					If ( cCgcDe # cCgcPara )
						lCgcDif := .T.

						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³                  *** Transferencia de empresas no eSocial ***                      ³
						//³ Caracterizada pela raiz do CNPJ (8 primeiros digitos), entao quando for diferente  ³
						//³ deve ser considerada uma transferencia de empresas, mesmo dentro do mesmo grupo.   ³
						//³ Nesse caso havera a geracao de dois eventos:                                       ³
						//³ S-2299 -> Desligamento do vinculo atual no CNPJ que o funcionario pertence         ³
						//³ S-2200 -> Criacao do vinculo para o CNPJ que o funcionario esta sendo transferido. ³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						If lTpDesl
							//Verifica a raiz do CNPJ para ver se pertence a outra empresa
							lTrfEmpES := !( SubStr(cCgcDe,1,8) == SubStr(cCgcPara,1,8) )
						EndIf

					ElseIf ( lFilDif .and. ( cCgcDe == cCgcPara ) )
						If lFirst
							aAdd( aLogTransf , __cSvEmpAnt + " " + cFilDe + " " + cMatDe +"-" + aSvTransfCols[nx,_NOME]  )
							lFirst:= .F.
						Endif
						If !lEmpDif
							aAdd( aLogTransf , space(5) + OemToAnsi(STR0048) ) 									//--"Filiais com mesmo CNPJ. A transfˆrencia ser  feita como se os CNPJs fossem diferentes"
						EndIf
						lCgcDif := .T.
					Endif
				Endif

				cFilMat := RHTamFilial(cFilDe,__cSvEmpAnt) + cMatDe

				dbSelectArea( "SRA" )
				SRA->(DbSetOrder(1))
				SRA->( dbSeek( cFilMat , .F. ) )

				cMatDe 	:= SRA->RA_MAT
				cCcDe  	:= SRA->RA_CC

				//Validações matrícula para rotina automática em lote
				If lRobo .And. !ConsMat( aTransfCols, nx, .F., @aLogTransf )
					aTransfCols[nX,nTamHead] := .T.       				   //-- Sinaliza q transferencia não deve ser efetuada
					lRetOk := .F.
				EndIf

				//Transferencia nao Pode Ser Inferior a Admissao do Funcionario
				IF !( dDataTra >= SRA->RA_ADMISSA )
					aAdd( aLogTransf , __cSvEmpAnt + " " + cFilDe + " " + cMatDe +"-" + aSvTransfCols[nx,_NOME]  )
                    If lGestPubl
					    aAdd( aLogTransf , space(5) + OemToAnsi( STR0263 ) ) //--"Relotação no puede ser anterior al ingreso"
                    Else
						aAdd( aLogTransf , space(5) + OemToAnsi( STR0027 ) ) //--"Transferencia no puede ser anterior al ingreso"
                    Endif
					aTransfCols[nX,nTamHead] := .T.       				   //-- Sinaliza q transferencia não deve ser efetuada
					lRetOk	:= .F.
				EndIF

				If cPaisLoc == "BRA"
					If SRA->RA_RESCRAI$'30/31'
						aAdd( aLogTransf , __cSvEmpAnt + " " + cFilDe + " " + cMatDe +"-" + aSvTransfCols[nx,_NOME]  )
						aAdd( aLogTransf , space(5) + OemToAnsi( STR0195 ) ) //--"Funcionario ja transferido anteriormente!"
						aTransfCols[nX,nTamHead] := .T.       				   //-- Sinaliza q transferencia não deve ser efetuada
						lRetOk	:= .F.
					EndIf
				EndIf

				If !Empty(SRA->RA_DEMISSA)
					If !IsBlind() // Para não interferir quando existir rotinas automáticas sem interação do usuário

						If !lFuncTransf
							aAdd( aLogTransf , __cSvEmpAnt + " " + cFilDe + " " + cMatDe +"-" + aSvTransfCols[nx,_NOME]  )
							aAdd( aLogTransf , space(5) + OemToAnsi( STR0207 ) ) //--"Funcionario com Status de Demitido."
							aTransfCols[nX,nTamHead] := .T.
							lRetOk	:= .F.
						Else
							aTransfCols[nX,nTamHead] := .F.
							lRetOk	:= .T.
						Endif

					Else
						// Para rotinas automáticas deixo no Log de ocorrência que o funcionário está com o Status de demitido
						aAdd( aLogTransf , space(5) + OemToAnsi( STR0207 ) ) //--"Funcionario com Status de Demitido."
						aTransfCols[nX,nTamHead] := .F.
						lRetOk	:= .T.
					Endif


				Endif

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Carrega Todas as Transferencias Anteriores do Funcionario     ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				fTransfAll(@aTransf)

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Transferencia nao Pode ser Inferior a Transferencia Anterior  ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				IF !Empty(aTransf)
					IF !( dDataTra > aTransf[Len(aTransf),7])
						aAdd( aLogTransf , __cSvEmpAnt + " " + cFilDe + " " + cMatDe +"-" + aSvTransfCols[nx,_NOME]  )
						If lGestPubl
							aAdd( aLogTransf , Space(5) + OemToAnsi( STR0264 ) )	 //--"Relotação no puede ser anterior a la ultima transferencia"
						Else
							aAdd( aLogTransf , Space(5) + OemToAnsi( STR0029 ) )	 //--"Transferencia no puede ser anterior a la ultima transferencia"
						Endif
						aTransfCols[nX,nTamHead] := .T.       					 //-- Sinaliza q transferencia não deve ser efetuada
						lRetOk	:= .F.
					EndIF
				EndIF

				//Executar a geracao do array com os periodos //
				If lRetOk
					If cProces <> SRA->RA_PROCES
						fTransfProc(aFilesTransf,cProces,If(lEmpDif, cEmpAte ,""), If(lFilDif .Or. cModoRCJ = 'E', cFilAte, ""),.F.,.F.,.T.,.T.)
					EndIf
				Endif
				lFirst 	:= .T.
				lRetOk	:= .T.
			ElseiF !lEmpDif .And. !lFilDif .And. !lCcDif .And. !lMatDif .And. !lProcDif .And. !lDeptoDif .And. !lPostoDif .And. lItemDif .And. lClvlDif

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Nao houve nenhuma transferencia - deve marcar a linha da Get como deletado               ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				aTransfCols[nX, nTamHead] := .F.
			Endif

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Chamada da funçao fTransProc apenas para guardar os periodos e funcinarios a trasnferir ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			fTransProc(NIL,cProces,cEmpAte,cFilAte,.F.,.F.,.T.,.T., lRobo)

		Next nX

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Mostra a tela de troca de periodos de todos os Funcionar.que estao sendo transferidos    ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If !fTransProc(NIL,NIL,NIL,NIL,.F.,lShowSelPer,.F.,.T., lRobo)
			aAdd( aLogTransf , ""    )
			aAdd( aLogTransf , ""    )
			If lGestPubl
				aAdd( aLogTransf , OemToAnsi(STR0265) ) 					// "Relotação Cancelado na selecao de Periodos"
			Else
				aAdd( aLogTransf , OemToAnsi(STR0088) )						// "Transferencia Cancelado na selecao de Periodos"
			EndIf
			Break
		EndIf

		//Observação Importante!!!!
		//Não setar a ordem do SRA pois o arquivo (neste ponto) pode estar filtrado.
		//SRA->( dbSeek( cFilSRA , .F. ) )
		If !IsBlind() .And. !(IsInCallStack( "TCFA040ATENDE" ))
			oBrwAux 		:= GetMBrowse()
			oFilAux 		:= oBrwAux:FwFilter()
			cSraFilter		:= oFilAux:GetExprSQL()
		EndIf

		cSraFilter += IF( !Empty( cSraFilter ) , " AND RA_OKTRANS = '" + cMarkTransf + "'" , "RA_OKTRANS = '"+cMarkTransf+"'" )
		cSraFilter += " AND RA_FILIAL = '" + cFilSRA + "'"

		cSraFilter := "%" + cSraFilter + "%"
		BeginSql alias "CNTSRA"
			SELECT COUNT(*) AS CONTADOR
			FROM %table:SRA% CNTSRA
			WHERE %Exp:cSraFilter%
		EndSql

		nProcRegua := CNTSRA->(CONTADOR)
		CNTSRA->( dbCloseArea() )

		RstTimeRemaining() 											//Reinicializa o Contador de Tempos em Proc2BarGauge()

		If !lRobo
			BarGauge1Set( nProcRegua )
		Endif

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Retira todos os filtros existentes, para as tabelas listadas³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		SPFilTerOff({"SRA","SRB","SRC","SRD","SRF","SRG","SRH","SRK","SRO","SRR","SRS","SRQ","SRT","SR0","SR7","SR3","SR8","SR9","RG1","RCP","RCR","RGB","RFX"})

		dbSelectArea( "SRA" )
		nSraOrder := SRA->( IndexOrd() )

		aSort(aTransfCols,,,{|x,y| x[_EMPRES] < y[_EMPRES] })

		For nX := 1 To Len(aTransfCols)

			nTransfSolicitada ++
			nPosAtu		:=  ascan(aSRACols, {|x| x[nPosRecSRA] == aTransfCols[nx,nPosRec] } )
			lIntTAFok	:= .F.
			lGer2240	:= .F.
			cCodUnic	:= ""
			cErXML		:= ""
			cMsgLogXML	:= ""
			cFilAnt		:= __cSvFilAnt
			lS2300		:= .F.
			lDifDtSPF	:= .F.
			lSolicPend	:= .F.
			cGeraMat	:= ""

			If !(aTransfCols[nX,nTamHead])						//-- Sinaliza q transferencia não deve ser efetuada

				nControl := ascan(aSvTransfCols, {|x| x[nPosRec] == aTransfCols[nx,nPosRec] } )

				cFilDe		:= aSvTransfCols[nControl,_FILIAL ]
				cCcDe		:= aSvTransfCols[nControl,_CCUSTO ]
				cMatDe		:= aSvTransfCols[nControl,_MATRIC ]
				cDeptoDe	:= aSvTransfCols[nControl,_DEPTO  ]
				cProcesDe	:= aSvTransfCols[nControl,_PROCES ]

				// FUNÇÃO QUE VALIDA SE EXISTE DATA DE TROCA DE TURNO POSTERIOR A DATA DE TRANSFERENCIA.
				fVldDtSPF(cFilDe, cMatDe, dDataTra, @lDifDtSPF)

				If lItemClvl
					cItemDe := aSvTransfCols[nControl,_CITEM  ]
					cClvlDe := aSvTransfCols[nControl,_CCLVL  ]
				EndIf

				If (cOrgCfg == "1")
					cPostoDe := aSvTransfCols[nControl,_POSTO  ]
				Endif

				cCcusto 	:= cCcDe
				cEmpAte   	:= aTransfCols[nX,_EMPRES ]
				cFilAte   	:= aTransfCols[nX,_FILIAL ]
				cCcuAte   	:= aTransfCols[nX,_CCUSTO ]
				cMatAte		:= aTransfCols[nX,_MATRIC ]
				cDeptoAte	:= aTransfCols[nX,_DEPTO  ]
				lEmpDif		:= ( __cSvEmpAnt # cEmpAte  )
				nRecno		:= aTransfCols[nx,nPosRec]

				If cEmpAte <> cEmpProc

					cEmpProc := cEmpAte
					//--Fecha os arquivos abertos que nao se referem ao Modulo
					nLoops := Len( aFilesOpen )
					For nLoop := 1 To nLoops
						( aFilesOpen[nLoop] )->( dbCloseArea() )
					Next nLoop

					If ( lDifEmp  )
						nLoops := Len(aFilesTransf)
						For nLoop := 1 To nLoops
							fFecEmpresa( aFilesTransf[nLoop,1] )
						Next nLoop
					Endif

					//--Carrega os Arquivos a Serem Transferidos
					MsAguarde( { || lFilesTransf := FilesTransf(@aFilesTransf,@aFilesOpen, @lArqRH3) },STR0040 + STR0020 ) //"Preparando Arquivos. Aguarde..."

					IF !( lFilesTransf )
						Break
					EndIF
				EndIf

				// CASO O ALIAS RH3 TENHA SIDO INFORMADO NO PARAMETRO MV_ARQTRAN
				// CHAMA A FUNÇÃO QUE VALIDA SE EXISTE ALGUMA SOLICITAÇÃO PENDENTE AO RH.
				If !lRobo .And. lArqRH3
					fRetInfRH3(cFilDe, cMatDe, @lSolicPend)

					If lSolicPend .And. !MsgNoYes(OemToAnsi(STR0334) + cMatDe + OemToAnsi(STR0335), OemToAnsi(STR0047)) // Existem solicitações ao RH que se encontram pendentes de aprovação, caso prossiga, esses dados não serão transferidos. Deseja Continuar? ## Atenção
						Loop
					EndIf
				EndIf

				If lItemClvl
					cItemAte	:= aTransfCols[nx,_CITEM  ]
					cClvlAte	:= aTransfCols[nx,_CCLVL  ]
				EndIf

				If (cOrgCfg == "1")
					cPostoAte	:= aTransfCols[nx,_POSTO  ]
				Endif

				cProces 	:= aTransfCols[nx,_PROCES ]
				lFilDif		:= ( cFilDe      # cFilAte  )
				lCcDif		:= ( xFilial("CTT", cFilDe) + cCcDe		# xFilial("CTT", cFilAte) + cCcuAte  )
				lMatDif		:= ( cMatDe      # cMatAte  )
				lProcDif	:= ( xFilial("RCJ", cFilDe) + cProcesDe	# xFilial("RCJ", cFilAte) + cProces  )
				lDeptoDif	:= ( xFilial("SQB", cFilDe) + cDeptoDe	# xFilial("SQB", cFilAte) + cDeptoAte)

				If lItemClvl
					lItemDif	:= ( cItemDe     # cItemAte )
					lClvlDif	:= ( cClvlDe     # cClvlAte )
				EndIf

				If (cOrgCfg == "1")
					lPostoDif	:= ( cPostoDe    # cPostoAte)
				Else
					lPostoDif	:= .F.
				Endif

				lDelNovo 	:= .F.							//-- Deletar Registro se exitir no Destino
				lGravaNovo	:= .F.							//-- Gera novo Registro  no arquivo destino ( Transf. Empresa e Filial )
				lDelAntigo	:= .F.							//-- Forca a Delecao dos Registros da Empresa e/ou Filial Anterior ( Transferencia entre Empresas e CGC Igual )
				lRegrava	:= .F.							//-- Nao Alterar Registro Atual Quando Empresa ou Filial
				lMudaSra	:= .F.							//-- Altera dados do SRA nas transf.Empresa/filial - CNPJ diferentes (nao grava cpos complementares)
				lRetTit    := lSubTit := .F.

				If _RETTIT > 0
					lRetTit := aTransfCols[nx,_RETTIT ] == "1"
					lSubTit := aTransfCols[nx,_SUBTIT ] == "1"
				EndIf

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Mudanca de empresa                                           ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If ( lEmpDif )
					If lCgcDif						//--CGC DIFERENTE
						lMudaSra	:= .T.
					Else  							//--CGC IGUAL
						lDelAntigo	:= .T.
					Endif

					lDelNovo 	:= .T.
					lGravaNovo	:= .T.
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Mudanca de Filial                                            ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				Elseif ( lFilDif )
					If ( lCgcDif )					//--CGC DIFERENTE
						lGravaNovo	:= .T.
						lMudaSra	:= .T.
					Else             				//--CGC IGUAL
						lRegrava	:= .T.
					Endif

					lDelNovo 	:= .T.
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Mudanca de C.Custo                                           ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				Elseif ( lCcDif )
					lRegrava	:= .T.
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Mudanca de Departamento                                      ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				Elseif ( lDeptoDif )
					lRegrava	:= .T.
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Mudanca de Matricula                                         ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				Elseif ( lMatDif )
					lDelNovo 	:= .T.
					lRegrava	:= .T.
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Mudanca de Processo                                          ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				ElseIf (lProcDif )
					lRegrava 	:= .T.
				ElseIf (cOrgCfg == "1" .AND. lPostoDif)
					lRegrava 	:= .T.
				ElseIf lItemClvl
					If (lItemDif) .or. (lClvlDif)
						lRegrava	:= .T.
					EndIf
				EndIf

				cFilMat 	:= fwXFilial("SRA",cFilDe) + cMatDe
				SRA->( dbSeek( cFilMat , .F. ) )

				cMatDe		:= SRA->RA_MAT
				cCPFDe		:= SRA->RA_CIC
				cCcDe		:= SRA->RA_CC
				cProcesDe	:= SRA->RA_PROCES
				cDeptoDe	:= SRA->RA_DEPTO

				If (cOrgCfg == "1")
					cPostoDe 	:= SRA->RA_POSTO
				Endif
				If lItemClvl
					cItemDe := SRA->RA_ITEM
					cClvlDe := SRA->RA_CLVL
				EndIf

				If !lRobo
					IncPrcG1Time(	AllTrim( SRA->RA_FILIAL + " / " + SRA->RA_MAT + " / " + SRA->RA_NOME )	,;	//01 -> Inicio da Mensagem
									nProcRegua																,;	//02 -> Numero de Registros a Serem Processados
									cTimeIni																,;	//03 -> Tempo Inicial
									.F.																		,;	//04 -> Defina se eh um processo unico ou nao ( DEFAULT .T. )
									-1																		,;	//05 -> Contador de Processos
									1	 																	 ;	//06 -> Percentual para Incremento
								)
				Endif

				If cPaisLoc == "BRA"
					lIntegTSV := !(SRA->RA_CATEFD $ cNTSV)
					cGeraMat := If(lMatTSV, SRA->RA_DESCEP, "")
					lGeraMat := cGeraMat == "1"
					lObraTot := .F.

					//Verifica se o registro de admissão ou carga inicial do funcionário ja foi integrado ao RET, dependendo da categoria
					//Se existir e estiver integrado retorna .F. , se nao foi possivel a integração não transfere
					If ( lCcDif .Or.  lFilDif )  .AND. (lIntTAF .Or. lMiddleware) .AND. lIntegTSV
						// VERIFICA O COMPARTILHAMENTO DAS TABELAS C9V/C9Y/CUP/T3L/CRQ/T80/T90/T1U/T1V/TOF/CUU/T3A E COMPARA
						// AO DA TABELA SRA.
						If !lRobo .And. Findfunction("fVldCmpTab") .And. !fVldCmpTab()
							Break
						EndIf

						IF lVerRJ5
							aOperCC	:= {.F., .F., .F., .F.}
							cOrigInsc := ""
							cDestNInsc := ""
							DbSelectArea("RJ5")
							aRH5Filt := fRJ5Filt()
							RJ5->( dbSetOrder(7) )//RJ5_FILIAL+RJ5_CC+RJ5_FILT+RJ5_COD+RJ5_INI
							RJ5->(dbGotop())
							If Len(aRH5Filt) > 0
								If RJ5->( dbSeek( xFilial("RJ5", cFilDe)  + SRA->RA_CC + SRA->RA_FILIAL ) )
									While RJ5->( !EoF() ) .And. RJ5->RJ5_FILIAL == xFilial("RJ5", cFilDe) .And.  RJ5->RJ5_CC == SRA->RA_CC .And.;
										IF(!Empty(RJ5->RJ5_FILT) , RJ5->RJ5_FILT == SRA->RA_FILIAL, .T.)
										IF AnoMes(dDataTra) >= RJ5_INI
											//CC de origem existe na RJ5
											aOperCC[1] := .T.
											cOrigInsc := RJ5_NIO
											IF !EMPTY(RJ5->(RJ5_TPIO)) .AND. !EMPTY(RJ5->(RJ5_NIO))
												//CC de origem tem as informações de tipo e inscrição preenchidas
												aOperCC[2] := .T.
											ENDIF
										ENDIF
										RJ5->( dbSkip() )
									EndDo
								EndIf
							Endif
							If Len(aRH5Filt) == 0 .Or.  !aOperCC[1]
								If RJ5->( dbSeek( xFilial("RJ5", cFilDe) + SRA->RA_CC ) )
									While RJ5->( !EoF() ) .And. RJ5->RJ5_FILIAL == xFilial("RJ5", cFilDe) .And. RJ5->RJ5_CC == SRA->RA_CC .And.;
										IF(!Empty(RJ5->RJ5_FILT) , RJ5->RJ5_FILT == cFilDe, .T.)
										IF AnoMes(dDataTra) >= RJ5_INI
											//CC de origem existe na RJ5
											aOperCC[1] := .T.
											cOrigInsc := RJ5_NIO
											IF !EMPTY(RJ5->(RJ5_TPIO)) .AND. !EMPTY(RJ5->(RJ5_NIO))
												//CC de origem tem as informações de tipo e inscrição preenchidas
												aOperCC[2] := .T.
											ENDIF
										ENDIF
										RJ5->( dbSkip() )
									EndDo
								EndIf
							Endif

							// Se não encontrou registro de origem, cancela a transferência
							IF !aOperCC[1]
								//Não Permite transferência
								cMsgLog := STR0281 + " " + M->RA_CC + " (origem), do funcionário " + ALLTRIM(M->RA_NOME) + " (Matrícula: " + M->RA_MAT + ") " + STR0282
								aAdd(aLogTransf, OemToAnsi(cMsgLog))
								RJ5->(DbCloseArea())
								Break
							ENDIF

							If lEmpDif
								fAbrEmpresa("RJ5",7,cEmpAte,cFilAte)
								cAliasRJ5 := "GPERJ5"
							EndIf
							cFilRJ5At := If(lEmpDif ,totvs.framework.company.xEmpFil("RJ5", cEmpAte, cFilAte), xFilial("RJ5", cFilAte))

							(cAliasRJ5)->( dbSetOrder(7) )//RJ5_FILIAL+RJ5_CC+RJ5_FILT+RJ5_COD+RJ5_INI
							(cAliasRJ5)->(dbGotop())
							If Len(aRH5Filt) > 0
								If (cAliasRJ5)->( dbSeek( cFilRJ5At + cCcuAte + cFilAte ) )
									While (cAliasRJ5)->(!EoF()) .And. (cAliasRJ5)->RJ5_FILIAL == cFilRJ5At .And. (cAliasRJ5)->RJ5_CC == cCcuAte .And.;
										IF(!Empty((cAliasRJ5)->RJ5_FILT) , (cAliasRJ5)->RJ5_FILT == cFilAte, .T.)
										IF AnoMes(dDataTra) >= (cAliasRJ5)->RJ5_INI
										//CC de destino existe na RJ5
											aOperCC[3] := .T.
											IF !EMPTY((cAliasRJ5)->(RJ5_TPIO)) .AND. !EMPTY((cAliasRJ5)->(RJ5_NIO))
												//CC de destino tem as informações de tipo e inscrição preenchidas
												aOperCC[4] := .T.
											ENDIF
										Endif
										(cAliasRJ5)->( dbSkip() )
									EndDo
								EndIf
							Endif
							If Len(aRH5Filt) == 0 .Or.  !aOperCC[1]
								IF (cAliasRJ5)->( dbSeek( cFilRJ5At + cCcuAte ) )
									While (cAliasRJ5)->(!EoF()) .And. (cAliasRJ5)->RJ5_FILIAL == cFilRJ5At .And. (cAliasRJ5)->RJ5_CC == cCcuAte .And.;
										IF(!Empty((cAliasRJ5)->RJ5_FILT) , (cAliasRJ5)->RJ5_FILT == cFilAte, .T.)
										IF AnoMes(dDataTra) >= RJ5_INI
											//CC de destino existe na RJ5
											aOperCC[3] := .T.
											IF !EMPTY((cAliasRJ5)->(RJ5_TPIO)) .AND. !EMPTY((cAliasRJ5)->(RJ5_NIO))
												//CC de destino tem as informações de tipo e inscrição preenchidas
												aOperCC[4] := .T.
											ENDIF
										Endif
										(cAliasRJ5)->( dbSkip() )
									EndDo
								EndIf

							Endif
							If lEmpDif
								fFecEmpresa("RJ5")
							EndIf

							IF !aOperCC[3]
								//Não Permite transferência
								cMsgLog := STR0281 + " " + cCcuAte + " (destino), do funcionário " + ALLTRIM(M->RA_NOME) + " (Matrícula: " + M->RA_MAT + ") " + STR0282
								aAdd(aLogTransf, OemToAnsi(cMsgLog))
								Break
							ELSEIF (aOperCC[2] .OR. aOperCC[4]) .AND. cOrigInsc != cDestNInsc
								//Gera S2206
								lObraTot := .T.
							ELSEIF aOperCC[1] .AND. !aOperCC[2] .AND. aOperCC[3] .AND. !aOperCC[4]
								//Não gerar S2206
								lObraTot := .F.
							ENDIF
							RJ5->(DbCloseArea())
						ELSE
							lObraTot := Gpa180CC()
						ENDIF
					Endif

					If lEmpDif .OR. lFilDif .OR. lObraTot
						If (lIntTAF .Or. lMiddleware) .And. (SRA->RA_CATEFD $ cTrabVincu .Or. (! SRA->RA_CATEFD $ cTrabVincu .And. ! lEmpDif )) .And. lIntegTSV
							lErroTaf 	  := a180VerTaf(aLogTransf,,@cFilEnv, lGeraMat, If(lEmpDif, cEmpAnt,), If(lEmpDif, cFilDe,))
						Endif
					EndIf

					If (lIntTaf .Or. lMiddleware) .AND. lErroTaf
						If nX == Len(aTransfCols)
							Break
						Else
							Loop
						EndIF
					EndIf

				EndIf

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Ponto de entrada para desprezar o registro corrente se retono .F. ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If lGP180VALID
					If !( ExecBlock("GP180VALID",.F.,.F.) )
						IF !( GotoNextRecno( "SRA" , nSraNextRecno , nSraOrder ) )
							Break
						EndIF
						Loop
					EndIf
				Endif

				Begin Transaction

					//Gerar os eventos S-2299 e S-2200 | S-2399 e S-2300 - desligamento e inicio de um novo cadastro
					//---------------------------------------------------------------------------------------------------
					//REGRA PARA GERACAO DOS EVENTOS S-2299 E S-2200 ==> VALIDACAO DAS TABELAS C1E e CR9 do TAF
					//REGRA PARA GERACAO DOS EVENTOS S-2399 E S-2300
					//---------------------------------------------------------------------------------------------------
					//EMPRESA DESTINO CONFIGURADA => Se algum dos eventos falhar todos os eventos serao cancelados
					//EMPRESA DESTINO NAO CONFIGURADA => Gera somente o desligamento na empresa Origem
					//---------------------------------------------------------------------------------------------------
					If lGeraDem .And. lTrfEmpES .And. (lIntTAF .Or. lMiddleware) .And. lIntegTSV
						If !lMiddleware
							If SRA->RA_CATEFD $ cTrabVincu
								cStatDesl	:= TAFGetStat( "S-2299", AllTrim(SRA->RA_CIC) + ";" + AllTrim(SRA->RA_CODUNIC), , SRA->RA_FILIAL)
							Else
								cStatDesl	:= TAFGetStat( "S-2399", AllTrim(SRA->RA_CIC) + ";" + Space(Len(SRA->RA_CODUNIC)) + ";" + "1", , SRA->RA_FILIAL )
							EndIf
						Else
							fPosFil( cEmpAnt, SRA->RA_FILIAL )
							aInfos   := fXMLInfos()
							IF Len(aInfos) >= 4
								cTpInsc  := aInfos[1]
								lAdmPubl := aInfos[4]
								cNrInsc  := aInfos[2]
								cId  	 := aInfos[3]
							Else
								cTpInsc  := ""
								lAdmPubl := .F.
								cNrInsc  := "0"
							EndIf
							If SRA->RA_CATEFD $ cTrabVincu
								cChaveBus	:= cTpInsc + PADR( Iif( !lAdmPubl .And. cTpInsc == "1", SubStr(cNrInsc, 1, 8), cNrInsc), 14) + "S2299" + Padr(SRA->RA_CODUNIC, fTamRJEKey(), " ")
							Else
								cChave := Iif( cVersEnvio >= "9.0" .And. lGeraMat, SRA->RA_CODUNIC, AllTrim( SRA->RA_CIC ) + AllTrim( SRA->RA_CATEFD ) + DTOS( SRA->RA_ADMISSA ) )
								cChaveBus	:= cTpInsc + PADR( Iif( !lAdmPubl .And. cTpInsc == "1", SubStr(cNrInsc, 1, 8), cNrInsc), 14) + "S2399" + Padr(cChave, fTamRJEKey(), " ")
							EndIf
							cStatDesl 	:= "-1"
							GetInfRJE( 2, cChaveBus, @cStatDesl )
							fPosFil( cEmpAnt, cFilAnt )
							EndIf

						If ( cStatDesl == "-1" .Or. SRA->RA_RESCRAI $ '30/31' .Or. (cStatDesl == "4" .And. reintegrad(cFilEnv, @cStat2298) ) )
							lGeraInt := .T.
						EndIf

						//Identifica se o funcionário está desligado antes da transferência para gravar os dados da sucessão de vínculo
						If !lGeraInt .And. !Empty(SRA->RA_DEMISSA) .And. cCodDesl == "13" .And. cStatDesl == "4"
							//Inclui ou altera a sucessao de vinculo
							If lEmpDif
								fAbrEmpresa("RFZ")
								cAliasRFZ := "GPERFZ"
							EndIf

							lIncRFZ := !( (cAliasRFZ)->( dbSeek( cFilAte + cMatAte + "4",.F.) ) )

							If (cAliasRFZ)->( RecLock((cAliasRFZ), lIncRFZ) )
								(cAliasRFZ)->RFZ_FILIAL	:= cFilAte
								(cAliasRFZ)->RFZ_MAT	:= cMatAte
								(cAliasRFZ)->RFZ_CATEG	:= SRA->RA_CATEFD
								(cAliasRFZ)->RFZ_TPADM 	:= "4"
								(cAliasRFZ)->RFZ_INDADM	:= "1"
								(cAliasRFZ)->RFZ_INDPEM	:= "N"
								(cAliasRFZ)->RFZ_CNPJAN	:= cCgcDe
								(cAliasRFZ)->RFZ_MATANT	:= SRA->RA_CODUNIC
								(cAliasRFZ)->RFZ_DTADAN	:= SRA->RA_ADMISSA
								(cAliasRFZ)->RFZ_DTTRA	:= If(lRfzCmp, dDataTra, Ctod("//"))
								(cAliasRFZ)->RFZ_TPINSC	:= If( Len(cCgcDe) == 11, "2", "1")

								(cAliasRFZ)->( MsUnLock() )
							EndIf

							If lEmpDif
								fFecEmpresa("RFZ")
							EndIf
						EndIf

						If lGeraInt

								RegToMemory("SRA",,,.F.)
								fLoadVarMem(nPosRec1, nRecno) //Atualiza as variaveis de Memoria conforme os campos dos dados cadastrais
								If FindFunction("fVersEsoc")
									fVersEsoc( IIF (SRA->RA_CATEFD $ cTrabVincu ,"S2299","S2399"), .F., /*aRetGPE*/, /*aRetTAF*/, @cVersEnvio, @cVersGPE )
								EndIf

								//Gera o evento S-2299 do Grupo/Empresa origem para indicar que o funcionario encerrou aquele vinculo
								cMsgErr	  := ""
								aVinc	  := {}

								IF SRA->RA_CATEFD $ cTrabVincu
									lGerouXml := fTrf2299( cCodDesl, If(Empty(cFilEnv), cFilDe, cFilEnv), cCgcPara, dDataTra, cVersEnvio, @cMsgErr, cTpInscPara )
								ELSE
									lGerouXml := fTrf2399New( cCodDesl, If(Empty(cFilEnv), cFilDe, cFilEnv), cCgcPara, dDataTra, cVersEnvio, @cMsgErr )
								ENDIF

								//Se o primeiro evento de desligamento foi gerado corretamente faz a geracao do evento S-2200 do Grupo/Empresa destino
								If lGerouXml
									IF SRA->RA_CATEFD $ cTrabVincu
										cErXML := "S-2200"

										If lMiddleware
											// Abre novamente as tabelas do grupo de empresas destino
											fPosFil( cEmpAte, cFilAte )
											If lEmpDif
												ChangeNew({"SR6", "SQ3", "SRJ", "SPA", "SPJ", "RJ9", "RJE"}, cEmpAte, cFilAte)
											EndIf
										EndIf
										If !lMiddleware
											If lEmpDif
												lTAFDest	:=  totvs.framework.company.getParameter(cEmpAte,cFilAte,"MV_RHTAF")
											Else
												lTAFDest	:= GetMv("MV_RHTAF")
											EndIf
										EndIf
										//Verifica se a empresa destino esta configurada para o e-Social para gerar o evento S-2200
										If !lMiddleware .And. !Empty( fTafFilGpe( cEmpAte + cFilAte,,,!lEmpDif, cEmpAte, @cFilS2200, cFilAte ) ) .AND. lTAFDest .Or.;
											lMiddleware .And. fVld1000( AnoMes(dDataTra),,cFilAte,cEmpAte)
											//Dados da sucessao de vinculo
											Aadd( aVinc, {;
															If( cCodDesl == '11', '2', If( cCodDesl == '12', '3', If(cCodDesl == '43', '7', '4'))),;
															'1',;
															'N',;
															cCgcDe,;
															SRA->RA_CODUNIC,;
															SRA->RA_ADMISSA,;
															"",;
															If( cVersEnvio >= "2.4" .And. lRfzCmp, dDataTra, Ctod("//")),;
															If( Len(cCgcDe) == 11, "2", "1")})
											If FindFunction("fVersEsoc")
												fVersEsoc( "S2200", .F., /*aRetGPE*/, /*aRetTAF*/, @cVersEnvio, @cVersGPE, .T. )
											EndIf

											//Gera novo codigo unico para o Grupo/Empresa destino
											cCodUnic := cEmpAte
											cCodUnic += cFilAte + cMatAte
											cCodUnic += dToS(Date())
											cCodUnic += StrTran(Time(),':')

											//Limita ao tamanho do campo para nao gerar problema na integracao
											If Len(cCodUnic) > nTamCod
												cCodUnic := SubStr( cCodUnic, 1, nTamCod )
											EndIf

											If lEmpDif
												If !lMiddleware
													// Abre as tabelas do grupo de empresas destino
													ChangeNew({"SR6", "SQ3", "SRJ", "SPA", "SPJ"}, cEmpAte, cFilAte)
												EndIf
												fAbrEmpresa("SRA",,cEmpAte, cFilAte)

												cArqSR6 := "SR6"
												cArqSRJ := "SRJ"
												cArqSQ3 := "SQ3"
												cArqSRA := "GPESRA"

												cSR6Fil :=  totvs.framework.company.xEmpFil("SR6", cEmpAte, cFilAte)
												cSRJFil	:=  totvs.framework.company.xEmpFil("SRJ", cEmpAte, cFilAte)
												cSQ3Fil :=  totvs.framework.company.xEmpFil("SQ3", cEmpAte, cFilAte)

											ELSE
												cArqSR6 := "SR6"
												cArqSRJ := "SRJ"
												cArqSQ3 := "SQ3"
												cArqSRA := "SRA"

												cSR6Fil := xFilial("SR6", cFilAte)
												cSRJFil := xFilial("SRJ", cFilAte)
												cSQ3Fil := xFilial("SQ3", cFilAte)
											EndIf

											lGerouXml := fIntAdmiss("SRA",,3,"S2200",If(Empty(cFilS2200), cFilAte, cFilS2200),,cCodUnic,, "ADM",@aErr2200,cVersEnvio,,,,cFilAte,,aVinc,cFilDe,.F.,cCcuAte,cArqSR6, cSR6Fil, cEmpAte, cArqSRJ, cSRJFil, cArqSQ3, cSQ3Fil, Nil, Nil, .T.)
										EndIf
										If lEmpDif
											// Abre novamente as tabelas do grupo de empresas origem
											If lMiddleware
												// Retorna para a empresa e filial logada inicialmente
												ChangeNew({"SR6", "SQ3", "SRJ", "SPA", "SPJ", "RJ9", "RJE"}, cEmpAnt, cFilDe)
											Else
												ChangeNew({"SR6", "SQ3", "SRJ", "SPA", "SPJ"}, cEmpAnt, cFilDe, .F.)
											EndIf
										EndIf
										If lMiddleware
											// Retorna para a empresa e filial logada inicialmente
											fPosFil( cEmpAnt, cFilDe )
										EndIf
									ELSE //TSV
										If lMiddleware
											// Abre novamente as tabelas do grupo de empresas destino
											fPosFil( cEmpAte, cFilAte )
											If lEmpDif
												ChangeNew({"SR6", "SQ3", "SRJ", "SPA", "SPJ", "RJ9", "RJE"}, cEmpAte, cFilAte)
											EndIf
										EndIf

										If !lMiddleware
											If lEmpDif
												lTAFDest	:=  totvs.framework.company.getParameter(cEmpAte,cFilAte,"MV_RHTAF")
											Else
												lTAFDest	:= GetMv("MV_RHTAF")
											EndIf
										EndIf

										If !lMiddleware .And. !Empty( fTafFilGpe( cEmpAte + cFilAte,,,!lEmpDif, cEmpAte, @cFilS2200, cFilAte ) ) .AND. lTAFDest .Or.;
											(lMiddleware .And. fVld1000( AnoMes(dDataTra),,cFilAte,cEmpAte))

											If FindFunction("fVersEsoc")
												fVersEsoc( "S2300", .F., /*aRetGPE*/, /*aRetTAF*/, @cVersEnvio, @cVersGPE, .T. )
											EndIf

											If cVersEnvio >= "9.0" .And. lMatTSV
												//Gera novo codigo unico para o Grupo/Empresa destino
												cCodUnic := cEmpAte
												cCodUnic += cFilAte + cMatAte
												cCodUnic += dToS(Date())
												cCodUnic += StrTran(Time(),':')
												//Limita ao tamanho do campo para nao gerar problema na integracao
												If Len(cCodUnic) > nTamCod
													cCodUnic := SubStr( cCodUnic, 1, nTamCod )
												EndIf
												cGeraMat := "1"
											EndIf

											If lEmpDif
												If !lMiddleware
													// Abre tabelas do grupo de empresas destino
													ChangeNew({"SR6", "SQ3", "SRJ", "SPA", "SPJ"}, cEmpAte, cFilAte)
												EndIf
												fAbrEmpresa("SRA",, cEmpAte, cFilAte)

												cArqSR6 := "SR6"
												cArqSRJ := "SRJ"
												cArqSQ3 := "SQ3"
												cArqSRA := "GPESRA"

												cSR6Fil :=  totvs.framework.company.xEmpFil("SR6", cEmpAte, cFilAte)
												cSRJFil :=  totvs.framework.company.xEmpFil("SRJ", cEmpAte, cFilAte)
												cSQ3Fil :=  totvs.framework.company.xEmpFil("SQ3", cEmpAte, cFilAte)

											EndIf

											If Len(GetAPOInfo("TafTransfTrab.prw")) > 0
												lTAFTransf := .T. //Indica que o TAF está atualizado com a refatoração da transferência.
											EndIf

											lGerouXml := fInt2300New("SRA",/*lAltCad*/,3,"S2300",If(Empty(cFilS2200) .Or. !lTAFTransf, cFilAte, cFilS2200),/*aDadosXml*/,cVersEnvio,/*lCadEst*/, /*oMdlRFS*/,@aErr2200,/*aFilial*/,/*oMdlRFZ*/,cFilDe, Nil, .F., cEmpAte,cGeraMat,cCodUnic)
											lS2300	  := lGerouXml
											cErXML := "S-2300"
										EndIf
										If lEmpDif
											//Abre novamente as tabelas do grupo de empresas origem
											If lMiddleware
												// Retorna para a empresa e filial logada inicialmente
												ChangeNew({"SR6", "SQ3", "SRJ", "SPA", "SPJ", "RJ9", "RJE"}, cEmpAnt, cFilDe)
											Else
												ChangeNew({"SR6", "SQ3", "SRJ", "SPA", "SPJ"}, cEmpAnt, cFilDe)
											EndIf
										EndIf
										If lMiddleware
											cFilAnt	  := cBkpFil
											fPosFil( cEmpAnt, cFilAnt )
										EndIf
									ENDIF
								Else
									IF SRA->RA_CATEFD $ cTrabVincu
										cErXML := "S-2299"
									ELSE
										cErXML := "S-2399"
									ENDIF
								EndIf

								If !lGerouXml
									cMsgLogErr := STR0075	//"Nao foi possivel Efetuar a Tranferencia para a Matricula:"
									IF SRA->RA_CATEFD $ cTrabVincu
										cMsgLogXML := Iif(!lMiddleware, STR0248, STR0302) //"eSocial: Não foi possivel integrar ao TAF os eventos: S-2299 e S-2200. Verifique no TAF os dados da empresa destino."#"eSocial: Não foi possivel integrar ao Middleware os eventos: S-2299 e S-2200. Verifique no Middleware os dados da empresa destino."
									Else
										cMsgLogXML := Iif(!lMiddleware, STR0315, STR0316) //"eSocial: Não foi possivel integrar ao TAF os eventos: S-2399 e S-2300. Verifique no TAF os dados da empresa destino."#"eSocial: Não foi possivel integrar ao Middleware o evento: S-2399"
									EndIf
									aAdd( aLogTransf , Space(5) + cMsgLogErr  )
									aAdd( aLogTransf , Space(5) + cEmpAnt + " " + cFilDe + " " + SRA->RA_MAT + " - " + SRA->RA_NOME )
									aAdd( aLogTransf , Space(5) + cMsgLogXML  )
									ConsLog(aLogTransf,aErr2200)

									dDataTAF := CTOD("//")

									If !Empty(cMsgErr)
										aAdd( aLogTransf , Space(5) + cMsgErr  )
									EndIf
									DisarmTransaction()
									Break
								Else
									//Preenche variável para gravação no campo RE_INTGTAF
									dDataTAF := dDataTra
									lIntTAFok := .T.
									IF  SRA->RA_CATEFD $ cTrabVincu
										//Se gerou o codigo unico indica que o evento de admissao foi gerado com sucesso na empresa destino
										If !Empty(cCodUnic) .And. Len( aVinc ) > 0
											//Inclui ou altera a sucessao de vinculo
											If lEmpDif
												fAbrEmpresa("RFZ")
												cAliasRFZ := "GPERFZ"
											EndIf

											(cAliasRFZ)->(DbSetOrder(1))
											lIncRFZ := !( (cAliasRFZ)->( dbSeek( cFilAte + cMatAte + aVinc[1,1],.F.) ) )

											(cAliasRFZ)->( RecLock((cAliasRFZ),lIncRFZ) )
											(cAliasRFZ)->RFZ_FILIAL	:= cFilAte
											(cAliasRFZ)->RFZ_MAT	:= cMatAte
											(cAliasRFZ)->RFZ_CATEG	:= SRA->RA_CATEFD
											(cAliasRFZ)->RFZ_TPADM 	:= aVinc[1,1]
											(cAliasRFZ)->RFZ_INDADM	:= aVinc[1,2]
											(cAliasRFZ)->RFZ_INDPEM	:= aVinc[1,3]
											(cAliasRFZ)->RFZ_CNPJAN	:= aVinc[1,4]
											(cAliasRFZ)->RFZ_MATANT	:= aVinc[1,5]
											(cAliasRFZ)->RFZ_DTADAN	:= aVinc[1,6]
											(cAliasRFZ)->RFZ_DTTRA	:= aVinc[1,8]
											(cAliasRFZ)->RFZ_TPINSC	:= aVinc[1,9]
											(cAliasRFZ)->( MsUnLock() )

											If lEmpDif
												fFecEmpresa("RFZ")
											EndIf

											//Altera o codigo unico no acols para gerar com o numero atualizado na empresa destino
											nPosUnico := aScan( aSRAHeader , { |x| x[2] == 'RA_CODUNIC' } )
											If nPosUnico > 0
												aSRACols[nPosAtu,nPosUnico] := cCodUnic
											EndIf

											cMsgLogXML := Iif(!lMiddleware, STR0249, STR0303) //"Eventos S-2299 e S-2200 enviados ao TAF com sucesso."#"Eventos S-2299 e S-2200 enviados ao Middleware com sucesso."
										Else
											//Foi gerado somente o evento de desligamento na origem
											//"Evento S-2299 enviado ao TAF com sucesso"#"Evento S-2299 enviado ao Middleware com sucesso"#"Evento S-2200 enviado ao TAF sem sucesso. Não foram localizados no TAF os dados da empresa destino."#"Evento S-2200 enviado ao Middleware sem sucesso. Não foram localizados no Middleware os dados da empresa destino."
											cMsgLogXML := Iif(!lMiddleware, STR0247, STR0301)  + CRLF + Iif(!lMiddleware, STR0246, STR0300)
										EndIf
									Else
										If lS2300

											If cVersEnvio >= "9.0" .And. lMatTSV .And. !Empty(cCodUnic)
												//Altera o codigo unico no acols para gerar com o numero atualizado na empresa destino
												nPosUnico := aScan( aSRAHeader , { |x| x[2] == 'RA_CODUNIC' } )
												If nPosUnico > 0
													aSRACols[nPosAtu,nPosUnico] := cCodUnic
												EndIf
												nPosGMat := aScan( aSRAHeader , { |x| AllTrim(x[2]) == 'RA_DESCEP' } )
												If nPosGMat > 0
													aSRACols[nPosAtu,nPosGMat] := cGeraMat
												EndIf
											EndIf

											cMsgLogXML := Iif(!lMiddleware, STR0309, STR0310) //"Eventos S-2399 e S-2300 enviados ao TAF com sucesso."#"Eventos S-2399 e S-2300 enviados ao Middleware com sucesso."
										Else
											//Foi gerado somente o evento de desligamento na origem
											//"Evento S-2399 enviado ao TAF com sucesso"#"Evento S-2399 enviado ao Middleware com sucesso"#"Evento S-2300 enviado ao TAF sem sucesso. Não foram localizados no TAF os dados da empresa destino."
											cMsgLogXML := Iif(!lMiddleware, STR0311, STR0312)  + CRLF + Iif(!lMiddleware, STR0313, "")
										EndIf
									ENDIF
								Endif
						EndIf
					EndIf

					// Realizar a alteração contratual apenas se mudou de filial com a mesma raiz de CNPJ
					If !lTrfEmpES .And. (lFilDif .Or. lObraTot) .And. (lIntTAF .Or. lMiddleware) .And. lIntegTSV .And. cPaisLoc == "BRA"
						// Não envia para o TAF se for transferência entre grupos de empresas
						If lEmpDif .And. cCgcDe == cCgcPara
							//Transferência entre filiais com CNPJ idênticos em grupos de empresas diferentes, o evento do eSocial não será enviado.
							aAdd( aLogTransf , Space(5) + OemToAnsi(STR0347)  )
							//Acesse a documentação:
							aAdd( aLogTransf , Space(5) + OemToAnsi(STR0348) + "https://tdn.totvs.com/pages/viewpage.action?pageId=836507602")
							lIntESoc := .F.
						Else
							cErXML := ""
						If aTpAlt[3]
							RegToMemory("SRA",,,.F.)
							fLoadVarMem(nPosRec1, nRecno) //Atualiza as variaveis de Memoria conforme os campos dos dados cadastrais
							If lFilDif .And. !fCheck2206(cFilDe, cFilAte)
								IF SRA->RA_CATEFD $ cTrabVincu
									If FindFunction("fVersEsoc")
										fVersEsoc( "S2200", .F., /*aRetGPE*/, /*aRetTAF*/, @cVersEnvio, @cVersGPE, .T. )
									EndIf
									lGerouXml := fIntAdmiss("SRA", NIL, 0, "S2200", cFilAte, NIL, NIL, NIL, NIL, aErr2200, cVersEnvio, NIL, NIL, NIL, cFilAte, , NIL, cFilDe)
									cErXML := "S-2200"
								ELSEIF !lEmpDif
									lGerouXml := fInt2300New("SRA",/*lAltCad*/,1,"S2300",cFilAte,/*aDadosXml*/,cVersEnvio,/*lCadEst*/, /*oMdlRFS*/,@aErr2200,/*aFilial*/,/*oMdlRFZ*/,cFilDe, Nil, .F.)
									cErXML := "S-2300"
								ENDIF
							Endif
							If lGerouXML .Or. lObraTot .Or. fCheck2206(cFilDe, cFilAte)
								// Geração do S-2206 somente para trabalhador com vinculo
								IF SRA->RA_CATEFD $ cTrabVincu
									If FindFunction("fVersEsoc")
										fVersEsoc( "S2206", .F., /*aRetGPE*/, /*aRetTAF*/, @cVersEnvio, @cVersGPE, .T. )
									EndIf
									cBkpFil	  := cFilAnt
									cFilAnt	  := cFilAte
									lGerouXml := fInt2206("SRA",,3,"S2206",cFilAte,,,,,,cVersEnvio,,dDataTra,.T., cCcuAte,aErr2206, .F., .T.)
									cFilAnt	  := cBkpFil
									cErXML += If( Empty(cErXML), "S-2206", " / S-2206" )
								ELSEIF !lEmpDif .And. cVersEnvio >= "9.2" .And. dDataTra >= CToD("22/01/2024") .And. FindFunction("fLocalTrab") .And. fLocalTrab(SRA->RA_CATEFD)
									cBkpFil	  := cFilAnt
									cFilAnt	  := cFilAte
									lGerouXml := fInt2306New("SRA",/*lAltCad*/,3,"S2306",cFilAte,/*dtEf*/,cVersEnvio,/*lCadEst*/,/*oMdlRFS*/,.T., dDataTra, .T.,aErr2306 , .F.)
									cFilAnt	  := cBkpFil
									cErXML += If( Empty(cErXML), "S-2306", " / S-2306" )
								ENDIF
							Endif
						Else
							cErXML += If( SRA->RA_CATEFD $ cTrabVincu, "S-2200", " / S-2300" )
							cMsgLogXML := STR0214 + cErXML   //"eSocial: Não foi possível gerar o XML para o evento: cErXML, podendo ser < S-2200 , S-2100 ou S-2206 >
							aAdd( aLogTransf , Space(5) + cEmpAnt + " " + cFilDe + " " + SRA->RA_MAT + " - " + SRA->RA_NOME )
							aAdd( aLogTransf , Space(5) + cMsgLogXML  )
							aAdd( aLogTransf , Space(5) + Iif(!lMiddleware, STR0280, STR0291) )//"Não será possível integrar com o TAF pois o registro de Admissão ou Carga Inicial deste funcionário ainda não foi efetivado no TAF."#"Não será possível integrar com o Middleware pois o registro de Admissão ou Carga Inicial deste funcionário ainda não foi efetivado."
							lGerouXml := .F.
							DisarmTransaction()
							Break
						Endif
					EndIf

					If lIntESoc
						If !lGerouXml
							//Limpa a variável de integração
							dDataTAF := CTOD("//")
							cMsgLogErr := STR0075	//"Nao foi possivel Efetuar a Tranferencia para a Matricula:"
							cMsgLogXML := STR0214 + cErXML   //"eSocial: Não foi possível gerar o XML para o evento: cErXML, podendo ser < S-2200 , S-2100 ou S-2206 >
							aAdd( aLogTransf , Space(5) + cEmpAnt + " " + cFilDe + " " + SRA->RA_MAT + " - " + SRA->RA_NOME )
							aAdd( aLogTransf , Space(5) + cMsgLogErr  )
							aAdd( aLogTransf , Space(5) + cMsgLogXML  )
							If Len( aErr2200 ) > 0
								FeSoc2Err( aErr2200[1], @cMsgErro , Iif( aErr2200[1] != '000026',1,2 ) )
								FrmTexto(@cMsgErro)
								aErr2200[1] := cMsgErro
								aAdd( aLogTransf, cMsgErro )
							EndIf
							If Len( aErr2206 ) > 0
								FeSoc2Err( aErr2206[1], @cMsgErro , Iif( aErr2206[1] != '000026',1,2 ) )
								FrmTexto(@cMsgErro)
								aErr2206[1] := cMsgErro
								aAdd( aLogTransf, cMsgErro )
							EndIf
							If Len( aErr2306 ) > 0
								FeSoc2Err( aErr2306[1], @cMsgErro , Iif( aErr2306[1] != '000026',1,2 ) )
								FrmTexto(@cMsgErro)
								aErr2306[1] := cMsgErro
								aAdd( aLogTransf, cMsgErro )
							EndIf
							DisarmTransaction()
							break
						Else
							cMsgLogXML := Iif(!lMiddleware, STR0250, STR0304) + "(" + cErXML + ")" //"Eventos(s) enviado(s) ao TAF com sucesso: "#"Eventos(s) enviado(s) ao Middleware com sucesso: "
							//Preenche variável para gravação no campo RE_INTGTAF
							dDataTAF := dDataTra
							lIntTafok := .T.
						Endif
						EndIf
					Endif

					//Integracao SIGAMDT -> SIGATAF/Middleware
					If lMdtGPE .And. FindFunction( "MDTIntEsoc" ) .And. leSocMDT .And. ( lIntTAF .Or. lMiddleware ) .And. lGerouXml .And. lIntESoc

						If nPosFuncao > 0
							cFuncAte := M->RA_CODFUNC
						EndIf

						If nPosCargo > 0
							cCargoAte := M->RA_CARGO
						EndIf

						If !Empty( cCodUnic ) //Caso não tenha um novo código unico a ser considerado, pega o da memória
							cCodUniMDT := cCodUnic
						Else
							cCodUniMDT := SRA->RA_CODUNIC
						EndIf

						//Adiciona as informações da transferência ao array a ser utilizado no SIGAMDT
						aAdd( aInfMDT, { dDataTra, cEmpAnt, cEmpAte, cFilDe, cFilAte, cMatDe, cMatAte, cCcDe, cCcuAte, cDeptoDe, cDeptoAte, cFuncAte, cCargoAte, cCodUniMDT } )

						//Integra o evento S-2240 com o SIGATAF/Middleware
						lGerouXml := MDTIntEsoc( "S-2240", 4, , { { cMatDe, , , , , , aInfMDT } }, .T., , , @cLogMDT )

						//Zera a variável para validação do próximo funcionário do laço
						aInfMDT := {}

						//Define a variável para o evento S-2240
						cErXML += IIf( Empty( cErXML ), "S-2240", " / S-2240" )

						If !lGerouXml
							//Limpa a variavel de integracao
							dDataTAF := SToD( "" )
							cMsgLogErr := STR0075 //"Nao foi possivel Efetuar a Tranferencia para a Matricula:"
							cMsgLogXML := STR0214 + cErXML //"eSocial: Nao foi possivel gerar o XML para o evento: cErXML, podendo ser < S-2200 , S-2100, S-2206 ou S-2240>
							aAdd( aLogTransf, Space( 5 ) + cEmpAnt + " " + cFilDe + " " + SRA->RA_MAT + " - " + SRA->RA_NOME )
							aAdd( aLogTransf, Space( 5 ) + cMsgLogErr )
							aAdd( aLogTransf, Space( 5 ) + cMsgLogXML )
							aAdd( aLogTransf, '' )
							aAdd( aLogTransf, cLogMDT )

							aAdd( aLogTransf, '' )
							cLogMDT := ""
							DisarmTransaction()
							Break
						Else
							cMsgLogXML := IIf( !lMiddleware, STR0250, STR0304 ) + "(" + cErXML + ")" //"Eventos(s) enviado(s) ao TAF com sucesso: "#"Eventos(s) enviado(s) ao Middleware com sucesso: "
							cLogMDT := ""
							//Preenche variavel para gravacao no campo RE_INTGTAF
							dDataTAF := dDataTra
							lIntTafok 	:= .T.
							// Ativa variável apenas se não ocorreu Alteração Contratual (evento S-2206)
							// Ou seja, transferências de entidades menores como Centro de Custo / Departamento / Processo
							// dentro da mesma raiz de CNPJ e ocorreu alteadminração salarial
							// Dessa forma a variável impedirá que seja gravado conteúdo no campo R3_INTGTAF
							If !(lTrfEmpES .And. (lFilDif .Or. lObraTot) .And. (lIntTAF .Or. lMiddleware) .And. lIntegTSV .And. cPaisLoc == "BRA")
								lGer2240 	:= .T.
							EndIf
						EndIf
					EndIf

					If lAhgora .And. (lFilDif .Or. lCcDif .Or. lDeptoDif .Or. lEmpDif)
						lGerouRUM := .T.
						If fAhgoraTransf(dDataTra, @lTemRUM)
							lGerouRUM := .F.
							aAdd(aLogTransf, '')
							aAdd(aLogTransf, Space(5) + STR0075) //"Nao foi possivel Efetuar a Tranferencia para a Matricula:"
							aAdd(aLogTransf, Space(5) + cEmpAnt + " " + cFilDe + " " + SRA->RA_MAT + " - " + SRA->RA_NOME)
							aAdd(aLogTransf, Space(5) + If(lTemRUM, STR0361, STR0362)) //Ahgora: Registro do funcionário está na tabela RUM(Integração Ahgora), porém não foi integrado. ### A Tabela RUM não exste na empresa destino.
							aAdd(aLogTransf, '')
							DisarmTransaction()
							Break
						EndIf
					EndIf
				End Transaction

				If !lGerouXml .Or. !lGerouRUM
					If nX == Len(aTransfCols)
						Break
					Else
						Loop
					EndIF
				EndIf

				Begin Transaction

					Begin Sequence

						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³ Grava Registro no Arquivo de Transferencia                   ³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						If lItemClvl
							IF (  lFilDif  .or.  lEmpDif  .or.  lCcDif  .Or.  lProcDif .or. lDeptoDif .or. lPostoDif .or. lItemDif .or. lClvlDif )
								IF !Grava_SRE( @aLogTransf )
									Break
								EndIF

								//-- Retira a matricula transferida como responsavel do Departamento (QB_FILTIT e QB_MATTIT)
								If lRetTit
									SQB->(DbSetOrder(1))
									SQB->(DbSeek(xFilial() + cDeptoDe))
									RecLock("SQB", .F.)
									SQB->QB_FILTIT := ""
									SQB->QB_MATTIT := ""
									SQB->(MsUnLock())
								EndIf

								//-- Indica a matricula transferida como responsavel do Departamento (QB_FILTIT e QB_MATTIT)
								If lSubTit
									SQB->(DbSetOrder(1))
									SQB->(DbSeek(xFilial() + cDeptoAte))
									RecLock("SQB", .F.)
									SQB->QB_FILTIT := SRE->RE_FILIALP
									SQB->QB_MATTIT := SRE->RE_MATP
									SQB->(MsUnLock())
								EndIf

								//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
								//³Monta Array com  os dados para envio de e-mail              ³
								//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
								fMontaMail("019")
							EndIF
						Else
							IF (  lFilDif  .or.  lEmpDif  .or.  lCcDif  .Or.  lProcDif .or. lDeptoDif .or. lPostoDif )
								IF !Grava_SRE( @aLogTransf )
									Break
								EndIF

								//-- Retira a matricula transferida como responsavel do Departamento (QB_FILTIT e QB_MATTIT)
								If lRetTit
									SQB->(DbSetOrder(1))
									SQB->(DbSeek(xFilial() + cDeptoDe))
									RecLock("SQB", .F.)
									SQB->QB_FILTIT := ""
									SQB->QB_MATTIT := ""
									SQB->(MsUnLock())
								EndIf

								//-- Indica a matricula transferida como responsavel do Departamento (QB_FILTIT e QB_MATTIT)
								If lSubTit
									SQB->(DbSetOrder(1))
									SQB->(DbSeek(xFilial() + cDeptoAte))
									RecLock("SQB", .F.)
									SQB->QB_FILTIT := SRE->RE_FILIALP
									SQB->QB_MATTIT := SRE->RE_MATP
									SQB->(MsUnLock())
								EndIf

								//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
								//³Monta Array com  os dados para envio de e-mail              ³
								//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
								fMontaMail("019")
							EndIF
						EndIf
						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³Chamada da Funcao de Transferencia                          ³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						Eval( bGpea180Tra )

						// Chama a Funcao de para salvar o Historico Salarial
						// nPosAtu guarda posição no grid de acordo com o recno
						// Com o aSort de aTransfCol é necessário validar o segundo grid de acordo com a posição
						If nPosSalAlt > 0
							If aSv1TransfCols[nPosAtu,nPosSalAlt] != aTransf1Cols[nPosAtu,nPosSalAlt]
								fSalvHstSal(aTransf1Cols[nPosAtu,nPosDtAlt],aTransf1Cols[nPosAtu,nPosTpAlt],aTransf1Cols[nPosAtu,nPosSalAlt],aSv1TransfCols[nPosAtu,nPosSalAlt],nSraOrder,If(lGer2240, !lGer2240, lIntTAFok))
							EndIf
						EndIf

						If laModTraj .AND.  Len(aModTraj) > 0
							GravaRCP()
						Endif

						//Gravacao na tabela RJP caso a Integração com NG estiver ativada
						If lGpe10InNG
							If lFilDif
								fSendDadosApi("D", dDataTra)
							ElseIf (lCcDif .Or. lDeptoDif)
								fSendDadosApi("I", dDataTra)
							EndIf
						Endif

						//atualiza vinculo funcional
						//mudança de vinculo funcional
						If cEmpAnt <> cEmpAte .Or. cFilDe <> cFilAte .Or. cMatDe <> cMatAte
							aFunc := FWVldVinc(cEmpAnt,Alltrim(cFilDe),cMatDe,.T.)
							//se tem retorno, tem vinculo funcional no SIGACFG
							If Valtype(aFunc) == "A"
								aRet := FWTrVinc(aFunc,cEmpAte,cFilAte,cMatAte)
								If !aRet[1]
									aAdd( aLogTransf ,  STR0075 + " " + cMatDe + " Msg : " + aRet[2][6])////"Nao foi possivel Efetuar a Tranferencia para a Matricula:"
									DisarmTransaction()
									Break
								EndIf
							EndIf
						EndIf

						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³Carregando Dados para relacionamento no RDZ/RD0             ³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						IF ( lSraRelation )
							IF EntExisteRel( "SRA" , SRA->RA_FILIAL + If(!lFilDif .And. lMatDif, cMatDe, SRA->RA_MAT) , __cSvEmpAnt , SRA->RA_FILIAL , .T. )
								aAdd( aSraUpdRelRd0 , { SRA->( Recno() ) , If( lMatDif, cMatAte, SRA->RA_MAT) , RD0->( Recno() ) } )
							EndIF
						EndIF

						IF ( lMudaSra )

							//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
							//³  Situacao do Funcionario                                     ³
							//³  Data de Demissao                                            ³
							//³  Situacao para RAIS                                          ³
							//³  Codigo de Transferencia FGTS                                ³
							//|  Numero do Cracha                                            |
							//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
							cBkpFil := cFilAnt
							cFilAnt := cFilDe
							aAreaSRA  := SRA->( GetArea() )
							lMudaSra := SRAnterior( cFilMat , dDataTra , @aLogTransf, lTsRep )  // registro anterior
							RestArea(aAreaSRA)
							cFilAnt	:= cBkpFil
						EndIf

						If lTSREP
							oObjREP := PTSREPOBJ():New()

							// Efetua o envio das informacoes para o TSA sobre o novo registro do SRA
							//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
							//³ Executa o WebServices TSA - Pessoa Fisica e Usuario          ³
							//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

							cChaveSRE := PADR(SRE->RE_FILIALP , TAMSX3("RA_FILIAL")[1]) + SRE->RE_MATP
							aAreaSRA  := SRA->( GetArea() )

							If ( SRA->(dbSeek(cChaveSRE)) .AND. oObjREP:WSNatural( 1 ) .And. oObjREP:WSUser( 1 ) )
								//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
								//³ Grava as informacoes de controle de log de integracao WebServices TSA ³
								//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
								oObjRep:WSUpdRHExp( "SRA" )
							EndIf

							// Se teve troca de turno, integra esta informação com o Suricato.
							If lMudaSra .Or. (nPosTurno > 0 .And. aTransf1Cols[nX, nPosTurno] <> aSv1TransfCols[nX, nPosTurno])
								aAreaSR6  := SR6->( GetArea() )
								aAreaSPF  := SPF->( GetArea() )

								SR6->(dbSetOrder(1))
								SPF->(dbSetOrder(1))

								If SR6->(DbSeek(xFilial("SR6",SRA->RA_FILIAL) + SRA->RA_TNOTRAB)) .And. SPF->(DbSeek(xFilial("SPF",SRA->RA_FILIAL) + SRA->RA_MAT + DtoS(dDataTra)))
									oObjREP:WSShiftWork(1)
									oObjREP:WSUser( 4 , SPF->PF_DATA,,,SPF->PF_TURNOPA,,,SPF->PF_SEQUEPA )
									oObjRep:WSUpdRHExp( "SR6" )
									oObjRep:WSUpdRHExp( "SPF" )
								EndIf
								RestArea(aAreaSR6)
								RestArea(aAreaSPF)
							EndIf
							RestArea(aAreaSRA)
						Endif

						//Necessário comparar "Filial+Posto de origem" contra "Filial+Posto Destino"
						//em virtude de transferências entre filiais, mas com o mesmo id do posto
						If (cOrgCfg == "1") .AND. (cFilDe+cPostoDe != cFilAte+cPostoAte)
							OrgXRescisao(cFilDe, cMatDe, dDataTra)
							OrgXOcupacao(cFilAte, cMatAte, cPostoAte, dDataTra)
						EndIf

						// banco de conhecimento
						If !lEmpDif .And. (lMatDif .Or. lFilDif )
							A180TBco( If(lEmpDif,cFilACBAt,"") , If(lEmpDif,cFilAC9At,"") , If(lEmpDif,cPathACB,""))
						EndIf

						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³ Ponto de Entrada para Alterar Alguns Campos Apos a transferencia                                    ³
						//³ -Variaveis que podem ser Usadas                                                                     ³
						//³  cEmpAte = Empresa Destino                                                                          ³
						//³  cFilAte = Filial Destino                                                                           ³
						//|  cMatAte = Matricula Destino                                                                        |
						//³  cCcuAte = C.Custo Destino                                                                          ³
						//³  cItemAte = Item Contabil Destino                                                                   ³
						//³  cClvlAte = Classe de valor Destino                                                                 ³
						//³  lMudaSra = Se havera mudanca no SRA e se ela foi efetivada                                         ³
						//³ Quando transferencia C.Custo/Filial e Empresa com Cgc Diferente fica posicionado no Funcionario     ³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						IF ( lGp180Tra )
							ExecBlock( "GP180TRA" , .F. , .F. )
						EndIF

					End Sequence

				End Transaction
				If !lEmpDif .And. lIntegDef
					FwIntegdef("GPEA180")
				EndIf

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Realiza a gravacao do responsavel no arquivo utilizado  |
				//|pelos modulos do Quality Celerina, caso haja integracao.|
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				IF FindFunction("QT_QUALITY")
					QT_QUALITY(cFilDe,cEmpAnt,cMatDe,cCcDe,cFilAte,cEmpAte,cMatAte,cCcuAte,dDataTra)
				Endif

				// INTEGRACAO MEDICINA E SEGURANCA DO TRABALHO
				If  lMdtGPE .And. FindFunction("MdtTransFicha") .And. (lEmpDif .Or. lFilDif .Or. lMatDif .Or. lCcDif .Or. lDeptoDif .Or. lProcDif)
					aAreaSRA  := SRA->( GetArea() )
					MdtTransFicha(cEmpAnt, cEmpAte, cFilDe, cFilAte,  cMatDe, cMatAte, cCcDe, cCcuAte, cDeptoDe, cDeptoAte)
					If lMdtAdic .And. lGerouXml
						If FindFunction("MDT180AGL") .And. SRJ->( ColumnPos( "RJ_CUMADIC" ) ) > 0 .And. Posicione( "SRJ" , 1 , xFilial( "SRJ" ) + SRA->RA_CODFUNC , "RJ_CUMADIC" ) == "2"
							MDT180AGL( cMatDe, "", cFilDif )
						ElseIf FindFunction("MDT180INT")
						 	MDT180INT( cMatDe, "", .F., 4, cFilAnt )//Preenchimento dos campos de Insalubridade e periculosidade da SRA
						EndIf
					EndIf
					If lEmpDif
						MDTChgEmp( {"SRA","SR8","SQ3","SRJ", "SQB","CTT", 'V3F', 'V5Y', 'C87', 'C92', 'C9V'}, cEmpAte, __cEmpAnte )
					EndIf
					RestArea(aAreaSRA)
				Endif

				// INTEGRACAO MANUTENCAO DE ATIVOS
				IF FindFunction("MNTTRANST1")
					DbSelectArea("ST1")
					DbSetOrder(1)
					IF DbSeek(cFilDe+cMatDe)
						MNTTRANST1(cEmpAnt, cEmpAte,cFilDe, cFilAte,  cMatDe, cMatAte, cCcDe, cCcuAte)
					EndIF
				EndIF

				//Integração com Gestão de Serviços
				If lInteRHAA1
					DbSelectArea("AA1")
					AA1->(DbSetOrder(7))

					If AA1->(DbSeek(cAA1Fil + cMatDe + cFilDe))
						TxTransfAA1(cEmpAnt, cEmpAte,cFilDe, cFilAte,  cMatDe, cMatAte, cCcDe, cCcuAte)
					EndIf

				EndIf

				// Integração com o módulo Gestão de Transportes - SIGATMS
				If lIntTMS .And. FindFunction("A040AtuMat")
					A040AtuMat(cFilDe,cMatDe,cFilAte,cMatAte)
				EndIf

				nTransfEfetuada ++

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Adiciona o Log de transferencia por funcionario - Dados Transferencia |
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If !lRobo
					If (nPosLog := aScan( oGetSRA1:aCols , { |x| x[_FILIAL]+x[_MATRIC] == cFilDe+cMatDe .And. (x[_COLBMP] == "BR_VERDE" .OR. x[_COLBMP] == "BR_AZUL")} )) > 0

						aAdd(aLogTransf," ")
						aAdd(aLogTransf,STR0179 + " " + oGetSRA1:aCols[nPosLog,_MATRIC ]+ "-" + oGetSRA1:aCols[nPosLog,_NOME ])	// "Funcionario:"
						aAdd(aLogTransf," ")

						If !Empty(cMsgLogXML)
							aAdd(aLogTransf, cMsgLogXML )
							aAdd(aLogTransf," ")
						EndIf

						If lDifDtSPF
							// "Existe troca de turno com data posterior a data de transferência para o funcionário." ##
							// "Esse processo de envio de eventos extemporâneos para o eSocial não é tratado pelo Protheus."
							aAdd(aLogTransf, OemToAnsi(STR0324) + CRLF + OemToAnsi(STR0325))
							aAdd(aLogTransf, " ")
						Endif

						For nColuna := 1 to nLogHeader
							// Não loga campos referente a mudança de titularidade
							If 	oGetSRA1:aCols[ nPosLog ][nColuna] <> oGetSRA2:aCols[ nPosLog ][nColuna] .And. nColuna <> _COLBMP .And.;
									! oGetSRA1:aHeader[nColuna,2] $ "QB_RETTIT,QB_SUBTIT,QB_FILTIT,QB_MATTIT,QB_NOMTIT"
								aAdd(aLogTransf,Padr(oGetSRA1:aHeader[nColuna,1],12)+ " "+STR0180+" " + Padr(AllTrim(oGetSRA1:aCols[ nPosLog ][nColuna]),50)+" "+STR0181+" " + Padr(AllTrim(oGetSRA2:aCols[ nPosLog ][nColuna]),50))	// "De:" ### "Para:"
							Endif
						Next
						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³Adiciona o Log de transferencia por funcionario - Dados Cadastro      |
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						For nColuna := 3 to nLog1Header
							// Não loga campos referente a mudança de titularidade
							If oGetSRA11:aCols[ nPosLog ][nColuna] <> oGetSRA21:aCols[ nPosLog ][nColuna] .And.;
								! oGetSRA11:aHeader[nColuna,2] $ "QB_RETTIT,QB_SUBTIT,QB_FILTIT,QB_MATTIT,QB_NOMTIT"
								aAdd(aLogTransf,Padr(oGetSRA11:aHeader[nColuna,1],12)+ " "+STR0180+" " + Padr(AllTrim(alltochar(oGetSRA11:aCols[ nPosLog ][nColuna])),50)+" "+STR0181+" "+ Padr(AllTrim(alltochar(oGetSRA21:aCols[ nPosLog ][nColuna])),50))	// "De:" ### "Para:"
							Endif
						Next
					Endif
				Else
					If (nPosLog := aScan( aSvTransfCols , { |x| x[_FILIAL]+x[_MATRIC] == cFilDe+cMatDe .And. (x[_COLBMP] == "BR_VERDE" .OR. x[_COLBMP] == "BR_AZUL")} )) > 0

						aAdd(aLogTransf," ")
						aAdd(aLogTransf,STR0179 + " " + aSvTransfCols[nPosLog,_MATRIC ]+ "-" + aSvTransfCols[nPosLog,_NOME ])	// "Funcionario:"
						aAdd(aLogTransf," ")

							If !Empty(cMsgLogXML)
								aAdd(aLogTransf, cMsgLogXML )
								aAdd(aLogTransf," ")
							EndIf

						For nColuna := 1 to nLogHeader
							// Não loga campos referente a mudança de titularidade
							If 	aSvTransfCols[ nPosLog ][nColuna] <> aTransHeader[ nPosLog ][nColuna] .And. nColuna <> _COLBMP .And.;
									! aTransHeader[nColuna,2] $ "QB_RETTIT,QB_SUBTIT,QB_FILTIT,QB_MATTIT,QB_NOMTIT"
								aAdd(aLogTransf,Padr(aTransHeader[nColuna,1],12)+ " "+STR0180+" " + Padr(AllTrim(aSvTransfCols[ nPosLog ][nColuna]),50)+" "+STR0181+" " + Padr(AllTrim(oGetSRA2:aCols[ nPosLog ][nColuna]),50))	// "De:" ### "Para:"
							Endif
						Next
						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³Adiciona o Log de transferencia por funcionario - Dados Cadastro      |
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						For nColuna := 3 to nLog1Header
							// Não loga campos referente a mudança de titularidade
							If aSv1TransfCols[ nPosLog ][nColuna] <> aTransf1Cols[ nPosLog ][nColuna] .And.;
								! aTransf1Header[nColuna,2] $ "QB_RETTIT,QB_SUBTIT,QB_FILTIT,QB_MATTIT,QB_NOMTIT"
								aAdd(aLogTransf,Padr(aTransf1Header[nColuna,1],12)+ " "+STR0180+" " + Padr(AllTrim(alltochar(aSv1TransfCols[ nPosLog ][nColuna])),50)+" "+STR0181+" "+ Padr(AllTrim(alltochar(aTransf1Cols[ nPosLog ][nColuna])),50))	// "De:" ### "Para:"
							Endif
						Next
					Endif
				Endif
			Endif
		Next nX

		FWSFClearCache( .T., .T. )

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Retorna todos os filtros retirados ao fim do processo de 	  ³
		//³ Transferencia												           ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		SPFilTerOff({"SRA","SRB","SRC","SRD","SRF","SRG","SRH","SRK","SRO","SRR","SRS","SRQ","SRT","SR0","SR7","SR3","SR8","SR9","RG1","RCP","RCR","RGB","RFX"}, .F. )

	End Sequence

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Verificando o Relacionamento no RDZ/RD0                     ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	IF ( ( nLoops := Len( aSraUpdRelRd0 ) ) > 0 )

		If !lRobo
			BarGauge1Set( nLoops )
			BarGauge2Set( nLoops )
		Endif

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Fecha o SRA para Trabalhar com dois SRA's                   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		SRA->( dbCloseArea() )
		IF ChkFile( "SRA" , NIL , "SRAORIG" )
			SRAORIG->( dbSetOrder( 1 ) )
			nSraOrder := SRAORIG->( IndexOrd() )
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Abre o arquivo da Empresa Destino                           ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			EmpChangeTable( "SRA" , cEmpAte , __cSvEmpAnt , nSraOrder )
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Monta Bloco Para Atualizacao dos Relacionamentos            ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			bSraUpdRelRd0 := { || SraUpdRelRd0(;
													nSraOrder ,;
													aSraUpdRelRd0[ nLoop , 1 ],;
													aSraUpdRelRd0[ nLoop , 2 ],;
													aSraUpdRelRd0[ nLoop , 3 ],;
													nLoops;
												);
							}
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Processa para Todos os Funcionarios que possuem Relacionamen³
			//³tos														                ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			For nLoop := 1 To nLoops
				Eval( bSraUpdRelRd0 )
			Next nLoop
		EndIF
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Fecha o SRAORIG que sera Reaberto como SRA					    ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		IF ( Select( "SRAORIG" ) > 0 )
			SRAORIG->( dbCloseArea() )
		EndIF
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Restaura o arquivo da Empresa Atual                         ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		EmpChangeTable( "SRA" , __cSvEmpAnt , cEmpAte , nSraOrder )
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Restaura o SRA                                              ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		IF ( Select( "SRA" ) == 0 )
			ChkFile( "SRA" )
		EndIF

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Finaliza Filtro da Transfrencia Em Lote                                  ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		EndFilBrw( "SRA" , aNewIndexSRA )

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Restaurando Filtro da Transfrencia Em Lote                               ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		SRA->( Eval( bNewFiltroBrw ) )
	EndIF

	//--Fecha os arquivos abertos que nao se referem ao Modulo
	nLoops := Len( aFilesOpen )
	For nLoop := 1 To nLoops
		( aFilesOpen[nLoop] )->( dbCloseArea() )
	Next nLoop

	//--Fecha os arquivos da empresa Destino
	If ( lDifEmp  )
		nLoops := Len(aFilesTransf)
		For nLoop := 1 To nLoops
			fFecEmpresa( aFilesTransf[nLoop,1] )
		Next nLoop
	Endif

	//--Se usa numeracao automatica guarda ou nao o codigo gerado
	If lCtrAutoMat .And. nTransfEfetuada > 0
		ConfirmSX8()
	Else
		RollBackSX8()
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ log das transferencias efetuadas                                         ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lGestPubl
		aAdd( aLogTransf , OemToAnsi(STR0266) + Strzero(nTransfSolicitada,5) ) // "Total de transferencias solicitadas : "
		aAdd( aLogTransf , OemToAnsi(STR0267) + Strzero(nTransfEfetuada,5) )   // "Total de transferencias efetuadas   : "
	Else
			aAdd( aLogTransf , OemToAnsi(STR0152) + Strzero(nTransfSolicitada,5) )	// "Total de transferencias solicitadas : "
			aAdd( aLogTransf , OemToAnsi(STR0153) + Strzero(nTransfEfetuada,5) ) 	// "Total de transferencias efetuadas   : "
	Endif
	If nTransfEfetuada > 0
		aAdd(aLogTransf," ")
		aAdd(aLogTransf,STR0183) // "Arquivos que foram transferidos"
		aAdd(aLogTransf," ")
		For nX := 1 to Len(aFilesTransf)
			If aFileReg[nX][6] .And. aFileReg[nX][7]
			aAdd(aLogTransf,aFilesTransf[nX, 1]+ " - " + fDesc( "SX2" , aFilesTransf[nX, 1], "X2_NOME") )
			EndIf
		Next
	Endif
	If (nTransfSolicitada <> nTransfEfetuada)
		If Len(aLogTransf) > 0 .And. lRobo
			For nPos:= 1 to Len(aLogTransf)
				AutoGrLog(aLogTransf[nPos])
			Next
		EndIf
	EndIf
Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³gp180LinOk   ºAutor  ³Microsiga           º Data ³  03/18/08   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³                                                               º±±
±±º          ³                                                               º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                            º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function gp180LinOk(oBrowse)

Local aArea			:= GetArea()
Local lRetOk		:= .T.
Local nLenaHeader	:= IIF(!lRobo , Len(oGetSRA2:aHeader) + 1 , Len(aTransfHeader) + 1)
Local lMatDupl		:= .F.
Local cMsg			:= ""
Local cProcOr		:= ""
Local cTpPgt		:= ""
Local nTpPgt		:= IIF(!lRobo , GdFieldPos("RA_TIPOPGT", oGetSRA21:aHeader) , GdFieldPos("RA_TIPOPGT", aTransf1Header) )
Local nPosTpAlt		:= IIF(!lRobo , GdFieldPos("RA_TIPOALT", oGetSra21:aHeader) , GdFieldPos("RA_TIPOALT", aTransf1Header) )
Local nPosDtAlt		:= IIF(!lRobo , GdFieldPos("RA_DATAALT", oGetSra21:aHeader) , GdFieldPos("RA_DATAALT", aTransf1Header) )
Local nPosSalAlt	:= IIF(!lRobo , GdFieldPos("RA_SALARIO", oGetSra21:aHeader) , GdFieldPos("RA_SALARIO", aTransf1Header) )

Local nPosItem 		:= IIF(!lRobo , GdfieldPos("RA_ITEM"   , oGetSRA2:aHeader), GdfieldPos("RA_ITEM"   , aTransfHeader) )
Local nPosClvl		:= IIF(!lRobo , GdfieldPos("RA_CLVL"   , oGetSRA2:aHeader), GdfieldPos("RA_CLVL"   , aTransfHeader) )

Local sCond			:= IIF(!lRobo , oGetSRA2:aCols[oGetSRA2:oBrowse:nAt,nLenaHeader] , aTransfCols[Len(aTransfCols),nLenaHeader])
Local sConfFil		:= IIF(!lRobo , oGetSRA2:aCols[oGetSRA2:oBrowse:nAt,_FILIAL] , aTransfCols[Len(aTransfCols),_FILIAL])
Local sConCC		:= IIF(!lRobo , oGetSRA2:aCols[oGetSRA2:oBrowse:nAt,_CCUSTO] , aTransfCols[Len(aTransfCols),_CCUSTO])
Local sConDepto		:= IIF(!lRobo , oGetSRA2:aCols[oGetSRA2:oBrowse:nAt,_DEPTO]	 , aTransfCols[Len(aTransfCols),_DEPTO])
Local sConPosto		:= IIF(!lRobo , oGetSRA2:aCols[oGetSRA2:oBrowse:nAt,_POSTO]	 , aTransfCols[Len(aTransfCols),_POSTO])
Local sConProc		:= IIF(!lRobo , oGetSRA2:aCols[oGetSRA2:oBrowse:nAt,_PROCES] , aTransfCols[Len(aTransfCols),_PROCES])
Local lGp180VDpto	:= ExistBlock("GP180VDP")

Private	lGp010Auto := .F.

_CITEM := Iif(nPosItem > 0, nPosItem, _CITEM)
_CCLVL := Iif(nPosClvl > 0, nPosClvl, _CCLVL)

	Begin Sequence

		IF !(sCond)

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Verifica se a Filial Digitada eh Valida					       ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			IF !(lRetOk:= !Empty(sConfFil))
				Help(" ",1,"A180NFIL") 			   			//-- Filial Informada como Destino não existe
				Break
			EndIF

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Centro de Custo nao Pode Estar Vazio                       ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			IF !(lRetOk:=!Empty(sConCC))
				Help(" ",1,"A180CCNEX")  					//--  Centro de custo não cadastrado.
				Break
			EndIF

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Departamento nao Pode Estar Vazio Quando SIGAORG Estiver em Uso ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			IF cOrgCfg == "1" .And. !(lRetOk:=!Empty(sConDepto))
				Help(" ",1,"A180DEPTONEX")					//-- Departamento informado invalido ou nao está cadastrado
				Break
			EndIF

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Posto nao Pode Estar Vazio                                 ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If (cOrgCfg == "1")
				If !lRobo
					If lGp180VDpto .And. !ExecBlock("GP180VDP", .F., .F., {oGetSRA2:oBrowse:nAt, oGetSRA2:aCols})
						lRetOk := .F.
						Break
					EndIf

					If !lGp180VDpto .And. !fVldDepPosto(oGetSRA2:oBrowse:nAt)
						lRetOk := .F.
						Break
					EndIf
				Endif
			EndIF

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Codigo do Processo nao Pode Estar Vazio                    ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			IF !(lRetOk:=!Empty(sConProc))
				Help(" ",1,"A180PROCNEX") 					//-- "Processo informado invalido ou nao está cadastrado
				Break
			EndIF

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Item Contabil nao Pode Estar Vazio                         ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If cItemClvl == "1"
				IF !lRobo .And. !(lRetOk:=!Empty(oGetSRA2:aCols[oGetSRA2:oBrowse:nAt,_CITEM]))
					Help(" ",1,"A180ITEMNEX")  					//--  Item Contabil não cadastrado.
					Break
				ElseIf lRobo .And. !(lRetOk:=!Empty(aTransfCols[Len(aTransfCols),_CITEM]))
					Break
				EndIF
			EndIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Classe de Valor nao Pode Estar Vazio                       ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If cItemClvl == "1"
				IF !lRobo
					IF !(lRetOk:=!Empty(oGetSRA2:aCols[oGetSRA2:oBrowse:nAt,_CCLVL]))
						Help(" ",1,"A180CLVLNEX")  					//--  Classe de Valor não cadastrado.
						Break
					EndIf
				ElseIf lRobo .And. !(lRetOk:=!Empty(aTransfCols[Len(aTransfCols),_CCLVL]))
					Break
				EndIF
			EndIf

			//Validações matrícula - em tela ou automática individual
			If !lRobo .And. !ConsMat( oGetSRA2:aCols, oGetSRA2:nAt );
			.Or. ( lRobo .And. Len(aTransfCols) == 1 .And. !ConsMat( aTransfCols, Len(aTransfCols) ))
				lRetOk := .F.
				Break
			EndIf

			dbSelectArea("SQB")
			dbSetOrder(1)

			If !lRobo
				dbSeek(xFilial("SQB",oGetSRA2:aCols[oGetSRA2:oBrowse:nAt,_FILIAL]) + oGetSRA2:aCols[oGetSRA2:oBrowse:nAt,_DEPTO])
			Else
				dbSeek(xFilial("SQB",aTransfCols[Len(aTransfCols),_FILIAL]) + aTransfCols[Len(aTransfCols),_DEPTO])
			Endif

			If !Empty(SQB->QB_CC) .and. ( SQB->QB_CC <> IIF ( !lRobo , oGetSRA2:aCols[oGetSRA2:oBrowse:nAt,_CCUSTO] , aTransfCols[Len(aTransfCols),_CCUSTO]) )
				lConsDptoOk	:= .F.
				MsgAlert( STR0205 ) //"Departamento possui centro de custo diferente do centro de custos do funcionário"
			EndIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Se empresa diferente Verifica se nao duplica matricula     ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If ( cEmpAte # __cSvEmpAnt )
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Se nao Conseguiu Abrir os Arquivos da Empresa Destino      ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				IF !( fAbrEmpresa("SRA",1) )
					lRet := .F.
					Break
				EndIF
				IF !lRobo .AND. ("GPESRA")->( dbSeek( RHTamFilial(oGetSRA2:aCols[oGetSRA2:oBrowse:nAt,_FILIAL], oGetSRA2:aCols[oGetSRA2:oBrowse:nAt,_EMPRES]) + oGetSRA2:aCols[oGetSRA2:oBrowse:nAt,_MATRIC] ) ) .AND.  !lReutMat  //Neste Ponto __cFil jah foi atualizado pela fAbrEmpresa()
					If lReutMat
						// Valida integridade de cálculo - Transferencia para o mesmo Processo e/ou Tipo de Pagamento
						cProcOr	:= SRA->RA_PROCES
						cTpPgt		:= SRA->RA_TIPOPGT
						If (oGetSRA2:aCols[oGetSRA2:oBrowse:nAt,_PROCES] <> cProcOr) .Or.; // Processo distintos
						If(nTpPgt > 0, oGetSRA21:aCols[oGetSRA21:oBrowse:nAt,nTpPgt] <> cTpPgt, .F.) // Tipo de Pagamento distintos

							If lGestPubl
								MsgAlert( OemToAnsi(STR0269) , OemToAnsi(STR0268) )	//"Não é permitida a transferência para o mesmo código de Matrícula ao serem alterados campos que referenciam o o procedimento de cálculo do Funcionário(Processo e/ou Tipo de Pagamento)."###"Transferencia de Matricula"
							Else
								MsgAlert( OemToAnsi(STR0209) , OemToAnsi(STR0034) )	//"Não é permitida a transferência para o mesmo código de Matrícula ao serem alterados campos que referenciam o o procedimento de cálculo do Funcionário(Processo e/ou Tipo de Pagamento)."###"Transferencia de Matricula"
							Endif
							lRetOk := .F.
							Break
						EndIf
					Else
						lMatDupl := .T.
					EndIf
				ELSEIF lRobo .AND. ("GPESRA")->( dbSeek( RHTamFilial(aTransfCols[Len(aTransfCols),_NFILIA],aTransfCols[Len(aTransfCols),_NEMPRE]) + aTransfCols[Len(aTransfCols),_MATRIC] ) ) .AND.  !lReutMat  //Neste Ponto __cFil jah foi atualizado pela fAbrEmpresa()
					If lReutMat
						// Valida integridade de cálculo - Transferencia para o mesmo Processo e/ou Tipo de Pagamento
						cProcOr	:= SRA->RA_PROCES
						cTpPgt		:= SRA->RA_TIPOPGT
						If (aTransfCols[Len(aTransfCols),_DPROCE] <> cProcOr) .Or.; // Processo distintos
						If(nTpPgt > 0, aTransfCols[Len(aTransfCols),nTpPgt] <> cTpPgt, .F.) // Tipo de Pagamento distintos
							Break	//"Não é permitida a transferência para o mesmo código de Matrícula ao serem alterados campos que referenciam o o procedimento de cálculo do Funcionário(Processo e/ou Tipo de Pagamento)."###"Transferencia de Matricula"
							lRetOk := .F.
						EndIf
					Else
						lMatDupl := .T.
					EndIf
				EndIF
				fFecEmpresa("SRA")
				DbSelectArea( "SRA" )
			ElseIf ( cFilAte # __cSvFilAnt )
				nPosRecno := SRA->( Recno() )
				IF !lRobo .AND. SRA->( dbSeek( oGetSRA2:aCols[oGetSRA2:oBrowse:nAt,_FILIAL] + oGetSRA2:aCols[oGetSRA2:oBrowse:nAt,_MATRIC] ) ) //Neste Ponto __cFil terah o conteudo de cFilAte ou Space(02)
					If lReutMat
						// Valida integridade de cálculo - Transferencia para o mesmo Processo e/ou Tipo de Pagamento
						cProcOr	:= SRA->RA_PROCES
						cTpPgt		:= SRA->RA_TIPOPGT
						If (oGetSRA2:aCols[oGetSRA2:oBrowse:nAt,_PROCES] <> cProcOr) .Or.; // Processo distintos
						If(nTpPgt > 0, oGetSRA21:aCols[oGetSRA21:oBrowse:nAt,nTpPgt] <> cTpPgt, .F.) // Tipo de Pagamento distintos

							If lGestPubl
								MsgAlert( OemToAnsi(STR0269) , OemToAnsi(STR0268) )	//"Não é permitida a transferência para o mesmo código de Matrícula ao serem alterados campos que referenciam o o procedimento de cálculo do Funcionário(Processo e/ou Tipo de Pagamento)."###"Transferencia de Matricula"
							Else
								MsgAlert( OemToAnsi(STR0209) , OemToAnsi(STR0034) )	//"Não é permitida a transferência para o mesmo código de Matrícula ao serem alterados campos que referenciam o o procedimento de cálculo do Funcionário(Processo e/ou Tipo de Pagamento)."###"Transferencia de Matricula"
							Endif
							lRetOk := .F.
							Break
						EndIf
					Else
						lMatDupl := .T.
					EndIf
				ELSEIF lRobo .AND. SRA->( dbSeek( aTransfCols[Len(aTransfCols),_FILIAL] + aTransfCols[Len(aTransfCols),_MATRIC] ) ) //Neste Ponto __cFil terah o conteudo de cFilAte ou Space(02)
					If lReutMat
						// Valida integridade de cálculo - Transferencia para o mesmo Processo e/ou Tipo de Pagamento
						cProcOr	:= SRA->RA_PROCES
						cTpPgt		:= SRA->RA_TIPOPGT
						If (aTransfCols[Len(aTransfCols),_PROCES] <> cProcOr) .Or.; // Processo distintos
						If(nTpPgt > 0, aTransfCols[Len(aTransfCols),nTpPgt] <> cTpPgt, .F.) // Tipo de Pagamento distintos
						//"Não é permitida a transferência para o mesmo código de Matrícula ao serem alterados campos que referenciam o o procedimento de cálculo do Funcionário(Processo e/ou Tipo de Pagamento)."###"Transferencia de Matricula"
							lRetOk := .F.
							Break
						EndIf
					Else
						lMatDupl := .T.
					EndIf
				EndIF
				SRA->(DbGoto(nPosRecno))
			Endif
			If lMatDupl
				If(!lRobo)
					cMsg :=  oGetSRA2:aCols[oGetSRA2:oBrowse:nAt,_MATRIC] + " <=> " + STR0033	//"Ja' existe Funcionario com a Matricula Digitada. Informe nova Matricula"
					MsgAlert( cMsg , OemToAnsi(STR0034) )	//"Transferˆncia de Matricula"
				Else
					Break
				Endif
			EndIf
			lRetOk := !lMatDupl

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Abre as tabelas da Empresa Destino                         ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If !lRobo
				ChangeNew(uAliasNewEmp, oGetSRA2:aCols[oGetSRA2:oBrowse:nAt,_EMPRES] , oGetSRA2:aCols[oGetSRA2:oBrowse:nAt,_FILIAL ])
			Else
				ChangeNew(uAliasNewEmp, aTransfCols[Len(aTransfCols),_EMPRES] , aTransfCols[Len(aTransfCols),_FILIAL ])
			Endif

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Grava alteracoes no aSRACols                                             ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			fSvMemToCols( IIF ( !lRobo , oGetSRA2:oBrowse:nAt  , Len(aTransfCols) ))

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Consistencia do Campo alt.Salarial /Tipo Alt. Salarial      ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If ascan (aTransf1Header,{|x| Alltrim(x[2]) $ "RA_SALARIO*RA_CODFUNC*RA_ANTEAUM*RA_CARGO"}) > 0 .And. nPosDtAlt > 0 .And. nPosTpAlt > 0 .And. nPosSalAlt > 0
				If !lRobo
					If (oGetSRA2:aCols[oGetSRA2:oBrowse:nAt,_EMPRES] == oGetSRA1:aCols[oGetSRA2:oBrowse:nAt,_EMPRES] .And. oGetSRA2:aCols[oGetSRA2:oBrowse:nAt,_FILIAL] == oGetSRA1:aCols[oGetSRA2:oBrowse:nAt,_FILIAL] .AND. SRA->( dbSeek( oGetSRA2:aCols[oGetSRA2:oBrowse:nAt,_FILIAL] + oGetSRA2:aCols[oGetSRA2:oBrowse:nAt,_MATRIC] ) )  .and. !(Gp010AltSal()) ) .Or. ( (oGetSRA2:aCols[oGetSRA2:oBrowse:nAt,_EMPRES] != oGetSRA1:aCols[oGetSRA2:oBrowse:nAt,_EMPRES] .And. oGetSRA11:aCols[oGetSRA2:oBrowse:nAt,nPosSalAlt] != oGetSRA21:aCols[oGetSRA2:oBrowse:nAt,nPosSalAlt]  .And.  ( Empty(oGetSRA21:aCols[oGetSRA2:oBrowse:nAt,nPosDtAlt]) .Or. Empty(oGetSRA21:aCols[oGetSRA2:oBrowse:nAt,nPosTpAlt]))))
						lRetOk:= .F.
						If oGetSRA2:aCols[oGetSRA2:oBrowse:nAt,_EMPRES] != oGetSRA1:aCols[oGetSRA2:oBrowse:nAt,_EMPRES]
							Help("",1,"GPTIPOALT")
						EndIf
						Break

					// Se a data de alteração salarial estiver preenchida, verifica se ela é menor que a data escolhida para a transferência
					// (não faz sentido a alteração salarial feita na transferência ocorrer antes da data de transferência)
					ElseIf (!Empty(oGetSRA21:aCols[oGetSRA2:oBrowse:nAt][nPosDtAlt]) .and. Type("dDataTra") == "D" .and. oGetSRA21:aCols[oGetSRA2:oBrowse:nAt][nPosDtAlt] < dDataTra)
						// "Atenção" | "A data de alteração salarial não pode ser inferior à data de tranferência." | "Rever o conteúdo da data de alteração salarial."
						Help(NIL, NIL, STR0210, NIL, STR0359, 1, 0, NIL, NIL, NIL, NIL, NIL, {STR0360})
						lRetOk := .F.
						BREAK
					EndIf
				ELSEIF  (aTransfCols[Len(aTransfCols),_NEMPRE] == aTransfCols[Len(aTransfCols),_EMPRES] .And. aTransfCols[Len(aTransfCols),_NFILIA] == aTransfCols[Len(aTransfCols),_FILIAL] .AND. SRA->( dbSeek( aTransfCols[Len(aTransfCols),_NFILIA] + aTransfCols[Len(aTransfCols),_MATRIC] ) )  .and. !(Gp010AltSal()) ) .Or. ( (aTransfCols[Len(aTransfCols),_NEMPRE] != aTransfCols[Len(aTransfCols),_EMPRES] .And. aTransfCols[Len(aTransfCols),nPosSalAlt] != aTransfCols[Len(aTransfCols),nPosSalAlt]  .And.  ( Empty(aTransfCols[Len(aTransfCols),nPosDtAlt]) .Or. Empty(aTransfCols[Len(aTransfCols),nPosTpAlt]))))
				//ELSEIf aTransfCols[Len(aTransfCols),_NEMPRE] == aTransfCols[Len(aTransfCols),_EMPRES] .And. aTransfCols[Len(aTransfCols),_NFILIA] == aTransfCols[Len(aTransfCols),_FILIAL] .AND. aTransfCols[Len(aTransfCols),_NFILIA] + aTransfCols[Len(aTransfCols),_MATRIC] ) )  .and. !(Gp010AltSal()) ) .Or. ( (aTransfCols[Len(aTransfCols),_NEMPRE] != aTransfCols[Len(aTransfCols),_EMPRES] .And. aTransfCols[Len(aTransfCols),nPosSalAlt] != aTransfCols[Len(aTransfCols),nPosSalAlt]  .And.  ( Empty(aTransfCols[Len(aTransfCols),nPosDtAlt]) .Or. Empty(aTransfCols[Len(aTransfCols),nPosTpAlt]))))
					lRetOk:= .F.
					Break
				Endif
			EndIf

			If cPaisLoc=="MEX"
				If!lRobo
					If !Gp010Adm(.F.,oGetSRA2:oBrowse:nAt, SRA->RA_FILIAL )
						lRetOk:= .F.
						Break
					Endif
				Else
					If !Gp010Adm(.F.,Len(aTransfCols), SRA->RA_FILIAL )
						lRetOk:= .F.
						Break
					Endif
				Endif


				If !Gp010ValSit()
					lRetOk:= .F.
					Break
				Endif

				If !Gpea010InfVal()
					lRetOk:= .F.
					Break
				Endif
			Endif

			// Atualiza o codigo da matricula no Folder Dados Cadastrais
			If lRetOk
				If !lRobo
					oGetSRA21:aCols[oGetSRA2:oBrowse:nAt,1] := oGetSRA2:aCols[oGetSRA2:oBrowse:nAt,_MATRIC]
				Else
					aTransf1Cols[Len(aTransfCols),1] := aTransfCols[Len(aTransfCols),_MATRIC]
				Endif

				If !IsBlind()
					oGetSRA21:Refresh()
				EndIf
			Endif

		Endif
	End Sequence

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Se retornou a situacao original,ajusta COLBMP               ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	fRetSitOrigem(oBrowse)

	RestArea(aArea)

Return( lRetOk )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³gp1801LinOk  ºAutor  ³IP RH - Inovacao    º Data ³  04/04/12   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Valida a linha digitada do Folder "Dados Cadastrais"           º±±
±±º          ³                                                               º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ GPEA180                                                       º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function gp1801LinOk(oBrowse)

Local aArea			:= GetArea()
Local lRetOk		   := .T.
Local nLenaHeader	:= Len(oGetSRA21:aHeader) + 1
Local nPosTpAlt		:= GdFieldPos("RA_TIPOALT", oGetSra21:aHeader )
Local nPosDtAlt		:= GdFieldPos("RA_DATAALT", oGetSra21:aHeader )
Local nPosSalAlt	:= GdFieldPos("RA_SALARIO", oGetSra21:aHeader )
Private	lGp010Auto := .F.

Begin Sequence
IF  !(oGetSRA21:aCols[oGetSRA21:oBrowse:nAt,nLenaHeader ])

 	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Abre as tabelas da Empresa Destino                         ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	ChangeNew(uAliasNewEmp, oGetSRA2:aCols[oGetSRA21:oBrowse:nAt,_EMPRES] , oGetSRA2:aCols[oGetSRA21:oBrowse:nAt,_FILIAL ]  )

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Grava alteracoes no aSRACols                                             ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	fSvMemToCols(oGetSRA21:oBrowse:nAt)

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Consistencia do Campo alt.Salarial /Tipo Alt. Salarial      ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
   	If ascan (aTransf1Header,{|x| Alltrim(x[2]) $ "RA_SALARIO*RA_CODFUNC*RA_ANTEAUM*RA_CARGO"}) > 0 .And. nPosDtAlt > 0 .And. nPosTpAlt > 0 .And. nPosSalAlt > 0
   		If (oGetSRA2:aCols[oGetSRA2:oBrowse:nAt,_EMPRES] == oGetSRA1:aCols[oGetSRA2:oBrowse:nAt,_EMPRES] .And. oGetSRA2:aCols[oGetSRA2:oBrowse:nAt,_FILIAL] == oGetSRA1:aCols[oGetSRA2:oBrowse:nAt,_FILIAL] .AND. SRA->( dbSeek( oGetSRA2:aCols[oGetSRA2:oBrowse:nAt,_FILIAL] + oGetSRA2:aCols[oGetSRA2:oBrowse:nAt,_MATRIC] ) )  .and. !(Gp010AltSal()) ) .Or. ( (oGetSRA2:aCols[oGetSRA2:oBrowse:nAt,_EMPRES] != oGetSRA1:aCols[oGetSRA2:oBrowse:nAt,_EMPRES] .And. oGetSRA11:aCols[oGetSRA2:oBrowse:nAt,nPosSalAlt] != oGetSRA21:aCols[oGetSRA2:oBrowse:nAt,nPosSalAlt]  .And.  ( Empty(oGetSRA21:aCols[oGetSRA2:oBrowse:nAt,nPosDtAlt]) .Or. Empty(oGetSRA21:aCols[oGetSRA2:oBrowse:nAt,nPosTpAlt]))))
   			lRetOk:= .F.
   			If oGetSRA2:aCols[oGetSRA2:oBrowse:nAt,_EMPRES] != oGetSRA1:aCols[oGetSRA2:oBrowse:nAt,_EMPRES]
				Help("",1,"GPTIPOALT")
			EndIf
   			Break

		// Se a data de alteração salarial estiver preenchida, verifica se ela é menor que a data escolhida para a transferência
		// (não faz sentido a alteração salarial feita na transferência ocorrer antes da data de transferência)
		ElseIf (!Empty(oGetSRA21:aCols[oGetSRA2:oBrowse:nAt][nPosDtAlt]) .and. Type("dDataTra") == "D" .and. oGetSRA21:aCols[oGetSRA2:oBrowse:nAt][nPosDtAlt] < dDataTra)
			// "Atenção" | "A data de alteração salarial não pode ser inferior à data de tranferência." | "Rever o conteúdo da data de alteração salarial."
			Help(NIL, NIL, STR0210, NIL, STR0359, 1, 0, NIL, NIL, NIL, NIL, NIL, {STR0360})
			lRetOk := .F.
			BREAK
   		EndIf
	Endif

	If cPaisLoc=="MEX"

		If !Gp010Adm(.F.,oGetSRA21:oBrowse:nAt, SRA->RA_FILIAL )
			lRetOk:= .F.
			Break
		Endif

		If !Gp010ValSit()
			lRetOk:= .F.
			Break
		Endif

		If !Gpea010InfVal()
			lRetOk:= .F.
			Break
		Endif
	Endif
Endif
End Sequence

RestArea(aArea)
Return( lRetOk )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³ fVldDepPosto  ºAutor  ³Microsiga           º Data ³  05/27/08   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³                                                                 º±±
±±º          ³                                                                 º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                              º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function fVldDepPosto(nAT )

Local aArea				:= GetArea()
Local cAliasRCL    		:= "RCL"
Local lConsPostoOk		:= .T.

If Empty( oGetSRA2:aCols[nAt,_POSTO ])
	Help(" ",1,"A180POSTONEX") 					//-- Posto informado invalido ou nao está cadastrado
	Return (.F.)
Else
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Valida o Departamento x posto                              ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	IF ( __cSvEmpAnt # oGetSRA2:aCols[nAt,_EMPRES ])
		IF !( lConsPostoOk := fAbrEmpresa("RCL", 1 ) )
			Break
		EndIF
		cAliasRCL	:= "GPERCL"
		lEmpDif	    :=.T.
		__cFil :=	totvs.framework.company.xEmpFil("RCL", oGetSRA2:aCols[nAt,_EMPRES ], oGetSRA2:aCols[nAt,_FILIAL ])
	Else
		dbSelectArea( "RCL" )
		__cFil := xFilial( "RCL" , oGetSRA2:aCols[nAt,_FILIAL ] )
	EndIF

	DbSelectArea(cAliasRCL)
	DbSetOrder( 1 )

	IF !( lConsPostoOk := (( cAliasRCL )->( dbSeek( __cFil + oGetSRA2:aCols[nAt,_DEPTO ] +  oGetSRA2:aCols[nAt,_POSTO ] , .F. ) ) ) )
		Help(" ",1,"A180POSTONEX") 																//-- Posto informado invalido ou nao cadatrado.
		Return (.F.)//Break
	EndIF

	IF ( lEmpDif )
		fFecEmpresa("RCL" )
	EndIF
Endif

RestArea(aArea)

Return( lConsPostoOk )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³gp180TudoOk  ºAutor  ³Microsiga           º Data ³  03/18/08   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³                                                               º±±
±±º          ³                                                               º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                            º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function gp180TudoOk(OBrowse)

Local nSvn
Local lOk 	:= .T.

If !lRobo
	nSvn := oBrowse:nAt
Endif

If !(gp180LinOk( oBrowse ) )
	lOk := .F.
EndIf

If !IsBlind() .And. !fGp180Ok()
	lOk := .F.
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Verifica se existe algum funcionario que não foi efetuado   ³
//³nenhum tipo de transferência                                ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lOk
	fChk_Transf()
	If lRobo
		lOk := fValidaMat(aSvTransfCols,aTransfCols)
	Else
		lOk := fValidaMat(oGetSRA1:aCols,oGetSRA2:aCols)
	EndIf
Endif

If !lRobo
	oBrowse:nAt := nSvn
Endif

If lOk
	ChangeNew(uAliasNewEmp, __cEmpAnt, __cFilAnt)
	//Retorna SX2 da empresa logada
	fOpenSx2(__cEmpAnt)
else
	If !lRobo
		ChangeNew(uAliasNewEmp, OGETSRA2:ACOLS[OGETSRA2:NAT][2], OGETSRA2:ACOLS[OGETSRA2:NAT][4])
		//Retorna SX2 da empresa destino
		fOpenSx2(OGETSRA2:ACOLS[OGETSRA2:NAT][2])
	Else
		ChangeNew(uAliasNewEmp, aTransfCols[Len(aTransfCols),_EMPRES] , aTransfCols[Len(aTransfCols),_FILIAL ])
		//Retorna SX2 da empresa destino
		fOpenSx2(aTransfCols[Len(aTransfCols),_EMPRES])
	Endif
endif

Return(lOk)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³fGp180Ok     ºAutor  ³Marcelo Silveira    º Data ³  07/11/16   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Exibe mensagem de confirmacao ao usuario antes de processar a  º±±
±±º          ³transferencia                                                  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                            º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function fGp180Ok()

	Local lRet

	//"Confirma a Transferência ?"
	//"Não deverão ser realizadas movimentações de Folha de Pagamento, como Rescisões , anteriores à Data de Transferência informada."
	//ATENÇÃO: Após a confirmação NÃO SERÁ POSSÍVEL DESFAZER ESSA OPERAÇÃO!"
	If !lRobo
		lRet := MsgNoYes( OemToAnsi(STR0017) + CRLF + CRLF + OemToAnsi(STR0285) + CRLF + CRLF + OemToAnsi(STR0212))
	Else
		lRet := .T.
	Endif

	If lFuncTransf
		If !lRobo
			lFuncTransf := MsgYesNo( OemToAnsi(STR0238) + OemToAnsi(STR0222), OemToAnsi(STR0210)) // Existem Funcionários com Status de Demitido. Deseja continuar ?
		Else
			lFuncTransf := .T.
		Endif
	Endif

Return( lRet )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³fRetSitOrigem ºAutor  ³Microsiga           º Data ³  04/10/08   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Retorna o Status original do aCols  caso nao tenha sido efetua º±±
±±º          ³ da nenhuma transferencia                                       º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                             º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function fRetSitOrigem(oBrowse)

Local lIgual    := .F.

If !lItemClvl
	If !lRobo
		If ( oGetSRA2:aCols[oBrowse:nAt,_EMPRES] = oGetSRA1:aCols[oBrowse:nAt,_EMPRES] ) .and. ;
		   ( oGetSRA2:aCols[oBrowse:nAt,_FILIAL] = oGetSRA1:aCols[oBrowse:nAt,_FILIAL] ) .and. ;
		   ( oGetSRA2:aCols[oBrowse:nAt,_CCUSTO] = oGetSRA1:aCols[oBrowse:nAt,_CCUSTO] ) .and. ;
		   ( oGetSRA2:aCols[oBrowse:nAt,_MATRIC] = oGetSRA1:aCols[oBrowse:nAt,_MATRIC] ) .and. ;
		   ( oGetSRA2:aCols[oBrowse:nAt,_DEPTO ] = oGetSRA1:aCols[oBrowse:nAt,_DEPTO ] ) .and. ;
		   ( oGetSRA2:aCols[oBrowse:nAt,_PROCES] = oGetSRA1:aCols[oBrowse:nAt,_PROCES] )

			lIgual :=  	.T.
			If (cOrgCfg == "1")
				lIgual := ( oGetSRA2:aCols[oBrowse:nAt,_POSTO  ] =  oGetSRA1:aCols[oBrowse:nAt,_POSTO] )
			Endif
		Endif
	Else
		If ( aTransfCols[Len(aTransfCols),_EMPRES] = aSvTransfCols[Len(aSvTransfCols),_EMPRES] ) .and. ;
		   ( aTransfCols[Len(aTransfCols),_FILIAL] = aSvTransfCols[Len(aSvTransfCols),_FILIAL] ) .and. ;
		   ( aTransfCols[Len(aTransfCols),_CCUSTO] = aSvTransfCols[Len(aSvTransfCols),_CCUSTO] ) .and. ;
		   ( aTransfCols[Len(aTransfCols),_MATRIC] = aSvTransfCols[Len(aSvTransfCols),_MATRIC] ) .and. ;
		   ( aTransfCols[Len(aTransfCols),_DEPTO ] = aSvTransfCols[Len(aSvTransfCols),_DEPTO ] ) .and. ;
		   ( aTransfCols[Len(aTransfCols),_PROCES] = aSvTransfCols[Len(aSvTransfCols),_PROCES] )

			lIgual :=  	.T.
			If (cOrgCfg == "1")
				lIgual := ( aTransfCols[Len(aTransfCols),_POSTO  ] =  aSvTransfCols[Len(aSvTransfCols),_POSTO] )
			Endif
		Endif
	Endif

ElseIf !lRobo
	If ( oGetSRA2:aCols[oBrowse:nAt,_EMPRES] = oGetSRA1:aCols[oBrowse:nAt,_EMPRES] ) .and. ;
	   ( oGetSRA2:aCols[oBrowse:nAt,_FILIAL] = oGetSRA1:aCols[oBrowse:nAt,_FILIAL] ) .and. ;
	   ( oGetSRA2:aCols[oBrowse:nAt,_CCUSTO] = oGetSRA1:aCols[oBrowse:nAt,_CCUSTO] ) .and. ;
	   ( oGetSRA2:aCols[oBrowse:nAt,_MATRIC] = oGetSRA1:aCols[oBrowse:nAt,_MATRIC] ) .and. ;
	   ( oGetSRA2:aCols[oBrowse:nAt,_DEPTO ] = oGetSRA1:aCols[oBrowse:nAt,_DEPTO ] ) .and. ;
	   ( oGetSRA2:aCols[oBrowse:nAt,_PROCES] = oGetSRA1:aCols[oBrowse:nAt,_PROCES] ) .and. ;
	   ( oGetSRA2:aCols[oBrowse:nAt,_CITEM ] = oGetSRA1:aCols[oBrowse:nAt,_CITEM ] ) .and. ;
       ( oGetSRA2:aCols[oBrowse:nAt,_CCLVL ] = oGetSRA1:aCols[oBrowse:nAt,_CCLVL ] )

		lIgual :=  	.T.
		If (cOrgCfg == "1")
			lIgual := ( oGetSRA2:aCols[oBrowse:nAt,_POSTO  ] =  oGetSRA1:aCols[oBrowse:nAt,_POSTO] )
		Endif
	Endif
Else
		If ( aTransfCols[Len(aTransfCols),_EMPRES] = aSvTransfCols[Len(aSvTransfCols),_EMPRES] ) .and. ;
		   ( aTransfCols[Len(aTransfCols),_FILIAL] = aSvTransfCols[Len(aSvTransfCols),_FILIAL] ) .and. ;
		   ( aTransfCols[Len(aTransfCols),_CCUSTO] = aSvTransfCols[Len(aSvTransfCols),_CCUSTO] ) .and. ;
		   ( aTransfCols[Len(aTransfCols),_MATRIC] = aSvTransfCols[Len(aSvTransfCols),_MATRIC] ) .and. ;
		   ( aTransfCols[Len(aTransfCols),_DEPTO ] = aSvTransfCols[Len(aSvTransfCols),_DEPTO ] ) .and. ;
		   ( aTransfCols[Len(aTransfCols),_PROCES] = aSvTransfCols[Len(aSvTransfCols),_PROCES] ) .and. ;
		   ( aTransfCols[Len(aTransfCols),_CITEM ] = aSvTransfCols[Len(aSvTransfCols),_CITEM ] ) .and. ;
      	   ( aTransfCols[Len(aTransfCols),_CCLVL ] = aSvTransfCols[Len(aSvTransfCols),_CCLVL ] )

			lIgual :=  	.T.
			If (cOrgCfg == "1")
				lIgual := ( aTransfCols[Len(aTransfCols),_POSTO  ] =  aSvTransfCols[Len(aSvTransfCols),_POSTO] )
			Endif
		Endif
EndIf

If lIgual
	If !lRobo
		If !(oGetSRA2:aCols[oBrowse:nAt , _COLBMP] 	= "BR_VERDE" )
			oGetSRA2:aCols[oBrowse:nAt , _COLBMP] 	:= "BR_BRANCO"
			oGetSRA1:aCols[oBrowse:nAt , _COLBMP] 	:= "BR_BRANCO"
		Endif
	Else
		If !(aTransfCols[Len(aTransfCols) , _COLBMP] 	= "BR_VERDE" )
			aTransfCols[Len(aTransfCols) , _COLBMP] 	:= "BR_BRANCO"
			aTransfCols[Len(aTransfCols) , _COLBMP] 	:= "BR_BRANCO"
		Endif
	Endif
Else
	If !lRobo
		If !(oGetSRA2:aCols[oBrowse:nAt , _COLBMP] 	= "BR_VERDE" )
			oGetSRA2:aCols[oBrowse:nAt , _COLBMP] 	:= "BR_AZUL"
			oGetSRA1:aCols[oBrowse:nAt , _COLBMP] 	:= "BR_AZUL"
		Endif
	Else
		If !(aTransfCols[Len(aTransfCols) , _COLBMP] 	= "BR_VERDE" )
			aTransfCols[Len(aTransfCols) , _COLBMP] 	:= "BR_AZUL"
			aTransfCols[Len(aTransfCols) , _COLBMP] 	:= "BR_AZUL"
		Endif
	Endif
Endif

If !IsBlind()
	oGetSRA2:Refresh()
	oGetSRA1:Refresh()
EndIf

Return(Nil)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³fChk_TransfºAutor  ³Microsiga           º Data ³  04/01/08   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³                                                             º±±
±±º          ³                                                             º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                          º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function fChk_Transf()

Local aCols_aux 	:= IIF (!lRobo , aClone(oGetSRA2:aCols) , aClone(aTransfCols))
Local lIgual 		:= .F.
Local nX			:= 0

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Verifica se houve algum tipo de transferencuia               ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
For nX:= 1 to Len( aCols_Aux )
	lIgual := .F.
	If !( aCols_aux[nX,_EMPRES] # aSvTransfCols[nX,_EMPRES] )
		If !(  aCols_aux[nX,_FILIAL] # aSvTransfCols[nX,_FILIAL] )
			If !(aCols_aux[nX,_CCUSTO] # aSvTransfCols[nX,_CCUSTO] )
				If !(aCols_aux[nX,_MATRIC] # aSvTransfCols[nX,_MATRIC] )
					If !(aCols_aux[nX,_DEPTO] # aSvTransfCols[nX,_DEPTO] )
						If  !(aCols_aux[nX,_PROCES] # aSvTransfCols[nX,_PROCES] )
							If lItemClvl
								If  !(aCols_aux[nX,_CITEM] # aSvTransfCols[nX,_CITEM] )
							 		If  !(aCols_aux[nX,_CCLVL] # aSvTransfCols[nX,_CCLVL] )
							 			lIgual:= .T.
										If (cOrgCfg == "1")
											lIgual 	:= !( aCols_aux[nX,_POSTO] # aSvTransfCols[nX,_POSTO] )
										EndIf
									EndIf
								EndIf
							Else
						 		lIgual:= .T.
								If (cOrgCfg == "1")
									lIgual 	:= !( aCols_aux[nX,_POSTO] # aSvTransfCols[nX,_POSTO] )
								Endif
							EndIf
						Endif
					Endif
				Endif
			Endif
		Endif
	Endif

	If lIgual
		aAdd( aLogTransf ,  aCols_Aux[nX,_EMPRES]+ " " + aCols_Aux[nX,_FILIAL]+ " " + aCols_Aux[nX,_MATRIC] + " - " + aCols_Aux[nX,_NOME] )
		aAdd( aLogTransf , Space(5) + OemToAnsi(STR0126) ) 						// Nao foi efetuado nenhuma solicitacao de transferencia para "
	Endif

Next nX

If !IsBlind()
	oGetSRA2:Refresh()
	oGetSRA1:Refresh()
EndIf

Return(.t.)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³fMontaHeader ºAutor  ³Microsiga           º Data ³  03/18/08   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Monta o aHeader com os campos de Empresa e campos complemen    º±±
±±º          ³tares                                                          º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                            º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function fMontaHeader(lHeadFull )

Local nUsado 		:= 1
Local cTitulo		:= ""
Local cBox		:= ""
Local cVisual		:= ""
Local cValid   	:= ""
Local cF3			:= ""
Local cPicture	:= ""
Local cWhen 		:= ""
Local nx			:= 0
Local aHeader_aux	:= {}
Local aHeader1_aux	:= {}
Local nLenaHeader	:= 0
Local nLen1aHeader	:= 0
Local lBloqMat		:= SuperGetMv("MV_BLOQMAT",NIL,.F.)

//--Utilizacao do modulo SIGAGFP (gestao de folha publica)
lGestPubl 	:= If( type("lGestPubl")=="U", if(ExistFunc("fUsaGFP"),fUsaGFP(),.f.) ,lGestPubl)

dbSelectArea("SX2")
dbseek("SRA")

dbSelectArea("SX3")
dbseek("SRA")
dbSetOrder(2)

If lHeadFull

	aFields	:= {}
	aFields1	:= {}

	aAdd( aFields , "COLBMP" )
	aAdd( aFields , "M_EMPRESA")
	aAdd( aFields , "M_NEMPRESA")
	aAdd( aFields , "RA_FILIAL" )
	aAdd( aFields , "M_NFILIAL")
	aAdd( aFields , "RA_MAT" )
	aAdd( aFields , "RA_NOME")
	aAdd( aFields , "RA_CC" )
	aAdd( aFields , "RA_DESCCC" )
	aAdd( aFields , "RA_DEPTO" )
	aAdd( aFields , "RA_DDEPTO" )
	aAdd( aFields , "RA_PROCES" )
	aAdd( aFields , "M_DPROCES" )
	aAdd( aFields , "RA_POSTO"  )
	aAdd( aFields , "M_DPOSTO"  )
	If lItemClvl
		aAdd( aFields , "RA_ITEM" )
		aAdd( aFields , "RA_CLVL" )
	EndIf

	If  lGestPubl .AND. cModulo $ "GFP*VDF" 	//Se Gestao de Folha Publica - SIGAGFP
		aAdd( aFields , "QB_RETTIT" )
		_RETTIT := Len(aFields)
		aAdd( aFields , "QB_SUBTIT" )
		_SUBTIT := Len(aFields)

		aAdd( aFields , "QB_FILTIT" )
		aAdd( aFields , "QB_MATTIT" )
		aAdd( aFields , "QB_NOMTIT" )
	EndIf

		If lTpDesl 		//Tipo de Desligamento - eSocial
			aAdd( aFields , "RE_DESL"  )
		EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Acrescenta campos Complementares segundo GpeCpoCompl.fch     ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	aAdd( aFields1 , "RA_MAT" )
	aAdd( aFields1 , "RA_NOME")
	If (cOrgCfg == "1")
		aAdd( aFields1 , "RA_CODFUNC" )
		aAdd( aFields1 , "RA_CARGO" )
		aAdd( aFields1 , "RA_SALARIO" )
		aAdd( aFields1 , "RA_TIPOALT" )
		aAdd( aFields1 , "RA_DATAALT" )
		If cPaisLoc == "MEX"
			aAdd( aFields1 , "RA_KEYLOC" )
		EndIf
	Endif
	aFields1	:= fCpoCompl()
Else
	If Len(aFields) >  10
		aFields	:= {}
		aFields1  := {}
		aAdd( aFields , "M_EMPRESA")
		aAdd( aFields , "M_NEMPRESA")
		aAdd( aFields , "RA_FILIAL" )
		aAdd( aFields , "M_NFILIAL")
		aAdd( aFields , "RA_CC" )
		aAdd( aFields , "RA_DESCCC" )
		aAdd( aFields , "RA_DEPTO" )
		aAdd( aFields , "RA_DDEPTO" )
		aAdd( aFields , "RA_PROCES" )
		aAdd( aFields , "M_DPROCES" )
		aAdd( aFields , "RA_POSTO"  )
		aAdd( aFields , "M_DPOSTO"  )

		If lItemClvl
			aAdd( aFields , "RA_ITEM" )
			aAdd( aFields , "RA_CLVL" )
		EndIf

		If  lGestPubl .AND. cModulo $ "GFP*VDF" 	//Se Gestao de Folha Publica - SIGAGFP
			aAdd( aFields , "QB_RETTIT" )
			aAdd( aFields , "QB_SUBTIT" )
			aAdd( aFields , "QB_FILTIT" )
			aAdd( aFields , "QB_MATTIT" )
			aAdd( aFields , "QB_NOMTIT" )
		Endif

	Endif
Endif

aSRAHeader	 := fAllHeader()
nLenaHeader := Len(aSRAHeader)

fAllCols()
aSvSRACols	:= aClone(aSRACols)

cConCTT		:= .F.
cConDept	:= .F.
cConProc	:= .F.
cConPosto	:= .F.
cConPeriod	:= .F.
cConNrPag	:= .F.
cConTurn	:= .F.
cConFunc	:= .F.
cConRegr	:= .F.
cConSeq		:= .F.
cConSM0		:= .F.
existF3New(@cConCTT, @cConDept, @cConProc, @cConPosto,@cConPeriod,@cConNrPag,@cConTurn,@cConFunc,@cConRegr,@cConSeq,@cConSM0)


For nX := 1 to Len(aFields)

	If ( nPos :=Ascan(aSRAHeader, {|x| alltrim(aFields[nx]) == alltrim(x[2]) }   )   ) > 0

		cTitulo := aSRAHeader[nPos,01]
		cPicture:= aSRAHeader[nPos,03]
		cValid	:= aSRAHeader[nPos,06]
		cF3		:= aSRAHeader[nPos,09]
		cBox	:= aSRAHeader[nPos,11]
		cWhen	:= aSRAHeader[nPos,13]
		cVisual	:= aSRAHeader[nPos,14]

		If alltrim(aSRAHeader[nPos,2]) == "RA_FILIAL"
			cValid  	:=  If(!Empty(cValid) .And. cValid != "Ch_Fil()", cValid + ".and. Ch_Fil()" , "Ch_Fil()")
			cVisual		:= "R"
			cF3			:= If(cConSM0, "XM0GPE", "XM0" )
		ElseIf alltrim(aSRAHeader[nPos,2]) == "RA_MAT"
			cValid :=  "ConsMat( oGetSRA2:aCols, oGetSRA2:nAt )"
			If cContrMat != "0" .Or. lBloqMat
				cVisual	:= "V"
			EndIf
		ElseIf alltrim(aSRAHeader[nPos,2]) == "RA_CC"
			cValid  :=  "ConsCc()"
			cF3		:= IF( cAliasCc == "CTT" , If (cConCTT, "RHCTT", "XTT" )  , "XI3" )
		ElseIf alltrim(aSRAHeader[nPos,2]) == "RA_PROCES"
			cValid  := "ConsProc()"
			cF3		:= IF(cConPROC, "RHPROC", "RCJ2" )
		ElseIf alltrim(aSRAHeader[nPos,2]) == "RA_DEPTO"
			cValid :=   "ConsDepto()"
			If (cOrgCfg == "1" .And. !cConDept)
				cF3		:= "RD4ORG"
				cVisual	:= "R"
			ElseIf cConDept
				cF3		:= "RHDEPT"
				cVisual	:= "R"
			EndIf
		ElseIf alltrim(aSRAHeader[nPos,2]) == "RA_POSTO"
			cValid 	:= "ConsPosto() .And. VldPosto()"
			cVisual	:= "R"
			If (cOrgCfg == "1" .And. !cConPosto)
				cF3		:= "RCLORG"
			Elseif cConPosto
				cF3		:= "RHPOST"
			Endif
		ElseIf alltrim(aSRAHeader[nPos,2]) $ "RA_NOME,QB_FILTIT,QB_MATTIT"
			cVisual	:= "V"
		ElseIf alltrim(aSRAHeader[nPos,2]) == "RA_PAGAUM"
			cValid :=  If(!Empty(cValid) , cValid + " .and. fConsPerAum() "  , "fConsPerAum()")
		ElseIf alltrim(aSRAHeader[nPos,2]) $ ( "RA_TNOTRAB/RA_SEQTURN/RA_REGRA" )
			cWhen	:= 'fVldTnoTrab()'
		Endif
		If lItemClvl
			If (alltrim(aSRAHeader[nPos,2]) == "RA_ITEM" )
				cValid  := If(!Empty(cValid) , cValid + " .and. ConsItem()"  , "ConsItem()")
			ElseIf (alltrim(aSRAHeader[nPos,2]) == "RA_CLVL" )
				cValid  := If(!Empty(cValid) , cValid + " .and. ConsClvl()"  , "ConsClvl()")
			EndIf
		EndIf

		If !Empty(cF3) .and. cF3<> "XM0" .and. ;
		(ascan(aFields, {|x| x = alltrim(aSRAHeader[nPos,2]) } )= 0 )
			cValid  := If(!Empty(cValid) , cValid + " .and. ConsVldCpo()"  , "ConsVldCpo()")
		Endif

		//{ cTitulo            , x3_campo,x3_picture,x3_tamanho, x3_decimal, cValid, x3_usado, x3_tipo, X3_F3, x3_context, cBox ,x3_relacao, x3_when, cVisual, x3_vlduser,"", .F.  })
		Aadd(aHeader_Aux,{cTitulo 				, aSRAHeader[nPos,2] 	, cPicture			, aSRAHeader[nPos,4], aSRAHeader[nPos,5] ,;
						cValid				, aSRAHeader[nPos,7]	, aSRAHeader[nPos,8], cF3               , aSRAHeader[nPos,10],;
						cBox 					, aSRAHeader[nPos,12]  , cWhen				 , cVisual          , aSRAHeader[nPos,15] ,;
						aSRAHeader[nPos,16]	, aSRAHeader[nPos,17]    })

		If alltrim(aSRAHeader[nPos,02])=="RA_PROCES"
			Aadd(aHeader_Aux,{ OemToAnsi(STR0087) , "M_DPROCES" ,'@!'                      ,15,0 ,""            ,"€€€€€€€€€€€€€€ ", "C" ,""   , "" ,""  ,""            ,"" ,"V"   ,  " ","" ,.F.  })
		Endif
		If alltrim(aSRAHeader[nPos,02])=="RA_POSTO"
			Aadd(aHeader_Aux,{ OemToAnsi(STR0162) , "M_DPOSTO" ,'@!'                      ,15,0 ,""            ,"€€€€€€€€€€€€€€ ", "C" ,""   , "" ,""  ,""            ,"" ,"V"   ,  " ","" ,.F.  })
		Endif
	Endif

Next nX

// Monta a aheader dos campos virtuais
For nX := 1 to Len(aFields1)
	If ( nPos :=Ascan(aSRAHeader, {|x| alltrim(aFields1[nx]) == alltrim(x[2]) }   )   ) > 0
		cTitulo := aSRAHeader[nPos,01]
		cPicture:= aSRAHeader[nPos,03]
		cValid	:= aSRAHeader[nPos,06]
		cF3		:= aSRAHeader[nPos,09]
		cBox	:= aSRAHeader[nPos,11]
		cWhen	:= aSRAHeader[nPos,13]
		cVisual	:= aSRAHeader[nPos,14]

		If alltrim(aSRAHeader[nPos,2]) == "RA_MAT"
			cWhen := ".F."
			cVisual	:= "V"
		ElseIf alltrim(aSRAHeader[nPos,2]) $ "RA_NOME,QB_FILTIT,QB_MATTIT"
			cVisual	:= "V"
		ElseIf alltrim(aSRAHeader[nPos,2]) == "RA_PAGAUM"
			cValid :=  If(!Empty(cValid) , cValid + " .and. fConsPerAum() "  , "fConsPerAum()")
		ElseIf alltrim(aSRAHeader[nPos,2]) == "RA_CODFUNC"
			cValid 	:= "Vld180Func() .And. VldPosto()"
			cF3		:= If(cConFunc, "RHSRJ", "SRJ" )
		ElseIf alltrim(aSRAHeader[nPos,2]) == "RA_CARGO"
			cValid 	:= "VldPosto()"
		ElseIf alltrim(aSRAHeader[nPos,2]) == "RA_TNOTRAB"
			cF3		:= If(cConTurn, "RHSR6", "SR6" )
			cValid 	:= "Vld180Turno() .And. FHIST()"
		ElseIf alltrim(aSRAHeader[nPos,2]) == "RA_REGRA"
			cF3		:= If(cConRegr, "RHSPA", "SPA" )
			cValid 	:= "Vld180Regr()"
		ElseIf alltrim(aSRAHeader[nPos,2]) == "RA_SEQTURN"
			cF3		:= If(cConSeq, "RHSPJ", "XPJ" )
			cValid 	:= "Vazio() .Or. Vld180Seq()"
		ElseIf alltrim(aSRAHeader[nPos,2]) == "RA_TIPOALT"
			cValid 	:= "Vazio() .Or. (Vld180SX5() .And. GP010TpAlt(M->RA_TIPOALT))"
		Endif

		If !Empty(cF3) .and. cF3<> "XM0" .and. ;
		(ascan(aFields1, {|x| x = alltrim(aSRAHeader[nPos,2]) } )= 0 )
			cValid  := If(!Empty(cValid) , cValid + " .and. ConsVldCpo()"  , "ConsVldCpo()")
		Endif

		//{ cTitulo            , x3_campo,x3_picture,x3_tamanho, x3_decimal, cValid, x3_usado, x3_tipo, X3_F3, x3_context, cBox ,x3_relacao, x3_when, cVisual, x3_vlduser,"", .F.  })
		Aadd(aHeader1_Aux,{cTitulo 			, aSRAHeader[nPos,2] 	, cPicture			, aSRAHeader[nPos,4], aSRAHeader[nPos,5] ,;
						cValid				, aSRAHeader[nPos,7]	, aSRAHeader[nPos,8], cF3               , aSRAHeader[nPos,10],;
						cBox 				, aSRAHeader[nPos,12]	, cWhen				, cVisual			, aSRAHeader[nPos,15],;
						aSRAHeader[nPos,16]	, aSRAHeader[nPos,17]    })
	Endif
Next nX

If lHeadFull
	Aadd(aHeader_Aux,{aSRAHeader[nLenaHeader-1,01], aSRAHeader[nLenaHeader-1,02]	, aSRAHeader[nLenaHeader-1,03], aSRAHeader[nLenaHeader-1,04], aSRAHeader[nLenaHeader-1,5] ,;
					aSRAHeader[nLenaHeader-1,06], aSRAHeader[nLenaHeader-1,07]	, aSRAHeader[nLenaHeader-1,08], aSRAHeader[nLenaHeader-1,09], aSRAHeader[nLenaHeader-1,10],;
					aSRAHeader[nLenaHeader-1,11], aSRAHeader[nLenaHeader-1,12]   , aSRAHeader[nLenaHeader-1,13], aSRAHeader[nLenaHeader-1,14], aSRAHeader[nLenaHeader-1,15] ,;
					aSRAHeader[nLenaHeader-1,16], aSRAHeader[nLenaHeader-1,17]    })
	Aadd(aHeader_Aux,{aSRAHeader[nLenaHeader,01], aSRAHeader[nLenaHeader,02]	, aSRAHeader[nLenaHeader,03], aSRAHeader[nLenaHeader,04], aSRAHeader[nLenaHeader,5] ,;
					aSRAHeader[nLenaHeader,06], aSRAHeader[nLenaHeader,07]	, aSRAHeader[nLenaHeader,08], aSRAHeader[nLenaHeader,09], aSRAHeader[nLenaHeader,10],;
					aSRAHeader[nLenaHeader,11], aSRAHeader[nLenaHeader,12]   , aSRAHeader[nLenaHeader,13], aSRAHeader[nLenaHeader,14], aSRAHeader[nLenaHeader,15],;
					aSRAHeader[nLenaHeader,16], aSRAHeader[nLenaHeader,17]    })

	Aadd(aHeader1_Aux,{aSRAHeader[nLenaHeader-1,01], aSRAHeader[nLenaHeader-1,02]	, aSRAHeader[nLenaHeader-1,03], aSRAHeader[nLenaHeader-1,04], aSRAHeader[nLenaHeader-1,5] ,;
					aSRAHeader[nLenaHeader-1,06], aSRAHeader[nLenaHeader-1,07]	, aSRAHeader[nLenaHeader-1,08], aSRAHeader[nLenaHeader-1,09], aSRAHeader[nLenaHeader-1,10],;
					aSRAHeader[nLenaHeader-1,11], aSRAHeader[nLenaHeader-1,12]   , aSRAHeader[nLenaHeader-1,13], aSRAHeader[nLenaHeader-1,14], aSRAHeader[nLenaHeader-1,15] ,;
					aSRAHeader[nLenaHeader-1,16], aSRAHeader[nLenaHeader-1,17]    })
	Aadd(aHeader1_Aux,{aSRAHeader[nLenaHeader,01], aSRAHeader[nLenaHeader,02]	, aSRAHeader[nLenaHeader,03], aSRAHeader[nLenaHeader,04], aSRAHeader[nLenaHeader,5] ,;
					aSRAHeader[nLenaHeader,06], aSRAHeader[nLenaHeader,07]	, aSRAHeader[nLenaHeader,08], aSRAHeader[nLenaHeader,09], aSRAHeader[nLenaHeader,10],;
					aSRAHeader[nLenaHeader,11], aSRAHeader[nLenaHeader,12]   , aSRAHeader[nLenaHeader,13], aSRAHeader[nLenaHeader,14], aSRAHeader[nLenaHeader,15],;
					aSRAHeader[nLenaHeader,16], aSRAHeader[nLenaHeader,17]    })

Endif

If ExistBlock("GP180HEA")
	If ( ValType( aRet := ExecBlock("GP180HEA", .F. , .F. ,{aHeader_Aux,aHeader1_Aux}) ) == "A" ) .And. Len(aRet) > 1
		aHeader_Aux   := aClone(aRet[1])
		aHeader1_Aux  := aClone(aRet[2])
    EndIf
Endif

Return( { aHeader_Aux , aHeader1_Aux } )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³fMontaColsºAutor  ³Microsiga           º Data ³  09/21/07   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Montagem  do aCols que sera mostrado na tela e do aSRACols  º±±
±±º          ³que possui todos os campos do SRA                           º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function fMontaCols(lColsFull, lNaoTemPosto )

Local aAreaSRA	 	:= SRA->(GetArea())
Local aStru		 	:= {}
Local cQuery		:= ""
Local cDescEmpr	 	:= ""
Local cDescFil	 	:= ""
Local cProces		:= ""
Local cPosto 		:= ""
Local cAliasSRA 	:= "SRA"
Local nX			:= 0
Local nY			:= 0
Local nCNT		 	:= 0
Local nHeader 	 	:= 0
Local nUsado		:= 00
Local nPos 		 	:= 0
Local nPosRec		:= 0
Local nPosAli		:= 0
Local nLenAcols	 	:= Len(aSRACols)
Local cFilSRA		:= xFilial( "SRA" , __cFilAnt )
Local lPostoEmpty 	:= .F.
Local lFirst		:= .T.
Local nPosTr		:= 0

Local cVar			:= ""
Local nPosDepto   := GdFieldPos("RA_DEPTO", aSRAHeader)

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Abre para buscar a descricao do posto ( =desc.Cargo)         ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
dbSelectArea("RCL")

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Carrega Informacoes da Empresa Origem                        ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If Empty(aInfo)
	fInfo( @aInfo ,__cFilAnt )
Endif
cDescEmpr	   := PadR(aInfo[2],35)
cDescFil	   := PadR(aInfo[1],35)

aTransfCols  := {}
aTransf1Cols := {}

If lColsFull

	// Carrega os campos do folder "Dados de Transferencia"
	nHeader := Len(aTransfHeader) +1
	For nY  := 1 To nLenAcols
		nUsado 		:= 0
		lPostoEmpty := .F.
		aaDD( aTransfCols, Array(nHeader) )
		For nX:= 1 To len(aFields)

			If aFields[nX] = "COLBMP"
				nUsado ++
				aTransfCols[nY,nUsado]	:= "BR_BRANCO"
			ElseIf aFields[nX]= "M_EMPRESA"
				nUsado++
				aTransfCols[nY,nUsado] := cEmpAnt
			ElseIf aFields[nX]= "M_NEMPRESA"
				nUsado++
				aTransfCols[nY,nUsado] := cDescEmpr
			ElseIf alltrim(aFields[nX]) = "RA_FILIAL"
				nUsado++
				aTransfCols[nY,nUsado] := cFilAnt
			ElseIf alltrim(aFields[nX]) = "M_NFILIAL"
				nUsado++
				aTransfCols[nY,nUsado]	:= cDescFil
			ElseIf alltrim(aFields[nX]) = "M_DPROCES"
				nUsado++
				aTransfCols[nY,nUsado]	:= fdesc("RCJ", cProces , 'RCJ_DESCRI' )

			ElseIf alltrim(aFields[nX]) == "QB_FILTIT" .Or. alltrim(aFields[nX]) == "QB_MATTIT"
				nUsado++
				If SQB->QB_DEPTO <> aSRACols[nY,nPosDepto]
					SQB->(DbSetOrder(1))
					SQB->(DbSeek(xFilial() + aSRACols[nY,nPosDepto]))
				EndIf
				cVar := SQB->QB_FILTIT
				If alltrim(aFields[nX]) = "QB_MATTIT"
					cVar := SQB->QB_MATTIT
				EndIf
				aTransfCols[nY,nUsado] := cVar
			ElseIf alltrim(aFields[nX]) == "QB_NOMTIT"
				nUsado++
				aTransfCols[nY,nUsado] := Posicione('SRA',1,SQB->(QB_FILTIT+QB_MATTIT),'RA_NOME')

			ElseIf alltrim(aFields[nX]) = "M_DPOSTO"
				nUsado++
				RCL->(dbSetOrder(2))
				If DbSeek(xFilial("RCL") + cPosto)
					aTransfCols[nY,nUsado]	:= fdesc("SQ3", RCL->RCL_CARGO , 'Q3_DESCSUM' )
				Else
					aTransfCols[nY,nUsado]	:= 	Space( TamSx3( "Q3_DESCSUM" )[1] )
				Endif
				RCL->(dbSetOrder(1))
			ElseIf aFields[nX] = "DESL"
				nUsado ++
				aTransfCols[nY,nUsado]	:= Space( TamSx3( "RE_DESL" )[1] )
			Else
				If( nPos:=ascan(aSRAHeader,{|x| alltrim(x[2])= alltrim(aFields[nX] )} )    ) > 0
					nUsado++
					aTransfCols[nY][nUsado] := aSRACols[nY,nPos]
					If alltrim(aFields[nX])=="RA_PROCES"
						cProces	:= aSRACols[nY,nPos]
					Endif
				Endif
				If aFields[nX] = "RA_POSTO"
					cPosto 		:= aSRACols[nY,nPos]       			// Pegar o Cargo do Posto
					lPostoEmpty	:= Empty(aTransfCols[nY][nUsado])
				Endif

			Endif
		Next nX

		nPosAli	:=	GdfieldPos("RA_ALI_WT",aSRAHeader)
		nPosRec	:=  GdfieldPos("RA_REC_WT",aSRAHeader)

		If nPosAli > 0
			nUsado ++
			aTransfCols[nY,nUsado] := aSRACols[nY,nPosAli]
		EndIf
		If nPosRec > 0
			nUsado ++
			aTransfCols[nY,nUsado] := aSRACols[nY,nPosRec]
		EndIf
		aTransfCols[nY,nUsado+1] := .F.
	Next nY

	// Carrega os campos do folder "Dados Cadastrais"
	nHeader 	:= Len(aTransf1Header) +1
	For nY:= 1 To nLenAcols
		nUsado 		:= 0
		aaDD( aTransf1Cols, Array(nHeader) )
		For nX:= 1 To len(aFields1)

			If aFields1[nX] = "COLBMP"
				nUsado ++
				aTransf1Cols[nY,nUsado]	:= "BR_BRANCO"
			Else

				If( nPos := aScan(aSRAHeader,{|x| alltrim(x[2])== alltrim(aFields1[nX] )} )    ) > 0
					nUsado++
					If AllTrim(aFields1[nX]) == "RA_DESCFUN"
						nPosTr := aScan(aSRAHeader,{|x| AllTrim(x[2]) == AllTrim("RA_CODFUNC")} )
						If nPosTr > 0
							aTransf1Cols[nY][nUsado] :=  ( Posicione("SRJ",1,xFilial("SRJ", M->RE_FILIALP)+ aSRACols[nY,nPosTr],"RJ_DESC") )
						Endif
					Else
						aTransf1Cols[nY][nUsado] := aSRACols[nY,nPos]
					EndIf
				Endif

			Endif
		Next nX

		nPosAli	:=	GdfieldPos("RA_ALI_WT",aSRAHeader)
		nPosRec	:=  GdfieldPos("RA_REC_WT",aSRAHeader)

		If nPosAli > 0
			nUsado ++
			aTransf1Cols[nY,nUsado] := aSRACols[nY,nPosAli]
		EndIf
		If nPosRec > 0
			nUsado ++
			aTransf1Cols[nY,nUsado] := aSRACols[nY,nPosRec]
		EndIf
		aTransf1Cols[nY,nUsado+1] := .F.
	Next nY
Else
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Monta aCols Vazio 								                  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	nUsado ++
	nHeader 	:= Len(aHeaderTran)+ 1
	aaDD( aColsTran, Array(nHeader) )

	For nX:= 1 To len(aFields)
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Monta Array do 1§ Elemento Vazio utilizando SRA              ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If aFields[nX]= "M_EMPRESA"
			aColsTran[1,nUsado]	:= __cEmpAnt
		ElseIf aFields[nX]= "M_NEMPRESA"
			nUsado++
			aColsTran[1,nUsado]	:= FWGrpName(__cEmpAnt)
		ElseIf aFields[nX]= "RA_FILIAL"
			nUsado++
			aColsTran[1,nUsado]	:= __cFilAnt
		ElseIf aFields[nX] = "M_NFILIAL"
			nUsado++
			aColsTran[1,nUsado]	:= FWFilialName(__cEmpAnt,__cFilAnt)
		ElseIf aFields[nX] = "RA_CC"
			nUsado++
			aColsTran[1,nUsado]	:= Space( TamSx3( "RA_CC" )[1] )
		ElseIf aFields[nX] = "RA_DESCCC"
			nUsado++
			aColsTran[1,nUsado]	:= Space( TamSx3( "RA_DESCCC" )[1] )
		ElseIf aFields[nX] = "RA_DEPTO"
			nUsado++
			aColsTran[1,nUsado]	:= Space( TamSx3( "RA_DEPTO" )[1] )
		ElseIf aFields[nX] = "RA_DDEPTO"
			nUsado++
			aColsTran[1,nUsado]	:= Space( TamSx3( "RA_DDEPTO" )[1] )
		ElseIf aFields[nX] = "RA_PROCES"
			nUsado++
			aColsTran[1,nUsado]	:= Space( TamSx3( "RA_PROCES" )[1] )
		ElseIf aFields[nX] = "M_DPROCES"
			nUsado++
			aColsTran[1,nUsado]	:= Space(15)
			ElseIf aFields[nX] = "RE_DESL"
				nUsado++
				aColsTran[1,nUsado]	:= Space( TamSx3( "RE_DESL" )[1] )
		ElseIf aFields[nX] = "QB_FILTIT"
			nUsado++
			aColsTran[1,nUsado]	:= Space( TamSx3( "QB_FILTIT" )[1] )
		ElseIf aFields[nX] = "QB_MATTIT"
			nUsado++
			aColsTran[1,nUsado]	:= Space( TamSx3( "QB_MATTIT" )[1] )
		ElseIf aFields[nX] = "QB_NOMTIT"
			nUsado++
			aColsTran[1,nUsado]	:= Space( TamSx3( "RA_NOME" )[1] )
		ElseIf aFields[nX] = "QB_SUBTIT" .Or. aFields[nX] = "QB_RETTIT"
			nUsado++
			aColsTran[1,nUsado]	:= " "
		ElseIf aFields[nX] = "RA_POSTO"
			nUsado++
			aColsTran[1,nUsado]	:= Space( TamSx3( "RA_POSTO" )[1] )
		ElseIf aFields[nX] = "M_DPOSTO"
			nUsado++
			aColsTran[1,nUsado]	:= Space(15)
		ElseIf lItemClvl == .T. .and. aFields[nX] = "RA_ITEM"
			nUsado++
			aColsTran[1,nUsado]	:= Space( TamSx3( "RA_ITEM" )[1] )
		ElseIf lItemClvl == .T. .and. aFields[nX] = "RA_CLVL"
			nUsado++
			aColsTran[1,nUsado]	:= Space( TamSx3( "RA_CLVL" )[1] )
		Endif
	Next nx
	aColsTran[1,nUsado+1] := .F.
Endif
RestArea(aAreaSRA)

Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³GPEA180   ºAutor  ³Microsiga           º Data ³  04/30/08   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Carrega os Alias das consulta padrao                        º±±
±±º          ³Utilizado para abrir tabelas q possuem cons.Padrao conforme º±±
±±º          ³filial - se estiver no modo exclusivo                       º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function fGetAlias(aTransfHeader,aTransf1Header)

Local aAlias	:= {}
Local aArea		:= GetArea()
Local nX		:= 0

// Carrega as consultas padroes do folder "Dados Transferencia"
For nX:= 1 to Len(aTransfHeader)

	If !Empty( aTransfHeader[nX,9 ] ) 			//-- Se Tem  consulta padrao, buscar  o alias
		dbSelectArea("SXB")
		If alltrim(aTransfHeader[nX,9 ]) <> "XM0" .AND. dbSeek( aTransfHeader[nX,9 ] + "101")
				If(nPos:= Ascan( aAlias,{|x| alltrim(x)== Substr(ALLTRIM(SXB->XB_CONTEM),1,3)  } ) ) =0
					aadd(aAlias, Substr(ALLTRIM(SXB->XB_CONTEM),1,3) )
			Endif
		Endif
	Endif

Next nX

// Carrega as consultas padroes do folder "Dados Cadastrais"
For nX:= 1 to Len(aTransf1Header)

	If !Empty( aTransf1Header[nX,9 ] ) 			//-- Se Tem  consulta padrao, buscar  o alias
		dbSelectArea("SXB")
		If alltrim(aTransf1Header[nX,9 ]) <> "XM0" .AND. dbSeek( aTransf1Header[nX,9 ] + "101")
				If(nPos:= Ascan( aAlias,{|x| alltrim(x)== Substr(ALLTRIM(SXB->XB_CONTEM),1,3)  } ) ) =0
					aadd(aAlias, Substr(ALLTRIM(SXB->XB_CONTEM),1,3) )
			Endif
		Endif
	Endif

Next nX

aadd(aAlias, cAliasCc )

If cOrgCfg == "1"
	aadd(aAlias, "RDK" )
EndIf

RestArea(aArea)

Return (aAlias)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³fSvMemToCols ºAutor  ³Microsiga           º Data ³  03/18/08   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Atualiza variaveis de memoria no aSRACols                      º±±
±±º          ³                                                               º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                            º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function fSvMemToCols(nLinBrowse)

Local nX	:= 0

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Atualiza aCols conforme Var.Memoria                           ³
//³Salva a linha anterior no acols                               ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

// Dados de Transferencia
For nX := 1 To Len(aTransfHeader)
	If !lRobo
		SetMemVar( aTransfHeader[nX,02] , oGetSRA2:aCols[nLinBrowse,nX] , .T. )
	Else
		SetMemVar( aTransfHeader[nX,02] , aTransfCols[nLinBrowse,nX] , .T. )
	Endif
Next nX

// Dados Cadastrais
For nX := 3 To Len(aTransf1Header)
	If !lRobo
		SetMemVar( aTransf1Header[nX,02] , oGetSRA21:aCols[nLinBrowse,nX] , .T. )
	Else
		SetMemVar( aTransf1Header[nX,02] , aTransf1Cols[nLinBrowse,nX] , .T. )
	Endif
Next nX

For nX := 1 To Len(aSRAHeader)
	aSRACols[nLinBrowse,nX] := &("M->"+ aSRAHeader[nX,02])
Next nX

Return(nil)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³fSvColsToMem  ºAutor  ³Microsiga           º Data ³  03/10/08   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Carrega todas as variaveis de memoria devido os gatilhos dos    º±±
±±º          ³campos complementares                                           º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                             º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function fSvColsToMem(nLinBrowse)

	Local aAreaSRA	:= GetArea("SRA")
	Local nX 			:= 0
	Local nPosRec		:= GdFieldPos("RA_REC_WT", aSRAHeader )
	Local nRecno 		:= aSRACols[nLinBrowse,nPosRec]

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Atualiza Var.Memoria dos aCols                                ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	For nX := 1 To Len(aSRAHeader)
		SetMemVar( aSRAHeader[ nX , 02 ] ,aSRACols[ nLinBrowse, nX ]  , .T. )
	Next nX

	SRA->(dbGoTo(  nRecno  )  )

	cFilAte := aSRACols[ nLinBrowse, _FILIAL ]
	cEmpAte := aSRACols[ nLinBrowse, _EMPRES ]

	RestArea(aAreaSRA)

Return(.T.)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³fTransfUnico  ºAutor  ³Microsiga           º Data ³  03/11/08   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Monta a get com os dados de transferencia para um unico destino º±±
±±º          ³                                                                º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                             º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function fTransfUnico()

	Local nOpca			:= 1
	Local aAdvSize		:= {}
	Local aInfoAdvSize	:= {}
	Local aObjSize		:= {}
	Local aObjCoords	:= {}
	Local aSvSRA2		:= aClone(oGetSRA2:aCols)
	Local oDLG3
	Local uNewEmpAlias	:= {cAliasCc, "SQB", "RCJ"}
	Local nPosItem		:= GdfieldPos("RA_ITEM", oGetSRA2:aHeader)
	Local nPosClVl		:= GdfieldPos("RA_CLVL", oGetSRA2:aHeader)

	Private aColsTran 	:= {}
	Private aHeaderTran	:= {}
	Private oGetTran

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Testa se tem  funcionarios selecionados     				      ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If ( nPos := Ascan(oGetSRA2:aCols , {|x| x[_COLBMP] == "BR_VERDE" }    )  )   = 0
		If (MsgYesNo( OemToAnsi( STR0138 ) ) )	  				//--"Nao existem  funcionarios selecionados para transferencia. Deseja selecionar todos ? "
			Aeval(oGetSRA2:aCols, { |x| x[_COLBMP]:= "BR_VERDE" }  )
		Else
			MsgAlert( 	OemToAnsi(STR0131) + CRLF +; 		     	//-- "Selecione os funcionarios que serao transferidos para a mesma "
						OemToAnsi(STR0132) + CRLF +CRLF +; 		 	//-- "Empresa, Filial, Centro de Custo ,Processo e Depto. "
						OemToAnsi(STR0133) + CRLF ; 		 		//-- "Utilize o Duplo click ou Enter "
					)
			Return (.T.)
		Endif
	Endif

	_CITEM := Iif(nPosItem > 0, nPosItem, _CITEM)
	_CCLVL := Iif(nPosClvl > 0, nPosClvl, _CCLVL)

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Monta as Dimensoes dos Objetos  		       				      ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	aAdvSize		:= MsAdvSize()
	aInfoAdvSize	:= { aAdvSize[1] , aAdvSize[2] , aAdvSize[3] , aAdvSize[4] , 5 , 5 }
	aAdd( aObjCoords , { 000 , 000 , .T. , .T. } )
	aObjSize		:= MsObjSize( aInfoAdvSize , aObjCoords )

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Montagem do aHeader com os campos da transferencia           ³
	//³ Transferencias para um mesmo destino                         ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If cEmpAnt <> __cEmpAnt
		ChangeNew("SRA", __cEmpAnt, __cFilAnt)
		//Retorna SX2 da empresa logada
		fOpenSx2(__cEmpAnt)
	EndIf
	aHeaderTran	:= fMontaHeader(.F.)[1]

	fMontaCols(.F.,.F.)

	DEFINE FONT oFont NAME "Arial" SIZE 0,-11 BOLD

	If lGestPubl
		DEFINE MSDIALOG oDlg3 TITLE  OemToAnsi(STR0270) FROM aAdvSize[7],0 TO aAdvSize[6],(aAdvSize[5]) OF oMainWnd PIXEL    //Relotações
	Else
	DEFINE MSDIALOG oDlg3 TITLE  OemToAnsi(STR0008) FROM aAdvSize[7],0 TO aAdvSize[6],(aAdvSize[5]) OF oMainWnd PIXEL    //Transferencias
	Endif

	oGetTran	:= MsNewGetDados():New(	aObjSize[1,1],;  		// 1-nTop
										aObjSize[1,2],;			// 2-nLelft
										aObjSize[1,3],;			// 3-nBottom
										aObjSize[1,4],;			// 4-nRright
										GD_UPDATE	,; 			// 5-controle do que podera ser realizado na GetDado - nstyle
										.T.   ,;				// 6-funcao para validar a edicao da linha - ulinhaOK
										"GPTranTudoOk",;		// 7-funcao para validar todos os registros da GetDados - uTudoOK
										NIL,;					// 8-cIniCPOS
										NIL,;					// 9-aAlter
										0,;						// 10-nfreeze
										99999,;					// 11-nMax
										NIL,;					// 12-cFieldOK
										NIL,;					// 13-usuperdel
										NIL,;					// 14-bloco com funcao para validar registros deletados (Gp400DelOk())
										oDlg3,;                 // 15-objeto de dialogo - oWnd
										aHeaderTran,;			// 16-Vetor com Header - AparHeader
										aColsTran;				// 17-Vetor com Colunas - AparCols
									)
	oGetTran:bChange := { |lChange|;
								ChangeNew(uNewEmpAlias, oGetTran:acols[oGetTran:nAt, 01], oGetTran:acols[oGetTran:nAt,03] ) ,;
								oGetTran:oBrowse:Refresh() ;
						}

	ACTIVATE MSDIALOG oDlg3 ON INIT EnchoiceBar(oDlg3, {||nOpcA:=1 ,IF(oGetTran:TudoOk(),oDlg3:End(),nOpcA:=0 )  } ,    {||nOpcA:=0, oDlg3:End() }     ) CENTERED

	If nOpca == 1
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Grava Destino para os funcionarios selecionados             ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If fAtualGetSRA2()
			Eval( bSvColsToMem, oGetSRA2:oBrowse:nAT )
		Endif
	Else
		oGetSRA2:aCols		:= aClone(aSvSRA2)
	Endif

	If( IsBlind(),, oGetSRA2:Refresh() )
	If cEmpAnt <> __cEmpAnt
		ChangeNew("SRA", __cEmpAnt, __cFilAnt)
		//Retorna SX2 da empresa logada
		fOpenSx2(__cEmpAnt)
	EndIf
Return(.T.)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³GPEA180   ºAutor  ³Microsiga           º Data ³  04/07/08   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³                                                            º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function GPTranTudoOk(oBrowse)
Local lRet		:= .F.
Local nPItem	:= gdFieldPos("RA_ITEM", oGetTran:aHeader)
Local nPClas	:= gdFieldPos("RA_CLVL", oGetTran:aHeader)

IF  !Empty( oGetTran:aCols[1,5]) .Or. ;							// Centro de Custo
	!Empty( oGetTran:aCols[1,7]) .Or. ; 						// Departamento
	!Empty( oGetTran:aCols[1,9]) .Or. ;							// Processo
	(lItemClvl .And. !Empty( oGetTran:aCols[1,nPItem]) ) .Or. ;	// Item
	(lItemClvl .And. !Empty( oGetTran:aCols[1,nPClas]) ) .Or. ;	// Classe de Valor
	(cOrgCfg == '1' .and. !Empty( oGetTran:aCols[1,11]) )		// Posto
	lRet := .T.
Endif

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Empresa nao Pode Estar Vazio                               ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
IF Empty( oGetTran:aCols[1,1]) 	//--  Empresa
	Help(" ",1,"A180NEMPR")
	Return (.F.)
EndIF

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Empresa nao Pode Estar Vazio                               ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
IF Empty( oGetTran:aCols[1,3])
	Help(" ",1,"A180NFIL")   //--  Filial
	Return (.F.)
EndIF

If !lRet
	MsgAlert( OemToAnsi(STR0171), OemToAnsi(STR0047) ) // "Pelo menos um campo deverá ser digitado para a transferencia de destino único!"
Endif

Return lRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³fAtualGetSRA2 ºAutor  ³Microsiga           º Data ³  04/07/08   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Atualiza oGetSRA2:aCols com as transferencias                   º±±
±±º          ³                                                                º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                             º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function fAtualGetSRA2()
Local nX 		:= 0
Local nPos3 	:= Ascan(aSRAHeader, {|x| alltrim("RA_FILIAL") == alltrim(x[2]) } )
Local nPosMat	:= Ascan(aSRAHeader, {|x| alltrim("RA_MAT") == alltrim(x[2]) } )
Local nPos5 	:= Ascan(aSRAHeader, {|x| alltrim("RA_CC") == alltrim(x[2]) } )
Local nPos7 	:= Ascan(aSRAHeader, {|x| alltrim("RA_DEPTO") == alltrim(x[2]) } )
Local nPos9 	:= Ascan(aSRAHeader, {|x| alltrim("RA_PROCES") == alltrim(x[2]) } )
Local nPos11 	:= Ascan(aSRAHeader, {|x| alltrim("RA_ITEM") == alltrim(x[2]) } )
Local nPos12 	:= Ascan(aSRAHeader, {|x| alltrim("RA_CLVL") == alltrim(x[2]) } )
Local nPos13 	:= Ascan(aSRAHeader, {|x| alltrim("RA_POSTO") == alltrim(x[2]) } )

Local nPFilTit  := GdFieldPos("QB_FILTIT", oGetTran:aHeader)
Local nPMatTit  := GdFieldPos("QB_MATTIT", oGetTran:aHeader)
Local nPNomTit  := GdFieldPos("QB_NOMTIT", oGetTran:aHeader)
Local nPItem	:= GdFieldPos("RA_ITEM", oGetTran:aHeader)
Local nPClas	:= GdFieldPos("RA_CLVL", oGetTran:aHeader)

	For nX:= 1 To len(oGetSRA2:aCols)
		If oGetSRA2:aCols[nX,_COLBMP]=="BR_VERDE"
			oGetSRA1:aCols[nX,_COLBMP]:=	"BR_AZUL"
			oGetSRA2:aCols[nX,_COLBMP]:=	"BR_AZUL"
			oGetSRA2:aCols[nX,_EMPRES]:= 	If(!Empty(oGetTran:aCols[1,01]), oGetTran:aCols[1,01], oGetSRA2:aCols[nX,_EMPRES] )
			oGetSRA2:aCols[nX,_NEMPRE]:= 	If(!Empty(oGetTran:aCols[1,02]), oGetTran:aCols[1,02], oGetSRA2:aCols[nX,_NEMPRE] )
			oGetSRA2:aCols[nX,_FILIAL]:= 	If(!Empty(oGetTran:aCols[1,03]), oGetTran:aCols[1,03], oGetSRA2:aCols[nX,_FILIAL])
			oGetSRA2:aCols[nX,_NFILIA]:= 	If(!Empty(oGetTran:aCols[1,04]), oGetTran:aCols[1,04], oGetSRA2:aCols[nX,_NFILIA])
			oGetSRA2:aCols[nX,_CCUSTO]:= 	If(!Empty(oGetTran:aCols[1,05]), oGetTran:aCols[1,05], oGetSRA2:aCols[nX,_CCUSTO])
			oGetSRA2:aCols[nX,_DCUSTO]:= 	If(!Empty(oGetTran:aCols[1,06]), oGetTran:aCols[1,06], oGetSRA2:aCols[nX,_DCUSTO])
			oGetSRA2:aCols[nX,_DEPTO ]:= 	If(!Empty(oGetTran:aCols[1,07]), oGetTran:aCols[1,07], oGetSRA2:aCols[nX,_DEPTO ])
			oGetSRA2:aCols[nX,_DDEPT ]:= 	If(!Empty(oGetTran:aCols[1,08]), oGetTran:aCols[1,08], oGetSRA2:aCols[nX,_DDEPT ])
			oGetSRA2:aCols[nX,_PROCES]:= 	If(!Empty(oGetTran:aCols[1,09]), oGetTran:aCols[1,09], oGetSRA2:aCols[nX,_PROCES])
			oGetSRA2:aCols[nX,_DPROCE]:= 	If(!Empty(oGetTran:aCols[1,10]), oGetTran:aCols[1,10], oGetSRA2:aCols[nX,_DPROCE])

			// Matricula do Responsável
			If nPFilTit > 0
				oGetSRA2:aCols[nX,GdFieldPos("QB_FILTIT", oGetSRA2:aHeader)] := oGetTran:aCols[1,nPFilTit]
				oGetSRA2:aCols[nX,GdFieldPos("QB_MATTIT", oGetSRA2:aHeader)] := oGetTran:aCols[1,nPMatTit]
				oGetSRA2:aCols[nX,GdFieldPos("QB_NOMTIT", oGetSRA2:aHeader)] := oGetTran:aCols[1,nPNomTit]

				UpdFilResp(oGetSRA2, oGetSRA2:aCols[nX,_FILIAL], oGetSRA2:aCols[nX,_DEPTO ], nX, _DEPTO)
			EndIf

			aSRACols[nX , nPos3 ]:= oGetSRA2:aCols[nX,_FILIAL]
			aSRACols[nX , nPos5 ]:= oGetSRA2:aCols[nX,_CCUSTO]
			aSRACols[nX , nPos7 ]:= oGetSRA2:aCols[nX,_DEPTO ]
			aSRACols[nX , nPos9 ]:= oGetSRA2:aCols[nX,_PROCES]

			If lItemClvl
				oGetSRA2:aCols[nX,_CITEM]:= If(!Empty(oGetTran:aCols[1,nPItem]) ,oGetTran:aCols[1,nPItem], oGetSRA2:aCols[nX,_CITEM] )
				oGetSRA2:aCols[nX,_CCLVL]:= If(!Empty(oGetTran:aCols[1,nPClas]) ,oGetTran:aCols[1,nPClas] ,oGetSRA2:aCols[nX,_CCLVL] )

				aSRACols[nX , nPos11 ]:= oGetSRA2:aCols[nX,_CITEM]
				aSRACols[nX , nPos12 ]:= oGetSRA2:aCols[nX,_CCLVL]

			Endif

			If cOrgcfg == "1"
				If !Empty(oGetTran:aCols[1,11]) //atualiza depto se o posto estiver preenchido
					oGetSRA2:aCols[nX,_DEPTO ]:= If(!Empty(oGetTran:aCols[1,07]), oGetTran:aCols[1,07], oGetSRA2:aCols[1,_DEPTO ])
					oGetSRA2:aCols[nX,_DDEPT ]:= If(!Empty(oGetTran:aCols[1,08]), oGetTran:aCols[1,08], oGetSRA2:aCols[1,_DDEPT ])
				EndIf
				oGetSRA2:aCols[nX,_POSTO] := If(!Empty(oGetTran:aCols[1,11]), oGetTran:aCols[1,11], oGetSRA2:aCols[1,_POSTO])
				oGetSRA2:aCols[nX,_DPOSTO]:= If(!Empty(oGetTran:aCols[1,12]), oGetTran:aCols[1,12], oGetSRA2:aCols[1,_DPOSTO])

				aSRACols[nX , nPos13 ]:= oGetSRA2:aCols[nX,_POSTO]
				aSRACols[nX , nPos7 ] := oGetSRA2:aCols[nX,_DEPTO]
			EndIf
		Endif

	Next nX

Return( .T. )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³Ch_Emp    ºAutor  ³Microsiga           º Data ³  03/18/08   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³                                                            º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function Ch_Emp()

	Local aArea			:= GetArea()
	Local aAreaSM0		:= SM0->( GetArea() )
	Local cEmp_Aux 		:= ""
	Local cFil_aux		:= ""
	Local lRet			:= .T.
	Local nColCpo		:= 0
	Local lTransfUni	:= IsInCallStack( "fTransfUnico" )
	Local nX			:= ""
	Local lVldGrpEmp	:= SuperGetMv("MV_VALIDTR",, .F.)

	If lTransfUni
		cEmp_Aux 	:= cEmpAte
		cFil_aux	:= cFilAte
	Endif

	cEmpAte 	:= &(ReadVar())

	lEmpDif 	:= .F.

	Begin Sequence

		// SE O USUARIO NÃO FOR ADMIN E DEVE-SE VALIDAR O GRUPO DE EMPRESA
		// SELECIONADO, CHAMA A FUNÇÃO RESPONSAVEL.
		If !FWIsAdmin() .And. lVldGrpEmp
			If !(lRet := fGpa180SM0())
				Help(,,'HELP',, OemToAnsi(STR0284), 1, 0)
				Break
			EndIf
		EndIf

		If  ( __cSvEmpAnt # cEmpAte ) .And. !( FwLibVersion() >= "20250811" )
			// "Atualização de LIB necessária"
			// "Para Transferência entre Grupo de Empresas é necessário estar com LIB superior a 11/08/2025."
			// "Verifique a LIB  através do comando Shitf + F6 e acesse a Central de Downloads para baixar a versão mais atualizada publicada."
			Help(,,OemToAnsi(STR0363),,OemToAnsi(STR0364)  ,1,0, NIL, NIL, NIL, NIL, NIL, {OemToAnsi(STR0365)} )
			lRet := .F.
			Break
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Pesquisa para verificar se Existe a Empresa Selecionada     ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		IF !( lRet := SM0->( dbSeek( cEmpAte ) ) )
			Help(" ",1,"A180NEMPR")         					//--Empresa informada  como  destino  não   existe.
			Break
		Else
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Quando Transferencia Entre Empresas o SRE devera estar   com³
			//³partilhado entre Empresas, ou seja Devera existir apenas  um³
			//³SRE														                ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			IF cEmpAte != __cSvEmpAnt
				IF !( lRet := fChkSRE( cEmpAte ) )
					Help(" ",1,"NOSRECOMP")
					Break
				EndIF
			EndIF

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Obtem a Descricao da Empresa e limpa                        ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			if oGetSRA2:LEDITLINE
				If !lTransfUni
					aCols[oGetSRA2:nAt, _COLBMP] 	:= "BR_AZUL"
					M_NEMPRESA := aCols[oGetSRA2:nAt, _NEMPRE] 	:= PadR( SM0->M0_NOME , 35 )
					aCols[oGetSRA2:nAt, _EMPRES] 	:= cEmpAte
					aCols[oGetSRA2:nAt, _FILIAL] 	:= RHTamFilial(SM0->M0_CODFIL)
					aCols[oGetSRA2:nAt, _NFILIA]	:= PadR( SM0->M0_FILIAL , 35 )

					aCols[oGetSRA2:nAt , _CCUSTO] 	:= Space( TamSx3( "RA_CC"     )[1] )
					aCols[oGetSRA2:nAt , _DCUSTO] 	:= Space( TamSx3( "RA_DESCCC" )[1] )
					If lItemClvl
						aCols[oGetSRA2:nAt , _CITEM ] 	:= Space( TamSx3( "RA_ITEM"  )[1] )
						aCols[oGetSRA2:nAt , _CCLVL ] 	:= Space( TamSx3( "RA_CLVL"  )[1] )
					EndIf
					aCols[oGetSRA2:nAt , _DEPTO ] 	:= Space( TamSx3( "RA_DEPTO"  )[1] )
					aCols[oGetSRA2:nAt , _DDEPT ] 	:= Space( TamSx3( "RA_DDEPTO" )[1] )
					aCols[oGetSRA2:nAt , _POSTO ] 	:= Space( TamSx3( "RA_POSTO"  )[1] )
					aCols[oGetSRA2:nAt , _PROCES] 	:= Space( TamSx3( "RA_PROCES" )[1] )
					aCols[oGetSRA2:nAt , _DPROCE] 	:= Space( TamSx3( "RCJ_DESCRI")[1] )

					If lCtrAutoMat .And. ( MesAno(M->RA_ADMISSA) == MesAno(dDataTra) .Or. oGetSRA1:aCols[oGetSRA1:nAt, _EMPRES] != cEmpAte )

						cFilAux := cFilAnt
						cFilAnt := cFilAte

						// Númeração por empresa.
						If cContrMat == "1"
							aCols[oGetSRA2:nAt, _MATRIC] := GetSx8Num("SRA", "RA_MAT")
						ElseIf cContrMat == "2"
							aCols[oGetSRA2:nAt, _MATRIC] := GetSx8Num("SRA", "RA_MAT", FwCodEmp("SRA") + "\SRA\RA_MAT")
						Else
							aCols[oGetSRA2:nAt, _MATRIC] := GetSx8Num("SRA", "RA_MAT", FWGrpCompany() + "\GRPEMP\SRA\RA_MAT")
						EndIf

						oGetSRA21:aCols[oGetSRA2:nAt , 01]	:= oGetSRA2:aCols[oGetSRA2:nAt, _MATRIC]
						aAdd( aAutoMat, oGetSRA2:nAt )
						cFilAnt := cFilAux

					EndIf
					If !IsBlind()
						oGetSRA2:Refresh()
						oGetSRA1:Refresh()
					EndIf
					//Tipo de Desligamento - eSocial
					If lTpDesl
						nColCpo := aScan( aFields, "RE_DESL" )
						If nColCpo > 0
							aCols[oGetSRA2:nAt , nColCpo] 	:= Space( TamSx3( "RE_DESL" )[1] )
						EndIf
					EndIf
				Else
					oGetTran:aCols[1, 2] 	:=  PadR(SM0->M0_NOME , 35 )
					oGetTran:aCols[1, 3]	:=  RHTamFilial(SM0->M0_CODFIL)
					oGetTran:aCols[1, 4] 	:= PadR( SM0->M0_FILIAL , 35 )
					For nX := 5 To len(oGetTran:aHeader)
						If oGetTran:aHeader[nX][8] == "C"
							oGetTran:aCols[1, nX] := Space(oGetTran:aHeader[nX][4])
						EndIf
					Next nX
					If !IsBlind()
						oGetTran:Refresh()
					EndIf
				Endif
			Else
			If !lTransfUni
				oGetSRA2:aCols[oGetSRA2:nAt, _COLBMP] 	:= "BR_AZUL"
				M_NEMPRESA := oGetSRA2:aCols[oGetSRA2:nAt, _NEMPRE] 	:= PadR( SM0->M0_NOME , 35 )
				oGetSRA2:aCols[oGetSRA2:nAt, _EMPRES] 	:= cEmpAte
				oGetSRA2:aCols[oGetSRA2:nAt, _FILIAL] 	:= RHTamFilial(SM0->M0_CODFIL,cEmpAte)
				oGetSRA2:aCols[oGetSRA2:nAt, _NFILIA]	:= PadR( SM0->M0_FILIAL , 35 )

				oGetSRA2:aCols[oGetSRA2:nAt , _CCUSTO] 	:= Space( TamSx3( "RA_CC"     )[1] )
				oGetSRA2:aCols[oGetSRA2:nAt , _DCUSTO] 	:= Space( TamSx3( "RA_DESCCC" )[1] )
				If lItemClvl
					oGetSRA2:aCols[oGetSRA2:nAt , _CITEM ] 	:= Space( TamSx3( "RA_ITEM"  )[1] )
					oGetSRA2:aCols[oGetSRA2:nAt , _CCLVL ] 	:= Space( TamSx3( "RA_CLVL"  )[1] )
				EndIf
				oGetSRA2:aCols[oGetSRA2:nAt , _DEPTO ] 	:= Space( TamSx3( "RA_DEPTO"  )[1] )
				oGetSRA2:aCols[oGetSRA2:nAt , _DDEPT ] 	:= Space( TamSx3( "RA_DDEPTO" )[1] )
				oGetSRA2:aCols[oGetSRA2:nAt , _POSTO ] 	:= Space( TamSx3( "RA_POSTO"  )[1] )
				oGetSRA2:aCols[oGetSRA2:nAt , _DPOSTO ] := Space( TamSx3( "Q3_DESCSUM" )[1] )
				oGetSRA2:aCols[oGetSRA2:nAt , _PROCES] 	:= Space( TamSx3( "RA_PROCES" )[1] )
				oGetSRA2:aCols[oGetSRA2:nAt , _DPROCE] 	:= Space( TamSx3( "RCJ_DESCRI")[1] )
				If !IsBlind()
					oGetSRA2:Refresh()
					oGetSRA1:Refresh()
				EndIf
				//Tipo de Desligamento - eSocial
				If lTpDesl
					nColCpo := aScan( aFields, "RE_DESL" )
					If nColCpo > 0
						oGetSRA2:aCols[oGetSRA2:nAt , nColCpo] 	:= Space( TamSx3( "RE_DESL" )[1] )
					EndIf
				EndIf
			Else
				oGetTran:aCols[1, 2] 	:= PadR(SM0->M0_NOME , 35 )
				oGetTran:aCols[1, 3]	:= RHTamFilial(SM0->M0_CODFIL,cEmpAte)
				oGetTran:aCols[1, 4] 	:= PadR( SM0->M0_FILIAL , 35 )
				For nX := 5 To len(oGetTran:aHeader)
					If oGetTran:aHeader[nX][8] == "C"
						oGetTran:aCols[1, nX] := Space(oGetTran:aHeader[nX][4])
					EndIf
				Next nX
				If !IsBlind()
					oGetTran:Refresh()
				EndIf
			Endif
			endIf
		Endif
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Seta a Transferencia Entre Empresas						       ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		lEmpDif := ( __cSvEmpAnt # cEmpAte )
		cFilAte 	:= RHTamFilial(SM0->M0_CODFIL,cEmpAte)
	End Sequence

	If lRet
		If !lTransfUni
			aAdd(uAliasNewEmp,"SRA")
			aAdd(uAliasNewEmp,"SR6")
			aAdd(uAliasNewEmp,"SRJ")
			aAdd(uAliasNewEmp,"SPA")
			If cOrgCfg == "1"
				aAdd(uAliasNewEmp,"RD4")
			Endif
			ChangeNew(uAliasNewEmp, cEmpAte, cFilAte )
		Else
			aAdd(uAliasNewEmp,"SRA")
			ChangeNew( {cAliasCc, "SQB","RCJ","SRA"}, cEmpAte, cFilAte )
			cEmpAte 	:= cEmp_Aux
			cFilAte 	:= cFil_Aux
		Endif

		If lCtrAutoMat .And. ( MesAno(M->RA_ADMISSA) == MesAno(dDataTra) .Or. oGetSRA1:aCols[oGetSRA1:nAt, _EMPRES] != cEmpAte )
			// Númeração por empresa.
			If cContrMat == "1"
				oGetSRA2:aCols[oGetSRA2:nAt, _MATRIC] := GetSx8Num("SRA", "RA_MAT")
			ElseIf cContrMat == "2"
				oGetSRA2:aCols[oGetSRA2:nAt, _MATRIC] := GetSx8Num("SRA", "RA_MAT", FwCodEmp("SRA") + "\SRA\RA_MAT")
			Else
				oGetSRA2:aCols[oGetSRA2:nAt, _MATRIC] := GetSx8Num("SRA", "RA_MAT", FWGrpCompany() + "\GRPEMP\SRA\RA_MAT")
			EndIf

			oGetSRA21:aCols[oGetSRA2:nAt , 01]	:= oGetSRA2:aCols[oGetSRA2:nAt, _MATRIC]
			aAdd( aAutoMat, oGetSRA2:nAt )
		Endif

		cConCTT		:= .F.
		cConDept	:= .F.
		cConProc	:= .F.
		cConPosto	:= .F.
		cConPeriod	:= .F.
		cConNrPag	:= .F.
		cConTurn	:= .F.
		cConFunc	:= .F.
		cConRegr	:= .F.
		cConSeq		:= .F.
		cConSM0		:= .F.
		existF3New(@cConCTT, @cConDept, @cConProc, @cConPosto, @cConPeriod, @cConNrPag,@cConTurn,@cConFunc,@cConRegr,@cConSeq,@cConSM0)
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Restaura os Dados de Entrada								          ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	RestArea( aAreaSM0 )
	RestArea( aArea )
Return lRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³Ch_Fil    ºAutor  ³Microsiga           º Data ³  03/18/08   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³                                                            º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function Ch_Fil()
	Local aArea			:= GetArea()
	Local aAreaSM0		:= SM0->( GetArea() )
	Local cEmp_Aux 		:= ""
	Local cFil_aux		:= ""
	Local cFilAux		:= ""
	Local lRet			:= .T.
	Local lTransfUni	:= IsInCallStack( "fTransfUnico" )
	Local lFilDif_Aux	:= .F.
	Local lChEmp		:= oGetSRA1:aCols[oGetSRA1:nAt, _EMPRES] != oGetSRA2:aCols[oGetSRA1:nAt, _EMPRES]
	Local cMatUnica 	:= ""

	If !lTransfUni
		cEmpAte 	:= oGetSRA2:aCols[(oGetSRA2:nAt) ,_EMPRES]
	Else
		lFilDif_Aux	:= lFilDif
		cEmp_Aux 	:= cEmpAte
		cFil_aux	:= cFilAte
		cEmpAte 	:= ( oGetTran:aCols[1,1] )
	Endif

	lFilDif 	:= .F.
	cFilAte 	:= &(ReadVar())

	Begin Sequence

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Verifica se a Filial Digitada eh Valida					       ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		IF !( lRet := SM0->( dbSeek( cEmpAte + cFilAte ) ) )
			Help(" ",1,"A180NFIL") 							//--Filial Informada como Destino não existe
			Break
		EndIF

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Seta a Variavel que Identifica que eh Transferenci de Filial³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		if oGetSRA2:LEDITLINE
			If !lTransfUni
				aCols[oGetSRA2:nAt ,_NFILIA] := PadR( SM0->M0_FILIAL , 35 )

				If(  oGetSRA1:aCols[oGetSRA1:nAt , _FILIAL] # cFilAte )
					aCols[oGetSRA2:nAt , _COLBMP] 	:= "BR_AZUL"
					aCols[oGetSRA2:nAt , _CCUSTO] 			:= Space( TamSx3( "RA_CC"     )[1] )
					aCols[oGetSRA2:nAt , _DCUSTO] 			:= Space( TamSx3( "RA_DESCCC" )[1] )

					If lItemClvl
						aCols[oGetSRA2:nAt , _CITEM] 			:= Space( TamSx3( "RA_ITEM" )[1] )
						aCols[oGetSRA2:nAt , _CCLVL] 			:= Space( TamSx3( "RA_CLVL" )[1] )
					EndIf

					aCols[oGetSRA2:nAt , _DEPTO] 			:= Space( TamSx3( "RA_DEPTO" )[1] )
					aCols[oGetSRA2:nAt , _DDEPT] 			:= Space( TamSx3( "RA_DDEPTO" )[1] )

					aCols[oGetSRA2:nAt , _POSTO] 			:= Space( TamSx3( "RA_POSTO" )[1] )
					aCols[oGetSRA2:nAt , _PROCES] 			:= Space( TamSx3( "RA_PROCES" )[1] )
					aCols[oGetSRA2:nAt , _DPROCE] 			:= Space( TamSx3( "RCJ_DESCRI" )[1] )
				Endif

				If lCtrAutoMat .And. ( MesAno(M->RA_ADMISSA) == MesAno(dDataTra) .Or. oGetSRA1:aCols[oGetSRA1:nAt, _FILIAL] != cFilAte ) .And. (oGetSRA2:aCols[oGetSRA2:nAt, _FILIAL] != cFilAte .Or. lChEmp)
					cFilAux := cFilAnt
					cFilAnt := cFilAte
					If Len(aAutoMat) > 0
						RollBackSX8()
					EndIf

					If cContrMat == "1"
						aCols[oGetSRA2:nAt , _MATRIC] 		  := GetSx8Num("SRA", "RA_MAT")
					ElseIf cContrMat == "2"
						aCols[oGetSRA2:nAt , _MATRIC] 		  := GetSx8Num("SRA", "RA_MAT", FwCodEmp("SRA") + "\SRA\RA_MAT")
					Else
						aCols[oGetSRA2:nAt , _MATRIC] 		  := GetSx8Num("SRA", "RA_MAT", FWGrpCompany() + "\GRPEMP\SRA\RA_MAT")
					EndIf

					oGetSRA21:aCols[oGetSRA2:nAt , 01]	:= aCols[oGetSRA2:nAt, _MATRIC]
					aAdd( aAutoMat, oGetSRA2:nAt )
					cFilAnt := cFilAux

				ElseIf lCtrAutoMat .And. (cFilate == SRA->RA_FILIAL)
				//Caso a filial "para" seja igual a filial atual do funcionario
				//atualizar a matricula para a matricula atual, visto que em uma transf de filial
				//pode ter sido criado anteriormente um novo código de matrícula
					aCols[oGetSRA2:nAt, _MATRIC] := SRA->RA_MAT
					RollBackSX8()
				EndIf

				If lTpDesl
					nColCpo := aScan( aFields, "RE_DESL" )
					If nColCpo > 0
						//So permite editar se houver mudanca de CNPJ
						If Ch_Desl('2')
							aCols[oGetSRA2:nAt , nColCpo] 	:= Space( TamSx3( "RE_DESL" )[1] )
						Else
							aCols[oGetSRA2:nAt , nColCpo] 	:= Space( TamSx3( "RE_DESL" )[1] )
							//"oGetDad:LACTIVE := .F.".
						EndIf
					EndIf
				EndIf
				If !IsBlind()
					oGetSRA2:Refresh()
					oGetSRA1:Refresh()
				EndIf
			Else
				oGetTran:aCols[1,4] := PadR( SM0->M0_FILIAL , 35 )
				If !IsBlind()
					oGetTran:Refresh()
				EndIf
			Endif
		Else
			If !lTransfUni
			oGetSRA2:aCols[oGetSRA2:nAt ,_NFILIA] := PadR( SM0->M0_FILIAL , 35 )

			If(  oGetSRA1:aCols[oGetSRA1:nAt , _FILIAL] # cFilAte )
				oGetSRA2:aCols[oGetSRA2:nAt , _COLBMP] 	:= "BR_AZUL"
				oGetSRA2:aCols[oGetSRA2:nAt , _CCUSTO] 	:= Space( TamSx3( "RA_CC"     )[1] )
				oGetSRA2:aCols[oGetSRA2:nAt , _DCUSTO] 	:= Space( TamSx3( "RA_DESCCC" )[1] )

				If lItemClvl
					oGetSRA2:aCols[oGetSRA2:nAt , _CITEM] 	:= Space( TamSx3( "RA_ITEM" )[1] )
					oGetSRA2:aCols[oGetSRA2:nAt , _CCLVL] 	:= Space( TamSx3( "RA_CLVL" )[1] )
				EndIf

				oGetSRA2:aCols[oGetSRA2:nAt , _DEPTO ] 	:= Space( TamSx3( "RA_DEPTO"  )[1] )
				oGetSRA2:aCols[oGetSRA2:nAt , _DDEPT ] 	:= Space( TamSx3( "RA_DDEPTO"  )[1] )

				oGetSRA2:aCols[oGetSRA2:nAt , _POSTO ] 	:= Space( TamSx3( "RA_POSTO"  )[1] )
				oGetSRA2:aCols[oGetSRA2:nAt , _PROCES] 	:= Space( TamSx3( "RA_PROCES" )[1] )
				oGetSRA2:aCols[oGetSRA2:nAt , _DPROCE] 	:= Space( TamSx3( "RCJ_DESCRI" )[1] )
			Endif

			If lTpDesl
				nColCpo := aScan( aFields, "RE_DESL" )
				If nColCpo > 0
					//So permite editar se houver mudanca de CNPJ
					If Ch_Desl('2')
						oGetSRA2:aCols[oGetSRA2:nAt , nColCpo] 	:= Space( TamSx3( "RE_DESL" )[1] )
					Else
						oGetSRA2:aCols[oGetSRA2:nAt , nColCpo] 	:= Space( TamSx3( "RE_DESL" )[1] )
						//"oGetDad:LACTIVE := .F.".
					EndIf
				EndIf
			EndIf
			If !IsBlind()
				oGetSRA2:Refresh()
				oGetSRA1:Refresh()
			EndIf
		Else
			oGetTran:aCols[1,4] := PadR( SM0->M0_FILIAL , 35 )
			If !IsBlind()
				oGetTran:Refresh()
			EndIf
		Endif
		endIf

	If !lTransfUni
		ChangeNew(uAliasNewEmp, cEmpAte, cFilAte )
	Else
		ChangeNew( {cAliasCc, "SQB", "RCJ"}, cEmpAte, cFilAte )
		cEmpAte 	:= cEmp_Aux
		cFilAte 	:= cFil_Aux
		lFilDif 	:= lFilDif_Aux
	Endif

	If lCtrAutoMat .And. ( MesAno(M->RA_ADMISSA) == MesAno(dDataTra) .Or. oGetSRA1:aCols[oGetSRA1:nAt, _FILIAL] != cFilAte ) .And. (oGetSRA2:aCols[oGetSRA2:nAt, _FILIAL] != cFilAte .Or. lChEmp)
		If Len(aAutoMat) > 0
			RollBackSX8()
		EndIf

		cMatUnica := SuperGetMV("MV_MATUNIC",.F.,"")
		If cContrMat == "1"
			If SRA->RA_CATFUNC == "A" .Or. !Empty(cMatUnica)
				oGetSRA2:aCols[oGetSRA2:nAt, _MATRIC]	:= fProxMat(cContrMat,.T.)	//Essa função está no GPEA265.
			Else
				oGetSRA2:aCols[oGetSRA2:nAt, _MATRIC] 	:= GetSx8Num("SRA", "RA_MAT")
			Endif
		ElseIf cContrMat == "2"
			If SRA->RA_CATFUNC == "A" .Or. !Empty(cMatUnica)
				oGetSRA2:aCols[oGetSRA2:nAt, _MATRIC]	:= fProxMat(cContrMat,.T.)	//Essa função está no GPEA265.
			Else
				oGetSRA2:aCols[oGetSRA2:nAt, _MATRIC] 	:= GetSx8Num("SRA", "RA_MAT", FwCodEmp("SRA") + "\SRA\RA_MAT")
			Endif
		Else
			If SRA->RA_CATFUNC == "A" .Or. !Empty(cMatUnica)
				oGetSRA2:aCols[oGetSRA2:nAt, _MATRIC]	:= fProxMat(cContrMat,.T.)	//Essa função está no GPEA265.
			Else
				oGetSRA2:aCols[oGetSRA2:nAt, _MATRIC] 	:= GetSx8Num("SRA", "RA_MAT", FWGrpCompany() + "\GRPEMP\SRA\RA_MAT")
			Endif
		EndIf

		oGetSRA21:aCols[oGetSRA2:nAt , 01]	:= oGetSRA2:aCols[oGetSRA2:nAt, _MATRIC]
		aAdd( aAutoMat, oGetSRA2:nAt )

	ElseIf lCtrAutoMat .And. (cFilate == SRA->RA_FILIAL)
	//Caso a filial "para" seja igual a filial atual do funcionario
	//atualizar a matricula para a matricula atual, visto que em uma transf de filial
	//pode ter sido criado anteriormente um novo código de matrícula
		oGetSRA2:aCols[oGetSRA2:nAt, _MATRIC] := SRA->RA_MAT
		RollBackSX8()
	EndIf
	End Sequence

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Restaura os Dados de Entrada								          ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	RestArea( aAreaSM0 )
	RestArea( aArea )
Return( lRet )


/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³ConsMat   ºAutor  ³Microsiga           º Data ³  03/18/08   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³                                                            º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function ConsMat( aCols_Aux, nLinAtu, lShowMsg, aLog, lFecEmpresa )

	Local aArea			:= GetArea()
	Local aAreaSRA		:= SRA->( GetArea() )
	Local aPerAtual		:= {}
	Local cName			:= ""
	Local cMsg			:= ""
	Local cMsgFk		:= ""
	Local cAnoMesAb		:= ""
	Local lRet			:= .T.
	Local nPos			:= 0
	Local lTeste		:= .T.
	Local cPic			:= ""
	Local nX            := 0

	DEFAULT lShowMsg	:= .T.
	DEFAULT aLog		:= {}
	DEFAULT lFecEmpresa	:= .T.

	If IsInCallStack("GP180LinOk") .Or. lRobo .Or. !oGetSRA2:lEditLine
		cEmpAte		:= aCols_Aux[nLinAtu, _EMPRES ]
		cFilAte		:= aCols_Aux[nLinAtu, _FILIAL ]
		cCcuAte		:= aCols_Aux[nLinAtu, _CCUSTO ]
		cProces		:= aCols_Aux[nLinAtu, _PROCES ]
		cDeptoAte	:= aCols_Aux[nLinAtu, _DEPTO  ]
		If (cOrgCfg == "1")
			cPostoAte := aCols_Aux[nLinAtu, _POSTO  ]
		Endif
	Else
		cEmpAte		:= M->M_EMPRESA
		cFilAte		:= M->RA_FILIAL
		cCcuAte		:= M->RA_CC
		cProces		:= M->RA_PROCES
		cDeptoAte	:= M->RA_DEPTO
		If (cOrgCfg == "1")
			cPostoAte := M->RA_POSTO
		Endif
	EndIf
	cProcesDe	:= aSvTransfCols[nLinAtu, _PROCES ]
	cCcDe		:= aSvTransfCols[nLinAtu, _CCUSTO ]

	cMatAte := If( IsInCallStack("GP180LinOk") .Or. lRobo, aCols_Aux[nLinAtu, _MATRIC], &(ReadVar()) )

	Begin Sequence

		If  ( cMatAte   <> aSvTransfCols[nLinAtu,_MATRIC]) .AND. ;
			!(cEmpAte   <> aSvTransfCols[nLinAtu,_EMPRES]) .AND. ;
			!(cFilAte   <> aSvTransfCols[nLinAtu,_FILIAL])

			If ( __lFkInUse )
				#IFNDEF STR0074
					#DEFINE STR0074 "Transferencia de matriculas nao e permitida para quem utiliza Integridade Referencial"
				#ENDIF
				If lGestPubl
					cMsgFk := STR0262										//"Relotação de matriculas nao e permitida para quem utiliza Integridade Referencial"
				Else
					cMsgFk := STR0074										//"Transferencia de matriculas nao e permitida para quem utiliza Integridade Referencial"
				Endif
				Help(" ", 1, OemToAnsi(STR0047),, OemToAnsi(cMsgFk), 1, 0 )	//"Atencao!"
				lRet := .F.
				Break
			EndIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Busca o periodo aberto atual                                 ³
			//³ Comparar data de admissao com periodo aberto, se for difente ³
			//³ nao deixa trocar matricula                                   ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If MesAno(M->RA_ADMISSA) # MesAno(dDataTra)
				If ( lShowMsg )
					Help(" ", 1, OemToAnsi(STR0047),, OemToAnsi(STR0049), 1, 0 )	//"Atencao!"###"Transferencia de matriculas so e permitida para funcionarios admitidos dentro do mes de competencia."
				Else
					aAdd( aLog, __cSvEmpAnt + " " + cFilDe + " " + cMatDe +"-" + aSvTransfCols[nLinAtu,_NOME])
					aAdd( aLog , STR0049 )
				EndIf
				lRet := .F.
				Break
			EndIf

			If lFilDif .or. lEmpDif
				If SRG->(dbSeek(M->RA_FILIAL+M->RA_MAT+MesAno(dDataTra)))
					Help(" ", 1, OemToAnsi(STR0047),, OemToAnsi(STR0197), 1, 0 )//"Funcionario tem demissao calculada no mes, e por este motivo nao foi transferido."
					lRet := .F.
					Break
				EndIF
			EndIf
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Se for apenas Transferencia de Centro de Custo nao  precisa³
		//³ validar a Matricula										          ³
		//³ Caso exista Item e Classe, utiliza o mesmo conceito.		    ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If lItemClVl
			IF ( ( cEmpAte == __cSvEmpAnt ) .and. ( cFilAte == __cSvFilAnt ) .and. (( cCcuAte # cCcDe ) .or.;
			( cProcesDe # cProces ) .or. ( cDeptoAte # cDeptoDe ) .or. ( cItemAte # cItemDe ).or. ( cClvlAte # cClvlDe ) ))
			lRet := .T.
			Break
			Endif
		Else
			IF ( ( cEmpAte == __cSvEmpAnt ) .and. ( cFilAte == __cSvFilAnt ) .and. (( cCcuAte # cCcDe ) .or.;
			( cProcesDe # cProces ) .or. ( cDeptoAte # cDeptoDe ) ))
			lRet := .T.
			Break
			Endif
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Verifica se no arquivo SRA Existe a Matricula              ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If ( cEmpAte # __cSvEmpAnt )
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Se nao Conseguiu Abrir os Arquivos da Empresa Destino      ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			IF !( fAbrEmpresa("SRA",1) )
				lRet := .F.
				Break
			EndIF
			IF ("GPESRA")->( dbSeek( RHTamFilial(__cFil,cEmpAte) + cMatAte ) ) //Neste Ponto __cFil jah foi atualizado pela fAbrEmpresa()
					cName   := ("GPESRA")->RA_NOME
					cCPFAte := ("GPESRA")->RA_CIC
			EndIF
		Else
			__cFil := IIF( Empty( xFilial("SRA") ) , xFilial("SRA",SRA->RA_FILIAL), RHTamFilial(cFilAte,cEmpAte) )
			IF SRA->( dbSeek( __cFil + cMatAte ) ) //Neste Ponto __cFil terah o conteudo de cFilAte ou Space(02)
				cName   := SRA->RA_NOME
				cCPFAte := SRA->RA_CIC
			EndIF
		Endif

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Fecha o GPESRA que foi aberto em fAbrEmpresa()             ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If ( cEmpAte # __cSvEmpAnt )
			IF ( lFecEmpresa )
				fFecEmpresa("SRA")
			EndIF
		Endif

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Verifica se Ja Existe a Matricula Informada na Empresa ou Fi³
		//³lial de Destino											             ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		IF !Empty(cName) .AND. (cMatAte <> aSvTransfCols[nLinAtu,_MATRIC])
			cFilMat 	:= RHTamFilial(cFilAte,cEmpAte) + cMatAte
			SRA->(dbSeek(cFilMat, .F.))
			cCPFDe  	:= SRA->RA_CIC

			If cCPFDe == cCPFAte .AND. lReutMat
				IF !lRobo .And. !MsgNoYes( OemToAnsi(STR0225 + Chr(013) + STR0017), OemToAnsi(STR0018))
				 	//"A matrícula digitada já existe e pertence ao mesmo funcionário. Confirma a Transferencia ?"###"Transferencia entre Filiais"
					lRet := .F.
					Break
				EndIF
			Else
				cMsg := cMatAte + " <=> " + STR0033	//"Já existe Funcionario com a Matricula Digitada. Informe nova Matricula"
				If ( lShowMsg )
					Help(" ", 1, OemToAnsi(STR0034),, OemToAnsi(cMsg), 1, 0 )//"Transferˆncia de Matricula"
				Else
					aAdd( aLog , cMsg )
				EndIf
				lRet := .F.
				Break
			EndIf
		Else
			If cMatAte <> aSvTransfCols[nLinAtu,_MATRIC]
				For nX := 1 To Len(aCols_Aux)
					If nX == nLinAtu
						Loop
					EndIf

					If cFilAte + cMatAte == aCols_Aux[nX,_FILIAL] + aCols_Aux[nX,_MATRIC]
						lRet := .F.
						cMsg := cMatAte + " <=> " + STR0033	//"Já existe Funcionario com a Matricula Digitada. Informe nova Matricula"

						If ( lShowMsg )
							Help(" ", 1, OemToAnsi(STR0034),, OemToAnsi(cMsg), 1, 0 )	//"Transferˆncia de Matricula"
						Else
							aAdd( aLog , cMsg )
						EndIf
					EndIf
				Next nX
			EndIf
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Se nao Tiver informado a Matricula						       ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		cPic 	:= PesqPict("SRE","RE_MATP")

		If  cPic == "999999"
			If ( Val(cMatAte) <= 0 .or. empty(cMatAte), lTeste := .T., lTeste := .F. )
		Else
			If ( Empty(cMatAte), lTeste := .T., lTeste := .F. )
		EndIf

		If lTeste
			cMsg := cMatAte + " <=> " + STR0071	//"Matricula Invalida"
			IF ( lShowMsg )
				Help(" ", 1, OemToAnsi(STR0034),, OemToAnsi(cMsg), 1, 0 )	//"Transferˆncia de Matricula"
			Else
				aAdd( aLog , cMsg )
			EndIF
			lRet := .F.
			Break
		EndIF

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Neste Caso seta a Diferenca de Matricula				       ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		lMatDif := ( cMatDe # cMatAte )
		lCpfDif := ( cCPFDe # cCPFAte )

		If lMatDif .And. !lRobo
			oGetSRA21:aCols[oGetSRA2:nat,1] := cMatAte
			If !IsBlind()
				oGetSRA21:Refresh()
			EndIf
		Endif
	End Sequence

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Restaura os Dados de Entrada								          ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	RestArea( aAreaSRA )
	RestArea( aArea )
Return( lRet )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³ConsCc    ºAutor  ³Microsiga           º Data ³  03/18/08   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³                                                            º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function ConsCc()

	Local aArea		:= GetArea()
	Local aTransf	   := {}
	Local cFilAux	   := ""
	Local cEmp_Aux 	:= ""
	Local cFil_aux	:= ""
	Local cDesccc	   := ""
	Local lConsCcOk	:= .T.
	Local lTransfUni := IsInCallStack( "fTransfUnico" )
	Local lMsBlql		:= .F.

	If !lTransfUni
		cEmpAte	:= If( oGetSRA2:LEDITLINE, M->M_EMPRESA, oGetSRA2:aCols[oGetSRA2:nAt, _EMPRES ] )
		cFilAte	:= If( oGetSRA2:LEDITLINE, M->RA_FILIAL, oGetSRA2:aCols[oGetSRA2:nAt, _FILIAL ] )
	Else
		cEmpAte	:= oGetTran:aCols[1,1]
		cFilAte	:= oGetTran:aCols[1,3]
		cEmp_Aux 	:= cEmpAte
		cFil_aux	:= cFilAte
	Endif

	lEmpDif	:= ( __cSvEmpAnt # cEmpAte )
	cCc 		:= &(ReadVar())

	Begin Sequence
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Centro de Custo nao Pode Estar Vazio                       ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		IF !( lConsCcOk := !Empty( cCc ) )
			Help(" ",1,"A180CCNEX") 		//--  Centro de custo não cadastrado.
			Break
		EndIF

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Verifica se no arquivo CTT Existe Centro de Custo          ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		IF ( lEmpDif )  .OR. lTransfUni
			IF !( lConsCcOk := fAbrEmpresa( cAliasCc , 1 ) )
				Break
			EndIF
			__cFil := cFilAux := totvs.framework.company.xEmpFil("CTT", cEmpAte, cFilAte)
		Else
			dbSelectArea( cAliasCc )
			__cFil := cFilAux := xFilial( cAliasCc , cFilAte )
		EndIF

		If lEmpDif
			// Caso o tamanho do Centro de Custo destino for menor que o tamanho do Centro
			// de Custo origem, impede a transferência para evitar erro de chave duplicada
			If Len(("GPE"+cAliasCc)->CTT_CUSTO) < TamSx3("RA_CC")[1]
				// "Tamanho do campo Centro de Custo"
				// "O tamanho do campo na empresa Destino é menor que o tamanho na empresa Origem. Não será possível realizar a transferência devido a conflito de integridade na migração das tabelas."
				// "Não será possível realizar a transferência devido a conflito de integridade na migração das tabelas".
				// "Compatabilizar o tamanho dos campos entre as empresas através do módulo Configurador."
				Help(,,OemToAnsi(STR0356),,OemToAnsi(STR0357)  ,1,0, NIL, NIL, NIL, NIL, NIL, {OemToAnsi(STR0358)} )
				lConsCcOk := .F.
				Break
			EndIf
		EndIf

		If	!(lEmpDif .And. (Len(cFilDe)  <> Len(cFilAte)))
			If !( lConsCcOk := CTB105CC() )
				Break
			EndIf
		Endif

		IF !lEmpDif
			(cAliasCc)->( dbSetOrder(RetOrdem("CTT","CTT_FILIAL+CTT_CUSTO")) )
		EndIf

		CTT->( dbSetOrder(1) )
		If!( lConsCcOk := ( If(lEmpDif,"GPE","")+cAliasCc )->( dbSeek( __cFil + cCc , .F. ) ) )
			Help(" ",1,"A180CCNEX")			//--  Centro de custo não cadastrado.
			Break
		EndIf

		lMsBlql		:= ( If(lEmpDif,"GPE","")+cAliasCc )->( FieldPos( "CTT_MSBLQL" ) ) != 0
		If 	lMsBlql .And. ( If(lEmpDif,"GPE","")+cAliasCc )->CTT_MSBLQL == "1"
			Help(" ",1,"REGBLOQ")
			lConsCcOk := .F.
			Break
		EndIF

		cDesccc:= DescCc( cCc , __cFil , NIL , lEmpDif )

		if oGetSRA2:LEDITLINE
			If !lTransfUni
				IF aCols[oGetSRA2:nAt , _CCUSTO]<> cCc
					aCols[oGetSRA2:nAt , _COLBMP] 	:= "BR_AZUL"
				Endif

				aCols[oGetSRA2:nAt , _DCUSTO] :=  cDesccc
				UpdFilResp(oGetSRA2, cFilAte, cCC, oGetSRA2:nAt, _CCUSTO)
				If !IsBlind()
					oGetSRA2:Refresh()
					oGetSRA1:Refresh()
				EndIf
			Else
				oGetTran:aCols[1, 6] :=  cDesccc
				UpdFilResp(oGetTran, cFilAte, "", 0, 0)
				If !IsBlind()
					oGetTran:Refresh()
				EndIf
				cEmpAte 	:= cEmp_Aux
				cFilAte 	:= cFil_Aux
			Endif
		Else
			If !lTransfUni
				IF oGetSRA2:aCols[oGetSRA2:nAt , _CCUSTO]<> cCc
					oGetSRA2:aCols[oGetSRA2:nAt , _COLBMP] 	:= "BR_AZUL"
				Endif

				oGetSRA2:aCols[oGetSRA2:nAt , _DCUSTO] :=  cDesccc
				UpdFilResp(oGetSRA2, cFilAte, cCC, oGetSRA2:nAt, _CCUSTO)
				If !IsBlind()
					oGetSRA2:Refresh()
					oGetSRA1:Refresh()
				EndIf
			Else
				oGetTran:aCols[1, 6] :=  cDesccc
				UpdFilResp(oGetTran, cFilAte, "", 0, 0)
				If !IsBlind()
					oGetTran:Refresh()
				EndIf
				cEmpAte 	:= cEmp_Aux
				cFilAte 	:= cFil_Aux
			Endif
		endIf
		lCcDif := .T.
		SetMemVar("RA_DESCCC",cDesccc)
	End Sequence

	IF ( lEmpDif )
		fFecEmpresa( cAliasCc )
	EndIF

	dbSelectArea( cAliasCc )
	RestArea( aArea )
Return( lConsCcOk )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³ConsDepto ºAutor  ³Microsiga           º Data ³  03/18/08   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³                                                            º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function ConsDepto()

	Local aArea			:= GetArea()
	Local aTransf		:= {}
	Local cFilAux		:= ""
	Local cEmp_Aux 		:= ""
	Local cFil_aux		:= ""
	Local lConsDeptoOk	:= .T.
	Local lTransfUni	:= IsInCallStack( "fTransfUnico" )
	Local cDescDepto    := ""
	Local cFilDept		:= ""
	Local lMsBlql		:= .F.
	Local cFilVisao		:= ""

	If !lTransfUni
		cEmpAte		:= oGetSRA2:aCols[oGetSRA2:nAt, _EMPRES ]
		cFilAte		:= oGetSRA2:aCols[oGetSRA2:nAt, _FILIAL ]
	Else
		cEmpAte		:= oGetTran:aCols[1,1]
		cFilAte		:= oGetTran:aCols[1,3]
		cEmp_Aux 	:= cEmpAte
		cFil_aux	:= cFilAte
	Endif

	lEmpDif		:= ( __cSvEmpAnt # cEmpAte )
	cDepto 		:= &(ReadVar())

	Begin Sequence

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Depto nao Pode Estar Vazio                                 ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		IF cOrgCfg == "1" .And. !( lConsDeptoOk := !Empty( cDepto))
			Help(" ",1,"A180DEPTONEX")       		 							//-- Departamento informado invalido ou nao cadastrado.
			Break
		EndIF

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Verifica se existo Depto                                   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If cOrgCfg == "1"
			IF ( lEmpDif ) .OR. lTransfUni
				IF !( lConsDeptoOk := fAbrEmpresa("RDK", 1 ) )
					Break
				EndIF
				IF !( lConsDeptoOk := fAbrEmpresa("RD4", 1 ) )
					Break
				EndIF
				__cFil 		:=	totvs.framework.company.xEmpFil("RD4", cEmpAte, cFilAte)
				cFilDept 	:=	totvs.framework.company.xEmpFil("SQB", cEmpAte, cFilAte)
				cFilVisao 	:=	totvs.framework.company.xEmpFil("RDK", cEmpAte, cFilAte)
			Else
				dbSelectArea( "RD4" )
				__cFil 		:= cFilAux := xFilial( "RD4" , cFilAte )
				cFilDept 	:= fWxFilial("SQB", cFilAte)
				cFilVisao 	:= fWxFilial("RDK", cFilAte)
			EndIF

			dbSelectArea("RD4")
			RD4->( dbSetOrder(RetOrdem("RD4", "RD4_FILIAL+RD4_EMPIDE+RD4_FILIDE+RD4_CODIDE")) )

			dbSelectArea("RDK")
			RDK->( dbSetOrder(RetOrdem("RDK","RDK_FILIAL+RDK_CODIGO+RDK_HIERAR+RDK_TIPO")) )

			If lConsDeptoOk := RD4->( dbSeek(__cFil + cEmpAte + cFilDept + cDepto) )
				lConsDeptoOk := .F.
				While RD4->( !Eof() ) .AND. (RD4->(RD4_FILIAL+RD4_EMPIDE+RD4_FILIDE+RD4_CODIDE) == __cFil + cEmpAte + cFilDept + cDepto)
					RDK->( dbGoTop() )
					If RDK->( dbSeek(cFilVisao + RD4->RD4_CODIGO + "11") )
						lConsDeptoOk := .T.
						cDescDepto := RD4->RD4_DESC
						Exit
					EndIf

					RD4->( dbSkip() )
				EndDo
			EndIf

			IF cOrgCfg == "1" .And. !( lConsDeptoOk )
				Help(" ",1,"A180DEPTONEX")										//-- Departamento informado invalido ou nao cadastrado.
				Break
			EndIF

			lMsBlql		:= RD4->( FieldPos( "RD4_MSBLQL" ) ) != 0
			If lMsBlql .And. RD4->RD4_MSBLQL == "1"
				Help(" ",1,"REGBLOQ")
				lConsDeptoOk	:= .F.
				Break
			EndIf

		Else
			IF ( lEmpDif ) .OR. lTransfUni
				IF !( lConsDeptoOk := fAbrEmpresa("SQB", 1 ) )
					Break
				EndIF
				__cFil := cFilAux := totvs.framework.company.xEmpFil("SQB", cEmpAte, cFilAte)
			Else
				dbSelectArea( "SQB" )
				__cFil := cFilAux := xFilial( "SQB" , cFilAte )
			EndIF

			IF  !( lConsDeptoOk := ( If(lEmpDif,"GPE","")+"SQB" )->( dbSeek( RHTamFilial(__cFil,cEmpAte) + cDepto , .F. ) ) )
				Help(" ",1,"A180DEPTONEX")										//-- Departamento informado invalido ou nao cadastrado.
				Break
			EndIF

			lMsBlql	:= (If(lEmpDif,"GPE","")+"SQB" )->( FieldPos( "QB_MSBLQL" ) ) != 0
			If lMsBlql .And. (If(lEmpDif,"GPE","")+"SQB" )->QB_MSBLQL == "1"
				Help(" ",1,"REGBLOQ")
				lConsDeptoOk	:= .F.
				Break
			EndIf
		EndIf

		if oGetSRA2:LEDITLINE

			If !lTransfUni
				aCols[oGetSRA2:nAT , _DDEPT ] :=  If(cOrgCfg == "1", cDescDepto, fDesc("SQB",  cDepto, "QB_DESCRIC"))
				IF aCols[oGetSRA2:nAt , _DEPTO]<> cDepto
					aCols[oGetSRA2:nAt , _COLBMP] 	:= "BR_AZUL"
				Endif
				If !IsBlind()
					oGetSRA2:Refresh()
					oGetSRA1:Refresh()
				EndIf
			Else
				aCols[1, 8 ] := If(cOrgCfg == "1", cDescDepto, fDesc("SQB",  cDepto, "QB_DESCRIC"))
				UpdFilResp(oGetTran, cFilAte, "", 0, 0)
				If !IsBlind()
					oGetTran:Refresh()
				EndIf
				cEmpAte 	:= cEmp_Aux
				cFilAte 	:= cFil_Aux
			Endif
		Else
			If !lTransfUni
				oGetSRA2:aCols[oGetSRA2:nAT , _DDEPT ] :=  If(cOrgCfg == "1", cDescDepto, fDesc("SQB",  cDepto, "QB_DESCRIC"))
				IF oGetSRA2:aCols[oGetSRA2:nAt , _DEPTO]<> cDepto
					oGetSRA2:aCols[oGetSRA2:nAt , _COLBMP] 	:= "BR_AZUL"
				Endif
				If !IsBlind()
					oGetSRA2:Refresh()
					oGetSRA1:Refresh()
				EndIf
			Else
				oGetTran:aCols[1, 8 ] := If(cOrgCfg == "1", cDescDepto, fDesc("SQB",  cDepto, "QB_DESCRIC"))
				UpdFilResp(oGetTran, cFilAte, "", 0, 0)
				If !IsBlind()
					oGetTran:Refresh()
				EndIf
				cEmpAte 	:= cEmp_Aux
				cFilAte 	:= cFil_Aux
			Endif
		endIf

		lDeptoDif := .T.

	End Sequence

	IF ( lEmpDif )
		fFecEmpresa("SQB" )
	EndIF

	dbSelectArea( "SQB" )

	RestArea( aArea )

Return( lConsDeptoOk )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³ConsPosto ºAutor  ³Microsiga           º Data ³  03/18/08   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Valida a digitacao do codigo do Posto                       º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function ConsPosto()
	Local aArea			:= GetArea()
	Local cFilAux		   := ""
	Local cAliasRCL    	:= "RCL"
	Local lConsPostoOk	:= .T.
	Local nQtdeOcupante	:= 0 						//-- Qte de ocupantes do posto
	Local cKeySeek
	Local lTransfUni	:= IsInCallStack( "fTransfUnico" )
	Local nPosEmpGd
	Local nPosFilGd
	Local nPosDepGd
	Local lMsBlql		:= .F.

	Local cQryQ3 		:= ''
	Local cAliasSQ3 	:= "QSQ3"

	If (cOrgCfg # "1")
		Return( lConsPostoOk )
	Endif

	If lTransfUni .And. ValType(oGetTran) == "O"
		nPosEmpGd	:= GdFieldPos("M_EMPRESA", oGetTran:aHeader)
		nPosFilGd	:= GdFieldPos("RA_FILIAL", oGetTran:aHeader)
		nPosDepGd	:= GdFieldPos("RA_DEPTO", oGetTran:aHeader)
		cEmpAte		:= oGetTran:aCols[oGetTran:nAt, nPosEmpGd ]
		cFilAte		:= oGetTran:aCols[oGetTran:nAt, nPosFilGd ]
		cDeptoAte	:= oGetTran:aCols[oGetTran:nAt, nPosDepGd ]
	Else
		cEmpAte		:= oGetSRA2:aCols[oGetSRA2:nAt, _EMPRES ]
		cFilAte		:= oGetSRA2:aCols[oGetSRA2:nAt, _FILIAL ]
		cDeptoAte := oGetSRA2:aCols[oGetSRA2:nAt, _DEPTO]
	EndIf

	lEmpDif		:= ( __cSvEmpAnt # cEmpAte )
	cPosto 		:= &(ReadVar())
	Begin Sequence

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Verifica se existo Posto                                   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		IF ( lEmpDif )
			IF !( lConsPostoOk := fAbrEmpresa("RCL", 1 ) )
				Break
			EndIF
			cAliasRCL:= "GPERCL"
			__cFil :=  cFilAux := totvs.framework.company.xEmpFil("RCL", cEmpAte, cFilAte)
		Else
			dbSelectArea( "RCL" )
			__cFil := cFilAux := xFilial( "RCL" , cFilAte )
		EndIF

		DbSelectArea(cAliasRCL)
		If Empty(cDeptoAte)
			DbSetOrder(2)
			cKeySeek:= __cFil + cPosto
		Else
			DbSetOrder(1)
			cKeySeek:= __cFil + cDeptoAte + cPosto
		EndIf

		IF !( lConsPostoOk := ( cAliasRCL )->( dbSeek(cKeySeek  , .F. ) ) )
			Help(" ",1,"A180POSTONEX") 										//-- Posto informado invalido ou nao cadatrado.
			Break
		EndIF

		lMsBlql		:= (cAliasRCL)->( FieldPos( "RCL_MSBLQL" ) ) != 0
		If lMsBlql .And. (cAliasRCL)->RCL_MSBLQL == "1"
			Help(" ",1,"REGBLOQ")
			lConsPostoOk := .F.
			Break
		EndIf

		M->RA_DEPTO := ( cAliasRCL )->RCL_DEPTO
		M->RA_POSTO := cPosto

		IF oGetSRA1:aCols[oGetSRA2:nAt, _POSTO]<> cPosto .Or. lEmpDif

			If  ( cAliasRCL )->RCL_STATUS == "3"  .OR.  (cAliasRCL )->RCL_STATUS ==  "4"
				MsgAlert( OemToAnsi(STR0144) + CRLF + ;		// "O Posto esta com  Status 'Congelado' ou 'Cancelado'."
				  		  OemToAnsi(STR0091) + CRLF , ;		// "Consulte al administrador do sistema."
			  	  		  OemToAnsi(STR0047) ) 				// "Atencao"
	 			lConsPostoOk := .F.
	 			Break
			Endif

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Verifica qtde de ocupantes no Posto. Nao deve permitir ocupacao³
			//³ultrapassando o limite de ocupantes                            ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			aEval(oGetSRA2:aCols, {|x| nQtdeOcupante+= If( ( cEmpAte +__cFil + cPosto ) ==x[_EMPRES ] + x[_FILIAL] +x[_POSTO] ,1,0) } )

			nQtdeOcupante +=  ( cAliasRCL )->RCL_OPOSTO

			If ( nQtdeOcupante  + 1 ) > ( cAliasRCL )->RCL_NPOSTO
				MsgAlert( OemToAnsi(STR0143) + CRLF  + ;			// "Excedeu a quantidade maxima de ocupantes permitida para o posto."
						  OemToAnsi(STR0091) + CRLF+CRLF , ;		// "Consulte al administrador do sistema."
			  			  OemToAnsi(STR0047) ) 						// "Atencao"
				lConsPostoOk := .F.
				Break
			Endif

			cDeptoAte  := ( cAliasRCL )->RCL_DEPTO
			cPostoAte  := ( cAliasRCL )->RCL_POSTO

			cQryQ3 := "SELECT Q3_DESCSUM FROM "
			cQryQ3 +=  RetFullName("SQ3",cEmpAte)
			cQryQ3 += " WHERE Q3_FILIAL = '" + totvs.framework.company.xEmpFil("SQ3", cEmpAte, cFilAte) + "' AND "
			cQryQ3 += " Q3_CARGO = '" + ( cAliasRCL )->RCL_CARGO + "' AND D_E_L_E_T_ = ' ' "

			cQryQ3 := ChangeQuery(cQryQ3)
			dbUseArea(.T., "TOPCONN", TCGenQry(,,cQryQ3), cAliasSQ3, .F., .T.)

			If oGetSRA2:LEDITLINE
				aCols[oGetSRA2:nAt , _DEPTO] := cDeptoAte
				aCols[oGetSRA2:nAt , _POSTO] := cPostoAte
				aCols[oGetSRA2:nAt , _DPOSTO] := iif(!(cAliasSQ3)->(EOF()),(cAliasSQ3)->Q3_DESCSUM,'')
			Else
				oGetSRA2:aCols[oGetSRA2:nAt , _DEPTO] := cDeptoAte
				oGetSRA2:aCols[oGetSRA2:nAt , _POSTO] := cPostoAte
				oGetSRA2:aCols[oGetSRA2:nAt , _DPOSTO] := iif(!(cAliasSQ3)->(EOF()),(cAliasSQ3)->Q3_DESCSUM,'')
			EndIf

			(cAliasSQ3)->(dbCloseArea())

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Atualiza os campos na Get (como gatilho)           			    ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If !lTransfUni
				if oGetSRA2:LEDITLINE
					aCols[oGetSRA2:nAt , _COLBMP] 	:= "BR_AZUL"
				Else
					oGetSRA2:aCols[oGetSRA2:nAt , _COLBMP] 	:= "BR_AZUL"
				endif
			EndIf

			If !IsBlind()
				oGetSRA2:ForceRefresh()
				oGetSRA1:ForceRefresh()
			EndIf
			lPostoDif := .T.
		EndIf
	End Sequence

	IF ( lEmpDif )
		fFecEmpresa("RCL" )
	EndIF

	dbSelectArea( "RCL" )

	RestArea( aArea )
Return lConsPostoOk

/*
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³ConsProc	  ³ Autor ³Mauricio T. Takakura   ³ Data ³02/05/2007³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Validar Transferencia de Processo                               ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<void>                                 							³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³<void>                      									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³GEPA180                    										³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
Function ConsProc()

	Local aArea		:= GetArea()
	Local cFilAux   	:= ""
	Local lProcOk	   := .T.
	Local lTransfUni := IsInCallStack( "fTransfUnico" )
	Local lMsBlql		:= .F.

	lProcDif	:= .F.
	If !lTransfUni
		cEmpAte		:= oGetSRA2:aCols[oGetSRA2:nAt , _EMPRES ]
		cFil   		:= oGetSRA2:aCols[oGetSRA2:nAt , _FILIAL ]
	Else
		cEmpAte		:= oGetTran:aCols[1,1 ]
		cFil   		:= oGetTran:aCols[1,3 ]
	Endif

	cProces		:= &(ReadVar())
	lEmpDif		:= ( __cSvEmpAnt # cEmpAte )

	Begin Sequence

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Codigo do Processo nao Pode Estar Vazio                    ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		IF !( lProcOk := !Empty( cProces ) )
			Help(" ",1,"A180PROCNEX") 					//-- "Processo informado invalido ou nao está cadastrado
			Break
		EndIF

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Verifica se existse no arquivo de Processo                 ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		IF ( lEmpDif )
			IF !( lProcOk := fAbrEmpresa( "RCJ" , 1 ) )
				Break
			EndIF
			__cFil :=  cFilAux := totvs.framework.company.xEmpFil("RCJ", cEmpAte, cFil)
		Else
			dbSelectArea( "RCJ" )
			__cFil := cFilAux := xFilial( "RCJ" , cFil )
		EndIF

		IF !( lProcOk := ( If(lEmpDif,"GPE","")+"RCJ" )->( dbSeek( __cFil + cProces , .F. ) ) )
			Help(" ",1,"A180PROCNEX") 					//-- "Processo informado invalido ou nao está cadastrado
			Break
		EndIF

		lMsBlql		:= (If(lEmpDif,"GPE","")+"RCJ" )->( FieldPos( "RCJ_MSBLQL" ) ) != 0
		If lMsBlql .And. (If(lEmpDif,"GPE","")+"RCJ" )->RCJ_MSBLQL == "1"
			Help(" ",1,"REGBLOQ")
			lProcOk := .F.
			Break
		EndIf

		if oGetSRA2:LEDITLINE

			If !lTransfUni
				aCols[oGetSRA2:nAt, _DPROCE ] :=  (If(lEmpDif,"GPE","")+"RCJ" )->RCJ_DESCRI
				IF aCols[oGetSRA2:nAt , _PROCES]<> cProces
					aCols[oGetSRA2:nAt , _COLBMP] 	:= "BR_AZUL"
				Endif
				If !IsBlind()
					oGetSRA2:Refresh()
					oGetSRA1:Refresh()
				EndIf
			Else
				oGetTran:aCols[oGetTran:nAt,10] :=  (If(lEmpDif,"GPE","")+"RCJ" )->RCJ_DESCRI
				If !IsBlind()
					oGetTran:Refresh()
				EndIf
			Endif
		Else
			If !lTransfUni
				oGetSRA2:aCols[oGetSRA2:nAt, _DPROCE ] :=  (If(lEmpDif,"GPE","")+"RCJ" )->RCJ_DESCRI
				IF oGetSRA2:aCols[oGetSRA2:nAt , _PROCES]<> cProces
					oGetSRA2:aCols[oGetSRA2:nAt , _COLBMP] 	:= "BR_AZUL"
				Endif
				If !IsBlind()
					oGetSRA2:Refresh()
					oGetSRA1:Refresh()
				EndIf
			Else
				oGetTran:aCols[oGetTran:nAt,10] :=  (If(lEmpDif,"GPE","")+"RCJ" )->RCJ_DESCRI
				If !IsBlind()
					oGetTran:Refresh()
				EndIf
			Endif
		endif
		lProcDif := .T.

	End Sequence

	IF ( lEmpDif )
		fFecEmpresa( "RCJ" )
	EndIF

	dbSelectArea( "RCJ" )

	RestArea( aArea )

Return( lProcOk )


/*/{Protheus.doc} Ch_Desl
Valida o campo RE_DESL e o seu preenchimento para indicar o motivo da transferencia entre empresas
@author jose.silveira
@since 28/03/2018
@version 12.1.17
/*/
Function Ch_Desl(cTipo)

Local nX		:= 0
Local nNumEmp	:= 0
Local cFilAux  	:= ""
Local cCGCde	:= ""
Local cCGCAte	:= ""
Local cFilParDe	:= ""
Local cFilParAte:= ""
Local aAreaAtu	:= {}
Local aAreaSM0	:= {}
Local aEmpFil	:= {}
Local lDesl   	:= .F.

//Valida conteudo do campo RE_DESL
If cTipo == "1"
	cDesl := &(ReadVar())

	If cDesl $ "11#12#13#43"
		lDesl := .T.
	Else
		if !empty(cDesl)
			If Len(cDesl) > 1
				MsgAlert( OemToAnsi( STR0344 )) //"Na transferencia entre Grupos/Empresas de CNPJ diferentes são aceitos os códigos de desligamento: 11, 12, 13 ou 43."
			Else
				MsgAlert( OemToAnsi( STR0232 )) //"Esse campo deve ser informado apenas se houver transferencia entre Grupos/Empresas de CNPJ diferentes."
			EndIf
		Endif
	EndIf

EndIf

//Valida se habilita ou nao a digitacao do campo RE_DESL
If cTipo == "2"

	If (cFilDe # cFilAte) .Or. (__cSvEmpAnt # cEmpAte .And. cFilDe == cFilAte )

		aAreaAtu	:= GetArea()
		aAreaSM0	:= SM0->( GetArea() )
		aEmpFil		:= ArrEmpFilGet()
		nNumEmp		:= Len(aEmpFil)
		cFilParDe	:= __cSvEmpAnt + PADR( cFilDe,  FWGETTAMFILIAL )
		cFilParAte	:= cEmpAte + PADR( cFilAte, FWGETTAMFILIAL )

		For nX := 1 To nNumEmp

			SM0->( MsGoto( aEmpFil[nX,3] ) )
			cFilTRF := SM0->M0_CODIGO + PADR( SM0->M0_CODFIL, FWGETTAMFILIAL )

			If cFilTRF $ ( cFilParDe + "/" + cFilParAte )
				cCGCde	:= If( cFilTRF $ cFilParDe,  SubStr(SM0->M0_CGC,1,8), cCGCde )
				cCGCAte	:= If( cFilTRF $ cFilParAte, SubStr(SM0->M0_CGC,1,8), cCGCAte )
			EndIf

			If !Empty(cCGCde) .And. !Empty(cCGCAte)
				Exit
			EndIf

		Next nX

		lDesl := cCGCde # cCGCAte

		RestArea( aAreaSM0 )
		RestArea( aAreaAtu )

	EndIf

EndIf

Return( lDesl )


/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³fConsPerAumºAutor  ³Microsiga           º Data ³  04/30/08   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Atribui valor  ao periodo para q possa ser utilizado no      º±±
±±º          ³gprchFiltro                                                  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³                                                             º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function fConsPerAum()
Local nPosPer 	:= GdFieldPos("RA_PERAUM", oGetSRA2:aHeader)

cPeriodo := oGetSRA2:aCols[oGetSRA2:nAt,nPosper]

Return(.T.)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³ConsVldCpoºAutor  ³Microsiga           º Data ³  04/30/08   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³                                                            º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function ConsVldCpo()

Local aArea			:= GetArea()
Local lRetOk 		:= .T.
Local cFilAux		:= ""
Local cCampo 		:= ""
Local cAliasCpo		:= ""
Local nAt			:= 0

cEmpAte		:= oGetSRA2:aCols[oGetSRA2:nAt, _EMPRES ]
cFilAte		:= oGetSRA2:aCols[oGetSRA2:nAt, _FILIAL ]

lEmpDif		:= ( __cSvEmpAnt # cEmpAte )
cCampo 		:= ReadVar()
nAT 		:= AT(">",cCampo)
cCampo		:= substr(cCampo,nAT+1,10)

//cConteudo 	:= &(ReadVar())
If ( nPos := ascan(oGetSRA2:AHeader, {|x| alltrim(x[2]) == alltrim(cCampo)   }  ) )  > 0
	If SXB->(DBSeek(oGetSRA2:aHeader[nPos, 9 ] ) )						//-- Verifica se tem  consulta padrao
		cAliasCpo 	:= ALLTRIM(SXB->XB_CONTEM)
	Endif
EndIf

Begin Sequence

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Abre Empresa                                               ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	IF ( lEmpDif )  .and. !empty(cAliasCpo)
		IF !( lRetOk := fAbrEmpresa(cAliasCpo, 1 ) )
			Break
		Endif
	EndIF

End Sequence

IF !empty(cAliasCpo)

	IF ( lEmpDif )
		fFecEmpresa(cAliasCpo )
	Endif
EndIF

RestArea( aArea )

Return(lRetOk)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³fVldTnoTrabºAutor ³Microsiga           º Data ³  03/18/08   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Nao permite a mudanda do tno trabalho se existe Regra       º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function fVldTnoTrab()
	Local lRetOk    := .T.

	If !Empty( GetMemVar( "RA_REGRA") )  .and. !Gpea010SeqVld( .F. , .T. )
		MsgAlert( OemToAnsi(STR0150) + CRLF +;					// "As alteracoes de Turno de Trabalho,Sequencia e Regra  deverao "
				OemToAnsi(STR0151), ;							// "ser feitas pelo programa de Trocas de Turno Quando Forem validos."
				OemToAnsi(STR0047) ) 							// "Atencao"
		lRetOk:= .F.
	Endif

Return(lRetOk)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³Grava_SRE ºAutor  ³Microsiga           º Data ³  03/18/08   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³                                                            º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function Grava_SRE( aLogTransf )

Local cMsgErr
Local lLockSre
Local lTSREP	:= SuperGetMv( "MV_TSREP" , NIL , .F. )
Local lTsaDep	:= If( SQB->(ColumnPos('QB_RHEXP'))>0, SuperGetMv("MV_TSADEP", NIL ,.F. ),.F. )
Local lGrava	:= .T.
Local aTransf	:= {}
Local dDataAnt	:= Ctod("")

Private oObjREP	:= Nil

If cEmpAnt == cEmpAte .And. cFilDe == cFilAte .And.;
	cMatDe == cMatAte .And. cCCDe == cCcuAte .And. cDeptoDe == cDeptoAte .And.;
	cItemAte == cItemDe .And. cClvlAte == cClvlDe .And.;
	cProcesDe == cProces .And. cPostoDe == cPostoAte
	 lGrava:= .F.
Endif

If lGrava
	IF ( lLockSre := RecLock( "SRE" , .T. , .F. ) )
		SRE->RE_EMPD    := cEmpAnt
		SRE->RE_FILIALD := cFilDe
		SRE->RE_MATD    := cMatDe
		SRE->RE_PROCESD := cProcesDe
		SRE->RE_CCD     := cCCDe
		SRE->RE_DEPTOD	:= cDeptoDe
		SRE->RE_POSTOD	:= cPostoDe
		SRE->RE_EMPP    := cEmpAte
		SRE->RE_FILIALP := cFilAte
		SRE->RE_MATP    := cMatAte
		SRE->RE_CCP     := cCcuAte
		SRE->RE_DATA    := dDataTra
		SRE->RE_PROCESP  := cProces
		SRE->RE_DEPTOP	:= cDeptoAte
		SRE->RE_POSTOP	:= cPostoAte
		SRE->RE_CODUNIC	:= SRA->RA_CODUNIC

		//Grava a data de integração com o TAF no campo RE_INTGTAF
		//Caso tenha integrado e exista o campo
		If SRE->(ColumnPos('RE_INTGTAF'))>0 .And. !Empty(dDataTAF)
			SRE->RE_INTGTAF  := dDataTAF
		Endif

		If lItemClvl
			SRE->RE_ITEMD	:= cItemDe
			SRE->RE_ITEMP	:= cItemAte
			SRE->RE_CLVLD	:= cClvlDe
			SRE->RE_CLVLP	:= cClvlAte
		EndIf

			If lTpDesl
				SRE->RE_DESL	:= cCodDesl
			EndIf

		SRE->RE_TRFOBS	:= cObsTra
		SRE->RE_TRFUNID	:= nNumTRF
		SRE->( MsUnlock() )
		aAdd(aFuncTran,{cEmpAnt,cFilDe,cCCDe,cMatDe,cProcesDe,cDeptoDe})

	Else
		cMsgErr := STR0075	//"Nao foi possivel Efetuar a Tranferencia para a Matricula:"
		aAdd( aLogTransf , cEmpAnt + " " + cFilDe + " " + cMatDe )
		aAdd( aLogTransf , Space(5) + cMsgErr  )
	EndIF
EndIf

If lTSREP
	If cEmpAnt <> cEmpAte .Or. cFilDe <> cFilAte .Or. cMatDe <> cMatAte .Or. cCCDe <> cCcuAte
	    oObjREP := PTSREPOBJ():New()
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Executa o WebServices TSA - Usuario Remover Centro de Custo  ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

		fTransfAll(@aTransf)
		If Len(aTransf) > 1
			dDataAnt := aTransf[Len(aTransf)-1,7]
    	Endif

		oObjREP:WSUser( 14, If(!Empty(dDataAnt),dDataAnt,NIL) , NIL , cEmpAnt+cFilDe+cMatDe, NIL, cEmpAnt+xFilial("CTT",cFilDe)+cCCDe )
	Endif

	If (cEmpAnt <> cEmpAte .Or. cFilDe <> cFilAte .Or. cMatDe <> cMatAte .Or. cDeptoDe <> cDeptoAte) .AND. lTsaDep

		oObjREP := PTSREPOBJ():New()

		//Executa o WebServices TSA - Usuario Remover Departamento
		oObjREP:WSUser( 15, If(!Empty(dDataAnt),dDataAnt,NIL) , NIL , cEmpAnt+cFilDe+cMatDe, NIL, cEmpAnt+xFilial("CTT",cFilDe)+cCCDe,,,Alltrim(cEmpAnt+xFilial("CTT",cFilDe)+cDeptoAte) )
	Endif

Endif
Return( lLockSre )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³Gpea180TraºAutor  ³Microsiga           º Data ³  03/18/08   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³                                                            º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function Gpea180Tra(aFilesTransf,cChave,lDelNovo,lGravaNovo,lDelAntigo,lRegrava,aFileReg)

	Local aAreaSRA	:= SRA->( GetArea() )
	Local nLoop
	Local nLoops

	DEFAULT aFileReg := {}
	// Dados da transferencia de Processo //
	Private aTrfPer
	Private aTrfHeader
	Private aFieldPer					// Campos de periodo da tabela
	GetPerTrf(@aTrfPer, @aTrfHeader) 	// Retorna o array com os periodos selecionados para transferencia de processo

	Private nPosProc   	:= GdFieldPos( "TRF_PROCES"	, aTrfHeader )
	Private nPosTab	   	:= GdFieldPos( "TRF_TABELA"	, aTrfHeader )
	Private nPosPerD   	:= GdFieldPos( "TRF_PERDE"	, aTrfHeader )
	Private nPosNPagoD	:= GdFieldPos( "TRF_NRODE"	, aTrfHeader )
	Private nPosRotD	:= GdFieldPos( "TRF_ROTDE"	, aTrfHeader )
	Private nPosPerP  	:= GdFieldPos( "TRF_PERPARA", aTrfHeader )
	Private nPosNPagoP	:= GdFieldPos( "TRF_NROPARA", aTrfHeader )
	Private nPosDel		:= Len(aTrfHeader)+1

	aFileReg := aClone(aFilesTransf)

	SRA->( dbSetOrder( 1 ) )

	nLoops	:= Len(aFilesTransf)

	If !lRobo
		BarGauge2Set( nLoops )
	Endif

	//Deleta registro destino
	For nLoop := 1 To nLoops

		If !lRobo
			IncProcG2( OemToAnsi( STR0040 + ": " + aFilesTransf[ nLoop , 1 ] ) ) 	//"Preparando Arquivos para a Transferência. "
		Endif

		IF ( aFilesTransf[nLoop,1] == "SRT" ) 									//Nao Pode Transferir Provisoes
			Loop
		EndIF
    	IF ( aFilesTransf[nLoop,1] == "RFE" ) //Nao Pode Transferir Marcações Originais
	    	Loop
	   EndIF
	   IF ( aFilesTransf[nLoop,1] == "RFB" ) //Nao Pode Transferir Cabeçalho da RFE
		   Loop
	   EndIF

		IF !(;
				( aFilesTransf[nLoop,1] == "SRD" );
				.and.;
				lFilDif;		//Transferencia de Filial
				.and.;
				lCgcDif;		//Diferenca de CGC
				.and.;
				!( lEmpDif );	//Não eh Transferencia de Empresa
			)
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ O conteudo do Array aFilesTransf[ nLoop, 6 ] indica se deve ³
			//³ efetuar alteracoes na tabela indica, caso seja .F. nao ira  ³
			//³ alterar nenhum registro da tabela listada					     ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			IF ( ( lDelNovo ) .and. ( aFilesTransf[ nLoop, 6 ] ) )
				//--Deletar Registro se exitir no Destino.
				If !( aFilesTransf[nLoop,1] == "SRA" )
					IF ( aFilesTransf[nLoop,1] == "SR7" )
						fDelNovo("SR3",cFilAte+cMatAte) //Deleta Primeiro os Itens
					EndIF
					If !(aFilesTransf[nLoop,1] == "SRD" .and. lEmpDif .and. !lMatDif) .And. ( !lCpfDif .And. !aFilesTransf[nLoop,1] == "SRD" )
						fDelNovo(aFilesTransf[nLoop,1],cFilAte+cMatAte)
					EndIf
				EndIf
				If ( nLoop == nLoops )
					fDelNovo("SRA",cFilAte+cMatAte)
				EndIf
			EndIf
		EndIf
	Next nLoop

	If !lRobo
		BarGauge2Set( nLoops )
	Endif

	//Inclui novos registros
	For nLoop := 1 To nLoops

		//Verifica se e possivel efetuar a transferencia
		If aFilesTransf[ nLoop, 6 ]

			If !lRobo
				IncProcG2( OemToAnsi( STR0019 + aFilesTransf[ nLoop , 1 ] ) ) //"Transferindo Arquivo: "
			Endif

			IF ( aFilesTransf[nLoop,1] == "SRT" ) //Nao Pode Transferir Provisoes
				Loop
			EndIF
			IF ( aFilesTransf[nLoop,1] == "RFE" ) //Nao Pode Transferir Marcações Originais
				Loop
			EndIF
			IF ( aFilesTransf[nLoop,1] == "RFB" ) //Nao Pode Transferir Cabeçalho da RFE
				Loop
			EndIF
			IF ( aFilesTransf[nLoop,1] $ "RHP*RHS" .And. ( lEmpDif .Or. lFilDif ) ) //Nao Pode transferir planos de saude caso haja mudanca de empresa/filial
				Loop
			EndIF

			IF ( aFilesTransf[nLoop,1] $ "SRK" .And. !(lEmpDif .Or. lFilDif) .And. lCcDif ) //Nao Pode transferir Valores Futuros caso haja mudanca de Centro de Custo
				aFilesTransf[nLoop,4] := .T.
			EndIF

			aFieldPer := aFilesTransf[nLoop,5]		// Campos do periodo para transferencia
			Gpea180Trf(;
							aFilesTransf[nLoop,1]	,;	//1-Alias
							aFilesTransf[nLoop,2]	,;	//2-Se Deleta o Autal
							aFilesTransf[nLoop,3]	,;	//3-Filial
							cChave					   ,;	//4-Chave
							lGravaNovo				   ,;	//5-Se Grava Novo
							lDelAntigo				   ,;	//6-Se Deleta o Antigo
							lRegrava				   ,;	//7-Se Regrava (Caso ja Exista)
			aFilesTransf[nLoop,4]	   ,;	//8-Se Modifica Centro de Custo Igual
			@aFileReg[nLoop];
						)
		EndIf

	Next nLoop

	//Verifica se há inclusão dos campos de turno, regra ou sequência para transferência(s)
	If nPos := AScan( aFields1, { |x| AllTrim( x ) == "RA_TNOTRAB" .OR. AllTrim( x ) == "RA_REGRA" .OR. AllTrim( x ) == "RA_SEQTURN" } ) > 0
		fGravaSpf()
	EndIf

	RestArea( aAreaSRA )
Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³Gpea180TrfºAutor  ³Microsiga           º Data ³  03/18/08   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³                                                            º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function Gpea180Trf(cAlias,lDelAtu,cFil,cChave,lGravaNovo,lDelAntigo,lRegrava,lModCcIgual,aFileReg)

	Local aRecnos		:= {}
	Local aSegmentos	:= {}
	Local aSRC			:= {}
	Local aRGB			:= {}
	Local aStruSRC		:= {}
	Local nRecnos		:= 0
	Local nSvOrder		:= ( cAlias )->( IndexOrd() )
	Local nTamSeq		:= TamSx3( "RC_SEQ" )[1]
	Local nY			:= 0
	Local cCampo 		:= ""
	Local xConteudo		:= ""
	Local cPrefix		:= PrefixoCpo( ( cAlias := Upper( AllTrim( cAlias ) ) ) )
	Local cF			:= PrefixoCpo(Upper(cAlias))+If(cAlias =='RI6',"_FILMAT","_FILIAL")
	Local cC			:= PrefixoCpo(Upper(cAlias))+"_CC"
	Local cM			:= PrefixoCpo(Upper(cAlias))+"_MAT"
	Local cD			:= PrefixoCpo(Upper(cAlias))+"_DEPTO"
	Local cCond			:= &( "{ || " + cAlias + "->" + cF + "+" + cAlias + "->" + cM + " == cChave }" )
	Local cIt			:= ""
	Local cCL			:= ""
	Local cFilAux 		:= cFilAnt
	Local nNext
	Local nRecAtu
	Local nRecAnt		:= 0
	Local nPosPer
	Local nMaxArray		:= 0
	Local nReg			:= 0
	Local nX			:= 0
	Local nPos         	:= 0
	Local nSequencia    := 0
	Local cCpoProc
	Local cCpoPer
	Local cCpoNPago
	Local cCpoRot
	Local cValProc
	Local cValPer
	Local cValNPago
	Local cValRot
	Local cSraMat
	Local lPeriodo
	Local lGrava		:= .T.
	Local lSftSeek		:= .F.
	Local lSRAxSRC		:= .F.
	Local lFechaPls     := .F.
	Local cSeekCmp		:= ""
	Local cBusca       	:= Nil
	Local cPerPon		:= GetMv( "MV_PONMES" , NIL , "" )
	Local cQuery       	:= ""
	Local cAliasSRC    	:= ""
	Local cAliasQry    	:= ""
	Local cArqTemp     	:= ""
	Local cIndTemp     	:= ""
	Local cDataAux 		:= dToS( dDataTra )
	Local dPonIni		:= CtoD('')
	Local aSQBArea		:= ("SQB")->( GetArea() )
	Local cFilialAA1	:= ""
	Local cCodFuncAA1	:= ""
	Local lAtuReg		:= .F.
	Local nPosPd		:= 0
	Local cAliasRGB		:= ""
	Local aStruRGB		:= {}
	Local lCC			:= .F.
	Local lCD			:= .F.
	Local lGP010AGRV	:= ExistBLock('GP010AGRV')
	Local lTemAltera	:= .F.
	Local aBkpSraCols   := {}
	Local aBkpSVSra 	:= {}
	Local aTmp1			:= {}
	Local aTmp2			:= {}
	Local lRespSQB		:= .F.
	Local lRespSQB1		:= .F.
	Local cPer			:= ""
	Local cProc			:= ""
	Local lGp180CPos	:= .F.

	Private lSraRelRd0	:= .T.
	Private nRd0Recno	:= 0
	Private aStruct     := {}

	If ( cAlias ) $ "REP/TM0/TM5/TMT"
	    cBusca 	:= Upper( cPrefix + "_FILFUN+" + cPrefix + "_MAT"  )
 	    cF		:= PrefixoCpo(Upper(cAlias))+"_FILFUN"
	    cCond	:= &( "{ || " + cAlias + "->" + cF + "+" + cAlias + "->" + cM + " == cChave }" )
	Elseif ( cAlias ) $ "BAU"
		cBusca 	:= Upper( cPrefix + "_FILFUN+" + cPrefix + "_MATFUN"  )
		cM	:= PrefixoCpo(Upper(cAlias))+"_MATFUN"
		cF		:= PrefixoCpo(Upper(cAlias))+"_FILFUN"
		cCond	:= &( "{ || " + cAlias + "->" + cF + "+" + cAlias + "->" + cM + " == cChave }" )
	EndIf

	__cFil 	:= cFil
	cFilAnt := cFilAte
	nOpc	:= xNopc

	If lItemClvl
		cIt	:= PrefixoCpo(Upper(cAlias))+"_ITEM"
		cCl	:= PrefixoCpo(Upper(cAlias))+"_CLVL"
	EndIf

	IF ( ChkFullName( cAlias ) )
		dbSelectArea("SRA")
		Return( NIL )
	EndIF

	//--Verifica se existe os campos Filial e Matricula no arquivo caso contrario nao trasnfere
	dbSelectArea( cAlias )

	lCC	:= Type(cC) # "U"
	lCD	:= Type(cD) # "U"

	If cAlias == 'RI6'
		dbSetOrder(4)
	Else
		dbSetOrder( RetOrdem( cAlias, cBusca ) )
	EndIf
	If (;
			( ( cAlias )->( FieldPos( cF ) ) == 0 );
			.and.;
			( ( cAlias )->( FieldPos( cM ) ) == 0 );
		)
		dbSelectArea("SRA")
		Return( NIL )
	Endif

	//--Verifica se o indice existe, senao cria indice temporario
   If ValType( cBusca ) # "U"
		If !( cBusca $ ( cAlias )->( IndexKey() ) )
			cArqTemp := CriaTrab(NIL,.F.)
			cIndTemp := ( cBusca )
			IndRegua( cAlias, cArqTemp, cIndTemp )
		EndIf
	EndIf

	//--Quando For Transferencia de Filial com CGC Diferente nao Leva SRD.
	If lItemClVl
 	    IF (;
				( cAlias $ "SRD|RIR" );
				.and.;
				(;
				 ( lFilDif .and. lCgcDif .and. !lEmpDif );
				.or.;
				 ( !lFilDif .And. !lCgcDif .And. !lEmpDif .And. (lCcDif .Or. lItemDif .Or. lClvlDif .or. lDeptoDif) );
				);
		    )
	      	  dbSelectArea("SRA")
	        Return( NIL )
	    EndIF
	Else
	    If (;
				( cAlias $ "SRD|RIR" );
				.and.;
				(;
				( lFilDif .and. lCgcDif .and. !lEmpDif );
				.or.;
				( !lFilDif .And. !lCgcDif .And. !lEmpDif .And. lCcDif .and. lDeptoDif);
				);
		    )
		     dbSelectArea("SRA")
		     Return( NIL )
	    EndIF
	EndIf

	If cAlias =="SRC"
	    aGetArea	:= GetArea()
	    nX     	 	:= 0
	    nPos		:= 0
	    nSequencia 	:= 0
	    cQuery	 	:= ""
		cAliasSRC 	:= "QSRC"
		aStruSRC  	:= SRC->( dbStruct() )

	    cQuery := "SELECT RC_FILIAL,RC_MAT, RC_PD, RC_CC,RC_SEMANA, RC_SEQ, RC_CONVOC, R_E_C_N_O_ RECNO "
	    cQuery += "	 FROM " +  RetSqlName("SRC") + " SRC " + CRLF
		cQuery += "	WHERE SRC.RC_FILIAL = '" + Substr(cChave,1,FWGETTAMFILIAL) + "'"  + CRLF
		cQuery += "	  AND SRC.RC_MAT    = '" + Substr(cChave,1+FWGETTAMFILIAL,6) + "'"  + CRLF
		cQuery += "   AND D_E_L_E_T_ = ' ' "
	    cQuery += " ORDER BY " + SqlOrder( SRC->( IndexKey() ) ) + " "	+ CRLF

	    cQuery := ChangeQuery(cQuery)

		//ABRE A EXECUCAO DA QUERY ATRIBUIDA AO SRC
		dbUseArea(.T., "TOPCONN", TCGenQry(,,cQuery), cAliasSRC, .F., .T.)

		For nX := 1 To Len(aStruSRC)
			If ( aStruSRC[nX][2] <> "C" )
				TcSetField(cAliasSRC,aStruSRC[nX][1],aStruSRC[nX][2],aStruSRC[nX][3],aStruSRC[nX][4])
			EndIf
		Next nX

		While (cAliasSrc)->( !EOF() ) .and. ( (cAliasSrc)->RC_FILIAL+(cAliasSrc)->RC_MAT == cChave )
			nPos := Ascan(aSRC,{|x|x[1]+x[2]+x[3]+x[4]+x[5] == RC_FILIAL+RC_MAT+RC_PD+RC_CC+RC_SEMANA})
			IF Empty(nPos)
				Aadd(aSRC,{ RC_FILIAL,RC_MAT,RC_PD,RC_CC,RC_SEMANA,1,{} })
				nPos:= Len(aSRC)
			Else
				//-- Qtde de lancamentos para a mesma chave
				aSRC[nPos,6]++
			Endif
			Aadd(aSRC[nPos,7], { RC_FILIAL,RC_MAT,RC_PD,RC_CC,RC_SEMANA,RC_SEQ, cCcuAte, RC_CONVOC, RECNO })
			(cAliasSrc)->( dbSkip() )
		EndDo

		//-- Gera conteudo do campo RC_SEQ
		fGeraSeq( @aSRC, nTamSeq )

		(cAliasSRC)-> (dbCloseArea())
		RestArea( aGetArea )
	EndIf

	If cAlias =="RGB"
	    aGetArea	:= GetArea()
	    nX     		:= 0
	    nPos		:= 0
	    nSequencia 	:= 0
		cQuery	 	:= ""
		cAliasRGB	:= "QRGB"
		aStruRGB	:= RGB->( dbStruct() )

	    cQuery := "SELECT RGB_FILIAL,RGB_MAT, RGB_PD, RGB_CC,RGB_SEMANA, RGB_SEQ, RGB_PERIOD, RGB_CONVOC, R_E_C_N_O_ RECNO "
	    cQuery += "	 FROM " + RetSqlName("RGB") + " RGB " + CRLF
		cQuery += "	WHERE RGB.RGB_FILIAL = '" + Substr(cChave,1,FWGETTAMFILIAL)+ "'"  + CRLF
		cQuery += "	  AND RGB.RGB_MAT    = '" + Substr(cChave,1+FWGETTAMFILIAL,6)+ "'"  + CRLF
	    cQuery += "   AND D_E_L_E_T_ = ' ' "
	    cQuery += " ORDER BY " + SqlOrder( RGB->( IndexKey() ) ) + " "	+ CRLF

	   	cQuery := ChangeQuery(cQuery)

		//ABRE A EXECUCAO DA QUERY ATRIBUIDA AO RGB
		dbUseArea(.T., "TOPCONN", TCGenQry(,,cQuery), cAliasRGB, .F., .T.)

	   	For nX := 1 To Len(aStruRGB)
			If ( aStruRGB[nX][2] <> "C" )
				TcSetField(cAliasRGB,aStruRGB[nX][1],aStruRGB[nX][2],aStruRGB[nX][3],aStruRGB[nX][4])
			EndIf
		Next nX

		While (cAliasRGB)->( !EOF() ) .and. ( (cAliasRGB)->RGB_FILIAL+(cAliasRGB)->RGB_MAT == cChave )
			nPos := Ascan(aRGB,{|x|x[1]+x[2]+x[3]+x[4]+x[5] == RGB_FILIAL+RGB_MAT+RGB_PD+RGB_CC+RGB_SEMANA})
			IF Empty(nPos)
				Aadd(aRGB,{ RGB_FILIAL,RGB_MAT,RGB_PD,RGB_CC,RGB_SEMANA,1,{} })
				nPos:= Len(aRGB)
			Else
				//-- Qtde de lancamentos para a mesma chave
				aRGB[nPos,6]++
			Endif
			Aadd(aRGB[nPos,7], { RGB_FILIAL,RGB_MAT,RGB_PD,RGB_CC,RGB_SEMANA,RGB_SEQ, cCcuAte, RGB_PERIOD, RGB_CONVOC, RECNO })
			(cAliasRGB)->( dbSkip() )
		EndDo

		//-- Gera conteudo do campo RC_SEQ
		fGeraSeq( @aRGB, nTamSeq )

		(cAliasRGB)-> (dbCloseArea())
		RestArea( aGetArea )
	EndIf

	aGetArea	:= GetArea()

	cQuery		:= ""
	cAliasQry 	:= "Qry" + cAlias
	dbSelectArea(cAlias)
	aStruct := (cAlias)->( dbStruct() )

	cQuery := "SELECT "
	For nX := 1 To len(aStruct)
			cQuery += aStruct[ nX , 1 ] + ", "
	Next nX

	cQuery += "R_E_C_N_O_ RECNO "
	cQuery += "			FROM " +  RetSqlName(cAlias) + " " + cAlias + " " + CRLF
	cQuery += "			WHERE " + cAlias + "." + cF + " = '" + Substr(cChave,1,FWSizeFilial(__cSvEmpAnt))+ "'"  + CRLF
	cQuery += "			AND	  " + cAlias + "." + cM + " = '" + Substr(cChave,1+FWSizeFilial(__cSvEmpAnt), TamSx3("RA_MAT")[1])+ "'"  + CRLF
	cQuery += "   AND D_E_L_E_T_ = ' ' "

	//So deve transferir a SPK do período aberto do ponto
	PerAponta(@dPonIni , Nil , Nil, .F.)
	If cAlias == "SPK"
		If !Empty(dPonIni)
			cQuery += "   AND PK_DATA >= '" + DtoS(dPonIni) + "' "
		Else
			//Se nao existir periodo do ponto aberto, transfere somente os registros com data a partir da data de transferencia
			cQuery += "   AND PK_DATA >= '" + DtoS(dDataTra) + "' "
		EndIf
	EndIf

	cQuery += "ORDER BY " + SqlOrder( (cAlias)->( IndexKey() ) ) + " "	+ CRLF
	cQuery := ChangeQuery(cQuery)

	//ABRE A EXECUCAO DA QUERY ATRIBUIDA AO SRC
	dbUseArea(.T., "TOPCONN", TCGenQry(,,cQuery), cAliasQry, .F., .T.)

	For nX := 1 To Len(aStruct)
		If ( aStruct[nX][2] <> "C" )
			TcSetField(cAliasQry,aStruct[nX][1],aStruct[nX][2],aStruct[nX][3],aStruct[nX][4])
		EndIf
	Next nX

	lContinua 	:= !( (cAliasQry)->( Bof() ) .And. (cAliasQry)->( Eof() ) )
	cCond		:= &( "{ || " + cAliasQry + "->" + cF + "+" + cAliasQry + "->" + cM + " == cChave }" )

Begin Transaction

	If lContinua

		lGp180CPos	:= ExistBlock("GP180CPOS")

		If cAlias == "SRR" //Guarda o período atual da folha
			cProc 	:= SRA->RA_PROCES
			fGetLastPer( @cPer, , cProc, cRtFol)

			dbSelectArea( cAliasQry )
		EndIf

		aAdd( aRecnos , RECNO )

		While !(cAliasQry)->(Eof())
			lTemAltera := .F.

		    //--Gerara novo registro se Alterou Filial Ou Empresa
			If lGravaNovo
				lSRAxSRC:= .F.
			    //-- Verifica se o CC foi trocado para tratar lancamentos do SRC
				If ( "SRC" $ cAlias )
					lSRAxSRC := ( (cAliasQry)->RC_CC # cCcDe )
				ElseIf ( "RGB" $ cAlias )
					lSRAxSRC := ( (cAliasQry)->RGB_CC # cCcDe )
				Endif
				//--FUNCAO PARA GRAVAR REGISTRO PARA NO ARQUIVO DESTINO
				fGravaNovo(cAlias,cAliasQry,lSRAxSRC, If(cAlias == "RGB",aRGB,aSRC), RECNO, lGp180CPos)
				lTemAltera := .T.
				If lGP010AGRV .And. !lEmpDif .And. (cOrgCfg == "1" .Or. lTemCpoCompl) .and. cAlias == "SRA"
					ExecBLock('GP010AGRV',.F.,.F.,{nOpc,lGrava})
				EndIf
			Endif

			//Tratamento para preencher o periodo final do plano de saude nas tabelas RHK, RHL e RHM
			//Porem, nao efetua o fechamento do plano de saude quando somente o CC for diferente
			If ( ( lFilDif ) .OR. ( lEmpDif ) )
				lFechaPls := .T.
			EndIf

			If lFechaPls .And. cAlias $ "RHK/RHL/RHM"
				dbSelectArea(cAlias)
				If ( cAlias )->( dbSeek( cChave , .F. ) )
					While ( cAlias )->( &(cAlias+"_FILIAL") + &(cAlias+"_MAT")  ) == cChave
						If ( cAlias )->( RecLock( cAlias , .F. ) )
							lTemAltera := .T.
							( cAlias )->( &(cAlias+"_PERFIM") ) := SubStr( cDataAux, 5, 2 ) + SubStr( cDataAux, 1, 4 )
							( cAlias )->( MsUnlock() )
						EndIf
						( cAlias )->( dbSkip() )
					End While
				EndIf
			 EndIf

			 //-- Se deleta registro do Antigo
			 If(( lDelAntigo ) .Or. (( lDelAtu ).And. (( lEmpDif ) .Or. (( lFilDif ) .And. ( lCgcDif )))))

				//--Deleta registro de Origem quando mudanca de Empresa
				dbSelectArea(cAlias)
				(cAlias)->(dbGoTo((cAliasQry)->RECNO))
				If ( cAlias )->( RecLock( cAlias, .F. ) )
					( cAlias )->( dbDelete() )
					( cAlias )->( MsUnlock() )
				EndIf
			Endif

			//--Nao Alterar Registro Atual Quando Empresa ou Filial
			nNext := Nil
			If lRegrava
				dbSelectArea( cAliasQry )
				lAtuReg := .F.
				nRecAtu := RECNO
				( cAlias )->( dbGoto(nRecAtu)  )

				//Manter o Centro de Custo Original no SRD
				If lCC .and. !( cAlias $ "SRD" )
					Begin Sequence
						If cAlias == "SRC"
							nPos := Ascan(aSRC,{|x|x[9] == ( cAliasQry )->RECNO} )
							If nPos # 0
									nPosPd := Ascan(aSRC,{|x|x[1]+x[2]+x[3]+x[4]+x[6]+x[8] == cChave + aSrc[nPos,3] + cCcuAte + aSrc[nPos,6] + ( cAliasQry )->RC_CONVOC} )
								If nPosPd # 0 .AND. (aSRC[nPosPd,9] <> nRecAtu .AND. !(lModCcIgual .and. ( cAliasQry )->(FieldGet( FieldPos ( cC )) ) # cCcDe ))
									nRecAnt	:= nRecAtu
									lAtuReg	:= .T.
								EndIf
								( cAlias )->( dbGoto(nRecAtu)  )
								If cAlias == 'SRA'
									PcoDetLan("000086","01","GPEA180")
								Endif
								RecLock(cAlias)

								If  ( cAliasQry )->(FieldGet( FieldPos ( cF ) )) # cFilAte
										lTemAltera := .T.
									FieldPut( FieldPos ( cF ) , cFilAte )
								Endif

								SRC->RC_SEQ := aSRC[nPos,6]
							Else
								If cAlias == 'SRA'
									PcoDetLan("000086","01","GPEA180")
								Endif
								RecLock(cAlias)

								If  ( cAliasQry )->(FieldGet( FieldPos ( cF ) )) # cFilAte
										lTemAltera := .T.
									FieldPut( FieldPos ( cF ) , cFilAte )
								Endif
							EndIf
						ElseIf cAlias == "RGB"
							nPos := Ascan(aRgb,{|x|x[10] == ( cAliasQry )->RECNO})
							If nPos # 0
								nPosPd := Ascan(aRgb,{|x|x[1]+x[2]+x[3]+x[4]+x[6]+x[8]+x[9] == cChave + aRgb[nPos,3] + cCcuAte + aRgb[nPos,6] + ( cAliasQry )->RGB_PERIOD + ( cAliasQry )->RGB_CONVOC	} )
								If nPosPd # 0 .AND. (aRgb[nPosPd,10] <> nRecAtu .AND. !(lModCcIgual .and. ( cAliasQry )->(FieldGet( FieldPos ( cC )) ) # cCcDe ))
									nRecAnt	:= nRecAtu
									lAtuReg	:= .T.
								EndIf
								( cAlias )->( dbGoto(nRecAtu)  )
								If cAlias == 'SRA'
									PcoDetLan("000086","01","GPEA180")
								Endif
								RecLock(cAlias)

								If  ( cAliasQry )->(FieldGet( FieldPos ( cF ) )) # cFilAte
									FieldPut( FieldPos ( cF ) , cFilAte )
										lTemAltera := .T.
								Endif

								RGB->RGB_SEQ := aRgb[nPos,6]
							Else
								If cAlias == 'SRA'
									PcoDetLan("000086","01","GPEA180")
								Endif
								RecLock(cAlias)

								If  ( cAliasQry )->(FieldGet( FieldPos ( cF ) )) # cFilAte
									FieldPut( FieldPos ( cF ) , cFilAte )
										lTemAltera := .T.
								Endif
							EndIf
						Else
							( cAlias )->( dbGoto(nRecAtu)  )

							If cAlias == 'SRA'
								PcoDetLan("000086","01","GPEA180")
							Endif

							RecLock(cAlias)
							If  ( cAliasQry )->(FieldGet( FieldPos ( cF ) )) # cFilAte
								FieldPut( FieldPos ( cF ) , cFilAte )
									lTemAltera := .T.
							Endif

						EndIf

						//So alterar o Centro de Custo do que seja igual ao Centro de Custo
						//do Cadastro de Funcionarios
						If lModCcIgual .and. ( cAliasQry )->(FieldGet( FieldPos ( cC ) )) # cCcDe
							Break
						EndIF
						//Altera os Centros de Custo
						If ( cAliasQry )->(FieldGet( FieldPos ( cC ) )) # cCcuAte
							If cAlias == "SRO"
								// Se a "Data da transferencia" for anterior à "Data final da tarefa" Ou
								// A "Data final da tarefa" está em branco e o CC na SRO era o mesmo que estava na SRA antes da Transferencia
								If dDataTra <= (cAliasQry)->RO_DATAATE .Or. ;
								(Empty((cAliasQry)->RO_DATAATE) .And. AllTrim(&(cC)) == AllTrim(cCCDe))
									FieldPut( FieldPos ( cC ) , cCcuAte )
									lTemAltera := .T.
								EndIf
							ElseIf cAlias == "SRR"
								If(( cAliasQry )-> RR_PERIODO == cPer)
									FieldPut( FieldPos ( cC ) , cCcuAte )
									lTemAltera := .T.
								Else
									lTemAltera := .F.
								EndIf
							ElseIf cAlias $ "SP8|SPC" .And. !Empty(dPonIni)
								If ( cAliasQry )->&(cPrefix + "_DATA") >= dPonIni
									FieldPut( FieldPos ( cC ), cCcuAte )
									lTemAltera := .T.
								Else
									lTemAltera := .F.
								EndIf
							Else
								FieldPut( FieldPos ( cC ) , cCcuAte )
								lTemAltera := .T.
								If lAtuReg
									If cAlias == "SRC"
										SRC->RC_HORAS += ( cAliasQry )->RC_HORAS
										SRC->RC_VALOR += ( cAliasQry )->RC_VALOR
									ElseIf cAlias == "RGB"
										RGB->RGB_HORAS += ( cAliasQry )->RGB_HORAS
										RGB->RGB_VALOR += ( cAliasQry )->RGB_VALOR
									EndIf
								EndIf
							EndIf
						Endif
						If ( cAliasQry )->(FieldGet( FieldPos ( cD ) )) # cDeptoAte
							FieldPut( FieldPos ( cD ) , cDeptoAte )
							lTemAltera := .T.
						Endif
						If lItemClVl
							If ( cAliasQry )->(FieldGet( FieldPos ( cIt ) )) # cItemAte
								FieldPut( FieldPos ( cIt ) , cItemAte )
								lTemAltera := .T.
							Endif
	   						If ( cAliasQry )->(FieldGet( FieldPos ( cCl ) )) # cClvlAte
								FieldPut( FieldPos ( cCl ) , cClvlAte )
								lTemAltera := .T.
							Endif
						EndIf
					End Sequence
				Else
					( cAlias )->( dbGoto(nRecAtu)  )
					If cAlias == 'SRA'
						PcoDetLan("000086","01","GPEA180")
					Endif
					RecLock(cAlias)

					If  ( cAliasQry )->(FieldGet( FieldPos ( cF ) )) # cFilAte
						FieldPut( FieldPos ( cF ) , cFilAte )
						lTemAltera := .T.
					Endif
				Endif

				//Manter o Departamento Original no SRD
				If lCD .and. !( "SRD" $ cAlias )
					Begin Sequence
					   //So alterar o Departamento do que seja igual ao Departamento do Cadastro de Funcionarios
					   If lModCcIgual .and. FieldGet( FieldPos ( cD ) ) # cDeptoDe
						    Break
					   EndIf
					   //Altera Departamento
					   If FieldGet( FieldPos ( cD ) ) # cDeptoAte
						 	FieldPut( FieldPos ( cD ) , cDeptoAte )
							lTemAltera := .T.
						Endif
					End Sequence
				Endif

				//Alterar o periodo na transferencia de processo e filial
				//Transferencia das tabelas de movimentos abaixo
				If (!Empty(aFieldPer) .and. !( "SRD" $ cAlias ) .and. lProcDif) .Or. ( cAlias == "SRA" )
					If cAlias == "SRA" .and. ( cPaisLoc $ "MEX*DOM*COS"  )
						cRotFol := fGetRotOrdinar()

						cValProc	  := (cAlias)->(RA_PROCES)
						cValPer 	  := (cAlias)->(RA_PERADM)
						cValNPago := (cAlias)->(RA_PAGADM)
						cValPer 	  := "INGRESO"
						cValNPago := Space( GetSx3Cache( "RCH_NUMPAG" , "X3_TAMANHO" ) )
						nPosPer := aScan( aTrfPer, { |x| x[nPosTab]+x[nPosProc]+x[nPosPerD]+x[nPosNPagoD]+x[nPosRotD] == cAlias+cValProc+cValPer+cValNPago+cRotFol } )
						If nPosPer > 0
							cValPer 	:= aTrfPer[nPosPer,nPosPerP]
							cValNPago	:= aTrfPer[nPosPer,nPosNPagoP]
							FieldPut( FieldPos ( "RA_PERADM" ), cValPer )
							FieldPut( FieldPos ( "RA_PAGADM" ), cValNPago )
							lTemAltera := .T.
						EndIf

						cValPer   	:= (cAlias)->(RA_PERAUM)
						cValNPago	:= (cAlias)->(RA_PAGAUM)
						cValPer 	   := "AUMENTO"
						cValNPago	:= Space( GetSx3Cache( "RCH_NUMPAG" , "X3_TAMANHO" ) )

						nPosPer := aScan( aTrfPer, { |x| x[nPosTab]+x[nPosProc]+x[nPosPerD]+x[nPosNPagoD]+x[nPosRotD] == cAlias+cValProc+cValPer+cValNPago+cRotFol } )
						If nPosPer > 0
							cValPer 	:= aTrfPer[nPosPer,nPosPerP]
							cValNPago	:= aTrfPer[nPosPer,nPosNPagoP]
							FieldPut( FieldPos ( "RA_PERAUM" ), cValPer )
							FieldPut( FieldPos ( "RA_PAGAUM" ), cValNPago )
							lTemAltera := .T.
						EndIf

						If cProces <> (cAlias)->(RA_PROCES)
							FieldPut( FieldPos ( "RA_PROCES" ), cProces )
							lTemAltera := .T.
						EndIf
					ElseIf cAlias == "SRA" .And. MV_MODFOL $ "1*2" .and. !cPaisLoc $ "MEX*DOM*COS"
						If cProces <> (cAlias)->(RA_PROCES)
							FieldPut( FieldPos ( "RA_PROCES" ), cProces )
							lTemAltera := .T.
						EndIf
					EndIf

					 //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					 //³Grava campos complementares                                 ³
					 //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If (cOrgCfg == "1" .Or. lTemCpoCompl ) .and. cAlias == "SRA"
						nMaxArray	:= Len(aSRAHeader)

						For nX := 1 To nMaxArray
							SetMemVar( aSRAHeader[ nX , 02 ] ,aSRACols[ nPosAtu, nX ]  , .T. )
						Next nX

						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³Chamada da funcao de gravacao do SRA                        ³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						aBkpSraCols := aClone(aSRACols)
						aBkpSVSra := aClone(aSvSraCols)

						aadd(aTMP1,aSRACols[nPosAtu])
						aadd(aTMP2,aSvSraCols[nPosAtu])
						aSRACols := {}
						aSvSraCols := {}
						aSRACols := aClone(aTMP1)
						aSvSraCols := aClone(aTMP2)


						lGrava :=  Gpea010Put(cAlias , 4 , nRecAtu , 1  , @cSraMat, aSegmentos)

						aSRACols := aBkpSraCols
						aSvSraCols := aBkpSVSra

						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³Ponto de Entrada apos a gravacao dos Registros				   ³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						If lGrava
							If lGP010AGRV
								ExecBLock('GP010AGRV',.F.,.F.,{nOpc,lGrava})
							Endif
						EndIf
					Endif

				    If cAlias == 'SRA'
						PcoDetLan("000086","02","GPEA180")
						SRA->RA_RHEXP := Space(6)
				    Endif
	        	Endif

          		If ( cAliasQry )->(FieldGet( FieldPos ( cM ) )) # cMatAte
					FieldPut( FieldPos ( cM ) , cMatAte )
					lTemAltera := .T.
			    Endif

				//Alterar o periodo na transferencia de processo e filial
				//Transferencia do funcionario acima ou em GRAVANOVO
				If (!Empty(aFieldPer) .and. !( "SRD" $ cAlias ) .and. lProcDif) .Or. ( cAlias == "SRA" )
				    If cAlias <> "SRA"
						// Tratamento para a troca de periodos //
						cCpoProc	:= aFieldPer[1]
						cCpoPer	:= aFieldPer[2]
						cCpoNPago	:= aFieldPer[3]
						cCpoRot	:= aFieldPer[4]

						lPeriodo := (!Empty( cCpoProc ) .and. !Empty( cCpoPer ) .and. !Empty( cCpoNPago ))
						If lPeriodo
							cValProc	:= ( cAlias )->( &cCpoProc )
							cValPer 	:= ( cAlias )->( &cCpoPer )
							cValNPago	:= ( cAlias )->( &cCpoNPago )
							If !Empty(cCpoRot)
								cValRot	:= ( cAlias )->( &cCpoRot )
								nPosPer := aScan( aTrfPer, { |x| x[nPosTab]+x[nPosProc]+x[nPosPerD]+x[nPosNPagoD]+x[nPosRotD] == cAlias+cValProc+cValPer+cValNPago+If(Empty(cValRot), Space( GetSx3Cache( "RCH_ROTEIR" , "X3_TAMANHO" ) ), cValRot) }  )
							Else
								nPosPer := aScan( aTrfPer, { |x| x[nPosTab]+x[nPosProc]+x[nPosPerD]+x[nPosNPagoD] == cAlias+cValProc+cValPer+cValNPago }  )
							EndIf
							If nPosPer > 0
								If aTrfPer[nPosPer,nPosDel]
									( cAlias )->( dbDelete() )
								Else
									FieldPut( FieldPos ( cCpoPer ), aTrfPer[nPosPer,nPosPerP] )
									FieldPut( FieldPos ( cCpoNPago ), aTrfPer[nPosPer,nPosNPagoP] )
									FieldPut( FieldPos ( cCpoRot ), aTrfPer[nPosPer,nPosRotD] )
									FieldPut( FieldPos ( cCpoProc ), cProces )
									lTemAltera := .T.
								EndIf
							Else
								FieldPut( FieldPos ( cCpoProc ), cProces )
								lTemAltera := .T.
							EndIf
						EndIf
					EndIf
				EndIf
				( cAlias )->( MsUnlock() )

				If lAtuReg
					( cAlias )->( dbGoto(nRecAnt)  )
					Reclock(cAlias,.F.)
					( cAlias )->( dbDelete() )
					MsUnLock()
					lTemAltera := .T.
				EndIf
	    	EndIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Se houve algum tipo de alteracao que envolva os campos do  |
			//| indice, devera procurar pela chave novamente.			   ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If !lEmpDif .and. (lMatDif .or. lFilDif)
				dbSelectArea(cAliasQry)
				nRecnos := 0
				While ( ( ++nRecnos ) <= Len( aRecnos ) )
					If aRecnos[ nRecnos ] == RECNO
    	        		dbSelectArea( cAliasQry )
    	        		( cAliasQry )->( dbSkip() )
    	        		If ( aScan( aRecnos, RECNO ) == 0 )
    	        			aAdd( aRecnos , RECNO )
							Exit
						EndIF
					EndIF
				EndDo
			Else
				dbSelectArea(cAliasQry)
	        	If ( "SRA" $ cAliasQry )
	        		Exit
	        	EndIf
	        	If nNext != NIL
	        		( cAliasQry )->( dbGoto(nNext) )
	        	Else
	        		( cAliasQry )->( dbSkip() )
				EndIf
			EndIf
		Enddo
	EndIf
	(cAliasQry)-> (dbCloseArea())

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Grava os Acumulados                                         ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		IF cAlias == "SRD"
			aFileReg[7] := .F.
		Else
			aFileReg[7] := lTemAltera
		EndIf
	If ( ( cAlias == "SRD" ) .and. ( lEmpDif ) )
		fGravaSrd( cChave, cAlias )
			aFileReg[7] := .T.
	EndIF

	cFilAnt:= cFilDe
	dbSelectArea("SQB")
	dbSetOrder(4)
	dbSeek(xFilial('SQB') + cCcDe)
	While xFilial('SQB') + cCcDe == SQB->QB_FILIAL + SQB->QB_CC
		If cMatde == SQB->QB_MATRESP  .And. cAlias == "SRA"
			If lRespSQB1 .Or. ( lRespSQB := iif( !lRobo , MsgNoYes( OemToAnsi( STR0198)  , OemToAnsi( STR0148 ) ) , .T. ) )
			   	If lRespSQB
			   		Reclock("SQB",.F.)
			   		SQB->QB_FILRESP:= ""
			   		SQB->QB_MATRESP:= ""
			   		MsUnlock()
			   	Endif
			EndIf
			lRespSQB1 := .T.
		Endif
		DbSkip()
	EndDo
	cFilAnt:= cFilAte

End Transaction

IF	cAlias == 'RI6'
	( cAlias )->( dbSetOrder(4) )
Else
	( cAlias )->( dbSetOrder ( nSvOrder ) )
Endif
dbSelectArea("SRA")

cFilAnt := cFilAux

//Exclui arquivo de indice temporario se houver
If !Empty( cArqTemp )
	( cAlias )->( dbCloseArea() )
	FErase( cArqTemp + OrdBagExt() )
EndIf

RestArea( aSQBArea )

Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³SRAnterior ºAutor  ³Microsiga           º Data ³  03/18/08   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³                                                               º±±
±±º          ³                                                               º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                            º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function SRAnterior( cFilMat , dDtDemissao , aLogTransf, lTsRep )
	Local aAreaSRA		:= SRA->(GetArea())
	Local lSra_AntOk	:= .T., nRecno := 0

Private cOldCracha	:= SRA->RA_CRACHA

Begin Sequence

	IF ChkFullName( "SRA" )
		Break
	EndIF

	IF !( lSra_AntOk := SRA->( MsSeek( cFilMat, .F. ) ) )
		aAdd( aLogTransf , __cSvEmpAnt + " "+ cFilDe + " " + cMatDe )			//-- "Nao existe o Funcionario na Filial de Origem:"
		aAdd( aLogTransf , Space(5) + STR0076  )
		Break
	EndIF

		IF !( lSra_AntOk := RecLock( "SRA" , .F. ) ) 							// Bloqueio registro SRA
		aAdd( aLogTransf , __cSvEmpAnt + " "+ cFilDe + " "  + cMatDe ) 			//--  "Nao foi possivel atualizar o Cadastro de Funcionarios na Origem:"
		aAdd( aLogTransf , Space(5) + STR0079 )
		Break
	EndIF

	SRA->RA_CRACHA := Space( GetSx3Cache( "RA_CRACHA" , "X3_TAMANHO" ) ) 		//Limpar o cracha para que nao fique duplicado no indice
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Utilizamos RetSituacao para Gravar a Data de Demissao,  Codigo³
	//³de Rescisao RAIS e FGTS e a Situacao da Folha                 ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	RetSituacao( cFilDe , cMatDe , .T. , dDtDemissao )

	If lTSREP
		SRA->(DbClearFil())
		SRA->(DbGoTop())
		If SRA->(DbSeek(cFilDe + cMatDe))
			RecLock("SRA",.F.)
			SRA->RA_RHEXP := Space(6)
        	// Efetua o envio das informacoes para o TSA sobre o registro antigo do SRA
        	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
        	//³ Executa o WebServices TSA - Pessoa Fisica e Usuario          ³
        	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If oObjREP:WSNatural( 1 ) .And. oObjREP:WSUser( 1 )
	        	 //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	         	//³ Grava as informacoes de controle de log de integracao WebServices TSA ³
	         	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				oObjRep:WSUpdRHExp( "SRA" )
			Endif
			SRA->( MsUnlock() )
		EndIf

		Fil180Browse()
		SRA->(DbGoTop())
	Endif

End Sequence
	RestArea( aAreaSRA )

Return( lSra_AntOk )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³Check_CGC    ºAutor  ³Microsiga           º Data ³  03/18/08   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³                                                               º±±
±±º          ³                                                               º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                            º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function Check_Cgc( aSRA_Aux, aSvSRA_Aux )

Local aArea		:= GetArea()
Local aAreaSM0	:= SM0->( GetArea() )
Local aCGC_Aux	:= {}
Local cCGCDe	   := ""
Local cCGCPara 	:= ""
Local cNomeDe   	:= ""
Local cNomePara := ""
Local nPos		:= 0
Local nX		   := 0

For nX:= 1 to Len(aSRA_Aux)
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Obtem o CGC da Empresa de Origem							       ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If SM0->( dbSeek( __cSvEmpAnt + aSvSRA_Aux[nX,2]  ) )
		cCgcDe   := SM0->M0_CGC
		cNomeDe  := SM0->M0_FILIAL
	Endif
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Obtem o CGC da Empresa de Destino							       ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	IF SM0->( dbSeek( aSRA_Aux[nX,1] + aSRA_Aux[nX,2]  ) )
		cCgcPara 	:= SM0->M0_CGC
		cNomePara 	:= SM0->M0_FILIAL
	EndIF

	If ( nPos:= Ascan(aCGC_Aux,{|x| x[1]+x[3] == (__cSvEmpAnt + aSvSRA_Aux[nX,2] )  + ( aSRA_Aux[nX,1] + aSRA_Aux[nX,2]  )    }   ) 	) <= 0
		aadd(aCGC_aux, {__cSvEmpAnt + aSvSRA_Aux[nX,2], ;	//1- Empresa+Filial De
		                                       cNomeDe , ;
		                                       cCgcDe  , ;
                        aSRA_Aux[nX,1] + aSRA_Aux[nX,2],;	//4- Empresa+Filial De
                                               cNomePara ,;
                                               cCgcPara ,;
                                               If( Len(cCgcPara) == 11, "2", "1" )  } )
	Endif

Next nX

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Restaura os Dados de Entrada								          ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
( RestArea( aAreaSM0 ) , RestArea( aArea ) )
Return( aCGC_Aux )

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³Gpea180Vis³ Autor ³ Kleber Dias Gomes     ³ Data ³ 13/07/99 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Programa de visualizacao Cadastro de Transferencias         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³Gpea180Vis(ExpC1,ExpN1,ExpN2)                               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Alias do arquivo                                   ³±±
±±³          ³ ExpN1 = Numero do registro                                 ³±±
±±³          ³ ExpN2 = Numero da opcao selecionada                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³GPEA180                                                     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Function Gpea180Vis(cAlias,nReg,nOpcx)

Local aAdvSize		:= {}
Local aInfoAdvSize	:= {}
Local aObjSize		:= {}
Local aObjCoords	   := {}

Local aAdv1Size		:= {}
Local aInfo1AdvSize	:= {}
Local aObj1Size		:= {}
Local aObj1Coords	:= {}

Local aTransf		:= {}
Local cTitulo		:= ""
Local cFilMat		:= SRA->( RA_FILIAL + RA_MAT )
Local lOrigem		:= .T.
Local nCnt		:= 0
Local nSavRec		:= 0
Local nOpcA		:= 0
Local nOpcNewGd	:= IF( nOpcx == 2 , 0 , GD_INSERT + GD_UPDATE + GD_DELETE )
Local nOpReal   := 0
Local oDlg4
Local oFont
Local oGroup
Local oGet
Local cInitPad
Local bInitPad
Local cInitPadAt
Local bInitPadAt
Local cInitPadBL
Local bInitPadBL

// Posicoes dos campos somente para gestao publica
Local   aGdAltera    := {}
Private nPOSGP_TPDATO:= 0
Private nPosGP_DTBLEG:= 0
Private nPosGP_TPBLEG:= 0
Private nPosGP_NRBLEG:= 0
Private nPosGP_COMPL := 0
Private nPosGP_ATO   := 0
Private nPosGP_BL    := 0
Private aMemos 		 := {}

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Nao Permitir que Funcionario de Outra Filial seja Visualizado³
//³ em Funcao de estar sendo Monstrado na mBrowse()              ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
IF SRA->RA_FILIAL != xFilial( "SRA" )
	Return( NIL )
EndIF
nSavRec     		:= RecNo()
cAlias      		:= "SRE"

//Tratamento da variavel nOpcx devido a montagem do MenuDef de acordo com o
//conteudo do paramentro MV_GSPUBL (lUsadoGP = .T.). Se for 2-Sim, tera uma
//opcao a mais, isto e, Manutencao
//(modelo antigo, não aplicado ao SIGAGFP Gestão de Folha Publica)
If lUsadoGP
    If nOpcx = 4
        nOpReal := 2 //excluir
    ElseIf nOpcx = 3
        nOpReal := 3 //manutencao
    Else
        nOpReal := 1 //visualizar
    EndIf
Else
    If nOpcx = 3
        nOpReal := 2 //excluir
    Else
        nOpReal := 1 //visualizar
    EndIf
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Verifica Exclusao                                            ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If nOpReal = 2
	cMsgNoYes := STR0080	//"Não é recomendada a Exclusão de Transferências."
	cMsgNoYes += CRLF
	cMsgNoYes += STR0081	//"Se for confirmada a Exclusão, apenas os Registros de Transferências"
	cMsgNoYes += STR0082	//"do SRE serão eliminados. Os Dados do Funcionário permanecerão inalterados."
	cMsgNoYes += CRLF
	cMsgNoYes += STR0083	//"Confirma a Exclusão?"

	IF !( MsgNoYes( OemToAnsi( cMsgNoYes )  , cCadastro ) )
		dbSelectArea("SRA")
		dbGoTo(nSavRec)
		Return( .F. )
	EndIF
Endif

Private aAC    := { STR0003,STR0001 } //"Abandona"###"Confirma"

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Checar Transferencias (Todas as Transferencias)            ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
fTransfAll(@aTransf)

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Verifica se Funcionario teve Transferencias                  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
IF ( nCnt := Len(aTransf) ) == 0
	Help(" ",1,"A180SLANC")
	dbSelectArea("SRA")
	dbGoTo(nSavRec)
	Return( .F. )
EndIF

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Monta a entrada de dados do arquivo                          ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Private aTELA[0,0],aGETS[0],aHeader[0],nUsado:=0

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Monta o cabecalho                                            ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
dbSelectArea( "SX2" )
dbSeek( cAlias )
dbSelectArea( "SX3" )
dbSetOrder(1)
dbSeek( cAlias )

While !Eof() .And. ( X3_ARQUIVO == cAlias )
	If X3USO(X3_USADO) .And. cNivel >= X3_NIVEL .Or.;
		(AllTrim(X3_CAMPO)=="RE_EMPD" .Or. AllTrim(X3_CAMPO)=="RE_EMPP" .Or.;
		AllTrim(X3_CAMPO)=="RE_FILIALD" .Or. AllTrim(X3_CAMPO)=="RE_FILIALP")
		nUsado++
		cTitulo := ""
		If AllTrim(X3_CAMPO) == "RE_FILIALD"
			cTitulo:= OemToAnsi(STR0127)
		ElseIf AllTrim(X3_CAMPO) == "RE_FILIALP"
			cTitulo:= OemToAnsi(STR0128)
		ElseIf AllTrim(X3_CAMPO) == "RE_EMPD"
			cTitulo:= OemToAnsi(STR0129)
		ElseIf AllTrim(X3_CAMPO) == "RE_EMPP"
			cTitulo:= OemToAnsi(STR0130)
		Else
			cTitulo:= AllTrim(X3TITULO())
		EndIf
		aAdd(aHeader,{cTitulo,X3_CAMPO,X3_PICTURE,X3_TAMANHO,X3_DECIMAL,X3_VALID,X3_USADO,X3_TIPO,X3_ARQUIVO,X3_RELACAO})
	Endif
	SX3->( dbSkip() )
EndDo

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Posiciona ponteiro do arquivo cabeca e inicializa variaveis  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
dbSelectArea( cAlias )
dbSetOrder( 2 )
Private aCols[nCnt,nUsado]
Private aColsAnt := {}

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Carrega aCols com o Conteudo de aTransf (Todas as   Transferen³
//³cias.                                                         ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
For nCnt := 1 To Len(aTransf)
	nUsado:=0
	dbSelectArea( "SX3" )
	dbSeek( cAlias )
	While !Eof() .And. X3_ARQUIVO == cAlias
		IF X3USO(X3_USADO) .And. cNivel >= X3_NIVEL .Or.;
		   (AllTrim(X3_CAMPO)=="RE_EMPD" .Or. AllTrim(X3_CAMPO)=="RE_EMPP" .Or.;
		   AllTrim(X3_CAMPO)=="RE_FILIALD" .Or. AllTrim(X3_CAMPO)=="RE_FILIALP")
		  	nUsado++
			IF AllTrim(X3_CAMPO) == "RE_EMPD"
			   aCols[nCnt,nUsado] := aTransf[nCnt,1]
			ElseIF Alltrim(X3_CAMPO) == "RE_DEMPORI"//descrição empresa de origem
				aCols[nCnt,nUsado] := POSICIONE("SM0",1,aTransf[nCnt,1],"M0_NOME")
			ElseIF AllTrim(X3_CAMPO) == "RE_FILIALD"
		    	aCols[nCnt,nUsado] := aTransf[nCnt,8]
		    ElseIF Alltrim(X3_CAMPO) == "RE_DFILORI" //descrição filial origem
			    aCols[nCnt,nUsado] := Posicione("SM0",1,aTransf[nCnt,1]+aTransf[nCnt,8],"M0_FILIAL")
		    ElseIF AllTrim(X3_CAMPO) == "RE_MATD"
		    	aCols[nCnt,nUsado] := aTransf[nCnt,9]
		    ElseIF AllTrim(X3_CAMPO) == "RE_CCD"
		    	aCols[nCnt,nUsado] := aTransf[nCnt,3]
		    ElseIF AllTrim(X3_CAMPO) == "RE_DCCORI" //descrição centro de custo origem
		    	aCols[nCnt,nUsado] := GetCttDesc(aTransf[nCnt,1], aTransf[nCnt,8], aTransf[nCnt,3])
		   	ElseIF AllTrim(X3_CAMPO) == "RE_EMPP"
		    	aCols[nCnt,nUsado] := aTransf[nCnt,4]
		    ElseIF AllTrim(X3_CAMPO) == "RE_DEMPDES"  //descrição empresa destino
			    aCols[nCnt,nUsado] := POSICIONE("SM0",1,aTransf[nCnt,4],"M0_NOME")
		    ElseIF AllTrim(X3_CAMPO) == "RE_FILIALP"
		    	aCols[nCnt,nUsado] := aTransf[nCnt,10]
		    ElseIF AllTrim(X3_CAMPO) == "RE_DFILDES" //descrição filial destino
				aCols[nCnt,nUsado] := Posicione("SM0",1,aTransf[nCnt,4] + aTransf[nCnt,10],"M0_FILIAL")
		    ElseIF AllTrim(X3_CAMPO) == "RE_MATP"
		    	aCols[nCnt,nUsado] := aTransf[nCnt,11]
		    ElseIF AllTrim(X3_CAMPO) == "RE_CCP"
		    	aCols[nCnt,nUsado] := aTransf[nCnt,6]
		    ElseIF AllTrim(X3_CAMPO) == "RE_DCCDES" //descrição centro de custo destino
				aCols[nCnt,nUsado] := GetCttDesc(aTransf[nCnt,4], aTransf[nCnt,10], aTransf[nCnt,6])
		    ElseIF AllTrim(X3_CAMPO) == "RE_DATA"
		    	aCols[nCnt,nUsado] := aTransf[nCnt,7]
		    ElseIF AllTrim(X3_CAMPO) == "RE_PROCESD"
		    	aCols[nCnt,nUsado] := aTransf[nCnt,14]
		    ElseIF AllTrim(X3_CAMPO) == "RE_PROCESP"
		    	aCols[nCnt,nUsado] := aTransf[nCnt,15]
		    ElseIF AllTrim(X3_CAMPO) == "RE_DEPTOD"
		    	aCols[nCnt,nUsado] := aTransf[nCnt,16]
		    ElseIF AllTrim(X3_CAMPO) == "RE_DDPTORI" //descrição departamento de origem
		    	aCols[nCnt,nUsado] := POSICIONE("SQB",1,xFilial("SQB")+aTransf[nCnt,16],"QB_DESCRIC")
		    ElseIF AllTrim(X3_CAMPO) == "RE_DEPTOP"
		    	aCols[nCnt,nUsado] := aTransf[nCnt,17]
		    ElseIF AllTrim(X3_CAMPO) == "RE_DDPTDES" // descrição departamento destino
		    	aCols[nCnt,nUsado] := POSICIONE("SQB",1,xFilial("SQB")+aTransf[nCnt,17],"QB_DESCRIC")
		    ElseIF AllTrim(X3_CAMPO) == "RE_POSTOD"
		       	aCols[nCnt,nUsado] := aTransf[nCnt,18]
		    ElseIF AllTrim(X3_CAMPO) == "RE_POSTOP"
		       	aCols[nCnt,nUsado] := aTransf[nCnt,19]
			 ElseIf 	lItemClvl .and. AllTrim(X3_CAMPO) == "RE_ITEMD"
		       	aCols[nCnt,nUsado] := aTransf[nCnt,20]
			 ElseIf 	lItemClvl .and. AllTrim(X3_CAMPO) == "RE_ITEMP"
		       	aCols[nCnt,nUsado] := aTransf[nCnt,21]
			 ElseIf 	lItemClvl .and. AllTrim(X3_CAMPO) == "RE_CLVLD"
				aCols[nCnt,nUsado] := aTransf[nCnt,22]
			 ElseIf 	lItemClvl .and. AllTrim(X3_CAMPO) == "RE_CLVLP"
		       	aCols[nCnt,nUsado] := aTransf[nCnt,23]
			 ElseIf 	AllTrim(X3_CAMPO) == "RE_TRFUNID"
		       	aCols[nCnt,nUsado] := aTransf[nCnt,24]
			 ElseIf 	AllTrim(X3_CAMPO) == "RE_TRFOBS"
		       	aCols[nCnt,nUsado] := aTransf[nCnt,25]
			ElseIf 	AllTrim(X3_CAMPO) == "RE_DESL"
		       	aCols[nCnt,nUsado] := aTransf[nCnt,26]
			 ElseIf 	AllTrim(X3_CAMPO) == "RE_INTGTAF"
		       	aCols[nCnt,nUsado] := aTransf[nCnt,27]
		    EndIF
		EndIF
		dbSelectArea("SX3")
		SX3->( dbSkip() )
	EndDo
Next nCnt

If nOpcx # 5
	DbSelectArea( "SX3" )
	SX3->(DbSetOrder(2))
	If dbSeek("RE_CMEMO")
		Aadd(aMemos,{"RE_CMEMO","RE_COMPL","RE6"})
	Endif
	M->RE_COMPL := "" // Inicializa variavel de memoria para nao gerar erro na gravacao

	// GUARDA A POSICAO DOS CAMPOS DA GESTAO PUBLICA PARA ALTERACAO NO OBJETO
	If lUsadoGP 		// SE RE_TPDATO ESTA EM USO ENTAO SABEMOS QUE EH GESTAO PUBLICA (modelo antigo, não aplicado ao SIGAGFP Gestão de Folha Publica)
	   					// GUARDANDO POSICOES
		nPOSGP_TPDATO:= GdFieldPos( "RE_TPDATO",aHeader )
		nPosGP_DTBLEG:= GdFieldPos( "RE_DTBLEG",aHeader )
		nPosGP_TPBLEG:= GdFieldPos( "RE_TPBLEG",aHeader )
		nPosGP_NRBLEG:= GdFieldPos( "RE_NRBLEG",aHeader )
		nPosGP_COMPL := GdFieldPos( "RE_COMPL" , aHeader) 	// Posicao do campo MEMO
		nPosGP_ATO   := GdFieldPos( "RE_DESCAT" , aHeader)
		nPosGP_BL    := GdFieldPos( "RE_DESCBL" , aHeader)

		// Campos alteraveis
		aAdd( aGdAltera , "RE_TPDATO" )
		aAdd( aGdAltera , "RE_DTBLEG" )
		aAdd( aGdAltera , "RE_TPBLEG" )
		aAdd( aGdAltera , "RE_NRBLEG" )
	 	AAdd( aGdAltera , "RE_COMPL" )

		dbSelectArea( "RE6" )
		dbSelectArea( "SX3" )

	   // Monta bloco para inicializador padrao para descricao do ato
		cInitPadAt := RTrim( aHeader[ nPosGP_ATO , 10] )
		bInitPadAt := &( "{ || " + cInitPadAt + "}" )

	   // Monta bloco para inicializador padrao para descricao da Base Legal
		cInitPadBL := RTrim( aHeader[ nPosGP_BL , 10] )
		bInitPadBL := &( "{ || " + cInitPadBL + "}" )

	   // Monta bloco para inicializador padrao para o campo memo re_compl
		cInitPad := RTrim( aHeader[ nPosGP_COMPL , 10] )
		bInitPad := &( "{ || " + cInitPad + "}" )

	   // abastece aCols com o conteudo do Arquivo SRE
		For nCnt:=1 To Len(aTransf)
			SRE->(DbGoTo(aTransf[nCnt,13]))
			aCols[nCnt,nPosGP_TPDATO] := SRE->RE_TPDATO
			aCols[nCnt,nPosGP_DTBLEG] := SRE->RE_DTBLEG
			aCols[nCnt,nPosGP_TPBLEG] := SRE->RE_TPBLEG
			aCols[nCnt,nPosGP_NRBLEG] := SRE->RE_NRBLEG
			aCols[nCnt,nPosGP_COMPL ] := Eval( bInitPad )
			aCols[nCnt,nPosGP_ATO]    := Eval( bInitPadAT )
			aCols[nCnt,nPosGP_BL]     := Eval( bInitPadBL )
			If nOpcx == 6
				aAdd( aRecnosT, aTransf[nCnt,13])  //Array que guarda os Recnos para serem utilizados na funcao GPEA180Grava para posicionar na SRE.
			EndIf
	   Next nCnt
	   aColsAnt := aClone(aCols)      //Copy de aCols para verificar na funcao Gpea180Grava se houve alteracao nos dados p/ gravar na SRE
	EndIf
Endif

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Monta as Dimensoes dos Objetos  		       				      ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
aAdvSize		:= MsAdvSize()
aInfoAdvSize	:= { aAdvSize[1] , aAdvSize[2] , aAdvSize[3] , aAdvSize[4] , 5 , 5 }
aAdd( aObjCoords , { 000 , 025 , .T. , .F. } )		//1-Cabecalho Dados Funcionario
aAdd( aObjCoords , { 000 , 000 , .T. , .T. } )		//2-Itens Transferencia
aObjSize		:= MsObjSize( aInfoAdvSize , aObjCoords )

//Divisao em colunas Linha 1-Cabecalho Dados Funcionario
aAdv1Size		:= aClone(aObjSize[1])
aInfo1AdvSize	:= { aAdv1Size[2] , aAdv1Size[1] , aAdv1Size[4] , aAdv1Size[3] , 1 , 1 }
aAdd( aObj1Coords , { 055 , 000 , .F. , .T. } )	//1-Matricula
aAdd( aObj1Coords , { 000 , 000 , .T. , .T. } )	//2-Nome
aAdd( aObj1Coords , { 040 , 000 , .F. , .T. } )	//3-Admissao
aObj1Size		:= MsObjSize( aInfo1AdvSize , aObj1Coords,,.T. )

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Mostra o corpo dos valores variaveis                 ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
nOpcA := 0

SetaPilha()
	DEFINE FONT oFont NAME "Arial" SIZE 0,-11 BOLD
	DEFINE MSDIALOG oDlg4 TITLE OemToAnsi(STR0008) From aAdvSize[7],0 TO aAdvSize[6],aAdvSize[5] OF GetWndDefault() PIXEL

	@ aObj1Size[1,1] , aObj1Size[1,2] GROUP oGroup TO aObj1Size[1,3], aObj1Size[1,4]	LABEL OemToAnsi(STR0022) OF oDlg4 PIXEL	// "Matricula:"
	oGroup:oFont:= oFont
	@ aObj1Size[2,1] , aObj1Size[2,2] GROUP oGroup TO aObj1Size[2,3], aObj1Size[2,4]	LABEL OemToAnsi(STR0023) OF oDlg4 PIXEL	// "Nome:"
	oGroup:oFont:= oFont
	@ aObj1Size[3,1] , aObj1Size[3,2] GROUP oGroup TO aObj1Size[3,3], aObj1Size[3,4]	LABEL OemToAnsi(STR0041) OF oDlg4 PIXEL	// "Admissao:"
	oGroup:oFont:= oFont
	@ aObj1Size[1,1]+10 , aObj1Size[1,2]+5		SAY StrZero(Val(SRA->RA_MAT),Len(SRA->RA_MAT))	SIZE 050,10 OF oDlg4 PIXEL FONT oFont
	@ aObj1Size[2,1]+10 , aObj1Size[2,2]+5		SAY OemToAnsi(SRA->RA_NOME) 					SIZE 146,10 OF oDlg4 PIXEL FONT oFont
	@ aObj1Size[3,1]+10 , aObj1Size[3,2]+5		SAY Dtoc(SRA->RA_ADMISSA)						SIZE 050,10 OF oDlg4 PIXEL FONT oFont

	oGet := MSGetDados():New(aObjSize[2,1],aObjSize[2,2],aObjSize[2,3],aObjSize[2,4],nOpcx,"" ,"" ,""      ,If(nOpcx=2,Nil,.F.), aGdAltera,2)

	ACTIVATE MSDIALOG oDlg4 ON INIT EnchoiceBar(oDlg4,{||nOpcA:=1,oDlg4:End()},{||oDlg4:End()}) CENTERED

	If lUsadoGP .AND. nOpcx == 4 .AND. nOpcA == 1  //(modelo antigo de Gestao Publica, não aplicado ao SIGAGFP Gestão de Folha Publica)
		Gpea180Grava( cAlias )
	EndIF

SetaPilha()

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Restaura a integridade da janela                           ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
cAlias := "SRA"
dbSelectArea( cAlias )
dbSetOrder( 1 )
SRA->( MsGoto( nSavRec ) )

Return( NIL )

/*/{Protheus.doc} fAbrEmpresa
Abre o Arquivo da Outra Empresa
@author Wilson de Godoy
@since 03/01/2001
@return lRet, lógico, indica se a tabela foi aberta ou não
@param cAlias, characters, Alias da tabela que será aberta
@param nOrdem, numeric, Ordem utilizada na tabela
@param cEmpPara, characters, Grupo de empresa que deverá ser aberto - Dafault: Empresa destino informada na transferência
@param cFilPara, characters, Filial do grupo que será utilizada - Default: Filial destino informada na transferência
@example
	fAbrEmpresa("SQB", 11, "T2", "L MG 01 ")
@history 01/09/2018, Cícero Alves, Adicionado os parâmetros cEmpPara e cFilPara
/*/
Function fAbrEmpresa(cAlias, nOrdem, cEmpPara, cFilPara)

	Local cModo
	Local lRet
	Local cSvFilAnt := cFilAnt

	Default cEmpPara := cEmpAte
	Default cFilPara := cFilAte

	If ( lRet := MyEmpOpenFile("GPE" + cAlias, cAlias, nOrdem, .T., cEmpPara, @cModo) )
		__cFil := totvs.framework.company.xEmpFil(cAlias, cEmpPara, cFilPara)
		dbSelectArea( "GPE" + cAlias )
	Else
		MsgAlert( OemToAnsi( STR0039 + cAlias )  )
	EndIF

	cFilAnt := cSvFilAnt

Return( lRet )

/*
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³fFecEmpresa	 ³ Autor ³Wilson de Godoy        ³ Data ³03/01/2001³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Fecha o Arquivo da Outra Empresa                        		    ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³ cAlias - Alias do Arquivo a Ser Fechado						       ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
Function fFecEmpresa( cAlias )

IF Select("GPE"+cAlias) > 0
	("GPE"+cAlias)->(dbCloseArea())
EndIF

Return( .T. )

/*
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³Ch_Dat    ³ Autor ³Marinaldo de Jesus     ³ Data ³09/06/2000³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Verifica se a Data Informada e Valida Para a Transferencia  ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
Static Function Ch_Dat( dData , lShowMsg ,  aLog, cPer ,cProc )

Local lChDatOk	:= .T.
Local cMsgLog		:= ""

DEFAULT lShowMsg	:= .T.
DEFAULT aLog		:= {}
DEFAULT cProc		:= ""

Begin Sequence

	If Empty(dData)
		cMsgLog := iif(lGestPubl, OemToAnsi(STR0261), OemToAnsi( STR0193 ))  //Data de transferencia e obrigatoria!
		lChDatOk	:= .F.
	EndIf

	If lChDatOk
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Transferencia nao pode ser posterior ao mes de calculo da folha ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If ( MesAno( dDataTra ) > cPer .Or. MesAno( dDataTra ) < cPer ) .And. !( Empty(cPer) )
			 cMsgLog := iif(lGestPubl, OemToAnsi( STR0260 ), OemToAnsi(STR0200)) //"Transferencias não são permitidas em meses Posteriores ou Anteriores ao atual mês de cálculo da Folha de Pagamento "
			 cMsgLog += cProc + " - (" + SubStr( cPer, 5, 2 ) + "/" + SubStr( cPer, 1, 4 ) + ")."
		     lChDatOk	:= .F.
		EndIf
	EndIf

End Sequence

If !( lChDatOk )
	If !Empty( cMsgLog )
		If ( lShowMsg )
			MsgAlert( cMsgLog )
		ElseIf IsBlind()
			Help("",1,"Help",,cMsgLog,1)
		Else
			aAdd( aLog , cMatDe  + "<=>" + cMsgLog )
		EndIF
	EndIF
EndIF
Return( lChDatOk )

/*
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³fGravaNovo	  ³ Autor ³Mauro Sergio Testoni   ³ Data ³25/08/2000³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Gravar Novos Registor na Empresa Destino              			³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³cAlias - Alias do Arquivo                                       ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
Static Function fGravaNovo(cAlias,cAliasQry,lSRAxSRC,aSRC, nRecno, lGp180CPos)

	Local aArea			:= GetArea()
	Local aAreaTIT
	Local aAreaSRA
	Local aConteudo		:= {}
	Local cCampo		:= ""
	Local cDataType		:= ""
	Local cNewAlias		:= IF( lEmpDif , ( "GPE"+cAlias ) , cAlias )
	Local nCampo		:= 0
	Local nNumCamp 		:= Len(aStruct)
	Local nConteudo		:= 0
	Local nPos			:= 0
	Local nPosFilMat	:= 0
	Local nLoops 		:= 0
	Local nLoop			:= 0
	Local nPosFilial	:= 0
	Local nPosMat		:= 0
	Local nPosCC		:= 0
	Local cCpoFil 		:= PrefixoCpo(Upper(cAlias))+If(cAlias =='RI6',"_FILMAT","_FILIAL")//PrefixoCpo(Upper(cAlias))+"_FILIAL"
	Local cCpoCc 		:= PrefixoCpo(Upper(cAlias))+"_CC"
	Local cCpoMat 		:= PrefixoCpo(Upper(cAlias))+"_MAT"
	Local cCpoDepto		:= PrefixoCpo(Upper(cAlias))+"_DEPTO"
	Local cCpoPosto		:= PrefixoCpo(Upper(cAlias))+"_POSTO"
	Local cCpoProc		:= ""
	Local cCpoPer		:= ""
	Local cCpoNPago		:= ""
	Local cCpoRot		:= ""
	Local cValProc		:= ""
	Local cValPer 		:= ""
	Local cValNPago		:= ""
	Local cValRot		:= ""
	Local cCpoHrs		:= ""
	Local cCpoVlr		:= ""
	Local cChvRGB		:= ""
	Local cBkpEmpAnt
	Local cValAPer
	Local cValANPago
	Local cValIPer
	Local cValINPago
	Local cSvAlias
	Local lDelPer		:= .F.	// Se o periodo foi deletado pelo usuario nao gravar
	Local lPeriodo
	Local cCpoItem 		:= ""
	Local cCpoClvl		:= ""
	Local uValor
	Local lRecLock  	:= .T.
	Local cTypeCampo
	Local nOrderAux		:= ( cAlias )->( IndexOrd() )
	Local nProcTmp 		:= 0
	Local nFilTmp 		:= 0
	Local aGP180Cpos 	:= {}

	DEFAULT lSRAxSRC	:= .F.
	DEFAULT lGp180CPos	:= .F.

	// Tratamento para a troca de periodos //
	If !Empty(aFieldPer)
		cCpoProc	:= aFieldPer[1]
		cCpoPer	:= aFieldPer[2]
		cCpoNPago	:= aFieldPer[3]
		cCpoRot	:= aFieldPer[4]
	EndIf
	lPeriodo := (!Empty( cCpoProc ) .and. !Empty( cCpoPer ) .and. !Empty( cCpoNPago ))

	If cAlias $ ("SRA|SR8")
		nPosFilial 	:= GdFieldPos("RA_FILIAL", aSRAHeader)
		nPosMat    	:= GdFieldPos("RA_MAT", aSRAHeader)
	EndIf

	If lItemClvl
		cCpoItem 		:= PrefixoCpo(Upper(cAlias))+"_ITEM"
		cCpoClvl 		:= PrefixoCpo(Upper(cAlias))+"_CLVL"
	EndIf

	If cAlias $ "SRA|RFX"
		aAreaSRA := (cAlias)->(GetArea())
		(cAlias)->(dbGoto( (cAliasQry)->RECNO))
	EndIf

	//-- Salva o Registro Origem no Array aconteudo
	For nCampo := 1 To nNumCamp
		cCampo 		:= FieldName(nCampo)
		cDataType	:= FWSX3Util():GetFieldType( cCampo )
		uValor		:= FieldGet(nCampo)
		// Tabelas que possuem os campos de periodo //
		If lPeriodo
			If cCpoProc == AllTrim(cCampo)
				cValProc := uValor
			Elseif cCpoPer == AllTrim(cCampo)
				cValPer := uValor
			Elseif cCpoNPago == AllTrim(cCampo)
				cValNPago := uValor
			ElseIf !Empty( cCpoRot ) .and. cCpoRot == AllTrim(cCampo)
				cValRot := uValor
			EndIf
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Carrega novo conteudo do campo alterado na transferencia      ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If cAlias == "SRA"
			If !( cCampo $ ( "RA_FILIAL*RA_MAT*RA_CC*RA_DEPTO*RA_POSTO*RA_PROCES*RA_ITEM*RA_CLVL")  )
				If ( nPos       := aScan(aSRAHeader, {|x| ALLTRiM(x[2]) == cCampo } ) ) > 0  .and. ;
					(nPosFilMat	:= Ascan(aSRACols, {|x| x[nPosFilial] + x[nPosMat] = (cFilAte)  + (cMatAte) } ) )  > 0
					If !(aSRACols[nPosFilMat, nPos] == uValor )
							uValor	:= aSRACols[nPosFilMat, nPos]
					Endif
				Endif
			EndIf

			If aStruct[nCampo][1] == "RA_OBSDEFI"
				aAdd(aConteudo,{aStruct[nCampo][1],SRA->RA_OBSDEFI,"M"})
			EndIf

		ElseIf cAlias == "SR8"
			If cCampo == "R8_PROCES"
				nProcTmp := ascan(aSRAHeader, { |x| ALLTRiM(x[2]) == "RA_PROCES" } )
				nFilTmp  := ascan(aSRACols, {|x| x[nPosFilial] + x[nPosMat] = (cFilAte)  + (cMatAte) } )

				If (nProcTmp > 0) .AND. (nFilTmp > 0)
					uValor	:= aSRACols[nFilTmp, nProcTmp]
				EndIf
			Endif
		ElseIf cAlias == "RFX"
			If aStruct[nCampo][1] == "RFX_OBSEST"
				aAdd(aConteudo, {aStruct[nCampo][1], RFX->RFX_OBSEST, "M"})
			EndIf
		ElseIf !lEmpDif .And. cAlias == "TIT"
			If cCampo == "TIT_CODIGO"

				(cAlias)->(DbGoto(nRecno))
				cCodTIT	:= (cAlias)->TIT_CODIGO

				aAreaTIT 	:= (cAlias)->(GetArea())

				(If(lEmpDif,"GPE","")+"TIT" )->(dbSetOrder( 1 ))

				uValor := GETSXENUM("TIT","TIT_CODIGO")
				// Verifica se Código já não existe na Empresa/Filial Destino
				While (If(lEmpDif,"GPE","")+"TIT" )->( dbSeek(cFilAte + uValor))
					uValor := GETSXENUM("TIT","TIT_CODIGO")
				End

				// Move tabela TIU
				fGrvTIU(cFilDe,cMatDe,cCodTIT,uValor)

				RestArea(aAreaTIT)

			EndIf
		Endif

		If cCampo=="RC_CC" .OR. cCampo=="RGB_CC"
			nPosCC	:= nCampo
		EndIf

		aAdd(aConteudo,{cCampo,uValor,cDataType})
	Next nCampo

	If cAlias $ "SRA|RFX"
		RestArea(aAreaSRA)
	EndIf

	If lGp180CPos
		aGP180Cpos := ExecBlock("GP180CPOS", .F., .F., {cAlias, aConteudo})
		If ((ValType(aGP180Cpos) == "A") .And. (!Empty(aGP180Cpos)))
			aConteudo := aGP180Cpos
		Endif
	Endif

	If lPeriodo
		If cAlias == "SRR"
			If SRR->RR_TIPO3 == 'R'
				cSvAlias := "SRG"
			Else
				cSvAlias := "SRH"
			EndIf
		Else
			cSvAlias := cAlias
		EndIf

		If Empty(cCpoRot)	// Tabela que nao possui roteiro
			nPosPer := aScan( aTrfPer, { |x| x[nPosTab]+x[nPosProc]+x[nPosPerD]+x[nPosNPagoD] == cSvAlias+cValProc+cValPer+cValNPago } )
		Else
			nPosPer := aScan( aTrfPer, { |x| x[nPosTab]+x[nPosProc]+x[nPosPerD]+x[nPosNPagoD]+x[nPosRotD] == cSvAlias+cValProc+cValPer+cValNPago+If(Empty(cValRot), Space( GetSx3Cache( "RCH_ROTEIR" , "X3_TAMANHO" ) ), cValRot) }  )
		EndIf
		If nPosPer > 0
			If aTrfPer[nPosPer,nPosDel]
				lDelPer	:= .T.
			Else
				cValProc 	:= cProces
				cValPer 	:= aTrfPer[nPosPer,nPosPerP]
				cValNPago	:= aTrfPer[nPosPer,nPosNPagoP]
				cValRot	:= aTrfPer[nPosPer,nPosRotD]
			EndIf
		Else
			If !IsBlind()
				// Se não existir período correspondente carregado em aTrfPer para RGB
				// pela tela de seleção de períodos, esse período não deverá ser transferido
				// sendo assim considerado como DELETADO.
				If cAlias == "RGB"
					lDelPer	:= .T.
				EndIf
			EndIf
		EndIf
	EndIf

	// Gerar transferencia dos periodos de admissao e Aumento de Salario //
	If cPaisLoc == "MEX" .and. cAlias == "SRA"
		cRotFol 	:= fGetRotOrdinar()
		cValIPer 	:= (cAlias)->(RA_PERADM)
		cValINPago	:= (cAlias)->(RA_PAGADM)
		cValAPer 	:= (cAlias)->(RA_PERAUM)
		cValANPago	:= (cAlias)->(RA_PAGAUM)

		cValProc 	:= (cAlias)->(RA_PROCES)
		cValPer 	:= (cAlias)->(RA_PERADM)
		cValNPago	:= (cAlias)->(RA_PAGADM)
		cValPer 	:= "INGRESO"
		cValNPago	:= Space( GetSx3Cache( "RCH_NUMPAG" , "X3_TAMANHO" ) )

		nPosPer := aScan( aTrfPer, { |x| x[nPosTab]+x[nPosProc]+x[nPosPerD]+x[nPosNPagoD]+x[nPosRotD] == cAlias+cValProc+cValPer+cValNPago+cRotFol }  )
		If nPosPer > 0
			cValIPer 	:= aTrfPer[nPosPer,nPosPerP]
			cValINPago	:= aTrfPer[nPosPer,nPosNPagoP]
		EndIf

		cValPer 	:= (cAlias)->(RA_PERAUM)
		cValNPago	:= (cAlias)->(RA_PAGAUM)
		cValPer 	:= "AUMENTO"
		cValNPago	:= Space( GetSx3Cache( "RCH_NUMPAG" , "X3_TAMANHO" ) )

		nPosPer := aScan( aTrfPer, { |x| x[nPosTab]+x[nPosProc]+x[nPosPerD]+x[nPosNPagoD]+x[nPosRotD] == cAlias+cValProc+cValPer+cValNPago+cRotFol }  )
		If nPosPer > 0
			cValAPer 	:= aTrfPer[nPosPer,nPosPerP]
			cValANPago	:= aTrfPer[nPosPer,nPosNPagoP]
		EndIf
	EndIf

	If !lDelPer

		If cAlias == "SRD" .And. lEmpDif
			//Esta transferindo os registros vindos de outra transferencia entre empresas
			If !Empty( (cAliasQry)->RD_EMPRESA ) .OR. (Empty( (cAliasQry)->RD_EMPRESA)  .AND. lReutMat)
				If !lItemClvl
					//Encontrou a matricula na empresa destino
					If (cNewAlias)->(dbSeek( cFilAte + cMatAte +(cAliasQry)->RD_DATARQ+(cAliasQry)->RD_PD+(cAliasQry)->RD_SEMANA+(cAliasQry)->RD_SEQ+(cAliasQry)->RD_CC ))
						//nao enviar os lancamento pois eles já existem na empresa
						RestArea( aArea )
						Return( NIL )
					ElseIf (cAliasQry)->RD_EMPRESA == cEmpAte .AND. lReutMat
						//nao enviar os lancamento que vieram desta empresa
						RestArea( aArea )
						Return( NIL )
					EndIf
				Else
					//Encontrou a matricula na empresa destino
					(cNewAlias)->(DBsetOrder(RetOrder(cNewAlias,"RD_FILIAL + RD_MAT + RD_DATARQ + RD_PD + RD_SEMANA + RD_SEQ + RD_CC + RD_ITEM + RD_CLVL")))
					If (cNewAlias)->(dbSeek( cFilAte + cMatAte +(cAliasQry)->RD_DATARQ+(cAliasQry)->RD_PD+(cAliasQry)->RD_SEMANA+(cAliasQry)->RD_SEQ+(cAliasQry)->RD_CC+RD_ITEM+RD_CLVL ))
						//nao enviar os lancamento pois eles já existem na empresa
						RestArea( aArea )
						Return( NIL )
					ElseIf (cAliasQry)->RD_EMPRESA == cEmpAte .AND. lReutMat
						//nao enviar os lancamento que vieram desta empresa
						RestArea( aArea )
						Return( NIL )
					EndIf
				EndIf
			EndIf
		EndIf


		If  cAlias == "RI6"
			cCod := RI6CODITE()
		Endif

		If cNewAlias == "SRF" .And. SRF->(MsSeek(cFilAte + SRA->RA_MAT + DTOS(aConteudo[FieldPos("RF_DATABAS"),2]) + aConteudo[FieldPos("RF_PD"),2]))
			lRecLock := .F.
		ElseIf cAlias == "RGB"
			If !litemClvl
				(cNewAlias)->(DbSetOrder(RetOrder(cAlias,"RGB_FILIAL+RGB_PROCES+RGB_MAT+RGB_PERIOD+RGB_SEMANA+RGB_ROTEIR+RGB_PD+RGB_CC+RGB_SEQ+DTOS(RGB_DTREF)")))
				cChvRGB := (cNewAlias)->( cFilAte + aConteudo[FieldPos("RGB_PROCES"),2] + cMatAte + aConteudo[FieldPos("RGB_PERIOD"),2] ;
											+  aConteudo[FieldPos("RGB_SEMANA"),2] +  aConteudo[FieldPos("RGB_ROTEIR"),2] ;
											+  aConteudo[FieldPos("RGB_PD"),2] + cCcuAte)
			Else
				(cNewAlias)->(DbSetOrder(RetOrder(cAlias,"RGB_FILIAL+RGB_PROCES+RGB_MAT+RGB_PERIOD+RGB_SEMANA+RGB_ROTEIR+RGB_PD+RGB_CC+RGB_ITEM+RGB_CLVL+RGB_SEQ+DTOS(RGB_DTREF)")))
				cChvRGB := (cNewAlias)->( cFilAte + aConteudo[FieldPos("RGB_PROCES"),2] + cMatAte + aConteudo[FieldPos("RGB_PERIOD"),2] ;
											+  aConteudo[FieldPos("RGB_SEMANA"),2] +  aConteudo[FieldPos("RGB_ROTEIR"),2] ;
											+  aConteudo[FieldPos("RGB_PD"),2] + cCcuAte + RGB_ITEM + RGB_CLVL)
			EndIf

			If (cNewAlias)->(MsSeek(cChvRGB))
				lRecLock := .F.
				cCpoHrs := PrefixoCpo(Upper(cAlias))+"_HORAS"
				cCpoVlr := PrefixoCpo(Upper(cAlias))+"_VALOR"
			EndIf
		ElseIf cAlias == "SRC"
			(cNewAlias)->(DbSetOrder(RetOrder(cNewAlias,"RC_FILIAL+RC_MAT+RC_PD+RC_CC+RC_SEMANA+RC_SEQ")))
			If (cNewAlias)->(MsSeek(cFilAte + cMatAte +  aConteudo[FieldPos("RC_PD"),2] + cCcuAte 	+ aConteudo[FieldPos("RC_SEMANA"),2]))
				lRecLock := .F.
				cCpoHrs := PrefixoCpo(Upper(cAlias))+"_HORAS"
				cCpoVlr := PrefixoCpo(Upper(cAlias))+"_VALOR"
			EndIf
		EndIf

		//--Append de um novo registro
		RecLock( cNewAlias , lRecLock )

			nConteudo := Len(aConteudo)
			//--Grava o aConteudo origem na nova Filial ou Empresa
			For nCampo := 1 To nConteudo
				//--Monta nome do Novo Campo
				cCampo := aConteudo[nCampo,1]

				//--Verifica se Campo existe na Empresa Para
				If cCampo == "RECNO" .or. cCampo == 'RA_USERLGA' .or. cCampo == 'RA_USERLGI'
					cTypeCampo	:= Type(cCampo)
				Else
					cTypeCampo	:= ValType(&cCampo)
				EndIf

				If cTypeCampo # "U"
					If cCpoFil == AllTrim(cCampo)
						FieldPut( FieldPos ( cCampo ) , cFilAte )
					Elseif cCpoMat == AllTrim(cCampo)
						FieldPut( FieldPos ( cCampo ) , cMatAte )
					Elseif cCpoCc == AllTrim(cCampo) .and. !( cAlias $ "SRD*SP2" ) //Manter o Centro de Custo Original no SRD
						//-- Se o CC do movimento (SRC) for diferente do CC orginal do funcionario (SRA)
						//-- Permanece o CC do movimento
						If lSRAxSRC
							FieldPut( FieldPos ( cCampo ) , aConteudo[ncampo,2] )
						ElseIf cAlias == "SRO" //Verifica se mantem CC do tarefeiro
							// Se a "Data da transferencia" for anterior à "Data final da tarefa" Ou
							// A "Data final da tarefa" está em branco e o CC na SRO era o mesmo que estava na SRA antes da Transferencia
							If dDataTra <= (cAliasQry)->RO_DATAATE .Or. ;
							(Empty((cAliasQry)->RO_DATAATE) .And. AllTrim((cAliasQry)->RO_CC) == AllTrim(cCCDe))
								FieldPut( FieldPos ( cCampo ) , cCcuAte )
							Else
								FieldPut( FieldPos ( cCampo ) , ( cAliasQry )->RO_CC  )
							EndIf
						Else
							FieldPut( FieldPos ( cCampo ) , cCcuAte )
						EndIf
					Elseif cCpoDepto == AllTrim(cCampo)
						FieldPut( FieldPos ( cCampo ) , cDeptoAte )
					Elseif cCpoPosto == AllTrim(cCampo)
						FieldPut( FieldPos ( cCampo ) , cPostoAte )
					ElseIf lPeriodo .and. cCpoProc == AllTrim(cCampo)
						FieldPut( FieldPos ( cCampo ) , cValProc )
					Elseif lPeriodo .and. cCpoPer == AllTrim(cCampo)
						FieldPut( FieldPos ( cCampo ) , cValPer )
					Elseif lPeriodo .and. cCpoNPago == AllTrim(cCampo)
						FieldPut( FieldPos ( cCampo ) , cValNPago )
					ElseIf lPeriodo .and. !Empty( cCpoRot ) .and. cCpoRot == AllTrim(cCampo)
						FieldPut( FieldPos ( cCampo ) , cValRot )
					ElseIf lItemClvl .And. cCpoItem == AllTrim(cCampo) .and. !( "SRD" $ cAlias ) //Manter o Item Contabil Original no SRD
						FieldPut( FieldPos ( cCampo ) , Iif(!Vazio(cItemAte),cItemAte,aConteudo[ncampo,2]) )
					ElseIf lItemClvl .And. cCpoClvl == AllTrim(cCampo) .and. !( "SRD" $ cAlias ) //Manter o classe de Valor Original no SRD
						FieldPut( FieldPos ( cCampo ) , Iif(!Vazio(cClvlAte),cClvlAte,aConteudo[ncampo,2]) )
					ElseIf cAlias $ "RGB|SRC" .And. !lRecLock .And. (cCpoHrs == AllTrim(cCampo) .OR. cCpoVlr == AllTrim(cCampo))
						If cAlias $ "RGB"
							If cCpoHrs == AllTrim(cCampo)
								(cNewAlias)->RGB_HORAS += aConteudo[ncampo,2]
							ElseIf cCpoVlr == AllTrim(cCampo)
								(cNewAlias)->RGB_VALOR += aConteudo[ncampo,2]
							EndIf
						Else
							If cCpoHrs == AllTrim(cCampo)
								(cNewAlias)->RC_HORAS += aConteudo[ncampo,2]
							ElseIf cCpoVlr == AllTrim(cCampo)
								(cNewAlias)->RC_VALOR += aConteudo[ncampo,2]
							EndIf
						EndIf
					Else
						//--Verifica se tipo do campo entre os arquivos
						If ( cTypeCampo == aConteudo[nCampo,3] ) .Or. aConteudo[nCampo,3] == "M"
							IF aConteudo[ncampo,2] == nil
								IF aConteudo[ncampo,3] == "C"
									aConteudo[ncampo,2] := ""
								ELSEIF aConteudo[ncampo,3] == "D"
									aConteudo[ncampo,2] := CTOD("  /  /    ")
								ELSEIF aConteudo[ncampo,3] == "N"
									aConteudo[ncampo,2] := 0
								ENDIF
							ENDIF
							FieldPut( FieldPos ( cCampo ) , aConteudo[ncampo,2] )

							If cAlias == "RI6" .And. Alltrim(CCAMPO) == 'RI6_CODITE'
								( cNewAlias )->( RI6_CODITE ) := cCod
							Endif
						Endif
					Endif

					//--Quando For Acumulado gravar codigo da Empresa Anterior
					If cAlias == "SRD" .And. lEmpDif .And. Empty(( cNewAlias )->( RD_EMPRESA) )
						( cNewAlias )->( RD_EMPRESA ) := cEmpAnt
					Endif

					//-- Se cadastro de funcionario Gravar Os tipos da transferencia
					If cAlias == "SRA"
						If cCampo = "RA_TIPOADM"
							If cPaisLoc == "DOM"
								( cNewAlias )->( RA_TIPOADM := RA_TIPOADM )
							Else
								( cNewAlias )->( RA_TIPOADM := Left(RA_TIPOADM, 1) + "C" )
							EndIf
						ElseIf cCampo = "RA_PROCES"
							( cNewAlias )->( RA_PROCES ) := cProces
						ElseIf cCampo = "RA_RHEXP"
							( cNewAlias )->( RA_RHEXP ) := Space(6)
						EndIf
					// Grava novo Item se o Destino for diferente da Origem
						If ( SRA->RA_ITEM # cItemAte )
							( cNewAlias )->( RA_ITEM := cItemAte )
						EndIf
						// Grava nova Classe de Valor se o Destino for diferente da Origem
						If ( SRA->RA_CLVL # cClvlAte )
							( cNewAlias )->( RA_CLVL := cClvlAte )
						EndIf
					Endif

					If cAlias == "SR8"
						If cCampo == "R8_PROCES"
							( cNewAlias )->( R8_PROCES ) := cProces
						EndIf
					EndIf

					If cPaisLoc == "MEX" .and. cAlias == "SRA"
						If cCampo == "RA_PERADM"
							FieldPut( FieldPos ( cCampo ), cValIPer )
						ElseIf cCampo == "RA_PAGADM"
							FieldPut( FieldPos ( cCampo ), cValINPago )
						ElseIf cCampo == "RA_PERAUM"
							FieldPut( FieldPos ( cCampo ), cValIPer )
						ElseIf cCampo == "RA_PAGAUM"
							FieldPut( FieldPos ( cCampo ), cValINPago )
						Endif
					Endif
				Endif
			Next nCampo

			/*If cAlias == "AA1"
				IF ( AA1->( FieldPos( "AA1_FUNFIL" ) ) > 0 )
					( cNewAlias )->( AA1_FUNFIL := cFilAte)
				EndIf
			EndIF*/

		( cNewAlias )->( MsUnlock() )

		If cAlias == "TIT"
			TIT->(ConfirmSx8())
		Endif
	EndIf
	RestArea( aArea )
	(cAlias)->( DBSetOrder(nOrderAux) )
Return( NIL )

/*
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³SraUpdRelRd0  ³ Autor ³Marinaldo de Jesus     ³ Data ³09/02/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Atualiza relacionamentos do SRA com o RDZ e RD0       			³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<vide parametros formais>                                       ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
Static Function SraUpdRelRd0( nOrderSRA , nSraRecnoDe , cMatDestino , nRd0Recno , nProcRegua )

	Local lUndoRelRdz	:= .T.

	Local cRd0Codigo
	Local cBkpEmpAnt
	Local cBkpFilAnt
	Local cChaveEntidade
	Local cFilSRA		:= ""
	Local cAliasSRA		:= ""
	Local aDadosRd0 	:= {}

	Begin Sequence
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Se nao Consegui Abir SRA da Empresa Origem, abandona        ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		IF ( Select( "SRAORIG" ) == 0 )
			Break
		EndIF

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Posiciona no Funcionario Para Efetuar o Relacionamento      ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		SRAORIG->( dbGoto( nSraRecnoDe ) )
		//Incrementa a Proc2BarGauge()

		If !lRobo
			IncPrcG1Time(	SRAORIG->( AllTrim( RA_FILIAL + " / " + RA_MAT + " / " + RA_NOME ) )	,;	//01 -> Inicio da Mensagem
							nProcRegua																,;	//02 -> Numero de Registros a Serem Processados
							cTimeIni																,;	//03 -> Tempo Inicial
							.F.																		,;	//04 -> Defina se eh um processo unico ou nao ( DEFAULT .T. )
							-2																		,;	//05 -> Contador de Processos
							1	 																	 ;	//06 -> Percentual para Incremento
						)
			IncProcG2( OemToAnsi( STR0046 + "SRA" ) )	//"Atualizando Relacionamentos do: "
		Endif

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Posiciona no Cadastro de Pessoas/Participantes              ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		RD0->( dbGoto( nRd0Recno ) )

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Pega os dados RD0_LOGIN e RD0_SENHA atual para inclusão     ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If !Empty(RD0->RD0_LOGIN) .And. !Empty(RD0->RD0_SENHA)
			aAdd(aDadosRd0,RD0->RD0_LOGIN)
			aAdd(aDadosRd0,RD0->RD0_SENHA)
			aAdd(aDadosRd0,RD0->RD0_PORTAL)
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Obtem o Codigo do RD0 para o Funcionario                    ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		cRd0Codigo := RD0->RD0_CODIGO

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Salva Empresa e Filial                                      ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		cBkpEmpAnt	:= cEmpAnt
		cBkpFilAnt	:= cFilAnt

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Verifica se ira desfazer o Relacionamento antigo            ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		IF ( lEmpDif )
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Na transferencia de Empresas sempre mantem o  relacionamento³
			//³antigo                									 	       ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			lUndoRelRdz := .F.
			cRd0Codigo	:= "" //Reinicializa para que a EntUpdateRd0() gere um novo codigo
		ElseIF ( lCcDif )
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Se for Apenas Transferencia de Centro de Custo nao desfaz  o³
			//³relacionamento antigo										          ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			IF ( !( lFilDif ) .and. !( lMatDif ) )
				lUndoRelRdz := .F.
			EndIF
		ElseIF ( lDeptoDif )
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Se for Apenas Transferencia de Departamento nao desfaz  o   ³
			//³relacionamento antigo										          ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			IF ( !( lFilDif ) .and. !( lMatDif ) )
				lUndoRelRdz := .F.
			EndIF
		EndIF

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Removendo o Antigo Relacionamento                           ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		IF ( lUndoRelRdz )
			UndoRelRdz( "SRA" , cRd0Codigo , __cSvEmpAnt , cFilDe, If(!lFilDif .And. lMatDif, .F., .T.) )
		EndIF

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Atualiza Empresa e Filial para Pesquisa do Funcionario		 ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		cFilAnt := cFilAte

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Posiciona no Funcionario                                    ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		cFilSRA 	:= If(lEmpDif, totvs.framework.company.xEmpFil("SRA", cEmpAte, cFilAte), xFilial( "SRA" , cFilAte ))
		cAliasSRA	:= If(lEmpDif, "GPESRA","SRA")
		cChaveEntidade := ( cFilSRA + cMatDestino )
		IF (cAliasSRA)->( MsSeek( cChaveEntidade , .F. ) )
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Restaura Empresa e Filial                                   ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			cFilAnt := cBkpFilAnt
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Atualiza Cadastro Pessoas x Entidades                       ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			EntUpdateRd0(	cRd0Codigo			,;	//01 -> Codigo da Pessoa
							"SRA"				,;	//02 -> Entidade Relacionada
							cChaveEntidade		,;	//03 -> Chave da Entidade
							nOrderSRA			,;	//04 -> Ordem
							(cAliasSRA)->( Recno() )	,;	//05 -> Recno da Entidade
							cEmpAte				,;	//06 -> Codigo da Empresa
							cFilAte				,;	//07 -> Codigo da Filial
							"1"					,;	//08 -> Conteudo para o RD0_TIPO "1"=Interno;"2"=Externo
							If(!lFilDif .And. lMatDif, .T.,.F.),;	//09 -> Se Atualiza as Entidades Relacionadas
							NIL					,;	//10 -> Array com as Entidades para o Before Update
							NIL					,;	//11 -> Se Executa algo depois do Update
							aRelation			,;	//12 -> Array com as Estruturas para o Update
							aDadosRd0			 ;  //13 -> Array com as informações de Login e Senha
						)

		EndIF

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Restaura Empresa e Filial                                   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		cFilAnt := cBkpFilAnt

	End Sequence

Return( NIL )

/*
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³fDelNovo	  ³ Autor ³Mauro Sergio Testoni   ³ Data ³25/08/2000³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Deleta Registros na Empresa de Destino                			³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³cAlias - Alias do Arquivo a Ser Aberto                          ³
³          ³cBusca - Chave para Pesquisa no Arquivo                         ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
Static Function fDelNovo( cAlias , cBusca)
	Local aArea      := GetArea()
	Local aSRAArea   := {}
	Local cNewAlias  := If( lEmpDif , "GPE"+cAlias , cAlias )
	Local cSeekCmp   := ""
	Local cPrefix    := PrefixoCpo( Upper( cAlias ) )
	Local bCondDel   := { || .T. }
	Local lSftSeek   := .F.
	Local bWhile
	Local cSRAFilter := ""

	Begin Sequence

		IF ( ChkFullName( cAlias ) )
			Break
		EndIF

		If cAlias == "SRA"
		    cSRAFilter := SRA->( dbFilter() )
		    If !Empty( cSRAFilter )
			     aSRAArea		:= SRA->(GetArea())
			     EndFilBrw( "SRA" , aNewIndexSRA )
			     aNewIndexSRA	:= {}
			     bNewFiltroBrw	:= { || FilBrowse( "SRA" , @aNewIndexSRA , "" ) }
			     SRA->( Eval( bNewFiltroBrw ) )
			     SRA->( dbGoTop() )
		    EndIf
	   EndIf

		//--Monta campo de Comparacao While
		Private cCpFl	:= ( PrefixoCpo( Upper( cAlias ) ) + "_FILIAL" )
		Private cCpMt	:= ( PrefixoCpo( Upper( cAlias ) ) + "_MAT" )
		Private cCpoCom	:= ( cNewAlias+"->"+cCpFl+"+"+cNewAlias+"->"+cCpMt )
		Private cIndOrd	:= ( cCpFl + "+" + cCpMt )

	   If ( cAlias ) $ "BAU/REP/TM0/TM5/TMT"
		    cCpFl	  := ( PrefixoCpo( Upper( cAlias ) ) + "_FILFUN" )
		    cCpoCom := ( cNewAlias+"->"+cCpFl+"+"+cNewAlias+"->"+cCpMt )
		    cIndOrd := ( cCpFl + "+" + cCpMt )
	   ElseIf ( cAlias ) $ "RCY"
		    cIndOrd	:= ( cCpFl + "+" + cCpMt + "+" + cPrefix + "_ANOMES"  + "+" + cPrefix + "_PD" )
		    cSeekCmp:= MesAno(dDataTra)
		    lSftSeek:= .T.
	   EndIf

		dbSelectArea( cNewAlias )
		DbSetOrder( RetOrdem( cNewAlias,cIndOrd) )

		( cNewAlias )->( dbSeek( cBusca + cSeekCmp, lSftSeek ) )
		bWhile 	:= &( "{ ||" + cCpoCom + " == cBusca } " )
		While ( cNewAlias )->( !Eof() .and. Eval( bWhile ) )
		   If Eval( bCondDel )
				( cNewAlias )->( RecLock( cNewAlias , .F. ) )
				( cNewAlias )->( dbDelete() )
				( cNewAlias )->( MsUnlock() )
				( cNewAlias )->( dbSkip() )
		   EndIf
		End While
	End Sequence

	If cAlias == "SRA" .And. !Empty( cSRAFilter )
		EndFilBrw( "SRA" , aNewIndexSRA )
		aNewIndexSRA	:= {}
		bNewFiltroBrw	:= { || FilBrowse( "SRA" , @aNewIndexSRA , @cSRAFilter ) }
		SRA->( Eval( bNewFiltroBrw ) )
		RestArea( aSRAArea )
	EndIf
	RestArea( aArea )
Return

/*
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³fGravaSrd ³ Autor ³Marinaldo de Jesus     ³ Data ³30/08/2000³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Gravar os Acumulados Anuais de Transferencias Anteriores    ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³cChave - Filial e Matricula do Funcionario                  ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
Static Function fGravaSrd( cChave, cAlias )
	Local nX	      := 0
	Local nPosCpo	   := 0
	Local nRecno	   := SRA->( Recno() )
	Local cChvSrd	   := ""
	Local cFilMatAt  := cFilAte + cMatAte
	Local xObtemCpo	:= ""
	Local aTransf	   := {}
	Local aStruct	   := SRD->( dbStruct() )
	Local ntransf	   := 0
	Local lRet      := .T.

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Verificar Transferencias Anteriores para Gravar nos  Acumula³
	//³dos os Valores de Outras Filiais.                           ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	dbSelectArea( "SRA" )
	SRA->( dbSeek( cChave ) )
	fTransfAll(@aTransf)
	aSort( aTransf,,,{ |x,y| x[7] > y[7] } )

	If !( fAbrEmpresa("SRD",1) )
			lRet := .F.
	Else
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Comeca a Pesquisa a Partir da Transferencia Anterior        ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		nTransf := Len( aTransf )
		For nX := 2 To nTransf
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³So Executa Enquanto for Transferencia de Filial             ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			IF aTransf[ nX , 1 ] == aTransf[ nX, 4 ]
		 		dbSelectArea( "SRD" )
				IF dbSeek( aTransf[ nX , 2 ] ) // Filial + Matricula
					While SRD->( !Eof() .and. RD_FILIAL + RD_MAT == aTransf[ nX , 2 ] )
						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³Chave para Pesquisa no Destino                              ³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						If !litemClvl
							cChvSrd := SRD->( cFilMatAt + RD_DATARQ + RD_PD + RD_SEMANA + RD_SEQ + RD_CC )
						Else
							("GPESRD")->(dbSetorder(RetOrder( "SRD", "RD_FILIAL + RD_MAT + RD_DATARQ + RD_PD + RD_SEMANA + RD_SEQ + RD_CC + RD_ITEM + RD_CLVL")))
							cChvSrd := SRD->( cFilMatAt + RD_DATARQ + RD_PD + RD_SEMANA + RD_SEQ + RD_CC + RD_ITEM + RD_CLVL)
						EndIf

						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³Se ja Existir o Registro no Destino nao Regrava             ³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						IF ("GPESRD")->( dbSeek( cChvSrd ) )
							dbSelectArea( "SRD" )
							SRD->( dbSkip() )
							Loop
						EndIF

						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³Carrega os Dados no Arquivo Destino                           ³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						RecLock( "GPESRD" , .T. , .F. )
						For nPosCpo := 1 To Len( aStruct )
		     				dbSelectArea( "SRD" )
		     				xObtemCpo :=  FieldGet( FieldPos ( aStruct[ nPosCpo , 1 ] ) )
			     			dbSelectArea( "GPESRD" )
			     			IF FieldPos ( aStruct[ nPosCpo , 1 ] ) > 0
		    	 				IF Upper( AllTrim( aStruct[ nPosCpo , 1 ] ) ) == "RD_FILIAL"
		    	 					FieldPut( FieldPos ( aStruct[ nPosCpo , 1 ] ) , cFilAte )
		    	 				ElseIF Upper( AllTrim( aStruct[ nPosCpo , 1 ] ) ) == "RD_MAT"
		    	 					FieldPut( FieldPos ( aStruct[ nPosCpo , 1 ] ) , cMatAte )
								ElseIF Upper( AllTrim( aStruct[ nPosCpo , 1 ] ) ) == "RD_EMPRESA"
									FieldPut( FieldPos ( aStruct[ nPosCpo , 1 ] ) , IF( Empty(xObtemCpo),cEmpAnt,xObtemCpo ) )
		    	 				Else
		    	 					FieldPut( FieldPos ( aStruct[ nPosCpo , 1 ] ) , xObtemCpo )
		     					EndIF
		     				EndIF
						Next nPosCpo
						dbSelectArea( "GPESRD" )
						("GPESRD")->( MsUnLock() )
						dbSelectArea( "SRD" )
						SRD->( dbSkip() )
					EndDo
				EndIF
			Else
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Ao Encontrar a 1a. Transferencia de Empresa sai do Loop.    ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				Exit
			EndIF
		Next nX
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Reposiciona Ponteiros                                         ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	SRA->( dbGoto( nRecno ) )
	dbSelectArea( cAlias )
Return

/*
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³fChkSRE   ³ Autor ³Marinaldo de Jesus     ³ Data ³03/01/2001³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Verificar se o SRE esta compartilhado entre Empresas        ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³ cEmp - Empresa                                             ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
Static Function fChkSRE( cEmp )
Return( EqualFullName( "SRE" , cEmp , __cEmpAnt ) )

/*
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³ChangeNew ³ Autor ³                       ³ Data ³03/01/2001³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Abrir tabelas para Consulta via Tecla F3                    ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³ cEmp - Empresa de Destino                                  ³
³          ³ cFil - Filial  de Destino                                  ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
Function ChangeNew(uAliasNewEmp, cEmp, cFil)
	Local nAT
	Local nX		:= 0
	Local cModo 	:= ""
	Local cAliaAux	:= ""
	Local lTransfUni:= IsInCallStack( "fTransfUnico" )

	if valtype(__cEmpAnt) <> "U" .and. !empty(__cEmpAnt)

		IF cEmp+cFil != __cLastEmp .OR. lTransfUni

			If (ValType(uAliasNewEmp) == "A" )
				fOpenSx2(cEmp)
				FWClearXFilialCache()

				For nX := 1 to Len(uAliasNewEmp)
					cAliaAux:= uAliasNewEmp[nX]

					IF cEmp != SubStr(__cLastEmp,1,2)
						UniqueKey( NIL , cAliaAux , .T. )
						MyEmpOpenFile(cAliaAux,cAliaAux,1,.t.,cEmp,@cModo)
						aAdd( aTabCompany, cAliaAux )
						If !lCorpManage
							nAT := AT(cAliaAux,cArqTab)
							IF nAT > 0
								cArqTab := SubStr(cArqTab,1,nAT+2)+cModo+SubStr(cArqTab,nAT+4)
							Else
								cArqTab += cAliaAux+cModo+"/"
							EndIF
						EndIf
					EndIF

				Next Nx
				cFilAnt := cFil

				__cLastEmp := cEmp+cFil
				__cLastData:= cAliaAux

			Else
				cAliaAux:= uAliasNewEmp
				IF cEmp != SubStr(__cLastEmp,1,2)
					fOpenSx2(cEmp)
					UniqueKey( NIL , cAliaAux , .T. )
					MyEmpOpenFile(cAliaAux,cAliaAux,1,.t.,cEmp,@cModo)
					aAdd( aTabCompany, cAliaAux )
				EndIF
				__cLastEmp := cEmp+cFil
				__cLastData:= cAliaAux
				cFilAnt := cFil
				nAT := AT(cAliaAux,cArqTab)
				IF nAT > 0
					cArqTab := SubStr(cArqTab,1,nAT+2)+cModo+SubStr(cArqTab,nAT+4)
				Else
					cArqTab += cAliaAux+cModo+"/"
				EndIF
			Endif

			aSRAHeader	 := fAllHeader()
			nLenaHeader := Len(aSRAHeader)
			If !( lRobo .Or. IsInCallStack("fEnvTaf180") )
				cOrgCfg := totvs.framework.company.getParameter(cEmp,cFil,"MV_ORGCFG",/*lExists*/,"0")
  			    nPos := GdFieldPos("RA_POSTO"	, aTransfHeader)
				if nPos > 0
					MyEmpOpenFile("RCL","RCL",1,.t.,cEmp,@cModo)
					OGETSRA2:AHEADER[nPos,06] := iif(cOrgCfg=='1',"ConsPosto() .And. VldPosto()",'')
					OGETSRA2:AHEADER[nPos,09] := iif(cOrgCfg=='1', "RCLORG", '')
				Endif

  			    nPos := GdFieldPos("RA_DEPTO"	, aTransfHeader)
				if nPos > 0
					OGETSRA2:AHEADER[nPos,06] :=  "ConsDepto()"

					If (cOrgCfg == "1".And. !cConDept)
						cF3		:= "RD4ORG"
						cVisual	:= "R"
						MyEmpOpenFile("RD4","RD4",1,.t.,cEmp,@cModo)
					elseIf cConDept
						cF3		:= "RHDEPT"
						cVisual	:= "R"
						MyEmpOpenFile("SQB","SQB",1,.t.,cEmp,@cModo)
					else
						cF3		:= "SQBCC"
						cVisual	:= "R"
						MyEmpOpenFile("SQB","SQB",1,.t.,cEmp,@cModo)
					EndIf
					OGETSRA2:AHEADER[nPos,09] := cF3
					OGETSRA2:AHEADER[nPos,14] := cVisual
				Endif
				 nPos := GdFieldPos("RA_PROCES"	, aTransfHeader)
				If nPos > 0
					OGETSRA2:AHEADER[nPos,06] :=  "ConsProc()"
				EndIf

				nPos := GdFieldPos("RA_POSTO"	, aTransfHeader)
				If nPos > 0
					If (cOrgCfg == "1".And. !cConPosto)
						cF3		:= "RCLORG"
						cVisual	:= "R"
						MyEmpOpenFile("RCL","RCL",1,.t.,cEmp,@cModo)
					ElseIf cConDept
						cF3		:= "RHPOST"
						cVisual	:= "R"
						MyEmpOpenFile("RCL","RCL",1,.t.,cEmp,@cModo)
					EndIf
					OGETSRA2:AHEADER[nPos,09] := cF3
					OGETSRA2:AHEADER[nPos,14] := cVisual
				EndIf
			EndIf
		endif
	EndIF
Return( .T. )

/*
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³MyEmpOpenFile ³ Autor ³Wilson de Godoy        ³ Data ³03/01/2001³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Abre Arquivo de Outra Empresa                         			³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³x1 - Alias com o Qual o Arquivo Sera Aberto                  	³
³          ³x2 - Alias do Arquivo Para Pesquisa e Comparacao                ³
³          ³x3 - Ordem do Arquivo a Ser Aberto                              ³
³          ³x4 - .T. Abre e .F. Fecha                                       ³
³          ³x5 - Empresa                                                    ³
³          ³x6 - Modo de Acesso (Passar por Referencia)                     ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
Static Function MyEmpOpenFile(x1,x2,x3,x4,x5,x6)
Local xRet
xRet	:= EmpOpenFile(@x1,@x2,@x3,@x4,@x5,@x6)


Return( xRet )

/*
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³FilesTransf   ³ Autor ³Marinaldo de Jesus     ³ Data ³30/03/2001³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Retorna Array com os Arquivos a Serem Transferidos              ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³                                       							³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³Retorna Array Com os Arquivos a Serem Transferidos             	³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
Function FilesTransf(aFilesTransf, aFilesOpen, lArqRH3)

	Local aTrfDelMov	:= {}
	Local aTrfNoCC		:= {}
	Local cArquivos		:= Upper( AllTrim( SuperGetMv("MV_ARQTRAN", NIL, "" )))
	Local cTrfDelMov	:= Upper( AllTrim( SuperGetMv("MV_TRFDELM", NIL, "" )))
	Local cTrfNoCC		:= Upper( AllTrim( SuperGetMv("MV_TRFNOCC", NIL, "" )))
	Local cArqNotTrf	:= Upper( AllTrim( SuperGetMv("MV_FNOTTRF", NIL, "" )))
	Local cAliasTrf		:= ""
	Local lTrfDelMov	:= .F.
	Local lTrfNoCC		:= .T.
	Local lRet			:= .T.
	Local nFor			:= 0
	Local nPosArq		:= 0
	Local cRotBlank
	Local cAliasPS		:= "RHK/RHL/RHM/RHN/RHO/RHP/RHR/RHS"
	Local aAliasDel		:= {}
	Local aArea			:= GetArea()	//?-Salva a Area Atual
	Local lTabRUO		:= ChkFile("RUO")

	Default lArqRH3		:= .F.
	Default lTemRU1		:= AliasInDic("RU1")

	//--Utilizacao do modulo SIGAGFP (gestao de folha publica)
	lGestPubl := If( type("lGestPubl") == "U", if(ExistFunc("fUsaGFP"), fUsaGFP(), .f.), lGestPubl)

	aFilesTransf		   := {}
	//aFilesTransf[1]	//Alias
	//aFilesTransf[2]	//Se Deleta o Autal
	//aFilesTransf[3]	//Filial
	//aFilesTransf[4] 	//Se Modifica Centro de Custo Igual
	//aFilesTransf[5] 	//Campos do cadastro de periodos --> Processo, Periodo, Semana e Roteiro
	//aFilesTransf[6]	//Se efetua a transferencia dos registros desta tabela
	cRotBlank := Space(GetSx3Cache("RCH_ROTEIR", "X3_TAMANHO"))
	aAdd(aFilesTransf, {"SRA", .F., "  ", .F., {}, .T., .F.})
	aAdd(aFilesTransf, {"SRB", .F., "  ", .T., {}, .T., .F.})
	aAdd(aFilesTransf, {"SRC", .T., "  ", .T., {"RC_PROCES", "RC_PERIODO", "RC_SEMANA", "RC_ROTEIR" }, .T., .F.})
	aAdd(aFilesTransf, {"SRD", .F., "  ", .T., {}, .T., .F.})
	aAdd(aFilesTransf, {"SRF", .F., "  ", .T., {}, .T., .F.})
	aAdd(aFilesTransf, {"SRG", .T., "  ", .T., {"RG_PROCES", "RG_PERIODO", "RG_SEMANA", "RG_ROTEIR"}, .T., .F.})
	aAdd(aFilesTransf, {"SRH", .T., "  ", .T., {"RH_PROCES", "RH_PERIODO", "RH_NPAGTO", "RH_ROTEIR"}, .T., .F.})
	aAdd(aFilesTransf, {"SRK", .T., "  ", .T., {"RK_PROCES", "RK_PERINI", "RK_NUMPAGO", cRotBlank}, .T., .F.})
	aAdd(aFilesTransf, {"SRO", .T., "  ", .T., {}, .T., .F.})
	aAdd(aFilesTransf, {"SRR", .T., "  ", .T., {"RR_PROCES", "RR_PERIODO", "RR_SEMANA", ""}, .T., .F.})
	aAdd(aFilesTransf, {"RI1", .F., "  ", .T., {}, .T., .F.})
	aAdd(aFilesTransf, {"RIQ", .T., "  ", .T., {"RIQ_PROCES", "RIQ_PERIOD", "RIQ_NUMPAG", "RIQ_ROTEIR"}, .T., .F.})
	aAdd(aFilesTransf, {"RIR", .F., "  ", .T., {}, .T., .F.})
	aAdd(aFilesTransf, {"AC9", .F., "  ", .F., {}, .F., .F.})
	aAdd(aFilesTransf, {"ACB", .F., "  ", .F., {}, .F., .F.})

	If  lGestPubl .AND. cModulo $ "GFP*VDF" //Se Gestão de Folha Pública - SIGAGFP
		aAdd(aFilesTransf,{"RI6", .F., "  ", .T., {}, .T., .F. })
		aAdd(aFilesTransf,{"RIA", .F., "  ", .T., {}, .T., .F.})
	EndIf

	IF cPaisLoc == "BRA"
		If lTabRUO
			aAdd(aFilesTransf, {"RUO",.T.,"  ",.T., {}, .T., .F.})
		EndIf
		aAdd(aFilesTransf, {"SR0",.T.,"  ",.T., {}, .T., .F.})
		aAdd(aFilesTransf, {"SM7",.T.,"  ",.T., {}, .T., .F.})
		aAdd(aFilesTransf, {"RFS",.F.,"  ",.T., {}, .T., .F.})
		// Tratamento para transferência das tabelas da nova estrutura do cálculo de plano de saúde
		aAdd(aFilesTransf, {"RHK", .F., "  ", .T., {}, .T., .F.})
		aAdd(aFilesTransf, {"RHL", .F., "  ", .T., {}, .T., .F.})
		aAdd(aFilesTransf, {"RHM", .F., "  ", .T., {}, .T., .F.})
		aAdd(aFilesTransf, {"RHN", .F., "  ", .T., {}, .T., .F.})
		aAdd(aFilesTransf, {"RHO", .T., "  ", .T., {}, .T., .F.})
		aAdd(aFilesTransf, {"RHP", .F., "  ", .T., {}, .T., .F.})
		aAdd(aFilesTransf, {"RHR", .T., "  ", .T., {}, .T., .F.})
		aAdd(aFilesTransf, {"RHS", .F., "  ", .T., {}, .T., .F.})
		aAdd(aFilesTransf, {"RFX", .F., "  ", .T., {}, .T., .F.})
	EndIf

	aAdd(aFilesTransf,	{"SRS", .F., "  ", .T., {}, .T., .F.})
	aAdd(aFilesTransf,	{"SRQ", .F., "  ", .T., {}, .T., .F.})
	aAdd(aFilesTransf,	{"SR7", .F., "  ", .T., {}, .T., .F.})
	aAdd(aFilesTransf,	{"SR3", .F., "  ", .T., {}, .T., .F.})
	aAdd(aFilesTransf,	{"SR8", .F., "  ", .T., {"R8_PROCES", "R8_PER", "R8_NUMPAGO", cRotBlank }, .T., .F.})
	aAdd(aFilesTransf,	{"SR9", .F., "  ", .T., {}, .T., .F.})
	aAdd(aFilesTransf,	{"RG1", .F., "  ", .T., {}, .T., .F.})
	aAdd(aFilesTransf,	{"RG2", .F., "  ", .T., {}, .T., .F.})

	//Actualización de la información en tabla Acumuladores (RG7)
	If cPaisLoc == "PAR"
		aAdd(aFilesTransf,	{"RG7", .F., "  ", .T., {}, .T., .F.})
	EndIf

	/*If lInteRHAA1
		aAdd(aFilesTransf, {"AA1", .F., "  ", .F., {}, .T., .F.})
	EndIf*/

	If cPaisLoc == "MEX"
		aAdd(aFilesTransf, {"RCP", .F., "  ", .T., {}, .T., .F.})
		aAdd(aFilesTransf, {"RCR", .F., "  ", .T., {"RCR_PROCES", "RCR_PERIOD", "RCR_NPAGTO", "RCR_ROTEIR"}, .T., .F.})
	EndIf

	aAdd(aFilesTransf, {"RGB", .T., "  ", .T., {"RGB_PROCES", "RGB_PERIOD", "RGB_SEMANA", "RGB_ROTEIR" }, .T., .F.})

	 If lTemRU1
        aAdd( aFilesTransf, { "RU1", .F., "  ", .T., {}, .T., .F. } )
        aAdd( aFilesTransf, { "RU3", .F., "  ", .T., {}, .T., .F. } )
    EndIf

	IF !Empty(cTrfDelMov)
		For nFor := 1 To Len(cTrfDelMov) Step 3
			cAliasTrf := Upper( SubStr( cTrfDelMov, nFor, 3 ))
			IF ( aScan( aTrfDelMov, { |x| x == cAliasTrf } ) == 0 )
				aAdd( aTrfDelMov, cAliasTrf )
			EndIF
		Next nFor
	EndIF

	IF !Empty(cTrfNoCC)
		For nFor := 1 To Len(cTrfNoCC) Step 3
			cAliasTrf := Upper( SubStr( cTrfNoCC, nFor, 3 ))
			IF ( aScan( aTrfNoCC, { |x| x == cAliasTrf } ) == 0 )
				aAdd( aTrfNoCC, cAliasTrf )
			EndIF
		Next nFor
	EndIF

	IF !Empty(cArquivos)
		For nFor := 1 To Len(cArquivos) Step 3
			cAliasTrf := Upper( SubStr( cArquivos, nFor, 3 ) )
			// Tratamento para nao incluir Alias Inválido
			dbSelectArea("SX2")
			If Len(cAliasTrf) < 3 .Or. !dbSeek(cAliasTrf, .F.)
				lRet := .F.
				MsgAlert( OemToAnsi(STR0190) + cAliasTrf, OemToAnsi(STR0047) )	// "Alias Inválido: " # "Atenção!"
				Exit
			Else
				If (!(cAliasTrf $ "TM0/TM5/TMT") .AND. ProcCmp(cAliasTrf)) .And. !(cAliasTrf $ "RH3*RH4") //As tabelas do SIGAMDT e a tabela SPK não devem ser transferidas pelo MV_ARQTRAN
					If ( aScan( aFilesTransf, { |x| x[1] == cAliasTrf } ) == 0 )
						lTrfDelMov := ( aScan( aTrfDelMov, { |x| x == cAliasTrf } ) > 0 )
						lTrfNoCC := ( aScan( aTrfNoCC, { |x| x == cAliasTrf } ) == 0 )
						aAdd( aFilesTransf, { cAliasTrf, lTrfDelMov, "  ", lTrfNoCC, {}, If(cAliasTrf $ "SRT*RFE*RFB*RHP*RHS", .F., .T.), "", .F.} )
					EndIf
				EndIf

				If cAliasTrf $ "RH3"
					lArqRH3 := .T.
				EndIf
			EndIF
		Next nFor

		RestArea(aArea)	// Restaura a Área Inicial
	EndIF

	If lRet
		// Caso seja transferência de FILIAL e/ou Empresa, respeita a configuração do parâmetro MV_FNOTTRF
		If ( (Type("cEmpAte") != "U") .and. (Type("cFilAte") != "U") )
			If ( ( __cSvEmpAnt # cEmpAte  ) .or. ( cFilDe # cFilAte ) )
				// Não deve transferir os registros das tabelas listadas no parâmetro MV_FNOTTRF
				If !Empty(cArqNotTrf)
					For nFor := 1 To Len(cArqNotTrf) Step 3
						cAliasTrf := Upper( SubStr( cArqNotTrf, nFor, 3 ) )
						If (cAliasTrf != "SRA" )
							If ( (nPosArq := aScan( aFilesTransf, { |x| x[1] == cAliasTrf })) > 0 )
								aFilesTransf[ nPosArq, 6 ] := .F.
							EndIf
						EndIf
					Next nFor
				EndIf
			EndIf
		EndIf

		For nFor := 1 To Len(aFilesTransf)
			If !IsBlind()
				MsProcTxt( aFilesTransf[nFor, 1] )
			EndIf
			If Select(aFilesTransf[nFor,1]) == 0
				If !( lRet := ChkFile( aFilesTransf[nFor, 1] ) )
					If ( aFilesTransf[ nFor, 1 ] $ cAliasPS )
						lRet := .T.
						aAdd( aAliasDel, nFor )
					Else
						Exit
					EndIf
				Else
					aAdd(aFilesOpen, aFilesTransf[nFor, 1])
				EndIf
			EndIF
			If ( lEmpDif )
				If !( lRet := fAbrEmpresa( aFilesTransf[nFor, 1], RetOrdem( aFilesTransf[nFor, 1])))
					Exit
				EndIF
				aFilesTransf[nFor, 3] := __cFil
			EndIF
		Next nFor
	EndIf

	If (Len(aAliasDel) > 0)
		For nFor := 1 To Len(aAliasDel)
			aDel( aFilesTransf, aAliasDel[nFor] )
		Next
		aSize( aFilesTransf, Len(aFilesTransf) - Len(aAliasDel))
	EndIf

Return( lRet )

/*
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³FiltraXI3()   ³ Autor ³Marinaldo de Jesus     ³ Data ³30/03/2001³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Retornar Chaves Unicas na Consulta via Tecla F3                 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³                                       							³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³.T. Se Chave Unica .F. c.c 										³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Consulta padrao XI3        										³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
Function FiltraXI3()

IF !( Type( "aKeyCcFilter" ) == "A" )
	aKeyCcFilter := {}
EndIF

//Necessário setar a tabela do CC quando proveniente do portal protheus
IF !( Type( "cAliasCc" ) == "C" ) .OR. Empty(cAliasCc)
	cAliasCc := "CTT"
EndIF

Return( UniqueKey( aKeyCcFilter , cAliasCc ) )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFuncao    ³Gpea180LotºAutor  ³Andreia dos Santos v.I ºData³ 29/08/2003 º±±
±±º          ³          º       ³Marinaldo de Jesus v.IIºData³ 18/02/2004 º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Faz a transferencia dos funcionarios em lote               º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function Gpea180Lot(cAlias,nReg,nOpcx)
Local aArea       := GetArea()
Local cTitulo
Local lMarca
Local lLock
Local bInRange
Local bStart
Local bLDblClick
Local bAllMark
Local bAllUnMark
Local bGpea180Cnf
Local bBeforeFiltro
Local bFiltra
Local bFiltro
Local nOpcA
Local nSvReg	    := nReg
Local oDlg
Local aFieldsBrowse	:= {}
Local aAdvSize		:= {}
Local aInfoAdvSize	:= {}
Local aObjSize		:= {}
Local aObjCoords  	:= {}
Local nI
//Variaveis para manipulacao dos botoes da enchoice
Local bSet15		:= { || .T. }
Local bSet24		:= { || .T. }

Private aTransfHeader	:= {}
Private aTransfCols		:= {}
Private aTransf1Header	:= {}
Private aTransf1Cols	:= {}
Private aLogTransf		:= {}
Private aModTraj		:= {}
Private aHeaderRCP     	:= {}
Private aRCPCols	    := {} // vetor com as colunas da GetDados RCP. (variavel para getdados da tabela RCP)
Private oMsSelect		//# Alterado para private para dar refresh na funcao Gpea180Flt()
Private nQtdFTrans		:= SuperGetMv("MV_QTDTR", .F., 50)

SRA->(MsUnLock()) //Retira o lock da SRA - devem ser reservados apenas os registros marcados
nQtdFTrans := Iif(nQtdFTrans < 50, 50, Iif(nQtdFTrans > 200, 200, nQtdFTrans))

SRA->(DbSetOrder(1))
_SetOwnerPrvt(	"cAltSal"	, Getmv("MV_ALTSAL") )

//Quando eh usado o controle automatico de matricula verifica se ela sera alterada
If !Empty(cContrMat) .And. cContrMat # "0"
	lCtrAutoMat := Gpe180MatAuto()
EndIf

Begin Sequence

	Private aNewIndexSRA  	:= {}
	Private bNewFiltroBrw 	:= {|| NIL }
	Private cMarkTransf		:= GetMark()
	Private cRaOkTransSpc	:= Space( TamSx3( "RA_OKTRANS" )[1] )
	Private lAbortPrint		:= .F.

	cTitulo  		:= STR0008												//"Transferências"
	lMarca   		:= .T.
	lLock			:= .F.

	//bInRange		:= { || SRA->RA_FILIAL == cFilAnt .and.  SRA->RA_SITFOLH<>'D' }
	bStart			:= { || SRA->(MsGoTo(nReg)) , oMsSelect:oWnd:Refresh(),oMsSelect:oBrowse:Refresh() }
	bLDblClick		:= { || Gpea180Mrk( "SRA" , NIL , .T. , SRA->( !IsMark( "RA_OKTRANS" , cMarkTransf ) ) ) }
	bAllMark		:= { || Gpea180MkAll( @lMarca , .T. , .F. ) }
	bAllUnMark		:= { || Gpea180MkAll( .F. , .T. , .F. ) , lMarca := .T. , oMsSelect:oBrowse:Refresh() }
	bGpea180Cnf		:= { || Gpea180Cnf() , lMarca := .T. }
	bBeforeFiltro	:= { || IF( Len( __aMrkRecnos__ ) > 0, Proc2BarGauge( bAllUnMark , OemToAnsi( STR0056 ) , NIL , NIL , .T. , .T. , .F. , .F. ) , .T. ) }	//"Retirando a Selecao"
	bFiltra			:= { || Gpea180Flt( bBeforeFiltro ) }
	bSelecID		:= { || Gpea180ID(), oMsSelect:oWnd:Refresh(),oMsSelect:oBrowse:Refresh() }
	nOpcA			:= 0
	__aMrkRecnos__	:= {}
	__aMrkKeys__	:= {}

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Monta Botoes no final do dialogo...                                      ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	bSet15	:= {|| nOpcA := 1 , Eval( bGpea180Cnf ) , oDlg , .T. }
	bSet24	:= {|| nOpcA := 2 , oDlg:End() , oDlg , .T. }

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Campos da MarkBrowse                                                     ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If !lItemClvl	                    //Campo      ,     ,Titulo              , Picture
		aFieldsBrowse := {{"RA_OKTRANS", 	"",                     ,	""},;
							{"RA_MAT"    , 	"", OemToAnsi (STR0013) ,	""},;
							{"RA_NOME"   ,	"", OemToAnsi (STR0147) ,	""},;
							{"RA_PROCES" , 	"", OemToAnsi (STR0087), 	""},;
							{"RA_CC"     , 	"", OemToAnsi (STR0014) , 	""},;
							{"RA_DEPTO"  , 	"", OemToAnsi (STR0148) , 	""},;
							{"RA_POSTO" , 	"", OemToAnsi (STR0149) , 	""}	}
	Else
		aFieldsBrowse := {{"RA_OKTRANS", 	"",                     ,	""},;
							{"RA_MAT"    , 	"", OemToAnsi (STR0013) ,	""},;
							{"RA_NOME"   ,	"", OemToAnsi (STR0147) ,	""},;
							{"RA_PROCES" , 	"", OemToAnsi (STR0087), 	""},;
							{"RA_CC"     , 	"", OemToAnsi (STR0014) , 	""},;
							{"RA_ITEM"   , 	"", OemToAnsi (STR0165) , 	""},;
							{"RA_CLVL"   , 	"", OemToAnsi (STR0166) , 	""},;
							{"RA_DEPTO"  , 	"", OemToAnsi (STR0148) , 	""},;
							{"RA_POSTO" , 	"", OemToAnsi (STR0149) , 	""}	}
	EndIf

	dbSelectArea("SRA")

	If !IsBlind()

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Monta Dialog...                                                          ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		aAdvSize		:= MsAdvSize()
		aInfoAdvSize	:= { aAdvSize[1] , aAdvSize[2] , aAdvSize[3] , aAdvSize[4],5,5  }
		aAdd( aObjCoords , { 010 , 010 , .F. , .F. } )
		aAdd( aObjCoords , { 000 , 100 , .T. , .T. } )
		aObjSize	:= MsObjSize( aInfoAdvSize , aObjCoords )

		DEFINE FONT oFont  NAME "Arial" SIZE 0,-11 BOLD
		DEFINE FONT oFont2 NAME "Arial" SIZE 0,-13 BOLD
		DEFINE MSDIALOG oDlg TITLE OemToAnsi(STR0008) FROM aAdvSize[7], 0 TO aAdvSize[6]-50, aAdvSize[5]-200 OF GetWndDefault() PIXEL //Trnasferencia

			oDlg:lEscClose := .F. //Nao permite sair ao se pressionar a tecla ESC.
			@ aObjSize[1,1]+2 , aObjSize[1,2]     SAY OemToAnsi(STR0015)                   SIZE 100,10 OF oDlg PIXEL FONT oFont
			@ aObjSize[1,1]   , aObjSize[1,2]+60  MSGET oGet VAR dDataTra VALID NaoVazio() SIZE 50,10  OF oDlg PIXEL HASBUTTON
			@ aObjSize[1,1]+4 , aObjSize[1,2]+225 SAY OemToAnsi(STR0333 + cValToChar(nQtdFTrans))  SIZE 500,10 OF oDlg PIXEL FONT oFont2

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Monta MarkBrowse...                                                      ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			oMsSelect := MsSelect():New(;
											"SRA"				,;	//Alias	do Arquivo de Filtro
											"RA_OKTRANS"		,;	//Campo para controle do mark
											NIL					,;	//Condicao para o Mark
											aFieldsBrowse		,;	//Array com os Campos para o Browse
											NIL					,;	//?
											cMarkTransf			,;	//Conteudo a Ser Gravado no campo de controle do Mark
											{aObjSize[2,1]+10,aObjSize[2,2],aObjSize[2,3]-30,aObjSize[2,4]-100}	,;	//Coordenadas do Objeto
											NIL					,;  //?
											NIL					,;	//?
											oDlg				 ;	//Objeto Dialog
										)
			oMsSelect:oBrowse:lHasMark    	:= .T.
			oMsSelect:oBrowse:lCanAllMark 	:= .F.
			oMsSelect:oBrowse:bLDblClick	:= bLDblClick
			oMsSelect:oBrowse:lAllMark		:= .F.

			If !lGpe180Fit
				oMsSelect:oWnd:bStart := bStart
			EndIf

			Gpea180Flt( bBeforeFiltro, .F. ) //Filtro inicial

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Ativa o Dialogo...                                                       ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			aButtons	:=	{;
							{"PESQUISA" ,{|| SRA->( PesqBrw( "SRA" , SRA->( Recno() ) , bNewFiltroBrw ) ) , oMsSelect:oBrowse:Refresh() } ,STR0069,STR0069},;	//"Pesquisar"
							{"SELECAO" 	,{|| Proc2BarGauge( bAllMark , OemToAnsi( IF( lMarca , STR0055 , STR0056 ) ) , NIL , NIL , .T. , .T. , .F. , .F. ) } , STR0045,STR0045 },;	//"Selecionando Funcion rios"###"Retirando a Seleção"
							{"FILTRO" 	,{|| MsAguarde( bFiltra , STR0054 ) }  ,STR0044,STR0044};
							}	//"Filtro      "###Filtrando Funcionarios"

			aAdd(aButtons,{"SELECAO" 	,{|| MsAguarde( bSelecID , OemToAnsi( STR0055 )) } , STR0173,STR0173 })	//"Selecionando Funcionarios"###"Selec.ID Transf."

			If lGpe180Menu	// CRIAÇÃO DO PONTO DE ENTRADA. Adiciona opcoes ao menu
				ExecBlock("GP180MEN",.F.,.F.)
			EndIf

		ACTIVATE DIALOG oDlg ON INIT EnchoiceBar(oDlg,bSet15,bSet24, Nil , aButtons )  CENTERED

	Else
		nOpcA := 1

		For nI := 1 to Len(aAutoItens)
			If SRA->(DbSeek( aAutoItens[nI][1] + aAutoItens[nI][2] ))
				Eval( bLDblClick )
			EndIf
		Next

		Gpea180Cnf(.T.)
		lMarca := .T.
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Fim da Rotina Principal                                                  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	IF ( ( nOpcA <> 2 ) .And. ( Len( __aMrkRecnos__ ) > 0  ) ) //winston robo __aMrkRecnos__ = 0
		IF ( Len( __aMrkRecnos__ ) > 0  )

			If !lRobo
				Proc2BarGauge( { || Gpea180MkAll( .F. , .F. , .F. ) } , OemToAnsi( STR0056 ) , NIL , NIL , .T. , .T. , .F. , .F. )
			Endif

			__aMrkRecnos__	:= {}
			__aMrkKeys__	:= {}
			If !IsBlind() .And. ValType(oMsSelect:oBrowse) == "O"
				oMsSelect:oBrowse:Refresh()
			EndIf
		EndIF
	EndIF

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Finaliza Filtro da Transfrencia Em Lote                                  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	EndFilBrw( "SRA" , aNewIndexSRA )

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Restaura Filtro de Entrada                                               ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	IF ( lGpea180Flt )
		Eval( bFiltraBrw )
	EndIF

	// Posiciona o SRA no Inicio
	SRA->(dbGoTop())

End Sequence

RestArea( aArea)
Return( NIL )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFuncao    ³Gpea180FltºAutor³Andreia dos Santos v.I º Data ³ 29/08/2003 º±±
±±º          ³          º     ³Marinaldo de Jesus v.IIº Data ³ 18/02/2004 º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Filtra os funcionarios da markbrowse                        º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function Gpea180Flt( bBeforeFiltro, lMonta )
Local cFiltro		:= ""
Local cRegime		:= ""
Local lExecFiltro	:= .F.

	Default lMonta 		:= .T.

	If lGpe180Fit // CRIAÇÃO DO PONTO DE ENTRADA, cria os filtros para consulta na SRA
		cFiltro := ExecBlock("GP18FILT", .F., .F.)
	Else
		cFiltro := cFiltroRet
	EndIf

If lMonta
	If GpFltBldExp( "SRA" , NIL , @cFiltro , NIL )
		lExecFiltro := ( !Empty( cFiltro ) .and. ( cFiltro <> cFiltroRet ) )
	EndIf
EndIf

cFiltroRet	:= cFiltro

IF ( lGpea180Flt )
	IF !Empty( cFiltraRh )
		EndFilBrw( "SRA" , aIndexSRA )
		IF !( lExecFiltro )
			cFiltro	:= cFiltraRh
		Else
			cFiltro	:= ( cFiltraRh + " .and. " + cFiltro )
		EndIF
	EndIF
EndIF

If lGestPubl
	cRegime := "SRA->RA_REGIME $ " + If(lGestPubl .AND. cModulo $ "VDF*GFP","'2'","' *1'")
	If !Empty(cFiltro)
		cFiltro += + " .and. " + cRegime
	Else
		cFiltro := cRegime
	EndIf
EndIf

IF ( lExecFiltro )
	Eval( bBeforeFiltro )
EndIF

EndFilBrw( "SRA" , aNewIndexSRA )
aNewIndexSRA	:= {}
bNewFiltroBrw	:= { || FilBrowse( "SRA" , @aNewIndexSRA , @cFiltro ) }
SRA->( Eval( bNewFiltroBrw ) )

oMsSelect:oBrowse:Refresh()
Return( lExecFiltro )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFuncao    ³Gpea180MkAllºAutor³Andreia dos Santos v.I ºData³ 08/29/2003 º±±
±±º          ³            º     ³Marinaldo de Jesus v.IIºData³ 18/02/2004 º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Marca/Desmarca todos os elementos do browse                 º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function Gpea180MkAll( lMarca , lShowMsg , lInsiste )

Local aNoLocks		:= {}
Local bWhile		:= { |cWhile| &( cWhile ) }
Local cFilSra		:= xFilial("SRA")
Local cMsg			:= ""
Local cSraFilter	:= SRA->( dbFilter() )
Local cTimeIni		:= Time()
Local lChkMrk		:= .T.
Local lUseCode		:= lMarca
Local lMaxAdsLckRec	:= .F.
Local nRecno		:= SRA->( Recno() )
Local nLocks		:= 0
Local nPosRec		:=	GdfieldPos("RA_REC_WT",aTransfHeader)
Local nPosRec1		:=	GdfieldPos("RA_REC_WT",aTransf1Header)
Local nX		  	:= 0
Local nLoop
Local nLoops
Local nNoLock
Local nLastSize
Local nProcRegua

DEFAULT lShowMsg	   := .T.
DEFAULT lInsiste	   := .T.

CursorWait()

IF !( lMarca )
	IF !( lAbortPrint )
		cSraFilter += IF( !Empty( cSraFilter ) , " .and. IsMark('RA_OKTRANS','"+cMarkTransf+"')" , "IsMark('RA_OKTRANS','"+cMarkTransf+"')" )
	EndIF
EndIF

IF ( !Empty( cSraFilter ) )
	cSraFilter += " .and. RA_FILIAL == '" + cFilSra + "'"
Else
	cSraFilter += "RA_FILIAL == '" + cFilSra + "'"
EndIF

CREATE SCOPE aScopeCount FOR &( cSraFilter )
nProcRegua := SRA->( RecCount() )
RstTimeRemaining() //Reinicializa o Contador de Tempos em Proc2BarGauge()

If !lRobo
	BarGauge1Set( nProcRegua )
Endif

If !lMarca
	SET FILTER TO SRA->RA_OKTRANS == cMarkTransf
EndIf

CursorArrow()
lAbortPrint := .F.
SRA->( dbSeek( cFilSra , .F. ) )
While SRA->( !Eof() )
	If !lRobo
		IncPrcG1Time( NIL , nProcRegua , cTimeIni , .T. , NIL , 1 )
	Endif

	IF ( lAbortPrint )
		Exit
	EndIF

	If !Eval( bWhile , cSraFilter )
		SRA->( dbSkip() )
		Loop
	EndIf

	lLock := SRA->( Gpea180Mrk( "SRA" , lMarca , lInsiste , lUseCode ) )

	IF ( lMarca )
		IF ( lLock )
			++nLocks
		Else
			aAdd( aNoLocks , SRA->( Recno() ) )
		EndIF
	EndIF

	SRA->( dbSkip() )
End While

IF ( lMarca )
	IF ( Len( aNoLocks ) > 0 )
		IF ( nLocks == 0 )
			cMsg := STR0057	//"Não foi possível a reserva dos registros para o processo de Transferˆncia"
			cMsg += CRLF
			lChkMrk := .F.
		Else
			cMsg := STR0058	//"Não foi possível a reserva de alguns registros para o processo de Transferˆncia"
			cMsg += CRLF
		EndIF
		IF ( lMaxAdsLckRec := MaxAdsLckRec() )
			cMsg += STR0070  //"Excedeu o número de registros a serem reservados."
			CursorWait()
			nLoops := Len( aNoLocks )
			For nLoop := 1 To nLoops
				IF ( ( nNoLock := aScan( __aMrkRecnos__ , { |x| ( x == aNoLocks[ nLoop ] ) } ) ) > 0 )
					FreeCodeUsed( "SRA" , __aMrkKeys__[ nNoLock ] )
					nLastSize := Len( __aMrkRecnos__ )
					aDel( __aMrkRecnos__ 	, nNoLock )
					aDel( __aMrkKeys__	 	, nNoLock )
					aSize( __aMrkRecnos__	, ( nLastSize - 1 ) )
					aSize( __aMrkKeys__		, ( nLastSize - 1 ) )
				EndIF
			Next nLoop
			CursorArrow()
		Else
			cMsg += STR0059	//"Estes registros estão reservados para outro usuário ou existem rescisões pendentes."
		EndIF
		cMsg += CRLF
		cMsg += STR0060	//"O Processo de Transferencia, para estes registros, não será efetuado."
	EndIF
	IF ( lShowMsg )
		IF ( !Empty( cMsg ) )
			MsgInfo( OemToAnsi( cMsg ) )
		EndIF
	EndIF
EndIF

IF ( lChkMrk )
	lMarca := !( lMarca )
EndIF

	SET FILTER TO

SRA->( MsGoto( nRecno ) )

Return( lChkMrk )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFuncao    ³Gpea180MrkºAutor³Andreia dos Santos v.I º Data ³ 08/29/2003 º±±
±±º          ³          º     ³Marinaldo de Jesus v.IIº Data ³ 18/02/2004 º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Marca/desmarca um elemento do browse.                      º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function Gpea180Mrk( cAlias , lAll , lShowHelp , lUseCode )

Local aRec		:= Array( 1 )
Local aKey		:= Array( 1 )
Local lLock		:= .F.
Local bMark_	:= { || ExecMark( lAll ) }

Local bLock
Local cMsg
Local nPos

DEFAULT cAlias		:= Alias()
DEFAULT lShowHelp	:= .T.

Begin Sequence

	IF !( cAlias == "SRA" )
	    Break
	EndIF

	If fFindSrc(SRA->( RA_FILIAL+RA_MAT+RA_PROCES )) .AND. !SRA->( IsMark( "RA_OKTRANS" , cMarkTransf ) )
		MsgAlert( OemToAnsi(STR0156) + CRLF +;		//Existe Rescisão pendente para o Funcionário
				  " " + SRA->RA_NOME + CRLF +;
				 iIf(lGestPubl, OemToAnsi(STR0259), OemToAnsi(STR0157)),;//Favor efetuar o pagamento antes de proceder a transferencia.
				  OemToAnsi(STR0047) ) 				// "Atencao"

	Else
		aRec[1]	:= SRA->( Recno() )
		aKey[1]	:= SRA->( RA_FILIAL+RA_MAT )

		IF ( lShowHelp )
			//"O Registro "###" está reservado para outro usuário."
			cMsg := OemToAnsi( STR0066 + " " + AllTrim( Str( aRec[1] ) ) + " " + STR0067 )
			bLock := { || Gpea180Locks(	aRec , aKey , cMsg , .T. , lUseCode ) }
		Else
			bLock := { || LockRegsCode( "SRA" , aRec , aKey , 0 , 0 , lUseCode , NIL ) }
		EndIF

		IF !( lLock := SRA->( Eval( bLock ) ) )
			Break
		EndIF

		lLock := SRA->( Eval( bMark_ ) )
	EndIf

End Sequence

Return( lLock )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFuncao    ³ExecMark  º Autor ³Andreia dos Santos v.I º Data ³08/29/2003º±±
±±º          ³          º       ³Marinaldo de Jesus v.IIº Data ³18/02/2004º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Marca/desmarca um elemento do browse.                      º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function ExecMark( lAll )

Local lIsMark 	:= SRA->( IsMark( "RA_OKTRANS" , cMarkTransf ) )
Local lIsLocked	:= IsLocked( "SRA" , SRA->( Recno() ) )

IF ( lIsLocked )
	IF ( lAll == NIL )	//Inverte
		IF ( lIsMark )
	    	SRA->RA_OKTRANS := cRaOkTransSpc
			AddRmvMrk( .T. )
		Else
			SRA->RA_OKTRANS := cMarkTransf
			AddRmvMrk( .F. )
		EndIF
	Else
		IF ( lAll )
	    	SRA->RA_OKTRANS := cMarkTransf
			AddRmvMrk( .F. )
		ElseIF ( lIsMark )
	    	SRA->RA_OKTRANS := cRaOkTransSpc
	    	AddRmvMrk( .T. )
		EndIF
	EndIF
EndIF

Return( lIsLocked )

/*
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³AddRmvMrk		 ³Autor³Marinaldo de Jesus³ Data ³18/02/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Reserva/Liberacao do(s) Recno(s) e Chave(s) qdo Mark/UnMark ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³GEPA180  	                                                ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
Static Function AddRmvMrk( lRmv )

Local nRec  	:= SRA->( Recno() )
Local cKey  	:= SRA->( RA_FILIAL + RA_MAT )
Local nPos		:= aScan( __aMrkRecnos__ , { |x| ( x == nRec ) } )
Local nLastSize

DEFAULT lRmv := .F.

IF ( lRmv )
	IF ( IsLocked( "SRA" , nRec ) )
		Gpea180FreeLocks( nRec , cKey )
	EndIF
	IF ( nPos > 0 )
		nLastSize := Len( __aMrkRecnos__ )
		aDel( __aMrkRecnos__ 	, nPos )
		aDel( __aMrkKeys__	 	, nPos )
		aSize( __aMrkRecnos__	, ( nLastSize - 1 ) )
		aSize( __aMrkKeys__		, ( nLastSize - 1 ) )
	EndIF
Else
	IF ( nPos == 0 )
		aAdd( __aMrkRecnos__ , nRec )
		aAdd( __aMrkKeys__	 , cKey )
	EndIF
EndIF

Return( NIL )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFuncao    ³Gpea180CnfºAutor  ³Andreia dos Santos v.I ºData³29/08/2003  º±±
±±º          ³          º       ³Marinaldo de Jesus v.IIºData³18/02/2004  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Chama a rotina de transferencia dos arquivos e apos proces-º±±
±±º          ³samento desmarca todos os itens do browse.                  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function Gpea180Cnf(lAuto)

Local bLock	 	:= { || CursorWait() , lLocksOk := Gpea180Locks() , CursorArrow() , lLocksOk }
Local bUnLock	:= { || CursorWait() , Gpea180FreeLocks() , CursorArrow() }
Local lLocksOk	:= .T.
Local nOpcA		:= 0

Default lAuto	:= .F.

Begin Sequence

	//"Reservando os Registros para Transferencia"
	MsAguarde( bLock , OemToAnsi( STR0061 ) )

	IF !( lLocksOk )
		Break
	EndIF

	IF Empty( __aMrkRecnos__ )
		MsgInfo( OemToAnsi( STR0068 ) )				//"Não existem funcionários a serem transferidos"
		Break
	EndIF

	aLogTransf := {}
	RstTimeRemaining()								//Reinicializa o Contador de Tempos em Proc2BarGauge()

	nOpcA := Gpea180Mat( "SRA", NIL, 4, lAuto )		//Chamada aa rotina de Transferencia

	MsAguarde( bUnLock , OemToAnsi( STR0062 ) )

End Sequence

IF ( ( nOpcA <> 2 ) .or. ( Len( __aMrkRecnos__ ) > 0  ) )
	IF ( Len( __aMrkRecnos__ ) > 0  )
		//"Retirando a Seleção"
		If !lRobo
			Proc2BarGauge( { || Gpea180MkAll( .F. , .F. , .F. ) } , OemToAnsi( STR0056 ) , NIL , NIL , .T. , .T. , .F. , .F. )
		Else
			Gpea180MkAll( .F. , .F. , .F. )
		Endif
		__aMrkRecnos__	:= {}
		__aMrkKeys__	:= {}
	EndIF
EndIF

Return( NIL )

/*
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³Gpea180Locks ³Autor³Marinaldo de Jesus    ³ Data ³11/02/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Lock dos Registros                                          ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³GEPA180  	                                                ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
Static Function Gpea180Locks( aRecnos , aKeys , cMsg1 , lUseCode )

Local lLocks		:= .T.

Local aQueryCond
Local aFieldsLock
Local bSkip
Local bLock
Local cFilSRA
Local cSraFilter

DEFAULT __aMrkRecnos__	:= {}
DEFAULT __aMrkKeys__	:= {}
DEFAULT aRecnos 		:= __aMrkRecnos__
DEFAULT aKeys			:= __aMrkKeys__
DEFAULT cMsg1			:= STR0063	//"Não foi possivel reservar todos os registros para transferência"
DEFAULT lUseCode		:= .T.

//Quando o controle de matricula esta ativado a transferencia ficou restrita a um registro por vez
If lCtrAutoMat .And. Len(aRecnos) > 1
	MsgAlert( OemToAnsi(STR0188), OemToAnsi(STR0034) )	//"Quando existe numeração automática de matricula a transferência deve ser individual"#"Transferencia de Matricula"
	Return( .F. )
EndIf

Begin Sequence

	IF ( Empty( aRecnos ) .and. Empty( aKeys ) )
		cFilSRA := xFilial( "SRA" )
		aQueryCond		:= Array( 05 )
		aQueryCond[01]	:= "RA_FILIAL='"+cFilSRA+"'"
		aQueryCond[02]	:= " AND "
		aQueryCond[03]	:= "RA_OKTRANS='"+cMarkTransf+"'"
		aQueryCond[04]	:= " AND "
		aQueryCond[05]	:= "D_E_L_E_T_=' ' "
		aFieldsLock		:= { "RA_FILIAL" , "RA_MAT" , "RA_OKTRANS" }

		IF Empty( cSraFilter := SRA->( dbFilter() ) )
			bSkip	:= { || !IsMark( "RA_OKTRANS" , cMarkTransf ) }
		Else
			bSkip	:= { || !IsMark( "RA_OKTRANS" , cMarkTransf ) .or. !( &( cSraFilter ) ) }
		EndIF

		aKeys 	 := {}
		aRecnos	 := {}
		bLock 	 := { |lLock,lExclu|	lLock 	:= .T.	,;
										lExclu	:= .T.	,;
										GdMontaCols(NIL				,;	//01 -> Array com os Campos do Cabecalho da GetDados
													NIL				,;	//02 -> Numero de Campos em Uso
													NIL				,;	//03 -> [@]Array com os Campos Virtuais
													NIL    			,;	//04 -> [@]Array com os Campos Visuais
													"SRA" 			,;	//05 -> Opcional, Alias do Arquivo Carga dos Itens do aCols
													aFieldsLock		,;	//06 -> Opcional, Campos que nao Deverao constar no aHeader
													@aRecnos		,;	//07 -> [@]Array unidimensional contendo os Recnos
													"SRA"		   	,;	//08 -> Alias do Arquivo Pai
													cFilSRA			,;	//09 -> Chave para o Posicionamento no Alias Filho
													NIL  			,;	//10 -> Bloco para condicao de Loop While
 													bSkip			,;	//11 -> Bloco para Skip no Loop While
													.F.     		,;	//12 -> Se Havera o Elemento de Delecao no aCols
													.F.     		,;	//13 -> Se cria variaveis Publicas
													.F.     		,;	//14 -> Se Sera considerado o Inicializador Padrao
													NIL  			,;	//15 -> Lado para o inicializador padrao
													.F.       		,;	//16 -> Opcional, Carregar Todos os Campos
													.T.         	,;	//17 -> Opcional, Nao Carregar os Campos Virtuais
													aQueryCond		,;	//18 -> Opcional, Utilizacao de Query para Selecao de Dados
													.F.				,;	//19 -> Opcional, Se deve Executar bKey  ( Apenas Quando TOP )
													.T.				,;	//20 -> Opcional, Se deve Executar bSkip ( Apenas Quando TOP )
													.F.				,;	//21 -> Carregar Coluna Fantasma
													.T.				,;	//22 -> Inverte a Condicao de aNotFields carregando apenas os campos ai definidos
													.F.				,;	//23 -> Verifica se Deve verificar se o campo eh usado
													.F.				,;	//24 -> Verifica se Deve verificar o nivel do usuario
													.F.				,;	//25 -> Verifica se Deve Carregar o Elemento Vazio no aCols
													@aKeys			,;	//26 -> [@]Array que contera as chaves conforme recnos
													@lLock			,;	//27 -> [@]Se devera efetuar o Lock dos Registros
													@lExclu			 ;	//28 -> [@]Se devera obter a Exclusividade nas chaves dos registros
													),;
									( lLock .and. lExclu );
					}
		__aMrkRecnos__	:= aClone( aRecnos )
		__aMrkKeys__	:= aClone( aKeys   )
	Else
		bLock := { || LockRegsCode( "SRA" , aRecnos , aKeys , 0 , 0 , lUseCode , NIL ) }
	EndIF

	IF !( lLocks := WhileYesNoWait(;
										bLock															,;	//Bloco a Ser Executando Enquando ( Devera Retornar Valor Logico )
										5																,;	//Numero de Tentativas
										.T.																,;	//Se podera Encerrar as as Tentativas ( Button Cancel Enabled )
										OemToAnsi( cMsg1 )												,;	//Mensagem de Corpo para a MsgInfo
										cCadastro														,;	//Titulo para a MsgInfo
										OemToAnsi( STR0064 ) /*"Tentar novamente?"*/					,;	//Mensagem de Corpo para a MsgYesNo
										cCadastro														,;	//Titulo para a MsgYesNo
										OemToAnsi( STR0065 ) /*"Tentando reservar o(s) registro(s)."*/	,;	//Mensagem de corpo para a ProcWaiting
										cCadastro												 		 ;	//Titulo para a ProcWaiting
								  );
		)
		Break
	EndIF

End Sequence

Return( lLocks )

/*
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³Gpea180FreeLocks ³Autor³Marinaldo de Jesus³ Data ³11/02/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Libera os Locks dos Registros                               ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³GEPA180  	                                                ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
Static Function Gpea180FreeLocks( nRecno , cUsedCod )
Return( FreeLocks( "SRA" , nRecno , .T. , cUsedCod ) )

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³ChkFullName  ³Autor³Marinaldo de Jesus    ³ Data ³30/08/2004³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Verifica se a Tabela e Compartilhada entre empresas         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpL1: .T.                                                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³Generico                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Static Function ChkFullName( cAlias )

Local lEqualFullName

lEqualFullName  := (;
						( lEmpDif );
						.and.;
						!( lFilDif );
						.and.;
						EqualFullName( cAlias , cEmpAte , __cEmpAnt );
					)

Return( lEqualFullName )

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³Gpea180Grava³ Autor ³ Equipe Advanced RH  ³ Data ³19/10/2005³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Grava no arquivo de transferencia os dados para gestão pu-  ³±±
±±³          |blica                                                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³GPEA180                                                     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function Gpea180Grava(cAlias)
Local SreRecno := SRE->(Recno())
Local n, cVar, cVar1, cAliasMemo
Local aArea := GetArea()

dbSelectArea( "SRE" )

Begin Transaction
	SRE->( RecLock( cAlias , .F. ) )
	SRE->RE_TPDATO := aCols[SRERecno,nPOSGP_TPDATO]
	SRE->RE_DTBLEG := aCols[SRERecno,nPosGP_DTBLEG]
	SRE->RE_TPBLEG := aCols[SRERecno,nPosGP_TPBLEG]
	SRE->RE_NRBLEG := aCols[SRERecno,nPosGP_NRBLEG]
	M->RE_COMPL    := aCols[SRERecno,nPosGP_COMPL]
	If Len(aMemos) > 0
		For n := 1 to Len(aMemos)
			cVar  := aMemos[n][2]
			cVar1 := aMemos[n][1]
			cAliasMemo := If(len(aMemos[n]) == 3,aMemos[n][3],Nil)
			MSMM(&cVar1,TamSx3(aMemos[n][2])[1],,&cVar,1,,,cAlias,aMemos[n][1],cAliasMemo)
		Next n
	EndIf
	SRE->( MsUnLock() )
End Transaction

RestArea( aArea )

Return( .T. )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³fCpoCompl ºAutor  ³Microsiga           º Data ³  03/05/08   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Monta aHeader com os campos complementares                  º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function fCpoCompl()

Local nX		:= 0
Local nLenaField:= Len(aFields1)

Private aDicioT := {}			//Array contendo os campos do SX3
Private aDicioW	:= {} 			//Array auxiliar do aDicioT com  campos selecionados

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Carrega   o array com os campos ja selecionados - aDicioT   ³
//³ conforme GpeCpoCompl.ch                                     ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Gpea180Sel()

aDicioT:= {}

Aeval(aDicioW, {|x| If(x[2], aAdd(aDicioT,{x[1],x[2],x[3]}  ),"")    } )

For Nx := 1 to Len(aDicioT)
	aAdd( aFields1 , aDicioT[nX,3]  )
Next nX

lTemCpoCompl:= Len(aFields1) > nLenaField

Return(aFields1)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³fA180ChangeBMPºAutor  ³Natie               º Data ³  04/03/08   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³                                                                º±±
±±º          ³                                                                º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                             º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function fA180ChangeBMP(oGetSRA1,oGetSRA2)

If oGetSRA2:aCols[oGetSRA2:nAt,_COLBMP]	<> "BR_VERDE"
	oGetSRA2:aCols[oGetSRA2:nAt,_COLBMP]	:= "BR_VERDE"
ElseIf oGetSRA2:aCols[oGetSRA2:nAt,_COLBMP]	== "BR_VERDE"
	If oGetSRA1:aCols[oGetSRA1:nAt,_COLBMP]	= "BR_AZUL"
		oGetSRA2:aCols[oGetSRA2:nAt,_COLBMP]	:= "BR_AZUL"
	Else
		oGetSRA2:aCols[oGetSRA2:nAt,_COLBMP]	:= "BR_BRANCO"
	Endif
Endif

oGetSRA2:Refresh()
oGetSRA1:Refresh()

Return .T.

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³ Fun‡…o   ³fTransfLegen³ Autor ³ Natie                 ³ Data ³21/09/2000³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Descri‡…o³ Cria uma janela contendo a legenda da Transferencia          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³                                                              ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function fTransfLegen()
	Local aLegenda := {;
						{"BR_BRANCO",OemToAnsi(STR0135)	}	,;	//"Não possui solicitação de transferências"
						{"BR_VERDE" ,OemToAnsi(STR0136) }  ,;	//"Funcionários Selecionados para Transf. Destino unico "
						{"BR_AZUL"	,OemToAnsi(STR0137)	}    ;	//"Solicitação de Transf.confirmada"
						}

	BrwLegenda(	OemToAnsi(STR0008)						,;	//Transferencias
				OemToAnsi(STR0021)						,;	//"Legenda"
				aLegenda ;
			 )

Return .T.

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³GpeConfCTrans ºAutor  ³Microsiga           º Data ³  05/20/08   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Configuracao dos campos complementares para a transferencia    º±±
±±º          ³                                                                º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                             º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function GpeConfCTrans( )
	Local aArea			:= GetArea()
	Private aDicioT 	:= {}															//-- Array contendo os campos do SX3
	Private aDicioW		:= {} 															//-- Array auxiliar do aDicioT com  campos selecionados

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Carrega   o array com os campos ja selecionados - aDicioT   ³
	//³ conforme GpeCpoCompl.ch                                     ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	Gpea180Sel()

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Selecao dos campos complementares                 aDicioT   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	Gpea180Cpo()

	RestArea( aArea )
Return

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³Gpea180Sel    ³Autor³Natie                ³ Data ³04/03/2008³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Configura array com  campos selecionados                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ gpea180                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function Gpea180Sel()
	Local aDicFch 	:= {}
	Local cFile  	:= "GpeCpoCompl.fch"
	Local cBuffer	:= ""
	Local cString	:= ""
	Local n			:= 0
	Local nHdl		:= 0
	Local nFor 		:= 0
	Local nPos 		:= 0
	Local nTamArq 	:= 0
	Local nBytes 	:= 0
	Local cX3campo	:= ""
	Local aNotCmp	:= {}

	//--Utilizacao do modulo SIGAGFP (gestao de folha publica)
	lGestPubl 	:= If( type("lGestPubl")=="U", if(ExistFunc("fUsaGFP"),fUsaGFP(),.f.) ,lGestPubl)

	aAdd( aNotCmp , "RA_CODFUNC" )
	aAdd( aNotCmp , "RA_CARGO" )
	aAdd( aNotCmp , "RA_SALARIO" )
	aAdd( aNotCmp , "RA_TIPOALT" )
	aAdd( aNotCmp , "RA_DATAALT" )
	If cPaisLoc == "MEX"
		aAdd( aNotCmp , "RA_KEYLOC" )
	EndIf

	If !lItemClvl
		cX3campo:="RA_MAT , RA_CC , RA_PROCES , RA_DEPTO , RA_POSTO"
	Else
		cX3campo:="RA_MAT , RA_CC , RA_PROCES , RA_DEPTO , RA_POSTO, RA_ITEM, RA_CLVL"

	EndIf

	If  lGestPubl .AND. cModulo $ "GFP*VDF"  //Se Gestao de Folha Publica - SIGAGFP
        cX3campo += "RA_DEPTO, RA_CODFUNC ,RA_CATFUNC,RA_TNOTRAB ,RA_DESCTUR , RA_DESCFUN , RA_CARGO , RA_HRSMES , RA_HRSEMAN , RA_SALARIO , RA_ANTEAUM ,"
		cX3campo += "RA_ANTEAUM , RA_ANTEAUM , RA_TABELA , RA_TABNIVE , RA_TABFAIX , RA_DATAALT , RA_TIPOALT "
	EndIf

	dbSelectArea("SX3")
	dbSetOrder(1)
	dbSeek("SRA")
	While ! Eof() .And. SX3->X3_ARQUIVO = 'SRA'

		If ( SX3->X3_TIPO = "M" ) .or. ;
		     Alltrim(SX3->X3_CAMPO) $(cX3campo)  .or. ;
			 ( cPaisLoc<>"MEX" .and. Alltrim(SX3->X3_CAMPO) $ "RA_ADMISSA" ) 							//-- Dt Admissao pode ser alterada no MEX
			SX3->(dbSkip())
			Loop
		Endif

		If X3USO(SX3->X3_USADO)

			If (cOrgCfg == "1")
				nPos := Ascan(aNotCmp,{|x| Alltrim(x) == Alltrim(SX3->X3_CAMPO)})
				If nPos == 0
					Aadd(aDicioT, X3Titulo()+Space(14)+CHR(179)+"[ ]"+Space(5)+SX3->X3_CAMPO )
				EndIf
			Else
				Aadd(aDicioT, X3Titulo()+Space(14)+CHR(179)+"[ ]"+Space(5)+SX3->X3_CAMPO )
			Endif

		Endif
		dbSkip()
	Enddo

	If File("GpeCpoCompl.fch")

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Le arquivo texto - Nro total de linhas     ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		nHdl    := Fopen(cfile,64)				//Abertura e gravacao e compartilhamento

		If Ferror() # 0 .or. nHdl < 0
		    Help(" ",1,"A210NOPEN")
		    Break
		EndIf

		cString		:= FReadStr(nHdl,64)
		nBytes := (At( CHR(13)+CHR(10),cString )) + 1

		nTamArq 	:= fSeek(nHdl,0,2)
		fSeek(nHdl,0,0)
		nFor 		:= nTamArq / nBytes
		cBuffer		:= space(nBytes)
		FRead(nHdl,@cBuffer,nBytes)

		For n:=1 to nFor
			If (cOrgCfg == "1")
				nPos := Ascan(aNotCmp,{|x| Alltrim(x) == Alltrim(substr(cBuffer,36,50))})
				If nPos == 0
					Aadd(aDicFch,cBuffer)
				EndIf
			Else
				Aadd(aDicFch,cBuffer)
			Endif

			cBuffer		:= space(nBytes)
			FRead(nHdl,@cBuffer,nBytes)
		Next n

		For n:= 1 to Len(aDicioT)
			nPos 	:= Ascan(aDicFch,{ |x| Subs(x,36,10)=Subs(aDicioT[n],36,10) })
			If nPos > 0
				aDicioT[n]	:= Subs(ADicioT[n],1,28)+Subs(aDicFch[nPos],29,1)+']'+Subs(aDicioT[n],31,23)+Subs(aDicioT[n],54,2)+Subs(aDicioT[n],56,3)				//mantem a ordem do SX3 para ser alterada pelo usuario
			Endif
		Next n
		FClose(nHdl)
	EndIf

	Aeval(aDicioT,{ |x| Aadd(aDicioW,{Subs(x,1,16),;   							//Descricao Campo
									   If (Subs(x,29,1) = "X",.t.,.f.),;			//usado/nao usado
									   Subs(x,36,12) , ;                           //Campo
									   })  } )
Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³Gpea180CpoºAutor  ³Microsiga           º Data ³  03/03/08   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Seleciona os campos complementares                          º±±
±±º          ³Campos que serao alterados na transferencias                º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function Gpea180Cpo()
	Local aKeys		:= GetKeys()
	Local cFile  	:= "GpeCpoCompl.fch"
	Local cDet  	:= ""
	Local cPesq 	:= Space(20)
	Local lSeek 	:= .F.
	Local n         := 0
	Local nHdl		:= 0
	Local nOpt		:= 0
	Local nPos 		:= 0
	Local aDicBkp 	:= {}
	Local oDlg5
	Local oFont3
	Local oFont
	Local oFont06
	Local oBtnMarcTod
	Local oBtnDesmTod
	Local oBtnInverte
	Local oBtnPesq
	Local oGroup1
	Local oGroup2

	Local oUso
	Local oPesq

	Local bNIL			:= { || NIL }
	Local bSvVK_F5		:= bNIL
	Local bSvVK_F6		:= bNIL
	Local bSvVK_F7		:= bNIL
	Local bSeek			:= { || fPesquisa( oUso, oUso:nAT, cPesq ) }

	Local aAdvSize		:= {}
	Local aInfoAdvSize	:= {}
	Local aObjSize		:= {}
	Local aObjCoords	:= {}

	Local aAdv1Size		:= {}
	Local aInfo1AdvSize	:= {}
	Local aObj1Size		:= {}
	Local aObj1Coords	:= {}

	Local aAdv2Size		:= {}
	Local aInfo2AdvSize	:= {}
	Local aObj2Size		:= {}
	Local aObj2Coords	:= {}

	Local aButtons		:= {}

Local nK := 0

	aDicBkp 	:= Aclone(aDicioT)

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Define o cabecalho da tela de atualizacoes                  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	oOk := LoadBitmap( GetResources(), "ENABLE" )
	oNo := LoadBitmap( GetResources(), "LBNO" )

	SETAPILHA()

	aAdvSize		:= MsAdvSize(,.T.,390)
	aInfoAdvSize	:= { aAdvSize[1] , aAdvSize[2] , aAdvSize[3] , aAdvSize[4] , 5 , 5 }
	aAdd(aObjCoords, { 000, 027, .T., .F.} ) 			//1-selecao dos campos complementares
	aAdd(aObjCoords, { 000, 000, .T., .T.} )     		//2-Group ListBox
	aObjSize		:= MsObjSize(aInfoAdvSize , aObjCoords)

	aAdv1Size		:= aClone(aObjSize[1])
	aInfo1AdvSize	:= { aAdv1Size[2] , aAdv1Size[1] , aAdv1Size[4] , aAdv1Size[3] , 5 , 10 }
	aAdd(aObj1Coords, { 050, 000, .F., .T.} )			//1-MsGet
	aAdd(aObj1Coords, { 000, 000, .T., .T.} )			//2-SButton
	aObj1Size		:= MsObjSize(aInfo1AdvSize , aObj1Coords,,.T.)

	aAdv2Size		:= aClone(aObjSize[2])
	aInfo2AdvSize	:= { aAdv2Size[2] , aAdv2Size[1] , aAdv2Size[4] , aAdv2Size[3] , 0 , 0 }
	aAdd(aObj2Coords, { 000, 000, .T., .T. , .T.} )	 		//1-LisBox
	aObj2Size		:= MsObjSize(aInfo2AdvSize , aObj2Coords)

	DEFINE FONT oFont3  NAME "Arial" BOLD
	DEFINE FONT oFont   NAME "Arial" SIZE 0,-11
	DEFINE FONT oFont06 NAME "Arial" SIZE 01,01

	If !lRobo
		DEFINE MSDIALOG oDlg5 FROM aAdvSize[7], 0 TO aAdvSize[6], aAdvSize[5]  TITLE OemToAnsi(STR0100) PIXEL	//Selecao de campos

		oDlg5:lEscClose := .F.
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Grupo : Pesquisa    campos complementares                               ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		@ aObjSize[1,1], aObjSize[1,2] 	GROUP oGroup2 	TO aObjSize[1,3], aObjSize[1,4] LABEL OemToAnsi(STR0094) OF oDlg5 PIXEL COLOR CLR_BLUE 			//-- Nome ou Titulo do Campo
		oGroup2:oFont:= oFont3

		@ aObj1Size[1,1], aObj1Size[1,2] MSGET oPesq 	VAR cPesq SIZE 50,10 PICTURE "@!" PIXEL  OF oDlg5

		DEFINE SBUTTON FROM aObj1Size[2,1], aObj1Size[2,2] TYPE 1 OF oDlg5 ENABLE ACTION ( Eval(bSeek), cPesq:= Space(20),oUso:Refresh() )

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Grupo : selecao dos campos complementares                              ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		@ aObjSize[2,1],aObjSize[2,2] Group oGroup1 To aObjSize[2,3], aObjSize[2,4] PROMPT OemToAnsi(STR0100) Of oDlg5 Pixel COLOR CLR_BLUE 		// Selecao de campos
		oGroup1:oFont:= oFont3

		@ aObjSize[2,1]+10,aObjSize[2,2]+5 LISTBOX oUso ;
				FIELDS HEADER STR0096,STR0097, STR0098;  //"U."###Titulo Campo###"Campos "
				SIZE aObj2Size[1,3]-10,aObj2Size[1,4]-15 ;
				ON DBLCLICK ( fTroca("",oUso:nAT), oUso:Refresh(.f.)  ) ;
				OF oDlg5 PIXEL  CENTERED
				oUso:SetArray(aDicioW)
				oUso:bLine := { || {if(aDicioW[oUso:nAt,2],oOk,oNo),OemToAnsi(aDicioW[oUso:nAt,1]),aDicioW[oUso:nAt,3]}}
				oUso:Refresh()

		Aadd( aButtons, {NIL, {|| (fTroca("M"),oUso:Refresh())}, OemToAnsi(STR0101), OemToAnsi(STR0101), {|| .T.}} )

		Aadd( aButtons, {NIL, {|| (fTroca("D"),oUso:Refresh())}, OemToAnsi(STR0102), OemToAnsi(STR0102), {|| .T.}} )
		Aadd( aButtons, {NIL, {|| (fTroca("I"),oUso:Refresh())}, OemToAnsi(STR0103), OemToAnsi(STR0103), {|| .T.}} )

		SetKey(VK_F5,{ ||(fTroca("M"),oUso:Refresh()) } )
		SetKey(VK_F6,{ ||(fTroca("D"),oUso:Refresh()) } )
		SetKey(VK_F7,{ ||(fTroca("I"),oUso:Refresh()) } )

		ACTIVATE MSDIALOG oDlg5 ON INIT EnchoiceBar(oDlg5,{||nOpt:=1 , fChkCpoRel() ,RestKeys(aKeys,.T.) ,oDlg5:End() },{||RestKeys(aKeys,.T.),oDlg5:End()},,aButtons) CENTERED

	Else
		For nK:=1 To Len(aCampADD)
			If (nPos:=(ascan(aDicioW,  {|x| Alltrim(x[3]) == aCampADD[nK] }))) > 0
				fTroca( "" , nPos)
			Endif
		End
		nOpt := 1
		fChkCpoRel()
		RestKeys(aKeys,.T.)
	Endif

	SETAPILHA()

	If nOpt == 1
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Volta o Array da tela para o aDicioT para ser gravado                   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		aDicioT := {}
		Aeval(aDicioW,{ |x| Aadd(aDicioT,Subs(x[1],1,12)+Space(14)+CHR(179)+"["+If (x[2],"X"," ")+"]"+Space(5)+x[3] )})

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ grava no arquivo GpeCpoCompl                                           ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		nHdl := MSFCREATE(cFile,FC_NORMAL)
		If nHdl == -1   .or. fError() # 0
			Help(" ",1,"SAVECONS")
		Else
			For n=1 to Len(aDicioT)
				cDet	:= aDicioT[n]+Chr(13)+Chr(10)
				fWrite(nHdl,cDet,Len(cDet) )
			Next
		EndIf
		FClose(nHdl)    //Fecha arq.binario e grava no disco
	Else
		aDicioT	:= Aclone(aDicBkp)
	Endif

	DeleteObject(oOk)
	DeleteObject(oNo)
	RestKeys(aKeys,.T.)
Return(nil)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³fChkCpoRelºAutor  ³Microsiga           º Data ³  03/04/08   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Verifica se cpos selecionados possuem outros relacionados   º±±
±±º          ³e que devem  ser tbem preenchidos na alteracao              º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function fChkCpoRel()

Local aDicioAux	:= {}
Local aLogTransf:= {}
Local lRet 		:= .T.
Local lFirst	:= .T.
Local nX		:= 0
Local bMakeLog		:= { || NIL }

Aeval(aDicioW, {|x| If(x[2], aAdd(aDicioAux,{x[1],x[2],x[3]}  ),"")    } )

For nX := 1 to Len(aDicioAux)

	If aDicioAux[nX,3] $ ('RA_SALARIO*RA_CODFUNC*RA_ANTEAUM*RA_CARGO')
		f180LogCpo( aDicioAux, "RA_TIPOALT" 	, aDicioAux[nX ,3] , @aLogTransf )
		f180LogCpo( aDicioAux, "RA_DATAALT" 	, aDicioAux[nX ,3] , @aLogTransf )

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Validacao efetuada no Gp010ValSal                                      ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If cPaisLoc == "MEX"  .AND. aDicioAux[nX,3] = 'RA_SALARIO'
			f180LogCpo( aDicioAux, "RA_PERAUM" 		, aDicioAux[nX ,3] , @aLogTransf )
			f180LogCpo( aDicioAux, "RA_PAGAUM" 		, aDicioAux[nX ,3] , @aLogTransf )
		EndiF
	ElseIf aDicioAux[nX,3] $ ('RA_TIPOALT*RA_DATAALT')
		f180LogCpo( aDicioAux, "RA_SALARIO" 	, aDicioAux[nX ,3] , @aLogTransf )
	ElseIf aDicioAux[nX,3] $ 'RA_SEQTURN/RA_TNOTRAB/RA_REGRA'
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Validacao efetuada no Gpea010seqVld                                    ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		f180LogCpo( aDicioAux, "RA_TNOTRAB", aDicioAux[nX ,3] , @aLogTransf )
		f180LogCpo( aDicioAux, "RA_REGRA"  , aDicioAux[nX ,3] , @aLogTransf )
		f180LogCpo( aDicioAux, "RA_SEQTURN", aDicioAux[nX ,3] , @aLogTransf )

	ElseIf cPaisLoc == "MEX"
	 	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Validacao efetuada no GP010Adm                                         ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If aDicioAux[nX,3] $ 'RA_ADMISSA'
			f180LogCpo( aDicioAux, "RA_PERADM" 		, aDicioAux[nX ,3] , @aLogTransf )
			f180LogCpo( aDicioAux, "RA_PAGADM" 		, aDicioAux[nX ,3] , @aLogTransf )
		Elseif 	 aDicioAux[nX,3] $ 'RA_DEMISSA/RA_CODRPAT'											//-- Registro Patronal
			f180LogCpo( aDicioAux, "RA_TIPOAFA" , aDicioAux[nX ,3] , @aLogTransf )

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Validacao efetuada no Gp010ValSit                                      ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		ElseIf aDicioAux[nX,3] $ 'RA_SITFOLH'
			f180LogCpo( aDicioAux, "RA_DEMISSA" , aDicioAux[nX ,3] , @aLogTransf )
			f180LogCpo( aDicioAux, "RA_FECREI"  , aDicioAux[nX ,3] , @aLogTransf )
			f180LogCpo( aDicioAux, "RA_DTBIMSS" , aDicioAux[nX ,3] , @aLogTransf )
			f180LogCpo( aDicioAux, "RA_TIPOAFA" , aDicioAux[nX ,3] , @aLogTransf )
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Validacao efetuada no Gpea010InfVal()                                  ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		ElseIf aDicioAux[nX,3] $ 'RA_TIPINF/RA_NUMINF'
			f180LogCpo( aDicioAux, "RA_DTMDINF" , aDicioAux[nX ,3] , @aLogTransf )
			f180LogCpo( aDicioAux, "RA_NUMINF" , aDicioAux[nX ,3] , @aLogTransf )
			f180LogCpo( aDicioAux, "RA_TIPINF" , aDicioAux[nX ,3] , @aLogTransf )
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Validacao efetuada no Gp010SuspValid                                   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		ElseIf aDicioAux[nX,3] $ 'RA_DTISINF/RA_DTCINF'
			f180LogCpo( aDicioAux, "RA_DTISINF", aDicioAux[nX ,3] , @aLogTransf )
			f180LogCpo( aDicioAux, "RA_DTCINF" , aDicioAux[nX ,3] , @aLogTransf )
			If aDicioAux[nX,3] $ 'RA_DTISINF
				f180LogCpo( aDicioAux, "RA_DTRDINF" , aDicioAux[nX ,3] , @aLogTransf )
			Endif
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Validacao efetuada no Gp010ReinValid                                   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		ElseIf aDicioAux[nX,3] $ 'RA_DTRDINF'
			f180LogCpo( aDicioAux, "RA_DTISINF", aDicioAux[nX ,3] , @aLogTransf )
		Endif
    Endif
Next nX

IF !Empty( aLogTransf )
	IF ( MsgNoYes( OemToAnsi( STR0105) + CRLF  + OemToAnsi(STR0106) + CRLF+ ; 	//- A manutencao dos campos selecionados podem  implicar no preenchimento de outros e portanto estes também devem ser preenchidos
				   OemToAnsi( STR0107)   ,;                    				   	//--Deseja imprimir Log ?
	               OemToAnsi( STR0047 ) ) )										//-- Atencao
		bMakeLog := { || fMakeLog( { aLogTransf } ,  { STR0073 } , NIL , .T. , FunName() , NIL , "G" , "L" , NIL , NIL ) }
		MsAguarde( bMakeLog , OemToAnsi( STR0073 ) ) 												//-- Log de Ocorrencias
	EndIF
EndIF

Return(lRet)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³GPEA180   ºAutor  ³Microsiga           º Data ³  03/05/08   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Log de aviso de campos que devem  ser utilizados conforme   º±±
±±º          ³relacionamento com  os campos escolhidos                    º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function f180LogCpo(aDicioAux, cCampo, cCpoMain, aLogTransf )

Local nPos := 0

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Os campos complementares e que possuem relacionamento se,    ³
//³ preenchidos,deverao ser validados no momento da transferencia³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If !(nPos:= ascan( aDicioAux, {|x|alltrim(x[3]) == alltrim(cCampo) }  ) ) > 0

	aAdd( aLogTransf , OemToAnsi(STR0108)  + cCpoMain+ OemToAnsi(STR0109)  + cCampo  )  //--"O campo  XXXXXXXXX " está vinculado ao preenchimento do campo YYYYYYYYY"

Endif

Return(NIl)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³fPesquisa ºAutor  ³Microsiga           º Data ³  03/04/08   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Efetua pesquisa de campo/titulo de campo na config.campos   º±±
±±º          ³complementares                                              º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static function fPesquisa(oUso,nEstou, cPesq)

	Local lRetOk:= .F.
	Local nPos 	:= 0

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Monta o Dialogo de pesquisa                                  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	nPos	:= ascan(aDicioW, {|x| UPPER( ALLTRIM(x[1]) )  = ALLTRIM(cPesq)  } )		//-- Nome Campo
	If nPos	= 0
		nPos := ascan(aDicioW, {|x|ALLTRIM(x[3])= ALLTRIM(cPesq) } ) 					//-- Titulo do campo
	Endif

	If nPos > 0
		oUso:nAt	:= nPos
	Else
		MsgAlert( OemToAnsi(STR0154) ,;				// Campo ou titulo nao localizado.
				OemToAnsi(STR0047) ) 				// "Atencao"
		lRetOk		:= .F.
		oUso:nAT 	:= nEstou
	Endif

	oUso:Refresh()

Return(lRetOk)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³fTroca    ºAutor  ³Microsiga -Natie    º Data ³  02/04/02   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Efetua a troca da selecao no ListBox                        º±±
±±º          ³(controle Usado/nao usado )                                 º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP5                                                        º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function fTroca( cTipo  ,		; //Tipo da Multipla Selecao "M"Marca todos ; "D" Desmarca Todos; "I" Inverte Selecao
					    nEstou )		  //oUso:nAt

	Local 	nPos 	:= 0

	IF cTipo == "M"
		aEval( aDicioW , { |x,y| aDicioW[y,2] := .T. } )
	ElseIF cTipo == "D"
		aEval( aDicioW , { |x,y| aDicioW[y,2] := .F. } )
	ElseIF cTipo == "I"
		aEval( aDicioW , { |x,y| aDicioW[y,2] := !aDicioW[y,2] } )
	Else
		aDicioW[nEstou,2] := !aDicioW[nEstou,2]

		If aDicioW[nEstou,3]= "RA_SALARIO"
			If (nPos:=(ascan(aDicioW,  {|x| x[3] =="RA_TIPOALT"  }      )       ) )  > 0
				aDicioW[nPos,2] := aDicioW[nEstou,2]
			Endif

			If (nPos:=(ascan(aDicioW,  {|x| x[3] =="RA_DATAALT"  }      )       ) )  > 0
				aDicioW[nPos,2] := aDicioW[nEstou,2]
			Endif

		ElseIf aDicioW[nEstou,3]= "RA_TIPOALT"
			If (nPos:=(ascan(aDicioW,  {|x| x[3] =="RA_SALARIO"  }      )       ) )  > 0
				aDicioW[nPos,2] := aDicioW[nEstou,2]
			Endif
			If (nPos:=(ascan(aDicioW,  {|x| x[3] =="RA_DATAALT"  }      )       ) )  > 0
				aDicioW[nPos,2] := aDicioW[nEstou,2]
			Endif
		ElseIf aDicioW[nEstou,3]= "RA_DATAALT"
			If (nPos:=(ascan(aDicioW,  {|x| x[3] =="RA_SALARIO"  }      )       ) )  > 0
				aDicioW[nPos,2] := aDicioW[nEstou,2]
			Endif
			If (nPos:=(ascan(aDicioW,  {|x| x[3] =="RA_TIPOALT"  }      )       ) )  > 0
				aDicioW[nPos,2] := aDicioW[nEstou,2]
			Endif
		Endif

	EndIF

Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³fAllHeader   ºAutor  ³Microsiga           º Data ³  03/18/08   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Monta o aHeader com todos os campos do SRA                     º±±
±±º          ³                                                               º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                            º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function fAllHeader()

	Local aArea			:= GetArea()
	Local nUsado 		:= 0
	Local cTitulo		:= ""
	Local cBox			:= ""
	Local cVisual		:= ""
	Local cValid   		:= ""
	Local cF3			:= ""
	Local cPicture		:= ""
	Local cWhen 		:= ""
	Local aHeader_aux	:= {}
	Local ACAMPOS		:= {}

	dbSelectArea("SX2")
	sx2->(dbseek("SRA") )

	dbSelectArea("SX3")
	SX3->(dbSetOrder(1))
	SX3->(dbGoTop())
	SX3->(dbseek("SRA"))

	Aadd(aHeader_Aux,{ ""                 ,"COLBMP"    						,"@BMP", 2, 0, "",	 		Chr(251),			"C", "",	"", "", "", "", "V",  "", "", .F.})
	Aadd(aHeader_Aux,{ OemToAnsi(STR0011), "M_EMPRESA" 						,"@!",   2, 0, "Ch_Emp()",	"€€€€€€€€€€€€€€ ",	"C", "YM0",	"", "", "", "", "R", "", "", .F.})
	Aadd(aHeader_Aux,{ OemToAnsi(STR0023)+ OemToAnsi(STR0011), "M_NEMPRESA","@!",  15, 0, "",			"€€€€€€€€€€€€€€ ",	"C", "",	"", "", "", "", "V", "", "", .F.})
	Aadd(aHeader_Aux,{ OemToAnsi(STR0012), "RA_FILIAL" 						,"@!",   2, 0, "Ch_Fil()",	"€€€€€€€€€€€€€€ ",	"C", If(cConSM0, "XM0GPE", "XM0" ),	"", "", "", "", "R", "", "", .F.})
	Aadd(aHeader_Aux,{ OemToAnsi(STR0023)+ OemToAnsi(STR0012), "M_NFILIAL" ,"@!",  15, 0, "",			"€€€€€€€€€€€€€€ ",	"C", "",	"", "", "", "", "V", "", "", .F.})

	//Tipo de Desligamento - eSocial
	If lTpDesl
		Aadd(aHeader_Aux,{ OemToAnsi(STR0230), "RE_DESL" 					,"@!",   2, 0,"Ch_Desl('1')","€€€€€€€€€€€€€€ ","C", "",	"A", "", "", "", "R", "", "", .F.}) //"Tipo Desligamento"
	EndIf

	nUsado:= 6

	While !SX3->(EOF()) .And. (SX3->X3_ARQUIVO == "SRA")

		IF ( x3uso(X3_USADO) .And. cNivel >= X3_NIVEL .And. Alltrim(SX3->X3_TIPO) <> "M" ) .Or. ( X3_CAMPO == "RA_CODUNIC" ) //tratamento para nao levar campos do tipo Memo
		NUsado++
		AADD(ACAMPOS, X3_CAMPO + STRZERO(NUSADO,6)  )

		cTitulo     := Trim(X3Titulo())
		cBox        := X3Cbox()

		cVisual		:= X3_VISUAL
		cValid  	:= alltrim( X3_VALID )
		cF3			:= X3_F3
		cPicture	:= X3_PICTURE
		cWhen		:= X3_WHEN

		Aadd(aHeader_Aux,{ cTitulo , X3_CAMPO,cPicture,X3_TAMANHO,;
							X3_DECIMAL, cValid, X3_USADO, X3_TIPO,cF3 , ;
							X3_CONTEXT, cBox ,X3_RELACAO, cWhen, cVisual,;
							X3_VLDUSER,"", .F.  })

		Endif
		cTitulo := ""
		cBox	:= ""
		cVisual	:= ""
		cValid  := ""
		cWhen 	:= ""
		cF3		:= ""
		cPicture:= ""

		SX3->(dbSkip())
	EndDo

	If _RETTIT > 0
		Aadd(aHeader_Aux,{STR0286,"QB_RETTIT","",1, 0, "", "€€€€€€€€€€€€€€ ", "C", "", "R", "1=Sim;2=Nao","" ,"", "", "","", .F. })	// "Retirar Tit"
		Aadd(aHeader_Aux,{STR0287,"QB_SUBTIT","",1, 0, "VldSubTit()", "€€€€€€€€€€€€€€ ", "C", "", "R", "1=Sim;2=Nao","" ,"", "", "","", .F. })	// "Atribui Tit"

		Aadd(aHeader_Aux,{RetTitle("QB_FILTIT"),"QB_FILTIT","",Len(SQB->QB_FILTIT), 0, "", "€€€€€€€€€€€€€€ ", "C", "", "V", "","" ,"", "", "","", .F. })
		Aadd(aHeader_Aux,{RetTitle("QB_MATTIT"),"QB_MATTIT","",Len(SQB->QB_MATTIT), 0, "", "€€€€€€€€€€€€€€ ", "C", "", "V", "","" ,"", "", "","", .F. })
		Aadd(aHeader_Aux,{STR0288,"QB_NOMTIT","",Len(SRA->RA_NOME), 0, "", "€€€€€€€€€€€€€€ ", "C", "", "V", "","" ,"", "", "","", .F. })		// "Titular Atual"
	EndIf

	Aadd(aHeader_Aux,{"Alias WT" ,"RA_ALI_WT","",3, 0, "", "€€€€€€€€€€€€€€ ", "C", "", "V", "","" ,"", "", "","", .F. })
	Aadd(aHeader_Aux,{"Recno WT" ,"RA_REC_WT","",10, 0, "","€€€€€€€€€€€€€€ " , "N", "", "V", "" ,"", "", "","","", .F. })

	RestArea(aArea)
Return( aHeader_Aux )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³fAllCols     ºAutor  ³Microsiga           º Data ³  03/18/08   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Monta o aHeader com todos os campos do SRA                     º±±
±±º          ³                                                               º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                            º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function fAllCols( )

Local aAreaSRA		:= SRA->(GetArea())
	Local aStru			:= {}
	Local aLogSRK		:= {}
	Local cQuery		:= ""
	Local cDescEmpr		:= ""
	Local cDescFil		:= ""
	Local cAliasSRA		:= "SRA"
	Local nX			:= 0
	Local nCNT			:= 0
	Local nHeader		:= 0
	Local nHeader1		:= 0
	Local nUsado		:= 00
	Local nPos			:= 0
	Local nPosAli		:= 0
	Local nPosAli1		:= 0
	Local cFilSRA		:= xFilial( "SRA" , __cFilAnt )
	Local lPostoEmpty	:= .F.
	Local lFirst		:= .T.
	Local lPortal		:= IsInCallStack( "TCFA040Atende" )
	local cProc			:= ""
	Local cTpRot		:= ""
	Local cRot			:= ""
	Local cSem			:= ""
	Local cPer			:= ""
	Local aPer			:= {}
	Local nAper			:= 0
	Local lAvisoBlq		:= .T.
	Local cVar			:= ""
	Local nPosDepto		:= GdFieldPos("RA_DEPTO", aSRAHeader)
	Local lAutoInitP	:= !IsBlind() .Or. lPortal
	Local lDuplSRK		:= .F.

	dbSelectArea("SX3")
	dbseek("SRA")
	dbSetOrder(2)

	DbSelectArea( "SRA" )
	DbSetOrder( RetOrder( "SRA", "RA_FILIAL + RA_MAT") )

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Monta os Dados para a GetDados							            ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		cAliasSRA := "QSRA"
		aStru := SRA->(dbStruct())

		cQuery := "SELECT "
		For nX := 1 To len(aStru)
			If aStru[nX][2] <> "M" //tratamento para nao levar campos do tipo Memo
					cQuery += aStru[ nX , 1 ] + ", "
			EndIf
		Next nX
		cQuery += "R_E_C_N_O_ RECNO "
		cQuery += "  FROM "+	RetSqlName("SRA")
		cQuery += " WHERE RA_FILIAL='"+cFilSRA+"'"
		cQuery += "   AND RA_OKTRANS='"+cMarkTransf+"'"
		cQuery += "   AND D_E_L_E_T_ = ' ' "
		cQuery += " ORDER BY RA_FILIAL, RA_MAT"

		cQuery := ChangeQuery( cQuery )

		If ! lPortal .And. MsOpenDbf(.T.,"TOPCONN",TcGenQry(, ,cQuery),cAliasSRA,.T.,.T.)
			For nX := 1 To Len(aStru)
				If ( aStru[nX][2] <> "C" )
					TcSetField(cAliasSRA,aStru[nX][1],aStru[nX][2],aStru[nX][3],aStru[nX][4])
				EndIf
			Next nX
		Else
			cAliasSRA := "SRA"
			(cAliasSRA)->(dbSeek(cFilDe+cMatDe,.T. ))
		Endif

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Carrega Informacoes da Empresa Origem                        ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		fInfo(@aInfo,(cAliasSRA)->RA_FILIAL)
		cDescEmpr	:= PadR(aInfo[2],35)
		cDescFil	:= PadR(aInfo[1],35)
		nHeader 	:= Len(aSRAHeader) +1
		aSRACols	:= {}

		While !(cAliasSRA)->(Eof()) .and. (cAliasSRA)->RA_FILIAL == cFilSRA

			// Carrega dados transferencia
			If ! lPortal
				nPos := aScan( __aMrkKeys__ , { |x| x ==  (cAliasSRA)->(RA_FILIAL + RA_MAT)  } )
				If nPos <=0
					(cAliasSRA)->(dbSkip())
					Loop
				Endif
			Else
				If (cAliasSRA)->RA_MAT <> cMatDe
					Exit
				EndIf
			EndIf

				//checa se tem periodo para processo/roteiro na data atual
			cProc 	:= (cAliasSRA)->RA_PROCES
			cRot 	:= If((cAliasSRA)->RA_CATFUNC $ "A/P",cRtAut,cRtFol)
			nAper := 0
			If Len(aPer) > 0
				nAper := Ascan(aPer,{|x| x[1] == cTpRot .AND. x[2]==cProc })
			EndIf
			If nAper >0
				cPer := aPer[nAper][5]
				cSem := aPer[nAper][4]
			Else
				//Carrega o periodo atual de calculo (aberto)
				If !(fGetLastPer( @cPer,@cSem , cProc, cRot ))
					cTpRot := If(cTpRot == "1","9","1") //Procura nos demais roteiros para o caso de ter cadastrado autonomo no processo errado ou vice-versa
					cRot   := If(cTpRot == "1",cRtAut,cRtFol)
					nAper := 0
					If Len(aPer) > 0
						nAper := Ascan(aPer,{|x| x[1] == cTpRot .AND. x[2]==cProc })
					EndIf
					If nAper >0
						cPer := aPer[nAper][5]
						cSem := aPer[nAper][4]
					Else
						fGetLastPer( @cPer,@cSem , cProc, cRot )
					EndIf
				EndIf
				If nAper == 0
					aadd(aPer,{cTpRot,cProc,cRot,cSem,cPer})
					// ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					// ³Verifica se o calculo esta liberado      ³
					// ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If !fVldAccess( (cAliasSRA)->RA_FILIAL, dDataTra, cSem, lAvisoBlq, cRot,"1" )
						Break
					EndIf
				EndIf
			EndIf
			//dDataTra := Ctod("01/"+Substr(cPer,5,2)+"/"+Substr(cPer,1,4) , "DDMMYY" )
			cMatDe := (cAliasSRA)->RA_MAT
			If !Ch_Dat(dDataTra,.F.,@aLogTransf,cPer,cProc)
				(cAliasSRA)->(dbSkip())
				Loop
			EndIf

			// Verifica Lançamentos Futuros com Número de Documento repetido
			lDuplSRK	:= fChkSRK(@aLogSRK,(cAliasSRA)->RA_FILIAL, (cAliasSRA)->RA_MAT)
			If lDuplSRK
				(cAliasSRA)->(dbSkip())
				Loop
			EndIf

			nCnt++
			nUsado 		:= 0
			lPostoEmpty := .F.
			aaDD( aSRACols, Array(nHeader) )
			For nX:= 1 To len(aSRAHeader)

				If alltrim(aSRAHeader[nX,2]) = "COLBMP"
					nUsado ++
					aSRACols[nCnt,nUsado]	:= "BR_BRANCO"
				ElseIf alltrim(aSRAHeader[nX,2])= "M_EMPRESA"
					nUsado++
					aSRACols[nCnt,nUsado]	:= cEmpAnt
				ElseIf alltrim(aSRAHeader[nX,2])= "M_NEMPRESA"
					nUsado++
					aSRACols[nCnt,nUsado]	:= cDescEmpr
				ElseIf alltrim(aSRAHeader[nX,2]) = "RA_FILIAL"
					nUsado++
					aSRACols[nCnt,nUsado]	:= cFilAnt
				ElseIf alltrim(aSRAHeader[nX,2]) = "M_NFILIAL"
					nUsado++
					aSRACols[nCnt,nUsado]	:= cDescFil
				ElseIf alltrim(aSRAHeader[nX,2]) = "M_DPROCES"
					nUsado++
					aSRACols[nCnt,nUsado]	:= fdesc("RCJ",(cAliasSRA)->RA_PROCES, 'RCJ_DESCRI' )
				ElseIf alltrim(aSRAHeader[nX,2]) = "M_DPOSTO"
					nUsado++
					aSRACols[nCnt,nUsado]	:= fdesc("SQ3",(cAliasSRA)->RA_CARGO , 'Q3_DESCSUM' )
				ElseIf alltrim(aSRAHeader[nX,2]) = "RE_DESL"
					nUsado++
					aSRACols[nCnt,nUsado]	:= ""
				ElseIf alltrim(aSRAHeader[nX,2]) == "QB_FILTIT" .Or. alltrim(aSRAHeader[nX,2]) == "QB_MATTIT"
					nUsado++
					cVar := SQB->QB_FILTIT
					If alltrim(aSRAHeader[nX,2]) = "QB_MATTIT"
						cVar := SQB->QB_MATTIT
					EndIf
					aSRACols[nCnt,nUsado]	:= cVar
				ElseIf alltrim(aSRAHeader[nX,2]) == "QB_NOMTIT"
					nUsado++
					aSRACols[nCNT,nUsado] := Posicione('SRA',1,SQB->(QB_FILTIT+QB_MATTIT),'RA_NOME')
				ElseIf alltrim(aSRAHeader[nX,2]) == "QB_RETTIT" .Or. alltrim(aSRAHeader[nX,2]) == "QB_SUBTIT"
					If SQB->QB_DEPTO <> aSRACols[nCNT,nPosDepto]
						SQB->(DbSetOrder(1))
						SQB->(DbSeek(xFilial() + aSRACols[nCNT,nPosDepto]))
					EndIf

					nUsado++
					aSRACols[nCNT,nUsado] := "2"

				Else
					SX3->( dbSetOrder(2) )
					If SX3->(DbSeek(aSRAHeader[nX,2]) )
						If SX3->x3_context == "V"
							nUsado++
							If alltrim(aSRAHeader[nX,2])== "RA_DESCCC"
								aSRACols[nCnt][nUsado] := DescCc( (cAliasSRA)->RA_CC  , cFilSRA  , NIL )
							ElseIf alltrim(aSRAHeader[nX,2]) == "RA_DDEPTO"
								aSRACols[nCnt][nUsado] := fDesc("SQB",(cAliasSRA)->RA_DEPTO, "QB_DESCRIC")
							ElseIf alltrim(aSRAHeader[nX,2]) == "RA_DCARGO"
								aSRACols[nCnt][nUsado] := fDesc("SQ3",(cAliasSRA)->RA_CARGO, "Q3_DESCSUM")
							Else
								aSRACols[nCnt][nUsado] := CriaVar(AllTrim(SX3->x3_campo), lAutoInitP )
							Endif
						ElseIf cNivel >= SX3->x3_nivel
							nUsado++
							aSRACols[nCnt][nUsado] := &(cAliasSRA+"->"+SX3->X3_CAMPO)
						EndiF
					Endif
					If cOrgCfg == "1" .and. alltrim(aSRAHeader[nX,2]) = "RA_POSTO"
						lPostoEmpty	:= Empty(aSRACols[nCnt][nUsado])
					Endif
				Endif
			Next nX

			nPosAli	:=	GdfieldPos("RA_ALI_WT",aSRAheader)
			nPosRec	:=  GdfieldPos("RA_REC_WT",aSRAheader)
			If nPosAli > 0
				nUsado ++
				aSRACols[nCnt,nPosAli] := "SRA"
			EndIf
			If nPosRec > 0
				nUsado ++
				If cAliasSRA == "SRA"
					aSRACols[nCnt,nPosRec] := (cAliasSRA)->(Recno())
				Else
					aSRACols[nCnt,nPosRec] := (cAliasSRA)->RECNO
				EndIf
			EndIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Se utiliza controle de postos, o campo deve estar preenchido ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If lPostoEmpty
				lNaoTemPosto 				:= .T.
				aSRACols[nCnt][nUsado+1] 	:= .F.
				If lFirst
					lFirst:= .F.
					aAdd( aLogTransf , "" )
					aAdd( aLogTransf , OemToAnsi(STR0141) )    		// "Funcionarios sem informacao de ocupacao de Posto "
				Endif
				aAdd( aLogTransf , __cSvEmpAnt + " " + aSRACols[nCnt][_FILIAL] + " " +aSRACols[nCnt][_MATRIC] +"-" + aSRACols[nCnt][_NOME] )
			Else
				aSRACols[nCnt][nUsado+1] 	:= .F.
			Endif

			If !Empty((cAliasSRA)->RA_DEMISSA)
				lFuncTransf := .T.
			Endif


			(cAliasSRA)->(DbSkip())
			If lPortal
				Exit
			EndIf
		Enddo

		If Len(aLogSRK) > 0
			// "As seguintes matrículas possuem Valores Futuros com mesmo Número de Documento para o mesmo lançamento de:"
			// "Filial + Matrícula + Verba + Centro de Custo + Número de Documento"
			// "Revisitar o cadastro e preencher o Número de Documento corretamente."
			aAdd( aLogTransf , OemToAnsi(STR0366))
			aAdd( aLogTransf , OemToAnsi(STR0367))
			aAdd( aLogTransf , {} )
			aAdd( aLogTransf , OemToAnsi(STR0368))
			aAdd( aLogTransf , {} )
			For nX := 1 To Len(aLogSRK)
				aAdd( aLogTransf , RTrim(aLogSRK[nX]) )
				aAdd( aLogTransf , {} )
			Next nX
		EndIf

		If !Empty(aLogTransf	)
			aAdd( aLogTransf , "" )
			aAdd( aLogTransf , Repl('-',80) )
			aAdd( aLogTransf , "" )
		Endif

	If ! lPortal
		(cAliasSRA)->( dbCloseArea() )
	EndIf
	RestArea(aAreaSRA)
Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFuncao    ³PcoVldBLq º Autor ³Bruno Sobieski Chavez  º Data ³30/06/2006º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Valida todos os registros marcadosse.                      º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function PcoVldBlq( )
	Local lRet 	:= .T.

	SRA->(DbSeek(xFilial()))
	While lRet .And. !SRA->(Eof()) .And. xFilial('SRA') == SRA->RA_FILIAL

		If SRA->( IsMark( "RA_OKTRANS" , cMarkTransf ) )
			lRet	:=	PcoVldLan('000086','01')
			If lRet
				lRet	:=	PcoVldLan('000086','02')
			Endif
		Endif
	   DbSkip()
	Enddo

Return lRet

/*
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³ MenuDef		³Autor³  Luiz Gustavo     ³ Data ³04/01/2007³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Isola opcoes de menu para que as opcoes da rotina possam    ³
³          ³ser lidas pelas bibliotecas Framework da Versao 9.12 .      ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³< Vide Parametros Formais >									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Uso      ³GPEA180                                                     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Retorno  ³aRotina														³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³< Vide Parametros Formais >									³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
Static Function MenuDef()
	/*ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ*\
	³ Define Array contendo as Rotinas a executar do programa      ³
	³ ----------- Elementos contidos por dimensao ------------     ³
	³ 1. Nome a aparecer no cabecalho                              ³
	³ 2. Nome da Rotina associada                                  ³
	³ 3. Usado pela rotina                                         ³
	³ 4. Tipo de Transa‡„o a ser efetuada                          ³
	³    1 - Pesquisa e Posiciona em um Banco de Dados             ³
	³    2 - Simplesmente Mostra os Campos                         ³
	³    3 - Inclui registros no Bancos de Dados                   ³
	³    4 - Altera o registro corrente                            ³
	³    5 - Remove o registro corrente do Banco de Dados          ³
	\*ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ*/
	Local aRotina	 := {}
	Local lDivergTAF := IIf(FwIsInCallStack("GPEA180") .And. FindFunction("fDivergTaf"),fDivergTaf(),.T.)

	AAdd(aRotina, { STR0004	,"PesqBrw"		, 0 , 1 , ,.F.})		   //"Pesquisar"
	AAdd(aRotina, { STR0005	,"Gpea180Vis"	, 0 , 2 })	 	      //"Visualizar"

	If GetMv( "MV_GSPUBL",, "1" ) == "2"  .and. !lGestPubl // Gestao Publica 1=Nao; 2=Sim  (modelo antigo, não aplicado ao SIGAGFP Gestão de Folha Publica)
		AAdd(aRotina, { STR0201	,"Gpea180Vis"		, 0 , 4 })	   //"Manutencao"
	EndIf

	//--> Retirada a opcao de exclusao. Futuramente sera analisada viabilidade de melhoria para um novo processo
	//    de exclusao para controle de integridade da SRE e periodos fechados
	//	AAdd(aRotina, { STR0007	,"Gpea180Vis"		, 0 , 5 }) 	 		//"Excluir"

	AAdd(aRotina, { STR0006	,"Gpea180Lot"		, 0 , 6,})			//"Transferir"
	AAdd(aRotina, { STR0099	,"GpeConfCTrans"	, 0 , 7 })			//"Config.Cpos Transf."
	AAdd(aRotina, { STR0021	, "GpLegend"		, 0 , 6 , ,.F.}) 	//"Legenda"
	If (lIntTAF .Or. lMiddleware) .And. !lDivergTAF
		AAdd(aRotina, { IIf(!lMiddleware, STR0239, STR0295)	,"Gpea180TAF", 0 , 6,})			//"Integrar com o TAF"#"Integrar com o Middleware"
		AAdd(aRotina, { STR0271, "fTransfExt", 0, 6,})			//Transferência Externa"
	Endif

Return aRotina

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³ConsItem  ºAutor  ³Reginaldo G.R       º Data ³  26/01/10   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³                                                            º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function ConsItem()

	Local aArea		 := GetArea()
	Local aTransf	    := {}
	Local cFilAux	    := ""
	Local cEmp_Aux 	 	:= ""
	Local cFil_aux	 	:= ""
	Local lConsItemOk 	:= .T.
	Local lTransfUni  	:= IsInCallStack( "fTransfUnico" )
	Local cItmClvl	 	:= SuperGetMv( "MV_ITMCLVL", .F., "2" )

	If !lTransfUni
		cEmpAte	:= oGetSRA2:aCols[oGetSRA2:nAt, _EMPRES ]
		cFilAte	:= oGetSRA2:aCols[oGetSRA2:nAt, _FILIAL ]
	Else
		cEmpAte	:= oGetTran:aCols[1,1]
		cFilAte	:= oGetTran:aCols[1,3]
		cEmp_Aux 	:= cEmpAte
		cFil_aux	:= cFilAte
	Endif

	lEmpDif	:= ( __cSvEmpAnt # cEmpAte )
	cItem 		:= &(ReadVar())

	Begin Sequence
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Item Contabil nao Pode Estar Vazio                         ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If cItmclvl == "3" .And. !Empty( cItem )
			IF !( lConsItemOk := CtbMovSaldo("CTD") )
				Help(" ",1,"A180ITEMNEX")
				Break
			EndIF
		ElseIF cItmClvl <> "3"
			IF !( lConsItemOk := (!Empty( cItem ) .And. CtbMovSaldo("CTD")))
				Help(" ",1,"A180ITEMNEX")
				Break
			EndIF
		Endif
		If	!(lConsItOk:= CTB105Item(cItem))
			Break
		Endif

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Verifica se no arquivo CTD Existe o Item Contabil          ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		IF ( lEmpDif )  .OR. lTransfUni
			IF !( lConsItemOk := fAbrEmpresa( "CTD" , 1 ) )
				Break
			EndIF
		Else
			dbSelectArea( "CTD" )
			__cFil := cFilAux := xFilial( "CTD" , cFilAte )
		EndIF

	If cItmClvl <> "3" .Or. (cItmclvl == "3" .And. !Empty( cItem ))
			If !( lConsItemOk := ( If(lEmpDif,"GPE","")+"CTD" )->( dbSeek( __cFil + cItem , .F. ) ) )
				Help(" ",1,"A18ITEMNEX")			//--  Item Contabil não cadastrado.
				Break
			EndIF
		EndIf

		If !lTransfUni
			IF oGetSRA2:aCols[oGetSRA2:nAt , _CITEM]<> cItem
				oGetSRA2:aCols[oGetSRA2:nAt , _COLBMP] 	:= "BR_AZUL"
			Endif
			If !IsBlind()
				oGetSRA2:Refresh()
				oGetSRA1:Refresh()
			EndIf
		Else
			If !IsBlind()
				oGetTran:Refresh()
			EndIf
			cEmpAte 	:= cEmp_Aux
			cFilAte 	:= cFil_Aux
		Endif
		lItemDif := .T.
	End Sequence

	IF ( lEmpDif )
		fFecEmpresa( "CTD" )
	EndIF

	dbSelectArea( "CTD" )

	RestArea( aArea )

Return( lConsItemOk )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³ConsClvl  ºAutor  ³Reginaldo G.R       º Data ³  26/01/10   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³                                                            º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function ConsClvl()

Local aArea		 	:= GetArea()
Local aTransf	    := {}
Local cFilAux	    := ""
Local cEmp_Aux 	 	:= ""
Local cFil_aux	 	:= ""
Local lConsClvlOk 	:= .T.
Local lTransfUni  	:= IsInCallStack( "fTransfUnico" )
Local cItmClvl	 	:= SuperGetMv( "MV_ITMCLVL", .F., "2" )

If !lTransfUni
	cEmpAte	:= oGetSRA2:aCols[oGetSRA2:nAt, _EMPRES ]
	cFilAte	:= oGetSRA2:aCols[oGetSRA2:nAt, _FILIAL ]
Else
	cEmpAte	:= oGetTran:aCols[1,1]
	cFilAte	:= oGetTran:aCols[1,3]
	cEmp_Aux 	:= cEmpAte
	cFil_aux	:= cFilAte
Endif

lEmpDif	:= ( __cSvEmpAnt # cEmpAte )
cClvl 		:= &(ReadVar())

Begin Sequence
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Classe de Valor nao Pode Estar Vazio                       ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If cItmclvl == "3" .And. !Empty( cClvl )
		IF !( lConsClOk := CtbMovSaldo("CTH") )
 			Help(" ",1,"A180CLVLNEX")
			Break
		Endif
	ElseIf cItmclvl <> "3"
	 	IF !( lConsClOk := ( !Empty( cClvl ) .and. CtbMovSaldo("CTH") ) )
			Help(" ",1,"A180CLVLNEX")
			Break
		Endif
	EndIF
 	If !( lConsClOk := CTB105Clvl(cClasse))
		Break
	Endif

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica se no arquivo CTH Existe a Classe de Valor        ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	IF ( lEmpDif )  .OR. lTransfUni
		IF !( lConsClvlOk := fAbrEmpresa( "CTH" , 1 ) )
			Break
		EndIF
	Else
		dbSelectArea( "CTH" )
		__cFil := cFilAux := xFilial( "CTH" , cFilAte )
	EndIF

	CTH->( dbSetOrder(1) )
	If cItmClvl <> "3" .Or. (cItmclvl == "3" .And. !Empty( cClvl ))
	    If !( lConsClvlOk := ( If(lEmpDif,"GPE","")+"CTH" )->( dbSeek( __cFil + cClvl , .F. ) ) )
		     Help(" ",1,"A180CLVLNEX")			//--  Classe de Valor não cadastrado.
		     Break
	    EndIF
   EndIf

	If !lTransfUni
		IF oGetSRA2:aCols[oGetSRA2:nAt , _CCLVL]<> cClvl
			oGetSRA2:aCols[oGetSRA2:nAt , _COLBMP] 	:= "BR_AZUL"
		Endif
		If !IsBlind()
			oGetSRA2:Refresh()
			oGetSRA1:Refresh()
		EndIf
	Else
		If !IsBlind()
			oGetTran:Refresh()
		EndIf
		cEmpAte 	:= cEmp_Aux
		cFilAte 	:= cFil_Aux
	Endif
	lClvlDif := .T.
End Sequence

IF ( lEmpDif )
	fFecEmpresa( "CTH" )
EndIF

dbSelectArea( "CTH" )
RestArea( aArea )
Return( lConsClvlOk )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³RHTamFilialºAutor  ³Mauricio T.         º Data ³  03/03/10  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Retorna a Filial do tamanho do layout da filial a ser trata º±±
±±º          ³da.                                                         º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function RHTamFilial(cFilCnv, cEmp)
Local cNewFil
Local nTamFil

DEFAULT cFilCnv := ""
DEFAULT cEmp	   := cEmpAnt

cNewFil := cFilCnv + Space(12)
nTamFil := FwSizeFilial(cEmp)
cNewFil := Substr(cNewFil, 1, nTamFil )

Return( cNewFil )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³GP180DelOk ºAutor  ³RH IP Inovacao      º Data ³  05/04/12  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Excluir a linha de Dados Transferencia                      º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ GPEA180                                                    º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function GP180DelOk()
Local lDel	:= If(oGetSRA2:aCols[oGetSRA2:oBrowse:nAt,Len(oGetSRA2:aHeader)+1], .F. , .T. )

oGetSRA21:aCols[oGetSRA2:oBrowse:nAt,Len(oGetSRA21:aHeader) + 1 ] := lDel
If( IsBlind(),, oGetSRA21:Refresh() )
Return .T.
/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³GP1801DelOkºAutor  ³RH IP Inovacao      º Data ³  05/04/12  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Retorna mensagem sobre Exclusao da linha de Dados Cadastraisº±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ GPEA180                                                    º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function GP1801DelOk()

MsgAlert( OemToAnsi(STR0172), OemToAnsi(STR0047) ) 				// "Exclusão permitida apenas na pasta Dados Transferência" ### "Atencao"

Return .F.

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFuncao    ³Gpea180ID   ºAutor³Andreia dos Santos v.I ºData³ 08/29/2003 º±±
±±º          ³            º     ³Marinaldo de Jesus v.IIºData³ 18/02/2004 º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Marca/Desmarca todos os elementos do browse                 º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function Gpea180ID()
Local aArea			:= GetArea()
Local cAliasQry		:= GetNextAlias()
Local cAliasSRA		:= GetNextAlias()
Local cWhere		:= ""
Local cTrfID		:= ""
Local cPesq 		:= Space(20)
Local nOpt			:= 0
Local oDlg5
Local oUso
Local bSeek			:= { || fPesquisa( oUso, oUso:nAT, cPesq ) }
Local aAdvSize		:= {}
Local aInfoAdvSize	:= {}
Local aObjSize		:= {}
Local aObjCoords	:= {}
Local aLstLote		:= {}
Local lTemItREP		:= SRE->( FieldPos( "RE_ITEMP" ) # 0 )
Local lTemClREP		:= SRE->( FieldPos( "RE_CLVLP" ) # 0 )

cWhere := "% SRE.D_E_L_E_T_ = ' ' AND SRE.RE_TRFUNID <> 0 %""

BeginSql alias cAliasQry
   	SELECT SRE.RE_TRFUNID, SRE.RE_TRFOBS
	FROM %table:SRE% SRE
	WHERE %exp:cWhere%
	GROUP BY RE_TRFUNID, RE_TRFOBS
	ORDER BY RE_TRFUNID, RE_TRFOBS
EndSql

If (cAliasQry)->( !Eof() )
	While (cAliasQry)->( !Eof() )
		aAdd(aLstLote, { (cAliasQry)->RE_TRFUNID, (cAliasQry)->RE_TRFOBS })
		(cAliasQry)->( dbSkip() )
	Enddo
Endif

If Len(aLstLote) > 0

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Define o cabecalho da tela de atualizacoes                  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	oOk := LoadBitmap( GetResources(), "ENABLE" )
	oNo := LoadBitmap( GetResources(), "LBNO" )

	SETAPILHA()

	aAdvSize		:= MsAdvSize(,.T.,390)
	aInfoAdvSize	:= { aAdvSize[1] , aAdvSize[2] , aAdvSize[3] , aAdvSize[4] , 5 , 5 }
	aAdd(aObjCoords, { 000, 000, .T., .T., .T.} )     		//2-Group ListBox
	aObjSize		:= MsObjSize(aInfoAdvSize , aObjCoords)

	If lGestPubl
		DEFINE MSDIALOG oDlg5 FROM aAdvSize[7], 0 TO aAdvSize[6], aAdvSize[5]  TITLE OemToAnsi(STR0258) PIXEL	//"Selecao de Id de Relotações"
	Else
	DEFINE MSDIALOG oDlg5 FROM aAdvSize[7], 0 TO aAdvSize[6], aAdvSize[5]  TITLE OemToAnsi(STR0174) PIXEL	//"Selecao de Id de Transferencias"
	Endif

	oDlg5:lEscClose := .F.

	@ aObjSize[1,1],aObjSize[1,2] LISTBOX oUso ;
			FIELDS HEADER STR0175,STR0176;  // "ID Transf." ### "Observação"
			SIZE aObjSize[1,3],aObjSize[1,4] ;
			OF oDlg5 PIXEL  CENTERED
			oUso:SetArray(aLstLote)
			oUso:bLine := { || {aLstLote[oUso:nAt,1],aLstLote[oUso:nAt,2]}}
			oUso:Refresh()

	ACTIVATE MSDIALOG oDlg5 ON INIT EnchoiceBar(oDlg5,{||nOpt:=1 , cTrfID := A180TrfID(oUso,aLstLote), oDlg5:End() },;
													 {|| oDlg5:End() } ) ;
													 CENTERED
	SETAPILHA()

	If nOpt == 1
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Marca todos os funcionarios do ID selecionado                           ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		cWhere := "% SRE.D_E_L_E_T_ = ' '"
		cWhere += " AND SRE.RE_TRFUNID = " + cTrfID
		cWhere += " AND SRE.RE_EMPP = '" + cEmpAnt + "'"
		cWhere += " AND SRA.RA_FILIAL = SRE.RE_FILIALP"
		cWhere += " AND SRA.RA_MAT = SRE.RE_MATP"
		cWhere += " AND SRA.RA_CC = SRE.RE_CCP"
		cWhere += " AND SRA.RA_POSTO = SRE.RE_POSTOP"
		cWhere += " AND SRA.RA_PROCES = SRE.RE_PROCESP"

		If lItemClVl
			If lTemItREP .And. lTemClREP
				cWhere += " AND SRA.RA_ITEM = SRE.RE_ITEMP"
				cWhere += " AND SRA.RA_CLVL = SRE.RE_CLVLP"
			EndIf
		EndIf

		cWhere += " %"

		BeginSql alias cAliasSRA
		   	SELECT SRA.R_E_C_N_O_ AS RECNOSRA
			FROM %table:SRE% SRE, %table:SRA% SRA
			WHERE %exp:cWhere%
			ORDER BY RE_TRFUNID,RE_FILIALP,RE_MATP
		EndSql

		If (cAliasSRA)->( !Eof() )
			While (cAliasSRA)->( !Eof() )
				SRA->(dbGoTo( (cAliasSRA)->( RECNOSRA ) ))
				Gpea180Mrk( "SRA" , .T. , .T. , SRA->( !IsMark( "RA_OKTRANS" , cMarkTransf ) ) )
				(cAliasSRA)->( dbSkip() )
			Enddo
		Endif

		dbSelectArea(cAliasSRA)
		dbCloseArea()

	Endif
Else

	MsgAlert( OemToAnsi(STR0184),OemToAnsi(STR0047) )  // "Não existe ID de transferência para ser selecionado" ### "Atencao"

Endif

dbSelectArea(cAliasQry)
dbCloseArea()
RestArea(aArea)
Return .T.

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFuncao    ³A180TrfID   ºAutor³IP RH Inovacao         ºData³ 21/05/2012 º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Retorna o codigo do lote de transferencia                   º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ GPEA180                                                    º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static function A180TrfID(oUso,aLstLote)
Local cTrfID := AllTrim(Str(aLstLote[oUso:nAt,1]))
Return cTrfID

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³fLogPreview   ºAutor  ³Microsiga           º Data ³  22/05/12   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Monta um log de previsao dos de/paras                           º±±
±±º          ³                                                                º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ GPEA180                                                        º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function fLogPreview()
Local cArquivo	:= FunName()+__cUserID+".##r"
Local bMakeLog 	:= { || fMakeLog( { aLogTransf } ,  { STR0073 } , NIL , .T. , cArquivo , NIL , "G" , "L" , NIL , NIL ) }
Local nX			:= 0
Local nLinha		:= 0
Local nColuna		:= 0
Local nHeader		:= Len(oGetSRA1:aHeader)
Local nAcols		:= Len(oGetSRA1:aCols)
Local nHeader1		:= Len(oGetSRA11:aHeader)
Local aLogTransf	:= {}
Local nPosMat 		:= Ascan(oGetSRA1:aHeader, {|x| "RA_MAT" == alltrim(x[2]) } )
Local nPosNome 		:= Ascan(oGetSRA1:aHeader, {|x| "RA_NOME" == alltrim(x[2]) } )

For nLinha := 1 to nAcols

	If oGetSRA1:aCols[nLinha , _COLBMP]	== "BR_VERDE" .OR. oGetSRA2:aCols[nLinha , _COLBMP] == "BR_AZUL"
		aAdd(aLogTransf," ")
		aAdd(aLogTransf,STR0179 + " " + oGetSRA1:aCols[ nLinha ][nPosMat]+ "-" + oGetSRA1:aCols[ nLinha ][nPosNome])	// "Funcionario:"
		aAdd(aLogTransf," ")

		// Dados Transferencia
		For nColuna := 1 to nHeader
			If oGetSRA1:aCols[ nLinha ][nColuna] <> oGetSRA2:aCols[ nLinha ][nColuna] .And. nColuna <> _COLBMP
				aAdd(aLogTransf,Padr(oGetSRA1:aHeader[nColuna,1],12)+ " "+STR0180+" " + Padr(AllTrim(oGetSRA1:aCols[ nLinha ][nColuna]),50)+" "+STR0181+" " + Padr(AllTrim(oGetSRA2:aCols[ nLinha ][nColuna]),50))	// "De:" ### "Para:"
			Endif
		Next

		// Dados de Cadastro
		For nColuna := 3 to nHeader1
			If oGetSRA11:aCols[ nLinha ][nColuna] <> oGetSRA21:aCols[ nLinha ][nColuna] .And. nColuna <> _COLBMP
				aAdd(aLogTransf,Padr(oGetSRA11:aHeader[nColuna,1],12)+ " "+STR0180+" " + Padr(AllTrim(oGetSRA11:aCols[ nLinha ][nColuna]),50)+" "+STR0181+" "+ Padr(AllTrim(oGetSRA21:aCols[ nLinha ][nColuna]),50))	// "De:" ### "Para:"
			Endif
		Next

	Endif
Next

If Len(aLogTransf) > 0
	MsAguarde( bMakeLog , OemToAnsi( STR0073 ) )
Else
	MsgAlert( OemToAnsi(STR0182),OemToAnsi(STR0047) ) 	// "Não existem transferências a serem efetuadas!" ### "Atencao"
Endif

FErase( __RelDir + cArquivo )

Return(.T.)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFuncao    ³Gpe180MatAutoºAutor  ³Marcelo Silveira    ºData³ 03/06/2013 º±±
±±º          ³             º       ³                    º    ³            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Tratamento especifico do controle automatico de Matricula  º±±
±±º          ³ Parametro MV_MATRICU                                       º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function Gpe180MatAuto()

LOCAL   oDlg
LOCAL   oRadio
LOCAL   aRadio   := { OemToAnsi(STR0186), OemToAnsi(STR0187) } //Sim#Nao
LOCAL   nRadio   := 2 //Valor padrao 2 (Nao havera transferencia de matricula)

If(!lRobo)

DEFINE MSDIALOG oDlg FROM 0,0 TO 110,320 PIXEL TITLE OemToAnsi(STR0034) //"Transferência de Matricula"

   @ 001,003 TO 050,110 LABEL "" OF oDlg PIXEL

   @ 008,008 SAY OemToAnsi(STR0185)  SIZE 090,009 PIXEL OF oDlg //"Haverá transferência de Matricula?"
   @ 020,008 RADIO oRadio VAR nRadio ITEMS aRadio[1],aRadio[2] SIZE 060,009 ;

   DEFINE SBUTTON FROM 020,120 TYPE 1 OF oDlg ENABLE ONSTOP OemToAnsi(STR0001) ACTION oDlg:End() //"Confirma"

ACTIVATE MSDIALOG oDlg CENTER

EndIf

Return( nRadio==1 )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³Gpea180F3 ºAutor  ³Gustavo M.          º Data ³  11/04/13   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Exibe a descricao do centro de custo.                      º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function Gpea180F3()

Local lMudaEmp	:=	.F.
Local nPosEmpOri	:=	GdFieldPos("RE_EMPD")
Local nPosEmpDes	:=	GdFieldPos("RE_EMPP")
Local nPosFilDes	:=  GdFieldPos("RE_FILIALP")
Local cAlias   	:=	"CTT"
Local cFilBkp 	:= cFilAnt
Local aArea		:=	( cAlias )->( GetArea() )

lMudaEmp	:=	( aCols[ n , nPosEmpDes ] <> aCols[n , nPosEmpOri ] )
If ( lMudaEmp )
	EmpChangeTable( cAlias, aCols[ n , nPosEmpDes ],  aCols[n , nPosEmpOri ] , 1)
	cFilAnt:= aCols[ n , nPosFilDes ]
EndIf

ConPad1(,,,"CTT")

If ( lMudaEmp )
	EmpChangeTable( cAlias, aCols[ n , nPosEmpOri ] , aCols[n , nPosEmpDes ] , 1)
EndIf

cFilAnt 		:= cFilBkp

( cAlias )->( RestArea(aArea) )

Return .T.

	/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³QrySRETra ³ Autor ³ Totvs	    ³ Data ³ 23/07/2013           ³±±
±±ÌÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descricao ³ Retornar quais os Funcionarios transferidos na SRE         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³                                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function QrySRETra(aFunc)
Local cQuery  := ""

If !Empty(aFunc)
	cQuery := " SELECT * "
	cQuery += " FROM "
	cQuery += + RetSqlName("SRE") +  " SRE "
	cQuery += " WHERE "
	cQuery += " SRE.RE_FILIAL = '"+FwxFilial("SRE")+ "' AND "
	cQuery += " SRE.RE_DATA = '"+DTOS(dDataTra)+ "' AND "
	cQuery += " SRE.RE_MATD BETWEEN '"+aFunc[1][4]+ "' AND  '"+aFunc[Len(aFunc)][4]+ "' AND"
	cQuery += " SRE.D_E_L_E_T_ = ' ' "
	cQuery = ChangeQuery(cQuery)
	DbUseArea(.T.,'TOPCONN',TCGENQRY(,,cQuery),'TRBSRE',.T.,.T.)
EndIf
Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³fGeraSeq  ºAutor  ³Mauricio MR		 º Data ³  02/12/10   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Gera conteudo do campo RC_SEQ para transferencia de lanca- º±±
±±º          ³ mentos.                                                    º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ GPEA180                                                    º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function fGeraSeq( aCols, nTamSeq )

Local aAux		:= {}
Local cStrCopy	:= ""
Local lRet		:= .T.
Local nX			:= 0.00
Local nY			:= 0.00
Local nSeq		:= 0.00
Local nPosOrd		:= 0.00
Local nPosSqOrig	:= 8
Local nPosCCAte	:= 7
Local nPosSq		:= 6
Local nPosSe		:= 5
Local nPosCc		:= 4
Local nPosPd		:= 3
Local nPosMat		:= 2
Local nPosFil		:= 1
Local nLenCols	:= Len( aCols )
Local lFound		:= .F.

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Renumera Sequencia de Lancamentos                             ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
For nX := 1 To nLenCols
    //--Se o CC do SRC == CC do SRA == CC do Destino deve regerar a sequencia caso contrario
    //-- manter a sequencia original.
    IF 	! ( ( aCols[nX,nPosCc ] ==	 cCCDe ) .and. ( cCCDe <> aCols[nX,7,1,nPosCcAte ] ) )
        Loop
    EndIF
    //-- Obtem uma chave que devera ter o CCusto Alterado
	cStrCopy := aCols[nX,nPosFil] + aCols[nX,nPosMat] + aCols[nX,nPosPd] + ;
				aCols[nX,7,1,nPosCcAte ]  + aCols[nX,nPosSe]

   lFound := .F.

    //-- Busca com a nova troca de CCusto
	nPos := Ascan(aCols,{|x|x[1]+x[2]+x[3]+x[4]+x[5] == cStrCopy })
	IF !Empty(nPos)
       nSeq	:= aCols[nPos, nPosSq]
       //-- Se jah possui 1 elemento
       IF  ( Len(aCols[nPos,7]) == 1  )
           //-- Se o valor original for branco, altera para 1 unidade
           IF ( aCols[nPos,7,1,nPosSq] ==  Space(nTamSeq ) )
                aCols[nPos,7,1,nPosSq]:=   StrZero( 1 , nTamSeq )
 	       Endif
       Endif
       lFound	:= .T.
	Else
	   	//-- Gera nova chave com CC Destino
    	Aadd(aCols,{ aCols[nX,nPosFil], aCols[nX,nPosMat], aCols[nX,nPosPd], aCols[nX,7,1,nPosCcAte ],;
    	             aCols[nX,nPosSe],0,{}, aCols[nX, nPosSq] })
	    nSeq:= 0
	    nPos:= Len(aCols)
	Endif

    //-- Corre todos os registros dessa chave e altera a sequencia
    For nY:=1 To Len(aCols[nX,7])
   		 nSeq++
   		 //-- Inicialiaza '1' se possui mais de 1 elemento ou deixa com o valor original
   		 IF lFound .or. ( Len(aCols[nX,7]) > 1 )
   		 	aCols[nX,7, nY,nPosSq]	:= StrZero( nSeq , nTamSeq )
   		 Endif

   		 aCols[nPos, nPosSq] 	:=	nSeq
    Next nY

Next nX

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Atualiza a Sequencia de Lancamentos                           ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
aAux:= {}
For nX := 1 To Len( aCols )
	//Se a chave possuir lancamentos remonta o array de entrada
	IF !Empty(aCols[nX,7])
        //Move os lancamentos para o array de entrada
		Aeval(aCols[nX,7], {|x| Aadd(aAux, x) } )
	Endif
Next nX

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Reordena pela Sequencia gerada			                       ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
aSort( aAux ,,, { |x,y| 	x[ nPosFil ]+ x[ nPosMat ]+ x[ nPosPd ] + x[ nPosCc ] + x[ nPosSe ] + x[ nPosSq ] < ;
						 	y[ nPosFil ]+ y[ nPosMat ]+ y[ nPosPd ] + y[ nPosCc ] + y[ nPosSe ] + y[ nPosSq ]   ;
				 } ;
	 )

aCols:=aClone(aAux)

Return( lRet )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³INTEGDEF  ºAutor  ³                     º Data ³ 22/10/2014 º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Função para a interação com EAI                             º±±
±±º          ³envio e recebimento                                         º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function IntegDef( cXml, nType, cTypeMsg, cVersaoMsg )

Local aRet := {}

aRet:= GPEI180( cXml, nType, cTypeMsg, cVersaoMsg )

Return aRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³GPFILSQB  ºAutor  ³ Leandro Drumond     º Data ³ 26/12/2014 º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Filtra consulta SQB						                  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function GPFILSQB

Local cFiltro	:= ""

If FunName() == "GPEA180" .OR. FunName() == "TCFA040"
	cFiltro += "SQB->QB_CC == '" + AllTrim(aCols[n,_CCUSTO]) + "' .OR. Empty(SQB->QB_CC)"
ElseIf cPaisLoc == "RUS"
	cFiltro += "Empty(SQB->QB_DTEND) .OR. SQB->QB_DTEND >= Date() .OR. SQB->QB_DTEND == CToD('12/31/9999')"
EndIf

cFiltro := "@#" + cFiltro + "@#"

Return(cFiltro)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³Fil180Browse ºAutor  ³ Wagner Mobile Costa º Data ³ 16/01/15º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Aplica filtro para rotina  				                  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function Fil180Browse

Local cFiltraRh		:= ChkRh( "GPEA180" , "SRA" , "1" )

bFiltraBrw	:= { || FilBrowse( "SRA" , @aIndexSRA , @cFiltraRh ) }
Eval( bFiltraBrw )

Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³ProcCmp ºAutor  ³Renan Borges  º Data ³  19/02/15           º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Procura a existência dos campos Filial e Matricula na tabe-º±±
±±º          ³ la desejada.                                               º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/

Static Function ProcCmp(cTab)
Local lRet	:= .T.
Local cCmpMat	:= ( PrefixoCpo( Upper( cTab ) ) + "_MAT" )
Local cCmpFil	:= ( PrefixoCpo( Upper( cTab ) ) + "_FILIAL" )
Local lTabExc := (( cTab ) $ "BAU/REP/TM0/TM5/TMT/RCY/RGV/AA1") // Tabelas que já são tratadas, pois possuem campos sinonimos aos de Filial e Matricula

If !lTabExc .AND. ( (cTab)->( FieldPos(cCmpMat) == 0 ) .OR. (cTab)->( FieldPos(cCmpMat) == 0 ) )
	lRet := .F.
EndIf

Return lRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³fVldTrf   ºAutor  ³Microsiga           º Data ³  22/05/14   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Valida se a transferencia pode ser processada               º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function fVldTrf()

Local lRet 			:= .T.
Local nCols 		:= 1
Local nPosMat 		:= IIF(!lRobo , GdFieldPos("RA_MAT"		, oGetSRA2:aHeader) , GdFieldPos("RA_MAT"	, aTransfHeader))
Local nPosRetTit 	:= IIF(!lRobo , GdFieldPos("QB_RETTIT"	, oGetSRA2:aHeader) , GdFieldPos("QB_RETTIT", aTransfHeader))
Local nPosSubTit 	:= IIF(!lRobo , GdFieldPos("QB_SUBTIT"	, oGetSRA2:aHeader) , GdFieldPos("QB_SUBTIT", aTransfHeader))
Local cMsg        	:= ""

If nPosRetTit == 0
	Return .T.
EndIf

For nCols := 1 To Len(oGetSRA2:aCols)
	If Empty(oGetSRA2:aCols[nCols,nPosRetTit]) .And. Empty(oGetSRA2:aCols[nCols,nPosSubTit])
		If ! Empty(cMsg)
			cMsg += ","
		EndIf
		cMsg += oGetSRA2:aCols[nCols,nPosMat]
	EndIf
Next

If ! Empty(cMsg)
	MsgInfo(STR0202 + cMsg + "] !")		// "Atenção. É obrigatório definir qual a ação de 'Retirar' e 'Atribuir' Titular para as matriculas ["
	lRet := .F.
EndIf

Return lRet


/*/{Protheus.doc} Gp180EmpTAF
Verifica se havera geracao dos eventos S-2299 e S-2200 ao fazer a transferencia entre Grupo/Empresa
@author jose.silveira
@since 20/03/2018
@version 12.1.17
/*/
Function Gp180EmpTAF()

Local nCols		:= 0
Local nPosDesl	:= 0
Local cMsg		:= ""
Local lRet 		:= .T.

If IsInCallStack( "TCFA040Atende" )
	cFilAte := M->RE_FILIALP
EndIf

If lTpDesl .And. Ch_Desl('2')

	If !lRobo
		If lGestPubl
			lGeraDem := MsgNoYes( OemToAnsi(Iif(!lMiddleware, STR0234, STR0292)) + CRLF + CRLF + OemToAnsi(Iif(!lMiddleware, STR0257, STR0306)) ) //"Integração com o TAF"#"Integração com o Middleware"#"A relotação está sendo realizada entre Grupo/Empresa de CNPJ diferente. Deseja integrar os eventos S-2299/S-2399 e S-2200/S-2300 com o TAF?"#"A relotação está sendo realizada entre Grupo/Empresa de CNPJ diferente. Deseja integrar os eventos S-2299 e S-2200 (para TCV) ou S-2399 (para TSV) com o Middleware?"
		Else
			lGeraDem := MsgNoYes( OemToAnsi(Iif(!lMiddleware, STR0234, STR0292)) + CRLF + CRLF + OemToAnsi(Iif(!lMiddleware, STR0235, STR0293)) ) //"Integração com o TAF"#"Integração com o Middleware"#"A transferencia está sendo realizada entre Grupo/Empresa de CNPJ diferente. Deseja integrar os eventos S-2299/S-2399 e S-2200/S-2300 com o TAF?"#A transferência está sendo realizada entre Grupo/Empresa de CNPJ diferente. Deseja integrar os eventos S-2299 e S-2200 (para TCV) ou S-2399 (para TSV) com o Middleware?"
		Endif
	Else
		lGeraDem := .T.
	EndIf

	//Se foi solicitada a geração dos eventos S-2299 e S-2200
	If lGeraDem
		//Não será possível utilizar MV_REUTMAT, a chave formada pela filial, matrícula e data
		//ultrapassa o tamanho máximo do campo de matrícula no eSocial podendo gerar inconsistências.
		If !lMiddleware .And. lReutMat .And. (TamSx3("RA_FILIAL")[1] + TamSx3("RA_MAT")[1] + Len(FwTimeStamp()) > TamSx3("C9V_MATRIC")[1] )
			Help(" ", 1, OemToAnsi(STR0047),, OemToAnsi(STR0345), 1, 0 )
			Return .F.
		EndIf
		//Verifica se o Tipo de Desligamento foi preenchido
		nPosDesl := aScan( aFields, "RE_DESL" )
		If nPosDesl > 0
			If !lRobo
				For nCols := 1 To Len(oGetSRA2:aCols)
					If Empty(oGetSRA2:aCols[nCols, nPosDesl])
						lRet 		:= .F.
						lGeraDem 	:= .F.
						If lGestPubl
							MsgAlert( OemToAnsi(STR0256) ) //"Existe relotação entre Grupo/Empresa de CNPJ diferente sem o Tipo de Desligamento informado."
						Else
						MsgAlert( OemToAnsi(STR0233) ) //"Existe transferencia entre Grupo/Empresa de CNPJ diferente sem o Tipo de Desligamento informado."
						Endif
						Exit
					EndIf
				Next
			Else
				For nCols := 1 To Len(aTransfCols)
					If Empty(aTransfCols[nCols, nPosDesl])
						lRet 		:= .F.
						lGeraDem 	:= .F.
						If lGestPubl
							MsgAlert( OemToAnsi(STR0256) ) //"Existe relotação entre Grupo/Empresa de CNPJ diferente sem o Tipo de Desligamento informado."
						Else
						MsgAlert( OemToAnsi(STR0233) ) //"Existe transferencia entre Grupo/Empresa de CNPJ diferente sem o Tipo de Desligamento informado."
						Endif
						Exit
					EndIf
				Next
			EndIf
		EndIf
	EndIf

	If lGeraDem .And. !FindFunction("fTrf2299")
		MsgAlert( OemToAnsi(Iif(!lMiddleware, STR0236, STR0294)) ) //"Nao será possivel efetuar a Tranferencia porque foi solicitada a integração dos eventos do TAF, porém a rotina GPEM026C está desatualizada."#"Nao será possivel efetuar a Tranferencia porque foi solicitada a integração dos eventos do Middleware, porém a rotina GPEM026C está desatualizada."
		lRet := .F.
	EndIf

EndIf

Return( lRet )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³UpdFilResp ºAutor  ³Microsiga          º Data ³  22/05/14   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³                                                            º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function UpdFilResp(oGet, cFilInf, cConteudo, nPosUpd, nPosDep)

Local nPosFil  := GdFieldPos("RA_FILIAL", aSRAHeader), nPosMat := GdFieldPos("RA_MAT", aSRAHeader)
Local nPosRetT := GdFieldPos("QB_RETTIT", oGet:aHeader), nPosSubT := GdFieldPos("QB_SUBTIT", oGet:aHeader)
Local nPosFilT := GdFieldPos("QB_FILTIT", oGet:aHeader), nPosMatT := GdFieldPos("QB_MATTIT", oGet:aHeader)
Local nPosNom  := GdFieldPos("QB_NOMTIT", oGet:aHeader)
Local aAreaSQB := SQB->(GetArea()), aArea := GetArea()

If nPosFilT > 0
	SQB->(DbSetOrder(1))
	SQB->(DbSeek(xFilial("SQB", cFilInf) + cConteudo))

	oGet:aCols[oGet:nAt, nPosFilT] := SQB->QB_FILTIT
	oGet:aCols[oGet:nAt, nPosMatT] := SQB->QB_MATTIT
	oGet:aCols[oGet:nAt, nPosNom] := ""
	If ! Empty(SQB->(QB_FILTIT + QB_MATTIT))
		oGet:aCols[oGet:nAt, nPosNom] := Posicione('SRA',1, SQB->(QB_FILTIT + QB_MATTIT),'RA_NOME')
	EndIf

	//-- Indica atualização dos campos Retira Titularidade e/ou Atribui Titularidade
	If nPosUpd > 0
		oGet:aCols[nPosUpd][nPosRetT] := oGet:aCols[nPosUpd][nPosSubT] := "2"

		//-- Caso o departamento tenha sido alterado e a filial+matricula for igual ao responsável coloca em branco
		//-- Obrigando ao usuário confirmar a ação
		If 	oGetSRA1:aCols[nPosUpd][nPosDep] <> cConteudo .And.;
			oGetSRA1:aCols[nPosUpd, nPosFilT] + oGetSRA1:aCols[nPosUpd, nPosMatT] ==;
			aSRACols[nPosUpd, nPosFil] + aSRACols[nPosUpd, nPosMat]
			oGet:aCols[nPosUpd][nPosRetT] := oGet:aCols[nPosUpd][nPosSubT] := " "
		EndIf
	EndIf
EndIf

RestArea(aAreaSQB)
RestArea(aArea)

Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³VldSubTit  ºAutor  ³MicroSiga           º Data ³  30/05/14   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³                                                            º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function VldSubTit()

Local lRet := .T.

If IsInCallStack( "fTransfUnico" )
	Return .T.
EndIf

If &(ReadVar()) = "1" .And. ! M->RA_CATFUNC $ "0,1"
	MsgInfo(STR0206) // "Atenção. Só é permitido atribuir titulares que forem membros !"

	lRet := .F.
EndIf

Return lRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFunction  ³a180VerTaf()ºAutor  ³Marcia Moura P11  º Data ³  18/08/16   º±±
±±º          ³            º       ³Claudinei S. P12  º Data ³  31/05/17   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Verifica se existe problema na integracao TAF               º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function a180VerTaf(aLogTransf,cFilAte,cFilEnv, lGeraMat, cEmpTrsf , cFilTrsf)
	Local aArea		:= GetArea()
	Local lRet		:= .F.
	Local cMsg		:= ""
	Local cCPF		:= ""
	Local cStatus	:= ""
	Local aFilInTaf := {}
	Local aArrayFil := {SRA->RA_FILIAL}
	Local aEstb		:= {}
	Local nPosFil	:= 0
	LOCAL cTrabVincu := fCatTrabEFD("TCV")
	Local cBkpFil	:= cFilAnt

	Default aLogTransf	:= {}
	Default cFilAte		:= ""
	Default cFilEnv		:= ""
	Default lGeraMat	:= SRA->(ColumnPos("RA_DESCEP")) > 0 .And. SRA->RA_DESCEP == "1"
	Default cEmpTrsf 	:= cEmpAnt // Empresa Origem/De
	Default cFilTrsf 	:= cFilAnt // Filial Origem/De

	If !lMiddleware
		fGp23Cons(@aFilInTaf, @aArrayFil,@cFilEnv, /*aFilInativ*/, If(lEmpDif, cEmpTrsf ,), If(lEmpDif, cFilTrsf,))
	EndIf

	If Empty(cFilEnv)
		cFilEnv:= cFilAnt
	EndIf

	aTpAlt := {.F.,.F.,.F.}

	aEstb		:= fGM23SM0(.T., .T.)
	nPosFil := aScan(aEstb,{|x| Alltrim(x[1]) == Alltrim(cFilAte)})

	If nPosFil > 0 .And. Len(aEstb[nPosFil]) > 3 .And. !aEstb[nPosFil,4]
		//"A transferência não será efetivada "
		//Funcionário ##Matricula## "está sendo transferido para uma filial que é uma obra, porém é sub-empreitada, empreitada parcial ou os dados da obra não foram encontrados na tabela F0F."
		//"Funcionários devem estar vinculados a uma filial ou obra própria da empresa. Verifique Dados da Filial - Módulo SIGACFG ou inclusão dos dados na tabela F0F"
		cMsg := STR0229 + CRLF + CRLF + STR0179 + SRA->RA_MAT + " " + STR0227 + CRLF + CRLF + STR0228
		aAdd( aLogTransf, cMsg )
		lRet := .T.
	Endif

	If !lRet
		If !(SRA->RA_CATEFD $ cTrabVincu)  // Se não possui vínculo, tenta resgatar CPF de trabalhador sem vínculo.
			If !lMiddleware
				If cVersEnvio >= "9.0"
					cCPF := AllTrim(SRA->RA_CIC) + ";" + If(lGeraMat, SRA->RA_CODUNIC, "") + ";" + AllTrim(SRA->RA_CATEFD) + ";" + DTOS(SRA->RA_ADMISSA)
				Else
					cCPF := AllTrim(SRA->RA_CIC) + ";" + AllTrim(SRA->RA_CATEFD) + ";" + DTOS(SRA->RA_ADMISSA)
				EndIf
				cStatus := TAFGetStat( "S-2300", cCPF )
			Else
				cCPF := If( cVersEnvio >= "9.0" .And. lGeraMat, SRA->RA_CODUNIC, AllTrim(SRA->RA_CIC) + AllTrim(SRA->RA_CATEFD) + DTOS(SRA->RA_ADMISSA) )

				cStatus := "-1"
				fPosFil( cEmpAnt, SRA->RA_FILIAL )
				aInfoC   := fXMLInfos()
				If LEN(aInfoC) >= 4
					cTpInsc  := aInfoC[1]
					lAdmPubl := aInfoC[4]
					cNrInsc  := aInfoC[2]
				Else
					cTpInsc  := ""
					lAdmPubl := .F.
					cNrInsc  := "0"
				EndIf
				cChaveMid	:= cTpInsc + PADR( Iif( !lAdmPubl .And. cTpInsc == "1", SubStr(cNrInsc, 1, 8), cNrInsc), 14) + "S2300" + Padr(cCPF, 40, " ")
				cStatus 	:= "-1"
				//RJE_TPINSC+RJE_INSCR+RJE_EVENTO+RJE_KEY+RJE_INI
				GetInfRJE( 2, cChaveMid, @cStatus )
			EndIf
		Else
			If !lMiddleware
				cCPF := AllTrim(SRA->RA_CIC) + ";" + ALLTRIM(SRA->RA_CODUNIC)
				cStatus := TAFGetStat( "S-2200", cCPF, cEmpAnt, cFilEnv )
			Else
				cStatus := "-1"
				fPosFil( cEmpAnt, SRA->RA_FILIAL )
				aInfoC   := fXMLInfos()
				If LEN(aInfoC) >= 4
					cTpInsc  := aInfoC[1]
					lAdmPubl := aInfoC[4]
					cNrInsc  := aInfoC[2]
				Else
					cTpInsc  := ""
					lAdmPubl := .F.
					cNrInsc  := "0"
				EndIf
				cChaveMid	:= cTpInsc + PADR( Iif( !lAdmPubl .And. cTpInsc == "1", SubStr(cNrInsc, 1, 8), cNrInsc), 14) + "S2200" + Padr(SRA->RA_CODUNIC, 36, " ")
				cStatus 	:= "-1"
				//RJE_TPINSC+RJE_INSCR+RJE_EVENTO+RJE_KEY+RJE_INI
				GetInfRJE( 2, cChaveMid, @cStatus )
			EndIf
		ENDIF

		If cStatus == "2"// em transito
			cMsg	:= STR0179+SRA->RA_MAT+" "+ iif(lGestPubl, Iif(!lMiddleware, STR0255, STR0305), Iif(!lMiddleware, STR0213, STR0290))
							//##"Funcionario "##" eSocial: Registro de admissão do funcionário em trânsito TAF x RET. A transferencia não será efetivada#"eSocial: Registro de admissão do funcionário em trânsito ao RET. A transferencia não será efetivada."
			aAdd( aLogTransf, cMsg )
			lRet := .T.
		Elseif (cStatus == "-1")
			aTpAlt := {.T.,.F.,.F.} // Gerar o evento S-2200
		Elseif (cStatus  $ " |0|1|3")
			aTpAlt := {.T.,.F.,.F.} // Gerar o evento S-2200
		Elseif cStatus == "4"
			aTpAlt := {.F.,.F.,.T.}
		Endif

		If lMiddleware
			fPosFil( cEmpAnt, cBkpFil )
		EndIf
	Endif

RestArea(aArea)
Return( lRet )

/*/{Protheus.doc} VldPosto
Valida a relação do posto com o cargo e a função do funcionário, perguntando ao usuário se deseja continuar
@author cicero.pereira
@since 16/06/2017
@version 1.0
/*/
Function VldPosto()

	Local aArea		:= GetArea()
	Local lRet		:= .T.
	Local cMsg		:= ""
	Local cKeySeek	:= ""
	Local lDifPosto	:= .F.

	If (cOrgCfg # "1")
		Return( lRet )
	Endif

	If ( lEmpDif )	// Tabela RCL já está aberta na Empresa Destino pela ConsPosto
		__cFil  := totvs.framework.company.xEmpFil("RCL", cEmpAte, cFilAte)
	Else
		__cFil  := FwxFilial( "RCL" , cFilAte )
	EndIf

	dbSelectArea("RCL")

	If Empty(M->RA_DEPTO)
		DbSetOrder(2)
		cKeySeek:= __cFil + M->RA_POSTO
	Else
		DbSetOrder(1)
		cKeySeek:= __cFil + M->RA_DEPTO + M->RA_POSTO
	EndIf

	RCL->( dbSeek(cKeySeek, .F. ))

	If !Empty(M->RA_CARGO) .And. RCL->RCL_CARGO != M->RA_CARGO
		cMsg := OemToAnsi(STR0218) // o cargo
		lDifPosto := .T.
	EndIf

	If RCL->RCL_FUNCAO != M->RA_CODFUNC
		If lDifPosto
			cMsg += OemToAnsi(STR0223) + OemToAnsi(STR0217) + OemToAnsi(STR0219) // e a Função diferentes
		Else
			cMsg := OemToAnsi(STR0217) + OemToAnsi(STR0220) // a Função diferente
		Endif
	ElseIf lDifPosto
		cMsg += OemToAnsi(OemToAnsi(STR0220)) // diferente
	EndIf

	If ! Empty(cMsg)
		lRet := MsgYesNo( OemToAnsi(STR0221) + cMsg + OemToAnsi(STR0224), OemToAnsi(STR0222)) // O Posto selecionado possui (o cargo e/ou a funcção) diferente do funcionário, Deseja continuar?
	EndIf

	RCL->(dbCloseArea())

	RestArea(aArea)

Return lRet
/*/{Protheus.doc} A180TBco
Função para copiar banco de conhecimento
@author Flavio
@since 17/07/2017
/*/
Static Function A180TBco(cFilACB,cFilAC9,cPathACB)
Local aArea		:= GetArea()
Local cObj 		:= ""
Local cDescri 	:= ""
Local cCodObj	:= ""
Local cAC9		:= "AC9"
Local cACB		:= "ACB"

Local cDirAtu	:= MsDocPath()
Local cDirNovo	:= ""
Local cAliasQry	:= ""
Local xFil		:= cFilAnt
Local cFilq		:= ""
Local xcEmp		:= ""
Local lNewReg	:= .T.
Local cQuery	:= ""
Local oStatement := Nil
Local nParamOrder := 1
Local cAliasSx8	 := ""

Default  cFilACB	:= xFilial("ACB")
Default  cFilAC9	:= xFilial("AC9")
Default  cPathACB	:= Upper(x2path("ACB"))

xcEmp	:= cEmpAnt
cFilq := xFilial("AC9",cFilde)

If lEmpDif
	cAC9		:= "GPEAC9"
	cACB		:= "GPEACB"
EndIf

	cQuery += "SELECT AC9.AC9_FILIAL, AC9.AC9_CODOBJ "
	cQuery += "FROM " + RetSqlName('AC9') + " AC9 "
	cQuery += "WHERE AC9.AC9_FILIAL = ? "
	cQuery +=	"AND AC9.AC9_ENTIDA = ? "
	cQuery +=	"AND AC9.AC9_FILENT = ? "
	cQuery +=	"AND AC9.AC9_CODENT = ? "
	cQuery += 	"AND AC9.D_E_L_E_T_ = ' ' "

	cQuery := ChangeQuery(cQuery)
	oStatement := FwExecStatement():New(cQuery)
	oStatement:SetString(nParamOrder++, cFilq)			// 1
	oStatement:SetString(nParamOrder++, 'SRA')			// 2
	oStatement:SetString(nParamOrder++, cFilde)			// 3
	oStatement:SetString(nParamOrder++, cFilde+cMatDe)	// 4

	// Executa a query e retorna o alias criado
	cAliasQry := oStatement:OpenAlias()

While !(cAliasQry)->(Eof())

	dbSelectArea("ACB")
	ACB->(dbSetOrder(1))
	If ACB->(dbSeek((cAliasQry)->AC9_FILIAL+(cAliasQry)->AC9_CODOBJ))
		cObj := ACB->ACB_OBJETO
		cDescri := ACB->ACB_DESCRI

		If lEmpDif
			cFilAnt	:= cFilAte
			cDirNovo	:= MsDocPath()

			If cDirNovo <> cDirAtu
				If File(cDirAtu + "\" +Alltrim(cObj)).And. !File(cDirNovo + "\" +Alltrim(cObj))
					__CopyFile( cDirAtu + "\" +Alltrim(cObj), cDirNovo + "\" +Alltrim(cObj) )
				EndIf
				EndIf
				fAbrEmpresa("ACB",1)
			EndIf

			cAliasSx8 := If(lEmpDif, cFilACB + cPathACB, "")
			cCodObj := GetSXENum( "ACB", "ACB_CODOBJ", cAliasSx8 )

			RecLock(cACB,.T.)
			(cACB)->ACB_FILIAL	:= cFilACB
			(cACB)->ACB_CODOBJ	:= cCodObj
			(cACB)->ACB_OBJETO	:= cObj
			(cACB)->ACB_DESCRI	:= cDescri
		(cACB)->(msUnlock())

		(cAC9)->(DbSetOrder(1))
		lNewReg := !((cAC9)->(DbSeek(cFilAC9 + "SRA" + cFilAte + cFilAte + cMatAte)))
		If RecLock(cAC9, lNewReg)
			(cAC9)->AC9_FILIAL	:= cFilAC9
			(cAC9)->AC9_ENTIDA	:= "SRA"
			(cAC9)->AC9_FILENT	:= cFilAte
			(cAC9)->AC9_CODENT	:= cFilAte+cMatAte
			(cAC9)->AC9_CODOBJ	:= cCodObj
			(cAC9)->(msUnlock())
		EndIf

		EndIf
		(cAliasQry)->(dbSkip())

		(cACB)->(ConfirmSx8())

		If lEmpDif
			fFecEmpresa( "ACB" )
		EndIf

	EndDo
	(cAliasQry)->(dbCloseArea())

	cFilAnt	:= xFil
	FreeObj(oStatement)
	RestArea(aArea)
Return

/*/{Protheus.doc} fOpenSx2
Função para abrir a SX2 de outra empresa
@author Rafael Reis
@since 29/12/2017
/*/
Static Function fOpenSx2(cEmp)
	Local lOk	:=	.T.

	SX2->(DBCloseArea())
	OpenSxs(,,,,cEmp,"SX2","SX2",,.F.)
	If Select("SX2") == 0
		lOk := .F.
	Endif

Return lOk

/*/{Protheus.doc} fMdtAdic
Função para validar adicionais do MDT
@author Allyson Mesashi
@since 05/03/2018
/*/
Static Function fMdtAdic(nOption)
Local cAliasTmp := iIf(lEmpDif,"GPESRA","SRA")
Local aArea		:= GetArea()
Local lOK		:= .T.
Local nRec		:= (cAliasTmp)->(recno())
If nOption == 1
	cBkpAdcIns	:= SRA->RA_ADCINS
	cBkpInsMax	:= SRA->RA_INSMAX
	cBkpAdcPeri	:= SRA->RA_ADCPERI
	cBkpPericul	:= SRA->RA_PERICUL
Else
	If !lEmpDif .And. lFilDif
		lOk := (cAliasTmp)->(dbSeek(cFilAte+cMatAte))
	EndIf
	If (SRA->RA_ADCINS != cBkpAdcIns .Or. SRA->RA_INSMAX != cBkpInsMax .Or. SRA->RA_ADCPERI != cBkpAdcPeri .Or. SRA->RA_PERICUL != cBkpPericul) .And. lOk .And. (cAliasTmp)->( RecLock(cAliasTmp, .F.) )
		(cAliasTmp)->RA_ADCINS	:= cBkpAdcIns
		(cAliasTmp)->RA_INSMAX	:= cBkpInsMax
		(cAliasTmp)->RA_ADCPERI	:= cBkpAdcPeri
		(cAliasTmp)->RA_PERICUL	:= cBkpPericul
		(cAliasTmp)->( MsUnlock() )
		If !lEmpDif .And. lFilDif
			(cAliasTmp)->(dbGoto(nRec))
		EndIF
	EndIf
EndIf

RestArea(aArea)
Return

/*/{Protheus.doc} Gpea180TAF
Função responsável por enviar os afastamentos ao TAF sob demanda(off-line)
@type function
@author Claudinei Soares
@since 27/04/2018
@version 1.0
@param cEvento	, Caracter	, Código do evento a ser verificado
@return lRet	, Lógico	, Retorno da função, se verdadeiro houve alteração
/*/
Function Gpea180TAF()

Local aSays		   	:= {}
Local aButtons	   	:= {}
Local cPerg        	:= "GP180TAF"
Local nOpcA		  	:= 0.00

Private aArea		:= GetArea()
Private aAreaSRA	:= SRA->( GetArea() )
Private cCadastro 	:= OemToAnsi(Iif(!lMiddleware, STR0240, STR0296)) //"Envio de Transferências ao SIGATAF"#"Envio de Transferências ao Middleware"

Private cSraFilter	:= ""
Private aRetFiltro	:= {}
Private aFilterExp	:= {}
Private aTabCompany	:= {}	// Array para controlar abertura das tabelas de outras empresas

If FindFunction("fVersEsoc")
    fVersEsoc( "S2200", .F., /*aRetGPE*/, /*aRetTAF*/, @cVersEnvio, @cVersGPE )
EndIf
Pergunte(cPerg, .F.)

AAdd( aFilterExp , { "FILTRO_ALS" , "SRA"     	, .T. } )			 /* Retorne os Filtros que contenham os Alias Abaixo */
AAdd( aFilterExp , { "FILTRO_PRG" , FunName() 	, NIL , NIL    } )  /* Que Estejam Definidos para a Função */

aAdd(aSays,OemToAnsi(Iif(!lMiddleware, STR0241, STR0297)))			//"Esta rotina tem como objetivo a geração e envio do XML das trasferências ao SIGATAF"#"Esta rotina tem como objetivo a geração e envio do XML das trasferências ao Middleware"
aAdd(aSays,OemToAnsi(Iif(!lMiddleware, STR0242, STR0298)))			//"Pode ser utilizada para as transferências que não foram integradas ao SIGATAF"#"Pode ser utilizada para as transferências que não foram integradas ao Middleware"
aAdd(aSays,OemToAnsi(STR0243))			//"automaticamente no processo de transferência."

aAdd(aButtons, { 17,.T.,{|| aRetFiltro := FilterBuildExpr( aFilterExp ) } } )
aAdd(aButtons, { 5,.T.,{|| Pergunte(cPerg,.T. ) } } )
aAdd(aButtons, { 1,.T.,{|o| nOpcA := 1,IF(gpconfOK(),FechaBatch(),nOpcA:=0) }} )
aAdd(aButtons, { 2,.T.,{|o| FechaBatch() }} )
FormBatch( cCadastro, aSays, aButtons )

IF nOpcA == 1
	Processa({|lEnd| fPrep180(cPerg),Iif(!lMiddleware, STR0240, STR0296)})  //"Envio de Transferências ao SIGATAF"#"Envio de Transferências ao Middleware"
EndIF

//Restaura os Dados de Entrada
RestArea( aAreaSRA )
RestArea( aArea )
Return( NIL )

Function fPrep180(cPerg)
Local aColsMark		:= {}
Local cIdGrid
Local lMarcar     	:= .F.
Local oPanelUp
Local oTela
LOcal oFont
Local aAdvSize		:= {}
Local aInfoAdvSize	:= {}
Local aObjSize		:= {}
Local aObjCoords	:= {}
Local bCalcula 		:= {|| If(fEnvTaf180(cPerg),oDlgMark:End(),Nil) }
Local aStru			:= SRE->(DBSTRUCT())

Private aRotMark   	:= {}
Private cAliasMark 	:= "TABAUX"
Private oMark		:= FWMarkBrowse():New()
Private oDlgMark	:= Nil
Private oTmpTable

fCriaTmp(aStru)
aColsMark:= fMntColsMark()

aAdvSize	:= MsAdvSize( .F.,.F.)
aInfoAdvSize	:= { aAdvSize[1] , aAdvSize[2] , aAdvSize[3] , aAdvSize[4] , 5 , 5 }
aAdd( aObjCoords , { 000 , 000 , .T. , .T. } )
aObjSize	:= MsObjSize( aInfoAdvSize , aObjCoords )

Define MsDialog oDlgMark FROM aAdvSize[7],0 TO aAdvSize[6],aAdvSize[5] Title "Transferências" Pixel  ////"Transferências"

// Cria o conteiner onde serão colocados os paineis
oTela     := FWFormContainer():New( oDlgMark )
cIdGrid   := oTela:CreateHorizontalBox( 90 )

oTela:Activate( oDlgMark, .F. )

//Cria os paineis onde serao colocados os browses
oPanelUp  	:= oTela:GeTPanel( cIdGrid )

oMark:SetAlias(cAliasMark)
oMark:SetFields(aColsMark)
oMark:SetIgnoreARotina(.T.)
oMark:SetMenuDef("")
oMark:SetOwner(oPanelUp)
oMark:AddButton("Transmitir", bCalcula,,,, .F., 2 ) //"Transmitir"
oMark:bAllMark := { || SetMarkAll(oMark:Mark(),lMarcar := !lMarcar ), oMark:Refresh(.T.)  }
oMark:SetFieldMark( 'TAB_OK')
oMark:AllMark()

oMark:Activate()

ACTIVATE MSDIALOG oDlgMark CENTERED

If oTmpTable <> NIL

	If (Select(cAliasMark) > 0)
		(cAliasMark)->(dbCloseArea())
	EndIf

	oTmpTable:Delete()
	oTmpTable := Nil
Endif

Return Nil

/*/{Protheus.doc} SetMarkAll
Marca/Desmarca todos os itens da markbrowse
@author Leandro Drumond
@since 16/05/2016
@version 1.0
/*/
Static Function SetMarkAll(cMarca,lMarcar )

Local aAreaMark  := (cAliasMark)->( GetArea() )

dbSelectArea(cAliasMark)
(cAliasMark)->( dbGoTop() )

While !(cAliasMark)->( Eof() )
	RecLock( (cAliasMark), .F. )
	(cAliasMark)->TAB_OK := IIf( lMarcar, cMarca, '  ' )
	MsUnLock()
	(cAliasMark)->( dbSkip() )
EndDo

RestArea( aAreaMark )

Return .T.

/*/{Protheus.doc} FMntColsMark
Carrega tabela temporária com dados para exibição na MarkBrowse
@author Leandro Drumond
@since 16/05/2016
@version 1.0
/*/
Static Function fMntColsMark()
Local aArea		:= GetArea()
Local aColsAux 	:=`{}
Local aColsSX3	:= {}
Local lDataTAF	 := SRE->(ColumnPos('RE_INTGTAF')) > 0
Local aCampos  	:= {"RE_DATA","RA_NOME","RE_EMPD","RE_FILIALD","RE_MATD","RE_EMPP","RE_FILIALP","RE_MATP","RE_CLVLD","RE_CLVLP","RE_CCD","RE_CCP","RE_ITEMD","RE_ITEMP","RE_DESL",iif(lDataTAF,"RE_INTGTAF","")}
Local aDados	:= {{||(cAliasMark)->RE_DATA},{||(cAliasMark)->RA_NOME},{||(cAliasMark)->RE_EMPD},{||(cAliasMark)->RE_FILIALD}, {||(cAliasMark)->RE_MATD},{||(cAliasMark)->RE_EMPP},{||(cAliasMark)->RE_FILIALP},{||(cAliasMark)->RE_MATP},{||(cAliasMark)->RE_CLVLD},{||(cAliasMark)->RE_CLVLP},{||(cAliasMark)->RE_CCD},{||(cAliasMark)->RE_CCP},{||(cAliasMark)->RE_ITEMD},{||(cAliasMark)->RE_ITEMP},{||(cAliasMark)->RE_DESL},iif(lDataTAF,{||(cAliasMark)->RE_INTGTAF},"")}
Local nX		:= 0

DbSelectArea("SX3")
DbSetOrder(2)

For nX := 1 to Len(aCampos)
	If !Empty(aCampos[nX]) .And. SX3->( dbSeek(aCampos[nX]) )
	    aColsSX3 := {X3Titulo(),aDados[nX], SX3->X3_TIPO, SX3->X3_PICTURE,1,SX3->X3_TAMANHO,SX3->X3_DECIMAL,.F.,,,,,,,,1}
	    aAdd(aColsAux,aColsSX3)
	    aColsSX3 := {}
	EndIf
Next nX


RestArea(aArea)

Return aColsAux

/*/{Protheus.doc} fCriaTmp
Cria tabela temporária para uso do FwMarkBrowse
@author Leandro Drumond
@since 16/05/2016
@version 1.0
/*/
Static Function fCriaTmp(aColumns)
Local aArea		 := GetArea()
Local cWhere	 := ''
Local lRet		 := .T.
Local lDataTAF	 := SRE->(ColumnPos('RE_INTGTAF')) > 0
Local nI 		 := 1
Local cAliasSRE	 := GetNextAlias()
Local cFilDe	:= If(Empty(MV_PAR01),""			, MV_PAR01) //Filial De
Local cFilAte	:= If(Empty(MV_PAR02),"ZZZZZZZZZZZZ", MV_PAR02) //Filial Ate
Local cCCDe		:= If(Empty(MV_PAR03),""			, MV_PAR03) //Centro de Custo De
Local cCCAte	:= If(Empty(MV_PAR04),"ZZZZZZZZZZZZ", MV_PAR04) //Centro de Custo Ate
Local cMatDe	:= If(Empty(MV_PAR05),""			, MV_PAR05) //Matricula De
Local cMatAte	:= If(Empty(MV_PAR06),"ZZZZZZ"		, MV_PAR06) //Matricula Ate
Local cDataDe	:= If(Empty(MV_PAR07),"CTOD('//')"	, MV_PAR07) //Data De
Local cDataAte	:= If(Empty(MV_PAR08),"date()"		, MV_PAR08) //Data Ate
Local cWhereSRE	:= ""
Local aGroup	:= FWAllGrpCompany()
Local nX		:= 1
Local nTamGrp	:= Len(aGroup)
Local cNome		:= ""
Local aTransf	:= {}
Local nY		:= 1
Local aRecno	:= {}

aAdd( aColumns, { "TAB_OK"		,"C",02,00 })
aAdd( aColumns, { "RA_NOME"		,"C",TamSx3("RA_NOME")[1],00 })

//Efetua a criacao do arquivo temporario
oTmpTable := FWTemporaryTable():New(cAliasMark)
oTmpTable:SetFields( aColumns )
oTmpTable:AddIndex( "TABAUX1", {"RA_NOME","RE_DATA"} )
oTmpTable:Create()

cSraFilter	:= GpFltAlsGet( aRetFiltro , "SRA" )

cWhere := " SRE.RE_FILIALD BETWEEN  " + "'" + cFilDe + "'" + " AND " + "'" + cFilAte+"'""
cWhere += " AND SRE.RE_MATD BETWEEN " + "'" + cMatDe + "'" + " AND " + "'" + cMatAte+"'""
cWhere += " AND SRE.RE_CCD BETWEEN " + "'" + cCCDe + "'" + " AND " + "'" + cCCAte + "'""
cWhere += " AND SRE.RE_DATA BETWEEN " + "'" + IIF(!EMPTY(MV_PAR07), DTOS(cDataDe), "") + "'" + " AND " + "'" + IIF(!EMPTY(MV_PAR08), DTOS(cDataAte), "") + "'""
If lDataTAF .And. MsgYesNo( OemToAnsi(Iif(!lMiddleware, STR0278, STR0307)) + CRLF + OemToAnsi(Iif(!lMiddleware, STR0279, STR0308)), OemToAnsi( STR0210 ) )//'Selecione "Sim" se deseja desprezar as transferências que já foram integradas ao TAF.'#'Selecione "Sim" se deseja DESPREZAR as transferências que já foram integradas ao Middleware.'#'Selecione "Não" se deseja reprocessar as transferências que já foram integradas ao TAF.'#'Selecione "Não" se deseja REPROCESSAR as transferências que já foram integradas ao Middleware.'#"Atenção"
	cWhere += " AND SRE.RE_INTGTAF = ' ' "
EndIf
cWhere += " AND SRE.D_E_L_E_T_ = ' ' "
cWhere := "% " + cWhere + " %"

BeginSql alias cAliasSRE
	SELECT  R_E_C_N_O_ AS RECNOSRE
	FROM %table:SRE% SRE
	WHERE %exp:cWhere%
	ORDER BY SRE.RE_DATA, SRE.RE_EMPD, SRE.RE_FILIALD, SRE.RE_MATD
EndSql

SRA->(dbSetOrder(1))
While (cAliasSRE)->(!Eof())
	SRE->(DbGoto((cAliasSRE)->(RECNOSRE)))
	SRA->(dbSeek(SubStr( SRE->(RE_FILIALD),1,FWGETTAMFILIAL)+SRE->RE_MATD))

	If !Empty( cSraFilter )
		If !( &( cSraFilter ) )
			(cAliasSRE)->(dbSkip())
			Loop
		EndIf
	EndIf

	aTransf := {}
	fTransfAll(@aTransf)
	For nY := 1 To Len(aTransf)
		If Empty(aRecno) .Or. Ascan(aRecno,{|x| x == aTransf[nY][13] }) == 0
			SRE->(DbGoto(aTransf[nY][13]))
			aadd(aRecno,aTransf[nY][13])
			If SRE->RE_DATA >= cDataDe .and. SRE->RE_DATA <= cDataAte
				cNome := GetAnyDesc(SRE->RE_EMPD, SubStr( SRE->(RE_FILIALD),1,FWGETTAMFILIAL), "SRA", SRE->RE_MATD)
				RecLock(cAliasMark,.T.)
					(cAliasMark)->RA_NOME	 	:= cNome
					(cAliasMark)->RE_FILIAL 	:= SRE->RE_FILIAL
					(cAliasMark)->RE_DATA 		:= SRE->RE_DATA
					(cAliasMark)->RE_EMPD 		:= SRE->RE_EMPD
					(cAliasMark)->RE_FILIALD 	:= SRE->RE_FILIALD
					(cAliasMark)->RE_MATD 		:= SRE->RE_MATD
					(cAliasMark)->RE_EMPP 		:= SRE->RE_EMPP
					(cAliasMark)->RE_FILIALP 	:= SRE->RE_FILIALP
					(cAliasMark)->RE_MATP 		:= SRE->RE_MATP
					(cAliasMark)->RE_CLVLD 		:= SRE->RE_CLVLD
					(cAliasMark)->RE_CLVLP 		:= SRE->RE_CLVLP
					(cAliasMark)->RE_CCD 		:= SRE->RE_CCD
					(cAliasMark)->RE_CCP 		:= SRE->RE_CCP
					(cAliasMark)->RE_ITEMD 		:= SRE->RE_ITEMD
					(cAliasMark)->RE_ITEMP 		:= SRE->RE_ITEMP
					If lDataTAF
						(cAliasMark)->RE_INTGTAF 	:= SRE->RE_INTGTAF
					EndIf
					(cAliasMark)->RE_DESL 		:= SRE->RE_DESL
				(cAliasMark)->(msUnlock())
				EndIf
		EndIf
	Next nY
	(cAliasSRE)->(dbSkip())
EndDo
(cAliasSRE)->(dbCloseArea())

Return lRet

/*/{Protheus.doc} GetAnyDesc
Busca descrição do campo em outro Grupo de empresa
@author Flavio Correa
@since 02/05/2019
/*/
Static Function GetAnyDesc(cEmp, cFilTab, cTab, cChv)
Local aArea 		:= GetArea()
Local cAliasQry		:= GetNextAlias()
Local cDescr		:= ""
Local cTabela		:= ""
Local nPos			:= 0

Default cEmp := cEmpAnt
IIF(Empty(cEmp),cEmp := cEmpAnt,cEmp := cEmp)

cTabela	:= "%"+RetFullName(cTab,cEmp)+"%"

BeginSQL alias cAliasQry
	SELECT SRA.RA_NOME,RA_NOMECMP
	FROM %Exp:cTabela% SRA
	WHERE SRA.RA_FILIAL = %exp:cFilTab% AND
      SRA.RA_MAT = %exp:cChv% AND
      SRA.%notDel%
EndSQL

If !(cAliasQry)->( Eof() )
	cDescr    :=Iif(!Empty((cAliasQry)->RA_NOMECMP),(cAliasQry)->RA_NOMECMP,Alltrim((cAliasQry)->RA_NOME))
EndIf

(cAliasQry)->(dbCloseArea())
RestArea(aArea)
Return cDescr



/*/{Protheus.doc} fEnvTaf180
Função responsável por processar os funcionarios transferidos para o TAF sob demanda(off-line)
@type function
@author Claudinei Soares
@since 02/05/2018
@version 1.0
@param cEvento	, Caracter	, Código do evento a ser verificado
@return lRet	, Lógico	, Retorno da função, se verdadeiro houve alteração
/*/
Static Function fEnvTaf180(cPerg)

Local aArea			:= GetArea()
Local cMarca 		:= oMark:Mark()
Local cFilTRF		:= ""
Local cCodUnic		:= ""
Local cTrabVincu	:= fCatTrabEFD("TCV") //"101|102|103|104|105|106|111|301|302|303|306|309" //Trabalhador com vinculo
Local cErXML		:= ""
Local cMsgLog		:= ""
Local cMsgLogXML	:= ""
Local cAliasRFZ		:= "RFZ"
Local lTrfEmp		:= If(Empty(MV_PAR09),.F.			, MV_PAR09 == 1) //Int. Tranf. Empresas ?
Local cTpDesl		:= MV_PAR10										//Tipo de Desligamento
Local cTpInscPara	:= ""

Local lCGC_Dif		:= .F.
Local lFilDif		:= .F.
Local lErroTaf		:= .F.
Local lCttDif		:= .F.
Local lObraTot		:= .F.
Local lGerouXml		:= .T.
Local lIncRFZ		:= .F.
Local nX			:= 0
Local nFilD			:= 0
Local nFilP			:= 0
Local nNumEmp		:= 0
Local aVinc			:= {}
Local aFilCNPJ		:= {}
Local aAreaSM0		:= {}
Local aEmpFil		:= {}
Local aErr2206		:= {}
Local aErr2200		:= {}
Local aErr2306		:= {}
Local aLogTransf	:= {}
Local dDtTRF		:= CtoD("//")

Local aOperCC		:= {.F., .F., .F., .F.}
Local cOrigInsc		:= ""
Local cDestNInsc	:= ""

Local bMkLog		:= { || NIL }

Local cArqSR6		:= ""
Local cArqSRJ		:= ""
Local cArqSQ3		:= ""
Local cArqSRA		:= ""
Local cSR6Fil
Local cSRJFil
Local cSQ3Fil
Local __cEmpAnte	:= ""
Local __cFilAnte 	:= ""
Local cMsgErro		:= ""
Local cSavFilAnt 	:= cFilAnt
Local lDataTAF		:= SRE->(ColumnPos('RE_INTGTAF')) > 0
Local nSraRec		:= 0
Local cCCAte		:= If(Empty(MV_PAR04),"''"			, MV_PAR04) //Centro de Custo Ate
Local lGrvCodUn		:= .F.
Local nTamCod		:= TamSx3("RA_CODUNIC")[1]
Local cBkpFil		:= ""
Local lS2300		:= .F.
Local lGeraInt		:= .F.
Local cStatDesl		:= "-1"
Local cNewCodUnic	:= ""
Local cFilEnv		:= ""
Local aRH5Filt	 	:= {}
Local cFilS2200		:= ""
Local lMatTSV		:= SRA->(ColumnPos("RA_DESCEP")) > 0
Local lGeraMat		:= .F.
Local cGeraMat		:= ""
Local lMdtGPE 		:= SuperGetMv( "MV_MDTGPE", , "N" ) == "S"
Local leSocMDT		:= IIf( FindFunction( "MDTVldEsoc" ), MDTVldEsoc(), .F. )
Local cFuncAte		:= ""
Local cCargoAte		:= ""
Local cCodUniMDT	:= ""
Local aInfMDT		:= {}
Local cLogMDT		:= ""
Local lTAFTransf	:= .F.
Local lTAFDest		:= .F.
Local nTamEmP		:= 0
Local cAliasRJ5		:= "RJ5"
Local cFilRJ5At		:= ""

Private cCcuAte		:= cCCAte
Private cFilAte		:= If(Empty(MV_PAR02),"''"			, MV_PAR02) //Filial Ate
Private lEmpDif		:= .F. // Declaração devido à uso em fTafFilGpe
Private cEmpD	 	:= "" // Declaração devido a uso em Transf. entre Grupo de Empresas fIntAdmiss/fInt2300New e Transferência Offline (fVersEsoc)
Private cFilD	 	:= "" // Declaração devido a uso em Transf. entre Grupo de Empresas fIntAdmiss/fInt2300New e Transferência Offline (fVersEsoc)
Private cEmpP	 	:= "" // Declaração devido a uso em Transf. entre Grupo de Empresas fTrf2299/fTrf2399 e Transferência Offline (fVersEsoc)
Private cFilP	 	:= "" // Declaração devido a uso em Transf. entre Grupo de Empresas fTrf2299/fTrf2399 e Transferência Offline (fVersEsoc)

Default lVerRJ5		:= FindFunction("fVldObraRJ") .And. (fVldObraRJ(@lParcial, .F.) .And. !lParcial)

Set(4,"dd/mm/yyyy")

//Se foi indicada a geracao de eventos entre empresas, nao processa a integracao caso o tipo de desligamento nao esteja informado
If lTrfEmp .And. Empty(cTpDesl)
	MsgInfo( STR0245 ) //"Foi selecionada a opção de integração entre empresas, mas não foi informado o Tipo de Desligamento."
	Return .T.
EndIf

//Obtem as informacoes das Filiais da empresa para obter o codigo do CNPJ
aAreaSM0	:= SM0->( GetArea() )
aEmpFil		:= ArrEmpFilGet()
nNumEmp		:= Len(aEmpFil)

For nX := 1 To nNumEmp

	SM0->( MsGoto( aEmpFil[nX,3] ) )

	cFilTRF := aEmpFil[nX,2]
	Aadd( aFilCNPJ, { SM0->M0_CODIGO, cFilTRF, SM0->M0_CGC, If( Len(SM0->M0_CGC) == 11, "2", "1" ) } )

Next nX

RestArea( aAreaSM0 )

SX3->(dbSetOrder(2)) //Indice por campo

__cEmpAnt := cEmpAnt
__cLastEmp := cEmpAnt+cFilAnt

DbSelectArea(cAliasMark)
(cAliasMark)->(DbGoTop())

//Posicionamento do primeiro registro e Loop Principal
While (cAliasMark)->(!Eof())

	If !oMark:IsMark(cMarca)
		(cAliasMark)->(DbSkip())
		Loop
	EndIf
	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Posiciona na tabela SRA - Fisica                    	 	   	³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	dbSelectArea("SRA")
	dbSetOrder(RetOrder("SRA", "RA_FILIAL+RA_MAT"))
	cEmpD := (cAliasMark)->(RE_EMPD)
	cEmpP := (cAliasMark)->(RE_EMPP)
	nTamEmP	:= Len(totvs.framework.company.xEmpFil("SRA", (cAliasMark)->(RE_EMPP), (cAliasMark)->(RE_FILIALP)))
	cFilD := SubStr( (cAliasMark)->(RE_FILIALD),1,FWGETTAMFILIAL) // Captura tamanho de acordo com a logada
	cFilP := SubStr( (cAliasMark)->(RE_FILIALP),1,nTamEmP)
	dDtTRF := ((cAliasMark)->(RE_DATA))
	cFilAnt := (cAliasMark)->(RE_FILIALD)

	If !SRA->(dbSeek(cFilD + (cAliasMark)->(RE_MATD),.F.))
		(cAliasMark)->(DbSkip())
		Loop
	EndIf
	lEmpDif 	:= (cAliasMark)->(RE_EMPD) <> (cAliasMark)->(RE_EMPP)
	lFilDif 	:= (cAliasMark)->(RE_FILIALD) <> (cAliasMark)->(RE_FILIALP)
	lCttDif 	:= (cAliasMark)->(RE_CCD) <> (cAliasMark)->(RE_CCP) .Or. xFilial("CTT", (cAliasMark)->(RE_FILIALD)) <> xFilial("CTT", (cAliasMark)->(RE_FILIALP))
	lObraTot 	:= .F.
	lGrvCodUn 	:= .F.
	lS2300		:= .F.
	cNewCodUnic	:= ""
	lGeraMat	:= If(lMatTSV, SRA->RA_DESCEP == "1", .F.)

	If lCttDif
		Begin Sequence
			IF lVerRJ5
				aOperCC	:= {.F., .F., .F., .F.}
				cOrigInsc := ""
				cDestNInsc := ""
				DbSelectArea("RJ5")
				aRH5Filt := fRJ5Filt()
				RJ5->( dbSetOrder(7) )//RJ5_FILIAL+RJ5_CC+RJ5_FILT+RJ5_COD+RJ5_INI
				RJ5->(dbGotop())
				If Len(aRH5Filt) > 0
					If RJ5->( dbSeek( xFilial("RJ5", cFilD) + (cAliasMark)->(RE_CCD) + cFilD ) )
						While RJ5->( !EoF() ) .And. RJ5->RJ5_FILIAL == xFilial("RJ5", cFilD) .And.  RJ5->RJ5_CC == (cAliasMark)->(RE_CCD) .And.;
							IF(!Empty(RJ5->RJ5_FILT) , RJ5->RJ5_FILT == cFilD, .T.)
							IF AnoMes(dDtTRF) >= RJ5_INI
								//CC de origem existe na RJ5
								aOperCC[1] := .T.
								cOrigInsc := RJ5_NIO
								IF !EMPTY(RJ5->(RJ5_TPIO)) .AND. !EMPTY(RJ5->(RJ5_NIO))
									//CC de origem tem as informações de tipo e inscrição preenchidas
									aOperCC[2] := .T.
								ENDIF
							ENDIF
							RJ5->( dbSkip() )
						EndDo
					EndIf
				Endif
				If Len(aRH5Filt) == 0 .Or.  !aOperCC[1]
					IF RJ5->( dbSeek( xFilial("RJ5", cFilD) + (cAliasMark)->(RE_CCD) ) )
						While RJ5->(!EoF()) .And. RJ5->RJ5_FILIAL == xFilial("RJ5", cFilD) .And. RJ5->RJ5_CC == (cAliasMark)->(RE_CCD) .And.;
								IF(!Empty(RJ5->RJ5_FILT) , RJ5->RJ5_FILT == (cAliasMark)->(RE_FILIALP), .T.)
								IF AnoMes(dDtTRF) >= RJ5_INI
									//CC de origem existe na RJ5
									aOperCC[1] := .T.
									cOrigInsc := RJ5_NIO
									IF !EMPTY(RJ5->(RJ5_TPIO)) .AND. !EMPTY(RJ5->(RJ5_NIO))
										//CC de origem tem as informações de tipo e inscrição preenchidas
										aOperCC[2] := .T.
									ENDIF
								ENDIF
								RJ5->( dbSkip() )
							EndDo
					EndIf
				Endif

				// Se não encontrou registro de origem, cancela a transferência
				IF !aOperCC[1]
					//Não Permite transferência
					cMsgLog := STR0281 + " " + (cAliasMark)->(RE_CCD) + " (origem), do funcionário " + ALLTRIM(SRA->RA_NOME) + " (Matrícula: " + SRA->RA_MAT + ") " + STR0282
					aAdd(aLogTransf, OemToAnsi(cMsgLog))
					RJ5->(DbCloseArea())
					Break
				ENDIF

				If lEmpDif
					fAbrEmpresa("RJ5",7,cEmpP,cFilP)
					cAliasRJ5 := "GPERJ5"
				EndIf
				cFilRJ5At := If(lEmpDif ,totvs.framework.company.xEmpFil("RJ5", cEmpP, cFilP), xFilial("RJ5", cFilAte))

				(cAliasRJ5)->( dbSetOrder(7) )//RJ5_FILIAL+RJ5_CC+RJ5_FILT+RJ5_COD+RJ5_INI
				(cAliasRJ5)->(dbGotop())
				If Len(aRH5Filt) > 0
					If (cAliasRJ5)->( dbSeek( cFilRJ5At + (cAliasMark)->(RE_CCP) + cFilP ) )
						While (cAliasRJ5)->(!EoF()) .And. (cAliasRJ5)->RJ5_FILIAL == cFilRJ5At .And. (cAliasRJ5)->RJ5_CC == (cAliasMark)->(RE_CCP) .And.;
							IF(!Empty((cAliasRJ5)->RJ5_FILT) , (cAliasRJ5)->RJ5_FILT == cFilP, .T.)
							IF AnoMes(dDtTRF) >= (cAliasRJ5)->RJ5_INI
							//CC de destino existe na RJ5
								aOperCC[3] := .T.
								IF !EMPTY((cAliasRJ5)->(RJ5_TPIO)) .AND. !EMPTY((cAliasRJ5)->(RJ5_NIO))
									//CC de destino tem as informações de tipo e inscrição preenchidas
									aOperCC[4] := .T.
								ENDIF
							Endif
							(cAliasRJ5)->( dbSkip() )
						EndDo
					EndIf
				Endif
				If Len(aRH5Filt) == 0 .Or.  !aOperCC[1]
					IF (cAliasRJ5)->( dbSeek( cFilRJ5At + (cAliasMark)->(RE_CCP) ) )
						While (cAliasRJ5)->(!EoF()) .And. (cAliasRJ5)->RJ5_FILIAL == cFilRJ5At .And. (cAliasRJ5)->RJ5_CC == (cAliasMark)->(RE_CCP) .And.;
							IF(!Empty((cAliasRJ5)->RJ5_FILT) , (cAliasRJ5)->RJ5_FILT == cFilP, .T.)
							IF AnoMes(dDtTRF) >= RJ5_INI
								//CC de destino existe na RJ5
								aOperCC[3] := .T.
								IF !EMPTY((cAliasRJ5)->(RJ5_TPIO)) .AND. !EMPTY((cAliasRJ5)->(RJ5_NIO))
									//CC de destino tem as informações de tipo e inscrição preenchidas
									aOperCC[4] := .T.
								ENDIF
							Endif
							(cAliasRJ5)->( dbSkip() )
						EndDo
					EndIf

				Endif
				If lEmpDif
					fFecEmpresa("RJ5")
				EndIf

				IF !aOperCC[3]
					//Não Permite transferência
					cMsgLog := " " + (cAliasMark)->(RE_CCP) + " (destino), do funcionário " + ALLTRIM(SRA->RA_NOME) + " (Matrícula: " + SRA->RA_MAT + ") "
					aAdd(aLogTransf, OemToAnsi(STR0281 + cMsgLog + STR0282))
					break
				ELSEIF (aOperCC[2] .OR. aOperCC[4]) .AND. cOrigInsc != cDestNInsc
					//Gera S2206
					lObraTot := .T.
				ELSEIF aOperCC[1] .AND. !aOperCC[2] .AND. aOperCC[3] .AND. !aOperCC[4]
					//Não gerar S2206
					lObraTot := .F.
				ENDIF
			ELSE
				lObraTot := Gpa180CC(cFilD, (cAliasMark)->(RE_CCD), cFilP, (cAliasMark)->(RE_CCP))
			ENDIF
		End Sequence
	Endif

	If lEmpDif .OR. lFilDif .OR. lObraTot
		If (lIntTAF .Or. lMiddleware) .And. (SRA->RA_CATEFD $ cTrabVincu .Or. (! SRA->RA_CATEFD $ cTrabVincu .And. ! lEmpDif ))
			lErroTaf := a180VerTaf(aLogTransf,cFilD,@cFilEnv, lGeraMat, If(lEmpDif, cEmpD,), If(lEmpDif, cFilD,))
		Endif
	EndIf

	If lErroTaf .Or. (SRA->RA_CATEFD $ cNTSV)
		(cAliasMark)->(dbSkip())
		Loop
	Endif

	//Verifica se a transferencia ocorre entre filiais da mesma empresa (raiz do CNPJ
	nFilD := aScan( aFilCNPJ, { |x| x[1] + x[2] == cEmpD + cFilD } )	//Empresa/Filial Origem
	nFilP := aScan( aFilCNPJ, { |x| x[1] + x[2] == cEmpP + cFilP } )	//Empresa/Filial Destino
	lCGC_Dif := nFilD > 0 .And. nFilP > 0 .And. ( SubStr(aFilCNPJ[nFilD,3],1,8) # SubStr(aFilCNPJ[nFilP,3],1,8) ) //Se CNPJS sao diferentes
	If nFilP > 0
		cTpInscPara := aFilCNPJ[nFilP, 4]
	EndIf

	//Gera os eventos de encerramento e inicio de vinculo, nas empresas origem e destino, respectivamente
	//A raiz do CNPJ precisa ser diferente (8 primeiros digitos)
	//---------------------------------------------------------------------------------------------------
	//REGRA PARA GERACAO DOS EVENTOS S-2299 E S-2200 ==> VALIDACAO DAS TABELAS C1E e CR9 do TAF
	//REGRA PARA GERACAO DOS EVENTOS S-2399 E S-2300
	//---------------------------------------------------------------------------------------------------
	//EMPRESA DESTINO CONFIGURADA => Se algum dos eventos falhar todos os eventos serao cancelados
	//EMPRESA DESTINO NAO CONFIGURADA => Gera somente o desligamento na empresa Origem
	//---------------------------------------------------------------------------------------------------
	If lTrfEmp .And. ( lEmpDif .Or. lFilDif ) .And. lCGC_Dif
		If !lMiddleware
			If SRA->RA_CATEFD $ cTrabVincu
				cStatDesl	:= TAFGetStat( "S-2299", AllTrim(SRA->RA_CIC) + ";" + AllTrim(SRA->RA_CODUNIC), , SRA->RA_FILIAL)
			Else
				cStatDesl	:= TAFGetStat( "S-2399", AllTrim(SRA->RA_CIC) + ";" + Space(Len(SRA->RA_CODUNIC)) + ";" + "1", , SRA->RA_FILIAL )
			EndIf
		Else
			fPosFil( cEmpAnt, SRA->RA_FILIAL )
			aInfos   := fXMLInfos()
			IF Len(aInfos) >= 4
				cTpInsc  := aInfos[1]
				lAdmPubl := aInfos[4]
				cNrInsc  := aInfos[2]
				cId  	 := aInfos[3]
			Else
				cTpInsc  := ""
				lAdmPubl := .F.
				cNrInsc  := "0"
			EndIf
			If SRA->RA_CATEFD $ cTrabVincu
				cChaveBus	:= cTpInsc + PADR( Iif( !lAdmPubl .And. cTpInsc == "1", SubStr(cNrInsc, 1, 8), cNrInsc), 14) + "S2299" + Padr(SRA->RA_CODUNIC, fTamRJEKey(), " ")
			Else
				cChaveBus	:= cTpInsc + PADR( Iif( !lAdmPubl .And. cTpInsc == "1", SubStr(cNrInsc, 1, 8), cNrInsc), 14) + "S2399" + Padr(AllTrim(SRA->RA_CIC) + AllTrim(SRA->RA_CATEFD) + dToS(SRA->RA_ADMISSA), fTamRJEKey(), " ")
			EndIf
			cStatDesl 	:= "-1"
			GetInfRJE( 2, cChaveBus, @cStatDesl )
			fPosFil( cEmpAnt, cFilAnt )
		EndIf

		lGeraInt := ( cStatDesl == "-1" .Or. SRA->RA_RESCRAI $ '30/31' )

		Begin Transaction

			//Identifica se o funcionário está desligado antes da transferência para gravar os dados da sucessão de vínculo
			If !lGeraInt .And. !Empty(SRA->RA_DEMISSA) .And. cTpDesl == "13" .And. cStatDesl == "4"

				//Inclui ou altera a sucessao de vinculo
				If lEmpDif
					fAbrEmpresa("RFZ", , cEmpP, cFilP)
					cAliasRFZ := "GPERFZ"
				EndIf

				lIncRFZ := !( (cAliasRFZ)->( dbSeek( cFilP + (cAliasMark)->(RE_MATP) + "4", .F.) ) )

				If (cAliasRFZ)->( RecLock((cAliasRFZ), lIncRFZ) )
					(cAliasRFZ)->RFZ_FILIAL	:= cFilP
					(cAliasRFZ)->RFZ_MAT	:= (cAliasMark)->(RE_MATP)
					(cAliasRFZ)->RFZ_CATEG	:= SRA->RA_CATEFD
					(cAliasRFZ)->RFZ_TPADM 	:= "4"
					(cAliasRFZ)->RFZ_INDADM	:= "1"
					(cAliasRFZ)->RFZ_INDPEM	:= "N"
					(cAliasRFZ)->RFZ_CNPJAN	:= aFilCNPJ[nFilD,3]
					(cAliasRFZ)->RFZ_MATANT	:= SRA->RA_CODUNIC
					(cAliasRFZ)->RFZ_DTADAN	:= SRA->RA_ADMISSA
					(cAliasRFZ)->RFZ_DTTRA	:= If(lRfzCmp, dDtTRF, Ctod("//"))
					(cAliasRFZ)->RFZ_TPINSC	:= If( Len(aFilCNPJ[nFilD,3]) == 11, "2", "1")

					(cAliasRFZ)->( MsUnLock() )
				EndIf

				If lEmpDif
					fFecEmpresa("RFZ")
				EndIf
			EndIf

			If lGeraInt
				RegToMemory("SRA",,,.F.)
				If FindFunction("fVersEsoc")
					fVersEsoc( IIF (SRA->RA_CATEFD $ cTrabVincu ,"S2299","S2399"), .F., /*aRetGPE*/, /*aRetTAF*/, @cVersEnvio, @cVersGPE )
				EndIf

				//Gera o evento S-2299 do Grupo/Empresa origem para indicar que o funcionario encerrou aquele vinculo
				cMsgErr	  := ""
				aVinc	  := {}
				IF SRA->RA_CATEFD $ cTrabVincu
					lGerouXml := fTrf2299( cTpDesl, If(Empty(cFilEnv), cFilD, cFilEnv), aFilCNPJ[nFilP,3], dDtTRF, cVersEnvio, @cMsgErr, cTpInscPara )
				ELSE
					lGerouXml := fTrf2399New( cTpDesl, If(Empty(cFilEnv), cFilD, cFilEnv), aFilCNPJ[nFilP,3], dDtTRF, cVersEnvio, @cMsgErr )
				ENDIF

				//Se o primeiro evento de desligamento foi gerado corretamente faz a geracao do evento S-2200 do Grupo/Empresa destino
				If lGerouXml
					IF SRA->RA_CATEFD $ cTrabVincu
						cErXML := "S-2200"

						If lMiddleware
							// Abre novamente as tabelas do grupo de empresas destino
							fPosFil( cEmpP, cFilP )
							If lEmpDif
								ChangeNew({"SR6", "SQ3", "SRJ", "SPA", "SPJ", "RJ9", "RJE"}, cEmpP, cFilP)
							EndIf
						EndIf
						If !lMiddleware
							If lEmpDif
								lTAFDest	:=  totvs.framework.company.getParameter(cEmpP,cFilP,"MV_RHTAF")
							Else
								lTAFDest	:= GetMv("MV_RHTAF")
							EndIf
						EndIf
						//Verifica se a empresa destino esta configurada para o e-Social
						If !lMiddleware .And. !Empty( fTafFilGpe( cEmpP + cFilP,,,!lEmpDif, cEmpP, @cFilS2200, cFilP) ) .AND. lTAFDest .oR.;
							lMiddleware .And. fVld1000( AnoMes(dDtTRF),,cFilP,cEmpP)
							//Dados da sucessao de vinculo
							Aadd( aVinc, {;
											If( cTpDesl == '11', '2', If( cTpDesl == '12', '3', If( cTpDesl == '43', '7', '4'))),;
											'1',;
											'N',;
											aFilCNPJ[nFilD,3],;
											SRA->RA_CODUNIC,;
											SRA->RA_ADMISSA,;
											"",;
											If( cVersEnvio >= "2.4" .And. lRfzCmp, dDtTRF, Ctod("//")),;
											aFilCNPJ[nFilD,4]})

							If FindFunction("fVersEsoc")
								fVersEsoc( "S2200", .F., /*aRetGPE*/, /*aRetTAF*/, @cVersEnvio, @cVersGPE, .T. )
							EndIf

							If lEmpDif
								If !lMiddleware
									// Abre as tabelas do grupo de empresas destino
									ChangeNew({"SR6", "SQ3", "SRJ", "SPA", "SPJ"}, cEmpP, cFilP)
								EndIf
								fAbrEmpresa("SRA", , cEmpP, cFilP)

								cArqSR6 := "SR6"
								cArqSRJ := "SRJ"
								cArqSQ3 := "SQ3"
								cArqSRA := "GPESRA"

								cFilAnt := cFilP

								cSR6Fil :=  totvs.framework.company.xEmpFil("SR6", cEmpP, cFilP)
								cSRJFil :=  totvs.framework.company.xEmpFil("SRJ", cEmpP, cFilP)
								cSQ3Fil :=  totvs.framework.company.xEmpFil("SQ3", cEmpP, cFilP)
							Else
								cArqSR6 := "SR6"
								cArqSRJ := "SRJ"
								cArqSQ3 := "SQ3"
								cArqSRA := "SRA"
							EndIf

							//Posiciona no registro da SRA destino e carrega as variáveis de memória
							(cArqSRA)->(DbSeek(cFilP + (cAliasMark)->(RE_MATP)))
							RegToMemory(cArqSRA,,.F.,.F.)

							//Gera novo codigo unico para o Grupo/Empresa destino
							If !(cEmpP+cFilP $ (cArqSRA)->RA_CODUNIC)
								cCodUnic := cEmpP
								cCodUnic += cFilP + (cAliasMark)->RE_MATP
								cCodUnic += dToS(Date())
								cCodUnic += StrTran(Time(),':')
								//Limita ao tamanho do campo para nao gerar problema na integracao
								If Len(cCodUnic) > nTamCod
									cCodUnic := SubStr( cCodUnic, 1, nTamCod )
								EndIf
								lGrvCodUn := .T.
							Else
								cCodUnic := (cArqSRA)->RA_CODUNIC
							EndIf

							lGerouXml := fIntAdmiss(cArqSRA,,3,"S2200", If(Empty(cFilS2200), cFilP, cFilS2200), , cCodUnic, ,"ADM", @aErr2200, cVersEnvio, , , ,cFilP, , aVinc, cFilD ,.F., (cAliasMark)->(RE_CCP), cArqSR6, cSR6Fil, cEmpP, cArqSRJ, cSRJFil, cArqSQ3, cSQ3Fil, Nil, Nil, .T.)
						EndIf
						If lEmpDif
							// Abre novamente as tabelas do grupo de empresas origem
							If lMiddleware
								//Retorna para a empresa e filial logada inicialmente
								ChangeNew({"SR6", "SQ3", "SRJ", "SPA", "SPJ", "RJ9", "RJE"}, cEmpD, cFilD)
							Else
								ChangeNew({"SR6", "SQ3", "SRJ", "SPA", "SPJ"}, cEmpD, cFilD)
							EndIf
						EndIf
						If lMiddleware
							fPosFil( cEmpD, cFilD )
						EndIf
					ELSE
						If lMiddleware
							fPosFil( cEmpP, cFilP )
							If lEmpDif
								// Abre as tabelas do grupo de empresas destino
								ChangeNew({"SR6", "SQ3", "SRJ", "SPA", "SPJ", "RJ9", "RJE"}, cEmpP, cFilP)
							EndIf
						EndIf
						If !lMiddleware
							If lEmpDif
								lTAFDest	:=  totvs.framework.company.getParameter(cEmpP,cFilP,"MV_RHTAF")
							Else
								lTAFDest	:= GetMv("MV_RHTAF")
							EndIf
						EndIf
						//Verifica se a empresa destino esta configurada para o e-Social
						If !lMiddleware .And. !Empty( fTafFilGpe( cEmpP + cFilP,,,!lEmpDif, cEmpP, @cFilS2200, cFilP) ) .AND. lTAFDest .oR.;
							lMiddleware .And. fVld1000( AnoMes(dDtTRF),,cFilP,cEmpP)

							If FindFunction("fVersEsoc")
								fVersEsoc( "S2300", .F., /*aRetGPE*/, /*aRetTAF*/, @cVersEnvio, @cVersGPE, /*cVersMW*/, /*lNT15*/, /*cGpeAmbe*/,  cEmpP, cFilP)
							EndIf

							If lEmpDif
								If !lMiddleware
									// Abre as tabelas do grupo de empresas destino
									ChangeNew({"SR6", "SQ3", "SRJ", "SPA", "SPJ"}, cEmpP, cFilP)
								EndIf
								fAbrEmpresa("SRA", , cEmpP, cFilP)

								cArqSR6 := "SR6"
								cArqSRJ := "SRJ"
								cArqSQ3 := "SQ3"
								cArqSRA := "GPESRA"

								cSR6Fil :=  totvs.framework.company.xEmpFil("SR6", cEmpP, cFilP)
								cSRJFil :=  totvs.framework.company.xEmpFil("SRJ", cEmpP, cFilP)
								cSQ3Fil :=  totvs.framework.company.xEmpFil("SQ3", cEmpP, cFilP)
							Else
								cArqSRA := "SRA"
							EndIf

							If cVersEnvio >= "9.0" .And. lMatTSV
								//Posiciona no registro da SRA destino e carrega as variáveis de memória
								(cArqSRA)->(DbSeek(cFilP + (cAliasMark)->(RE_MATP)))
								RegToMemory(cArqSRA,,.F.,.F.)

								//Gera novo codigo unico para o Grupo/Empresa destino
								If !(cEmpP+cFilP $ (cArqSRA)->RA_CODUNIC)
									cCodUnic := cEmpP
									cCodUnic += cFilP + (cAliasMark)->RE_MATP
									cCodUnic += dToS(Date())
									cCodUnic += StrTran(Time(),':')
									//Limita ao tamanho do campo para nao gerar problema na integracao
									If Len(cCodUnic) > nTamCod
										cCodUnic := SubStr( cCodUnic, 1, nTamCod )
									EndIf
									lGrvCodUn := .T.
								Else
									cCodUnic := (cArqSRA)->RA_CODUNIC
								EndIf
								cGeraMat := "1"
							EndIf

							If Len(GetAPOInfo("TafTransfTrab.prw")) > 0
								lTAFTransf := .T. //Indica que o TAF está atualizado com a refatoração da transferência.
							EndIf

							lGerouXml := fInt2300New("SRA",/*lAltCad*/,3,"S2300",If(Empty(cFilS2200) .Or. !lTAFTransf, cFilP, cFilS2200),/*aDadosXml*/,cVersEnvio,/*lCadEst*/, /*oMdlRFS*/,@aErr2200,/*aFilial*/,/*oMdlRFZ*/,cFilD, Nil, .F., cEmpP, cGeraMat, cCodUnic)
							lS2300	  := lGerouXml
							cErXML := "S-2300"

						EndIf
						If lEmpDif
							// Abre novamente as tabelas do grupo de empresas origem
							If lMiddleware
								//Retorna para a empresa e filial logada inicialmente
								ChangeNew({"SR6", "SQ3", "SRJ", "SPA", "SPJ", "RJ9", "RJE"}, cEmpD, cFilD)
							Else
								ChangeNew({"SR6", "SQ3", "SRJ", "SPA", "SPJ"}, cEmpD, cFilD)
							EndIf
						EndIf
						If lMiddleware
							fPosFil( cEmpD, cFilD )
						EndIf
					ENDIF
				Else
					IF SRA->RA_CATEFD $ cTrabVincu
						cErXML := "S-2299"
					ELSE
						cErXML := "S-2399"
					ENDIF
				EndIf

				If !lGerouXml
					IF SRA->RA_CATEFD $ cTrabVincu
						cMsgLogXML := Iif(!lMiddleware, STR0248, STR0302) //"eSocial: Não foi possivel integrar ao TAF os eventos: S-2299 e S-2200. Verifique no TAF os dados da empresa destino."#"eSocial: Não foi possivel integrar ao Middleware os eventos: S-2299 e S-2200. Verifique no Middleware os dados da empresa destino."
					Else
						cMsgLogXML := Iif(!lMiddleware, STR0315, STR0316) //"eSocial: Não foi possivel integrar ao TAF os eventos: S-2399 e S-2300. Verifique no TAF os dados da empresa destino."#"eSocial: Não foi possivel integrar ao Middleware o evento: S-2399"
					EndIf
					aAdd( aLogTransf , Space(5) + cEmpAnt + " " + cFilD + " " + SRA->RA_MAT + " - " + SRA->RA_NOME )
					aAdd( aLogTransf , Space(5) + cMsgLogXML  )
					ConsLog(@aLogTransf,@aErr2200)
					If !Empty(cMsgErr)
						aAdd( aLogTransf , Space(5) + cMsgErr  )
					EndIf
					DisarmTransaction()
					break
				Else

					//Chama função para gravação do campo RE_INTGTAF
					If lDataTAF
						fGrvSREOff((cAliasMark)->(RE_EMPD),(cAliasMark)->(RE_FILIALD),(cAliasMark)->(RE_MATD),dtos((cAliasMark)->(RE_DATA)) )
					EndIf
					IF  SRA->RA_CATEFD $ cTrabVincu
						If Len( aVinc ) > 0

							//Inclui ou atualiza a sucessao de vinculo
							If lEmpDif
								fAbrEmpresa("RFZ",,cEmpP, cFilP)
								cAliasRFZ := "GPERFZ"
							EndIf

							(cAliasRFZ)->(DbSetOrder(1))
							lIncRFZ := !( (cAliasRFZ)->( dbSeek( cFilP + (cAliasMark)->(RE_MATP) + aVinc[1,1],.F.) ) )

							(cAliasRFZ)->( RecLock((cAliasRFZ),lIncRFZ) )
							(cAliasRFZ)->RFZ_FILIAL	:= cFilP
							(cAliasRFZ)->RFZ_MAT	:= (cAliasMark)->(RE_MATP)
							(cAliasRFZ)->RFZ_CATEG	:= SRA->RA_CATEFD
							(cAliasRFZ)->RFZ_TPADM 	:= aVinc[1,1]
							(cAliasRFZ)->RFZ_INDADM	:= aVinc[1,2]
							(cAliasRFZ)->RFZ_INDPEM	:= aVinc[1,3]
							(cAliasRFZ)->RFZ_CNPJAN	:= aVinc[1,4]
							(cAliasRFZ)->RFZ_MATANT	:= aVinc[1,5]
							(cAliasRFZ)->RFZ_DTADAN	:= aVinc[1,6]
							(cAliasRFZ)->RFZ_DTTRA	:= aVinc[1,8]
							(cAliasRFZ)->RFZ_TPINSC	:= aVinc[1,9]
							(cAliasRFZ)->( MsUnLock() )

							If lEmpDif
								fFecEmpresa("RFZ")
							EndIf

							If lGrvCodUn
								If RecLock( (cArqSRA), .F. )
									(cArqSRA)->RA_CODUNIC := cCodUnic
									(cArqSRA)->( MsUnlock() )
								EndIf
							EndIf

							cMsgLog := Iif(!lMiddleware, STR0244, STR0299) //"XML enviado ao TAF com sucesso"#"XML enviado ao Middleware com sucesso"
							aAdd( aLogTransf , Space(5) + cEmpAnt + " " + cFilD + " " + SRA->RA_MAT + " - " + SRA->RA_NOME )
							aAdd( aLogTransf , Space(5) + cMsgLog  )
							aAdd( aLogTransf , "" )
						Else
							//Foi gerado somente o evento de desligamento na origem
							aAdd( aLogTransf , ""  )
							aAdd( aLogTransf , Space(5) + cEmpAnt + " " + cFilD + " " + SRA->RA_MAT + " - " + SRA->RA_NOME )
							cMsgLog := Iif(!lMiddleware, STR0247, STR0301) //"Evento S-2299 enviado ao TAF com sucesso."#"Evento S-2299 enviado ao Middleware com sucesso."
							aAdd( aLogTransf , Space(5) + cMsgLog  )
							cMsgLog := Iif(!lMiddleware, STR0246, STR0300) //"Evento S-2200 enviado ao TAF sem sucesso. Não foram localizados no TAF os dados da empresa destino."#"Evento S-2200 enviado ao Middleware sem sucesso. Não foram localizados no Middleware os dados da empresa destino."
							aAdd( aLogTransf , Space(5) + cMsgLog  )
							aAdd( aLogTransf , "" )
						EndIf
					Else
						If lS2300
							If cVersEnvio >= "9.0" .And. lMatTSV
								If RecLock( (cArqSRA), .F. )
									(cArqSRA)->RA_DESCEP := cGeraMat
									If lGrvCodUn //verificar se precisa
										(cArqSRA)->RA_CODUNIC := cCodUnic
									EndIf
									(cArqSRA)->( MsUnlock() )
								EndIf
							EndIf

							cMsgLog := Iif(!lMiddleware, STR0244, STR0299) //"XML enviado ao TAF com sucesso"#"XML enviado ao Middleware com sucesso"
							aAdd( aLogTransf , Space(5) + cEmpAnt + " " + cFilD + " " + SRA->RA_MAT + " - " + SRA->RA_NOME )
							aAdd( aLogTransf , Space(5) + cMsgLog  )
							aAdd( aLogTransf , "" )
						Else
							//Foi gerado somente o evento de desligamento na origem
							aAdd( aLogTransf , ""  )
							aAdd( aLogTransf , Space(5) + cEmpAnt + " " + cFilD + " " + SRA->RA_MAT + " - " + SRA->RA_NOME )
							cMsgLog := Iif(!lMiddleware, STR0311, STR0312) //"Evento S-2399 enviado ao TAF com sucesso."#"Evento S-2399 enviado ao Middleware com sucesso."
							aAdd( aLogTransf , Space(5) + cMsgLog  )
							cMsgLog := Iif(!lMiddleware, STR0313, "") //"Evento S-2300 enviado ao TAF sem sucesso. Não foram localizados no TAF os dados da empresa destino."
							aAdd( aLogTransf , Space(5) + cMsgLog  )
							aAdd( aLogTransf , "" )
						EndIf
					ENDIF
				Endif
			EndIf
		End Transaction
	EndIf

	Begin Transaction // validação do middleware/MDT devem esta na mesma transaction do 2200 para deixar sujeira na tabela de integração caso a validação do MDT aborte a operação

		// Realizar a alteração contratual apenas se mudou de filial com a mesma raiz de CNPJ
		If !lCGC_Dif .And. (lFilDif .Or. lObraTot) .And. (lIntTAF .Or. lMiddleware)
				cErXML := ""
				If aTpAlt[3]
					RegToMemory("SRA",,,.F.)
					nSraRec	:= SRA->( Recno() )
					If (lFilDif .Or. lEmpDif)

						//Se os dados da empresa e filial de origem estiveram na chave guarda para posteiror ajuste
						If (cEmpd+cFild $ M->RA_CODUNIC)
							cNewCodUnic	:= M->RA_CODUNIC
						EndIf

						If SRA->( dbSeek(cFilP + (cAliasMark)->RE_MATP) )
							RegToMemory("SRA",,,.F.)
						Else
							SRA->( dbGoTo( nSraRec ) )
						EndIf

						//Ajusta codigo unico caso o código do grupo + filial for diferente.
						If !Empty(cNewCodUnic) .And. !(cEmpd+cFild $ M->RA_CODUNIC) .And. cNewCodUnic <> M->RA_CODUNIC
							If RecLock( ("SRA"), .F. )
								SRA->RA_CODUNIC := cNewCodUnic
								SRA->( MsUnlock() )
								RegToMemory("SRA",,,.F.)
							EndIf
						EndIf

						IF !fCheck2206(cFilD, cFilP)
							IF SRA->RA_CATEFD $ cTrabVincu
								lGerouXml := fIntAdmiss("SRA"    , NIL    , 0    ,"S2200", cFilP   , NIL , NIL   , NIL   , NIL    , @aErr2200, cVersEnvio, NIL    , NIL    , NIL    , cFilP  , NIL   , NIL  , cFilD , .F.    , (cAliasMark)->(RE_CCP), , , cEmpP, , , , )
								cErXML := "S-2200"
							ELSEIF !lEmpDif
								lGerouXml := fInt2300New("SRA",/*lAltCad*/,1,"S2300",cFilP,/*aDadosXml*/,cVersEnvio,/*lCadEst*/, /*oMdlRFS*/,@aErr2200,/*aFilial*/,/*oMdlRFZ*/,cFilD, Nil, .F., , , , , cFilD)
								cErXML := "S-2300"
							ENDIF
						EndIf
					Endif
					If lGerouXML .Or. lObraTot .Or. fCheck2206(cFilD, cFilP)
						IF SRA->RA_CATEFD $ cTrabVincu
							cBkpFil	  := cFilAnt
							cFilAnt	  := cFilP
							lGerouXml := fInt2206("SRA",, 3, "S2206", cFilP,,,,,, cVersEnvio,, dDtTRF, .T., (cAliasMark)->(RE_CCP), @aErr2206, .F., .T.)
							cFilAnt	  := cBkpFil
							cErXML += If( Empty(cErXML), "S-2206", " / S-2206" )
						ELSEIF !lEmpDif .And. cVersEnvio >= "9.2" .And. dDtTRF >= CToD("22/01/2024") .And. FindFunction("fLocalTrab") .And. fLocalTrab(SRA->RA_CATEFD)
							cBkpFil	  := cFilAnt
							cFilAnt	  := cFilP
							lGerouXml := fInt2306New("SRA",/*lAltCad*/,3,"S2306",cFilP,/*dtEf*/,cVersEnvio,/*lCadEst*/,/*oMdlRFS*/,.T., dDtTRF, .T.,@aErr2306 , .F., cFilD)
							cFilAnt	  := cBkpFil
							cErXML += If( Empty(cErXML), "S-2306", " / S-2306" )
						ENDIF
					Endif
				Else
					cErXML += If( SRA->RA_CATEFD $ cTrabVincu, "S-2200", " / S-2300" )
					cMsgLogXML := STR0214 + cErXML   //"eSocial: Não foi possível gerar o XML para o evento: cErXML, podendo ser < S-2200 , S-2100 ou S-2206 >
					aAdd( aLogTransf , Space(5) + cEmpAnt + " " + cFilD + " " + SRA->RA_MAT + " - " + SRA->RA_NOME )
					aAdd( aLogTransf , Space(5) + cMsgLogXML  )
					aAdd( aLogTransf , Space(5) + Iif(!lMiddleware, STR0280, STR0291) )//"Não será possível integrar com o TAF pois o registro de Admissão ou Carga Inicial deste funcionário ainda não foi efetivado no TAF."#"Não será possível integrar com o Middleware pois o registro de Admissão ou Carga Inicial deste funcionário ainda não foi efetivado."
					lGerouXml := .F.
					DisarmTransaction()
					Break
				Endif

				If !lGerouXml
					cMsgLogXML := STR0214 + cErXML   //"eSocial: Não foi possível gerar o XML para o evento: cErXML, podendo ser < S-2200 , S-2100 ou S-2206 >
					aAdd( aLogTransf , Space(5) + cEmpAnt + " " + cFilD + " " + SRA->RA_MAT + " - " + SRA->RA_NOME )
					aAdd( aLogTransf , Space(5) + cMsgLogXML  )
					If Len( aErr2200 ) > 0
						FeSoc2Err( aErr2200[1], @cMsgErro , Iif( aErr2200[1] != '000026',1,2 ) )
						FrmTexto(@cMsgErro)
						aErr2200[1] := cMsgErro
						aAdd( aLogTransf, cMsgErro)
					EndIf
					If Len( aErr2206 ) > 0
						FeSoc2Err( aErr2206[1], @cMsgErro , Iif( aErr2206[1] != '000026',1,2 ) )
						FrmTexto(@cMsgErro)
						aErr2206[1] := cMsgErro
						aAdd( aLogTransf, cMsgErro)
					EndIf
					If Len( aErr2306 ) > 0
						FeSoc2Err( aErr2306[1], @cMsgErro , Iif( aErr2306[1] != '000026',1,2 ) )
						FrmTexto(@cMsgErro)
						aErr2306[1] := cMsgErro
						aAdd( aLogTransf, cMsgErro)
					EndIf
					DisarmTransaction()
					break
				Else
					//Chama função para gravação do campo RE_INTGTAF
					If lDataTAF
						fGrvSREOff((cAliasMark)->(RE_EMPD),(cAliasMark)->(RE_FILIALD),(cAliasMark)->(RE_MATD),dtos((cAliasMark)->(RE_DATA) ))
					EndIf

					cMsgLog := Iif(!lMiddleware, STR0250, STR0304) + "(" + cErXML + ")" //"Eventos(s) enviado(s) ao TAF com sucesso: "#"Eventos(s) enviado(s) ao Middleware com sucesso: "
					aAdd( aLogTransf , Space(5) + cEmpAnt + " " + cFilD + " " + SRA->RA_MAT + " - " + SRA->RA_NOME )
					aAdd( aLogTransf , Space(5) + cMsgLog     )
					aAdd( aLogTransf , "" )
				Endif
		Endif

		//Integracao SIGAMDT -> SIGATAF/Middleware
		If lMdtGPE .And. FindFunction( "MDTIntEsoc" ) .And. leSocMDT .And. ( lIntTAF .Or. lMiddleware )

				cFuncAte := SRA->RA_CODFUNC
				cCargoAte := SRA->RA_CARGO

				//Busca o código único
				If !Empty( cNewCodUnic )
					cCodUniMDT := cNewCodUnic
				ElseIf !Empty( cCodUnic )
					cCodUniMDT := cCodUnic
				Else
					cCodUniMDT := SRA->RA_CODUNIC //Caso não tenha um novo código unico a ser considerado, pega o da memória
				EndIf

				//Adiciona as informações da transferência ao array a ser utilizado no SIGAMDT
				aAdd( aInfMDT, { dDtTRF, cEmpD, cEmpP, cFilD, cFilP, ( cAliasMark )->RE_MATD, ( cAliasMark )->RE_MATP, ( cAliasMark )->RE_CCD, ( cAliasMark )->RE_CCP, ( cAliasMark )->RE_DEPTOD, ( cAliasMark )->RE_DEPTOP, cFuncAte, cCargoAte, cCodUniMDT } )

				//Integra o evento S-2240 com o SIGATAF/Middleware
				lGerouXml := MDTIntEsoc( "S-2240", 4, , { { ( cAliasMark )->RE_MATD, , , , , , aInfMDT } }, .T., , , @cLogMDT )

				//Zera a variável para validação do próximo funcionário do laço
				aInfMDT := {}

				//Define a variável para o evento S-2240
				cErXML += IIf( Empty( cErXML ), "S-2240", " / S-2240" )

				If !lGerouXml
					//Limpa a variavel de integracao
					aAdd( aLogTransf, Space( 5 ) + cEmpAnt + " " + cFilD + " " + SRA->RA_MAT + " - " + SRA->RA_NOME )
					aAdd( aLogTransf, Space( 5 ) + STR0214 + cErXML ) //"eSocial: Nao foi possivel gerar o XML para o evento: cErXML, podendo ser < S-2200 , S-2100, S-2206 ou S-2240>
					aAdd( aLogTransf, '' )
					aAdd( aLogTransf, cLogMDT )

					aAdd( aLogTransf, '' )
					cLogMDT := ""
					DisarmTransaction()
					Break
				Else
					aAdd( aLogTransf, Space( 5 ) + cEmpAnt + " " + cFilD + " " + SRA->RA_MAT + " - " + SRA->RA_NOME )
					aAdd( aLogTransf, Space( 5 ) + IIf( !lMiddleware, STR0250, STR0304 ) + "(" + cErXML + ")" ) //"Eventos(s) enviado(s) ao TAF com sucesso: "#"Eventos(s) enviado(s) ao Middleware com sucesso:"
					cLogMDT := ""
				EndIf
		EndIf

	End Transaction

	(cAliasMark)->(dbSkip())
EndDo

IF !Empty( aLogTransf )
	// "Log de Ocorrencias"
	bMkLog := { || fMakeLog( { aLogTransf } ,;
	{ STR0073 } ,;
	NIL , .T. , FunName() , NIL , "G" , "L" , NIL , NIL ) }
	MsAguarde( bMkLog , OemToAnsi( STR0073 ) )
EndIF


cFilAnt := cSavFilAnt
RestArea(aArea)

Return .T.

/*/{Protheus.doc} Gpa180CC()
Função responsável por verificar se quando houver troca de centro de custo este centro de custo é uma obra total,
neste caso seria necessário o envio do evento S-2206 ao TAF
@type function
@author Claudinei Soares
@since 24/05/2018
@version 2.0
@param cFilOri, characters, Filial Origem. Default: cFilD - Variável private
@param cCCOri, characters, Centro de Custo Origem. Default: cCcDe - Variável private
@param cFilDes, characters, Filial Destino. Default: cFilAte - Variável private
@param cCCDes, characters, Centro de Custo Destino. Default: cCcuAte - Variável private
@return lRet, Lógico, Se verdadeiro o centro de custo é uma obra total
@history 23/08/2018, Cícero Alves, Inclusão dos parâmetros
/*/
Function Gpa180CC(cFilOri, cCCOri, cFilDes, cCCDes)

	Local lRet		:= .F.
	Local aArea		:= GetArea()

	Default cFilOri := cFilDe
	Default cFilDes := cFilAte
	Default cCCOri	:= cCcDe
	Default cCCDes	:= cCcuAte

	dbSelectArea("CTT")
	CTT->( dbSetOrder(1) )

	If CTT->( dbSeek( xFilial('CTT', cFilOri) + cCCOri ) )
		If CTT->CTT_TPLOT = "01" .And. CTT->CTT_TIPO2 = "4" .And. !Empty(CTT->CTT_CEI2)
			lRet := .T.
		Endif
	Endif

	If !lRet .AND. CTT->( dbSeek(xFilial("CTT", cFilDes) + cCCDes) )
		If CTT->CTT_TPLOT = "01" .And. CTT->CTT_TIPO2 = "4" .And. !Empty(CTT->CTT_CEI2)
			lRet := .T.
		Endif
	Endif

	RestArea(aArea)

Return( lRet )

/*/{Protheus.doc} CONSLOG
Consolida informações de log para exibição final.
@type function
@author Eduardo
@since 06/06/2018
@version 1.0
@param aLogTransf, array, Log final para apresentar para o usuário
@return aLogRetTaf, Log de Retorno do TAF
/*/
Static Function ConsLog(aLogTransf,aLogRetTaf)
Local nErros		:= 0

Default aLogTransf	:= {}
Default aLogRetTaf	:= {}

If Len(aLogRetTaf) > 0
	aAdd( aLogTransf , " ")
	For nErros := 1 To Len(aLogRetTaf)
		aAdd( aLogTransf , Space(5) + aLogRetTaf[nErros])
	Next nErros
	aLogRetTaf := Array(0) //Elimina as informacoes para nao duplicar dados de outras matriculas
	aAdd( aLogTransf , " ")
EndIf
Return .T.

/*/{Protheus.doc} fTafFilGpe

Funcao para retornar a filial para onde as informacoes de integracao serao
importadas

@param
	cSeekFil  - CNPJ ou Filial a ser verificada a existencia
	aIncons   - Array contendo as inconsistencias encontradas
	cAliasTAF - Alias que esta em processamento. Parametro utilizado
			    para indetificar as tabelas que estão compartilhadas
			    no sistema.

@return
	cFilTAF - Filial de Referencia do TAF

@author Rodrigo Aguilar
@since 23/09/2013
@version 1.0
/*/
//-------------------------------------------------------------------
Function fTafFilGpe( cSeekFil, aIncons, cAliasTAF, lEmpLog, cSeekEmp, cFilTAF, cOnlyFil)

Local cFilTAF	:=	""
Local cIdCR9	:=	""
Local cTabC1E	:= "GPEC1E"
Local cTabCR9	:= "GPECR9"
Local cFilBsc	:= ""

Default cSeekFil 	:= ""	// Empresa + Filial
Default	aIncons		:=	{}
Default	cAliasTAF	:=	""
Default lEmpLog		:= .F.
Default cSeekEmp 	:= ""
Default cFilTAF		:= ""
Default	cOnlyFil	:= ""	// Somente  a Filial

If lEmpLog
	cTabC1E	:= "C1E"
	cTabCR9	:= "CR9"
EndIf

If !Empty(cSeekEmp)
	fAbrEmpresa("C1E", 1, cSeekEmp, cSeekFil)
	fAbrEmpresa("CR9", 1, cSeekEmp, cSeekFil)
EndIf

//Caso a tabela seja compartilhada no nivel de filial, devo utilizar o xFilial ao invés do
//conteudo cadastro no Complemento de Empresa.
If !Empty( cAliasTAF ) .And. FWModeAccess( cAliasTAF ) == "C"
	cFilTAF	:=	xFilial( cAliasTAF )
Else
	//Validação para verificar se existe C1E ( De/Para ) para
	//a filial em que as informações serão importadas
	If (cTabC1E)->( IndexOrd() ) <> 7
		(cTabC1E)->( DBSetOrder( 7 ) )
	EndIf

	cFilBsc	:= If (lEmpDif, totvs.framework.company.xEmpFil("C1E", cSeekEmp, cOnlyFil) , xFilial( "C1E" ))

	If (cTabC1E)->( MsSeek( cFilBsc + PadR( cSeekFil, TamSX3( "C1E_CODFIL" )[1] ) + "1" ) )
		cFilTAF := (cTabC1E)->C1E_FILTAF
	Else
		//Tratamento para que quando a informação de filial de importação
		//esteja na tabela CR9 ela seja utilizada na integração
		(cTabCR9)->( DBSetOrder( 2 ) )
		(cTabCR9)->( DBGoTop() )

		While (cTabCR9)->( !Eof() )
			//If CR9->( MsSeek( xFilial( "CR9" ) + PadR( cSeekFil, TamSX3( "CR9_CODFIL" )[1] ) + "1" ) )
			If (cTabCR9)->CR9_CODFIL == PadR( cSeekFil, TamSX3( "CR9_CODFIL" )[1] ) .And. (cTabCR9)->CR9_ATIVO == '1'
				cIdCR9 := (cTabCR9)->CR9_ID

				(cTabC1E)->( DBSetOrder( 5 ) )
				If (cTabC1E)->( MsSeek( cFilBsc + cIdCR9 + "1" ) )
					cFilTAF := (cTabC1E)->C1E_FILTAF
					Exit
				EndIf
			EndIf
			(cTabCR9)->(dbSkip())
		EndDo
	EndIf
Endif

If !Empty(cSeekEmp)
	fFecEmpresa("C1E")
	fFecEmpresa("CR9")
EndIf

Return( cFilTAF )

/*/{Protheus.doc} fCheck2206
Função responsável por verificar se o complemento de empresas está 1x1 ou 1xN, ou e se é 1xN e a C9V está com a filial compartilhada.
Nesses 2 casos para uma transferência entre filiais não deverá ser gerado o evento S-2200 na filial de destino, somente o evento S-2206.
@author Claudinei
@since 25/06/2018
@version 1.0
/*/
Function fCheck2206(cFilDe, cFilAte)

Local cFilT		:= ""
Local lRet 		:= .F.
Local aFilTaf 	:= {}
Local aFilT		:= {}
Local nX		:= 0

Default cFilDe	:= ""
Default cFilAte	:= ""

If !lMiddleware
	If !Empty(cFilDe) .And. !Empty(cFilAte)
		aFilT := {cFilDe, cFilAte}
	EndIf

	fGp23Cons(@aFilTaf, @aFilT,@cFilT)

	For nX := 1 To Len(aFilTaf)
		If FWModeAccess("C9V", 3) == "C" .Or. aScan( aFilTaf[nX, 3], { |x| x == cFilDe } ) > 0 .And. aScan( aFilTaf[nX, 3], { |x| x == cFilAte } ) > 0
			lRet := .T.
			Exit
		EndIf
	Next nX
Else
	lRet := .T.
EndIf

Return lRet



/*/{Protheus.doc} fLoadVarMem
Função responsável por carregar para as variaveis de memoria os campos da aba dados cadastrais na geracao dos eventos do eSocial.
@author M. Silveira
@since 28/06/2018
@version 1.0
/*/
Static Function fLoadVarMem( nPosRec, nRecno )

	Local nX	:= 0
	Local nPos  := 0

	If nPosRec > 0
		If ( nPos := aScan( aTransf1Cols, { |x| x[nPosRec] == nRecno } ) ) > 0
			IF lRobo
				For nX := 1 To Len(aTransf1Header)
					SetMemVar( aTransf1Header[nX, 02], aTransf1Cols[nPos, nX] )
				Next nX
			ELSE
				For nX := 1 To Len(oGetSRA21:aHeader)
					SetMemVar( oGetSRA21:aHeader[nX, 02], aTransf1Cols[nPos, nX] )
				Next nX
			ENDIF
		EndIf
	EndIf

Return()

Static Function fSalvHstSal(dRaDataAlt,cTipAum,nSalario,nSalarAnt,nSraOrder,lIntTAFok)
	Local aArea 		:= GetArea()
	Local aAreaSRA		:= SRA->( GetArea() )

	Default lIntTAFok	:= .F.

	If cEmpAnt != cEmpAte
		EmpChangeTable( "SRA" , cEmpAte , __cSvEmpAnt , nSraOrder )
		EmpChangeTable( "SR3" , cEmpAte , __cSvEmpAnt , nSraOrder )
		EmpChangeTable( "SR7" , cEmpAte , __cSvEmpAnt , nSraOrder )
		EmpChangeTable( "SRJ" , cEmpAte , __cSvEmpAnt , nSraOrder )
		EmpChangeTable( "SQ3" , cEmpAte , __cSvEmpAnt , nSraOrder )

		SRA->(dbSeek(cFilAte+cMatAte))
		fGravaSr3(dRaDataAlt,cTipAum,nSalario,Nil,Nil,Nil,nSalarAnt,lIntTAFok)

		EmpChangeTable( "SRA" , __cSvEmpAnt , cEmpAte , nSraOrder )
		EmpChangeTable( "SR3" , __cSvEmpAnt , cEmpAte , nSraOrder )
		EmpChangeTable( "SR7" , __cSvEmpAnt , cEmpAte , nSraOrder )
		EmpChangeTable( "SRJ" , __cSvEmpAnt , cEmpAte , nSraOrder )
		EmpChangeTable( "SQ3" , __cSvEmpAnt , cEmpAte , nSraOrder )
	Else
		SRA->(dbSeek(cFilAte+cMatAte))
		fGravaSr3(dRaDataAlt,cTipAum,nSalario,Nil,Nil,Nil,nSalarAnt,lIntTAFok)
	EndIf


	RestArea( aArea )
	RestArea( aAreaSRA )
Return()

//-------------------------------------------------------------------
/*/{Protheus.doc} fTransfExt
Função responsável por realizar transferência de funcionários para empresas
que não fazem parte do ambiente protheus, gerando evento S-2299 (Desligamento)
e atualizando cadastro de funcionários
@author  Rafael Reis
@since   16/08/18
@version 1
/*/
//-------------------------------------------------------------------
Function fTransfExt(cTable, nOpcRot, aAutoParam, lRobo)
Local aSays			:= {}
Local aButtons 		:= {}
Local aLogs			:= { {}, {} }
Local aTitle		:= {STR0322, STR0323}//"Funcionários processados com sucesso"##"Funcionários processados com erro"
Local aFils			:= FWLoadSM0()
Local cPerg			:= "GP180EXT"
Local nOpcA		  	:= 0.00
Local cCnpjDest		:= ""
Local cTipoRes		:= ""
Local cMsgErr		:= ""
Local cRescRais		:= ""
Local cAfasfgts		:= ""
Local cCdEFD		:= ""
Local cTpInscDest	:= ""
Local cAlias    	:= GetNextAlias()
Local cExpFiltro	:= ""
Local cQuery		:= ""
Local cLastFil		:= ""
Local dDataDesl
Local lGerouXml		:= .F.
Local nI
Local nPosFil		:= 0
Local lAcesFil		:= .F.

Default cTable		:= ""
Default nOpcRot		:= 1
Default aAutoParam	:= {}
Default lRobo	:= .F.

Private dDataRes 	:= SToD("")

If FindFunction("fVersEsoc")
    fVersEsoc( "S2299", .F., /*aRetGPE*/, /*aRetTAF*/, @cVersEnvio, @cVersGPE )
EndIf

Pergunte(cPerg, .F.)
If !lRobo
	Aadd(aSays, OEMToAnsi(STR0273)) // "Essa rotina deve ser utilizada nos casos onde o funcionário será transferido"
	Aadd(aSays, OEMToAnsi(STR0274)) // "para uma empresa que não faz parte do ambiente Protheus existente."
	Aadd(aSays, OEMToAnsi(STR0275)) // "O cadastro de funcionários será atualizado de acordo com o tipo de rescisão e será"
	Aadd(aSays, OEMToAnsi(STR0276)) // "gerado um evento de desligamento com sucessão de vínculo para o CNPJ/CPF informado."

	aAdd(aButtons, { 17,.T.,{|| GpFltBldExp( "SRA" , NIL , @cExpFiltro , NIL ) }   } )
	aAdd(aButtons, { 5,.T.,{|| Pergunte(cPerg,.T. ) } } )
	aAdd(aButtons, { 1,.T.,{|o| nOpcA := 1,IF(gpconfOK(),FechaBatch(),nOpcA:=0) }} )
	aAdd(aButtons, { 2,.T.,{|o| FechaBatch() }} )

	FormBatch( OemToAnsi(STR0272), aSays, aButtons ) //"Transferência para empresas externas"
Else
	nOpcA	:= nOpcRot
	If Valtype(aAutoParam) == "A" .And. !Empty(aAutoParam)
		For nI := 1 To Len(aAutoParam)
			Do Case
				Case aAutoParam[nI][1] == "cFiltro"
					cExpFiltro := aAutoParam[nI][2]
				Case aAutoParam[nI][1] == "cCnpjDest"
					cCnpjDest := aAutoParam[nI][2]
				Case aAutoParam[nI][1] == "cTipoRes"
					cTipoRes  := aAutoParam[nI][2]
				Case aAutoParam[nI][1] == "dDataTra"
					dDataDesl := aAutoParam[nI][2]
			EndCase
		Next nI
	EndIf
EndIf

If (lIntTAF .Or. lMiddleware) .AND. nOpca == 1
	If !lRobo
		cCnpjDest := MV_PAR01
		cTipoRes  := MV_PAR02
		dDataDesl := MV_PAR03
	EndIf

	IF Empty(cCnpjDest) .OR. Empty(cTipoRes) .OR. Empty(dDataDesl)
		IIf(!lRobo,MsgAlert(OemToAnsi(STR0277),OemToAnsi(STR0047)),Help(,,'HELP',, STR0277,1,0 ))//É necessário preencher todos os parâmetros / Atenção
	ElseIf Empty(cExpFiltro)
		IIf(!lRobo,MsgAlert(OemToAnsi(STR0317),OemToAnsi(STR0047)),Help(,,'HELP',, STR0317,1,0 ))//'É necessário efetuar o preenchimento do filtro de processamento através do botão "Filtrar"'##"Atenção"
	Else
		cQuery := "SELECT SRA.R_E_C_N_O_ AS RECNO "
		cQuery += "FROM " + RetSqlName('SRA') + " SRA "
		If !lRobo
			cQuery += "WHERE " + GPEParSQL(fPrepExpIn(cExpFiltro)) + " AND "
			cQuery += "SRA.D_E_L_E_T_ = ' ' "
		Else
			cQuery += "WHERE " + cExpFiltro + " "
		EndIf
		cQuery += "ORDER BY SRA.RA_FILIAL, SRA.R_E_C_N_O_"
		dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAlias,.T.,.T.)

		While (cAlias)->(!Eof())
			SRA->( dbGoTo( (cAlias)->RECNO ) )
			If (nPosFil := aScan(aFils, {|x| x[2] == SRA->RA_FILIAL })) > 0
				lAcesFil := aFils[nPosFil,11]
			EndIf
			If FWIsAdmin() .Or. lAcesFil
				If cLastFil != SRA->RA_FILIAL
					RstGpexIni()
					cLastFil 	:= SRA->RA_FILIAL
					aIncRes	  	:= {}
					fIncRes(SRA->RA_FILIAL,cTipoRes,@aIncRes,,@cRescrais,@cAfasfgts,)
					dDataRes	:= dDataDesl
					cCdEFD 		:= fGP40TPRES( cTipoRes )
				EndIf
				cTpInscDest := If( Len(Alltrim(cCnpjDest)) == 11, "2", "1" )

				lGerouXml := fTrf2299( cCdEFD, SRA->RA_FILIAL, cCnpjDest, dDataDesl, cVersEnvio, @cMsgErr, cTpInscDest )

				If !lGerouXML
					aAdd( aLogs[2], STR0318 + SRA->RA_FILIAL + " - " + SRA->RA_MAT + STR0319 )//"Funcionário: "##" não foi integrado, devido ao erro abaixo:"
					aAdd( aLogs[2], cMsgErr )
				Else
					If RecLock("SRA",.F.,.T.)
						SRA->RA_SITFOLH  := "D"
						SRA->RA_DEMISSA  := dDataDesl
						SRA->RA_RESCRAI  := cRescRais
						SRA->RA_AFASFGT  := cAfasFgts
						SRA->( MsUnLock() )
						aAdd( aLogs[1], STR0318 + SRA->RA_FILIAL + " - " +  SRA->RA_MAT + STR0320 )//"Funcionário: "##" integrado com sucesso."
					EndIf
				EndIf
			EndIf
			(cAlias)->( dbSkip() )
			lAcesFil := .F.
		EndDo

		(cAlias)->( dbCloseArea() )
		If !Empty(aLogs)
			fMakeLog(aLogs, aTitle, Nil, !lRobo, , OemToAnsi(STR0321), "M", "L",, .F.) //"Log de Ocorrências"
		EndIf
	Endif
Endif

Return

/*/{Protheus.doc} fGrvSREOff()
Função responsável por gravar a data base do sistema no campo RE_INTGTAF, para os casos do envio da
trasferência ser feita pela rotina (off-line)
@type function
@author Claudinei Soares
@since 10/10/2018
@version 1.0
@param cEmpreD, characters, Grupo Origem. Default: vazio
@param cFiliD, characters, Filial Origem. Default: vazio
@param cMatriD, characters, Matrícula Origem. Default: vazio
@param cDataTran, characters, Data da Transferência. Default: vazio
@return Nil
/*/
Function fGrvSREOff(cEmpreD,cFiliD,cMatriD,cDataTran)

	Local aArea			:= GetArea()

	Default cEmpreD 	:= ""
	Default cFiliD 		:= ""
	Default cMatriD		:= ""
	Default cDataTran	:= ""

	dbSelectArea("SRE")
	SRE->( dbSetOrder(1) )

	If SRE->(DbSeek(cEmpreD + cFiliD + cMatriD + cDataTran ) )
		SRE->( Reclock("SRE", .F.) )
		SRE->RE_INTGTAF := dDataBase
		SRE->( MsUnlock() )
	Endif

	RestArea(aArea)

Return Nil

//-------------------------------------------------------------------
/*/{Protheus.doc} fGravaSpf
Na alteração de turno, regra ou sequência na transferência do
funcionário, cria nova linha de registro na SPF.
@author  Philipe Couto
@since   29/03/2019
@version 0.1
/*/
//-------------------------------------------------------------------
Static Function fGravaSpf()

	Local aArea			:= GetArea()

	Local cCampoTurn 	:= "RA_TNOTRAB"
	Local cCampoSeq		:= "RA_SEQTURN"
	Local cCampoRegra	:= "RA_REGRA"

	//Obtém novos registros através da SRA, já atualizada
	Local cFil			:= SRA->RA_FILIAL
	Local cMat 			:= SRA->RA_MAT
	Local cTurnoPara 	:= SRA->RA_TNOTRAB
	Local cSeqPar 		:= SRA->RA_SEQTURN
	Local cRegPar 		:= SRA->RA_REGRA

	Local cTurnoDe 		:= ""
	Local cSequeDe 		:= ""
	Local cRegraDe 		:= ""
	Local lGeraSpf		:= .F.
	Local dDataTrans 	:= dDataTra
	Local nPosFilial	:= AScan( aSRAHeader, { |x| AllTrim( x[2] ) == "RA_FILIAL" } )
	Local nPosMat       := AScan( aSRAHeader, { |x| AllTrim( x[2] ) == "RA_MAT"    } )

	If (nPosFilMat	:= Ascan(aSRACols, {|x| x[nPosFilial] + x[nPosMat] == cFil + cMat } ) )  > 0
		//Procura Turno
		If ( nPos := AScan( aSRAHeader, { |x| AllTrim( x[2] ) == cCampoTurn } ) )
			cTurnoDe := aSvSraCols[nPosFilMat][nPos]
			lGeraSpf := .T.
		EndIf

		//Procura Sequencia
		If ( nPos := AScan( aSRAHeader, { |x| AllTrim( x[2] ) == cCampoSeq } ) )
			cSequeDe := aSvSraCols[nPosFilMat][nPos]
			lGeraSpf := .T.
		EndIf

		//Procura Regra
		If ( nPos := AScan( aSRAHeader, { |x| AllTrim( x[2] ) == cCampoRegra } ) )
			cRegraDe := aSvSraCols[nPosFilMat][nPos]
			lGeraSpf := .T.
		EndIf

		DBSelectArea("SPF")
		SPF->( DBSetOrder(1) )

		If lGeraSpf
			If SPF->( RecLock( "SPF" , SPF->( !DbSeek( ( cFil + cMat + DTOS(dDataTrans) ) ) ) ) )
				SPF->PF_FILIAL	:= cFil
				SPF->PF_MAT		:= cMat
				SPF->PF_DATA	:= dDataTrans
				SPF->PF_TURNODE	:= cTurnoDe
				SPF->PF_SEQUEDE	:= cSequeDe
				SPF->PF_REGRADE	:= cRegraDe
				SPF->PF_TURNOPA	:= cTurnoPara
				SPF->PF_SEQUEPA	:= cSeqPar
				SPF->PF_REGRAPA	:= cRegPar
				SPF->( MsUnLock() )
			EndIf
		EndIf

		RestArea(aArea)
	EndIf

Return Nil

//-------------------------------------------------------------------
/*/{Protheus.doc} fGpa180SM0
Consulta específica dos grupos de empresa que retorna apenas as empresas
liberadas para o usuário no configurador.

@author  Silvio C. Stecca
@since   10/05/2019
@version 0.1
/*/
//-------------------------------------------------------------------
Function fGpa180SM0()

	// DECLARAÇÃO DE ARRAYS PARA DIMENSIONAR TELA
	Local aRet 			:= PswRet()
	Local nPosGrpEmp	:= 0
	Local lRet			:= .T.
	Local aUsrGrp		:= UsrRetGrp()
	Local aUsrFil		:= {}
	Local nI

	// MONTA ARRAY COM AS EMPRESAS
	If Len(aRet[2][6]) > 0

		// ARMAZENA NO ARRAY OS GRUPOS E FILIAIS DO USUÁRIO.
		aUsrFil := aRet[2][6]

		For nI := 1 to Len(aUsrFil)

			// VERIFICA SE O GRUPO ESTA LIBERADO PARA USO DO USUÁRIO.
			If nPosGrpEmp := aScan(aUsrFil, {|x| SubStr(x, 1, 2) == cEmpAnt}) == 0
				lRet := .F.
				Exit
			EndIf
		Next nI
	EndIf

Return lRet

/*/{Protheus.doc} fValidaMat
Valida troca de matrícula no GRID
@author gabriel.almeida
@since 26/06/2019
@version 1.0
/*/
Static Function fValidaMat(aTrfCols1,aTrfCols2)
	Local lMatVal  := .T.
	Local nX       := 0
	Local nY       := 0
	Local cFilMat  := ""
	Local nLenCols := Len(aTrfCols1)

	If nLenCols > 1
		For nX := 1 To nLenCols
			If aTrfCols1[nX,_FILIAL] + aTrfCols1[nX,_MATRIC] <> ( cFilMat := aTrfCols2[nX,_FILIAL] + aTrfCols2[nX,_MATRIC] )
				For nY := (nX + 1) To nLenCols
					If cFilMat == aTrfCols2[nY,_FILIAL] + aTrfCols2[nY,_MATRIC]
						lMatVal := .F.
						cMsg := aTrfCols2[nY,_MATRIC] + " <=> " + STR0033	//"Já existe Funcionario com a Matricula Digitada. Informe nova Matricula"

						If !IsBlind()
							MsgAlert( cMsg , OemToAnsi(STR0034) ) //"Transferência de Matricula"
						EndIf

						Exit
					EndIf
				Next nY
			EndIf

			If !lMatVal
				Exit
			EndIf
		Next nX
	EndIf
Return lMatVal

//-------------------------------------------------------------------
/*/{Protheus.doc} function GetCttDesc
Retorna a descrição do centro de custo indicado pelos parâmetros
@author  Philipe Couto
@since   05/08/2019
@version 0.1
/*/
//-------------------------------------------------------------------
Static Function GetCttDesc(cEmp, cFil, cChv)
	Local aArea 		:= GetArea()
	Local cAliasQry		:= GetNextAlias()
	Local cDescr		:= ""
	Local cTabela		:= ""

	Default cEmp := cEmpAnt

	cTabela	:= "%"+RetFullName('CTT',cEmp)+"%"

	BeginSQL alias cAliasQry
		SELECT CTT.CTT_DESC01
			FROM %exp:cTabela% CTT
		WHERE CTT.CTT_FILIAL = %exp:xFilial("CTT", cFil)% AND
			CTT.CTT_CUSTO = %exp:cChv% AND
			CTT.%notDel%
	EndSQL

	If !(cAliasQry)->( Eof() )
		cDescr    :=(cAliasQry)->CTT_DESC01
	EndIf

	(cAliasQry)->(dbCloseArea())
	RestArea(aArea)
Return cDescr

/*/{Protheus.doc} fSendSRAApi
Processo para enviar os dados de inclusão/alteração/deleção/Copia para
integração via API REST.
@since	23/04/2020
@autor	Silvia Taguti
@version 1.0
/*/
Static Function fSendDadosApi(cOperacao,dREData)

Local dDtBase    := dDataBase
Local cHoraAt    := Time()
Local cTmpEmp    := cEmpAnt
Local cProces    := "SRE"
Local cUserId    := SubStr(cUsuario,7,15)
Local cTmpMat    := cMatDe
Local cTmpFil    := cFilDe
Local cChave     := cTmpEmp + "|" + cTmpFil + "|" + cTmpMat
Local cFilbkp	:= cFilAnt
Default cOperacao:= ""
Default dREData  := CTOD("//")

If !ChkFile("RJP")
	Return
Endif

If cOperacao == "D" //mandar 2 employee
	cProces := "SRA"
	cFilant := cTmpFil
	fSetInforRJP(cTmpFil, cTmpMat, cProces, cChave, cOperacao, dDtBase, cHoraAt, cUserId) //origem

	cChave := cEmpAte + "|" + cFilAte + "|" + cMatAte
	cFilAnt := cFilbkp
	fSetInforRJP(cFilAte, cMatAte, cProces, cChave, "I", dDtBase, cHoraAt, cUserId) //destino
Else
	cChave += "|" + DTOS(dREData)
	fSetInforRJP(cTmpFil, cTmpMat, cProces, cChave, cOperacao,  dDtBase, cHoraAt, cUserId)

	IF (lCcDif .Or. lDeptoDif) .And. !( lFilDif )
		cProces := "SRA"
		cChave    := cTmpEmp + "|" + cTmpFil + "|" + cTmpMat
		fSetInforRJP(cTmpFil, cTmpMat, cProces, cChave, "A",  dDtBase, cHoraAt, cUserId)
	EndIf
EndIf

Return (.T.)

//-------------------------------------------------------------------
/*/{Protheus.doc} function HabPosto
Funcao para habilitar ou nao a edicao do campo (when)
@author  Gisele Nuncherino
@since   08/10/2020
/*/
//-------------------------------------------------------------------
function HabPosto()
Local lRet 		:= .F.
Local cOrgcfg	:= ""

If FunName() == "GPEA180"
	If !lEmpDif
		If SX6->(DbSeek(fwxFilial("SX6")+"MV_ORGCFG"))
			cOrgcfg := Alltrim(SX6->X6_CONTEUD)
		EndIf
	Else
		cOrgcfg := totvs.framework.company.getParameter(cEmpAte,cFilAnt,"MV_ORGCFG")
	EndIf

	If cOrgCfg == '1' //utiliza posto
		lRet := .T.
	Else
		lRet := .F.
	Endif
Else
	lRet := .T.
Endif

Return lRet

/*/{Protheus.doc} fRJ5Filt
Pesquisa as lotações com campo da filial do trabalhador preenchidos
@type      	Static Function
@author Silvia Taguti
@since 04/11/2020
@version	1.0
@return aRJ5Fil
/*/

Static Function fRJ5Filt(cAliasRJ5,cFilRJ5)
Local aAreaRJ5  := RJ5->(GetArea())
Local aRJ5Fil   := {}

Default cAliasRJ5	:= "RJ5"
Default cFilRJ5		:= fwXFilial('RJ5')

(cAliasRJ5)->(dbSetOrder(7))
(cAliasRJ5)->(dbGotop())
(cAliasRJ5)->( dbSeek( xFilial("RJ5")) )

	While (cAliasRJ5)->(!Eof()) .AND. (cAliasRJ5)->RJ5_FILIAL == cFilRJ5
		If !Empty((cAliasRJ5)->RJ5_FILT)
			AADD(aRJ5Fil,{(cAliasRJ5)->RJ5_FILIAL, (cAliasRJ5)->RJ5_CC, (cAliasRJ5)->RJ5_FILT, (cAliasRJ5)->RJ5_COD, (cAliasRJ5)->RJ5_INI})
		Endif
		(cAliasRJ5)->(dbSkip())
	EndDo

(cAliasRJ5)->(dbGotop())

RestArea(aAreaRJ5)

Return aRJ5Fil

//-------------------------------------------------------------------
/*/{Protheus.doc} function fVldCTrib
Função que verifica se existe data de troca de turno posterior a data da transferência.

@author  Silvio C. Stecca
@since   29/12/2020
@version V 1.0

/*/
//-------------------------------------------------------------------
Static Function fVldDtSPF(cFilFunc, cMatFunc, dDtTransf, lDifDtSPF)

	Local aArea		:= GetArea()
	Local cArqSPF	:= GetNextAlias()
	Local cQrySPF	:= ""

	If oStaSPF == Nil
		oStaSPF := FWPreparedStatement():New()

		cQrySPF := "SELECT MAX(SPF.PF_DATA) PF_DATA "
		cQrySPF += "FROM " + RetSqlName("SPF") + " SPF "
		cQrySPF += "WHERE "
		cQrySPF += "SPF.PF_FILIAL = ? "
		cQrySPF += "AND SPF.PF_MAT = ? "
		cQrySPF += "AND SPF.D_E_L_E_T_ = ' '"

		cQrySPF := ChangeQuery(cQrySPF)

		oStaSPF:SetQuery(cQrySPF)
	EndIf

	// DEFINIÇÃO DOS PARÂMETROS.
	oStaSPF:SetString(1, cFilFunc)
	oStaSPF:SetString(2, cMatFunc)

	// RESTAURA A QUERY COM OS PARÂMETROS INFORMADOS.
	cQrySPF := oStaSPF:getFixQuery()

	dbUseArea(.T., "TOPCONN", TcGenQry(,, cQrySPF), cArqSPF, .T., .T.)

	If (cArqSPF)->(!Eof())
		If (cArqSPF)->PF_DATA > dTos(dDtTransf)
			lDifDtSPF := .T.
		EndIf
	Endif

	// FECHA O ARQUIVO TEMPORARIO CRIADO.
	(cArqSPF)->(dbCloseArea())

	// RESTAURA O AMBIENTE SALVO.
	RestArea(aArea)

Return Nil

//-------------------------------------------------------------------
/*/{Protheus.doc} fRetInfRH3
Função que verifica se existe alguma solicitação ao rh pendente para o funcionario.

@author  Silvio C. Stecca
@since   18/05/2021
@version V 1.0

/*/
//-------------------------------------------------------------------
Static Function fRetInfRH3(cFilFunc, cMatFunc, lSolicPend)

	Local aArea		:= GetArea()
	Local cArqRH3	:= GetNextAlias()
	Local cQryRH3	:= ""
	Local cStaRH3	:= "2|3"

	Default cFilFunc	:= ""
	Default cMatFunc	:= ""
	Default lSolicPend	:= .F.

	If oStaRH3 == Nil
		oStaRH3 := FWPreparedStatement():New()

		cQryRH3 := "SELECT DISTINCT(RH3_STATUS) "
		cQryRH3 += "FROM " + RetSqlName("RH3") + " RH3 "
		cQryRH3 += "WHERE "
		cQryRH3 += "RH3.RH3_FILIAL = ? "
		cQryRH3 += "AND RH3.RH3_MAT = ? "
		cQryRH3 += "AND RH3.RH3_STATUS NOT IN " + FORMATIN(cStaRH3, "|") + " "
		cQryRH3 += "AND RH3.D_E_L_E_T_ = ' '"

		cQryRH3 := ChangeQuery(cQryRH3)

		oStaRH3:SetQuery(cQryRH3)
	EndIf

	// DEFINIÇÃO DOS PARÂMETROS.
	oStaRH3:SetString(1, cFilFunc)
	oStaRH3:SetString(2, cMatFunc)

	// RESTAURA A QUERY COM OS PARÂMETROS INFORMADOS.
	cQryRH3 := oStaRH3:getFixQuery()

	dbUseArea(.T., "TOPCONN", TcGenQry(,, cQryRH3), cArqRH3, .T., .T.)

	If (cArqRH3)->(!Eof())
		lSolicPend := .T.
	Endif

	// FECHA O ARQUIVO TEMPORARIO CRIADO.
	(cArqRH3)->(dbCloseArea())

	// RESTAURA O AMBIENTE SALVO.
	RestArea(aArea)

Return Nil

//-------------------------------------------------------------------
/*/{Protheus.doc} fConRHCTT
Função especifica para retornar o centro de custo

@author  Fernando Luis Guilherme
@since   25/02/2022
@version V 1.0

/*/
//-------------------------------------------------------------------


Function fConRHCTT()
    Local i             As Numeric
    Local lRet          As Logical
    Local bOk           As Block
    Local bCancel       As Block
    Local aSeek         As Array
    Local oModalPanel   As Object
    Local oPanelGrid    As Object
    Local aArrayGrup    As Array
    Local cEnvQuery     As Character
	Local cFilCTT		As Character
	Local nSzCC			As Numeric
	Local nSzDsCC		As Numeric
	Local lTransfUni	:= IsInCallStack( "fTransfUnico" )
	Local lMsBlql		:= CTT->( FieldPos( "CTT_MSBLQL" ) ) != 0
	Local cEmpCTT		:= 	""

    Private oBrowse     As Object
    Private oModal      As Object

    lRet        := .T.
    bOk         := {||lRet := .T., oModal:oOwner:End()}
    bCancel     := {||lRet := .F., oModal:oOwner:End()}
    aSeek       := {}
    aArrayGrup  := {}
	nSzCC		:= TamSX3("RA_CC")[1]
	nSzDsCC		:= TamSX3("RA_DESCCC ")[1]

	cEmpCTT		:= 	If(lTransfUni,oGetTran:aCols[1,1],cEmpAte)
	If lEmpDif
		cFilCTT		:= totvs.framework.company.xEmpFil("CTT", cEmpCTT , If(lTransfUni,oGetTran:aCols[1,3],cFilAte))
	Else
		cFilCTT		:= FwxFilial("CTT",If(lTransfUni,oGetTran:aCols[1,3],cFilAte))
	EndIf

    oModal := FWDialogModal():New()

    oModal:SetFreeArea(300, 200)
    oModal:createDialog()
    oModal:SetEscClose(.T.)
    oModal:AddButton( OemToAnsi( STR0338 ), bOk, OemToAnsi( STR0338 ), , .T., .F., .T., {|| .T.}) //OK
    oModal:AddButton( OemToAnsi( STR0339 ), bCancel, OemToAnsi( STR0339 ), , .T., .F., .T., ) //Cancelar

    oModalPanel := oModal:GetPanelMain()

    oPanelGrid := TPanel():New(0, 0, "", oModalPanel, ,,,,, 0, 0)

    oPanelGrid:Align := CONTROL_ALIGN_ALLCLIENT

    cEnvQuery := "SELECT DISTINCT CTT_CUSTO, CTT_DESC01 "
    cEnvQuery += "FROM "+RetFullName("CTT",cEmpCTT)+" CTT "
    cEnvQuery += "WHERE "
	If !Empty(cFilCTT)
		cEnvQuery += "CTT.CTT_FILIAL = '"+cFilCTT+"' AND "
	EndIf
	If lMsBlql
		cEnvQuery += "CTT.CTT_MSBLQL <> '1' AND "
	EndIF
    cEnvQuery += "CTT.D_E_L_E_T_=' ' "
    cEnvQuery += "ORDER BY CTT_DESC01 "

    cAliasQry := GetNextAlias()
    DbUseArea(.T., "TOPCONN", TcGenQry(,,cEnvQuery), cAliasQry, .T., .T.)

    (cAliasQry)->(DbGoTop())

    While (cAliasQry)->(!EOF())
        aAdd(aArrayGrup, {(cAliasQry)->(CTT_CUSTO), (cAliasQry)->(CTT_DESC01) })
        (cAliasQry)->(DbSkip())
    EndDo

    (cAliasQry)->(DbCloseArea())

    Aadd( aSeek, { OemToAnsi( STR0336 ) , {{"","C",nSzDsCC,0,OemToAnsi( STR0336 ), "@!"}}, 1} ) //"Código"
    Aadd( aSeek, { OemToAnsi( STR0337 ) , {{"","C",nSzDsCC,0,OemToAnsi( STR0337 ), "@!"}}, 2} )  //"Descrição"

    oBrowse := FWBrowse():New(oPanelGrid)
    oBrowse:SetDescription(OemToAnsi( STR0340 )) //"Centro de custo"

    oBrowse:SetDataArray()
    oBrowse:DisableFilter()
    oBrowse:DisableConfig()
    oBrowse:SetColumns(CriaColumns(OemToAnsi( STR0336 ),1,,0,nSzCC,"oBrowse")) //"Código"
    oBrowse:SetColumns(CriaColumns(OemToAnsi( STR0337 ),2,,0,nSzDsCC,"oBrowse")) //"Descrição"
    oBrowse:SetArray(aArrayGrup)
    oBrowse:SetSeek( , aSeek)
    oBrowse:Activate()

    oModal:Activate()

    // ---------------------------------------------------------------------------
    // Atribuo o valor selecionado ao conteúdo de retorno da consulta específica
    // ---------------------------------------------------------------------------

    If lRet
        If Len(aArrayGrup) > 0
            cCc	:= M->RA_CC := aArrayGrup[oBrowse:nAt][1]
        Else
            cCc	:= M->RA_CC := ""
        EndIf

    EndIf
Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} fConRHDPT
Função especifica para retornar o departamento

@author  Fernando Luis Guilherme
@since   11/03/2022
@version V 1.0

/*/
//-------------------------------------------------------------------


Function fConRHDPT()
    Local i             As Numeric
    Local lRet          As Logical
    Local bOk           As Block
    Local bCancel       As Block
    Local aSeek         As Array
    Local oModalPanel   As Object
    Local oPanelGrid    As Object
    Local aArrayGrup    As Array
    Local cEnvQuery     As Character
	Local nSzDept    	As Numeric
	Local nSzDsDe    	As Numeric
	Local cFilSQB		As Character
	Local lTransfUni	:= IsInCallStack( "fTransfUnico" )
	Local lMsBlql		:= SQB->( FieldPos( "QB_MSBLQL" ) ) != 0
	Local cEmpSQB		:= ""

    Private oBrowse     As Object
    Private oModal      As Object

    lRet        := .T.
    bOk         := {||lRet := .T., oModal:oOwner:End()}
    bCancel     := {||lRet := .F., oModal:oOwner:End()}
    aSeek       := {}
    aArrayGrup  := {}
	nSzDept		:= TamSX3("QB_DEPTO")[1]
	nSzDsDe		:= TamSX3("QB_DESCRIC")[1]

	cEmpSQB			:= 	If(lTransfUni,oGetTran:aCols[1,1],cEmpAte)
	If lEmpDif
		cFilSQB		:= totvs.framework.company.xEmpFil("SQB", cEmpSQB , If(lTransfUni,oGetTran:aCols[1,3],cFilAte))
	Else
		cFilSQB		:= FwxFilial("SQB",If(lTransfUni,oGetTran:aCols[1,3],cFilAte))
	EndIf

    oModal := FWDialogModal():New()

    oModal:SetFreeArea(300, 200)
    oModal:createDialog()
    oModal:SetEscClose(.T.)
    oModal:AddButton( OemToAnsi( STR0338 ), bOk, OemToAnsi( STR0338 ), , .T., .F., .T., {|| .T.}) //OK
    oModal:AddButton( OemToAnsi( STR0339 ), bCancel, OemToAnsi( STR0339 ), , .T., .F., .T., ) //Cancelar

    oModalPanel := oModal:GetPanelMain()

    oPanelGrid := TPanel():New(0, 0, "", oModalPanel, ,,,,, 0, 0)

    oPanelGrid:Align := CONTROL_ALIGN_ALLCLIENT

	If cOrgCfg == "1"
		aArrayGrup:= fRD4ORG()
	Else
		cEnvQuery := "SELECT DISTINCT QB_DEPTO, QB_DESCRIC "
		cEnvQuery += "FROM "+RetFullName("SQB",cEmpSQB)+" SQB "
		cEnvQuery += "WHERE "
		If !Empty(cFilSQB)
			cEnvQuery += "SQB.QB_FILIAL = '"+cFilSQB+"' AND "
		EndIf
		If lMsBlql
			cEnvQuery += "SQB.QB_MSBLQL <> '1' AND "
		EndIF
		cEnvQuery += "SQB.D_E_L_E_T_=' ' "
        cEnvQuery += "ORDER BY QB_DEPTO, QB_DESCRIC "

		cAliasQry := GetNextAlias()
		DbUseArea(.T., "TOPCONN", TcGenQry(,,cEnvQuery), cAliasQry, .T., .T.)

		(cAliasQry)->(DbGoTop())

		While (cAliasQry)->(!EOF())
			aAdd(aArrayGrup, {(cAliasQry)->(QB_DEPTO), (cAliasQry)->(QB_DESCRIC) })

			(cAliasQry)->(DbSkip())
		EndDo

		(cAliasQry)->(DbCloseArea())
	Endif

    Aadd( aSeek, { OemToAnsi( STR0336 ) , {{"","C",nSzDsDe,0,OemToAnsi( STR0336 )}}, 1, .T. } ) //"Código"
    Aadd( aSeek, { OemToAnsi( STR0337 ) , {{"","C",nSzDsDe,0,OemToAnsi( STR0337 )}}, 1, .T. } ) //"Descrição"

    oBrowse := FWBrowse():New(oPanelGrid)

    oBrowse:SetDescription(OemToAnsi( STR0341 )) //"Departamentos
    oBrowse:SetDataArray()
    oBrowse:DisableFilter()
    oBrowse:DisableConfig()
    oBrowse:SetColumns(CriaColumns(OemToAnsi( STR0336 ),1,,0,nSzDept,"oBrowse")) //"Código"
    oBrowse:SetColumns(CriaColumns(OemToAnsi( STR0337 ),2,,0,nSzDsDe,"oBrowse")) //"Descrição"
    oBrowse:SetArray(aArrayGrup)
    oBrowse:SetSeek( , aSeek)
    oBrowse:Activate()

    oModal:Activate()

    // ---------------------------------------------------------------------------
    // Atribuo o valor selecionado ao conteúdo de retorno da consulta específica
    // ---------------------------------------------------------------------------

    If lRet
        If Len(aArrayGrup) > 0
            M->RA_DEPTO := aArrayGrup[oBrowse:nAt][1]
        Else
            M->RA_DEPTO := ""
        EndIf
    EndIf
Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} fConRHPROC
Função especifica para retornar o processo

@author  Fernando Luis Guilherme
@since   11/03/2022
@version V 1.0

/*/
//-------------------------------------------------------------------


Function fConRHPROC()
    Local i             As Numeric
    Local lRet          As Logical
    Local bOk           As Block
    Local bCancel       As Block
    Local aSeek         As Array
    Local oModalPanel   As Object
    Local oPanelGrid    As Object
    Local aArrayGrup    As Array
    Local cEnvQuery     As Character
	Local nSzProc		As Numeric
	Local nSzDsPro		As Numeric
	Local cFilRCJ		As Character
	Local lTransfUni	:= IsInCallStack( "fTransfUnico" )
	Local lMsBlql		:= RCJ->( FieldPos( "RCJ_MSBLQL" ) ) != 0
	Local cEmpRCJ		:= 	If(lTransfUni,oGetTran:aCols[1,1],cEmpAte)

    Private oBrowse     As Object
    Private oModal      As Object

    lRet        := .T.
    bOk         := {||lRet := .T., oModal:oOwner:End()}
    bCancel     := {||lRet := .F., oModal:oOwner:End()}
    aSeek       := {}
    aArrayGrup  := {}
	nSzProc		:= TamSX3("RCJ_CODIGO")[1]
	nSzDsPro	:= TamSX3("RCJ_DESCRI")[1]

	cEmpRCJ			:= 	If(lTransfUni,oGetTran:aCols[1,1],cEmpAte)
	If lEmpDif
		cFilRCJ		:= totvs.framework.company.xEmpFil("RCJ", cEmpRCJ , If(lTransfUni,oGetTran:aCols[1,3],cFilAte))
	Else
		cFilRCJ		:= FwxFilial("RCJ",If(lTransfUni,oGetTran:aCols[1,3],cFilAte))
	EndIf

    oModal := FWDialogModal():New()

    oModal:SetFreeArea(300, 200)
    oModal:createDialog()
    oModal:SetEscClose(.T.)
    oModal:AddButton( OemToAnsi( STR0338 ), bOk, OemToAnsi( STR0338 ), , .T., .F., .T., {|| .T.}) //OK
    oModal:AddButton( OemToAnsi( STR0339 ), bCancel, OemToAnsi( STR0339 ), , .T., .F., .T., ) //Cancelar

    oModalPanel := oModal:GetPanelMain()

    oPanelGrid := TPanel():New(0, 0, "", oModalPanel, ,,,,, 0, 0)

    oPanelGrid:Align := CONTROL_ALIGN_ALLCLIENT

    cEnvQuery := "SELECT DISTINCT RCJ_CODIGO, RCJ_DESCRI "
    cEnvQuery += "FROM "+RetFullName("RCJ",cEmpRCJ)+" RCJ "
    cEnvQuery += "WHERE "
	If !Empty(cFilRCJ)
		cEnvQuery += "RCJ.RCJ_FILIAL = '"+cFilRCJ+"' AND "
	EndIf
	If lMsBlql
		cEnvQuery += "RCJ.RCJ_MSBLQL <> '1' AND "
	EndIF
    cEnvQuery += "RCJ.D_E_L_E_T_=' ' "
    cEnvQuery += "ORDER BY RCJ_CODIGO, RCJ_DESCRI "

    cAliasQry := GetNextAlias()
    DbUseArea(.T., "TOPCONN", TcGenQry(,,cEnvQuery), cAliasQry, .T., .T.)

    (cAliasQry)->(DbGoTop())

    While (cAliasQry)->(!EOF())
        aAdd(aArrayGrup, {(cAliasQry)->(RCJ_CODIGO), (cAliasQry)->(RCJ_DESCRI) })

        (cAliasQry)->(DbSkip())
    EndDo

    (cAliasQry)->(DbCloseArea())

    Aadd( aSeek, { OemToAnsi( STR0336 ) , {{"","C",nSzDsPro,0,OemToAnsi( STR0336 )}}, 1, .T. } ) //"Código"
    Aadd( aSeek, { OemToAnsi( STR0337 ) , {{"","C",nSzDsPro,0,OemToAnsi( STR0337 )}}, 1, .T. } ) //"Descrição"

    oBrowse := FWBrowse():New(oPanelGrid)

    oBrowse:SetDescription(OemToAnsi( STR0342 )) //"Processos"
    oBrowse:SetDataArray()
    oBrowse:DisableFilter()
    oBrowse:DisableConfig()
    oBrowse:SetColumns(CriaColumns(OemToAnsi( STR0336 ),1,,0,nSzProc,"oBrowse")) //"Código"
    oBrowse:SetColumns(CriaColumns(OemToAnsi( STR0337 ),2,,0,nSzDsPro,"oBrowse")) //"Descrição"
    oBrowse:SetArray(aArrayGrup)
    oBrowse:SetSeek( , aSeek)
    oBrowse:Activate()

    oModal:Activate()

    // ---------------------------------------------------------------------------
    // Atribuo o valor selecionado ao conteúdo de retorno da consulta específica
    // ---------------------------------------------------------------------------

    If lRet
        If Len(aArrayGrup) > 0
            M->RA_PROCES := aArrayGrup[oBrowse:nAt][1]
        Else
            M->RA_PROCES := ""
        EndIf
    EndIf
Return lRet


//-------------------------------------------------------------------
/*/{Protheus.doc} fRD4ORG
Função especifica filtrar o departamento a partir da visão no SIGAORG

@author  Fernando Luis Guilherme
@since   14/03/2022
@version V 1.0

/*/
//-------------------------------------------------------------------


Static Function fRD4ORG()
	Local oStat1 		:= Nil
	Local aVisao		:= {}
	Local aArea    		:= GetArea()
	Local aAreaRDK 		:= RDK->( GetArea() )
	Local cFiltro  		:= ""
	Local cEmpRD4  		:= ""
	Local cFilRD4  		:= ""
	Local cAliasRD4		:= GetNextAlias()
	Local cFilVisao		:= ""
	Local cQuery		:= ""
	Local lTransfUni	:= IsInCallStack( "fTransfUnico" )
	Local lMsBlql		:= RD4->( FieldPos( "RD4_MSBLQL" ) ) != 0

	cFiltro := " (RD4_FILIAL == '" + xFilial("RD4")  + "' .AND. "

	// Tabela RDK/RD4 já está aberta na Empresa Destino pela ConsDepto
	cFilVisao 	:=	If(lEmpDif, totvs.framework.company.xEmpFil("RDK", cEmpAte, cFilAte), FwxFilial("RDK"))

	dbSelectArea("RDK")
	dbSetOrder(4)		//RDK_FILIAL+RDK_HIERAR+RDK_TIPO+RDK_CODIGO
	If RDK->( dbSeek(cFilVisao+"11") )
		If Type("oGetSRA2") != "U"		//Se existir o objeto oGetSRA2, é porque esta sendo chamado da transferencia nova
			cEmpRD4 := If (lTransfUni,oGetTran:aCols[1,1],oGetSRA2:aCols[oGetSRA2:nAt, GdFieldPos("M_EMPRESA", oGetSRA2:aHeader)] )
			cFilRD4 := If (lTransfUni,oGetTran:aCols[1,3],oGetSRA2:aCols[oGetSRA2:nAt, GdFieldPos("RA_FILIAL", oGetSRA2:aHeader)] )
			If lEmpDif
				cFilRD4 	:=  totvs.framework.company.xEmpFil("SQB", cEmpRD4, cFilRD4)
			Else
				cFilRD4 	:=  FwxFilial("SQB", cFilRD4)
			EndIf
		EndIf
	EndIf

	If oStat1 == Nil
		oStat1 := FWPreparedStatement():New()
		cQuery := "SELECT DISTINCT  RD4.RD4_CODIDE, RD4.RD4_DESC" + If( lMsBlql, ", RD4.RD4_MSBLQL", "" )
		cQuery += "FROM " + RetFullName('RD4',cEmpAte) + " RD4 "
		cQuery += "INNER JOIN "+ RetFullName('RDK',cEmpAte) + " RDK ON RD4.RD4_CODIGO = RDK.RDK_CODIGO  AND RDK.RDK_HIERAR = ? "
		cQuery += "WHERE RD4.RD4_EMPIDE  = ? "
		cQuery +=	"AND ( RD4.RD4_FILIDE = ? OR RD4.RD4_FILIDE = ?)"
		cQuery += 	"AND RD4.D_E_L_E_T_ = ? "
		cQuery += 	"AND RDK.D_E_L_E_T_ = ? "
		cQuery += "ORDER BY RD4.RD4_CODIDE, RD4.RD4_DESC"
		cQuery := ChangeQuery(cQuery)
		oStat1:SetQuery(cQuery)
	EndIf

	oStat1:SetString(1, "1")
	oStat1:SetString(2, cEmpRD4)
	oStat1:SetString(3, cFilRD4)
	oStat1:SetString(4, cFilAnt)
	oStat1:SetString(5, ' ')
	oStat1:SetString(6, ' ')
	cQuery := oStat1:getFixQuery()
	dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasRD4,.T.,.T.)

	(cAliasRD4)->(DbGoTop())

	While (cAliasRD4)->(!EOF())
		If (lMsBlql .And. (cAliasRD4)->(RD4_MSBLQL) $ "2 ") .Or. !lMsBlql
			aAdd(aVisao, {(cAliasRD4)->(RD4_CODIDE), (cAliasRD4)->(RD4_DESC) })
		EndIf

		(cAliasRD4)->(DbSkip())
	EndDo

	(cAliasRD4)->(DbCloseArea())

	RestArea( aAreaRDK )
	RestArea( aArea )

Return aVisao


//-------------------------------------------------------------------
/*/{Protheus.doc} fConRHPOSTO
Função especifica para retornar o processo

@author  Fernando Luis Guilherme
@since   14/03/2022
@version V 1.0

/*/
//-------------------------------------------------------------------


Function fConRHPOSTO()
    Local i             As Numeric
    Local lRet          As Logical
    Local bOk           As Block
    Local bCancel       As Block
    Local aSeek         As Array
    Local oModalPanel   As Object
    Local oPanelGrid    As Object
    Local aArrayGrup    As Array
    Local cEnvQuery     As Character
	Local nSzPost		As Numeric
	Local nSzDsPost		As Numeric
	Local cFilRCL		As Character
	Local lTransfUni	:= IsInCallStack( "fTransfUnico" )
	Local lMsBlql		:= RCL->( FieldPos( "RCL_MSBLQL" ) ) != 0
	Local cEmpRCL		:= 	""

    Private oBrowse     As Object
    Private oModal      As Object

    lRet        := .T.
    bOk         := {||lRet := .T., oModal:oOwner:End()}
    bCancel     := {||lRet := .F., oModal:oOwner:End()}
    aSeek       := {}
    aArrayGrup  := {}
	nSzPost		:= TamSX3("RCL_POSTO")[1]
	nSzDsPost	:= TamSX3("Q3_DESCSUM")[1]

	cEmpRCL			:= 	If(lTransfUni,oGetTran:aCols[1,1],cEmpAte)
	If lEmpDif
		cFilRCL 	:= totvs.framework.company.xEmpFil("RCL", cEmpRCL , If(lTransfUni,oGetTran:aCols[1,3],cFilAte))
	Else
		cFilRCL 	:= FwxFilial("RCL",If(lTransfUni,oGetTran:aCols[1,3],cFilAte))
	EndIf

	// Depto nao Pode Estar Vazio
	If cOrgCfg == "1" .And. Empty(M->RA_DEPTO)
		Help(" ",1,"A180DEPTONEX") // Departamento informado invalido ou nao cadastrado.
		lRet := .F.
	EndIf

	If lRet
		oModal := FWDialogModal():New()

		oModal:SetFreeArea(300, 200)
		oModal:createDialog()
		oModal:SetEscClose(.T.)
		oModal:AddButton( OemToAnsi( STR0338 ), bOk, OemToAnsi( STR0338 ), , .T., .F., .T., {|| .T.}) //OK
		oModal:AddButton( OemToAnsi( STR0339 ), bCancel, OemToAnsi( STR0339 ), , .T., .F., .T., ) //Cancelar

		oModalPanel := oModal:GetPanelMain()

		oPanelGrid := TPanel():New(0, 0, "", oModalPanel, ,,,,, 0, 0)

		oPanelGrid:Align := CONTROL_ALIGN_ALLCLIENT
		cEnvQuery := "SELECT DISTINCT RCL_POSTO, SQ3.Q3_DESCSUM "
		cEnvQuery += "FROM "+RetFullName("RCL",cEmpRCL)+" RCL "
		cEnvQuery += "INNER JOIN "+RetFullName("SQ3",cEmpRCL)+" SQ3 ON "
		cEnvQuery += "RCL.RCL_CARGO = SQ3.Q3_CARGO "
		cEnvQuery += "WHERE "
		If !Empty(cFilRCL)
			cEnvQuery += "RCL.RCL_FILIAL = '"+cFilRCL+"' AND "
		EndIf
		If lMsBlql
			cEnvQuery += "RCL.RCL_MSBLQL <> '1' AND "
		EndIF
		cEnvQuery += "RCL.RCL_DEPTO = '"+M->RA_DEPTO+"' AND "
		cEnvQuery += "RCL.D_E_L_E_T_=' ' AND "
		cEnvQuery += "SQ3.D_E_L_E_T_=' ' "
        cEnvQuery += "ORDER BY SQ3.Q3_DESCSUM"

		cAliasQry := GetNextAlias()
		DbUseArea(.T., "TOPCONN", TcGenQry(,,cEnvQuery), cAliasQry, .T., .T.)

		(cAliasQry)->(DbGoTop())

		While (cAliasQry)->(!EOF())
			aAdd(aArrayGrup, {(cAliasQry)->(RCL_POSTO), (cAliasQry)->(Q3_DESCSUM) })

			(cAliasQry)->(DbSkip())
		EndDo

		(cAliasQry)->(DbCloseArea())

		Aadd( aSeek, { OemToAnsi( STR0336 ) , {{"","C",nSzDsPost,0,OemToAnsi( STR0336 )}}, 1, .T. } ) //"Código"
        Aadd( aSeek, { OemToAnsi( STR0337 ) , {{"","C",nSzDsPost,0,OemToAnsi( STR0337 )}}, 1, .T. } ) //"Descrição"

		oBrowse := FWBrowse():New(oPanelGrid)

		oBrowse:SetDescription(OemToAnsi( STR0343 )) //"Postos"
		oBrowse:SetDataArray()
		oBrowse:DisableFilter()
		oBrowse:DisableConfig()
		oBrowse:SetColumns(CriaColumns(OemToAnsi( STR0336 ),1,,0,nSzPost,"oBrowse")) //"Código"
		oBrowse:SetColumns(CriaColumns(OemToAnsi( STR0337 ),2,,0,nSzDsPost,"oBrowse")) //"Descrição"
		oBrowse:SetArray(aArrayGrup)
		oBrowse:SetSeek( , aSeek)
		oBrowse:Activate()

		oModal:Activate()

		// ---------------------------------------------------------------------------
		// Atribuo o valor selecionado ao conteúdo de retorno da consulta específica
		// ---------------------------------------------------------------------------

		If lRet
			If Len(aArrayGrup) > 0
				M->RA_POSTO := aArrayGrup[oBrowse:nAt][1]
			Else
				M->RA_POSTO := ""
			EndIf
		EndIf

	EndIf
Return lRet


//-------------------------------------------------------------------
/*/{Protheus.doc} CriaColumns
Função especifica para construir as colunas da consulta especifica

@author  Fernando Luis Guilherme
@since   25/02/2022
@version V 1.0

/*/
//-------------------------------------------------------------------


Static Function CriaColumns(cTitulo,xArrData,cPicture,nAlign,nSize,cBrowse,cTipo,nDecimal)
    Local aColumn   As Array
    Local bData     As Block

    Default nAlign := 1
    Default nSize := 20

    bData   := {||}
    aColumn := {}

    If !Empty(xArrData)
        If ValType(xArrData) == "N" .AND. xArrData > 0 .AND. !Empty(cBrowse)
            bData := &("{||"+cBrowse+":oData:aArray["+cBrowse+":At(),"+STR(xArrData)+"]}")
        EndIf
    EndIf

    aColumn := {cTitulo,bData,cTipo,cPicture,nAlign,nSize,nDecimal,.F.,{||.T.},.F.,{||oModal:oOwner:End()},NIL,{||.T.},.F.,.F.,{}}
Return {aColumn}


//-------------------------------------------------------------------
/*/{Protheus.doc} function fSX7Descc
Função que retorna descrição do Centro de Custo executada pelo gatilho (SX7)
@author  raquel.andrade
@since   31/03/2022
@version V 1.0

/*/
//-------------------------------------------------------------------
Function fSX7Descc()
Local cChave := ""
Local cVarMem	:= ReadVar()
Local cAlias	:= ""
Local cId		:= ""

If FunName() == "GPEA180" .Or. (IsInCallStack("GPEA180MAT")  .And. FunName() == "GPEA011")
	If cVarMem == "M->RA_CC"
		cAlias	:= "CTT"
		cId		:= cCc
	ElseIf cVarMem == "M->RA_DEPTO"
			cAlias	:= "SQB"
			cId		:= cDepto
	EndIf
	If lEmpDif
		cChave	:= totvs.framework.company.xEmpFil(cAlias, cEmpAte, cFilAte) + cId
	Else
		cChave	:= FwxFilial(cAlias,cFilAte) + cId
	EndIf
Else
	If cVarMem == "M->RA_CC" .Or. (FWIsInCallstack("ORGXPosto") .And. AllTrim(SX7->X7_CAMPO) = 'RA_CC')
		cChave	:= xFilial("CTT")+ M->RA_CC
	ElseIf cVarMem == "M->RA_DEPTO" .Or. (FWIsInCallstack("ORGXPosto") .And. AllTrim(SX7->X7_CAMPO) = 'RA_DEPTO')
		cChave	:= xFilial("SQB")+  M->RA_DEPTO
	EndIf
EndIf

Return cChave

//-------------------------------------------------------------------
/*/{Protheus.doc} function existF3New
Função verifica a existencia das novas consultas
@author  martins.marcio
@since   10/06/2022
@version V 1.0

/*/
//-------------------------------------------------------------------
Function existF3New(cConCTT, cConDept, cConProc, cConPosto, cConPeriod,cConNrPag,cConTurn,cConFunc,cConRegr,cConSeq,cConSM0)

	Local aArea	:= GetArea()

	Default cConCTT		:= ""
	Default cConDept	:= ""
	Default cConProc	:= ""
	Default cConPosto	:= ""
	Default cConPeriod	:= ""
	Default cConNrPag	:= ""
	Default cConTurn	:= ""
	Default cConFunc	:= ""
	Default cConRegr	:= ""
	Default cConSeq		:= ""
	Default cConSM0		:= ""

	DbSelectArea("SXB")
	If dbSeek("RHCTT") //Verifica se existe a nova consulta de centro de custo
		cConCTT := .T.
	Endif
	If dbSeek("RHDEPT") //Verifica se existe a nova consulta de departamento
		cConDept := .T.
	Endif
	If dbSeek("RHPROC") //Verifica se existe a nova consulta processos
		cConProc := .T.
	Endif
	If dbSeek("RHPOST") //Verifica se existe a nova consulta postos
		cConPosto := .T.
	Endif
	If dbSeek("RHPER") //Verifica se existe a nova consulta períodos
		cConPeriod := .T.
	Endif
	If dbSeek("RHNRPG") //Verifica se existe a nova consulta número de pagamento
		cConNrPag := .T.
	Endif
	If dbSeek("RHSR6") //Verifica se existe a nova consulta turno de trabalho
		cConTurn := .T.
	Endif
	If dbSeek("RHSRJ") //Verifica se existe a nova consulta código da função
		cConFunc := .T.
	Endif
	If dbSeek("RHSPA") //Verifica se existe a nova consulta regra de apontamento
		cConRegr := .T.
	Endif
	If dbSeek("RHSPJ") //Verifica se existe a nova consulta sequencia de turno de trabalho
		cConSeq := .T.
	Endif
	If dbSeek("XM0GPE") //Verifica se existe a nova consulta empresas x filiais
		cConSM0 := .T.
	Endif

	RestArea( aArea )

Return

//-------------------------------------------------------------------
/*/{Protheus.doc} fConRHPer
Função especifica para retornar o periodo/número de pagamento
@author  raquel.andrade
@since   14/05/2024
@version V 1.0
/*/
//-------------------------------------------------------------------
Function fConRHPer(nRetorno)
    Local lRet          As Logical
    Local bOk           As Block
    Local bCancel       As Block
    Local aSeek         As Array
    Local oModalPanel   As Object
    Local oPanelGrid    As Object
    Local aArrayGrup    As Array
    Local cEnvQuery     As Character
	Local cProcPesq     As Character
	Local cRotPesq	    As Character
	Local nSzPer		As Numeric
	Local nSzNrPag		As Numeric
	Local nSzProc		As Numeric
	Local nSzRot		As Numeric
	Local nSzDtPg		As Numeric
	Local nSzDtFec		As Numeric
	Local cFilRCH		As Character
	Local lMsBlql		:= RCH->( FieldPos( "RCH_MSBLQL" ) ) != 0
	Local cChvRCH		:= ""
    Private oBrowse     As Object
    Private oModal      As Object

    lRet        := .T.
    bOk         := {||lRet := .T., oModal:oOwner:End()}
    bCancel     := {||lRet := .F., oModal:oOwner:End()}
    aSeek       := {}
    aArrayGrup  := {}
	nSzPer		:= TamSX3("RCH_PER")[1]
	nSzNrPag	:= TamSX3("RCH_NUMPAG")[1]
	nSzProc		:= TamSX3("RCH_PROCES")[1]
	nSzRot		:= TamSX3("RCH_ROTEIR")[1]
	nSzDtPg		:= TamSX3("RCH_DTPAGO")[1]
	nSzDtFec	:= TamSX3("RCH_DTFECH")[1]
	// Esse F3 é somente associado através da função fTelaTransf cujo objeto oGetDados
	// é private ou seja sempre irá existir
	cProcPesq	:= oGetDados:aCols[n,5]
	cRotPesq	:= oGetDados:aCols[n,4]

	cFilRCH := If(lEmpDif, totvs.framework.company.xEmpFil("RCH", cEmpAte, cFilAte), FwxFilial("RCH",cFilAte))

    oModal := FWDialogModal():New()

    oModal:SetFreeArea(300, 200)
    oModal:createDialog()
    oModal:SetEscClose(.T.)
    oModal:AddButton( OemToAnsi( STR0338 ), bOk, OemToAnsi( STR0338 ), , .T., .F., .T., {|| .T.}) 	//OK
    oModal:AddButton( OemToAnsi( STR0339 ), bCancel, OemToAnsi( STR0339 ), , .T., .F., .T., ) 		//Cancelar

    oModalPanel := oModal:GetPanelMain()

    oPanelGrid := TPanel():New(0, 0, "", oModalPanel, ,,,,, 0, 0)

    oPanelGrid:Align := CONTROL_ALIGN_ALLCLIENT

	cChvRCH	:=  cFilRCH + cProcPesq + cRotPesq
	DbSelectArea( "RCH" )
	RCH->(DbSetOrder( RetOrder("RCH", "RCH_FILIAL+RCH_PROCES+RCH_ROTEIR+RCH_PER+RCH_NUMPAG") ) )
	If RCH->(DbSeek(cChvRCH))
		While RCH->(!EOF()) .And. cChvRCH == RCH->(RCH_FILIAL + RCH_PROCES + RCH_ROTEIR)
			If Empty(RCH->RCH_DTFECH) .And. dDataTra <= RCH->RCH_DTFIM
				aAdd(aArrayGrup, {	RCH->RCH_PROCES	, RCH->RCH_PER	, ;
									RCH->RCH_NUMPAG	, RCH->RCH_ROTEIR	, ;
									RCH->RCH_DTPAGO, RCH->RCH_DTFECH })
			EndIf
			RCH->(DbSkip())
		EndDo
	EndIf

    Aadd( aSeek, { OemToAnsi( STR0349 ) , {{"","C",nSzPer,0,OemToAnsi( STR0349 )}}, 1, .T. } ) 		//"Período"
    Aadd( aSeek, { OemToAnsi( STR0351 ) , {{"","C",nSzRot,0,OemToAnsi( STR0351 )}}, 1, .T. } ) 		//"Roteiro"

    oBrowse := FWBrowse():New(oPanelGrid)

    oBrowse:SetDescription(OemToAnsi( STR0355 )) //"Período(s) / Número(s) de Pagamento"
    oBrowse:SetDataArray()
    oBrowse:DisableFilter()
    oBrowse:DisableConfig()
	oBrowse:SetColumns(CriaColumns(OemToAnsi( STR0087 ),1,,0,nSzProc,"oBrowse"))		//"Processo"
    oBrowse:SetColumns(CriaColumns(OemToAnsi( STR0349 ),2,,0,nSzPer,"oBrowse"))	 		//"Período"
    oBrowse:SetColumns(CriaColumns(OemToAnsi( STR0350 ),3,,0,nSzNrPag,"oBrowse")) 		//"Número de Pagamento"
    oBrowse:SetColumns(CriaColumns(OemToAnsi( STR0351 ),4,,0,nSzRot,"oBrowse")) 		//"Roteiro"
	oBrowse:SetColumns(CriaColumns(OemToAnsi( STR0352 ),5,,0,nSzDtPg,"oBrowse", "D")) 	//"Data de Pagamento"
    oBrowse:SetColumns(CriaColumns(OemToAnsi( STR0353 ),6,,0,nSzDtFec,"oBrowse", "D")) 	//"Data de Fechamento"

	oBrowse:SetArray(aArrayGrup)
    oBrowse:SetSeek( , aSeek)
    oBrowse:Activate()

    oModal:Activate()

    // ---------------------------------------------------------------------------
    // Atribuo o valor selecionado ao conteúdo de retorno da consulta específica
    // ---------------------------------------------------------------------------
    If lRet
        If Len(aArrayGrup) > 0
			If nRetorno == 1
            	M->TRF_PERPARA := aArrayGrup[oBrowse:nAt][2]
			ElseIf nRetorno == 2
				M->TRF_NROPARA := aArrayGrup[oBrowse:nAt][3]
			EndIf
        EndIf
    EndIf

Return lRet

/*/{Protheus.doc} fAhgoraTransf
Geração das informações da transferência para integração com Ahgora
@since	16/09/2024
@autor	Bruno Costa
@version 1.0
/*/
Static Function fAhgoraTransf(dDTransf, lTemRUM)
Local aArea		  := GetArea()
Local aCodInterno := {}
Local cTab        := ""
Local __cEmpAnte  := ""
Local __cFilAnte  := ""
Local cVldPonto   := SuperGetMv("MV_INTEGPW",, "1")
Local cChave      := cEmpAnt + "|" + cFilDe + "|" + cMatDe
Local lAhgDest    := .F.
Local lAborta     := .F.

If cVldPonto <> "1"
	If !GPEAhGora():fAhgoraPW(cVldPonto)
		Return .F.
	EndIf
EndIf

If lEmpDif
	__cEmpAnte 	:= cEmpAnt
	__cFilAnte 	:= cFilAnt
	lAhgDest	:= totvs.framework.company.getParameter(cEmpAte,cFilAte,"MV_RHAHGOR")
	If lAhgDest
		aAdd(aCodInterno, {cFilAte, cMatAte, __cEmpAnte+__cFilAnte+cMatDe, "A", cEmpAte+cFilAte+cMatAte, dDTransf, .T., cEmpAte})
		cChave := __cEmpAnte + "|" + __cFilAnte + "|" + cMatDe + "|SRE|" + cEmpAte + "|" + cFilAte + "|" + cMatAte
		cTab   := "SRE"
		GPEAhGora():gravaRUMTransf("I", cTab, cChave, aCodInterno, @lAborta, @lTemRUM)
	EndIf
ElseIf lFilDif
	aAdd(aCodInterno, {cFilAte, cMatAte, cEmpAnt+cFilDe+cMatDe, "A", cEmpAnt+cFilAte+cMatAte, dDTransf, .F.})
	cChave := cEmpAnt + "|" + cFilDe + "|" + cMatDe + "|SRE|" + cEmpAnt + "|" + cFilAte + "|" + cMatAte
	cTab   := "SRE"
ElseIf lCcDif .Or. lDeptoDif
	aAdd(aCodInterno, {cFilDe, cMatDe, cEmpAnt+cFilDe+cMatDe, Nil, Nil, "A"})
	cChave := cEmpAnt + "|" + cFilDe + "|" + cMatDe
	cTab   := "SRA"
	GPEAhGora():gravaRUM("I", cTab, cChave, aCodInterno, "1")
EndIf

If !Empty(cTab) .And. cTab != "SRA" .And. !lEmpDif
	GPEAhGora():gravaRUMTransf("I", cTab, cChave, aCodInterno, @lAborta)
EndIf

RestArea(aArea)

Return lAborta


/*/{Protheus.doc} fGrvTIU
Geração da tabela TIU (Gestão Disciplinar) na Empresa/Filial Destino
@since	05/11/2024
@autor	raquel.andrade
@version 1.0
/*/
Static Function fGrvTIU(cTITFil, cTITMat, cTITCod, cTITNew)
Local oStat1		:= Nil
Local aConteudo		:= {}
Local aStruct		:= TIU->( dbStruct() )
Local cNewAlias		:= IF( lEmpDif , ( "GPE"+"TIU" ) , "TIU" )
Local cCampo		:= ""
Local cDataType		:= ""
Local cQuery		:= ""
Local cAliasQry		:= GetNextAlias()
Local nNumCamp 		:= Len(aStruct)
Local nCampo		:= 0
Local nX			:= 0
Local uValor

Default cTITFil		:= ""
Default cTITMat		:= ""
Default cTITCod		:= ""
Default cTITNew		:= ""

	If oStat1 == Nil
		oStat1 := FWPreparedStatement():New()
		cQuery := "SELECT TIU.* "
		cQuery += "FROM " + RetSqlName('TIU') + " TIU "
		cQuery += "INNER JOIN "+ RetSqlName('TIT') + " TIT ON TIT.TIT_FILIAL = TIU.TIU_FILIAL  AND TIT.TIT_CODIGO = TIU.TIU_CODTIT "
		cQuery += "WHERE TIT.TIT_FILIAL = ? "
		cQuery +=	"AND TIT.TIT_CODIGO = ? "
		cQuery +=	"AND TIT.TIT_MAT = ? "
		cQuery += 	"AND TIT.D_E_L_E_T_ = ? "
		cQuery += 	"AND TIU.D_E_L_E_T_ = ? "
		cQuery += "ORDER BY TIU.TIU_FILIAL, TIU.TIU_CODTIT "
		cQuery := ChangeQuery(cQuery)
		oStat1:SetQuery(cQuery)
	EndIf

	oStat1:SetString(1, cTITFil)
	oStat1:SetString(2, cTITCod)
	oStat1:SetString(3, cTITMat)
	oStat1:SetString(4, ' ')
	oStat1:SetString(5, ' ')
	cQuery := oStat1:getFixQuery()
	dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasQry,.T.,.T.)

	While (cAliasQry)->(!EoF())
		For nCampo := 1 To nNumCamp
			cCampo 		:= FieldName(nCampo)
			cDataType	:= FWSX3Util():GetFieldType( cCampo )
			uValor		:= FieldGet(nCampo)
			aAdd(aConteudo,{cCampo,uValor,cDataType})
		Next nCampo
		(cAliasQry)->(DbSkip())
	EndDo
	(cAliasQry)->(dbCloseArea())

	If Len(aConteudo) > 0
		// Lock como inclusão pois conteúdo da Chave da tabela
		// é gerado com Controle de Numeração
		// TIU_FILIAL+TIU_CODTIT+TIU_CODIGO
		RecLock( cNewAlias , .T.)

		// Grava o aConteudo origem na Empresa/Filial Destino
		nConteudo := Len(aConteudo)
		For nCampo := 1 To nConteudo
			// Monta nome do Campo
			cCampo := aConteudo[nCampo,1]

			// Verifica se Campo existe na Empresa Destino
			If cCampo == "R_E_C_N_O_" .Or.  cCampo == "R_E_C_D_E_L_" .Or. cCampo == 'TIU_USERLGA' .Or. cCampo == 'TIU_USERLGI'
				cTypeCampo	:= Type(cCampo)
			Else
				cTypeCampo	:= ValType(&cCampo)
			EndIf

			If ( cTypeCampo == aConteudo[nCampo,3] )

				FieldPut( FieldPos ( cCampo ) , aConteudo[nCampo,2] )

				If AllTrim(cCampo) == "TIU_FILIAL"
					( cNewAlias )->( TIU_FILIAL ) :=  cFilAte
				ElseIf  Alltrim(CCAMPO) == 'TIU_CODTIT'
					( cNewAlias )->( TIU_CODTIT ) := cTITNew
				ElseIf AllTrim(cCampo) == "TIU_CODIGO"
					uValor := GETSXENUM("TIU","TIU_CODIGO")
					( cNewAlias )->( TIU_CODIGO ) :=  uValor
				EndIf
			EndIf

		Next nCampo

		( cNewAlias )->(ConfirmSx8())

		( cNewAlias )->( MsUnlock() )
	EndIf

Return

/*/{Protheus.doc} reintegrad
Retorna se o funcionário foi reintegrado
@since	28/11/2024
@autor	martins.marcio
@version 1.0
/*/
Static Function reintegrad(cFilEnv, cStat2298)
	Local lRet	:= .F.
	Local aArea	:= GetArea()

	Default cFilEnv		:= SRA->RA_FILIAL
	Default cStat2298	:= "-1"

	If !lMiddleware
		If 	SRA->RA_SITFOLH <> 'D' .And. Empty(SRA->RA_DEMISSA) .And. !Empty(SRA->RA_DTEFRET)
			//2 - CMF_FILIAL + CMF_FUNC(AllTrim(SRA->RA_CIC)+SRA->RA_CODUNIC)+DTOS(CMF_DTRET) + CMF_ATIVO
			cStat2298 := TAFGetStat( "S-2298", AllTrim(SRA->RA_CIC) + SRA->RA_CODUNIC + ";" + DTOS(SRA->RA_DTEFRTN) + ";" + "1", , cFilEnv, 2)
			If cStat2298 <> "-1"
				lRet := .T.
			EndIf
		EndIf
	EndIf

	RestArea(aArea)
Return lRet

/*/{Protheus.doc} fChkSRK
Verifica se funcionário possui Valores Futuros com mesmo número de documento
@since	25/02/2025
@autor	raquel.andrade
@version 1.0
/*/
Static Function fChkSRK( aLog, cFilDe, cMatDe)
Local aDupl			:= {}
Local cQuery		:= ""
Local cAliasQry		:= GetNextAlias()
Local oStat1		:= Nil
Local lDuplSRK		:= .F.
Local nX			:= 0

Default aLog		:= {}
Default cFilDe		:= ""
Default cMatDe		:= ""

	If oStat1 == Nil
		oStat1 := FWPreparedStatement():New()
		cQuery := "SELECT SRK.RK_FILIAL, SRK.RK_MAT , SRK.RK_PD , SRK.RK_DOCUMEN "
		cQuery += "FROM " + RetSqlName('SRK') + " SRK "
		cQuery += "WHERE SRK.RK_FILIAL = ? "
		cQuery +=	"AND SRK.RK_MAT = ? "
		cQuery += 	"AND SRK.D_E_L_E_T_ = ? "
		cQuery += "GROUP BY RK_FILIAL, RK_MAT, RK_PD, RK_DOCUMEN HAVING COUNT(RK_DOCUMEN) > 1"
		cQuery := ChangeQuery(cQuery)
		oStat1:SetQuery(cQuery)
	EndIf

	oStat1:SetString(1, cFilDe)
	oStat1:SetString(2, cMatDe)
	oStat1:SetString(3, ' ')
	cQuery := oStat1:getFixQuery()
	dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasQry,.T.,.T.)

	While (cAliasQry)->(!EoF())
			aAdd(aDupl,{ (cAliasQry)->RK_FILIAL, (cAliasQry)->RK_MAT,  (cAliasQry)->RK_PD ,  (cAliasQry)->RK_DOCUMEN } )
		(cAliasQry)->(DbSkip())
	EndDo
	(cAliasQry)->(dbCloseArea())

	If Len(aDupl) > 0
		For nX := 1 To Len(aDupl)
			// "Filial: " + "Matrícula: " + "Verba: " + "Nro. de Documento: "
			aAdd( aLog , OemToAnsi(STR0369) + RTrim(aDupl[nX][1]) + " "  + ;
						 OemToAnsi(STR0370) + RTrim(aDupl[nX][2]) + " "  + ;
						 OemToAnsi(STR0371) + RTrim(aDupl[nX][3]) + " "  + ;
						 OemToAnsi(STR0372) + RTrim(aDupl[nX][4])  )
		Next nX
		lDuplSRK := .T.
	EndIF


Return( lDuplSRK )

/*/{Protheus.doc} fConRHTURN
Função especifica para retornar o Turno de Trabalho.
@author  Raquel Hager Lopes de Andrade
@since   19/08/2025
@version V 1.0
/*/
Function fConRHTURN()
Local lRet          As Logical
Local bOk           As Block
Local bCancel       As Block
Local aSeek         As Array
Local oModalPanel   As Object
Local oPanelGrid    As Object
Local aArrayGrup    As Array
Local cEnvQuery     As Character
Local nSzTurn		As Numeric
Local nSzDsTurn		As Numeric
Local cFilSR6		As Character
Local lMsBlql		:= SR6->( FieldPos( "R6_MSBLQL" ) ) != 0
Local cEmpSR6		:= cEmpAte
Local aStrSR61 		:= FWSX3Util():GetFieldStruct( "R6_TURNO" )
Local aStrSR62 		:= FWSX3Util():GetFieldStruct( "R6_DESC" )

Private oBrowse     As Object
Private oModal      As Object

    lRet        := .T.
    bOk         := {||lRet := .T., oModal:oOwner:End()}
    bCancel     := {||lRet := .F., oModal:oOwner:End()}
    aSeek       := {}
    aArrayGrup  := {}
	nSzTurn		:= aStrSR61[3]
	nSzDsTurn	:= aStrSR62[3]

	cEmpSR6			:= 	cEmpAte
	If lEmpDif
		cFilSR6		:= totvs.framework.company.xEmpFil("SR6", cEmpSR6 , cFilAte)
	Else
		cFilSR6		:= FwxFilial("SR6",cFilAte)
	EndIf

    oModal := FWDialogModal():New()

    oModal:SetFreeArea(300, 200)
    oModal:createDialog()
    oModal:SetEscClose(.T.)
    oModal:AddButton( OemToAnsi( STR0338 ), bOk, OemToAnsi( STR0338 ), , .T., .F., .T., {|| .T.}) 	//OK
    oModal:AddButton( OemToAnsi( STR0339 ), bCancel, OemToAnsi( STR0339 ), , .T., .F., .T., ) 		//Cancelar

    oModalPanel := oModal:GetPanelMain()

    oPanelGrid := TPanel():New(0, 0, "", oModalPanel, ,,,,, 0, 0)

    oPanelGrid:Align := CONTROL_ALIGN_ALLCLIENT

    cEnvQuery := "SELECT DISTINCT R6_TURNO, R6_DESC "
    cEnvQuery += "FROM "+RetFullName("SR6",cEmpSR6)+" SR6 "
    cEnvQuery += "WHERE "
	If !Empty(cFilSR6)
		cEnvQuery += "SR6.R6_FILIAL = '"+cFilSR6+"' AND "
	EndIf
	If lMsBlql
		cEnvQuery += "SR6.R6_MSBLQL <> '1' AND "
	EndIF
    cEnvQuery += "SR6.D_E_L_E_T_=' ' "
    cEnvQuery += "ORDER BY R6_TURNO, R6_DESC "

    cAliasQry := GetNextAlias()
    DbUseArea(.T., "TOPCONN", TcGenQry(,,cEnvQuery), cAliasQry, .T., .T.)

    (cAliasQry)->(DbGoTop())

    While (cAliasQry)->(!EOF())
        aAdd(aArrayGrup, {(cAliasQry)->(R6_TURNO), (cAliasQry)->(R6_DESC) })

        (cAliasQry)->(DbSkip())
    EndDo

    (cAliasQry)->(DbCloseArea())

    Aadd( aSeek, { OemToAnsi( STR0336 ) , {{"","C",nSzDsTurn,0,OemToAnsi( STR0336 )}}, 1, .T. } ) //"Código"
    Aadd( aSeek, { OemToAnsi( STR0337 ) , {{"","C",nSzDsTurn,0,OemToAnsi( STR0337 )}}, 1, .T. } ) //"Descrição"

    oBrowse := FWBrowse():New(oPanelGrid)

    oBrowse:SetDescription(OemToAnsi( STR0373 )) //"Turnos de Trabalho"
    oBrowse:SetDataArray()
    oBrowse:DisableFilter()
    oBrowse:DisableConfig()
    oBrowse:SetColumns(CriaColumns(OemToAnsi( STR0336 ),1,,0,nSzTurn,"oBrowse")) //"Código"
    oBrowse:SetColumns(CriaColumns(OemToAnsi( STR0337 ),2,,0,nSzDsTurn,"oBrowse")) //"Descrição"
    oBrowse:SetArray(aArrayGrup)
    oBrowse:SetSeek( , aSeek)
    oBrowse:Activate()

    oModal:Activate()

    // Atribuo o valor selecionado ao conteúdo de retorno da consulta específica
    If lRet
        If Len(aArrayGrup) > 0
            M->RA_TNOTRAB := aArrayGrup[oBrowse:nAt][1]
        Else
            M->RA_TNOTRAB := ""
        EndIf
    EndIf

Return lRet

/*/{Protheus.doc} Vld180Turno
Valida o Código de Turno informado.
@author raquel.andrade
@since 19/08/2025
@version 1.0
/*/
Function Vld180Turno()
Local aArea		:= GetArea()
Local lRet		:= .T.

	If ( lEmpDif )	// Tabela SR6 já está aberta na Empresa Destino pela Ch_Emp()
		__cFil  := totvs.framework.company.xEmpFil("SR6", cEmpAte, cFilAte)
	Else
		__cFil  := FwxFilial( "SR6" , cFilAte )
	EndIf

	dbSelectArea("SR6")
	DbSetOrder(1) // R6_FILIAL+R6_TURNO
	If !(SR6->( dbSeek(__cFil + M->RA_TNOTRAB , .F. )))
		//"Turno inválido!"###Código de Turno informado não existe."###"Verificar o cadastro de Turnos de Trabalho ou selecionar um Código de Turno da consulta."
		Help(,,OemToAnsi(STR0374),,OemToAnsi(STR0375)  ,1,0, NIL, NIL, NIL, NIL, NIL, {OemToAnsi(STR0376)} )
		lRet	:= .F.
	EndIf

	RestArea(aArea)

Return lRet

/*/{Protheus.doc} fConRHFUNC
Função especifica para retornar o Código da Função.
@author  Raquel Hager Lopes de Andrade
@since   19/08/2025
@version V 1.0
/*/
Function fConRHFUNC()
Local lRet          As Logical
Local bOk           As Block
Local bCancel       As Block
Local aSeek         As Array
Local oModalPanel   As Object
Local oPanelGrid    As Object
Local aArrayGrup    As Array
Local cEnvQuery     As Character
Local nSzFunc		As Numeric
Local nSzDsFunc		As Numeric
Local cFilSRJ		As Character
Local lMsBlql		:= SR6->( FieldPos( "R6_MSBLQL" ) ) != 0
Local cEmpSRJ		:= cEmpAte
Local aStrSRJ1 		:= FWSX3Util():GetFieldStruct( "RJ_FUNCAO" )
Local aStrSRJ2 		:= FWSX3Util():GetFieldStruct( "RJ_DESC" )

Private oBrowse     As Object
Private oModal      As Object

    lRet        := .T.
    bOk         := {||lRet := .T., oModal:oOwner:End()}
    bCancel     := {||lRet := .F., oModal:oOwner:End()}
    aSeek       := {}
    aArrayGrup  := {}
	nSzFunc		:= aStrSRJ1[3]
	nSzDsFunc	:= aStrSRJ2[3]

	cEmpSRJ			:= 	cEmpAte
	If lEmpDif
		cFilSRJ		:= totvs.framework.company.xEmpFil("SRJ", cEmpSRJ , cFilAte)
	Else
		cFilSRJ		:= FwxFilial("SRJ",cFilAte)
	EndIf

    oModal := FWDialogModal():New()

    oModal:SetFreeArea(300, 200)
    oModal:createDialog()
    oModal:SetEscClose(.T.)
    oModal:AddButton( OemToAnsi( STR0338 ), bOk, OemToAnsi( STR0338 ), , .T., .F., .T., {|| .T.}) 	//OK
    oModal:AddButton( OemToAnsi( STR0339 ), bCancel, OemToAnsi( STR0339 ), , .T., .F., .T., ) 		//Cancelar

    oModalPanel := oModal:GetPanelMain()

    oPanelGrid := TPanel():New(0, 0, "", oModalPanel, ,,,,, 0, 0)

    oPanelGrid:Align := CONTROL_ALIGN_ALLCLIENT

    cEnvQuery := "SELECT DISTINCT RJ_FUNCAO  , RJ_DESC "
    cEnvQuery += "FROM "+RetFullName("SRJ",cEmpSRJ)+" SRJ "
    cEnvQuery += "WHERE "
	If !Empty(cFilSRJ)
		cEnvQuery += "SRJ.RJ_FILIAL = '"+cFilSRJ+"' AND "
	EndIf
	If lMsBlql
		cEnvQuery += "SRJ.RJ_MSBLQL <> '1' AND "
	EndIF
    cEnvQuery += "SRJ.D_E_L_E_T_=' ' "
    cEnvQuery += "ORDER BY RJ_FUNCAO , RJ_DESC "

    cAliasQry := GetNextAlias()
    DbUseArea(.T., "TOPCONN", TcGenQry(,,cEnvQuery), cAliasQry, .T., .T.)

    (cAliasQry)->(DbGoTop())

    While (cAliasQry)->(!EOF())
        aAdd(aArrayGrup, {(cAliasQry)->(RJ_FUNCAO), (cAliasQry)->(RJ_DESC) })

        (cAliasQry)->(DbSkip())
    EndDo

    (cAliasQry)->(DbCloseArea())

    Aadd( aSeek, { OemToAnsi( STR0336 ) , {{"","C",nSzDsFunc,0,OemToAnsi( STR0336 )}}, 1, .T. } ) //"Código"
    Aadd( aSeek, { OemToAnsi( STR0337 ) , {{"","C",nSzDsFunc,0,OemToAnsi( STR0337 )}}, 1, .T. } ) //"Descrição"

    oBrowse := FWBrowse():New(oPanelGrid)

    oBrowse:SetDescription(OemToAnsi( STR0377 )) //"Função"
    oBrowse:SetDataArray()
    oBrowse:DisableFilter()
    oBrowse:DisableConfig()
    oBrowse:SetColumns(CriaColumns(OemToAnsi( STR0336 ),1,,0,nSzFunc,"oBrowse")) //"Código"
    oBrowse:SetColumns(CriaColumns(OemToAnsi( STR0337 ),2,,0,nSzDsFunc,"oBrowse")) //"Descrição"
    oBrowse:SetArray(aArrayGrup)
    oBrowse:SetSeek( , aSeek)
    oBrowse:Activate()

    oModal:Activate()

    // Atribuo o valor selecionado ao conteúdo de retorno da consulta específica
    If lRet
        If Len(aArrayGrup) > 0
            M->RA_CODFUNC := aArrayGrup[oBrowse:nAt][1]
        EndIf
    EndIf

Return lRet

/*/{Protheus.doc} Vld180Func
Valida o Código de Função informado.
@author raquel.andrade
@since 19/08/2025
@version 1.0
/*/
Function Vld180Func()
Local aArea		:= GetArea()
Local lRet		:= .T.
Local cFilSRJ	:= ""

	If ( lEmpDif )	// Tabela SR6 já está aberta na Empresa Destino pela Ch_Emp()
		cFilSRJ  := totvs.framework.company.xEmpFil("SRJ", cEmpAte, cFilAte)
	Else
		cFilSRJ  := FwxFilial( "SRJ" , cFilAte )
	EndIf

	dbSelectArea("SRJ")
	DbSetOrder(1) // RJ_FILIAL+RJ_FUNCAO
	If !(SRJ->( dbSeek(cFilSRJ + M->RA_CODFUNC , .F. )))
		//"Código de Função inválido!"###Código de Função informado não existe."###"Verificar o cadastro de Funções ou selecionar um Código de Turno da consulta."
		Help(,,OemToAnsi(STR0378),,OemToAnsi(STR0379)  ,1,0, NIL, NIL, NIL, NIL, NIL, {OemToAnsi(STR0380)} )
		lRet	:= .F.
	EndIf

	RestArea(aArea)

Return lRet

/*/{Protheus.doc} function fSX7DsFunc
Função que retorna descrição da Função executada pelo gatilho (SX7).
@author  raquel.andrade
@since   31/03/2022
@version V 1.0
/*/
Function fSX7DsFunc()
Local cChave := ""

If FunName() == "GPEA180"
	If lEmpDif
		cChave	:= totvs.framework.company.xEmpFil("SRJ", cEmpAte, cFilAte) + M->RA_CODFUNC
	Else
		cChave	:= FwxFilial("SRJ",cFilAte) + M->RA_CODFUNC
	EndIf
Else
	cChave	:= fWxFilial("SRJ")+ M->RA_CODFUNC
EndIf

Return cChave

/*/{Protheus.doc} fConRHREG
Função especifica para retornar o Código da Regra.
@author  Raquel Hager Lopes de Andrade
@since   19/08/2025
@version V 1.0
/*/
Function fConRHREG()
Local lRet          As Logical
Local bOk           As Block
Local bCancel       As Block
Local aSeek         As Array
Local oModalPanel   As Object
Local oPanelGrid    As Object
Local aArrayGrup    As Array
Local cEnvQuery     As Character
Local nSzRegr		As Numeric
Local nSzDsRegr		As Numeric
Local cFilSPA		As Character
Local lMsBlql		:= SPA->( FieldPos( "PA_MSBLQL" ) ) != 0
Local cEmpSPA		:= cEmpAte
Local aStrSPA1 		:= FWSX3Util():GetFieldStruct( "PA_CODIGO" )
Local aStrSPA2 		:= FWSX3Util():GetFieldStruct( "PA_DESC" )

Private oBrowse     As Object
Private oModal      As Object

    lRet        := .T.
    bOk         := {||lRet := .T., oModal:oOwner:End()}
    bCancel     := {||lRet := .F., oModal:oOwner:End()}
    aSeek       := {}
    aArrayGrup  := {}
	nSzRegr		:= aStrSPA1[3]
	nSzDsRegr	:= aStrSPA2[3]

	cEmpSPA			:= 	cEmpAte
	If lEmpDif
		cFilSPA		:= totvs.framework.company.xEmpFil("SPA", cEmpSPA , cFilAte)
	Else
		cFilSPA		:= FwxFilial("SPA",cFilAte)
	EndIf

    oModal := FWDialogModal():New()

    oModal:SetFreeArea(300, 200)
    oModal:createDialog()
    oModal:SetEscClose(.T.)
    oModal:AddButton( OemToAnsi( STR0338 ), bOk, OemToAnsi( STR0338 ), , .T., .F., .T., {|| .T.}) 	//OK
    oModal:AddButton( OemToAnsi( STR0339 ), bCancel, OemToAnsi( STR0339 ), , .T., .F., .T., ) 		//Cancelar

    oModalPanel := oModal:GetPanelMain()

    oPanelGrid := TPanel():New(0, 0, "", oModalPanel, ,,,,, 0, 0)

    oPanelGrid:Align := CONTROL_ALIGN_ALLCLIENT

    cEnvQuery := "SELECT DISTINCT PA_CODIGO  , PA_DESC "
    cEnvQuery += "FROM "+RetFullName("SPA",cEmpSPA)+" SPA "
    cEnvQuery += "WHERE "
	If !Empty(cFilSPA)
		cEnvQuery += "SPA.PA_FILIAL = '"+cFilSPA+"' AND "
	EndIf
	If lMsBlql
		cEnvQuery += "SPA.PA_MSBLQL <> '1' AND "
	EndIF
    cEnvQuery += "SPA.D_E_L_E_T_=' ' "
    cEnvQuery += "ORDER BY PA_CODIGO , PA_DESC "

    cAliasQry := GetNextAlias()
    DbUseArea(.T., "TOPCONN", TcGenQry(,,cEnvQuery), cAliasQry, .T., .T.)

    (cAliasQry)->(DbGoTop())

    While (cAliasQry)->(!EOF())
        aAdd(aArrayGrup, {(cAliasQry)->(PA_CODIGO), (cAliasQry)->(PA_DESC) })
        (cAliasQry)->(DbSkip())
    EndDo

    (cAliasQry)->(DbCloseArea())

    Aadd( aSeek, { OemToAnsi( STR0336 ) , {{"","C",nSzDsRegr,0,OemToAnsi( STR0336 )}}, 1, .T. } ) //"Código"
    Aadd( aSeek, { OemToAnsi( STR0337 ) , {{"","C",nSzDsRegr,0,OemToAnsi( STR0337 )}}, 1, .T. } ) //"Descrição"

    oBrowse := FWBrowse():New(oPanelGrid)

    oBrowse:SetDescription(OemToAnsi( STR0381 )) //"Regra de Apontamento"
    oBrowse:SetDataArray()
    oBrowse:DisableFilter()
    oBrowse:DisableConfig()
    oBrowse:SetColumns(CriaColumns(OemToAnsi( STR0336 ),1,,0,nSzRegr,"oBrowse")) //"Código"
    oBrowse:SetColumns(CriaColumns(OemToAnsi( STR0337 ),2,,0,nSzDsRegr,"oBrowse")) //"Descrição"
    oBrowse:SetArray(aArrayGrup)
    oBrowse:SetSeek( , aSeek)
    oBrowse:Activate()

    oModal:Activate()

    // Atribuo o valor selecionado ao conteúdo de retorno da consulta específica
    If lRet
        If Len(aArrayGrup) > 0
            M->RA_REGRA := aArrayGrup[oBrowse:nAt][1]
        EndIf
    EndIf

Return lRet


/*/{Protheus.doc} Vld180Regr
Valida o Código de Regra de Apontamento informado.
@author raquel.andrade
@since 19/08/2025
@version 1.0
/*/
Function Vld180Regr()
Local aArea		:= GetArea()
Local lRet		:= .T.
Local cFilSPA	:= ""

	If ( lEmpDif )	// Tabela SPA já está aberta na Empresa Destino pela Ch_Emp()
		cFilSPA  := totvs.framework.company.xEmpFil("SPA", cEmpAte, cFilAte)
	Else
		cFilSPA  := FwxFilial( "SPA" , cFilAte )
	EndIf

	dbSelectArea("SPA")
	DbSetOrder(1) // PA_FILIAL+PA_CODIGO
	If !(SPA->( dbSeek(cFilSPA + M->RA_REGRA , .F. )))
		//"Regra de Apontamento inválida!"###Código de Regra de Apontamento informado não existe."###"Verificar o cadastro de Regra de Apontamento ou selecionar um Código de Turno da consulta."
		Help(,,OemToAnsi(STR0382),,OemToAnsi(STR0383)  ,1,0, NIL, NIL, NIL, NIL, NIL, {OemToAnsi(STR0384)} )
		lRet	:= .F.
	EndIf

	RestArea(aArea)

Return lRet

/*/{Protheus.doc} fConRHSQT
Função especifica para retornar o Sequencial Turno.
@author  Raquel Hager Lopes de Andrade
@since 19/08/2025
@version V 1.0
/*/
Function fConRHSQT()
Local lRet          As Logical
Local bOk           As Block
Local bCancel       As Block
Local aSeek         As Array
Local oModalPanel   As Object
Local oPanelGrid    As Object
Local aArrayGrup    As Array
Local cEnvQuery     As Character
Local nSzTurn		As Numeric
Local nSzSeqSm		As Numeric
Local cFilSPJ		As Character
Local lMsBlql		:= SPJ->( FieldPos( "PJ_MSBLQL" ) ) != 0
Local cEmpSPJ		:= cEmpAte
Local aStrSPJ1 		:= FWSX3Util():GetFieldStruct( "PJ_TURNO" )
Local aStrSPJ2 		:= FWSX3Util():GetFieldStruct( "PJ_SEMANA" )

Private oBrowse     As Object
Private oModal      As Object

    lRet        := .T.
    bOk         := {||lRet := .T., oModal:oOwner:End()}
    bCancel     := {||lRet := .F., oModal:oOwner:End()}
    aSeek       := {}
    aArrayGrup  := {}
	nSzTurn		:= aStrSPJ1[3]
	nSzSeqSm	:= aStrSPJ2[3]

	cEmpSPJ			:= 	cEmpAte
	If lEmpDif
		cFilSPJ		:= totvs.framework.company.xEmpFil("SPJ", cEmpSPJ , cFilAte)
	Else
		cFilSPJ		:= FwxFilial("SPJ",cFilAte)
	EndIf

    oModal := FWDialogModal():New()

    oModal:SetFreeArea(300, 200)
    oModal:createDialog()
    oModal:SetEscClose(.T.)
    oModal:AddButton( OemToAnsi( STR0338 ), bOk, OemToAnsi( STR0338 ), , .T., .F., .T., {|| .T.}) 	//OK
    oModal:AddButton( OemToAnsi( STR0339 ), bCancel, OemToAnsi( STR0339 ), , .T., .F., .T., ) 		//Cancelar

    oModalPanel := oModal:GetPanelMain()

    oPanelGrid := TPanel():New(0, 0, "", oModalPanel, ,,,,, 0, 0)

    oPanelGrid:Align := CONTROL_ALIGN_ALLCLIENT

    cEnvQuery := "SELECT DISTINCT PJ_TURNO   , PJ_SEMANA "
    cEnvQuery += "FROM "+RetFullName("SPJ",cEmpSPJ)+" SPJ "
    cEnvQuery += "WHERE "
	If !Empty(cFilSPJ)
		cEnvQuery += "SPJ.PJ_FILIAL = '"+cFilSPJ+"' AND "
	EndIf
	If !Empty(M->RA_TNOTRAB)
		cEnvQuery += "SPJ.PJ_TURNO = '"+M->RA_TNOTRAB+"' AND "
	EndIf
	If lMsBlql
		cEnvQuery += "SPJ.PJ_MSBLQL <> '1' AND "
	EndIF
    cEnvQuery += "SPJ.D_E_L_E_T_=' ' "
    cEnvQuery += "ORDER BY PJ_TURNO  , PJ_SEMANA "

    cAliasQry := GetNextAlias()
    DbUseArea(.T., "TOPCONN", TcGenQry(,,cEnvQuery), cAliasQry, .T., .T.)

    (cAliasQry)->(DbGoTop())

    While (cAliasQry)->(!EOF())
        aAdd(aArrayGrup, {(cAliasQry)->(PJ_TURNO), (cAliasQry)->(PJ_SEMANA) })
        (cAliasQry)->(DbSkip())
    EndDo

    (cAliasQry)->(DbCloseArea())

    Aadd( aSeek, { OemToAnsi( STR0337 ) , {{"","C",nSzSeqSm,0,OemToAnsi( STR0337 )}}, 1, .T. } ) //"Sequência"

    oBrowse := FWBrowse():New(oPanelGrid)

    oBrowse:SetDescription(OemToAnsi( STR0385 )) //"Sequência Inicial Turno"
    oBrowse:SetDataArray()
    oBrowse:DisableFilter()
    oBrowse:DisableConfig()
    oBrowse:SetColumns(CriaColumns(OemToAnsi( STR0373 ),1,,0,nSzTurn,"oBrowse")) //"Turno de Trabalho"
    oBrowse:SetColumns(CriaColumns(OemToAnsi( STR0385 ),2,,0,nSzSeqSm,"oBrowse")) //"Seq. Início Turno"
    oBrowse:SetArray(aArrayGrup)
    oBrowse:SetSeek( , aSeek)
    oBrowse:Activate()

    oModal:Activate()

    // Atribuo o valor selecionado ao conteúdo de retorno da consulta específica
    If lRet
        If Len(aArrayGrup) > 0
            M->RA_SEQTURN := aArrayGrup[oBrowse:nAt][2]
        EndIf
    EndIf

Return lRet

/*/{Protheus.doc} Vld180Seq
Valida a Seq. Início de Turno informado.
@author raquel.andrade
@since 19/08/2025
@version 1.0
/*/
Function Vld180Seq()
Local aArea		:= GetArea()
Local lRet		:= .T.
Local cFilSPJ	:= ""

	If ( lEmpDif )	// Tabela SPA já está aberta na Empresa Destino pela Ch_Emp()
		cFilSPJ  := totvs.framework.company.xEmpFil("SPJ", cEmpAte, cFilAte)
	Else
		cFilSPJ  := FwxFilial( "SPJ" , cFilAte )
	EndIf

	dbSelectArea("SPJ")
	DbSetOrder(1) // PJ_FILIAL+PJ_TURNO+PJ_SEMANA+PJ_DIA
	If !(SPJ->( dbSeek(cFilSPJ + M->RA_TNOTRAB + M->RA_SEQTURN , .F. )))
		//"Seq. Início de Turno inválida!"###"Seq. Início de Turno não existe."###"Verificar o cadastro de Seq. Início de Turno ou selecionar uma Seq. Início de Turno da consulta."
		Help(,,OemToAnsi(STR0386),,OemToAnsi(STR0387)  ,1,0, NIL, NIL, NIL, NIL, NIL, {OemToAnsi(STR0388)} )
		lRet	:= .F.
	EndIf

	RestArea(aArea)

Return lRet

/*/{Protheus.doc} Vld180SX5
Valida TIpo de Alteração Salarial
@author raquel.andrade
@since 19/08/2025
@version 1.0
/*/
Function Vld180SX5()
Local aArea		:= GetArea()
Local lRet		:= .T.
Local cFilSX5	:= ""

	If ( lEmpDif )	// Tabela SPA já está aberta na Empresa Destino pela Ch_Emp()
		cFilSX5  := totvs.framework.company.xEmpFil("SX5", cEmpAte, cFilAte)
	Else
		cFilSX5  := FwxFilial( "SX5" , cFilAte )
	EndIf

	dbSelectArea("SX5")
	DbSetOrder(1) // X5_FILIAL+X5_TABELA+X5_CHAVE
	If !(SX5->( dbSeek(cFilSX5 + "41" + M->RA_TIPOALT , .F. )))
		//"Tipo de alteração inválida!"###"Tipo de Alteração Salarial não existe."###"Verificar os registros da Tabela Genérica 41 através do Módulo SIGACFG."
		Help(,,OemToAnsi(STR0389),,OemToAnsi(STR0390)  ,1,0, NIL, NIL, NIL, NIL, NIL, {OemToAnsi(STR0391)} )
		lRet	:= .F.
	EndIf

	RestArea(aArea)

Return lRet
