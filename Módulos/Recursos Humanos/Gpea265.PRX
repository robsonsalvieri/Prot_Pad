#INCLUDE "PROTHEUS.CH"
#INCLUDE "GPEA265.CH"
#INCLUDE "FILEIO.CH"

#Define Confirma 1
#Define Redigita 2
#Define Abandona 3

Static lGpe10Menu	:= ExistBlock( "GPE10MENU" )
Static lPort1510	:= Port1510() //Verifica se Portaria 1510/2009 esta em vigor.
Static cContrMat	:= StrTran(SuperGetMv("MV_MATRICU",NIL,"0"),'"','')
//Integração do TAF
Static lIntTAF		:= ((SuperGetMv("MV_RHTAF",, .F.) == .T.) .AND. Val(SuperGetMv("MV_FASESOC",/*lHelp*/,' ')) >= 1 )
Static lMiddleware	:= If( cPaisLoc == 'BRA' .AND. Findfunction("fVerMW"), fVerMW(), .F. )
Static cNTSV		:= SuperGetMv("MV_NTSV",,"")
Static cNovaMat     := ""

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡ao    ³ Gpea265  ³ Autor ³ Andreia dos Santos    ³ Data ³  16.07.02  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Cadastramento de Autonomos                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³         ATUALIZACOES SOFRIDAS DESDE A CONSTRU€AO INICIAL.               ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Programador  ³Data      ³BOPS/FNC        ³  Motivo da Alteracao                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ³±±
±±³Carlos E. O. ³09/01/2014³M12RH01         ³Inclusao do fonte na P12, retirada de      ³±±
±±³             ³          ³RQ007           ³funcoes nao mais utilizadas para ajustar   ³±±
±±³             ³          ³                ³dicionario, etc.                           ³±±
±±³Cecilia Carv.³10/04/2014³9097/2014       ³Ajuste para correcao das alteracoes efetua ³±±
±±³             ³          ³TPCJMG          ³das na ordem de apresentacao das opcoes do ³±±
±±³             ³          ³                ³menu.                                      ³±±
±±³Alberto M    ³03/11/2014³TQYMYT          ³Ajustes para que os campos nao usados nao  ³±±
±±³             ³          ³                ³aparecam nas telas de incluir, visualizar, ³±±
±±³             ³          ³                ³alterar e selecionar campos.               ³±±
±±³Alberto M    ³06/11/2014³TQYMYT          ³Inclusao da funcao fRetX3Usado e alteracao ³±±
±±³             ³          ³                ³na validacao de campos usados na funcao    ³±±
±±³             ³          ³                ³Gp265Dic.                                  ³±±
±±³Allyson M.   ³16/10/2015³TTPMJ1			³Ajuste p/ integracao com o TSA p/ gerar o  ³±±
±±³             ³          ³                ³codigo unico do funcionario.				³±±
±±³Cícero Alves ³05/08/2016³TVNVM9          ³Adicionado o campo RA_CATFUNC para permitir³±±
±±³			    ³		   ³ 		        ³o castro de pró-labore (categoria P)		³±±
±±³Marcos Cout. ³09/05/2017³DRHESOCP-225    ³Realizar a geração do evento S-2300        ³±±
±±³             ³          ³                ³Compatibilização do eSocial p layout 2.2.01³±±
±±³Marcos Cout. ³12/05/2017³DRHESOCP-249    ³Realizar a geração do evento S-2306        ³±±
±±³             ³          ³                ³Compatibilização do eSocial p layout 2.2.01³±±
±±³Marcos Cout. ³13/06/2017³DRHESOCP-404    ³Realizar o ajuste para chamada do evento   ³±±
±±³             ³          ³                ³S2300. (Mudou de fIntTSV para fInt2300)    ³±±
±±³Marcos Cout  ³20/07/2017³DRHESOCP-403    ³Realizado ajustes necessários para que o   ³±±
±±³             ³          ³                ³evento S-2205 seja gerado corretamente p/  ³±±
±±³             ³          ³                ³para registros de Trabalhador S Vinculos   ³±±
±±³Cícero Alves ³01/09/2017³DRHPAG-256      ³Inclusao de msg para cadastro do historico ³±±
±±³             ³          ³                ³de contratos, Autonomo Residen. Exterior   ³±±
±±³Marcos Cout  ³29/09/2017³DRHESOCP-1374   ³Colocando tratativa para cVersEnvio para q ³±±
±±³             ³          ³                ³não seja gerado ErrorLog ao cair na valida_³±±
±±³             ³          ³                ³ção fGp10Esoci. Removendo a regra de SITFOL³±±
±±³             ³          ³                ³ <> "D". Ajustando regra p geração da exclu³±±
±±³             ³          ³                ³_são do S2399. Ajuste na po_               ³±±
±±³             ³          ³                ³sição dos parametros do evento S-2399      ³±±
±±³Cecília C.   ³03/10/2017³DRHPAG-1367     ³Ajuste para emitir mensagem da integração  ³±±
±±³             ³          ³                ³com TAF no envio do evento S-2300.         ³±±
±±³Marco A. Glez³04/10/2017³ TSSERMI01-166  ³Se localizan las funciones fBtnRD0/fGrvRD0 ³±±
±±³             ³          ³                ³y funcionalidad detonada a partir de para- ³±±
±±³             ³          ³                ³metro MV_RHTAF. (MEX)                      ³±±
±±³Eduardo Vi   ³06/10/2017³DRHESOCP-1447   ³Inclusão de chamada de funçao fInt2399     ³±±
±±³Cecília Carv ³08/01/2018³DRHESOCP-2682   ³Ajuste para geração de contrato intermiten-³±±
±±³             ³          ³                ³te - evento S-2200.                        ³±±
±±³Marcos Cout. ³16/02/2017³DRHESOCP-3618   ³Realizando ajuste na chave de pesquisa trab³±±
±±³             ³          ³                ³sem vinculo (TSV)                          ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function Gpea265(aRotAuto, nOpc)

LOCAL cFiltraSRA			//Variavel para filtro
LOCAL aIndexSRA		:= {}		//Variavel Para Filtro
LOCAL cOrgCfg		:= GetMv("MV_ORGCFG", NIL, "0")
LOCAL lItemClVl 	:= SuperGetMv( "MV_ITMCLVL", .F., "2" ) $ "13"
LOCAL lIncItClVl	:= .T.
LOCAL cCpoNoShow	:= 'RA_FILIAL'
Local aSRANotFields := {}
Local bSkip			:= { || .F. }
Local nI			:= 0
Local aAcho			:= {}
Local cVersGPE		:= ""

Private bFiltraBrw	:= {|| Nil}		//Variavel para Filtro
Private aDicio		:= {}
Private aDicioT		:= {}			//Array contendo os campos do SX3
Private aDicioW		:= {} 			//Array auxiliar do aDicioT
Private nAgrup		:= 01
Private nCampo		:= 0
Private cAltSal		:= Getmv("MV_ALTSAL")
Private FocoAnterior:= ""

Private lSetCentury := __SetCentury("on")
Private lGp265Auto 	:=	(aRotAuto <> Nil)

Private cIncRD0		:= GetMvRH( "MV_AUTPART", .F., "3" ) // 1-Pergunta se incluiu RD0;2-Sempre inclui;3-Nunca incluiu
Private cCodUnic	:= ""
Private aRetGPE		:= array(2)
Private aRetTAF		:= array(2)
Private cVersEnvio	:= ""
Private cMatUnica	:= SuperGetMV("MV_MATUNIC",.F.,"")
Private cMatIni		:= SuperGetMV("MV_MATAUT",.F.,"900000")
Private cFuncAnt	:= ""
Private nSalAnt		:= 0
Private lAltSal		:= .F.

// Informa usuário sobre compartilhamento indevido na SRA
If fR33SRA()
	Return
EndIf

If Type("lMsErroAuto") <> "L"
	lMsErroAuto := .F.
EndIf

If lIntTaf .Or. lMiddleware
	If( FindFunction("fVersEsoc") )
		fVersEsoc("S2300", .F., @aRetGPE, @aRetTAF, @cVersEnvio, @cVersGPE)
	Else
		cVersEnvio := "2.2"
		aRetGPE := {.F., ""}
		aRetTAF := {.F., ""}
	EndIf

	If FindFunction("ESocMsgVer") .And. !lMiddleware .And. cVersGPE <> cVersEnvio .And. (cVersGPE >= "9.0" .Or. cVersEnvio >= "9.0")
		//"Atenção! A versão do leiaute GPE é xxx e a do TAF é xxx, sendo assim, estão divergentes. O Evento xxx não será integrado com o TAF, e consequentemente, não será enviado ao RET.
		//Caso prossiga a informação será atualizada somente na base do GPE. Deseja continuar?"
		If ESocMsgVer(.F.,"S-2300/S-2306/S-2205", cVersGPE, cVersEnvio)
			lIntTaf := .F.
		Else
			Return
		EndIf
	EndIf
EndIf

Default lGpe10Menu := ExistBlock( "GPE10MENU" )

_SetOwnerPrvt(	"aSraFields"	, {} )
_SetOwnerPrvt(	"aSraAltera" 	, {} )
_SetOwnerPrvt(	"aSraNaoAlt" 	, {} )
_SetOwnerPrvt(	"aSraVirtual"	, {} )
_SetOwnerPrvt(	"aSraVisual" 	, {} )
_SetOwnerPrvt(	"aSraHeader" 	, {} )
_SetOwnerPrvt(	"aSraCols" 		, {} )
_SetOwnerPrvt(	"aSvSraCols"	, {} )

If lGp265Auto
	Private aGp265Auto 	:=	aClone(aRotAuto)
EndIf

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Se Portaria estiver ativada, verifica se base esta OK		   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
If lPort1510
	If !fVerBasePort()
		Break
	EndIf
EndIf

If !lItemClVl
	cCpoNoShow += '/RA_ITEM/RA_CLVL'
EndIf

//--Monta o Array com os Campos do sx3 e quando usado marca com x
SX3->(dbSetOrder(1))
SX3->(dbSeek("SRA"))
While SX3->(! Eof()) .And. SX3->X3_ARQUIVO = 'SRA'
	uCampo := SX3->X3_CAMPO
	If Alltrim(uCampo) $ cCpoNoShow .or. ;
	  (__lPyme	.and. SX3->X3_PYME="N" )
		SX3->(dbSkip())
		loop
	Endif

   	lIncItClVl	:= .T.
	// Remove ou insere os campos RA_ITEM e RA_CLVL conforme o conteudo do paramentro MV_ITMCLVL
   	If ! lItemClVl
		If AllTrim(SX3->X3_CAMPO) == "RA_ITEM" .OR. AllTrim(SX3->X3_CAMPO) == "RA_CLVL"
	   		lIncItClVl	:= .F.
	   	EndIf
	EndIf

	nCampo := nCampo + 1
	If lIncItClVl
		If cPaisLoc=="BRA"
			Aadd(aDicioT, X3Titulo()+Space(14)+CHR(179)+"["+If (X3USO(SX3->X3_USADO),"X"," ")+"]"+Space(5)+SX3->X3_CAMPO+Space(3)+STRZERO(SX3->X3_TAMANHO,3)+STRZERO(SX3->X3_DECIMAL,2)+ strzero(nAgrup,2)+ Strzero(nCampo,3) )
		Else
			If X3USO(SX3->X3_USADO)
				Aadd(aDicioT, X3Titulo()+Space(14)+CHR(179)+"["+If (X3USO(SX3->X3_USADO),"X"," ")+"]"+Space(5)+SX3->X3_CAMPO+Space(3)+STRZERO(SX3->X3_TAMANHO,3)+STRZERO(SX3->X3_DECIMAL,2)+ strzero(nAgrup,2)+ Strzero(nCampo,3) )
			Endif
		Endif
	EndIf
	SX3->(dbSkip())
Enddo

//--Funcao Para atualizar a configuracao da ficha
f265Conf()

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Define array contendo as Rotinas a executar do programa      ³
//³ ----------- Elementos contidos por dimensao ------------     ³
//³ 1. Nome a aparecer no cabecalho                              ³
//³ 2. Nome da Rotina associada                                  ³
//³ 3. Usado pela rotina                                         ³
//³ 4. Tipo de Transa‡„o a ser efetuada                          ³
//³    1 - Pesquisa e Posiciona em um Banco de Dados             ³
//³    2 - Simplesmente Mostra os Campos                         ³
//³    3 - Inclui registros no Bancos de Dados                   ³
//³    4 - Altera o registro corrente                            ³
//³    5 - Remove o registro corrente do Banco de Dados          ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
PRIVATE aRotina := MenuDef() // ajuste para versao 9.12 - chamada da funcao MenuDef() que contem aRotina
//-- Adiciona opcoes ao menu
If lGpe10Menu
	ExecBlock("GPE10MENU",.F.,.F.)
EndIf

cCadastro := OemToAnsi(STR0011)  //"Cadastro de Autonomos"

If lMiddleware .And. !ChkFile("RJE")
	Help( " ", 1, OemToAnsi(STR0037),, OemToAnsi(STR0038), 1, 0 )//"Tabela RJE não encontrada. Execute o UPDDISTR - atualizador de dicionário e base de dados."
	Return
EndIf

If lGp265Auto
	aSvRotSetOpc := aRotSetOpc( NIL , NIL , nOpc )
	nPos := Ascan(aRotAuto,{|x| Alltrim(x[1]) == "RA_FILIAL"})
	If nPos > 0
		If FWFilExist(,aRotAuto[nPos,2])
			cFilAnt := aRotAuto[nPos,2]
		Else
			Break
		EndIf
	EndIf

	dbSelectArea("SRA")

	Begin Transaction
		If nOpc == 4
			// Salva o conteúdo atual (Gravado na SRA) dos campos passados no aRotAuto
			SaveMenVar(aRotAuto)
			nPosMat := Ascan(aRotAuto,{|x| Alltrim(x[1]) == "RA_MAT"})
			SRA->(dbSeek(cFilAnt + aRotAuto[nPosMat][2]))
			RegToMemory("SRA", .F., .F., .F., "GPEA265")

			For nI := 1 To Len(aGp265Auto)
				//Carrega os campos e seu conteúdo na memória
				If aGp265Auto[nI,1] <> "RA_FILIAL"
					SetMemVar( aGp265Auto[nI,1], aGp265Auto[nI,2], .T. )
				Endif

				/* caso queira alterar o nome do aut via execauto*/
				if aGp265Auto[nI,1] == "RA_NOME" .AND. !EMPTY(aGp265Auto[nI,2]) .AND. SRA->RA_NOME <> aGp265Auto[nI,2]
					SRA->(dbSeek(cFilAnt + aGp265Auto[nPosMat][2]))
					SRA->(RecLock("SRA", .F.))
						SRA->RA_NOME := aGp265Auto[nI,2]
					SRA->(MsUnLOck())
				ENDIF
			Next nI

			If !Gpea265ValPE(nOpc,SRA->( Recno() ),"SRA")
				DisarmTransaction()
			EndIf
		EndIf

		Aeval(aDicioT,{|x| If(Substr(x, 29, 1) == "X", Aadd(aAcho, Subs(x, 36, 10)), "")})

		MsRotAuto(nOpc, aRotAuto, "SRA", aAcho )

		If nOpc == 4
			RstMenVar()
		EndIf
	End Transaction

Else
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Inicializa o filtro utilizando a funcao FilBrowse.                     ³
	//³ Somente serao apresentados funcionarios autonomos.                     ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	cFiltraRh := CHKRH("GPEA265","SRA","1")
	cFiltraRh += if(!empty(cFiltraRh), '.and. RA_CATFUNC $ "A|P"', 'RA_CATFUNC $ "A|P"')
	bFiltraBrw 	:= {|| FilBrowse("SRA",@aIndexSRA,@cFiltraRH) }
	Eval(bFiltraBrw)

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Endereca a funcao de BROWSE                                  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	dbSelectArea("SRA")

	mBrowse( 6, 1,22,75,"SRA",,,,,,fCriaCor() )

	//Retorna o SET EPOCH padrao do framework
	If(FindFunction( "RetPadEpoch" ))
		RetPadEpoch()
	EndIf

	If !lSetCentury
		__SetCentury("off")
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Deleta o filtro utilizando a funcao FilBrowse                     	   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	EndFilBrw("SRA",aIndexSra)
EndIf

Return

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ f265Conf ³ Autor ³ Andreia dos Santos    ³ Data ³23/07/02  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Verifica se Existe o Arquivo e Configura o array do Sx3    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ gpea265                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function f265Conf()
Local aArea	    := GetArea()
Local cFile  	:= "GpeAuton.fch"
Local aDicFch 	:= {}
Local n
Local nTamArq
Local nBuffer
Local cBuffer

If File("GpeAuton.fch")

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Le arquivo texto - Nro total de linhas     ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	nHdl    := Fopen(cfile,2+64)				//Abertura e gravacao e compartilhamento

	If nHdl <= 0
		return .f.
	EndIf
	cString	:= FReadStr(nHdl,60)
	nBuffer	:= 60
	nTamArq := fSeek(nHdl,0,2)

	fSeek(nHdl,0,0)

	nFor 	:= nTamArq / nBuffer
	cBuffer	:= space(nBuffer)

	FRead(nHdl,@cBuffer,nBuffer)

	SX3->(dbSetOrder(2))
	For n=1 to nFor
		SX3->(dbSeek(AllTrim(substr(cBuffer,36,12))))
		If!(X3USO(SX3->X3_USADO))//Caso o campo seja Nao usado, atualiza o cBuffer.
			cBuffer := Substr(cBuffer,1,28) + Space(1) + Substr(cBuffer,30,30)
		EndIf
		Aadd(aDicFch,cBuffer)
		cBuffer	:= space(nBuffer)
		FRead(nHdl,@cBuffer,nBuffer)
	Next n

	For n:= 1 to Len(aDicioT)
		nPos := Ascan(aDicFch,{ |x| Subs(x,36,10)=Subs(aDicioT[n],36,10) })
		If nPos > 0
			aDicioT[n] := Subs(ADicioT[n],1,28)+Subs(aDicFch[nPos],29,1)+']'+Subs(aDicioT[n],31,23)+Subs(aDicioT[n],54,2)+Subs(aDicioT[n],56,3)			//mantem a ordem do SX3 para ser alterada pelo usuario
		Endif
	Next n
	FClose(nHdl)
EndIf

aDicioT	:= aSort(aDicioT,,,{|x,y| Substr(x,54,2)+ Substr(x,56,3) < Substr(y,54,2)+Substr(y,56,3)})

RestArea( aArea )

Return Nil

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ Gp265Dic ³ Autor ³ Andreia dos Santos    ³ Data ³23/07/02  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Achoice para escolha do Sx3 para a ficha                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ gpea260                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function Gp265Dic()

Local cFile		:= "GpeAuton.fch"
Local cBuffer
Local cDet
Local nHdl
Local n
Local nOpt		:= 0
Local nTam
Local aDicBkp 	:= Aclone(aDicioT)
Local aCpoNAlt
Local oFont3
Local oFont
Local oFont06
Local oBtnMarcTod
Local oBtnDesmTod
Local oBtnInverte
Local oGroup1
Local bNIL			:= { || NIL }
Local bSvVK_F4		:= bNIL
Local bSvVK_F5		:= bNIL
Local bSvVK_F6		:= bNIL
Local nY

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Declaração de arrays para dimensionar tela		                         ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Local aRetCoords		:= {}

Private l1Elem		:= .F.
Private oAgrup

INCLUI = .F.

oOk := LoadBitmap( GetResources(), "Enable" )
oNo := LoadBitmap( GetResources(), "LBNO" )

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Monta array com os campos da selecao, desconsiderando   ³
//³aqueles que sempre aparecerao na tela.                  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
aDicioW := {}
Aeval(aDicioT,{ |x| If(!(ALLTRIM(substr(x,36,10))$"RA_MAT/RA_NOME/RA_CC/RA_DESCCC/RA_CIC/RA_TIPOPGT/RA_CATFUNC/RA_PROCES") .And. X3USO(fRetX3Usado(ALLTRIM(substr(x,36,10)))),;
								Aadd(aDicioW,{Subs(x,1,16),; 					//Descricao Campo
								If (Subs(x,29,1) = "X",.t.,.f.),;			//usado/nao usado
								Subs(x,36,18) , ;                          	//Campo
								Subs(x,54,2), ;						   		//Agrupamento
								Subs(x,56,3) }),"" ) })        				//Ordem

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Monta array com os campos que sempre aparecerao na tela,³
//³mesmo que nao tenham sido selecionados.                 ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
aCpoNAlt:= {}
Aeval(aDicioT,{ |x| If(ALLTRIM(substr(x,36,10))$"RA_MAT/RA_NOME/RA_CC/RA_DESCCC/RA_CIC/RA_TIPOPGT/RA_CATFUNC/RA_PROCES",;
								Aadd(aCpoNAlt,{Subs(x,1,16),; 				//Descricao Campo
								.T.,;											//usado/nao usado
								Subs(x,36,18) , ;                          	//Campo
								Subs(x,54,2), ;						   		//Agrupamento
								Subs(x,56,3) }),"" ) })        				//Ordem



cTitulo := oEmToAnsi(STR0012)   //"Dicionario"

SETAPILHA()

DEFINE FONT oFont3  NAME "Arial" BOLD
DEFINE FONT oFont   NAME "Arial" SIZE 0,-11
DEFINE FONT oFont06 NAME "Arial" SIZE 01,01

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Monta as Dimensoes dos Objetos         					   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
aRetCoords := RetCoords(1,2,0,120)
//-- Atualiza Array com os campos agrupados
DEFINE MSDIALOG oDlg4 FROM 0,0 TO 350,500 TITLE cTitulo PIXEL

	@ aRetCoords[1][1],aRetCoords[1][2] Group oGroup1 To aRetCoords[2][1]+20,240 PROMPT OemToAnsi(STR0013) Of oDlg4 Pixel COLOR CLR_BLUE  //"Selecao de Campos"

	//--ListBox do Dicionario de dados   25,30,120,150
	@ aRetCoords[1][1]+10,aRetCoords[1][2]+10 LISTBOX oUso;
			FIELDS HEADER STR0014,STR0015,Left(STR0016,5),STR0017;   //"U."###"Campos"###"Agrupamento"###"Ordem"
			SIZE 210,100 ;
			ON DBLCLICK (aDicioW:= fG265Troca(aDicioW,,oUso:nAT),oUso:Refresh(.f.) ) ;
			OF oDlg4 PIXEL
			oUso:SetArray(aDicioW)
			oUso:bLine := { || {if(aDicioW[oUso:nAt,2],oOk,oNo),OemToAnsi(aDicioW[oUso:nAt,1]),aDicioW[oUso:nAt,4],aDicioW[oUso:nAt,5] }}
			oUso:Refresh()

	//--  Botoes Usado/Nao Usado
	@ aRetCoords[2][1],aRetCoords[2][2]+10 BUTTON oBtnMarcTod	PROMPT OemToAnsi(STR0018) FONT oFont06	SIZE 65,13 OF oDlg4	PIXEL  ; //"Marca Todos <F4>"
      ACTION (aDicioW:=fG265Troca(aDicioW,"M"),oUso:Refresh())
      bSvVK_F4 := SetKey(VK_F4,{ || (aDicioW:=fG265Troca(aDicioW,"M"),oUso:Refresh()) } )

	@ aRetCoords[2][1],aRetCoords[2][2]+80 BUTTON oBtnDesmTod	PROMPT OemToAnsi(STR0019) FONT ofont06	SIZE 65,13 OF oDlg4	PIXEL ; //"Desmarca Todos <F5>"
	  ACTION (aDicioW:=fG265Troca(aDicioW,"D"),oUso:Refresh())
   	  bSvVK_F6 := SetKey(VK_F5,{ || (aDicioW:=fG265Troca(aDicioW,"D"),oUso:Refresh()) } )

	@ aRetCoords[2][1],aRetCoords[2][2]+150 BUTTON oBtnInverte	PROMPT OemToAnsi(STR0020) FONT ofont06	SIZE 65,13 OF oDlg4	PIXEL ; //"Inverte Sele‡„o <F6>"
	  ACTION (aDicioW:=fG265Troca(aDicioW,"I"),oUso:Refresh())
	  bSvVK_F6 := SetKey(VK_F6,{ || (aDicioW:=fG265Troca(aDicioW,"I"),oUso:Refresh()) } )

ACTIVATE MSDIALOG oDlg4 CENTERED ON INIT Enchoicebar(oDlg4,{|| nOpt := 1,oDlg4:End()},{|| nOpt := 3,oDlg4:End()})

SETAPILHA()

SetKey( VK_F4	,	IF( Empty( bSvVK_F4 ) , bNIL , bSvVK_F4 ) )
SetKey( VK_F5	,	IF( Empty( bSvVK_F5 ) , bNIL , bSvVK_F5 ) )
SetKey( VK_F6	,	IF( Empty( bSvVK_F6 ) , bNIL , bSvVK_F6 ) )

//--volta o Array da tela para o aDicioT para ser gravado
If nOpt == 1
	aDicioT := {}

	Aeval(aDicioW,{ |x| Aadd(aDicioT,Subs(x[1],1,12)+Space(14)+CHR(179)+"["+If (x[2],"X"," ")+"]"+Space(5)+x[3]+x[4]+x[5] )})

   	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Ajusta o tamanho do array de tela para serem inseridos ³
    //³os campos que sempre terao que aparecer.                ³
    //³ Estes campos serao inseridos nos primeiros elementos do³
    //³array de tela.                                          ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
    nTam := Len(aCpoNAlt)+len(aDicioT)
    ASize(aDicioT,nTam)
    For nY := 1 to Len(aCpoNAlt)
	    Ains(aDicioT,1)
	Next

	nY := 1
	nTam := len(aCpoNAlt)
	//-- Inclui no array de tela os campos que sempre aparecerao em tela
	For n := 1 to nTam
		aDicioT[n]:= Subs(aCpoNAlt[nY,1],1,12)+Space(14)+CHR(179)+"["+If (aCpoNAlt[nY,2],"X"," ")+"]"+Space(5)+aCpoNAlt[nY,3]+aCpoNAlt[nY,4]+aCpoNAlt[nY,5]
		nY++
    Next

Endif

DeleteObject(oOk)
DeleteObject(oNo)

//--Quando confirma grava o Arquivo .fch
If nOpt == 1
	nHdl := MSFCREATE(cFile,FC_NORMAL)
	If nHdl == -1   .or. fError() # 0
		Help(" ",1,"SAVECONS")
	Else
		For n=1 to Len(aDicioT)
			cDet	:= aDicioT[n]+Chr(13)+Chr(10)
			fWrite(nHdl,cDet,Len(cDet) )
		Next
	EndIf
	FClose(nHdl)    //Fecha arq.binario e grava no disco
Else
	aDicioT	:= Aclone(aDicBkp)
EndIf

Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFuncao    ³fG265TrocaºAutor  ³Andreia dos Santos  º Data ³  23/07/02   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Efetua a troca da selecao no ListBox                        º±±
±±º          ³(controle Usado/nao usado )                                 º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP5                                                        º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function fG265Troca( aArray,		; //Array contendo os elementos para troca
		       		   cTipo  ,		; //Tipo da Multipla Selecao "M"Marca todos ; "D" Desmarca Todos; "I" Inverte Selecao
			    	   nEstou ,		; //oUso:nAt
	                   l1Elem)        //So pode escolher um  unico elemento usado no Array (.t.)

Local nArray	:= 0
Local nX		:= 0
DEFAULT l1Elem	:= .F.

	If l1Elem
		nArray:= Len(aArray)
		For nX := 1 To nArray
			IF nX == nEstou
				aArray[nEstou,4]	:= .T.
			Else
				aArray[nX,4]		:= .F.
			EndIF
		Next nX
	    oAgrup:SetArray(aArray)
		oAgrup:bLine := { || {if(aArray[oAgrup:nAT,4],oOk,oNo),aArray[oAgrup:nAt,2],aArray[oAgrup:nAt,3]}}
	Else
		IF cTipo == "M"
			aEval( aArray , { |x,y| aArray[y,2] := .T. } )
		ElseIF cTipo == "D"
			aEval( aArray , { |x,y| aArray[y,2] := .F. } )
		ElseIF cTipo == "I"
			aEval( aArray , { |x,y| aArray[y,2] := !aArray[y,2] } )
		Else
			aArray[nEstou,2] := !aArray[nEstou,2]
		EndIF

    Endif

Return aArray

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³gp265Cad  ³ Autor ³ Andreia dos Santos    ³ Data ³ 23.07.02 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Programa de (Vis.,Inc.,Alt. e Del. de Autonomos            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ gp260Cad(ExpC1,ExpN1,ExpN2)                                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Alias do arquivo                                   ³±±
±±³          ³ ExpN1 = Numero do registro                                 ³±±
±±³          ³ ExpN2 = Numero da opcao selecionada                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ GPEACad                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
FUNCTION gp265Cad(cAlias,nReg,nOpc,aAcho,aCpos)

LOCAL nOpcA			:=0
Local cCpoFil
LOCAL nSavRec 		:= RecNo()
Local aGpea265Bt	:= {}										//Array com botões para exibição na enchoicebar
Local aSegmentos	:= {}										//Segmentos utilizados no módulo Gestao Educacional
Local nOpcGE		:= 0										//Controla a sequencia correta de opçoes para utilizacao da gravacao no SigaGE
Local bSraPosto		:= {}
Local oEnchSra		:= NIL

Local aAdvSize		:= {}
Local aInfoAdvSize	:= {}
Local aObjCoords 	:= {}
Local aObjSize		:= {}
Local nPos			:= 0

// Controle eSocial
Local cCPF	:= ""
Local cCatEFD := ""
Local cMatric	:= ""
Local lTCVori 	:= .F.
Local lTSVori 	:= .F.
Local lTCValt 	:= .F.
Local lTSValt 	:= .F.
Local cTrabVincu	:= "201*202*305*308*401*410*701*711*712*721*722*723*731*734*738*741*751*761*771*781*901*902*903" //Trabalhador sem vinculo
Local nLoops		:= 0
Local aSRANotFields := {}
Local bSkip			:= { || .F. }
// Fim de Controle eSocial
/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Variaveis utilizadas na integracao SIGAPON x TSREP		  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Local lTSREP		:= SuperGetMv( "MV_TSREP" , NIL , .F. )
Local lNewDmDev		:= SuperGetMv( "MV_IDEVTE" , , .F. ) .And. ChkFile("RU8") .And. FindFunction("fTemRU8") .And. FindFunction("fAuxRU8")
Local lAhgora		:= SuperGetMv("MV_RHAHGOR",, .F. )

Private oObjREP		:= Nil

Private cOrgCfg		:= GetMv("MV_ORGCFG", NIL, "0")				//# 1=Controla com Posto
Private lShared 	:= Empty(xFilial("RCL"))
Private cPosto
Private cKeyPosto

Private bSraShwRel	:= { || Nil }
Private bSraRelRd0	:= { || Nil }
Private cRd0Codigo	:= ""
Private lSraRelRd0	:= .F.
Private lNewRelRd0	:= .T.
Private nSraRdzOrd	:= GetRdzIndRel( "SRA" )
Private nRd0Recno	:= 0

//# Tratamento do campo RA_POSTO igual ao GPEA010
If cOrgCfg == "1"  .and. nOpc == 3
	bSraPosto := { || CursorWait(),;
					Iif(nOpc == 4, ORGXPosto(oEnchSra,.T.), .T.) ,;
					SetKey( VK_F7 , bSraPosto ),;
					CursorArrow();
					}

	aAdd( aGpea265Bt, {"MSGFORWD", bSraPosto, OemToAnsi(STR0022 + "...<F7>"), OemToAnsi(STR0023) }	)	//"Selec. Posto" ## "Posto"
EndIf

//--Limpar o Filtro para nao permitir duplicacao na validacao
If nOpc == 3
	dbSelectArea(cAlias)
	dbClearFilter()
Endif

PRIVATE uCampo

If cPaisLoc == 'BRA' .And. (nOpc == 4 .OR. nOpc == 2) .And. lNewDmDev .And. fTemRU8(SRA->RA_FILIAL, SRA->RA_MAT)
	aAdd(aGpea265Bt , { NIL,  {||fAuxRU8()}, "", OemToAnsi(STR0045)})  //"Prefixo IdeDmDev
EndIf

If lAhgora .AND. ((nOpc == 5 .And. Empty(SRA->RA_DEMISSA)) .OR. nOpc == 2)
	aAdd(aGpea265Bt, {NIL, {||fPAhgora(nOpc)}, "", OemToAnsi(STR0046)}) //Integração Ahgora"
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Verifica se esta' alterando um registro da mesma filial               ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If nOpc <> 2 .And. nOpc <> 3
	cCpoFil := Subs(cAlias,2,2)+"_FILIAL"
	IF TYPE(cCpoFil) != "U"
		If &cCpoFil != cFilial
			Help(" ",1,"A000FI")
			Return 3
		EndIf
	ENDIF
EndIf
//--Monta o array com os campos do SRA que aparecem na ficha
aAcho := {}
Aeval(aDicioT,{|x| If(Substr(x,29,1)== "X", Aadd(aAcho,Subs(x,36,10)),"") })

//--Inclusao do campo para não apresentar automaticamente os campos de usuario.
Aadd(aAcho,"NOUSER    " )

//--Adiciona no array aCpos, os campos que poderao ser editados
aCpos := {}
If ! lGp265Auto
	Aeval(aDicioT, {|x| If(SubStr(x, 36, 9) # "RA_PROCES" .Or. nOpc == 3, Aadd(aCpos, Subs(x, 36, 10)), "")})
Else
	Aeval(aDicioT, {|x| If(Substr(x, 29, 1) == "X" .And. SubStr(x, 36, 9) != "RA_PROCES", Aadd(aCpos, Subs(x, 36, 10)), "") })
EndIf

If ( nOpc == 3 )
	//Nao podera informar a matricula quando for controle de numeracao por Filial ou Empresa
	If !Empty(cContrMat) .And. cContrMat != "0"
    	nPos := aScan(aCpos,{|x| Alltrim(x) == "RA_MAT"})
    	If nPos > 0
    		adel(aCpos,nPos)
			aSize( aCpos , Len(aCpos)-1 )
    	EndIf

	EndIf
EndIf
If cPaisLoc == "BRA" .And. ( (nPos := aScan(aCpos, {|x| Alltrim(x) == "RA_CODUNIC"})) > 0 )
	aDel(aCpos, nPos)
	aSize(aCpos, Len(aCpos)-1 )
EndIf

/*?
Sintaxe: AxInclui(	cAlias,		01-Alias do arquivo
					nReg,		02-Numero do registro
					nOpc,		03-Numero da opcao selecionada
					aAcho,		04-Array com os campos a serem mostrados
					cFunc,		05-Funcao de validacao para confirmacao dos dados
					aCpos,		06-Controle da CondPad
					cTudoOk,	07-Funcao a ser chamada durante a transacao
					lF3,		08-
					cTransact,	09-
					aButtons,	10-Array com os botoes da EnchoiceBar
					aParam,		11-Array de codeblock de execucao
					aAuto,		12-Array da rotina automatica
					lVirtual,	13-Inicializa os campos virtuais?
					lMaximized,	14-
					cTela)		15-
*/

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Verifica se esta integracao com WebServices TSA                       ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If (nOpc == 3 .Or. nOpc == 5) .And. lTSREP
	oObjREP := PTSREPOBJ():New()
	oObjRep:WSReadRHExp( "SRA", 1 )
EndIF

If lGp265Auto
	If nOpc == 4
		nOpc := 5
	EndIf
EndIf

If nOpc == 3  //Inclui
	If cPaisLoc == "BRA"
		fBtnRD0(@aGpea265Bt,nOpc)
	EndIf

	Begin Transaction

		nOpca := AxInclui( cAlias,nReg,nOpc,aAcho,,aCpos,"Gpea265ValPE(nOpc,nReg,cAlias,@cCodUnic)",,,If(Len(aGpea265Bt)>0,aGpea265Bt,NIL),;
							Iif(cOrgCfg=="1",({ {|| NumMat(), ORGXPosto(oEnchSra,.T.)},{|| .T.},{|| .T.},{|| .T.} }),;
												{ {|| NumMat()},{|| .T.},{|| .T.},{|| .T.} }	), If(lGp265Auto, aGp265Auto, Nil) )
		If nOpca == 1		// Confirma
			Reclock("SRA",.F.)
				If Empty(SRA->RA_ADMISSA)
					SRA->RA_ADMISSA	:= dDataBase  //Data de Admissao
				EndIf
				//If lTSREP
				If Empty(cCodUnic)
					SRA->RA_CODUNIC := fRACodUnic()
				Else
					SRA->RA_CODUNIC := cCodUnic
				EndIf
				//EndIf
				//Salvar em branco mesmo que o parametro MV_SIGAGFP esteja ativo (2 ou 3)
				SRA->RA_REGIME := " "
			SRA->(MsUnLock())
			cCodUnic := ""

			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³SIGAORG - Se usa controle de postos, criar movimentacao de ocupacao de   ³
			³posto, como selcionado no inicio da rotina ?? nome da funcao			  ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			If cOrgCfg == "1" //#.and. nOpc == 3	//# Inclusao
				dbSelectArea("RCX")
				dbSetorder(4)		//# RCX_FILIAL+RCX_FILFUN+RCX_MATFUN+RCX_POSTO
				cPosto		:= SRA->RA_POSTO
				cKeyPosto	:= xFilial("RCX") + SRA->(RA_FILIAL + RA_MAT + RA_POSTO)

				dbSelectArea("SRA")
				OrgGpe265Grv(nOpc)
			EndIf

			If lTSREP

				/*/
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Carrega os campos alterados para analise da integracao WebServices TSA ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
				oObjRep:WSReadRHExp( "SRA", 2 )

				/*/
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Executa o WebServices TSA - Pessoa Fisica e Usuarios         ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
				If oObjREP:WSNatural( 1 ) .And. oObjREP:WSUser( 1 )
					oObjRep:WSUpdRHExp( "SRA" )
				Endif

			EndIF

			If cPaisLoc == "BRA"
				fGrvRD0( nOpc ) // Atualiza cadastro de participantes(RD0)
			EndIf

			If !lGp265Auto .And. lAhgora
				fPAhgora(nOpc)
			EndIf
		EndIf

	End Transaction

	//# Limpa a tecla F7
	If cOrgCfg == "1"  //#.and. nOpc == 3
		SetKey( VK_F7 , { || NIL })
	EndIf
ElseIf nOpc == 5 //Altera
	If cPaisLoc == "BRA"
		fBtnRD0(@aGpea265Bt,nOpc)
	EndIf
	aSraCols	:= SRA->( GdBuildCols( @aSraHeader , @nLoops , @aSraVirtual , @aSraVisual, "SRA", aSRANotFields,,,,, bSkip ) )
	aSvSraCols	:= aClone( aSraCols )

	nOpca := AxAltera(cAlias,nReg,nOpc,aAcho,aCpos,,,"Gpea265ValPE(nOpc,nReg,cAlias)","fAtuAutRD0()",,If(Len(aGpea265Bt)>0,aGpea265Bt,NIL),,If(lGp265Auto, aGp265Auto, Nil),,.T.)

	Begin Transaction
		Reclock("SRA",.F.)
		if Empty(SRA->RA_CODUNIC)
			SRA->RA_CODUNIC := fRACodUnic()
		EndIf
		MsUnLock()
	End Transaction

	If nOpca == 1

		If lTSREP
			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Carrega os campos alterados para analise da integracao WebServices TSA ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			oObjRep:WSReadRHExp( "SRA", 2 )

			/*/
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Verifica se houve alteracoes nos campos de integracao WebServices TSA ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			If oObjRep:WSChkRHExp( "SRA" )
				/*/
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Executa o WebServices TSA - Pessoa Fisica e Usuarios         ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
				If oObjREP:WSNatural( 1 ) .And. oObjREP:WSUser( 1 )
					oObjRep:WSUpdRHExp( "SRA" )
				Endif

			Endif

		EndIF

		If (lIntTAF .Or. lMiddleware) .AND. (Findfunction("fGP26SRA")) .And. cPaisLoc == "BRA"
			aSraCols	:= SRA->( GdBuildCols( @aSraHeader , @nLoops , @aSraVirtual , @aSraVisual, "SRA", aSRANotFields,,,,, bSkip ) )

			If nOpc == 5
				cCPF	:= SRA->RA_CIC //Sempre enviaremos o original, esperaremos
				cMatric	:= SRA->RA_MAT

				//nao pode alterar a categoria do esocial
				//tem que terminar um vinculo e começar outroa
				cCatEFD := SRA->RA_CATEFD
			EndIf
			//													  Alterado   Cabec		Original
			fGP26SRA(cCPF, cCatEFD, cMatric, 4, "GPEA010",NIL,aSraCols,aSraHeader, aSvSraCols )
		EndIf

		If lAhgora
			aSraCols := SRA->( GdBuildCols( @aSraHeader , @nLoops , @aSraVirtual , @aSraVisual, "SRA", aSRANotFields,,,,, bSkip ) )
			If fVerAltAhgora(aSraHeader, aSvSraCols, aSraCols)
				fDadosAhgora(nOpc) //Função para gravar dados na tabela de integração com Ahgora
			EndIf
		EndIf

	Endif

ElseIf nOpc == 2 //Visual
	If cPaisLoc == "BRA"
		fBtnRD0(@aGpea265Bt,nOpc)
	EndIf
	nOpca := AxVisual(cAlias,nReg,nOpc,aAcho,,,,If(Len(aGpea265Bt)>0,aGpea265Bt,NIL))
ElseIf nOpc == 6 //Exclui

	aAdvSize		:= MsAdvSize()
	aInfoAdvSize	:= { aAdvSize[1] , aAdvSize[2] , aAdvSize[3] , aAdvSize[4] , 0 , 0 }
	aAdd( aObjCoords , { 000 , 000 , .T. , .T. } )
	aObjSize		:= MsObjSize( aInfoAdvSize , aObjCoords )

	gp010dele(cAlias,nReg,nOpc-1,aAcho,.F.,,aObjSize)

	Eval(bFiltraBrw)
Endif

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Integracao Protheus X RM Classis Net (RM Sistemas)³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
if GetNewPar("MV_CLASSIS", .F.) .And. FindFunction("ClsQryDat") .and. ( nOpc == 3 .or. nOpc == 5 ) .and. nOpca == 1 //Somente executa a procedure na inclusao e alteracao, pois na exclusao a procedure eh chamada atraves do fonte GPEA010
	//Efetua inclusao de registros na tabela INT_FUNC (Tabela de integracao de professores)
	//referente a Integracao do Protheus x RM Classis Net (RM Sistemas)
	ClsIncPrf(if(nOpc == 3,"I",if(nOpc==5,"U","D")), "GPE265")
endif

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Integracao PIMS GRAOS                             ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If( nOpc == 3 .or. nOpc == 5 ) .And. nOpca == 1 // Somente envia para o EAI quando for Inclusão ou alteração
	If SuperGetMV("MV_PIMSINT",.F.,.F.) .And. FindFunction("PIMSGeraXML")
		PIMSGeraXML("Employee",STR0011,"2","SRA") //-- ## Cadastro de autonomos
	EndIf
	If FwHasEAI("GPEA010", .T.,, .T.)
		RegToMemory("SRA", .F., .F.)
		FwIntegDef("GPEA010")
	EndIf
EndIf

dbSelectArea("SRA")

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Realiza a gravacao do responsavel no arquivo utilizado  |
//|pelos modulos do Quality Celerina, caso haja integracao.|
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If ( nOpc == 3 .Or. nOpc == 5 ) .And. nOpca == 1		//Inclui / Altera
	QA_QUALITY()

	dbSelectArea("SRA")
EndIf

If nOpc == 3
	dbSetOrder(1)
	//--Restaurar Filtro Inicial
	Eval(bFiltraBrw)
Endif

dbGoTo(nSavRec)

If !Empty(cNovaMat)
	Leave1Code(cNovaMat)
EndIf

Return

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³Gpea265ValPE()³Autor³Tania Bronzeri       ³ Data ³27/04/2006³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Validacao ponto entrada de Inclusao/Alteracao de Autonomo   ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³Gpea265ValPE()												³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³                                                         	³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³lRet														³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<void>														³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function Gpea265ValPE(nOpc,nReg,cAliasN,cCodUnic)
	Local aTpAlt
	Local nOpcAux 		//nOpc Auxiliar
	Local lTroca  		// Valida ou nao uso do campo RA_ANTEAUM
	Local lRet			:= .T.
	Local cMsg 			:= ""
	Local cTrabSemVinc	:= fCatTrabEFD("TSV") //"201|202|305|308|401|410|701|711|712|721|722|723|731|734|738|741|751|761|771|781|901|902|903" //Trabalhador sem vinculo
	Local lIntegra		:= .T.
	Local cVersaoEnv	:= ""
	Local cCatTSV		:= If(Empty(cNTSV), "701|711|712|741|", cNTSV )
	Local cCpf			:= ""
	Local cStatus		:= "-1"
	Local lTSREP
	Local lGravaHist    := SuperGetMv( "MV_HSTSAL" , NIL , .F. )
	Local cEFDAviso		:= If(cPaisLoc == 'BRA' .And. Findfunction("fEFDAviso"), fEFDAviso(), SuperGetMv("MV_EFDAVIS",, "0")) //Integracao com TAF)
	Local cStat2300		:= ""
	Local lGeraMat		:= SRA->(ColumnPos("RA_DESCEP")) > 0
	Local cGeraMat		:= If(lGeraMat, M->RA_DESCEP, "")
	Local cRetf2300		:= "1"

	Default nOpc 		:= 4
	Default cCodUnic	:= ""

	Private lUsaAnteAum	:= 	.F.

	// Checa a opção selecionada
	aRotSetOpc( cAliasN , @nReg ,IIF(nOpc == 5 , 4, nOPC) )

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Ponto de Entrada para checar os dados de inclusao/alteracao  |
	//³ de Autonomos. O retorno deve ser logico (.T. ou .F.)         |
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If ExistBlock("Gp265ValPE")
		lRet := ExecBlock("Gp265ValPE",.F.,.F.)
	EndIf

	//Valida o preenchimento de caracteres especiais na matricula (RA_MAT)
	If lRet .and. ( nOpc == 3 .Or. nOpc == 7 ) .And. FindFunction("fVldMatEsp")
		lRet := fVldMatEsp(M->RA_MAT)
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Integracao Protheus X RM Classis Net (RM Sistemas)³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lRet .and. GetNewPar("MV_CLASSIS", .F.)
		If Empty(M->RA_CODTIT)
			If "A" $ GetMv("MV_ACCATPR") //A=Autonomo
				//Obriga o preenchimento do campo RA_CODTIT, caso o funcionario seja um professor
				MsgAlert(STR0024) //A Titulação deve ser informada para funcionário que exerce a função de professor.
				lRet := .F.
			ElseIf "A" $ alltrim(GetNewPar("MV_GPCFUPR", "")) //A=Autonomo
				//Pergunta ao usuario se eh um funcionario que tambem exerce a funcao de professor
			    if MsgYesNo(STR0025) //Esse funcionário exerce a função de professor?
					//Obriga o preenchimento do campo RA_CODTIT, caso o funcionario seja um professor
					MsgAlert(STR0024) //A Titulação deve ser informada para funcionário que exerce a função de professor.
					lRet := .F.
				EndIf
			EndIf
		EndIf
	EndIf

	//Mensagen para cadastro do Residente no exterior no Historico de Contrato
	If cPaisLoc == 'BRA'
		//Se funcionario tiver sido cadastrado ou atualizado como Residente no Exterior
		If M->RA_RESEXT == "1" .And. SRA->RA_RESEXT <> M->RA_RESEXT
			cMsg := OemtoAnsi(STR0026) + CRLF		//"Para contribuintes individuais residentes no exterior, "
			cMsg += OemtoAnsi(STR0027) + CRLF		//"informar na rotina de Historico de Contratos, "
			cMsg += OemtoAnsi(STR0028) + CRLF		//"Atualizacoes/Funcionario/Historico Contrato, "
			cMsg += OemtoAnsi(STR0029) + CRLF		//"quais os impostos, IR, Dedução de INSS, "
			cMsg += OemtoAnsi(STR0030) + CRLF		//"Contribuicoes Patronais, "
			cMsg += OemtoAnsi(STR0031) + CRLF		//"deverão ser calculados para ele."
			MsgInfo(cMsg)
		EndIf
	EndIf

	//-----------------------------
	//| Realiza integração com TAF
	//-----------------------------
	If (lIntTAF .Or. lMiddleware) .And. cPaisLoc == "BRA" .And. !(M->RA_CATEFD $ cCatTSV)

		If FindFunction("fVersEsoc")
			fVersEsoc( "S2300", .F., /*aRetGPE*/, /*aRetTAF*/, @cVersaoEnv )
		Else
			cVersaoEnv := '2.2'
		EndIf

		//Realizar a validação dos campos
		If nOpc == 5
			nOpcAux := 4
			lRet1 := fGP10ENew( nOpcAux )
		ElseIf nOpc == 4
			nOpcAux := 3
			lRet1 := fGP10ENew( nOpcAux )
		ElseIf nOpc == 3
			nOpcAux := 3
			lRet1 := fGP10ENew( nOpcAux )
		EndIf

		//Se encontrar alguma inconsistencia, ele rejeita o cadastro
		If !lRet1
			lRet := .F.
		EndIf

		If !lMiddleware
			If cVersaoEnv >= "9.0"
				cCPF := AllTrim( M->RA_CIC ) + ";" + Iif(cGeraMat == "1", M->RA_CODUNIC, "") + ";" + AllTrim( M->RA_CATEFD ) + ";" + DTOS( M->RA_ADMISSA )
			Else
				cCPF := AllTrim( M->RA_CIC ) + ";" + AllTrim( M->RA_CATEFD ) + ";" + DTOS( M->RA_ADMISSA )
			EndIf
			cStatus := TAFGetStat( "S-2300", cCPF )
		Else
			cCPF := If(cVersaoEnv >= "9.0" .And. cGeraMat == "1", M->RA_CODUNIC, AllTrim( M->RA_CIC ) + AllTrim( M->RA_CATEFD ) + DTOS( M->RA_ADMISSA ))
			fPosFil( cEmpAnt, cFilAnt )
			aInfoC   := fXMLInfos()
			If LEN(aInfoC) >= 4
				cTpInsc  := aInfoC[1]
				lAdmPubl := aInfoC[4]
				cNrInsc  := aInfoC[2]
			Else
				cTpInsc  := ""
				lAdmPubl := .F.
				cNrInsc  := "0"
			EndIf
			cChaveMid	:= cTpInsc + PADR( Iif( !lAdmPubl .And. cTpInsc == "1", SubStr(cNrInsc, 1, 8), cNrInsc), 14) + "S2300" + Padr(cCPF, fTamRJEKey(), " ")
			//RJE_TPINSC+RJE_INSCR+RJE_EVENTO+RJE_KEY+RJE_INI
			GetInfRJE( 2, cChaveMid, @cStatus, , @cRetf2300 )
		EndIf

		//Se não tiver restrição, realiza a integração
		If lRet .And. !(M->RA_CATEFD $ cCatTSV)
			If ( M->RA_CATEFD $ cTrabSemVinc )
				//Se for inclusão, irá executar esta regra
				If !lGp265Auto .And. nOpc <> 5 .Or. lGp265Auto .And. nOpc <> 4

					If cVersaoEnv >= "9.0"
						If Empty(M->RA_CODUNIC) .And. Empty(cCodUnic)
							cCodUnic :=  fRACodUnic(.F.)
						EndIf
					EndIf
					lRet := fInt2300New("SRA",,nOpc,"S2300",,,cVersaoEnv,,,,,,,,,,/*cGeraMat*/"1",cCodUnic)	//Campo controle para geração de matricula com codUnico

					If lRet
						If cVersaoEnv >= "9.0" .And. lGeraMat
							M->RA_DESCEP := "1"
						EndIf
						If !lGp265Auto
							fEFDMsg()
						EndIf
					EndIf

				//
				ElseIf(M->RA_CATEFD $ cTrabSemVinc)

					lRet := fVTpAltNew(@aTpAlt, lRet, Nil, cVersaoEnv, If(lGp265Auto, aClone(aGp265Auto), Nil)) //Funcao responsavel por verificar tipo de alteracao realizada

					//Não sera permitido a alteraçao da data de admissao se o registro ja foi transmitido ao Ret
					If SRA->RA_ADMISSA <> M->RA_ADMISSA .And. lRet .And. If(lGp265Auto, nOpc == 4, nOpc == 5) .And. !lMiddleware
						If cVersaoEnv >= "9.0"
							cCPF := AllTrim( SRA->RA_CIC ) + ";" + Iif(cGeraMat == "1", SRA->RA_CODUNIC, "") + ";" + AllTrim( SRA->RA_CATEFD ) + ";" + DTOS( SRA->RA_ADMISSA )
						Else
							cCPF := AllTrim( SRA->RA_CIC ) + ";" + AllTrim( SRA->RA_CATEFD ) + ";" + DTOS( SRA->RA_ADMISSA )
						EndIf
						cStat2300 := TAFGetStat( "S-2300", cCPF )
						If cStat2300 == '4'
							Help(,,OemToAnsi(STR0037),,OemToAnsi(STR0041),1,0)//"A data de admissão não pode ser alterada, pois o registro de admissão ja foi transmitido ao Ret
							lRet := .F.
						Endif
					Endif
					//Inclusão
					//O Evento S-2300 possui a mesma sintaxe de alteração cadastral do S-2205

					If SRA->RA_DEMISSA == M->RA_DEMISSA .And. lRet
						If ( aTpAlt[1] )
							If cVersaoEnv >= "9.0"
								If cStatus <> "4" .And. ( (lMiddleware .And. cRetf2300 <>"2") .Or. (!lMiddleware .And. Empty(C9V->C9V_VERANT)) )
									cGeraMat := "1"
								ElseIf Empty(cGeraMat)	//se houve retificação, manter conforme registro original
									cGeraMat := "0"
								EndIf
							EndIf
							lRet := fInt2300New("SRA",,nOpcAux,"S2300",,,cVersaoEnv,,,,,,,,,,cGeraMat)

							If lRet .And. (lMiddleware .Or. !lMiddleware .And. C9V->C9V_NOMEVE <> "TAUTO")
								If lGeraMat .And. cVersaoEnv >= "9.0"
									M->RA_DESCEP := cGeraMat
								EndIf
								If FindFunction("fEFDMsg") .And. !lGp265Auto
									fEFDMsg()
								EndIf
							EndIf

						ElseIf (lMiddleware .Or. !lMiddleware .And. C9V->C9V_NOMEVE <> "TAUTO") .AND. cStatus <> "-1" // A tabela C9V foi posicionada na chamada da função TAFGetStat
							//Alteração Cadastral
							If ( aTpAlt[3] ) .And. M->RA_SITFOLH <> "D"
								fVersEsoc( "S2205", .F., /*aRetGPE*/, /*aRetTAF*/, @cVersaoEnv )
								lRet := fIntAdmiss("SRA",,nOpcAux,"S2205",,,,,,,cVersaoEnv)
								If lRet .And. FindFunction("fEFDMsg") .And. (lMiddleware .Or. !lMiddleware .And. C9V->C9V_NOMEVE <> "TAUTO") .And. !lGp265Auto
									fEFDMsg()
								EndIf
							EndIf

							//Alteração Contratual
							If aTpAlt[4]
								dAltSal := If( !Empty(GetMemVar("RA_DATAALT")), GetMemVar("RA_DATAALT"), Nil )
								lRet := fInt2306New("SRA", Nil, nOpcAux, "S2306", Nil, Nil, cVersEnvio, Nil, Nil, Nil, dAltSal, .T.)
								If lRet .And. FindFunction("fEFDMsg") .And. (lMiddleware .Or. !lMiddleware .And. C9V->C9V_NOMEVE <> "TAUTO") .And. !lGp265Auto
									fEFDMsg()
								EndIf
							Endif
						EndIf
					ElseIf ( SRA->RA_DEMISSA != M->RA_DEMISSA ) .And. lRet

						If !(M->RA_CATEFD $ cCatTSV) .or. ( cStatus <> "-1" .And. (M->RA_CATEFD $ cCatTSV) .AND. (lMiddleware .Or. !lMiddleware .And. C9V->C9V_NOMEVE <> "TAUTO"))
							//Verifica se o registro esta sendo demitido
							lIntegra := Iif( FindFunction("fVersEsoc"), fVersEsoc( "S2399", .T., /*aRetGPE*/, /*aRetTAF*/, @cVersEnvio ), .T.)
							cVersEnvio := Iif( Empty(cVersEnvio), "2.2",cVersEnvio)

							If ( lIntegra )
								If cStatus != "4"
									Help(,,OemToAnsi(STR0037),,OemToAnsi(STR0039),1,0)//"Registro não foi enviado pois o funcionário não foi transmitido ao RET."
									lRet := .F.
								Else
									If(!Empty( M->RA_DEMISSA ))
										lRet:= fInt2399New(/*aCols*/,/*aErros*/,"S2399",/*cCodDslg*/,"1",  /*aPd*/,/*dDataRes*/,/*cDiasInde*/,cVersEnvio, nOpcAux)
										//Valida a Demissão do funcionario
										If lRet
											M->RA_SITFOLH := "D"
										EndIf
									Else
										lRet:= fInt2399New(/*aCols*/,/*aErros*/,"S2399",/*cCodDslg*/,"1",  /*aPd*/,/*dDataRes*/,/*cDiasInde*/,cVersEnvio, 5)
									EndIf
								EndIf
							EndIf
							If lRet .And. FindFunction("fEFDMsg") .And. !lGp265Auto
								fEFDMsg()
							EndIf
						EndIf
					EndIf
				EndIf
			EndIf
		ElseIf lRet .And. M->RA_CATEFD $ cCatTSV
			IF (cStatus == "-1" .OR. (lMiddleware .Or. !lMiddleware .And. C9V->C9V_NOMEVE <> "TAUTO")) .Or. cEFDAviso == "2"
				lRet :=  .T.
			ENDIF
		EndIf
	EndIf

	// Se a ação for alteração e se o retorno da integração com o TAF deu sucesso
	IF nOpc == 5 .AND. lRet
		// Se o parâmetro para gravar histórico salarial está habilitado para os funcionários autônomos ou prolabores.
		IF lGravaHist
			// Verifica campos Tpo.Alt.Sal e Dta.AltSal
			IF !(Gp010AltSal())
				lRet := .F.
			ELSE
				// Verifica se houve alteracao de salario, funcao ou categoria
				// Verifica se campo RA_ANTEAUM existe atraves da verificacao no dicionario SX3
		    	lTroca := (ValType(GetSX3Cache('RA_ANTEAUM', 'X3_TAMANHO')) == 'N' .And. GetSX3Cache('RA_ANTEAUM', 'X3_TAMANHO') > 0 .And. lUsaAnteAum )

				If (;
						!(cPaisLoc == "RUS") .And.	;
						IsMemVar( "RA_SALARIO" ) .And. ;
						IsMemVar( "RA_CODFUNC" ) .And. ;
						IsMemVar( "RA_CATFUNC" ) .And. ;
						IsMemVar( "RA_CARGO"   ) .And. ;
						(!lTroca .Or. (lTroca .And. IsMemVar( "RA_ANTEAUM" )))  	;
					)
					If (;
							( GdFieldGet( "RA_SALARIO" , 1 , .F. , aSraHeader , aSvSraCols ) <> GetMemVar( "RA_SALARIO" ) ) .Or. ;
							( GdFieldGet( "RA_CODFUNC" , 1 , .F. , aSraHeader , aSvSraCols ) <> GetMemVar( "RA_CODFUNC" ) ) .Or. ;
							( GdFieldGet( "RA_CATFUNC" , 1 , .F. , aSraHeader , aSvSraCols ) <> GetMemVar( "RA_CATFUNC" ) ) .Or. ;
							( GdFieldGet( "RA_CARGO"   , 1 , .F. , aSraHeader , aSvSraCols ) <> GetMemVar( "RA_CARGO"   ) ) .Or. ;
							( !lTroca .Or. (lTroca .And. GdFieldGet( "RA_ANTEAUM" , 1 , .F. , aSraHeader , aSvSraCols ) <> GetMemVar( "RA_ANTEAUM" ) ))     ;
						)

						// Garante o Posicionamento no Recno de Entrada
						//SRA->( MsGoto( nReg ) )

					    If lTSREP
							If SRA->RA_CODFUNC != GetMemVar( "RA_CODFUNC" )
								oObjREP:WSUser( 3 )
							ENDIF
					    ENDIF
						If (GetMemVar("RA_SALARIO") <> SRA->RA_SALARIO .Or. GetMemVar("RA_CODFUNC") <> SRA->RA_CODFUNC .Or. ;
							GetMemVar("RA_CATFUNC") <> SRA->RA_CATFUNC .Or. GetMemVar("RA_CARGO") <> SRA->RA_CARGO )
							// Grava as Informacoes no SR3 e SR7
							fGravaSr3(GetMemVar( "RA_DATAALT" ),GetMemVar("RA_TIPOALT"),GetMemVar("RA_SALARIO"),, nOpc)
						EndIf
					ENDIF
				ENDIF
			ENDIF // END - Verifica campos Tpo.Alt.Sal e Dta.AltSal
		ENDIF // END - Verifica se o retorno da integração com o TAF não deu erro
	ENDIF // END - Se a ação for alteração e se o retorno da integração com o TAF deu sucesso

	If lRet .And. CVALTOCHAR(nOpc) $ '3/2'
		NumMat()
	EndIf
Return(lRet)

/*
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³ MenuDef		³Autor³  Luiz Gustavo     ³ Data ³07/12/2006³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Isola opcoes de menu para que as opcoes da rotina possam    ³
³          ³ser lidas pelas bibliotecas Framework da Versao 9.12 .      ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³< Vide Parametros Formais >									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Uso      ³GPEA265                                                     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Retorno  ³aRotina														³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³< Vide Parametros Formais >									³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
*/
Static Function MenuDef()
 Local aRotina :={	{ STR0004 ,"PesqBrw"  , 0 , 1,,.F.},;  		//"Pesquisar"
					{ STR0005 ,"gp265Cad" , 0 , 2},; 			//"Visualizar"
 					{ STR0006 ,"gp265Cad" , 0 , 3},; 			//"Incluir"
					{ STR0010 ,"gp265Dic" , 0 , 3},;  			//"Selec.Campos"
					{ STR0007 ,"gp265Cad" , 0 , 4},; 			//"Alterar"
					{ STR0008 ,"gp265Cad" , 0 , 5},; 			//"Excluir"
					{ STR0009 ,"gpLegend" , 0 , 5 , ,.F.} } 	//"Legenda"

If cPaisLoc == "BRA" .And. (lIntTaf .Or. lMiddleware) .And. FindFunction("GPEA941")
	aAdd(aRotina, {STR0040, "VIEWDEF.GPEA941",0,4}) //"Processos do Funcionário"
EndIf

Return aRotina

/*
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³ OrgGpe010Grv	³Autor³  Marcos Alves	  ³ Data ³30/11/07  ³
³Fun‡„o    ³ OrgGpe265Grv	³Autor³ Ademar Fernandes  ³ Data ³10/10/08  ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Integracao - SIGAORG:									    ³
³Descri‡„o ³Gravacao da movimentacao de ocupacao do posto               ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³< Vide Parametros Formais >									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Uso      ³GPEA265                                                     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³< Vide Parametros Formais >									³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
*/
Static Function OrgGpe265Grv(nOpc)
Local lDemissao		:= .F.
Local aArea			:= GetArea()
Local lRet			:= .T.
Local nGetSX8Len
Local lExistePessoa := ExistePessoa("SRA", SRA->(RA_FILIAL + RA_MAT))

If Type("cPosto") == "U"
	nSize:=	GetSx3Cache("RCL_POSTO","X3_TAMANHO" )
	_SetOwnerPrvt("cPosto", IIF(ValType(nSize) == "N", Space(nSize), Space(9) ) )
EndIf

Begin Sequence
	nGetSX8Len:= GetSX8Len()

	If (nOpc == 5)	//Alteracao
		If (GdFieldGet("RA_DEMISSA", 1, .F. , aSraHeader , aSvSraCols) <> GetMemVar( "RA_DEMISSA")) .And.;
			!Empty(GetMemVar("RA_DEMISSA")) .And.;
			(GetMemVar("RA_SITFOLH") == "D" )
			lDemissao:= .T.
		EndIf

		If lExistePessoa
			RCX->(dbSetorder(5))		//RCX_FILIAL+RCX_FILOCU+RCX_CODOCU+RCX_FILFUN+RCX_MATFUN
			cKeyPosto:= xFilial("RCX") + RD0->(RD0_FILIAL + RD0_CODIGO) + SRA->(RA_FILIAL + RA_MAT)
		Else
			RCX->(dbSetorder(4))		//RCX_FILIAL+RCX_FILFUN+RCX_MATFUN+RCX_POSTO
			cKeyPosto:= xFilial("RCX") + SRA->(RA_FILIAL + RA_MAT)
		EndIf
	EndIf

	//# RCX_FILIAL+RCX_FILFUN+RCX_MATFUN+RCX_POSTO
	If (nOpc == 3) .OR.; //Inclusao
		(nOpc == 5 .AND. !RCX->(DBSeek(cKeyPosto)) .AND. !Empty(cPosto) .AND. !lDemissao)

		If lExistePessoa
			OrgXOcupacao(SRA->RA_FILIAL, SRA->RA_MAT, cPosto, SRA->RA_ADMISSA, RD0->RD0_FILIAL, RD0->RD0_CODIGO)
		Else
			OrgXOcupacao(SRA->RA_FILIAL, SRA->RA_MAT, cPosto, SRA->RA_ADMISSA)
		EndIf

	ElseIf nOpc == 5 	//Alteracao
		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Demissao (Alteracao no cadastro)							   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		If lDemissao
			OrgXRescisao(SRA->RA_FILIAL, SRA->RA_MAT, SRA->RA_DEMISSA)
		EndIf
	EndIf

	While ( GetSX8Len() > nGetSX8Len )
		ConfirmSX8()
	End While
End Sequence

RestArea( aArea )
Return lRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFuncao    ³Gp265GrvFunºAutor ³Leandro Drumond     º Data ³  17/12/13   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Grava autonomo a partir da mensagem unica de fornecedores   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³MU Fornecedores                                             º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function Gp265GrvFun(nOpcX,cPis, cMarca, cCampo, cValExt, cAlias, cValInt)
Local aAreas   := {SRA->(GetArea()),SA2->(GetArea()),GetArea()}
Local cMatAux  := ""
Local lGPEI090 := IsInCallStack("GPEI090")
Local nCount   := 0

cPis := StrTran(cPis, "-", "")

SRA->(DbSetOrder(1))
If !Empty(cValInt) .And. SRA->(DbSeek(cValInt))
	RecLock("SRA",.F.)
 	If nOpcX <> 5
		SRA->RA_ENDEREC   := SA2->A2_END
		If cPaisLoc=="BRA"
			SRA->RA_NUMENDE   := SA2->A2_NR_END
		EndIf

		SRA->RA_BAIRRO    := SA2->A2_BAIRRO
		SRA->RA_MUNICIP   := SA2->A2_MUN
		SRA->RA_ESTADO    := SA2->A2_EST
		SRA->RA_CEP       := SA2->A2_CEP
		SRA->RA_DEPIR     := StrZero(SA2->A2_NUMDEP,TamSx3("RA_DEPIR")[1])
		SRA->RA_PIS		  := cPis
       SRA->RA_CIC       := SA2->A2_CGC
		SRA->RA_NOME      := SA2->A2_NOME
		SRA->RA_ADMISSA   := SA2->A2_DTINIV
		/* Se "demite" o autonomo e envia de novo na mensagem unica
		e preciso limpar os campos que indicam a "demissao" */
		SRA->RA_DEMISSA   := cToD("//")
  		SRA->RA_SITFOLH   := ""
		If Empty(SRA->RA_PROCES)
  			SRA->RA_PROCES 	  := '00003'
  		EndIf
  	Else
  		SRA->RA_DEMISSA := dDataBase
  		SRA->RA_SITFOLH := "D"
	EndIf
	SRA->(MsUnLOck())
ElseIf nOpcX <> 5 //Delete
	cMatAux := fProxMat()

	If lGPEI090
		RegToMemory("SRA")
	EndIf

	RecLock("SRA",.T.)
	If !lGPEI090
		SRA->RA_FILIAL    := xFilial("SRA")
		SRA->RA_MAT       := cMatAux
		SRA->RA_CIC       := SA2->A2_CGC
		SRA->RA_NOME      := SA2->A2_NOME
		SRA->RA_TIPOPGT   := "M"
		SRA->RA_CATFUNC   := "A"   //autonomo
		SRA->RA_CATEG     := "15" //Categoria de Autonomo utilizado na SEFIP.
		SRA->RA_ENDEREC   := SA2->A2_END

		If cPaisLoc=="BRA"
			SRA->RA_NUMENDE   := SA2->A2_NR_END
		EndIf

		SRA->RA_BAIRRO    := SA2->A2_BAIRRO
		SRA->RA_MUNICIP   := SA2->A2_MUN
		SRA->RA_ESTADO    := SA2->A2_EST
		SRA->RA_CEP       := SA2->A2_CEP
		SRA->RA_DEPIR     := StrZero(SA2->A2_NUMDEP,TamSx3("RA_DEPIR")[1])
		SRA->RA_ADMISSA   := SA2->A2_DTINIV
		SRA->RA_PIS       := cPis
		SRA->RA_PROCES 	  := '00003'
	Else
		For nCount := 1 To SRA->( fCount() )
			If FieldName(nCount) == "RA_FILIAL"
				SRA->RA_FILIAL := xFilial("SRA")
			ElseIf FieldName(nCount) == "RA_MAT"
				SRA->RA_MAT := cMatAux
			Else
				SRA->( FieldPut( nCount, GetMemVar( FieldName(nCount) ) ) )
			EndIf
		Next nCount
	EndIf

	SRA->(MsUnLOck())

	If !lGPEI090
		RecLock("SA2",.F.)
		SA2->A2_NUMRA := SRA->RA_MAT
		SA2->(MsUnLOck())
	EndIf


	cValInt := cEmpAnt + '|' + PadR(xFilial("SRA"), TamSX3('RA_FILIAL')[1]) + '|' + PadR(cMatAux, TamSX3('RA_MAT')[1])

	CFGA070Mnt( cMarca, "SRA", "RA_MAT", cValExt, cValInt )
EndIf

aEval(aAreas,{|x|RestArea(x)})
Return Nil

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFuncao    ³fProxMat   ºAutor ³Leandro Drumond     º Data ³  17/12/13   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Busca Proxima matricula									  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³MU Fornecedores                                             º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function fProxMat(cContrMat,lTransf)

	Local aArea	    := GetArea()
	Local cNextMat  := ""
	Local cWhere    := ""
	Local cAliasQry := GetNextAlias()
	Local cCodEmp   := FWCodEmp()
	Local cFilMat   := xFilial("SRA")
	Local cMatIni   := SuperGetMV("MV_MATAUT",.F.,"900000")
	Local cMatUnica := SuperGetMV("MV_MATUNIC",.F.,"")
	Local nX	    := 1
	Local aSM0	    := {}

	Default cContrMat	:= "1"
	Default lTransf		:= .F.

	If cContrMat == "2" .AND. fIsCorpManage(FWGrpCompany()) == .F.
		cContrMat := "3"
	EndIf

	If Empty(cMatUnica)

		If cContrMat == "1"

			If lTransf
				cWhere := "%"
				cWhere += "SRA.RA_FILIAL = '" + xFilial('SRA') + "' AND "
				cWhere += "SRA.RA_CATFUNC = 'A' "
				cWhere += "%"
			Else
				cWhere := "%"
				cWhere += "SRA.RA_FILIAL = '" + xFilial('SRA') + "' "
				cWhere += "%"
			Endif

			BeginSql alias cAliasQry
				SELECT MAX(SRA.RA_MAT) as cLastMat
				FROM %table:SRA% SRA
				WHERE %Exp:cWhere%
				AND SRA.%notDel%
			EndSql

		ElseIf cContrMat == "2"

			aSM0 := FWAllFilial(cCodEmp,,,.F.)

			For nX := 1 To Len(aSM0)
				If Empty(cWhere)
					cWhere := "SRA.RA_FILIAL IN ('"+aSM0[nX]+"'"
				Else
					cWhere += ",'"+aSM0[nX]+"'"
				EndIf
			Next

			If lTransf
				cWhere += ")" + " AND SRA.RA_CATFUNC = 'A' "
			Else
				cWhere += ")"
			Endif

			cWhere := "%" + cWhere + "%"

			BeginSql alias cAliasQry
				SELECT MAX(SRA.RA_MAT) as cLastMat
				FROM %table:SRA% SRA
				WHERE %Exp:cWhere%
				AND SRA.%notDel%
			EndSql

		ElseIf cContrMat == "3"

			cWhere := IIf(lTransf, "%SRA.RA_CATFUNC = 'A' %", "%SRA.RA_MAT <> '' %")

			BeginSql alias cAliasQry
				SELECT MAX(SRA.RA_MAT) as cLastMat
				FROM %table:SRA% SRA
				WHERE %Exp:cWhere%
				AND SRA.%notDel%
			EndSql
		EndIf

		If (cAliasQry)->(!Eof()) .AND. !Empty((cAliasQry)->cLastMat)
			cNextMat := Soma1((cAliasQry)->cLastMat)
		Else
			cNextMat := GetSx8Num("SRA", "RA_MAT")
		EndIf

		If cNextMat <= cMatIni
			cNextMat := cMatIni
		EndIf

		RestArea(aArea)

		While !MayIUseCode(cEmpAnt + cFilAnt + cNextMat)
			cNextMat := Soma1(cNextMat)
		EndDo

	//Utiliza sequencial unico para Funcionários e Autônomos
	//A nova matrícula preencherá as lacunas de matriculas faltantes
	//O conteúdo de 'cMatUnica'(MV_MATUNIC) indicará a partir de qual matrícula a busca irá começar
	ElseIf !Empty(cMatUnica)

		cMatIni	 := cMatUnica		//Matricula Anterior
		cNextMat := Soma1(cMatUnica)//Próxima Matrícula

		If cContrMat $ "1|3"

			While fExistMat(cContrMat, cNextMat)
				cMatIni	 := cNextMat
				cNextMat := Soma1(cNextMat)
			EndDo

		ElseIf cContrMat == "2"

			aSM0	:= FWAllFilial(cCodEmp,,,.F.)
			cWhere	:= ""

			For nX := 1 To Len(aSM0)
				If Empty(cWhere)
					cWhere := "SRA.RA_FILIAL IN ('"+aSM0[nX]+"'"
				Else
					cWhere += ",'"+aSM0[nX]+"'"
				EndIf
			Next

			cWhere += ")"

			While fExistMat(cContrMat, cNextMat, cWhere)
				cMatIni	 := cNextMat
				cNextMat := Soma1(cNextMat)
			EndDo

		EndIf

		RestArea(aArea)
		Do Case
			Case cContrMat == "1" //1=Automática por Filial;
				cFilMat := FWxFilial("SRA", cFilAnt, "E", "E", "E")
			Case cContrMat == "2" //2=Autom. por Empresa;
				cFilMat := FWxFilial("SRA", cFilAnt, "E", "C", "C")
			Case cContrMat == "3" //3=Autom. por Grp Empresa;
				cFilMat := FWxFilial("SRA", cFilAnt, "C", "C", "C")
		End Case

		While fExistMat(cContrMat, cNextMat, cWhere) .Or. !MayIUseCode(cEmpAnt + cFilMat + cNextMat)
			cNextMat := Soma1(cNextMat)
		EndDo

		//Atualiza o parâmetro para que na proxima execução não precise percorrer toda a SRA
		PutMv("MV_MATUNIC", cMatIni) //Salva a última matrícula existente antes do GAP

	EndIf

	cNovaMat := cEmpAnt + cFilAnt + cNextMat
Return cNextMat

/*/{Protheus.doc} fExistMat
@author martins.marcio
@since 10/02/2020
@version 1.0
@param cContrMat, characters, 1=Automática por Filial; 2=Autom. por Empresa; 3=Autom. por Grp Empresa (MV_MATRICU)
@param cNextMat, characters, Matrícula que será verificada sua existência
@param cWhereFil, characters, Filtro de Filiais quando cContrMat for igual a 2
/*/
Function fExistMat(cContrMat, cNextMat, cWhereFil)

Local lRet := .F.
Local cAliasQry := GetNextAlias()
Local cWhere	:= ""

Default cContrMat	:= "1"
Default cNextMat	:= ""
Default cWhereFil	:= ""

If cContrMat == "1"

	cWhere := " SRA.RA_FILIAL = '" + xFilial('SRA') + "' AND "
	cWhere += " SRA.RA_MAT = '" + cNextMat + "' "
	cWhere := "%" + cWhere + "%"

ElseIf cContrMat == "2"

	cWhere := cWhereFil
	cWhere += " AND SRA.RA_MAT = '" + cNextMat + "' "
	cWhere := "%" + cWhere + "%"

ElseIf cContrMat == "3"

	cWhere := " SRA.RA_MAT = '" + cNextMat + "' "
	cWhere := "%" + cWhere + "%"

EndIf

BeginSql alias cAliasQry
	SELECT COUNT(SRA.RA_MAT) as nQtdMat
	FROM %table:SRA% SRA
	WHERE %Exp:cWhere%
	AND SRA.%notDel%
EndSql

If (cAliasQry)->(!Eof())
	If (cAliasQry)->nQtdMat > 0
		lRet := .T.
	EndIf
EndIf
(cAliasQry)->(dbCloseArea())

Return lRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFuncao    ³fRetX3UsadoºAutor ³Alberto M           º Data ³  06/11/14   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Recebe um campo em formato de String, busca na SX3 e retornaº±±
±±º          ³seu campo X3_USADO, caso nao encontre retorna ""            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³GPEA265 - Cadastro de Autônomos                             º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function fRetX3Usado(cConteudo)

Local cRet   := ""
Local aArea  := GetArea()

dbSelectArea("SX3")
SX3->(dbSetOrder(2)) //Campo
//Se encontrar o campo na SX3, atribui X3_USADO para cRet.
cRet := If( SX3->(dbSeek(cConteudo)) , SX3->X3_USADO , cRet )

RestArea( aArea )

Return (cRet)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFuncao    ³NumMat     ºAutor ³                    º Data ³             º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³                                                            º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³GPEA265 - Cadastro de Autônomos                             º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function NumMat()

cMatUnica := IIf(Valtype(cMatUnica)=="C", cMatUnica	, SuperGetMV("MV_MATUNIC"	,.F. ,""))
cMatIni   := IIf(Valtype(cMatIni)  =="C", cMatIni	, SuperGetMV("MV_MATAUT"	,.F. ,"900000"))

If !Empty(cContrMat) .And. cContrMat != "0"
	If Empty(cMatUnica) .And. Empty(cMatIni)
		If cContrMat == "1"
			SetMemVar("RA_MAT", GetSx8Num("SRA", "RA_MAT"))
		ElseIf cContrMat == "2"
			SetMemVar("RA_MAT", GetSx8Num("SRA", "RA_MAT", FwCodEmp("SRA") + "\SRA\RA_MAT"))
		Else
			SetMemVar("RA_MAT", GetSx8Num("SRA", "RA_MAT", FWGrpCompany() + "\GRPEMP\SRA\RA_MAT"))
		EndIf
	Else
		SetMemVar("RA_MAT", fProxMat(cContrMat))
	EndIf
EndIf

Return .T.

/*/{Protheus.doc}fGrvRD0()
- Grava autonomo no cadastro de pessoas
@author:	Jônatas Alves
@since:		11/08/2017
@param:		nOpc - Opcao do menu
/*/
Static Function fGrvRD0( nOpc, lCriaRD0 )

	DEFAULT lCriaRD0	:= .F.

	cEndAnt 	:= SRA->RA_NUMENDE
	cLastCodRd0	:= ""
	cRd0Codigo	:= ""
	lNewRelRd0	:= .T.
	lAtuRD0		:= .F.
	nSraRdzOrd	:= GetRdzIndRel( "SRA" )
	nRd0Recno	:= 0

	SetMemVar("RA_MAT", SRA->RA_MAT, .T.)

	lSraRelRd0 := SraRelRd0( @nRd0Recno , , .T. , , @lNewRelRd0, nOpc )

	If nOpc == 3 .Or. lCriaRD0 // Inclusão
		// Obtem o Codigo do RD0
		If ( lSraRelRd0 )
			RD0->( MsGoto( nRd0Recno ) )
			cRd0Codigo := RD0->RD0_CODIGO
		Else
			Rd0GetCodigo( @cRd0Codigo , .F. )
		EndIf

		If lNewRelRd0 .And. ( cIncRD0 == "2" .Or. ( cIncRD0 == "1" .And. MsgYesNo( OemToAnsi( STR0032 ), OemToAnsi( STR0033 ) )) ) // "Relacionamento de Participantes" # "Deseja incluir o participante no cadastro de pessoas?"

			EntUpdateRd0(	cRd0Codigo							,;	//01 -> Codigo da Pessoa
							"SRA"								,;	//02 -> Entidade Relacionada
							xFilial("SRA")+GetMemVar("RA_MAT")	,;	//03 -> Chave da Entidade
							nSraRdzOrd							,;	//04 -> Ordem
							SRA->( Recno() )					,;	//05 -> Recno da Entidade
							cEmpAnt								,;	//06 -> Codigo da Empresa
							cFilAnt								,;	//07 -> Codigo da Filial
							"1"									,;	//08 -> Conteudo para o RD0_TIPO "1"=Interno;"2"=Externo
							.F.									,;	//09 -> Se Atualiza as Entidades Relacionadas
							NIL									,;	//10 -> Array com as Entidades para o Before Update
							NIL					 				,;	//11 -> Array com as Entidades para o Later Update
							NIL									,;	//12 -> Array com as Entidades para o Before Update
							NIL								 	;	//13 -> Array com as informações de Login e Senha
				  		)
		ElseIf !lNewRelRd0
			lAtuRD0 := !lNewRelRd0
		EndIf
	EndIf

	If ( nOpc == 5 .Or. lAtuRD0 ) .And. ( cIncRD0 == "2" .Or. cIncRD0 == "1" )// Alteração
		If ( lSraRelRd0 )
			RD0->( MsGoto( nRd0Recno ) )
			cRd0Codigo	:= RD0->RD0_CODIGO
			// Verifica se esta alterando relacionamento existente
			cLastCodRd0 := fGetPessoa( "SRA" , ( xFilial( "SRA" ) + GetMemVar( "RA_MAT" ) ), cEmpAnt, FwCodFil() )
			If ( cRd0Codigo <> cLastCodRd0 )
				// Exclui o antigo relacionamento
				UndoRelRdz( "SRA", cLastCodRd0 , cEmpAnt, FwCodFil() )
			EndIf
		Else
			cRd0Codigo := fGetPessoa( "SRA" , ( xFilial( "SRA" ) + GetMemVar( "RA_MAT" ) ) , cEmpAnt, FwCodFil() )
		EndIf
	EndIf
Return

/*
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Funcao    ³ SraRelRd0 	  ³ Autor ³ Marinaldo de Jesus  ³ Data ³ 05/02/04 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descricao ³ Atualiza o SR9 com as alteracoes efetuadas pela RD0.		  ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³ GPEA010                                                	  ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
Static Function SraRelRd0( nRd0Recno , aHeader , lChkPessoa , cLstCodRd0, lNewRelRd0, nOpc )
Local aSvKeys		:= GetKeys()
Local aArea 		:= GetArea()
Local aAreaRD0		:= RD0->( GetArea() )
Local aAreaSRA		:= SRA->( GetArea() )
Local cMsgErr		:= ""
Local cCic
Local cSeek
Local lSraRelRd0	:= .F.
Local lUndoRelRdz	:= .F.
Local nSraRdzOrd	:= GetRdzIndRel( "SRA" )
Local nSvRecno

DEFAULT lChkPessoa := .T.
DEFAULT lNewRelRd0 := .T.

	nRd0Recno := 0

	Begin Sequence

		If Empty( GetMemVar( "RA_MAT" ) )
			MsgInfo( OemToAnsi( "Preencha o codigo da Matricula" ) )	// "Preencha o codigo da Matricula"
			Break
		EndIf

		If ( lChkPessoa )
			If ( ExistePessoa( "SRA" , xFilial("SRA") + GetMemVar( "RA_MAT" ) , cEmpAnt , cFilAnt , .T. ) )
				cLstCodRd0 := RD0->RD0_CODIGO
	  		   	MsgInfo( OemToAnsi( "Já existe relacionamento para este funcionário." ) ) 	// "Ja existe relacionamento para este funcionario."
	  		   	lNewRelRd0 := .F.
				Break
			EndIf
		EndIf

		If ( IsMemVar( "RA_CIC" ) )
			cCic := GetMemVar( "RA_CIC" )
	        If !Empty( cCic )
				RD0->( dbSetOrder( RetOrdem( "RD0" , "RD0_FILIAL+RD0_CIC" ) ) )
				cSeek := ( xFilial( "RD0" , xFilial("SRA") ) + cCic )
				If RD0->( dbSeek( cSeek , .F. ) )
					nSvRecno := RD0->( Recno() )
					If ( RD0->RD0_MSBLQL <> "2" )
						While RD0->( !Eof() .And. ( cSeek == RD0_FILIAL + RD0_CIC ) )
							If ( RD0->RD0_MSBLQL == "2" )
								nSvRecno := RD0->( Recno() )
								Exit
							EndIf
							RD0->( dbSkip() )
						End While
					EndIf
					RD0->( MsGoto( nSvRecno ) )
					If !lGp265Auto
						If !(cPaisLoc == "RUS")
							// "O participante/A Pessoa ("####") possui o mesmo numero de ( "####") , criar relacionamento??
							lSraRelRd0 := MsgYesNo( OemToAnsi( "O participante/A Pessoa "  + " ( " + AllTrim( RD0->RD0_NOME ) + " ) " + AllTrim( "possui o mesmo numero de " + " ( " + SRA->RA_NOME ) + " ), " + "criar relacionamento?" ) )
						Else
							lSraRelRd0 := .T.
						EndIf
					Else
						lSraRelRd0 := .F.
					EndIf

					If lSraRelRd0
						//Caso seja incluido via Cadastro do Participante
						If Type("cArmCodRd0") == "U"
							Private cArmCodRd0	:= ""		// Armazena o Cod RD0 da pessoa antes de inciar a cópia
						EndIf
						If Empty(cArmCodRd0)
							cArmCodRd0 := RD0->RD0_CODIGO
							fSraSenha()
						EndIf

						nRd0Recno := nSvRecno
						RD0->( dbSetOrder( RetOrdem( "RD0" , "RD0_FILIAL+RD0_CODIGO" ) ) )
						Break
					EndIf
					If !lGp265Auto
						lNewRelRd0	:=	lSraRelRd0    // Indica que ja existe participante para o funcionario mas nao sera feito relacionamento
					EndIf
				EndIf
				RD0->( dbSetOrder( RetOrdem( "RD0" , "RD0_FILIAL+RD0_CODIGO" ) ) )
			Else
				If ( cIncRD0 == "2" .Or. cIncRD0 == "1" )
					MsgInfo( OemToAnsi( STR0034 ) + OemToAnsi( STR0035 ) + OemToAnsi( STR0036 ) )	// "CPF não informado. O relacionamento com cadastro de pessoas não será realizado. Caso deseje, efetue relacionamento através do botão 'Relacionar...<F4>' após preenchimento do CPF."
				EndIf
				lNewRelRd0:= .F.   // Nao gera relacionamento quando nao foi cadastrado o CPF
			EndIf
		ElseIf nOpc == 3 .And. Empty( SRA->RA_CIC )
			If ( cIncRD0 == "2" .Or. cIncRD0 == "1" )
				MsgInfo( OemToAnsi( STR0034 ) + OemToAnsi( STR0035 ) + OemToAnsi( STR0036 ) )	// "CPF não informado. O relacionamento com cadastro de pessoas não será realizado. Caso deseje, efetue relacionamento através do botão 'Relacionar...<F4>' após preenchimento do CPF."
			EndIf
			lNewRelRd0:= .F.   // Nao gera relacionamento quando nao foi cadastrado o CPF
		EndIf

	End Sequence

	CursorWait()

	If !Empty( nRd0Recno )
		RD0->( MsGoto( nRd0Recno ) )
		fUpdateEnt( RD0->RD0_CODIGO , "SRA" , xFilial( "SRA" ) + GetMemVar( "RA_MAT" ) , nSraRdzOrd , cEmpAnt , cFilAnt )
	EndIf

	RestArea( aAreaRd0 )
	RestArea( aAreaSRA )
	RestArea( aArea )
	RestKeys( aSvKeys , .T. )

	CursorArrow()

Return( lSraRelRd0 )

/*/{Protheus.doc}fBtnRD0()
- Realiza relacionamento com RD0
@author:	Jônatas Alves
@since:		11/08/2017
/*/
Static Function fBtnRD0(aGpea265Bt,nOpc)

	Local lPyme		   		:= If( Type( "__lPyme" ) <> "U", __lPyme, .F. )

	If BldArrRdZRel() .And. !lPyme
		If nOpc <> 3
			// Define o botao para efetuar relacionamentos com a RD0
			bSraRelRd0 := { ||	CursorWait(),;
								fGrvRD0(nOpc,.T.),;
								SetKey( VK_F4 , bSraRelRd0 )		,;
								CursorArrow();
					   	  }
			aAdd(;
					aGpea265Bt	,;
									{;
										"DESTINOS_OCEAN"					,;
			   							bSraRelRd0							,;
			   							OemToAnsi( "Relacionar" + "...<F4>"  )	,;	// "Relacionar"
			       	   					OemToAnsi( "Relac."				)	 ;	// "Relac."
			           				};
			     )
		EndIf

		// Define o botao para visualizar relacionamentos com a RD0
		bSraShwRel := { || 	CursorWait(),;
							SraShwRel( @nRd0Recno ),;
							SetKey( VK_F5 , bSraShwRel ),;
						   	CursorArrow();
				   	  }

		aAdd(;
				aGpea265Bt	,;
								{;
									"ANALITICO"							,;
		   							bSraShwRel							,;
		       	   					OemToAnsi( "Visualizar Relacionamento" + "...<F5>"  )	,;	// "Visualizar Relacionamento"
		       	   					OemToAnsi( "Vis.Relac."				)	 ;	// "Vis.Relac."
		           				};
		)
	EndIf
Return

/*
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Funcao    ³ SraShwRel 	  ³ Autor ³ Marinaldo de Jesus  ³ Data ³ 05/02/04 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descricao ³ Atualiza a SR9 com as alteracoes efetuadas pela RD0.		  ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³ GPEA010                                                	  ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
Static Function SraShwRel( nRd0Recno )

	Begin Sequence

		If Empty( nRd0Recno )
			If ( EntExisteRel( "SRA" , xFilial("SRA")+GetMemVar( "RA_MAT" ) , cEmpAnt , cFilAnt , .T. ) )
				nRd0Recno := RD0->( Recno() )
			Else
				nRd0Recno := 0
			EndIf
		EndIf

		If !Empty( nRd0Recno )
			RD0->( MsGoto( nRd0Recno ) )
			Apda020Vis( "RD0" , nRd0Recno , 2 )
		Else
			MsgInfo( OemToAnsi( "Nao existe relacionamento a ser visualizado." ) ) // "Nao existe relacionamento a ser visualizado."
		EndIf
	End Sequence
Return( Nil )

/*/{Protheus.doc} fAtuAutRD0
Atualiza o cadastro de participantes se houver relacionamento
@author Gabriel A.
@since 17/10/2017
@version 1.0
/*/
Function fAtuAutRD0()
	Local nSraRdzOrd := GetRdzIndRel( "SRA" )
	Local cRd0Codigo := fGetPessoa( "SRA" , ( xFilial( "SRA" ) + GetMemVar( "RA_MAT" ) ) , cEmpAnt, FwCodFil() )

	If !Empty( cRd0Codigo )
		EntUpdateRd0(	cRd0Codigo, "SRA", ( cFilAnt + SRA->RA_MAT ), nSraRdzOrd, SRA->(Recno()), cEmpAnt, cFilAnt, "1", .T.)
	EndIf
Return Nil

/*/{Protheus.doc} SaveMenVar
Salva o conteúdo atual (Valor gravado na SRA) dos campos passados no aRotAuto
@author Cícero Alves
@since 26/11/2018
@version 12.1.17
/*/
Static Function SaveMenVar(aRotAuto)

	Local aArea := GetArea()
	local nPosMat := Ascan(aRotAuto,{|x| Alltrim(x[1]) == "RA_MAT"})
	Local nPosFil := Ascan(aRotAuto,{|x| Alltrim(x[1]) == "RA_FILIAL"})
	Local nI

	Static aSaveCpos := {}

	dbSelectArea("SRA")
	dbSetOrder(1)

	If nPosFil > 0 .And. nPosMat > 0 .And. SRA->(dbSeek(aRotAuto[nPosFil][2] + aRotAuto[nPosMat][2]))
		For nI:= 1 to Len(aRotAuto)
			// Apenas campos Reais
			If GetSx3Cache(aRotAuto[nI][1], "X3_CONTEXT") $ " |R"
				Aadd(aSaveCpos, {aRotAuto[nI][1], &("SRA->" + aRotAuto[nI][1])})
			EndIf
		Next
	EndIf

	RestArea(aArea)

Return

Static Function RstMenVar()

aSaveCpos := {}

Return

/*/{Protheus.doc} SaveMenVar
Verifica alterações nos campos disponíveis para integração com Ahgora
@author Bruno Costa
@since 28/08/2024
/*/
Static Function fVerAltAhgora(aSraCpo, aSRAOrig, aSRAalt)
Local aArea	  := GetArea()
Local nPos	  := 0
Local nI	  := 0
Local aCampos := {}
Local lAltera := .F.

aCampos := 	{"RA_CIC", "RA_PIS", "RA_NOME", "RA_SEXO", "RA_NASC", "RA_HRSMES",;
		     "RA_TNOTRAB", "RA_CODFUNC", "RA_CATFUNC", "RA_SINDICA", "RA_ADMISSA",;
			 "RA_DEMISSA", "RA_NUMCP", "RA_RG", "RA_TELEFON", "RA_EMAIL"}

For nI := 1 To Len(aCampos)
	nPos := aScan(aSraCpo, { |x| x[2] == aCampos[nI] } )
	If nPos > 0 .And. aSRAOrig[1, nPos] <> aSRAalt[1, nPos]
		lAltera := .T.
		Exit
	EndIf
Next nI

RestArea(aArea)

Return lAltera
