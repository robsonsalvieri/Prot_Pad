#INCLUDE "PROTHEUS.CH"
#INCLUDE "GPEA070.CH"
#INCLUDE "COLORS.CH"

Static lGeraPMes

/*


Ŀ
Funcao     Gpea070   Autor  Emerson Rosa de Souza              Data  28.07.00   
Ĵ
Descricao  Acumulado de Provisoes                                                   
Ĵ
 Uso       Generico                                                                 
Ĵ
           ATUALIZACOES SOFRIDAS DESDE A CONSTRUAO INICIAL.                          
Ĵ
PROGRAMADOR   DATA     CHAMADO/REQ       MOTIVO DA ALTERACAO                      
Ĵ
Mohanad      20/12/2013                Unificacao da Folha V12                    
                                                                                  
Christiane V.17/04/2014M12RH01/RQ1021  UNIFICACAO DA FOLHA V12                    
Renan Borges 24/06/2016 TVIRBJ         Ajuste para redimensionar tela de tolazao
                                       corretamente ao visualizar as provises    
                                       calculadas.                                
Claudinei S. 29/06/2016 TUTSTS         Ajuste em gp070aCols para carregar os itens
                                       de provisao de recesso.                    
Allyson M.   11/11/2016 TWEHXD         Ajuste em gp070aCols p/ exibio correta   
                                       dos avos de 13.		                    
Renan Borges 12/01/2017 MRH-4608	 	Ajuste para ao calcular proviso com o     
                                       mes fechado, o sistema calcule correta-    
                                       mente os dias que tinha na poca.          
ٱ

*/
Function GPEA070()

LOCAL aIndexSRA	:= {}		    //Variavel Para Filtro
Private bFiltraBrw := {|| Nil}	//Variavel para Filtro
Private lItemClVl  := GetMvRH( "MV_ITMCLVL", .F., "2" ) $ "13"
Private lUsadoGP   := IF(Empty(X3USADO("RE_TPDATO")),.F.,X3USADO("RE_TPDATO")) //Verifica se  Gesto Pblica
Private cFilAntBkp := cFilAnt

lGeraPMes := .F.
If GetMvRH("MV_RATPROV",,"N") == "S"
	lGeraPMes	  := fChkRHQBase()	// Verifica a existencia da tabela RHQ
Endif

PRIVATE aRotina := MenuDef() // ajuste para versao 9.12 - chamada da funcao MenuDef() que contem aRotina

cCadastro := OemToAnsi(STR0006)  //"Acumulado de Provisoes"

If !ChkVazio("SRA") //VERIFICA SE O ARQUIVO ESTA Vazio
	Return
Endif

If !IsBlind() .And. !fMsgIds()
	Return
EndIf

//INICIALIZA O FILTRO UTILIZANDO A FUNCAO FILBROWSE
cFiltraRh := CHKRH("GPEA070","SRA","1")
bFiltraBrw 	:= {|| FilBrowse("SRA",@aIndexSRA,@cFiltraRH) }
Eval(bFiltraBrw)

//ENDERECA A FUNCAO DE BROWSE
dbSelectArea("SRA")
dbSetOrder(1)
mBrowse( 6, 1,22,75,"SRA",,,,"SRA->RA_SITFOLH #'D'",,fCriaCor())

//DELETA O FILTRO UTILIZANDO A FUNCAO FILBROWSE
EndFilBrw("SRA",aIndexSra)

Return

/*


Ŀ
Funcao    gp070Atu   Autor  Emerson Rosa de Souza  Data  28.07.00 
Ĵ
Descricao  Programa de (Vis.,Inc.,Alt. e Del. de Afastamentos         
Ĵ
Sintaxe    gp070Atu(ExpC1,ExpN1,ExpN2)                                
Ĵ
Parametros ExpC1 = Alias do arquivo                                   
           ExpN1 = Numero do registro                                 
           ExpN2 = Numero da opcao selecionada                        
Ĵ
 Uso       GPEA070                                                    
ٱ

*/
Function gp070Atu(cAlias,nReg,nOpcx)

Local nCnt		 := 0
Local cMat       := SRA->RA_MAT
Local nSavRec    := RecNo()
Local nOpcLbx    := 0
Local nGrava     := 3
Local aRegAcols  := {}
Local oDlg
Local oDlgT
Local cChaveBus
Local aBotoes  	 := {}
Local aAdvSize		:= {}
Local aInfoAdvSize	:= {}
Local aObjSize		:= {}
Local aObjCoords	:= {}
Local aOfusca		:= If(FindFunction('ChkOfusca'), ChkOfusca(), {.T. , .F.}) //[1] Acesso; [2]Ofusca
Local aFldOfusca	:= {}
Local bSet15
Local bSet24
Local oFont
Local oGroup
Local lHistMed		:= AliasInDic("RJK") .And. AliasInDic("SRP") .And. FindFunction("fVerHistMed") .And. FindFunction("fTemHMed")
Local lOfuscaNom	:= .F.
Local lOfuscaAdm	:= .F.

Private aAC      := {STR0007,STR0008}  //"Abandona"###"Confirma"
Private aCols    := {}
Private aHeader  := {}
Private aTotAcols:= {}
Private aTotAuxAcols:= {}	//Array utilizado para verificar se houve manuteno nos valores de proviso
Private aTotRecno:= {}
Private aLbx     := {}
Private oLbx,oGet,cLbx
Private nUsado   := 0
Private aCposAlbx  := {"RT_FILIAL","RT_CC","RT_MAT","RT_DATACAL","RT_DATABAS","RT_DFERVEN","RT_DFERPRO",;
					    "RT_DFERANT","RT_DFALVEN","RT_DFALPRO","RT_TIPMOVI","RT_SALARIO","RT_AVOS13S" }
If Type("lItemClVl") == "U"
	Private lItemClVl   := GetMvRH( "MV_ITMCLVL", .F., "2" ) $ "13"
EndIf
If !lItemClVl
	AaDD( aCposAlbx, "RT_ITEM" )
	AaDD( aCposAlbx, "RT_CLVL" )
EndIf

If nOpcx == 5 //A EXCLUSAO DEVERA SER FEITA MES A MES NO LISTBOX
	Return
EndIf

Private aCodFol := {}

If !Fp_CodFol(@aCodFol,SRA->RA_FILIAL)
	Return
EndIf

//VERIFICA SE EXISTE ALGUM DADO NO ARQUIVO
dbSelectArea("SRT")
If lItemClVl
	dbSetOrder(4)
Else
	dbSetOrder(1)
EndIf

dbSeek(xFilial("SRT") + cMat)
nCnt := 0
If lItemClVl
	cChaveBus := SRT->RT_CC + SRT->RT_ITEM + SRT->RT_CLVL + MesAno(SRT->RT_DATACAL)
Else
	cChaveBus := SRT->RT_CC + MesAno(SRT->RT_DATACAL)
EndIf

While !Eof() .And. RT_FILIAL + RT_MAT == xFilial("SRT") + cMat
	nCnt++
	dbSkip()
	If ( ( !lItemClVl .And. RT_FILIAL+RT_MAT+RT_CC+MesAno(SRT->RT_DATACAL) != xFilial("SRT")+cMat+cChaveBus ) .Or.;
		( lItemClVl .And. RT_FILIAL+RT_MAT+RT_CC+RT_ITEM+RT_CLVL+MesAno(SRT->RT_DATACAL) != xFilial("SRT")+cMat+cChaveBus ) ) .And. nCnt > 0
		Aadd(aRegAcols, { cChaveBus, nCnt })
		If lItemClVl
			cChaveBus := SRT->RT_CC + SRT->RT_ITEM + SRT->RT_CLVL + MesAno(SRT->RT_DATACAL)
		Else
			cChaveBus := SRT->RT_CC + MesAno(SRT->RT_DATACAL)
		EndIf
		nCnt := 0
	EndIf
EndDo

If Len(aRegAcols) > 0  .And. nOpcx = 3 //QUANDO INCLUSAO E EXISTIR REGISTRO
    Help(" ",1,"A070IPROV")
	Return
Elseif Len(aRegAcols) = 0 .And. nOpcx # 3 //QUANDO NAO FOR INCLUSAO E NAO EXISTIR REGISTRO
    Help(" ",1,"A070APROV")
	Return
Endif

//Protecao de Dados Sensiveis - Ofuscar dados
If aOfusca[2]
	aFldOfusca 	:= FwProtectedDataUtil():UsrNoAccessFieldsInList( {"RA_NOME", "RA_ADMISSA"}) 
	if aScan( aFldOfusca , { |x| x:CFIELD == "RA_NOME" } ) > 0 
		lOfuscaNom	:= FwProtectedDataUtil():IsFieldInList( "RA_NOME" )
	ENDIF
	if aScan( aFldOfusca , { |x| x:CFIELD == "RA_ADMISSA" } ) > 0 
		lOfuscaAdm	:= FwProtectedDataUtil():IsFieldInList( "RA_ADMISSA" )
	ENDIF
EndIf

//MONTAR O LISTBOX E A GETDADOS COM OS LANCAMENTOS DA PROVISAO
gp070Acols(aRegAcols,nUsado,nOpcx)
aTotAuxACols := AClone(aTotAcols)

nUsado	:= Len(aHeader)

//MONTA AS DIMENSOES DOS OBJETOS
aAdvSize		:= MsAdvSize()
aInfoAdvSize	:= { aAdvSize[1] , aAdvSize[2] , aAdvSize[3] , aAdvSize[4], 5, 5 }
aAdd( aObjCoords , { 000 , 020 , .T. , .F. } )			// Matricula + Nome + Admissao
aAdd( aObjCoords , { 000 , 015 , .T. , .F. } )			// Provisao - Titulo
aAdd( aObjCoords , { 000 , 000 , .T. , .T. , .T.} )		// provisao - Dados
aAdd( aObjCoords , { 000 , 015 , .T. , .F. } )			// Botoes
aAdd( aObjCoords , { 000 , 015 , .T. , .F. } )			// itens da provisao - Titulo
aAdd( aObjCoords , { 000 , 000, .T. , .T. } )			// itens da provisao - Dados

aObjSize := MsObjSize( aInfoAdvSize , aObjCoords )

//INICIALIZA A GRAVACAO DOS LANCAMENTOS DO SIGAPCO
PcoIniLan("000091")

//Insero dos botes na Enchoicebar
aAdd( aBotoes, { 'COLTOT', { || fTotProv(nOpcx) }, STR0036, STR0036 } )// 'Totaliza'
aAdd( aBotoes, { "COLGERA", { || oDlgT := _TWalkThru():New("SRT"),oDlgT:Execute() }, STR0058, STR0058 } )// "WalkThru"

DEFINE FONT oFont NAME "Arial" SIZE 0,-11 BOLD

DEFINE MSDIALOG oDlg TITLE cCadastro From 0,0 TO aAdvSize[6],aAdvSize[5] OF oMainWnd PIXEL

bSet15 := {|| lOk :=.T.,If(oGet:TudoOk(),(nGrava:=1,nOpcLbx:=oLbx:nAt,oDlg:End()),.F.)}


bSet24 := {|| nGrava:= 0,oDlg:End()}

// MATRICULA + NOME + ADMISSAO
@ aObjSize[1,1] , aObjSize[1,2]				GROUP oGroup TO ( aObjSize[1,3] ),( ( aObjSize[1,4]/100*12 - 2 ) )	LABEL OemToAnsi(STR0052) OF oDlg PIXEL		// "Matricula:"
oGroup:oFont:= oFont
@ aObjSize[1,1] , ( ( aObjSize[1,4]/100*12 ) )	GROUP oGroup TO ( aObjSize[1,3] ),( aObjSize[1,4]/100*78 - 2 )			LABEL OemToAnsi(STR0053) OF oDlg PIXEL		// "Nome:"
oGroup:oFont:= oFont
@ aObjSize[1,1] , ( aObjSize[1,4]/100*78 )		GROUP oGroup TO ( aObjSize[1,3] ),aObjSize[1,4]						LABEL OemToAnsi(STR0062) OF oDlg PIXEL		// "Admisso:"
oGroup:oFont:= oFont

@ (aObjSize[1,1])+10 , (aObjSize[1,2]+5)				SAY StrZero(Val(SRA->RA_MAT),Len(SRA->RA_MAT))					SIZE 050,10 OF oDlg PIXEL FONT oFont	// Matricula
@ aObjSize[1,1]+10 , ( ( aObjSize[1,4]/100*12 )+5 )		SAY If(lOfuscaNom,Replicate('*',15),OemToAnsi(SRA->RA_NOME))	SIZE 146,10 OF oDlg PIXEL FONT oFont	// Nome
@ aObjSize[1,1]+10 , ( aObjSize[1,4]/100*78 )+5			SAY If(lOfuscaAdm,Replicate('*',10),Dtoc(SRA->RA_ADMISSA))		SIZE 050,10 OF oDlg PIXEL FONT oFont	// Admissao

//"CABECALHO DE PROVISAO"
@ aObjSize[2,1] , aObjSize[2,2] GROUP oGroup TO ( aObjSize[2,3] ), ( aObjSize[2,4] )	LABEL "" OF oDlg PIXEL
oGroup:oFont:= oFont
@ ( ( ( ( aObjSize[2,3] ) - ( aObjSize[2,1] ) ) / 2 ) + ( aObjSize[2,1] - 3 ) ) , ((aObjSize[2,4]/2)-40) SAY STR0060 SIZE 150,10 OF oDlg PIXEL FONT oFont	// CABECALHO PROVISAO

If lItemClVl
	@  aObjSize[3,1],aObjSize[3,2] LISTBOX oLbx VAR cLbx FIELDS HEADER 	OemtoAnsi(STR0010),;//"Data do Calculo"
												OemtoAnsi(STR0050),;//"Centro de Custo"
												OemtoAnsi(STR0011),;//"Data Base Ferias"
												OemtoAnsi(STR0012),;//"Dias Ferias Venc."
												OemtoAnsi(STR0013),;//"Dias Ferias Prop."
												OemtoAnsi(STR0014),;//"Dias Ferias Antec."
												OemtoAnsi(STR0015),;//"Dias Faltas Venc."
												OemtoAnsi(STR0016),;//"Dias Faltas Prop."
												OemtoAnsi(STR0017),;//"Movimentacao"
												OemtoAnsi(STR0018),;//"Valor do Salario"
												OemtoAnsi(STR0019),;//"Avos 13o"
												OemtoAnsi(STR0056),;//"Item"
												OemtoAnsi(STR0057),;//"Classe"
												OemtoAnsi(STR0020) SIZE aObjSize[3,3],aObjSize[3,4] OF oDlg PIXEL; //"Status"
	ON CHANGE (nPos:=oLbx:nAt,A070AtuGD(nPos,1))
	oLbx:SetArray(aLbx)
Else
	@ aObjSize[3,1],aObjSize[3,2] LISTBOX oLbx VAR cLbx FIELDS HEADER 	OemtoAnsi(STR0010),;//"Data do Calculo"
												OemtoAnsi(STR0050),;//"Centro de Custo"
												OemtoAnsi(STR0011),;//"Data Base Ferias"
												OemtoAnsi(STR0012),;//"Dias Ferias Venc."
												OemtoAnsi(STR0013),;//"Dias Ferias Prop."
												OemtoAnsi(STR0014),;//"Dias Ferias Antec."
												OemtoAnsi(STR0015),;//"Dias Faltas Venc."
												OemtoAnsi(STR0016),;//"Dias Faltas Prop."
												OemtoAnsi(STR0017),;//"Movimentacao"
												OemtoAnsi(STR0018),;//"Valor do Salario"
												OemtoAnsi(STR0019),;//"Avos 13o"
												OemtoAnsi(STR0020) SIZE aObjSize[3,3],aObjSize[3,4] OF oDlg PIXEL; //"Status"
	ON CHANGE (nPos:=oLbx:nAt,A070AtuGD(nPos,1))
	oLbx:SetArray(aLbx)
EndIf

If lItemClVl
	oLbx:bLine := { ||  { aLbx[oLbx:nAt,_DatCalc],aLbx[oLbx:nAt,_CentroC],aLbx[oLbx:nAt,_DBsProv],aLbx[oLbx:nAt,_DFerVen],;
                       aLbx[oLbx:nAt,_DFerPro],aLbx[oLbx:nAt,_DFerAnt],aLbx[oLbx:nAt,_DFalVen],aLbx[oLbx:nAt,_DFalPro],;
                       aLbx[oLbx:nAt,_MovProv],aLbx[oLbx:nAt,_SalProv],aLbx[oLbx:nAt,_Avos13S] ,;
                       aLbx[oLbx:nAt,_cItem],aLbx[oLbx:nAt,_Clvl],aLbx[oLbx:nAt,_PStatus]}}
Else
	oLbx:bLine := { ||  { aLbx[oLbx:nAt,_DatCalc],aLbx[oLbx:nAt,_CentroC],aLbx[oLbx:nAt,_DBsProv],aLbx[oLbx:nAt,_DFerVen],;
	                       aLbx[oLbx:nAt,_DFerPro],aLbx[oLbx:nAt,_DFerAnt],aLbx[oLbx:nAt,_DFalVen],aLbx[oLbx:nAt,_DFalPro],;
	                       aLbx[oLbx:nAt,_MovProv],aLbx[oLbx:nAt,_SalProv],aLbx[oLbx:nAt,_Avos13S],aLbx[oLbx:nAt,_PStatus] }}

EndIf

// ITENS DA PROVISAO
@ aObjSize[5,1] , aObjSize[5,2] GROUP oGroup TO ( aObjSize[5,3] ), ( aObjSize[5,4] )	LABEL "" OF oDlg PIXEL
oGroup:oFont:= oFont
@ ( ( ( ( aObjSize[5,3] ) - ( aObjSize[5,1] ) ) / 2 ) + ( aObjSize[5,1] - 3 ) ) , ( ( aObjSize[5,4] /2)-30 ) SAY STR0061 SIZE 150,10 OF oDlg PIXEL FONT oFont	// I T E N S  D A  P R O V I S A O

If Len( aTotAcols ) > 0
	aCols		:= aClone(aTotAcols[1,1])
Endif
n			:= Len(aCols)

oGet        := MSGetDados():New(aObjSize[6,1],; // nTop
								 aObjSize[6,2],; // nLelft
								 aObjSize[6,3],; // nBottom
								 aObjSize[6,4],; // nRright
								 nOpcx,;
								 "gp070LinOk",;
								 "gp070TudOk",;
								 "",;
								 If(nOpcx # 2,.T.,Nil),,,,,,,,,)

oGet:oBrowse:bValid := {|| A070AtuGD(oLbx:nAt,2) }	// funcao a ser executada quando o browse perder o foco

If nOpcx == 3 .Or. nOpcx == 4		// Inclusao e Alteracao
	DEFINE SBUTTON FROM aObjSize[4,1], aObjSize[4,2]	   TYPE  4 ENABLE OF oDlg ACTION (dVar:=A070ListBox(oLbx:nAt,1,nUsado),If(!Empty(dVar),A070Acres(oLbx:nAt,oLbx,dVar),))
	DEFINE SBUTTON FROM aObjSize[4,1], (aObjSize[4,2]+30)  TYPE 11 ENABLE OF oDlg ACTION (dVar:=A070ListBox(oLbx:nAt,2,nUsado),If(!Empty(dVar),A070Acres(oLbx:nAt,oLbx,dVar),))
	DEFINE SBUTTON FROM aObjSize[4,1], (aObjSize[4,2]+60)  TYPE  3 ENABLE OF oDlg ACTION (dVar:=A070ListBox(oLbx:nAt,3,nUsado),If(!Empty(dVar),A070Acres(oLbx:nAt,oLbx,dVar),))
	If lHistMed
		oTButton1 := TButton():New( aObjSize[4,1], (aObjSize[4,2]+90), STR0102,oDlg,{||fMedia()}, 25,11,,,.F.,.T.,.F.,,.F.,,,.F. )   //"Medias"
	EndIf
Else		// Visualizacao e Exclusao
	DEFINE SBUTTON FROM aObjSize[4,1],aObjSize[4,2]			TYPE  4 OF oDlg
	DEFINE SBUTTON FROM aObjSize[4,1],(aObjSize[4,2]+30)	TYPE 11 OF oDlg
	DEFINE SBUTTON FROM aObjSize[4,1],(aObjSize[4,2]+60)	TYPE  3 OF oDlg
	If lHistMed
		oTButton1 := TButton():New( aObjSize[4,1], (aObjSize[4,2]+90), STR0102,oDlg,{||fMedia()}, 25,11,,,.F.,.T.,.F.,,.F.,,,.F. )   //"Medias"
	EndIf
EndIf


ACTIVATE MSDIALOG oDlg ON INIT EnchoiceBar( oDlg, bSet15, bSet24,, aBotoes ) CENTERED

//GRAVA O ARRAY ATOTACOLS E ALBX NO ARQUIVO SRT
If nOpcx # 2 .And. nOpcx # 5 .And. nGrava == 1
	gp070Grava(nOpcLbx,nUsado,nOpcx)
EndIf

//FINALIZA A GRAVACAO DOS LANCAMENTOS DO SIGAPCO
PcoFinLan("000091")

//Restaura a integridade da janela
cAlias := "SRA"
dbSelectArea(cAlias)
Go nSavRec
Return

/*


Ŀ
                   ROTINAS DE CRITICA DE CAMPOS                        
ٱ



Ŀ
Funcao    gp070Grava Autor  Emerson Rosa de Souza  Data  28.07.00 
Ĵ
Descricao  Grava o array aLbx e aTotAcols no arquivo de Provisoes     
Ĵ
 Uso       gp070Grava                                                 
ٱ

*/
Static Function gp070Grava(nOpcLbx,nUsado,nOpcx)
Local aArea	:= GetArea()
Local lPriReg := .T.
Local ny
Local nx
Local nz
Local lPE	:= EXISTBLOCK("GP70MAIL")
//Local lAtualiza := !fCompArray( aTotAcols , aTotAuxAcols )

Begin Transaction

	dbSelectArea("SRT")
	dbSetOrder(1)
	For nx := 1 To Len(aTotAcols)
		lPriReg := .T.
		For ny := 1 To Len(aTotAcols[nx,1])
			If ny <= Len(aTotRecno[nx,1]) .And. aTotRecno[nx,1,ny] > 0
		        MsGoto(aTotRecno[nx,1,ny])

	    	    If aTotAcols[nx,1,ny,nUsado+1] == .T. .And. lPE .And. lPriReg //ponto de entrada para disparo de email, registro posicionado na SRT antes da deleo. So chama 1x por data de referencia
					ExecBLock('GP70MAIL',.F.,.F.)
					//para garantir que o PE no disposicionou o registro
					dbSelectArea("SRT")
					dbSetOrder(1)
					MsGoto(aTotRecno[nx,1,ny])
				EndIf

	    	    RecLock( "SRT",.F.,.T.)
		        If aTotAcols[nx,1,ny,nUsado+1] == .T. //VERIFICA SE ESTA DELETADO
					//integracao com modulo SIGAPCO
				    PcoDetLan("000091","01","GPEA070", .T.)
	    		    dbDelete()
	    		    MsUnlock()
	    		    If lPriReg
	    		    	fDelHist(aTotAcols[nx,2])
	    		    EndIf
	    		    If lGeraPMes //Excluir os registros da tabela de Proviso Mensal - RHT
	                	fExcluiProvMes()
					EndIf
					lPriReg := .F.
	        	    Loop
		        Endif
			Else
	        	If aTotAcols[nx,1,ny,nUsado+1] == .F. //VERIFICA SE NAO ESTA DELETADO
	    	         RecLock( "SRT",.T.,.T.)
	    	         SRT->RT_FILIAL := SRA->RA_FILIAL
	    	         SRT->RT_MAT    := SRA->RA_MAT
		        Else
	    	         Loop
		        Endif
	    	Endif
			For nz := 1 To Len(aHeader)
		        cCampo    := Trim(aHeader[nz,2])
	   		    xConteudo := aTotAcols[nx,1,ny,nz]
	    	    &cCampo   := xConteudo
		    Next nz
		    SRT->RT_DATACAL := aLbx[nx,_DatCalc]
	   	    SRT->RT_CC 		:= aLbx[nx,_CentroC]
			If lItemClVl
		   	    SRT->RT_ITEM	 := aLbx[nx,_cItem]
	   		    SRT->RT_CLVL	 := aLbx[nx,_Clvl]
	       	EndIf
	       	//SOMENTE GRAVAR CABECALHO NO PRIMEIRO REGISTRO DO MES/ANO
	   	    If lPriReg
			 	SRT->RT_DATABAS := aLbx[nx,_DBsProv]
		 		SRT->RT_DFERVEN := aLbx[nx,_DFerVen]
			 	SRT->RT_DFERPRO := aLbx[nx,_DFerPro]
			 	SRT->RT_DFERANT := aLbx[nx,_DFerAnt]
		 		SRT->RT_DFALVEN := aLbx[nx,_DFalVen]
			 	SRT->RT_DFALPRO := aLbx[nx,_DFalPro]
			 	SRT->RT_TIPMOVI := aLbx[nx,_MovProv]
		    	SRT->RT_SALARIO := aLbx[nx,_SalProv]
			    SRT->RT_AVOS13S := aLbx[nx,_Avos13S]
				lPriReg := .F.
			 EndIf
			 MsUnlock()
	         PcoDetLan("000091","01","GPEA070") //INTEGRACAO COM MODULO SIGAPCO
	         /*
	         If lGeraPMes .And. lAtualiza //Recalcular os valores do ms de acordo com o valor acumulado atual que foi alterado
	         	fAtuProvMes(nX, nY,nOpcx)
	         Endif
	         */
		Next ny
	Next nx

End Transaction

RestArea(aArea)
Return

/*


Ŀ
Funcao    gp070LinOk Autor  Emerson Rosa de Souza  Data  06.08.94 
Ĵ
Descricao Critica linha digitada                                      
Ĵ
 Uso       Generico                                                   
ٱ

*/
Function gp070LinOk()
Local aCposKey	:= {}
Local nx
Local lRet := .T.
Local nQtdLiTipo := 0

nUsado	:= Len(aHeader)
If aCols[n,nUsado+1] == .F.
	aEval(aCols, {|x| If(x[1] == aCols[n][1] .And. !x[nUsado+1], nQtdLiTipo++, Nil)})
	For nx = 1 To Len(aHeader)
		If Empty(aCols[n][nx]) .And. Lastkey() # 27
			If Trim(aHeader[nx][2]) == "RT_TIPPROV"
				Help(" ",1,"A070TPROV")  // Tipo da provisao nao pode estar em branco
				lRet := .F.
				Exit
			Endif
			If Trim(aHeader[nx][2]) == "RT_VERBA" .And. nQtdLiTipo > 1 
				Help(" ",1,"A040SPD")   // Codigo da verba nao pode estar em branco
				lRet := .F.
				Exit
			EndIf
			If Trim(aHeader[nx][2]) == "RT_VALOR" .And. nQtdLiTipo > 1
				Help(" ",1,"A070VPROV")  // Valor da verba nao pode ser igual a zero
				lRet := .F.
				Exit
			Endif
		Endif
	Next nx
Endif

//Verifica Itens Duplicados na GetDados
If lItemClVl
	aCposKey	:= { "RT_TIPPROV", "RT_VERBA", "RT_ITEM", "RT_CLVL"  }
Else
	aCposKey	:= { "RT_TIPPROV", "RT_VERBA" }
EndIf

IF !( GdCheckKey( aCposKey , 4 ) )
	lRet := .F.
EndIf
Return lRet

/*


Ŀ
Funcao    gp070TudOk Autor  Emerson Rosa de Souza  Data  28/07/00 
Ĵ
Descricao                                                             
Ĵ
 Uso       Generico                                                   
ٱ

*/
Function gp070TudOk()
Local lRet  := .T.
Continua 	:= .F.
Return lRet

/*


Ŀ
Funcao    g070aCols  Autor  Emerson Rosa de Souza  Data  28/07/00 
Ĵ
Descricao  Criar o Arrays aCols das Provisoes				          
Ĵ
 Uso       gpea070                                                    
ٱ

*/
Static Function gp070aCols(aRegAcols,nUsado,nOpcx)
Local aArea			:= GetArea()
Local aColsTmp		:= {},aLbxTmp	:= {}
Local cChaveBus,nUsadoTmp
Local bSeekWhile	:= {|| .T. }
Local nSRTOrd		:= 0
Local _cFilMat		:= xFilial("SRA")+SRA->RA_MAT
Local nCont			:= 0
Local aColsRec 		:= {}
Local nPosAscan		:= 0
Local dDataCols		:= Date()
Local nCont2 		:= 0

If lItemClVl
	bSeekWhile	:= {|| SRT->RT_FILIAL+SRT->RT_MAT+SRT->RT_CC+SRT->RT_ITEM+SRT->RT_CLVL+ DTOS(SRT->RT_DATACAL) }
	nSRTOrd		:= RetOrdem( "SRT" , "RT_FILIAL+RT_MAT+RT_CC+RT_ITEM+RT_CLVL+DTOS(RT_DATACAL)+RT_TIPPROV+RT_VERBA" )
Else
	bSeekWhile	:= {|| SRT->RT_FILIAL+SRT->RT_MAT+SRT->RT_CC+ DTOS(SRT->RT_DATACAL) }
	nSRTOrd		:= RetOrdem( "SRT" , "RT_FILIAL+RT_MAT+RT_CC+ DTOS(RT_DATACAL)+RT_TIPPROV+RT_VERBA" )
EndIf

dbSelectArea("SRT")
If lItemClVl
	dbSetOrder(4)
Else
	dbSetOrder(1)
EndIf
If dbseek(SRA->RA_FILIAL+SRA->RA_MAT)
	While !EOF() .And. RT_FILIAL + RT_MAT == SRA->RA_FILIAL + SRA->RA_MAT
		If !Empty(SRT->RT_DATABAS)
			If (RT_TIPPROV == "1" .OR. RT_TIPPROV == "2" .OR. RT_TIPPROV == "3" .OR. RT_TIPPROV == "4" .OR. RT_TIPPROV == "7" .OR. RT_TIPPROV == "8" .OR. RT_TIPPROV == "9")
				If lItemClVl
					cChaveBus := SRT->RT_CC + SRT->RT_ITEM + SRT->RT_CLVL + Dtos(SRT->RT_DATACAL)
					nPosAscan := Ascan(aLbxTmp,{|x| Dtos(x[1]) + x[2] + x[13] + x[14] == Dtos(SRT->RT_DATACAL)+SRT->RT_CC+SRT->RT_ITEM+SRT->RT_CLVL  })
				Else
					cChaveBus := SRT->RT_CC + Dtos(SRT->RT_DATACAL)
					nPosAscan := Ascan(aLbxTmp,{|x| Dtos(x[1])+ x[2]== Dtos(SRT->RT_DATACAL)+SRT->RT_CC  })
				EndIf
				//CASO NAO EXISTA NO ARRAY ALBXTMP, ESTE PERIODO (DATA) ELE IRA CRIAR (CONTEUDO DA LISTBOX)
				If nPosAscan == 0
					If lItemClVl
						Aadd(aLbxTmp,{SRT->RT_DATACAL,SRT->RT_CC,SRT->RT_DATABAS,SRT->RT_DFERVEN,;
								       SRT->RT_DFERPRO,SRT->RT_DFERANT,SRT->RT_DFALVEN,SRT->RT_DFALPRO,;
								       SRT->RT_TIPMOVI,SRT->RT_SALARIO,SRT->RT_AVOS13S,STR0026,SRT->RT_ITEM,SRT->RT_CLVL,cChaveBus }) // 14 - Ativo
			        Else
			        	Aadd(aLbxTmp,{SRT->RT_DATACAL,SRT->RT_CC,SRT->RT_DATABAS,SRT->RT_DFERVEN,;
								       SRT->RT_DFERPRO,SRT->RT_DFERANT,SRT->RT_DFALVEN,SRT->RT_DFALPRO,;
								       SRT->RT_TIPMOVI,SRT->RT_SALARIO,SRT->RT_AVOS13S,STR0026,cChaveBus } )// 12 - Ativo
					EndIf
			    ElseIf Empty(aLbxTmp[nPosAscan, 11]) .And. !Empty(SRT->RT_AVOS13S)
			    	aLbxTmp[nPosAscan, 11] := SRT->RT_AVOS13S
			    Endif
			EndIf
		EndIf
		dbSkip()
	Enddo
	CcChavePesq	:=	""
    // Fazer todo o periodo(aLbxTmp) e armazenando no aTotAcols com o segundo elemento a data(periodo)
	For nCont := 1 to Len(aLbxTmp)
		aCols	:= {}
		aHeader	:= {}
		aColsRec:= {}
		// Chave para busca do periodo Centro de Custo + Data
		CcChavePesq	:= aLbxTmp[nCont][Len(aLbxTmp[1])]
		bSeekFor := If(lGeraPMes, {|| RT_TIPPROV == "1" .OR. RT_TIPPROV == "2" .OR. RT_TIPPROV == "3" .OR. RT_TIPPROV == "4" .OR. RT_TIPPROV == "7" .OR. RT_TIPPROV == "8" .OR. RT_TIPPROV == "9"}, Nil)

		FillGetDados(nOpcx					,; //1-nOpcx - nmero correspondente  operao a ser executada, exemplo: 3 - incluso, 4 alterao e etc;
					 "SRT"					,; //2-cAlias - area a ser utilizada;
					 nSRTOrd				,; //3-nOrder - ordem correspondente a chave de indice para preencher o  acols;
					 _cFilMat+CcChavePesq	,; //4-cSeekKey - chave utilizada no posicionamento da area para preencher o acols;
					 bSeekWhile				,; //5-bSeekWhile - bloco contendo a expresso a ser comparada com cSeekKey na condio  do While.
					 bSeekFor				,; //6-uSeekFor - pode ser utilizados de duas maneiras:1- bloco-de-cdigo, condio a ser utilizado para executar o Loop no While;2 - array bi-dimensional contendo N.. condies, em que o 1 elemento  o bloco condicional, o 2  bloco a ser executado se verdadeiro e o 3  bloco a ser executado se falso, exemplo {{bCondicao1, bTrue1, bFalse1}, {bCondicao2, bTrue2, bFalse2}.. bCondicaoN, bTrueN, bFalseN};
					 aCposAlbx	   	    	,; //7-aNoFields - array contendo os campos que no estaro no aHeader;
					 NIL					,; //8-aYesFields - array contendo somente os campos que estaro no aHeader;
					 NIL					,; //9-lOnlyYes - se verdadeiro, exibe apenas os campos de usurio;
					 NIL					,; //10-cQuery - query a ser executada para preencher o acols(Obs. Nao pode haver MEMO);
					 NIL					,; //11-bMontCols - bloco contendo funo especifica para preencher o aCols; Exmplo:{|| MontaAcols(cAlias)}
					 Iif(nOpcx==3,.t.,.f.)  ,; //12-Caso inclusao inclua um registro em branco no acols
					 NIL			      	,; //13-aHeaderAux
					 NIL			      	,; //14-aColsAux
					 NIL			     	) //15-bAfterCols
		nPosVerba	:=  GdfieldPos("RT_VERBA")
		nPosDesc	:=  GdfieldPos("RT_DESCVER")
		nPosRec	:=  GdfieldPos("RT_REC_WT")
		nUsadoTmp	:= 	nUsado := Len(aHeader)
		If !Empty(aCols[1][1])
	        dDataCols	:= aLbxTmp[nCont][1]
			For nCont2:= 1 to Len(aCols)
				// gravando a descricao do aCols
				If !Empty(aCols[nCont2,nPosVerba])
					aCols[nCont2,nPosDesc] := DescPd(aCols[nCont2,nPosVerba])
				EndIf
				// Gravando o aColsRec para ser usado na gravacao
				Aadd(aColsRec,aCols[nCont2,nPosRec] )
			Next nCont2
			Aadd(aTotAcols,{ aCols, dDataCols })
			Aadd(aTotRecno,{ aColsRec, dDataCols })
        Endif
	Next nCont
	aColsTmp	:= aCols
	//CARREGA ATOTACOLS E ALBX COM CADA UM DOS MESES DA PROVISAO
    //GRAVANDO A DATA O ARRAY ALBXTMP PARA SER ARMAZENADO EM ALBXBKP, QUANDO SELECIONADO NA LISTBOX
    If Len(aColsTmp) > 0 .And. !Empty(aColsTmp[1][nPosRec])
		aLbxBkp		:= {}
		For nCont:= 1 to Len(aLbxTmp)
			Aadd(aLbxBkp,aLbxTmp[nCont])
		Next
		aLbx	:= aLbxBkp
    Endif
	aLbx      := ASort(aLbx,,,     { |x,y| x[1]>y[1] })
	aTotAcols := ASort(aTotAcols,,,{ |x,y| x[2]>y[2] })
	aTotRecno := ASort(aTotRecno,,,{ |x,y| x[2]>y[2] })
Else
	bSeekWhile	:= {|| SRT->RT_FILIAL+SRT->RT_MAT }
	//MONTA ARRAY DO 1 ELEMENTO VAZIO. SE INCLUSAO
	If lItemClVl
		aLbxTmp  := { CTOD(""),Space(9),CTOD(""),0,0,0,0,0,0,0,0,STR0026,Space(GetSx3Cache("RT_ITEM","X3_TAMANHO")),Space(GetSx3Cache("RT_CLVL","X3_TAMANHO"))} // Ativo
	Else
		aLbxTmp  := { CTOD(""),Space(9),CTOD(""),0,0,0,0,0,0,0,0,STR0026 } // ATIVO
	EndIf
	// SOMENTE QUANDO FOR .T. INCLUSAO
	FillGetDados(nOpcx					,; //1-nOpcx - nmero correspondente  operao a ser executada, exemplo: 3 - incluso, 4 alterao e etc;
				 "SRT"					,; //2-cAlias - area a ser utilizada;
				 nSRTOrd				,; //3-nOrder - ordem correspondente a chave de indice para preencher o  acols;
				 _cFilMat   		    ,; //4-cSeekKey - chave utilizada no posicionamento da area para preencher o acols;
				 bSeekWhile				,; //5-bSeekWhile - bloco contendo a expresso a ser comparada com cSeekKey na condio  do While.
				 NIL					,; //6-uSeekFor - pode ser utilizados de duas maneiras:1- bloco-de-cdigo, condio a ser utilizado para executar o Loop no While;2 - array bi-dimensional contendo N.. condies, em que o 1 elemento  o bloco condicional, o 2  bloco a ser executado se verdadeiro e o 3  bloco a ser executado se falso, exemplo {{bCondicao1, bTrue1, bFalse1}, {bCondicao2, bTrue2, bFalse2}.. bCondicaoN, bTrueN, bFalseN};
				 aCposAlbx	   	    	,; //7-aNoFields - array contendo os campos que no estaro no aHeader;
				 NIL					,; //8-aYesFields - array contendo somente os campos que estaro no aHeader;
				 NIL					,; //9-lOnlyYes - se verdadeiro, exibe apenas os campos de usurio;
				 NIL					,; //10-cQuery - query a ser executada para preencher o acols(Obs. Nao pode haver MEMO);
				 NIL					,; //11-bMontCols - bloco contendo funo especifica para preencher o aCols; Exmplo:{|| MontaAcols(cAlias)}
				 .T.  					,; //12-Caso inclusao inclua um registro em branco no acols
				 NIL			      	,; //13-aHeaderAux
				 NIL			      	,; //14-aColsAux
				 NIL			     	) //15-bAfterCols
	aColsTmp	:= aCols
	Aadd(aTotAcols, { aColsTmp, aLbxTmp[1] })
	Aadd(aTotRecno,{ {}, aLbxTmp[1] })
	Aadd(aLbx,aLbxTmp)
EndIf

RestArea(aArea)

Return

/*


Ŀ
Funo     A070AtuGD Autor  Emerson Rosa de Souza  Data  01.08.00   
Ĵ
Descrio  Monta os arrays da getdados qdo selecionar outro mes/ano     
Ĵ
Sintaxe    A070AtuGd(ExpN1,ExpN2)                                     
Ĵ
Parametro  nPos = Posicao no listbox                                  
           nVar = Indica quem chamou a funcao                         
Ĵ
Uso		  Generico 												  
ٱ


*/
Static Function A070AtuGD(nPos,nVar)
If Len(aLbx) == 0 .And. nVar == 1
	Return .T.
EndIf

If nVar == 1
	aCols  		      := aClone(aTotAcols[nPos,1])
ElseIf nVar == 2
	aTotAcols[nPos,1] := aClone(aCols)
EndIf


oGet:ForceRefresh()
Return .T.

/*/


Ŀ
Funcao     A070ListBox Autor  Emerson R. de Souza  Data  04.08.00 
Ĵ
Descricao  Controle dos dados do ListBox                              
Ĵ
Sintaxe    A070ListBox(nPosLbx,nOpcLbx,nUsado)                        
Ĵ
Parametros nPosLbx = Posicao no ListBox                               
           nOpcLbx = Opcao escolhida atraves dos botoes               
                     1 - inclusao                                     
                     2 - alteracao                                    
                     3 - exclusao                                     
ٱ


*/
Static Function A070ListBox(nPosLbx,nOpcLbx,nUsado,nOpcx)

Local oDlg
Local nOpc1 := 0
Local aTipoMov := { Str(_Demitido,1)+"="+STR0021,; //Demitido
					 Str(_Cong_Fer,1)+"="+STR0022 + " " + STR0031,; //Congelado Ferias
   					 Str(_Cong_13s,1)+"="+STR0022 + " " + STR0023,; //Congelado 13o
   					 Str(_Cong_F13,1)+"="+STR0022 + " " + STR0031+"/"+STR0023,; //Congelado Ferias/13o
					 Str(_Trfe_Sai,1)+"="+STR0024,; 				  //Transferencia Saida
					 Str(_Trfe_Ent,1)+"="+STR0025,"0=" } 			 //Transf. Entrada##Ativo
Local nCnt1

//| Variaveis para Get dos campos da LisBox						 

Local dDtCalPro   := CTOD("")
Local cCentroC    := SRA->RA_CC
Local dDtBasFer	  := CTOD("")
Local cTipoMov	  := "0"
Local nDFerVenc	  := nDFerProp := nDFerAnt	 := nDFalVen := 0
Local nDFalPro    := nValSal   := nAvos13   := 0
Local cDescTit 	  := OemToAnsi(STR0028) //"Incluir"
Local cItem
Local cClvl
Local aRetcoords	:={}


If lItemClVl
	cItem		  := SRA->RA_ITEM
	cClvl		  := SRA->RA_CLVL
EndIf

If Len(aLbx) > 0 .And. Empty(aLbx[1,_DatCalc]) .And. nOpcLbx # 1
	HELP("",1,"A070APROV") // Nao editar lancamento vazio
	Return
EndIf

If nOpcLbx # 1 // Alteracao ou Exclusao
	dDtCalPro   := aLbx[nPosLbx,_DatCalc]
	cCentroC    := aLbx[nPosLbx,_CentroC]
	dDtBasFer	:= aLbx[nPosLbx,_DBsProv]
	nDFerVenc	:= aLbx[nPosLbx,_DFerVen]
	nDFerProp	:= aLbx[nPosLbx,_DFerPro]
	nDFerAnt	:= aLbx[nPosLbx,_DFerAnt]
	nDFalVen	:= aLbx[nPosLbx,_DFalVen]
	nDFalPro	:= aLbx[nPosLbx,_DFalPro]
	cTipoMov	:= Str(aLbx[nPosLbx,_MovProv],1)
	nValSal		:= aLbx[nPosLbx,_SalProv]
	nAvos13		:= aLbx[nPosLbx,_Avos13S]
	If lItemClVl
		cItem		:= aLbx[nPosLbx,_cItem]
		cClvl		:= aLbx[nPosLbx,_Clvl]
    EndIf
	cDescTit 	:= If(nOpcLbx = 2, OemToAnsi(STR0029), OemToAnsi(STR0030)) //"Alterar"###"Excluir"
EndIf

aRetcoords := RetCoords(4,7,57,20,2,40)

If lItemClVl

	DEFINE MSDIALOG oDlg FROM  190,10 TO 550,625 TITLE cDescTit PIXEL

	@ aRetcoords[01][1]   , aRetcoords[01][2] SAY OemtoAnsi(STR0010) SIZE 60,10 OF oDlg PIXEL  //"Data do Calculo"
	@ aRetcoords[02][1]   , aRetcoords[02][2] MSGET oDtCalPro 	VAR dDtCalPro WHEN (nOpcLbx==1) VALID !Empty(dDtCalPro);
			  SIZE 60,10 OF oDlg PIXEL HASBUTTON

	@ aRetcoords[05][1]   , aRetcoords[05][2] SAY OemtoAnsi(STR0050) SIZE 60,10 OF oDlg PIXEL  //"Centro de Custo"
	@ aRetcoords[06][1]   , aRetcoords[06][2] MSGET oCentroC  	VAR cCentroC WHEN (nOpcLbx==1) F3 "SI3" ;
		      SIZE 60,10 OF oDlg PIXEL HASBUTTON

	@ aRetcoords[09][1]   , aRetcoords[09][2] SAY OemtoAnsi(STR0056) SIZE 60,10 OF oDlg PIXEL  //"Item"
	@ aRetcoords[10][1]   , aRetcoords[10][2] MSGET oItem  	VAR cItem WHEN (nOpcLbx==1) F3 "CTD";
		      SIZE 60,10 OF oDlg PIXEL HASBUTTON

	@ aRetcoords[13][1]   , aRetcoords[13][2] SAY OemtoAnsi(STR0057) SIZE 60,10 OF oDlg PIXEL  //"Classe de Valor"
	@ aRetcoords[14][1]   , aRetcoords[14][2] MSGET oClvl  	VAR cClvl WHEN (nOpcLbx==1) F3 "CTH";
		      SIZE 60,10 OF oDlg PIXEL	HASBUTTON

	@ aRetcoords[17][1]   , aRetcoords[17][2] SAY OemtoAnsi(STR0011) SIZE 60,10 OF oDlg PIXEL  //"Data Base Ferias"
	@ aRetcoords[18][1]   , aRetcoords[18][2] MSGET oDtBasFer 	VAR dDtBasFer WHEN nOpcLbx#3 VALID  NaoVazio(dDtBasFer) SIZE 60,10 OF oDlg PIXEL HASBUTTON

	@ aRetcoords[21][1]   , aRetcoords[21][2] SAY OemtoAnsi(STR0012) SIZE 60,10 OF oDlg PIXEL  //"Dias Ferias Venc."
	@ aRetcoords[22][1]   , aRetcoords[22][2] MSGET oDFerVenc VAR nDFerVenc PICTURE "999.99" WHEN nOpcLbx#3 VALID nDFerVenc >= 0;
	                          SIZE 60,10 OF oDlg PIXEL HASBUTTON

	@ aRetcoords[25][1]   , aRetcoords[25][2] SAY OemtoAnsi(STR0013) SIZE 60,10 OF oDlg PIXEL  //"Dias Ferias Prop."
	@ aRetcoords[26][1]   , aRetcoords[26][2] MSGET oDFerProp VAR nDFerProp PICTURE "999.99" WHEN nOpcLbx#3 VALID nDFerProp >= 0;
	                          SIZE 60,10 OF oDlg PIXEL HASBUTTON

	@ aRetcoords[07][1]   , aRetcoords[07][2] SAY OemtoAnsi(STR0014) SIZE 60,10 OF oDlg PIXEL  //"Dias Ferias Antec."
	@ aRetcoords[08][1]   , aRetcoords[08][2] MSGET oDFerAnt VAR nDFerAnt PICTURE "999.99" WHEN nOpcLbx#3 VALID nDFerAnt >= 0;
	                         SIZE 60,10 OF oDlg PIXEL HASBUTTON

	@ aRetcoords[11][1]   , aRetcoords[11][2] SAY OemtoAnsi(STR0015) SIZE 60,10 OF oDlg PIXEL  //"Dias Faltas Venc."
	@ aRetcoords[12][1]   , aRetcoords[12][2] MSGET oDFalVen VAR nDFalVen PICTURE "999.99" WHEN nOpcLbx#3 VALID nDFalVen >= 0;
	                         SIZE 60,10 OF oDlg PIXEL HASBUTTON

	@ aRetcoords[15][1]   , aRetcoords[15][2] SAY OemtoAnsi(STR0016) SIZE 60,10 OF oDlg PIXEL  //"Dias Faltas Prop."
	@ aRetcoords[16][1]   , aRetcoords[16][2] MSGET oDFalPro VAR nDFalPro PICTURE "999.99" WHEN nOpcLbx#3 VALID nDFalPro >= 0;
	                         SIZE 60,10 OF oDlg PIXEL HASBUTTON

	@ aRetcoords[19][1]   , aRetcoords[19][2] SAY OemtoAnsi(STR0017) SIZE 60,10 OF oDlg PIXEL  //"Tipo de Movimento"
	@ aRetcoords[20][1]   , aRetcoords[20][2] MSCOMBOBOX oTipoMov VAR cTipoMov WHEN nOpcLbx#3 ITEMS aTipoMov SIZE 85,10 OF oDlg PIXEL

	@ aRetcoords[23][1]   , aRetcoords[23][2] SAY OemtoAnsi(STR0018) SIZE 60,10 OF oDlg PIXEL  //"Valor do Salario"
	@ aRetcoords[24][1]   , aRetcoords[24][2] MSGET oValSal VAR nValSal PICTURE "@E 9,999,999,999.99" WHEN nOpcLbx#3 VALID nValSal >= 0;
	                         SIZE 60,10 OF oDlg PIXEL HASBUTTON

	@ aRetcoords[27][1]   , aRetcoords[27][2] SAY OemtoAnsi(STR0019) SIZE 60,10 OF oDlg PIXEL  //"Avos 13o"
	@ aRetcoords[28][1]   , aRetcoords[28][2] MSGET oAvos13 VAR nAvos13 PICTURE "999.99" WHEN nOpcLbx#3 VALID nAvos13 >= 0;
	                         SIZE 60,10 OF oDlg PIXEL HASBUTTON
Else

	DEFINE MSDIALOG oDlg FROM  190,10 TO 520,625 TITLE cDescTit PIXEL

	@ aRetcoords[01][1]   , aRetcoords[01][2] SAY OemtoAnsi(STR0010) SIZE 60,10 OF oDlg PIXEL  //"Data do Calculo"
	@ aRetcoords[02][1]   , aRetcoords[02][2] MSGET oDtCalPro 	VAR dDtCalPro WHEN (nOpcLbx==1) VALID !Empty(dDtCalPro);
			  SIZE 60,10 OF oDlg PIXEL HASBUTTON

	@ aRetcoords[05][1]   , aRetcoords[05][2] SAY OemtoAnsi(STR0050) SIZE 60,10 OF oDlg PIXEL  //"Centro de Custo"
	@ aRetcoords[06][1]   , aRetcoords[06][2] MSGET oCentroC  	VAR cCentroC WHEN (nOpcLbx==1) F3 "SI3";
		      SIZE 60,10 OF oDlg PIXEL HASBUTTON


	@ aRetcoords[09][1]   , aRetcoords[09][2] SAY OemtoAnsi(STR0011) SIZE 60,10 OF oDlg PIXEL  //"Data Base Ferias"
	@ aRetcoords[10][1]   , aRetcoords[10][2] MSGET oDtBasFer 	VAR dDtBasFer WHEN nOpcLbx#3 SIZE 60,10 OF oDlg PIXEL HASBUTTON

	@ aRetcoords[13][1]   , aRetcoords[13][2] SAY OemtoAnsi(STR0012) SIZE 60,10 OF oDlg PIXEL  //"Dias Ferias Venc."
	@ aRetcoords[14][1]   , aRetcoords[14][2] MSGET oDFerVenc VAR nDFerVenc PICTURE "999.99" WHEN nOpcLbx#3 VALID nDFerVenc >= 0;
	                          SIZE 60,10 OF oDlg PIXEL HASBUTTON

	@ aRetcoords[17][1]   , aRetcoords[17][2] SAY OemtoAnsi(STR0013) SIZE 60,10 OF oDlg PIXEL  //"Dias Ferias Prop."
	@ aRetcoords[18][1]   , aRetcoords[18][2] MSGET oDFerProp VAR nDFerProp PICTURE "999.99" WHEN nOpcLbx#3 VALID nDFerProp >= 0;
	                          SIZE 60,10 OF oDlg PIXEL HASBUTTON

	@ aRetcoords[21][1]   , aRetcoords[21][2] SAY OemtoAnsi(STR0014) SIZE 60,10 OF oDlg PIXEL  //"Dias Ferias Antec."
	@ aRetcoords[22][1]   , aRetcoords[22][2] MSGET oDFerAnt VAR nDFerAnt PICTURE "999.99" WHEN nOpcLbx#3 VALID nDFerAnt >= 0;
	                         SIZE 60,10 OF oDlg PIXEL HASBUTTON

	@ aRetcoords[07][1]   , aRetcoords[07][2] SAY OemtoAnsi(STR0015) SIZE 60,10 OF oDlg PIXEL  //"Dias Faltas Venc."
	@ aRetcoords[08][1]   , aRetcoords[08][2] MSGET oDFalVen VAR nDFalVen PICTURE "999.99" WHEN nOpcLbx#3 VALID nDFalVen >= 0;
	                         SIZE 60,10 OF oDlg PIXEL HASBUTTON

	@ aRetcoords[11][1]   , aRetcoords[11][2] SAY OemtoAnsi(STR0016) SIZE 60,10 OF oDlg PIXEL  //"Dias Faltas Prop."
	@ aRetcoords[12][1]   , aRetcoords[12][2] MSGET oDFalPro VAR nDFalPro PICTURE "999.99" WHEN nOpcLbx#3 VALID nDFalPro >= 0;
	                         SIZE 60,10 OF oDlg PIXEL HASBUTTON

	@ aRetcoords[15][1]   , aRetcoords[15][2] SAY OemtoAnsi(STR0017) SIZE 60,10 OF oDlg PIXEL  //"Tipo de Movimento"
	@ aRetcoords[16][1]   , aRetcoords[16][2] MSCOMBOBOX oTipoMov VAR cTipoMov WHEN nOpcLbx#3 ITEMS aTipoMov SIZE 85,10 OF oDlg PIXEL

	@ aRetcoords[19][1]   , aRetcoords[19][2] SAY OemtoAnsi(STR0018) SIZE 60,10 OF oDlg PIXEL  //"Valor do Salario"
	@ aRetcoords[20][1]   , aRetcoords[20][2] MSGET oValSal VAR nValSal PICTURE "@E 9,999,999,999.99" WHEN nOpcLbx#3 VALID nValSal >= 0;
	                         SIZE 60,10 OF oDlg PIXEL HASBUTTON

	@ aRetcoords[23][1]   , aRetcoords[23][2] SAY OemtoAnsi(STR0019) SIZE 60,10 OF oDlg PIXEL  //"Avos 13o"
	@ aRetcoords[24][1]   , aRetcoords[24][2] MSGET oAvos13 VAR nAvos13 PICTURE "999.99" WHEN nOpcLbx#3 VALID nAvos13 >= 0;
	                         SIZE 60,10 OF oDlg PIXEL HASBUTTON

EndIf

ACTIVATE MSDIALOG oDlg On Init Enchoicebar( oDlg, { || nOpc1 := 1,If(nOpcLbx == 1, If(NaoVazio(dDtBasFer), oDlg:End(),oDtBasFer:SetFocus() ) , oDlg:End()) }, { || nOpc1 := 0,oDlg:End() } ) CENTERED

If nOpc1 = 1
	If nOpcLbx = 1		// Inclusao no ListBox
		If Len(aLbx) == 1 .And. Empty(aLbx[1,_DatCalc])
			aLbx[1,_DatCalc] := dDtCalPro
			aLbx[1,_CentroC] := cCentroC
			aLbx[1,_DBsProv] := dDtBasFer
			aLbx[1,_DFerVen] := nDFerVenc
			aLbx[1,_DFerPro] := nDFerProp
			aLbx[1,_DFerAnt] := nDFerAnt
			aLbx[1,_DFalVen] := nDFalVen
			aLbx[1,_DFalPro] := nDFalPro
			aLbx[1,_MovProv] := Val(cTipoMov)
			aLbx[1,_SalProv] := nValSal
			aLbx[1,_Avos13S] := nAvos13
			aLbx[1,_PStatus] := STR0026 //"Ativo"
			If lItemClVl
				aLbx[1,_cItem]	 := cItem
				aLbx[1,_CLVL]	 := cClvl
			EndIf
		Else
			If lItemClVl
				Aadd( aLbx, { dDtCalPro,cCentroC,dDtBasFer,nDFerVenc,nDFerProp,nDFerAnt,;
							   nDFalVen,nDFalPro,Val(cTipoMov),nValSal,nAvos13,STR0026,cItem,cClvl }) //"Ativo"
			Else
				Aadd( aLbx, { dDtCalPro,cCentroC,dDtBasFer,nDFerVenc,nDFerProp,nDFerAnt,;
							   nDFalVen,nDFalPro,Val(cTipoMov),nValSal,nAvos13,STR0026}) //"Ativo"
			EndIf
			A070AtuGD(nPosLbx,2)
			nUsado := Len(aHeader)
			aCols := Array(1,nUsado+1)
			fMontAcols(@aCols)
			Aadd(aTotaCols, { aCols, dDtCalPro })
			Aadd(aTotRecno,{ { 0 }, dDtCalPro })
		EndIf
	ElseIf nOpcLbx = 2   	// Alteracao no ListBox
		aLbx[nPosLbx,_DatCalc] := dDtCalPro
		aLbx[nPosLbx,_CentroC] := cCentroC
		aLbx[nPosLbx,_DBsProv] := dDtBasFer
		aLbx[nPosLbx,_DFerVen] := nDFerVenc
		aLbx[nPosLbx,_DFerPro] := nDFerProp
		aLbx[nPosLbx,_DFerAnt] := nDFerAnt
		aLbx[nPosLbx,_DFalVen] := nDFalVen
		aLbx[nPosLbx,_DFalPro] := nDFalPro
		aLbx[nPosLbx,_MovProv] := Val(cTipoMov)
		aLbx[nPosLbx,_SalProv] := nValSal
		aLbx[nPosLbx,_Avos13S] := nAvos13
		aLbx[nPosLbx,_PStatus] := STR0026 //"Ativo"
		If lItemClVl
			aLbx[nPosLbx,_cItem]   := cItem
			aLbx[nPosLbx,_CLVL]    := cClvl
		EndIf
   ElseIf nOpcLbx = 3  	   // Exclusao no ListBox
		aLbx[nPosLbx,_PStatus] := If(aLbx[nPosLbx,_PStatus]==STR0026, STR0027, STR0026) //Ativo##Excluido
		If Len(aLbx) == 1 .And. Empty(aLbx[1,1])
			If lItemClVl
				aLbx := { CTOD(""),Space(9),CTOD(""),0,0,0,0,0,0,0,0,STR0026,Space(GetSx3Cache("RHQ_ITEM","X3_TAMANHO")),Space(GetSx3Cache("RHQ_CLVL","X3_TAMANHO")) } // Ativo
			Else
				aLbx := { CTOD(""),Space(9),CTOD(""),0,0,0,0,0,0,0,0,STR0026 } // Ativo
			EndIf
		EndIf

		//| Exclui todos os elementos da acols							 

		For nCnt1 := 1 To Len(aCols)
			aCols[nCnt1,nUsado+1] := If(aCols[nCnt1,nUsado+1] == .F., .T., .F.)
		Next nCnt1
		A070AtuGD(nPosLbx,2)
	EndIf
EndIf

Return dDtCalPro

/*


Ŀ
Funcao     A070Acres Autor  Emerson Rosa de Souza  Data  28.07.00 
Ĵ
Descricao  Atualiza os arrays do listbox em qual operacao efetuada    
Ĵ
Sintaxe    A070Acres(ExpN1,ExpO1,ExpD1)                               
Ĵ
Parametros nPos = posicao no listbox                                  
           oLbx = objeto do listbox                                   
           dVar = Data da provisao                                    
Ĵ
Uso        RSPA070                                                    
ٱ

*/
Static Function A070Acres(nPos,oLbx,dVar)
Local nPosAtu := 0
dVar := If(dVar==Nil,CTOD(""),dVar)
If Len(aLbx) # 0
	aLbx      := ASort(aLbx,,,     { |x,y| x[1]>y[1] })
	aTotAcols := ASort(aTotAcols,,,{ |x,y| x[2]>y[2] })
	aTotRecno := ASort(aTotRecno,,,{ |x,y| x[2]>y[2] })
	nPosAtu	:= Ascan(aLbx,{|x| x[1] == dVar })
	nPosAtu := If(nPosAtu==0,1,nPosAtu)
	oLbx:SetArray(aLbx)
	If lItemClVl
		oLbx:bLine := { ||  { aLbx[oLbx:nAt,_DatCalc],aLbx[oLbx:nAt,_CentroC],aLbx[oLbx:nAt,_DBsProv],aLbx[oLbx:nAt,_DFerVen],;
	    	                   aLbx[oLbx:nAt,_DFerPro],aLbx[oLbx:nAt,_DFerAnt],aLbx[oLbx:nAt,_DFalVen],aLbx[oLbx:nAt,_DFalPro],;
	        	               aLbx[oLbx:nAt,_MovProv],aLbx[oLbx:nAt,_SalProv],aLbx[oLbx:nAt,_Avos13S],aLbx[oLbx:nAt,_PStatus],;
	        	               aLbx[oLbx:nAt,_cItem],aLbx[oLbx:nAt,_Clvl]}}
	Else
		oLbx:bLine := { ||  { aLbx[oLbx:nAt,_DatCalc],aLbx[oLbx:nAt,_CentroC],aLbx[oLbx:nAt,_DBsProv],aLbx[oLbx:nAt,_DFerVen],;
    		                   aLbx[oLbx:nAt,_DFerPro],aLbx[oLbx:nAt,_DFerAnt],aLbx[oLbx:nAt,_DFalVen],aLbx[oLbx:nAt,_DFalPro],;
        		               aLbx[oLbx:nAt,_MovProv],aLbx[oLbx:nAt,_SalProv],aLbx[oLbx:nAt,_Avos13S],aLbx[oLbx:nAt,_PStatus]}}
	EndIf
	oLbx:nAt   := nPosAtu
	EVal(oLbx:bChange)
EndIf
oLbx:Refresh()
Return Nil

/*


Ŀ
Funcao     fTotProv    Autor  Emerson R. de Souza  Data  09.08.00 
Ĵ
Descricao  Totaliza a provisao e apresenta no video                   
Ĵ
Sintaxe    fTotProv()                                                 
Ĵ
Parametros                                                            
ٱ

*/
Static Function fTotProv(nOpcx)
Local oDlg,oFont,oFont1
Local nOpc1   := 0
Local nUltPos := _Colunas + 1
Local aProvFer    := Array(nUltPos)
Local aProv13s    := Array(nUltPos)
Local nPosAlbx    := oLbx:nAt
Local nCnt1
Local aRetcoords	:= {}
Local bSet15
Local bSet24
Local aBotoes
Private aVerba  := {}

AFILL(aProvFer,0)
AFILL(aProv13s,0)

//CARREGA OS IDENTIFICADORES DA PROVISAO
fIdentProv(@aVerba,aCodFol,.T.,.T.)
For nCnt1 := 1 To Len(aCols)
	If nOpcx == 2 .Or. nOpcx == 5 .Or. aCols[nCnt1,nUsado+1] == .F.
	   	nPosVerba := Ascan(aVerba, { |X| X[4] == aCols[nCnt1,2] })
		//SE HOUVER IDENTIFICADOR GRAVA NA POSICAO PRE-DEFINIDA, CASO CONTRARIO GRAVA EM OUTROS VALORES
		If nPosVerba > 0
		    nPosCol := aVerba[nPosVerba,3]
		    If aVerba[nPosVerba,1] == _FerVenc
				aProvFer[nPosCol] += aCols[nCnt1,4] // Valor
			Else
				aProv13s[nPosCol] += aCols[nCnt1,4] // Valor
			EndIf
		Else
			If aCols[nCnt1,1] $ Str(_FerVenc,1) + Str(_FerProp,1)
				aProvFer[nUltPos] += aCols[nCnt1,4] // Valor
			Else
				aProv13s[nUltPos] += aCols[nCnt1,4] // Valor
			EndIf
		EndIf
	EndIf
Next nCnt1

aRetcoords := RetCoords(3,11,80,10)
DEFINE FONT oFont  NAME "Courier New"  SIZE 7,16 BOLD
DEFINE FONT oFont1 NAME "Courier New"  SIZE 7,16
DEFINE MSDIALOG oDlg FROM  190,10 TO 500,530 TITLE OemToAnsi(STR0039) PIXEL //"Totais da Provisao"

bSet15 := {|| nOpc1 := 1,oDlg:End()}
bSet24 := {|| oDlg:End()}

@ aRetcoords[01][1]   , aRetcoords[01][2] SAY OemtoAnsi(STR0040) SIZE 70,10 OF oDlg PIXEL FONT oFont COLOR CLR_BLUE //"Referencia"
@ aRetcoords[07][1]   , aRetcoords[07][2] SAY OemtoAnsi(STR0041) SIZE 70,10 OF oDlg PIXEL FONT oFont1 //"Dias/Avos"
@ aRetcoords[10][1]   , aRetcoords[10][2] SAY OemtoAnsi(STR0042) SIZE 70,10 OF oDlg PIXEL FONT oFont1 //"Valor"
@ aRetcoords[13][1]   , aRetcoords[13][2] SAY OemtoAnsi(STR0043) SIZE 70,10 OF oDlg PIXEL FONT oFont1 //"Adicionais"
@ aRetcoords[16][1]   , aRetcoords[16][2] SAY OemtoAnsi(STR0044) SIZE 70,10 OF oDlg PIXEL FONT oFont1 //"Um Terco/1a Parcela"
@ aRetcoords[19][1]   , aRetcoords[19][2] SAY OemtoAnsi(STR0045) SIZE 70,10 OF oDlg PIXEL FONT oFont1 //"INSS"
@ aRetcoords[22][1]   , aRetcoords[22][2] SAY OemtoAnsi(STR0046) SIZE 70,10 OF oDlg PIXEL FONT oFont1 //"FGTS"
@ aRetcoords[25][1]   , aRetcoords[25][2] SAY OemtoAnsi(STR0051) SIZE 70,10 OF oDlg PIXEL FONT oFont1 //"Outros Valores"
@ aRetcoords[31][1]   , aRetcoords[31][2] SAY OemtoAnsi(STR0047) SIZE 70,10 OF oDlg PIXEL FONT oFont COLOR CLR_RED //"T O T A L"

@ aRetcoords[02][1]   , aRetcoords[02][2] SAY OemtoAnsi(STR0048) SIZE 70,10 OF oDlg PIXEL FONT oFont COLOR CLR_BLUE //"Provisao de Ferias"
@ aRetcoords[08][1]   , aRetcoords[08][2] SAY ( MAX(aLbx[nPosAlbx,_DFerVen]+aLbx[nPosAlbx,_DFerPro]-aLbx[nPosAlbx,_DFerAnt], 0) ) PICTURE "@E 9,999,999,999.99" SIZE 70,10 OF oDlg PIXEL FONT oFont1
@ aRetcoords[11][1]   , aRetcoords[11][2] SAY aProvFer[_Prov]   PICTURE "@E 9,999,999,999.99" SIZE 70,10 OF oDlg PIXEL FONT oFont1
@ aRetcoords[14][1]   , aRetcoords[14][2] SAY aProvFer[_Adic]   PICTURE "@E 9,999,999,999.99" SIZE 70,10 OF oDlg PIXEL FONT oFont1
@ aRetcoords[17][1]   , aRetcoords[17][2] SAY aProvFer[_1Ter]   PICTURE "@E 9,999,999,999.99" SIZE 70,10 OF oDlg PIXEL FONT oFont1
@ aRetcoords[20][1]   , aRetcoords[20][2] SAY aProvFer[_INSS]   PICTURE "@E 9,999,999,999.99" SIZE 70,10 OF oDlg PIXEL FONT oFont1
@ aRetcoords[23][1]   , aRetcoords[23][2] SAY aProvFer[_FGTS]   PICTURE "@E 9,999,999,999.99" SIZE 70,10 OF oDlg PIXEL FONT oFont1
@ aRetcoords[26][1]   , aRetcoords[26][2] SAY aProvFer[nUltPos] PICTURE "@E 9,999,999,999.99" SIZE 70,10 OF oDlg PIXEL FONT oFont1
@ aRetcoords[32][1]   , aRetcoords[32][2] SAY aProvFer[_Prov]+aProvFer[_Adic]+aProvFer[_1Ter]+;
              aProvFer[_INSS]+aProvFer[_FGTS]+aProvFer[nUltPos] PICTURE "@E 9,999,999,999.99" SIZE 70,10 OF oDlg PIXEL;
              FONT oFont COLOR CLR_RED

@ aRetcoords[03][1]   , aRetcoords[03][2] SAY OemtoAnsi(STR0049) SIZE 70,10 OF oDlg PIXEL FONT oFont COLOR CLR_BLUE //"Provisao 13 Salario"
@ aRetcoords[09][1]   , aRetcoords[09][2] SAY aLbx[nPosAlbx,_Avos13s] PICTURE "@E 9,999,999,999.99" SIZE 70,10 OF oDlg PIXEL FONT oFont1
@ aRetcoords[12][1]   , aRetcoords[12][2] SAY aProv13s[_Prov]   PICTURE "@E 9,999,999,999.99" SIZE 70,10 OF oDlg PIXEL FONT oFont1
@ aRetcoords[15][1]   , aRetcoords[15][2] SAY aProv13s[_Adic]   PICTURE "@E 9,999,999,999.99" SIZE 70,10 OF oDlg PIXEL FONT oFont1
@ aRetcoords[18][1]   , aRetcoords[18][2] SAY aProv13s[_1Par]   PICTURE "@E 9,999,999,999.99" SIZE 70,10 OF oDlg PIXEL FONT oFont1
@ aRetcoords[21][1]   , aRetcoords[21][2] SAY aProv13s[_INSS]   PICTURE "@E 9,999,999,999.99" SIZE 70,10 OF oDlg PIXEL FONT oFont1
@ aRetcoords[24][1]   , aRetcoords[24][2] SAY aProv13s[_FGTS]   PICTURE "@E 9,999,999,999.99" SIZE 70,10 OF oDlg PIXEL FONT oFont1
@ aRetcoords[27][1]   , aRetcoords[27][2] SAY aProv13s[nUltPos] PICTURE "@E 9,999,999,999.99" SIZE 70,10 OF oDlg PIXEL FONT oFont1
@ aRetcoords[33][1]   , aRetcoords[33][2] SAY aProv13s[_Prov]+aProv13s[_Adic]-aProv13s[_1Par]+;
              aProv13s[_INSS]+aProv13s[_FGTS]+aProv13s[nUltPos] PICTURE "@E 9,999,999,999.99" SIZE 70,10 OF oDlg PIXEL;
              FONT oFont COLOR CLR_RED

ACTIVATE MSDIALOG oDlg ON INIT EnchoiceBar( oDlg, bSet15, bSet24,, aBotoes ) CENTERED
Return .T.

/*


Ŀ
Funcao     fMontAcols  Autor  Emerson R. de Souza  Data  09.08.00 
Ĵ
Descricao  Monta o primeiro elemento da aCols                         
Ĵ
Sintaxe    fMontAcols(aColsTmp)                                       
Ĵ
Parametros                                                            
ٱ

*/
Static Function fMontAcols(aColsTmp)
Local cAlias    := ALIAS()
Local nUsadoTmp	:= 0
Local nUsado 	:= Len(aHeader)

dbSelectArea("SX3")
dbseek("SRT")
While !EOF() .And. (x3_arquivo == "SRT")
	IF x3uso(x3_usado) .AND. cNivel >= x3_nivel .and. ASCAN(aCposAlbx,Trim(x3_campo)) == 0
		nUsadoTmp ++
		IF x3_tipo == "C"
			aColsTmp[1,nUsadoTmp] := SPACE(x3_tamanho)
		ELSEIF x3_tipo == "N"
			aColsTmp[1,nUsadoTmp] := 0
		ELSEIF x3_tipo == "D"
			aColsTmp[1,nUsadoTmp] := CTOD("")
		Endif
	Endif
	dbSkip()
EndDo
// GRAVACAO PARA O USO DO WT
aColsTmp[1,nUsado-1] := "SRT"
aColsTmp[1,nUsado] 	 := 0
aColsTmp[1,nUsado+1] := .F.

dbSelectArea(cAlias)

Return

/*
Ŀ
Funcao     MenuDef		Autor  Luiz Gustavo      Data 13/12/2006   
Ĵ
Descricao Isola opcoes de menu para que as opcoes da rotina possam    
          ser lidas pelas bibliotecas Framework da Versao 9.12 .      
Ĵ
Sintaxe   < Vide Parametros Formais >									
Ĵ
 Uso      GPEA070                                                     
Ĵ
 Retorno  aRotina														
Ĵ
Parametros< Vide Parametros Formais >									
*/
Static Function MenuDef()

// Define array contendo as Rotinas a executar do programa      
// ----------- Elementos contidos por dimensao ------------     
// 1. Nome a aparecer no cabecalho                              
// 2. Nome da Rotina associada                                  
// 3. Usado pela rotina                                         
// 4. Tipo de Transao a ser efetuada                          
//    1 - Pesquisa e Posiciona em um Banco de Dados             
//    2 - Simplesmente Mostra os Campos                         
//    3 - Inclui registros no Bancos de Dados                   
//    4 - Altera o registro corrente                            
//    5 - Remove o registro corrente do Banco de Dados          
// A funcao GpeProvisao Carrega variaveis privates comuns a     |
// GPEA070,GPER070 e GPEM070
Local aRotina 	:= {}
Local lPLRPE	:= ExistBlock("GP070PLR")
Local lRateio	:= GetMvRH("MV_RATPROV",,"N") == "S"
Local lVer027	:= GetRPORelease() >= "12.1.027"

aAdd(aRotina, {	STR0001, "AxPesqui"   	, 0 , 1,,.F.} )  			//"Pesquisar"
aAdd(aRotina, {	STR0002, "GpeProvisao" 	, 0 , 2} )  				//"Visualizar"
aAdd(aRotina, {	STR0003, "GpeProvisao" 	, 0 , 4} )  				//"Incluir"
aAdd(aRotina, {	STR0004, "GpeProvisao" 	, 0 , 4} )  				//"Alterar"
If lRateio
	aAdd(aRotina, {	STR0065, "VIEWDEF.GPEA071", 0 , 4} )  			//"Proviso Rateada"
	aAdd(aRotina, {	STR0063+" "+STR0031, "GP056Fer", 0 , 2} )  		//"Impr. Mensal de Ferias"
EndIf
aAdd(aRotina, {	STR0054+" "+STR0031, "GPER070", 0 , 2} )  			//"Imprimir Ferias"
If lRateio
	aAdd(aRotina, {	STR0063+" "+STR0023, "GP056Dec", 0 , 2} )  		//"Impr. Mensal de 13o"
EndIf
aAdd(aRotina, {	STR0054+" "+STR0023, "GPER090", 0 , 2} )  			//"Imprimir 13o"
If fConfigSV()
	aAdd(aRotina, {STR0123, "fCallProvSV()", 0 , 2})                //"Impr. Frias/13 Smart View"
EndIf
aAdd(aRotina, {	STR0055, "GPEM070"   	, 0 , 2} )  				//"Calculo"
If cPaisLoc == "BRA"
	aAdd(aRotina, {	STR0121, "GP070EXC(.F.)"   	, 0 , 5} )  			//"Excluso em lote"
EndIf
aAdd(aRotina, {	STR0068, "GPER071"   	, 0 , 2} )  				//"Divergncias"
aAdd(aRotina, {	STR0059, "GpLegend" , 0 , 5 , ,.F.} )  				//"Legenda"
If !lVer027
	aadd(aRotina,{	STR0067 ,"GPER080", 0 , 2})  					//"Relatrio Mdias"
EndIf
If lPLRPE
	aadd(aRotina,{	STR0054+" "+ STR0066 ,"GPER095", 0 , 2})  		//"Imprimir Plr"
EndIf

Return aRotina

/*


Ŀ
Funcao     fRetVerbaMes Autor  Christiane Vieira    Data  31/08/12 
Ĵ
Descricao  Retorna a verba de proviso mensal correspondente  verba   
           de proviso acumulada que est sendo atualizada             
Ĵ
 Uso       Generico                                                    
ٱ

*/
Function fRetVerbaMes(cVerba, cVerbaRet)
Local nX	:= 0
Local nId	:= 0
Local aDePara	:= {  { "130" , "960" } ,; 	// Provisao de Ferias					- Tipo Provisao Ferias
					  { "254" , "962" } ,;	// Adicional Provisao de Ferias			- Tipo Provisao Ferias
					  { "255" , "961" } ,;	// Um Terco Provisao de Ferias			- Tipo Provisao Ferias
					  { "131" , "963" } ,;	// INSS Provisao de Ferias				- Tipo Provisao Ferias
					  { "132" , "964" } ,;	// FGTS Provisao de Ferias				- Tipo Provisao Ferias
					  { "416" , "965" } ,; 	// PIS Provisao de Ferias				- Tipo Provisao Ferias
					  { "136" , "966" } ,; 	// Provisao de 13o Salario				- Tipo Provisao 13o.Salario
					  { "267" , "967" } ,; 	// Adicional Provisao de 13o Salario	- Tipo Provisao 13o.Salario
					  { "268" , "968" } ,; 	// 1a. Parcela 13o Provisao				- Tipo Provisao 13o.Salario
					  { "137" , "969" } ,; 	// INSS Provisao 13o Salario			- Tipo Provisao 13o.Salario
					  { "138" , "970" } ,; 	// FGTS Provisao 13o Salario			- Tipo Provisao 13o.Salario
					  { "421" , "971" } }  	// PIS Provisao 13o Salario				- Tipo Provisao 13o.Salario
For nX := 1 To Len(aDePara)
	nId := Val(aDePara[nX,1])
	If aCodFol[nId,1] == cVerba
		nId := Val(aDePara[nX,2]) //Alimenta o nId com o Identificador de Clculo da verba de retorno
		cVerbaRet := aCodFol[nId,1]
		Exit
	Endif
Next nX

Return cVerbaRet

/*


Ŀ
Funcao    fExcluiProvMes  Autor  Christiane Vieira  Data  29/08/12 
Ĵ
Descricao  Excluso dos valores mensais de proviso, referentes ao     
           registro de proviso que est sendo excludo.               
Ĵ
 Uso       Generico                                                    
ٱ

*/
Static Function fExcluiProvMes()
Local aArea		:= GetArea()

dbSelectArea ("RHT")
// Ordem 5 - RHT_FILIAL+RHT_MAT+DTOS(RHT_DTCALC)+RHT_TPPROV
RHT->(dbSetOrder(RetOrdem("RHT","RHT_FILIAL+RHT_MAT+DTOS(RHT_DTCALC)+RHT_TPPROV" ) ) )
dbSeek( SRT->RT_FILIAL+SRT->RT_MAT+DTOS(SRT->RT_DATACAL) )

While !Eof() .And. RHT->RHT_FILIAL + RHT->RHT_MAT + DTOS(RHT->RHT_DTCALC) == SRT->RT_FILIAL + SRT->RT_MAT + DTOS(SRT->RT_DATACAL)
	RecLock( "RHT",.F.,.T.)
	dbDelete()
	MsUnlock()
	dbSkip()
EndDo

RestArea(aArea)

Return NIL

/*


Ŀ
Funcao     fAtuProvMes  Autor  Christiane Vieira    Data  29/08/12 
Ĵ
Descricao  Alterao dos valores mensais de proviso, referentes ao    
           registro de proviso que est sendo alterado.               
Ĵ
Parametros nX = posicao do item no cabealho da proviso               
           nY = posio do item acumulado da proviso                  
Ĵ
 Uso       Generico                                                    
ٱ

*/
Static Function fAtuProvMes(nX, nY,nOpcx)
Local aArea		:= GetArea()
Local nPosAscan	:= 0
Local nAcuAnt	:= 0
Local nAcuMes	:= 0
Local nTpProv	:= 0
Local nVlrMes	:= 0
Local cVerbaAc	:= ""
Local cVerbaMes := ""
Local cVerbasBx	:= ""
//VARIAVEIS PARA O RATEIO
Local nC		:= 0
Local nQtd		:= 0
Local nPerc		:= 0
Local nValDiv 	:= 0
Local nVlComp	:= 0
Local nPosRateio:= 0
Private aRateio	:= {}

//ARMAZENA TODAS AS VERBAS REFERENTES AOS IDENTIFICADORES DE BAIXA (FERIAS E 13)
cVerbasBx +=  aCodFol[332,1] + " - " + aCodFol[333,1] + " - " + aCodFol[334,1] + " - " + aCodFol[335,1] + " - "
cVerbasBx +=  aCodFol[336,1] + " - " + aCodFol[423,1] + " - " + aCodFol[270,1] + " - " + aCodFol[271,1] + " - "
cVerbasBx +=  aCodFol[272,1] + " - " + aCodFol[273,1] + " - " + aCodFol[424,1] + " - " + aCodFol[274,1] + " - "
cVerbasBx +=  aCodFol[275,1] + " - " + aCodFol[276,1] + " - " + aCodFol[277,1] + " - " + aCodFol[425,1] + " - "
cVerbasBx +=  aCodFol[233,1] + " - " + aCodFol[258,1] + " - " + aCodFol[259,1] + " - " + aCodFol[234,1] + " - "
cVerbasBx +=  aCodFol[235,1] + " - " + aCodFol[418,1] + " - " + aCodFol[239,1] + " - " + aCodFol[260,1] + " - "
cVerbasBx +=  aCodFol[261,1] + " - " + aCodFol[240,1] + " - " + aCodFol[241,1] + " - " + aCodFol[419,1] + " - "
cVerbasBx +=  aCodFol[262,1] + " - " + aCodFol[263,1] + " - " + aCodFol[264,1] + " - " + aCodFol[265,1] + " - "
cVerbasBx +=  aCodFol[266,1] + " - " + aCodFol[420,1]

nTpProv	:= aTotAcols[nX,1,nY,1]
cVerbaAc:= aTotAcols[nX,1,nY,2]
nAcuMes	:= aTotAcols[nX,1,nY,4]

fRetVerbaMes(cVerbaAc,@cVerbaMes)

If nX < Len(aTotAcols) //quando for o ultimo elemento do array no  possvel encontrar o valor acumulado anterior
	//verifico se existe a verba que foi alterada no acumulado do mes anterior
	nPosAscan	:= Ascan(aTotAcols[nx+1][1],{|x| x[1]== nTpProv .And. x[2]== cVerbaAc  })
    If nPosAscan > 0
		nAcuAnt	:= aTotAcols[nX+1,1,nPosAscan,4]
	Endif
Endif

nVlrMes := nAcuMes - nAcuAnt //Valor do ms  o valor acumulado atual menos o valor do acumulado anterior

//CARREGA O RATEIO POR CENTRO DE CUSTO DA TABELA DE RATEIOS - RHQ
aRateio	:= {}

//VERIFICA SE A VERBA NO  DE BAIXA, VERBAS DE BAIXA NO SO RATEADAS
If !(cVerbaAc $ cVerbasBx)
	fRateio({},2) 			// Carrega os registros da tabela RHQ-Programacao de Rateio para pegar os percentuais x centro de custo
Else
	cVerbaMes := cVerbaAc 	//Verbas de baixa so gravadas com o mesmo ID e no so rateadas
Endif

//VERIFICA O TAMANHO DO RETORNO DO ARRAY PARA CRIAR AO MENOS UM REGISTRO PARA A GERACAO
nQtd := Len(aRateio)

If nQtd == 0
	If lItemClVl
	   	aAdd(aRateio,{SRT->RT_CC, SRT->RT_ITEM, SRT->RT_CLVL, 100, "S", 0, ""})
	Else
	   	aAdd(aRateio,{SRT->RT_CC, Space(GetSx3Cache("RHQ_ITEM","X3_TAMANHO")), Space(GetSx3Cache("RHQ_CLVL","X3_TAMANHO")), 100, "S", 0, ""})
	Endif
	nQtd := 1
Else
	// VERIFICA SE EXISTEM ORIGENS SISTEMAS (CAMPO RHQ_ORIGEM = 'S') E TAMBEM GERADAS PELO
	// USUARIO PARA CONSIDERAR APENAS OS REGISTROS DO TIPO USUARIO (CAMPOS RHQ_ORIGEM = 'U'),
	// CASO EXISTIR APENAS UM TIPO, IRA CONSIDERAR O QUE EXISTIR
    If aScan(aRateio, { |X| X[5] == "S" })	> 0 .And. aScan(aRateio, { |X| X[5] == "U" })	> 0
	    For nC := 1 to Len(aRateio)
			If  ( nPosRateio := aScan(aRateio, { |X| X[5] == "S" })) > 0
				aDel(aRateio , nPosRateio)
				aSize(aRateio,Len(aRateio)-1)
			Endif
	    Next
		nQtd := Len(aRateio)
	Endif
Endif

If !nVlrMes == 0
	For nC := 1 to nQtd
		If nC # nQtd
			nValDiv := Round( nVlrMes * aRateio[nC,4],2)
			nVlComp += nValDiv
		Else
			nValDiv := nVlrMes-nVlComp
		Endif
		nPerc := aRateio[nC,4]
		If nPerc < 1
			nPerc := nPerc * 100
		Endif
	   	// Ordem 4 - RHT_FILIAL+RHT_MAT+RHT_CC+RHT_ITEM+RHT_CLVL+DTOS(RHT_DTCALC)+RHT_TPPROV+RHT_VERBA
		RHT->(dbSetOrder(RetOrdem("RHT","RHT_FILIAL+RHT_MAT+RHT_CC+RHT_ITEM+RHT_CLVL+DTOS(RHT_DTCALC)+RHT_TPPROV+RHT_VERBA" ) ) )
		If RHT->(dbSeek(SRT->RT_FILIAL+SRT->RT_MAT+aRateio[nC,1]+aRateio[nC,2]+aRateio[nC,3]+DTOS(SRT->RT_DATACAL)+nTpProv+cVerbaMes)) .Or. nOpcx == 3
			If nOpcx == 3
				RecLock( "RHT", .T. )
				RHT->RHT_FILIAL  := SRT->RT_FILIAL
				RHT->RHT_MAT     := SRT->RT_MAT
				RHT->RHT_CC      := aRateio[nC,1]
				If lItemClVl
					RHT->RHT_ITEM := aRateio[nC,2]
					RHT->RHT_CLVL := aRateio[nC,3]
				EndIf
				RHT->RHT_TPPROV := nTpProv
				RHT->RHT_VERBA  := cVerbaMes
				RHT->RHT_DTCALC := SRT->RT_DATACAL
				RHT->RHT_PERC	:= nPerc
			Else
				RecLock("RHT", .F.)
			Endif
			RHT->RHT_VALOR  := nValDiv
			MsUnlock()
		Endif
	Next nC
Endif

RestArea(aArea)
Return NIL

/*/{Protheus.doc} fMedia
/Relatorio de medias
@author flavio.scorrea
@since 23/10/2019
/*/
Static Function fMedia()
Local lTemTransf := .F.
Local lverSV	 := FindFunction("fConfigSV")

If fTemHMed(aLbx[oLbx:nAt,_DatCalc],Nil,anomes(aLbx[oLbx:nAt,_DatCalc]),"01","PRV",@lTemTransf, "P")
	
	If lverSV .And. fConfigSV()
		IF !fCallMediaSV("P", aLbx[oLbx:nAt,_DatCalc],, lTemTransf)
			fVerHistMed("P",aLbx[oLbx:nAt,_DatCalc], lTemTransf)
		EndIf	
	Else	
		fVerHistMed("P",aLbx[oLbx:nAt,_DatCalc], lTemTransf)
	EndIf		
Else
	Aviso(STR0103,STR0104) //"Ateno"##"Sem dados para imprimir!"
EndIf

Return


/*/{Protheus.doc} fDelHist
/Delete historico de medias
@author flavio.scorrea
@since 23/10/2019
/*/
Static Function fDelHist(dRef)
Local lHistMed		:= AliasInDic("RJK") .And. AliasInDic("SRP") .And. FindFunction("fTemHMed")

If lHistMed
	If fTemHMed(dRef,,anomes(dRef),"01","PRV")
		cIdHistMed := RJK->RJK_ID
		fDelHMedId(cIdHistMed)
	Endif
EndIf

Return

/*/{Protheus.doc} fMsgIds
Mensagem de alerta sobre Ids "obrigatrios" para proviso
@author Allyson Mesashi
@since 18/03/2021
/*/
Static Function fMsgIds()

Local aAreaSRV 	:= SRV->( GetArea() )
Local lRet		:= .T.
Local oButton1
Local oGroup1
Local oPanel1
Local oSay1
Local oSay2
Local oDlg

dbSelectArea("SRV")
SRV->( dbSetOrder(2) )
If !SRV->( dbSeek( xFilial("SRV") + "0332" ) ) .Or.;
	!SRV->( dbSeek( xFilial("SRV") + "0333" ) ) .Or.;
	!SRV->( dbSeek( xFilial("SRV") + "0334" ) ) .Or.;
	!SRV->( dbSeek( xFilial("SRV") + "0335" ) ) .Or.;
	!SRV->( dbSeek( xFilial("SRV") + "0336" ) ) .Or.;
	!SRV->( dbSeek( xFilial("SRV") + "1854" ) )
	lRet := .F.

	DEFINE MSDIALOG oDlg TITLE OemToAnsi(STR0009) FROM 000, 000  TO 200, 500 COLORS 0, 16777215 PIXEL //#STR0009 = "Provises"

		@ 000, 000 MSPANEL oPanel1 SIZE 300, 150 OF oDlg COLORS 0, 16777215 RAISED
		@ 005, 012 GROUP oGroup1 TO 055, 237 PROMPT OemToAnsi(STR0103) OF oPanel1 COLOR 0, 16777215 PIXEL //#STR0103 = "Ateno"
		@ 017, 017 SAY oSay1 PROMPT OemToAnsi(STR0105 + CRLF + STR0107) SIZE 215, 035 OF oPanel1 COLORS 0, 16777215 PIXEL //#STR0105 = "Os IDs de clculo 0332, 0333, 0334, 0335, 0336 e 1854 so obrigatrios, mas no existem verbas vinculadas a todos os IDs. A rotina ser abortada."|STR0107 = "Verifique a documentao conforme orientaes no link abaixo""
		@ 063, 012 SAY oSay2 PROMPT "https://tdn.totvs.com/x/IoVNKw" SIZE 095, 007 OF oPanel1 COLORS 0, 16777215 PIXEL
		@ 070, 200 BUTTON oButton1 PROMPT "OK" SIZE 037, 012 OF oPanel1 PIXEL

		oSay2:bLClicked := {|| ShellExecute("open", "https://tdn.totvs.com/x/IoVNKw", "", "", 1) }

		oButton1:bLClicked := {|| oDlg:End() }

	ACTIVATE MSDIALOG oDlg CENTERED
EndIf

RestArea( aAreaSRV )

Return lRet

/*/{Protheus.doc} GP070EXC
Excluso de clculo da proviso
@author Allyson Mesashi
@since 18/08/2021
/*/
Function GP070EXC( lRobo )

Local aArea 		:= GetArea()
Local aAreaSX1 		:= SX1->( GetArea() )
Local aButtons 		:= {}
Local aLog			:= {}
Local aLogTitle 	:= { Upper(OemToAnsi(STR0108)) } //'Log de ocorrncias da excluso proviso'
Local cPergSX1		:= "GPM070EXCL"
Local cExpFiltro 	:= ""
Local lTemSX1		:= .F.
Local nCont			:= 0
Local nOpca			:= 0

Local aAdvSize		:= {}
Local aInfoAdvSize	:= {}
Local aObjCoords	:= {}
Local aObjSize		:= {}

Private aLogFile  	:= {}
Private lAbortPrint := .F.

Default lRobo		:= .F.

SX1->( dbSetOrder(1) )
lTemSX1	:= SX1->( dbSeek(cPergSX1) )

If !lTemSX1
	fMsgExc()
Else
	If !lRobo
		aAdvSize		:= MsAdvSize(,.T.,280)
		aInfoAdvSize	:= { aAdvSize[1] , aAdvSize[2] , aAdvSize[3] , aAdvSize[4] , 5 , 5 }
		aAdd(aObjCoords , { 000 , 000 , .T. , .T. })
		aObjSize := MsObjSize(aInfoAdvSize , aObjCoords)

		DEFINE FONT oFont NAME "Arial" SIZE 7,-11 BOLD
		DEFINE MSDIALOG oDlg TITLE OemToAnsi(STR0109) From aAdvSize[7],0 TO aAdvSize[6],aAdvSize[5] PIXEL//"Excluso do clculo da proviso"
			@ aObjSize[1,1] , aObjSize[1,2] GROUP oGroup TO aObjSize[1,3], aObjSize[1,4] LABEL OemToAnsi("") OF oDlg PIXEL
			oGroup:oFont:= oFont
			@ aObjSize[1,1]+15	,aObjSize[1,2]+10 SAY   STR0110 Size  500,008 OF oDlg PIXEL FONT oFont//"Excluso do clculo de proviso de frias e 13 salrio"
			@ aObjSize[1,1]+25	,aObjSize[1,2]+10 SAY   STR0111 Size  500,008 OF oDlg PIXEL FONT oFont//"Serprocessado de acordo com os parmetros selecionados pelo usurio."

			bParam := {|| Pergunte(cPergSX1,.T.) }
			AAdd(aButtons, {OemToAnsi(STR0112), bParam 	, OemToAnsi(STR0112), OemToAnsi(STR0112) }  )//"Parmetros"

			bFiltro := {|| GpFltBldExp( "SRA" , NIL , @cExpFiltro , NIL ) }
			AAdd(aButtons, {OemToAnsi(STR0122), bFiltro , OemToAnsi(STR0122), OemToAnsi(STR0122) }  )	//"Filtro"

			bSet15	:= {|o| nOpca := 1,If(GPA070Ok(),oDlg:End(),nOpca:=0)}
			bSet24	:= {|o| oDlg:End() }
		ACTIVATE MSDIALOG oDlg ON INIT EnchoiceBar(oDlg, bSet15 , bSet24 , Nil , aButtons)  CENTERED
	Else
		nOpca := 1
	EndIf
EndIf

If nOpca == 1
	If !lRobo
		ProcGpe({|lEnd| GP070Excl(.F., cExpFiltro)},,,.T.)
	Else
		GP070Excl( .T. )
	EndIf
EndIf

If !Empty(aLogFile)
	aAdd(aLog, {})
	For nCont := 1 To Len(aLogFile)
		aAdd( aLog[1], aLogFile[nCont] )
	Next nCont
	fMakeLog( aLog, aLogTitle, "GPEA070", NIL, FunName(), STR0108 )//'Log de ocorrncias da excluso proviso'
EndIf

RestArea( aAreaSX1 )
RestArea( aArea )

Return

/*/{Protheus.doc} GPA070Ok
Mensagem de confirmao da excluso
@author Allyson Mesashi
@since 18/08/2021
/*/
Static Function GPA070Ok()
Return MsgYesNo(OemToAnsi(STR0113),OemToAnsi(STR0103)) //"Confirma configurao dos parmetros?"###"ATENO"

/*/{Protheus.doc} GP070Excl
Excluso do clculo de proviso
@author Allyson Mesashi
@since 18/08/2021
/*/
Static Function GP070Excl( lRobo, cFiltro )

Local aArea			:= GetArea()
Local aAreaSRT		:= SRT->( GetArea() )
Local aAreaRHT		:= RHT->( GetArea() )
Local cAcessaSRA	:= &( " { || " + IF( Empty( cAcessaSRA := ChkRH( "GPEA070" , "SRA" , "1" ) ) , ".T." , cAcessaSRA ) + " } " )
Local cAliasSRA		:= "QSRA"
Local cCat			:= ""
Local cCCRange		:= ""
Local cFilRange		:= ""
Local cMatRange		:= ""
Local cSit			:= ""
Local cWhere		:= ""
Local dDataAte		:= cToD("")
Local dDataDe		:= cToD("")
Local nQtd			:= 0

Local aOfusca		:= If(FindFunction('ChkOfusca'), ChkOfusca(), {.T., .F.}) //[2]Ofuscamento
Local aFldRel		:= If(aOfusca[2], FwProtectedDataUtil():UsrNoAccessFieldsInList({"RA_NOME"}), {})
Local lOfusca		:= Len(aFldRel) > 0

Default lRobo 		:= .F.
Default cFiltro 	:= ""

Pergunte("GPM070EXCL", .F.)
MakeSqlExpr( "GPM070EXCL" ) //Transforma perguntas do tipo Range em expressao SQL

dDataDe		:= MV_PAR01
dDataAte	:= MV_PAR02
cFilRange	:= MV_PAR03
cMatRange	:= MV_PAR04
cCCRange	:= MV_PAR05
cSit		:= MV_PAR06
cCat		:= MV_PAR07

If !Empty(cFilRange)
	cWhere += cFilRange + " AND "
EndIf

If !Empty(cMatRange)
	cWhere += cMatRange + " AND "
EndIf

If !Empty(cCCRange)
	cWhere += cCCRange + " AND "
EndIf

cSit 	:= "%" + fSqlIn(cSit, 1) + "%"
cCat 	:= "%" + fSqlIn(cCat, 1) + "%"
cWhere	:= "%" + cWhere + "%"

If Select("QSRA") > 0
	QSRA->( dbCloseArea() )
EndIF

BeginSql alias cAliasSRA
	SELECT RA_FILIAL,RA_MAT,RA_NOME
	FROM %table:SRA% SRA
	WHERE %exp:cWhere%
		SRA.RA_SITFOLH IN (%exp:cSit%)    
		AND SRA.RA_CATFUNC IN (%exp:cCat%) 
		AND SRA.%notDel%
	ORDER BY RA_FILIAL,RA_MAT
EndSql

DbSelectArea(cAliasSRA)
Count To nQtd
(cAliasSRA)->( dbGoTop() )

If !lRobo
	GpProcRegua(nQtd)
EndIf

SRT->( dbSetOrder(5) )//RT_FILIAL+RT_MAT+DTOS(RT_DATACAL)+RT_TIPPROV
RHT->( dbSetOrder(5) )//RHT_FILIAL+RHT_MAT+DTOS(RHT_DTCALC)+RHT_TPPROV+RHT_VERBA

While (cAliasSRA)->( !EoF() )
	IF lAbortPrint
		Exit
	EndIf

	If !((cAliasSRA)->RA_FILIAL $ fValidFil() ) .Or. !Eval( cAcessaSRA )
		(cAliasSRA)->( dbSkip() )
		Loop
	EndIf

	If !Empty(cFiltro) 	
		If SRA->( dbSeek( (cAliasSRA)->RA_FILIAL+(cAliasSRA)->RA_MAT ) ) .And. !(&cFiltro) 
			(cAliasSRA)->( dbSkip() )
			Loop
		EndIf
	EndIf

	If !lRobo
		GpIncProc( (cAliasSRA)->RA_FILIAL + " - " + (cAliasSRA)->RA_MAT + If(lOfusca, "", " - " + (cAliasSRA)->RA_NOME) )
	EndIf

	If SRT->( dbSeek( (cAliasSRA)->RA_FILIAL+(cAliasSRA)->RA_MAT ) )
		While SRT->( !EoF() ) .And. SRT->RT_FILIAL+SRT->RT_MAT == (cAliasSRA)->RA_FILIAL+(cAliasSRA)->RA_MAT
			If SRT->RT_DATACAL >= dDataDe .And. SRT->RT_DATACAL <= dDataAte
				If SRT->( RecLock( "SRT", .F. ) )
					If !lRobo
						aAdd(aLogFile, STR0117 + SRT->RT_FILIAL + SRT->RT_MAT + " | " + STR0118 + dToC(SRT->RT_DATACAL) + " | " + STR0119 + SRT->RT_TIPPROV + " | " + STR0120 + SRT->RT_VERBA ) //'- Filial/Matrcula: '##'Data de clculo: '##"Tipo: "##"Verba: "
					EndIf
					SRT->( dbDelete() )
					SRT->( MsUnlock() )				
				EndIf
			EndIf			
			SRT->( dbSkip() )
		End
	EndIf

	If lGeraPMes
		If RHT->( dbSeek( (cAliasSRA)->RA_FILIAL+(cAliasSRA)->RA_MAT ) )
			While RHT->( !EoF() ) .And. RHT->RHT_FILIAL+RHT->RHT_MAT == (cAliasSRA)->RA_FILIAL+(cAliasSRA)->RA_MAT
				If RHT->RHT_DTCALC >= dDataDe .And. RHT->RHT_DTCALC <= dDataAte
					If RHT->( RecLock( "RHT", .F. ) )
						RHT->( dbDelete() )
						RHT->( MsUnlock() )				
					EndIf
				EndIf			
				RHT->( dbSkip() )
			End
		EndIf
	EndIf

	(cAliasSRA)->( dbSkip() )
End

(cAliasSRA)->( dbCloseArea() )

RestArea( aAreaRHT )
RestArea( aAreaSRT )
RestArea( aArea )

Return

/*/{Protheus.doc} fMsgExc
Mensagem de alerta sobre o grupo GPM070EXCL
@author Allyson Mesashi
@since 18/08/2021
/*/
Static Function fMsgExc()

Local oButton1
Local oCheckBo1
Local lCheckBo1 	:= .F.
Local oGroup1
Local oPanel1
Local oSay1
Local oSay2
Local lChkMsg 		:= .F.
Local oDlg
Local oProfile 		:= FWProfile():New()

Default lTemCampo 	:= .F.

oProfile:SetUser( RetCodUsr() )
oProfile:SetProgram( "GPEA070" )
oProfile:SetTask( "MSGEXC" )
oProfile:Load()

lChkMsg := (oProfile:GetStringProfile() == "")

If lChkMsg
	DEFINE MSDIALOG oDlg TITLE OemToAnsi(STR0114) FROM 000, 000  TO 200, 500 COLORS 0, 16777215 PIXEL //"Proviso"

		@ 000, 000 MSPANEL oPanel1 SIZE 300, 150 OF oDlg COLORS 0, 16777215 RAISED
		@ 005, 012 GROUP oGroup1 TO 055, 237 PROMPT OemToAnsi(STR0103) OF oPanel1 COLOR 0, 16777215 PIXEL //"Ateno"
		@ 017, 017 SAY oSay1 PROMPT OemToAnsi(STR0115 + CRLF + STR0107) SIZE 215, 035 OF oPanel1 COLORS 0, 16777215 PIXEL //"Ambiente sem atualizao de dicionrio para a excluso em lote do calculo"##"Verifique a documentao conforme orientaes no link abaixo"
		@ 063, 012 SAY oSay2 PROMPT "https://tdn.totvs.com/x/M3bOJQ" SIZE 095, 007 OF oPanel1 COLORS 0, 16777215 PIXEL
		@ 080, 012 CHECKBOX oCheckBo1 VAR lCheckBo1 PROMPT OEMToAnsi(STR0106) SIZE 067, 008 OF oPanel1 COLORS 0, 16777215 PIXEL //"No exibir novamente"
		@ 070, 200 BUTTON oButton1 PROMPT "OK" SIZE 037, 012 OF oPanel1 PIXEL

		oSay2:bLClicked := {|| ShellExecute("open", "https://tdn.totvs.com/x/M3bOJQ", "", "", 1) }

		oButton1:bLClicked := {|| oDlg:End() }

	ACTIVATE MSDIALOG oDlg CENTERED

	If lCheckBo1		
		oProfile:SetStringProfile("*")
		oProfile:Save()
	EndIf
EndIf

Return
