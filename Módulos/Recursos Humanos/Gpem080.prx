#INCLUDE "PROTHEUS.CH"
#INCLUDE "GPEM080.CH"
#include "fileio.ch"

Static lAutomato	:= IsBlind()

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funca‡…o    ³ GPEM080  ³ Autor ³ R.H. - Tatiane          ³ Data ³   13.05.05  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…cao ³ Geracao de Liquidos em disquete                                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³                                                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³         ATUALIZACOES SOFRIDAS DESDE A CONSTRU€CAO INICIAL.                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Programador ³ Data     ³CHAMADO/REQ³  Motivo da Alteracao                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Mohanad Odeh³01/04/2013³M12RH01    ³Unificacao dos Fontes V12                 ³±±
±±³            ³          ³RQ0310     ³                                          ³±±
±±|Will C.     ³30/09/2014³TQRTUJ     |Ajuste para respeitar controle de filiais ³±±
±±³            ³          ³           |e o controle de acesso do usuario.        ³±±
±±|L.Trombini  ³31/03/2015³TRYTRY     |Ajuste para acerto do arredondamento com  ³±±
±±³            ³          ³           |grandes valores que diminuia 0,01 centavo ³±±
±±³M. Silveira ³11/11/2015³TTSGNL     ³Ajuste para validar o tipo de conta para a³±±
±±³            ³          ³           |geracao do arquivo.                       ³±±
±±³Matheus M.  ³10/12/2015³TTUTLJ     ³Ajuste para alimentar o vetor aInfo com   ³±±
±±³            ³          ³           |o nome da empresa cNomeEmpr antes de usar ³±±
±±³            ³          ³           |a gravação do Header e Lote.              ³±±
±±³P. Pompeu...|21/06/2016|TVLNVO     |Adicionada opção de múltiplos lotes Mod2  ³±±
±±³Gabriel A.  ³21/07/2016³TVICH3     |Declaração da variável cSeq como private  ³±±
±±³            ³          ³           |para geração de CNAB e SISPAG.            ³±±
±±³Renan Borges³25/07/2016³TVPIFW     |Ajuste para corrigir error.log em oracle. ³±±
±±³Gabriel A.  ³26/07/2016³TVRLKW     |Ajuste para preencher as perguntas Agência³±±
±±³            ³          ³           |e Conta do pergunte GPEM080.              ³±±
±±³Cícero Alves³08/09/2016³TVXPEZ     |Ajuste para verificar se existe o novo    ³±±
±±³            ³          ³           |grupo de perguntas e para posicionar no   ³±±
±±³            ³          ³           |registro correto na S052					 ³±±
±±³Joâo Balbino³21/09/2016³	TWBWYG 	  |Ajuste para não gerar error log caso o não³±±
±±³            ³          ³           |exista o novo grupo de perguntes.         ³±±
±±³Cícero Alves³19/10/2016³TW3476	  |Ajuste para quando for informada apenas a ³±±
±±³            ³          ³           |situação normal não gerar erro na query	 ³±±
±±³Daniel Mendes³21/10/2016³TWIOQV	  |Ajustes para levar as informações do banco³±±
±±³gsantacruz  ³27/11/2015³pcreq-7944 ³Al arreglo  aValBenef se elimino el campo ³±±
±±³            ³          ³           |RA_TPCTSAL que solo aplioca para Brasil   ³±±
±±³            ³          ³           |para los demas paises no.                 ³±±
±±³Jonathan Glz³18/01/2016³PCREQ-7944 ³Localizacion GPE CHI v12.                 ³±±
±±³            ³          ³           ³-Modifcaciones a diccionario.(Preguntas ) ³±±
±±³            ³          ³           ³-Se cambia el emcabezado  del log y titulo³±±
±±³            ³          ³           ³se pone "Liquido a pagar".                ³±±
±±³            ³          ³           ³-Se agrega variable CTPOARCE que sera     ³±±
±±³            ³          ³           ³ usada en el layout CNAB 1 y 2            ³±±
±±³Cícero Alves³21/06/2017³DRHPAG-2252³Implementação do botão cancelar			 ³±±
±±³Paulo O.    ³05/06/2017³DRHPAG-2260³Efetuado ajuste para ordenar funcionarios ³±±
±±³Inzonha     ³          ³           ³por matricula alem de banco e tipo conta  ³±±
±±³Isabel N.   ³16/08/2017³DRHPAG-4475³Ajuste na ordem do aValBenef p/considerar ³±±
±±³            ³          ³           ³banco E agência, alteração no log p/exibir³±±
±±³            ³          ³           ³Filial+RA_BCDEPSA+Matricula+Nome+valor.   ³±±
±±³Eduardo K.  ³23/10/2017³MPRIMESP   ³Ajuste p/ verificar dados do beneficiário ³±±
±±³            ³          ³-11706     ³quando a pergunta 'processa banco'        ³±±
±±³            ³          ³           ³estiver em branco.					     ³±±
±±³Oswaldo L   ³01/12/17  ³DRHPAG-8855³Acerto para permitir selecionar bancos da ³±±
±±³            ³          ³           ³filial conectada                          ³±±
±±³WinstonCosta³01/11/2018³           ³Preparando o fonte para execução via Robô ³±±
±±³            ³          ³           ³(automacao-ADVPR)                         ³±±
±±³Oscar G.    ³05/03/2019³DMINA-6197 ³Se realiza bifurcación para consulta a    ³±±
±±³            ³          ³           ³tabla S052 para uso exclusivo de Brasil en³±±
±±³            ³          ³           ³funcion GetBankInf(). (COL)               ³±±
±±³Diego Rivera³05/08/2019³DMINA-7113 ³Replica de DMINA-6876. Se agrega función  ³±±
±±³            ³          ³           ³fAtuTot para actualizar total de empleados³±±
±±³            ³          ³           ³en el encabezado una vez que se han proce-³±±
±±³            ³          ³           ³sado todos los registros.                 ³±±
±±³Eduardo P.  ³20/11/2019³DMINA-7393 ³Replica de DMINA-7334. Se modifica función³±±
±±³            ³          ³           ³fAtuTot para actualizar total de empleados³±±
±±³            ³          ³           ³en 1 o mas encabezados una vez que se han ³±±
±±³            ³          ³           ³procesado todos los registros.            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function GPEM080(lAuto)
	Local aOfusca		:= If(FindFunction('ChkOfusca'), ChkOfusca(), { .T., .F. }) //[1]Acesso; [2]Ofusca; [3]Mensagem
	Local aFldRel		:= {"RA_NOME","RA_NOMECMP","RA_CIC","RQ_NOME","A6_AGENCIA","A6_NUMCON"}
	Local lBlqAcesso	:= aOfusca[2] .And. !Empty( FwProtectedDataUtil():UsrNoAccessFieldsInList( aFldRel ) )
	Local oSX1

	Private cCadastro 	:= OemToAnsi(STR0001) //"Geracao de liquido em disquete (CNAB/SISPAG)"
	Private nSavRec  	:= RECNO()
	Private cProcessos	:= ""
	Private aTotNeto    := Array(0) //Valores de nTotal y nTotFunc
	Private cPerg		:= ""
	Private lUsaSeqS52	:= .F.

	Default lAuto 		:= .F.

	If lBlqAcesso	//Tratamento de acesso a dados pessoais
		Help(" ",1,aOfusca[3,1],,aOfusca[3,2],1,0)	//"Dados Protegidos- Acesso Restrito: Este usuário não possui permissão de acesso aos dados dessa rotina. Saiba mais em {link documentação centralizadora}"
		Return
	EndIf

	//FUNCAO VERIFICA SE EXISTE ALGUMA RESTRICAO DE ACESSO PARA O USUARIO QUE IMPECA A EXECUCAO DA ROTINA
	If !(fValidFun({"SRQ","SRC"}))
		Return( nil )
	Endif

	oSX1 := FWSX1Util():New()
	oSX1:AddGroup("GPEM080R2")
	oSX1:SearchGroup()

	If (Len(oSX1:aGrupo) >= 1 .And. Len(oSX1:aGrupo[1][2]) >= 1) .And. cPaisLoc $ "BRA|RUS"
		cPerg := "GPEM080R2"
	Else
		cPerg := "GPEM080R1"
	EndIf

	FreeObj(oSX1)

	Pergunte(cPerg, .F.)

	cDescricao := OemToAnsi(STR0002) + CRLF + OemToAnsi(STR0003) + CRLF + OemToAnsi(STR0004)
	//" ESTE PROGRAMA TEM O OBJETIVO DE GERAR O ARQUIVO DE LIQUIDO EM DISCO."
	//" ANTES DE RODAR ESTE PROGRAMA‚ NECESSARIO CADASTRAR O LAYOUT DO "
	//" ARQUIVO. MODULO SIGACFG OPCAO CNAB A RECEBER OU SISPAG. "
	bProcesso := {|oSelf| GPM080Processa(oSelf, lAuto)}

	If !lAuto
		If lAutomato
			eVal(bProcesso,Nil)
		Else
			tNewProcess():New( "GPEM080", cCadastro, bProcesso, cDescricao, cPerg, , .F., 20, cDescricao, .F., .T.)
		Endif
	Else
		GPM080Processa(oSelf, lAuto)
	EndIf

Return

/*
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Funca‡…o    ³Gpm080processa³ Autor ³ Equipe de RH      ³ Data ³13/05/2005³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Processamento da geracao do arquivo                         ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³Gpm080processa()                                            ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³                                                            ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Uso      ³ Gpem080                                                    ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
Static Function Gpm080processa(oSelf, lAuto)
	Local aCodFol		:={}
	Local lHeader		:= .F.
	Local lFirst		:= .F.
	Local lGrava		:= .F.
	Local lGp410Des 	:= ExistBlock("GP410DES")
	Local lGp450Des 	:= ExistBlock("GP450DES")
	Local lGp450Val 	:= ExistBlock("GP450VAL")
	Local lGp080Usr 	:= ExistBlock("GP080USR")
	Local lGp080Us1 	:= ExistBlock("GP080US1")
	Local nCntP
	Local aStruSRA
	Local cAliasSRA		:= "SRA" 	//ALIAS DA QUERY
	Local cLocaBco 		:= cLocaPro := ""
	Local X				:= 0
	Local lAllProc		:= .F.
	Local nTamCod		:= 0
	Local lCpyS2T		:= .F.
	Local lValidFil		:= .T.
	Local nTamFil		:= FWSIZEFILIAL()
	Local cNumPag		:= ""
	Local lUtilizaMI	:= cPaisLoc $ "PER|MEX|COL|EQU"
	//VARIAVEIS PARA CRIACAO DE LOG
	Local cLog			:= 	""
	Local aLog			:= {}
	Local aTitle		:= {}
	Local nTotRegs		:= 0
	Local nRegsGrav		:= 0
	Local nTotVal		:= 0
	Local cData			:= ""
	Local cHora			:= ""

	//ARQUIVO MESES ANTERIORES
	Local cQuebra	:= CHR(13)+CHR(10)
	Local nX		:=0
	Local cTpConta	:=''
	Local nPos		:=0
	Local aFunBenef := {}
	Local lMod2Ambos:= .F.
	Local cBcoValB	:= ""
	Local cCtaValB	:= ""
	Local cSitQuery := ""
	Local cCatQuery := ""
	Local cProcQuery:= ""
	Local cNomArq	:= ""
	Local cNomDir	:= ""
	Local cDeptoDe	:=	Space(TamSx3("RA_DEPTO")[1])
	Local cDeptoAte	:=	Replicate("Z",TamSx3("RA_DEPTO")[1])
	Local FilAnt 	:= Replicate("!", nTamFil)
	Local cFilIni	:= cFilAnt
	Local cFilSRV   := ""
	Local cFilAux   := ""
	Local nContador := 0
	Local uRet      := Nil
	Local lRangeX1  := .F.
	Local cArqEntBkp	:= ""
	Local lCpyBkp		:= .F.

	Private cStartPath := GetSrvProfString("StartPath","")
	Private cLote	:= Nil
	Private cNome,cBanco,cConta,cCPF
	Private aValBenef 	:= {}
	Private aRoteiros	:= {}

	// VARIAVEIS DE ACESSO DO USUARIO
	Private cAcessaSR1	:= &( " { || " + ChkRH( "GPER080" , "SR1" , "2" ) + " } " )
	Private cAcessaSRA	:= &( " { || " + ChkRH( "GPER080" , "SRA" , "2" ) + " } " )
	Private cAcessaSRC	:= &( " { || " + ChkRH( "GPER080" , "SRC" , "2" ) + " } " )
	Private cAcessaSRD	:= &( " { || " + ChkRH( "GPER080" , "SRD" , "2" ) + " } " )
	Private cAcessaSRG	:= &( " { || " + ChkRH( "GPER080" , "SRG" , "2" ) + " } " )
	Private cAcessaSRH	:= &( " { || " + ChkRH( "GPER080" , "SRH" , "2" ) + " } " )
	Private cAcessaSRR	:= &( " { || " + ChkRH( "GPER080" , "SRR" , "2" ) + " } " )

	// DEFINE VARIAVEIS PRIVADAS BASICAS
	Private aABD := { STR0007,STR0007,STR0006 } //"Drive A"###"Drive B"###"Abandona"
	Private aTA  := { STR0005,STR0006 } //"Tenta Novamente"###"Abandona"

	// DEFINE VARIAVEIS PRIVADAS DO PROGRAMA
	Private nEspaco := nDisco := nGravados := 0
	Private cDrive := " "
	Private nArq, cTipInsc
	// VARIAVEIS USADAS NO ARQUIVO DE CADASTRAMENTO
	Private nSeq		:= 0
	Private nValor		:= 0
	Private nTotal		:= 0
	Private nTotFunc	:= 0
	// VARIAVEIS DISPONIBILIZADAS PARA GERACAO DO ARQUIVO - MOD.2
	Private CIC_ARQ		:= "" //CPF
	Private NOME_ARQ		:= "" //Nome Completo
	Private PRINOME_ARQ	:= "" //Primeiro Nome
	Private SECNOME_ARQ	:= "" //Segundo Nome
	Private PRISOBR_ARQ	:= "" //Primeiro Sobrenome
	Private SECSOBR_ARQ	:= "" //Segundo Sobrenome
	Private BANCO_ARQ	:= "" //Banco
	Private CONTA_ARQ	:= "" //Conta
	Private lRegFun		:= .F.
	Private nHdlBco		:=0,nHdlSaida:=0
	Private xConteudo

	// BLOCO DE VARIAVEIS PARA CONTROLE DOS DADOS BANCARIOS DA EMPRESA
	Private lUsaBanco  := .F.
	Private lGeraDOC   := .F.
	Private lDocCC	   := .F.
	Private lDocPoup   := .F.
	Private cCodBanco  := ""
	Private cCodAgenc  := ""
	Private cDigAgenc  := ""
	Private cCodConta  := ""
	Private cSeqS052   := ""
	Private cDigConta  := ""
	Private cCodConve  := ""
	Private cCodFilial := ""
	Private cCodCnpj   := ""
	Private cNomeEmpr  := ""
	Private lCCorrent  := .T.
	Private aInfo      := {}
	Private nTipoConta := 0
	Private CTPOARCE   := "" // Tipo Archivo Enviado
	Private nLoteSeq		:= 1 /*Variável guarda a sequência atual do Lote*/
	Private nLoteTotal	:= 0 /*--------------- o valor total do Lote atual*/
	Private nLoteQtd	:= 0 /*--------------- a quantidade de funcionários do Lote Atual*/
	Private nQtdLinLote	:= 0 /*--------------- a quantidade de linhas do Lote Atual*/
	Private cSeq		:= ""
	Private nTotLin		:= 0
	Private lQbCta		:= .T.
	Private nDecTotal	:= 0

	Default lAuto		:= .F.

	lRangeX1 := ( cPerg == "GPEM080R2" )

	//PONTO DE ENTRADA PARA VALIDAÇÕES DO CAMINHO DE SAÍDA
	If lGp080Usr
		uRet := ExecBlock("GP080USR",.F.,.F.,{If(!lRangeX1,mv_par19,mv_par13)})
		If ValType(uRet) == "L" .AND. !uRet
			Return
		ElseIf ValType(uRet) == "C" .AND. !Empty(uRet)
			If !lRangeX1
				mv_par19 := uRet
			Else
				mv_par13 := uRet
			EndIf
		EndIf
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ VARIAVEIS UTILIZADAS PARA PARAMETROS (GPEM080R1)                    ³
	//³ mv_par01        //  Roteiros                                        ³
	//³ mv_par02        //  Roteiros                                        ³
	//³ mv_par03        //  Roteiros                                        ³
	//³ mv_par04        //  Filial  De                                      ³
	//³ mv_par05        //  Filial  Ate                                     ³
	//³ mv_par06        //  Centro de Custo De                              ³
	//³ mv_par07        //  Centro de Custo Ate                             ³
	//³ mv_par08        //  Banco /Agencia De                               ³
	//³ mv_par09        //  Banco /Agencia Ate                              ³
	//³ mv_par10        //  Matricula De                                    ³
	//³ mv_par11        //  Matricula Ate                                   ³
	//³ mv_par12        //  Nome De                                         ³
	//³ mv_par13        //  Nome Ate                                        ³
	//³ mv_par14        //  Conta Corrente De                               ³
	//³ mv_par15        //  Conta Corrente Ate                              ³
	//³ mv_par16        //  Situacao                                        ³
	//³ mv_par17        //  Layout                                          ³
	//³ mv_par18        //  Arquivo de configuracao                         ³
	//³ mv_par19        //  nome do arquivo de saida                        ³
	//³ mv_par20        //  data de credito                                 ³
	//³ mv_par21        //  Data de Pagamento De                            ³
	//³ mv_par22        //  Data de Pagamento Ate                           ³
	//³ mv_par23        //  Categorias                                      ³
	//³ mv_par24        //  Imprimir 1-Funcionarios 2-Beneficiarias 3-Ambos ³
	//³ mv_par25        //  Data de Referencia                              ³
	//³ mv_par26        //  Selecao de Processos                            ³
	//³ mv_par27        //  Selecao de Processos                            ³
	//³ mv_par28        //  Selecao de Processos                            ³
	//³ mv_par29        //  Linha Vazia no Fim do Arquivo                   ³
	//³ mv_par30        //  Processar Banco                                 ³
	//³ mv_par31        //  Agência				                            ³
	//³ mv_par32        //  Conta				                            ³
	//³ mv_par33        //  Gerar Conta Tipo                                ³
	//³ mv_par34        //  DOC Outros Bancos                               ³
	//³ mv_par35		//  Numero Pagamento                                ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If !lRangeX1
		cFilDe		:= mv_par04
		cFilAte		:= mv_par05
		cCcDe     	:= mv_par06
		cCcate    	:= mv_par07
		cBcoDe		:= mv_par08
		cBcoAte		:= mv_par09
		cMatDe    	:= mv_par10
		cMatAte		:= mv_par11
		cNomDe		:= mv_par12
		cNomAte		:= mv_par13
		cCtaDe		:= mv_par14
		cCtaAte		:= mv_par15
		cSituacao 	:= mv_par16
		nModelo		:= mv_par17
		cArqent		:= mv_par18
		cArqSaida	:= mv_par19
		dDataPgto	:= mv_par20
		dDataDe		:= mv_par21
		dDataAte	:= mv_par22
		cCategoria	:= mv_par23
		nFunBenAmb	:= mv_par24  // 1-FUNCIONARIOS  2-BENEFICIARIAS  3-AMBOS
		dDataRef	:= IIf(Empty(mv_par25), dDataBase,mv_par25)
		lLnVazia	:= mv_par29 == 1

		If !cPaisLoc $ "MEX|PAR"
			cCodBanco	:= mv_par30
			cCodAgenc	:= mv_par31
			cCodConta	:= mv_par32

			If cPaisLoc $ "CHI|COL|PER"
				nTipoConta	:= mv_par34
				lGeraDOC  	:= mv_par35 == 1
			Else
				nTipoConta	:= mv_par33
				lGeraDOC  	:= mv_par34 == 1
				If (cPaisLoc == "BRA")
					cNumPag	:= mv_par35
				Else
					cNumPag	:= StrZero(mv_par35, TamSX3("RC_SEMANA")[1])
				Endif
			EndIf
			lUsaBanco 	:= !Empty(cCodBanco)
			CTPOARCE 	:= IIF(cPaisLoc == "CHI" , mv_par33 , "" ) //Tipo Archivo Enviado
		EndIf
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ VARIAVEIS UTILIZADAS PARA PARAMETROS (GPEM080R2)                    ³
		//³ mv_par01        //  Roteiros                                        ³
		//³ mv_par02        //  Roteiros                                        ³
		//³ mv_par03        //  Roteiros                                        ³
		//³ mv_par04        //  Filial                                          ³
		//³ mv_par05        //  Centro de Custo                                 ³
		//³ mv_par06        //  Banco /Agencia                                  ³
		//³ mv_par07        //  Matricula                                       ³
		//³ mv_par08        //  Nome                                            ³
		//³ mv_par09        //  Conta Corrente                                  ³
		//³ mv_par10        //  Situacao                                        ³
		//³ mv_par11        //  Layout                                          ³
		//³ mv_par12        //  Arquivo de configuracao                         ³
		//³ mv_par13        //  nome do arquivo de saida                        ³
		//³ mv_par14        //  data de credito                                 ³
		//³ mv_par15        //  Data de Pagamento De                            ³
		//³ mv_par16        //  Data de Pagamento Ate                           ³
		//³ mv_par17        //  Categorias                                      ³
		//³ mv_par18        //  Imprimir 1-Funcionarios 2-Beneficiarias 3-Ambos ³
		//³ mv_par19        //  Data de Referencia                              ³
		//³ mv_par20        //  Selecao de Processos                            ³
		//³ mv_par21        //  Selecao de Processos                            ³
		//³ mv_par22        //  Selecao de Processos                            ³
		//³ mv_par23        //  Linha Vazia no Fim do Arquivo                   ³
		//³ mv_par24        //  Processar Banco                                 ³
		//³ mv_par25        //  Agência				                            ³
		//³ mv_par26        //  Conta				                            ³
		//³ mv_par27        //  Gerar Conta Tipo                                ³
		//³ mv_par28        //  DOC Outros Bancos                               ³
		//³ mv_par29		//  Numero Pagamento                                ³
		//³ mv_par30        //  Departamento De                                 ³
		//³ mv_par31		//  Departamento Ate                                ³
		//³ mv_par32		//  Seq. Conv. S052 ?                               ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	Else
		MakeSqlExpr( cPerg ) //Transforma perguntas do tipo Range em expressao SQL
		cSituacao 	:= mv_par10
		nModelo		:= mv_par11
		cArqent		:= mv_par12
		cArqSaida	:= mv_par13
		dDataPgto	:= mv_par14
		dDataDe		:= mv_par15
		dDataAte	:= mv_par16
		cCategoria	:= mv_par17
		nFunBenAmb	:= mv_par18  // 1-FUNCIONARIOS  2-BENEFICIARIAS  3-AMBOS
		dDataRef	:= IIf(Empty(mv_par19),dDataBase,mv_par19)//25
		cDeptoDe	:=	IIf(Empty(mv_par30), cDeptoDe, mv_par30)
		cDeptoAte	:=	IIf(Empty(mv_par31), cDeptoAte, mv_par31)

		lLnVazia	:= mv_par23 == 1

		If !cPaisLoc $ "MEX|PAR"
			cCodBanco	:= mv_par24
			cCodAgenc	:= mv_par25
			cCodConta	:= mv_par26
			cSeqS052	:= mv_par32

			If cPaisLoc $ "CHI|COL|PER"
				nTipoConta	:= mv_par28
				lGeraDOC  	:= mv_par29 == 1
			Else
				nTipoConta	:= mv_par27
				lGeraDOC  	:= mv_par28 == 1
				If (cPaisLoc == "BRA")
					cNumPag	:= mv_par29
				Else
					cNumPag	:= StrZero(mv_par29, TamSX3("RC_SEMANA")[1])
				Endif
			EndIf
			lUsaBanco 	:= !Empty(cCodBanco)
			CTPOARCE 	:= IIF(cPaisLoc == "CHI" , mv_par27 , "" ) //Tipo Archivo Enviado
		EndIf
	EndIf

	lMod2Ambos	:= (nModelo == 2 .And. nTipoConta == 3)
	lCCorrent 	:= (nTipoConta == 1) .Or. (lMod2Ambos)

	/*Determina os tipos de contas permitidos*/
	Do Case
		Case (nTipoConta == 1)
			cTpConta := " *1"
		Case (nTipoConta == 3)
			cTpConta := " *1*2"
		OtherWise
			cTpConta := "2"
	EndCase

	// AGRUPA OS PROCESSOS SELECIONADOS
	If !lRangeX1
		If !(Empty(MV_PAR26 + MV_PAR27 + MV_PAR28)) //Processos para Impressao
			cProcessos:= CodProces(AllTrim(MV_PAR26)) + CodProces(AllTrim(MV_PAR27)) + CodProces(AllTrim(MV_PAR28))
		EndIf
	Else
		If !(Empty(MV_PAR20 + MV_PAR21 + MV_PAR22)) //Processos para Impressao
			cProcessos:= CodProces(AllTrim(MV_PAR20)) + CodProces(AllTrim(MV_PAR21)) + CodProces(AllTrim(MV_PAR22))
		EndIf
	EndIf

	If Empty(cProcessos)
		Help(" ",1,"GPEM80PROC") //P: Nenhum processo foi selecionado. ### S: Selecione ao menos um processo.
		Return()
	EndIf

	If(lMod2Ambos .And. !lUsaBanco)
		/*Para gerar o arquivo para ambos os tipos de contas é necessário informar o código do banco da empresa.*/
		Help(,,OemToAnsi(STR0021),, OemToAnsi(STR0036),1,0 )
		Return()
	EndIf

	//DEFINE SE DEVERA SER IMPRESSO FUNCIONARIOS OU BENEFICIARIOS
	lImprFunci  := ( nFunBenAmb # 2 )
	lImprBenef  := ( nFunBenAmb # 1 )

	SA6->(dbSetOrder(1))

	/*Trata o nome do arquivo*/
	SetArqNome(@cArqSaida, @lCpyS2T,@cNomArq,@cNomDir)

	if(lUsaBanco)
		/*É necessário obter as informações sobre o banco antes,
		dessa forma o cliente pode usar os dados no cabeçalho.*/
		GetBankInf( .F., cFilAnt )
	endIf

	/*Valida a existência do arquivo.*/
	If	!(FILE(cArqEnt))
		Help(" ",1,"NOARQPAR")
		Return
	Endif

	// MODIFICA VARIAVEIS PARA A QUERY
	cSitQuery	:= fSqlIn(StrTran(cSituacao,'*'),1)
	cCatQuery	:= fSqlIn(StrTran(cCategoria,'*'),1)
	lAllProc	:= AllTrim( cProcessos ) == "*"

	If Empty(cSitQuery)
		aAdd( aLog, { OemToAnsi(STR0037) } ) //-- "Não foi informada nenhuma Situação nos parâmetros."
		cSitQuery := "''"
	EndIF

	If Empty(cCatQuery)
		aAdd( aLog, { OemToAnsi(STR0038) } ) //-- "Não foi informada nenhuma Categoria nos parâmetros."
		cCatQuery := "''"
	EndIF

	If !lAllProc
		nTamCod := GetSx3Cache("RCJ_CODIGO", "X3_TAMANHO")
		cProcQuery := fSqlIn(cProcessos,nTamCod)
	EndIf

	cQuery := "SELECT R_E_C_N_O_ AS CHAVE, " + RetSqlName("SRA") + ".* "
	cQuery += "  FROM " + RetSqlName("SRA") + " WHERE "
	cQuery += "   RA_CATFUNC IN (" + Upper(cCatQuery) + ")"
	cQuery += "   AND RA_SITFOLH IN (" + Upper(cSitQuery) + ")"

	If !lRangeX1
		cQuery += "   AND RA_FILIAL BETWEEN '" + cFilDe + "' AND '" + cFilAte + "'"
		cQuery += "   AND RA_MAT BETWEEN '" + cMatDe + "' AND '" + cMatAte + "'"
		cQuery += "   AND RA_NOME BETWEEN '" + cNomDe + "' AND '" + cNomAte + "'"
		cQuery += "   AND RA_CC BETWEEN '" + cCcDe  + "' AND '" + cCcate  + "'"
	Else
		If !Empty(MV_PAR04) //Filial
			cQuery += " AND " + MV_PAR04
		EndIf

		If !Empty(MV_PAR05) //Centro de Custo
			cQuery += " AND " + MV_PAR05
		EndIf

		If !Empty(MV_PAR07) //Matrícula
			cQuery += " AND " + MV_PAR07
		EndIf

		If !Empty(MV_PAR08) //Nome
			cQuery += " AND " + MV_PAR08
		EndIf

		cQuery += "   AND RA_DEPTO BETWEEN '" + cDeptoDe  + "' AND '" + cDeptoAte  + "'"

		// Variáveis serão usadas na função fChkBenef
		If (nFunBenAmb == 2 .Or. nFunBenAmb == 3) 
			// MV_PAR06 Expressão SQL - RA_BCDEPSA in ('')
			// MV_PAR09 Expressão SQL - RA_CTDEPSA in ('')			
			cBcoValB	:= StrTran( MV_PAR06, "RA_BCDEPSA", "RQ_BCDEPBE" )
			cCtaValB	:= StrTran( MV_PAR09, "RA_CTDEPSA", "RQ_CTDEPBE" )
		EndIf
	EndIf

	If !lAllProc
		cQuery += "AND RA_PROCES IN("+ Upper(cProcQuery)+ ")"
	EndIf
	cQuery += "   AND D_E_L_E_T_ = ' '"
	cQuery	+= " ORDER BY RA_FILIAL, RA_MAT"

	aStruSRA := SRA->(dbStruct())
	SRA->( dbCloseArea() )
	dbUseArea(.T., "TOPCONN", TCGenQry(,,cQuery), 'SRA', .F., .T.)

	DbSelectArea("SRA")
	Count To nTotalQ /*Conta a quantidade de registros retornados pela consulta.*/
	SRA->(DbGoTop()) /*Retorna ao primeiro registro.*/

	IF !lAutomato
		oSelf:SetRegua1(Int(nTotalQ/100)) // Total de Elementos da regua
	Endif

	For nX := 1 To Len(aStruSRA)
		If ( aStruSRA[nX][2] <> "C" )
			TcSetField(cAliasSRA,aStruSRA[nX][1],aStruSRA[nX][2],aStruSRA[nX][3],aStruSRA[nX][4])
		EndIf
	Next nX

	nContador := 0

	While (cAliasSRA)->(!Eof())
		// MOVIMENTA CURSOR
		IF !lAutomato
			nContador++

			If (nContador == 100)
				nContador := 0
				oSelf:IncRegua1(IIF(cPaisLoc == "CHI", STR0035, STR0012) + "[" + SRA->(RA_FILIAL + '/' + RA_MAT) + "]")
			Endif

			If oSelf:lEnd
				Exit
			EndIf
		Endif

		nValor		:= 0
		aFunBenef	:= {}

		If SRA->RA_FILIAL # FilAnt .And. ( cFilAux := xFilial("SRV",SRA->RA_FILIAL) ) <> cFilSRV
			If !Fp_CodFol(@aCodFol,SRA->RA_FILIAL)
				Exit
			Endif
			// Verifica Existencia da Tabela S052 - Bancos para CNAB
			If lUsaBanco
				GetBankInf()
			EndIf
			FilAnt 	:= SRA->RA_FILIAL
			cFilSRV := cFilAux
			cFilAnt := SRA->RA_FILIAL
			lValidFil	:= .T.

			// CARREGANDO ARRAY AROTEIROS COM OS ROTEIROS SELECIONADOS
			If Len(MV_PAR01 + MV_PAR02 + MV_PAR03) > 0
				aRoteiros := {}
				SelecRoteiros()
			EndIf

			// CONSISTE FILIAIS E ACESSOS
			If !( SRA->RA_FILIAL $ fValidFil() ) .or. !Eval( cAcessaSRA )
				SRA->(dbSkip())
				lValidFil := .F.
				Loop
			EndIf
		EndIf

		// CONSISTE FILIAIS E ACESSOS
		If !lValidFil
			SRA->(dbSkip())
			Loop
		EndIf

		// BUSCA OS VALORES DE LIQUIDO E BENEFICIOS
		If !Empty(cNumPag)
			Gp020BuscaLiq(@nValor,@aFunBenef,,cNumPag)
		Else
			Gp020BuscaLiq(@nValor,@aFunBenef)
		Endif

		For nX:=1 To Len(aFunBenef)		//Adicionando mais uma coluna no array para testes
			aAdd(aFunBenef[nX], .T.)	//Se imprime Beneficiario (Analisando pergunta [Doc outros bancos])
		End

		// CONSISTE PARAMETROS DE BANCO E CONTA DO FUNCIONARIO
		If !lRangeX1
			If (SRA->RA_BCDEPSA < cBcoDe) .Or. (SRA->RA_BCDEPSA > cBcoAte) .Or. (SRA->RA_CTDEPSA < cCtaDe) .Or. (SRA->RA_CTDEPSA > cCtaAte)
				nValor := 0
			EndIf
		Else
			// MV_PAR06 Expressão SQL - RA_BCDEPSA in ('')
			// MV_PAR09 Expressão SQL - RA_CTDEPSA in ('')
			If !(fChkFunc(SRA->(R_E_C_N_O_) , MV_PAR06, MV_PAR09))
				nValor := 0
			EndIf
		EndIf

		// FILTRA GERACAO DE DOC'S
		If lUsaBanco
			lDocCc   := Left( SRA->RA_BCDEPSA,3 ) <> cCodBanco .And. lCCorrent
			lDocPoup := Left( SRA->RA_BCDEPSA,3 ) <> cCodBanco .And. !lCCorrent
			If !lGeraDoc .And. ( lDocCc .Or. lDocPoup )
			nValor := 0
			EndIf

			If lImprBenef
				For nX:=1 To Len(aFunBenef)
					lDoCc   := Left( aFunBenef[nX,2],3 ) <> cCodBanco .And. lCCorrent
					lDoPoup := Left( aFunBenef[nX,2],3 ) <> cCodBanco .And. !lCCorrent
					If !lGeraDoc .And. ( lDoCc .Or. lDoPoup )
					aFunBenef[nX,12] := .F.
					EndIf
				End
			Endif
		EndIf

		/*Se deve gerar funcionários e valor maior que zero, adiciona o funcionário no vetor.*/
		If lImprFunci .And. nValor > 0
			aAdd(aFunBenef, {IIF(Empty(SRA->RA_NOMECMP),SRA->RA_NOME,SRA->RA_NOMECMP),;
			SRA->RA_BCDEPSA, SRA->RA_CTDEPSA, "", nValor, SRA->RA_CIC, SRA->CHAVE, "SRA", IIf(cPaisLoc == "BRA",SRA->RA_TPCTSAL, "") , "" , "" , .T.})
		EndIf

		// CONSISTE PARAMETROS DE BANCO E CONTA DO BENEFICIARIO
		// AFUNBENEF: 1-NOME  2-BANCO  3-CONTA  4-VERBA  5-VALOR  6-CPF 9-TIPO DE CONTA 12-IMPRIME DOC (T/F)
		If lUsaBanco
			If Len(aFunBenef) > 0
				/*Exclui do vetor possíveis beneficiários que não respeitem ao filtro ou funcionários que tem o tipo de conta não pertinente.*/

				while( ( nPos := aScan(aFunBenef,{|x| (X[12] <> .T.) .Or. ( !lRangeX1 .and. ( (X[2] < cBcoDe .Or. X[2] > cBcoAte) .Or. (X[3] < cCtaDe .Or. X[3] > cCtaAte) ) ) .Or. (!(X[9] $ cTpConta) .And. (cPaisLoc == "BRA"))})) > 0 )
				aDel(aFunBenef,nPos)
				aSize(aFunBenef,Len(aFunBenef)-1)
				EndDo
			Else
				SRA->(dbSkip())
				Loop
			EndIf
		EndIf


		// Ponto de Entrada para desprezar somente o funcionario,somente o beneficiario ou ambos, utilizando o array aValBenef.
		// CNAB Modelos 1 e 2
		If lGp410Des
			If !(ExecBlock("GP410DES",.F.,.F.))
				SRA->(dbSkip(1))
				Loop
			EndIf
		EndIf
		// SISPAG
		If lGp450Des
			If !(ExecBlock("GP450DES",.F.,.F.))
				SRA->(dbSkip(1))
				Loop
			EndIf
		EndIf

		for nCntP:= 1 to Len(aFunBenef)
			/*Registros cujo campo TPCONTA estiverem vazios são considerados Conta Corrente.*/
			if(Empty(aFunBenef[nCntP,9]))
				aFunBenef[nCntP,9] := '1'
			endIf
			aAdd(aFunBenef[nCntP],IIF((Left(aFunBenef[nCntP,2],3) == cCodBanco),cCodBanco,"DOC"))
		next nCntP

		/*Adiciona ao vetor aFunBenef os registros que forem do próprio banco,
		os que não forem(ou seja, sejam DOC), só são adicionados se lGeraDoc for .T. e for
		utilizar um layout com múltiplos lotes*/
		aEval(aFunBenef,{|x|IIF((lMod2Ambos .And. !lGeraDOC .And. Left(x[2],3) != cCodBanco) .Or. x[5] <= 0,/*Não faz nada*/,aAdd(aValBenef,x))})
		aSize(aFunBenef,0)

		nTotVal += nValor
		SRA->( dbSkip( ) )
	Enddo

	If lGp080Us1
		uRet := ExecBlock("GP080US1",.F.,.F.,{nTotVal})
		If ValType(uRet) == "L" .AND. !uRet
			Return
		EndIf
	EndIf

	cFilAnt := cFilIni

	/*Como a tabela está filtrada, fecho a tabela.*/
	SRA->(dbCloseArea())
	ChkFile("SRA")
	dbSelectArea("SRA")/*O dbSelectArea reabre a tabela 'normal'*/
	SRA->(dbSetOrder(1))

	if(nModelo == 2 .And. Len(aValBenef) > 0)
		/*Ordena por forma de pagamento, utilizando o Banco + Agencia + TpContaSal + Matricula*/
		aSort(aValBenef,,,{|x,y|x[13] + x[9] + x[2] + STRZERO(x[7],GetSx3Cache("RA_MAT","X3_TAMANHO")) < y[13] + y[9] + y[2] + STRZERO(y[7],GetSx3Cache("RA_MAT","X3_TAMANHO"))})
		/*cLote é sempre: cCodBanco+TpContaSal OU 'DOC'+TpContaSal, sendo 'DOC' usado
		para qualquer outro banco diferente de cCodBanco.*/
		cLote := aValBenef[1,13] + aValBenef[1,9]
		/*Por padrão, ao chamar o HeadCnab2(pela função AbrePar), ela já monta o cabeçalho
		do primeiro lote.*/

	endIf

	If !lAutomato
		If !oSelf:lEnd
			// Após concluída a consulta, cria o arquivo de saída.
			AbrePar(@cArqSaida,@cArqEnt,@cArqEntBkp, @lCpyBkp)
		Else
			Aviso(OemToAnsi(STR0039),OemToAnsi(STR0040), {OemToAnsi(STR0041)})
			Return
		EndIf
	Else
		// Após concluída a consulta, cria o arquivo de saída.
		AbrePar(@cArqSaida,@cArqEnt,@cArqEntBkp, @lCpyBkp)
	Endif

	If nModelo == 3 //SISPAG
		// ANALISA O TIPO DE BORDERO E DEFINE QUAIS HEADERS,TRAILLERS
		// E DETALHES DE LOTE QUE SER„O UTILIZADOS.
		//IDENTIFICADORES
		// A - HEADER ARQUIVO
		// B - HEADER  LOTE 1   HEADER LOTE CHEQUE/OP/DOC/CRED.CC
		// D - TRAILER LOTE 1   TRAILLER LOTE CHEQUE/OP/DOC/CRED.CC
		// F - TRAILER ARQUIVO
		// G - SEGMENTO A       CHEQUE/OP/DOC/CRED.CC
		// H - SEGMENTO B       INFORMACOES COMPLEMNTARES
		cHeadArq  := "A"
		cTraiArq  := "F"
		cHeadLote := "B"
		cTraiLote := "D"
		cDetaG    := "G"
		cDetaH    := "H"
		// GRAVA OS HEADERS DE ARQUIVO DE LOTE
		// OBSERVACAO: SERA' UM ARQUIVO PARA CADA BORDERO.
		GPM080Empresa( xFilial("SRA"), @cCodCnpj, @cNomeEmpr )
		lRet := fm080Linha(cHeadArq)

		If lRet
			fm080Linha(cHeadLote)
		Else
			Return()
		Endif
	EndIf

	nTotVal := 0

	For nCntP := 1 To Len(aValBenef)
		//Indica se o registro atual e o funcionario ou o beneficiario
		lRegFun := (aValBenef[nCntP,8] == 'SRA')

		//Posiciona no registro que esta sendo processado
		(aValBenef[nCntP,8])->(dbGoTo(aValBenef[nCntP,7]))

		If(!lRegFun) /*Se for Beneficiário, posiciona no Funcionário também.*/
			SRA->(dbSeek(SRQ->(RQ_FILIAL+RQ_MAT)))
		EndIf

		cNome	:= SubStr( aValBenef[nCntP,1], 1, 60 )
		cBanco	:= aValBenef[nCntP,2]
		cConta	:= aValBenef[nCntP,3]
		cCPF	:= aValBenef[nCntP,6]

		// VERIFICA VALOR E BANCO/AGENCIA DOS BENEFICIARIOS
		If !lRegFun
			If !lRangeX1
				If aValBenef[nCntP,5] == 0  .Or. (!Empty(cBanco) .And. ( cBanco < cBcoDe) .Or. (cBanco > cBcoAte)) .Or. (!Empty(cConta) .And.  ((cConta < cCtaDe) .Or. (cConta > cCtaAte)))
					Loop
				EndIf
			Else
				If aValBenef[nCntP,5] == 0 .Or. Empty(cBanco) .Or. !(fChkBenef(aValBenef[nCntP,7], cBcoValB, cCtaValB))
					Loop
				EndIf
			EndIf
		EndIf

		// IGUALA NAS VARIAVEIS USADAS DO ARQUIVO DE CADASTRAMENTO
		If cPaisLoc $ "PER|MEX|COL|EQU"
			nValor := aValBenef[nCntP,5]
		Else
			nValor := aValBenef[nCntP,5] * 100
		EndIf
		// PONTO DE ENTRADA PARA ALTERAR DADOS CASO NECESSARIO
		If lGp450Val
			If !(ExecBlock("GP450VAL",.F.,.F.))
				Loop
			EndIf
		EndIf

		nTotal += nValor
		nTotFunc++
		nSeq++

		If ( nModelo == 1 )
			// LE ARQUIVO DE PARAMETRIZACAO
			nLidos:=0
			fSeek(nHdlBco,0,0)
			nTamArq:=FSEEK(nHdlBco,0,2)
			fSeek(nHdlBco,0,0)

			While nLidos <= nTamArq
				// VERIFICA O TIPO QUAL REGISTRO FOI LIDO
				xBuffer:=Space(85)
				FREAD(nHdlBco,@xBuffer,85)

				Do case
					Case SubStr(xBuffer,1,1) == CHR(1)
						If lHeader
							nLidos+=85
							Loop
						EndIf
					Case SubStr(xBuffer,1,1) == CHR(2)
						If !lFirst
							lFirst := .T.
							FWRITE(nHdlSaida,CHR(13)+CHR(10))
						EndIf
					Case SubStr(xBuffer,1,1) == CHR(3)
						nLidos+=85
						Loop
					Otherwise
						nLidos+=85
						Loop
				EndCase
				nTam := 1+(Val(SubStr(xBuffer,20,3))-Val(SubStr(xBuffer,17,3)))
				nDec := Val(SubStr(xBuffer,23,1))
				cConteudo:= SubStr(xBuffer,24,60)
				If ( aValBenef[ nCntP, 7 ] != 0 .and. ( SubStr(AllTrim(cConteudo),3,1) == "SRQ" ) )
					SRQ->(dbGoTo(aValBenef[nCntP,7]))
				EndIf
				lGrava := fM080Grava(nTam,nDec,cConteudo)
				If !lGrava
					Exit
				EndIf
				nLidos+=85
			EndDo
			If !lGrava
				Exit
			EndIf
		ElseIf ( nModelo == 2 )
			if(lMod2Ambos)
				if(cLote != aValBenef[nCntP,13] + aValBenef[nCntP,9]) .And. lQbCta

					nTotal  := nLoteTotal
					nTotLin += nQtdLinLote + 2
					/*Encerra o Lote atual imprimindo seu Rodapé(Trailer)*/
					RodaLote2(nHdlSaida,cArqent)

					/*Antes de imprimir o Header do Lote subsequente, incrementa o sequencial,
					zera o valor total e a quantidade de linhas do Lote.*/
					nLoteSeq++
					nTotal      := nValor
					nLoteTotal	:= nValor
					nLoteQtd	:= 1 //Número de Funcionários

					cLote 		:= aValBenef[nCntP,13] + aValBenef[nCntP,9]
					nQtdLinLote	:= 0 //Número de LINHAS, utilizado quando há múltiplos segmentos.
					HeadLote2(nHdlSaida,cArqent)
				else
					nLoteTotal	+= nValor
					nLoteQtd++
				endIf
			else
				nLoteTotal	+= nValor
				nLoteQtd++
			endIf

			lGrava := fM080Grava(,,,nCntP)
		ElseIf ( nModelo == 3 )
			// GRAVA AS LINHAS DE DETALHE DE ACORDO COM O TIPO DO BORDERO
			fm080Linha( cDetaG ,@cLocaBco,@cLocaPro)
			fm080Linha( cDetaH ,@cLocaBco,@cLocaPro)
		EndIf
		If lGrava
			If ( nModelo == 1 )
				fWrite(nHdlSaida,CHR(13)+CHR(10))
				If !lHeader
					lHeader := .T.
				EndIf
			EndIf
		EndIf
		//Grava arquivo de log.
		If nTotRegs == 0
			// 12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123
			//"Processo          Filial          Matricula          Funcionario                             Líquido em Arquivo"
			// 12345             XX              123456             123456789012345678901234567890              999,999,999.99
				if cPaisLoc == "CHI"
					cLog := (Alltrim(STR0018)+ Space(03) + Alltrim(STR0019) + Space(nTamFil) + Alltrim(STR0023) + Space(04) + ;
					Alltrim(STR0017) + Space(Len(cNome)) + STR0035 )
				else
					cLog := (Alltrim(STR0019) + Space(06) + STR0042 + Space(05) + STR0011 + Space(08) + Alltrim(STR0023) + Space(TAMSX3("RA_MAT")[1] - 2) + Alltrim(STR0017) + Space(41) + STR0012 )
			//						"Filial"							"Bco./Ag."			  "Conta"					"Matricula"					"Funcionario"			"Líquido em Arquivo"
				endif

			Aadd(aTitle,cLog)
			Aadd(aLog,{})
			nTotRegs := len(aLog)
		EndIf
		if cPaisLoc == "CHI"
			Aadd(aLog[nTotRegs],(PADR(ALLTRIM(SRA->RA_PROCES),len(Alltrim(STR0018))+TAMSX3("RA_PROCES")[1], ) + PADR(ALLTRIM(SRA->RA_FILIAL),len(Alltrim(STR0019))+TAMSX3("RA_FILIAL")[1], ) +;
			PADR(ALLTRIM(SRA->RA_MAT),len(Alltrim(STR0023))+ TAMSX3("RA_MAT")[1], )+ PADR(ALLTRIM(cNome), TAMSX3("RA_NOMECMP")[1] , ) + PADL(alltrim(transform( (nValor / 100), "@E 999,999,999.99")),18, )))
			//"Processo " ### - "Filial " ### - "Matricula " ### - Funcionario " ### " - " + "Valor " ###.##
		else
			Aadd(aLog[nTotRegs], ( SRA->RA_FILIAL + Space( 12 - nTamFil ) + cBanco + Space(05) + cConta + Space(03) + SRA->RA_MAT + space(07) +  Left(cNome,54) + space(62 - len(cNome)) + Transform( (IIF(cPaisLoc $ "PER|MEX|COL|EQU",nValor,nValor /100) ), "@E 999,999,999.99") ) )
			//Filial ######## - Banco/Agencia ######## - Conta ######## - Matricula ###### - Nome ########## - Valor ###.##
		endif
		nRegsGrav++
		nTotVal += nValor
		gpm280Reset()
	Next nCntP

	If (nModelo == 1)
		// MONTA REGISTRO TRAILLER
		nSeq++
		nLidos:=0
		FSEEK(nHdlBco,0,0)
		nTamArq:=FSEEK(nHdlBco,0,2)
		FSEEK(nHdlBco,0,0)

		While nLidos <= nTamArq
			If !lGrava
				Exit
			EndIf
			// TIPO QUAL REGISTRO FOI LIDO
			xBuffer:=Space(85)
			fRead(nHdlBco,@xBuffer,85)
			If SubStr(xBuffer,1,1) == CHR(3)
				nTam := 1+(Val(SubStr(xBuffer,20,3))-Val(SubStr(xBuffer,17,3)))
				nDec := Val(SubStr(xBuffer,23,1))
				cConteudo:= SubStr(xBuffer,24,60)
				lGrava:=fM080Grava( nTam,nDec,cConteudo )
				If !lGrava
					Exit
				EndIf
			EndIf
			nLidos+=85
		EndDo
		If lGrava .And. lLnVazia
			fWrite(nHdlSaida, cQuebra)
		EndIf
	ElseIf ( nModelo == 2 )
		nTotLin += nQtdLinLote + 4
		RodaCnab2(nHdlSaida,cArqent,lLnVazia)
	ElseIf ( nModelo == 3 )
		// GRAVA OS TRAILLERS DE LOTE E DE ARQUIVO
		fm080Linha(cTraiLote)
		fm080Linha(cTraiArq)
	EndIf

	If nTotfunc > 0
		fAtuTot(cArqSaida)
	EndIf

	// SE UTILIZAR TOTALIZADOR NO CABECALHO, TROCAR STRING POR VALOR
	If ExistBlock("GPM080HDR") .And. lUtilizaMI
		ExecBlock("GPM080HDR",.F.,.F.)
	EndIf

	//PONTOS DE ENTRADAS UTILIZADOS PARA CRIPTOGRAFIA DE ARQUIVO DE ENVIO
	// CNAB Modelos 1 e 2
	If ExistBlock("GP410CRP")
		ExecBlock("GP410CRP",.F.,.F.)
	EndIf
	// SISPAG
	If ExistBlock("GP450CRP")
		ExecBlock("GP450CRP",.F.,.F.)
	EndIf

	If nModelo == 2 .and. lLnVazia .And.  cPaisLoc != "MEX"
		fWrite(nHdlSaida,CHR(13)+CHR(10))
	Endif

	fClose(nHdlSaida)
	fClose(nHdlBco)

	If ( nModelo == 1 ) .Or. ( nModelo == 3 )
		If lCpyBkp
			Ferase( cArqEntBkp )
		EndIf
	EndIf

	If lCpyS2T
		If CpyS2T( cStartPath + IIF(cPaisLoc == "MEX", "", "temp_") + cNomArq, cNomDir,,IIf(cPaisLoc == "MEX", .F.,))

			If  cPaisLoc != "MEX"
				If File(cNomDir + cNomArq)
					fErase(cNomDir + cNomArq)
				EndIf

				fRename(cNomDir + "temp_" + cNomArq, cNomDir + StrTran( cNomArq, "temp_", ""))
			Endif
			fErase( cStartPath + IIF(cPaisLoc == "MEX", "", "temp_") + cNomArq )
		EndIf
	EndIf

	//Gera arquivo de log
	//Exibe apenas após o fechamento do arquivo, pois caso contrário o arquivo fica preso até
	//fecharem a tela de Log.
	If nTotRegs > 0
		Aadd(aLog[nTotRegs], Replicate("-",132))
		Aadd(aLog[nTotRegs], ( STR0024 + lTrim(Str(nRegsGrav,6))+ space(23) + STR0025 + Transform((IIF(cPaisLoc $ "PER|MEX|COL|EQU",nTotVal,nTotVal /100)),"@E 99,999,999,999.99")) )
		//"Total de Registros Gerados: " ### "Valor Total: "
	Else
		aAdd( aLog, { OemToAnsi(STR0026) } ) //"Nenhum Registro Processado com os Parametros Informados!"
	EndIf

	//	--	"Deseja visualizar movimentos gerados?" ### "Atencao!"
	If !lAutomato
		If !lAuto .And. MsgYesNo(OemToAnsi( STR0020), OemToAnsi(STR0021))
			cData	:=	DtoS(DDATABASE)
			cHora	:=	Time()
			cArq := "GPM080" + cData
			fMakeLog (aLog,aTitle,,.T.,cArq,IIF(cPaisLoc == "CHI", STR0034 , STR0022),"M","P",,.F.)	//	"Log de Geracao de Liquidos em Arquivo."
		EndIf
	Endif

Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³AbrePar   ³ Autor ³ Wagner Xavier         ³ Data ³ 26/05/92 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Abre arquivo de Parametros                                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³AbrePar()                                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³GPEM080                                                     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function AbrePar(cArqSaida,cArqEnt, cArqEntBkp, lCpyBkp)
Local cPathSrv		:= "" 	// Caminho Startpatch
Local cArchNom		:= ""	// Nome do Arquivo de Configuração
Local cNewArq		:= "" 	// Captura  Arquivo de Configuração de acordo com Configuração de Parâmetros
Local cNewLayout	:= ""	// Layout da Impressão considerando cópia para system

Default lCpyBkp		:= .F.	// Valida operação de Cópia de Arquivo
Default cArqEntBkp	:= ""

If ( nModelo == 1 .Or. nModelo == 3 )
	cNewArq 	:= AllTrim(cArqEnt)
	// Verifico se Arquivo de Configuração está no Servidor
	nPosIni	:= At( "\", cNewArq ) 
	If !(nPosIni == 1)
		nPosFim 	:= rAt( "\", cNewArq )
		cArchNom 	:= SubStr(cNewArq, nPosFim+1, Len(cNewArq) ) // Captura nome do arquivo
		cPathSrv	:= GetPvProfString( GetEnvServer(),"StartPath","",GetAdv97() )	
		lCpyBkp		:= CpyT2S( cArqEnt , cPathSrv ) // Copia arquivo para pasta System 
		Frename( cPathSrv + cArchNom,  cPathSrv + "\" + "bkp" + cArchNom) // Renomeia arquivo na pasta System
		cNewLayout	:= If(lCpyBkp, cPathSrv + "bkp" + cArchNom, cArqEnt)
		nTipo		:= 16 // FO_EXCLUSIVE
	Else
		cNewLayout	:= cArqEnt
		nTipo		:= 64 // FO_DENYNONE
	EndIf
	nHdlBco		:=	FOPEN(cNewLayout,nTipo)
	cArqEntBkp	:= 	cNewLayout
EndIf


// CRIA ARQUIVO SAIDA
If ( nModelo == 1 .or. nModelo == 3 )
	nHdlSaida:=MSFCREATE(cArqSaida,0)
Else
	If cPaisLoc $ "MEX|CHI"
		nHdlSaida:=HeadCnabMI(cArqSaida,cArqent)
	Else
		nHdlSaida:=HeadCnab2(cArqSaida,cArqent)
	EndIf
EndIf

Return .T.

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³fM080Grava³ Autor ³ Wagner Xavier         ³ Data ³ 26/05/92 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Rotina de Geracao do Arquivo de Remessa de Comunicacao      ³±±
±±³          ³Bancaria                                                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ExpL1:=fM080Grava(ExpN1,ExpN2,ExpC1)                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ GPEM080                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
STATIC Function fM080Grava( nTam, nDec, cConteudo, nCntP )
Local lConteudo := .T., cCampo

If ( nModelo == 1 .or. nModelo == 3 )
	// ANALISA CONTEUDO
	If Empty(cConteudo)
		cCampo:=Space(nTam)
	Else
		If "_ARQ" $ cConteudo
			gpm280Var(cConteudo)
		EndIf
		lConteudo := fM080Orig( cConteudo )
		If !lConteudo
			Return .F.
		Else
			If ValType(xConteudo)="D"
				cCampo := GravaData(xConteudo,.F.)
			ElseIf ValType(xConteudo)="N"
				cCampo:=Substr(Strzero(xConteudo,nTam,nDec),1,nTam)
			Else
				If ValType(xConteudo) == "U"
					xConteudo := ""
				EndIf

				cCampo:=Substr(xConteudo,1,nTam)
			EndIf
		EndIf
	EndIf
	If Len(cCampo) < nTam  //Preenche campo a ser gravado, caso menor
		cCampo:=cCampo+Space(nTam-Len(cCampo))
	EndIf
	Fwrite( nHdlSaida,cCampo,nTam )
Else
	DetCnab2(nHdlSaida,cArqent,,,nCntP)
EndIf

Return lConteudo

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³fM080Orig ³ Autor ³ Wagner Xavier         ³ Data ³ 10/11/92 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Verifica se expressao e' valida para Remessa CNAB.          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³GPEM080                                                     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function fM080Orig( cForm )
Local bBlock:=ErrorBlock(),bErro := ErrorBlock( { |e| ChecErr260(e,cForm) } )
Private lRet := .T.

BEGIN SEQUENCE
	xConteudo := &cForm
END SEQUENCE

ErrorBlock(bBlock)

Return lRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³fm080Linha³ Autor ³ Vinicius S.Barreira   ³ Data ³ 11.11.96 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Grava linha do Arquivo Remessa SisPag                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ fm080Linha( Parametro )                                    ³±±
±±³          ³ Parametro: letra correspondente  „ linha do arquivo de     ³±±
±±³          ³ configura‡„o SisPag.                                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ GPEM080()                                                  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function fm080Linha( cParametro ,cLocaBco , cLocaPro)
Local nLidos    := 0
Local nTamArq   := 0
Local nTam      := 0
Local nDec      := 0
local cConteudo := ""
Local lGerouReg := .F.
Local lArqOk	:= .T.

cLocaBco := If(Empty(cLocaBco),"",cLocaBco)
cLocaPro := If(Empty(cLocaPro),"",cLocaPro)

If ValType( cParametro ) # "C" .or. Empty( cParametro )
   Return .T.
EndIf

//VENDO O TAMANHO DA PRIMEIRA LINHA. EVITAR ERROS EM QUE O ARQUIVO .2pe/2re é renomeado para .PAG

nHandle := FT_FUse(cArqEnt)

If nHandle == -1
	Help(" ",1,"A210NOPEN")	// "Nao foi possivel abrir o arquivo."
	lArqOk := .F.
	Return lArqOk
Endif

FT_FGoTop()

cLine  := FT_FReadLn()

FT_FUSE()

If Len(cLine) == 500
	Aviso(OemToAnsi(STR0021),OemToAnsi(STR0043), {OemToAnsi(STR0041)})
	lArqOk := .F.
	Return lArqOk
Endif

// LE ARQUIVO DE PARAMETRIZACAO
nLidos := 0
fSeek(nHdlBco,0,0)
nTamArq := fSeek(nHdlBco,0,2)
fSeek(nHdlBco,0,0)

While nLidos <= nTamArq
   // VERIFICA O TIPO QUAL REGISTRO FOI LIDO

   xBuffer := Space(85)
   fRead(nHdlBco,@xBuffer,85)

   If SubStr( xBuffer,1,1) == cParametro
      nTam := 1+(Val(SubStr(xBuffer,20,3))-Val(SubStr(xBuffer,17,3)))
      nDec := Val(SubStr(xBuffer,23,1))
      cConteudo := SubStr(xBuffer,24,60)
		If ( STR0009== SubStr(xBuffer,2,15) .Or.; //"Codigo Banco   "
			  STR0010==SubStr(xBuffer,2,15) .Or.;  //"Num. Agencia   "
			  STR0011==SubStr(xBuffer,2,15) )      //"Num. C/C.      "
			If (!SubStr(xBuffer,2,15)$cLOCAPRO )
				cLOCABCO += &(ALLTRIM(cConteudo))
				cLOCAPRO += SubStr(xBuffer,2,15)
			EndIf
		EndIf
		If (("CGC"$Upper(SubStr(xBuffer,2,15)) .And.	AllTrim(cConteudo)=='"16670085000155"' ) .Or. cLOCABCO=="34101403000000034594")
			Alert("CONFIGURACAO INVALIDA")
			lGrava := .F.
		Else
	      lGrava := fM080Grava(nTam,nDec,cConteudo)
		EndIf
      If !lGrava
         Exit
      EndIf
      lGerouReg := .T.
   EndIf

   nLidos += 85

EndDo

If lGerouReg
	FWRITE(nHdlSaida,CHR(13)+CHR(10))
EndIf

Return lArqOk

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³FDLiqu    ³ Autor ³ R.H. -                ³ Data ³ 26/01/01 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ SELECIONAR DIRETORIO PARA GRAVA ARQUIVO CNAB/SISPAG        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ FDLiqu()                                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ GPEM080                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function FDLiqu(cLayout)
Local mvRet		:= Alltrim(ReadVar())
Local cType 	:= ""
Local cArq		:= ""
Local aDir		:= {}
Local nDir		:= 0

if cPaisLoc <> "BRA
	cType := If(cLayout == 1, ".REM|*.REM|", If(cLayout == 2, ".RE2|*.RE2|.2RE|*.2RE|.2PE|*.2PE" , STR0015))
ELSE
	cType := If(cLayout == 1, ".CPE|*.CPE|.REM|*.REM|", If(cLayout == 2, ".2PE|*.2PE|.2RE|*.2RE|.2PR|*.2PR|.2RR|*.2RR|" , STR0015))
ENDIF

// COMANDO PARA SELECIONAR UM ARQUIVO.
// PARAMETRO: GETF_LOCALFLOPPY - INCLUI O FLOPPY DRIVE LOCAL.
//            GETF_LOCALHARD - INCLUI O HARDDISK LOCAL.
cArq 	:= cGetFile(cType, OemToAnsi(STR0016), 0,, .T.,GETF_LOCALHARD+GETF_LOCALFLOPPY,,)  // "Selecione arquivo "
aDir	:= { { cArq } }

For nDir := 1 To Len(aDir)
	cArq := aDir[nDir][1]

	If !Empty(cArq)
		If !File(cArq)
			MsgAlert(OemToAnsi(STR0030)+ cArq)  // "Arquivo nao encontrado "
			Return .F.
		EndIf
	EndIf
Next nDir

&mvRet := cArq

Return (.T.)

/*
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³DetCnab2      ³ Autor ³ Marcelo Silveira  ³ Data ³23/11/2012³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Geracao do arquivo na rotina local devido o tratamento das  ³
³          ³variaveis disponibilizadas para geracao do arquivo liquidos ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Uso      ³ Gpem080                                                    ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
Static Function DetCnab2(nHandle,cLayOut,lIdCnab,cAlias,nCntP)
Local nHdlLay	:= 0
Local lContinua := .T.
Local cBuffer	:= ""
Local aLayOut	:= {}
Local aDetalhe  := {}
Local nCntFor	:= 0
Local nCntFor2  := 0
Local lFormula  := ""
Local nPosIni	:= 0
Local nPosFim	:= 0
Local nTamanho  := 0
Local nDecimal  := 0
Local bBlock	:= ErrorBlock()
Local bErro 	:= ErrorBlock( { |e| ChecErr260(e,xConteudo) } )
Local aGetArea  := GetArea()
Local cIdCnab
Local aArea
Local nOrdem
Local lRodaCnab2:= .F.
Local cPathSrv		:= "" 	// Caminho Startpatch
Local cArchNom		:= ""	// Nome do Arquivo de Configuração
Local cNewArq		:= "" 	// Captura  Arquivo de Configuração de acordo com Configuração de Parâmetros
Local cNewLayout	:= ""	// Layout da Impressão considerando cópia para system
Local lCpyOk		:= .F.	// Valida operação de Cópia de Arquivo

DEFAULT cAlias		:= ""
DEFAULT lIdCnab 	:= .F.
Default nCntP		:= 0

Private xConteudo	:= ""

cNewArq 	:= AllTrim(cLayOut)
// Verifico se Arquivo de Configuração está no Servidor
nPosIni	:= At( "\", cNewArq ) 
If !(nPosIni == 1)
	nPosFim 	:= rAt( "\", cNewArq )
	cArchNom 	:= SubStr(cNewArq, nPosFim+1, Len(cNewArq) ) // Captura nome do arquivo
	cPathSrv	:= GetPvProfString( GetEnvServer(),"StartPath","",GetAdv97() )	
	lCpyOk		:= CpyT2S( cLayOut , cPathSrv ) // Copia arquivo para pasta System 
	Frename( cPathSrv + cArchNom,  cPathSrv + "\" + "bkp" + cArchNom) // Renomeia arquivo na pasta System
	cNewLayout	:= If(lCpyOk, cPathSrv + "bkp" + cArchNom, cLayOut)
	nTipo		:= 16 // FO_EXCLUSIVE
Else
	cNewLayout	:= cLayOut
	nTipo		:= 64 // FO_DENYNONE
EndIf

If  File( cNewLayout )
	nHdlLay := FOpen(cNewLayout,nTipo)
	While ( lContinua )
		cBuffer := FreadStr(nHdlLay,502)
		If ( !Empty(cBuffer) )
			If ( SubStr(cBuffer,1,1)=="1" )
				If ( SubStr(cBuffer,3,1) == "D" )
					aadd(aLayOut,{ SubStr(cBuffer,02,03),;
					SubStr(cBuffer,05,30),;
					SubStr(cBuffer,35,255)})
				EndIf
				If  cPaisLoc == "MEX" .And. ( SubStr(cBuffer,3,1) == "T" )
					lRodaCnab2 := .T.
				EndIf

			Else
				If ( SubStr(cBuffer,3,1) == "D" )
					aadd(aDetalhe,{SubStr(cBuffer,02,03),;
					SubStr(cBuffer,05,15),;
					SubStr(cBuffer,20,03),;
					SubStr(cBuffer,23,03),;
					SubStr(cBuffer,26,01),;
					SubStr(cBuffer,27,255)})
				EndIf
				If cPaisLoc == "MEX" .And. ( SubStr(cBuffer,3,1)=="T" )
					lRodaCnab2 := .T.
				EndIf
			EndIf
		Else
			lContinua := .F.
		EndIf
	End
	FClose(nHdlLay)
EndIf
If nHandle > 0
	For nCntFor := 1 To Len(aLayOut)
		Begin Sequence
		lFormula := &(AllTrim(aLayOut[nCntFor,3]))
		If ( lFormula .And. SubStr(aLayOut[nCntFor,1],2,1)=="D" )
			cBuffer := ""
			// So gera outro identificador, caso o titulo ainda nao o tenha, pois pode ser um re-envio do arquivo
			If !Empty(cAlias) .And. lIdCnab .And. Empty((cAlias)->&(Right(cAlias,2)+"_IDCNAB"))
				// Gera identificador do registro CNAB no titulo enviado
				nOrdem := If(Alltrim(Upper(cAlias))=="SE1",16,11)
				cIdCnab := GetSxENum(cAlias, Right(cAlias,2)+"_IDCNAB",Right(cAlias,2)+"_IDCNAB"+cEmpAnt,nOrdem)
				// Garante que o identificador gerado nao existe na base
				dbSelectArea(cAlias)
				aArea := (cAlias)->(GetArea())
				dbSetOrder(nOrdem)
				While (cAlias)->(MsSeek(xFilial(cAlias)+cIdCnab))
					ConOut("Id CNAB " + cIdCnab + " já existe para o arquivo " + cAlias + ". Gerando novo número ")
					If ( __lSx8 )
						ConfirmSX8()
					EndIf
					cIdCnab := GetSxENum(cAlias, Right(cAlias,2)+"_IDCNAB",Right(cAlias,2)+"_IDCNAB"+cEmpAnt,nOrdem)
				EndDo
				(cAlias)->(RestArea(aArea))
				Reclock(cAlias)
				(cAlias)->&(Right(cAlias,2)+"_IDCNAB") := cIdCnab
				MsUnlock()
				ConfirmSx8()
				lIdCnab := .F. // Gera o identificacao do registro CNAB apenas uma vez no
									// titulo enviado
			EndIf
			For nCntFor2 := 1 To Len(aDetalhe)
				If ( aDetalhe[nCntFor2,1] == aLayOut[nCntFor,1] )
					xConteudo := aDetalhe[nCntFor2,6]
					If ( Empty(xConteudo) )
						xConteudo := ""
					Else
						If "_ARQ" $ xConteudo
							gpm280Var(xConteudo)
						EndIf
						xConteudo := &(AllTrim(xConteudo))
					EndIf
					nPosIni   := Val(aDetalhe[nCntFor2,3])
					nPosFim   := Val(aDetalhe[nCntFor2,4])
					nDecimal  := Val(aDetalhe[nCntFor2,5])
					nTamanho  := nPosFim-nPosIni+1
					Do Case
						Case ValType(xConteudo) == "D"
							xConteudo := GravaData(xConteudo,.F.)
						Case ValType(xConteudo) == "N"
							xConteudo := StrZero(xConteudo,nTamanho,nDecimal)
					EndCase
					xConteudo := SubStr(xConteudo,1,nTamanho)
					xConteudo := PadR(xConteudo,nTamanho)
					cBuffer += xConteudo
				EndIf
			Next nCntFor2
			If cPaisLoc == "MEX" .And. nCntP == Len(aValBenef) .And. !lRodaCnab2
				cBuffer += Iif(nCntFor < Len(aLayOut), Chr(13)+Chr(10), "")
			Else
				cBuffer += Chr(13)+Chr(10)
			Endif
			Fwrite(nHandle,cBuffer,Len(cBuffer))
			nQtdLinLote++
		EndIf
		End Sequence
	Next nCntFor
	ErrorBlock(bBlock)
EndIf

If 	lCpyOk
	Ferase( cNewLayout )
EndIf

RestArea(aGetArea)
Return(.T.)

/*
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³gpm280Var     ³ Autor ³ Marcelo Silveira  ³ Data ³26/11/2012³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Atualiza as variaveis disponibilizadas para o arquivo de    ³
³          ³configuracao                                                ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Uso      ³ Gpem080                                                    ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
Static Function gpm280Var(xConteudo)

If cPaisLoc == "MEX"
	If( "CIC_ARQ"     $ xConteudo, CIC_ARQ     := If( lRegFun, SRA->RA_CIC, SRQ->RQ_CIC ),    	   "" )
	If( "NOME_ARQ"    $ xConteudo, NOME_ARQ    := If( lRegFun, SRA->RA_NOME, SRQ->RQ_NOME ),	   "" )
	If( "PRINOME_ARQ" $ xConteudo, PRINOME_ARQ := If( lRegFun, SRA->RA_PRINOME, SRQ->RQ_PRINOME ), "" )
	If( "SECNOME_ARQ" $ xConteudo, SECNOME_ARQ := If( lRegFun, SRA->RA_SECNOME, SRQ->RQ_SECNOME ), "" )
	If( "PRISOBR_ARQ" $ xConteudo, PRISOBR_ARQ := If( lRegFun, SRA->RA_PRISOBR, SRQ->RQ_PRISOBR ), "" )
	If( "SECSOBR_ARQ" $ xConteudo, SECSOBR_ARQ := If( lRegFun, SRA->RA_SECSOBR, SRQ->RQ_SECSOBR ), "" )
	If( "BANCO_ARQ"   $ xConteudo, BANCO_ARQ   := If( lRegFun, AllTrim(SRA->RA_BCDEPSA), AllTrim(SRQ->RQ_BCDEPBE)), "" )
	If( "CONTA_ARQ"   $ xConteudo, CONTA_ARQ   := If( lRegFun, AllTrim(SRA->RA_CTDEPSA), AllTrim(SRQ->RQ_CTDEPBE)), "" )
EndIf

Return()

/*
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³gpm280Reset   ³ Autor ³ Marcelo Silveira  ³ Data ³26/11/2012³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Limpa o conteudo da variaveis usadas no arquivo de config.  ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Uso      ³ Gpem080                                                    ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
STATIC FUNCTION gpm280Reset()
	CIC_ARQ		:= ""
	NOME_ARQ	:= ""
	PRINOME_ARQ	:= ""
	SECNOME_ARQ	:= ""
	PRISOBR_ARQ	:= ""
	SECSOBR_ARQ	:= ""
	BANCO_ARQ	:= ""
	CONTA_ARQ	:= ""
Return()

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ³±±
±±³Funcao    ³GPM080Empresa³ Autor ³ Adilson Silva      ³ Data ³ 05/04/13 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ³±±
±±³Descricao ³Busca o CNPJ da Empresa com Convenio no Banco para o CNAB.  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ³±±
±±³ Uso      ³ GPEM080()                                                  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function GPM080Empresa(cFil, cCodCnpj, cNomeEmpr)
Local aOldAtu := GetArea()
Local aOldSm0 := SM0->(GetArea())

DbSelectArea("SM0")
DbSetOrder(1)
If dbSeek(cEmpAnt + cFil)
   cCodCnpj  := SM0->M0_CGC
   cNomeEmpr := Upper(Alltrim(SM0->M0_NOMECOM))
   fInfo(@aInfo,cFil)
EndIf

RestArea(aOldSm0)
RestArea(aOldAtu)

Return

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³CNABSequencia³ Autor ³ Adilson Silva      ³ Data ³ 05/04/13 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Busca o CNPJ da Empresa com Convenio no Banco para o CNAB.  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ GPEM450()                                                  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Function CNABSequencia()
Local cSTabela   := "S052"
Local aOldAtu   := GetArea()
Local cRet      := "000000"
Local cTexto    := ""
Local cRCCAlias := GetNextAlias()

If lUsaBanco

	BeginSql Alias cRCCAlias
		SELECT  RCC.*   FROM 	%table:RCC% RCC
		        WHERE RCC.RCC_CODIGO   = %Exp:(cSTabela)%  AND RCC.%NotDel%
	EndSql

	While ! Eof() .And. (cRCCAlias)->(RCC_CODIGO) == cSTabela

	    If  (cRCCAlias)->(RCC_FIL)  == cCodFilial .or.  Empty((cRCCAlias)->(RCC_FIL))
		    RCC->(DbGoto( (cRCCAlias)->(R_E_C_N_O_) ))

		    If SubStr(RCC->RCC_CONTEU,21,3) == cCodBanco .And. SubStr(RCC->RCC_CONTEU,24,5) == cCodAgenc .And. SubStr(RCC->RCC_CONTEU,30,12) == cCodConta
		 		cRet   := StrZero(Val(SubStr(RCC->RCC_CONTEU,43,6))+1,6)
		      	cTexto := Stuff(RCC->RCC_CONTEU,43,6,cRet)
		      	RecLock("RCC",.F.)
				RCC->RCC_CONTEU := cTexto
		      	MsUnlock()
		      	Exit
	      	EndIf

		EndIf

		(cRCCAlias)->(dbSkip())
	EndDo

	(cRCCAlias)->(DBCloseArea())
EndIf

RestArea( aOldAtu )

Return( cRet )

/*/{Protheus.doc} GetBankInf
	Obtem os dados sobre o banco selecionado pelo usuário
@author philipe.pompeu
@since 22/06/2016
@version P11
@return ${return}, ${return_description}
/*/
Static Function GetBankInf( lShowHelp, cFilBco )
	Local aTabS052      := {}

	DEFAULT lShowHelp := .T.
	DEFAULT cFilBco   := SRA->RA_FILIAL
	If cPaisLoc == "BRA"
		fCarrTab( @aTabS052, "S052", Nil,,,,cFilBco)
		If Len( aTabS052 ) == 0 .Or. ;
		( nPos := aScan(aTabS052,{|x| x[6] == cCodBanco .And. (Empty(cSeqS052) .Or. x[4] == cSeqS052 ) .And. ;
		IIf( cPaisLoc <> "MEX",(x[7] == cCodAgenc .And. x[9] == cCodConta),.T. ) .And. (Empty(x[2]) .Or. x[2] == cFilBco)}) ) == 0

		   If lShowHelp
		   		Aviso(STR0021,STR0031,{STR0032}) //"ATENCAO","Banco e Filial para processamento do CNAB não cadastrados na tabela S052! Favor verificar!" ### Sair
		   EndIf
		   Return .F.
		EndIf
	EndIf
	GPM080Empresa( cFilBco, @cCodCnpj, @cNomeEmpr )
	If cPaisLoc == "BRA"
	   	cCodFilial := aTabS052[nPos,2]
		cCodConve  := aTabS052[nPos,5]
		cCodAgenc  := aTabS052[nPos,7]
		cDigAgenc  := aTabS052[nPos,8]
		cCodConta  := aTabS052[nPos,9]
		cDigConta  := aTabS052[nPos,10]
		cSeq       := aTabS052[nPos,11]

		If Len( aTabS052[nPos] ) >= 12
			lQbCta := aTabS052[nPos,12] == "S"
		EndIf
	EndIf

	SA6->(dbSeek( xFilial("SA6",cFilBco) + cCodBanco + cCodAgenc + cCodConta ))
Return .T.

/*/{Protheus.doc} SetArqNome
 Trata o nome do arquivo.
@author philipe.pompeu
@since 22/06/2016
@version P11
@param cArqSaida, character, (Descrição do parâmetro)
@param lCpyS2T, ${param_type}, (Descrição do parâmetro)
@param cNomArq, character, (Descrição do parâmetro)
@param cNomDir, character, (Descrição do parâmetro)
@return ${return}, ${return_description}
/*/
Static Function SetArqNome(cArqSaida,lCpyS2T,cNomArq,cNomDir)
	Local nTpRemote	:= 0
	Local nAt			:= 0
	Local cNewArq		:= ""
	Local cAux			:= ""
	Local nCont		:= 1
	Default cArqSaida := ""
	Default lCpyS2T := .F.
	Default cNomArq := ""
	Default cNomDir := ""


	/*ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	|VERIFICA SE O USUARIO DEFINIU UM DIRETORIO LOCAL PARA GRAVACAO DO ARQ. |
	|DE SAIDA, POIS NESSE CASO EFETUA A GERACAO DO ARQUIVO NO SERVIDOR E AO |
	|FIM DA GERACAO COPIA PARA O DIRETORIO LOCAL E APAGA DO SERVIDOR.       |
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ*/

    // PONTOS DE ENTRADAS PARA ALTERAR O NOME DA VARIAVEL CARQSAIDA

    // CNAB MODELOS 1 E 2
    If ExistBlock("GP410ARQ")
        cArqSaida := ExecBlock( "GP410ARQ", .F., .F., {cArqSaida} )
    EndIf

    // SISPAG
    If ExistBlock("GP450ARQ")
        cArqSaida := ExecBlock( "GP450ARQ", .F., .F., {cArqSaida} )
    EndIf


	If Substr(cArqSaida, 2, 1) == ":"

		//?-CHECA O SO DO REMOTE (1=WINDOWS, 2=LINUX)
		nTpRemote := (GetRemoteType())

		If nTpRemote = 2
			nAt := RAt("/", cArqSaida)
		Else
			nAt := RAt("\", cArqSaida)
		EndIf

		If nAt = 0
			//"O ENDERECO ESPECIFICADO NO PARAMETRO 'ARQUIVO DE SAIDA' NAO E VALIDO. DIGITE UM ENDERECO VALIDO CONFORME O EXEMPLO:"
			//"UNIDADE:\NOME_DO_ARQUIVO"#"/NOME_DO_ARQUIVO"
			Alert(STR0027 + CRLF + CRLF + If(nTpRemote = 1, STR0028, STR0029))
			Return
		EndIf

		cNewArq := cArqSaida

		If (cAux := Substr(cArqSaida, Len(cArqSaida), 1)) == " "
			While cAux == " "
				cNewArq	:= Substr(cArqSaida, 1, Len(cArqSaida) - nCont)
				cAux	:= Substr(cNewArq, Len(cNewArq), 1)
				nCont++
			EndDo
		EndIf

		cNomArq		:= Right(cNewArq, Len(cNewArq) - nAt)
		cNomDir		:= Left(cNewArq, nAt)

		cArqSaida	:= cStartPath + IIF(cPaisLoc == "MEX", "", "temp_") + cNomArq
		lCpyS2T		:= .T.
	Endif
Return nil

/*/{Protheus.doc} CodProces
 Tratamiento para string de procesos.
@author oscar.lopez
@since 06/03/2019
@version P12
@param cProcessos, character, (Codigos de procesos)
@return cProcessos, character, (Codigos de procesos)
/*/
Static Function CodProces(cProcessos)

	Local nTamCod	:= GetSx3Cache("RCJ_CODIGO", "X3_TAMANHO")
	Local nPadR		:= 0
	Local lPad		:= .T.

	While lPad
		If ((Len(cProcessos) + nPadR) % nTamCod) == 0
			lPad := .F.
		Else
			nPadR++
		EndIf
	EndDo

	cProcessos := PadR(cProcessos, Len(cProcessos) + nPadR)

Return cProcessos

/*/{Protheus.doc} fAtuTot
Actualiza total de empleados en el encabezado.
@type function
@author mayra.camargo
@since 08/07/2019
@version 1.0
@param cFile, ruta con nombre del archivo que está siendo generado
/*/
Static Function fAtuTot(cFile)

Local nHandle 	:= 0
Local nFor    	:= 0
Local nX   		:= 0
Local cLinea  	:= ""
Local cAux		:= ""
Local nPos1		:= 0
Local nPos2		:= 0
Local cTotFunc	:= ""
Local aLineas   := {}
Local nI        := 0
Local nLoop     := 0
Local cNewLine  := ""
Local nDecimal  := 0
Local xConteudo := ""
Local nTamanho  := ""

nHandle := FT_FUse(cFile)

	If nHandle != -1

		nX := 1
		FT_FGoTop()
		nFor := FT_FLastRec()
		ProcRegua(nFor)

		While !FT_FEOF()

			IncProc(Str(nX))
			cLinea := FT_FREADLN()

			If  Empty(cLinea)
				FT_FSKIP()
				Loop
			Else
				If Len(aTotNeto) > 0
					//Valor nTotal y nTotFunc
					For nLoop := 1 To Len(aTotNeto)
						If aTotNeto[nLoop][6] == "" .And. At(aTotNeto[nLoop][5],cLinea) > 0
							nPos1 := Val(aTotNeto[nLoop][1])
							nPos2 := Val(aTotNeto[nLoop][2])
							nDecimal := Val(aTotNeto[nLoop][3])
							xConteudo := &(aTotNeto[nLoop][4])
							nTamanho  := nPos2-nPos1+1

							cNewLine := Substr( cLinea, 1, (nPos1 - 1) )
							If Valtype(xConteudo) == "N"
								xConteudo := STRZERO(xConteudo, (nPos2-(nPos1-1)), nDecimal)
							Else
								xConteudo := PADR(Alltrim(xConteudo), nTamanho)
							EndIf
							cNewLine += xConteudo + Substr( cLinea, (nPos2 + 1), Len(cLinea))
							cLinea := cNewLine

							aTotNeto[nLoop][6] := "X"
						Endif
					Next nLoop
				Else
					nPos1 := at("^",cLinea)
					If nPos1 > 0
						nPos2 := rat("^",cLinea)

						cAux := replicate("^",nPos2-(nPos1-1))
						cTotFunc:= STRZERO(nTotFunc,nPos2-(nPos1-1) )
						cLinea:= strTran(cLinea,cAux,cTotFunc)

					Endif
				EndIf
				If  cPaisLoc == "MEX"
					aAdd(aLineas,cLinea + Iif(nX < nFor .OR. lLnVazia, Chr(13)+ Chr(10), "")  )
				Else
					aAdd(aLineas,cLinea + Chr(13)+ Chr(10))
				Endif
			EndIf
			FT_FSKIP()
			nX++
		EndDo
		FT_FUSE()
	EndIf
	If len(aLineas)>0
		 If (nHandle := FOPEN(cFile,2)) >= 0
		    FSEEK(nHandle, 0)
		    For nI := 1 to len(aLineas)
		 		FWrite(nHandle, aLineas[nI])
		    Next Ni
		    FCLOSE(nHandle)
		 EndIf
	EndIf
Return

/*/{Protheus.doc} HeadCnabMI
Genera información para encabezado de archivo.
@type function
@author Luis Samaniego
@since 05/01/2021
@version 1.0
@param cArquivo, ruta con nombre del archivo que está siendo generado
       cLayOut, archivo de configuración para archivo de netos
/*/
Static Function HeadCnabMI(cArquivo,cLayOut)

Local nHandle	 := 0
Local lContinua := .T.
Local cBuffer	 := ""
Local aLayOut	 := {}
Local aDetalhe  := {}
Local nCntFor	 := 0
Local nCntFor2  := 0
Local lFormula  := ""
Local nPosIni	 := 0
Local nPosFim	 := 0
Local nTamanho  := 0
Local nDecimal  := 0
Local bBlock	 := ErrorBlock()
Local xConteudo := ""

If ( File(cLayOut) )
	nHandle := FOpen(cLayOut,64)
	While ( lContinua )
		cBuffer := FreadStr(nHandle,502)
		If ( !Empty(cBuffer) )
			If ( SubStr(cBuffer,1,1)=="1" )
				If ( SubStr(cBuffer,3,1) == "H" )
					aadd(aLayOut,{ SubStr(cBuffer,02,03),;
					SubStr(cBuffer,05,30),;
					SubStr(cBuffer,35,255)})
				EndIf
			Else
				If ( SubStr(cBuffer,3,1) == "H" )
					aadd(aDetalhe,{SubStr(cBuffer,02,03),;
					SubStr(cBuffer,05,15),;
					SubStr(cBuffer,20,03),;
					SubStr(cBuffer,23,03),;
					SubStr(cBuffer,26,01),;
					SubStr(cBuffer,27,255)})
				EndIf
			EndIf
		Else
			lContinua := .F.
		EndIf
	End
	FClose(nHandle)
EndIf
nHandle := FCreate(cArquivo)
If nHandle > 0
	For nCntFor := 1 To Len(aLayOut)
		Begin Sequence
		lFormula := &(AllTrim(aLayOut[nCntFor,3]))
		If ( lFormula .And. SubStr(aLayOut[nCntFor,1],2,1)=="H" )
			cBuffer := ""
			For nCntFor2 := 1 To Len(aDetalhe)
				If ( aDetalhe[nCntFor2,1] == aLayOut[nCntFor,1] )

					xConteudo := (AllTrim(aDetalhe[nCntFor2,6]))
					nPosIni   := Val(aDetalhe[nCntFor2,3])
					nPosFim   := Val(aDetalhe[nCntFor2,4])
					nDecimal  := Val(aDetalhe[nCntFor2,5])
					nTamanho  := nPosFim-nPosIni+1

					If ( Empty(xConteudo) )
						xConteudo := ""
					Else
						If "NTOTFUNC" $ xConteudo
							aAdd(aTotNeto, {aDetalhe[nCntFor2][3], aDetalhe[nCntFor2][4], aDetalhe[nCntFor2][5], xConteudo, "^", ""})
							xConteudo := &(AllTrim(xConteudo))
							xConteudo := replicate("^", nTamanho)
						Elseif "NTOTAL" $ xConteudo
							aAdd(aTotNeto, {aDetalhe[nCntFor2][3], aDetalhe[nCntFor2][4], aDetalhe[nCntFor2][5], xConteudo, "#", ""})
							xConteudo := &(AllTrim(xConteudo))
							xConteudo := replicate("#", nTamanho)
						Else
							xConteudo := &(AllTrim(xConteudo))
						EndIf
					EndIf

					If "NTOTAL" $ aDetalhe[nCntFor2,6]
						nDecTotal := nDecimal
					EndIF

					Do Case
						Case ValType(xConteudo) == "D"
							xConteudo := GravaData(xConteudo,.F.)
						Case ValType(xConteudo) == "N"
							xConteudo := StrZero(xConteudo,nTamanho,nDecimal)
					EndCase

					xConteudo := SubStr(xConteudo,1,nTamanho)
					xConteudo := PadR(xConteudo,nTamanho)
					cBuffer += xConteudo
				EndIf
			Next nCntFor2
			cBuffer += Chr(13)+Chr(10)
			Fwrite(nHandle,cBuffer,Len(cBuffer))
		EndIf
		End Sequence
	Next nCntFor
	ErrorBlock(bBlock)
Endif
Return(nHandle)

/*/{Protheus.doc} fChkFunc
// Verifica se Funcionário possui Banco/Nro Agência ou Conta Corrente do filtro
// quando usado Grupo de Perguntas GPEM080R2
@author raquel.andrade
@since 20/05/2025
@version P12
@return lRet, Funcionário possui dados de acordo com o filtro
/*/
Static Function fChkFunc(nRecFunc,cBcoFunc, cCtaFunc)
Local aAreaSRA		:= SRA->(GetArea())
Local oStFunc 		:= Nil
Local cAlias		:= GetNextAlias()
Local cQuery		:= ""
Local cQueryFunc	:= ""
Local lRet			:= .F.

Default nRecFunc	:= 0
Default cBcoFunc	:= ""
Default cCtaFunc	:= ""

	If oStFunc == Nil 

		oStFunc 	:= FWPreparedStatement():New()

		cQueryFunc := " SELECT RA_BCDEPSA, RA_CTDEPSA, R_E_C_N_O_  FROM " + RetSqlName("SRA") 
		cQueryFunc += 	" WHERE R_E_C_N_O_ = ? "
		If !Empty(cBcoFunc) 	// Banco/Nro Agência
			cQueryFunc += " AND " + cBcoFunc
		EndIf
		If !Empty(cCtaFunc) // Conta Corrente
			cQueryFunc += " AND " + cCtaFunc
		EndIf
		cQueryFunc +=		  " AND D_E_L_E_T_ = ? "

		cQueryFunc 	:= ChangeQuery(cQueryFunc)		
		oStFunc:SetQuery(cQueryFunc)
		oStFunc:SetString(1,cValToChar(nRecFunc))
		oStFunc:SetString(2,'')

		cQuery := oStFunc:getFixQuery()
		dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAlias,.T.,.T.)

		// Funcionário atende dados do filtro 
		If (cAlias)->(!Eof())
			lRet := .T.
		EndIf

		(cAlias)->(DbCloseArea())

	EndIf

	RestArea(aAreaSRA)

Return lRet

/*/{Protheus.doc} fChkBenef
// Verifica se Beneficiário possui Banco/Nro Agência ou Conta Corrente do filtro
// quando usado Grupo de Perguntas GPEM080R2
@author raquel.andrade
@since 20/05/2025
@version P12
@return lRet, Beneficiário possui dados de acordo com o filtro
/*/
Static Function fChkBenef(nRecBnf,cBcoBnf, cCtaBnf)
Local aAreaSRQ	:= SRQ->(GetArea())
Local oStBenef 	:= Nil
Local cAlias	:= GetNextAlias()
Local cQuery	:= ""
Local cQueryBnf	:= ""
Local lRet		:= .F.

Default nRecBnf	:= 0
Default cBcoBnf	:= ""
Default cCtaBnf	:= ""

	If oStBenef == Nil 

		oStBenef 	:= FWPreparedStatement():New()

		cQueryBnf := " SELECT RQ_BCDEPBE, RQ_CTDEPBE, R_E_C_N_O_  FROM " + RetSqlName("SRQ") 
		cQueryBnf += 	" WHERE R_E_C_N_O_ = ? "
		If !Empty(cBcoBnf) 	// Banco/Nro Agência
			cQueryBnf += " AND " + cBcoBnf
		EndIf
		If !Empty(cCtaBnf) // Conta Corrente
			cQueryBnf += " AND " + cCtaBnf
		EndIf
		cQueryBnf +=		  " AND D_E_L_E_T_ = ? "

		cQueryBnf 	:= ChangeQuery(cQueryBnf)		
		oStBenef:SetQuery(cQueryBnf)
		oStBenef:SetString(1,cValToChar(nRecBnf))
		oStBenef:SetString(2,'')

		cQuery := oStBenef:getFixQuery()
		dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAlias,.T.,.T.)

		// Beneficiário atende dados do filtro 
		If (cAlias)->(!Eof())
			lRet := .T.
		EndIf

		(cAlias)->(DbCloseArea())

	EndIf

	RestArea(aAreaSRQ)

Return lRet
