#INCLUDE "PROTHEUS.CH"
#INCLUDE "FONT.CH"
#INCLUDE "COLORS.CH"
#INCLUDE "GPEM770.CH"
/*/


Ŀ
Funo     GPEM770   Autor  Rogerio Vaz Melonio    Data  22/07/08 
Ĵ
Descrio  Geracao de Informacoes para o Quadro de Pessoal            
Ĵ
 Uso       Generico                                                   
Ĵ
         ATUALIZACOES SOFRIDAS DESDE A CONSTRUAO INICIAL.             
Ĵ
Programador  Data    BOPS   Motivo da Alteracao                     
Ĵ
 Tiago Malta07/01/1000280/ Alterado o uso da variavel cEmpant para  
                      2010 a funo FwCodEmp("SRD").                
 Alex       22/12/1029463/ Atender Nova Interface Totvs 11.5 utili- 
                      2010 zando a funcao MsAdvSize.                
 Tiago Malta27/05/1129463/ Alterado as posies dos objetos usando a
                      2010 funo retcoords.                        
ٱ

/*/
Function GPEM770()
Local nOpca 	:= 0
Local cTabMestra	:= "SRA"				//nome da Tabela Mestra
Local aFilterExp	:=  {} 					//expressao do filtro
Local aRetFiltro							//retorno do filtro
Local bNewFiltro							//bloco para inclusao de novos filtros
Local bAltFilter							//bloco para Alteracao do filtro selecionado
Local bBtnCalcule							//bloco do boto OK
Local bPergunte								//bloco para o pergunte
Local cExpFiltro	:= ""					//variavel com o retorno do filtro
Local cSays			:= OemToAnsi(STR0002)	//"Este programa gera as informaes do Quadro de Pessoal"
Local oDlg
Local oBtnNewFil
Local oBtnAltFil
Local oBtnCalcule
Local oBtnEnd
Local oBtnPergunte
Local lShowDlgFilt	:= .T.					//visualizar a dialog de filtros
Local bDialogInit							//bloco de inicializacao da janela
Local nLinha
Local aAdvSize		:= {}
Local aInfoAdvSize	:= {}
Local aObjSize		:= {}
Local aObjCoords	:= {}
Local aButtons		:= {}
Local bSet15		:= { || NIL }
Local bSet24		:= { || NIL }
Local aRetcoords

Private cTxtFil := ""
Private cAnoMesQP := Space(6)
Private oAnoMes, oTxtFil
Private cPerg := Padr("GPEM770",10)

DEFINE FONT oFont1  NAME "Arial" SIZE 0,-13 BOLD
cBlkGet :=  "{ | u | If( PCount() == 0, cTxtFil,cTxtFil:= u ) }"
cBlKVld :=  "{|| .T. }"
cBlKWhen := "{|| .F. }"

Pergunte(cPerg,.F.)
cAnoMesQP := mv_par01

bDialogInit 	:= { || ;
						Gpem770Arq(	@cTabMestra	,;
									oBtnNewFil	,;
									oBtnAltFil	,;
									oBtnCalcule	,;
									.T.			 ;
								 )								,;	// seta o arquivo Mestre
						Gpem770SetFil(@aFilterExp, cTabMestra)	,;	// Setar as opcoes que filtrara o cadastro de Filtro
						lShowDlgFilt := .F.						,;
						Gpem770Filter( 	aFilterExp	,;
							 			cTabMestra	,;
							 			@cExpFiltro ,;
							 			lShowDlgFil  ;
									),;	// setar o ultimo filtro utilizado
						lShowDlgFilt := .T.;
				   }
Gpem770SetFil(@aFilterExp, cTabMestra)
lShowDlgFilt := .F.
Gpem770Filter(aFilterExp,cTabMestra,@cExpFiltro,lShowDlgFil)
If !Empty(cExpFiltro)
	cTxtFil := Gpem770QbrFil(cExpFiltro)
Endif

/*
Ŀ
 Monta as Dimensoes dos Objetos         					   
*/
aAdvSize		:= MsAdvSize()  
aAdvSize[5]	:=	(aAdvSize[5]/100) * 70	//horizontal
aAdvSize[6]	:=  (aAdvSize[6]/100) * 75	//Vertical
aInfoAdvSize	:= { aAdvSize[1] , aAdvSize[2] , aAdvSize[3] , aAdvSize[4] , 0 , 0 }					 
aAdd( aObjCoords , { 000 , 000 , .T. , .T. } )
aObjSize	:= MsObjSize( aInfoAdvSize , aObjCoords )
//aGdCoord	:= { (aObjSize[1,1]+3), (aObjSize[1,2]+5), (((aObjSize[1,3])/100)*60), (((aObjSize[1,4])/100)*70) }	//1,3 Vertical /1,4 Horizontal
aRetcoords      := RetCoords(3,4,50,15,1,0,,,aAdvSize)

DEFINE MSDIALOG oDlg TITLE OemToAnsi( STR0001 ) From aAdvSize[7],0 TO aAdvSize[6],aAdvSize[5] OF oMainWnd PIXEL // "Gerao do Quadro de Pessoal"
	/*/    
	
	Ŀ
	 Descricao da Janela                                                      
	 */
   	@ aObjSize[1][1]+5 , aObjSize[1][2]+5 TO oDlg:nBottom*0.37,oDlg:nRight*0.49 OF oDlg PIXEL  //@ 11,12 TO 100,245 OF oDlg PIXEL
	@ aRetcoords[1][1] , aRetcoords[1][2] SAY cSays Of oDlg Pixel  FONT oFont1 // "Este programa gera as informaes do Quadro de Pessoal" //@ 20,25
	@ aRetcoords[4][1] , aRetcoords[4][2] SAY STR0005 Of oDlg Pixel FONT oFont1 // "Parametros:"  @ 30,25 
	@ aRetcoords[5][1] , aRetcoords[5][2] SAY STR0035 Of oDlg Pixel FONT oFont1 // "Ano/Mes"   @ 30,73 
	@ aRetcoords[6][1] , aRetcoords[6][2] MsGET oAnoMes VAR cAnoMesQP Picture "@R 9999/99" Size 15,08 When .F. Of oDlg Pixel    //@ 29,110 
	@ aRetcoords[7][1] , aRetcoords[7][2] SAY STR0033 Of oDlg Pixel FONT oFont1 // "Filtro de Funcionrio:"  @ 40,25 
	oTxtFil := TMultiGet():New(aRetcoords[10][1],aRetcoords[10][2],&cBlKGet,oDlg,200,40,,.F.,,,,.T.,,.F.,&(cBlkWhen),.F.,.F.,.F.,&(cBlkVld),,.F.,.F.,.T.)
	/*/
	Ŀ
	 Funcoes em GpFiltro  - Blocos de Execucao dos filtros                    
	 GpFiltro - Chama a janela principal do cadastro de filtros               
	 GpFltAlsGet - Retorna a expressao para elaborar o filtro                 
	*/
	AADD(aButtons, {"LogOcorr" ,{ || GPM770Log() },STR0008,STR0008} )
	AADD(aButtons, {"AltFiltro" ,{ || Gpem770Filter( aFilterExp, cTabMestra, @cExpFiltro, .T. ), Gpem770QbrFil(cExpFiltro),oTxtFil:Refresh() },STR0003,STR0003} )
	AADD(aButtons, {"IncFiltro" ,{ || aRetFiltro := GpFiltro( aFilterExp ) , cExpFiltro := GpFltAlsGet( aRetFiltro , cTabMestra ), Gpem770QbrFil(cExpFiltro),oTxtFil:Refresh() },STR0004,STR0004} )
	AADD(aButtons, {"Parametros" ,{ || Pergunte("GPEM770",.T.), cAnoMesQP := mv_par01, oAnoMes:Refresh() },STR0005,STR0005} )
	
	bSet15		:= { || nOpca := 1, IF( GPM770Ok()( ),oDlg:End(), nOpca:=0 ) }
	bSet24		:= { || oDlg:End() }

ACTIVATE MSDIALOG oDlg CENTERED ON INIT EnchoiceBar( oDlg , bSet15 , bSet24 , NIL , aButtons )


//Ŀ
// Variaveis utilizadas para parametros                         
//
//Ŀ
// mv_par01 - Ano/Mes Referencia                                
//

IF nOpca == 1
	If Empty(cExpFiltro)
		lRet := MsgYesNo(OemToAnsi(STR0010),OemToAnsi(STR0011)) // "Nenhum filtro foi selecionado! Processar toda a tabela?"###"Ateno"
	Else
		lRet := .T.
	EndIf	
	If lRet
		cAnoMesQP := mv_par01
		ProcGpe({|lEnd| GPM770Grava(cExpFiltro,cTabMestra)})  // Chamada do Processamento
	Endif
Endif
Return

/*


ͻ
Funcao    GPM770Log     Autor  Rogerio Melonio    Data   07/08/08  
͹
Desc.     Visualizacao do Relatorio de Log de Processamento.           
͹
Uso        AP                                                          
ͼ


*/
Static Function GPM770Log()
cPathFile := ""
cExtRel := ".##R"
cPathFile := ( __RelDir + "GPEM770" + cExtRel )
If File(cPathFile)
	OurSpool( "GPEM770" )
	Ms_Flush()
Else
	MsgStop(STR0027) // "No existe Log de Processamento para exibir"
Endif

Return

/*


ͻ
Funcao    GPM770Grava   Autor  Rogerio Melonio    Data   07/08/08  
͹
Desc.     Rotina que processa os registros das tabelas SRA e SRD con-  
          forme parametros selecionados                                
͹
Uso        AP                                                          
ͼ


*/
Static Function GPM770Grava(cExpFiltro,cTabMestra)
//Ŀ
// Define Variaveis LOCAIS DO PROGRAMA                          
//
Local nX
Local nA
Local aIndex := {}
Local cChave        
Local cFilRCA	:= xFilial( "RCA" )
Local aMnemos	:= {}

Private aInfo 	:= {}
Private aCodFol	:= {}   // Matriz com Codigo da folha
Private aLog	:= {}
Private aTitle	:= {}
Private aTotRegs:= array(17) // Ajustar o tamanho do array aLogSRA na funcao f770LogSRA() caso aparecam novas ocorrencias
Private aVerba	:= {}
Private cAliasSRD := "SRD"
Private cInfOut := ""
Private cDescri := ""
Private cCodRet := ""
Private aFunc 	:= {}     
Private aPerAtual := {}
Private dUltDia
aFill(aTotRegs,0)
//Ŀ
// Limpar o arquivo do Quadro de Pessoal                                    
// Limpar RGP se forem encontradas informacoes dos funcionarios solicitados.
//Apenas serao limpos os dados dos funcionario selecionados para geracao.   
//
#IFDEF TOP          
	cQuery := "DELETE FROM "+RetSqlName("RGP")+" "
   	cQuery += " WHERE RGP_ANOMES	=  	'" 	+ cAnoMesQP 		+ "'"
	cQuery += " AND EXISTS(" 
	cQuery += " SELECT R_E_C_N_O_ FROM " + RetSqlName("SRA") +""
	cQuery += " WHERE "         
	cQuery += " RA_FILIAL = RGP_FILIAL " 
	cQuery += " AND RA_MAT = RGP_MATRIC "                 
	cQuery += " AND D_E_L_E_T_ = ' ')"
	TcSqlExec(cQuery)
	dbSelectArea("RGP")
	dbCloseArea()
	ChkFile("RGP",.F.)
#ELSE    
	// IMPLEMENTAR LOGICA PARA LIMPEZA CASO SEJA DBF
	// CONFORME DEFINICAO DADA EM 22/08/08, A ROTINA SO DEVE SER DESENVOLVIDA PARA TOP.
	dbSelectArea("RGP")
	dbSetOrder(2) // RGP_FILIAL+RGP_MATRIC+RGP_ANOMES
	dbSelectArea("SRA")
	dbSetOrder(1)
	dbGoTop()
	While SRA->( !EOF()) 
		cCodEsta := Posicione("SQB",1,xFilial("SQB")+SRA->RA_DEPTO,"QB_CESTAB") // Caracter ,4
		cChave	:= SRA->RA_FILIAL+cAnoMesQP+cCodEsta+SRA->RA_CODIRCT+SRA->RA_MAT
		dbSelectArea("RGP")
		If dbSeek( cChave )
			RecLock("RGP",.F.)
			dbDelete()
			MsUnlock()
		Endif
		dbSelectArea("RGP")
		SRA->( dbSkip() )
	EndDo
#ENDIF

Gpem770Verba() // Monta o array aVerba com codigo das verbas que serao consideradas na totalizacao de valores do Quadro de Pessoal

dbSelectArea( "SRD" )
dbSetOrder(1)
dbSelectArea( "SRA" )
dbSetOrder(1)
dbGoTop()
ProcRegua(SRA->(RecCount()))
cAxTabMestra := cTabMestra
If !Empty(cExpFiltro)
	cFilter := cExpFiltro
	If aTotRegs[12] == 0
		cLog := STR0009 // "Filtro da Tabela SRA: "
		Aadd(aTitle,cLog)  
		Aadd(aLog,{})
		aTotRegs[12] := len(aLog)
	EndIf	
	Aadd(aLog[aTotRegs[12]], cExpFiltro ) 
	/*/
	Ŀ
	 Aplicar o filtro na tabela                                   
	*/
	bFiltraBrw 	:= { || FilBrowse( cAxTabMestra, @aIndex , @cFilter ) }
	Eval( bFiltraBrw )
Else
	cFilter := ""
Endif

dDataRef := Stod(cAnoMesQP+"01") // ex.: 2007 10 01
dUltDia	 := LastDate( dDataRef ) // retorna ultimo dia do mes/ano de referencia, ex.: 31/10/2007
/*/
Ŀ
 Inicializa os Mneumonicos Para uso em Formulas			   
/*/
SetMnemonicos( cFilRCA , @aMnemos , .T. )

dbSelectArea(cAxTabMestra)
dbGoTop()
lProcessou := .F.
While SRA->(!Eof()) // .And. SRA->RA_FILIAL <= cFilAte
	lProcessou := .T.
	//Ŀ
	// Movimenta cursor para movimentacao da barra                  
	//
	IncProc(SRA->RA_FILIAL+" - "+SRA->RA_MAT+" - "+SRA->RA_NOME)
	// Efetua validacoes no SRA
	If SRA->RA_ADMISSA > dUltDia // se a data de admissao eh maior que o ultimo dia valido ignora funcionario
		SRA->( dbskip() )
		loop             
	EndIf
 	If !Empty(SRA->RA_DEMISSA) .And. (SRA->RA_DEMISSA < dUltDia) // se foi demitido antes do ultimo dia valido ignora funcionario
		SRA->( dbskip() )
		loop             
	Endif
	// Verifica se o cadastro de funcionario esta com campos obrigatorios para o quadro de pessoal preenchidos.
	// os campos a serem validados conforme o dossie de especificaoces tecnicas de 2007 sao:
	// 1 - "Funcionrio sem Estabelecimento
	// 2 - "Funcionrio sem IRCT
	// 3 - "Funcionrio sem Data de Nascimento
	// 4 - "Funcionrio sem Data de Admisso
	// 5 - "Funcionrio sem Categoria Profissional
	// 6 - "Funcionrio sem Profisso
	// 7 - "Funcionrio sem Formao Escolar
	// 8 - "Funcionrio sem Nacionalidade
	// 9 - "Funcionrio sem Situao Profissional
	cCodEsta := Posicione("SQB",1,xFilial("SQB")+SRA->RA_DEPTO,"QB_CESTAB") // Caracter ,4
	If !Empty(cCodEsta) .And. !Empty(SRA->RA_CODIRCT) .And. !Empty(SRA->RA_NASC) .And. !Empty(SRA->RA_ADMISSA) .And. !Empty(SRA->RA_CODCAT) ;
		.And. !Empty(SRA->RA_CDPROF) .And. !Empty(SRA->RA_HABESCO) .And. !Empty(SRA->RA_NACIONA) .And. !Empty(SRA->RA_SITPROF)
		// se nao ha inconsistencias no cadastro do funcionario
		If aTotRegs[10] == 0
			cLog := STR0025 // "Funcionrios sem inconsistencias."
			Aadd(aTitle,cLog)  
			Aadd(aLog,{})
			aTotRegs[10] := len(aLog)
		EndIf	
		Aadd(aLog[aTotRegs[10]], SRA->RA_FILIAL+"-"+SRA->RA_MAT+ space(02)+SRA->RA_NOME ) 
    Else
		// se ha inconsistencias no cadastro do funcionario registra no Log de Ocorrencias
    	f770LogSRA()
	Endif

	//Ŀ
	// Buscar Valores no Acumulado "SRD"                            
	//
	cMat := SRA->RA_MAT		
	cFil := SRA->RA_FILIAL
	aFunc   	:= {0,0,0,0,0,0} // Vlr Base, Horas Normais, Vlr. Horas Extras, Horas Extras, Premios Regulares, Prestacoes Irregulares
	dbSelectArea("SRD")
	#IFDEF TOP
		lQuery 		:= .T.
		cAliasSRD 	:= "qPessoalSRD"
		aStru  		:= SRD->(dbStruct())
		cQuery 		:= "SELECT * "		
		cQuery 		+= " FROM "+	RetSqlName("SRD")
		cQuery 		+= " WHERE RD_FILIAL  ='" + cFil + "'"
		cQuery 		+= " AND RD_MAT     = '" + cMat+ "'"
		cQuery 		+= " AND RD_ROTEIR IN('FOL','NAT')"
		cQuery 		+= " AND RD_DATARQ = '"+cAnoMesQP+"'"
		cQuery 		+= " AND D_E_L_E_T_ = ' ' "
		cQuery 		+= "ORDER BY "+SqlOrder(SRD->(IndexKey()))
		cQuery := ChangeQuery(cQuery)
		dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasSRD,.T.,.T.)
		For nX := 1 To len(aStru)
			If aStru[nX][2] <> "C" .And. FieldPos(aStru[nX][1])<>0
				TcSetField(cAliasSRD,aStru[nX][1],aStru[nX][2],aStru[nX][3],aStru[nX][4])
			EndIf
		Next nX
		dbSelectArea(cAliasSRD)	
	#ELSE
		cAliasSRD 	:= "SRD"
		(cAliasSRD)->(MsSeek(SRA->RA_FILIAL+SRA->RA_MAT+cAnoMesQP,.T.))
	#ENDIF
    aVerbaDupl := {}
	While (cAliasSRD)->(!Eof()) .And. (cAliasSRD)->RD_FILIAL+(cAliasSRD)->RD_MAT == SRA->RA_FILIAL+SRA->RA_MAT
		//Ŀ
		//Despreza os lanctos sem correspondencia de valor no quadro de pessoal 
		//
      	If Ascan(aVerba,{|X| X[1] == (cAliasSRD)->RD_PD } ) == 0
			(cAliasSRD)->( dbSkip() )
			Loop
		Endif
		//Ŀ
		//Despreza os lanctos de transferencias de outras empresas
		//
      	If (cAliasSRD)->RD_EMPRESA # FwCodEmp("SRD") .And. !Empty((cAliasSRD)->RD_EMPRESA)
			(cAliasSRD)->( dbSkip() )
			Loop
		Endif
		//Ŀ
		//Despreza os tipos de roteiros diferentes de FOL/NAT
		//
		If !( (cAliasSRD)->RD_ROTEIR  $ "FOL/NAT" )
			(cAliasSRD)->( dbSkip() )
			Loop
		EndIf
		If empty((cAliasSRD)->RD_PD)
			If aTotRegs[13] == 0
				cLog := STR0028 // "Lancamento com verba em branco no acumulado.    Filial/Matricula  Competencia            Valor "
				Aadd(aTitle,cLog)  
				Aadd(aLog,{})
				aTotRegs[13] := len(aLog)
			EndIf	      
			Aadd(aLog[aTotRegs[13]],space(49)+(cAliasSRD)->RD_FILIAL+"-"+(cAliasSRD)->RD_MAT+space(08)+substr((cAliasSRD)->RD_DATARQ,5,2)+"/"+substr((cAliasSRD)->RD_DATARQ,1,4) +space(04)+transform((cAliasSRD)->RD_VALOR,"@E 99,999,999,999.99") )
			(cAliasSRD)->( dbSkip() )
			Loop
		EndIf                      
		If empty((cAliasSRD)->RD_DATARQ)
			If aTotRegs[14] == 0
				cLog := STR0029 // "Lancamento com competencia em branco no acumulado.   Filial/Matricula  Verba             Valor"
				Aadd(aTitle,cLog)  
				Aadd(aLog,{})
				aTotRegs[14] := len(aLog)
			EndIf	     
			Aadd(aLog[aTotRegs[14]],space(54)+(cAliasSRD)->RD_FILIAL+"-"+(cAliasSRD)->RD_MAT+space(09)+(cAliasSRD)->RD_PD+space(03)+transform((cAliasSRD)->RD_VALOR,"@E 99,999,999,999.99") )
			(cAliasSRD)->( dbSkip() )
			Loop
		EndIf
		If empty((cAliasSRD)->RD_DATPGT)
			If aTotRegs[15] == 0
				cLog := STR0030 // "Lancamento com data de pagamento em branco no acumulado."
				Aadd(aTitle,cLog)  
				Aadd(aLog,{})
				aTotRegs[15] := len(aLog)
			EndIf	             
			Aadd(aLog[aTotRegs[15]],(cAliasSRD)->RD_FILIAL+"-"+(cAliasSRD)->RD_MAT+"-"+(cAliasSRD)->RD_PD+"-" +transform((cAliasSRD)->RD_VALOR,"@E 99,999,999,999.99") )
			(cAliasSRD)->( dbSkip() )
			Loop
		EndIf
		If Ascan( aVerbaDupl,(cAliasSRD)->(RD_FILIAL+RD_MAT+RD_DATARQ+RD_PD+RD_SEMANA+RD_SEQ+RD_CC+RD_ROTEIR)) == 0
			Aadd(aVerbaDupl,(cAliasSRD)->(RD_FILIAL+RD_MAT+RD_DATARQ+RD_PD+RD_SEMANA+RD_SEQ+RD_CC+RD_ROTEIR))
		Else 
			If aTotRegs[16] == 0
				cLog := STR0031 // "Verba duplicada nos acumulados.    Filial/Matricula   Verba   Competencia             Valor"
				Aadd(aTitle,cLog)  
				Aadd(aLog,{})
				aTotRegs[16] := len(aLog)
			EndIf	             
			Aadd(aLog[aTotRegs[16]],SPACE(35)+(cAliasSRD)->RD_FILIAL+"-"+(cAliasSRD)->RD_MAT+SPACE(10)+(cAliasSRD)->RD_PD+SPACE(05)+substr((cAliasSRD)->RD_DATARQ,5,2)+"/"+substr((cAliasSRD)->RD_DATARQ,1,4)+SPACE(5)+ transform((cAliasSRD)->RD_VALOR,"@E 99,999,999,999.99") )
		EndIf		
		//Ŀ
		//Esta funo buscar os valores das verbas no acumulado,      
		//e suas incidncias, e as guardar no array afun, para gravar 
		//posteriormente na tabelas RGP.                               
		//
		f770MontaDados((cAliasSRD)->RD_PD,xFilial("SRV"))
		(cAliasSRD)->( dbSkip())
	Enddo
	#IFDEF TOP
		dbSelectArea(cAliasSRD)
		dbCloseArea()
	#ENDIF    
	//Ŀ
	//Gravar Quadro de Pessoal        
	//
	FGravaRGP	()
	dbSelectArea("SRA")
	dbSkip()
Enddo
If lProcessou
	If aTotRegs[1] == 0 .and. aTotRegs[2] == 0 .and. aTotRegs[4] == 0 .and. aTotRegs[5]==0 .and. ;
	   aTotRegs[6] == 0 .and. aTotRegs[7] == 0 .and. aTotRegs[8] == 0 
		If aTotRegs[11] == 0
			cLog := STR0012 // "Quadro de Pessoal Gerado com sucesso!"
			Aadd(aTitle,cLog)  
			Aadd(aLog,{})
			aTotRegs[11] := len(aLog)
		EndIf	
		Aadd(aLog[aTotRegs[11]], STR0013 ) // "Nao foi encontrada nenhuma inconsistencia durante a geracao."
	EndIf   
Else
	If aTotRegs[17] == 0
		cLog := STR0014 // "Informacoes para gerar o Quadro de Pessoal."
		Aadd(aTitle,cLog)  
		Aadd(aLog,{})
		aTotRegs[17] := len(aLog)
	Endif
	Aadd(aLog[aTotRegs[17]], STR0034 ) // "No foram encontrados registros para processar com os parmetros/filtro informados"
Endif
If aTotRegs[3] == 0
	cLog := STR0014 // "Informacoes para gerar o Quadro de Pessoal."
	Aadd(aTitle,cLog)  
	Aadd(aLog,{})
	aTotRegs[3] := len(aLog)
EndIf	
fMakeLog(aLog,aTitle,,,"GPEM770",STR0015,"M","P",,.F.) // "Log de ocorrencias do Quadro de Pessoal"
Return Nil

/*


ͻ
Funcao    FGravaRGP Autor  Rogerio Vaz Melonio  Data   19/08/08   
͹
Desc.      Atualiza registro na tabela RGP                            
͹
Uso        AP                                                         
ͼ


*/
Static Function FGravaRGP()            
cCodEsta := Posicione("SQB",1,xFilial("SQB")+SRA->RA_DEPTO,"QB_CESTAB") // Caracter ,4
cChave	:= SRA->RA_FILIAL+cAnoMesQP+cCodEsta+SRA->RA_CODIRCT+SRA->RA_MAT
cTipoContrato := Gpem770Tipoco()
If !Empty(cTipoContrato)
	cTpContrQP := fDescRcc("S011",cTipoContrato,1,2,77,1)
Else
	cTpContrQP := "8"
Endif
dUltPromo := Gpem770DtProm() // Busca data da ultima promocao na tabela SR3
If aFunc[2]-Int(aFunc[2]) <= 0.50
	nHrNormal 	:= Int(aFunc[2])
Else
	nHrNormal 	:= Int(aFunc[2])+1
EndIf			
If aFunc[4]-Int(aFunc[4]) <= 0.50
	nHrSupl 	:= Int(aFunc[4])
Else
	nHrSupl 	:= Int(aFunc[4])+1
EndIf

nPerNormal 	:= SRA->RA_HRSMES * 12 / 52          // Periodo NOrmal de Trabalho 
 

// Configuracao do Controle da Remuneracao Base
If (aFunc[1] > 0 .And. aFunc[2] >= SRA->RA_HRSMES) // remunerao mensal base completa e horas normais correspondentes
	cContrRemu := "0"
ElseIf	(aFunc[2] > 0 .And. aFunc[2] < SRA->RA_HRSMES .And. aFunc[1] > 0) // remunerao mensal base incompleta e horas normais correspondentes
	cContrRemu := "1"
ElseIf	(aFunc[1]+aFunc[5] = 0 .And. aFunc[2] = 0) // sem remunerao mensal base ou qualquer tipo de remunerao e sem horas
	cContrRemu := "2"
ElseIf	(aFunc[1] = 0 .And. aFunc[2] = 0 .And. aFunc[5] > 0) // com remunerao mensal base = 0 e horas normais = 0, mas tendo havido lugar ao pagamento de outro tipo de remuneraes. 
	cContrRemu := "3"
Else
	cContrRemu := ""
Endif
dbSelectArea("RGP")
dbSetOrder(1) // RGP_FILIAL + RGP_ANOMES + RGP_CODEST + RGP_IRCT + RGP_MATRIC
If dbSeek( cChave )
	RecLock("RGP",.F.)
Else
	RecLock("RGP",.T.)
Endif
RGP->RGP_FILIAL   := SRA->RA_FILIAL
RGP->RGP_ANOMES	  := cAnoMesQP
RGP->RGP_CODEST	  := cCodEsta
RGP->RGP_IRCT	  := SRA->RA_CODIRCT
RGP->RGP_MATRIC   := SRA->RA_MAT
RGP->RGP_NOME	  := SRA->RA_NOME
RGP->RGP_ULTPRO	  := dUltPromo
RGP->RGP_CATEGO	  := SRA->RA_CODCAT
RGP->RGP_CODPRO	  := SRA->RA_CDPROF
RGP->RGP_CODNAC	  := SRA->RA_NACIONA
RGP->RGP_CODHAB	  := SRA->RA_HABESCO
RGP->RGP_SITPRO	  := Iif(SRA->RA_SITPROF<='4',SRA->RA_SITPROF,'8')
RGP->RGP_TIPOCO	  := cTpContrQP
RGP->RGP_REGIME	  := SRA->RA_RDURTRA
RGP->RGP_REMUBA	  := aFunc[1]
RGP->RGP_HRNORM	  := nHrNormal
RGP->RGP_TRBSUP	  := aFunc[3]
RGP->RGP_HRSUPL	  := nHrSupl
RGP->RGP_PERNOR	  := nPerNormal
RGP->RGP_CONTRO	  := cContrRemu
RGP->RGP_PREMIO	  := aFunc[5]
RGP->RGP_IRREGU	  := aFunc[6]
MsUnlock()
Return Nil

/*


ͻ
Funcao    f770MontaDados Autor  Rogerio Vaz Melonio  Data 19/08/08
͹
Desc.                                                                 
͹
Uso        AP                                                         
ͼ


*/
Function f770MontaDados(cPD,cCodFil)
Local aArea		:= GetArea()                            
//Ŀ
//Posiciona a Verba no SRV
//
PosSrv(cPd,cCodFil)
If SRV->( eof() ) .and. !empty( cPd )
	If aTotRegs[17] == 0
		cLog := STR0032 // "Verba consta nos acumulados, mas nao consta no cadastro de verbas.   Verba    Competencia             Valor"
		Aadd(aTitle,cLog)  
		Aadd(aLog,{})
		aTotRegs[17] := len(aLog)
	EndIf	     
	Aadd(aLog[aTotRegs[17]],space(70)+cPd+space(06)+substr((cAliasSRD)->RD_DATARQ,5,2)+"/"+substr((cAliasSRD)->RD_DATARQ,1,4) +space(04)+transform((cAliasSRD)->RD_VALOR,"@E 99,999,999,999.99") )
	Return
EndIf
nFator := IIf(SRV->RV_TIPOCOD='1',1,-1)
nVal :=	(cAliasSRD)->RD_VALOR * nFator
If SRA->RA_CATFUNC = 'M' // se eh mensalista converte dias para horas
	nRef := (cAliasSRD)->RD_HORAS * (SRA->RA_HRSMES/30) * nFator
ElseIf SRA->RA_CATFUNC = 'H' // se eh horista 
	nRef := (cAliasSRD)->RD_HORAS * nFator
Else
	nRef := 0
Endif
If SRV->RV_REMUNQP == '01' // Valor Base
	aFunc[1] += nVal // Valor Base 
	aFunc[2] += nRef // Horas Normais ref. ao Valor Base
ElseIf SRV->RV_REMUNQP == '02' // Horas Extras (Trabalho Suplementar)
	aFunc[3] += nVal // Valor de Horas extras
	aFunc[4] += nRef // Horas Extras ref. ao Valor de Horas Extras
ElseIf SRV->RV_REMUNQP == '03' // Premios e Subsidios Regulares
	aFunc[5] += nVal // Valor de Premios e Subsidios Regulares
ElseIf SRV->RV_REMUNQP == '04' // Prestacoes Irregulares
	aFunc[6] += nVal // Valor de Prestacoes Irregulares
Else // Demais verbas que compoem horas do quadro de pessoal
	If SRV->RV_HORASQP == '1' // Se a verba compoe as horas do Quadro de Pessoal
		If SRV->RV_HE = "S"
			aFunc[3] += nVal // Valor de Horas extras
			aFunc[4] += nRef // Horas Extras
		Else
			aFunc[1] += nVal // Valor Base 
			aFunc[2] += nRef // Horas Normais
		Endif
	Endif
Endif
RestArea(aArea)		

Return		


/*


ͻ
Funcao    f770LogSRA     Autor  Rogerio Vaz Melonio  Data 19/08/08
͹
Desc.                                                                 
͹
Uso        Cria Log de Inconsistencia de Funcionario                  
ͼ


*/
Static Function f770LogSRA()
Local aLogSRA := {}
Local nLog
lCodEsta := Empty(Posicione("SQB",1,xFilial("SQB")+SRA->RA_DEPTO,"QB_CESTAB"))
aAdd(aLogSRA,{lCodEsta				,STR0016}) // 1 - "Funcionrio sem Estabelecimento cadastrado."
aAdd(aLogSRA,{Empty(SRA->RA_CODIRCT),STR0017}) // 2 - "Funcionrio sem IRCT cadastrado."
aAdd(aLogSRA,{Empty(SRA->RA_NASC)   ,STR0018}) // 3 - "Funcionrio sem Data de Nascimento cadastrada."
aAdd(aLogSRA,{Empty(SRA->RA_ADMISSA),STR0019}) // 4 - "Funcionrio sem Data de Admisso cadastrada."
aAdd(aLogSRA,{Empty(SRA->RA_CODCAT) ,STR0020}) // 5 - "Funcionrio sem Categoria Profissional cadastrada."
aAdd(aLogSRA,{Empty(SRA->RA_CDPROF) ,STR0021}) // 6 - "Funcionrio sem Profisso cadastrada."
aAdd(aLogSRA,{Empty(SRA->RA_HABESCO),STR0022}) // 7 - "Funcionrio sem Formao Escolar cadastrada."
aAdd(aLogSRA,{Empty(SRA->RA_NACIONA),STR0023}) // 8 - "Funcionrio sem Nacionalidade cadastrada."
aAdd(aLogSRA,{Empty(SRA->RA_SITPROF),STR0024}) // 9 - "Funcionrio sem Situao Profissional cadastrada."
aAdd(aLogSRA,{.F.					,STR0025}) //10 - "Funcionrios sem inconsistencias." (posicao 10 reservada para funcionario OK)
aAdd(aLogSRA,{.F.					,STR0013}) //11 - "Nao foi encontrada nenhuma inconsistencia durante a geracao." (posicao 11 reservada para processamento total OK)
aAdd(aLogSRA,{.F.					,STR0009}) //12 - "Filtro da Tabela SRA: " (posicao 12 reservada para mensagem de filtro)
aAdd(aLogSRA,{.F.					,STR0028}) //13 - "Lancamento com verba em branco no acumulado.    Filial/Matricula  Competencia            Valor "
aAdd(aLogSRA,{.F.					,STR0029}) //14 - "Lancamento com competencia em branco no acumulado.   Filial/Matricula  Verba             Valor"
aAdd(aLogSRA,{.F.					,STR0030}) //15 - "Lancamento com data de pagamento em branco no acumulado."
aAdd(aLogSRA,{.F.					,STR0031}) //16 - "Verba duplicada nos acumulados.    Filial/Matricula   Verba   Competencia             Valor"
aAdd(aLogSRA,{.F.					,STR0034}) //17 - "No foram encontrados registros para processar com os parmetros/filtro informados"
//Ŀ
// A T E N C A O !!!!!!!!!        
//
// se incluir mais elementos no array aLogSRA, corrigir a inicializacao do aTotRegs no inicio da funcao GPM770Grava
For nLog := 1 To Len(aLogSRA)
	If aLogSRA[nLog][1] // se tem inconsistencia no SRA adiciona funcionario ao array de log de ocorrencia
		If aTotRegs[nLog] == 0
			cLog := aLogSRA[nLog][2]
			Aadd(aTitle,cLog)  
			Aadd(aLog,{})
			aTotRegs[nLog] := len(aLog)
		EndIf	
		Aadd(aLog[aTotRegs[nLog]], SRA->RA_FILIAL+"-"+SRA->RA_MAT+ space(02)+SRA->RA_NOME ) 
	Endif
Next
Return

/*


ͻ
Funcao    GPM770Ok  Autor  Microsiga            Data   22/08/08   
͹
Desc.      Exibe confirmacao do processamento                         
͹
Uso        AP                                                         
ͼ


*/
Static Function GPM770Ok()
Return (MsgYesNo(OemToAnsi(STR0026),OemToAnsi(STR0011))) //"Confirma configurao dos parmetros?"###"Ateno"

/*/
Ŀ
Funo    Gpem770FilterAutor Rogerio Vaz Melonio    Data22/08/2008
Ĵ
Descrio Botao de alteracao do filtro                 				
Ĵ
Sintaxe   <Vide Parametros Formais>									
Ĵ
Parametros<Vide Parametros Formais>									
/*/
Function Gpem770Filter(	aFilterExp 	,;		// opcoes do filtro  // MUDEI AQUI
								cTabMestra	,;		// alias do filtro
					 			cExpFiltro	,;		// string com o filtro - passado por referencia
								lShowDlg	 ;		// Se visualiza janela de filtros
					  		 )
Local aRetFiltro 	:= {}
Local aHeader 		:= {}
Local cTxtFil 		:= ""
DEFAULT lShowDlg	:= .T.
/*/
Ŀ
Elabora o cabecalho do arquivo Mestre                 	       
/*/
aHeader := GdMontaHeader(NIL,NIL,NIL,cTabMestra,NIL,.T.,.T.,.F.,.F.,.F.,.F.,.F.)
/*/
Ŀ
Retorna os filtros selecionados                       	       
/*/
aRetFiltro := GpFiltro( aFilterExp, .F. )
/*/
Ŀ
Se for na inicializacao da dialog, nao mostrar a janela       
Caso possua mais de 1 filtro selecionado-retornar filtro Vazio
/*/
If (;
		( Len(aRetFiltro) > 1 );
		.And.;
		( lShowDlg );
	)	
	aRetFiltro := GpFiltro( aFilterExp )
ElseIf (;
			( Len(aRetFiltro) > 1 );
			.And.;
			!( lShowDlg );
		)	
	aRetFiltro := NIL
EndIf
If !Empty(aRetFiltro)
	/*/
	Ŀ
	Retorna a expressao dos filtros                      	       
	/*/
	cExpFiltro := GpFltAlsGet( aRetFiltro , cTabMestra )

	If lShowDlg
		cTxtFil    := GpFltBldDesc( cExpFiltro, @aHeader, cTabMestra )
		/*/
		Ŀ
		Janela para alteracao dos valores do filtro          	       
		/*/
		AltValExp( cTabMestra , @cExpFiltro , @cTxtFil , NIL , aHeader )
	EndIf
EndIf
Return( NIL )

/*/
Ŀ
Funo    Gpem770ArqAutor Rogerio Vaz Melonio       Data22/08/2008
Ĵ
Descrio                                              				
Ĵ
Sintaxe   <Vide Parametros Formais>									
Ĵ
Parametros<Vide Parametros Formais>									
/*/
Function Gpem770Arq(	cTabMestra		,;	// nome do arquivo mestre  // MUDEI AQUI
						oBtnNewFil		,;	// botao de novo filtro
						oBtnAltFil		,;  // botao de alteracao do filtro
						oBtnCalcule		 ;	// botao OK
					  )
Local lBtn		:= .T.
/*/
Ŀ
Ativar / Desativar os botoes conforme arquivo selecionado     
/*/
IF lBtn
	lBtn	:= !Empty( cTabMestra )
EndIF
oBtnNewFil:lActive 	:= lBtn
oBtnAltFil:lActive 	:= lBtn
oBtnCalcule:lActive	:= lBtn
Return( NIL )

/*/
Ŀ
Funo    Gpem770SetFilAutor Rogerio Vaz Melonio    Data22/08/2008
Ĵ
Descrio Setar as opcoes do Filtro									
Ĵ
Sintaxe   <Vide Parametros Formais>									
Ĵ
Parametros<Vide Parametros Formais>									
/*/
Function Gpem770SetFil( aFilterExp , cTabMestra )
Local aGrpUsr		:= {}	// Grupo dos Usuarios
Local cGrpUsr		:= ""	// string com o Grupo de usuario
Local nLoop			:= 0	
aAdd( aFilterExp , { "FILTRO_ALS" , cTabMestra 	, NIL , NIL    } )
/*/		
Ŀ
 Localizar os grupos a que o usuario pertence                             
 */
aGrpUsr := UsrRetGrp( SubStr( cUsuario , 7 , 15 ) )
For nLoop := 1 To Len(aGrpUsr)
	cGrpUsr := aGrpUsr[nLoop]
	aAdd( aFilterExp , { "FILTRO_GRP" , cGrpUsr 	, NIL , NIL    } )
Next nLoop
Return( NIL )
 
/*/
Ŀ
Funo    Gpem770Verba Autor Rogerio Vaz Melonio    Data22/08/2008
Ĵ
Descrio Inicializa o array de Verbas   								
Ĵ
Sintaxe   <Vide Parametros Formais>									
Ĵ
Parametros<Vide Parametros Formais>									
/*/
Function Gpem770Verba()
dbSelectArea("SRV")
dbGoTop()
While ! Eof()
	If !SRV->RV_TIPOCOD $ '1/2' // Se nao eh provento nem desconto, desconsidera a verba
		dbSkip()
		Loop
	Endif
	If (Empty(SRV->RV_REMUNQP) .And. Empty(RV_HORASQP)) // Se nao entra em remuneracao ou horas do quadro de pessoal, desconsidera a verba
		dbSkip()
		Loop
	Endif
	aAdd(aVerba,{SRV->RV_COD})
	dbSkip()
EndDo

/*/
Ŀ
Funo    Gpem770TipocoAutor Rogerio Vaz Melonio    Data22/08/2008
Ĵ
Descrio Retorna o tipo de contrato vigente na data do parametro		
Ĵ
Sintaxe   <Vide Parametros Formais>									
Ĵ
Parametros<Vide Parametros Formais>									
/*/
Function Gpem770Tipoco()
cMat := SRA->RA_MAT		
cFil := SRA->RA_FILIAL
dbSelectArea("RGE")
dbSetOrder(2) // ordem por RGE_FILIAL+RGE_MAT+DTOS(RGE_DATAIN)+RGE_TIPOCO
#IFDEF TOP
	lQuery 		:= .T.
	cAliasRGE 	:= "qPessoalRGE"
	cQuery 		:= "SELECT RGE_TIPOCO,MAX(RGE_DATAIN)"
	cQuery 		+= " FROM "+	RetSqlName("RGE")
	cQuery 		+= " WHERE RGE_FILIAL  ='" + cFil + "'"
	cQuery 		+= " AND RGE_MAT = '" + cMat+ "'"
	cQuery 		+= " AND RGE_DATAIN < '" + Dtos(dUltDia) + "'"
	cQuery 		+= " AND D_E_L_E_T_ = ' ' "
	cQuery 		+= " GROUP BY RGE_MAT,RGE_TIPOCO"
	cQuery := ChangeQuery(cQuery)
	dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasRGE,.T.,.T.)
	dbSelectArea(cAliasRGE)	
#ENDIF
#IFNDEF TOP
	cAliasRGE 	:= "RGE"
	(cAliasRGE)->(MsSeek(SRA->RA_FILIAL+SRA->RA_MAT+cAnoMesQP,.T.))
#ENDIF

If !Eof()                                                                      
	cTipoContrato := (cAliasRGE)->(RGE_TIPOCO)
Else
	cTipoContrato := ""
Endif
#IFDEF TOP
	dbCloseArea()
#ENDIF
Return(cTipoContrato)

/*/
Ŀ
Funo    Gpem770DtPromAutor Rogerio Vaz Melonio    Data22/08/2008
Ĵ
Descrio Retorna o tipo de contrato vigente na data do parametro		
Ĵ
Sintaxe   <Vide Parametros Formais>									
Ĵ
Parametros<Vide Parametros Formais>									
/*/
Function Gpem770DtProm()
cMat := SRA->RA_MAT		
cFil := SRA->RA_FILIAL
cTipoProm := "'%"+AllTrim(P_TPPROQP)+"%'"
dbSelectArea("SR3")
dbSetOrder(1) // ordem por R3_FILIAL+R3_MAT+DTOS(R3_DATA)+R3_TIPO+R3_PD
#IFDEF TOP
	lQuery 		:= .T.
	cAliasSR3 	:= "qPessoalSR3"
	cQuery 		:= "SELECT R3_MAT,MAX(R3_DATA) DATAPROM"
	cQuery 		+= " FROM "+RetSqlName("SR3")
	cQuery 		+= " WHERE R3_FILIAL  ='" + cFil + "'"
	cQuery 		+= " AND R3_MAT     = '" + cMat+ "'"
	cQuery 		+= " AND R3_DATA < '" + dTos(dUltDia) + "'"
	cQuery 		+= " AND R3_TIPO LIKE " + cTipoProm
	cQuery 		+= " AND D_E_L_E_T_ = ' ' "
	cQuery 		+= " GROUP BY R3_MAT"
	cQuery := ChangeQuery(cQuery)
	dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasSR3,.T.,.T.)
	dbSelectArea(cAliasSR3)	
#ENDIF
#IFNDEF TOP
	cAliasSR3 	:= "SR3"
	(cAliasSR3)->(MsSeek(SRA->RA_FILIAL+SRA->RA_MAT+cAnoMesQP,.T.))
#ENDIF

If !Eof()
	#IFDEF TOP
		dUltPromo := Stod((cAliasSR3)->(DATAPROM))
	#ELSE
		dUltPromo := (cAliasSR3)->R3_DATA
	#ENDIF
Else
	dUltPromo := cTod("  /  /  ")
Endif
#IFDEF TOP
	dbCloseArea()
#ENDIF
Return(dUltPromo)

/*/
Ŀ
Funo    Gpem770QbrFilAutor Rogerio Vaz Melonio    Data22/08/2008
Ĵ
Descrio Retorna o texto do filtro qubrado em linhas            		
Ĵ
Sintaxe   <Vide Parametros Formais>									
Ĵ
Parametros<Vide Parametros Formais>									
/*/
Function Gpem770QbrFil(cExpFiltro)
nLinha := 1
nStrFil := 1
cTxtFil := ""
While nStrFil <= Len(cExpFiltro)
	If nLinha > 5
		Exit
	Endif
	cTxtFil += Substr(cExpFiltro,nStrFil,80)+Chr(13)
	nStrFil+=80  
	nLinha++
EndDo
While nLinha <= 5
	cTxtFil += Chr(13)
	nLinha++
EndDo
Return(cTxtFil)