#INCLUDE "GPEXCALC.CH"
#INCLUDE "PROTHEUS.CH"

Static aCriterio 	:= {}
Static aFaltas		:= {}
Static aConvoc 		:= {}
Static aSLYAlias
Static aM7Inativ 
Static cTipoCri		:= ""
Static cNroPed		:= ""
Static cFilPed      := ""
Static cRI1Tab
Static cSLYTipo
Static lUsaCPer		:= GetMvRH("MV_USACPER",, .F.) //.T.=Usa periodo folha/.F.= usa calendario ponto
Static lUsaGS       := GetMvRH("MV_TECXRH", NIL, .F. )
Static lGp210Sal
Static lGPM5001
Static lGPVALDias
Static lGPVRFDias
Static lGPVTRDias
Static nFaltasAut	:= 0 // Dias de falta para o cálculo automático
Static nDiasRef		:= 0 // Dias de referência para VA e VR
Static nTamPed 		:= GetSx3Cache( "R0_NROPED", "X3_TAMANHO" )
Static __lMemCalc
Static lGPM19RGB 
Static lTemCCT
Static lTemPagFal
Static lTemRecalc
Static lTemRU1
Static lTemSldAnt
Static lVlMinMax
Static lOtbCCT
Static _oPS1
Static lTemQtVD
Static nOrderSR0
Static lTamRU1VL
Static lCpoSts

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³			ATUALIZACOES SOFRIDAS DESDE A CONSTRU€AO INICIAL.			  			³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Programador ³ Data	³ FNC			 ³  Motivo da Alteracao 					³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Flavio Corre³25/02/15³PCREQ-2898      ³Inclusao fonte							³±±
±±³Allyson M.  ³04/03/15³TRIA28    		 ³Ajuste em fMedia13() p/ verificar se e'   ³±±
±±³            ³        ³          		 ³complemento de 13o.    					³±±
±±³Mariana M.  ³04/09/15³TSZLXV    		 ³Ajuste em fVTRCalc() p/ quando percentual ³±±
±±³            ³        ³          		 ³for diferente de 6%. Sistema irá respeitar³±±
±±³            ³        ³          		 ³o que foi informado no cadastro da verba. ³±±
±±³            ³        ³          		 ³Também foi ajustado o sistema para quando ³±±
±±³            ³        ³          		 ³possuir sábados como não trabalhados, mas ³±±
±±³            ³        ³          		 ³a empresa para o VT para os funcionários, ³±±
±±³            ³        ³          		 ³o sistema terá que calcular a quantidade  ³±±
±±³            ³        ³          		 ³de Dias Uteis de VT e Não Uteis de VT cor-³±±
±±³            ³        ³          		 ³retamente.								³±±
±±³Allyson M.  ³19/10/15³TTQ964    		 ³Ajuste em fVRFCalc() p/ considerar os dias³±±
±±³            ³        ³          		 ³de VR que sao no sabado/domingo			³±±
±±³Renan Borges³14/12/15³TTUHKO    		 ³Ajuste no cálculo de VT quando há dias fi-³±±
±±³            ³        ³          		 ³xos cadastrados no meio de VT.            ³±±
±±³Christiane V.³06/11/15³TTSM85         ³Ajuste na FCalcDSR para considerar a data ³±±
±±³             ³        ³               ³de admissao ao pesquisar os dias de DSR   ³±±
±±³             ³        ³               ³somente no mes de admissao do funcionario.³±±
±±³Allyson M.   ³11/12/15³TU9321         ³Ajuste na validacao dos dias afastados    ³±±
±±³             ³        ³               ³quando for calculo do dissidio            ³±±
±±³Allyson M.   ³11/12/15³TU9321         ³Ajuste em fVTRCalc() p/ nao descontar     ³±±
±±³             ³        ³               ³o VT de funcionario estagiario.           ³±±
±±³Renan Borges ³18/12/15³TUBRN8		 ³Ajuste para fechar alias temporario aberto³±±
±±³Allyson M.   ³24/12/15³TTZEZ2         ³Ajuste em fVlsAus() e em fVTRCalc() p/ nao³±±
±±³             ³        ³               ³calcular VT p/ funcionario afastado no    ³±±
±±³             ³        ³               ³periodo inteiro    						³±±
±±³Ricardo D.  ³19/12/15³TUCIXY		     ³Arredondamento no calculo de Vale Alimen- ³±±
±±³            ³        ³          		 ³tacao e Refeicao nas funcoes FVRFCALC e   ³±±
±±³            ³        ³          		 ³FVALCALC								    ³±±
±±³Eduardo F.  ³05/05/16³TUVDWU		     ³Ajuste para que na integração da rotina   ³±±
±±³            ³        ³          		 ³BEN não duplicar o valor.                 ³±±
±±³Raquel Hager³17/05/16³TUYLIQ		     ³Ajuste na função fValCalc p/ contabilizar ³±±
±±³            ³        ³          		 ³qualquer dia desde que seja trabalhado.   ³±±
±±³Allyson M.  ³23/06/16³TVJ289          ³Ajuste em fVlsAus() p/ guardar os dias de ³±±
±±³            ³        ³                ³ferias p/ gravacao correta no cabecalho   ³±±
±±³Gabriel A.  ³24/06/16³TVGZA5          ³Ajuste para zerar o valor da empresa      ³±±
±±³            ³        ³                ³quando o valor do benefício for zero.     ³±±
±±³Esther V.   ³27/06/16³	   TVIAMO    ³Ajuste na gravacao do campo R0_DIASPRO no ³±±
±±³            ³        ³          		 ³calculo de VR/VA quando há calculo propor-³±±
±±³            ³        ³          		 ³cional.									³±±
±±³Allyson M.  ³12/07/16³TURHSE          ³Ajuste p/ desconto do VT p/ verificar as  ³±±
±±³            ³        ³                ³verbas que serão somadas ao salário       ³±±
±±³Allyson M.  ³12/08/16³TURHSE          ³Ajuste p/ desconto do VT p/ verificar a   ³±±
±±³            ³        ³                ³garantia de comissão       				³±±
±±³Raquel Hager³12/08/16³TURHSE          ³Ajuste nas funções fCrgAutom e fCrgBenAut ³±±
±±³            ³        ³                ³para cálculo automático de Benefícios em  ³±±
±±³            ³        ³                ³ambiente com Gestão de Serviços para consi³±±
±±³            ³        ³                ³derar os dias de cálculo conforme cadastro³±±
±±³Allyson M.  ³20/09/16³TVYDXQ          ³Ajuste p/ verificar corretamente os bene- ³±±
±±³            ³        ³                ³fícios quando há integração com gestão de ³±±
±±³            ³        ³                ³serviços 									³±±
±±³Raquel Hager³27/09/16³TWCLU0          ³Realizado ajuste para pagamento devido da ³±±
±±³            ³        ³                ³parte empresa conforme configurações da   ³±±
±±³            ³        ³                ³definição de benefício.                   ³±±
±±³Claudinei S.³05/10/16³TVQFFA          ³Ajuste na função fAuxCre() para calcular o³±±
±±³            ³        ³                ³auxílio-creche com retenção de IR no novo ³±±
±±³            ³        ³                ³ID de cálculo 1414, conforme a tabela S015³±±
±±³Cícero Alves³19/10/16³TWGETX          ³Ajuste na função fVlsRGB para procurar as ³±±
±±³            ³        ³                ³faltas na RGB com o período do roteiro que³±±
±±³            ³        ³                ³está sendo executado						³±±
±±³Leandro Dr. ³01/12/16³98909           ³Ajuste para pagar todos os dias de VR e VA³±±
±±³            ³        ³                ³que estejam definidos no cadastro de perio³±±
±±³            ³        ³                ³do para ser pago, mesmo feriados.			³±±
±±³Renan Borges³05/12/16³MRH-2368        ³Ajuste para descontar faltas de acordo com³±±
±±³            ³        ³                ³Mnemonico P_BENBUSFA.                     ³±±
±±³Allyson M.  ³28/12/16³MRH-2534        ³Ajuste em fCargaRI1() p/ validar as datas ³±±
±±³            ³        ³                ³de inícios e fim corretamente.			³±±
±±³Allyson M.  ³28/12/16³MRH-3331        ³Ajuste em fVTRCalc() p/ sempre gravar o   ³±±
±±³            ³        ³                ³cálculo de VT.							³±±
±±³Raquel Hager³04/01/16³MRH-4035        ³Ajuste em fOtbCalc p/ validar Demissão do ³±±
±±³            ³        ³                ³funcionário no cálculo de Oturos Benef.	³±±
±±³Raquel Hager³19/01/16³MRH-5140        ³Ajuste em fVTRCalc p/ considerar qtde de  ³±±
±±³            ³        ³                ³vales por dia util no cálc. de Dif. VTR. e³±±
±±³            ³        ³                ³o valor já custeado pelo funcionário.   	³±±
±±³Renan Borges³19/01/16³MRH-5185		 ³Ajuste para não gerar error.log quando ca-³±±
±±³            ³        ³          		 ³lendário for sintético (MV_TPCALEN).      ³±±
±±³Allyson M.  ³20/01/17³MRH-825         ³Ajuste p/ considerar o ID 0242 p/ desconto³±±
±±³            ³        ³                ³das faltas e p/ não considerar os dias de	³±±
±±³            ³        ³                ³férias programadas se já considerou os das³±±
±±³            ³        ³                ³férias calculadas							³±±
±±³Cícero Alves³08/06/17³DRHPAG-2445	 ³Alteração na fVTRSal para considerar a	³±±
±±³            ³        ³                ³verba de salário horista quando lançada na³±±
±±³            ³        ³                ³RGB em vez dasa horas no cadastro de		³±±
±±³            ³        ³                ³funcionários								³±±
±±³Cecília C.  ³22/06/17³DRHPAG-3454     ³Alteração na fAuxCre para acessar o regis-³±±
±±³            ³        ³                ³tro da tabela S015 correta.               ³±±
±±³Cecília C.  ³04/07/17³DRHPAG-3753     ³Ajuste em fAuxCre para não ocorrer error.³±±
±±³            ³        ³                ³log em fPosTab e acessar a tabela S015 cor³±±
±±³            ³        ³                ³retamente.                                ³±±
±±³Cecília C.  ³28/07/17³DRHPAG-4463     ³Ajuste em para calcular VA/VR/VT não pro- ³±±
±±³            ³        ³                ³porcional quando utiliza calendário sinté-³±±
±±³            ³        ³                ³tico.                                     ³±±
±±³Esther V.   ³03/10/17³DRHPAG-6110     ³Verifica se funcionario está demitido no  ³±±
±±³            ³        ³                ³período de cálculo.                       ³±±
±±³Isabel N.   ³17/10/17³DRHPAG-6790     ³Ajuste no PE GPVTRDIAS.                   ³±±
±±³Jaqueline L ³15/12/17³DRHPAG-7346     ³Inclusão do PE GPM5001                    ³±±
±±³Jaqueline L ³15/12/17³DRHPAG-7670     ³Quando preenchido o R0_DPROPIN deverá ser ³±±
±±³            ³        ³  				 ³considerado ao invés do RFO_DIAFIX NO vr	³±±
±±³Jaqueline L ³20/12/17³DRHPAG-7941     ³Verifico se o funcionário é comissionado  ³±±
±±³            ³        ³  				 ³se for, atualizo o custo com base no 		³±±
±±³            ³        ³  				 ³RCE_GCOMIS do sindicato do funcionáio 	³±±
±±³Jaqueline L ³07/02/18³DRHPAG-12323    ³Quando preenchido o R0_DPROPIN deverá ser ³±±
±±³            ³        ³  				 ³considerado ao invés do RFO_DIAFIX no VA  ³±±
±±³Jaqueline L ³08/02/18³DRHPAG-12906    ³Correção para quando o R0_DPROPIN não est ³±±
±±³            ³        ³  				 ³iver preenchido e o dias fixo sim, manter ³±±
±±³            ³        ³  				 ³os dias fixo     							³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³ fAssMed2 ºAutor  ³ Adilson Silva      º Data ³ 01/11/2009  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Novo Calculo da Assistencia Medica.                        º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ P11                                                        º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function fAssmed2(aCodFol)

 // Valores de Desconto
 Local nMedTit  := 0
 Local nMedDep  := 0
 Local nMedAgr  := 0

 // Valores da Parte Empresa
 Local nEmprTit := 0
 Local nEmprDep := 0
 Local nEmprAgr := 0

 // Bases p/ Calculo
 Local nBaseTit := 0
 Local nBaseDep := 0
 Local nBaseAgr := 0

 // Percentuais de Calculo do Desconto
 Local nPercTit := 0
 Local nPercDep := 0
 Local nPercAgr := 0

 // Quantidades Processadas - Funcionario / Dependentes / Agregados
 Local nQdeTit  := 0
 Local nQdeDep  := 0
 Local nQdeAgr  := 0

 // Variaveis Totalizadoras
 Local nDesc    := 0
 Local nRef     := 0
 Local nEmpr    := 0

 // Verbas Utilizadas no Calculo
 Local cPdDescTit
 Local cPdDescDep
 Local cPdDescAgr
 Local cPdEmprTit
 Local cPdEmprDep
 Local cPdEmprAgr
 Local nBusca, cTab, nLinha

 Local aPdDescDep := {}
 Local nX := 0
 Local dDataCalc
 Local nUltDia
 Local cIdadeDesc    := SuperGetMv( "MV_PLSBASI",, "1" )

If !FP_CODFOL(@aCodFol,SRA->RA_FILIAL)
	Return
EndIf

cPdDescTit := aCodFol[049,1]		//-- Assistencia Medica
cPdDescDep := aCodFol[723,1]		//-- Desc.Ass.Medica Dependentes
cPdDescAgr := aCodFol[724,1]		//-- Desc.Ass.Medica Agregados
cPdEmprTit := aCodFol[213,1]		//-- Base parte Empresa Assist.Medica
cPdEmprDep := aCodFol[725,1]		//-- Base parte Empresa Ass.Medica Dependentes
cPdEmprAgr := aCodFol[726,1]		//-- Base parte Empresa Ass.Medica Agregados


 If aCodFol[49,1] # Space( 03 ) .And. SRA->RA_ASMEDIC # Space( 02 )
    If ( c__Roteiro == "RES" .And. ( cCompl # "S" .Or. ( cCompl == "S" .And. MesAno(GetMemVar("RG_DATADEM")) == MesAno(GetMemVar("RG_DTGERAR")) ) .And. aIncRes[11] == "S")) .Or. ;
       ( c__Roteiro == "FOL" .And. ( SRA->RA_TIPOPGT # "S" .Or. ( SRA->RA_TIPOPGT == "S" .And. lUltSemana)) )

	   // Busca salário mês correspondente
	   If (SRA->RA_CATFUNC = "H")
       		nBusca := SRA->RA_HRSMES * SRA->RA_SALARIO
       Else
	   		nBusca := SALMES
	   EndIf

       // Busca Tabela Relacionada
       cTab   := "S008"
       If SRA->RA_TIPAMED == "2"
          nBusca := Val( Left(cFolMes,4) ) - Year( SRA->RA_NASC )
          cTab   := "S009"
          If Month( SRA->RA_NASC ) >  Val( Right(cFolMes,2) ) .OR. ( cIdadeDesc == "2" .AND. ( Month( SRA->RA_NASC ) ==  Val( Right(cFolMes,2) )))
             nBusca--
          EndIf
       EndIf

       // Calculo da Assistencia Medica
       If ( nLinha := fPosTab(cTab,SRA->RA_ASMEDIC,"=",4,nBusca,"<=",6) ) > 0
          nBaseTit := fTabela(cTab,nLinha,7)
          nPercTit := fTabela(cTab,nLinha,10) / 100

          nMedTit  := nBaseTit * nPercTit

          nEmprTit := nBaseTit - nMedTit
          nQdeTit ++


          If lDissidio
           	 dDataCalc := dDatabase
          Else
             nUltDia:= f_UltDia(CToD("01"+"/"+Substr(cFolMes,5,2)+"/"+Substr(cFolMes,1,4)))   //Ultimo dia do Mes
		 	 dDataCalc:= CToD(StrZero(nUltDia,2)+"/"+Substr(cFolMes,5,2)+"/"+Substr(cFolMes,1,4))
          EndIf
          SRB->(dbSetOrder( 1 ))
          SRB->(dbSeek( SRA->(RA_FILIAL + RA_MAT) ))
          Do While !(SRB->(Eof())) .And. SRB->(RB_FILIAL + RB_MAT) == SRA->(RA_FILIAL + RA_MAT)
				If 	(!Empty(SRB->RB_DTINIAM) .or. !Empty(SRB->RB_DTFIMAM))

						If (!Empty(SRB->RB_DTINIAM) .and. dDataCalc < SRB->RB_DTINIAM) .or.;
						   (!Empty(SRB->RB_DTFIMAM) .and. dDataCalc > SRB->RB_DTFIMAM)
							SRB->(dbSkip())
							Loop
						EndIf
				EndIf

		   	If (cPaisLoc == "BRA")
		   		aAdd(aPdDescDep,{SRB->RB_VBDESAM,0,,1})
		   	EndIf


             // Busca Tabela Relacionada
             nBusca := SALMES
             cTab   := "S008"
             If SRB->RB_TIPAMED == "2"
                nBusca := Val( Left(cFolMes,4) ) - Year( SRB->RB_DTNASC )
                cTab   := "S009"
                If Month( SRB->RB_DTNASC ) >  Val( Right(cFolMes,2) ) .OR. ( cIdadeDesc == "2" .AND. ( Month( SRB->RB_DTNASC ) ==  Val( Right(cFolMes,2) )))
                   nBusca--
                EndIf
             EndIf

             // Calculo da Assistencia Medica
             If ( nLinha := fPosTab(cTab,SRB->RB_CODAMED,"=",4,nBusca,"<=",6) ) > 0
                nBaseDep := fTabela(cTab,nLinha,8)
                nBaseAgr := fTabela(cTab,nLinha,9)
                nPercDep := fTabela(cTab,nLinha,11) / 100
                nPercAgr := fTabela(cTab,nLinha,12) / 100

                If SRB->RB_TPDEPAM == "1"
	               If (cPaisLoc == "BRA")
	                   aPdDescDep[Len(aPdDescDep),2] := nBaseDep * nPercDep
	                   aPdDescDep[Len(aPdDescDep),3] := "1"	//significa que é Dependente
	               EndIf
                   nMedDep  += nBaseDep * nPercDep
                   nEmprDep += nBaseDep - ( nBaseDep * nPercDep )
                   nQdeDep ++
                ElseIf SRB->RB_TPDEPAM == "2"
                   If (cPaisLoc == "BRA")
	                   aPdDescDep[Len(aPdDescDep),2] := nBaseAgr * nPercAgr
	                   aPdDescDep[Len(aPdDescDep),3] := "2"	//significa que é Agregado
                   EndIf
                   nMedAgr  += nBaseAgr * nPercAgr
                   nEmprAgr += nBaseAgr - ( nBaseAgr * nPercAgr )
                   nQdeAgr ++
                EndIf
             EndIf

             SRB->(dbSkip())
          EndDo
       EndIf
    EndIf
 EndIf

 If nMedTit + nMedDep + nMedAgr + nEmprTit + nEmprDep + nEmprAgr > 0
	//Verificar se o valor calculado é superior ao limite para desconto.
	//Caso o valor seja superior, os valores de descontos serão alterados para atingir o Limite de Desconto.
	//A alteração será na seguinte ordem: 1- Agregado / 2- Dependente / 3- Titular

    nDesc += nMedTit
    nRef  += nQdeTit
    nEmpr += nEmprTit

    // Soma Desconto dos Dependentes Caso Nao Tenha Identificador Especifico Cadastrado
//    If Empty( cPdDescDep )
//       nDesc += nMedDep
//       nRef  += nQdeDep
//    EndIf

    // Soma Desconto dos Agregados Caso Nao Tenha Identificador Especifico Cadastrado
//    If Empty( cPdDescAgr )
//       nDesc += nMedAgr
//       nRef  += nQdeAgr
//    EndIf

    // Soma Parte Empresa dos Dependentes Caso Nao Tenha Identificador Especifico Cadastrado
    If Empty( cPdEmprDep )
       nEmpr += nEmprDep
    EndIf

    // Soma Parte Empresa dos Agregados Caso Nao Tenha Identificador Especifico Cadastrado
    If Empty( cPdEmprAgr )
       nEmpr += nEmprAgr
    EndIf

    // Grava Desconto
    If nDesc > 0
       If cPaisLoc == "BRA"
          If ! (( Ascan(aPd,{|X| X[1] == cPdDescTit .And. X[9] <> "D" .And. X[7] == "I"}) > 0 ) )
          		fGeraVerba(cPdDescTit,nDesc,nRef)
          EndIf
       Else
       		fGeraVerba(cPdDescTit,nDesc,nRef,,,,,,,,.T.)
       EndIf
    EndIf
    // Grava Parte Empresa
    If nEmpr > 0
	   If cPaisLoc == "BRA"
          If ! (( Ascan(aPd,{|X| X[1] == cPdEmprTit .And. X[9] <> "D" .And. X[7] == "I"}) > 0 ) )
          		fGeraVerba(cPdEmprTit,nEmpr)
          EndIf
       Else
	       fGeraVerba(cPdEmprTit,nEmpr,,,,,,,,,.T.)
	   EndIf
    EndIf
    If (cPaisLoc == "BRA")
	    // Grava Desconto dos Dependentes
	    If nMedDep > 0
			For nX := 1 to Len(aPdDescDep)
				If aPdDescDep[nX,3] == "1"	//significa que é Dependente
					If cPaisLoc == "BRA"
				          If ! (( Ascan(aPd,{|X| X[1] == aPdDescDep[nX,1] .And. X[9] <> "D" .And. X[7] == "I"}) > 0 ) )
				          		fGeraVerba(aPdDescDep[nX,1],aPdDescDep[nX,2],aPdDescDep[nX,4])
				          EndIf
			       	Else
					fGeraVerba(aPdDescDep[nX,1],aPdDescDep[nX,2],aPdDescDep[nX,4],,,,,,,,.T.)
					EndIf
		  		EndIf
	  		Next nX
	    EndIf
    EndIf
    // Grava Parte Empresa dos Dependentes
    If !Empty( cPdEmprDep ) .And. nEmprDep > 0
    	If cPaisLoc == "BRA"
			If ! (( Ascan(aPd,{|X| X[1] == cPdEmprDep .And. X[9] <> "D" .And. X[7] == "I"}) > 0 ) )
				fGeraVerba(cPdEmprDep,nEmprDep)
			EndIf
		Else
       		fGeraVerba(cPdEmprDep,nEmprDep,,,,,,,,,.T.)
       	EndIf
    EndIf
    If (cPaisLoc = "BRA")
	    // Grava Desconto dos Agregados
	    If nMedAgr > 0
			For nX := 1 to Len(aPdDescDep)
				If aPdDescDep[nX,3] == "2"	//significa que é Agregado
					If cPaisLoc == "BRA"
						If ! (( Ascan(aPd,{|X| X[1] == aPdDescDep[nX,1] .And. X[9] <> "D" .And. X[7] == "I"}) > 0 ) )
							fGeraVerba(aPdDescDep[nX,1],aPdDescDep[nX,2],aPdDescDep[nX,4])
						EndIf
					Else
					fGeraVerba(aPdDescDep[nX,1],aPdDescDep[nX,2],aPdDescDep[nX,4],,,,,,,,.T.)
					EndIf
		  		EndIf
	  		Next nX
	    EndIf
    EndIf
    // Grava Parte Empresa dos Agregados

    If !Empty( cPdEmprAgr ) .And. nEmprAgr > 0
    	If cPaisLoc == "BRA"
			If ! (( Ascan(aPd,{|X| X[1] == cPdEmprAgr .And. X[9] <> "D" .And. X[7] == "I"}) > 0 ) )
				fGeraVerba(cPdEmprAgr,nEmprAgr)
			EndIf
		Else
       		fGeraVerba(cPdEmprAgr,nEmprAgr,,,,,,,,,.T.)
       	EndIf
    EndIf
 EndIf

Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³ fAssOdon ºAutor  ³ Renata Bueno       º Data ³ 18/11/2009  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Calculo da Assistencia Odontologica.                       º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ P11                                                        º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function fAssOdon(aCodfol)

 // Valores de Desconto
 Local nOdonTit := 0
 Local nOdonDep := 0
 Local nOdonAgr := 0

 // Valores da Parte Empresa
 Local nEmprTit := 0
 Local nEmprDep := 0
 Local nEmprAgr := 0

 // Bases p/ Calculo
 Local nBaseTit := 0
 Local nBaseDep := 0
 Local nBaseAgr := 0

 // Percentuais de Calculo do Desconto
 Local nPercTit := 0
 Local nPercDep := 0
 Local nPercAgr := 0

 // Quantidades Processadas - Funcionario / Dependentes / Agregados
 Local nQdeTit  := 0
 Local nQdeDep  := 0
 Local nQdeAgr  := 0

 // Variaveis Totalizadoras
 Local nDesc    := 0
 Local nRef     := 0
 Local nEmpr    := 0

 // Verbas Utilizadas no Calculo
 Local cPdDescTit := aCodFol[714,1]		//-- Desconto Assist.Odontologica Titular
 Local cPdEmprTit := aCodFol[717,1]		//-- Parte Empresa Assist.Odontologica Titular
 Local cPdEmprDep := aCodFol[718,1]		//-- Parte Empresa Assist.Odontologica Dependente
 Local cPdEmprAgr := aCodFol[719,1]		//-- Parte Empresa Assist.Odontologica Agregado

 Local dDataCalc
 Local nUltDia

 Local aPdDescDep := {}
 Local nX := 0
 Local nBusca, cTab, nLinha

 If aCodFol[49,1] # Space( 03 ) .And. SRA->RA_ASODONT # Space( 02 )
    If ( c__Roteiro == "RES" .And. ( cCompl # "S" .Or. ( cCompl == "S" .And. MesAno(GetMemVar("RG_DATADEM")) == MesAno(GetMemVar("RG_DTGERAR")) ) .And. aIncRes[11] == "S")) .Or. ;
       ( c__Roteiro == "FOL" .And. ( SRA->RA_TIPOPGT # "S" .Or. ( SRA->RA_TIPOPGT == "S" .And. lUltSemana)) )

       // Busca Tabela Relacionada
       nBusca := SALMES
       cTab   := "S013"
       If SRA->RA_TPASODO == "2"
          nBusca := Val( Left(cFolMes,4) ) - Year( SRA->RA_NASC )
          cTab   := "S014"
          If Month( SRA->RA_NASC ) > Val( Right(cFolMes,2) )
             nBusca--
          EndIf
       EndIf

       // Calculo da Assistencia Odontologica
       If ( nLinha := fPosTab(cTab,SRA->RA_ASODONT,"=",4,nBusca,"<=",6) ) > 0
          nBaseTit := fTabela(cTab,nLinha,7)
          nPercTit := fTabela(cTab,nLinha,10) / 100

          nOdonTit := nBaseTit * nPercTit
          nEmprTit := nBaseTit - nOdonTit
          nQdeTit ++


          If lDissidio
           	 dDataCalc := dDatabase
          Else
             nUltDia:= f_UltDia(CToD("01"+"/"+Substr(cFolMes,5,2)+"/"+Substr(cFolMes,1,4)))   //Ultimo dia do Mes
		 	 dDataCalc:= CToD(StrZero(nUltDia,2)+"/"+Substr(cFolMes,5,2)+"/"+Substr(cFolMes,1,4))
          EndIf
          SRB->(dbSetOrder( 1 ))
          SRB->(dbSeek( SRA->(RA_FILIAL + RA_MAT) ))
          Do While !(SRB->(Eof())) .And. SRB->(RB_FILIAL + RB_MAT) == SRA->(RA_FILIAL + RA_MAT)
				If 	(!Empty(SRB->RB_DTINIAO) .or. !Empty(SRB->RB_DTFIMAO))

					If (!Empty(SRB->RB_DTINIAO) .and. dDataCalc < SRB->RB_DTINIAO) .or.;
						(!Empty(SRB->RB_DTFIMAO) .and. dDataCalc > SRB->RB_DTFIMAO)
		            SRB->(dbSkip())
						Loop
					EndIf
				EndIf

			    If(cPaisLoc == "BRA")
					aAdd(aPdDescDep,{SRB->RB_VBDESAO,0,,1})
                EndIf

             // Busca Tabela Relacionada
             nBusca := SALMES
             cTab   := "S013"
             If SRB->RB_TPASODO == "2"
                nBusca := Val( Left(cFolMes,4) ) - Year( SRB->RB_DTNASC )
                cTab   := "S014"
                If Month( SRB->RB_DTNASC ) > Val( Right(cFolMes,2) )
                   nBusca--
                EndIf
             EndIf

             // Calculo da Assistencia Odontologica
             If ( nLinha := fPosTab(cTab,SRB->RB_ASODONT,"=",4,nBusca,"<=",6) ) > 0
                nBaseDep := fTabela(cTab,nLinha,8)
                nBaseAgr := fTabela(cTab,nLinha,9)
                nPercDep := fTabela(cTab,nLinha,11) / 100
                nPercAgr := fTabela(cTab,nLinha,12) / 100

                If SRB->RB_TPDPODO == "1"
                	If(cPaisLoc == "BRA")
	                   aPdDescDep[Len(aPdDescDep),2] := nBaseDep * nPercDep
	                   aPdDescDep[Len(aPdDescDep),3] := "1"	//significa que é Dependente
	                EndIf
                   nOdonDep += nBaseDep * nPercDep
                   nEmprDep += nBaseDep - ( nBaseDep * nPercDep )
                   nQdeDep ++
                ElseIf SRB->RB_TPDPODO == "2"
                	If(cPaisLoc == "BRA")
	                   aPdDescDep[Len(aPdDescDep),2] := nBaseAgr * nPercAgr
	                   aPdDescDep[Len(aPdDescDep),3] := "2"	//significa que é Agregado
                    EndIf
                   nOdonAgr += nBaseAgr * nPercAgr
                   nEmprAgr += nBaseAgr - ( nBaseAgr * nPercAgr )
                   nQdeAgr ++
                EndIf
             EndIf

             SRB->(dbSkip())
          EndDo
       EndIf
    EndIf
 EndIf

 If nOdonTit + nOdonDep + nOdonAgr + nEmprTit + nEmprDep + nEmprAgr > 0
	/*Verificar se o valor calculado é superior ao limite para desconto.
	 Caso o valor seja superior, os valores de descontos serão alterados para atingir o Limite de Desconto.
	 A alteração será na seguinte ordem: 1- Agregado / 2- Dependente / 3- Titular	*/

    nDesc += nOdonTit
    nRef  += nQdeTit
    nEmpr += nEmprTit

    // Soma Parte Empresa dos Dependentes Caso Nao Tenha Identificador Especifico Cadastrado
    If Empty( cPdEmprDep )
       nEmpr += nEmprDep
    EndIf

    // Soma Parte Empresa dos Agregados Caso Nao Tenha Identificador Especifico Cadastrado
    If Empty( cPdEmprAgr )
       nEmpr += nEmprAgr
    EndIf

    // Grava Desconto
    If nDesc > 0
    	If cPaisLoc == "BRA"
			If ! (( Ascan(aPd,{|X| X[1] == cPdDescTit .And. X[9] <> "D" .And. X[7] == "I"}) > 0 ) )
				fGeraVerba(cPdDescTit,nDesc,nRef)
			EndIf
		Else
	       fGeraVerba(cPdDescTit,nDesc,nRef,,,,,,,,.T.)
	    EndIf
    EndIf
    // Grava Parte Empresa
    If nEmpr > 0
    	If cPaisLoc == "BRA"
			If ! (( Ascan(aPd,{|X| X[1] == cPdEmprTit .And. X[9] <> "D" .And. X[7] == "I"}) > 0 ) )
				fGeraVerba(cPdEmprTit,nEmpr)
			EndIf
		Else
	       fGeraVerba(cPdEmprTit,nEmpr,,,,,,,,,.T.)
	    EndIf
    EndIf
    If(cPaisLoc = "BRA")
	    // Grava Desconto dos Dependentes
	    If nOdonDep > 0
			For nX := 1 to Len(aPdDescDep)
				If aPdDescDep[nX,3] == "1"	//significa que é Dependente
					If cPaisLoc == "BRA"
						If ! (( Ascan(aPd,{|X| X[1] == aPdDescDep[nX,1] .And. X[9] <> "D" .And. X[7] == "I"}) > 0 ) )
								fGeraVerba(aPdDescDep[nX,1],aPdDescDep[nX,2],aPdDescDep[nX,4])
						EndIf
					Else
					fGeraVerba(aPdDescDep[nX,1],aPdDescDep[nX,2],aPdDescDep[nX,4],,,,,,,,.T.)
					EndIf
		  		EndIf
	  		Next nX
	    EndIf
    EndIf
    // Grava Parte Empresa dos Dependentes
    If !Empty( cPdEmprDep ) .And. nEmprDep > 0
    	If cPaisLoc == "BRA"
			If ! (( Ascan(aPd,{|X| X[1] == cPdEmprDep .And. X[9] <> "D" .And. X[7] == "I"}) > 0 ) )
					fGeraVerba(cPdEmprDep,nEmprDep)
			EndIf
		Else
	       fGeraVerba(cPdEmprDep,nEmprDep,,,,,,,,,.T.)
	    EndIf
    EndIf
    If (cPaisLoc == "BRA")
	    // Grava Desconto dos Agregados
	    If nOdonAgr > 0
			For nX := 1 to Len(aPdDescDep)
				If aPdDescDep[nX,3] == "2"	//significa que é Agregado
					If cPaisLoc == "BRA"
						If ! (( Ascan(aPd,{|X| X[1] == aPdDescDep[nX,1] .And. X[9] <> "D" .And. X[7] == "I"}) > 0 ) )
								fGeraVerba(aPdDescDep[nX,1],aPdDescDep[nX,2],aPdDescDep[nX,4])
						EndIf
					Else
					fGeraVerba(aPdDescDep[nX,1],aPdDescDep[nX,2],aPdDescDep[nX,4],,,,,,,,.T.)
					EndIf
		  		EndIf
	  		Next nX
	    EndIf
    EndIf
    // Grava Parte Empresa dos Agregados
    If !Empty( cPdEmprAgr ) .And. nEmprAgr > 0
    	If cPaisLoc == "BRA"
			If ! (( Ascan(aPd,{|X| X[1] == cPdEmprAgr .And. X[9] <> "D" .And. X[7] == "I"}) > 0 ) )
					fGeraVerba(cPdEmprAgr,nEmprAgr)
			EndIf
		Else
	       fGeraVerba(cPdEmprAgr,nEmprAgr,,,,,,,,,.T.)
	    EndIf
    EndIf
 EndIf

Return


/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³fAuxCre   ºAutor  ³ Renata Elena       º Data ³ 30/11/2009  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Calculo do Auxilio Creche                                  º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ P11                                                        º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/

Function fAuxCre(aCodfol,cPdMes)

Local cPdMeIsIr	:= If(Len(aCodFol) > 1413, aCodFol[1414,1], "")
Local dDtRef   	:= StoD( cAnoMes + "01" )
Local nValBase	:= 0
Local nValCre   := 0
Local nValCrIsIR:= 0 	//Valor do Auxilio com a isenção de IR
Local nQdeDep  	:= 0
Local nQdeDeIsIR:= 0 	//Quantidade de Dependentes com isenção de IR
Local nPerc		:= 100
Local nPercIsIr	:= 100	// Percentual da verba com isenção de IR
Local lValorDep	:= .F. // Se o valor do Auxílio-Creche a ser considerado será o valor informado no cad. de dependentes.
Local lIsIR		:= .F.
Local nBusca, cTab, nLinha
Local nSizeSin := TamSX3("RA_SINDICA")[1]
	
nPerc		:= RetValSRV(cPdMes,SRA->RA_FILIAL,"RV_PERC") /100
nPercIsIr	:= RetValSRV(cPdMeIsIr,SRA->RA_FILIAL,"RV_PERC") /100

SRB->(dbSetOrder( 1 ))
SRB->(dbSeek( SRA->(RA_FILIAL + RA_MAT) ))

Do While !(SRB->(Eof())) .And. SRB->(RB_FILIAL + RB_MAT) == SRA->(RA_FILIAL + RA_MAT)

	If !(SRB->RB_AUXCRE == "1") .or. ( !Empty(SRB->RB_DTBAIXA) .and. AnoMes(SRB->RB_DTBAIXA) <= cAnoMes)
		SRB->(dbSkip())
		Loop
	Else

		If Empty(cPdMes)
			CMSGLOG := FMSGFORM({19}) + " -> 0721 - " + aCodFol[721,2] //"Nao existe verba cadastrada para identificador de calculo "
			S_MSGLOG()
			FINALCALC()
			Return()
		EndIf

		If SRB->RB_VLRCRE > 0
			lValorDep := .T.
    	Else
    		lValorDep := .F.
    	Endif
    	// Busca Tabela Relacionada
		nBusca :=  DateDiffMonth( dDtRef , SRB->RB_DTNASC )
		cTab   := "S015"
		dDataRef	:= dDataBase
		nValBase    := 0

		If !lValorDep
			//verifica se dados para o sindicato mes / ano / filial
			nLinha := fPosTab(cTab,SRA->RA_SINDICA,"==",4 ,,,,,,,,SRA->RA_FILIAL,,,,dDtRef) //filial+mes/ano+sindicato (preenchidos)
			If nLinha == 0
			     nLinha := fPosTab(cTab,SRA->RA_SINDICA,"==",4 ,,,,,,,,SRA->RA_FILIAL,,,,Ctod("  /  /    ")) //filial+sindicato (preenchidos)
			EndIf
			If nLinha == 0
			    nLinha := fPosTab(cTab,SRA->RA_SINDICA,"==",4 ,,,,,,,,Space(FWGetTamFilial),,,,dDtRef) //mes/ano+sindicato (preenchidos)
			EndIf
			If nLinha == 0
			    nLinha := fPosTab(cTab,SRA->RA_SINDICA,"==",4 ,,,,,,,,Space(FWGetTamFilial),,,,Ctod("  /  /    ")) //sindicato (preenchido)
			EndIf
			If nLinha == 0
			    nLinha := fPosTab(cTab,Space(nSizeSin),"==",4 ,,,,,,,,Space(FWGetTamFilial),,,,Ctod("  /  /    ")) //filial+mes/ano+sindicato (em branco)
			EndIf

			If nLinha > 0
				//so depois verifica os meses que tem direito para não mostrar msg indevidamente, pq se o dependente não tem mais direito não preciso mostrar msg
				nLinha := fPosTab(cTab,SRA->RA_SINDICA,"==",4 ,nBusca,"<=",5,,,,,SRA->RA_FILIAL,nBusca,">=",7,dDtRef,,,,,,.T.) //filial+mes/ano+sindicato (preenchidos)
				If nLinha == 0
				     nLinha := fPosTab(cTab,SRA->RA_SINDICA,"==",4 ,nBusca,"<=",5,,,,,SRA->RA_FILIAL,nBusca,">=",7,Ctod("  /  /    "),,,,,,.T.) //filial+sindicato (preenchidos)
				EndIf
				If nLinha == 0
				    nLinha := fPosTab(cTab,SRA->RA_SINDICA,"==",4 ,nBusca,"<=",5,,,,,Space(FWGetTamFilial),nBusca,">=",7,dDtRef,,,,,,.T.) //mes/ano+sindicato (preenchidos)
				EndIf
				If nLinha == 0
				    nLinha := fPosTab(cTab,SRA->RA_SINDICA,"==",4 ,nBusca,"<=",5,,,,,Space(FWGetTamFilial),nBusca,">=",7,Ctod("  /  /    "),,,,,,.T.) //sindicato (preenchido)
				EndIf
				If nLinha == 0
				    nLinha := fPosTab(cTab,Space(nSizeSin),"==",4 ,nBusca,"<=",5,,,,,Space(FWGetTamFilial),nBusca,">=",7,Ctod("  /  /    "),,,,,,.T.) //filial+mes/ano+sindicato (em branco)
				EndIf

				If nLinha > 0
					nValBase := fTabela(cTab,nLinha,6)
					lIsIR	 := fTabela(cTab,nLinha,8) == "N"
				EndIf
			Else
				CMSGLOG := FMSGFORM({40}) + " S015 para o Sindicato: " + SRA->RA_SINDICA  //"Não existem dados cadastrados na Tabela  "
				S_MSGLOG()
			EndIf
		Else
			nValBase := SRB->RB_VLRCRE
		EndIf

		If nValBase > 0
			If !lIsIR
	  			nValCre  += (nValBase * If(nPerc == 0, 1, nPerc) )
	  			nQdeDep ++
	  		Else
	  			nValCrIsIR += (nValBase * If(nPercIsIr == 0, 1, nPercIsIr) )
	  			nQdeDeIsIR ++
	  		EndIf
	  	EndIf
	EndIf

	SRB->(dbSkip())
EndDo

If nValCre > 0 .Or. nValCrIsIR > 0
	If cPaisLoc == "BRA"		
		If ! (( Ascan(aPd,{|X| X[1] == cPdMes .And. X[9] <> "D" .And. X[7] $ "G|I"}) > 0 ) )
      		fGeraVerba(cPdMes,nValCre,nQdeDep)
		EndIf        
		IF ! (( Ascan(aPd,{|X| X[1] == cPdMeIsIr .And. X[9] <> "D" .And. X[7] == "I"}) > 0 ) )
      		fGeraVerba(cPdMeIsIr,nValCrIsIR,nQdeDeIsIR)
        Endif
   	Else
   		fGeraVerba(cPdMes,nValCre,nQdeDep,,,,,,,,.T.)
   	EndIf
EndIf

Return
/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³ FornVld  ºAutor  ³ Adrianne Furtado   º Data ³ 11/11/2010  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Validacao de Fornedores na Configuração de Ass Medica/Odontº±±
±±º          ³ modelo 2                                                   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ P10                                                        º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function FornVld(cCodTab)
Local lRet := .F.
Local nPosIni := 1
Local nLenCod
Local nOrdem
Local nX := 1

Local cVar		:= Alltrim(ReadVar())
Local cFOrigem := ""

Local oModel
Local oStructRHX
Local cTpForn

If cVar == "M->RB_CODAMED" .or. cVar == "SRB->RB_CODAMED" // DEPENDENTES ASSISTENCIA MEDICA
	cFOrigem := xFilial("SRB")
ElseIf cVar == "M->RB_ASODONT" .or. cVar == "SRB->RB_ASODONT" // DEPENDENTES ASSISTENCIA ODONTOLOGICA
	cFOrigem := xFilial("SRB")
ElseIf __READVAR == "M->CODFOR"           //CONSULTA F3 A PARTIR DE UMA TABELA SNNN
	cFOrigem := aCols[n][1]
	If cCodTab == "S074"
		cTpForn := aCols[n][5]
		If cTpForn == "1"
			cCodTab := "S016"
		Else
			cCodTab := "S017"
		EndIf
	Endif
ElseIf cVar $ "M->RHK_CODFOR/M->RHL_CODFOR/M->RHM_CODFOR/M->RHN_CODFOR/M->RHO_CODFOR/M->JX_CODFORN"
	oModel 		:= FWModelActive()

	If cVar $ "M->RHK_CODFOR*M->RHL_CODFOR*M->RHM_CODFOR"
		oStructRHX	:= oModel:GetModel( "GPEA001_MRHK" )
		cTpForn		:= oStructRHX:GetValue("RHK_TPFORN")
	ElseIf cVar == "M->RHN_CODFOR"
		oStructRHX	:= oModel:GetModel( "GPEA002_MRHN" )
	  	cTpForn		:= oStructRHX:GetValue("RHN_TPFORN")
	ElseIf cVar == "M->RHO_CODFOR"
		oStructRHX	:= oModel:GetModel( "GPEA003_MRHO" )
	  	cTpForn		:= oStructRHX:GetValue("RHO_TPFORN")
	ElseIf cVar == "M->JX_CODFORN"
		oStructSJX	:= oModel:GetModel( "GPEA063_MSJX" )
		cTpForn := oStructSJX:GetValue("JX_TPFORN")
	EndIf

	If FunName() = "GPEA063"
		cFOrigem := xFilial("SJX")
	Else
		cFOrigem := xFilial("SRA")
	EndIf

	If cTpForn == "1"
		cCodTab := "S016"
	ElseIf cTpForn == "2"
		cCodTab := "S017"
	EndIf

	M->CODFOR := &(cVar)
EndIf

RCB->(dbSetOrder(3))
RCB->(dbSeek(xFilial("RCB")+"CODIGO    "+cCodTab))

nLenCod := RCB->RCB_TAMAN
nOrdem := Val(RCB->RCB_ORDEM)

RCB->(dbSetOrder(1))
RCB->(dbSeek(xFilial("RCB")+cCodTab))

While nX < nOrdem .and. RCB->RCB_CODIGO == cCodTab

	If Val(RCB->RCB_ORDEM) < nOrdem
		nPosIni += RCB->RCB_TAMAN
		nX ++
	EndIf
	RCB->(DbSkip())
EndDo

RCC->(dbSetOrder(1))

If RCC->(dbSeek(xFilial("RCC")+cCodTab))
	While RCC->RCC_CODIGO == cCodTab .and. !lRet
		If M->CODFOR == SubStr(RCC->RCC_CONTEU,nPosIni,nLenCod) .and.;
			(Empty(RCC->RCC_FIL) .or. RCC->RCC_FIL == cFOrigem)
			lRet := .T.
		EndIf
		RCC->(DbSkip())
	EndDo
EndIf

Return lRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFunction³fCarDiasMes    ºAutor  ³Leandro Drumond  º Data ³  24/07/2013 º±±
±±ÌÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.   ³Carrega dados dos beneficios                                  º±±
±±º        ³                                                              º±±
±±ÌÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso     ³ Roteiro de Calculo                                           º±±
±±ÈÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function fCarDiasMes(aDias, lPropAdm, aPeriod)

	Local nCont			:= 0
	Local nX 			:= 0
	Local lCalc			:= .F.
	Local cTpDia		:= ""
	Local cTipo			:= "3"
	Local cVale			:= ""
	Local cMotivo		:= ""
	Local dBkpFim		:= cToD("//")
	Local dIni			:= ctod("")
	Local dFim			:= ctod("")
	Local dDtAdmi		:= Iif(Empty(SRA->RA_FECREI), SRA->RA_ADMISSA, SRA->RA_FECREI)
	Local lAdd			:= .T.
	Local aTabCalend	:= {}
	Local aDiasBkp		:= {}
	Local aAloc			:= {}
	Local lComplS151	:= .F.
	Local lPropFerias	:= .F. //APERGUNTE[4, 3] == 1
	Local lFeriado		:= .F.
	Local lVerFimCT		:= .F.

	DEFAULT aPeriod := aPeriodo
	DEFAULT __lMemCalc	:= cPaisLoc == "BRA" .And. fMemCalc() // Memória de Cálculo

	If Len(aPeriod) < 1
		If __lMemCalc
			fAddMemLog("Período não carregado" ,1,2)
		EndIf
		Return(Nil)
	EndIf

	If cTipoRot == "8"
		cTipo 		:= "0"
		lPropFerias	:= APERGUNTE[4,3] == 1	// Se calcula proporcional a férias programadas
		lVerFimCT	:= ValType(MV_PAR11) != "N" .Or. MV_PAR11 == 1
        lComplS151  := cPaisLoc == "BRA" .And. ValType(MV_PAR12) == "N" .And. MV_PAR12 == 1
	ElseIf cTipoRot $ "D*E"
		cTipo		:= If(cTipoRot == "D", "1", "2" )
		lPropFerias	:= APERGUNTE[3,3] == 1	// Se calcula proporcional a férias programadas
		lVerFimCT	:= cPaisLoc == "BRA" .And. ValType(MV_PAR07) != "N" .Or. MV_PAR07 == 1
        lComplS151  := cPaisLoc == "BRA" .And. ValType(MV_PAR08) == "N" .And. MV_PAR08 == 1
	EndIf

	If lVerFimCT .And. SRA->RA_TPCONTR == "2" .And. !Empty(SRA->RA_DTFIMCT) .And. AnoMes(SRA->RA_DTFIMCT) == cPeriodo
		dBkpFim				:= aPeriod[nPosSem, 4]
		aPeriod[nPosSem, 4] := Min( SRA->RA_DTFIMCT, aPeriod[nPosSem, 4] )
	EndIf

    dIni		:=  aPeriod[nPosSem, 3]
    dFim		:=  aPeriod[nPosSem, 4]

	If __lMemCalc
		fAddMemLog("Proporcional a férias : " + If(lPropFerias,"Sim","Não") ,1,2)
		fAddMemLog("Proporcional a admissão/reintegração : " + If(LPROPADM,"Sim","Não") ,1,2)
		fAddMemLog("Data admissão : " + dtoc(SRA->RA_ADMISSA)  ,1,2)
		If(!Empty(SRA->RA_FECREI), fAddMemLog("Data reintegração : " + dtoc(SRA->RA_FECREI), 1, 2), "")
		fAddMemLog("Período de cálculo : " + dtoc(dIni) + " a " + dtoc(dFim) ,1,2)
		fAddMemLog("Calendário utilizado (MV_USACPER) : " +If(lUsaCPer,"Folha","Ponto") ,1,2)
	EndIf

	aDias := {}
    If lComplS151
        aDiasS151 := fDiasS151( aPeriod[nPosSem, 3], aPeriod[nPosSem, 4] )
    EndIf

	Begin Sequence

		// Se utilizar o calendário do ponto carrega o aDias com base nesse calendário
		If !lUsaCPer
			aTabCalend := fCarPonto(aPeriod,lPropAdm)
			If Len(aTabCalend) > 1
				SPA->( dbSeek( xFilial("SPA", SRA->RA_FILIAL ) + aTabCalend[1,23] ) )
				lFeriado := ( SPA->PA_FERIADO == "S" .Or. ( SPA->( Type("PA_RECBENF") ) != "U" .And. SPA->PA_RECBENF == "1" ) )
				For nCont := 1 To Len(aTabCalend)
					If lComplS151 .And. aScan( aDiasS151, { |x| x[1] == aTabCalend[nCont, 1] } ) == 0
						Loop
					EndIf
					If cPaisLoc == "BRA" .and. P_NVAFABEN //Não deve validar afastamentos na montagem do aDiasMes, gestão será feita pela S135
						cTpDia  := Iif( aTabCalend[nCont, 6] == "S", "1", If(aTabCalend[nCont,25] $ "A*F" .and. aTabCalend[nCont,36] == "S", "1", ""))
						cVale   := Iif( (Empty(dDataDem) .Or. aTabCalend[nCont, 1] < dDataDem) .and. ( aTabCalend[nCont, 6] == "S" .or. aTabCalend[nCont, 36] == "S" ),"1","2")
					Else
						cTpDia  := Iif( aTabCalend[nCont, 6] == "S", "1", "" )
					
						cVale   := Iif( ( ( lPropFerias .And. (Empty(dDataDem) .Or. aTabCalend[nCont, 1] < dDataDem) .And. ((( aTabCalend[nCont, 6] == "S" .And. ( aTabCalend[nCont, 19] == .F. .or. aTabCalend[nCont, 10] == "E" ) ) .Or. ( lFeriado .And. (( aTabCalend[nCont, 6] == "F" .And. aTabCalend[nCont, 24] == .F. .And. aTabCalend[nCont, 36] == "S") .Or. ( aTabCalend[nCont, 6] == "S" .And. aTabCalend[nCont, 24] == .F. .And. aTabCalend[nCont, 36] == "S" .And. aTabCalend[nCont, 19] == .T.))))) ) .Or.;
										( !lPropFerias .And. (Empty(dDataDem) .OR. aTabCalend[nCont, 1] < dDataDem) .AND.((( ( aTabCalend[nCont, 6] == "S" .And. aTabCalend[nCont, 19] == .F. ) .Or. ( lFeriado .And. ( (aTabCalend[nCont, 6] == "F" .And. aTabCalend[nCont, 24] == .F. .And. aTabCalend[nCont, 36] == "S" ) .Or. (aTabCalend[nCont, 6] == "S" .And. aTabCalend[nCont, 24] == .F. .And. aTabCalend[nCont, 36] == "S" .And. aTabCalend[nCont, 19] == .T.)))) ) .Or. ( aTabCalend[nCont, 6] == "N" .And. aTabCalend[nCont, 19] == .F. .And. aTabCalend[nCont, 24] == .T. .And. aTabCalend[nCont, 36] == "S" ) ) ) ), "1", "2" )
						cVale   := Iif( lComplS151, "1", cVale )
					EndIf
					lCalc   := cVale == "1"
					aAdd( aDias, { aTabCalend[nCont, 1], cTpDia, cVale, lCalc, "", aTabCalend[nCont, 6], 0 } )
				Next nCont
			EndIf
			If __lMemCalc
				If !Empty(dDataDem)
					fAddMemLog("Data de demissão : " + dtoc(dDataDem) ,1,2)
					fAddMemLog("Considera feriado cadastro de regra (SPA) : " + If(lFeriado,"Sim","Não") ,1,2)
				EndIf
			EndIf
			// Proporcionaliza a admissão
			If lPropAdm .Or. dDtAdmi > aPeriod[nPosSem, 4]
				For nX := 1 To Len(aDias)
					If (dDtAdmi > aDias[nX][1])
						aDias[nX][4] := .F.
						aDias[nX][5] := "ADM"
					EndIf
				Next
			EndIf

			Break //sair do sequence
		EndIf

		For nX := 1 to Len(aPeriod[1][5])
			cTpDia  := Iif( aPeriod[nPosSem][5][nX][2] == "1", "S", Iif( aPeriod[nPosSem][5][nX][2] == "3", "D", Iif( aPeriod[nPosSem][5][nX][2] == "4", "F", "N" ) ) )
			lAdd    := .T.
			If lComplS151 .And. aScan( aDiasS151, { |x| x[1] == aPeriod[nPosSem][5][nX][1] } ) == 0
				Loop
			EndIf
			If !(aPeriod[1][5][nX][1] >= dIni .And. aPeriod[1][5][nX][1] <= dFim )
				lAdd := .F.
			EndIf
			If lAdd
				lCalc	:= .T.
				cMotivo	:= ""

				If cTipo = "0"  //Vale Transporte
					cVale := aPeriod[1][5][nX][3]
				ElseIf cTipo = "1" //Vale Refeição
					cVale := aPeriod[1][5][nX][5]
				ElseIf cTipo = "2" //Vale Alimentação
					cVale := aPeriod[1][5][nX][8]
				Else //Outros beneficios
					cVale := "1"
				Endif
				cVale := Iif( lComplS151, "1", cVale )
				lCalc := cVale == "1"

				If lPropAdm .And. (dDtAdmi > aPeriod[1][5][nX][1])
					lCalc := .F.
					cMotivo  := "ADM"
				EndIf

				aAdd( aDias, { aPeriod[nPosSem][5][nX][1], aPeriod[nPosSem][5][nX][2], cVale, lCalc, cMotivo, cTpDia, 0 })
			EndIf
		Next nX
	
	End Sequence

	If cTipoRot == "8" .and. lUsaGS//Verifica se funcionário possui alocação no GS
		aAloc := TXRetAloc(SRA->RA_FILIAL, SRA->RA_MAT, dIni, dFim)

		If Len(aAloc) > 0 //Se tiver alocação no período, zera aDias e monta novamente apenas com os dias de alocação
			aDiasBkp := aClone(aDias)
            aDias 	 := {}

			For nX := 1 to Len(aAloc)			
				If ( nPos := AScan( aDiasBkp, { |x| x[1] == aAloc[nX, 2] } ) ) > 0
					aAdd( aDias, aClone(aDiasBkp[nPos]) )
					aDias[Len(aDias), 3] := "1"
					aDias[Len(aDias), 4] := .T.
				EndIf
			Next nX 
		EndIf
	EndIf

	// Dias de Referência
	If(Empty(nDiasRef), aEval( aDias, {|x| If( x[4], nDiasRef++, Nil ) }), Nil)

	If lVerFimCT .And. SRA->RA_TPCONTR == "2" .And. !Empty(SRA->RA_DTFIMCT) .And. AnoMes(SRA->RA_DTFIMCT) == cPeriodo
		aPeriod[nPosSem, 4] := dBkpFim
	EndIf

Return (aDias)


//-------------------------------------------------------------------
/*/{Protheus.doc} function RHOTPATEN
Retorna os tipos de Atendimentos disponíveis na rotina de Co-participação e Reembolso. Usado no ComboBox de Cadastro.
@author  Hugo de Oliveira
@since   04/04/2019


@version 12.1.23
/*/
//-------------------------------------------------------------------
Function RHOTPATEN()
	Local cOpcBox := "1=Eletivo;2=PS;3=Exame;4=PAC;5=Material/Medicamento;6=Internação;7=Terapia;8=Taxa/Diária;9=Case;10=Reembolso;11=Remoção;12=Não Informado;13=Ambulatorio"
Return(cOpcBox)


/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFunction³fCarPonto    ºAutor  ³Leandro Drumond  º Data ³  24/07/2013 º±±
±±ÌÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.   ³Carrega dados dos beneficios                                  º±±
±±º        ³                                                              º±±
±±ÌÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso     ³ Roteiro de Calculo                                           º±±
±±ÈÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function fCarPonto(aPeriod,lPropAdm)
Local dIni		 := CtoD("")
Local dFim		 := CtoD("")
Local dDtAdmi	 := Iif(Empty(SRA->RA_FECREI), SRA->RA_ADMISSA, SRA->RA_FECREI)
Local aTabPadrao := {}
Local aTurnos	 := {}
Local aTabCalend := {}
Local lPropAfast := .T.
Local lPropFER	 := .T.

Static _aTabAux	:= {}
Static __cFunTab:= ""

DEFAULT aPeriod  := aPeriodo
DEFAULT lPropAdm := If(CTIPOROT == "8",APERGUNTE[2,3] == 1, If(cTipoRot $ "D*E",APERGUNTE[1,3] == 1,.F.))

If cTipoRot == "8"
	lPropAfast 	:= (APERGUNTE[3, 3] == 1 .Or. APERGUNTE[3, 3] == 4)
	lPropFER 	:= (APERGUNTE[3, 3] == 1 .Or. APERGUNTE[3, 3] == 3)
ElseIf cTipoRot $ "D*E"
	lPropAfast 	:= (APERGUNTE[2, 3] == 1 .Or. APERGUNTE[2, 3] == 4)
	lPropFER 	:= (APERGUNTE[2, 3] == 1 .Or. APERGUNTE[2, 3] == 3)
EndIf

dIni		:=  aPeriod[nPosSem,3]
dFim		:=  aPeriod[nPosSem,4]

If cTipoRot == "8" .And. aPergunte[1,3] == 3
    dIni :=  aPergunte[12, 3]
    dFim :=  aPergunte[13, 3]
ElseIf cTipoRot $ "D*E" .And. aPergunte[6,3] == 1
    dIni :=  aPergunte[8, 3]
    dFim :=  aPergunte[9, 3]
EndIf

//Tratamento para performance
If __cFunTab <> SRA->RA_FILIAL + SRA->RA_MAT
	_aTabAux := {}
EndIf

//Carrega apenas se já não tiver sido carregado
If Empty(_aTabAux) .or. _aTabAux[1,1] > dFim .or. _aTabAux[Len(_aTabAux)][1] < dFim

	CriaCalend(		dIni 			,;	//01 -> Data Inicial do Periodo
					dFim			,;	//02 -> Data Final do Periodo
					SRA->RA_TNOTRAB	,;	//03 -> Turno Para a Montagem do Calendario
					SRA->RA_SEQTURN	,;	//04 -> Sequencia Inicial para a Montagem Calendario
					@aTabPadrao		,;	//05 -> Array Tabela de Horario Padrao
					@_aTabAux		,;	//06 -> Array com o Calendario de Marcacoes
					SRA->RA_FILIAL  ,;	//07 -> Filial para a Montagem da Tabela de Horario
					SRA->RA_MAT   	,;	//08 -> Matricula para a Montagem da Tabela de Horario
					SRA->RA_CC   	,;	//09 -> Centro de Custo para a Montagem da Tabela
					@aTurnos		,;	//10 -> Array com as Trocas de Turno
					NIL				,;	//11 -> Array com Todas as Excecoes do Periodo
					NIL				,;	//12 -> Se executa Query para a Montagem da Tabela Padrao
					.T.				,;	//13 -> Se executa a funcao se sincronismo do calendario (Default .T.)
					.T.			 	;	//14 -> Se Forca a Criacao de Novo Calendario
					)

	__cFunTab := SRA->RA_FILIAL + SRA->RA_MAT
	
EndIf

aEval( _aTabAux, { |x| If( x[4] == "1E" .and. x[1] >= dIni .and. x[1] <= dFim, aAdd( aTabCalend, aClone(x) ), Nil)  } )

If lPropAdm
	aEval(aTabCalend,{ |x| if(x[1] < dDtAdmi, x[6]:= "N",nil)})
EndIf

If !lPropAfast
	aEval(aTabCalend, { |x| if(x[24] .and. x[25] == "A", ( x[6] := x[36], x[24] := .F.), nil)})
EndIf

If !lPropFER
	aEval(aTabCalend, { |x| if(x[24] .and. x[25] == "F", ( x[6] := x[36], x[24] := .F.), nil)})
EndIf

Return (aTabCalend)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFunction³fVlsAus		   ºAutor  ³Leandro Drumond  º Data ³  24/07/2013 º±±
±±ÌÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.   ³Verifica ausencias para pagamento de beneficios               º±±
±±º        ³                                                              º±±
±±ÌÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso     ³ Roteiro de Calculo                                           º±±
±±ÈÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function fVlsAus(dDtPesq1, dDtPesq2, aAfast, aDiasMes)
Local aArea		:= GetArea()
Local cTipoAfas	:= ""
Local dDataAux	:= CtoD("")
Local dDataAux2	:= CtoD("")
Local nAfas		:= 0
Local nLenAfa 	:= 0
Local nX		:= 0
Local nY		:= 0
Local nAfaFer	:= If(cTipoRot == "I", 0, If(cTipoRot == '8', aPergunte[3,3], aPergunte[2,3]))

DEFAULT dDtPesq1 	:= aPeriodo[nPosSem,3] //Data inicial do periodo de calculo
DEFAULT dDtPesq2 	:= aPeriodo[nPosSem,4] //Data final do periodo de calculo
DEFAULT __lMemCalc	:= cPaisLoc == "BRA" .And. fMemCalc() // Memória de Cálculo

aAfast 		:= {}
nDiasAfas 	:= 0
nFerVen		:= 0
DIASTRAB	:= 0

// -- Apura Dias Trabalhados
fDiasTrab(@DIASTRAB)

If nAfaFer <> 1
	cTipoAfas := If(nAfaFer == 3, '4','123')
EndIf
// -- Apura Dias Trabalhados e Dias de Afastamento
fDiasAfast(@nAfas,@DIASTRAB,dDataBase,,,cTipoAfas)

DIASTRAB	:= Max( ( DIASTRAB  + nDiasMat + nDPrgSalMa ) , 0 )

fRetAfas(dDtPesq1, dDtPesq2 , , , ,cTipoAfas, @aAfast,,,,,,,,,.F.)

If __lMemCalc
	fAddMemLog("Período de cálculo : " + dtoc(dDtPesq1) + " a " + dtoc(dDtPesq2) ,1,2)
	fAddMemLog("Dias trabalhados: " + cvaltochar(DIASTRAB) ,1,2)
	If(nAfas > 0, fAddMemLog("Dias afastados: " + cvaltochar(nAfas) ,1,2), "")
	If(nDiasMat + nDPrgSalMa>0, fAddMemLog("Dias maternidade: " + cvaltochar(nDiasMat + nDPrgSalMa) ,1,2), "")
EndIf

If !Empty(aAfast)
	nLenAfa := Len(aAfast)
	If Len(aDiasMes) > 0
		For nX := 1 to nLenAfa
			dDataAux  := aAfast[nX,3]
			dDataAux2 := aAfast[nX,4]
			If ( !Empty(dDataAux2) .And. aDiasMes[1,1] > dDataAux2 ) .Or. aDiasMes[Len(aDiasMes),1] < dDataAux
				Loop
			EndIf
			For nY := 1 to Len(aDiasMes)
				If aDiasMes[nY,1] >= dDataAux .and. ( aDiasMes[nY,1] <= dDataAux2 .OR. Empty(dDataAux2))
					aDiasMes[nY,4] := .F.
					If aAfast[nX,5] == "A"
						aDiasMes[nY,5] := "AFA"
						nDiasAfas++
					ElseIf aAfast[nX,5] == "F"
						aDiasMes[nY,5] := "FER"
						nFerVen++
					EndIf
				EndIf
			Next nY
		Next nX
	EndIf
EndIf
RestArea(aArea)

Return Nil

/*/{Protheus.doc} fVlsFerPrg
Verifica ferias programadas para pagamento de beneficios
@author Leandro Drumond
@since 24/07/2013
@param dDtPesq1, date, Data para o início da pesquisa
@param dDtPesq2, date, Data para o Fim da Pesquisa
@param aDiasMes, array, Array com os dias do mes
@example
	fVlsFerPrg(cTod("01/09/2017"), cTod("30/09/2017"), @aDiasMes)
/*/
Function fVlsFerPrg(dDtPesq1, dDtPesq2, aDiasMes, lBusca)

	Local aArea		:= GetArea()
	Local cMesAno	:= ""
	Local dDataAux	:= CtoD("")
	Local dDataAux2	:= CtoD("")
	Local nDiasFer	:= 0
	Local nPos		:= 0
	Local nY		:= 0

	Default dDtPesq1	:= aPeriodo[nPosSem,3]	// Data inicial do periodo de calculo
	Default dDtPesq2	:= aPeriodo[nPosSem,4]	// Data final do periodo de calculo
	Default lBusca		:= .F.					// Apenas realiza a busca, não atualiza o mnemônico nFerVen
	DEFAULT __lMemCalc	:= cPaisLoc == "BRA" .And. fMemCalc() // Memória de Cálculo

	DbSelectArea("SRH")
	DbSetOrder(1)
	DbSelectArea("SRF")
	DbSetOrder(1)

	If DbSeek( xFilial("SRF") + SRA->RA_MAT )
		cMesAno := MesAno(dDtPesq1)
		While SRF->( ! Eof() .and. RF_FILIAL + RF_MAT == xFilial("SRF") + SRA->RA_MAT )
			If SRF->RF_STATUS = "1"		//Ativo
				If __lMemCalc
					fAddMemLog("Período de férias ativo : " + dtoc(SRF->RF_DATABAS) + " a " + dtoc(SRF->RF_DATAFIM) ,1,2)
				EndIf
				dDataAux := CtoD("")
				If MesAno(SRF->RF_DATAINI) == cMesAno .And. SRF->RF_DATAINI <= dDtPesq2 .and. (Empty(dDataAux2) .or. SRF->RF_DATAINI > dDataAux2)
					dDataAux := SRF->RF_DATAINI
					nDiasFer := SRF->RF_DFEPRO1
				ElseIf MesAno(SRF->RF_DATINI2) == cMesAno .And. SRF->RF_DATINI2 <= dDtPesq2 .and. (Empty(dDataAux2) .or. SRF->RF_DATINI2 > dDataAux2)
					dDataAux := SRF->RF_DATINI2
					nDiasFer := SRF->RF_DFEPRO2
				ElseIf MesAno(SRF->RF_DATINI3) == cMesAno .And. SRF->RF_DATINI3 <= dDtPesq2 .and. (Empty(dDataAux2) .or. SRF->RF_DATINI3 > dDataAux2)
					dDataAux := SRF->RF_DATINI3
					nDiasFer := SRF->RF_DFEPRO3
				EndIf
				If ! Empty(dDataAux)
					dDataAux2 := dDataAux + nDiasFer - 1 //Subtrai um porque o dia de inicio deve ser contado.
					dDataAux2 := Min(dDataAux2, dDtPesq2) //Limite eh a menor data entre final do periodo e fim das ferias
					If !Empty(aDiasMes)
						//Se as férias já foram calculadas, ignora programação
						If !SRH->(DbSeek(SRA->RA_FILIAL + SRA->RA_MAT + DtoS(SRF->RF_DATABAS) + DtoS(dDataAux)))
							nPos := Ascan( aDiasMes, { |X| X[1] == dDataAux } )
							If nPos == 0
								nPos := Ascan( aDiasMes, { |X| X[1] == dDataAux2 } )
							EndIf
							If nPos > 0
								For nY := nPos to Len(aDiasMes)
									If aDiasMes[nY, 1] >= dDataAux .and. aDiasMes[nY,1] <= dDataAux2
										If !lBusca .And. aDiasMes[nY, 5] != "FER"
											nFerVen++
										EndIf
										aDiasMes[nY, 4] := .F.
										aDiasMes[nY, 5] := "PRG"
									Else
										Exit //Sai do laco interno
									EndIf
								Next nY
							EndIf
						EndIf
					EndIf
				EndIf
				//Exit //Pode existir outra programação, no mesmo mês, referente a outro período aquisitivo
			EndIf
			SRF->(DbSkip())
		EndDo
	EndIf

	If __lMemCalc .And. nFerVen > 0
		fAddMemLog("Dias férias programadas : " + cvaltochar(nFerVen) ,1,2)
	EndIf
	RestArea(aArea)

Return Nil


/*/{Protheus.doc} fVlsRGB
Verifica existência de faltas na RGB, SRC ou SRD e alimenta mnemônico
@author Leandro Drumond
@since 25/07/2013
@version 12.1.17
@history 01/11/2017, Cícero Alves, Incluído tratamento para busca das faltas no ponto
/*/
Function fVlsRGB()

	Local aArea			:= GetArea()
	Local aPerAtual		:= {}
	Local cAliasQry		:= ""
	Local cWhere		:= ""
	Local cWhere1		:= ""
	Local cPdAux		:= ""
	Local nFDias		:= 0
	Local nFHoras		:= 0
	Local nDesconto		:= 0  //faltas ja descontadas para o periodo
	Local dDt1			:= ctod("")
	Local dDt2			:= ctod("")
	Local nMesAnt		:= If( Type("P_BENBUSFA") == "U", 0, P_BENBUSFA)
	Local cEventosPon	:= If( Type("P_BENPONEV") == "U", "", StrTran( P_BENPONEV, ",", "','" ))	// Eventos do ponto que serão considerados para desconto
	Local cPerBusFal	:= ""
	Local aPerAberto	:= {}
	Local aPerFechado	:= {}
	Local cRotFun		:= If(SRA->RA_CATFUNC $ 'A|P', fGetCalcRot('9'), fGetCalcRot('1'))
	Local dDataIni		:= cTod("//")
	Local dDataFim		:= cTod("//")
	Local dPonIni		:= cTod("//")
	Local dPonFim		:= cTod("//")
	Local cAliasPON		:= ""
	Local nFalArray		:= 0

	DEFAULT __lMemCalc	:= cPaisLoc == "BRA" .And. fMemCalc() // Memória de Cálculo

	nFaltas := 0 //Mnemonico
	aFaltas := {}

	If cTipoRot != "I"
		If cTipoRot == "8" .AND. APERGUNTE[1, 3] == 3
			dDt1 := APERGUNTE[12, 3]
			dDt2 := APERGUNTE[13, 3]
		EndIF

		If cTipoRot <> "8" .AND. APERGUNTE[6,3] == 1
			dDt1 := APERGUNTE[8, 3]
			dDt2 := APERGUNTE[9, 3]
		EndIF

		nDesconto := FaltasDes(cPeriodo, dDt1, dDt2)
		If __lMemCalc
			fAddMemLog("Calendário utilizado (MV_USACPER) : " +If(lUsaCPer,"Folha","Ponto") ,1,2)
			If(nDesconto > 0, fAddMemLog("Faltas já descontadas de pedidos anteriores : " + cvaltochar(nDesconto) ,1,2),"")
			If(nMesAnt > 0, fAddMemLog("Meses para busca de faltas (P_BENBUSFA) : " + cvaltochar(nMesAnt) ,1,2), "")
			If(!Empty(cEventosPon),fAddMemLog("Eventos do ponto para desconto (P_BENPONEV) : " + cEventosPon ,1,2), "")
		EndIf
	EndIf

	fGetPerAtual( @aPerAtual, , SRA->RA_PROCES, cRot )

	// Se usa calendário do ponto e se o mnemônico P_BENPONEV está preenchido com os eventos do ponto verifica as faltas no ponto
	If !lUsaCPer .And. !Empty(cEventosPon) .And. !Empty(aPerAtual)

		cAliasPON := GetNextAlias()

		// Busca o período atual do ponto
		GetPerAtu(@dPonIni, @dPonFim )

		// Carrega o período de apontamento considerando o conteúdo do mnemônico P_BenBusFa
		PerAponta(@dDataIni, @dDataFim, MonthSub(aPerAtual[1][6], nMesAnt),,,,,,,.T.)

		If __lMemCalc
			fAddMemLog("Período atual do ponto : " + dtoc(dPonIni) + " a " + dtoc(dPonFim) ,1,2)
			fAddMemLog("Período de busca de desconto : " + dtoc(dDataIni) + " a " + dtoc(dDataFim) ,1,2)
		EndIf

		// Se for o período atual ou superior busca na SPC
		If dDataIni >= dPonIni

			BeginSQL Alias cAliasPON

				SELECT COUNT(*) FALTAS
				FROM %Table:SPC% SPC
				WHERE ( PC_PD IN (%Exp: cEventosPon%)
				AND PC_PDI = ''
				OR PC_PDI IN (%Exp: cEventosPon% ))
				AND PC_DATA BETWEEN %Exp: dTos(dDataIni)% AND %Exp: dTos(dDataFim)%
				AND PC_MAT = %Exp: SRA->RA_MAT%
				AND PC_FILIAL = %Exp: SRA->RA_FILIAL%
				AND SPC.%NotDel%

			EndSQL

		Else
			//Caso seja um período anterior busca na SPH

			BeginSQL Alias cAliasPON

				SELECT COUNT(*) FALTAS
				FROM %Table:SPH% SPH
				WHERE ( PH_PD IN (%Exp: cEventosPon%)
				AND PH_PDI = ''
				OR PH_PDI IN (%Exp: cEventosPon% ))
				AND PH_DATA BETWEEN %Exp: dTos(dDataIni)% AND %Exp: dTos(dDataFim)%
				AND PH_MAT = %Exp: SRA->RA_MAT%
				AND PH_FILIAL = %Exp: SRA->RA_FILIAL%
				AND SPH.%NotDel%

			EndSQL

		EndIf

		nFaltas := (cAliasPON)->(FALTAS)

		(cAliasPON)->(dbCloseArea())

		If nFaltas > 0
			//Posições no array: 1=domingo,2=segunda,3=terça,4=quarta,5=quinta,6=sexta,7=sabado
			aFaltas := {0,0,0,0,0,0,0}
			//Busca as faltas por dia da semana
			cAliasPON := GetNextAlias()
			If dDataIni >= dPonIni
				BeginSQL Alias cAliasPON

					SELECT DISTINCT PC_DATA AS DATAFAL
					FROM %Table:SPC% SPC
					WHERE ( PC_PD IN (%Exp: cEventosPon%)
					AND PC_PDI = ''
					OR PC_PDI IN (%Exp: cEventosPon% ))
					AND PC_DATA BETWEEN %Exp: dTos(dDataIni)% AND %Exp: dTos(dDataFim)%
					AND PC_MAT = %Exp: SRA->RA_MAT%
					AND PC_FILIAL = %Exp: SRA->RA_FILIAL%
					AND SPC.%NotDel%

				EndSQL

			Else
				//Caso seja um período anterior busca na SPH

				BeginSQL Alias cAliasPON

					SELECT DISTINCT PH_DATA AS DATAFAL
					FROM %Table:SPH% SPH
					WHERE ( PH_PD IN (%Exp: cEventosPon%)
					AND PH_PDI = ''
					OR PH_PDI IN (%Exp: cEventosPon% ))
					AND PH_DATA BETWEEN %Exp: dTos(dDataIni)% AND %Exp: dTos(dDataFim)%
					AND PH_MAT = %Exp: SRA->RA_MAT%
					AND PH_FILIAL = %Exp: SRA->RA_FILIAL%
					AND SPH.%NotDel%

				EndSQL
			EndIf

			While (cAliasPON)->(!Eof())
				aFaltas[Dow(StoD((cAliasPON)->DATAFAL))] += 1 //Acrescenta uma falta no dia da semana referente a data
				(cAliasPON)->(DbSkip())
			EndDo

			(cAliasPON)->(dbCloseArea())
		EndIf

	ElseIf ! Empty(aPerAtual) .and. (!Empty(aCodFol[54, 1]) .or. !Empty(aCodFol[242, 1]))

		If ! Empty(aCodFol[54, 1])
			cPdAux := "'" + aCodFol[54, 1] + "'"
		EndIf
		If ! Empty(aCodFol[242, 1])
			cPdAux += If(Empty(cPdAux), "'" + aCodFol[242, 1] + "'", ",'" + aCodFol[242, 1] + "'")
		EndIf
		If ! Empty(aCodFol[0244, 1])
			cPdAux += If(Empty(cPdAux), "'" + aCodFol[0244, 1] + "'", ",'" + aCodFol[0244, 1] + "'")
		EndIf

		If nMesAnt == 0
			//Posições no array: 1=domingo,2=segunda,3=terça,4=quarta,5=quinta,6=sexta,7=sabado
			aFaltas := {0,0,0,0,0,0,0}

			cWhere1 += " RGB.RGB_FILIAL = '" + SRA->RA_FILIAL + "' "
			cWhere1 += " AND RGB.RGB_MAT = '" + SRA->RA_MAT + "' "
			cWhere1 += " AND RGB.RGB_PROCES = '" + aPerAtual[1, 8] + "' "
			cWhere1 += " AND RGB.RGB_PERIOD = '" + aPerAtual[1, 1] + "' "
			cWhere1 += " AND RGB.RGB_ROTEIR = '" + cRotFun + "' "
			cWhere1 += " AND RGB.RGB_PD IN (" + cPdAux + ") "

			cWhere := "%" + cWhere1 + " AND RGB.RGB_TIPO1 = 'D'"
			cWhere += "%"

			cAliasQry:= "QRGB"
			BeginSql alias cAliasQry
				SELECT RGB_PD, RGB_HORAS, RGB_DTREF
				FROM %table:RGB% RGB
				WHERE %exp:cWhere% AND
				RGB.%notDel%
			EndSql

			While !(cAliasQry)->( EOF() )
				If (cAliasQry)->RGB_PD == aCodFol[0244,1]
					nFDias -= (cAliasQry)->RGB_HORAS
				Else
					nFDias += (cAliasQry)->RGB_HORAS
				EndIf
				If !Empty((cAliasQry)->RGB_DTREF)
					aFaltas[Dow(StoD((cAliasQry)->RGB_DTREF))] += 1 //Acrescenta uma falta no dia da semana referente a data
				EndIf
				(cAliasQry)->( DbSkip() )
			EndDo

			(cAliasQry)->(DbCloseArea())

			cWhere := "%" + cWhere1 + " AND RGB.RGB_TIPO1 = 'H'"
			cWhere += "%"

			cAliasQry:= "QRGB"
			BeginSql alias cAliasQry
				SELECT RGB_PD, RGB_HORAS, RGB_DTREF
				FROM %table:RGB% RGB
				WHERE %exp:cWhere% AND
				RGB.%notDel%
			EndSql

			While !(cAliasQry)->( EOF() )
				If (cAliasQry)->RGB_PD == aCodFol[0244,1]
					nFHoras -= Round((cAliasQry)->RGB_HORAS / SRA->RA_HRSDIA, 0)
				Else
					nFHoras += Round((cAliasQry)->RGB_HORAS / SRA->RA_HRSDIA, 0)
				EndIf
				If !Empty((cAliasQry)->RGB_DTREF)
					aFaltas[Dow(StoD((cAliasQry)->RGB_DTREF))] += 1 //Acrescenta uma falta no dia da semana referente a data
				EndIf
				(cAliasQry)->( DbSkip() )
			EndDo

			(cAliasQry)->(DbCloseArea())

		Else
			cPerBusFal := MesAno(MonthSub(aPerAtual[1][6], nMesAnt))
			If __lMemCalc .And. !Empty(cPdAux)
				fAddMemLog("Período de busca de desconto : " + cPerBusFal ,1,2)
				fAddMemLog("Verbas  : " + cPdAux ,1,2)
			EndIf

			RetPerAbertFech(SRA->RA_PROCES,; // Processo selecionado na Pergunte.
						cRotFun		,; // Roteiro selecionado na Pergunte.
						cPerBusFal	,; // Periodo selecionado na Pergunte.
						"99"		,; // Numero de Pagamento selecionado na Pergunte.
						NIL			,; // Periodo Ate - Passar "NIL", pois neste relatorio eh escolhido apenas um periodo.
						NIL			,; // Numero de Pagamento Ate - Passar "NIL", pois neste relatorio eh escolhido apenas um numero de pagamento.
						@aPerAberto	,; // Retorna array com os Periodos e NrPagtos Abertos
						@aPerFechado ) // Retorna array com os Periodos e NrPagtos Fechados

			If nMesAnt == 1 .and. ! Empty(aPerAberto)
				cWhere1 += " SRC.RC_FILIAL = '" + SRA->RA_FILIAL + "' "
				cWhere1 += " AND SRC.RC_MAT = '" + SRA->RA_MAT    + "' "
				cWhere1 += " AND SRC.RC_PROCES = '" + SRA->RA_PROCES + "' "
				cWhere1 += " AND SRC.RC_PERIODO = '" + aPerAberto[1,1] + "' "
				cWhere1 += " AND SRC.RC_ROTEIR = '" + cRotFun + "' "
				cWhere1 += " AND SRC.RC_PD IN (" + cPdAux   + ") "

				cWhere := "%" + cWhere1 + " AND SRC.RC_TIPO1 = 'D'"
				cWhere += "%"

				cAliasQry:= "QSRC"
				BeginSql alias cAliasQry
					SELECT RC_PD, RC_HORAS
					FROM %table:SRC% SRC
					WHERE %exp:cWhere% AND
					SRC.%notDel%
				EndSql

				While !(cAliasQry)->( EOF() )
					If (cAliasQry)->RC_PD == aCodFol[0244,1]
						nFDias -= (cAliasQry)->RC_HORAS
					Else
						nFDias += (cAliasQry)->RC_HORAS
					EndIf

					(cAliasQry)->( DbSkip() )
				EndDo

				(cAliasQry)->(DbCloseArea())

				cWhere := "%" + cWhere1 + " AND SRC.RC_TIPO1 = 'H'"
				cWhere += "%"
				cAliasQry:= "QSRC"
				BeginSql alias cAliasQry
					SELECT RC_PD,RC_HORAS
					FROM %table:SRC% SRC
					WHERE %exp:cWhere% AND
					SRC.%notDel%
				EndSql

				While !(cAliasQry)->( EOF() )
					If (cAliasQry)->RC_PD == aCodFol[0244,1]
						nFHoras -= Round((cAliasQry)->RC_HORAS / SRA->RA_HRSDIA, 0)
					Else
						nFHoras += Round((cAliasQry)->RC_HORAS / SRA->RA_HRSDIA, 0)
					EndIf

					(cAliasQry)->( DbSkip() )
				EndDo

				(cAliasQry)->(DbCloseArea())
			ElseIf !Empty(aPerFechado)
				cWhere1 += " SRD.RD_FILIAL = '" + SRA->RA_FILIAL + "' "
				cWhere1 += " AND SRD.RD_MAT = '" + SRA->RA_MAT + "' "
				cWhere1 += " AND SRD.RD_PROCES = '" + SRA->RA_PROCES + "' "
				cWhere1 += " AND SRD.RD_PERIODO = '" + aPerFechado[1, 1] + "' "
				cWhere1 += " AND SRD.RD_ROTEIR = '" + cRotFun + "' "
				cWhere1 += " AND SRD.RD_PD IN (" + cPdAux + ") "

				cWhere := "%" + cWhere1 + " AND SRD.RD_TIPO1 = 'D'"
				cWhere += "%"

				cAliasQry:= "QSRD"
				BeginSql alias cAliasQry
					SELECT RD_PD,RD_HORAS
					FROM %table:SRD% SRD
					WHERE %exp:cWhere% AND
					SRD.%notDel%
				EndSql

				While !(cAliasQry)->( EOF() )
					If (cAliasQry)->RD_PD == aCodFol[0244,1]
						nFDias -= (cAliasQry)->RD_HORAS
					Else
						nFDias += (cAliasQry)->RD_HORAS
					EndIf

					(cAliasQry)->( DbSkip() )
				EndDo

				(cAliasQry)->(DbCloseArea())

				cWhere := "%" + cWhere1 + " AND SRD.RD_TIPO1 = 'H'"
				cWhere += "%"
				cAliasQry:= "QSRD"
				BeginSql alias cAliasQry
					SELECT RD_PD,RD_HORAS
					FROM %table:SRD% SRD
					WHERE %exp:cWhere% AND
					SRD.%notDel%
				EndSql

				While !(cAliasQry)->( EOF() )
					If (cAliasQry)->RD_PD == aCodFol[0244,1]
						nFHoras -= Round((cAliasQry)->RD_HORAS / SRA->RA_HRSDIA, 0)
					Else
						nFHoras += Round((cAliasQry)->RD_HORAS / SRA->RA_HRSDIA, 0)
					EndIf

					(cAliasQry)->( DbSkip() )
				EndDo

				(cAliasQry)->(DbCloseArea())
			EndIf
		EndIf
		nFaltas := nFDias + nFHoras
	EndIf
	If __lMemCalc .And. nFaltas > 0
		fAddMemLog("Faltas no período : " + cvaltochar(nFaltas) ,1,2)
	EndIf

	aEval(aFaltas, {|x| nFalArray += x})
	If nFalArray == 0
		aFaltas := {}
	EndIf

	nFaltas := nFaltas - nDesconto

	If __lMemCalc .And. nFaltas > 0
		fAddMemLog("Faltas no período - faltas ja descontadas em outros pedidos: " + cvaltochar(nFaltas) ,1,2)
	EndIf
	If nFaltas < 0 .And. nDesconto > 0
		nFaltas := 0
		aFaltas := {}
	EndIf

	RestArea(aArea)
Return Nil

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFunction³fVTRSal		   ºAutor  ³Leandro Drumond  º Data ³  25/07/2013 º±±
±±ÌÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.   ³Monta salario base para calculo do vale transporte		      º±±
±±º        ³                                                              º±±
±±ÌÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso     ³ Roteiro de Calculo                                           º±±
±±ÈÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function fVTRSal()

	Local aArea		:= GetArea()
	Local lCVTUso	:= GetMvRH( "MV_CVTUSO", .F., "2" ) == "1"
	Local cVTProp	:= GetMvRH( "MV_CVTPROP", .F., "P" )
	Local cCodigos	:= ""
	Local nDiaTra	:= 0
	Local nTVerbas	:= 0
	Local nQtdPerg	:= 7
	Local nCont		:= 0
	Local nInfNorm	:= 0
	Local nInfDesc	:= 0
	Local nValRed	:= 0
	Local lSALHBEN	:= .F.
	Local lLDSRHRSP := Type("P_LDSRHRSP") # "U" .And. P_LDSRHRSP

	DEFAULT __lMemCalc	:= cPaisLoc == "BRA" .And. fMemCalc() // Memória de Cálculo

	If SRA->RA_TPCONTR == "3"
		nSalBsVT := 0
		aConvoc := BuscaConv(aPeriodo[nPosSem,3], aPeriodo[nPosSem,4])
		aEval(aConvoc, {|x| nSalBsVT += (x[5] * x[7] * x[4])})
		nSalBsVT := Round(nSalBsVT,2)
		nSalMes  := nSalBsVT
		If __lMemCalc 
			fAddMemLog("Salário base para cálculo do benefício : " + Transform(nSalBsVT,"@E 999,999,999.99") ,1,2)
		EndIf
	Else

		fSalario(@nSalario, @SalHora, @SalDia, @nSalMes, "A")

		If SRA->RA_CATFUNC == "H" .And. lLDSRHRSP
			nSalMes := (SRA->RA_SALARIO * nHrsCal)
		EndIf

		If DIASTRAB == 0 .and. Len(aAfast) == 0
			fDiasTrab(@DIASTRAB)
		EndIf

		If lCVTUso
			nDiatra := If(cVTProp == "T", If(GetMvRH("MV_DIASPER",,"1") == "1",nDiasP,(If(SRA->RA_TIPOPGT =="M", P_QTDIAMES, P_NTOTDIAS))), DIASTRAB)
		EndIf

		nSalBsVT := 0 //Salario Base VTR - Mnemonico

		aPd := FCARMVTO(SRA->RA_FILIAL, SRA->RA_MAT, CSEMANA, CPROCESSO, CPERIODO, "FOL", CNUMPAG, ,.F.)

		lSALHBEN := If( Type("P_SALHBEN") == "U", .F., P_SALHBEN)

		If __lMemCalc
			fAddMemLog("MV_CVTUSO : " + If(lCVTUso,"Sim","Não") + " ("+retX6Desc("MV_CVTUSO")+")" ,1,2)
			If(!Empty(cVTProp), fAddMemLog("MV_CVTPROP : " + cVTProp + " ("+retX6Desc("MV_CVTPROP")+")" ,1,2), "")
			fAddMemLog("P_LDSRHRSP : " + If(P_LDSRHRSP,"Sim","Não") + " ("+ retRcaDes("P_LDSRHRSP")+")" ,1,2)
			fAddMemLog("P_SALHBEN : " + If(lSALHBEN,"Sim","Não")  + " ("+ retRcaDes("P_SALHBEN")+")",1,2)
			fAddMemLog("Dias período : " + cvaltochar(nDiatra) ,1,2)
			fAddMemLog("Dias trabalhados : " + cvaltochar(DIASTRAB) ,1,2)
			If(nDiasAfas>0, fAddMemLog("Dias afastamento : " + cvaltochar(nDiasAfas) ,1,2), "")
			fAddMemLog("Salário : " + Transform(nSalario,"@E 999,999,999.99")  ,1,2)
			fAddMemLog("Salário hora : " + Transform(SalHora,"@E 999,999,999.99")  ,1,2)
			fAddMemLog("Salário dia : " + Transform(SalDia,"@E 999,999,999.99")  ,1,2)
			fAddMemLog("Salário incorporado : " + Transform(nSalMes,"@E 999,999,999.99")  ,1,2)
			fAddMemLog("Horas normal : " + cvaltochar(Normal) ,1,2)
			fAddMemLog("Horas descanso : " + cvaltochar(Descanso) ,1,2)
		EndIf

		If SRA->RA_CATFUNC == "H" .AND. lSALHBEN
			//Percorre o aPd em busca das verbas de salário horista (Id 0032) e DSR horista (Id 0033)
			For nCont := 1 To Len(aPd)
				If aPd[nCont, 1] == aCodFol[032, 1] .And. aPd[nCont, 9] != "D" .And. AllTrim( aPd[nCont, 3] ) == AllTrim( cSemana ) .And. aPd[nCont, 7] == "I"
					nInfNorm += aPd[nCont, 4]
				EndIf
				If aPd[nCont, 1] == aCodFol[033, 1] .And. aPd[nCont, 9] != "D" .And. AllTrim( aPd[nCont, 3] ) == AllTrim( cSemana ) .And. aPd[nCont, 7] == "I"
					nInfDesc += aPd[nCont, 4]
				EndIf
			Next nCont

			//Caso tenha informado a verba de salário horista, utiliza as horas informadas
			If nInfNorm > 0
				Normal := nInfNorm
				//Caso possua afastamento, divide as horas pelas dias trabalhados e multiplica pelos dias de cálculo para considerar as horas previstas no mês
				If nDiasAfas > 0
					Normal := (Normal / DiasTrab * nDiasC)
				EndIf
				//Verifica a quantidade de horas trabalhadas por dia, de acordo com as horas informadas
				//Conta será as horas trabalhadas, dividido pelos dias úteis, multiplicado pelos dias de cálculo e dividido por 30
				nHrsDia := (Normal / aPeriodo[nPosSem, 24] * aPeriodo[nPosSem, 20] / 30)
				//Caso tenha informado a verba de DSR horista, utiliza as horas informadas
				If nInfDesc > 0
					Descanso := nInfDesc
				//Caso contrário, multiplica as horas trabalhadas por dia pelos dias de DSR
				Else
					Descanso := nHrsDia * aPeriodo[nPosSem, 7]
				EndIf

				//Retira a incorporação das variáveis de salário, pois foram consideradas as horas cadastrais
				nSalMes -= (SRA->RA_SALARIO * nHrsCal)
				SalDia -= (SRA->RA_SALARIO * SRA->RA_HRSDIA)

				//Efetua a incorporação das variáveis de salário, com base nas horas trabalhadas
				nHrsCal := nHrsDia * nDiasC
				nSalMes += (SRA->RA_SALARIO * nHrsCal)
				SalDia += (SRA->RA_SALARIO * nHrsDia)

				If __lMemCalc
					fAddMemLog("Horas informadas normal : " + cvaltochar(nInfNorm) ,1,2)
					fAddMemLog("Horas informadas descanso : " + cvaltochar(nInfDesc) ,1,2)
					fAddMemLog("Horas cálculo : " + cvaltochar(nHrsCal) ,1,2)
					fAddMemLog("Novo salário dia : " + Transform(SalDia,"@E 999,999,999.99")  ,1,2)
					fAddMemLog("Novo salário incorporado : " + Transform(nSalMes,"@E 999,999,999.99")  ,1,2)
				EndIf
			EndIf
		EndIf

		If Len(aPergunte) > nQtdPerg
			cCodigos := AllTrim(aPergunte[7, 3]) + AllTrim(aPergunte[8, 3]) + AllTrim(aPergunte[9, 3]) + AllTrim(aPergunte[10, 3])
			If !Empty(cCodigos) // Incorpora verbas do Movimento Mensal ao Salario
				nTVerbas := 0
				fSVerbas(cCodigos, @nTVerbas, aPd)
				nSalMes += nTVerbas
				If __lMemCalc
					fAddMemLog("Verbas a serem incorporadas : " + cCodigos ,1,2)
					fAddMemLog("Valor das verbas : " + Transform(nTVerbas,"@E 999,999,999.99") ,1,2)
					fAddMemLog("Novo salário incorporado : " + Transform(nSalMes,"@E 999,999,999.99")  ,1,2)
				EndIf
			EndIf
		EndIf

		If P_lPPEAtiv .And. P_RedSalB
			fInssResEx()
			fSalRed(@nValRed, Nil, Nil, nSalMes)
			nSalMes -= nValRed
		EndIf

		If lCVTUso //Usa parametro MV_CVTPROP
			If !BaseVTProp(@nSalBsVT, nDiaTra, cVTProp)
				Return(.F.)
			EndIf
		Else
			nSalBsVT  := nSalMes //Considera salario integral
			If __lMemCalc
				fAddMemLog("Salário base para cálculo do benefício(nSalMes) : " + Transform(nSalMes,"@E 999,999,999.99") ,1,2)
			EndIf
		EndIf

		// Verifico se o Funcionário é Comissionado
		If SRA->RA_CATFUNC == "C" .And. (nSalBsVT == 0 .OR. empty(nSalBsVT))
			nSalBsVT := fDesc("RCE", SRA->RA_SINDICA, "RCE_GCOMISS", Nil, SRA->RA_FILIAL)
			If __lMemCalc
				fAddMemLog("Garantia comissão (salário) : " + Transform(nSalBsVT,"@E 999,999,999.99") ,1,2)
			EndIf
		Endif
	EndIf

RestArea(aArea)

Return .T.

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFunction³BaseVTProp	   ºAutor  ³Leandro Drumond  º Data ³  25/07/2013 º±±
±±ÌÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.   ³Monta base de salario para VT baseado no parametro		      º±±
±±º        ³                                                              º±±
±±ÌÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso     ³ Roteiro de Calculo                                           º±±
±±ÈÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function BaseVTProp(nSalBsVT,nDiaTra,cVTProp)
Local aPdAux    := {}
Local lRet		:= .T.
Local lGpem040  := FunName() == "GPEM040" .or. FunName() == "GPEM040B"
Local nX		:= 0
Local nDiasFunc	:= 0
Local nDPropInf	:= 0
Local nDiasPer	:= 0
Local nDiasTb	:= 0
Local nPos 		:= 0

DEFAULT __lMemCalc	:= cPaisLoc == "BRA" .And. fMemCalc() // Memória de Cálculo

If __lMemCalc
	fAddMemLog("Calendário  : " + if( Empty(aDiasMes),"Sintético","Analítico") ,1,2)
EndIf

If P_PROPVT .and. lGpem040 //Recalcular VT parte empresa proporcional ao saldo de salário na rescisão
	aPdAux  := fPropVtRES()
	nPos 	:= aScan(aPdAux, {|x| x[1] == aCodFol[048,1] .And. x[9] != "D" })	
	If nPos > 0
		nSalBsVT  := aPdAux[nPos,5] //Saldo de salário
	EndIF
ElseIf cVTProp == "I" 	//Integral
	nSalBsVT := nSalMes
ElseIf cVTProp == "T"	//Trabalhado
	If Empty(aDiasMes) //Periodo sintetico, nao tem informacao de dia. Utilizar salario do mes
		nSalBsVT := nSalMes		//Considera salario integral
		If __lMemCalc
			fAddMemLog("Salário base para cálculo do benefício(nSalMes) : " + Transform(nSalMes,"@E 999,999,999.99") ,1,2)
		EndIf
	Else
		For nX := 1 to Len(aDiasMes)
			If ( aDiasMes[nX,2] $ "1*3" .and. Empty(aDiasMes[nX,5]) ) //Dias úteis e DSR sem afastamento
				nDiasFunc++
			EndIf
		Next nX
		nSalBsVT := nSalMes * (nDiasFunc/nDiaTra)
		If __lMemCalc
			fAddMemLog("Dias trabalhados (calendário)  : " + cvaltochar(nDiasFunc) ,1,2)
			fAddMemLog("Salário base para cálculo do benefício (nSalMes * (nDiasFunc/nDiaTra)) : " + Transform(nSalBsVT,"@E 999,999,999.99") ,1,2)
		EndIf
	EndIf
ElseIf cVTProp == "P"
    DbSelectArea("SM7")
    DbSetOrder(RetOrdem("SM7","M7_FILIAL+M7_MAT+M7_TPVALE+M7_CODIGO"))
    If DbSeek(SRA->RA_FILIAL+SRA->RA_MAT+"0")
        While ( !Eof() .and. M7_FILIAL+M7_MAT+M7_TPVALE == SRA->RA_FILIAL+SRA->RA_MAT+"0" )
            //Se existir algum meio de transporte sem dias proporcionais informados ou com dias proporcionais diferentes entre si, campo será desconsiderado
            If SM7->M7_DPROPIN == 0 .or. ( nDPropInf <> 0 .and. nDPropInf <> SM7->M7_DPROPIN .and. SM7->M7_DPROPIN <> 99 )
                nDPropInf := 0
                Exit
            EndIf
            If SM7->M7_DPROPIN <> 99
                nDPropInf := SM7->M7_DPROPIN
            EndIf
            DbSkip()
        EndDo
    EndIf
	If __lMemCalc .And. nDPropInf > 0
		fAddMemLog("Dias proporcionais informados  : " + cvaltochar(nDPropInf) ,1,2)
	EndIf
	If nDPropInf == 0
		If Empty(aDiasMes)
			nSalBsVT  := nSalMes	//Considera salario integral pois nao eh possivel calcular dias proporcionais informados
			nDPropInf := 0
			If __lMemCalc
				fAddMemLog("Salário base para cálculo do benefício (nSalMes) : " + Transform(nSalMes,"@E 999,999,999.99") ,1,2)
			EndIf
		Else
			For nX := 1 to Len(aDiasMes)
				If aDiasMes[nX,3] == "1" .and. aDiasMes[nX,4]  //RCG_VTRANS = "S"
					nDPropInf++
				EndIf
			Next nX
		EndIf
	EndIf
	If nDPropInf > 0
		nDiasPer  := If(SRA->RA_TIPOPGT =="S", P_NTOTDIAS, nDiasC)
		nSalBsVT  := nSalMes/nDiasPer*nDPropInf
		If __lMemCalc 
			fAddMemLog("Dias proporcionais calendário : " + cvaltochar(nDPropInf) ,1,2)
			fAddMemLog("Salário base para cálculo do benefício(nSalMes/nDiasPer*nDPropInf ) : " + Transform(nSalBsVT,"@E 999,999,999.99") ,1,2)
		EndIf
	EndIf
ElseIf cVTProp == "S" //Base Saldo de Salario
	nDiasTb     := Max(DiasTrab - ( nDiasMat + nDPrgSalMa ), 0)
	nDiasPer	:= If(GetMvRH("MV_DIASPER",,"1") == "1",nDiasP,(If(SRA->RA_TIPOPGT =="M", P_QTDIAMES, P_NTOTDIAS)))
	If !Empty(aDiasMes)
		For nX := 1 to Len(aDiasMes)
			If !aDiasMes[nX,4] .and. aDiasMes[nX,5] == "PRG" .and. Day(aDiasMes[nX,1]) <= nDiasPer //Se tiver férias programadas, subtrai dos dias trabalhados
				nDiasTb--
			EndIf
		Next nX
	EndIf
	nSalBsVT 	:= (( nSalMes / nDiasPer ) * nDiasTb )
	If __lMemCalc
		fAddMemLog("Dias trabalhados - dias de férias programadas  : " + cvaltochar(DiasTrab-nDiasTb) ,1,2)
		fAddMemLog("Dias trabalhados  : " + cvaltochar(nDiasTb) ,1,2)
		fAddMemLog("Salário base para cálculo do benefício((( nSalMes / nDiasPer ) * nDiasTb )	 ) : " + Transform(nSalBsVT,"@E 999,999,999.99") ,1,2)
	EndIf
EndIf

Return lRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFunction³fChkSM7  	   ºAutor  ³Leandro Drumond  º Data ³  26/07/2013 º±±
±±ÌÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.   ³Checa se existem dados na SR0							      º±±
±±º        ³                                                              º±±
±±ÌÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso     ³ Roteiro de Calculo                                           º±±
±±ÈÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function fChkSM7(cFilFunc,cMatFunc,cTipoVale,lAgrup)
Local aArea		:= GetArea()
Local lRet		:= .T.

DEFAULT cFilFunc  := xFilial("SM7")
DEFAULT cMatFunc  := SRA->RA_MAT
DEFAULT cTipoVale := If(cTipoRot == "8","0",(If(cTipoRot == "D","1","2"))) //0-Vale Transporte / 1-Vale Refeição / 2-Vale Alimentação
DEFAULT lAgrup	  := .F.


DbSelectArea("SM7")
SM7->(DbSetOrder(RetOrder("SM7", "M7_FILIAL+M7_MAT+M7_TPVALE")))

If lAgrup
	If SM7->(DbSeek(cFilFunc + cMatFunc + cTipoVale))
		While !SM7->(Eof()) .And. SM7->(M7_FILIAL+M7_MAT+M7_TPVALE) == cFilFunc + cMatFunc + cTipoVale
			If SM7->M7_TPCALC <> "2"
				lRet := .F.
			Else
				RecLock("SM7",.F.)
				DbDelete()
				MsUnLock()
			EndIf
			SM7->(dbSkip())
		EndDo
	EndIf
Else
	If !SM7->(DbSeek(cFilFunc + cMatFunc + cTipoVale))
		lRet := .F.
	EndIf
EndIf
RestArea(aArea)

Return lRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFunction³fChkRG2  	   ºAutor  ³Leandro Drumond  º Data ³  29/07/2013 º±±
±±ÌÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.   ³Checa se existe pedido completo na RG2					      º±±
±±º        ³                                                              º±±
±±ÌÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso     ³ Roteiro de Calculo                                           º±±
±±ÈÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function fChkRG2(cFilFunc, cMatFunc, cTipoVale)

Local aArea		:= GetArea()
Local lRet		:= .T.
Local cTpRG2Ped	:= GetSx3Cache("RG2_PEDIDO", "X3_TIPO")

DEFAULT cFilFunc  := xFilial("RG2")
DEFAULT cMatFunc  := SRA->RA_MAT
DEFAULT cTipoVale := If(cTipoRot == "8","0",(If(cTipoRot == "D","1","2"))) //0-Vale Transporte / 1-Vale Refeição / 2-Vale Alimentação

DbSelectArea("RG2")
DbSetOrder(RetOrder("RG2", "RG2_FILIAL+RG2_PERIOD+RG2_NROPGT+RG2_ROTEIR+RG2_MAT+RG2_TPVALE+RG2_CODIGO"))

If DbSeek(cFilFunc + cPeriodo + cSemana + cRot + cMatFunc + cTipoVale)
	If RG2->RG2_PEDIDO == If( cTpRG2Ped == "C", "2", 2 )			//Se pedido foi concluido, nao recalcula
		If GetRemoteType() == -1
			MsgLogGrid( STR0036, .F. ) // "Pedido de compra do beneficio já foi concluído. Não será recalculado."
		Else
			If IsInCallStack( "EXECROT" ) //Se estiver executando roteiro de calculo
				AddLogExecRot( STR0036 )	// "Pedido de compra do beneficio já foi concluído. Não será recalculado."
			Else
				Help(" ", 1, "Help",, OemToAnsi(STR0036), 1, 0)  // "Pedido de compra do beneficio já foi concluído. Não será recalculado."
			EndIf
		EndIf
		lRet := .F.
	EndIf
EndIf

RestArea(aArea)

Return lRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFunction³fVTRCalcN	   ºAutor  ³Leandro Drumond  º Data ³  25/07/2013 º±±
±±ÌÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.   ³Calculo do Vale Transporte								      º±±
±±º        ³                                                              º±±
±±ÌÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso     ³ Roteiro de Calculo                                           º±±
±±ÈÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function fVTRCalcN(aVTCalc)

Local aArea		    := GetArea()
Local aCfgS151	    := {}
Local aPerAux	    := {}
Local aTabS151	    := {}
Local cFilFunc      := SRA->RA_FILIAL
Local cMatFunc      := SRA->RA_MAT
Local cKeyAux	    := ""
Local lGrvRU1	    := .F.
Local nCustFunc     := 0
Local nDiaNUtil	    := 0
Local nDiaUtil	    := 0
Local nDiasFix	    := 0
Local nValUni	    := 0
Local nValUniAnt    := 0
Local nValUniDif    := 0
Local nDiaTran	    := 0
Local nDiaNTran	    := 0
Local nDiaUCal	    := 0
Local nDiaNUCal	    := 0
Local nValVTR	    := 0
Local nTotVTR	    := 0
Local nDiasVTR	    := 0
Local nDiasProp	    := 0
Local nX		    := 0
Local nTotDif		:= 0
Local nValOri		:= 0
Local nPos		    := 0
Local lPeriodico	:= aPergunte[1,3] == 3//Avulso/Complemnto/Semanal/diario
Local lDifVT		:= aPergunte[1,3] == 2 
Local nDiasSeg 		:= 0									//-- Qtde Segundas trabalhadas
Local nDiasTer 		:= 0									//-- Qtde Tercas trabalhadas
Local nDiasQua		:= 0									//-- Qtde Quartas trabalhadas
Local nDiasQui 		:= 0									//-- Qtde Quintas trabalhadas
Local nDiasSex 		:= 0									//-- Qtde Sextas trabalhadas
Local nDiasSab 		:= 0									//-- Qtde Sabados trabalhadas
Local nDiasDom 		:= 0									//-- Qtde Domingos trabalhadas
Local nDiasPonto 	:= 0
Local nFalAux		:= 0
Local lDias			:= .F.
Local lFeriado 		:= .F.
Local lPropFerias	:= APERGUNTE[4,3] == 1 .Or. APERGUNTE[3,3] == 1 .Or. APERGUNTE[3,3] == 3
Local lComplS151	:= cPaisLoc == "BRA" .And. ValType(MV_PAR12) == "N" .And. MV_PAR12 == 1
Local aTabCalend	:= If (!lUsaCPer,fCarPonto(),{})
Local lSP7			:= .F.
Local dDt1			:= ctod("")
Local dDt2			:= ctod("")
Local nH			:= 0
Local nDiaNTraPE	:= 0
Local nDiaTraPE		:= 0
Local nCustAux		:= 0
Local nDias			:= 0
Local nDNUtil		:= 0
Local nDUtil		:= 0

Private nPercentual := RetValSRV(aCodFol[051,1],SRA->RA_FILIAL,"RV_PERC")
Private aVTRDias    := {}

DEFAULT lGp210Sal	:= ExistBlock("GP210SAL")
DEFAULT lGPVTRDias  := ExistBlock("GPVTRDias")
DEFAULT __lMemCalc	:= cPaisLoc == "BRA" .And. fMemCalc() // Memória de Cálculo
DEFAULT lCpoSts     := SM7->(ColumnPos("M7_STAT")) > 0
DEFAULT aM7Inativ   := {}

If lGp210Sal
	EXECBLOCK("GP210SAL", .F. , .F. ) //Retorna nPercentual
	If ValType(nPercentual) <> "N"
		nPercentual := 6
	EndIf
EndIf

If SRA->RA_CATFUNC $ "E*G"
	nCustFunc := nPercentual := 0
Else
	nCustFunc := Round(NSALBSVT * ( nPercentual / 100 ),2) //Custo Mensal do Funcionario
EndIf

If ( lPeriodico .or. lDifVT ) .and. nCustFunc > 0//Verifica se já houve pagamento de VT no mês para abater o custo do funcionário
	SR0->(DbSetOrder(3)) //R0_FILIAL+R0_MAT+R0_TPVALE+R0_CODIGO+R0_PEDIDO
	If SR0->(DbSeek(SRA->RA_FILIAL +  SRA->RA_MAT + "0"))
		While(SR0->(!Eof() .and. R0_FILIAL + R0_MAT + R0_TPVALE == SRA->RA_FILIAL +  SRA->RA_MAT + "0"))
			If lDifVT .or. ( SR0->R0_PERIOD == cPeriodo .and. SR0->R0_PEDIDO == "2" ) //Apenas pedidos concluídos
				nCustFunc -= SR0->R0_VLRFUNC
			EndIf
			SR0->(DbSkip())
		EndDo
		nCustFunc := Max(nCustFunc,0)
	EndIf
EndIf

If !lUsaCPer .And. Len(aTabCalend) > 1
	SPA->( dbSeek( xFilial("SPA", SRA->RA_FILIAL ) + aTabCalend[1,23] ) )
	lFeriado := ( SPA->PA_FERIADO == "S" .Or. ( SPA->( Type("PA_RECBENF") ) != "U" .And. SPA->PA_RECBENF == "1" ) )
EndIf

If __lMemCalc
	fAddMemLog("Calendário utilizado (MV_USACPER) : " +If(lUsaCPer,"Folha","Ponto") ,1,2)
	fAddMemLog("Considera feriado cadastro de regra (SPA) : " + If(lFeriado,"Sim","Não") ,1,2)
	If !lUsaCPer
		fAddMemLog("Tabela padrão do ponto carregada : " + If(Len(aTabCalend) > 1 ,"Sim","Não") ,1,2)
	EndIf
	fAddMemLog("Proporcional a férias : " + If(lPropFerias,"Sim","Não") ,1,2)
	fAddMemLog("Cálculo periódico : " + If(lPeriodico,"Sim","Não") ,1,2)
EndIf

aVTCalc	  := {}

DbSelectArea("SM7")
SM7->(DbSetOrder(RetOrder("SM7", "M7_FILIAL+M7_MAT+M7_TPVALE+M7_CODIGO")))

If SM7->(DbSeek(cFilFunc + cMatFunc + "0"))

    If lComplS151
        fCarrTab( @aTabS151, "S151", dDataBase, .T., cPeriodo )
		If Empty(aTabS151)
			CMSGLOG := STR0047 + "https://tdn.totvs.com/pages/releaseview.action?pageId=776129138" //"Para que o cálculo seja efetuado com a opção 'Complemento por HE' ativa é necessário o preenchimento da tabela S151 conforme documentação: "
			S_MSGLOG()
			FINALCALC()
			Return()
		EndIf
    EndIf

	While SM7->(!Eof() .and. M7_FILIAL + M7_MAT + M7_TPVALE == cFilFunc + cMatFunc + "0") 

		If lCpoSts .And. SM7->M7_STAT == "1"
			aAdd(aM7Inativ, {SM7->M7_FILIAL + SM7->M7_MAT + SM7->M7_TPVALE + SM7->M7_CODIGO})
			SM7->(dbSkip())
			Loop
		EndIf

		lGrvRU1 := .F.
        nFalAux := 0

		If lPeriodico .And. aPergunte[14,3] == 1 .And. SM7->M7_COMPL <> '1'
			SM7->(dbSkip())
			Loop
		EndIf

		lDias :=  SM7->M7_VALSEG > 0 .Or. SM7->M7_VALTER  > 0 .Or. SM7->M7_VALQUA  > 0 .Or.  SM7->M7_VALQUI  > 0 .Or.  SM7->M7_VALSEX  > 0 .Or.  SM7->M7_VALSAB  > 0 .Or.  SM7->M7_VALDOM >0
		aDiaVales := {SM7->M7_VALSEG , SM7->M7_VALTER , SM7->M7_VALQUA , SM7->M7_VALQUI , SM7->M7_VALSEX , SM7->M7_VALSAB , SM7->M7_VALDOM}
		nDiasSeg := 0									//-- Qtde Segundas trabalhadas
		nDiasTer := 0									//-- Qtde Tercas trabalhadas
		nDiasQua := 0									//-- Qtde Quartas trabalhadas
		nDiasQui := 0									//-- Qtde Quintas trabalhadas
		nDiasSex := 0									//-- Qtde Sextas trabalhadas
		nDiasSab := 0									//-- Qtde Sabados trabalhadas
		nDiasDom := 0
		nDias    := 0
		nDNUtil	 := 0
		nDUtil	 := 0

		nDiaNUtil := SM7->M7_QDNUTIL //Qtde vale em dias não úteis de VT
		nDiaUtil  := SM7->M7_QDIAINF //Qtde vale em dias úteis de VT
		nDiasProp := SM7->M7_DPROPIN
		nValUni	  := PosAlias( "SRN" , SM7->M7_CODIGO , xFilial("SRN") , "RN_VUNIATU" , 1 )
		nDiasFix  := PosAlias( "SRN" , SM7->M7_CODIGO , xFilial("SRN") , "RN_DIASFIX" , 1 )

		If !lUsaCPer .And. SM7->M7_VALFIX > 0
			nDiasFix := SM7->M7_VALFIX
		EndIf

		If SM7->M7_DPROPIN == 99 //Se diasprop for 99 não calcula meio de transporte
			SM7->(DbSkip())
			Loop
		EndIf

		If lComplS151 
            If lPeriodico .Or. ( nDiasProp > 0 .Or. nDiasFix > 0 )
                SM7->( dbSkip() )
                Loop
		    EndIf
            aCfgS151 := fS151SM7( aTabS151, "0", SM7->M7_CODIGO )
		EndIf

		If lPeriodico //complemento
			nDiasFix	:= 0
			If aPergunte[11,3] > 0
				nDiaUtil	:= aPergunte[11,3]
			EndIf
			aPergunte[6,3] 	:= 0 //vales a deduzir
		EndIf

		If __lMemCalc
			fAddMemLog("Benefício : " + SM7->M7_CODIGO ,1,2)
			fAddMemLog("Benefício avulso : " +If(SM7->M7_COMPL=="1","Sim","Não") ,1,2)
			fAddMemLog("Dias da semana preenchidos : " +If(lDias,"Sim","Não") ,1,2)
			fAddMemLog("Dias fixos : " + cvaltochar(nDiasFix) ,1,2)
			fAddMemLog("Quantidade de vales dias úteis : " + cvaltochar(nDiaUtil) ,1,2)
			fAddMemLog("Quantidade de vales dias não úteis : " + cvaltochar(nDiaNUtil) ,1,2)
			fAddMemLog("Quantidade de vales proporcionais : " + cvaltochar(nDiasProp) ,1,2)
			If lPeriodico
				fAddMemLog("Vales por dia informados : " + cvaltochar(nDiaUtil) ,1,2)
			EndIf
			fAddMemLog("Vales a deduzir informado : " + cvaltochar(aPergunte[6,3]) ,1,2)
			fAddMemLog("Faltas  : " + cvaltochar(nFaltas) ,1,2)
			fAddMemLog("Valor Unitário  : " + Transform(nValUni,"@E 999,999,999.99") ,1,2)
		EndIf

		If aPergunte[1,3] == 2 //Se for calculo da diferenca
			SQY->(dbSeek(xFilial("SQY")+SM7->M7_CODIGO+dtos(aPeriodo[nPosSem,3]),.T.))
			If SQY->QY_COD == SM7->M7_CODIGO .AND. (SQY->QY_DATVIGE >= aPeriodo[nPosSem,3] .and. SQY->QY_DATVIGE <= aPeriodo[nPosSem,4])
				nValUniAnt := SQY->QY_VUNIANT
				nValUniDif := nValUni - nValUniAnt
				nDiasVtr := 0
				For nh := 1 to Len(aDiasMes)
					If aDiasMes[nh][1] >= SQY->QY_DATVIGE .and. aDiasMes[nh][4]
						nDiasVTR ++
					EndIf
				Next nh
			Else
				nValUniAnt := PosAlias( "SRN" , SM7->M7_CODIGO , xFilial("SRN") , "RN_VUNIANT" , 1 )
				nValUniDif := nValUni - nValUniAnt
				nDiasVTR   := aPeriodo[nPosSem,11] //RCF_DDIFVT
			EndIf
			If SRA->RA_TPCONTR == "3" //Se for contrato intermitente
				nDiasVTR := 0
				aEval(aConvoc,{|x| nDiasVTR += x[5]})
			EndIf
			nValVTR    := (nDiasVTR  * nDiaUtil) * nValUniDif
			nDiasProp  := 0	//Zera pois nao sera utilizado
		Else
			nDiaTran  := 0
			nDiaNTran := 0
			If Empty(nDiasFix) .And. Empty(nDiasProp)	//Caso informe dias proporcionais ou fixos, considera os dias informados ao invés de calcular
				If SRA->RA_TPCONTR == "3" //Se for contrato intermitente
					nDiaUCal := 0
					aEval(aConvoc,{|x| nDiaUCal += x[5]})
					nDiaUCal  := Max(( nDiaUCal * nDiaUtil ) - aPergunte[6,3],0)
					lDias	 := .F. //Sempre será calculado pelos dias de convocação
				ElseIf !lUsaCPer .And. Len(aTabCalend) > 1 .And. lDias
					
					GetDiasTab( aTabCalend, aDiaVales, lPropFerias, lFeriado, .T., nDiaUtil, nDiaNUtil, @nDiasSeg, @nDiasTer, @nDiasQua, @nDiasQui, @nDiasSex, @nDiasSab, @nDiasDom, @nDias, @nDiaNTran, lComplS151, aCfgS151 )

					lGrvRU1 := .T.
                    //-- Calculo dos Dias Uteis     ( Qtde de cada dia semana * No vales de cada dia da semana ) - deducao
					nDiaTran := nDiasSeg + nDiasTer + nDiasQua + nDiasQui + nDiasSex  + nDiasSab + nDiasDom
					
					nDiasPonto	:= ( ( nDiasSeg * SM7->M7_VALSEG) + ( nDiasTer * SM7->M7_VALTER ) + ( nDiasQua *  SM7->M7_VALQUA ) + ( nDiasQui * SM7->M7_VALQUI ) + ( nDiasSex * SM7->M7_VALSEX ) + ( nDiasSab * IIf( !lComplS151 .Or. SM7->M7_VALSAB > 0, SM7->M7_VALSAB, nDiaUtil ) ) + ( nDiasDom * IIf( !lComplS151 .Or. SM7->M7_VALDOM > 0, SM7->M7_VALDOM, nDiaUtil ) ) )

					nDiaUCal  := nDiasPonto - Iif( !lComplS151, aPergunte[6, 3], 0 )
					nDiaNUCal := 0

					If nFaltas > 0 .and. Len(aFaltas) > 0
						If SM7->M7_VALDOM > 0
							nFalAux += aFaltas[1] * SM7->M7_VALDOM
						EndIf
						If SM7->M7_VALSEG > 0
							nFalAux += aFaltas[2] * SM7->M7_VALSEG
						EndIf
						If SM7->M7_VALTER > 0
							nFalAux += aFaltas[3] * SM7->M7_VALTER
						EndIf
						If SM7->M7_VALQUA > 0
							nFalAux += aFaltas[4] * SM7->M7_VALQUA
						EndIf
						If SM7->M7_VALQUI > 0
							nFalAux += aFaltas[5] * SM7->M7_VALQUI
						EndIf
						If SM7->M7_VALSEX > 0
							nFalAux += aFaltas[6] * SM7->M7_VALSEX
						EndIf
						If SM7->M7_VALSAB > 0
							nFalAux += aFaltas[7] * SM7->M7_VALSAB
						EndIf
						nDiaUCal -= nFalAux
					EndIf
				Else
					If !Empty(aDiasMes) .Or. lComplS151//Se existir dados no array aDiasMes, utiliza estes dados para montar dias uteis e nao uteis de vale transporte
						If __lMemCalc
							fAddMemLog("Calendário analítico" ,1,2)
						EndIf
                        lGrvRU1  := .T.
						If lPeriodico
							nPos := aScan(aDiasMes,{|x| x[1] == aPergunte[12,3]})
						EndIf
						If nPos == 0
							nPos := 1
						EndIf
						For nX := nPos to Len(aDiasMes)
                            If lComplS151 .And. !fVldS151( aCfgS151, "0", SM7->M7_CODIGO, aDiasMes[nX, 1], aDiasMes[nX, 6] )
                                Loop
                            EndIf
							If aDiasMes[nX, 3] == "1"
                                If aDiasMes[nX, 2] == "1"
                                    nDUtil++
                                Else
                                    nDNUtil++
                                EndIf
                            EndIf
                            If (!lUsaCPer .And. aDiasMes[nX,4]) .Or. (aDiasMes[nX,2] == "1" .and. (Empty(dDataDem) .OR. aDiasMes[nX,1] < dDataDem) .and. aDiasMes[nX,4])
								nDiaTran        += 1
                                aDiasMes[nX, 7] := nDiaUtil
							ElseIf (!lUsaCPer .And. aDiasMes[nX,4]) .Or. (aDiasMes[nX,2] <> "1" .and. (Empty(dDataDem) .OR. aDiasMes[nX,1] < dDataDem) .and. aDiasMes[nX,4])
								nDiaNTran       += 1
                                aDiasMes[nX, 7] := Iif( nDiaNUtil > 0, nDiaNUtil, nDiaUtil )
							EndIf
							If lPeriodico .And. aDiasMes[nX][1]==aPergunte[13,3]
								exit
							EndIf
						Next nX
					Else //do contrario utiliza cadastro de periodo - RCF_DUTILT e RCF_DNUTIL
						If __lMemCalc
							fAddMemLog("Calendário sintético" ,1,2)
						EndIf

						If lPeriodico
							nDiaTran  := DateDiffDay( aPergunte[12,3],aPergunte[13,3] ) + 1
							nDiaNTran := 0
						Else
							nDiaTran  := aPeriodo[nPosSem,10]
							nDiaNTran := aPeriodo[nPosSem,9]
						EndIf
					EndIf
					If __lMemCalc
						fAddMemLog("Dias úteis : " +  cvaltochar(nDiaTran) ,1,3)
						fAddMemLog("Dias não úteis : " +  cvaltochar(nDiaNTran) ,1,3)
					EndIf
					nDiaUCal  := ( nDiaTran * nDiaUtil ) - Iif( !lComplS151, aPergunte[6, 3], 0 )
					nDiaNUCal := nDiaNTran * Iif( !lComplS151 .Or. nDiaNUtil > 0, nDiaNUtil, nDiaUtil )
				EndIf
			EndIf

			// Ponto de entrada para alteracao dos dias de vales e dias trabalhados no mes.
			If lGPVTRDias
				aVTRDias := {}
				aAdd(aVTRDias , {nDiaNTran, nDiaTran, nDiasProp, nDiasFix } )
				aVTRDias := ExecBlock("GPVTRDias",.F.,.F.)

				If ValType(aVTRDias) == "A" .And. Len(aVTRDias) > 0 .And. Len(aVTRDias[1]) >= 4
					nDiaNTraPE	:= aVTRDias[1,1]
					nDiaTraPE	:= aVTRDias[1,2]
					nDiasProp	:= aVTRDias[1,3]
					nDiasFix	:= aVTRDias[1,4]
				EndIf

				If ( nDiaNTraPE != nDiaNTran ) .Or. ( nDiaTraPE != nDiaTran )	//Se qtde. de dias úteis ou não úteis for alterada,
					nDiaNUCal += ( (nDiaNTraPE - nDiaNTran) * nDiaNUtil )
					nDiaUcal += ( (nDiaTraPE - nDiaTran) * nDiaUtil )			//soma com a quantidade de vales já calculada
					nDiaNTran := nDiaNTraPE
					nDiaTran  := nDiaTraPE										//e dias prop passa a ser informado
				EndIf
			EndIf

			//Considera dias fixos caso use integração com Serviços; para os demais, apenas considera fixos caso não informe dias proporcionais
			If nDiasFix > 0 .And. ( Empty(SM7->M7_DPROPIN) .Or. fIntRHGS() )
				nDiaTran  := nDiasFix
				nDiaNTran := 0
				nDiasProp := nDiasFix
			ElseIf !Empty(SM7->M7_DPROPIN) .And. nDiasProp > 0	//Caso informe dias proporcionais, considera o valor como dias úteis de VT e zera dias não úteis
				nDiaTran  := nDiasProp
				nDiaNTran := 0
				nDiaNUCal := 0
				nDiaUcal  := ( nDiaTran * nDiaUtil ) - aPergunte[6,3]
			EndIf

			If !lSP7 .And. nFaltas > 0 .And. nFaltas >= nDiaTran
				If lPeriodico
					dDt1	:= aPergunte[12,3]
					dDt2	:= aPergunte[13,3]
				Else
					dDt1	:= aPeriodo[nPosSem,3]
					dDt2	:= aPeriodo[nPosSem,4]
				EndIf
				GravaSP7(nDiaTran,dDt1,dDt2)
				lSP7 := .T.
			EndIf

			nDiasVTR  := Max( If( nDiasFix > 0 .And. ( Empty(SM7->M7_DPROPIN) .Or. fIntRHGS() ), nDiasFix * nDiaUtil, If (!lUsaCPer .And. Len(aTabCalend) > 1 .And. lDias, nDiaUCal ,nDiaUCal + nDiaNUCal - ( nFaltas * nDiaUtil ) ) ), 0 )
			nValVTR  := nDiasVTR * nValUni
			If __lMemCalc .And. nValVTR > 0
				fAddMemLog("Dias de cálculo : " +  cvaltochar(nDiasVTR) ,1,2)
				fAddMemLog("Valor cálculo : " +  Transform(nValVTR,"@E 999,999,999.99") ,1,2)
			EndIf
		EndIf

        nValOri := nValVTR

        If P_RECALCVT .And. !lPeriodico .And. aPergunte[1, 3] == 1
            If Empty(aPerAux)
                fRetBenAnt( SRA->RA_FILIAL, SRA->RA_MAT, SRA->RA_PROCES, "1", @aPerAux, .T. )
            EndIf
            If Len(aPerAux) > 0
                nTotDif := fApurPAnt( aPerAux[1], "0", Nil, SM7->M7_CODIGO )[1]
            EndIf
            If nTotDif != 0
                If __lMemCalc
                    fAddMemLog( "Código do vale recalculado : " + SM7->M7_CODIGO, 1, 2 )
                    fAddMemLog( "Valor diferença mês anterior : " + Transform(nTotDif, "@E 999,999,999.99"), 1, 2 )
                EndIf
                If nTotDif > 0 //Se houver diferença positiva para pagar em relação ao mês anterior, soma no valor total do VT
                    nValVTR += nTotDif
                    nTotDif := 0
                ElseIf ( nValVTR + nTotDif ) >= 0
                    nValVTR += nTotDif
                    nTotDif := 0
                Else
                    nTotDif += nValVTR
                    nValVTR := 0
                EndIf
            EndIf
        EndIf

		nTotVTR += nValVTR
		cKeyAux := SM7->(M7_FILIAL+M7_MAT+M7_TPVALE+M7_CODIGO)

		If !lComplS151 .Or. nDiasVTR > 0
            aAdd( aVTCalc, { cKeyAux, nDiasVTR, nValUni, nValVTR, nCustFunc, (nValVTR-nCustFunc), nValUniDif, nDiasProp, 0, SM7->M7_CODIGO, Iif( nDias > 0, nDias, nDiaTran ), nDiaUtil, nDiaNUtil, SM7->M7_TPCALC, aDiaVales, SM7->M7_VALFIX, Iif( !Empty(nDNUtil), nDNUtil, nDiaNTran ), nDUtil, "", Iif( lGrvRU1, aClone(aDiasMes), {} ), 0, nValOri, Iif( lGrvRU1, aClone(aDiasAnt), {} ) } )
        EndIf

        If nTotDif < 0 //Grava o saldo negativo
            aVTCalc[Len(aVTCalc), 21] := nTotDif
        EndIf

		If SM7->M7_COMPL == "1"
			RecLock("SM7",.F.)
			SM7->(dbDelete())
			SM7->(msUnlock())
		EndIf

		SM7->(dbSkip())

	EndDo
EndIf

If __lMemCalc
	fAddMemLog("Total VTR : " +  Transform(nTotVTR,"@E 999,999,999.99") ,1,2)
	fAddMemLog("Percentual funcionário  : " +  Transform(nPercentual,"@E 999,999,999.99") + " %" ,1,2)
	fAddMemLog("Teto do custo VT = salário base * percentual : " +  Transform(nCustFunc,"@E 999,999,999.99")  ,1,2)
	
EndIf

For nX := 1 to Len(aVTCalc)
	aVTCalc[nX,9] := nTotVTR //Atualiza valor total de vale transporte
	If nCustFunc > nTotVTR
		aVTCalc[nX,5] := aVtCalc[nX,4] //Se Custo funcionario for maior que soma do total de VT, custo do funcinario passa a ser o valor total do VT
		aVTCalc[nX,6] := 0
	Else
		If nX == Len(aVTCalc)
			aVTCalc[nX,5] := nCustFunc - nCustAux //Rateia custo do VT
			aVTCalc[nX,6] := aVTCalc[nX,4] - aVTCalc[nX,5] //Custo Empresa
		Else
			aVTCalc[nX,5] := Round(aVTCalc[nX,5] / nTotVTR * aVTCalc[nX,4],2) //Rateia custo do VT
			aVTCalc[nX,6] := aVTCalc[nX,4] - aVTCalc[nX,5] //Custo Empresa
			nCustAux += aVTCalc[nX,5]
		EndIf
	EndIf
Next nX

RestArea(aArea)

Return Nil

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFunction³fVTRGrvN 	   ºAutor  ³Leandro Drumond  º Data ³  29/07/2013 º±±
±±ÌÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.   ³Gravacao do calculo do vale transporte					      º±±
±±º        ³                                                              º±±
±±ÌÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso     ³ Roteiro de Calculo                                           º±±
±±ÈÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function fVTRGrvN(aVTCalc)

Local aArea		:= GetArea()
Local cNumPed   := ""
Local cKey		:= ""
Local cCodCCT 	:= ""
Local nX		:= 0
Local nPos      := 0
Local lNovo		:= .T.
Local lPeriodico:= aPergunte[1,3] == 3//Avulso/Complemnto/Semanal/diario
Local lGpem040  := FunName() == "GPEM040" .or. FunName() == "GPEM040B"
Local lTemIndex := .F.

DEFAULT lGPM5001   := ExistBlock("GPM5001")
DEFAULT lTemCCT	   := SR0->(ColumnPos("R0_CODCCT")) > 0
DEFAULT lTemQtVD   := SR0->(ColumnPos("R0_QTVDEDU")) > 0
DEFAULT lTemRU1	   := AliasInDic("RU1")
DEFAULT lTemRecalc := Iif( lTemRU1, RU1->( ColumnPos("RU1_RECALC") ) > 0, .F. )
DEFAULT lTemSldAnt := SR0->( ColumnPos("R0_SLDANT") ) > 0
DEFAULT aM7Inativ  := {}

If lGpem040 //Se for rescisão, inclui valores calculados no array para desconto na rescisão

	aBenefRes[1] := aClone(aVTCalc)

Else

	If lTemCCT .and. !Empty(SRA->RA_SINDICA)
		cCodCCT := fBuscaCCT(SRA->RA_SINDICA)
	EndIf

	DbSelectArea("SR0")

	//Indice incluído na 12.1.2210 junto com alteração de chave única para possibilitar a gravação de dois períodos diferentes.
	DEFAULT nOrderSR0 := RetOrder("SR0", "R0_FILIAL+R0_MAT+R0_TPVALE+R0_PERIOD+R0_NROPGT")

	If nOrderSR0 <= 1
		nOrderSR0 := RetOrder("SR0", "R0_FILIAL+R0_MAT+R0_TPVALE+R0_CODIGO+R0_PEDIDO")
	EndIf

	lTemIndex := nOrderSR0 > 3

	SR0->(DbSetOrder(nOrderSR0))

	// Exclui cálculo anterior para o mesmo período, caso exista
	cKey := SRA->RA_FILIAL + SRA->RA_MAT + "0" + If(lTemIndex, cPeriodo + cNumPag,"")
	If SR0->(dbSeek(cKey))
		While SR0->(R0_FILIAL + R0_MAT + R0_TPVALE + If(lTemIndex, R0_PERIOD + R0_NROPGT,"")) == cKey
			//Somente deleta o cálculo se for recálculo. Caso o pedido já tenha sido emitido, não deleta.
			If SR0->R0_DTREFI == aPeriodo[nPosSem, 3] .And. SR0->R0_DTREFF == aPeriodo[nPosSem, 4] .And. SR0->R0_PEDIDO == "1" .AND. aPergunte[1,3] != 2 ;
				.Or. (Empty(SR0->R0_DTREFI) .And. Empty(SR0->R0_DTREFF) .And. SR0->R0_PEDIDO != "2")
				//Se já existir um cálculo em aberto, quer dizer que é recálculo, então armazena o numero do pedido já utilizado.
				If ( nPos := aScan(aVTCalc, {|x| x[1] == SR0->R0_FILIAL+SR0->R0_MAT+SR0->R0_TPVALE+SR0->R0_CODIGO}) ) > 0
					aVTCalc[nPos,19] := SR0->R0_NROPED
				EndIf
				//Se existe cálculo e foi alterado para inativo, não deleta.
				If aScan(aM7Inativ, {|x| x[1] == SR0->R0_FILIAL+SR0->R0_MAT+SR0->R0_TPVALE+SR0->R0_CODIGO}) > 0
					SR0->(dbSkip())
					Loop
				EndIf
				Reclock("SR0", .F.)
				SR0->(dbDelete())
				SR0->(MsUnlock())
                If lTemRU1
                    If RU1->( dbSeek( SR0->R0_FILIAL+SR0->R0_MAT+SR0->R0_TPVALE+SR0->R0_CODIGO+SR0->R0_NROPED ) )
                        While RU1->( !Eof() ) .And. RU1->RU1_FILIAL+RU1->RU1_MAT+RU1->RU1_TPVALE+RU1->RU1_CODIGO+RU1->RU1_NROPED == SR0->R0_FILIAL+SR0->R0_MAT+SR0->R0_TPVALE+SR0->R0_CODIGO+SR0->R0_NROPED 
                            If RU1->( Reclock("RU1", .F.) )
                                RU1->( dbDelete() )
                                RU1->( MsUnlock() )
                            EndIf
                            RU1->( dbSkip() )
                        End
                    EndIf
                EndIf
			EndIf
			SR0->(dbSkip())
		EndDo
		SR0->(dbGoTop())
	EndIf

	aM7Inativ := {}

	For nX := 1 to Len(aVTCalc)
		lNovo 	  := .T.
		cNumPed   := ""
		If SR0->(DbSeek(aVTCalc[nX, 1] + "1"))
			While SR0->( !EoF() ) .And. SR0->R0_FILIAL+SR0->R0_MAT+SR0->R0_TPVALE+SR0->R0_CODIGO+SR0->R0_PEDIDO == aVTCalc[nX, 1] + "1"
				If SR0->R0_NROPGT == aPeriodo[nPosSem, 2]  .and. (!lTemIndex .or. SR0->R0_PERIOD == cPeriodo)
					lNovo := .F.
					Exit
				EndIf
				SR0->( dbSkip() )
			EndDo
		EndIf
		If !lNovo .And. !Empty(SR0->R0_NROPED)
			cNroPed := SR0->R0_NROPED
		ElseIf lNovo
			cNumPed := aVTCalc[nX,19]
		EndIf
		If Reclock( "SR0" , lNovo)
			If aVTCalc[nX,8] > 0  .OR. (lUsaCPer .And. (aVTCalc[nX,11] != aPeriodo[nPosSem,10]))
				SR0->R0_DPROPIN := aVTCalc[nX,8]	// Grava apenas se utilizou o campo R0_DPROPIN
			Else
				SR0->R0_DPROPIN := 0
			EndIf
			SR0->R0_FILIAL	:= SRA->RA_FILIAL
			SR0->R0_MAT		:= SRA->RA_MAT
			SR0->R0_TPVALE	:= "0"
			SR0->R0_CODIGO	:= aVTCalc[nX,10]
			SR0->R0_DIASPRO	:= aVTCalc[nX,11]
			SR0->R0_QDIAINF	:= aVTCalc[nX,12]
			SR0->R0_QDNUTIL	:= aVTCalc[nX,13]
			SR0->R0_TPCALC	:= aVTCalc[nX,14]
			SR0->R0_ROTEIR	:= cRot
			SR0->R0_PERIOD 	:= cPeriodo
			SR0->R0_NROPGT	:= cNumPag
			SR0->R0_ANOMES	:= SubSTr(cPeriodo,5,2) + SubSTr(cPeriodo,1,4)
			SR0->R0_PEDIDO	:= "1"
			SR0->R0_QVALSEG  := aVTCalc[nX,15,1]
			SR0->R0_QVALTER  := aVTCalc[nX,15,2]
			SR0->R0_QVALQUA  := aVTCalc[nX,15,3]
			SR0->R0_QVALQUI  := aVTCalc[nX,15,4]
			SR0->R0_QVALSEX  := aVTCalc[nX,15,5]
			SR0->R0_QVALSAB  := aVTCalc[nX,15,6]
			SR0->R0_QVALDOM  := aVTCalc[nX,15,7]
			SR0->R0_QVALFIX  := aVTCalc[nX,16]

			If lPeriodico
				SR0->R0_DTREFI	:= aPergunte[12,3]
				SR0->R0_DTREFF	:= aPergunte[13,3]
			Else
				SR0->R0_DTREFI	:= aPeriodo[nPosSem,3]
				SR0->R0_DTREFF	:= aPeriodo[nPosSem,4]
			EndIf

			If lNovo
				//Caso não exista pedido, pode ser novo mês ou mais de 1 pedido no mês, então assume o novo número do pedido.
				If cNumPed <> ""
					cNroPed := cNumPed
				EndIf
				SR0->R0_NROPED	:= GetNroPed()
			EndIf
			SR0->R0_TPBEN	:= BuscaTBen(SR0->R0_TPVALE,SR0->R0_CODIGO,SR0->R0_FILIAL)

			SR0->R0_DUTILM	:= If(!Empty(aVTCalc[nX,18]), aVTCalc[nX,18], aVTCalc[nX,11])	//Dias Uteis no Mês - campo RCF_DUTILT
			SR0->R0_DNUTIM	:= aVTCalc[nX,17]			//Dias Não Uteis no Mês - campo RCF_DNUTIL
			SR0->R0_SALBASE	:= nSalmes					//Salário Base
			SR0->R0_CC		:= SRA->RA_CC				//Centro de Custo do Funcionário
			SR0->R0_FALTAS 	:= nFaltas					//Dias correspondentes à faltas (mnemônico NFALTAS)
			SR0->R0_FERIAS 	:= nFerVen					//Dias correspondentes a férias (mnemônico NFERVEN)
			SR0->R0_AFAST 	:= nDiasAfas				//Dias correspondentes a afastamentos (mnemônico NDIASAFAS)

			If aPergunte[1,3] == 2
				SR0->R0_QDIADIF	:= aVTCalc[nX,2]	//Dias de Difer. calculados
				SR0->R0_VALDIF 	:= aVTCalc[nX,4]	//Valor de Dif. VTR calculado
				SR0->R0_CUNIDF 	:= aVTCalc[nX,7]	//Custo Unitário de Difer. (RN_VUNIATU - RN_VUNIANT)
				SR0->R0_CFUNDF	:= aVTCalc[nX,5]	//Custo Funcionário Difer.
				SR0->R0_CEMPDF	:= aVTCalc[nX,6]	//Custo Empresa Difer.
			Else
				SR0->R0_QDIACAL	:= aVTCalc[nX,2]	//Dias calculados
				SR0->R0_VALCAL 	:= aVTCalc[nX,4] 	//Valor VTR calculado
				SR0->R0_VLRVALE	:= aVTCalc[nX,3]	//Custo Unitário
				SR0->R0_VLRFUNC	:= aVTCalc[nX,5] 	//Custo Funcionário
				SR0->R0_VLREMP 	:= aVTCalc[nX,6]	//Custo Empresa
			EndIf

			If lTemSldAnt
				SR0->R0_SLDANT  := aVTCalc[nX, 21]	//Saldo negativo
				SR0->R0_VALORI	:= aVTCalc[nX, 22]	//Valor Calculado originalmente
			EndIf

			If lTemCCT
				SR0->R0_CODCCT 	:= cCodCCT	//Convenção Coletiva de Trabalho
			EndIf

			If lTemQtVD .AND. aPergunte[6,3] > 0
				SR0->R0_QTVDEDU := aPergunte[6,3]	//Quantidade de vales a deduzir
			EndIf

			SR0->( MsUnLock() )

			//PE para gravar campos personalizados
			If lGPM5001
				ExecBlock("GPM5001",.F.,.F.)
			EndIf
		EndIf

        If lTemRU1
            If Len(aVTCalc[nX]) >= 20
                fGravaRU1( aVTCalc[nX, 20] )
            EndIf
            If lTemRecalc .And. Len(aVTCalc[nX]) >= 23
                fGravaRU1( aVTCalc[nX, 23], .T. )
            EndIf
        EndIf

		If cNumPed <> ""
			cNroPed := "" //Zera static para não usar o mesmo número para outro funcionário causando chave duplicada.
		EndIf

	Next nX

	CustoVales("0")

	RestArea(aArea)

EndIf

Return Nil

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFunction³fVRFCalcN 	   ºAutor  ³Leandro Drumond  º Data ³  03/08/2013 º±±
±±ÌÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.   ³Efetua o calculo do vale refeicao   					      º±±
±±º        ³                                                              º±±
±±ÌÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso     ³ Roteiro de Calculo                                           º±±
±±ÈÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function fVRFCalcN(aVRCalc)

Local aArea			:= GetArea()
Local aCfgS151		:= {}
Local aPerAux		:= {}
Local aDias			:= {}
Local aTabS151		:= {}
Local cFilFunc  	:= SRA->RA_FILIAL
Local cMatFunc  	:= SRA->RA_MAT
Local cKeyAux		:= ""
Local lGrvRU1		:= .F.
Local lPropin		:= .F.
Local lPriVez		:= .T.
Local nCustFunc 	:= 0
Local nCustEmp		:= 0
Local nValVRF		:= 0
Local nDiaInf		:= 0
Local nValUni		:= 0
Local nPerc			:= 0
Local nTeto			:= 0
Local nDiasFix		:= 0
Local nDiaRef		:= 0
Local nDiaNRef		:= 0
Local nDiaCal		:= 0
Local nX			:= 0
Local nTotDif		:= 0
Local nValOri		:= 0
Local nDiasProp 	:= 0
Local lPeriodico	:= aPergunte[6,3] == 1//Avulso/Complemnto/Semanal/diario
Local nPos			:= 0
Local nDiasSeg 		:= 0									//-- Qtde Segundas trabalhadas
Local nDiasTer 		:= 0									//-- Qtde Tercas trabalhadas
Local nDiasQua 		:= 0									//-- Qtde Quartas trabalhadas
Local nDiasQui 		:= 0									//-- Qtde Quintas trabalhadas
Local nDiasSex 		:= 0									//-- Qtde Sextas trabalhadas
Local nDiasSab 		:= 0									//-- Qtde Sabados trabalhadas
Local nDiasDom 		:= 0									//-- Qtde Domingos trabalhadas
Local nDiasPonto 	:= 0
Local nDiaUtil		:= 0
Local nDiaNUtil		:= 0
Local nDUtil		:= 0
Local nDNUtil		:= 0
Local nAuxUtil		:= 0
Local nAuxNUtil		:= 0
Local nFalAux		:= 0
Local lComplS151	:= cPaisLoc == "BRA" .And. ValType(MV_PAR08) == "N" .And. MV_PAR08 == 1
Local lDias			:= .F.
Local lFeriado 		:= .F.
Local lPropFerias	:= APERGUNTE[3,3] == 1
Local aTabCalend	:= If (!lUsaCPer,fCarPonto(),{})
Local aDiaVales		:= {}
Local lSP7			:= .F.
Local dDt1			:= ctod("")
Local dDt2			:= ctod("")
Local nDiasPer		:= If(GetMvRH("MV_DIASPER",,"1") == "1",nDiasP,(If(SRA->RA_TIPOPGT =="M", P_QTDIAMES, P_NTOTDIAS)))
Local nDiaNTraPE	:= 0
Local nDiaTraPE		:= 0

Private aVRFDias    := {}

DEFAULT __lMemCalc	:= cPaisLoc == "BRA" .And. fMemCalc() // Memória de Cálculo
DEFAULT lGPVRFDias  := ExistBlock("GPVRFDias")
DEFAULT lCpoSts     := SM7->(ColumnPos("M7_STAT")) > 0 
DEFAULT aM7Inativ   := {}

If !lUsaCPer .And. Len(aTabCalend) > 1
	SPA->( dbSeek( xFilial("SPA", SRA->RA_FILIAL ) + aTabCalend[1,23] ) )
	lFeriado := ( SPA->PA_FERIADO == "S" .Or. ( SPA->( Type("PA_RECBENF") ) != "U" .And. SPA->PA_RECBENF == "1" ) )
EndIf

If __lMemCalc
	fAddMemLog("Calendário utilizado (MV_USACPER) : " +If(lUsaCPer,"Folha","Ponto") ,1,2)
	fAddMemLog("Considera feriado cadastro de regra (SPA) : " + If(lFeriado,"Sim","Não") ,1,2)
	If !lUsaCPer
		fAddMemLog("Tabela padrão do ponto carregada : " + If(Len(aTabCalend) > 1 ,"Sim","Não") ,1,2)
	EndIf
	fAddMemLog("Proporcional a férias : " + If(lPropFerias,"Sim","Não") ,1,2)
	fAddMemLog("Cálculo periódico : " + If(lPeriodico,"Sim","Não") ,1,2)
	fAddMemLog("Dias período : " + cvaltochar(nDiasPer) ,1,2)
EndIf

aVRCalc	  := {}

DbSelectArea("RFO")
RFO->(DbSetOrder(RetOrder("RFO","RFO_FILIAL+RFO_TPVALE+RFO_CODIGO")))

DbSelectArea("SM7")
SM7->(DbSetOrder(RetOrder("SM7", "M7_FILIAL+M7_MAT+M7_TPVALE+M7_CODIGO")))

If SM7->(DbSeek(cFilFunc + cMatFunc + "1") )

    If lComplS151
        fCarrTab( @aTabS151, "S151", dDataBase, .T., cPeriodo )
		If Empty(aTabS151)
			CMSGLOG := STR0047 + "https://tdn.totvs.com/pages/releaseview.action?pageId=776129138" //"Para que o cálculo seja efetuado com a opção 'Complemento por HE' ativa é necessário o preenchimento da tabela S151 conforme documentação: "
			S_MSGLOG()
			FINALCALC()
			Return()
		EndIf
    EndIf

	While SM7->(!Eof() .and. M7_FILIAL + M7_MAT + M7_TPVALE == cFilFunc + cMatFunc + "1") 

		If lCpoSts .And. SM7->M7_STAT == "1"
			aAdd(aM7Inativ, {SM7->M7_FILIAL + SM7->M7_MAT + SM7->M7_TPVALE + SM7->M7_CODIGO})
			SM7->(dbSkip())
			Loop
		EndIf

		lGrvRU1 := .F.
		nFalAux := 0

		If lPeriodico .And. aPergunte[10,3] == 1 .And. SM7->M7_COMPL <> '1'
			SM7->(dbSkip())
			Loop
		EndIf

		If SM7->M7_DPROPIN == 99 //Se diasprop for 99 não calcula meio de transporte
			SM7->(DbSkip())
			Loop
		EndIf

		lDias :=  SM7->M7_VALSEG > 0 .Or. SM7->M7_VALTER  > 0 .Or. SM7->M7_VALQUA  > 0 .Or.  SM7->M7_VALQUI  > 0 .Or.  SM7->M7_VALSEX  > 0 .Or.  SM7->M7_VALSAB  > 0 .Or.  SM7->M7_VALDOM >0
		aDiaVales := {SM7->M7_VALSEG , SM7->M7_VALTER , SM7->M7_VALQUA , SM7->M7_VALQUI , SM7->M7_VALSEX , SM7->M7_VALSAB , SM7->M7_VALDOM}

		nDiasSeg := 0									//-- Qtde Segundas trabalhadas
		nDiasTer := 0									//-- Qtde Tercas trabalhadas
		nDiasQua := 0									//-- Qtde Quartas trabalhadas
		nDiasQui := 0									//-- Qtde Quintas trabalhadas
		nDiasSex := 0									//-- Qtde Sextas trabalhadas
		nDiasSab := 0									//-- Qtde Sabados trabalhadas
		nDiasDom := 0

		nDUtil	 := SM7->M7_QDIAINF
	    nDNUtil	 := SM7->M7_QDNUTIL
		nDiasProp := SM7->M7_DPROPIN
		nValUni  := 0
		nPerc	 := 0
		nTeto	 := 0
		nDiasFix := 0
		nDiaRef	 := 0
		lPropin	 := .F.
		nDiaUtil := 0
		nDiaNUtil:= 0

		If RFO->(DbSeek(xFilial("RFO")+SM7->(M7_TPVALE + M7_CODIGO)))
			nValUni  := RFO->RFO_VALOR
			nPerc	 := RFO->RFO_PERC
			nTeto	 := RFO->RFO_TETO
			nDiasFix := RFO->RFO_DIAFIX
		EndIf

		If !lUsaCPer .And. SM7->M7_VALFIX > 0
			nDiasFix := SM7->M7_VALFIX
		EndIf

		If lComplS151 
            If lPeriodico .Or. ( nDiasProp > 0 .Or. nDiasFix > 0 )
                SM7->( dbSkip() )
                Loop
		    EndIf
            aCfgS151 := fS151SM7( aTabS151, "1", SM7->M7_CODIGO )
		EndIf

		If lPeriodico //complemento
			nDiasFix	:= 0
			nDiaInf	  := SM7->M7_QDIAINF
			If aPergunte[7,3] > 0
				nDiaInf	:= aPergunte[7,3]
			EndIf
			aPergunte[5,3] 	:= 0 //vales a deduzir
		EndIf
		If __lMemCalc
			fAddMemLog("Benefício : " + SM7->M7_CODIGO ,1,2)
			fAddMemLog("Benefício avulso : " +If(SM7->M7_COMPL=="1","Sim","Não") ,1,2)
			fAddMemLog("Dias da semana preenchidos : " +If(lDias,"Sim","Não") ,1,2)
			fAddMemLog("Dias fixos : " + cvaltochar(nDiasFix) ,1,2)
			fAddMemLog("Quantidade de vales dias úteis : " + cvaltochar(nDUtil) ,1,2)
			fAddMemLog("Quantidade de vales dias não úteis : " + cvaltochar(nDNUtil) ,1,2)
			fAddMemLog("Quantidade de vales proporcionais : " + cvaltochar(nDiasProp) ,1,2)
			If lPeriodico
				fAddMemLog("Vales por dia informados : " + cvaltochar(nDiaInf) ,1,2)
			EndIf
			fAddMemLog("Vales a deduzir informado : " + cvaltochar(aPergunte[5,3]) ,1,2)
			fAddMemLog("Faltas  : " + cvaltochar(nFaltas) ,1,2)
			fAddMemLog("Valor unitário  : " + Transform(nValUni,"@E 999,999,999.99") ,1,2)
		EndIf
		If nDiasProp > 0
			nDiaRef := nDiasProp
			lPropin	:= .T.
			nDiaCal := Max( ( nDiaRef - If(nDUtil > 0,nFaltas,0) ) * If (lPeriodico, nDiaInf - aPergunte[5,3], nDUtil), 0 ) //Parametro MV_PAR05 - Deducoes
            If SM7->M7_TPCALC == "2"
                lGrvRU1 := .T.
                For nX := 1 To Len(aDiasMes)
                    If (Empty(dDataDem) .Or. aDiasMes[nX, 1] < dDataDem) .And. aDiasMes[nX, 3] == "1" .And. aDiasMes[nX, 4]
                        aDiasMes[nX, 7] := nDUtil
                    EndIf
                Next nX  
            EndIf
		Else
			If nDiasFix > 0
				nDiaRef  := nDiasFix
				nDiasProp := nDiasFix
				nDiaCal :=  nDiaRef - aPergunte[5,3] //Parametro MV_PAR05 - Deducoes
			Else

				If SRA->RA_TPCONTR == "3" //Se for contrato intermitente
					nDiaRef := 0
					aConvoc := BuscaConv(aPeriodo[nPosSem,3], aPeriodo[nPosSem,4])
					aEval(aConvoc,{|x| nDiaRef += x[5]})
					nDiaCal  := Max((nDiaRef * SM7->M7_QDIAINF) - aPergunte[5,3],0)
					lDias	 := .F. //Sempre será calculado pelos dias de convocação
				ElseIf !lUsaCPer .And. Len(aTabCalend) > 1 .And. lDias

					GetDiasTab(aTabCalend, aDiaVales, lPropFerias, lFeriado, .F., nDUtil, nDNUtil, @nDiasSeg, @nDiasTer, @nDiasQua, @nDiasQui, @nDiasSex, @nDiasSab, @nDiasDom, @nDiaUtil, @nDiaNUtil, lComplS151, aCfgS151)

                    lGrvRU1 := .T.
					//-- Calculo dos Dias Uteis     ( Qtde de cada dia semana * No vales de cada dia da semana ) - deducao
					nDiaRef := nDiasSeg + nDiasTer + nDiasQua + nDiasQui + nDiasSex  + nDiasSab + nDiasDom
					
					nDiasPonto	:= ( ( nDiasSeg * SM7->M7_VALSEG) + ( nDiasTer * SM7->M7_VALTER ) + ( nDiasQua *  SM7->M7_VALQUA ) + ( nDiasQui * SM7->M7_VALQUI ) + ( nDiasSex * SM7->M7_VALSEX ) + ( nDiasSab * IIf( !lComplS151 .Or. SM7->M7_VALSAB > 0, SM7->M7_VALSAB, nDUtil ) ) + ( nDiasDom * IIf( !lComplS151 .Or. SM7->M7_VALDOM > 0, SM7->M7_VALDOM, nDUtil ) ) )
					nDiaCal := nDiasPonto - Iif( !lComplS151, aPergunte[5,3], 0 )//Parametro MV_PAR05 - Deducoes
					
					If nFaltas > 0 .and. Len(aFaltas) > 0
						If SM7->M7_VALDOM > 0
							nFalAux += aFaltas[1]
						EndIf
						If SM7->M7_VALSEG > 0
							nFalAux += aFaltas[2]
						EndIf
						If SM7->M7_VALTER > 0
							nFalAux += aFaltas[3]
						EndIf
						If SM7->M7_VALQUA > 0
							nFalAux += aFaltas[4]
						EndIf
						If SM7->M7_VALQUI > 0
							nFalAux += aFaltas[5]
						EndIf
						If SM7->M7_VALSEX > 0
							nFalAux += aFaltas[6]
						EndIf
						If SM7->M7_VALSAB > 0
							nFalAux += aFaltas[7]
						EndIf
						nDiaCal -= nFalAux
					EndIf
				Else
					If !Empty(aDiasMes)	.Or. lComplS151//Se existir dados no array aDiasMes, utiliza estes dados para montar dias uteis e nao uteis de vale transporte (analitico)
						If __lMemCalc
							fAddMemLog("Calendário analítico " ,1,2)
						EndIf
						lGrvRU1 := .T.
                        nDiaRef := 0
						nDiaNRef:= 0
						If lPeriodico
							nPos := aScan(aDiasMes,{|x| x[1] == aPergunte[8,3]})
						EndIf
						If nPos == 0
							nPos := 1
						EndIf
						For nX := nPos to Len(aDiasMes)
                            If lComplS151 .And. !fVldS151( aCfgS151, "1", SM7->M7_CODIGO, aDiasMes[nX, 1], aDiasMes[nX, 6] )
                                Loop
                            EndIf
							If aDiasMes[nX, 3] == "1"
                                If(aDiasMes[nX, 2] == "1",nDiaUtil++,nDiaNUtil++)
                            EndIf
                            If aDiasMes[nX,4] .and. ( !lUsaCPer .Or. (aDiasMes[nX,2] == "1" .and. aDiasMes[nX,3] == "1" .and. (Empty(dDataDem) .OR. aDiasMes[nX,1] < dDataDem) ) )
								nDiaRef++
                                aDiasMes[nX, 7] := nDUtil
							ElseIf aDiasMes[nX,4] .and. aDiasMes[nX,2] <> "1" .and. aDiasMes[nX,3] == "1" .and. (Empty(dDataDem) .OR. aDiasMes[nX,1] < dDataDem)
								nDiaNRef++
                                aDiasMes[nX, 7] := Iif( nDNUtil > 0, nDNUtil, nDUtil )
							EndIf

							If lPeriodico .And. aDiasMes[nX][1]==aPergunte[9,3]
								exit
							EndIf
						Next nX
						If nDiaRef == 0 .And. nDiaNRef == 0 .And. nDiaUtil + nDiaNUtil > 0
							nDiaUtil := 0
							nDiaNUtil:= 0
						EndIf
					Else				//do contrario utiliza cadastro de periodo - RCF_DUTILT e RCF_DNUTIL (sintetico)
						If __lMemCalc
							fAddMemLog("Calendário sintético " ,1,2)
						EndIf
						If lPeriodico
							nDiaRef  := DateDiffDay( aPergunte[8,3],aPergunte[9,3] ) + 1
						ElseIf aPergunte[2,3] <> 2 .And. DiasTrab < nDiasPer
							nDiaUtil  := Int( Round( aPeriodo[nPosSem,12] * ( ( DiasTrab - ( nDiasMat + nDPrgSalMa ) ) / nDiasPer ), 2 ) )
							nDiaNUtil := 0
						Else
							nDiaUtil  := aPeriodo[nPosSem,12]
							nDiaNUtil := 0
						EndIf
					EndIf
					If __lMemCalc
						fAddMemLog("Dias úteis : " +  cvaltochar(nDiaUtil) ,1,3)
						fAddMemLog("Dias não úteis : " +  cvaltochar(nDiaNUtil) ,1,3)
					EndIf

					// O array aFaltas só é utilizado quando o lUsaCPer = .F. (Usa informações do Ponto)
					If Len(aFaltas) > 0
						aFaltas := {}
						nFalAux := nFaltas
					EndIf

					If nDiaRef > 0
						nDiaInf := If(lPeriodico .and. nDiaInf > 0, nDiaInf, nDUtil)
		    			nDiaCal := Max( ( nDiaRef -  If(nDUtil > 0,nFaltas,0) ) * nDiaInf - aPergunte[5,3], 0 ) //Parametro MV_PAR05 - Deducoes
						nDiaCal += nDiaNRef * If(lPeriodico .and. nDiaInf > 0, nDiaInf, Iif( !lComplS151 .Or. nDNUtil > 0, nDNUtil, nDUtil ))
					Else
			    		nAuxUtil  := ( nDiaUtil * If(lPeriodico .and. nDiaInf > 0, nDiaInf, nDUtil) ) - Iif( !lComplS151, aPergunte[5,3], 0 )
			    		nAuxNUtil := nDiaNUtil * If(lPeriodico .and. nDiaInf > 0, nDiaInf, Iif( !lComplS151 .Or. nDNUtil > 0, nDNUtil, nDUtil ))
			    		nDiaCal   := ( nAuxUtil + nAuxNUtil ) - ( If(nDUtil > 0,nFaltas,0) * nDUtil)
					EndIf
				EndIf
			EndIf
		EndIf

		// Ponto de entrada para alteracao dos dias de vales e dias trabalhados no mes.
		If lGPVRFDias
			aVRFDias := {}
			aAdd(aVRFDias, {nDiaNUtil, nDiaUtil, nDiasProp, nDiasFix } )
			aVRFDias := ExecBlock("GPVRFDias", .F., .F.)

			If ValType(aVRFDias) == "A" .And. Len(aVRFDias) > 0 .And. Len(aVRFDias[1]) >= 4
				nDiaNTraPE	:= aVRFDias[1,1]
				nDiaTraPE	:= aVRFDias[1,2]
				nDiasProp	:= aVRFDias[1,3]
				nDiasFix	:= aVRFDias[1,4]
			EndIf

			If ( nDiaNTraPE != nDiaNUtil ) .Or. ( nDiaTraPE != nDiaUtil )	//Se qtde. de dias úteis ou não úteis for alterada,
				nDiaCal 	+= ( (nDiaNTraPE - nDiaNUtil) * nDNUtil )
				nDiaCal 	+= ( (nDiaTraPE - nDiaUtil) * nDUtil )			//soma com a quantidade de vales já calculada
				nDiaNUtil 	:= nDiaNTraPE
				nDiaUtil  	:= nDiaTraPE									//e dias prop passa a ser informado
				nDiasRef	:= nDiaTraPE
			EndIf
		EndIf

		If !lSP7 .And. If(nDUtil > 0,nFaltas,0) > 0 .And. If(nDUtil > 0,nFaltas,0) >= nDiaRef
			If lPeriodico
				dDt1	:= aPergunte[8,3]
				dDt2	:= aPergunte[9,3]
			Else
				dDt1	:= aPeriodo[nPosSem,3]
				dDt2	:= aPeriodo[nPosSem,4]
			EndIf
			GravaSP7(nDiaRef,dDt1,dDt2)
			lSP7 := .T.
		EndIf
				
		nDiaCal := Iif( nDiaCal > 0, nDiaCal, 0)
		nValVRF := nDiaCal * nValUni
		
		If __lMemCalc .And. nValVRF > 0
			fAddMemLog("Dias de cálculo : " +  cvaltochar(nDiaCal) ,1,2)
			fAddMemLog("Valor cálculo : " +  Transform(nValVRF,"@E 999,999,999.99") ,1,2)
		EndIf

		//Inicio do trecho para recalculo dos beneficios gerados pela integração com serviços

		//Recalcula último VR pago por critérios definidos na intergração com serviços para verificar se deve ser feito algum desconto ou acréscimo
		If lPriVez .And. ( ( fIntRHGS() .AND. SuperGetMv("MV_BENEXGS",,.T.) ) .or. P_RECALBEN )
			fRetBenAnt(SRA->RA_FILIAL, SRA->RA_MAT, SRA->RA_PROCES, "1", @aPerAux)
			If Len(aPerAux) > 0
				nTotDif := fApurPAnt(aPerAux[1], "1")[1]
			EndIf
			If __lMemCalc .And. nTotDif != 0
				fAddMemLog("Integração com serviços ativada "  ,1,2)
				fAddMemLog("Valor diferença mês anterior : " +  Transform(nTotDif,"@E 999,999,999.99") ,1,2)
			EndIf

			lPriVez := .F.
		EndIf

		nValOri := nValVRF	// Guarda o valor calculado originalmente

		If nTotDif != 0

			If nTotDif > 0 //Se houver diferença positiva para pagar em relação ao mês anterior, soma no valor total do VR
				nValVRF += nTotDif
				nTotDif := 0
			ElseIf ( nValVRF + nTotDif ) >= 0
				nValVRF += nTotDif
				nTotDif := 0
			Else
				nTotDif += nValVRF
				nValVRF := 0
			EndIf

		EndIf

		//Fim do trecho para recalculo dos beneficios gerados pela integração com serviços

		nCustFunc   := Round(( nValVRF * nPerc ) / 100,2)

		If nTeto > 0
			nCustFunc   := Min(nCustFunc, nTeto)
		EndIf
		nCustEmp	:= nValVRF - nCustFunc

		If __lMemCalc .And. nPerc > 0
			fAddMemLog("Percentual desconto funcionário : " +  cvaltochar(nPerc) + " %" ,1,2)
			fAddMemLog("Teto  : " +  Transform(nTeto,"@E 999,999,999.99") ,1,2)
			fAddMemLog("Custo funcionário : " +  Transform(nCustFunc,"@E 999,999,999.99") ,1,2)
			fAddMemLog("Custo empresa : " +  Transform(nCustEmp,"@E 999,999,999.99") ,1,2)
		EndIf

		cKeyAux := SM7->(M7_FILIAL+M7_MAT+M7_TPVALE+M7_CODIGO)

		If !lComplS151 .Or. nDiaCal > 0
            aAdd( aVRCalc, { cKeyAux, nDiaCal, nValUni, nValVRF, nCustFunc, nCustEmp, nDiasRef, lPropin, SM7->M7_CODIGO, nDiasProp, nDUtil, nDNUtil, SM7->M7_TPCALC, SM7->M7_TPVALE, aDiaVales, SM7->M7_VALFIX, 0, nValOri, nDiaUtil, nDiaNUtil, Iif( nDUtil > 0, Iif( Len(aFaltas) > 0 , nFalAux, nFaltas ), 0 ), "", Iif( lGrvRU1, aClone(aDiasMes), {} ), Iif( aPergunte[5,3] > 0, nDiaCal + aPergunte[5,3], nDiaCal ), Iif( lGrvRU1, aClone(aDiasAnt), {} ) } )
        EndIf

		If SM7->M7_COMPL == "1"
			RecLock("SM7",.F.)
			SM7->(dbDelete())
			SM7->(msUnlock())
		EndIf

		SM7->(DbSkip())

	EndDo

	If nTotDif < 0 //Grava o saldo negativo no último vale calculado
		aVRCalc[Len(aVRCalc), 17] := nTotDif
	EndIf

Else // Não Encontrou Registros na SM7, mas deve recalcular o mês anterior

	If ( fIntRHGS() .AND. SuperGetMv("MV_BENEXGS",,.T.) ) .or. P_RECALBEN // Apenas integração com serviços
		fRetBenAnt(SRA->RA_FILIAL, SRA->RA_MAT, SRA->RA_PROCES, "1", @aPerAux)
		If Len(aPerAux) > 0
			aDias := fApurPAnt(aPerAux[1], "1")
			nTotDif := aDias[1]
			cCodBen := aDias[2]
		EndIf
	EndIf

	nValOri := nValVRF	// Guarda o valor calculado originalmente

	If nTotDif != 0

		//Grava na SM7
		AtuSM7Aut("1", cCodBen)

		If nTotDif > 0	// Se houver diferença positiva para pagar em relação ao mês anterior, soma no valor total do VA
			nValVRF += nTotDif
			nTotDif := 0
		ElseIf ( nValVRF + nTotDif ) >= 0	// Se houver diferença negativa, debita do total até o minimo de zero
			nValVRF += nTotDif
			nTotDif := 0
		Else
			nTotDif += nValVRF
			nValVRF := 0
		EndIf

		cKeyAux := SRA->(RA_FILIAL + RA_MAT + "1" + cCodBen)
		aAdd(aVRCalc, {cKeyAux, 0, nValUni, nValVRF, nCustFunc, nCustEmp, nDiaRef, lPropin, cCodBen, nDiasProp, nDUtil, nDNUtil, "2", "1", {0, 0, 0, 0, 0, 0, 0}, 0, nTotDif, nValOri,0,0,nFaltas,"" })

	EndIf

EndIf

RestArea(aArea)

Return Nil

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFunction³fVALCalcN 	   ºAutor  ³Leandro Drumond  º Data ³  04/08/2013 º±±
±±ÌÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.   ³Efetua o calculo do vale alimentacao   					      º±±
±±º        ³                                                              º±±
±±ÌÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso     ³ Roteiro de Calculo                                           º±±
±±ÈÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function fVALCalcN(aVACalc)

Local aArea			:= GetArea()
Local aCfgS151		:= {}
Local aDias 		:= {}
Local aPerAux 		:= {}
Local aTabS151		:= {}
Local cFilMat   	:= SRA->RA_FILIAL + SRA->RA_MAT
Local cKeyAux		:= ""
Local lGrvRU1		:= .F.
Local lPropin		:= .F.
Local nCustFunc 	:= 0
Local nCustEmp		:= 0
Local nValAli		:= 0
Local nDiaInf		:= 0
Local nValUni		:= 0
Local nPerc			:= 0
Local nTeto			:= 0
Local nDiasFix		:= 0
Local nDiaAlim		:= 0
Local nDiaNAlim		:= 0
Local nDiaCal		:= 0
Local nTotDif 		:= 0
Local nValOri		:= 0
Local nX			:= 0
Local lPeriodico	:= aPergunte[6,3] == 1//Avulso/Complemnto/Semanal/diario
Local nPos			:= 0
Local nDiasProp 	:= 0
Local nDiasSeg 		:= 0									//-- Qtde Segundas trabalhadas
Local nDiasTer 		:= 0									//-- Qtde Tercas trabalhadas
Local nDiasQua 		:= 0									//-- Qtde Quartas trabalhadas
Local nDiasQui 		:= 0									//-- Qtde Quintas trabalhadas
Local nDiasSex 		:= 0									//-- Qtde Sextas trabalhadas
Local nDiasSab 		:= 0									//-- Qtde Sabados trabalhadas
Local nDiasDom 		:= 0									//-- Qtde Domingos trabalhadas
Local nDiasPonto 	:= 0
Local nDiaUtil		:= 0
Local nDiaNUtil		:= 0
Local nDUtil		:= 0
Local nDNUtil		:= 0
Local nAuxUtil		:= 0
Local nAuxNUtil		:= 0
Local nFalAux		:= 0
Local lComplS151	:= cPaisLoc == "BRA" .And. ValType(MV_PAR08) == "N" .And. MV_PAR08 == 1
Local lDias			:= .F.
Local lFeriado 		:= .F.
Local lPropFerias	:= APERGUNTE[3,3] == 1
Local aTabCalend	:= If (!lUsaCPer,fCarPonto(),{})
Local lSP7			:= .F.
Local dDt1			:= ctod("")
Local dDt2			:= ctod("")
Local cCodBen		:= ""
Local nDiasPer		:= If(GetMvRH("MV_DIASPER",,"1") == "1",nDiasP,(If(SRA->RA_TIPOPGT =="M", P_QTDIAMES, P_NTOTDIAS)))
Local nDiaNTraPE	:= 0
Local nDiaTraPE		:= 0

Private aVALDias    := {}

DEFAULT __lMemCalc	:= cPaisLoc == "BRA" .And. fMemCalc() // Memória de Cálculo
DEFAULT lGPVALDias  := ExistBlock("GPVALDias")
DEFAULT lCpoSts     := SM7->(ColumnPos("M7_STAT")) > 0
DEFAULT aM7Inativ   := {}

If !lUsaCPer .And. Len(aTabCalend) > 1
	SPA->( dbSeek( xFilial("SPA", SRA->RA_FILIAL ) + aTabCalend[1,23] ) )
	lFeriado := ( SPA->PA_FERIADO == "S" .Or. ( SPA->( Type("PA_RECBENF") ) != "U" .And. SPA->PA_RECBENF == "1" ) )
EndIf

If __lMemCalc
	fAddMemLog("Calendário utilizado (MV_USACPER) : " +If(lUsaCPer,"Folha","Ponto") ,1,2)
	fAddMemLog("Considera feriado cadastro de regra (SPA) : " + If(lFeriado,"Sim","Não") ,1,2)
	If !lUsaCPer
		fAddMemLog("Tabela padrão do ponto carregada : " + If(Len(aTabCalend) > 1 ,"Sim","Não") ,1,2)
	EndIf
	fAddMemLog("Proporcional a férias : " + If(lPropFerias,"Sim","Não") ,1,2)
	fAddMemLog("Cálculo periódico : " + If(lPeriodico,"Sim","Não") ,1,2)
	fAddMemLog("Dias período : " + cvaltochar(nDiasPer) ,1,2)
EndIf

aVACalc	  := {}

DbSelectArea("RFO")
DbSetOrder(RetOrder("RFO","RFO_FILIAL+RFO_TPVALE+RFO_CODIGO"))

DbSelectArea("SM7")
SM7->(DbSetOrder(RetOrder("SM7", "M7_FILIAL+M7_MAT+M7_TPVALE+M7_CODIGO")))

If SM7->( DbSeek(cFilMat + "2") )

    If lComplS151
        fCarrTab( @aTabS151, "S151", dDataBase, .T., cPeriodo )
		If Empty(aTabS151)
			CMSGLOG := STR0047 + "https://tdn.totvs.com/pages/releaseview.action?pageId=776129138" //"Para que o cálculo seja efetuado com a opção 'Complemento por HE' ativa é necessário o preenchimento da tabela S151 conforme documentação: "
			S_MSGLOG()
			FINALCALC()
			Return()
		EndIf
    EndIf

	While SM7->(!Eof() .and. M7_FILIAL + M7_MAT + M7_TPVALE == cFilMat + "2") 

		If lCpoSts .And. SM7->M7_STAT == "1"
			aAdd(aM7Inativ, {SM7->M7_FILIAL + SM7->M7_MAT + SM7->M7_TPVALE + SM7->M7_CODIGO})
			SM7->(dbSkip())
			Loop
		EndIf

		lGrvRU1 := .F.
        nFalAux := 0

		If lPeriodico .And. aPergunte[10,3] == 1 .And. SM7->M7_COMPL <> '1'
			SM7->(dbSkip())
			Loop
		EndIf

		If SM7->M7_DPROPIN == 99 //Se diasprop for 99 não calcula meio de transporte
			SM7->(DbSkip())
			Loop
		EndIf

		lDias :=  SM7->M7_VALSEG > 0 .Or. SM7->M7_VALTER  > 0 .Or. SM7->M7_VALQUA  > 0 .Or.  SM7->M7_VALQUI  > 0 .Or.  SM7->M7_VALSEX  > 0 .Or.  SM7->M7_VALSAB  > 0 .Or.  SM7->M7_VALDOM >0
		aDiaVales := {SM7->M7_VALSEG , SM7->M7_VALTER , SM7->M7_VALQUA , SM7->M7_VALQUI , SM7->M7_VALSEX , SM7->M7_VALSAB , SM7->M7_VALDOM}
		nDiasSeg := 0									//-- Qtde Segundas trabalhadas
		nDiasTer := 0									//-- Qtde Tercas trabalhadas
		nDiasQua := 0									//-- Qtde Quartas trabalhadas
		nDiasQui := 0									//-- Qtde Quintas trabalhadas
		nDiasSex := 0									//-- Qtde Sextas trabalhadas
		nDiasSab := 0									//-- Qtde Sabados trabalhadas
		nDiasDom := 0
		nDiaUtil := 0
		nDiaNUtil := 0

		nDUtil	 := SM7->M7_QDIAINF
		nDNUtil	 := SM7->M7_QDNUTIL
		nDiasProp:= SM7->M7_DPROPIN
		nValUni  := 0
		nPerc	 := 0
		nTeto	 := 0
		nDiasFix := 0
		nDiaAlim := 0
		nDiaNAlim:= 0
		lPropin	 := .F.

		If RFO->(DbSeek(xFilial("RFO")+SM7->(M7_TPVALE + M7_CODIGO)))
			nValUni  := RFO->RFO_VALOR
			nPerc	 := RFO->RFO_PERC
			nTeto	 := RFO->RFO_TETO
			nDiasFix := RFO->RFO_DIAFIX
		EndIf

		If !lUsaCPer .And. SM7->M7_VALFIX > 0
			nDiasFix := SM7->M7_VALFIX
		EndIf

		If lComplS151 
            If lPeriodico .Or. ( nDiasProp > 0 .Or. nDiasFix > 0 )
                SM7->( dbSkip() )
                Loop
		    EndIf
            aCfgS151 := fS151SM7( aTabS151, "2", SM7->M7_CODIGO )
		EndIf

		If lPeriodico //complemento
			nDiasFix	:= 0
			nDiaInf	  := SM7->M7_QDIAINF
			If aPergunte[7,3] > 0
				nDiaInf	:= aPergunte[7,3]
			EndIf
			aPergunte[5,3] 	:= 0 //vales a deduzir
		EndIf
		If __lMemCalc
			fAddMemLog("Benefício : " + SM7->M7_CODIGO ,1,2)
			fAddMemLog("Benefício avulso : " +If(SM7->M7_COMPL=="1","Sim","Não") ,1,2)
			fAddMemLog("Dias da semana preenchidos : " +If(lDias,"Sim","Não") ,1,2)
			fAddMemLog("Dias fixos : " + cvaltochar(nDiasFix) ,1,2)
			fAddMemLog("Quantidade de vales dias úteis : " + cvaltochar(nDUtil) ,1,2)
			fAddMemLog("Quantidade de vales dias não úteis : " + cvaltochar(nDNUtil) ,1,2)
			fAddMemLog("Quantidade de vales proporcionais : " + cvaltochar(nDiasProp) ,1,2)
			If lPeriodico
				fAddMemLog("Vales por dia informados : " + cvaltochar(nDiaInf) ,1,2)
			EndIf
			fAddMemLog("Vales a deduzir informado : " + cvaltochar(aPergunte[5,3]) ,1,2)
			fAddMemLog("Faltas  : " + cvaltochar(nFaltas) ,1,2)
			fAddMemLog("Valor unitário  : " + Transform(nValUni,"@E 999,999,999.99") ,1,2)
		EndIf

		If nDiasProp > 0
			nDiaAlim := nDiasProp
			lPropin	 := .T.
			nDiaCal := Max( ( nDiaAlim - nFaltas ) * If(lPeriodico, nDiaInf - aPergunte[5,3], nDUtil), 0 ) //Parametro MV_PAR05 - Deducoes
            If SM7->M7_TPCALC == "2"
                lGrvRU1 := .T.
                For nX := 1 To Len(aDiasMes)
                    If (Empty(dDataDem) .Or. aDiasMes[nX, 1] < dDataDem) .And. aDiasMes[nX, 3] == "1" .And. aDiasMes[nX, 4]
                        aDiasMes[nX, 7] := nDUtil
                    EndIf
                Next nX  
            EndIf
		Else
			If nDiasFix > 0
				nDiaAlim  := nDiasFix
				nDiasProp := nDiasFix
				nDiaCal   := nDiaAlim - aPergunte[5,3] //Parametro MV_PAR05 - Deducoes
			Else
				If SRA->RA_TPCONTR == "3" //Se for contrato intermitente
					nDiaAlim := 0
					aConvoc := BuscaConv(aPeriodo[nPosSem,3], aPeriodo[nPosSem,4])
					aEval(aConvoc,{|x| nDiaAlim += x[5]})
					nDiaCal  := Max((nDiaAlim * SM7->M7_QDIAINF) - aPergunte[5,3],0)
					lDias	 := .F. //Sempre será calculado pelos dias de convocação
				ElseIf !lUsaCPer .And. Len(aTabCalend) > 1 .And. lDias

					GetDiasTab(aTabCalend, aDiaVales, lPropFerias, lFeriado, .F., nDUtil, nDNUtil, @nDiasSeg, @nDiasTer, @nDiasQua, @nDiasQui, @nDiasSex, @nDiasSab, @nDiasDom, @nDiaUtil, @nDiaNUtil, lComplS151, aCfgS151 )
					
					lGrvRU1 := .T.
                    //-- Calculo dos Dias Uteis     ( Qtde de cada dia semana * No vales de cada dia da semana ) - deducao
					nDiaAlim := nDiasSeg + nDiasTer + nDiasQua + nDiasQui + nDiasSex  + nDiasSab + nDiasDom
									
					nDiasPonto	:= ( ( nDiasSeg * SM7->M7_VALSEG) + ( nDiasTer * SM7->M7_VALTER ) + ( nDiasQua *  SM7->M7_VALQUA ) + ( nDiasQui * SM7->M7_VALQUI ) + ( nDiasSex * SM7->M7_VALSEX ) + ( nDiasSab * IIf( !lComplS151 .Or. SM7->M7_VALSAB > 0, SM7->M7_VALSAB, nDUtil ) ) + ( nDiasDom * IIf( !lComplS151 .Or. SM7->M7_VALDOM > 0, SM7->M7_VALDOM, nDUtil ) ) )
					nDiaCal := nDiasPonto - Iif( !lComplS151, aPergunte[5,3], 0 ) //Parametro MV_PAR05 - Deducoes

					If nFaltas > 0 .and. Len(aFaltas) > 0
						If SM7->M7_VALDOM > 0
							nFalAux += aFaltas[1]
						EndIf
						If SM7->M7_VALSEG > 0
							nFalAux += aFaltas[2]
						EndIf
						If SM7->M7_VALTER > 0
							nFalAux += aFaltas[3]
						EndIf
						If SM7->M7_VALQUA > 0
							nFalAux += aFaltas[4]
						EndIf
						If SM7->M7_VALQUI > 0
							nFalAux += aFaltas[5]
						EndIf
						If SM7->M7_VALSEX > 0
							nFalAux += aFaltas[6]
						EndIf
						If SM7->M7_VALSAB > 0
							nFalAux += aFaltas[7]
						EndIf
						nDiaCal -= nFalAux
					EndIf
				Else
					If !Empty(aDiasMes) .Or. lComplS151//Se existir dados no array aDiasMes, utiliza estes dados para montar dias uteis e nao uteis de vale transporte
						If __lMemCalc
							fAddMemLog("Calendário analítico" ,1,2)
						EndIf
						lGrvRU1     := .T.
                        nDiaAlim    := 0
						nDiaNAlim   := 0
						If lPeriodico
							nPos := aScan(aDiasMes,{|x| x[1] == aPergunte[8,3]})
						EndIf
						If nPos == 0
							nPos := 1
						EndIf
						For nX := nPos to Len(aDiasMes)
                            If lComplS151 .And. !fVldS151( aCfgS151, "1", SM7->M7_CODIGO, aDiasMes[nX, 1], aDiasMes[nX, 6] )
                                Loop
                            EndIf

							If aDiasMes[nX, 3] == "1"
								If(aDiasMes[nX, 2] == "1",nDiaUtil++,nDiaNUtil++)
                            EndIf
                            If aDiasMes[nX,4] .and. ( !lUsaCPer .Or. (aDiasMes[nX,2] == "1" .and. aDiasMes[nX,3] == "1" .and. (Empty(dDataDem) .OR. aDiasMes[nX,1] < dDataDem) ) )
								nDiaAlim++
                                aDiasMes[nX, 7] := nDUtil
							ElseIf aDiasMes[nX,4] .and. aDiasMes[nX,2] <> "1" .and. aDiasMes[nX,3] == "1" .and. (Empty(dDataDem) .OR. aDiasMes[nX,1] < dDataDem) 
								nDiaNAlim++
                                aDiasMes[nX, 7] := Iif( nDNUtil > 0, nDNUtil, nDUtil )
							EndIf

							If lPeriodico .And. aDiasMes[nX][1]==aPergunte[9,3]
								exit
							EndIf
						Next nX
						If nDiaAlim == 0 .And. nDiaNAlim == 0 .And. nDiaUtil + nDiaNUtil > 0
							nDiaUtil := 0
							nDiaNUtil:= 0
						EndIf
					Else //do contrario utiliza cadastro de periodo - RCF_DALIM
						If __lMemCalc
							fAddMemLog("Calendário sintético" ,1,2)
						EndIf
						If lPeriodico
							nDiaAlim  := DateDiffDay( aPergunte[8,3],aPergunte[9,3] ) + 1
						ElseIf aPergunte[2,3] <> 2 .And. DiasTrab < nDiasPer
							nDiaUtil  := Int( Round( aPeriodo[nPosSem,21] * ( ( DiasTrab - ( nDiasMat + nDPrgSalMa ) ) / nDiasPer ), 2 ) )
							nDiaNUtil := 0
						Else
							nDiaUtil  := aPeriodo[nPosSem,21]
							nDiaNUtil := 0
						EndIf
						nDiasRef := nDiaUtil
					EndIf
					If __lMemCalc
						fAddMemLog("Dias úteis : " +  cvaltochar(nDiaUtil) ,1,3)
						fAddMemLog("Dias não úteis : " +  cvaltochar(nDiaNUtil) ,1,3)
					EndIf
					If nDiaAlim > 0
		    			nDiaInf := If(lPeriodico .and. nDiaInf > 0, nDiaInf, nDUtil)
		    			nDiaCal := Max( ( nDiaAlim - nFaltas ) * nDiaInf - aPergunte[5,3], 0 ) //Parametro MV_PAR05 - Deducoes
						nDiaCal += nDiaNAlim * If(lPeriodico .and. nDiaInf > 0, nDiaInf, Iif( !lComplS151 .Or. nDNUtil > 0, nDNUtil, nDUtil ))
		    		Else
			    		nAuxUtil  := ( nDiaUtil * If(lPeriodico .and. nDiaInf > 0, nDiaInf, nDUtil) ) - Iif( !lComplS151, aPergunte[5,3], 0 )
			    		nAuxNUtil := nDiaNUtil * If(lPeriodico .and. nDiaInf > 0, nDiaInf, Iif( !lComplS151 .Or. nDNUtil > 0, nDNUtil, nDUtil ))
			    		nDiaCal   := ( nAuxUtil + nAuxNUtil ) - (nFaltas * nDUtil)						
			    	EndIf
				EndIf
			EndIf
		EndIf

		// Ponto de entrada para alteracao dos dias de vales e dias trabalhados no mes.
		If lGPVALDias
			aVALDias := {}
			aAdd(aVALDias, {nDiaNUtil, nDiaUtil, nDiasProp, nDiasFix } )
			aVALDias := ExecBlock("GPVALDias", .F., .F.)

			If ValType(aVALDias) == "A" .And. Len(aVALDias) > 0 .And. Len(aVALDias[1]) >= 4
				nDiaNTraPE	:= aVALDias[1,1]
				nDiaTraPE	:= aVALDias[1,2]
				nDiasProp	:= aVALDias[1,3]
				nDiasFix	:= aVALDias[1,4]
			EndIf

			If ( nDiaNTraPE != nDiaNUtil ) .Or. ( nDiaTraPE != nDiaUtil )	//Se qtde. de dias úteis ou não úteis for alterada,
				nDiaCal 	+= ( (nDiaNTraPE - nDiaNUtil) * nDNUtil )
				nDiaCal 	+= ( (nDiaTraPE - nDiaUtil) * nDUtil )			//soma com a quantidade de vales já calculada
				nDiaNUtil 	:= nDiaNTraPE
				nDiaUtil  	:= nDiaTraPE									//e dias prop passa a ser informado
				nDiasRef	:= nDiaTraPE
			EndIf
		EndIf

		If !lSP7 .And. nFaltas > 0 .And. nFaltas >= nDiaAlim
			If lPeriodico
				dDt1	:= aPergunte[8,3]
				dDt2	:= aPergunte[9,3]
			Else
				dDt1	:= aPeriodo[nPosSem,3]
				dDt2	:= aPeriodo[nPosSem,4]
			EndIf
			GravaSP7(nDiaAlim,dDt1,dDt2)
			lSP7 := .T.
		EndIf

		nDiaCal := Iif( nDiaCal > 0, nDiaCal, 0)
		nValAli := nDiaCal * nValUni

		If __lMemCalc .And. nValAli > 0
			fAddMemLog("Dias de cálculo : " +  cvaltochar(nDiaCal) ,1,2)
			fAddMemLog("Valor cálculo : " +  Transform(nValAli,"@E 999,999,999.99") ,1,2)
		EndIf
		//Inicio do trecho para recalculo dos beneficios gerados pela integração com serviços

		//Recalcula último VA pago por critérios definidos na intergração com serviços para verificar se deve ser feito algum desconto ou acréscimo
		If ( fIntRHGS() .AND. SuperGetMv("MV_BENEXGS",,.T.) ) .or. P_RECALBEN
			fRetBenAnt(SRA->RA_FILIAL, SRA->RA_MAT, SRA->RA_PROCES, "2", @aPerAux)
			If Len(aPerAux) > 0
				nTotDif := fApurPAnt(aPerAux[1], "2", Nil, SM7->M7_CODIGO)[1]
			EndIf
			If __lMemCalc .And. nTotDif != 0
				fAddMemLog("Integração com serviços ativada "  ,1,2)
				fAddMemLog("Valor diferença mês anterior : " +  Transform(nTotDif,"@E 999,999,999.99") ,1,2)
			EndIf
		EndIf

		nValOri := nValAli	// Guarda o valor calculado originalmente

		If nTotDif != 0
			If nTotDif > 0 //Se houver diferença positiva para pagar em relação ao mês anterior, soma no valor total do VA
				nValALI += nTotDif
				nTotDif := 0
			ElseIf ( nValALI + nTotDif ) >= 0 //Se houver diferença negativa, debita do total até o minimo de zero
				nValALI += nTotDif
				nTotDif := 0
			Else
				nTotDif += nValALI
				nValALI := 0
			EndIf
		EndIf
		//Fim do trecho para recalculo dos beneficios gerados pela integração com serviços

		nCustFunc   := Round(( nValAli * nPerc ) / 100, 2)
		If nTeto > 0
			nCustFunc   := Min(nCustFunc, nTeto)
		EndIf
		nCustEmp	:= nValAli - nCustFunc
		If __lMemCalc .And. nPerc > 0
			fAddMemLog("Percentual desconto funcionário : " +  cvaltochar(nPerc) + " %" ,1,2)
			fAddMemLog("Teto  : " +  Transform(nTeto,"@E 999,999,999.99") ,1,2)
			fAddMemLog("Custo funcionário : " +  Transform(nCustFunc,"@E 999,999,999.99") ,1,2)
			fAddMemLog("Custo empresa : " +  Transform(nCustEmp,"@E 999,999,999.99") ,1,2)
		EndIf
		cKeyAux := SM7->(M7_FILIAL + M7_MAT + M7_TPVALE + M7_CODIGO)

		If !lComplS151 .Or. nDiaCal > 0
            aAdd( aVACalc, { cKeyAux, nDiaCal, nValUni, nValAli, nCustFunc, nCustEmp, nDiasRef, lPropin, SM7->M7_CODIGO, nDiasProp, nDUtil, nDNUtil, SM7->M7_TPCALC, SM7->M7_TPVALE, aDiaVales, SM7->M7_VALFIX, 0, nValOri, nDiaUtil, nDiaNUtil, Iif( Len(aFaltas) > 0 .and. nFalAux > 0, nFalAux, nFaltas ), "", Iif( lGrvRU1, aClone(aDiasMes), {} ), Iif( aPergunte[5,3] > 0, nDiaCal + aPergunte[5,3], nDiaCal ), Iif( lGrvRU1, aClone(aDiasAnt), {} ) } )
        EndIf

		If SM7->M7_COMPL == "1"
			RecLock("SM7",.F.)
			SM7->(dbDelete())
			SM7->(msUnlock())
		EndIf

		SM7->(DbSkip())

	EndDo

	If nTotDif < 0 //Grava o saldo negativo no último vale calculado
		aVACalc[Len(aVACalc),17] := nTotDif
	EndIf

Else // Não Encontrou Registros na SM7, mas deve recalcular o mês anterior

	If ( fIntRHGS() .AND. SuperGetMv("MV_BENEXGS",,.T.) ) .or. P_RECALBEN // Apenas integração com serviços
		fRetBenAnt(SRA->RA_FILIAL, SRA->RA_MAT, SRA->RA_PROCES, "2", @aPerAux)
		If Len(aPerAux) > 0
			aDias := fApurPAnt(aPerAux[1], "2")
			nTotDif := aDias[1]
			cCodBen := aDias[2]
		EndIf
	EndIf

	nValOri := nValAli	// Guarda o valor calculado originalmente

	If nTotDif != 0

		//Grava na SM7
		AtuSM7Aut("2", cCodBen)

		If nTotDif > 0 //Se houver diferença positiva para pagar em relação ao mês anterior, soma no valor total do VA
			nValALI += nTotDif
			nTotDif := 0
		ElseIf ( nValALI + nTotDif ) >= 0 //Se houver diferença negativa, debita do total até o minimo de zero
			nValALI += nTotDif
			nTotDif := 0
		Else
			nTotDif += nValALI
			nValALI := 0
		EndIf

		cKeyAux := SRA->(RA_FILIAL + RA_MAT + "2" + cCodBen)

		aAdd(aVACalc, {cKeyAux, 0, nValUni, nValAli, nCustFunc, nCustEmp, nDiaAlim, lPropin, cCodBen, nDiasProp, nDUtil, nDNUtil, "2", "2", {0, 0, 0, 0, 0, 0, 0}, 0, nTotDif, nValOri,0,0,nFaltas,"" })
	EndIf

EndIf

RestArea(aArea)

Return Nil

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFunction³fValGrvN 	   ºAutor  ³Leandro Drumond  º Data ³  03/08/2013 º±±
±±ÌÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.   ³Gravacao do calculo do vale refeicao/alimentacao		      º±±
±±º        ³                                                              º±±
±±ÌÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso     ³ Roteiro de Calculo                                           º±±
±±ÈÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function fValGrvN(aVLCalc)

Local aArea		:= GetArea()
Local lNovo		:= .T.
Local nX		:= 0
Local nPos 		:= 0
Local lPeriodico:= aPergunte[6,3] == 1//Avulso/Complemnto/Semanal/diario
Local cNumPed   := ""
Local cCodCCT   := ""
Local lGpem040  := FunName() == "GPEM040" .or. FunName() == "GPEM040B"
Local lTemIndex := .F.

DEFAULT aVLCalc     := {}
DEFAULT lTemCCT	    := SR0->(ColumnPos("R0_CODCCT")) > 0
DEFAULT lTemRU1	    := AliasInDic("RU1")
DEFAULT lTemRecalc  := If(lTemRU1,RU1->( ColumnPos("RU1_RECALC") ) > 0,.F.)
DEFAULT lTemQtVD  	:= SR0->(ColumnPos("R0_QTVDEDU")) > 0
DEFAULT lTemSldAnt 	:= SR0->( ColumnPos("R0_SLDANT") ) > 0
DEFAULT aM7Inativ   := {}

If lGpem040 //Se for rescisão, inclui valores calculados no array para desconto na rescisão

	aBenefRes[If(cRot == "VRF",2,3)] := aClone(aVLCalc)

Else

	If lTemCCT .and. !Empty(SRA->RA_SINDICA)
		cCodCCT := fBuscaCCT(SRA->RA_SINDICA)
	EndIf

	DbSelectArea("SM7")
	SM7->(DbSetOrder(RetOrder("SM7","M7_FILIAL+M7_MAT+M7_TPVALE+M7_CODIGO")))

	DbSelectArea("SR0")

	//Indice incluído na 12.1.2210 junto com alteração de chave única para possibilitar a gravação de dois períodos diferentes.
	DEFAULT nOrderSR0 := RetOrder("SR0", "R0_FILIAL+R0_MAT+R0_TPVALE+R0_PERIOD+R0_NROPGT")

	If nOrderSR0 <= 1
		nOrderSR0 := RetOrder("SR0", "R0_FILIAL+R0_MAT+R0_TPVALE+R0_CODIGO+R0_PEDIDO")
	EndIf

	lTemIndex := nOrderSR0 > 3

	SR0->(DbSetOrder(nOrderSR0))

	// Exclui cálculo anterior para o mesmo período, caso exista
	cKey := SRA->RA_FILIAL + SRA->RA_MAT + If(cRot == "VAL", "2", If(cRot == "VRF", "1", "0")) + If(lTemIndex, cPeriodo + cNumPag,"")

	If SR0->(dbSeek(cKey))
		While SR0->(R0_FILIAL + R0_MAT + R0_TPVALE + If(lTemIndex, R0_PERIOD + R0_NROPGT,"")) == cKey
			//Somente deleta o cálculo se for recálculo. Caso o pedido já tenha sido emitido, não deleta.
			If (SR0->R0_DTREFI == aPeriodo[nPosSem, 3] .And. SR0->R0_DTREFF == aPeriodo[nPosSem, 4] .And. SR0->R0_PEDIDO != "2") ;
				.Or. (Empty(SR0->R0_DTREFI) .And. Empty(SR0->R0_DTREFF) .And. SR0->R0_PEDIDO != "2")
				//Se já existir um cálculo em aberto, quer dizer que é recálculo, então armazena o numero do pedido já utilizado.
				If ( nPos := aScan(aVLCalc, {|x| x[1] == SR0->R0_FILIAL+SR0->R0_MAT+SR0->R0_TPVALE+SR0->R0_CODIGO}) ) > 0
					aVLCalc[nPos,22] := SR0->R0_NROPED
				EndIf
				//Se existe cálculo e foi alterado para inativo, não deleta.
				If aScan(aM7Inativ, {|x| x[1] == SR0->R0_FILIAL+SR0->R0_MAT+SR0->R0_TPVALE+SR0->R0_CODIGO}) > 0
					SR0->(dbSkip())
					Loop
				EndIf
				Reclock("SR0", .F.)
				SR0->(dbDelete())
				SR0->(MsUnlock())
                If lTemRU1
                    If RU1->( dbSeek( SR0->R0_FILIAL+SR0->R0_MAT+SR0->R0_TPVALE+SR0->R0_CODIGO+SR0->R0_NROPED ) )
                        While RU1->( !Eof() ) .And. RU1->RU1_FILIAL+RU1->RU1_MAT+RU1->RU1_TPVALE+RU1->RU1_CODIGO+RU1->RU1_NROPED == SR0->R0_FILIAL+SR0->R0_MAT+SR0->R0_TPVALE+SR0->R0_CODIGO+SR0->R0_NROPED 
                            If RU1->( Reclock("RU1", .F.) )
                                RU1->( dbDelete() )
                                RU1->( MsUnlock() )
                            EndIf
                            RU1->( dbSkip() )
                        End
                    EndIf
                EndIf
			EndIf
			SR0->(dbSkip())
		EndDo
		SR0->(dbGoTop())
	EndIf

	aM7Inativ := {}

	For nX := 1 to Len(aVLCalc)
		SM7->(DbSeek(SRA->RA_FILIAL + SRA->RA_MAT + aVLCalc[nX, 14] + aVLCalc[nX, 9]))
		lNovo 	  := .T.
		cNumPed   := ""
		If SR0->(DbSeek(aVLCalc[nX, 1] + "1"))
			While SR0->( !EoF() ) .And. SR0->R0_FILIAL+SR0->R0_MAT+SR0->R0_TPVALE+SR0->R0_CODIGO+SR0->R0_PEDIDO == aVLCalc[nX, 1] + "1"
				If SR0->R0_NROPGT == aPeriodo[nPosSem, 2] .and. (!lTemIndex .or. SR0->R0_PERIOD == cPeriodo)
					lNovo := .F.
					Exit
				EndIf
				SR0->( dbSkip() )
			EndDo
		EndIf		
		If ! lNovo .And. ! Empty(SR0->R0_NROPED)
			cNroPed := SR0->R0_NROPED
		ElseIf lNovo
			cNumPed := aVLCalc[nX,22]
		EndIf
		If Reclock( "SR0", lNovo)
			If !Empty(aVLCalc[nX, 10]) .And. (aVLCalc[nX,8] .OR. ( aVLCalc[nX,10] <> IIf( aVLCalc[nX, 14] == "1", aPeriodo[nPosSem,12] , aPeriodo[nPosSem,21] ) ))
				//Grava apenas se utilizou o campo R0_DPROPIN -OU-
				//Se dias calculados diferente da quantidade de dias do mes.
				SR0->R0_DPROPIN	:= aVLCalc[nX, 10]
				SR0->R0_DIASPRO := aVLCalc[nX, 10]
			Else
				SR0->R0_DPROPIN := 0
				If aVLCalc[nX, 21] >= 0
					SR0->R0_DIASPRO :=  Iif(aVLCalc[nX, 2] < aVLCalc[nX, 7], Iif(Len(aVLCalc[nX]) >= 24, aVLCalc[nX, 24], aVLCalc[nX, 2] ), aVLCalc[nX, 7])
				Else
					// Se houver devolução de Faltas soma a devolução aos dias proporcionais
					SR0->R0_DIASPRO := Iif(aVLCalc[nX, 2] < aVLCalc[nX, 7], Iif(Len(aVLCalc[nX]) >= 24, aVLCalc[nX, 24] - aVLCalc[nX, 21], aVLCalc[nX, 2] - aVLCalc[nX, 21] ), aVLCalc[nX, 7] - aVLCalc[nX, 21])																								
				EndIf
			EndIf
			SR0->R0_FILIAL	:= SRA->RA_FILIAL
			SR0->R0_MAT		:= SRA->RA_MAT
			SR0->R0_TPVALE	:= aVLCalc[nX, 14]
			SR0->R0_CODIGO	:= aVLCalc[nX, 9]
			SR0->R0_QDIAINF	:= aVLCalc[nX, 11]
			SR0->R0_QDNUTIL	:= aVLCalc[nX, 12]
			SR0->R0_TPCALC	:= aVLCalc[nX, 13]
			SR0->R0_ROTEIR	:= cRot
			SR0->R0_PERIOD 	:= cPeriodo
			SR0->R0_NROPGT	:= cNumPag
			SR0->R0_ANOMES	:= SubSTr(cPeriodo,5,2) + SubSTr(cPeriodo,1,4)
			SR0->R0_PEDIDO	:= "1"
			SR0->R0_QVALSEG  := aVLCalc[nX, 15, 1]
			SR0->R0_QVALTER  := aVLCalc[nX, 15, 2]
			SR0->R0_QVALQUA  := aVLCalc[nX, 15, 3]
			SR0->R0_QVALQUI  := aVLCalc[nX, 15, 4]
			SR0->R0_QVALSEX  := aVLCalc[nX, 15, 5]
			SR0->R0_QVALSAB  := aVLCalc[nX, 15, 6]
			SR0->R0_QVALDOM  := aVLCalc[nX, 15, 7]
			SR0->R0_QVALFIX  := aVLCalc[nX, 16]
			If lPeriodico
				SR0->R0_DTREFI	:= aPergunte[8, 3]
				SR0->R0_DTREFF	:= aPergunte[9, 3]
			Else
				SR0->R0_DTREFI	:= aPeriodo[nPosSem, 3]
				SR0->R0_DTREFF	:= aPeriodo[nPosSem, 4]
			EndIf

			If lNovo
				//Caso não exista pedido, pode ser novo mês ou mais de 1 pedido no mês, então assume o novo número do pedido.
				If cNumPed <> ""
					cNroPed := cNumPed
				EndIf
				SR0->R0_NROPED	:= GetNroPed()
			EndIf
			SR0->R0_TPBEN	:= BuscaTBen(SR0->R0_TPVALE, SR0->R0_CODIGO, SR0->R0_FILIAL)		
			SR0->R0_DUTILM	:= aPeriodo[nPosSem,10]							//Dias Uteis no Mês - campo RCF_DUTILT
			SR0->R0_DNUTIM	:= aPeriodo[nPosSem,9]							//Dias Não Uteis no Mês - campo RCF_DNUTIL			
			SR0->R0_SALBASE	:= SRA->RA_SALARIO								//Salário Base
			SR0->R0_CC		:= SRA->RA_CC									//Centro de Custo do Funcionário
			SR0->R0_FALTAS	:= If(Len(aVlCalc[nX]) >= 21, aVlCalc[nX,21], (If(Empty(nFaltasAut), If(SM7->M7_QDIAINF > 0, nFaltas, 0), nFaltasAut)))	//Dias correspondentes à faltas (mnemônico NFALTAS) - Só desconta faltas se houvere pagamento de dias úteis.
			SR0->R0_FERIAS	:= nFerVen										//Dias correspondentes a férias (mnemônico NFERVEN)
			SR0->R0_AFAST	:= nDiasAfas									//Dias correspondentes a afastamentos (mnemônico NDIASAFAS)

			SR0->R0_QDIACAL	:= aVLCalc[nX, 2]								//Dias calculados
			SR0->R0_VALCAL 	:= aVLCalc[nX, 4]								//Valor Vale calculado
			SR0->R0_VLRVALE	:= aVLCalc[nX, 3]								//Custo Unitário
			SR0->R0_VLRFUNC	:= aVLCalc[nX, 5]								//Custo Funcionário
			SR0->R0_VLREMP 	:= aVLCalc[nX, 6]								//Custo Empresa

			If lTemSldAnt
				SR0->R0_SLDANT  := aVLCalc[nX, 17]							//Saldo negativo
				SR0->R0_VALORI	:= aVLCalc[nX, 18]							//Valor Caculado originalmente
			EndIf

			If lTemCCT
				SR0->R0_CODCCT 	:= cCodCCT	//Convenção Coletiva de Trabalho
			EndIf

			If lTemQtVD .AND. aPergunte[5,3] > 0
				SR0->R0_QTVDEDU := aPergunte[5,3]	//Quantidade de vales a deduzir
			EndIf

			SR0->( MsUnLock() )
		EndIf

        If lTemRU1
            If Len(aVLCalc[nX]) >= 23
                fGravaRU1( aVLCalc[nX, 23] )
            EndIf
            If lTemRecalc .And. Len(aVLCalc[nX]) >= 25
                fGravaRU1( aVLCalc[nX, 25], .T. )
            EndIf
        EndIf

		If cNumPed <> ""
			cNroPed := "" //Zera static para não usar o mesmo número para outro funcionário causando chave duplicada.
		EndIf

	Next nX

	If Len(aVLCalc) > 0
		CustoVales( aVLCalc[1, 14])
	EndIf

EndIf

// Zera Variáveis Static
RestXCBEN()

RestArea(aArea)

Return Nil

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFunction³fCargaRI1      ºAutor  ³Leandro Drumond  º Data ³ 21/02/2014  º±±
±±ÌÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.   ³Carrega dados dos beneficios do funcionario.                  º±±
±±º        ³                                                              º±±
±±ÌÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso     ³Roteiros de Calculo			                                  º±±
±±ÈÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function fCargaRI1(aBenRI1)
Local aArea		:= GetArea()
Local lRet		:= .F.
Local lRetAut	:= .F.

DEFAULT lTemPagFal := RIS->( ColumnPos( "RIS_PAGFAL" ) ) > 0

lRetAut := fCrgBenAut(.F.) //Verifica se existem critérios automáticos para o funcionário

DbSelectArea("RI1")
DbSetOrder(1)

lRI1Afast := .F.

If DbSeek(SRA->RA_FILIAL + SRA->RA_MAT)
	If Empty(SRA->RA_DEMISSA) .or. SRA->RA_DEMISSA > dDataDe
		
		While RI1->(!Eof() .and. RI1_FILIAL + RI1_MAT == SRA->RA_FILIAL + SRA->RA_MAT )
			If RI1->( RI1_TPCALC != "2" .And. (( Empty(RI1_DINIPG) .or. RI1_DINIPG <= dDataAte ) .And. (Empty(RI1_DFIMPG) .Or. RI1_DFIMPG >= dDataDe)))
				lRet := .T.
				RI1->( aAdd( aBenRI1, { RI1_MAT, RI1_BENEF, RI1_TABELA, RI1_PD, RI1_PD1, RI1_PD2, RI1_PROPOR, Iif( lTemPagFal, RI1->RI1_PAGFAL, " " ) } ) )
				If RI1->RI1_PROPOR == "1"
					lRI1Afast := .T.
				EndIf
			EndIf
			RI1->(DbSkip())
		EndDo
		
	EndIf
EndIf

lRet := lRet .Or. lRetAut

If lRI1Afast .Or. lRetAut //Se existir cálculo proporcional, carrega dias trabalhados
	fDiasTrab(@DiasTrab)
EndIf

If lRetAut .And. RIS->RIS_PROPOR == "1"
	lRI1Afast := .T.
EndIf

RestArea(aArea)

Return lRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFunction³fOtbCalc       ºAutor  ³Leandro Drumond  º Data ³ 21/02/2014  º±±
±±ÌÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.   ³Calcula outros beneficios.                                    º±±
±±º        ³                                                              º±±
±±ÌÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso     ³Roteiros de Calculo			                                  º±±
±±ÈÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function fOtbCalc()
Local cCodBenef	:= ""
Local cCodTab	:= ""
Local cTpRef	:= ""
Local cTpDesc	:= ""
Local cPdBen	:= ""
Local cPdFunc	:= ""
Local cPdEmp	:= ""
Local nValBen	:= 0
Local nValEmp	:= 0
Local nValFunc	:= 0
Local nRef		:= 0
Local nRefCalc	:= 0
Local nPercFunc	:= 0
Local nPercBen	:= 0
Local nPercEmp	:= 0
Local nValMin	:= 0
Local nValMax	:= 0
Local nX 		:= 0
Local nY 		:= 0
Local nDiasProp	:= 0
Local nValAux	:= 0
Local nValRed	:= 0
Local nBkpSalMes:= SalMes
Local nDiasPer	:= If(GetMvRH("MV_DIASPER",,"1") == "1",nDiasP,(If(SRA->RA_TIPOPGT =="M", P_QTDIAMES, P_NTOTDIAS)))
Local lPagFalt	:= .F.
Local lProp		:= .F.
Local lSalOuBen := If( Type("P_SALOUBEN") <> "U", P_SALOUBEN, .F.)

DEFAULT lTemPagFal := RIS->( ColumnPos( "RIS_PAGFAL" ) ) > 0
DEFAULT lVlMinMax  := RIS->( ColumnPos( "RIS_VALMIN" ) ) > 0

// Valida Demissão do Funcionário
If ( !Empty(SRA->RA_DEMISSA) .And. MesAno(SRA->RA_DEMISSA) <= cAnoMes .And. cSitFolh == "D")
    Return()
EndIf

DbSelectArea("RIS")
DbSetOrder(1)

For nX := 1 to Len(aBenRI1)
	cCodBenef 	:= aBenRI1[nX,2]
	cCodTab		:= aBenRI1[nX,3]
	cPdBen		:= aBenRI1[nX,4]
	cPdFunc		:= aBenRI1[nX,5]
	cPdEmp		:= aBenRI1[nX,6]
	lProp		:= aBenRI1[nX,7] == "1"
	lPagFalt	:= aBenRI1[nX,8] $ " /1"
	aRISCalc	:= {}
	SalMes		:= nBkpSalMes

	If ( Empty(cPdBen) .And. Empty(cPdFunc) .And. Empty(cPdEmp) ) .Or. ( lTemPagFal .And. !lPagFalt .And. P_BENMAXFA > 0  .and. GpVldFal(cCodBenef) )
		Loop
	EndIf

	If RIS->(DbSeek(xFilial("RIS")+cCodBenef+cCodTab))
		While RIS->(!Eof() .and. RIS_FILIAL + RIS_TPBENE + RIS_COD == xFilial("RIS")+cCodBenef + cCodTab )
			If Empty(RIS->RIS_SALATE)
				nValAux := RIS->RIS_SALMIN * Val_SalMin
			Else
				nValAux := RIS->RIS_SALATE
			EndIf
			If SalMes <= nValAux
				cTpRef 		:= RIS->RIS_TPREF
				cTpDesc		:= RIS->RIS_TPDESC
				nRef		:= RIS->RIS_REF
				nPercFunc	:= RIS->RIS_FUNCD
				nPercBen	:= RIS->RIS_FUNCP
				nPercEmp	:= RIS->RIS_EMP
				nValMin		:= RIS->RIS_MINIMO
				nValMax		:= RIS->RIS_MAXIMO
				nValBen		:= 0
				nValEmp		:= 0
				nValFunc	:= 0
				nRefCalc	:= 0
				nDiasProp	:= 0

				If cTpRef == "1" //Valor Fixo
					nRefCalc := nRef
				ElseIf cTpRef == "2" //Percentual do Salario Base
					If !lSalOuBen
						nRefCalc := SalMes * ( nRef / 100 )
					Else
						fSalInc(@nSalario,@SalMes,@SalHora,@SalDia)
						//Se for comissionado, utiliza a mesma estrutura utilizada na fórmula S_NVLGOMIS()
						If SRA->RA_CATFUNC == "C"
							nTotComis := FBUSCAPD(ACODFOL[165,1] + "," + ACODFOL[166,1],,CSEMANA)
                    		nGComisPro := 0
                    		FPROPGCOMIS('2',@nGComisPro)
    	                    SalMes += MAX(SalMes,nTotComis)
    	                    SalMes := MAX(SalMes,nGComisPro)
						EndIf
						//Se for tarefeiro, utiliza a mesma estrutura utilizada na fórmula S_NVLGTARE()
						If SRA->RA_CATFUNC == "T"
							nGTarPro := 0
                   			FPROPGTAR('2',@nGTarPro)
                   			SalMes += MAX(SalMes,nTotTarefa)
                    		SalMes := MAX(SalMes,nGTarPro)
						EndIf
						nRefCalc := SalMes * ( nRef / 100 )
					EndIf
				ElseIf cTpRef == "3" //Percentual sobre salario minimo
					nRefCalc := Val_SalMin * ( nRef / 100 )
				EndIf

				If !Empty(nPercBen)
					nValBen := nRefCalc * ( nPercBen / 100 )
				EndIf

				If lProp
					If !P_NVAFABEN
						nValBen := Round( ( nValBen / nDiasPer ) * DiasTrab, 2)
						nDiasProp := DiasTrab
					Else
						nDiasProp := nDiasPer
						For nY := 1 to Len(aDiasMes)
							If !aDiasMes[nY,4] .and. aDiasMes[nY,5] $ "FER/AFA"
								nDiasProp-- 
							EndIf 
						Next nY
						nDiasProp -= nFaltas
						nValBen := Round( ( nValBen / nDiasPer ) * nDiasProp, 2)
					EndIf
				EndIf

				If lVlMinMax //Limita os valores do beneficio ao mínimo e máximo definidos no cadastro
					If RIS->RIS_VALMIN > 0
						nValBen := Max(nValBen, RIS->RIS_VALMIN)
					EndIf

					If RIS->RIS_VALMAX > 0
						nValBen := Min(nValBen, RIS->RIS_VALMAX)
					EndIf
				EndIf

				If !Empty(cPdFunc) .and. !Empty(nPercFunc) .And. nValBen > 0
					If cTpDesc == "1" //Percentual do Beneficio
						nValFunc := nValBen * ( nPercFunc / 100 )
					ElseIf cTpDesc == "2"
						If !lSalOuBen
							If P_lPPEAtiv .And. P_RedSalB
								If Empty(aPPE)
									fInssResEx()
									fSalRed(@nValRed, Nil, Nil, nSalMes)
								EndIf
								SalMes -= nValRed
							EndIf
							nValFunc := SalMes * ( nPercFunc / 100 )
						Else
							fSalInc(@nSalario,@SalMes,@SalHora,@SalDia)
							If P_lPPEAtiv .And. P_RedSalB
								If Empty(aPPE)
									fInssResEx()
									fSalRed(@nValRed, Nil, Nil, nSalMes)
									EndIf
								SalMes -= nValRed
							EndIf
							If SRA->RA_CATFUNC == "C"
								nTotComis := FBUSCAPD(ACODFOL[165,1] + "," + ACODFOL[166,1],,CSEMANA)
								nGComisPro := 0
								FPROPGCOMIS('2',@nGComisPro)
								SalMes += MAX(SalMes,nTotComis)
								SalMes := MAX(SalMes,nGComisPro)
							EndIf
							If SRA->RA_CATFUNC == "T"
								nGTarPro := 0
								FPROPGTAR('2',@nGTarPro)
								SalMes += MAX(SalMes,nTotTarefa)
								SalMes := MAX(SalMes,nGTarPro)
							EndIf
							nValFunc := SalMes  * ( nPercFunc / 100 )
						EndIf
					ElseIf cTpDesc == "3" //Percentual Salario Minimo
						nValFunc := Val_SalMin * ( nPercFunc / 100 )
					EndIf
					nValFunc := Round(nValFunc,2)
					If nValMin > 0
						nValFunc := Max(nValFunc,nValMin)
					EndIf
					If nValMax > 0
						nValFunc := Min(nValFunc,nValMax)
					EndIf
				EndIf

				// Quando informado 100% no campo RIS_FUNCP(%Pagto.Func) quer dizer que o pagamento
				// daquele benefício realizado por aquela empresa. Por exemplo, ao informar que aquela empresa
				// pagará 50% sobre um benefício no valor de R$ 60,00, então R$ 30,00
				// é que serão utilizados para construir o desconto do funcionário e o desconto da empresa.
				nValEmp := If(nValBen == 0, nValBen, nValBen - nValFunc )

				aAdd(aCalcRI1,{cCodBenef, nValBen, nValFunc, nValEmp, cPdBen, cPdFunc, cPdEmp, cCodTab, nDiasProp, nRefCalc})

				Exit
			EndIf
			RIS->(DbSkip())
		EndDo
	EndIf
Next nX

Return Nil

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFunction³fOtbCalc       ºAutor  ³Leandro Drumond  º Data ³ 21/02/2014  º±±
±±ÌÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.   ³Calcula outros beneficios.                                    º±±
±±º        ³                                                              º±±
±±ÌÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso     ³Roteiros de Calculo			                                  º±±
±±ÈÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function fGrvOtB()
Local cCodCCT 	:= ""
Local nX 		:= 0

DEFAULT lOtbCCT	  	:= RIQ->(ColumnPos("RIQ_CODCCT")) > 0

If lOtbCCT .and. !Empty(SRA->RA_SINDICA)
	cCodCCT := fBuscaCCT(SRA->RA_SINDICA)
EndIf

fDelRIQ()

DbSelectArea("RIQ")

For nX := 1 to Len(aCalcRI1)
	RecLock("RIQ",.T.)

	RIQ_FILIAL 	:= SRA->RA_FILIAL
	RIQ_MAT	   	:= SRA->RA_MAT
	RIQ_TPBENE	:= aCalcRI1[nX,1]
	RIQ_VALBEN	:= aCalcRI1[nX,2]
	RIQ_VLRFUN	:= aCalcRI1[nX,3]
	RIQ_VLREMP	:= aCalcRI1[nX,4]
	RIQ_PD		:= aCalcRI1[nX,5]
	RIQ_PD1		:= aCalcRI1[nX,6]
	RIQ_PD2		:= aCalcRI1[nX,7]
	RIQ_COD		:= aCalcRI1[nX,8]
	RIQ_DIAPRO	:= aCalcRI1[nX,9]
	RIQ_VALCAL	:= aCalcRI1[nX,10]
	RIQ_SALBAS	:= SalMes
	RIQ_SALMIN	:= Val_SalMin
	RIQ_PROCES	:= cProcesso
	RIQ_ROTEIR	:= cRot
	RIQ_PERIOD	:= cPeriodo
	RIQ_NUMPAG	:= cSemana
	RIQ_TIPO	:= "1"

	If lOtbCCT
		RIQ_CODCCT := cCodCCT 
	EndIf

	MsUnLock()
Next nX

Return Nil

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFunction³fDelRIQ        ºAutor  ³Leandro Drumond  º Data ³ 21/02/2014  º±±
±±ÌÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.   ³Deleta calculo anterior.	                                  º±±
±±º        ³                                                              º±±
±±ÌÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso     ³Roteiros de Calculo			                                  º±±
±±ÈÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function fDelRIQ()

Local aArea := GetArea()
Local cQuery
Local cNameDB
Local cDelet
Local cSqlName := InitSqlName( "RIQ" )

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³O banco DB2 nao aceita o nome da tabela apos o comando DELETE			 ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
cNameDB	:= Upper(TcGetDb())

cQuery	:= "DELETE "

cDelet	:= "RIQ.D_E_L_E_T_ = ' ' "

If ( cNameDB $ "INFORMIX" )
	cDelet := cSqlName + ".D_E_L_E_T_ = ' ' "
EndIf

If !( cNameDB $ "DB2_ORACLE_INFORMIX_POSTGRES" )
	cQuery += cSqlName
EndIf

 		/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³O Informix precisa do nome da tabela ao inves do Alias no comando DELETE³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
If ( cNameDB $ "INFORMIX" )
	cQuery += " FROM " + cSqlName
Else
	cQuery += " FROM " + cSqlName + " RIQ"
	cSqlName := "RIQ"
EndIf

cQuery += " WHERE " + cSqlName + ".RIQ_FILIAL = '" + SRA->RA_FILIAL + "'"
cQuery += " AND " + cSqlName + ".RIQ_MAT = '" + SRA->RA_MAT + "'"
cQuery += " AND " + cSqlName + ".RIQ_PROCES = '" + cProcesso + "'"
cQuery += " AND " + cSqlName + ".RIQ_ROTEIR = '" + cRot + "'"
cQuery += " AND " + cSqlName + ".RIQ_PERIOD = '" + cPeriodo + "'"
cQuery += " AND " + cSqlName + ".RIQ_NUMPAG = '" + cSemana + "'"
cQuery += " AND " + cDelet

TcSqlExec( cQuery )

RestArea( aArea )

Return( .T. )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFunction³fIntegraOUT    ºAutor  ³Leandro Drumond  º Data ³ 22/02/2014  º±±
±±ÌÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.   ³Integra outros beneficios com a folha.                        º±±
±±º        ³                                                              º±±
±±ÌÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso     ³Roteiros de Calculo			                                  º±±
±±ÈÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function fIntegraOUT(cFil, cMat, cProcBen, cProcFol, cRotFol, cPerFol, cSemFol, cRotBen, cPerBen, cSemBen)
Local aArea			:= GetArea()
Local aVerbas		:= {"RIQ->RIQ_PD","RIQ->RIQ_PD1","RIQ->RIQ_PD2"}
Local aValAux		:= {"RIQ->RIQ_VALBEN","RIQ->RIQ_VLRFUN","RIQ->RIQ_VLREMP"}
Local cKeyRIQ		:= cFil + cMat + cProcBen + cRotBen + cPerBen
Local cPdAux		:= ""
Local cPdGerado     := ""
Local cTpBenAux		:= ""
Local cCodAux		:= ""
Local cSeq			:= ""
Local lGrava		:= .T.
Local lAtualiza		:= .F.
Local nValAux		:= 0
Local nX			:= 0
Local dDataBen

DEFAULT lGPM19RGB 	:= ExistBlock("GPM19RGB")

Pergunte("GPEM015OUT",.F.) //Carrega o grupo de perguntas, a definição da sobreposição vira do conteúdo gravado, mesmo quando a integração ocorrer pelo GPEM019
nSobrepor := mv_par04

DbSelectArea("SRA")
DbSetOrder(1)
DbSeek(cFil + cMat)

DbSelectArea("RGB")
DbSetOrder(RetORder("RGB","RGB_FILIAL+RGB_PROCES+RGB_PERIOD+RGB_SEMANA+RGB_ROTEIR+RGB_MAT+RGB_PD+RGB_SEQ"))

DbSelectArea("RIQ")
DbSetOrder(1)

If(DbSeek(cKeyRIQ))
	While RIQ->(!Eof() .and. RIQ_FILIAL+RIQ_MAT+RIQ_PROCES+RIQ_ROTEIR+RIQ_PERIOD == cKeyRIQ )
		If !Empty(cSemBen) .and. RIQ->RIQ_NUMPAG <> cSemBen
			RIQ->(DbSkip())
			Loop
		EndIf

		For nX := 1 to Len(aVerbas)
			cPdAux 		:= &(aVerbas[nX])
			lGrava 		:= .T.
			lAtualiza 	:= .F.
			cSeq 		:= ""
			
			If Empty(cPdAux) .or. &(aValAux[nX]) == 0
				Loop
			Else
				nValAux := &(aValAux[nX])
			EndIf

			If RGB->(DbSeek(cFil + cProcFol + cPerFol + cSemFol + cRotFol + cMat + cPdAux))
				If cTpBenAux == RIQ->RIQ_TPBENE .and. cCodAux <> RIQ->RIQ_COD
				  	If Val(RetValSRV(  cPdAux , cFil , "RV_QTDLANC" )) > 1
				  		If nSobrepor <> 1
					  		If Empty(cSeq)
					  			cSeq := "1"
					  		Else
								cSeq := Soma1(cSeq)
							EndIf
						Else
							cSeq := RGB->RGB_SEQ
						EndIf
						If RGB->(DbSeek(cFil + cProcFol + cPerFol + cSemFol + cRotFol + cMat + cPdAux + cSeq)) 
							If nSobrepor <> 1
								While RGB->(!Eof() .And. RGB_FILIAL+RGB_PROCES+RGB_PERIOD+RGB_SEMANA+RGB_ROTEIR+RGB_MAT+RGB_PD == cFil + cProcFol + cPerFol + cSemFol + cRotFol + cMat + cPdAux)
									cSeq := Soma1(RGB->RGB_SEQ)
									RGB->(DbSkip())
								EndDo
								RGB->(RecLock("RGB", .T.))
							Else 
								RGB->( RecLock( "RGB" , .F. ) )
							EndIf 	
						Else
							RGB->( RecLock( "RGB" , .T. ) )
						Endif
					Else
						if nSobrepor == 1
				  			nValAux := RGB->RGB_VALOR
				  		Else
				  			nValAux += RGB->RGB_VALOR
				  		Endif
				  		RGB->( RecLock( "RGB" , .F. ) )
					EndIf
				ElseIf RGB->RGB_ROTORI == cRotBen .and. RGB->RGB_TIPO2 == "G" .and. cPdAux $ cPdGerado //Dois beneficios diferentes, para o mesmo funcionário, calculado na mesma verba
					RGB->( RecLock( "RGB" , .F. ) )
					lAtualiza := .T.
				ElseIf nSobrepor == 1
					RGB->( RecLock( "RGB" , .F. ) )
				Else
					aAdd( aLog[Len(aLog)], SRA->RA_FILIAL + "  " + SRA->RA_MAT + "-" + If(lOfusca, Replicate('*',15), SRA->RA_NOME) + "   " + cPdAux + "   " + fDesc( "SRV" , cPdAux  , "RV_DESC" ) )
					lGrava := .F.
				EndIf
			Else
				RGB->( RecLock( "RGB" , .T. ) )
			EndIf

			cTpBenAux := RIQ->RIQ_TPBENE
			dDataBen  := StoD(cPerFol+"01")

			If lGrava
				RGB->RGB_FILIAL	:= RIQ->RIQ_FILIAL
				RGB->RGB_MAT 	:= RIQ->RIQ_MAT
				RGB->RGB_CC		:= SRA->RA_CC
				RGB->RGB_PD		:= cPdAux
				RGB->RGB_TIPO1	:= RetValSRV(  cPdAux , cFil , "RV_TIPO" )
				RGB->RGB_TIPO2	:= "G"
				RGB->RGB_VALOR	:= If(lAtualiza,RGB->RGB_VALOR + nValAux, nValAux)
				RGB->RGB_PARCEL	:= 0
				RGB->RGB_ITEM 	:= SRA->RA_ITEM
				RGB->RGB_CLVL 	:= SRA->RA_CLVL
				RGB->RGB_PROCES	:= cProcFol
				RGB->RGB_PERIOD	:= cPerFol
				RGB->RGB_ROTEIR	:= cRotFol
				RGB->RGB_SEMANA	:= cSemFol
				RGB->RGB_ROTORI	:= cRotBen
				RGB->RGB_SEQ	:= cSeq
				RGB->RGB_DTREF	:= dDataBen

				If lGPM19RGB
					ExecBlock("GPM19RGB", .F. , .F., { cRotBen, RIQ->RIQ_FILIAL, RIQ->RIQ_MAT, cPerFol, cSemFol } )
				EndIf

				RGB->(MsUnLock())

				cPdGerado += cPdAux + "/"
			EndIf
		Next nX

		cCodAux	  := RIQ->RIQ_COD

		RIQ->(DbSkip())
	EndDo
EndIf

RestArea(aArea)

Return .T.

/*/{Protheus.doc} fCrgAutom
Carrega benefícios por critério
@author Flavio S Correa
@since 22/02/2014
@param cTipo, characters, "VR" - Vale refeição ou "VA" - Vale alimentação
@param cTipoVale, characters, "1" - Vale Refeição ou "2" - Vale Alimentação
/*/
Function fCrgAutom(cTipo, cTipoVale, lGrava)
	
	Local aArea			:= GetArea()
	Local aAreaRFO		:= RFO->(GetArea())
	Local aAloc			:= {}
	Local nI, nJ		:= 1
	Local lOk			:= .F.
	Local nCrit			:= 0
	Local nX			:= 0
	Local aDias			:= {}
	Local aDiasBkp		:= {}
	Local nDias			:= 0
	Local nPos		    := 0
	Local nPosAdias		:= 0
	Local lDesprezar	:= .F.
	Local lNovo			:= .T.
	Local lFrist		:= .T.
	Local lRepete		:= .F.
	Local cChave		:= ""
	Local cCCChave		:= ""
	Local cFilChave		:= ""
	local cDeptoChave	:= ""
	Local cPostoChave	:= ""
	Local cSindChave	:= ""
	Local cCargoChave	:= ""
	Local cCodBen		:= ""
	Local cTurnoChave	:= ""
	Local cFuncaoChave	:= ""
	Local cChaveBEN		:= ""
	Local cCCTChave		:= ""
	Local cTipoBen		:= ""
	Local cCodSLY		:= ""
	Local cEntidade		:= ""
	Local cCCTAnt 		:= ""
	Local aCCTChave		:= ""
	Local aTransf		:= {}
		
	DEFAULT cTipo		:= If(cTipoRot == "D", "VR", "VA") //1-Vale Refeição / 2-Vale Alimentação
	DEFAULT cTipoVale	:= If(cTipoRot == "D", "1", "2") //0-Vale Transporte / 1-Vale Refeição / 2-Vale Alimentação
	DEFAULT lGrava		:= .T.

	DEFAULT __lMemCalc	:= cPaisLoc == "BRA" .And. fMemCalc() // Memória de Cálculo
	DEFAULT lTemPagFal 	:= RI1->( ColumnPos( "RI1_PAGFAL" ) ) > 0

	If __lMemCalc
		fAddMemLog("Periodo de cálculo : " + dtoc(dDataDe) + " a " + dtoc(dDataAte) ,1,2)
	EndIf
	
	fCarrAdias(dDataDe, dDataAte) // Carrega o array _aDias com os dias do mês
	
	If Empty(aCriterio) .Or. cTipo <> cTipoCri
		CargaCrit(cTipo, @aCriterio, dDataDe, dDataAte)
		cTipoCri := cTipo
	EndIf
	
	// Carrega transferências do funcionário
	If fTransf(@aTransf, MesAno(dDataDe), , , , , , , , , , , SRA->RA_FILIAL, SRA->RA_MAT)
		For nI := 1 To Len(aTransf)
			If aTransf[nI][2] != SRA->RA_FILIAL		// Transferência de Filial
				cFilChave += SubStr(aTransf[nI][2], 1, FWGetTamFilial) + "|"
			EndIf
			If aTransf[nI][3] != SRA->RA_CC			// Transferência de Centro de Custo
				cCCChave += aTransf[nI][3] + "|"
			EndIf
			If aTransf[nI][16] != SRA->RA_DEPTO		// Transferência de Departamento
				cDeptoChave += aTransf[nI][16] + "|"
			EndIf
			If aTransf[nI][18] != SRA->RA_POSTO		// Transferência de Posto
				cPostoChave += aTransf[nI][18] + "|"
			EndIf
		Next
	EndIf
	
	If __lMemCalc .And. !Empty(cFilChave)
		fAddMemLog("Transferências filial : " + cFilChave ,1,2)
	EndIf
	If __lMemCalc .And. !Empty(cCCChave)
		fAddMemLog("Transferências CC : " + cCCChave ,1,2)
	EndIf
	If __lMemCalc .And. !Empty(cDeptoChave)
		fAddMemLog("Transferências depto : " + cDeptoChave ,1,2)
	EndIf
	If __lMemCalc .And. !Empty(cPostoChave)
		fAddMemLog("Transferências posto : " + cPostoChave ,1,2)
	EndIf
	
	//Carrega alterações no cadastro do Funcionário
	//Alteração de Sindicato
	aTransf := HistSRA("RCE")
	For nI := 1 To Len(aTransf)
		cSindChave += aTransf[nI][2] + "|"
	Next
	
	//Alteração de Cargo
	aTransf := HistSRA("SQ3")
	For nI := 1 To Len(aTransf)
		cCargoChave += aTransf[nI][2] + "|"
	Next
	
	//Alteração de Turno
	aTransf := HistSPF( dDataDe, dDataAte)
	For nI := 1 To Len(aTransf)
		cTurnoChave += aTransf[nI][2] + "|"
	Next
	
	//Alteração de Função
	aTransf := HistSR7()
	For nI := 1 To Len(aTransf)
		cFuncaoChave += aTransf[nI][2] + "|"
	Next
	
	cCCChave		+= SRA->RA_CC		// Adiciona Centro de Custo atual na Chave
	cFilChave		+= SRA->RA_FILIAL	// Adiciona Filial atual na Chave
	cDeptoChave		+= SRA->RA_DEPTO	// Adiciona Departamento atual na Chave
	cPostoChave		+= SRA->RA_POSTO	// Adiciona Posto atual na Chave
	cSindChave		+= SRA->RA_SINDICA	// Adiciona Sindicato atual na Chave
	cCargoChave		+= SRA->RA_CARGO	// Adiciona Cargo atual na Chave
	cTurnoChave		+= SRA->RA_TNOTRAB	// Adiciona Turno atual na Chave
	cFuncaoChave	+= SRA->RA_CODFUNC	// Adiciona Função atual na Chave
	aCCTChave		:= {} 				//Zera pois deve carregar apenas se houver critério de CCT definido
	
	For nI := 1 To Len(aCriterio)
		
		If cTipoVale == "OUT" .And. aCriterio[nI][12] $ "VR*VA*PS"
			Loop
		EndIf
		
		// Verifica se possui mesmo Tipo de Beneficio em mais de 1 linha do critério na mesma Entidade
		// ou o mesmo tipo de benefício em hiearquias diferentes
		lDesprezar 	:= .F.
		lRepete 	:= .F.
		If nI > 1 
			For nX := 1 To (nI-1)
				If cTipoVale <> "OUT" .And. cEntidade == aCriterio[nI, 1] .And. aCriterio[nI, 1] == aCriterio[nX, 1] .And. aCriterio[nI, 4] == aCriterio[nX, 4]
					lRepete 	:= .T.
				ElseIf cTipoVale == "OUT" .And. aCriterio[nI, 1] != aCriterio[nX, 1] .And. aCriterio[nI, 12] == aCriterio[nX, 12] .And. lOk
					lDesprezar 	:= .T.		
				EndIf
				If lRepete .Or. lDesprezar
					Exit
				EndIf
			Next nX
		EndIf

		If lDesprezar
			Loop
		EndIf

		cChave	:= Alltrim(aCriterio[nI][2])
		If __lMemCalc .And. !Empty(cChave)
			fAddMemLog("Tabela critério : " + aCriterio[nI][1] ,1,2)
			fAddMemLog("Chave critério : " + cChave ,1,2)
		EndIf
		
		nDias	:= 0
		lOk		:= .F.
		lNovo 	:= .T.
		
		If ! lOk .And. (aCriterio[nI][1] == "SQB") // Departamento
			lOk := cChave $ cDeptoChave
			nDias := If(lOk, NroDias("SQB", cChave, dDataDe, dDataAte,, lRepete), 0)
		EndIf
		If ! lOk .And. (aCriterio[nI][1] == "RCE") // Sindicato
			lOk := cChave $ cSindChave
			nDias := If(lOk, NroDias("RCE", cChave, dDataDe, dDataAte,, lRepete), 0)
		EndIf
		If ! lOk .And. (aCriterio[nI][1] == "CTT") // Centro de Custo
			lOk := cChave $ cCCChave
			nDias := If(lOk, NroDias("CTT", cChave, dDataDe, dDataAte,, lRepete), 0)
		EndIf
		If ! lOk .And. (aCriterio[nI][1] == "SQ3") // Cargo
			lOk := cChave $ cCargoChave
			nDias := If(lOk, NroDias("SQ3", cChave, dDataDe, dDataAte,, lRepete), 0)
		EndIf
		If ! lOk .And. (aCriterio[nI][1] == "RCL") // Posto
			lOk := cChave $ cPostoChave
			nDias := If(lOk, NroDias("RCL", cChave, dDataDe, dDataAte,, lRepete), 0)
		EndIf
		If ! lOk .And. (aCriterio[nI][1] == "SRJ") // Função
			lOk := cChave $ cFuncaoChave
			nDias := If(lOk, NroDias("SRJ", cChave, dDataDe, dDataAte,, lRepete), 0)
		EndIf
		If ! lOk .And. (aCriterio[nI][1] == "SR6") // Turno
			lOk := cChave $ cTurnoChave
			nDias := If(lOk, NroDias("SR6", cChave, dDataDe, dDataAte,, lRepete), 0)
		EndIf
		If ! lOk .And. (aCriterio[nI][1] == "SWY") // Convenção Coletiva de Trabalho
			If Empty(aCCTChave) .or. cCCTAnt <> cChave
				aCCTChave := fLoadCCT(cChave, cFilChave)
				cCCTAnt := cChave
			EndIf
			cCCTChave := ""
			aEval(aCCTChave, {|x| If(x $ cSindChave, cCCTChave += x + "/", Nil)})
			lOk := !Empty(cCCTChave)
			nDias := If(lOk, NroDias("SWY", cCCTChave, dDataDe, dDataAte,, lRepete), 0)
		EndIf
		If ! lOk .And. (aCriterio[nI][1] == "SM0") // Filial
			lOk := cChave $ cFilChave
			nDias := If(lOk, NroDias("SM0", cChave, dDataDe, dDataAte,, lRepete), 0)
		EndIf
		If !lOk .And. lUsaGS .and. (aCriterio[nI][1] $ "ABS*SA1*TDX") // Local de Atendimento ou Cliente ou Turno do Posto
			If lFrist
				AA1->(DbSetOrder(7)) // AA1_FILIAL, AA1_CDFUNC, AA1_FUNFIL
				If AA1->(DbSeek(xFilial("AA1") + SRA->RA_MAT + SRA->RA_FILIAL))
					aAloc := TXRetAloc(SRA->RA_FILIAL, SRA->RA_MAT, dDataDe, dDataAte)
					For nX := 1 To Len(aAloc)
						Aadd(aAloc[nX], 0)
					Next
				EndIf
                aDiasBkp := aClone(aDiasMes)
                aDiasMes := {}
				lFrist   := .F.
			EndIf
			For nX := 1 to Len(aAloc)
				If ( aCriterio[nI][1] == "ABS" .And. AllTrim(aAloc[nX][07]) == cChave ) .or. ( aCriterio[nI][1] == "SA1" .And. AllTrim(aAloc[nX][10] + aAloc[nX][11]) == cChave ) .or. ( aCriterio[nI][1] == "TDX" .And. AllTrim(aAloc[nX][15] + aAloc[nX][08]) == cChave )
					lPaga := fVldCrit(aAloc[nX],aCriterio[nI],aDiasMes)
					
					If lPaga .And. aAloc[nX][Len(aAloc[nX])] == 0	// Se o dia deve ser pago e não foi pago em um critério anterior
						nDias++
						If cTipoVale != "OUT" 
							aAloc[nX][Len(aAloc[nX])] := 1
							
							If (nPosAdias := Ascan( _aDias, { |X| X[1] == aAloc[nX][02] } )) > 0
								_aDias[nPosAdias][4] := .F.
								If FindFunction("TecBAtuDia")
									TecBAtuDia( SRA->RA_FILIAL, SRA->RA_MAT, _aDias[nPosAdias][1], .F. )
								EndIf
							EndIf
						EndIf
                        If ( nPos := AScan( aDiasBkp, { |x| x[1] == aAloc[nX, 2] } ) ) > 0
                            aAdd( aDiasMes, AClone(aDiasBkp[nPos]) )
                            aDiasMes[Len(aDiasMes), 3] := "1"
                            aDiasMes[Len(aDiasMes), 4] := .T.
                        EndIf
					ElseIf ! lPaga	// Se o dia não deve ser pago
						aAloc[nX][Len(aAloc[nX])] := 1
						If (nPosAdias := Ascan( _aDias, { |X| X[1] == aAloc[nX][02] } )) > 0
							_aDias[nPosAdias][4] := .F.
							If FindFunction("TecBAtuDia")
								TecBAtuDia( SRA->RA_FILIAL, SRA->RA_MAT, _aDias[nPosAdias][1], .F. )
							EndIf
						EndIf
					EndIf
				EndIf
			Next nX
			If __lMemCalc 
				If(!Empty(aCriterio[nI][13]), fAddMemLog("Mínimo informado no critério : " + cValtochar(aCriterio[nI][13]) ,1,2), "")
				If(nDias > 0, fAddMemLog("Dias : " + cvaltochar(nDias) ,1,2), "")
			EndIf
			If cTipoVale != "OUT" .And. nDias > 0 .And. nDias >= aCriterio[nI, 13]	//Se quantidade de dias maior que 0 e maior que o número minimo de dias informado no crit
				aAdd(aDias, {nI, nDias, .T., 0})
			ElseIf cTipoVale == "OUT" 
				lOk := .T.
				If nDias < aCriterio[nI, 13]
					nDias := 0
				EndIf
			Endif
		EndIf
		If lOk .And. nDias > 0
			nCrit 		:= nI
			cCodBen 	:= Alltrim(aCriterio[nCrit][3])
			cTipoBen 	:= Alltrim(aCriterio[nCrit][12])
			cCodSLY 	:= Alltrim(aCriterio[nCrit][3])
			For nJ := 1 To Len(aDias)
				If cTipoVale == "OUT" .And. aCriterio[aDias[nJ, 1]][12] == cTipoBen .And. aCriterio[aDias[nJ, 1]][3] == cCodSLY
					lNovo := .F.
					EXIT
				Else
					If (cTipoVale != "OUT" .And. Alltrim(aCriterio[aDias[nJ, 1]][3]) == cCodBen) .Or. (cTipoVale == "OUT" .And. aCriterio[aDias[nJ, 1]][12] == cTipoBen .And. Alltrim(aCriterio[aDias[nJ, 1]][3]) == cCodBen)
						aDias[nJ][2] += nDias
						lNovo := .F.
					EndIf
				EndIf
			Next
			If lNovo
				Aadd(aDias, {nI, nDias, .T., 0})
				lNovo := .T.
				If Empty(cEntidade)
					cEntidade := aCriterio[nCrit][1]
				EndIf
			EndIf
		EndIf
	Next nI
	
	If Len(aDias) > 0
		
		RFO->(DbSetOrder(1)) //RFO_FILIAL+RFO_TPVALE+RFO_CODIGO
		
		If cTipoVale <> "OUT"
            //Grava SM7
            DbSelectArea("SM7")
            SM7->(DbSetOrder(3))
            
            For nX := 1 to Len(aDias)
                nCrit := aDias[nX,1]
                
                RFO->(DbSeek(xFilial("RFO")+cTipoVale + Alltrim(aCriterio[nCrit][3])))
                
                If SM7->(DbSeek(SRA->RA_FILIAL + SRA->RA_MAT + cTipoVale + Alltrim(aCriterio[nCrit][3])))
                    lNovo := .F.
                Else
                    lNovo := .T.
                EndIf
                
                RecLock("SM7",lNovo)
                    
                    SM7->M7_FILIAL 	:= SRA->RA_FILIAL
                    SM7->M7_MAT		:= SRA->RA_MAT
                    SM7->M7_CODIGO	:= Alltrim(aCriterio[nCrit][3])
                    SM7->M7_TPCALC	:= "2"
                    SM7->M7_QDIAINF	:= 1
                    SM7->M7_TPVALE	:= cTipoVale
                    SM7->M7_COMPL	:= "2"
                    If aDias[nX,3] //Se for criterio de serviços, grava os dias calculados no campo R0_DPROPIN para que elessejam considerados no calculo.
                        If RFO->RFO_DIAFIX > 0
                            SM7->M7_DPROPIN := RFO->RFO_DIAFIX
                        Else
                            SM7->M7_DPROPIN := aDias[nX, 2]
                        EndIf
                    EndIf
                    
                SM7->(MsUnlock())
            Next nX
		Else
			DbSelectArea("RIS")
			DbSetOrder(1) //RIS_FILIAL + RIS_TPBENE + RIS_COD + STR(RIS_SALATE)
			
			DbSelectArea("RI1")
			RI1->(DbSetOrder(1)) // RI1_FILIAL + RI1_MAT + RI1_BENEF + RI1_TABELA
			
			For nX := 1 to Len(aDias)
				nCrit := aDias[nX,1]
				
				If aCriterio[nCrit][12] $ "VR*VA*PS"
					Loop
				EndIf
				
				// Preserva os benefícios informados
				cChaveBEN := Alltrim(aCriterio[nCrit][3]) + Alltrim(aCriterio[nCrit][12])
				If aScan(aBenRI1, {|x| AllTrim(x[3]) + AllTrim(x[2]) == cChaveBEN }) > 0
					LOOP
				EndIf
				
				RIS->(DbSeek(xFilial("RIS", SRA->RA_FILIAL) + aCriterio[nCrit][12] + Alltrim(aCriterio[nCrit][3] )))
				cProp := RIS->RIS_PROPOR
				
				If Empty(cProp)
					cProp := "2"
				EndIf
				
				If lGrava
					If RI1->(DbSeek(SRA->RA_FILIAL + SRA->RA_MAT + aCriterio[nCrit][12] + Alltrim(aCriterio[nCrit][3])))
						lNovo := .F.
					Else
						lNovo := .T.
					EndIf
					
					If RecLock("RI1", lNovo)						
						RI1->RI1_FILIAL 	:= SRA->RA_FILIAL
						RI1->RI1_MAT		:= SRA->RA_MAT
						RI1->RI1_COD		:= "001"
						RI1->RI1_BENEF		:= aCriterio[nCrit][12]
						RI1->RI1_TABELA		:= Alltrim(aCriterio[nCrit][3])
						RI1->RI1_PROPOR		:= cProp
						RI1->RI1_TPCALC		:= "2"
						RI1->RI1_PD			:= RIS->RIS_PD
						RI1->RI1_PD1		:= RIS->RIS_PD1
						RI1->RI1_PD2		:= RIS->RIS_PD2
						RI1->RI1_DINIPG		:= StoD(aCriterio[nCrit][14])
						RI1->RI1_DFIMPG		:= StoD(aCriterio[nCrit][15])
						If lTemPagFal
							RI1->RI1_PAGFAL	:= aCriterio[nCrit, 16]
						EndIf						
						RI1->(MsUnlock())
					EndIf
				EndIf
				//Adiciona no array para calculo
				aAdd( aBenRI1, { RI1->RI1_MAT, RI1->RI1_BENEF, RI1->RI1_TABELA, RI1->RI1_PD, RI1->RI1_PD1, RI1->RI1_PD2, RI1->RI1_PROPOR, Iif( lTemPagFal, RI1->RI1_PAGFAL, " " ) } )
			Next nX
		EndIf
	EndIf
	
	_aDias				:= {} // Zera array com os dias do funcionário
	RestArea(aAreaRFO)
	RestArea(aArea)

Return Nil

/*/{Protheus.doc} fApurPAnt
Apura pagamento de beneficios no periodo anterior.
@author Leandro Drumond
@since 28/04/2015
@param aPerAux, array, Período que será recalculado
@param cTipoVale, characters, "1" - Vale Refeição ou "2" - Vale Alimentação
@param aCritRet, array, Array com o critério de benefícios
@return nDiferenca, Numérico, Diferença entre o que foi pago e o que era devido para o funcionário no mês anterior
/*/
Function fApurPAnt( aPerAux, cTipoVale, aCritRet, cCodSM7 )

	Local aAloc			:= {}
	Local aDiasAux		:= {}
	Local aDiasMesAnt	:= {}
	Local aTransf		:= {}
	Local aTabS153 		:= {}
	Local aRet			:= {0, ""}
	Local cChave		:= ""
	Local cTnoAux		:= SRA->RA_TNOTRAB
	Local cTpDia		:= ""
	Local nCont			:= 0
	Local nI			:= 0
	Local nX			:= 0
	Local nDias			:= 0
	Local nDiasAux1		:= 0
	Local nDiasAux2		:= 0
	Local nCrit			:= 0
	Local nPos		    := 0
	Local nPosAdias		:= 0
	Local nValPago		:= 0
	Local nValDevido	:= 0
	Local nDiasFixos	:= 0
	Local nValUni		:= 0
	Local nDiferenca	:= 0
	Local nQtdeDia	    := 0
	Local nValUniAnt	:= 0
	Local lAchou		:= .F.
	Local lAchouRG2		:= .F.
	Local lOk			:= .F.
	Local lPaga			:= .F.
	Local lFrist		:= .T.
	Local lFaltas		:= .F. 
	Local lAfast		:= .T.
	Local cCodBen		:= ""
	Local cCCChave		:= ""
	Local cDeptoChave	:= ""
	Local cPostoChave	:= ""
	Local cFilChave		:= ""
	Local cSindChave	:= ""
	Local cCargoChave	:= ""
	Local cTurnoChave	:= ""
	Local cFuncaoChave	:= ""
	Local cCampos		:= ""
	Local cAliasRG2		:= ""
	Local cCCTChave		:= ""
	Local cCCTAnt		:= ""
	Local aCCTChave		:= {}
	Local cWhereCod		:= "%%"
	Local cTipo			:= If(cTipoVale == "2", "VA", If(cTipoVale == "1", "VR", ""))
	
	Static nTamRg2Cd	:= TamSX3("RG2_CODIGO")[1]
	Static lSLDANT
	Static lVlrAnt

	DEFAULT aCritRet 	:= {}
	DEFAULT cCodSM7 	:= ""
	DEFAULT lSLDANT 	:= RG2->(ColumnPos("RG2_SLDANT")) > 0
	DEFAULT lVlrAnt		:= RFO->(ColumnPos("RFO_VUNANT")) > 0

	If cTipoVale != "0"
        CargaCrit(cTipo, @aCriterio, aPerAux[5], aPerAux[6])

        If ! Empty(aCritRet)
            aCriterio := aCritRet
        EndIf
	EndIf

	fCarrAdias(aPerAux[5], aPerAux[6], aPerAux[1]) // Carrega o array _aDias com os dias do mês

	If cTipoVale != "0" .and. Len(aCriterio) > 0
        // Carrega transferências do funcionário
        If fTransf(@aTransf, aPerAux[1], , , , , , , , , , , SRA->RA_FILIAL, SRA->RA_MAT)
            For nI := 1 To Len(aTransf)
                If aTransf[nI][2] != SRA->RA_FILIAL		// Transferência de Filial
                    cFilChave += SubStr(aTransf[nI][2], 1, FWGetTamFilial) + "|"
                EndIf
                If aTransf[nI][3] != SRA->RA_CC			// Transferência de Centro de Custo
                    cCCChave += aTransf[nI][3] + "|"
                EndIf
                If aTransf[nI][16] != SRA->RA_DEPTO		// Transferência de Departamento
                    cDeptoChave += aTransf[nI][16] + "|"
                EndIf
                If aTransf[nI][18] != SRA->RA_POSTO		// Transferência de posto
                    cPostoChave += aTransf[nI][18] + "|"
                EndIf
            Next
        EndIf

        // Verifica alterações no cadastro de Funcionários
        // Alterações de Sindicato
        aTransf := HistSRA("RCE")
        For nI := 1 To Len(aTransf)
            cSindChave += aTransf[nI][2] + "|"
        Next

        // Alterações de Cargo
        aTransf := HistSRA("SQ3")
        For nI := 1 To Len(aTransf)
            cCargoChave += aTransf[nI][2] + "|"
        Next

        // Alterações de Turno
        aTransf := HistSPF( aPerAux[5], aPerAux[6])
        For nI := 1 To Len(aTransf)
            cTurnoChave += aTransf[nI][2] + "|"
        Next

        // Alterações de Função
        aTransf := HistSR7()
        For nI := 1 To Len(aTransf)
            cFuncaoChave += aTransf[nI][2] + "|"
        Next

        cCCChave		+= SRA->RA_CC		// Adiciona Centro de Custo atual na Chave
        cFilChave		+= SRA->RA_FILIAL	// Adiciona Filial atual na Chave
        cDeptoChave		+= SRA->RA_DEPTO	// Adiciona Departamento atual na Chave
        cPostoChave		+= SRA->RA_POSTO	// Adiciona Posto atual na Chave
        cSindChave		+= SRA->RA_SINDICA	// Adiciona Sindicato atual na Chave
        cCargoChave		+= SRA->RA_CARGO	// Adiciona Cargo atual na Chave
        cTurnoChave		+= SRA->RA_TNOTRAB	// Adiciona Turno atual na Chave
        cFuncaoChave	+= SRA->RA_CODFUNC	// Adiciona Função atual na Chave
        aCCTChave		:= {} 				//Zera pois deve carregar apenas se houver critério de CCT definido

        For nI := 1 To Len(aCriterio)
            cChave := Alltrim(aCriterio[nI][2])
            nDias  := 0
            If !Empty(cCodSM7) .And. AllTrim(cCodSM7) != Alltrim(aCriterio[nI][3])
                Loop
            EndIf
            Do Case
                Case (aCriterio[nI][1] $ "ABS*SA1*TDX") // Local de Atendimento * Cliente * Turno do Posto (Entidades do Gestão de Serviços)

                    If lFrist
                        If lUsaGS
                            AA1->(DbSetOrder(7)) // AA1_FILIAL, AA1_CDFUNC, AA1_FUNFIL
                            If AA1->(DbSeek(xFilial("AA1") + SRA->RA_MAT + SRA->RA_FILIAL))
                                aAloc := TXRetAloc(SRA->RA_FILIAL, SRA->RA_MAT, aPerAux[5], aPerAux[6])

                                For nX := 1 To Len(aAloc)
                                    Aadd(aAloc[nX], 0)
                                Next
                            EndIf
                        EndIf
                        lFrist := .F.
                    EndIf

                    For nX := 1 to Len(aAloc)
                        If ( aCriterio[nI][1] == "ABS" .And. aAloc[nX][07] == cChave ) .or. ( aCriterio[nI][1] == "SA1" .And. aAloc[nX][10] + aAloc[nX][11] == cChave ) .or. ( aCriterio[nI][1] == "TDX" .And. aAloc[nX][15] + aAloc[nX][08] == cChave )
                            If ( aCriterio[nI][10] <> "1" .or. aCriterio[nI][11] <> "1" ) .And. Empty(aDiasMesAnt) //Se não paga ferias ou afastamentos, monta DiasMes do periodo anterior.
                                RCG->(DbSetOrder(RetOrder("RCG","RCG_FILIAL+RCG_PROCES+RCG_PER+RCG_SEMANA+RCG_ROTEIR+RCG_TNOTRA+DTOS(RCG_DIAMES)")))
                                lAchou := RCG->( dbSeek(xFilial("RCG") + SRA->RA_PROCES + aPerAux[1] + aPerAux[2] + Space(3) + cTnoAux ) )
                                If !lAchou
                                    cTnoAux := "@@@"
                                    lAchou := RCG->( dbSeek(xFilial("RCG") + SRA->RA_PROCES + aPerAux[1] + aPerAux[2] + Space(3) + cTnoAux ) )
                                EndIf
                                If lAchou
                                    While !RCG->( Eof() )  .And. RCG->(RCG_FILIAL + RCG_PROCES + RCG_PER + RCG_SEMANA + RCG_ROTEIR + RCG_TNOTRA ) == xFilial("RCG") + SRA->RA_PROCES + aPerAux[1] + aPerAux[2] + Space(3) + cTnoAux
                                        cTpDia  := Iif( RCG->RCG_TIPDIA == "1", "S", Iif( RCG->RCG_TIPDIA == "3", "D", Iif( RCG->RCG_TIPDIA == "4", "F", "N" ) ) )
                                        aAdd( aDiasMesAnt, { RCG->RCG_DIAMES, RCG->RCG_TIPDIA, "", .T., "", cTpDia, 0, 0 } )
                                        RCG->( DbSkip() )
                                    Enddo
                                    nDiasAux1 := DiasTrab
                                    nDiasAux2 := nDiasAfas
									If !P_NVAFABEN
                                    	fVlsAus(aPerAux[5], aPerAux[6], , @aDiasMesAnt)
									Else 
										aTabS153 := fLoadS153(@lFaltas, @lAfast)
										If ( Len(aTabS153) > 0 )    
											fCDiasS153(@aDiasMesAnt, aTabS153, lFaltas, lAfast, aPerAux[5], aPerAux[6])							
										EndIf										
									EndIf
                                    nDiasAfas := nDiasAux2
                                    DiasTrab  := nDiasAux1
                                    nDiasAux1 := nFerVen
                                    fVlsFerPrg(aPerAux[5], aPerAux[6],@aDiasMesAnt)
                                    nFerVen   := nDiasAux1
                                EndIf
                            EndIf
                            lPaga := fVldCrit(aAloc[nX], aCriterio[nI], aDiasMesAnt)
                            If lPaga .And. aAloc[nX][Len(aAloc[nX])] == 0 // Se o dia deve ser paga e se ainda não foi pago em outro critério
                                nDias++
                                aAloc[nX][Len(aAloc[nX])] := 1
                                If (nPosAdias := Ascan( _aDias, { |X| X[1] == aAloc[nX][02] } )) > 0
                                    _aDias[nPosAdias][4] := .F.
                                EndIf
                                If ( nPos := AScan( aDiasMesAnt, { |x| x[1] == aAloc[nX, 2] } ) ) > 0
                                    AAdd( aDiasAnt, AClone(aDiasMesAnt[nPos]) )
                                    aDiasAnt[Len(aDiasAnt), 3] := "1"
                                    aDiasAnt[Len(aDiasAnt), 4] := .T.
                                EndIf
                            ElseIf ! lPaga // Se o dia não deve ser pago
                                aAloc[nX][Len(aAloc[nX])] := 1
                                If (nPosAdias := Ascan( _aDias, { |X| X[1] == aAloc[nX][02] } )) > 0
                                    _aDias[nPosAdias][4] := .F.
                                EndIf
                            EndIf
                        EndIf
                    Next nX

                    lOk := nDias > 0

                Case (aCriterio[nI][1] == "CTT") // Centro de Custo
                    lOk := cChave $ cCCChave
                    nDias := If(lOk, NroDias("CTT", cChave, aPerAux[5], aPerAux[6], aPerAux[1]), 0)

                Case (aCriterio[nI][1] == "SQB") // Departamento
                    lOk := cChave $ cDeptoChave
                    nDias := If(lOk, NroDias("SQB", cChave, aPerAux[5], aPerAux[6], aPerAux[1]), 0)

                Case (aCriterio[nI][1] == "RCL") // Posto
                    lOk := cChave $ cPostoChave
                    nDias := If(lOk, NroDias("RCL", cChave, aPerAux[5], aPerAux[6], aPerAux[1]), 0)

                Case (aCriterio[nI][1] == "SM0") // Filial
                    lOk := cChave $ cFilChave
                    nDias := If(lOk, NroDias("SM0", cChave, aPerAux[5], aPerAux[6], aPerAux[1]), 0)

                Case (aCriterio[nI][1] == "RCE") // Sindicato
                    lOk := cChave $ cSindChave
                    nDias := If(lOk, NroDias("RCE", cChave, aPerAux[5], aPerAux[6], aPerAux[1]), 0)

                Case (aCriterio[nI][1] == "SQ3") // Cargo
                    lOk := cChave $ cCargoChave
                    nDias := If(lOk, NroDias("SQ3", cChave, aPerAux[5], aPerAux[6], aPerAux[1]), 0)

                Case (aCriterio[nI][1] == "SR6") // Turno
                    lOk := cChave $ cTurnoChave
                    nDias := If(lOk, NroDias("SR6", cChave, aPerAux[5], aPerAux[6], aPerAux[1]), 0)

                Case (aCriterio[nI][1] == "SRJ") // Função
                    lOk := cChave $ cFuncaoChave
                    nDias := If(lOk, NroDias("SRJ", cChave, aPerAux[5], aPerAux[6], aPerAux[1]), 0)

                Case (aCriterio[nI][1] == "SWY") // Convenção Coletiva de Trabalho
                    If Empty(aCCTChave) .or. cCCTAnt <> cChave
                        aCCTChave := fLoadCCT(cChave, cFilChave)
                        cCCTAnt := cChave
                    EndIf
                    cCCTChave := ""
                    aEval(aCCTChave, {|x| If(x $ cSindChave, cCCTChave += x + "/", Nil)})
                    lOk := !Empty(cCCTChave)
                    nDias := If(lOk, NroDias("SWY", cCCTChave, aPerAux[5], aPerAux[6], aPerAux[1]), 0)
                Otherwise
                    lOk := .F.
            EndCase

            If nDias > 0 .And. nDias >= aCriterio[nI, 13]	//Se quantidade de dias maior que 0 e maior que o número minimo de dias informado no crit
                If !(aCriterio[nI, 1] $ "ABS*SA1*TDX")
                    aDiasAnt := aClone(_aDias)
                EndIf
                Aadd(aDiasAux, {nI, nDias, 0, 0, 0, 0, .F.})
            EndIf

        Next nI
    EndIf 
	
	If cTipoVale == "0" .or. ( P_RECALBEN .and. nDias == 0 )
		aCriterio := {}
        If ( nDias := NroDias( Nil, Nil, aPerAux[5], aPerAux[6], aPerAux[1], Nil, .T. ) ) > 0
            aDiasAnt := aClone(_aDias)
            Aadd(aDiasAux, {nI, nDias, 0, 0, 0, 0, .F.})
        EndIf
    EndIf

	If Len(aDiasAux) > 0 .Or. lSLDANT

		DbSelectArea("RG2")
		DbSetOrder(1)	// RG2_FILIAL + RG2_MAT + RG2_TPVALE + RG2_CODIGO + RG2_PERIOD + RG2_NROPGT + RG2_ROTEIR

		cAliasRG2 := GetNextAlias()

		// Busca valor pago no mês anterior
		cCampos := Iif( lSLDANT, "%RG2_VALCAL, RG2_SLDANT, RG2_CODIGO, RG2_VTDUTE%", "%RG2_VALCAL, RG2_CODIGO, RG2_VTDUTE%" )

		If !Empty(cCodSM7)
			cWhereCod	:= "%AND RG2_CODIGO = '" + cCodSM7 + "'%"
		EndIf

		BeginSQL ALIAS cAliasRG2

			SELECT %Exp: cCampos%

			FROM %Table:RG2% RG2

			WHERE RG2_FILIAL = %Exp:SRA->RA_FILIAL%
			AND RG2_MAT = %Exp:SRA->RA_MAT%
			AND RG2_TPVALE = %Exp:cTipoVale%
			AND RG2_PERIOD = %Exp:aPerAux[1]%
			AND RG2_NROPGT = %Exp:aPerAux[2]%
			AND RG2_ROTEIR = %Exp:aPerAux[8]%
			AND RG2.%notDel%
			%Exp:cWhereCod%

		ENdSQL

		While ! (cAliasRG2)->(Eof())
			If Len(aDiasAux) > 0 .or. (cAliasRG2)->RG2_SLDANT <> 0
				If(lSLDANT, nValPago += (cAliasRG2)->(RG2_VALCAL + RG2_SLDANT), nValPago += (cAliasRG2)->RG2_VALCAL)
				cCodBen 	:= (cAliasRG2)->RG2_CODIGO
                nQtdeDia    := (cAliasRG2)->RG2_VTDUTE
				lAchouRG2 	:= .T.
			EndIf
			(cAliasRG2)->(dbSkip())
		EndDo

		(cAliasRG2)->(dbCloseArea())

		// Calcula valor devido para o funcionário
		If lAchouRG2
			For nX := 1 To Len(aDiasAux)
                If cTipoVale != "0" .and. ( Len(aCriterio) > 0 .or. P_RECALBEN )
					If Len(aCriterio) > 0
						nCrit 		:= aDiasAux[nX, 1]
						cCodBen 	:= Padr(aCriterio[nCrit, 3], nTamRg2Cd )
					EndIf
                    nDiasFixos 	:= Posicione("RFO", 1, xFilial("RFO", SRA->RA_FILIAL) + cTipoVale + cCodBen, "RFO_DIAFIX")
                    nValUni 	:= RFO->RFO_VALOR
					If lVlrAnt
						nValUniAnt := RFO->RFO_VUNANT		
					
						nValUni := If(!Empty(RFO->RFO_DATVIGE) .and. AnoMes(RFO->RFO_DATVIG) > aPerAux[1], nValUniAnt, nValUni)

						If Empty(nDiasFixos) .and. !Empty(RFO->RFO_DATVIG) .and. AnoMes(RFO->RFO_DATVIG) == aPerAux[1] .and. RFO->RFO_DATVIG > aPerAux[5]
						
							nValDevido += ( VldDiasRH( aPerAux[5], RFO->RFO_DATVIG ,.T., .T. )  * nValUniAnt ) * nQtdeDia

							nValDevido += ( VldDiasRH( RFO->RFO_DATVIG, aPerAux[6] + 1,.T., .T. )  * nValUni ) * nQtdeDia
						Else
							nValDevido += Iif( !Empty(nDiasFixos), nDiasFixos * nValUni, aDiasAux[nX, 2] * nValUni * nQtdeDia )
						EndIf
					Else
						nValDevido += Iif( !Empty(nDiasFixos), nDiasFixos * nValUni, aDiasAux[nX, 2] * nValUni * nQtdeDia )
					EndIf

					For nCont := 1 To Len(aDiasAnt)
						If aDiasAnt[nCont, 4]
							aDiasAnt[nCont, 7] := nQtdeDia
							AAdd(aDiasAnt[nCont], cCodBen)
							AAdd(aDiasAnt[nCont], If(Empty(nValUniAnt) .or. Empty(RFO->RFO_DATVIG) .or. !Empty(nDiasFixos) .or. RFO->RFO_DATVIG <= aDiasAnt[nCont, 1], nValUni, nValUniAnt))
						EndIf
					Next nCont
                ElseIf cTipoVale == "0"
                    nDiasFixos  := Posicione( "SRN", 1, xFilial("SRN", SRA->RA_FILIAL) + cCodBen, "RN_DIASFIX" )
                    nValUni     := SRN->RN_VUNIATU
					nValUniAnt  := SRN->RN_VUNIANT

					nValUni := If(!Empty(SRN->RN_DATVIGE) .and. AnoMes(SRN->RN_DATVIGE) > aPerAux[1], nValUniAnt, nValUni)
					
					If Empty(nDiasFixos) .and. !Empty(SRN->RN_DATVIGE) .and. AnoMes(SRN->RN_DATVIGE) == aPerAux[1] .and. SRN->RN_DATVIGE > aPerAux[5]
						
						nValDevido += ( VldDiasRH( aPerAux[5], SRN->RN_DATVIGE ,.T., .T. )  * nValUniAnt ) * nQtdeDia

						nValDevido += ( VldDiasRH( SRN->RN_DATVIGE, aPerAux[6] + 1,.T., .T. )  * nValUni ) * nQtdeDia
					Else
						nValDevido += Iif( !Empty(nDiasFixos), nDiasFixos * nValUni, aDiasAux[nX, 2] * nValUni * nQtdeDia )
					EndIf
					
					For nCont := 1 To Len(aDiasAnt)
						If aDiasAnt[nCont, 4]
							aDiasAnt[nCont, 7] := nQtdeDia
							AAdd(aDiasAnt[nCont], cCodBen)
							AAdd(aDiasAnt[nCont], If(Empty(nValUniAnt) .or. Empty(SRN->RN_DATVIGE) .or. !Empty(nDiasFixos) .or. SRN->RN_DATVIGE <= aDiasAnt[nCont, 1], nValUni, nValUniAnt))
						EndIf
					Next nCont
                EndIf				
			Next nX
		
			// calcula a diferença entre o que foi pago e o que é devido
			nDiferenca := If(nValpago > 0, nValDevido - nValPago, nValDevido + nValPago)

			aRet := {nDiferenca, cCodBen}
		EndIf
	EndIf

	_aDias := {} // Zera array com os dias do funcionário

Return aRet

/*/{Protheus.doc} fVldCrit
Valida criterios de servicos.
@author Leandro Drumond
@since 28/04/2015
/*/
Static Function fVldCrit(aAloc,aCriterio,aDiasMes)

Local lPaga := .F.

	lPaga := aAloc[Len(aAloc)] == 0 // Se não foi pago em um critério anterior (Estará sempre na última posição)
	If lPaga
		If (lPaga := ! aAloc[13] .or. aCriterio[08] == "1") // Se não for falta ou se estiver definido para pagar falta
			If (lPaga := ! aAloc[12] .or. aCriterio[07] == "1") // Se nao for feriado ou se estiver definido para pagar feriado
				If (lPaga := Dow(aAloc[02]) <> 1 .or. aCriterio[06] == "1") //Se não for domingo ou se estiver definido para pagar o domingo
					If (lPaga := Dow(aAloc[02]) <> 7 .or. aCriterio[05] == "1") //Se não for sabado ou se estiver definido para pagar o sabado
						If (lPaga := ! aAloc[14] .or. aCriterio[09] == "1") //Se não for substituto ou se estiver definido para pagar substituição
							If aCriterio[10] <> "1" //Não paga afastamento e férias
								If (nPos := Ascan( aDiasMes , { |X| X[1] == aAloc[02] } )) > 0
									If aDiasMes[nPos, 5] == "AFA" .or. aDiasMes[nPos, 5] == "FER"
										lPaga := .F.
									EndIf
								EndIf
							EndIf
						EndIf
						If lPaga
							If aCriterio[11] <> "1" //Não paga férias programadas
								If (nPos := Ascan( aDiasMes, { |X| X[1] == aAloc[02] } )) > 0
									If aDiasMes[nPos,5] == "PRG"
										lPaga := .F.
									EndIf
								EndIf
							EndIf
						EndIf
					EndIf
				EndIf
			EndIf
			If lPaga
				If DateWorkDay( aAloc[02] , aAloc[02], .F., .F., .F. ) > 0 .And. aCriterio[04] <> "1" //É dia útil e esta definido para não pagar dias úteis
					lPaga := .F.
				EndIf
			EndIf
		EndIf
	EndIf

Return lPaga

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFunction³CargaCrit    ºAutor  ³Flavio S Correa  º Data ³ 22/02/2014  º±±
±±ÌÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.   ³Carrega beneficios por criterio			                      º±±
±±º        ³                                                              º±±
±±ÌÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso     ³Roteiros de Calculo			                                  º±±
±±ÈÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function CargaCrit(cTipo, aCriterio, dDt1, dDt2)

Local aArea			:= GetArea()
Local cQry			:= GetNextAlias()
Local cSGBD			:= AllTrim( Upper( TcGetDb() ) )
Local cWhere		:= ""
Local cLimite		:= ""
Local cWhereFil		:= "%%"
Local cSelect		:= ""

Default dDt1		:= aPeriodo[nPosSem,3] //Data inicial do periodo de calculo
Default dDt2		:= aPeriodo[nPosSem,4] //Data final do periodo de calculo

DEFAULT lTemPagFal 	:= SLY->( ColumnPos( "LY_PAGFAL" ) ) > 0

Do Case
	Case cSGBD $ "ORACLE/MYSQL/POSTGRES/DB2"
		cLimite += If(cSGBD $ "ORACLE", " WHERE ROWNUM <= 1 ", If(cSGBD $ "MYSQL/POSTGRES", " TSTALIAS LIMIT 1 ", " FETCH FIRST 1 ROW ONLY "))
	Case cSGBD $ "INFORMIX"
	Otherwise
		cSelect := " TOP 1 "
EndCase

cWhere  := "% " + cWhere + " %"

If !Empty( xFilial("SJQ") )
	cWhereFil	:= "% LY_FILIAL = '"+ xFilial("SLY") + "' AND %"
EndIf

If !Empty(cSelect) //MSSQLServer
	cSelect := "% " + cSelect + " %"

	BEGINSQL ALIAS cQry
		SELECT * FROM %table:SLY% SLY
		INNER JOIN %table:SJS% SJS on JS_FILIAL = %xfilial:SJS% AND JS_CDAGRUP = LY_AGRUP and JS_TABELA = LY_ALIAS and SJS.%notDel%
		WHERE %exp:cWhereFil%
		LY_TIPO IN (%exp:cTipo%)
		AND LY_AGRUP=(SELECT %exp:cSelect% JQ_CODIGO
						FROM %table:SJQ%  SJQ
						WHERE SJQ.%notDel%
						AND JQ_FILIAL = %xfilial:SJQ%
						AND JQ_STATUS = %exp:'1'%
						AND JQ_FILREF IN (%exp:SRA->RA_FILIAL%,'')
						AND ( %exp:AnoMes(dDt1)% >= JQ_PERINI AND (%exp:AnoMes(dDt2)% <= JQ_PERFIM OR JQ_PERFIM = %exp:''%) )
						%exp:cWhere% 
						ORDER BY JQ_FILREF DESC)
		AND ( %exp:dtos(dDt1)% >= LY_DTINI AND (%exp:dtos(dDt2)% <= LY_DTFIM or LY_DTFIM = %exp:''%))	and SLY.%notDel%
		ORDER BY JS_SEQ
	ENDSQL
Else
	cLimite := "% " + cLimite + " %"

	BEGINSQL ALIAS cQry
		SELECT * FROM %table:SLY% SLY
		INNER JOIN %table:SJS% SJS on JS_FILIAL = %xfilial:SJS% AND JS_CDAGRUP = LY_AGRUP and JS_TABELA = LY_ALIAS and SJS.%notDel%
		WHERE %exp:cWhereFil%
		LY_TIPO IN (%exp:cTipo%)
		AND LY_AGRUP=(SELECT CODIGO FROM 
			(SELECT JQ_CODIGO CODIGO
						FROM %table:SJQ%  SJQ
						WHERE SJQ.%notDel%
						AND JQ_FILIAL = %xfilial:SJQ%
						AND JQ_STATUS = %exp:'1'%
						AND JQ_FILREF IN (%exp:SRA->RA_FILIAL%,'')
						AND ( %exp:AnoMes(dDt1)% >= JQ_PERINI AND (%exp:AnoMes(dDt2)% <= JQ_PERFIM OR JQ_PERFIM = %exp:''%) )
						%exp:cWhere% 
						ORDER BY JQ_FILREF DESC) %exp:cLimite% )
		AND ( %exp:dtos(dDt1)% >= LY_DTINI AND (%exp:dtos(dDt2)% <= LY_DTFIM or LY_DTFIM = %exp:''%))	and SLY.%notDel%
		ORDER BY JS_SEQ
	ENDSQL
EndIf

aCriterio 	:= {}
aSLYAlias	:= {}
cSLYAlias	:= ""
cSLYTipo	:= ""

While !(cQry)->(Eof())
	(cQry)->( aAdd( aCriterio, { LY_ALIAS, LY_CHVENT, LY_CODIGO, LY_PGDUT, LY_PGSAB, LY_PGDOM, LY_PGFER, LY_PGFALT, LY_PGSUBS, LY_PGAFAS, LY_PGVAC, LY_TIPO, LY_DIAS, LY_DTINI, LY_DTFIM, Iif( lTemPagFal, LY_PAGFAL, " " ) } ) )
	If !( (cQry)->LY_ALIAS $ cSLYAlias )
		cSLYAlias += (cQry)->LY_ALIAS + "/"
	EndIf
	If !( (cQry)->LY_TIPO $ cSLYTipo )
		cSLYTipo += (cQry)->LY_TIPO
	EndIf
	(cQry)->(dbSkip())
EndDo

aSLYAlias := StrTokArr( cSLYAlias, "/" )

(cQry)->(DbCloseArea())

RestArea(aArea)
Return .T.

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFunction³fCrgBenAut     ºAutor  ³Leandro Drumond  º Data ³ 05/05/2015  º±±
±±ÌÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.   ³Valida criterios de servicos.  			                      º±±
±±º        ³                                                              º±±
±±ÌÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso     ³Roteiros de Calculo			                                  º±±
±±ÈÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function fCrgBenAut(lGrava)

Local aArea		:= GetArea()
Local aTabBenef := {}
Local cQryRI1	:= ""
Local cQryUpd	:= ""
Local cTipo		:= ""
Local cWhere	:= ""
Local cWhereBen	:= ""
Local nX		:= 0
Local lCarga	:= .F.
Local lDiasMes	:= .F.

DEFAULT cRI1Tab	:= RetSQlName( "RI1" )

If Empty(aCriterio)
	fCarrTab( @aTabBenef,"S011", Nil,.T.)
	If !Empty(aTabBenef)
		For nX := 1 to Len(aTabBenef)
			cTipo += aTabBenef[nX,5]
			If nX < Len(aTabBenef)
				cTipo += "','"
			EndIf
		Next nX
	EndIf
	If Empty(aCriterio) .Or. cTipo <> cTipoCri
		CargaCrit(cTipo, @aCriterio)
		cTipoCri := cTipo
	EndIf
EndIf

If Len(aCriterio) > 0
	cWhere 		+= "WHERE RI1_FILIAL = '" + SRA->RA_FILIAL + "' AND "
	cWhere 		+= "RI1_MAT = '" + SRA->RA_MAT + "' AND "
	cWhereBen 	:= "RI1_BENEF IN (" + fSqlIN(cSLYTipo, 2) + ") AND "	
	
	//Verifica se há registros na tabela RI1 com RI1_TPCALC = 2
	cQryRI1 := "SELECT COUNT(*) TOTRI1 FROM " + cRI1Tab + " "
	cQryRI1 += cWhere
	cQryRI1 += cWhereBen
	cQryRI1 += "RI1_TPCALC = '2' AND "
	cQryRI1 += "D_E_L_E_T_ = ' '"

	dbUseArea(.T., "TOPCONN", TcGenQry2( Nil, Nil, cQryRI1, {} ), "QRI1")
	
	If QRI1->TOTRI1 > 0 
		lCarga := .T.
	EndIf 
	QRI1->(dbCloseArea())

	If lCarga
		//--Exclui registros existentes da RI1
		cQryUpd := "UPDATE " + RetSqlName("RI1") + " "
		cQryUpd += "SET D_E_L_E_T_ = '*', R_E_C_D_E_L_ = R_E_C_N_O_ "
		cQryUpd += cWhere
		cQryUpd += cWhereBen
		cQryUpd += "RI1_TPCALC = '2' AND "
		cQryUpd += "D_E_L_E_T_ = ' '"

		TcSqlExec( cQryUpd )
	Else
		//Verifica se há registros na tabela RI1
		cQryRI1 := "SELECT COUNT(*) TOTRI1 FROM " + cRI1Tab + " "
		cQryRI1 += cWhere
		cQryRI1 += cWhereBen
		cQryRI1 += "D_E_L_E_T_ = ' '"

		dbUseArea(.T., "TOPCONN", TcGenQry2( Nil, Nil, cQryRI1, {} ), "QRI1")
		
		If QRI1->TOTRI1 == 0 
			lCarga := .T.
		EndIf 
		QRI1->(dbCloseArea())	
	EndIf

	lDiasMes := ( aScan( aSLYAlias, { |x| x $ "ABS*SA1*TDX" } ) > 0 )

	If lCarga
		If lGrava
			//Carrega aDiasMes
			If lDiasMes
				fVlsAus(,,, @aDiasMes)
				fVlsFerPrg(,,@aDiasMes)
			EndIf
		EndIf
		fCrgAutom(cTipoCri,"OUT",lGrava)
		If !lGrava
			lCarga := !Empty(aBenRI1) //Se não houver critérios lançados para o funcionário, retorna .F. para carregar a definição padrão.
			aBenRI1 := {}
		EndIf
	EndIf
EndIf

RestArea(aArea)

Return lCarga

/*/{Protheus.doc} fSVerbas
Funcao de soma as verbas definidas no cálculo da folha
@author Allyson Mesashi
@since 12/07/2016
@version P12.1.07
@Param cCodigos, Caracter, Código de verbas que serão verificados
@Param nValor, Numérico, Variável contendo o valor das verbas selecionadas
/*/
Static Function fSVerbas(cCodigos, nValor, aVerbas)

Local aPd		:= aClone( If(Type("aBkpPd") != "U" .and. !Empty(aBkpPd), aBkpPd, aVerbas) )
Local cVerbas 	:= ""
Local nFor		:= 0
Local nGarantia	:= 0

// Separa os Codigos das verbas solicitadas a listar
For nFor := 1 To Len(ALLTRIM(cCodigos)) Step 3
	cVerbas += Subs(cCodigos,nFor,3)
	If Len(ALLTRIM(cCodigos)) > ( nFor+3 )
		cVerbas += "/"
	Endif
Next nFor

For nFor := 1 To Len(aPd)
	If aPd[nFor, 3] != cSemana
		Loop
	EndIf
	If aPd[nFor, 1] $ cVerbas
		If RetValSRV( aPd[nFor, 1], SRA->RA_FILIAL, "RV_TIPOCOD" ) == "1"//Proventos
			nValor += aPd[nFor, 5]
		ElseIf RetValSRV( aPd[nFor, 1], SRA->RA_FILIAL, "RV_TIPOCOD" ) == "2"//Descontos
			nValor -= aPd[nFor, 5]
		EndIf
	EndIf
Next nFor

fPosReg("RCE", 1, xFilial("RCE", SRA->RA_FILIAL)+SRA->RA_SINDICA)
nGarantia := RCE->RCE_GCOMIS

If nValor < nGarantia .AND. SRA->RA_CATFUNC $ "C"
	nValor := nGarantia
EndIf

Return Nil


Static Function GetNroPed()

Local aAreaSR0 	:= {}
Local cAliasTab	:= ""

If Empty(cNroPed) .or. cFilPed <> SRA->RA_FILIAL
	aAreaSR0 	:= SR0->( GetArea() )
	cAliasTab	:= GetNextAlias()

	BeginSql Alias cAliasTab
		SELECT MAX(R0_NROPED) NROPED FROM %table:SR0% SR0
		WHERE SR0.R0_FILIAL = %Exp:(xFilial("SR0", SRA->RA_FILIAL))%
			AND %NotDel%
	EndSql

	cNroPed := StrZero( Val((cAliasTab)->NROPED)+1, nTamPed )

	(cAliasTab)->( dbCloseArea() )

	cFilPed := SRA->RA_FILIAL

	RestArea( aAreaSR0 )
	
EndIf

Return cNroPed

/*/{Protheus.doc} CustoVales
Como podemos ter mais de um pedido por periodo é preciso recalcular os custos
@author Flavio Correa
@since 12/08/2016
@version P12.1.07
/*/
Static Function CustoVales(cTipo)
Local aArea			:= GetArea()
Local nCustFunc		:= 0
Local nCalc			:= 0
Local nFechF		:= 0
Local nCustAux		:= 0
Local nI			:= 1
Local aCalc			:= {}
Local cCod			:= ""
Local nTeto			:= 0
Local cAliasQry		:= ""

Private nPercentual	:= RetValSRV(aCodFol[051, 1], SRA->RA_FILIAL, "RV_PERC")

DEFAULT lGp210Sal	:= ExistBlock("GP210SAL")

If cTipo == "0"
	If lGp210Sal
		EXECBLOCK("GP210SAL", .F. , .F. ) //Retorna nPercentual
		If ValType(nPercentual) <> "N"
			nPercentual := 6
		EndIf
	EndIf

	If SRA->RA_CATFUNC $ "E*G"
		nCustFunc := nPercentual := 0
	Else
		nCustFunc := Round(NSALBSVT * ( nPercentual / 100 ),2) //Custo Mensal do Funcionario
	EndIf

	DbSelectArea("SR0")
	SR0->(DbSetOrder(RetOrder("SR0", "R0_FILIAL+R0_MAT+R0_TPVALE+R0_CODIGO+R0_PEDIDO")))
	SR0->(DbSeek(SRA->RA_FILIAL+SRA->RA_MAT+cTipo+cPeriodo))
	While !SR0->(Eof()) .And. SR0->(R0_FILIAL+R0_MAT+R0_TPVALE+R0_PERIOD) == SRA->RA_FILIAL+SRA->RA_MAT+cTipo+cPeriodo
		If SR0->R0_PEDIDO == "1"
			nCalc += SR0->R0_VALCAL
			Aadd(aCalc,SR0->(Recno()))
		Else
			nCustFunc := Max(nCustFunc - SR0->R0_VLRFUNC,0)
		EndIf
		SR0->(dbSkip())
	EndDo

	For nI := 1 To Len(aCalc)
		SR0->(dbGoto(aCalc[nI]))
		RecLock("SR0",.F.)
		If nCustFunc > nCalc
			SR0->R0_VLRFUNC := SR0->R0_VALCAL
			SR0->R0_VLREMP := 0
		Else
			If nI == Len(aCalc)
				SR0->R0_VLRFUNC := nCustFunc - nCustAux
			Else
				SR0->R0_VLRFUNC := Round(nCustFunc / nCalc * SR0->R0_VALCAL, 2) //Rateia custo do VT
				nCustAux += SR0->R0_VLRFUNC
			EndIf
			SR0->R0_VLREMP := SR0->R0_VALCAL - SR0->R0_VLRFUNC  //Custo Empresa
		EndIf

		SR0->(msUnlock())

	Next nI
Else
	cAliasQry := GetNextAlias()
	BeginSql alias cAliasQry
		SELECT SR0.R_E_C_N_O_ AS RECSR0,SR0.*
		FROM %table:SR0% SR0
		WHERE R0_FILIAL = %exp:SRA->RA_FILIAL%
		AND R0_MAT = %exp:SRA->RA_MAT%
		AND R0_TPVALE = %exp:cTipo%
		AND R0_PERIOD = %exp:cPeriodo%
 	    AND SR0.%notDel%
 	    ORDER BY R0_PEDIDO DESC
	EndSql
	cCod := ""
	While !(cAliasQry)->(Eof()) .And. (cAliasQry)->(R0_FILIAL+R0_MAT+R0_TPVALE) == SRA->RA_FILIAL+SRA->RA_MAT+cTipo
		SR0->(dbGoto( (cAliasQry)->RECSR0))
		If cCod <> (cAliasQry)->R0_CODIGO
			nTeto := 0
			nFechF := 0
			If RFO->(DbSeek(xFilial("RFO")+(cAliasQry)->(R0_TPVALE + R0_CODIGO)))
		    	nTeto	 := RFO->RFO_TETO
		    EndIf
	    EndIf

	    If nTeto <= 0
	    	cCod := (cAliasQry)->R0_CODIGO
	    	(cAliasQry)->(dbSkip())
	    	Loop
	    EndIf


	    If (nFechF + (cAliasQry)->R0_VLRFUNC) >= nTeto
	    	nVal :=  nTeto  - nFechF
	    	If nVal > 0
		    	RecLock("SR0",.F.)
		    		SR0->R0_VLRFUNC := nVal
		    		SR0->R0_VLREMP  := (cAliasQry)->R0_VALCAL - nVal
		    	SR0->(msUnlock())
		    Else
		    	RecLock("SR0",.F.)
		    		SR0->R0_VLRFUNC := 0
		    		SR0->R0_VLREMP  := (cAliasQry)->R0_VALCAL
		    	SR0->(msUnlock())
		    EndIf
	    Endif
	    nFechF += (cAliasQry)->R0_VLRFUNC

		cCod := (cAliasQry)->R0_CODIGO
		(cAliasQry)->(dbSkip())
	EndDo
	(cAliasQry)->(dbCloseArea())
EndIf
RestArea(aArea)
Return

/*/{Protheus.doc} FaltasDes
faltas ja descontadas da tabela SP7 = faltas da tabela SR0 com pedido = 2
@author Flavio Correa
@since 12/08/2016
@version P12.1.07
/*/
Static Function FaltasDes(cPeriodo,dDt1,dDt2)
Local aArea		:= GetArea()
Local nDescont 	:= 0
Local cAliasQry	:= GetNextAlias()
Local cTipoVale := If(cTipoRot == "8","0",(If(cTipoRot == "D","1","2"))) //0-Vale Transporte / 1-Vale Refeição / 2-Vale Alimentação

DEFAULT dDt1 	:= aPeriodo[nPosSem,3] //Data inicial do periodo de calculo
DEFAULT dDt2 	:= aPeriodo[nPosSem,4] //Data final do periodo de calculo

dbSelectArea("SP7")

//nao pegar faltas que sao do mesmo periodo(inicio/Fim), pois se for considerar recalculo e sobreescrever as faltas
BeginSql alias cAliasQry
	SELECT SUM(P7_DFALT) TOTALFAL
	FROM %table:SP7% SP7
	WHERE SP7.%notDel%
    AND SP7.P7_FILIAL = %exp:SRA->RA_FILIAL%
    AND SP7.P7_MAT = %exp:SRA->RA_MAT%
    AND SP7.P7_PERIOD = %exp:cPeriodo%
    AND SP7.P7_DATAINI <> %exp:dDt1%
    AND SP7.P7_DATAFIM <> %exp:dDt2%
EndSql
nDescont := (cAliasQry)->TOTALFAL
(cAliasQry)->(DbCloseArea())

BeginSql alias cAliasQry
	SELECT DISTINCT R0_NROPED, R0_FALTAS
	FROM %table:SR0% SR0
	WHERE SR0.%notDel%
    AND SR0.R0_FILIAL = %exp:SRA->RA_FILIAL%
    AND SR0.R0_MAT = %exp:SRA->RA_MAT%
    AND SR0.R0_PERIOD = %exp:cPeriodo%
    AND SR0.R0_TPVALE = %exp:cTipoVale%
    AND SR0.R0_PEDIDO ='2'
EndSql
While !(cAliasQry)->(Eof())
	nDescont += (cAliasQry)->R0_FALTAS
	(cAliasQry)->(dbskip())
EndDo
(cAliasQry)->(DbCloseArea())


RestArea(aArea)
Return nDescont

/*/{Protheus.doc} GravaSP7
Grava faltas descontadas
@author Flavio Correa
@since 12/08/2016
@version P12.1.07
/*/
Static Function GravaSP7(nValor,dDt1,dDt2)
Local aArea	:= GetArea()
Local lNovo	:= .T.

DEFAULT dDt1 	:= aPeriodo[nPosSem,3] //Data inicial do periodo de calculo
DEFAULT dDt2 	:= aPeriodo[nPosSem,4] //Data final do periodo de calculo


dbSelectArea("SP7")

lNovo := !(SP7->(dbSeek(SRA->RA_FILIAL+ SRA->RA_MAT+cPeriodo+dtos(dDt1)+dtos(dDt2))))
RecLock("SP7",lNovo)
	SP7->P7_FILIAL 	:= SRA->RA_FILIAL
	SP7->P7_MAT		:= SRA->RA_MAT
	SP7->P7_PERIOD	:= cPeriodo
	SP7->P7_DFALT	:= nValor
	SP7->P7_DATAINI	:= dDt1
	SP7->P7_DATAFIM	:= dDt2
SP7->(msUnlock())

RestArea(aArea)
Return

/*/{Protheus.doc} NovoCalcBEN
Usa o calculo novo ou nao do beneficios
@author Flavio Correa
@since 12/08/2016
@version P12.1.07
@see http://tdn.totvs.com/x/ikyZDg
/*/
Function NovoCalcBEN()
Return .T.

/*/{Protheus.doc} fRetBenAnt
Verifica o último mês de pagamento de beneficio para o funcionário
@author Leandro Drumond
@since 19/08/2017
@version P12.1.17
/*/
Function fRetBenAnt( cFilFunc, cMatFunc, cProcFunc, cTipoVale, aPerAux, lVT )

	Local aArea		:= GetArea()
	Local cAnoAux	:= ""
	Local cMesAux	:= ""
	Local dDtIni	:= Ctod("//")
	Local cAliasQuey	:= GetNextAlias()
	Local cTipo		:= If(cTipoVale == "2", "VA", If(cTipoVale == "1", "VR", ""))

    Default lVT     := .F.

	BeginSQL Alias cAliasQuey

		COLUMN RCH_DTINI AS DATE
		COLUMN RCH_DTFIM AS DATE

		SELECT RCH_PER, RCH_NUMPAG, RCH_MES, RCH_ANO, RCH_DTINI, RCH_DTFIM, RCH_DTFECH

		FROM %Table:RCH% RCH

		WHERE RCH.RCH_FILIAL = %Exp:xFilial("RCH", cFilFunc)%
		AND RCH.RCH_PROCES = %Exp:cProcFunc%
		AND RCH.RCH_ROTEIR = %Exp:fGetCalcRot(cTipoRot)%
		AND RCH.%notDel%

		ORDER BY RCH_DTINI DESC

	EndSQL

	// Último período fechado
	While ! (cAliasQuey)->(Eof())
		If ! Empty((cAliasQuey)->RCH_DTFECH)
			cAnoAux := (cAliasQuey)->RCH_ANO
			cMesAux := (cAliasQuey)->RCH_MES
			dDtIni	:= (cAliasQuey)->RCH_DTINI
			Exit
		EndIf
		(cAliasQuey)->(dbSkip())
	EndDo

	(cAliasQuey)->(dbCloseArea())

	If !lVT
        BeginSQL Alias cAliasQuey

            SELECT LY_AGRUP

            FROM %Table:SLY% SLY

            WHERE SLY.LY_FILIAL = %Exp:xFilial("SLY", cFilFunc)%
            AND SLY.LY_TIPO = %Exp:cTipo%
            AND SLY.LY_DTINI <= %Exp:dTos(dDtIni)%
            AND SLY.%notDel%

        EndSQL
    EndIf

	// Só faz o recalculo se no perído havia calculo automático configurado
	If lVT .Or. P_RECALBEN .Or. (cAliasQuey)->( !Eof() )
		fRetPerComp(cMesAux, cAnoAux, , cProcFunc, fGetCalcRot(cTipoRot), , , @aPerAux)
	EndIf

	If !lVT
        (cAliasQuey)->(dbCloseArea())
    EndIf

	RestArea(aArea)

Return Nil

/*/{Protheus.doc} NroDias
Calcula o número de dias que deve ser pago para o benefício em determinada entidade
@author cicero.pereira
@since 30/09/2017
@param cEntidade, characters, Entidade do critério que está sendo calculada
@param cChave, characters, Código referente a entidade informada
@param dDataDe, date, Início do período
@return nDias, numerico
@param dDataAte, date, Fim do período
@sample
	NroDias("CTT", "000000001", cTod("01/09/2017"), cTod("30/09/2017"))
	Verifica quantos dias o funcionário ficou no Centro de custo 000000001, verificando transferências
	e retorna a quantidades de dias válidos para o pagamento do benefício
/*/
Static Function NroDias( cEntidade, cChave, dDataDe, dDataAte, cPeriod, lRepete, lVT )

	Local nDias		:= 0
	Local nI		:= 0
	Local nPosDe	:= 0
	Local nPosPara	:= 0
	Local nPosData	:= 7
	Local aTransf	:= {}
	Local dAuxPara	:= Ctod("//")

	Default cPeriod := ""
	Default lRepete := .F.
	Default lVT     := .F.

	If Empty(_aDias)
		fCarrAdias(dDataDe, dDataAte, cPeriod)
	EndIf

	If !lVT
        If cEntidade == "CTT" // Centro de Custo
            fTransf(@aTransf, MesAno(dDataDe), , , .T., , , , , , , , SRA->RA_FILIAL, SRA->RA_MAT)
            nPosDe		:= 3
            nPosPara	:= 6
        ElseIf cEntidade == "SQB" // Departamento
            fTransf(@aTransf, MesAno(dDataDe), , , , , , , , .T., , , SRA->RA_FILIAL, SRA->RA_MAT)
            nPosDe		:= 16
            nPosPara	:= 17
        ElseIf cEntidade == "RCL" // Posto
            fTransf(@aTransf, MesAno(dDataDe), , , , , , , , , .T., , SRA->RA_FILIAL, SRA->RA_MAT)
            nPosDe		:= 18
            nPosPara	:= 19
        ElseIf cEntidade == "SM0" // Filial
            fTransf(@aTransf, MesAno(dDataDe), , .T., , , , , , , , , SRA->RA_FILIAL, SRA->RA_MAT)
            nPosDe		:= 2
            nPosPara	:= 5
            cChave += SRA->RA_MAT
        ElseIf cEntidade == "RCE" .or.  cEntidade == "SWY"// Sindicato
            aTransf		:= HistSRA("RCE")
            nPosData	:= 1
            nPosDe		:= 2
            nPosPara	:= 3
        ElseIf cEntidade == "SQ3" // Cargo
            aTransf		:= HistSRA("SQ3")
            nPosData	:= 1
            nPosDe		:= 2
            nPosPara	:= 3
        ElseIf cEntidade == "SR6" // Turno
            aTransf		:= HistSPF(dDataDe, dDataAte)
            nPosData	:= 1
            nPosDe		:= 2
            nPosPara	:= 3
        ElseIf cEntidade == "SRJ" // Função
            aTransf		:= HistSR7()
            nPosData	:= 1
            nPosDe		:= 2
            nPosPara	:= 3
        EndIf
	EndIf

	If !Empty(aTransf)
		For nI := 1 To Len(aTransf)
			If ( cEntidade == "SWY" .and. aTransf[nI][nPosDe] $ cChave ) .or. ( cEntidade <> "SWY" .and. aTransf[nI][nPosDe] == cChave ) // Saindo
				If ! Empty(dAuxPara)
					nDias += VldDiasRH(dAuxPara, aTransf[nI][nPosData], lRepete)
					dAuxPara := Ctod("//")
				Else
					nDias += VldDiasRH(dDataDe, aTransf[nI][nPosData], lRepete)
				EndIf
			ElseIf ( cEntidade == "SWY" .and. aTransf[nI][nPosPara] $ cChave ) .or. ( cEntidade <> "SWY" .and. aTransf[nI][nPosPara] == cChave ) // Entrando
				dAuxPara := aTransf[nI][nPosData]
			EndIf
		Next
		If ! Empty(dAuxPara)
			nDias += VldDiasRH(dAuxPara, dDataAte + 1, lRepete)
		EndIf
	Else
		nDias += VldDiasRH( dDataDe, dDataAte + 1, lRepete, lVT )
	EndIf

Return nDias

/*/{Protheus.doc} HistSPF
Busca histórico de alterações do turno de trabalho
@author cicero.pereira
@since 02/10/2017
@param dInicio, date, Data inicial da pesquisa
@param dFim, date, Data final da pesquisa
/*/
Function HistSPF(dInicio, dFim)

	Local cAliasSPF := GetNextAlias()
	Local aAlt		:= {}

	BeginSQL Alias cAliasSPF
		Column  PF_DATA As Date
		SELECT PF_DATA, PF_TURNODE, PF_TURNOPA
		FROM %Table:SPF% SPF
		WHERE PF_FILIAL = %Exp:xFilial("SPF", SRA->RA_FILIAL)%
		AND SPF.PF_MAT = %Exp:SRA->RA_MAT%
		AND SPF.PF_DATA >= %Exp: dTos(dInicio)%
		AND SPF.PF_DATA <= %Exp: dTos(dFim)%
		AND SPF.%notDel%
	EndSQL

	While ! (cAliasSPF)->(Eof())
		Aadd(aAlt, {(cAliasSPF)->PF_DATA, Alltrim((cAliasSPF)->PF_TURNODE), Alltrim((cAliasSPF)->PF_TURNOPA)})
		(cAliasSPF)->(dbSkip())
	EndDo

	(cAliasSPF)->(dbCloseArea())

Return aAlt

/*/{Protheus.doc} VldDiasRH
Retorna quanto dias válidos para o pagamento do benefício, atualiza o _aDias
@author cicero.pereira
@since 30/09/2017
@param dInicio, date, Início do período
@param dFim, date, Fim do período
/*/
Static Function VldDiasRH( dInicio, dFim, lRepete, lVT )

	Local lGS       := .F.
	Local nDias	    := 0
	Local nI	    := 0

	Default lRepete := .F.
	Default lVT     := .F.

    lGS := !lVT .And. SuperGetMV("MV_TECXRH", NIL, .F. ) .AND. SuperGetMV("MV_GSBENAG", NIL, .F. ) .AND. FindFunction("TecBVldBnf")

	For nI := 1 To Len(_aDias)
		If _aDias[nI][1] >= dInicio .And. _aDias[nI][1] < dFim .And. (_aDias[nI][Len(_aDias[nI])] == 0 .Or. lRepete)
			If lGS
				IF TecBVldBnf(_aDias[nI],SRA->RA_FILIAL, SRA->RA_MAT)
					nDias++
					If cTipoRot != "I"
						_aDias[nI][Len(_aDias[nI])] := 1
					EndIf
				EndIf
			ElseIf _aDias[nI][4]
				nDias++
				If cTipoRot != "I"
					_aDias[nI][Len(_aDias[nI])] := 1
				EndIf
			EndIf
		EndIf
	Next

Return nDias

/*/{Protheus.doc} HistSRA
Busca o Histórico de alterações de um campo da SRA em determinado período
@author cicero.pereira
@since 29/09/2017
@param cEntidade, characters, Define qual campo será buscado. Ex.: Entidade RCE retorna o hitórico do campo RA_SINDICA
@param dInicio, date, Data para inicio da busca
@return aAlt, array
@example
	HistSRA("RCE", cTod("01/09/2017"))

	Retorna o array aAlt com as alterações do campo RA_SINDICA sendo:
	aAlt[nI][1] = Data da alteração
	aAlt[nI][1] = Conteúdo De
	aAlt[nI][1] = Conteúdo Para
/*/
Static Function HistSRA(cEntidade)

	Local cAliasSR9 := GetNextAlias()
	Local aAlt		:= {}
	Local cCampo	:= ""
	Local cCodAux	:= ""
	Local lFrist	:= .T.
	
	Static nTamSind

	DEFAULT nTamSind  := TamSX3("RA_SINDICA")[1]

	If cEntidade == "RCE"
		cCampo := "RA_SINDICA"
	ElseIf cEntidade == "SQ3"
		cCampo := "RA_CARGO"
	EndIf

	BeginSQL Alias cAliasSR9
		Column  R9_DATA As Date
		SELECT R9_DATA, R9_DESC
		FROM %Table:SR9% SR9
		WHERE SR9.R9_FILIAL = %Exp:SRA->RA_FILIAL%
		AND SR9.R9_MAT = %Exp:SRA->RA_MAT%
		AND SR9.R9_CAMPO = %Exp:cCampo%
		AND SR9.%notDel%
	EndSQL

	While ! (cAliasSR9)->(Eof())
		If lFrist
			cCodAux := If(cEntidade == "RCE", PadR((cAliasSR9)->R9_DESC,nTamSind), Alltrim((cAliasSR9)->R9_DESC))
			lFrist := .F.
		Else
			Aadd(aAlt, {(cAliasSR9)->R9_DATA, cCodAux, If(cEntidade == "RCE", PadR((cAliasSR9)->R9_DESC,nTamSind), Alltrim((cAliasSR9)->R9_DESC))})
			cCodAux := If(cEntidade == "RCE", PadR((cAliasSR9)->R9_DESC,nTamSind), Alltrim((cAliasSR9)->R9_DESC))
		EndIf
		(cAliasSR9)->(dbSkip())
	EndDo
	(cAliasSR9)->(dbCloseArea())

Return aAlt

/*/{Protheus.doc} HistSR7
Busca o histórico das alterações de função do funcionário posicionado
@author cicero.pereira
@since 29/09/2017
@return aAlt, Array, Array contendo todas as alterações de função do funcionário
@sample
	HistSR7()

	Retorna aAlt sendo:
	aAlt[nI][1] = Data da alteração
	aAlt[nI][2] = Função De
	aAlt[nI][2] = Função Para
/*/
Static Function HistSR7()

	Local cAliasSR7 := GetNextAlias()
	Local aAlt		:= {}
	Local lFrist	:= .T.
	Local cFuncAux	:= ""

	BeginSQL Alias cAliasSR7
		Column  R7_DATA As Date
		SELECT R7_DATA, R7_FUNCAO
		FROM %Table:SR7% SR7
		WHERE SR7.R7_FILIAL = %Exp:SRA->RA_FILIAL%
		AND SR7.R7_MAT = %Exp:SRA->RA_MAT%
		AND SR7.%notDel%
	EndSQL

	While ! (cAliasSR7)->(Eof())
		If lFrist
			cFuncAux := Alltrim((cAliasSR7)->R7_FUNCAO)
			lFrist := .F.
		ElseIf cFuncAux != Alltrim((cAliasSR7)->R7_FUNCAO)
			Aadd(aAlt, {(cAliasSR7)->R7_DATA, cFuncAux, Alltrim((cAliasSR7)->R7_FUNCAO)})
			cFuncAux := Alltrim((cAliasSR7)->R7_FUNCAO)
		EndIf
		(cAliasSR7)->(dbSkip())
	EndDo
	(cAliasSR7)->(dbCloseArea())

Return aAlt

/*/{Protheus.doc} fCarrAdias
Carrega os dias do mês validando em quais dias devem ser pagos os benefícios
@author cicero.pereira
@since 30/09/2017
@param dInicio, date, Inicio do período
@param dFim, date, Fim do período
@param cPeriod, caracter, Código do período que será carregado
/*/
Static Function fCarrAdias(dInicio, dFim, cPeriod)

	Local nI, nJ		:= 0
	Local lPropAdm		:= .F. //APERGUNTE[1,3] == 1	// Se calcula proporcional a admissão
	Local lDesAfast		:= .F. //APERGUNTE[2,3] <> 2	// Se desconta férias/astamentos
	Local lDesFerProg	:= .F. //APERGUNTE[3,3] == 1	// Se calcula proporcional a férias programadas
	Local lDesFaltas	:= .F. //APERGUNTE[4,3] == 1	// Se desconta faltas
	Local cTipoAfas		:= ""
	Local aAfast		:= {}
	Local aPerAnt		:= {}
	//Local nAfaFer	:= If(cTipoRot == "I", 0, If(cTipoRot == '8', aPergunte[3,3], aPergunte[2,3]))
	Static _aDias		:= {}

	Default cPeriod := ""
	DEFAULT __lMemCalc	:= cPaisLoc == "BRA" .And. fMemCalc() // Memória de Cálculo

	If cTipoRot == "8"
		lPropAdm	:= APERGUNTE[2,3] == 1	// Se calcula proporcional a admissão
		lDesAfast	:= APERGUNTE[3,3] <> 2	// Se desconta férias/astamentos
		lDesFerProg	:= APERGUNTE[4,3] == 1	// Se calcula proporcional a férias programadas
		lDesFaltas	:= APERGUNTE[5,3] == 1	// Se desconta faltas
	ElseIf cTipoRot $ "D*E"
		lPropAdm	:= APERGUNTE[1,3] == 1	// Se calcula proporcional a admissão
		lDesAfast	:= APERGUNTE[2,3] <> 2	// Se desconta férias/astamentos
		lDesFerProg	:= APERGUNTE[3,3] == 1	// Se calcula proporcional a férias programadas
		lDesFaltas	:= APERGUNTE[4,3] == 1	// Se desconta faltas
	EndIf

	If __lMemCalc
		fAddMemLog("Proporcional a férias : " + If(lDesFerProg,"Sim","Não") ,1,2)
		fAddMemLog("Proporcional a admissão/reintegração : " + If(lPropAdm,"Sim","Não") ,1,2)
		fAddMemLog("Desconta faltas  : " + If(lDesFaltas,"Sim","Não") ,1,2)
		fAddMemLog("Desconta afastamentos  : " + If(lDesAfast,"Sim","Não") ,1,2)
	EndIf

	If !Empty(cPeriod) // Se estiver preenchido está recalculando o mês anterior
		fCarPeriodo( cPeriod , cRot, @aPerAnt, , , ! IsBlind(), )
		fCarDiasMes(@_aDias, lPropAdm, aPerAnt)
	Else
		fCarDiasMes(@_aDias, lPropAdm)
	EndIf

	If lDesAfast
		If cTipoRot == "8"
			If aPergunte[2,3] > 1
				cTipoAfas := If(aPergunte[2,3] == 3, '4','123')
			EndIf
		Else
			If aPergunte[2,3] > 1
				cTipoAfas := If(aPergunte[3,3] == 3, '4','123')
			EndIf
		EndIf

		fRetAfas(dInicio, dFim, , , ,cTipoAfas , @aAfast)
		For nI := 1 To Len(aAfast)
			For nJ := 1 To Len(_aDias)
				If _aDias[nJ][1] >= aAfast[nI][3] .And. (_aDias[nJ][1] <= aAfast[nI][4] .Or. Empty(aAfast[nI][4]))
					_aDias[nJ][4] := .F.
				EndIf
			Next
		Next
	EndIf

	If lDesFerProg
		fVlsFerPrg(dInicio, dFim, @_aDias, .T.)
	EndIf

	For nI := 1 To Len(_aDias)
		Aadd(_aDias[nI], 0)
	Next

Return

/*/{Protheus.doc} AtuSM7Aut
Grava Registro na SM7
@author cicero.pereira
@since 09/10/2017
@version 12.1.17
@param cTpVale, characters, Tipo do vale: 1 Vale Refeição; 2 Vale Alimentação
@param cCodBen, characters, Código do benefício
/*/
Static Function AtuSM7Aut(cTpVale, cCodBen)

	Local aArea	:= GetArea()

	dbSelectArea("SM7")

	RecLock("SM7", .T.)
		SM7->M7_FILIAL := xFilial("SM7", SRA->RA_FILIAL)
		SM7->M7_MAT := SRA->RA_MAT
		SM7->M7_TPCALC := "2"	// Cálculo automático
		SM7->M7_TPVALE := cTpVale
		SM7->M7_CODIGO := cCodBen
		SM7->M7_COMPL := "2"
	SM7->(MSUnlock())

	RestArea(aArea)

Return

/*/{Protheus.doc} fVlDemMs
Verifica demissao mes seguinte para pagamento de beneficios
@author Esther de Viveiro
@since 03/10/2017
@version P12.1.14
/*/
Function fVlDemMs()
	Local aArea		:= GetArea()
	Local lGpem040 	:= FunName() == "GPEM040" .or. FunName() == "GPEM040B"

	If !lGpem040 //Se esta sendo calculado pela rescisão, a data de demissão já esta preenchida, mas a SRG ainda não foi gravada.
		dDataDem	:= StoD("//")

		//verifica se ha calculo de rescisao para o periodo de processamento do beneficio
		SRG->( DbSetOrder(1) )	// Ordem 1 - RetOrdem( "SRG", "RG_FILIAL+RG_MAT+DTOS(RG_DTGERAR)")
		If SRG->(DbSeek( SRA->RA_FILIAL + SRA->RA_MAT))
			While SRG->(!Eof()) .and. SRG->(RG_FILIAL+RG_MAT) == SRA->(RA_FILIAL + RA_MAT)
				If SRG->RG_EFETIVA == 'S' .AND. AnoMes(SRG->RG_DATADEM) <= cPeriodo
					dDataDem := (SRG->RG_DATADEM)
				EndIf
				SRG->(dbSkip())
			EndDo
		EndIf

		RestArea(aArea)
	EndIf
Return Nil

/*/{Protheus.doc} RestXCBEN
Reinicia variáveis Static do fonte GPEXCBEN
@author cicero.pereira
@since 14/11/2017
/*/
Function RestXCBEN()

	nFaltasAut	:= 0
	nDiasRef	:= 0
	aCriterio 	:= {}
	lUsaCPer	:= GetMvRH("MV_USACPER",, .F.) //.T.=Usa periodo folha/.F.= usa calendario ponto
	cTipoCri	:= ""

Return

/*/{Protheus.doc} RestXCBEN
Reinicia cNroPed
@author Allyson Mesashi
@since 30/07/2021
/*/
Function RstNroPed()

cNroPed := ""

Return

/*/{Protheus.doc} fLoadCCT
Carrega sindicatos associados a CCT
@author Leandro Drumond
@since 23/05/2022
/*/
Static Function fLoadCCT(cCodCCT, cFilSRA)
Local aRet  		:= {"##"}
Local cAliasQry 	:= GetNextAlias()
Local cFilRCE       := xFilial("RCE", cFilSRA)

BeginSql alias cAliasQry
	SELECT RCE_CODIGO
	FROM %table:RCE% RCE
	WHERE RCE_CCT = %exp:cCodCCT% AND
	RCE_FILIAL = %exp:cFilRCE% AND
	RCE.%notDel%
EndSql

If !(cAliasQry)->( EOF() )
	aRet := {}
	While !(cAliasQry)->( EOF() )
		aAdd(aRet, (cAliasQry)->RCE_CODIGO)
		(cAliasQry)->( DbSkip() )
	EndDo
EndIf

(cAliasQry)->(DbCloseArea())

Return aRet

/*/{Protheus.doc} fBuscaCCT
Busca o código da CCT associado ao sindicato
@author Leandro Drumond
@since 02/06/2022
/*/
Static Function fBuscaCCT(cSindicato)
Local aArea		:= GetArea()
Local cRet		:= ""

DbSelectArea("RCE")
RCE->(DbSetOrder(1))

If RCE->(DbSeek(xFilial("RCE") + cSindicato))
	cRet := RCE->RCE_CCT
EndIf

RestArea(aArea)

Return cRet

/*{Protheus.doc} GetDiasTab
Carrega os dias de beneficio de acordo com a tabela de horário padrão
@author Leandro Drumond
@since 23/08/2022
*/
Static Function GetDiasTab(aTabCalend, aDiaVales, lPropFerias, lFeriado, lVT, nDUtil, nDiaNUtil, nDiasSeg, nDiasTer, nDiasQua, nDiasQui, nDiasSex, nDiasSab, nDiasDom, nDias, nDiaNTran, lComplS151, aCfgS151)

Local dDtAux	:= CtoD("")
Local nX 		:= 0
Local nDiaSem 	:= 0
Local nPos 		:= 0
Local nPosDMes  := 0
Local lSoma 	:= .F.
Local cDiaSem	:= ""

DEFAULT lComplS151  := .F.
DEFAULT aCfgS151    := .T.

For nX := 1 to Len(aTabcalend)
	If lComplS151 .And. ( aScan( aDiasMes, { |x| x[1] == aTabCalend[nX, 1] } ) == 0 .Or. !fVldS151( aCfgS151, "1", SM7->M7_CODIGO, aTabCalend[nX, 1], aTabCalend[nX, 6] ) )
        Loop
    EndIf
    
	lSoma	:= .F.
	cDiaSem := Alltrim( Upper(cDow( aTabCalend[nX][1] ) ))

	Do Case
		Case cDiaSem == "MONDAY"
			nDiaSem := 1
		Case cDiaSem == "TUESDAY"
			nDiaSem := 2
		Case cDiaSem == "WEDNESDAY"
			nDiaSem := 3
		Case cDiaSem == "THURSDAY"
			nDiaSem := 4
		Case cDiaSem == "FRIDAY"
			nDiaSem := 5
		Case cDiaSem == "SATURDAY"
			nDiaSem := 6
		Otherwise
			nDiaSem := 7
	EndCase

	If aDiaVales[nDiaSem] > 0
		If aTabCalend[nX][6] == "S" .and. nDUtil > 0
			nDias++
		ElseIf aTabCalend[nX][6] <> "S" .and. nDiaNUtil > 0
			nDiaNTran++
		EndIf
	EndIf

	dDtAux      := aTabCalend[nX][1]
    nPosDMes    := aScan( aDiasMes, { |x| x[1] == dDtAux } )

	If nPosDMes == 0 
		Loop 
	EndIf

	If lVT .or. ( aDiasMes[nPosDMes][4] .or.(  aTabCalend[nX][19] == .F. .And. nDiaNUtil > 0 .And. aDiaVales[nDiaSem] > 0 ) )
		If lPropFerias			
			nPos := aScan(aDiasMes,{|y| y[1] == dDtAux})
			If !lVT .or. ( nPos == 0 .or. aDiasMes[nPos,5] <> 'PRG' ) //Se for vale transporte ou o dia estiver configurado para pagamento de beneficio
				If (Empty(dDataDem) .OR. aTabCalend[nX][1] < dDataDem)
					If ( aTabCalend[nX][6] == "S" .And. !aTabCalend[nX][19] ) ; //Se tipo de dia é trabalhado e não é feriado
						.or. ;
					   ( !aTabCalend[nX][19] .And. nDiaNUtil > 0 .And. aDiaVales[nDiaSem] > 0) ; //Se dia não for trabalhado, não for feriado, pagar dias não úteis e pagar vale no dia especifico da semana
						.or. ;
						( lFeriado .and. ( aTabCalend[nX][6] == "F" .And. !aTabCalend[nX][24] .And. aTabCalend[nX][36] == "S") ) ; //Se for feriado, pagar feriado  e funcionário não estiver afastado
						.or. ;
						( lFeriado .and.  ( aTabCalend[nX][6] == "S" .And. !aTabCalend[nX][24] .And. aTabCalend[nX][36] == "S" .And. aTabCalend[nX][19]) )
							lSoma := .T.
					EndIf 
				EndIf 
			EndIf
		Else
			If (Empty(dDataDem) .OR. aTabCalend[nX][1] < dDataDem)
				If ( aTabCalend[nX][6] == "S" .And. !aTabCalend[nX][19] ) ;
					.or. ;
				( !aTabCalend[nX][19] .And. nDiaNUtil > 0 .And. aDiaVales[nDiaSem] > 0) ;
					.or. ;
				( lFeriado .and. (aTabCalend[nX][6] == "F" .And. !aTabCalend[nX][24] .And. aTabCalend[nX][36] == "S" ) ) ;
					.or. ;
				( lFeriado .and. (aTabCalend[nX][6] == "S" .And. !aTabCalend[nX][24] .And. aTabCalend[nX][36] == "S" .And. aTabCalend[nX][19]) ) ;
					.or. ;
				( aTabCalend[nX][6] == "N" .And. !aTabCalend[nX][19] .And. aTabCalend[nX][24] .And. aTabCalend[nX][36] == "S" ) ;
                    .Or. ;
                ( lComplS151 )
					lSoma := .T.
				EndIf 
			EndIf 
		EndIf

		If lSoma
			Do Case
				Case cDiaSem == "MONDAY"
					nDiasSeg++
                    aDiasMes[nPosDMes, 7] := SM7->M7_VALSEG
				Case cDiaSem == "TUESDAY"
					nDiasTer++
                    aDiasMes[nPosDMes, 7] := SM7->M7_VALTER
				Case cDiaSem == "WEDNESDAY"
					nDiasQua++
                    aDiasMes[nPosDMes, 7] := SM7->M7_VALQUA
				Case cDiaSem == "THURSDAY"
					nDiasQui++
                    aDiasMes[nPosDMes, 7] := SM7->M7_VALQUI
				Case cDiaSem == "FRIDAY"
					nDiasSex++
                    aDiasMes[nPosDMes, 7] := SM7->M7_VALSEX
				Case cDiaSem == "SATURDAY"
					nDiasSab++
                    aDiasMes[nPosDMes, 7] := IIf( SM7->M7_VALSAB > 0, SM7->M7_VALSAB, IIf( SM7->M7_QDNUTIL > 0, SM7->M7_QDNUTIL, SM7->M7_QDIAINF ) )
				Otherwise
					nDiasDom++
                    aDiasMes[nPosDMes, 7] := IIf( SM7->M7_VALDOM > 0, SM7->M7_VALDOM, IIf( SM7->M7_QDNUTIL > 0, SM7->M7_QDNUTIL, SM7->M7_QDIAINF ) )
			EndCase	
		EndIf
	EndIf
Next nX

If __lMemCalc
	fAddMemLog("Qtd dias de Segunda : " +  cValtoChar(nDiasSeg) ,1,2)
	fAddMemLog("Qtd dias de Terça   : " +  cValtoChar(nDiasTer) ,1,2)
	fAddMemLog("Qtd dias de Quarta  : " +  cValtoChar(nDiasQua) ,1,2)
	fAddMemLog("Qtd dias de Quinta  : " +  cValtoChar(nDiasQui) ,1,2)
	fAddMemLog("Qtd dias de Sexta   : " +  cValtoChar(nDiasSex) ,1,2)
	fAddMemLog("Qtd dias de Sabado  : " +  cValtoChar(nDiasSab) ,1,2)
	fAddMemLog("Qtd dias de Domingo : " +  cValtoChar(nDiasDom) ,1,2)
EndIf

Return Nil

/*{Protheus.doc} fDiasS151
Verifica apontamentos do ponto em busca dos dias que tiveram horas extras para cálculo do complemento de 
benefícios (VA, VR e VT) conforme configuração da tabela S151
@author Allyson Luiz Mesashi
@since 20/07/2023
*/
Static Function fDiasS151( dPerIni, dPerFim )

Local aDiasHe       := {}
Local cAliasQry     := GetNextAlias()
Local cQuery        := ""
Local nCont         := 0
Local nPos          := 0
Local nValHE        := 0

DEFAULT dPerIni     := dDataBase
DEFAULT dPerFim     := dDataBase

If _oPS1 == Nil
    _oPS1 := FWPreparedStatement():New()	 

    cQuery := "SELECT PC_FILIAL,PC_MAT,PC_DATA,PC_PD,PC_QUANTC,PC_PDI,PC_QUANTI FROM " + RetSqlName("SPC") + " SPC "
    cQuery += "INNER JOIN " + RetSqlName("SP9") + " SP9 ON " + FWJoinFilial( "SPC", "SP9" ) + " AND (SPC.PC_PD = SP9.P9_CODIGO OR SPC.PC_PDI = SP9.P9_CODIGO) AND SP9.P9_CLASEV = '01' AND SP9.D_E_L_E_T_ = ' ' "
    cQuery += "WHERE "
    cQuery += "SPC.PC_FILIAL = ? AND " 
    cQuery += "SPC.PC_MAT = ? AND "    
    cQuery += "SPC.PC_DATA >= ? AND "    
    cQuery += "SPC.PC_DATA <= ? AND "       
    cQuery += "SPC.D_E_L_E_T_ = ' ' "     
    cQuery += "UNION "     
    cQuery += "SELECT PH_FILIAL,PH_MAT,PH_DATA,PH_PD,PH_QUANTC,PH_PDI,PH_QUANTI FROM " + RetSqlName("SPH") + " SPH "
    cQuery += "INNER JOIN " + RetSqlName("SP9") + " SP9 ON " + FWJoinFilial( "SPH", "SP9" ) + " AND (SPH.PH_PD = SP9.P9_CODIGO OR SPH.PH_PDI = SP9.P9_CODIGO) AND SP9.P9_CLASEV = '01' AND SP9.D_E_L_E_T_ = ' ' "
    cQuery += "WHERE "
    cQuery += "SPH.PH_FILIAL = ? AND " 
    cQuery += "SPH.PH_MAT = ? AND "    
    cQuery += "SPH.PH_DATA >= ? AND "    
    cQuery += "SPH.PH_DATA <= ? AND "       
    cQuery += "SPH.D_E_L_E_T_ = ' ' "     
    cQuery += "ORDER BY 1,2,3"  
    cQuery := ChangeQuery(cQuery)    
    _oPS1:SetQuery(cQuery)
EndIf

_oPS1:SetString( 1, SRA->RA_FILIAL )
_oPS1:SetString( 2, SRA->RA_MAT)
_oPS1:SetString( 3, dToS(dPerIni) )
_oPS1:SetString( 4, dToS(dPerFim) )
_oPS1:SetString( 5, SRA->RA_FILIAL )
_oPS1:SetString( 6, SRA->RA_MAT)
_oPS1:SetString( 7, dToS(dPerIni) )
_oPS1:SetString( 8, dToS(dPerFim) )

cQuery := _oPS1:getFixQuery()

dbUseArea( .T., "TOPCONN", TcGenQry( Nil, Nil, cQuery), cAliasQry ) 

While (cAliasQry)->( !EoF() )
    nValHE := Iif( (cAliasQry)->PC_QUANTI > 0, (cAliasQry)->PC_QUANTI, (cAliasQry)->PC_QUANTC )
    If ( nPos := aScan( aDiasHe, { |x| x[1] == sToD( (cAliasQry)->PC_DATA ) } ) ) == 0
        aAdd( aDiasHe, { sToD( (cAliasQry)->PC_DATA ), nValHE } )
    Else
        aDiasHe[nPos, 2] := SomaHoras( aDiasHe[nPos, 2], nValHE )
    EndIf
    (cAliasQry)->( dbSkip() )
End

For nCont := 1 To Len(aDiasHe)
    aDiasHe[nCont, 2] := fConvHr( aDiasHe[nCont, 2], "D" )
Next nCont

(cAliasQry)->( dbCloseArea() )

Return aDiasHe

/*{Protheus.doc} fS151SM7
Verifica a configuração da tabela S151 para o tipo de benefício da SM7
benefícios (VA, VR e VT) conforme configuração da tabela S151
@author Allyson Luiz Mesashi
@since 20/07/2023
*/
Static Function fS151SM7( aTabS151, cTipoBen, cCodBen )

Local aAuxConfig    := {}
Local aConfig       := {}
Local cCodCCT       := fDesc("RCE", SRA->RA_SINDICA, "RCE_CCT", NIL, SRA->RA_FILIAL)
Local nCont         := 0

DEFAULT aTabS151    := {}
DEFAULT cTipoBen    := ""
DEFAULT cCodBen     := ""

For nCont := 1 To Len(aTabS151)
    If aTabS151[nCont, 7] == cTipoBen
        aAdd( aAuxConfig, aClone(aTabS151[nCont]) )
    EndIf
Next nCont

For nCont := 1 To Len(aAuxConfig)
    If aAuxConfig[nCont, 2] == SRA->RA_FILIAL .And. aAuxConfig[nCont, 5] == cCodCCT .And. aAuxConfig[nCont, 6] == SRA->RA_SINDICA .And. aAuxConfig[nCont, 8] == cCodBen
        aAdd( aConfig, aClone(aAuxConfig[nCont]) )
    EndIf
Next nCont

If Empty(aConfig)
    For nCont := 1 To Len(aAuxConfig)
        If aAuxConfig[nCont, 2] == SRA->RA_FILIAL .And. aAuxConfig[nCont, 5] == cCodCCT .And. Empty(aAuxConfig[nCont, 6]) .And. aAuxConfig[nCont, 8] == cCodBen
            aAdd( aConfig, aClone(aAuxConfig[nCont]) )
        EndIf
    Next nCont
EndIf

If Empty(aConfig)
    For nCont := 1 To Len(aAuxConfig)
        If aAuxConfig[nCont, 2] == SRA->RA_FILIAL .And. Empty(aAuxConfig[nCont, 5]) .And. Empty(aAuxConfig[nCont, 6]) .And. aAuxConfig[nCont, 8] == cCodBen
            aAdd( aConfig, aClone(aAuxConfig[nCont]) )
        EndIf
    Next nCont
EndIf

If Empty(aConfig)
    For nCont := 1 To Len(aAuxConfig)
        If Empty(aAuxConfig[nCont, 2]) .And. Empty(aAuxConfig[nCont, 5]) .And. Empty(aAuxConfig[nCont, 6]) .And. aAuxConfig[nCont, 8] == cCodBen
            aAdd( aConfig, aClone(aAuxConfig[nCont]) )
        EndIf
    Next nCont
EndIf

If Empty(aConfig)
    For nCont := 1 To Len(aAuxConfig)
        If Empty(aAuxConfig[nCont, 2]) .And. Empty(aAuxConfig[nCont, 5]) .And. aAuxConfig[nCont, 6] == SRA->RA_SINDICA .And. aAuxConfig[nCont, 8] == cCodBen
            aAdd( aConfig, aClone(aAuxConfig[nCont]) )
        EndIf
    Next nCont
EndIf

If Empty(aConfig)
    For nCont := 1 To Len(aAuxConfig)
        If Empty(aAuxConfig[nCont, 2]) .And. aAuxConfig[nCont, 5] == cCodCCT .And. Empty(aAuxConfig[nCont, 6]) .And. aAuxConfig[nCont, 8] == cCodBen
            aAdd( aConfig, aClone(aAuxConfig[nCont]) )
        EndIf
    Next nCont
EndIf

If Empty(aConfig)
    For nCont := 1 To Len(aAuxConfig)
        If Empty(aAuxConfig[nCont, 2]) .And. aAuxConfig[nCont, 5] == cCodCCT .And. aAuxConfig[nCont, 6] == SRA->RA_SINDICA .And. aAuxConfig[nCont, 8] == cCodBen
            aAdd( aConfig, aClone(aAuxConfig[nCont]) )
        EndIf
    Next nCont
EndIf

If Empty(aConfig)
    For nCont := 1 To Len(aAuxConfig)
        If aAuxConfig[nCont, 2] == SRA->RA_FILIAL .And. aAuxConfig[nCont, 5] == cCodCCT .And. aAuxConfig[nCont, 6] == SRA->RA_SINDICA .And. Empty(aAuxConfig[nCont, 8])
            aAdd( aConfig, aClone(aAuxConfig[nCont]) )
        EndIf
    Next nCont
EndIf

If Empty(aConfig)
    For nCont := 1 To Len(aAuxConfig)
        If aAuxConfig[nCont, 2] == SRA->RA_FILIAL .And. aAuxConfig[nCont, 5] == cCodCCT .And. Empty(aAuxConfig[nCont, 6]) .And. Empty(aAuxConfig[nCont, 8])
            aAdd( aConfig, aClone(aAuxConfig[nCont]) )
        EndIf
    Next nCont
EndIf

If Empty(aConfig)
    For nCont := 1 To Len(aAuxConfig)
        If aAuxConfig[nCont, 2] == SRA->RA_FILIAL .And. Empty(aAuxConfig[nCont, 5]) .And. Empty(aAuxConfig[nCont, 6]) .And. Empty(aAuxConfig[nCont, 8])
            aAdd( aConfig, aClone(aAuxConfig[nCont]) )
        EndIf
    Next nCont
EndIf

If Empty(aConfig)
    For nCont := 1 To Len(aAuxConfig)
        If Empty(aAuxConfig[nCont, 2]) .And. Empty(aAuxConfig[nCont, 5]) .And. aAuxConfig[nCont, 6] == SRA->RA_SINDICA .And. Empty(aAuxConfig[nCont, 8])
            aAdd( aConfig, aClone(aAuxConfig[nCont]) )
        EndIf
    Next nCont
EndIf

If Empty(aConfig)
    For nCont := 1 To Len(aAuxConfig)
        If Empty(aAuxConfig[nCont, 2]) .And. aAuxConfig[nCont, 5] == cCodCCT .And. Empty(aAuxConfig[nCont, 6]) .And. Empty(aAuxConfig[nCont, 8])
            aAdd( aConfig, aClone(aAuxConfig[nCont]) )
        EndIf
    Next nCont
EndIf

If Empty(aConfig)
    For nCont := 1 To Len(aAuxConfig)
        If Empty(aAuxConfig[nCont, 2]) .And. aAuxConfig[nCont, 5] == cCodCCT .And. aAuxConfig[nCont, 6] == SRA->RA_SINDICA .And. Empty(aAuxConfig[nCont, 8])
            aAdd( aConfig, aClone(aAuxConfig[nCont]) )
        EndIf
    Next nCont
EndIf

If Empty(aConfig)
    For nCont := 1 To Len(aAuxConfig)
        If Empty(aAuxConfig[nCont, 2]) .And. Empty(aAuxConfig[nCont, 5]) .And. Empty(aAuxConfig[nCont, 6]) .And. Empty(aAuxConfig[nCont, 8])
            aAdd( aConfig, aClone(aAuxConfig[nCont]) )
        EndIf
    Next nCont
EndIf

Return aConfig

/*{Protheus.doc} fVldS151
Verifica se o dia possui a quantidade mínima de horas extras necessárias para o cálculo do complemento de
benefícios (VA, VR e VT) conforme configuração da tabela S151
@author Allyson Luiz Mesashi
@since 20/07/2023
*/
Static Function fVldS151( aCfgS151, cTipoBen, cCodBen, dData, cTpDia )

Local nPosHE        := 0
Local nPosS151      := 0
Local lRet          := .F.

DEFAULT aCfgS151    := {}
DEFAULT cTipoBen    := ""
DEFAULT cCodBen     := ""
DEFAULT dData       := cToD("//")
DEFAULT cTpDia      := ""

If ( nPosHE := aScan( aDiasS151, { |x| x[1] == dData } ) ) > 0 .And. ( nPosS151 := aScan( aCfgS151, { |x| x[9] == cTpDia } ) ) > 0 .And. aDiasS151[nPosHe, 2] >= aCfgS151[nPosS151, 10]
    lRet := .T.
EndIf

Return lRet

/*{Protheus.doc} GpVldFal
Verifica se funcionário perdeu o direito ao benefício devido a faltas
benefícios (VA, VR e VT) conforme configuração da tabela S151
@author Allyson Luiz Mesashi
@since 20/07/2023
*/
Static Function GpVldFal(cCodBenef)
Local aArea 	:= GetArea()
Local lRet 		:= .F.
Local cCodCCT   := fDesc("RCE", SRA->RA_SINDICA, "RCE_CCT", NIL, SRA->RA_FILIAL)
Local nX        := 0
Local nY        := 0

Static aTab152 := {}

If Empty(aTab152)
	fCarrTab( @aTab152,"S152", Nil,.T.)
EndIf

If !Empty(aTab152)
	Begin Sequence 

		For nY := 1 to 5
			For nX := 1 to Len(aTab152)
				Do Case
					Case nY == 1 //Chave completa
						If aTab152[nX,2] + aTab152[nX,3] + aTab152[nX,5] + aTab152[nX,6] == SRA->RA_FILIAL + cPeriodo + cCodCCT + cCodBenef
							lRet := nFaltas > aTab152[nX,7]
							Break
						EndIf
					Case nY == 2
						If aTab152[nX,2] + aTab152[nX,3] + aTab152[nX,5] == SRA->RA_FILIAL + cPeriodo + cCodCCT .and. Empty(aTab152[nX,6])
							lRet := nFaltas > aTab152[nX,7]
							Break
						EndIf
					Case nY == 3
						If aTab152[nX,2] + aTab152[nX,3] == SRA->RA_FILIAL + cPeriodo .and. Empty(aTab152[nX,5]) .and. Empty(aTab152[nX,6])
							lRet := nFaltas > aTab152[nX,7]
							Break
						EndIf
					Case nY == 4
						If aTab152[nX,2] == SRA->RA_FILIAL .and. Empty(aTab152[nX,3]) .and. Empty(aTab152[nX,5]) .and. Empty(aTab152[nX,6])
							lRet := nFaltas > aTab152[nX,7]
							Break
						EndIf
					Otherwise 
						//Se algum dos parametros for igual e os demais vazios
						If ( aTab152[nX,2] == SRA->RA_FILIAL .or. Empty(aTab152[nX,2]) ) .and.;
						   ( aTab152[nX,3] == cPeriodo .or. Empty(aTab152[nX,3]) ) .and.;
						   ( aTab152[nX,5] == cCodCCT .or. Empty(aTab152[nX,5]) ) .and.;
						   ( aTab152[nX,6] == cCodBenef .or. Empty(aTab152[nX,6]) )
							lRet := nFaltas > aTab152[nX,7]
							Break
						EndIf
				EndCase
				
			Next nX
		Next nY

	End Sequence 
Else
	lRet := nFaltas >= P_BENMAXFA 
EndIf

RestArea(aArea)

Return lRet

/*{Protheus.doc} fGravaRU1
Efetua a gravação analítica dos dias considerados para o cálculo na tabela RU1
@author Allyson Luiz Mesashi
@since 18/01/2024
*/
Static Function fGravaRU1( aRU1, lRecalc )

Local nCont     := 0
Local cValAux   := ""

DEFAULT lRecalc   := .F.
DEFAULT lTamRU1VL := TamSX3("RU1_VALDIA")[1] == 6

For nCont := 1 To Len(aRU1)
    If aRU1[nCont, 7] > 0
		If lTamRU1VL .and. aRU1[nCont, 7] * Iif( !lRecalc, SR0->R0_VLRVALE, aRU1[nCont, 10] ) >= 1000
			cValAux := cValToChar(aRU1[nCont, 7] * Iif( !lRecalc, SR0->R0_VLRVALE, aRU1[nCont, 10] ))
			CMSGLOG := "Tamanho do campo RU1_VALDIA é menor que o valor diário do beneficio (" + cValAux + "). Altere o tamanho do campo e/ou verifique a documentação em: " + CRLF
			CMSGLOG += "https://tdn.totvs.com/pages/viewpage.action?pageId=845770428"
			S_MSGLOG()
			FINALCALC()
			Return()
		EndIf
        lNovo := RU1->( !dbSeek( SR0->R0_FILIAL+SR0->R0_MAT+SR0->R0_TPVALE+SR0->R0_CODIGO+SR0->R0_NROPED+dToS(aRU1[nCont, 1]) ) )
        If RU1->( Reclock( "RU1", lNovo) )
            RU1->RU1_FILIAL	    := SR0->R0_FILIAL
            RU1->RU1_MAT	    := SR0->R0_MAT
            RU1->RU1_TPVALE	    := SR0->R0_TPVALE
            RU1->RU1_TPBEN	    := SR0->R0_TPBEN
            RU1->RU1_CODIGO	    := Iif( !lRecalc, SR0->R0_CODIGO, aRU1[nCont, 9] )
            RU1->RU1_CC		    := SR0->R0_CC
            RU1->RU1_DATA	    := aRU1[nCont, 1]
            RU1->RU1_TPDIA	    := aRU1[nCont, 6]
            RU1->RU1_VALDIA	    := aRU1[nCont, 7] * Iif( !lRecalc, SR0->R0_VLRVALE, aRU1[nCont, 10] )
            RU1->RU1_QTDDIA	    := aRU1[nCont, 7]
            RU1->RU1_PERIOD     := SR0->R0_PERIOD 
            RU1->RU1_NROPGT	    := SR0->R0_NROPGT
            RU1->RU1_ROTEIR	    := SR0->R0_ROTEIR
            RU1->RU1_PEDIDO	    := SR0->R0_PEDIDO
            RU1->RU1_NROPED	    := SR0->R0_NROPED
            RU1->RU1_CODCCT 	:= SR0->R0_CODCCT

            If lTemRecalc
                RU1->RU1_RECALC := Iif( lRecalc, "1", "2" )
            EndIf

            RU1->( MsUnLock() )
        EndIf
    EndIf
Next nCont

Return

/*{Protheus.doc} fLoadS153
Carrega dados da tabela S153
@author Leandro Drumond
@since 04/12/2024
@return Array com a seguinte extrutura:
[1] - Eventos de falta
[2] - Tipos de ausência
[3] - Dias máximo de Ausências/Faltas
[4] - Códigos de abono
[5] - Dias máximo de Abono 
[6] - Se paga saldo ou total

Parâmetros lFaltas e lAfast são atualizados indicando se existe configuração para faltas e afastamentos, se passados por referência.

*/
Function fLoadS153(lFaltas, lAfast)

Local aRet 		:= {}
Local aEvAux 	:= {}
Local aFalAux   := {}
Local aAfaAux   := {}
Local aS153Aux  := {}
Local aCodBenef := {}
Local aBenef153 := {}
Local cFilFunc  := SRA->RA_FILIAL 
Local cCodCCT   := If(Empty(SRA->RA_SINDICA),"",fBuscaCCT(SRA->RA_SINDICA))
Local cTipo		:= If(cTipoRot == "8", "0", If(cTipoRot == "D", "1", If(cTipoRot == "E", "2", "I")))
Local nX 		:= 0
Local nY 		:= 0
Local nMax 		:= 0
Local nCfgFal   := 0 
Local nCfgAfa   := 0
Local nKeyAux   := 0 //3 - Possui filial e CCT informada, 2 - Possui apenas CCT informada, 1 - Possui apenas filial informada, 0 - Não possui nem filial nem CCT (genérico)
Local cFilAux   := xFilial("RCC")
Local lAfaCompl	:= .F.
Local uX 
Local bChkBen   := {|aArg| aScan(aArg, {|x| uX := x, aScan(aCodBenef, {|y| y == uX }) > 0}) > 0}
Local lTemCdBen := .F.
Local lChkBen   := .F.

Static aTabS153
Static _cFilRCC

DEFAULT lFaltas 	:= .T.
DEFAULT lAfast  	:= .T. 
DEFAULT __lMemCalc	:= cPaisLoc == "BRA" .And. fMemCalc() // Memória de Cálculo

If(__lMemCalc, fAddMemLog("Parâmetro P_NVAFABEN ativo. Faltas e afastamentos serão descontados com base na configuração definida na tabela S153" ,1,2), Nil)

If aTabS153 == Nil .or. _cFilRCC <> cFilAux 
	aTabS153  := {}
	_cFilRCC := cFilAux
	fCarrTab( @aTabS153, "S153",,.T.,cPeriodo )
	aSort( aTabS153 ,,, { |x,y| x[2] + x[5] > y[2] + y[5] } ) //Ordena por filial e CCT (maior na frente)
EndIf

If Len(aTabS153) > 0 
	fGetCodBen(cTipo, aCodBenef)
	For nX := 1 To Len(aTabS153)
		aBenef153 := StrTokArr(AllTrim(aTabS153[nX, 14]), "/")
		lTemCdBen := Eval(bChkBen, aBenef153)	
		If lTemCdBen
			Exit
		EndIf
	Next nX
	aBenef153 := {}
EndIf

For nX := 1 to Len(aTabS153)
	
	aAdd(aS153Aux, Array(7))
	aS153Aux[nX,1] := ""
	aS153Aux[nX,2] := ""
	
	If Len(aTabS153[nX]) > 13
		aBenef153 := StrTokArr(AllTrim(aTabS153[nX, 14]), "/")
		lChkBen   := Eval(bChkBen, aBenef153)
		If lTemCdBen .And. !lChkBen
			Loop
		EndIf
	EndIf 

	If ( Empty(aTabS153[nX,2]) .or. aTabS153[nX,2] == cFilFunc ) .and. ( Empty(aTabS153[nX,5]) .or. aTabS153[nX,5] == cCodCCT) .and. cRot $ aTabS153[nX,11] .And. (Len(aBenef153) == 0 .Or. lChkBen)
		If !Empty(aTabS153[nX,2]) .or. !Empty(aTabS153[nX,5])
			nKeyAux := If(!Empty(aTabS153[nX,2]) .and. !Empty(aTabS153[nX,5]), 3, If(!Empty(aTabS153[nX,5]), 2, 1) )
		Else 
			nKeyAux := 0
		EndIf
	
		If lFaltas .and. !Empty(aTabS153[nX,6])
			aEvAux := StrTokArr(AllTrim(aTabS153[nX,6]), "/")
			For nY := 1 to Len(aEvAux)
				If ( nPos := aScan(aFalAux, {|x| x[1] == aEvAux[nY] }) ) > 0
					If aFalAux[nPos,2] > nKeyAux 
						aEvAux[nY] := ""
					Else
						aS153Aux[aFalAux[nPos,3],1] := StrTran(aS153Aux[aFalAux[nPos,3],1], aEvAux[nY]+"/", "")
					EndIf
				EndIf
			Next nY
			aEval(aEvAux, {|x| If(!Empty(x), aAdd(aFalAux,{x, nKeyAux, nX}),Nil)})
		EndIf

		If lAfast .and. !Empty(aTabS153[nX,7]) .and. !lAfaCompl
			If AllTrim(aTabS153[nX,7]) == "*"
				lAfaCompl := nKeyAux == 3
				If lAfaCompl .or. aScan(aAfaAux, { |x| x[2] < nKeyAux} ) > 0 //Chave completa
					aEval(aS153Aux, {|x| x[2] := ""}) //Esvazia os eventos de afastamento genéricos pois deve ser utilizado o evento com chave maior
				EndIf
				aEvAux := {"*"}
			Else
				aEvAux := StrTokArr(AllTrim(aTabS153[nX,7]), "/")
				For nY := 1 to Len(aEvAux)
					If ( nPos := aScan(aAfaAux, {|x| x[1] == aEvAux[nY] .or. x[1] == "*"}) ) > 0
						If aAfaAux[nPos,2] > nKeyAux 
							aEvAux[nY] := ""
						ElseIf aS153Aux[aAfaAux[nPos,3],2] <> "*"
							aS153Aux[aAfaAux[nPos,3],2] := If(Left(aS153Aux[aAfaAux[nPos,3],2],1) == "*" .or. Empty(aS153Aux[aAfaAux[nPos,3],2]), "", StrTran(aS153Aux[aAfaAux[nPos,3],2], aEvAux[nY]+"/", ""))
						EndIf
					EndIf
				Next nY
			EndIf
			aEval(aEvAux, {|x| If(!Empty(x), aAdd(aAfaAux,{x, nKeyAux, nX}),Nil)})
		EndIf

		aS153Aux[nX,3] := aTabS153[nX,8]
		aS153Aux[nX,4] := aTabS153[nX,9]
		aS153Aux[nX,5] := aTabS153[nX,10]
		aS153Aux[nX,6] := aTabS153[nX,12]
		aS153Aux[nX,7] := If(Len(aTabS153[nX]) > 12, aTabS153[nX,13], "")
		
		If ( lFaltas .and. aScan(aFalAux, {|x| x[3] == nX}) > 0 ) .or. ( lAfast .and. aScan(aAfaAux, {|x| x[3] == nX }) > 0 )
			nMax := Max(Len(aAfaAux), Len(aFalAux))

			For nY := 1 to nMax 
				If lFaltas .and. Len(aFalAux) >= nY .and. aFalAux[nY,3] == nX
					aS153Aux[nX,1] += aFalAux[nY,1] + "/" 
				EndIf
				If lAfast .and. Len(aAfaAux) >= nY .and. aAfaAux[nY,3] == nX
					aS153Aux[nX,2] += aAfaAux[nY,1] + If(aAfaAux[nY,1] != "*", "/", "") 
				EndIf
			Next nY
		EndIf
	EndIf
Next nX

For nX := 1 to Len(aS153Aux)
	If !Empty(aS153Aux[nX,1]) .or. !Empty(aS153Aux[nX,2]) //Retorna apenas se existir faltas ou afastamentos definidos 
		nCfgFal += If(!Empty(aS153Aux[nX,1]),1,0)
		nCfgAfa += If(!Empty(aS153Aux[nX,2]),1,0)
		aAdd(aRet, aS153Aux[nX])
		If(__lMemCalc .and. Len(aRet) == 1, fAddMemLog("Configurações da S153:" ,1,2), Nil)
		If(__lMemCalc .and. Len(aRet) > 1, fAddMemLog(" "), Nil)
		If(__lMemCalc, fAddMemLog("Eventos de Falta = " + aRet[Len(aRet),1],1,2), Nil)
		If(__lMemCalc, fAddMemLog("Tipos de Ausências = " + aRet[Len(aRet),2],1,2), Nil)
		If(__lMemCalc, fAddMemLog("Máx. Ocorrências = " + cValToChar(aRet[Len(aRet),3]),1,2), Nil)
		If(__lMemCalc, fAddMemLog("Eventos de Abono = " + aRet[Len(aRet),4],1,2), Nil)
		If(__lMemCalc, fAddMemLog("Máx. Abonos = " + cValToChar(aRet[Len(aRet),5]),1,2), Nil)
		If(__lMemCalc, fAddMemLog("Desconta Saldo/Total = " + aRet[Len(aRet),6],1,2), Nil)		
	EndIf
Next nX

lFaltas := nCfgFal > 0 
lAfast  := nCfgAfa > 0

Return aRet

/*{Protheus.doc} fCDiasS153
Valida e desconta faltas e afastamentos de acordo com configuração da tabela S153
@author Leandro Drumond
@since 05/12/2024
*/
Function fCDiasS153(aDiasMes, aTabS153, lFaltas, lAfast, dDtIni, dDtFim)
Local aAfast 		:= {}
Local aTabAus       := {}
Local aEveFalta     := {}
Local aFaltAux 		:= {}
Local aDatAus 		:= {}
Local cEveFalta 	:= ""
Local cSupAbono 	:= ""
Local cAliasAux 	:= ""
Local cQrySt 		:= ""
Local dPonIni       := CtoD("")
Local dPonFim 		:= CtoD("")
Local dPonAuxI      := CtoD("")
Local dPonAuxF      := CtoD("")
Local nDescAus      := 0
Local nX 			:= 0 
Local nY 			:= 0
Local nJ 			:= 0
Local nMesAnt		:= P_BENBUSFA

Static oStQryPON

DEFAULT dDtIni     	:= aPeriodo[nPosSem,3] //Data inicial do periodo de calculo
DEFAULT dDtFim 	 	:= aPeriodo[nPosSem,4] //Data final do periodo de calculo
DEFAULT aTabS153 	:= {}
DEFAULT lFaltas  	:= .T. 
DEFAULT lAfast   	:= .T.

For nX := 1 to Len(aTabS153)
	aAdd(aTabAus, Array(8))
	aAdd(aFaltAux, Array(7))
	aAdd(aDatAus,{})
	aFaltAux[nX] := {0,0,0,0,0,0,0}
	cEveFalta += aTabS153[nX,1]
	cSupAbono += aTabS153[nX,7]
	For nY := 1 to Len(aTabS153[nX])
		aTabAus[nX][nY] := aTabS153[nX][nY]
	Next nY
	aTabAus[nX,7] := 0 //Total de ocorrências
	aTabAus[nX,8] := 0 //Total de abonos
Next nX

If lFaltas
	
	aEveFalta := StrTokArr(AllTrim(cEveFalta), "/")

	cAliasAux := GetNextAlias()

	// Busca o período atual do ponto
	GetPerAtu(@dPonIni, @dPonFim )

	// Carrega o período de apontamento considerando o conteúdo do mnemônico P_BenBusFa
	PerAponta(@dPonAuxI, @dPonAuxF, MonthSub(dPonIni, nMesAnt),,,,,,,.T.)

	If(__lMemCalc, fAddMemLog("Período atual do ponto : " + dtoc(dPonIni) + " a " + dtoc(dPonFim) ,1,2), Nil)
	If(__lMemCalc, fAddMemLog("Período de busca de desconto : " + dtoc(dPonAuxI) + " a " + dtoc(dPonAuxF) ,1,2), Nil )

	If oStQryPON == Nil
		oStQryPON := FWPreparedStatement():New()
		cQrySt := "SELECT ? , ? , ? , ? "
		cQrySt += "FROM ? "
		cQrySt += "WHERE ? = ? AND "
		cQrySt += 		"? = ? AND ( "
		cQrySt += 		"? IN (?) OR "
		cQrySt += 		"? IN (?) ) AND "
		cQrySt += 		"? BETWEEN ? AND ? AND "
		cQrySt += 		"D_E_L_E_T_ = ' '"
		cQrySt := ChangeQuery(cQrySt)
		oStQryPON:SetQuery(cQrySt)
	EndIf

	oStQryPON:SetNumeric(1, If(dPonAuxI >= dPonIni,"PC_PD EVENTO","PH_PD EVENTO"))
	oStQryPON:SetNumeric(2, If(dPonAuxI >= dPonIni,"PC_PDI EVINFO","PH_PDI EVINFO"))
	oStQryPON:SetNumeric(3, If(dPonAuxI >= dPonIni,"PC_ABONO ABONO","PH_ABONO ABONO"))
	oStQryPON:SetNumeric(4, If(dPonAuxI >= dPonIni,"PC_DATA DATAFAL","PH_DATA DATAFAL"))
	oStQryPON:SetNumeric(5, If(dPonAuxI >= dPonIni,RetSqlName('SPC'),RetSqlName('SPH')))
	oStQryPON:SetNumeric(6, If(dPonAuxI >= dPonIni,"PC_FILIAL","PH_FILIAL"))
	oStQryPON:SetString(7, SRA->RA_FILIAL)
	oStQryPON:SetNumeric(8, If(dPonAuxI >= dPonIni,"PC_MAT","PH_MAT"))
	oStQryPON:SetString(9, SRA->RA_MAT)
	oStQryPON:SetNumeric(10, If(dPonAuxI >= dPonIni,"PC_PD","PH_PD"))
	oStQryPON:SetIn(11, aEveFalta) 
	oStQryPON:SetNumeric(12, If(dPonAuxI >= dPonIni,"PC_PDI","PH_PDI"))
	oStQryPON:SetIn(13, aEveFalta)
	oStQryPON:SetNumeric(14, If(dPonAuxI >= dPonIni,"PC_DATA","PH_DATA"))
	oStQryPON:SetDate(15, dPonAuxI)
	oStQryPON:SetDate(16, dPonAuxF)
	
	cQrySt := oStQryPON:getFixQuery()

	dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQrySt),cAliasAux,.T.,.T.)

	While (cAliasAux)->( !EoF() )
		If ( nPos := aScan(aTabAus, {|x| If(Empty((cAliasAux)->EVINFO), (cAliasAux)->EVENTO $ x[1], (cAliasAux)->EVINFO $ x[1])}) ) > 0
			If !Empty((cAliasAux)->ABONO) .and. !Empty(cSupAbono) .and. (cAliasAux)->ABONO $ cSupAbono
				//Abono empresa nunca desconta
				(cAliasAux)->(DbSkip())
				Loop 
			EndIf

			aTabAus[nPos][7] += 1
			If !Empty((cAliasAux)->ABONO) .and. (cAliasAux)->ABONO $ aTabAus[nPos][4]
				aTabAus[nPos][8] += 1
			EndIf
			If Empty((cAliasAux)->ABONO) .or. aTabAus[nPos][8] > aTabAus[nPos][5] .or. aTabAus[nPos][6] == "T"
				aFaltAux[nPos][Dow(StoD((cAliasAux)->DATAFAL))] += 1 
			EndIf
		EndIf
		(cAliasAux)->(DbSkip())
	EndDo

	(cAliasAux)->(dbCloseArea())

EndIf 

If lAfast
	fRetAfas(dDtIni, dDtFim , , , , , @aAfast,,,,,,,,,.F.)
	For nX := 1 to Len(aAfast)
		//Primeiro verifica as ausências especificas, depois as genéricas (*)
		If ( nPos := aScan(aTabAus, {|x| aAfast[nX,13] $ x[2] }) ) > 0 .or. ( nPos := aScan(aTabAus, {|x| x[2] == "*" })) > 0 
			aTabAus[nPos,7] += aAfast[nX,11]
			aAdd(aDatAus[nPos], { Max(aAfast[nX,3],dDtIni), Min(aAfast[nX,4],dDtFim), aAfast[nX,5] })
		EndIf
	Next nX 	
EndIf

aFaltas := {0,0,0,0,0,0,0}

If Len(aTabAus) > 0 .and. ( Empty(aDiasMes) .or. cTipoRot == "I")
	aDiasMes := {}
	fCarDiasMes(@aDiasMes)
EndIf

For nX := 1 to Len(aTabAus)
	If aTabAus[nX,7] - Min(aTabAus[nX,5],aTabAus[nX,8]) > aTabAus[nX,3] //Se faltas + afastamentos - Abonos (limitado ao máximo) for maior que a quantidade máxima de ocorrências, DESCONTA.
		If aTabAus[nX,6] == "T"
			nDescAus := 0 
		Else
			nDescAus := aTabAus[nX,3] //Dias Máximo de ausências permitido
			nDescAus -= Min(aTabAus[nX,5],aTabAus[nX,8])
			nDescAux := Max(nDescAus,0)
		EndIf

		For nY := 1 To Len(aDatAus[nX])
			For nJ := 1 To Len(aDiasMes)
				If aDiasMes[nJ][1] >= aDatAus[nX][nY][1] .And. (aDiasMes[nJ][1] <= aDatAus[nX][nY][2] .Or. Empty(aDatAus[nX][nY][2]))
					If nDescAus > 0
						nDescAus-- //Irá marcar o dia como afastado apenas do saldo
						Loop 
					EndIf
					aDiasMes[nJ][4] := .F.
					If aDatAus[nX,nY,3] == "F"
						aDiasMes[nJ,5] := "FER"
						nFerVen++
					Else
						aDiasMes[nJ,5] := "AFA"
						nDiasAfas++
					EndIf
				EndIf
			Next nJ
		Next nY
		For nY := 1 to Len(aFaltAux[nX])
			If nDescAus > 0 .and. aFaltAux[nX][nY] > 0
				If aFaltAux[nX][nY] <= nDescAus
					nDescAus -= aFaltAux[nX][nY]
					aFaltAux[nX][nY] := 0
				Else 
					aFaltAux[nX][nY] -= nDescAus 
					nDescAus := 0 
				EndIf
			EndIf
			nFaltas += aFaltAux[nX][nY]
			aFaltas[nY] += aFaltAux[nX][nY]
		Next nY
	EndIf
Next nX

Return Nil

/*{Protheus.doc} fGetCodBen
Busca os códigos de benefícios por funcionário
@author Bruno Costa
@since 15/05/2025
*/
Static Function fGetCodBen(cTipo, aCodBenef)
Local cAlias := GetNextAlias()
Local cQrySt := ""

Static oStQryCodBen

If oStQryCodBen == Nil
	oStQryCodBen := FWPreparedStatement():New()
	cQrySt := "SELECT ? "
	cQrySt += "FROM ? "
	cQrySt += "WHERE ? = ? AND "
	cQrySt += 		"? = ? AND "
	cQrySt += 		"? ? ? AND "
	cQrySt += 		"D_E_L_E_T_ = ?"
	cQrySt := ChangeQuery(cQrySt)
	oStQryCodBen:SetQuery(cQrySt)
EndIf

oStQryCodBen:SetNumeric(1, If(cTipo == "I", "RI1_TABELA CODIGO", "M7_CODIGO CODIGO"))
oStQryCodBen:SetNumeric(2, If(cTipo == "I", RetSqlName('RI1'), RetSqlName('SM7')))
oStQryCodBen:SetNumeric(3, If(cTipo == "I", "RI1_FILIAL", "M7_FILIAL"))
oStQryCodBen:SetString(4, SRA->RA_FILIAL)
oStQryCodBen:SetNumeric(5, If(cTipo == "I", "RI1_MAT", "M7_MAT"))
oStQryCodBen:SetString(6, SRA->RA_MAT)
oStQryCodBen:SetNumeric(7, If(cTipo == "I", "RI1_TABELA", "M7_TPVALE"))
oStQryCodBen:SetNumeric(8, If(cTipo == "I", "<>", "="))
oStQryCodBen:SetString(9, If(cTipo == "I", " ", cTipo))
oStQryCodBen:SetString(10, " ")

cQrySt := oStQryCodBen:getFixQuery()

dbUseArea(.T., "TOPCONN", TcGenQry(,,cQrySt), cAlias, .T., .T.)

While (cAlias)->(!EoF())
	aAdd(aCodBenef, Alltrim((cAlias)->CODIGO))
	(cAlias)->(DbSkip())
EndDo

(cAlias)->(dbCloseArea())

Return
