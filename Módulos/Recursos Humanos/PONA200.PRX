#INCLUDE "PONA200.CH"
#INCLUDE "PROTHEUS.CH"
#INCLUDE "FWMVCDEF.CH"

Static lMesesBH 	:= NIL
Static oSPIQuery	:= NIL
Static lNewSPI		:= .F.
Static nRecSPI		:= 0

PUBLISH MODEL REST NAME PONA200

/*/{Protheus.doc} PONA200
Manutenção do Banco de Horas
@type function
@author Cícero Alves
@since 12/06/2024
/*/
Function PONA200()
	
	Local oBrowse := BrowseDef()
	
	// Valida se o usuário tem acesso
	If BloqPer()
		Return
	EndIf
	
	oBrowse:Activate()
	
Return

/*/{Protheus.doc} BrowseDef
Definição do Browse
@type function
@author Cícero Alves
@since 12/06/2024
@return oBrwSRA, Object, Instância da classe FWMBrowse
/*/
Static Function BrowseDef()
	
	Local oBrwSRA := FWMBrowse():New()
	Local cFiltraRh
	
	oBrwSRA:SetAlias("SRA")
	oBrwSRA:SetDescription(STR0011) // "Manutenção de Banco de Horas"
	oBrwSRA:DisableDetails()
	
	// Adiciona Legenda
	GpLegend(@oBrwSRA,.T.)
	
	// Filtro
	cFiltraRh := CHKRH( "PONA200", "SRA", "1" )
	oBrwSRA:SetFilterDefault(cFiltraRh)
	
	// Menu
	oBrwSRA:SetMenuDef("PONA200")
	
Return oBrwSRA

/*/{Protheus.doc} MenuDef
Opções do menu da rotina
@type static function
@author Cícero Alves
@since 12/06/2024
@return aRotina, Array, Opções de menu da rotina
/*/
Static Function MenuDef()
	
	Local aRotina := {}
	
	ADD OPTION aRotina TITLE STR0030 	ACTION 'VIEWDEF.PONA200' 	OPERATION MODEL_OPERATION_UPDATE 	ACCESS 0 // "Manutenção"
	ADD OPTION aRotina TITLE STR0005 	ACTION 'VIEWDEF.PONA200'	OPERATION MODEL_OPERATION_VIEW 		ACCESS 0 // "Visualizar"
	ADD OPTION aRotina TITLE STR0010 	ACTION 'VIEWDEF.PONA200' 	OPERATION MODEL_OPERATION_DELETE 	ACCESS 0 // "Excluir"
	ADD OPTION aRotina TITLE STR0031 	ACTION 'AtuMesesBH()' 		OPERATION MODEL_OPERATION_UPDATE	ACCESS 0 // "Atualizar Vencimento"
	ADD OPTION aRotina TITLE STR0004 	ACTION 'PesqBrw'			OPERATION 1 						ACCESS 0 // "Pesquisar"
	
Return aRotina

/*/{Protheus.doc} ViewDef
efinição da interface visual
@type static function
@author Cícero Alves
@since 12/06/2024
@return oView, object, Instância da classe FWFormView
/*/
Static Function ViewDef()
	
	Local oView 		:= FWFormView():New()
	Local oModel		:= FwLoadModel("PONA200")
	Local oStructSRA 	:= FWFormStruct(2, "SRA", {|cCampo| AllTrim(cCampo) + "|" $ "RA_MAT|RA_NOME|RA_ADMISSA|"})
	Local oStructSPI	:= FWFormStruct(2, "SPI", {|cCampo| !(AllTrim(cCampo) + "|" $ "PI_POSTO|PI_DEPTO|PI_CODFUNC|PI_PROCES|PI_PERIODO|PI_ROTEIR|PI_NUMPAG|PI_MESESBH|")})
	
	lMesesBH := If(lMesesBH == NIL, SPI->(ColumnPos("PI_MESESBH")) > 0, lMesesBH)
	
	oView:SetModel(oModel)
	
	oStructSRA:SetNoFolder()
	
	If lMesesBH
		// Adiciona o campo como virtual na estrutura da SRA
		// "Venc.BH" - "Meses Vencimento BH"
		oStructSRA:AddField("MESESBH", "04", STR0039, STR0040, {STR0032}, "N", "@E 99",,,,,,,,, .T.) // "Informe a quantidade de meses para vencimento dos lançamentos do banco de horas"
	EndIf
	
	If oStructSRA:HasField("RA_MAT")
		oStructSRA:SetProperty( 'RA_MAT', MVC_VIEW_ORDEM, '01')
		oStructSRA:SetProperty( 'RA_MAT', MVC_VIEW_CANCHANGE, .F.)
	EndIf
	
	If oStructSRA:HasField("RA_NOME")
		oStructSRA:SetProperty( 'RA_NOME', MVC_VIEW_ORDEM, '02')
		oStructSRA:SetProperty( 'RA_NOME', MVC_VIEW_CANCHANGE, .F.)
	EndIf
		
	If oStructSRA:HasField("RA_ADMISSA")
		oStructSRA:SetProperty( 'RA_ADMISSA', MVC_VIEW_ORDEM, '03')
		oStructSRA:SetProperty( 'RA_ADMISSA', MVC_VIEW_CANCHANGE, .F.)
	EndIf
	
	oView:AddField( "PONA200_SRA", oStructSRA )
	oView:AddGrid( "PONA200_SPI", oStructSPI )
	
	oView:createHorizontalBox("FORMFIELD", 10)
	oView:createHorizontalBox("GRID"     , 90)
	
	oView:SetOwnerView( "PONA200_SRA", "FORMFIELD")
	oView:SetOwnerView( "PONA200_SPI", "GRID")
	oView:EnableControlBar(.T.)
	oView:SetCloseOnOk({ || .T. })
	
Return oView

/*/{Protheus.doc} ModelDef
Definição do modelo de dados
@type static function
@author Cícero Alves
@since 12/06/2024
@return oModel, object, Instância da classe MPFormModel
/*/
Static Function ModelDef()
	
	Local oModel 		:= MPFormModel():New("PONA200",,, {|oModel| Pn200Grava(oModel)})
	Local oStructSRA 	:= FWFormStruct(1, "SRA", {|cCampo| AllTrim(cCampo) + "|" $ "RA_FILIAL|RA_MAT|RA_NOME|RA_ADMISSA|"})
	Local oStructSPI	:= FWFormStruct(1, "SPI", {|cCampo| !(AllTrim(cCampo) + "|" $ "PI_POSTO|PI_DEPTO|PI_CODFUNC|PI_PROCES|PI_PERIODO|PI_ROTEIR|PI_NUMPAG|PI_MESESBH|")})
	Local aAux			:= {}
	
	lMesesBH := If(lMesesBH == NIL, SPI->(ColumnPos("PI_MESESBH")) > 0, lMesesBH)
	
	oModel:SetDescription(STR0011) // "Manutenção Banco de Horas"
	
	If lMesesBH
		// Adiciona o campo como virtual na estrutura da SRA
		// "Venc.BH" - "Meses Vencimento BH"
		oStructSRA:AddField(STR0039, STR0040, "MESESBH", "N", 2, 0, FwBuildFeature( STRUCT_FEATURE_VALID, "Positivo()"),,, .F.,, .F.,, .T.)
	EndIf
	
	// Adiciona o gatilho para a descrição do evento
	aAux := FwStruTrigger("PI_PD", "PI_DESC", "SP9->P9_DESC", .T., "SP9", 1, "xFilial('SP9', SRA->RA_FILIAL) + M->PI_PD")
	oStructSPI:AddTrigger(aAux[1], aAux[2], aAux[3], aAux[4])
	
	// Os campos da SRA não devem ser alterados
	If oStructSRA:HasField("RA_MAT")
		oStructSRA:SetProperty('RA_MAT', MODEL_FIELD_WHEN, {||.F.})
	EndIf
	
	If oStructSRA:HasField("RA_NOME")
		oStructSRA:SetProperty('RA_NOME', MODEL_FIELD_WHEN, {||.F.})
	EndIf
	
	If oStructSRA:HasField("RA_ADMISSA")
		oStructSRA:SetProperty('RA_ADMISSA', MODEL_FIELD_WHEN, {||.F.})
	EndIf
	
	oModel:AddFields("PONA200_SRA",, oStructSRA)
	oModel:GetModel('PONA200_SRA'):SetOnlyQuery(.T.)
	
	oModel:AddGrid("PONA200_SPI", "PONA200_SRA", oStructSPI,, {|oGridModel| Pona200LOk(oGridModel)})
	
	If lMesesBH
		oModel:GetModel('PONA200_SPI'):SetLoadFilter({}, "PI_MESESBH = 0")
	EndIf
	
	oModel:GetModel('PONA200_SPI'):SetMaxLine(99999)
	
	oModel:GetModel('PONA200_SPI'):SetOptional(.T.)
	
	oModel:SetRelation("PONA200_SPI", {{"PI_FILIAL", "SRA->RA_FILIAL"}, {"PI_MAT", "SRA->RA_MAT"}}, SPI->(IndexKey(2)))
	
	oModel:SetActivate({|oModel| BhSaldo(oModel, .T.), InitMBH(oModel) })
	
Return oModel

/*/{Protheus.doc} BhSaldo
Calcula os saldos do Banco de Horas e atualiza o Grid
@type static function
@author Cícero Alves
@since 12/06/2024
@param oModel, object, instância da classe MPFormModel contendo as informações da SRA e da SPI
@param lTodos, logical, Determina se atualiza o saldo de todas as linhas ou apartir da linha atual
@return NIL, NIL
/*/
Static Function BhSaldo(oModel, lTodos)
	
	Local oModelSPI		:= oModel:GetModel("PONA200_SPI")
	Local nLines		:= oModelSPI:Length()
	Local nLinhaAtu		:= oModelSPI:GetLine()
	Local nI			:= 0
	Local nSaldoN 		:= 0.00
	Local nSaldoV		:= 0.00
	
	DEFAULT lTodos := .F.
	
	// Não é possível alterar o conteúdo dos campos no delete
	If oModel:GetOperation() == MODEL_OPERATION_DELETE
		Return .T.
	EndIf
	
	If !lTodos .And. nLinhaAtu > 1
		nLinhaAtu--
		While nLinhaAtu > 0
			oModelSPI:GoLine(nLinhaAtu)
			If oModelSPI:GetValue("PI_STATUS") != "B" .And. !oModelSPI:IsDeleted()
				
				nSaldoN	:= oModelSPI:GetValue("PI_SALDO")  // Saldo normal
				nSaldoV	:= oModelSPI:GetValue("PI_SALDOV") // Saldo valorizado
				nLinhaAtu++
				EXIT
			EndIf
			nLinhaAtu--
		EndDo
	EndIf
	
	For nI := nLinhaAtu To nLines
		
		oModelSPI:GoLine(nI)
		
		If oModelSPI:GetValue("PI_STATUS") != "B" .And. !oModelSPI:IsDeleted()
			If PosSP9(oModelSPI:GetValue("PI_PD"), SRA->RA_FILIAL, "P9_TIPOCOD", 1, .F.) $ "1*3" // Provento
				nSaldoN	:= __TimeSum(nSaldoN, oModelSPI:GetValue("PI_QUANT"))  // Saldo normal
				nSaldoV	:= __TimeSum(nSaldoV, oModelSPI:GetValue("PI_QUANTV")) // Saldo valorizado
			Else // Desconto
				nSaldoN	:= __TimeSub(nSaldoN, oModelSPI:GetValue("PI_QUANT"))  // Saldo normal
				nSaldoV	:= __TimeSub(nSaldoV, oModelSPI:GetValue("PI_QUANTV")) // Saldo valorizado
			EndIf
			
			oModelSPI:LoadValue("PI_SALDO", nSaldoN)
			oModelSPI:LoadValue("PI_SALDOV", nSaldoV)
		EndIf
		
	Next nI
	
Return .T.

/*/{Protheus.doc} Pn200Saldo
Atualiza o saldo de acodo com as horas informadas
@type function
@author Cícero Alves
@since 12/06/2024
@param nOpc, numeric, 1 - Chamada do valid do campo PI_QUANT; 2 - Chamada do valid do campo PI_QUANTV
@return logical, Verdadeiro quando as horas do lançamento forem válidas
/*/
Function Pn200Saldo(nOpc)
	
	Local oModel 	:= FWModelActive()
	Local oModelSPI := oModel:GetModel("PONA200_SPI")
	Local nLine		:= oModelSPI:GetLine()
	Local nValI		:= 0
	Local oView		:= FWViewActive()
	Local nPerc		:= 0
	Local nVarVal	:= 0
	
	// Validação dos minutos informados nos campos PI_QUANT e PI_QUANTV
	nQuant := If(nOpc == 1, oModelSPI:GetValue("PI_QUANT"), oModelSPI:GetValue("PI_QUANTV"))
	If (nQuant - Int(nQuant)) * 100 >= 60
		Help(' ', 1, 'THORMAIO59')
		Return .F.
	EndIF
	
	If nOpc == 1
		// Atualiza o campo de horas valorizadas de acordo com o percentual do evento
		nValI := oModelSPI:GetValue("PI_QUANT")
		nPerc := PosSP9(oModelSPI:GetValue("PI_PD"), SRA->RA_FILIAL, "P9_BHPERC", 1, .F.)
		nVarVal := fConvHr(Round(fConvHr(nValI, "D") * (nPerc/100), 2), "H")
		oModelSPI:LoadValue("PI_QUANTV", nVarVal)
	EndIf
	
	// Atualiza o Saldo das demais linhas
	BhSaldo(oModel, .F.)
	
	If oView != NIL .And. oView:IsActive()
		oView:Refresh()
		oView:GetViewObj("PONA200_SPI")[3]:obrowse:GoTo(nLine)
	EndIf
	
	// Retorna para a linha alterada
	oModelSPI:GoLine(nLine)
	
Return .T.

/*/{Protheus.doc} Pona200LOk
Validação de linha do grid
@type static function
@author Cícero Alves
@since 12/06/2024
@param oModelSPI, object, submodelo contendo as informações da SPI
@return lLinOk, logical, verdadeiro de a linha digitada for válida
/*/
Static Function Pona200LOk(oModelSPI)
	
	Local lLinOk	:= .T.
	Local nLinha	:= 1
	Local nSPILinha := oModelSPI:GetLine()
	Local cSPINew	:= ""
	Local dDataB	:= oModelSPI:GetValue("PI_DATA")
	Local nLength	:= oModelSPI:Length()
	
	If !oModelSPI:IsDeleted()
		
		// inclusão de linha ou alteração dos campos chave
		If nLength > 1 .And. oModelSPI:IsInserted() .Or. oModelSPI:IsFieldUpdate("PI_DATA") .Or. oModelSPI:IsFieldUpdate("PI_PD") .Or. oModelSPI:IsFieldUpdate("PI_STATUS") .Or. oModelSPI:IsFieldUpdate("PI_CC") .Or. oModelSPI:IsFieldUpdate("PI_DTBAIX")
			
			cSPINew := DToS(oModelSPI:GetValue("PI_DATA")) + oModelSPI:GetValue("PI_PD") + oModelSPI:GetValue("PI_STATUS") + oModelSPI:GetValue("PI_CC") + DToS(oModelSPI:GetValue("PI_DTBAIX"))
			
			
			// Validação de linha duplicada
			oModelSPI:GoLine(1)
			
			While nLinha <= nLength
				
				oModelSPI:GoLine(nLinha)
				
				If !oModelSPI:IsDeleted() .And. nLinha <> nSPILinha .And. oModelSPI:GetValue("PI_DATA") == dDataB
					If cSPINew == DToS(oModelSPI:GetValue("PI_DATA")) + oModelSPI:GetValue("PI_PD") + oModelSPI:GetValue("PI_STATUS") + oModelSPI:GetValue("PI_CC") + DToS(oModelSPI:GetValue("PI_DTBAIX"))
						// "Registro Duplicado"
						Help(,, "HELP",, STR0041, 1, 0,,,, NIL, NIL, {STR0042 + cValtoChar(nLinha) + "."})
						lLinOk := .F.
						EXIT
					EndIf
				EndIf
				
				nLinha++
				
			EndDo
			
			oModelSPI:GoLine(nSPILinha)
			
		EndIf
		
		If oModelSPI:GetValue("PI_STATUS") == "B" // Evento baixado
			If Empty(oModelSPI:GetValue("PI_DTBAIX"))
				lLinOk := .F.
				//"Para Lançamentos baixados é necessário informar a data de baixa."
				Help(NIL, NIL, "HELP", NIL, STR0033, 1, 0, NIL, NIL, NIL, NIL, NIL, {STR0034}) // "Informe a data de baixa do evento"
			EndIf
		Else
			If !Empty(oModelSPI:GetValue("PI_DTBAIX"))
				lLinOk := .F.
				// "Para Lançamentos sem baixa o campo data de baixa não deve ser preenchido"
				Help(NIL, NIL, "HELP", NIL, STR0035, 1, 0, NIL, NIL, NIL, NIL, NIL, {STR0036}) // "Remova a data de baixa ou altere o status do evento"
			EndIf
		EndIf
	EndIf
	
Return lLinOk

/*/{Protheus.doc} InitMBH
Busca pelo registro com os meses para vancimento do BH na SPI e atualiza o campo
@type static function
@author Cícero Alves
@since 12/06/2024
@param oModel, object, instância da classe MPFormModel contendo as informações da SRA e da SPI
@return logical, sempre verdadeiro
/*/
Static Function InitMBH(oModel)
	
	Local cQuery := ""
	Local cAliasSPI := ""
	
	// Não é possível alterar o conteúdo dos campos no delete
	If oModel:GetOperation() == MODEL_OPERATION_DELETE
		Return .T.
	EndIf
	
	lMesesBH := If(lMesesBH == NIL, SPI->(ColumnPos("PI_MESESBH")) > 0, lMesesBH)
	
	If !lMesesBH
		Return .T.
	EndIf
	
	If oSPIQuery == Nil
		cQuery := "SELECT PI_MESESBH, R_E_C_N_O_ RECNO FROM " + RetSqlName("SPI")
		cQuery += " WHERE PI_FILIAL = ? " 
		cQuery += " AND PI_MAT = ? "
		cQuery += " AND PI_MESESBH > 0 "
		cQuery += " AND D_E_L_E_T_ = ' '"
		cQuery := ChangeQuery(cQuery)
		oSPIQuery := FWExecStatement():New(cQuery)
	EndIf
	
	oSPIQuery:SetString(1, SRA->RA_FILIAL)
	oSPIQuery:SetString(2, SRA->RA_MAT)
	
	cAliasSPI := oSPIQuery:OpenAlias()
	
	If (cAliasSPI)->(!EoF())
		oModel:GetModel("PONA200_SRA"):LoadValue("MESESBH", (cAliasSPI)->PI_MESESBH)
		lNewSPI := .F. // Gurda o recno para atualizar o registro
		nRecSPI := (cAliasSPI)->RECNO
	Else
		lNewSPI := .T. // Grava um novo registro na SPI ao salvar os meses para vencimento
		nRecSPI := 0
	EndIf
	
	(cAliasSPI)->(dbCloseArea())
	
Return .T.

/*/{Protheus.doc} Pn200Grava
Realiza o commit das informações
@type static function
@author Cícero Alves
@since 12/06/2024
@param oModel, object, instância da classe MPFormModel contendo as informações da SRA e da SPI
@return logical, sempre verdadeiro
/*/
Static Function Pn200Grava(oModel)
	
	oModelSRA := oModel:GetModel("PONA200_SRA")
	
	lMesesBH := If(lMesesBH == NIL, SPI->(ColumnPos("PI_MESESBH")) > 0, lMesesBH)
	
	If FwFormCommit(oModel)
		// Grava os meses para vencimento quado informado
		If lMesesBH .And. (oModelSRA:GetValue("MESESBH") > 0 .Or. !lNewSPI)
			GravaSPI(nRecSPI, SRA->RA_FILIAL, SRA->RA_MAT, oModelSRA:GetValue("MESESBH"))
		EndIf
	EndIf
	
Return .T.

/*/{Protheus.doc} Pn200ValDt
Função chamada pelo valid do campo PI_DATA, atualiza a data de vencimento do evento
@type function
@author Cícero Alves
@since 12/06/2024
@return Logical, Sempre Verdadeiro
/*/
Function Pn200ValDt()
	
	Local oModel 	:= NIL
	local nMeses	:= 0
	
	lMesesBH := If(lMesesBH == NIL, SPI->(ColumnPos("PI_MESESBH")) > 0, lMesesBH)
	
	If lMesesBH
		oModel := FWModelActive()
		nMeses := oModel:GetModel("PONA200_SRA"):GetValue("MESESBH")
		If nMeses > 0
			oModel:GetModel("PONA200_SPI"):LoadValue("PI_DTVENC", MonthSum(oModel:GetModel("PONA200_SPI"):GetValue("PI_DATA"), nMeses))
		EndIf
	EndIf
	
Return .T.

/*/{Protheus.doc} Pn200ValPd
Função mantida por compatibilidade, a chamada foi excluída do dicionário na release 12.1.2410
@type function
@return Logical, Sempre Verdadeiro
/*/
Function Pn200ValPd()
Return .T.

/*/{Protheus.doc} AtuMesesBH
Atualiza os meses para vencimento e a data de vencimento dos registros do banco de horas
@type  Function
@author Cícero Alves
@since 17/06/2024
@param lGestao, logical, se a chamada foi feita pela rotina de gestão de banco de horas
@return NIL, NIL
/*/
Function AtuMesesBH(lGestao)
	
	Local cAliasSRA := GetNextAlias()
	Local cJoin		:= ""
	Local nMeses	:= 0
	Local lAtuSPI	:= .F.
	Local dDtSPIDe	:= cToD("")
	Local cSRAWhere	:= ""
	Local cSRAAlias := ""
	Local cMarkSRA	:= ""
	
	DEFAULT lGestao	:= .F.
	
	If lGestao 
		If Type("oArqSRA") == "O" .And. Type("cMark") == "C"
			cSRAAlias := oArqSRA:GetRealName()
			cMarkSRA := cMark
		EndIf
		lGestao := If(Empty(cSRAAlias) .Or. Empty(cMarkSRA), .F., lGestao)
	EndIf
	
	lMesesBH := If(lMesesBH == NIL, SPI->(ColumnPos("PI_MESESBH")) > 0, lMesesBH)
	
	If !lMesesBH
		//"Opção não disponível para esta versão do sistema"
		Help(NIL, NIL, "HELP", NIL, STR0037, 1, 0, NIL, NIL, NIL, NIL, NIL, {STR0038}) // "Para utilizar o Fechamento por vencimento é necessário atualizar o sistema."
		Return
	EndIf
	
	Pergunte("PONA200", !lGestao)
	
	nMeses := MV_PAR09
	lAtuSPI := MV_PAR10 == 1
	dDtSPIDe := MV_PAR11
	
	If !lGestao
		cSRAWhere := GetSRAWhere()
	Else
		cJoin := "INNER JOIN " + cSRAAlias + " TMP "
		cJoin += "ON SRA.RA_FILIAL = TMP.RA_FILIAL AND "
		cJoin += "SRA.RA_MAT = TMP.RA_MAT AND "
		cJoin += "TMP.OK = '" + cMarkSRA + "' "
	EndIf
	
	cJoin := "%" + cJoin + "%"
	cSRAWhere := "%" + cSRAWhere + "%"
	
	BeginSQL ALIAS cAliasSRA
		SELECT DISTINCT SRA.RA_FILIAL, SRA.RA_MAT, SPI.R_E_C_N_O_ PI_RECNO
		FROM %Table:SRA% SRA
		LEFT JOIN %Table:SPI% SPI
		ON SRA.RA_FILIAL = SPI.PI_FILIAL
		AND SRA.RA_MAT = SPI.PI_MAT
		AND SPI.PI_MESESBH > 0
		AND SPI.%NotDel%
		%Exp:cJoin%
		WHERE SRA.%NotDel%
		%Exp:cSRAWhere%
		ORDER BY RA_FILIAL, RA_MAT
	EndSQL
	
	While (cAliasSRA)->(!EoF())
		
		(cAliasSRA)->(GravaSPI(PI_RECNO, RA_FILIAL, RA_MAT, nMeses))
		
		If lAtuSPI
			(cAliasSRA)->(AtuSPI(RA_FILIAL, RA_MAT, nMeses, If(Empty(dDtSPIDe), "", dToS(dDtSPIDe))))
		EndIf
		
		(cAliasSRA)->(!dbSkip())
	EndDo
	
	(cAliasSRA)->(dbCloseArea())
	
Return

/*/{Protheus.doc} GetSRAWhere
Retorna a clásula whera utilizada para filtrar a SRA com base nos parâmetros selecionados
@type  Static Function
@author Cícero Alves
@since 17/06/2024
@return cWhereSRA, Caractere, clásula whera utilizada para filtrar a SRA
/*/
Static Function GetSRAWhere()
	
	Local cAcessaSRA	:= ""
	Local cWhereSRA		:= ""
	
	cAcessaSRA	:= fSFiltrSQL(ChkRH("PONA200", "SRA", "2"))
	
	MV_PAR07 := fSqlIn(StrTran(MV_PAR07, '*'), 1)
	MV_PAR08 := fSqlIn(StrTran(MV_PAR08, '*'), 1)
	
	MakeSqlExp("PONA200")
	
	cWhereSRA += If(!Empty(MV_PAR01), " AND " + MV_PAR01, "") 							// Filiais
	cWhereSRA += If(!Empty(MV_PAR02), " AND " + MV_PAR02, "") 							// Centros de Custo
	cWhereSRA += If(!Empty(MV_PAR03), " AND " + MV_PAR03, "")							// Turnos
	cWhereSRA += If(!Empty(MV_PAR04), " AND " + MV_PAR04, "") 							// Matrículas
	cWhereSRA += If(!Empty(MV_PAR05), " AND " + MV_PAR05, "") 							// Regras de Apontamento
	cWhereSRA += If(!Empty(MV_PAR06), " AND " + MV_PAR06, "") 							// Sindicatos
	cWhereSRA += If(!Empty(MV_PAR07), " AND RA_SITFOLH IN (" + MV_PAR07 + ")", "") 		// Situações
	cWhereSRA += If(!Empty(MV_PAR08), " AND RA_CATFUNC IN (" + MV_PAR08 + ")", "") 		// Categorias
	
	// Controle de Acesso
	cWhereSRA += If(!Empty(cAcessaSRA) .And. cAcessaSRA != ".T.", " AND " + cAcessaSRA, "")
	
Return cWhereSRA

/*/{Protheus.doc} GravaSPI
Grava os meses para vencimento do banco de horas na linha de cabeçalho da SPI
@type static function
@author Cícero Alves
@since 17/06/2024
@param nRecno, numeric, Recno do registro de cabeçalho caso já exista
@param cFilFunc, character, Filial do funcionário
@param cMatFunc, character, Matrícula do funcionário
@param nMeses, numeric, Meses para vencimento do banco de horas
@return NIL, NIL
/*/
Static Function GravaSPI(nRecno, cFilFunc, cMatFunc, nMeses)
	
	If Empty(nRecno)
		If nMeses > 0
			RecLock("SPI", .T.)
				SPI->PI_FILIAL := cFilFunc
				SPI->PI_MAT := cMatFunc
				SPI->PI_MESESBH := nMeses
			SPI->(MSUnlock())
		EndIf
	Else
		dbSelectArea("SPI")
		SPI->(dbGoTo(nRecno))
		RecLock("SPI", .F.)
			If nMeses > 0
				SPI->PI_MESESBH := nMeses
			Else
				SPI->(dbDelete())
			EndIf
		SPI->(MSUnlock())
	EndIf
	
Return

/*/{Protheus.doc} AtuSPI
Atualiza a data de vencimento dos registros da SPI
@type Static function
@author Cícero Alves
@since 17/06/2024
@param cFilFunc, character, Filial do funcionário
@param cMatFunc, character, Matrícula do funcionário
@param nMeses, numeric, Meses para vencimento do banco de horas
@param cDtSPIDe, date, Data inicial para alteração dos registros
@return variant, return_description
/*/
Static Function AtuSPI(cFilFunc, cMatFunc, nMeses, cDtSPIDe)
	Local aArea		:= GetArea()
	Local dNovoVenc := cToD("")
	Local cAlias	:= "SPIVENCBH"
	Local cQuery	:= ""

	Static oAtuBHVenc
	
	DEFAULT cDtSPIDe := ""
	
	dbSelectArea("SPI")

	If oAtuBHVenc == Nil
		oAtuBHVenc := FWPreparedStatement():New()

		cQuery := "SELECT SPI.PI_STATUS, SPI.PI_MESESBH, SPI.PI_DATA, SPI.R_E_C_N_O_"
		cQuery += "FROM " + RetSqlName("SPI") + " SPI "
		cQuery += "WHERE SPI.PI_FILIAL = ? "
		cQuery +=   "AND SPI.PI_MAT = ? "
		cQuery +=   "AND SPI.PI_DATA >= ? "
		cQuery +=   "AND SPI.PI_STATUS <> ? "
		cQuery +=   "AND SPI.PI_MESESBH = ? "
		cQuery +=   "AND SPI.D_E_L_E_T_ = ? "

		cQuery := ChangeQuery(cQuery)

		oAtuBHVenc:SetQuery(cQuery)		
	EndIf

	oAtuBHVenc:SetString(1, cFilFunc)
	oAtuBHVenc:SetString(2, cMatFunc)
	oAtuBHVenc:SetString(3, cDtSPIDe)
	oAtuBHVenc:SetString(4,"B")
	oAtuBHVenc:setNumeric(5, 0)
	oAtuBHVenc:SetString(6, " ")
	
	cQuery := oAtuBHVenc:getFixQuery()
	dbUseArea(.T., "TOPCONN", TcGenQry(,,cQuery), cAlias)

	While !(cAlias)->(Eof())
		dNovoVenc := MonthSum(sToD((cAlias)->PI_DATA), nMeses)

		SPI->(DbGoTo((cAlias)->R_E_C_N_O_))
		
		If RecLock("SPI", .F.)
			SPI->PI_DTVENC := dNovoVenc
			SPI->(MSUnlock())
		EndIf

		SPI->(dbSkip())
		(cAlias)->(dbSkip())
	Enddo

	(cAlias)->(dbCloseArea())
	
	RestArea(aArea)
Return

/*/{Protheus.doc} GetMesesBH
Retorna os meses para vencimento do banco de horas de um funcionário
@type function
@author Cícero Alves
@since 17/06/2024
@param cFilFunc, character, Filial do funcionário
@param cMatFunc, character, Matrícula do funcionário
@return number, Meses gravados na linha de cabeçalho da SPI; 0 caso não encontre
/*/
Function GetMesesBH(cFilFunc, cMatFunc)
	
	Local cQuery 		:= ""
	Local cAliasSPI 	:= ""
	Local nRet			:= 0
	
	lMesesBH := If(lMesesBH == NIL, SPI->(ColumnPos("PI_MESESBH")) > 0, lMesesBH)
	
	If lMesesBH
		If oSPIQuery == Nil
			cQuery := "SELECT PI_MESESBH, R_E_C_N_O_ RECNO FROM " + RetSqlName("SPI")
			cQuery += " WHERE PI_FILIAL = ? " 
			cQuery += " AND PI_MAT = ? "
			cQuery += " AND PI_MESESBH > 0 "
			cQuery += " AND D_E_L_E_T_ = ' '"
			cQuery := ChangeQuery(cQuery)
			oSPIQuery := FWExecStatement():New(cQuery)
		EndIf
		
		oSPIQuery:SetString(1, cFilFunc)
		oSPIQuery:SetString(2, cMatFunc)
		
		cAliasSPI := oSPIQuery:OpenAlias()
		
		If (cAliasSPI)->(!EoF())
			nRet := (cAliasSPI)->PI_MESESBH
		EndIf
		
		(cAliasSPI)->(dbCloseArea())
	EndIf
	
Return nRet
