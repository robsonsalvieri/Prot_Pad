#INCLUDE "PONA030.CH"
#INCLUDE "PROTHEUS.CH"
#INCLUDE "TOPCONN.CH"

Static lPort1510 	:= Port1510() 	//Verifica se Portaria 1510/2009 esta em vigor.
Static lCpos671
Static l671RR1MSA
Static lSP0Comp

/*/
эээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤└o    Ё PONA030  Ё Autor Ё Equipe Advanced RH    Ё Data Ё07/02/1996Ё╠╠
╠╠цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤└o Ё Cadastro de Rel╒gio de Ponto                               Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠Ё Uso      Ё SIGAPON                                                    Ё╠╠
╠╠цддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠Ё         ATUALIZACOES SOFRIDAS DESDE A CONSTRU─AO INICIAL.             Ё╠╠
╠╠цддддддддддддбддддддддбддддддбдддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁProgramador Ё Data   Ё BOPS Ё  Motivo da Alteracao                     Ё╠╠
╠╠цддддддддддддеддддддддеддддддедддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁLeandro Dr. Ё14/04/14Ё      ЁRetirada de ajustes, database e FieldPos  Ё╠╠
╠╠Ё            Ё        Ё      Ёque nao serao utilizados na P12.		  Ё╠╠
╠╠ЁLuis Artuso Ё24/06/15ЁTSGNVOЁAjuste p/ identificacao do cracha quando  Ё╠╠
╠╠Ё            Ё        Ё      Ёutilizar o parametro MV_TPLMARC, e coletarЁ╠╠
╠╠Ё            Ё        Ё      Ёas marcacoes atraves da tabela 		 	  Ё╠╠	
╠╠Ё            Ё        Ё      ЁMSA_CONTROL_MARCAC(TSA).                  Ё╠╠	
╠╠ЁAllyson M.  Ё16/10/15ЁTTPMJ1ЁAjuste p/ integracao ao TSA p/ atualizar  Ё╠╠
╠╠Ё            Ё        Ё      Ёflag de leitura na MSA_CONTROL_MARCAC	  Ё╠╠
╠╠Ё            Ё        Ё      Ёquando ja existir o registro na RFE		  Ё╠╠
╠╠Ё            Ё        Ё      ЁAjuste p/ validacao do campo P0_INC.      Ё╠╠
╠╠Ё            Ё        Ё      ЁRelogios do tipo 'REP' devem ser incre-   Ё╠╠
╠╠Ё            Ё        Ё      Ёmentais, conforme boletim:				  Ё╠╠
╠╠Ё            Ё        Ё      Ёhttp://tdn.totvs.com/x/9YRsAQ 			  Ё╠╠
╠╠Ё            Ё        Ё      ЁCorrecao na coleta de marcacoes de refei- Ё╠╠
╠╠Ё            Ё        Ё      Ёcao. Efetuado ajuste para gravar na RFE   Ё╠╠
╠╠Ё            Ё        Ё      Ёregistros que nao possuam NSR.            Ё╠╠
╠╠Ё            Ё        Ё      ЁAjuste para eliminar espaco gerado indevi-Ё╠╠
╠╠Ё            Ё        Ё      Ёdos na variavel 'cData' (TSA).            Ё╠╠
╠╠ЁRenan BorgesЁ08/01/16ЁTUDTQOЁAjuste para realizar a leitura e o aponta-Ё╠╠
╠╠Ё            Ё        Ё      Ёmento das marcaГУes referentes a dias anteЁ╠╠
╠╠Ё            Ё        Ё      Ёriores ao inicio do periodo, que estejam  Ё╠╠
╠╠Ё            Ё        Ё      Ёdentro dos limites do periodo atual e de  Ё╠╠
╠╠Ё            Ё        Ё      Ёacordo com o parametro MV_GETDIAA.        Ё╠╠
╠╠ЁRenan BorgesЁ18/04/16ЁTUJU54ЁAjuste para buscar marcaГЦo correta na leiЁ╠╠
╠╠Ё            Ё        Ё      Ёtura do TSA.                              Ё╠╠
╠╠ЁRenan BorgesЁ13/05/16ЁTVEQZXЁAjuste p/ integracao ao TSA p/ sempre  	  Ё╠╠
╠╠Ё            Ё        Ё      Ёretornar flag de leitura com .T. mesmo se Ё╠╠
╠╠Ё            Ё        Ё      Ёnao tiver sido importado registros do TSA Ё╠╠
╠╠Ё            Ё        Ё      Ёpois pode ser que haja registros na RFE   Ё╠╠
╠╠Ё            Ё        Ё      Ёque nao foram apontados 				  Ё╠╠
╠╠ЁRenan BorgesЁ16/05/16ЁTVE419ЁAjuste para utilizar a opГЦo de visuali - Ё╠╠
╠╠Ё            Ё        Ё      Ёzar os registros contidos no TXT, sem     Ё╠╠
╠╠Ё            Ё        Ё      Ёgerar mensagem de inconsistЙncia, mesmo   Ё╠╠
╠╠Ё            Ё        Ё      Ёo arquivo estando correto.			      Ё╠╠
╠╠ЁMatheus M.  Ё13/06/16ЁTUSX09ЁAjuste no log da leitura do TXT onde serА Ё╠╠
╠╠Ё            Ё        Ё      ЁpossМvel visualizar detalhadamente as     Ё╠╠
╠╠Ё            Ё        Ё      ЁinconsistЙncias entre TXT x RFE.	      Ё╠╠
╠╠ЁOswaldo L.  Ё03/04/17ЁDRHPONTP-164  ЁProjeto cTree                     Ё╠╠
╠╠юддддддддддддаддддддддаддддддадддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ*/
Function PONA030(aInfo, nOpcAuto)

Local aArea			:= GetArea()
Local aIndexSP0		:= {}
Local aAdvSize		:= MsAdvSize()
Local aSvKeys		:= GetKeys()
Local nAlias		:= 0
Local nX			:= 0

DEFAULT aInfo := {}
DEFAULT nOpcAuto := 0

Private lAutoExec	:= (nOpcAuto != 0 .And. Len(aInfo) > 0)
Private aAutoCab	:= aInfo

Begin Sequence
	// So Executa se o Modo de Acesso dos Arquivos do Ponto Estiverem OK
	IF !ValidArqPon()
		Break
	EndIF
    
	Private aSp0Buttons	:= {}
	Private aAliasRelo 	:= {}
	Private aRotina		:= MenuDef()
	
	Private bFiltraBrw	:= { || NIL }
	Private cFiltraRh	  := ChkRh( FunName() , "SP0" , "1" )
	Private cTxtAlias 	:= ""
	Private cCadastro	:= OemToAnsi(STR0009 ) // "Cadastro de Rel╒gios"
	
	// Cria a Variavel de Memoria TXT
	SetMemVar( "TXT" , "" , .T. )
	
	// Inicializa o filtro utilizando a funcao FilBrowse
	bFiltraBrw 	:= { || FilBrowse( "SP0" , @aIndexSP0 , @cFiltraRH ) }
	SP0->( Eval( bFiltraBrw ) )
	
	// Monta a Configuracao do Botao para Consulta do Arquivo do Relogio
	//"Carregando MarcaГУes. "###"Aguarde..."
	bSp0Buttons := { ||	MsAguarde( { || Pona030Btn() } , OemToAnsi( STR0014 + STR0015 ) ,;
						If (SP0->P0_TIPOARQ == "R", STR0034, Lower( IF( IsMemVar( "P0_ARQUIVO" ) , GetMemVar( "P0_ARQUIVO" ) , SP0->P0_ARQUIVO ) ) )),;	// "Carregando arquivo de marcacoes do REP..."
						SetKey( VK_F4 , bSp0Buttons );
			       }
	aAdd(aSp0Buttons, { "pesquisa", bSp0Buttons, OemToAnsi( STR0005 + "...<F4>"), OemToAnsi( STR0005 )}) // "Visualizar"
	
	If lPort1510
		bSp0Hist := { || MsAguarde({|| Pona030Log()}, OemToAnsi(STR0014 + STR0015 ), Lower( IF( IsMemVar( "P0_ARQUIVO" ), GetMemVar( "P0_ARQUIVO" ), SP0->P0_ARQUIVO ))), SetKey( VK_F5, bSp0Hist )}
		
		aAdd(aSp0Buttons, {"relatorio", bSp0Hist, OemToAnsi( STR0022 + "...<F5>"), OemToAnsi( STR0022 )})// "Log Leitura"
		SetKey( VK_F5 , bSp0Hist )
	EndIf
	
	// Endereca a funcao de BROWSE
	dbSelectArea("SP0")
	SP0->(dbGoTop())
	SetKey(VK_F4, bSp0Buttons)
	
	If !lAutoExec
		SP0->(mBrowse( aAdvSize[7], 0, aAdvSize[6], aAdvSize[5], "SP0"))
	Else
		mBrowseAuto( nOpcAuto, aAutoCab, 'SP0', .T., .T. )
	EndIf
	
	RestKeys( aSvKeys, .T.)
	
	// Deleta o filtro utilizando a funcao FilBrowse
	EndFilBrw("SP0", aIndexSp0)
	
	// Fecha os arquivos  abertos durante a execucao do programa
	IF ( ( nAlias := Len(aAliasRelo) ) > 0 )
		For nX := 1 To nAlias
			/*/
			здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Fecha os Arquivos Abertos em AbreArqRel()					 			 Ё
			юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			IF ( aAliasRelo[nX,04] == "D" )
				TxtAliasClose( aAliasRelo[nX,01] )
			ElseIF (;
						( aAliasRelo[nX,04] == "T" );
						.and.;
						( aAliasRelo[nX,05] > 0 );
					)	
				fClose( aAliasRelo[nX,05] )
			EndIF
			/*/
			здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			Ё Se copiou para o server, Exclui                           			 Ё
			юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
			IF ( aAliasRelo[nX,02] )
				fErase( aAliasRelo[nX,03] )
			EndIF
		Next nX
	EndIF
	
End Sequence

RestArea( aArea )

Return( NIL )

/*/
зддддддддддбдддддддддддддбдддддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁPona030Vis	 Ё Autor ЁMarinaldo de Jesus   Ё Data Ё16/09/2004Ё
цддддддддддедддддддддддддадддддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁChamada a AxVisual com Abertura do Arquivo do Relogio        Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁRetorno da AxVisual()                                	     Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁObserva┤└oЁ                                                      	     Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
Ё Uso      ЁPONA030														 Ё
юддддддддддаддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function Pona030Vis(;
						cAlias		,;
						nRecno		,;
						nOpc		,;
						aAcho		,;
						nColMens	,;
						cMensagem	,;
						cFunc		,;
						aButtons	,;
						lMaximized	 ;
					)

DEFAULT lMaximized := .T.

IF ( Type( "aSp0Buttons" ) == "A" )
	DEFAULT aButtons := aClone( aSp0Buttons )
EndIF

Return(;
			AxVisual(;
						cAlias		,;
						nRecno		,;
						nOpc		,;
						aAcho		,;
						nColMens	,;
						cMensagem	,;
						cFunc		,;
						aButtons	,;
						lMaximized	 ;
					);
		 )

/*/
зддддддддддбдддддддддддддбдддддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁPona030Inc	 Ё Autor ЁMarinaldo de Jesus   Ё Data Ё16/09/2004Ё
цддддддддддедддддддддддддадддддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁChamada a AxInclui											 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁRetorno da AxIncual()                                	     Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁObserva┤└oЁ                                                      	     Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
Ё Uso      ЁPONA030														 Ё
юддддддддддаддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function Pona030Inc(;
						cAlias		,;
						nRecno		,;
						nOpc		,;
						aAcho		,;
						cFunc		,;
						aCpos		,;
						cTudoOk		,;
						lF3			,;
						cTransact	,;
						aButtons	,;
						aParam		,;
						aAuto		,;
						lVirtual	,;
						lMaximized	 ;
					)

Local nRet		:= 0

DEFAULT lMaximized := .T.

lAutoExec := If(Type("lAutoExec") == "U", .F., lAutoExec)

cTudoOk		:= "Pn030TudOk()"

IF ( Type( "aSp0Buttons" ) == "A" )
	DEFAULT aButtons := aClone( aSp0Buttons )
EndIF

nRet := AxInclui(;
						cAlias		,;
						nRecno		,;
						nOpc		,;
						aAcho		,;
						cFunc		,;
						aCpos		,;
						cTudoOk		,;
						lF3			,;
						cTransact	,;
						aButtons	,;
						aParam		,;
						If(lAutoExec, aAutoCab, aAuto),;
						lVirtual	,;
						lMaximized	 ;
					)


Return( nRet )

/*/
зддддддддддбдддддддддддддбдддддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁPona030Alt	 Ё Autor ЁMarinaldo de Jesus   Ё Data Ё16/09/2004Ё
цддддддддддедддддддддддддадддддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁChamada a AxAtera com Abertura do Arquivo do Relogio         Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁRetorno da AxAltera()                                	     Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁObserva┤└oЁ                                                      	     Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
Ё Uso      ЁPONA030														 Ё
юддддддддддаддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function Pona030Alt(;
						cAlias		,;
						nRecno		,;
						nOpc		,;
						aAcho		,;
						aCpos		,;
						nColMens	,;
						cMensagem	,;
						cTudoOk		,;
						cTransact	,;
						cFunc		,;
						aButtons	,;
						aParam		,;
						aAuto		,;
						lVirtual	,;
						lMaximized	 ;
					)

Local aArea		:= GetArea()
Local nRet		:= 0

DEFAULT lMaximized	:= .T.

cTudoOk		:= "Pn030TudOk()"

IF ( Type( "aSp0Buttons" ) == "A" )
	DEFAULT aButtons := aClone( aSp0Buttons )
EndIF

// Adiciona a opГЦo de Reiniciar NSR
If SP0->( P0_TIPOARQ == "T" .And. P0_INC == "1") // Apenas para relСgios com arquivo incremental
	aAdd(aButtons, {, {|| LimpaNSR() }, STR0059}) // "Reiniciar NSR"
EndIf

// Fecha o cTxtAlias Anteriormente Aberto
TxtAliasClose( @cTxtAlias )

SP0->( AbreArqRel( P0_TIPOARQ , P0_ARQUIVO , NIL , .T. , .T. ) )

IF !Empty( aArea )
	RestArea( aArea )
EndIF

nRet := AxAltera(;
						cAlias		,;
						nRecno		,;
						nOpc		,;
						aAcho		,;
						aCpos		,;
						nColMens	,;
						cMensagem	,;
						cTudoOk		,;
						cTransact	,;
						cFunc		,;
						aButtons	,;
						aParam		,;
						aAuto		,;
						lVirtual	,;
						lMaximized	 ;
	  )

Return( nRet )

/*/
зддддддддддбдддддддддддддбдддддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁPona030Del	 Ё Autor ЁMarinaldo de Jesus   Ё Data Ё16/09/2004Ё
цддддддддддедддддддддддддадддддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁChamada a AxDeleta											 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁRetorno da AxIncual()                                	     Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁObserva┤└oЁ                                                      	     Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
Ё Uso      ЁPONA030														 Ё
юддддддддддаддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function Pona030Del(;
						cAlias		,;
						nRecno		,;
						nOpc		,;
						cTransact	,;
						aCpos		,;
						aButtons	,;
						aParam		,;
						aAuto		,;
						lMaximized	 ;
					)

Local lValid	:= .T.
Local bValidDel := {|| lValid := fPn30VldDel()  }
Local nRet		:= 0

DEFAULT lMaximized := .T.

IF ( Type( "aSp0Buttons" ) == "A" )
	DEFAULT aButtons := aClone( aSp0Buttons )
EndIF

If lPort1510
	aParam := {{|| },bValidDel,{|| },{|| }}
EndIf

nRet := AxDeleta(;
						cAlias		,;
						nRecno		,;
						nOpc		,;
						cTransact	,;
						aCpos		,;
						aButtons	,;
						aParam		,;
						aAuto		,;
						lMaximized	 ;
 	  )

Return( nRet )

/*/
зддддддддддбдддддддддддддбдддддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁPona030Btn   Ё Autor ЁMarinaldo de Jesus   Ё Data Ё16/09/2004Ё
цддддддддддедддддддддддддадддддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁDisponibiliza Consulta ao Cadastro Temporario de Marcacoes   Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ															 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁNIL                                                  	     Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁObserva┤└oЁ                                                      	     Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
Ё Uso      ЁGENERICO                                                     Ё
юддддддддддаддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function Pona030Btn()

Local aSvKeys			:= GetKeys()
Local aAdvSize			:= {}
Local aInfoAdvSize		:= {}
Local aObjCoords		:= {}
Local aObjSize			:= {}
Local aButtons			:= {}
Local aFields			:= {}
Local aBagName			:= {}
Local aLogFile			:= {}

Local bSet15 			:= { || NIL }
Local bSet24			:= { || NIL }
Local bInitDlg			:= { || NIL }

Local cTipoArq			:= IF( IsMemVar( "P0_TIPOARQ" ) , GetMemVar( "P0_TIPOARQ" ) , SP0->P0_TIPOARQ )
Local cArquivo			:= IF( IsMemVar( "P0_ARQUIVO" ) , GetMemVar( "P0_ARQUIVO" ) , SP0->P0_ARQUIVO )
Local cArqSrv			:= ""
Local cDataFile			:= ""
Local cHelp				:= ""

Local lSetCentury		:= __SetCentury("on")
Local lCpyT2Srv			:= .F.
Local lForceCopy		:= .F.

Local nLoop				:= 0
Local nLoops			:= 0
Local nHandle			:= 0

Local oDlg				:= NIL
Local oMsSelect			:= NIL
Local oRecMarc			:= NIL
Local cPonArq			:= If( !Empty( SuperGetMv("MV_POARQ",.F.,"N") ), SuperGetMv("MV_POARQ",.F.,"N"), "2" )
Private oTmpTabFO1
/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
ЁReinicia a variavel do nome do arquivo qdo for REP devido o campo P0_ARQUIVO ser obrigatorio Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
If SP0->P0_TIPOARQ == "R"	
	cArquivo := "REP"
	M->P0_ARQUIVO := "REP"
Endif

Begin Sequence

	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	ЁFecha o cTxtAlias Anteriormente Aberto                 	   Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	TxtAliasClose( @cTxtAlias )

	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	ЁAbre  o Arquivo do Relogio                             	   Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	If SP0->P0_TIPOARQ <> "R"
		IF !AbreArqRel( cTipoArq , cArquivo , @nHandle , .T. , .T. , @cArqSrv , @lCpyT2Srv )
			Break
		EndIF
	Endif
	
	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	ЁMonta o Temporario de Marcacoes Quando Nao For Informado REP  Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	IF !SP0BldData( cTipoArq , IF( !Empty( cArqSrv ) , cArqSrv , cArquivo ) , @cDataFile , @aBagName , @cTxtAlias , @aLogFile, , , , , .T. )
		IF !Empty( aLogFile )
			nLoops := Len( aLogFile )
			For nLoop := 1 To nLoops
				cHelp += aLogFile[ nLoop ]
				cHelp += CRLF
			Next nLoop
			Help( "" , 1 , "PONA030INV" , NIL , OemToAnsi( cHelp ) , 1 , 0 )
		EndIF
		Break
	EndIF
 	
	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	ЁDefine o Array com os Campos                           	   Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	aAdd( aFields ,	{ "CRACHA"	, NIL ,	PosAlias( "SX3" , "RA_CRACHA"	, "" , "X3Titulo()" , 2 , .F. ) , "@!" } )
	aAdd( aFields ,	{ "DDATE"	, NIL ,	PosAlias( "SX3" , "P8_DATA" 	, "" , "X3Titulo()" , 2 , .F. ) , "@D" } )
	aAdd( aFields ,	{ "HORA"	, NIL ,	PosAlias( "SX3" , "P8_HORA" 	, "" , "X3Titulo()" , 2 , .F. ) , "@R 99.99" } )
	aAdd( aFields ,	{ "CODREL"	, NIL ,	PosAlias( "SX3" , "P8_RELOGIO"  , "" , "X3Titulo()" , 2 , .F. ) , "@!" } )
	aAdd( aFields ,	{ "FUNCAO"	, NIL ,	PosAlias( "SX3" , "P8_FUNCAO"	, "" , "X3Titulo()" , 2 , .F. ) , "@!" } )
	aAdd( aFields ,	{ "GIRO"	, NIL ,	PosAlias( "SX3" , "P8_GIRO"		, "" , "X3Titulo()" , 2 , .F. ) , "@!" } )
	aAdd( aFields ,	{ "CUSTO"	, NIL ,	PosAlias( "SX3" , "P8_CC"		, "" , "X3Titulo()" , 2 , .F. ) , "@!" } )


	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Define os Blocos para as Teclas <CTRL-O>					   Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	bSet15 	:= { || RestKeys( aSvKeys , .T. ) , oDlg:End() }

	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Define os Blocos para as Teclas <CTRL-X>     	   			   Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	bSet24	:= { || RestKeys( aSvKeys , .T. ) , oDlg:End() }
	
	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Define o Bloco para o Init do Dialog         	   			   Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	bInitDlg := { ||	Eval( oMsSelect:oBrowse:bGotop )	,;
						oMsSelect:oBrowse:Refresh()			,;
						EnchoiceBar( oDlg , bSet15 , bSet24 , NIL , aButtons );
			 	}

	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Monta as Dimensoes para o Dialogo Principal				   Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	aAdvSize		:= MsAdvSize(.T.,.T.)
	aInfoAdvSize	:= { aAdvSize[1] , aAdvSize[2] , aAdvSize[3] , aAdvSize[4] , 5 , 5 }
	aAdd( aObjCoords , { 000 , 000 , .T. , .T. } )
	aAdd( aObjCoords , { 000 , 020 , .T. , .F. } )
	aObjSize		:= MsObjSize( aInfoAdvSize , aObjCoords )
	aMsSltCoords	:= { aObjSize[1,1] , aObjSize[1,2] , aObjSize[1,3] , aObjSize[1,4] }

	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Monta Dialogo para Montagem do Filtro                        Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	DEFINE MSDIALOG oDlg TITLE cCadastro From aAdvSize[7],0 TO aAdvSize[6],aAdvSize[5] OF GetWndDefault() PIXEL

		oMsSelect := MsSelect():New(;
										cTxtAlias		,;	//Alias	do Arquivo de Filtro
										NIL				,;	//Campo para controle do mark
										NIL				,;	//Condicao para o Mark
										aFields			,;	//Array com os Campos para o Browse
										NIL				,;	//?
										NIL   			,;	//Conteudo a Ser Gravado no campo de controle do Mark
										aMsSltCoords	,;	//Coordenadas do Objeto
										NIL				,;  //?
										NIL				,;	//?	
										oDlg			 ;	//Objeto Dialog
									)
		
		@ aObjSize[2,1]+5,aObjSize[2,2];
			SAY oRecMarc;
			VAR (;
					OemToAnsi( STR0012	 ); //"Numero de MarcaГУes:"
					+ " " +;
					AllTrim( Str( ( cTxtAlias )->( LastRec() ) ) );
					+ " " +;
					STR0013;	//" Registro:"
					+ " " +;
					AllTrim( Str( ( cTxtAlias )->( Recno() ) ) );
				 );	
			SIZE 150,010;
			OF oDlg;
			PIXEL
		oMsSelect:oBrowse:bChange	:= { || oRecMarc:Refresh() }

	ACTIVATE MSDIALOG oDlg CENTERED ON INIT Eval( bInitDlg ) 

End Sequence

/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Restaura as Teclas de Atalho        						  Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
RestKeys( aSvKeys , .T. )

/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Exclui os Arquivos Temporarios 							  Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
TxtAliasClose( @cTxtAlias )


If oTmpTabFO1 <> Nil
	oTmpTabFO1:Delete()
	Freeobj(oTmpTabFO1)
EndIf

If SP0->P0_TIPOARQ <> "R"
	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	ЁcPonArq - indica que sС copia o arquivo para o StartPath caso Ё
	Ёo parametro MV_POARQ esteja com valor NцO					   Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	If (cPonArq != "1")
		/*/
		зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		Ё Se copiou para o server, Exclui 							  Ё
		юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
		IF ( ( lCpyT2Srv ) .and. !Empty( cArqSrv ) )
			IF !( Upper( AllTrim( cArquivo ) ) == Upper( AllTrim( cArqSrv ) ) )
				lForceCopy := .T.
				fErase( cArqSrv )
			EndIF
		EndIF
	EndIf
	
	/*/
	зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Mantenho o arquivo do Relogio Aberto						  Ё
	юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	AbreArqRel( cTipoArq , cArquivo , @nHandle , .F. , .F., Nil, Nil, lForceCopy )
Endif

IF !( lSetCentury )
	__SetCentury("off")
EndIF

Return( NIL )

/*/
зддддддддддбдддддддддддддбдддддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁSP0BldData	 Ё Autor ЁMarinaldo de Jesus   Ё Data Ё16/09/2004Ё
цддддддддддедддддддддддддадддддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁMonta Arquivo Temporario de Marcacoes de acordo com a EstrutuЁ
Ё          Ёra Definida no Cadastro de Relogios							 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ<Vide Parametros Formais>									 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁNIL                                                  	     Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁObserva┤└oЁNecessita que o SP0 esteja Posicionado                	     Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁGENERICO                                                     Ё
юддддддддддаддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function SP0BldData(	cDataType	,;
						cDataName	,;
						cDataFile	,;
						aBagName	,;
						cTxtAlias	,;
						aLogFile	,; 
						dDataIni	,;
						dDataFim    ,;
						nDiasExtA	,;
						nDiasExtP	,;						
						lTempF4		,;
						lWorkFlow	,;
						cArquivo	;
				   )

Local aArea			:= GetArea()
Local aInfoFile
Local aErroData		:= {}
Local aErroFunc		:= {}

Local lTemReg		:= .T.
Local lRet			:= .T.
Local lSetCentury	:= __SetCentury("on")

Local aFields
Local aFieldsSize

Local cExt
Local cDia
Local cMes
Local cAno
Local cData
Local cCodRel
Local cHrs
Local cMin
Local cCracha
Local cFuncao
Local cGiro
Local cCusto
Local cRAFilial
Local cRAMat
Local cDbfAlias
Local cLatitude  := ""
Local cLongitude := ""
Local cGeofence  := ""
Local cDtGvMarc
Local cMarcOn
Local cIdMarc
Local cSRH256
Local cCRC


Local cPIS
Local cCPF
Local nHora

Local cFormCra
Local cFormRel
Local cFormFun
Local cFormGir
Local cFormCcu
Local cFormDia
Local cFormMes
Local cFormAno
Local cFormHrs
Local cFormMin
Local cDtHrLi
Local cDtHrLf
Local cDtHrG
Local cDhOrg
Local cIdOrg
Local cLastIdOrg
Local cLinha
Local cHoraAux
Local cDataAux
Local cKeySeek
Local cKeyAux
Local cMsgErr
Local cNumRep
Local cPonDiv		:= SuperGetMv('MV_PONDIV',.F.,'10')
Local cFilMarc		:= ""

Local dData

Local lVerPeriodo  	:= ( dDataIni <> NIL )
Local lGrvRFE	   	:= .F.
Local lIncremental 	:= .F.
Local lREP			:= .F.
Local lExistRFE		:= .F.

Local nCraIni
Local nCraFim
Local nRelIni
Local nRelFim
Local nFunIni
Local nFunFim
Local nGirIni
Local nGirFim
Local nCcuIni
Local nCcuFim
Local nDiaIni
Local nDiaFim
Local nMesIni
Local nMesFim
Local nAnoIni
Local nAnoFim
Local nHrsIni
Local nHrsFim
Local nMinIni
Local nMinFim
Local nTpRegIni
Local nTpRegFim
Local nDtGMarIni
Local nDtGMarFim
Local nTpDispIni
Local nTpDispFim
Local nMrcOnIni
Local nMrcOnFim
Local nSRH256Ini
Local nSRH256Fim
Local nCRCIni
Local nCRCFim
Local nLinha
Local nGuardLin  	:= 0
Local nTamArq
Local nRegsLinTxt 	:= 0
Local nRegsTot		:= 0
Local nContDiv		:= 0
Local nContErro		:= 0
Local nTipErro		:= 0

Local nCodRel
Local nCracha
Local nFuncao
Local nGiro
Local nCusto
Local nFields  

Local cAliasMSA		:= GetNextAlias()
Local cAliasNSR		:= "QRFENSR"
Local cWhere		:= ""
Local cWhereNSR		:= ""
Local cSelect		:= ""
Local cRepDtIni 	:= ""
Local cRepDtFim 	:= ""
Local cOrder		:= ""
Local cTipoDado		:= ""
Local cTipoREP		:= ""
Local cMsg			:= ""
Local cCCTREP		:= ""
Local nOrdSRA		:= SRA->(IndexOrd())

Local cSGBD			:= AllTrim( Upper( TcGetDb() ) )

Local cTpLMarc		:= GetMv("MV_TPLMARC",.F.,"1")

Local cQueryUpdate  := "" 
Local aLstIndices := {}

Local cTabInteg		:= "MSA_CONTROL_MARCAC"
Local lCaClockIn 	:= SuperGetMv( "MV_APICLO0" , NIL , .F. )
Local cConec 		:= SuperGetMv("MV_APICLO3", .F., '')
Local lIntegServ 	:= SuperGetMV('MV_TECXRH',.F.,.F.) .AND. ExistFunc("TecCheckIn")
Local lTsRep		:= SuperGetMv("MV_TSREP", .F., .F.)
Local lIntRR1Car	:= SuperGetMv("MV_APICLOD", .F., .T.)
Local lIntRR1Sur	:= SuperGetMv("MV_APISUR", NIL, .F.)
Local lGeoFence		:= lCaClockIn .And. RFE->( ColumnPos("RFE_LATITU") ) > 0
Local lTemRR1		:= AliasInDic("RR1")
Local lIntegRR1		:= .F.
Local lSP0TPREP		:= SP0->( ColumnPos("P0_TPREP") ) > 0
Local lRepCarol		:= .F.
Local lRR1CCT		:= RR1->( ColumnPos("RR1_CCTREP") ) > 0
Local lMemoCalc		:= GetlMemoCalc()
Local nTabs			:= 0
Local lExtFilMsa	:= .F.

Local lTipoDoc		:= SP0->( ColumnPos("P0_TIPODOC") ) > 0
Local cTipoDoc		:= ""

Local nDocCol  		:= 0
Local nRelCol  		:= 0
Local nDataCol 		:= 0
Local nHRsCol  		:= 0
Local nCCCol   		:= 0
Local cTipoDT 		:= ""
Local cSeparador 	:= ""
Local aLinha		:= {}

DEFAULT nDiasExtA	:= 2
DEFAULT nDiasExtP	:= 2
DEFAULT lTempF4		:= .F.
DEFAULT lWorkFlow	:= .F.
DEFAULT lSP0Comp	:= FWModeAccess("SP0",1) == "C" .AND. FWModeAccess("SP0",2) == "C" .AND. FWModeAccess("SP0",3) == "C"

lCpos671 := If(lCpos671 == NIL, fValid671(), lCpos671)

If lTemRR1
	If lTsRep .And. lCaClockIn
		If lIntRR1Car <> lIntRR1Sur
			Help(,, OemToAnsi(STR0051),, OemToAnsi(STR0052), 1, 0) // Se houver integraГЦo com a Carol e Suricato os parБmetros MV_APICLOD e MV_APISUR precisam estar com o mesmo conteЗdo.
			Return .F.
		Else
			lIntegRR1 := If(lIntRR1Car,.T.,.F.)
		EndIf
	ElseIf lTsRep .And. !lCaClockIn
		lIntegRR1 := If(lIntRR1Sur,.T.,.F.)
	ElseIf lCaClockIn .And. !lTsRep
		lIntegRR1 := If(lIntRR1Car,.T.,.F.)
	ElseIf SP0->P0_TIPOARQ == "R"
		lIntegRR1 := .T. 
	EndIf
EndIf

l671RR1MSA := If(l671RR1MSA == NIL, fValid671(If(lIntegRR1, 1, 2)), l671RR1MSA)

If SP0->P0_TIPOARQ == "R" .And. Empty(SP0->P0_REP)
	lRepCarol := .T.
	If !lIntegRR1
		lExtFilMsa	:= fVldMSAFil()
	EndIf
EndIf

If lPort1510 .and. !lTempF4
	cDataAux := DtoS(MsDate())
	cHoraAux := Time()
	cDtHrLi	 := SUBSTR(cDataAux,3,2) + SUBSTR(cDataAux,5,2) + SUBSTR(cDataAux,7,2) + SUBSTR(cHoraAux,1,2) + SUBSTR(cHoraAux,4,2) //-- AAMMDDHHMM
	nTamArq  := GetSx3Cache( "RFB_ARQ   "	, "X3_TAMANHO" )
EndIf

If lMemoCalc .And. !lTempF4
	GravaMCalc("01", 1, "-" + STR0064 + "(PONA030)") // "PrИ-Leitura"
EndIf

Begin Sequence
	
	IF !( lRet := ( cDataType $ "Dd_Tt_Rr_Cc" ) )
		Break
	EndIF
	
	If lTipoDoc
		cTipoDoc := If(IsMemVar("P0_TIPODOC"), GetMemVar("P0_TIPODOC"), SP0->P0_TIPODOC)
		cTipoDoc := If(Empty(cTipoDoc), "1", cTipoDoc)
		
		If cDataType == "C"
			nDocCol  := If(IsMemVar("P0_DOCCOL") , GetMemVar("P0_DOCCOL") , SP0->P0_DOCCOL)
			nRelCol  := If(IsMemVar("P0_RELCOL") , GetMemVar("P0_RELCOL") , SP0->P0_RELCOL)
			nDataCol := If(IsMemVar("P0_DATACOL"), GetMemVar("P0_DATACOL"), SP0->P0_DATACOL)
			nHRsCol  := If(IsMemVar("P0_HRSCOL") , GetMemVar("P0_HRSCOL") , SP0->P0_HRSCOL)
			nCCCol   := If(IsMemVar("P0_CCCOL")  , GetMemVar("P0_CCCOL")  , SP0->P0_CCCOL)
			
			cTipoDT := If(IsMemVar("P0_TPDATA"), GetMemVar("P0_TPDATA"), SP0->P0_TPDATA)
			cSeparador := If(IsMemVar("P0_CHAR"), GetMemVar("P0_CHAR"), SP0->P0_CHAR)
		EndIf
	EndIf
	
	IF !Empty( IF( IsMemVar( "P0_CODFOR" ) , GetMemVar( "P0_CODFOR" ) , SP0->P0_CODFOR ) )
		cFormCra := AllTrim( StrTran( IF( IsMemVar( "P0_CODFOR" ) , GetMemVar( "P0_CODFOR" ) , SP0->P0_CODFOR ) , '"' , "'" ) )
	Else	
		nCraIni := IF( IsMemVar( "P0_CODINI" ) , GetMemVar( "P0_CODINI" ) , SP0->P0_CODINI )
		IF ( nCraIni > 0 )
			nCraFim := ( ( IF( IsMemVar( "P0_CODFIM" ) , GetMemVar( "P0_CODFIM" ) , SP0->P0_CODFIM ) - nCraIni ) + 1 )
		Else
			nCraFim := 0
		EndIF	
	EndIF
	
	IF !Empty( IF( IsMemVar( "P0_RELOFOR" ) , GetMemVar( "P0_RELOFOR" ) , SP0->P0_RELOFOR ) )
		cFormRel := AllTrim( StrTran( IF( IsMemVar( "P0_RELOFOR" ) , GetMemVar( "P0_RELOFOR" ) , SP0->P0_RELOFOR ) , '"' , "'" ) )
	Else	
		nRelIni := IF( IsMemVar( "P0_RELOINI" ) , GetMemVar( "P0_RELOINI" ) , SP0->P0_RELOINI ) 
		IF ( nRelIni > 0 )
			nRelFim := ( ( IF( IsMemVar( "P0_RELOFIM" ) , GetMemVar( "P0_RELOFIM" ) , SP0->P0_RELOFIM )  - nRelIni ) + 1 )
		Else
			nRelFim := 0
		EndIF	
	EndIF
	
	IF !Empty( IF( IsMemVar( "P0_FUNCFOR" ) , GetMemVar( "P0_FUNCFOR" ) , SP0->P0_FUNCFOR ) )
		cFormFun := AllTrim( StrTran( IF( IsMemVar( "P0_FUNCFOR" ) , GetMemVar( "P0_FUNCFOR" ) , SP0->P0_FUNCFOR )  , '"' , "'" ) )
	Else	
		nFunIni := IF( IsMemVar( "P0_FUNCINI" ) , GetMemVar( "P0_FUNCINI" ) , SP0->P0_FUNCINI )
		IF ( nFunIni > 0 )
			nFunFim := ( ( IF( IsMemVar( "P0_FUNCFIM" ) , GetMemVar( "P0_FUNCFIM" ) , SP0->P0_FUNCFIM ) - nFunIni ) + 1 )
		Else
			nFunFim := 0
		EndIF	
	EndIF
	
	IF !Empty( IF( IsMemVar( "P0_GIROFOR" ) , GetMemVar( "P0_GIROFOR" ) , SP0->P0_GIROFOR ) )
		cFormGir := AllTrim( StrTran( IF( IsMemVar( "P0_GIROFOR" ) , GetMemVar( "P0_GIROFOR" ) , SP0->P0_GIROFOR ) , '"' , "'" ) )
	Else	
		nGirIni := IF( IsMemVar( "P0_GIROINI" ) , GetMemVar( "P0_GIROINI" ) , SP0->P0_GIROINI )
		IF ( nGirIni > 0 )
			nGirFim := ( ( IF( IsMemVar( "P0_GIROFIM" ) , GetMemVar( "P0_GIROFIM" ) , SP0->P0_GIROFIM ) - nGirIni ) + 1 ) 
		Else
			nGirFim := 0
		EndIF	
	EndIF
	
	IF !Empty( IF( IsMemVar( "P0_CCFOR" ) , GetMemVar( "P0_CCFOR" ) , SP0->P0_CCFOR ) )
		cFormCcu := AllTrim( StrTran( IF( IsMemVar( "P0_CCFOR" ) , GetMemVar( "P0_CCFOR" ) , SP0->P0_CCFOR ) , '"' , "'" ) )
	Else	
		nCcuIni := IF( IsMemVar( "P0_CCINI" ) , GetMemVar( "P0_CCINI" ) , SP0->P0_CCINI )
		IF ( nCcuIni > 0 )
			nCcuFim := ( ( IF( IsMemVar( "P0_CCFIM" ) , GetMemVar( "P0_CCFIM" ) , SP0->P0_CCFIM ) - nCcuIni ) + 1 )
		Else
			nCcuFim := 0
		EndIF	
	EndIF
	
	IF !Empty( IF( IsMemVar( "P0_DIAFOR" ) , GetMemVar( "P0_DIAFOR" ) , SP0->P0_DIAFOR ) )
		cFormDia := AllTrim( StrTran( IF( IsMemVar( "P0_DIAFOR" ) , GetMemVar( "P0_DIAFOR" ) , SP0->P0_DIAFOR ) , '"' , "'" ) )
	Else	
		nDiaIni := IF( IsMemVar( "P0_DIAINI" ) , GetMemVar( "P0_DIAINI" ) , SP0->P0_DIAINI )
		IF ( nDiaIni > 0 )
			nDiaFim := ( ( IF( IsMemVar( "P0_DIAFIM" ) , GetMemVar( "P0_DIAFIM" ) , SP0->P0_DIAFIM ) - nDiaIni ) + 1 )
		Else
			nDiaFim := 0
		EndIF	
	EndIF
	
	IF !Empty( IF( IsMemVar( "P0_MESFOR" ) , GetMemVar( "P0_MESFOR" ) , SP0->P0_MESFOR ) )
		cFormMes := AllTrim( StrTran( IF( IsMemVar( "P0_MESFOR" ) , GetMemVar( "P0_MESFOR" ) , SP0->P0_MESFOR ) , '"' , "'" ) )
	Else	
		nMesIni := IF( IsMemVar( "P0_MESINI" ) , GetMemVar( "P0_MESINI" ) , SP0->P0_MESINI )
		IF ( nMesIni > 0 )
			nMesFim := ( ( IF( IsMemVar( "P0_MESFIM" ) , GetMemVar( "P0_MESFIM" ) , SP0->P0_MESFIM ) - nMesIni ) + 1 )
		Else
			nMesFim := 0
		EndIF	
	EndIF
	
	IF !Empty( IF( IsMemVar( "P0_ANOFOR" ) , GetMemVar( "P0_ANOFOR" ) , SP0->P0_ANOFOR ) )
		cFormAno := AllTrim( StrTran( IF( IsMemVar( "P0_ANOFOR" ) , GetMemVar( "P0_ANOFOR" ) , SP0->P0_ANOFOR ) , '"' , "'" ) )
	Else	
		nAnoIni := IF( IsMemVar( "P0_ANOINI" ) , GetMemVar( "P0_ANOINI" ) , SP0->P0_ANOINI )
		IF ( nAnoIni > 0 )
			nAnoFim := ( ( IF( IsMemVar( "P0_ANOFIM" ) , GetMemVar( "P0_ANOFIM" ) , SP0->P0_ANOFIM ) - nAnoIni ) + 1 ) 
		Else
			nAnoFim := 0
		EndIF	
	EndIF
	
	IF !Empty( IF( IsMemVar( "P0_HORAFOR" ) , GetMemVar( "P0_HORAFOR" ) , SP0->P0_HORAFOR ) )
		cFormHrs := AllTrim( StrTran( IF( IsMemVar( "P0_HORAFOR" ) , GetMemVar( "P0_HORAFOR" ) , SP0->P0_HORAFOR ) , '"' , "'" ) )
	Else	
		nHrsIni := IF( IsMemVar( "P0_HORAINI" ) , GetMemVar( "P0_HORAINI" ) , SP0->P0_HORAINI )
		IF ( nHrsIni > 0 )
			nHrsFim := ( ( IF( IsMemVar( "P0_HORAFIM" ) , GetMemVar( "P0_HORAFIM" ) , SP0->P0_HORAFIM ) - nHrsIni ) + 1 )
		Else
			nHrsFim := 0
		EndIF	
	EndIF
	
	IF !Empty( IF( IsMemVar( "P0_MINUFOR" ) , GetMemVar( "P0_MINUFOR" ) , SP0->P0_MINUFOR ) )
		cFormMin := AllTrim( StrTran( IF( IsMemVar( "P0_MINUFOR" ) , GetMemVar( "P0_MINUFOR" ) , SP0->P0_MINUFOR ) , '"' , "'" ) )
	Else	
		nMinIni := IF( IsMemVar( "P0_MINUINI" ) , GetMemVar( "P0_MINUINI" ) , SP0->P0_MINUINI )
		IF ( nMinIni > 0 )
			nMinFim := ( ( IF( IsMemVar( "P0_MINUFIM" ) , GetMemVar( "P0_MINUFIM" ) , SP0->P0_MINUFIM ) - nMinIni ) + 1 )
		Else
			nMinFim := 0
		EndIF	
	EndIF
	
	//Seta layout pre definidos para relogio REP
	If lCaClockIn .And. (Empty(SP0->P0_REP) .And. SP0->P0_TIPOARQ == "R")
		lREP := ( !Empty(cNumRep := cConec) ) 
	ElseIf lPort1510 
		lREP := ( !Empty(cNumRep := SP0->P0_REP) ) //.And. SP0->P0_NOVO == "1" )
	EndIf
	
	If !lSP0TPREP .Or. (lSP0TPREP .And. Empty(SP0->P0_TPREP))
		cTipoREP := "1"
	Else
		If SP0->P0_TPREP $ "2*3*4"
			If fValid671()
				cTipoREP := SP0->P0_TPREP
			Else
				cMsg := STR0054 + SP0->P0_RELOGIO + STR0055 + CRLF + STR0056 + CRLF + STR0057
				aAdd(aLogFile, OemToAnsi(cMsg))
				Break
			EndIf
		Else
			cTipoREP := "1"
		EndIf
	EndIf
	
	If ( lRep .And. ( IsInCallStack("PONM010") .Or. ltempf4 ) )
		If cTipoREP == "1"
			nCraIni 	:= 23 ; nCraFim 	:= 12
			nDiaIni		:= 11 ; nDiaFim		:= 2
			nMesIni 	:= 13 ; nMesFim		:= 2
			nAnoIni		:= 15 ; nAnoFim		:= 4
			nHrsIni		:= 19 ; nHrsFim		:= 2
			nMinIni		:= 21 ; nMinFim		:= 2
		ElseIf cTipoREP $ "2*3"
			nTpRegIni	:= 10 ; nTpRegFim	:= 1
			nAnoIni		:= 11 ; nAnoFim		:= 4
			nMesIni 	:= 16 ; nMesFim		:= 2
			nDiaIni		:= 19 ; nDiaFim		:= 2
			nHrsIni		:= 22 ; nHrsFim		:= 2
			nMinIni		:= 25 ; nMinFim		:= 2
			nCraIni 	:= 35 ; nCraFim 	:= 12
			nCRCIni 	:= 47 ; nCRCFim 	:= 4
		ElseIf cTipoREP == "4"
			nTpRegIni	:= 10 ; nTpRegFim	:= 1
			nAnoIni		:= 11 ; nAnoFim		:= 4
			nMesIni 	:= 16 ; nMesFim		:= 2
			nDiaIni		:= 19 ; nDiaFim		:= 2
			nHrsIni		:= 22 ; nHrsFim		:= 2
			nMinIni		:= 25 ; nMinFim		:= 2
			nCraIni 	:= 35 ; nCraFim 	:= 12
			nDtGMarIni	:= 47 ; nDtGMarFim	:= 24
			nTpDispIni 	:= 71 ; nTpDispFim 	:= 2
			nMrcOnIni 	:= 73 ; nMrcOnFim 	:= 1
			nSRH256Ini 	:= 74 ; nSRH256Fim 	:= 64
		EndIf
	EndIf
	
	SetMemVar( "TXT" , "" , .T. )
	SetMemVar( "cErrSp0GetInf" , "" , .T. )
	
	If lPort1510 .and. !lTempF4
		
		If lREP
			cDataAux    := DtoS(Date())
			cHoraAux	:= Time()
			cDtHrG 		:= SUBSTR(cDataAux,3,2) + SUBSTR(cDataAux,5,2) + SUBSTR(cDataAux,7,2) + SUBSTR(cHoraAux,1,2) + SUBSTR(cHoraAux,4,2) //-- AAMMDDHHMM
			cKeySeek    := ( SP0->P0_FILIAL + PADR(cArquivo,nTamArq) + cDtHrG )
		Else
			aInfoFile	 := Directory( cDataName )
			If ( !( ValType(aInfoFile) == "A" ) .or. ( Empty(aInfoFile) ) ) //--Arquivo nao existe.
				lRet := .F. 
				Break
			EndIf
			cDataAux    := DtoS(aInfoFile[1,3])
			cHoraAux	:= aInfoFile[1,4]
			cDtHrG 		:= SUBSTR(cDataAux,3,2) + SUBSTR(cDataAux,5,2) + SUBSTR(cDataAux,7,2) + SUBSTR(cHoraAux,1,2) + SUBSTR(cHoraAux,4,2) //-- AAMMDDHHMM
			cKeySeek    := ( SP0->P0_FILIAL + PADR(cArquivo,nTamArq) + cDtHrG )
		Endif
		
		RFB->(DbsetOrder(RetOrder("RFB","RFB_FILIAL+RFB_ARQ+RFB_DTHRG+RFB_DTHRLI")))
		If ( RFB->( DbSeek(cKeySeek) ) )
			While RFB->( !Eof() .and. ( cKeySeek == ( RFB_FILIAL + RFB_ARQ + RFB_DTHRG ) ) )
				nGuardLin := Val(RFB->RFB_IDORG)
				cKeyAux := RFB->RFB_RELOGI+RFB->RFB_NUMREP+RFB->RFB_DTHRG
				RFB->( dbSkip() )
			End While
			If nGuardLin > 0
				cKeyAux := SP0->P0_FILIAL+cKeyAux
			EndIf
	   	ElseIf SP0->P0_INC == "1" .And. ( !lREP .or. cDataType <> "R" )  //--Arquivo incremental
			lIncremental := .T.
			cKeySeek    := ( SP0->P0_FILIAL + PADR(cArquivo,nTamArq) )
			If ( RFB->( DbSeek(cKeySeek) ) )
				While RFB->( !Eof() .and. ( cKeySeek == ( RFB_FILIAL + RFB_ARQ ) ) )
					nGuardLin := Val(RFB->RFB_IDORG)
					cKeyAux := RFB->RFB_RELOGI+RFB->RFB_NUMREP+RFB->RFB_DTHRG
					RFB->( dbSkip() )
				End While
				If nGuardLin > 0
					cKeyAux := SP0->P0_FILIAL+cKeyAux
				EndIf
			ElseIf !Empty(SP0->P0_REP) // Caso nЦo encontre o txt busca pelo nЗmero do REP 
				RFB->(dbSetOrder(1)) // RFB_FILIAL + RFB_RELOGI + RFB_NUMREP + RFB_DTHRLI
				cKeySeek := SP0->(P0_FILIAL + P0_RELOGIO + SP0->P0_REP)
				If RFB->(DbSeek(cKeySeek)) 
					While RFB->( !Eof() .And. cKeySeek == RFB_FILIAL + RFB_RELOGI + RFB_NUMREP)
						nGuardLin := Val(RFB->RFB_IDORG)
						cKeyAux := RFB->(RFB_RELOGI + RFB_NUMREP + RFB_DTHRG)
						RFB->(dbSkip())
					EndDo
					If nGuardLin > 0
						cKeyAux := SP0->P0_FILIAL + cKeyAux
					EndIf
				EndIf
			EndIf
		EndIF
		
		IF RecLock( 'RFB' , .T. )
			RFB->RFB_FILIAL  := SP0->P0_FILIAL
			RFB->RFB_ORIG    := cFilSP0 
			RFB->RFB_RELOGI  := SP0->P0_RELOGIO
			RFB->RFB_NUMREP  := cNumRep
			RFB->RFB_DTHRLI  := cDtHrLi
			RFB->RFB_ARQ     := PADR(cArquivo,nTamArq)
			RFB->RFB_TIPARQ  := If(cDataType=="T","1","2")
			RFB->RFB_DTHRG   := cDtHrG
			If nGuardLin > 0 //Se arquivo ja foi lido, deixa registrada ultima linha
				RFB->RFB_IDORG   := StrZero(nGuardLin, Len(RFB->RFB_IDORG) )
			EndIf
			RFB->RFB_ORIGEM  := If(lWorkFlow,"2","1")
			RFB->RFB_USUARI := __cUserId
			RFB->( MsUnLock() )
			
			If lMemoCalc .And. !lTempF4
				GravaMCalc("01", 2, STR0065 + StrZero(nGuardLin, Len(RFB->RFB_IDORG))) // "NSR Inicial: "
				GravaMCalc("01", 2, STR0066) // "Registro incluМdo na RFB"
			EndIf
			
		EndIf
		
		cKeySeek := SP0->P0_FILIAL + RFB->RFB_ARQ + RFB->RFB_DTHRG + RFB->RFB_DTHRLI
	EndIf
	
	IF ( cDataType == "T" )
		
		If lTempF4 .or. !lPort1510
			cDbfAlias := "__TMPRELOG" 
			TxtAliasClose( cDbfAlias )
		Else	
			cDbfAlias := "RFE"
		EndIf
		
		fT_fUse( cDataName )
		fT_fGotop()
		
		lRet := !( fT_fEof() )
		IF !( lRet )
			Break
		EndIF
		
		//Validacao para verificar se o numero de registros de tipo 3 no TXT
		//eh o mesmo informado no totalizador
		
		If !lTempF4 .And. lPort1510 .And. lREP
			
			nRegsLinTxt := 0
			While ( !fT_fEof() )
				
				M->TXT	:= fT_fReadLn()
				
				If cTipoREP $ "1*2*3"
					If Sp0GetInfo( M->TXT , Nil  , 10 , 1 ) == "3"
						nRegsLinTxt++
					ElseIf Sp0GetInfo( M->TXT , Nil  , 1 , 9 ) == "999999999"
						nRegsTot := Val( Sp0GetInfo( M->TXT , Nil  , 19 , 9 ) )
						exit
					EndIf
					fT_fSkip()
					Loop
				ElseIf cTipoREP == "4"
					If Sp0GetInfo( M->TXT , Nil  , 10 , 1 ) == "7"
						nRegsLinTxt++
					ElseIf Sp0GetInfo( M->TXT , Nil  , 1 , 9 ) == "999999999"
						nRegsTot := Val( Sp0GetInfo( M->TXT , Nil  , 55 , 9 ) )
						exit
					EndIf
					fT_fSkip()
					Loop
				EndIf
				
			EndDo
			
			If ( lRet := ( nRegsLinTxt == nRegsTot ) )
				fT_fGotop()
			Else
				//"Arquivo (Nome do Arquivo) possui nЗmero de marcaГУes divergentes do totalizador".
				aAdd( aLogFile , STR0020 + " " + cArquivo + " " + OemToAnsi(STR0031) )	
				Break
			EndIf
		
		EndIf
		
		While ( !fT_fEof() )
			
			M->TXT				:= fT_fReadLn()
			M->cErrSp0GetInf	:= ""
			
			If lPort1510 .And. lREP
				//-- O tipo do registro deve ser 3 (marcacao do funcionario)
				If cTipoREP $ "1*2*3"
					If !Sp0GetInfo( M->TXT , Nil  , 10 , 1 ) == "3"
						fT_fSkip()
						Loop
					EndIf
				ElseIf cTipoREP == "4"
					If !Sp0GetInfo( M->TXT , Nil  , 10 , 1 ) == "7"
						fT_fSkip()
						Loop
					EndIf
				EndIf
			EndIf
			
			cCracha := Sp0GetInfo( M->TXT, cFormCra, nCraIni, nCraFim)
			
			If lTipoDoc
				If(cTipoDoc == "2", cCPF := cCracha, If(cTipoDoc == "3", cPIS := cCracha, NIL))
			EndIf
			
			If lREP
				If cTipoREP == "1"
					
					// Por "padrЦo" na portaria 1510 И enviado o PIS com tamanho 12
					cPIS := AllTrim(Sp0GetInfo( M->TXT, Nil, nCraIni, nCraFim ))
					
					If Len(cPIS) == 11 // Enviou com um espaГo no fim
						cPIS := PadL( cPIS, 12, "0" )
					ElseIf Len(cPIS) == 12 .And. lCpos671 // AlteraГЦo da portaria 671 que passa a ser possМvel enviar o CPF
						cTipoDado := Left(cPIS, 1)
						
						If cTipoDado == "9" // CPF completo apСs o 9
							cCPF := Right(cPis, 11)
							cPis := ""
						ElseIf cTipoDado == "8" // 10 primeiros nЗmeros do CPF apСs o 8 
							cCPF := SubStr(cPis, 2, 10) + fGetNumCPF(SubStr(cPis, 2, 10))
							cPis := ""
						EndIf 
					EndIf
				ElseIf cTipoREP $ "2*3*4"
					cCPF := AllTrim(Sp0GetInfo( M->TXT, Nil, nCraIni, nCraFim ))
					If Len(cCPF) == 12 .And. SubStr(cCPF, 1, 1) == "0" // Enviou com um 0 no comeГo
						cCPF := Right(cCPF, 11)
					EndIf
				EndIf
			EndIf
			
			If (!lREP .And. !lTipoDoc .And. Empty(cCracha)) .Or. (lREP .And. Empty(cCPF) .And. Empty(cPIS)) .Or. (Empty(cCracha) .And. Empty(cCPF) .And. Empty(cPIS))
				M->cErrSp0GetInf := "ERRO"
			EndIF
			
			If !lPort1510 .Or. !lREP
				cCodRel := Sp0GetInfo( M->TXT , cFormRel , nRelIni , nRelFim )
			Else
				cCodRel := SP0->P0_RELOGIO
			EndIf
			cFuncao := Sp0GetInfo( M->TXT , cFormFun , nFunIni , nFunFim )
			cGiro   := Sp0GetInfo( M->TXT , cFormGir , nGirIni , nGirFim )
			cCusto  := Sp0GetInfo( M->TXT , cFormCcu , nCcuIni , nCcuFim )
			cDia	:= Sp0GetInfo( M->TXT , cFormDia , nDiaIni , nDiaFim )
			cMes	:= Sp0GetInfo( M->TXT , cFormMes , nMesIni , nMesFim )
			cAno	:= Sp0GetInfo( M->TXT , cFormAno , nAnoIni , nAnoFim )
			cHrs	:= Sp0GetInfo( M->TXT , cFormHrs , nHrsIni , nHrsFim )
			cMin	:= Sp0GetInfo( M->TXT , cFormMin , nMinIni , nMinFim )
			
			IF ( M->cErrSp0GetInf <> "ERRO" )
				cData := ( cDia + "/" + cMes + "/" + cAno )
				IF Empty( Ctod( cData , "DDMMYYYY" ) )
					M->cErrSp0GetInf := "ERRO"
				EndIF
			EndIF
            
			IF ( lRet := ( M->cErrSp0GetInf <> "ERRO" ) )
				
				If lTempF4 .or. !lPort1510
					
					nCracha := Max( 1 , Len( cCracha ) )
					nCodRel := Max( 1 , Len( cCodRel ) )
					nFuncao := Max( 1 , Len( cFuncao ) )
					nGiro   := Max( 1 , Len( cGiro   ) )
					nCusto  := Max( 1 , Len( cCusto  ) )
					
					cExt	:= GetDbExtension()
					
					aFieldsSize := {}
					aAdd( aFieldsSize , { nCracha	, 0 } )
					aAdd( aFieldsSize , { 8 		, 0 } )
					aAdd( aFieldsSize , { 5			, 2 } )
					aAdd( aFieldsSize , { nCodRel	, 0 } )
					aAdd( aFieldsSize , { nFuncao	, 0 } )
					aAdd( aFieldsSize , { nGiro		, 0 } )
					aAdd( aFieldsSize , { nCusto	, 0 } )
					
					aFields	:= GetFields( aFieldsSize )
					
					AAdd(aLstIndices, {"CRACHA","DDATE","HORA"} )
					
					oTmpTabFO1:= RhCriaTrab(cDbfAlias, aFields, aLstIndices)
					
				Else
					//Alterado para utilizar tabela de transferencia RFE
					dbSelectArea(cDbfAlias)
					nLinha := 0
				EndIf
				
				fT_fGotop()
				While ( !fT_fEof() )
					
					M->TXT	:= fT_fReadLn()
					
					//Tipo do registro. Se for REP-A, REP-C ou 1510, tipo do registro precisa ser 3, se for REP-P precisa ser 7
					If ( Len(M->TXT) <= 1 ) .Or. (lREP .And. (cTipoREP $ "1*2*3" .And. !Sp0GetInfo( M->TXT , Nil , 10 , 1 ) == "3") .Or. (cTipoREP $ "4" .And. !Sp0GetInfo( M->TXT , Nil , 10 , 1 ) == "7"))
						fT_fSkip()
						Loop
					EndIF
					
					If !lPort1510 .Or. !lREP
						cCracha := Sp0GetInfo(M->TXT, cFormCra, nCraIni, nCraFim)
						If lTipoDoc
							If(cTipoDoc == "2", cCPF := cCracha, If(cTipoDoc == "3", cPIS := cCracha, NIL))
						EndIf
					Else
						If cTipoREP == "1"
							
							// Por "padrЦo" na portaria 1510 И enviado o PIS com tamanho 12
							cPIS := AllTrim(Sp0GetInfo( M->TXT, Nil, nCraIni, nCraFim ))
							
							If Len(cPIS) == 11 // Eviou com um espaГo no fim
								cPIS := PadL( cPIS, 12, "0" )
							ElseIf Len(cPIS) == 12 .And. lCpos671 // AlteraГЦo da portaria 671 que passa a ser possМvel enviar o CPF
								cTipoDado := Left(cPIS, 1)
								
								If cTipoDado == "9" // CPF completo apСs o 9
									cCPF := Right(cPis, 11)
									cPis := ""
								ElseIf cTipoDado == "8" // 10 primeiros nЗmeros do CPF apСs o 8 
									cCPF := SubStr(cPis, 2, 10) + fGetNumCPF(SubStr(cPis, 2, 10))
									cPis := ""
								EndIf 
							EndIf
							
						ElseIf cTipoREP $ "2*3*4"
							cCPF := AllTrim(Sp0GetInfo( M->TXT, Nil, nCraIni, nCraFim ))
							If Len(cCPF) == 12 .And. SubStr(cCPF, 1, 1) == "0" // Enviou com um 0 no comeГo
								cCPF := Right(cCPF, 11)
							EndIf
						EndIf
					EndIf
					
					If !lPort1510 .Or. !lREP
						cCodRel := Sp0GetInfo( M->TXT , cFormRel , nRelIni , nRelFim )
					Else
						cCodRel := SP0->P0_RELOGIO
					EndIf
					
					cFuncao := Sp0GetInfo( M->TXT , cFormFun , nFunIni , nFunFim )
					cGiro   := Sp0GetInfo( M->TXT , cFormGir , nGirIni , nGirFim )
					cCusto  := Sp0GetInfo( M->TXT , cFormCcu , nCcuIni , nCcuFim )
					cDia	:= Sp0GetInfo( M->TXT , cFormDia , nDiaIni , nDiaFim )
					cMes	:= Sp0GetInfo( M->TXT , cFormMes , nMesIni , nMesFim )
					cAno	:= Sp0GetInfo( M->TXT , cFormAno , nAnoIni , nAnoFim )
					cHrs	:= Sp0GetInfo( M->TXT , cFormHrs , nHrsIni , nHrsFim )
					cMin	:= Sp0GetInfo( M->TXT , cFormMin , nMinIni , nMinFim )
					
					If lRep .And. cTipoREP $ "2*3"
						cTpReg	:= Sp0GetInfo(M->TXT, Nil, nTpRegIni, nTpRegFim)
						cCRC	:= Sp0GetInfo(M->TXT, Nil, nCRCIni, nCRCFim)
					ElseIf lRep .And. cTipoREP $ "4"
						cTpReg		:= Sp0GetInfo(M->TXT, Nil, nTpRegIni, nTpRegFim)
						cIdMarc		:= Sp0GetInfo(M->TXT, Nil, nTpDispIni, nTpDispFim)
						cMarcOn		:= Sp0GetInfo(M->TXT, Nil, nMrcOnIni, nMrcOnFim)
						cSRH256		:= Sp0GetInfo(M->TXT, Nil, nSRH256Ini, nSRH256Fim)
						cDtGvMarc	:= Sp0GetInfo(M->TXT, Nil, nDtGMarIni, nDtGMarFim)
					EndIf 
					
					cData	:= ( cDia + "/" + cMes + "/" + cAno )
                    dData   :=  Ctod( cData , "DDMMYYYY" )
                    
					IF ( M->cErrSp0GetInf == "ERRO" )
						M->cErrSp0GetInf := ""
						fT_fSkip() 
						Loop
					EndIF
                    
					If lPort1510 .and. !lTempF4
						If !lREP
							nLinha ++
						Else
							If isnumeric(Sp0GetInfo( M->TXT , NIL , 1 , 9 ))
								nLinha := Val( Sp0GetInfo( M->TXT , NIL , 1 , 9 ) )//N.S.R.
							Else
								nLinha ++
							EndIf
						EndIf
						
						If nLinha <= nGuardLin// .And. dData >= dPerIni .And. dData <= dPerFim
							RFE->(DbsetOrder(RetOrder("RFE","RFE_FILIAL+RFE_RELSP0+RFE_NUMREP+RFE_DTHRG+RFE_IDORG")))
							If ( RFE->( DbSeek(cKeyAux + STRZero(nLinha,Len(RFE->RFE_IDORG) ) ) ) )
								If RFE->RFE_DATA == dData .and. RFE->RFE_HORA == Val( ( cHrs + "." + cMin ) )
									fT_fSkip()
									Loop //Arquivo ja lido
								Else
									If Val(cPonDiv) > 0 
										/*******************************************************
										/ - Exibir as divergЙncias encontradas na quantidade
										/ - estipulada pelo parБmetro MV_PONDIV.
										/*******************************************************/
										If aScan( aLogFile, { |x| x == STR0020 + " " + cArquivo + " " + 'com marcaГУes divergentes: ' } ) == 0
											aAdd( aLogFile , STR0020 + " " + cArquivo + " " + STR0044 )
										EndIf
										
										lRet := .F.
										
										nContDiv++
										
										If nContDiv > Val(cPonDiv)
											Break
										EndIf
										
										cIdOrg	:= StrZero(nLinha, Len(RFE->RFE_IDORG) )
										
										/************************************
										/ - Exibir o Log de forma completa.
										/************************************/
										aAdd( aLogFile , " . NSR: " + cIdOrg + " | RFE -> Data: " + dToC( RFE->RFE_DATA ) + " Hora: " + STR(RFE->RFE_HORA,5,2) + " | TXT -> Data: " + dToC(dData) + " Hora: " + cHrs + "." + cMin)
										cIdOrg := ""
									ElseIf Val(cPondiv) == 0
									 	//"Arquivo (Nome do Arquivo) Com problema(s) de integridade.
										aAdd( aLogFile , STR0020 + " " + cArquivo + " " + STR0043 )
										lRet := .F.
										Break
									EndIf
									fT_fSkip()
									Loop //Arquivo ja lido
								EndIf
							ElseIf SP0->P0_INC == "1" .And. ( !lREP .or. cDataType <> "R" )  //--Arquivo incremental
								lIncremental := .T.
								fT_fSkip()
								Loop //Arquivo ja lido
							EndIF
						EndIf
						
						cDhOrg	:= cAno + cMes + cDia + cHrs + cMin //-- AAMMDDHHMM
						cIdOrg	:= StrZero(nLinha, Len(RFE->RFE_IDORG) )
						cLinha  := M->TXT
					EndIf
					
					If lVerPeriodo  
						If !((dData >= ( dPerIni - nDiasExtA )) .AND. ( dData <= (dPerAte + nDiasExtP )))
							If lMemoCalc .And. !lTempF4
								GravaMCalc("01", 2, STR0067 + STRZero(nLinha, len(RFE->RFE_IDORG)) + " | " + dToC(dData) + "-" + cHrs + ":" + cMin) // "MarcaГЦo: "
								GravaMCalc("01", 3, STR0068) // "MarcaГЦo fora do perМodo de leitura."
							EndIf
							fT_fSkip()
							LOOP
						Endif	
					EndIF					
					
					If lTempF4 .or. !lPort1510
						( cDbfAlias )->( dbAppend( .T. ) )
						
						If !Empty(cPIS)
							cCracha := cPIS
						ElseIf !Empty(cCPF)
							cCracha := cCPF
						EndIf
						
						( cDbfAlias )->( CRACHA ) := cCracha
						( cDbfAlias )->( DDATE  ) := dData
						( cDbfAlias )->( HORA   ) := Val( ( cHrs + "." + cMin ) )
						( cDbfAlias )->( CODREL ) := cCodRel
						( cDbfAlias )->( FUNCAO ) := cFuncao
						( cDbfAlias )->( GIRO   ) := cGiro
						( cDbfAlias )->( CUSTO  ) := cCusto
					Else
						
						IF RecLock( cDbfAlias , .T. )
							If lCaClockIn .And. (Empty(SP0->P0_REP) .And. SP0->P0_TIPOARQ == "R")
								( cDbfAlias )->RFE_FILIAL 	:= cRAFilial
								( cDbfAlias )->RFE_ORIG 	:= cRAFilial
							Else
								( cDbfAlias )->RFE_FILIAL 	:= SP0->P0_FILIAL
								( cDbfAlias )->RFE_ORIG   	:= cFilSP0
							EndIf
							
							If !lREP .And. (!lTipoDoc .Or. (lTipoDoc .And. cTipoDoc == "1"))
								( cDbfAlias )->RFE_CRACHA := cCracha
							Else
								( cDbfAlias )->RFE_PIS := cPIS
							EndIf
							( cDbfAlias )->RFE_DATA   := dData
							( cDbfAlias )->RFE_HORA   := Val( ( cHrs + "." + cMin ) )
							( cDbfAlias )->RFE_CC     := cCusto
							( cDbfAlias )->RFE_RELOGI := cCodRel
							( cDbfAlias )->RFE_RELSP0 := SP0->P0_RELOGIO
							( cDbfAlias )->RFE_FUNCAO := cFuncao
							( cDbfAlias )->RFE_GIRO   := cGiro
							( cDbfAlias )->RFE_FLAG   := "0"
							( cDbfAlias )->RFE_NUMREP := cNumRep
							( cDbfAlias )->RFE_DTHRLI := cDtHrLi
							( cDbfAlias )->RFE_DTHRG  := cDtHrG
							( cDbfAlias )->RFE_EMPORG := cEmpAnt
							( cDbfAlias )->RFE_DHORG  := cDhOrg
							( cDbfAlias )->RFE_IDORG  := cIdOrg
							( cDbfAlias )->RFE_NATU   := "3"
							( cDbfAlias )->RFE_LINHA  := cLinha
							
							If !Empty(cCPF) .And. lCpos671
								( cDbfAlias )->RFE_CPF		:= cCPF
							EndIf
							
							If lREP .And. cTipoREP $ "2*3"
								( cDbfAlias )->RFE_TPREG	:= cTpReg
								( cDbfAlias )->RFE_CRC		:= cCRC
							ElseIf lREP .And.  cTipoREP $ "4"
								( cDbfAlias )->RFE_TPREG	:= cTpReg
								( cDbfAlias )->RFE_DTGVMA	:= cDtGvMarc
								( cDbfAlias )->RFE_IDMARC	:= cIdMarc
								( cDbfAlias )->RFE_MARCON	:= cMarcOn
								( cDbfAlias )->RFE_SRH256	:= cSRH256
							EndIf
							
							( cDbfAlias )->( MsUnLock() )
							lGrvRFE := .T.
							cLastIdOrg := cIdOrg
							
							If lMemoCalc .And. !lTempF4
								GravaMCalc("01", 2, STR0067 + STRZero(nLinha, len(RFE->RFE_IDORG)) + " | " + dToC(dData) + "-" + cHrs + ":" + cMin) // "MarcaГЦo: "
								GravaMCalc("01", 3, STR0069) // "MarcaГЦo gravada na RFE"
								// "Data: " - "Hora: " - "CrachА: "
								GravaMCalc("01", 4, "NSR: " + cIdOrg + " | " + STR0070 + dToC(dData) + " | " + STR0071 + cHrs + ":" + cMin + " | PIS: " + If(!Empty(cPIS), cPis, " ") + " | CPF: " + If(!Empty(cCPF), cCPF, " ") + " | " + STR0072 + If( !lREP .And. !Empty(cCracha), cCracha, " "))
							EndIf
							
						EndIF
					EndIf
					
					cCPF := ""
					cPIS := ""
					
					fT_fSkip()
					
				EndDo
				
				// Gravar na RFB depois que tiver gravado tudo na RFE
				If lGrvRFE
					RFB->(DbsetOrder(RetOrder("RFB","RFB_FILIAL+RFB_ARQ+RFB_DTHRG+RFB_DTHRLI")))
					If ( RFB->( DbSeek(cKeySeek) ) )
						IF RecLock( 'RFB' , .F. )
							RFB->RFB_IDORG := cLastIdOrg
							RFB->( MsUnLock() )
							If lMemoCalc .And. !lTempF4
								GravaMCalc("01", 2, STR0073) // "Registro atualizado na RFB"
								GravaMCalc("01", 2, STR0074 + cLastIdOrg) // "зltimo NSR Lido: "
							EndIf
						EndIF		
					EndIF
				EndIF
				
			EndIF
			
			IF ( lRet )
				Exit
			EndIF
			
			fT_fSkip()
			
		EndDo
		
		fT_fUse()
		
	ElseIF ( cDataType == "D" )
		If lTempF4 .or. !lPort1510
			cDbfAlias	:= "__TMPRELOG"
		Else
			cDbfAlias	:= "RFE"
		EndIf
		
		nFields		:= ( cTxtAlias )->( fCount() )
		
		( cTxtAlias )->( dbGotop() )
		
		lRet := ( cTxtAlias )->( !Eof() )
		IF !( lRet )
			Break
		EndIF
		
		While ( cTxtAlias )->( !Eof() )

			M->TXT				:= DbfGetData( cTxtAlias , nFields )
			M->cErrSp0GetInf	:= ""
			
			cCracha := Sp0GetInfo( M->TXT , cFormCra , nCraIni , nCraFim )
			IF Empty( cCracha ) 
				M->cErrSp0GetInf := "ERRO"
			EndIF

			cCodRel := Sp0GetInfo( M->TXT , cFormRel , nRelIni , nRelFim )
			cFuncao := Sp0GetInfo( M->TXT , cFormFun , nFunIni , nFunFim )
			cGiro   := Sp0GetInfo( M->TXT , cFormGir , nGirIni , nGirFim )
			cCusto  := Sp0GetInfo( M->TXT , cFormCcu , nCcuIni , nCcuFim )
			cDia	:= Sp0GetInfo( M->TXT , cFormDia , nDiaIni , nDiaFim )
			cMes	:= Sp0GetInfo( M->TXT , cFormMes , nMesIni , nMesFim )
			cAno	:= Sp0GetInfo( M->TXT , cFormAno , nAnoIni , nAnoFim )
			cHrs	:= Sp0GetInfo( M->TXT , cFormHrs , nHrsIni , nHrsFim )
			cMin	:= Sp0GetInfo( M->TXT , cFormMin , nMinIni , nMinFim )

			cData	:= ( cDia + "/" + cMes + "/" + cAno )
            dData   :=  Ctod( cData , "DDMMYYYY" )            

			IF ( M->cErrSp0GetInf <> "ERRO" )
				IF Empty( dData )
					M->cErrSp0GetInf := "ERRO"
				EndIF
			EndIF

			IF ( lRet := ( M->cErrSp0GetInf <> "ERRO" ) )
				
				nCracha := Max( 1 , Len( cCracha ) )
				nCodRel := Max( 1 , Len( cCodRel ) )
				nFuncao := Max( 1 , Len( cFuncao ) )
				nGiro   := Max( 1 , Len( cGiro   ) )
				nCusto  := Max( 1 , Len( cCusto  ) )

				cExt	:= GetDbExtension()

				aFieldsSize := {}
				aAdd( aFieldsSize , { nCracha	, 0 } )
				aAdd( aFieldsSize , { 8 		, 0 } )
				aAdd( aFieldsSize , { 5			, 2 } )
				aAdd( aFieldsSize , { nCodRel	, 0 } )
				aAdd( aFieldsSize , { nFuncao	, 0 } )
				aAdd( aFieldsSize , { nGiro		, 0 } )
				aAdd( aFieldsSize , { nCusto	, 0 } )

				aFields	:= GetFields( aFieldsSize )

				If lTempF4 .or. !lPort1510
					aLstIndices := {}
					AAdd(aLstIndices, {"CRACHA","DDATE","HORA"} )
					oTmpTabFO1:= RhCriaTrab(cDbfAlias, aFields, aLstIndices)
                 
				Else
					//Alterado para utilizar tabela de transferencia RFE
					dbSelectArea(cDbfAlias)
					nLinha := 0
				EndIf

				( cTxtAlias )->( dbGotop() )
				While ( cTxtAlias )->( !Eof() )

					M->TXT	:= DbfGetData( cTxtAlias , nFields )
					cCracha := Sp0GetInfo( M->TXT , cFormCra , nCraIni , nCraFim )
					cCodRel := Sp0GetInfo( M->TXT , cFormRel , nRelIni , nRelFim )
					cFuncao := Sp0GetInfo( M->TXT , cFormFun , nFunIni , nFunFim )
					cGiro   := Sp0GetInfo( M->TXT , cFormGir , nGirIni , nGirFim )
					cCusto  := Sp0GetInfo( M->TXT , cFormCcu , nCcuIni , nCcuFim )
					cDia	:= Sp0GetInfo( M->TXT , cFormDia , nDiaIni , nDiaFim )
					cMes	:= Sp0GetInfo( M->TXT , cFormMes , nMesIni , nMesFim )
					cAno	:= Sp0GetInfo( M->TXT , cFormAno , nAnoIni , nAnoFim )
					cHrs	:= Sp0GetInfo( M->TXT , cFormHrs , nHrsIni , nHrsFim )
					cMin	:= Sp0GetInfo( M->TXT , cFormMin , nMinIni , nMinFim )

					cData	:= ( cDia + "/" + cMes + "/" + cAno )
					dData   :=  Ctod( cData , "DDMMYYYY" )
				
					IF ( M->cErrSp0GetInf == "ERRO" )
						M->cErrSp0GetInf := ""
						( cTxtAlias )->( dbSkip() )
						Loop
					EndIF
					
					If lVerPeriodo  
					    If !( ( dData >= ( dPerIni - nDiasExtA ) )  .AND. ( dData <= (dPerAte + nDiasExtP ) ) )
							( cTxtAlias )->( dbSkip() )
							Loop
						Endif	
					EndIF	

					If lPort1510 .and. !lTempF4
					
						nLinha ++	
						
						If nLinha <= nGuardLin .And. dData >= dPerIni .And. dData <= dPerFim
							RFE->(DbsetOrder(RetOrder("RFE","RFE_FILIAL+RFE_RELSP0+RFE_NUMREP+RFE_DTHRG+RFE_IDORG")))
							If ( RFE->( DbSeek(cKeyAux + STRZero(nLinha,len(RFE_IDORG) ) ) ) ) 
								If RFE->RFE_DATA == dData .and. RFE->RFE_HORA == Val( ( cHrs + "." + cMin ) )
									( cTxtAlias )->( dbSkip() )
									Loop //Arquivo ja lido
								Else
									//"Arquivo (Nome do Arquivo) corrompido.
									aAdd( aLogFile , STR0020 + " " + cArquivo + " " + STR0021 )
									lRet := .F.
									Break
								EndIf
						    ElseIf SP0->P0_INC == "1" .And. ( !lREP .or. cDataType <> "R" )  //--Arquivo incremental
								lIncremental := .T.
								( cTxtAlias )->( dbSkip() )
								Loop //Arquivo ja lido
							EndIF
						EndIf
		
						cDhOrg	:= cAno + cMes + cDia + cHrs + cMin //-- AAMMDDHHMM
						cIdOrg	:= STRZero(nLinha, Len(RFE->RFE_IDORG) )
						cLinha  := M->TXT
					EndIf

					If lTempF4 .or. !lPort1510
						( cDbfAlias )->( dbAppend( .T. ) )
						( cDbfAlias )->( CRACHA ) := cCracha
						( cDbfAlias )->( DDATE  ) := dData
						( cDbfAlias )->( HORA   ) := Val( ( cHrs + "." + cMin ) )
						( cDbfAlias )->( CUSTO  ) := cCusto
						( cDbfAlias )->( CODREL ) := cCodRel
						( cDbfAlias )->( FUNCAO ) := cFuncao
						( cDbfAlias )->( GIRO   ) := cGiro
					Else
	
						IF RecLock( cDbfAlias , .T. )					
							If lCaClockIn .And. (Empty(SP0->P0_REP) .And. SP0->P0_TIPOARQ == "R")
								( cDbfAlias )->RFE_FILIAL := cRAFilial
								( cDbfAlias )->RFE_ORIG   := cRAFilial
							Else
								( cDbfAlias )->RFE_FILIAL := SP0->P0_FILIAL
								( cDbfAlias )->RFE_ORIG   := cFilSP0
							EndIf
							
							( cDbfAlias )->RFE_CRACHA := cCracha
							( cDbfAlias )->RFE_DATA   := dData
							( cDbfAlias )->RFE_HORA   := Val( ( cHrs + "." + cMin ) )
							( cDbfAlias )->RFE_CC     := cCusto
							( cDbfAlias )->RFE_RELOGI := cCodRel
							( cDbfAlias )->RFE_RELSP0 := SP0->P0_RELOGIO
							( cDbfAlias )->RFE_FUNCAO := cFuncao
							( cDbfAlias )->RFE_GIRO   := cGiro
							( cDbfAlias )->RFE_FLAG	  := "0"
							( cDbfAlias )->RFE_NUMREP := cNumRep
							( cDbfAlias )->RFE_DTHRLI := cDtHrLi
							( cDbfAlias )->RFE_DTHRG  := cDtHrG
							( cDbfAlias )->RFE_EMPORG := cEmpAnt
							( cDbfAlias )->RFE_DHORG  := cDhOrg
							( cDbfAlias )->RFE_IDORG  := cIdOrg
							( cDbfAlias )->RFE_NATU   := "3"
							( cDbfAlias )->RFE_LINHA  := cLinha
	
							( cDbfAlias )->( MsUnLock() )
							If lPort1510
								RFB->(DbsetOrder(RetOrder("RFB","RFB_FILIAL+RFB_ARQ+RFB_DTHRG+RFB_DTHRLI")))
								If ( RFB->( DbSeek(cKeySeek) ) )
									IF RecLock( 'RFB' , .F. )
										RFB->RFB_IDORG   := cIdOrg
										RFB->( MsUnLock() )
									EndIF		
								EndIF
							EndIf
							
							lGrvRFE := .T.
						EndIF
	      			EndIF

					( cTxtAlias )->( dbSkip() )
	
				End While
			
			EndIF
			
			IF ( lRet )
				Exit
			EndIF
	
			( cTxtAlias )->( dbSkip() )
	
		End While
		( cTxtAlias )->( dbCloseArea() )
		
	ElseIf cDataType == "C" // CSV
		
		If lTempF4 .Or. !lPort1510
			cDbfAlias := "__TMPRELOG" 
			TxtAliasClose( cDbfAlias )
		Else	
			cDbfAlias := "RFE"
		EndIf
		
		fT_fUse(cDataName)
		fT_fGotop()
		
		While !fT_fEof()
			
			M->TXT				:= fT_fReadLn()
			M->cErrSp0GetInf	:= ""
			
			aLinha := StrTokArr2(M->TXT, cSeparador, .T.)
			
			cCracha := SP0GetCSV(aLinha, nDocCol)
			
			If lTipoDoc
				If(cTipoDoc == "2", cCPF := cCracha, If(cTipoDoc == "3", cPIS := cCracha, NIL))
			EndIf
			
			If Empty(cCracha) .And. Empty(cCPF) .And. Empty(cPIS)
				M->cErrSp0GetInf := "ERRO"
			EndIF
			
			cCodRel := SP0GetCSV(aLinha, nRelCol, cFormRel)
			cCusto  := SP0GetCSV(aLinha, nCCCol, cFormCcu)
			
			cDataAux := SP0GetCSV(aLinha, nDataCol)
			
			dData := formatData(cDataAux, cTipoDT, 1)
			
			If cTipoDT $ "345"
				cHoraAux := formatData(cDataAux, cTipoDT, 2)
			Else
				cHoraAux := SP0GetCSV(aLinha, nHRsCol)
			EndIf
			
			cHrs	:= formatHora(@cHoraAux, 1)
			cMin	:= formatHora(@cHoraAux, 2)
			
			If ( M->cErrSp0GetInf <> "ERRO" ) .And. Empty(dData)
				M->cErrSp0GetInf := "ERRO"
			EndIf
            
			If ( lRet := ( M->cErrSp0GetInf <> "ERRO" ) )
				
				cFuncao := ""
				cGiro := ""
				
				If lTempF4 .or. !lPort1510
					
					nCracha := Max(1, Len( cCracha ))
					nCodRel := Max(1, Len( cCodRel ))
					nFuncao := Max(1, Len( cFuncao ))
					nGiro   := Max(1, Len( cGiro   ))
					nCusto  := Max(1, Len( cCusto  ))
					
					cExt	:= GetDbExtension()
					
					aFieldsSize := {}
					aAdd( aFieldsSize , { nCracha	, 0 } )
					aAdd( aFieldsSize , { 8 		, 0 } )
					aAdd( aFieldsSize , { 5			, 2 } )
					aAdd( aFieldsSize , { nCodRel	, 0 } )
					aAdd( aFieldsSize , { nFuncao	, 0 } )
					aAdd( aFieldsSize , { nGiro		, 0 } )
					aAdd( aFieldsSize , { nCusto	, 0 } )
					
					aFields	:= GetFields( aFieldsSize )
					
					AAdd(aLstIndices, {"CRACHA", "DDATE", "HORA"} )
					
					oTmpTabFO1:= RhCriaTrab(cDbfAlias, aFields, aLstIndices)
					
				Else
					//Alterado para utilizar tabela de transferencia RFE
					dbSelectArea(cDbfAlias)
					nLinha := 0
				EndIf
				
				fT_fGotop()
				While !fT_fEof()
					
					M->TXT	:= fT_fReadLn()
					
					aLinha := StrTokArr2(M->TXT, cSeparador, .T.)
					
					If Len(M->TXT) <= 1
						fT_fSkip()
						LOOP
					EndIf
					
					cCracha := SP0GetCSV(aLinha, nDocCol)
					If lTipoDoc
						If(cTipoDoc == "2", cCPF := cCracha, If(cTipoDoc == "3", cPIS := cCracha, NIL))
					EndIf
					
					cCodRel := SP0GetCSV(aLinha, nRelCol, cFormRel)
					cCusto  := SP0GetCSV(aLinha, nCCCol, cFormCcu)
					
					cDataAux := SP0GetCSV(aLinha, nDataCol)
					
					dData := formatData(cDataAux, cTipoDT, 1)
					
					If cTipoDT $ "345"
						cHoraAux := formatData(cDataAux, cTipoDT, 2)
					Else
						cHoraAux := SP0GetCSV(aLinha, nHRsCol)
					EndIf
					
					cHrs	:= formatHora(@cHoraAux, 1)
					cMin	:= formatHora(@cHoraAux, 2)
					
					If ( M->cErrSp0GetInf <> "ERRO" ) .And. Empty(dData)
						M->cErrSp0GetInf := "ERRO"
					EndIf
					
					If M->cErrSp0GetInf == "ERRO"
						M->cErrSp0GetInf := ""
						fT_fSkip() 
						LOOP
					EndIf
                    
					If lPort1510 .and. !lTempF4
						
						nLinha ++
						
						If nLinha <= nGuardLin
							RFE->(DbsetOrder(RetOrder("RFE", "RFE_FILIAL+RFE_RELSP0+RFE_NUMREP+RFE_DTHRG+RFE_IDORG")))
							If RFE->( DbSeek(cKeyAux + STRZero(nLinha, Len(RFE->RFE_IDORG))))
								If RFE->RFE_DATA == dData .And. RFE->RFE_HORA == Val( ( cHrs + "." + cMin ) )
									fT_fSkip()
									LOOP //Arquivo ja lido
								Else
									If Val(cPonDiv) > 0 
										// Exibir as divergЙncias encontradas na quantidade estipulada pelo parБmetro MV_PONDIV.
										If aScan( aLogFile, { |x| x == STR0020 + " " + cArquivo + " " + 'com marcaГУes divergentes: ' } ) == 0
											aAdd( aLogFile, STR0020 + " " + cArquivo + " " + STR0044 )
										EndIf
										
										lRet := .F.
										
										nContDiv++
										
										If nContDiv > Val(cPonDiv)
											Break
										EndIf
										
										cIdOrg	:= StrZero(nLinha, Len(RFE->RFE_IDORG) )
										
										// Exibir o Log de forma completa.
										aAdd( aLogFile , " . NSR: " + cIdOrg + " | RFE -> Data: " + dToC( RFE->RFE_DATA ) + " Hora: " + STR(RFE->RFE_HORA,5,2) + " | TXT -> Data: " + dToC(dData) + " Hora: " + cHrs + "." + cMin)
										cIdOrg := ""
									ElseIf Val(cPondiv) == 0
									 	//"Arquivo (Nome do Arquivo) Com problema(s) de integridade.
										aAdd( aLogFile , STR0020 + " " + cArquivo + " " + STR0043 )
										lRet := .F.
										Break
									EndIf
									fT_fSkip()
									LOOP //Arquivo ja lido
								EndIf
							ElseIf SP0->P0_INC == "1" .And. ( !lREP .or. cDataType <> "R" )  //--Arquivo incremental
								lIncremental := .T.
								fT_fSkip()
								LOOP //Arquivo ja lido
							EndIf
						EndIf
						
						cDhOrg	:= dToS(dData) + cHrs + cMin //-- AAMMDDHHMM
						cIdOrg	:= StrZero(nLinha, Len(RFE->RFE_IDORG) )
						cLinha  := M->TXT
						
					EndIf
					
					If lVerPeriodo  
						If !((dData >= ( dPerIni - nDiasExtA )) .AND. ( dData <= (dPerAte + nDiasExtP )))
							If lMemoCalc .And. !lTempF4
								GravaMCalc("01", 2, STR0067 + STRZero(nLinha, len(RFE->RFE_IDORG)) + " | " + dToC(dData) + "-" + cHrs + ":" + cMin) // "MarcaГЦo: "
								GravaMCalc("01", 3, STR0068) // "MarcaГЦo fora do perМodo de leitura."
							EndIf
							fT_fSkip()
							LOOP
						Endif	
					EndIF					
					
					If lTempF4 .or. !lPort1510
						( cDbfAlias )->( dbAppend( .T. ) )
						
						If !Empty(cPIS)
							cCracha := cPIS
						ElseIf !Empty(cCPF)
							cCracha := cCPF
						EndIf
						
						( cDbfAlias )->( CRACHA ) := cCracha
						( cDbfAlias )->( DDATE  ) := dData
						( cDbfAlias )->( HORA   ) := Val( ( cHrs + "." + cMin ) )
						( cDbfAlias )->( CODREL ) := cCodRel
						( cDbfAlias )->( CUSTO  ) := cCusto
					Else
						
						IF RecLock( cDbfAlias , .T. )
							
							( cDbfAlias )->RFE_FILIAL 	:= SP0->P0_FILIAL
							( cDbfAlias )->RFE_ORIG   	:= cFilSP0
							
							If !lTipoDoc .Or. (lTipoDoc .And. cTipoDoc == "1")
								( cDbfAlias )->RFE_CRACHA := cCracha
							Else
								( cDbfAlias )->RFE_PIS := cPIS
							EndIf
							
							( cDbfAlias )->RFE_DATA   := dData
							( cDbfAlias )->RFE_HORA   := Val( ( cHrs + "." + cMin ) )
							( cDbfAlias )->RFE_CC     := cCusto
							( cDbfAlias )->RFE_RELOGI := cCodRel
							( cDbfAlias )->RFE_RELSP0 := SP0->P0_RELOGIO
							( cDbfAlias )->RFE_FLAG   := "0"
							( cDbfAlias )->RFE_NUMREP := cNumRep
							( cDbfAlias )->RFE_DTHRLI := cDtHrLi
							( cDbfAlias )->RFE_DTHRG  := cDtHrG
							( cDbfAlias )->RFE_EMPORG := cEmpAnt
							( cDbfAlias )->RFE_DHORG  := cDhOrg
							( cDbfAlias )->RFE_IDORG  := cIdOrg
							( cDbfAlias )->RFE_NATU   := "3"
							( cDbfAlias )->RFE_LINHA  := cLinha
							
							If !Empty(cCPF) .And. lCpos671
								( cDbfAlias )->RFE_CPF := cCPF
							EndIf
							
							(cDbfAlias)->( MsUnLock() )
							lGrvRFE := .T.
							cLastIdOrg := cIdOrg
							
							If lMemoCalc .And. !lTempF4
								GravaMCalc("01", 2, STR0067 + STRZero(nLinha, len(RFE->RFE_IDORG)) + " | " + dToC(dData) + "-" + cHrs + ":" + cMin) // "MarcaГЦo: "
								GravaMCalc("01", 3, STR0069) // "MarcaГЦo gravada na RFE"
								// "Data: " - "Hora: " - "CrachА: "
								GravaMCalc("01", 4, "NSR: " + cIdOrg + " | " + STR0070 + dToC(dData) + " | " + STR0071 + cHrs + ":" + cMin + " | PIS: " + If(!Empty(cPIS), cPis, " ") + " | CPF: " + If(!Empty(cCPF), cCPF, " ") + " | " + STR0072 + If( !lREP .And. !Empty(cCracha), cCracha, " "))
							EndIf
						EndIf
					EndIf
					
					cCPF := ""
					cPIS := ""
					
					fT_fSkip()
					
				EndDo
				
				// Gravar na RFB depois que tiver gravado tudo na RFE
				If lGrvRFE
					RFB->(DbsetOrder(RetOrder("RFB", "RFB_FILIAL+RFB_ARQ+RFB_DTHRG+RFB_DTHRLI")))
					If ( RFB->( DbSeek(cKeySeek) ) )
						IF RecLock( 'RFB' , .F. )
							RFB->RFB_IDORG := cLastIdOrg
							RFB->( MsUnLock() )
							If lMemoCalc .And. !lTempF4
								GravaMCalc("01", 2, STR0073) // "Registro atualizado na RFB"
								GravaMCalc("01", 2, STR0074 + cLastIdOrg) // "зltimo NSR Lido: "
							EndIf
						EndIf
					EndIf
				EndIf
			EndIf
			
			If ( lRet )
				Exit
			EndIf
			
			fT_fSkip()
			
		EndDo
		
		fT_fUse()
		
	Else	// TSREP
		
		// Exemplo do calculo para identificar o horario da marcacao originado do aplicado TSA - conceito definido 28/07/11
		//MarcaГЦo aconteuceu as 16:35:30
		//
		//num_horar_marcac_aces = 59730
		//num_horar_marcac_aces/3600
		//resto * 60
		//o resto И segundo
		//--------------------------
		//
		//59730/3600 = 16,59166666666667
		//hora = 16
		//Resto (0,59166666666667) * 60 = 35,5
		//Minuto = 35
		//Resto (0,5) * 60 = 30
		//Segundos = 30
		
        If lTemRR1 .Or. TCSQLExec("Select * FROM " + cTabInteg) >= 0
			
			If lIntegRR1
				dbSelectArea("RR1")
				If !fMigrRR1()
					Help(,, 'HELP',, STR0045, 1, 0 ) //"Erro na migraГЦo dos registros da tabela MSA_CONTROL_MARCAC para a tabela RR1. SerА necessАrio reinicializar a tabela RR1 e reiniciar o processo. A integraГЦo serА abortada"
					lRet := .F.
					Break
				EndIf
			EndIf			
			
			If !lIntegRR1
				If cSGBD $ "ORACLE*POSTGRES"
					cSelect		:= "COD_PIS_MSA,to_char(DAT_MARCAC_ACES, 'yyyymmdd') as DATA_MARC,NUM_HORAR_MARCAC_ACES AS NUM_HORA,COD_REP,COD_NSR,COD_USUAR_EXT_CHAVE,VAL_CONTROL_MARCAC AS RECNO"
				Else
					cSelect		:= "COD_PIS_MSA,CONVERT(VARCHAR,DAT_MARCAC_ACES,126) AS DATA_MARC,NUM_HORAR_MARCAC_ACES AS NUM_HORA,COD_REP,COD_NSR,COD_USUAR_EXT_CHAVE,VAL_CONTROL_MARCAC AS RECNO"
				Endif
				If l671RR1MSA
					cSelect += ", COD_CPF_FUNC, COD_FUSO, COD_CCT AS COD_CCT "
				EndIf 
				If lExtFilMsa
					cSelect += ", COD_FIL_MARC "
				EndIf 
				cSelect += ", COD_UNID_EXT_CHAVE, COD_FUNC_MSA, COD_INSCR_EMP "
			Else
				cSelect			:= "RR1_CODPIS as COD_PIS_MSA,RR1_DATMAR as DATA_MARC,RR1_NUMMAR AS NUM_HORA,RR1_CODREP as COD_REP,RR1_CODNSR as COD_NSR,RR1_CODUSU as COD_USUAR_EXT_CHAVE,RR1_VALCON AS RECNO"
				If lGeoFence
					cSelect += ", RR1_LATITU, RR1_LONGIT, RR1_GEOFEN"
				EndIf
				If l671RR1MSA
					cSelect += ", RR1_CODCPF AS COD_CPF_FUNC, RR1_FUSO AS COD_FUSO"
				EndIf 
				If lRR1CCT
					cSelect += ", RR1_CCTREP AS COD_CCT"
				EndIf
				
				cSelect += ", RR1_FILIAL AS COD_FIL_MARC"
				cSelect += ", RR1_CODUNI AS COD_UNID_EXT_CHAVE, RR1_CODFUN AS COD_FUNC_MSA, RR1_INSCR AS COD_INSCR_EMP"
			EndIf			
			
			cSelect += "%"
			
			If lCaClockIn .And. (Empty(SP0->P0_REP) .And. SP0->P0_TIPOARQ == "R")
				If !lIntegRR1
					cWhere		:= "% MSA.COD_UNID_EXT_CHAVE = '" + AllTrim(cConec) + "'"
				Else
					cWhere		:= "% MSA.RR1_CODUNI = '" + AllTrim(cConec) + "'"
				EndIf
			Else			
				// Caso o relogio for novo eh considerado como REP
				If SP0->P0_NOVO == "1"
					If !lIntegRR1
						cWhere	:= "% MSA.COD_REP = '" + AllTrim(SP0->P0_REP) + "'"
					Else
						cWhere	:= "% MSA.RR1_CODREP = '" + AllTrim(SP0->P0_REP) + "'"
					EndIf
				Else
					If !lIntegRR1
						cWhere	:= "% MSA.COD_RELOGIO_EXT_CHAVE = '" + AllTrim(SP0->P0_REP) + "'"
					Else
						cWhere	:= "% MSA.RR1_CODREL = '" + AllTrim(SP0->P0_REP) + "'"
					EndIf
				Endif				
			EndIf
			
			If lVerPeriodo
				
				If !lIntegRR1
					cWhere += " AND LOG_IMPORT_PRODUT = 0 "
				Else
					cWhere += " AND RR1_LOGIP = '0' "
				EndIf
				
				cRepDtIni := DTOS(dDataIni - nDiasExtA)
				cRepDtFim := DTOS(dDataFim + nDiasExtP)
				
				If !lIntegRR1
					If cSGBD $ "ORACLE*POSTGRES"
						cWhere	+= " AND TO_CHAR(DAT_MARCAC_ACES, 'yyyymmdd') BETWEEN '" + cRepDtIni + "' AND '" + cRepDtFim + "' "
					Else
						cRepDtIni := SubStr(cRepDtIni,1,4)+"-"+SubStr(cRepDtIni,5,2)+"-"+SubStr(cRepDtIni,7,2)+"T00:00:00"
						cRepDtFim := SubStr(cRepDtFim,1,4)+"-"+SubStr(cRepDtFim,5,2)+"-"+SubStr(cRepDtFim,7,2)+"T23:59:00"
						cWhere	+= " AND CONVERT(VARCHAR,DAT_MARCAC_ACES,126) BETWEEN '" + cRepDtIni + "' AND '" + cRepDtFim + "' "
					Endif
				Else
					cWhere	+= " AND RR1_DATMAR BETWEEN '" + cRepDtIni + "' AND '" + cRepDtFim + "' "
				EndIf
				If !lIntegRR1
					cOrder	:= "% COD_NSR %"
				Else
					cOrder	:= "% RR1_CODNSR %"
				EndIf
			Else
				If !lIntegRR1
					cOrder	:= "% DATA_MARC DESC "
				Else
					cOrder	:= "% RR1_DATMAR DESC "
				EndIf
				Do Case
					Case cSGBD $ "ORACLE"
						cWhere += " AND ROWNUM <= 50 "
					Case cSGBD $ "MYSQL"
						cOrder	:= " LIMIT 50 "
					Case cSGBD $ "DB2"
						cOrder += " FETCH FIRST 50 ROW ONLY "
					Otherwise
						cSelect := " TOP 50 " + cSelect
				EndCase
				cOrder	+= "%"
			Endif
			
			cSelect		:= "%" + cSelect
			cWhere		+= " %"
			
			If lIntegRR1
				cTabInteg	:= RetSqlName('RR1')
			EndIf
			cTabInteg := "%" + cTabInteg + "%"
			
			BeginSql alias cAliasMSA
				SELECT %exp:cSelect%
				FROM %exp:cTabInteg% MSA
				WHERE %exp:cWhere%
				ORDER BY %exp:cOrder%
			EndSql
			
			cTabInteg := StrTran(cTabInteg,"%","")
			
			If lMemoCalc .And. !lTempF4
				GravaMCalc("01", 2, STR0075 + cTabInteg) // "Origem das MarcaГУes: "
				GravaMCalc("01", 2, STR0076) // "Query para busca das marcaГУes: "
				cMemoQuery := GetlastQuery()[2]
				nTabs := 3
				While Len(cMemoQuery) > 0
					GravaMCalc("01", nTabs, Left(cMemoQuery, 254), .F.)
					cMemoQuery := SubStr(cMemoQuery, 255)
					nTabs := 0
				EndDo
				//Quebra de linha
				GravaMCalc("01", 0, "")
			EndIf
			
			If lTempF4 .or. !lPort1510
				cDbfAlias	:= "__TMPRELOG"
			Else
				cDbfAlias	:= "RFE"
			EndIf
			
			nFields		:= ( cAliasMSA )->( fCount() )
			
			lTemReg := ( cAliasMSA )->( !Eof() )
			IF !( lTemReg )
				If lTempF4
					aAdd( aLogFile, STR0058 ) // "NЦo foram encontradas marcaГУes na tabela de integraГЦo para este relСgio."
					lRet := .F.
				EndIf
				If lMemoCalc .And. !lTempF4
					GravaMCalc("01", 2, STR0077) // "Nenhuma marcaГЦo encontrada."
				EndIf
				( cAliasMSA )->( dbCloseArea() )
				Break
			EndIF
			
			cCodRel := SP0->P0_RELOGIO
			
			While ( cAliasMSA )->( !Eof() )
				
				M->cErrSp0GetInf	:= ""
				
				// Pega o Cracha, caso seja para visualizar as marcaГУes na opГЦo F4 do cadastro do relogio.
				If lTempF4
					If(Empty((cAliasMSA)->COD_PIS_MSA), cCracha := (cAliasMSA)->COD_CPF_FUNC, cCracha := (cAliasMSA)->COD_PIS_MSA)
				EndIf
				
				cData	:= ALLTRIM(( cAliasMSA )->DATA_MARC)
				If Len(cData) > 8
					dData 	:= STOD( SubStr(cData,1,4) +  SubStr(cData,6,2) + SubStr(cData,9,2) )
				Else
					dData 	:= STOD( cData )
				Endif
				
				// Identificar a hora da marcacao
				cHrs 	:= StrZero( Int( ( cAliasMSA )->NUM_HORA / 3600 ) , 2 )	
				cMin	:= "00"
				
				nMin 	:= (( cAliasMSA )->NUM_HORA / 3600) - Int( ( cAliasMSA )->NUM_HORA / 3600 ) 
				If nMin > 0
					cMin := StrZero( Int( Round( nMin * 60 , 0 ) ) , 2 )
				Endif
				
				IF Empty( dData )
					M->cErrSp0GetInf 	:= "ERRO"
					nTipErro 			:= 3
					aAdd( aErroData, AllTrim(Str( (cAliasMSA)->RECNO )) )
				EndIF
				
				If lMemoCalc .And. !lTempF4
					GravaMCalc("01", 2, STR0067 + STRZero(( cAliasMSA )->COD_NSR, len(RFE->RFE_IDORG)) + " | " + dToC(dData) + "-" + cHrs + ":" + cMin) // "MarcaГЦo: "
				EndIf
				
				// Usa a filial da marcaГЦo do Clock In
				If lCaClockIn
					cFilMarc := ""
					
					If lIntegRR1
						cFilMarc := (cAliasMSA)->COD_FIL_MARC
					ElseIf lExtFilMsa
						cFilMarc := (cAliasMSA)->COD_FIL_MARC
					EndIf
				EndIf
				
				// Verifica o tipo da regra de busca de funcionario
				If !lTempF4 .And. !PN030BscFunc(cTpLMarc, cAliasMSA, @cPis, @cCracha, @cRAFilial, @cCPF, cFilMarc, @cRAMat)
					If Empty(aSemCpfPis)
						aAdd(aSemCpfPis,{STR0085,1}) // Existem marcaГУes do Suricato sem o PIS e CPF.
					Else
						aSemCpfPis[1,2] += 1
					EndIf
					
					( cAliasMSA )->( dbSkip())
					Loop
				Endif

				If !Empty(cRAMat) .And. !Empty(cRAFilial) .And. Upper(AllTrim(SP0->P0_DESC)) == "PONTOWEB AUTO" .And. Upper(AllTrim(SP0->P0_FILIAL)) <> Upper(AllTrim(xFilial("SP0", cRAFilial)))
					( cAliasMSA )->( dbSkip())
					Loop
				EndIf

				IF Empty( cCracha )	
					M->cErrSp0GetInf 	:= "ERRO"
					nTipErro			:= 2
					aAdd( aErroFunc, AllTrim(Str( (cAliasMSA)->RECNO )) )
					
				EndIF
				
				cFuncao := Space(Len(RFE->RFE_FUNCAO))
				cGiro   := Space(Len(RFE->RFE_GIRO))
				cCusto  := Space(Len(RFE->RFE_CC))
				
				IF ( lRet := ( M->cErrSp0GetInf <> "ERRO" ) )
					
					nCracha := Max( 1 , Len( cCracha ) )
					nCodRel := Max( 1 , Len( cCodRel ) )
					nFuncao := Max( 1 , Len( cFuncao ) )
					nGiro   := Max( 1 , Len( cGiro   ) )
					nCusto  := Max( 1 , Len( cCusto  ) )
					
					cExt	:= GetDbExtension()
					
					aFieldsSize := {}
					aAdd( aFieldsSize , { nCracha	, 0 } )
					aAdd( aFieldsSize , { 8 		, 0 } )
					aAdd( aFieldsSize , { 5			, 2 } )
					aAdd( aFieldsSize , { nCodRel	, 0 } )
					aAdd( aFieldsSize , { nFuncao	, 0 } )
					aAdd( aFieldsSize , { nGiro		, 0 } )
					aAdd( aFieldsSize , { nCusto	, 0 } )
					
					aFields	:= GetFields( aFieldsSize )
					
					If lTempF4 .or. !lPort1510
						
						aLstIndices := {}
						AAdd(aLstIndices, {"CRACHA","DDATE","HORA"} )
						oTmpTabFO1:= RhCriaTrab(cDbfAlias, aFields, aLstIndices)
						
                    Else
						//Alterado para utilizar tabela de transferencia RFE
						dbSelectArea(cDbfAlias)
						
					EndIf
					
					While ( cAliasMSA )->( !Eof() )
						
						cData	:= ALLTRIM(( cAliasMSA )->DATA_MARC)
						If Len(cData) > 8
							dData 	:= STOD( SubStr(cData,1,4) +  SubStr(cData,6,2) + SubStr(cData,9,2) )
							cDia	:= SubStr(cData,9,2)
							cMes	:= SubStr(cData,6,2)
							cAno	:= SubStr(cData,3,2)
						Else		
							dData 	:= STOD( cData )
							cDia	:= SubStr(cData,7,2)
							cMes	:= SubStr(cData,5,2)
							cAno	:= SubStr(cData,1,4)
						Endif
						
						// Identificar a hora da marcacao
						cHrs 	:= StrZero( Int( ( cAliasMSA )->NUM_HORA / 3600 ) , 2 )	
						cMin	:= "00"
						
						nMin 	:= (( cAliasMSA )->NUM_HORA / 3600) - Int( ( cAliasMSA )->NUM_HORA / 3600 ) 
						If nMin > 0
							cMin := StrZero( Int( Round( nMin * 60 , 0 ) ) , 2 )
						Endif
						
						If lMemoCalc .And. !lTempF4
							GravaMCalc("01", 2, STR0067 + STRZero(( cAliasMSA )->COD_NSR, len(RFE->RFE_IDORG)) + " | " + dToC(dData) + "-" + cHrs + ":" + cMin) // "MarcaГЦo: "
						EndIf
						
						// Usa a filial da marcaГЦo do Clock In
						If lCaClockIn
							cFilMarc := ""
							
							If lIntegRR1
								cFilMarc := (cAliasMSA)->COD_FIL_MARC
							ElseIf lExtFilMsa
								cFilMarc := (cAliasMSA)->COD_FIL_MARC
							EndIf
						EndIf
						
						// Verifica o tipo da regra de busca de funcionario
						If !lTempF4 .And. !PN030BscFunc(cTpLMarc, cAliasMSA, @cPis, @cCracha, @cRAFilial, @cCPF, cFilMarc, @cRAMat)
							If Empty(aSemCpfPis)
								aAdd(aSemCpfPis,{STR0085,1}) // Existem marcaГУes do Suricato sem o PIS e CPF.
							Else
								aSemCpfPis[1,2] += 1
							EndIf
							
							( cAliasMSA )->( dbSkip())
							Loop
						Endif

						If !Empty(cRAMat) .And. !Empty(cRAFilial) .And. Upper(AllTrim(SP0->P0_DESC)) == "PONTOWEB AUTO" .And. Upper(AllTrim(SP0->P0_FILIAL)) <> Upper(AllTrim(xFilial("SP0", cRAFilial)))
							( cAliasMSA )->( dbSkip())
							Loop
						EndIf
						
						IF Empty( cCracha )
							M->cErrSp0GetInf := "ERRO"
							aAdd( aErroFunc, AllTrim(Str( (cAliasMSA)->RECNO )) )
						EndIF
						
						cIdOrg := STRZero(( cAliasMSA )->COD_NSR,len(RFE->RFE_IDORG))
						
						IF ( M->cErrSp0GetInf == "ERRO" )
							M->cErrSp0GetInf := ""
							( cAliasMSA )->( dbSkip() )
							Loop
						EndIF
						
						If lGeoFence .And. lIntegRR1
							cLatitude  := (cAliasMSA)->RR1_LATITU
							cLongitude := (cAliasMSA)->RR1_LONGIT
							cGeofence  := (cAliasMSA)->RR1_GEOFEN
						EndIf 
						
						If l671RR1MSA
							cFuso	:= (cAliasMSA)->COD_FUSO
							If lRR1CCT
								cCCTREP	:= AllTrim((cAliasMSA)->COD_CCT)
							EndIf
						EndIf
						
						If lPort1510 .and. !lTempF4 .And. !lCaClockIn .And. Empty((cAliasMSA)->COD_INSCR_EMP)
							lExistRFE	:= .F.
							cWhereNSR	:= "% RFE.RFE_RELSP0 = '" + SP0->P0_RELOGIO + "' AND RFE.RFE_IDORG = '" + cIdOrg + "' AND RFE.RFE_CRACHA = '" + cCracha + "' "
							If ( Val(cIdOrg) == 0 ) //NAO EXISTE NSR
								cData 	:= cAno + cMes + cDia
								nHora	:=  Val( cHrs + "." + cMin )
								cWhereNSR	+= " AND RFE.RFE_DATA = '" + cData + "' AND RFE.RFE_HORA = "
								cWhereNSR	+= Str(nHora)
							EndIf
							
							cWhereNSR	+= "%" 
							
							BeginSql alias cAliasNSR
								SELECT COUNT(*) AS NROREG
								FROM %table:RFE% RFE
								WHERE %exp:cWhereNSR%
								and RFE.D_E_L_E_T_  = ' '
							EndSql
							
							If lMemoCalc .And. !lTempF4
								GravaMCalc("01", 3, STR0078) // "Busca na RFE: "
								cMemoQuery := GetlastQuery()[2]
								nTabs := 4
								While Len(cMemoQuery) > 0
									GravaMCalc("01", nTabs, Left(cMemoQuery, 254), .F.)
									cMemoQuery := SubStr(cMemoQuery, 255)
									nTabs := 0
								EndDo
								//Quebra de linha
								GravaMCalc("01", 0, "")
							EndIf
							
							If (cAliasNSR)->NROREG > 0
								lExistRFE	:= .T.
								// Gravar o controle de leitura das marcacoes - TcSqlExec()
								cQueryUpdate := "UPDATE " + cTabInteg
								If !lIntegRR1
									cQueryUpdate += " SET LOG_IMPORT_PRODUT = 1"
									cQueryUpdate += "WHERE VAL_CONTROL_MARCAC = " + AllTrim(Str( ( cAliasMSA )->RECNO ))
								Else
									cQueryUpdate += " SET RR1_LOGIP = '1'"
									cQueryUpdate += "WHERE RR1_VALCON = '" + AllTrim(Str( ( cAliasMSA )->RECNO )) + "'"
								EndIf
								TcSqlExec(cQueryUpdate)
								
								If lMemoCalc .And. !lTempF4
									GravaMCalc("01", 3, STR0079) // "MarcaГЦo jА gravada na RFE"
									GravaMCalc("01", 3, STR0080 + cTabInteg + " RR1_LOGIP = '1' | RECNO = " + AllTrim(Str((cAliasMSA)->RECNO))) // "Atualizada a tabela "
								EndIf
							EndIf
							
							(cAliasNSR)->( dbCloseArea() )
							
							If lExistRFE
								( cAliasMSA )->( dbSkip() )
								Loop //Arquivo ja lido
							EndIf							
						EndIf
						
						If lTempF4 .or. !lPort1510
							( cDbfAlias )->( dbAppend( .T. ) )
							( cDbfAlias )->( CRACHA ) := cCracha
							( cDbfAlias )->( DDATE  ) := dData
							( cDbfAlias )->( HORA   ) := Val( ( cHrs + "." + cMin ) )
							( cDbfAlias )->( CUSTO  ) := cCusto
							( cDbfAlias )->( CODREL ) := cCodRel
							( cDbfAlias )->( FUNCAO ) := cFuncao
							( cDbfAlias )->( GIRO   ) := cGiro
						Else
							BEGIN TRANSACTION
								IF RecLock( cDbfAlias , .T. )					
								If !lRepCarol
									( cDbfAlias )->RFE_FILIAL	:= SP0->P0_FILIAL
									( cDbfAlias )->RFE_ORIG		:= cFilSP0
								Else
									( cDbfAlias )->RFE_ORIG		:= cRAFilial
								EndIf
								
								( cDbfAlias )->RFE_CRACHA	:= cCracha
								( cDbfAlias )->RFE_PIS		:= cPIS
								( cDbfAlias )->RFE_DATA		:= dData
								( cDbfAlias )->RFE_HORA		:= Val( ( cHrs + "." + cMin ) )
								( cDbfAlias )->RFE_CC		:= cCusto
								( cDbfAlias )->RFE_FUNCAO	:= cFuncao
								( cDbfAlias )->RFE_GIRO		:= cGiro
								( cDbfAlias )->RFE_FLAG		:= "0"
								( cDbfAlias )->RFE_NUMREP	:= cNumRep
								( cDbfAlias )->RFE_DTHRLI	:= cDtHrLi
								( cDbfAlias )->RFE_DTHRG	:= cDtHrG
								( cDbfAlias )->RFE_EMPORG	:= cEmpAnt
								( cDbfAlias )->RFE_DHORG	:= cDhOrg
								( cDbfAlias )->RFE_IDORG	:= cIdOrg
								( cDbfAlias )->RFE_NATU		:= "3"
								
								If !lRepCarol
									( cDbfAlias )->RFE_RELOGI	:= cCodRel
									( cDbfAlias )->RFE_RELSP0	:= SP0->P0_RELOGIO
								EndIf
								
								If lGeoFence .And. lIntegRR1
									( cDbfAlias )->RFE_LATITU	:= cLatitude
									( cDbfAlias )->RFE_LONGIT	:= cLongitude
									( cDbfAlias )->RFE_GEOFEN	:= cGeofence
								EndIf
								
								If l671RR1MSA
									( cDbfAlias )->RFE_CPF		:= cCPF
									( cDbfAlias )->RFE_FUSO		:= cFuso
									If lRR1CCT
										( cDbfAlias )->RFE_CCTREP	:= cCCTREP
									EndIf
								EndIf
								
								If !Empty(cRAMat) .And. !Empty(cRAFilial)
									( cDbfAlias )->RFE_FILORG	:= cRAFilial
									( cDbfAlias )->RFE_MATORG	:= cRAMat
								EndIf
													
								( cDbfAlias )->( MsUnLock() )
								
								If lMemoCalc .And. !lTempF4
									GravaMCalc("01", 3, STR0069) // "MarcaГЦo gravada na RFE"
									// "Data: " - "Hora: " - "CrachА: "
									GravaMCalc("01", 4, "NSR: " + cIdOrg + " | " + STR0070 + dToC(dData) + " | " + STR0071 + cHrs + ":" + cMin + " | cPIS: " + If(!Empty(cPIS), cPis, " ") + " | CPF: " + If(!Empty(cCPF), cCPF, " ") + " | " + STR0072 + If(!Empty(cCracha), cCracha, " "))
								EndIf
								
								If lPort1510
									RFB->(DbsetOrder(RetOrder("RFB", "RFB_FILIAL+RFB_ARQ+RFB_DTHRG+RFB_DTHRLI")))
									If ( RFB->( DbSeek(cKeySeek) ) )
										IF RecLock( 'RFB' , .F. )
											RFB->RFB_IDORG   := cIdOrg
											RFB->( MsUnLock() )
											If lMemoCalc .And. !lTempF4
												GravaMCalc("01", 3, STR0073 + " - NSR: " + cIdOrg) // "Registro atualizado na RFB"
											EndIf
										EndIF
									EndIF
								EndIf
								
								lGrvRFE := .T.
								
								// Gravar o controle de leitura das marcacoes - TcSqlExec()
								cQueryUpdate := "UPDATE " + cTabInteg
								If !lIntegRR1
									cQueryUpdate += " SET LOG_IMPORT_PRODUT = 1"
									cQueryUpdate += "WHERE VAL_CONTROL_MARCAC = " + AllTrim(Str( ( cAliasMSA )->RECNO ))
								Else
									cQueryUpdate += " SET RR1_LOGIP = '1' "
									cQueryUpdate += "WHERE RR1_VALCON = '" + AllTrim(Str( ( cAliasMSA )->RECNO )) + "'"
								EndIf
									
									TcSqlExec(cQueryUpdate)
									
									If (!Empty(TcSqlError()),DisarmTransaction(),)
									If lMemoCalc .And. !lTempF4
										GravaMCalc("01", 3, STR0080 + cTabInteg + " RR1_LOGIP = '1' | RECNO = " + AllTrim(Str((cAliasMSA)->RECNO))) // "Atualizada a tabela "
									EndIf
									
								EndIF
							END TRANSACTION
						EndIF
						
						//Aqui vai ser feito a funГЦo para a batida do atendente somente quando for Clockin e a integrГЦo com o SIGATEC estiver ativado
						If lCaClockIn .And. lIntegServ
							TecCheckIn(cCracha,cRAFilial,dData,Val( ( cHrs + "." + cMin ) ))
						EndIf 
						( cAliasMSA )->( dbSkip() )
						
					EndDo
					
				EndIF
				
				IF ( lRet )
					Exit
				EndIF
				
				( cAliasMSA )->( dbSkip() )
				
			EndDo
			
			( cAliasMSA )->( dbCloseArea() )
			
			SRA->( dbSetOrder(nOrdSRA) )	   
		Else
			lRet		:= .F. 
			nTipErro	:= 1
		Endif
	EndIF
	
	If lPort1510 .and. !lTempF4 .and. lGrvRFE
		cDataAux := DtoS(MsDate())
		cHoraAux := Time()
		cDtHrLf	 := SUBSTR(cDataAux,3,2) + SUBSTR(cDataAux,5,2) + SUBSTR(cDataAux,7,2) + SUBSTR(cHoraAux,1,2) + SUBSTR(cHoraAux,4,2) //-- AAMMDDHHMM
		RFB->(DbsetOrder(RetOrder("RFB","RFB_FILIAL+RFB_ARQ+RFB_DTHRG+RFB_DTHRLI")))
		If ( RFB->( DbSeek(cKeySeek) ) )
			IF RecLock( 'RFB' , .F. )
				RFB->RFB_DTHRLF  := cDtHrLf
				RFB->( MsUnLock() )
			EndIF		
		EndIF		
	EndIf
	
	IF ( lRet ) .and. ( lTempF4 )  .or. !( lPort1510 )
		If !(lRet := iif (oTmpTabFO1 <> NIL,.T.,.F.))
			nTipErro := 4
		EndIf
	EndIF	
	
	IF !( lRet )
		DEFAULT aLogFile := {}
		If cDataType == "R"
			If nTipErro == 1
				aAdd( aLogFile, STR0046 )//"Existem inconsistЙncias na configuraГЦo da integraГЦo com Suricato ou Clock In. Verifique se o parБmetro MV_TSREP estА ativo, em caso de integraГЦo com o Suricato, ou se o parБmetro MV_APICLO0 estА ativo, em caso de integraГЦo com o Clock In. E verifique se a tabela MSA_CONTROL_MARCAC existe no banco de dados, em caso de nЦo haver a tabela RR1 no dicionАrio."
			ElseIf nTipErro == 4
				aAdd( aLogFile, STR0047 )//"NЦo foi possМvel criar a tabela temporАria para visualizaГЦo das marcaГУes devido a um erro desconhecido. Contate o administrador do sistema."
			EndIf
			If nTipErro == 2
				aAdd( aLogFile, STR0048 )//"HА marcaГЦo(Уes) sem preenchimento de PIS/informaГЦo cadastral do funcionАrio ou que nЦo foi possМvel encontrar o funcionАrio com a identificaГЦo no cadastro de funcionАrios. Essa(s) marcaГЦo(Уes) nЦo serА(Цo) importada(s) para o SIGAPON."
				If !lTempF4
					aAdd( aLogFile, STR0049 )//"ID da(s) marcaГУes na tabela: "
					For nContErro := 1 To Len(aErroFunc)
						aAdd( aLogFile, aErroFunc[nContErro] )
					Next nContErro
				EndIf
			EndIf
			If nTipErro == 3
				aAdd( aLogFile, STR0050 )//"HА marcaГЦo(Уes) com preenchimento incorreto da data. Essa(s) marcaГЦo(Уes) nЦo serА(Цo) importada(s) para o SIGAPON."
				If !lTempF4
					aAdd( aLogFile, STR0049 )//"ID da(s) marcaГУes na tabela: "
					For nContErro := 1 To Len(aErroData)
						aAdd( aLogFile, aErroData[nContErro] )
					Next nContErro
				EndIf
			EndIf
		Else
			//"Foi encontrada uma Inconsist┬ncia de Informa┤■es no Relogio:"
			aAdd( aLogFile , STR0010 + " " + IF( IsMemVar( "P0_RELOGIO" ) , GetMemVar( "P0_RELOGIO" ) , SP0->P0_RELOGIO ) )
			//"Verifique a configura┤ao do Relogio para o Arquivo: "
			aAdd( aLogFile , STR0011 + " " + IF( IsMemVar( "P0_ARQUIVO" ) , GetMemVar( "P0_ARQUIVO" ) , SP0->P0_ARQUIVO ) )
		Endif
		Break
	EndIF
	
	If lTempF4 .or. !lPort1510
		
		cDataType := "D"
	EndIf
	
	cTxtAlias := cDbfAlias
	
End Sequence

If Select( cAliasMSA ) > 0
	( cAliasMSA )->( dbCloseArea() )
Endif

If ( lPort1510 .and. !lTempF4 .and. !Empty(cKeySeek) .and. ( !lRet .or. !lGrvRFE ) )
	RFB->(DbsetOrder(RetOrder("RFB","RFB_FILIAL+RFB_ARQ+RFB_DTHRG+RFB_DTHRLI")))
	If ( RFB->( DbSeek(cKeySeek) ) )
		While RFB->( !Eof() .and. ( cKeySeek == ( RFB_FILIAL+RFB_ARQ+RFB_DTHRG+RFB_DTHRLI ) ) )
			If !( RFB->RFB_RELOGI == SP0->P0_RELOGIO )
				RFB->( dbSkip() )
			Else
				IF RecLock( 'RFB' , .F. )
					IF !RFB->( FkDelete( @cMsgErr ) )
						RollBackDelTran( cMsgErr )
					EndIF
					RFB->( MsUnLock() )
					If lMemoCalc .And. !lTempF4
						GravaMCalc("01", 2, STR0081) // "Registro excluМdo da tabela RFB."
					EndIf
				EndIF
				Exit				
            EndIf
		EndDo
	EndIF		
EndIf

IF !( lSetCentury )
	__SetCentury("off")
EndIF

RestArea( aArea )

Return( lRet )

/*/
зддддддддддбдддддддддддддбдддддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁGetFields    Ё Autor ЁMarinaldo de Jesus   Ё Data Ё16/09/2004Ё
цддддддддддедддддддддддддадддддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁObtem os campos para a Montagem do Temporario de Marcacoes   Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ															 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁNIL                                                  	     Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁObserva┤└oЁ                                                      	     Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
Ё Uso      ЁGENERICO                                                     Ё
юддддддддддаддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function GetFields( aFieldsSize )

Local aFields := Array( 7 , 4 )

aFields[ 01 , 01 ] := "CRACHA"
aFields[ 01 , 02 ] := "C"
aFields[ 01 , 03 ] := aFieldsSize[1,1]
aFields[ 01 , 04 ] := aFieldsSize[1,2]

aFields[ 02 , 01 ] := "DDATE"
aFields[ 02 , 02 ] := "D"
aFields[ 02 , 03 ] := aFieldsSize[2,1]
aFields[ 02 , 04 ] := aFieldsSize[2,2]

aFields[ 03 , 01 ] := "HORA"
aFields[ 03 , 02 ] := "N"
aFields[ 03 , 03 ] := aFieldsSize[3,1]
aFields[ 03 , 04 ] := aFieldsSize[3,2]

aFields[ 04 , 01 ] := "CODREL"
aFields[ 04 , 02 ] := "C"
aFields[ 04 , 03 ] := aFieldsSize[4,1]
aFields[ 04 , 04 ] := aFieldsSize[4,2]

aFields[ 05 , 01 ] := "FUNCAO"
aFields[ 05 , 02 ] := "C"
aFields[ 05 , 03 ] := aFieldsSize[5,1]
aFields[ 05 , 04 ] := aFieldsSize[5,2]

aFields[ 06 , 01 ] := "GIRO"
aFields[ 06 , 02 ] := "C"
aFields[ 06 , 03 ] := aFieldsSize[6,1]
aFields[ 06 , 04 ] := aFieldsSize[6,2]

aFields[ 07 , 01 ] := "CUSTO"
aFields[ 07 , 02 ] := "C"
aFields[ 07 , 03 ] := aFieldsSize[7,1]
aFields[ 07 , 04 ] := aFieldsSize[7,2]

Return( aFields )

/*/
зддддддддддбдддддддддддддбдддддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o	   ЁDbfGetData	 Ё Autor ЁMarinaldo de Jesus   Ё Data Ё08/09/2004Ё
цддддддддддедддддддддддддадддддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁTransforma o conteudo do arquivo de marcacoes em String      Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ															 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁNIL                                                  	     Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁObserva┤└oЁ                                                      	     Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁSP0BldData                                                   Ё
юддддддддддаддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function DbfGetData( cDbfAlias , nFields )

Local cTxt := ""
Local cFieldType
Local nField
Local uData

For nField := 1 To nFields
	uData		:= ( cDbfAlias )->( FieldGet( nField ) )
	cFieldType	:= ValType( uData )
	IF ( cFieldType == "C" )
		cTxt += uData
	ElseIF ( cFieldType == "N" )
		cTxt += StrZero( uData , 5 , 2 )
	ElseIF ( cFieldType == "D" )
		cTxt += Dtos( uData )
	EndIF
Next nField

Return( cTxt )

/*/
зддддддддддбдддддддддддддбдддддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o	   ЁSp0GetInfo   Ё Autor ЁMarinaldo de Jesus   Ё Data Ё08/09/2004Ё
цддддддддддедддддддддддддадддддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁRetorna Informacoes do Relogio                               Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ															 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁNIL                                                  	     Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁObserva┤└oЁ                                                      	     Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁSP0BldData                                                   Ё
юддддддддддаддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function Sp0GetInfo( cTxt , cForm , nPosIni , nPosFim )

IF ( cForm <> NIL )
	Return( Sp0ExecForm( cForm ) )
Else
	Return( SubStr( cTxt , nPosIni , nPosFim ) )
EndIF

/*/
зддддддддддбдддддддддддддбдддддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁSp0ExecForm  ЁAutor  ЁMarinaldo de Jesus   Ё Data Ё16/09/2004Ё
цддддддддддедддддддддддддадддддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o Ё Verifica se a formula digitada ┌ V═lida                     Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ															 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁNIL                                                  	     Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁObserva┤└oЁ                                                      	     Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁSp0GetInfo                                                   Ё
юддддддддддаддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function Sp0ExecForm( cFor )

Local cRet := cFor

IF !( CheckExecForm( @cRet ) )
	cRet := ""
	SetMemVar( "cErrSp0GetInf" , "ERRO" )
EndIF

Return( cRet )

/*/
зддддддддддбдддддддддддддбдддддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁTxtAliasCloseЁAutor  ЁMarinaldo de Jesus   Ё Data Ё16/09/2004Ё
цддддддддддедддддддддддддадддддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁFecha o arquivo Referenciado pelo cTxtAlias                  Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё<Vide Parametros Formais>									 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ															 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁNIL                                                  	     Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁObserva┤└oЁ                                                      	     Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁSIGAPON														 Ё
юддддддддддаддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function TxtAliasClose( cTxtAlias )

Local cAlias := Alias()

IF (;
		!Empty( cTxtAlias );
		.and.;
		( Select( cTxtAlias ) > 0 );
	 )
	( cTxtAlias )->( dbCloseArea() )
	cTxtAlias := ""
EndIF

dbSelectArea( "SP0" )

IF (;
		!Empty( cAlias );
		.and.;
		( Select( cAlias ) > 0 );
	)	
	dbSelectArea( cAlias )
EndIF

Return( NIL )

/*/
зддддддддддбдддддддддддддбдддддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁP0RepVld     ЁAutor  ЁLeandro Drumond      Ё Data Ё14/10/2009Ё
цддддддддддедддддддддддддадддддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o Ё Valida conteudo do campo P0_REP                             Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё                         									 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ															 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁNIL                                                  	     Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁObserva┤└oЁ                                                      	     Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁPONA030                                                      Ё
юддддддддддаддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function P0RepVld()

Local aArea 	:= GetArea()
Local cMsgInfo 	:= ""
Local lRet  	:= .T.
Local nOrdem	:= 0
Local nRegSM0	:= SM0->(Recno())
Local cCNPJ		:= SM0->M0_CGC

SM0->(dbSetOrder(1))

Begin Sequence                 

	If lPort1510
		If !Empty(M->P0_REP) //--Se conteudo nao estava vazio

			// Caso seja alteracao nao deixa alterar o codigo do REP quando ja foi utilizado
			If ALTERA
				DbSelectArea("RFB")
				nOrdem := RFB->( IndexOrd() )
				RFB->(DbsetOrder(RetOrder("RFB","RFB_FILIAL+RFB_RELOGI+RFB_NUMREP")))
				If DbSeek(SP0->P0_FILIAL + SP0->P0_RELOGIO + SP0->P0_REP)
					cMsgInfo	:= STR0018  //"NЗmero do REP nЦo pode ser alterado pois jА foi utilizado."
					MsgInfo( OemToAnsi( cMsgInfo ) , OemToAnsi( STR0017 ) ) //"AtenГЦo!"
					lRet := .F.
					RFB->( DbsetOrder(nOrdem) )
					Break
				EndIf
				RFB->( DbsetOrder(nOrdem) )
			Endif
				
			SP0->( dbGoTop() )
			While SP0->( !Eof() )
				If SP0->P0_RELOGIO <> M->P0_RELOGIO .And. SP0->P0_REP == M->P0_REP

					// Quando o cadastro da empresa e por codigo de CEI valida rep unico
					// ou quando a tabela SP0 esta compartilhada
					// ou na mesma filial utilizando o mesmo rep nao deixa cadastrar
					If SM0->M0_TPINSC == 1 .Or. Empty(xFilial("SP0")) .Or. SP0->P0_FILIAL == M->P0_FILIAL
						lRet := .F.
					Else
						If SM0->(dbSeek( cEmpAnt + AllTrim(SP0->P0_FILIAL) )) .And. cCNPJ == SM0->M0_CGC
							lRet := .F.
						Endif
					Endif

				EndIF

				If !lRet
					cMsgInfo	:= STR0023 //"O nЗmero do REP jА estА sendo utilizado por outro relСgio."
					MsgInfo (OemToAnsi( cMsgInfo ), OemToAnsi( STR0017 )) //"AtenГЦo!"
					Break
				Endif
				
				SP0->( dbSkip() )
			End While	
		EndIf
	EndIf

End Sequence

RestArea(aArea)

SM0->(dbGoTo(nRegSM0))

Return( lRet )

/*/
зддддддддддбдддддддддддддбдддддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁfPn30VldDel  ЁAutor  ЁLeandro Drumond      Ё Data Ё15/10/2009Ё
цддддддддддедддддддддддддадддддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁValida delecao da axDeleta()                                 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё                         									 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ															 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁNIL                                                  	     Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁObserva┤└oЁ                                                      	     Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁUso       ЁPONA030                                                      Ё
юддддддддддаддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function fPn30VldDel()

Local aArea 	:= GetArea()
Local cMsgInfo 	:= ""
Local lRet  	:= .T.
Local nOrdem	:= 0
                 
If lPort1510
	If !Empty(SP0->P0_REP) //--Se conteudo nao esta vazio
		DbSelectArea("RFB")
		nOrdem := RFB->( IndexOrd() )
		RFB->(DbsetOrder(RetOrder("RFB","RFB_FILIAL+RFB_RELOGI+RFB_NUMREP")))
		If DbSeek(SP0->P0_FILIAL + SP0->P0_RELOGIO + SP0->P0_REP)
			cMsgInfo	:= STR0019  //"RelСgio nЦo poderА ser excluМdo pois existem marcaГУes relacionadas a ele."
			MsgInfo( OemToAnsi( cMsgInfo ) , OemToAnsi( STR0017 ) ) //"AtenГЦo!"
			lRet := .F.
		EndIf
		RFB->( DbsetOrder(nOrdem) )
	EndIf
EndIf

RestArea(aArea)

Return( lRet )

/*/
зддддддддддбдддддддддддддбдддддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁPona030Log   Ё Autor ЁLeandro Drumond      Ё Data Ё21/10/2009Ё
цддддддддддедддддддддддддадддддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁDisponibiliza Consulta ao Log de Leitura.                    Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ															 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁNIL                                                  	     Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁObserva┤└oЁ                                                      	     Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
Ё Uso      ЁGENERICO                                                     Ё
юддддддддддаддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Static Function Pona030Log()

Local aSvKeys			:= GetKeys()
Local aAdvSize			:= {}
Local aInfoAdvSize		:= {}
Local aObjCoords		:= {}
Local aObjSize			:= {}
Local aButtons			:= {}
Local aFields			:= {}
Local aArea				:= GetArea()

Local bSet15 			:= { || NIL }
Local bSet24			:= { || NIL }
Local bInitDlg			:= { || NIL }

Local cTopFun			:= ""
Local cBotFun			:= ""

Local lSetCentury		:= __SetCentury("on")

Local oDlg				:= NIL
Local oMsSelect			:= NIL

Begin Sequence

	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	ЁDefine o Array com os Campos                           	   Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	aAdd( aFields ,	{ "RFB_RELOGI"	, NIL ,	"RelСgio" 		 , "999" } )
	aAdd( aFields ,	{ "RFB_NUMREP"	, NIL ,	"N╨ REP"  	   	 , "99999999999999999" } )
	aAdd( aFields ,	{ "RFB_ARQ"	    , NIL ,	"Arquivo"        , "@!" } )
	aAdd( aFields ,	{ "RFB_DTHRLI"	, NIL ,	"Data/Hora InicМo Leitura" , "@!" } )
	aAdd( aFields ,	{ "RFB_DTHRLF"	, NIL , "Data/Hora Fim Leitura"    , "@!" } )
	aAdd( aFields ,	{ "RFB_IDORG"	, NIL ,	"Quantidade Lido", "@!" } )

	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Define os Blocos para as Teclas <CTRL-O>					   Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	bSet15 	:= { || RestKeys( aSvKeys , .T. ) , oDlg:End() }

	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Define os Blocos para as Teclas <CTRL-X>     	   			   Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	bSet24	:= { || RestKeys( aSvKeys , .T. ) , oDlg:End() }
	
	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Define o Bloco para o Init do Dialog         	   			   Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	bInitDlg := { ||	Eval( oMsSelect:oBrowse:bGotop )	,;
						oMsSelect:oBrowse:Refresh()			,;
						EnchoiceBar( oDlg , bSet15 , bSet24 , NIL , aButtons );
			 	}

	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Monta as Dimensoes para o Dialogo Principal				   Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	aAdvSize		:= MsAdvSize(.T.,.T.)
	aInfoAdvSize	:= { aAdvSize[1] , aAdvSize[2] , aAdvSize[3] , aAdvSize[4] , 5 , 5 }
	aAdd( aObjCoords , { 000 , 000 , .T. , .T. } )
	aObjSize		:= MsObjSize( aInfoAdvSize , aObjCoords )
	aMsSltCoords	:= { aObjSize[1,1] , aObjSize[1,2] , aObjSize[1,3] , aObjSize[1,4] }

	DbSelectArea("RFB")
	RFB->(DbsetOrder(RetOrder("RFB","RFB_FILIAL+RFB_RELOGI+RFB_NUMREP+RFB_DTHRLI")))
	cTopFun := "fPn030LogPos"
	cBotFun := "fPn030LogPos"

	/*/
	здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	Ё Monta Dialogo para Montagem do Filtro                        Ё
	юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
	DEFINE MSDIALOG oDlg TITLE "Log de Leitura" From aAdvSize[7],0 TO aAdvSize[6],aAdvSize[5] OF GetWndDefault() PIXEL

		oMsSelect := MsSelect():New(;
										"RFB"			,;  //Alias	do Arquivo de Filtro
										NIL				,;  //Campo para controle do mark
										NIL				,;  //Condicao para o Mark
										aFields			,;  //Array com os Campos para o Browse
										NIL				,;  //?
										NIL   			,;  //Conteudo a Ser Gravado no campo de controle do Mark
										aMsSltCoords	,;  //Coordenadas do Objeto
										cTopFun			,;  //Posicao Inicial em cAlias
										cBotFun			,;  //Posicao Final em cAlias
										oDlg			 ;	//Objeto Dialog
									)

	ACTIVATE MSDIALOG oDlg CENTERED ON INIT Eval( bInitDlg )

End Sequence

RestArea(aArea)

/*/
зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
Ё Restaura as Teclas de Atalho        						  Ё
юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
RestKeys( aSvKeys , .T. )

IF !( lSetCentury )
	__SetCentury("off")
EndIF

Return( NIL )

/*/
зддддддддддбдддддддддддддбдддддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁfPn030LogPos Ё Autor ЁLeandro Drumond      Ё Data Ё22/10/2009Ё
цддддддддддедддддддддддддадддддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁFuncao para posicionar a MsSelect no relogio atual.          Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ															 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁNIL                                                  	     Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁObserva┤└oЁ                                                      	     Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
Ё Uso      ЁGENERICO                                                     Ё
юддддддддддаддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function fPn030LogPos()
Local cKey := xFilial("RFB") + SP0->P0_RELOGIO

Return (cKey)

/*/
зддддддддддбдддддддддддддбдддддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁPn030TudOk   Ё Autor ЁAllyson Mesashi      Ё Data Ё31/07/2010Ё
цддддддддддедддддддддддддадддддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁValida Todos os Itens da GetDados.					         Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   ЁlRet                                                  	     Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
Ё Uso      ЁPONA030                                                     Ё
юддддддддддаддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function Pn030TudOk()

Local aArea			:= GetArea()
Local lRet			:= .T.
Local lCaClockIn 	:= M->P0_TIPOARQ == "R" .And. Empty(M->P0_REP)
Local lCSV			:= M->P0_TIPOARQ == "C"

Begin Sequence
    
	//Validacao para nao permitir alteracao de relogio antigo
	If cPaisLoc == "BRA" .and. ( ( !lPort1510 .And. ProcName(8) $ "AXALTERA" ) .Or. ( lPort1510 .And. ProcName(8) $ "AXALTERA" .And. Empty(M->P0_NOVO) ) )
		//"NЦo И permitida a alteraГЦo de relСgio antigo."
		MsgInfo(OemToAnsi( STR0032 ) , OemToAnsi( STR0017 )) //"AtenГЦo!"
		lRet := .F.
		Break
	EndIf
	
	//Validacao do preenchimento do layout qdo relogio antigo
	If ( lPort1510 ) .And. !lCaClockIn
		If Empty(M->P0_REP) 
			If (!lCSV .And. (Empty(M->P0_CODINI) .Or. Empty(M->P0_CODFIM))) .Or. (lCSV .And. Empty(M->P0_DOCCOL))
				If Empty(M->P0_CODFOR) 
					//"Informe as posiГУes de layout do CrachА"
					MsgInfo(OemToAnsi( STR0024 ), OemToAnsi( STR0017 )) //"AtenГЦo!"
					lRet := .F.
					Break
				EndIf
			EndIf
			If (!lCSV .And. (Empty(M->P0_RELOINI) .Or. Empty(M->P0_RELOFIM))) .Or. (lCSV .And. Empty(M->P0_RELCOL))
				If Empty(M->P0_RELOFOR)
					//"Informe as posiГУes de layout do RelСgio"
					MsgInfo(OemToAnsi( STR0025 ), OemToAnsi( STR0017 )) //"AtenГЦo!"
					lRet := .F.
					Break
				EndIf
			EndIf
			If !lCSV .And. (Empty(M->P0_DIAINI) .Or. Empty(M->P0_DIAFIM))
				If Empty(M->P0_DIAFOR)
					//"Informe as posiГУes de layout do Dia"
					MsgInfo(OemToAnsi( STR0026 ), OemToAnsi( STR0017 )) //"AtenГЦo!"
					lRet := .F.
					Break
				EndIf
			EndIf
			If !lCSV .And. (Empty(M->P0_MESINI) .Or. Empty(M->P0_MESFIM))
				If Empty(M->P0_MESFOR)
					//"Informe as posiГУes de layout do MЙs"
					MsgInfo(OemToAnsi( STR0027 ), OemToAnsi( STR0017 )) //"AtenГЦo!"
					lRet := .F.
					Break
				EndIf
			EndIf
			If !lCSV .And. (Empty(M->P0_ANOINI) .Or. Empty(M->P0_ANOFIM))
				If Empty(M->P0_ANOFOR)
					//"Informe as posiГУes de layout do Ano"
					MsgInfo(OemToAnsi( STR0028 ), OemToAnsi( STR0017 )) //"AtenГЦo!"
					lRet := .F.
					Break
				EndIf
			EndIf
			If !lCSV .And. (Empty(M->P0_HORAINI) .Or. Empty(M->P0_HORAFIM))
				If Empty(M->P0_HORAFOR)
					//"Informe as posiГУes de layout da Hora"
					MsgInfo(OemToAnsi( STR0029 ), OemToAnsi( STR0017 )) //"AtenГЦo!"
					lRet := .F.
					Break
				EndIf
			EndIf	
			If !lCSV .And. (Empty(M->P0_MINUINI) .Or. Empty(M->P0_MINUFIM))
				If Empty(M->P0_MINUFOR)
					//"Informe as posiГУes de layout dos Minutos"
					MsgInfo(OemToAnsi( STR0030 ), OemToAnsi( STR0017 )) //"AtenГЦo!"
					lRet := .F.
				EndIf
			EndIf
			
			If lCSV .And. Empty(M->P0_DATACOL)
				//"Informe o nЗmero da coluna para a data"
				MsgInfo(OemToAnsi( STR0086 ), OemToAnsi( STR0017 )) //"AtenГЦo!"
				lRet := .F.
				Break
			EndIf
			
			If lCSV .And. Empty(M->P0_TPDATA)
				//"Selecione o formato da data"
				MsgInfo(OemToAnsi( STR0087 ), OemToAnsi( STR0017 )) //"AtenГЦo!"
				lRet := .F.
				Break
			EndIf
			
			If lCSV .And. M->P0_TPDATA $ "1|2" .And. Empty(M->P0_HRSCOL)
				//"Informe o nЗmero da coluna para as horas"
				MsgInfo(OemToAnsi( STR0088 ), OemToAnsi( STR0017 )) //"AtenГЦo!"
				lRet := .F.
			EndIf
			
		Else
			If (M->P0_INC == '2')
				//" Este relСgio deve ser incremental "
				MsgInfo(OemToAnsi( STR0036 ), OemToAnsi( STR0017 )) //"AtenГЦo!"
				lRet	:= .F.			
			EndIf
			If !Empty(M->P0_TPREP) .And. M->P0_TPREP $ "2,3,4"
				If !fValid671()
					//"O relСgio foi configurado para o Layout da Portaria 671, porИm estЦo faltando os campos RFE_TPREG, RFE_CPF, RFE_IDMARC, RFE_MARCON, RFE_DTGVMA, RFE_SRH256 e RFE_CRC na tabela de PrИ-Leitura (RFE). SerА necessАrio incluiur os campos antes de alterar ou incluir um relСgio da portaria 671."
					MsgInfo(OemToAnsi(STR0053), OemToAnsi(STR0017)) //"AtenГЦo!"
					lRet	:= .F.	
				EndIf
			EndIf	
		EndIf
	EndIf
    
//Se nova inclusao, marca o campo Novo com '1' para indicar que eh novo relogio
//    If ProcName(8) $ "AXINCLUI" .And. lRet .And. lPort1510
//    	M->P0_NOVO := "1"
//    EndIf
	
	If M->P0_TIPOARQ == "R"	
		M->P0_ARQUIVO := "REP"
	Endif

End Sequence

RestArea(aArea)

Return ( lRet )


/*
зддддддддддбддддддддддддддддбдддддбдддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    Ё MenuDef		ЁAutorЁ  Luiz Almeida     Ё Data Ё21/11/2006Ё
цддддддддддеддддддддддддддддадддддадддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁIsola opcoes de menu para que as opcoes da rotina possam    Ё
Ё          Ёser lidas pelas blibliotecas Framework da Versao 9.12 .     Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁSintaxe   Ё< Vide Parametros Formais >									Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
Ё Uso      ЁPONA030                                                     Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
Ё Retorno  ЁaRotina														Ё
цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ< Vide Parametros Formais >									Ё
юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды*/

Static Function MenuDef()

	Local aRotina := {;
						   		{ STR0004 ,"PesqBrw" 	, 0, 1, ,.F.} ,; // "Pesquisar"
								{ STR0005 ,"Pona030Vis"	, 0, 2} ,; // "Visualizar"
								{ STR0006 ,"Pona030Inc"	, 0, 3} ,; // "Incluir"
								{ STR0007 ,"Pona030Alt"	, 0, 4} ,; // "Alterar"
								{ STR0008 ,"Pona030Del"	, 0, 5}  ; // "Excluir"
							}
						
Return aRotina

/*/
зддддддддддбдддддддддддддбдддддддбдддддддддддддддддддддбддддддбдддддддддд©
ЁFun┤└o    ЁPN030BscFunc Ё Autor ЁIP RH Inovacao       Ё Data Ё04/05/2012Ё
цддддддддддедддддддддддддадддддддадддддддддддддддддддддаддддддадддддддддд╢
ЁDescri┤└o ЁVerifica se existe o funcionario                             Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁParametrosЁ ExpC - Tipo da busca do funcionario PIS/Matricula 			 Ё
Ё          Ё ExpC - Alias da tabela de marcacao 						 Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁRetorno   Ё ExpL - Verdadeiro ou Falso                            	     Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
ЁObserva┤└oЁ Posiciona na tabela SRA para leitura dos funcionarios 	     Ё
цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢
Ё Uso      ЁPONA030                                                      Ё
юддддддддддаддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды/*/
Function PN030BscFunc(cTpLMarc, cAliasMSA, cPis, cCracha, cRAFilial, cCPF, cFilMarc, cRAMat)
	
	Local lRet			:= .T.
	Local cPisAux		:= ""
	Local cAliasSRA		:= GetNextAlias()
	Local cFilSRA		:= ""
	Local cMatSRA		:= ""
	Local cWhere		:= ""
	Local cCatQuery		:= ""
	Local cSitQuery		:= ""
	Local lCaClockIn	:= SuperGetMv( "MV_APICLO0" , NIL , .F. )
	Local lRelCarol		:= (Empty(SP0->P0_REP) .And. SP0->P0_TIPOARQ == "R")
	Local nI			:= 0
	Local cMemoQuery	:= ""
	Local lMemoCalc		:= GetlMemoCalc()
	Local nTabs			:= 0
	Local lPW			:= .F.
	Local lPWMultV		:= .F.
	
	DEFAULT cRAFilial	:= ""
	DEFAULT cCPF 		:= ""
	DEFAULT cFilMarc	:= ""
	DEFAULT cRAMat		:= ""
	
	l671RR1MSA := If(l671RR1MSA == NIL, fValid671(If(lIntegRR1, 1, 2)), l671RR1MSA)
	
	cPis	:= Padr(AllTrim(StrZero(Val(( cAliasMSA )->COD_PIS_MSA),Len(SRA->RA_PIS))),Len(SRA->RA_PIS))
	cPisAux := If( Left( cPis , 1) = "0", Right(cPis,Len(cPis)-1), cPis )
	cCracha := ""
	lPW := AllTrim((cAliasMSA)->COD_UNID_EXT_CHAVE) == "PONTOWEB"
	lPWMultV := lPW .And. (Empty((cAliasMSA)->COD_FUNC_MSA) .Or. Empty((cAliasMSA)->COD_USUAR_EXT_CHAVE))
	
	If l671RR1MSA
		cCPF	:= ( cAliasMSA )->COD_CPF_FUNC
		If Val(cPis) == 0
			cPis := ""
			cPisAux := ""
		EndIf 
	EndIf
	
	If Empty(cPis) .And. Empty(cCPF)
		Return .F.
	EndIf
	
	If !(lCaClockIn .And. lRelCarol) .And. !lPW
		cWhere  := "% SRA.RA_CRACHA <> '" + Space(TamSX3("RA_CRACHA")[1]) + "' AND ( "
	Else
		cWhere  := "% ( "
	EndIf
	
	If !lPW .And. lRelCarol .And. !Empty(cFilMarc) .And. (!Empty(cPis) .Or. !Empty(cCPF))
		cWhere += "SRA.RA_FILIAL = '" + xFilial("SRA", cFilMarc) + "' AND ("
		If !Empty(cPis) .And. !Empty(cCPF)
			cWhere += "SRA.RA_PIS = '" + cPis + "' OR SRA.RA_CIC = '" + cCPF + "'"
		ElseIf !Empty(cPis) .And. Empty(cCPF)
			cWhere += "SRA.RA_PIS = '" + cPis + "'"

			If (cPis <> cPisAux, cWhere += " OR SRA.RA_PIS = '" + cPisAux + "'", Nil)
		Else
			cWhere += "SRA.RA_CIC = '" + cCPF + "'"
		EndIf
		cWhere += ")"
	ElseIf !lPW .And. SP0->P0_NOVO == "1" .Or. ((lCaClockIn .And. lRelCarol) .Or. (lPW .And. lPWMultV))
		If !Empty(cPis)
			cWhere += " SRA.RA_PIS = '" + cPis + "'"
			If cPis <> cPisAux
				cWhere += " OR SRA.RA_PIS = '" + cPisAux + "'"
			Endif
		EndIf
		If l671RR1MSA .And. !Empty(cCPF)
			cWhere += If(!Empty(cPis), " OR ", "") + " SRA.RA_CIC = '" + cCPF + "'"
		EndIf
	Else
		// Configuracao do parametro cTplMarc
		//1-Busca pelo PIS ( RA_PIS - COD_PIS_MSA )
		//2-Busca pela chave externa (Empresa+RA_FILIAL+RA_MAT - COD_USUAR_EXT_CHAVE)
		If !lPW .And. cTplMarc == "1"
			If !Empty(cPis)
				cWhere += " SRA.RA_PIS = '" + cPis + "'"
				If cPis <> cPisAux
					cWhere += " OR SRA.RA_PIS = '" + cPisAux + "'"
				Endif
			ElseIf l671RR1MSA .And. !Empty(cCPF)
				cWhere += " SRA.RA_CIC = '" + cCPF + "'"
			EndIf 
			
		ElseIf cTplMarc == "2" .Or. lPW

			If cEmpAnt <> Left(AllTrim(( cAliasMSA )->COD_USUAR_EXT_CHAVE), Len(cEmpAnt))
				lRet := .F.
			EndIf
			
			cFilSRA := SubStr(AllTrim((cAliasMSA)->COD_USUAR_EXT_CHAVE), Len(cEmpAnt) + 1, FWGetTamFilial)
			cMatSRA := If(!Empty((cAliasMSA)->COD_FUNC_MSA), AllTrim((cAliasMSA)->COD_FUNC_MSA), SubStr((cAliasMSA)->COD_USUAR_EXT_CHAVE, Len(cEmpAnt) + FWGetTamFilial + 1))
			
			cWhere += " SRA.RA_FILIAL = '" + cFilSRA + "' AND SRA.RA_MAT = '" + cMatSRA + "'"
			
		Endif
		
	EndIf
	
	For nI:=1 to Len(cCategoria)
		cCatQuery += "'"+Subs(cCategoria,nI,1)+"'"
		If ( nI+1) <= Len(cCategoria)
			cCatQuery += ","
		EndIf
	Next 
	
	For nI:=1 to Len(cSituacoes)
		cSitQuery += "'" + Subs(cSituacoes,nI,1) + "'"
		If (nI+1) <= Len(cSituacoes)
			cSitQuery += ","
		EndIf
	Next
	
	cWhere += ") AND RA_CATFUNC IN (" + cCatQuery + ") "
	cWhere += "AND RA_SITFOLH IN (" + cSitQuery + ") "
	If !lSP0Comp
		cWhere += "AND RA_FILIAL >= '" + cFilDe + "' "
		cWhere += "AND RA_FILIAL <= '" + cFilAte + "' "
	EndIf 
	cWhere += "AND RA_MAT >= '" + cMatDe + "' "
	cWhere += "AND RA_MAT <= '" + cMatAte + "' "
	cWhere += "AND RA_TNOTRAB >= '" + cTurnoDe + "' "
	cWhere += "AND RA_TNOTRAB <= '" + cTurnoAte + "' "
	cWhere += "AND RA_REGRA >= '" + cRegDe + "' "
	cWhere += "AND RA_REGRA <= '" + cRegAte + "' "
	cWhere += "AND RA_CC >= '" + cCCDe + "' "
	cWhere += "AND RA_CC <= '" + cCCAte + "' %"
	
	If lRet
		BeginSql alias cAliasSRA
			SELECT RA_CRACHA, RA_MAT, RA_FILIAL
			FROM %table:SRA% SRA
			WHERE %exp:cWhere%
			  AND SRA.D_E_L_E_T_  = ' '
			ORDER BY RA_CATFUNC DESC
		EndSql
		
		If lMemoCalc
			GravaMCalc("01", 3, STR0082) // "Query para identificar o funcionАrio: "
			cMemoQuery := GetlastQuery()[2]
			nTabs := 4
			While Len(cMemoQuery) > 0
				GravaMCalc("01", nTabs, Left(cMemoQuery, 254), .F.)
				cMemoQuery := SubStr(cMemoQuery, 255)
				nTabs := 0
			EndDo
			//Quebra de linha
			GravaMCalc("01", 0, "")
		EndIf
		
		If ( cAliasSRA )->( Eof() )
			If (lCaClockIn .And. Empty(SP0->P0_REP) .And. SP0->P0_TIPOARQ == "R")
				lRet := .F.
			Else	
				M->cErrSp0GetInf := "ERRO"
			EndIf
			If lMemoCalc
				GravaMCalc("01", 3, STR0083) // "FuncionАrio nЦo encontrado."
			EndIf
		Else
			cCracha := ( cAliasSRA )->RA_CRACHA
			If lCaClockIn .And. lRelCarol .Or. lPW
				If Empty(cCracha) 
					cCracha := ( cAliasSRA )->RA_MAT
				EndIf
				If (Empty(cFilMarc) .And. lRelCarol) .Or. lPWMultV
					cRAFilial := ""
				Else
					cRAFilial := ( cAliasSRA )->RA_FILIAL
				EndIf
				If lPW .And. !lPWMultV
					cRAMat := (cAliasSRA)->RA_MAT
				EndIf
			EndIf
			If lMemoCalc
				GravaMCalc("01", 3, STR0084 + (cAliasSRA)->RA_FILIAL + " - " + (cAliasSRA)->RA_MAT + ", CrachА: " + cCracha ) // "FuncionАrio encontrado: "
			EndIf
		EndIF
		
		(cAliasSRA)->(dbCloseArea())
		
	Endif
	
Return lRet

/*/{Protheus.doc} fMigrRR1
Efetua migraГЦo dos registros da MSA_CONTROL_MARCAC para a tabela RR1
@author allyson.mesashi
@since 05/10/2020
@version P12.1.27
/*/
Function fMigrRR1()

Local cAliasMSA	:= GetNextAlias()
Local lMigra		:= .T.
Local lOk			:= .T.
Local lCposMSA		:= .F.
Local lCposRR1		:= RR1->(ColumnPos( "RR1_CODCPF") > 0 .And. ColumnPos( "RR1_FUSO"  ) > 0 .And. ColumnPos( "RR1_VRSLAY") > 0 .And. ColumnPos( "RR1_INSCR" ) > 0 .And. ColumnPos( "RR1_CCTREP" ) > 0)
Local lExtFilMsa	:= .F.

If TCCanOpen("MSA_CONTROL_MARCAC")
	If !( TCSQLExec("Select * FROM MSA_CONTROL_MARCAC") >= 0)
		Return .T.
	Endif
Else
	Return .T.
EndIf

lExtFilMsa := fVldMSAFil()

BeginSql alias cAliasMSA
	SELECT * FROM MSA_CONTROL_MARCAC MSA
EndSql

RR1->( dbSetOrder(6) )
If (cAliasMSA)->( !Eof() ) .And. RR1->( dbSeek( Str( (cAliasMSA)->VAL_CONTROL_MARCAC, 16 ) ) )
	lMigra	:= .F.
EndIf

lCposMSA := TCSQLExec("SELECT COD_FUSO, COD_CPF_FUNC, NUM_VERS_LAYOUT_AFD, COD_INSCR_EMP, COD_CCT FROM MSA_CONTROL_MARCAC") >= 0

// Caso exista os novos campos na MSA, mas nЦo exista na RR1 nЦo faz a migraГЦo
If( lCposMSA .And. !lCposRR1, lMigra := lOk := .F., )

If lMigra
	While (cAliasMSA)->( !Eof() )
		If !RR1->( dbSeek( Str( (cAliasMSA)->VAL_CONTROL_MARCAC, 16 ) ) )
			If RR1->( RecLock("RR1", .T.) )
				If lExtFilMsa
					RR1->RR1_FILIAL	:= (cAliasMSA)->COD_FIL_MARC
				EndIf
				RR1->RR1_VALCON		:= (cAliasMSA)->VAL_CONTROL_MARCAC
				RR1->RR1_CODREL		:= Iif( AllTrim( (cAliasMSA)->COD_RELOGIO_EXT_CHAVE ) != "NULL", (cAliasMSA)->COD_RELOGIO_EXT_CHAVE, "" )
				RR1->RR1_CODFUN		:= Iif( AllTrim( (cAliasMSA)->COD_FUNC_MSA ) != "NULL", (cAliasMSA)->COD_FUNC_MSA, "" )
				RR1->RR1_LOGIP		:= AllTrim( Str( (cAliasMSA)->LOG_IMPORT_PRODUT ) )
				RR1->RR1_CODNSR		:= (cAliasMSA)->COD_NSR
				RR1->RR1_CODPIS		:= Iif( AllTrim( (cAliasMSA)->COD_PIS_MSA ) != "NULL", (cAliasMSA)->COD_PIS_MSA, "" )
				RR1->RR1_DATMAR		:= (cAliasMSA)->DAT_MARCAC_ACES
				RR1->RR1_NUMMAR		:= (cAliasMSA)->NUM_HORAR_MARCAC_ACES
				RR1->RR1_CODREP		:= (cAliasMSA)->COD_REP
				RR1->RR1_CODUNI		:= Iif( AllTrim( (cAliasMSA)->COD_UNID_EXT_CHAVE ) != "NULL", (cAliasMSA)->COD_UNID_EXT_CHAVE, "" )
				RR1->RR1_CODUSU		:= Iif( AllTrim( (cAliasMSA)->COD_USUAR_EXT_CHAVE ) != "NULL", (cAliasMSA)->COD_USUAR_EXT_CHAVE, "" )
				If lCposMSA .And. lCposRR1
					RR1->RR1_FUSO	:= Iif( AllTrim( (cAliasMSA)->COD_FUSO ) != "NULL", (cAliasMSA)->COD_FUSO, "" )
					RR1->RR1_CODCPF	:= Iif( AllTrim( (cAliasMSA)->COD_CPF_FUNC ) != "NULL", (cAliasMSA)->COD_CPF_FUNC, "" )
					RR1->RR1_VRSLAY	:= Iif( AllTrim( (cAliasMSA)->NUM_VERS_LAYOUT_AFD ) != "NULL", (cAliasMSA)->NUM_VERS_LAYOUT_AFD, 0 )
					RR1->RR1_INSCR	:= Iif( AllTrim( (cAliasMSA)->COD_INSCR_EMP ) != "NULL", (cAliasMSA)->COD_INSCR_EMP, "" )
					RR1->RR1_CCTREP	:= Iif( AllTrim( (cAliasMSA)->COD_CCT ) != "NULL", (cAliasMSA)->COD_CCT, "" )
				EndIf
				RR1->( MsUnlock() )
				TcSqlExec("DELETE FROM MSA_CONTROL_MARCAC WHERE VAL_CONTROL_MARCAC = '" + cValToChar( (cAliasMSA)->VAL_CONTROL_MARCAC ) + "'")
			Else
				lOk		:= .F.
			EndIf
		EndIf
		(cAliasMSA)->( dbSkip() )
	EndDo
	If lOk
		TCSQLExec("DROP TABLE MSA_CONTROL_MARCAC")
	EndIf
EndIf

(cAliasMSA)->( dbCloseArea() )

Return lOk

/*/{Protheus.doc} fValid671
Valida se os novos campos da RFE para a portaria 671 existem.
@author Marco.Nakazawa
@since 05/05/2022
@version P12.1.27
@param nRR1MSA, NumИrico, Define se verifica as  tabelas RR1 ou MSA_CONTROL_MARCAC
/*/
Function fValid671(nRR1MSA)
	
	Local lOk		:= .F.
	
	Default nRR1MSA := 0
	
	DbSelectArea("RFE")
	If RFE->(ColumnPos("RFE_TPREG")) > 0 .And. RFE->(ColumnPos("RFE_CPF")) > 0 .And. RFE->(ColumnPos("RFE_IDMARC")) > 0 .And. RFE->(ColumnPos("RFE_MARCON")) > 0 .And. RFE->(ColumnPos("RFE_SRH256")) > 0 .And. RFE->(ColumnPos("RFE_CRC")) > 0 .And. RFE->(ColumnPos("RFE_DTGVMA")) > 0 .And. RFE->(ColumnPos("RFE_FUSO")) .And. RFE->(ColumnPos("RFE_CCTREP"))
		lOk := .T.
	EndIf
	
	RFE->(dbCloseArea())
	
	If nRR1MSA == 1 // Verifica RR1
		DbSelectArea("RR1")
		If RR1->(ColumnPos( "RR1_CODPIS") > 0 .And. ColumnPos( "RR1_FUSO"  ) > 0 .And. ColumnPos( "RR1_VRSLAY") > 0 .And. ColumnPos( "RR1_INSCR" ) > 0 .And. ColumnPos( "RR1_CCTREP" ) > 0)
			lOk := .T.
		Else
			lOk := .F.
		EndIf
	ElseIf nRR1MSA == 2 // Verifica MSA
		If TCSQLExec("SELECT COD_FUSO, COD_CPF_FUNC, NUM_VERS_LAYOUT_AFD, COD_INSCR_EMP, COD_CCT FROM MSA_CONTROL_MARCAC") >= 0
			lOk := .T.
		Else
			lOk := .F.
		EndIf
	EndIf
	
Return lOk

/*/{Protheus.doc} fGetNumCPF
Retorna o 11╨ nЗmero do CPF
@type  Static Function
@author CМcero Alves
@since 30/09/2022
@param cCPF, Caractere, NЗmeros do CPF
@return cLastN, Caractere, зltimo dМgito do CPF
/*/
Static Function fGetNumCPF(cCPF)
	
	Local cLastN 	:= ""
	Local nFator 	:= 11
	Local nXCPF		:= 0
	Local nDigito
	Local nI
	
	DEFAULT cCPF := ""
	
	If Len(cCPF) >= 10
		For nI := 1 To 10
			nDigito := Val(SubStr(cCPF, nI, 1))
			nXCPF += nDigito * nFator--
		Next nI
		
		nXCPF := nXCPF - Int( nXCPF / 11 ) * 11
		
		nXCPF := If(nXCPF <= 1, 0, 11 - nXCPF)
		
		cLastN := CValToChar(nXCPF)
	EndIf
	
Return cLastN

/*/{Protheus.doc} LimpaNSR
inclui um registro na tabela RFB com o NSR 0 
@type  Static Function
@author CМcero
@since 25/04/2023
/*/
Static Function LimpaNSR()
	
	Local aArea 	:= GetArea()
	Local nTamArq	:= GetSx3Cache( "RFB_ARQ   ", "X3_TAMANHO" )
	Local cDataAux	:= DtoS(MsDate())
	Local cHoraAux	:= Time()
	Local cDtHrLi	:= SUBSTR(cDataAux,3,2) + SUBSTR(cDataAux,5,2) + SUBSTR(cDataAux,7,2) + SUBSTR(cHoraAux,1,2) + SUBSTR(cHoraAux,4,2) //-- AAMMDDHHMM
	
	//"Esta opГЦo irА excluir a Зltima NSR lida deste relСgio, este procedimento deve ser realizado apenas em casos onde, ao passar por manutenГЦo, o REP teve o controle de NSR reiniciado."
	If MsgNoYes(STR0060 + CRLF + CRLF +  STR0061, STR0017) // "Deseja continuar?" - "AtenГЦo!"
		
		dbSelectArea("RFB")
		If RecLock( "RFB", .T. )
			RFB->RFB_FILIAL  := SP0->P0_FILIAL
			RFB->RFB_ORIG    := SP0->P0_FILIAL
			RFB->RFB_RELOGI  := SP0->P0_RELOGIO
			RFB->RFB_NUMREP  := SP0->P0_REP
			RFB->RFB_DTHRLI  := cDtHrLi
			RFB->RFB_ARQ     := PADR(SP0->P0_ARQUIVO, nTamArq)
			RFB->RFB_TIPARQ  := If(SP0->P0_TIPOARQ == "T", "1", "2")
			RFB->RFB_DTHRG   := cDtHrLi
			RFB->RFB_DTHRLF  := cDtHrLi
			RFB->RFB_IDORG   := StrZero(0, Len(RFB->RFB_IDORG)) //Grava como zero
			RFB->RFB_ORIGEM  := "1"
			RFB->RFB_USUARI := __cUserId
			RFB->(MsUnLock())
		EndIf
		
		// "Registro alterado." - "Ao executar a leitura das marcaГУes o sistema irА buscar pelo primeiro NSR do arquivo"
		MsgInfo(STR0062 + CRLF + STR0063)
		
	EndIf
	
	RestArea(aArea)
	
Return

Static Function SP0GetCSV(aLinha, nCol, cForm)
	
	Local cRet	:= ""
	Local nLenLinha := 0
	
	DEFAULT aLinha := {}
	DEFAULT nCol := 0
	
	If !Empty(cForm)
		Return(Sp0ExecForm(cForm))
	EndIf
	
	nLenLinha := Len(aLinha)
	
	If nCol > 0 .And. nLenLinha > 0 .And. nCol <= nLenLinha
		cRet := AllTrim(aLinha[nCol])
	EndIf
	
Return cRet

/*/{Protheus.doc} formatData
Formata a data lida do arquivo CSV de acordo com o campo P0_TPDATA
@type static function
@author CМ╜cero Alves
@since 29/05/2025
@param cData, character, data lida do arquivo CSV do relСgio
@param cTipoDt, character, formato da data de acordo com o campo P0_TPDATA
@param nTipoRet, numeric, 1 = Data; 2 = Horas
@return variant, Data quando nTipoRet = 1 e Caractere quando nTipoRet = 2
/*/
Static Function formatData(cData, cTipoDt, nTipoRet)
	
	Local xRet
	
	DEFAULT cData := ""
	DEFAULT cTipoDt := ""
	DEFAULT nTipoRet := 1
	
	If nTipoRet == 1 // Retornar a Data
		
		Do Case 
			Case cTipoDt == "1" // "DD/MM/AAAA"
				xRet := cToD(cData)
			Case cTipoDt == "2" // "AAAA-MM-DD Ou AAAAMMDD"
				cData := StrTran(cData, "-", "")
				xRet := sToD(cData)
			Case cTipoDt == "3" // "DD/MM/AAAA hh:mm:ss"
				cData := Left(cData, 10)
				xRet := cToD(cData)
			Case cTipoDt == "4" // "AAAA-MM-DDThh:mm:ss Ou AAAA-MM-DDThh:mm:ssTZD"
				cData := Left(cData, 10)
				cData := StrTran(cData, "-", "")
				xRet := sToD(cData)
		EndCase
		
	Else // Retornar a Hora
		
		Do Case
			Case cTipoDt == "3" // "DD/MM/AAAA hh:mm:ss"
				cData := Right(cData, 8)
				xRet := Left(cData, 5)
			Case cTipoDt == "4" // "AAAA-MM-DDThh:mm:ss Ou AAAA-MM-DDThh:mm:ssTZD"
				cData := StrTran(cData, "-", "")
				cData := StrTran(cData, "T", "")
				xRet := SubStr(cData, 9, 8)
		EndCase
		
	EndIf
	
Return xRet

/*/{Protheus.doc} formatHora
Formata as horas lidas do arquivo CSV do relСgio e retorna as horas ou os minutos
@type static function
@author CМ╜cero Alves
@since 29/05/2025
@param cHora, character, Hora lida do CSV
@param nTipoRet, numeric, 1 = Hora ; 2 = Minutos
@return caractere, Hora ou Minutos de acordo com o nTipoRet
/*/
Static Function formatHora(cHora, nTipoRet)
	
	Local cRet 		:= ""
	Local cMin 		:= "00"
	Local nMin		:= 0
	Local nHoras	:= 0
	
	DEFAULT cHora := ""
	DEFAULT nTipoRet := 1
	
	If !Empty(cHora)
		If !(":" $ cHora .Or. "." $ cHora)
			nHoras := Val(cHora)
			cHrs 	:= StrZero( Int( nHoras / 3600 ), 2)
			nMin 	:= (nHoras / 3600) - Int( nHoras / 3600)
			If nMin > 0
				cMin := StrZero(Int( Round( nMin * 60, 0 )), 2)
			EndIf
			cHora := cHrs + ":" + cMin
		EndIf
		
		If Len(cHora) > 5 
			cHora := Left(cHora, 5)
		EndIf
		
		Do Case
			Case nTipoRet == 1 // Retorna apenas a hora 
				cRet := Left(cHora, 2)
			Case nTipoRet == 2 // Retorna apenas os minutos
				cRet := Right(cHora, 2)
		EndCase
	EndIf
	
Return cRet
