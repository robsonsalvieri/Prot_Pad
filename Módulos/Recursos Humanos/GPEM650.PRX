#INCLUDE "PROTHEUS.CH"
#INCLUDE "GPEM650.CH"
#INCLUDE "Report.ch"

Static aInssEmp		:= If( Type("aInssEmp") == "A", aInssEmp, {} ) // Array com os dados do parametro 14
Static lGp650Chk 	:= ExistBlock("GP650CHK")
Static lGp650Cpo 	:= ExistBlock("GP650CPO")
Static lGp650Acm	:= ExistBlock("GP650ACM")
Static lRc1Arelin 	:= RC1->( FieldPos('RC1_ARELIN') ) > 0
Static lGP650CFO    := ExistBlock("GP650CFO")
Static lCtrlTit		:= !Empty(GetNewPar("MV_BTITRES", "" )) .And. !Empty(GetNewPar("MV_BTITFOL", "" )) .And. !Empty(GetNewPar("MV_BTITADT", "" )) .And. !Empty(GetNewPar("MV_BTITFER", "" ))
Static lTamTitDif   := ChkFile("RJ1") .And. TamSX3( "RC1_NUMTIT" )[1] <> TamSX3( "RJ1_NUMTIT" )[1]
Static lMsgRJ1      := .T.

Static cFilLastNum	:= ""
Static lTitLog1 := .F.
Static lTitLog2 := .F.
Static lTitLog3 := .F.

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ GPEM650  ³ Autor ³ Emerson Rosa de Souza ³ Data ³ 09/08/01 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Gera Movimentacao de Titulos no arquivo RC1                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³         ATUALIZACOES SOFRIDAS DESDE A CONSTRU€AO INICIAL.             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Programador ³ Data   ³ BOPS ³  Motivo da Altera‡„o                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Cecilia H Y ³15/05/13³M12RH01³Unificacao da Folha de Pagamento         ³±±
±±³Flavio Correa³07/05/14³TPKHR3³Replica V11 Desoneração   				. ³±±
±±³Gustavo M.  ³02/07/14³TPYCXG³Ajuste para nao fixar o valor com a inte- ³±±
±±³            ³        ³      ³gracao com o logix ativada.				  ³±±
±±³Alberto M   ³19/08/14³TPXWQ2³Inclusao do campo de Cod. Retencao para   ³±±
±±             ³        ³      ³geracao de titulo e integracao com Finan  ³±±
±±             ³        ³      ³ceiro.                                    ³±±
±±³Alberto M   ³19/09/14³TPXWQ2³Tratamento de parametros dDataDeT e       ³±±
±±             ³        ³      ³(dDataAteT) tem que sempre estar no mesmo ³±±
±±             ³        ³      ³mes                                       ³±±
±±³Alberto M   ³09/10/14³TPXWQ2³Tratamento para geracao de titulos apenas ³±±
±±             ³        ³      ³usando definicoes(RC0) da filial corrente ³±±
±±³Flavio Corre³22/06/15³TSRHGG³Ajuste na busca da SR para ferias,        ³±±
±±³            ³        ³      ³RR_DATA = RH_DATAINI                      ³±±
±±³Gabriel A.  ³14/10/15³TSXBDD³Alteração para consistir a duplicidade de ³±±
±±³            ³        ³      ³títulos (Réplica)                         ³±±
±±³Gabriel A.  ³07/12/15³TTWPVL³Alterações para: não gerar error log ao   ³±±
±±³            ³        ³      ³gerar título definido por usuário sem     ³±±
±±³            ³        ³      ³informar verba e não gerar títulos em     ³±±
±±³            ³        ³      ³looping quando houver data de vencimento  ³±±
±±³            ³        ³      ³baseada em um registro de uma tabela      ³±±
±±³Gabriel A.  ³10/12/15³TTRWND³Alterações para considerar a data de      ³±±
±±³            ³        ³      ³pagamento no momento da geração do título ³±±
±±³Raquel Hager³07/01/15³TUDZYG³Ajuste na variável cNovoTit (GPEM650) como³±±
±±³            ³        ³      ³private para que, ao possuir os pontos de ³±±
±±³            ³        ³      ³entrada GP650CHK e GP650ACM, sistema pro- ³±±
±±³            ³        ³      ³cesse corretamente, conforme link do tdn. ³±±
±±³Joao Balbino³02/02/16³TUEUB7³Feito ajuste para considerar o filtro 	  ³±±
±±³            ³        ³      ³informado na geração do título 			  ³±±
±±³Esther V.   ³30/05/16³TVFY37³Ajuste na validacao de acesso de filiais  ³±±
±±³            ³        ³      ³do usuario.					 			  ³±±
±±³Raquel Hager³21/09/16³TVUPNJ ³Remoção de validação quanto ao preenchi- ³±±
±±³            ³        ³       ³mento da data de pagamento.			  ³±±
±±³Cícero Alves³26/10/16³TW5891 ³Ajuste para incluir os campos contidos no³±±
±±³            ³        ³       ³cCamposRC0 na query executada na RC0	  ³±±
±±³Oswaldo L.  ³01/02/17³MRH5505³Trativa para que o sistema apenas utiliz³±±
±±³            ³        ³       ³os campos de acordo com o pais conectado³±±
±±³Gabriel A.  ³01/03/17³MRH-  ³Alterações no cadastro automático de      ³±±
±±³            ³        ³5585  ³fornecedores.                             ³±±
±±³Raquel Hager³12/01/17³MRH-4110³Agrupamento por beneficiario na geração ³±±
±±³            ³        ³        ³Tit. Pensão Alimentícia.                ³±±
±±³Cecilia Carv³02/06/17³DRHPAG³Ajuste para nao ocorre error.log para ou- ³±±
±±³            ³        ³-2426 ³tras localizações.                        ³±±
±±³Gabriel A.  ³14/08/17³DRHPAG³Tratamento para gravação de valor do      ³±±
±±³            ³        ³-4948 ³título rateado por Item Contábil.         ³±±
±±³João Balbino³07/12/17³      ³MPRIMESP-12652 -Definição da variavel     ³±±
±±³            ³        ³      ³cAcessaSRD para não gerar error log       ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function GPEM650(lAutomato)
	Local nOpca 	   := 0
	Local aSays 	   :={ }
	Local aButtons	:= { } // arrays locais de preferencia
	Local aFilterExp :=  {} //Expressao de filtro
	Local nI := 0
	Local lSched		:= FwIsInCallStack("WFLAUNCHER") .or. FwIsInCallStack("FWBOSCHDEXECUTE")

	DEFAULT lAutomato := .F.

	Private lRobo		:= IIf(Valtype(lAutomato) == "L", lAutomato, .F.)
	Private aRetFiltro
	Private cRC0Filter

	Private cCadastro := OemToAnsi(STR0001) //"Geracao de Titulos"
	Private cTitulo   := OemToAnsi(STR0001) //"Geracao de Titulos"
	Private cTipoCont := 3                  // Tipo de Contabilizacao: 1-Folha Pagamento;2-Provisao;3-Ambas
	Private lDrop	 := .F.
	Private cAnoMes	 := ""

	Private nTpImpre := 2

	Private aLogFile	:= {}
	Private aLogTitle	:= {}

	Private cGeraBen	:= ""

	Private cChvsRJ1	:= ""
	Private lCpoInteg	:= ChkFile("RJ1") .And. RJ1->(ColumnPos( "RJ1_ROTEIR")) > 0 .And. RJ1->(ColumnPos( "RJ1_PROCES")) > 0 .And. RJ1->(ColumnPos( "RJ1_TIPO")) > 0

	Pergunte("GPM650",.F.)

	lTitLog1 := .F.
	lTitLog2 := .F.

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Funcao verifica se existe alguma restrição de acesso para o³
	//³usuário que impeça a execução da rotina.                   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If !(fValidFun({"RC1","RC0","CTT","SRZ","SRT","SRG","SRH"}))
		Return( nil )
	Endif

	// Verifica se registros RJ1 estão com dados atualizados
	If lCtrlTit
		If !fVldRJ1()
			If !fAlertRJ1()
				Return()
			EndIf
		EndIf
	EndIf

	/* Retorne os Filtros que contenham os Alias Abaixo */
	aAdd( aFilterExp , { "FILTRO_ALS" , "RC0"     	, NIL , NIL } )
	/* Que Estejam Definidos para a Função */
	aAdd( aFilterExp , { "FILTRO_PRG" , FunName() 	, NIL , NIL    } )

	AADD(aSays,OemToAnsi( STR0002 )) //"Este programa gera titulos no  arquivo  de  movimentos (RC1) a partir do cadastro de"
	AADD(aSays,OemToAnsi( STR0003))  //"definicoes (RC0). Apos gerados, estarao disponiveis para consultas e integracao com "
	AADD(aSays,OemToAnsi( STR0004))  //"o financeiro.                           											 "

	AADD(aButtons, { 17,.T.,{|| aRetFiltro := FilterBuildExpr( aFilterExp ) } } )
	AADD(aButtons, { 5,.T.,{|o| Pergunte("GPM650",.T. ) } } )
	AADD(aButtons, { 1,.T.,{|o| nOpca := 1, If(GPM650OK(),FechaBatch(), nOpca:=0 ) }} )
	AADD(aButtons, { 2,.T.,{|o| FechaBatch() }} )

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Inicializa a gravacao dos lancamentos do SIGAPCO        ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	PcoIniLan("000092")

	If !(IsBlind()) .And. !lRobo
		FormBatch( cCadastro, aSays, aButtons )

		// Se o usuário escolher não executar em segundo plano ou o sistema não estive apto para isso, executa o processamento em tela
		If (nOpca == 1 .and. !GPESmartViewUtils():ValidBackGExec("GPEM650", 7, {MV_PAR01, MV_PAR02, MV_PAR03, MV_PAR04, MV_PAR05, MV_PAR06, MV_PAR07, MV_PAR08, MV_PAR09, MV_PAR10, MV_PAR11, MV_PAR12, MV_PAR13, aRetFiltro}))
			ProcGpe({|lEnd| GPM650Proc()})
		EndIf
	ElseIf (lSched)
		Processa({|| GPM650Proc(lSched)})
	Else
		GPM650Proc()
	EndIf

	If !Empty(aLogFile)
		AAdd(aLogTitle ,{OemToAnsi(STR0022)})
		ASort(aLogFile,,,{|x,y| x[1] < y[1]}) // Ordena o Log de duplicidade de títulos e do cadastro de fornecedores

		For nI := 1 To Len(aLogFile)
			ADel(aLogFile[nI],1)
		Next nI

		If (lSched)
			GPESmartViewUtils():CreateLog(aLogFile, aLogTitle, "GPEM650")
		Else
			fMakeLog( aLogFile, aLogTitle, "GPEM650", NIL, FunName())
			aLogFile := {}
		EndIf

	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Finaliza a gravacao dos lancamentos do SIGAPCO          ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	PcoFinLan("000092")

Return Nil

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³GPM650Proc³ Autor ³ Emerson Rosa de Souza ³ Data ³ 04.08.01 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Programa de geracao de Titulos				                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ GPM650Proc()  			                                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ 							                                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³                                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Static Function GPM650Proc(lSched As Logical)

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Define Variaveis LOCAIS DO PROGRAMA                          ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	Local cAlias    := ALIAS()
	Local cTitProc  := ""
	Local nCnt      := 0
	Local nCnt1     := 0
	Local nFol13Sal := 0
	Local nNroSem   := 0
	Local lCabec    := .F.
	Local lVenc    := .F.
	Local cCpoPadRC1 := ""
	Local cCposRC0  := ""
	Local cRC1Cpo   := ""
	Local cRC1Conf  := ""
	Local nRecnoRC1 := 0

	Local aArea			:= GetArea()
	Local aAreaSM0		:= SM0->( GetArea() )
	Local cCodEmp		:= SM0->M0_CODIGO
	Local cModoRC0		:= ""
	Local aFilProc		:= {}
	Local nCont			:= 0
	Local nFatDes 		:= 0
	Local nFatFol 		:= 0
	Local nFatTot 		:= 0
	Local nFilial		:= 0
	Local nProp			:= 0
	Local cRecFatEmp	:= ""
	Local aTabS033		:= {}
	Local lRecDesTot	:= .F.
	Local lRec2DesTot	:= .F.
	Local lChkRHH 		:= Sx2ChkTable( "RHH" )
	Local cWhereRC0 	:= ""
	Local cCamposRC0 	:= ""
	Local cChave		:= ""
	Local cChaveAnt     := ""
	Local nTamFilRC0	:= 0
	Local nTamFilDe		:= 0
	Local nTamFilATe	:= 0
	Local lRC0Exclus	:= !(FWModeAccess( "RC0", 1 )+FWModeAccess( "RC0", 2 )+FWModeAccess( "RC0", 3 ) == "CCC")

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Define Variaveis PRIVATE DO PROGRAMA                         ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	Private aCposUsu    := {}
	Private dDataVenc   := CTOD("")
	Private cAliasCC    := "CTT"
	Private lSrz		:=	.F.
	Private aPerAberto  := {}
	Private aPerFechado := {}
	Private cProcesso   := ""
	Private cRoteiro    := ""
	Private lConsiste   := SuperGetMv("MV_CONDUPL",,.F.) //.T. - Consiste / .F. - Não consiste
	Private cChaveDup   := SuperGetMv("MV_CHAVDUP",,"1") //"1" - Chave sem data de vencimento / "2" - Chave com data de vencimento
	Private aRatTit     := {}
	Private cAliasRC0 	:= ""
	Private aTipContra	:= {1, 2, 3}
	Private cInssDev	:= ""

	// Definição dos valores padrão
	DEFAULT lSched := .F.

	_SetOwnerPrvt(	"aAliasFields"	, {} )

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Variaveis utilizadas para parametros                          ³
	//³ mv_par01        //  Filial De                                 ³
	//³ mv_par02        //  Filial Ate                                ³
	//³ mv_par03        //  Centro de Custo De                        ³
	//³ mv_par04        //  Centro de Custo Ate                       ³
	//³ mv_par05        //  Matricula De                              ³
	//³ mv_par06        //  Matricula Ate                             ³
	//³ mv_par07        //  Dt. Busca Pagto De                        ³
	//³ mv_par08        //  Dt. Busca Pagto Ate                       ³
	//³ mv_par09        //  Codigo Titulo De                          ³
	//³ mv_par10        //  Codigo Titulo Ate                         ³
	//³ mv_par11        //  Data de Emissao                           ³
	//³ mv_par12        //  Competencia                               ³
	//³ mv_par13        //  Data de vencimento                        ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	cFilDeT     := mv_par01
	cFilAteT    := mv_par02
	cCCDeT      := mv_par03
	cCCAteT     := mv_par04
	cMatDeT     := mv_par05
	cMatAteT    := mv_par06
	dDataDeT    := mv_par07
	dDataAteT   := mv_par08
	cCodTitDe   := mv_par09
	cCodTitAte  := mv_par10
	dDtEmisTit  := mv_par11
	cCompetTit  := mv_par12
	dVctoInf	 := mv_par13
	cAnoMes    :=substr(cCompetTit,3,4)+substr(cCompetTit,1,2)

	// Quando executado pelo Schedule, captura o filtro
	If (lSched)
		aRetFiltro := MV_PAR14
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Campos do RC1 (padrao do sistema)				                  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If cpaisloc == "BRA"

		cCpoPadRC1 := "RC1_FILIAL/RC1_INTEGR/RC1_FILTIT/RC1_CODTIT/RC1_DESCRI/RC1_PREFIX/"+;
					"RC1_NUMTIT/RC1_TIPO/RC1_NATURE/RC1_FORNEC/RC1_EMISSA/RC1_VENCTO/"  +;
					"RC1_VENREA/RC1_VALOR/RC1_DTBUSI/RC1_DTBUSF/RC1_CODRET/RC1_LOJA"
	Else

		cCpoPadRC1 := "RC1_FILIAL/RC1_INTEGR/RC1_FILTIT/RC1_CODTIT/RC1_DESCRI/RC1_PREFIX/"+;
					"RC1_NUMTIT/RC1_TIPO/RC1_NATURE/RC1_FORNEC/RC1_EMISSA/RC1_VENCTO/"  +;
					"RC1_VENREA/RC1_VALOR/RC1_DTBUSI/RC1_DTBUSF"
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Carrega os Filtros                                 	 	      ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	cRC0Filter	:= GpFltAlsGet( aRetFiltro , "RC0" )

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Variaveis utilizadas para geracao do SRZ via procedure     	³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	lFolPgto    := .F.
	lFol13Sl    := .F.

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Grava no array os campos do usuario criados no arquivo RC0 e ³
	//³ RC1, assegurando que os dois tem o mesmo tipo e tamanho.     ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	dbSelectArea("SX3")
	dbSetOrder(1)
	dbSeek("RC1")
	While !Eof() .And. X3_ARQUIVO == "RC1"
		If !(AllTrim(X3_CAMPO) $ cCpoPadRC1)
			cRC1Cpo   := X3_CAMPO
			cRC1Conf  := X3_TIPO+StrZero(X3_TAMANHO, 3)+StrZero(X3_DECIMAL, 1)
			nRecnoRC1 := RECNO()
			dbSetOrder(2)
			If dbSeek("RC0" + Right(cRC1Cpo, 7))
				If X3_TIPO+StrZero(X3_TAMANHO, 3)+StrZero(X3_DECIMAL, 1) == cRC1Conf
					Aadd(aCposUsu, { "(cAliasRC0)->"+X3_CAMPO, "RC1->" + cRC1Cpo, Nil })
				EndIf
			EndIf
			dbSetOrder(1)
			dbGoTo(nRecnoRC1)
		EndIf
		dbSkip()
	EndDo

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica se existem os campos RC1_CC e RC1_MAT		         ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	dbSelectArea( "RC1" )

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica existencia dos cpos RC0_ALIADV/RC0_CPOBDV/RC0_FILTDV³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	cFilAte := xFilial( "RC0", cFilAteT )

	xRetModo( "RC0" , NIL , .F. , @cModoRC0 , NIL )

	cAliasRC0	:= GetNextAlias()
	cCamposRC0	:= "%RC0_FILIAL, RC0_CODTIT, RC0_TIPTIT, RC0_VERBAS, RC0_DESCRI, RC0_AGRUPA,  "
	cCamposRC0	+= "RC0_DMVENC, RC0_MESPGT, RC0_DSVENC, RC0_FORNEC, RC0_LOJA, RC0_NATURE, RC0_ANTPGT, "
	cCamposRC0	+= "RC0_PREFIX, RC0_TIPO, RC0_FILTRV, RC0_FILTRF, RC0_FILTRD, RC0_ALIAS, RC0_SEQUEN,  "

	If cpaisloc == "BRA"
		cCamposRC0 += "RC0_CODRET, RC0_TPRET, "
		If RC0->(ColumnPos( "RC0_GERBEN")) > 0
			cCamposRC0 += " RC0_GERBEN,"
		EndIf
		cCamposRC0 += " RC0_DIAUTI, RC0_ALIADV, RC0_CPODTV, RC0_FILTDV, RC0_CPODTR"
	Else
		cCamposRC0 += " RC0_DIAUTI, RC0_ALIADV, RC0_CPODTV, RC0_FILTDV, RC0_CPODTR"
	EndIf

	For nCnt1 := 1 To Len(aCposUsu)
		cCamposRC0 += ", " + SubStr(aCposUsu[nCnt1,1], 14)
	Next nCnt1

	cCamposRC0 += "%"

	cWhereRC0 := "%RC0.RC0_FILIAL >= " + "'" + xFilial("RC0",cFilDeT)  + "'" + " AND "
	cWhereRC0 += "RC0.RC0_FILIAL <= " + "'" + xFilial("RC0",cFilATet) + "'" + " AND "
	cWhereRC0 += "RC0.RC0_CODTIT >= " + "'" + cCodTitDe  + "'" + " AND "
	cWhereRC0 += "RC0.RC0_CODTIT <= " + "'" + cCodTitAte + "'" + "%"

	BeginSql alias cAliasRC0
		SELECT %exp:cCamposRC0%
		FROM  %table:RC0% RC0
		WHERE %exp:cWhereRC0% AND RC0.%notDel%
	EndSql

	nTamFilRC0	:= Len(RTrim((cAliasRC0)->RC0_FILIAL))
	nTamFilDe	:= Len(RTrim(cFilDeT))
	nTamFilATe	:= Len(RTrim(cFilAteT))

	If !lRobo .and. !lSched
		GPProcRegua((cAliasRC0)->(RecCount()))
	EndIf

	// Se a execução for pelo Scheduele, define o tamanho da régua de processamento
	If (lSched)
		nTotal := Contar(cAliasRC0, "!EOF()")
		ProcRegua(nTotal)
		(cAliasRC0)->(DBGoTop())
	EndIf

	While (cAliasRC0)->(!EoF())
		cNovoTit 	:= ""

		If !lRobo .and. !lSched
			GPIncProc(STR0010) // "Processando..."
		EndIf

		// Se a execução for pelo Scheduele, incrementa a régua de processamento
		If (lSched)
			IncProc()
		EndIf

		If (cAliasRC0)->RC0_CODTIT < cCodTitDe .Or. (cAliasRC0)->RC0_CODTIT > cCodTitAte
			dbSelectArea((cAliasRC0))
			(cAliasRC0)->(dbSkip())
			Loop
		EndIf

		If !Empty( cRC0Filter )
			If !( &( cRC0Filter ) )
				(cAliasRC0)->( dbSkip())
				Loop
			EndIf
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Verifica existencia da nova tabela de Dissidio Acumulado (RHH) SE a		 ³
		//³ geracao de Titulo for de Dissidio. Se NAO existir a tabela sera			 ³
		//³ apresentada a mensagem informando a necessidade da execucao do update 	 ³
		//³ 150 para a criacao e impede a execucao da geracao somente para o tipo de³
		//³ titulo 006 - INSS - DISSIDIO ate que o update seja executado.		   	    ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If (cAliasRC0)->RC0_TIPTIT == '1' .and. '006' $ AllTrim( (cAliasRC0)->RC0_VERBAS ) .and. !lChkRHH

			Aviso( STR0008, STR0015 + CRLF + STR0016, { STR0017 } )	//"Atencao" ## "Execute a opção do compatibilizador referente à criação da nova tabela de Dissídio Acumulado. Para maiores informações verifique respectivo Boletim Técnico."
																			//"Somente os títulos de tipo 006 - INSS - Dissidio NÃO serão gerados até que o compatibilizador seja executado." ## "OK"

			(cAliasRC0)->( dbSkip())
			Loop
		EndIf

		cFilAtu		:= (cAliasRC0)->RC0_FILIAL
		cCodTit		:= (cAliasRC0)->RC0_CODTIT
		cDescri		:= (cAliasRC0)->RC0_DESCRI
		cAgrupa		:= (cAliasRC0)->RC0_AGRUPA
		cDmVenc		:= (cAliasRC0)->RC0_DMVENC
		cMesPgt		:= (cAliasRC0)->RC0_MESPGT
		cDsVenc		:= (cAliasRC0)->RC0_DSVENC
		cFornec		:= (cAliasRC0)->RC0_FORNEC
		cLoja		:= (cAliasRC0)->RC0_LOJA
		cNature		:= (cAliasRC0)->RC0_NATURE
		cPrefix		:= (cAliasRC0)->RC0_PREFIX
		cTipTit		:= (cAliasRC0)->RC0_TIPTIT
		cIdentTit	:= AllTrim((cAliasRC0)->RC0_TIPO)
		cFiltrLan	:= AllTrim((cAliasRC0)->RC0_FILTRV)
		cFiltrSRA	:= (cAliasRC0)->RC0_FILTRF
		cCpoDtLan	:= Alltrim((cAliasRC0)->RC0_FILTRD)
		cAliasLan	:= If (!Empty( (cAliasRC0)->RC0_ALIAS ),(cAliasRC0)->RC0_ALIAS, "RC0")

		If cpaisloc == "BRA"
			cCodRetTit := (cAliasRC0)->RC0_CODRET
			cTipoRet  := (cAliasRC0)->RC0_TPRET
			If RC0->(ColumnPos( "RC0_GERBEN")) > 0
				cGeraBen  := (cAliasRC0)->RC0_GERBEN
			EndIf
		Else
			cCodRetTit := ""
			cTipoRet  := ""
			cGeraBen  := ""
		EndIf

		cSRACodRet := ""

		lSrz	   := If( cAliasLan == "SRZ" , .T. , .F. )
		cDiaUtil  := (cAliasRC0)->RC0_DIAUTI
		cVerbas   := ""
		lCabec    := .F.
		lVenc    := .F.

		cAliasCab := (cAliasRC0)->RC0_ALIADV
		cCpoDtCab := AllTrim((cAliasRC0)->RC0_CPODTV)
		cFiltrCab := (cAliasRC0)->RC0_FILTDV
		cCpoDtRel := (cAliasRC0)->RC0_CPODTR
		lCabec    := (!Empty((cAliasRC0)->RC0_ALIADV) .And. !Empty((cAliasRC0)->RC0_CPODTV)) .And. ((cAliasRC0)->RC0_ALIAS <> (cAliasRC0)->RC0_ALIADV) .And. Empty(dVctoInf)
		lVenc     := !lCabec .And. (!Empty((cAliasRC0)->RC0_ALIADV) .And. !Empty((cAliasRC0)->RC0_CPODTV) .And. (cAliasRC0)->RC0_ALIAS == (cAliasRC0)->RC0_ALIADV )

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Grava o conteudo dos campos de usuario do RC0 em aCposUsu	   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		For nCnt1 := 1 To Len(aCposUsu)
			cCposRC0          := aCposUsu[nCnt1,1]
			aCposUsu[nCnt1,3] := &cCposRC0
		Next nCnt1

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Calcula data de vencimento do titulo			                  ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		dDataVenc := CTOD("")
		If !Empty(cDmVenc) .And. !Empty(cMesPgt)  // Dia do mes para o vencimento
			If cMesPgt == "3" // Mes Seguinte ao Pagamento
				cNovMes :=  Strzero(Month(dDataDeT),2)
				cNovAno := Str(Year(dDataDeT),4)
				//-- Calcula o mes seguinte a data de apuracao.
				cNovMes := If(cNovMes == "12", "01", StrZero(Val(cNovMes)+1,2))
				cNovAno := If(cNovMes == "01", StrZero(Val(cNovAno)+1,4), cNovAno)
			Else
				cNovMes :=  Left(cCompetTit,2)
				cNovAno := Right(cCompetTit,4)
				If cMesPgt == "2" // Mes Seguinte
					cNovMes := If(cNovMes == "12", "01", StrZero(Val(cNovMes)+1,2))
					cNovAno := If(cNovMes == "01", StrZero(Val(cNovAno)+1,4), cNovAno)
				EndIf
			EndIf

			dDataVenc := CTOD(cDmVenc + "/" + cNovMes + "/" + cNovAno)
			//-- Se gerou um data invalida pois o dia nao existe para o mes gerado
			IF Empty(dDataVenc)
				//-- Assume o maior dia do mes gerado
				dDataVenc:= CTOD(Strzero(F_ULTDIA(Ctod("01/"+cNovMes+"/"+cNovAno)),2) + "/" + cNovMes + "/" + cNovAno)
			Endif

		ElseIf !Empty(cDsVenc)   // Dia da Semana para o vencimento
			nNroSem := If(DOW(dDataAteT) > Len(cDsVenc), 7, 0)
			dDataVenc := (dDataAteT - DOW(dDataAteT) + Val(cDsVenc) + nNroSem)
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Verifica se existem outros registro e os carregas em cVerbas ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		cChave	:= (cAliasRC0)->(RC0_FILIAL+RC0_CODTIT+RC0_SEQUEN)
		If RC0->(dbSeek(cChave))
			While RC0->(!Eof()) .And. RC0->(RC0_FILIAL+RC0_CODTIT+RC0_SEQUEN) == cChave
				cVerbas += AllTrim(RC0->RC0_VERBAS)
				RC0->( dbSkip())
			EndDo
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Geracao dos titulos padroes do sistema                       ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If cTipTit == "1"

			cTitProc := Left(cVerbas,3)

			If cTitProc $ "001*002*007" // INSS * INSS RRA
				If lRC0Exclus // Se RC0 é exclusiva, define o filtro Filial De/Ate que será usado na função fGeraFolSRZ() - GPEM110
					Private cFilConDe	:= xFilial("RC0", (cAliasRC0)->RC0_FILIAL)
					Private cFilConAte	:= PadR(AllTrim(xFilial("RC0",(cAliasRC0)->RC0_FILIAL)), Len(cFilAnt), "Z")
				EndIf
			EndIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Chamada para o programa de geracao do INSS - FOLHA/13o	      ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If cTitProc $ "001*002"
				If cAgrupa = "4"
					Aviso(STR0008, STR0018 + STR0019, {"OK"})
					//"Atencao!"###"Para titulos de INSS nao e permitido o agrupamento por funcionario". Acerte o agrupamento e processe a geracao novamente."
					Return
				EndIf
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Verifica se deve gerar o arquivo SRZ com os valores de INSS	³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				nFol13Sal := If(cTitProc == "001", 1, 2)   // 1-Folha, 2-13o Salario

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Variaveis utilizadas para geracao do SRZ via procedure       ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				lFolPgto    := ( nFol13Sal == 1 ) // Geracao dos registros 'FL' no SRZ
				lFol13Sl    := ( nFol13Sal == 2 ) // Geracao dos registros '13' no SRZ
				Rst040Imp() // Reinicializa static para execucao da procedure

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Carregar os periodos abertos (aPerAberto) e/ou os periodos   ³
				//³ fechados (aPerFechado), de acordo com uma determinada compe- ³
				//³ tencia.                 				                         ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

				fRetPerComp(substr(cCompetTit,1,2),substr(cCompetTit,3,4), Nil, Nil, Nil, @aPerAberto, @aPerFechado)
				cAnoMes:=substr(cCompetTit,3,4)+substr(cCompetTit,1,2)

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Tipo de Geracao na GPS:     1 - CC, 2 - Nivel CC, 3 - Filial ³
				//³ Tipo de Geracao no Titulo:  2 - CC, 3 - Nivel CC, 1 - Filial ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				nPorCc        := If(cAgrupa == "2", 1, If(cAgrupa == "3", 2, 3))
				cNivCCusto    := If( nPorCc == 2, "1", "")
				cTipo         := nFol13Sal

				If !fGeraFolSRZ(nFol13Sal, aTipContra, cCompetTit, aPerAberto, aPerFechado) // 1-Indeterminado, 2-Determinado, 3-Intermitente
					Loop
				EndIf

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Carregando variaveis mv_par?? para Variaveis do Sistema      ³
				//³ Estas variaveis serao utilizadas em GPM240Proc()		         ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				nValAutonomo  := 0.00
				nValProLabore := 0.00
				nValReceita   := 0.00
				nValDedSer    := 0.00
				nValJuros     := 0.00
				cCentra       := Space(FwGetTamFilial)
				cCompetencia  := cCompetTit

				// Processa os contratos.
				// 1-Contrato Indeterminado
				// 2-Determinado
				// 3-Intermitente
				For nCnt := 1 To Len(aTipContra)
					cTpc    := Str(nCnt, 1) //Define o tipo de contrato

					If cModoRC0 == "E"
						cFilIni := cFilAtu
						cFilFim := cFilAtu
					Else
						cFilIni := cFilDeT
						cFilFim := cFilAteT
					EndIf

					aRatTit := {}

					Processa({|lEnd|GPM240Proc(3,@lEnd,,,cFilIni,cFilFim,cCCDeT,cCCAteT,cTpc),STR0009})  //"Gerando arquivo aguarde..."
				Next nCnt

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Chamada para o programa de geracao dos valores de I.R.	      ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			ElseIf cTitProc == "003"
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Carregando variaveis mv_par?? para Variaveis do Sistema      ³
				//³ Estas variaveis serao utilizadas em GR050Imp()		         ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If Empty(xFilial("RC0"))
					cFilDe  := cFilDeT
					cFilAte := cFilAteT
				Else
					If nTamFilRC0 >= nTamFilDe
						cFilDe  := cFilAtu
					else
						cFilDe  := If( RTrim(cFilAtu) == Left(cFilDeT,nTamFilRC0), cFilDeT, cFilAtu)
					EndIf

					If nTamFilRC0 >= nTamFilAte
						cFilAte := cFilAtu
					else
						cFilAte := If( RTrim(cFilAtu) == Left(cFilAteT,nTamFilRC0), cFilAteT, cFilAtu )
					EndIf
				Endif
				cFilAte := PadR(RTrim(cFilAte), FWGETTAMFILIAL, "Z")

				cCCDe 	  := cCCDeT
				cCCAte 	  := cCCAteT
				cMatDe    := cMatDeT
				cMatAte   := cMatAteT
				dDataDe   := dDataDeT
				dDataAte  := dDataAteT
				cNomDe    := Space(30)
				cNomAte   := Replicate("z", 30)
				cSinAna   := "A" // Analitica
				lSalta    := .F.
				nTipImp   := If( cTipoRet == "2", 3, 1) // Tipo Relatorio no programa GPER050
				dVencto   := CTOD("")
				cNumRef   := ""
				cCentra   := ""

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Ordem na Impressao do I.R.: 1 - Mat, 2 - CC,    3 - Nome	   ³
				//³ Ordem na Geracao de titulo: 2 - CC,  3 - Nivel, 1 - Filial   ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				nOrdem	:= If(cAgrupa $ "2*3", 2, 1)
				aRatTit := {}
				GR050Imp(2, .F.,,, cAgrupa,, "GPEM650",, cTipoRet)
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Chamada para o programa de geracao dos valores de PENSAO     ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			ElseIf cTitProc == "004"
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Verifica se existem outros registro com mesmo cod/seq em outras filiais ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If (FwModeAccess('RC0',3) == 'E' .and. FwModeAccess('RC1',3) == 'E') .and. !Empty(cChaveAnt)
					If cChaveAnt == (cAliasRC0)->(RC0_CODTIT+RC0_TIPTIT+RC0_AGRUPA+RC0_SEQUEN)
						(cAliasRC0)->( dbSkip())
						Loop
					EndIf
				EndIf
				cChaveAnt := (cAliasRC0)->(RC0_CODTIT+RC0_TIPTIT+RC0_AGRUPA+RC0_SEQUEN)
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Verifica var referente ao RC0_ALIAS e seta tabela RC0 se vazio.	³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If Empty(cAliasLan)
					cAliasLan := "RC0"
				EndIf
				If Empty(xFilial("RC0"))
					cFilDe  := cFilDeT
					cFilAte := cFilAteT
				Else
					If nTamFilRC0 >= nTamFilDe
						cFilDeT  := cFilAtu
					else
						cFilDeT  := If( RTrim(cFilAtu) == Left(cFilDeT,nTamFilRC0), cFilDeT, cFilAtu)
					EndIf

					If nTamFilRC0 >= nTamFilAte
						cFilAteT := cFilAtu
					else
						cFilAteT := If( RTrim(cFilAtu) == Left(cFilAteT,nTamFilRC0), cFilAteT, cFilAtu )
					EndIf
				Endif
				cFilAteT := PadR(RTrim(cFilAteT), FWGETTAMFILIAL, "Z")

				aRatTit := {}
				Processa({|lEnd| fGerPens(@lEnd),STR0009})  //"Gerando arquivo aguarde..."

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Chamada para o programa de geracao dos valores de DISSIDIO   ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			ElseIf cTitProc $ "006"

				Rst040Imp() // Reinicializa static para execucao da procedure
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Carregando variaveis mv_par?? para Variaveis do Sistema      ³
				//³ Estas variaveis serao utilizadas em GPM240PrcD()			      ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				nValAutonomo  := 0.00
				nValProLabore := 0.00
				nValReceita   := 0.00
				nValDedSer    := 0.00
				nValJuros     := 0.00
				cCentra       := ""
				cCompetencia  := cCompetTit
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Tipo de Geracao na GPS:     1 - CC, 2 - Nivel CC, 3 - Filial ³
				//³ Tipo de Geracao no Titulo:  2 - CC, 3 - Nivel CC, 1 - Filial ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				nPorCc        := If( cAgrupa == "2", 1, If(cAgrupa == "3", 2, 3))
				cNivCCusto    := If( nPorCc == 2, "1", "")
				cTipo         := nFol13Sal
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Processa duas vezes. 1-Contrato Indeterminado, 2-Determinado ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				For nCnt := 1 To 2
					cTpc := Str(nCnt,1) //Define o tipo de contrato
					If cModoRC0 == "E"
						cFilIni := cFilAtu
						cFilFim := cFilAtu
					Else
						cFilIni := cFilDeT
						cFilFim := cFilAteT
					EndIf
					aRatTit := {}
					Processa( { |lEnd| GPM240PrcD(3,@lEnd,,,cFilIni,cFilFim,cCCDeT,cCCAteT,cTpc,cAnoMes),STR0009})  //"Gerando arquivo aguarde..."
				//               Gpm240PrcD( nTipGer, lEnd, WnRel, cFilArq, cFilIni, cFilFim, cCcIni, cCcFim, cTipCont, cAnoMes )
				Next nCnt
			//INSS RRA
			ElseIf cTitProc $ "007"

				Rst040Imp() // Reinicializa static para execucao da procedure
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Carregando variaveis mv_par?? para Variaveis do Sistema      ³
				//³ Estas variaveis serao utilizadas em GPM240PrcD()			      ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				nValAutonomo  := 0.00
				nValProLabore := 0.00
				nValReceita   := 0.00
				nValDedSer    := 0.00
				nValJuros     := 0.00
				cCentra       := ""
				cCompetencia  := cCompetTit

				// Carregar os periodos abertos (aPerAberto) e/ou os periodos
				// fechados (aPerFechado), de acordo com uma determinada competencia.
				fRetPerComp(substr(cCompetTit,1,2),substr(cCompetTit,3,4), Nil, Nil, Nil, @aPerAberto, @aPerFechado)
				cAnoMes:=substr(cCompetTit,3,4)+substr(cCompetTit,1,2)

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Tipo de Geracao na GPS:     1 - CC, 2 - Nivel CC, 3 - Filial ³
				//³ Tipo de Geracao no Titulo:  2 - CC, 3 - Nivel CC, 1 - Filial ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				nPorCc        := If( cAgrupa == "2", 1, If(cAgrupa == "3", 2, 3))
				cNivCCusto    := If( nPorCc == 2, "1", "")
				cTipo         := nFol13Sal := 1

				// Processa os contratos.
				// 1-Contrato Indeterminado
				// 2-Determinado
				// 3-Intermitente
				lFolPgto    := .T. // Geracao dos registros 'FL' no SRZ
				lFol13Sl    := .T. // Geracao dos registros '13' no SRZ
				Rst040Imp() // Reinicializa static para execucao da procedure

				If !fGeraFolSRZ(nFol13Sal, aTipContra, cCompetTit, aPerAberto, aPerFechado)// 1-Indeterminado, 2-Determinado, 3-Intermitente
					Loop
				EndIf

				For nCnt := 1 To Len(aTipContra)
					cTpc := Str(nCnt,1) //Define o tipo de contrato

					If Empty( xFilial( "RC0" ) )
						cFilIni := cFilDeT
						cFilFim := cFilAteT
					Else
						cFilIni := cFilAtu
						cFilFim := cFilAtu
					EndIf

					aRatTit := {}

					Processa({|lEnd|GPM240PrcR(@lEnd,    ,,cFilIni,cFilFim,cCCDeT,cCCAteT,cTpc),STR0009})  //"Gerando arquivo aguarde..."
				//            Gpm240PrcR(lEnd,WnRel,cFilSRZ,cFilIni,cFilFim,cCcIni,cCcFim,cTipCont)
				Next nCnt
			//IMPOSTO DE RENDA - RRA
			ElseIf cTitProc == "008"
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Carregando variaveis mv_par?? para Variaveis do Sistema      ³
				//³ Estas variaveis serao utilizadas em GR050Imp()				   ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If Empty( xFilial( "RC0" ) )
					cFilDe	:= cFilDeT
					cFilAte	:= cFilAteT
				Else
					cFilDe	:= cFilAtu
					cFilAte := cFilAtu
				EndIf

				cCCDe 	  := cCCDeT
				cCCAte 	  := cCCAteT
				cMatDe    := cMatDeT
				cMatAte   := cMatAteT
				dDataDe   := dDataDeT
				dDataAte  := dDataAteT
				cNomDe    := Space(30)
				cNomAte   := Replicate("z", 30)
				cSinAna   := "A" // Analitica
				lSalta    := .F.
				nTipImp   :=  If( cTipoRet == "2", 3, 1) // Tipo Relatorio no programa GPER050
				dVencto   := CTOD("")
				cNumRef   := ""
				cCentra   := ""
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Ordem na Impressao do I.R.: 1 - Mat, 2 - CC,    3 - Nome	   ³
				//³ Ordem na Geracao de titulo: 2 - CC,  3 - Nivel, 1 - Filial   ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				nOrdem	:= If(cAgrupa $ "2*3", 2, 1)
				aRatTit	:= {}
				Processa({|lEnd| GR050Imp(2,@lEnd,,,cAgrupa,,"GPEM650",.T., cTipoRet),STR0009})  //"Gerando arquivo aguarde..."
			//             GR050Imp(nTipGer,lEnd,WnRel,cString,cAgrupa,oReport,cFonte)
			ElseIf cTitProc == "009"	// DARF - DESONERACAO
				aRatTit := {}
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Carregando variaveis mv_par?? para Variaveis do Sistema      ³
				//³ Estas variaveis serao utilizadas em GR050Imp()				   ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If Empty(FWFilial("RC0"))
						cFilDe	:= cFilDeT
						cFilAte	:= cFilAteT
					Else
						cFilDe	:= cFilAtu
						cFilAte	:= cFilAtu
				EndIf

				// Monta o array das filiais a processar
				dbSelectArea( "SM0" )
				dbSeek( cCodEmp, .T. )
				While SM0->( ! EoF() ) .And. cCodEmp == SM0->M0_CODIGO
					If FWGETCODFILIAL >= cFilDe .And. FWGETCODFILIAL <= cFilAte
						aAdd( aFilProc, {FWGETCODFILIAL, " ", 0.00, " ", 0.00} )
					Endif
					SM0->( DbSkip() )
				EndDo

				//Retorna a area do arquivo de empresas. SIGAMAT.EMP
				RestArea( aAreaSM0 )

				//Chama fCarrTab para carregar tabela auxiliar S033
				fCarrTab( @aTabS033, "S033", CtoD( "01/" + SubStr( cAnoMes, 5, 2 ) + "/" + SubStr( cAnoMes, 1, 4 ) ), .T. )

				//Apura a receita bruta total da empresa
				aEval(aTabS033, {|aTabS033| nFatTot += aTabS033[7] } )
				//Apura a receita bruta que nao e' sobre as atividades desoneradas
				aEval(aTabS033, {|aTabS033| If( aTabS033[6] == "2", nFatFol += aTabS033[7], ) } )
				//Apura a receita bruta que e' sobre as atividades desoneradas
				aEval(aTabS033, {|aTabS033| If( aTabS033[6] == "1", nFatDes += aTabS033[7], ) } )
				//Verifica se a receita desonerada da empresa e' superior a 95% do total
				lRecDesTot := ( nFatDes / nFatTot >= 0.95 )

				lRec2DesTot := ( nFatFol / nFatTot >= 0.95 )

				For nFilial := 1 to Len( aFilProc )
					aArea	:= GetArea()
					nFatFol := 0
					fInssEmp( aFilProc[nFilial,1], @aInssEmp, Nil, cAnoMes )

					For nCnt := 1 To Len( aInssEmp[27] )
						cRecFatEmp	:= aInssEmp[ 27, nCnt ]	// X14_RECFAT
						If cRecFatEmp $ "S*M*C"
							Exit
						EndIf
					Next

					//Se a empresa recolhe contribuicao previdenciaria sobre a receita bruta
					If cRecFatEmp $ "S*M*C"
						//Caso seja S, ou M/C sem a atividade desonerada ou não desonerada representar 95% do faturamento.
						If cRecFatEmp == "S" .Or. ((cRecFatEmp =="M" .Or. cRecFatEmp =="C") .And. !lRecDesTot .And. !lRec2DesTot)
							//Verifica os registros da filial em processamento e guarda o valor da contribuicao calculada
							aEval(aTabS033, {|aTabS033| If( aTabS033[2]  ==  aFilProc[nFilial, 1] .And.  aTabS033[6] == "1", aFilProc[nFilial, 5] += aTabS033[9], ) } )
						Else
							If (cRecFatEmp == "C" .And. lRec2DesTot) .Or. (lRecDesTot) .Or. (!lRecDesTot .And. !lRec2DesTot)
								//Apura a receita bruta que nao e' sobre as atividades beneficiadas da Lei no. 12.546/2011
								aEval(aTabS033, {|aTabS033| If( aTabS033[2] == aFilProc[nFilial, 1] .And. aTabS033[6] == "2", nFatFol += aTabS033[7], ) } )
								//Se a receita bruta da atividade desonerada for maior do que 95% do total devera ser
								//considerado a receita bruta da atividade nao desonerada.Sera aplicado a proporcionalidade
								//das aliquotas das atividades desoneradas conforme correspondencia do percentual da receita
								//desonerada em relacao ao total desonerado
								//Ex: Cod de atividade X possui receita bruta de 45.000 com aliquota de 1%. A receita bruta
								//    total de atividade desonerada e' igual a 98.000 e ha 2.000 de atividade nao desonerada.
								//	  Sera feito a regra de 3 para saber quanto da receita bruta da atividade corresponde
								//    ao total desonerado. Percentual = 45.000 * 100 / 98.000 = 45,91%. O percentual sera
								//    aplicado sobre os 2.000 da receita nao desonerada. Sobre o valorencontrado sera
								//	  aplicado a aliquota correspondente ao codigo da atividade. Esse valor sera somado ao
								//    que a empresa ja recolhe de contribuicao sobre a atividade desonerada.
								For nCont := 1 To Len(aTabS033)
									If aTabS033[nCont, 6] == "1"
										nProp := ( aTabS033[nCont, 7] * 100 / nFatDes ) / 100
										aFilProc[nFilial, 5] += ( nProp * nFatFol ) * ( aTabS033[nCont, 8] / 100 )
									EndIf
								Next nCont
							EndIf
						EndIf

					EndIf

					fGravTit( aFilProc[nFilial,1], cAgrupa, , aFilProc[nFilial, 5] )

					RestArea( aArea )
				Next nFilial
			EndIf
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Geracao dos titulos definidos pelo usuario			            ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		ElseIf cTipTit == "2"
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Verifica Alias e Campo para filtrar o periodo   		         ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If Empty(cAliasLan)
				dbSelectArea( (cAliasRC0) )
				Loop
			EndIf
			aRatTit := {}
			Processa({|lEnd| fTitUsu(@lEnd,lCabec,lVenc),STR0009})  //"Gerando arquivo aguarde..."
		EndIf
		(cAliasRC0)->( dbSkip())
		cFilAte := xFilial( "RC0", cFilAteT )
		dbSelectArea( (cAliasRC0) )
	EndDo

Return Nil

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³GPM650OOk ³ Autor ³ Emerson Rosa de Souza ³ Data ³ 13.08.01 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Confirma parametros             				               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ GPM650Ok()    			                                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ 							                                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³                                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Static Function GPM650Ok()

Return (MsgYesNo(OemToAnsi(STR0007),OemToAnsi(STR0008))) //"Confirma configura‡„o dos parƒmetros?"###"Aten‡„o"

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ fGerPens ³ Autor ³ Emerson Rosa de Souza ³ Data ³ 13.08.01 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Monta valores de pensao e grava no arquivo de titulos	      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ fGerPens	    			                                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ 							                                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³                                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Static Function fGerPens(lEnd)
	Local cAlias		:= ALIAS()
	Local aArea
	Local aCodFol		:= {}
	Local aValBenef		:= {}
	Local aOrdBagRC		:= {}
	Local aRotAux		:= {}
	Local nValor		:= 0
	Local nValTotal		:= 0
	Local cAliasRC		:= ""
	Local cFilRotAux	:= "#########"
	Local cRCName
	Local cFilialAnt
	Local cCCAnt
	Local nCntB			:= 0
	Local cAgrupAnt
	Local dDataRef
	Local cQuery		:= ""
	Local cAliasSRA		:= "SRA"
	Local cAliasCount	:= ""
	Local cQry			:= ""
	Local cCount		:= ""
	Local lQuery		:= .F.
	Local cOrder
	Local cPensVer		:= ""
	Local cValidFil		:= fValidFil()
	Local nRoteir		:= 0
	Local cAliasPENS    := GetNextAlias()
	Local cOrderBy      := ""

	//-- Tratamento para competencia dos benecifiarios
	Local cMesAno		:= ''
	Local dDtIniComp	:= Ctod('')
	Local dDtFimComp	:= Ctod('')
	Local nUltDia		:= 0
	Local nX			:= 0
	Local aSRQStru
	//-- Tratamento para geração de Título de Pensão Alimentícia por Beneficiário
	Local lGeraTit		:= .T.
	Local cFornAnt		:= cFornec
	Local cLojaAnt		:= cLoja
	Local nOrdRot		:= 1

	//Variaveis Privates utilizadas em fBuscaLiq()
	Private lImprFunci  := .F. // Indica se deve buscar valores dos funcionarios
	Private lImprBenef  := .T. // Indica se deve buscar valores dos beneficiarios

	Private cArqMovRC   := ""

	Private cAcessaSRA	:= &( " { || " + ChkRH( "GPEM650" , "SRA" , "2" ) + " } " )
	Private cAcessaSRC	:= &( " { || " + ChkRH( "GPEM650" , "SRC" , "2" ) + " } " )
	Private cAcessaSRG	:= &( " { || " + ChkRH( "GPEM650" , "SRG" , "2" ) + " } " )
	Private cAcessaSRH	:= &( " { || " + ChkRH( "GPEM650" , "SRH" , "2" ) + " } " )
	Private cAcessaSRR	:= &( " { || " + ChkRH( "GPEM650" , "SRR" , "2" ) + " } " )
	Private cAcessaSRD	:= &( " { || " + ChkRH( "GPEM650" , "SRD" , "2" ) + " } " )
	Private cCpoDel		:= "D_E_L_E_T_"

	Private dDataDe     := dDataDeT
	Private dDataAte    := dDataAteT
	Private Semana      := "  "
	Private aRoteiros	:= {}

	//-- Tratamento para competencia dos beneficios
	cMesAno  := Substr(cCompetTit,1,2)+"/"+Substr(cCompetTit,3,4)

	dDtIniComp	:= CToD( "01" + "/" + cMesAno )    //Primeiro dia do Mes
	nUltDia	:= f_UltDia( dDtIniComp )      	 //Ultimo dia do Mes
	dDtFimComp	:= CToD(StrZero(nUltDia,2)+"/"+ cMesAno)

	cPensVer := "   "

	If cAgrupa $ "1*4" // Filial*Funcionario
		cOrderBy := "%1,2%"
	ElseIf cAgrupa $ "2*3" //Centro de Custo/Nivel de Centro de Custo
		cOrderBy := "%1,3%"
	EndIf

	BeginSql Alias cAliasPENS
		SELECT DISTINCT
			RA_FILIAL, RA_MAT, RA_CC
		FROM
			%Table:SRA% SRA
			JOIN %Table:SRQ% SRQ ON RQ_FILIAL = RA_FILIAL AND RQ_MAT = RA_MAT
			JOIN %Table:SRC% SRC ON RC_FILIAL = RA_FILIAL AND RC_MAT = RA_MAT
		WHERE
			SRA.%NotDel%
			AND SRQ.%NotDel%
			AND SRC.%NotDel%
			AND RC_PERIODO = %Exp:cAnoMes%
			AND RA_FILIAL >= %Exp:cFilDeT%
			AND RA_FILIAL <= %Exp:cFilAteT%
			AND RA_CC >= %Exp:cCCDeT%
			AND RA_CC <= %Exp:cCCAteT%
			AND RA_MAT >= %Exp:cMatDeT%
			AND RA_MAT <= %Exp:cMatAteT%

		UNION

		SELECT DISTINCT
			RA_FILIAL, RA_MAT, RA_CC
		FROM
			%Table:SRA% SRA
			JOIN %Table:SRQ% SRQ ON RQ_FILIAL = RA_FILIAL AND RQ_MAT = RA_MAT
			JOIN %Table:SRD% SRD ON RD_FILIAL = RA_FILIAL AND RD_MAT = RA_MAT
		WHERE
			SRA.%NotDel%
			AND SRQ.%NotDel%
			AND SRD.%NotDel%
			AND RD_PERIODO = %Exp:cAnoMes%
			AND RA_FILIAL >= %Exp:cFilDeT%
			AND RA_FILIAL <= %Exp:cFilAteT%
			AND RA_CC >= %Exp:cCCDeT%
			AND RA_CC <= %Exp:cCCAteT%
			AND RA_MAT >= %Exp:cMatDeT%
			AND RA_MAT <= %Exp:cMatAteT%

		UNION

		SELECT DISTINCT
			RA_FILIAL, RA_MAT, RA_CC
		FROM
			%Table:SRA% SRA
			JOIN %Table:SRQ% SRQ ON RQ_FILIAL = RA_FILIAL AND RQ_MAT = RA_MAT
			JOIN %Table:SRR% SRR ON RR_FILIAL = RA_FILIAL AND RR_MAT = RA_MAT
		WHERE
			SRA.%NotDel%
			AND SRQ.%NotDel%
			AND SRR.%NotDel%
			AND RR_PERIODO = %Exp:cAnoMes%
			AND RA_FILIAL >= %Exp:cFilDeT%
			AND RA_FILIAL <= %Exp:cFilAteT%
			AND RA_CC >= %Exp:cCCDeT%
			AND RA_CC <= %Exp:cCCAteT%
			AND RA_MAT >= %Exp:cMatDeT%
			AND RA_MAT <= %Exp:cMatAteT%

		ORDER BY
			%Exp:cOrderBy%
	EndSql

	DbSelectArea("SRY")
	("SRY")->( DbGoTop() )
	While !("SRY")->(Eof())
		If SRY->RY_TIPO $ "1*2*3*4*5*6*F"
			If SRY->RY_TIPO == "4"
				Aadd(aRotAux, {SRY->RY_CALCULO, SRY->RY_TIPO, cPensVer,SRY->RY_FILIAL,0 })
			Else
				Aadd(aRotAux, {SRY->RY_CALCULO, SRY->RY_TIPO, cPensVer,SRY->RY_FILIAL,nOrdRot} )
			EndIf
			nOrdRot++
		EndIf
		("SRY")->(DbSkip())
	EndDo

	aSort(aRotAux,,,{|x,y| x[5] < y[5]})
	DbSelectArea("SRA")

	ProcRegua( (cAliasPENS)->(RecCount()) )

	nValTotal  := 0
	cFilialAnt := Replicate("!",FWGETTAMFILIAL)
	cCCAnt     := Replicate("!",GetSx3Cache("RA_CC","X3_TAMANHO"))
	cCpoAgrup  := If(cAgrupa=="1","(cAliasPENS)->RA_FILIAL",If(cAgrupa$"2*3","(cAliasPENS)->RA_CC","(cAliasPENS)->RA_MAT"))

	While (cAliasPENS)->( !Eof() )
		If cAgrupa $ "1*4" // Filial*Funcionario
			SRA->( DbSetOrder(1) )
			SRA->( DbSeek( (cAliasPENS)->(RA_FILIAL+RA_MAT) ) )
		ElseIf cAgrupa $ "2*3" //Centro de Custo/Nivel de Centro de Custo
			SRA->( DbSetOrder(2) )
			SRA->( DbSeek( (cAliasPENS)->(RA_FILIAL+RA_CC+RA_MAT) ) )
		EndIf

		//Verifica quebra de filial e busca novos codigos da folha
		If SRA->RA_FILIAL # cFilialAnt
			//Consiste acesso do usuario a filiais
			If ! ( SRA->RA_FILIAL $ cValidFil )
				SRA->(dbSkip())
				Loop
			EndIf
		IF !FP_CODFOL(@aCodFol,SRA->RA_FILIAL)
			Exit
		Endif
		cFilialAnt := SRA->RA_FILIAL
		Endif

		If cFilRotAux <> xFilial("SRY",SRA->RA_FILIAL)
			cFilRotAux := xFilial("SRY",SRA->RA_FILIAL)
			aRoteiros := {}
			For nX := 1 to Len(aRotAux)
				If cFilRotAux == aRotAux[nX,4]
					Aadd(aRoteiros, {aRotAux[nX,1], aRotAux[nX,2], aRotAux[nX,3]} )
				EndIf
			Next nX
		EndIf

		//Centro de custo para gravacao quando agrupar por funcionario
		If SRA->RA_CC # cCCAnt
			cCCAnt := SRA->RA_CC
		EndIf

		cAgrupAnt := &cCpoAgrup
		While (cAliasPENS)->( !Eof() ) .And. cFilialAnt + cAgrupAnt == (cAliasPENS)->RA_FILIAL + &cCpoAgrup
			IncProc(STR0005 + cDescri) //"Gerando Titulos - "

			//Busca os valores do beneficiario
			nValor    := 0
			aValBenef 	:= {}
			dDataRef	:= CTOD("01"+"/"+Substr(cCompetTit,1,2)+"/"+Substr(cCompetTit,3,4) )

			Gp020BuscaLiq(@nValor, @aValBenef, cPensVer,, (cAliasPENS)->RA_FILIAL, (cAliasPENS)->RA_MAT)
			lGeraTit := .F.
			For nCntB := 1 To Len( aValBenef )
				If cGeraBen == "1" .And. cAgrupa == "4"
					lGeraTit := .T.

					If !Empty(aValBenef[nCntB,10]) .And. !Empty(aValBenef[nCntB,11])
						cFornec := aValBenef[nCntB,10]
						cLoja := aValBenef[nCntB,11]
					EndIf

					//Grava o titulo de acordo com seu agrupamento
					aArea :=  (cAliasSRA)->(GetArea())
					If !(fGravTit(cFilialAnt,If(cAgrupa$"2*3",cAgrupAnt,If(cAgrupa=="4",cCCAnt,Nil)),If(cAgrupa=="4",cAgrupAnt, Nil),aValBenef[nCntB,5]))
						Exit
					EndIf
					RestArea(aArea)

					cFornec := cFornAnt
					cLoja := cLojaAnt

				Else
					nValTotal += aValBenef[nCntB,5]
				EndIf
			Next nCntB

			(cAliasPENS)->( DbSkip() )
		EndDo

		//Grava o titulo de acordo com seu agrupamento
		If !lGeraTit
			//Grava o titulo de acordo com seu agrupamento
			aArea :=  (cAliasSRA)->(GetArea())
			If !(fGravTit(cFilialAnt,If(cAgrupa$"2*3",cAgrupAnt,If(cAgrupa=="4",cCCAnt,Nil)),If(cAgrupa=="4",cAgrupAnt, Nil),nValTotal))
				Exit
			EndIf
			RestArea(aArea)
		EndIf
		nValTotal := 0
	EndDo

	(cAliasPENS)->( DbCloseArea() )

	DbSelectArea( "SRA" )
	DbSetOrder(1)
	DbSelectArea( cAlias)
Return Nil

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ fTitUsu  ³ Autor ³ Emerson Rosa de Souza ³ Data ³ 13.08.01 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Busca valores no arquivo definido pelo usuario		         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ fTitUsu	    			                                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ 							                                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³                                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Static Function fTitUsu(lEnd,lCabec,lVenc)
	Local cAlias		:= ALIAS()
	Local cFilLimI		:= If(Len(Alltrim(cFilAtu)) < FWGETTAMFILIAL, cFilDeT, cFilAtu)
	Local cFilLimF		:= If(Len(Alltrim(cFilAtu)) < FWGETTAMFILIAL, cFilAteT, cFilAtu)
	Local cIniCpo
	Local cPriCpo
	Local cDtFiltro
	Local cIndCond
	Local cFor
	Local cChaveCab
	Local cChaveLan
	Local cChaveBas
	Local aChaveAgrup	:= {}
	Local nRecAgrup		:= 0
	Local nPosAgrup
	Local cChaveAgrup
	Local cModeAccess
	Local cOrder		:= ""
	Local cSelect		:= ""
	Local cPdAux		:= ""
	Local cAliasAux		:= cAliasLan
	Local aAliasStru	:= {}
	Local nX 			:= 0
	Local cValidFil		:= fValidFil()
	Local cChaveCabL    := ""
	Local cCpoData		:= ""

	DEFAULT lVenc		:= .F.
	Private cArqNtx
	Private cCcLan
	Private cMatLan
	Private cFilLan
	Private cPDLan
	Private cValLan
	Private lMatLan
	Private lCcLan
	Private lMatCab
	Private cCcCab
	Private cItem

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Variavel obritatorias do arquivo LANCAMENTOS  		         ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	dbSelectArea( cAliasLan )
	cPriCpo := FieldName(1) // Nome do primeiro campo do arquivo
	cIniCpo := Substr(cPriCpo, 1, AT("_", cPriCpo))
	cFilLan := cIniCpo + "FILIAL"
	cCcLan  := cIniCpo + "CC"
	cMatLan := cIniCpo + "MAT"
	cValLan := cIniCpo + If(cAliasLan == "SRZ", "VAL",If (cAliasLan == "SRK","VALORTO","VALOR"))
	cPDLan  := cIniCpo + If(cAliasLan == "SRT", "VERBA", "PD")
	lMatLan := ( FieldPos( cMatLan ) > 0 )
	lCcLan	 := ( FieldPos( cCcLan ) > 0 )
	cItem   := cIniCpo + "ITEM"

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Prepara filtro do cadastro de funcionarios       		      ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	dbSelectArea( "SRA" )
	dbSetOrder(1)
	cFiltrSRA := AllTrim(cFiltrSRA)

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Chave para comparacao entre arquivo CABECALHO E LANCAMENTOS  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	cChaveCab := &( "{ || .T.}" )
	cChaveLan := &( "{ || .T.}" )

	cModeAccess := FWModeAccess( "RC0", 1) + FWModeAccess( "RC0", 2) + FWModeAccess( "RC0", 3)
	If Empty(cFilAtu) .Or. ( !Empty(cFilAtu) .and. cModeAccess <> "EEE")
		cFilLimI := cFilDeT
		cFilLimF := cFilAteT
	Else
		cFilLimI := cFilAtu
		cFilLimF := cFilAtu
	EndIf

	If lCabec

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Variaveis obritatorias do arquivo CABECALHO    		         ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		dbSelectArea( cAliasCab )
		cPriCpo := FieldName(1) // Nome do primeiro campo do arquivo
		cIniCpo := Substr(cPriCpo, 1, AT("_", cPriCpo))
		cFilCab := cIniCpo + "FILIAL"
		cMatCab := cIniCpo + "MAT"
		lMatCab := ( FieldPos( cMatCab ) > 0 )

		// Tratamento para CC, pois na rescisao (SRG) este campo somente fara parte da tabela de itens (SRR)
		cCcCab	:= If( FieldPos( cIniCpo + "CC" ) > 0, cIniCpo + "CC", "" )

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Monta indice condicional do arquivo CABECALHO                ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If cAgrupa == "2" .and. !( cAliasCab $ "SRG*SRH" )   // Centro de Custo/Nivel de Centro de Custo - Cabecalho de Rescisao nao tem CC
			cIndCond := cFilCab + "+" + cCcCab + If(lMatCab, "+" + cMatCab, "")

			cFor := '(' + cFilCab + "+" + cCcCab + If(lMatCab, "+" + cMatCab, "")+;
					' >= "' + cFilLimI+cCCDeT+ If(lMatCab, cMatDeT,'') + '")'

			cFor += ' .And. (' + cFilCab+ "+" + cCcCab + If(lMatCab, "+" + cMatCab, "")+;
					' <= "' + cFilLimF+cCCAteT + If(lMatCab, cMatAteT ,'') + '")'

		Else
			cIndCond := cFilCab + If(lMatCab, "+" + cMatCab, "")

			cFor := '(' + cFilCab + If(lMatCab, "+" + cMatCab, "")+;
					' >= "' + cFilLimI + If(lMatCab, cMatDeT,'') + '")'

			cFor += ' .And. (' + cFilCab + If(lMatCab, "+" + cMatCab, "")+;
					' <= "' + cFilLimF + If(lMatCab, cMatAteT ,'') + '")'

		EndIf

		If !Empty(cFiltrCab)
			cFor += ' .And. ' + AllTrim(cFiltrCab)
		EndIf

		If !Empty(cCpoDtCab)
			cDtFiltro := 'DTOS(' + cCpoDtCab + ')'
			cFor += ' .And. (' +cDtFiltro+' >= "'+DTOS(dDataDeT)+'")'+' .And. ('+cDtFiltro+' <= "'+DTOS(dDataAteT)+'")'
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Cria indice temporario do arquivo CABECALHO			         ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		cArqNtx := CriaTrab(NIL,.f.)
		IndRegua(cAliasCab,cArqNtx,cIndCond,,cFor,STR0006)  //"Selecionando Registros..."
		dbGoTop()

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Monta chave para busca das verbas no arquivo de LANCAMENTOS  ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		cTipoItens  := If(cAliasCab == "SRG", "R", If(cAliasCab == "SRH", "F", ""))
		cChaveBas   := "" //Chave basica para busca - somente Filial + Matricula

		If cAliasCab == "SRG"
			cChaveCab := &( "{ || " + cAliasCab + "->" + cFilCab + " + " + cAliasCab + "->" + cMatCab + " + cTipoItens + Dtos(SRG->RG_DTGERAR) }" )
		ElseIf cAliasCab == "SRH"
			cChaveCab := &( "{ || " + cAliasCab + "->" + cFilCab + " + " + cAliasCab + "->" + cMatCab + " + cTipoItens + Dtos(SRH->RH_DATAINI) }" )
		Else
			If cAgrupa == "2"   //Centro de Custo
				cChaveCab := &( "{ || " + cAliasCab + "->" + cFilCab + " + " + cAliasCab + "->" + cCcCab + If(lMatCab, " + " + cAliasCab + "->" + cMatCab,"") + " + Dtos(" + cAliasCab + "->" + cCpoDtRel + ") }" )
				cChaveBas := &( "{ || " + cAliasCab + "->" + cFilCab + " + " + cAliasCab + "->" + cCcCab + If(lMatCab, " + " + cAliasCab + "->" + cMatCab,"") + " }" )
			else
				cChaveCab := &( "{ || " + cAliasCab + "->" + cFilCab + If(lMatCab, " + " + cAliasCab + "->" + cMatCab,"") + " + Dtos(" + cAliasCab + "->" + cCpoDtRel + ") }" )
				cChaveBas := &( "{ || " + cAliasCab + "->" + cFilCab + If(lMatCab, " + " + cAliasCab + "->" + cMatCab,"") + " }" )
			EndIf
		EndIf

		If cAgrupa == "2" .And. cAliasCab != "SRH"   //Centro de Custo
			If 	!Empty(cCpoDtLan)
				cChaveLan := &( "{ || " + cAliasLan + "->" + cFilLan + " + " + cAliasLan + "->" + cCcLan + " + " + cAliasLan + "->" + cMatLan + " + cTipoItens + DTOS(" + cAliasLan + "->" + cCpoDtLan + ") }" )
			Else
				cChaveLan := &( "{ || " + cAliasLan + "->" + cFilLan + " + " + cAliasLan + "->" + cCcLan + " + " + cAliasLan + "->" + cMatLan + " + cTipoItens }" )
			Endif
		else
			If 	!Empty(cCpoDtLan)
				cChaveLan := &( "{ || " + cAliasLan + "->" + cFilLan + " + " + cAliasLan + "->" + cMatLan + " + cTipoItens + DTOS(" + cAliasLan + "->" + cCpoDtLan + ") }" )
			Else
				cChaveLan := &( "{ || " + cAliasLan + "->" + cFilLan + " + " + cAliasLan + "->" + cMatLan + " + cTipoItens }" )
			Endif
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Processa o arquivo CABECALHO definido pelo usuario		      ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		While !Eof()

			//Consiste acesso do usuario a filiais
			If ! ( (cAliasCab)->&cFilCab $ cValidFil )
				(cAliasCab)->(dbSkip())
				Loop
			EndIf

			dbSelectArea( cAliasLan )
			If dbSeek( If(Empty(cChaveBas), Eval(cChaveCab), Eval(cChaveBas)) )
				dDataVenc := &(cAliasCab + "->" + cCpoDtCab)
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Efetua tratamento especifico para agrupamento Filial/C.Custo,³
				//³ preserva a chave de agrupamento para somar a cada registro.  ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If cAgrupa # "4"           //Agrupamento Funcionario
					cChaveAgrup := ""
					nRecAgrup   := 0
					If cAgrupa == "1"      //Agrupamento Filial
						cChaveAgrup := &cFilLan + Dtos(dDataVenc)
					ElseIf cAgrupa $ "2*3" //Agrupamento Centro de Custo
						cChaveAgrup := &cFilLan + &cCcLan + Dtos(dDataVenc)
					EndIf
					nPosAgrup := Ascan( aChaveAgrup, { |X| X[1] == cChaveAgrup })
					If nPosAgrup > 0
						nRecAgrup := aChaveAgrup[nPosAgrup, 2]
					Else
						Aadd( aChaveAgrup, { cChaveAgrup, 0 } )
					EndIf
				EndIf

				If cAliasCab $ "SRG*SRH"
					cChaveCabL := &( "{ || " + cAliasCab + "->" + cFilCab + If(lMatCab, " + " + cAliasCab + "->" + cMatCab,"") + " + cTipoItens + Dtos(" + cAliasCab + "->" + cCpoDtRel + ") }" )
					While !Eof() .And. !(Eval(cChaveCabL) == Eval(cChaveLan))
						DbSkip()
					EndDo
				EndIf

				fProcLctos(IIf( !Empty(cChaveCabL),cChaveCabL,cChaveCab ), cChaveLan, aChaveAgrup, nRecAgrup)
			EndIf
			dbSelectArea( cAliasCab )
			dbSkip()
		EndDo
	Else
		If cAliasLan <> "RC0"
			aAliasStru 	:= (cAliasLan)->(dbStruct())

			For nX := 1 to Len(cVerbas) Step 4
				If !Empty(cPdAux)
					cPdAux += ","
				EndIf
				cPdAux += "'" + SubStr(cVerbas,nX,3) + "'"
			Next nX

			cSelect := "SELECT * " + CRLF

			If cIdentTit == "RES"
				cCpoData := cIniCpo + IIf(cIniCpo $ "RD_|RGB_", "DTREF", "DATA")
				cQuery := "FROM " + RetSqlName(cAliasLan) + " SRR " + CRLF
				cQuery += "INNER JOIN " + RetSqlName("SRG") + " SRG ON "
				cQuery += "SRR." + cIniCpo + "FILIAL  = SRG.RG_FILIAL "
				cQuery += "AND SRR." + cIniCpo + "MAT = SRG.RG_MAT "
				cQuery += "AND SRR." + cCpoData + " = SRG.RG_DTGERAR "
			Else
				cQuery := "FROM " + RetSqlName(cAliasLan) + CRLF
			EndIf

			cQuery += "WHERE " + cFilLan +	" BETWEEN '" + cFilLimI + "' AND '" + cFilLimF	+ "' AND "

			If lMatLan
				cQuery += cMatLan + " BETWEEN '" + cMatDeT + "' AND '" + cMatAteT	+ "' AND "
			EndIf

			If lCcLan
				cQuery += cCcLan + " BETWEEN '" + cCcDeT  + "' AND '" + cCcAteT	+ "' AND "
			EndIf

			If cAliasLan == "SRD" .and. !Empty(cAnoMes)
				cQuery += "RD_DATARQ = '" + cAnoMes + "' AND "
			EndIf

			If !Empty(cCpoDtLan)
				cQuery += " " + cCpoDtLan + " BETWEEN '" + Dtos(dDataDeT) + "' AND '" + Dtos(dDataAteT) + "' AND "
			EndIf

			If !( Empty(cPdAux) )
				cQuery += cPDLan + " IN ( " + cPdAux + " ) AND "
			Else
				cQuery += cPDLan + " IN ('') AND "
			EndIf

			If cIdentTit == "RES"
				cQuery += "SRR.D_E_L_E_T_ = ' ' AND SRG.D_E_L_E_T_ = ' ' "
			Else
				cQuery += "D_E_L_E_T_ = ' ' "
			EndIf

			cOrder := " ORDER BY "

			If cAgrupa $ "1*4"       // Filial*Funcionario
				cOrder += cFilLan + If(lMatLan, "," + cMatLan, "") + If(lCcLan,"," + cCcLan, "") + CRLF
			ElseIf cAgrupa $ "2*3"   //Centro de Custo/Nivel de Centro de Custo
				cOrder += cFilLan + "," + cCcLan + If(lMatLan, "," + cMatLan, "") + CRLF
			EndIf

			cQuery := ChangeQuery(cSelect+cQuery+cOrder)
			cAliasLan 	:= GetNextAlias()

			//ABRE A EXECUCAO DA QUERY ATRIBUIDA AO SRA
			If MsOpenDbf(.T.,"TOPCONN",TcGenQry(, ,cQuery),cAliasLan,.F.,.T., .F. , .F.)
				For nX := 1 To Len(aAliasStru)
					If !( aAliasStru[ nX , 02 ] == "C" )
						TcSetField(cAliasLan,aAliasStru[nX][1],aAliasStru[nX][2],aAliasStru[nX][3],aAliasStru[nX][4])
					EndIf
				Next nX
			EndIf
		EndIf

		If cAliasLan <> "RC0"
			fProcLctos(cChaveCab, cChaveLan,,, cAliasAux, cFiltrLan, lVenc)
		EndIf
	EndIf

	(cAliasLan)->(DbCloseArea())
	dbSelectArea(cAlias)

Return Nil

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³fProcLctos³ Autor ³ Emerson Rosa de Souza ³ Data ³ 13.08.01 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Busca valores no arquivo de Intes definido pelo usuario	  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ fProcLctos    			                                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ 							                                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³                                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Static Function fProcLctos(cChaveCab,cChaveLan,aChaveAgrup,nRecAgrup,cAliasAux,cFiltrLan,lVenc)
	Local cAlias    := ALIAS()
	Local cTipVerba
	Local nValTitulo 	:= 0
	Local cFilialAnt
	Local cCCAnt
	Local cAgrupAnt
	Local cCpoAgrup  	:= If(cAgrupa == "1", cFilLan, If(cAgrupa $ "2*3", cCcLan, cMatLan))
	Local lIRRF			:= .F.
	Local lRatItm		:= SuperGetMV("MV_RATITM",,.F.)
	Local aDetTitulo	:= {}
	Local cDetTitulo    := ""
	Local nTamMat		:= TamSX3("RA_MAT")[1]

	DEFAULT cAliasAux	:= cAliasLan
	DEFAULT cFiltrLan	:= ""
	DEFAULT lVenc		:= .F.

	cFilialAnt := Replicate("!",FWGETTAMFILIAL)
	cCCAnt     := Replicate("!", GetSx3Cache("RA_CC", "X3_TAMANHO"))

	If lVenc .And. Empty(dVctoInf)
		dDataVenc := ctod("  /  /  ")
	EndIf

	While (cAliasLan)->(!Eof()) .And. Eval(cChaveCab) == Eval(cChaveLan)
		DbSelectArea(cAliasLan)
		cFilialAnt    	:= &cFilLan
		cAgrupAnt     	:= &cCpoAgrup
		aAliasFields	:= {}
		aDetTitulo		:= {}
		cDetTitulo      := ""

		If lVenc .And. Empty(dDataVenc)
			dDataVenc := &(cAliasLan + "->" + cCpoDtCab)
		EndIf

		While (cAliasLan)->(!Eof()) .And. cFilialAnt + cAgrupAnt == &cFilLan + &cCpoAgrup

			// VALIDA A FILIAL DA TABELA RC0 E FILIAL DO ALIAS DE LANÇAMENTOS POIS
			// AS TABELAS PODEM TER COMPARTILHAMENTOS DIFERENTES.
			If SubStr(cFilialAnt, 1, Len(Alltrim((cAliasRC0)->RC0_FILIAL))) <> Alltrim((cAliasRC0)->RC0_FILIAL)
				DbSelectArea(cAliasLan)
				(cAliasLan)->(dbSkip())
				Loop
			EndIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Verifica se satisfaz a condicao do arquivo de Cabecalho    	³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If Eval(cChaveCab) # Eval(cChaveLan)
				DbSelectArea( cAliasLan )
				(cAliasLan)->(dbSkip())
				Loop
			EndIf

			//Filtra centro de custo
			If &cCcLan < cCCDeT .Or. &cCcLan > cCCAteT
				DbSelectArea( cAliasLan )
				(cAliasLan)->(dbSkip())
				Loop
			EndIf

			If !Empty(cFiltrLan)
				(cAliasAux)->( dbGoTo( (cAliasLan)->R_E_C_N_O_ ) )
				If !&cFiltrLan
					dbSelectArea( cAliasLan )
					(cAliasLan)->(dbSkip())
					Loop
				EndIf
			EndIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Centro de custo para gravacao quando agrupar por funcionario ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If &cCcLan # cCCAnt
				cCCAnt := &cCcLan
			EndIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Testa o filtro do cadastro de funcionarios                   ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If cFiltrSRA # Nil .And. !Empty(cFiltrSRA)
				cChaveBusca := &cFilLan + &cMatLan
				dbSelectArea( "SRA" )
				If dbSeek( cChaveBusca )
					If !&cFiltrSRA
						dbSelectArea( cAliasLan )
						(cAliasLan)->(dbSkip())
						Loop
					EndIf
				EndIf
				dbSelectArea( cAliasLan )
			EndIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Verifica se for titulo de RES se a rescisão é efetiva        ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If cIdentTit == "RES"
				If aChaveAgrup == Nil
					If (cAliasLan)->RG_EFETIVA = 'N'
						dbSelectArea( cAliasLan )
						(cAliasLan)->(dbSkip())
						Loop
					EndIf
				Else
					If SRG->RG_EFETIVA = 'N'
						dbSelectArea( cAliasLan )
						(cAliasLan)->(dbSkip())
						Loop
					EndIf
				EndIf
			EndIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Verifica se as verbas existem no arquivo em processamento    ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If &cPDLan $ cVerbas
				cTipVerba := Substr( cVerbas, AT(&cPDLan, cVerbas)+3, 1)
				PosSrv(&cPDLan,&cFilLan)
				lIRRF	:=	.F.
				If ( SRV->RV_CODFOL == '0152' )
					lIRRF	:=	.T.
				EndIf
				dbSelectArea( cAliasLan )
				If !(cTipVerba $ "P*D")
					cTipVerba := If(SRV->RV_TIPOCOD == "2", "D", "P")
				EndIf
				If cTipVerba == "P"     // Verbas definidas (No Titulo) pelo usuario como provento
					nValTitulo += &cValLan
					If lRatItm
						fSomaRat( &cValLan, &cItem )
					EndIf
				ElseIf cTipVerba == "D" //Verbas definidas (No Titulo) pelo usuario como desconto
					nValTitulo -= &cValLan
					If lRatItm
						fSomaRat( (&cValLan)*(-1), &cItem )
					EndIf
				EndIf

				If cAliasAux == "SRR" .And. If(Empty(RR_ROTEIR), .F. ,fGetTipoRot(RR_ROTEIR) $ "3*4") .And. !( ( RR_FILIAL + RR_PROCES + RR_ROTEIR + RR_PERIODO + RR_SEMANA + DtoS(RR_DATA) + RR_MAT ) $ cDetTitulo )

					aAdd(aDetTitulo,{RR_FILIAL,RR_PROCES, RR_ROTEIR, RR_PERIODO,RR_SEMANA, RR_DATA , RR_MAT })

					cDetTitulo += RR_FILIAL + RR_PROCES + RR_ROTEIR + RR_PERIODO + RR_SEMANA + DtoS(RR_DATA) + RR_MAT + "|"

				ElseIf cAliasAux $ "SRC" .And. If(Empty(RC_ROTEIR), .F. ,fGetTipoRot(RC_ROTEIR) $ "1*2")
					If cAgrupa == "4" // Agrupamento por Funcionário
						// Considera matrícula
						If !( ( RC_FILIAL + RC_PROCES + RC_ROTEIR, RC_PERIODO + RC_SEMANA + DtoS(RC_DATA) + RC_MAT ) $ cDetTitulo ) // Verifica se chave já foi lida
							aAdd(aDetTitulo,{RC_FILIAL,RC_PROCES, RC_ROTEIR , RC_PERIODO, RC_SEMANA, RC_DATA , RC_MAT })

							cDetTitulo += RC_FILIAL + RC_PROCES + RC_ROTEIR + RC_PERIODO + RC_SEMANA + DtoS(RC_DATA) + RC_MAT + "|"
						EndIf
					Else
						If !( ( RC_FILIAL + RC_PROCES + RC_ROTEIR + RC_PERIODO + RC_SEMANA + DtoS(RC_DATA) + Space(nTamMat) )  $ cDetTitulo )
							aAdd(aDetTitulo,{RC_FILIAL,RC_PROCES, RC_ROTEIR, RC_PERIODO, RC_SEMANA, RC_DATA, Space(nTamMat)})

							cDetTitulo += RC_FILIAL + RC_PROCES + RC_ROTEIR + RC_PERIODO + RC_SEMANA + DtoS(RC_DATA) + Space(nTamMat) + "|"
						EndIf
					EndIf
				EndIf



				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³O ponto de entrada GP650ACM e utilizado no momento do agrupamento dos titulos      ³
				//³Nele e possivel armazenar no array "aAliasFields" os dados que formam o título.    ³
				//³Exemplo: filial, matricula, verba, centro de custo, valor.                         ³
				//³Variaveis disponíveis:                                                             ³
				//³                                                                                   ³
				//³"	cFilLan                                                                         ³
				//³"	cCpoAgrup                                                                       ³
				//³"	cCcLan                                                                          ³
				//³"	cMatLan                                                                         ³
				//³"	cPDLan                                                                          ³
				//³"	cValLan                                                                         ³
				//³Todas estas variáveis deverão ser utilizadas com o símbolo de macro("&") na frente.³
				//³Ex.: cFil := &cFilLan                                                              ³
				//³Utiliar o ponto de entrada GP650CHK para utilizar o numero do titulo e guardar as  ³
				//³informacoes em  uma tabela.                                                        ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If lGp650Acm
					ExecBlock("GP650ACM",.F.,.F.)
				EndIf

			EndIf
			dbSelectArea(cAliasLan)
			(cAliasLan)->(dbSkip())
		EndDo
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Grava o titulo de acordo com seu agrupamento                 ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If !(fGravTit(cFilialAnt,If(cAgrupa$"2*3",cAgrupAnt,If(cAgrupa=="4",cCCAnt,Nil)),If(cAgrupa=="4",cAgrupAnt, Nil),nValTitulo,aChaveAgrup,nRecAgrup,cAliasAux,aDetTitulo))
			Exit
		EndIf
		nValTitulo := 0
	EndDo
	dbSelectArea(cAlias)

Return Nil

/*/{Protheus.doc} fGravTit
Grava os valores gerados no arquivo de titulos
@author  Emerson Rosa de Souza
@since   13/08/2001
@version 1.0
/*/
Function fGravTit(cFilGrav, cCCGrav, cMatGrav, nValTit, aChaveAgrup, nRecAgrup, cAliasAux, aChaveDet)
	Local cAlias     := Alias()
	Local cFilAux    := cFilAnt
	Local cCposRC1
	Local nCnt1
	Local dDataAux
	Local aAreaSRA   := SRA->( GetArea() )
	Local aAreaSRZ   := SRZ->( GetArea() )
	Local aAreaAux	 := {}

	Local aDadosAuto := {} // Array para o cadastro de fornecedores via ExecAuto
	Local aDadosPE   := {} // Array de retorno para o PE GP650CFO
	Local nOpc 		 := 0
	Local aErro 	 := {}
	Local cLog 	  	 := ""
	Local aLogCampo  := {}
	Local nI 		 := 0
	Local cPeriodo   := ""
	Local lGeraRJ1   := .F.
	Local lExist	 := .F.
	Local nPosFor	 := 0
	Local nPosLoj 	 := 0
	Local cCodSA2    := ""

	Private nVlTotTit  := nValTit
	Private cCpoFornec := cFornec
	Private cNovoTit

	//Variáveis declaradas para a execução da MSExecAuto
	Private lMsErroAuto    := .F.
	Private lMsHelpAuto    := .T.
	Private lAutoErrNoFile := .T.

	Static cValidFil	:= fValidFil()
	Static lCadForA 	:= SuperGetMv( 'MV_CADFORA', .F., .F., cFilAnt )

	DEFAULT cAliasAux := cAliasLan
	DEFAULT aChaveDet := {}

	If cAliasAux $ "SRR*SRC" .And. lTamTitDif .And. lMsgRJ1
		lMsgRJ1 := .F.
		If !MSGYESNO(STR0049) //Deseja continuar a geração de títulos sem gravar os dados na RJ1?
			Return .F.
		EndIf
	ElseIf cAliasAux $ "SRR*SRC"
		lGeraRJ1 := !lTamTitDif
	EndIf

	//Variaveis utilizadas para agrupamento Filial/C.Custo quando o usuario definir Data de Vencimento pelo arquivo de CABECALHO
	aChaveAgrup := If( aChaveAgrup == Nil, {}, aChaveAgrup )
	nRecAgrup   := If( nRecAgrup   == Nil, 0,  nRecAgrup   )

	If !( cFilGrav $ cValidFil )
		If !lTitLog3
			aAdd(aLogFile,{5,OemToAnsi(STR0046) + CRLF}) // Os títulos que seguem não foram gerados pois o usuário não tem acesso as filiais dos mesmos:
			lTitLog3 := .T.
		EndIf

		aAdd(aLogFile,{6,""})

		If !Empty(cFilGrav)
			aAdd( aLogFile[Len(aLogFile)], OemToAnsi(STR0024) + cFilGrav )
		Endif
		If !Empty(cCCGrav)
			aAdd( aLogFile[Len(aLogFile)], OemToAnsi(STR0025) + cCCGrav )
		Endif
		If !Empty(cMatGrav)
			aAdd( aLogFile[Len(aLogFile)], OemToAnsi(STR0026) + cMatGrav )
		Endif
		aAdd( aLogFile[Len(aLogFile)], OemToAnsi(STR0027) + cPrefix )
		aAdd( aLogFile[Len(aLogFile)], OemToAnsi(STR0028) + cIdentTit )

		Return .T.
	EndIf

	If cAliasAux # Nil .And. !Empty(cAliasAux)
		aAreaAux	:= (cAliasAux)->(GetArea())
	EndIf

	If cAgrupa == "4"
		DbSelectArea( cAliasAux )

		If cAliasAux == "SRR" .And. !Empty(cCpoDtCab)
			SRR->( DbSetOrder(4) )
			cPeriodo := SubStr(cCompetTit,3,4) + SubStr(cCompetTit,1,2)
		EndIf

		If !Empty(cPeriodo)
			If DbSeek( cFilGrav + cMatGrav + cPeriodo )
				If ( !Empty(cAliasCab) .and. !Empty(cCpoDtCab) )
					dDataVenc := &(cAliasCab + "->" + cCpoDtCab)
				EndIf
			EndIf
		EndIf
	EndIf

	dDataVenc := If( !Empty(dVctoInf),dVctoInf,dDataVenc)
	dDataAux  := DataValida(dDataVenc,If(cdiaUtil =="1",.F.,.T.)) // Vencimento real
	dDataVenc := If(dDataAux < dDataVenc,dDataAux,dDataVenc)      // Vencimento

	If lConsiste
		lExist	:= fExistTit(xFilial("RC1", cFilGrav ),cPrefix,cIdentTit,cFilGrav,cCCGrav,cMatGrav,cAgrupa,cCompetTit,nVlTotTit,dDataVenc)
		If lExist
			If Len(aAreaAux) > 0
				RestArea( aAreaAux )
			EndIf
			If nVlTotTit > 0
				Return .T.
			Else
				Return .F.
			EndIf
		EndIf
	EndIf

	If !Empty(cFilGrav) .And. nVlTotTit > 0
		//Verifica se Fornecedor foi preenchido com campo de arquivo
		If "_" $ cFornec
			cCpoFornec := ""
			If cAgrupa $ "2*3" .And. cCCGrav # Nil
				dbSelectArea( cAliasCC )
				dbSeek( xFilial(cAliasCC) + cCCGrav )
				cCpoFornec := &( cAliasCC + "->" + AllTrim(cFornec) )
			ElseIf cAgrupa == "4" .And. cMatGrav # Nil
				dbSelectArea( "SRA" )
				dbSeek( cFilGrav + cMatGrav )
				cCpoFornec := &( "SRA->" + AllTrim(cFornec) )
				If lCadForA
					DbSelectArea( "RDZ" )
					RDZ->(DbSetOrder(1)) //RDZ_FILIAL+RDZ_EMPENT+RDZ_FILENT+RDZ_ENTIDA+RDZ_CODENT+RDZ_CODRD0
					If (RDZ->(MsSeek(xFilial("RDZ") + cEmpAnt + xFilial("SRA",SRA->RA_FILIAL) + "SRA" + cFilGrav + cMatGrav)))
						DbSelectArea( "RD0" )
						RD0->(DbSetOrder(1)) //RD0_FILIAL+RD0_CODIGO
						If (RD0->(MsSeek(xFilial("RD0") + RDZ->RDZ_CODRD0)))
							//Incluir os dados na aDadosAuto para gravação na SA2 via ExecAuto
							DbSelectArea( "SA2" )
							SA2->(DbSetOrder(1)) //A2_FILIAL+A2_COD+A2_LOJA

							If (Empty(RD0->RD0_FORNEC + RD0->RD0_LOJA))
								//Verifica se o fornecedor existe na SA2
								If SA2->(MsSeek(xFilial("SA2") + &( "SRA->" + AllTrim(cFornec) )))
									If Empty( cCodSA2 := CriaVar("A2_COD") )
										cCpoFornec := GetSx8Num("SA2","A2_COD",,)
									Else
										cCpoFornec := cCodSA2
										If __lSx8
											RollBackSX8()
										EndIf
									EndIf
								EndIf

								//Tratamento de campos que serão enviados da SRA para SA2
								Aadd( aDadosAuto, {'A2_COD'		, cCpoFornec , NIL} )
								Aadd( aDadosAuto, {'A2_LOJA' 	, cLoja , Nil} )
								Aadd( aDadosAuto, {'A2_NOME'	, If(TamSX3( 'RA_NOME' )[1] > TamSX3( 'A2_NOME' )[1], Substr(SRA->RA_NOME , 1 , TamSX3( 'A2_NOME' )[1] ) , SRA->RA_NOME ) , Nil} )
								Aadd( aDadosAuto, {'A2_NREDUZ'	, If(TamSX3( 'RA_NOME' )[1] > TamSX3( 'A2_NREDUZ' )[1], Substr(SRA->RA_NOME , 1 , TamSX3( 'A2_NREDUZ' )[1] ) , SRA->RA_NOME ) , Nil} )

								If !Empty(SRA->RA_ENDEREC)
									Aadd( aDadosAuto, {'A2_END' , If(TamSX3( 'RA_ENDEREC' )[1] > TamSX3( 'A2_END' )[1], Substr(SRA->RA_ENDEREC , 1 , TamSX3( 'A2_END' )[1] ) , SRA->RA_ENDEREC ) , Nil} )
								Else
									Aadd( aLogCampo, "SRA->RA_ENDEREC")
								Endif

								If !Empty(SRA->RA_ESTADO)
									Aadd( aDadosAuto, {'A2_EST' , If(TamSX3( 'RA_ESTADO' )[1] > TamSX3( 'A2_EST' )[1], Substr(SRA->RA_ESTADO , 1 , TamSX3( 'A2_EST' ) )[1] , SRA->RA_ESTADO ) , Nil} )
								Else
									Aadd( aLogCampo, "SRA->RA_ESTADO")
								Endif

								If !Empty(SRA->RA_MUNICIP)
									Aadd ( aDadosAuto, {'A2_MUN' , If(TamSX3( 'RA_MUNICIP' )[1] > TamSX3( 'A2_MUN' )[1], Substr(SRA->RA_MUNICIP , 1 , TamSX3( 'A2_MUN'  )[1] ) , SRA->RA_MUNICIP ) , Nil} )
								Else
									Aadd( aLogCampo, "SRA->RA_MUNICIP")
								Endif

								Aadd( aDadosAuto, {'A2_TIPO' , 'F' , Nil} )
								Aadd( aDadosAuto, {'A2_CGC' , SRA->RA_CIC , Nil} )
								Aadd( aDadosAuto, {'A2_BAIRRO' , If(TamSX3( 'RA_BAIRRO' )[1] > TamSX3( 'A2_BAIRRO' )[1], Substr(SRA->RA_BAIRRO , 1 , TamSX3( 'A2_BAIRRO'  )[1] ) , SRA->RA_BAIRRO ) , Nil} )

								If Len(aLogCampo) > 0
									If !lTitLog2
										aAdd(aLogFile,{3,OemToAnsi(STR0035)}) // Os funcionários abaixo não foram cadastrados como fornecedores
										lTitLog2 := .T.
									EndIf
									aAdd(aLogFile,{4,"",""})
									aLogFile[Len(aLogFile),2] += STR0033 + SRA->RA_FILIAL + SRA->RA_MAT + STR0037
									aLogFile[Len(aLogFile),3] += "É necessário que os campos do funcionário estejam preenchidos:" + CRLF
									For nCnt1 := 1 to Len(aLogCampo)
										aLogFile[Len(aLogFile),3] += aLogCampo[nCnt1] + " / "
									Next nCnt1
									Return .T.
								Endif

								If lGP650CFO
									aDadosPE := ExecBlock("GP650CFO",.F.,.F.,aDadosAuto)

									If ValType(aDadosPE) == "A" .And. Len(aDadosPE) >= 10
										aDadosAuto := aDadosPE
									EndIf
								EndIf

								//Cadastra um novo Fornecedor
								MSExecAuto({|x, y| MATA020(x, y)},aDadosAuto, 3)

								If !lMsErroAuto
									nPosFor := Ascan(aDadosAuto, { |x|  Upper(x[1]) == "A2_COD" })
									nPosLoj := Ascan(aDadosAuto, { |x|  Upper(x[1]) == "A2_LOJA"})

									If nPosFor > 0 .AND. nPosLoj > 0
										RecLock("RD0",.F.)
										RD0->RD0_FORNEC := aDadosAuto[nPosFor,2]	//SA2->A2_COD
										RD0->RD0_LOJA 	:= aDadosAuto[nPosLoj,2]	//SA2->A2_LOJA
										RD0->(MsUnlock())
									Endif

									ConfirmSX8()
								Else
									If Empty(cCodSA2)
										RollBackSX8()
									EndIf

									aErro := GetAutoGRLog()

									VarInfo(STR0036, aErro)

									For nI := 1 To Len(aErro)
										cLog += StrTran( StrTran( StrTran( StrTran( StrTran( aErro[nI], CHR(10), " " ), CHR(13), " " ), "/", "" ), "<", "" ), ">", "" ) + "|"
									Next nI

									aAdd(aLogFile,{4,"",""})
									aLogFile[Len(aLogFile),2] += Alltrim(StrTran(cLog, "-", ""))

									SA2->(DbCloseArea())
									RD0->(DbCloseArea())
									SRA->(DbCloseArea())

									Return .T.
								EndIf
							EndIf

							SA2->(DbCloseArea())
							cCpoFornec := RD0->RD0_FORNEC
							cLoja      := RD0->RD0_LOJA
						EndIf

						RD0->(DbCloseArea())
					Else
						If !lTitLog2
							aAdd(aLogFile,{3,OemToAnsi(STR0035) + CRLF}) // Os funcionários abaixo não foram cadastrados como fornecedores
							lTitLog2 := .T.
						EndIf

						aAdd(aLogFile,{4,""})
						aLogFile[Len(aLogFile),2]+= STR0033 + cFilGrav + cMatGrav + STR0034 //O funcionário não pode ser cadastrado pois não possui vínculo na RDZ + CRLF

						RDZ->(DbCloseArea())
						Return .T.
					EndIf
					RDZ->(DbCloseArea())
				EndIf
			EndIf
		EndIf

		//Posiciona cFilAnt na filial corrente p/ garantir Integridade
		cFilAnt := cFilGrav

		cNovoTit := GetSx8Num("RC1","RC1_NUMTIT",,RetOrdem( "RC1" , "RC1_FILIAL+RC1_NUMTIT" ))

		DbSelectArea( "RC1" )

		//Ponto de entrada para checar o valor do titulo
		If lGp650Chk
			aRet1 := {}
			aRet1 := ExecBlock("GP650CHK",.F.,.F.,{nRecAgrup,.T.})
			If ValType(aRet1) == "A" .and. len(aRet1) == 2
				If aRet1 [2] = .F.
					dbSelectArea( cAlias )
					RollbackSX8()
					Return( .T. )
				EndIf
				nRecAgrup := aRet1 [1]
			Else
				RollbackSX8()
				MsgAlert(OemToAnsi(STR0039)) // "O retorno do ponto de entrada GP650CHK deve ser um array e possuir duas posições, sendo a primeira um valor e a segunda uma variável lógica"
				Return ( .F. )
			EndIf
		EndIf

		Begin Transaction
			If nRecAgrup > 0
				dbGoTo( nRecAgrup )
				RecLock("RC1",.F.,.F.)
				RC1->RC1_VALOR += nVlTotTit
				MsUnLock()
			Else
				//Novo numero do titulo deve ser antes do Reclock devido a integridade
				RecLock("RC1",.T.,.T.)
				RC1->RC1_FILIAL   := xFilial("RC1", cFilGrav )
				RC1->RC1_INTEGR   := "0"
				RC1->RC1_FILTIT   := cFilGrav
				If cCCGrav # Nil .and. cAgrupa # "1"
					RC1->RC1_CC := cCCGrav
				EndIf
				If cMatGrav # Nil
					RC1->RC1_MAT := cMatGrav
				EndIf

				//Tratamento de Integração Logix x Rh Protheus
				If cpaisloc == "BRA"
					If lRc1Arelin
						fGravArelin( cMatGrav )
					EndIf
				EndIf

				RC1->RC1_CODTIT   := cCodTit
				RC1->RC1_DESCRI   := cDescri
				RC1->RC1_PREFIX   := cPrefix
				RC1->RC1_NUMTIT   := cNovoTit
				RC1->RC1_TIPO     := cIdentTit
				RC1->RC1_NATURE   := cNature
				RC1->RC1_FORNEC   := cCpoFornec
				RC1->RC1_LOJA	  := cLoja
				RC1->RC1_EMISSA   := dDtEmisTit
				RC1->RC1_VENCTO   := dDataVenc
				RC1->RC1_VENREA   := dDataAux
				RC1->RC1_VALOR    := nVlTotTit
				RC1->RC1_DTBUSI   := dDataDeT
				RC1->RC1_DTBUSF   := dDataAteT
				RC1->RC1_COMPET   := cCompetTit

				If cpaisloc == "BRA"
					If cTipoRet <> "2"
						RC1->RC1_CODRET := cCodRetTit
					Else
						RC1->RC1_CODRET := cSRACodRet
					EndIf
				EndIf

				//Grava os campos criados pelo usuario - do RC0 para o RC1
				For nCnt1 := 1 To Len(aCposUsu)
					cCposRC1  := aCposUsu[nCnt1,2]
					&cCposRC1 := aCposUsu[nCnt1,3]
				Next nCnt1

				//Grava no array o numero do recno para agrupar posteriormente
				If Len(aChaveAgrup ) > 0
					aChaveAgrup[Len(aChaveAgrup),2] := Recno()
				EndIf

				RC1->( MsUnLock() )

				ConfirmSX8()
			EndIf

			If lGeraRJ1
				fGrvTitCal(aChaveDet)
			EndIf

			SX3->(DbSetOrder(2))

			//Gravacao dos valores do Titulo agrupados por Item Contabil.
			//ColumnPos() - Retirar essa validação do campo QF_FILTIT a partir do release 12.1.18
			If SX3->( DbSeek("QF_FILTIT") ) //se campo existe realiza gravacao
				For nI := 1 to Len(aRatTit)
					RecLock("SQF",.T.)
						SQF->QF_FILIAL := xFilial("SQF",cFilGrav)
						SQF->QF_FILTIT := cFilGrav
						SQF->QF_NUMTIT := cNovoTit
						SQF->QF_ITEM   := aRatTit[nI][1]
						SQF->QF_VALOR  := aRatTit[nI][2]
					MsUnLock()
				Next nI

				aRatTit := {}
			EndIf

			//Ponto de entrada para alterar campos do RC1
			If lGp650Cpo
				ExecBlock("GP650CPO",.F.,.F.)
			EndIf

			//Integracao com modulo SIGAPCO
			PcoDetLan("000092","01","GPEM650")
		End Transaction

		//Retorna filial original para o cFilAnt
		cFilAnt := cFilAux
	EndIf

	RestArea( aAreaSRA )
	RestArea( aAreaSRZ )

	If Len(aAreaAux) > 0
		RestArea( aAreaAux )
	EndIf

	DbSelectArea( cAlias )

Return .T.

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³fGravArelin  ºAutor  ³Tiago Malta      º Data ³  10/09/09   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Integração Logix X Rh Protheus.                  		  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³                                                            º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function fGravArelin( cMat )

	Local cDepto  := space(10)
	Local cArelin := space(10)

	IF cMat <> nil .AND. !EMPTY(cMat) .AND. Getmv("MV_ERPLOGI") == '1'

		SRA->( dbSetOrder(1) )
		SRA->( dbSeek( xFilial('SRA') + cMat ) )
		cDepto := SRA->RA_DEPTO

		SQB->( dbSetOrder(1) )
		SQB->( dbSeek( xFilial('SQB') + cDepto ) )
		cArelin := SQB->QB_ARELIN

		IF !EMPTY(cArelin)
			RC1->RC1_ARELIN := cArelin
		ENDIF

	ENDIF

Return()

/*/{Protheus.doc} fExistTit
Verifica se o título já foi gerado
@author  gabriel.almeida
@since   17/07/2015
@param   cFil = Filial vinda da RC0
@param   cPrex = Prefixo vindo da RC0
@param   cTipoT = Tipo do título vindo da RC0
@param   cFilt = Filial do título vindo da RC0
@param   cCC = Centro de custo vindo da RC0
@param   cMat = Matrícula vinda da RC0
@param   cAgrup = Agrupamento
@param   cCompet = Competência do título
@param   nValor = Valor do título
@param   dDtVenc = Data de vencimento do título
/*/
Static Function fExistTit(cFil,cPrex,cTipoT,cFilT,cCC,cMat,cAgrup,cCompet,nValor,dDtVenc)
	Local lRet      := .F.
	Local aArea     := GetArea()
	Local cArqRC1   := CriaTrab( "", .F. )
	Local cArqRJ1   := CriaTrab( "", .F. )
	Local nIndex    := 0
	Local cIndex    := ""
	Local cTitRes 		:= ""
	Local cTitFer 		:= ""
	Local cTitFol 		:= ""
	Local cTitAdi 		:= ""
	Local nTam1     := TamSX3("RC1_VALOR")[1]
	Local nTam2     := TamSX3("RC1_VALOR")[2]
	Local nTam3		:= TamSX3("RJ1_PREFIX")[1]
	Local lCfgTit	:= .F.
	Local cDataVen  := ""
	Local cFilGra	:= cFilT
	Local cCompetOr	:= ""

	If lCtrlTit
		cTitRes 	:= SuperGetMv("MV_BTITRES",,"0")
		cTitFer 	:= SuperGetMv("MV_BTITFER",,"0")
		cTitFol 	:= SuperGetMv("MV_BTITFOL",,"0")
		cTitAdi 	:= SuperGetMv("MV_BTITADT",,"0")
		// Executa validação apenas se controle estiver ativo
		If  (cTitRes $ "1*2" .And. cTipoT == "RES") .Or.;
		 	(cTitFer $ "1*2" .And. cTipoT == "FER") .Or. ;
			(cTitFol $ "1*2" .And. cTipoT == "FOL") .Or. ;
			(cTitAdi $ "1*2" .And. cTipoT == "ADI")
			lCfgTit := .T.
		Endif
	EndIf

	Do Case
		Case cAgrup == "1" //Filial
			cIndex := "RC1_FILIAL+RC1_PREFIX+RC1_TIPO+RC1_COMPET+Str(RC1_VALOR,nTam1,nTam2)+RC1_FILTIT"
			cMat   := ""
			cCC    := ""
		Case cAgrup $ "2/3" //Centro de Custo
			cIndex := "RC1_FILIAL+RC1_PREFIX+RC1_TIPO+RC1_COMPET+Str(RC1_VALOR,nTam1,nTam2)+RC1_FILTIT+RC1_CC"
			cMat   := ""
		Case cAgrup == "4" //Matrícula
			cIndex := "RC1_FILIAL+RC1_PREFIX+RC1_TIPO+RC1_COMPET+Str(RC1_VALOR,nTam1,nTam2)+RC1_MAT"
			cFilT  := ""
			cCC    := ""
	EndCase

	If cChaveDup == "2" //Incluí a data de vencimento na chave
		cIndex   += "+DTOS(RC1_VENCTO)"
		cDataVen := DToS(dDtVenc)
	EndIf

	RC1->(IndRegua( "RC1", cArqRC1, cIndex, NIL, NIL, NIL, .F.))
	nIndex := RetIndex( "RC1" ) + 1
	RC1->( DbSetOrder( nIndex ) )

	cTipoT := cTipoT + Space(TamSX3("RC1_TIPO")[1]-Len(cTipoT))

	//Se já existir log por duplicidade na RJ1, não adiciona mais dados da RC1
	If RC1->( MsSeek( cFil+cPrex+cTipoT+cCompet+Str(nValor,nTam1,nTam2)+cFilT+cCC+cMat+cDataVen ) ) .And. ;
		If(!Empty(aLogFile) .And. aScan(aLogFile,{|x| x[1] == 3}) > 0, .F. , .T.)

		lRet := .T.

		If !lTitLog1
			// O valor 1 na primeira posição do array representa o Log de duplicidade de títulos
			aAdd(aLogFile,{1,OemToAnsi(STR0023) + CRLF})
			lTitLog1 := .T.
		EndIf
		aAdd(aLogFile,{2})
		If !Empty(cFilT)
			aAdd( aLogFile[Len(aLogFile)], OemToAnsi(STR0024) + cFilT )
		EndIf
		If !Empty(cCC)
			aAdd( aLogFile[Len(aLogFile)], OemToAnsi(STR0025) + cCC )
		EndIf
		If !Empty(cMat)
			aAdd( aLogFile[Len(aLogFile)], OemToAnsi(STR0025) + cCC )
		EndIf
		aAdd( aLogFile[Len(aLogFile)], OemToAnsi(STR0027) + cPrex )
		aAdd( aLogFile[Len(aLogFile)], OemToAnsi(STR0028) + cTipoT )
		aAdd( aLogFile[Len(aLogFile)], OemToAnsi(STR0029) + cCompet )
		If !Empty(cDataVen)
			aAdd( aLogFile[Len(aLogFile)], OemToAnsi(STR0048) + DToC(dDtVenc) )
		EndIf
		aAdd( aLogFile[Len(aLogFile)], OemToAnsi(STR0030) + Alltrim(Transform(nValor,"@E 9,999,999,999,999.99")) )
	//Se já existir log por duplicidade na RC1, não adiciona mais dados da RJ1
	ElseIf lCtrlTit .And. lCfgTit .And.  If(!Empty(aLogFile) .And. aScan(aLogFile,{|x| x[1] == 1}) > 0, .F. , .T.)

		// Verifica se chave principal (Processo+Roteiro+Período+Semana) já foi gerado por outro título de agrupamento diferente
		cCompetOr	:=  cCompet
		cCompet		:= SubStr(cCompet,3,4)+SubStr(cCompet,1,2)
		dbSelectArea("RJ1")
		RJ1->( DbSetOrder( 4 ) ) // RJ1_FILIAL+RJ1_PREFIX+RJ1_PERIODO+RJ1_TIPO
		If RJ1->( dbSeek( cFilGra+PadR(cPrex,nTam3)+cCompet+cTipoT) )
			While RJ1->(!Eof()) .And. (	RJ1->RJ1_FILIAL == cFilGra  .AND. ;
								RJ1->RJ1_PREFIX == PadR(cPrex,nTam3) .AND. ;
								RJ1->RJ1_PERIODO == cCompet .AND. ;
								RJ1->RJ1_TIPO == cTipoT .AND. !lRet)

				If !lTitLog1
					// O valor 3 na primeira posição do array representa o Log de duplicidade de títulos
					aAdd(aLogFile,{3,OemToAnsi(STR0052) + CRLF +; 							// Não foram gerados títulos pois já foram gerados valores para a mesma composição:
									 OemToAnsi(STR0024) + cFilGra 	+ CRLF +; 				// Filial:
									 OemToAnsi(STR0027) + cPrex 	+ CRLF +; 				// Prefixo:
									 OemToAnsi(STR0029) + cCompetOr + CRLF +; 				// Competência:
									 OemToAnsi(STR0028) + cTipoT 	+ CRLF + CRLF + ;		// Tipo:
									 OemToAnsi(STR0060) + CRLF 		+ CRLF + ;   			// Verificar configuração dos parâmetros:  MV_BTITRES, MV_BTITFOL, MV_BTITADT e MV_BTITFER
									 OemToAnsi(STR0053) }) 									// Acesse a opção de Manutenção de Título e filtre os títulos com as configurações abaixo:
					lTitLog1 := .T.
				EndIf

				If !(cFilGra+cPrex+cCompet+RJ1->RJ1_CODTIT+RJ1->RJ1_NUMTIT $ cChvsRJ1)
					aAdd(aLogFile,{4})
					aAdd( aLogFile[Len(aLogFile)], OemToAnsi(STR0027) + cPrex )
					aAdd( aLogFile[Len(aLogFile)], OemToAnsi(STR0028) + cTipoT )
					aAdd( aLogFile[Len(aLogFile)], OemToAnsi(STR0029) + cCompetOr )
					aAdd( aLogFile[Len(aLogFile)], OemToAnsi(STR0051) + RJ1->RJ1_CODTIT )

					cChvsRJ1	+= cFilGra+cPrex+cCompet+RJ1->RJ1_CODTIT+RJ1->RJ1_NUMTIT + "|"
					lRet := .T.
				ElseIf cFilGra+cPrex+cCompet+RJ1->RJ1_CODTIT+RJ1->RJ1_NUMTIT $ cChvsRJ1
					lRet := .T.
				EndIf

				RJ1->(DbSkip())

			Enddo
		Else
			lRet := .F.
		EndIf

	EndIf

	RestArea(aArea)

Return lRet

/*/{Protheus.doc} fTamCpoFor
Valida o tamanho do campo fornecedor
@author Gabriel de Souza Almeida
@since 26/10/2015
@version P12
@param cCpo, varchar, Código do Fornecedor
@return lRet
/*/
Function fTamCpoFor(cCpo)
	Local lRet := .T.
	Local nTamSA2 := 0
	Local nTamSRA := 0

	If lRet .And. M->RC0_AGRUPA == "4"
		If "_" $ cCpo
			nTamSA2 := TAMSX3("A2_COD")[1]
			nTamSRA := TAMSX3(cCpo)[1]
			If nTamSRA > nTamSA2
				MsgAlert(STR0031) //Tamanho do campo maior do que o configurado para o campo A2_COD da tabela de fornecedor.
				lRet := .F.
			EndIf
		EndIf
	EndIf
Return lRet

/*/{Protheus.doc} fSomaRat
Funcao responsavel em alimentar array aRatTit que guarda valor do titulo rateado por Item Contabil.
@author esther.viveiro
@since 14/08/2017
@version P12
@param nValor, numerico, valor rateado
@param cItem, caractere, codigo do Item Contabil referente ao valor enviado.
@return Nil
/*/
Static Function fSomaRat(nValor, cItem)
	If ( ValType(aRatTit) == "A" )
		nPosItem := aScan(aRatTit,{|aBusca| aBusca[1] == cItem})
		If nPosItem > 0 //encontrou Item no array
			aRatTit[nPosItem][2] += nValor
		Else
			aadd(aRatTit,{cItem,nValor})
		EndIf
	EndIf
Return Nil

Function GP650Venc()

	If !Empty(MV_PAR13) .And. MV_PAR11 > MV_PAR13
		Help(,,STR0047) //"Data de emissão tem que ser menor que a data de vencimento!"
		Return .F.
	EndIf

Return .T.


/*/{Protheus.doc} fGrvTitCal
//Grava os detalhes do titulo
@author paulo.inzonha
@since 24/01/2019
@version 1.0
@return Logico
@type function
/*/
Function fGrvTitCal(aChaveDet)
	Local nX 		:= 0
	Local nTamFil	:= TamSX3("RA_FILIAL")[1]

	If TCCanOpen(RetSqlname("RJ1")) .AND. LEN(aChaveDet) > 0
		dbSelectArea( "RJ1" )
		For nX := 1 To Len(aChaveDet)
			RecLock("RJ1",.T.)

			// Posicoes no array
			//1 -_FILIAL
			//2 -_PROCES
			//3- _ROTEIR
			//4- _PERIOD
			//5- _SEMANA
			//6- _DTGERA/_DATA/_DATPGT
			//7 -_MAT

			RJ1->RJ1_FILIAL := RC1->RC1_FILTIT
			RJ1->RJ1_CODTIT := RC1->RC1_CODTIT
			RJ1->RJ1_PREFIX	:= RC1->RC1_PREFIX
			RJ1->RJ1_NUMTIT := RC1->RC1_NUMTIT

			If lCpoInteg
				RJ1->RJ1_PROCES := aChaveDet[nX,2]
				RJ1->RJ1_ROTEIR	:= aChaveDet[nX,3]
				RJ1->RJ1_TIPO 	:= cIdentTit
			EndIf

			RJ1->RJ1_PERIOD := aChaveDet[nX,4]
			RJ1->RJ1_SEMANA := aChaveDet[nX,5]
			RJ1->RJ1_DTGERA := aChaveDet[nX,6]
			RJ1->RJ1_FILFUN := If(Empty(aChaveDet[nX,7]),Space(nTamFil), aChaveDet[nX,1])
			RJ1->RJ1_MAT	:= aChaveDet[nX,7]

			RJ1->( MsUnLock() )
		Next nX
		dbCloseArea( "RJ1" )
	EndIf

Return .T.

/*/{Protheus.doc} FGPEM650NumTit
//Verifica a gravação do campo RJ1_NUMTIT
@author Wesley Alves Pereira
@since 30/10/2019
@version 1.0
@return Logico
@type function
/*/
Function FGPEM650NumTit()
	Local lReto := .T.

	lReto := ChkFile("RJ1") .And. ( TamSX3( "RC1_NUMTIT" )[1] == TamSX3( "RJ1_NUMTIT" )[1] )

	If ! lReto
		Help(,,STR0050) //"Há diferença entre o tamanho do campo RC1_NUMTIT e RJ1_NUMTIT, porém para que os dados sejam gravados na RJ1 é necessário que esses dois campos tenham o mesmo tamanho.
	EndIf

Return (lReto )

/*/{Protheus.doc} fVldRJ1
// Caso usuário possuir base atualizada mas não ter executado o RDMAKE é exibida uma mensagem
@author raquel.andrade
@since 03/08/2020
@version 1.0
@return Logico
/*/
Static Function fVldRJ1()
	Local lRet := .T.

	dbSelectArea("RJ1")
	RJ1->( DbSetOrder( 1 ) ) // RJ1_FILIAL+RJ1_PREFIX+RJ1_PERIODO+RJ1_TIPO
	If RJ1->( dbSeek( cFilAnt ) )
			While RJ1->(!Eof()) .And. (	RJ1->RJ1_FILIAL == cFilAnt) .And. lRet
				If Empty(RJ1->RJ1_ROTEIR)
					lRet := .F.
				EndIf
				RJ1->(DbSkip())
			EndDo
	EndIf

Return lRet



/*/{Protheus.doc} fAlertRJ1
Função para exibição de alerta e link para o TDN com orientação sobre atualização da RJ1 via rdmake
@author raquel.andrade
@since 03/08/2020
@version 1.0
/*/
Static Function fAlertRJ1()
	Local oButton1
	Local oButton2
	Local oCheckBo1
	Local lCheckBo1 	:= .F.
	Local lRet			:= .T.
	Local oGroup1
	Local oPanel1
	Local oSay1
	Local cSession		:= "AlertaGPEM650_"
	Local lChkMsg 		:= fwGetProfString(cSession,"AlertaGPEM650_" + cUserName,'',.T.) == ""
	Local cTitRes 		:= ""
	Local cTitFer 		:= ""
	Local cTitFol 		:= ""
	Local cTitAdi 		:= ""
	Local oDlg

	If lCtrlTit
		cTitRes 	:= SuperGetMv("MV_BTITRES",,"0")
		cTitFer 	:= SuperGetMv("MV_BTITFER",,"0")
		cTitFol 	:= SuperGetMv("MV_BTITFOL",,"0")
		cTitAdi 	:= SuperGetMv("MV_BTITADT",,"0")
		If lChkMsg .And. (cTitRes $ "1*2" .Or. cTitFer $ "1*2" .Or. cTitFol $ "1*2" .Or. cTitAdi $ "1*2") // Apenas exibe mensagem se existe controle
			DEFINE MSDIALOG oDlg TITLE OemToAnsi(STR0054) FROM 000, 000  TO 200, 500 COLORS 0, 16777215 PIXEL //"Atualização de Base de Dados - Registros RJ1"

				@ 000, 000 MSPANEL oPanel1 SIZE 300, 150 OF oDlg COLORS 0, 16777215 RAISED
				@ 005, 012 GROUP oGroup1 TO 065, 237 PROMPT OemToAnsi(STR0008) OF oPanel1 COLOR 0, 16777215 PIXEL //"Atenção"
				//'Ao habilitar a base de dados para geração de detalhes de títulos para outros roteiros além da Rescisão é necessário atualizar registros anteriores através do rdmake AtuRJ1.prw. '
				//'Caso o rdmake AtuRJ1.prw não seja executado, a base poderá gerar dados inconsistentes.'
				//'Clique em "Abrir Link" para consultar a documentação no TDN'
				@ 020, 017 SAY oSay1 PROMPT OemToAnsi(STR0055) + OemToAnsi(STR0056) + CRLF + OemToAnsi(STR0057) SIZE 215, 035 OF oPanel1 COLORS 0, 16777215 PIXEL
				@ 080, 012 CHECKBOX oCheckBo1 VAR lCheckBo1 PROMPT OEMToAnsi(STR0058) SIZE 067, 008 OF oPanel1 COLORS 0, 16777215 PIXEL //"Não exibir novamente"
				@ 070, 160 BUTTON oButton1 PROMPT STR0059 SIZE 037, 012 OF oPanel1 PIXEL//"Abrir Link"
				@ 070, 200 BUTTON oButton2 PROMPT "OK" SIZE 037, 012 OF oPanel1 PIXEL

				oButton1:bLClicked := {|| ShellExecute("open","https://tdn.totvs.com/x/KXUxIQ","","",1) }
				oButton2:bLClicked := {|| oDlg:End() }

			ACTIVATE MSDIALOG oDlg CENTERED

			If lCheckBo1
				fwWriteProfString(cSession, "MSG_GPEM650_" + cUserName, 'CHECKED', .T.)
			EndIf

			lRet	:= .F.

		EndIf
	EndIf

Return lRet

/*/{Protheus.doc} SchedDef
    Definições de agendamento do Schedule.
    @type Function
    @version 12.1.2410
    @author arthur.sales
    @since 09/10/2024
    @return Array, Definições do agendamento
/*/
Static Function SchedDef() As Array
    // Declaração das variáveis locais
    Local aParam As Array

    // Inicialização das variáveis
    aParam := {}

    // Montagem da estrutura do vetor de retorno
    AAdd(aParam, "P")      // Tipo do agendamento: "P" = Processo | "R" = Relatório
    AAdd(aParam, "GPM650") // Pergunte (SX1) (usar "PARAMDEF" caso não tenha conjunto de perguntas)
    AAdd(aParam, "")       // Alias principal (exclusivo para relatórios)
    AAdd(aParam, {})       // Vetor de ordenação (exclusivo para relatórios)
    AAdd(aParam, "")       // Título (exclusivo para relatórios)
Return aParam

/*/{Protheus.doc} fVldRes650
	Função de verificação da data e tipo de demissão, para uso no filtro SRA da definição de título de fgts mensal
    @version 1.0
    @author isabel.noguti
    @since 16/12/2024
    @return lRet, logico, se processa o registro posicionado ou não
/*/
Static Function fVldRes650()
    Local aArea		:= GetArea()
    Local lRet		:= .T.
	Local cCodSaq	:= ""
	Local dDemissa	:= SRA->RA_DEMISSA

	If !Empty(dDemissa) .And. ( Day(dDemissa) < 10 ) .And. AnoMes(dDemissa) == SomaMesAno(cAnoMes)
		dbSelectArea("SRG")
		SRG->(dbSetOrder(3)) //RG_FILIAL+RG_MAT+DTOS(RG_DATADEM)+DTOS(RG_DATAHOM)+RG_EFETIVA
		If SRG->( dbSeek( SRA->RA_FILIAL + SRA->RA_MAT + DtoS(dDemissa) ))
			cCodSaq := fDescRCC("S043",SRG->RG_TIPORES,1,2,52,2)	//CodigoAM
			lRet := cCodSaq $ "00*NA"
		EndIf
	EndIf

	RestArea(aArea)
Return lRet
