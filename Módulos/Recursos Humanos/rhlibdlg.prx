#INCLUDE "PROTHEUS.CH"   
#INCLUDE "RHLIBDLG.CH"

/*/


Ŀ
Funo     RHLIBDLG  Autor  Rogerio Ribeiro da Cruz			  Data  12/05/2009 
Ĵ
Descrio  Biblioteca de funcoes para dialogs, mensagens e perguntas		         
Ĵ
 Uso       Generico                                                   				 
Ĵ
         ATUALIZACOES SOFRIDAS DESDE A CONSTRUAO INICIAL.             				 
Ĵ
Programador  Data    FNC              Motivo da Alteracao                          
Ĵ
Emerson Camp10/12/1000000028320/2010Ajuste para nova interface 11. Com a aplicao  
                                    do parametro MV_ECMFTPP que afirma ser a       
                                    verso 11.5 do Protheus                        
Tiago Malta 10/06/1100000013091/2011Ajustes de tela para a versao 11.5.            
Marcos Perei03/09/15PCREQ-5342      Ajuste na ExistCPORH para aceitar a filial como
                                    parametro para a busca                         
Marcos Perei07/12/15PCDEF-87121     Ajuste na fCategoria() para filtrar categorias 
                                    especificas do SIGAGFP e tambem alinhar os     
                                    asteriscos na esquerda apos retorno da f_opcoes
Oswaldo L   21/12/17DRHPAG-9991     Tratar acessos diretos na SX2, pontuados       
                                    pelo sonarqube                                 
ٱ

/*/
/*
Usar essa documentao quando inclui o fonte em alguma pasta de inovao, por exemplo
12.1.6, a cada merge com o fonte da sustentao atualizar as informaes abaixo para 
que no merge final fique facil a atualizao do fonte
ͳ
Data Fonte Sustentao ChangeSet 
ĳ  
    11/06/2015          307896   
ͱ
*/

/*


Ŀ
Funo     RHLIBDLG  Autor  Rogerio Ribeiro da Cruz			  Data  12/05/2009 
Ĵ
Descrio  Biblioteca de funcoes para dialogs, mensagens e perguntas		         
Ĵ
 Uso       Generico                                                   				 
ٱ

/*/

Function InputDate(cMessage)
	Local oDlg
	Local dData:= CTOD("")
	Local oGetData
	Local lOk:= .F.	
	Local bSet15
	Local bSet24
	Local aButtons := {}
	
	//Ŀ
	// Declarao de arrays para dimensionar tela		                         
	//
	Local aAdvSize		:= {}
	Local aInfoAdvSize	:= {}
	Local aObjSize		:= {}
	Local aObjCoords	:= {}
	
    DEFAULT cMessage := ""
        
	/*
	Ŀ
	 Monta as Dimensoes dos Objetos         					   
	*/
	aAdvSize		:= MsAdvSize()                  
	aAdvSize[5] := 450
	aAdvSize[6] := 120
	aInfoAdvSize	:= { aAdvSize[1] , aAdvSize[2] , aAdvSize[3] , aAdvSize[4] , 10 , 10 }					 
	aAdd( aObjCoords , { 000 , 000 , .T. , .T. } )
	aObjSize	:= MsObjSize( aInfoAdvSize , aObjCoords )
	
	DEFINE DIALOG oDlg TITLE "TOTVS" FROM aAdvSize[7],0 TO aAdvSize[6], aAdvSize[5] OF GetWndDefault() PIXEL
		
		bSet15 := {|| lOk:= .T., oDlg:End()}
		bSet24 := {|| lOk:= .F., oDlg:End()}
		
		@ aObjSize[1][1]   , aObjSize[1][2] SAY cMessage SIZE 150,10 PIXEL
		@ aObjSize[1][1]+10, aObjSize[1][2] GET oGetData VAR dData SIZE 40,10 PIXEL //VALID OrgVldxDepto()		
						
		oDlg:lEscClose := .T.
	ACTIVATE DIALOG oDlg ON INIT EnchoiceBar(oDlg, bSet15, bSet24, Nil, aButtons) CENTERED	

	If !lOk
		dData:= CTOD("")
	EndIf
Return dData

/*


Ŀ
Funo     fAvisoBc  Autor  Emerson Rosa de Souza  Data  07.05.01 
Ĵ
Descrio  Mostra aviso da nao existencia dos campos banco e conta    
Ĵ
Sintaxe    fAvisoBC()				                                  
Ĵ
 Uso       Generico                                                   
ٱ

*/
Function fAvisoBC()
Aviso( STR0001, STR0002+STR0003, { STR0004 } ) //##"Atencao"##"Os campos RQ_BCDEPBE..."##"A impressao do relatorio..."##"Ok"
Return Nil

/*/


Ŀ
Funo	  fchkComp  Autor  Jose Ricardo		     Data  29.03.95 
Ĵ
Descrio  Checa a Competencia										  
Ĵ
Sintaxe    fchkcomp(lEmpty)											  
Ĵ
Parametros lEmpty = .T. para aceitar periodo em branco				  
Ĵ
 Uso		  Generico 												  
ٱ

/*/
Function fChkComp(lEmpty)
	Local cMesAno := &(Alltrim(ReadVar()))
	Default lEmpty := .F.
	
	If lEmpty
		If !Empty(AllTrim(cMesAno))
			If Val(Left(cMesAno,2)) < 1 .OR. Val(Left(cMesAno,2)) > 12
				Help(" ",1, "XINVMESANO")
				Return (.F.)
			EndIf
			If Len(AllTrim(cMesAno)) <> 6
				Help(" ",1,"XINVMESANO")
				Return (.F.)
			EndIf			
		EndIf
	Else
		If Empty(cMesAno) .OR. Val(Left(cMesAno,2)) < 1 .OR. Val(Left(cMesAno,2)) > 12
			Help(" ",1, "XINVMESANO")
			Return (.F.)
		EndIf
		If Len(AllTrim(cMesAno)) <> 6
			Help(" ",1,"XINVMESANO")
			Return (.F.)
		EndIf		
	EndIf
	
	If (Val(cMesAno) > 0 .AND. Val(cMesAno) < 10) .AND. Left(cMesAno,1) != "0"
		Help(" ",1, "XINVMESANO")
		Return (.F.)
	EndIf
Return (.T.)

/*/


Ŀ
Funo	 fSituacao  Autor  Ze Maria			     Data  13/04/95 
Ĵ
Descrio Selecionar a Situacao do Func. com Base no SX5			  
Ĵ
Sintaxe	  fSituacao() 												  
Ĵ
 Uso		  Generico 												  
ٱ

/*/
Function fSituacao(l1Elem,lTipoRet)
	Local cTitulo:=""
	Local MvPar
	Local MvParDef:=""
	Local nTam	:= 0
	
	Private aSit:={}
	
	l1Elem := If (l1Elem = Nil , .F. , .T.)
	
	Default lTipoRet := .T.
	
	cAlias := Alias() 					 // Salva Alias Anterior
	
	IF lTipoRet
		MvPar:=Rtrim(&(Alltrim(ReadVar())))			 // Carrega Nome da Variavel do Get em Questao
		mvRet:=Alltrim(ReadVar())			 // Iguala Nome da Variavel ao Nome variavel de Retorno
		nTam := Len(&mvRet)
	EndIf
	
	If FunName() == "CFGA010" // Cadastro de schedule
		MvPar := &(Alltrim(ReadVar()))
	EndIf
	
	dbSelectArea("SX5")

	If dbSeek(cFilial + "0031")
	   cTitulo := Alltrim(Left(X5Descri(), 20))
	EndIf

	If dbSeek(cFilial+"31")
		CursorWait()
			While !Eof() .AND. SX5->X5_Tabela == "31"
				Aadd(aSit,Left(SX5->X5_Chave,1) + " - " + Alltrim(X5Descri()))
				MvParDef+=Left(SX5->X5_Chave,1)
				dbSkip()
			Enddo
		CursorArrow()
	Else
		Help(" ",1, "GPEXSITDEF") // Estou usando situacao Default, nao achei tabela
		aSit := {;
					"  - " + STR0005,;	//"Normal"
					"A - " + STR0006,;	//"Afastado"
					"D - " + STR0007,;	//"Demitido"
					"T - " + STR0008,;	//"Transferido"
					"F - " + STR0009;	//"Ferias"
				}  
		MvParDef:=" ADTF"
		cTitulo :=STR0010  //"Situacao"
	EndIf
	
	IF lTipoRet
		IF f_Opcoes(@MvPar,cTitulo,aSit,MvParDef,12,49,l1Elem)  // Chama funcao f_Opcoes
			&MvRet := mvpar                                                                          // Devolve Resultado
			If nTam > Len(aSit)
				&MvRet += Replicate("*",nTam-Len(aSit))
			EndIf 
		EndIf	
	EndIf
	If !Empty(cAlias)
		dbSelectArea(cAlias) 								 // Retorna Alias
	EndIf
Return( IF( lTipoRet , .T. , MvParDef ) )


/*/


Ŀ
Funo	 fCategoria Autor  Ze Maria			     Data  13/04/95 
Ĵ
Descrio Selecionar a Categoria do Func. com Base no SX5			  
Ĵ
Sintaxe	  fCategoria()												  
Ĵ
 Uso		  Generico 												  
ٱ

/*/
Function fCategoria(l1Elem,lTipoRet)
	Local MvPar
	Local cTitulo	 := ""
	Local MvParDef	 := ""
	Local lGestPubl := if(ExistFunc("fUsaGFP"),fUsaGFP(),.f.) //Verifica se utiliza o modulo de Gestao de Folha Publica - SIGAGFP
	Local nElemRet   := If ( ValType(&( ReadVar() )) <> 'U' , Len( &( ReadVar() ) ) , 1 )
	Local lOpeSoc	:= SuperGetMv("MV_OPESOC", NIL, .F.) 
	Private aCat	 := {}
	Default lTipoRet := .T.
	
	l1Elem := If (l1Elem = Nil , .F. , .T.)
	cAlias := Alias() 					 // Salva Alias Anterior
	
	IF lTipoRet
		MvPar:=&(Alltrim(ReadVar()))		 // Carrega Nome da Variavel do Get em Questao
		mvRet:=Alltrim(ReadVar())			 // Iguala Nome da Variavel ao Nome variavel de Retorno
	EndIf
	
	dbSelectArea("SX5")
	
	If dbSeek(cFilial+"0028")
	   cTitulo := Alltrim(Left(X5Descri(),20))
	EndIf
	
	If dbSeek(cFilial+"28")
		CursorWait()
			While !Eof() .AND. SX5->X5_Tabela == "28"
				If lGestPubl .Or. (lOpeSoc .And. Left(SX5->X5_Chave,1) == '9') .Or. (!lGestPubl .and. Left(SX5->X5_Chave,1) >= 'A') .Or. (cPaisLoc == "PAR" .And. AllTrim(SX5->X5_Chave) $ "AEDMTS123456")
					Aadd(aCat,Left(SX5->X5_Chave,1) + " - " + Alltrim(X5Descri()))
					MvParDef+=Left(SX5->X5_Chave,1)
				EndIf
				dbSkip()
			Enddo
		CursorArrow()
	Else
		Help(" ",1, "GPEXCATDEF") // Estou usando situacao Default, nao achei tabela
		aCat :={;
					"M - "+STR0011,;	//"Mensalista"
					"H - "+STR0012,;	//"Horista"
					"S - "+STR0013,;	//"Semanalista"
					"T - "+STR0014,;	//"Taref.Sem."
					"C - "+STR0015,;	//"Comissionado"
					"D - "+STR0016,;	//"Diarista"###
					"R - "+STR0017;		//"Taref.Mens."
				}  	
		MvParDef:="MHSTCDR"
		cTitulo :=STR0018  //"Categoria"
	EndIf
	
	IF lTipoRet
		IF f_Opcoes(@MvPar,cTitulo,aCat,MvParDef,12,49,l1Elem,,nElemRet)  	// Chama funcao f_Opcoes
			mvpar  := strtran(mvpar,"*","")									// Retirar astericos que retorna na esquerda
			mvpar  := padr(mvpar,nElemRet,'*')								// Complementa com asteriscos na direita para manter o tamanho padrao da variavel
			&MvRet := mvpar										 			// Devolve Resultado
		EndIf
	EndIf
	
	If !Empty(cAlias)
		dbSelectArea(cAlias) 								 // Retorna Alias	
	EndIf
Return( IF( lTipoRet , .T. , MvParDef ) )
	
/*


Ŀ
Funo	  Gpconfok  Autor  Mauro				     Data 		  
Ĵ
Descrio  Funcao para Confirmacao da Pergunte.						  
Ĵ
Sintaxe	  GpConfok()												  
Ĵ
 Uso		  Genrico 												  
ٱ

*/
Function GpConfOk( cMensagem , cTitulo )

cMensagem	:= IF( cMensagem == NIL .OR. ValType( cMensagem ) != "C" , STR0019 , cMensagem )//"Confirma configurao dos parmetros?"
cTitulo		:= IF( cTitulo	 == NIL .OR. ValType( cTitulo )   != "C" , STR0020 , cTitulo   )//"Ateno"

Return( MsgYesNo( OemToAnsi( cMensagem ) , OemToAnsi( cTitulo ) ) ) //"Ateno"

/*


Ŀ
Funo    fSeleArq() Autor  Emerson Rosa de Souza  Data  09/08/01 
Ĵ
Descrio  Monta uma ListBox com os arquivos abertos				  
Ĵ
 Uso                                                                  
ٱ

*/
Function fSeleArq( cNomeAlias , lBranco , aLbxA , lShowDialog )

Local aAreaSX2	:= SX2->( GetArea() )
Local cAlias  	:= Alias()
Local cPesq   	:= IF( !Empty( cNomeAlias ) , Padr( cNomeAlias , 20 ) , Space( 20 ) )
Local lOK     	:= .F.
Local nPosLbxA	:= 0.00
Local oPesq		:= NIL
Local oDlg		:= NIL
Local oLbxA		:= NIL

Local bSet15 	:= {||}
Local bSet24 	:= {||}

//Ŀ
// Declarao de arrays para dimensionar tela		         
//
Local aAdvSize		:= {}
Local aInfoAdvSize	:= {}
Local aObjSize		:= {}
Local aObjCoords	:= {}

Default lBranco		:= .F.
Default aLbxA		:= {}
Default lShowDialog	:= .T.

aLbxA := {} 

/*
Ŀ
 Monta as Dimensoes dos Objetos         					   
*/
IF ( lShowDialog )
	aAdvSize	 := MsAdvSize(,.t.,370)
	aInfoAdvSize := { aAdvSize[1] , aAdvSize[2] , aAdvSize[3] , aAdvSize[4] , 5 , 5 }					 
	aAdd( aObjCoords , { 000 , 000 , .T. , .T. , .T.} )
	aAdd( aObjCoords , { 000 , 040 , .T. , .F. } )
	aObjSize	 := MsObjSize( aInfoAdvSize , aObjCoords )
EndIf

IF ( lBranco )
	aAdd( aLbxA , { Space( 3 ) , Space( 30 ) } )
EndIf

SX2->( dbGoTop() )
While SX2->( !Eof() )
	If ( FWX2CHAVE() $ cFOPENED )
		SX2->( aAdd( aLbxA , { FWX2CHAVE() , AllTrim( X2Nome() ) } ) )
	EndIf
	SX2->( dbSkip() )
EndDo
RestArea( aAreaSX2 )

IF ( lShowDialog )

	DEFINE MSDIALOG oDlg FROM aAdvSize[7],0 TO aAdvSize[6],aAdvSize[5] TITLE OemToAnsi(STR0021) PIXEL		// "Selecione o Arquivo"
		
		@ aObjSize[1,1], aObjSize[1,2] LISTBOX oLbxA FIELDS HEADER "" , OemToAnsi(STR0022) SIZE aObjSize[1,3], aObjSize[1,4];	// "Bases de Dados"
		      OF oDlg PIXEL ON DBLCLICK ( lOk := .T., nPosLbxA:=oLbxA:nAt,oDlg:End() )
		
		oLbxA:SetArray(aLbxA)
		oLbxA:bLine := { || {aLbxA[oLbxA:nAt,1],aLbxA[oLbxA:nAt,2]}}
		
		@ aObjSize[2,1], aObjSize[2,2] SAY OemToAnsi(STR0023) SIZE 25, 7 OF oDlg PIXEL //"Pesquisar:"
		@ aObjSize[2,1], aObjSize[2,2]+50 MSGET oPesq VAR cPesq  SIZE 80,10 OF oDlg PIXEL PICTURE "@!" VALID VldPosArq( oLbxA , aLbxA , cPesq )
		
		bSet15	:= {|| lOk := .T., nPosLbxA:=oLbxA:nAt,oDlg:End() }
		bSet24	:= {|| lOk := .F., oDlg:End() }
				
	ACTIVATE MSDIALOG oDlg CENTERED ON INIT (EnchoiceBar(oDlg, bSet15, bSet24),;
									 VldPosArq( oLbxA , aLbxA , cNomeAlias ))
	        
	If ( lOk )
		cNomeAlias := aLbxA[nPosLbxA,1]
	EndIf

EndIf

dbSelectArea( cAlias )

Return( lOk )

/*
Ŀ
Funo	   VldPosArq	  Autor Marinaldo de Jesus   Data 16/01/2003
Ĵ
Descrio Efetua a Pesquisa do Alias                                  
Ĵ
Sintaxe   <Vide Parametros Formais> 									
Ĵ
Parametros<Vide Parametros Formais> 									
Ĵ
Uso	   fSeleArq()    												
*/
Static Function VldPosArq( oListBox , aListBox , cAliasPesq  )

Local bAscan	:= { || NIL }
Local lValidArq := .T.
Local nPosArq	:= 0.00

Default aListBox	:= {}	
Default cAliasPesq	:= ""

IF ( ValType( oListBox ) == "O" )
	IF !Empty( cAliasPesq )
		bAscan := { |z| AllTrim( cAliasPesq ) $ z[1] .OR. AllTrim( cAliasPesq ) $ z[2] }
		IF ( lValidArq := ( nPosArq := aScan( aListBox , bAscan ) ) > 0.00 )
			oListBox:nAt := nPosArq
		Else
			MsgStop( OemtoAnsi( STR0024 ) ) //"Arquivo nao encontrado"
		EndIf
		oListBox:Refresh()
	EndIf	
EndIf
	
Return( lValidArq )


/*/


Ŀ
Funo	 ExistCpoRH| Autor  IgorFranzoi	 		 Data  21/01/09   
Ĵ
Descrio Validar a existencia da chave									
Ĵ
Sintaxe	 																
Ĵ
Parametros																 
Ĵ
 Uso		 Generico														
ٱ

/*/
Function ExistCpoRH( cAlias, cValor, nOrdem, cFil )

Local cAliasAtu	:= Alias()
Local lRet 		:= .T.

Default nOrdem	:= 01
Default cFil	:= xFilial(cAlias)

dbselectArea(cAlias)
dbSetOrder(nOrdem)

If dbSeek(cFil+cValor)
	lRet := .T.
Else
	lRet := .F.
EndIf
If !Empty(cAliasAtu)
	dbSelectArea(cAliasAtu)
EndIf

Return lRet   


/*


ͻ
Programa   fAcumAux Autor   Equipe RH Inovacao  Data   07/06/11   
͹
Descricao  Monta markBrowse (f_Opcoes) com dados de uma Tab. Auxiliar 
           e retornar as opcoes selecionadas no campo que chamou esta 
           funcao, via <F3> especifico de Tabela Auxiliar.            
͹
Uso        Microsiga Protheus 11                                      
ͼ


*/
Function fAcumAux(cTabPesq)

Local nX       
Local aTab001	:= {}
Local aTabDesc	:= {}
Local cMvPar	:= ""
Local cMvParAux	:= ""
Local cTitulo	:= STR0025//"Acumuladores Auxiliares"
Local lRet		:= .T.
Local l1Elem	:= .T.	
Local nTamChv	:= 0

Private uMvRet	:= Alltrim( ReadVar() )

Default cTabPesq := "S030"

//-fRetTab( aTab_Fol, cCodTab, npoSind, npoExpre, dDataRef, cSindica, lTabFull)
fRetTab(@aTab001,cTabPesq,,,dDataBase,,.T.)

For nX:=1 To Len(aTab001)
	cMvParAux += aTab001[nX,05]+"-" 
	aAdd( aTabDesc, aTab001[nX,05] +"-"+ aTab001[nX,06] )
Next nX                            

nTamChv := Len(aTab001[01,05])+1
l1Elem  := Iif( l1Elem == NIL .and. ValType( l1Elem ) != "L" , .T. , .F. )

CursorWait()
	
//					Retorno,  Titulo,	opcoes, Strin Ret, lin, col, Tipo Sel, tam.chave, n.ele.ret, Botao 
	If ( f_Opcoes ( @cMvPar, cTitulo, aTabDesc, cMvParAux,  12,  49,   l1Elem,   nTamChv,       999, .T. ) )
		&(uMvRet) := cMvPar 
		lRet:= .T.
	Else
		lRet:= .F.
	EndIf
	
CursorArrow()

Return( lRet )

/*


Ŀ
Funo     ValidPerg     Autor  Kleber Dias Gomes  Data  04.08.98 
Ĵ
Descrio  Verifica as perguntas, Incluindo-as ou Alterando-as        
Ĵ
Sintaxe    ValidPerg(aRegs, cPerg, lAltera, aCpoComp)                 
Ĵ
Adilson S. Inclusao do parametro aCpoComp                             
06/08/2009 aCpoComp -> Array unidimensional para definir os campos do 
  ----                 SX1 que serao testados na alteracao das        
  ----                 perguntas.                                     
Ĵ
 Uso       GeraKit                                                    
Ĵ

*/
Function ValidPerg(aRegs,cPerg,lAltera,aCpoComp)
//-- Transferimos o Conteudo do Array para variaveis
//-- Alguns Elementos (Cnt02..Cnt05,...) estao mantindos para compatibilizacao
//-- Embora nao sejam utilizados 
Local cGrupo	:=cPerg
Local cOrdem	,cPergunt	,cPerSpa	,cPerEng	, cVar		,cTipo		
Local nTamanho	,nDecimal	,nPresel	,cGSC		, cValid	,cF3
Local cGrpSxg	,cVar01	    ,cDef01		,cDefSpa1	, cDefEng1	,cCnt01	
Local cVar02	,cDef02		,cDefSpa2	,cDefEng2	, cCnt02	,cVar03	
Local cDef03	,cDefSpa3	,cDefEng3	,cCnt03		, cVar04	, cDef04
Local cDefSpa4	,cDefEng4	,cCnt04		,cVar05		, cDef05	, cDefSpa5
Local cDefEng5	,cCnt05		,cPyme		,aHelpPor	,aHelpEng	,aHelpSpa
Local cHelp		
Local nX, nY, cCpoComp, nPosComp
Local nTamX1GRUPO	:= Len(SX1->X1_GRUPO)

Local nSX1Order:=nX:=0
Local lCriarNovo:=lIncluiAltera:=.F.
                      
Local nLenaRegs

DEFAULT aCpoComp := {}
                          
nSX1Order := SX1->(IndexOrd())
SX1->(dbSetOrder(1))
cPerg := Left(cPerg+Spac(nTamX1GRUPO), nTamX1GRUPO)
cGrupo:=cPerg
//-- Corre Todas as Perguntas
For nX:=1 to Len(aRegs)      
    //-- Obtem o tamanho do array da pergunta lida para posterior comparacao
    nLenaRegs:=Len(aRegs[nX])
	//-- Carrega os Elementos do Array para Variaveis afim de facilitar a leitura
	//-- do fonte
	cOrdem	:= aRegs[nX,02]
	cPergunt:= aRegs[nX,03];cPerSpa		:= aRegs[nX,04]
	cPerEng	:= aRegs[nX,05];cVar		:= aRegs[nX,06]; cTipo		:= aRegs[nX,07]
	nTamanho:= aRegs[nX,08];nDecimal	:= aRegs[nX,09]; nPresel	:= aRegs[nX,10]
	cGSC	:= aRegs[nX,11];cValid		:= aRegs[nX,12]
	cVar01	:= aRegs[nX,13]
	
	cCnt01	:= If(17 > nLenaRegs,"",aRegs[nX,17])		
	
	If cGSC == "C"			// Mult Escolha
		cDef01	:= If(14 > nLenaRegs,"",aRegs[nX,14])
	    cDefSpa1:= If(15 > nLenaRegs,"",aRegs[nX,15])
	    cDefEng1:= If(16 > nLenaRegs,"",aRegs[nX,16])
		
		cVar02	:= If(18 > nLenaRegs,"",aRegs[nX,18])
		cDef02	:= If(19 > nLenaRegs,"",aRegs[nX,19])
		cDefSpa2:= If(20 > nLenaRegs,"",aRegs[nX,20])
		cDefEng2:= If(21 > nLenaRegs,"",aRegs[nX,21])
		cCnt02	:= If(22 > nLenaRegs,"",aRegs[nX,22])
		
		cVar03	:= If(23 > nLenaRegs,"",aRegs[nX,23])
		cDef03	:= If(24 > nLenaRegs,"",aRegs[nX,24])
		cDefSpa3:= If(25 > nLenaRegs,"",aRegs[nX,25])
		cDefEng3:= If(26 > nLenaRegs,"",aRegs[nX,26])
		cCnt03	:= If(27 > nLenaRegs,"",aRegs[nX,27])
		
		cVar04	:= If(28 > nLenaRegs,"",aRegs[nX,28])
		cDef04	:= If(29 > nLenaRegs,"",aRegs[nX,29])
		cDefSpa4:= If(30 > nLenaRegs,"",aRegs[nX,30])
		cDefEng4:= If(31 > nLenaRegs,"",aRegs[nX,31])
		cCnt04	:= If(32 > nLenaRegs,"",aRegs[nX,32])
		
		cVar05	:= If(33 > nLenaRegs,"",aRegs[nX,33])
		cDef05	:= If(34 > nLenaRegs,"",aRegs[nX,34])
		cDefSpa5:= If(35 > nLenaRegs,"",aRegs[nX,35])
		cDefEng5:= If(36 > nLenaRegs,"",aRegs[nX,36])
		cCnt05	:= If(37 > nLenaRegs,"",aRegs[nX,37])
    
    EndIf
    
    //-- Trata Campos Especiais que podem nao ser fornecidos
    cF3		:= If(38 > nLenaRegs,"",aRegs[nX,38])	
	cGrpSxg	:= If(39 > nLenaRegs,"",aRegs[nX,39])
	cPyme	:= If(40 > nLenaRegs,"",aRegs[nX,40])
	aHelpPor:= If(41 > nLenaRegs,{},aRegs[nX,41])
	aHelpEng:= If(42 > nLenaRegs,{},aRegs[nX,42]) 
	aHelpSpa:= If(43 > nLenaRegs,{},aRegs[nX,43])
	cHelp   := If(44 > nLenaRegs,"",aRegs[nX,44])
	
	lIncluiAltera:=.F.
    lCriarNovo:=.F.
    
    //-- Procura pelo Grupo de Perguntas e Item 
    If SX1->(dbSeek(cPerg+aRegs[nX,2]))
    
       //-- Se Houver Divergencia nos Textos das Perguntas em qualquer Idioma
       //-- Forca a OPERACAO: regravacao das informacoes
       lIncluiAltera := (  (SX1->X1_PERGUNT # aRegs[nX,3])    .OR. ;
		                   (!Empty(aRegs[nX,4])  .AND. SX1->X1_PERSPA  # aRegs[nX,4])    .OR. ;
		                   (!Empty(aRegs[nX,5])  .AND. SX1->X1_PERENG  # aRegs[nX,5]) ;
		                 )
	   If !lIncluiAltera
	      If ValType( aCpoComp ) == "A" .And. Len( aCpoComp ) > 0
	         For nY := 1 To Len( aCpoComp )
	             If ( nPosComp := SX1->(FieldPos( aCpoComp[nY] )) ) > 0 .And. nPosComp <= nLenaRegs
	                cCpoComp := If(">" $ aCpoComp[nY], aCpoComp[nY], "SX1->"+aCpoComp[nY] )
	                If ( lIncluiAltera := &( cCpoComp ) <> aRegs[nX,nPosComp] )
	                   Exit
	                EndIf
	             EndIf
             Next nY
          EndIf
       EndIf
      
       //-- OPERACAO: ALTERAR registro
       lCriarNovo:=.F. //-- Nao Cria Novo Registro
    
    Else   
       //-- Se for uma nova pergunta forca a OPERACAO: inclusao das informacoes        
       lIncluiAltera:=.T.
       //-- OPERACAO: INCLUIR novo registro
       lCriarNovo:=.T.
    EndIf                  
Next nX

SX1->(dbSetOrder(nSX1Order))

Return

/*


ͻ
Programa  fDelSX1   Autor  R.H.                 Data   05/01/00   
͹
Desc.     Deleta um item ou todo o grupo de perguntas do SX1          
͹
Sintaxe   FDelSX1(cGrupo,cPergunt,cItemBus,cItemDel)                  
͹
ParametroscGrupo    - Grupo da pergunta que sera deletado             
          cPergunta - Pergunta que sera comparada para definir delecao
          cItemBus  - Item de Busca para definir delecao              
          cItemDel  - Item que sera deletado se comparacao verdadeira 
          lElimina  - .T. Elimina obrigatoriamente a pergunta indepen-
                      dentemente de divergencia no conteudo no idioma 
                      portugues. Padrao .F. .                         
͹
Uso        Generico                                                   
ͼ

*/
Function FDelSX1(cGrupo,cPergunta,cItemBus,cItemDel,lElimina)

Local lDeletar,cAlias,nOrdem

lDeletar := .F.
cAlias   := Alias()
cItemDel := If(cItemDel == Nil, "", cItemDel)
lElimina := If(lElimina == Nil, .F., lElimina)

dbSelectArea("SX1")
nOrdem := IndexOrd()

dbSetOrder(1)
If dbSeek(cGrupo+cItemBus)
	If ( ( SX1->X1_PERGUNT == cPergunta ) .or. ( lElimina ) )
		lDeletar := .T.
	EndIf
EndIf

If ( lDeletar )
	If dbSeek(cGrupo+cItemDel)
		While !Eof() .And. X1_GRUPO == cGrupo
			If Empty(cItemDel) .Or. (!Empty(cItemDel) .And. X1_ORDEM == cItemDel)
				RecLock("SX1",.F.,.F.)
				dbDelete()
				MsUnlock()
			EndIf	
			dbSkip()
		EndDo
	EndIf
EndIf	
dbSetOrder(nOrdem)
dbSelectArea(cAlias)
Return lDeletar

/*


ͻ
Programa  |ValidaFil	Autor  Marcio Barretos      Data   02/03/09   
͹
Desc.     Verifica um parametro do tipo range para filiais e retorna  
          somente as filiais que o usurio tem acesso.                
͹
Uso                                                                   
ͼ


*/
Function ValidaFil(cPar) 

Local cFValidFil := ""
Local nPrime := 0 
Local nUltim := 0 
Local cFilAcess := ""  
Local nX := 0 

cFValidFil := fValidFil()
If !(Empty(cFValidFil))

	cFilAcess := ""

	If ( "-" $cPar)
		nPrime := VAL(SUBSTR(cPar,AT("-",cPar)-3 ,FWGETTAMFILIAL))
		nUltim := VAL(SUBSTR(cPar,AT("-",cPar)+1 ,FWGETTAMFILIAL)) 
		cFilAcess := ";"+Iif( STRZERO(nPrime,FWGETTAMFILIAL)$cFValidFil,STRZERO(nPrime,FWGETTAMFILIAL),"")
		For nX := (nPrime + 1) to (nUltim - 1)
			cFilAcess += ";"+Iif(STRZERO(nX,FWGETTAMFILIAL)$cFValidFil,STRZERO(nX,FWGETTAMFILIAL),"")
		Next nX
		cFilAcess += ";"+Iif(STRZERO(nUltim,FWGETTAMFILIAL)$cFValidFil,STRZERO(nUltim,FWGETTAMFILIAL),"")
	EndIf

	If ( ";" $cPar )
		nPrime := VAL(SUBSTR(cPar,AT(";",cPar)+1,FWGETTAMFILIAL))
		nUltim := LEN(TRIM(cPar))
		For nX:= nPrime To nUltim step 3
			cFilAcess += ";"+Iif(SUBSTR(cPar,nX,FWGETTAMFILIAL)$cFValidFil,SUBSTR(cPar,nX,FWGETTAMFILIAL),"")
		Next nX
	EndIf
	cPar := cFilAcess	

EndIf

Return (cPar)

/*


ͻ
Funcao    GPELocks  Autor  Microsiga            Data   11/09/09   
͹
Desc.      Bloqueia registros em uma GetDados, nao permitindo que usu-
          arios facam alteracoes simultaneas num mesmo registro.      
                                                                      
          Parametros elem1=> opcao do menu                            
                     elem2=> alias a ser bloqueado                    
                     elem3=> Registros a serem bloqueados             
                     elem5=> numero da opcao de visualizacao          
͹
Uso        AP                                                         
ͼ


*/
Function GpeLocks( nOpc , cAlias , aRecnos, nOpcVisual,lMayIUseCode,cChave )

Local lLocks	:= .T.
Local aRecAux	:= {}

DEFAULT aRecnos	:= {}
DEFAULT lMayIUseCode := .F.

Begin Sequence

	/*/
	Ŀ
	Se nao For Visualizacao             	 					   
	/*/
	If ( nOpc == nOpcVisual ) 
		Break
	EndIf

	aEval( aRecnos , { |x| If( !Empty( x ) , aAdd( aRecAux , x ) , NIL ) } )

	If !( lLocks := WhileNoLock( cAlias , aRecAux , { cChave } , 1 , 1 , lMayIUseCode , NIL ) )
		Break
	EndIf

End Sequence

Return( lLocks )

/*


ͻ
Programa  GpRCJVld Autor  Leandro Drumond      Data   27/08/14   
͹
Desc.     Valida o processo informado.							      
͹
Uso        Generico                                                  
ͼ


*/
Function GpRCJVld()
Local aArea	:= GetArea()
Local cVar	:= &(ReadVar())
Local lRet	:= .F.

DbSelectArea("RCJ")
DbSetOrder(1)
DbGoTop()
While RCJ->(!Eof())
	If RCJ->RCJ_CODIGO == cVar
		lRet := .T.
		Exit
	EndIf
	RCJ->(DbSkip())
EndDo

If !lRet
	ExistCpo("RCJ",cVar)
EndIf

RestArea(aArea)

Return lRet


/*


ͻ
Programa  GpSRYVld Autor  Leandro Drumond      Data   27/08/14   
͹
Desc.     Valida o roteiro informado.							      
͹
Uso        Generico                                                  
ͼ


*/
Function GpSRYVld()
Local aArea	:= GetArea()
Local cVar	:= &(ReadVar())
Local lRet	:= .F.

DbSelectArea("SRY")
DbSetOrder(1)
DbGoTop()
While SRY->(!Eof())
	If SRY->RY_CALCULO == cVar
		lRet := .T.
		Exit
	EndIf
	SRY->(DbSkip())
EndDo

If !lRet
	ExistCpo("SRY",cVar)
EndIf

RestArea(aArea)

Return lRet

/*


ͻ
Programa  fOpcTab   Autor  Erika Kanamori       Data   08/21/08   
͹
Desc.     Funcao para montar tela de opcoes para tabelas adicionadas  
          atraves de "definicao de tabelas".(RCB,RCC)                 
͹
Uso        Campos WHEN para apresentar consulta de tabelas RCB.       
ͼ


*/

Function fOpcTab( cCampo,  ; // variavel de memoria que, ao ser acessada, vai acionar a funcao
				  cTabela, ; // codigo da tabela em RCB a ser consultada
				  nColA,   ; // n da coluna em RCB (q a funcao retornar)
				  nColB,   ; // n da coluna em RCB(descricao, opcional)
				  nColC,   ; // n da coluna em RCB(descricao, opcional)
				  nColD,   ; // n da coluna em RCB(descricao, opcional) 
				  lFiltra, ; // se deseja filtrar somente uma opcao para cada conteudo de nColA. 
				  lSemCar  ;  // se deseja retirar o caracter asterisco do retorno.
				 ) 

Local cTitulo	:= ""
Local cString	:= ""                 
Local MvParDef	:= ""
Local MvRetor	:= ""
Local aCposTab	:= {}    
Local aCol		:= {}
Local nFor		:= 0   
Local nAux      := 0
Local MvPar            
Local lExiste   := .F. 
Private aSit	:= {}                                                        
Default lSemCar := .F.    
                                                                                            
cAlias := Alias() 					// Salva Alias Anterior   
lFiltra:= If(lFiltra == Nil, .F. , lFiltra )
          
If Alltrim(ReadVar() )== cCampo                        
	MvPar:=&(Alltrim(ReadVar()))	// Carrega Nome da Variavel do Get em Questao
	mvRet:=Alltrim(ReadVar())		// Iguala Nome da Variavel ao Nome variavel de Retorno
	         
	//carrega propriedade dos campos de cTabela                           
	dbSelectArea("RCB")         
	("RCB")->(dbGoTop())
	dbSetOrder(RetOrdem("RCB", "RCB_FILIAL+RCB_CODIGO"))
	If dbSeek(cFilial+cTabela)
		CursorWait()          
		lExiste:= .T.
		While !Eof() .AND. (RCB->RCB_FILIAL+RCB->RCB_CODIGO == cFilial+cTabela) 
			cTitulo:= RCB->RCB_DESC
			Aadd(aCposTab, {RCB->RCB_CAMPOS, RCB->RCB_DESCPO, RCB->RCB_TIPO, RCB->RCB_TAMAN})
			dbSkip()
		End                                   
		
	   	aCol:={{nColA,0},{nColB,0},{nColC,0},{nColD,0}} 
	 	   
	    //calcula a posicao inicial em RCC->RCC_CONTEU de cada campo
		For nFor:= 1 to len(aCol)
			If aCol[nFor][1] <> nil  
				nAux:= 1
				While nAux < aCol[nFor][1]
					aCol[nFor][2]+= aCposTab[nAux][4]
					nAux++
				End
				aCol[nFor][2]++
			EndIf
		End
		
		
		//carrega as descricoes a serem mostradas na consulta
		dbSelectArea("RCC") 
		("RCC")->(dbGoTop())
		dbSetOrder(RetOrdem("RCC", "RCC_FILIAL+RCC_CODIGO+RCC_FIL")) 
		If dbSeek(xFilial("RCC")+cTabela)
		  	While RCC->(!Eof())
		  	    //Averigua se Definicao de Tabela exclusiva da Filial ou compartilhadas (com o camo RCC_FIL vazio) 
		  	    //Para sua apresentacao no When do campo
		  		IF (RCC->(RCC_FILIAL+RCC_CODIGO+RCC_FIL) == xFilial("RCC")+cTabela+FwCodFil())  .or. ( RCC->RCC_FILIAL+RCC_CODIGO == xFilial("RCC")+cTabela .AND. EMPTY(RCC->(RCC_FIL)) )//) )//      )))
				  	If Eval({||Iif(lFiltra .AND. Substr(RCC->RCC_CONTEU, aCol[1][2], aCposTab[aCol[1][1]][4]) $ MvParDef, .F., .T.)})	
				  		MvParDef+= Substr(RCC->RCC_CONTEU, aCol[1][2], aCposTab[aCol[1][1]][4])  
				  		cString:= ""
				  		For nAux:= 2 to len(aCol)
				  			If aCol[nAux][1] <> nil
				  				cString+= Substr(RCC->RCC_CONTEU, aCol[nAux][2], aCposTab[aCol[nAux][1]][4])   
				  			EndIf
				  		End
						aAdd(aSit, cString)
					EndIf
				EndIf
				dbSkip()
			End  
		EndIf	
					
	 	CursorArrow()
	EndIf
	
	IF f_Opcoes(@MvPar,cTitulo,aSit,MvParDef,,,.F.,If(lExiste,aCposTab[1][4],0),1)
		CursorWait()
		For nFor := 1 To Len( mVpar ) Step 2
			IF ( SubStr( mVpar , nFor , 2 ) != "**" )
				mvRetor += SubStr( mVpar , nFor , 2 )
			EndIf
		Next nFor
		If lSemCar == .T. 
			Mvretor := strtran( Mvretor , "*" , "" )
		EndIf	
		&MvRet := Alltrim(Mvretor)
		CursorArrow()	
	EndIf	
                                                   
EndIf		

dbSelectArea(cAlias) // Retorna Alias

Return( MvParDef )    

/*


Ŀ
Funo    MontaF3SRV() Autor  Valdeci Lira 		 Data  14/12/07 
Ĵ
Descrio  Monta as Opcoes de verbas Disponiveis					  
           aArray-> Carrega um array com as verbas por processo       
           lForce-> Forca a remontagem do aArray                      
Ĵ
 Uso       F3                                                         
ٱ

*/
Function MontaF3SRV(lForce, cRoteiro, cProcesso, aIndexSrv, lOnlyInc)
Local 	cFilAux	    := If(MV_MODFOL == "2" , xFilial("SRM"), xFilial('SRV'))
Local 	cFilSRV	    := xFilial('SRV')
Local 	cQuery      := ""
Local 	lExecQry	:= .F. 
Local 	cFuncOrig	:= FunName()

DEFAULT lForce		:= .F.
DEFAULT lOnlyInc	:= .F.	// Carregar somente as verbas que estao com Lee Incidencias = '1'
      
If cFuncOrig == "GPEA520"
   	lExecQry := (Len(aIndexSrv) == 0) .OR. (cabecalhoAlterado()) .OR. lForce
Else
   	lExecQry := (Len(aIndexSrv) == 0) .OR. lForce
EndIf
   				
If lExecQry
	//Ŀ
	// Seleciona apenas verbas de provento.                       
	//		
	cQuery := " SELECT RV_COD, RV_DESC, RV_TIPO"
	cQuery += " FROM " + RetSqlName("SRV") + " SRV " 
	If MV_MODFOL == "2"
		cQuery += " INNER JOIN " + RetSqlName("SRM") + " SRM ON "
		cQuery += " ( SRV.RV_FILIAL = '" + cFilSRV + "' AND "
		cQuery += " SRV.RV_COD = SRM.RM_VERBA )"
		cQuery += " WHERE RM_FILIAL  = '" + cFilAux    + "' AND "
		cQuery += 		 "RM_PROCES  = '" + cProcesso  + "' AND "
		cQuery += 		 "RM_CALCULO = '" + cRoteiro   + "' AND " 
		cQuery += 		 "RM_LEEINC = '1' AND " 
		cQuery +=        "SRM.D_E_L_E_T_ <> '*' ORDER BY RV_COD"
	Else
		cQuery += " WHERE RV_FILIAL = '" + cFilAux + "' AND "
		cQuery += 		 "RV_LEEINC = '1' AND "
		cQuery +=        "SRV.D_E_L_E_T_ <> '*' ORDER BY RV_COD"
	EndIf

	dbUseArea(.T., "TOPCONN", TCGenQry(,,cQuery), 'QSRV', .F., .T.)		
	
	aIndexSrv:= {}
	While !QSRV->(EOF())
		aAdd(aIndexSrv, {QSRV->RV_COD, Upper(QSRV->RV_DESC), QSRV->RV_TIPO })			
		QSRV->(dbSkip())
	EndDo
        
	QSRV->(dbclosearea())
EndIf

Return ( .T. )

/*

Ŀ
Funcao   RangeSX1  Autor Marcos Kato                Data  28/11/08 
Ĵ
Descricao Tratamento do Range do Sx1 para ser utilizado na Query       
Ĵ
 Uso      Microsiga						                               
ٱ
*/
Function RangeSx1(cCampo,cParSX1)
Local nCaract:=0
Local cConteudo:=""

If At("-",cParSX1)>0//Intervalo
	cConteudo:=" "+cCampo+" BETWEEN ' "
 	For nCaract:=1 To Len(cParSX1)       
		If Substr(cParSX1,nCaract,1)=="-"
			cConteudo+="' AND '"
		Else
			cConteudo+=Substr(cParSX1,nCaract,1)
    	EndIf
    Next	           
    cConteudo+="' "
ElseIf  At(";",cParSX1)>0//Contido
	cConteudo:=" "+cCampo+" IN ('"
 	For nCaract:=1 To Len(Alltrim(cParSX1))       
		If Substr(cParSX1,nCaract,1)==";"
			cConteudo+="','"
		Else
			cConteudo+=Substr(cParSX1,nCaract,1)
    	EndIf
    Next	           
    If Substr(cConteudo,Len(cConteudo)-1,2)==",'"
    	cConteudo:=Substr(cConteudo,1,Len(cConteudo)-2)+") "
    Else
	    cConteudo+="') "
	EndIf    
Else               
	cConteudo:=" "+cCampo+" = '"+cParSx1+"' "
EndIf	
Return cConteudo

/*/{Protheus.doc} fTpPlan
Selecionar o tipo de plano
@author Allyson Mesashi
@since 26/08/2021
@version P12.1.27
/*/
Function fTpPlan(l1Elem,lTipoRet)

	Local cTitulo		:= ""
	Local MvPar
	Local MvParDef		:= ""
	Local nTam			:= 0
	
	Private aTp			:= {}
	
	Default lTipoRet 	:= .T.

	l1Elem := If (l1Elem = Nil , .F. , .T.)
	
	IF lTipoRet
		MvPar := Rtrim(&(Alltrim(ReadVar())))
		mvRet := Alltrim(ReadVar())
		nTam  := Len(&mvRet)
	EndIf
	
	aTp := {;
				"1 - " + STR0026,;	//"Faixa Salarial"
				"2 - " + STR0027,;	//"Faixa Etaria"
				"3 - " + STR0028,;	//"Valor Fixo"
				"4 - " + STR0029,;	//"% Sobre Salario"
				"5 - " + STR0030,;	//"Salarial/Etaria"
				"6 - " + STR0031;	//"Salarial/Tempo"
			}  
	MvParDef:= "123456"
	cTitulo := STR0032 //"Tipo"
	
	IF lTipoRet
		IF f_Opcoes(@MvPar, cTitulo, aTp, MvParDef, 12, 49, l1Elem)
			&MvRet := mvpar
			If nTam > Len(aTp)
				&MvRet += Replicate("*",nTam-Len(aTp))
			EndIf 
		EndIf	
	EndIf

Return( IF( lTipoRet , .T. , MvParDef ) )

/*


Ŀ
Funo    fTpContrat   Autor Marco N. Nakazawa     Data 19/11/2021
Ĵ
Descrio  Codigo do tipos de contrato			 					  
Ĵ
 Uso       Generico                                                   
ٱ

*/
Function fTpContrat()
Local aTpContrat	:= {}
Local cTitulo		:= STR0033 // Selecione as Jornadas com Inicio na: 
Local MvParDef		:= "123"
Local MvPar			:= &(Alltrim(ReadVar()))
Local lRet			:= .T.
Local nLenTpCont	:= 0

MvRet := Alltrim(ReadVar())

aAdd(aTpContrat , "1 - " + STR0034)
aAdd(aTpContrat , "2 - " + STR0035)
aAdd(aTpContrat , "3 - " + STR0036)

nLenTpCont := Len(aTpContrat)

If MvPar != NIL
	f_Opcoes(@MvPar,cTitulo,aTpContrat,MvParDef,,,.F.,1,3)
EndIf	

&(MvRet) := MvPar
If Empty(&(MvRet))
   lRet:=.F.
EndIf

Return(lRet)
