#INCLUDE "PROTHEUS.CH"
#INCLUDE "SCOPECNT.CH"
#INCLUDE "GPEM1120.CH"
#INCLUDE "FWMVCDEF.CH"
#INCLUDE "FWLIBVERSION.CH"

Static __aRotErr		:= {}
Static aProcRet 		:= {}
Static __lMemCalc
Static lVerMetrics

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ GPEM120  ³ Autor   ³ Ze Maria                           ³ Data ³ 06/04/95 ³±±
±±³          ³          ³         ³ Leandro Drumond                    ³ Data ³ 09/10/13 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Fechamento Mensal                                                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³         ATUALIZACOES SOFRIDAS DESDE A CONSTRU€AO INICIAL.                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Programador ³ Data     ³   BOPS/FNC   ³  Motivo da Alteracao                          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Leandro Dr. ³09/10/2013³M12RH01       ³Unificao da Folha. Historico no TFS da P11.8   ³±±
±±³            ³          ³RQ.: 195901   ³Protheus Versão 12.                            ³±±
±±³Raquel Hager³01/04/2013³TPCJHL		 ³Criacao da funcao fChkStatus que altera  o     ³±±
±±³            ³          ³              ³status do periodo quando todos estiverem fech. ³±±
±±³Christiane V³09/12/2014³ TRALOR	     ³Alteração para o fechamento de VT, VA, VR      ³±±
±±³Allyson M   ³06/07/2015³TSOG89		 ³Ajuste no fechamento de ferias p/ caso em que  ³±±
±±³            ³          ³              ³funcionario antecipou mais dias de ferias do   ³±±
±±³            ³          ³              ³tinha direito   								 ³±±
±±³gsantacruz  ³17/08/2015³req-5930      ³En la funcion GRAVASR8 se elicmino el filtro de³±±
±±³            ³          ³              ³cTpRoteir = '3' para Mexico.                   ³±±
±±³Flavio Corr ³24/08/2015³TTDZBA		 ³Passar a filial da RCH p/ funcao fcarrperiodo  ³±±
±±³Allyson M   ³19/10/2015³TTJB52		 ³Ajuste no fechamento de adiantamento p/ manter ³±±
±±³            ³          ³              ³a data de calculo do adiantamento   			 ³±±
±±³GSantacruz  ³09/11/2015³PCREQ-5930    ³Merge 12.1.8                                   ³±±
±±³Allyson M   ³15/12/2015³TUAQAC		 ³Ajuste no fechamento de ferias p/ atualizar o  ³±±
±±³            ³          ³              ³SRK corretamente   							 ³±±
±±³Renan Borges³21/12/2015³TTZPC3		 ³Ajuste para quando for realizado o fechamento o³±±
±±³            ³          ³              ³sistema baixe os dias do mes de afastamento cor³±±
±±³            ³          ³              ³retamente para meses afastados de 31 dias e MV_³±±
±±³            ³          ³              ³DIASPER igual 2.                               ³±±
±±³Cícero Alves³23/12/2015³TUBRAK        ³Correção nas chamadas da função fGetCodFol     ³±±
±±³            ³          ³              ³      									     ³±±
±±³Allyson M   ³23/12/2015³TUCDWH		 ³Ajuste no fechamento dos roteiros para nao     ³±±
±±³            ³          ³              ³atualizar a SRF de funcionario demitido		 ³±±
±±³Allyson M   ³07/01/2016³TUCYMY		 ³Ajuste na atualizacao da SRK quando verba for  ³±±
±±³            ³          ³              ³referente a emprestimo consignado				 ³±±
±±³Allyson M   ³12/01/2016³TUFCRX		 ³Ajuste p/ sempre gravar as verbas de ID 0106 e ³±±
±±³            ³          ³              ³0107 (IR mes anterior) no roteiro ADI 		 ³±±
±±³            ³          ³TUFEU0		 ³Ajuste no fechamento do adiantamento p/ ver se ³±±
±±³            ³          ³              ³nao ha calculo na SRC e jogar as verbas de ID  ³±±
±±³            ³          ³              ³0106 e 0107 (IR mes anterior) no roteiro FOL   ³±±
±±³Allyson M   ³05/02/2016³TUJCHW		 ³Ajuste no fechamento da folha p/ gravar a data ³±±
±±³            ³          ³              ³de pagamento nas verbas de ID 0106 e 0107      ³±±
±±³            ³          ³              ³Ajuste no fechamento do adiantamento p/ gerar a³±±
±±³            ³          ³              ³verba de Id 0009 como 0012					 ³±±
±±³Raquel Hager³19/02/2016³TUKE03		 ³Ajuste no fechamento da folha p/ baixa de      ³±±
±±³            ³          ³              ³afastamentos que ocorreram com MV_DIASPER = 2  ³±±
±±³            ³          ³              ³e nDiasC igual a 30.							 ³±±
±±³Raquel Hager³03/02/2016³TUPOEE		 ³Ajuste no fechamento da folha p/ baixa de      ³±±
±±³            ³          ³              ³afastamentos que ocorreram com MV_DIASPER = 2  ³±±
±±³            ³          ³              ³e nDiasC igual a 30 em mes com 31 dias.	     ³±±
±³Flavio Correa³08/03/2016³TUPHFR		 ³Ajuste no fechamento mensal para gerar periodo ³±±
±±³            ³          ³              ³ de recesso corretamente para estagiarios      ³±±
±±³Raquel Hager³11/03/2016³TUQU95		 ³Ajuste no fechamento da folha p/ baixa de      ³±±
±±³            ³          ³              ³afastamentos que ocorreram com MV_DIASPER = 2  ³±±
±±³            ³          ³              ³e nDiasC igual a 30 em mes com 31 dias.	     ³±±
±±³Raquel Hager³11/03/2016³TUQU95		 ³Ajuste no fechamento da folha p/ baixa de      ³±±
±±³            ³          ³              ³afastamentos que ocorreram com MV_DIASPER = 2  ³±±
±±³            ³          ³              ³e nDiasC igual a 30 em mes com 28/29 dias.	 ³±±
±±³Renan Borges³20/05/2016³TUZGS1  	     ³Ajuste para que em Fevereiro seja proporcionali³±±
±±³            ³          ³   		  	 ³zado pelos dias do periodo quando funcionário  ³±±
±±³            ³          ³   		  	 ³for admitido no mes, demitido possuir afastamen³±±
±±³            ³          ³   		  	 ³to, ou férias.                                 ³±±
±±³Gustavo M.  ³20/05/2016³TV5634  	     ³Ajuste para filtrar as filiais que o usuario   ³±±
±±³            ³          ³   		  	 ³tem acesso.						 			 ³±±
±±³Renan Borges³02/06/2016³TUPYXC  	     ³Ajuste para geração de programação de férias   ³±±
±±³            ³          ³   		  	 ³corretamente quando há funcionários diferentes ³±±
±±³            ³          ³   		  	 ³com mesma matricula em filiais diferentes.     ³±±
±±³Allyson M   ³06/06/2016³TVBNGB  	     ³Ajuste p/ nao somar horas quando for ID 0164   ³±±
±±³            ³          ³   		  	 ³p/ nao gerar referencia incorreta pois pode    ³±±
±±³            ³          ³   		  	 ³haver férias + médias.     					 ³±±
±±³            ³          ³   		  	 ³Ajuste na validacao de acesso da filial		 ³±±
±±³Allyson M   ³08/06/2016³TVGSLA  	     ³Ajuste no fechamento do adiantamento: o ID do  ³±±
±±³            ³          ³   		  	 ³arredondamento estava errado    				 ³±±
±±³Renan Borges³15/06/2016³TVIGQD  	     ³Criação do Mnemonico P_PGSALFEV para que seja  ³±±
±±³            ³          ³   		  	 ³possível definir se em fevereiro será utilizado³±±
±±³            ³          ³   		  	 ³os dias do mês (Art. 64 a CLT) ou 30 dias.     ³±±
±±³Raquel Hager³15/06/2016³TVBQGV  	     ³Remoção da geração da parcela 99.              ³±±
±±³Gabriel A.  ³11/07/2016³TTTYG4        ³Ajuste na geração da SR3 para Argentina.       ³±±
±±³Gabriel A.  ³19/07/2016³TVQHLG        ³Ajuste no fechamento quando há verba de faltas.³±±
±±³Allyson M   ³19/07/2016³TVLTT3  	     ³Ajuste no fechamento de fevereiro p/ considerar³±±
±±³            ³          ³   		  	 ³os dias corretos de pagamento    				 ³±±
±±³Gabriel A.  ³22/07/2016³TVPMC1        ³Ajuste na geração da SRF para autônomos.       ³±±
±±³Renan Borges³26/07/2016³TVLO93  	     ³Ajuste para gerar quantidade de parcelas corre-³±±
±±³            ³          ³   		  	 ³tamente no fechamento quando houver uma parcela³±±
±±³            ³          ³   		  	 ³maior que 1 e não possuir data de referência.  ³±±
±±³Cícero Alves³02/08/2016³TVQVU8  	     ³Adicionado tratamento para atualizara a SRF    ³±±
±±³            ³          ³   		  	 ³quando é calculado apenas abono pecuniário	 ³±±
±±³Allyson M   ³10/08/2016³TVOISA  	     ³Ajuste no fechamento de adiantamento p/ não    ³±±
±±³            ³          ³   		  	 ³gravar os lançamentos se houver demissão		 ³±±
±±³Allyson M   ³12/08/2016³TVQKA9  	     ³Ajuste no fechamento p/ quando for o Id 0232   ³±±
±±³            ³          ³   		  	 ³p/ descontar o valor corretamente e assim gerar³±±
±±³            ³          ³   		  	 ³a verba do Id 0164 corretamente				 ³±±
±±³Allyson M   ³17/08/2016³TVUY47		 ³Ajuste em fGravaSalInc() pois estava alterando ³±±
±±³            ³          ³              ³o registro de salário base da SR3, ao invés de ³±±
±±³            ³          ³              ³apenas incluir um registro com o valor da verba³±±
±±³            ³          ³              ³que incorpora ao salario						 ³±±
±±³Renan Borges³22/08/2016³TVUX16 	     ³Ajuste para ao realizar o fechamento possuindo ³±±
±±³            ³          ³   		  	 ³2 calculos de férias dentro do mesmo mes siste-³±±
±±³            ³          ³   		  	 ³ma totalize os dias pagos corretamente.        ³±±
±±³Allyson M   ³19/10/2016³TVWVIJ		 ³Ajuste p/ validar preenchimento da verba de mês³±±
±±³            ³          ³              ³seguinte antes de efetuar o fechamento da folha³±±
±±³            ³          ³              ³Ajustes p/ execução do robô de testes          ³±±
±±³Cícero Alves³25/10/2016³TVQKTX		 ³Incluído o ponto de entrada GP120INC			 ³±±
±±³M.Camargo   ³01/11/2016³TSSERMI01-57  ³Merge Localización  CHILE | COLOMBIA           ³±±
±±³Allyson M   ³04/11/2016³TWHDQ5		 ³Ajuste na comparação do NUMID da RCK com SRK   ³±±
±±³Renan Borges³29/11/2016³MRH-2305		 ³Ajuste para quando for realizado o fechamento o³±±
±±³            ³          ³              ³sistema grave as verbas Base de IRRF e IR no ro³±±
±±³            ³          ³              ³teiro correto, quando funcionário for autonomo.³±±
±±³Gabriel A.  ³19/12/2016³MRH-3011      ³Ajuste na forma de monstar a quantidade de     ³±±
±±³            ³          ³              ³threads no fechamento, visando melhora de      ³±±
±±³            ³          ³              ³performance.                                   ³±±
±±³Renan Borges³26/12/2016³MRH-3252  	 ³Ajuste para preencher campo status da ausência ³±±
±±³            ³          ³              ³corretamente quando o saldo a pagar for zerado ³±±
±±³            ³          ³              ³no fechamento.                                 ³±±
±±³Raquel Hager³28/12/2016³MRH-3812  	 ³Realizado ajuste para atualizar Control de Dias³±±
±±³            ³          ³              ³de Direito corretamente para Estagiários.      ³±±
±±³Allyson M.  ³16/01/2017³MRH-1185    	 ³Ajuste na atualização dos lançamentos futuros  ³±±
±±³            ³          ³           	 ³quando verba é rateada  						 ³±±
±±³Marcos Cout.³07/03/2017³MRH-7420    	 ³Realizar ajustes de compatibilização dos progra³±±
±±³            ³          ³           	 ³mas para Mercado Internacional 				 ³±±
±±³Eduardo K.  ³07/04/2017³MPRIMESP-9463 ³Ajuste para carregar corretamente as verbas de ³±±
±±³            ³          ³           	 ³Mês seguinte para a proxima competencia.   	 ³±±
±±|Claudinei S.|28/04/2017|MRH-482       | Implementado o cálculo para funcionários      |±±
±±|            |          |              | com regime parcial. fAtAvProj()               |±±
±±³Jônatas A.  ³08/05/2017³DRHPAG-1574   ³Ajuste para validar a existência do período ADI³±±
±±³            ³          ³           	 ³no mês seguinte ativo, nos casos de não haver  ³±±
±±³            ³          ³           	 ³adiantamento no mês atual e o roteiro do mês   ³±±
±±³            ³          ³           	 ³seguinte não existir ou não estiver ativo      ³±±
±±³            ³          ³           	 ³(somente para regime CAIXA).                   ³±±
±±³Paulo O.    ³06/07/2017³DRHPAG-3817   ³Ajuste para tratar error log no fechamento de  ³±±
±±³Inzonha     ³          ³           	 ³Autonomos semanalista com pgto no mes seguinte ³±±
±±³            ³          ³           	 ³(somente para regime CAIXA).                   ³±±
±±³Rafael Reis ³24/08/2017³DRHPAG-4860   ³Mudança de escopo da variável bTemAcesso       ³±±
±±³            ³          ³           	 ³                                               ³±±
±±³Raul Ortiz  ³30/08/2017³DMICNS-49     ³Modificación para cerrar tablas temporales     ³±±
±±³            ³          ³              ³Chile                                          ³±±
±±³Isabel N.   ³13/09/2017³DRHPAG-5697   ³Ajustes dias pagos de férias no fechamento MEX.³±±
±±³M. Silveira/³06/07/2017³DRHPAG-6118   ³Ajuste no tratamento de erro das threads e para³±±
±±³Leandro Dr. ³          ³           	 ³para atribuir a filial correta em cada JOB.    ³±±
±±³Isabel N.   ³02/10/2017³DRHPAG-6238   ³Ajustes MI:fechamento por roteiro atualizar RG7³±±
±±³   Marco A  ³13/10/2017³TSSERMI01-175 ³Se realiza correccion para el calculo correcto ³±±
±±³            ³          ³              ³de Dias Derecho y Ausencia en el cierre de     ³±±
±±³            ³          ³              ³periodos. (MEX/ARG)                            ³±±
±±³   Marco A  ³01/11/2018³DMINA-4608    ³Se realiza correccion para el calculo correcto ³±±
±±³LuisEnríquez³          ³              ³de Dias Derecho y Ausencia en el cierre de     ³±±
±±³            ³          ³              ³periodos. (MEX)                                ³±±
±±³M.Camargo   ³21/03/2019³DMINA-6231    ³Ajustes Actualización dias derecho y ausentis- ³±±
±±³            ³          ³              ³mos para Loc. Colombia                         ³±±
±±³M.Camargo   ³17/09/2019³DMINA-7480    ³Modificación cuando MV_PERMOD=2 en función     ³±±
±±³            ³          ³              ³Gp120FecFer  y Gp120FecFol.                    ³±±
±±Alf. Medrano ³07/01/2020³DMINA-7983    ³fun GravaSR8 si no hay reg en SR8 entonces pro-³±±
±±³            ³          ³              ³cesa valor días a pagar y recorre SRF. En Fun  ³±±
±±³            ³          ³              ³VerNewPerSRF() se valida modificacion de campo ³±±
±±³            ³          ³              ³RF_DFERVAT. En fun UpdStateSRF() toma dias pro-³±±
±±³            ³          ³              ³porcionales de tabla SRC campo RC_HORAS. En Fun³±±
±±³            ³          ³              ³Gp120FecFol() asigna val de SRA->RA_PROCES como³±±
±±³            ³          ³              ³param a fun FGetPerAtual().Cambios Solo para   ³±±
±±³            ³          ³              ³aplicación de finiquito MEX                    ³±±
±±³Laura Medina³19/02/2020³DMICNS-7513   ³Ajustes para la Localización de la nómina de 	 ³±±
±±³            ³          ³              ³Paraguay.                   					 ³±±
±±Alf. Medrano ³19/02/2020³DMINA-8402    ³Fun GETSR8 en array aAllSR8 se agregan ausencia³±±
±±³            ³          ³              ³de vac. de fechas anteriores a fecha inicial de³±±
±±³            ³          ³              ³periodo nomina calculado. En Fun VerNewPerSRF  ³±±
±±³            ³          ³              ³se asigna dia aniversario cuando RF_DFERVAT = 0³±±
±±³            ³          ³              ³En fun GRAVASR8 array aValSR8 debe tener valor ³±±
±±³            ³          ³              ³en NumId para actualizar SR8 y de SRF  MEX     ³±±
±±Alf. Medrano ³26/02/2020³DMINA-8505    ³En fun fSRAThread se filtra SRG(Rescisión) con ³±±
±±³            ³          ³              ³RG_APLPER,RG_APLNPG,RG_APLROT para obtener Empl³±±
±±³            ³          ³              ³-eados con RA_DEMISSA/RG_DTGERAR anterior a    ³±±
±±³            ³          ³              ³fecha periodo en proceso de cierre.            ³±±
±±Luis Enriquez³21/05/2020³DMINA-8971    ³Se ajusta función MkNewPerSRF para indicar en  ³±±
±±³            ³          ³              ³campo RF_DATABAS fecha de Reconocimiento. (MEX)³±±
±±³LuisEnríquez³26/01/2021³DMINA-10765   ³Localización de vacaciones pagadas para mercado³±±
±±³            ³          ³              ³internacional.                                 ³±±
±±³Cristian E. ³19/03/2021³DMICNS-10676  ³Localización cierre de vacaciones para país    ³±±
±±³Franco      ³          ³              ³paraguay.                                      ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function GPEM120(cProcAut, cRotAut, lRobo)

Local aArea			:= GetArea()
Local aColsMark		:= {}
Local aAdvSize		:= {}
Local aInfoAdvSize	:= {}
Local aObjSize		:= {}
Local aObjCoords	:= {}
Local aOfusca		:= If(FindFunction('ChkOfusca'), ChkOfusca(), {.T., .F.}) //[2]Ofuscamento
Local aFldRel		:= If(aOfusca[2], FwProtectedDataUtil():UsrNoAccessFieldsInList({"RA_NOME"}), {})
Local cNotInt		:= fGetRotNotInt() //Obtem roteiros que nao necessitam ser integrados
Local lBlind     	:= IsBlind()
Local lMarcar     	:= .F.
Local cProcesTit	:= ""
Local cPeriodTit	:= ""
Local cNumPagTit	:= ""
Local cProcedTit	:= ""
Local cDtPgtTit		:= ""

Local oPanelUp
Local oTela
Local oPanelDown
Local oGroup
LOcal oFont

Private cValidFil   := fValidFil('RCH')
Private bTemAcesso  := { |x| ( Empty((cAliasMark)->TAB_FIL) .Or. AllTrim((cAliasMark)->TAB_FIL) $ cValidFil ) }
Private bVldDtPago  := { |x| ( Empty(dDtPagoFil) .Or. TAB_DTPAG == dDtPagoFil ) }
Private aLogErros	:= Array(17,0) 				// Log de Erros dos periodos que houveram inconsistencias
Private cAliasMark 	:= GetNextAlias()
Private cCadastro	:= OemToAnsi(STR0001) // "Fechamento de Periodos"
Private cProcesso 	:= Space( GetSx3Cache( "RCH_PROCES", "X3_TAMANHO" ) ) 	// Codigo do Processo
Private cPeriodo 	:= Space( GetSx3Cache( "RCH_PER", "X3_TAMANHO" ) ) 	// Codigo do Periodo
Private cRoteiro	:= Space( GetSx3Cache( "RCH_ROTEIR", "X3_TAMANHO" ) ) 	// Roteiro de Calculo
Private cNumPag		:= Space( GetSx3Cache( "RCH_NUMPAG", "X3_TAMANHO" ) ) 	// Nro. de Pagamento
Private dDtPagoFil  := CtoD("  /  /  ")
Private cTpRoteir	:= "" 	// Tipo de Roteiro
Private cPaisFol1	:= "VEN/PER"
Private cAtualSit   := GetMvRH( "MV_SITRES", .F., "2" )
Private cSRCDesc	:= ""
Private cSRDDesc	:= ""
Private oMark
Private oDlg
Private oTmpTable
Private lModPadrao  := !(MV_MODFOL == '2') 	 		// 1-Modelo padrao ; 2- Novo Modelo Mexico
Private lPerMod2	:= !lModPadrao .And. GetMvRH( "MV_PERMOD2" , .F., .F. )	 //Usa cadastro de periodos simplificado para folha modelo 2 (valor padrao = .F.)
Private lFilComp	:= Empty(xFilial("RCH"))
Private lOfusca		:= Len(aFldRel) > 0
Private lGestPubl 	:= IIF(ExistFunc("fUsaGFP"),If(cModulo=="GPE", .F. , fUsaGFP()),.F.)
Private lVldFecFol  := GetMvRH( "MV_FECFOL" , .F., .F. )
Private lGeraAcumulador	:= .F.
Private lSegPlan	:= FwIsInCallStack("WFLAUNCHER") .or. FwIsInCallStack("FWBOSCHDEXECUTE")

aProcRet 		   := {}

Default cRotAut    := ""
Default __lMemCalc := cPaisLoc == "BRA" .And. FindFunction("fMemCalc") .And. fMemCalc() // Memória de Cálculo
Default lRobo 	   := .F.

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Tratamento para pesquisa da função de validação do SuperFiltro ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
If FindFunction("fValidFun")

	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Funcao verifica se existe alguma restrição de acesso para o³
	³usuário que impeça a execução da rotina.                   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	If !(fValidFun({"SRA","SRV","SRC","SRD",;
					"SRK","SR8","SRF","RG1",;
					"RCI","SR3","SRM","RG9",;
					"RG7","RG8","RGB","SRH","RCM"}))
		RestArea(aArea)
		Return( Nil )
	EndIf

EndIf

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Verifica se existe algum Roteiro definido como Ordinario     ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
If Empty(fGetRotOrdinar())
	Help(" ",1,"M120ROTORD")	// Nenhum Roteiro foi definido como Ordinario! - Solucao: No cadastro de Roteiro de Calculo informe um roteiro como Ordinario.
	Return(Nil)
EndIf

If !PgsExclusive()
   Help(" ",1,"PGSEXC")
EndIf

If !fCriaTmp()
	Help( ,, 'HELP',, STR0004, 1, 0) //"Nenhum dos roteiros aptos a integração possuem período de cálculo ativo."
EndIf

aColsMark:= fMntColsMark()

DbSelectArea(cAliasMark)
If lSegPlan
	Gpm120IniMark(lRobo)
ElseIf lBlind 
	If ! Empty(cRotAut)
		SET FILTER TO TAB_PROC  == cProcAut .AND. TAB_ROT == cRotAut
	Else
		SET FILTER TO TAB_PROC  == cProcAut
	EndIf
	Gpm120IniMark(lRobo)
Else

	SET FILTER TO TAB_PROC  == space(TAMSX3("RCH_PROCES")[1])

	DBSelectArea("SX3")
	SX3->(DBSetOrder(2))//X3_CAMPO

	If SX3->(DBSeek("RCH_PROCES"))
		cProcesTit := X3Titulo()
	EndIf
	If SX3->(DBSeek("RCH_PER"))
		cPeriodTit := X3Titulo()
	EndIf
	If SX3->(DBSeek("RCH_NUMPAG"))
		cNumPagTit := X3Titulo()
	EndIf
	If SX3->(DBSeek("RCH_ROTEIR"))
		cProcedTit := X3Titulo()
	EndIf
	If SX3->(DBSeek("RCH_DTPAGO"))
		cDtPgtTit := X3Titulo()
	EndIf	

	aAdvSize	:= MsAdvSize()
	aInfoAdvSize	:= { aAdvSize[1] , aAdvSize[2] , aAdvSize[3] , aAdvSize[4] , 10 , 5 }
	aAdd( aObjCoords , { 000 , 000 , .T. , .T. } )
	aObjSize	:= MsObjSize( aInfoAdvSize , aObjCoords )

	Define MsDialog oDlg FROM aAdvSize[7],0 TO aAdvSize[6],aAdvSize[5] Title STR0001 Pixel  ////"Fechamento de Periodos"

	// Cria o conteiner onde serão colocados os paineis
	oTela     := FWFormContainer():New( oDlg )
	cIdCab	  := oTela:CreateHorizontalBox( 13 )
	cIdGrid   := oTela:CreateHorizontalBox( 80 )

	oTela:Activate( oDlg, .F. )

	//Cria os paineis onde serao colocados os browses
	oPanelUp  	:= oTela:GeTPanel( cIdCab )
	oPanelDown  := oTela:GeTPanel( cIdGrid )

		@ 3 , 3	GROUP oGroup TO (aObjSize[1,1]*0.5)+22, aObjSize[1,4] LABEL OemToAnsi(STR0076) OF oPanelUp PIXEL	//"Selecione os filtros para fechamento"
		oGroup:oFont:=oFont

		@ aObjSize[1,1]*0.5, aObjSize[1,2]+1 		SAY   OemToAnsi(cProcesTit) SIZE 038,007 OF oPanelUp PIXEL
		@ (aObjSize[1,1]*0.5)+6, aObjSize[1,2]+1 	MSGET cProcesso PICTURE "@!" SIZE 010,007	OF oPanelUp F3 "RCJ" HASBUTTON PIXEL WHEN .T. VALID ( Vazio() .OR. ExistCpo("RCJ") ) .and. Gp120VldGrid()

		@ aObjSize[1,1]*0.5	, aObjSize[1,2]+60 	SAY   OemToAnsi(cPeriodTit) SIZE 038,007 OF oPanelUp PIXEL
		@ (aObjSize[1,1]*0.5)+6, aObjSize[1,2]+60	MSGET cPeriodo PICTURE "@!" SIZE 010,007	OF oPanelUp PIXEL WHEN .T. VALID Gp120VldGrid()

		@ aObjSize[1,1]*0.5	, aObjSize[1,2]+120		SAY   OemToAnsi(cNumPagTit) SIZE 038,007 OF oPanelUp PIXEL
		@ (aObjSize[1,1]*0.5)+6, aObjSize[1,2]+120	MSGET cNumPag PICTURE "@!" SIZE 010,007	OF oPanelUp PIXEL WHEN .T. VALID Gp120VldGrid()

		@ aObjSize[1,1]*0.5	, aObjSize[1,2]+180		SAY   OemToAnsi(cProcedTit) SIZE 038,007 OF oPanelUp PIXEL
		@ (aObjSize[1,1]*0.5)+6, aObjSize[1,2]+180	MSGET cRoteiro PICTURE "@!" SIZE 010,007	OF oPanelUp PIXEL WHEN .T. VALID Gp120VldGrid()

		@ aObjSize[1,1]*0.5	, aObjSize[1,2]+240		SAY   OemToAnsi(cDtPgtTit) SIZE 038,007 OF oPanelUp PIXEL
		@ (aObjSize[1,1]*0.5)+6, aObjSize[1,2]+240	MSGET dDtPagoFil SIZE 040,007	OF oPanelUp PIXEL WHEN .T. HASBUTTON VALID Gp120VldGrid()

	oMark := FWMarkBrowse():New()

	oMark:SetAlias((cAliasMark))
	oMark:SetFields(aColsMark)

	//Indica o container onde sera criado o browse
	oMark:SetOwner(oPanelDown)

	oMark:bAllMark := { || SetMarkAll(oMark:Mark(),lMarcar := !lMarcar ), oMark:Refresh(.T.)  }

	// Define o campo que sera utilizado para a marcação
	oMark:SetFieldMark( 'TAB_OK')

	oMark:SetValid({||(!lModPadrao .Or. !Empty((cAliasMark)->TAB_INTEG) .OR. (cAliasMark)->TAB_ROT $ cNotInt) .And. ( Empty((cAliasMark)->TAB_FIL) .Or. AllTrim((cAliasMark)->TAB_FIL) $ cValidFil )}) //So permite o fechamento de registros integrados
	oMark:SetMenuDef("GPEM120")

	oMark:AddLegend( "lModPadrao .AND. Empty(TAB_INTEG) .AND. !(TAB_ROT $ " + cNotInt + ")", "RED", STR0082 ) //Falta Integrar
	oMark:AddLegend( "!lModPadrao .OR. !Empty(TAB_INTEG) .OR. TAB_ROT $ " + cNotInt , "GREEN" , STR0083 ) //Apto para Fechamento

	oMark:Activate()

	ACTIVATE MSDIALOG oDlg CENTERED

EndIf

PgsShared()

If oTmpTable <> Nil
	oTmpTable:Delete()
	oTmpTable := Nil
EndIf

RestArea( aArea )

Return( NIL )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³Gpm120Processa³ Autor ³Mauricio T. Takakura   ³ Data ³15/12/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Processamento para fechamento mensal                            ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³Gpm120Processa										    		³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³                                                                ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³ Uso      ³GPEM120()	                                                    ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
/*/
Static function Gpm120Processa(aRoteiros,lRobo)

Local aGpem120Log	:= {}			// Log de Erros
Local aTitleLog		:= {}			// Titulo de Log de Erros
Local aNextPer		:= {}			// Array com as informacoes do proximo periodo
Local aNextComp		:= {}			// Array com as informacoes do proximo periodo da competencia seguinte
Local aFields		:= {}			// Campos que montara o cabecalho de Log dos Periodos
Local aTamFields	:= {}			// Array com os tamanhos de cada campo do Log de Periodos
Local aThreads		:= {}
Local aJobAux		:= {}
Local aLogAux		:= {}
Local aLogGrid		:= aClone(aLogErros)

Local cUID			:= "GPEM120" + AllTrim(Str(ThreadID()))
Local cFilAux     	:= cFilAnt
Local cFilRCH						// Filial da tabela RCH
Local cRotAberto    := ""
Local cAliasQry		:= ""
Local cTimeIni		:= Time()		// Informacoes da Regua
Local cDuracaoProcesso
Local cTimeIniRot
Local cStartPath	:= GetSrvProfString("Startpath","")
Local cJobFile		:= ""
Local cJobAux		:= ""
Local cUltDiaMes	:= ""                       // Variavel para obter ultimo dia do mes
Local cMesProc    	:= ""						// Mes do Fechamento
Local cAnoProc    	:= ""						// Ano do Fechamento
Local cProxPer		:= ""
Local cProxNPagto	:= ""
Local cRotAux		:= ""
Local cJoin			:= ""
Local cWhere 		:= ""
Local cWhere2 		:= ""
Local cPcPrSm		:= ""
Local cDemissa 		:= ""

Local dDtaLimite								// Data Limite para periodo aquisitivo no SRF

Local lVldProx
Local lBlind		:= IsBlind()
Local lFechOk		:= .T.
Local lAutMovSRC	:= GetMvRH("MV_AUTOSRC",, .F. ) // Calculo autonomo com movimento
Local lGP120VLD		:= ExistBlock("GP120VLD")

Local nX
Local nY
Local nLoop
Local nLoops
Local nLoopAux
Local nPos
Local nRecno						// ultimo recno
Local nSumRCH						// variavel utilizada no total da regua
Local nRegsAux		:= 0
Local nRegsOk		:= 0
Local nRetry_0		:= 0
Local nRecRCH
Local nRotCnt		:= 0
Local nRetry_1		:= 0

Local aOfusca	    := If(FindFunction('ChkOfusca'), ChkOfusca(), { .T., .F. }) //[2]Ofuscamento
Local aFldRel	    := If(aOfusca[2], FwProtectedDataUtil():UsrNoAccessFieldsInList( {"RA_NOME"} ), {})
Local cGPEGrid		:= GetMvRH("MV_GPEGRID",, " ") //(1=Provisao 2=Calculo Roteiros 3=Fechamento em branco=Todas)
Local lOfusca	    := Len(aFldRel) > 0
Local lGrid 		:= GetMvRH("MV_GRID",, .F.) .and. ( Empty(cGPEGrid) .Or. "3" $ cGPEGrid )
Local lTknUser      := FWLibVersion() >= "20250630" 

Private aFuncProg	:= {}
Private aProcLog	:= {}
Private cTimeIniSRA					// Informacoes da Regua
Private lNextPer	:= .T.			// Proximo Periodo de fechamento esta OK
Private nTotProvLiq := 0			// Total de Proventos do periodo
Private nTotDescLiq := 0			// Total de Descontos do periodo
Private nTotEmp 	:= 0			// Total da Empresa - inclusive as Bases de Calculo
Private nTotBsProv	:= 0 			// Total Base Proventos
Private nTotBsDesc	:= 0 			// Total Base Descontos
Private nTotRegs	:= 0 			// Total de Registros
Private nTotFunc	:= 0			// Total de Funcionarios Acumulados no campo de controle
Private nSumSRA		:= 0			// variavel utilizada no total da regua
Private cTemMov		:= ""
Private dDtFimPer   := CTOD("  /  /  ")	//# Data final do periodo em processamento
Private _dtPagNexP  := CTOD(" / / ") // Fecha Pago _Next Per.
Private	aTabS106	:= {}
Private lGestPubl 	:= IIF(ExistFunc("fUsaGFP"),If(cModulo=="GPE", .F. , fUsaGFP()),.F.)
//FP Criação de variáveis para atender SRF/RIA
If lGestPubl
	Private aRIAFields	:= {} 			// Estrutura do arquivo RIA
	Private cAliasRIA	:= "RIA"
	Private nFalLicen	:= SuperGetMv("MV_VDFALIC",.F.,3)
	Private nMesLicen	:= SuperGetMv("MV_VDMELIC",.F.,1)
	Private cTransPd	:= SuperGetMv("MV_VDTRAPD",.F.,"1")
	Private cLimFalDev	:= SuperGetMv("MV_VDDFADE",.F.,"15")
	Private lOrdinar	:= .T.
	Private lIntegra	:= .F.
EndIf

Static lTemRCHUser
Static __cUserAux 
Static __cNameAux

TCInternal(5,"*OFF")   // Desliga Refresh no Lock do Top

DbSelectArea( "SRA" )
DbSelectArea( "SRC" )

DEFAULT lTemRCHUser := RCH->(ColumnPos( 'RCH_USERFE' )) > 0

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Cabecalho do Log Processado  							 	   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
If Empty( aLogErros[3] )
	aFields := { "RCH_FILIAL", "RCH_PER", "RCH_NUMPAG", "RCH_PROCES", "RCH_ROTEIR", "RCH_MES", "RCH_ANO" }
	aAdd( aLogErros[3], Gp120CabLog( "RCH", aFields, @aTamFields, .T., .T. ) ) // Cabecalho do Log de Erros
	aAdd( aLogErros[3], "" ) // Cabecalho do Log de Erros
EndIf

aAdd( aProcLog , STR0052 + " " + cTimeIni + " " + STR0053 + " " + DtoC( MsDate() ) ) //"Inicio do Processo de Fechamento:"###" de "

PutGlbVars("lOfuscaJob", lOfusca)
/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Parametros para a Regua                                      ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
nSumRCH := Len(aRoteiros)
If lSegPlan
	ProcRegua(nSumRCH)
ElseIf !lBlind 
	BarGauge1Set( nSumRCH )
EndIf

For nRotCnt := 1 to nSumRCH
	cTimeIniRot := Time()
	cRoteiro    := aRoteiros[nRotCnt,1]
	cPeriodo    := aRoteiros[nRotCnt,2]
	cNumPag	    := aRoteiros[nRotCnt,3]
	cTpRoteir   := aRoteiros[nRotCnt,4]
	cFilRCH 	:= aRoteiros[nRotCnt,5]
	cProcesso	:= aRoteiros[nRotCnt,6]
	cWhere 		:= " SRA.RA_PROCES = '" + cProcesso + "' "
	cWhere2		:= "% SRA.RA_PROCES = '" + cProcesso + "' %"
	cPcPrSm		:= "% SRG.RG_DTGERAR >= '"+ cPeriodo + "01' %"
	cDemissa 	:= "% AND SRA.RA_DEMISSA < '" + cPeriodo + "01' %"

	//Se for roteiro de PLR e estiver definido para efetuar calculo de PLR de demitidos, carrega até os funcionários deletados para fechamento
	If !(cRoteiro == fGetCalcRot('F') .And. GetMvRH("MV_PLRDEM",,"N") == "S") .And. cPaisLoc != "MEX"
		cWhere += " AND ( SRA.RA_DEMISSA = '' OR SRA.RA_DEMISSA >= '" + cPeriodo + "01' ) "
	EndIf
	cWhere := "% " + cWhere + " %"
	If cPaisLoc != "BRA" // para rescisión tomará el periodo, procedimeinto y num Pago
		cPcPrSm := "% SRG.RG_APLPER ='" + cPeriodo + "' AND  RG_APLNPG ='" + cNumPag + "' AND RG_APLROT = '" + cRoteiro +"' %"
		cDemissa := "% %"
	EndIf

	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Movimenta Regua de Processamento                             ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	If lSegPlan
		IncProc()
	ElseIf !lBlind
		IncPrcG1Time( STR0012 + " " + cPeriodo + " / " + cNumPag + " / " + cRoteiro , nSumRCH , cTimeIni , .T. , 1 , 1 , .T. )	//"Fechamento do Periodo ->"
	EndIf

	If cPaisLoc == "ARG"
		If cTpRoteir == "4"
			aAdd( aLogErros[1], ( Ap5GetHelp("ROT_APL") ) ) //-- Fechamento deve utilizar o roteiro de Aplicacao de Rescisão
			Loop
		EndIf
	EndIf

	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Percorrer a tabela de Periodos conforme Parametros           ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	DbSelectArea( "RCH" )
	DbSetOrder(1) //RCH_FILIAL+RCH_PROCES+RCH_PER+RCH_NUMPAG+RCH_ROTEIR
	DbSeek(cFilRCH+cProcesso+cPeriodo+cNumPag+cRoteiro)

    /*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Guarda o Recno do RCH para reposicionamento				   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	nRecRCH := RCH->(Recno())

	If cTpRoteir $ "1*9" .and. lModPadrao //Se for folha, verifica se os demais roteiros foram fechados
		If !fVerRotFec(@cRotAberto,cFilRCH)
			aAdd( aLogErros[1], STR0069 + cRotAberto ) //-- "Os roteiros a seguir estão abertos e precisam ser fechados antes do fechamento da folha: "### .
			aAdd( aLogErros[1],"")
			Loop
		EndIf
	EndIf

	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Verifica Status do Periodo/Atualiza o Status do periodo      ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	If !lModPadrao
		If RCH->RCH_STATUS =="1"
			aAdd( aLogErros[1], ( Ap5GetHelp("PER_PREFECHADO") ) )						//-- O período selecionado está Pré-Fechado!
			Loop
		EndIf

		If RCH->RCH_STATUS =="2"
			aAdd( aLogErros[1], ( Ap5GetHelp("PER_EMUSO") ) )							//-- O período selecionado está sendo utilizado para cálculos !
			Loop
		EndIf

		If RCH->RCH_STATUS =="4"
			aAdd( aLogErros[1], ( Ap5GetHelp("PER_EMFECHAM") ) )						//-- O Período selecionado está em processo de fechamento !
			Loop
		EndIf
		
		If  cPaisLoc == "PAR"
			If  !NoExisSRC()
				aAdd( aLogErros[1], STR0118 )	//--No se puede cerrar este periodo porque no est- calculado !
				Loop
			Endif
		Endif
		
		If !fAtuStatus()
			aAdd( aLogErros[1], STR0039 ) 											// "Periodo devera estar selecionado no Cadastro de Periodos e os recibos devem  estar impressos "
			Loop
		EndIf
	EndIf

	cMesProc	:= RCH->RCH_MES
	cAnoProc	:= RCH->RCH_ANO

	nTotProvLiq 	:= 0
	nTotDescLiq 	:= 0
	nTotBsProv		:= 0
	nTotBsDesc		:= 0
	nTotEmp 		:= 0
	nTotRegs		:= 0
	nTotFunc		:= 0
	nRegsAux		:= 0
	nRetry_0		:= 0
	cTemMov			:= ""

	GetSRDValues(@nTotProvLiq, @nTotDescLiq, @nTotBsProv, @nTotBsDesc)
	GetSRDCounts(@nTotFunc, @nTotRegs)

	nTotEmp	:= nTotProvLiq + nTotDescLiq + nTotBsProv + nTotBsDesc

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Obtem data limite para periodo aquisitivo no SRF             ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	cUltDiaMes	:= f_UltDia(CtoD("01/"+cMesProc+"/"+cAnoProc , "DDMMYY" ))
	dDtaLimite	:= CtoD(StrZero(cUltDiaMes,2)+"/"+cMesProc+"/"+cAnoProc , "DDMMYY" )

    /*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Verifica se o Periodo Anterior e o Seguinte sao validos      ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	aNextPer := {}
	aNextComp:= {}
	lNextPer := .T.

	lVldProx := !(cTpRoteir $ "F*5*6*7*N*K") //Nao valida se existe proximo periodo de PLR e 13º, Retificadora e "OUTROS"

	If lGP120VLD
		If !ExecBlock( "GP120VLD", .F., .F., {cFilRCH, cProcesso, cPeriodo, cNumPag, cRoteiro } )
			Loop
		EndIf
	EndIf

	If !Gpem120ValFech( cFilRCH	,cProcesso,cRoteiro,cPeriodo,cNumPag,@aNextPer,@aNextComp,lVldProx)
		Loop
	EndIf

	If cPaisLoc == "COL" .and. Len(aNextPer) > 0
		_dtPagNexP := aNextPer[1,08]
	EndIf
	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Parametros para a 2a. Regua                                  ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	cTimeIniSRA := Time()

	nSumSRA 	:= 0
	cAliasQry	:= GetNextAlias()

	//Busca as filiais da SRA que serao processadas
	If lAutMovSRC .and. cTpRoteir == '9' //Se for fechamento de autonomo e parametro estiver ativo, verifica apenas quem teve movimento.
	   	If !Empty(cFilRCH)
			cJoin := "%"
			cJoin += FWJoinFilial( "SRA", "RCH" )
			cJoin += "%"
			BeginSql alias cAliasQry
				SELECT COUNT(*) CONTADOR
				FROM
				(
					SELECT DISTINCT SRA.RA_FILIAL, SRA.RA_MAT
					FROM 		%table:SRA% SRA INNER JOIN %table:RCH% RCH
								ON %exp:cJoin%
								INNER JOIN %table:SRC% SRC
								ON SRA.RA_FILIAL = SRC.RC_FILIAL AND SRA.RA_MAT = SRC.RC_MAT AND
								SRC.RC_PERIODO = %exp:cPeriodo% AND SRC.RC_ROTEIR = %exp:cRoteiro%
					WHERE RCH.RCH_FILIAL = %exp:cFilRCH% AND
						SRA.RA_PROCES = %exp:cProcesso% AND
						RCH.%NotDel% AND SRA.%NotDel% AND SRC.%NotDel%
				) Matriculas
			EndSql

			If (cAliasQry)->( !Eof() )
				nSumSRA := (cAliasQry)->(CONTADOR)
			EndIf
		Else
			BeginSql alias cAliasQry
				SELECT COUNT(*) CONTADOR
				FROM 		%table:SRA% SRA
				INNER JOIN %table:SRC% SRC
				ON SRA.RA_FILIAL = SRC.RC_FILIAL AND SRA.RA_MAT = SRC.RC_MAT AND
				SRC.RC_PERIODO = %exp:cPeriodo% AND SRC.RC_ROTEIR = %exp:cRoteiro%
				WHERE SRA.RA_PROCES = %exp:cProcesso% AND
				      SRA.%NotDel% AND SRC.%NotDel%
			EndSql

			If (cAliasQry)->( !Eof() )
				nSumSRA := (cAliasQry)->(CONTADOR)
			EndIf
		EndIf
	Else
	   	If !Empty(cFilRCH)
			aOldArea := GetArea()

			cJoin := "%"
			cJoin += FWJoinFilial( "SRA", "RCH" )
			cJoin += "%"
			
			If cPaisLoc != "BRA"
				BeginSql alias cAliasQry
					SELECT COUNT(*) CONTADOR
					FROM
						(
						SELECT DISTINCT SRA.RA_FILIAL, SRA.RA_MAT
							FROM
							%table:SRA% SRA INNER JOIN %table:RCH% RCH
								ON %exp:cJoin%
						WHERE RCH.RCH_FILIAL = %exp:cFilRCH% AND
							%exp:cWhere% AND
							RCH.%NotDel% AND SRA.%NotDel%
						) Matriculas
				EndSql
			Else
				BeginSql alias cAliasQry
					SELECT COUNT(*) CONTADOR
					FROM (
						SELECT DISTINCT SRA.R_E_C_N_O_ NRECNO, SRA.RA_FILIAL FILIAL, SRA.RA_PROCES, SRA.RA_TNOTRAB, SRA.RA_SEQTURN, SRA.RA_REGRA, SRA.RA_MAT
						FROM %table:SRA% SRA INNER JOIN %table:RCH% RCH ON %exp:cJoin%
						WHERE %exp:cWhere% AND
							SRA.%NotDel% AND
							RCH.RCH_FILIAL = %exp:cFilRCH% AND
							RCH.%NotDel%
						UNION
						SELECT DISTINCT SRA.R_E_C_N_O_ NRECNO, SRA.RA_FILIAL FILIAL, SRA.RA_PROCES, SRA.RA_TNOTRAB, SRA.RA_SEQTURN, SRA.RA_REGRA, SRA.RA_MAT
						FROM %table:SRA% SRA INNER JOIN %table:RCH% RCH ON %exp:cJoin%
						INNER JOIN %table:SRG% SRG ON SRG.RG_FILIAL = SRA.RA_FILIAL AND SRG.RG_MAT = SRA.RA_MAT AND %exp:cPcPrSm% AND SRG.%NotDel%
						WHERE %exp:cWhere2% AND
							SRA.%NotDel% AND
							RCH.RCH_FILIAL = %exp:cFilRCH% AND
							RCH.%NotDel%
							%exp:cDemissa% 
					) X
				EndSql
			EndIf

			If (cAliasQry)->( !Eof() )
				nSumSRA := (cAliasQry)->(CONTADOR)
			EndIf

			RestArea(aOldArea)
		Else
			If cPaisLoc != "BRA"
				BeginSql alias cAliasQry
					SELECT COUNT(*) CONTADOR
					FROM 		%table:SRA% SRA
					WHERE SRA.RA_PROCES = %exp:cProcesso% AND
						SRA.%NotDel%
				EndSql

				If (cAliasQry)->( !Eof() )
					nSumSRA := (cAliasQry)->(CONTADOR)
				EndIf
			Else
				BeginSql alias cAliasQry
					SELECT COUNT(*) CONTADOR 
					FROM (
						SELECT DISTINCT SRA.R_E_C_N_O_ NRECNO, SRA.RA_FILIAL FILIAL, SRA.RA_PROCES, SRA.RA_TNOTRAB, SRA.RA_SEQTURN, SRA.RA_REGRA, SRA.RA_MAT
						FROM %table:SRA% SRA
						WHERE %exp:cWhere% AND
							SRA.%NotDel%
						UNION
						SELECT DISTINCT SRA.R_E_C_N_O_ NRECNO, SRA.RA_FILIAL FILIAL, SRA.RA_PROCES, SRA.RA_TNOTRAB, SRA.RA_SEQTURN, SRA.RA_REGRA, SRA.RA_MAT
						FROM %table:SRA% SRA
						INNER JOIN %table:SRG% SRG ON SRG.RG_FILIAL = SRA.RA_FILIAL AND SRG.RG_MAT = SRA.RA_MAT AND %exp:cPcPrSm% AND SRG.%NotDel%
						WHERE %exp:cWhere2% AND
							SRA.%NotDel%
							%exp:cDemissa%
					) X
				EndSql

				If (cAliasQry)->( !Eof() )
					nSumSRA += (cAliasQry)->(CONTADOR)
				EndIf
			EndIf
		EndIf
	EndIf

	(cAliasQry)->(dbCloseArea())
	//Cria segunda regua
	If lSegPlan
		ProcRegua(nSumRCH)
	ElseIf !lBlind 
		BarGauge2Set( nSumSRA )	
	EndIf

	aThreads := fSRAThread(nSumSRA,cFilRCH,lAutMovSRC,lRobo,lGrid)

	nLoops	:= Len(aThreads)

	If nLoops > 1
		VarSetUID(cUID,.T.)
		VarSetAD(cUID,"aRecProg",{})
	EndIf
	
	If nLoops == 0
		lFechOk := .T.
		cTemMov := "N"
	Else
		//Cria um token e adicona na variável global para uso em outras threads 
		PutGlbValue("cToken", If(lTknUser, totvs.framework.users.rpc.getAuthToken(), ""))
		GlbUnLock()
		If nLoops == 1 //Execucao sem multi-thread
			Gpm120Thread(,,, aThreads[1], cProcesso,,, dDtaLimite, aNextPer, aNextComp, nRecRCH, .F., @lFechOk, @cTemMov,,cUID,@aLogGrid)

			If !Empty(aLogGrid)
				For nLoop := 1 to Len(aLogGrid)
					For nX := 1 to Len(aLogGrid[nLoop])
						aAdd(aLogErros[nLoop],aLogGrid[nLoop,nX])
					Next nX
				Next nLoop
			EndIf
		Else
			If !lGrid //Se usa GRID mantém a execução dentro das threads
				nLoops-- //O último grupo de funcionários será executado na thread principal
			EndIf
			//Dispara jobs
			For nLoop := 1 to nLoops
				// Informacoes do semaforo
				cJobFile:= cStartPath + CriaTrab(Nil,.F.)+".job"

				// Adiciona o nome do arquivo de Job no array aJobAux
				aAdd(aJobAux,{StrZero(nLoop,2),cJobFile})

				// Inicializa variavel global de controle de thread
				cJobAux:="GPM120"+cEmpAnt+cFilAnt+StrZero(nLoop,2)
				PutGlbValue(cJobAux,"0")
				GlbUnLock()

				//Incrementa contador de funcionarios processados para mover a regua
				PutGlbValue("nTotReg"+StrZero(nLoop,2),"0")
				GlbUnLock()

				//Variavel para controle de error.log
				PutGlbValue("nTemErro"+StrZero(nLoop,2),"0")
				GlbUnLock()

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Dispara thread    ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				StartJob("Gpm120Thread",GetEnvServer(), .F., cEmpAnt, cFilAnt, __cUserId, aThreads[nLoop], cProcesso, cJobFile, StrZero(nLoop,2), dDtaLimite, aNextPer, aNextComp, nRecRCH,.T.,,,lPerMod2, cUID)

				Sleep(1000) //Para o processamento por um segundo para evitar o bombardeio ao ctree e consequente travamento das threads em ambientes mais lentos.

			Next nLoop

			If !lGrid //Se usa GRID mantém a execução dentro das threads
				//Executa o último grupo na thread principal
				Gpm120Thread(,,, aThreads[nLoops+1], cProcesso,,, dDtaLimite, aNextPer, aNextComp, nRecRCH, .F., @lFechOk, @cTemMov,,cUID)

				nRegsAux := Len(aThreads[nLoops+1]) //Incrementa contador com a quantidade que já foi processada na thread principal
			EndIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Controle de Seguranca para MULTI-THREAD                                   ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			For nLoop := 1 to nLoops

				nPos := aScan(aJobAux,{|x| x[1] == StrZero(nLoop,2)})

				// Informacoes do semaforo
				cJobFile:= aJobAux[nPos,2]

				// Inicializa variavel global de controle de thread
				cJobAux:="GPM120"+cEmpAnt+cFilAnt+StrZero(nLoop,2)

				While .T.

					nRegsOk := 0

					For nLoopAux := 1 to nLoops
						nRegsOk += Val(GetGlbValue("nTotReg"+StrZero(nLoopAux,2)))
					Next nLoopAux

					If !lGrid
						nRegsOk += Len(aThreads[nLoops+1])
					EndIf

					For nRegsAux := nRegsAux to nRegsOk
						/*
						ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						³ Movimenta Regua de Processamento                             ³
						ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
						If lSegPlan
							IncProc()
						ElseIf !lBlind 
							IncPrcG2Time( STR0026 + " " +SRA->RA_MAT + If(lOfusca, "", "-" + SRA->RA_NOME ), nSumSRA , cTimeIniSRA , .T. , 1 , 1 , .T. )	// Processando Funcionario ->
						EndIf
						SRA->(DbSkip())
					Next nRegsAux

					Do Case
						// TRATAMENTO PARA ERRO DE SUBIDA DE THREAD
						Case GetGlbValue(cJobAux) == '0'
							If nRetry_0 > 50
								Conout(Replicate("-",65))				  						//"-----------------------------------------------------"
								Conout("GPEM120: " + STR0060 + " " + StrZero(nLoop,2) )		//"GPEM120: Não foi possivel subir a thread"
								Conout(Replicate("-",65))  										//"-----------------------------------------------------"
								//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
								//³ Atualiza o log de processamento			    ³
								//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
								Final(STR0060) 	 												//"Não foi possivel subir a thread"
							Else
								nRetry_0 ++
							EndIf
						// TRATAMENTO PARA ERRO DE CONEXAO
						Case GetGlbValue(cJobAux) == '1'
							If FCreate(cJobFile) # -1
								If nRetry_1 > 5
									Conout(Replicate("-",65)) 						//"------------------------------------------------"
									Conout("GPEM120: " + STR0061 ) 					//"GPEM120: Erro de conexao na thread"
									Conout(STR0062 + StrZero(nLoop,2) )				//"Thread numero : "
									Conout(STR0063)									//"Numero de tentativas excedidas"
									Conout(Replicate("-",65))  						//"------------------------------------------------"
									//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
									//³ Atualiza o log de processamento			    ³
									//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
									Final("GPEM120: " + STR0061)   					//"GPEM120: Erro de conexao na thread"
								Else
					    			// Inicializa variavel global de controle de Job
									PutGlbValue(cJobAux, "0" )
									GlbUnLock()
									// Reiniciar thread
									Conout(Replicate("-",65))				 				//"------------------------------------------------"
									Conout("GPEM120: " + STR0061 ) 							//"GPEM120: Erro de conexao na thread"
									Conout(STR0064	+ StrZero(nRetry_1,2))					//"Tentativa numero: "
									Conout(STR0065 + StrZero(nLoop,2))						//"Reiniciando a thread : "
									Conout(Replicate("-",65))                 				//"------------------------------------------------"
									//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
									//³ Dispara thread 						        ³
									//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
									StartJob("Gpm120Thread",GetEnvServer(), .F., cEmpAnt, cFilAnt, __cUserId, aThreads[nLoop], cProcesso, cJobFile, StrZero(nLoop,2), dDtaLimite, aNextPer, aNextComp, nRecRCH,.T.,,,lPerMod2)
								EndIf
								nRetry_1 ++
							EndIf
						// TRATAMENTO PARA ERRO DE APLICACAO
						Case GetGlbValue(cJobAux) == '2'
							If FCreate(cJobFile) # -1
								Sleep(1000)
								If FCreate(cJobFile) # -1
									Conout(Replicate("-",65))									//"-------------------------------------------------"
									Conout("GPEM120: " + STR0066  )								//"GPEM120: Erro de aplicacao na thread"
									Conout(STR0062 + StrZero(nLoop,2))							//"Thread numero : "
									Conout(Replicate("-",65))  									//"--------------------------------------------------"
									//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
									//³ Atualiza o log de processamento			    ³
									//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
									Final("GPEM120: " + STR0066) 								//"GPEM120: Erro de aplicacao na thread"
								EndIf
							EndIf
							If GetGlbValue("nTemErro"+StrZero(nLoop,2)) == "1" //Ocorrencia de error.log na thread
								Conout(Replicate("-",65))									//"-------------------------------------------------"
								Conout("GPEM120: " + STR0066  )								//"GPEM120: Erro de aplicacao na thread"
								Conout(STR0062 + StrZero(nLoop,2))							//"Thread numero : "
								Conout(Replicate("-",65))  									//"--------------------------------------------------"
								//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
								//³ Atualiza o log de processamento			    ³
								//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
								Final("GPEM120: " + STR0066) 								//"GPEM120: Erro de aplicacao na thread"
							EndIf
						// THREAD PROCESSADA CORRETAMENTE
						Case GetGlbValue(cJobAux) == '3'
							Exit
						Otherwise
							// ERRO DE EXECUCAO QUE ANULA A VARIAVEL CJOBAUX
							// 2017/09 - Erro na execucao da thread ocorrido na D'Avo - nao identificado motivo mesmo c/ apoio TEC/Framework
							Conout(Replicate("-",65))											//"-------------------------------------------------"
							Conout("GPEM120: " + STR0115)										//"GPEM120: Erro na execucao da thread"
							Conout(STR0116)														//"Variavel cJobAux Nula"
							Conout(Replicate("-",65))											//"-------------------------------------------------"
							Exit
					EndCase
					Sleep(2500)
				End

			Next nLoop

			If !IsBlind() .and. lGrid //Finaliza segunda gauge
				IncPrcG2Time( STR0026 + " " +SRA->RA_MAT + If(lOfusca, "", "-" + SRA->RA_NOME ), nSumSRA , cTimeIniSRA , .T. , nSumSRA - nRegsAux - 1 , nSumSRA - nRegsAux - 1, .T. )	// Processando Funcionario ->
			EndIf

			//Carrega retorno das variaveis globais
			For nLoop := 1 to nLoops
				nTotFunc += Val(GetGlbValue("nTotFunc"+StrZero(nLoop,2)))
				nTotEmp  += Val(GetGlbValue("nTotEmp" +StrZero(nLoop,2)))
				nTotRegs += Val(GetGlbValue("nTotRegs"+StrZero(nLoop,2)))

				nTotProvLiq += Val(GetGlbValue("nTotPLiq"+StrZero(nLoop,2)))
				nTotDescLiq += Val(GetGlbValue("nTotDLiq"+StrZero(nLoop,2)))
				nTotBsProv += Val(GetGlbValue("nTotBsProv"+StrZero(nLoop,2)))
				nTotBsDesc += Val(GetGlbValue("nTotBsDesc"+StrZero(nLoop,2)))

				If cTemMov <> "S"
					cTemMov := GetGlbValue("cTemMov"+StrZero(nLoop,2))
				EndIf

				If lFechOk
					lFechOk := GetGlbValue("lFechOk"+StrZero(nLoop,2)) == "S"
				EndIf

				GetGlbVars("aLogErr"+StrZero(nLoop,2),@aLogAux)
				GlbUnLock()

				//Transfere erros encontrados nas threads para aLogErros
				For nX := 1 to Len(aLogAux)
					If !Empty(aLogAux)
						For nY := 1 to Len(aLogAux[nX])
							aAdd(aLogErros[nX],aLogAux[nX,nY])
						Next nY
					EndIf
				Next nX

				//Limpa variaveis globais
				ClearGlbValue("lFechOk"+StrZero(nLoop,2))
				ClearGlbValue("nTotFunc"+StrZero(nLoop,2))
				ClearGlbValue("nTotEmp"+StrZero(nLoop,2))
				ClearGlbValue("nTotRegs"+StrZero(nLoop,2))
				ClearGlbValue("nTotPLiq"+StrZero(nLoop,2))
				ClearGlbValue("nTotDLiq"+StrZero(nLoop,2))
				ClearGlbValue("nTotBsProv"+StrZero(nLoop,2))
				ClearGlbValue("nTotBsDesc"+StrZero(nLoop,2))
				ClearGlbValue("aLogErr"+StrZero(nLoop,2))
				ClearGlbValue("cTemov"+StrZero(nLoop,2))
			Next nLoop

			ClearGlbValue("ctoken")

			VarGetA(cUID,"aRecProg",@aFuncProg)
			VarClean(cUID)
		EndIf
	EndIf

	RCH->(dbGoTo(nRecRCH))

	If !lModPadrao

		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Grava campos de controle - RG8                                 ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		fGrvControle(	nTotProvLiq,;
						nTotDescLiq,;
						nTotEmp,;
						nTotBsProv,;
						nTotBsDesc,;
						nTotRegs,;
						nTotFunc )

	EndIf

	If cPaisLoc =="ARG"
		fDelRH8Arg( cPeriodo, cRoteiro, cNumPag )
	EndIf

	If lFechOk
		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Gravacao do Historico de Periodos - Auditoria                ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		If lModPadrao .and. cPaisLoc <> 'BRA'
			GpGrvRCI( (nTotProvLiq - nTotDescLiq), nTotFunc )
		EndIf

		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Fechamento do Periodo na tabela RCH                          ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		RCH->(dbGoTo(nRecRCH))
		DbSelectArea( "RCH" )
		RecLock("RCH",.F.)                 // Bloqueio registro RCH
		RCH->RCH_DTFECH	:= dDataBase
		If lTemRCHUser
			DEFAULT __cUserAux := RetCodUsr()
			DEFAULT __cNameAux := UsrRetName(__cUserAux)

			RCH->RCH_USERFE	:= __cUserAux + " - " + __cNameAux
		EndIf
		RCH->RCH_STATUS	:= "5"
		RCH->RCH_PERSEL := "2"				// Periodo Não selecionado
		RCH->( MsUnLock() )

		//Memória de cálculo
		//Apaga Log de Memória de Cálculo antigo - período fechado -2 (exemplo: fechamento 201712, apaga 201710, mantem 201711,201712 e 201701)
		If __lMemCalc
			fDelLog(RCH->RCH_FILIAL,RCH->RCH_PROCES, RCH->RCH_PER, RCH->RCH_NUMPAG, RCH->RCH_ROTEIR)
		EndIF

		// Ativa ou nao status do periodo - nao aplicavel quando usa cadastro modelo 2 simplificado
		If !lPerMod2
			fChkStatus(cProcesso,cRoteiro,cPeriodo,cNumPag,RCH->RCH_DTINI,RCH->RCH_DTFIM)
		EndIf

		If cTpRoteir $ "5*6" //Se for 13o 1a. parcela, ativa o periodo da 2a. parcela e vice-versa
			nRecno	:= RCH->(Recno())
			cRotAux := If(cTpRoteir == "5", fGetCalcRot("6"), fGetCalcRot("5"))
			If fGetLastPer( @cProxPer, @cProxNPagto, cProcesso, cRotAux, .T., .F. )
				RCH->(DbSetOrder(1)) //RCH_FILIAL+RCH_PROCES+RCH_PER+RCH_NUMPAG+RCH_ROTEIR
				If RCH->(DbSeek(cFilRCH+cProcesso+cProxPer+cProxNPagto+cRotAux))
					RecLock(("RCH"),.F.)                 // Bloqueio registro RCH
					RCH->RCH_PERSEL := "1"
					RCH->( MsUnLock() )
					RCH->( dbGoto( nRecno ) )
				EndIf
			EndIf
		Else
			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Marca  o proximo periodo como selecionado                    ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			nRecno	:= RCH->(Recno())
			If ValType(aNextPer) == "A" .and. Len(aNextPer) > 0 .and. aNextPer[1,12]> 0
				RCH->(DbSetOrder(4))
				RCH->(DbSeek( cFilRCH + cProcesso + cRoteiro + cPeriodo + cNumPag, .F. ))
				RCH->(DbSkip())

				If !RCH->RCH_COMPL == "1"
					RCH->( dbGoto( aNextPer[1,12] ) )
				EndIf

				If cTpRoteir != "N" .Or. Empty( RCH->RCH_DTFECH )
                    RecLock(("RCH"),.F.)                 // Bloqueio registro RCH
                    RCH->RCH_PERSEL := "1"
                    RCH->( MsUnLock() )
                EndIf
                
				RCH->( dbGoto( nRecno ) )
			EndIf
		EndIf
	EndIf

	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Gerar o Log do Periodo                                       ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	aAdd( aLogErros[3],	cFilRCH			+ Space( aTamFields[1] ) + ;
						cPeriodo		+ Space( aTamFields[2] ) + ;
						cNumPag			+ Space( aTamFields[3] ) + ;
						cProcesso		+ Space( aTamFields[4] ) + ;
						cRoteiro		+ Space( aTamFields[5] ) + ;
						cMesProc		+ Space( aTamFields[6] ) + ;
						cAnoProc 		+ Space( aTamFields[7] ) + ;
						If(cTemMov=="S",STR0101,STR0102)			+ Space( aTamFields[8] ) + ;
						ElapTime( cTimeIniRot, Time() )				;
		 )

Next nRotCnt

If !IsBlind() .and. Len(aFuncProg) > 0
	GP120ProgReaj(aFuncProg)			
EndIf

//--Calcula tempo gasto no fechamento
cDuracaoProcesso	:= RemainingTime( NIL , 1 , .F. )

aAdd( aProcLog , STR0054 + " " + Time() + " " + STR0053 + " "  + DtoC( MsDate() ) )//"Final do Processo de Fechamento:"###"de"
aAdd( aProcLog , STR0055 + " " + cDuracaoProcesso )	//"Duracao do Processo de Fechamento:"

If Len(aRoteiros) > 1
	aAdd( aProcLog , STR0056 + " " + MediumTime( cDuracaoProcesso , Len(aRoteiros) , .T. ) ) //"Tempo Médio de Fechamento por Roteiro:"
Else
	aAdd( aProcLog , STR0057 + " " + MediumTime( cDuracaoProcesso , nSumSRA , .T. ) ) //"Tempo Médio de Fechamento por Funcionoário:"
EndIf

aAdd(aTitleLog, STR0058)//"Informações do Processo de Fechamento"
aAdd(aGpem120Log, aClone(aProcLog))

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Geracao do Log de Erros - aLogErros                          ³
³    [1] - Erros de Periodos                                   ³
³    [2] - Registros que nao foram transferidos                ³
³    [3] - Periodos Processados e com Erros                    ³
³    [4] - Lanc. com + verbas que o cadastro permite           ³
³    [5] - Campos do SRC nao existentes na tabela SRD          ³
³    [6] - Registros duplicados de Ausentismos (Tabela - SR8)  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
If !Empty( aLogErros[1] )
	aAdd( aTitleLog, STR0023 )	// "Log de Validacao do Periodo"
	aAdd( aGpem120Log, aClone( aLogErros[1] ) )
EndIf
If Len( aLogErros[3] ) > 1
	aAdd( aTitleLog, STR0027 ) // "Periodos Processados no Fechamento"
	aLogErros[3,1] := StrTran( aLogErros[3,1], "+", " ")
	aAdd( aGpem120Log, aClone( aLogErros[3] ) )
EndIf
If !Empty( aLogErros[2] )
	aAdd( aTitleLog, OemToAnsi(STR0037) ) // "Funcionarios com Lancamentos para o Periodo Seguinte que nao foram Transferidos"
	aLogErros[2,1] := StrTran( aLogErros[2,1], "+", " ")
	aAdd( aGpem120Log, aClone( aLogErros[2] ) )
EndIf
If !Empty( aLogErros[4] )
	aAdd( aTitleLog, STR0030 ) // "Funcionarios com Numero de Movimentos maior que permitido no Cadastro de Verbas"
	aAdd( aGpem120Log, aClone( aLogErros[4] ) )
EndIf
If !Empty( aLogErros[5] )
	aAdd( aTitleLog, STR0040 ) // "Campos existentes na tabela SRC "
	aTitleLog[ Len(aTitleLog) ] += "(" + cSRCDesc + ") " //Descricao da tabela SRC
	aTitleLog[ Len(aTitleLog) ] += STR0041 // "que não foram encontrados na tabela SRD "
	aTitleLog[ Len(aTitleLog) ] += "(" + cSRDDesc + ") " //Descricao da tabela SRD
	aAdd( aGpem120Log, aClone( aLogErros[5] ) )
EndIf
If !Empty( aLogErros[6] )
	aAdd( aTitleLog, STR0045 ) 								// "Registros duplicados de Ausentismos (Tabela - SR8)"
	aAdd( aGpem120Log, aClone( aLogErros[6] ) )
EndIf
If !Empty( aLogErros[7] )
	aAdd( aTitleLog, STR0046 ) 								// "Verba nao Autorizada para Ausentismo"
	aAdd( aGpem120Log, aClone( aLogErros[7] ) )
EndIf
If !Empty( aLogErros[8] )
	aAdd( aTitleLog, STR0047 ) 								// "Nao existe registro/verba de Rescisao (Tabela - SRM)"
	aAdd( aGpem120Log, aClone( aLogErros[8] ) )
EndIf
If !Empty( aLogErros[9] )
	aAdd( aTitleLog, STR0071 ) 								// "Falha na gravação do histórico (Tabela - RG2)"
	aAdd( aGpem120Log, aClone( aLogErros[9] ) )
EndIf
If !Empty( aLogErros[10] )
	aAdd( aTitleLog, STR0080 ) 								// "Os seguintes períodos já possuem dados na tabela de acumulados (Tabela - SRD). O período não será fechado."
	aAdd( aGpem120Log, aClone( aLogErros[10] ) )
EndIf
If !Empty( aLogErros[11] )
	aAdd( aTitleLog, "" )
	aAdd( aGpem120Log, aClone( aLogErros[11] ) )
EndIf
If !Empty( aLogErros[12] )
	aAdd( aTitleLog, STR0104 ) // "Não há o cadastro de verba de mês seguinte da(s) verba(s) abaixo: "
	aAdd( aGpem120Log, aClone( aLogErros[12] ) )
EndIf
If !Empty( aLogErros[13] )
	aAdd( aTitleLog, STR0117 ) // "Não há o cadastro da(s) verba(s) do(s) Id(s) abaixo: "
	aAdd( aGpem120Log, aClone( aLogErros[13] ) )
EndIf
If !Empty( aLogErros[14] )
	aAdd( aTitleLog, STR0123 ) // "Não há o cadastro de calendário do(s) turno(s) abaixo: "
	aAdd( aGpem120Log, aClone( aLogErros[14] ) )
EndIf
If !Empty( aLogErros[15] )
	aAdd( aTitleLog, STR0128 ) //"Férias compulsórias programadas para evitar geração de férias em dobro:"
	aAdd( aGpem120Log, aClone( aLogErros[15] ) )
EndIf
If !Empty( aLogErros[16] )
	aAdd( aTitleLog, STR0129 ) //"Programações de aumento salarial processadas durante o fechamento"
	aAdd( aGpem120Log, aClone( aLogErros[16] ) )
EndIf
If !Empty( aLogErros[17] )
	aAdd( aTitleLog, STR0134 ) //"Falha no fechamento com GRID"
	aAdd( aGpem120Log, aClone( aLogErros[17] ) )
EndIf

If ExistBlock("GP120END")
	ExecBlock("GP120END",.F.,.F., aRoteiros)
EndIf

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Mostrar o Log                                                          ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
If lSegPlan
	GPESmartViewUtils():CreateLog(aGpem120Log, aTitleLog , "GPEM120" , NIL , FunName() , STR0025)
ElseIf !lBlind 
	MsAguarde( { || fMakeLog( aGpem120Log, aTitleLog , "GPEM120" , NIL , FunName() , STR0025 ) } ,  STR0025 ) // "Log de Ocorrencias no Fechamento de Periodo"
EndIf
ClearGlbValue("lOfuscaJob")

// Pegar o Array de Log de Erros da EXECROT

DbSelectArea("SRC")
SRC->( DbSetOrder(1) )

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Limpar a variavel static da funcao PosAlias                  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
RstPosAlias( "RCM" )

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Retorna filial original para o cFilAnt                       ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
cFilAnt := cFilAux

Return( Nil )

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³ fChkStatus   ³ Autor ³ Raquel Hager      ³ Data ³ 01/04/14 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descricao ³ Altera ou nao RFQ_STATUS				                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ GPEM120()                                                  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß/*/
Function fChkStatus(cProcesso,cRoteiro,cPeriodo,cNumPag,dDIni,dDFim)
Local aArea			:= GetArea()
Local cConteudo		:= ""
Local cContRFQ		:= ""
Local lExistAber	:= .F.

	cConteudo := xFilial("RCH", RCH->RCH_FILIAL)+cPeriodo+cNumPag+cProcesso+dToS(dDIni)+dToS(dDFim)
	cContRFQ  := xFilial("RCH", RCH->RCH_FILIAL)+cProcesso+cPeriodo+cNumPag+dToS(dDIni)+dToS(dDFim)
	dbSelectArea("RCH")
	RCH->(dbSetOrder(RetOrdem("RCH", "RCH_FILIAL+RCH_PER+RCH_NUMPAG+RCH_PROCES+DTOS(RCH_DTINI)+DTOS(RCH_DTFIM)+RCH_MODULO")))
	If RCH->(dbSeek(cConteudo))
		While RCH->(!Eof() .And. RCH_FILIAL+RCH_PER+RCH_NUMPAG+RCH_PROCES+dToS(RCH_DTINI)+dToS(RCH_DTFIM) == cConteudo)
			If Empty(RCH->RCH_DTFECH)
				lExistAber := .T.
			EndIf
			RCH->(dbSkip())
		End While

		// Se ele encontrar 1 periodo aberto, nao altera status para fechado
		If !lExistAber
			dbSelectArea("RFQ")
			RFQ->(dbSetOrder(1))
			If RFQ->(dbSeek(cContRFQ))
				If RFQ->RFQ_MODULO $ "GPE*GFP"
					RecLock("RFQ",.F.,.T.)
					RFQ->RFQ_STATUS := "2"
					RFQ->( MsUnlock() )
				EndIf
			EndIf
		EndIf
	EndIf

	RestArea(aArea)

Return

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³Gpm120Thread  ³ Autor ³ Leandro Drumond   ³ Data ³14.10.2013³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Job para execucao das multi-threads.                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ GPEM120()                                                  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function Gpm120Thread(xEmp, xFil, xUser, aRegsSRA, xProcAux, cJobFile, cNumJob, dDtaLimite, aPerNext, aCompNext, nRecRCH, lThread, lFechOk, cTemMov, lPMod2, cUID, aLogGrid)

Local aSindPLR	:= {}
Local aRecAux 	:= {}
Local aVlrMetric:= {}
Local aCall 	:= {}
Local aLoad		:= {}
Local bErro		:= Nil
Local cFunExec  := "GetSrvVersion"
Local cUser		:= "__cUser"
Local cId		:= "Id"
Local nX		:= 0
Local nLoop		:= 0
Local nParcPLR	:= 0
Local nCOuntReg := 0
Local nRegGrid  := 0
Local lExecGrid := .F.
Local cGPEGrid	:= ""

DEFAULT lThread         := .T.
DEFAULT lFechOk	        := .T.
DEFAULT cTemMov	        := "N"
DEFAULT cUID	        := "GPEM120" + AllTrim(Str(ThreadID()))
DEFAULT lVerMetrics     := cPaisLoc == "BRA" .And. FwLibVersion() >= "20200727" .And. FindClass( "FWCustomMetrics" ) .And. FindFunction( cFunExec ) .And. &cFunExec.() >= "19.3.0.6"

Private cTnoAux	:= "!!!!!"
Private cFilAux	:= "!!"
Private cFilAux2:= "!!!!!!"

If lThread
	bErro := ErrorBlock( { |oErr| ErroForm( oErr , @lFechOk, @aLogErros[11], cNumJob, lThread ) } )
	
	// Apaga arquivo ja existente
	If File(cJobFile)
		fErase(cJobFile)
	EndIf

	// Criacao do arquivo de controle de jobs
	MSFCreate(cJobFile)

	// STATUS 1 - Iniciando execucao do Job
	PutGlbValue("GPM120"+xEmp+xFil+cNumJob, "1" )
	GlbUnLock()

	//Prepara ambiente
	RPCSetType( 3 )
	RpcSetEnv( xEmp, xFil,,,'GPE')
	SetsDefault()

	If Empty(cFilAnt)
		cFilAnt:= xFil
	EndIf

	//Autentica o usuário via token na thread
	If !Empty(GetGlbValue("cToken"))	
		totvs.framework.users.rpc.authByToken(GetGlbValue("cToken"))
	Else	
		&(cUser + cId) := xUser
	EndIf

Else
	cGPEGrid  := GetMvRH("MV_GPEGRID",, " ") //(1=Provisao 2=Calculo Roteiros 3=Fechamento em branco=Todas)
	lExecGrid := GetMvRH("MV_GRID",, .F.) .and. ( Empty(cGPEGrid) .Or. "3" $ cGPEGrid ) // Se o parametro esta configurado para utilizacao do GRID
EndIf

SetMnemonicos(NIL,NIL,.T.) //Carrega mnemonicos que serao utilizados nas funcoes de ferias e afastamentos

//Inicializar todas as variáveis private dentro desta função, seguindo o modelo, para que o GRID funcione
lFechOk := Gpm120SetPrivate(xEmp,xFil,xUser,xProcAux,cJobFile,cNumJob,lPMod2,lThread,nRecRCH,lExecGrid,aPerNext,aCompNext,@aLoad)

If lThread
	Conout(DtoC(Date())+ " " + Time() + " GPEM120: " + STR0067 + cNumJob )   //Iniciando Thread ##

	// STATUS 2 - Conexao efetuada com sucesso
	PutGlbValue("GPM120"+xEmp+xFil+cNumJob, "2" )
	GlbUnLock()
EndIf

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Inicia Processo Lancamento - Integracao com modulo PCO       ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
PcoIniLan("000085")

If nMinGrid > Len(aRegsSRA)
	lGrid := .F.
EndIf

For nLoop := 1 to Len(aRegsSRA)

	If lGrid
		If nCountReg == 0 .Or. nCountReg >= nLoteGrid
			Aadd(aCall, {} )
			nRegGrid++
			nCountReg := 0
		EndIf
		nCountReg++
		SRA->(DbGoTo(aRegsSRA[nLoop]))
		Aadd(aCall[nRegGrid], {nRegGrid, "SRA", aRegsSRA[nLoop], SRA->RA_FILIAL, SRA->RA_MAT} )
	Else
		If !lFechOk
			If lThread
				PutGlbValue("nTotReg"+cNumJob,AllTrim(STR(nLoop)))
				GlbUnLock()
			Else
				If !IsBlind()
					IncPrcG2Time( STR0026 + " " +SRA->RA_MAT + If(lOfusca, "", "-" + SRA->RA_NOME ), nSumSRA , cTimeIniSRA , .T. , 1 , 1 , .T. )	// Processando Funcionario ->
				EndIf
			EndIf
			Loop
		EndIf

		lFechOk := Gpm120Fecha(aRegsSRA,nLoop,dDtaLimite,lThread,cNumJob,@cTemMov,@aSindPLR,@aVlrMetric,.F.)

	EndIf

Next nLoop

If lGrid

	lFechOk := Gpm120ExecGrid( dDtaLimite, aCall, lThread, aLoad, aPerNext, aCompNext, lPMod2, nRecRCH, xProcAux, cNumJob, @cTemMov, @aSindPLR, @aVlrMetric)

	For nLoop := 1 to Len(aLogErros)
		For nX := 1 to Len(aLogErros[nLoop])
			aAdd(aLogGrid[nLoop],aLogErros[nLoop,nX])
		Next nX
	Next nLoop

	If lThread 
		PutGlbValue("nTotReg"+cNumJob,AllTrim(STR(Len(aRegsSRA))))
	ElseIf !IsBlind() //Finaliza segunda gauge 
		IncPrcG2Time( STR0026 + " " +SRA->RA_MAT + If(lOfusca, "", "-" + SRA->RA_NOME ), nSumSRA , cTimeIniSRA , .T. , 1 , 100 , .T. )	// Processando Funcionario ->
	EndIf

EndIf

If cTpRoteir == "F" //PLR

	DbSelectArea("RCE")
	DbSetOrder(1)

	For nX := 1 to Len(aSindPLR)

		//Grava historico do PLR no sindicato e zera dados de calculo
		If RCE->(DbSeek(aSindPLR[nX,1]+aSindPLR[nX,2]))
			nParcPLR := FBusParcPLR(aSindPLR[nX,3],RCE->RCE_PLRARC)
			If !Empty(RCE->RCE_PLRTPC) .and. ( AllTrim(Str(nParcPLR)) == RCE->RCE_PLRPAR .or. nParcPLR == 0 )
				DbSelectArea("RG4")
				DbSetOrder(2)
				If !DbSeek(RCE->RCE_FILIAL+RCE->RCE_CODIGO+"1")
					RecLock("RG4",.T.)
					RG4_FILIAL	:= RCE->RCE_FILIAL
					RG4_CODIGO	:= RCE->RCE_CODIGO
					RG4_PLRTPC 	:= RCE->RCE_PLRTPC
					RG4_PLRBSC 	:= RCE->RCE_PLRBSC
					RG4_PLRVLR	:= RCE->RCE_PLRVLR
					RG4_PLRPER	:= RCE->RCE_PLRPER
					RG4_PLRVMI	:= RCE->RCE_PLRVMI
					RG4_PLRVMA	:= RCE->RCE_PLRVMA
					RG4_PLRMAS	:= RCE->RCE_PLRMAS
					RG4_PLRARC	:= RCE->RCE_PLRARC
					RG4_PLRAMP	:= cPeriodo
					RG4_TIPO	:= "1"
					RG4_USER	:= __cUserID
					RG4->(MsUnLock())
				EndIf
				RecLock("RCE",.F.)
				RCE->RCE_PLRTPC	:= ""
				RCE->RCE_PLRBSC	:= ""
				RCE->RCE_PLRVLR	:= 0
				RCE->RCE_PLRPER	:= 0
				RCE->RCE_PLRVMI	:= 0
				RCE->RCE_PLRVMA	:= 0
				RCE->RCE_PLRMAS	:= ""
				RCE->RCE_PLRARC	:= ""
				RCE->RCE_PLRPAR	:= ""
				RCE->RCE_PLRQTD	:= 0
				RCE->(MsUnLock())
			EndIf
		EndIf
	Next nX
	fPackGpe("SRC") //Limpa os registros deletados
	fPackGpe("RGB")
EndIf

//-- Atualiza situação dos funcionários processados
If lFechOk .And. Len(aFuncAtSit) > 0 .And. (cTpRoteir $ "1*9" .Or. (cPaisLoc $ "MEX|ARG" .And. cTpRoteir == "A") .Or. (lGestPubl .And. cTpRoteir $ "L*M"))
	UpdSitFunc(aFuncAtSit)
EndIf

If lFechOk .And. cTpRoteir $ "1*9" .And. lVerMetrics
    For nLoop := 1 To Len(aVlrMetric)
        FwCustomMetrics():setSumMetric( aVlrMetric[nLoop, 1], "totvs-rh-protheus_total-liquido-folha_total", aVlrMetric[nLoop, 2], Nil, Nil, "GPEM120" )
        FwCustomMetrics():setSumMetric( aVlrMetric[nLoop, 1], "totvs-rh-protheus_totalproventos-folha-_total", aVlrMetric[nLoop, 3], Nil, Nil, "GPEM120" )
    Next nLoop
EndIf

If lThread
	ErrorBlock( bErro )

	If lFechOk
		PutGlbValue("lFechOk"+cNumJob,"S")
		GlbUnLock()
	Else
		PutGlbValue("lFechOk"+cNumJob,"N")
		GlbUnLock()
	EndIf

	PutGlbValue("cTemMov"+cNumJob,AllTrim(cTemMov))
	GlbUnLock()

	PutGlbValue("nTotFunc"+cNumJob,AllTrim(STR(nTotFunc)))
	GlbUnLock()

	PutGlbValue("nTotEmp"+cNumJob,AllTrim(STR(nTotEmp)))
	GlbUnLock()

	PutGlbValue("nTotRegs"+cNumJob,AllTrim(STR(nTotRegs)))
	GlbUnLock()

	PutGlbValue("nTotPLiq"+cNumJob,AllTrim(STR(nTotProvLiq)))
	GlbUnLock()

	PutGlbValue("nTotDLiq"+cNumJob,AllTrim(STR(nTotDescLiq)))
	GlbUnLock()

	PutGlbValue("nTotBsProv"+cNumJob,AllTrim(STR(nTotBsProv)))
	GlbUnLock()

	PutGlbValue("nTotBsDesc"+cNumJob,AllTrim(STR(nTotBsDesc)))
	GlbUnLock()

	PutGlbVars("aLogErr"+cNumJob,aLogErros)
	GlbUnLock()

	Conout(DtoC(Date())+ " " + Time() + " GPEM120: " + STR0068 + cNumJob )  //Finalizando Thread ##

EndIf

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Finaliza Processo Lancamento - Integracao com modulo PCO     ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
PcoFinLan("000085")

If lThread
	If Len(aRecProg) > 0
		VarBeginT(cUID,"aRecProg")
			VarGetAD(cUID,"aRecProg",@aRecAux)
			For nX := 1 to Len(aRecProg)
				aAdd(aRecAux, aRecProg[nX])
			Next nX
			VarSetAD(cUID,"aRecProg",aRecAux)
		VarEndT(cUID,"aRecProg")
	EndIf
	// STATUS 3 - Processamento efetuado com sucesso
	PutGlbValue("GPM120"+xEmp+xFil+cNumJob,"3")
	GlbUnLock()

	//Limpa ambiente
	RpcClearEnv()
Else 
	For nX := 1 to Len(aRecProg)
		aAdd(aFuncProg, aRecProg[nX])
	Next nX
EndIf

// Fechar todos os alias de querys criados na rotina
If (Select( cAliasSRC ) > 0)
	(cAliasSRC )->(dbCloseArea())
EndIf
If (Select( cAliasSR8 ) > 0)
	(cAliasSR8 )->(dbCloseArea())
EndIf
If (Select( cAliasSR3 ) > 0)
	(cAliasSR3 )->(dbCloseArea())
EndIf

Return

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³Gpem120ValFech³Autor³Mauricio Takakura    ³ Data ³20/12/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Validar o Fechamento do Mes Anterior e Mes Seguinte 		³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³Gpem120ValFech() 											³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³                 											³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³                                                            ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function Gpem120ValFech( cFilRCH 	,;	// Filial de RCH
								cProcFec	,;	// Codigo do Processo
								cRotFec		,;	// Codigo do Roteiro
								cPerFec		,;	// Codigo do Periodo
								cSemFec		,;	// Codigo da Semana
								aNextPer	,;	// @ Array com informacoes do proximo periodo
								aNextComp	,; 	// @ Proximo periodo da competencia seguinte
								lVldProx	;	// Se valida proximo periodo
							  )

Local aArea			:= RCH->( GetArea() )
Local aPerErros		:= {}
Local aFields_Log 	:= {}
Local aTamRCH		:= {}
Local aOldArea		:= {}
Local cAliasRCH		:= "RCH"
Local cFilSRV		:= ""
Local cAliasQry		:= GetNextAlias()
Local cJoin			:= ""
Local cRotRTF       := fGetCalcRot("N")
Local lRet 			:= .T.
Local lVldInteg		:= Posicione("SRY",1,xFilial("SRY")+cRotFec,"RY_INTEGRA") == "1"
Local lBrkPer		:= .F.
Local nX 			:= 0
Local nRecRCH		:= 0

DEFAULT aNextPer := {}

Begin Sequence

	DbSelectArea( cAliasRCH )
	(cAliasRCH)->(DbSetOrder( 4 )) // RCH_FILIAL + RCH_PROCES + RCH_ROTEIR + RCH_PER + RCH_NUMPAG
	DbSeek( cFilRCH + cProcFec + cRotFec + cPerFec + cSemFec, .F. )

	If (cAliasRCH)->( Eof() )
		aAdd( aPerErros, STR0022 ) // "Periodo não cadastrado."
		lRet := .F.
		Break
	EndIf

	If !Empty((cAliasRCH)->RCH_DTFECH)
		aAdd( aPerErros, STR0072 )	//"O período selecionado já está fechado."
		lRet := .F.
		Break
	EndIf

	If lVldInteg
		If Empty((cAliasRCH)->RCH_DTINTE)
			aAdd( aPerErros, STR0073 )	//"O período não foi integrado com a folha. Realize a integração antes do fechamento."
			lRet := .F.
			Break
		EndIf
	EndIf

	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Validacao do Periodo Anterior                                 ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	(cAliasRCH)->( DbSkip(-1) )
	If 	( (cAliasRCH)->( !BOF() ))				.and.	;
		( (cAliasRCH)->RCH_FILIAL == cFilRCH ) 	.and.	;
		( (cAliasRCH)->RCH_PROCES == cProcFec )	.and. 	;
		( (cAliasRCH)->RCH_ROTEIR == cRotFec ) .and.	;
		( Empty( (cAliasRCH)->RCH_DTFECH ) )

		aAdd( aPerErros, STR0016 ) // "O periodo anterior nao foi fechado"
		lRet := .F.

	EndIf

	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Validacao do Periodo Seguinte                                 ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	If (cAliasRCH)->( Bof() )
		(cAliasRCH)->( DbSkip() )
	Else
		(cAliasRCH)->( DbSkip(+2) )
	EndIf

	While (cAliasRCH)->( !Eof() ) .and. (cAliasRCH)->RCH_FILIAL == cFilRCH .and. ;
		  (cAliasRCH)->RCH_PROCES == cProcFec .and. (cAliasRCH)->RCH_ROTEIR == cRotFec
		 If (cAliasRCH)->RCH_COMPL == "1"
		 	(cAliasRCH)->( DbSkip() )
		 Else
		 	Exit
		 EndIf
	EndDo

	If lGestPubl .AND. cModulo == "GFP"
		lRet := f120TraVer(@aPerErros , cTransPd,cFilRCH , cProcFec, cRotFec,cSemFec,aNextPer,aNextComp, (cAliasRCH)->RCH_MES, ( cAliasRCH )->RCH_ANO )
	Else
		If 	( (cAliasRCH)->( !Eof() ) ) 			.and. ;
			( (cAliasRCH)->RCH_FILIAL == cFilRCH ) 	.and. ;
			( (cAliasRCH)->RCH_PROCES == cProcFec )  .and. ;
			( (cAliasRCH)->RCH_ROTEIR == cRotFec )	.and. ;
			( !Empty( (cAliasRCH)->RCH_DTFECH ) ) .and. cRotRTF <> cRotFec

			aAdd( aPerErros, STR0017 ) // "O periodo seguinte ja foi fechado"
			lRet := .F.

		ElseIf 	( ( (cAliasRCH)->( !Eof() ) ) 				.and. ;
				( ( (cAliasRCH)->RCH_FILIAL <> cFilRCH )	.or.  ;
				( (cAliasRCH)->RCH_PROCES <> cProcFec )  	.or.  ;
				( (cAliasRCH)->RCH_ROTEIR <> cRotFec) ) )	.or.  ;
				( (cAliasRCH)->( Eof() ))

			lNextPer := .F.

			(cAliasRCH)->( DbSkip(-1) )

			If lVldProx
				aAdd( aPerErros, STR0033 ) // "O periodo seguinte nao esta cadastrado."
				lRet := .F.
			EndIf

		Else

			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³Array com as informacoes do proximo periodo - Transf. Verbas  ³
			³Periodo de Controle da Semana                                 ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			aAdd( aNextPer, { 	(cAliasRCH)->RCH_FILIAL	,;
								(cAliasRCH)->RCH_PER	,;
								(cAliasRCH)->RCH_NUMPAG	,;
								(cAliasRCH)->RCH_PROCES	,;
								(cAliasRCH)->RCH_ROTEIR	,;
								(cAliasRCH)->RCH_MES	,;
								(cAliasRCH)->RCH_ANO	,;
								(cAliasRCH)->RCH_DTPAGO	,;
								(cAliasRCH)->RCH_DTINI	,;
								(cAliasRCH)->RCH_DTFIM	,;
								.T.						,;
								(cAliasRCH)->(Recno())  ;
						} )

			If cTpRoteir $ "1*9" //Se calculo da folha, cria array com o proximo periodo de adiantamento, para transferencia de verbas de IR
				nRecRCH := (cAliasRCH)->(Recno())
				DbSetOrder( RetOrder( "RCH", "RCH_FILIAL+RCH_PROCES+RCH_ROTEIR+RCH_PERSEL" ) )
				If DbSeek( cFilRCH + cProcesso + fGetCalcRot("2") + "1", .F. )
					aAdd( aNextPer, { 	(cAliasRCH)->RCH_FILIAL	,;
										(cAliasRCH)->RCH_PER	,;
										(cAliasRCH)->RCH_NUMPAG	,;
										(cAliasRCH)->RCH_PROCES	,;
										(cAliasRCH)->RCH_ROTEIR	,;
										(cAliasRCH)->RCH_MES	,;
										(cAliasRCH)->RCH_ANO	,;
										(cAliasRCH)->RCH_DTPAGO	,;
										(cAliasRCH)->RCH_DTINI	,;
										(cAliasRCH)->RCH_DTFIM	,;
										.T.						,;
										(cAliasRCH)->(Recno())  ;
								} )
				Else
					//Busca as filiais da SRV que serao processadas
					//Validação incluída para garantir que as verbas de IR Mês Anterior sejam gravadas no roteiro 'ADI' do mês seguinte
					If !Empty(cFilRCH)

						aOldArea := GetArea()

						cJoin := "%"
						cJoin += FWJoinFilial( "SRV", "RCH" )
						cJoin += "%"

						BeginSql alias cAliasQry
							SELECT DISTINCT(SRV.RV_FILIAL)
							FROM 		%table:SRV% SRV INNER JOIN %table:RCH% RCH
										ON %exp:cJoin%
							WHERE 		RCH.RCH_FILIAL = %exp:cFilRCH%
									AND RCH.%NotDel%
									AND SRV.%NotDel%
						EndSql

						If (cAliasQry)->( !Eof() )
							Do While (cAliasQry)->( !Eof() )

								cFilSRV  := (cAliasQry)->RV_FILIAL

								If PosSrv( fGetCodFol( "0006", .F. , cFilSRV), cFilSRV, "RV_IR" ) == "S" .and. fVerAdiAnt(cFilRCH,cProcFec,cRotFec)
									If Empty( cFilSRV )
										aAdd( aPerErros, OemToAnsi( STR0111 ) + CRLF + OemToAnsi( STR0112 ) + "." ) // "Não foi encontrado o período ADI ativo para a próxima competência. Regime caixa configurado no cadastro de verbas."
									Else
										aAdd( aPerErros, OemToAnsi( STR0111 ) + CRLF + OemToAnsi( STR0112 ) + " " + OemToAnsi( STR0113 ) + " " + cFilSRV + "." ) // "Não foi encontrado o período ADI ativo para a próxima competência. Regime caixa configurado no cadastro de verbas da filial "
									EndIf
									lNextPer := .F.
									lRet 	 := .F.
									lBrkPer  := .T.
								EndIf
								(cAliasQry)->( DbSkip() )
							EndDo
						EndIf

						(cAliasQry)->(dbCloseArea())
						RestArea(aOldArea)

						If lBrkPer
							Break
						EndIf
					EndIf
				EndIf

				(cAliasRCH)->( DbSetOrder( 4 ) )
				(cAliasRCH)->( DbGoTo( nRecRCH ) )

			EndIf

			While (cAliasRCH)->( !Eof() ) .and. (cAliasRCH)->RCH_FILIAL == cFilRCH .and. ;
				(cAliasRCH)->RCH_PROCES == cProcFec .and. (cAliasRCH)->RCH_ROTEIR == cRotFec
				If (cAliasRCH)->RCH_PER == cPerFec .and. ((cAliasRCH)->RCH_NUMPAG == cSemFec .Or. (cAliasRCH)->RCH_COMPL == "1" )
					(cAliasRCH)->( DbSkip() )
				Else
					Exit
				EndIf
			EndDo

			If (cAliasRCH)->( !Eof() ) .and. (cAliasRCH)->RCH_FILIAL == cFilRCH .and. ;
			(cAliasRCH)->RCH_PROCES == cProcFec .and. (cAliasRCH)->RCH_ROTEIR == cRotFec
				aAdd( aNextComp, { 	(cAliasRCH)->RCH_FILIAL	,;
									(cAliasRCH)->RCH_PER	,;
									(cAliasRCH)->RCH_NUMPAG	,;
									(cAliasRCH)->RCH_PROCES	,;
									(cAliasRCH)->RCH_ROTEIR	,;
									(cAliasRCH)->RCH_MES	,;
									(cAliasRCH)->RCH_ANO	,;
									(cAliasRCH)->RCH_DTPAGO	,;
									(cAliasRCH)->RCH_DTINI	,;
									(cAliasRCH)->RCH_DTFIM	,;
									.T.						,;
									(cAliasRCH)->(Recno())  ;
								} )
				If cTpRoteir $ "1*9" //Se calculo da folha, cria array com o proximo periodo de adiantamento, para transferencia de verbas de IR
					nRecRCH := (cAliasRCH)->(Recno())
					DbSetOrder( RetOrder( "RCH", "RCH_FILIAL+RCH_PROCES+RCH_ROTEIR+RCH_PERSEL" ) )
					If DbSeek( cFilRCH + cProcesso + fGetCalcRot("2") + "1", .F. )
						aAdd( aNextComp, { 	(cAliasRCH)->RCH_FILIAL	,;
											(cAliasRCH)->RCH_PER	,;
											(cAliasRCH)->RCH_NUMPAG	,;
											(cAliasRCH)->RCH_PROCES	,;
											(cAliasRCH)->RCH_ROTEIR	,;
											(cAliasRCH)->RCH_MES	,;
											(cAliasRCH)->RCH_ANO	,;
											(cAliasRCH)->RCH_DTPAGO	,;
											(cAliasRCH)->RCH_DTINI	,;
											(cAliasRCH)->RCH_DTFIM	,;
											.T.						,;
											(cAliasRCH)->(Recno())  ;
									} )
					Else
						//Busca as filiais da SRV que serao processadas
						//Validação incluída para garantir que as verbas de IR Mês Anterior sejam gravadas no roteiro 'ADI' do mês seguinte
						If !Empty(cFilRCH)

							aOldArea := GetArea()

							cJoin := "%"
							cJoin += FWJoinFilial( "SRV", "RCH" )
							cJoin += "%"

							BeginSql alias cAliasQry
								SELECT DISTINCT(SRV.RV_FILIAL)
								FROM 		%table:SRV% SRV INNER JOIN %table:RCH% RCH
											ON %exp:cJoin%
								WHERE 		RCH.RCH_FILIAL = %exp:cFilRCH%
										AND RCH.%NotDel%
										AND SRV.%NotDel%
							EndSql

							If (cAliasQry)->( !Eof() )
								Do While (cAliasQry)->( !Eof() )

									cFilSRV  := (cAliasQry)->RV_FILIAL

									If PosSrv( fGetCodFol( "0006", .F. , cFilSRV), cFilSRV, "RV_IR" ) == "S" .and. fVerAdiAnt(cFilRCH,cProcFec,cRotFec)
										If Empty( cFilSRV )
											aAdd( aPerErros, OemToAnsi( STR0111 ) + CRLF + OemToAnsi( STR0112 ) + "." ) // "Não foi encontrado o período ADI ativo para a próxima competência. Regime caixa configurado no cadastro de verbas."
										Else
											aAdd( aPerErros, OemToAnsi( STR0111 ) + CRLF + OemToAnsi( STR0112 ) + " " + OemToAnsi( STR0113 ) + " " + cFilSRV + "." ) // "Não foi encontrado o período ADI ativo para a próxima competência. Regime caixa configurado no cadastro de verbas da filial "
										EndIf
										lNextPer := .F.
										lRet 	 := .F.
										lBrkPer  := .T.
									EndIf
									(cAliasQry)->( DbSkip() )
								EndDo
							EndIf

							(cAliasQry)->(dbCloseArea())
							RestArea(aOldArea)

							If lBrkPer
								Break
							EndIf
						EndIf
					EndIf

					(cAliasRCH)->( DbSetOrder( 4 ) )
					(cAliasRCH)->( DbGoTo( nRecRCH ) )

				EndIf
			Else
				If lVldProx
					aAdd( aPerErros, STR0074 ) // "Não existe período cadastrado para a próxima competência."
					lNextPer := .F.
					lRet 	 := .F.
				EndIf
			EndIf

		EndIf
	EndIf

End Sequence

If Len(aPerErros) > 0
	aFields_Log := { "RCH_FILIAL", "RCH_PER", "RCH_NUMPAG", "RCH_PROCES", "RCH_ROTEIR" }
	aAdd( aLogErros[1], Gp120CabLog( "RCH", aFields_Log, @aTamRCH ) ) // Cabecalho do Log de Erros
	aAdd( aLogErros[1],	cFilRCH + Space( aTamRCH[1] ) + ;
						cPerFec + Space( aTamRCH[2] ) + ;
						cSemFec + Space( aTamRCH[3] ) + ;
						cProcFec + Space( aTamRCH[4] ) + ;
						cRotFec + Space( aTamRCH[5] )  )
	For nX := 1 To Len( aPerErros)
		aAdd( aLogErros[1], aPerErros[nX] )
	Next nX
	aAdd( aLogErros[1], "" )
EndIf

RestArea( aArea )

Return( lRet )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³fCargaTrans ³ Autor ³ Leandro Drumond     ³ Data ³ 18.10.13 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Carrega dados para a serem transportados para o mes seguinte³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³fCargaTrans(aPdTrans,cFilial)                               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³Generico                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function fCargaTrans(aPdTrans, aCodF, cFilSRA, aLogVerbas)
Local aArea 	:= GetArea()
Local cFilSRV	:= ""

Local cCampos 	:= "SRV.RV_COD, SRV.RV_CODMSEG, SRV.RV_REFFER, SRV.RV_CODFOL"
Local cOrder 	:= ""
Local cWhere 	:= ""
Local cFromTable:= ""

Local cAliasQry := ""
Local lFirst	:= .T.
Local lRet		:= .T.
Local nCont		:= 0
Local nContId	:= 0
Local cCod1		:= ""

Local aIdsObrig := { "0043", "0045", "0073", "0089", "0091", "0078", "0093", "0076", "0081", "0083", "0097", "0085", "0099",;
					"0160", "0162", "0344", "0346", "0637", "0205", "0206", "0207", "0208", "0232", "0633", "0634", "0635",;
					"0839", "0841", "1297", "1299", "1301", "1303", "1305", "1307", "1309", "1311", "1313", "1315", "1317",;
					"1319", "1321", "1323", "1325", "1327", "1331", "1405", "1406", "1409", "1410" }

Local cCodAbon  := "0205/0206/0207/0208/0633/0634/0635/1313/1315/1317/1319/1321/1323/1325/1327/1331/1409/1410/1418/1419/"

Default aLogVerbas := {}
Default cFilSRA	   := cFilAnt

cFilSRV	:= xFilial( "SRV", cFilSRA )

If !(PosSrv(aCodFol[6,1],SRA->RA_FILIAL,"RV_IR") == "N" .And. PosSrv(aCodFol[7,1], SRA->RA_FILIAL,"RV_IR") == "N")
	Aadd (aIdsObrig,  "0015" )
	Aadd (aIdsObrig,  "0066" )
Endif

If Type( "cAliasSRV" ) == "U"
	cAliasSRV := "SRV"
EndIf

If Type( "lRefAbono" ) == "U"
	lRefAbono	:= If(SRV->(ColumnPos( 'RV_REFABON' )) > 0,.T.,.F.)
EndIf

If lRefAbono
	cCampos += ", SRV.RV_REFABON"
EndIf

cCampos	:= "%" + cCampos + "%"

cAliasQry := GetNextAlias()

cOrder := "% SRV.RV_FILIAL, SRV.RV_COD %"
cWhere := "% SRV.RV_FILIAL = '" + cFilSRV +"' AND SRV.RV_CODMSEG <> '' AND %"

cFromTable := "% " + RetSqlName("SRV") + " SRV %"

BeginSql alias cAliasQry
	SELECT 		%exp:cCampos%
	FROM 		%exp:cFromTable%
	WHERE 		%exp:cWhere%
				SRV.%NotDel%
	ORDER BY    %exp:cOrder%
EndSql

Do While (cAliasQry)->( !Eof() )
	aAdd( aPdTrans, { (cAliasQry)->RV_COD		,;						// codigo corrente na tabela SRC
					  (cAliasQry)->RV_CODMSEG	,;						// codigo a ser transferido
					  If( (cAliasQry)->RV_REFFER == "S", Iif( cPaisLoc == "BRA" .And. ((cAliasQry)->RV_CODFOL $ cCodAbon .Or. If(lRefAbono, (cAliasQry)->RV_REFABON == "1", .F.)), "A", "F"), "B" );	// F-Ferias, A-Abono e B-Basico
					} )
	(cAliasQry)->(DbSkip())
EndDo

(cAliasQry)->(dbCloseArea())

If IsInCallStack("GPEM120") .And. cPaisLoc == "BRA"
	For nCont := 1 To Len(aIdsObrig)
		cCod1:= aCodFol[Val(aIdsObrig[nCont]),1]
		If !Empty(cCod1) .And. aScan(aPdTrans, { |x| x[1] == cCod1 }) == 0
			If nContId == 0 .Or. nContId == 40
				If lFirst
					aAdd(aLogVerbas[1], STR0105 + cFilSRV )//"Filial: "
				EndIf
				aAdd(aLogVerbas[1], aCodFol[Val(aIdsObrig[nCont]),1] )
				If nContId == 40
					nContId := 0
				EndIf
			Else
				aLogVerbas[1][Len(aLogVerbas[1])] += "/" + cCod1
			EndIf
			nContId++
			lFirst := .F.
			lRet	:= .F.
		EndIf
	Next nCont
EndIf

//Para semanalista, somara as verbas das semanas anteriores na base de IR da semana para enviar para a próxima.
aAdd( aPdTrans, { aCodFol[106,1],;		// codigo corrente na tabela SRC
				  aCodFol[106,1],;		// codigo a ser transferido
				  "B" } )				// B-Base

aAdd( aPdTrans, { aCodFol[107,1],;		// codigo corrente na tabela SRC
				  aCodFol[107,1],;		// codigo a ser transferido
				  "B" } )				// B-Base

RestArea( aArea )

Return( lRet )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³fProcTrans    ³Autor³Mauricio T. Takakura ³ Data ³28/12/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Processar as verbas a serem transportados                   ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³                               								³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³                 											³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³ Generico                                                   ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function fProcTrans( aPdTrans		,;
							aPerSeguinte	,;
							aSRCFields		,;
							aNextPer		,;
							aNextComp		,;
							cMesProc		,;
							cAnoProc		,;
							cMv_CatNPgt		,;
							aValMSegRGB		 ;
						  )

Local lNotAppl		:= .F.
Local lVld1890		:= Len(aCodFol) >= 1890 .And. !Empty(aCodFol[1890,1]) .And. PosSrv(aCodFol[1890,1],SRA->RA_FILIAL,"RV_IR") == "S"
Local l1890 		:= .F.

Local cText
Local cChave
Local cTipoVerba
Local cPrefixo		:= PrefixoCpo( "RGB")+ "_"

Local nTrans
Local nQtdeSRV
Local nQtdeLan
Local nSvTrans
Local nFindTrans

Local nFilial 	:= 0
Local nCC		:= 0
Local nDtRef	:= 0
Local nMat		:= 0
Local nSeq		:= 0
Local nPD		:= 0

Local aFields	:= aRGBFields

nFilial 	:= aScan( aFields, { |x| x[1] == cPrefixo +"FILIAL" } )
nCC			:= aScan( aFields, { |x| x[1] == cPrefixo +"CC"     } )
nDtRef		:= aScan( aFields, { |x| x[1] == cPrefixo +"DTREF"  } )

If lItemClvl
	nItem		:= aScan( aFields, { |x| x[1] == cPrefixo +"ITEM"  } )
	nClvl		:= aScan( aFields, { |x| x[1] == cPrefixo +"CLVL"  } )
EndIf

nMat		:= aScan( aFields, { |x| x[1] == cPrefixo +"MAT"   } )
nSeq		:= aScan( aFields, { |x| x[1] == cPrefixo +"SEQ"   } )
nPD			:= aScan( aFields, { |x| x[1] == cPrefixo +"PD"    } )

DEFAULT aValMSegRGB := {}

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Checa se a Verba possui transferencia para o Periodo Seguinte³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
DbSelectArea( cAliasSRC )
If ( cAliasSRA )->RA_SITFOLH # "D"
	nTrans := Ascan(aPdTrans,{|x| x[1] == (cAliasSRC)->RC_PD })
Else
	nTrans := 0
EndIf

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Transferencia dos valores para o proximo periodo             ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
If nTrans # 0
	If aPdTrans[nTrans,3] == "F"
		If !lItemClvl
			cChave := (cAliasSRC)->RC_FILIAL + (cAliasSRC)->RC_CC + (cAliasSRC)->RC_MAT + aCodFol[164,1] + dToS( (cAliasSRC)->RC_DATA )
		Else
			cChave := (cAliasSRC)->RC_FILIAL + (cAliasSRC)->RC_CC + (cAliasSRC)->RC_ITEM + (cAliasSRC)->RC_CLVL + (cAliasSRC)->RC_MAT + aCodFol[164,1] + dToS( (cAliasSRC)->RC_DATA )
		EndIf
		nSvTrans := 0
		cTipoVerba := aPdTrans[nTrans,3]
		If !lItemClvl
			nFindTrans := aScan( aPerSeguinte, { |x,y| x[nFilial]+x[nCC]+x[nMat]+x[nPD]+dToS( x[nDtRef] ) == cChave } )
		Else
			nFindTrans := aScan( aPerSeguinte, { |x,y| x[nFilial]+x[nCC]+x[nItem]+x[nClvl]+x[nMat]+x[nPD]+dToS( x[nDtRef] ) == cChave } )
		EndIf
		fGetTrans(aPdTrans, aNextPer, aNextComp, @aPerSeguinte, aSRCFields, nFindTrans, nSvTrans, cTipoVerba, cAnoProc+cMesProc, NIL, cMv_CatNPgt)
	ElseIf aPdTrans[nTrans,3] == "A"
		l1890 := lVld1890 .And. ( aPdTrans[nTrans,1] $ aCodFol[206,1] + "/" + aCodFol[208,1] ) // .T. = 1/3 Abono /// .F. = Abono
		If !lItemClvl
			cChave := (cAliasSRC)->RC_FILIAL + (cAliasSRC)->RC_CC + (cAliasSRC)->RC_MAT + IIf(l1890, aCodFol[1890,1], aCodFol[1449,1] ) + dToS( (cAliasSRC)->RC_DATA )
		Else
			cChave := (cAliasSRC)->RC_FILIAL + (cAliasSRC)->RC_CC + (cAliasSRC)->RC_ITEM + (cAliasSRC)->RC_CLVL + (cAliasSRC)->RC_MAT + IIf(l1890, aCodFol[1890,1], aCodFol[1449,1] ) + dToS( (cAliasSRC)->RC_DATA )
		EndIf
		
		nSvTrans := 0
		cTipoVerba := aPdTrans[nTrans,3]
		If !lItemClvl
			nFindTrans := aScan( aPerSeguinte, { |x,y| x[nFilial]+x[nCC]+x[nMat]+x[nPD]+dToS( x[nDtRef] ) == cChave } )
		Else
			nFindTrans := aScan( aPerSeguinte, { |x,y| x[nFilial]+x[nCC]+x[nItem]+x[nClvl]+x[nMat]+x[nPD]+dToS( x[nDtRef] ) == cChave } )
		EndIf
		fGetTrans(aPdTrans, aNextPer, aNextComp, @aPerSeguinte, aSRCFields, nFindTrans, nSvTrans, cTipoVerba, cAnoProc+cMesProc, NIL, cMv_CatNPgt)
	EndIf
	If !lItemClvl
		cChave := (cAliasSRC)->RC_FILIAL + (cAliasSRC)->RC_CC + (cAliasSRC)->RC_MAT + aPdTrans[nTrans,2] + (cAliasSRC)->RC_SEQ
	Else
		cChave := (cAliasSRC)->RC_FILIAL + (cAliasSRC)->RC_CC + (cAliasSRC)->RC_ITEM+ (cAliasSRC)->RC_CLVL + (cAliasSRC)->RC_MAT + aPdTrans[nTrans,2] + (cAliasSRC)->RC_SEQ
	EndIf
	nSvTrans := nTrans
	cTipoVerba := NIL

	If !lItemClvl
		nFindTrans := aScan( aPerSeguinte, { |x,y| x[nFilial]+x[nCC]+x[nMat]+x[nPD]+x[nSeq] == cChave } )
	Else
		nFindTrans := aScan( aPerSeguinte, { |x,y| x[nFilial]+x[nCC]+x[nItem]+x[nClvl]+x[nMat]+x[nPD]+x[nSeq] == cChave } )
	EndIf
	fGetTrans(aPdTrans, aNextPer, aNextComp, @aPerSeguinte, aSRCFields, nFindTrans, nSvTrans, cTipoVerba, cAnoProc+cMesProc, NIL, cMv_CatNPgt)
Else
	If (cAliasSRA)->RA_SITFOLH # "D"

		nQtdeSRV := Val( RetValSrv( (cAliasSRC)->RC_PD, (cAliasSRA)->RA_FILIAL, "RV_QTDLANC" ) ) 

		nQtdeLan := 0
		If !lItemClvl
			cChave := (cAliasSRC)->RC_FILIAL + (cAliasSRC)->RC_CC + (cAliasSRC)->RC_MAT + (cAliasSRC)->RC_PD
			aEval( aPerSeguinte, { |x| If( x[nFilial]+x[nCC]+x[nMat]+x[nPD] == cChave, nQtdeLan++, 0) })
		Else
			cChave := (cAliasSRC)->RC_FILIAL + (cAliasSRC)->RC_CC + (cAliasSRC)->RC_ITEM + (cAliasSRC)->RC_CLVL + (cAliasSRC)->RC_MAT + (cAliasSRC)->RC_PD
			aEval( aPerSeguinte, { |x| If( x[nFilial]+x[nCC]+ x[nItem] + x[nClvl] + x[nMat]+x[nPD] == cChave, nQtdeLan++, 0) })
		EndIf
		If nQtdeLan < nQtdeSRV
			nFindTrans := 0
		Else
			If !lItemClvl
				nFindTrans := aScan( aPerSeguinte, { |x| x[nFilial]+x[nCC]+x[nMat]+x[nPD] == cChave } )
			Else
				nFindTrans := aScan( aPerSeguinte, { |x| x[nFilial]+x[nCC]+x[nItem]+x[nClvl]+x[nMat]+x[nPD] == cChave } )
			EndIf
		EndIf

		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Gerar Lancamentos quando houver parcelas                     ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		If (cAliasSRC)->RC_PARCELA > 1 .And. (cAliasSRC)->RC_PARCELA < 99
			nFindTrans := 0
			fGetTrans(aPdTrans, aNextPer, aNextComp, @aPerSeguinte, aSRCFields, nFindTrans, 0, "I", cAnoProc+cMesProc, 1, cMv_CatNPgt,, @aValMSegRGB )
		EndIf

		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Se tem valor nao aplicado, nao gera para o periodo seguinte   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		If ( !lModPadrao .and. (cAliasSRC)->RC_VNAOAPL > 0 )
			If Substr((cAliasSRC)->RC_NUMID,1,3) == "SRK"
				lNotAppl := .T.
			EndIf
		EndIf

		// Tratamento para Valor Não Aplicado de Valores Futuros
		If !lNotAppl
			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Gerar o Lancamento quando possuir valores em Nao Aplicado    ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			If (cAliasSRC)->RC_VNAOAPL > 0 .and. (cAliasSRC)->RC_PARCELA > 1

				/*
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Gerar Log, pois sera gerado + lancamentos do que a verba per-³
				³ mite.                                                        ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
				nQtdeLan := 0
				If !lItemClvl
					aEval( aPerSeguinte, { |x| If( x[nFilial]+x[nCC]+x[nMat]+x[nPD] == cChave, nQtdeLan++, 0) } )
				Else
					aEval( aPerSeguinte, { |x| If( x[nFilial]+x[nCC]+x[nItem]+x[nClvl]+x[nMat]+x[nPD] == cChave, nQtdeLan++, 0) } )
				EndIf
				If nQtdeLan >= nQtdeSRV
					nFindTrans := 0
					If Empty( aLogErros[4] )
						aAdd( aLogErros[4], STR0031 + Space(40) + STR0032)	// "Funcionarios" ### "Verbas"
						aAdd( aLogErros[4], "" )
					EndIf
					cText := ( cAliasSRA )->RA_MAT + "-" + ( cAliasSRA )->RA_NOME
					cText := cText + Space( If( (52 - Len( cText )) > 0, (52 - Len( cText )), 1))
					cText := cText + ( cAliasSRC )->RC_PD + "-" + PosSrv( (cAliasSRC)->RC_PD, (cAliasSRA)->RA_FILIAL, "RV_DESC" )
					aAdd( aLogErros[4], cText )
				EndIf
				nFindTrans := 0
				fGetTrans(aPdTrans, aNextPer, aNextComp, @aPerSeguinte, aSRCFields, nFindTrans, 0, "I", cAnoProc+cMesProc, 0, cMv_CatNPgt, 1,@aValMSegRGB,.T.)
			ElseIf (cAliasSRC)->RC_VNAOAPL > 0
				If  Iif(cPaisLoc == "PAR",EsVlrNoApl((cAliasSRC)->RC_PD) ,.T.) 
					nFindTrans := 0
					fGetTrans(aPdTrans, aNextPer, aNextComp, @aPerSeguinte, aSRCFields, nFindTrans, 0, "I", cAnoProc+cMesProc, 0, cMv_CatNPgt,,@aValMSegRGB)
				Endif
			EndIf
		EndIf
	EndIf
EndIf

Return( Nil )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³fGetTrans     ³Autor³Equipe de RH         ³ Data ³16/02/1995³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Pegar os lancamentos do mes seguinte                     	³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³fGetTrans()                                                 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³ Vide Abaixo                                                ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³ Generico                                                   ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function fGetTrans(	aPdTrans	,;	// 01 - matriz com as informacoes da Transferencia
							aNextPer	,;	// 02 - array com informacoes do proximo periodo
							aNextComp	,;  // 03 - array com o periodo da proxima competencia
							aPerSeguinte,;	// 04 - array com os registros a serem transferidos para o mes seguinte
							aSRCFields	,;	// 05 - array com a estrutura do arquivo SRC
							nAltReg		,;	// 06 - Se 0, novo registro, senao somente alteracao
							nTrans		,;	// 07 - elemento do array no aPdTrans
							cBFM		,;	// 08 - caracteristica da Operacao	- F(Ferias ou Media) I (Outras Verbas)
							cMesAno		,;	// 09 - Ano e Mes
							nParcMenos  ,;	// 10 - parcelas a serem descontas
							cMv_CatNPgt	,;	// 11 - Parametro com as categorias
							nVInfoParc99,;  // 12 - 1 - Lancamento de Valor Informado com Nro Pago 99 (Gravar com 0)
							aValMSegRGB ,;  // 13 - Array com as incidencias de parcelas maior que 0
							lParcNoAplc  ;  // 14 - Controlar Parcelas > 1 e com valores nao aplicados
						 )

Local aFields_log 						// Campos para montagem do Log de Erros
Local cSeq								// Campo Sequencia qdo for incluir +1 registro do mesmo empregado e Verba
Local cChave		:= ""
Local cCampo							// valor da verba a ser transferida
Local cField							// nome do campo na tabela para gravacao
Local cNextPer
Local cNextPgto
Local cNextProc
Local cNextRot
Local cNextDtRef
Local cConteudo
Local cAlias 		:= Alias()			// alias corrente para restaurar ao retornar
Local cPrefixo		:= PrefixoCpo( "RGB")+ "_"
Local lContinua     := .T.
Local lFilSRV
Local lVld1449		:= (cPaisLoc == "BRA")
Local lInsufADI     := cPaisLoc == "BRA" .and. P_INSUFADI
Local lVld1890		:= Len(aCodFol) >= 1890 .And. !Empty(aCodFol[1890,1]) .And. PosSrv(aCodFol[1890,1],SRA->RA_FILIAL,"RV_IR") == "S"

Local nPos
Local nQtdeLan		:= 0
Local nField
Local nQtdeSRV
Local nFields							// quantidade de campos da tabela SRC
Local nSRVPosRGB
Local nPosParcel
Local nPosSeq
Local nPosDtRef
Local nPosRGB
Local nPosTipo2     := 0

Local nFilial 	:= 0
Local nCC		:= 0
Local nMat		:= 0
Local nSeq		:= 0
Local nPD		:= 0
Local nLanDia   := 0

Local aFields	:= aRGBFields
Local lIrNeg	:= Len(aCodFol) >= 1726 .And. !Empty(aCodFol[1726,1]) .And. !Empty(aCodFol[1727,1])

Default cBFM	:= ""

nFilial 	:= aScan( aFields, { |x| x[1] == cPrefixo +"FILIAL"} )
nCC			:= aScan( aFields, { |x| x[1] == cPrefixo +"CC"    } )

If lItemClvl
	nItem		:= aScan( aFields, { |x| x[1] == cPrefixo +"ITEM"  } )
	nClvl		:= aScan( aFields, { |x| x[1] == cPrefixo +"CLVL"  } )
EndIf

nMat		:= aScan( aFields, { |x| x[1] == cPrefixo +"MAT"   } )
nSeq		:= aScan( aFields, { |x| x[1] == cPrefixo +"SEQ"   } )
nPD			:= aScan( aFields, { |x| x[1] == cPrefixo +"PD"    } )

Static aTamSRC	:= {}					// Determina o tamanho de cada campo

DEFAULT nParcMenos 		:= 0			// Parcelas a Deduzir
DEFAULT lParcNoAplc 	:= .F.          // Registro com Valor Nao aplicado e Parcela > 1

nFields := Len(aRGBFields)

lFilSRV := FWModeAccess("SRV", 3) == "C"
/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Para os funcionarios cadastrados no parametro MV_CATNPGT, nao  ³
³ lancamento para o mes seguinte. Apenas um log informando quais ³
³ verbas e seus respectivos valores.                             ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
If !lNextPer
	aFields_Log := { "RC_MAT", "RC_NOME", "RC_PD", "RC_DESCPD", "RC_HORINFO", "RC_VALINFO", "RC_HORAS", "RC_VALOR", "RC_VNAOAPL", "RC_DATA", "RC_DTREF", "RC_PARCELA", "RC_PERIODO", "RC_SEMANA" }

	If Empty(aLogErros[2])
		aAdd( aLogErros[2], Gp120CabLog( "SRC", aFields_Log, @aTamSRC ) ) // Cabecalho do Log de Erros
		aAdd( aLogErros[2], "" )
	EndIf

	aAdd( aLogErros[2], (cAliasSRC)->RC_MAT 										+ Space( aTamSRC[1] ) + ;
						If( lOfusca, Replicate('*',30), (cAliasSRA)->RA_NOME )		+ Space( aTamSRC[2] ) + ;
						(cAliasSRC)->RC_PD											+ Space( aTamSRC[3] ) + ;
						PosSrv((cAliasSRC)->RC_PD,(cAliasSRC)->RC_FILIAL,"RV_DESC")	+ Space( aTamSRC[4] ) + ;
						Str((cAliasSRC)->RC_HORINFO,6,2)							+ Space( aTamSRC[5] ) + ;
						Str((cAliasSRC)->RC_VALINFO,12,2)							+ Space( aTamSRC[6] ) + ;
						Str((cAliasSRC)->RC_HORAS,6,2)								+ Space( aTamSRC[7] ) + ;
						Str((cAliasSRC)->RC_VALOR,12,2)								+ Space( aTamSRC[8] ) + ;
						Str((cAliasSRC)->RC_VNAOAPL,12,2)							+ Space( aTamSRC[9] ) + ;
						Dtoc((cAliasSRC)->RC_DATA)									+ Space( aTamSRC[10] )+ ;
						Dtoc((cAliasSRC)->RC_DTREF)									+ Space( aTamSRC[11] )+ ;
						Str((cAliasSRC)->RC_PARCELA,2,0)							+ Space( aTamSRC[12] )+ ;
						(cAliasSRC)->RC_PERIODO										+ Space( aTamSRC[13] )+ ;
						(cAliasSRC)->RC_SEMANA										+ Space( aTamSRC[14] )  ;
		)
	DbSelectArea(cAlias)
	Return( Nil )
EndIf

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Pegar o codigo da verba a gravar                               ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
cCampo := (cAliasSRC)->RC_PD

If nTrans # 0
	cCampo := aPdTrans[nTrans, 2]  // Grava Codigo de acordo com Matriz
Else
	If cBFM = "F"
		cCampo := aCodFol[164,1]	// Ferias Pagas Mes Anterior - Se mostra Help ou nao
	ElseIf cBFM = "A"
		cCampo := IIf( lVld1890 .And. ( cCampo $ aCodFol[206,1] + "/" + aCodFol[208,1] ), aCodFol[1890,1], aCodFol[1449,1] )	// 1/3 Abonos Pagos Mes Anterior  /// Abonos Pagos Mes Anterior
	ElseIf cBFM == "I"
		cCampo := (cAliasSRC)->RC_PD
	EndIf
EndIf

If nTrans == 0 .And. cBFM $ "F/A" .And. RetValSrv( (cAliasSRC)->RC_PD, (cAliasSRC)->RC_FILIAL, "RV_TIPOCOD" ) $ "3/4"
	Return
EndIf

// Verificar se possui lancamentos em incidencias //
nSRVPosRGB 	:= Ascan(aRGBFields,{|x| x[1] = "RGB_PD" })
nPosParcel  := Ascan(aRGBFields,{|x| x[1] = "RGB_PARCEL" })
nPosSeq		:= Ascan(aRGBFields,{|x| x[1] = "RGB_SEQ" })
nPosDtRef	:= Ascan(aRGBFields,{|x| x[1] = "RGB_DTREF" })
nPosPeriod	:= Ascan(aRGBFields,{|x| x[1] = "RGB_PERIOD" })
nPosTipo2	:= Ascan(aRGBFields,{|x| x[1] = "RGB_TIPO2" })

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Gravar no Array o registro a ser transferido para o mes seguinte³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
If nAltReg == 0
	nQtdeSRV := Val( PosSrv( (cAliasSRC)->RC_PD, (cAliasSRA)->RA_FILIAL, "RV_QTDLANC" ) )

	If !lItemClvl
		cChave := (cAliasSRC)->RC_FILIAL + (cAliasSRC)->RC_CC + (cAliasSRC)->RC_MAT + cCampo + Iif( cBFM $ "F/A", dToS( (cAliasSRC)->RC_DATA ), "" )
		aEval( aPerSeguinte, { |x| If( x[nFilial]+x[nCC]+x[nMat]+x[nPD]+Iif( cBFM $ "F/A", dToS( x[nPosDtRef] ), "" ) == cChave, nQtdeLan++, 0) })
	Else
		cChave := (cAliasSRC)->RC_FILIAL + (cAliasSRC)->RC_CC + (cAliasSRC)->RC_ITEM + (cAliasSRC)->RC_CLVL + (cAliasSRC)->RC_MAT + cCampo + Iif( cBFM $ "F/A", dToS( (cAliasSRC)->RC_DATA ), "" )
		aEval( aPerSeguinte, { |x| If( x[nFilial]+x[nCC]+x[nItem]+x[nClvl]+x[nMat]+x[nPD]+Iif( cBFM $ "F/A", dToS( x[nPosDtRef] ), "" ) == cChave, nQtdeLan++, 0) })
	EndIf

	If (cAliasSRC)->RC_TIPO2 == "K" //Se for verba de férias, mantém a sequencia gravada na SRC para controle das verbas de mês seguinte
		cSeq := (cAliasSRC)->RC_SEQ
	ElseIf nQtdeSRV <= 1 .or. nQtdeLan < 1
		cSeq := Space( GetSx3Cache( "RC_SEQ", "X3_TAMANHO" ) )
	Else
    	cSeq := StrZero(nQtdeLan+1,1)
	EndIf

	If ( cCampo # aCodFol[164,1] .And. Iif( lVld1449, cCampo # aCodFol[1449,1], .T. ) ) .Or. ( nQtdeLan == 0 )
		aAdd( aPerSeguinte, Array( nFields ) )
		nAltReg := Len(aPerSeguinte)
	EndIf
	If ( cCampo == aCodFol[164,1] ) .And. ( nQtdeLan > 0 )
		nAltReg := Ascan( aPerSeguinte, { |x| x[nPD] == aCodFol[164,1] } )
	EndIf
	If ( Iif( lVld1449, cCampo == aCodFol[1449,1], .F. ) ) .And. ( nQtdeLan > 0 )
		nAltReg := Ascan( aPerSeguinte, { |x| x[nPD] == aCodFol[1449,1] } )
	EndIf
EndIf

//Tratamento para férias do mês seguinte no mês de janeiro, que pode trafegar até março.
If cCampo # aCodFol[164,1] .And. Iif( lVld1449, cCampo # aCodFol[1449,1], .T. ) .And. cCampo <> (cAliasSRC)->RC_PD .and. nTrans > 0 .And. aPdTrans[nTrans,3] == "F" .And. Month((cAliasSRC)->RC_DTREF) == 1 //Se for Férias e sequencia for maior que "1", verifica se trata-se de férias pagas no terceiro mês (inicio em 31/01) para gravá-la no próximo mês ainda como mês seguinte
	If !Empty((cAliasSRC)->RC_SEQ) .and. Val((cAliasSRC)->RC_SEQ) > 1//Se existe duas verbas, apenas a primeira deve ser alterada para mês, a segunda permnanece como mês seguinte
		cCampo := (cAliasSRC)->RC_PD
	EndIf
EndIf

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Posicao do array aNextPer                                       ³
³      aNextPer[01] - RCH_FILIAL                                  ³
³      aNextPer[02] - RCH_PER                                     ³
³      aNextPer[03] - RCH_NUMPAG                                  ³
³      aNextPer[04] - RCH_PROCES                                  ³
³      aNextPer[05] - RCH_ROTEIR                                  ³
³      aNextPer[06] - RCH_MES                                     ³
³      aNextPer[07] - RCH_ANO                                     ³
³      aNextPer[08] - RCH_DTPAGO                                  ³
³      aNextPer[09] - RCH_DTINI                                   ³
³      aNextPer[10] - RCH_DTFIM                                   ³
³      aNextPer[11] - SE .T. PERTENCE AO PROXIMO PERIODO          ³
³      aNextPer[12] - Recno                                       ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Seleciona a qual periodo sera enviado a verba - 1=Competencia           ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
If PosSrv( (cAliasSRC)->RC_PD , (cAliasSRC)->RC_FILIAL, "RV_FECCOMP") == "1"
	If Len(aNextComp) > 1 .and. ( ( aCodFol[106,1] == cCampo .Or. aCodFol[107,1] == cCampo ) .Or. (lIrNeg .And. (cCampo = aCodFol[1727,1] ) ) .Or. ( aCodFol[46,1] == cCampo .and. lInsufADI ) ) //Transfere verbas para o periodo de adiantamento, se existir
		cNextPer 	:= aNextComp[2, 02]
		cNextPgto 	:= aNextComp[2, 03]
		cNextProc   := aNextComp[2, 04]
		cNextRot    := aNextComp[2, 05]
		cNextDtRef	:= aNextComp[2, 10] // Data de Referencia para as verbas sem lancamentos diarios
		nLanDia 	:= aNextComp[2, 10] - aNextComp[1, 9]
	Else
		cNextPer 	:= aNextComp[1, 02]
		cNextPgto 	:= aNextComp[1, 03]
		cNextProc   := aNextComp[1, 04]
		cNextRot    := aNextComp[1, 05]
		cNextDtRef	:= aNextComp[1, 10] // Data de Referencia para as verbas sem lancamentos diarios
		nLanDia 	:= aNextComp[1, 10] - aNextComp[1, 9]
	EndIf
Else
	If Len(aNextPer) > 1 .And. (cAliasSRA)->RA_PERCADT > 0 .And. ( ( aCodFol[106,1] == cCampo .Or. aCodFol[107,1] == cCampo ) .Or. (lIrNeg .And. (cCampo = aCodFol[1727,1]  ) .Or. ( aCodFol[46,1] == cCampo .and. lInsufADI )))  //Transfere verbas para o periodo de adiantamento, se existir
		cNextPer 	:= aNextPer[2, 02]
		cNextPgto 	:= aNextPer[2, 03]
		cNextProc   := aNextPer[2, 04]
		cNextRot    := aNextPer[2, 05]
		cNextDtRef	:= aNextPer[2, 10]
		nLanDia 	:= aNextPer[2, 10] - aNextPer[2, 9]
	Else
		cNextPer 	:= aNextPer[1, 02]
		cNextPgto 	:= aNextPer[1, 03]
		cNextProc   := aNextPer[1, 04]
		cNextRot    := aNextPer[1, 05]
		cNextDtRef	:= aNextPer[1, 10]
		nLanDia 	:= aNextPer[1, 10] - aNextPer[1, 9]
	EndIf
EndIf

//Se estiver tentando somar a base de IR mes anterior / IR mes anterior para lançar na próxima semana e não for freteiro semanalista ou a data de pagamento de uma semana para outra foi alterada, ignora
If cCampo $ aCodFol[106,1] + "/" + aCodFol[107,1]
	If ( aPdTrans[nTrans,2] == aPdTrans[nTrans,1] .and. !((cAliasSRA)->RA_TIPOPGT == "S" .and. (cAliasSRA)->RA_CATEG == "15" .and. (cAliasSRA)->RA_CATFUNC == "A" .and. (cAliasSRC)->RC_SEMANA <> "01") ) ; //Se não for freteiro semanalista e com próximo pagamento no mesmo mês, não efetua soma das verbas de mês seguinte
	 .or. ( aPdTrans[nTrans,2] <> aPdTrans[nTrans,1] .and. (cAliasSRA)->RA_TIPOPGT == "S" .and. cNextPgto <> "01" ) //Se for semanalista e a semana seguinte não for 01, não grava as verbas de mes seguinte
		If nAltReg == Len(aPerSeguinte) .and. aPerSeguinte[nAltReg,1] == Nil //Apaga última posição criada e que não será utiliada
			aDel(aPerSeguinte , Len(aPerSeguinte))
			aSize(aPerSeguinte,Len(aPerSeguinte)-1)
		EndIf
		Return Nil
	EndIf
EndIf

cPrefixo:= ( PrefixoCpo( "SRC") + "_" )
nFields := Len(aSRCFields)

If (cAliasSRC)->RC_PARCELA > 0
	//Encontra a parcela calculada no RGB
	nPosRGB		:= Ascan(aValMSegRGB, {|x| ;
											x[nSRVPosRGB] = (cAliasSRC)->(RC_PD) 			;
											.And. 								  			;
											x[nPosParcel] = (cAliasSRC)->(RC_PARCELA) 		;
											.And. 								  			;
											( (Empty((cAliasSRC)->(RC_DTREF)) .OR. Empty(x[nPosDtRef])) .or. x[nPosDtRef] == (cAliasSRC)->(RC_DTREF) )		;
											.And. 								  			;
											(	x[nPosSeq] = (cAliasSRC)->(RC_SEQ) .OR.	;
												(									   		;
													"1" == AllTrim((cAliasSRC)->(RC_SEQ))	;
													.And.							   		;
													"" == AllTrim(x[nPosSeq])		   		;
												)									 		;
											)												;
										}													;
				   		)
    If cPaisLoc == "BRA" .And. nPosRGB > 0 .And. P_LRATINFO .And. cBFM == "I" .And. nTrans == 0 .And. cCampo == (cAliasSRC)->RC_PD .And. nPD > 0 .And. nPosTipo2 > 0 .And. aScan( aPerSeguinte, { |x| x[nPD] == (cAliasSRC)->RC_PD .And. x[nPosTipo2] == "I" } ) > 0
		If nAltReg == Len(aPerSeguinte) .And. aPerSeguinte[nAltReg, 1] == Nil //Apaga última posição criada e que não será utiliada
			aDel(aPerSeguinte, Len(aPerSeguinte))
			aSize(aPerSeguinte, Len(aPerSeguinte)-1)
		    lContinua  := .F.
		EndIf
    EndIf
Else
	nPosRGB		:= 0
EndIf

If lContinua
    //# Qdo a Parcela eh 99 buscar as Horas e o Valor do RGB
    nHorasGrv := (cAliasSRC)->RC_HORAS
    nValorGrv := (cAliasSRC)->RC_VALOR

    If (cAliasSRC)->RC_PARCELA = 99
        DbSelectArea("RGB")
        DbSetOrder(3)	// "RGB_FILIAL + RGB_PROCES + RGB_MAT +  RGB_PERIOD + RGB_SEMANA + RGB_PD + RGB_SEQ"
        If RGB->( DbSeek(xFilial("RGB") + cProcesso + (cAliasSRC)->( RC_MAT + RC_PERIODO + RC_SEMANA + RC_PD + RC_SEQ ), .F.) )
            nHorasGrv := RGB->RGB_HORAS
            nValorGrv := RGB->RGB_VALOR
        EndIf
    EndIf

    If cPaisLoc == "BRA"  .And. RetValSrv( (cAliasSRC)->RC_PD, (cAliasSRC)->RC_FILIAL, "RV_TIPOCOD" ) == "2" .And. cCampo == aCodFol[164,1] .And. (cAliasSRC)->RC_PD != aCodFol[232,1]
        nValorGrv *= (-1)
    EndIf

    For nField := 1 To nFields

        cField 		:= aSRCFields[nField, 1]
        nPos 		:= At("_", cField )

        If cField == (cPrefixo+"FILIAL")
            nPos := Ascan(aRGBFields,{|x| x[1] = "RGB_"+ Substr(cField ,nPos+1,06 )  }) //-- Procura campo correspondente no aRGB
            If nPosRGB == 0
                cConteudo	:= (cAliasSRC)->RC_FILIAL
            Else
                cConteudo	:= aValMSegRGB[nPosRGB, nPos]
            EndIf
            aPerSeguinte[nAltReg, nPos]	:= cConteudo
        ElseIf cField == (cPrefixo+"PD")
            nPos 						:= Ascan(aRGBFields,{|x| x[1] = "RGB_"+ Substr(cField ,nPos+1,06)  }) //-- Procura campo correspondente no aRGB
            aPerSeguinte[nAltReg, nPos] := cCampo
        ElseIf cField == (cPrefixo+"PERIODO")
            nPos 						:= Ascan(aRGBFields,{|x| x[1] = "RGB_"+ Substr(cField ,nPos+1,06 )  }) //-- Procura campo correspondente no aRGB
            aPerSeguinte[nAltReg, nPos] := cNextPer
        ElseIf cField == (cPrefixo+"SEMANA")
            nPos 						:= Ascan(aRGBFields,{|x| x[1] = "RGB_"+ Substr(cField ,nPos+1,06 )  }) //-- Procura campo correspondente no aRGB
            aPerSeguinte[nAltReg, nPos] := cNextPgto
        ElseIf cField == (cPrefixo+"PROCES")
            nPos 						:= Ascan(aRGBFields,{|x| x[1] = "RGB_"+ Substr(cField ,nPos+1,06 )  }) //-- Procura campo correspondente no aRGB
            aPerSeguinte[nAltReg, nPos] := cNextProc
        ElseIf cField == (cPrefixo+"ROTEIR")
            nPos	:= Ascan(aRGBFields,{|x| x[1] = "RGB_"+ Substr(cField ,nPos+1,06 )  }) //-- Procura campo correspondente no aRGB
            If Empty(cNextRot)
                aPerSeguinte[nAltReg, nPos] := (cAliasSRC)->RC_ROTEIR
            Else
                aPerSeguinte[nAltReg, nPos] := cNextRot
            EndIf
        ElseIf cField == (cPrefixo+"PARCELA")
            nPos	:= Ascan(aRGBFields,{|x| x[1] = "RGB_PARCEL" } ) //+ Substr(cField ,nPos+1,06 )  }) //-- Procura campo correspondente no aRGB
            If !Empty(nVInfoParc99)
                cConteudo := 0
            Else
                If nPosRGB == 0
                    If (cAliasSRC)->RC_PARCELA > 1
                        cConteudo	:= (cAliasSRC)->RC_PARCELA - nParcMenos
                    Else
                        cConteudo	:= 0
                    EndIf
                Else
                    cConteudo	:= aValMSegRGB[nPosRGB, nPos] - nParcMenos
                EndIf
            EndIf
            aPerSeguinte[nAltReg, nPos] := cConteudo
        ElseIf cField == (cPrefixo+"TIPO2")
            nPos	:= Ascan(aRGBFields,{|x| x[1] = "RGB_"+ Substr(cField ,nPos+1,06 )  }) //-- Procura campo correspondente no aRGB
            If nPosRGB == 0
                cConteudo	:= If((cAliasSRC)->RC_TIPO2 $ "CK","V", (cAliasSRC)->RC_TIPO2)
            Else
                cConteudo	:= aValMSegRGB[nPosRGB, nPos]
            EndIf
            aPerSeguinte[nAltReg, nPos] := cConteudo
        ElseIf cField == (cPrefixo+"DATA")
            nPos	:= Ascan(aRGBFields,{|x| x[1] = "RGB_DTREF"  }) //-- Procura campo correspondente no aRGB
            //--Gerar a Data para Compara‡Æo no calculo de IR
            If (aCodFol[106,1] == cCampo .Or. aCodFol[107,1] == cCampo) .And. aPdTrans[nTrans,2] != aPdTrans[nTrans,1]
                aPerSeguinte[nAltReg, nPos] := (cAliasSRC)->RC_DATA
            EndIf

            If lIrNeg .And. (aCodFol[1727,1] == cCampo ) .And. aPdTrans[nTrans,2] != aPdTrans[nTrans,1]
                aPerSeguinte[nAltReg, nPos] := (cAliasSRC)->RC_DATA
            EndIf
        ElseIf cField == (cPrefixo+"DTREF") .And. !( cCampo $ aCodFol[106,1] + "/" + aCodFol[107,1] + "/" + Iif(lIrNeg,aCodFol[1727,1],"" ) )
            nPos	:= Ascan(aRGBFields,{|x| x[1] = "RGB_"+ Substr(cField ,nPos+1,06 )  }) //-- Procura campo correspondente no aRGB
            //SE VERBA FOR DE DIFERENÇA DE FÉRIAS MANTÉM A DATA DE PAGAMENTO
            If (cAliasSRC)->RC_PD $ aCodFol[91,1] + "/" + aCodFol[93,1] + "/" + aCodFol[97,1] + "/" + aCodFol[99,1] + "/" + aCodFol[162,1] + "/" + aCodFol[207,1] + "/" + aCodFol[208,1] + "/" + aCodFol[1418,1] + "/" + aCodFol[1419,1] + "/" + aCodFol[89,1] + "/" + aCodFol[839,1]
                //Se estiver gerando a verba de pagamento mês anterior mantém a data atual
                If !( cCampo $ aCodFol[0164,1] + "/" + aCodFol[1449,1] ) .or. Empty(aPerSeguinte[nAltReg, nPos])
                    aPerSeguinte[nAltReg, nPos] := (cAliasSRC)->RC_DATA
                EndIf
            Else 
				If (cAliasSRC)->RC_TIPO2 $ "G*I" .and. RetValSRV((cAliasSRC)->RC_PD, SRA->RA_FILIAL, "RV_LCTODIA" ) != "S"
					aPerSeguinte[nAltReg, nPos] :=  cToD("//")
				Else 
                	aPerSeguinte[nAltReg, nPos] := If( !Empty((cAliasSRC)->RC_DTREF) , (cAliasSRC)->RC_DTREF , cToD("//"))
				EndIf
            EndIf
        ElseIf cField ==(cPrefixo+"SEQ")
            nPos	:= Ascan(aRGBFields,{|x| x[1] = "RGB_"+ Substr(cField ,nPos+1,06 )  }) //-- Procura campo correspondente no aRGB
            If nAltReg == 0
                aPerSeguinte[nAltReg, nPos] := cSeq
            Else
                If ValType( aPerSeguinte[nAltReg, nPos] ) == "U"
                aPerSeguinte[nAltReg, nPos] := cSeq
                EndIf
            EndIf
        ElseIf cField == (cPrefixo+"HORAS")
            nPos	:= Ascan(aRGBFields,{|x| x[1] = "RGB_"+ Substr(cField ,nPos+1,06 )  }) //-- Procura campo correspondente no aRGB
            If nPosRGB == 0
                //# Tratamento de Parcela 99 no RGB
                cConteudo := nHorasGrv
                If cCampo != aCodFol[164,1] .And. Iif( lVld1449, cCampo != aCodFol[1449,1], .T. ) .And. !Empty(aPerSeguinte[nAltReg, nPos])
                    cConteudo += aPerSeguinte[nAltReg, nPos]
                EndIf
            Else
                cConteudo := aValMSegRGB[nPosRGB, nPos]
            EndIf
            aPerSeguinte[nAltReg, nPos] := If(Empty(aPerSeguinte[nAltReg, nPos]), cConteudo, aPerSeguinte[nAltReg, nPos])
        ElseIf cField == (cPrefixo+"VALOR")
            cConteudo := 0
            nPos	:= Ascan(aRGBFields,{|x| x[1] = "RGB_"+ Substr(cField ,nPos+1,06 )  }) //-- Procura campo correspondente no aRGB
            /*
            ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
            ³ Verifica se devera somar o Valor do Inss Mes Seg. no Liquido das ferias ³
            ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
            // 164 - Ferias Pagas Mes Anterior // 232 - Inss Ferias Mes Seg.p/Desc. no Mes Corrente
            If cPaisLoc <> "URU" .And. cBFM == "F" .And. cCampo == aCodFol[164,1] .And. (cAliasSRC)->RC_PD == aCodFol[232,1]
                If PosSrv((cAliasSRC)->RC_PD, xFilial("SRV", (cAliasSRC)->RC_FILIAL), "RV_TIPOCOD") != "4"
                    If Empty( aPerSeguinte[nAltReg, nPos] )
                        If nPosRGB > 0
                            aPerSeguinte[nAltReg, nPos] := aValMSegRGB[nPosRGB, nPos] * (-1)
                        Else
                            aPerSeguinte[nAltReg, nPos] := (cAliasSRC)->RC_VALOR * (-1)
                        EndIf
                    Else
                        If nPosRGB > 0
                            aPerSeguinte[nAltReg, nPos] -= aValMSegRGB[nPosRGB, nPos]
                        Else
                            aPerSeguinte[nAltReg, nPos] -= (cAliasSRC)->RC_VALOR
                        EndIf
                    EndIf
                EndIf
            // 164 - Ferias Pagas Mes Anterior // 376 - BPS Ferias Mes Seguinte // 377 - IRP Ferias Mes Seguinte
            // 378 - FRL Ferias Mes Seguinte   // 379 - DISSE Ferias Mes Seguinte
            ElseIf cPaisLoc == "URU" .And. cBFM =="F" .And. cCampo == aCodFol[164,1] .And. ;
                ((cAliasSRC)->RC_PD == aCodFol[376,1] .or. (cAliasSRC)->RC_PD == aCodFol[377,1] .or.;
                (cAliasSRC)->RC_PD == aCodFol[378,1] .or. (cAliasSRC)->RC_PD == aCodFol[379,1])
                If Empty( aPerSeguinte[nAltReg, nPos] )
                    If nPosRGB > 0
                        aPerSeguinte[nAltReg, nPos] := aValMSegRGB[nPosRGB, nPos]
                    Else
                        aPerSeguinte[nAltReg, nPos] := (cAliasSRC)->RC_VALOR
                    EndIf
                Else
                    If nPosRGB > 0
                        aPerSeguinte[nAltReg, nPos] -= aValMSegRGB[nPosRGB, nPos]
                    Else
                        aPerSeguinte[nAltReg, nPos] -= (cAliasSRC)->RC_VALOR
                    EndIf
                EndIf
            Else
                If (cAliasSRA)->RA_TIPOPGT == "S" .And. cPaisLoc <> "URU"

                    /*
                    ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
                    ³Verifica Mes/Ano Para Gravacao da Base e do IR mes Anterior     ³
                    ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
                    // 106 - Rend. Bruto Ir. Anter.  // 107 - Desc. Ir. Anterior

                    If ( ( cCampo = aCodFol[106,1] .or. cCampo = aCodFol[107,1] ) .Or. (lIrNeg .And. (cCampo = aCodFol[1727,1]  )) ) .and.;
                        ( MesAno((cAliasSRC)->RC_DATA) > cMesAno .or. ( (cAliasSRA)->RA_CATFUNC $ "A*P" .and. (cAliasSRA)->RA_CATEG <> "15" .and. cNextPgto == "01" ) )

                        If ( (cAliasSRA)->RA_CATFUNC $ "A*P" .and. (cAliasSRA)->RA_CATEG <> "15" .and. cNextPgto == "01" )
                            If cCampo == aCodFol[107,1]
                                aPerSeguinte[nAltReg, nPos] := (cAliasSRC)->RC_VALOR + fGetValAnt((cAliasSRC)->RC_PD,(cAliasSRC)->RC_PERIODO, (cAliasSRC)->RC_ROTEIR, (cAliasSRC)->RC_SEMANA, AnoMes((cAliasSRC)->RC_DATA) )
                            Else
                                aPerSeguinte[nAltReg, nPos] := (cAliasSRC)->RC_VALOR
                            EndIf
                        Else
                            /*
                            ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
                            ³ Se a Data ja Gravada for maior que a Competencia, Soma o Valor.³
                            ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
                            If aPerSeguinte[nAltReg, nPosPeriod] <> Nil .and. aPerSeguinte[nAltReg, nPosPeriod] > cMesAno
                                If Empty( aPerSeguinte[nAltReg, nPos] )
                                    If nPosRGB > 0
                                        aPerSeguinte[nAltReg, nPos] := aValMSegRGB[nPosRGB, nPos]
                                    Else
                                        aPerSeguinte[nAltReg, nPos] := (cAliasSRC)->RC_VALOR
                                    EndIf
                                Else
                                    If nPosRGB > 0
                                        aPerSeguinte[nAltReg, nPos] += aValMSegRGB[nPosRGB, nPos]
                                    Else
                                        aPerSeguinte[nAltReg, nPos] += (cAliasSRC)->RC_VALOR
                                    EndIf
                                EndIf
                            Else
                                aPerSeguinte[nAltReg, nPos] := (cAliasSRC)->RC_VALOR
                            EndIf
                        EndIf

                    ElseIf cCampo = aCodFol[46,1]  .AND. cPaisLoc $ "ARG"   // Tratamento para INSUF. SALDO

                        If Empty( aPerSeguinte[nAltReg, nPos] )
                            If nPosRGB > 0
                                aPerSeguinte[nAltReg, nPos] := aValMSegRGB[nPosRGB, nPos]
                            Else
                                aPerSeguinte[nAltReg, nPos] := (cAliasSRC)->RC_VALOR
                            EndIf
                        Else
                            If nPosRGB > 0
                                aPerSeguinte[nAltReg, nPos] += aValMSegRGB[nPosRGB, nPos]
                            Else
                                aPerSeguinte[nAltReg, nPos] += (cAliasSRC)->RC_VALOR
                            EndIf
                        EndIf

                    Else
                        If Empty( aPerSeguinte[nAltReg, nPos] )
                            aPerSeguinte[nAltReg, nPos] := (cAliasSRC)->RC_VALOR
                        Else
                            aPerSeguinte[nAltReg, nPos] += (cAliasSRC)->RC_VALOR
                        EndIf
                    EndIf
                Else
                    If nPosRGB == 0
                        cConteudo := nValorGrv
                        If (cAliasSRC)->RC_PARCELA = 99
                            //# Tratamento de Parcela 99 no RGB
                            If !Empty(aPerSeguinte[nAltReg, nPos])
                                cConteudo += aPerSeguinte[nAltReg, nPos]
                            EndIf
                        ElseIf (cAliasSRC)->RC_PARCELA > 1 .And. Empty(nVInfoParc99)
                            If !Empty(aPerSeguinte[nAltReg, nPos])
                                cConteudo += (cAliasSRC)->RC_VALOR
                            EndIf
                        Else
                            If !Empty( aPerSeguinte[nAltReg, nPos] )
                                cConteudo += aPerSeguinte[nAltReg, nPos]
                            EndIf
                        EndIf
                    Else
                        cConteudo := aValMSegRGB[nPosRGB, nPos]
                    EndIf
                    aPerSeguinte[nAltReg, nPos] := cConteudo
                EndIf
            EndIf
        ElseIf cField == (cPrefixo+"VNAOAPL")
            nPos	:= Ascan(aRGBFields,{|x| x[1] = "RGB_VALOR"  }) //-- Procura campo correspondente no aRGB
            If (cAliasSRC)->RC_VNAOAPL > 0
                If nPos > 0 .AND. ( ( (cAliasSRC)->RC_PARCELA <= 1 ) .Or. ( (cAliasSRC)->RC_PARCELA > 1 .and. !Empty(nVInfoParc99) ) )
                    If nPosRGB > 0 .and. !lParcNoAplc
                        aPerSeguinte[nAltReg, nPos] := aValMSegRGB[nPosRGB, nPos]
                    Else
                        aPerSeguinte[nAltReg, nPos] := (cAliasSRC)->( &cField )
                    EndIf
                Else
                    If nPosRGB > 0 .and. !lParcNoAplc
                        aPerSeguinte[nAltReg, nPos] := aValMSegRGB[nPosRGB, nPos]
                    Else
                        aValMSegRGB[nPosRGB, nPos] := (cAliasSRC)->( &cField )
                    EndIf
                EndIf
            EndIf
        Else
            nPos	:= Ascan(aRGBFields,{|x| x[1] = "RGB_"+ Substr(cField ,nPos+1,06 )  }) 				//-- Procura campo correspondente no aRGB
            If !( cField == "RC_DTREF" .And. ( cCampo $ aCodFol[106,1] + aCodFol[107,1] + Iif(lIrNeg,aCodFol[1727,1] ,"" ) ) )
                If nPosRGB == 0
                    If nPos > 0
                        aPerSeguinte[nAltReg, nPos] := (cAliasSRC)->( &cField )
                    EndIf
                Else
                    If nPos > 0
                        aPerSeguinte[nAltReg, nPos] := aValMSegRGB[nPosRGB, nPos]
                    EndIf
                EndIf
            EndIf
        EndIf
    Next nField

    // Gerar flag para registros com movimentos em SRC
    // Os que nao tiverem sera gerado apos o While do SRC
    If nPosRGB > 0
        aValMSegRGB[nPosRGB, Len(aValMSegRGB[nPosRGB])] := "2"
    EndIf
EndIf

DbSelectArea(cAlias)

Return( Nil )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³fGravaTrans   ³Autor³Mauricio Takakura    ³ Data ³29/12/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Transferir do Array para o Arquivo SRC os lancamentos       ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³fGetTrans()                                                 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³ Vide Abaixo                                                ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³ Generico                                                   ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function fGravaTrans( aPerSeguinte, aFields)

Local cCampo
Local cOldAlias := Iif(Empty(Alias()), "SRF", Alias())

Local nItem
Local nItens
Local nField
Local nFields
Local cAliasAtu		:= "RGB"
Local cPrefixo		:= ( PrefixoCpo( cAliasAtu ) + "_" )
Local nFil
Local nMat
Local nCc
Local nPd
Local nPer
Local nSem
Local nSeq
Local nRot
Local nProc
Local cChave1
Local cProxSeq
Local nItemCt
Local nClvl
Local nParcel

nFields := Len( aFields )
nItens 	:= Len( aPerSeguinte )

For nField := 1 To nFields

	If aFields[nField,1] == cPrefixo +"FILIAL"
		nFil := nField
	ElseIf aFields[nField,1] == cPrefixo +"CC"
		nCc := nField
	ElseIf aFields[nField,1] == cPrefixo +"MAT"
		nMat := nField
	ElseIf aFields[nField,1] == cPrefixo +"SEQ"
		nSeq := nField
	ElseIf aFields[nField,1] == cPrefixo +"PERIOD" .Or. aFields[nField,1] == cPrefixo +"PERIODO"
		nPer := nField
	ElseIf aFields[nField,1] == cPrefixo +"SEMANA"
		nSem := nField
	ElseIf aFields[nField,1] == cPrefixo +"ROTEIR"
		nRot := nField
	ElseIf aFields[nField,1] == cPrefixo +"PROCES"
		nProc := nField
	ElseIf aFields[nField,1] == cPrefixo +"PD"
		nPd := nField
	ElseIf aFields[nField,1] == cPrefixo +"ITEM"
		nItemCt := nField
	ElseIf aFields[nField,1] == cPrefixo +"CLVL"
		nClvl := nField
	ElseIf aFields[nField,1] == cPrefixo +"PARCEL"
		nParcel := nField
	EndIf
Next nField

DbSelectArea( cAliasAtu )
DbSetOrder( nCrgOrdRGB )

cProxSeq := ""
For nItem := 1 To nItens

	//-Montagem da chave de busca
	cChave1 := aPerSeguinte[nItem,nFil]+aPerSeguinte[nItem,nProc]+aPerSeguinte[nItem,nMat]+aPerSeguinte[nItem,nPer]+aPerSeguinte[nItem,nSem]+aPerSeguinte[nItem,nRot]+aPerSeguinte[nItem,nPd]+aPerSeguinte[nItem,nCc]+aPerSeguinte[nItem,nItemCt]+aPerSeguinte[nItem,nClvl]

	//-- Verifica a existencia da chave no arquivo, se existir adiciona um na sequencia e volta para pesquisar
    If DbSeek(cChave1+cProxSeq)
		cProxSeq := Str(Val(cProxSeq)+1,1)
		nItem := nItem -1
		Loop
	EndIf
	RecLock(cAliasAtu, .T.)
	For nField := 1 To nFields
		cCampo := aFields[nField, 1]
		If cCampo == (cPrefixo+"TIPO2")
			(cAliasAtu)->(&cCampo)	:= If( ( aPerSeguinte[ nItem, nField ] $ "V|I" .And. aPerSeguinte[nItem,nParcel] == 0 ), "F", aPerSeguinte[ nItem, nField ] )	// Sempre o lancamento sera do tipo F - Fechamento
		ElseIf cCampo == (cPrefixo+"SEQ")
			(cAliasAtu)->(&cCampo)	:= cProxSeq  //Grava a sequencia correta
		Else
			(cAliasAtu)->( &cCampo) := aPerSeguinte[ nItem, nField ]
		EndIf
	Next nField

	RGB->RGB_CODFUN := SRA->RA_CODFUNC

	MsUnLock()
	cProxSeq := ""
Next nItem

DbSelectArea( cOldAlias )

Return( Nil )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³fGravaAcum    ³Autor³Equipe de RH         ³ Data ³16/02/1995³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Transfere os registros do SRC para SRD                   	³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³fGravaAcum( )                                      			³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³                 											³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³ Generico                                                   ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function fGravaAcum( cMesProc, cAnoProc, aSRCFields, cCriterio , cSequencia )

Local aArea			:= GetArea()
Local cKey			:= ( cAliasSRC )->(RC_FILIAL+RC_MAT+RC_CC+cAnoProc + cMesProc+RC_PD+RC_SEQ+RC_PERIODO+RC_SEMANA+RC_ROTEIR+DTOS(RC_DTREF)+if(lContrInt,RC_CONVOC,""))
Local nUltDia 		:= f_UltDia( CtoD("01/" + cMesProc + "/" + cAnoProc , "DDMMYY" ) )
Local nCposSRD		:= 0
Local nPosCpo		:= 0
Local lDSolQui		:= SRD->(FieldPos('RD_DSOLQUI')) > 0 //Nem todos os paises possuem o campo

DEFAULT cCriterio	:= ""
DEFAULT cSequencia  := ""

If lItemClvl
	cKey := ( cAliasSRC )->(RC_FILIAL+RC_MAT+RC_CC+RC_ITEM+RC_CLVL+cAnoProc + cMesProc+RC_PD+RC_SEQ+RC_PERIODO+RC_SEMANA+RC_ROTEIR+DTOS(RC_DTREF)+if(lContrInt,RC_CONVOC,""))
EndIf

DbSelectArea("SRD")
DbSetOrder(nOrderSRD)
//Faz a busca pois se estiver utilizando multi-thread e uma das threads der problema o rollback não sera feito nas demais threads e o registro ficara gravado
If DbSeek(cKey)
	RecLock("SRD", .F.)
Else
	RecLock("SRD", .T.)
EndIf

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Efetua preenchimento da tabela SRD buscando a SRC, filtrando ³
³ apenas pelo nome do campo. O tamanho, o tipo e o decimal nao ³
³ sao verificados pois tornaria o processo mais demorado, e    ³
³ ainda existem campos "iguais" no SRC e SRD (como os campos   ³
³ HORAS e HORINFO) que possuem tamanhos diferentes em cada uma ³
³ das tabelas.                                                 ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
For nCposSRD := 1 To Len(aSRDFields)
	If ( nPosCpo := aScan( aSRCFields, { |x| Substr( x[1], 4, Len(x[1]) - 3 ) == Substr( aSRDFields[nCposSRD,1], 4, Len(aSRDFields[nCposSRD,1]) - 3 ) } ) ) > 0
		If lDSolQui .And. aSRDFields[nCposSRD,1] == "RD_DSOLQUI"
			( cAliasSRD )->RD_DSOLQUI := ( cAliasSRC )->RC_DSOLQUI
		Else
			( cAliasSRD )->&( aSRDFields[nCposSRD,1] ) := ( cAliasSRC )->&( aSRCFields[nPosCpo,1] )
		EndIf
	Else
		Do Case
			Case aSRDFields[nCposSRD,1] == "RD_DATARQ"
				( cAliasSRD )->RD_DATARQ	:= cAnoProc + cMesProc
			Case aSRDFields[nCposSRD,1] == "RD_DATPGT"
				( cAliasSRD )->RD_DATPGT	:= If( Empty( ( cAliasSRC )->RC_DATA ), CtoD( StrZero( nUltDia, 2 ) + "/" + cMesProc + "/" + cAnoProc, "DDMMYY" ), ( cAliasSRC )->RC_DATA )
			Case aSRDFields[nCposSRD,1] == "RD_MES"
				( cAliasSRD )->RD_MES		:= cMesProc
			Case aSRDFields[nCposSRD,1] == "RD_STATUS"
				( cAliasSRD )->RD_STATUS	:= "A"
			Case aSRDFields[nCposSRD,1] == "RD_INSS"
				( cAliasSRD )->RD_INSS		:= RetValSrv( ( cAliasSRC )->RC_PD, ( cAliasSRC )->RC_FILIAL, "RV_INSS" )
			Case aSRDFields[nCposSRD,1] == "RD_IR"
				( cAliasSRD )->RD_IR		:= RetValSrv( ( cAliasSRC )->RC_PD, ( cAliasSRC )->RC_FILIAL, "RV_IR" )
			Case aSRDFields[nCposSRD,1] == "RD_FGTS"
				( cAliasSRD )->RD_FGTS		:= RetValSrv( ( cAliasSRC )->RC_PD, ( cAliasSRC )->RC_FILIAL, "RV_FGTS" )
		EndCase
	EndIf
Next nCposSRD

( cAliasSRD )->RD_CRITER	:= cCriterio
( cAliasSRD )->RD_SEQUE		:= cSequencia

//--Ponto de Entrada para gravar campos do usuario
If ExistBlock("GP120INC")
	EXECBLOCK("GP120INC",.F.,.F.)
Endif
MsUnLock()

If SRV->(FieldPos('RV_LANCPCO')) > 0 .And. !Empty(SRV->RV_LANCPCO) //Nem todos os paises possuem o campo
	PcoDetLan("000085", SRV->RV_LANCPCO, "GPEM120")
EndIf

//--Ponto de Entrada para gravar campos do usuario fora do Reclock
If ExistBlock("GP120CMP")
	EXECBLOCK("GP120CMP",.F.,.F.)
EndIf

RestArea(aArea)

Return( Nil )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³GetValFuturo  ³Autor³Mauricio Takakura    ³ Data ³06/01/2005³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Pegar os valores da tabela SRK - Valores Futuros         	³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³GetValFuturo												³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³                 											³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³                                                            ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
Static Function GetValFuturo( cFilSRA, aValFutSRK, aNextPer, aNextComp )

Local cField
Local cVerba
Local cCC			:= ""
Local dDataPer
Local lNotNumID		:= .F.			// Possui NUMID para controle de Valores Futuros
Local lPdJuros 		:= .F.			// Se o lancamento pertence a juros
Local lEmpCons 		:= .F.			// Se o lancamento e' referente a emprestimo consignado
Local lRateio		:= .F.
Local lFrete		:= .F.
Local lSuspECon		:= .F.
Local nX
Local nValor
Local nParcela
Local nSldValor
Local nSldParc
Local nFound 		:= 0
Local nPosPd
Local nPosPdJuros
Local nPosNumID
Local nPosDtVenc
Local nPosParcPag
Local nPosParcela
Local nPosVlrParc
Local nPosVlrPago
Local nPosValorTo
Local nPosVlSaldo
Local nPosVlNaoAp
Local nPosJuroMes
Local nPosQuitar
Local nPosVlRar
Local nPosReg
Local nFields
Local nPosSRK
Local nPosNrCtr     := 0
Local nPosCFGTS     := 0
Local nPosBcCon     := 0
Local nPosSts		:= 0
Local nParcECon     := 0
Local nQtdParPg  	:= 0
Local nValEmpr      := 0 
Local nTotParc      := 0
Local nValorAux		:= 0

Static aSRKAux		:= {}

DEFAULT aValFutSRK := {}
DEFAULT aNextPer   := {}
DEFAULT aNextComp  := {}

nPosPd 		:= aScan( aSRKFields,{ |x| x[1] ==  "RK_PD" } )
nPosPdJuros	:= aScan( aSRKFields,{ |x| x[1] ==  "RK_PDJUROS" } )
nPosDtVenc 	:= aScan( aSRKFields,{ |x| x[1] ==  "RK_DTVENC" } )

If Empty( aAllSRK ) .AND. !lAllSRK

	lAllSRK := .T.

	DbSelectArea( cAliasSRK )
	SRK->( DbSetOrder( nGVFOrdSRK ) )	// RK_FILIAL + RK_MAT + RK_PD + DtoS(RK_DTMOVI)

	nFields := Len( aSRKFields )

	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Transferir todas os lancamentos do funcionario em aberto para³
	³ o array. Evitar acessos constantes ao banco de dados.        ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	If ( cAliasSRK )->( dbSeek( cFilSRA+(cAliasSRA)->RA_MAT) )
		While ( cAliasSRK )->( !Eof() ) .and. ( cAliasSRK )->RK_FILIAL == cFilSRA .and. ( cAliasSRK )->RK_MAT == (cAliasSRC)->RC_MAT

			If (cAliasSRK)->RK_VLSALDO <> 0 .Or. (cAliasSRK)->RK_VLRPAGO < (cAliasSRK)->RK_VALORTO .Or. (cPaisLoc == "BRA" .And. (cAliasSRK)->RK_TIPO == "P")
				aAdd( aAllSRK, {} )
				nPosReg := Len( aAllSRK )

				For nX := 1 To nFields
					cField := (caliasSRK) + "->" + aSRKFields[ nX, 1 ]
					aAdd( aAllSRK[ nPosReg ], &( cField ) )
				Next nX

				aAdd( aAllSRK[ nPosReg ], (cAliasSRK)->( Recno() ) )
				aAdd( aAllSRK[ nPosReg ], 0)

			EndIf

			( cAliasSRK )->( DbSkip() )

		EndDo
	EndIf
	aSort( aAllSRK,,, { |x, y| x[nPosPd]+DtoS(x[nPosDtVenc]) < y[nPosPd] + DtoS( y[nPosDtVenc] ) } )

EndIf 

If cPaisLoc == "BRA"
	lEmpCons	:= ( RetValSrv(( cAliasSRC )->RC_PD, ( cAliasSRC )->RC_FILIAL, "RV_EMPCONS") == "1" ) 
EndIf
lNotNumID	:= If(!lEmpCons, Empty( (cAliasSRC)->RC_NUMID ), .T.)
nPosNumID := aScan( aSRKFields,{ |x| x[1] ==  "RK_NUMID" } )

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ A baixa de Juros soh poderar ocorrer se existir Nro. de ID   ³
³ senao sera considerado um lancamento informado.              ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
//--Quando tem identificacao do ID
If !lNotNumID
	nFound := aScan( aAllSRK, { |x| AllTrim(x[nPosNumID]) == AllTrim((cAliasSRC)->RC_NUMID)  } )
	If nFound == 0 .And. cPaisLoc != "MEX"
		nFound := aScan( aAllSRK, { |x| x[nPosPd] == (cAliasSRC)->RC_PD  } )
	EndIf
//Se nao tiver ID e nao for Mexico baixar pelo codigo da verba apenas se não existir NUMID na SRK.
Else
	If cPaisLoc # "MEX"
		nFound := aScan( aAllSRK, { |x| x[nPosPd] == (cAliasSRC)->RC_PD .And. ( Empty(x[nPosNumID]) .Or. AllTrim(x[nPosNumID]) == AllTrim((cAliasSRC)->RC_NUMID) .Or. SRA->RA_SITFOLH == "D" ) } )
	EndIf
EndIf

cVerba := (cAliasSRC)->RC_PD

//Tratamento para autonomo fretista pois as verbas foram desmembradas
If nFound == 0 .and. (cAliasSRA)->RA_CATFUNC $ "A*P" .and. (cAliasSRA)->RA_CATEG == "15" .and. cTpRoteir == "9" .and. (cAliasSRC)->RC_PD $ aCodFol[1563,1] + "/" + aCodFol[1564,1] + "/" + aCodFol[1565,1]
	nFound := aScan( aAllSRK, { |x| x[nPosPd] == aCodFol[218,1]  } ) //Verifica se houve lançamento de verba para autonomo nos lançamentos futuros
	If nFound > 0
		cVerba := aCodFol[218,1]
		lFrete := .T.
	EndIf
EndIf

If nFound > 0

	nValor		:= ( cAliasSRC )->RC_VALOR
	nValorAux   := nValor
	nParcela	:= If( ( cAliasSRC )->RC_PARCELA > 0, ( cAliasSRC )->RC_PARCELA , 1)
	nSldValor	:= 0
	nSldParc 	:= 0

	nPosParcPag := aScan( aSRKFields,{ |x| x[1] ==  "RK_PARCPAG" } )
	nPosParcela := aScan( aSRKFields,{ |x| x[1] ==  "RK_PARCELA" } )
	nPosVlrParc := aScan( aSRKFields,{ |x| x[1] ==  "RK_VALORPA" } )
	nPosVlrPago := aScan( aSRKFields,{ |x| x[1] ==  "RK_VLRPAGO" } )
	nPosValorTo := aScan( aSRKFields,{ |x| x[1] ==  "RK_VALORTO" } )
	nPosVlSaldo := aScan( aSRKFields,{ |x| x[1] ==  "RK_VLSALDO" } )
	nPosPgJuros := aScan( aSRKFields,{ |x| x[1] ==  "RK_PGJUROS" } )
	nPosVlJuros := aScan( aSRKFields,{ |x| x[1] ==  "RK_VLJUROS" } )
	nPosVlNaoAp := aScan( aSRKFields,{ |x| x[1] ==  "RK_VNAOAPL" } )
	nPosJuroMes := aScan( aSRKFields,{ |x| x[1] ==  "RK_JUROMES" } )
	nPosQuitar  := aScan( aSRKFields,{ |x| x[1] ==  "RK_QUITAR"  } )
	nPosVlRar   := aScan( aSRKFields,{ |x| x[1] ==  "RK_VALORAR" } )
	nPosNumID 	:= aScan( aSRKFields,{ |x| x[1] ==  "RK_NUMID"   } )
	nPosNrCtr   := aScan( aSRKFields,{ |x| x[1] ==  "RK_NRCONTR" } )
	nPosCFGTS   := aScan( aSRKFields,{ |x| x[1] ==  "RK_CONSFGT" } )
	nPosBcCon   := aScan( aSRKFields,{ |x| x[1] ==  "RK_BCOCONS" } )
	nPosSts     := aScan( aSRKFields,{ |x| x[1] ==  "RK_STATUS"  } )

	For nX := nFound To Len( aAllSRK )
		lRateio   := lSuspECon := .F.
		nQtdParPg := nParcECon := nValEmpr := nTotParc := 0
		If lItemClvl
			cCC := (cAliasSRC)->RC_CC+(cAliasSRC)->RC_ITEM+(cAliasSRC)->RC_CLVL
		Else
			cCC := (cAliasSRC)->RC_CC
		EndIf

		lPdJuros := .F.
		If aAllSRK[ nX, nPosPdJuros ] == cVerba
			lPdJuros := .T.
		EndIf

		If ! lPdJuros .And. aScan( aValFutSRK, { |x| ( ( !Empty(aAllSRK[ nX, nPosNumID ]) .And. x[2] == aAllSRK[ nX, nPosNumID ] .And. x[1] == aAllSRK[ nX, nPosPd ]) .or. (Empty(aAllSRK[ nX, nPosNumID ]) .And. x[1] == aAllSRK[ nX, nPosPd ]) ) .And. Alltrim(cCC) == Alltrim(x[10]) }) > 0
			If lFrete .or.  (cAliasSRA)->RA_SITFOLH == "D" //Se estiver demitido pode existir mais de uma verba igual na rescisão.
				lRateio := .T.
			Else
				Loop
			EndIf
		EndIf

		If aScan( aValFutSRK, { |x| ( x[2] == aAllSRK[ nX, nPosNumID ] .And. Alltrim(cCC) <> Alltrim(x[10]) ) .or. ((cAliasSRA)->RA_SITFOLH == "D" .and. Empty(aAllSRK[ nX, nPosNumID ]) .and.  x[1] == aAllSRK[ nX, nPosPd ] ) }) > 0
			lRateio := .T.
		EndIf

		If aAllSRK[ nX, nPosPd ] != cVerba .And. aAllSRK[ nX, nPosPdJuros ] != cVerba
			Exit
		EndIf

		If lFrete

			nPosSRK := aScan(aSRKAux, {|x| x[1] == aAllSRK[nX, nPosNumID]})

			//Se a data de vencimento original for maior que a data de pagamento, lançamento não foi calculado, logo, não deve ser atualizado
			If nPosSRK == 0 .and. aAllSRK[nX, nPosDtVenc] > (cAliasSRC)->RC_DATA
				Loop 
			EndIf

			If nPosSRK == 0 
				aAdd(aSRKAux, {aAllSRK[nX, nPosNumID],aAllSRK[nX, nPosDtVenc]})
			EndIf

		EndIf

		If !lPdJuros

			If cPaisLoc <> "MEX" .And. !lEmpCons
				/*
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Calcular o Valor ja Pago                                     ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
				If ( aAllSRK[nX, nPosVlrPago] + nValor ) > aAllSRK[nX, nPosValorTo]  .And. (cPaisLoc == "BRA") 
					nSldValor := nValor - ( aAllSRK[nX, nPosValorTo] - aAllSRK[nX, nPosVlrPago] )
					nValor := ( aAllSRK[nX, nPosValorTo] - aAllSRK[nX, nPosVlrPago] )
				EndIf

				/*
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Validar o Valor do Saldo                                     ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
				If aAllSRK[nX, nPosVlSaldo] > 0 .And. aAllSRK[nX, nPosVlSaldo] < nValor
					nSldValor += nValor - aAllSRK[nX, nPosVlSaldo]
					nValor := aAllSRK[nX, nPosVlSaldo]
				EndIf
			ElseIf lEmpCons
				If aAllSRK[nX, nPosQuitar] == "1" .Or. SRA->RA_SITFOLH == "D"
					nValor := ( aAllSRK[nX, nPosVlrParc] * aAllSRK[nX, nPosParcela] ) - aAllSRK[nX, nPosVlrPago] + aAllSRK[nX, nPosVlRar]
				Else
					nValor := aAllSRK[nX, nPosVlrParc]  * nParcela
				EndIf
			EndIf
			If !lRateio
				aAllSRK[nX, nPosParcPag] += nParcela
			EndIf
			aAllSRK[nX, nPosVlrPago] += nValor
			If aAllSRK[nX, nPosVlSaldo] > 0
				aAllSRK[nX, nPosVlSaldo] -= nValor
			Else
				aAllSRK[nX, nPosVlSaldo] := aAllSRK[nX, nPosValorTo] - aAllSRK[nX, nPosVlrPago]
			EndIf
			If lCpoNPgto .And. aAllSRK[nX, nPosCFGTS] == "1" 
				aAllSRK[nX, Len(aSRKFields)+2] += nValorAux
			EndIf
		Else

			nParcela := 0

			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Calcular o Valor ja Pago                                     ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			If ( aAllSRK[nX, nPosPgJuros] + nValor ) > aAllSRK[nX, nPosVlJuros]
				nValor := ( aAllSRK[nX, nPosVlJuros] - aAllSRK[nX, nPosPgJuros] )
			EndIf

			If !lRateio
				aAllSRK[nX, nPosParcPag] += nParcela
			EndIf
			aAllSRK[nX, nPosPgJuros] += nValor

        EndIf

		If aAllSRK[nX, nPosVlSaldo] <> 0
			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Verificar de qual periodo jogar a data                       ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			If PosSrv( cVerba , (cAliasSRC)->RC_FILIAL, "RV_FECCOMP") == "1"
				If aNextComp[1,11]
					If cPaisLoc == "MEX"
						dDataPer := aNextComp[1,9] // considerar data inicial do periodo
					Else
			   			dDataPer := aNextComp[1,8]
			  		EndIf
			 	Else
			 		dDataPer := MonthSum( aNextComp[1,8], 1 )
			 	EndIf
			Else
				If aNextPer[1,11]
					If cPaisLoc == "MEX"
						dDataPer := aNextPer[1,9]
					Else
						dDataPer := aNextPer[1,8]
					EndIf
				Else
					dDataPer := MonthSum( aNextComp[1,8], 1 )
				EndIf
			EndIf
			aAllSRK[nX, nPosDtVenc] := If( !Empty(dDataPer), dDataPer, fDtMesSeg( aAllSRK[nX, nPosDtVenc] ) )
		EndIf

		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Se tem valor nao aplicado, e nao gera novo registro no SRC   ³
		³ Caso contrario zera o valor nao aplicado					   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			If ( cPaisLoc $ "MEX|DOM|COS|CHI|PAR" .and. !lModPadrao )
				If ( (cAliasSRC)->RC_VNAOAPL > 0 )
					aAllSRK[ nX, nPosVlNaoAp ] := (cAliasSRC)->RC_VNAOAPL
				Else
					aAllSRK[ nX, nPosVlNaoAp ] := 0
				EndIf
			EndIf
			If ( cPaisLoc $ "CHI" )
			If ( (cAliasSRC)->RC_VNAOAPL > 0 )
				aAllSRK[ nX, nPosVlNaoAp ] := (cAliasSRC)->RC_VNAOAPL
			Else
				aAllSRK[ nX, nPosVlNaoAp ] := 0
			EndIf
		EndIf

		If lVerRUO .And. aAllSRK[nX, nPosCFGTS] == "1" .And. !lRateio .And. aNextPer[1, 11] 
			If fEConsRUO(cVerba, aNextPer[1, 6] + aNextPer[1, 7], aAllSRK[nX, nPosNrCtr], aAllSRK[nX, nPosBcCon], @nQtdParPg, @nParcECon, @nValEmpr, @nTotParc)
				aAllSRK[nX, nPosParcPag] := Max(aAllSRK[nX, nPosParcPag], nQtdParPg)
				aAllSRK[nX, nPosVlrParc] := nParcECon
				aAllSRK[nX, nPosValorTo] := nValEmpr
				aAllSRK[nX, nPosVlSaldo] := nValEmpr - aAllSRK[nX, nPosVlrPago]
				aAllSRK[nX, nPosParcela] := nTotParc
			Else 
				lSuspECon := .T.	
			EndIf  
		EndIf 

		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Posicao dos arrays a serem gravados na tabela.               ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		If !lRateio
			aAdd( aValFutSRK, { cVerba					,;
								aAllSRK[ nX, nPosNumID ],;
								(cAliasSRC)->RC_DATA	,;
								nValor 					,;
								(cAliasSRC)->RC_PARCELA ,;
								(cAliasSRC)->RC_PERIODO ,;
								(cAliasSRC)->RC_SEMANA 	,;
								(cAliasSRC)->RC_ROTEIR	,;
								nX						,;
								cCC					    ,;
								lSuspECon } )
		Else
			aValFutSRK[Len(aValFutSRK)][4] += nValor
		EndIf
		If (nSldValor == 0 .And. nValor == 0 ).Or. !lNotNumID
			Exit
		EndIf
		nValor 	 := If(nSldValor > 0, nSldValor, nValor)
		nParcela := If(nSldParc > 0, nSldParc, nParcela)
	Next nX

EndIf

Return ( Nil )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³GrvValFuturo  ³Autor³Mauricio Takakura    ³ Data ³28/12/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Atualizar a Tabela SRK - Valores Futuros                 	³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³GrvValFuturo												³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³                 											³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³                                                            ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
Quando o usuario incluir a opcao de gravacao do campo NUMID na formula, o sistema devera realizar a busca atraves
deste campo agilizando o fechamento. Quando o campo estiver vazio, varrer a tabela e localizar o registro para
atualizacao.
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ*/
Static Function GrvValFuturo( cFilSRA, aValFutSRK )

Local lPDJuros

Local nSeq
Local nItens		:= 0
Local nPosArray
Local nPosRecno
Local nPosNumID
Local nPosDtVenc
Local nPosParcPag
Local nPosVlrPago
Local nPosVlSaldo
Local nPosPgJuros
Local nPosVlNaoAp
Local nPosJuroMes
Local nPosPdJuros
Local nValNPgto
Local lCpoPDJUROS := SRK->(ColumnPos("RK_PDJUROS") > 0)

DEFAULT cFilSRA 	:= xFilial( "SRA" )
DEFAULT aValFutSRK 	:= {}

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Filtrar o array para iniciar as baixas pelos registros com   ³
³ NUMID.                                                       ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
aSort( aValFutSRK,,, { |x, y| x[2] < y[2] } )

nPosPd		:= aScan( aSRKFields,{ |x| x[1] ==  "RK_PD" } )
nPosParcPag := aScan( aSRKFields,{ |x| x[1] ==  "RK_PARCPAG" } )
nPosVlrPago := aScan( aSRKFields,{ |x| x[1] ==  "RK_VLRPAGO" } )
nPosVlSaldo := aScan( aSRKFields,{ |x| x[1] ==  "RK_VLSALDO" } )
nPosDtVenc 	:= aScan( aSRKFields,{ |x| x[1] ==  "RK_DTVENC" } )
nPosNumID	:= aScan( aSRKFields,{ |x| x[1] ==  "RK_NUMID" } )
nPosPGJuros := aScan( aSRKFields,{ |x| x[1] ==  "RK_PGJUROS" } )
nPosVlNaoAp := aScan( aSRKFields,{ |x| x[1] ==  "RK_VNAOAPL" } )
nPosJuroMes := aScan( aSRKFields,{ |x| x[1] ==  "RK_JUROMES" } )
nPosPdJuros := aScan( aSRKFields,{ |x| x[1] ==  "RK_PDJUROS" } )

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Transferir do array para a tabela no banco de dados.         ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
For nItens := 1 To Len( aValFutSRK )

	nPosArray := aValFutSRK[ nItens, 9 ]
	nPosRecno := aAllSRK[ nPosArray, Len( aSRKFields )+1 ]
	nValNPgto := aAllSRK[ nPosArray, Len( aSRKFields )+2 ]
	SRK->( DbGoTo( nPosRecno ) )

    lPDJuros := (lCpoPDJUROS .And. !(aValFutSRK[ nItens, 1 ] == SRK->( RK_PD )))
	RecLock( "SRK", .F. )
	If !lPDJuros
		SRK->RK_PARCPAG := aAllSRK[ nPosArray, nPosParcPag ]
		SRK->RK_VLRPAGO := aAllSRK[ nPosArray, nPosVlrPago ]
		SRK->RK_VLSALDO := aAllSRK[ nPosArray, nPosVlSaldo ]
		SRK->RK_DTVENC 	:= aAllSRK[ nPosArray, nPosDtVenc  ]
		If ( FieldPos("RK_VNAOAPL") > 0 )  //Campo nao utilizado em todos os paises
			SRK->RK_VNAOAPL := aAllSRK[ nPosArray, nPosVlNaoAp ]
		EndIf
		If cPaisLoc == "COL"
			SRK->RK_DTVENC := _dTPagNexP
		EndIf
	Else
		SRK->RK_PGJUROS := aAllSRK[ nPosArray, nPosPgJuros ]
	EndIf

	If SRK->RK_VLSALDO <= 0 .OR. (SRK->RK_VLJUROS > 0 .AND. SRK->RK_PGJUROS >= SRK->RK_VLJUROS)
		SRK->RK_STATUS := "3"
        If ( cPaisLoc == "MEX" )
			SRK->RK_VALPARE := 0
   		EndIf
 	EndIf

	//Suspende quando não tem próxima parcela na RUO para o eConsignado
	If aValFutSRK[nItens, 11] .And. SRK->RK_VLSALDO > 0
		SRK->RK_STATUS := "4"
	EndIf 

	MsUnLock()

    /*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Pegar a sequencia do registro em RCK                         ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	DbSelectArea( "RCK" )
	DbSetOrder( nGRVVFRCK )
	DbSeek( SRK->RK_FILIAL + (cAliasSRA)->RA_MAT + aAllSRK[ nPosArray, nPosNumID ], .F.)
	nSeq := 1
	While RCK->( !Eof() ) .and. RTrim(RCK->( RCK_FILIAL+RCK_MAT+RCK_NUMID )) == RTrim(SRK->RK_FILIAL + (cAliasSRA)->RA_MAT + aAllSRK[ nPosArray, nPosNumID ])
		nSeq++
		//Atualiza o status de todos os registros da RCK
		If cPaisLoc == "BRA" 
			RecLock( "RCK", .F. )
				RCK->RCK_STATUS := SRK->RK_STATUS
			MsUnLock()
		EndIf
		RCK->( DbSkip() )
	EndDo

  	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Gerar o Registro em RCK - Valores Pagos                      ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	RecLock( "RCK", .T. )
	RCK->RCK_FILIAL := (cAliasSRA)->RA_FILIAL
	RCK->RCK_MAT 	:= (cAliasSRA)->RA_MAT
	RCK->RCK_PD		:= SRK->RK_PD
	If lPDJuros
		RCK->RCK_PDJURO := SRK->RK_PDJUROS
	EndIf
	RCK->RCK_STATUS := SRK->RK_STATUS	// Ativo
	RCK->RCK_POSTO	:= (cAliasSRA)->RA_POSTO
	RCK->RCK_PARCPG := SRK->RK_PARCPAG
	RCK->RCK_QTDEPG := If(aValFutSRK[nItens, 5] > 0, aValFutSRK[nItens, 5], 1)
	RCK->RCK_VLPAGO	:= aValFutSRK[nItens, 4]
	RCK->RCK_DTPAGO := aValFutSRK[nItens, 3]
	RCK->RCK_PXVCTO := SRK->RK_DTVENC
	RCK->RCK_PER	:= aValFutSRK[nItens, 6]
	RCK->RCK_NUMPAG	:= aValFutSRK[nItens, 7]
	RCK->RCK_CALCUL	:= aValFutSRK[nItens, 8]
	RCK->RCK_USUARI := UsrRetName(RetCodUsr())
	RCK->RCK_DTALTE := MsDate()
	RCK->RCK_SEQUEN := nSeq
	RCK->RCK_NUMID  := aValFutSRK[nItens, 2]
	If cPaisLoc == "COS"
		RCK->RCK_REFERE := SRK->RK_DOCUMEN
	EndIf
	If lCpoNPgto .And. nValNPgto > 0 .And. nValNPgto < aValFutSRK[nItens, 4]
		RCK->RCK_NPAG := aValFutSRK[nItens, 4] - nValNPgto
	EndIf
	MsUnLock()

	If ExistBlock("GP120PRE")
		ExecBlock("GP120PRE",.F.,.F.)
	EndIf

Next nItens

Return( Nil )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³GetSR8        ³Autor³Mauricio Takakura    ³ Data ³08/06/2005³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Tratamento para os afastamento e Ferias                  	³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³GetSR8        												³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³                 											³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³ Gpem120                                                    ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
Static Function GetSR8( cFilSRA, aValSR8, lFerias )

Local aArea			:= GetArea()
Local aSR8Filter 	:= {}

Local cField        := ""
Local cPdFerias		:= ""
Local cPdFerProp	:= ""
Local cTipoAfa      := ""

Local cOrder		:= ""
Local cWhere		:= ""
Local cFromTable	:= ""
Local cCampoMat
Local cPerAfast		:= ""

Local dDataIni
Local dDataFim

Local lNotNumID		:= .F.
Local lDiasPer		:= GetMvRH("MV_DIASPER",,"1") == "1"
Local lProvPMes     := cPaisLoc == "BRA" .and. GetMvRH("MV_RATPROV",,"N") == "S"
       
Local nX
Local nValor
Local nValorAux
Local nValPago
Local nFields
Local nPosReg
Local nPosPd
Local nPosPdInteg
Local nDiasAux
Local nDiasPagos	:= 0
Local nFound		:= 0
Local nPosDRever 	:= 0
Local nValorFer 	:= 0
Local nPosNumID
Local nPosTPAfa
Local nSldValor
Local nPosStatus
Local nPosDPagos
Local nPosVlPago
Local nPosSdPagar
Local nPosDataIni
Local nPosValor
Local nPosDataFim
Local nUltDia		:= 0
Local nDayRetAfa	:= 0
Local nBkpSaldo		:= 0
Local nPosDPgMes	:= 0

Private aRateio	:= {}

DEFAULT aValSR8 := {}
DEFAULT lFerias := .F.	// Tratamento de ferias para o Brasil

cCampoMat := IIf(lFerias, (cAliasSRA)->RA_MAT , (cAliasSRC)->RC_MAT )

nPosPd 		:= aScan( aSR8Fields,{ |x| x[1] ==  "R8_PD" } )
nPosPdInteg	:= aScan( aSR8Fields,{ |x| x[1] ==  "R8_VRBINT" } )
nPosDataIni := aScan( aSR8Fields,{ |x| x[1] ==  "R8_DATAINI" } )
nPosDataFim := aScan( aSR8Fields,{ |x| x[1] ==  "R8_DATAFIM" } )
nPosValor 	:= aScan( aSR8Fields,{ |x| x[1] ==  "R8_VALOR" } )
nPosTPAfa 	:= aScan( aSR8Fields,{ |x| x[1] ==  "R8_TIPOAFA" } )
nFields 	:= Len( aSR8Fields )

If Empty( aAllSR8 ) .AND. !lAllSR8 .Or. lFerias

	lAllSR8 := .T.
	cAliasSR8 := IIf( Substr(cAliasSR8,1,1) == "Q", Substr(cAliasSR8,2), cAliasSR8 )
	DbSelectArea(cAliasSR8)
	SR8->(DbSetOrder(nOrdGetSR8)) 	//R8_FILIAL + R8_MAT+DtoS(R8_DATAINI)+R8_TIPOAFA+STR(R8_DIASEMP)
	If SR8->( DbSeek(cFilSRA + (cAliasSRA)->RA_MAT) )
		cWhere := "%"
		If !(cPaisLoc $ "MEX|COS|DOM")
			If Empty( aSR8Filter )
				cWhere += " SR8.R8_FILIAL = '" + cFilSRA + "' AND "
				cWhere += " SR8.R8_MAT    = '" + (cAliasSRA)->RA_MAT + "' AND "

				If !lFerias
					cWhere += " ( SR8.R8_SDPAGAR > 0 OR SR8.R8_DPAGAR <> SR8.R8_DPAGOS ) AND "
				Else
					If cPaisLoc == "COL"
						cWhere += " SR8.R8_PD IN ('" + aCodFol[72,1] + "','" +aCodFol[1241,1]+ "') AND "
					Else
						If cPaisLoc == "BRA"
							If (cAliasSRA)->RA_CATFUNC $ "E*G"   // Estagiario Mensalista/Horista
								cWhere += " SR8.R8_PD = '" + aCodFol[891,1] + "' AND "
							Else
								cWhere += " SR8.R8_PD = '" + aCodFol[72,1] + "' AND "
							EndIf
						Else
							cWhere += " SR8.R8_PD = '" + aCodFol[72,1] + "' AND "
						EndIf
					EndIf
				EndIf

			EndIf
		Else
			cWhere += " SR8.R8_FILIAL = '" + cFilSRA + "' AND "
			cWhere += " SR8.R8_MAT    = '" + (cAliasSRA)->RA_MAT + "' AND "
			cWhere += " ( SR8.R8_SDPAGAR <> 0 OR SR8.R8_DPAGAR <> SR8.R8_DPAGOS ) AND "
		EndIf
		cWhere += "%"

		cAliasSR8 := "Q" + cAliasSR8
		If ( SELECT(cAliasSR8) > 0 )
			(cAliasSR8)->(dbCloseArea())
		EndIf

		cOrder := "% SR8.R8_FILIAL, SR8.R8_MAT %"

		cFromTable := "% " + cNamSR8Tab + " SR8 %"

		BeginSql alias cAliasSR8
			column R8_DATA as Date, R8_DATAINI as Date, R8_DATAFIM as Date
			SELECT
					%exp:cFieldsSR8%
			FROM
					%exp:cFromTable%
			WHERE
					%exp:cWhere%
					SR8.%NotDel%
			ORDER BY
					%exp:cOrder%
		EndSql

		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Transferir todas os lancamentos do funcionario em aberto para o array.³
		³ Evitar acessos constantes ao banco de dados.                          ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		While ( cAliasSR8 )->( !Eof() ) .and. ( cAliasSR8 )->R8_FILIAL == cFilSRA .and. ( cAliasSR8 )->R8_MAT == cCampoMat

			cTipoAfa := PosAlias( "RCM", (cAliasSR8)->R8_TIPOAFA, xFilial( "RCM" ), "RCM_TIPOAF", 1 )

			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Ausencia do tipo ferias deve pertencer ao periodo corrente.           ³
			³ Ausencia que nao seja ferias deve possuir Saldo a Pagar.              ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			dDataIni := ( cAliasSR8 )->R8_DATAINI
			dDataFim := ( cAliasSR8 )->R8_DATAFIM

			If ( cPaisLoc $ "MEX|PTG|HAI|COS|DOM|ARG|COL|CHI" .And. (cAliasSR8)->R8_STATUS == "C" ) .Or. ;
			        ( ( (cTipoAfa == "4") .And. (lFerias .Or. !lModPadrao) .And. ;
				        ( ( cPaisLoc == "MEX" .and. (cAliasSR8)->R8_PER == cAnoProc + cMesProc  ) .Or.;
						  ( cPaisLoc != "MEX" .and. ( (MesAno(dDataIni) == cAnoProc + cMesProc) .Or. (MesAno(dDataFim) == cAnoProc + cMesProc ) .Or. (MesAno(dDataIni) < cAnoProc + cMesProc .and. MesAno(dDataFim) > cAnoProc + cMesProc) ) ) ) );
					   .Or. ( (cTipoAfa != "4") .and. dDataIni <= dDataAte)   ) //Se afastamento iniciou após o fim do período, desconsidera.

					If (cPaisLoc == "ARG" .And. cTipoAfa == "4" .And. cTpRoteir == "3")
				( cAliasSR8 )->( DbSkip() )
				Loop
				EndIf

				aAdd( aAllSR8, {} )
				nPosReg := Len( aAllSR8 )

				For nX := 1 To nFields
					cField := (caliasSR8) + "->" + aSR8Fields[ nX, 1 ]
					If !(aSR8Fields[ nX , 02 ] == "M")
						aAdd( aAllSR8[ nPosReg ], &( cField ) )
					Else
						aAdd( aAllSR8[ nPosReg ], "" )
					EndIf
				Next nX

				/*
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Alem da estrutura do arquivo SR8 foi incluido no final tres      ³
				³ novos campos no array: Tipo do Afastamento, Recno e dias pagos.  ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
				aAdd( aAllSR8[ nPosReg ], cTipoAfa )
				aAdd( aAllSR8[ nPosReg ], (cAliasSR8)->( R_E_C_N_O_ ) )
				If cPaisLoc == "BRA"
					aAdd( aAllSR8[ nPosReg ], 0 )
				EndIf
			EndIf

			(cAliasSR8)->(DbSkip())

		EndDo
	EndIf
	aSort( aAllSR8,,, { |x, y| x[nPosPd]+DtoS(x[nPosDataIni]) < y[nPosPd] + DtoS( y[nPosDataIni] ) } )

EndIf

If !lFerias

	lNotNumID := Empty( (cAliasSRC)->RC_NUMID ) .and. !((cAliasSRC)->RC_PD == aCodFol[103,1]) //Se for licença remunerada e não tiver NUMID foi calculada as férias, não deve atualizar SR8

	If lNotNumID
		If cPaisLoc <> "MEX"
			nFound := aScan(aAllSR8, {|x| x[nPosPd] == (cAliasSRC)->RC_PD})
		EndIf
	Else
		nPosNumID	:= aScan(aSR8Fields	, {|x| x[1] == "R8_NUMID"})
		nFound		:= aScan(aAllSR8	, {|x| AllTrim(x[nPosNumID]) == AllTrim((cAliasSRC)->RC_NUMID)})
	EndIf

Else
	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Se for ferias, mesmo nao existindo verba no SRC devera processar ³
	³ os registros do SR8 para atualizar o SRF.						   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	nFound := IIf( Len( aAllSR8 ) > 0, 1, 0 )

EndIf

If cPaisLoc == "BRA" .AND. (cAliasSRA)->RA_CATFUNC $ "E*G"	// Estagiario Mensalista/Horista
	cPdFerias	:= aCodFol[891,1]
Else
	cPdFerias	:= aCodFol[72,1]
EndIf

If cPaisLoc $ "MEX|COS|PER"
	cPdFerProp := aCodFol[87,1]
EndIf
if !lFerias
	If (cPaisLoc $ "MEX|COS|COL|PER|PAR" .and. (((cAliasSRC)->RC_PD == cPdFerias) .Or. (cAliasSRC)->RC_PD == cPdFerProp)) .And. IIf(cPaisLoc == "ARG" .And. cTpRoteir == "3" , .F., .T.)
		nPosReg		:= aScan( aAllSR8, { |x| x[nPosPd] == cPdFerias } )
		nPosDPagos	:= aScan( aSR8Fields,{ |x| x[1] ==  "R8_DPAGOS" } )
		If nFound == 0
		  	aAdd( aAllSR8, {} )
			nPosReg := Len( aAllSR8 )

			For nX := 1 To nFields
				aAdd( aAllSR8[ nPosReg ], "" )
			Next nX

			aAdd( aAllSR8[ nPosReg ], "4" )		// Para o tipo de afastamento - Dias de Direito
			aAdd( aAllSR8[ nPosReg ], 0 )		// Posicao do Recnos
			aAllSR8[ nPosReg, nPosPD ] := (cAliasSRC)->RC_PD

			aAllSR8[ nPosReg, nPosDPagos ] := 0
		EndIf
		aAdd( aValSR8, { "" , nPosReg } )
	EndIf
endif

If nFound > 0

	nValor		:= IIf( !lFerias, ( cAliasSRC )->RC_HORAS, 0 )
	nValPago	:= IIf( !lFerias, ( cAliasSRC )->RC_VALOR, 0 )
	nValorFer   := IIf( !lFerias, ( cAliasSRC )->RC_VALOR, 0 )
	nValorAux	:= nValor
	nDiasAux	:= nValor
	nSldValor	:= 0
	nPosSdPagar	:= aScan( aSR8Fields,{ |x| x[1] ==  "R8_SDPAGAR" } )
	nPosDPagos	:= aScan( aSR8Fields,{ |x| x[1] ==  "R8_DPAGOS" } )
	nPosVlPago	:= aScan( aSR8Fields,{ |x| x[1] ==  "R8_VLRPAGO" } )
	nPosStatus  := aScan( aSR8Fields,{ |x| x[1] ==  "R8_STATUS" } )
	nPosDRever	:= aScan( aSR8Fields,{ |x| x[1] ==  "R8_DIASREV" } )
	nPosValor	:= aScan( aSR8Fields,{ |x| x[1] ==  "R8_VALOR" } )
	IF cPaisLoc == "COL"
		nPosDPagar	:= aScan( aSR8Fields,{ |x| x[1] ==  "R8_DPAGAR" } )
		nSdoDias	:= aScan( aSR8Fields,{ |x| x[1] ==  "R8_SDODIAS" } )
	Else
		nPosDPagar	:= aScan( aSR8Fields,{ |x| x[1] ==  "R8_DPAGAR" } )
		nPosTpAfa	:= aScan( aSR8Fields,{ |x| x[1] ==  "R8_TIPOAFA" } )
	EndIf
	nPosDtRet	:= aScan( aSR8Fields,{ |x| x[1] ==  "R8_DATAFIM" } )
	nPosNumID	:= aScan(aSR8Fields	, {|x| x[1] == "R8_NUMID"})
	nPosPd		:= aScan(aSR8Fields	, {|x| x[1] == "R8_PD"})
	If cPaisLoc == "BRA"
		nPosDPgMes 	:= Len( aSR8Fields )+3
	EndIf

	If !lFerias
		nUltDia   := F_UltDia( STOD( ( cAliasSRC )->RC_PERIODO+"01") )
		If nUltDia > 30 .AND. !lDiasPer .AND. nValor == 30
			cPerAfast 	:= StrZero(Year(aAllSR8[nFound][nPosDtRet]),4) + StrZero(Month(aAllSR8[nFound][nPosDtRet]),2)
			nDayRetAfa	:= Day(aAllSR8[nFound][nPosDtRet])
			If cPerAfast > ( cAliasSRC )->RC_PERIODO .OR. nDayRetAfa == 31
				nValor := nUltDia
			EndIf

		EndIf
	EndIf
	If lProvPMes .And. RetValSrv(( cAliasSRC )->RC_PD, SRA->RA_FILIAL, "RV_ENCARCC") == "S"
		fRateio({}, 2) // Carrega os registros da tabela RHQ-Programacao de Rateio para pegar os percentuais x centro de custo
	EndIf

	DbSelectArea("SRH")
	DbSetOrder(2)

	For nX := nFound To Len( aAllSR8 )

		If !lFerias .And. ( (aAllSR8[ nX, nPosPd ] != ( cAliasSRC )->RC_PD .And. (!((cAliasSRA)->RA_CATFUNC $ 'C/T' .And. (cAliasSRA)->RA_SALARIO == 0 ))) .OR. ;
			( !Empty((cAliasSRC)->RC_NUMID) .And. SubStr(aAllSR8[nX, nPosNumID],1,18) != SubStr( (cAliasSRC)->RC_NUMID ,1,18 ) .And. nDiasPagos == nDiasAux ) )
			Exit
		EndIf

		If !lFerias .And. !(Alltrim(PosAlias( "RCM", aAllSR8[nX, nPosTPAfa], xFilial( "RCM" ), "RCM_CODSEF", 1 )) $ "Q1*Q2*Q3*Q4*Q5*Q6") .And. RetValSRV((cAliasSRC)->RC_PD, SRA->RA_FILIAL, "RV_LCTODIA") == "S" .And. !Empty((cAliasSRC)->RC_NUMID) .And. (cAliasSRC)->RC_NUMID <> aAllSR8[nX, nPosNumID]
			Exit
		EndIf


		If cPaisLoc == "BRA"
			If lFerias .And. aAllSR8[ nX, nPosPd ] != cPdFerias
				Loop
			EndIf
		  /*ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿


			³ Demais ausencias - atualiza DIAS PAGOS e abate do SALDO A PAGAR ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		    If aAllSR8[ nX, nFields+1 ] != "4"
		    	// Para quando ocorrer alteracao nos dias de calculo e
		    	// o valor abatido foi dos dias de afastamento, no momento na baixa,
		    	// esse valor deve ser recuperado.
				If GetMvRH("MV_DIASPER",,"1") == "2" .And. (cAliasSRA)->RA_CATFUNC = 'M'
					If !Empty(aAllSR8[nX, nPosDtRet]) .and. aAllSR8[nX, nPosDtRet] <= dDataAte
						nValor := aAllSR8[nX, nPosDtRet] - dDataDe + 1
						nValor	:= Min(nValor,aAllSr8[nX,nPosDPagar])
					Else						
						If Len(aRateio) == 0
							nValor :=  dDataAte - Max(aAllSR8[nX][nPosDataIni], dDataDe) + 1
						EndIf
						If Day(dDataAte) == 31 .And. aAllSr8[nX,nPosDPagar] > nValor
							nValor	:= Min(nValor, 31)
						ElseIf P_PGSALFEV
							If Day(dDataAte) <= 29 .And. nDiasC == 30
								If nValor < 30
									nValor := dDataAte - Max(aAllSR8[nX][nPosDataIni], dDataDe) + 1
								ElseIf Day(dDataAte) <= 29 .And. nDiasC == 30
									nValor := Day(dDataAte)
								EndIf
							EndIf							
							nValor	:= Min(nValor,aAllSr8[nX,nPosDPagar])
						EndIf
					EndIf
				ElseIf (cPaisLoc == "BRA" .And. nValor < nDiasC) .Or. (cPaisLoc != "BRA" .And. GetMvRH("MV_DIASPER",,"1") == "1")
					nValor := nValorAux
					nValor := Min(nValor,aAllSR8[nX, nPosDPagar])
					nValorAux -= nValor
				EndIf
			    If nPosDPgMes > 0 .And. aAllSR8[nX, nPosSdPagar] > 0 .And. nValor > aAllSR8[nX, nPosSdPagar]
					nBkpSaldo 			 	 := aAllSR8[nX, nPosSdPagar]
					aAllSR8[nX, nPosSdPagar] := Max(0,If(!Empty(aAllSR8[nX, nPosSdPagar]),aAllSR8[nX, nPosSdPagar],aAllSR8[nX, nPosDPagar])-nBkpSaldo)
					aAllSR8[nX, nPosDPagos]  += nBkpSaldo
					aAllSR8[nX, nPosDPgMes]  := nBkpSaldo
				Else
					aAllSR8[nX, nPosSdPagar] := Max(0,If(!Empty(aAllSR8[nX, nPosSdPagar]),aAllSR8[nX, nPosSdPagar],aAllSR8[nX, nPosDPagar])-nValor)
					aAllSR8[nX, nPosDPagos]  += nValor
					aAllSR8[nX, nPosDPgMes]  := nValor
				EndIf
				aAllSR8[nX, nPosStatus]  := "C"
			EndIf

		  /*ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Posicao dos arrays a serem gravados na tabela.               ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			aAdd( aValSR8, { If(!lFerias,(cAliasSRC)->RC_NUMID,"") , nX } )
			If nX == 1
				fOrdAvalSR8(@aValSR8, cPdFerias, nPosNumID, nPosPd)
			EndIf
		Else // Paises Diferente de Brasil

		    /*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Validar o Valor do Saldo                                     ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			If !cPaisLoc $ "MEX|COS"
				If aAllSR8[nX, nPosSdPagar] < nValor
					nSldValor += nValor - aAllSR8[nX, nPosSdPagar]
					nValor 	  := aAllSR8[nX, nPosSdPagar]
				EndIf
			EndIf

			IF cPaisLoc == "COL"
				aAllSR8[nX, nPosValor]	+= nValPago
				aAllSR8[nX, nPosDPagar]	-= nValor
				aAllSR8[nX, nPosSdPagar]	-= nValor
				aAllSR8[nX, nSdoDias] 	-= nValor
				aAllSR8[nX, nPosDPagos]	+= nValor
			Else
				aAllSR8[nX, nPosSdPagar] -= nValor
				aAllSR8[nX, nPosDPagos]  += nValor
				If  cPaisLoc == "PAR"
					aAllSR8[nX, nPosDPagar]	-= nValor
					aAllSR8[nX, nPosValor]	+= nValPago
				Endif
			EndIf
			If nPosVlPago > 0
				aAllSR8[nX, nPosVlPago]  += nValPago
			EndIf
			aAllSR8[nX, nPosStatus]  := "C"
			If cPaisLoc == "MEX"
				If aAllSR8[nX, nPosDRever] > 0
					aAllSR8[nX, nPosStatus]  := "R"
				EndIf
			EndIf
			If lFerias .And. cPaisLoc == "ARG" .And. nPosValor > 0 //Não há chamadas da rotina GetSR8 com lFerias=.T.
				aAllSR8[nX, nPosValor]  := nValorFer
			EndIf

			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Posicao dos arrays a serem gravados na tabela.               ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			aAdd( aValSR8, { If(!lFerias,(cAliasSRC)->RC_NUMID,"") , nX } )
			If nX == 1
				fOrdAvalSR8(@aValSR8, cPdFerias, nPosNumID, nPosPd)
			EndIf
			
			If ( nSldValor == 0 .Or. !lNotNumID ) .and. !lFerias
				Exit
			EndIf

			nValor 	 := If(nSldValor > 0, nSldValor, nValor)

		EndIf

		nDiasPagos += nValor

		//DESOCUPACAO DO POSTO
		If (!Empty(aAllSR8[nx, nPosDtRet]) .AND. MesAno(aAllSR8[nx, nPosDtRet]) <= cPeriodo) .AND. GetMvRH("MV_ORGCFG", NIL, "0" ) == "1" ; // MV_ORGCFG - CONTROLDE DE POSTOS : 0-NAO USA SIGAORG; 1-TEM CONTROLE DE POSTOS; 2- NAO TEM  CONTROLE DE POSTOS
		.AND. GetMvRH("MV_IORGGPE", NIL, "0" ) == "1" // MV_IORGGPE - FAZ SUBSTIUICAO DE POSTOS NO SIGAGPE; 0-SEM SUBSTIUICAO; 1-COM SUBSTITUICAO
			cPosto := SRA->RA_POSTO
			DbSelectArea("RCM")
			DbSetOrder(RetOrder("RCM", "RCM_FILIAL+RCM_TIPO"))
			If dbSeek(xFilial("RCM")+aAllSR8[nX, nPosTpAfa])
				If RCM->RCM_SUBPOS == '2' .AND. !Empty(cPosto)
					DbSelectArea("RCX")
					DbSetOrder(RetOrder("RCX","RCX_FILIAL+RCX_POSTO+RCX_FILFUN+RCX_MATFUN"))
					DbSeek(xFilial("RCX")+cPosto)
					While RCX->(!Eof() .AND. RCX_FILIAL == xFilial("RCX") .AND. RCX_POSTO == cPosto)
						If RCX->RCX_AFAST == "1" //1 - "SIM"
							DbSelectArea("RBU")
							RBU->(dbSetOrder(1)) //RBU_FILIAL+RBU_POSTO+RBU_CODMOV
							If RBU->(DBSeek(xFilial("RBU") + cPosto))
								While !RBU->(EOF()) .AND. RBU->RBU_FILIAL == xFilial("RBU") .AND. RBU->RBU_POSTO == cPosto
									If RBU->RBU_FILFUN == RCX->RCX_FILFUN .AND. RBU->RBU_MATFUN == RCX->RCX_MATFUN .AND. RBU->RBU_DTFIM == CTOD("  /  /  ")
										RBU->(RecLock("RBU", .F.))
										RBU->RBU_DTFIM := aAllSR8[nx, nPosDtRet]
										RBU->(MsUnLock())
									EndIf
									RBU->(dbSkip())
								EndDo
							EndIf
							RBU->(DbCloseArea())
							RCX->(RecLock("RCX", .F.))
							RCX->(dbDelete())
							RCX->(MsUnLock())
						EndIf
						RCX->(DbSkip())
					EndDo
				EndIf
			EndIf
		EndIf

	Next nX

EndIf

If cPaisLoc == "VEN"
	// Atualiza dias e valor pago com informacoes de dias integrais

	aSort( aAllSR8,,, { |x, y| x[nPosPdInteg] < y[nPosPdInteg] } )
	nFound := aScan( aAllSR8, { |x| x[nPosPdInteg] == (cAliasSRC)->RC_PD } )
	If nFound > 0
		nPosSdPagar	:= aScan( aSR8Fields,{ |x| x[1] ==  "R8_SDPAGAR" } )
		nPosDPagos	:= aScan( aSR8Fields,{ |x| x[1] ==  "R8_DPAGOS" } )
		nPosVlPago	:= aScan( aSR8Fields,{ |x| x[1] ==  "R8_VLRPAGO" } )
  		For nX := nFound To Len( aAllSR8 )
			nValor		:= ( cAliasSRC )->RC_HORAS
			nValPago	:= ( cAliasSRC )->RC_VALOR
			aAllSR8[nX, nPosSdPagar] -= nValor
			aAllSR8[nX, nPosDPagos]  += nValor
			aAllSR8[nX, nPosVlPago]  += nValPago
		Next nX
	EndIf
EndIf

RestArea(aArea)

Return ( Nil )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³fAtuRG1  	  ³Autor³Abel Ribeiro         ³ Data ³19/12/2008³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Atualiza status de Pago, tabela RG1, campo RG1->RG1_STATUS=1³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³fAtuRG1      												³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³                 											³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Gpem120                                                     ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
Static Function fAtuRG1( cFilRG1, cNumID, nValor, cRCProc, cRCRoter, cRCPD)
DEFAULT  nValor := 0
Default cRCProc := ""
Default cRCRoter:= ""
Default cRCPD := ""

DbSelectArea( "RG1" )
DbSetOrder( RetOrdem( "RG1", "RG1_FILIAL+RG1_NUMID" ) )
If DbSeek( cFilRG1 + cNumID )
   RecLock("RG1",.F.)
   If cPaisLoc <> "CHI"
   		RG1->RG1_STATUS := "3"  // Altera Status = PAGO
   		If  cPaisLoc == "PAR"
   			If  POSICIONE("SRM",3,xFilial("SRM")+cRCProc+cRCRoter+cRCPD,"RM_LEEFIX") == "1"
   				RG1->RG1_VNAOAP := nValor
   			Endif
   		Endif
   	Else
   		RG1->RG1_VNAOAP := nValor
   	EndIF
   MsUnLock()
EndIf

Return Nil

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³GravaSR8	  ³Autor³Mauricio Takakura    ³ Data ³09/06/2005³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Gravacao da movimentacao de afastamentos e periodos (ferias)³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³GravaSR8    												³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³                 											³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Gpem120                                                     ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
Quando o usuario incluir a opcao de gravacao do campo NUMID na formula, o sistema devera realizar a busca atraves
deste campo agilizando o fechamento. Quando o campo estiver vazio, varrer a tabela e localizar o registro para
atualizacao.
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ*/
Static Function GravaSR8( cFilSRA, aValSR8, lAbono ,lProg, nVacPer)

Local cOrder		:= ""
Local cWhere		:= ""
Local cAliasQry 	:= ""
Local cFromTable	:= ""
Local cPDSRF
Local cPDPag
Local dBaseAtu
Local dDtPrescPer
Local lDivDiasPg	:= .T.
Local lDPropInd		:= .F.
Local lFindSRF		:= .T.
Local nX
Local nItens		:= 0
Local nPosArray		:= 0
Local nPosRecno		:= 0
Local nPosPd		:= 0
Local nPosDPagos	:= 0
Local nPosSdPagar	:= 0
Local nPosStatus	:= 0
Local nPosVlPago	:= 0
Local nPosDuracao	:= 0
Local nPosDtIni		:= 0
Local nPosDtFim		:= 0
Local nDiasPgAnt	:= 0
Local nDiasPago		:= 0
Local nPosValor 	:= 0
Local nDFerPagos	:= 0
Local nPosSdoDias:= 0
Local nPosDPagar := 0
Local nTotDiaPag	:= 0
Local nDiasPagar
Local nSldDPagar
Local lAtuSRF		:= .F.
Local lSinID 		:= .F.
Local lEdt 			:= .F.
Local nPos			:= 0
Local cPdEstag		:= aCodFol[891,1]

Default cFilSRA 	:= xFilial( "SRA" )
Default aValSR8 	:= {}
default lProg		:= .F.
Default lAbono 		:= .F.
Default nVacPer		:= 0

nPosPd	:= aScan( aSR8Fields,{ |x| x[1] ==  "R8_PD" } )

//Tratamento para quando é calculado apenas abono pecuniário sem dias de férias, mas é necessário atualizar a SRF
If lAbono .AND. !(cPaisLoc $ "MEX|HAI|COS|ARG")
	AtuSRF()
EndIf

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Filtrar o array para iniciar as baixas pelos registros com   ³
³ NUMID.                                                       ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
aSort( aValSR8,,, { |x, y| x[1]+cValToChar(x[2]) < y[1]+cValToChar(y[2]) } )

nPosSdPagar := aScan( aSR8Fields,{ |x| x[1] ==  "R8_SDPAGAR" } )
nPosDPagos	:= aScan( aSR8Fields,{ |x| x[1] ==  "R8_DPAGOS" } )
nPosStatus	:= aScan( aSR8Fields,{ |x| x[1] ==  "R8_STATUS" } )
nPosPd		:= aScan( aSR8Fields,{ |x| x[1] ==  "R8_PD" } )
nPosDuracao := aScan( aSR8Fields,{ |x| x[1] ==  "R8_DURACAO" } )
nPosVlPago  := aScan( aSR8Fields,{ |x| x[1] ==  "R8_VLRPAGO" } )
nPosDtIni   := aScan( aSR8Fields,{ |x| x[1] ==  "R8_DATAINI" } )
nPosDtFim   := aScan( aSR8Fields,{ |x| x[1] ==  "R8_DATAFIM" } )
nPosValor   := aScan( aSR8Fields,{ |x| x[1] ==  "R8_VALOR" } )

If  cPaisLoc $ "COL|PAR"
	If  cPaisLoc == "COL"
		nPosSdodias   	:= aScan( aSR8Fields,{ |x| x[1] ==  "R8_SDODIAS" } )
	Endif
	nPosDPagar 	:= aScan( aSR8Fields,{ |x| x[1] ==  "R8_DPAGAR" } )
EndIF

nDFerPagos := nDFerFol

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Transferir do array para a tabela no banco de dados.         ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
DbSelectArea("SR8")
For nItens := 1 To Len( aValSR8 )

	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Dar baixa somente quando existir movimento em SR8. Podera exi³
	³ tir baixa em SRF sem possuir afastamento. Ex. Ferias Pagas.  ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	nPosArray := aValSR8[ nItens, 2 ]
	nPosRecno := aAllSR8[ nPosArray, Len( aSR8Fields )+2 ]
	lSinID := .F.
	If cPaisLoc =='MEX' .AND. empty(aValSR8[ nItens, 1 ])
		lSinID := .T.
	EndIf
	If !lSinID
		If nPosRecno > 0
			SR8->(DbGoTo(nPosRecno))
	     	If cPaisLoc $ "MEX|PTG|VEN|EQU|ARG|DOM|COL|CHI|PAR|PER"
				nDiasPago := aAllSR8[ nPosArray, nPosDPagos ] - SR8->R8_DPAGOS
				If cPaisLoc == "ARG"
					nDiasPago	:= nVacPer
					nVacPer		:= 0
				EndIf
				RecLock( "SR8", .F. )

				SR8->R8_SDPAGAR := aAllSR8[ nPosArray, nPosSdPagar ]
				SR8->R8_DPAGOS	:= aAllSR8[ nPosArray, nPosDPagos  ]

				If cPaisLoc == "ARG" .And. R8_PD == aCodFol[72,1] 
					If SR8->R8_SDPAGAR != 0
						SR8->R8_STATUS 	:= ' '					
					Else
						SR8->R8_STATUS 	:= aAllSR8[ nPosArray, nPosStatus  ]
					Endif
				Endif		

				If nPosVlPago > 0
					SR8->R8_VLRPAGO	:= aAllSR8[ nPosArray, nPosVlPago  ]
				EndIf
				If cPaisLoc $ "ARG|COL|PAR" .And. nPosValor > 0
					SR8->R8_VALOR 	:= aAllSR8[ nPosArray, nPosValor ]
				Endif
				If cPaisLoc $ "COL|PAR"
					If cPaisLoc == "COL
						SR8->R8_SDODIAS := aAllSR8[ nPosArray, nPosSdoDias ]
					EndIf
					SR8->R8_DPAGAR  := aAllSR8[ nPosArray, nPosDPagar ]
				EndIf
				MsUnLock()

			Else
				RecLock( "SR8", .F. )
				SR8->R8_SDPAGAR := aAllSR8[ nPosArray, nPosSdPagar ]
				If aAllSR8[ nPosArray, Len( aSR8Fields )+1 ] == "4"
					If cPaisLoc == "BRA" .And. aAllSR8[ nPosArray, nPosPd ] <> cPdEstag .And. (nPos := aScan(aFerPag,{ |x| x[1] ==  aAllSR8[ nPosArray, nPosDtIni ] })) > 0
						SR8->R8_DPAGOS	+= aFerPag[nPos][2]
						SR8->R8_SDPAGAR := Max(0, SR8->R8_SDPAGAR - SR8->R8_DPAGOS)
					Else
						SR8->R8_DPAGOS	+= Min(nDFerPagos,If(SR8->R8_SDPAGAR>0,SR8->R8_SDPAGAR,SR8->R8_DPAGAR))
						nTotDiaPag := Min(nDFerPagos,If(SR8->R8_SDPAGAR>0,SR8->R8_SDPAGAR,SR8->R8_DPAGAR))
						nDFerPagos -= SR8->R8_DPAGOS
						SR8->R8_SDPAGAR := Max(0, SR8->R8_SDPAGAR - SR8->R8_DPAGOS)
						If aAllSR8[ nPosArray, nPosPd ] == cPdEstag //Recesso estagiário
							SR8->R8_SDPAGAR := aAllSR8[ nPosArray, nPosDuracao ] - SR8->R8_DPAGOS
							aAllSR8[ nPosArray , nPosDPagos ] := nTotDiaPag
						EndIf
					EndIf
				Else
					SR8->R8_DPAGOS	:= aAllSR8[ nPosArray, nPosDPagos  ]
				EndIf
				If SR8->R8_SDPAGAR == 0 .AND. SR8->R8_DPAGOS == SR8->R8_DPAGAR
					SR8->R8_STATUS 	:= "C"
				EndIf
				MsUnLock()
			EndIf
		Else
			nDiasPago := aAllSR8[ nPosArray, nPosDPagos ]
		EndIf
	EndIF
	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Pra Localiz. Colombia, verifica se existe o campo RF_FERPAGA ³
	³ e atualiza-o, se necessario.                                 ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	If cPaisLoc == "COL" .And. ValType(SRF->RF_FERPAGA) <> NIL .And. aAllSR8[nPosArray,nPosPd] == aCodFol[1241,1]
		DbSelectArea( "SRF" )
		DbSetOrder(2)	//-RF_FILIAL+RF_MAT+RF_PD+DtoS(RF_DATABAS)

		cMyChv := xFilial("SRF")+SR8->R8_MAT+aCodFol[72,1]
		DbSeek(cMyChv, .F.)

		nDiasProxP := aAllSR8[nPosArray,nPosSdPagar]
		While !Eof() .And. SRF->( RF_FILIAL+RF_MAT+RF_PD ) == ( cMyChv )
			If !( SRF->RF_STATUS $ " /1" )
				DbSkip()
				Loop
			EndIf

			nDiasTotPer := SRF->(RF_DIASANT + RF_DFERANT + RF_FERPAGA)
			nDiasSaldo  := nTotDiaPer - nDiasTotPer
			nDiasGravar := IIf(nDiasSaldo > nDiasProxP, nDiasProxP, nDiasSaldo)
			nDiasProxP  -= nDiasGravar

			If nDiasGravar > 0
				RecLock( "SRF", .F. )
				SRF->RF_FERPAGA += nDiasGravar
				If nDiasProxP > 0
					SRF->RF_STATUS  := "3"
					dBaseAtu := SRF->RF_DATAFIM+1
				EndIf
				MsUnLock()
			EndIf

			If nDiasProxP <= 0
				Exit
			Else
				DbSkip()

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Cria novo periodo no SRF                                     ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If Eof() .OR. SRF->( RF_FILIAL+RF_MAT+RF_PD ) <> ( cMyChv )

					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Apura periodos posteriores ao calculado                      ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					aPerFerias	:= {}
					Calc_Fer(@aPerFerias,iIf(dDtaLimite<dBaseAtu,dBaseAtu,dDtaLimite),,,,,,,dBaseAtu)

					For nX := 1 to Len(aPerFerias)
						If !SRF->( DbSeek( SRA->RA_FILIAL + SRA->RA_MAT + aAllSR8[ nPosArray, nPosPd ] + DtoS(aPerFerias[nX][01]) ) )
							RecLock( "SRF" , .T. )
							SRF->RF_FILIAL	:= SRA->RA_FILIAL
							SRF->RF_MAT		:= SRA->RA_MAT
							SRF->RF_PD		:= aAllSR8[ nPosArray, nPosPd ]
							SRF->RF_DIASDIR := nTotDiaPer
							SRF->RF_STATUS	:= "1"
							SRF->RF_DATABAS := aPerFerias[nX][01]
							SRF->RF_DATAFIM := aPerFerias[nX][02]
							SRF->RF_DFERVAT := aPerFerias[nX][03]
							SRF->RF_DFERAAT := aPerFerias[nX][04]
							SRF->RF_DFERANT := aPerFerias[nX][14]
							SRF->RF_DVENPEN := aPerFerias[nX][11]
							SRF->RF_IVENPEN := aPerFerias[nX][12]
							SRF->RF_FVENPEN := aPerFerias[nX][13]
							SRF->RF_DFALVAT := aPerFerias[nX][15]
							SRF->RF_DFALAAT := aPerFerias[nX][16]
							SRF->RF_FERPAGA := nDiasProxP
							SRF->( MsUnLock() )
						EndIf
					Next nX

				EndIf
			EndIf
		EndDo

		DbSetOrder(1)	//-RF_FILIAL+RF_MAT+DtoS(RF_DATABAS)+RF_PD
		DbSelectArea( "SR8" )
	EndIf

	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Se pertencer ao tipo de afastamento de periodos, atualizar a ³
	³ tabela SRF e se necessario gerar um novo periodo.            ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	If aAllSR8[ nPosArray, Len( aSR8Fields )+1 ] == "4"  .And. !(cPaisLoc $ "PTG|EQU") .AND. !lAtuSRF //GSA .and. cTpRoteir == "3" //Ferias

		If !(cPaisLoc $ "MEX|HAI|COS|ARG|COL|CHI|PER|PAR")

			AtuSRF(aAllSR8[ nPosArray ])
			lAtuSRF := .T.

		Else	// Mexico - PROPORCIONALIDADE DE FERIAS NO FECHAMENTO

			cPDSRF 		:= aAllSR8[ nPosArray, nPosPD ]
			cPDPag 		:= cPDSRF
			nDiasPgAnt	:= nDiasPago

			If (nPosRecno == 0 .and. (cPDSRF == aCodFol[86,1]) .or. cPDSRF == aCodFol[87,1])
				cPDSRF		:= aCodFol[72,1]
				lDPropInd	:= .T. //Indica que ha pagto de Ferias Indenizadas ou Proporcionais
			EndIf

			IF lProg .and. cPaisLoc == "CHI"
				cPDSRF := aCodFol[1383,1]
			EndIf

			If !( Select("SRF") > 0 )
				DbSelectArea( "SRF" )
				DbSetOrder( nOrdSR8SRF )
			EndIf

			cAliasQry := GetNextAlias()

			cOrder := "%"
			cOrder += " SRF.RF_FILIAL, SRF.RF_MAT, SRF.RF_PD, SRF.RF_DATABAS "
			cOrder += "%"

			cWhere := "%"
			cWhere += " SRF.RF_FILIAL = '" + xFilial( "SRF" )		+ "' AND "
			cWhere += " SRF.RF_MAT    = '" + (cAliasSRA)->RA_MAT	+ "' AND "
			cWhere += " SRF.RF_PD     = '" + cPDSRF 				+ "' AND "
			cWhere += "%"

			cFromTable := "% "+RetSqlName("SRF")+" SRF %"

			BeginSql alias cAliasQry
				SELECT 		SRF.R_E_C_N_O_ NRECNO
				FROM 		%exp:cFromTable%
				WHERE 		%exp:cWhere%
							SRF.%NotDel%
				ORDER BY    %exp:cOrder%
			EndSql

			If ( (cAliasQry)->NRECNO == 0 )
				lFindSRF := .F.
			Else
				SRF->(dbGoTo((cAliasQry)->NRECNO))
			EndIf

			(cAliasQry)->(dbCloseArea())

			nDiasPagar	:= 0
			nSldDPagar	:= 0
			lDivDiasPg 	:= .T.

			If lFindSRF

				Do While SRF->( !Eof() ) .and. SRF->( RF_FILIAL + RF_MAT + RF_PD ) == ( xFilial( "SRF" ) + (cAliasSRA)->RA_MAT + cPDSRF )
					lEdt := .F.
					If lDivDiasPg
						If cPaisLoc $ "MEX|ARG|PER|PAR"
						        dDtPrescPer :=( YearSum( SRF->RF_DATAFIM , Int( RCJ->RCJ_VIGVAC )))
						        dDtPrescPer := MonthSum( dDtPrescPer, ( RCJ->RCJ_VIGVAC -Int(RCJ->RCJ_VIGVAC)))
						Else
						        dDtPrescPer :=( YearSum( SRF->RF_DATAFIM , Int( RCJ->RCJ_VIGVAC / 365 )))
						        dDtPrescPer := MonthSum( dDtPrescPer, (( (RCJ->RCJ_VIGVAC / 365)-Int(RCJ->RCJ_VIGVAC/365))* 12 ))
						EndIf
					ENDIF
				    /*
					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					³IGNORA se o periodo estiver prescrito e o inicio da ausencia for superior a³
					³data de prescricao, ou se nao houve lancamento da ausencia, compara o final³
					³do periodo (RCH) com o fim da vigencia do periodo aquisitivo (SRF/RCJ).    ³
					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
					If SRF->RF_STATUS == "2" .And. IIf( !Empty(aAllSR8[nPosArray,nPosDtIni]), aAllSR8[nPosArray,nPosDtIni] > dDtPrescPer, dDtFimPer > dDtPrescPer )
						SRF->( DbSkip() )
						Loop
					EndIf

					nDiasPagar := IIf( SRF->( RF_DFERVAT ) == 0, IIf(cPaisLoc <> "BRA", SRF->( RF_DIASANT + RF_DFERAAT ),SRF->RF_DFERAAT ), SRF->( RF_DFERVAT ) )
					If cPaisLoc=="MEX" .and. cTpRoteir == "A" //Roteiro A = Aplicacion Finiquito
						nDiasPago := IIF(nDiasPago == 0,nDiasPagar,nDiasPago)
						If nDiasPagar == 0
							nDiasPago := 0
						EndIf
					EndIf

					If SRF->RF_DFERANT < nDiasPagar
						If nDiasPago > ( nDiasPagar - SRF->( RF_DFERANT ) )
							nSldDPagar := nDiasPago - ( nDiasPagar - SRF->( RF_DFERANT ) )
							nDiasPago  := ( nDiasPagar - SRF->( RF_DFERANT ) )
						Else
							nSldDPagar := 0
						EndIf

						/*
						ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						³Quando a data final da Ausencia ultrapassar a prescricao, os dias pagos    ³
						³serao divididos com o periodo subsequente. Um periodo recebera os dias ate ³
						³a data de prescricao, e o outro recebera os dias restantes.                ³
						ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
						If !Empty( aAllSR8[nPosArray,nPosDtIni]	)
							If ( aAllSR8[nPosArray,nPosDtIni] < dDtPrescPer ) .And. (aAllSR8[nPosArray,nPosDtFim] > dDtPrescPer )
								If lDivDiasPg
									nDiasPago 	:= DateDiffDay( aAllSR8[nPosArray,nPosDtIni], (dDtPrescPer+1) )
									lDivDiasPg	:= .F.
								Else
									nDiasPago := nDiasPago - ( DateDiffDay( aAllSR8[nPosArray,nPosDtIni], (dDtPrescPer+1) ) )
								EndIf
							EndIf
						EndIf

						If cPaisloc == "MEX" .AND. Empty(aValSR8[ nItens, 1 ]) .and. cTpRoteir != "A"
							lEdt := .T.
						EndIF

                        If !(cPaisLoc == "ARG" .AND. cPDSRF == aCodFol[87,1]) .AND. !lEdt
                        	RecLock( "SRF", .F. )
							SRF->RF_DFERANT += nDiasPago // dias Pagados
							MsUnLock()
						EndIf
					Else
						nSldDPagar := nDiasPago
					EndIf

					If nSldDPagar > 0
					   	nDiasPago := nSldDPagar
					EndIf

					If MV_MODFOL == "2"
						UpdStateSRF(cFilSra, SRA->RA_MAT, .T., cPDSRF, cTpRoteir, cPDPag, nDiasPago )
						If lDivDiasPg .And. nSldDPagar <= 0 .and. !(cPaisLoc=="MEX" .and. cTpRoteir == "A") //Roteiro A = Aplicacion Finiquito
							Exit
						EndIf
					EndIf

					//Restaura o valor inicial para dividir os dias pagos corretamente
					nDiasPago := IIf( !lDivDiasPg, nDiasPgAnt, nDiasPago )

					SRF->( DbSkip() )
				EndDo

			EndIf

		EndIf

	EndIf

Next nItens

Return( Nil )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³fDtMesSeg ºAutor  ³Microsiga           º Data ³  05/08/02   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Retorna data do mes seguinte com o mesmo dia da data de ref.º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP6                                                        º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function fDtMesSeg(dData)

Local nDia := Day(dData)
Local nMes := Month(dData)
Local nAno := Year(dData)
Local nUDia

If nMes == 12
	nMes := 1
	nAno ++
Else
	nMes ++
EndIf

nUDia := F_UltDia(CtoD("01/"+StrZero(nMes,2)+"/"+StrZero(nAno,4)))

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³-Se o dia do vencto. anterior for o ultimo dia do mes, considerar o dia do ³
³ vencto atual como ultimo dia do mes.                                      ³
³-Se o dia do vencto. anterior for maior que o ultimo dia do vencto do mes  ³
³ atual, considerar o dia do vencto atual como ultimo dia do mes.           ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
If (nDia == F_UltDia(dData)) .or. (nDia > nUDia)
   nDia := nUDia
EndIf

Return( CtoD(StrZero(nDia,2)+"/"+StrZero(nMes,2)+"/"+StrZero(nAno,4)))

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³fDependentes  ³Autor³Mauricio Takakura    ³ Data ³28/12/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Atualizacao de dependentes                               	³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³fDependentes  												³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³                 											³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico                                                    ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function fDependentes( cFilSRA, cMesProc, cAnoProc )

Local cTipodep
Local cTipodep1
Local cDia
Local cGrauPar

Local dDatanas

Local nDepIR	:= 0
Local nDepSF	:= 0
Local nIdade
Local lJob		:= .F.
Local lIntEsoc	:= (SuperGetMv("MV_RHTAF",, .F.) == .T. .Or. SuperGetMv("MV_MID",, .F.) == .T.) .And. Val(SuperGetMv("MV_FASESOC",/*lHelp*/,' ')) >= 1

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Configuracao para TOP para SRB                               ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
DbSelectArea( cAliasSRB )
SRB->( DbSetOrder( 1 ) )		// RB_FILIAL + RB_MAT

If (cAliasSRB)->( dbSeek( cFilSRA + (cAliasSRA)->RA_MAT  ) )
	While !(cAliasSRB)->(Eof()) .and. ( (cAliasSRB)->RB_FILIAL + (cAliasSRB)->RB_MAT == cFilSRA + (cAliasSRA)->RA_MAT )

		cTipodep  := If(cPaisLoc == "EQU",(cAliasSRB)->RB_DEPPLR,(cAliasSRB)->RB_TIPIR)
		cTipodep1 := (cAliasSRB)->RB_TIPSF
		dDatanas  := (cAliasSRB)->RB_DTNASC
		cGrauPar  := (cAliasSRB)->RB_GRAUPAR
		cDia      := If ( cMesProc == "02" , "28" , "30")
		nIdade    := Calc_idade( CtoD(cDia+"/" + cMesProc + "/" + cAnoProc , "DDMMYY" ), dDatanas)
		If cTipodep = "1" .or. (cTipodep = "2" .and. nIdade <= 21) .Or. (cTipodep = "3" .and. nIdade <= 24)
			nDepIR ++
		EndIf
		If (cTipodep1 = "1" .or. (cTipodep1 = "2" .and. nIdade < 14)) .And. cPaisLoc <> "CHI"
			nDepSF ++
		EndIf
		//# Tratamento Localizacao Angola
		If (cTipodep1 = "1" .or. (cTipodep1 = "2" .and. nIdade <= 18)) .And. cPaisLoc == "ANG"
			nDepSF ++
		EndIf
		If cPaisLoc == "CHI" .And. cTipodep1 $ "1|2|3|4|5"
			nDepSF ++
		EndIf

		If cPaisLoc == "BRA" .And. !(cTipodep == "2" .And. nIdade > 21) .And. !(cTipodep == "3" .And. nIdade > 24) .And. !(cTipodep1 == "2" .And. nIdade >= 14)
			(cAliasSRB)->( dbSkip() )
			Loop
		EndIf

		RecLock("SRB",.F.)
		If cPaisLoc == "ARG"
			If cGrauPar == "F" .And. (cTipodep = "2" .and. nIdade >= 21) .Or. (cTipodep = "3" .and. nIdade >= 24)
				If Empty(SRB->RB_DTBAIXA)
					SRB->RB_DTBAIXA := LastDate( CtoD("01/" + cMesProc + "/" + cAnoProc , "DDMMYY" ) )
				EndIf
			EndIf
		ElseIf cPaisLoc == "EQU"
			If cTipodep = "2" .and. nIdade >= 18 .and. Empty(SRB->RB_DTBAIXA)
				SRB->RB_DTBAIXA := LastDate( CtoD("01/" + cMesProc + "/" + cAnoProc , "DDMMYY" ) )
			EndIf
		ElseIf cPaisLoc <> "ARG"
			If (cTipodep = "2" .and. nIdade > 21) .Or. (cTipodep = "3" .and. nIdade > 24)
				SRB->RB_TIPIR := "4"
				lJob := .T.
			EndIf
		EndIf
		If cPaisLoc == "BRA"
			If cTipodep1 = "2" .and. nIdade >= 14
				SRB->RB_TIPSF := "3"
				lJob := .T.
			EndIf
		ElseIf cPaisLoc == "ARG"
			If cTipodep1 = "1" .and. nIdade >= 21
				SRB->RB_TIPSF := "4"
			EndIf
			If cTipodep1 = "2" .and. nIdade >= 18
				SRB->RB_TIPSF := "4"
			EndIf
		ElseIf cPaisLoc == "CHI"
			If cTipoDep1 = "2" .and. nIdade >= 18
				SRB->RB_TIPSF := "6"
			ElseIf cTipoDep1 = "3" .and. nIdade >= 24
				SRB->RB_TIPSF := "6"
			EndIf
		EndIf
		MsUnLock()
		(cAliasSRB)->(DbSkip())
	EndDo
	fGravaSr9("RA_DEPIR",StrZero(nDepIR,2),If(Empty(SRA->RA_DEPIR),"00",SRA->RA_DEPIR),dDataBase)
	If lDepSf
		fGravaSr9("RA_DEPSF",StrZero(nDepSF,2),If(Empty(SRA->RA_DEPSF),"00",SRA->RA_DEPSF),dDataBase)
	EndIf
	RecLock("SRA",.F.)                 // Bloqueio registro SRA
	SRA->RA_DEPIR   := StrZero(nDepIR,2)   // Mudancas SRA
	If lDepSf
		SRA->RA_DEPSF   := StrZero(nDepSF,2)
	EndIf

	//Grava informação na tabela RJB para geração do evento S-2205 via job
	If lJob .And. lIntEsoc
		fGravaRJB()
	EndIf

	SRA->( MsUnLock() )
EndIf

Return( Nil )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³GpGrvRCI      ³Autor³Mauricio Takakura    ³ Data ³20/01/2005³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Gravacao do Historico de Periodos - Auditoria            	³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³GpGrvRCI													³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³                 											³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Gpem120                                                     ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function GpGrvRCI( nTotLiq, nTotEmp )

Local aArea 	 := GetArea()
Local cAliasRCH  := "RCH"

DbSelectArea( "RCI" )

If DbSeek( (cAliasRCH)->(RCH_FILIAL+RCH_PROCES+RCH_PER+RCH_NUMPAG+RCH_ROTEIR) )
	RecLock("RCI",.F.)
Else
	RecLock("RCI",.T.)
	RCI->RCI_FILIAL 	:= (cAliasRCH)->RCH_FILIAL
	RCI->RCI_PER		:= (cAliasRCH)->RCH_PER
	RCI->RCI_NUMPAG		:= (cAliasRCH)->RCH_NUMPAG
	RCI->RCI_PROCES		:= (cAliasRCH)->RCH_PROCES
	RCI->RCI_ROTEIR		:= (cAliasRCH)->RCH_ROTEIR
EndIf

RCI->RCI_MES		:= (cAliasRCH)->RCH_MES
RCI->RCI_ANO		:= (cAliasRCH)->RCH_ANO
RCI->RCI_NETO		:= nTotLiq				// Somente o liquido do periodo - Proventos - Descontos
RCI->RCI_TOTEMP		:= nTotEmp				// Total de funcionários processados no período
RCI->RCI_DTFEC		:= dDataBase
RCI->RCI_HORFEC		:= Time()

RCI->( MsUnLock() )

RestArea( aArea )

Return( Nil )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³fGravaSalInc  ³Autor³Mauricio Takakura    ³ Data ³29/12/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Gravacao das informacoes de aSalInc                      	³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³fGravaSalInc  												³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³                 											³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Gpem120                                                     ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function fGravaSalInc( 	aSalInc	,;
								cMesProc,;
								cAnoproc,;
								cFilSRA	;
							)
Local cOrder 		:= ""
Local cWhere		:= ""
Local cFromTable	:= ""
Local cTipo

Local dDtPesq
Local dDtAum
Local dUltDia

Local nSavRec
Local n

If Len(aSalInc) > 0
	dDtPesq  := CtoD("01/" + cMesProc + "/" + cAnoProc , "DDMMYY")
	DbSelectArea( cAliasSR3 )
	SR3->( DbSetOrder( 1 ) ) // R3_FILIAL + R3_MAT + DtoS(R3_DATA) + R3_TIPO + R3_PD

	cAliasSR3 := If( Substr(cAliasSR3,1,1) == "Q", Substr(cAliasSR3, 2), cAliasSR3)
	cWhere := "%"
	dUltDia := CtoD(StrZero(f_UltDia( CtoD("01/" + cMesProc + "/" + cAnoProc , "DDMMYY" )),2) + "/" + cMesProc + "/" + cAnoProc , "DDMMYY")


	cWhere += " SR3.R3_FILIAL  =  '" + cFilSRA + "' AND "
	cWhere += " SR3.R3_MAT 	   =  '" + (cAliasSRA)->RA_MAT + "' AND "
	cWhere += " SR3.R3_DATA    >= '" + DtoS(dDtPesq) + "' AND "
	cWhere += " SR3.R3_DATA	   <= '" + DtoS(dUltDia) + "' AND "

	cWhere += "%"

	cAliasSR3 := "Q" + cAliasSR3
	If ( SELECT(cAliasSR3) > 0 )
		(cAliasSR3)->(dbCloseArea())
	EndIf

	cOrder := "% SR3.R3_FILIAL, SR3.R3_MAT %"

	cFromTable := "% "+RetSqlName("SR3")+" SR3 %"

	BeginSql alias cAliasSR3
		column R3_DATA as Date
		SELECT
				%exp:cFieldsSR3%
		FROM
				%exp:cFromTable%
		WHERE
			 	%exp:cWhere%
			 	SR3.%NotDel%
		ORDER BY
				%exp:cOrder%
	EndSql

	While (cAliasSR3)->(!Eof()) .And. cFilSRA + (cAliasSRA)->RA_MAT == (cAliasSR3)->R3_FILIAL + (cAliasSR3)->R3_MAT ;
				 .And. Year((cAliasSR3)->R3_DATA) == Year(dDtPesq) .And. Month((cAliasSR3)->R3_DATA) == Month(dDtPesq)
		nSavRec := Recno()
		dDtAum := (cAliasSR3)->R3_DATA
		cTipo  := (cAliasSR3)->R3_TIPO
		For n := 1 To Len(aSalInc)
			SR3->( DbSetOrder( 1 ) ) // R3_FILIAL + R3_MAT + DtoS(R3_DATA) + R3_TIPO + R3_PD
			If SR3->( DbSeek( cFilSRA + (cAliasSRA)->RA_MAT + DtoS(dDtAum) + cTipo + aSalInc[n,1]) )
				RecLock( "SR3", .F.)
				SR3->R3_VALOR := aSalInc[n,3]
			Else
				If SR7->( DbSeek(cFilSRA + (cAliasSRA)->RA_MAT + DtoS(dDtAum) + cTipo + aSalInc[n,1]) )
					RecLock("SR3",.T., .T.)
					SR3->R3_FILIAL   := (cAliasSRA)->RA_FILIAL
					SR3->R3_MAT      := (cAliasSRA)->RA_MAT
					SR3->R3_DATA     := dDtAum
					SR3->R3_PD       := aSalInc[n,1]
					SR3->R3_DESCPD   := DescPd(aSalInc[n,1], (cAliasSRA)->RA_FILIAL)
					SR3->R3_VALOR    := aSalInc[n,3]
					SR3->R3_TIPO     := cTipo
					SR3->R3_SEQ		 := SR7->R7_SEQ
				Endif
			EndIf
			MsUnLock()
		Next
		DbSelectArea( cAliasSR3 )
		dbGoTo( nSavRec )
		DbSkip()
	EndDo
EndIf

Return( Nil )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³CreateQry     ³Autor³Mauricio Takakura    ³ Data ³27/12/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Cria/Altera uma query                                    	³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³CreateQry     												³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³                 											³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³                                                            ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function CreateQry( aFields		,;			// Array com os campos para a Query
					aFilter		,;			// Filtro para query
					cAlias		,;			// Alias da Tabela
					cQuery		,;			// String com a Query Montada
					cSvQuery	,;			// Copia da Query
					cQryAlias	,;			// Nome da Query a ser Retornada
					lExecCount	,;			// Se deve executar a contagem dos registros
					nRetCount   ,;			// Retorna por referencia o numero de registros contados
					cStr         ;			// caso esteja preenchido aReturn[7] -> mediante filtro do setprint
				  )
Local cField
Local cValue
Local cNewValue
Local cOperador
Local cQryCount
Local cCpoRecno 	:= "R_E_C_N_O_"

Local lChgQry
Local lQryOpened

Local nField
Local nX

DEFAULT cQryAlias	:= "Q" + cAlias
DEFAULT aFields 	:= {}
DEFAULT	aFilter 	:= {}
DEFAULT lExecCount	:= .F.
DEFAULT nRetCount	:= 0
DEFAULT cStr		:= ""


If Empty( cQuery )
	cQuery := "SELECT "

	// Todos os campos da tabela //
	If !Empty(aFields)
		For nField := 1 To Len( aFields )
			cQuery += aFields[ nField , 01 ] + ", "
		Next nField
		If aScan( aFields, { |x| x[1] == "R_E_C_N_O_"}) = 0
			cQuery := cQuery + cCpoRecno + ", "
		EndIf
	Else
		cQuery += "*, "
		If At( cCpoRecno, cQuery) == 0
			cQuery := cQuery + cCpoRecno + ", "
		EndIf
	EndIf

	cQuery := SubStr( cQuery , 1 , Len( cQuery ) - 2 )
	cQuery += ( " FROM " + InitSqlName(cAlias) + " " + cAlias )
	cQuery += ( " WHERE " )

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Montagem do Filtro                                          ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	If !Empty( aFilter )
		For nX := 1 To Len( aFilter )
			cQuery += ( cAlias + "." )
			cField := aFilter[nX, 1]
			cOperador := aFilter[nX, 2]
			cValue := aFilter[nX, 3]
			If ValType(cValue) = "N"
				cQuery += ( cField + " " + cOperador + " " + Str( cValue, 30, 10) )
			Else
				cQuery += ( cField + " " + cOperador + " " + If( cOperador != "IN", "'", "") + cValue + If( cOperador != "IN", "'", "") )
			EndIf
			cQuery += ( " AND " )
	    Next nX
	EndIf

	cQuery += ( cAlias + ".D_E_L_E_T_=' ' " )

	cQuery += Iif(cStr#"", ' AND ' + StrTran(StrTran(StrTran(aReturn[7],".",Space(1)), "==", " = "), '"', "'") + ' ', "")

	If lExecCount
		cQryCount := "SELECT COUNT(*) NROREG " + Substr( cQuery, At( "FROM", cQuery ) )
	EndIf
	cQuery += ( "ORDER BY " + SqlOrder( (cAlias)->( IndexKey() ) ) )

	cSvQuery := cQuery

Else

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Remonta a Query Substituindo os Valores Anteriores pelos atu³
	³ ais														  ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	For nX := 1 To Len( aFilter )
    	cField 		:= aFilter[nX, 1]
    	cOperador 	:= aFilter[nX, 2]
    	cValue 		:= aFilter[nX, 3]

    	cNewValue 	:= aFilter[nX, 4]
    	If cNewValue != cValue
			cQuery	:= StrTran( cSvQuery , ( cField + " " + cOperador + " '" + cValue + "'" ) , ( cField + " " + cOperador + " '" + cNewValue + "'" ) )
			aFilter[nX, 3] := cNewValue
			lChgQry := .T.
    	EndIf
	Next nX

	If lChgQry
		cSvQuery := cQuery
	EndIf

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Query para montagem do contador de registros                ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	If lExecCount
		cQryCount := "SELECT COUNT(*) NROREG " + Substr( cQuery, At( "FROM", cQuery ) )
		cQryCount := Substr( cQryCount, 1, At( "ORDER BY ", cQryCount )-1 )
	EndIf
EndIf

If ( lChgQry )
	cQuery := ChangeQuery( cQuery )
EndIf

If ( Select( cQryAlias ) > 0 )
	( cQryAlias )->( dbCloseArea() )
EndIf
If ( lQryOpened := MsOpenDbf(.T., "TOPCONN", TcGenQry(NIL,NIL,cQuery), cQryAlias, .T., .T., .F., .F.))
	For nField := 1 To Len( aFields )
		If !( aFields[ nField , 02 ] == "C" )
			TcSetField(cQryAlias, aFields[nField,01], aFields[nField,02], aFields[nField,03], aFields[nField,04])
		EndIf
	Next nField
EndIf

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Query para montagem do contador de registros                ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
If lExecCount
	cQryCount := ChangeQuery( cQryCount )
	If ( lQryOpened := MsOpenDbf(.T., "TOPCONN", TcGenQry(NIL,NIL,cQryCount), "QTMP", .T., .T., .F., .F.))
		nRetCount := QTMP->NROREG
		QTMP->( dbCloseArea() )
	EndIf
EndIf

Return( lQryOpened )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³Gp120CabLog   ³Autor³Mauricio Takakura    ³ Data ³20/01/2005³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Montar cabecalho do Log de Erros                         	³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³Gp120CabLog   												³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³                 											³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³                                                            ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function Gp120CabLog( cAliasLog, aFieldsLog, aTamFields, lDuracao, lMovimento )

Local aHeaderLog	:= {}

Local cCabLog		:= ""
Local cSpace		:= ""

Local nField
Local nPosCampo
Local nTamField		:= 0

DEFAULT aFieldsLog := {}
DEFAULT aTamFields := {}
DEFAULT lDuracao   := .F.
DEFAULT lMovimento := .F.

aHeaderLog := (cAliasLog)->( GdMontaHeader(,,,,,.T.) )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Gerar Log de Todos os campos                                ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
If Empty( aFieldsLog )
	For nField := 1 To Len( aHeaderLog )
		aAdd( aFieldsLog, aHeaderLog[ nField, 2] )
	Next nField
EndIf

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Gerar array com os campos selecionados                      ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
For nField := 1 To Len( aFieldsLog )
	nPosCampo := GdFieldPos( aFieldsLog[nField], aHeaderLog )

	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Item do cabecalho que nao pertence a tabela - Definido      ³
	³ pelo Usuario.                                               ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	If nPosCampo == 0
		cCabLog += aFieldsLog[nField]
		aAdd( aTamFields, 0 )	// quando for zero, eh prq nao pertence a tabela (o usuario devera controlar os espacos)
	Else
		nTamField := aHeaderLog[ nPosCampo, 4]
		If Len( aHeaderLog[ nPosCampo, 1 ] ) >= nTamField
			cSpace := " "	// o caracter + sera apenas para detectar o tamanho de cada campo. No final sera substituido por " "
		Else
			cSpace := Space( nTamField - Len(aHeaderLog[ nPosCampo, 1 ]) )
		EndIf
		cCabLog += aHeaderLog[ nPosCampo, 1 ] + cSpace

		aAdd( aTamFields,  Max( Len( aHeaderLog[ nPosCampo, 1 ] + cSpace ) - aHeaderLog[nPosCampo, 4] , 1) )
	EndIf

Next nField

If lMovimento
	cCabLog += STR0100 + " "//"Movimento?"
	aAdd( aTamFields,  Len(STR0100)-3 )
EndIf

If lDuracao
	cCabLog += STR0059 //Duracao
EndIf

Return( cCabLog )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³Gp120GetSalInc³Autor³Mauricio Takakura    ³ Data ³20/12/2004³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Retorna por referencia o vetor aSalInc                   	³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³Gp120GetSalInc												³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³                 											³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³                                                            ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function Gp120GetSalInc( aSalInc	 )		// Vetor com Dif. Salario

Local nSal
Local nPos

nSal := (cAliasSRC)->RC_VALOR

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Quando For Horista Gravar o Salario Hora                     ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
If (cAliasSRA)->RA_CATFUNC == "H"
	nSal := nSal / (cAliasSRA)->RA_HRSMES
EndIf

nPos := Ascan(aSalInc,{ |X| x[1] == (cAliasSRC)->RC_PD })
If nPos = 0
	aAdd(aSalInc, { (cAliasSRC)->RC_PD, (cAliasSRC)->RC_HORAS, nSal})
Else
	aSalInc[nPos,3] += nSal
EndIf

Return( Nil )

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
					F U N C O E S     U T I L I Z A D A S    E M     S X B
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ/*/

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³Gpm120Per ³Autor³Mauricio T. Takakura       ³Data³05/01/2005³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Validar o Periodo digitado na Consulta Padrao				³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Consulta Padrao (SXB)				                  	   	³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function Gpm120Per( lDtFech )

Local cOldAlias := Alias()
Local cFilRCH	:= xFilial("RCH")
Local cMsg

Local lRet 		:= .T.

DEFAULT lDtFech := .T.

If !( lRet := NaoVazio() )
	DbSelectArea(cOldAlias)
	Return( lRet )
EndIf

DbSelectArea( "RCH" )
RCH->( DbSetOrder( Retorder( "RCH", "RCH_FILIAL+RCH_PROCES+RCH_PER+DtoS(RCH_DTFECH)" ) ) )
If lDtFech
	RCH->( DbSeek( cFilRCH + MV_PAR01 + MV_PAR02 + SPACE(8) , .F. ) )
Else
	RCH->( DbSeek( cFilRCH + MV_PAR01 + MV_PAR02 , .F. ) )
EndIf
If RCH->( Eof() )
	lRet := .F.
	cMsg := STR0022	// "Periodo nao Cadastrado!"
	MsgInfo( cMsg )
Else
	cPeriodo := MV_PAR02
EndIf

DbSelectArea(cOldAlias)

Return( lRet )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³fVldPerM120³Autor³Mauricio T. Takakura      ³Data³22/05/2006³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Validar o Periodo Completo digitado          				³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Consulta Padrao (SXB)				                  	   	³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function fVldPerM120(nItem)

Local lRet := .T.

DbSelectArea("RCH")
DbSetOrder(1)
If nItem = 1
	DbSeek( xFilial("RCH")+MV_PAR01+MV_PAR02+MV_PAR03 )
	MV_PAR04 := RCH->RCH_ROTEIR
Else
    If !( lRet := DbSeek( xFilial("RCH")+MV_PAR01+MV_PAR02+MV_PAR03+MV_PAR04))
		cMsg := STR0022	// "Periodo nao Cadastrado!"
		MsgInfo( cMsg )
    EndIf
EndIf

Return(lRet)


/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³fAtuStatusºAutor  ³Microsiga           º Data ³  11/25/07   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Atualiza status do Cadastro de periodos RCH_STATUS          º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function  fAtuStatus()
Local lOk 	:= .T.

If RCH->(RCH_PERSEL = '1' .and. RCH_STATUS=='3' .and. 	Empty(RCH_DTFECH)  )  								//-- Deve ser periodo selecionado  e Recibo ja devem  ter sido impresso
	RecLock( "RCH", .F. )
	RCH->RCH_STATUS	:= "4" 																					//-- Em processo de Fechamento
	MsUnLock()
Else
	lOk 	:= .F.
EndIf

Return lOk

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³fGrvControle ºAutor  ³Microsiga           º Data ³  11/25/07   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³                                                               º±±
±±º          ³                                                               º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                            º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static function fGrvControle( nTotProvLiq, nTotDescLiq, nTotEmp,  nTotBsProv,nTotBsDesc, nTotRegs,nTotFunc )

Local aArea 	:= GetArea()
Local cAliasRCH := "RCH"

//-- RG8_FILIAL + RG8_MODORI  + RG8_PERORI + RG8_NPGORI + RG8_PRCORI+  RG8_ROTORI + RG8_MODCOR  + RG8_PERCOR +  RG8_NPGCOR + RG8_PROCOR+  RG8_ROTC
DbSelectArea( "RG8" )
If RG8->( DbSeek( (cAliasRCH)->RCH_FILIAL + cModulo + (cAliasRCH)->RCH_PER + (cAliasRCH)->RCH_NUMPAG +(cAliasRCH)->RCH_PROCES  + (cAliasRCH)->RCH_ROTEIR + ;
					                         cModulo + (cAliasRCH)->RCH_PER + (cAliasRCH)->RCH_NUMPAG +(cAliasRCH)->RCH_PROCES  + (cAliasRCH)->RCH_ROTEIR   ;
         ) )
	RecLock("RG8",.F.)
Else
	RecLock("RG8",.T.)
	RG8->RG8_FILIAL 	:= (cAliasRCH)->RCH_FILIAL
	RG8->RG8_PERORI		:= (cAliasRCH)->RCH_PER
	RG8->RG8_NPGORI		:= (cAliasRCH)->RCH_NUMPAG
	RG8->RG8_PRCORI		:= (cAliasRCH)->RCH_PROCES
	RG8->RG8_ROTORI		:= (cAliasRCH)->RCH_ROTEIR
	RG8->RG8_ANOORI		:= (cAliasRCH)->RCH_ANO
	RG8->RG8_MESORI		:= (cAliasRCH)->RCH_MES
	RG8->RG8_MODORI		:=  cModulo
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ O periodo correspondente devera ser gerada automaticamente  ³
	³ na tabela e devera ser igual ao Per.Origem para o fechamento³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
	RG8->RG8_PERCOR		:= (cAliasRCH)->RCH_PER
	RG8->RG8_NPGCOR		:= (cAliasRCH)->RCH_NUMPAG
	RG8->RG8_PROCOR		:= (cAliasRCH)->RCH_PROCES
	RG8->RG8_ROTCOR		:= (cAliasRCH)->RCH_ROTEIR
	RG8->RG8_ANOCOR		:= (cAliasRCH)->RCH_ANO
	RG8->RG8_MESCOR		:= (cAliasRCH)->RCH_MES
	RG8->RG8_MODCOR		:=  cModulo
EndIf

RG8->RG8_QTREGS	:= nTotRegs
RG8->RG8_QTFUNC	:= nTotFunc
RG8->RG8_TOTLIQ	:= (nTotProvLiq - nTotDescLiq )
RG8->RG8_TOTPRO	:= nTotProvLiq
RG8->RG8_TOTDES := nTotDescLiq
RG8->RG8_BSPROV	:= nTotBsProv
RG8->RG8_BSDESC	:= nTotBsDesc

MsUnLock()

RestArea(aArea)

Return ( Nil )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³fGetIncidenºAutor ³Mauricio Takakura   º Data ³  14/10/08   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Carregar em array as incidencias com Parcela > 1            º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function fGetInciden(aValMSegRGB)

Local aArea			:= GetArea()
Local cFields 		:= ""
Local cChave		:= (cAliasSRA)->RA_FILIAL  + cProcesso + cPeriodo + cNumPag + cRoteiro + (cAliasSRA)->RA_MAT
Local nX
Local nPos
Local nFields 		:= Len(aRGBFields)

(cAliasRGB)->( dbSetOrder(5) )//RGB_FILIAL+RGB_PROCES+RGB_PERIOD+RGB_SEMANA+RGB_ROTEIR+RGB_MAT+RGB_PD+RGB_SEQ
If (cAliasRGB)->( dbSeek( cChave ) )
	While !(cAliasRGB)->(Eof()) .and. (cAliasRGB)->( RGB_FILIAL + RGB_PROCES + RGB_PERIOD + RGB_SEMANA + RGB_ROTEIR + RGB_MAT ) == cChave
		If (cAliasRGB)->( RGB_PARCEL ) > 1
			aAdd( aValMSegRGB, Array( nFields ) )
			nPos := Len(aValMSegRGB)
			For nX := 1 To nFields
				cFields := "(cAliasRGB)->(" + aRGBFields[nX,1] + ")"
				aVAlMSegRGB[nPos,nX] := &cFields
			Next nX
			aAdd( aVAlMSegRGB[nPos], "1" )
		EndIf
		(cAliasRGB)->( DbSkip() )
	EndDo
EndIf

RestArea(aArea)

Return

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³GetAfPerda    ³Autor³Leandro Drumond      ³ Data ³21/10/2013³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Obtem faltas no mes/ano corrente						    ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³GetAfFalta     												³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³                 											³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³ Gpem120                                                    ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
Static Function GetAfFalta(cFil,aPerFerias,dDtaLimite)
Local aArea 		:= GetArea()
Local cCodFer 		:= ""
Local dDataAux		:= CtoD("")
Local lRet			:= .F.
Local nPer			:= 0
Local nFaltas		:= 0

If SRA->RA_CATFUNC $ "E*G"   // Estagiario Mensalista/Horista
	cCodFer	:= aCodFol[891,1]
Else
	cCodFer	:= aCodFol[72,1]
EndIf

SRF->( DbSetOrder( 1 ) )

For nPer := 1 to Len(aPerFerias)
	If SRF->( DbSeek(SRA->(RA_FILIAL+RA_MAT)+DtoS(aPerFerias[nPer,1])+cCodFer) )

		RecLock("SRF",.F.)

		SRF->RF_DATAATU := dDataBase //Grava a data da ultima atualizacao

		nFaltas := fGetFaltas(aPerFerias[nPer,1],aPerFerias[nPer,2])

		dDataAux := aPerFerias[nPer,2]

		If aPerFerias[nPer,3] > 0
			SRF->RF_DFALVAT += nFaltas + SRF->RF_DFALAAT
			SRF->RF_DFALAAT := 0
		Else
			If P_DECFALT
				SRF->RF_DFALAAT := NoRound(SRF->RF_DFALAAT + nFaltas,1)
			Else
				SRF->RF_DFALAAT += nFaltas
			EndIf
		EndIf

		SRF->RF_DFALVAT := Max(0,SRF->RF_DFALVAT)
		SRF->RF_DFALAAT := Max(0,SRF->RF_DFALAAT)

		SRF->(MsUnLock())
	EndIf
Next nPer

RestArea(aArea)

Return lRet

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³fGetFaltas    ³Autor³Leandro Drumond      ³ Data ³21/10/2013³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Obtem faltas no periodo									    ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³fGetFaltas     												³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³                 											³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³ Gpem120                                                    ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
Static Function fGetFaltas(dDataIni, dDataFim)
Local aArea		:= GetArea()
Local aAreaSRD	:= SRD->( GetArea() )
Local cAlias	:= GetNextAlias()
Local cQuery	:= ""
Local cVerbaPesq:= ""
Local cPd054 	:= aCodFol[54,1]
Local cPd055 	:= aCodFol[55,1]
Local cPd203 	:= aCodFol[203,1]
Local cPd242 	:= aCodFol[242,1]
Local cPd243 	:= aCodFol[243,1]
Local cPd244 	:= aCodFol[244,1]
Local cPd245 	:= aCodFol[245,1]
Local nRet		:= 0
Local oStFalta 	:= Nil

If dDataIni <= dDataFim
	SRD->(DbSetOrder(6)) 	//RD_FILIAL+RD_MAT+RD_PD+RD_ROTEIR+DTOS(RD_DATPGT)
	If SRD->( DbSeek(cFilSRA+SRA->RA_MAT+cPd054) ) .Or. SRD->( DbSeek(cFilSRA+SRA->RA_MAT+cPd055) ) .Or. SRD->( DbSeek(cFilSRA+SRA->RA_MAT+cPd203) ) .Or. ;
		SRD->( DbSeek(cFilSRA+SRA->RA_MAT+cPd242) ) .Or. SRD->( DbSeek(cFilSRA+SRA->RA_MAT+cPd243) ) .Or. SRD->( DbSeek(cFilSRA+SRA->RA_MAT+cPd244) ) .Or.;
		SRD->( DbSeek(cFilSRA+SRA->RA_MAT+cPd245) ) 

		oStFalta 	:= FWPreparedStatement():New()
		oStFalta:SetQuery(cQueryFalt)

		oStFalta:SetString(1,cFilSRA)
		oStFalta:SetString(2,SRA->RA_MAT)
		oStFalta:SetIn(3,aCodFalta)

		If lSegFaltas
			oStFalta:SetString(4,Dtos(dDataIni))
			oStFalta:SetString(5,Dtos(dDataFim))
		endIf

		cQuery := oStFalta:getFixQuery()
		dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAlias,.T.,.T.)

		While (cAlias)->(!Eof())
			If !lSegFaltas
				If AnoMes(sToD((cAlias)->RC_DATA)) < AnoMes(dDataIni) .or. AnoMes(sToD((cAlias)->RC_DATA)) > AnoMes(dDataFim)
					(cAlias)->(DbSkip())
					Loop
				EndIf
			EndIf
			cVerbaPesq := (cAlias)->RC_PD

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Pesquisa Faltas no Acumulado                                    ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If cVerbaPesq == cPd054
				If PosSrv(cPd054,SRA->RA_FILIAL,"RV_MEDFER") $ "S *SP"
					If P_DECFALT
						nRet += If((cAlias)->RC_TIPO1 == "D", (cAlias)->RC_HORAS, NoRound((cAlias)->RC_HORAS/Round(SRA->RA_HRSMES/30,2),2) )
					Else
						nRet += If((cAlias)->RC_TIPO1 == "D", (cAlias)->RC_HORAS, Int((cAlias)->RC_HORAS/Round(SRA->RA_HRSMES/30,2)) )
					EndIf
				EndIf
			EndIf
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Pesquisa Atraso no Acumulado                                    ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If cVerbaPesq == cPd055
				If PosSrv(cPd055,SRA->RA_FILIAL,"RV_MEDFER") $ "S *SP"
					If P_DECFALT
						nRet += If((cAlias)->RC_TIPO1 == "D", (cAlias)->RC_HORAS, NoRound((cAlias)->RC_HORAS/Round(SRA->RA_HRSMES/30,2),2) )
					Else
						nRet += If((cAlias)->RC_TIPO1 == "D", (cAlias)->RC_HORAS, Int((cAlias)->RC_HORAS/Round(SRA->RA_HRSMES/30,2)) )
					EndIf
				EndIf
			EndIf
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Pesquisa Faltas Mes Anterior no Acumulado                       ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If cVerbaPesq == cPd203
				If PosSrv(cPd203,SRA->RA_FILIAL,"RV_MEDFER") $ "S *SP"
					If P_DECFALT
						nRet += If((cAlias)->RC_TIPO1 == "D", (cAlias)->RC_HORAS, NoRound((cAlias)->RC_HORAS/Round(SRA->RA_HRSMES/30,2),2) )
					Else
						nRet += If((cAlias)->RC_TIPO1 == "D", (cAlias)->RC_HORAS, Int((cAlias)->RC_HORAS/Round(SRA->RA_HRSMES/30,2)) )
					EndIf
				EndIf
			EndIf
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Pesquisa Faltas (II) no Acumulado                               ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If cVerbaPesq == cPd242
				If PosSrv(cPd242,SRA->RA_FILIAL,"RV_MEDFER") $ "S *SP"
					If P_DECFALT
						nRet += If((cAlias)->RC_TIPO1 == "D", (cAlias)->RC_HORAS, NoRound((cAlias)->RC_HORAS/Round(SRA->RA_HRSMES/30,2),2) )
					Else
						nRet += If((cAlias)->RC_TIPO1 == "D", (cAlias)->RC_HORAS, Int((cAlias)->RC_HORAS/Round(SRA->RA_HRSMES/30,2)) )
					EndIf
				EndIf
			EndIf
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Pesquisa Atrasos (II) no Acumulado                              ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If cVerbaPesq == cPd243
				If PosSrv(cPd243,SRA->RA_FILIAL,"RV_MEDFER") $ "S *SP"
					If P_DECFALT
						nRet += If((cAlias)->RC_TIPO1 == "D", (cAlias)->RC_HORAS, NoRound((cAlias)->RC_HORAS/Round(SRA->RA_HRSMES/30,2),2) )
					Else
						nRet += If((cAlias)->RC_TIPO1 == "D", (cAlias)->RC_HORAS, Int((cAlias)->RC_HORAS/Round(SRA->RA_HRSMES/30,2)) )
					EndIf
				EndIf
			EndIf
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Pesquisa Reembolso de Faltas/Atrasos no Acumulado               ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If cVerbaPesq $ (cPd244 + "*" + cPd245)
				If PosSrv(cVerbaPesq, SRA->RA_FILIAL, "RV_MEDFER") $ "S *SP"
					nRet -= Iif( (cAlias)->RC_TIPO1 == "D", (cAlias)->RC_HORAS, Iif( P_DECFALT, NoRound((cAlias)->RC_HORAS/Round(SRA->RA_HRSMES/30,2),2), Int((cAlias)->RC_HORAS/Round(SRA->RA_HRSMES/30,2)) ) )
				EndIf
			EndIf
			(cAlias)->(DbSkip())
		EndDo

		(cAlias)->(DbCloseArea())
	EndIf

	RestArea(aArea)
	RestArea(aAreaSRD)
EndIf

Return nRet

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³GetAfPerda    ³Autor³Leandro Drumond      ³ Data ³21/10/2013³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Obtem afastamentos com retorno no mes/ano corrente cujo     ³
³          ³periodo de ferias devera ser prescrito ou prorrogado.       ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³GetTpPerda     												³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³                 											³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³ Gpem120                                                    ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
Static Function GetAfPerda(cFil)

Local aArea 		:= GetArea()
Local cAlias		:= GetNextAlias()
Local cQuery		:= ""
Local lRet			:= .F.
Local oStAfPerda 	:= FWPreparedStatement():New()

oStAfPerda:SetQuery(cQryAfPerd)

oStAfPerda:SetString(1,cFil)
oStAfPerda:SetString(2,(cAliasSRA)->RA_MAT)
oStAfPerda:SetString(3, cAnoProc + cMesProc )

cQuery := oStAfPerda:getFixQuery()

dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAlias,.T.,.T.)

lRet := (cAlias)->TOTALREG > 0

(cAlias)->(DbCloseArea())

RestArea(aArea)

Return lRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³fDeleteGpeºAutor  ³Microsiga           º Data ³  02/27/08   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Deleta registros do SRC diretamente no Banco                º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function fDeleteGpe(cFil, cMat, cProc, cPer, cSem, cRot)

Local cAliasSRC	:= InitSqlName("SRC")
Local cQuery 	:= ""

cQuery := "DELETE FROM " + cAliasSRC + " "
cQuery += "WHERE RC_FILIAL  = '" + cFil + "'"
cQuery += "  AND RC_MAT     = '" + cMat + "'"
cQuery += "  AND RC_PROCES  = '" + cProc + "'"
cQuery += "  AND RC_PERIODO = '" + cPer  + "'"
cQuery += "  AND RC_SEMANA  = '" + cSem  + "'"
cQuery += "  AND RC_ROTEIR  = '" + cRot  + "'"

TcSqlExec(cQuery)

Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³fDeleteRGBºAutor  ³Microsiga           º Data ³  09/09/08   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Deleta registros da RGB diretamente no Banco                º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function fDeleteRGB(cFilSRA, cMatSRA, cTemMov)

Local cAliasRGB	:= GetNextAlias()
Local cFilter 	:= ""
Local cWhere	:= ""
Local cRGBSqlName
Local cQuery
Local cCpoRecno

If ( Select( cAliasRGB ) > 0 )
	( cAliasRGB )->( dbCloseArea() )
EndIf

cRGBSqlName := InitSqlName( "RGB" )
cCpoRecno 	:= "R_E_C_N_O_"

cFilter := "     RGB_PROCES = '" + cProcesso  + "'"
cFilter += " AND RGB_PERIOD = '" + cPeriodo + "'"
cFilter += " AND RGB_SEMANA = '" + cNumPag  + "'"
cFilter += " AND RGB_ROTEIR = '" + cRoteiro + "'"
cFilter += " AND RGB_FILIAL = '" + cFilSRA + "'"
cFilter += " AND RGB_MAT = '" + cMatSRA + "'"
cFilter := "%" + cFilter +"%"

cFilter := Substr( cFilter, 2, (Len(cFilter)-2) )
cQuery := "DELETE FROM "  + cRGBSqlName + " WHERE "

cQueryDelet := ( cQuery + cFilter )

If cTemMOv <> "S"
	cTmpAlias := GetNextAlias()
	cWhere	:= " RGB_PROCES = '" + cProcesso  + "'"
	cWhere  += " AND RGB_PERIOD = '" + cPeriodo + "'"
	cWhere	+= " AND RGB_SEMANA = '" + cNumPag  + "'"
	cWhere  += " AND ( RGB_ROTEIR = '" + cRoteiro + "' OR ( RGB_ROTORI = '" + cRoteiro + "'))" //verifica qualquer roteiro integrado - RES/FER/etc...
	cWhere  += " AND RGB_FILIAL = '" + cFilSRA + "'"

	cWhere  := "%" + cWhere + "%"

	BeginSQL ALIAS cTmpAlias
		SELECT
			COUNT(*) AS TOTALREG
		FROM
			%Table:RGB% RGB
		WHERE
			RGB.%NotDel% AND
			%Exp:cWhere%
	EndSQL

	cTemMov := If( (cTmpAlias)->TOTALREG > 0, "S", "N" )

	(cTmpAlias)->(DBCloseArea())
EndIf

TcSqlExec( cQueryDelet )

Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³fUpdateRGBºAutor  ³Microsiga           º Data ³  12/01/16   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Deleta registros da RGB diretamente no Banco                º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function fUpdateRGB(cFilSRA, cMatSRA,cRotFunc)

Local cQuery 	:= ""
Local cNameFile := RetSqlName("RGB")
Local lIrNeg	:= Len(aCodFol) >= 1726 .And. !Empty(aCodFol[1726,1]) .And. !Empty(aCodFol[1727,1])
Local cVb		:= "'" + aCodFol[106,1] + "', '" + aCodFol[107,1] + "'"

DEFAULT cRotFunc := fGetRotOrdinar()

If lIrNeg
	cVb += + "', '" + aCodFol[1727,1] + "'"
EndIf

cQuery := "UPDATE "
cQuery += cNameFile + " "
cQuery += "SET RGB_ROTEIR = '" + cRotFunc + "' "
cQuery += "WHERE RGB_FILIAL = '" + cFilSRA + "' "
cQuery += "AND RGB_MAT = '" + cMatSRA + "' "
cQuery += "AND RGB_PROCES = '" + cProcesso  + "' "
cQuery += "AND RGB_PERIOD = '" + cPeriodo + "' "
cQuery += "AND RGB_SEMANA = '" + cNumPag  + "' "
cQuery += "AND RGB_ROTEIR = '" + fGetCalcRot("2") + "'"
cQuery += "AND RGB_PD IN (" + cVb + ")"

TcSqlExec( cQuery )

Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³GravaSRF  ºAutor  ³Microsiga           º Data ³  06/02/08   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Atualiza o SRF para Portugal                               º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function GravaSRF(cFilSRA)

Local cCodFer 	:= aCodFol[72,1]
Local dBaseAtu
Local nFaltas	:= 0
Local nTotDias	:= 0
Local nTotAux	:= 0
Local nx 		:= 0

DbSelectArea( "SRH" )
DbSetOrder( RetOrder( "SRH", "RH_FILIAL+RH_MAT+DtoS(RH_DATABAS)+DtoS(RH_DATAINI))" ))

If	DbSeek( (cAliasSRA)->RA_FILIAL + (cAliasSRA)->RA_MAT )
	While !SRH->( Eof() ) .And. SRH->( RH_FILIAL + RH_MAT ) == (cAliasSRA)->RA_FILIAL + (cAliasSRA)->RA_MAT

		If MesAno(SRH->RH_DATAINI) == (cAnoProc+cMesProc) .And. SRH->RH_TIPO == '1'

			aPerFerias	:= {}
			nTotDiaPer	:= Iif(Year(SRA->RA_ADMISSA)==Year(SRH->RH_DATABAS), 20, 22)
			nTotDias	:= SRH->RH_DFERIAS

			DbSelectArea("SRF")
			DbSetOrder(2)
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Se recebeu todos os dias de direito, atualiza DIAS PAGOS e   ³
			//³ STATUS e gera novo periodo.                                  ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If DbSeek( SRH->RH_FILIAL + SRH->RH_MAT + cCodFer + DtoS(SRH->RH_DATABAS) )
				nFaltas := SRH->RH_DFALTAS
				TabFaltas(@nFaltas)
				nTotAux := nTotDias + nFaltas

				If nTotAux >= nTotDiaPer .Or. nTotAux + SRF->RF_DFERANT >= nTotDiaPer

					RecLock( "SRF" , .F. )
					SRF->RF_DFERANT += nTotDias
					SRF->RF_STATUS  := "3"
					SRF->( MsUnLock() )

					dBaseAtu := SRH->RH_DBASEAT+1

					If RCA->( DbSeek( xFilial( "RCA" ) + "P_FERPAC" ) )
						lPerFeAc := ( AllTrim( RCA->RCA_CONTEU ) == "S" )
					EndIf

					If SRA->(Type("RA_FERPAC")) # "U" .and. !Empty(SRA->RA_FERPAC)
						lPerFeAc := ( AllTrim( SRA->RA_FERPAC ) == "S" )
					EndIf

					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Apura periodos posteriores ao calculado                      ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					Calc_Fer(aPerFerias,dDtaLimite,,,,,,,dBaseAtu)

					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Cria o periodo posterior (se ainda nao existir) 			 ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					For nX := 1 to Len(aPerFerias)

						If !SRF->( DbSeek( SRH->RH_FILIAL + SRH->RH_MAT + cCodFer + DtoS(aPerFerias[nX][01]) ) )
							RecLock( "SRF" , .T. )
							SRF->RF_FILIAL	:= SRH->RH_FILIAL
							SRF->RF_MAT		:= SRH->RH_MAT
							SRF->RF_PD		:= cCodFer
							SRF->RF_DIASDIR := nTotDiaPer
							SRF->RF_STATUS	:= "1"
							SRF->RF_DATABAS := aPerFerias[nX][01]
							SRF->RF_DATAFIM := aPerFerias[nX][02]
							SRF->RF_DFERVAT := aPerFerias[nX][03]
							SRF->RF_DFERAAT := aPerFerias[nX][04]
							SRF->RF_DFERANT := aPerFerias[nX][14]
							SRF->RF_DVENPEN := aPerFerias[nX][11]
							SRF->RF_IVENPEN := aPerFerias[nX][12]
							SRF->RF_FVENPEN := aPerFerias[nX][13]
							SRF->RF_DFALVAT := aPerFerias[nX][15]
							SRF->RF_DFALAAT := aPerFerias[nX][16]
							SRF->( MsUnLock() )
						EndIf

					Next nX
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Se nao foram dados todos os dias de direito, atualiza DIAS ANTECIPADOS ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				Else
					RecLock( "SRF" , .F. )
					SRF->RF_DFERANT += nTotDias
					SRF->( MsUnLock() )
				EndIf
			EndIf
		EndIf
		SRH->( DbSkip() )

	EndDo
EndIf

Return( Nil )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³VerNewPerSRF ºAutor  ³Valdeci Lira     º Data ³  20/08/09   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Verifica a necessidade de gerar um novo periodo de ferias  º±±
±±º          ³para o funcionario                                          º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function VerNewPerSRF(cFilSRA,lProg)
Local aArea			:= GetArea()
Local cKeyFind  	:= ""
Local cOrder		:= ""
Local cWhere		:= ""
Local cAliasQry 	:= ""
Local cDayIni		:= "01"
Local cMonthIni 	:= "01"
Local cFilSRF		:= Space(FWGETTAMFILIAL)
Local cPdSrf		:= aCodFol[72,1]
Local cMat			:= SRA->RA_MAT
Local cYearPer		:= RCH->RCH_ANO
Local cMonthPer 	:= RCH->RCH_MES
Local dFecAntVac   	:= CtoD("//")
Local dBsEmplComp  	:= CtoD("//")
Local dBsEmployee  	:= CtoD("//")
Local dBsLastVac	:= CtoD("//")
Local dYearFinPeriod:= CtoD("//")
Local dDatePresc 	:= CtoD("//")
Local dDateIni  	:= RCH->RCH_DTINI
Local dDateFin		:= RCH->RCH_DTFIM
Local lFindSRF		:= .T.
Local lUltPerAno	:= If(RCH->(Type("RCH_ULTANO")) <> "U",RCH->RCH_ULTANO, "2")
Local lUltPerMes	:= If(RCH->(Type("RCH_ULTMES")) <> "U",RCH->RCH_ULTMES, "2")
Local nYearsPassed	:= 0
Local nYearsMax 	:= 0
Local nDProp		:= 0
Local lAniv			:= .T.

Private _aPerSel := {}

DEFAULT cFilSRA := Space(FWGETTAMFILIAL)
Default lProg := .F.

cPDSRF := IIF(!lProg,aCodFol[72,1],aCodFol[1383,1])

IF cPaisLoc == "COL"
	AADD(_aPerSel,{ RCH->RCH_PER, RCH->RCH_NUMPAG,RCH-> RCH_ROTEIR, RCH->RCH_MES,RCH-> RCH_ANO,RCH-> RCH_DTINI,RCH-> RCH_DTFIM,RCH-> RCH_PROCES })
EndIf

If Type("SRA->RA_FECREI") # "U" .And. !Empty(SRA->RA_FECREI)
	dBsEmployee := SRA->RA_FECREI
ElseIf cPaisLoc =="ARG" .And. !Empty(SRA->RA_DTREC)
	dBsEmployee := 	SRA->RA_DTREC
Else
	dBsEmployee := SRA->RA_ADMISSA
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Tratamento para geracao de novo registro quando as ferias sao por ano civil ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If cPerFeAc == "S"
	If cMonthPer == "12" .And. lUltPerAno == "1" .And. lUltPerMes == "1"
		cDayIni := If(cYearPer == Str(Year(dBsEmployee),4), Str(Day(dBsEmployee),2),"01" )
		cMonthIni := If(cYearPer == Str(Year(dBsEmployee),4), Str(Month(dBsEmployee),2), "01" )
		dBsEmplComp := CtoD(cDayIni + "/"+ cMonthIni +"/" + StrZero(Val(cYearPer)+1,4))
    Else
		cDayIni := If(cYearPer == Str(Year(dBsEmployee),4), Str(Day(dBsEmployee),2),"01" )
		cMonthIni := If(cYearPer == Str(Year(dBsEmployee),4), Str(Month(dBsEmployee),2), "01" )
		dBsEmplComp := CtoD(cDayIni + "/"+ cMonthIni +"/" + StrZero(Val(cYearPer),4))
	EndIf
	If cPaisLoc == "ARG" .And. cMonthPer == "09" .And. lUltPerMes == "1"
		dFecAntVac := CtoD("29/09/"+ StrZero(Val(cYearPer),4))
	EndIf
Else
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica se o periodo de fechamento compreende a data base   ³
	//³ para a aquisicao de um novo periodo de ferias para o func.   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If (STRZERO(Day(dBsEmployee),2)) == "01" .AND.  STRZERO(Month(dBsEmployee),2) == "01" .and. cPaisLoc == "CHI"
		dBsEmplComp := CTOD(STRZERO(Day(dBsEmployee),2)+"/"+STRZERO(Month(dBsEmployee),2)+"/"+STRZERO(Val(cYearPer) + 1,4))
	Else
		dBsEmplComp := CTOD(STRZERO(Day(dBsEmployee),2)+"/"+STRZERO(Month(dBsEmployee),2)+"/"+STRZERO(Val(cYearPer),4))
EndIf
Endif

DbSelectArea("SRF")
SRF->(DbSetOrder( nOrdSR8SRF ))
If Empty(xFilial("SRF"))
	cFilSRF := Space(FWGETTAMFILIAL)
Else
	cFilSRF:= cFilSra
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Se nao existir o periodo do ano do fechamento RCH, a rotina  ³
//³ ira criar                                                    ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
cKeyFind := cFilSRF + SRA->RA_MAT + cPdSRF + DtoS(dBsEmplComp)
If !(SRF->(dbSeek( cKeyFind )))
	IF !(cPaisLoc $ "COL|CHI")
		MkNewPerSRF(cFilSra, cMat, cPdSrf, dDateIni)
	ElseiF cPaisLoc $ "COL"
		MkNewSRFCol(cFilSra, cMat, cPdSrf, dBsEmplComp,.t.)
	ElseiF cPaisLoc $ "CHI"
		MkNewSRFChi(cFilSra, cMat, cPdSrf, dDateFin,.t.,lProg)
	EndIf
EndIf

cAliasQry := GetNextAlias()

cOrder := "%"
cOrder += " SRF.RF_FILIAL, SRF.RF_MAT, SRF.RF_PD, SRF.RF_DATABAS "
cOrder += "%"

cWhere := "%"
cWhere += " SRF.RF_FILIAL = '" + cFilSRF				+ "' AND "
cWhere += " SRF.RF_MAT    = '" + SRA->RA_MAT			+ "' AND "
cWhere += " SRF.RF_PD     = '" + cPdSRF 				+ "' AND "
cWhere += "%"

BeginSql alias cAliasQry
	SELECT 		SRF.R_E_C_N_O_ NRECNO
	FROM 		%table:SRF% SRF
	WHERE 		%exp:cWhere%
				SRF.%NotDel%
	ORDER BY    %exp:cOrder%
EndSql

If ( (cAliasQry)->NRECNO == 0 )
	lFindSRF := .F.
Else
	SRF->(dbGoTo((cAliasQry)->NRECNO))
EndIf

(cAliasQry)->(dbCloseArea())

If lFindSRF

	While (SRF->(!Eof()) .AND. SRF->(RF_FILIAL+RF_MAT+RF_PD) == (cFilSRF + SRA->RA_MAT + cPdSRF) )

		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Calcula o tempo que passou desde o vencimento do dias de dir³
		³ate a data final do periodo posicionado, se a quantidade    ³
		³resultante for maior que o configurado em RCJ entao o per.  ³
		³de dias de direito sera prescrito.                          ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		*/
		If cPaisLoc $ "MEX|ARG|PER|PAR"
			nYearsMax  		:= RCJ->RCJ_VIGVAC
		Else
			nYearsMax  		:= RCJ->RCJ_VIGVAC/365
		EndIf
		dBsLastVac 		:= SRF->RF_DATAFIM
		dYearFinPeriod 	:= RCH->RCH_DTFIM

		dDatePresc		:= ( YearSum( dBsLastVac, Int(nYearsMax) ) )							//Soma o numero de anos na data
		dDatePresc		:= MonthSum( dDatePresc, ( ( nYearsMax - Int(nYearsMax) ) * 12 ) )		//Soma o numero de meses

		If !(cPaisLoc $ "CHI|MEX|ARG|PER") // Para chile se preescribirán después de procesar todos los registros incluyendo ausencias.
			If dYearFinPeriod >= dDatePresc .And. SRF->RF_STATUS != "3"
				RecLock("SRF", .F.)
				SRF->RF_STATUS := "2" //Prescrito
				If cPaisLoc == "COL"
					SRF -> RF_DFERVAT := SRF -> RF_DIASDIR
					SRF -> RF_DIASANT := 0
					SRF -> RF_DFERAAT := 0
				EndIf
				SRF->(MsUnlock())
			EndIf
		EndIF
		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Se o periodo estiver vencido e a prescricao for menor que a ³
		³data do calculo o status sera alterado para ativo.          ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		If dDatePresc > dYearFinPeriod .And. SRF->RF_STATUS == "2"
			RecLock( "SRF", .F. )
			SRF->RF_STATUS := "1"
			SRF->( MsUnLock() )
		EndIf

		If cPaisLoc <> "ARG"
			If cPaisLoc $ "CHI|MEX|PER"
				dBsEmplComp := SRF->RF_DATAFIM
			EndIf
			lAniv :=   SRF->RF_DFERVAT == 0 //lAniv :=   SRF->RF_DFERVAT <> 0
			If cPaisLoc=="MEX" .and. cTpRoteir == "A" //Roteiro A = Aplicacion Finiquito
				lAniv :=   SRF->RF_DFERVAT == 0
			EndIf
			If cPaisLoc $ "MEX" .AND. dBsEmplComp <= dDateFin .AND. lAniv  //If cPaisLoc $ "MEX" .AND. dBsEmplComp >= dDateIni .And. dBsEmplComp <= dDateFin .AND. lAniv
				RecLock( "SRF" , .F. )
				SRF->RF_DFERVAT := SRF->RF_DIASDIR
				SRF->RF_DIASANT := 0
				SRF->(MsUnlock())
			ElseIf !(cPaisLoc $ "MEX") .AND. dBsEmplComp <= dDateFin .and.  SRF->RF_DFERVAT == 0
					RecLock( "SRF" , .F. )
					SRF->RF_DFERVAT := SRF->RF_DIASDIR	//Dias vencidos
					SRF->RF_DIASANT := 0
					If cPaisLoc $ "COL/PER/CHI"
						SRF->RF_DFERAAT := 0
					EndIf
					SRF->( MsUnlock() )
			ElseIF cPaisLoc $ "CHI/PER/PAR" .and. SRF->RF_DFERVAT == 0
				 // Para los registros donde la fecha de inicio RF_DATABAS es posterior a la
				 // fecha de cierre RCH_DTFIM  no debe calcular ni actualizar Proporcionales:
				 IF !lProg	.and. (SRF->RF_DATABAS<= dDateFin .AND. SRF->RF_DATAFIM > dDateFin)
				 	// Actualiza vacaciones proporcionales Chile
					nDProp := fGenPropCh()
					RecLock( "SRF" , .F. )
						SRF->RF_DFERAAT := nDProp
					SRF->( MsUnlock() )
				EndIF
			ElseIf cPaisLoc $ "COL".and. SRF->RF_DIASDIR <> SRF->RF_DFERVAT
					nYearsPassed := (SRF->RF_DIASDIR / 365) * ( (RCH-> RCH_DTFIM - SRF-> RF_DATABAS ) + 1 )
					RecLock( "SRF" , .F. )
						SRF->RF_DFERAAT := nYearsPassed
					SRF->( MsUnlock() )
			Endif
		ElseIf cPaisLoc == "ARG"
			If !Empty(dFecAntVac)
				If ((dFecAntVac >= dDateIni) .And. ( dFecAntVac < dDateFin))
					nYearsPassed := DateDiffYear( (SRF->RF_DATABAS)-1, dDateFin)
					nDiasFer := 0
					nDiasProp := 0
					If( nYearsPassed == 0 .And. SRF->RF_DFERVAT == 0)
						//Se não existe dias vencidos e dias de antecipo eh diferente a de direito,
						//entao libero os dias de direito igual ao de antecipos
						If (SRF->RF_DIASANT != SRF->RF_DIASDIR)
							RecLock( "SRF" , .F. )
							SRF->RF_DIASANT := SRF->RF_DIASDIR //Libero ?
							SRF->( MsUnLock() )
						EndIf
					EndIf
				EndIf
			Else
				//Aqui só ficarão vencidos os dias de direito do ano(SRF) igual ano RCH em fechamento
				If( lUltPerAno == "1" .AND. lUltPerMes = "1" .AND. SRF->RF_DFERVAT == 0 .AND. YEAR(SRF->RF_DATABAS) == VAL(RCH->RCH_ANO))
					RecLock( "SRF" , .F. )
					SRF->RF_DIASANT := 0
					SRF->RF_DFERVAT := SRF->RF_DIASDIR
					SRF->( MsUnLock() )
				EndIf
			EndIf
		EndIf
		SRF->(DbSkip())
	EndDo
EndIf

RestArea(aArea)

Return( Nil )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³GrvSRFCol ³Autor³Abel Ribeiro               ³Data³04/12/2008³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Atualiza SRF, conforme afastamentos no Periodo  			³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³GPEM120				                  	   					³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function GrvSRFCol(cFilSRA)
Local cQuery	:= ""
Local cAlias	:= ""
Local cTipoAf 	:= ""
Local dDtIni1 	:= CtoD("//")
Local dDtIni2  	:= CtoD("//")
Local lRet		:= .F.
Local lAfast 	:= .F.
Local nLinAtu	:= 0
Local nLinha   	:= 0

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Busca os dias de afastamento do periodo corrente.  			 |
//³ 5=Suspensao de Contrato de Trabalho ou 1=Ausencia sem Pagto  |
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
aSR8Dados  := {}   //ARRAY para armazenar os dias de afastamento para posterior tratamento de dias aplicados

nDiasAf := 0
nDNAPLIC:= 0

dDtIniFec:= RCH->RCH_DTINI
dDtFimFec:= RCH->RCH_DTFIM

cAlias := "Q1"
cQuery := " SELECT RCM_TIPO FROM " + RetSqlName("RCM")
cQuery += " WHERE RCM_TIPOAF IN ( '1','5' ) AND "              //Somente Tipo 1= Ausencia sem pagto e 5=Suspensao de COntrato de  Trabalho
cQuery += " D_E_L_E_T_ = ' ' "

cQuery := ChangeQuery(cQuery)
dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAlias,.T.,.T.)

While (cAlias)->(!Eof())
	cTipoAf += "'" + (cAlias)->RCM_TIPO + "'"
	(cAlias)->(DbSkip())
	If (cAlias)->(!Eof())
		cTipoAf += ","
	EndIf
EndDo
(cAlias)->(DbCloseArea())

If !Empty(cTipoAf)
    If Empty(cTipoAf)
    	cTipoAf:= "''"
    EndIf
	cAlias := "Q2"
	cQuery := " SELECT * FROM " + RetSqlName("SR8") + " SR8 "
	cQuery += " WHERE R8_FILIAL = '" + cFilSRA + "' AND "
	cQuery +=       " R8_MAT = '" + (cAliasSRA)->RA_MAT + "' AND "
	cQuery +=       " R8_TIPOAFA IN ( " + cTipoAf + ") AND "
	cQuery +=       " D_E_L_E_T_ = ' ' "

	cQuery := ChangeQuery(cQuery)
	dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAlias,.T.,.T.)
	lAfast := IIF(RECCOUNT() > 0,.T.,.F.)

    While (cAlias)->(!Eof()) .And. (cAlias)->( R8_FILIAL + R8_MAT ) = SRA->( RA_FILIAL + RA_MAT )

		/*
		dDtIniFec - Data Inicial do Periodo	(01/05/08)
		dDtFimFec - Data Final do Periodo		(30/05/08)
		dDTIni1	- Variavel Data Inicial Comparacao
		dDTIni2	- Variavel Data Final Comparacao
		*/
		If (cAlias)->R8_DATAFIM < DtoS(dDtIniFec)
			(cAlias)->(DbSkip() )
			Loop
		EndIf
		If (cAlias)->R8_DATAINI > DtoS(dDtIniFec)
			dDTIni1 := (cAlias)->R8_DATAINI
		Else
			dDTIni1 := dDtIniFec
		EndIf
		If (cAlias)->R8_DATAFIM < DtoS(dDtFimFec)
			dDTIni2 := (cAlias)->R8_DATAFIM
		Else
			dDTIni2 := dDtFimFec
		EndIf

		If ValType(dDTIni2) == 'C'
			dDtIni2 := STOD(dDTIni2)
		EndIf
		If ValType(dDTIni1) == 'C'
			dDtIni1 := STOD(dDTIni1)
		EndIf

		nDiasAf += ( dDTIni2 - dDTIni1 + 1 )

		aAdd(aSR8Dados,{ dDTIni1,dDTIni2,nDiasAf } )

		lAfast := .T.

		(cAlias)->(DbSkip() )
	EndDo

    If lAfast
	  For nLinAtu := 1 To Len(aSR8dados)
	      dDtIni	:= aSR8dados[nLinAtu,1]      //aSR8Dados[1] = Data Inicial
	      dDtFim	:= aSR8dados[nLinAtu,2]      //aSR8Dados[2] = Data Final
	      nDuracao  := aSR8dados[nLinAtu,3]      //aSR8Dados[3] = Duracao Dias Afastamento

	      For nLinha := 1 To Len(aSR8dados)
 	          If (nLinha <> nLinAtu .AND. dDtIni  >= aSR8Dados[nLinha,1])
			     If (!Empty(aSR8dados[nLinha,2]) .and. ( dDtIni >= aSR8Dados[nLinha,1]) .and. (dDtIni <= aSR8Dados[nLinha,2]) .and. ( (dDtFim > aSR8Dados[nLinha,2]) .OR. Empty(dDtFim)))
				    nDNAplic += (aSR8Dados[nLinha,2] - dDtIni + 1)
				    Exit
			     ElseIf (!Empty(aSR8Dados[nLinha,2]) .and. (dDtFim >= aSR8Dados[nLinha,1]) .and. (dDtFim <= aSR8Dados[nLinha,2]) .and. (dDtIni < aSR8Dados[nLinha,1])) .OR. ;
			   	        (Empty(aSR8Dados[nLinha,2])  .and. (dDtIni <= aSR8Dados[nLinha,1]) .and. (dDtFim >= aSR8Dados[nLinha,1]))
				        nDNAplic += (dDtFim - aSR8Dados[nLinha,1] + 1)
				         Exit
			     ElseIf (!Empty(aSR8Dados[nLinha,2]) .and. (dDtIni >= aSR8Dados[nLinha,1]) .and. (dDtFim <= aSR8Dados[nLinha,2]))
				        nDNAplic += nDuracao
				        Exit
			     ElseIf (!Empty(aSR8Dados[nLinha,2]) .and. (dDtIni < aSR8Dados[nLinha,1]) .and. (dDtFim > aSR8Dados[nLinha,2]))
						nDNAplic += nDuracao
						Exit
   				     EndIf
		      EndIf
	      Next y1
      Next x1

      nDiasAf :=( nDiasAf - nDNAPLIC )
	EndIf

	(cAlias)->(DbCloseArea())
EndIf

If lAfast
   DbSelectArea( "SRF" )
   DbSetOrder( RetOrder( "SRF", "RF_FILIAL+RF_MAT+DtoS(RF_DATABAS)+RF_PD" ))
   SET FILTER TO RF_FILIAL + RF_MAT  == (cAliasSRA)->RA_FILIAL + (cAliasSRA)->RA_MAT

   SRF->(dbGobottom())	//Posiciona no Fim do arquivo para buscar o ultimo periodo em aberto
   If SRF->RF_STATUS == '1'
	  RecLock( "SRF" , .F. )
	  SRF->RF_DATAFIM := SRF->RF_DATAFIM + nDiasAF
	  SRF->( MsUnLock() )
   EndIf
   SET FILTER TO     //Desativa o Filtro
EndIf

Return( lRet )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³GrvSRFven ºAutor  ³ Ademar Fernandes   º Data ³  10/02/09   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Atualiza o SRF para Venezuela                              º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function GrvSRFven(cFilSRA)

Local aTabUTIL 	:= {}
Local dBaseAtu 	:= RCH->RCH_DTINI
Local dDtInic  	:= CtoD("01/01/"+Str((Year(dBaseAtu)),4))
Local dDtFinal 	:= CtoD("31/12/"+Str((Year(dBaseAtu)),4))
Local nTotDias	:= (cAliasSRC)->RC_HORAS
Local nTotDiaPer:= 0

If Year(SRA->RA_ADMISSA) == Year(dBaseAtu)
	dDtInic := SRA->RA_ADMISSA
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Busca dias de utilidade na tabela S011                       ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
fRetTAB( @aTabUTIL, "S011", 4, 8, dBaseAtu, SRA->RA_SINDICA )
If Len(aTabUTIL) > 0
	nTotDiaPer := aTabUTIL[6]
EndIf

DbSelectArea("SRF")
DbSetOrder(2)

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Se recebeu todos os dias de direito, atualiza DIAS PAGOS e   ³
//³ STATUS e gera novo periodo.                                  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If DbSeek( SRA->RA_FILIAL + SRA->RA_MAT + aCodFol[881,1] + DtoS(dDtInic) )
	If nTotDias >= nTotDiaPer .Or. ;
	   nTotDias + SRF->RF_DFERANT >= nTotDiaPer

		RecLock( "SRF", .F. )
		SRF->RF_DFERANT += nTotDias
		SRF->RF_STATUS  := "3"
		If Empty(SRF->RF_DIASDIR) .And. nTotDiaPer > 0
			SRF->RF_DIASDIR := nTotDiaPer
		EndIf
		SRF->( MsUnLock() )

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Cria o periodo posterior (se ainda nao existir) 			 ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If !SRF->( DbSeek( SRA->RA_FILIAL + SRA->RA_MAT + aCodFol[881,1] + DtoS(dDtInic) ) )
			RecLock( "SRF", .T. )
			SRF->RF_FILIAL	:= SRH->RH_FILIAL
			SRF->RF_MAT		:= SRH->RH_MAT
			SRF->RF_PD		:= aCodFol[881,1]
			SRF->RF_DIASDIR := nTotDiaPer
			SRF->RF_STATUS	:= "1"
			SRF->RF_DATABAS := dDtInic
			SRF->RF_DATAFIM := dDtFinal
			SRF->( MsUnLock() )
		EndIf
	Else
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Se nao foram dados todos os dias de direito, atualiza DIAS ANTECIPADOS ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		RecLock( "SRF", .F. )
		SRF->RF_DFERANT += nTotDias
		If Empty(SRF->RF_DIASDIR) .And. nTotDiaPer > 0
			SRF->RF_DIASDIR := nTotDiaPer
		EndIf
		SRF->( MsUnLock() )
	EndIf
EndIf

Return( Nil )
/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³fLoadRCM  ³Autor³Igor Franzoi               ³Data³10/10/2008³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Carrega os dados da tabela RCM - Tipos de Ausencia			³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³GPEM120				                  	   					³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function fLoadRCM( aData, aFields )

Local aArea		:= GetArea()
Local cCpos		:= ""
Local cAliasRCM	:= "RCM"
Local nCont		:= 0

aFields := 	(cAliasRCM)->(dbStruct())

For nCont := 1 To Len(aFields)

	If ( aFields[nCont,01] == "RCM_FILIAL" )
		nPosRCMFil := nCont
	ElseIf ( aFields[nCont,01] == "RCM_TIPO" )
		nPosRCMTip := nCont
	ElseIf ( aFields[nCont,01] == "RCM_PD" )
		nPosRCMPd := nCont
	EndIf

	If (nCont > 1)
		cCpos += " , " + aFields[ nCont, 01 ]
	Else
		cCpos += aFields[ nCont, 01 ]
	EndIf
Next
cCpos := "%"+cCpos+"%"

cAliasRCM := GetNextAlias()

BeginSql Alias cAliasRCM
	%NoParser%
	SELECT
		%Exp:cCpos%
	FROM
		%Table:RCM% RCM
	WHERE
		RCM.%NotDel%
	ORDER BY
		%Order:RCM%
EndSql

//Adiciona todos os tipos de Ausencia ao Array
While (cAliasRCM)->(!Eof())
	aAdd( aData, {} )
	For nCont := 1 To Len(aFields)
		aAdd( aData[Len(aData)], (cAliasRCM)->&(aFields[ nCont, 01 ]) )
	Next
	(cAliasRCM)->(DbSkip())
EndDo


#IFDEF TOP
	If ( Select( cAliasRCM ) > 0 )
		( cAliasRCM )->( dbCloseArea() )
	EndIf
#ENDIF

RestArea(aArea)

Return (Nil)

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³fRecAusSR8³Autor³Igor Franzoi               ³Data³10/10/2008³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³Gera um registro de Afastamento no SR8 - Ausentismo			³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³GPEM120				                  	   					³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function fRecAusSR8( aData, aFields, nPosRCM )

Local aArea		:= GetArea()
Local aTamSR8	:= {}
Local aFieldLog	:= {}

Local cKey		:= ""
Local cTipo		:= ""
Local cNumId	:= ""
Local cField	:= ""
Local cOrder	:= ""
Local cWhere	:= ""
Local cAliasQry	:= ""
Local cFromTable:= ""
Local cAlias	:= "SR8"

Local dDtaFim	:= CtoD("//")

Local lFind		:= .F.

Local nCont		:= 0

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Geracao do NUMID											  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
cNumId := cAlias + (cAliasSRA)->RA_MAT + (cAliasSRC)->RC_PD + ;
				  StrZero(YEAR(dDtaIni),4) + ;
			 	  StrZero(Month(dDtaIni),2) + ;
			 	  StrZero(DAY(dDtaIni),2)

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ O registro que vem do SRC e sempre ferias - "F" Tabela SX5  ³
³ Essa tabela nao e utilizada, porem o valor e preenchido para³
³ formar a chave (X5_TABELA)								  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
cTipo := "F"

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Calcula a data final do Afastamento						  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
GpeCalend(,,,,,dDtaIni,@dDtaFim,Abs( (cAliasSRC)->RC_HORAS ),"F",,.F.,cAliasSRA)

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Monta chave para a pesquisa de registro					  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
cKey := (cAliasSRA)->RA_FILIAL+(cAliasSRA)->RA_MAT+DtoS(dDtaIni)+aData[ nPosRCM, nPosRCMTip ]

DbSelectArea(cAlias)
(cAlias)->( DbSetOrder( nOrdGetSR8 ) )

cAliasQry := GetNextAlias()

cOrder := "%"
cOrder += " SR8.R8_FILIAL, SR8.R8_MAT, SR8.R8_DATAINI, SR8.R8_TIPOAFA, SR8.R8_DIASEMP "
cOrder += "%"

cWhere := "%"
cWhere += " SR8.R8_FILIAL  = '" + (cAliasSRA)->RA_FILIAL + "' AND "
cWhere += " SR8.R8_MAT     = '" + (cAliasSRA)->RA_MAT    + "' AND "
cWhere += " SR8.R8_DATAINI = '" + DtoS(dDtaIni) + "' AND "
cWhere += " SR8.R8_TIPOAFA = '" + aData[ nPosRCM, nPosRCMTip ] + "' "
cWhere += "%"

cFromTable := "% "+cNamSR8Tab+" SR8 %"

BeginSql alias cAliasQry
	SELECT 		SR8.R_E_C_N_O_ NRECNO
	FROM 		%exp:cFromTable%
	WHERE 		%exp:cWhere%
				SR8.%NotDel%
	ORDER BY    %exp:cOrder%
EndSql

If !( (cAliasQry)->NRECNO == 0 )
	lFind := .T.
EndIf

(cAliasQry)->(dbCloseArea())

/*/
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Caso encontre um registro, cria log no fim do processo	  ³
³ de fechamento												  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
If lFind

		If Empty(aLogErros[6])
			aFieldLog := { "R8_FILIAL", "R8_MAT", "R8_DATAINI", "R8_TIPO", "R8_TIPOAFA" }
			aAdd( aLogErros[6], Gp120CabLog( "SR8", aFieldLog, @aTamSR8 ) ) 					// Cabecalho do Log de Erros
			aAdd( aLogErros[6], "" )
		EndIf

		aAdd( aLogErros[6],	(cAliasSRA)->RA_FILIAL	+ Space( aTamSR8[1] )		+;
							(cAliasSRA)->RA_MAT + Space( aTamSR8[2]	)			+;
							DtoC(dDtaIni) + Space( aTamSR8[3] )					+;
							cTipo + Space( aTamSR8[4] )							+;
							aData[ nPosRCM, nPosRCMTip ] + Space( aTamSR8[5])	 )

Else

	RecLock(cAlias,.T.,.T.)
		(cAlias)->R8_FILIAL 	:= (cAliasSRA)->RA_FILIAL
		(cAlias)->R8_MAT   		:= (cAliasSRA)->RA_MAT
		(cAlias)->R8_DATA   	:= dDtaIni
		(cAlias)->R8_TIPO		:= cTipo
		(cAlias)->R8_TIPOAFA	:= aData[ nPosRCM, nPosRCMTip ]
		(cAlias)->R8_PD		 	:= (cAliasSRC)->RC_PD
		(cAlias)->R8_NUMID		:= cNumId
		(cAlias)->R8_DATAINI  	:= dDtaIni
		(cAlias)->R8_DURACAO	:= (cAliasSRC)->RC_HORAS
		(cAlias)->R8_DATAFIM  	:= dDtaFim
		(cAlias)->R8_CONTINU    := "2"
		(cAlias)->R8_PER        := cPeriodo
		(cAlias)->R8_NUMPAGO    := cNumPag
		(cAlias)->R8_CODRPAT    := (cAliasSRA)->RA_CODRPAT
	(cAlias)->( MsUnLock() )

	aAdd( aAllSR8, {} )
	nFields := Len(aSR8Fields)
	For nCont := 1 To nFields
		cField := (cAlias) + "->" + aSR8Fields[ nCont, 01 ]
		If !(aSR8Fields[ nCont , 02 ] == "M")
	 		aAdd( aAllSR8[ Len(aAllSR8) ], &( cField ) )
	 	Else
		 	aAdd( aAllSR8[ Len(aAllSR8) ], ""  )
	 	EndIf
	Next

EndIf

RestArea(aArea)

Return (Nil)

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³GetSRDValues³Autor³Rogerio Ribeiro          ³Data³14/05/2009³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³ 		                                                    ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³                                                            ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³                                                            ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³                                                            ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function GetSRDValues(nTotProvLiq,nTotDescLiq,nTotBsProv,nTotBsDesc)
Local aArea 	:= GetArea()

Local cTmpAlias	:= GetNextAlias()
Local cWhere	:= FilterSRD()

BEGINSQL ALIAS cTmpAlias
	SELECT
		SUM(RD_VALOR) AS RD_VALOR,
		RV_TIPOCOD
	FROM
		%Table:SRD% SRD
	INNER JOIN %Table:SRV% SRV
	ON SRV.RV_COD = SRD.RD_PD
	WHERE
		SRD.%NotDel% AND
		%Exp:cWhere%
	GROUP BY
		RV_TIPOCOD
ENDSQL


While !(cTmpAlias)->(Eof())
	If (cTmpAlias)->RV_TIPOCOD == "1"
		nTotProvLiq += (cTmpAlias)->RD_VALOR
	ElseIf (cTmpAlias)->RV_TIPOCOD == "2"
		nTotDescLiq += (cTmpAlias)->RD_VALOR
	ElseIf (cTmpAlias)->RV_TIPOCOD == "3"				// Total Base provento
		nTotBsProv 	+= (cTmpAlias)->RD_VALOR
	ElseIf (cTmpAlias)->RV_TIPOCOD == "4"				// Base Desconto
		nTotBsDesc	+= (cTmpAlias)->RD_VALOR
	EndIf

	(cTmpAlias)->(DbSkip())
EndDo

(cTmpAlias)->(DBCloseArea())

RestArea(aArea)

Return

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³GetSRDCounts³Autor³Rogerio Ribeiro          ³Data³14/05/2009³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³ 		                                                    ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³                                                            ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³                                                            ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³                                                            ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Function GetSRDCounts(nTotFunc, nTotRegs)

Local aArea 	:= GetArea()
Local cTmpAlias	:= GetNextAlias()
Local cWhere	:= FilterSRD()

BEGINSQL ALIAS cTmpAlias
	SELECT
		COUNT(DISTINCT RD_MAT) AS FUNCIONARIOS,
		COUNT(*) AS REGISTROS
	FROM
		%Table:SRD% SRD
	WHERE
		SRD.%NotDel% AND
		%Exp:cWhere%
ENDSQL

nTotFunc:= (cTmpAlias)->FUNCIONARIOS
nTotRegs:= (cTmpAlias)->REGISTROS

(cTmpAlias)->(DBCloseArea())

RestArea(aArea)

Return

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡…o    ³FilterSRD   ³Autor³Rogerio Ribeiro          ³Data³14/05/2009³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡…o ³ 		                                                    ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³                                                            ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³                                                            ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³                                                            ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function FilterSRD()
Local cWhere := "RD_PROCES = '" + cProcesso + "' "

cWhere += "AND RD_ROTEIR = '" + cRoteiro + "' "
cWhere += "AND RD_PERIODO = '" + cPeriodo + "' "
cWhere += "AND RD_SEMANA = '" + cNumPag + "'"

Return ("%" + cWhere + "%")

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³MkNewPerSRFºAutor  ³Microsiga          º Data ³  08/28/09   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³                                                            º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function MkNewPerSRF(cFilSra, cMat, cPdSrf, dDateIni)
Local aArea			:= GetArea()
Local cFilSRF		:= ""
Local cProcess		:= ""
Local dDatePer		:= CtoD("//")
Local dDateRec		:= CtoD("//")
Local dDateFinish 	:= CtoD("//")
Local dDatePerAtu 	:= CtoD("//")
Local lRet			:= .T.
Local lFound		:= .F.
Local lDtNova		:= .T.
Local nDaysRef		:= 0

DEFAULT cPDSrf 	:= aCodFol[72,1] 	//Verba de ferias

If Type("cPerFeAc") == "U"
	cPerFeAc := GetMvRH("MV_FERPAC", NIL, "N") // Ferias por ano civil
EndIf

If(!(SRA->(RA_FILIAL+RA_MAT)) ==(cFilSra + cMat))
	DbSelectArea("SRA")
	SRA->(DbSetOrder( RetOrdem("SRA", "RA_FILIAL+RA_MAT") ))
	lFound := SRA->(DbSeek(cFilSra + cMat))
Else
	lFound := .T.
EndIf

If(lFound) .and. !(SRA->RA_SITFOLH == "D") .And. dDateIni >= SRA->RA_ADMISSA
	cProcess := SRA->RA_PROCES
	//Posiciona nos periodos de dia de direito do funcionadio
	DbSelectArea("SRF")
	SRF->(DbSetOrder( RetOrdem( "SRF", "RF_FILIAL+RF_MAT+RF_PD+DtoS(RF_DATABAS)" ) ))

	If Empty(xFilial("SRF"))
		cFilSRF := Space(FWGETTAMFILIAL)
	Else
		cFilSRF:= cFilSra
	EndIf

	lFound := SRF->(DbSeek( cFilSrf + cMat + cPdSRF ))

	dDateFinish := CtoD("//")

	If(lFound)
		nI := 1
		While ((SRF->( RF_FILIAL + RF_MAT + RF_PD )) == (cFilSrf + cMat + cPdSRF))
			//Nao considera periodos vencidos ou pagos
			If Empty(SRF->RF_STATUS) .Or. SRF->RF_STATUS == "1"
				dDatePer	:= SRF->RF_DATABAS
				dDateFinish	:= SRF->RF_DATAFIM  //04/01/2011
			EndIf
			SRF->(DbSkip())
			nI ++
		EndDo

		//Checa se pelo menos uma data eh superior ao inicio do ultimo periodo cadastrado
		//esta situacao so eh possivel na primeira vez (reingresso ou reconhecimento)
		If !(cPaisLoc $ "ARG") .And. (Type("SRA->RA_FECREI") # "U" .And. !Empty(SRA->RA_FECREI))
			If cPaisLoc == "COS"
				lDtNova	 := SRA->RA_FECREI >= dDatePer
			Else
				lDtNova	 := SRA->RA_FECREI >= dDatePer .Or. SRA->RA_DTREC >= dDatePer
			EndIf
		EndIf
  	EndIf
	If !(cPaisLoc $ "ARG")
		If Type("SRA->RA_DTREC") # "U" .And. !Empty(SRA->RA_DTREC) //Campo só existe ARG/MEX/BOL - ARG nao usa no fechamento
			dDateRec := SRA->RA_DTREC
		Else
   			If Type("SRA->RA_FECREI") # "U" .And. !Empty(SRA->RA_FECREI) //Campo só existe MEX/BRA
				dDateRec := SRA->RA_FECREI
			Else
				dDateRec := SRA->RA_ADMISSA
			EndIf
		EndIf
	EndIf

	//Considera a data do ultimo periodo somente se nao for o primeiro reingresso ou reconhecimento
	If !(cPaisLoc $ "ARG") .And. Type("SRA->RA_FECREI") # "U"
		If(!Empty(dDateFinish))
			If !lDtNova .Or. ( Empty(SRA->RA_FECREI) .Or. Empty(SRA->RA_DTREC) )
				dDateIni := DaySum( dDateFinish, 1)
			EndIf
		EndIf
    EndIf

	If !(cPaisLoc $ "ARG") .And. ((Type("SRA->RA_FECREI") # "U" .And. !Empty(SRA->RA_FECREI)))
		dDateIni := CtoD(StrZero(Day(SRA->RA_FECREI),2)+"/"+StrZero(Month(SRA->RA_FECREI),2)+"/"+StrZero(Year(dDateIni),4))
	ElseIf cPerFeAc == "S"
		dDateIni := CtoD("01/01/"+StrZero(Year(YearSum(dDateIni, 1)),4))
	ElseIf !(SRF->RF_STATUS $ "2*1")
		dDateIni := CtoD(StrZero(Day(SRA->RA_ADMISSA),2)+"/"+StrZero(Month(SRA->RA_ADMISSA),2)+"/"+StrZero(Year(dDateIni),4))
	EndIf

	dDatePerAtu := CtoD( StrZero(Day(dDateIni),2)+ "/"+RCH->RCH_MES+"/"+RCH->RCH_ANO )
 	dDateFinish := YearSum(dDateIni, 1) //Data RCH_DTINI, mas ano incrementando  + 1
	dDateFinish := DaySub(dDateFinish, 1)

	If cPaisLoc == "COS"
		nDaysRef := RCJ->RCJ_DIAVAC
	ElseIf cPaisLoc == "ARG"
		fDiasFerArg(cPerFeAc == "S",dDateIni,dDateFinish,@nDaysRef)
	ElseIf cPaisLoc == "DOM"
		nDaysRef := Iif(fTabela("S006",01,06) <> Nil, fTabela("S006",01,06), 0)
	ElseIf cPaisLoc == "PAR"
	    nDaysRef := DiasFerPar(cProcess,SRA->RA_DTREC,SRA->RA_ADMISSA,SRA->RA_GPOVAC)
	ElseIf cPaisLoc == "PER"
		nI := fPosTab("S008",  SRA->RA_GPOVAC,  "==", 4)
		If Empty (nI)
			nI := 0
			nDaysRef = 30   // porque por defaul el periodo vacacional es de 30 días
		Else
			    nDaysRef := IIf (SRA->RA_MEIOPER == "1", fTabela ("S008", nI, 7), fTabela ("S008", nI, 6) )      
		EndIf
	Else
	    nDaysRef := GetDaysRef(dDateRec, DaySum(dDateFinish,1) , cProcess)
	EndIf

	If Empty(xFilial("SRF"))
		cFilSRF := Space(FWGETTAMFILIAL)
	Else
		cFilSRF:= cFilSra
	EndIf

	//Checa se o periodo jah existe, e tambem se jah se passou 12 meses do ultimo periodo valido.
	If !( SRF->(DbSeek( cFilSRF + SRA->RA_MAT + cPdSrf + DtoS(dDateIni))) ) .And. IIf(cPerFeAc <> "S",( Empty(dDatePer) .Or. dateDiffMonth(dDatePer,dDatePerAtu) >= 12 ),.T.)

		RecLock( "SRF" , .T. )

		SRF->RF_FILIAL	:= cFilSRF
		SRF->RF_MAT		:= cMat
		SRF->RF_PD		:= cPdSrf				//Verba lancamento
		SRF->RF_DATABAS := dDateIni             //Data Inicio do Periodo
		SRF->RF_DATAFIM := dDateFinish			//Data Fim do Periodo
		SRF->RF_DIASDIR := nDaysRef    			//Calculado considerando anos de empresa
		SRF->RF_DFERVAT := 0	        		//Dias vencidos
		SRF->RF_DIASANT := 0             		//Dias antecipados
		SRF->RF_DFERANT := 0        			//Saldo
		SRF->RF_STATUS	:= "1"
		

		SRF->( MsUnLock() )
	EndIf

	RestArea( aArea )
EndIf

Return lRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³GetDaysRefºAutor  ³Valdeci Lira        º Data ³  31/08/09   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Retorna os dias de referencia (dias de direito) para o func.º±±
±±º          ³e periodo informado.                                        º±±
±±º          ³cPeriod -> Periodo de referencia para busca dos dias de ref.º±±
±±º          ³cNumPag -> Numero de pagamento para busca dos dias de ref.  º±±
±±º          ³cProced -> Roteiro do periodo para busca dos dias de ref.   º±±
±±º          ³cFilSra -> Filial do funcionario                            º±±
±±º          ³cMat    -> Matricula do funcionario                         º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ Calculo de dias de referencia                              º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function GetDaysRef(dBsEmployee, dDateFin, cProcess)
Local nDaysRef 		:= 0   //->Dias de Referencia do funcionario
Local nI	   		:= 0    //->Contador de linhas para FTabela
Local nYearsWorked 	:= 0    //->Anos trabalhados
Local nYearS008		:= 0	//->Anos tabela S008
Local nYearGet		:= 0	// Variavel de auxilio para definicao De/Ate

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Considerando os anos trabalhados e o processo do trabalhador³
³ira buscar na tabela S008 os dias de direito para o retorno ³
³da funcao                                                   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
*/
nYearsWorked:= DateDiffYear( dDateFin, dBsEmployee)

fPosTab( "S008", cProcess, "==", 4,,,,,@nI)
If Empty(nI)
	nI := 0
EndIf
While (cProcess == fTabela( "S008", nI , 4 ))
	nYearS008 := fTabela( "S008", nI , 5 )  // Representa Ate

	If nYearsWorked >= nYearGet .and. nYearsWorked <= nYearS008
		nDaysRef := fTabela( "S008", nI , 6)
		Exit
	Else
		nYearGet := nYearS008
	EndIf
	nI++
EndDo

Return( nDaysRef )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³UpdStateSRFºAutor  ³Valdeci Lira	      º Data ³ 28/08/09   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Atualiza SRF se MV_MODFOL =="2"                     	 	  º±±
±±º          ³ 			       e paises: "MEX|HAI|COS|ARG"				  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function UpdStateSRF(cFilSra, cMat, lPresc, cPdSrf, cTpRoteir, cPDPag, nDiasPago )
Local dDatePresc	:= CtoD("//")
Local lRet 			:= .T.
Local lRun			:= .T.
Local cAliasVac 	:= CriaTrab(Nil, .F.)
Local nVacPropMx    := 0
Local cQuery		:= ""
DEFAULT cPdSRF		:= ""
DEFAULT cPDPag		:= ""

If (lRun)
	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Se os dias pagos estiverem iguais aos dias de referencia    ³
	³para o periodo de dias de direito, entao o periodo sera     ³
	³marcado como pago.                                          ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	*/
	//RF_DFERANT  Dias Pagos
	//RF_DFERVAT  Dias Vencidos
	//RF_DIASDIR  Dias de Direito
	If ((SRF->RF_DFERANT == SRF->RF_DIASDIR) .AND. (SRF->RF_STATUS == "1") .AND. !( cTpRoteir == "4" ))
		RecLock("SRF", .F.)
		SRF->RF_STATUS := "3" //Pago
		SRF->(MsUnLock())
		lRun := .F.
	EndIf
	If ( lRun .AND. lPresc)

		If (cPDPag == aCodFol[87,1]) //Ferias proporcionais
			RecLock("SRF", .F.)
			SRF->RF_STATUS 	:= "3" //Pago
			If SRF->RF_DFERVAT == 0 // Dias Vencidos
				If cPaisLoc=="MEX" .and. cTpRoteir == "A" //Roteiro A = Aplicacion Finiquito
					cQuery := "SELECT RC_HORAS FROM " + RetSqlName("SRC")
					cQuery += " WHERE RC_FILIAL  = '" + SRA->RA_FILIAL + "' AND "
					cQuery += " RC_MAT 	   = '" + SRA->RA_MAT + "' AND "
					cQuery += " RC_PROCES  = '" + cProcesso + "' AND "
					cQuery += " RC_PERIODO = '" + cPeriodo + "' AND "
					cQuery += " RC_ROTEIR  = '" + cRoteiro + "' AND "
					cQuery += " RC_SEMANA  = '" + cNumPag +"' AND "
					cQuery += " RC_PD      = '" + aCodFol[87,1] +"' AND "
					cQuery += " D_E_L_E_T_ = ' ' "
					cQuery := ChangeQuery(cQuery)
					dbUseArea(.T., "TOPCONN", TcGenQry(,,cQuery), cAliasVac, .T., .T.)
					If (cAliasVac)->(!EOF())
						nVacPropMx := (cAliasVac)->RC_HORAS
					EndIf
					(cAliasVac)->( dbCloseArea())
					SRF->RF_DFERVAT := nVacPropMx
					SRF->RF_DFERANT := nVacPropMx
				Else
					SRF->RF_DFERVAT := nDiasPago + SRF->RF_DIASANT			// Dias Vencidos (Somar os dias pagos no SRC + Dias Antecipados
					SRF->RF_DFERANT += nDiasPago							// Dias Pagos (Somar os dias pagos em SRC)
				EndIf
				SRF->RF_DIASANT := 0									// Dias Anticipados (Foi para o dias Vencidos
				IF cPaisLoc == "COL"
					SRF->RF_DFERAAT := (SRF->RF_DIASDIR / 365 )* ((RCH->RCH_DTFIM - SRF->RF_DATABAS) + 1 )
				EndIf
			EndIf
			SRF->(MsUnLock())
			lRun := .F.
			lRet := .T.
		EndIf

		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Calcula o tempo que passou desde o vencimento do dias de dir³
		³ate a data final do periodo posicionado, se a quantidade    ³
		³resultante for maior que o configurado em RCJ entao o per.  ³
		³de dias de direito sera prescrito.                          ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		*/
		If SRF->RF_DFERVAT <> SRF->RF_DFERANT .and. !(cPaisLoc $ "CHI")

			If cPaisLoc $ "MEX|ARG|PER|PAR "
				nYearsMax  		:= RCJ->RCJ_VIGVAC //Años de vigencia de vacaciones
				dBsLastVac 		:= SRF->RF_DATAFIM
				dYearFinPeriod	:= RCH->RCH_DTFIM
				dDatePresc		:= (YearSum(dBsLastVac, Int(nYearsMax)))	//Soma o numero de anos na data
				dDatePresc		:= MonthSum(dDatePresc, ((nYearsMax - Int(nYearsMax)) * 12))	//Soma o numero de meses

				If dYearFinPeriod >= dDatePresc
					RecLock("SRF", .F.)
					SRF->RF_STATUS := "2" //Prescrito
					SRF->(MsUnLock())
					lRun := .F.
					lRet := .T.
				EndIf
		Else
			nYearsMax  		:= RCJ->RCJ_VIGVAC/365
			dBsLastVac 		:= SRF->RF_DATAFIM
			dYearFinPeriod	:= RCH->RCH_DTFIM
			dDatePresc		:= ( YearSum( dBsLastVac, Int(nYearsMax) ) )							//Soma o numero de anos na data
			dDatePresc		:= MonthSum( dDatePresc, ( ( nYearsMax - Int(nYearsMax) ) * 12 ) )		//Soma o numero de meses

			If dYearFinPeriod >= dDatePresc
				RecLock("SRF", .F.)
				SRF->RF_STATUS := "2" //Prescrito
				SRF->(MsUnLock())
				lRun := .F.
				lRet := .T.
			EndIf
		EndIf
	EndIf
EndIf
EndIf

Return lRet
/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³SelectPerSRFºAutor  ³MicroSiga	     º Data ³  28/08/09   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Seleciona o primeiro periodo ativo do trabalhador, do mais  º±±
±±º          ³antigo para o mais novo, deixando a tabela SRF posicionada. º±±
±±º          ³cFilSra -> Filial do Funcionario                            º±±
±±º          ³cMat    -> Matricula do funcionario                         º±±
±±º          ³cPdSrf  -> Verba do periodo que se quer selecionar          º±±
±±º          ³nRecnoSRF-> Recno para que a rotina nao tente posicionar a  º±±
±±º          ³a tabela.                                                   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ Atualicao dos dias de direito do funcionario               º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function SelectPerSRF(cFilSra, cMat, cPdSRF, nRecnoSRF, cFilSrf)
Local aArea 		:= {} 	//->Armazena a area Corrente
Local lRun 			:= .T.	//->Indica se a rotina deve continuar
Local lFound		:= .F.	//->Indica se o registro foi selecionado

DEFAULT cPdSRF		:= "" 	//->Verba de ferias
DEFAULT nRecnoSRF	:= -1	//->Indica se deve se pular diretamente para um recno
DEFAULT cFilSrf		:= xFilial("SRF")   //Filial SRF

Sx2ChkModo( "SRF", NIL, .F., @cModSRF, NIL )
lSRFExclusiv := (cModSRF == "E")

//So executa para mexico modelo 2
If !(cPaisLoc == "MEX") .OR. !(MV_MODFOL=="2")
	Return (.T.)
EndIf

aArea := GetArea()
If(Empty(cPdSRF))
	cPdSRF	:= aCodFol[72,1]
EndIf

//Garante o posicionamento do SRF
DbSelectArea( "SRF" )
If (nRecnoSRF <> -1)
	If( nRecno <> SRF->(Recno()))
		SRF->(dbGoTo(nRecno))
	EndIf
Else
	If(Empty(cFilSrf))
		If Empty(xFilial("SRF"))
			cFilSRF := Space(FWGETTAMFILIAL)
		Else
			cFilSRF:= cFilSra
		EndIf
	EndIf

	SRF->(DbSetOrder( RetOrdem( "SRF", "RF_FILIAL+RF_MAT+RF_PD+DtoS(RF_DATABAS)" ) ))
	lRun := SRF->(DbSeek( cFilSrf + cMat + cPdSRF ))
EndIf

If (lRun)
	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Sera retornado o primeiro periodo com status ativo          ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	*/
	lFound	:= .F.
	While( lRun .AND. (cMat == SRF->RF_MAT) )
		If( SRF->RF_PD == cPdSRF .AND. SRF->RF_STATUS == "1" )
			lFound	:= .T.
			lRun 	:= .F.
		Else
			lFound	:= .F.
			SRF->(DbSkip())
		EndIf
	EndDo

	If ((nRecnoSRF <> -1) .AND. !lFound)
		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Se um recno foi indicado como ideal para que o processamento³
		³da funcao fosse reduzido, e o resultado nao foi encontrado  ³
		³entao a funcao tentara selecionar o periodo sem a indicacao ³
		³do recno                                                    ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		*/
        	lFound := SelectPerSRF(cFilSra, cMat, cPdSRF, Nil, cFilSrf)
	EndIf
EndIf

RestArea(aArea)

Return lFound

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³GrvSR8Ang ºAutor  ³Tiago Malta         º Data ³  04/09/09   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Função que grava os dias pagos na ausencia para Angola     º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function GrvSR8Ang()

Local cVerbGoz   := If( cPaisLoc=="ANG", aCodFol[72,1], aCodFol[786,1] )
Local lCnt       := .T.
Local nDesAfas   := (cAliasSRC)->RC_HORAS
Local nSaldo     := 0
Local nPagar     := 0
Local nSaldoProx := 0
Local nDiasAus	 := 0

If (cAliasSRC)->RC_PD == cVerbGoz

	SR8->( DbSetOrder(1) )
	SR8->( DbSeek( xFilial('SR8') + (cAliasSRA)->RA_MAT ) )
	While SR8->( !Eof() ) .AND. SR8->R8_MAT == (cAliasSRA)->RA_MAT

		nDiasAus := If( cPaisLoc=="ANG", SR8->R8_DURACAO, SR8->R8_SDPAGAR )

		If nDiasAus > 0

			If nDesAfas > nDiasAus
				nSaldo     := 0
				nSaldoProx := nDesAfas - nDiasAus
				nPagar     := nDesAfas - ( nDesAfas - nDiasAus )
				nDesAfas   := nSaldoProx
			Else
				nPagar      := nDiasAus - ( nDiasAus - nDesAfas )
				nSaldo      := nDiasAus - nDesAfas
				nSaldoProx  := nDiasAus - nDesAfas
				lCnt := .F.
			EndIf

		    RecLock('SR8',.F.)

		    SR8->R8_STATUS  := 'C'

			//Na Angola o pagto de ferias eh total no mes do calculo, nao transita no mes seguinte
		    If cPaisLoc # "ANG"
			    SR8->R8_DPAGOS  := nPagar
			    SR8->R8_SDPAGAR := nSaldo
			EndIf
		    MsUnLock()

		    If !lCnt
		    	Exit
		    EndIf

		 EndIf

		SR8->( DbSkip() )
	EndDo

EndIf

Return()

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³GrvSRFAng ºAutor  ³Tiago Malta         º Data ³  04/09/09   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³  Funçào que atualiza os dias antecipados de ferias para    º±±
±±º          ³  portugal.                                                 º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function GrvSRFAng()

Local aDiasRet   := {}
Local cVerbFer   := aCodFol[72,1]
Local cVerbGoz   := aCodFol[786,1]
Local lAchou     := .F.
Local lFerias    := .F.
Local nAfasAnt   := (cAliasSRC)->RC_HORAS
Local nDiasDir   := 0
Local npos       := 0

If (cAliasSRC)->RC_PD == cVerbFer
	lFerias := .T.
ElseIf (cAliasSRC)->RC_PD == cVerbGoz
	lFerias := .F.
EndIf

//Posiciona na tabela de Controle de Dias
SRF->( DbSetOrder(1) )
If SRF->( DbSeek( xFilial('SRF') + (cAliasSRC)->RC_MAT ) )
	While SRF->( !Eof() ) .AND. SRF->RF_MAT == (cAliasSRC)->RC_MAT
		If SRF->RF_PD == cVerbFer .AND. SRF->RF_STATUS $ " 1"
			lAchou     := .T.
			Exit
		EndIf
		SRF->( DbSkip() )
	EndDo
EndIf

If lFerias .AND. lAchou
	If Empty(SRF->RF_PAGOFER)
		RecLock('SRF',.F.)
		SRF->RF_PAGOFER := "A" // Grava como subsidio pago
		MsUnLock()
	ElseIf SRF->RF_PAGOFER == "B"
		RecLock('SRF',.F.)
		SRF->RF_STATUS := "3"  // Grava Periodo Pago
		SRF->RF_PAGOFER := " "
		MsUnLock()
	EndIf
ElseIf !(lFerias) .AND. lAchou

  		DiasFerPtg(@aDiasRet,SRF->RF_DATABAS,SRF->RF_DATAFIM)
  		npos := aScan( aDiasRet , {|x| x[1]==SRF->RF_DATABAS .and. x[2]==SRF->RF_DATAFIM } )
  		If npos > 0
  		nDiasDir := aDiasRet[npos][4]
	EndIf

	RecLock('SRF',.F.)

	If LEN(aDiasRet) > 0
		If ( nAfasAnt + SRF->RF_DIASANT) == nDiasDir
			If SRF->RF_PAGOFER == "A"
				SRF->RF_STATUS := "3" // Grava Periodo Pago
				SRF->RF_PAGOFER := " "
			ElseIf Empty(SRF->RF_PAGOFER)
				SRF->RF_PAGOFER := "B" // Grava gozo de ferias total pago
			EndIf
		EndIf
	EndIf

	SRF->RF_DFERANT += nAfasAnt

	MsUnLock()
EndIf
Return()

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³GrvSRFBol ºAutor  ³Luis Trombini       º Data ³ 27/05/2011  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³  Funçào que atualiza os dias antecipados de ferias para    º±±
±±º          ³  Bolivia.                                                  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function GrvSRFBol()

Local cVerbFer   := aCodFol[72,1]
Local dDtIni   	 := CtoD("  /  /  ")
Local dDtfim   	 := CtoD("  /  /  ")
Local dDataFim   := CtoD("  /  /  ")
Local lAchou     := .F.
Local lFerias    := .F.
Local nAfasAnt   := nDFerfol
Local nAfasPer   := 0

If nDFerfol > 0
	lFerias := .T.
EndIf

//Posiciona na tabela de Controle de Dias
SRF->( DbSetOrder(1) )
If SRF->( DbSeek( xFilial('SRF') + SRA->RA_MAT ) )
	While SRF->( !Eof() ) .AND. SRF->RF_MAT == SRA->RA_MAT
		If SRF->RF_PD == cVerbFer .AND. SRF->RF_STATUS $ " 1"
			lAchou     := .T.
			Exit
		EndIf
		SRF->( DbSkip() )
	EndDo
EndIf

//Se a verba eh referente a Ferias e foi encontrado periodo
If lFerias .And. lAchou

    //Grava dias pagos em periodos nao vencidos no SRF
	If( nAfasAnt += SRF->RF_DFERANT ) > 0

		If nAfasAnt < SRF->RF_DFERVAT
	 		RecLock('SRF',.F.)
			SRF->RF_DFERANT := nAfasAnt// Grava DIAS PAGOS DE FERIAS
			SRF->( MsUnLock() )
			nAfasAnt := 0
	 	ElseIf nAfasAnt == SRF->RF_DFERVAT
	 		RecLock('SRF',.F.)
			SRF->RF_STATUS := "3"  //Atualiza Status para Pago
			SRF->RF_DFERANT := nAfasAnt
			SRF->( MsUnLock() )
			nAfasAnt := 0
		ElseIf nAfasAnt > SRF->RF_DFERVAT
		    If nAfasAnt < SRF->RF_DIASDIR
				RecLock('SRF',.F.)
				SRF->RF_STATUS := "1"  // Grava Periodo ANTECIPADO
				SRF->RF_DFERANT := nAfasAnt
				SRF->( MsUnLock() )
				nAfasAnt := 0
			ElseIf nAfasAnt >= SRF->RF_DIASDIR
			   RecLock('SRF',.F.)
			   SRF->RF_STATUS := "3"  //Atualiza Status para Pago
			   SRF->RF_DFERANT := SRF->RF_DIASDIR
		       SRF->( MsUnLock() )
		       nAfasPer := int(nAfasAnt - SRF->RF_DIASDIR)
			   DDATAINIC := CtoD("  /  /  ")
			   ddtini := SRF->RF_DATAFIM + 1
			   dDtfim := SRF->RF_DATAFIM
			EndIf
		EndIf

	    //Atualiza os proximos periodos ativos quando ainda resta dias pagos (antecipacao)
		If nAfasPer > 0
			SRF->( DbSetOrder(1) )
			If SRF->( DbSeek( xFilial('SRF') + SRA->RA_MAT ) )
				While SRF->( !Eof() ) .AND. SRF->RF_MAT == SRA->RA_MAT
					If SRF->RF_PD == cVerbFer .AND. SRF->RF_STATUS $ " 1"
				 		RecLock('SRF',.F.)
				 		If( SRF->RF_DIASDIR >= (SRF->RF_DFERANT + nAfasPer) )
							SRF->RF_DFERANT += nAfasPer
							nAfasPer := 0
						Else
							nAfasPer -= (SRF->RF_DIASDIR - SRF->RF_DFERANT)
							SRF->RF_DFERANT := SRF->RF_DIASDIR
							SRF->RF_STATUS := "3"  //Atualiza Status para Pago
						EndIf
						SRF->( MsUnLock() )
					EndIf
					SRF->( DbSkip() )
				EndDo
			EndIf
		EndIf

		//Cria um novo periodo de ferias relativo ao restante dos dias pagos (antecipacao)
		If nAfasPer > 0
			If( !Empty(SRA->RA_DTREC) )
               	DDATAINIC := SRA->RA_DTREC
   		    EndIf
   			If( Empty(DDATAINIC) )
   	        	DDATAINIC := SRA->RA_ADMISSA
	    	EndIf
			DDATAF := If(SRA->RA_SITFOLH = "D" , SRA->RA_DEMISSA, dDtFimPer )
           	NANOSTRAB := (( DDATAF - DDATAINIC) + 1) / 365
           	NX := FPOSTAB("S010", SRA->RA_PROCES, "=", 4 , NANOSTRAB , "<=" , 6 )
           	NDIASVAC := If( NX > 0,  FTABELA("S010" , NX , 7),  0 )
			dDataFim := CtoD( StrZero( Day( dDtIni ),2 ) + "/" + StrZero( Month( dDtIni ) ,2 ) + "/" + StrZero( Year( dDtIni ) + 1, 4) ) - 1

			RecLock( "SRF" , .T. )
			SRF->RF_FILIAL	:= SRA->RA_FILIAL
			SRF->RF_MAT		:= SRA->RA_MAT
			SRF->RF_PD		:= cVerbFer
			SRF->RF_DIASDIR := NDIASVAC
			SRF->RF_STATUS	:= "1"
			SRF->RF_DATABAS := dDtIni
			SRF->RF_DATAFIM := dDataFim
			SRF->RF_DFERANT := nAfasPer   // dias pagos
			SRF->( MsUnLock() )
		EndIf

	EndIf

//Se a verba eh referente a ferias e nao foi encontrado periodo
ElseIf lFerias .And. !(lAchou)

	dDtini := SRA->RA_ADMISSA
	If( !Empty(SRA->RA_DTREC) )
       	DDATAINIC := SRA->RA_DTREC
   	EndIf
   	If( Empty(DDATAINIC) )
   	   	DDATAINIC:=SRA->RA_ADMISSA
   	EndIf
	DDATAF := If(SRA->RA_SITFOLH = "D" , SRA->RA_DEMISSA, dDtFimPer  )
	NANOSTRAB := (( DDATAF - DDATAINIC) + 1) / 365
	NX := FPOSTAB("S010", SRA->RA_PROCES, "=", 4 , NANOSTRAB , "<=" , 6 )
	NDIASVAC := If(NX > 0,  FTABELA("S010" , NX , 7 ) ,  0 )
	dDataFim := CtoD( StrZero( Day( dDtIni ),2 ) + "/" + StrZero( Month( dDtIni ) ,2 ) + "/" + StrZero( Year( dDtIni ) + 1, 4) ) - 1

	RecLock( "SRF" , .T. )
	SRF->RF_FILIAL	:= SRA->RA_FILIAL
	SRF->RF_MAT		:= SRA->RA_MAT
	SRF->RF_PD		:= cVerbFer
	SRF->RF_DIASDIR := NDIASVAC
	SRF->RF_STATUS	:= "1"
	SRF->RF_DATABAS := dDtIni
	SRF->RF_DATAFIM := dDataFim
	SRF->RF_DFERANT := nAfasAnt
	SRF->( MsUnLock() )

EndIf

Return()

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³GrvSR8Dom ºAutor  ³Christiane Vieira   º Data ³  13/08/2011 º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Função que grava os dias pagos na ausencia para Republica  º±±
±±º          ³ Dominicana                                                 º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function GrvSR8Dom()

Local cVerbGoz   := IIf((cTpRoteir = "3".Or. cPaisLoc=="ARG"), aCodFol[72,1], aCodFol[786,1])
Local lCnt       := .T.
Local nDesAfas   := (cAliasSRC)->RC_HORAS
Local nSaldo     := 0
Local nPagar     := 0
Local nSaldoProx := 0

If (cAliasSRC)->RC_PD == cVerbGoz

	SR8->( DbSetOrder(1) )
	SR8->( DbSeek( xFilial('SR8') + (cAliasSRA)->RA_MAT ) )
	While SR8->( !Eof() ) .AND. SR8->R8_MAT == (cAliasSRA)->RA_MAT

		If SR8->R8_PD ==  If(cPaisLoc =="ARG",aCodFol[72,1],aCodFol[786,1])
			If SR8->R8_SDPAGAR > 0

				If nDesAfas > SR8->R8_SDPAGAR
					nSaldo     := 0
					nSaldoProx := nDesAfas - SR8->R8_SDPAGAR
					nPagar     := nDesAfas - ( nDesAfas - SR8->R8_SDPAGAR )
					nDesAfas   := nSaldoProx
				Else
					nPagar      := SR8->R8_SDPAGAR - ( SR8->R8_SDPAGAR - nDesAfas )
					nSaldo      := SR8->R8_SDPAGAR - nDesAfas
					nSaldoProx  := SR8->R8_SDPAGAR - nDesAfas
					lCnt := .F.
				EndIf

			    RecLock('SR8',.F.)
			    If cTpRoteir == "3"
				    SR8->R8_VALOR := (cAliasSRC)->RC_VALOR
				EndIf

				If cPaisLoc == "DOM" .Or. (cPaisLoc == "ARG" .And. cTpRoteir != "3")
				    SR8->R8_DPAGOS  := nPagar
				    SR8->R8_SDPAGAR := nSaldo
					SR8->R8_STATUS  := 'C'
				EndIf

			    MsUnLock()

			    If !lCnt
			    	Exit
			    EndIf
			EndIf
		EndIf

		SR8->( DbSkip() )
	EndDo

EndIf

Return()

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³GrvSR8Per ºAutor  ³Carolina Kossoy     º Data ³  27/02/2025 º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Esta función graba los dias pagados en las ausencias       º±±
±±º            para Perú                                                  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function GrvSR8Per()

Local cVerbGoz   := aCodFol[72,1]
Local nDesAfas   := (cAliasSRC)->RC_HORAS
Local nSaldo     := 0
Local nPagar     := 0
Local nSaldoProx := 0

If (cAliasSRC)->RC_PD == cVerbGoz

	SR8->( DbSetOrder(1) ) //R8_FILIAL+R8_MAT+DTOS(R8_DATAINI)+R8_TIPO
	SR8->( DbSeek( xFilial('SR8') + (cAliasSRA)->RA_MAT ) )
	While SR8->( !Eof() ) .AND. SR8->R8_MAT == (cAliasSRA)->RA_MAT

		If SR8->R8_PD == cVerbGoz
			If SR8->R8_SDPAGAR > 0
				If nDesAfas >= SR8->R8_SDPAGAR
					nSaldo     := 0
					nSaldoProx := nDesAfas - SR8->R8_SDPAGAR
					nPagar     := 0
					nDesAfas   := nSaldoProx
				Else
					nPagar      := SR8->R8_SDPAGAR - ( SR8->R8_SDPAGAR - nDesAfas )
					nSaldo      := SR8->R8_SDPAGAR - nDesAfas
					nSaldoProx  := SR8->R8_SDPAGAR - nSaldo - nDesAfas
					lCnt := .F.
				EndIf

			    RecLock('SR8',.F.)
			    
				SR8->R8_DPAGOS  := nPagar
				SR8->R8_SDPAGAR := nSaldo
				SR8->R8_DPAGAR  := nSaldo
				If nSaldo == 0
					SR8->R8_STATUS  := 'C'
				EndIf
				
			    SR8->(MsUnLock())

			EndIf
		EndIf

		SR8->( DbSkip() )
	EndDo

EndIf

Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³GrvSRFDom	ºAutor  ³Christiane Vieira 	 º Data ³  12/08/2011 º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³  Funçào que atualiza os dias antecipados de ferias para    º±±
±±º          ³  Republica Dominicana                                      º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function GrvSRFDOM()

Local aPerFerias := {}
Local cVerbFer   := aCodFol[72,1]
Local lAchou     := .F.
Local lFerias    := .F.
Local nPos       := 0
Local nDTotFeria := 0
Local nDiasPagos := 0

If cTpRoteir == "3"
	lFerias := .T.
Else
	lFerias := .F.
EndIf

//Posiciona na tabela de Controle de Dias
SRF->( DbSetOrder(1) )
If SRF->( DbSeek( xFilial('SRF') + (cAliasSRC)->RC_MAT ) )
	While SRF->( !Eof() ) .AND. SRF->RF_MAT == (cAliasSRC)->RC_MAT
		If SRF->RF_PD == cVerbFer .AND. SRF->RF_STATUS $ " 1"
			lAchou     := .T.
			Exit
		EndIf
		SRF->( DbSkip() )
	EndDo
EndIf

If lFerias .And. lAchou //Fechamento de Férias - Atualizar RHI e RHJ
//Posicionar o cabeçalho de Férias
	DbSelectArea("RHI")
	If RHI-> ( DbSeek( xFilial('RHI') + (cAliasSRC)->RC_MAT ))
		While RHI-> ( !Eof() ) .And. RHI->RHI_MAT == (cAliasSRC)->RC_MAT
			If RHI->RHI_PROCES == cProcesso .And. RHI->RHI_ROTEIR == cRoteiro .And. RHI->RHI_NUMPAG == cNumPag .And. RHI->RHI_PERIODO == cPeriodo .And. !( RHI->RHI_STATUS $ "5|1" )
				//Atualizar cabeçalho de Férias
				RecLock('RHI',.F.)
				RHI->RHI_STATUS := "5"
				RHI->( MsUnLock() )

				//Dias totais de férias
				nDTotFeria:= RHI->RHI_DFERIA

				//Posicionar a tabela RHJ
				DbSelectArea("RHJ")
				RHJ->( DbSetOrder(1) )
				If RHJ->( MsSeek( xFilial('RHJ') + (cAliasSRC)->RC_MAT + DtoS(RHI->RHI_DTINI) + DtoS(SRF->RF_DATABAS) ) )
					While RHJ-> ( !Eof() ) .And. RHJ->RHJ_DIASPG <> 0  .And. RHJ->RHJ_MAT== RHI->RHI_MAT
				    	//Atualizar Itens de Ferias
                        //RHJ_DFERAN = Dias Pagos
                        //RHJ_DIASPG = Dias a Pagar
						RecLock('RHJ',.F.)
							nDiasPagos :=	RHJ->RHJ_DFERAN + RHJ->RHJ_DIASPG
							//Verificando se Dias de Direito é igual ao Dias Pagos, caso sim, será alterado status de item de férias
							If RHJ->RHJ_DIASDI == nDiasPagos
								RHJ->RHJ_STATUS := "2"      //"2"-> Item de férias descontados
							EndIf
							RHJ->RHJ_DFERAN := nDiasPagos
						RHJ->( MsUnLock() )

						DbSelectArea("SRF")
						SRF->( DbSetOrder(1) )
						If SRF->( MsSeek( xFilial('SRF') + (cAliasSRC)->RC_MAT + DtoS(RHJ->RHJ_DTBASE) + (cAliasSRC)->RC_PD  ))
					     	//Atualizar Dias Pagos de Férias
						   	RecLock('SRF',.F.)
								If RHJ->RHJ_STATUS == "2"
									SRF->RF_STATUS  := "3" //"3"-> Ferias Pagas
								EndIf

								SRF->RF_DFERANT := SRF->RF_DFERANT + RHJ->RHJ_DIASPG
							SRF->( MsUnLock() )
						EndIf

				    	RHJ->( DbSkip() )
					EndDo
			    EndIf
			EndIf
		    RHI->( DbSkip() )
		EndDo
	EndIf

ElseIf !lFerias .And. lAchou .And. cPaisLoc <> "ARG"

	// Busca os dias de direito de ferias
	CargaFerias(@aPerFerias, RCH->RCH_DTFIM)

	SRF->( DbSetOrder(1) )

	For nPos = 1 to len(aPerFerias)
		If SRF->( DbSeek( xFilial('SRF') + (cAliasSRC)->RC_MAT + DtoS(aPerFerias[nPos][1]) + aCodFol[72,1] ) )
			RecLock('SRF',.F.)
			If SRF->RF_DIASDIR == SRF->RF_DFERANT
				SRF->RF_STATUS = "3"
			EndIf
			SRF->RF_DFERAAT	:= aPerFerias[nPos][4] //Proporcionais
			SRF->RF_DIASANT	:= aPerFerias[nPos][5] //Antecipados
			SRF->RF_DFERVAT	:= aPerFerias[nPos][6] //Vencidos
			SRF->RF_DFERANT	:= aPerFerias[nPos][7] //Pagos
			SRF->( MsUnLock() )
		Else
			//Novo Período
			RecLock('SRF',.T.)
			SRF->RF_FILIAL 	:= xFilial("SRF")
			SRF->RF_MAT		:= (cAliasSRC)->RC_MAT
			SRF->RF_STATUS 	:= "1"
			SRF->RF_PD		:= aCodFol[72,1]
			SRF->RF_DATABAS	:= aPerFerias[nPos][1]
			SRF->RF_DATAFIM := aPerFerias[nPos][2]
			SRF->RF_DIASDIR	:= aPerFerias[nPos][3]
			SRF->RF_DFERAAT	:= aPerFerias[nPos][4] //Proporcionais
			SRF->RF_DIASANT	:= aPerFerias[nPos][5] //Antecipados
			SRF->RF_DFERVAT	:= aPerFerias[nPos][6] //Vencidos
			SRF->RF_DFERANT	:= aPerFerias[nPos][7] //Pagos
			SRF->( MsUnLock() )
		EndIf
 	Next
EndIf

Return()

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³GravSRFPer ºAutor ³Carolina Kossoy 	 º Data ³  27/02/2025 º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³  Funcion que actualiza los dias pagados de vacaciones      º±±
±±º          ³  disfrutadas o compradas para Perú                         º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function GravSRFPer(nDiasLiq)

Local lAchou		:= .F.
Local nSaldo 		:= 0
Local cCptoVac		:= aCodFol[72,1]
Local cCptoVacCo	:= aCodFol[74,1]
Local cFilSRF		:=  xFilial('SRF')
Default nDiasLiq	:= 0

//Posiciona en la tabla de Control de Dias de Derecho
SRF->( DbSetOrder(1) ) //RF_FILIAL+RF_MAT+DTOS(RF_DATABAS)+RF_PD
If SRF->( DbSeek( cFilSRF + (cAliasSRC)->RC_MAT ) )
	While SRF->( !Eof() ) .AND. SRF->RF_MAT == (cAliasSRC)->RC_MAT .AND. SRF->RF_PD == cCptoVac 
		If SRF->RF_STATUS == "1" .OR. Empty(SRF->RF_STATUS)
			lAchou     := .T.					
			Exit
		EndIf
		SRF->( DbSkip() )
	EndDo
EndIf

If lAchou //Cierre de Vacaciones

	DbSelectArea( "SRF" )
	SRF->(DbSetOrder(2)) //RF_FILIAL+RF_MAT+RF_PD+DtoS(RF_DATABAS)
	SRF->(DbSeek( cFilSRF + (cAliasSRA)->RA_MAT + cCptoVac ))
	Do While SRF->( !Eof() ) .and. SRF->( RF_FILIAL + RF_MAT + RF_PD ) == ( cFilSRF + (cAliasSRA)->RA_MAT + cCptoVac )
		If SRF->RF_STATUS <> "1"  		
			SRF->( DbSkip() )
			Loop
		Else
			If nDiasLiq > 0
				RecLock('SRF',.F.)

				nSaldo 		:= SRF->RF_DFERVAT + SRF->RF_DFERAAT - SRF->RF_DFERANT 
							
				If nSaldo == 0
					SRF->RF_STATUS  := "3"  //Actualiza Estatus para Pago
				Else
					If nDiasLiq < nSaldo
						SRF->RF_DFERANT += nDiasLiq // Graba Dias Pagados de Vacaciones
						If (cAliasSRC)->RC_PD == cCptoVacCo
							SRF->RF_FERPAGA += nDiasLiq
						EndIf
						nDiasLiq 		:= 0
					ElseIf nDiasLiq == nSaldo			
						SRF->RF_STATUS  := "3"  //Actualiza Estatus para Pago
						SRF->RF_DFERANT += nDiasLiq  // Graba Dias Pagados de Vacaciones
						If (cAliasSRC)->RC_PD == cCptoVacCo
							SRF->RF_FERPAGA += nDiasLiq
						EndIf
						nDiasLiq 		:= 0
					ElseIf nDiasLiq > nSaldo 
						SRF->RF_STATUS  := "3"  //Actualiza Estatus para Pago
						SRF->RF_DFERANT += nSaldo  // Graba Dias Pagados de Vacaciones
						If (cAliasSRC)->RC_PD == cCptoVacCo
							SRF->RF_FERPAGA += nSaldo  // Graba Dias Pagados de Vacaciones
						EndIf
						nDiasLiq 		:= nDiasLiq - nSaldo// Actualiza días a colocar como Pagados en el próximo periodo
					EndIf
				EndIf

				SRF->( MsUnLock() )	
			EndIf
		EndIf			
		SRF->( DbSkip() )
	EndDo 
EndIf

Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  |GrvSRFHAI ºAutor  ³Natie Sugahara      º Data ³  01/09/09   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Atualiza saldo dos dias de faltas                          º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function GrvSRFHAI(cFilSRA)
Local aAreaSRF		:= SRF->(GetArea())
Local cPD 	 		:= aCodFol[54,1]
Local nDuracao 		:= 0 												//-- total de faltas do mes
Local nPosPd		:= aScan( aSR8Fields,{ |x| x[1] ==  "R8_PD" } )
Local nPosDuracao 	:= aScan( aSR8Fields,{ |x| x[1] ==  "R8_DURACAO" } )
Local nX	:= 0

aSort( aAllSR8,,, { |x, y| x[1] < y[1] } )
For nX := 1 to Len(aAllSR8)
	If aAllSR8[ nX, nPosPD ] == cPD 		//-- somente atualiza saldo para as faltas
		nDuracao += aAllSR8[nX,nposDuracao]
    EndIf
Next nX

DbSelectArea( "SRF" )
DbSetOrder( RetOrdem( "SRF", "RF_FILIAL+RF_MAT+RF_PD+DtoS(RF_DATABAS)" ) )
DbSeek( xFilial( "SRF" ) + (cAliasSRA)->RA_MAT + cPD )
Do While SRF->( !Eof() ) .and. SRF->( RF_FILIAL + RF_MAT + RF_PD ) == ( xFilial( "SRF" ) + (cAliasSRA)->RA_MAT + cPD )
	If SRF->RF_STATUS <> "1"  			//-- utiliza somente o que esta "Ativo"
		SRF->( DbSkip() )
		Loop
	EndIf
	RecLock('SRF',.F.)
	SRF->RF_SDPAGAR -= nDuracao
	MsUnLock()
	SRF->( DbSkip() )
EndDo

RestArea(aAreaSRF)

Return()

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Atualiza dias de direito (SRF) do funcionario. Se for aniver-³
//³ sario, cria novo periodo aquisitivo.                         ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

aPerFerias:= {}
Calc_Fer(aPerFerias,dDateFin,,,,,,.T., ,dDateIni)

DbSelectArea("SRF")
DbSetOrder(2)
For nX:= 1 to len(aPerFerias)
	If aPerFerias[nX][08] == "1"
		If !(SRF->( DbSeek( SRA->RA_FILIAL + SRA->RA_MAT + aCodFol[72,1]+ DtoS(aPerFerias[nX][01]) ) ))
			RecLock( "SRF" , .T. )

			SRF->RF_FILIAL	:= SRA->RA_FILIAL
			SRF->RF_MAT		:= SRA->RA_MAT
			SRF->RF_PD		:= aCodFol[72,1]
			SRF->RF_DIASDIR := aPerFerias[nX][24]
			SRF->RF_STATUS	:= "1"
			SRF->RF_DATABAS := aPerFerias[nX][01]
			SRF->RF_DATAFIM := aPerFerias[nX][02]
			SRF->RF_DFERVAT := aPerFerias[nX][03]
			SRF->RF_DFERAAT := aPerFerias[nX][04]
			SRF->RF_DFERANT := aPerFerias[nX][14]
			SRF->RF_DFALVAT := aPerFerias[nX][15]
			SRF->RF_DFALAAT := aPerFerias[nX][16]

			SRF->( MsUnLock() )

		Else
			RecLock( "SRF" , .F. )
			SRF->RF_DIASDIR := aPerFerias[nX][24]
			SRF->RF_DFERVAT := aPerFerias[nX][03]// - SRF->RF_DIASANT
			SRF->RF_DFERAAT := aPerFerias[nX][04]
			SRF->RF_DFALAAT := aPerFerias[nX][16]
			SRF->RF_DFALVAT := aPerFerias[nX][15]
			SRF->( MsUnLock() )
		EndIf
	EndIf
Next nX

Return( Nil )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³GrvSR8Equ ºAutor  ³Kelly Soares        º Data ³  04/11/10   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Função que grava os dias pagos na ausencia para Equador    º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function GrvSR8Equ()

Local cVerbGoz   := aCodFol[786,1]
Local lCnt       := .T.
Local nDesAfas   := (cAliasSRC)->RC_HORAS
Local nSaldo     := 0
Local nPagar     := 0
Local nSaldoProx := 0

If (cAliasSRC)->RC_PD == cVerbGoz

	SR8->( DbSetOrder(1) )
	SR8->( DbSeek( xFilial('SR8') + (cAliasSRA)->RA_MAT ) )
	While SR8->( !Eof() ) .AND. SR8->R8_MAT == (cAliasSRA)->RA_MAT

		If SR8->R8_SDPAGAR > 0

			If nDesAfas > SR8->R8_SDPAGAR
				nSaldo     := 0
				nSaldoProx := nDesAfas - SR8->R8_SDPAGAR
				nPagar     := nDesAfas - ( nDesAfas - SR8->R8_SDPAGAR )
				nDesAfas   := nSaldoProx
			Else
				nPagar      := SR8->R8_SDPAGAR - ( SR8->R8_SDPAGAR - nDesAfas )
				nSaldo      := SR8->R8_SDPAGAR - nDesAfas
				nSaldoProx  := SR8->R8_SDPAGAR - nDesAfas
				lCnt := .F.
			EndIf

		    RecLock('SR8',.F.)
		    SR8->R8_DPAGOS  := nPagar
		    SR8->R8_SDPAGAR := nSaldo
		    SR8->R8_STATUS  := 'C'
		    MsUnLock()

		    If !lCnt
		    	Exit
		    EndIf

		 EndIf

		SR8->( DbSkip() )
	EndDo

EndIf

Return()

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³GrvFerEqu ºAutor  ³ Kelly Soares       º Data ³  28/10/10   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Atualiza ausencias (SR8) e periodos (SRF) de ferias.       º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ Equador                                                    º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function GrvFerEqu()

Local cVerba 	 := aCodFol[72,1]
Local dDataAux
Local dDataAux1
Local lOk    	 := .F.
Local lCnt		 := .T.
Local nPagar 	 := 0
Local nSaldo 	 := 0
Local nSaldoProx := 0
Local nDias  	 := nDFerFol + nDFerGoz

If nDias > 0

//---------------------------------------------------------------------------------------//
// Atualiza dias de ausencia referente a ferias.                                         //
//---------------------------------------------------------------------------------------//
	SR8->( DbSetOrder( RetOrdem("SR8","R8_FILIAL+R8_MAT+R8_PER+R8_NUMPAGO") ) )
	SR8->( DbSeek( SRA->RA_FILIAL + SRA->RA_MAT + cPeriodo ) )
	While SR8->( !Eof() ) .AND. SR8->R8_FILIAL + SR8->R8_MAT + SR8->R8_PER == SRA->RA_FILIAL + SRA->RA_MAT + cPeriodo

		If ( SR8->R8_PD == cVerba ) .and. ( SR8->R8_SDPAGAR > 0 )

			If nDias > SR8->R8_SDPAGAR
				nSaldo     := 0
				nSaldoProx := nDias - SR8->R8_SDPAGAR
				nPagar     := nDias - ( nDias - SR8->R8_SDPAGAR )
				nDias      := nSaldoProx
			Else
				nPagar      := SR8->R8_SDPAGAR - ( SR8->R8_SDPAGAR - nDias )
				nSaldo      := SR8->R8_SDPAGAR - nDias
				nSaldoProx  := SR8->R8_SDPAGAR - nDias
				lCnt := .F.
			EndIf

		    RecLock('SR8',.F.)
		    SR8->R8_DPAGOS  := nPagar
		    SR8->R8_SDPAGAR := nSaldo
		    SR8->R8_STATUS  := 'C'
		    MsUnLock()

		    If !lCnt
		    	Exit
		    EndIf

		EndIf
		SR8->( DbSkip() )
	EndDo

EndIf

//---------------------------------------------------------------------------------------//
// Atualiza dias de ferias e dias adicionais pagos nos periodos aquisitivos.             //
//---------------------------------------------------------------------------------------//
If (nDFerFol > 0) .or. (nDFerAdi > 0) .or. (nDFerGoz > 0)
	DbSelectArea("SRH")
	DbSetOrder(1)
	If DbSeek(SRA->RA_FILIAL + SRA->RA_MAT)
		While !Eof() .and. SRH->RH_FILIAL + SRH->RH_MAT == SRA->RA_FILIAL + SRA->RA_MAT
			If lOk := (SRH->RH_PERIODO == cPeriodo)
		   		dDataAux := SRH->RH_DATABAS
		   		Exit
			EndIf
			DbSkip()
		EndDo
	EndIf
	If lOk
		DbSelectArea("SRF")
		DbSetOrder(1)
		If DbSeek(SRA->RA_FILIAL + SRA->RA_MAT + DtoS(dDataAux))
			RecLock("SRF",.F.)
			SRF->RF_DFERANT += nDFerFol
			SRF->RF_DBONANT += nDFerAdi
			SRF->RF_DBONGOZ += nDFerGoz
			If (SRF->RF_DIASDIR <= SRF->RF_DFERANT + SRF->RF_DFALVAT + SRF->RF_DFALAAT) .AND. ;
			   (SRF->RF_DIASADI == SRF->RF_DBONANT + SRF->RF_DBONGOZ)
				SRF->RF_STATUS := "3"
				SRF->RF_DFERVAT := 0
				SRF->RF_DFERAAT := 0
				SRF->RF_DFALVAT := 0
				SRF->RF_DFALAAT := 0
				SRF->RF_DBONVAT := 0
				SRF->RF_DBONAAT := 0
			EndIf
			SRF->(MsUnLock())
	   		dDataAux1:= SRF->RF_DATAFIM
		EndIf
	EndIf
EndIf

AtuFerEqu(dDtaLimite,dDataAux1)

Return( Nil )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³AtuFerEqu ºAutor  ³ Erika Kanamori     º Data ³  07/12/10   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Atualiza SRF para localizacao Equador.                     º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ Equador (fechamento e GPFERIAS).                           º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function AtuFerEqu(dDtaLimite,dDtaBase)

Local nX:= 0

DEFAULT dDtaBase := SRA->RA_ADMISSA

//---------------------------------------------------------------------------------------//
// Carrega periodos aquisitivos para atualizacao.                                        //
//---------------------------------------------------------------------------------------//
aPerFerias := {}
Calc_Fer(aPerFerias,dDtaLimite,,,,,,,dDtaBase)

DbSelectArea("SRF")

	DbSetOrder(2)
	For nX:= 1 to len(aPerFerias)
		If aPerFerias[nX][08] == "1"
			If !(SRF->( DbSeek( SRA->RA_FILIAL + SRA->RA_MAT + aCodFol[72,1]+ DtoS(aPerFerias[nX][01]) ) ))
				RecLock( "SRF" , .T. )

				SRF->RF_FILIAL	:= SRA->RA_FILIAL
				SRF->RF_MAT		:= SRA->RA_MAT
				SRF->RF_PD		:= aCodFol[72,1]
				SRF->RF_DIASDIR := aPerFerias[nX][19]
				SRF->RF_DIASADI := aPerFerias[nX][20]
				SRF->RF_STATUS	:= "1"
				SRF->RF_DATABAS := aPerFerias[nX][01]
				SRF->RF_DATAFIM := aPerFerias[nX][02]
				SRF->RF_DFERVAT := aPerFerias[nX][03]
				SRF->RF_DFERAAT := aPerFerias[nX][04]
				SRF->RF_DFERANT := aPerFerias[nX][14]
				SRF->RF_DFALVAT := aPerFerias[nX][15]
				SRF->RF_DFALAAT := aPerFerias[nX][16]
				SRF->RF_DBONVAT := aPerFerias[nX,17]
				SRF->RF_DBONAAT := aPerFerias[nX,18]
				SRF->( MsUnLock() )

			Else
				DbGoTo(aPerFerias[nX,30])
				If aPerFerias[nX,03] == 0 .Or. SRF->RF_DFERVAT == 0
					RecLock("SRF",.F.)
					SRF->RF_DFERVAT := aPerFerias[nX,3]
					SRF->RF_DFERAAT := aPerFerias[nX,4]
					SRF->RF_DFALVAT := aPerFerias[nX,15]
					SRF->RF_DFALAAT := aPerFerias[nX,16]
					SRF->RF_DBONVAT := aPerFerias[nX,17]
					SRF->RF_DBONAAT := aPerFerias[nX,18]
					SRF->RF_DIASDIR := aPerFerias[nX,19]
					SRF->RF_DIASADI := aPerFerias[nX,20]
					SRF->(MsUnLock())
				EndIf

			EndIf
		EndIf
	End

Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³GrvFerSRF ºAutor  ³Tiago Malta         º Data ³  13/05/11   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Atualiza o SRF para Venezuela                              º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function GrvFerSRF(cFilSRA)

Local aDias    	:= {}
Local dProxPer 	:= CtoD('//')
Local nTotDias	:= 0
Local nTotAux	:= 0
Local nx       	:= 0
Local nPosAb   	:= 0
Local nTotDiff 	:= 0

Private cRot := ""

DbSelectArea( "SRH" )
DbSetOrder( RetOrder( "SRH", "RH_FILIAL+RH_MAT+DtoS(RH_DATABAS)+DtoS(RH_DATAINI))" ))

If	DbSeek( (cAliasSRA)->RA_FILIAL + (cAliasSRA)->RA_MAT )
	While !SRH->( Eof() ) .And. SRH->( RH_FILIAL + RH_MAT ) == (cAliasSRA)->RA_FILIAL + (cAliasSRA)->RA_MAT

		If MesAno(SRH->RH_DATAINI) == (cAnoProc+cMesProc)

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Apura periodos posteriores ao calculado                      ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			aPerFerias	:= {}
			Calc_Fer(aPerFerias,dDtaLimite)

 			nPosAb      := Ascan(aPerFerias,{ |X| X[8] $ " 1" })

 			If nPosAb > 0

				nTotDiaPer	:= aPerFerias[nPosAb][3] + aPerFerias[nPosAb][4]
				nTotDias	:= SRH->RH_DFERIAS
				nTotDiff    := iif( nTotDias > nTotDiaPer , nTotDias - nTotDiaPer,0 )
				nTotAux     := iif( nTotDias <= nTotDiaPer , nTotDias , nTotDiaPer )

				DbSelectArea("SRF")
				DbSetOrder(2)
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Se recebeu todos os dias de direito, atualiza DIAS PAGOS e   ³
				//³ STATUS e gera novo periodo.                                  ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If DbSeek( SRH->RH_FILIAL + SRH->RH_MAT + aCodFol[72,1] + DtoS(SRH->RH_DATABAS) )

					If SRF->RF_DFERANT + nTotAux > nTotDiaPer
						nTotAux  := ( nTotAux - SRF->RF_DFERANT )
						nTotDiff += SRF->RF_DFERANT
					EndIf

					RecLock( "SRF" , .F. )
					SRF->RF_DFERANT += nTotAux

					If SRF->RF_DFERANT == SRF->RF_DIASDIR
						SRF->RF_STATUS  := "3"
						aPerFerias[nPosAb][8] := "3"
					EndIf

					SRF->( MsUnLock() )

					If nTotDiff > 0

						dProxPer := aPerFerias[nPosAb][2] + 1

						For nX := 1 to Len(aPerFerias)

							If !SRF->( DbSeek( SRH->RH_FILIAL + SRH->RH_MAT + aCodFol[72,1]+ DtoS(dProxPer) ) )

									DiasFerVen(dProxPer,YearSum(dProxPer - 1,1),@aDias)

									RecLock( "SRF" , .T. )
									SRF->RF_FILIAL	:= SRH->RH_FILIAL
									SRF->RF_MAT		:= SRH->RH_MAT
									SRF->RF_PD		:= aCodFol[72,1]
									SRF->RF_DIASDIR := IIF( LEN(aDias) > 0 , aDias[1] , 0 )
									SRF->RF_STATUS	:= "1"
									SRF->RF_DATABAS := dProxPer
									SRF->RF_DATAFIM := YearSum(dProxPer - 1,1)
									SRF->RF_DIASANT := nTotDiff
									SRF->( MsUnLock() )

									nTotDiff := 0
									Exit
							ElseIf SRF->RF_STATUS $ " 1"
								RecLock( "SRF" , .F. )
								SRF->RF_DIASANT := nTotDiff
								SRF->( MsUnLock() )
								Exit
							ElseIf SRF->RF_STATUS == "3"
								dProxPer := aPerFerias[nX][2] + 1
							EndIf
						Next nX
					EndIf
				EndIf
			EndIf
		EndIf
		SRH->( DbSkip() )

	EndDo
EndIf

Return( Nil )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³fAtuSRFAng   ³Autor  ³Marcelo Silveira ³ Data ³  04/10/12   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Atualiza os periodos de ferias do funcionario e gera novos  º±±
±±º          ³para o ano seguinte - Angola                                º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function fAtuSRFAng( cFilSRA )

Local aTabS004  := {}
Local aAreaSRF	:= SRF->( getArea() )
Local aAreaSRH	:= SRH->( GetArea() )
Local cChaveSRF	:= ""
Local cFilSRF	:= Space(FWGETTAMFILIAL)
Local cPdSrf	:= aCodFol[72,1]
Local cMat		:= SRA->RA_MAT
Local dDateIni  := RCH->RCH_DTINI
Local dDateFin	:= RCH->RCH_DTFIM
Local dIniUltP	:= CtoD("//")
Local dIniNextP	:= CtoD("//")
Local dFimNextP	:= CtoD("//")
Local lPerFeAc	:= .T.
Local nx		:= 0
Local nDiasAnt	:= 0
Local nDiasPg   := 0
Local nDiasFer	:= 30

DEFAULT cFilSRA := Space(FWGETTAMFILIAL)

//Dados da tabela de Ferias
fRetTab(@aTabS004,"S004",,,RCH->RCH_DTFIM)
If !Empty(aTabS004)
   	nDiasFer := aTabS004[5]
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Atualiza dias de ferias dos periodos existentes   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
aPerFerias:= {}
Calc_Fer(aPerFerias,dDateFin,,,,,,.T., ,dDateIni)

DbSelectArea("SRF")
DbSetOrder(2)
For nX:= 1 to len(aPerFerias)
	If aPerFerias[nX][08] == "1" //Somente periodos ativos
		If (SRF->( DbSeek( SRA->RA_FILIAL + SRA->RA_MAT + aCodFol[72,1]+ DtoS(aPerFerias[nX][01]) ) ))
			RecLock( "SRF" , .F. )
			SRF->RF_DFERVAT := Min( SRF->RF_DIASDIR, aPerFerias[nX][03] ) //Dias de ferias vencidos
			SRF->RF_DFERAAT := Min( SRF->RF_DIASDIR, aPerFerias[nX][04] ) //Dias de ferias proporcionais
			SRF->RF_DIASANT := aPerFerias[nX][25] //Dias de ferias antecipados
			SRF->( MsUnLock() )
		EndIf
		dIniUltP := aPerFerias[nX][01]
	EndIf
Next nX


//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Atualiza dias de ferias pagos no fechamento do periodo ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If nDFerfol > 0

	DbSelectArea( "SRH" )
	DbSetOrder( RetOrder( "SRH", "RH_FILIAL+RH_MAT+DtoS(RH_DATABAS)+DtoS(RH_DATAINI))" ))

	If	DbSeek( (cAliasSRA)->RA_FILIAL + (cAliasSRA)->RA_MAT )
		Do While !SRH->( Eof() ) .And. SRH->( RH_FILIAL + RH_MAT ) == (cAliasSRA)->RA_FILIAL + (cAliasSRA)->RA_MAT

			If MesAno(SRH->RH_DATAINI) == (cAnoProc+cMesProc)

				nDiasPg	:= SRH->RH_DFERIAS

				DbSelectArea("SRF")
				DbSetOrder(2)
				If DbSeek( SRH->RH_FILIAL + SRH->RH_MAT + aCodFol[72,1] + DtoS(SRH->RH_DATABAS) )

					Do While SRF->( !Eof() ) .AND. SRF->RF_MAT == SRA->RA_MAT
						If SRF->RF_PD == cPdSrf .AND. SRF->RF_STATUS $ " 1"

							RecLock( "SRF" , .F. )

							If nDiasAnt > 0
								SRF->RF_DIASANT += nDiasAnt
								nDiasAnt := 0
							EndIf

							//Se ja possui dias vencidos atualiza os dias pagos do periodo
							If SRF->RF_DFERVAT > 0
								SRF->RF_DFERANT += nDiasPg
							Else
								SRF->RF_DIASANT += nDiasPg
							EndIf

							nDiasPg := 0

							If (SRF->RF_DFERANT + SRF->RF_DIASANT) > SRF->RF_DIASDIR
								nDiasAnt := (SRF->RF_DFERANT + SRF->RF_DIASANT) - SRF->RF_DIASDIR
								SRF->RF_DFERANT	-= nDiasAnt
			                   	SRF->RF_STATUS	:= "3"
			   				ElseIf (SRF->RF_DFERANT + SRF->RF_DIASANT) == SRF->RF_DIASDIR
								SRF->RF_DFERANT	+= SRF->RF_DIASANT
								SRF->RF_DIASANT	:= 0
			                   	SRF->RF_STATUS	:= "3"
			   				EndIf

							SRF->( MsUnLock() )

						EndIf
						SRF->( DbSkip() )
					EndDo
				EndIf
			EndIf
			SRH->( DbSkip() )
		EndDo
    EndIf

EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Cria um novo periodo para o ano seguinte          ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If (nDiasAnt > 0 .Or. RCH->RCH_MES == "12") .And. SRA->RA_SITFOLH # "D"

	If Empty(xFilial("SRF"))
		cFilSRF := Space(FWGETTAMFILIAL)
	Else
		cFilSRF:= cFilSra
	EndIf

	//Verifica se utiliza Ano Civil
	If Type('P_FERPAC') == "U"
		lPerFeAc  := AllTrim( Posicione("RCA",1,xFilial("RCA")+"P_FERPAC","RCA_CONTEU") ) $ '"S"'
	EndIf

	dIniNextP := FirstYDate( YearSum(RCH->RCH_DTFIM, 1) )	//Primeiro dia do ano civil seguinte
	dFimNextP := LastYDate( YearSum(RCH->RCH_DTFIM, 1) ) 	//Ultimo dia do ano civil seguinte

	//Se nao usa ano civil a data sera com base nos periodos existentes
	If !lPerFeAc .And. !Empty( dIniUltP )
		dIniNextP	:= YearSum(dIniUltP,1)
		dFimNextP	:= YearSum(dIniUltP,2)-1
	EndIf

	cChaveSRF 	:= cFilSRF + SRA->RA_MAT + cPdSRF + DtoS(dIniNextP)

	SRF->( DbSetOrder(nOrdSR8SRF) )
	SRF->( DbGoTop() )
	If !(SRF->(DbSeek( cChaveSRF )))

		RecLock( "SRF" , .T. )
		SRF->RF_FILIAL	:= cFilSRF
		SRF->RF_MAT		:= cMat
		SRF->RF_PD		:= cPdSrf		//Verba lancamento
		SRF->RF_DATABAS	:= dIniNextP	//Data inicio do periodo ano seguinte
		SRF->RF_DATAFIM	:= dFimNextP	//Data fim do periodo ano seguinte
		SRF->RF_DIASDIR	:= nDiasFer		//Dias de direito conforme a tabela de ferias
		SRF->RF_DIASANT	:= nDiasAnt		//Dias antecipados do proximo periodo (se houver)
		SRF->RF_STATUS	:= "1"
		SRF->( MsUnLock() )

	EndIf

EndIf

RestArea(aAreaSRF)
RestArea(aAreaSRH)

Return( Nil )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³fAtuSRFBol   ³Autor  ³Claudinei Soares ³ Data ³  26/12/12   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Atualiza os periodos de ferias do funcionario e gera novos  º±±
±±º          ³para o ano seguinte - Bolivia                               º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function fAtuSRFBol()

Local cVerbFer   := aCodFol[72,1]
Local dDataInic  := CtoD("")
Local dDataIniP  := CtoD("")
Local dDtFimP	 := CtoD("")
Local dDataDe	 := CtoD("")
Local nDiasven   := 0
Local cKey       := ""
Local lExiste    := .F.

If ( !Empty(SRA->RA_DTREC) )
	dDataInic := SRA->RA_DTREC
EndIf

If ( Empty(dDatainic) )
	dDataInic:=SRA->RA_ADMISSA
EndIf

//Posiciona na tabela de Controle de Dias
SRF->( DbSetOrder(1) )
	If SRF->( DbSeek( xFilial('SRF') + SRA->RA_MAT ) )
		While SRF->( !Eof() ) .AND. SRF->RF_MAT == SRA->RA_MAT
			If SRF->RF_PD == cVerbFer .AND. SRF->RF_STATUS $ " 1"

				dDataDe :=CtoD( StrZero(Day(dDataInic),2)+ "/"+RCH->RCH_MES+"/"+RCH->RCH_ANO) //DIA ADM + MES/ANO PERIODO.
				dDataIniP :=CtoD( StrZero( DAY( dDataInic ), 2 ) + "/" + StrZero( Month( dDataInic ),2 ) + "/" + StrZero(YEAR(dDataDe),4 ) )  //DIA/MES ADM + ANO PERIODO
				If dDataIniP <= dDataDe
					dDtFimP := CtoD( StrZero( DAY( dDataInic ),2 ) + "/" + StrZero( Month( dDataInic ) ,2 ) + "/" + StrZero( YEAR(dDataDe) + 1, 4) ) -1
				Else
					dDataIniP:= CtoD( StrZero( DAY( DDATAINIC) , 2 )  + "/" + StrZero( Month( DDATAINIC ) ,  2 ) + "/" + StrZero( YEAR(DDATADE ) - 1,  4 ) )
					dDtFimP := CtoD( StrZero( DAY( DDATAINIC ), 2 ) + "/" + StrZero( Month( DDATAINIC ),2  ) + "/" + StrZero(YEAR(DDATADE) , 4) ) -1
				EndIf

				If dDataInic < dDtFimPer
					cKey := XFILIAL("SRF") + SRA->RA_MAT + DtoS(dDatainip) + aCodFol[72,1]
					DDATAF := If(SRA->RA_SITFOLH = "D" , SRA->RA_DEMISSA, dDtFimPer )
					NANOSTRAB := (( DDATAF - DDATAINIC) + 1) / 365
					NX := FPOSTAB("S010", SRA->RA_PROCES, "=", 4 , NANOSTRAB , "<=" , 6 )
					NDIASVAC := If(NX > 0,  FTABELA("S010" , NX , 7 ) ,  0 )
					NDIASPROP := NDIASVAC / 365  * ( dDataF - dDataIniP + 1 )
					If ( NDIASPROP >= NDIASVAC )
						NDIASVEN  :=  NDIASVAC
						NDIASPROP := 0
					EndIf

					lExiste := (SRF->RF_FILIAL+SRF->RF_MAT+DtoS(SRF->RF_DATABAS)+SRF->RF_PD == cKey)

					If !lExiste
						lExiste := SRF->( DbSeek( cKey ) )
						If lExiste .And. !SRF->RF_STATUS $ " 1"
							Exit
						EndIf
   					EndIf

					If lExiste
						RecLock( "SRF" , .F. )
						SRF->RF_DATABAS := dDatainip
						SRF->RF_DATAFIM := dDtFimP
						SRF->RF_DIASDIR := NDIASVAC
						SRF->RF_DFERVAT := NDIASVEN
						SRF->RF_DFERAAT := NDIASPROP
						SRF->RF_STATUS	:= "1"
						SRF->( MsUnLock() )

						If NDIASPROP > NDIASVEN .And. dDatainip > dDataInic
							cKey    := xFilial("SRF") + SRA->RA_MAT + DTOS(YearSub(dDatainip, 1)) + aCodFol[72,1]
							lExiste := SRF->(DBSeek(cKey))
							IF lExiste .And. SRF->RF_STATUS $ " 1"
								RecLock("SRF", .F.)
								SRF->RF_DFERVAT := SRF->RF_DIASDIR
								SRF->RF_DFERAAT := 0
								SRF->(MsUnlock())
							EndIf
						EndIf 
					Else
						RecLock( "SRF" , .T. )
						SRF->RF_FILIAL	:= SRA->RA_FILIAL
						SRF->RF_MAT		:= SRA->RA_MAT
						SRF->RF_PD		:= cVerbFer
						SRF->RF_DATABAS := dDatainip
						SRF->RF_DATAFIM := dDtFimP
						SRF->RF_DIASDIR := NDIASVAC
						SRF->RF_DFERVAT := NDIASVEN
						SRF->RF_DFERAAT := NDIASPROP
						SRF->RF_STATUS	:= "1"
						SRF->( MsUnLock() )

						cKey := XFILIAL("SRF") + SRA->RA_MAT + DTOS(YearSub(dDatainip,1)) + aCodFol[72,1]
						lExiste := SRF->( DBSeek( cKey ) )
						IF lExiste .And. SRF->RF_STATUS $ " 1"
							RecLock( "SRF" , .F. )
							SRF->RF_DFERVAT := SRF->RF_DIASDIR
							SRF->RF_DFERAAT := 0
							SRF->( MsUnlock() )
						EndIf

					EndIf
				EndIf
				Exit
			EndIf
			SRF->( DbSkip() )
		EndDo
	EndIf
Return()

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³Gpm120PrcVld ³Autor  ³Leandro Drumond  ³ Data ³  09/10/13   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Valida processo selecionado no pergunte (SX1)               º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function Gpm120PrcVld()
Local lRet := .T.

lRet := ExistCpo("RCJ")

If lRet //Zera demais perguntas para forcar a selecao e atualizacao
	SetMVValue("GPEM120","MV_PAR01",MV_PAR01)
	SetMVValue("GPEM120","MV_PAR02",Space(3))
	SetMVValue("GPEM120","MV_PAR03",Space(6))
	SetMVValue("GPEM120","MV_PAR04",Space(2))
	Pergunte("GPEM120",.F.)
EndIf

Return lRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³Gpm120RotVld ³Autor  ³Leandro Drumond  ³ Data ³  09/10/13   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Valida roteiro selecionado no pergunte (SX1)                º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function Gpm120RotVld(cProcesso,cVarRet)

Local cRoteiro  := &cVarRet
Local cPeriodo	:= Space(6)
Local cSemana	:= Space(2)
Local lRet 		:= .T.

DEFAULT cProcesso := ""

If !Empty(cRoteiro)
	If !Empty( cProcesso )
		If !fGetLastPer( @cPeriodo, @cSemana , cProcesso, cRoteiro ) //Procura proximo periodo aberto
			Help( ,, "HELP",, STR0051, 1, 0 ) //"Não existe período aberto para o roteiro selecionado"
			lRet := .F.
		EndIf
	EndIf
EndIf

//Atualiza variaveis do pergunte
SetMVValue("GPEM120","MV_PAR02",cProcesso)
SetMVValue("GPEM120","MV_PAR02",cRoteiro)
SetMVValue("GPEM120","MV_PAR03",cPeriodo)
SetMVValue("GPEM120","MV_PAR04",cSemana)
Pergunte("GPEM120",.F.)

Return lRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³fSRAThread   ³Autor  ³Leandro Drumond  ³ Data ³  14/10/13   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Monta registros que serao executados em cada thread         º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function fSRAThread(nSumSRA,cFil,lAutMovSRC,lRobo,lGrid)
Local aThreads	:= {}
Local aAux		:= {}
Local cAliasQry := GetNextAlias()
Local cOrder 	:= "% 2, 3, 4, 5, 6, 7 %" //Filial, Processo, Turno, SEQ Turno, Regra, Matrícula
Local cWhere 	:= " SRA.RA_PROCES = '" + cProcesso + "' "
Local cWhere2	:= "% SRA.RA_PROCES = '" + cProcesso + "' %"
Local nCount	:= 0
Local cJoin   	:= ""
Local cFilSRA	:= ""
Local nThreads  := 1
Local nFuncPThr := nSumSRA
Local cPcPrSm	:= "% SRG.RG_DTGERAR >= '"+ cPeriodo + "01' %"
Local cDemissa 	:= "% AND SRA.RA_DEMISSA < '" + cPeriodo + "01' %"
Local cFunExec  := "GetSrvVersion"

If cPaisLoc $ "ARG/CHI/COL/COS/DOM/MEX" // para rescisión tomará el periodo, procedimeinto y num Pago
	cPcPrSm := "% SRG.RG_APLPER ='" + cPeriodo + "' AND  RG_APLNPG ='" + cNumPag + "' AND RG_APLROT = '" + cRoteiro +"' %"
	cDemissa := "% %"
EndIf

//Se for roteiro de PLR e estiver definido para efetuar calculo de PLR de demitidos, carrega até os funcionários deletados para fechamento
If !(cRoteiro == fGetCalcRot('F') .and. GetMvRH("MV_PLRDEM",,"N") == "S")
	If cPaisLoc != "MEX"
		cWhere += " AND ( SRA.RA_DEMISSA = '' OR SRA.RA_DEMISSA >= '" + cPeriodo + "01' ) "
	EndIf
EndIf

cWhere := "% " + cWhere + " %"

If nSumSRA > 300 .Or. lRobo
	If FindFunction(cFunExec) .and. SubStr(&cFunExec.(), 1, 2) >= "17"
		nThreads  := GetMvRH("MV_CALCTHD",, 5)
	Else
		nThreads  := Min(GetMvRH("MV_CALCTHD",, 5),5)
	EndIf
	nThreads  := Max(nThreads,1)
	If nThreads > 1 .and. !lGrid
		 nThreads++ //Soma um para que uma parte dos registros sejam executados na thread principal
	EndIf
	nFuncPThr := Int(nSumSRA / nThreads)
EndIf

cJoin := "%"
cJoin += FWJoinFilial( "SRA", "RCH" )
cJoin += "%"

If lAutMovSRC .and. cTpRoteir == '9'
	BeginSql alias cAliasQry
		SELECT DISTINCT SRA.R_E_C_N_O_ NRECNO, SRA.RA_FILIAL FILIAL, SRA.RA_PROCES, SRA.RA_TNOTRAB, SRA.RA_SEQTURN, SRA.RA_REGRA, SRA.RA_MAT
		FROM %table:SRA% SRA INNER JOIN %table:RCH% RCH ON %exp:cJoin%
		INNER JOIN %table:SRC% SRC ON SRA.RA_FILIAL = SRC.RC_FILIAL AND SRA.RA_MAT = SRC.RC_MAT AND	SRC.RC_PERIODO = %exp:cPeriodo% AND SRC.RC_ROTEIR = %exp:cRoteiro%
		WHERE %exp:cWhere% AND
		      SRA.%NotDel% AND
		      SRC.%NotDel% AND
		      RCH.RCH_FILIAL = %exp:cFil% AND
		      RCH.%NotDel%

		UNION

		SELECT DISTINCT SRA.R_E_C_N_O_ NRECNO, SRA.RA_FILIAL FILIAL, SRA.RA_PROCES, SRA.RA_TNOTRAB, SRA.RA_SEQTURN, SRA.RA_REGRA, SRA.RA_MAT
		FROM %table:SRA% SRA INNER JOIN %table:RCH% RCH ON %exp:cJoin%
		INNER JOIN %table:SRG% SRG ON SRG.RG_FILIAL = SRA.RA_FILIAL AND SRG.RG_MAT = SRA.RA_MAT AND SRG.RG_DTGERAR >= %exp:(cPeriodo+"01")% AND SRG.%NotDel%
		WHERE %exp:cWhere2% AND
		      SRA.%NotDel% AND
		      RCH.RCH_FILIAL = %exp:cFil% AND
		      RCH.%NotDel% AND
		      SRA.RA_DEMISSA < %exp:(cPeriodo+"01")%
		ORDER BY %exp:cOrder%
	EndSql
Else

	If cPaisLoc == "MEX"
		BeginSql alias cAliasQry
			SELECT DISTINCT SRA.R_E_C_N_O_ NRECNO, SRA.RA_FILIAL FILIAL, SRA.RA_PROCES, SRA.RA_TNOTRAB, SRA.RA_SEQTURN, SRA.RA_REGRA, SRA.RA_MAT
			FROM %table:SRA% SRA INNER JOIN %table:RCH% RCH ON %exp:cJoin%
			INNER JOIN %table:SRC% SRC ON SRA.RA_FILIAL = SRC.RC_FILIAL AND SRA.RA_MAT = SRC.RC_MAT AND	SRC.RC_PERIODO = %exp:cPeriodo% AND	SRC.RC_SEMANA = %exp:cNumPag% AND SRC.RC_ROTEIR = %exp:cRoteiro%
			WHERE %exp:cWhere% AND
			      SRA.%NotDel% AND
			      SRC.%NotDel% AND
			      RCH.RCH_FILIAL = %exp:cFil% AND
			      RCH.%NotDel%

			UNION

			SELECT DISTINCT SRA.R_E_C_N_O_ NRECNO, SRA.RA_FILIAL FILIAL, SRA.RA_PROCES, SRA.RA_TNOTRAB, SRA.RA_SEQTURN, SRA.RA_REGRA, SRA.RA_MAT
			FROM %table:SRA% SRA INNER JOIN %table:RCH% RCH ON %exp:cJoin%
			INNER JOIN %table:SRG% SRG ON SRG.RG_FILIAL = SRA.RA_FILIAL AND SRG.RG_MAT = SRA.RA_MAT AND %exp:cPcPrSm% AND SRG.%NotDel%
			WHERE %exp:cWhere2% AND
			      SRA.%NotDel% AND
			      RCH.RCH_FILIAL = %exp:cFil% AND
			      RCH.%NotDel%
			     %exp:cDemissa%
			ORDER BY %exp:cOrder%
		EndSql
	Else
		BeginSql alias cAliasQry
			SELECT DISTINCT SRA.R_E_C_N_O_ NRECNO, SRA.RA_FILIAL FILIAL, SRA.RA_PROCES, SRA.RA_TNOTRAB, SRA.RA_SEQTURN, SRA.RA_REGRA, SRA.RA_MAT
			FROM %table:SRA% SRA INNER JOIN %table:RCH% RCH ON %exp:cJoin%
			WHERE %exp:cWhere% AND
			      SRA.%NotDel% AND
			      RCH.RCH_FILIAL = %exp:cFil% AND
			      RCH.%NotDel%

			UNION

			SELECT DISTINCT SRA.R_E_C_N_O_ NRECNO, SRA.RA_FILIAL FILIAL, SRA.RA_PROCES, SRA.RA_TNOTRAB, SRA.RA_SEQTURN, SRA.RA_REGRA, SRA.RA_MAT
			FROM %table:SRA% SRA INNER JOIN %table:RCH% RCH ON %exp:cJoin%
			INNER JOIN %table:SRG% SRG ON SRG.RG_FILIAL = SRA.RA_FILIAL AND SRG.RG_MAT = SRA.RA_MAT AND %exp:cPcPrSm% AND SRG.%NotDel%
			WHERE %exp:cWhere2% AND
			      SRA.%NotDel% AND
			      RCH.RCH_FILIAL = %exp:cFil% AND
			      RCH.%NotDel%
			     %exp:cDemissa%
			ORDER BY %exp:cOrder%
		EndSql

	EndIf

EndIf

While ( ( cAliasQry )->( !Eof() ) )
	If Empty(cFilSRA)
		cFilSRA := ( cAliasQry )->FILIAL
	EndIf

	If nCount > nFuncPThr
		aAdd(aThreads,aAux)
		aAux := {}
		nCount := 0
	EndIf

	aAdd( aAux , ( cAliasQry )->NRECNO )
	nCount++

	( cAliasQry )->( DbSkip() )
EndDo

If !Empty(aAux)
	aAdd(aThreads,aAux)
	aAux := {}
EndIf

If !Empty(cFilSRA)
	cFilAnt := cFIlSRA
EndIf

(cAliasQry)->(dbCloseArea())

Return aThreads

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³Gp120FecFol   ³ Autor ³ Leandro Drumond   ³ Data ³16.10.2013³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Fecha periodo da folha.				                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ GPEM120()                                                  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function Gp120FecFol(cTnoAux, dDtaParam, cTemMov, aLogVerbas, aLogId, aLogPer, aLogPrgF, aVlrMetric)

Local aSalInc       	:= {}			// Verbas que Inc. Sal. Arq. Alt. Salariais
Local aValFutSRK		:= {} 			// Valores futuros a serem atualizados
Local aValSR8			:= {}			// Lancamentos do SR8 a serem atualizados
Local aValMSegRGB		:= {}		    // Lancamentos para o Periodo Seguinte de Incidencias
Local aPerSeguinte		:= {}			// Perido seguinte a ser transferido
Local aTamSR8			:= {}
Local aDadosIR			:= {}
Local aMat          	:= {}
Local aAntig        	:= {}
Local aTabModal     	:= {}  			// Tabela de Modalidade Argentina
Local aTabReduc     	:= {}  			// Tabela de Redução Patronal
Local aRatFunc			:= {}			//Programação de rateio que deverá ser replicada para o próximo período
Local cCodFer							//Codigo da Verba de Ferias refere ao mes
Local cCodAdi							//Codigo da Verba de Adicionais de Ferias refere ao mes
Local cCodGoz							//Codigo da Verba de Adicionais de Ferias Gozadas refere ao mes
Local cCodDPag          := ""           //Código de días Pagados
Local cCodCesa
Local cNextPer
Local cNextPgto
Local cNextProc
Local cNextRot
Local cNextDtRef
Local cCampo
Local cContrSind
Local cCodProx      	:= ""
Local cCodReduc     	:= ""
Local cDeMes			:= ""
Local cFunExec  		:= "GetSrvVersion"
Local cRotBkp			:= cRoteiro
Local dDataAux			:= CtoD("")
Local dDtFimAfa			:= CToD("")
Local lPgSind 			:= .F.
Local lAtualiza 		:= .T.
Local lIdAboOk 			:= .T.
Local lVerbasOk 		:= .F.
Local nPosMod
Local nAntig
Local nMesAntig
Local nPrazo
Local nCont
Local nPosRCM							// Contador controle
Local nItens
Local nPosRev
Local nAltReg
Local nPosPDRGB
Local nPosFilialRGB
Local nO
Local nP
Local nPer
Local nPosMetric        := 0
Local nPosRed
Local nPosDataIni		:= 0
Local nPosDtRet			:= 0
Local nPosSdPagar		:= 0
Local nPosDPagos		:= 0
Local nPosStatus		:= 0
Local nPosvalor			:= 0
Local nPosDPagar		:= 0
Local nPosNumID			:= 0
Local nPosContAfa		:= 0
Local nPosSeq			:= 0
Local nPosDPgMes		:= 0
Local nPosDiasEmp		:= 0
Local nTempoParc		:= 0
Local nPosTbFer			:= 0
Local nX				:= 0
Local nPosSem 			:= 0
Local lUltSemana 		:= .F.
Local dDtIniFer
Local nPos				:= 0
Local nPosAux			:= 0
Local nValLiq           := 0
Local nValProv          := 0
Local nVacPer			:= 0
Local nDFerApPg			:= 0
Local cCodConVac		:= ""
Local cTipoAfas			:= ""

SetMnemonicos(xFilial("RCA"),NIL,.T.,"P_REGPARCI")
P_REGPARCI			:= If( Type("P_REGPARCI") == "U", .F., P_REGPARCI)

SetMnemonicos(xFilial("RCA"),NIL,.T.,"P_SEGFALT")
P_SEGFALT			:= If( Type("P_SEGFALT") == "U", .F., P_SEGFALT)

SetMnemonicos(xFilial("RCA"),NIL,.T.,"P_FECPROG")
P_FECPROG			:= If( Type("P_FECPROG") == "U", .F., P_FECPROG)

Private lSegFaltas	:= P_SEGFALT
Private lGestPubl 	:= IIF(ExistFunc("fUsaGFP"),If(cModulo=="GPE", .F. , fUsaGFP()),.F.)
Private lTemAbMes	:= .F.			// Variavel para Abono Pecuniario no mes corrente
Private lTemAbMSeg	:= .F.			// Variavel para Abono Pecuniario no mes seguinte
Private lAllSRK		:= .F.			// SRK do funcionário já pesquisada?
Private lAllSR8		:= .F.			// SR8 do funcionário já pesquisada?
Private lAfPerda	:= .F.			// Variavel para informar existencia de afastamento com perda ou prorrogacao do periodo de ferias
Private lVerRUO     := cPaisLoc == "BRA" .And. ChkFile("RUO")
Private aAllSRK		:= {}			// Array com todos os valores futuros abertos do funcionario
Private aAllSR8		:= {}			// Array com todos os afastamentos e ferias - Tabela SR8
Private aFerPag		:= {}
Private cCriterio	:= ""			// Criterio de acumulacao da verba
Private cSequencia	:= ""			// Sequencia de acumulacao da verba
Private cQueryFalt 	:= ""
Private nContFer	:= 0
Private nVacPag     := 0
Private dDtaLimite	:= dDtaParam

DEFAULT lVerMetrics := cPaisLoc == "BRA" .And. FwLibVersion() >= "20200727" .And. FindClass( "FWCustomMetrics" ) .And. FindFunction( cFunExec ) .And. &cFunExec.() >= "19.3.0.6"

cQueryFalt := " SELECT RC_HORAS, RC_TIPO1, RC_PD, RC_DATA FROM " + RetSqlName("SRC")
cQueryFalt += 	" WHERE RC_FILIAL = ? AND"
cQueryFalt +=		  " RC_MAT = ? AND"
cQueryFalt +=		  " RC_PD IN (?) AND"
If lSegFaltas
	cQueryFalt += " ( RC_DTREF >= ? AND RC_DTREF <= ? ) AND"
EndIf
cQueryFalt +=		  " D_E_L_E_T_ = '' "

cQueryFalt := ChangeQuery(cQueryFalt)

If Empty(cFilSRA) .or. cFilSRA <> SRA->RA_FILIAL

	cCodVerba 	:= aCodFol[68,1]	// 068: Desc. Contr. Sindical

	If cPaisLoc == "BRA" .And. (Len(aCodFol) < 1449 .Or. (Len(aCodFol) >= 1449 .And. Empty(aCodFol[1449,1])))
		aAdd( aLogId[1], STR0105 + cFilSRA)//"Filial: "
		aAdd( aLogId[1], "1449 - Abonos Pagos Mes Anterior")
		aAdd( aLogId[1], "Para prosseguir com o fechamento da Folha é necessário incluir a verba com o ID 1449, que tem como objetivo")
		aAdd( aLogId[1], "somar os valores referentes a Abono de Férias pagos em férias que devem ser deduzido no mês posterior")
		lIdAboOk := .F.
	EndIf

	If 	cPaisLoc == "BRA" .And.;
		( ( PosSrv(aCodFol[206,1],SRA->RA_FILIAL,"RV_IR") == "S" ) .Or. PosSrv(aCodFol[208,1],SRA->RA_FILIAL,"RV_IR") == "S" ) .And.;
	    ( Len(aCodFol) < 1890 .Or.;
		( Len(aCodFol) >= 1890 .And.;
		( Empty(aCodFol[1890,1]) .Or.;
		PosSrv(aCodFol[1890,1],SRA->RA_FILIAL,"RV_IR") == "N" ) ) )

		If !Empty(cFilSRA)
			aAdd( aLogId[1], STR0105 + cFilSRA)//"Filial: "
		EndIf
		aAdd( aLogId[1], "1890 - 1/3 Abono Pago Mes Anterior")
		aAdd( aLogId[1], "Para prosseguir com o fechamento da Folha é necessário incluir a verba com o ID 1890 com IR = Sim, que tem como objetivo")
		aAdd( aLogId[1], "somar os valores referentes a 1/3 Abono de Férias pagos em férias que devem ser deduzido no mês posterior")
		lIdAboOk := .F.
	EndIf

	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Pegar as Verbas que possuem transferencia para o mes Seguinte    ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	aPdTrans  := {}
	lVerbasOk := fCargaTrans(@aPdTrans, Nil, SRA->RA_FILIAL, aLogVerbas)
	If !lVerbasOk .Or. !lIdAboOk
		Return .F.
	EndIf
EndIf

If SRA->RA_CATFUNC $ "E*G"   // Estagiario Mensalista/Horista
	cCodFer	:= aCodFol[891,1]
Else
	cCodFer	:= aCodFol[72,1]
EndIf
//Carrega dados do periodo do funcionario
If cPaisloc $ "PER" .Or. cTnoAux == "!!!!!" .or. cTnoAux <> SRA->RA_TNOTRAB  .or. cFilSRA <> SRA->RA_FILIAL
	cTnoAux := SRA->RA_TNOTRAB
	If !lPerMod2
		If fCarPeriodo( cPeriodo , cRoteiro , @aPeriodo, @lUltSemana, @nPosSem,,cFilRCH)
			dDataDe 	:= aPeriodo[nPosSem,3]
			dDataAte 	:= aPeriodo[nPosSem,4]
			NSVNORMAL 	:= NORMAL 	:= aPeriodo[nPosSem,14]
			NSVDESCAN 	:= DESCANSO	:= aPeriodo[nPosSem,13]
			cAnoMes  	:= aPeriodo[nPosSem,15] + aPeriodo[nPosSem,16]
			dData_Pgto 	:= aPeriodo[nPosSem,17]
			nDiasC 		:= aPeriodo[nPosSem,20]
			dDataRef 	:= CtoD("01/" + aPeriodo[nPosSem,16] + "/" + aPeriodo[nPosSem,15])
		Else
			aAdd( aLogPer[1], SRA->RA_TNOTRAB )
			Return .F.			
		EndIf
	Else
		fGetPerAtual(@aPeriodo,xFilial("RCH"),SRA->RA_PROCES,cRoteiro,.T.)
		nPosSem := 1
		dDataDe 	:= aPeriodo[nPosSem,6]
    	dDataAte 	:= aPeriodo[nPosSem,7]
    	NSVNORMAL 	:= NORMAL 	:= 0
    	NSVDESCAN 	:= DESCANSO	:= 0
    	cAnoMes  	:= aPeriodo[nPosSem,5] + aPeriodo[nPosSem,4]
    	dData_Pgto 	:= aPeriodo[nPosSem,9]
   		nDiasC 		:= RCH->RCH_DIAPER
    	dDataRef 	:= CtoD("01/" + aPeriodo[nPosSem,4] + "/" + aPeriodo[nPosSem,5])
	EndIf
EndIf

//Recarrega a tabela apenas se houver mudança de sindicato/filial
If cPaisLoc == "BRA" .and. ( cFilSRA <> SRA->RA_FILIAL .or. cSindSRA <> SRA->RA_SINDICA )
	fTab_Fer(@aTabFer,,@aTabFer2)
EndIf

cFilSRA 	:= SRA->RA_FILIAL
cSindSRA    := SRA->RA_SINDICA

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Posiciona cFilAnt na filial corrente p/ garantir Integridade ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
cFilAnt  := SRA->RA_FILIAL
cSitFunc := SRA->RA_SITFOLH			// variavel utilizada para ponto de entrada
aAllSRK	 := {}						// a cada funcionario e realizado a carga deste array

DbSelectArea("SRC")
SRC->( DbSetOrder( 6 ) )	// RC_FILIAL + RC_MAT + RC_PROCES + RC_ROTEIR + RC_PERIODO + RC_SEMANA
SRV->( DbSetOrder(1) )

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//| Carrega tabela para apuracao dos dias de ferias - aTabFer    |
//| 1-Meses Periodo    2-Nro Periodos   3-Dias do Mes    4-Fator |
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If cPaisLoc == "VEN"
	//# Tratamento pra Venezuela - Busca Tabela S006
	fRetTab(@aTabFer,"S006",4,,fCalcFimAq(Iif(dDataRef==Nil,dDataBase,dDataRef)),SRA->RA_SINDICA)
	nDiasDir := aTabFer[6]

	If Len(aTabFer) > 0
		nTotDiaPer := aTabFer[6]
	Else
		nTotDiaPer := 0
	EndIf

ElseIf cPaisLoc == "EQU"

	nTotDiaPer := 0
	nTotAdiPer := 0
	FatorFerEqu(dDtaIni, dDtaFim, , , @nTotDiaPer, @nTotAdiPer)

ElseIf cPaisLoc == "PER"
	//# Tratamento pro Peru - Busca Tabela S017
	fRetTab(@aTabFer,"S017",,,fCalcFimAq(Iif(Type("dDataRef") == "U" .Or. dDataRef==Nil,dDataBase,dDataRef)),)

	If Len(aTabFer) > 0
		If SRA->RA_MEIOPER == "1" //# Part Time
			nTotDiaPer := aTabFer[6]
		Else
			nTotDiaPer := aTabFer[5]
		EndIf
	Else
		nTotDiaPer := 0
	EndIf

ElseIf cPaisLoc <> "COL"
	If cPaisLoc <> "BRA"
		fTab_Fer(@aTabFer,,@aTabFer2)
	EndIf
	If cPaisLoc == "BRA"
		//Se as horas semanais forem inferiores a 26, e o Mnemonico P_REGPARCI estiver ativo,
		//utiliza os dias de férias da tabela S065 - Tabela de férias tempo parcial (Artigo 130A da CLT)
		nTempoParc := SRA->RA_HRSEMAN
		If ( ( SRA->RA_HOPARC == "1" .And. nTempoParc <= 25 ) .And. nTempoParc  > 0 .And. Len(aTabFer2) > 0	.And. P_REGPARCI )
			nPosTbFer := Ascan(aTabFer2, { |X|  nTempoParc <= X[6] .And. nTempoParc > X[5] })
			If nPosTbFer > 0
				aTabFer := aClone(aTabFer2[nPosTbFer])
			Endif
		Endif
	EndIf
	If Len(aTabFer) > 0
		nTotDiaPer := aTabFer[3]
	Else
		nTotDiaPer := 0
	EndIf

	If lGestPubl .AND. SRA->RA_REGIME == "2"
		fDdPerAqui(SRA->RA_FILIAL,SRA->RA_MAT,SRA->RA_CATFUNC,SRA->RA_REGIME,dDtaIni,dDtaFim,aTabS106,SRA->RA_SINDICA)
	Endif
EndIf
//lIMPIAR PRÉSTAMOSY CONCEPTOS FIJOS PARA CHILE
If cPaisLoc == "CHI"
	UPDSRKCHI(cFilSRA,aNextPer, aNextComp )
	UPDRG1CHI((cAliasSRA)->RA_MAT)
EndIf

aSalInc 	:= {} 	// Verbas que Inc. Sal. Arq. Alt. Salariais
aValFutSRK	:= {}
aValSR8		:= {}
aAllSR8		:= {}
aValMSegRGB	:= {}
aPerSeguinte:= {}

If cPaisLoc == "EQU"
	cCodAdi	 	:= aCodFol[1004,1]
	nDFerAdi	:= 0
	cCodGoz	 	:= aCodFol[1207,1]
	nDFerGoz	:= 0
EndIf

//Código de Cocncepto con Identificador de cálculo de días pagados (1088)
If cPaisLoc != "BRA" .And. MV_MODFOL == "2" 
	cCodDPag 	:= aCodFol[1088,1]
EndIf

If cPaisLoc == "COL"
	cCodCesa    := aCodFol[889,1]
EndIf
If cPaisLoc == "ARG"
	cCodConVac := aCodFol[72,1]
EndIf
nDFerFol	:= 0
nCont 		:= 0

// Carregar no Array as verbas de Incidencias para o Periodo Seguinte
If cPaisLoc $ "BRA | PAR"
	fGetInciden(@aValMSegRGB)
EndIf

(cAliasSRC)->( dbSetOrder(6) )//RC_FILIAL+RC_MAT+RC_PROCES+RC_ROTEIR+RC_PERIODO+RC_SEMANA+RC_PD

Begin Sequence

	If (cAliasSRC)->( dbSeek( SRA->RA_FILIAL+SRA->RA_MAT+cProcesso+cRoteiro+cPeriodo+cNumPag ) )

		While (cAliasSRC)->( !Eof() ) .And. (cAliasSRC)->RC_FILIAL+(cAliasSRC)->RC_MAT+(cAliasSRC)->RC_PROCES+(cAliasSRC)->RC_ROTEIR+(cAliasSRC)->RC_PERIODO+(cAliasSRC)->RC_SEMANA == SRA->RA_FILIAL+SRA->RA_MAT+cProcesso+cRoteiro+cPeriodo+cNumPag
			cTemMov := "S"
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Totaliza qtde de funcionarios que tiveram movimento          ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If nCont = 0
				nCont ++
				nTotFunc ++
			EndIf


			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Verifica se foram calculadas ferias no mes  				   ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			If (cAliasSRC)->RC_PD == cCodFer
				nDFerFol += (cAliasSRC)->RC_HORAS
				If cPaisLoc == "BRA"
					dDtIniFer := GetSRHIni((cAliasSRC)->RC_DTREF,(cAliasSRC)->RC_HORAS)
					If !Empty(dDtIniFer)
						If Len(aFerPag) == 0 .Or. (nPos := Ascan(aFerPag,{|x| x[1] == dDtIniFer})) == 0
							aadd(aFerPag,{dDtIniFer,(cAliasSRC)->RC_HORAS})
						Else
							aFerPag[nPos][2] += (cAliasSRC)->RC_HORAS
						EndIf
					EndIf
				EndIf
			EndIf
			If cPaisLoc == "EQU" .and. (cAliasSRC)->RC_PD == cCodAdi
				nDFerAdi += (cAliasSRC)->RC_HORAS
			EndIf
			//Días pagados
			If cPaisLoc != "BRA" .And. MV_MODFOL == "2" .And. !Empty(cCodDPag) .And. (cAliasSRC)->RC_PD == cCodDPag
				nVacPag += (cAliasSRC)->RC_HORAS
			EndIf
			If cPaisLoc == "EQU" .and. (cAliasSRC)->RC_PD == cCodGoz
				nDFerGoz += (cAliasSRC)->RC_HORAS
			EndIf
			If cPaisLoc == "ARG" .And. (cAliasSRC)->RC_PD == cCodConVac
				nVacPer += (cAliasSRC)->RC_HORAS
			EndIf
			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Verifica se foi Gerada Verba de Adiant. de Cesantias  	   ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			If cPaisLoc == "COL"
				If (cAliasSRC)->RC_PD $ cCodCesa
					fAtuRg1((cAliasSRC)->RC_FILIAL,(cAliasSRC)->RC_NUMID)
				EndIf
			ElseIf cPaisLoc == "CHI"
					fAtuRg1((cAliasSRC)->RC_FILIAL,(cAliasSRC)->RC_NUMID,(cAliasSRC)->RC_VNAOAPL)
			ElseIf cPaisLoc == "PAR"
					fAtuRg1((cAliasSRC)->RC_FILIAL,(cAliasSRC)->RC_NUMID, (cAliasSRC)->RC_VNAOAPL)
					If  SRQ->(ColumnPos('RQ_VNAOAPL')) > 0 
						fBeneficia((cAliasSRC)->RC_FILIAL,(cAliasSRC)->RC_MAT,(cAliasSRC)->RC_VNAOAPL,(cAliasSRC)->RC_PROCES,(cAliasSRC)->RC_ROTEIR,(cAliasSRC)->RC_PD )
					Endif
			EndIf

			If (cAliasSRC)->RC_PD == cCodVerba
				lPgSind := .T.
			EndIf

			SRV->( DbSeek( xFilial("SRV", SRA->RA_FILIAL)+(cAliasSRC)->RC_PD ) )
			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Adiciona na Matriz de Salario Incorporado para Gravar SR3        ³
			³ Grava as verbas que compoem o salario para atualizacao do histo- ³
			³ rico de salarios. Exemplo. Ad. Tempo de Servico          	       ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			If !(cPaisLoc $ "ARG")
				If SRV->RV_INCORP == "S" 
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Verifica e Atualiza aSalInc                                  ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					Gp120GetSalInc( @aSalInc )
				EndIf
			EndIf

			If SRV->RV_TIPOCOD == "1"
				nTotProvLiq += (cAliasSRC)->RC_VALOR
                nValProv    += (cAliasSRC)->RC_VALOR
			ElseIf SRV->RV_TIPOCOD == "2"
				nTotDescLiq += (cAliasSRC)->RC_VALOR
			ElseIf SRV->RV_TIPOCOD == "3"				// Total Base provento
				nTotBsProv 	+= (cAliasSRC)->RC_VALOR
			ElseIf SRV->RV_TIPOCOD == "4"				// Base Desconto
				nTotBsDesc	+= (cAliasSRC)->RC_VALOR
			EndIf

            If SRV->RV_CODFOL == "0047"//Liquido a Receber
                nValLiq     += (cAliasSRC)->RC_VALOR
            EndIf

			nTotEmp += (cAliasSRC)->RC_VALOR

			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Totalizador dos campos de controle                           ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			nTotRegs++ 									// Total de Registros processados

			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Se a verba for de Ausencia Gera Registro no SR8			   ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			If ( cPaisLoc $ "MEX|COS" )
				If ( AllTrim((cAliasSRC)->(RC_NUMID)) == "SR8I" )
					If ( ( nPosRCM := aScan( aRCMData, { |x| x[nPosRCMPd] == (cAliasSRC)->(RC_PD) .and. x[nPosRCMFil] == xFilial("SRV") } ) ) > 0 )
						oPeriodo:cProcesso := SRA->(RA_PROCES)
						oPeriodo:GetPer()
						fRecAusSR8( aRCMData, aRCMFields, nPosRCM )
					Else

						If Empty(aLogErros[7])
							aFieldLog := { "R8_FILIAL", "R8_MAT", "R8_DATAINI", "R8_PD" }
							aAdd( aLogErros[7], Gp120CabLog( "SR8", aFieldLog, @aTamSR8 ) ) 					// Cabecalho do Log de Erros
							aAdd( aLogErros[7], "" )
						EndIf

						aAdd( aLogErros[7],	SRA->RA_FILIAL + Space( aTamSR8[1] )+;
											SRA->RA_MAT + Space( aTamSR8[2] ) +;
											DtoC(dDtaIni) + Space( aTamSR8[3] )	+;
											(cAliasSRC)->RC_PD	+ Space( aTamSR8[4] ) )
					EndIf
				EndIf
			EndIf


			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Traz o criterio de acumulacao da verba                       ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			cCriterio	:= ""						// Criterio de acumulacao da verba
			cSequencia	:= ""						// Sequencia de acumulacao da verba
			lGeraAcumulador := .F.
			If !lModPadrao .Or. (cPaisLoc $ cPaisFol1)
				If !Empty( cCritAux) .and.  ;
				(fBuscaCrit(@cCriterio , @cSequencia, cAliasSRC, (cAliasSRC)->RC_PROCES, (cAliasSRC)->RC_ROTEIR, (cAliasSRC)->RC_PD, cCritAux, cSeqAux) )

					lGeraAcumulador := .T.

				EndIf
			EndIf

			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Grava as informacoes no arquivo de acumulados SRD              ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			fGravaAcum( cMesProc, cAnoProc, aSRCFields, cCriterio , cSequencia )

			If !lModPadrao .Or. (cPaisLoc $ cPaisFol1)	//#

				/*
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Traz o criterio de acumulacao da verba                       ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
				If lGeraAcumulador
					/*
					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					³ Grava campos de Acumuladores                                   ³
					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
					If cPaisLoc=="CHI"
						fGrvAcumulador( cCriterio , cSequencia ,,,,, cMesProc, cAnoProc )
					Else
						fGrvAcumulador( cCriterio , cSequencia ,,,,, (cAliasRCH)->RCH_MES, (cAliasRCH)->RCH_ANO )
					EndIf
				EndIf

			EndIf

			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³ Processar a transferencia para o Periodo Seguinte            ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			If cPaisLoc <> "CHI"
				If SRA->RA_TPCONTR <> '3'
					fProcTrans( aPdTrans, @aPerSeguinte, aSRCFields, aNextPer, aNextComp, cMesProc, cAnoProc, cMv_CatNPgt, @aValMSegRGB )
				EndIf
			Else
				If !(Substr((cAliasSRC)->RC_NUMID,0,3) $ "SRK|RG1")
					fProcTrans( aPdTrans, @aPerSeguinte, aSRCFields, aNextPer, aNextComp, cMesProc, cAnoProc, cMv_CatNPgt, @aValMSegRGB )
				EndIF
			EndIf

			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³Atualiza parcelas dos Valores Futuros                         ³
			³1-Verba, 2-NumID, 3-Data, 4-Valor, 5-Qtde Parcelas            ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			GetValFuturo( cFilSRA, @aValFutSRK, aNextPer, aNextComp )

			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³Tratamento para afastamentos (Nao tratara Ferias)			   ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			GetSR8( cFilSRA, @aValSR8)

			/*
			ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			³Atualiza o Controle de Periodos (SRF) - Utilidades            ³
			ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
			If cPaisLoc == "VEN"
				//# Verbas: Utilidade / Utilidade na Rescisao / Antecipacao de utilidade
				cVrbUti := aCodFol[881,1]+"/"+aCodFol[882,1]+"/"+aCodFol[879,1]

				If (cAliasSRC)->RC_PD $ cVrbUti
					GrvSRFVen( cFilSRA )
				EndIf

				If (cAliasSRC)->RC_PD $ cCodFer
					GrvFerSRF(cFilSRA)
				EndIf
			EndIf

			If cPaisLoc $ "ANG|PTG" .AND. ( (cAliasSRC)->RC_PD == aCodFol[786,1] .OR. (cAliasSRC)->RC_PD == cCodFer )
				GrvSR8Ang() //Atualiza os dias pagos das Ausencias
				If cPaisLoc $ "PTG"
					GrvSRFAng() //Atualiza dos dias antecipados de ferias.
				EndIf
			EndIf

			If cPaisLoc $ "ARG|DOM" .AND. ((cAliasSRC)->RC_PD == aCodFol[786,1] .OR. (cAliasSRC)->RC_PD == cCodFer ) 
				GrvSR8Dom() //Atualiza os dias pagos das Ausencias
				GrvSRFDom() //Atualiza dos dias antecipados de ferias.
			EndIf

			If cPaisLoc $ "PER" .And. SRF->(ColumnPos("RF_FERPAGA")) > 0 .AND. cTpRoteir == "1" .AND. ((cAliasSRC)->RC_PD == cCodFer .OR. (cAliasSRC)->RC_PD == aCodFol[74,1])
				If (cAliasSRC)->RC_PD == cCodFer
					GrvSR8Per() //Actualiza los días pagados en Ausencias
				EndIf
	 			GravSRFPer((cAliasSRC)->RC_HORAS) //Actualiza los dias pagados de Vacaciones (Disfrutadas o Compradas).
			EndIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Se existe a verba referente a geracao de valores futuros (usado na Argentina³
			//³para gerar bases de calculo de IR para os proximos meses, quando existe     ³
			//³alguma remuneracao nao habitual que eh maior que o 20 % da base de calculo  ³
			//³de IR), deve gerar verbas futuras, para somar na base de calculo de IR dos  ³
			//³proximos meses.                                                             ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If cPaisLoc == "ARG" .And.  (cAliasSRC)->RC_PD == aCodFol[326,1] .And. Month((cAliasSRC)->RC_DATA) < 12
				If !lItemClvl
					aDadosIR	:=	{SRA->RA_FILIAL,SRA->RA_MAT,(cAliasSRC)->RC_DATA,(cAliasSRC)->RC_CC,(cAliasSRC)->RC_VALOR}
				Else
					aDadosIR	:=	{SRA->RA_FILIAL,SRA->RA_MAT,(cAliasSRC)->RC_DATA,(cAliasSRC)->RC_CC,(cAliasSRC)->RC_VALOR,(cAliasSRC)->RC_ITEM,(cAliasSRC)->RC_CLVL}
				EndIf
			EndIf

			DbSelectArea(cAliasSRC)
			DbSkip()
		EndDo
	Else 
		SRD->(DbSetOrder(5)) //RD_FILIAL+RD_MAT+RD_PROCES+RD_ROTEIR+RD_PERIODO+RD_SEMANA+RD_PD

		If SRD->( dbSeek( SRA->RA_FILIAL+SRA->RA_MAT+cProcesso+cRoteiro+cPeriodo+cNumPag ) )  //Se existe registro na SRD, indica que o fechamento do funcionário já foi processado
			Break
		EndIf
	EndIf

	//Fechamento de verbas com roteiro FIN
	If cPaisLoc == "BOL"
		cRoteiro := "FIN"
		If (cAliasSRC)->( dbSeek( SRA->RA_FILIAL+SRA->RA_MAT+cProcesso+cRoteiro+cPeriodo+cNumPag ) )
			While (cAliasSRC)->( !Eof() ) .And. (cAliasSRC)->RC_FILIAL+(cAliasSRC)->RC_MAT+(cAliasSRC)->RC_PROCES+(cAliasSRC)->RC_ROTEIR+(cAliasSRC)->RC_PERIODO+(cAliasSRC)->RC_SEMANA == SRA->RA_FILIAL+SRA->RA_MAT+cProcesso+cRoteiro+cPeriodo+cNumPag
				cTemMov := "S"
				/*
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Verifica se foram calculadas ferias no mes  				   ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
				If (cAliasSRC)->RC_PD == cCodFer
					nDFerFol += (cAliasSRC)->RC_HORAS
				EndIf

				If (cAliasSRC)->RC_PD == cCodVerba
					lPgSind := .T.
				EndIf

				SRV->( DbSeek( xFilial("SRV", SRA->RA_FILIAL)+(cAliasSRC)->RC_PD ) )
				/*
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Adiciona na Matriz de Salario Incorporado para Gravar SR3        ³
				³ Grava as verbas que compoem o salario para atualizacao do histo- ³
				³ rico de salarios. Exemplo. Ad. Tempo de Servico          	       ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
				If SRV->RV_INCORP == "S" 
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Verifica e Atualiza aSalInc                                  ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					Gp120GetSalInc( @aSalInc )
				EndIf

				If SRV->RV_TIPOCOD == "1"
					nTotProvLiq += (cAliasSRC)->RC_VALOR
				ElseIf SRV->RV_TIPOCOD == "2"
					nTotDescLiq += (cAliasSRC)->RC_VALOR
				ElseIf SRV->RV_TIPOCOD == "3"				// Total Base provento
					nTotBsProv 	+= (cAliasSRC)->RC_VALOR
				ElseIf SRV->RV_TIPOCOD == "4"				// Base Desconto
					nTotBsDesc	+= (cAliasSRC)->RC_VALOR
				EndIf

				nTotEmp += (cAliasSRC)->RC_VALOR

				/*
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Totalizador dos campos de controle                           ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
				nTotRegs++ 									// Total de Registros processados

				/*
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Grava as informacoes no arquivo de acumulados SRD              ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
				fGravaAcum( cMesProc, cAnoProc, aSRCFields, cCriterio , cSequencia )

				/*
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³ Processar a transferencia para o Periodo Seguinte            ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
				If SRA->RA_TPCONTR <> '3'
					fProcTrans( aPdTrans, @aPerSeguinte, aSRCFields, aNextPer, aNextComp, cMesProc, cAnoProc, cMv_CatNPgt, @aValMSegRGB )
				EndIf

				/*
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³Atualiza parcelas dos Valores Futuros                         ³
				³1-Verba, 2-NumID, 3-Data, 4-Valor, 5-Qtde Parcelas            ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
				GetValFuturo( cFilSRA, @aValFutSRK, aNextPer, aNextComp )

				/*
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³Tratamento para afastamentos (Nao tratara Ferias)			   ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
				GetSR8( cFilSRA, @aValSR8)

				DbSelectArea(cAliasSRC)
				DbSkip()
			EndDo
		EndIf
		cRoteiro := cRotBkp
	EndIf

	// Verifico afastamentos que nao foram pagos no roteiro
	If cPaisLoc == "BRA"
		nPosDataIni 	:= aScan( aSR8Fields,{ |x| x[1] ==  "R8_DATAINI" } )
		nPosDtRet		:= aScan( aSR8Fields,{ |x| x[1] ==  "R8_DATAFIM" } )
		nPosSdPagar		:= aScan( aSR8Fields,{ |x| x[1] ==  "R8_SDPAGAR" } )
		nPosDPagos		:= aScan( aSR8Fields,{ |x| x[1] ==  "R8_DPAGOS" } )
		nPosStatus  	:= aScan( aSR8Fields,{ |x| x[1] ==  "R8_STATUS" } )
		nPosValor		:= aScan( aSR8Fields,{ |x| x[1] ==  "R8_VALOR" } )
		nPosDPagar		:= aScan( aSR8Fields,{ |x| x[1] ==  "R8_DPAGAR" } )
		nPosNumID		:= aScan( aSR8Fields,{ |x| x[1] ==  "R8_NUMID" } )
		nPosContAfa		:= aScan( aSR8Fields,{ |x| x[1] ==  "R8_CONTAFA" } )
		nPosSeq			:= aScan( aSR8Fields,{ |x| x[1] ==  "R8_SEQ" } )
		nPosDiasEmp		:= aScan( aSR8Fields,{ |x| x[1] ==  "R8_DIASEMP" } )
		nFields 		:= Len( aSR8Fields )
		nPosDPgMes 		:= Len( aSR8Fields )+3

		For nX := 1 to Len(aAllSR8)
			If aAllSR8[ nX, nFields+1 ] <> "4"	.And. aAllSR8[nX, nPosStatus] <> "C"  // Sem ser Ferias	e ter sido calculado
				If aAllSR8[nX, nPosSdPagar] > 0 .And. !Empty(aAllSR8[nX, nPosDtRet]) .And. aAllSR8[nX, nPosDtRet] <= dDataAte
					If nPosContAfa > 0 .And. nPosSeq > 0 .And. nPosDPgMes > 0 .And. nPosDiasEmp > 0 .And. !Empty(aAllSR8[nX, nPosContAfa]) .And. aAllSR8[nX, nPosDiasEmp] == 999 .And. (nPosAux := aScan( aAllSR8, { |x| x[nPosSeq] == aAllSR8[nX, nPosContAfa]  } ) ) > 0
						aAllSR8[nX, nPosDPagos]  += aAllSR8[nX, nPosSdPagar] - aAllSR8[nPosAux, nPosDPgMes]
						aAllSR8[nX, nPosSdPagar] -= aAllSR8[nX, nPosSdPagar] - aAllSR8[nPosAux, nPosDPgMes]
					Else
						aAllSR8[nX, nPosDPagos]  += aAllSR8[nX, nPosSdPagar]
						aAllSR8[nX, nPosSdPagar] -= aAllSR8[nX, nPosSdPagar]
					EndIf
					aAllSR8[nX, nPosStatus]  := "C"
				Else
					If !Empty(aAllSR8[nX, nPosDtRet]) .and. aAllSR8[nX, nPosDtRet] <= dDataAte
						nValor := aAllSR8[nX, nPosDtRet] - dDataDe + 1
					ElseIf aAllSR8[nX][nPosDataIni] <= dDataAte
						nValor := dDataAte - aAllSR8[nX][nPosDataIni] + 1
					EndIf
					aAllSR8[nX, nPosSdPagar] := Max(0,If(!Empty(aAllSR8[nX, nPosSdPagar]),aAllSR8[nX, nPosSdPagar],aAllSR8[nX, nPosDPagar])-nValor)
					aAllSR8[nX, nPosDPagos]  += Min(nValor, aAllSR8[nX, nPosDPagar])
					aAllSR8[nX, nPosStatus]  := "C"
				EndIf
				If aScan(aValSR8,{|x| x[1] = aAllSR8[nX][nPosNumID]}) == 0
					aAdd( aValSR8, { aAllSR8[nX][nPosNumID] , nX } )
				EndIf
			EndIf
		Next
	EndIf

	If Len(aDadosIR) > 0
		If !lItemClvl
			LocIRSRK(aDadosIR[1,1],aDadosIR[1,2],aDadosIR[1,3],aDadosIR[1,4],aDadosIR[1,5])
		Else
			LocIRSRK(aDadosIR[1,1],aDadosIR[1,2],aDadosIR[1,3],aDadosIR[1,4],aDadosIR[1,5],,aDadosIR[1,6],aDadosIR[1,7])
		EndIf
	EndIf

	aDadosIR	:=	{}

	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Tratamento para Lancamento de Incidencias com Parcela > 1     ³
	³Gerar no array de Transf Mes seguintes verbas sem movim em SRC³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	If SRA->RA_SITFOLH # "D"
		nItens := Len(aValMSegRGB)
		If nItens > 0
			nPosRev := Len(aValMSegRGB[1])
			nPosPDRGB := aScan( aRGBFields, { |x| x[1] == "RGB_PD" } )
			nPosFilialRGB := aScan( aRGBFields, { |x| x[1] == "RGB_FILIAL" } )
			For nO := 1 To nItens
				If aValMSegRGB[nO, nPosRev] == "1"

					/*
					ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					³ Seleciona a qual periodo sera enviado a verba - 1=Competencia           ³
					ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
					If PosSrv( aValMSegRGB[nO,nPosPDRGB], aValMSegRGB[nO,nPosFilialRGB], "RV_FECCOMP") == "1"
						cNextPer 	:= aNextComp[1, 02]
						cNextPgto 	:= aNextComp[1, 03]
						cNextProc   := aNextComp[1, 04]
						cNextRot    := aNextComp[1, 05]
						cNextDtRef	:= aNextComp[1, 10] // Data de Referencia para as verbas sem lancamentos diarios
					Else
						cNextPer 	:= aNextPer[1, 02]
						cNextPgto 	:= aNextPer[1, 03]
						cNextProc   := aNextPer[1, 04]
						cNextRot    := aNextPer[1, 05]
						cNextDtRef	:= aNextPer[1, 10]
					EndIf

					aAdd( aPerSeguinte, Array(nPosRev-1) )
					nAltReg := Len(aPerSeguinte)
					For nP := 1 To Len(aRGBFields)
						cCampo := aRGBFields[nP,1]
						If cCampo == ("RGB_PERIOD")
							aPerSeguinte[nAltReg, nP] := cNextPer
						ElseIf cCampo == ("RGB_SEMANA")
							aPerSeguinte[nAltReg, nP] := cNextPgto
						ElseIf cCampo == ("RGB_PROCES")
							aPerSeguinte[nAltReg, nP] := cNextProc
						ElseIf cCampo == ("RGB_ROTEIR")
							If Empty(cNextRot)
								aPerSeguinte[nAltReg, nP] := aValMSegRGB[nO,nP]
							Else
								aPerSeguinte[nAltReg, nP] := cNextRot
							EndIf
						ElseIf ( cCampo == ("RGB_DTREF") )
							If Empty(cNextDtRef)
								aPerSeguinte[ nAltReg, nP ] := aValMSegRGB[ nO, nP ]
							Else
								aPerSeguinte[ nAltReg, nP ] := cNextDtRef
							EndIf
						Else
							aPerSeguinte[nAltReg, nP] := aValMSegRGB[nO,nP]
						EndIf
					Next nP
				EndIf
			Next nO
		EndIf
	EndIf

	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Atualiza parcelas dos Valores Futuros                         ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	If Len( aValFutSRK ) > 0
		GrvValFuturo( cFilSRA, aValFutSRK )		// Atualizar SRK
	EndIf

	//Verifica se tem eConsigando novo na RUO e cria na SRK
	If lVerRUO .And. aNextPer[1, 11]
	   fGeraEConsig(aNextPer)
	EndIF

	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Tratamento para Ferias										   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	If ( cPaisLoc $ "BRA/VEN/BOL" .And. ( SRA->RA_SITFOLH == "F" .or. fVerFerMes()))
		GetSR8( cFilSRA, @aValSR8, .T. )
	EndIf

	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Atualiza Afastamentos (SR8) e controle de Periodos (SRF)      ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	If cPaisLoc $ "MEX/HAI/COS/DOM/COL/CHI/PAR/PER"
		VerNewPerSRF( cFilSRA )
	EndIf
	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Atualiza registros en SRF para Vacaciones Progresivas solo CHI³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	If cPaisLoc $ "CHI"
		VerNewPerSRF( cFilSRA,.T. )
	EndIf

	// Actualiza y crea registros en SRF para Argentina
	If cPaisLoc == "ARG" .and. FindFunction("GrvSRFArg")
		GrvSRFArg(aCodFol[72,1],RCH->RCH_DTINI,cTpRoteir,SRA->RA_MAT,SRA->RA_ADMISSA,SRA->RA_CODCONV, RCJ->RCJ_VIGVAC, RCH->RCH_DTFIM)
	EndIf

	If (Len( aValSR8 ) > 0 .and. !( cPaisLoc $ 'ANG|PTG' ) .and. RCH->RCH_COMPL = '2') .Or. (cPaisLoc $ "MEX|PAR|PER" .And. Len( aValSR8 ) > 0)
		GravaSR8( cFilSRA, aValSR8, , ,nVacPer )
	ElseIf GetSRH() .and. !( cPaisLoc $ 'ANG|PTG' ) .and. RCH->RCH_COMPL = '2' // verifica se teve calculo apenas de abono pecuniário
		GravaSR8( cFilSRA, aValSR8, .T. )
	EndIF
	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Atualiza registros en SRF para Vacaciones Progresivas solo CHI³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	If cPaisLoc $ "CHI" .and. Len( aValSR8 ) > 0
		GravaSR8( cFilSRA, aValSR8,.T. )
	EndIF

	If cPaisLoc $ "PTG"
		GravaSRF( cFilSRA )
	EndIf

	If cPaisLoc == "ANG"
		fAtuSRFAng( cFilSRA )
	EndIf

	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Atualiza Dias de Direito (SRF) se houver afastamento no Periodo³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	If cPaisLoc == "COL"
		GrvSRFCol( cFilSRA )
	EndIf

	If cPaisLoc == 'BOL'
		fAtuSRFBol()
		If Len( aValSR8 ) > 0
			GrvSRFBOL()
		EndIf
	EndIf

	If cPaisLoc $ "EQU"
		GrvFerEqu()
	EndIf

	If cPaisLoc != "BRA" .And. MV_MODFOL == "2"
		UpdVacPag()
	EndIf

	If Len( aValSR8 ) > 0 .and. cPaisLoc == 'HAI'
		GrvSRFHAI( cFilSRA )
	EndIf
	// PREESCRIPCIÓN DE DÍAS DERECHO PAISES DE MODELO 2 (Por ahora solo para chile)
	If cPaisLoc $ "CHI" .AND. !lModPadrao
		fPrescSRF( cFilSRA )
	EndIf
	// Fin preescripción días derecho modelo 2
	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Se houve no mes corrente retorno de afastamento com perda ou  ³
	³prorrogacao do periodo de ferias, atualiza o SRF.             ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	If cPaisLoc == "BRA" .And. !( AllTrim(SRA->RA_RESCRAI) $ '30/31' ) .And. ( SRA->RA_SITFOLH # "D" .or. AnoMes(SRA->RA_DEMISSA) >= AnoMes(dDtaLimite) ) .And. !(SRA->RA_REGIME == "2")
		aPerFerias := {}

		If SRA->RA_TPCONTR <> "3" //Não atualiza SRF para funcionário com contrato intermitente.
			dDataAux := fBuscaFer()
			Calc_Fer(@aPerFerias,If(SRA->RA_SITFOLH == "D", SRA->RA_DEMISSA, dDtaLimite),,,,,,.F.,dDataAux)
		EndIf

		cTipoAfas := ""

		If Len(aPerFerias) > 0 .and. SRA->RA_SITFOLH == "A" .and. fVerFerMes()
			fChkAfas(SRA->RA_FILIAL,SRA->RA_MAT,dDataDe,,,,dDataDe,dDataAte,,,@cTipoAfas)
			SRH->( dbSetOrder(1) )
		EndIf

		SRF->( DbSetOrder( 1 ) )
		For nPer := 1 to Len(aPerFerias)
			If SRF->( DbSeek(SRA->(RA_FILIAL+RA_MAT)+DtoS(aPerFerias[nPer,1])+cCodFer) )
				nDFerApPg := 0
			
				If cTipoAfas == "U3" //Se esta aposentado por invalidez e houve calculo de férias, efetua baixa na SRF 					
					If SRH->( dbSeek( SRA->RA_FILIAL+SRA->RA_MAT+dToS(aPerFerias[nPer, 1]) ) )
						While SRH->( !Eof() ) .And. SRH->RH_FILIAL+SRH->RH_MAT+dToS(SRH->RH_DATABAS) == SRA->RA_FILIAL+SRA->RA_MAT+dToS(aPerFerias[nPer, 1])
							If AnoMes(SRH->RH_DATAINI) == cPeriodo
								nDFerApPg += SRH->RH_DFERIAS
							EndIf
							SRH->( dbSkip() )
						EndDo
					EndIf
				EndIf

				RecLock("SRF",.F.)
				If SRA->RA_SITFOLH != "D"
					If !Empty(aPerFerias[nPer,7])
						SRF->RF_DATAFIM := aPerFerias[nPer,2]
						SRF->RF_DFERVAT := aPerFerias[nPer,3]
						SRF->RF_DFERAAT := aPerFerias[nPer,4]
						SRF->RF_STATUS  := aPerFerias[nPer,8]
					ElseIf !Empty(aPerFerias[nPer,9])
						SRF->RF_DFERVAT := 0
						SRF->RF_DFERAAT := 0
						SRF->RF_STATUS  := aPerFerias[nPer,8]
					Else
						SRF->RF_DFERVAT := aPerFerias[nPer,3] //Atualiza dias vencidos
						SRF->RF_DFERAAT := aPerFerias[nPer,4] //Atualiza dias proporcionais
					EndIf
				Else
					SRF->RF_DFERVAT := aPerFerias[nPer,3]
					SRF->RF_DFERAAT := aPerFerias[nPer,4] //Atualiza dias proporcionais
					SRF->RF_DFERANT := Max(SRF->RF_DFERANT, If(aPerFerias[nPer,3] > 0, aPerFerias[nPer,3], aPerFerias[nPer,4])) //Se já tiver antecipado férias, deixa gravado a quantidade paga.
					SRF->RF_STATUS  := "3"
				EndIf

				If nDFerApPg > 0 
					SRF->RF_DFERANT += nDFerApPg 
					If SRF->RF_DFERANT >= SRF->RF_DFERVAT .And. SRF->RF_STATUS == '1'
						SRF->RF_STATUS := '3' 
					EndIf
				EndIf

				MsUnLock()
				// Se o funcionário for autônomo não gera férias.
			ElseIf SRA->RA_SITFOLH != "D" .And. !(SRA->RA_CATFUNC $ "A/P")
				If ( nPer > 1 .and. aPerFerias[nPer,8] == "1" .and. aPerFerias[nPer-1,8] == "2" .and. Empty(aPerFerias[nPer-1,9]) ) .or. (aPerFerias[nPer,3] == 0 .and. aPerFerias[nPer,4] == 0 .and. ( AnoMes(aPerFerias[nPer,1]) > cPeriodo .or. (nPer > 1 .And. aPerFerias[nPer-1,8] == "1"))) //Se período anterior esta preescrito e não houve retorno do afastamento, não cria registro ativo
					Loop
				EndIf
				RecLock("SRF",.T.)
				SRF->RF_FILIAL  := SRA->RA_FILIAL
				SRF->RF_MAT     := SRA->RA_MAT
				SRF->RF_PD      := cCodFer
				SRF->RF_DATABAS := aPerFerias[nPer,1]
				SRF->RF_DATAFIM := aPerFerias[nPer,2]
				SRF->RF_DFERVAT := aPerFerias[nPer,3]
				SRF->RF_DIASDIR := aTabFer[3]
				SRF->RF_DFERAAT := aPerFerias[nPer,4]
				SRF->RF_STATUS  := aPerFerias[nPer,8]
				SRF->RF_DVENPEN := aPerFerias[nPer,11]
				SRF->RF_IVENPEN := aPerFerias[nPer,12]
				SRF->RF_FVENPEN := aPerFerias[nPer,13]
				SRF->RF_DFERANT := aPerFerias[nPer,14]
				SRF->RF_DFALVAT := aPerFerias[nPer,15]
				SRF->RF_DFALAAT := aPerFerias[nPer,16]
				SRF->RF_DATAATU	:= dDataBase
				MsUnLock()
			EndIf
		Next nPer
		GetAfFalta(cFilSRA,aPerFerias,dDtaLimite)  //Atualiza Faltas na SRF
		If !(SRA->RA_CATFUNC $ "A*P") .And. SRA->RA_SITFOLH != "D" .And. P_FDOBVLD > 0 .And. P_FDOBPRG > 0 .And. P_FDOBMES > 0 .And. Len(aPerFerias) > 1 .And. aPerFerias[1, 8] == "1" .And. aPerFerias[1, 3] == aTabFer[3] .And. DateDiffMonth( aPerFerias[1, 2], dDtaLimite ) > P_FDOBMES
			fVldFerDob( @aLogPrgF )
		EndIf
	EndIf

	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Gravar na tabela RGB os lancamentos do proximo periodo       ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	If Len( aPerSeguinte ) > 0
		fGravaTrans( aPerSeguinte, aRGBFields)
	EndIf

	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Verifica e Muda situacao da Contribuicao Sindical no Cadastro  ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	DbSelectArea( "SRA" )
	cContrSind := SRA->RA_PGCTSIN

	If !lRefTrab //De acordo com reforma trabalhista, contribuição deixa de ser obrigatória. Funcionário deverá solicitar que o desconto seja feito formalmente.
		If SRA->RA_PGCTSIN $ "S*D*T" .And. lPgSind
			If Val( cMesProc ) >= 3
				cContrSind := "P"
			Else
				cContrSind := "S"
			EndIf
		ElseIf Val( cMesProc ) < 3 .And. SRA->RA_PGCTSIN = "P"
			cContrSind := "S"
		EndIf
	Else
		cContrSind := "N"
	EndIf

	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Manutencao de Dependentes                                    ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	fDependentes( cFilSRA, cMesProc, cAnoProc )

	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Gravacao das Verbas que Inc. Sal. Arq. Alt. Salariais        ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	If Len(aSalInc) > 0
		fGravaSalInc( aSalInc, cMesProc, cAnoproc, cFilSRA )
	EndIf

	//# Indica se atualiza o RA_SITFOLH
	If cPaisLoc <> "BRA" .And. (!(cPaisLoc $ "CHI|PAR") .Or. !(cTpRoteir == "1" .And. SRA->RA_SITFOLH == "F"))
		lAtualiza := .F.
	EndIf

	//Atualiza SRA
	RecLock("SRA",.F.)                 // Bloqueio registro SRA
	SRA->RA_PGCTSIN := cContrSind
	SRA->RA_ALTEND  := "N"
	SRA->RA_ALTCP   := "N"
	SRA->RA_ALTPIS  := "N"
	SRA->RA_ALTADM  := "N"
	SRA->RA_ALTOPC  := "N"
	SRA->RA_ALTNOME := "N"

	If !Empty(SRA->RA_AFASFGT) 
		dDtFimAfa := fRetSR8()
		If !Empty(dDtFimAfa) .And. Dtos(dDtFimAfa) >= Dtos(dDtaIni) .And. Dtos(dDtFimAfa) <= Dtos(dDtaFim)
			SRA->RA_AFASFGT := ""
		EndIf
	EndIf

	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Ponto Entrada Funcionario no Fechamento (Ex.Apagar Tarefas)  ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	If ExistBlock("GPRAM120")
		lAtualiza := EXECBLOCK("GPRAM120",.F.,.F.)
		If ValType(lAtualiza) != "L"
			lAtualiza := .T.
		EndIf
	EndIf

	DbSelectArea( "SRA" )
	RecLock("SRA",.F.)                 // Bloqueio registro SRA

	If cPaisLoc == "ARG" .And. cTpRoteir == "1"

		//Atualizacao do ultimo periodo calculado - Modelo 2
		If nCont > 0
			SRA->RA_ULTPER := cPeriodo
			SRA->RA_ULTPAG := cNumPag
		EndIf

		// Alteração da Modalidade dependendo da redução patronal.
		If !Empty(SRA->RA_MODALID)
			aMat   := fRetMat(SRA->RA_FILIAL+SRA->RA_MAT)
			aAntig := fCalAntig(aMat,,dDtFimPer,.T.)	//#fCalAntig(aMat,nMeses,dDtDemiss,lRetMes,lTruncMes)
			fRetTab(@aTabModal,"S023",,,dDataBase,,.T.)
			If Len(aTabModal) > 0
				nPosMod   := aScan( aTabModal , {|x| x[5] == SRA->RA_MODALID } )
				If nPosMod > 0
					cCodProx  := aTabModal[nPosMod][8]
					cCodReduc := aTabModal[nPosMod][7]
					If !Empty(cCodReduc) .AND. !Empty(cCodProx)
						fRetTab(@aTabReduc,"S033",,,dDataBase,,.T.)
						If Len(aTabReduc) > 0
							nPosRed   := aScan( aTabReduc , {|x| x[5] == cCodReduc } )
							If nPosRed > 0
								nAntig    := aTabReduc[nPosRed][6]
								nMesAntig := ( (12 * nAntig)-1 )
								If cCodReduc == "01"
									nMesAntig := nMesAntig + 0.1
								Else
									nMesAntig := nMesAntig + 0.2
								EndIf
								nPrazo:= Round(aAntig[1] / 30 , 2)
								If nPrazo > nMesAntig
									SRA->RA_MODALID := cCodProx
								EndIf
							EndIf
						EndIf
					EndIf
				EndIf
			EndIf
		EndIf
	EndIf
	SRA->( MsUnLock() )

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Exclui registros da tabelas SRC que ja foram gravados na SRD ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	fDeleteGpe(SRA->RA_FILIAL, SRA->RA_MAT, cProcesso, cPeriodo, cNumPag,  cRoteiro)
	If cPaisLoc == "BOL"
		fDeleteGpe(SRA->RA_FILIAL, SRA->RA_MAT, cProcesso, cPeriodo, cNumPag, "FIN")
	EndIf

	fDeleteRGB(SRA->RA_FILIAL, SRA->RA_MAT) //"Efetuando limpeza na tabela de incidências"###"Aguarde..."

	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Retorna a Situacao do Funcionario                            ³
	³ Quando nao possuir proximo periodo, a funcao devera retornar ³
	³ a data final +1 dia do final do periodo que se esta fechando ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	If Len(aNextPer) > 0
		If aNextPer[1, 11]	// Informa se pertence ao proximo periodo ou nao
			dDataIni := aNextPer[1, 09]	// Data Inicial do Proximo Periodo
			dDataRef := aNextPer[1, 10] // Data Final do Proximo Periodo
		Else
			dDataIni := aNextPer[1, 10]+1	// Data Inicial do Proximo Periodo
			dDataRef := aNextPer[1, 10]+1 // Data Final do Proximo Periodo
		EndIf
	EndIf

	If !cPaisLoc $ "MEX|DOM|COS|ARG" .Or. (((cPaisLoc $ "MEX|DOM|COS|ARG" .and. SRA->RA_SITFOLH <> "D") .And.;
		((cPaisLoc $ "DOM|ARG" .And. cTpRoteir == "A" .And. cAtualSit <> "3" )) .Or. .T. ) .And. cTpRoteir # '3')

		aAdd(aFuncAtSit, {SRA->RA_FILIAL, SRA->RA_MAT, lAtualiza, dDataRef, dDataIni, SRA->(Recno())})
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Alterar situacao do funcionario de FERIAS para NORMAL, caso  ³
	//³ possua, no mes corrente, apenas ABONO.                       ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lTemAbMes .And. SRA->RA_SITFOLH == "F" .And. nContFer == 1 .And. !lTemAbMSeg
		SRA->( RecLock("SRA",.F.) )
		SRA->RA_SITFOLH		:= " "
		SRA->( MsUnLock() )
	EndIf

	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Limpa o campo de Bloqueio de Funcionario, o qual foi atuali- ³
	³ zado na Rescisao de Contrato depois da Folha ja Calculada.   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	If cPaisLoc == "ARG" .And. !Empty(SRA->RA_BLQRES)
		SRA->( RecLock("SRA", .F.) )
		SRA->RA_BLQRES := " "
		SRA->( MsUnLock("SRA") )
	EndIf
	If cPaisLoc <> "BRA" .and. cTpRoteir == '1'
		SRA->(Reclock("SRA",.F.))
			If  SRA->(ColumnPos('RA_PERORD')) > 0 
				SRA->RA_PERORD := RCH->RCH_PER
			EndIf
			If  SRA->(ColumnPos('RA_PAGORD')) > 0 
				SRA->RA_PAGORD := RCH->RCH_NUMPAG
			EndIf
		SRA->( MsUnlock("SRA") )
	EndIf

	If lReplRat .And. (Empty(SRA->RA_DEMISSA) .Or. AnoMes(SRA->RA_DEMISSA) > cPeriodo)//Se deve replicar o rateio cadastrado no mês para o próximo período
		cDeMes := SubStr(cPeriodo,5,2) + SubStr(cPeriodo,1,4)
		//Se encontrar rateio com inicio e término no período atual, replica o rateio para o próximo período se já não existir cadastrado
		If RHQ->(DbSeek(SRA->RA_FILIAL + SRA->RA_MAT + cDeMes))
			While RHQ->(!Eof() .and. RHQ_FILIAL+RHQ_MAT+RHQ_DEMES == SRA->RA_FILIAL + SRA->RA_MAT + cDeMes)
				If RHQ->RHQ_AMES == RHQ->RHQ_DEMES
					aAdd(aRatFunc, {RHQ->RHQ_FILIAL, RHQ->RHQ_MAT, RHQ->RHQ_CC, If(lItemClvl,RHQ->RHQ_ITEM,""), If(lItemClvl,RHQ->RHQ_CLVL,""), RHQ->RHQ_PERC, RHQ->RHQ_ORIGEM})
				EndIf
				RHQ->(DbSkip())
			EndDo
			If Len(aRatFunc) > 0
				cDeMes := SubStr(aNextPer[1, 02],5,2) + SubStr(aNextPer[1, 02],1,4)
				For nCont := 1 to Len(aRatFunc)
					If !RHQ->(DbSeek(aRatFunc[nCont,1] + aRatFunc[nCont,2] + cDeMes + aRatFunc[nCont,3] + aRatFunc[nCont,4] + aRatFunc[nCont,5]))
						RecLock("RHQ",.T.)
							RHQ->RHQ_FILIAL := aRatFunc[nCont,1]
							RHQ->RHQ_MAT	:= aRatFunc[nCont,2]
							RHQ->RHQ_DEMES  := cDeMes
							RHQ->RHQ_AMES   := cDeMes
							RHQ->RHQ_CC 	:= aRatFunc[nCont,3]
							If lItemClvl
								RHQ->RHQ_ITEM 	:= aRatFunc[nCont,4]
								RHQ->RHQ_CLVL 	:= aRatFunc[nCont,5]
							EndIf
							RHQ->RHQ_PERC 	:= aRatFunc[nCont,6]
							RHQ->RHQ_ORIGEM	:= aRatFunc[nCont,7]
						MsUnLock()
					EndIf
				Next nCont
			EndIf
		EndIf
	EndIf

	//Verifica se existe programação de aumento para o próximo mês
	If cPaisLoc == "BRA" .and. Empty(SRA->RA_DEMISSA) .and. P_FECPROG
		If RB7->(DbSeek(SRA->RA_FILIAL + SRA->RA_MAT))
			While RB7->(!Eof() .and. RB7_FILIAL + RB7_MAT == SRA->RA_FILIAL + SRA->RA_MAT )
				If SRA->RA_SALARIO < RB7->RB7_SALARI .and. AnoMes(RB7->RB7_DATALT) == aNextPer[1,2]
					aAdd(aRecProg, RB7->(Recno()))
				EndIf
				RB7->(DbSkip())
			EndDo
		EndIf
	EndIf

    If cPaisLoc == "BRA" .And. lVerMetrics .And. !Empty(SRA->RA_CATEFD )
        If ( nPosMetric := aScan( aVlrMetric, { |x| x[1] == SRA->RA_CATEFD } ) ) == 0
            aAdd( aVlrMetric, { SRA->RA_CATEFD, nValLiq, nValProv } )
        Else
            aVlrMetric[nPosMetric, 2] += nValLiq
            aVlrMetric[nPosMetric, 3] += nValProv
        EndIf
    EndIf

End Sequence

Return .T.

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³Gp120FecAdi   ³ Autor ³ Leandro Drumond   ³ Data ³16.10.2013³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Fecha periodo adiantamento.			                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ GPEM120()                                                  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function Gp120FecAdi(cTemMov)

Local aPerSeguinte	:= {}
Local cCodAdtArr	:= ""
Local cCodAdt		:= ""
Local cCodIrAdt		:= ""
Local nCount		:= 0
Local lSRCVazio		:= .T.
Local lIrNeg		:= Len(aCodFol) >= 1726 .And. !Empty(aCodFol[1726,1]) .And. !Empty(aCodFol[1727,1])

Private cCriterio	:= ""						// Criterio de acumulacao da verba
Private cSequencia	:= ""						// Sequencia de acumulacao da verba

If Empty(cFilSRA) .or. cFilSRA <> SRA->RA_FILIAL
	cFilSRA 	:= SRA->RA_FILIAL
EndIf

cCodAdtArr	:= aCodFol[1329,1] //Arredondamento do Adiantamento
cCodAdt		:= aCodFol[6,1] //Provento Adiantamento
cCodIrAdt	:= aCodFol[9,1] //IR do Adiantamento

cAliasSRV := "SRV"
DbSelectArea(cAliasSRV)
DbSetOrder(1)

(cAliasSRC)->( dbSetOrder(6) )//RC_FILIAL+RC_MAT+RC_PROCES+RC_ROTEIR+RC_PERIODO+RC_SEMANA+RC_PD
If (cAliasSRC)->( dbSeek( SRA->RA_FILIAL+SRA->RA_MAT+cProcesso+cRoteiro+cPeriodo+cNumPag ) )
	While (cAliasSRC)->( !Eof() ) .And. (cAliasSRC)->RC_FILIAL+(cAliasSRC)->RC_MAT+(cAliasSRC)->RC_PROCES+(cAliasSRC)->RC_ROTEIR+(cAliasSRC)->RC_PERIODO+(cAliasSRC)->RC_SEMANA == SRA->RA_FILIAL+SRA->RA_MAT+cProcesso+cRoteiro+cPeriodo+cNumPag
		lSRCVazio := .F.
		cTemMov := "S"

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Totaliza qtde de funcionarios que tiveram movimento          ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If nCount = 0
			nCount ++
			nTotFunc ++
		EndIf

		( cAliasSRV )->( DbSeek(xFilial("SRV")+(cAliasSRC)->RC_PD ) )

		If ( cAliasSRV )->RV_TIPOCOD == "1"
			nTotProvLiq += (cAliasSRC)->RC_VALOR
		ElseIf ( cAliasSRV )->RV_TIPOCOD == "2"
			nTotDescLiq += (cAliasSRC)->RC_VALOR
		ElseIf ( cAliasSRV )->RV_TIPOCOD == "3"				// Total Base provento
			nTotBsProv 	+= (cAliasSRC)->RC_VALOR
		ElseIf ( cAliasSRV )->RV_TIPOCOD == "4"				// Base Desconto
			nTotBsDesc	+= (cAliasSRC)->RC_VALOR
		EndIf

		nTotEmp += (cAliasSRC)->RC_VALOR //Soma ao total da empresa
		nTotRegs++ 	// Total de Registros processados

		//Traz o criterio de acumulacao da verba
		cCriterio	    := "" // Criterio de acumulacao da verba
		cSequencia	    := "" // Sequencia de acumulacao da verba
		lGeraAcumulador := .F.
		If !lModPadrao .Or. (cPaisLoc $ cPaisFol1)
			If !Empty( cCritAux) .and.  ;
			(fBuscaCrit(@cCriterio , @cSequencia, cAliasSRC, (cAliasSRC)->RC_PROCES, (cAliasSRC)->RC_ROTEIR, (cAliasSRC)->RC_PD, cCritAux, cSeqAux) )
				lGeraAcumulador := .T.
			EndIf
		EndIf

		//Grava as informacoes no arquivo de acumulados SRD
		fGravaAcum( cMesProc, cAnoProc, aSRCFields, cCriterio , cSequencia )

		If !lModPadrao .Or. (cPaisLoc $ cPaisFol1)
			//Traz o criterio de acumulacao da verba
			If lGeraAcumulador
				//Grava campos de Acumuladores
				If cPaisLoc=="CHI"
					fGrvAcumulador( cCriterio , cSequencia ,,,,, cMesProc, cAnoProc )
				Else	
					fGrvAcumulador( cCriterio , cSequencia ,,,,, (cAliasRCH)->RCH_MES, (cAliasRCH)->RCH_ANO )
				EndIf
			EndIf
		EndIf

		If SRA->RA_SITFOLH != "D"
			If (cAliasSRC)->RC_PD $ cCodAdt + "|" + cCodAdtArr + "|" + cCodIrAdt
				If (cAliasSRC)->RC_PD == cCodAdt
					fCarProxRGB(@aPerSeguinte,cProcesso,aProxPerRGB[1,1],aProxPerRGB[1,8],aProxPerRGB[1,2],aCodFol[7,1], (cAliasSRC)->RC_ROTEIR, (cAliasSRC)->RC_DATA)
				EndIf

				If (cAliasSRC)->RC_PD == cCodAdtArr
					fCarProxRGB(@aPerSeguinte,cProcesso,aProxPerRGB[1,1],aProxPerRGB[1,8],aProxPerRGB[1,2],aCodFol[8,1], (cAliasSRC)->RC_ROTEIR, (cAliasSRC)->RC_DATA)
				EndIf

				If (cAliasSRC)->RC_PD == cCodIrAdt
					fCarProxRGB(@aPerSeguinte,cProcesso,aProxPerRGB[1,1],aProxPerRGB[1,8],aProxPerRGB[1,2],aCodFol[12,1], (cAliasSRC)->RC_ROTEIR, (cAliasSRC)->RC_DATA)
				EndIf
			ElseIf PosSrv((cAliasSRC)->RC_PD,SRA->RA_FILIAL,"RV_ADIANTA") = "S" .Or. !Empty(PosSrv((cAliasSRC)->RC_PD,SRA->RA_FILIAL,"RV_CODMSEG"))
				If !Empty(PosSrv((cAliasSRC)->RC_PD,SRA->RA_FILIAL,"RV_CODMSEG"))
					fCarProxRGB(@aPerSeguinte,cProcesso,aProxPerRGB[1,1],aProxPerRGB[1,8],aProxPerRGB[1,2],PosSrv((cAliasSRC)->RC_PD,SRA->RA_FILIAL,"RV_CODMSEG"), (cAliasSRC)->RC_ROTEIR, (cAliasSRC)->RC_DATA)
				EndIf
				If PosSrv((cAliasSRC)->RC_PD,SRA->RA_FILIAL,"RV_ADIANTA") = "S" .And. Empty(SRV->RV_CODCORR) .And. !((cAliasSRC)->RC_PD $ aCodFol[10,1]+'*'+aCodFol[59,1]+'*'+aCodFol[546,1])
					If cPaisLoc == "BRA" .And. (cAliasSRC)->RC_TIPO2 $ "I*G" .And. P_PROVADIF // Apenas para verbas informadas ou geradas no adiantamento
						fCarProxRGB(@aPerSeguinte,cProcesso,aProxPerRGB[1,1],aProxPerRGB[1,8],aProxPerRGB[1,2],(cAliasSRC)->RC_PD, (cAliasSRC)->RC_ROTEIR, (cAliasSRC)->RC_DATA)
					EndIf
					If PosSrv((cAliasSRC)->RC_PD,SRA->RA_FILIAL,"RV_TIPOCOD") == "1"
						fCarProxRGB(@aPerSeguinte,cProcesso,aProxPerRGB[1,1],aProxPerRGB[1,8],aProxPerRGB[1,2],aCodFol[7,1], (cAliasSRC)->RC_ROTEIR, (cAliasSRC)->RC_DATA)
					Elseif PosSrv((cAliasSRC)->RC_PD,SRA->RA_FILIAL,"RV_TIPOCOD") == "2"
						fCarProxRGB(@aPerSeguinte,cProcesso,aProxPerRGB[1,1],aProxPerRGB[1,8],aProxPerRGB[1,2],aCodFol[6,1], (cAliasSRC)->RC_ROTEIR, (cAliasSRC)->RC_DATA)
					Endif
				Endif
			ElseIf (cAliasSRC)->RC_PD $ aCodFol[0106,1] + aCodFol[0107,1] + iif(lIrNeg,  aCodFol[01727,1] ,"")
				If AnoMes( (cAliasSRC)->RC_DTREF ) == cPeriodo .And. AnoMes(aProxPerRGB[1,9]) == cPeriodo
					fCarProxRGB(@aPerSeguinte,cProcesso,aProxPerRGB[1,1],aProxPerRGB[1,8],aProxPerRGB[1,2],(cAliasSRC)->RC_PD, (cAliasSRC)->RC_ROTEIR, (cAliasSRC)->RC_DATA)
				EndIf
			EndIf
		EndIf

		(cAliasSRC)->(DbSkip())
	EndDo
EndIf

If SRA->RA_SITFOLH != "D"
	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Gravar na tabela RGB os lancamentos do proximo periodo       ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	If Len( aPerSeguinte ) > 0
		fGravaTrans( aPerSeguinte, aRGBFields)
	EndIf
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Exclui registros da tabelas SRC que ja foram gravados na SRD ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
fDeleteGpe(SRA->RA_FILIAL, SRA->RA_MAT, cProcesso, cPeriodo, cNumPag,  cRoteiro)

If lSRCVazio
	fUpdateRGB(SRA->RA_FILIAL, SRA->RA_MAT,If(SRA->RA_CATFUNC $ 'A|P',fGetCalcRot('9'),fGetCalcRot('1')))
EndIf

fDeleteRGB(SRA->RA_FILIAL, SRA->RA_MAT, @cTemMov)

Return Nil

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³Gp120FecRes   ³ Autor ³ Leandro Drumond   ³ Data ³16.10.2013³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Fecha periodo rescisao.  			                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ GPEM120()                                                  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function Gp120FecRes(cTemMov)

fDeleteRGB(SRA->RA_FILIAL, SRA->RA_MAT, @cTemMov)

If cPaisLoc == "BRA" .And. lConsig .And. lCpoFlagIC
	fAtuFlagIC(SRA->RA_FILIAL, SRA->RA_MAT)
EndIf

fVincSQG()

Return Nil

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³Gp120FecfER   ³ Autor ³ Leandro Drumond   ³ Data ³18.10.2013³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Fecha periodo ferias.	  			                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ GPEM120()                                                  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function Gp120FecFer(dDataParam, cTnoAux, cTemMov, aLogPer)
Local aValSR8	 := {}
Local cCodFer	 := aCodFol[72,1]
Local dDataAux	 := CtoD("")
Local lAfPerda	 := .F.
Local nPer		 := 0
Local nPosSem    := 0
Local cWhere     := ""
Local cFromTable := ""
Local cOrder     := ""
Local cCriterio  := "" // Criterio de acumulacao da verba
Local cSequencia := "" // Sequencia de acumulacao da verba

Private lAllSR8		:= .F.			            // SR8 do funcionário já pesquisada?
Private aAllSR8		:= {}
Private nDFerFol	:= 0
Private dDtaLimite  := dDataParam
If SRA->RA_CATFUNC $ "E*G"   // Estagiario Mensalista/Horista
	cCodFer	:= aCodFol[891,1]
EndIf

If cTnoAux == "!!!!!" .or. cTnoAux <> SRA->RA_TNOTRAB  .or. cFilSRA <> SRA->RA_FILIAL
	cTnoAux := SRA->RA_TNOTRAB
    If !lPerMod2
    	If fCarPeriodo( cPeriodo , cRoteiro , @aPeriodo, @lUltSemana, @nPosSem,,cFilRCH)
			dDataDe 	:= aPeriodo[nPosSem,3]
			dDataAte 	:= aPeriodo[nPosSem,4]
			NSVNORMAL 	:= NORMAL 	:= aPeriodo[nPosSem,14]
			NSVDESCAN 	:= DESCANSO	:= aPeriodo[nPosSem,13]
			cAnoMes  	:= aPeriodo[nPosSem,15] + aPeriodo[nPosSem,16]
			dData_Pgto 	:= aPeriodo[nPosSem,17]
			nDiasC 		:= aPeriodo[nPosSem,20]
			dDataRef 	:= CtoD("01/" + aPeriodo[nPosSem,16] + "/" + aPeriodo[nPosSem,15])
		Else
			aAdd( aLogPer[1], SRA->RA_TNOTRAB )
			Return .F.
		EndIf
	Else
		fGetPerAtual(@aPeriodo,xFilial("RCH"),GetMemVar("RA_PROCES"),cRoteiro,.T.)
		nPosSem := 1
		dDataDe 	:= aPeriodo[nPosSem,6]
    	dDataAte 	:= aPeriodo[nPosSem,7]
    	NSVNORMAL 	:= NORMAL 	:= 0
    	NSVDESCAN 	:= DESCANSO	:= 0
    	cAnoMes  	:= aPeriodo[nPosSem,5] + aPeriodo[nPosSem,4]
    	dData_Pgto 	:= aPeriodo[nPosSem,9]
   		nDiasC 		:= RCH->RCH_DIAPER
    	dDataRef 	:= CtoD("01/" + aPeriodo[nPosSem,4] + "/" + aPeriodo[nPosSem,5])
	EndIf
EndIf

cFilSRA := SRA->RA_FILIAL

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//| Carrega tabela para apuracao dos dias de ferias - aTabFer    |
//| 1-Meses Periodo    2-Nro Periodos   3-Dias do Mes    4-Fator |
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If cPaisLoc == "VEN"
	//# Tratamento pra Venezuela - Busca Tabela S006
	fRetTab(@aTabFer,"S006",4,,fCalcFimAq(Iif(dDataRef==Nil,dDataBase,dDataRef)),SRA->RA_SINDICA)
	nDiasDir := aTabFer[6]

	If Len(aTabFer) > 0
		nTotDiaPer := aTabFer[6]
	Else
		nTotDiaPer := 0
	EndIf

ElseIf cPaisLoc == "EQU"

	nTotDiaPer := 0
	nTotAdiPer := 0
	FatorFerEqu(dDtaIni, dDtaFim, , , @nTotDiaPer, @nTotAdiPer)

ElseIf cPaisLoc == "COL"
	nDiasFer := If(fTabela("S021", 1, 8) <> Nil, fTabela("S021", 1, 8), 15)
	nFator	 := nDiasFer/12
	nTotDiaPer := nDiasFer
	aTabFer	 := {}
	aAdd( aTabFer, {12, 0, nDiasFer, nFator} )
Else
	If !(lGestPubl .AND. SRA->RA_REGIME == "2")
		fTab_Fer(@aTabFer)
	EndIf

	If Len(aTabFer) > 0
		nTotDiaPer := aTabFer[3]
	Else
		nTotDiaPer := 0
	EndIf

	If lGestPubl .AND. SRA->RA_REGIME == "2"
		fDdPerAqui(SRA->RA_FILIAL,SRA->RA_MAT,SRA->RA_CATFUNC,SRA->RA_REGIME,dDtaIni,dDtaFim,aTabS106, SRA->RA_SINDICA)
	Endif
EndIf

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Tratamento para Ferias										   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
If ( cPaisLoc $ "BRA/VEN/BOL/COL" .And. SRA->RA_SITFOLH == "F" ) .OR. ;
	(cPaisLoc $ "COL|PAR" .And. SRA->RA_SITFOLH <> "D")
	GetSR8( cFilSRA, @aValSR8, .T. )
EndIf

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Atualiza Afastamentos (SR8) e controle de Periodos (SRF)      ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
If cPaisLoc $ "MEX/HAI/COS/ARG/DOM/PAR"
	VerNewPerSRF( cFilSRA )
EndIf

If cPaisLoc $ "ARG|PAR"
	cAliasSRC := "Q" + "SRC"

	If ( SELECT(cAliasSRC) > 0 )
		(cAliasSRC)->(dbCloseArea())
	EndIf

	cWhere := "%"
	cWhere += " SRC.RC_FILIAL  = '" + SRA->RA_FILIAL + "' AND "
	cWhere += " SRC.RC_MAT 	   = '" + SRA->RA_MAT + "' AND "
	cWhere += " SRC.RC_PROCES  = '" + cProcesso + "' AND "
	cWhere += " SRC.RC_PERIODO = '" + cPeriodo + "' AND "
	cWhere += " SRC.RC_ROTEIR = '" + cRoteiro + "' AND "
	cWhere += " SRC.RC_SEMANA = '" + cNumPag +"' AND "

	cWhere += "%"

	cOrder := "% SRC.RC_FILIAL, SRC.RC_MAT, SRC.RC_PROCES, SRC.RC_PERIODO, SRC.RC_SEMANA %"

	cFromTable := "% " + cNamSRCTab + " SRC %"

	BeginSql Alias cAliasSRC
		Column RC_DATA as Date, RC_DTREF as Date
		SELECT
				%exp:cFieldsSRC%
		FROM
				%exp:cFromTable%
		WHERE
				%exp:cWhere%
				SRC.%NotDel%
		ORDER BY
				%exp:cOrder%
	EndSql

	While (cAliasSRC)->( !Eof() )
		//Traz o criterio de acumulacao da verba
		cCriterio	    := "" // Criterio de acumulacao da verba
		cSequencia	    := "" // Sequencia de acumulacao da verba
		lGeraAcumulador := .F.
		If !lModPadrao
			If !Empty( cCritAux) .and.  ;
			(fBuscaCrit(@cCriterio , @cSequencia, cAliasSRC, (cAliasSRC)->RC_PROCES, (cAliasSRC)->RC_ROTEIR, (cAliasSRC)->RC_PD, cCritAux, cSeqAux) )
				lGeraAcumulador := .T.
			EndIf
		EndIf

		//Grava as informacoes no arquivo de acumulados SRD
		fGravaAcum( cMesProc, cAnoProc, aSRCFields, cCriterio , cSequencia )

		If !lModPadrao
			//Traz o criterio de acumulacao da verba
			If lGeraAcumulador
				//Grava campos de Acumuladores
				If cPaisLoc=="CHI"
					fGrvAcumulador( cCriterio , cSequencia ,,,,, cMesProc, cAnoProc )
				Else	
					fGrvAcumulador( cCriterio , cSequencia ,,,,, (cAliasRCH)->RCH_MES, (cAliasRCH)->RCH_ANO )
				EndIf
			EndIf
		EndIf

		If cPaisLoc $ "ARG|DOM" .AND. ((cAliasSRC)->RC_PD == aCodFol[786,1] .OR. (cAliasSRC)->RC_PD == cCodFer )
			GrvSR8Dom() //Atualiza os dias pagos das Ausencias
			GrvSRFDom() //Atualiza dos dias antecipados de ferias.
		EndIf	

		(cAliasSRC)->(DbSkip())
	EndDo

	(cAliasSRC)->(DbCloseArea())
EndIf

If Len( aValSR8 ) > 0 .and. !( cPaisLoc $ 'ANG|PTG|BRA|' ) .Or. (cPaisLoc $ "PAR" .And. Len( aValSR8 ) > 0) //Brasil Deve atualizar a SRF apenas no fechamento da folha.
	GravaSR8( cFilSRA, aValSR8 )
EndIf


If cPaisLoc == "PTG"
	GravaSRF( cFilSRA )
EndIf

If cPaisLoc == "ANG"
	fAtuSRFAng( cFilSRA )
EndIf

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Atualiza Dias de Direito (SRF) se houver afastamento no Periodo³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
If cPaisLoc == "COL"
	GrvSRFCol( cFilSRA )
EndIf

If cPaisLoc == 'BOL'
	fAtuSRFBol()
	If Len( aValSR8 ) > 0
		GrvSRFBOL()
	EndIf
EndIf

If cPaisLoc == "EQU"
	GrvFerEqu()
EndIf

If Len( aValSR8 ) > 0 .and. cPaisLoc == 'HAI'
	GrvSRFHAI( cFilSRA )
EndIf

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Tratamento para Ferias										   ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
If ( cPaisLoc == "BRA" ) .And. SRA->RA_SITFOLH <> "D" .AND. !(SRA->RA_REGIME == "2")

	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Se houve no mes corrente retorno de afastamento com perda ou  ³
	³prorrogacao do periodo de ferias, atualiza o SRF.             ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	aPerFerias := {}
	If !( lAfPerda := GetAfPerda(cFilSRA) ) //Se nao existir afastamento no periodo, monta aPerFerias apenas com período atual
		dDataAux := fBuscaFer() //Busca periodo atualde ferias
	EndIf
	Calc_Fer(@aPerFerias,Max(dDtaLimite,dDataAux),,,,,,.F.,dDataAux)

	SRF->( DbSetOrder( 1 ) )
	For nPer := 1 to Len(aPerFerias)
		If SRF->( DbSeek(SRA->(RA_FILIAL+RA_MAT)+DtoS(aPerFerias[nPer,1])+cCodFer) )
			RecLock("SRF",.F.)
			If !Empty(aPerFerias[nPer,7])
				SRF->RF_DATAFIM := aPerFerias[nPer,2]
			ElseIf !Empty(aPerFerias[nPer,9])
				SRF->RF_DFERVAT := 0
				SRF->RF_DFERAAT := 0
				SRF->RF_STATUS  := aPerFerias[nPer,8]
			Else
				SRF->RF_DFERVAT := aPerFerias[nPer,3]
				SRF->RF_DFERAAT	:= aPerFerias[nPer,4]
				If !Empty(aPerFerias[nPer,6]) .and. SRF->RF_STATUS <> aPerFerias[nPer,8]
					SRF->RF_STATUS   := aPerFerias[nPer,8]
					SRF->RF_OBSERVA	 := aPerFerias[nPer,6]
				EndIf
			EndIf
			MsUnLock()
		Else
			If ( nPer > 1 .and. aPerFerias[nPer,8] == "1" .and. aPerFerias[nPer-1,8] == "2" .and. Empty(aPerFerias[nPer-1,9]) ) .or.; 
				(aPerFerias[nPer,3] == 0 .and. aPerFerias[nPer,4] == 0 .and. ( AnoMes(aPerFerias[nPer,1]) > cPeriodo .or. ( nPer > 1 .and. aPerFerias[nPer-1,8] == "1" ) ) )//Se período anterior esta preescrito e não houve retorno do afastamento, não cria registro ativo
				Loop
			EndIf
			RecLock("SRF",.T.)
			SRF->RF_FILIAL  := SRA->RA_FILIAL
			SRF->RF_MAT     := SRA->RA_MAT
			SRF->RF_PD      := cCodFer
			SRF->RF_DATABAS := aPerFerias[nPer,1]
			SRF->RF_DATAFIM := aPerFerias[nPer,2]
			SRF->RF_DFERVAT := aPerFerias[nPer,3]
			SRF->RF_DIASDIR := aTabFer[3]
			SRF->RF_DFERAAT := aPerFerias[nPer,4]
			SRF->RF_STATUS  := aPerFerias[nPer,8]
			SRF->RF_DVENPEN := aPerFerias[nPer,11]
			SRF->RF_IVENPEN := aPerFerias[nPer,12]
			SRF->RF_FVENPEN := aPerFerias[nPer,13]
			SRF->RF_DFERANT := aPerFerias[nPer,14]
			SRF->RF_DFALVAT := aPerFerias[nPer,15]
			SRF->RF_DFALAAT := aPerFerias[nPer,16]
			MsUnLock()
		EndIf
	Next nPer
EndIf

If !(cPaisLoc $ "ARG|CHI")
	fAtuSRH()
EndIf

If cPaisLoc $ "ARG|PAR"
	fDeleteGpe(SRA->RA_FILIAL, SRA->RA_MAT, cProcesso, cPeriodo, cNumPag,  cRoteiro)
EndIf

fDeleteRGB(SRA->RA_FILIAL, SRA->RA_MAT, @cTemMov)

Return .T.

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³fAtuSRH       ³ Autor ³ Leandro Drumond   ³ Data ³02.12.2013³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Atualiza RH_SALDIF				.	                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ GPEM120()                                                  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function fAtuSRH()
Local cQuery 	:= ""
Local cNameFile := RetSqlName("SRH")

cQuery := "UPDATE "
cQuery += cNameFile + " "
cQuery += "SET RH_SALDIF = '" + Str(SRA->RA_SALARIO) + "',"
cQuery += " RH_SALMIND = '" + Str(Val_SalMin) + "' "
cQuery += "WHERE RH_FILIAL = '" + SRA->RA_FILIAL + "' "
cQuery += "AND RH_MAT = '" + SRA->RA_MAT + "' "
cQuery += "AND RH_PERIODO = '" + cPeriodo + "' "

TcSqlExec( cQuery )

Return Nil

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³Gp120FecGen   ³ Autor ³ Leandro Drumond   ³ Data ³16.10.2013³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Fecha periodo 13o Salario e genereicos                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ GPEM120()                                                  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function Gp120FecGen(cTemMov)

Local nCount		:= 0

Local cCriterio     := "" // Criterio de acumulacao da verba
Local cSequencia    := "" // Sequencia de acumulacao da verba

//Melhoria de performance, sai se não existir cálculo para o funcionário
SRC->(DbSetOrder(RetOrder("SRC","RC_FILIAL+RC_MAT+RC_PROCES+RC_ROTEIR+RC_PERIODO+RC_SEMANA")))

If SRC->(DbSeek(SRA->RA_FILIAL + SRA->RA_MAT + cProcesso + cRoteiro + cPeriodo + cNumPag))

	cAliasSRV := "SRV"
	DbSelectArea(cAliasSRV)
	DbSetOrder(1)

	If (cAliasSRC)->( dbSeek( SRA->RA_FILIAL+SRA->RA_MAT+cProcesso+cRoteiro+cPeriodo+cNumPag ) )
		While (cAliasSRC)->( !Eof() ) .And. (cAliasSRC)->RC_FILIAL+(cAliasSRC)->RC_MAT+(cAliasSRC)->RC_PROCES+(cAliasSRC)->RC_ROTEIR+(cAliasSRC)->RC_PERIODO+(cAliasSRC)->RC_SEMANA == SRA->RA_FILIAL+SRA->RA_MAT+cProcesso+cRoteiro+cPeriodo+cNumPag

			cTemMov := "S"

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Totaliza qtde de funcionarios que tiveram movimento          ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If nCount = 0
				nCount ++
				nTotFunc ++
			EndIf

			( cAliasSRV )->( DbSeek(xFilial("SRV")+(cAliasSRC)->RC_PD ) )

			If ( cAliasSRV )->RV_TIPOCOD == "1"
				nTotProvLiq += (cAliasSRC)->RC_VALOR
			ElseIf ( cAliasSRV )->RV_TIPOCOD == "2"
				nTotDescLiq += (cAliasSRC)->RC_VALOR
			ElseIf ( cAliasSRV )->RV_TIPOCOD == "3"				// Total Base provento
				nTotBsProv 	+= (cAliasSRC)->RC_VALOR
			ElseIf ( cAliasSRV )->RV_TIPOCOD == "4"				// Base Desconto
				nTotBsDesc	+= (cAliasSRC)->RC_VALOR
			EndIf

			nTotEmp += (cAliasSRC)->RC_VALOR //Soma ao total da empresa
			nTotRegs++ 	// Total de Registros processados

			If cPaisLoc == "BRA"
				fGravaAcum( cMesProc, cAnoProc, aSRCFields )
			Else
				//Traz o criterio de acumulacao da verba
				cCriterio	    := "" // Criterio de acumulacao da verba
				cSequencia	    := "" // Sequencia de acumulacao da verba
				lGeraAcumulador := .F.
				If !lModPadrao .Or. (cPaisLoc $ cPaisFol1)
					If !Empty( cCritAux) .and.  ;
					(fBuscaCrit(@cCriterio , @cSequencia, cAliasSRC, (cAliasSRC)->RC_PROCES, (cAliasSRC)->RC_ROTEIR, (cAliasSRC)->RC_PD, cCritAux, cSeqAux) )
						lGeraAcumulador := .T.
					EndIf
				EndIf

				//Grava as informacoes no arquivo de acumulados SRD
				fGravaAcum( cMesProc, cAnoProc, aSRCFields, cCriterio , cSequencia )

				If !lModPadrao .Or. (cPaisLoc $ cPaisFol1)
					//Traz o criterio de acumulacao da verba
					If lGeraAcumulador
						//Grava campos de Acumuladores
						If cPaisLoc=="CHI"
							fGrvAcumulador( cCriterio , cSequencia ,,,,, cMesProc, cAnoProc )
						Else
							fGrvAcumulador( cCriterio , cSequencia ,,,,, (cAliasRCH)->RCH_MES, (cAliasRCH)->RCH_ANO )
						EndIf
					EndIf
				EndIf
			EndIf

			(cAliasSRC)->(DbSkip())
		EndDo
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Exclui registros da tabelas SRC que ja foram gravados na SRD ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	fDeleteGpe(SRA->RA_FILIAL, SRA->RA_MAT, cProcesso, cPeriodo, cNumPag,  cRoteiro)

	fDeleteRGB(SRA->RA_FILIAL, SRA->RA_MAT)
EndIf

Return Nil

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³fCarProxRGB   ³ Autor ³ Leandro Drumond   ³ Data ³16.10.2013³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Carrega verba para periodo especifico                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ GPEM120()                                                  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function fCarProxRGB(aPerSeguinte,cNextProc,cNextPer,cNextRot,cNextPgto,cPdPara, cRotCalc, dDataPagto)

Local cPrefixo		:= ( PrefixoCpo( "SRC") + "_" )
Local cField		:= ""
Local cConteudo		:= ""
Local nField		:= 0
Local nPos			:= 0
Local nPosAux		:= 0
Local nAltReg		:= 0
Local nFields 		:= Len(aSRCFields)

Default cRotCalc 	:= "FOL"
Default dDataPagto  := cToD("//")

aAdd( aPerSeguinte, Array( nFields ) )

nAltReg := Len(aPerSeguinte)

	For nField := 1 To nFields

		cField 		:= aSRCFields[nField, 1]
		nPosAux		:= At("_", cField )
		cConteudo 	:= ""

		If cField == (cPrefixo+"FILIAL")
			nPos := Ascan(aRGBFields,{|x| x[1] = "RGB_FILIAL"  }) //-- Procura campo correspondente no aRGB
			aPerSeguinte[nAltReg, nPos]	:= (cAliasSRC)->RC_FILIAL
		ElseIf cField == (cPrefixo+"PD")
			nPos := Ascan(aRGBFields,{|x| x[1] = "RGB_PD"  }) //-- Procura campo correspondente no aRGB
			aPerSeguinte[nAltReg, nPos] := cPdPara
		ElseIf cField == (cPrefixo+"PERIOD")
			nPos := Ascan(aRGBFields,{|x| x[1] = "RGB_PERIOD"  }) //-- Procura campo correspondente no aRGB
			aPerSeguinte[nAltReg, nPos] := cNextPer
		ElseIf cField == (cPrefixo+"SEMANA")
			nPos := Ascan(aRGBFields,{|x| x[1] = "RGB_SEMANA"  }) //-- Procura campo correspondente no aRGB
			aPerSeguinte[nAltReg, nPos] := cNextPgto
		ElseIf cField == (cPrefixo+"PROCES")
			nPos := Ascan(aRGBFields,{|x| x[1] = "RGB_PROCES"  }) //-- Procura campo correspondente no aRGB
			aPerSeguinte[nAltReg, nPos] := cNextProc
		ElseIf cField == (cPrefixo+"ROTEIR")
			nPos := Ascan(aRGBFields,{|x| x[1] = "RGB_ROTEIR"  }) //-- Procura campo correspondente no aRGB
			aPerSeguinte[nAltReg, nPos] := cNextRot
		ElseIf cField == (cPrefixo+"PARCEL")
			nPos := Ascan(aRGBFields,{|x| x[1] = "RGB_PARCEL" } ) 						 //-- Procura campo correspondente no aRGB
			aPerSeguinte[nAltReg, nPos] := (cAliasSRC)->RC_PARCELA
		ElseIf cField == (cPrefixo+"TIPO2")
			nPos := Ascan(aRGBFields,{|x| x[1] = "RGB_TIPO2"  }) //-- Procura campo correspondente no aRGB

			//Caso a verba de provento de adiantamento tenha sido informada.
			If cRotCalc == "ADI" .And. (cAliasSRC)->RC_TIPO2 == "I"
				//Garante que seja gerada na RGB com Origem = A
				// Caso contrário, ficará com orgem F e a data de pagto no cálculo da folha ficará incorreta.
				aPerSeguinte[nAltReg, nPos] := "A"
			Else
				aPerSeguinte[nAltReg, nPos] := (cAliasSRC)->RC_TIPO2
			EndIf
		ElseIf cField == (cPrefixo+"HORAS")
			nPos := Ascan(aRGBFields,{|x| x[1] = "RGB_HORAS"  }) //-- Procura campo correspondente no aRGB
			aPerSeguinte[nAltReg, nPos] := (cAliasSRC)->RC_HORAS
		ElseIf cField == (cPrefixo+"VALOR")
			nPos := Ascan(aRGBFields,{|x| x[1] = "RGB_VALOR"  }) //-- Procura campo correspondente no aRGB
			If Empty( aPerSeguinte[nAltReg, nPos] )
				aPerSeguinte[nAltReg, nPos] := (cAliasSRC)->RC_VALOR
			Else
				aPerSeguinte[nAltReg, nPos] -= (cAliasSRC)->RC_VALOR
			EndIf
		ElseIf cField == (cPrefixo+"DTREF")
	 		nPos := Ascan(aRGBFields,{|x| x[1] = "RGB_DTREF"  }) //-- Procura campo correspondente no aRGB
			If cRotCalc == "ADI"
				aPerSeguinte[nAltReg, nPos] := dDataPagto
			Else
				aPerSeguinte[nAltReg, nPos] := LastDate( StoD(cNextPer+"01") )
			EndIf
		ElseIf cField == (cPrefixo+"ROTORI")
			nPos := Ascan(aRGBFields,{|x| x[1] = "RGB_ROTORI"  }) //-- Procura campo correspondente no aRGB
			aPerSeguinte[nAltReg, nPos] := fGetCalcRot("9")
		Else
			nPos := Ascan(aRGBFields,{|x| x[1] = "RGB_"+ Substr(cField ,nPosAux+1,06 )  }) 				//-- Procura campo correspondente no aRGB
			If nPos > 0
				aPerSeguinte[nAltReg, nPos] := (cAliasSRC)->( &cField )
			EndIf
		EndIf
	Next nField

Return Nil

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³fVerRotFec    ³ Autor ³ Leandro Drumond   ³ Data ³16.10.2013³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Verifica se existe algum roteiro aberto alem da folha      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ GPEM120()                                                  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function fVerRotFec(cRotAberto,cFilRCH)
Local aArea		:= GetArea()
Local cWhere	:= ""
Local cFromTable:= ""
Local cNumPagAux:= ""
Local cAliasQry	:= GetNextAlias()
Local lRet		:= .T.

cFromTable := "% " + RetSqlName("RCH") + " RCH %"

cWhere := "%"
cWhere += " RCH.RCH_PROCES  = '" + cProcesso + "' AND "
cWhere += " RCH.RCH_PER = '" + cPeriodo + "' AND "
cWhere += " RCH.RCH_ROTEIR = '" + cRoteiro + "' AND "
cWhere += " RCH.RCH_DTFECH = '' AND "
cWhere += " RCH.RCH_FILIAL = '" + cFilRCH + "' AND "
cWhere += "%"

BeginSql alias cAliasQry
	SELECT MAX(RCH_NUMPAG) AS MAXNUMPAG FROM
			%exp:cFromTable%
	WHERE
		 	%exp:cWhere%
		 	RCH.%NotDel%
EndSql

cNumPagAux := (cAliasQry)->MAXNUMPAG

(cAliasQry)->(dbCloseArea())

cWhere := "%"
cWhere += " RCH.RCH_PROCES  = '" + cProcesso + "' AND "
cWhere += " RCH.RCH_PER = '" + cPeriodo + "' AND "
cWhere += " RCH.RCH_ROTEIR <> '" + cRoteiro + "' AND "

If cNumPagAux == cNumPag
	cWhere += " RCH.RCH_NUMPAG >= '" + cNumPag +"' AND "
Else
	cWhere += " RCH.RCH_NUMPAG = '" + cNumPag +"' AND "
EndIf

cWhere += " RCH.RCH_DTFECH = '' AND "
cWhere += " RCH.RCH_FILIAL = '" + cFilRCH + "' AND "
cWhere += "%"

BeginSql alias cAliasQry
	SELECT * FROM
			%exp:cFromTable%
	WHERE
		 	%exp:cWhere%
		 	RCH.%NotDel%
EndSql

While (cAliasQry)->( !Eof() )

	cRotAberto += CRLF + (cAliasQry)->RCH_ROTEIR + " - " + Posicione("SRY",1,xFilial("SRY")+(cAliasQry)->RCH_ROTEIR,"RY_DESC")
	(cAliasQry)->(DbSkip())
	lRet := .F.
EndDo

(cAliasQry)->(dbCloseArea())

RestArea(aArea)

Return lRet
/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³fCriaTmp       ³ Autor ³ Leandro Drumond    ³ Data ³ 17/10/13 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Cria tabela temporaria para uso no FWMarkBrowse      			³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³fCriaTmp()				                                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³GPEM120					                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function fCriaTmp()
Local aArea		 := GetArea()
Local aColumns	 := {}
Local aStruct 
Local cQuery	 := ''
Local cAliasRCH	 := 'QRCH'
Local cKeyAux	 := ""
Local cAcessaRCH := ChkRH( "GPEM120" , "RCH" , "1" )
Local cAcessaSRY := ChkRH( "GPEM120" , "SRY" , "1" )
Local cCpoQry    := "RCH_FILIAL, RCH_ROTEIR, RY_DESC, RCH_PROCES, RCH_PER, RCH_NUMPAG, RCH_DTINTE, RCH_DTINI, RCH_DTPAGO, RY_TIPO"
Local lRet		 := .F.
Local lUsaBulk   := FwLibVersion() >= "20201009" .And. FindClass( "FwBulk" )
Local nX 		 := 0
Local oBulk

//Se existir filtro inclui todos os campos na query para não gerar error.log
If !Empty(cAcessaRCH) .or. !Empty(cAcessaSRY)
	DbSelectARea("SRY")
	DbSelectARea("RCH")
	cCpoQry := ""
	aStruct := SRY->(dbStruct())
	For nX := 1 to Len(aStruct)
		cCpoQry += aStruct[nX,1] + ", "
	Next nX 
	aStruct := RCH->(dbStruct())
	For nX := 1 to Len(aStruct)
		cCpoQry += aStruct[nX,1] + ", "
	Next nX
	cCpoQry := SubStr(cCpoQry,1,Len(cCpoQry)-2)
EndIf

cAcessaRCH := If(!Empty(cAcessaRCH),StrTran(cAcessaRCH, "RCH->", "QRCH->"),".T.")
cAcessaSRY := If(!Empty(cAcessaSRY),StrTran(cAcessaSRY, "SRY->", "QRCH->"),".T.")

If Select(cAliasMark) > 0
	DbSelectArea(cAliasMark)
	DbCloseArea()
EndIf

aAdd( aColumns, { "TAB_OK"		,"C",02,00 })
aAdd( aColumns, { "TAB_FIL"		,"C",TAMSX3("RCH_FILIAL")[1],TAMSX3("RCH_FILIAL")[2]})
aAdd( aColumns, { "TAB_ROT"		,"C",TAMSX3("RY_CALCULO")[1],TAMSX3("RY_CALCULO")[2]})
aAdd( aColumns, { "TAB_DESC"	,"C",TAMSX3("RY_DESC")[1],TAMSX3("RY_DESC")[2]})
aAdd( aColumns, { "TAB_PROC"	,"C",TAMSX3("RCH_PROCES")[1],TAMSX3("RCH_PROCES")[2]})
aAdd( aColumns, { "TAB_PER"		,"C",TAMSX3("RCH_PER")[1],TAMSX3("RCH_PER")[2]})
aAdd( aColumns, { "TAB_NPAG"	,"C",TAMSX3("RCH_NUMPAG")[1],TAMSX3("RCH_NUMPAG")[2]})
aAdd( aColumns, { "TAB_TPROT"	,"C",TAMSX3("RY_TIPO")[1],TAMSX3("RY_TIPO")[2]})
aAdd( aColumns, { "TAB_INTEG"	,"D",8,0})
aAdd( aColumns, { "TAB_DTREF"	,"D",8,0})
aAdd( aColumns, { "TAB_DTPAG"	,"D",8,0})

//Efetua a criacao do arquivo temporario
oTmpTable := FWTemporaryTable():New(cAliasMark)
oTmpTable:SetFields( aColumns )
oTmpTable:Create()

If lUsaBulk
	oBulk := FwBulk():New( oTmpTable:GetTableNameForTCFunctions() )
	lUsaBulk := FwBulk():CanBulk()
    If lUsaBulk
        oBulk:SetFields(aColumns)
    EndIf
EndIf

dbSelectArea( "RCH" )
DbSetOrder(RetOrdem("RCH","RCH_FILIAL+RCH_PROCES+RCH_ROTEIR+RCH_PER+RCH_NUMPAG"))

cQuery := "SELECT " + cCpoQry
cQuery += 		" FROM " + RetSqlName("RCH") + " RCH"
cQuery +=			" INNER JOIN " + RetSqlName("SRY") + " SRY"
cQuery +=			" ON " + FWJoinFilial( "RCH", "SRY" ) + " AND RCH_ROTEIR = RY_CALCULO AND SRY.D_E_L_E_T_ = ' ' "
cQuery +=		" WHERE RCH_PERSEL = '1' AND"
If FunName() == "GPEA001" .Or. FunName() == "GP001FECH"
	cQuery +=	" SRY.RY_TIPO = 'C' AND"
ElseIf FunName() == "GP068FECH"
	cQuery +=	" SRY.RY_TIPO = 'I' AND"
ElseIf FunName() == "GP131FECH"
	cQuery +=	" SRY.RY_TIPO IN ('8','D','E') AND"
EndIf
cQuery +=			" RCH.D_E_L_E_T_ = ' '"
cQuery += 		" ORDER BY " + SqlOrder(RCH->(IndexKey()))

cQuery := ChangeQuery( cQuery )

dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasRCH)

TcSetField(cAliasRCH,"RCH_DTINTE","D",8,0)

DbSelectArea(cAliasRCH)

DbSelectArea(cAliasMark)

While (cAliasRCH)->(!Eof())
	//Se não satisfizer os filtros do controle de usuários, pula registro.
	If !(&(cAcessaSRY)) .or. !(&(cAcessaRCH))
		(cAliasRCH)->(DbSkip())
		Loop
	EndIf

	If cKeyAux <> (cAliasRCH)->RCH_FILIAL + (cAliasRCH)->RCH_PROCES + (cAliasRCH)->RCH_ROTEIR + (cAliasRCH)->RCH_PER
		lRet := .T.

		If(!lUsaBulk,RecLock(cAliasMark,.T.),Nil)

		If(!lUsaBulk,(cAliasMark)->TAB_FIL		:= (cAliasRCH)->RCH_FILIAL, Nil)
		If(!lUsaBulk,(cAliasMark)->TAB_ROT 		:= (cAliasRCH)->RCH_ROTEIR, Nil)
		If(!lUsaBulk,(cAliasMark)->TAB_DESC 	:= (cAliasRCH)->RY_DESC, Nil)
		If(!lUsaBulk,(cAliasMark)->TAB_PROC		:= (cAliasRCH)->RCH_PROCES, Nil)
		If(!lUsaBulk,(cAliasMark)->TAB_PER		:= (cAliasRCH)->RCH_PER, Nil)
		If(!lUsaBulk,(cAliasMark)->TAB_NPAG		:= (cAliasRCH)->RCH_NUMPAG, Nil)
		If(!lUsaBulk,(cAliasMark)->TAB_INTEG	:= (cAliasRCH)->RCH_DTINTE, Nil)
		If(!lUsaBulk,(cAliasMark)->TAB_TPROT	:= (cAliasRCH)->RY_TIPO, Nil)
		If(!lUsaBulk,(cAliasMark)->TAB_DTREF	:= StoD((cAliasRCH)->RCH_DTINI), Nil)
		If(!lUsaBulk,(cAliasMark)->TAB_DTPAG	:= StoD((cAliasRCH)->RCH_DTPAGO), Nil)

		If(!lUsaBulk,MsUnLock(),;
									oBulk:AddData({	'  '							,; //TAB_OK
													(cAliasRCH)->RCH_FILIAL   		,;
													(cAliasRCH)->RCH_ROTEIR			,;
													(cAliasRCH)->RY_DESC     		,;
													(cAliasRCH)->RCH_PROCES			,;
													(cAliasRCH)->RCH_PER			,;
													(cAliasRCH)->RCH_NUMPAG			,;
													(cAliasRCH)->RY_TIPO			,;
													(cAliasRCH)->RCH_DTINTE			,;
													StoD((cAliasRCH)->RCH_DTINI)	,;
													StoD((cAliasRCH)->RCH_DTPAGO)	}))

		cKeyAux := (cAliasRCH)->RCH_FILIAL + (cAliasRCH)->RCH_PROCES + (cAliasRCH)->RCH_ROTEIR + (cAliasRCH)->RCH_PER
	EndIf

	(cAliasRCH)->(DbSkip())

EndDo

( cAliasRCH )->( dbCloseArea() )

If lUsaBulk
    oBulk:Close()
    oBulk:Destroy()
    oBulk := nil
EndIf

RestArea(aArea)

Return lRet


/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³fMntColsMark³ Autor ³ Leandro Drumond       ³ Data ³ 17/10/13 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Monta dados dos campos da tabela temporaria                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ fMntColsMark()                                               ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function fMntColsMark()
Local aArea		:= GetArea()
Local aColsAux 	:=`{}
Local aColsSX3	:= {}
Local aCampos  	:= {}
Local aDados	:= {}
Local nX		:= 0

If lFilComp
	aCampos  	:= {"RY_CALCULO","RY_DESC","RCH_PROCES","RCH_PER","RCH_NUMPAG","RCH_DTINTE"}
	aDados		:= {{||(cAliasMark)->TAB_ROT}, {||(cAliasMark)->TAB_DESC},{||(cAliasMark)->TAB_PROC},{||(cAliasMark)->TAB_PER},{||(cAliasMark)->TAB_NPAG},{||(cAliasMark)->TAB_INTEG}}
Else
	aCampos  	:= {"RCH_FILIAL","RY_CALCULO","RY_DESC","RCH_PROCES","RCH_PER","RCH_NUMPAG","RCH_DTINTE"}
	aDados		:= {{||(cAliasMark)->TAB_FIL},{||(cAliasMark)->TAB_ROT}, {||(cAliasMark)->TAB_DESC},{||(cAliasMark)->TAB_PROC},{||(cAliasMark)->TAB_PER},{||(cAliasMark)->TAB_NPAG},{||(cAliasMark)->TAB_INTEG}}
EndIf

DbSelectArea("SX3")
DbSetOrder(2)

For nX := 1 to Len(aCampos)
	If SX3->( dbSeek(aCampos[nX]) )
	    aColsSX3 := {X3Titulo(),aDados[nX], SX3->X3_TIPO, SX3->X3_PICTURE,1,SX3->X3_TAMANHO,SX3->X3_DECIMAL,.F.,,,,,,,,1}
	    aAdd(aColsAux,aColsSX3)
	    aColsSX3 := {}
	EndIf
Next nX

RestArea(aArea)

Return aColsAux

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³SetMarkAll  ³ Autor ³ Leandro Drumond       ³ Data ³ 17/10/13 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Marca/desmarca todos os itens 			                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ SetMarkAll(cMarca,lMarcar )                                  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function SetMarkAll(cMarca,lMarcar,cAliasAux )

Local aAreaMark
Local cAliasMrk  := ""

DEFAULT cAliasAux := cAliasMark

cAliasMrk := cAliasAux

aAreaMark  := (cAliasMrk)->( GetArea() )

dbSelectArea(cAliasMrk)
(cAliasMrk)->( dbGoTop() )

While !(cAliasMrk)->( Eof() )
	RecLock( (cAliasMrk), .F. )
	(cAliasMrk)->TAB_OK := IIf( lMarcar , cMarca, '  ' )
	MsUnLock()
	(cAliasMrk)->( dbSkip() )
EndDo

RestArea( aAreaMark )

Return .T.

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³Gpm120IniMark ³ Autor ³ Leandro Drumond     ³ Data ³ 17/10/13 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Inicializador de procesamento auxiliar da markbrowse         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ SetMarkAll(cMarca,lMarcar )                                  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function Gpm120IniMark(lRobo)

Local aRoteiros := {}
Local cMarca 	:= ""
Local lBlind	:= IsBlind()
Local lVldFol	:= .F.
Local lClose    := .T.
Local nX        := 0

Default lRobo   := .F.

If !lBlind
	cMarca 	:= oMark:Mark()
EndIf

DbSelectArea(cAliasMark)
DbGoTop()

While !Eof() 
	If !lSegPlan .And. (lBlind .Or. oMark:IsMark(cMarca))
		aAdd(aRoteiros,{TAB_ROT, TAB_PER, TAB_NPAG, TAB_TPROT, TAB_FIL, TAB_PROC})
		If TAB_TPROT $ "1*9"
			lVldFol := .T.
		EndIf
	EndIf
	DbSkip()
EndDo

If lSegPlan .And. ValType(MV_PAR01) == "A" //Carrega o aRoteiros ao rodar em segundo plano
	For nX := 1 To Len( MV_PAR01 )
		aAdd(aRoteiros, MV_PAR01[nX])
	Next nX
EndIf

aSort( aRoteiros,,, { |x, y| x[5]+x[4] > y[5]+y[4] } )

//Valida a incidência de verbas de férias mês seguinte
If !lBlind .And. lVldFol 
	If !fVldPd()
		oDlg:End()
		Return Nil
	EndIf
EndIf

If Len(aRoteiros) > 0
	//Se a validação de fechamento da folha estiver ativo e selecionou algum roteiro diferente de FOL/AUT para fechamento, bloqueia
	If lVldFecFol .and. lVldFol .and. aScan(aRoteiros,{|x| !(x[4] $ "1*9")}) > 0
		//Atenção ### Conforme configuração do parâmetro MV_FECFOL, não será permitido a execução do fechamento do roteiro FOL/AUT em conjunto com outro roteiro de cálculo ### Efetue o fechamento do roteiro FOL/AUT apenas após ter fechado todos os demais
		Help(NIL, NIL, STR0007, NIL, STR0140, 1, 0, NIL, NIL, NIL, NIL, NIL, {STR0141})
	Else
		If lSegPlan
			Processa({|| GPM120Processa(aRoteiros, lRobo)})		
		ElseIf !lBlind
			If !GPESmartViewUtils():ValidBackGExec("GPEM120", 7, {aRoteiros})
				Proc2BarGauge( { || GPM120Processa(aRoteiros, lRobo) } , OemToAnsi(STR0001) , NIL , NIL , .T. , .T. , .T. , .T. )	// "Fechamento de Periodos"
			EndIf
		Else
			GPM120Processa(aRoteiros, lRobo)
		EndIf
	EndIf
Else
	Help( ,, "HELP",, STR0078, 1, 0 )//"Nenhum roteiro selecionado"
	lClose := .F.
EndIf

If !lBlind .And. lClose .And. !lSegPlan
	oDlg:End()   //Fecha dialog
EndIf

Return Nil

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ fBuscaFer  ³ Autor ³ Leandro Drumond       ³ Data ³ 24/11/13 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Busca periodo aquisitivo atual		                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ fBuscaFer()                                                  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function fBuscaFer()
Local aArea		:= GetArea()
Local cChave 	:= ""
Local dRet 		:= SRA->RA_ADMISSA

If SRA->RA_CATFUNC $ "E*G"   // Estagiario Mensalista/Horista
	cChave 	:= SRA->RA_FILIAL + SRA->RA_MAT + aCodFol[891,1]
Else
	cChave 	:= SRA->RA_FILIAL + SRA->RA_MAT + aCodFol[72,1]
EndIf

DbSelectArea("SRF")
DbSetOrder(2)

If DbSeek(cChave)
	While !Eof() .and. SRF->(RF_FILIAL+RF_MAT+RF_PD == cChave)
		If SRF->RF_STATUS == "1" //ATIVO
			dRet := SRF->RF_DATABAS
			Exit
		Else
			dRet := SRF->RF_DATAFIM + 1
		EndIf
		DbSkip()
	EndDo
EndIf

RestArea(aArea)

Return dRet

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³Gp120IniSXB ³ Autor ³ Leandro Drumond       ³ Data ³ 27/03/14 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Consulta especifica do cadastro de periodos                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ Gp120IniSXB()		                                        ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function Gp120IniSXB()
Local aArea		:= GetArea()
Local cAliasQry	:= "QRCH"
Local cWhere	:= ""
Local cKeyAux 	:= ""
Local lOK     	:= .F.
Local nPosLbxA	:= 0.00
Local oDlg		:= NIL
Local oLbxA		:= NIL
Local nOpca		:= 0

Local aAdvSize		:= {}
Local aInfoAdvSize	:= {}
Local aObjCoords	:= {}
Local aObjSize		:= {}

Local lGestPubl 	:= IIF(ExistFunc("fUsaGFP"),fUsaGFP(),.F.)
Local cJoinModl		:= ""
Local lRCJModulo	:= RCJ->(ColumnPos("RCJ_MODULO")) > 0

Local bSet15 := {|| NIL}
Local bSet24 := {|| NIL}

aLbxA := {}

VAR_IXB := {'','',''}

cWhere := "%"
cWhere += " RCH.RCH_PERSEL 	= '1' AND "
cWhere += " RCH.RCH_DTFECH 		= '' "
cWhere += GPEFilQry("RCH_FILIAL")
cWhere += "%"

cJoinModl := "%"
If lGestPubl .AND. lRCJModulo
	cJoinModl += "JOIN " + RetSqlName("RCJ") + " RCJ  ON "
	cJoinModl += FWJoinFilial( "RCH", "RCJ" )
	cJoinModl += " AND RCH.RCH_PROCES = RCJ.RCJ_CODIGO "
	cJoinModl += " AND  RCJ.RCJ_MODULO IN ('" + If(cModulo $ "GFP*VDF", "GFP", " ','GPE") + "')"
EndIf
cJoinModl += "%"

BeginSql alias cAliasQry
	SELECT 		RCH_FILIAL, RCH_PROCES, RCH_PER, RCH_NUMPAG
	FROM 		%table:RCH% RCH
	%exp:cJoinModl%
	WHERE 		%exp:cWhere% AND
				RCH.%NotDel%
	ORDER BY RCH_FILIAL, RCH_PROCES, RCH_PER, RCH_NUMPAG
EndSql

While (cAliasQry)->( !Eof() )
	If cKeyAux <> (cAliasQry)->( RCH_FILIAL + RCH_PROCES + RCH_PER + RCH_NUMPAG )
		If lFilComp
			(cAliasQry)->( aAdd( aLbxA, { RCH_PROCES, RCH_PER, RCH_NUMPAG} ) )
		Else
			(cAliasQry)->( aAdd( aLbxA, { RCH_FILIAL, RCH_PROCES, RCH_PER, RCH_NUMPAG } ) )
		EndIf
		cKeyAux := (cAliasQry)->( RCH_FILIAL + RCH_PROCES + RCH_PER + RCH_NUMPAG )
	EndIf
	(cAliasQry)->( dbSkip() )
EndDo

If Empty(aLbxA)
	If lFilComp
		aAdd( aLbxA , {'','','' } )
	Else
		aAdd( aLbxA , {'','','','' } )
	EndIf
EndIf

( cAliasQry )->( dbCloseArea() )

aAdvSize		:= MsAdvSize( , .T., 390)
aInfoAdvSize	:= { aAdvSize[1] , aAdvSize[2] , aAdvSize[3] , aAdvSize[4] , 15 , 5 }
aAdd( aObjCoords , { 000 , 000 , .T. , .T. } )
aObjSize := MsObjSize( aInfoAdvSize , aObjCoords )

//Abaixo utilizamos o tamanho da janela como na versão 10, pois cada objeto tem seu posicionamento específico,
//o cada qual eh realocado conforme a resolução da tela do usuário
DEFINE FONT oFont NAME "Arial" SIZE 0,-11 BOLD
DEFINE MSDIALOG oDlg FROM aAdvSize[7],0 TO aAdvSize[6],aAdvSize[5] TITLE OemToAnsi(STR0001) PIXEL

	If lFilComp
		@ aObjSize[1,1], aObjSize[1,2] LISTBOX oLbxA FIELDS HEADER GetSx3Cache("RCH_PROCES", "X3_TITULO"),GetSx3Cache("RCH_PER", "X3_TITULO"),;
		 GetSx3Cache("RCH_NUMPAG", "X3_TITULO")  SIZE 290,130;
		OF oDlg PIXEL ON DBLCLICK ( lOk := .T., nPosLbxA:=oLbxA:nAt,oDlg:End() )
	Else
		@ aObjSize[1,1], aObjSize[1,2] LISTBOX oLbxA FIELDS HEADER GetSx3Cache("RCH_FILIAL", "X3_TITULO"),GetSx3Cache("RCH_PROCES", "X3_TITULO"),GetSx3Cache("RCH_PER", "X3_TITULO"),;
		 GetSx3Cache("RCH_NUMPAG", "X3_TITULO")  SIZE 290,130;
		OF oDlg PIXEL ON DBLCLICK ( lOk := .T., nPosLbxA:=oLbxA:nAt,oDlg:End() )
	EndIf

	oLbxA:SetArray(aLbxA)
	If lFilComp
		oLbxA:bLine := { || {aLbxA[oLbxA:nAt,1],aLbxA[oLbxA:nAt,2],aLbxA[oLbxA:nAt,3]}}
	Else
		oLbxA:bLine := { || {aLbxA[oLbxA:nAt,1],aLbxA[oLbxA:nAt,2],aLbxA[oLbxA:nAt,3],aLbxA[oLbxA:nAt,4]}}
	EndIf

	bSet15 := { || nOpca := 1, lOk := .T., nPosLbxA:=oLbxA:nAt,oDlg:End()}
	bSet24 := { || nOpca := 0, lOk := .F., oDlg:End() }

ACTIVATE MSDIALOG oDlg CENTERED ON INIT (EnchoiceBar(oDlg, bSet15, bSet24))

If ( lOk )
	If lFilComp
		VAR_IXB[1] := aLbxA[nPosLbxA,1]
		VAR_IXB[2] := aLbxA[nPosLbxA,2]
		VAR_IXB[3] := aLbxA[nPosLbxA,3]
	Else
		VAR_IXB[1] := aLbxA[nPosLbxA,2]
		VAR_IXB[2] := aLbxA[nPosLbxA,3]
		VAR_IXB[3] := aLbxA[nPosLbxA,4]
	EndIf
EndIf

RestArea( aArea )

Return lOk

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³Gp120VldGrid³ Autor ³ Leandro Drumond       ³ Data ³ 28/03/14 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Valid da enchoice						                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ MenuDef()                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function Gp120VldGrid()

//Se nao executou consulta padrao, obtem o periodo atual para carregr os demais campos
DbSelectArea(cAliasMark)

If !Empty(cProcesso) .and. !Empty(cPeriodo) .and. !Empty(cNumPag) .and. !Empty(cRoteiro)
	SET FILTER TO TAB_PROC == cProcesso .And.  TAB_PER ==  cPeriodo .And. TAB_NPAG ==cNumPag .And.  TAB_ROT  ==   cRoteiro .And. Eval(bTemAcesso) .and. Eval(bVldDtPago)
ElseIf !Empty(cProcesso) .and. !Empty(cPeriodo) .and. !Empty(cNumPag) .and. Empty(cRoteiro)
	SET FILTER TO TAB_PROC == cProcesso .And.  TAB_PER ==  cPeriodo .And. TAB_NPAG ==cNumPag .And. Eval(bTemAcesso) .and. Eval(bVldDtPago)
ElseIf !Empty(cProcesso) .and. !Empty(cPeriodo) .and. Empty(cNumPag) .and. !Empty(cRoteiro)
 	SET FILTER TO TAB_PROC == cProcesso .And.  TAB_PER ==  cPeriodo .And.  TAB_ROT  ==   cRoteiro .And. Eval(bTemAcesso) .and. Eval(bVldDtPago)
ElseIf !Empty(cProcesso) .and. Empty(cPeriodo) .and. !Empty(cNumPag) .and. !Empty(cRoteiro)
	SET FILTER TO TAB_PROC == cProcesso .And. TAB_NPAG ==cNumPag .And.  TAB_ROT  ==   cRoteiro .And. Eval(bTemAcesso) .and. Eval(bVldDtPago)
ElseIf !Empty(cProcesso) .and. Empty(cPeriodo) .and. !Empty(cNumPag) .and. Empty(cRoteiro)
	SET FILTER TO TAB_PROC == cProcesso .And. TAB_NPAG ==cNumPag .And. Eval(bTemAcesso) .and. Eval(bVldDtPago)
ElseIf !Empty(cProcesso) .and. Empty(cPeriodo) .and. Empty(cNumPag) .and. !Empty(cRoteiro)
	SET FILTER TO TAB_PROC + TAB_ROT  == cProcesso + cRoteiro .And. Eval(bTemAcesso) .and. Eval(bVldDtPago)
ElseIf !Empty(cProcesso) .and. !Empty(cPeriodo) .and. Empty(cNumPag) .and. Empty(cRoteiro)
	SET FILTER TO TAB_PROC == cProcesso .And.  TAB_PER == cPeriodo .And. Eval(bTemAcesso) .and. Eval(bVldDtPago)
ElseIf !Empty(cProcesso) .and. Empty(cPeriodo) .and. Empty(cNumPag) .and. Empty(cRoteiro)
	SET FILTER TO TAB_PROC == cProcesso .And. Eval(bTemAcesso) .and. Eval(bVldDtPago)
ElseIf Empty(cProcesso) .and. !Empty(cPeriodo) .and. Empty(cNumPag) .and. Empty(cRoteiro)
	SET FILTER TO TAB_PER == cPeriodo .And. Eval(bTemAcesso) .and. Eval(bVldDtPago)
ElseIf Empty(cProcesso) .and. !Empty(cPeriodo) .and. !Empty(cNumPag) .and. !Empty(cRoteiro)
	SET FILTER TO TAB_PER + TAB_NPAG + TAB_ROT  == cPeriodo + cNumPag + cRoteiro .And. Eval(bTemAcesso) .and. Eval(bVldDtPago)
ElseIf Empty(cProcesso) .and. !Empty(cPeriodo) .and. !Empty(cNumPag) .and. Empty(cRoteiro)
	SET FILTER TO TAB_PER + TAB_NPAG  == cPeriodo + cNumPag .And. Eval(bTemAcesso) .and. Eval(bVldDtPago)
ElseIf Empty(cProcesso) .and. !Empty(cPeriodo) .and. Empty(cNumPag) .and. !Empty(cRoteiro)
	SET FILTER TO  TAB_PER ==  cPeriodo .And.  TAB_ROT  ==   cRoteiro .And. Eval(bTemAcesso) .and. Eval(bVldDtPago)
ElseIf Empty(cProcesso) .and. Empty(cPeriodo) .and. !Empty(cNumPag) .and. !Empty(cRoteiro)
	SET FILTER TO  TAB_NPAG ==cNumPag .And.  TAB_ROT  ==   cRoteiro .And. Eval(bTemAcesso) .and. Eval(bVldDtPago)
ElseIf Empty(cProcesso) .and. Empty(cPeriodo) .and. !Empty(cNumPag) .and. Empty(cRoteiro)
	SET FILTER TO TAB_NPAG == cNumPag .And. Eval(bTemAcesso) .and. Eval(bVldDtPago)
ElseIf Empty(cProcesso) .and. Empty(cPeriodo) .and. Empty(cNumpag) .and. !Empty(cRoteiro)
	SET FILTER TO TAB_ROT  == cRoteiro .And. Eval(bTemAcesso) .and. Eval(bVldDtPago)
ElseIf Empty(cProcesso) .and. Empty(cPeriodo) .and. Empty(cNumpag) .and. Empty(cRoteiro)
	SET FILTER TO Eval(bTemAcesso) .and. Eval(bVldDtPago)
EndIf

oMark:Refresh(.T.)

Return .T.

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³fGetRotNotInt³ Autor ³ Leandro Drumond      ³ Data ³ 16/04/14 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Obte os roteiros que nao necessitam  de integracao	        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ fGetRotNotInt()                                              ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function fGetRotNotInt()
Local cNotInt 	:= "'"
Local cAliasQry := GetNextAlias()

BeginSql alias cAliasQry
	SELECT 		RY_CALCULO
	FROM 		%table:SRY% SRY
	WHERE 		RY_INTEGRA = '2' AND
				SRY.%NotDel%
EndSql

While (cAliasQry)->( !Eof() )
	cNotInt += (cAliasQry)->RY_CALCULO + "*"
	(cAliasQry)->( dbSkip() )
EndDo
cNotInt += "'"

( cAliasQry )->( dbCloseArea() )

Return cNotInt

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³ErroForm 		³Autor³Leandro Drumond     ³ Data ³27/07/2015³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Verifica os Erros na Execucao da Formula                     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL                                                  	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                                      	     ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico                                                     ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function ErroForm(	oErr			,;	//01 -> Objeto oErr
							lNotErro		,;	//02 -> Se Ocorreu Erro ( Retorno Por Referencia )
							aLog			,;
							cNumJob			,;
							lThread			;
						)

Local aErrorStack
Local cMsgHelp	:= ""

DEFAULT lNotErro	:= .T.

IF !( lNotErro := !( oErr:GenCode > 0 ) )
	cMsgHelp += "Error Description: "
	cMsgHelp += oErr:Description
	aAdd( aLog, cMsgHelp )
	aErrorStack	:= Str2Arr( oErr:ErrorStack , Chr( 10 ) )
	aEval( aErrorStack , { |X| aAdd(aLog, X) } )
	aEval( aErrorStack , { |cStackError| RotAddErr( cStackError ) } )
	If lThread
		PutGlbValue("nTemErro"+cNumJob,"1")
		GlbUnLock()
	EndIf
EndIF

Break

Return( NIL )

/*/
ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿
³Fun‡„o    ³RotAddErr	  ³Autor ³Leandro Drumond      ³ Data ³27/07/2015³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´
³Descri‡„o ³Adiciona String de Erro aa __aRotErr						 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Sintaxe   ³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Parametros³<Vide Parametros Formais>									 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Retorno   ³NIL     													 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Observa‡„o³                                         					 ³
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Uso       ³Generico 													 ³
ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ/*/
Static Function RotAddErr( cErr )

Local aErr

Local nErr		:= Len( cErr )

DEFAULT __aRotErr := {}

IF ( nErr > 220 )
	aErr := {}
	While ( nErr > 220 )
		aAdd( aErr , SubStr( cErr , 1 , 220 ) )
		cErr := SubStr( cErr , 221 )
		IF ( ( nErr := Len( cErr ) ) < 220 )
			aAdd( aErr , cErr )
			Exit
		EndIF
	End While
	aEval( aErr , { |cErr| RotAddErr( cErr ) } )
ElseIF ( aScan( __aRotErr , { |x| x == cErr } ) == 0 )
	aAdd( __aRotErr , cErr )
EndIF

Return( NIL )

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ MenuDef    ³ Autor ³ Leandro Drumond       ³ Data ³ 17/10/13 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Menu Funcional utilizado na mark browse                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ MenuDef()                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function MenuDef()

	Local aRotina   := {}

	ADD OPTION aRotina TITLE STR0077	ACTION 'Gpm120IniMark()'	OPERATION 2 ACCESS 0 	//"Confirmar"

Return aRotina

/*/{Protheus.doc} GetSRH
Verifica se o funcionário teve férias calculadas apenas com abono pecuniário, sem gerar afastamento na SR8
@author cicero.pereira
@since 02/08/2016
@version 1.0
@return lAbono, Lógica, .T. se o funcionário teve calculo de férias apenas com abono.
/*/
Static Function GetSRH()

	Local aArea  := getArea()
	Local lAbono := .F.

	lTemAbMes	:= .F.
	lTemAbMSeg	:= .F.
	nContFer	:= 0

	DbSelectArea( "SRH" )

	If SRH->( DbSeek( SRA->RA_FILIAL + SRA->RA_MAT ) )
		While ! SRH->( Eof() ) .AND. SRH->( RH_FILIAL + RH_MAT ) == SRA->RA_FILIAL + SRA->RA_MAT
			If MesAno(Iif( !(cPaisLoc $ "ARG"), SRH->RH_DATAINI, SRH->RH_DTRECIB )) == (cAnoProc + cMesProc)
				// Se houver apenas abono pecuniário no mês corrente.
				If	SRH->RH_DFERIAS == 0 .AND. SRH->RH_DABONPE > 0 .AND. SRH->RH_DATAINI == SRH->RH_DATAFIM
					lAbono	:= .T.
					EXIT
				EndIf
			EndIf
			SRH->( dbSkip() )
		EndDo
	EndIf

	RestArea(aArea)

Return lAbono


/*/{Protheus.doc} AtuSRF
Atualiza dias de direito quando foi calculado apenas abono pecuniário nas férias
@author cicero.pereira
@since 02/08/2016
@version 1.0
/*/
Static Function AtuSRF(aSR8)

	Local nFaltas		:= 0
	Local nX 			:= 0
	Local nPosDurac		:= 0
	Local nPosIniFer	:= 0
	Local nTotDias		:= 0
	Local nPosAt		:= 0
	Local dBaseAtu		:= CtoD("//")
	Local dFerVen		:= 0
	Local cFerAnt		:= ""
	Local nFerAnt		:= 0

	lTemAbMes	:= .F.
	lTemAbMSeg	:= .F.
	nContFer	:= 0

	Default aSR8 := {}

	If (cAliasSRA)->RA_CATFUNC $ "E*G"
		// Atualiza SRF para Estagiário Mensalista/Horista
		// Estagiários não possuem cálculo efetuado na SRF, apenas lançamento da ausência de Recesso
		If Len(aSR8) > 0
			nPosDurac	:= aScan( aSR8Fields,{ |x| x[1] ==  "R8_DURACAO" } )
			nPosIniFer	:= aScan( aSR8Fields,{ |x| x[1] ==  "R8_DATAINI" } )
			nTotDias	:= aSR8[nPosDurac] // Duração
			aPerFerias 	:= {}
			Calc_Fer(@aPerFerias, dDtaLimite, , , , , , ,)
			If Len(aPerFerias) > 0
				nPosAt := aScan(aPerFerias,{|x| x[8]== "1"}) // Busca pelo Período Aquisito Ativo
				If nPosAt > 0
					dBaseAtu 	:= DtoS(aPerFerias[nPosAt][01])
					dFerVen	:= 	aPerFerias[nPosAt][03]
					DbSelectArea("SRF")
					DbSetOrder(2)
					If DbSeek( SRA->RA_FILIAL + SRA->RA_MAT + aCodFol[891,1] + dBaseAtu )
						// Só atualiza a SRF com total de dias de ferias antecipadas no primeiro período do recesso
						If MesAno(aSR8[nPosIniFer]) == cPeriodo
							// Se recebeu todos os dias de direito, atualiza os Dias Pagos e Status
							// Cria/Atualiza novo período
							If  nTotDias >= nTotDiaPer .Or. nTotDias + SRF->RF_DFERANT >= nTotDiaPer
								RecLock( "SRF", .F. )
								SRF->RF_DFERANT += nTotDias
								If dFerVen < nTotDias // Dias de Férias Vencidas < Total de Dias
									SRF->RF_DIASANT += nTotDias - dFerVen // Atualiza Dias Antecipados
								EndIf
								SRF->RF_STATUS  := "3"
								SRF->( MsUnLock() )

								//Apura periodos posteriores ao calculado
								Calc_Fer(@aPerFerias, dDtaLimite, , , , , , , aPerFerias[nPosAt][01]+1)

								//Cria o periodo posterior (se ainda nao existir)
								For nX := 1 to Len(aPerFerias)
									If ! SRF->( DbSeek( SRA->RA_FILIAL + SRA->RA_MAT + aCodFol[891,1] + DtoS(aPerFerias[nX][01]) ) )
										RecLock( "SRF", .T. )
										SRF->RF_FILIAL	:= SRA->RA_FILIAL
										SRF->RF_MAT		:= SRA->RA_MAT
										SRF->RF_PD		:= aCodFol[891,1]
										SRF->RF_DIASDIR := nTotDiaPer
										SRF->RF_STATUS	:= "1"
										SRF->RF_DATABAS := aPerFerias[nX][01]
										SRF->RF_DATAFIM := aPerFerias[nX][02]
										SRF->RF_DFERVAT := aPerFerias[nX][03]
										SRF->RF_DFERAAT := aPerFerias[nX][04]
										SRF->RF_DFERANT := aPerFerias[nX][14]
										SRF->RF_DVENPEN := aPerFerias[nX][11]
										SRF->RF_IVENPEN := aPerFerias[nX][12]
										SRF->RF_FVENPEN := aPerFerias[nX][13]
										SRF->RF_DFALVAT := aPerFerias[nX][15]
										SRF->RF_DFALAAT := aPerFerias[nX][16]
										SRF->( MsUnLock() )
									EndIf
								Next nX
							// Se nao foram dados todos os dias de direito, atualiza DIAS ANTECIPADOS
							Else
								RecLock( "SRF", .F. )
								SRF->RF_DFERANT += nTotDias

								If dFerVen < nTotDias // Dias de Férias Vencidas < Total de Dias
									SRF->RF_DIASANT += nTotDias - dFerVen // Atualiza Dias Antecipados
								EndIf

								SRF->( MsUnLock() )
							EndIf
						EndIf
					ElseIf nTotDias > 0 .and. MesAno(aSR8[nPosIniFer]) == cPeriodo//Se não encontrou o período mas existe dias pagos (SRF vazia). Cria a linha na SRF
						RecLock( "SRF", .T. )
						SRF->RF_FILIAL	:= SRA->RA_FILIAL
						SRF->RF_MAT		:= SRA->RA_MAT
						SRF->RF_PD		:= aCodFol[891,1]
						SRF->RF_DIASDIR := nTotDiaPer
						SRF->RF_STATUS	:= If(nTotDias >= nTotDiaPer,"3","1")
						SRF->RF_DFERANT := nTotDias
						If dFerVen < nTotDias // Dias de Férias Vencidas < Total de Dias
							SRF->RF_DIASANT := nTotDias - dFerVen // Atualiza Dias Antecipados
						EndIf
						SRF->RF_DATABAS := aPerFerias[nPosAt][01]
						SRF->RF_DATAFIM := aPerFerias[nPosAt][02]
						SRF->RF_DFERVAT := aPerFerias[nPosAt][03]
						SRF->RF_DFERAAT := aPerFerias[nPosAt][04]
						SRF->RF_DVENPEN := aPerFerias[nPosAt][11]
						SRF->RF_IVENPEN := aPerFerias[nPosAt][12]
						SRF->RF_FVENPEN := aPerFerias[nPosAt][13]
						SRF->RF_DFALVAT := aPerFerias[nPosAt][15]
						SRF->RF_DFALAAT := aPerFerias[nPosAt][16]
						SRF->( MsUnLock() )
					EndIf
		 		EndIf
			EndIf
		EndIf

	ElseIf !(cPaisLoc $ "BRA") .OR. (cPaisLoc $ "BRA" .AND. !(SRA->RA_REGIME == "2")) //Não utilizado pela Folha Pública

		DbSelectArea( "SRH" )

		If SRH->( DbSeek( (cAliasSRA)->RA_FILIAL + (cAliasSRA)->RA_MAT ) )

			While ! SRH->( Eof() ) .AND. SRH->( RH_FILIAL + RH_MAT ) == (cAliasSRA)->RA_FILIAL + (cAliasSRA)->RA_MAT

				If MesAno(Iif( !(cPaisLoc $ "ARG"), SRH->RH_DATAINI, SRH->RH_DTRECIB )) == (cAnoProc + cMesProc)

					// Se houver abono pecuniario no mes corrente.
					nContFer ++
					If	SRH->RH_DFERIAS == 0 .AND. SRH->RH_DABONPE > 0 .AND. ;
						SRH->RH_DATAINI == SRH->RH_DATAFIM
						lTemAbMes	:= .T.
					EndIf

					aPerFerias	:= {}
					nTotDias	:= SRH->RH_DFERIAS + SRH->RH_DABONPE

					DbSelectArea("SRF")
					DbSetOrder(2)

					// Se recebeu todos os dias de direito, atualiza DIAS PAGOS e
					// STATUS e gera novo periodo.
					If DbSeek( SRH->RH_FILIAL + SRH->RH_MAT + aCodFol[72,1] + DtoS(SRH->RH_DATABAS) )
						nFaltas := SRH->RH_DFALTAS
						TabFaltas(@nFaltas)
						If nTotDias + nFaltas >= nTotDiaPer .OR. ;
						   nTotDias + nFaltas + SRF->RF_DFERANT >= nTotDiaPer .OR. ;
						   ( cPaisLoc=="COL" .AND. (nTotDias + SRF->RF_FERPAGA + SRF->RF_DFERANT) >= nTotDiaPer )

							RecLock( "SRF", .F. )
							SRF->RF_DFERANT += nTotDias
							If SRH->RH_DFERVEN < nTotDias //Foi antecipado valores de férias
								SRF->RF_DIASANT += nTotDias - SRH->RH_DFERVEN
							EndIf
							SRF->RF_STATUS  := "3"
							SRF->( MsUnLock() )

							dBaseAtu := SRH->RH_DBASEAT + 1

							If RCA->( DbSeek( xFilial("RCA") + "P_FERPAC" ) )
								lPerFeAc := ( AllTrim( RCA->RCA_CONTEU ) == "S" )
							EndIf

							If SRA->(Type("RA_FERPAC")) # "U" .AND. ! Empty(SRA->RA_FERPAC)
								lPerFeAc := ( AllTrim( SRA->RA_FERPAC ) == "S" )
							EndIf

							//Apura periodos posteriores ao calculado
							Calc_Fer(@aPerFerias, dDtaLimite, , , , , , , dBaseAtu)

							//Cria o periodo posterior (se ainda nao existir)
							For nX := 1 to Len(aPerFerias)
								If ! SRF->( DbSeek( SRH->RH_FILIAL + SRH->RH_MAT + aCodFol[72,1] + DtoS(aPerFerias[nX][01]) ) ) .and. SRA->RA_SITFOLH <> 'D'
									RecLock( "SRF", .T. )
									SRF->RF_FILIAL	:= SRH->RH_FILIAL
									SRF->RF_MAT		:= SRH->RH_MAT
									SRF->RF_PD		:= aCodFol[72,1]
									SRF->RF_DIASDIR := nTotDiaPer
									SRF->RF_STATUS	:= "1"
									SRF->RF_DATABAS := aPerFerias[nX][01]
									SRF->RF_DATAFIM := aPerFerias[nX][02]
									SRF->RF_DFERVAT := aPerFerias[nX][03]
									SRF->RF_DFERAAT := aPerFerias[nX][04]
									SRF->RF_DFERANT := aPerFerias[nX][14]
									SRF->RF_DVENPEN := aPerFerias[nX][11]
									SRF->RF_IVENPEN := aPerFerias[nX][12]
									SRF->RF_FVENPEN := aPerFerias[nX][13]
									SRF->RF_DFALVAT := aPerFerias[nX][15]
									SRF->RF_DFALAAT := aPerFerias[nX][16]
									SRF->( MsUnLock() )
								EndIf
							Next nX

						// Muda Periodo Quando For Ferias Coletivas Com Menos de um Ano
						ElseIf SRH->RH_TIPCAL == "C" .AND. SRH->RH_DATAINI < SRA->RA_ADMISSA + 365 .AND. cPerFeAc # "S"
							RecLock( "SRF", .F. )
							
							nFaltas := SRH->RH_DFALTAS
							TabFaltas(@nFaltas)

							If Empty(cFerAnt)
								nFerAnt			:= SRF->RF_DFERANT
								SRF->RF_DFERANT += nTotDias

								If nTotDias + nFaltas < SRH->RH_DFERVEN
									SRF->RF_DVENPEN += (SRH->RH_DFERVEN - SRH->RH_DFERIAS - nFerAnt)
									SRF->RF_IVENPEN := SRF->RF_DATABAS
									SRF->RF_FVENPEN := SRH->RH_DATAINI - 1
									SRF->RF_DFERVAT := SRH->RH_DFERVEN
									SRF->RF_DIASDIR := SRH->RH_DFERVEN
								Else
									//-- *Atendimento pontual*--
									If nTotDias == SRH->RH_DFERVEN
										//-- Se foi gerada licenca remunerada foi porque os dias pendentes ja foram
										//-- deduzidos dos dias vencidos.
										//-- Dias Pendentes: 2,5
										//-- Dias Vencidos: 2,5
										//-- Dias de Ferias: 20
										//-- Licenca remunerada: 15 (Dias Vencidos - Dias Pendentes - Dias de Ferias)
										//-- Assim, Dias Pendentes passa a ser: 0
										If SRH->RH_DIALREM > 0
											SRF->RF_DVENPEN := 0
											SRF->RF_IVENPEN := CtoD('')
											SRF->RF_FVENPEN := CtoD('')
										EndIf
										SRF->RF_DFERVAT := 0 // Dias de ferias vencidas
										SRF->RF_DFERAAT := SRF->RF_DFERANT // Dias de férias proporcionais
									ElseIf SRH->RH_DFALTAS > 0
										SRF->RF_DFERVAT := SRH->RH_DFERVEN
										SRF->RF_DFALVAT := SRH->RH_DFALTAS
										SRF->RF_DFALAAT := 0
									EndIf
									SRF->RF_STATUS := "3"
								EndIf

								SRF->RF_DATAFIM := SRH->RH_DATAINI - 1
								SRF->( MsUnLock() )

								dBaseAtu := SRH->RH_DBASEAT + 1

								// Apura periodos posteriores ao calculado
								Calc_Fer(aPerFerias, dDtaLimite, , , , , , , dBaseAtu)

								// Cria o periodo posterior (se ainda nao existir)
								For nX := 1 to Len(aPerFerias)
									If ! SRF->( DbSeek( SRH->RH_FILIAL + SRH->RH_MAT + aCodFol[72,1] + DtoS(aPerFerias[nX][01]) ) )
										RecLock( "SRF", .T. )
										SRF->RF_FILIAL	:= SRH->RH_FILIAL
										SRF->RF_MAT		:= SRH->RH_MAT
										SRF->RF_PD		:= aCodFol[72,1]
										SRF->RF_DIASDIR := nTotDiaPer
										SRF->RF_STATUS	:= "1"
										SRF->RF_DATABAS := aPerFerias[nX][01]
										SRF->RF_DATAFIM := aPerFerias[nX][02]
										SRF->RF_DFERVAT := aPerFerias[nX][03]
										SRF->RF_DFERAAT := aPerFerias[nX][04]
										SRF->RF_DFERANT := aPerFerias[nX][14]
										SRF->RF_DVENPEN := aPerFerias[nX][11]
										SRF->RF_IVENPEN := aPerFerias[nX][12]
										SRF->RF_FVENPEN := aPerFerias[nX][13]
										SRF->RF_DFALVAT := aPerFerias[nX][15]
										SRF->RF_DFALAAT := aPerFerias[nX][16]
										SRF->( MsUnLock() )
									ElseIf nTotDias < SRH->RH_DFERVEN .And. Len(aPerFerias) == 1 .And. aPerFerias[nX][01] != dBaseAtu .And. SRF->( DbSeek( SRH->RH_FILIAL + SRH->RH_MAT + aCodFol[72,1] + DtoS(aPerFerias[nX][01]) ) )
										RecLock( "SRF", .F. )
										SRF->RF_DATABAS := dBaseAtu
										SRF->RF_DATAFIM := fCalcFimAq(dBaseAtu)
										SRF->RF_DFERVAT := aPerFerias[nX][03]
										SRF->RF_DFERAAT := aPerFerias[nX][04]
										SRF->( MsUnLock() )
									EndIf
								Next nX
							Else
								SRF->RF_DFERANT += nTotDias

								If SRF->RF_DFERANT + nFaltas == SRF->RF_DFERVAT
									SRF->RF_DFERAAT := 0
									SRF->RF_VPROVAT := 0
									SRF->RF_DVENPEN := 0
									SRF->RF_STATUS	:= "3"
								EndIf
								
								SRF->( MsUnLock() )
							EndIf
						ElseIf SRF->RF_DVENPEN > 0 .And. SRF->RF_DFERANT + nTotDias == SRF->RF_DFERVAT //Encerra periodo caso esteja sendo pago dias restantes do calculo de Ferias Coletivas Com Menos de um Ano
							RecLock( "SRF", .F. )
							SRF->RF_DFERANT += nTotDias
							SRF->RF_STATUS  := "3"
							SRF->( MsUnLock() )
						// Se nao foram dados todos os dias de direito, atualiza DIAS ANTECIPADOS
						Else
							RecLock( "SRF", .F. )
							SRF->RF_DFERANT += nTotDias
							If SRH->RH_DFERVEN < nTotDias //Se foi pago mais dias do que possui, grava os dias antecipados
								SRF->RF_DIASANT += (nTotDias - SRH->RH_DFERVEN)
							EndIf
							SRF->( MsUnLock() )
						EndIf					
					EndIf
				Else

					// Se houver abono pecuniario no mes seguinte.
					If MesAno(SRH->RH_DATAINI) > (cAnoProc+cMesProc) .AND. SRH->RH_DFERIAS == 0 .AND. ;
						SRH->RH_DABONPE > 0 .AND. SRH->RH_DATAINI == SRH->RH_DATAFIM
						lTemAbMSeg	:= .T.
					EndIf

					If SRH->RH_TIPCAL == "C"
						cFerAnt := MesAno(Iif( !(cPaisLoc $ "ARG"), SRH->RH_DATAINI, SRH->RH_DTRECIB ))
					EndIf
				EndIf
				SRH->( DbSkip() )
			EndDo
		EndIf
	Endif
Return

// Actualiza SRK para chile antes de realizar cualquier movimiento en SRC/SRD
// Para campo RK_VLDNOAPL
/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³UpdSRKCHI ³ Autor ³ Mayra Camargo     	³ Data ³ 09/12/13 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Limpia campo RK_VNAOAPL							          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³Pais Chile												  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function UpdSRKCHI( cFilSRA,aNextPer, aNextComp )

Local cSRKTab := getNextAlias()
Local nReg := 0
Local aArea:= GetArea()

#IFDEF TOP

	Local cOrder		:= ""
	Local cWhere		:= ""

#ENDIF


DEFAULT aNextPer   := {}
DEFAULT aNextComp  := {}

Begin Sequence

		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³ Configuracao para TOP para SRK                               ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		#IFDEF TOP

			cWhere := "%"
			cWhere += " SRK.RK_FILIAL  = '" + cFilSRA + "' AND "
			cWhere += " SRK.RK_MAT 	   = '" + (cAliasSRA)->RA_MAT + "' AND SRK.RK_STATUS='2' "
			cWhere += "%"

			cOrder := "% SRK.RK_FILIAL, SRK.RK_MAT %"

			cFromTable := "% "+RetSqlName("SRK")+" SRK %"

			BeginSql alias cSRKTab
				column RK_DTVENC as Date, RK_DTMOVI as Date
				SELECT
						%exp:cFieldsSRK%
				FROM
						%exp:cFromTable%
				WHERE
					 	%exp:cWhere%
					 	AND SRK.%NotDel%
				ORDER BY
						%exp:cOrder%

			EndSql


		#ENDIF

		While ( cSRKTab )->( !Eof() ) .and. ( cSRKTab )->RK_FILIAL == cFilSRA .and. ( cSRKTab )->RK_MAT == ( cAliasSRA )->RA_MAT

			#IFDEF TOP
				nreg := (cSRKTab)->( R_E_C_N_O_ )
			#ELSE
				nreg := (cSRKTab)->( Recno() )
			#ENDIF

			IF nReg > 0
				SRK->( dbGoto(nReg) )
				RecLock("SRK",.F.)
					SRK->RK_VNAOAPL := 0
				SRK->(MsUnlock())
			EndIF

			(cSRKTab )->( DbSkip() )

		EndDo

End Sequence

#IFDEF TOP
	If ( Select( cSRKTab ) > 0 )
		( cSRKTab )->( dbCloseArea() )
	EndIf
#ENDIF

RestArea(aArea)
Return
/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³UPDRG1CHI ³ Autor ³ Mayra Camargo     	³ Data ³ 09/12/13 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Limpia campo RG1_VNAOAPL							          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³Pais Chile												  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßß
*/
Static Function UPDRG1CHI(cMatSRA)
	Local aArea := getArea()
	Local cTabRG1 := GetNextAlias()

	BeginSQL ALIAS cTabRG1
		select R_E_C_N_O_ AS RECNUM
		FROM %Table:RG1%
		where RG1_MAT= %EXP:cmatSRA%
		and RG1_FILIAL=%EXP:XfILIAL("rg1")%
		AND %notDel%
	EndSQL

	While ( cTabRG1 )->( !Eof() )
		dbSelectArea("RG1")
		RG1->( dbGoto(( cTabRG1 )->RECNUM) )
		RecLock("RG1",.F.)
		RG1->RG1_VNAOAP := 0
		RG1->( MsUnlock())
		( cTabRG1 )->( dbSkip() )
	EndDo

	( cTabRG1 )->( dbCloseArea() )
	RestArea(aArea)

Return
/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³fGenPropChi³ Autor³ Mayra Camargo     	³ Data ³ 09/12/13 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Proporcionales para Chile							          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³Pais Chile												  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßß
*/
Static function fGenPropCh()

Local nDias360  := 0
Local nAnoFcIni := 0
Local nAnoFcFin := 0
Local nAnoTotal := 0
Local nMesFcIni := 0
Local nMesFcFin := 0
Local nMesTotal := 0
Local nDayFcIni := 0
Local nDayFcFin := 0
Local nDayTotal := 0
Local nPropDias := 0
Local cTipoCale := "2"

Local dFchIni := CTOD("//") 
Local dFchFin := CTOD("//") 


IF cPaisLoc ="PER"
       cTipoCale := RCJ->RCJ_DIACAL
ElseIf cPaisLoc ="PAR"
       cTipoCale :=IIf (RCJ->RCJ_CALEND =="1", "2", "1")
EndIf

If cTipoCale == "2"

		dFchIni :=  SRF->RF_DATABAS
		dFchFin :=  RCH->RCH_DTFIM

		//Año
		nAnoFcIni := YEAR(dFchIni)
		nAnoFcFin := YEAR(dFchFin)
		
		//Mes
		nMesFcIni := MONTH(dFchIni)
		nMesFcFin := MONTH(dFchFin)
		
		//Día
		nDayFcIni := DAY(dFchIni)
		nDayFcFin := DAY(dFchFin)
		
		nDayFcIni := If(nDayFcIni>30, 30, Iif(nMesFcIni == 2 .And. (nDayFcIni == 28 .OR. nDayFcIni == 29), 30, nDayFcIni))
		nDayFcFin := If(nDayFcFin>30, 30, Iif(nMesFcFin == 2 .And. (nDayFcFin == 28 .OR. nDayFcFin == 29), 30, nDayFcFin))
		
		nDayTotal := nDayFcFin - nDayFcIni + 1  //13 - 01 = 12
	
		If  nDayTotal < 0  //Días en negativo
		    nDayFcFin += 30
		    nDayTotal := nDayFcFin - nDayFcIni + 1
		    nMesFcFin -= 1
		Endif
	
	
		nMesTotal := nMesFcFin - nMesFcIni  //01 - 10 = -09
		
		If  nMesTotal < 0  //Días en negativo
		    nMesFcFin += 12
		    nMesTotal := nMesFcFin - nMesFcIni
		    nAnoFcFin -= 1
		Endif
		
		nAnoTotal := nAnoFcFin - nAnoFcIni  //2020 - 2007 = 13
		
		nDias360 := nDayTotal + ( nMesTotal * 30) + (nAnoTotal * 360)
	
	
		nPropDias := nDias360  *((SRF->RF_DIASDIR/12)/ 30)


	Else
	
		nPropDias := (SRF->RF_DIASDIR / 365) * ( (RCH->RCH_DTFIM - SRF->RF_DATABAS ) + 1 )
	
	 
	
	EndIf



Return nPropDias

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³fPrescSRF ³ Autor ³ Mayra Camargo     	³ Data ³ 09/12/13 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Preescripción de registros en SRF					          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³Pais Chile												  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static function fPrescSRF(cFilSRA)
	Local aArea := GetArea()
	Local cAliasQry 	:= ""
	Local cFilSRF		:= Space(FWGETTAMFILIAL)
	Local lPresc 		:= RCJ->RCJ_VIGVAC <> 0//X3USO("RCJ_VIGVAC")
	Local dYearFinPeriod := RCH->RCH_DTFIM

	If FWModeAccess("SRF") == "C"
		cFilSRF := Space(FWGETTAMFILIAL)
	Else
		cFilSRF:= cFilSra
	EndIf

	//lPresc := iif(lPresc, RCJ->RCJ_VIGVAC <> 0, .F.)

	If lPresc
		cAliasQry := GetNextAlias()

		cOrder := "%"
		cOrder += " SRF.RF_FILIAL, SRF.RF_MAT, SRF.RF_PD, SRF.RF_DATABAS "
		cOrder += "%"

		cWhere := "%"
		cWhere += " SRF.RF_FILIAL = '" + cFilSRF				+ "' AND "
		cWhere += " SRF.RF_MAT    = '" + SRA->RA_MAT			+ "' AND "
		cWhere += " SRF.RF_DATAFIM <= '" + DTOS(RCH->RCH_DTFIM) 		+ "' AND "
		cWhere += " SRF.RF_STATUS <> '2' AND "
		cWhere += "%"

		BeginSql alias cAliasQry
			SELECT 		SRF.R_E_C_N_O_ NRECNO, SRF.RF_FILIAL, SRF.RF_MAT, SRF.RF_DATAFIM,
						SRF.RF_STATUS, SRF.RF_DATABAS
			FROM 		%table:SRF% SRF
			WHERE 		%exp:cWhere%
						SRF.%NotDel%
			ORDER BY   %exp:cOrder%
		EndSql

		(cAliasQry)->(dbgotop())

		While ((cAliasQry)->(!Eof()) .AND. ((cAliasQry)->RF_FILIAL + (cAliasQry)->RF_MAT)==(cFilSRF + SRA->RA_MAT))

				/*
				ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				³Calcula o tempo que passou desde o vencimento do dias de dir³
				³ate a data final do periodo posicionado, se a quantidade    ³
				³resultante for maior que o configurado em RCJ entao o per.  ³
				³de dias de direito sera prescrito.                          ³
				ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				*/
				dDatePresc := fDtPresc(RCJ->RCJ_VIGVAC,STOD((cAliasQry)->(RF_DATAFIM)),RCH->RCH_DTFIM)
				If dYearFinPeriod >= dDatePresc .And. (cAliasQry)->RF_STATUS != "3"
					If ( (cAliasQry)->NRECNO <> 0 )
						SRF->(dbGoTo((cAliasQry)->NRECNO))
						RecLock("SRF", .F.)
						SRF->RF_STATUS := "2" //Prescrito
						SRF->(MsUnlock())
					EndIf
				EndIf
				(cAliasQry)->(dbSkip())
		EndDo
	EndIf
	RestArea(aArea)
Return
/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³fDtPresc  ³ Autor ³ Mayra Camargo         ³ Data ³ 09/12/13 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Calcula la fecha de preescripción de un registro en SRF     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³nVigVac  	 := RCJ->RCJ_VIGVAC                               ³±±
±±³          ³dBsLastVac := SRF->RF_DATAFIM                               ³±±
±±³          ³dYearFinPeriod := RCH->RCH_DTFIM                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function fDtPresc(nVigVac,dBsLastVac,dYearFinPeriod)

	Local dRet 		:= CTOD(" / / ")
	Local nVigencia	:= 0
	Local nAnios	:= 0
	Local cFec		:= ""
	Local nFecDif	:= 0
	Local nDecimal := 0

	Default nVigVac		:= RCJ->RCJ_VIGVAC
	Default dBsLastVac		:= SRF->RF_DATAFIM
	Default dYearFinPeriod := RCH->RCH_DTFIM

	nVigencia := int(nVigVac)
	nDecimal  := abs(nVigencia  - nVigVac)
	nAnios 	  := Year(dBsLastVac) + Int(nVigencia)
	nFecDif	  := CTOD("31/12/"+ STR(nAnios)) - CTOD("01/01/"+ STR(nAnios)) + 1
	cFec	  := STOD(STRZERO(nAnios,4)	+ STRZERO(MONTH(dBsLastVac),2) +  STRZERO(DAY(dBsLastVac), 2))
	dRet 	  := cFec + (nDecimal * nFecDif)
Return dRet


/*/{Protheus.doc} fVldPd
Verifica se existem verbas de férias mês seguinte que estão com campo RV_REFFER com "não"
@author Leandro.Drumond
@since 01/02/17
@version 1.0
@return lRet, Lógica, .T. se deve prosseguir com o processamento
/*/
Static Function fVldPd()
Local lRet 		:= .T.
Local cAliasQry	:= GetNextAlias()
Local aLogItens	:= {}

BeginSql alias cAliasQry
	SELECT SRV1.RV_FILIAL AS FILIAL, SRV1.RV_COD AS COD1, SRV1.RV_DESC AS DESC1, SRV2.RV_COD AS COD2, SRV2.RV_DESC AS DESC2
	FROM %table:SRV% SRV1
	INNER JOIN %table:SRV% SRV2
	ON SRV1.RV_FILIAL = SRV2.RV_FILIAL AND SRV2.RV_COD = SRV1.RV_CODMSEG
	WHERE SRV1.RV_CODMSEG <> '' AND SRV2.RV_REFFER = 'S' AND SRV1.RV_REFFER <> 'S' AND SRV1.%NotDel% AND SRV2.%NotDel%
	ORDER BY SRV1.RV_COD
EndSql

If (cAliasQry)->( !Eof() )
	Do While (cAliasQry)->( !Eof() )
		If !Empty((cAliasQry)->(FILIAL))
			If Empty(aLogItens)
				aAdd(aLogItens,STR0106)//"As seguintes verbas estão configuradas como 'Verba de Mês Seguinte' de verbas de férias porém a sua referência para férias (RV_REFFER) está como 'Não'"
				aAdd(aLogItens,"")
				aAdd(aLogItens,Padr(STR0107,TAMSX3("RV_FILIAL")[1]) + Space(3) + Padr(STR0108,TAMSX3("RV_COD")[1]+3+TAMSX3("RV_DESC")[1]+3) +  Padr(STR0109,TAMSX3("RV_COD")[1]+3+TAMSX3("RV_DESC")[1]+3))
			EndIf
			aAdd(aLogItens,(cAliasQry)->(FILIAL + Space(3) + COD1 + " - " + DESC1 + Space(3) + COD2 + " - " + DESC2 ))
		Else
			If Empty(aLogItens)
				aAdd(aLogItens,STR0106)
				aAdd(aLogItens,"")
				aAdd(aLogItens,Padr(STR0108,TAMSX3("RV_COD")[1]+3+TAMSX3("RV_DESC")[1]+3) +  Padr(STR0109,TAMSX3("RV_COD")[1]+3+TAMSX3("RV_DESC")[1]+3))
			EndIf
			aAdd(aLogItens,(cAliasQry)->(COD1 + " - " + DESC1 + Space(3) + COD2 + Space(3) + DESC2 ))
		EndIf
		(cAliasQry)->( DbSkip() )
	EndDo
	MsAguarde( { || fMakeLog( {aLogItens},{} , "GPEM120" , NIL , FunName() , STR0025 ) } ,  STR0025 ) // "Log de Ocorrencias no Fechamento de Periodo"
	If !MsgYesNo( STR0110 ) //"Deseja prosseguir com o fechamento? "
		lRet := .F.
	EndIf
EndIf

(cAliasQry)->(dbCloseArea())

Return lRet

/*/{Protheus.doc} fVerAdiAnt
Verifica se existe roteiro de adiantamento no período anterior
@author Leandro.Drumond
@since 28/06/17
@version 1.0
@return lRet, Lógica, .T. se deve prosseguir com o processamento
/*/
Static Function fVerAdiAnt(cFil,cProc,cRot)
Local aArea		:= GetArea()
Local nPos		:= 0
Local lRet		:= .F.
Local lTemFec	:= .F.
Local lBlind	:= IsBlind()

DbSelectArea("RCH")
RCH->(DbSetOrder(4)) //RCH_FILIAL+RCH_PROCES+RCH_ROTEIR+RCH_PER+RCH_NUMPAG

//Posiciona no último período fechado
If RCH->(DbSeek(cFil + cProc + cRot))
	While !(RCH->( EOF() )) .And. !(Empty(RCH_DTFECH))
		lTemFec := .T.
		RCH->(DbSkip())
	EndDo
EndIf

If lTemFec
	RCH->(DbSkip(-1))
	cPerAux := RCH->RCH_PER
	If RCH->(DbSeek(cFil + cProc + fGetCalcRot("2")+ cPerAux))
		lRet := .T.
	EndIf
Else
	If (nPos := aScan(aProcRet,{|x| x[1] == cProc})) == 0
		lRet := !lBlind .And. !lSegPlan .AND. !MsgYesNo(STR0114 + cProc + ". " + STR0036) //"Não foi encontrado roteiro de adiantamento para o próximo período do processo " Deseja Continuar?
		aAdd(aProcRet,{cProc,lRet})
	Else
		lRet := aProcRet[nPos,2]
	EndIf
EndIf

RestArea(aArea)

Return lRet

/*/{Protheus.doc} fVincSQG
Desvincula o funcionário do currículo caso haja rescisão no mês
@author Gabriel A.
@Since 21/09/2017
@version 1.0
@param cFil Filial do funcionário
@param cMat Matrícula do funcionário
/*/
Static Function fVincSQG()
	Local cCurriculo := ""
	Local aArea      := GetArea()
	Local cAliasQry  := GetNextAlias()
	Local cFilSQG    := ""

	BeginSql Alias cAliasQry
		SELECT SQG.QG_FILIAL,SQG.QG_CURRIC,SQG.QG_FILMAT,SQG.QG_MAT,SRG.RG_PERIODO
		FROM %Table:SQG% SQG
			INNER JOIN %Table:SRG% SRG ON SRG.RG_FILIAL = SQG.QG_FILMAT AND SRG.RG_MAT = SQG.QG_MAT
		WHERE
			SRG.RG_PERIODO = %Exp:cPeriodo% AND
			SQG.%NotDel% AND
			SRG.%NotDel%
	EndSql

	DbSelectArea("SQG")
	SQG->( DbSetOrder(1) )

	While !( (cAliasQry)->(EOF()) )
		cCurriculo := (cAliasQry)->QG_CURRIC
		cFilSQG    := (cAliasQry)->QG_FILIAL

		If SQG->( DbSeek(cFilSQG + cCurriculo) )
			RecLock("SQG",.F.)
			SQG->QG_FILMAT := ""
			SQG->QG_MAT := ""
			SQG->( MsUnlock() )
		EndIf

		(cAliasQry)->(DbSkip())
	EndDo

	SQG->( DbCloseArea() )
	(cAliasQry)->( DbCloseArea() )
	RestArea(aArea)
Return


/*/{Protheus.doc} fVerFerMes
Verifica se funcionário esteve de férias no mês
@author Leandro Drumond
@Since 28/11/2018
@version 1.0
/*/
Static Function fVerFerMes()
Local aArea	:= GetArea()
Local lRet	:= .F.

DbSelectArea("SRR")
SRR->(DbSetOrder(4)) //RR_FILIAL+RR_MAT+RR_PERIODO+RR_ROTEIR+RR_SEMANA+RR_PD+RR_CC+RR_SEQ+DTOS(RR_DATA)

//Se funcionário retornou de férias e teve outro tipo de afastamento no mesmo mês, a situação não estará "F", por isso verifica se ele esteve de férias no mês
If DbSeek(SRA->RA_FILIAL + SRA->RA_MAT + cPeriodo + fGetCalcRot("3"))
	lRet := .T.
EndIf

RestArea(aArea)

Return lRet

/*/{Protheus.doc} fGetValAnt
Obtem soma das semanas anteriores de determinada verba e competencia
@author Leandro Drumond
@Since 28/11/2018
@version 1.0
/*/
Static Function fGetValAnt(cPd, cPer, cRot, cSem, cData)
Local cKey  := (cAliasSRA)->RA_FILIAL + (cAliasSRA)->RA_MAT + cPer + cPd
Local cProc := (cAliasSRA)->RA_PROCES
Local nRet  := 0

SRD->(DbSetOrder(1)) //RD_FILIAL+RD_MAT+RD_DATARQ+RD_PD+RD_SEMANA+RD_SEQ+RD_CC

If SRD->(DbSeek(cKey))
	While SRD->(!Eof() .and. RD_FILIAL+RD_MAT+RD_DATARQ+RD_PD == cKey)
		If SRD->RD_PROCES == cProc .and. SRD->RD_ROTEIR == cRot .and. SRD->RD_SEMANA <> cSem .and. AnoMes(SRD->RD_DATPGT) == cData
			nRet += SRD->RD_VALOR
		EndIf
		SRD->(DbSkip())
	EndDo
EndIf

Return nRet

/*/{Protheus.doc} NoExisSRC
Verifica se existen registros en la SRC. Validaci¥n localizada para Paraguay.
@author Laura Medina (lmedina.qro)
@since 26/12/20
@version 1.0
@return lRet, L¥gica, .T. se deve prosseguir com o processamento
/*/
Static Function NoExisSRC()
Local aArea		:= GetArea()
Local lRet      := .F. 
Local nCountSRA := 0  
Local cAliasQry	:= GetNextAlias()

BeginSql alias cAliasQry
	SELECT COUNT(*) CONTADOR
	FROM	%table:SRA% SRA,%table:SRC% SRC
	WHERE  SRA.RA_FILIAL = SRC.RC_FILIAL AND SRA.RA_MAT = SRC.RC_MAT AND 
		SRC.RC_PERIODO = %exp:cPeriodo% AND SRC.RC_SEMANA = %exp:cNumPag% AND SRC.RC_ROTEIR = %exp:cRoteiro% AND
		SRC.RC_PROCES  = %exp:cProcesso% AND
		SRA.%NotDel% AND SRC.%NotDel%
EndSql
 
If (cAliasQry)->(!Eof())
	nCountSRA := (cAliasQry)->(CONTADOR)
EndIf

If  nCountSRA>0
	lRet    := .T. 
Endif

RestArea(aArea)
			
Return lRet

/*/{Protheus.doc} EsVlrNoApl
Verifica se existen registros en la SRM para aplicar a Valores Futuros
@author Laura Medina (lmedina.qro)
@since 10/02/20
@version 1.0
@param 		cSRMPD		Caracter	Concepto a ser procesado.    
@return lRet, L¥gica, .T. se deve prosseguir com o processamento
/*/
Static Function EsVlrNoApl(cSRMPD)
Local aArea		:= GetArea()
Local lRet      := .F. 
Local cAliasQry	:= GetNextAlias()
Local cFilSRM   := xFilial("SRM")
Local cEsVlrSI  := '1'
Local cEsVlrNO  := '2'
Local nCountSRM := 0

BeginSql alias cAliasQry
	SELECT COUNT(*) CONTADOR
	FROM	%table:SRM% SRM
	WHERE SRM.RM_VERBA = %exp:cSRMPD% 
	AND SRM.RM_CALCULO = %exp:cRoteiro% 
	AND SRM.RM_PROCES  = %exp:cProcesso% 	
	AND (SRM.RM_LEEINC = %exp:cEsVlrSI% 
		OR (SRM.RM_LEEINC = %exp:cEsVlrNO% 
			AND SRM.RM_LEEPRE = %exp:cEsVlrNO% 
			AND SRM.RM_LEEAUS = %exp:cEsVlrNO% 
			AND SRM.RM_LEEBEN = %exp:cEsVlrNO% 
			AND SRM.RM_LEEFIX = %exp:cEsVlrNO%) )  
	AND SRM.%NotDel%
	AND SRM.RM_FILIAL  = %exp:cFilSRM% 
EndSql
 
If (cAliasQry)->(!Eof())
	nCountSRM := (cAliasQry)->(CONTADOR)
EndIf

If  nCountSRM>0
	lRet    := .T. 
Endif
		
RestArea(aArea)
	
Return lRet

/*/{Protheus.doc} fBeneficia
Verifica si el concepto en la SRM aplica para Beneficiarios ("RM_LEEBEN")
@author Laura Medina (lmedina.qro)
@since 17/02/20
@version 1.0
@param 		cFilSRC		Caracter	Filial del empleado en proceso.
@param 		cMatSRC		Caracter	Matricula del empleado en proceso.
@param 		nValor		Numerico	Valor campo RC_VNAOAPL. 
@param 		cRCProc		Caracter	Matricula del empleado en proceso. 
@param 		cRCRoter	Caracter	Matricula del empleado en proceso.  
@param 		cRCPD		Caracter	Concepto a ser procesado. 
@return		No aplica
/*/
Static Function fBeneficia(cFilSRC, cMatSRC, nValor, cRCProc, cRCRoter, cRCPD)
Local aArea		:= GetArea()
Local cAliasQry	:= GetNextAlias()

If  POSICIONE("SRM",3,xFilial("SRM")+cRCProc+cRCRoter+cRCPD,"RM_LEEBEN") == "1"

	BeginSql alias cAliasQry
		SELECT  SRQ.R_E_C_N_O_ NRECNO
		FROM	%table:SRQ% SRQ
		WHERE SRQ.RQ_VERBFOL = %exp:cRCPD% 
		AND SRQ.RQ_FILIAL  = %exp:cFilSRC% 
		AND SRQ.RQ_MAT = %exp:cMatSRC% 	  
		AND SRQ.%NotDel%	
	EndSql   
    
	If  (cAliasQry)->( !Eof() )
		If ((cAliasQry)->NRECNO != 0)
			SRQ->(dbGoTo((cAliasQry)->NRECNO))
			RecLock("SRQ", .F.)
			SRQ->RQ_VNAOAPL := nValor
			SRQ->( MsUnLock() )
		Endif 
	EndIf
            
Endif

RestArea(aArea)
Return

/*/{Protheus.doc} fGravaRJB()
Função para gravação da tabela RJB
@type      	Function
@author   	lidio.oliveira
@since		20/02/2020
@version	1.0
/*/

Static Function fGravaRJB()

If ChkFile("RJB") .and. ChkFile("RJC") // se existem as tabelas RJB e RJC, continua com o processamento

	RJB->(DbSetOrder(2)) //RJB_FILIAL+RJB_CODIGO+RJB_FCHAVE+RJB_CHAVE
	RecLock("RJB", .T.)
		RJB->RJB_FILIAL 	:= Fwxfilial('RJB')
		RJB->RJB_CODIGO 	:= GetSx8Num("RJB", "RJB_CODIGO")
		RJB->RJB_EVENT  	:= "S2205"
		RJB->RJB_TIPO		:= "3" //Atualização de dependentes
		RJB->RJB_STATUS		:= "0" //Pendente
		RJB->RJB_FCHAVE 	:= Fwxfilial('SRB')
		RJB->RJB_CHAVE		:= SRB->RB_MAT
		RJB->RJB_DTINC		:= dDataBase

	MsUnLock()
	ConfirmSx8()
Endif

Return

/*/{Protheus.doc} GetSRHIni
Retorna data inicio das ferias
@author Flavio Correa
@since 24/04/2020
@version 1.0
/*/
Static Function GetSRHIni(dDtPg,nQtd)
Local aArea  := GetArea()
Local dDtIni := CTOD("  /  /  ")
Local nPos   := 0

DbSelectArea( "SRH" )
SRH->(dbSetOrder(1))

If SRH->( DbSeek( SRA->RA_FILIAL + SRA->RA_MAT ) )
	While ! SRH->( Eof() ) .AND. SRH->( RH_FILIAL + RH_MAT ) == SRA->RA_FILIAL + SRA->RA_MAT
		If SRH->RH_DTRECIB == dDtPg
			nPos := Ascan(aFerPag,{|x| x[1] == SRH->RH_DATAINI})
			If nPos == 0 .Or. ( nPos > 0 .And. aFerPag[nPos][2] + nQtd <= SRH->RH_DFERIAS )
				dDtIni	:= SRH->RH_DATAINI
				Exit
			EndIf
		EndIf
		SRH->( dbSkip() )
	EndDo
EndIf

RestArea(aArea)

Return dDtIni

/*/{Protheus.doc} GrvVacPag
Actualiza días pagados en control de días derecho
@author Luis Eduardo Enríquez Mata
@Since 26/01/2021
@version 1.0
/*/
Static Function UpdVacPag()
	Local aArea   := GetArea()
	Local cFilSRF := xFilial("SRF")
	Local cIDVac  := aCodFol[72,1]
	Local nDias   := 0
	Local nDiff   := 0

	If nVacPag > 0
		DbSelectArea("SRF")
		DbSetOrder(2) //RF_FILIAL + RF_MAT + RF_PD + DTOS(RF_DATABAS) 

		If SRF->(DbSeek(cFilSRF + SRA->RA_MAT + cIDVac))
			While SRF->(!EOF()) .And. SRF->(RF_FILIAL + RF_MAT + RF_PD) == cFilSRF + SRA->RA_MAT + cIDVac .And. nVacPag > 0
				If SRF->RF_STATUS == "1"
					If SRF->RF_DFERVAT == 0
						nDiff := SRF->RF_DIASDIR //Cantidad Referencia del Periodo
					Else
						nDiff := SRF->RF_DFERVAT //Días Vencidos
					EndIf
					If nVacPag + SRF->RF_DFERANT > nDiff
						nDias := nDiff - SRF->RF_DFERANT
					Else
						nDias := nVacPag
					EndIf
					nVacPag -= nDias
					RecLock("SRF",.F.)
						SRF->RF_DFERANT += nDias
						If SRF->RF_DFERANT == SRF->RF_DFERVAT
							SRF->RF_STATUS := "3"
						EndIf	
					SRF->(MsUnlock())
				EndIF
				SRF->(dbSkip())
			EndDo
		EndIf
	EndIf
	RestArea(aArea)
Return Nil

/*/{Protheus.doc} fAtuFlagIC
Atualiza o campo RG_CONFIC no fechamento da rescisão
@author Allyson Mesashi
@since 10/02/2021
/*/
Static Function fAtuFlagIC(cFilSRA, cMatSRA)

Local cAliasSRG	:= GetNextAlias()
Local cFilter 	:= ""
Local cSet 		:= ""
Local cSRGSqlName
Local cQuery
Local cQueryUPD

If ( Select( cAliasSRG ) > 0 )
	( cAliasSRG )->( dbCloseArea() )
EndIf

cSRGSqlName := InitSqlName( "SRG" )

cQuery 	:= "UPDATE " + cSRGSqlName
cSet	:= " SET RG_CONFIC = '3'"
cFilter := " WHERE RG_FILIAL = '" + cFilSRA  + "'"
cFilter += " AND RG_MAT = '" + cMatSRA + "'"
cFilter += " AND RG_PROCES = '" + cProcesso  + "'"
cFilter += " AND RG_PERIODO = '" + cPeriodo + "'"
cFilter += " AND RG_SEMANA = '" + cNumPag  + "'"
cFilter += " AND RG_EFETIVA = 'S'"
cFilter += " AND RG_CONFIC = '4'"
cFilter += " AND D_E_L_E_T_ = ' '"

cQueryUPD := ( cQuery + cSet + cFilter )

TcSqlExec( cQueryUPD )

Return

/*/{Protheus.doc} fOrdAvalSR8
Ajusta posiçao correta da Ordem conforme aAllSR8
@author Emerson Grassi
@since 17/05/2021
/*/
Static Function fOrdAvalSR8(aValSR8, cPdFerias, nPosNumID, nPosPd)

Local cCod 			:= ""
Local nY 			:= 0
Local nPos 			:= 0	

If Len(aValSR8) > 1 .And. nPosNumID > 0 .And. nPosPd > 0
	For nY := 1 to Len(aValSR8)
		If aValSR8[nY,1] == ""
			cCod := cPdFerias
		Else
			cCod := Substr(aValSR8[nY,1],10,3)
		Endif
		nPos := Ascan( aAllSR8, { |x| Iif( !Empty(aValSR8[nY, 1]), x[nPosNumID] == aValSR8[nY,1], x[nPosPd] == cCod )} )
		If nPos > 0
			aValSR8[nY,2] := nPos
		EndIf
	Next nY
EndIF
Return

/*/{Protheus.doc} fVldFerDob()
Efetua validação de férias em dobro e programação automática de férias
@author Allyson Luiz Mesashi
@since 01/08/2022
/*/
Static Function fVldFerDob( aLogPrgF )

Local aArea				:= GetArea()
Local aAreaSRF			:= SRF->( GetArea() )
Local aAreaSRH			:= SRH->( GetArea() )
Local cCmpData			:= ""
Local cCmpDias			:= ""
Local dDtIniAux			:= cToD("//")
Local lProg1 			:= .T.
Local lProg2 			:= .T.
Local lProg3 			:= .T.
Local nCalcFer			:= 0
Local nDDobro			:= 0
Local nDescFal			:= aPerFerias[1, 15]//RF_DFALVAT
Local nProgFer			:= 0
Local nSaldoFer			:= 0

TabFaltas(@nDescFal)

SRF->( dbGoTo( aPerFerias[1, 30] ) )
If !Empty(SRF->RF_DATAINI) 
	lProg1 := .F.
	If SRF->RF_DATAINI > dDtaLimite
		nProgFer 	+= SRF->RF_DFEPRO1 + SRF->RF_DABPRO1
		dDtIniAux 	:= SRF->RF_DATAINI + SRF->RF_DFEPRO1 + SRF->RF_DABPRO1 + 1
	EndIf
EndIf
If !Empty(SRF->RF_DATINI2) 
	lProg2 := .F.
	If SRF->RF_DATINI2 > dDtaLimite
		nProgFer 	+= SRF->RF_DFEPRO2 + SRF->RF_DABPRO2
		dDtIniAux 	:= SRF->RF_DATINI2 + SRF->RF_DFEPRO2 + SRF->RF_DABPRO2 + 1
	EndIf
EndIf
If !Empty(SRF->RF_DATINI2) 
	lProg3 := .F.
	If SRF->RF_DATINI3 > dDtaLimite
		nProgFer 	+= SRF->RF_DFEPRO3 + SRF->RF_DABPRO3
		dDtIniAux 	:= SRF->RF_DATINI3 + SRF->RF_DFEPRO3 + SRF->RF_DABPRO3 + 1
	EndIf
EndIf

SRH->( dbSetOrder(1) )
If SRH->( dbSeek( SRA->RA_FILIAL+SRA->RA_MAT+dToS(aPerFerias[1, 1]) ) )
	While SRH->( !Eof() ) .And. SRH->RH_FILIAL+SRH->RH_MAT+dToS(SRH->RH_DATABAS) == SRA->RA_FILIAL+SRA->RA_MAT+dToS(aPerFerias[1, 1])
		If AnoMes(SRH->RH_DATAINI) > AnoMes(dDtaLimite)
			If Empty(dDtIniAux) .Or. (SRH->RH_DATAINI + SRH->RH_DFERIAS + SRH->RH_DABONPE + 1) > dDtIniAux
				nCalcFer 	+= SRH->RH_DFERIAS + SRH->RH_DABONPE
				dDtIniAux 	:= SRH->RH_DATAINI + SRH->RH_DFERIAS + SRH->RH_DABONPE + 1
			EndIf
		EndIf
		SRH->( dbSkip() )
	EndDo
EndIf

nSaldoFer := (aPerFerias[1, 3] - nDescFal - aPerFerias[1, 14] - nCalcFer - nProgFer)//RF_DFERVAT - Faltas - RF_DFERANT - Dias calculados - Dias programados

If nSaldoFer > 0
	SetMemVar("RH_DATAINI", (dDtaLimite + P_FDOBVLD), .T.)
	fDiasDobra(@nDDobro, 0, Nil, nSaldoFer, aPerFerias[1, 1], (dDtaLimite + P_FDOBVLD), (dDtaLimite + P_FDOBVLD + nSaldoFer - 1))
	If nDDobro > 0
		cCmpData 	:= Iif( lProg1, "RF_DATAINI", Iif(lProg2, "RF_DATINI2", "RF_DATINI3"))
		cCmpDias 	:= Iif( lProg1, "RF_DFEPRO1", Iif(lProg2, "RF_DFEPRO2", "RF_DFEPRO3"))
		If Empty(dDtIniAux)
			dDtIniAux	:= dDtaLimite+P_FDOBPRG
		EndIf
		fVerIniAux( @dDtIniAux )
		If SRF->( RecLock("SRF", .F.) )
			SRF->( &(cCmpData) ) := dDtIniAux
			SRF->( &(cCmpDias) ) := nSaldoFer
			SRF->( MsUnLock() )
		EndIf
		aAdd( aLogPrgF[1], STR0124 + SRA->RA_FILIAL+SRA->RA_MAT + STR0125 + dToC(SRF->RF_DATABAS) + STR0126 + dToC(dDtIniAux) + STR0127 + cValToChar(nSaldoFer) )//"Filial + Matrícula: "|" | Período aquisitivo: "|" | Data programada: "|" | Dias programados: "
	EndIf
EndIf

RestArea( aAreaSRF )
RestArea( aAreaSRH )
RestArea( aArea )

Return

/*/{Protheus.doc} fVerIniAux()
Efetua validação do início ideal das férias
@author Allyson Luiz Mesashi
@since 01/08/2022
/*/
Static Function fVerIniAux( dDtIni )

Local dDtAux	:= dDtIni
Local dDtBkp	:= dDtIni
Local lDSR 		:= .F.
Local lFer 		:= .F.
Local nVezes	:= 1

While nVezes <= 7
	lDSR	:= !Empty( fVldDSR(SRA->RA_FILIAL, SRA->RA_MAT, dDtAux, 2, "D") )
	lFer	:= !Empty( fVldDSR(SRA->RA_FILIAL, SRA->RA_MAT, dDtAux, 2, "F") ) 
	If !lFer .And. !lDSR
		dDtIni := dDtAux
		Exit
	EndIf
	dDtAux += 1
	nVezes++
EndDo

If nVezes > 7
	dDtIni := dDtBkp
EndIf

Return


/*/{Protheus.doc} fRetSR8()
Retorna Data de Retorno do Ultimo Afastamento do funcionário
@author Emerson Grassi Rocha
@since 30/09/2022
/*/
Static Function fRetSR8()

Local aArea 	:= GetArea()
Local dDataFim 	:= Ctod('')

dbSelectArea("SR8")
SR8->( dbSetOrder(1) )
If SR8->( dbSeek(SRA->RA_FILIAL + SRA->RA_MAT) )
	While SR8->( !Eof() ) .And. ( SRA->RA_FILIAL+SRA->RA_MAT == SR8->R8_FILIAL+SR8->R8_MAT )
		dDataFim := SR8->R8_DATAFIM
		SR8->( DbSkip() )
	EndDo
EndIf

RestArea(aArea)

Return(dDataFim)

/*/{Protheus.doc} GP120ProgReaj()
Efetiva programação de reajuste salarial
@author Leandro Drumond
@since 25/11/2022
/*/
Static Function GP120ProgReaj(aFuncProg)

Local aArea 		:= GetArea()
Local aStru  		:= {}
Local aLstIndices	:= {}
Local aColumns		:= {}
Local aPesq			:= {}
Local aLogAux 		:= {}
Local cAliasTRB
Local nX 			:= 0
Local nOpcX			:= 0
Local oFont         := TFont():New('Arial',,-16,,.T.)
Local oSize
Local oTela
Local oDlgGrid
Local oPanel
Local oMark
Local oArqTmp

Private lGpAltSal	:= ExistBlock( "GPALTSAL" )
Private lCs080Grv 	:= ExistBLock("CSA080GRV")
Private lTSREP		:= SuperGetMv( "MV_TSREP" , NIL , .F. )
Private oObjREP

If lTSREP
	oObjREP := PTSREPOBJ():New()
EndIf

Aadd(aStru, {"TAB_OK"	, "C", 2						, 0})
Aadd(aStru, {"FILIAL"	, "C", FwGetTamFilial			, 0})
Aadd(aStru, {"MAT"  	, "C", TamSx3("RA_MAT")[1]		, 0})
Aadd(aStru, {"NOME"  	, "C", 40						, 0})
Aadd(aStru, {"DATAPRG" 	, "D", 8						, 0})
Aadd(aStru, {"SALARIO" 	, "N", TamSx3("RA_SALARIO")[1]  , TamSx3("RA_SALARIO")[2]})
Aadd(aStru, {"RECRB7" 	, "N", 20 						, 0})
AAdd(aLstIndices, {"FILIAL","MAT"})
AAdd(aLstIndices, {"NOME"})

cAliasTRB := GetNextAlias()

oArqTmp := RhCriaTrab(cAliasTRB, aStru, aLstIndices)

dbSelectArea("SRA")
dbSetOrder(1)

DbSelectArea("RB7")
dbSetOrder(1)

DbSelectArea("SQ3")
dbSetOrder(1)

For nX := 1 to Len(aFuncProg)

	RB7->(DbGoTo(aFuncProg[nX]))

	SRA->(DbSeek(RB7->RB7_FILIAL + RB7->RB7_MAT))

	RecLock(cAliasTRB, .T.)
	(cAliasTRB)->FILIAL	:= RB7->RB7_FILIAL
	(cAliasTRB)->MAT	:= RB7->RB7_MAT
	(cAliasTRB)->NOME	:= SRA->RA_NOME
	(cAliasTRB)->DATAPRG:= RB7->RB7_DATALT
	(cAliasTRB)->SALARIO:= RB7->RB7_SALARI
	(cAliasTRB)->RECRB7 := aFuncProg[nX]
	(cAliasTRB)->(MsUnlock())
Next nX

AAdd(aColumns,FWBrwColumn():New())
aColumns[Len(aColumns)]:SetData( &("{||(cAliasTRB)->FILIAL}") )
aColumns[Len(aColumns)]:SetTitle(GetSx3Cache("RA_FILIAL", "X3_TITULO")) //"Filial"
aColumns[Len(aColumns)]:SetSize(FwGetTamFilial)
aColumns[Len(aColumns)]:SetDecimal(0)
aColumns[Len(aColumns)]:SetPicture("@!")

AAdd(aColumns,FWBrwColumn():New())
aColumns[Len(aColumns)]:SetData( &("{||(cAliasTRB)->MAT}") )
aColumns[Len(aColumns)]:SetTitle(GetSx3Cache("RA_MAT", "X3_TITULO")) //"Matrícula"
aColumns[Len(aColumns)]:SetSize(2)
aColumns[Len(aColumns)]:SetDecimal(0)
aColumns[Len(aColumns)]:SetPicture("@!")

AAdd(aColumns,FWBrwColumn():New())
aColumns[Len(aColumns)]:SetData( &("{||(cAliasTRB)->NOME}") )
aColumns[Len(aColumns)]:SetTitle(GetSx3Cache("RA_NOME", "X3_TITULO")) //"Nome"
aColumns[Len(aColumns)]:SetSize(40)
aColumns[Len(aColumns)]:SetDecimal(0)
aColumns[Len(aColumns)]:SetPicture("@!")

AAdd(aColumns,FWBrwColumn():New())
aColumns[Len(aColumns)]:SetData( &("{||(cAliasTRB)->DATAPRG}") )
aColumns[Len(aColumns)]:SetTitle(GetSx3Cache("RB7_DATALT", "X3_TITULO")) //"Data da Programação"
aColumns[Len(aColumns)]:SetSize(40)
aColumns[Len(aColumns)]:SetDecimal(0)
aColumns[Len(aColumns)]:SetPicture("@!")

Aadd( aPesq , {	GetSx3Cache("RA_MAT", "X3_TITULO"), { { "MAT"   , "C", 02 , 0, "MAT" , "@!"}}, 1})
Aadd( aPesq , {	GetSx3Cache("RA_NOME", "X3_TITULO"), { { "NOME"  , "C", 40 , 0, "NOME", "@!"}}, 1})

oSize := FwDefSize():New(.F.)

oSize:AddObject( "CABECALHO",(oSize:aWindSize[3]*1.1),(oSize:aWindSize[3]*0.4) , .F., .F. ) // Não dimensionavel
oSize:aMargins 	:= { 0, 0, 0, 0 } 		// Espaco ao lado dos objetos 0, entre eles 3
oSize:lProp 		:= .F. 				// Proporcional
oSize:Process() 	   					// Dispara os calculos

DEFINE MSDIALOG oDlgGrid TITLE OemToAnsi( STR0130 ) From 0,0 TO 400,900 OF oMainWnd PIXEL //"Programações de Reajuste Salarial"

	// Cria o conteiner onde serão colocados os paineis
	oTela		:= FWFormContainer():New( oDlgGrid )
	cIdGrid  	:= oTela:CreateHorizontalBox( 90 )

	oTela:Activate( oDlgGrid, .F. )

	//Cria os paineis onde serao colocados os browses
	oPanel	:= oTela:GeTPanel( cIdGrid )

	@ oSize:GetDimension("CABECALHO","LININI")+08 , oSize:GetDimension("CABECALHO","COLINI")+6 SAY OemToAnsi(STR0131) Of oDlgGrid Pixel FONT oFont //"Selecione os funcionários que deverão ter a programação de reajuste salarial efetivadas"

	oMark := FWMarkBrowse():New()

	oMark:SetOwner(oPanel)
	oMark:SetAlias(cAliasTRB)
	oMark:SetTemporary(.T.)
	oMark:SetColumns(aColumns)
	oMark:SetFieldMark('TAB_OK')
	oMark:SetFilterDefault( "" )
	oMark:SetIgnoreARotina(.T.)
	oMark:SetMenuDef('')

	oMark:bAllMark := { || SetMarkAll(oMark:Mark(), lMarcar := !lMarcar, cAliasTRB ), oMark:Refresh(.T.)  }

	oMark:Activate()

	SetMarkAll(oMark:Mark(),.T.,cAliasTRB) //Marca todos os registros

	oMark:Refresh(.T.)

	//Botoes
    oBtn1:= TBrowseButton():New( oSize:GetDimension("CABECALHO","LININI")+20,oSize:GetDimension("CABECALHO","COLINI")+320, OemToAnsi("Confirmar"),oDlgGrid, {||nOpcX := 1, oDlgGrid:End()},42,12,,,.F.,.T.,.F.,,.F.,,,)	//"Confirmar"			         
    oBtn2:= TBrowseButton():New( oSize:GetDimension("CABECALHO","LININI")+20,oSize:GetDimension("CABECALHO","COLINI")+370, OemToAnsi("Cancelar"),oDlgGrid, {||nOpcX := 0, oDlgGrid:End()},42,12,,,.F.,.T.,.F.,,.F.,,,)	//"Cancelar"

ACTIVATE MSDIALOG oDlgGrid CENTERED

//Adiciona filiais selecionadas
(cAliasTRB)->(dbGoTop())

While (cAliasTRB)->(!EOF())
	SRA->(DbSeek((cAliasTRB)->FILIAL+(cAliasTRB)->MAT))
	RB7->(DbGoTo((cAliasTRB)->RECRB7))
	If nOpcX == 1 .and. !Empty((cAliasTRB)->TAB_OK)
		Gp120AtuSal(cAliasTRB)
		aAdd( aLogAux, { 1 , SRA->RA_MAT + " - " + SRA->RA_NOME + STR0132 + DtoC(RB7->RB7_DATALT) } ) //" Reajuste efetivado. Data da programação: "
	Else
		aAdd( aLogAux, { 2 , SRA->RA_MAT + " - " + SRA->RA_NOME + STR0133 + DtoC(RB7->RB7_DATALT) } ) //" Reajuste não efetivado. Data da programação: "
	EndIf
	(cAliasTRB)->(dbSkip())
EndDo
If !Empty(aLogAux)
	aSort( aLogAux,,, { |x, y| x[1] < y[1] } )
	aAdd( aLogErros[16], "" )
	For nX := 1 to Len(aLogAux)
		aAdd( aLogErros[16], aLogAux[nX,2] )
	Next nX
EndIf

RestArea(aArea)

Return Nil

/*/{Protheus.doc} Gp120AtuSal()
Atualiza salário
@author Leandro Drumond
@since 25/11/2022
/*/
Static Function Gp120AtuSal(cAliasTRB)
Local aR7AllRecs 	:= {}
Local cFun 			:= DescFun(SRA->RA_CODFUNC,SRA->RA_FILIAL)
Local cDescCar		:= ""
Local nR7SeqTam 	:= 0
Local nPosTp 		:= 0 
Local nPosDt 		:= 0
Local nSalAnt 		:= 0
Local lAchouAlt     := .T.
	
If SQ3->( dbSeek(xFilial("SQ3")+SRA->RA_CARGO+SRA->RA_CC)) .or. SQ3->( dbSeek(xFilial("SQ3")+SRA->RA_CARGO))
	cDescCar := SQ3->Q3_DESCSUM
EndIf

fSeqHistSal( @aR7AllRecs, @nR7SeqTam ) //Funcao para preenchimento dos campos R7_SEQ e R3_SEQ

If !SR7->(DbSeek(SRA->RA_FILIAL+SRA->RA_MAT))
	// Grava o Salario Anterior Quando Nao Existir Alteracao (SR7)
	RecLock("SR7",.T.,.T.)
	SR7->R7_FILIAL   := SRA->RA_FILIAL
	SR7->R7_MAT      := SRA->RA_MAT
	SR7->R7_DATA     := SRA->RA_ADMISSA
	SR7->R7_TIPO     := "001"
	SR7->R7_FUNCAO   := SRA->RA_CODFUNC
	SR7->R7_DESCFUN  := cFun
	SR7->R7_TIPOPGT  := SRA->RA_TIPOPGT
	SR7->R7_CATFUNC  := SRA->RA_CATFUNC
	SR7->R7_USUARIO  := "Sistema"		//"Sistema"
	SR7->R7_CARGO    := SRA->RA_CARGO
	SR7->R7_DESCCAR	 := cDescCar
	SR7->R7_SEQ		 := Strzero( 1, nR7SeqTam )

	MsUnLock()

	// Grava o Salario Anterior Quando Nao Existir Alteracao (SR3)
	RecLock("SR3",.T.,.T.)
		SR3->R3_FILIAL   := SRA->RA_FILIAL
		SR3->R3_MAT      := SRA->RA_MAT
		SR3->R3_DATA     := SRA->RA_ADMISSA
		SR3->R3_PD       := "000"
		SR3->R3_DESCPD   := "SALARIO BASE"			//"SALARIO BASE"
		SR3->R3_VALOR    := SRA->RA_SALARIO
		SR3->R3_TIPO     := "001"
		SR3->R3_ANTEAUM := SRA->RA_ANTEAUM
		SR3->R3_SEQ		:= SR7->R7_SEQ
	MsUnLock()
EndIf

// Atualizando SR7 - Alteracao Salarial
If SR7->(dbSeek( SRA->RA_FILIAL + SRA->RA_MAT + Dtos(RB7->RB7_DATALT) + RB7->RB7_TPALT))
	RecLock("SR7",.F.,.T.)
Else
	RecLock("SR7",.T.,.T.)
	lAchouAlt := .F.
EndIf

// Busca descricao da funcao do funcionario
cFun := DescFun(RB7->RB7_FUNCAO,SRA->RA_FILIAL)

SR7->R7_FILIAL   := SRA->RA_FILIAL
SR7->R7_MAT      := SRA->RA_MAT
SR7->R7_DATA     := RB7->RB7_DATALT
SR7->R7_TIPO     := RB7->RB7_TPALT
SR7->R7_FUNCAO   := RB7->RB7_FUNCAO
SR7->R7_DESCFUN  := cFun
SR7->R7_TIPOPGT  := SRA->RA_TIPOPGT
SR7->R7_CATFUNC  := RB7->RB7_CATEG
SR7->R7_USUARIO  := cUserName

If !Empty(RB7->RB7_CARGO)
	SR7->R7_CARGO   := RB7->RB7_CARGO
	cDescCar:= ""
	If SQ3->( dbSeek(xFilial("SQ3")+RB7->RB7_CARGO+SRA->RA_CC)) .or. SQ3->( dbSeek(xFilial("SQ3")+RB7->RB7_CARGO))
		cDescCar := SQ3->Q3_DESCSUM
	EndIf
Else
	SR7->R7_CARGO   := SRA->RA_CARGO
EndIf

SR7->R7_DESCCAR	:= cDescCar

If Len( aR7AllRecs ) > 0 .And. ( ( nPosDt := aScan( aR7AllRecs, { |x| x[ 1 ] == SR7->R7_DATA } ) ) > 0 ) //Existe alteracao salarial para a data informada
	If lAchouAlt //Mesmo tipo de aumento, entao localiza seq. e substitui
		nPosTp 	:= aScan( aR7AllRecs[ nPosDt, 2 ], { |x| x[ 2 ] == SR7->R7_TIPO } ) //Localiza registro do mesmo tipo de aumento
		SR7->R7_SEQ	:= aR7AllRecs[ nPosDt, 2, nPosTp, 3 ]
	Else //Tipo de aumento diferente, entao atualiza seq. como sendo a ultima
		aSort( @aR7AllRecs[ nPosDt, 2 ], , , { | x, y | x[ 3 ] < y[ 3 ] } )
		SR7->R7_SEQ	:= StrZero( Val( Soma1( aR7AllRecs[ nPosDt, 2, Len( aR7AllRecs[ nPosDt, 2 ] ), 3 ] ) ), nR7SeqTam )
	EndIf
Else //Nao existem quaisquer alteracoes salariais p/ a data informada, logo eh a primeira seq.
	SR7->R7_SEQ := StrZero( 1, nR7SeqTam )
EndIf

MsUnLock()

If SR3->(DbSeek( SRA->RA_FILIAL + SRA->RA_MAT + Dtos(RB7->RB7_DATALT) + RB7->RB7_TPALT ))
	RecLock("SR3",.F.,.T.)
Else
	RecLock("SR3",.T.,.T.)
EndIf

SR3->R3_FILIAL	:= SRA->RA_FILIAL
SR3->R3_MAT  	:= SRA->RA_MAT
SR3->R3_DATA  	:= RB7->RB7_DATALT
SR3->R3_PD 		:= "000"
SR3->R3_DESCPD	:= "SALARIO BASE"				//"SALARIO BASE"
SR3->R3_VALOR	:= RB7->RB7_SALARI
SR3->R3_TIPO	:= RB7->RB7_TPALT
SR3->R3_ANTEAUM	:= RB7->RB7_SALARI
SR3->R3_SEQ		:= SR7->R7_SEQ

MsUnLock()

/*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Ponto de Entrada para atualizar tabela personalizada        ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
If lGpAltSal
	Execblock("GPALTSAL",.F.,.F.,)
EndIf

nSalAnt := SRA->RA_SALARIO//armazena salario anterior ao reajuste

// Atualizando SRA
DbSelectArea("SRA" )
RecLock("SRA",.F.)
	SRA->RA_SALARIO	:= RB7->RB7_SALARI
	SRA->RA_CATFUNC	:= RB7->RB7_CATEG
	SRA->RA_CODFUNC	:= RB7->RB7_FUNCAO

	If !Empty(RB7->RB7_CARGO)
		SRA->RA_CARGO	:= RB7->RB7_CARGO
	EndIf

	SRA->RA_ANTEAUM	:= RB7->RB7_SALARI
MsUnlock()

dbSelectArea("RB7")
RecLock("RB7",.F.)
	RB7->RB7_ATUALI	:= "S"
	RB7->RB7_DTPROC := dDataBase
MsUnlock()

// Ponto-de-Entrada para Gravação Log Alteração
If lCs080Grv
	ExecBlock("CSA080GRV",.F.,.F., {nSalAnt} )
EndIf

If lTSREP
	/*/
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³ Executa o WebServices TSA - Usuario 					       ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	If oObjREP:WSUser( 3 )
		oObjRep:WSUpdRHExp( "SRA" )
	EndIf
EndIf

Return Nil

/*/{Protheus.doc} fSendSRAApi
Processo para enviar atualização de status de Férias
integração via API REST.
@since	13/06/2023
@autor	raquel.andrade
@version 1.0
/*/
Static Function fSendSRAApi(cOperacao,cTmpFil,cTmpMat)
Local dDtBase   := dDataBase
Local cHoraAt   := Time()
Local cTmpEmp   := cEmpAnt
Local cProces   := "SRA"
Local cUserId   := SubStr(cUsuario,7,15)
Local cChave    := cTmpEmp + "|" + cTmpFil + "|" + cTmpMat

DEFAULT cTmpMat   := SRA->RA_MAT
DEFAULT cTmpFil   := xFilial ("SRA",SRA->RA_FILIAL)

fSetInforRJP(cTmpFil, cTmpMat, cProces, cChave, cOperacao,  dDtBase, cHoraAt, cUserId)

Return (.T.)

/*/{Protheus.doc} Gpm120ExecGrid()
Executa o fechamento com GRID de processamento
@author Leandro Drumond
@since 18/08/2023
/*/
Static Function Gpm120ExecGrid( dDtaLimite, aCall, lThread, aLoad, aPerNext, aCompNext, lPMod2, nRecRCH, xProcAux, cNumJob, cTemMov, aSindPLR, aVlrMetric)
Local aSaveMnemo
Local aParAmb	:= {}
Local lFechOk   := .T.
Local nI, nT, nX, nY, nW
Local nPosMetric

Private oGrid

oGrid := GridClient():New()

lFechOk := !ValType(oGrid) == "U"

If(!lFechOk .and. Empty(aLogErros[17]), aAdd( aLogErros[17], "" ), Nil)
If(!lFechOk, aAdd( aLogErros[17], STR0135 ), Nil) //"Falha na criacao do Objeto GridClient. Impossivel executar processo em GRID."

If lFechOk

	SetMnemonicos(NIL,@aSaveMnemo,.T.)
	aParAmb :=	 { cEmpAnt, cFilAnt, dDataBase, aEmpresas, cUsuario, __cUserId,; 								// Parametros Public do sistemas
		 		 { aSaveMnemo, aLoad, aPerNext, aCompNext, lPMod2, nRecRCH, xProcAux, cNumJob, dDtaLimite} } 	// Parametros Privates da Rotina

	// Chama a execucao em Grid. Caso ela retorne .F., ou o grid nao pode ser iniciado, 
	// ou algum processo deu erro, ou um ou mais itens nao foram processados.	
	lFechOk := oGrid:BatchExec("GPEM120AMB",aParAmb,"GPEM120GRD",aCall,Nil)

	If ( !Empty(oGrid:cErrorMsg) .and. Empty(aLogErros[17]), aAdd( aLogErros[17], "" ), Nil )
	If ( !Empty(oGrid:cErrorMsg), aAdd( aLogErros[17], oGrid:cErrorMsg) , Nil )

	If (!lFechOk .and. Empty(oGrid:aGridThreads) .and. Empty(aLogErros[17]), aAdd( aLogErros[17], "" ), Nil )
	If (!lFechOk .and. Empty(oGrid:aGridThreads), aAdd( aLogErros[17], OemToAnsi(STR0136)) , Nil ) // "Nenhum Agente do GRID disponivel no Momento."

	// Requisicoes que nao foram processadas //
	If !Empty(oGrid:aSendProc)
		aAdd( aLogErros[17], "")
		aAdd( aLogErros[17], STR0138)  // "Informações não processadas no GRID"

		// [1] : Numero sequencial da instrucao enviada que nao foi processada
		// [2] : Parametro enviado para processamento 
		// [3] : Retorno da execuçao 
		nT := Len(oGrid:aSendProc)
		For nI := 1 to nT  
			aAdd( aLogErros[17], CRLF + OemToAnsi( STR0137 ) + " " + Str(oGrid:aSendProc[nI,1],5)) // "Requisição:"
			For nW := 1 To Len(oGrid:aSendProc[nI,2])
				aAdd( aLogErros[17], Space(10) + OemToAnsi(STR0107) + " " + oGrid:aSendProc[nI,2,nW,4] + "   " + OemToAnsi(STR0139) + " " + oGrid:aSendProc[nI,2,nW,5]) // "Filial" ## "Matrícula"
			Next nW
		Next nI
	EndIf

	// Recupera retornos das chamadas - Retorno diferente de NIL da funcao GPEM120GRD
	If !Empty(oGrid:aInfoProc)
		
		For nX := 1 to Len(oGrid:aInfoProc)

			lFechOk := oGrid:aInfoProc[nX][4][4]
			
			cTemMov := If(oGrid:aInfoProc[nX][4][5] == "S","S","N")

			//Retorno aSindPLR
			For nY := 1 to Len(oGrid:aInfoProc[nX][4][1])
				aAdd(aSindPLR,oGrid:aInfoProc[nX][4][1][nY])
			Next nY

			//Retorno aVlrMetric
			For nY := 1 to Len(oGrid:aInfoProc[nX][4][2])
				If ( nPosMetric := aScan( aVlrMetric, { |x| x[1] == SRA->RA_CATEFD } ) ) == 0
					aAdd( aVlrMetric, oGrid:aInfoProc[nX][4][2][nY] )
				Else
					aVlrMetric[nPosMetric, 2] += oGrid:aInfoProc[nX][4][2][nY][2]
					aVlrMetric[nPosMetric, 3] += oGrid:aInfoProc[nX][4][2][nY][3]
				EndIf
			Next nY

			//Retorno aLogErros
			For nY := 1 to Len(oGrid:aInfoProc[nX][4][3])
				If !Empty(oGrid:aInfoProc[nX][4][3][nY])
					For nW := 1 to Len(oGrid:aInfoProc[nX][4][3][nY])
						aAdd(aLogErros[nY],oGrid:aInfoProc[nX][4][3][nY][nW])
					Next nW 
				EndIf
			Next nY
		Next nX
	EndIf
EndIf

Return lFechOk

/*/{Protheus.doc} Gpem120Amb()
Inicializa o ambiente no GRID
@author Leandro Drumond
@since 21/08/2023
/*/
Function Gpem120Amb(aParms)
Local cEmpParm  	:= aParms[1]	// Empresa conectada 	--> cEmpAnt
Local cFilParm  	:= aParms[2]	// Filial conectada 	--> cFilAnt
Local dDataParm 	:= aParms[3]	// Data Base			--> dDataBase
Local aEmpParm		:= aParms[4]	// Array com empresas 	--> aEmpresas
Local cUsuaParm 	:= aParms[5]	// Usuario conectado	--> cUsuario
Local cIdUser		:= aParms[6]	// ID Usuario conectado	--> __cUserId
Local aMnemonicos	:= aClone(aParms[7,1])	//Menmonicos salvos
Local aLoad 		:= aClone(aParms[7,2])	//Privates da rotina
Local aPerNext		:= aClone(aParms[7,3])
Local aCompNext		:= aClone(aParms[7,4])
Local lPMod2		:= aParms[7,5]
Local nRecRCH		:= aParms[7,6]
Local xProcAux		:= aParms[7,7]
Local cNumJob		:= aParms[7,8]
Local cUser			:= "__cUser"
Local cId			:= "Id"
Local dDtaLimite	:= aParms[7,9]
Local nMnemo 		:= 0
Local nMnemos 		:= 0
Local nX 			:= 0
Local aParLoad 		:= {}
Local uVar
Local lSetDef
Local cType

Private lThread		:= !Empty(cNumJob)

//Prepara ambiente
RPCSetType( 3 )
RpcSetEnv( cEmpParm, cFilParm,,,'GPE')
SetsDefault()

cFilAnt:= If(Empty(cFilAnt),cFilParm,cFilAnt)

_SetOwnerPrvt( "dDtaLimiteGrid", dDtaLimite )
_SetOwnerPrvt( "lThreadGrid", lThread )
_SetOwnerPrvt( "cNumJobGrid", cNumJob )

If !Empty(GetGlbValue("cToken"))	
	totvs.framework.users.rpc.authByToken(GetGlbValue("cToken"))
Else
	&(cUser + cId) := cIdUser
EndIf

aEmpresas := aClone(aEmpParm)
dDataBase := dDataParm
cUsuario  := cUsuaParm

RstMvBuff() //Reseta cache SX6

nMnemos := Len(aMnemonicos)

//Recarrega os mnemonicos (Mais rápído que setmnemonicos)
If nMnemos > 0 
	For nMnemo := 1 to nMnemos
		lSetDef := .T.

		/*
		ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		³Inicializa e carrega os valores Padroes declarando como       ³
		³Privates na Funcao que Chamou( 1 nivel acima )				   ³
		ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
		IF !Empty( uVar := AllTrim( aMnemonicos[ nMnemo , 03 ] ) )
			IF ( aMnemonicos[ nMnemo , 04 ] == "D" .and. ( "/" $ uVar ) )
				IF CheckExecForm( { || uVar := Ctod( uVar ) },.F. )
					IF ( ( cType := ValType( uVar ) ) == aMnemonicos[ nMnemo , 04 ] )
						_SetOwnerPrvt( aMnemonicos[ nMnemo , 01 ], uVar )
						lSetDef := .F.
					EndIf
				EndIf
			ElseIf CheckExecForm( @uVar , .F. ) 
				_SetOwnerPrvt( aMnemonicos[ nMnemo , 01 ], uVar )
			EndIf
		EndIf
		If lSetDef
			_SetOwnerPrvt( aMnemonicos[ nMnemo , 01 ], GetValType( aMnemonicos[ nMnemo , 04 ] ) )
		EndIf

	Next nMnemo
EndIf

//Carrega variáveis private para uso na rotina
Gpm120SetPrivate(cEmpParm,cFilParm,cUsuaParm,xProcAux,"","",lPMod2,.F.,nRecRCH,.T.,aPerNext,aCompNext,@aLoad,@aParLoad)

//Inicializa as variáveis
For nX := 1 to Len(aParLoad)
	_SetOwnerPrvt( aParLoad[nX], aLoad[nX])
Next nX

DbSelectArea( "SRD" )
DbSetOrder( nOrderSRD )

Do Case
	Case cTpRoteir $ "8*D*E" //VT + VR + VL
		DbSelectArea("SR0")
		DbSetOrder(RetOrder("SR0", "R0_FILIAL+R0_MAT+R0_TPVALE+R0_CODIGO"))

		DbSelectArea("RG2")
		DbSetOrder(RetOrder("RG2", "RG2_FILIAL+RG2_MAT+RG2_TPVALE+RG2_CODIGO+RG2_PERIOD+RG2_NROPGT+RG2_ROTEIR"))
	Case cTpRoteir == "C" //Plano de Saude
		DbSelectArea( "RHO" )
		DbSetOrder( RetOrder( "RHO", "RHO_FILIAL+RHO_MAT+RHO_COMPPG" ) )
		DbSelectArea( "RHR" )
		DbSetOrder( RetOrder( "RHR", "RHR_FILIAL+RHR_MAT+RHR_COMPPG+RHR_ORIGEM+RHR_CODIGO+RHR_TPLAN+RHR_TPFORN+RHR_CODFOR+RHR_TPPLAN+RHR_PLANO+RHR_PD" ) )
		DbSelectArea( "RHK" )
		DbSetOrder( RetOrder( "RHK", "RHK_FILIAL+RHK_MAT+RHK_TPFORN+RHK_CODFOR" ) )
		DbSelectArea( "RHL" )
		DbSetOrder( RetOrder( "RHL", "RHL_FILIAL+RHL_MAT+RHL_TPFORN+RHL_CODFOR+RHL_CODIGO" ) )
		DbSelectArea( "RHM" )
		DbSetOrder( RetOrder( "RHM", "RHM_FILIAL+RHM_MAT+RHM_TPFORN+RHM_CODFOR+RHM_CODIGO" ) )
	Case cTpRoteir == "F" //PLR
		DbSelectArea( "SRC" )
		DbSetOrder( RetOrder( "SRC", "RC_FILIAL+RC_MAT+RC_PROCES+RC_ROTEIR+RC_PERIODO+RC_SEMANA" ) )
	Case cTpRoteir == "I" //Outros Beneficios
		DbSelectArea("RIQ")
		DbSetOrder(1)
		DbSelectArea("RIR")
		DbSetOrder(1)
EndCase

Return(.T.)

/*/{Protheus.doc} Gpem120Grd()
Executa o fechamento através do GRID
@author Leandro Drumond
@since 21/08/2023
/*/
Function GPEM120GRD(aCall)

Local nTotReg
Local nPosRecno
Local nX			:= 0
Local cTemMov 		:= ""
Local aSindPLR 		:= {} 
Local aVlrMetric 	:= {}
Local aRegsSRA 		:= {}
Local lFechOk       := .T.

Private cTnoAux	:= "!!!!!"
Private cFilAux	:= "!!"
Private cFilAux2:= "!!!!!!"

nTotReg := Len(aCall)

For nX := 1 to nTotReg

	nPosRecno	:= aCall[nX,3]	// Posicao do recno na tabela Mestre

	aRegsSRA := {}
	aAdd(aRegsSRA, nPosRecno )

	If !lFechOk
		Loop
	EndIf

	lFechOk := Gpm120Fecha(aRegsSRA,1,dDtaLimiteGrid,lThreadGrid,cNumJobGrid,@cTemMov,@aSindPLR,@aVlrMetric,.T.)

Next nX

//-- Atualiza situação dos funcionários processados
If lFechOk .And. Len(aFuncAtSit) > 0
	UpdSitFunc(aFuncAtSit)
EndIf

Return({aSindPLR,aVlrMetric,aLogErros,lFechOk,cTemMov})

/*/{Protheus.doc} Gpm120SetPrivate()
Carrega as privates utilizadas no fechamento. Seguir o padrão para que funcione no GRID
@author Leandro Drumond
@since 18/08/2023
/*/
Static Function Gpm120SetPrivate(xEmp,xFil,xUser,xProcAux,cJobFile,cNumJob,lPMod2,lThread,nRecRCH,lLoadGrid,aPerNext,aCompNext,aLoad,aParLoad) 

Local aParams		:= {}
Local cGPEGrid		:= GetMvRH("MV_GPEGRID",, " ") //(1=Provisao 2=Calculo Roteiros 3=Fechamento em branco=Todas)
Local cUser			:= "__cUser"
Local cId			:= "Id"
Local nX 			:= 0
Local lFechOk       := .T.
Local lLoad 		:= .F.

DEFAULT aLoad 		:= {}

//( cMesProc, cAnoProc, aSRCFields, cCriterio , cSequencia )

aAdd(aParams, "aRecProg")
aAdd(aParams, "aCodFol")  
aAdd(aParams, "aRCMData")
aAdd(aParams, "aTabFer")
aAdd(aParams, "aTabFer2")
aAdd(aParams, "aPerFerias")
aAdd(aParams, "aProxPerRGB")
aAdd(aParams, "aPdTrans")
aAdd(aParams, "aNextPer")
aAdd(aParams, "aNextComp")
aAdd(aParams, "lNextPer")
aAdd(aParams, "aRCMFields")
aAdd(aParams, "aSRCFields")
aAdd(aParams, "aRGBFields")
aAdd(aParams, "aSRKFields")
aAdd(aParams, "aSR8Fields")
aAdd(aParams, "aSRDFields")
aAdd(aParams, "aSR3Fields")
aAdd(aParams, "aRIQFields")
aAdd(aParams, "aRIRFields")
aAdd(aParams, "aStruRHO")
aAdd(aParams, "aStruRHP")
aAdd(aParams, "aStruRHR")
aAdd(aParams, "aStruRHS")
aAdd(aParams, "cFieldsSRC")
aAdd(aParams, "cFieldsSRK")
aAdd(aParams, "cFieldsSR8")
aAdd(aParams, "cFieldsSR3")
aAdd(aParams, "cCritAux")
aAdd(aParams, "cSeqAux")
aAdd(aParams, "cCodVerba")
aAdd(aParams, "cCodFer")
aAdd(aParams, "cFilSRA")
aAdd(aParams, "cFilRCH")
aAdd(aParams, "cSindSRA")
aAdd(aParams, "cCritAnt")
aAdd(aParams, "cAliasSRV")
aAdd(aParams, "cAliasRCH")
aAdd(aParams, "cAliasSRA")
aAdd(aParams, "cAliasSRC")
aAdd(aParams, "cAliasSRH")
aAdd(aParams, "cAliasSRK")
aAdd(aParams, "cAliasSRB")
aAdd(aParams, "cAliasSR3")
aAdd(aParams, "cAliasSR8")
aAdd(aParams, "cAliasRGB")
aAdd(aParams, "cAliasSRD")
aAdd(aParams, "cPaisFol1")
aAdd(aParams, "nPosRCMFil")
aAdd(aParams, "nPosRCMPd")
aAdd(aParams, "nPosRCMTip")
aAdd(aParams, "oPeriodo")
aAdd(aParams, "_dtPagNexP")
aAdd(aParams, "aCodFalta")
aAdd(aParams, "aPeriodo")
aAdd(aParams, "dDataate")
aAdd(aParams, "cQryAfPerd")
aAdd(aParams, "cMesProc")
aAdd(aParams, "cAnoProc")
aAdd(aParams, "dDtaIni")
aAdd(aParams, "dDtaFim")
aAdd(aParams, "cAnoMes")
aAdd(aParams, "cTipCal")

If lThread .or. lLoadGrid
	//So declara as variaveis se estiver utilizando JOB, do contrario utiliza as privates declaradas na funcao principal
	aAdd(aParams, "aLogErros")
	aAdd(aParams, "nTotFunc")
	aAdd(aParams, "nTotEmp")
	aAdd(aParams, "nTotRegs")
	aAdd(aParams, "nTotProvLiq")
	aAdd(aParams, "nTotDescLiq")
	aAdd(aParams, "nTotBsProv")
	aAdd(aParams, "nTotBsDesc")
	aAdd(aParams, "lPerMod2")
	aAdd(aParams, "cProcesso")
	aAdd(aParams, "cRoteiro")
	aAdd(aParams, "cPeriodo")
	aAdd(aParams, "cSemana")
	aAdd(aParams, "cNumPag")
	aAdd(aParams, "dDtFimPer")
	aAdd(aParams, "cTpRoteir")
EndIf

aAdd(aParams, "aFuncAtSit")
aAdd(aParams, "lContrInt")
aAdd(aParams, "lCpoFlagIC")
aAdd(aParams, "lRefAbono")
aAdd(aParams, "cMv_CatNPgt")
aAdd(aParams, "lConsig")
aAdd(aParams, "cPerFeAc")
aAdd(aParams, "cNamSRCTab")
aAdd(aParams, "cNamSR8Tab")
aAdd(aParams, "lModPadrao")
aAdd(aParams, "lItemClvl")
aAdd(aParams, "lDepSf")
aAdd(aParams, "nCrgOrdRGB")
aAdd(aParams, "nCrgOrd1SRC")
aAdd(aParams, "nCrgOrd2SRC")
aAdd(aParams, "nGVFOrdSRK")
aAdd(aParams, "nGRVVFRCK")
aAdd(aParams, "nOrdGetSR8")
aAdd(aParams, "nOrdSR8SRF")
aAdd(aParams, "nOrderSRD")
aAdd(aParams, "lRefTrab")
aAdd(aParams, "lReplRat")
aAdd(aParams, "lGestPubl")
aAdd(aParams, "lGrid")
aAdd(aParams, "nMinGrid")
aAdd(aParams, "nLoteGrid")
aAdd(aParams, "lCpoNPgto")

lLoad := Len(aLoad) > 0

If lLoad
	aParLoad := aClone(aParams)
Else

	For nX := 1 to Len(aParams)
		_SetOwnerPrvt( aParams[nX], Nil)
	Next nX

	aRecProg  	:= {}
	aCodFol		:= {}
	aRCMData	:= {}
	aTabFer		:= {}
	aTabFer2	:= {}
	aPerFerias	:= {}
	aProxPerRGB	:= {}
	aPdTrans    := {}				// Transferencia de valores para o mes seguinte
	aNextPer	:= aPerNext
	aNextComp	:= aCompNext
	lNextPer	:= !Empty(aNextPer)
	aRCMFields	:= {}
	aSRCFields	:= {}
	aRGBFields	:= {}
	aSRKFields	:= {}
	aSR8Fields	:= {}
	aSRDFields	:= {}
	aSR3Fields	:= {}
	aRIQFields	:= {}
	aRIRFields	:= {}
	aStruRHO	:= {}
	aStruRHP	:= {}
	aStruRHR	:= {}
	aStruRHS	:= {}
	cFieldsSRC	:= ""
	cFieldsSRK	:= ""
	cFieldsSR8	:= ""
	cFieldsSR3	:= ""
	cCritAux	:= ""                       //Criterio de Acumulação do RCH
	cSeqAux		:= ""						//Sequencia de Acumulação do RCH
	cCodVerba 	:= ""
	cCodFer	 	:= ""
	cFilSRA		:= ""
	cTipCal		:= ""
	cSindSRA	:= "!!"
	cCritAnt	:= "!!"
	cAliasSRV 	:= "SRV"
	cAliasRCH	:= "RCH"
	cAliasSRA	:= "SRA"
	cAliasSRC	:= "SRC"
	cAliasSRH	:= "SRH"
	cAliasSRK	:= "SRK"
	cAliasSRB	:= "SRB"
	cAliasSR3	:= "SR3"
	cAliasSR8	:= "SR8"
	cAliasRGB	:= "RGB"
	cAliasSRD	:= "SRD"
	cPaisFol1	:= "VEN/PER"
	nPosRCMFil	:= 0
	nPosRCMPd	:= 0
	nPosRCMTip	:= 0
	_dtPagNexP	:= CtoD(" / / ") // Fecha Pago _Next Per.
	aCodFalta	:= {}
	aPeriodo	:= {}
	dDataate	:= CtoD(" / / ")
	cQryAfPerd	:= ""

	If lThread .or. lLoadGrid
		//So declara as variaveis se estiver utilizando JOB, do contrario utiliza as privates declaradas na funcao principal
		aLogErros	:= Array(17,0) 		// Log de Erros dos periodos que houveram inconsistencias
		nTotFunc	:= 0
		nTotEmp		:= 0
		nTotRegs	:= 0
		nTotProvLiq := 0
		nTotDescLiq := 0
		nTotBsProv 	:= 0
		nTotBsDesc	:= 0
		lPerMod2	:= lPMod2

		If lThread
			// Apaga arquivo ja existente
			If File(cJobFile)
				fErase(cJobFile)
			EndIf

			// Criacao do arquivo de controle de jobs
			MSFCreate(cJobFile)

			// STATUS 1 - Iniciando execucao do Job
			PutGlbValue("GPM120"+xEmp+xFil+cNumJob, "1" )
			GlbUnLock()

			//Prepara ambiente
			RPCSetType( 3 )
			RpcSetEnv( xEmp, xFil,,,'GPE')
			SetsDefault()

			cFilAnt := If(Empty(cFilAnt),xFil,cFilAnt)

			If !Empty(GetGlbValue("cToken"))	
				totvs.framework.users.rpc.authByToken(GetGlbValue("cToken"))
			Else
				&(cUser + cId) := xUser
			EndIf
			
		EndIf
	EndIf

	aFuncAtSit	:= {}
	lContrInt	:= If(SRD->(ColumnPos( 'RD_CONVOC' )) > 0,.T.,.F.)
	lCpoFlagIC	:= SRG->(ColumnPos("RG_CONFIC")) > 0 
	lRefAbono	:= If(SRV->(ColumnPos( 'RV_REFABON' )) > 0,.T.,.F.)
	cMv_CatNPgt	:= GetMvRH( "MV_CATNPGT" )
	lConsig		:= GetMvRH("MV_CONSIG",, .F.)
	cPerFeAc  	:= If (cPaisLoc <> "BRA",GetMvRH("MV_FERPAC", NIL, "N"),"")		// Ferias por ano civil
	cNamSRCTab	:= RetSqlName("SRC")
	cNamSR8Tab	:= RetSqlName("SR8")
	lModPadrao  := !(GetMvRH("MV_MODFOL", NIL, "1") == "2") 	 		// 1-Modelo padrao ; 2- Novo Modelo Mexico
	lItemClvl   := GetMvRH( "MV_ITMCLVL", .F., "2" ) $ "1*3"
	lDepSf		:= Iif(SRA->(FieldPos("RA_DEPSF"))>0,.T.,.F.)      //Nem todos os paises possuem o campo
	nCrgOrdRGB	:= RetOrdem( "RGB" , "RGB_FILIAL+RGB_PROCES+RGB_MAT+RGB_PERIOD+RGB_SEMANA+RGB_ROTEIR+RGB_PD+RGB_CC+RGB_ITEM+RGB_CLVL+RGB_SEQ+DTOS(RGB_DTREF)" )
	nCrgOrd1SRC	:= RetOrdem( "SRC" , "RC_FILIAL+RC_MAT+RC_PERIODO+RC_SEMANA+RC_ROTEIR+RC_PD+RC_CC+RC_SEQ" )
	nCrgOrd2SRC := RetOrdem( "SRC" , "RC_FILIAL+RC_MAT+RC_PERIODO+RC_SEMANA+RC_ROTEIR+RC_PD+RC_CC+RC_ITEM+RC_CLVL+RC_SEQ" )
	nGVFOrdSRK	:= RetOrdem( "SRK" , "RK_FILIAL+RK_MAT+RK_PD+DtoS(RK_DTMOVI)" )
	nGRVVFRCK	:= RetOrdem( "RCK" , "RCK_FILIAL+RCK_MAT+RCK_NUMID+STR(RCK_SEQUEN)" )
	nOrdGetSR8	:= RetOrdem( "SR8" , "R8_FILIAL+R8_MAT+DtoS(R8_DATAINI)+R8_TIPOAFA+STR(R8_DIASEMP)" )
	nOrdSR8SRF	:= RetOrdem( "SRF" , "RF_FILIAL+RF_MAT+RF_PD+DtoS(RF_DATABAS)" )
	nOrderSRD 	:= RetOrdem( "SRD" , "RD_FILIAL+RD_MAT+RD_CC+RD_DATARQ+RD_PD+RD_SEQ+RD_PERIODO+RD_SEMANA+RD_ROTEIR+DTOS(RD_DTREF)"+iIf(lContrInt,"+RD_CONVOC","") )
	lRefTrab	:= FindFunction("fRefTrab") .And. fRefTrab("S")
	lReplRat	:= GetMvRH("MV_REPLRAT",NIL,.F.)
	lGestPubl 	:= IIF(ExistFunc("fUsaGFP"),If(cModulo=="GPE", .F. , fUsaGFP()),.F.)
	lGrid		:= GetMvRH("MV_GRID",, .F.)  .and. ( Empty(cGPEGrid) .Or. "3" $ cGPEGrid )// Se o parametro esta configurado para utilizacao do GRID
	nMinGrid 	:= GetMvRH("MV_MINGRID",, 0)
	nLoteGrid 	:= GetMvRH("MV_REGGRID",,20) // Identifica o Nro de Registros a processar por Thread
	lCpoNPgto   := cPaisLoc == "BRA" .And. RCK->(ColumnPos("RCK_NPAG") > 0)

	If lItemClvl
		nOrderSRD 	:= RetOrdem( "SRD", "RD_FILIAL+RD_MAT+RD_CC+RD_ITEM+RD_CLVL+RD_DATARQ+RD_PD+RD_SEQ+RD_PERIODO+RD_SEMANA+RD_ROTEIR+DTOS(RD_DTREF)"+iIf(lContrInt,"+RD_CONVOC","") )
	EndIf

	DbSelectArea(cAliasRCH)
	DbGoTo(nRecRCH)

	If( cPaisLoc $ "MEX|COS", fLoadRCM( @aRCMData, @aRCMFields ), Nil )
	If( cPaisLoc $ "MEX|COS", oPeriodo := RHPERIODO():New(), Nil )

	cProcesso	:= xProcAux
	cRoteiro    := ( cAliasRCH )->RCH_ROTEIR
	cPeriodo    := ( cAliasRCH )->RCH_PER
	cSemana		:= cNumPag	    := ( cAliasRCH )->RCH_NUMPAG
	dDtFimPer 	:= ( cAliasRCH )->RCH_DTFIM
	cMesProc	:= ( cAliasRCH )->RCH_MES
	cAnoProc	:= ( cAliasRCH )->RCH_ANO
	dDtaIni		:= ( cAliasRCH )->RCH_DTINI
	dDtaFim		:= ( cAliasRCH )->RCH_DTFIM
	cAnoMes		:= ( cAliasRCH )->RCH_ANO + ( cAliasRCH )->RCH_MES

	cTpRoteir   := fGetTipoRot(cRoteiro)
	
	cCritAux 	:= If(!lModPadrao .Or. (cPaisLoc $ cPaisFol1), Alltrim((cAliasRCH)->RCH_CRITER), cCritAux)
	cSeqAux		:= If(!lModPadrao .Or. (cPaisLoc $ cPaisFol1), Alltrim((cAliasRCH)->RCH_SEQUE ), cSeqAux)

	cFilRCH 	:= ( cAliasRCH )->RCH_FILIAL

	_dtPagNexP := If(cPaisLoc == "COL" .and. Len(aPerNext) > 0,aPerNext[1,08],_dtPagNexP)

	// Obtem afastamentos com perda do periodo e duracao acima de 6 meses;
	// suspensao do periodo com qualquer duracao; para ambos os casos com
	// retorno do afastamento no mes/ano do fechamento.
	cQryAfPerd := " SELECT COUNT(*) TOTALREG"
	cQryAfPerd +=	" FROM " + RetSqlName("SR8") + " SR8"
	cQryAfPerd += 	" INNER JOIN " + RetSqlName("RCM") + " RCM"
	cQryAfPerd += 	" ON " + FWJoinFilial( "SR8", "RCM" ) + " AND"
	cQryAfPerd +=	" R8_TIPOAFA = RCM_TIPO"
	cQryAfPerd += " WHERE R8_FILIAL = ? AND"
	cQryAfPerd += 		" R8_MAT = ? AND"
	cQryAfPerd += 		" SUBSTRING(R8_DATAFIM,1,6) = ? AND"
	cQryAfPerd +=	 	" RCM_FERIAS IN ('1','2') AND"
	cQryAfPerd += 		" SR8.D_E_L_E_T_ = '' AND RCM.D_E_L_E_T_ = ''"

	cQryAfPerd := ChangeQuery(cQryAfPerd)

	DbSelectArea( "SRD" )
	DbSetOrder( nOrderSRD )

	/*
	ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	³Posiciona o RCJ no processo que esta sendo executado		   ³
	ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
	DbSelectArea("RCJ")
	RCJ->( DbSetOrder( RetOrdem( "RCJ", "RCJ_FILIAL+RCJ_CODIGO" ) ) )
	RCJ->(DbSeek(cFilRCH+cProcesso))

	Do Case
		Case cTpRoteir $ "1*2*9" .Or. (cPaisLoc $ "MEX|PAR" .AND. cTpRoteir $ "7*A*3") .Or. (cPaisLoc $ "ARG" .AND. cTpRoteir $ "7*A*3*4*5") .Or. (lGestPubl .And. cTpRoteir $ "L*M") //Folha - Adiantamento - Autonomo - Outros
			DbSelectArea("RHQ")
			DbSetOrder(1)
			DbSelectArea(cAliasSRC)
			aSRCFields	:= ( cAliasSRC )->( dbStruct() )
			DbSelectArea(cAliasSRD)
			aSRDFields	:= ( cAliasSRD )->( dbStruct() )
			DbSelectArea(cAliasSRK)
			aSRKFields 	:= ( cAliasSRK )->( dbStruct() )
			DbSelectArea(cAliasSR8)
			aSR8Fields 	:= ( cAliasSR8 )->( dbStruct() )
			DbSelectArea(cAliasSR3)
			aSR3Fields	:= ( cAliasSR3 )->( dbStruct() )
			DbSelectArea(cAliasRGB)
			aRGBFields 	:= ( cAliasRGB )->( dbStruct() )

			aEval(aSRCFields, { |aField| cFieldsSRC += "SRC." + aField[01] + ", "})
			cFieldsSRC += "SRC.R_E_C_N_O_ "
			cFieldsSRC := "% " + cFieldsSRC + " %"

			aEval(aSRKFields, { |aField| cFieldsSRK += "SRK." + aField[01] + ", "})
			cFieldsSRK += "SRK.R_E_C_N_O_ "
			cFieldsSRK := "% " + cFieldsSRK + " %"

			aEval(aSR8Fields, { |aField| cFieldsSR8 += "SR8." + aField[01] + ", "})
			cFieldsSR8 += "SR8.R_E_C_N_O_ "
			cFieldsSR8 := "% " + cFieldsSR8 + " %"

			aEval(aSR3Fields, { |aField| cFieldsSR3 += "SR3." + aField[01] + ", "})
			cFieldsSR3 += "SR3.R_E_C_N_O_ "
			cFieldsSR3 := "% " + cFieldsSR3 + " %"

			If cTpRoteir == "2"
				fRetPerComp(cMesProc, cAnoProc,cFilRCH, cProcesso,fGetRotOrdinar(),@aProxPerRGB )
				If Empty(aProxPerRGB)
					fRetPerComp(cMesProc, cAnoProc,cFilRCH, cProcesso,fGetCalcRot("9"),@aProxPerRGB )
					If Empty(aProxPerRGB)
						aAdd( aLogErros[1], STR0103 ) //-- "Não existe período de cálculo cadastrado para o roteiro de folha/autonômo."
						aAdd( aLogErros[1],"")
						lFechOk := .F.
					EndIf
				EndIf
			EndIf
		Case cTpRoteir == "3" //Ferias
			DbSelectArea(cAliasSR8)
			aSR8Fields 	:= ( cAliasSR8 )->( dbStruct() )
			aEval(aSR8Fields, { |aField| cFieldsSR8 += "SR8." + aField[01] + ", "})
			cFieldsSR8 += "SR8.R_E_C_N_O_ "
			cFieldsSR8 := "% " + cFieldsSR8 + " %"
		Case cTpRoteir $ "8*D*E" //VT + VR + VL
			DbSelectArea("SR0")
			DbSetOrder(RetOrder("SR0", "R0_FILIAL+R0_MAT+R0_TPVALE+R0_CODIGO"))

			DbSelectArea("RG2")
			DbSetOrder(RetOrder("RG2", "RG2_FILIAL+RG2_MAT+RG2_TPVALE+RG2_CODIGO+RG2_PERIOD+RG2_NROPGT+RG2_ROTEIR"))

			cTipCal := If(cTpRoteir == "8","0",(If(cTpRoteir == "D","1","2")))
		Case cTpRoteir == "C" //Plano de Saude
			DbSelectArea( "RHO" )
			DbSetOrder( RetOrder( "RHO", "RHO_FILIAL+RHO_MAT+RHO_COMPPG" ) )
			DbSelectArea( "RHR" )
			DbSetOrder( RetOrder( "RHR", "RHR_FILIAL+RHR_MAT+RHR_COMPPG+RHR_ORIGEM+RHR_CODIGO+RHR_TPLAN+RHR_TPFORN+RHR_CODFOR+RHR_TPPLAN+RHR_PLANO+RHR_PD" ) )
			DbSelectArea( "RHK" )
			DbSetOrder( RetOrder( "RHK", "RHK_FILIAL+RHK_MAT+RHK_TPFORN+RHK_CODFOR" ) )
			DbSelectArea( "RHL" )
			DbSetOrder( RetOrder( "RHL", "RHL_FILIAL+RHL_MAT+RHL_TPFORN+RHL_CODFOR+RHL_CODIGO" ) )
			DbSelectArea( "RHM" )
			DbSetOrder( RetOrder( "RHM", "RHM_FILIAL+RHM_MAT+RHM_TPFORN+RHM_CODFOR+RHM_CODIGO" ) )
			aStruRHO	:= RHO->( dbStruct() )
			aStruRHP	:= RHP->( dbStruct() )
			aStruRHR	:= RHR->( dbStruct() )
			aStruRHS	:= RHS->( dbStruct() )
		Case cTpRoteir == "F" //PLR
			DbSelectArea( "SRC" )
			DbSetOrder( RetOrder( "SRC", "RC_FILIAL+RC_MAT+RC_PROCES+RC_ROTEIR+RC_PERIODO+RC_SEMANA" ) )
			aSRCFields	:= SRC->( dbStruct() )
			aSRDFields	:= SRD->( dbStruct() )
		Case cTpRoteir == "I" //Outros Beneficios
			DbSelectArea("RIQ")
			DbSetOrder(1)
			aRIQFields	:= RIQ->( dbStruct() )
			DbSelectArea("RIR")
			DbSetOrder(1)
			aRIRFields 	:= RIR->( dbStruct() )
		OtherWise
			DbSelectArea(cAliasSRC)
			aSRCFields	:= ( cAliasSRC )->( dbStruct() )
			DbSelectArea(cAliasSRD)
			aSRDFields	:= ( cAliasSRD )->( dbStruct() )
	EndCase
EndIf

//Carrega o conteúdo na variável aLoad para utilização na montagem do ambiente do GRID
If lFechOk .and. !lLoad .and. lGrid
	aLoad := {}
	For nX := 1 to Len(aParams)
		aAdd(aLoad, &(aParams[nX]))
	Next nX
EndIf

Return lFechOk

/*/{Protheus.doc} Gpm120Fecha()
Chama as funções de fechamento por roteiro
@author Leandro Drumond
@since 18/08/2023
/*/
Static Function Gpm120Fecha(aRegsSRA,nLoop,dDtaLimite,lThread,cNumJob,cTemMov,aSindPLR,aVlrMetric,lUsaGrid)
Local aLogAux	:= {}
Local aLogPer	:= {}
Local aLogPrgF	:= {}
Local lFechOk	:= .T.

DbSelectArea("SRA")
DbGoTo(aRegsSRA[nLoop])

If ( cFilAux2 <> SRA->RA_FILIAL .and. !Empty(xFilial("SRV")) ) .or. Empty(aCodFol)
	Fp_CodFol(@aCodFol , SRA->RA_FILIAL, .F., .F.) //Carrega verbas
	cFilAux2 := SRA->RA_FILIAL
	aCodFalta := { aCodFol[54,1], aCodFol[55,1], aCodFol[203,1], aCodFol[242,1], aCodFol[243,1], aCodFol[244,1], aCodFol[245,1] } //Utilizado na pesquisa de faltas no fechamento da folha e ferias
EndIf

Begin Transaction

	Begin Sequence

		Do Case
			Case cTpRoteir $ "1*9" .Or. (cPaisLoc $ "MEX" .And. cTpRoteir $ "A") .Or. (cPaisLoc $ "ARG" .And. cTpRoteir $ "A*4*5") .Or. (lGestPubl .And. cTpRoteir $ "L*M")
			//Folha*Autonomo	//MEX não usa integração de roteiros mas fecha "aplicação de finiquitos"
				aLogAux := {{}}
				aLogId 	:= {{}}
				aLogPer := {{}}
				aLogPrgF:= {{}}
				lFechOk := Gp120FecFol(@cTnoAux, dDtaLimite, @cTemMov, @aLogAux, @aLogId, @aLogPer, @aLogPrgF, @aVlrMetric)

				If(!lFechOk .and. Len(aLogAux[1]) > 0 .and. Empty(aLogErros[12]),aAdd( aLogErros[12], "" ),Nil)
				If(!lFechOk, aEval( aLogAux[1], { |x| aAdd( aLogErros[12], x ) }), Nil)

				If(!lFechOk .and. Len(aLogId[1]) > 0 .and. Empty(aLogErros[13]),aAdd( aLogErros[13], "" ),Nil)
				If(!lFechOk,aEval( aLogId[1], { |x| aAdd( aLogErros[13], x ) }),Nil)

				If(!lFechOk .and. Len(aLogPer[1]) > 0 .and. Empty(aLogErros[14]),aAdd( aLogErros[14], "" ),Nil)
				If(!lFechOk,aEval( aLogPer[1], { |x| aAdd( aLogErros[14], x ) }),Nil)

				If lFechOk
					If(Len(aLogPrgF[1]) > 0 .and. Empty(aLogErros[15]),aAdd( aLogErros[15], "" ),Nil)
					aEval( aLogPrgF[1], { |x| aAdd( aLogErros[15], x ) })
				EndIf
			Case cTpRoteir == "2"  .and. cPaisLoc == "BRA"//Adiantamento
				Gp120FecAdi(@cTemMov)
			Case cTpRoteir == "3"  //Ferias
				aLogPer := {{}}
				lFechOk := Gp120FecFer(dDtaLimite, @cTnoAux, @cTemMov, @aLogPer)

				If(!lFechOk .and. Len(aLogPer[1]) > 0 .and. Empty(aLogErros[14]),aAdd( aLogErros[14], "" ),Nil)
				If(!lFechOk, aEval( aLogPer[1], { |x| aAdd( aLogErros[14], x ) }),Nil)

			Case cTpRoteir == "4"  //Rescisao
				Gp120FecRes(@cTemMov)
			Case cTpRoteir $ "8*D*E"//VT - VR - VA
				aLogAux := {{}}
				lFechOk := Gpm18FecBen("SRA",cProcesso,cPeriodo,cRoteiro,cNumPag,cAnoMes,cTipCal,@aLogAux,@cTemMov)
				
				If(!Empty(aLogAux[1]) .and. Empty(aLogErros[9]),aAdd( aLogErros[9], "" ),Nil)
				If(Len(aLogAux[1])>0, aEval( aLogAux[1], { |x| aAdd( aLogErros[9], x ) }), Nil)

			Case cTpRoteir == "C"	//Plano de Saude
				lFechOk := Gpm18FecPS("SRA",@cFilAux,@aCodFol,cAnoMes,cProcesso,cRoteiro,cPeriodo,cNumPag,aStruRHO,aStruRHP,aStruRHR,aStruRHS,@cTemMov,lThread)
			Case cTpRoteir == "F"	//PLR
				lFechOk := Gpm18FecPR("SRA",cAnoMes,cProcesso,cRoteiro,cPeriodo,cNumPag,aSRCFields,aSRDFields,@aSindPLR,@cTemMov)
			Case cTpRoteir == "I"	//Outros Beneficios
				lFechOk := Gpm18FecOB("SRA",cProcesso,cRoteiro,cPeriodo,cNumPag,aRIQFields,aRIRFields,@cTemMov,lThread)
			OtherWise //13o Primeira e Segunda Parcela e OUTROS
				Gp120FecGen(@cTemMov)
		EndCase

	End Sequence

	If lThread
		If !lUsaGrid
			PutGlbValue("nTotReg"+cNumJob,AllTrim(STR(nLoop)))
			GlbUnLock()
		EndIf
	Else
		If !IsBlind() .And. !lSegPlan
			IncPrcG2Time( STR0026 + " " +SRA->RA_MAT + If(lOfusca, "", "-" + SRA->RA_NOME ), nSumSRA , cTimeIniSRA , .T. , 1 , 1 , .T. )	// Processando Funcionario ->
		EndIf
	EndIf

	If !lFechOk
		DisarmTransaction()
		Break
	EndIf

End Transaction

Return lFechOk

/*/{Protheus.doc} UpdSitFunc()
Atualiza situação do funcionário
@author Leandro Drumond
@since 15/03/2024
/*/
Static Function UpdSitFunc(aFuncAtSit)
Local nX
Local cSitFol
Local lIntNGRJP	:= GetMvRH('MV_RHNG', .F., .F.)

DbSelectArea("SRA")
For nX := 1 to Len(aFuncAtSit)
	DbGoto(aFuncAtSit[nX,6])
	cSitFol	:= SRA->RA_SITFOLH
	RetSituacao(aFuncAtSit[nX,1], aFuncAtSit[nX,2], aFuncAtSitnX[nX,3], aFuncAtSit[nX,4], Nil, .F., Nil, aFuncAtSit[nX,5], , , , , .T.)
	If( lIntNGRJP .And. cSitFol <> SRA->RA_SITFOLH, fSendSRAApi("A",aFuncAtSit[nX,1], aFuncAtSit[nX,2]), Nil)
Next nX

Return Nil

/*/{Protheus.doc} SchedDef
Definições de agendamento do Schedule.
@author Maria Luísa de Souza Arcanjo Bastos
@since 22/11/2024
/*/
Static Function SchedDef()

    Local aParam As Array
    // Inicialização das variáveis
    aParam := {}

    // Montagem da estrutura do vetor de retorno
    AAdd(aParam, "P")       // Tipo do agendamento: "P" = Processo | "R" = Relatório
    AAdd(aParam, "GPEM120") // Pergunte (SX1) (usar "PARAMDEF" caso não tenha conjunto de perguntas)
    AAdd(aParam, "")        // Alias principal (exclusivo para relatórios)
    AAdd(aParam, {})        // Vetor de ordenação (exclusivo para relatórios)
    AAdd(aParam, "")        // Título (exclusivo para relatórios)

Return aParam

/*/{Protheus.doc} fEConsRUO
Verifica se possuí parcela do eConsignado no período seguinte
@author Bruno Costa
@since 05/05/2025
/*/
Static Function fEConsRUO(cPd, cNextPer, cNrContr, cBanco, nQtdParPg, nParcECon, nValEmpr, nTotParc)
Local aArea := GetArea()
Local lRet  := .F.

DbSelectArea("RUO")
DbSetOrder(1) //RUO_FILIAL+RUO_MAT+RUO_NRCONT+RUO_COMPET+RUO_PD+RUO_BCOCON

If RUO->(DbSeek(SRA->RA_FILIAL + SRA->RA_MAT + cNrContr + cNextPer + cPd + cBanco))
	If RUO->RUO_VLPARC > 0 .And. RUO->RUO_INTEGR == "2"
		nParcECon := RUO->RUO_VLPARC 
		nValEmpr  := RUO->RUO_VLTOT
		nQtdParPg := RUO->RUO_PARPAG
		nTotParc  := RUO->RUO_PARCEL
		lRet	  := .T.
	EndIf 	
	If lRet .And. RUO->(RecLock("RUO", .F.))
		 RUO->RUO_INTEGR := "1"
		 RUO->(MsUnlock())
	EndIf 
EndIf 

RUO->(dbCloseArea())
RestArea(aArea)

Return lRet

/*/{Protheus.doc} fGeraEConsig
Cria o empréstimo na SRK a partir do histórico da RUO
@author Bruno Costa
@since 12/05/2025
/*/
Static Function fGeraEConsig(aNextPer)
Local aArea     := GetArea()
Local cComp     := aNextPer[1, 6] + aNextPer[1, 7]
Local nTamDoc   := 0
Local nPosPd    := 0
Local nPVlSaldo := 0
Local nPos      := 0
Local lTemSRK   := Len(aAllSRK) > 0

Static lTemDupRUO

DEFAULT lTemDupRUO := fVerDupRUO(cComp)

DbSelectArea("RUO")
DbSetOrder(3) //RUO_FILIAL+RUO_MAT+RUO_COMPET

If RUO->(DbSeek(SRA->RA_FILIAL + SRA->RA_MAT + cComp))
	nTamDoc   := aSRKFields[aScan(aSRKFields, {|x| x[1] == "RK_DOCUMEN"})][3]
	nPosPd	  := aScan(aSRKFields, {|x| x[1] == "RK_PD"})
	nPVlSaldo := aScan(aSRKFields, {|x| x[1] == "RK_VLSALDO"})
	While RUO->(!Eof() .And. RUO_FILIAL + RUO_MAT + RUO_COMPET == SRA->RA_FILIAL + SRA->RA_MAT + cComp)
	 	If !(RUO->RUO_VLPARC > 0 .And. RUO->RUO_INTEGR == "2" )
			RUO->(dbSkip())
			Loop
		EndIf
	    If lTemSRK .And. (nPos := aScan(aAllSRK, {|x| x[nPosPd] == RUO->RUO_PD})) > 0 .And. aAllSRK[nPos][nPVlSaldo] > 0
			RUO->(dbSkip())
			Loop
		EndIf
		SRK->(RecLock("SRK", .T.))
		SRK->RK_FILIAL	:= SRA->RA_FILIAL
		SRK->RK_MAT		:= SRA->RA_MAT
		SRK->RK_PD		:= RUO->RUO_PD
		SRK->RK_DOCUMEN	:= fNextDocSRK(nTamDoc) 
		SRK->RK_NUMID	:= "SRK" + SRA->RA_FILIAL + SRA->RA_MAT + RUO->RUO_PD + SRK->RK_DOCUMEN //Recria pois está sempre criando o documento com 01 na RUO
		SRK->RK_NRCONTR	:= RUO->RUO_NRCONT
		SRK->RK_CC		:= SRA->RA_CC
		SRK->RK_PROCES	:= SRA->RA_PROCES
		SRK->RK_POSTO	:= SRA->RA_POSTO
		SRK->RK_ITEM	:= SRA->RA_ITEM
		SRK->RK_CLVL	:= SRA->RA_CLVL
		SRK->RK_BCOCONS	:= RUO->RUO_BCOCON
		SRK->RK_PERINI	:= aNextPer[1, 2]
		SRK->RK_PARCELA	:= RUO->RUO_PARCEL
		SRK->RK_VALORPA	:= RUO->RUO_VLPARC
		SRK->RK_VALORTO	:= RUO->RUO_VLTOT
		SRK->RK_PARCPAG	:= RUO->RUO_PARPAG	
		SRK->RK_EMPCONS	:= "1" 
		SRK->RK_CONSFGT	:= "1" 
		SRK->RK_STATUS	:= "2" 
		SRK->RK_VLSALDO	:= RUO->RUO_VLTOT
		SRK->RK_TIPO	:= "G"
		SRK->RK_NUMPAGO	:= aNextPer[1, 3]
		SRK->RK_DTVENC	:= aNextPer[1, 10]
		SRK->RK_DTMOVI	:= dDataBase
		SRK->RK_DTREF	:= dDataBase
		SRK->(MsUnlock())		
		RUO->(RecLock("RUO", .F.))
		RUO->RUO_INTEGR := "1"
		RUO->RUO_NUMID  := SRK->RK_NUMID
		RUO->(MsUnlock())						
		RUO->(dbSkip())
	EndDo
EndIf 

RUO->(dbCloseArea())
RestArea(aArea)

Return 

/*/{Protheus.doc} fNextDocSRK
Cria próxima sequencia do documento para o empréstimo do eConsignado
@author Bruno Costa
@since 13/05/2025
/*/
Static Function fNextDocSRK(nTamDoc) 
Local aArea	 	:= GetArea()
Local cAliasSeq	:= GetNextAlias()
Local cNextDoc  := StrZero(1, nTamDoc)
Local cWhere    := "% SRK.RK_FILIAL = '" + SRA->RA_FILIAL + "' AND SRK.RK_MAT = '" + SRA->RA_MAT + "' %"

BeginSql Alias cAliasSeq
	SELECT MAX(RK_DOCUMEN) PROX
	FROM %table:SRK% SRK
	WHERE %exp:cWhere%
	AND SRK.%NotDel%
EndSql

IF !(cAliasSeq)->(Eof())
	cNextDoc := Soma1((cAliasSeq)->PROX)
	(cAliasSeq)->(DbCloseArea())
EndIf 

RestArea(aArea)

Return cNextDoc

/*/{Protheus.doc} fVerDupRUO
Verifica se houve importação de verbas iguais indevidamente pela rotina de importação e informa usuário para executar rotina novamente.
@author Leandro Drumond
@since 30/06/2025
/*/
Static Function fVerDupRUO(cComp)
Local lRet        := .F. 
Local cAliasQry   := GetNextAlias()

BeginSql alias cAliasQry
	SELECT 		RUO_FILIAL,
				RUO_MAT,
				RUO_COMPET,
				RUO_PD,
				COUNT(*) AS QTDE
	FROM 		%table:RUO% RUO
	GROUP BY 	RUO_FILIAL,
				RUO_MAT,
				RUO_COMPET,
				RUO_PD
	HAVING      COUNT(*) > 1
EndSql

If (cAliasQry)->( !Eof() )
	lRet := .T. 
	aAdd( aLogErros[1], STR0142 ) //-- "Foram encontradas inconsistências na importação dos lançamentos relacionados ao Programa Crédito do Trabalhador. "
	aAdd( aLogErros[1], STR0143 ) //-- "Execute a rotina de importação novamente para efetuar as devidas correções."
	aAdd( aLogErros[1], STR0144 + "https://tdn.totvs.com/pages/viewpage.action?pageId=960993664 .") //-- "Para maiores informações consulte a documentação: "
	aAdd( aLogErros[1], "")
EndIf 

(cAliasQry)->( DbCloseArea() )

Return lRet
