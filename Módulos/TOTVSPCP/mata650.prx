/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³ ATENCAO ESTE PROGRAMA E UTILIZADO PELA ROTINA DE ORCAMENTO             ³±±
±±³ ASSIM DEVE-SE TESTAR O PROGRAMA A415BAIXA QUANDO ESTE FOR ALTERADO     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/

#INCLUDE "MATA650.CH"
#INCLUDE "PROTHEUS.CH"
#INCLUDE "FWEVENTVIEWCONSTS.CH"
#INCLUDE "FWADAPTEREAI.CH"
#DEFINE USADO CHR(0)+CHR(0)+CHR(1)

Static lPmsInt    := (IsIntegTop(,.T.))
Static lMTA650AC  := ExistBlock('MTA650AC')
Static lMTA650PR  := ExistBlock("MTA650PR")
Static lIntSFC    := ExisteSFC("SC2") .And. !IsInCallStack("AUTO650")
Static lWmsNew    := SuperGetMV("MV_WMSNEW",.F.,.F.)
Static lPCPREVATU := FindFunction('PCPREVATU') .AND. SuperGetMv("MV_REVFIL",.F.,.F.)
Static sG1TRT     := NIL
Static mvlPCPOS   := NIL //Indica se utiliza/gera Ordem de Substituição
Static lMopcGRV   := SuperGetMv("MV_MOPCGRV",.F.,.F.) // Parametro criado para definir se gravas os opcionais somente no Produto Pai ( Seq pai igual a branco/vazio).
Static _lNewMRP   := Nil
Static _lF4Lote   := .F.
Static lEMPREVVAZ := Nil
Static snTotNewOp := 0
Static lQIPOPEPQP := FindFunction("QIPOPEPQPK")
Static _lCrpOk    := Nil
Static _lFilPrMES := Nil
Static _lAtuIniSC := Nil

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³ Fun‡„o   ³ Mata650  ³ Autor ³ Claudinei M. Benzi    ³ Data ³          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ³±±
±±³ Descri‡„o³ Cadastramento de Ordens de Producao                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function MATA650(aRotAuto,nOpcAuto,lGeraInter)
Local nOpc, nPos, lGerar := .F., cAlias := Alias()
Local nOps := 0
Local nPosBlock
Local bBlock
Local ni       := 0
Local aCorAux  := {}
Local aCores   := {}
Local lMA650FBW:= ExistBlock("MA650FBW")
Local lA650GEF   := If(SuperGetMV("MV_A650GEF",.F.,"N")=="S",.T.,.F.)
Local cFiltro    := ""
Local cMsg       := ""
Local cTitle     := ""
Local lRet       := .T.
Local lUsaSemaf  := (SUPERGETMV("MV_SEMAFGE", .T., "N") == "S")
Local aFilial    := {}
Local aFiliais   := {}
Local aMetrics	 := {}

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Array criado p/ substituir parametros                        ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
PRIVATE aSav650 := Array(20)
PRIVATE lConsTerc
PRIVATE lConsNPT
PRIVATE lProj711 := .F.
PRIVATE lMata712 := .F.
PRIVATE lPCPA107 := .F.
PRIVATE lPCPA113 := .F.
PRIVATE aLegenda := {}
PRIVATE aRotProd := aClone(aRotAuto)

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Variáveis utilizadas para o MRP multi-empresa                ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
PRIVATE lPmp107   := .F.
PRIVATE nRec107   := 0
PRIVATE cProd107  := ""
PRIVATE cPeri107  := ""

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Tratamento de Filtro para o browse                           ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
PRIVATE cCondFil := ""
PRIVATE aIndSC2  := {}

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Estas variaveis indicam para as funcoes de validacao qual    ³
//³ programa as esta' chamando                                   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
PRIVATE l240:=.F.,l250 :=.F.,l241:=.F.,l242:=.F.,l261:=.F.,l185:=.F.,l650:=.T.
PRIVATE aOPOpc := {}

PRIVATE aAltSaldo := {}
Private aOPNova:={"",""}

Private lRodaAPS := .F.

Private lMt650RevDis	:= IIF(Empty(aRotAuto),.F.,.T.)

Private cBkpFilial := cFilAnt
//-######################
//-Variáveis para integração com o PCFactory
Private aIntegPPI := {}
//-######################

Private lOpVendas := .F.
Private aValAlt   := {}

Private nMetricEmp := 0

//Pega as filiais do grupo de empresas.
If lA650GEF
	aFiliais := FWAllFilial(,,cEmpAnt,.F.)
	For nI := 1 To Len(aFiliais)
	   aAdd(aFilial,{aFiliais[nI],0,xFilial("SC2",aFiliais[nI])})
	Next nI
Else
	aAdd(aFilial,{cFilAnt,0,xFilial("SC2")})
EndIf

Private aLotesUsado := {}

Private aArrayPro1     := {}
Private aArrayOps1     := {}
Private lBackX8        := .T.
Private lRunMnt        := .F.

Default nOpcAuto	:= If(aRotProd<>Nil,3,nOpcAuto)
Default lGeraInter  := .T.

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Verifica a permissao do programa em relacao aos modulos      ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If AMIIn(4,10,19,25,44)

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Variaveis utilizadas na geracao de SCS aglutinadas por data  ³
	//³ de necessidade.                                              ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	PRIVATE aDataOPC1:={},aDataOPC7:={},aOPC1:={},aOPC7:={}, aOPC7Local:={}
	PRIVATE l650Auto := (ValType(aRotProd)=="A")
	PRIVATE aRotina := MenuDef()
	PRIVATE cCadastro := OemToAnsi(STR0006)	//"Ordens de Produ‡„o"
	PRIVATE lEnd:=.F.
	PRIVATE cFilA650 := ''

	// Variável para controlar a criação do aHeader na rotina automatica
	PRIVATE lZrHeader := If(l650Auto,.T.,.F.)

	If ( l650Auto .Or. nOpcAuto<>Nil )
		aRotina := {	{STR0001,"AxPesqui"  , 0 , 1, 0, .F.},;	//"Pesquisar"
						{STR0047,"A650View"  , 0 , 2, 0, .F.},;	//"Visualizar"
						{STR0003,"A650Inclui", 0 , 3, 0, nil},;	//"Incluir"
						{STR0004,"A650Altera", 0 , 4, 0, nil},;	//"Alterar"
						{STR0005,"A650Deleta", 0 , 5, 0, nil},;	//"Excluir"
						{STR0002,"MATA650C", 0 , 6, 0, nil},;	//"venDas"
						{STR0166,"ViA650b"	, 0 , 2, 0, nil}}	//"Operações da Ordem"
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ mv_par01 - 1 = ALOCACAO PELO FIM      2 = ALOCACAO PELO INICIO ³
	//³ mv_par02 - Considera saldo apenas Local Padrao ? 1-sim  2-nao  ³
	//³ mv_par03 - Almoxarifado de (Usado p/compor o estoque atual)    ³
	//³ mv_par04 - Almoxarifado ate                                    ³
	//³ mv_par05 - Altera Prioridade das OPs Filhas tambem ?           ³
	//³ mv_par06 - Gera SC - Por Empenho / Por OP / Por Data           ³
	//³ mv_par07 - Altera Data Empenho/Ops Filhas ? Sim / Nao          ³
	//³ mv_par08 - Sugere Lotes a Empenhar Sim / Nao                   ³
	//³ mv_par09 - Grava Obs Ops Inter Sim / Nao                       ³
	//³ mv_par10 - Exclui OPs Filhas ? 1-Sim 2-NÆo                     ³
	//³ mv_par11 - Alt.todos Prod. Grd?                                ³
	//³ mv_par12 - Exc.todos Prod. Grd?                                ³
	//³ mv_par13 - Mostra tela alteracao empenhos                      ³
	//³ mv_par14 - Qtd. Nossa Poder 3o.  1-Ignora / 2-Soma             ³
	//³ mv_par15 - Qtd. 3o. Nosso Poder  1-Ignora / 2-Subtrai          ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	Pergunte("MTA650",.F.)
	//Salvar variaveis existentes
	For ni := 1 to 20
		aSav650[ni] := &("mv_par"+StrZero(ni,2))
	Next ni

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Ativa tecla F12 para acionar perguntas                         ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If ! ( l650Auto )
		SetKey(VK_F12, {||MTA650PERG(.T.)})
	EndIF
	lConsNPT  := (aSav650[14] == 1)
	lConsTerc := !(aSav650[15] == 1)

	//Chama a função MRPIntOp, para identificar se existe integração com o novo MRP.
	If FindFunction("Ma650MrpOn")
		Ma650MrpOn(@_lNewMRP)
	EndIf

	dbSelectArea("SC2")
	If ( l650Auto )
		nPos := aScan(aRotProd,{|x| x[1] == "MRP"})
		If ( nPos > 0 .and. aRotProd[nPos,2] == "S" )
			lProj711:=.T.
		Else
			lProj711:=.F.
		EndIf

		//Verifica se rotina está sendo chamado do programa novo de MRP
		nPos := aScan(aRotProd,{|x| x[1] == "MRPNOVO"})
		If (nPos > 0 .and. aRotProd[nPos,2] == "S" )
			lMata712 := .T.
		Else
			lMata712 := .F.
		EndIf

		//Verifica se rotina está sendo chamada pelo apontamento por produto - cria op automaticamente
		nPos := aScan(aRotProd,{|x| x[1] == "C2_BLQAPON"})
		If (nPos > 0 .and. aRotProd[nPos,2] == "1" )
			lPCPA113 := .T.
		Else
			lPCPA113 := .F.
		EndIf

		//Verifica se rotina está sendo chamado do programa novo de MRP Multi-Empresa
		nPos := aScan(aRotProd,{|x| x[1] == "MRPME"})
		If (nPos > 0 .and. aRotProd[nPos,2] == "S" )
			lPCPA107 := .T.
			nPos := aScan(aRotProd,{|x| x[1] == "PMP"})
			If nPos > 0
				lPmp107 := aRotProd[nPos,2]
			EndIf
			nPos := aScan(aRotProd,{|x| x[1] == "RECNO"})
			If nPos > 0
				nRec107 := aRotProd[nPos,2]
			EndIf
            nPos := aScan(aRotProd,{|x| x[1] == "C2_PRODUTO"})
			If nPos > 0
				cProd107 := aRotProd[nPos,2]
			EndIf
			nPos := aScan(aRotProd,{|x| x[1] == "PERIODO"})
			If nPos > 0
				cPeri107 := aRotProd[nPos,2]
			EndIf
		Else
			lPCPA107 := .F.
		EndIf

		nPos := aScan(aRotProd,{|x| x[1] == "AUTBACKX8"})
		If ( nPos > 0 .and. aRotProd[nPos,2] == .F. )
			lBackX8 := .F.
		Else
			lBackX8 := .T.
		EndIf

		nPos := aScan(aRotProd,{|x| x[1] == "ROTINA"})
		If ( nPos > 0 .AND. aRotProd[nPos,2] == "APS" )
			lRodaAPS :=.T.
		Else
			lRodaAPS :=.F.
		EndIf
		If ( nPos > 0 .AND. aRotProd[nPos,2] == "MNT" )
			lRunMnt :=.T.
		Else
			lRunMnt :=.F.
		EndIf

   		MBrowseAuto(nOpcAuto,aRotProd,"SC2",.F.)
	Else
		If nOpcAuto<>Nil
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Chamada direta da funcao ( Visualizacao,Alteracao,Exlcusao ) ³
			//³ atraves do nOpcAuto sem passar pela mBrowse.                 ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			nPosBlock := Ascan(aRotina,{|x| x[4]== nOpcAuto})
			If ( nPosBlock <> 0 )
				bBlock := &( "{ |x,y,z,k| " + aRotina[ nPosBlock,2 ] + "(x,y,z,k) }" )
				Eval( bBlock,Alias(),SC2->(Recno()),nPosBlock)
			EndIf
		Else
		aCorAux    := {	{ "A650DefLeg(1)", "BR_AMARELO" ,STR0151},; 	//"Prevista"
						{ "A650DefLeg(2)", "BR_VERDE",STR0152 },; 		//"Em aberto"
						{ "A650DefLeg(3)", "BR_LARANJA",STR0153 },; 	//"Iniciada"
						{ "A650DefLeg(4)", "BR_CINZA",STR0154 },; 		//"Ociosa"
						{ "A650DefLeg(5)", "BR_AZUL",STR0155 },; 		//"Encerrada parcialmente"
						{ "A650DefLeg(6)", "BR_VERMELHO",STR0156 }} 	//"Encerrada totalmente"

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ P.E. Utilizado para adicionar/alterar a legenda com a classi-³
			//³ ficacao do usuario.Lembrando que o array passado possui 3 di-³
			//³ menssoes para contemplar o titulo da legenda, e que a priori-³
			//³ dade de analise sempre sera as condicoes para legenda padrao.³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If ExistBlock('MA650LEG')
				aCorAux := aClone(ExecBlock('MA650LEG',.F.,.F.,{aCorAux}))
			EndIf

			aCores    := {}
			aLegenda  := {}
			For ni:=1 To Len(aCorAux)
				aadd(aCores,{aCorAux[ni,1],aCorAux[ni,2]})
				aadd(aLegenda,{aCorAux[ni,2],If(Empty(aCorAux[ni,3]),"-",aCorAux[ni,3])})
			Next ni

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³P.E. Utilizado para inclusao de filtro do usuario no browse   ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If lMA650FBW
				cCondFil := ExecBlock('MA650FBW',.F.,.F.)
			EndIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Endereca a funcao de BROWSE                                  ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Ponto de entrada para verificacao de filtros na Mbrowse      ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If  ExistBlock("M650FILB")
				cFiltro := ExecBlock("M650FILB",.F.,.F.)
				If Valtype(cFiltro) <> "C"
					cFiltro := ""
				EndIf
			EndIf

			mBrowse( 6, 1,22,75,"SC2",,,,,,aCores,,,,,,,, IF(!Empty(cFiltro),cFiltro, NIL),,,,cCondFil)
		EndIf
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Desativa tecla que aciona perguntas                            ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If ! ( l650Auto )
		Set Key VK_F12 To
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica se existe OP's Intermediarias para geracao          ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

	//If l650Auto
		//Marca o semaforo
		If lUsaSemaf
			lRet := MATA650LCK()
			If !lRet
				Return nil
			EndIf
		EndIf
	//EndIf
	aIntegPPI := {}

	DbSelectArea("SC2")
	If lGeraInter .And. vldRegOPI(@lGerar, l650Auto, aRotProd)
		a650RegOPI(@lGerar, @nOps,,@aFilial)
	EndIf
	If lGerar
		//proteção para armazém em branco vazio.
		If aSav650[2] == 2  .And. Empty(aSav650[4])
			aSav650[4] :=  Replicate("Z",tamsx3("B2_LOCAL")[1])
		EndIf
		//proteção para armazém preenchido caso não utilizar o padrão.
		If l650Auto
			nPos := aScan(aRotProd,{|x| x[1] == "AUTEXPLODE"})
			If ( nPos > 0 .and. aRotProd[nPos,2] == "S" )
				nOpc := 1

				//Se o parâmetro GERAEMP estiver como N, não será gerado nenhum empenho para a ordem de produção.
				//A geração dos empenhos será feita posteriormente pelo mata380/mata381
				nPos := 0
				nPos := aScan(aRotProd,{|x| x[1] == "GERAEMP"})
				If ( nPos > 0 .and. aRotProd[nPos,2] == "N" )
					nOpc := 2
					Reclock("SC2",.F.)
					Replace C2_BATCH  With "S"
					Replace C2_BATROT  With FunName()
					MsUnLock()
				EndIf
			Else
				nOpc := 2
			EndIf
		Else
			MTA650OK(@nOpc)
		EndIf
		If nOpc == 1

			For nI := 1 To Len(aFilial)
				If aFilial[nI,2] < 1
					Loop
				EndIf
				cFilAnt := aFilial[nI,1]

				DbSelectArea("SC2")
				//If lMult650 .And. !lProj711
				//	StartJob("MA650JProc",GetEnvServer(),.F.,@lEnd, cEmpAnt,cFilAnt, nOps, RetCodUsr())
				//Else
					If ( l650Auto )
						MA650Process(@lEnd,nOps)
					Else
					    If Len(aFilial) > 1
							cTitle := AllTrim(STR0007) + ". " + AllTrim(STR0181) + aFilial[nI,1] //"Gera‡„o de OPs Intermediarias e SCs. Filial: 01"
						Else
							cTitle := AllTrim(STR0007) //"Gera‡„o de OPs Intermediarias e SCs"
						EndIf
						Processa({|lEnd| MA650Process(@lEnd,nOps)},STR0007,OemToAnsi(STR0008),.F.) 	//"Gera‡„o de OPs Intermediarias e SCs"###"Gerando OPs Intermediarias e SCs..."
						If Len(aIntegPPI) > 0
							cMsg := STR0182 + CHR(10) //"Atenção! Ocorreram erros na integração com o PCFactory. Erro: "
							For ni := 1 To Len(aIntegPPI)
								cMsg += STR0195 + AllTrim(aIntegPPI[ni,1]) + " - " + AllTrim(aIntegPPI[ni,2]) + CHR(10)
							Next ni
							Aviso(STR0186,cMsg,{"Ok"},3)
						EndIf
					EndIf
	                //EndIf
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Ponto de entrada executado apos o processamento da inclusao  ³
				//³ da Op e os pedidos de compras.                               ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If (ExistTemplate("A650PROC"))
					ExecTemplate('A650PROC',.F.,.F.)
				EndIf

				If (ExistBlock("A650PROC"))
					ExecBlock('A650PROC',.F.,.F.)
				EndIf
			Next nI
			cFilAnt := cBkpFilial
		EndIf
	EndIf

	//Integra com o LS a métrica - Quantidade média de componentes por ordem de produção manual
	If Type("nMetricEmp") == "N" .And. nMetricEmp > 0
		If !lProj711 .And. !lMata712 .And. !lPCPA107 .And. !lOpVendas .And. !l650Auto
			If Findfunction("PCPMETRIC")
				PCPMETRIC("MATA650", {{"manufatura-protheus_volume-medio-de-empenhos-por-op-manual_average", nMetricEmp }})
			EndIf
		EndIf
	EndIf

	dbSelectArea(cAlias)

	//If l650Auto
		//Libera semaforo
		If lUsaSemaf
			UnLockByName("650USOGOP",.T.,.T.)
		EndIf
	//EndIf
EndIf

If l650Auto .and. !lProj711 .and. !lMata712 .and. !lPCPA107 .and. snTotNewOp > 0
	aAdd(aMetrics, "sigapcp-protheus_quantidade-de-ordens-de-producao-geradas-por-integracao_total")
	aAdd(aMetrics, snTotNewOp)

	PCPMETRIC("MATA650", aMetrics, .F., .T., "MATA650")
EndIf
RETURN


/*-------------------------------------------------------------------------/
//Programa:	 RodaAPS
//Autor:	 Mateus Hengle
//Data:		 28/07/2023
//Descricao: Valida se a variável lRodaAPS existe
//Uso: 		 MATA650
//------------------------------------------------------------------------*/
Static Function RodaAPS()

Local lAPS := .F.

IF Type("lRodaAPS") == "L"
	lAPS := lRodaAPS
ENDIF

Return lAPS



/*-------------------------------------------------------------------------/
//Programa:	MATA650LCK
//Autor:	Michele Girardi
//Data:		07/07/2014
//Descricao:Cria semaforo para as tabelas
//Uso: 		MATA650
//------------------------------------------------------------------------*/
Function MATA650LCK()
Local nTentativa := 0

While !LockByName("650USOGOP",.T.,.T.)
	nTentativa ++
	If nTentativa > 99000
		Return .F.
		Exit
	EndIf
End

Return .T.

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³MA650Process³ Autor ³ Rodrigo de A. Sartorio³ Data ³28/12/95³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Gera OPs intermediarias e SCs    		                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA650                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function MA650Process(lEnd,nOps,lOrcamento, cCodUsr)
A650RunBatch(nOps,lOrcamento, cCodUsr)
RETURN

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³A650Deleta³ Autor ³ Eveli Morasco         ³ Data ³ 27/11/92 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Programa de Delecao de O.Ps                                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ A650Deleta(ExpC1,ExpN1,ExpN2)                              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Alias do arquivo                                   ³±±
±±³          ³ ExpN1 = Numero do registro                                 ³±±
±±³          ³ ExpN2 = Opcao selecionada no menu                          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Mata650                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
*/
Function A650Deleta(cAlias,nReg,nOpc,aCpo,cProgOrig,lProcessou,aMRPxJson)

Local nOpcA
Local lMTA650ET := ExistTemplate( "MTA650E" )
Local lMTA650E  := (ExistBlock( "MTA650E" ) )
Local lMA650ENOT:= (ExistBlock( "MA650ENOT" ))
Local lIntACD	:= SuperGetMV("MV_INTACD",.F.,"0") == "1"
Local lProcessa :=.T.
Local oDlg
Local lPar, cNum, cItem, cSeq
Local lMonta    := .F.
Local nQuant    := 0
Local nQuant2UM := 0
Local bCampo    := {|nCpo| Field(nCpo) }
Local cMascara	:= SuperGetMv("MV_MASCGRD")
Local nTamRef	:= Val(Substr(cMascara,1,2))
Local aAreaSC2  := SC2->(GetArea())
Local cItemGrd
Local lExcGra   := .F.
Local aBut650   := {}
Local lRet
Local i         := 0
Local lIntQIP   := If(cModulo=="QIP",IntQIP(SC2->C2_PRODUTO,,"E"),IntQIP(SC2->C2_PRODUTO))
Local cOPExc    := ""
Local aSize    := {}
Local aInfo    := {}
Local aObjects := {}
Local lRetorno := .T.
Local cFilSC2  := xFilial("SC2")
Local cFiltro  := ""

Local lDelTBMRP  := _lNewMRP == NIL
Local lIntLocal  := aMRPxJson  == NIL
Local lIntNewMRP := Iif(_lNewMRP  == Nil, FindFunction("Ma650MrpOn") .AND. Ma650MrpOn(@_lNewMRP),_lNewMRP)
Local lWMSSaas   := FindFunction("WMSSaasHas") .And. WMSSaasHas()

Private lRetSFC := .T.

Default l650Auto := .F.
Default aMRPxJson  := Iif(lIntNewMRP, {{}, JsonObject():New()}, Nil) //{aDados para commit, JsonObject() com RECNOS} - Integracao Novo MRP - APONTAMENTOS

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Verifica se o usuario tem permissao para deletar produto ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If !(lRetorno := MaAvalPerm(1,{SC2->C2_PRODUTO,"MTA650",5}))
	Help(,,1,"SEMPERM")
EndIf

//Verifica se a origem da OP é produto 'RM' não permitir excluir a OP manualmente
If lRetorno .And. !l650Auto .And. AllTrim( SC2->C2_PROGRAM) == 'RM'
	Help( ,, 'Help',,STR0218, 1, 0 ) //A OP não poderá ser excluída por ter sua origem no produto RM.
	lRetorno := .F.
EndIf

//Verifica se existem Pedido de Compra Confirmados e impede a exclusão.
If fFindPC(SC2->C2_NUM,SC2->C2_ITEM,SC2->C2_SEQUEN)
	//Se Achou Pedido de Compra não é possível a exclusão.
	Help(NIL, NIL, STR0079, NIL, STR0208 +SC2->C2_NUM+SC2->C2_ITEM+SC2->C2_SEQUEN,;
		1, 0, NIL, NIL, NIL, NIL, NIL, {STR0209})
		//"Não é possivel excluir a Ordem de Produção. Existem Pedidos de Compras com situação de Confirmado vinculados à Ordem de Produção: "
		// "Favor verificar situação do Pedido de Compra para realizar a exclusão da Ordem de Produção."
  	lRetorno := .F.
EndIF

If lRetorno .And. IsProdProt(SC2->C2_PRODUTO) .And. !IsInCallStack("DPRA340INT")
	Aviso(STR0024,STR0160,{"OK"}) //-- Protótipos podem ser manipulados somente através do módulo Desenvolvedor de Produtos (DPR).
	lRetorno := .F.
EndIf

//-- Tratamento de Exclusão de OP de requisições WMS
If lRetorno .And. IntWms()
	lRetorno := WmsAvalSC2("3",,,,,SC2->(Recno()))
EndIf

//-- Validacoes para permitir exclusão de OP com integracao WMS SaaS
If lRetorno .And. lWMSSaas .And. FindFunction("WMSSVExcOP")
	lRetorno := WMSSVExcOP(SC2->(Recno()))
EndIf

// Validação SIGAMNT para evitar exclusão com MNT de origem ( C2_BATROT )
If !IsBlind() .And. !l650Auto .And. AllTrim( SC2->C2_ITEM ) == 'OS' .And. AllTrim( SC2->C2_SEQUEN ) == '001' .And.;
	SubStr( AllTrim( SC2->C2_BATROT ), 1, 3 ) $ 'MNT#RPC'

	/*
		Quando acionado pela rotina MATA740 que realiza a exclusão de O.P. armazena a mensagem para
		apresentação posterior
	*/
	If !FWIsInCallStack( 'MATA740' )

		Help( '', 1, 'MNTSC2', , STR0205,; // A OP não poderá ser excluida por ter sua origem no Manutenção de Ativos (SIGAMNT)
			2, 0, , , , , , { STR0206 } )  // O registro somente poderá ser excluído pelo módulo de Manutenção de Ativos

	EndIf

	lRetorno := .F.

EndIf

//Verifica se tem Ordens Efetivadas no CRP tabela HWF
If lRetorno .And. UsaCRP() .And. !IsBlind() .And. IsInCallStack("MATA650")
	cFiltro += " AND HWF.HWF_OP LIKE '" + SC2->C2_NUM + "%'"
	cFiltro += " AND SC2.C2_SEQUEN >= '" +  SC2->C2_SEQUEN + "'"
	lRetorno := PCPA152Efetivacao():abreTela(cFiltro)
Endif

If lRetorno
	If cProgOrig == NIL
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Verifica se devera' excluir ou nao todos os itens da Grade      ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		lExcGra  := If(aSav650[12]==1, .T. , .F.)
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Monta a entrada de dados do arquivo                          ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	PRIVATE aTELA[0][0],aGETS[0]
	PRIVATE aRatAFM		:= {}					//Variavel utilizada pela Funcao PMSDLGOP - Gerenc. Projetos
	PRIVATE bPMSDlgOP	:= {||PmsDlgOP(5,SC2->C2_NUM,SC2->C2_ITEM,SC2->C2_SEQUEN)} // Chamada da Dialog de Gerenc. Projetos

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Botao para exportar dados para EXCEL                    ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If RemoteType() == 1
		aAdd(aBut650,{PmsBExcel()[1],{|| DlgToExcel({{"ENCHOICE",cCadastro,aGets,aTela}})},PmsBExcel()[2],PmsBExcel()[3]})
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Executa ponto de entrada para montar array com botoes a      ³
	//³ serem apresentados na tela de exclusao                       ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If (ExistBlock("M650BCHOI"))
		aBut650:=ExecBlock("M650BCHOI",.F.,.F.)
		If ValType(aBut650) # "A"
			aBut650:={}
		EndIf
	Endif

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Se for deletar todos os itens da Grade, a Enchoice sera' mon-³
	//³ tada de acordo com as variaveis de memoria, caso contrario,  ³
	//³ sera' montada baseando-se no registro corrente no SC2        ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

	If IntePms().AND. !lPmsInt		// Se usa PMS integrado com o ERP
		Aadd(aBut650,{'PROJETPMS',{||Eval(bPmsDlgOP)},OemToAnsi(STR0071),OemToAnsi(STR0117) }) //"Gerenciamento de Projetos" //"Projetos"
	Endif

	If lIntQIP //Define a integracao com o QIP
		Aadd(aBut650,{"RELATORIO",{|| QP650HIS(SC2->C2_NUM,SC2->C2_ITEM,SC2->C2_SEQUEN,SC2->C2_CHAVE)},OemToAnsi(STR0087),OemToAnsi(STR0118)}) //"Observação da Ordem de Produção..." //"Observação"
	EndIf

	AAdd(aBut650,{ "bmpord1", {|| A650Track() },STR0102} ) // Botao System Tracker

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Salva a integridade dos campos de Bancos de Dados            ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	RestArea(aAreaSC2)
	FOR i := 1 TO FCount()
		M->&(EVAL(bCampo,i)) := FieldGet(i)
	NEXT i

	If lExcGra  .And. !EMPTY(SC2->C2_ITEMGRD)
		lMonta := .T.
		cNum := SC2->C2_NUM
		cItem:= SC2->C2_ITEM
		cSeq := SC2->C2_SEQUEN
		dbSeek(cFilSC2+SC2->C2_NUM+SC2->C2_ITEM+SC2->C2_SEQUEN)
		aAreaSC2:=SC2->(GetArea())
		Do While !Eof() .And. C2_FILIAL+SC2->C2_NUM+SC2->C2_ITEM+SC2->C2_SEQUEN == cFilSC2+cNum+cItem+cSeq
			nQuant+= (C2_QUANT-C2_QUJE-C2_PERDA)
			nQuant2UM += C2_QTSEGUM
			dbSkip()
		EndDo
		RestArea(aAreaSC2)
		M->C2_PRODUTO := Substr(M->C2_PRODUTO,1,nTamRef)
		M->C2_QUANT   := nQuant
		M->C2_QTSEGUM := nQuant2UM
		M->C2_OPC     := " "
		M->C2_ITEMGRD := " "
	EndIf

	If SuperGetMv("MV_SELEOPC") == "S"
      AAdd(aBut650,{, {|| A650Opc() },STR0175} ) // Botao Opcionais
   EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Envia para processamento dos Gets.                           ³
	//³ Pcount() retorna num. de parametros enviados na chamada da   ³
	//³ funcao. Se Pcount() >= 5 foi chamado pelo mata740 (cancel.Op)³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Se for rotinas automaticas atualiza a nopca com 2 e nao deve ³
	//³ montar a janela                                              ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

	aAreaSC2:=SC2->(GetArea())
	If PCount() < 5 .and. (Type("l650Auto") # "L" .or. !l650Auto)
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Ajusta a largura para o tamanho padrao Protheus ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		aSize := MsAdvSize()
		aObjects := {}
		AAdd( aObjects, { 100, 100, .T., .T. } )
		aInfo    := { aSize[1], aSize[2], aSize[3], aSize[4], 2, 2 }
		aPosObj := MsObjSize( aInfo, aObjects )

		DEFINE MSDIALOG oDlg TITLE cCadastro FROM aSize[7],0 TO aSize[6],aSize[5] OF oMainWnd PIXEL
		nOpcA:=EnChoice( cAlias, nReg, 5,,,,,aPosObj[1],,,,,,,,lMonta)	//"Quanto „ Exclus„o?"
			ACTIVATE MSDIALOG oDlg ON INIT EnchoiceBar(oDlg,{|| nOpca := 2,oDlg:End()},{|| nOpca := 1,oDlg:End()},,aBut650)
	Else
		nOpcA := 2
	EndIf
	cNum     := SC2->C2_NUM
	cItem    := SC2->C2_ITEM
	cSeq     := SC2->C2_SEQUEN
	cItemGrd := SC2->C2_ITEMGRD

	If nOpcA == 2

		If lExcGra .And. !Empty(SC2->C2_ITEMGRD)
			dbSeek(cFilSC2+cNum+cItem)
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Integracao TOTVS APS: deleta Operacoes X Ordem (SHY) 	     ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		//TAPSOperac(cNum+cItem+cSeq+cItemGrd,,,,.F.)

		RestArea(aAreaSC2)
		While !Eof() .And. C2_FILIAL+C2_NUM+C2_ITEM+C2_SEQUEN == cFilSC2+cNum+cItem+cSeq

			If !lExcGra .And. SC2->C2_ITEMGRD!=cItemGrd
				dbSkip()
				loop
			EndIf

			//Integração ACD x SFC - Verifica se a OP já teve apontamento iniciado no ACD.
			//Se tiver, não permite a exclusão da ordem.
			If lProcessa
				lProcessa := vldOpACD()
			EndIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ integracao com o ACD - Faz Validacao da  exclusao da OP 	 	 ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If lProcessa .And. lIntACD
				lProcessa:= CBMTA650E()
				If !(ValType(lProcessa) == "L")
					lProcessa := .T.
				EndIf
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Template acionando Ponto de entrada                ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			ElseIf lProcessa .And. lMTA650ET
				lProcessa:= ExecTemplate("MTA650E",.F.,.F.)
				If !(ValType(lProcessa) == "L")
					lProcessa := .T.
				EndIf
			EndIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Ponto de entrada anterior a exclusao - MTA650E      ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If lProcessa .and. lMTA650E
				lProcessa:= ExecBlock("MTA650E",.F.,.F.)
				If !(ValType(lProcessa) == "L")
					lProcessa := .T.
				EndIf
			EndIf

			If lProcessa .And. A650ChkComp(SC2->C2_NUM,SC2->C2_ITEM,SC2->C2_SEQUEN,SC2->C2_ITEMGRD)
				lPar:=Iif(PCount() < 5,.T.,.F.)
				// Verifica se foram geradas as OPs Filhas, SCs, Demandas, etc.
				cOPExc := SC2->(C2_NUM+C2_ITEM+C2_SEQUEN+C2_ITEMGRD)
				DbSelectArea("SC2")

				Begin Transaction
					A650DelOp(lPar,@cAlias,@lProcessou,lExcGra,cProgOrig,@aMRPxJson)
					If !lRetSFC .and. InTransact()
						DisarmTransaction()
					EndIf
				End Transaction

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ TS2101 - VIVIAN - 14/04/2015                                   ³
				//³ Ponto de entrada apos a exclusao fora da transação - MA650ENOT ³	    ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If lMA650ENOT
					ExecBlock("MA650ENOT",.F.,.F.,{cNum,cItem,cSeq})
				EndIf

				If lProcessou
					Exit
				EndIf
				// Caso nao tenha excluido, aplica skip para nao ficar em loop
				If cOPExc == SC2->(C2_NUM+C2_ITEM+C2_SEQUEN+C2_ITEMGRD)
					SC2->(dbSkip())
				EndIf
			ElseIf !lProcessa .Or. !lRet
				Exit
			EndIf
		EndDo
	Else
		If ( (ExistBlock("M650CAN")) )
			ExecBlock("M650CAN",.f.,.f., {3})
		EndIf
	EndIf
EndIf

//Chama integração de empenhos com novo MRP
If lIntNewMRP .AND. lIntLocal
	enviaOpMrp("INSERT", @aMRPxJson, lDelTBMRP)
EndIf

dbSelectArea("SC2")
RETURN .T.

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³A650Inclui³ Autor ³ Claudinei M. Benzi    ³ Data ³          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Programa de inclusao  de O.P.s                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ Void A650Inclui(ExpC1,ExpN1,ExpN2,ExpC2)                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Alias do arquivo                                   ³±±
±±³          ³ ExpN1 = Numero do registro                                 ³±±
±±³          ³ ExpN2 = Opcao selecionada no menu                          ³±±
±±³          ³ ExpL1 = Se .T. atualiza Projecao de Estoques               ³±±
±±³          ³ ExpC2 = Campo a ser atualizado na Projacao de Estoques     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Mata650                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
*/
Function A650Inclui(cAlias,nReg,nOpcx,aCpo,aX,cCpoProj,cTpOp)
Local aAuxArea  := GetArea()
Local aBut650   := {}
Local aCpsRPC   := {}
Local cCpsRPC   := "C2_VERIFI*"
Local cItem
Local lProj := .F.
Local lEsc      := .F.
Local lIntQIP   := If(cModulo=="QIP",.T.,IntQIP())

Local nOpca

//Salva Registros de controle de numeracao
Local aParam    := {{|| aOPNova[1]:=M->C2_NUM },; //1-Apos inicializar os campos
                    {|| aOPNova[2]:=M->C2_NUM,Iif(aOPNova[2]!=aOPNova[1],Iif(Type("lBackX8")!="L" .Or. (Type("lBackX8")=="L" .And. lBackX8),RollBackSx8(),.T.),.T.),.T.},; //2-Para validar a Janela
                    {|| aOPNova[2]:=M->C2_NUM},; //3-Processamento de codeblock dentro da transacao APOS GRAVAR a OP
                    {|| .T.}} //4-Processamento de codeblock fora da transacao APOS GRAVAR a OP

Local lIntNewMRP := Iif(_lNewMRP == Nil, FindFunction("Ma650MrpOn") .AND. Ma650MrpOn(@_lNewMRP),_lNewMRP)
Local aMRPxJson  := Iif(lIntNewMRP, {{}, JsonObject():New()}, Nil)

PRIVATE aRetorOpc   := {}
PRIVATE aHeader		:= {}
PRIVATE acols		:= {}
PRIVATE aColsRot    := {}
PRIVATE lGrade		:= MaGrade()
PRIVATE lOpQIP      := .T.
PRIVATE aRatAFM		:= {}					//Variavel utilizada pela Funcao PMSDLGOP - Gerenc. Projetos
PRIVATE bPMSDlgOP	:= {||PmsDlgOP(3,M->C2_NUM,M->C2_ITEM,M->C2_SEQUEN)} // Chamada da Dialog de Gerenc. Projetos
PRIVATE lAltEsp		:= .F. // Indica se ‚ a 1a. Entrada ap¢s alteracao especificacao
PRIVATE N // Variavel utilizada na inclusao de armazens pela consulta padrao

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Cria Ambiente/Objeto para tratamento de grade        ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
PRIVATE oGrade	  := MsMatGrade():New("oGrade",,"C2_QUANT",,"aVldGrade('A650')",, ;
					{	{"C2_QUANT"		,.T. ,{	{"C2_QTSEGUM"	,{|| ConvUm(AllTrim(oGrade:GetNameProd(,nLinha,nColuna)),aCols[nLinha][nColuna],0,2) } }},.T. }, ;
						{"C2_QTSEGUM"	,NIL ,{	{"C2_QUANT"		,{|| ConvUm(AllTrim(oGrade:GetNameProd(,nLinha,nColuna)),0,aCols[nLinha][nColuna],1) } }},.F. },;
						{"C2_OPC"		,NIL ,NIL}, ;
						{"C2_ROTEIRO"	,NIL ,NIL};
					})
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Botao para exportar dados para EXCEL                    ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If RemoteType() == 1
	aAdd(aBut650,{PmsBExcel()[1],{|| DlgToExcel({{"ENCHOICE",cCadastro,aGets,aTela}})},PmsBExcel()[2],PmsBExcel()[3]})
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Executa ponto de entrada para montar array com botoes a      ³
//³ serem apresentados na tela de inclusao                       ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If (ExistBlock("M650BCHOI"))
	aBut650:=ExecBlock("M650BCHOI",.F.,.F.)
	If ValType(aBut650) # "A"
		aBut650:={}
	EndIf
Endif

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Verifica se a rotina esta sendo chamada da Proj.Estoques   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If cCpoProj != NIL
	lProj := .T.
EndIf

If ValType(aX) != "L"
	aX := .F.
EndIf

Private cSeqC2 :="001", cNumOp, cItemOp , cLocal

If ( Type("l650Auto")=="L" .and. l650Auto )

	//Variável para não apresentar o Help QA_NREVDIS desnecessariamente
	lMt650RevDis := .T.
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Tratamento WebService desconsiderar campos obrigatorios de outros modulos	³
	//| ** Estes campos devem ser adicionados na variavel cCpsRPC					|
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If AllTrim(FunName()) == "RPC"
		aEval(aRotProd,{|x| If(Substr(x[1],1,3) == "C2_" .And. !(AllTrim(x[1]) $ cCpsRPC), aAdd(aCpsRPC,x[1]),.F.)})
	EndIf
	nOpca := AxInclui(cAlias,nReg,nOpcx,,,aCpsRPC,"A650TudoOK()",,"A650AtuInc()",aBut650,aParam,aRotProd)
Else
	//Variável para não apresentar o Help QA_NREVDIS desnecessariamente
	lMt650RevDis := .F.
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Envia para rotina de inclusao de OPs (Exceto Proj. Estoques) ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If (lProj==.F.) .and. (aX == .F.)

		If IntePms().AND. !lPmsInt		// Se usa PMS integrado com o ERP
			AADD(aBut650,{'PROJETPMS',{||Eval(bPmsDlgOP)},OemToAnsi(STR0071),OemToAnsi(STR0117) }) //"Gerenciamento de Projetos"
		Endif
		If lIntQIP //Define a integracao com o QIP
			Aadd(aBut650,{"RELATORIO",{|| QP650HIS(M->C2_NUM,M->C2_ITEM,M->C2_SEQUEN,M->C2_CHAVE)},OemToAnsi(STR0087),OemToAnsi(STR0118)}) //"Observação da Ordem de Produção..."
		EndIf

		nOpca := AxInclui(cAlias,nReg,nOpcx,,,,"A650TudoOK()",,,aBut650,aParam)
	Else
		nOpca := 1
	EndIf
EndIf

If __lSX8
	If nOpcA == 1
		ConfirmSX8()
	Else
		RollBackSx8()
	EndIf
EndIf

dbSelectArea("SC2")
If nOpca == 1
	snTotNewOP++
	aAuxArea  := GetArea()

	A650AtuInc()

	//Integração de ordem de produção com o novo MRP.
	//Operação de INCLUSÃO/ALTERAÇÃO.
	If lIntNewMRP
		A650AddJIn(@aMRPxJson) //Inclui dados no array para integração com o novo MRP
		enviaOpMrp("INSERT", @aMRPxJson)
	EndIf

	If SC2->C2_TPOP == "F" .And. IntQIP(SC2->C2_PRODUTO,"1",If(cModulo=="QIP","E","T")) .And. GetNewPar("MV_QPIMPPL","S") == "S" .And. (Type("l650Auto") # "L" .or. !l650Auto) .and. lOpQIP
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Faz a Impressao da Ficha de Produto  -  USO                               ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If !Pergunte("QPR041", .T. )
			lEsc	:= .T.
		EndIf
		If !lEsc .And. mv_par01 == 1
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Ponto de Entrada para execucao do relatorio Customizado                         ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If ExistBlock("QIPR041")
				ExecBlock("QIPR041",.F.,.F.,{"MATA650",SC2->C2_NUM+SC2->C2_ITEM+SC2->C2_SEQUEN})
			Else
				QIPR040("MATA650",SC2->C2_NUM+SC2->C2_ITEM+SC2->C2_SEQUEN,"","")
			EndIf

		EndIf
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Retorna a pergunta Original                                               ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		Pergunte("MTA650",.F.)
		dbSelectArea('SC2')
	EndIf

	If (ExistBlock( "MTA650I" ) )
		ExecBlock("MTA650I",.F.,.F.)
	Endif

	cNumOp:= SC2->C2_NUM
	cItem := SC2->C2_ITEM
	If (lProj==.F.) .and. (aX == .F.)
		Do While !SC2->(EOF()) .And. SC2->C2_FILIAL+SC2->C2_NUM+SC2->C2_ITEM == xFilial('SC2')+cNumOp+cItem
			dbSelectArea("SB2")
			dbSetOrder(1)
			If !MsSeek(xFilial("SB2")+SC2->C2_PRODUTO+SC2->C2_LOCAL)
				CriaSB2(SC2->C2_PRODUTO,SC2->C2_LOCAL)
				MsUnlock()
			EndIf
			GravaB2Pre("+",SC2->C2_QUANT,SC2->C2_TPOP,SC2->C2_QTSEGUM)
			dbSelectArea("SC2")
			A650PutBatch(C2_FILIAL+C2_NUM+C2_ITEM+C2_SEQUEN+C2_ITEMGRD,,SC2->C2_DATPRI,SC2->C2_DATPRF)
			// Verifica item da grade
			If Empty(SC2->C2_ITEMGRD)
				Exit
			EndIf
			SC2->(dbSkip())
		EndDo
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Execblock a ser executado apos gravacao do arquivo BATCH     ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		IF ExistBlock('MA650PBAT')
			ExecBlock('MA650PBAT',.F.,.F.)
		Endif
	Else
		A650WriteOp(lProj,aX,cCpoProj,cTpOp)
	EndIf
Else
	If ( (ExistBlock("M650CAN")) )
		ExecBlock("M650CAN",.f.,.f., {1})
	EndIf
EndIf

RestArea(aAuxArea)
Return

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³A650AtuInc³ Autor ³ Edson Maricate        ³ Data ³13-06-2001³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Funcao chamada pela Axinclui para atualizacao das tabelas   ³±±
±±³          ³relacionadas com a inclusao de ordens de producao.          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³A650AtuInc()                                                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³Nenhum                                                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³Mata650,AxInclui                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
*/
Function A650AtuInc()
Local aArea    := GetArea()
Local cRoteiro := ""
Local lLite    := .F.
Local nSEQPAI  := 0

Begin Transaction
	//-- Tratamento para WebService
	If Type('cWSMAT650') == "C"
		cWSMAT650 := SC2->(C2_NUM+C2_ITEM+C2_SEQUEN+C2_ITEMGRD)

		//-- Tratamentos para integracao com Totvs APS
		If SuperGetMV("MV_APS",.F.,"") == "TOTVS" .And. !Empty(SC2->C2_IDAPS)
			//-- Se possui sequencia pai, atualiza D4_OPORIG do empenho da OP pai
			If (nSEQPAI := aScan(aRotProd,{|x| AllTrim(x[1]) == "C2_SEQPAI"})) > 0
				SD4->(dbSetOrder(1))
				If SD4->(dbSeek(xFilial("SD4")+SC2->(C2_PRODUTO+C2_NUM+C2_ITEM)+aRotProd[nSEQPAI,2]))
					RecLock("SD4",.F.)
					SD4->D4_OPORIG := SC2->(C2_NUM+C2_ITEM+C2_SEQUEN)
					SD4->(MsUnLock())
				EndIf
			EndIf

			//-- Se possui filhas ja incluidas, atualiza D4_OPORIG do empenho da OP
			BeginSQL Alias "TRB"
				SELECT C2_NUM, C2_ITEM, C2_SEQUEN, C2_ITEMGRD, C2_PRODUTO
				FROM %Table:SC2%
				WHERE %NotDel% AND C2_FILIAL = %xFilial:SC2% AND C2_NUM = %Exp:SC2->C2_NUM% AND
					C2_ITEM = %Exp:SC2->C2_ITEM% AND C2_SEQPAI = %Exp:SC2->C2_SEQUEN%
			EndSQL

			SD4->(dbSetOrder(1))
			While !TRB->(EOF())
				SD4->(dbSeek(xFilial("SD4")+TRB->(C2_PRODUTO+C2_NUM+C2_ITEM)+SC2->(C2_SEQUEN+C2_ITEMGRD)))
				While SD4->(EOF()) .And. SD4->(D4_FILIAL+D4_COD+D4_OP) == xFilial("SD4")+TRB->C2_PRODUTO+SC2->(C2_NUM+C2_ITEM+C2_SEQUEN+C2_ITEMGRD)
					If Empty(SD4->D4_OPORIG)
						RecLock("SD4",.F.)
						SD4->D4_OPORIG := TRB->(C2_NUM+C2_ITEM+C2_SEQUEN+C2_ITEMGRD)
						SD4->(MsUnLock())
						Exit
					EndIf
					SD4->(dbSkip())
				End
				TRB->(dbSkip())
			End
			TRB->(dbCloseArea())

			//-- Atualiza numero da OP em SCs recebidas antes da OP
			BeginSQL Alias "TRB"
				SELECT R_E_C_N_O_ SC1RECNO
				FROM %Table:SC1%
				WHERE %NotDel% AND C1_FILIAL = %xFilial:SC1% AND C1_OP = %Exp:CriaVar("C1_OP",.F.)% AND
					C1_IDAPS = %Exp:SC2->C2_IDAPS%
			EndSQL
			While !TRB->(EOF())
				SC1->(dbGoTo(TRB->SC1RECNO))
				RecLock("SC1",.F.)
				SC1->C1_OP := SC2->(C2_NUM+C2_ITEM+C2_SEQUEN+C2_ITEMGRD)
				SC1->(MsUnLock())

				TRB->(dbSkip())
			End
			TRB->(dbCloseArea())

			//-- Atualiza numero da OP em operacoes recebidas antes da OP
			BeginSQL Alias "TRB"
				SELECT R_E_C_N_O_ SHYRECNO
				FROM %Table:SHY%
				WHERE %NotDel% AND HY_FILIAL = %xFilial:SHY% AND HY_OP = %Exp:CriaVar("HY_OP",.F.)% AND
					HY_IDAPS = %Exp:SC2->C2_IDAPS%
			EndSQL
			While !TRB->(EOF())
				SHY->(dbGoTo(TRB->SHYRECNO))
				RecLock("SHY",.F.)
				SHY->HY_OP := SC2->(C2_NUM+C2_ITEM+C2_SEQUEN+C2_ITEMGRD)
				SHY->(MsUnLock())

				TRB->(dbSkip())
			End
			TRB->(dbCloseArea())

			If PCPIntgPPI("SC2", @lLite)
				If !lLite .Or.;
				   (lLite .And. totvs.protheus.manufacturing.meslite.productionorder.permiteIntegrarOrdem(cWSMAT650, "SC2", SC2->C2_PRODUTO))
					//Criação da SOJ indicando que as OP´s vindas do APS ainda não foram integradas com o TOTVS MES
					//Elas serão integradas com a execução do PCPA114 no schedule
					PCPA114APS(SC2->C2_NUM,SC2->C2_ITEM,SC2->C2_SEQUEN,SC2->C2_ITEMGRD,'N')
				EndIf
			EndIf
		 EndIf
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Gera integracao com Inspecao de Processos (QIP), caso exista ³
	//| Obs: funcao OPGeraQIP esta contida no PCPXFUN.				 ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	OPGeraQIP()

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Grava no SC2 os Itens Informados na Grade                    ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lGrade .And. Len(aCols) > 0
		Ma650GraGr("SC2","A650",.T.)
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Executa a atualizacao das tabelas do SIGAPMS 1-Inclusao      ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	dbSelectArea("SC2")
	PmsWriteOP(1,"SC2")

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Integracoes TOTVS APS e SFC: gera Operacoes X Ordem (SHY)    ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If Empty(cRoteiro := SC2->C2_ROTEIRO)
		If Empty(cRoteiro := Posicione("SB1",1,xFilial("SB1")+SC2->C2_PRODUTO,"B1_OPERPAD"))
			cRoteiro := StrZero(1,TamSX3("G2_CODIGO")[1])
		EndIf
	EndIf
	SC2->(TAPSOperac(C2_NUM+C2_ITEM+C2_SEQUEN+C2_ITEMGRD,C2_PRODUTO,cRoteiro,C2_QUANT))

	If lIntSFC
		A650IntSFC(4,2) //Evento 2 - Geracao das Operacoes
	EndIf

End Transaction

RestArea( aArea )

Return

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³A650Altera³ Autor ³ Claudinei M. Benzi    ³ Data ³          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Programa de alteracao de O.P.s                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ Void A650Altera(ExpC1,ExpN1,ExpN2)                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Alias do arquivo                                   ³±±
±±³          ³ ExpN1 = Numero do registro                                 ³±±
±±³          ³ ExpN2 = Opcao selecionada no menu                          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Mata650                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
*/
Function A650Altera(cAlias,nReg,nOpcx)

Local aAlter     := {}
Local aAlterUsr  := {}
Local aAreaSC2   := {}
Local aBackRot   := aClone(aRotina)
Local aBut650    := {}
Local aInfo      := {}
Local aMRPxJson  := Nil
Local aObjects   := {}
Local aSize      := {}
Local bCampo     :={|nCpo| Field(nCpo) }
Local cAps       := SuperGetMV("MV_APS",.F.,"")
Local cCC        := ""
Local cEmp690    := Alltrim(STR(a690FilNum(FwCodFil())))
Local cFilSC2    := xFilial("SC2")
Local cItem      := ""
Local cItemGrd   := ""
Local cMascara   := SuperGetMv("MV_MASCGRD")
Local cNameCarga := "CARGA"+If(Empty(cEmp690),cNumEmp,cEmp690) //Nome do arquivo de Carga
Local cNum       := ""
Local cObs       := ""
Local cPrior     := ""
Local cRoteiro   := ""
Local cRotOld    := SC2->C2_ROTEIRO
Local cSeq       := ""
Local cSeqPai    := ""
Local cStatus    := ""
Local cUM        := ""
Local dDatPri    := Nil
Local dEmissao   := Nil
Local i          := 0
Local l650Emi    := If(ExistBlock("MA650EMI"),ExecBlock("MA650EMI",.F.,.F.),.T.)
Local lAltGra    := If(mv_par11==1, .T. , .F. )
Local lContinua  := .T.
Local lIntQIP    := IntQIP(SC2->C2_PRODUTO,,If(cModulo=="QIP","E","T"))
Local lLite      := .F.
Local lMonta     := .F.
Local lMT650ATHY := ExistBlock("MTA650ATHY")
Local lRetPE     := .T.
Local lDelTBMRP  := _lNewMRP == NIL
Local lIntNewMRP := Iif(_lNewMRP == Nil, Ma650MrpOn(@_lNewMRP),_lNewMRP)
Local nOpca      := Nil
Local nQuant     := 0
Local nQuant2UM  := 0
Local nTamRef    := Val(Substr(cMascara,1,2))
Local oDlg       := Nil

PRIVATE nRecSC2 := nReg
PRIVATE cSacram := ""
PRIVATE aTela[0][0], aGets[0]
PRIVATE aRatAFM		:= {}					//Variavel utilizada pela Funcao PMSDLGOP - Gerenc. Projetos
PRIVATE bPMSDlgOP	:= {||PmsDlgOP(4,M->C2_NUM,M->C2_ITEM,M->C2_SEQUEN)} // Chamada da Dialog de Gerenc. Projetos

aMRPxJson := Iif(lIntNewMRP, {{}, JsonObject():New()}, Nil)

If ValType(l650Emi) # "L"
	l650Emi := .T.
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Botao para exportar dados para EXCEL                    ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If RemoteType() == 1
	aAdd(aBut650,{PmsBExcel()[1],{|| DlgToExcel({{"ENCHOICE",cCadastro,aGets,aTela}})},PmsBExcel()[2],PmsBExcel()[3]})
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Executa ponto de entrada para montar array com botoes a      ³
//³ serem apresentados na tela de alteracao                      ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If (ExistBlock("M650BCHOI"))
	aBut650:=ExecBlock("M650BCHOI",.F.,.F.)
	If ValType(aBut650) # "A"
		aBut650:={}
	EndIf
Endif

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Verifica se o usuario tem permissao para alterar produto ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If !(lContinua := MaAvalPerm(1,{SC2->C2_PRODUTO,"MTA650",4}))
	Help(,,1,'SEMPERM')
EndIf

If lContinua .And. !Empty(SC2->C2_DATRF) .and. GetNewPar("MV_ATOPFEC","2") == "1"	// Permite alterar OP encerrada para campos do usuario
	Help("",1,"A650NAOALT")
	lContinua := .F.
EndIf

If lContinua .And. IsProdProt(SC2->C2_PRODUTO) .And. !IsInCallStack("DPRA340INT")
	Aviso(STR0024,STR0160,{"OK"}) //-- Protótipos podem ser manipulados somente através do módulo Desenvolvedor de Produtos (DPR).
	lContinua := .F.
EndIf

If lContinua
	AADD(aAlter,"C2_CC")
	AADD(aAlter,"C2_UM")
	AADD(aAlter,"C2_DATPRI")
	AADD(aAlter,"C2_DATPRF")
	AADD(aAlter,"C2_OBS")
	AADD(aAlter,"C2_EMISSAO")
	AADD(aAlter,"C2_PRIOR")
	AADD(aAlter,"C2_STATUS")
	AADD(aAlter,"C2_TPPR")
	AADD(aAlter,"C2_LINHA")
	AADD(aAlter,"C2_OPTERCE")

	If cModulo == "PCP" .or. cModulo == "QIP"
		If !(SH6->(dbSeek(xFilial("SH6")+SC2->(C2_NUM+C2_ITEM+C2_SEQUEN+C2_ITEMGRD+C2_PRODUTO)))) .or. cModulo == "QIP"
			AADD(aAlter,"C2_ROTEIRO")
		EndIf
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Considera os campos criados pelo usuario na alteracao da OP  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	dbSelectArea("SX3")
	dbSetOrder(1)
	dbSeek("SC2")
	While !Eof() .And. X3_ARQUIVO == "SC2"
		If X3_PROPRI == "U" .And. X3USO(X3_USADO) .And. X3_CAMPO <> 'C2_PRODAUT'
			AADD(aAlter,X3_CAMPO)
		EndIf
		dbSkip()
	EndDo

	dbSelectArea("SC2")
	nRecSC2 := SC2->(RecNo())
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Variaveis utilizadas para posterior alteracao de OPs filhas  ³
	//³ OPs Sacramentadas                                            ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	cNum	:= SC2->C2_NUM
	cItem	:= SC2->C2_ITEM
	cItemGrd:= SC2->C2_ITEMGRD
	cSeq 	:= SC2->C2_SEQUEN
	cSeqPai := SC2->C2_SEQPAI
	dDatPri := SC2->C2_DATPRI

	aAreaSC2:=SC2->(GetArea())
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Salva a integridade dos campos de Bancos de Dados            ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If Type("l650Auto") # "L" .Or. !l650Auto
		FOR i := 1 TO FCount()
			M->&(EVAL(bCampo,i)) := FieldGet(i)
		NEXT i
	EndIf

	If lAltGra .And. !EMPTY(SC2->C2_ITEMGRD)
		lMonta := .T.
		dbSeek(cFilSC2+SC2->C2_NUM+SC2->C2_ITEM+SC2->C2_SEQUEN)
		Do While !Eof() .And. SC2->C2_FILIAL+SC2->C2_NUM+SC2->C2_ITEM+SC2->C2_SEQUEN == cFilSC2+cNum+cItem+cSeq
			nQuant+= (C2_QUANT-C2_QUJE-C2_PERDA)
			nQuant2UM += C2_QTSEGUM
			dbSkip()
		EndDo
		RestArea(aAreaSC2)
		M->C2_PRODUTO := Substr(M->C2_PRODUTO,1,nTamRef)
		M->C2_QUANT   := nQuant
		M->C2_QTSEGUM := nQuant2UM
		M->C2_OPC     := " "
		M->C2_ITEMGRD := " "
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Ponto de Entrada para alterar campos nao editaveis           ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ----
	If (ExistBlock("MTA650ALT"))
 		aAlterUsr:=ExecBlock("MTA650ALT",.F.,.F.,{aAlter})
		If ValType(aAlterUsr) == "A"
			aAlter:=ACLONE(aAlterUsr)
		EndIf
	Endif

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Envia para rotina de Alteracao de OPs                        ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If Type("l650Auto") # "L" .or. !l650Auto
		If IntePms().AND. !lPmsInt	// Se usa PMS integrado com o ERP
			Aadd(aBut650,{'PROJETPMS',{||Eval(bPmsDlgOP)},OemToAnsi(STR0071),OemToAnsi(STR0117) }) //"Observação da Ordem de Produção..."
		Endif

		If lIntQIP //Define a integracao com o QIP
			Aadd(aBut650,{"RELATORIO",{|| QP650HIS(M->C2_NUM,M->C2_ITEM,M->C2_SEQUEN,M->C2_CHAVE)},OemToAnsi(STR0087),OemToAnsi(STR0118)}) //"Observação da Ordem de Produção..."
		EndIf
		AAdd(aBut650,{ "bmpord1", {|| A650Track() },STR0102} ) // Botao System Tracker

		If SuperGetMv("MV_SELEOPC") == "S"
		   AAdd(aBut650,{, {|| A650Opc() },STR0175} ) // Botao Opcionais
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Ajusta a largura para o tamanho padrao Protheus ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		aSize := MsAdvSize()
		aObjects := {}
		AAdd( aObjects, { 100, 100, .T., .T. } )
		aInfo    := { aSize[1], aSize[2], aSize[3], aSize[4], 2, 2 }
		aPosObj := MsObjSize( aInfo, aObjects )

		DEFINE MSDIALOG oDlg TITLE cCadastro FROM aSize[7],0 TO aSize[6],aSize[5] OF oMainWnd PIXEL
  		nOpca := EnChoice(cAlias, nReg, nOpcx, , , , ,aPosObj[1],aAlter, , , ,"A650TudoOK()", , ,lMonta)
		ACTIVATE MSDIALOG oDlg ON INIT EnchoiceBar(oDlg,&("{|| nOpca := 1,If(Obrigatorio(aGets,aTela).and. Eval({|| " + "a650TudoOk()" + "}),oDlg:End(),(nOpca:=3,.f.))}"),{|| nOpca := 3,oDlg:End()},,aBut650)
	Else
		nOpcA := AxAltera(cAlias,nReg,nOpcx,,aAlter,,,"A650TudoOK()",,,,,aRotProd)
	EndIf

	IF nOpca == 1

		Begin Transaction

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Garante estar posicionado no RecNo de origem evitando problemas c/³
			//³ customizacoes de clientes. (bops 000000908047)                    ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			DbSelectArea("SC2")
			SC2->(DbGoto(nRecSC2))
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Executa a atualizacao das tabelas do SIGAPMS 2-Estorno/1-Inclusao ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			PmsWriteOP(2,"SC2")

			If Type("l650Auto") == "L" .And. !l650Auto
				RecLock("SC2", .F.)
				For i := 1 TO FCount()
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Nao alterar o conteudo destes campos, pois, se for uma OP com Grade e o parametro estiver ativado³
					//³ para alterar todos os itens de Grade da OP, os campos abaixo, nao deverao ser alterados.         ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If FieldName(i)!="C2_PRODUTO".And.FieldName(i)!="C2_QUANT".And.FieldName(i)!="C2_OPC".And.FieldName(i)!="C2_ITEMGRD" .And. FieldName(i) != "C2_MOPC"
						FieldPut(i,M->&(EVAL(bCampo,i)))
					EndIf
				Next i
			EndIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Executa a atualizacao das tabelas do SIGAPMS 2-Estorno/1-Inclusao ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			PmsWriteOP(1,"SC2")

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Tratamento para alteracao no status da OP						  ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If SC2->C2_STATUS == "U"
				A650AtuSusp(.T.)
			Else
				A650AtuSusp(.F.)
			EndIf

			cCC     :=SC2->C2_CC
			cUM     :=SC2->C2_UM
			cObs    :=SC2->C2_OBS

			dEmissao:=SC2->C2_EMISSAO
			cPrior  :=SC2->C2_PRIOR
			cStatus :=SC2->C2_STATUS

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Variaveis utilizadas para posterior alteracao de OPs filhas  ³
			//³ OPs Sacramentadas                                            ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			dEmissao := SC2->C2_EMISSAO
			cPrior	 := SC2->C2_PRIOR
			cStatus	 := SC2->C2_STATUS
			cObs	 := SC2->C2_OBS
			dDatIni  := SC2->C2_DATPRI
			dDatFim  := SC2->C2_DATPRF

			dbSelectArea("SC2")
			dbSetOrder(1)

			dbSeek(cFilSC2+cNum+cItem+If(lAltGra .And. !Empty(SC2->C2_ITEMGRD),"",cSeq))

			While !Eof() .And. C2_FILIAL+C2_NUM+C2_ITEM == cFilSC2+cNum+cItem

				If !lAltGra .And. SC2->C2_ITEMGRD!=cItemGrd
					dbSkip()
					loop
				EndIf

				RecLock("SC2",.F.)
				If !Empty(SC2->C2_ITEMGRD)
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ So' gravar  a observacao nas OP's Pai                        ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If cSeq == C2_SEQUEN
						Replace C2_OBS With cObs
					EndIf
					Replace C2_CC With cCC,;
						C2_UM With cUM,;
						C2_DATPRI  With dDatIni,;
						C2_DATPRF  With dDatFim,;
						C2_EMISSAO With dEmissao,;
						C2_PRIOR   With cPrior,;
						C2_STATUS  With cStatus
				EndIf
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Caso usuario deseje, grava Prioridade nas OPs Intermed.   ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If mv_par05 == 1
					Replace C2_PRIOR With cPrior
				EndIf
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Caso usuario deseje, grava Observacao nas OPs Intermed.   ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If mv_par09 == 1
					Replace C2_OBS	With cObs
				EndIf

				If l650Emi
					Replace C2_EMISSAO	With dEmissao
				EndIf
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Caso usuario deseje, grava Status nas OPs Intermed.       ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If mv_par16 == 1
					Replace C2_STATUS	With cStatus
					If cStatus == "U"
						A650AtuSusp(.T.)
					Else
						A650AtuSusp(.F.)
					EndIf
				EndIf

				MsUnLock()

				//Integração de OPs filhas com o novo MRP. Carrega os dados para enviar
				If lIntNewMRP
					A650AddJIn(@aMRPxJson) //Inclui dados no array para integração com o novo MRP
				EndIf

				dbSkip()
			End
			dbGoto(nRecSC2)

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Verifica a alteracao das datas previstas p/ Inicio/Fim       ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Caso alterou a data prevista de inicio e o parametro permitir ³
			//³ acerta data das OPs posteriores                               ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If dDatPri # SC2->C2_DATPRI .And. mv_par07 == 1
				If dDatPri < SC2->C2_DATPRI
					dbSkip()
					Do While !Eof() .And. C2_FILIAL+C2_NUM+C2_ITEM == cFilSC2+cNum+cItem .And. C2_SEQUEN > cSeq .And. C2_SEQPAI > cSeqPai
						If Empty(C2_DATRF)
							RecLock("SC2",.F.)
							aAreaC2 := SC2->(GetArea())
							SC2->(DbSetOrder(1))
							If SC2->(dbSeek(xFilial("SC2")+SC2->C2_NUM+SC2->C2_ITEM+SC2->C2_SEQPAI))
								dDatIni := SC2->C2_DATPRI
								SC2->(RestArea(aAreaC2))
								Replace C2_DATPRF With dDatIni
								nPrazo := CalcPrazo(C2_PRODUTO,C2_QUANT,,,.F.,C2_DATPRF)
								dDatIni := SomaPrazo(C2_DATPRF, -nPrazo)
								Replace C2_DATPRI With dDatIni
							EndIf
							MsUnlock()
							//Integração de OPs filhas com o novo MRP. Carrega os dados para enviar
							If lIntNewMRP
								A650AddJIn(@aMRPxJson) //Inclui dados no array para integração com o novo MRP
							EndIf
						EndIf
						dbSkip()
					EndDo
				Else
					dbSkip()
					Do While !Eof() .And. C2_FILIAL+C2_NUM+C2_ITEM == cFilSC2+cNum+cItem .And. C2_SEQUEN > cSeq .And. C2_SEQPAI > cSeqPai
						If Empty(C2_DATRF)
							RecLock("SC2",.F.)
							aAreaC2 := SC2->(GetArea())
							SC2->(DbSetOrder(1))
							If SC2->(dbSeek(xFilial("SC2")+SC2->C2_NUM+SC2->C2_ITEM+SC2->C2_SEQPAI))
								dDatIni := SC2->C2_DATPRI
								SC2->(RestArea(aAreaC2))
								Replace C2_DATPRF With dDatIni
								nPrazo := CalcPrazo(C2_PRODUTO,C2_QUANT,,,.F.,C2_DATPRF)
								dDatIni := SomaPrazo(C2_DATPRF, -nPrazo)
								Replace C2_DATPRI With dDatIni
							EndIf
							MsUnlock()
							//Integração de OPs filhas com o novo MRP. Carrega os dados para enviar
							If lIntNewMRP
								A650AddJIn(@aMRPxJson) //Inclui dados no array para integração com o novo MRP
							EndIf
						EndIf
						dbSkip()
					EndDo
				EndIf
				dbGoto(nRecSC2)
			EndIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Integracao TOTVS APS: re-gera Operacoes X Ordem (SHY) 	     ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If Empty(cRoteiro := SC2->C2_ROTEIRO)
				If Empty(cRoteiro := Posicione("SB1",1,xFilial("SB1")+SC2->C2_PRODUTO,"B1_OPERPAD"))
					cRoteiro := StrZero(1,TamSX3("G2_CODIGO")[1])
				EndIf
			EndIf

			//Ponto de entrada para validar se atualizar a tabela SHY
			If lMT650ATHY
				lRetPE := ExecBlock("MTA650ATHY",.F.,.F.)
			EndIf

			If lRetPE .and. Empty(SC2->C2_IDAPS)
				SC2->(TAPSOperac(C2_NUM+C2_ITEM+C2_SEQUEN+C2_ITEMGRD,C2_PRODUTO,cRoteiro,C2_QUANT))
			EndIf

			if cRotOld != cRoteiro .OR. dDatPri != SC2->C2_DATPRI
				If (cAps == "TOTVS" .Or. lIntSFC .OR. SuperGetMV("MV_PCPATOR",.F.,.F.) == .T.)

					// Replicar alteração para SIGASFC
					If lIntSFC
						A650IntSFC(4,2) //Evento 2 - Geracao das Operacoes
					EndIf
				Endif

				dbSelectArea('SD4')
				SD4->(dbSetOrder(2))
				if SD4->(dbSeek(xFilial('SD4')+SC2->C2_NUM+SC2->C2_ITEM+SC2->C2_SEQUEN))
					While SD4->(!EOF()) .AND. SD4->D4_FILIAL == xFilial('SD4') .AND. Alltrim(SD4->D4_OP) == Alltrim(SC2->C2_NUM+SC2->C2_ITEM+SC2->C2_SEQUEN)
						dbSelectArea('SGF')
						SGF->(dbSetOrder(2))
						if SGF->(dbSeek(xFilial('SGF')+SC2->C2_PRODUTO+cRoteiro+SD4->D4_COD+SD4->D4_TRT))
							RecLock('SD4',.F.)

							SD4->D4_OPERAC  := SGF->GF_OPERAC
							SD4->D4_ROTEIRO := cRoteiro

							MsUnLock()
						Else
							RecLock('SD4',.F.)

							If Alltrim(cRoteiro) == ''
								SD4->D4_OPERAC  := ''
								SD4->D4_PRODUTO := ''
								SD4->D4_ROTEIRO := ''
							ElseIf SD4->D4_ROTEIRO == cRoteiro
								SD4->D4_ROTEIRO := cRoteiro
							Else
								SD4->D4_OPERAC  := ''
								SD4->D4_ROTEIRO := cRoteiro
							EndIf


							MsUnLock()
						Endif

						IF lIntSFC
							A650IntSFC(4,3) //Evento 3 - Geracao das necessidades
						Endif

						SD4->(dbSkip())
					End
				Endif
			Endif

			If Type('cWSMAT650') == "C"
				cWSMAT650 := SC2->(C2_NUM+C2_ITEM+C2_SEQUEN+C2_ITEMGRD)
				IF Type("lRodaAPS") == "L" .And. lRodaAPS

					If PCPIntgPPI("SC2", @lLite)
						If !lLite .Or.;
						   (lLite .And. totvs.protheus.manufacturing.meslite.productionorder.permiteIntegrarOrdem(cWSMAT650, "SC2", SC2->C2_PRODUTO))
							//Criação da SOJ indicando que as OP´s vindas do APS ainda não foram integradas com o TOTVS MES
							//Elas serão integradas com a execução do PCPA114 no schedule
							PCPA114APS(SC2->C2_NUM,SC2->C2_ITEM,SC2->C2_SEQUEN,SC2->C2_ITEMGRD,'N')
						EndIf
					EndIf

					If cAps == "TOTVS" .And. Empty(SC2->C2_IDAPS)
						RecLock("SC2",.F.)
						Replace C2_IDAPS With DTOS(date()) + ';' + Time()
						MsUnlock()
					Endif
				Endif
			EndIf

			//Integração de ordem de produção com o novo MRP.
			//Operação de INCLUSÃO/ALTERAÇÃO.
			//Integração de OPs filhas com o novo MRP. Carrega os dados para enviar
			If lIntNewMRP
				A650AddJIn(@aMRPxJson) //Inclui dados no array para integração com o novo MRP
				enviaOpMrp("INSERT", @aMRPxJson, lDelTBMRP)
			EndIf

		End Transaction

		// Apos gravar todos os registros de alteracao
		If (ExistBlock( "MTA650A" ) )
			ExecBlock("MTA650A",.F.,.F.)
		Endif

		If lIntQIP //Define a integracao com o QIP

			If SuperGetMV("MV_QPIMPPL",.F.,"S") == "S"

				If Type("l650Auto") # "L" .or. !l650Auto
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Faz a Impressao da Ficha de Produto  -  USO                               ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If Pergunte("QPR041",.T.) .And. mv_par01 == 1
						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³Ponto de Entrada para execucao do relatorio Customizado                         ³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						If ExistBlock("QIPR041")
							ExecBlock("QIPR041",.F.,.F.,{"MATA650",SC2->C2_NUM+SC2->C2_ITEM+SC2->C2_SEQUEN})
						Else
							QIPR040("MATA650",SC2->C2_NUM+SC2->C2_ITEM+SC2->C2_SEQUEN)
						EndIf
					EndIf
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Retorna a pergunta Original                                               ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					Pergunte("MTA650",.F.)
				EndIf
			EndIf
		EndIf

		If cSacram == "S" .Or. cSacram == "N"
			//-- Checa se arquivo SH8 nao esta em uso. Se nao tiver gera semaforo de bloqueio
			If OpenSemSh8()

				If !TCCanOpen(cNameCarga+"OPE")
					A690CheckSC2(.F.)
				Else
					dbUseArea(.T.,"TOPCONN",cNameCarga+"OPE","CARGA",.F.,.F.)
					dbSetIndex(cNameCarga+"OPE"+"1")
					dbSetIndex(cNameCarga+"OPE"+"2")
					dbSetIndex(cNameCarga+"OPE"+"3")
					dbSetIndex(cNameCarga+"OPE"+"4")
					dbSetIndex(cNameCarga+"OPE"+"5")
					dbSetIndex(cNameCarga+"OPE"+"6")
					dbGotop()
				EndIf

				If TCCanOpen(cNameCarga+"FER")
					dbUseArea(.T.,"TOPCONN",cNameCarga+"FER","FER",.F.,.F.)
					dbSetIndex(cNameCarga+"FER1")
					dbGotop()
				EndIf

				// Apagando OP Sacramentada (caso cSacram = "N" - "dessacramentando" uma OP, esta
				// rotina ‚ executada como medide de precau‡„o).
				dbSelectArea("SHD")
				dbSetOrder(1)
				dbSeek(xFilial("SHD")+cNum+cItem+cSeq)
				While !Eof()
					If Substr(HD_OP,1,8) # cNum+cItem
						Exit
					EndIf
					RecLock("SHD",.F.,.T.)
					dbDelete()
					MsUnLock()
					dbSkip()
				End
				// Apagando Ferramentas Sacramentada (caso cSacram = "N" - "dessacramentando" uma OP,
				// esta rotina ‚ executada como medide de precau‡„o).
				dbSelectArea("SHE")
				SHE->(dbSeek(xFilial("SHE")+cNum+cItem+cSeq))
				While SHE->(!Eof())
					If Substr(SHE->HE_OP,1,8) # cNum+cItem
						Exit
					EndIf

					If Select("FER") > 0
						RecLock("FER",.T.)
						Replace FER->HE_FILIAL  With SHE->HE_FILIAL,;
								FER->HE_PRODUTO With SHE->HE_PRODUTO,;
								FER->HE_CODIGO  With SHE->HE_CODIGO,;
								FER->HE_OPERAC  With SHE->HE_OPERAC,;
								FER->HE_FERRAM  With SHE->HE_FERRAM,;
								FER->HE_DTINI   With SHE->HE_DTINI,;
								FER->HE_DTFIM   With SHE->HE_DTFIM,;
								FER->HE_HRINI   With SHE->HE_HRINI,;
								FER->HE_HRFIM   With SHE->HE_HRFIM,;
								FER->HE_OP      With SHE->HE_OP
						FER->(MsUnLock())
					EndIf

					RecLock("SHE",.F.,.T.)
					SHE->(dbDelete())
					SHE->(MsUnLock())
					SHE->(dbSkip())
				End
				If cSacram == "S"

					dbSelectArea("SH8")
					dbSetOrder(1)
					dbSeek(xFilial("SH8")+cNum+cItem+cSeq)
					While !Eof()
						If Substr(H8_OP,1,8) # cNum+cItem
							Exit
						EndIf
						If H8_OP # SC2->C2_NUM+SC2->C2_ITEM+SC2->C2_SEQUEN
							dbSelectArea("SC2")
							dbSeek(cFilSC2+SH8->H8_OP)
							If !Found()
								Help(" ",1,"A690NAOOP",,SH8->H8_OP,01,21)
								Exit
							EndIf
						EndIf
						RecLock("SHD",.T.)
						Replace  HD_FILIAL With xFilial("SHD"),;
							HD_OP With SH8->H8_OP,;
							HD_OPER With SH8->H8_OPER,;
							HD_RECURSO With SH8->H8_RECURSO,;
							HD_FERRAM With SH8->H8_FERRAM,;
							HD_HRINI With SH8->H8_HRINI,;
							HD_DTINI With SH8->H8_DTINI,;
							HD_HRFIM With SH8->H8_HRFIM,;
							HD_DTFIM With SH8->H8_DTFIM,;
							HD_DTIDEAL With SH8->H8_DTIDEAL,;
							HD_HRIDEAL With SH8->H8_HRIDEAL,;
							HD_BITINI With SH8->H8_BITINI,;
							HD_BITFIM With SH8->H8_BITFIM,;
							HD_SEQPAI With SH8->H8_SEQPAI,;
							HD_CTRAB With SH8->H8_CTRAB,;
							HD_USO With SH8->H8_USO,;
							HD_QUANT With SH8->H8_QUANT,;
							HD_DESDOBR With SH8->H8_DESDOBR,;
							HD_BITUSO With SH8->H8_BITUSO,;
							HD_ROTEIRO With SH8->H8_ROTEIRO,;
							HD_DATRF With SC2->C2_DATRF
						MsUnLock()

						If Select("FER") > 0
							dbSelectArea("FER")
							If FER->(dbSeek(xFilial("SHE")))
								FER->(dbSetOrder(1))
								FER->(dbSeek(xFilial("SHE")+FER->HE_OP))
								While FER->(!Eof()) .And. xFilial("SH8")+SH8->H8_OP == FER->(HE_FILIAL+HE_OP)
									RecLock("SHE",.T.)
									Replace SHE->HE_FILIAL  With xFilial("SHE"),;
											SHE->HE_PRODUTO With FER->HE_PRODUTO,;
											SHE->HE_CODIGO  With FER->HE_CODIGO,;
											SHE->HE_OPERAC  With FER->HE_OPERAC,;
											SHE->HE_FERRAM  With FER->HE_FERRAM,;
											SHE->HE_DTINI   With FER->HE_DTINI,;
											SHE->HE_DTFIM   With FER->HE_DTFIM,;
											SHE->HE_HRINI   With FER->HE_HRINI,;
											SHE->HE_HRFIM   With FER->HE_HRFIM,;
											SHE->HE_OP      With FER->HE_OP
									SHE->(MsUnLock())
									RecLock("FER",.F.)
									FER->(dbDelete())
									FER->(MsUnLock())
									FER->(dbSkip())
								End
							EndIf
						EndIf
						dbSelectArea("SH8")
						RecLock("SH8",.F.)
						Replace H8_STATUS With "S"
						MsUnLock()
						dbSkip()
					End
					If Select("CARGA") > 0
						dbSelectArea("CARGA")
						If CARGA->(dbSeek(xFilial("SH8")))
							CARGA->(dbSetOrder(1))
							CARGA->(dbSeek(xFilial("SH8")+cNum+cItem+cSeq))
							While CARGA->(!Eof())
								If Substr(CARGA->H8_OP,1,8) # cNum+cItem
									Exit
								EndIf
								RecLock("CARGA",.F.)
									Replace CARGA->H8_STATUS With "S"
								MsUnLock()
								CARGA->(dbSkip())
							End
						EndIf
					EndIf
				Else
					dbSelectArea("SH8")
					dbSetOrder(1)
					dbSeek(xFilial("SH8")+cNum+cItem+cSeq)
					While !Eof()
						If Substr(H8_OP,1,8) # cNum+cItem
							Exit
						EndIf
						RecLock("SH8",.F.)
						Replace H8_STATUS With " "
						MsUnLock()
						dbSkip()
					End
					If Select("CARGA") > 0
						dbSelectArea("CARGA")
						If CARGA->(dbSeek(xFilial("SH8")))
							CARGA->(dbSetOrder(1))
							CARGA->(dbSeek(xFilial("SH8")+cNum+cItem+cSeq))
							While CARGA->(!Eof())
								If Substr(CARGA->H8_OP,1,8) # cNum+cItem
									Exit
								EndIf
								RecLock("CARGA",.F.)
								Replace CARGA->H8_STATUS With " "
								MsUnLock()
								CARGA->(dbSkip())
							End
						EndIf
					EndIf
				EndIf

				//-- Fecha/Libera Semafaro do SH8
				ClosSemSH8()

			EndIf
			dbSelectArea("SH8")
			dbCloseArea()
			If Select("CARGA") > 0
				dbSelectArea("CARGA")
				dbCloseArea()
			EndIf
			If Select("FER") > 0
				dbSelectArea("FER")
				dbCloseArea()
			EndIf

		EndIf
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Envia para rotina de Alteracao de data dos Empenhos          ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If mv_par07 == 1
			A650TrCDT(SC2->C2_NUM+SC2->C2_ITEM+SC2->C2_SEQUEN)
		EndIf

	Else
		If ( (ExistBlock("M650CAN")) )
			ExecBlock("M650CAN",.f.,.f., {2})
		EndIf
	Endif

EndIf

aRotina := aBackRot
RETURN NIL

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³A650DelOP ³ Autor ³ Claudinei M. Benzi    ³ Data ³          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Programa de exclusao de O.P.s                              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ Void A650DelOP(ExpC1,ExpN1,ExpN2)	                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Alias do arquivo                                   ³±±
±±³          ³ ExpN1 = Numero do registro                                 ³±±
±±³          ³ ExpN2 = Opcao selecionada no menu                          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Mata650                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
*/
Function A650DelOp(lPar,cAlias,lProcessou,lExcGra,cProgOri,aMRPxJson)
Local aAreaAtu    := {}
Local aDocs       := {}
Local aOpsDel     := {SC2->(C2_NUM+C2_ITEM+C2_SEQUEN)}
Local aRegsSC1    := {}
Local aRegsSC6    := {}
Local aResultados := {}
Local aTravas     := {}
Local cChave1     := ""
Local cChave2     := ""
Local cFilSC2     := ""
Local cFilSD4     := ""
Local cItem       := Nil
Local cNivel      := Nil
Local cNivel2     := Nil
Local cNum        := Nil
Local cNumOp      := SC2->C2_NUM+SC2->C2_ITEM+SC2->C2_SEQUEN+If(lExcGra,"",SC2->C2_ITEMGRD)
Local cOp         := Nil
Local cOpLigada   := ""
Local cProduto    := ""
Local cSeq        := Nil
Local cTipoDHN    := "1"
Local cXml        := ""
Local lAprovEt    := SuperGetMV("MV_APRSCEC",.F.,.T.) // Alcada por Entidade Contabil
Local lAtuSGJ     := SuperGetMV("MV_PVCOMOP",.F.,.F.)
Local lDeleSC6    := ExistBlock("MA650DC6")
Local lExcluiAE   := IIF(SuperGetMv("MV_DELEAE")=="S",.T.,.F.)
Local lExcluiOPF  := If(Valtype(mv_par10)=="N",mv_par10==1,.T.)
Local lExcluiSC   := .T.
Local lExcluiSC2  := .T.
Local lIntMES     := .F.
Local lIntNewMRP  := Iif(_lNewMRP == Nil, Ma650MrpOn(@_lNewMRP), _lNewMRP)
Local lIntQIP     := IntQIP(SC2->C2_PRODUTO,"1",IIf(cModulo=="QIP","E","T"))
Local lLite       := .F.
Local lMTA650AE   := ExistBlock("MTA650AE")
Local lMTA650EF   := ExistBlock("MTA650EF")
Local lMTA650EMP  := ExistBlock("MTA650EMP")
Local lOpQuebrada := .F.
Local lOutraOp    := .F.
Local lProcessa   := .T.
Local lRetPe      := .T.
Local lSCSldBl    := SuperGetMv("MV_SCSLDBL",.F.,.F.)
Local lTratou     := .F.
Local nEntregSC7  := 0
Local nQtdAtuEmp  := 0
Local nQtdEmp     := 0
Local nQtdOri     := 0
Local nRecno      := 0
Local nRegSC2     := Nil
Local nSavSc7     := 0
Local nX          := 0
Local lWMSSaas    := FindFunction("WMSSaasHas") .And. WMSSaasHas()

Default aMRPxJson := Iif(lIntNewMRP, {{}, JsonObject():New()}, Nil)
Default cProgOri  := "MATA650"

If IsInCallStack('A108AtuOrd')
	lExcluiOPF := .F.
Endif

lIntMES := PCPIntgPPI("SC2", @lLite)

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Verifica se devera' ser excluido ou nao todos os itens da Grade ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
lExcGra := If(lExcGra==NIL, .F. , lExcGra)

dbSelectArea(cAlias)
A650DelSD3(cNumOp,@lExcluiSC2,lExcGra)

If (!lExcluiSC2 .Or. SC2->(C2_QUJE+C2_PERDA) > 0 ) .And. lPar
	Help(" ",1,"MA650INI")
	lExcluiSC2:= .F.
EndIf

If lExcluiSC2 .And. lPar
	lExcluiSC2 := a650DelHZA(cNumOp, .T.)
EndIf

If Type("l650Auto") == "L" .And. l650Auto
	If (nX := aScan(aRotProd,{|x| x[1] == "DELOPI"})) > 0
		lExcluiOPF := aRotProd[nX,2] == "S"
	EndIf
	If (nX := aScan(aRotProd,{|x| x[1] == "DELSC"})) > 0
		lExcluiSC := aRotProd[nX,2] == "S"
	EndIf
EndIf

If lExcluiSC2 .And. !(SC2->C2_QUJE+SC2->C2_PERDA>0)
	cFilSC2 := xFilial("SC2")
	cFilSD4 := xFilial("SD4")
	dbSelectarea("SD4")
	SD4->(dbSetOrder(4))
	cOpLigada:=If(dbSeek(cFilSD4+SC2->(C2_NUM+C2_ITEM+C2_SEQUEN)),SD4->D4_OP,"")

	dbSelectArea("SG1")
	SG1->(dbSeek(xFilial("SG1")+SC2->C2_PRODUTO))
	cNivel := SG1->G1_NIV
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Se a Exclusao for manual, le o proximo registro para     ³
	//³ deletar todas as OPs filho c/mesmo Numero e Item.        ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	dbSelectArea("SC2")
	nRegSC2 := SC2->(RecNo())
	SC2->(dbSetOrder(1))
	cOp     := SC2->(C2_NUM+C2_ITEM+C2_SEQUEN)
	cItemGrd:= SC2->C2_ITEMGRD
	SC2->(dbSkip())
	While lExcluiOPF .And. !EOF() .And. C2_FILIAL+C2_NUM+C2_ITEM == cFilSC2+SubStr(cOp,1,8) .And. lExcluiSC2
		If lMTA650EF
			lRetPE := ExecBlock("MTA650EF",.F.,.F.,{SC2->(C2_NUM+C2_ITEM+C2_SEQUEN)})
			If ValType(lRetPE) == "L" .And. !lRetPE
				SC2->(dbSkip())
				Loop
			EndIf
		EndIf
		dbSelectarea("SD4")
		dbSetOrder(4)
		If dbSeek(cFilSD4+SC2->C2_NUM+SC2->C2_ITEM+SC2->C2_SEQUEN) .And. !Empty(cOpLigada) .And. cOpLigada == SD4->D4_OP
			dbSelectArea("SC2")
			Exit
		EndIf
		dbSelectArea("SC2")

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Verifica se devera deletar ou nao os outros itens da grade, conforme³
		//³ mv_par12                                                            ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If !lExcGra .And. SC2->C2_ITEMGRD!=cItemGrd
			dbSkip()
			loop
		EndIf

		/*
		DMANSMARTSQUAD1-29131
		Essa validação sempre existiu no MATA650
		Foi retirada essa validação para sempre excluir as OPs intermediárias
		independente se existir estrutura.

		dbSelectArea("SG1")
			If !MsSeek(xFilial("SG1")+SC2->C2_PRODUTO) .And. SC2->C2_DESTINA != "P"
			Exit
		EndIf
		*/

		//Integração ACD x SFC - Verifica se a OP já teve apontamento iniciado no ACD.
		//Se tiver, não permite a exclusão da ordem.
		If !vldOpACD()
			dbSelectArea("SC2")
			SC2->(dbSkip())
			Loop
		EndIf

		cNumOp  := SC2->C2_NUM+SC2->C2_ITEM+SC2->C2_SEQUEN+If(lExcGra,"",SC2->C2_ITEMGRD)
		A650DelSD3(cNumOp,@lExcluiSC2,lExcGra)
		If !lExcluiSC2
			lExcluiSC2 := .t.
			dbSelectArea("SC2")
			dbSkip()
			Loop
		EndIf

		If lExcluiSC2
			lExcluiSC2 := a650DelHZA(cNumOp, .F.)
			If !lExcluiSC2
				lExcluiSC2 := .T.
				dbSelectArea("SC2")
				SC2->(dbSkip())
				Loop
			EndIf
		EndIf

		//-- Controla a ExclusÆo das OP's Filhas
		/*
			Validação com o array aOpsDel deve ser feita após a chamada da funão A650DelSD3, para não excluir
			as ordens de produção filhas caso a ordem pai não possa ser excluída.
		*/
		cItemGrd := SC2->C2_ITEMGRD
		If aScan(aOpsDel, {|x| x == SC2->(C2_NUM+C2_ITEM+C2_SEQPAI)}) == 0
			dbSelectArea('SC2')
			dbSkip()
			Loop
		ElseIf aScan(aOpsDel, {|x| x == SC2->(C2_NUM+C2_ITEM+C2_SEQUEN)}) == 0
			aAdd(aOpsDel,SC2->(C2_NUM+C2_ITEM+C2_SEQUEN))
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Antes de deletar verifica se tem resultados 	                  ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If lIntQIP //Define a integracao com o QIP

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Exclui o Movimento OP x Lotes (Integracao QIP x PCP)		 ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			lProcessa := QIPAtualiza("SC2",2)

			If !lProcessa
				Aviso('',OemToAnsi(STR0067),{'Ok'}) //"Existe resultado j  coletado para esta Ordem de Produ‡„o. Esta O.P. n„o poder  ser exclu¡da."
				SC2->(dbSkip())
				Loop
			EndIf
		EndIf

		// Exclusão de OP Intermediaria com integracao WMS SaaS. Exclui DBZ,DBY e DBX.
		If lWMSSaas .And. FindFunction("WMSSVExcOP") .And. FindFunction("WMSSExcOP")
			lProcessa := WMSSVExcOP((SC2->(Recno()))) 
			If lProcessa
				WMSSExcOP((SC2->(Recno())))
			Else
				SC2->(dbSkip())
				Loop
			EndIf
		EndIf

		dbSelectArea("SC2")
		If C2_QUJE+C2_PERDA>0
			lProcessou:=.T. // Variavel usada apenas na Rotina de Cancelamento de OPs
			cNivel2 := SG1->G1_NIV
			RecLock("SC2",.F.)
			Replace C2_STATUS With "O"
			MsUnLock()
			dbSkip()
			While !EOF() .And. C2_FILIAL+C2_NUM+C2_ITEM == cFilSC2+SubStr(cOp,1,8)
				dbSelectArea("SG1")
				dbSeek(xFilial("SG1")+SC2->C2_PRODUTO)
				If G1_NIV <= cNivel2
					dbSelectArea("SC2")
					Exit
				EndIf
				dbSelectArea("SC2")
				dbSkip()
			EndDo
			Loop
		EndIf

		//-- Integracao com Chao de Fabrica (SFC) *** DEVE SER SEMPRE A ULTIMA VALIDACAO
		If lIntSFC .And. !A650IntSFC(5)
			dbSkip()
			Loop
		EndIf

		cOp := xFilial("SHD")+SC2->C2_NUM+SC2->C2_ITEM
		cItemGrd := SC2->C2_ITEMGRD
		nTam := Len(SC2->C2_ITEMGRD)
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Se a OP for Sacramentada, deleta no SHD.                 ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		dbSelectArea("SHD")
		dbSetOrder(1)
		dbSeek(xFilial("SHD")+SC2->C2_NUM+SC2->C2_ITEM+SC2->C2_SEQUEN+If(lExcGra,"",SC2->C2_ITEMGRD))
		//Do While !Eof() .And. HD_FILIAL+Substr(HD_OP,1,8) == cOp
		Do While !Eof() .And. SHD->HD_FILIAL+SHD->HD_OP == xFilial("SHD")+cNumOp
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Verifica se devera deletar ou nao os outros itens da grade, confor- ³
			//³ me mv_par12                                                         ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If !lExcGra .And. Right(HD_OP,nTam) != cItemGrd
				dbSkip()
				loop
			EndIf
			RecLock("SHD",.F.,.T.)
			dbDelete()
			dbSkip()
		Enddo

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Se a OP estiver efetivada no CRP deleto a HWF            ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

		If UsaCRP()
			dbSelectArea("HWF")
			dbSetOrder(1)
			If dbSeek(xFilial("HWF")+cNumOp)
				PCPA152Efetivacao():deletaHWF(cNumOp, xFilial("HWF"))
			Endif
		Endif

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Se a OP foi alocada, deleta da SH8.   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		dbSelectArea("SH8")
		dbSetOrder(1)
		dbSeek(xFilial("SHD")+SC2->C2_NUM+SC2->C2_ITEM+SC2->C2_SEQUEN+If(lExcGra,"",SC2->C2_ITEMGRD))
		//Do While !Eof() .And. H8_FILIAL+Substr(H8_OP,1,8) == cOp
		Do While !Eof() .And. SH8->H8_FILIAL+SH8->H8_OP == xFilial("SHD")+cNumOp

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Verifica se devera deletar ou nao os outros itens da grade, confor- ³
			//³ me mv_par12                                                         ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If !lExcGra .And. Right(H8_OP,nTam) != cItemGrd
				dbSkip()
				loop
			EndIf
			RecLock("SH8",.F.,.T.)
			dbDelete()
			dbSkip()
		Enddo

		dbSelectArea("SC2")
		cOp := C2_NUM+C2_ITEM+C2_SEQUEN+If(lExcGra,"",C2_ITEMGRD)
		cItemGrd := SC2->C2_ITEMGRD

		dbSelectArea("SD4")
		dbSetOrder(2)
		dbSeek(cFilSD4+cOp)
		While !EOF() .And. D4_FILIAL+If(!lExcGra,D4_OP,left(SD4->D4_OP,len(cOp))) == cFilSD4+cOp

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Verifica se devera deletar ou nao os outros itens da grade, confor- ³
			//³ me mv_par12                                                         ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If !lExcGra .And. Right(D4_OP,nTam) != cItemGrd
				dbSkip()
				loop
			EndIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Atualiza arquivo de empenhos               ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			GravaEmp(SD4->D4_COD,;
				SD4->D4_LOCAL,;
				SD4->D4_QUANT,;
				SD4->D4_QTSEGUM,;
				SD4->D4_LOTECTL,;
				SD4->D4_NUMLOTE,;
				NIL,;
				NIL,;
				SD4->D4_OP,;
				SD4->D4_TRT,;
				NIL,;
				NIL,;
				"SC2",;
				SD4->D4_OPORIG,;
				SD4->D4_DATA,;
				@aTravas,;
				.T.,;
				NIL,;
				NIL,;
				.T.,;
				NIL,;
				NIL,;
				NIL,;
				NIL,;
				NIL,;
				NIL,;
				NIL,;
				NIL,;
				NIL,;
				IIF(cPaisLoc=="BRA",SD4->D4_CODLAN,NIL),;
				NIL,;
				NIL,;
				NIL)
			// Deve estornar o empenho no novo WMS quado for o caso - lWmsNew
			If lWmsNew .And. IntWms(SD4->D4_COD)
				WmsEmpReq("SC2",;
							 SD4->D4_COD,;
							 SD4->D4_LOCAL,;
							 SD4->D4_QUANT,;
							 /*cEndereco*/,;
							 SD4->D4_LOTECTL,;
							 SD4->D4_NUMLOTE,;
							/*cNumSerie*/,;
							 SD4->D4_OP,;
							 SD4->D4_TRT,;
							 /*cIdDCF*/,;
							 /*cIdUnitiz*/,;
							 .T.,; // lEstorno
							 .T.,; // lCriaSDC
							 .T.)  // lEmpD14
			EndIf

			dbSelectArea("SG1")
			dbSeek(xFilial("SG1")+SD4->D4_COD)
			If EOF()
				dbSelectArea("SC1")
				dbSetOrder(4)
				dbSeek(xFilial("SC1")+cOp)
				While lExcluiSC .And. !EOF() .And. C1_FILIAL+If(!lExcGra,C1_OP,left(C1_OP,len(cOp))) == xFilial("SC1")+cOp
					If C1_PRODUTO == SD4->D4_COD
						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³ Verifica se devera deletar ou nao os outros itens da grade, confor- ³
						//³ me mv_par12                                                         ³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						If !lExcGra .And. Right(C1_OP,nTam) != cItemGrd
							dbSkip()
							loop
						EndIf

						// Verifica se esta em processo de cotacao
						If !Empty(SC1->C1_COTACAO) .And.  SC1->C1_COTACAO <> Replicate("X",Len(SC1->C1_COTACAO)) .And. SC1->C1_IMPORT <> "S" .And. SC1->C1_QUJE == 0
							Aviso(STR0051,STR0122+AllTrim(SC1->C1_NUM)+STR0123+AllTrim(SC1->C1_ITEM)+STR0124,{'Ok'})
							AADD(aRegsSC1,SC1->(Recno())) //A solicitacao de compras numero ### item ### nao podera ser excluida pois se encontra em processo de cotacao!
							dbSkip()
							Loop
						Endif

						// Verifica se esta em processo de importacao
						If !Empty(SC1->C1_NUM_SI)
 							Aviso(STR0051,STR0122+AllTrim(SC1->C1_NUM)+STR0123+AllTrim(SC1->C1_ITEM)+STR0140,{'Ok'})
							AADD(aRegsSC1,SC1->(Recno())) //A solicitacao de compras numero ### item ### nao podera ser excluida pois se encontra em processo de importacao!
							SC1->(dbSkip())
							Loop
						Endif

						If !Empty(SC1->C1_ACCNUM)
							Aviso(STR0051,STR0122+AllTrim(SC1->C1_NUM)+STR0123+AllTrim(SC1->C1_ITEM)+STR0204,{'Ok'})
							AADD(aRegsSC1,SC1->(Recno())) //A solicitacao de compras numero ### item ### nao podera ser excluida pois se encontra integrada com o Paradigma!
							SC1->(dbSkip())
							Loop
						EndIf

						If (SC1->C1_TPOP == "F") .And. ((cProgOri == "MATA710") .Or. (cProgOri == "MATA651" .And.;
  							Aviso(STR0051,STR0122+SC1->C1_NUM+STR0123+SC1->C1_ITEM+STR0132+AllTrim(SC1->C1_OP)+STR0133,{STR0134,STR0135})==2))
							SC1->(dbSkip())
							Loop
						EndIf

						dbSelectArea("SB2")
						dbSetOrder(1)
						If !dbSeek(xFilial("SB2")+SC1->C1_PRODUTO+SC1->C1_LOCAL)
							CriaSB2(SC1->C1_PRODUTO,SC1->C1_LOCAL)
							MsUnlock()
						EndIf
						If SC1->C1_APROV <> "B" .Or. (SC1->C1_APROV == "B" .And. !lSCSldBl)
							GravaB2Pre("-",(SC1->C1_QUANT-SC1->C1_QUJE),SC1->C1_TPOP)
						EndIf
						// Caso ja haja qtd no PC, iguala qtd na SC para encerra-la
						// Senao deleta
						If SC1->C1_QUJE > 0
							RecLock("SC1",.F.)
							Replace C1_QUANT   With C1_QUJE
							Replace C1_QTSEGUM With ConvUM(SB2->B2_COD, C1_QUJE, 0, 2)
							MsUnlock()
						Else
							//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
							//³ Execblock a ser executado antes da Exclusao do SC1           ³
							//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
							IF (ExistBlock('MT650DC1'))
								ExecBlock('MT650DC1',.F.,.F.)
							Endif
							//Realiza Exclusao de Alcada contabil
							If lAprovEt
								A650ALCCTB(cOp)
							EndIf
							If Type('aProcMRP') == "A" .And. !Empty(SC1->C1_SEQMRP)
								aAdd(aProcMRP, {SC1->C1_SEQMRP, SC1->C1_PRODUTO, SC1->C1_QUANT} )
							EndIf

							//Executa a exclusão da tabela DHN
							aAreaAtu := GetArea()
							COMEXCDHN("1",xFilial("SC1"),SC1->C1_NUM)
							RestArea(aAreaAtu)

							// Gerar Carta de Correcao do Pedido
							RecLock("SC1",.F.,.T.)
							Replace C1_OBS With STR0025 //"CANCELADA PELO SISTEMA."
							dbDelete()
							MsUnLock()
						EndIf
					EndIf
					dbSkip()
				EndDo
				dbSetOrder(1)
				dbSelectArea("SC7")
				dbSetOrder(8)
				dbSeek(xFilial("SC7")+cOp)
				While lExcluiSC .And. !EOF() .And. C7_FILIAL+If(!lExcGra,C7_OP,left(C7_OP,len(cOp))) == xFilial("SC7")+cOp
					If C7_PRODUTO == SD4->D4_COD .And. C7_TIPO == 2
						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³ Verifica se devera deletar ou nao os outros itens da grade, confor- ³
						//³ me mv_par12                                                         ³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						If !lExcGra .And. Right(C7_OP,nTam) != cItemGrd
							dbSkip()
							loop
						EndIf

						If (SC7->C7_TPOP == "F") .And. ((cProgOri == "MATA710") .Or. (cProgOri == "MATA651" .And.;
						Aviso(STR0051,STR0136+SC7->C7_NUM+STR0123+SC7->C7_ITEM+STR0132+AllTrim(SC7->C7_OP)+STR0133,{STR0137,STR0138})==2))
							SC7->(dbSkip())
							Loop
						EndIf

						dbSkip()
						nSavSc7 := RecNo()
						dbSkip(-1)

						dbSelectArea("SB2")
						dbSetOrder(1)
						If !dbSeek(xFilial("SB2")+SC7->C7_PRODUTO+SC7->C7_LOCAL)
							CriaSB2(SC7->C7_PRODUTO,SC7->C7_LOCAL)
							MsUnlock()
						EndIf
						nEntregSC7:=SC7->C7_QUJE+SC7->C7_QTDACLA
						GravaB2Pre("-",SC7->C7_QUANT-nEntregSC7,SC7->C7_TPOP)
						// Volta saldo ate a autorizacao de entrega
						If nEntregSC7 > 0 .Or. lExcluiAE
							dbSelectArea("SC3")
							dbSetOrder(1)
							If dbSeek(xFilial("SC3")+SC7->C7_NUMSC+SC7->C7_ITEMSC)
								RecLock("SC3",.F.)
								Replace C3_QUJE With C3_QUJE - (SC7->C7_QUANT-nEntregSC7)
								If C3_QUANT > C3_QUJE .And. C3_ENCER == "E"
									Replace C3_ENCER 	With " "
								Endif
								MsUnlock()
							EndIf
						EndIf
						dbSelectArea("SC7")
						// Caso ja haja qtd ENTREGUE no PC
						If nEntregSC7 > 0
							RecLock("SC7",.F.)
							Replace C7_QUANT With SC7->C7_QUJE+SC7->C7_QTDACLA
							Replace C7_TOTAL With SC7->C7_QUANT * SC7->C7_PRECO
							MsUnlock()
						ElseIf lExcluiAE
							//Executa a exclusão da tabela DHN
							aAreaAtu := GetArea()
							If SC7->C7_TIPO == 2
								cTipoDHN := "3"
							Else
								cTipoDHN := "2"
							EndIf
							COMEXCDHN(cTipoDHN,xFilial("SC7"),SC7->C7_NUM)
							RestArea(aAreaAtu)

							RecLock("SC7",.F.,.T.)
							Replace C7_OBS With STR0025 //"CANCELADA PELO SISTEMA."
							dbDelete()
							MsUnLock()
						EndIf
					EndIf
					dbGoto(nSavSc7)
					If !( C7_PRODUTO == SD4->D4_COD .And. C7_TIPO == 2 )
						Exit
					Endif
				EndDo
				dbSetOrder(1)
			EndIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ PE antes da exclusao de cada empenho do SD4      ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If lMTA650EMP
				ExecBlock("MTA650EMP",.F.,.F.,{cOp})
			EndIf

			If FindFunction("A381GrvAgr")
				//Grava os dados do SIGAAGR (Dados existentes somente quando utilizado a integração com o PIMS)
				A381GrvAgr(.T.,SD4->D4_COD, SD4->D4_LOCAL, SD4->D4_OP, SD4->D4_TRT, SD4->D4_LOTECTL, SD4->D4_NUMLOTE)
			EndIf

			dbSelectArea("SD4")
			RecLock("SD4",.F.,.T.)
			SD4->(dbDelete())
			SD4->(MsUnLock())
			SD4->(dbSkip())
		EndDo

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Exclui SC's e AE's que estavam vinculadas a OP   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		A650DelC1C7(cOp,lExcGra,nTam,cItemGrd,@aRegsSC1,cProgOri)

		dbSelectArea("SB2")
		dbSetOrder(1)
		If !dbSeek(xFilial("SB2")+SC2->C2_PRODUTO+SC2->C2_LOCAL)
			CriaSB2(SC2->C2_PRODUTO,SC2->C2_LOCAL)
			MsUnlock()
		EndIf
		GravaB2Pre("-",SC2->C2_QUANT,SC2->C2_TPOP,SC2->C2_QTSEGUM)
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Executa a exclusao das tabelas do SIGAPMS 2-Estorno/3-Exclusao³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		dbSelectArea("SC2")
		PmsWriteOP(2,"SC2")
		PmsWriteOP(3,"SC2")
		A650DelSHC(SC2->C2_PRODUTO,SC2->(C2_NUM+C2_ITEM+C2_SEQUEN+C2_ITEMGRD),SC2->C2_DATPRI)

		A650DelSc1BN(cOp)

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Atualiza variaveis antes da exclusap p/ uso em P.E. ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		cNum	:= SC2->C2_NUM
		cItem	:= SC2->C2_ITEM
		cSeq	:= SC2->C2_SEQUEN

		//Integração de ordens de produção com o novo MRP. Exclusão de ordens.
		If lIntNewMRP
			A650AddJIn(@aMRPxJson, "DELETE") //Inclui dados no array para integração com o novo MRP
		EndIf

		aAreaSC2 := SC2->(GetArea())

		//Integração PCFactory -> Exclusão da OP.
		If lIntMES
			If RodaAPS()
				If lLite
					//MES Lite somente vai criar a SOJ da exclusão se essa OP for integrada considerando os filtros do PCPA109.
					If totvs.protheus.manufacturing.meslite.productionorder.permiteIntegrarOrdem(cNum+cItem+cSeq+cItemGrd, "SC2", SC2->C2_PRODUTO)
						PCPA114APS(cNum, cItem, cSeq, cItemGrd, "N", "[DELETE] " + cNum+cItem+cSeq+cItemGrd)
					EndIf
				Else
					cXml := a650XmlMES(cNum+cItem+cSeq+cItemGrd)
					If !Empty(cXml)
						PCPA114APS(cNum,cItem,cSeq,cItemGrd,"N",cXml)
					EndIf
				EndIf
			Else
				lProcessa := mata650PPI(,,.T.,.T.,.T.)
			EndIf
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Integracao TOTVS APS: deleta Operacoes X Ordem (SHY)         ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		TAPSOperac(cNum+cItem+cSeq+cItemGrd,,,,.F.)
		SC2->(RestArea(aAreaSC2))

		// para uso na funcao comgeradoc(processo exclusao) precisa somente da filial e numero da OP
		aDocs:={}
		Aadd(aDocs,{,,cFilAnt,,,/**/,/**/,,/**/,{},cNum,cItem})

		If !Empty(aDocs)
			aResultados := ComGeraDoc(aDocs,,,,,,,,,5  )
		EndIf

		//Exclui as ordens de substituição existentes desta ordem.
		delOrdSub(cNum+cItem+cSeq+cItemGrd)

		RecLock(cAlias,.F.,.T.) // EXCLUSAO DA SC2
		(cAlias)->(dbDelete())
		(cAlias)->(MsUnLock())

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Ponto de entrada apos a exclusao - MTA650AE 	    ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If lMTA650AE
			ExecBlock("MTA650AE",.F.,.F.,{cNum,cItem,cSeq})
		EndIf

		(cAlias)->(dbSkip())
	EndDo
	dbSelectArea("SC2")
	dbGoTo(nRegSC2)

	lProcessa := .T.
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Antes de deletar verifica se tem resultados 	                  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lIntQIP //Define a integracao com o QIP

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Exclui o Movimento OP x Lotes (Integracao QIP x PCP)		 ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		lProcessa := QIPAtualiza("SC2",2)

		If !lProcessa
			Aviso('',OemToAnsi(STR0067),{'Ok'}) //"Existe resultado j  coletado para esta Ordem de Produ‡„o. Esta O.P. n„o poder  ser exclu¡da."
		EndIf
	EndIf

	//Integração PCFactory -> Exclusão da OP.
	If lIntMES
		If RodaAPS()
			If lLite
				//MES Lite somente vai criar a SOJ da exclusão se essa OP for integrada considerando os filtros do PCPA109.
				If totvs.protheus.manufacturing.meslite.productionorder.permiteIntegrarOrdem(SC2->(C2_NUM+C2_ITEM+C2_SEQUEN+C2_ITEMGRD), "SC2", SC2->C2_PRODUTO)
					PCPA114APS(SC2->C2_NUM, SC2->C2_ITEM, SC2->C2_SEQUEN, SC2->C2_ITEMGRD,;
					           "N", "[DELETE] " + SC2->(C2_NUM+C2_ITEM+C2_SEQUEN+C2_ITEMGRD))
				EndIf
			Else
				cXml := a650XmlMES(SC2->(C2_NUM+C2_ITEM+C2_SEQUEN+C2_ITEMGRD))
				If !Empty(cXml)
					PCPA114APS(SC2->C2_NUM,SC2->C2_ITEM,SC2->C2_SEQUEN,SC2->C2_ITEMGRD,"N",cXml)
				EndIf
			EndIf
		Else
			lProcessa := mata650PPI(,,.T.,.F.,.T.)
		EndiF
	EndIf

	// Exclusão de OP com integracao WMS SaaS. Exclui DBZ,DBY e DBX.
	If lWMSSaas .And. FindFunction("WMSSExcOP")
		WMSSExcOP(SC2->(Recno()))
	EndIf

	//Integração de ordens de produção com o novo MRP. Exclusão de ordens.
	If lIntNewMRP
		A650AddJIn(@aMRPxJson, "DELETE") //Inclui dados no array para integração com o novo MRP
	EndIf

	//-- Integracao com Chao de Fabrica (SFC) *** DEVE SER SEMPRE A ULTIMA VALIDACAO
	If lIntSFC
		lProcessa := A650IntSFC(5)
	EndIf

	If lProcessa
		cNumOp  := SC2->C2_NUM+SC2->C2_ITEM+SC2->C2_SEQUEN+If(lExcGra,"",SC2->C2_ITEMGRD)
		cOp := xFilial("SHD")+C2_NUM+C2_ITEM
		cItemGrd := SC2->C2_ITEMGRD
		nTam := Len(SC2->C2_ITEMGRD)
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Se a OP for Sacramentada, deleta no SHD.                 ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		dbSelectArea("SHD")
		dbSetOrder(1)
		//dbSeek(xFilial("SHD")+SC2->C2_NUM+SC2->C2_ITEM)
		//Do While !Eof() .And. HD_FILIAL+Substr(HD_OP,1,8) == cOp
		dbSeek(xFilial("SHD")+SC2->C2_NUM+SC2->C2_ITEM+SC2->C2_SEQUEN+If(lExcGra,"",SC2->C2_ITEMGRD))
		Do While !Eof() .And. SHD->HD_FILIAL+SHD->HD_OP == xFilial("SHD")+cNumOp
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Verifica se devera deletar ou nao os outros itens da grade, confor- ³
			//³ me mv_par12                                                         ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If !lExcGra .And. Right(HD_OP,nTam) != cItemGrd
				dbSkip()
				loop
			EndIf
			RecLock("SHD",.F.,.T.)
			dbDelete()
			dbSkip()
		Enddo

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Se a OP estiver efetivada no CRP deleto a HWF            ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

		If UsaCRP()
			dbSelectArea("HWF")
			dbSetOrder(1)
			If dbSeek(xFilial("HWF")+cNumOp)
				PCPA152Efetivacao():deletaHWF(cNumOp, xFilial("HWF"))
			Endif
		Endif

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Se a OP foi alocada, deleta da SH8.   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		dbSelectArea("SH8")
		dbSetOrder(1)
		//dbSeek(xFilial("SHD")+SC2->C2_NUM+SC2->C2_ITEM)
		//Do While !Eof() .And. H8_FILIAL+Substr(H8_OP,1,8) == cOp

		dbSeek(xFilial("SHD")+SC2->C2_NUM+SC2->C2_ITEM+SC2->C2_SEQUEN+If(lExcGra,"",SC2->C2_ITEMGRD))
		Do While !Eof() .And. SH8->H8_FILIAL+SH8->H8_OP == xFilial("SHD")+cNumOp
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Verifica se devera deletar ou nao os outros itens da grade, confor- ³
			//³ me mv_par12                                                         ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If !lExcGra .And. Right(H8_OP,nTam) != cItemGrd
				dbSkip()
				loop
			EndIf
			RecLock("SH8",.F.,.T.)
			dbDelete()
			dbSkip()
		Enddo

		dbSelectArea("SC2")
		cOp := SC2->C2_NUM+SC2->C2_ITEM+SC2->C2_SEQUEN+If(lExcGra,"",C2_ITEMGRD)
		cItemGrd := SC2->C2_ITEMGRD
		nTam:= Len(cItemGrd)
		dbSelectArea("SD4")
		dbSetOrder(2)
		dbSeek(cFilSD4+cOp)
		While !EOF() .And. D4_FILIAL+If(!lExcGra,D4_OP,left(SD4->D4_OP,len(cOp))) == cFilSD4+cOp

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Verifica se devera deletar ou nao os outros itens da grade, confor- ³
			//³ me mv_par12                                                         ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If !lExcGra .And. Right(D4_OP,nTam) != cItemGrd
				dbSkip()
				loop
			EndIf
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Atualiza arquivo de empenhos               ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			GravaEmp(SD4->D4_COD,;
				SD4->D4_LOCAL,;
				SD4->D4_QUANT,;
				SD4->D4_QTSEGUM,;
				SD4->D4_LOTECTL,;
				SD4->D4_NUMLOTE,;
				NIL,;
				NIL,;
				SD4->D4_OP,;
				SD4->D4_TRT,;
				NIL,;
				NIL,;
				"SC2",;
				SD4->D4_OPORIG,;
				SD4->D4_DATA,;
				@aTravas,;
				.T.,;
				NIL,;
				NIL,;
				.T.,;
				NIL,;
				NIL,;
				NIL,;
				NIL,;
				NIL,;
				NIL,;
				NIL,;
				NIL,;
				NIL,;
				IIF(cPaisLoc=="BRA",SD4->D4_CODLAN,NIL),;
				NIL,;
				NIL,;
				NIL)
			// Deve estornar o empenho no novo WMS quado for o caso - lWmsNew
			If lWmsNew .And. IntWms(SD4->D4_COD)
				WmsEmpReq("SC2",;
							 SD4->D4_COD,;
							 SD4->D4_LOCAL,;
							 SD4->D4_QUANT,;
							 /*cEndereco*/,;
							 SD4->D4_LOTECTL,;
							 SD4->D4_NUMLOTE,;
							/*cNumSerie*/,;
							 SD4->D4_OP,;
							 SD4->D4_TRT,;
							 /*cIdDCF*/,;
							 /*cIdUnitiz*/,;
							 .T.,; // lEstorno
							 .T.,; // lCriaSDC
							 .T.)  // lEmpD14
			EndIf

			dbSelectArea("SG1")
			dbSeek(xFilial("SG1")+SD4->D4_COD)
			If EOF()
				dbSelectArea("SC1")
				dbSetOrder(4)
				dbSeek(xFilial("SC1")+cOp)
				While lExcluiSC .And. !EOF() .And. C1_FILIAL+If(!lExcGra,C1_OP,left(C1_OP,len(cOp))) == xFilial("SC1")+cOp
					If C1_PRODUTO == SD4->D4_COD
						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³ Verifica se devera deletar ou nao os outros itens da grade, confor- ³
						//³ me mv_par12                                                         ³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						If !lExcGra .And. Right(C1_OP,nTam) != cItemGrd
							dbSkip()
							loop
						EndIf

						If !Empty(SC1->C1_COTACAO) .And.  SC1->C1_COTACAO <> Replicate("X",Len(SC1->C1_COTACAO)) .And. SC1->C1_IMPORT <> "S" .And. SC1->C1_QUJE == 0
							Aviso(STR0051,STR0122+AllTrim(SC1->C1_NUM)+STR0123+AllTrim(SC1->C1_ITEM)+STR0124,{'Ok'})
							AADD(aRegsSC1,SC1->(Recno())) //"Aten‡„o"###"A solicitacao de compras numero "###" item "###" nao podera ser excluida pois se encontra em processo de cotacao! "
							dbSkip()
							Loop
						Endif

						If (SC1->C1_TPOP == "F") .And. ((cProgOri == "MATA710") .Or. (cProgOri == "MATA651" .And.;
							Aviso(STR0051,STR0122+SC1->C1_NUM+STR0123+SC1->C1_ITEM+STR0132+AllTrim(SC1->C1_OP)+STR0133,{STR0134,STR0135})==2))
							SC1->(dbSkip())
							Loop
						EndIf

						// Verifica se existe SI vinculada a OP, se existir, emite aviso.
						// Sera permitido apagar a OP porém a SC não será apagada, somente havera a quebra do vinculo
						// com a OP
						If !Empty(SC1->C1_NUM_SI)
	 						Aviso(STR0051,STR0122+AllTrim(SC1->C1_NUM)+STR0123+AllTrim(SC1->C1_ITEM)+STR0140,{'Ok'})
							AADD(aRegsSC1,SC1->(Recno()))//"Aten‡„o"###"A solicitacao de compras numero "###" item "###" nao podera ser excluida pois se encontra em processo de importacao! "
							SC1->(dbSkip())
							Loop
						Endif

						If !Empty(SC1->C1_ACCNUM)
							Aviso(STR0051,STR0122+AllTrim(SC1->C1_NUM)+STR0123+AllTrim(SC1->C1_ITEM)+STR0204,{'Ok'})
							AADD(aRegsSC1,SC1->(Recno())) //A solicitacao de compras numero ### item ### nao podera ser excluida pois se encontra integrada com o Paradigma!
							SC1->(dbSkip())
							Loop
						EndIf

						dbSelectArea("SB2")
						dbSetOrder(1)
						If !MsSeek(xFilial("SB2")+SC1->C1_PRODUTO+SC1->C1_LOCAL)
							CriaSB2(SC1->C1_PRODUTO,SC1->C1_LOCAL)
							MsUnlock()
						EndIf
						If SC1->C1_APROV <> "B" .Or. (SC1->C1_APROV == "B" .And. !lSCSldBl)
							GravaB2Pre("-",(SC1->C1_QUANT-SC1->C1_QUJE),SC1->C1_TPOP)
						EndIf
						// Caso ja haja qtd no PC, iguala qtd na SC para encerra-la
						// Senao deleta
						If SC1->C1_QUJE > 0
							RecLock("SC1",.F.)
							Replace C1_QUANT   With C1_QUJE
							Replace C1_QTSEGUM With ConvUM(SB2->B2_COD, C1_QUJE, 0, 2)
							MsUnlock()
						Else
							//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
							//³ Execblock a ser executado antes da Exclusao do SC1           ³
							//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
							IF (ExistBlock('MT650DC1'))
								ExecBlock('MT650DC1',.F.,.F.)
							Endif
							//Realiza Exclusao de Alcada contabil
							If lAprovEt
								A650ALCCTB(cOp)
							EndIf
							If Type('aProcMRP') == "A" .And. !Empty(SC1->C1_SEQMRP)
								aAdd(aProcMRP, {SC1->C1_SEQMRP, SC1->C1_PRODUTO, SC1->C1_QUANT} )
							EndIf

							//Executa a exclusão da tabela DHN
							aAreaAtu := GetArea()
							COMEXCDHN("1",xFilial("SC1"),SC1->C1_NUM)
							RestArea(aAreaAtu)

							// Gerar Carta de Correcao do Pedido
							RecLock("SC1",.F.,.T.)
							Replace C1_OBS With STR0025 //"CANCELADA PELO SISTEMA."
							dbDelete()
							MsUnLock()
						EndIf
					EndIf
					dbSkip()
				EndDo
				dbSetOrder(1)
				dbSelectArea("SC7")
				dbSetOrder(8)
				dbSeek(xFilial("SC7")+cOp)
				While lExcluiSC .And. !EOF() .And. C7_FILIAL+If(!lExcGra,C7_OP,left(C7_OP,len(cOp))) == xFilial("SC7")+cOp
					If C7_PRODUTO == SD4->D4_COD .And. C7_TIPO == 2
						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³ Verifica se devera deletar ou nao os outros itens da grade, confor- ³
						//³ me mv_par12                                                         ³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						If !lExcGra .And. Right(C7_OP,nTam) != cItemGrd
							dbSkip()
							loop
						EndIf

						If (SC7->C7_TPOP == "F") .And. ((cProgOri == "MATA710") .Or. (cProgOri == "MATA651" .And.;
						Aviso(STR0051,STR0136+SC7->C7_NUM+STR0123+SC7->C7_ITEM+STR0132+AllTrim(SC7->C7_OP)+STR0133,{STR0137,STR0138})==2))
							SC7->(dbSkip())
							Loop
						EndIf

						dbSelectArea("SB2")
						dbSetOrder(1)
						If !MsSeek(xFilial("SB2")+SC7->C7_PRODUTO+SC7->C7_LOCAL)
							CriaSB2(SC7->C7_PRODUTO,SC7->C7_LOCAL)
							MsUnlock()
						EndIf
						nEntregSC7:=SC7->C7_QUJE+SC7->C7_QTDACLA
						GravaB2Pre("-",SC7->C7_QUANT-nEntregSC7,SC7->C7_TPOP)
						// Volta saldo ate a autorizacao de entrega
						If nEntregSC7 > 0 .Or. lExcluiAE
							dbSelectArea("SC3")
							dbSetOrder(1)
							If dbSeek(xFilial("SC3")+SC7->C7_NUMSC+SC7->C7_ITEMSC)
								RecLock("SC3",.F.)
								Replace C3_QUJE With C3_QUJE - (SC7->C7_QUANT-nEntregSC7)
								If C3_QUANT > C3_QUJE .And. C3_ENCER == "E"
									Replace C3_ENCER 	With " "
								Endif
								MsUnlock()
							EndIf
						Endif
						dbSelectArea("SC7")
						// Caso ja haja qtd ENTREGUE no PC
						If nEntregSC7 > 0
							RecLock("SC7",.F.)
							Replace C7_QUANT With SC7->C7_QUJE+SC7->C7_QTDACLA
							Replace C7_TOTAL With SC7->C7_QUANT * SC7->C7_PRECO
							MsUnlock()
						ElseIf lExcluiAE
							//Executa a exclusão da tabela DHN
							aAreaAtu := GetArea()
							If SC7->C7_TIPO == 2
								cTipoDHN := "3"
							Else
								cTipoDHN := "2"
							EndIf
							COMEXCDHN(cTipoDHN,xFilial("SC7"),SC7->C7_NUM)
							RestArea(aAreaAtu)

                            //Exclui AE
                            cTipoSC7 := if(SC7->C7_TIPO == 1,"PC","AE")

                            If MtExistSCR(cTipoSC7, SC7->C7_NUM )
                                MaAlcDoc({SC7->C7_NUM,cTipoSC7 ,0,,,SC7->C7_APROV,,SC7->C7_MOEDA,SC7->C7_TXMOEDA,SC7->C7_EMISSAO},SC7->C7_EMISSAO,3)
                            EndIF

							RecLock("SC7",.F.,.T.)
							Replace C7_OBS With STR0025 //"CANCELADA PELO SISTEMA."
							dbDelete()
							MsUnLock()


						EndIf
					EndIf
					dbSkip()
				EndDo
				dbSetOrder(1)
			EndIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ PE antes da exclusao de cada empenho do SD4      ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ



			If lMTA650EMP
				ExecBlock("MTA650EMP",.F.,.F.,{cOp})
			EndIf

			If FindFunction("A381GrvAgr")
				//Grava os dados do SIGAAGR (Dados existentes somente quando utilizado a integração com o PIMS)
				A381GrvAgr(.T.,SD4->D4_COD, SD4->D4_LOCAL, SD4->D4_OP, SD4->D4_TRT, SD4->D4_LOTECTL, SD4->D4_NUMLOTE)
			EndIf

			dbSelectArea("SD4")
			RecLock("SD4",.F.,.T.)
			dbDelete()
			MsUnLock()
			dbSkip()
		EndDo
		dbSetOrder(1)

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Exclui SC's e AE's que estavam vinculadas a OP   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		A650DelC1C7(cOp,lExcGra,nTam,cItemGrd,@aRegsSC1,cProgOri)

		dbSelectArea("SB2")
		dbSetOrder(1)

		If !MsSeek(xFilial("SB2")+SC2->C2_PRODUTO+SC2->C2_LOCAL)
			CriaSB2(SC2->C2_PRODUTO,SC2->C2_LOCAL)
			MsUnlock()
		EndIf
		iif(!A650DefLeg(5),GravaB2Pre("-",SC2->C2_QUANT,SC2->C2_TPOP,SC2->C2_QTSEGUM),.F.)
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Se tiver um pedido de venda vinculado ,dever  apag -lo   ³
		//³ caso n„o haja um desdobramento da OP ainda pendente      ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If SC2->C2_DESTINA == "P" .Or. SC2->C2_AGLUT == "S"
			dbSelectArea("SC2")
			dbSeek(cFilSC2+Substr(cOP,1,8))
			Do While !Eof() .And. C2_FILIAL+C2_NUM+C2_ITEM == cFilSC2+Substr(cOP,1,8)
				If C2_PRODUTO == cProduto .And. Recno() # nRegSC2
					lOutraOP:=.T.
				EndIf
				dbSkip()
			EndDo
			dbGoTo(nRegSC2)
			dbSelectArea("SC6")
			dbSetOrder(7)
			If dbSeek(xFilial("SC6")+SC2->C2_NUM+SC2->C2_ITEM)
				aRegsSC6:={}
				While !Eof() .And. xFilial("SC6")+SC2->C2_NUM+SC2->C2_ITEM == C6_FILIAL+C6_NUMOP+C6_ITEMOP
					If !lExcGra .And. Upper(Trim(SC2->C2_GRADE)) == 'S' .And. Val(SC2->C2_ITEMGRD) <> Val(SC6->C6_ITEMGRD)
						SC6->(dbSkip())
						Loop
					EndIf
					//Verifica se a ordem de produção foi quebrada para atender lote economico.
					lOpQuebrada := MAT650OPLE(SC2->C2_NUM,SC2->C2_ITEM,SC2->C2_PRODUTO)

					If !Empty(C6_NOTA) .And. !Empty(C6_SERIE) .And. !Empty(C6_DATFAT)
						Help(" ",1,"A650NOTA",,C6_NOTA+" / "+SerieNfId("SC6",2,"C6_SERIE")+" de "+DTOC(C6_DATFAT)+".",02,13)
					EndIf
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Caso esteja OK, desmarca o pedido,liberando o mesmo para ³
					//³ OPs novamente                                            ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

					nQtdAtuEmp := 0
					If C6_OP $ "01#03#08" .And. !lOutraOP
					//verifico se existe quebra da op PAI
						If !lOpQuebrada
							AADD(aRegsSC6,Recno())
							nQtdAtuEmp += SC6->C6_QTDVEN
						Else
							nQtdAtuEmp += SC2->C2_QUANT
						EndIf
					EndIf

					If lAtuSGJ
						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³ Executa a exclusao da tabela SGJ por Item           ³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						A650DelSGJ("I")
					EndIf

					//atualiza a SB2
				    A650AtEmpn(nQtdAtuEmp - A650QLibPv(),"-",SC2->C2_TPOP)

					dbSelectArea("SC6")
					dbSkip()
				End

			Endif

			// Limpa numero das OPs dos Pedidos de Venda
			For nx:=1 to Len(aRegsSC6)
				MAT650CDEL(aRegsSC6[nx])

				If lDeleSC6
					ExecBlock('MA650DC6',.F.,.F.)
				EndIf
			Next nx
		EndIf
		dbSelectArea("SC2")
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Limpa empenho relacionado a OPque esta sendo apagada³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		dbSelectArea("SD4")
		dbSetOrder(4)
		If dbSeek(cFilSD4+SC2->(C2_NUM+C2_ITEM+C2_SEQUEN+C2_ITEMGRD))
			lTratou := .F.
			nRecno := SD4->(Recno())
			nQtdEmp := SD4->D4_QUANT
			nQtdOri := SD4->D4_QTDEORI
			cChave1 := SD4->(D4_FILIAL+D4_COD+D4_OP+D4_TRT+D4_LOTECTL+D4_NUMLOTE)
			cChave2 := SD4->(D4_FILIAL+D4_COD+D4_OP+D4_TRT+D4_LOTECTL+D4_NUMLOTE+D4_LOCAL+D4_ORDEM)

			dbSetOrder(1)
			dbGoTop()
			dbSeek(cChave1)
			While !EOF() .And. SD4->(D4_FILIAL+D4_COD+D4_OP+D4_TRT+D4_LOTECTL+D4_NUMLOTE) == cChave1
				If SD4->(Recno()) # nRecno .And. Empty(SD4->D4_OPORIG) .And.;
									cChave2 == SD4->(D4_FILIAL+D4_COD+D4_OP+D4_TRT+D4_LOTECTL+D4_NUMLOTE+D4_LOCAL+D4_ORDEM)
	  				//--Incrementa a quantidade do empenho no registro encontrado
					RecLock("SD4",.F.)
					Replace D4_QUANT With D4_QUANT + nQtdEmp
					//Replace D4_QTDEORI With D4_QTDEORI + nQtdEmp
					Replace D4_QTDEORI With D4_QTDEORI + nQtdOri
					MsUnLock()

					If lIntSFC
						AtuCYP(SD4->D4_COD, SD4->D4_OP, SD4->D4_LOCAL)
					EndIf

					//--Deleta o registro relacionado a OP
					dbGoTo(nRecno)
					If FindFunction("A381GrvAgr")
						//Grava os dados do SIGAAGR (Dados existentes somente quando utilizado a integração com o PIMS)
						A381GrvAgr(.T.,SD4->D4_COD, SD4->D4_LOCAL, SD4->D4_OP, SD4->D4_TRT, SD4->D4_LOTECTL, SD4->D4_NUMLOTE)
					EndIf
					RecLock("SD4",.F.,.T.)
					dbDelete()
					MsUnLock()
					lTratou := .T.
					Exit
				EndIf

				SD4->(dbSkip())
			EndDo

			If !lTratou
				//--Limpa o campo D4_OPORIG pois nao ha duplicidade
				dbSetOrder(4)
				dbGoTo(nRecno)
				RecLock("SD4",.F.)
				Replace D4_OPORIG With Space(TamSX3("D4_OPORIG")[1])
				MsUnLock()
			EndIf

		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Executa a exclusao das tabelas do SIGAPMS 2-Estorno/3-Exclusao³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		dbSelectArea("SC2")
		PmsWriteOP(2,"SC2")
		PmsWriteOP(3,"SC2")
		A650DelSHC(SC2->C2_PRODUTO,SC2->(C2_NUM+C2_ITEM+C2_SEQUEN+C2_ITEMGRD),SC2->C2_DATPRI)

		A650DelSc1BN(cOp)

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Atualiza variaveis antes da exclusap p/ uso em P.E. ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		cNum	:= SC2->C2_NUM
		cItem	:= SC2->C2_ITEM
		cSeq	:= SC2->C2_SEQUEN

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Integracao com PCP ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If lIntQIP
			If lProcessa
				aAreaSC2 := SC2->(GetArea())
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Integracao TOTVS APS: deleta Operacoes X Ordem (SHY)         ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				TAPSOperac(cNum+cItem+cSeq+cItemGrd,,,,.F.)
				SC2->(RestArea(aAreaSC2))

				// para uso na funcao comgeradoc(processo exclusao) precisa somente da filial e numero da OP
				aDocs:={}
				Aadd(aDocs,{,,cFilAnt,,,/**/,/**/,,/**/,{},cNum,cItem})

				If !Empty(aDocs)
					aResultados := ComGeraDoc(aDocs,,,,,,,,,5  )
				EndIf

				RecLock(cAlias,.F.,.T.)
				dbDelete()
				MsUnLock()
			Endif
		Else
			aAreaSC2 := SC2->(GetArea())
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Integracao TOTVS APS: deleta Operacoes X Ordem (SHY)         ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			TAPSOperac(cNum+cItem+cSeq+cItemGrd,,,,.F.)
			SC2->(RestArea(aAreaSC2))

			// para uso na funcao comgeradoc(processo exclusao) precisa somente da filial e numero da OP
			aDocs:={}
			Aadd(aDocs,{,,cFilAnt,,,/**/,/**/,,/**/,{},cNum,cItem})

			If !Empty(aDocs)
				aResultados := ComGeraDoc(aDocs,,,,,,,,,5  )
			EndIf
			RecLock(cAlias,.F.,.T.)
			dbDelete()
			MsUnLock()
		Endif

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Ponto de entrada apos a exclusao - MTA650AE 	    ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If lMTA650AE
			ExecBlock("MTA650AE",.F.,.F.,{cNum,cItem,cSeq})
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Limpa o numero da OP das SC's que nao foram excluidas que estavam em processo de cotacao ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If Len(aRegsSC1) > 0
			For nX:= 1 To Len(aRegsSC1)
				SC1->(dbGoTo(aRegsSC1[nX]))
				RecLock("SC1",.F.)
				Replace C1_OP With CriaVar("C1_OP")
				MsUnlock()
			Next
		Endif

		//Exclui as ordens de substituição existentes desta ordem.
		delOrdSub(cOp)
	Else
		lProcessou:=.T. // Variavel usada apenas na Rotina de Cancelamento de OPs
	EndIf
	dbSelectArea("SC2")
	dbSkip()
	//Nao pode dar Skip(-1) quando for deletar todos os Itens da Grade,  pois dependendo do item
	//que foi selecionado para exclusao, o ponteiro podera' ficar posicionado em outra OP, nao deletando
	//as demais.
	If EMPTY(SC2->C2_ITEMGRD) .And. lExcGra .and. SC2->(Eof())
		// Para que o Refresh da tela funcione corretamente quando
		// deletamos os ultimos registros do browse (da Enchoice).
		dbSkip(-1)
	EndIf
EndIf
SC6->(dbSetOrder(1))
RETURN

/*/{Protheus.doc} MAT650OPLE
	Valida se existe quebra da OP PAI por lote economico
	Mesmo numero de OP, mesmo produto com sequencias diferentes.
	@type  Static Function
	@author mauricio.joao
	@since 17/06/2021
	@version 1.0
	@param cNumOp, char, numero da op
	@param cItemOp, char, item da op
	@return lExiste, logical, se existe a quebra da op pai.
	/*/
Function MAT650OPLE(cNumOp, cItemOp, cProduto)
	Local aAliasSC6 := SC6->(GetArea())
	Local cQuery := GetNextAlias()
	Local lExiste := .F.

	BeginSql alias cQuery

    SELECT
        COUNT(SC2.C2_NUM) TOTAL
    FROM
        %table:SC2% SC2
    WHERE
        SC2.C2_FILIAL= %xfilial:SC2% AND
        SC2.C2_NUM = %exp:cNumOp% AND
        SC2.C2_ITEM = %exp:cItemOp% AND
		SC2.C2_PRODUTO = %exp:cProduto% AND
        SC2.%notDel%

	EndSql
	//se houver mais de uma op não deletada com o nmesmo numero, existe quebra.
	lExiste :=  Iif( (cQuery)->TOTAL > 1 , .T., .F.)
	(cQuery)->(DbCloseArea())

	RestArea(aAliasSC6)

Return lExiste
/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³ Fun‡„o   ³ MontEstru³ Autor ³ Eveli Morasco         ³ Data ³ 09/09/92 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Descri‡„o³ Monta array com estrutura do produto                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Sintaxe  ³ MontEstru(ExpC1,ExpN1,ExpD1,ExpC2,ExpN2,ExpC3,ExpL1,ExpC4, ³±±
±±³          ³           ExpL2,ExpC5,ExpC6,ExpC7)                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Codigo do produto a ser explodido                  ³±±
±±³          ³ ExpN1 = Quantidade a ser explodida                         ³±±
±±³          ³ ExpD1 = Data Prevista de Entrega                           ³±±
±±³          ³ ExpC2 = Campo da Projecao de Estoques                      ³±±
±±³          ³ ExpN2 = Sequencia da OP                                    ³±±
±±³          ³ ExpC3 = Prioridade da OP                                   ³±±
±±³          ³ ExpL1 = Considera saldo em estoque (.T. Sim .F. Nao)       ³±±
±±³          ³ ExpC4 = String com opcionais selecionados                  ³±±
±±³          ³ ExpL2 = Indicador se gera uma unica OP por produto qdo     ³±±
±±³          ³         utiliza projecao de estoques                       ³±±
±±³          ³ ExpC5 = Tipo da Ordem de Producao                          ³±±
±±³          ³ ExpC6 = Revisao do Produto                                 ³±±
±±³          ³ ExpC7 = String com toda arvore para controle de opcionais  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
*/
Function MontEstru(cProduto,nQuantPai,dEntrega,cCpoProj,cSeqPai,cPrior,lConsEst,cOpcionais,lOne,cTpOp,cRevisao,cStrOpc,aOPInt,cProOpc,aMRPxJson,aArrOpc)
Static l650LocEmp

Local nR		:= 0
Local nRegSC2	:= 0
Local nQuantItem:= 0
Local nQtyStok	:= 0
Local nQtdBack	:= 0
Local nAchoOpc	:= 0
Local nNecessid := 0
Local nSG1		:= 0
Local nRecSB1	:= 0
Local nAchoSeq	:= 0
Local nBaixa    := 0
Local nEstSeg   := 0
Local i         := 0
Local nPeriodo  := 0
Local nSaldoSB2 := 0
Local nQtdSC    := 0
Local nQtdPrj   := 0
Local nOpca		:= 3

Local aAlter    := {}
Local aObjects  := {}
Local aPosObj   := {}
Local aScAglu   := {}
Local aQtdes    := {}
Local aSalvRot	:= {}
Local aSalvCols	:= {}
Local aSeq		:= {}
Local aOps		:= {}
Local aTravas	:= {}
Local aButtons  := {}
Local aRetPE	:= {}

Local cLocalSC1	 := ""
Local cPeriodoOpc:= ""
Local cOldTipo   := ""
Local cLocAnt    := ""
Local cRevAtu    := ""
Local cSeqC2Aux	 := ""

Local lConsAlmTer := SuperGetMV("MV_SLDATER",.F.,.F.)
Local lRastroLoc  := .T.
Local lRetBlock   := .T.
Local lOkPeri     := .T.

Local cDesc		 := SB1->B1_DESC
Local nSalB1     := SB1->(Recno())
Local lAltEmp    := (SubStr( cAcesso,37,1 ) == "S")
Local lExistBlkT := ExistTemplate("A650SALDO")
Local lA650CCF   := ExistBlock("A650CCF")
Local lExistBlock:= ExistBlock("A650SALDO")
Local lBlockOPI  := ExistBlock("A650OPI")
Local lMA650SAL  := ExistBlock("MA650SAL")
Local lA650REVEM := ExistBlock("A650REVEM")
Local lMA650SEQ  := ExistBlock("MA650SEQ")
Local lEMP650    := ExistBlock( "EMP650" )
Local lM650BUT   := ExistBlock( "M650BUT" )
Local lMA650EMP  := ExistBlock( "MA650EMP" )
Local lMA650Dlg	 := ExistBlock("MA650DLG")
Local lA650ALTD4 := ExistBlock("A650ALTD4")
Local lMTA650GEM := ExistBlock("MTA650GEM")
Local cLocProc   := GetMvNNR('MV_LOCPROC','99')
Local lEmpPrj    := SuperGetMV("MV_EMPPRJ",.F.,.T.)
Local lEmpBN 	 := SuperGetMV("MV_EMPBN",.F.,.F.)
Local lGERAPI    := SuperGetMv("MV_GERAPI")
Local lGRCLOCP   := SuperGetMV("MV_GRVLOCP",.F.,.T.)
Local lOPIPROC   := SuperGetMv("MV_OPIPROC",.F.,.T.)
Local lBuyBN     := MatBuyBN()
Local lEstMax    := lProj711 .And. aPergs711[19] == 2 .And. aPergs711[1] == 1
Local aSize      := MsAdvSize()
Local aInfo      := {aSize[1],aSize[2],aSize[3],aSize[4],3,3}
Local lEvento001 := MExistMail("001")
Local laSAv651   := TYPE("aSAv651") == 'A'
Local aNegEst	 := {}
Local cFormMRP   := ""
Local lRetPe 	 := .T.


Local nX,cOp,cTipo,lProjIni,nY
Local aComplCols
Local lGeraSc,lGeraOPI
Local oGet,oDlg2
Local cTitulo
Local lProj
Local cD4_OPORIG  := ''
Local aAreaSH5 := If (lProj711 .And. !lMata712 .And. !lPCPA107, SH5->(GetArea()),nil)
Local aAreaCZI := If (lMata712, CZI->(GetArea()),nil)
Local aAreaSOQ := If (lPCPA107, SOQ->(GetArea()),Nil)
Local lExistComp
Local nInd       := 0
Local cOpcSB1    := ""
Local cNameFile := "MontEstru-" + Dtos(Date()) + ".log"

Local cEventID   := 0    // Variavel usada para armazenar o ID do EventViewer
Local cMensagem  := " " // Variavel para armazenar a mensagem utilizada no eventviewer

Local cFilSB1 := xFilial("SB1")
Local cFilSB2 := xFilial("SB2")
Local cFilSG1 := xFilial("SG1")
Local lPrdOrg := .F.

Local aSVF		:= {}
Local aT4I		:= {}
Local aSVJ		:= {}
Local cProdOriAux
Local cTrtOriAux
Local nQtdOriAux
Local cLocAnAux

Local aColsExc    := {}

Local lDelTBMRP  := _lNewMRP == NIL
Local lIntLocal  := aMRPxJson  == NIL
Local lIntNewMRP := Iif(_lNewMRP  == Nil, FindFunction("Ma650MrpOn") .AND. Ma650MrpOn(@_lNewMRP),_lNewMRP)
Local lRevOk     := .F.
Local lLite      := .F.
Local lMA650ACG  := ExistBlock('MA650ACG')
Local nAc        := 0

Default aOPInt    := {}
Default cProOpc   := cProduto + Space(Len(SG1->G1_TRT))
Default aMRPxJson := Iif(lIntNewMRP, {{}, JsonObject():New()}, Nil) //{aDados para commit, JsonObject() com RECNOS} - Integracao Novo MRP - APONTAMENTOS

Private cLocCQ    := ""
Private cPrdEmpDop:= ""
Private lPrevista := .F.
Private aCols     := {}
Private aColsDele := {}
Private aOpcCam   := {}
Private aRecNec   := {}

Private _lErrSFC := .F.
Private _nHndSFC := ""

Default nMetricEmp := 0

If lIntSFC
	If Empty(_nHndSFC) .Or. !(File(cNameFile))
		_nHndSFC := FCreate(cNameFile)
	EndIf
EndIf

If SB1->B1_GRADE == "S" .AND. Empty(cRevisao)
	cRevisao := PCPREVATU(cProduto)
EndIf

mvlPCPOS := IIf(mvlPCPOS  == NIL, SuperGetMV("MV_PCPOS" ,.F.,.F.) .And. FindFunction("geraOrdSub"), mvlPCPOS)
lEMPREVVAZ := IIF(lEMPREVVAZ == Nil, ExistBlock("EMPREVVAZ") .And. ExecBlock('EMPREVVAZ',.F.,.F.), lEMPREVVAZ)

dbSelectArea('SD4')
If SD4->(FieldPos('D4_PRDORG')) > 0
	lPrdOrg := .T.
EndIf

cLocCQ    := GetMvNNR('MV_CQ','98')


//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Verifica se a rotina esta sendo chamada da Proj.Estoques NOVA ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
lProj711:=If(Type("lProj711") == "L",lProj711,.F.)

l650Auto := Iif(Type("l650Auto")=="L",l650Auto,.F.)

If lProj711 .And. !lMata712 .And. !lPCPA107 .And. Select('SH5') > 0
	aAreaSH5 := SH5->(GetArea())
EndIf

lAltEmp 	:= If( (ValType( lAltEmp ) # "L"),.F.,lAltEmp )
l650LocEmp 	:= If(ValType(l650LocEmp)#"L",ExistBlock("A650LEMP"),l650LocEmp)

If TYPE("aRotina") == "A"
	aSalvRot := aClone(aRotina)
Endif

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Tratamento da variavel "aSav650", que armazena as perguntas MTA650  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If !(Type('aSav650')=='A') .Or. !Empty(AsCan(aSav650,{|x|x == NIL}))
	aSav650 := Array(20)
	MTA650PERG(.F.)
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Se a chamada da funcao vier da projecao, verifica se    ³
//³ e' Projecao pelo inicio :                               ³
//³ Se Sim nao gera op dos filhos e solicitacao de compra.  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
lProj	 := If(  cCpoProj == NIL ,.F.,.T.)
lProjIni := If( (cCpoProj == NIL),.F.,If(cCpoProj == "INICIO",.T.,.F.) )
lConsEst := If( (lConsEst == NIL),(SuperGetMV("MV_CONSEST",.F.,"S") == "S"),lConsEst )

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Se a chamada da funcao vier da projecao, verifica se    ³
//³ e' Projecao, quanto a geracao da sc (nPar02 - PRIVATE)  ³
//³ 1 - Gera Sc no Mata650   2 - Gera SC no MATA710         ³
//³ quanto a geracao da OP PI (nPar03 - PRIVATE)            ³
//³ 1 - Gera OP de PI (Mata650)  2 - Gera OP de PI (MATA710)³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If cCpoProj != NIL
	If nPar02 == 2
		lGeraSc := .F.
	Else
		lGeraSC := .T.
	Endif
	If nPar03 == 2
		lGeraOPI:= .F.
	Else
		lGeraOPI:= .T.
	Endif
ElseIf lProj711
	If (i := aScan(aRotProd,{|x| AllTrim(x[1]) == "GERANEC"})) > 0 .And. aRotProd[i,2] == .T.
		lGeraSC  := .F.
		lGeraOPI := .F.
	Else
		SB5->(dbSetOrder(1))
		If SB5->(dbSeek(xFilial("SB5")+cProduto))
			cFormMRP := SB5->B5_FORMMRP
		Else
			cFormMRP := '1'
		EndIf
		If cFormMRP $ ' 1'
			lGeraSC  := aPergs711[2] == 1
			lGeraOPI := aPergs711[3] == 1
		Else
			lGeraSC  := cFormMRP == '2'
			lGeraOPI := cFormMRP == '2'
		EndIf
	EndIF
Else
	lGeraSc := SuperGETMV("MV_GERASC")
	lGeraOPI:= SuperGETMV("MV_GERAOPI")

	//-- Verifica se ha flag no array da execauto para nao gerar SCs
	If l650Auto .And. (i := aScan(aRotProd,{|x| AllTrim(x[1]) == "GERASC"})) > 0 .And. ValType(aRotProd[i,2]) == "C"
		lGeraSc := aRotProd[i,2] == "S"
	EndIf

	//-- Verifica se ha flag no array da execauto para nao gerar OPIs
	If l650Auto .And. (i := aScan(aRotProd,{|x| AllTrim(x[1]) == "GERAOPI"})) > 0 .And. ValType(aRotProd[i,2]) == "C"
		lGeraOPI := aRotProd[i,2] == "S"
	EndIf
Endif

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Grava nas Ops filhas o numero da sequencia da Op Pai    ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

cSeqPai := IIf(cSeqPai != NIL,cSeqPai,"000")

cPrior  := IIf(cPrior != NIL,cPrior,"500")

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Pega o numero da OP que serao gerados os empenhos       ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
cOp := SC2->C2_NUM+SC2->C2_ITEM+SC2->C2_SEQUEN+SC2->C2_ITEMGRD

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Verifica se utiliza OP Prevista                         |
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
lPrevista := SC2->C2_TPOP == 'P'

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Monta o array aCols verificando se existem produtos     ³
//³ fantasma na estrutura.                                  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
aRotina   := { { "" , "        ", 0 , 3}}

// Verifica se tem que zerar o aHeader
if !IsInCallStack('MATA760')
	If lZrHeader
		lZrHeader := .F.
		aHeader := {}
	EndIf
EndIf

// Joga o conteúdo da variavel cProduto para a variavel private cPrdEmpDop
// que será utilizada na função EmpPai() não é possível passar por parâmetro.
cPrdEmpDop := cProduto
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Montagem do AHeader.                                         ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If Type('aHeader')<>'A' .Or. (Type('aHeader')=='A' .And. Len(aHeader)==0) .Or. lMTA650AC .Or. lMA650ACG
 	PRIVATE aHeader := {}
	aTam:=TamSX3("G1_COMP")	//1
	Aadd(aHeader,{STR0026,"G1_COMP" ,PesqPict("SG1","G1_COMP" ,atam[1]),aTam[1],aTam[2],"NaoVazio() .And. ExistCpo('SB1') .And. EmpPai() .And. A650IniPrd()",USADO, "C" ,"SG1"," " })	//"Componente"
	aTam:=TamSX3("D4_QUANT")//2
	Aadd(aHeader,{STR0027,"D4_QUANT",PesqPict("SD4","D4_QUANT"),aTam[1],aTam[2],"A650ConvUM(2) .And. M->D4_QUANT # 0 .And. A650VlQtNg() .And. A380TipDec(aCols[n,nPosCod],aCols[n,nPosQuant],aCols[n,nPosQuant],2) .And. A650VlQtNe(aCols[n,nPosCod]) ",USADO, "N" ,"SD4"," " })	//"Quantidade Empenho"
	aTam:=TamSX3("D4_LOCAL")//3
	Aadd(aHeader,{STR0028,"D4_LOCAL",PesqPict("SD4","D4_LOCAL",atam[1]),aTam[1],aTam[2],"NaoVazio() .And. existcpo('SB2',aCols[n,1]+M->D4_LOCAL) .And. M->D4_LOCAL <> cLocCQ .And. ValLocProc(aCols[n,1])",USADO, "C" ,"SD4"," " })	//"Local"
	aTam:=TamSX3("G1_TRT")	//4
	Aadd(aHeader,{STR0017,"G1_TRT"  ,PesqPict("SG1","G1_TRT"  ,atam[1]),aTam[1],aTam[2],"A650Seq()",USADO, "C" ,"SG1"," " })	//"Sequencia"
	aTam:=TamSX3("D4_NUMLOTE")//5
	Aadd(aHeader,{STR0029,"D4_NUMLOTE",PesqPict("SD4","D4_NUMLOTE",atam[1]),aTam[1],aTam[2],"A650LotCTL()",USADO, "C" ,"SD4"," " })	//"Sub-Lote"
	aTam:=TamSX3("D4_LOTECTL")//6
	Aadd(aHeader,{STR0030,"D4_LOTECTL",PesqPict("SD4","D4_LOTECTL",atam[1]),aTam[1],aTam[2],"A650LotCTL()",USADO, "C" ,"SD4"," " })	//"Lote"
	aTam:=TamSX3("D4_DTVALID")//7
	Aadd(aHeader,{STR0031,"D4_DTVALID",PesqPict("SD4","D4_DTVALID",atam[1]),aTam[1],aTam[2]," ",USADO, "D" ,"SD4"," " })	//"Data de Validade"
	aTam:=TamSX3("D4_POTENCI")//8
	Aadd(aHeader,{STR0089,"D4_POTENCI",PesqPict("SD4","D4_POTENCI",atam[1]),aTam[1],aTam[2]," ",USADO, "N" ,"SD4"," " })	//"Potencia"
	aTam:=TamSX3("DC_LOCALIZ")//9
	Aadd(aHeader,{STR0048,"DC_LOCALIZ",PesqPict("SDC","DC_LOCALIZ" ,atam[1]),aTam[1],aTam[2],"Vazio() .Or. (ExistCpo('SBE',aCols[n,3]+M->DC_LOCALIZ) .And. A650VldLoclz(." + If(lConsEst, "T", "F") + ".))",USADO, "C" ,"SBE"," " })	//"Localizacao"
	aTam:=TamSX3("DC_NUMSERI")//10
	Aadd(aHeader,{STR0049,"DC_NUMSERI",PesqPict("SDC","DC_NUMSERI" ,atam[1]),aTam[1],aTam[2],"",USADO, "C" ,""," " })	//"Num de Serie"
	aTam:=TamSX3("B1_UM")//11
	Aadd(aHeader,{STR0069,"B1_UM",PesqPict("SB1","B1_UM",atam[1]),aTam[1],aTam[2],,USADO, "C" ,"SB1","V" })	//" 1a. UM
	aTam:=TamSX3("D4_QTSEGUM")//12
	Aadd(aHeader,{STR0068,"D4_QTSEGUM",PesqPict("SD4","D4_QTSEGUM",atam[1]),aTam[1],aTam[2],"A650ConvUM(1)",USADO, "N" ,"SD4"," " })	//"Quantidade Empenho 2a. UM"
	aTam:=TamSX3("B1_SEGUM")//13
	Aadd(aHeader,{STR0070,"B1_SEGUM",PesqPict("SB1","B1_SEGUM",atam[1]),aTam[1],aTam[2],,USADO, "N" ,"SB1"," " })	// "2a. UM"
	aTam:=TamSX3("B1_DESC")	//14
	Aadd(aHeader,{STR0085,"B1_DESC" ,PesqPict("SB1","B1_DESC" ,atam[1]),aTam[1],aTam[2],,USADO, "C" ,"SB1"," " })	//"Descri‡„o"
	aTam:=TamSX3("D4_OPERAC")	//15
	Aadd(aHeader,{STR0194,"D4_OPERAC",PesqPict("SD4","D4_OPERAC" ,aTam[1]),aTam[1],aTam[2],,USADO, "C" ,"SD4"," " })	//Operação
	If lPrdOrg
		aTam:=TamSX3("D4_PRDORG") //16
		Aadd(aHeader,{"Prd. Orig.","D4_PRDORG",PesqPict("SD4","D4_PRDORG" ,aTam[1]),aTam[1],aTam[2],,USADO, "C" ,"SD4"," " })	//Prd. Orig.
	EndIf
	Aadd(aHeader,{STR0200,"PRDALTERN","",5,0,,,"C",""," " })	//"Alternativo?"

	aTam:=TamSX3("G1_TRT")	//TRTORI
	Aadd(aHeader,{STR0207,"TRTORI"  ,PesqPict("SG1","G1_TRT"  ,atam[1]),aTam[1],aTam[2],"A650Seq()",USADO, "C" ,"SG1"," " })	//"Seq.Origem"

EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Execblock Para Inserir Campo em aCols - MTA650AC        ³
//³ 1 - Complemento do aHeader                              ³
//³ 2 - Conteudo do aCols                                   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lMTA650AC
	aComplCols := ExecBlock('MTA650AC',.F.,.F.)
	If Len(aComplCols[1]) != 0
		Aadd(aHeader,aComplCols[1])
	EndIf
ElseIf lMA650ACG
	aComplCols := ExecBlock('MA650ACG', .F., .F.)
	If Len(aComplCols) != 0
		For nAc := 1 To Len(aComplCols)
			Aadd(aHeader,aComplCols[nAc])
		Next nAc
	EndIf
Else
	aComplCols := {{},}
EndIf

nPosCod    :=aScan(aHeader,{|x| AllTrim(x[2])=="G1_COMP"})
nPosQuant  :=aScan(aHeader,{|x| AllTrim(x[2])=="D4_QUANT"})
nPosLocal  :=aScan(aHeader,{|x| AllTrim(x[2])=="D4_LOCAL"})
nPosTrt    :=aScan(aHeader,{|x| AllTrim(x[2])=="G1_TRT"})
nPosLote   :=aScan(aHeader,{|x| AllTrim(x[2])=="D4_NUMLOTE"})
nPosLotCTL :=aScan(aHeader,{|x| AllTrim(x[2])=="D4_LOTECTL"})
nPosDValid :=aScan(aHeader,{|x| AllTrim(x[2])=="D4_DTVALID"})
nPosPotenc :=aScan(aHeader,{|x| AllTrim(x[2])=="D4_POTENCI"})
nPosLocLz  :=aScan(aHeader,{|x| AllTrim(x[2])=="DC_LOCALIZ"})
nPosnSerie :=aScan(aHeader,{|x| AllTrim(x[2])=="DC_NUMSERI"})
nPosUM     :=aScan(aHeader,{|x| AllTrim(x[2])=="B1_UM"})
nPosQtSegum:=aScan(aHeader,{|x| AllTrim(x[2])=="D4_QTSEGUM"})
nPos2UM    :=aScan(aHeader,{|x| AllTrim(x[2])=="B1_SEGUM"})
nPosDescr  :=aScan(aHeader,{|x| AllTrim(x[2])=="B1_DESC"})
nPosOper   :=aScan(aHeader,{|x| AllTrim(x[2])=="D4_OPERAC"})
nPosPrdOrg :=aScan(aHeader,{|x| AllTrim(x[2])=="D4_PRDORG"})
nPosIsAlt  :=aScan(aHeader,{|x| AllTrim(x[2])=="PRDALTERN"})
nPosTRTORI :=aScan(aHeader,{|x| AllTrim(x[2])=="TRTORI"})

//aLotesUsado := {}

If !lMTA650AC .And. lMA650ACG
	A650ACols(cProduto,nQuantPai,cOpcionais,lConsEst,cRevisao,aComplCols,aHeader,cLocProc,cProOpc,@aOpcCam,,,@aMRPxJson,,aArrOpc)
Else
	A650ACols(cProduto,nQuantPai,cOpcionais,lConsEst,cRevisao,aComplCols[2],aHeader,cLocProc,cProOpc,@aOpcCam,,,@aMRPxJson,,aArrOpc)
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Pontos de Entrada   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If (ExistTemplate( "EMP650" ) )
	ExecTemplate("EMP650",.F.,.F.,{cStrOpc})
EndIf

If lEMP650
	ExecBlock("EMP650",.F.,.F.,{cStrOpc})
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Varre o array aCols verificando se existem produtos     ³
//³ com o mesmo nivel e sequencia na estrutura. Caso isso   ³
//³ ocorra, soma o nivel do segundo para n„o gerar divergen ³
//³ cias na hora da producao.                               ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

For i:=1 To Len(aCols)
	If /*!aCols[i,Len(aCols[i])]*/ aScan(aColsDele,{|x| x == i}) == 0
		nAchoSeq:=ASCAN(aSeq,aCols[i,nPosCod]+aCols[i,nPosTrt]+aCols[i,nPosLote]+aCols[i,nPosLotCtl]+aCols[i,nPosLocLz]+aCols[i,nPosnSerie]+aCols[i,nPosLocal])
		IF nAchoSeq > 0
			aCols[i,nPosTrt]:=Soma1(aCols[i,nPosTrt])
			nAchoSeq:=ASCAN(aSeq,aCols[i,nPosCod]+aCols[i,nPosTrt]+aCols[i,nPosLote]+aCols[i,nPosLotCtl]+aCols[i,nPosLocLz]+aCols[i,nPosnSerie]+aCols[i,nPosLocal])
			While nAchoSeq > 0
				aCols[i,nPosTrt]:=Soma1(aCols[i,nPosTrt])
				nAchoSeq:=ASCAN(aSeq,aCols[i,nPosCod]+aCols[i,nPosTrt]+aCols[i,nPosLote]+aCols[i,nPosLotCtl]+aCols[i,nPosLocLz]+aCols[i,nPosNserie]+aCols[i,nPosLocal])
			EndDo
			AADD(aSeq,aCols[i,nPosCod]+aCols[i,nPosTrt]+aCols[i,nPosLote]+aCols[i,nPosLotCtl]+aCols[i,nPosLocLz]+aCols[i,nPosnSerie]+aCols[i,nPosLocal])
		Else
			AADD(aSeq,aCols[i,nPosCod]+aCols[i,nPosTrt]+aCols[i,nPosLote]+aCols[i,nPosLotCtl]+aCols[i,nPosLocLz]+aCols[i,nPosnSerie]+aCols[i,nPosLocal])
		Endif
	EndIf
Next i

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Salva em aSalvCols o array aCols para copia de seguranca.    ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
aSalvCols := AClone(aCols)

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ PE para alterar a qtde. de empenho antes da tela             ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If ValType(lA650ALTD4)=='L' .And. lA650ALTD4
	ExecBlock("A650ALTD4",.F.,.F.,{cStrOpc})
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Caso usuario deseje alterar empenho, monta GetDados.         ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lAltEmp .And. Len(aCols) > 0 .And. aSav650[13] == 1 .And. !l650Auto
	Private aTELA[0,0],aGETS[0]
	Private nUsado := 5
	nPosAtu:=0
	nPosAnt:=9999
	nColAnt:=9999
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Ativa tecla F4 para comunicacao com Saldos dos Lotes         ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	SetKey( VK_F4, {||ShowF4()})
	If lMTA650AC
		cTitulo:=OemToAnsi(STR0032+Trim(cProduto)+ " - "+Trim(cDesc)+" / "+cOp)	//"Altera‡„o de Empenho - "
	Else
		cTitulo:=OemToAnsi(STR0032+AllTrim(cProduto)+" / "+cOp)	//"Altera‡„o de Empenho - "
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Executa ponto de entrada para montar array com botoes a      ³
	//³ serem apresentados na tela de alteracao de empenho           ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lM650BUT
		aButtons:=ExecBlock("M650BUT",.F.,.F.)
		If ValType(aButtons) # "A"
			aButtons:={}
		EndIf
	Endif
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Botao para exportar dados para EXCEL                    ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If RemoteType() == 1
		aColsExc := AClone(aCols)
		For i:=1 To Len(aCols)
			If ValType(aCols[i][Len(aCols[i])-1]) == "A"
				aDel(aColsExc[i],Len(aColsExc[i])-1)
				aSize(aColsExc[i],Len(aColsExc[i])-1)
			EndIf
		Next i

		aAdd(aButtons   , {PmsBExcel()[1],{|| DlgToExcel({ {"GETDADOS",cTitulo,aHeader,aColsExc}})},PmsBExcel()[2],PmsBExcel()[3]})
	EndIf
	If ( !l650Auto )
		For i := 1 to Len(aHeader)

			If ! aHeader[i,2] $ "B1_UM, B1_SEGUM, PRDALTERN,TRTORI"
				Aadd(aAlter, aHeader[i,2])
			Endif
		Next
		nOpca := 0
		AADD(aObjects,{100,100,.T.,.T.,.F.})
		aPosObj:=MsObjSize(aInfo,aObjects)
		If lMA650Dlg
			lRetPe := ExecBlock("MA650DLG",.F.,.F.)
			If ValType (lRetPe) != "L"
				lRetPe := .T.
			EndIf
		EndIf
		If lRetPe
			DEFINE MSDIALOG oDlg2 TITLE ctitulo OF oMainWnd PIXEL FROM aSize[7],0 TO aSize[6],aSize[5]
		Else
			DEFINE MSDIALOG oDlg2 TITLE ctitulo OF oMainWnd PIXEL FROM aSize[7],0 TO aSize[6],aSize[5] STYLE DS_MODALFRAME
		EndIf
		oGet := MSGetDados():New(aPosObj[1,1],aPosObj[1,2],aPosObj[1,3],aPosObj[1,4],1,"A650LinOk","A650AETdOk","",.T.,,,,1024,,,,"A650DelOK")
		oGet:oBrowse:aAlter := aAlter
		If lRetPe
			ACTIVATE MSDIALOG oDlg2 ON INIT (EnchoiceBar(oDlg2,{||If(A650AETdOk(),(nopca:=1,oDlg2:End()),.F.)},{||oDlg2:End()},,aButtons),A650DelCols(oGet:oBrowse))
		Else
			ACTIVATE MSDIALOG oDlg2 ON INIT (EnchoiceBar(oDlg2,{||If(A650AETdOk(),(nopca:=1,oDlg2:End()),.F.)},{||.T.},,aButtons),A650DelCols(oGet:oBrowse))
		EndIf
	Else
		nopca:=1
	EndIF
	If nOpca == 0
		aCols := AClone(aSalvCols)
	Else
		aSalvCols:=AClone(aCols)
	EndIf
	Set Key VK_F4 TO
EndIf

fOrdenaAcols(@aSalvCols,@aOpcCam)

aCols := AClone(aSalvCols)

For nSG1 := 1 to Len(aSalvCols) //commit dos empenhos ou recursivo (quando for pai)

	aSize(aSVF,0)
	aSize(aT4I,0)
	aSize(aSVJ,0)

	If aSalvCols[nSG1,Len(aSalvCols[nSG1])] .Or. Empty(aSalvCols[nSG1,1])
		Loop
	Endif
	aQtdes     := {}
	nQuantItem := aSalvCols[nSG1,nPosQuant]
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Posiciona SB1                          ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If SB1->B1_COD != aSalvCols[nSG1,nPosCod]
		SB1->(dbSetOrder(1))
		SB1->(MsSeek(cFilSB1+aSalvCols[nSG1,nPosCod]))
	EndIf
	cRoteiro:= SB1->B1_OPERPAD

	If QtdComp(nQuantItem,.T.) == QtdComp(0)
		Loop
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Valida Armazem de CQ                   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If aSalvCols[nSG1,nPosLocal] == cLocCQ
		aSalvCols[nSG1,nPosLocal] := RetFldProd(SB1->B1_COD,"B1_LOCPAD")
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Posiciona SB2                          ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

	If SB1->B1_APROPRI == 'I'
		cLocal := SB1->B1_LOCPAD
	Else
		cLocal := aSalvCols[nSG1,nPosLocal]
	EndIf

	dbSelectArea("SB2")
	dbSetOrder(1)
	MsSeek(cFilSB2+aSalvCols[nSG1,nPosCod]+cLocal)
	If Eof()
		CriaSB2(aSalvCols[nSG1,nPosCod],cLocal)
		MsUnlock()
	EndIf
	If mv_par02 = 1 .And. cCpoProj == NIL .And. !lProj711
		If lConsEst
			If !lEmpPrj
				nQtdPrj := SB2->B2_QEMPPRJ
			EndIf
			nQtyStok := SaldoSB2(.T., , ,lConsTerc,lConsNPT,,,nQtdPrj)+SB2->B2_SALPEDI-SB2->B2_QEMPN+AvalQtdPre("SB2",2)
			If lPrevista .And. ( nQtyStok > SB2->B2_QEMPPRE )
				nQtyStok -= SB2->B2_QEMPPRE
			Endif

			//Calc. Estoque de Apropriação Indireta
			If SB1->B1_APROPRI == 'I' .And. aSalvCols[nSG1,nPosLocal] == cLocProc
				nQtyStok := fCalcStokInd(cFilSB2,SB1->B1_LOCPAD,aSalvCols,nSG1,nQtyStok,@nQtdPrj)
			Else
				nQtyStok += A650Prev(SB2->B2_COD)
			EndIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Executa P.E. para tratar saldo disponivel.                    ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If lExistBlkT
				nQtdBack:=nQtyStok
				nQtyStok:=ExecTemplate("A650SALDO",.F.,.F.,nQtyStok)
				If ValType(nQtyStok) != "N"
					nQtyStok:=nQtdBack
				EndIf
			EndIf
			If lExistBlock
				nQtdBack:=nQtyStok
				nQtyStok:=ExecBlock("A650SALDO",.F.,.F.,nQtyStok)
				If ValType(nQtyStok) != "N"
					nQtyStok:=nQtdBack
				EndIf
			EndIf
		Else
			nQtyStok := 0
		Endif
	Else
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Posiciona SB2                          ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		nQtyStok := 0
		If cCpoProj <> NIL
			nQtyStok:=A650SldMRP(.F.,.T.,aSalvCols[nSG1,nPosCod],dEntrega,cOpcionais)
		ElseIf lProj711 .And. nQuantItem > 0
			nQtyStok:=Max(A650SldMRP(.T.,.F.,aSalvCols[nSG1,nPosCod],dEntrega,cOpcionais)+nQuantItem,0)
		ElseIf lConsEst
			dbSelectArea("SB2")
			dbSetOrder(1)
			dbSeek(cFilSB2+aSalvCols[nSG1,nPosCod]+aSav650[3],.T.)
			lPrimo := .T.
			While !Eof() .And. SB2->B2_FILIAL+SB2->B2_COD+SB2->B2_LOCAL <= cFilSB2+aSalvCols[nSG1,nPosCod]+aSav650[4]
				If !lEmpPrj
					nQtdPrj := SB2->B2_QEMPPRJ
				EndIf
				If lConsNPT .and. lConsAlmTer
					If lPrimo
						nQtyStok := SaldoSB2(.T., , ,lConsTerc,lConsNPT,,,nQtdPrj)+SB2->B2_SALPEDI-SB2->B2_QEMPN+AvalQtdPre("SB2",2)
						lPrimo:=.F.
					Else
						nQtyStok += SaldoSB2(.T., , ,lConsTerc,.F.,,,nQtdPrj)+SB2->B2_SALPEDI-SB2->B2_QEMPN+AvalQtdPre("SB2",2)
					EndIf
				Else
					nQtyStok += SaldoSB2(.T., , ,lConsTerc,lConsNPT,,,nQtdPrj)+SB2->B2_SALPEDI-SB2->B2_QEMPN+AvalQtdPre("SB2",2)
				Endif

				dbSkip()
			End
			nQtyStok += A650Prev(aSalvCols[nSG1,nPosCod])
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Executa P.E. para tratar saldo disponivel.                    ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If lExistBlkT
				nQtdBack:=nQtyStok
				nQtyStok:=ExecTemplate("A650SALDO",.F.,.F.,nQtyStok)
				If ValType(nQtyStok) != "N"
					nQtyStok:=nQtdBack
				EndIf
			EndIf

			If lExistBlock
				nQtdBack:=nQtyStok
				nQtyStok:=ExecBlock("A650SALDO",.F.,.F.,nQtyStok)
				If ValType(nQtyStok) != "N"
					nQtyStok:=nQtdBack
				EndIf
			EndIf

			dbSelectArea("SB2")
			dbSetOrder(1)
			MsSeek(cFilSB2+aSalvCols[nSG1,nPosCod]+aSalvCols[nSG1,nPosLocal])
		Endif
	Endif

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Calcula necessidade para o produto     ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If !lProj711
		If laSAv651
			If aSav651[26] == 1
				// --- Verifica Estoque de Seguranca (B1_ESTSEG)
				nEstSeg := CalcEstSeg( RetFldProd(SB1->B1_COD,"B1_ESTFOR") )
				nQtyStok -= nEstSeg
			EndIf
		Else
			// --- Verifica Estoque de Seguranca (B1_ESTSEG)
			If lConsEst
				nEstSeg := CalcEstSeg( RetFldProd(SB1->B1_COD,"B1_ESTFOR") )
				nQtyStok -= nEstSeg
			EndIf
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Tratamento para considerar somente uma vez o Estoque de Seguranca ³
		//³quando parametrizado para Aglut. SCs "Por OP" ou "Por Data Nece"  ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If QtdComp(nEstSeg) > QtdComp(0) .And. aSav650[06] <> 1
			If aSav650[06] == 2
				aScAglu := aClone(aOpc1)
			ElseIf aSav650[06] == 3
				aScAglu := aClone(aDataOpC1)
			EndIf
			nQtdSC := 0
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³A verificacao de saldo de SCs anteriores		  			|
			//³foi retirada, pois isso ja eh feito na funcao A650Prev   ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		EndIf
	EndIf

	If nQuantItem < 0
		nNecessid := nQuantItem
	Else
		nNecessid := IIF(nQtyStok >= nQuantItem,0,nQuantItem - nQtyStok)
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica se envia e-mail ref. PONTO DE PEDIDO - 001³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lEvento001 .And. nQuantItem > 0 .And. !(SB2->B2_LOCAL == cLocCQ) .And. !Empty(RetFldProd(SB1->B1_COD,"B1_EMIN"))
		nSaldoSB2 := SALDOSB2(.T.,.T.,dDataBase)+SB2->B2_SALPEDI+SB2->B2_QACLASS
		nSaldoSB2 += A650Prev(SB2->B2_COD)
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Ponto de Entrada para validar saldo em TODOS os armazens³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If lMA650SAL
			nSaldoSB2 := ExecBlock('MA650SAL',.F.,.F.)
			nSaldoSB2 := IIf(Valtype(nSaldoSB2) <> "N", 0, nSaldoSB2)
		EndIf
		If (nSaldoSB2 - nQuantItem) <= RetFldProd(SB1->B1_COD,"B1_EMIN")
			dbSelectarea("SXI")
			dbsetorder(2)
			cEventID  := "001" //Ponto de pedido
			If msSeek('002' + '001' + cEventID)
				cMensagem:=STR0176+SB1->B1_COD+" - "+SB1->B1_DESC+STR0177	//"O produto "###" atingiu a quantidade de "
				cMensagem+= Str(nSALDOSB2 + (nSaldoSB2 - nQuantItem))+STR0028+SB2->B2_LOCAL+STR0178+ Str(RetFldProd(SB1->B1_COD,"B1_EMIN"))	//" (armazém "###"), abaixo do Ponto de Pedido de "
				EventInsert(FW_EV_CHANEL_ENVIRONMENT, FW_EV_CATEGORY_MODULES, cEventID,FW_EV_LEVEL_INFO,""/*cCargo*/,STR0179,cMensagem,.T./*lPublic*/)
			//Else - DMANSMARTSQUAD1-28567
			//	MEnviaMail("001",{SB1->B1_COD,SB1->B1_DESC,SB2->B2_LOCAL,(nSaldoSB2 - nQuantItem),RetFldProd(SB1->B1_COD,"B1_EMIN")})
			EndIf
		EndIf
	EndIf

	If SG1->(MsSeek(cFilSG1+aSalvCols[nSG1,nPosCod]))
		lExistComp := .F.
		While SG1->(!Eof()) .And. SG1->G1_FILIAL == cFilSG1 .And. aSalvCols[nSG1,nPosCod] == SG1->G1_COD
			lValidOk := .F.
			lRevOk   := .F.
			If dEntrega <= SG1->G1_FIM .And. dEntrega >=SG1->G1_INI
				lValidOk := .T.
			EndIf

			cRevisaoOk :=IIF(lPCPREVATU , PCPREVATU(SB1->B1_COD), SB1->B1_REVATU )/*SB1->B1_REVATU*/
			If PCPVldRev(SB1->B1_COD, cRevisaoOk)
				If SG1->G1_REVINI <= cRevisaoOk .And. SG1->G1_REVFIM >= cRevisaoOk
					lRevOk := .T.
				Else
					If lEMPREVVAZ .And. Empty(cRevisaoOk) //PE para empenhar o componente quando a revisão está em branco.
						lRevOk := .T.
					Else
						lRevOk := .F.
					EndIf
				EndIf
			Else
				If lEMPREVVAZ .And. Empty(cRevisaoOk) //PE para empenhar o componente quando a revisão está em branco.
					lRevOk := .T.
				Else
					lRevOk := .F.
				EndIf
			EndIf	

			If lValidOk .And. lRevOk
				lExistComp := .T.
				Exit
			//Else
				//SG1->(dbskip())
			EndIf

			SG1->(dbskip())
		End

		If lExistComp
			cTipo := "F"
		Else
	  		cTipo := "C"
		EndIf
	ElseIf !lProj711 .And. IsNegEstr(aSalvCols[nSG1,nPosCod],,,cProduto)[1] //Sub-produto
		cTipo := "S"
	Else
		cTipo := "C"
	Endif
	If cTipo $ "FS" .And. !lGERAPI .And. RetFldProd(SB1->B1_COD,"B1_MRP") == "N" // Projeto Implementeacao de campos MRP e FANTASM no SBZ
		cTipo := "I"
	Endif
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Executa execblock para verificar se     ³
	//³ produto sera fabricado ou comprado      ³
	//³ "COMPONENTE FABRICADO OU COMPRADO"      ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lA650CCF
		cOldTipo:=cTipo
		cTipo:=ExecBlock("A650CCF",.F.,.F.,{aSalvCols[nSG1,nPosCod],cTipo,SC2->C2_DATPRI,nSG1})
		If !(ValType(cTipo) == "C") .Or. !(cTipo $ "FCI")
			cTipo:=cOldtipo
		EndIf
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica se o produto eh intermediario  ³
	//³ e se deve ou nao considerar o armazem de³
	//³ processo na geracao de SCs              ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If SB1->B1_APROPRI == "I"
		If lGRCLOCP
			cLocalSC1:= cLocProc
		Else
			cLocalSC1:= RetFldProd(SB1->B1_COD,"B1_LOCPAD")
		EndIf
	Else
		cLocalSC1:= aSalvCols[nSG1,nPosLocal]
	EndIf

	nRecSB1:=SB1->(Recno())
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Permite alterar o local atraves de P.E. ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If l650LocEmp
		cLocAnt:=ExecBlock("A650LEMP",.F.,.F.,aSalvCols[nSG1])
		If ValType(cLocAnt) == "C" .And. Len(cLocAnt) == Len(aSalvCols[nSG1,nPosLocal])
			aSalvCols[nSG1,nPosLocal]:=cLocAnt
			If SB1->B1_APROPRI == "I"
				If lGRCLOCP
					cLocalSC1:= cLocProc
				Else
					cLocalSC1:= RetFldProd(SB1->B1_COD,"B1_LOCPAD")
				EndIf
			Else
				cLocalSC1:= aSalvCols[nSG1,nPosLocal]
			EndIf
		EndIf
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica se Lote do Empenho ja foi preenchido ou   ³
	//³ se a Localizacao do Empenho ja foi preenchida      ³
	//³ Caso ja tenha sido, o estoque ja foi verificado.   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	lRastroLoc:=.T.
	If Rastro(aSalvCols[nSG1,nPosCod],"S")
		lRastroLoc:=Empty(aSalvCols[nSG1,nPosLote]).And.Empty(aSalvCols[nSG1,nPosLotCtl])
	ElseIf Rastro(aSalvCols[nSG1,nPosCod],"L")
		lRastroLoc:=Empty(aSalvCols[nSG1,nPosLotCtl])
	EndIf
	If lRastroLoc .And. Localiza(aSalvCols[nSG1,nPosCod],.T.)
		lRastroLoc:=Empty(aSalvCols[nSG1,nPosLocLz]).And.Empty(aSalvCols[nSG1,nPosNSerie])
	EndIf

	If lProj711
		nPeriodo := Val(A650DtoPer(dEntrega))
		If cTipo == "C" .And. lGeraSC
			lOkPeri := Substr(cSelPerSC,nPeriodo,1) == "û"
		Endif
		If cTipo == "F" .And. lGeraOPI
			lOkPeri :=  Substr(cSelPer,nPeriodo,1)   == "û"
		Endif
	Endif

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Gera Solicitacoes de Compras ou OPs intermediarias ³
	//³ caso haja necessidade.                             ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If nNecessid > 0 .And. lOkPeri //.And. lRastroLoc (removido para gerar SC quando possui EstSeg e empenha o Lote)
		If cTipo == "F"
			nAchoOpc:=ASCAN(aRetorOpc,{|x| x[1] == cStrOpc+aSalvCols[nSG1,nPosCod]+aSalvCols[nSG1,nPosTRTORI] })
			If nAchoOpc > 0 .And. cOpcionais == ""
				cOpcionais:=aRetorOpc[nAchoOpc,2]
			EndIf
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Verifica ponto de entrada para gerar ou nao OPs    ³
			//³ intermediarias                                     ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If lBlockOPI
				lRetBlock:=ExecBlock("A650OPI",.F.,.F.,nSG1)
				If ValType(lRetBlock) # "L"
					lRetBlock:=.T.
				EndIf
			EndIf

			lRet:= .T.
			If lMTA650GEM .AND. ( l650Auto)
				lRet := .F.
			Else
				If lMTA650GEM .AND. (!l650Auto)
					lRet := ExecBlock("MTA650GEM",.F.,.F.,{'2',SC2->C2_FILIAL,SC2->C2_NUM,SC2->C2_ITEM,SC2->C2_SEQUEN,SC2->C2_ITEMGRD, nil})
					If Valtype(lRet) <> "L"
   						lRet:= .T.
   					EndIf
   				EndIf
   			EndIf

			If lRet .And. lGeraOPI .And. lRetBlock .And. RetFldProd(SB1->B1_COD,"B1_FANTASM") != "S" // Projeto Implementeacao de campos MRP e FANTASM no SBZ
				aOps:={}
				aQtdes := CalcLote(aSalvCols[nSG1,nPosCod],nNecessid,"F")
				If lEstMax
					aQtdes := A711LotMax(aSalvCols[nSG1,nPosCod], nNecessid, aQtdes)
				Endif
				If laSAv651
			    	If Asav651[19] == 2
					   aQtdes := {nNecessid}
					EndIF
				EndIf
				nRegSC2 := SC2->(RecNo())
				SB1->(MsGoto(nRecSB1))
				For nX := 1 To Len(aQtdes)
					If !((RetFldProd(SB1->B1_COD,"B1_FANTASM") == "S") .Or. (cTipo == "F" .And. !lGERAPI))  // Projeto Implementeacao de campos MRP e FANTASM no SBZ
						IF (cCpoProj != NIL .and. RetFldProd(SB1->B1_COD,"B1_MRP") $ " S") .or. cCpoProj = NIL // Projeto Implementeacao de campos MRP e FANTASM no SBZ
							//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
							//³ Caso gere Ordem de Producao pela projecao³
							//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
							If lProj .And. nPar10 == 2
								cPeriodoOpc:=A650DtoPer(dEntrega)
								dbSelectArea("TRBOPC")
								dbSetOrder(2)
								If dbSeek(cPeriodoOpc+cProduto+aSalvCols[nSG1,nPosCod]+cOpcionais)
									RecLock("TRBOPC",.F.)
									Replace QUANTIDADE With QUANTIDADE - aQtdes[nx]
									MsUnlock()
								EndIf
							EndIf
							cSeqC2:=Soma1(cSeqC2,Len(SC2->C2_SEQUEN))
							//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
							//³ Ponto de entrada para Alterar a sequencia ³
							//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						 	If lMA650SEQ
						  		cSeqC2Aux := ExecBlock("MA650SEQ",.F.,.F.)
								If Valtype(cSeqC2Aux) == "C"
							  		cSeqC2 := cSeqC2Aux
								EndIf
							EndIf
							cItemGrd := SC2->C2_ITEMGRD
							cGrade := SC2->C2_GRADE
							If !lOne
								cRevAtu := IIF(lPCPREVATU , PCPREVATU(SB1->B1_COD), SB1->B1_REVATU )/*SB1->B1_REVATU*/
								//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
								//³ Ponto de Entrada para alterar a Revisao da estrutura  ³
								//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
								If lA650REVEM
									aRetPE := ExecBlock("A650REVEM",.F.,.F.,{cRevAtu})
									If ValType(aRetPE) == "A" .And. !Empty(aRetPE[1])
										cRevAtu := aRetPE[1]
									EndIf
								elseif  lEMPREVVAZ
									cRevAtu := cRevisao
								EndIf
								A650GeraC2(aSalvCols[nSG1,nPosCod],aQtdes[nX],,dEntrega,SC2->C2_DATAJI,cCpoProj,cSeqPai,cPrior,.F.,,If(lOPIPROC,aSalvCols[nSG1,nPosLocal],RetFldProd(SB1->B1_COD,"B1_LOCPAD")),cOpcionais,cTpOp,cRevAtu,NIL,cNumOp,cItemOp,@cSeqC2,cRoteiro,cObs,SC2->C2_OPC,@aMRPxJson)
								AADD(aOps,SC2->C2_NUM+SC2->C2_ITEM+SC2->C2_SEQUEN+SC2->C2_ITEMGRD)
								AADD(aOPInt, {SC2->C2_PRODUTO, SC2->C2_NUM+SC2->C2_ITEM+SC2->C2_SEQUEN+SC2->C2_ITEMGRD, (SC2->C2_QUANT - nQuantItem) } )
								dbSelectArea("SG1")
								nR := RecNo()

								MontEstru(aSalvCols[nSG1,nPosCod],aQtdes[nX],SC2->C2_DATPRI,cCpoProj,cSeqC2,SC2->C2_PRIOR,lConsEst,Iif(Len(aRetorOpc)>0,Array2Str(aRetorOpc,.F.),cOpcionais),lOne,cTpOp,cRevAtu,cStrOpc+aSalvCols[nSG1,nPosCod]+aSalvCols[nSG1,nPosTRTORI],@aOPInt,If(Len(aOpcCam)<=nSG1, aSalvCols[nSG1,nPosCod]+aSalvCols[nSG1,nPosTRTORI]/*aSalvCols[nSG1,nPosTRT]*/,aOpcCam[nSG1]),@aMRPxJson,aArrOpc)
							EndIf
						EndIf
					EndIf
				Next nX
				SC2->(dbGoTo(nRegSC2))
			EndIf
		ElseIf cTipo == "C" .And. (SB1->B1_TIPO # "BN" .Or. lBuyBN)
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Verifica se deve quebrar pelo Lote Economico ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

			//If lEstMax
			//	//nNecessid := Min(nNecessid, A711Lote(nQuantItem,aSalvCols[nSG1,nPosCod]) + AReadSha(aSalvCols[nSG1,nPosCod], dEntrega, "1") - nQuantItem)
			//	If lMata712
			//	  nNecessid := Min(nNecessid, A711Lote(nQuantItem,aSalvCols[nSG1,nPosCod]) + A712RetVld(aSalvCols[nSG1,nPosCod], dEntrega, "1") - nQuantItem)
			//	Else
			//	  If lPCPA107
			//	     nNecessid := Min(nNecessid, A711Lote(nQuantItem,aSalvCols[nSG1,nPosCod]) + A107RetVld(aSalvCols[nSG1,nPosCod], dEntrega, "1") - nQuantItem)
			//	  Else
			//	     nNecessid := Min(nNecessid, A711Lote(nQuantItem,aSalvCols[nSG1,nPosCod]) + AReadSha(aSalvCols[nSG1,nPosCod], dEntrega, "1") - nQuantItem)
			//	  EndIf
			//	EndIf
			//Endif

			// Aglutina SC por OP
			If aSav650[06] == 2
				aQtdes := { nNecessid }
			Else
				aQtdes := CalcLote(aSalvCols[nSG1,nPosCod],nNecessid,"C")
			EndIf

			If laSAv651
				If aSav651[19] == 2
					aQtdes := { nNecessid }
				EndIf
			EndIf

			If lEstMax
				aQtdes := A711LotMax(aSalvCols[nSG1,nPosCod], nNecessid, aQtdes)
			Endif
			If !IsProdMod(aSalvCols[nSG1,nPosCod])
				If lGeraSc
					IF (cCpoProj != NIL .and. RetFldProd(SB1->B1_COD,"B1_MRP") $" S") .Or. cCpoProj = NIL // Projeto Implementeacao de campos MRP e FANTASM no SBZ
						//aDocs := {}
						//aFornecedor:= COMPESQFOR(aSalvCols[nSG1,nPosCod]) //-- Retorna codigo e loja do fornecedor
						//nPrc:= COMPESQPRECO(aSalvCols[nSG1,nPosCod],cFilAnt,aFornecedor[1],aFornecedor[2])
						//Aadd(aDatasNec,dEntrega)
						For nX := 1 To Len(aQtdes)
							//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
							//³ Baixa quantidade do arquivo de opcionais       ³
							//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
							If lProj .And. nPar10 == 2
								dbSelectArea("TRBOPC")
								dbSetOrder(2)
								If dbSeek(A650DtoPer(dEntrega)+cProduto+aSalvCols[nSG1,nPosCod]+cOpcionais)
									RecLock("TRBOPC",.F.)
									Replace QUANTIDADE With QUANTIDADE - aQtdes[nx]
									MsUnlock()
								EndIf
							EndIf
							//Aadd(aDocs,{aSalvCols[nSG1,nPosCod],aQtdes[nX],cFilAnt,cFilAnt,"1",aFornecedor[1],aFornecedor[2],,nPrc,{},SC2->C2_NUM,SC2->C2_ITEM})
							A650GeraC1(aSalvCols[nSG1,nPosCod],aQtdes[nX],cOp,dEntrega,cCpoProj,nx,nNecessid,cLocalSC1,cTpOp,,,,nQuantItem)
						Next nX
						//If !Empty(aDocs)
						//	aResultados:= ComGeraDoc(aDocs,.T.,.F.,.F.,.T.,ComDtNeces(aDatasNec),"MATA650" ,/*lEnviaEmail*/,1  )
						//EndIf
					Endif
				Endif
			EndIf
			dbSelectArea("SG1")
		ElseIf cTipo == "S"
			aNegEst := IsNegEstr(aSalvCols[nSG1,nPosCod],SC2->C2_DATPRI,nNecessid,cProduto)
			SB1->(MsSeek(cFilSB1+aNegEst[2]))
			For nX := 1 To aNegEst[5]
				aQtdes := CalcLote(aNegEst[2],aNegEst[4],"F")
				If lEstMax
					aQtdes := A711LotMax(aNegEst[2],nNecessid,aQtdes)
				Endif
				cRevAtu := IIF(lPCPREVATU , PCPREVATU(SB1->B1_COD), SB1->B1_REVATU )/*SB1->B1_REVATU*/
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Ponto de Entrada para alterar a Revisao da estrutura  ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If lA650REVEM
					aRetPE := ExecBlock("A650REVEM",.F.,.F.,{cRevAtu})
					If ValType(aRetPE) == "A" .And. !Empty(aRetPE[1])
						cRevAtu := aRetPE[1]
					EndIf
				EndIf
				For nY := 1 To Len(aQtdes)
					cSeqC2:=Soma1(cSeqC2,Len(SC2->C2_SEQUEN))
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Ponto de entrada para Alterar a sequencia ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				  	If lMA650SEQ
						cSeqC2Aux := ExecBlock("MA650SEQ",.F.,.F.,{cSeqC2})
					 	If Valtype(cSeqC2Aux) == "C"
					  		cSeqC2 := cSeqC2Aux
						EndIf
					EndIf
					cOpcSB1 := Iif(Empty(RetFldProd(SB1->B1_COD,"B1_MOPC")),RetFldProd(SB1->B1_COD,"B1_OPC"),RetFldProd(SB1->B1_COD,"B1_MOPC"))
					A650GeraC2(aNegEst[2],aQtdes[nY],,SC2->C2_DATPRI,SC2->C2_DATAJI,cCpoProj,cSeqPai,cPrior,.F.,,If(lOPIPROC,aSalvCols[nSG1,nPosLocal],RetFldProd(SB1->B1_COD,"B1_LOCPAD")),cOpcSB1,cTpOp,cRevAtu,NIL,cNumOP,cItemOP,@cSeqC2,cRoteiro,cObs,SC2->C2_OPC,@aMRPxJson)
					AADD(aOPInt, {SC2->C2_PRODUTO, SC2->C2_NUM+SC2->C2_ITEM+SC2->C2_SEQUEN+SC2->C2_ITEMGRD, (SC2->C2_QUANT - nQuantItem) } )
					dbSelectArea("SG1")
					nR := RecNo()
			        MontEstru(aNegEst[2],aQtdes[nY],SC2->C2_DATPRI,cCpoProj,cSeqC2,SC2->C2_PRIOR,lConsEst,cOpcSB1,lOne,cTpOp,cRevAtu,cStrOpc,@aOPInt,aNegEst[2],,aArrOpc)
					SG1->(dbGoTo(nR))
				Next nY
			Next nX
		Endif
	EndIf
	If nQuantItem > 0 .Or. nQuantItem < 0
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Amarra empenhos com OPs geradas            ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If nQuantItem > 0 .And. cTipo # "C" .And. nNecessid > 0 .And. lGeraOPI .And. RetFldProd(SB1->B1_COD,"B1_FANTASM") != "S" .And. (SB1->B1_TIPO != "BN" .Or. lEmpBN) // Projeto Implementeacao de campos MRP e FANTASM no SBZ
			For nx:=1 To Len(aQtdes)
				nBaixa:=Min(nQuantItem,aQtdes[nx])
				nQtNeces := A650CalNec(aSalvCols[nSG1,nPosCod],aSalvCols[nSG1,nPostrt], cOp)//Produto + TRT

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Atualiza arquivo de empenhos               ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				GravaEmp(	aSalvCols[nSG1,nPosCod],;
							aSalvCols[nSG1,nPosLocal],;
							nBaixa,;
							aSalvCols[nSG1,nPosQtSegum],;
							aSalvCols[nSG1,nPosLotCtl],;
							aSalvCols[nSG1,nPosLote],;
							aSalvCols[nSG1,nPosLocLz],;
							aSalvCols[nSG1,nPosnSerie],;
							cOp,;
							aSalvCols[nSG1,nPosTrt],;
							NIL,;
							NIL,;
							"SC2",;
							If(Len(aOps)>0,aOps[nx],NIL),;
							dEntrega,;
							@aTravas,;
							.F.,;
							lProj,;
							.T.,;
							.T.,;
							NIL,;
							NIL,;
							!lRastroLoc,;
							,;
							,;
							aClone(aSalvCols),;
							nSG1,;
							,;
							cTpOp,;
							NIL,;
							NIL,;
							NIL,;
							NIL,;
							NIL,;
							nQtNeces)
				//Soma quantidade de empenhos para envio de métrica - Quantidade média de componentes por ordem de produção manual
				nMetricEmp++

				//Se for um alternativo e o parâmetro MV_PCPOS estiver .T., grava a ordem de substituição
				If mvlPCPOS .And. aSalvCols[nSG1,nPosIsAlt] == STR0201 //"Sim"
					cProdOriAux	:= aCols[nSG1,Len(aHeader)+1][1]
					cTrtOriAux	:= aCols[nSG1,Len(aHeader)+1][2]
					nQtdOriAux	:= aCols[nSG1,Len(aHeader)+1][3]
					cLocAnAux	:= aCols[nSG1,Len(aHeader)+1][4]

					If Empty(aSVF)
						aSVF := {xFilial("SVF"),;					//01-01: VF_FILIAL	- Filial do empenho anterior;
								cOP,;								//01-02: VF_OP		- OP do empenho anterior;
								cProdOriAux,;						//01-03: VF_COMP	- Componente do empenho anterior;
								cLocAnAux,;							//01-04: VF_LOCAL	- Local do empenho anterior;
								cTrtOriAux,;						//01-05: VF_TRT		- TRT do empenho anterior;
								"",;								//01-06: VF_SEQ		- Sequencia do empenho anterior;
								"",;								//01-07: VF_OPORIG	- OP Origem do empenho anterior;
								"",;								//01-08: VF_LOTE	- Lote do empenho anterior;
								"",;								//01-09: VF_SUBLOTE	- SubLote do empenho anterior;
								"",;								//01-10: VF_ORDEM	- Ordem do empenho anterior;
								nQtdOriAux}							//01-11: VF_QTDEORI	- Quantidade do empenho anterior;

						aAdd(aT4I, {xFilial("T4I"),;				//02-nX-01: Filial da T4I
									nQtdOriAux,;					//02-nX-02: nQuantidade		- Quantidade anterior;
									"",;							//02-nX-03: nLocalizacao	- Localizacao anterior;
									""})							//02-nX-04: cNumSerie		- Numero de serie anterior;
					EndIf

					aAdd(aSVJ, {xFilial("SVJ"),;				//03-nX-01: VJ_FILIAL	- Filial do empenho novo;
								aSalvCols[nSG1,nPosCod],;		//03-nX-02: VJ_ALTERN	- Componente do empenho novo - ALTERNATIVO;
								aSalvCols[nSG1,nPosLocal],;		//03-nX-03: VJ_LOCAL	- Local do empenho novo;
								aSalvCols[nSG1,nPosTrt],;		//03-nX-04: VJ_TRT		- TRT do empenho novo;
								"",;							//03-nX-05: VJ_SEQ		- Sequencia do empenho novo;
								"",;							//03-nX-06: VJ_OPORIG	- OP Origem do empenho novo;
								aSalvCols[nSG1,nPosLotCtl],;	//03-nX-07: VJ_LOTE		- Lote do empenho novo;
								aSalvCols[nSG1,nPosLote],;		//03-nX-08: VJ_SUBLOTE	- SubLote do empenho novo;
								"",;							//03-nX-09: VJ_ORDEM	- Ordem do empenho novo;
								nQuantItem,;					//03-nX-10: VJ_QUANT	- Quantidade do empenho novo
								aSalvCols[nSG1,nPosLocLz],;		//03-nX-11: VJ_LOCALIZ 	- Localizacao do empenho novo;
								aSalvCols[nSG1,nPosnSerie]})	//03-nX-12: VJ_NUMSERI 	- Numero de serie do empenho novo
				EndIf

				// Deve gravar o empenho no novo WMS quado for o caso - lWmsNew
				If lWmsNew .And. !lRastroLoc .And. !Empty(aSalvCols[nSG1,nPosLocLz]) .And. IntWms(aSalvCols[nSG1,nPosCod])
					WmsEmpReq("SC2",;
								 aSalvCols[nSG1,nPosCod],;
								 aSalvCols[nSG1,nPosLocal],;
								 nBaixa,;
								 aSalvCols[nSG1,nPosLocLz],;
								 aSalvCols[nSG1,nPosLotCtl],;
								 aSalvCols[nSG1,nPosLote],;
								 aSalvCols[nSG1,nPosnSerie],;
								 cOp,;
								 aSalvCols[nSG1,nPosTrt],;
								 /*cIdDCF*/,;
								 /*cIdUnitiz*/,;
								 .F.,; // lEstorno
								 .T.,; // lCriaSDC
								 .T.)  // lEmpD14
				EndIf

				//Michele
				If !lProj711 .And. !lMata712
 					For nInd := 1 to len(aAltSaldo)
						If aAltSaldo[nInd,1] == aSalvCols[nSG1,nPosCod]
							aAltSaldo[nInd,2] -= nBaixa
 							Exit
						EndIf
					Next nInd
				EndIf

				nIndice := ASCAN(aLotesUsado,{|x| x[1] == aSalvCols[nSG1,nPosCod] .And. x[2] == aSalvCols[nSG1,nPosLotCtl] .And. x[3] == aSalvCols[nSG1,nPosLocLz]})

	    		If nIndice > 0
	    			aLotesUsado[nIndice,4] -= nBaixa
	    		EndIf

				nQuantItem-=Min(nQuantItem, nBaixa)

			Next nx
		EndIf
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Gera Empenho de qtd que ja existente ou    ³
		//³ quantidade que nao precisa ser produzida.  ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If nQuantItem # 0 .And. (SB1->B1_TIPO != "BN" .Or. lEmpBN)
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Somente se B1_LM estiver configurado:          ³
			//³ Localiza no vetor aOPInt a OP gerada para o PI ³
			//³ e tenta utiliza-la no empenho (D4_OPORIG).     ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			cD4_OPORIG := ''
			If !Empty(SB1->B1_LM)
				nX := aScan(aOPInt,{|x| x[1] == aSalvCols[nSG1,nPosCod] .And. QtdComp(x[3]) > QtdComp(0) }) // Posiciona no primeiro elemento do vetor igual ao produto com qtd > 0
				If nX > 0
					cD4_OPORIG   := aOPInt[nX,2] // obtem a OP intermediaria
					aOPInt[nX,3] -= nQuantItem 	 // subtrai a quantidade empenhada do produto
				EndIf
			EndIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Atualiza arquivo de empenhos               ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			nQtNeces := A650CalNec(aSalvCols[nSG1,nPosCod],aSalvCols[nSG1,nPostrt], cOp)//Produto + TRT
			GravaEmp(	aSalvCols[nSG1,nPosCod],;
						aSalvCols[nSG1,nPosLocal],;
						nQuantItem,;
						aSalvCols[nSG1,nPosQtSegum],;
						aSalvCols[nSG1,nPosLotCtl],;
						aSalvCols[nSG1,nPosLote],;
						aSalvCols[nSG1,nPosLocLz],;
						aSalvCols[nSG1,nPosnSerie],;
						cOp,;
						aSalvCols[nSG1,nPosTrt],;
						NIL,;
						NIL,;
						"SC2",;
						IIF(!Empty(cD4_OPORIG), cD4_OPORIG, NIL),;
						dEntrega,;
						@aTravas,;
						.F.,;
						lProj,;
						.T.,;
						.T.,;
						NIL,;
						NIL,;
						!lRastroLoc,;
						,;
						,;
						aClone(aSalvCols),;
						nSG1,;
						,;
						cTpOp,;
						NIL,;
						NIL,;
						NIL,;
						NIL,;
						NIL,;
						nQtNeces)

			//Soma quantidade de empenhos para envio de métrica - Quantidade média de componentes por ordem de produção manual
			nMetricEmp++

			//Se for um alternativo e o parâmetro MV_PCPOS estiver .T., grava a ordem de substituição
			If mvlPCPOS .And. aSalvCols[nSG1,nPosIsAlt] == STR0201 //"Sim"
				cProdOriAux	:= aCols[nSG1,Len(aHeader)+1][1]
				cTrtOriAux	:= aCols[nSG1,Len(aHeader)+1][2]
				nQtdOriAux	:= aCols[nSG1,Len(aHeader)+1][3]
				cLocAnAux	:= aCols[nSG1,Len(aHeader)+1][4]

				If Empty(aSVF)
					aSVF := {xFilial("SVF"),;					//01-01: VF_FILIAL	- Filial do empenho anterior;
							cOP,;								//01-02: VF_OP		- OP do empenho anterior;
							cProdOriAux,;						//01-03: VF_COMP	- Componente do empenho anterior;
							cLocAnAux,;							//01-04: VF_LOCAL	- Local do empenho anterior;
							cTrtOriAux,;						//01-05: VF_TRT		- TRT do empenho anterior;
							"",;								//01-06: VF_SEQ		- Sequencia do empenho anterior;
							"",;								//01-07: VF_OPORIG	- OP Origem do empenho anterior;
							"",;								//01-08: VF_LOTE	- Lote do empenho anterior;
							"",;								//01-09: VF_SUBLOTE	- SubLote do empenho anterior;
							"",;								//01-10: VF_ORDEM	- Ordem do empenho anterior;
							nQuantItem,}						//01-11: VF_QTDEORI	- Quantidade do empenho anterior;

					aAdd(aT4I, {xFilial("T4I"),;				//02-nX-01: Filial da T4I
								nQuantItem,;					//02-nX-02: nQuantidade		- Quantidade anterior;
								"",;							//02-nX-03: nLocalizacao	- Localizacao anterior;
								""})							//02-nX-04: cNumSerie		- Numero de serie anterior;
				EndIf

				aAdd(aSVJ, {xFilial("SVJ"),;				//03-nX-01: VJ_FILIAL	- Filial do empenho novo;
							aSalvCols[nSG1,nPosCod],;		//03-nX-02: VJ_ALTERN	- Componente do empenho novo - ALTERNATIVO;
							aSalvCols[nSG1,nPosLocal],;		//03-nX-03: VJ_LOCAL	- Local do empenho novo;
							aSalvCols[nSG1,nPosTrt],;		//03-nX-04: VJ_TRT		- TRT do empenho novo;
							"",;							//03-nX-05: VJ_SEQ		- Sequencia do empenho novo;
							"",;							//03-nX-06: VJ_OPORIG	- OP Origem do empenho novo;
							aSalvCols[nSG1,nPosLotCtl],;	//03-nX-07: VJ_LOTE		- Lote do empenho novo;
							aSalvCols[nSG1,nPosLote],;		//03-nX-08: VJ_SUBLOTE	- SubLote do empenho novo;
							"",;							//03-nX-09: VJ_ORDEM	- Ordem do empenho novo;
							nQuantItem,;					//03-nX-10: VJ_QUANT	- Quantidade do empenho novo
							aSalvCols[nSG1,nPosLocLz],;		//03-nX-11: VJ_LOCALIZ 	- Localizacao do empenho novo;
							aSalvCols[nSG1,nPosnSerie]})	//03-nX-12: VJ_NUMSERI 	- Numero de serie do empenho novo
			EndIf

			// Deve gravar o empenho no novo WMS quado for o caso - lWmsNew
			If lWmsNew .And. !lRastroLoc .And. !Empty(aSalvCols[nSG1,nPosLocLz]) .And. IntWms(aSalvCols[nSG1,nPosCod])
				WmsEmpReq("SC2",;
							 aSalvCols[nSG1,nPosCod],;
							 aSalvCols[nSG1,nPosLocal],;
							 nQuantItem,;
							 aSalvCols[nSG1,nPosLocLz],;
							 aSalvCols[nSG1,nPosLotCtl],;
							 aSalvCols[nSG1,nPosLote],;
							 aSalvCols[nSG1,nPosnSerie],;
							 cOp,;
							 aSalvCols[nSG1,nPosTrt],;
							 /*cIdDCF*/,;
							 /*cIdUnitiz*/,;
							 .F.,; // lEstorno
							 .T.,; // lCriaSDC
							 .T.)  // lEmpD14
			EndIf

			//Michele
			If !lProj711 .And. !lMata712
				For nInd := 1 to len(aAltSaldo)
					If aAltSaldo[nInd,1] == aSalvCols[nSG1,nPosCod]
						aAltSaldo[nInd,2] -= nQuantItem
 						Exit
					EndIf
				Next nInd
			EndIf

			nIndice := ASCAN(aLotesUsado,{|x| x[1] == aSalvCols[nSG1,nPosCod] .And. x[2] == aSalvCols[nSG1,nPosLotCtl] .And. x[3] == aSalvCols[nSG1,nPosLocLz]})

	    	If nIndice > 0
	    		aLotesUsado[nIndice,4] -= nQuantItem
	    	EndIf
		EndIf
	EndIf

	//Gera a ordem de substituição
	If mvlPCPOS .And. !Empty(aSVF)
		geraOrdSub(aSVF, aT4I, aSVJ)
	EndIf
Next

//Integração de ordens de produção com o novo MRP. Inclusão/Alteração de ordens
If lIntNewMRP .and. lIntLocal
	enviaOpMrp("INSERT", @aMRPxJson, lDelTBMRP)
EndIf

If lIntSFC
	A650IntSFC(4,3) //Evento 3 - Geracao dos Empenhos
EndIf
SB1->(dbGoTo(nSalB1))
If aSalvRot != NIL
	aRotina:=aClone(aSalvRot)
EndIf

//Integração com o PCFactory. Manda a OP novamente após a geração dos empenhos.
//Se for MES LITE, não envia empenhos, então não precisa reenviar a OP neste ponto.
If !lMata712 .And. RodaAPS() == .F. .And. PCPIntgPPI("SC2", @lLite) .And. lLite == .F.
	mata650PPI(,,.T.,.T.,.F.)
EndIf

If lMA650EMP
	ExecBlock('MA650EMP',.F.,.F.)
EndIf

If lProj711 .And. !lMata712 .And. !lPCPA107
	RestArea(aAreaSH5)
ElseIf lMata712
	RestArea(aAreaCZI)
	ElseIf lPCPA107
		RestArea(aAreaSOQ)
EndIf

If _lErrSFC
	FClose(_nHndSFC)
	Alert(STR0187 + "("+cNameFile+") " + STR0188) // "Algumas das ordens geradas no SIGASFC(Chão de Fábrica) não possuem operação reportada e portanto foi trocado o parametro das ordens para reporte por produção. Um log("+cNameFile+") foi criado na pasta local do servidor Protheus contendo todas ordens afetadas."
EndIf

Return

/*/{Protheus.doc} fOrdenaAcols
	Ordena o Acols e o Acols de Opc de acordo com o tipo de produto,
	-> não podemos gerar os produtos com filhos antes das matérias primas.
	@type  Static Function
	@author mauricio.joao
	@since 12/05/2021
	@version 1.0
	@param aAcols, array, Array a ser ordenado
	@param aOpcs, array, Array de Opc a ser ordenado
	@return nil
	/*/
Static Function fOrdenaAcols(aAcols,aOpcs)
Local aMp		:= {} //array com materia prima
Local aMpOpc	:= {} //array com os opc de materia prima
Local aPa 		:= {} //array com os produtos acabados
Local aPaOpc 	:= {} //array com os opc dos produtos acabados
Local aPiLot 	:= {} //array com os produtos intermediários com lote
Local nAcols	:= 0
Local nTamAtual := 0 //tamanho acols.

For nAcols := 1 to Len(aAcols)
	//verifica se o produto é pai na sg1.
	If fBuscaFilho(aAcols[nAcols,nPosCod])
		//valida se tem lote preenchido.
		If Empty(aAcols[nAcols,nPosLotCtl])
			//produtos de produção
			Aadd(aPa,aAcols[nAcols])
		Else
			//produtos de produção com lote.
			Aadd(aPiLot,aAcols[nAcols])
		EndIf

		If nAcols <= LEN(aOpcs)
			//opc de produção
			Aadd(aPaOpc,aOpcs[nAcols])
		EndIf
	Else
		//produtos materia prima
		Aadd(aMp,aAcols[nAcols])
		IF nAcols <= LEN(aOpcs)
			//opc de produção
			Aadd(aMpOpc,aOpcs[nAcols])
		ENDIF
	EndIf
Next nAcols

//agrupa os arrays dos produtos PI com lote.
nTamAtual = len(aMp)
asize(aMp, nTamAtual + len(aPiLot))
acopy(aPiLot, aMp, 1, len(aPiLot), nTamAtual + 1)

//agrupa os arrays das materias primas.
nTamAtual = len(aMp)
asize(aMp, nTamAtual + len(aPa))
acopy(aPa, aMp, 1, len(aPa), nTamAtual + 1)

aAcols := aMp

//agrupa os arrays do opc
nTamAtual = len(aMpOpc)
asize(aMpOpc, nTamAtual + len(aPaOpc))
acopy(aPaOpc, aMpOpc, 1, len(aPaOpc), nTamAtual + 1)
aOpcs := aMpOpc

Return nil


/*/{Protheus.doc} fBuscaFilho
	identifica se existe filho dentro da estrutura para o produto informado
	@type  Static Function
	@author mauricio.joao
	@since 12/05/2021
	@version 1.0
	@param cProduto, char, codigo produto
	@return lExiste, logico, retorna se existe filho para o produto
	/*/
Static Function fBuscaFilho(cProduto)
	Local lExiste 	:= .F.
	Local cAliasSG1	:= GetNextAlias()
	BeginSql alias cAliasSG1
		SELECT
			SG1.G1_COD
		FROM
			%Table:SG1% SG1
		WHERE
			SG1.G1_FILIAL = %xFilial:SG1% AND
			SG1.G1_COD 	= %Exp:cProduto% AND
			SG1.%NotDel%
	EndSQL

	If (cAliasSG1)->(!Eof())
		lExiste := .T.
	EndIf

	(cAliasSG1)->(dbCloseArea())

Return lExiste

/*/{Protheus.doc} fCalcStokInd
Calcula o estoque de produto com apropriação Indireta.
@type  Static Function
@author mauricio.joao
@since 11/01/2021
@version 1.0

@param cFilSB2, char, Filial da SB2
@param cLocPadr, char, Armazém padrão do Produto
@param aSalvCols, array, Array dos Acols
@param nSG1, numeric, Linha do SG1
@param nQtyStok, numeric, Quantidade calculada de Estoque
@param nQtdPrj, numeric, Quantidade Projeto


@return nQtyStok, numeric, Quantidade calculada de Estoque
/*/
Static Function fCalcStokInd(cFilSB2,cLocPadr,aSalvCols,nSG1,nQtyStok,nQtdPrj)
Local aAreaSB2 := GetArea("SB2")
Local lEmpPrj    := SuperGetMV("MV_EMPPRJ",.F.,.T.)
Local cLocProc    := GetMvNNR('MV_LOCPROC','99')
Local nQtStokPrc  := 0

	dbSelectArea("SB2")
	dbSetOrder(1)

	DbSeek(cFilSB2+aSalvCols[nSG1,nPosCod]+aSalvCols[nSG1,nPosLocal])
	If Eof()
		CriaSB2(aSalvCols[nSG1,nPosCod],aSalvCols[nSG1,nPosLocal])
		MsUnlock()
	EndIf

	If !lEmpPrj
		nQtdPrj := SB2->B2_QEMPPRJ
	EndIf

	If lPrevista .And. ( nQtStokPrc > SB2->B2_QEMPPRE )
		nQtStokPrc -= SB2->B2_QEMPPRE
	Endif

	//Valida se o local do processamento é diferente do local de processo para não duplicar o estoque.
	If cLocProc <> cLocPadr
		nQtStokPrc := SaldoSB2(.T., , ,lConsTerc,lConsNPT,,,nQtdPrj)+SB2->B2_SALPEDI-SB2->B2_QEMPN+AvalQtdPre("SB2",2)
	EndIf

	nQtStokPrc += A650Prev(SB2->B2_COD)
	nQtyStok += nQtStokPrc

	RestArea(aAreaSB2)

Return nQtyStok

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³A650GeraC2³ Autor ³ Claudinei M. Benzi    ³ Data ³ 10.01.92 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Gera O.P. para Produto e quantidade informada via param.   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Sintaxe  ³ A650GeraC2(ExpC1,ExpN1,ExpD1,ExpD2,ExpD3,ExpC2,ExpN2,ExpC3,³±±
±±³          ³            ExpL1,ExpL2,ExpC4,ExpC5,ExpC6,ExpC7)            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Codigo do produto                                  ³±±
±±³          ³ ExpN1 = Quantidade da OP                                   ³±±
±±³          ³ ExpD1 = Data de inicio da OP                               ³±±
±±³          ³ ExpD2 = Data de entrega da OP                              ³±±
±±³          ³ ExpD3 = Data ajustada de entrega da OP                     ³±±
±±³          ³ ExpC2 = Campo para Atualizar a Projacao de Estoques        ³±±
±±³          ³ ExpN2 = Sequencia da OP                                    ³±±
±±³          ³ ExpC3 = Prioridade da OP                                   ³±±
±±³          ³ ExpL1 = Utiliza local padrao                               ³±±
±±³          ³ ExpL2 = OP gerada por Pedido de Venda                      ³±±
±±³          ³ ExpC4 = Local considerado                                  ³±±
±±³          ³ ExpC5 = Opcionais da OP                                    ³±±
±±³          ³ ExpC6 = Tipo da OP                                         ³±±
±±³          ³ ExpC7 = Revisao da Estrutura                               ³±±
±±³          ³ ExpN3 = Quantidade 2a. UM                                  ³±±
±±³          ³ ExpC8 = Numero da OP                                       ³±±
±±³          ³ ExpC9 = Item da Op                                         ³±±
±±³          ³ ExpCA = Sequencia da OP                                    ³±±
±±³          ³ ExpCB = Roteiro da OP                                      ³±±
±±³          ³ ExpCC = Observacao da OP                                   ³±±
±±³          ³ ExpCD = Opcionais (C2_OPC) da ordem de produção PAI        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ MATA650                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
*/
Function A650GeraC2(cProduto,nQuant,dInicio,dEntrega,dAjusFim,cCpoProj,cSeqPai,cPrior,lLocPad,lPedido,cLocal,cOpcionais,cTpOp,cRevisao,nQtde2UM,cNumOp,cItemOp,cSeqC2,cRoteiro,cObs,cOpcPai,aMRPxJson,aArrOpc)
Static aIniCpos := {}
Static lMTA650I := ExistBlock( "MTA650I" )

Local cFilSC2    := xFilial("SC2")
Local cOPGerada  := " "
Local cPerProj   := Nil
Local lExistIni  := .F.
Local lExistOP   := .T.
Local lGrvAllOpc := SuperGetMV("MV_GALLOPC",.F.,.F.)
Local lIntLocal  := aMRPxJson  == NIL
Local lIntNewMRP := Iif(_lNewMRP == Nil, Ma650MrpOn(@_lNewMRP), _lNewMRP)
Local lLite      := .F.
Local lProj      := .F.
Local lRevAut    := SuperGetMv("MV_REVAUT",.F.,.F.) //Indica se o controle de revisões será controlado automaticamente. (T=Sim;F=Não).
Local nPos       := 0
Local nPrazo     := Nil
Local nX         := 0

Default cOpcPai   := cOpcionais
Default aMRPxJson := Iif(lIntNewMRP, {{}, JsonObject():New()}, Nil)
Default l650Auto  := .F.
Default lOpVendas := .F.
Default lPCPA107  := .F.
Default lMata712  := .F.

Private lAtuNec  := .F.

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Verifica se a rotina esta sendo chamada da Proj.Estoques NOVA ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
lProj711:=If(Type("lProj711") == "L",lProj711,.F.)

nPrazo     := CalcPrazo(cProduto,nQuant,,,!Empty(dInicio),If(Empty(dInicio),dEntrega,dInicio))
dInicio    := IIf( dInicio  == NIL, SomaPrazo(dEntrega, - nPrazo),dInicio)
dEntrega   := IIf( dEntrega == NIL, SomaPrazo(dInicio, nPrazo),dEntrega)

If lProj711
	dEntrega := aPeriodos[Val(a650DtoPer(dEntrega))]
	dInicio  := aPeriodos[Val(a650DtoPer(SomaPrazo(dEntrega, - nPrazo)))]
EndIf

dAjusFim   := IIf( dAjusFim == NIL, "" , dAjusFim)
cRevisao   := IIf( cRevisao == NIL ,"" , cRevisao)
lLocPad    := IIf( lLocPad  == NIL, .T., lLocPad )
lPedido    := IIf( lPedido  == NIL, .F., lPedido )
cTpOp      := IIf( cTpOp == NIL .Or. Empty(cTpOp),"F",cTpOp)
cOpcionais := IIf( cOpcionais == NIL ,"" , cOpcionais)
nQtde2UM   := IIf( nQtde2UM   == NIL ,0 , nQtde2UM)
cItemGrd   := IF(Type("cItemGrd") == "U", "", cItemGrd)
cGrade     := IF(Type("cGrade")   == "U", "", cGrade)
cStatus    := IF(Type("cStatus")  == "U", CriaVar("C2_STATUS"), cStatus)
cBlqApon   := If (Type("lPCPA113") == "L" .And. lPCPA113, "1", "2")

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Grava nas Ops filhas o numero da sequencia da Op Pai    ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
cSeqPai := IIf(cSeqPai != NIL,cSeqPai,"000")
cPrior  := IIf(cPrior != NIL,cPrior,"500")

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Tratamento da variavel "aSav650", que armazena as perguntas MTA650  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If !(Type('aSav650')=='A') .Or. !Empty(AsCan(aSav650,{|x|x == NIL}))
	aSav650 := Array(20)
	MTA650PERG(.F.)
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Verifica se a rotina esta sendo chamada da Proj.Estoques   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If cCpoProj != NIL
	lProj := .T.
endif

If Type("aRetorOpc") <> "A"
	aRetorOpc:={}
EndIf

SB1->(dbSetOrder(1))
SB1->(MsSeek(xFilial("SB1")+cProduto))
cRoteiro:= SB1->B1_OPERPAD

If !IsInCallStack('A650WriteOp') .And. Empty(cRevisao)
	cRevisao := IIF(lRevAut , PCPREVATU(SB1->B1_COD), SB1->B1_REVATU)
EndIf

dbSelectArea("SC2")

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Atualiza dados padroes do arquivo de O.P.s              ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If inclui
	//Verifica se já existe esse número.
	lExistOP := .T.
	SC2->(dbSetOrder(1))
	While lExistOP
		If SC2->(dbSeek(cFilSC2+cNumOp+cItemOp+cSeqC2+cItemGrd))
			cSeqC2 := Soma1(cSeqC2,Len(SC2->C2_SEQUEN))
		Else
			lExistOP := .F.
		EndIf
		SC2->(dbSkip())
	End
	RecLock("SC2",.T.)

	//Gravando inicializador padrão dos campos de usuario
	bCampo := { |nCPO| Field(nCPO) }

	For nX := 1 TO FCount()
		nPos := aScan(aIniCpos,{|x| x[1] == Field(nX)}) //Trata desta forma para melhor desempenho no MRP.
		If nPos > 0
			lExistIni := aIniCpos[nPos,2]
		Else
			lExistIni := ExistIni(EVAL(bCampo,nX))
			aAdd(aIniCpos,{Field(nX),lExistIni,SX3->X3_RELACAO})
			nPos := Len(aIniCpos)
		EndIf
		If lExistIni .And. !(Field(nX) $ "C2_NUM/C2_ITEM/C2_SEQUEN")
			SC2->&(EVAL(bCampo,nX)) := InitPad(aIniCpos[nPos,3])
		EndIf
	Next nX

Else
	If dbSeek(cFilSC2+cNumOp+cItemOp+cSeqC2+cGrade)
		dbSelectArea("SB2")
		dbSetOrder(1)
		If !MsSeek(xFilial("SB2")+cProduto+IIf(lLocPad,RetFldProd(SB1->B1_COD,"B1_LOCPAD"),cLocal))
			CriaSB2(cProduto,IIf(lLocPad,RetFldProd(SB1->B1_COD,"B1_LOCPAD"),cLocal))
			MsUnlock()
		EndIf
		GravaB2Pre("-",SC2->C2_QUANT,SC2->C2_TPOP,SC2->C2_QTSEGUM)
		dbSelectArea("SC2")
		RecLock("SC2",.F.)
	Else
		RecLock("SC2",.T.)

		//Gravando inicializador padrão dos campos de usuario
		bCampo := { |nCPO| Field(nCPO) }

		For nX := 1 TO FCount()
			nPos := aScan(aIniCpos,{|x| x[1] == Field(nX)}) //Trata desta forma para melhor desempenho no MRP.
			If nPos > 0
				lExistIni := aIniCpos[nPos,2]
			Else
				lExistIni := ExistIni(EVAL(bCampo,nX))
				aAdd(aIniCpos,{Field(nX),lExistIni,SX3->X3_RELACAO})
				nPos := Len(aIniCpos)
			EndIf
			If lExistIni .And. !(Field(nX) $ "C2_NUM/C2_ITEM/C2_SEQUEN")
				SC2->&(EVAL(bCampo,nX)) := InitPad(aIniCpos[nPos,3])
			EndIf
		Next nX

	Endif
Endif

If lProj711 .AND. Type('lDiasHf')=="L" .AND. lDiasHf
	cTpOp:= A710VerHf(dEntrega,cProduto)
EndIf

If cProduto != SB1->B1_COD
	SB1->(dbSetOrder(1))
	SB1->(MsSeek(xFilial("SB1")+cProduto))
EndIf

cOPGerada := cNumOp + cItemOp + cSeqC2 + cItemGrd

dbSelectArea("SC2")

Replace	C2_FILIAL	With cFilSC2
Replace C2_PRODUTO	With cProduto
Replace	C2_NUM		With cNumOp
Replace	C2_ITEM	    With cItemOp
Replace	C2_SEQUEN	With cSeqC2
Replace	C2_EMISSAO	With dDataBase
Replace	C2_LOCAL	With IIf(lLocPad,RetFldProd(SB1->B1_COD,"B1_LOCPAD"),cLocal)
Replace	C2_CC		With SB1->B1_CC
Replace	C2_UM		With SB1->B1_UM
Replace	C2_QUANT	With nQuant
Replace	C2_QTSEGUM	With ConvUm(cProduto,nQuant,nQtde2UM,2)
Replace	C2_DATPRF	With dEntrega
Replace	C2_DESTINA	With IIF(lPedido,"P","E")
Replace	C2_PRIOR	With cPrior
Replace	C2_SEGUM	With SB1->B1_SEGUM
Replace	C2_DATPRI	With dInicio
Replace	C2_SEQPAI	With cSeqPai
Replace	C2_ROTEIRO	With A650VldRot(SC2->C2_PRODUTO,cRoteiro)
Replace	C2_IDENT	With IIF(lProj.Or.lProj711,"P"," ")
Replace	C2_PEDIDO	With IIF(lPedido,cPedido,"")
Replace	C2_ITEMPV	With IIF(lPedido,cItemPv,"")
Replace C2_OP       With cOPGerada

If !empty(cOpcionais)
	If ! lMopcGRV
		Replace C2_MOPC With cOpcionais
	Else
		If (Empty(cSeqPai) .OR. cSeqpai = '000')
			Replace C2_MOPC With cOpcionais
		endif
	Endif
EndIf
//Replace	C2_MOPC	With Iif(Len(aRetorOpc)>0,Array2Str(aRetorOpc,.F.),cOpcionais)

If !lGrvAllOpc
	Replace	C2_OPC	With cOpcionais
Else
	Replace	C2_OPC	With cOpcPai
EndIf
Replace C2_TPOP     With cTpop
Replace C2_REVISAO  With cRevisao
Replace C2_ITEMGRD  With cItemGrd
Replace C2_GRADE    With cGrade
If SC2->(ColumnPos("C2_BLQAPON"))
	Replace C2_BLQAPON  With cBlqApon
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Atualizacao dos campos utilizados pelo processo de geracao ³
//³em BATCH das OP's intermediarias.                          ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

Replace C2_BATCH   With "S"
Replace C2_BATUSR  With RetCodUsr()
Replace C2_BATROT  With FunName()


//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Atualizacao do campo C2_DIASOCI utilizados pelo processo   ³
//³de geracao em BATCH das OP's intermediarias.               ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Replace C2_DIASOCI With SuperGetMV("MV_DIASOCI",.F.,99)

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Caso usuario deseje, grava Observacao nas OPs Intermed.   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If aSav650[09] == 1
	Replace C2_OBS	With cObs
EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Caso usuario deseje, grava Status nas OPs Intermed.       ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If aSav650[16] == 1
	Replace C2_STATUS With cStatus
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Atualiza data de ajuste caso a OP PAI tenha sido ajustada ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If !Empty(dAjusFim)
	Replace C2_DATAJF  With dAjusFim	, C2_DATAJI With SomaPrazo(dAjusFim, -nPrazo)
EndIf

If lProj711
	Replace C2_SEQMRP With c711NumMRP
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Gera integracao com Inspecao de Processos (QIP), caso exista    ³
//| Obs: funcao OPGeraQIP esta programada no PCPXFUN.				³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If SuperGetMV("MV_QPOPINT",.F.,.T.) // Parametro identifica se o usuário deseja inspecionar OPs intermediárias.
	OPGeraQIP()
EndIf

If lMTA650I
	ExecBlock("MTA650I",.F.,.F.)
Endif
MsUnLock()

If Type("nMetricOP") == "N"
	//Soma qtd de OP geradas - para métrica de OP por Venda
	nMetricOP++
EndIf

If !lProj711 .And. !lMata712 .And. !lPCPA107 .And. !lOpVendas .And. !l650Auto
	//ID de métricas - usado para inclusão de OP manual
	//Intermediárias
	If Findfunction("PCPMETRIC")
		PCPMETRIC("MATA650", {{"manufatura-protheus_qtde-ops-manuais_total", 1 }})
	EndIf
EndIf

If lProj711 .or. lMata712 .or. lPCPA107
	If Type("nMetricAut") == "N"
		//Soma qtd de OP automáticas para envio de métrica - Qtde OPs Auto
		nMetricAut++
	EndIf
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Integracoes TOTVS APS e SFC: gera OP e Operacoes X Ordem (SHY)    ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lIntSFC
	A650IntSFC(3,4) //Evento 4 - Geracao de Op Filha
EndIf

If Empty(cRoteiro := SC2->C2_ROTEIRO)
	If Empty(cRoteiro := Posicione("SB1",1,xFilial("SB1")+SC2->C2_PRODUTO,"B1_OPERPAD"))
		cRoteiro := StrZero(1,TamSX3("G2_CODIGO")[1])
	EndIf
EndIf
SC2->(TAPSOperac(C2_NUM+C2_ITEM+C2_SEQUEN+C2_ITEMGRD,C2_PRODUTO,cRoteiro,C2_QUANT))

If lIntSFC
	A650IntSFC(4,2) //Evento 2 - Geracao das Operacoes
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Atualiza Necessidade da Projecao de Estoques                   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lProj
	cPerProj := A650DtoPer(C2_DATPRF)
	If !Empty(cPerProj)
		cCpoProj := "H5_PER"+cPerProj
		dbSelectArea("SH5")
		dbSetOrder(1)
		If dbSeek(xFilial("SH5")+cProduto+"2")
			RecLock("SH5",.F.)
			Replace &(cCpoProj) with &(cCpoProj)+nQuant
			MsUnlock()
		EndIf
		If dbSeek(xFilial("SH5")+cProduto+"5")
			dbSetOrder(2)
			RecLock("SH5",.F.)
			Replace &(cCpoProj) with &(cCpoProj)-nQuant
			If &(cCpoProj) < .005
				Replace &(cCpoProj) with 0
			EndIf
			MsUnlock()
		EndIf
	EndIf
ElseIf lProj711 .And. !lMata712 .And. !lPCPA107
	A711CriSH5(SC2->C2_DATPRF,SC2->C2_PRODUTO,Iif(Empty(IIF(lMopcGRV,cCampoMopc,SC2->C2_MOPC)),SC2->C2_OPC,IIF(lMopcGRV,cCampoMopc,SC2->C2_MOPC)),SC2->C2_REVISAO,"SC2",SC2->(Recno()),SC2->(C2_NUM+C2_ITEM+C2_SEQUEN+C2_ITEMGRD),"",If(!Empty(SC2->C2_PEDIDO),SC2->C2_PEDIDO+"/"+SC2->C2_ITEMPV,""),Max(0,SC2->(C2_QUANT-C2_QUJE)),"2",.T.,NIL,NIL,.T.)
ElseIf Type("lMata712")== "L"
	if lMata712
		A712CriCZI(SC2->C2_DATPRF,SC2->C2_PRODUTO,/*03*/,SC2->C2_REVISAO,"SC2",SC2->(Recno()),SC2->(C2_NUM+C2_ITEM+C2_SEQUEN+C2_ITEMGRD),/*08*/,If(!Empty(SC2->C2_PEDIDO),SC2->C2_PEDIDO+"/"+SC2->C2_ITEMPV,""),Max(0,SC2->(C2_QUANT-C2_QUJE)),"2",.T.,/*13*/,/*14*/,.T.,/*16*/,/*17*/,/*18*/,/*19*/,/*20*/,/*21*/,/*22*/,/*23*/,/*24*/,IIF(lMopcGRV,cCampoMopc,SC2->C2_MOPC),/*26*/)
	Else
		If Type("lPCPA107")=="L"
			If lPCPA107
				lAtuNec := .T.
				A107CriSOQ(SC2->C2_DATPRF,SC2->C2_PRODUTO,/*03*/,SC2->C2_REVISAO,"SC2",SC2->(Recno()),SC2->(C2_NUM+C2_ITEM+C2_SEQUEN+C2_ITEMGRD),/*08*/,If(!Empty(SC2->C2_PEDIDO),SC2->C2_PEDIDO+"/"+SC2->C2_ITEMPV,""),Max(0,SC2->(C2_QUANT-C2_QUJE)),"2",.T.,/*13*/,/*14*/,.T.,/*16*/,/*17*/,/*18*/,/*19*/,/*20*/,/*21*/,/*22*/,/*23*/,/*24*/,IIF(lMopcGRV,cCampoMopc,SC2->C2_MOPC),/*26*/)
				lAtuNec := .F.
				A107CriSOU('OP',Iif(cProd107==SC2->C2_PRODUTO,nRec107,0), lPmp107, SC2->C2_NUM, SC2->C2_SEQUEN, SC2->C2_ITEM, SC2->C2_ITEMGRD, SC2->C2_QUANT, cPeri107, SC2->C2_DATPRF, SC2->C2_PRODUTO)
			EndIf
		EndIf
	EndIf
Endif

//Integração PCFactory
If !lProj711 .And. PCPIntgPPI("SC2", @lLite) .And. (!IsInCallStack("MontEstru") .Or. lLite)
	//Se está chamando a partir da MontEstru, não irá executar a integração agora,
	//pois na função MontEstru já irá realizar a chamada da função de integração.
	//Caso seja MES LITE e está chamando do MONTSTRU executa a integração aqui, pois não irá executar a
	//integração no montEstru para o MES LITE.
	mata650PPI(,,.T.,.T.,.F.)
EndIf

//Integração de ordens de produção com o novo MRP. Inclusão/Alteração de ordens
If lIntNewMRP
	A650AddJIn(@aMRPxJson) //Inclui dados no array para integração com o novo MRP
	If lIntLocal
		enviaOpMrp("INSERT", @aMRPxJson)
	EndIf
EndIf

dbSelectArea("SB2")
dbSetOrder(1)
If !MsSeek(xFilial("SB2")+cProduto+IIf(lLocPad,RetFldProd(SB1->B1_COD,"B1_LOCPAD"),cLocal))
	CriaSB2(cProduto,IIf(lLocPad,RetFldProd(SB1->B1_COD,"B1_LOCPAD"),cLocal))
	MsUnlock()
EndIf
GravaB2Pre("+",SC2->C2_QUANT,SC2->C2_TPOP,SC2->C2_QTSEGUM)
snTotNewOp++
Return

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³A650GeraC1³ Autor ³ Claudinei M. Benzi    ³ Data ³ 10.01.92 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Gera Solic. para produto na quantidade informada via param.³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Sintaxe  ³ A650GeraC1(ExpC1,ExpN1,ExpC2,ExpD1)                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Codigo do produto                                  ³±±
±±³          ³ ExpN1 = Quantidade da SC                                   ³±±
±±³          ³ ExpC2 = Numero da OP geradora                              ³±±
±±³          ³ ExpD1 = Data de entrega da SC                              ³±±
±±³          ³ ExpC3 = Campo para atualizar projecao de estoques          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ MATA650                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
*/
Function A650GeraC1(cProduto,nQuant,cOp,dEntrega,cCpoProj,nx,nNecessid,cLocal,cTpOp,cPedido,cItemPedido,aPedidos,nQuantItem)
Static lA650OKSC  := NIL
Static lA650OKSCT := NIL

Local lProj       :=.F.,nAchou
Local nLoop		  := 0
Local lGeraSCAE   :=.T.
Local aAreaSC6

Local aFornecedor := {}
Local nPrc		  := 0
Local aDocs		  := {}
Local aResultados := {}
Local aDatasNec	  := {}
Local aParam   	  := {}
Local aCampos	  := {}

Local cLocProc    := GetMvNNR('MV_LOCPROC','99')
Local nGravaOP    := SuperGetMV("MV_GRAVOP",.F.,1)
Local laSAv651	  := TYPE("aSAv651") == 'A'
Local lLteEmb	  := .T.
Local nSAv651     := 0
Local nBkpPar06   := 1

DEFAULT cPedido     := ""
DEFAULT cItemPedido := ""
DEFAULT aPedidos    := {}
DEFAULT nQuantItem  := 0


cTpOp:=If(cTpOp == NIL .Or. Empty(cTpOp),"F",cTpOp)
lA650OKSCT:=If(lA650OKSCT == NIL,ExistTemplate("A650OKSC"),lA650OKSCT)
lA650OKSC :=If(lA650OKSC == NIL,ExistBlock("A650OKSC"),lA650OKSC)

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Posiciona no produto correto.                              ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
SB1->(dbSetOrder(1))
SB1->(MsSeek(xFilial("SB1")+cProduto))

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Verifica se a rotina esta sendo chamada da Proj.Estoques   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If cCpoProj != NIL
	lProj := .T.
endif

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Verifica se a rotina esta sendo chamada da Proj.Estoques NOVA ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
lProj711:=If(Type("lProj711") == "L",lProj711,.F.)

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Tratamento da variavel "aSav650", que armazena as perguntas MTA650  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If !(Type('aSav650')=='A') .Or. !Empty(AsCan(aSav650,{|x|x == NIL}))
	aSav650 := Array(20)
	MTA650PERG(.F.)
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Pontos de Entrada                                             ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lA650OKSCT
	lGeraSCAE:=ExecTemplate("A650OKSC",.F.,.F.,{cProduto,nQuant,cOp})
	If !(ValType(lGeraSCAE) == "L")
		lGeraSCAE:=.T.
	EndIf
EndIf

If lA650OKSC
	lGeraSCAE:=ExecBlock("A650OKSC",.F.,.F.,{cProduto,nQuant,cOp})
	If !(ValType(lGeraSCAE) == "L")
		lGeraSCAE:=.T.
	EndIf
EndIf

//Se está sendo gerada as ordens pelo MRP,
//executa o ponto de entrada para determinar se a SC será gerada ou não.
If (lProj711) .Or. ;
   (Type('lMata712') == "L" .And. lMata712) .Or. ;
   (Type('lPCPA107') == "L" .And. lPCPA107)
	aParam := {dEntrega,nQuant,cProduto}
	//PE para tratamento se deve ou não incluir a SC. Se retornar F não inclui a SC.
	If (ExistBlock("MT711VLSC"))
	    lGeraSCAE := Execblock ("MT711VLSC",.F.,.F.,aParam)
	    If !(ValType(lGeraSCAE) == "L")
			lGeraSCAE:=.T.
		EndIf
	EndIf
EndIf


//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Verifica se o produto tem contrato de parceria             ³
//³ Se nao, gera solic.Compra; Se sim, gera Autor. de Entrega  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lGeraSCAE .And. SB1->B1_CONTRAT $ "N "

	nBkpPar06 := aSav650[06]

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ A alteracao do conteudo da variavel que controla as SC's foi  ³
	//³ incluida para tratar separadamente as geracoes, sem a neces-  ³
	//³ sidade de se analisar as variaveis lProj e lProj711.          ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	aSav650[06] := If(aSav650[06] == 3 .and. (lProj .or. lProj711 ),1,aSav650[06])
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ A alteracao do conteudo da variavel que controla as SC's foi  ³
	//³ incluida para tratar separadamente as geracoes por venda.	  |
	//³ Nestes casos a aglutinacao sera definida pela pergunta 18 do  |
	//| array aSav651, tratada na AvalMarca e A650GeraOp			  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	aSav650[06] := If(aSav650[06] > 1 .And. (Empty(cOP) .And. !Empty(cPedido+cItemPedido)),1,aSav650[06])
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica se as SC's/CP's devem ser aglutinados ou se j     ³
	//³ devems ser gerados.                                        ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If (aSav650[06] == 1) // Gera
		If lMTA650PR .OR. (lProj711 .And. lMata712) //MRP - Desempenho

			If nQuant == nNecessid
				A650GravC1(cProduto,nQuant,cOp,dEntrega,cCpoProj,nx,nNecessid,,,cLocal,cTpOp,nil,cPedido,cItemPedido,.T.,{{cPedido, cItemPedido}})
			Else
				A650GravC1(cProduto,nQuant,cOp,dEntrega,cCpoProj,nx,nNecessid,,,cLocal,cTpOp,nil,,,.T.)
			EndIf
		Else
			//aFornecedor:= COMPESQFOR(cProduto) //-- Retorna codigo e loja do fornecedor
			aFornecedor := aPesqFor(cProduto) //-- Retorna codigo e loja do fornecedor padrão
			nPrc:= COMPESQPRECO(cProduto,cFilAnt,aFornecedor[1],aFornecedor[2])
			Aadd(aDatasNec,dEntrega)

			If laSAv651
			   nSAv651 := aSav651[2]
			EndIf

			If (nQuant == nNecessid) .or. (nNecessid == 0 .and. nSAv651 == 2)// RETIRADO. Verificar chamado TUVYG0. As solicitações de compra devem ser geradas com o relacionamento da OP.
				//A650GravC1(cProduto,nQuant,cOp,dEntrega,cCpoProj,nx,nNecessid,,,cLocal,cTpOp,nil,cPedido,cItemPedido,.T.,{{cPedido, cItemPedido}})
				If nGravaOP <> 4
					aadd(aCampos,{"OP",cOp})
				EndIf
				aadd(aCampos,{"DATPRF",dEntrega})
				aadd(aCampos,{"TPOP",cTpOp})
				aadd(aCampos,{"OBS",If(!Empty(cPedido+cItemPedido),"PV #"+cPedido+"#"+cItemPedido,"") })

				If (SB1->B1_APROPRI=="I" .And. cLocProc != cLocal) .Or. !(SB1->B1_APROPRI == "I")
					aadd(aCampos,{"Local",cLocal})
				EndIf
				If Type('lProj711') == "L" .And. lProj711
					aadd(aCampos,{"SEQMRP",c711NumMRP})
				EndIf
				Aadd(aDocs,{cProduto,nQuant,cFilAnt,cFilAnt,"1",aFornecedor[1],aFornecedor[2],,nPrc,{},cOp,"",aCampos})
			Else
				//A650GravC1(cProduto,nQuant,' ',dEntrega,cCpoProj,nx,nNecessid,,,cLocal,cTpOp,nil,cPedido,cItemPedido,.T.,{{cPedido, cItemPedido}})
				If nGravaOP == 2 .OR. (nGravaOP == 3 .AND. (nQuant == nQuantItem .or. Mod(nQuantItem,nQuant) == 0))//Se a quantidade empenhado for igual ao lote ou multiplo do lote.
					aadd(aCampos,{"OP",cOp})
				EndIf
				aadd(aCampos,{"TPOP",cTpOp})
				aadd(aCampos,{"DATPRF",dEntrega})

				If (SB1->B1_APROPRI=="I" .And. cLocProc != cLocal) .Or. !(SB1->B1_APROPRI == "I")
					aadd(aCampos,{"Local",cLocal})
				EndIf
				If Type('lProj711') == "L" .And. lProj711
					aadd(aCampos,{"SEQMRP",c711NumMRP})
				EndIf
				Aadd(aDocs,{cProduto,nQuant,cFilAnt,cFilAnt,"1",aFornecedor[1],aFornecedor[2],,nPrc,{}," ","",aCampos})
			EndIf
			If laSAv651
				If Asav651[19] == 2
					lLteEmb = .F.
				Else
					lLteEmb = .T.
				EndIF
			EndIf

			If !Empty(aDocs)
				aResultados:= ComGeraDoc(aDocs,.T.,.F.,lLteEmb,.F.,ComDtNeces(aDatasNec),"MATA650",/*lEnviaEmail*/,1)
				a650TabMRP(aResultados)
				If Len(aResultados) > 0 .And. Len(aResultados[1]) > 0 .And. aResultados[1,1,3] == "1" .And. Empty(cOp)
	    			aArea    := GetArea()
	    			aAreaSC6 := SC6->(GetArea())

	    			SC6->(dbSetOrder(1))
					If SC6->(MsSeek(xFilial('SC6')+cPedido+cItemPedido)) .And. Empty(SC6->C6_NUMSC)
						Reclock("SC6",.F.)
						Replace C6_NUMSC  With SubStr(aResultados[1,1,2],1,TamSX3("C1_NUM")[1])
						Replace C6_ITEMSC With SubStr(aResultados[1,1,2],TamSX3("C1_NUM")[1]+1,Len(aResultados[1,1,2]))
						MsUnLock()
					EndIf

					RestArea(aAreaSC6)
					RestArea(aArea)
				EndIf

				If ExistBlock("MT650C1")
					For nLoop := 1 To Len( aResultados )
						Do Case
							//--Tipo de documento gerado pela biblioteca de compras
							Case aResultados[nLoop,1,3] == "1" //-- Solicitação de Compras
								SC1->(dbSetOrder(1)) //-- C1_FILIAL+C1_NUM+C1_ITEM+C1_ITEMGRD
								If SC1->(dbSeek(aResultados[nLoop,1,1]+aResultados[nLoop,1,2]))
									Execblock("MT650C1",.F.,.F.,{"SC1",SC1->C1_NUM,SC1->C1_ITEM,SC1->(Recno())})
								EndIf
						EndCase
					Next nLoop
				EndIf
			EndIf
		EndIf

	ElseIf aSav650[06] == 2				// Aglutina por OP
		nAchou:=ASCAN(aOpC1,{|x| x[1] == cProduto .And. x[3] == cOP .And. x[8] == NIL .And. x[11] == cTpOp})
		If nAchou == 0
			AADD(aOpC1,{cProduto,nQuant,cOP,dEntrega,cCpoProj,nx,nNecessid,NIL,NIL,cLocal,cTpOp,NIL,{}})
			//-- Se estiver gerando OP atraves dos pedidos 'aglutinados' (Avalia PV == 'Agrupadamente'), a posicao 13 do array aOpc1
			//-- devera conter todos os pedidos de venda 'aglutinados', caso contrario, ira conter apenas o pedido de venda posicionado
			If Len(aPedidos) > 0
			   aAreaSC6 := SC6->(GetArea())
				For nX := 1 To Len(aPedidos)
					SC6->(dbGoto(aPedidos[nX,1]))
					AADD(aOpC1[Len(aOpC1)][13], {SC6->C6_NUM, SC6->C6_ITEM})
				Next
				RestArea(aAreaSC6)
			Else
				AADD(aOpC1[Len(aOpC1)][13], {cPedido, cItemPedido})
			EndIf
		Else
			If aOpC1[nAchou,2] < aOpC1[nAchou,7]+nNecessid
				aOpC1[nAchou,2]+=nQuant
			EndIf
			aOpC1[nAchou,7]  +=nNecessid
			AADD(aOpC1[nAchou][13], {cPedido, cItemPedido})
		EndIf
	Else									// Aglutina por Data de Necessidade
		nAchou:=ASCAN(aDataOpC1,{|x| x[1] == cProduto .And. x[4] == dEntrega .And. x[8] == NIL .And. x[11] == cTpOp})
		If nAchou == 0
			AADD(aDataOpC1,{cProduto,nQuant,cOP,dEntrega,cCpoProj,nx,nNecessid,NIL,NIL,cLocal,cTpOp,NIL,{}})
			//-- Se estiver gerando OP atraves dos pedidos 'aglutinados' (Avalia PV == 'Agrupadamente'), a posicao 13 do array aDataOpc1
			//-- devera conter todos os pedidos de venda 'aglutinados', caso contrario, ira conter apenas o pedido de venda posicionado
			If Len(aPedidos) > 0
			   aAreaSC6 := SC6->(GetArea())
				For nX := 1 To Len(aPedidos)
					SC6->(dbGoto(aPedidos[nX,1]))
					AADD(aDataOpC1[Len(aDataOpC1)][13], {SC6->C6_NUM, SC6->C6_ITEM})
				Next
				RestArea(aAreaSC6)
			Else
				AADD(aDataOpC1[Len(aDataOpC1)][13], {cPedido, cItemPedido})
			EndIf
		Else
			If aDataOpC1[nAchou,2] < aDataOpC1[nAchou,7]+nNecessid
				aDataOpC1[nAchou,2]+=nQuant
			EndIf
			//--Limpa nro da OP somente se necessario
			If aDataOpC1[nAchou,3] # cOP
				aDataOpC1[nAchou,3]:=CriaVar("C1_OP")
			EndIf
			aDataOpC1[nAchou,7]+=nNecessid
			AADD(aDataOpC1[nAchou][13], {cPedido, cItemPedido})
		EndIf
	EndIf

	aSav650[06] := nBkpPar06

ElseIf lGeraSCAE
	nQuantBaixa:= nQuant
	aSav650[06] := If(aSav650[06] == 3 .and. (lProj .or. lProj711 ),1,aSav650[06])

	If aSav650[06] == 1   // Gera
		If lProj711 .And. lMata712
			If nQuant == nNecessid
				A650GravC7(cProduto,nQuant,cOp,dEntrega,cCpoProj,cTpOp,cPedido,cItemPedido) //MRP - Desempenho
			Else
				A650GravC7(cProduto,nQuant," ",dEntrega,cCpoProj,cTpOp) //MRP - Desempenho
			EndIf
		Else
			//aFornecedor:= COMPESQFOR(cProduto) //-- Retorna codigo e loja do fornecedor
			aFornecedor := aPesqFor(cProduto) //-- Retorna codigo e loja do fornecedor padrão
			nPrc:= COMPESQPRECO(cProduto,cFilAnt,aFornecedor[1],aFornecedor[2])
			Aadd(aDatasNec,dEntrega)
			aadd(aCampos,{"DATPRF",dEntrega})
			aadd(aCampos,{"TPOP",cTpOp})
			If Type('lProj711') == "L" .And. lProj711
				aadd(aCampos,{"SEQMRP",c711NumMRP})
			EndIf
			If nQuant == nNecessid
				aadd(aCampos,{"OP",cOp})
				Aadd(aDocs,{cProduto,nQuant,cFilAnt,cFilAnt,"1",aFornecedor[1],aFornecedor[2],,nPrc,{},cOp,"",aCampos})
			Else
				Aadd(aDocs,{cProduto,nQuant,cFilAnt,cFilAnt,"1",aFornecedor[1],aFornecedor[2],,nPrc,{}," ","",aCampos})
			EndIf

			//A650GravC7(cProduto,nQuant,cOp,dEntrega,cCpoProj,cTpOp,cPedido,cItemPedido)
			If !Empty(aDocs)
				aResultados:= ComGeraDoc(aDocs,.T.,.F.,.T.,.F.,ComDtNeces(aDatasNec),"MATA650",/*lEnviaEmail*/,1)
				a650TabMRP(aResultados)
				If ExistBlock("MT650C1")
					For nLoop := 1 To Len( aResultados )
						Do Case
							//--Tipo de documento gerado pela biblioteca de compras
							Case aResultados[nLoop,1,3] == "1" //-- Solicitação de Compras
								SC1->(dbSetOrder(1)) //-- C1_FILIAL+C1_NUM+C1_ITEM+C1_ITEMGRD
								If SC1->(dbSeek(aResultados[nLoop,1,1]+aResultados[nLoop,1,2]))
									Execblock("MT650C1",.F.,.F.,{"SC1",SC1->C1_NUM,SC1->C1_ITEM,SC1->(Recno())})
								EndIf
						EndCase
					Next nLoop
				EndIf
			EndIf
		EndIf
	ElseIf aSav650[06] == 2					// Aglutina por OP
		nAchou := aScan(aOpC7,{|x| x[1] == cProduto .And. x[3] == cOP .And. x[6] == cTpOp})
		If nAchou == 0
			aAdd(aOpC7,{cProduto,nQuant,cOP,dEntrega,cCpoProj,cTpOp,nNecessid,cPedido,cItemPedido})
			aAdd(aOpC7Local,{cProduto,nQuant,cOP,dEntrega,cCpoProj,cTpOp,nNecessid,cPedido,cItemPedido,cLocal})
		Else
			nAchouLoc := aScan(aOpC7Local,{|x| x[1] == cProduto .And. x[3] == cOP .And. x[6] == cTpOp .And. x[10] == cLocal})
			If nAchouLoc == 0
				aAdd(aOpC7Local,{cProduto,nQuant,cOP,dEntrega,cCpoProj,cTpOp,nNecessid,cPedido,cItemPedido,cLocal})
			Else
				If aOpC7Local[nAchouLoc,2] < aOpC7Local[nAchouLoc,7] + nNecessid
					aOpC7Local[nAchouLoc,2] += nQuant
				EndIf
				aOpC7Local[nAchouLoc,7] += nNecessid
			EndIf

			If aOpC7[nAchou,2] < aOpC7[nAchou,7] + nNecessid
				aOpC7[nAchou,2] += nQuant
			EndIf
			aOpC7[nAchou,7] += nNecessid
		EndIf
	Else										// Aglutina por Data de Necessidade
		nAchou := aScan(aDataOpC7,{|x| x[1] == cProduto .And. x[4] == dEntrega .And. x[6] == cTpOp})
		If nAchou == 0
			aAdd(aDataOpC7,{cProduto,nQuant,cOP,dEntrega,cCpoProj,cTpOp,nNecessid,cPedido,cItemPedido,cLocal})
		Else
			If aDataOpC7[nAchou,2] < aDataOpC7[nAchou,7] + nNecessid
				aDataOpC7[nAchou,2] += nQuant
			EndIf
			//-- Limpa nro da OP somente se necessario
			If aDataOpC7[nAchou,3] # cOP
				aDataOpC7[nAchou,3] := CriaVar("C1_OP")
			EndIf
			aDataOpC7[nAchou,7] += nNecessid
		EndIf
	EndIf
Endif
RETURN NIL

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³A650GravC1³ Autor ³ Marcos Bregantim      ³ Data ³ 29.04.96 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Grava Solic. de compra                                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ A650GravC1(ExpC1,ExpN1,ExpC2,ExpD1)                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Codigo do produto                                  ³±±
±±³          ³ ExpN1 = Quantidade da SC                                   ³±±
±±³          ³ ExpC2 = Numero da OP geradora                              ³±±
±±³          ³ ExpD1 = Data de entrega da SC                              ³±±
±±³          ³ ExpC3 = Campo para atualizar projacao de estoques          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ MATA650                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
*/
Function A650GravC1(cProduto,nQuant,cOp,dEntrega,cCpoProj,nx,nNecessid,lAutEnt,lSemData,cLocal,cTpOp,lFaltaQtd,cPedido,cItemPedido,lFNewSC,aPedSC1,dDataQuebr,nLastRecno)
Static cUser

Local aAreaSH5 := {}
Local aAreaSC6 := {}
Local aArea    := {}
Local aHeadSC1 := {}
Local aColSC1  := {}
Local aHeadSCX := {}
Local aColsSCX := {}
Local aColsClone := {}
Local aCols      := {}
Local aHeaderCl1 := {}
Local cNumSolic,cItem, cPerProj, lProj:=.F.
Local dDatPrf
Local lAprovEt := SuperGetMV("MV_APRSCEC",.F.,.T.) // Alcada por Entidade Contabil
Local cFilSC1 := xFilial("SC1")

Private lAtuNec := .F.

DEFAULT cPedido    := ""
DEFAULT cItemPedido:= ""
DEFAULT lFNewSC	   := .F.  //Forca nova solicitacao de compras
DEFAULT aPedSC1    := {}   //Contem todos os pedidos de Venda relacionados a SC que sera' gerada (aglutinada)
DEFAULT dDataQuebr := NIL
DEFAULT nLastRecno := 0

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Posiciona no produto correto.                              ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
SB1->(dbSetOrder(1))
SB1->(MsSeek(xFilial("SB1")+cProduto))

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Obtem usuario e grupo de compras utilizado                 ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If cUser == NIL
	cUser 	:= RetCodUsr()
EndIf

lAutEnt   := IIF(lAutEnt==NIL,.F.,lAutEnt)
lSemData  := IIF(lSemData==NIL,.F.,lSemData)
lFaltaQtd := IIF(lFaltaQtd==NIL,.F.,lFaltaQtd)

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Verifica se a rotina esta sendo chamada da Proj.Estoques NOVA ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
lProj711:=If(Type("lProj711") == "L",lProj711,.F.)

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Verifica se a rotina esta sendo chamada da Proj.Estoques   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If cCpoProj != NIL
	lProj := .T.
EndIf

nx := IIF(nx==NIL,1,nx)

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Inicializa a gravacao dos lancamentos do SIGAPCO          ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
PcoIniLan("000051")

dbSelectArea("SC1")
If inclui
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Caso nao venha de MRP, trata a aglutinacao de SC's	³
	//³ conforme mv_par06.								   	³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If !lProj .And. !lProJ711
		If aSav650[06] == 2 .And. !Empty(cOp)
			dbSetOrder(4)
			If dbSeek(cFilSC1+cOp)
				cNumSolic := SC1->C1_NUM
				While !EOF() .And. SC1->(C1_FILIAL+C1_OP) == cFilSC1+cOp
					cItem := Soma1(SC1->C1_ITEM)
					SC1->(dbSkip())
				End
			EndIf
		ElseIf aSav650[06] == 3
			If !Empty(dDataQuebr) .And. dDataQuebr == dEntrega
				SC1->(dbGoTo(nLastRecno))
				cNumSolic := SC1->C1_NUM
				cItem := Soma1(SC1->C1_ITEM)
			Else
				dDataQuebr := dEntrega
			EndIf
		EndIf
	EndIf

	If Empty(cNumSolic)
		cNumSolic := GetNumSc1(.T.)
		If Empty(cNumSolic)
			cNumSolic := ProximoNum("SC1")
		EndIf
		cItem := StrZero(1,Len(SC1->C1_ITEM))
	EndIf
	RecLock("SC1",.T.)
Else
	dbSetOrder(4)
	dbSeek(cFilSC1+cOp)
	If Found() .And. !lProj .And. !lProJ711 .And. ! Empty(cOp) .And. !lFNewSC
		While !EOF() .And. C1_FILIAL+C1_OP == cFilSC1+cOp
			If C1_PRODUTO == cProduto
				Exit
			EndIf
			dbSkip()
		EndDo
		If !EOF() .And. C1_FILIAL+C1_OP+C1_PRODUTO == cFilSC1+cOp+cProduto
			dbSelectArea("SB2")
			dbSetOrder(1)
			If !MsSeek(xFilial("SB2")+SC1->C1_PRODUTO+SC1->C1_LOCAL)
				CriaSB2(SC1->C1_PRODUTO,SC1->C1_LOCAL)
				MsUnlock()
			EndIf
			GravaB2Pre("-",SC1->C1_QUANT,SC1->C1_TPOP,SC1->C1_QTSEGUM)
			dbSelectArea("SC1")
			cNumSolic := C1_NUM
			cItem     := C1_ITEM
			RecLock("SC1",.F.)
		Else
			cNumSolic := GetNumSc1(.T.)
			If Empty(cNumSolic)
				cNumSolic := ProximoNum("SC1")
			EndIf
			cItem     := StrZero(1,Len(SC1->C1_ITEM))
			RecLock("SC1",.T.)
		EndIf
	Else
		cNumSolic := GetNumSc1(.T.)
		If Empty(cNumSolic)
			cNumSolic := ProximoNum("SC1")
		EndIf
		cItem     := StrZero(1,Len(SC1->C1_ITEM))
		RecLock("SC1",.T.)
	Endif
Endif

//Retirado calculo da entrega com base nos períodos para gerar SCs retroativas no MRP com a data correta para atender a necessidade. Ticket = 3846777
//dDatPrf:= IIF(lProj.Or.lProj711,aPeriodos[Val(a650DtoPer(dEntrega))],dEntrega)
dDatPrf:= dEntrega
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Verifica se o produto possui Horizonte Firme cadastrado   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lProj711 .AND. Type('lDiasHf')=="L" .AND. lDiasHf
	cTpOp:= A710VerHf(dDatPrf,cProduto)
EndIf

Replace	C1_FILIAL  With cFilSC1	,C1_ITEM	With cItem,;
		C1_PRODUTO With cProduto       	,C1_UM		With SB1->B1_UM,;
		C1_LOCAL   With cLocal         	,C1_CC		With SB1->B1_CC,;
		C1_EMISSAO With dDataBase      	,C1_NUM		With cNumSolic,;
		C1_OP      With cOp            	,C1_DESCRI	With SB1->B1_DESC,;
		C1_SEGUM   With SB1->B1_SEGUM	,C1_QUANT	With nQuant,;
		C1_QTSEGUM With ConvUm(cProduto,nQuant,0,2),;
		C1_DATPRF  With dDatPrf,;
		C1_IMPORT  With SB1->B1_IMPORT	,C1_COTACAO	With If(SB1->B1_IMPORT=="S","IMPORT",""),;
		C1_TPOP    With cTpOp			,C1_GRUPCOM	With MaRetComSC(SB1->B1_COD,UsrRetGrp(),cUser),;
		C1_USER    With cUser          	,C1_FORNECE	With SB1->B1_PROC,;
		C1_LOJA    With SB1->B1_LOJPROC	,C1_SOLICIT	With CriaVar("C1_SOLICIT"),;
		C1_CONTA   With SB1->B1_CONTA  	,C1_QTDORIG	With nQuant,;
		C1_FILENT  With xFilEnt(If(Empty(C1_FILENT),C1_FILIAL, C1_FILENT)),;
		C1_ORIGEM  With "MATA650"

	MsUnLock()
	nLastRecno := SC1->(Recno())

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Tratamento para controle de Alcada com entidade contabil             //
//	Tratamento não realizado via ExecAuto para não causar lentidão no MRP //
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
If lAprovEt
	//-- Gera aHeader e aCols das tabelas SC1 e SCX para utilização no bloqueio por Entidade Contabil.
	aColsClone := aClone(aCols)

	If (Type('aHeader')=='A' .And. Len(aHeader)>0)
		aHeaderCl1 := aClone(aHeader)
	EndIf

	COMGerC1Cx(cNumSolic,@aHeadSC1,@aColSC1,@aHeadSCX,@aColsSCX)
	SC1->(dbSetOrder(1))
	MaEntCtb("SC1","SCX",cNumSolic,"SC",aHeadSC1,aColSC1,aHeadSCX,aColsSCX,2,dDataBase)
	aCols := aClone(aColsClone)

	If (Type('aHeader')=='A' .And. Len(aHeader)>0)
		aHeader := aClone(aHeaderCl1)
	EndIf
EndIF

MaAvalSC("SC1",1)


If (ExistBlock( "MT650C1" ) )
	ExecBlock("MT650C1",.F.,.F.)
EndIf
If lAutEnt
	RecLock("SC1",.F.)
	If lSemData
		Replace C1_OBS With If(!Empty(cPedido+cItemPedido),C1_OBS+Substr(STR0033,1,15),STR0033)	//"FORA DA DATA CONTR. PARCERIA"
	ElseIf lFaltaQtd
		Replace C1_OBS With If(!Empty(cPedido+cItemPedido),C1_OBS+Substr(STR0052,1,15),STR0052)	//"QUANT. DO CONTRATO ESGOTADA"
	Else
		Replace C1_OBS With If(!Empty(cPedido+cItemPedido),C1_OBS+Substr(STR0034,1,15),STR0034)	//"SEM CONTRATO DE PARCERIA"
	Endif
	MsUnLock()
Endif

//-- Se a geracao do solicitacao for feita pelo MRP sera preenchido o SEQMRP
RecLock("SC1",.F.)
If  lProj711
	SC2->( DbSetOrder(1) )
	If SC2->( MsSeek(xFilial("SC2")+cOp) )
		Replace C1_SEQMRP With SC2->C2_SEQMRP
	EndIf
EndIf

//-- Executa avaliação do tipo de Compra
SC1->C1_TIPCOM := MRetTipCom(,.T.,"SC")

MsUnLock()

dbSetOrder(1)
If __lSX8
	ConfirmSX8()
EndIf

If Empty(cOp)
    aArea:=GetArea()
    aAreaSC6:=SC6->(GetArea())
    For nx := 1 To Len(aPedSC1)
		SC6->(dbSetOrder(1))
		If SC6->(MsSeek(xFilial('SC6')+aPedSC1[nX][1]+aPedSC1[nX][2])) .And. Empty(SC6->C6_NUMSC)
			Reclock("SC6",.F.)
			Replace C6_NUMSC  With cNumSolic
			Replace C6_ITEMSC With cItem
			MsUnLock()
		EndIf
	Next nX
	RestArea(aAreaSC6)
	RestArea(aArea)
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Atualiza Necessidade da Projecao de Estoques                   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lProj
	cPerProj := A650DtoPer(C1_DATPRF)
	If !Empty(cPerProj)
		cCpoProj := "H5_PER"+cPerproj
		dbSelectArea("SH5")
		aAreaSH5:=GetArea()
		dbSetOrder(1)
		If dbSeek(xFilial("SH5")+cProduto+"2")
			RecLock("SH5",.F.)
			Replace &(cCpoProj) With &(cCpoProj)+nQuant
			MsUnlock()
		EndIf
		If dbSeek(xFilial("SH5")+cProduto+"5")
			RecLock("SH5",.F.)
			dbSetOrder(2)
			Replace &(cCpoProj) with &(cCpoProj)-nQuant
			If &(cCpoProj) < .005
				Replace &(cCpoProj) with 0
			EndIf
		EndIf
		RestArea(aAreaSH5)
	EndIf
ElseIf lProj711 .And. !lMata712 .And. !lPCPA107
	A711CriSH5(SC1->C1_DATPRF,SC1->C1_PRODUTO,CriaVar("C2_OPC",.F.),Space(Len(SB1->B1_REVATU)),"SC1",SC1->(Recno()),SC1->C1_NUM,SC1->C1_ITEM,SC1->C1_OP,Max(0,SC1->C1_QUANT-SC1->C1_QUJE),"2",.T.,NIL,NIL,.T.)
ElseIf Type("lMata712") == "L"
	If lMata712
		A712CriCZI(SC1->C1_DATPRF,SC1->C1_PRODUTO,CriaVar("C2_OPC",.F.),Space(Len(SB1->B1_REVATU)),"SC1",SC1->(Recno()),SC1->C1_NUM,SC1->C1_ITEM,SC1->C1_OP,Max(0,SC1->C1_QUANT-SC1->C1_QUJE),"2",.T.,/*13*/,/*14*/,.T.,/*16*/,/*17*/,/*18*/,/*19*/,/*20*/,/*21*/,/*22*/,/*23*/,/*24*/,/*25*/,/*26*/)
	Else
		If Type("lPCPA107") == "L"
			If lPCPA107
				lAtuNec := .T.
				A107CriSOQ(SC1->C1_DATPRF,SC1->C1_PRODUTO,CriaVar("C2_OPC",.F.),Space(Len(SB1->B1_REVATU)),"SC1",SC1->(Recno()),SC1->C1_NUM,SC1->C1_ITEM,SC1->C1_OP,Max(0,SC1->C1_QUANT-SC1->C1_QUJE),"2",.T.,/*13*/,/*14*/,.T.,/*16*/,/*17*/,/*18*/,/*19*/,/*20*/,/*21*/,/*22*/,/*23*/,/*24*/,/*25*/,/*26*/)
				lAtuNec := .F.
				A107CriSOU('SC',Iif(cProd107==SC1->C1_PRODUTO,nRec107,0), lPmp107, SC1->C1_NUM, /*05*/, SC1->C1_ITEM, SC1->C1_ITEMGRD, SC1->C1_QUANT, cPeri107, SC1->C1_DATPRF, SC1->C1_PRODUTO)
			EndIf
		EndIf
	EndIf
Endif

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Finaliza a gravacao dos lancamentos do SIGAPCO            ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
PcoFinLan("000051")
PcoFreeBlq("000051")

Return Nil

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³A650GravC7³ Autor ³ Marcos Bregantim      ³ Data ³ 29.04.96 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Grava Autorizacao de Entrega                               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ A650GravC7(ExpC1,ExpN1,ExpC2,ExpD1)                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Codigo do produto                                  ³±±
±±³          ³ ExpN1 = Quantidade da SC                                   ³±±
±±³          ³ ExpC2 = Numero da OP geradora                              ³±±
±±³          ³ ExpD1 = Data de entrega da SC                              ³±±
±±³          ³ ExpC3 = Campo para atualizar projacao de estoques          ³±±
±±³          ³ ExpN2 = Indicador para Projecao de Estoques                ³±±
±±³          ³ ExpN3 = Quantidade para Projecao de Estoques               ³±±
±±³          ³ ExpC4 = Tipo da Ordem de Producao                          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ MATA650                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
*/
Function A650GravC7(cProduto,nQuant,cOp,dEntrega,cCpoProj,cTpOp,cPedido,cItemPed)
Local cNumSolic := ""
Local cItem		:= ""
Local lProj		:= .F.
Local aCampos 	:= {}
Local cFilSC7 := xFilial("SC7")

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Posiciona no produto correto.                              ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
SB1->(dbSetOrder(1))
SB1->(MsSeek(xFilial("SB1")+cProduto))

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Verifica se a rotina esta sendo chamada da Proj.Estoques   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If cCpoProj != NIL
	lProj := .T.
endif

dbSelectArea("SC7")
If !INCLUI
	dbSetOrder(8)
	If dbSeek(cFilSC7+cOp) .And. !lProj .And. !lProj711 .And. !Empty(cOp)
		While !EOF() .And. C7_FILIAL+C7_OP == cFilSC7+cOp
			If C7_PRODUTO == cProduto
				Exit
			EndIf
			dbSkip()
		EndDo
		If !EOF() .And. C7_FILIAL+C7_OP+C7_PRODUTO == cFilSC7+cOp+cProduto
			dbSelectArea("SB2")
			GravaB2Pre("-",SC7->C7_QUANT,SC7->C7_TPOP,SC7->C7_QTSEGUM)
			dbSelectArea("SC7")
			cNumSolic := C7_NUM
			cItem     := C7_ITEM
		Else
			cNumSolic := GetNumSc7(.T.)
			If Empty(cNumSolic)
				cNumSolic := ProximoNum("SC7")
			Endif
			cItem := StrZero(1,Len(SC7->C7_ITEM))
		EndIf
	Else
		cNumSolic := GetNumSc7(.T.)
		If Empty(cNumSolic)
			cNumSolic := ProximoNum("SC7")
		Endif
		cItem := StrZero(1,Len(SC7->C7_ITEM))
	Endif

	aAdd(aCampos,{"NUM",cNumSolic})
	aAdd(aCampos,{"ITEM",cItem})
Endif


aAdd(aCampos,{"DATPRF",If(lProj.Or.lProj711,aPeriodos[Val(a650DtoPer(dEntrega))],dEntrega)})
aAdd(aCampos,{"TPOP",If(lProj711 .And. Type('lDiasHf') == "L" .And. lDiasHf,A710VerHf(aCampos[Len(aCampos),2],cProduto),cTpOp)})
aAdd(aCampos,{"OP",cOP})
aAdd(aCampos,{"USER",   RetCodUsr( )})

MatGeraAE(cProduto,nQuant,aCampos,If(lProj .Or. lProj711,if( lMata712, "MATA712", "MATA710"),"MATA650"),cPedido,cItemPed)

RETURN NIL

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³ProximoNum³ Autor ³ Eveli Morasco         ³ Data ³ 22/10/92 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Pega o proximo numero e item disponiveis no SC1            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ ExpC1:=ProximoNum(ExpC2)                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Proximo Numero                                     ³±±
±±³          ³ ExpC2 = Alias a ser incrementado (SC1/SC7)                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA650                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function ProximoNum(cAlias)
Local cNumSolic
dbSelectArea(cAlias)
dbSetOrder(1)
dbSeek(xFilial(cAlias)+"z",.T.)
dbSkip(-1)
If &(Substr(cAlias,2,2)+"_FILIAL") == xFilial(cAlias)
	cNumSolic := StrZero(Val(&(Substr(cAlias,2,2)+"_NUM"))+1,6)
Else
	cNumSolic := "000001"
EndIf
RETURN cNumSolic

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³A650IniCpo³ Autor ³ Claudinei M. Benzi    ³ Data ³ 07/01/92 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Rotina p/ inicializacao de alguns campos a partir do Prod. ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA650                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function A650IniCpo()
Local cProdMnt  := SuperGetMV("MV_PRODMNT",.F.," ")
Local nEndereco	:= 0
Local lIntQIP   := IntQIP(M->C2_PRODUTO,,IIf(cModulo=="QIP","E","T"))
Local lRet      := .T.
Local lContinua := .T.
Local lBLOESP   := If(SuperGetMV("MV_QBLOESP",.F.,"2") == "2",.F.,.T.)//Devido a integracao do PCP com o QIP, bloqueia se nao tiver Especifacao. 1 = Sim/ 2 =Nao
Local lIntQIPMAT:= If(SuperGetMV("MV_QIPMAT",.F.,"N")=="N",.F.,.T.)//Integracao do QIP com Materiais
Local lMT650QIP :=  If(ExistBlock("MT650QIP"),ExecBlock("MT650QIP",.F.,.F.),.T.)//ponto de entrada para validar ou nao a integracao com SIGAQIP
Local nTipoVld	:= 2

If ValType(lMT650QIP) # "L"
	lMT650QIP := .T.
EndIf

//--------------------------------------------------------//
//Alterar o conteudo da variavel 						     //
// Caso seja um produto previsto no manutenção de Ativos //
//-------------------------------------------------------//
If (ALLTRIM(cProdMnt) == ALLTRIM(M->C2_PRODUTO)) .And. (lIntQIP .or. lIntQIPMAT)
	lBLOESP := .F.
EndIF

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Verifica se o usuario tem permissao para incluir produto ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

If !(lRet := MaAvalPerm(1,{M->C2_PRODUTO,"MTA650",3}))
	Help(,,1,'SEMPERM')
EndIf

If lRet .And. (lRet := MatGrdPrrf(M->C2_PRODUTO) .Or. ExistCpo("SB1",M->C2_PRODUTO))

	dbSelectArea("SB1")
	dbSetOrder(1)
	MsSeek(xFilial("SB1")+M->C2_PRODUTO)
	IF !Found()
		lContinua := .F.
	EndIf
	IF lContinua .And. RetFldProd(SB1->B1_COD,"B1_FANTASM") == "S"  // Projeto Implementeacao de campos MRP e FANTASM no SBZ
		HELP(" ",1,"A650FANT")
		lContinua	:= .F.
		lRet		:= .F.
	Endif
	If lContinua .And. IsProdProt(M->C2_PRODUTO) .And. !IsInCallStack("DPRA340INT")
		Aviso(STR0024,STR0160,{"OK"}) //-- Protótipos podem ser manipulados somente através do módulo Desenvolvedor de Produtos (DPR).
		lContinua	:= .F.
		lRet		:= .F.
	EndIf

	If lContinua
		M->C2_LOCAL := RetFldProd(SB1->B1_COD,"B1_LOCPAD")
		nEndereco := Ascan(aGets,{ |x| Subs(x,9,8) == "C2_LOCAL" } )
		If nEndereco > 0
			aTela[Val(Subs(aGets[nEndereco],1,2))][Val(Subs(aGets[nEndereco],3,1))*2] := RetFldProd(SB1->B1_COD,"B1_LOCPAD")
		EndIf

		M->C2_CC := SB1->B1_CC
		nEndereco := Ascan(aGets,{ |x| Subs(x,9,5) == "C2_CC" } )
		If nEndereco > 0
			aTela[Val(Subs(aGets[nEndereco],1,2))][Val(Subs(aGets[nEndereco],3,1))*2] := SB1->B1_CC
		EndIf

		M->C2_UM := SB1->B1_UM
		nEndereco := Ascan(aGets,{ |x| Subs(x,9,5) == "C2_UM" } )
		If nEndereco > 0
			aTela[Val(Subs(aGets[nEndereco],1,2))][Val(Subs(aGets[nEndereco],3,1))*2] := SB1->B1_UM
		EndIf

		M->C2_SEGUM := SB1->B1_SEGUM
		nEndereco := Ascan(aGets,{ |x| Subs(x,9,5) == "C2_SEGUM" } )
		If nEndereco > 0
			aTela[Val(Subs(aGets[nEndereco],1,2))][Val(Subs(aGets[nEndereco],3,1))*2] := SB1->B1_SEGUM
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Execblock a ser executado para verificar a validacao         ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		IF (ExistBlock('MA650VLD'))
			nTipoVld := ExecBlock('MA650VLD',.F.,.F.)
			If ValType(nTipoVld) <> "N" .Or. (nTipoVld <> 1 .And. nTipoVld <> 2)
				nTipoVld:=1
			EndIf
		Endif
		If nTipoVld == 1 .Or. Empty(M->C2_SEQUEN)
			M->C2_SEQUEN := "001"
		EndIf
		nEndereco := Ascan(aGets,{ |x| Subs(x,9,9) == "C2_SEQUEN" } )
		If nEndereco > 0
			aTela[Val(Subs(aGets[nEndereco],1,2))][Val(Subs(aGets[nEndereco],3,1))*2] := M->C2_SEQUEN
		EndIf

		nEndereco := Ascan(aGets,{ |x| Subs(x,9,8) == "C2_PRIOR" } )
		If nEndereco > 0
			M->C2_PRIOR := "500"
			aTela[Val(Subs(aGets[nEndereco],1,2))][Val(Subs(aGets[nEndereco],3,1))*2] := "500"
		EndIf

		nEndereco := Ascan(aGets,{ |x| Subs(x,9,10) == "C2_REVISAO" } )
		If nEndereco > 0
			M->C2_REVISAO := IIF(lPCPREVATU , PCPREVATU(SB1->B1_COD), SB1->B1_REVATU )/*SB1->B1_REVATU*/
			If !PCPVldRev(SB1->B1_COD, M->C2_REVISAO)
				M->C2_REVISAO := '   '
			EndIf
			aTela[Val(Subs(aGets[nEndereco],1,2))][Val(Subs(aGets[nEndereco],3,1))*2] := M->C2_REVISAO
		EndIf

		If lIntQIP .And. lMT650QIP//Define se o produto esta definido na QP6

			//Compara posicionada com valor da memória para saber se o produto foi trocado e revalidar
			If !l650Auto .And. SC2->C2_PRODUTO <> M->C2_PRODUTO
				lMt650RevDis := .F.
			EndIf

			M->C2_ROTEIRO := A650VldRot(M->C2_PRODUTO,SB1->B1_OPERPAD)

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Verifica se o Produto possui ensaios.³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If QIPValEns(M->C2_PRODUTO, M->C2_REVI, M->C2_ROTEIRO)
				nEndereco := Ascan(aGets,{|x|SubStr(x,9,9)=="C2_ROTEIRO"})
				If nEndereco > 0
					aTela[Val(Subs(aGets[nEndereco],1,2))][Val(Subs(aGets[nEndereco],3,1))*2] := M->C2_ROTEIRO
				EndIf
			ElseIf lBLOESP
				lContinua	:= .F.
				lRet		:= .F.
			Endif
		Else
			If lIntQIPMAT .And. lMT650QIP //.And. SB1->B1_NUMCQPR <> 0 //necessario para não exibir a msg qdo nao houver integracao
				M->C2_ROTEIRO := A650VldRot(M->C2_PRODUTO,SB1->B1_OPERPAD)

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Verifica se o Produto possui ensaios.³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If !Empty(AllTrim(M->C2_ROTEIRO))
					If !QIPValEns(M->C2_PRODUTO, M->C2_REVI, M->C2_ROTEIRO)
						If lQIPOPEPQP
							If QIPOPEPQPK(M->C2_PRODUTO, M->C2_REVI, M->C2_ROTEIRO, !l650Auto .Or. lBLOESP, .F.) .AND. lBLOESP
								lContinua	:= .F.
								lRet		:= .F.
							Endif
						Else
							If lBLOESP
								lContinua	:= .F.
								lRet		:= .F.
							Endif
							If !l650Auto .Or. !lRet
								Help(" ",1,"C650NOREV")//"Nao existe especificação para esse Produto/Roteiro."
							EndIf
						EndIf
					Endif
				Else
					If lQIPOPEPQP
						If QIPOPEPQPK(M->C2_PRODUTO, M->C2_REVI, M->C2_ROTEIRO, !l650Auto, .F.) .AND. lBLOESP
							lContinua	:= .F.
							lRet		:= .F.
						Endif
					Else
						If lBLOESP
							lContinua	:= .F.
							lRet		:= .F.
						Endif
						If !l650Auto
							Help(" ",1,"C650NOREV")//"Nao existe especificação para esse Produto/Roteiro."
						EndIf
					EndIf
				Endif
			Else
				M->C2_ROTEIRO := SB1->B1_OPERPAD
			Endif
		EndIf
	EndIf
EndIf
RETURN lRet

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³ A650DtoPer ³ Autor ³ Ary Medeiros        ³ Data ³ 25/08/92 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Retorna o Periodo da projecao correspondente a uma data    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ ExpC1 := A650DtoPer(ExpD2,ExpA1,ExpN1)                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 := String com o numero do periodo Ex. "01"           ³±±
±±³          ³ ExpD2 := Data a ser convertida                             ³±±
±±³          ³ ExpA1 := Array com periodos (utilizado em job)             ³±±
±±³          ³ ExpN1 := Tipo de calculo (utilizado em job)                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA710  e MATA650                                         ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function A650DtoPer(dData,aParPeriodos,nParTipo,cProduto,nQuant)
Local i, cRet, dFimProj
Local nSomaDia	:= 0
Default cProduto := ""

//If !Empty( cProduto )
//	nPrazo := CalcPrazo(cProduto,nQuant,,,.F.,dData)
//Endif

If ValType(aParPeriodos) == "A"
	aPeriodos:=ACLONE(aParPeriodos)
EndIf

If ValType(nParTipo) == "N"
	nTipo:=nParTipo
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³dFimProj - Data limite para ultimo periodo -> Len(aperiodos) + 1³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If Len(aPeriodos) > 1 .And. nTipo # 1 .And. nTipo # 7 .And. nTipo # 2 .And. nTipo # 3
	IF nTipo == 4
		dFimProj := LastDay(aPeriodos[Len(aPeriodos)])
	Else
		dFimProj := aPeriodos[Len(aPeriodos)] + (aPeriodos[Len(aPeriodos)] - aPeriodos[Len(aPeriodos)-1])
	Endif

	If nTipo == 4 .And. Month(dFimProj-30)==2
		nSomaDia := 30- Day(CTOD("01/03/"+Substr(Str(Year(aPeriodos[Len(aPeriodos)-1]),4),3,2))-1)
		dFimProj := aPeriodos[Len(aPeriodos)] + (aPeriodos[Len(aPeriodos)] - aPeriodos[Len(aPeriodos)-1])+nSomaDia
	EndIf
Else
	If nTipo == 1 .or. nTipo == 7		// Projecao Diaria ou Periodos Variaveis
		dFimProj := aPeriodos[Len(aPeriodos)]
	ElseIf nTipo == 2	// Projecao Semanal
		dFimProj := aPeriodos[Len(aPeriodos)] + 6
	ElseIf nTipo == 3	// Projecao Quinzenal
		dFimProj := CtoD(If(Substr(DtoC(aPeriodos[Len(aPeriodos)]),1,2)="01","15"+Substr(DtoC(aPeriodos[Len(aPeriodos)]),3,6),;
			"01/"+If(Month(aPeriodos[Len(aPeriodos)])+1<=12,StrZero(Month(aPeriodos[Len(aPeriodos)])+1,2)+"/"+;
			SubStr(DtoC(aPeriodos[Len(aPeriodos)]),7,4),"01/"+Substr(Str(Year(aPeriodos[Len(aPeriodos)])+1,4),3,2))),"ddmmyy")
	ElseIf nTipo == 4	// Projecao Mensal
		dFimProj := CtoD("01/"+If(Month(aPeriodos[Len(aPeriodos)])+1<=12,StrZero(Month(aPeriodos[Len(aPeriodos)])+1,2)+;
			"/"+Substr(Str(Year(aPeriodos[Len(aPeriodos)]),4),3,2),"01/"+Substr(Str(Year(aPeriodos[Len(aPeriodos)])+1,4),3,2)),"ddmmyy")
		dFimProj := dFimProj - 1
	ElseIf nTipo == 5	// Projecao Trimestral
		dFimProj := CtoD("01/"+If(Month(aPeriodos[Len(aPeriodos)])+3<=12,StrZero(Month(aPeriodos[Len(aPeriodos)])+3,2)+;
			"/"+Substr(Str(Year(aPeriodos[Len(aPeriodos)]),4),3,2),"01/"+Substr(Str(Year(aPeriodos[Len(aPeriodos)])+1,4),3,2)),"ddmmyy")
		dFimProj := dFimProj - 1
	ElseIf nTipo == 6	// Projecao Semestral
		dFimProj := CtoD("01/"+If(Month(aPeriodos[Len(aPeriodos)])+6<=12,StrZero(Month(aPeriodos[Len(aPeriodos)])+6,2)+;
			"/"+Substr(Str(Year(aPeriodos[Len(aPeriodos)]),4),3,2),"01/"+Substr(Str(Year(aPeriodos[Len(aPeriodos)])+1,4),3,2)),"ddmmyy")
		dFimProj := dFimProj - 1
	EndIf
EndIf

//If nTipo == 4 .And. !( Upper(ProcName(1)) $ "MTA711SH5/A711CRISH5/MATA712INP/A712CRICZI" )	//Mensal
//	cRet := "001"
//	For i:=1 To Len(aPeriodos)
//		If dData < aPeriodos[i]
//			cRet := StrZero(i,3)
//			Exit
//		Endif
//	Next
//Else
	If dData <= aPeriodos[1]
		cRet := "001"
	EndIf
	If Len(aPeriodos) >= 2 .And. Empty(cRet)
		For i:= 2 To Len(aPeriodos)
		//--Verifica se a data esta entre o periodo atual e o periodo anterior, devendo assumir o periodo anterior.
			If dData < aPeriodos[i] .And. dData >= aPeriodos[i-1]
				cRet := StrZero(i-1,3)
				Exit
			EndIf
		Next
	EndIf
// Endif

If dData >= aPeriodos[Len(aPeriodos)] .And. dData <= dFimProj
	cRet := StrZero(Len(aPeriodos),3)
ElseIf dData > dFimProj
	cRet := ""
EndIf

//Tratamento para geracao de OP's e SC's via MATA711, onde o periodo tem apenas 2 posicoes
If FunName() = "MATA711"
	cRet := Right(cRet,2)
EndIf

RETURN cRet

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³A650WriteOp ³ Autor ³ Ary Medeiros        ³ Data ³ 10/09/93 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descricao ³ Gera OP's intermedi rias e solicita‡”es de compra          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA650                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function A650WriteOp(lProj,aX,cCpoProj,cTpOp)
Local aQtdes:={},nX,nRegSb2
Local nPrazo			// Prazo de Entrega (Lead Time)
Local dDataIni,dDataFim	// Data Prevista Inicio / Fim
Local dDataAjus			// Data Ajustada Inicio
Local cProduto,nQtde, nQtde2UM,cOpcionais
Local nz  := 0
Local lOne:=.F.
Local lEstMax     := If(Type('lProj711')=='L',lProj711,.F.) .And. aPergs711[19] == 2 .And. aPergs711[1] == 1
Local nLoop		  := 0
Local cOP         := ""
Local dEntrega
Local nQuant      := 0
Local nNecessid   := 0
Local nAchou      := 0
Local dDataQuebr
Local nLastRecno
Local aOPInt      := {} // Vetor para armazenar as OP's intermediarias
Local aFornecedor := {}
Local nPrc        := 0
Local aDocs       := {}
Local aResultados := {}
Local aDatasNec   := {}
Local aCampos     := {}

Local aAreaC2 := {}

Local lDelTBMRP  := _lNewMRP == NIL
Local lIntNewMRP := Iif(_lNewMRP  == Nil, FindFunction("Ma650MrpOn") .AND. Ma650MrpOn(@_lNewMRP),_lNewMRP)
Local aMRPxJson  := Iif(lIntNewMRP, {{}, JsonObject():New()}, Nil) //{aDados para commit, JsonObject() com RECNOS} - Integracao Novo MRP - APONTAMENTOS

Private lAtuNec := .F.
Private aLotesUsado := {}

cObs	   := SC2->C2_OBS
nQtde	   := SC2->C2_QUANT
nQtde2UM   := SC2->C2_QTSEGUM
cLocal     := SC2->C2_LOCAL
cNumOp	   := SC2->C2_NUM
cItemOp	   := SC2->C2_ITEM
cItemGrd   := SC2->C2_ITEMGRD
cProduto   := SC2->C2_PRODUTO
cGrade     := SC2->C2_GRADE
cStatus    := SC2->C2_STATUS
cRoteiro   := A650VldRot(SC2->C2_PRODUTO,SC2->C2_ROTEIRO)

IF ! lMopcGRV
    cOpcionais := Iif(Empty(SC2->C2_MOPC),SC2->C2_OPC,SC2->C2_MOPC)
Else
    cMopc := ""

    If !Empty(SC2->C2_SEQPAI) .AND. (SC2->C2_SEQPAI) <> '000'
		aAreaC2 := SC2->(GetArea())
		SC2->(DbSetOrder(1))
		If dbSeek(xFilial("SC2")+SC2->C2_NUM+SC2->C2_ITEM)
			cMopc := SC2->C2_MOPC
		EndIf
		SC2->(RestArea(aAreaC2))
	Else
		cMopc := SC2->C2_MOPC
	EndIf

	cOpcionais := Iif(Empty(cMopc),SC2->C2_OPC,cMopc)
endif

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Verifica se a rotina esta sendo chamada da Proj.Estoques NOVA ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
lProj711:=If(Type("lProj711") == "L",lProj711,.F.)

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Envia para rotina de Montagem da Estrutura                   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If cCpoProj != NIL .And. cCpoProj # "INICIO"
	aQtdes := CalcLote(cProduto,nQtde,"F")
	If lEstMax
		aQtdes := A711LotMax(cProduto, A650SldMRP(.T.,.F.,cProduto,aPeriodos[Val(cCpoProj)],cOpcionais), nQtde, aQtdes)
	EndIf
Else
	AADD(aQtdes,nQtde)
EndIf

nPrazo := CalcPrazo(cProduto,aQtdes[1],,,.T.,SC2->C2_DATPRI)

If cCpoProj != NIL
	dbSelectArea("SC2")
	RecLock("SC2",.F.)
	Replace C2_QUANT With aQtdes[1]
	Replace C2_QTSEGUM With ConvUm(cProduto,aQtdes[1],nQtde2UM,2)
	MsUnLock()
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//| Caso nao exista cria array que registra todos os niveis da estrutura    |
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If Type("aRetorOpc") <> "A"
	aRetorOpc:={}
EndIf

// Indica se permite repeir o mesmo grupo de opcionais em varios niveis ou nao
//If GetNewPar("MV_REPGOPC","N") == "S"

	If !Empty(IIF(lMopcGRV,cMopc,SC2->C2_MOPC))
		aRetorOpc:=STR2Array(IIF(lMopcGRV,cMopc,SC2->C2_MOPC),.F.)
		If aRetorOpc == Nil
			aRetorOpc := {}
		EndIf
	EndIf

//EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Atualiza Campo Necessidade da Projecao de Estoques             ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lProj .And. cCpoProj != "INICIO"
	dbSelectArea("SH5")
	If dbSeek(xFilial("SH5")+SG1->G1_NIV+cProduto+"2")
		RecLock("SH5",.F.)
		Replace &(cCpoProj) with &(cCpoProj)+aQtdes[1]
	EndIf
	If dbSeek(xFilial("SH5")+SG1->G1_NIV+cProduto+"5")
		RecLock("SH5",.F.)
		Replace &(cCpoProj) with &(cCpoProj)-aQtdes[1]
		If &(cCpoProj) < .005
			Replace &(cCpoProj) with 0
		EndIf
	EndIf
	If nPar10 == 1
		lOne:=.T.
	EndIf
ElseIf lProj711 .And. !lMata712 .And. !lPCPA107
	A711CriSH5(SC2->C2_DATPRF,SC2->C2_PRODUTO,SC2->C2_OPC,SC2->C2_REVISAO,"SC2",SC2->(Recno()),SC2->(C2_NUM+C2_ITEM+C2_SEQUEN+C2_ITEMGRD),"",If(!Empty(SC2->C2_PEDIDO),SC2->C2_PEDIDO+"/"+SC2->C2_ITEMPV,""),Max(0,SC2->(C2_QUANT-C2_QUJE)),"2",.T.,NIL,NIL,.T.)
	If aPergs711[16] == 1
		lOne:=.T.
	EndIf
ElseIf lMata712
	A712CriCZI(SC2->C2_DATPRF,SC2->C2_PRODUTO,SC2->C2_OPC,SC2->C2_REVISAO,"SC2",SC2->(Recno()),SC2->(C2_NUM+C2_ITEM+C2_SEQUEN+C2_ITEMGRD),/*08*/,If(!Empty(SC2->C2_PEDIDO),SC2->C2_PEDIDO+"/"+SC2->C2_ITEMPV,""),Max(0,SC2->(C2_QUANT-C2_QUJE)),"2",.T.,/*13*/,/*14*/,.T.,/*16*/,/*17*/,/*18*/,/*19*/,/*20*/,/*21*/,/*22*/,/*23*/,/*24*/,IIF(lMopcGRV,cMopc,SC2->C2_MOPC),/*26*/)
	If aPergs711[16] == 1
		lOne:=.T.
	EndIf
ElseIf lPCPA107
	lAtuNec := .T.
	A107CriSOQ(SC2->C2_DATPRF,SC2->C2_PRODUTO,SC2->C2_OPC,SC2->C2_REVISAO,"SC2",SC2->(Recno()),SC2->(C2_NUM+C2_ITEM+C2_SEQUEN+C2_ITEMGRD),/*08*/,If(!Empty(SC2->C2_PEDIDO),SC2->C2_PEDIDO+"/"+SC2->C2_ITEMPV,""),Max(0,SC2->(C2_QUANT-C2_QUJE)),"2",.T.,/*13*/,/*14*/,.T.,/*16*/,/*17*/,/*18*/,/*19*/,/*20*/,/*21*/,/*22*/,/*23*/,/*24*/,IIF(lMopcGRV,cMopc,SC2->C2_MOPC),/*26*/)
	lAtuNec := .F.
	A107CriSOU('OP',Iif(cProd107==SC2->C2_PRODUTO,nRec107,0), lPmp107, SC2->C2_NUM, SC2->C2_SEQUEN, SC2->C2_ITEM, SC2->C2_ITEMGRD, SC2->C2_QUANT, cPeri107, SC2->C2_DATPRF, SC2->C2_PRODUTO)
	If aPergs711[16] == 1
		lOne:=.T.
	EndIf
EndIf

dbSelectArea("SC2")

If aX
	RecLock("SC2",.F.)
	Replace C2_DATPRF With SomaPrazo(C2_DATPRI, nPrazo)
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Datas de referencia para geracao das OP's intermediarias       ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
dDataFim := C2_DATPRF
dDataIni := C2_DATPRI
dDataAjus:= C2_DATAJI

dbSelectArea("SB2")
dbSetOrder(1)
If !MsSeek(xFilial("SB2")+cProduto+SC2->C2_LOCAL)
	CriaSB2(cProduto,SC2->C2_LOCAL)
	MsUnlock()
EndIf
GravaB2Pre("+",SC2->C2_QUANT,SC2->C2_TPOP,SC2->C2_QTSEGUM)
nRegSb2 := RecNo()

For nX := 1 To Len(aQtdes)
	If nX > 1
		cSeqC2:=Soma1(cSeqC2,Len(SC2->C2_SEQUEN))
		A650GeraC2(cProduto,aQtdes[nX],dDataIni,dDataFim,dDataAjus,cCpoProj,,,.F.,,SC2->C2_LOCAL,IIf(Empty(IIF(lMopcGRV,cMopc,SC2->C2_MOPC)),SC2->C2_OPC,IIF(lMopcGRV,cMopc,SC2->C2_MOPC)),cTpOp,SC2->C2_REVISAO,nQtde2UM,cNumOp,cItemOp,@cSeqC2,cRoteiro,cObs,SC2->C2_OPC,@aMRPxJson)
		AADD(aOPInt, {SC2->C2_PRODUTO, SC2->C2_NUM+SC2->C2_ITEM+SC2->C2_SEQUEN+SC2->C2_ITEMGRD, (SC2->C2_QUANT - aQtdes[nX]) } )
	EndIf
	MsUnlock()
	SB2->(DBCLOSEAREA())

	cOpc := IIf(Empty(IIF(lMopcGRV,cMopc,SC2->C2_MOPC)),SC2->C2_OPC,IIF(lMopcGRV,cMopc,SC2->C2_MOPC))

	MontEstru(cProduto,aQtdes[nX],SC2->C2_DATPRI,cCpoProj,cSeqC2,SC2->C2_PRIOR,NIL,cOpc,lOne,cTpOp,SC2->C2_REVISAO,cProduto,@aOPInt,cProduto,@aMRPxJson,aRetorOpc)
	dbSelectArea("SB2")
	dbGoTo(nRegSb2)
Next nX

//Integração de ordens de produção com o novo MRP. Inclusão/Alteração de ordens
If lIntNewMRP
	enviaOpMrp("INSERT", @aMRPxJson, lDelTBMRP)
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Gera SC's aglutinadas por OP.                                ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If mv_par06 == 2
	For nz := 1 to Len(aOPC7)
		aQtdes := CalcLote(aOPC7[nz,1],aOPC7[nz,7],"C")
		nQuant := 0
		aEval(aQtdes,{|x| nQuant+=x})
		// ---- Acerta quantidades do Contrato de Parceria (SC3)
		If aOPC7[nz,7] < nQuant
			cProduto := aOPC7[nz,1]
			cOp      := aOPC7[nz,3]
			dEntrega := aOPC7[nz,4]
			If (nNecessid := (nQuant - aOPC7[nz,7])) > 0
				aOPC7[nz,2] += nNecessid
			EndIf
		EndIf
		If lMata712
			If aOPC7[nz,2] == aOPC7[nz,7]
				A650GravC7(aOPC7[nz,1],aOPC7[nz,2],aOPC7[nz,3],aOPC7[nz,4],aOPC7[nz,5],aOPC7[nz,6])
			Else
				A650GravC7(aOPC7[nz,1],aOPC7[nz,2]," ",aOPC7[nz,4],aOPC7[nz,5],aOPC7[nz,6])
			EndIf
		Else
			//aFornecedor:= COMPESQFOR(aOPC7[nz,1]) //-- Retorna codigo e loja do fornecedor
			aFornecedor := aPesqFor(aOPC7[nz,1]) //-- Retorna codigo e loja do fornecedor padrão
			nPrc:= COMPESQPRECO(aOPC7[nz,1],cFilAnt,aFornecedor[1],aFornecedor[2])
			aCampos := {}
			Aadd(aDatasNec,aOPC7[nz,4])
			aadd(aCampos,{"DATPRF",aOPC7[nz,4]})
			aadd(aCampos,{"TPOP",aOPC7[nz,6]})
			If Type('lProj711') == "L" .And. lProj711
				aadd(aCampos,{"SEQMRP",c711NumMRP})
			EndIf

			If aOPC7[nz,2] == aOPC7[nz,7]
				aadd(aCampos,{"OP",aOPC7[nz,3]})
				Aadd(aDocs,{aOPC7[nz,1],aOPC7[nz,2],cFilAnt,cFilAnt,"1",aFornecedor[1],aFornecedor[2],,nPrc,{},aOPC7[nz,3],"",aCampos})
			Else
				Aadd(aDocs,{aOPC7[nz,1],aOPC7[nz,2],cFilAnt,cFilAnt,"1",aFornecedor[1],aFornecedor[2],,nPrc,{}," ","",aCampos})
			EndIf

		EndIf
	Next nz
	For nz := 1 to Len(aOPC1)
		cProduto := aOPC1[nz,1]
		nQuant   := aOPC1[nz,2]
		nAchou:=ASCAN(aOpC7,{|x| x[1] == cProduto .And. x[8] == cTpOp})
		If nAchou == 0
			aQtdes := CalcLote(aOPC1[nz,1],aOPC1[nz,2],"C")
			nQuant := 0
			aEval(aQtdes,{|x| nQuant+=x})
		EndIf
		If lMata712
			If nQuant == aOPC1[nz,7]
				A650GravC1(aOPC1[nz,1],nQuant,aOPC1[nz,3],aOPC1[nz,4],aOPC1[nz,5],;
				aOPC1[nz,6],aOPC1[nz,7],aOPC1[nz,8],aOPC1[nz,9],aOPC1[nz,10],aOPC1[nz,11],aOPC1[nz,12],,,,{},@dDataQuebr,@nLastRecno)
			Else
				A650GravC1(aOPC1[nz,1],nQuant," ",aOPC1[nz,4],aOPC1[nz,5],;
				aOPC1[nz,6],aOPC1[nz,7],aOPC1[nz,8],aOPC1[nz,9],aOPC1[nz,10],aOPC1[nz,11],aOPC1[nz,12],,,,{},@dDataQuebr,@nLastRecno)
			EndIf
		Else
			//aFornecedor:= COMPESQFOR(aOPC1[nz,1]) //-- Retorna codigo e loja do fornecedor
			aFornecedor := aPesqFor(aOPC1[nz,1]) //-- Retorna codigo e loja do fornecedor padrão
			nPrc:= COMPESQPRECO(aOPC1[nz,1],cFilAnt,aFornecedor[1],aFornecedor[2])
			aCampos := {}
			Aadd(aDatasNec,aOPC1[nz,4])
			aadd(aCampos,{"DATPRF",aOPC1[nz,4]})
			aadd(aCampos,{"TPOP",aOPC1[nz,11]})
			If Type('lProj711') == "L" .And. lProj711
				aadd(aCampos,{"SEQMRP",c711NumMRP})
			EndIf
			If nQuant == aOPC1[nz,7]
				aadd(aCampos,{"OP",aOPC1[nz,3]})
				Aadd(aDocs,{aOPC1[nz,1],aOPC1[nz,2],cFilAnt,cFilAnt,"1",aFornecedor[1],aFornecedor[2],,nPrc,{},aOPC1[nz,3],"",aCampos})
			Else
				Aadd(aDocs,{aOPC1[nz,1],aOPC1[nz,2],cFilAnt,cFilAnt,"1",aFornecedor[1],aFornecedor[2],,nPrc,{}," ","",aCampos})
			EndIf
		EndIf
	Next nz
	If !Empty(aDocs)
		aResultados:= ComGeraDoc(aDocs,.T.,.F.,.T.,.F.,ComDtNeces(aDatasNec),"MATA650"  ,/*lEnviaEmail*/,1  )
		a650TabMRP(aResultados)
		If ExistBlock("MT650C1")
			For nLoop := 1 To Len( aResultados )
				Do Case
					//--Tipo de documento gerado pela biblioteca de compras
					Case aResultados[nLoop,1,3] == "1" //-- Solicitação de Compras
						SC1->(dbSetOrder(1)) //-- C1_FILIAL+C1_NUM+C1_ITEM+C1_ITEMGRD
						If SC1->(dbSeek(aResultados[nLoop,1,1]+aResultados[nLoop,1,2]))
							Execblock("MT650C1",.F.,.F.,{"SC1",SC1->C1_NUM,SC1->C1_ITEM,SC1->(Recno())})
						EndIf
				EndCase
			Next nLoop
		EndIf
	EndIf
	aOPC1:={}
	aOPC7:={}
	aOPC7Local:={}
EndIf
Return
/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³A650PutBatch³ Autor ³ Ary Medeiros        ³ Data ³ 10/09/93 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descricao ³ Coloca OP na fila para geracao em Batch                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA650                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function A650PutBatch(cOp,lOrcamento,dDataPrIni,dDataPrFim)

Local cAlias := Alias()

Default lOrcamento := .F.
Default dDataPrIni := dDataBase
Default dDataPrFim := dDataBase
Default l650Auto   := .F.

DbSelectArea("SC2")
Reclock("SC2",.f.)
Replace C2_BATORCA With If(lOrcamento,"S","N")
Replace C2_BATROT  With FunName()
If Empty(SC2->C2_BATUSR) .or. !l650Auto
	Replace C2_BATUSR  With RetCodUsr()
EndIf
MsUnLock()
dbSelectArea(cAlias)
RETURN NIL

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³A650RunBatch³ Autor ³ Ary Medeiros        ³ Data ³ 10/09/93 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descricao ³ Executa geracao de OP's intermediarias em batch            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA650                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function A650RunBatch(nOps,lOrcamento,cCodUsr)
Local aAreaAnt := GetArea()
Local aAreaSC2 := SC2->(GetArea())
Local lControlUser:=.F.
Local nZ         := 0
Local cFuncOri   := AllTrim(Left(FunName(),20))
Local dDataQuebr
Local nLastRecno
Local aFornecedor	:= {}
Local nPrc	       := 0
Local aDocs		:= {}
Local aResultados	:= {}
Local aDatasNec	:= {}
Local cAliasTop	:= GetNextAlias()
Local nLoop		  := 0
Local aCampos		:= {}
Local lAuto       := Type("l650Auto") == "L" .And. l650Auto
Local lMTA650GEM  := ExistBlock("MTA650GEM")
Local cFilSC2 := xFilial("SC2")
Local cBanco  := Upper(TcGetDb())
Local nx
Local nDt
Local nPosDT  := 2

//Se a função é chamada do MATA760, não passa pela declaração da variável aRotProd
If IsInCallStack('MATA760')
	Private aRotProd := {}
	PRIVATE aAltSaldo := {}
EndIf

Private cSeqC2 , cNumOp, cItemOp , cLocal

dbSelectArea("SC2")

Default cCodUsr  := RetCodUsr()

lOrcamento := If(lOrcamento == NIL, .F. , lOrcamento )

If Type("l650Auto") # "L" .or. !l650Auto
	ProcRegua(nOps)
EndIf

//--Libera os registros filtrados.
SC2->(DbClearFil())
RetIndex("SC2")
Inclui := .T.
lControlUser:= (GetNewPar("MV_EXPLOPU","N") == "S")

cQuery := " SELECT SC2.R_E_C_N_O_ C2REC "
cQuery += " FROM " + RetSqlName("SC2") + " SC2 "

cQuery += "LEFT JOIN  (SELECT D4_FILIAL, D4_OP, COUNT(*) AS LINHAS FROM " + RetSQLNAME('SD4') + " SD4 "
cQuery += "WHERE D_E_L_E_T_ = ' ' GROUP BY D4_FILIAL, D4_OP) SD4 ON "
cQuery += " (SD4.D4_FILIAL = '"+ cFilSC2 + "' AND SD4.D4_OP = SC2.C2_NUM + SC2.C2_ITEM + SC2.C2_SEQUEN + SC2.C2_ITEMGRD) "

cQuery += " WHERE SC2.C2_FILIAL = '" + cFilSC2 + "' "
cQuery +=   " AND (SC2.C2_BATCH = ' ' "
cQuery +=   "  OR  SC2.C2_BATCH IS NULL) "
cQuery +=   " AND SC2.C2_BATROT <> ' ' "
cQuery +=   " AND SC2.C2_BATROT IS NOT NULL "
cQuery +=   " AND (SC2.C2_DATRF = ' ' "
cQuery +=   "  OR  SC2.C2_DATRF IS NULL) "
cQuery +=   " AND SC2.D_E_L_E_T_ = ' ' "
cQuery +=   " AND SD4.LINHAS IS NULL "
cQuery += " ORDER BY " + SqlOrder(SC2->(IndexKey(1)))

//cQuery := ChangeQuery(cQuery)

//Se não for SQL Server, troca o comando de concatenação de + por ||
If !("MSSQL" $ cBanco)
	cQuery := StrTran(cQuery, "+", "||")
EndIf

dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasTop,.T.,.T.)

While (cAliasTop)->(!Eof())
	SC2->(DbGoto((cAliasTop)->(C2REC)))
	If !If(cFuncOri $ "RPC|MATA650",.T.,(AllTrim(SC2->C2_BATROT) $ cFuncOri+"|MATA760|MATA416"))
		(cAliasTop)->(DbSkip())
		Loop
	EndIf

	If !lAuto
		IncProc()
	EndIf

	If lMTA650GEM
		ExecBlock("MTA650GEM",.F.,.F.,{'1',SC2->C2_FILIAL,SC2->C2_NUM,SC2->C2_ITEM,SC2->C2_SEQUEN,SC2->C2_ITEMGRD,SC2->C2_PRODUTO})
	EndIf

	aAltSaldo := {}

	If If(lControlUser,SC2->C2_BATUSR == cCodUsr .Or. Empty(SC2->C2_BATUSR),.T.) .And. SC2->(MsRLock())
		If ( Empty(SC2->C2_BATCH) .and. SC2->C2_FILIAL == cFilSC2 .And. ;
		If(lOrcamento,SC2->C2_BATORCA=="S",SC2->C2_BATORCA!="S") )
			If Empty(SC2->C2_DATRF)
				dbSelectArea("SB2")
				dbSetOrder(1)
				If !MsSeek(xFilial("SB2")+SC2->C2_PRODUTO+SC2->C2_LOCAL)
					CriaSB2(SC2->C2_PRODUTO,SC2->C2_LOCAL)
					MsUnlock()
				EndIf
				GravaB2Pre("-",SC2->C2_QUANT,SC2->C2_TPOP,SC2->C2_QTSEGUM)
				cSeqC2 :=SC2->C2_SEQUEN
				lMt650RevDis := .T.
				A650WriteOp(.F.,.F.,,SC2->C2_TPOP)
			EndIf
			SC2->(DbGoto((cAliasTop)->(C2REC)))
			RecLock("SC2",.F.)
			SC2->C2_BATCH := "S"
			MsUnLock()
		EndIf
		SC2->(MsUnLock())
	EndIf
	(cAliasTop)->(DbSkip())
End
SC2->(MsUnlock())

(cAliasTop)->(dbCloseArea())

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Gera SC's aglutinadas por data de Necessidade.               ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If mv_par06 == 3
	If Type("lMata712") == "L" .And. lMata712 // Desempenho MRP
		For nz:=1 to Len(aDataOPC7)
			A650GravC7(aDataOPC7[nz,1],aDataOPC7[nz,2],aDataOPC7[nz,3],aDataOPC7[nz,4],aDataOPC7[nz,5],aDataOPC7[nz,6])
		Next nz
		For nz:=1 to Len(aDataOPC1)
			A650GravC1(aDataOPC1[nz,1],aDataOPC1[nz,2],aDataOPC1[nz,3],aDataOPC1[nz,4],aDataOPC1[nz,5],;
				aDataOPC1[nz,6],aDataOPC1[nz,7],aDataOPC1[nz,8],aDataOPC1[nz,9],aDataOPC1[nz,10],aDataOPC1[nz,11],aDataOPC1[nz,12],,,,{},@dDataQuebr,@nLastRecno)
		Next nz
	Else
		For nz:=1 to Len(aDataOPC7)
			//aFornecedor:= COMPESQFOR(aDataOPC7[nz,1]) //-- Retorna codigo e loja do fornecedor
			aFornecedor := aPesqFor(aDataOPC7[nz,1]) //-- Retorna codigo e loja do fornecedor padrão
			nPrc:= COMPESQPRECO(aDataOPC7[nz,1],cFilAnt,aFornecedor[1],aFornecedor[2])
			aCampos := {}
			If aDataOPC7[nz,2] == aDataOPC7[nz,7]
				aadd(aCampos,{"OP",aDataOPC7[nz,3]})
			EndIf
			aadd(aCampos,{"DATPRF",aDataOPC7[nz,4]})
			aadd(aCampos,{"TPOP",aDataOPC7[nz,6]})
			If Type('lProj711') == "L" .And. lProj711
				aadd(aCampos,{"SEQMRP",c711NumMRP})
			EndIf

			//verifica se já existe a data no array
			If (ASCAN(aDatasNec, { |x| x == aDataOPC7[nz,4] }) == 0)
				//adiciona a data no array.
				Aadd(aDatasNec,aDataOPC7[nz,4])
			EndIf

			Aadd(aDocs,{aDataOPC7[nz,1],aDataOPC7[nz,2],cFilAnt,cFilAnt,"1",aFornecedor[1],aFornecedor[2],,nPrc,{}," ","",aCampos})

		Next nz
		For nz:=1 to Len(aDataOPC1)
			//aFornecedor:= COMPESQFOR(aDataOPC1[nz,1]) //-- Retorna codigo e loja do fornecedor
			aFornecedor := aPesqFor(aDataOPC1[nz,1]) //-- Retorna codigo e loja do fornecedor padrão
			nPrc:= COMPESQPRECO(aDataOPC1[nz,1],cFilAnt,aFornecedor[1],aFornecedor[2])
			aCampos := {}

			If aDataOPC1[nz,2] == aDataOPC1[nz,7]
				aadd(aCampos,{"OP",aDataOPC1[nz,3]})
			EndIf
			aadd(aCampos,{"DATPRF",aDataOPC1[nz,4]})
			aadd(aCampos,{"TPOP",aDataOPC1[nz,11]})
			If Type('lProj711') == "L" .And. lProj711
				aadd(aCampos,{"SEQMRP",c711NumMRP})
			EndIf

			//verifica se já existe a data no array
			If (ASCAN(aDatasNec, { |x| x == aDataOPC1[nz,4] }) == 0)
				//adiciona a data no array.
				Aadd(aDatasNec,aDataOPC1[nz,4])
			EndIf

			Aadd(aDocs,{aDataOPC1[nz,1],aDataOPC1[nz,2],cFilAnt,cFilAnt,"1",aFornecedor[1],aFornecedor[2],,nPrc,{}," ","",aCampos})

		Next nz
		If !Empty(aDocs)
			//Passo por cada data
			For nx := 1 to Len(aDatasNec)

				aDocsDt := {}
				aDocNew := {}

				For nDt := 1 to Len(aDocs)

					//Busca posição correta da data devido ao comportamento do if da linha 6437
					nPosDT := ASCAN(aDocs[nDt][13], { |x| x[1] == "DATPRF" })

					//separa as necessidades por Data
					If (aDatasNec[nx] == aDocs[nDt][13][nPosDT][2])
						//adiciono no array os docs que enviarei para gerar SC/AE
						Aadd(aDocsDt,aDocs[nDt])
					Else
						//adiciono no array os valores que não usei.
						Aadd(aDocNew,aDocs[nDt])
					EndIf
				Next nDt
				//removo os que já usei.
				aDocs := AClone(aDocNew)

				aResultados:= ComGeraDoc(aDocsDt,.T.,.F.,.T.,.F.,ComDtNeces({aDatasNec[nx]}),"MATA650" ,/*lEnviaEmail*/,2  )
				a650TabMRP(aResultados)
				If ExistBlock("MT650C1")
					For nLoop := 1 To Len( aResultados )
						Do Case
							//--Tipo de documento gerado pela biblioteca de compras
							Case aResultados[nLoop,1,3] == "1" //-- Solicitação de Compras
								SC1->(dbSetOrder(1)) //-- C1_FILIAL+C1_NUM+C1_ITEM+C1_ITEMGRD
								If SC1->(dbSeek(aResultados[nLoop,1,1]+aResultados[nLoop,1,2]))
									Execblock("MT650C1",.F.,.F.,{"SC1",SC1->C1_NUM,SC1->C1_ITEM,SC1->(Recno())})
								EndIf
						EndCase
					Next nLoop
				EndIf
			Next nx
		EndIf
	EndIf
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Refaz informacoes do arquivo batch.op caso necessario        ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
DbSelectArea("SC2")
If	A650NumReg() .And. A650OpenBatch(.T.)
	dbClearIndex()
	__dbPack()
	If TMP->(LastRec() = 0)
		A650OpenBatch(.T., .T., .T.)
	Endif
	TMP->(dbCloseArea())
	A650OpenBatch(, .T.)
EndIf

If FindFunction('ClrCachOpc')
   ClrCachOpc()
EndIf

RestArea(aAreaSC2)
RestArea(aAreaAnt)

If ExistBlock("MTA650GEM") .AND. (Type('l650Auto') # "L" .Or. !l650Auto)
	ExecBlock("MTA650GEM",.F.,.F.,{'3',nil,nil,nil,nil,nil,nil})
EndIf

RETURN NIL

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³ A650Trcdt³ Autor ³ Ary Medeiros          ³ Data ³ 10/09/93 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descricao ³ Troca a data do empenho na alteracao                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA650                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function A650Trcdt(cOP)
Local aArea := GetArea()
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Verifica se devera' ser alterado ou nao todos os itens da Grade ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Local lAltGra   := If(mv_par11==1, .T. , .F. )
Local lRet	:= .T.
Local cFilSC2 := xFilial("SC2")
Local cFilSD4 := xFilial("SD4")
Local cFilSC1 := xFilial("SC1")
Local cFilSC8 := xFilial("SC8")
Local cFilSC7 := xFilial("SC7")

dbSelectArea("SC2")
SC2->(dbSetOrder(1))
SC2->(dbSeek(cFilSC2+cOP))
Do While !Eof() .And. C2_FILIAL+C2_NUM+C2_ITEM == cFilSC2+left(cOP,len(SC2->(C2_NUM+C2_ITEM)))
	dbSelectArea("SD4")
	SD4->(DbsetOrder(2))
	If SD4->(dbSeek(cFilSD4+SC2->C2_NUM+SC2->C2_ITEM+SC2->C2_SEQUEN))
		Do While SD4->(!Eof()) .And. D4_FILIAL+If(!lAltGra,D4_OP,left(SD4->D4_OP,len(cOp))) == cFilSD4+SC2->C2_NUM+SC2->C2_ITEM+If(lAltGra,SC2->C2_SEQUEN,SC2->C2_SEQUEN+SC2->C2_ITEMGRD)
			Reclock("SD4",.F.)
			Replace D4_DATA With SC2->C2_DATPRI
			MsUnlock()
			dbSkip()
		EndDo
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Ponto de Entrada MT650ALT antes da alteração de SC's e AE's  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If ExistBlock( "MT650ALT" )
	   lRet:=ExecBlock("MT650ALT",.F.,.F.,{SC2->C2_NUM+SC2->C2_ITEM+SC2->C2_SEQUEN+SC2->C2_ITEMGRD})
	   If Valtype(lRet) <> "L"
	   	lRet:= .T.
	   EndIf
	Endif

	If lRet
    	//Atualiza datas das SC`s
		dbSelectArea("SC1")
		dbSetOrder(4)
		dbSeek(cFilSC1+SC2->C2_NUM+SC2->C2_ITEM+SC2->C2_SEQUEN)
		Do While ! Eof() .And. C1_FILIAL+If(!lAltGra,C1_OP,Left(C1_OP,Len(cOp))) == cFilSC1+SC2->C2_NUM+SC2->C2_ITEM+SC2->C2_SEQUEN+If(lAltGra,SC2->C2_SEQUEN,SC2->C2_ITEMGRD)
			RecLock("SC1",.F.)
				Replace C1_DATPRF with SC2->C2_DATPRI
				atuIniCom()
			MsUnlock()
			dbSkip()
			//Atualiza datas das cotacoes
			dbSelectArea("SC8")
			dbSetOrder(3)
			dbSeek(cFilSC8+SC1->(C1_COTACAO+C1_PRODUTO))
			While !EOF() .And. C8_FILIAL+C8_NUM+C8_PRODUTO == cFilSC8+SC1->(C1_COTACAO+C1_PRODUTO)
				RecLock("SC8",.F.)
				Replace C8_DATPRF With SC2->C2_DATPRI
				MsUnLock()
				dbSkip()
			End
			dbSelectArea("SC1")
		End
		//Atualiza datas das AE`s
		dbSelectArea("SC7")
		dbSetOrder(8)
		dbSeek(cFilSC7 + SC2->C2_NUM+SC2->C2_ITEM+SC2->C2_SEQUEN)
		Do While ! Eof() .And. C7_FILIAL+If(!lAltGra,C7_OP,Left(C7_OP,Len(cOp))) == cFilSC7+SC2->C2_NUM+SC2->C2_ITEM+SC2->C2_SEQUEN+If(lAltGra,SC2->C2_SEQUEN,SC2->C2_ITEMGRD)
			If C7_TIPO = 2
				RecLock("SC7", .F.)
				Replace C7_DATPRF with  SC2->C2_DATPRI
				MsUnlock()
			EndIf
			dbSkip()
		EndDo
	EndIF

	dbSelectArea("SC2")
	dbSkip()
EndDo
RestArea(aArea)
RETURN .T.

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³ A650Credit³ Autor ³ Rosane                ³ Data ³ 13/02/95 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Avalia Credito e Lim. de Cred. de P.V. para Gerar O.P.      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA650                                                     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function A650Credit(cAlias,cCampo,nOpcE,cMarca,lInverte)
Local nRecno := Recno(), lCredito := lCredVenc := .T.

If MsgYesNo(OemToAnsi(STR0088)) //###"Inicia o processo de avaliacao de credito ?"
	dbSelectArea("SC5")
	dbSetOrder(1)
	dbSelectArea("SA1")
	dbSetOrder(1)

	dbSelectArea(cAlias)
	dbGoTop()
	While !Eof()
		If Empty(C6_OP) .Or. C6_OP == "04"
			dbSelectArea("SC5")
			dbSeek(xFilial("SC5")+SC6->C6_NUM)
			If Found()
				lCredito := A650Comp(SC6->C6_CLI+SC6->C6_LOJA,SC6->C6_PRCVEN,SC6->C6_QTDVEN,SC5->C5_MOEDA)
				If lCredito
					dbSelectArea("SA1")
					dbSeek(xFilial("SA1")+SC5->C5_CLIENTE+SC5->C5_LOJACLI)
					If Found() .And. !Empty(SA1->A1_VENCLC) .And. SA1->A1_VENCLC < dDataBase
						lCredVenc := .F.
					EndIf
				EndIf
			EndIf
			RecLock(cAlias,.F.)
			Replace C6_OP With IIF(lCredito.And.lCredVenc,"  ","04")
			If C6_OP == "04"
				Replace C6_OK With " "
			EndIf
			MsUnLock()
		EndIf
		dbSkip()
		lCredito := lCredVenc := .T.
	End
	dbGoTo(nRecno)
EndIf
Return .T.

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³ A650Comp ³ Autor ³ Claudinei M. Benzi    ³ Data ³ 22.01.92 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Efetua comparacao dos saldos com o limite em moeda forte,  ³±±
±±³          ³ retornando .T. ou .F.   .T.-> Aprovado    .F.-> Reprovado  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ ExpL1 = A650Comp()                                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Mata650                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function A650Comp(cCodCli,nPrcUnit,nQtdLib,nMoeda)
Local lRet:=.T., nLimCred, cTipoCred, nValPed, nNumDias
Local lExistBlock:=ExistBlock("A650AVALC")
Local	lBackRet

Private lLiber := .F., lTransf := .F.

nMoeda  := Iif(nMoeda == NIL,1,nMoeda)
nMoeda  := Iif(nMoeda == 0,1,nMoeda)
nPrcUnit:= xMoeda(nPrcUnit,nMoeda,1,dDataBase)
cMCusto := SuperGetMV("MV_MCUSTO")

dbSelectArea("SA1")
dbSeek(xFilial("SA1")+cCodCli)
cMCusto		:= If(SA1->A1_MOEDALC > 0, Alltrim(STR(SA1->A1_MOEDALC)), cMCusto)

If Found() .And. SuperGetMV("MV_BLOQUEI")
	cTipoCred := Substr(SA1->A1_RISCO,1,1)

	If cTipoCred == "A"
		lRet := .T.
	ElseIf cTipoCred == "E"
		lRet := .F.
	Else
		dbSelectArea("SM2")
		dbSeek(dDataBase)

		nLimCred  := (SA1->A1_LC) * IIF(!Empty(M2_MOEDA&cMCusto.),M2_MOEDA&cMCusto.,1)

		nValPed := (nQtdLib * nPrcUnit)
		If SA1->A1_SALDUP + xMoeda(SA1->A1_SALPEDL,Val(cMCusto),1,dDatabase) + nValPed > nLimCred
			lRet := .F.
		Else
			If cTipoCred $ "BCD"
				nNumDias := SuperGetMV("MV_RISCO"+cTipoCred)
				dbSelectArea("SE1")
				dbSetOrder(8)
				dbSeek(xFilial("SE1")+cCodCli+"A")
				If Found()
					If dDataBase - E1_VENCREA < nNumDias
						lRet := .T.
					Else
						lRet := .F.
					EndIf
				Else
					lRet := .T.
				EndIf
			EndIf
		EndIf
	EndIf
EndIf

// Executa ponto de entrada
If lExistBlock
	lRet:=ExecBlock("A650AVALC",.F.,.F.,lRet)
	If ValType(lRet) # "L"
		lRet:=lBackRet
	EndIf
EndIf

RETURN lRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³A650Prior   ³ Autor ³ Waldemiro Lustosa   ³ Data ³ 12/09/95 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Validacao do campo C2_PRIOR                                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA650                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function A650Prior()
Local cAlias := Alias(), nIndexOrd := IndexOrd(), nRecno := Recno()
Local cCpoPrior := ReadVar(), cPrior := &(ReadVar())
Local cSeqAnt, nEndereco, lRet := .T.

If cCpoPrior == "M->C2_PRIOR" .And. altera .And. M->C2_PRIOR # SC2->C2_PRIOR
	If M->C2_SEQUEN # "001"
		cSeqAnt := StrZero( Val( M->C2_SEQUEN ) - 1, 3, 0)
		dbSelectArea("SC2")
		dbSetOrder(1)
		dbSeek(xFilial("SC2")+M->C2_NUM+M->C2_ITEM+cSeqAnt)
		If Found()
			If cPrior > C2_PRIOR
				Help(" ",1,"A650PRIOR",,C2_PRIOR,03,20)
				M->C2_PRIOR := C2_PRIOR
				nEndereco := Ascan(aGets,{ |x| Subs(x,9,8) == "C2_PRIOR" } )
				If nEndereco > 0
					aTela[Val(Subs(aGets[nEndereco],1,2))][Val(Subs(aGets[nEndereco],3,1))*2] := C2_PRIOR
				EndIf
				lRet := .F.
			EndIf
		EndIf
	EndIf
EndIf

dbSelectArea(cAlias)
dbSetOrder(nIndexOrd)
dbGoto(nRecno)
RETURN lRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³A650Status  ³ Autor ³ Waldemiro Lustosa   ³ Data ³ 14/09/95 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Validacao do campo C2_STATUS                               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA650                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function A650Status()
Local cAlias := Alias(), nIndexOrd := IndexOrd(), nRecno := Recno()
Local cCpoStatus := ReadVar(), cStatus := &(ReadVar())
Local nEndereco, lRet := .T.
Local nOpcA

If cCpoStatus == "M->C2_STATUS"
	If inclui
		If cStatus == "S"
			Help(" ",1,"A650SACRAM")
			lRet := .F.
		EndIf
	Else
		If SC2->C2_STATUS # "S" .And. cStatus == "S"
			dbSelectArea("SC2")
			dbSetOrder(1)
			dbSeek(xFilial("SC2")+M->C2_NUM+M->C2_ITEM+M->C2_SEQUEN)
			If Found()
				If !Empty(C2_DATRF)
					Help(" ",1,"A650SACRA2")
					lRet := .F.
				Else
					If OpenSemSH8()
						dbSelectArea("SH8")
						dbGotop()
						If Bof() .And. Eof()
							Help(" ",1,"A650SACRAM")
							lRet := .F.
						Else
							dbSetOrder(1)
							dbSeek(xFilial("SH8")+M->C2_NUM+M->C2_ITEM+M->C2_SEQUEN)
							If Empty(SC2->C2_DATAJI) .Or. Empty(SC2->C2_DATAJF) .Or. Empty(SC2->C2_HORAJI) .Or. Empty(SC2->C2_HORAJF)
								If !Found()
									Help(" ",1,"A650SACRAM")
								Else
									If A690CheckSC2()
										Help(" ",1,"A650SACRA3")
									Else
										Help(" ",1,"A650SACRAM")
									EndIf
								EndIf
								lRet := .F.
							Else
								If SH8->(Found())
									If !A690CheckSC2()
										If A690ChkFlag(2) == 0
											Help(" ",1,"A650SACRA4")
											lRet := .F.
										Else
											cSacram := "S"
										EndIf
									Else
										Help(" ",1,"A650SACRA3")
										lRet := .F.
									EndIf
								Else
									Help(" ",1,"A650SACRAM")
									lRet := .F.
								EndIf
							EndIf
						EndIf
						dbCloseArea()

						//-- Fecha/Libera semaforo do SH8
						ClosSemSH8()
					Else
						lRet := .F.
					EndIf
				EndIf
			EndIf
		ElseIf SC2->C2_STATUS == "S" .And. cStatus # "S"
			cText:=STR0035+CHR(13)	//"Esta O.P. est  Sacramentada (aloca‡„o fixa)."
			cText+=STR0036	//"Vocˆ tem certeza que deseja mudar a Situa‡„o ?"
			IIF(MsgYesNo(OemToAnsi(cText),OemToAnsi(STR0024)),nOpca:=2,nOpca:=1)	//"Aten‡„o"
			If nOpcA == 2
				cSacram := "N"
			Else
				lRet := .F.
			EndIf
		ElseIf SC2->C2_STATUS == "S" .And. cStatus == "S"
			cSacram := ""
		ElseIf SC2->C2_STATUS # "S" .And. cStatus # "S"
			cSacram := ""
		EndIf
		If !lRet
			M->C2_STATUS := SC2->C2_STATUS
			nEndereco := Ascan(aGets,{ |x| Subs(x,9,9) == "C2_STATUS" } )
			If nEndereco > 0
				aTela[Val(Subs(aGets[nEndereco],1,2))][Val(Subs(aGets[nEndereco],3,1))*2] := SC2->C2_STATUS
			EndIf
		EndIf
	EndIf
EndIf

dbSelectArea(cAlias)
dbSetOrder(nIndexOrd)
dbGoto(nRecno)
RETURN lRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³A650DatPri  ³ Autor ³ Rodrigo de A. Sartorio³ Data ³ 22/08/97 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Validacao do campo C2_DATPRI                                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA650                                                      ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function A650DatPri(cCpoDatPri,dDatPri,cProd,nQuant,lReferencia)

Local lRet := .T.,nEndereco:=0
Local nPrazo
Local lHoras := .F.
Local lConsDtI := .T.

// Desconsidera Calcular Datas Previstas somente na alteração
If IsInCallStack("A650Altera")
	If Type("MV_PAR19") == "N" .And. MV_PAR19 == 2
		lConsDtI := .F.
	Endif
Endif

cCpoDatPri:= IF(cCpoDatPri==NIL,ReadVar(),cCpoDatPri)
dDatpri := IF(dDatPri==NIL,&(ReadVar()),dDatPri)
cProd   := IF(cProd  ==NIL,M->C2_PRODUTO,cProd)
nQuant  := IF(nQuant ==NIL,M->C2_QUANT,nQuant)
cRoteiro := IF(!Empty(M->C2_ROTEIRO),M->C2_ROTEIRO,nil)

nPrazo := CalcPrazo(cProd,nQuant,,,.T.,dDatPri,cRoteiro)
If RetFldProd(cProd,"B1_TIPE")=="H" .And. RetFldProd(cProd,"B1_PE")>0 .And. nPrazo = 0 //prazo em horas nao completa um dia
	lHoras := .T.
EndIf
lReferencia := If(lReferencia == NIL, .F., lReferencia)

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Verifica se a rotina esta sendo chamada da Proj.Estoques NOVA ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
lProj711:=If(Type("lProj711") == "L",lProj711,.F.)

If !lProj711 .And. cCpoDatpri == "M->C2_DATPRI" .And. lConsDtI
	If !Empty(nPrazo) .Or. lHoras
		// Valida Data
		If	!Empty(M->C2_DATPRF) .And. (((M->C2_DATPRF - dDatPri) < nPrazo) .Or. (lHoras .And. (M->C2_DATPRI # M->C2_DATPRF)))
		 	//(((M->C2_DATPRF - dDatPri) != nPrazo) .Or. (lHoras .And. (M->C2_DATPRI # M->C2_DATPRF)))
			// Nao apresenta o help qdo chamado do MRP
			If !lProj711 .and. !l650Auto
				Help(" ",1,"A650AJUSTD")
			EndIf
			If mv_par01 == 1 // Valida pela data Final
				M->C2_DATPRI:= If(!lHoras,SomaPrazo(M->C2_DATPRF, - nPrazo),M->C2_DATPRF)
			Else	// Valida pela data Inicial
				M->C2_DATPRF:= If(!lHoras,SomaPrazo(dDatPri, nPrazo),dDatPri)
			EndIf
			// Valida Data prevista p/ fim com a DataBase do sistema
			If M->C2_DATPRF < dDataBase
				M->C2_DATPRF:= If(!lHoras,SomaPrazo(dDataBase, nPrazo),dDataBase)
			EndIf
			If !lReferencia
				nEndereco := Ascan(aGets,{ |x| Subs(x,9,9) == "C2_DATPRI" } )
				If nEndereco > 0
					aTela[Val(Subs(aGets[nEndereco],1,2))][Val(Subs(aGets[nEndereco],3,1))*2] := DTOC(M->C2_DATPRI)
				EndIf
				nEndereco := Ascan(aGets,{ |x| Subs(x,9,9) == "C2_DATPRF" } )
				If nEndereco > 0
					aTela[Val(Subs(aGets[nEndereco],1,2))][Val(Subs(aGets[nEndereco],3,1))*2] := DTOC(M->C2_DATPRF)
				EndIf
			EndIf
			// Inicializa Data
		ElseIf Empty(M->C2_DATPRF)
			M->C2_DATPRF:= If(!lHoras,SomaPrazo(dDatPri, nPrazo),dDatPri)
			// Valida Data prevista p/ fim com a DataBase do sistema
			If M->C2_DATPRF < dDataBase
				M->C2_DATPRF:= If(!lHoras,SomaPrazo(dDataBase, nPrazo),dDataBase)
			EndIf
			If !lReferencia
				nEndereco := Ascan(aGets,{ |x| Subs(x,9,9) == "C2_DATPRF" } )
				If nEndereco > 0
					aTela[Val(Subs(aGets[nEndereco],1,2))][Val(Subs(aGets[nEndereco],3,1))*2] := DTOC(M->C2_DATPRF)
				EndIf
			EndIf
		EndIf
	Else
		If ( Type("l650Auto")=="L" .and. l650Auto ) .And. !Empty(M->C2_DATPRI) .And. Empty(M->C2_DATPRF) .And. mv_par01 == 2
			M->C2_DATPRF := M->C2_DATPRI
		Endif
	EndIf
EndIf
RETURN lRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³A650DatPrf  ³ Autor ³ Rodrigo de A. Sartorio³ Data ³ 22/08/97 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Validacao do campo C2_DATPRF                                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA650                                                      ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function A650DatPrf(cCpoDatPrf,dDatPrf,cProd,nQuant, lReferencia)

Local lRet := .T.
Local nPrazo, nEndereco:=0
Local lHoras := .F.
Local lConsDtF := .T.

// Considera Calcular Datas Previstas somente na alteração
If IsInCallStack("A650Altera")
	If Type("MV_PAR19") == "N" .And. MV_PAR19 == 2
		lConsDtF := .F.
	Endif
Endif

cCpoDatPrf:= IF(cCpoDatPrf==NIL,ReadVar(),cCpoDatPrf)
dDatprf := IF(dDatPrf==NIL,&(ReadVar()),dDatPrf)
cProd   := IF(cProd  ==NIL,M->C2_PRODUTO,cProd)
nQuant  := IF(nQuant ==NIL,M->C2_QUANT,nQuant)
lReferencia := If(lReferencia == NIL, .F., lReferencia)
cRoteiro := IF(!Empty(M->C2_ROTEIRO),M->C2_ROTEIRO,nil)

nPrazo := CalcPrazo(cProd,nQuant,,,.F.,M->C2_DATPRF,cRoteiro)
If RetFldProd(cProd,"B1_TIPE")=="H" .And. RetFldProd(cProd,"B1_PE")>0 .And. nPrazo = 0 //prazo em horas nao completa um dia
	lHoras := .T.
EndIf

If Empty(M->C2_DATPRI) .And. nPrazo = 0
	M->C2_DATPRI := dDatPrf
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Verifica se a rotina esta sendo chamada da Proj.Estoques NOVA ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
lProj711:=If(Type("lProj711") == "L",lProj711,.F.)

If !lProj711 .And. cCpoDatprf == "M->C2_DATPRF" .And. lConsDtF
	// Valida em relacao a data base
	If dDatprf < dDataBase .And. !lProj711
		Help(" ",1,"A650DATPRF")
		lRet := .F.
	EndIf
	If lRet
		// Verifica se o prazo de entrega esta sendo respeitado e caso
		// nao esteja, mostra Help
		If !Empty(nPrazo) .Or. lHoras
			// Valida Data
			If !Empty(M->C2_DATPRI) .And. ((SomaPrazo(M->C2_DATPRI, nPrazo) != dDatPrf) .Or. (lHoras .And. (M->C2_DATPRI # M->C2_DATPRF)))
			 	//Se a data de previsao de inicio for diferente, alterar para a nova data calculada
				//.And. ((SomaPrazo(M->C2_DATPRI, nPrazo) > dDatPrf) .Or. (lHoras .And. (M->C2_DATPRI # M->C2_DATPRF)))
				If !lProj711 .and. !l650Auto
					Help(" ",1,"A650AJUSTD")
				EndIf
				If mv_par01 == 1	// Valida pela data Final
					M->C2_DATPRI:= If(!lHoras,SomaPrazo(dDatprf, - nPrazo),dDatPrf)
				Else // Valida pela data Inicial
					M->C2_DATPRF:= If(!lHoras,SomaPrazo(M->C2_DATPRI, nPrazo),M->C2_DATPRI)
				EndIf
				// Valida Data prevista p/ fim com a DataBase do sistema
				If M->C2_DATPRF < dDataBase
					M->C2_DATPRF:= If(!lHoras,SomaPrazo(dDataBase, nPrazo),dDataBase)
				EndIf
				If !lReferencia
					nEndereco := Ascan(aGets,{ |x| Subs(x,9,9) == "C2_DATPRI" } )
					If nEndereco > 0
						aTela[Val(Subs(aGets[nEndereco],1,2))][Val(Subs(aGets[nEndereco],3,1))*2] := DTOC(M->C2_DATPRI)
					EndIf
					nEndereco := Ascan(aGets,{ |x| Subs(x,9,9) == "C2_DATPRF" } )
					If nEndereco > 0
						aTela[Val(Subs(aGets[nEndereco],1,2))][Val(Subs(aGets[nEndereco],3,1))*2] := DTOC(M->C2_DATPRF)
					EndIf
				EndIf
				// Inicializa Data
			ElseIf Empty(M->C2_DATPRI)
				M->C2_DATPRI:= If(!lHoras,SomaPrazo(dDatprf, - nPrazo),dDatprf)
				If !lReferencia
					nEndereco := Ascan(aGets,{ |x| Subs(x,9,9) == "C2_DATPRI" } )
					If nEndereco > 0
						aTela[Val(Subs(aGets[nEndereco],1,2))][Val(Subs(aGets[nEndereco],3,1))*2] := DTOC(M->C2_DATPRI)
					EndIf
				EndIf
			EndIf
		EndIf
	EndIf
EndIf
RETURN lRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³A650TudoOk³ Autor ³ Rodrigo de A. Sartorio ³ Data ³22/08/97 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Valida a Enchoice em relacao as datas de inicio previsto   ³±±
±±³          ³ e entrega prevista com prazo de entrega.                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA650                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function A650TudoOk()
Local aInfGrd     := {}
Local aTamB2      := TamSX3("B2_SALPED2")
Local aTamC2      := TamSX3("C2_QTSEGUM")
Local aTamC2Seq   := TamSx3("C2_SEQUEN")
Local cC2_Produto := ""
Local cMsg        := ""
Local cNovoNum    := ""
Local cOPGerada   := M->C2_NUM + M->C2_ITEM + M->C2_SEQUEN + M->C2_ITEMGRD
Local cProduto    := M->C2_PRODUTO
Local lC2_Produto := .F.
Local lConsDt     := .T.
Local lGrade      := MaGrade()
Local lIntgMES    := .F.
Local lIntQIP     := IntQIP(cProduto,,IIf(cModulo=="QIP","E","T"))
Local lLite       := .F.
Local lRefGrade   := MatGrdPrrf(@cProduto)
Local lProdGrade  := lRefGrade .And. Type("aCols") == "A"
Local lPrzEstr    := GetNewPar("MV_PRZESTR",.T.)
Local lRet        := .T.
Local nEndereco   := 0
Local nGrdCol     := 0
Local nGrdLin     := 0
Local nI          := 0
Local nPos        := 0
Local nPosDPrF    := 0
Local nPosOpc     := 0
Local nPosQtd     := 0
Local nPrazo      := CalcPrazo(M->C2_PRODUTO,M->C2_QUANT,,,mv_par01==2,If(mv_par01==2,M->C2_DATPRI,M->C2_DATPRF))
Local nPrazoTot   := Nil
Local nTipoVld    := 2

Private aIntegPPI := {}

lIntgMES := PCPIntgPPI("SC2", @lLite)

If INCLUI
	nPos := If(l650Auto,aScan(aRotProd,{|x| AllTrim(x[1]) == "C2_PRODUTO" }),1)
	If nPos < 1
		Help(" ",1,"HELP", ,STR0222+".",1,0, ,,,,,{STR0223})
		lRet := .F.
	EndIf

	nPosQtd := If(l650Auto,aScan(aRotProd,{|x| AllTrim(x[1]) == "C2_QUANT" }),1)
	If (nPosQtd < 1 .Or. (nPosQtd > 1 .And. aRotProd[nPosQtd,2] <= 0))
		Help(" ",1,"HELP", ,STR0224+".",1,0, ,,,,,{STR0225})
		lRet := .F.
	EndIf

	nPosDPrF := If(l650Auto .and. mv_par01 == 1,aScan(aRotProd,{|x| AllTrim(x[1]) == "C2_DATPRF" }),1)
	If nPosDPrF < 1
		Help(" ",1,"HELP", ,STR0226+".",1,0, ,,,,,{STR0227})
		lRet := .F.
	EndIf
EndIf

M->C2_OP := cOPGerada

nPosOpc := If(l650Auto,aScan(aRotProd,{|x| AllTrim(x[1]) == "C2_MOPC" }),0)
If nPosOpc < 1
	nPosOpc := If(l650Auto,aScan(aRotProd,{|x| AllTrim(x[1]) == "C2_OPC" }),0)
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Verifica se a rotina esta sendo chamada da Proj.Estoques NOVA ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
lProj711:=If(Type("lProj711") == "L",lProj711,.F.)

If lRet
	If !Empty(M->C2_REVISAO) .AND. !Empty(M->C2_PRODUTO)
		If !PCPVldRev(M->C2_PRODUTO,M->C2_REVISAO) .And. !MatGrdPrrf(M->C2_PRODUTO, .T.)
			Help(" ",1,"HELP", ,STR0264+".",1,0, ,,,,,{STR0265}) //Revisão não existe para o produto informado.
			lRet := .F.
		EndIf
	EndIf
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Verifica se tem permissao de armazem  |
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lRet
	If lGrade .And. lProdGrade .And. Len(aCols) > 0
   		For nGrdLin:=1 to Len(oGrade:aColsGrade[1])
      		For nGrdCol:=2 to Len(oGrade:aHeadGrade[1])
         		If oGrade:aColsFieldByName("C2_QUANT",1,nGrdLin,nGrdCol) > 0
            		cProdRef := Substr(M->C2_PRODUTO,1,oGrade:TamRef())
            		MatGrdPrrf(@cProdRef)
            		cProdRef := oGrade:GetNameProd(cProdRef,nGrdLin,nGrdCol)
            		lRet := MaAvalPerm(3,{M->C2_LOCAL,cProdRef})

            		If !lRet
               			Exit
            		EndIf
        	 	EndIf
      		Next
      		If !lRet
        		 Exit
      		EndIf
   		Next
	Else
   		lRet := MaAvalPerm(3,{M->C2_LOCAL,M->C2_PRODUTO})
	EndIf
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Garante estar posicionado no RecNo de origem evitando problemas c/³
//³ customizacoes de clientes. Somente alteracao(bops 000000908047)   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lRet .And. Type('Altera')=='L'
	If Altera .And. Type('nRecSC2')#'U'
		SC2->(DbGoto(nRecSC2))
	EndIf
EndIf

//--Verifica se o SH8 estava locado (exclusivo) para outro processo
aAreaSh8 := SH8->(GetArea())
SH8->(DbsetOrder(1))
If SH8->(DbSeek(xFilial("SH8")+M->C2_NUM+M->C2_ITEM+M->C2_SEQUEN))
	If IsLockSH8()
		lRet := .F.
	EndIf
endif
RestArea(aAreaSh8)

//----------------------------------------------------------------------------------------//
// Verifica se a quantidade da segunda unidade de medida não ultrapassou o limite do campo//
//----------------------------------------------------------------------------------------//
If lRet .And. ((aTamC2[1]-aTamC2[2]) <= LEN(CvalToChar(Int(M->C2_QTSEGUM))))
	IF (aTamC2[1]-aTamC2[2]) >= (aTamB2[1]-aTamB2[2])
		If (!l650Auto)
			MsgAlert(OemToAnsi(STR0161)+' '+OemToAnsi(STR0164)+OemToAnsi(STR0163),OemToAnsi(STR0051))  //"Quantidade da segunda unidade de medida impossível de ser calculada. Favor verificar o tamanho dos campos C2_QTSEGUM e B2_SALPED2 ou ajustar o fator de conversão (B1_CONV)."
		Else
			AutoGRLog(OemToAnsi(STR0161)+' '+OemToAnsi(STR0164)+OemToAnsi(STR0163),OemToAnsi(STR0051)) //"Quantidade da segunda unidade de medida impossível de ser calculada. Favor verificar o tamanho dos campos C2_QTSEGUM e B2_SALPED2 ou ajustar o fator de conversão (B1_CONV)."
		EndIf
	Else
		If (!l650Auto)
			MsgAlert(OemToAnsi(STR0161)+' '+OemToAnsi(STR0162)+OemToAnsi(STR0163),OemToAnsi(STR0051))  //"Quantidade da segunda unidade de medida impossível de ser calculada. Favor verificar o tamanho do campo C2_QTSEGUM ou ajustar o fator de conversão (B1_CONV)."
		Else
			AutoGRLog(OemToAnsi(STR0161)+' '+OemToAnsi(STR0162)+OemToAnsi(STR0163),OemToAnsi(STR0051)) //"Quantidade da segunda unidade de medida impossível de ser calculada. Favor verificar o tamanho do campo C2_QTSEGUM ou ajustar o fator de conversão (B1_CONV)."
		EndIf
	EndIf
	lRet := .F.
EndIf

If lRet .And. ((aTamB2[1]-aTamB2[2]) <= LEN(CvalToChar(Int(M->C2_QTSEGUM))))
	If (!l650Auto)
		MsgAlert(OemToAnsi(STR0161)+' '+OemToAnsi(STR0165)+OemToAnsi(STR0163),OemToAnsi(STR0051))  //"Quantidade da segunda unidade de medida impossível de ser calculada. Favor verificar o tamanho do campo B2_SALPED2 ou ajustar o fator de conversão (B1_CONV)."
	Else
		AutoGRLog(OemToAnsi(STR0161)+' '+OemToAnsi(STR0165)+OemToAnsi(STR0163),OemToAnsi(STR0051)) //"Quantidade da segunda unidade de medida impossível de ser calculada. Favor verificar o tamanho do campo B2_SALPED2 ou ajustar o fator de conversão (B1_CONV)."
	EndIf
	lRet := .F.
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Verifica se a grade esta ativa e se o produto digitado eh uma referencia³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lRet .And. lIntQIP .And. (!(lGrade .And. lRefGrade) .Or. (lGrade .And. lRefGrade ))
	If Empty(M->C2_ROTEIRO)
		If !(l650Auto .And. Type("lRunMnt") == "L" .And. lRunMnt) //Se estiver criando OP pelo SIGAMNT, não deve obrigar a informar o Roteiro.
			If lQIPOPEPQP
				lRet := !QIPOPEPQPK(M->C2_PRODUTO, M->C2_REVI, M->C2_ROTEIRO, !l650Auto, l650Auto)
			Else
				lRet := .F.
				If (!l650Auto)
					MsgAlert(OemToAnsi(STR0050)+CHR(13)+OemToAnsi(STR0053),OemToAnsi(STR0051))		//"O campo roteiro dever  ser preenchido, pois a integra‡„o com os"###"m¢dulos CELERINA est  ativa (Verifique o parametro MV_QIPMAT)"###"Aten‡„o"
				Else
					AutoGRLog(OemToAnsi(STR0050)+CHR(13)+OemToAnsi(STR0053),OemToAnsi(STR0051))		//"O campo roteiro dever  ser preenchido, pois a integra‡„o com os"###"m¢dulos CELERINA est  ativa (Verifique o parametro MV_QIPMAT)"###"Aten‡„o"
				EndIf
			EndIf
		EndIf
	EndIf
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Verifica a compatibilidade dos tamanho dos campos D3_LOTECTL x QPK_LOTE ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lRet .And. lIntQIP
	If TamSX3("D3_LOTECTL")[1] != (TamSX3("QPK_LOTE")[1] - TamSX3("D3_NUMLOTE")[1] )
		If (!l650Auto)
			Aviso(STR0158,OemToAnsi(STR0159),{"Ok"},3)		//"O campo QPK_LOTE, deve ter o tamanho igual ao campo D3_LOTECTL + D3_NUMLOTE . Favor efetuar o ajuste do grupo de campo 069, conforme procedimentos descritos em Boletim Técnico."
		Else
			AutoGRLog(STR0159,STR0158)	//"O campo QPK_LOTE, deve ter o tamanho igual ao campo D3_LOTECTL + D3_NUMLOTE . Favor efetuar o ajuste do grupo de campo 069, conforme procedimentos descritos em Boletim Técnico."
		EndIf
		lRet := .F.
	EndIf
EndIf

// Verifica campos obrigatorios
If lRet .And. !Obrigatorio(aGets,aTela)
	lRet:=.F.
EndIf

If IsInCallStack("A650Altera")
	If Type("MV_PAR19") == "N" .And. MV_PAR19 == 2
		lConsDt := .F.
	Endif
Endif
If lConsDt
	// Verifica datas previstas
	If lRet .And. !lProj711 .And. SomaPrazo(M->C2_DATPRI, nPrazo) > M->C2_DATPRF
		If !l650Auto
			lRet:=.F.
			Help(" ",1,"A650AJUSTD")
		EndIf
		If mv_par01 == 1	// Valida pela data Final
			M->C2_DATPRI:= SomaPrazo(M->C2_DATPRF, - nPrazo)
		Else // Valida pela data Inicial
			M->C2_DATPRF:= SomaPrazo(M->C2_DATPRI, nPrazo)
		EndIf
		nEndereco := Ascan(aGets,{ |x| Subs(x,9,9) == "C2_DATPRI" } )
		If nEndereco > 0
			aTela[Val(Subs(aGets[nEndereco],1,2))][Val(Subs(aGets[nEndereco],3,1))*2] := DTOC(M->C2_DATPRI)
		EndIf
		nEndereco := Ascan(aGets,{ |x| Subs(x,9,9) == "C2_DATPRF" } )
		If nEndereco > 0
			aTela[Val(Subs(aGets[nEndereco],1,2))][Val(Subs(aGets[nEndereco],3,1))*2] := DTOC(M->C2_DATPRF)
		EndIf
	EndIf
ElseIF M->C2_DATPRF < M->C2_DATPRI
		Help(" ",1,"HELP", ,STR0259,1,0, ,,,,,{STR0260})
		lRet := .F.
EndIF
If lRet .And. Inclui
	If lPrzEstr .And. !lProj711
		If SuperGetMv("MV_PRZEXPL",.F.,.F.)
			nPrazoTot := CalcEntreg(M->C2_PRODUTO,M->C2_QUANT,M->C2_DATPRI)
		Else
			nPrazoTot := PrazoEstru(M->C2_PRODUTO,M->C2_QUANT,M->C2_DATPRI)
		EndIf
		If nPrazoTot > 0 .And. (SomaPrazo(M->C2_DATPRI, - nPrazoTot) < dDataBase)
			lRet:=A650Alert2(M->C2_NUM+M->C2_ITEM+M->C2_SEQUEN,nPrazoTot,M->C2_PRODUTO)
		EndIf
	EndIf
	If lRet
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Execblock a ser executado para verificar a validacao         ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		IF (ExistBlock('MA650VLD'))
			nTipoVld := ExecBlock('MA650VLD',.F.,.F.)
			If ValType(nTipoVld) # "N" .Or. (nTipoVld # 1 .And. nTipoVld # 2)
				nTipoVld:=1
			EndIf
		Endif
		If nTipoVld == 1
			M->C2_SEQUEN := "001"
			nEndereco := Ascan(aGets,{ |x| Subs(x,9,9) == "C2_SEQUEN" } )
			If nEndereco > 0
				aTela[Val(Subs(aGets[nEndereco],1,2))][Val(Subs(aGets[nEndereco],3,1))*2] := "001"
			Endif
		EndIf
		//-- Valida existencia na inclusao manual ou na automatica quando passou o numero na execauto. Nao valida quando
		//-- nao passou no array pois o sistema quem controlara e trocara no momento da gravao caso ja exista na base
		If !l650Auto .Or. NrExecAuto()
			lRet:=ExistChav("SC2",M->C2_NUM+M->C2_ITEM+If(nTipoVld==1,"",M->C2_SEQUEN))
		EndIf
	EndIf
EndIf
If lRet
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Grava no SC2 os Itens Informados na Grade                    ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lGrade .And. lProdGrade .And. Len(aCols) > 0
		aInfGrd := Ma650GraGr("SC2","A650",.F.)
		If Empty(aInfGrd) .Or. aInfGrd[1]==NIL
			Aviso(STR0108,STR0126,{"Ok"}) //"Nao existem dados informados para interface de grade"
			lRet := .F.
		Else
			cC2_Produto := M->C2_PRODUTO
			lC2_Produto := .T.
			M->C2_PRODUTO := aInfGrd[1]
			nEndereco := Ascan(aGets,{ |x| Subs(x,9,10) == "C2_PRODUTO" } )
			If nEndereco > 0
				aTela[Val(Subs(aGets[nEndereco],1,2))][Val(Subs(aGets[nEndereco],3,1))*2] := M->C2_PRODUTO
			EndIf
		EndIf
	EndIf
EndIf

If lRet .And. !lRefGrade .And. Inclui .And. (!l650Auto .Or. (l650Auto .And. (Empty(nPosOpc) .Or. Empty(aRotProd[nPosOpc,2]))))
	lRet := SeleOpc(1,"MATA650",M->C2_PRODUTO,/*04*/,/*05*/,/*06*/,"M->C2_MOPC",,M->C2_QUANT,M->C2_DATPRI,M->C2_REVISAO)
EndIf

// Tratamento para evitar erro caso numero esteja em concorrencia
SC2->(dbSetOrder(1))
cNovoNum := M->C2_NUM
While INCLUI
	If SC2->(dbSeek(xFilial("SC2")+cNovoNum+M->C2_ITEM+If(nTipoVld==1,"",M->C2_SEQUEN)))
		cNovoNum := GetNumSC2()
	ElseIf cNovoNum # M->C2_NUM
		M->C2_NUM := cNovoNum
		If !l650Auto
			Help(" ",1,"NUMSEQ",,M->C2_NUM,4,15)
		EndIf
		Exit
	Else
		Exit
	EndIf
End

//Verifica se o campo C2_SEQUEN está com todos os caracteres preenchidos para evitar erros nos processos onde é feito SEEK
If lRet .And. !Empty(M->C2_SEQUEN) .And. aTamC2Seq[1] # Len(AllTrim(M->C2_SEQUEN))
	MsgAlert(STR0180,STR0051) //"O campo sequência (C2_SEQUEN) não está com todos os caracteres preenchidos."
	lRet := .F.
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³P.E. Utilizado para executar a validacao do usuario ao confir-³
//³mar a OP.                                                     ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lRet .and. ExistBlock('MA650TOK')
	If lC2_Produto
		M->C2_PRODUTO := cC2_Produto
	Endif
		lRet := ExecBlock('MA650TOK',.F.,.F.)
	If lC2_Produto
		M->C2_PRODUTO := aInfGrd[1]
	Endif
EndIf

//Faz a validação para verificar se o roteiro foi informado.
If lRet .And. lIntgMES .And. !lLite
	/*
		MES Lite não obriga informar roteiro.
		Se não possuir operações, a OP não será integrada.
	*/
	If Empty(M->C2_ROTEIRO) .And. (Inclui .Or. Altera /*Exclusão não precisa validar.*/) .And. PCPFiltPPI("SC2", M->C2_NUM+M->C2_ITEM+M->C2_SEQUEN,"M")
		If Type('l650Auto') == "L" .And. l650Auto
			dbSelectArea("SB1")
			SB1->(dbSetOrder(1))
			If SB1->(dbSeek(xFilial("SB1")+M->C2_PRODUTO))
				M->C2_ROTEIRO := Iif(Empty(SB1->B1_OPERPAD),"01",SB1->B1_OPERPAD)
			Else
				M->C2_ROTEIRO := "01"
			EndIf
		Else
			Aviso(STR0186,STR0185,{"Ok"},2) //"Roteiro não informado. Para ordens de produção que são integradas com o TOTVS MES este campo é obrigatório."
			lRet := .F.
		EndIf
	EndIf
EndIf

If lRet .And. lIntSFC
	//Se Inclui=.T. Entao nEvento==1, Se for alteracao e foi
	//alterado o roteiro conteudo sera 2, senao conteudo sera 5
	//Evento 1 - Inclusao da Op
	//Evento 2 - Geracao das Operacoes
	//Evento 5 - Alteracao da Op
	DbSelectArea("CY9")
	CY9->(DbSetOrder(1))
	//Se não foi integrado no SFC no momento da inclusão e na alteração
	If ALTERA .and. Empty(SC2->C2_ROTEIRO) .and. !Empty(M->C2_ROTEIRO) .and. !(CY9->(DbSeek(xFilial("CY9")+M->(C2_NUM+C2_ITEM+C2_SEQUEN))))
		lRet := A650IntSFC(3,1)
	Else
		lRet := A650IntSFC(If(INCLUI,3,If(ALTERA,4,5)),If(INCLUI,1,If(ALTERA .And. M->C2_ROTEIRO # SC2->C2_ROTEIRO,2,5)))
	EndIf
EndIf


// Alteração colocando mais uma validação com a variável lRodaAPS - MATEUS HENGLE 21/07/23
If lRet .And. lIntgMES .And. RodaAPS() == .F.
   aIntegPPI := {}
   lRet      := mata650PPI(,,,.T.)
   If Len(aIntegPPI) > 0
		cMsg := STR0182 + CHR(10) //"Atenção! Ocorreram erros na integração com o MES. Erro: "
		For ni := 1 To Len(aIntegPPI)
			cMsg += STR0195 + AllTrim(aIntegPPI[ni,1]) + " - " + AllTrim(aIntegPPI[ni,2]) + CHR(10) //"OP: "
		Next ni
		Aviso(STR0186,cMsg,{"Ok"},3)
	EndIf
EndIf

If lRet .And. (!lProj711 .And. !lMata712 .And. !lPCPA107 .And. !l650Auto)
	//ID de métricas - usado para inclusão de OP manual
	//OP principal
	If Findfunction("PCPMETRIC")
		PCPMETRIC("MATA650", {{"manufatura-protheus_qtde-ops-manuais_total", 1 }})
	EndIf
EndIf

If lRet .And. (lProj711 .or. lMata712 .or. lPCPA107)
	If Type("nMetricAut") == "N"
		//Soma qtd de OP automáticas para envio de métrica - Qtde OPs Auto
		nMetricAut++
	EndIf
EndIf

If lC2_Produto
   M->C2_PRODUTO := cC2_Produto

   If nEndereco > 0
      aTela[Val(Subs(aGets[nEndereco],1,2))][Val(Subs(aGets[nEndereco],3,1))*2] := M->C2_PRODUTO
   EndIf
Endif

RETURN lRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³MTA650PERG³ Autor ³ Rodrigo de A. Sartorio³ Data ³ 28/12/95 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Chamada da funcao PERGUNTE                                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA650                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function MTA650PERG(lMostra)
Local ni:=0
Pergunte("MTA650", lMostra)
//Salvar variaveis existentes
For ni := 1 to 20
	aSav650[ni] := &("mv_par"+StrZero(ni,2))
Next ni
lConsNPT  := (aSav650[14] == 1)
lConsTerc := !(aSav650[15] == 1)
RETURN NIL

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³ Fun‡„o   ³MTA650OK  ³ Autor ³Rodrigo de A. Sartorio ³ Data ³ 04/12/95 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Descri‡„o³ Confirmacao antes de gerar OPs intermediarias e SCs        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MTA650OK                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function MTA650OK(nOpc)
Static lBlockMta650Ok
Local lRet := .T.
Local lMta650Ok
Local cText:=STR0037+CHR(13)	//"As OPs intermediarias e as SCs n„o foram geradas."
cText+=STR0038+CHR(13)	//"As op‡”es s„o:"
cText+=STR0039+CHR(13)  //"- Sim ,gerar agora."
cText+=STR0040+chr(13)	//"- N„o ,abandona para gera-las posteriormente."
cText+=STR0096+CHR(13) //"Se o parametro MV_EXPLOPV estiver configurado como SIM so serao"
cText+=STR0097 //"gerados OPs Interm. / Empenhos para as OPs desse usuario."
If lBlockMta650Ok == Nil
	lBlockMta650Ok := ExistBlock("Mta650Ok")
Endif
If lBlockMta650Ok .And. ValType(lMta650Ok := ExecBlock("MTA650OK", .F., .F.)) == "L"
	lRet := (If(lMta650Ok, nOpc:=1, nOpc:=2))
Else
	lRet := (IIF(MsgYesNo(OemToAnsi(cText),OemToAnsi(STR0024)),nOpc:=1,nOpc:=2))	//"Aten‡„o"
Endif
Return lRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³ SHOWF4   ³ Autor ³ Rodrigo de A. Sartorio³ Data ³ 02/12/96 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Chamada da funcao F4LOTE                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA650                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function ShowF4()

Local cLoteAnt := ""
Local dVldAnt  := nil

If (Alltrim(ReadVar()) $ "M->DC_LOCALIZ")
	F4Localiz(,,, "A260",aCols[n,nPosCod],aCols[n,nPosLocal],,ReadVar())
ELSEIf (Alltrim(ReadVar()) $ "M->D4_LOTECTL/M->D4_NUMLOTE")
	cLoteAnt := aCols[n, nPosLotCtl]
	dVldAnt  := aCols[n, nPosdValid]

	F4Lote(,,,"A650",aCols[n,nPosCod],aCols[n,nPosLocal])

	If cLoteAnt != aCols[n, nPosLotCtl] .Or. dVldAnt != aCols[n, nPosdValid]
		_lF4Lote := .T.
	EndIf

EndIf
Return Nil

/*/{Protheus.doc} a650F4Lote
Retorna o conteúdo da variável static _lF4Lote, e altera o valor da mesma para .F.

@type  Static Function
@author juliana.oliveira
@since 03/09/2019
@version P12.1.27
@return lReturn - Logic - Valor da variável _lF4Lote
/*/
Function a650F4Lote()
	Local lReturn := _lF4Lote

	_lF4Lote := .F.
Return lReturn

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³A650ACols ³ Autor ³ Rodrigo de A. Sartorio ³ Data ³ 16/06/97³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Fun‡„o recursiva que monta o array aCols usado para gerar  ³±±
±±³          ³ empenhos e SC's, verifica se existem produtos fantasma na  ³±±
±±³          ³ estrutura e substitue os mesmos pelos produtos incluidos   ³±±
±±³          ³ nos n¡veis abaixo.                                         ³±±
±±³          ³ Caso o usuario tenha preenchido a pergunte MV_PAR08        ³±±
±±³          ³ ("Sugerir lotes a empenhar") como SIM, quebra o empenho das³±±
±±³          ³ MPS de acordo com os lotes dispon¡veis.                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA650                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function A650ACols(cProduto,nQuantPai,cOpcionais,lConsEst,cRevisao,uConteudo,aHeader,cLocProc,cProOpc,aOpcCam,cOperac,lRecursivo,aMRPxJson,cRevFan,aArrOpc)
Local nRecno     := 0
Local cGravaOpc  := ""
Local cAlias     := Alias()
Local zi         := 0
Local aRetorno   := {}
Local nSC2Recno  := SC2->(Recno())
Local nQtd2UM    := 0
Local nDecSD4    := TamSX3('D4_QUANT')[2]
Local nTamProd   := TamSX3("B1_COD")[1]
Local nTamSeq    := TamSX3("G1_TRT")[1]
Local cDescB1    := ""
Local nProcura   := 0
Local nProcACols := 0
Local aLotesTot  := {}
Local lPotencia  :=.F.,nQuantPot:=0,nQuantPot2:=0
Local lExistePE  := ExistBlock("A650ADCOL")
Local lA650POT   := ExistBlock("A650POT")
Local lFANREV    := ExistBlock("A650FANREV")
Local nRegSB2    := 0
Local nQtyStok   := 0
Local nCntFor    := 0
Local lEmpPrj    := SuperGetMV("MV_EMPPRJ",.F.,.T.)
Local nQtdPrj    := 0
Local nSldDisp   := 0
Local nQtdBack   := 0
Local nQtdDif    := 0
Local lEmpBN     := SuperGetMV("MV_EMPBN",.F.,.F.)
Local lGrvAllOpc := SuperGetMV("MV_GALLOPC",.F.,.F.)	//Grava todos os opcionais no campo C2_OPC
Local cRepGOPC   := SuperGetMV("MV_REPGOPC",.F.,"N")
Local cMVQTDPREV := SuperGetMV("MV_QTDPREV",.F.,"N")
Local nSldSBF    := 0
Local aTravSB2	 :=  (Iif (GetNewpar("MV_EMPEXCL",.F.),{},NIL))
Local cProOpcT   := ""
Local aLoteTeste := {}
Local nCont      := 0
Local nIndice    := 0
Local lEmpAlt
Local cRoteiro   := ""
Local nI         := 0
Local cString    := ""
Local lEmpenOri	 := .T.
Local lTemAlter	 := .F.
Local lExisGiEst := SGI->(FieldPos("GI_ESTOQUE")) > 0
Local nPoten     := 0

Local cD4NUMLOTE := CriaVar("D4_NUMLOTE")
Local cD4LOTECTL := CriaVar("D4_LOTECTL")
Local dD4DTVALID := CriaVar("D4_DTVALID")
Local nD4POTENCI := CriaVar("D4_POTENCI")
Local cDCLOCALIZ := CriaVar("DC_LOCALIZ")
Local cDCNUMSERI := CriaVar("DC_NUMSERI")

Local cFilSG1 := xFilial("SG1")
Local cFilSB1 := xFilial("SB1")
Local cFilSB2 := xFilial("SB2")
Local cFilSGI := xFilial("SGI")

Local nTamGropc := TamSX3("G1_GROPC")[1]
Local nTamOpc := TamSX3("G1_OPC")[1]

Local nInd       := 0
Local lExistEmSa := .F.
Local lVlOpc := .T.
Local lValOpcVnd := .F.
Local aOpc	     := aArrOpc //Str2Array(cOpcionais,.F.)
Local nAchaPrd	 := 0
Local cLocalP	 := ''
Local nX         := 0
Local nY         := 0
Local lIntNewMRP := Iif(_lNewMRP  == Nil, FindFunction("Ma650MrpOn") .AND. Ma650MrpOn(@_lNewMRP),_lNewMRP)
Local lConsVenc  := SuperGetMV("MV_LOTVENC",.F.,"S") == "S"
Local lDispSB8   := SuperGetMV("MV_SUGLOTE",.F.,.F.) //Considera ou não saldo SB8 no processamento.
Local aAreaB1Fan := {}

Local aAreaSG1   := {}
Local cSG1Comp   := ''
Local cPIFant    := 'N'
Local lExistComp := .F.
Local lGERAPI    := SuperGetMv("MV_GERAPI")
Local lRevOk     := .F.
Local nPotEstr   := 0
Local aRetPE	 := {}
Local lMA650ACG  := ExistBlock('MA650ACG')
Local nAc        := 0
Local nPosicao   := 0

PRIVATE uTrans:=uConteudo

Default cOperac    := Criavar("D4_OPERAC",.f.)
Default cRevisao   := Space(Len(SB1->B1_REVATU))
Default lRecursivo := .F.

STATIC lA650GRVOPC := ExistBlock("A650GRVOPC")
STATIC lExistePE   := ExistBlock("A650ADCOL")
STATIC lA650CALT   := ExistBlock("A650CALT")
STATIC lTA650SLD   := ExistTemplate("A650SALDO")
STATIC lBA650SLD   := ExistBlock("A650SALDO")
STATIC lGerOPI     := ExistBlock("MTGEROPI")
STATIC lA650VALES  := ExistBlock("A650VALEST")

If Empty(cRevisao) .And. !Empty(cRevFan)
	cRevisao := cRevFan
EndIf

lConsEst := If( (lConsEst == NIL),(SuperGetMV("MV_CONSEST") == "S"),lConsEst )
If Type('lOpVendas') == "L"
	lValOpcVnd := lOpVendas
EndIf

If Type("nPosOper") != "N"
	nPosOper:=0
EndIf

SB1->(dbSetOrder(1))

cPIFant := "N"

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Verifica informacoes de rastreabilidade                      ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If mv_par08 == 1 .And. lConsEst

	SG1->(dbSetOrder(1))
	SG1->(dbSeek(cFilSG1+cProduto))
	Do While SG1->(!Eof()) .And. SG1->(G1_FILIAL+G1_COD) == cFilSG1+cProduto

		SB1->(MsSeek(cFilSB1+SG1->G1_COMP))

		//DMANSMARTSQUAD1-23697 - considerar PI como Fantasma quando parâmetro
 		//MV_GERAPI igual a F
		cPIFant := "N"
		If !lGERAPI
			cSG1Comp := SG1->G1_COMP
			aAreaSG1 := SG1->(GetArea())
			SG1->(dbSetOrder(1))
			SG1->(dbSeek(cFilSG1+cSG1Comp))
			lExistComp := .F.
			While SG1->(!Eof()) .And. SG1->G1_FILIAL == cFilSG1 .And. cSG1Comp == SG1->G1_COD
				lValidOk := .F.
				lRevOk   := .F.
				If SC2->C2_DATPRI <= SG1->G1_FIM .And. SC2->C2_DATPRI >=SG1->G1_INI
					lValidOk := .T.
				EndIf

				cRevisaoOk :=IIF(lPCPREVATU , PCPREVATU(SB1->B1_COD), SB1->B1_REVATU )/*SB1->B1_REVATU*/
				If PCPVldRev(SB1->B1_COD, cRevisaoOk)
					If SG1->G1_REVINI <= cRevisaoOk .And. SG1->G1_REVFIM >= cRevisaoOk
						lRevOk := .T.
					EndIf
				EndIf	

				If lValidOk .And. lRevOk
					lExistComp := .T.
					Exit
				//Else
					//SG1->(dbskip())
				EndIf

				SG1->(dbskip())
			End

			If lExistComp
				If !lGERAPI
					cPIFant := "S"
				EndIf
			EndIf
			SG1->(RestArea(aAreaSG1))
		EndIF

		//nQuantItem:=Round(ExplEstr(nQuantPai,SC2->C2_DATPRI,cOpcionais,cRevisao),nDecSD4)
		cProOpcT   := (cProOpc + SG1->G1_COMP + SG1->G1_TRT )
		If (lProj711 .And. (lMata712 .Or. lPCPA107)) .Or. lValOpcVnd .Or. lGerOPI
			If ExistOpc(cOpcionais, SG1->G1_GROPC+SG1->G1_OPC, cProOpcT, SG1->G1_COMP + SG1->G1_TRT)
				nQuantItem :=Round(ExplEstr(nQuantPai,SC2->C2_DATPRI,cOpcionais,cRevisao, /*05*/, /*06*/, /*07*/, /*08*/, /*09*/, /*10*/,cProOpcT,/*12*/,.F.),nDecSD4)
			Else
				nQuantItem := 0
			EndIf
		Else
			nQuantItem :=Round(ExplEstr(nQuantPai,SC2->C2_DATPRI,cOpcionais,cRevisao, /*05*/, /*06*/, /*07*/, /*08*/, /*09*/, /*10*/,cProOpcT,/*12*/,.T.),nDecSD4)
		EndIf

		nQtd2UM:=ConvUM(SG1->G1_COMP,nQuantItem,0,2)
		cDescB1:=SB1->B1_DESC
		If (RetFldProd(SB1->B1_COD,"B1_FANTASM") != "S" .and. cPIFant != "S") .And. QtdComp(nQuantItem,.T.) # QtdComp(0) // Projeto Implementeacao de campos MRP e FANTASM no SBZ
			If lEmpBN .Or. SB1->B1_TIPO <> "BN"
				If SG1->G1_POTENCI > 0
					nPotEstr := SG1->G1_POTENCI
				Else
					nPotEstr   := 100
				EndIf

				nProcura := ASCAN(aLotesTot,{|x| x[1]== SG1->G1_COMP .And. x[6]== nPotEstr})
				If nProcura == 0
					AADD(aLotesTot,{SG1->G1_COMP,nQuantItem,nQtd2UM,If(SB1->B1_APROPRI=="I",cLocProc,If(MV_PAR02=1,RetFldProd(SB1->B1_COD,"B1_LOCPAD"),aSav650[3])),NIL,nPotEstr})
				Else
					aLotesTot[nProcura,2]+=nQuantItem
					aLotesTot[nProcura,3]+=nQtd2Um
				EndIf
			Endif
		EndIf

		SG1->(dbSkip())
	EndDo
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Inclui informacoes referente aos lotes que serao utilizados  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
nRegSB2 := SB2->(RecNo())
For zi:=1 to Len(aLotesTot)
	aRetorno := {}
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica o Saldo Disponivel no SB2 antes de verificar o Saldo dos Lotes³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	nQtyStok := 0
	SB1->(MsSeek(cFilSB1+aLotesTot[zi,1]))
	SB2->(MsSeek(cFilSB2+aLotesTot[zi,1]+If(mv_par02==1,RetFldProd(aLotesTot[zi,1],"B1_LOCPAD"),aSav650[3]),.T.))
	If lDispSB8
		nQtyStok := SaldoLote(SB1->B1_COD,IIF(SB1->B1_APROPRI=="I",cLocProc,RetFldProd(SB1->B1_COD,"B1_LOCPAD")),,,.F.,lConsVenc,,dDATABASE,,)
	Else
		While SB2->(!Eof() .And. SB2->(B2_FILIAL+B2_COD)==cFilSB2+aLotesTot[zi,1] .And. ;
			SB2->B2_LOCAL <= If(mv_par02==1,RetFldProd(aLotesTot[zi,1],"B1_LOCPAD"),aSav650[4]))
			If !lEmpPrj
				nQtdPrj := SB2->B2_QEMPPRJ
			EndIf
			nQtyStok += SaldoSB2(.T., , ,lConsTerc,lConsNPT,,,nQtdPrj)+SB2->B2_SALPEDI-SB2->B2_QEMPN+AvalQtdPre("SB2",2)
			nQtyStok += A650Prev(SB2->B2_COD)

			SB2->(DbSkip())
		EndDo
	EndIf

    If QtdComp(nQtyStok) > QtdComp(0)
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Verifica informacoes de maneira diferenciada quando produto  ³
		//³ utiliza controle de potencia identificada na estrutura.      ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

		aLoteTeste := {}

		For nCont := 1 TO LEN(aLotesUsado)
			If aLotesUsado[nCont,1] == aLotesTot[zi,1]
				AADD(aLoteTeste,{aLotesUsado[nCont,2], CriaVar("BF_NUMLOTE"), aLotesUsado[nCont,3], CriaVar("BF_NUMSERI"), aLotesUsado[nCont,4],0,aLotesUsado[nCont,5]})
			EndIf
		Next nCont

		If Empty(aLotesTot[zi,6]) .Or. !PotencLote(aLotesTot[zi,1])
			aRetorno:=SldPorLote(aLotesTot[zi,1],aLotesTot[zi,4],aLotesTot[zi,2],aLotesTot[zi,3],NIL,NIL,NIL,NIL,aTravSB2,.T.,;
										If(mv_par02==1 .Or. aLotesTot[zi,4] == cLocProc,NIL,aSav650[4]),nil,aLoteTeste,;
										If(SC2->C2_TPOP == "F",cMVQTDPREV=="S" .And. !PotencLote(aLotesTot[zi,1]),.T.),;
										dDataBase)
		Else
			aRetorno:=SldPorLote(aLotesTot[zi,1],aLotesTot[zi,4],999999999999999,999999999999999,NIL,NIL,NIL,NIL,NIL,.T.,;
										If(mv_par02==1 .Or. aLotesTot[zi,4] == cLocProc,NIL,aSav650[4]),nil,aLoteTeste,;
										If(SC2->C2_TPOP == "F",cMVQTDPREV=="S" .And. !PotencLote(aLotesTot[zi,1]),.T.),;
										dDataBase)
		EndIf
		For nCntFor := 1 To Len(aRetorno)
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Verifica se o endereco possui quantidade suficiente para atender o empenho. ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If lWmsNew .And. IntWMS(aLotesTot[zi,1])
				// Quando integrado ao WMS a função saldo por lote não retorna o endereço - Deve validar apenas Lote/SubLote
				nSldSBF := WmsSldD14(aLotesTot[zi,4],/*cEndereco*/,aLotesTot[zi,1],/*cNumSerie*/,aRetorno[nCntFor,1],aRetorno[nCntFor,2])
			Else
				nSldSBF := SaldoSBF(aLotesTot[zi,4], aRetorno[nCntFor,3], aLotesTot[zi,1])
			EndIf
	    	aRetorno[nCntFor,5] := Min(aRetorno[nCntFor,5],If(QtdComp(nQtyStok)<QtdComp(0),0,IIf(nSldSBF < nQtyStok, nQtyStok, nSldSBF)))
	    	aRetorno[nCntFor,6] := ConvUM(aLotesTot[zi,1],aRetorno[nCntFor,5],0,2)
	    	nQtyStok -= aRetorno[nCntFor,5]

	    	nIndice := ASCAN(aLotesUsado,{|x| x[1] == aLotesTot[zi,1] .And. x[2] == aRetorno[nCntFor,1] .And. x[3] == aRetorno[nCntFor,3] .And. x[5] == aRetorno[nCntFor,11] })
	    	If nIndice == 0
	    		AADD(aLotesUsado,{aLotesTot[zi,1],aRetorno[nCntFor,1],aRetorno[nCntFor,3],aRetorno[nCntFor,5],aRetorno[nCntFor,11]})
	    	Else
	    		aLotesUsado[nIndice,4] += aRetorno[nCntFor,5]
	    	EndIf
		Next nCntFor
	EndIf
	aLotesTot[zi,5] := ACLONE(aRetorno)
Next zi
SB2->(DbGoto(nRegSB2))

SB1->(dbSetOrder(1))

cPIFant := "N"

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Inicializa aCols                                             ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
dbSelectArea("SG1")
dbSetOrder(1)
dbSeek(cFilSG1+cProduto)
Do While !Eof() .And. SG1->G1_FILIAL+SG1->G1_COD == cFilSG1+cProduto

	If lA650VALES
		ExecBlock("A650VALEST",.F.,.F.,{cProduto,SG1->G1_COMP})
	EndIf

    //nQuantItem := Round(If(Empty(nQuantPai),0,ExplEstr(nQuantPai,SC2->C2_DATPRI,cOpcionais,cRevisao)),nDecSD4)
    cProOpcT := (cProOpc + Iif(lProj711 .And. (lMata712 .Or. lPCPA107) .And. Val(SG1->G1_NIV) > 1 .And. Len(cProOpc) == nTamProd,Space(nTamSeq),"") + SG1->G1_COMP + SG1->G1_TRT )

    If cRepGOPC == "S"
    	lVldOpc := .T.
		If ExistOpc(cOpcionais, SG1->G1_GROPC+SG1->G1_OPC, cProOpcT, SG1->G1_COMP + SG1->G1_TRT, aOpc)
			lVlOpc := .F.
		Else
			lVlOpc := .T.
		EndIf
	Else
		lVlOpc := .T.
	    If ! Empty(SG1->G1_GROPC+SG1->G1_OPC)
			If aOpc != Nil .And. Len(aOpc) > 0 .And. !Empty(aOpc[1])
				If (lProj711 .And. (lMata712 .Or. lPCPA107)) .Or. lValOpcVnd .Or. lGerOPI
					If ExistOpc(cOpcionais, SG1->G1_GROPC+SG1->G1_OPC, cProOpcT, SG1->G1_COMP + SG1->G1_TRT)
						lVlOpc := .F.
					Else
						lVlOpc := .T.
					EndIf
				Else
					If OpcSelec(cOpcionais, SG1->G1_GROPC+SG1->G1_OPC, cProOpc, SG1->G1_COMP + SG1->G1_TRT)
						lVlOpc := .F.
					Else
						lVlOpc := .T.
					EndIf
				EndIf
			Else
				If SG1->G1_GROPC+SG1->G1_OPC $ cOpcionais
					lVlOpc := .F.
				Else
					lVlOpc := .T.
				EndIf
			EndIf
		Else
			lVlOpc := .F.
		EndIf
	EndIf

   	nQuantItem := Round(If(Empty(nQuantPai),0,ExplEstr(nQuantPai,SC2->C2_DATPRI,cOpcionais,cRevisao, /*05*/, /*06*/, /*07*/, /*08*/, /*09*/, /*10*/, cProOpcT,/*12*/,lVlOpc )),nDecSD4)

 	nQtd2UM	   := ConvUM(SG1->G1_COMP,nQuantItem,0,2)
	nSldDisp   := 0
	nQtdDif	   := 0
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica informacoes de maneira diferenciada quando produto  ³
	//³ utiliza controle de potencia identificada na estrutura.      ³
	//³ Converte a quantidade necessaria sempre baseado na POTENCIA  ³
	//³ MAXIMA (100%)                                                ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	nPoten := SG1->G1_POTENCI
	If lA650POT
		nPoten := ExecBlock("A650POT",.F.,.F.)
        If ValType(nPoten) # "N"
            nPoten := SG1->G1_POTENCI
        EndIf
	EndIf

	If !Empty(nPoten) .And. PotencLote(SG1->G1_COMP) .And. QtdComp(nQuantItem,.T.) > QtdComp(0)
		lPotencia  :=.T.
		nQuantItem := Round(nQuantItem*(nPoten/100),nDecSD4)
		nQtd2UM    := ConvUM(SG1->G1_COMP,nQuantItem,0,2)
	ElseIf Empty(nPoten) .And. PotencLote(SG1->G1_COMP) .And. QtdComp(nQuantItem,.T.) > QtdComp(0)
		lPotencia  :=.T.
		nQuantItem := Round(nQuantItem*(100/100),nDecSD4)
		nQtd2UM    := ConvUM(SG1->G1_COMP,nQuantItem,0,2)
	Else
		lPotencia:=.F.
	EndIf

	SB1->(MsSeek(cFilSB1+SG1->G1_COMP))
	cDescB1:=SB1->B1_DESC
	If lProj711 .And. !RetFldProd(SG1->G1_COMP,"B1_MRP") $ " SE"
		 SG1->(DbSkip())
		 Loop
	EndIf

	//DMANSMARTSQUAD1-23697 - considerar PI como Fantasma quando parâmetro
 	//MV_GERAPI igual a F
	cPIFant := "N"
	If !lGERAPI
		cSG1Comp := SG1->G1_COMP
		aAreaSG1 := SG1->(GetArea())
		SG1->(dbSetOrder(1))
		SG1->(dbSeek(cFilSG1+cSG1Comp))
		lExistComp := .F.
		While SG1->(!Eof()) .And. SG1->G1_FILIAL == cFilSG1 .And. cSG1Comp == SG1->G1_COD
			lValidOk := .F.
			lRevOk   := .F.
			If SC2->C2_DATPRI <= SG1->G1_FIM .And. SC2->C2_DATPRI >=SG1->G1_INI
				lValidOk := .T.
			EndIf

			cRevisaoOk :=IIF(lPCPREVATU , PCPREVATU(SB1->B1_COD), SB1->B1_REVATU )/*SB1->B1_REVATU*/
			If PCPVldRev(SB1->B1_COD, cRevisaoOk)
				If SG1->G1_REVINI <= cRevisaoOk .And. SG1->G1_REVFIM >= cRevisaoOk
					lRevOk := .T.
				EndIf
			EndIf	

			If lValidOk .And. lRevOk
				lExistComp := .T.
				Exit
			Else
				SG1->(dbskip())
			EndIf
		End

		If lExistComp
			If !lGERAPI
				cPIFant := "S"
			EndIf
		EndIf
		SG1->(RestArea(aAreaSG1))
	EndIF

	If (RetFldProd(SB1->B1_COD,"B1_FANTASM") != "S" .and.  cPIFant != "S") // Projeto Implementeacao de campos MRP e FANTASM no SBZ
		If lEmpBN .Or. SB1->B1_TIPO != "BN"
			If QtdComp(nQuantItem,.T.) <= QtdComp(0)
				AADD(aCols,ARRAY(Len(aHeader)+1))
				aCols[Len(aCols),nPosCod  ] := SG1->G1_COMP
				aCols[Len(aCols),nPosQuant] := nQuantItem
				aCols[Len(aCols),nPosLocal] := If(SB1->B1_APROPRI=="I",cLocProc,RetFldProd(SB1->B1_COD,"B1_LOCPAD"))
				aCols[Len(aCols),nPosTRT  ] := SG1->G1_TRT
				aCols[Len(aCols),nPosLote  ]:= cD4NUMLOTE
				aCols[Len(aCols),nPosLotCtl]:= cD4LOTECTL
				aCols[Len(aCols),nPosdValid]:= dD4DTVALID
				aCols[Len(aCols),nPosPotenc]:= nD4POTENCI
				aCols[Len(aCols),nPosLocLz ]:= cDCLOCALIZ
				aCols[Len(aCols),nPosnSerie]:= cDCNUMSERI
				aCols[Len(aCols),nPosUM     ] := SB1->B1_UM
				aCols[Len(aCols),nPosQtSegum] :=nQtd2UM
				aCols[Len(aCols),nPos2UM    ] :=SB1->B1_SEGUM
				aCols[Len(aCols),nPosDescr  ] :=cDescB1
				aCols[Len(aCols),nPosIsAlt  ] :=STR0202
				aCols[Len(aCols),nPosTRTORI ] := SG1->G1_TRT
				If nPosOper > 0
					If Empty(cOperac) .Or. Empty(cRoteiro)
						If Empty(SC2->C2_ROTEIRO)
							SB1->(dbSeek(cFilSB1+SC2->C2_PRODUTO))
							cRoteiro := SB1->B1_OPERPAD
							If Empty(cRoteiro)
								cRoteiro := '01'
							Endif
						Else
							cRoteiro := SC2->C2_ROTEIRO
						Endif

						SGF->(dbSetOrder(2))
						If SGF->(dbSeek(xFilial("SGF") + SC2->C2_PRODUTO + cRoteiro + SG1->G1_COMP + SG1->G1_TRT))
							aCols[Len(aCols),nPosOper] := MATAFINDOP(SC2->C2_PRODUTO, cRoteiro, SGF->GF_OPERAC, SG1->G1_COMP)
						Else
							aCols[Len(aCols),nPosOper] := MATAFINDOP(SC2->C2_PRODUTO, cRoteiro, cOperac, SG1->G1_COMP)
						Endif
					Else
						aCols[Len(aCols),nPosOper] := MATAFINDOP(SC2->C2_PRODUTO, cRoteiro, cOperac, SG1->G1_COMP)
					EndIf
				EndIf
				If ValType(uConteudo) != "U"
					If !lMTA650AC .And. lMA650ACG
						For nAc := 1 To Len(uConteudo)
							nPosicao := aScan(aHeader,{|x| AllTrim(x[2]) == AllTrim(uConteudo[nAc][2])})
							aCols[Len(aCols), nPosicao] := &("SD4->" + AllTrim(uConteudo[nAc][2]))
						Next nAc
					Else
						aCols[Len(aCols), Len(aHeader)] := &(uTrans)
					EndIf
				EndIf

				aCols[Len(aCols),Len(aHeader)+1]:= .F.

				If (QtdComp(nQuantItem) == QtdComp(0)) .OR.;
					(cRevisao < SG1->G1_REVINI .OR. cRevisao > SG1->G1_REVFIM)
					AADD(aColsDele,Len(aCols))
				EndIf
				If lExistePE
					ExecBlock("A650ADCOL",.F.,.F.,{cProduto,nQuantPai,cOpcionais,cRevisao,SC2->C2_DATPRI})
				EndIf
				If !lGrvAllOpc	//Grava todos os opcionais no campo C2_OPC
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Incrementa variavel dos opcionais                            ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If !Empty(cOpcionais) .And. !Empty(SG1->G1_GROPC) .And. ;
						!Empty(SG1->G1_OPC) .And. (ExistOpc(cOpcionais,SG1->G1_GROPC+SG1->G1_OPC,cProOpc,SG1->G1_COMP + SG1->G1_TRT)) .And. ;
						!(SG1->G1_GROPC+SG1->G1_OPC $ cGravaOpc)
						cGravaOpc+=SG1->G1_GROPC+SG1->G1_OPC+"/"
					EndIf
				Endif

				AADD(aOpcCam,cProOpc + SG1->G1_COMP + SG1->G1_TRT)
				AADD(aRecNec,{SG1->G1_COMP, SG1->G1_TRT, SG1->G1_QUANT})
			Else
				If lExisGiEst // FieldPos("GI_ESTOQUE")
					//Estratégia de Estoque:
					//  1: Verifica o Produto Original, se não tiver saldo, verifica o Alternativo, se também não tiver saldo, compra/produz o Produto Original
					//  2: Verifica o Produto Original, se não tiver saldo, verifica o Alternativo, se também não tiver saldo, compra/produz o Alternativo
					//  3: Verifica o Alternativo, se não tiver saldo, compra/produz o Alternativo
					lEmpenOri := .T.
					lTemAlter := .F.
					SGI->(DbSetOrder(3))
					SGI->(MsSeek(cFilSGI+SG1->G1_COMP)) //GI_FILIAL+GI_PRODORI+GI_DATA
					If SGI->(!EOF()) .And. ;
						SGI->GI_FILIAL == cFilSGI .And. SGI->GI_PRODORI == SG1->G1_COMP .And. ;
						(Empty(SGI->GI_DATA) .Or. SGI->GI_DATA <= SC2->C2_DATPRI)

						lTemAlter := .T.
						If SGI->GI_ESTOQUE == '3'
							lEmpenOri := .F.
						EndIf
					EndIf
				EndIf

				If !lGrvAllOpc	//Grava todos os opcionais no campo C2_OPC
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Incrementa variavel dos opcionais                            ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If !Empty(cOpcionais) .And. !Empty(SG1->G1_GROPC) .And. ;
							!Empty(SG1->G1_OPC) .And. (ExistOpc(cOpcionais,SG1->G1_GROPC+SG1->G1_OPC,cProOpc,SG1->G1_COMP + SG1->G1_TRT)) .And. ;
							!(SG1->G1_GROPC+SG1->G1_OPC $ cGravaOpc)
						cGravaOpc+=SG1->G1_GROPC+SG1->G1_OPC+"/"
					EndIf
				Endif
				// Verifica se usa Rastro ou Localizacao Fisica
				// e se deve sugerir os lotes e localizacoes do empenho
				// Quando WMS novo neste ponto não deve sugerir o endereço, por isso não passa .T. para Localiza(cProduto,lWMS)
				If mv_par08 == 1 .And. (Rastro(SG1->G1_COMP) .Or. Localiza(SG1->G1_COMP));
						.And. lConsEst .And. QtdComp(SG1->G1_QUANT) > QtdComp(0)

					//Estratégia de estoque definida para considerar o estoque do Produto Origem
					If lEmpenOri
						nProcura := ASCAN(aLotesTot,{|x| x[1]== SG1->G1_COMP})
						If nProcura > 0
							aRetorno:=ACLONE(aLotesTot[nProcura,5])
							For zi:=1 to Len(aRetorno)
								If QtdComp(aRetorno[zi,5]) > QtdComp(0) .And. If(lPotencia,aRetorno[zi,12] > 0,.T.)
									//DMANSMARTSQUAD1-27617
									nProcACols := 0
									For nY := 1 To Len(aCols)
										If aCols[nY][nPosCod] == SG1->G1_COMP .And. aCols[nY][nPosTRT] == SG1->G1_TRT .And. aCols[nY][nPosLotCtl] == aRetorno[zi,1];
		   									.And. aCols[nY][nPosLote] == aRetorno[zi,2];
		   									.And. IIf(nPosLocLz>0,(aCols[nY][nPosLocLz] == aRetorno[zi,3] .And. aCols[nY][nPosnSerie] == aRetorno[zi,4]),.T.);
											.And. aCols[nY][nPosLocal] == aRetorno[zi,11]
											nProcACols := nY
											Exit
										EndIf
									Next nX

									If nProcACols > 0
										aCols[nProcACols,nPosQuant]   += aRetorno[zi,5]
										aCols[nProcACols,nPosQtSegum] += ConvUM(SG1->G1_COMP,aRetorno[zi,6],0,2)
										If lPotencia
											nQuantItem -= nQuantPot
											nQtd2UM    -= nQuantPot2
										Else
											nQuantItem -= aRetorno[zi,5]
											nQtd2UM    -= aRetorno[zi,6]
										EndIf
									Else
										AADD(aCols,ARRAY(Len(aHeader)+1))
										aCols[Len(aCols),nPosCod]   := SG1->G1_COMP
										If lPotencia
											// PRIMEIRA UNIDADE DE MEDIDA
											nQuantPot:=aRetorno[zi,5]*(aRetorno[zi,12]/100)
											aCols[Len(aCols),nPosQuant] := Min(nQuantPot,nQuantItem)
											nQuantPot:=aCols[Len(aCols),nPosQuant]
											aCols[Len(aCols),nPosQuant] := aCols[Len(aCols),nPosQuant]/(aRetorno[zi,12]/100)
											// SEGUNDA UNIDADE DE MEDIDA
											nQuantPot2:=aRetorno[zi,6]*(aRetorno[zi,12]/100)
											aCols[Len(aCols),nPosQtSegum] := Min(nQuantPot2,nQtd2UM)
											nQuantPot2:=aCols[Len(aCols),nPosQtSegum]
											aCols[Len(aCols),nPosQtSegum] := aCols[Len(aCols),nPosQtSegum]/(aRetorno[zi,12]/100)
										Else
											aCols[Len(aCols),nPosQuant] := Min(aRetorno[zi,5],nQuantItem)
											aCols[Len(aCols),nPosQtSegum]:=Min(aRetorno[zi,6],nQtd2UM)
										EndIf
										aCols[Len(aCols),nPosLocal] := aRetorno[zi,11]
										aCols[Len(aCols),nPosTRT]   := SG1->G1_TRT
										aCols[Len(aCols),nPosLote]  := aRetorno[zi,2]
										aCols[Len(aCols),nPosLotCtl]:= aRetorno[zi,1]
										aCols[Len(aCols),nPosdValid]:= aRetorno[zi,7]
										aCols[Len(aCols),nPosPotenc]:= aRetorno[zi,12]
										aCols[Len(aCols),nPosLocLz] := aRetorno[zi,3]
										aCols[Len(aCols),nPosnSerie]:= aRetorno[zi,4]
										If SB1->B1_COD <> SG1->G1_COMP
											SB1->(MsSeek(cFilSB1+SG1->G1_COMP))
										EndIf
										aCols[Len(aCols),nPosUM]    := SB1->B1_UM
										aCols[Len(aCols),nPos2UM]   := SB1->B1_SEGUM
										aCols[Len(aCols),nPosDescr] := cDescB1
										aCols[Len(aCols),nPosIsAlt] := STR0202
										aCols[Len(aCols),nPosTRTORI ] := SG1->G1_TRT
										If nPosOper > 0
											If Empty(cOperac) .Or. Empty(cRoteiro)
												If Empty(SC2->C2_ROTEIRO)
													SB1->(dbSeek(cFilSB1+SC2->C2_PRODUTO))
													cRoteiro := SB1->B1_OPERPAD
													If Empty(cRoteiro)
														cRoteiro := '01'
													Endif
												Else
													cRoteiro := SC2->C2_ROTEIRO
												Endif

												SGF->(dbSetOrder(2))
												If SGF->(dbSeek(xFilial("SGF") + SC2->C2_PRODUTO + cRoteiro + SG1->G1_COMP + SG1->G1_TRT))
													aCols[Len(aCols),nPosOper] := MATAFINDOP(SC2->C2_PRODUTO, cRoteiro, SGF->GF_OPERAC, SG1->G1_COMP)
												Else
													aCols[Len(aCols),nPosOper] := MATAFINDOP(SC2->C2_PRODUTO, cRoteiro, cOperac, SG1->G1_COMP)
												Endif
											Else
												aCols[Len(aCols),nPosOper] := MATAFINDOP(SC2->C2_PRODUTO, cRoteiro, cOperac, SG1->G1_COMP)
											EndIf
										EndIf
										If ValType(uConteudo) != "U"
											If !lMTA650AC .And. lMA650ACG
												For nAc := 1 To Len(uConteudo)
													nPosicao := aScan(aHeader,{|x| AllTrim(x[2]) == AllTrim(uConteudo[nAc][2])})
													aCols[Len(aCols), nPosicao] := &("SD4->" + AllTrim(uConteudo[nAc][2]))
												Next nAc
											Else
												aCols[Len(aCols), Len(aHeader)] := &(uTrans)
											EndIf
										EndIf

										aCols[Len(aCols),Len(aHeader)+1]:= .F.

										If (cRevisao < SG1->G1_REVINI .OR. cRevisao > SG1->G1_REVFIM)
											AADD(aColsDele,Len(aCols))
										EndIf

										If lExistePE
											ExecBlock("A650ADCOL",.F.,.F.,{cProduto,nQuantPai,cOpcionais,cRevisao,SC2->C2_DATPRI})
										EndIf
										If lPotencia
											nQuantItem -= nQuantPot
											nQtd2UM    -= nQuantPot2
										Else
											nQuantItem -= aCols[Len(aCols),nPosQuant]
											nQtd2UM    -= aCols[Len(aCols),nPosQtSegum]
										EndIf
										aRetorno[zi,5] -= aCols[Len(aCols),nPosQuant]
										aRetorno[zi,6] -= aCols[Len(aCols),nPosQtSegum]
										aLotesTot[nProcura,5] := ACLONE(aRetorno)

										AADD(aOpcCam,cProOpc + SG1->G1_COMP + SG1->G1_TRT)
										AADD(aRecNec,{SG1->G1_COMP, SG1->G1_TRT, SG1->G1_QUANT})
									EndIf
									If QtdComp(nQuantItem,.t.) <= QtdComp(0,.t.)
										Exit
									EndIf
								EndIf
							Next zi
						EndIf
					EndIf

					// Utiliza produtos alternativos (SGI)
					If lA650CALT
						lEmpAlt := .T.
						lEmpAlt :=!ExecBlock('A650CALT',.F.,.F.,{SG1->G1_COMP, nQtdDif, cProduto, nQuantPai, cLocProc,SC2->C2_DATPRI })

						If lEmpAlt
							A650EmpAlt(SG1->G1_COMP,nQtdDif,uConteudo,cLocProc,{cProduto,nQuantPai,cOpcionais,cRevisao,SC2->C2_DATPRI},SC2->C2_DATPRI,cOpcionais,cProOpc,@aOpcCam,cOperac,SG1->G1_TRT,cRevisao)
						EndIf
					Else
						If QtdComp(nQuantItem,.T.) > QtdComp(0)
							A650EmpAlt(SG1->G1_COMP,nQuantItem,uConteudo,cLocProc,{cProduto,nQuantPai,cOpcionais,cRevisao,SC2->C2_DATPRI},SC2->C2_DATPRI,cOpcionais,cProOpc,@aOpcCam,cOperac,SG1->G1_TRT,cRevisao)
						EndIf
					EndIf
				Else
					If SB1->B1_COD <> SG1->G1_COMP
						SB1->(MsSeek(cFilSB1+SG1->G1_COMP))
					EndIf
					// Calcula saldo disponivel para, se for o caso, utilizar alternativos (SGI)
					If lConsEst .And. SGI->(MsSeek(xFilial("SGI")+SG1->G1_COMP))
						//Estratégia de estoque definida para considerar o estoque do Produto Origem
						If lEmpenOri
							// Posiciona SB2
							If !lProj711
								//Verificar o parametro para consistir local padrão
								If mv_par02 == 1
									//Se utilizar local padrão a regra continua igual
									dbSelectArea("SB2")
									dbSetOrder(1)
									dbSeek(cFilSB2+SG1->G1_COMP+If(SB1->B1_APROPRI=="I",cLocProc,RetFldProd(SB1->B1_COD,"B1_LOCPAD")))
									If EOF()
										CriaSB2(SG1->G1_COMP,If(SB1->B1_APROPRI=="I",cLocProc,RetFldProd(SB1->B1_COD,"B1_LOCPAD")))
										MsUnlock()
									EndIf
									nQtdPrj := SB2->B2_QEMPPRJ
									nSldDisp := SaldoSB2(.T., , ,lConsTerc,lConsNPT,,,nQtdPrj)+SB2->B2_SALPEDI-SB2->B2_QEMPN+AvalQtdPre("SB2",2)
									nSldDisp += A650Prev(SB2->B2_COD)
								Else
									//Se não utilizar local padrão verificar os locais que deve considerar e verificar saldo nesses locais.
									nSldDisp1 := 0
									nSldDisp  := 0
									dbSelectArea("SB2")
									dbSetOrder(1)
									dbSeek(cFilSB2+SG1->G1_COMP+aSav650[3],.T.)
									While !Eof() .And. SB2->B2_FILIAL+SB2->B2_COD+SB2->B2_LOCAL <= cFilSB2+SG1->G1_COMP+aSav650[4]
										nQtdPrj := SB2->B2_QEMPPRJ
										nSldDisp1 := SaldoSB2(.T., , ,lConsTerc,lConsNPT,,,nQtdPrj)+SB2->B2_SALPEDI-SB2->B2_QEMPN+AvalQtdPre("SB2",2)
										nSldDisp1 += A650Prev(SB2->B2_COD)
										nSldDisp  += nSldDisp1
										dbSkip()
									End
								EndIf
							ElseIf lProj711 .And. !lMata712 .And. !lPCPA107
								nSldDisp := A650UsoSH5(SG1->G1_COD,SG1->G1_COMP,Space(Len(SG1->G1_COMP)),cOpcionais,A650DtoPer(SC2->C2_DATPRI),nQuantItem)
							ElseIf lMata712
								nSldDisp := A650UsoCZI(SG1->G1_COD,SG1->G1_COMP,Space(Len(SG1->G1_COMP)),cOpcionais,A650DtoPer(SC2->C2_DATPRI),nQuantItem)
							ElseIf lPCPA107
								nSldDisp := A650UsoSOQ(SG1->G1_COD,SG1->G1_COMP,Space(Len(SG1->G1_COMP)),cOpcionais,A650DtoPer(SC2->C2_DATPRI),nQuantItem)
							EndIf
						Else
							nSldDisp := 0
						EndIf

						//Michele
						//Verifica array de saldo do alternativo para descontar o que ja foi empenhado no nivel anterior
						If !lProj711 .And. !lMata712
							lExistEmSa := .F.

							For nInd := 1 to len(aAltSaldo)
			   					If aAltSaldo[nInd,1] == SG1->G1_COMP
				  					nSldDisp -= aAltSaldo[nInd,2]

			    					If nSldDisp <= 0
					 					nSldDisp := 0
				  					/*Else
										nSalDisAlt :=aAltSaldo[nInd,2]
										aAltSaldo[nInd,2] := nSalDisAlt + nSldDisp*/
								    EndIf

									lExistEmSa := .T.
				   					Exit
								EndIf
							Next nInd
						EndIf

						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³ Executa P.E. para tratar saldo disponivel.                    ³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						If lTA650SLD
							nQtdBack := nSldDisp
							nSldDisp := ExecTemplate("A650SALDO",.F.,.F.,nSldDisp)
							If ValType(nQtyStok) != "N"
								nSldDisp := nQtdBack
							EndIf
						EndIf
						If lBA650SLD
							nQtdBack := nSldDisp
							nSldDisp := ExecBlock("A650SALDO",.F.,.F.,nSldDisp)
							If ValType(nSldDisp) != "N"
								nSldDisp:=nQtdBack
							EndIf
						EndIf
					EndIf
					If nSldDisp > 0
						nQtdDif := Max(nQuantItem-nSldDisp,0)
					Else
						nQtdDif := Max(nQuantItem,0)
					EndIf
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//| Empenha o saldo que esta disponivel	|
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If nQtdDif < nQuantItem .OR. !lConsEst
						cLocalP		:=	If(SB1->B1_APROPRI=="I",cLocProc,RetFldProd(SB1->B1_COD,"B1_LOCPAD"))
						nAchaPrd := 0
						For nX := 1 To Len(aCols)

							If aCols[nX,nPosCod]+aCols[nX,nPosTRT]+ALLTRIM(aCols[nX,nPosOper])+ALLTRIM(aCols[nX,nPosLocal]) == ;
							SG1->G1_COMP+SG1->G1_TRT+AllTrim(cOperac)+AllTrim(cLocalP)
								If aScan(aColsDele,{|x| x == nX}) > 0
									nAchaPrd := 0
								Else
									nAchaPrd := nX
									Exit
								EndIf
							EndIf
						Next nX

						IF  nAchaPrd > 0
							aCols[nAchaPrd,nPosQuant] +=  nQuantItem
						ELSE
							AADD(aCols,ARRAY(Len(aHeader)+1))
							aCols[Len(aCols),nPosCod    ] := SG1->G1_COMP
							if !lConsEst
								aCols[Len(aCols),nPosQuant  ] := nQuantItem
							else
								aCols[Len(aCols),nPosQuant  ] := If(Empty(nQtdDif),nQuantItem,nSldDisp)
							EndIf
							aCols[Len(aCols),nPosLocal  ] := cLocalP //If(SB1->B1_APROPRI=="I",cLocProc,RetFldProd(SB1->B1_COD,"B1_LOCPAD"))
							aCols[Len(aCols),nPosTRT    ] := SG1->G1_TRT
							aCols[Len(aCols),nPosLote   ] := cD4NUMLOTE
							aCols[Len(aCols),nPosLotCtl ] := cD4LOTECTL
							aCols[Len(aCols),nPosdValid ] := dD4DTVALID
							aCols[Len(aCols),nPosPotenc ] := nD4POTENCI
							aCols[Len(aCols),nPosLocLz  ] := cDCLOCALIZ
							aCols[Len(aCols),nPosnSerie ] := cDCNUMSERI
							aCols[Len(aCols),nPosUM     ] := SB1->B1_UM
							aCols[Len(aCols),nPosQtSegum] := nQtd2UM
							aCols[Len(aCols),nPos2UM    ] := SB1->B1_SEGUM
							aCols[Len(aCols),nPosDescr  ] := cDescB1
							aCols[Len(aCols),nPosIsAlt  ] := STR0202
							aCols[Len(aCols),nPosTRTORI ] := SG1->G1_TRT
							If nPosOper > 0
								If Empty(cOperac) .Or. Empty(cRoteiro)
									If Empty(SC2->C2_ROTEIRO)
										SB1->(dbSeek(cFilSB1+SC2->C2_PRODUTO))
										cRoteiro := SB1->B1_OPERPAD
										If Empty(cRoteiro)
											cRoteiro := '01'
										Endif
									Else
										cRoteiro := SC2->C2_ROTEIRO
									Endif
									SGF->(dbSetOrder(2))
									If SGF->(dbSeek(xFilial("SGF") + SC2->C2_PRODUTO + cRoteiro + SG1->G1_COMP + SG1->G1_TRT))
										aCols[Len(aCols),nPosOper] := MATAFINDOP(SC2->C2_PRODUTO, cRoteiro, SGF->GF_OPERAC, SG1->G1_COMP)
									Else
									aCols[Len(aCols),nPosOper] := MATAFINDOP(SC2->C2_PRODUTO, cRoteiro, cOperac, SG1->G1_COMP)
									Endif
								Else
									aCols[Len(aCols),nPosOper] := MATAFINDOP(SC2->C2_PRODUTO, cRoteiro, cOperac, SG1->G1_COMP)
								EndIf
							EndIf
							If ValType(uConteudo) != "U"
								If !lMTA650AC .And. lMA650ACG
									For nAc := 1 To Len(uConteudo)
										nPosicao := aScan(aHeader,{|x| AllTrim(x[2]) == AllTrim(uConteudo[nAc][2])})
										aCols[Len(aCols), nPosicao] := &("SD4->" + AllTrim(uConteudo[nAc][2]))
									Next nAc
								Else
									aCols[Len(aCols), Len(aHeader)] := &(uTrans)
								EndIf
							EndIf

							aCols[Len(aCols),Len(aHeader)+1]:= .F.

							If (cRevisao < SG1->G1_REVINI .OR. cRevisao > SG1->G1_REVFIM)
								AADD(aColsDele,Len(aCols))
							EndIf

							AADD(aOpcCam,cProOpc + SG1->G1_COMP + SG1->G1_TRT)
							AADD(aRecNec,{SG1->G1_COMP, SG1->G1_TRT, SG1->G1_QUANT})
						Endif

						If lExistePE
							ExecBlock("A650ADCOL",.F.,.F.,{cProduto,nQuantPai,cOpcionais,cRevisao,SC2->C2_DATPRI})
						EndIf

						//Michele
						//Inclui alternativo e o saldo no array
						If !lProj711 .And. !lMata712 .And. !lExistEmSa .And. !lPCPA107
 							If SB1->B1_COD <> SG1->G1_COMP
								SB1->(MsSeek(cFilSB1+SG1->G1_COMP))
							EndIf
 							aadd(aAltSaldo,{SG1->G1_COMP,If(Empty(nQtdDif),nQuantItem,nSldDisp),If(SB1->B1_APROPRI=="I",cLocProc,RetFldProd(SB1->B1_COD,"B1_LOCPAD"))})

						ElseIf !lProj711 .And. !lMata712 .And. lExistEmSa .And. !lPCPA107
							aAltSaldo[nInd][2]	+= If(Empty(nQtdDif),nQuantItem,nSldDisp)

			 			EndIf
					EndIf

					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Utiliza produtos alternativos (SGI)	³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If lA650CALT
						lEmpAlt := .T.
						lEmpAlt :=!ExecBlock('A650CALT',.F.,.F.,{SG1->G1_COMP, nQtdDif, cProduto, nQuantPai, cLocProc,SC2->C2_DATPRI })

						If lEmpAlt
							A650EmpAlt(SG1->G1_COMP,nQtdDif,uConteudo,cLocProc,{cProduto,nQuantPai,cOpcionais,cRevisao,SC2->C2_DATPRI},SC2->C2_DATPRI,cOpcionais,cProOpc,@aOpcCam,cOperac,SG1->G1_TRT,cRevisao)
						EndIf
					Else
						If nQtdDif > 0 .And. lConsEst
							A650EmpAlt(SG1->G1_COMP,nQtdDif,uConteudo,cLocProc,{cProduto,nQuantPai,cOpcionais,cRevisao,SC2->C2_DATPRI},SC2->C2_DATPRI,cOpcionais,cProOpc,@aOpcCam,cOperac,SG1->G1_TRT,cRevisao)
						EndIf
					EndIf
				EndIf
			EndIf
		Endif
	Else
		If !lGrvAllOpc	//Grava todos os opcionais no campo C2_OPC
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Incrementa variavel dos opcionais dos componentes fantasmas  ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If !Empty(cOpcionais) .And. !Empty(SG1->G1_GROPC) .And. ;
					!Empty(SG1->G1_OPC) .And. (ExistOpc(cOpcionais,SG1->G1_GROPC+SG1->G1_OPC,cProOpc,SG1->G1_COMP + SG1->G1_TRT)) .And. ;
					!(SG1->G1_GROPC+SG1->G1_OPC $ cGravaOpc)
				cGravaOpc+=SG1->G1_GROPC+SG1->G1_OPC+"/"
			EndIf
		Endif
		nRecno:=SG1->(Recno())

		If Empty(SC2->C2_ROTEIRO)
			SB1->(dbSeek(cFilSB1+SC2->C2_PRODUTO))
			cRoteiro := SB1->B1_OPERPAD
			If Empty(cRoteiro)
				cRoteiro := '01'
			Endif
		Else
			cRoteiro := SC2->C2_ROTEIRO
		Endif

		If !lRecursivo
			SGF->(dbSetOrder(2))
			If SGF->(dbSeek(xFilial("SGF") + SC2->C2_PRODUTO + cRoteiro + SG1->G1_COMP + SG1->G1_TRT))
				cOperac := SGF->GF_OPERAC
			Endif
		EndIf

		If !cProOpcT $ cOpcionais
			cProOpcT := (cProOpc + SG1->G1_COMP + SG1->G1_TRT )
		EndIf

		If !(cRevisao < SG1->G1_REVINI .OR. cRevisao > SG1->G1_REVFIM)
			aAreaB1Fan := SB1->(GetArea())
			SB1->(dbSeek(cFilSB1+SG1->G1_COMP))
			If lPCPREVATU
				cRevFan := PCPREVATU(SB1->B1_COD)
			Else
				cRevFan := SB1->B1_REVATU
			EndIf

			If lFANREV				
				aRetPE := ExecBlock("A650FANREV",.F.,.F.,{cRevFan})
				If ValType(aRetPE) == "A" .And. !Empty(aRetPE[1])
					cRevFan := aRetPE[1]
				EndIf
			EndIf

			SB1->(RestArea(aAreaB1Fan))

			A650ACols(SG1->G1_COMP,nQuantItem,cOpcionais,lConsEst,,uConteudo,aHeader,cLocProc,cProOpcT,@aOpcCam,cOperac, .T.,@aMRPxJson,cRevFan,aOpc)
			//cOperac := ""
		EndIf

		If !lRecursivo
			cOperac := Criavar("D4_OPERAC",.F.)
		EndIf

		SG1->(dbGoto(nRecno))
		SC2->(dbGoto(nSC2Recno))
	EndIf
	dbSelectArea("SG1")
	dbSkip()

	IF SG1->G1_NIV = '01'
		cOperac := ""
	ENDIF

EndDo

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Grava opcionais corretos na Ordem de Producao                ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
SB1->(MsSeek(cFilSB1+cProduto))

SC2->(dbGoto(nSC2Recno))
If !lGrvAllOpc
	If ! (Empty(cGravaOpc) .And. RetFldProd(SB1->B1_COD,"B1_FANTASM") == "S" )
		Reclock("SC2",.F.)
		If !Empty( cOpcionais )
			If aScan(aOPOpc,SC2->(C2_FILIAL+C2_NUM+C2_ITEM+C2_SEQUEN)) == 0
				If !(lProj711 .And. (lMata712 .Or. lPCPA107) .And. !Empty(SC2->C2_OPC) .And. Empty(cGravaOpc))
					Replace	SC2->C2_OPC	With cGravaOpc
					If lIntNewMRP ////Integração de ordem de produção com o novo MRP.
						A650AddJIn(@aMRPxJson) //Inclui dados no array para integração com o novo MRP
					EndIf
				EndIf
				AADD(aOPOpc,SC2->(C2_FILIAL+C2_NUM+C2_ITEM+C2_SEQUEN))
			Else
				If (lProj711 .And. (lMata712 .Or. lPCPA107))
					If !Empty(cGravaOpc) .And. !(cGravaOpc $ cOpcionais)
						SC2->C2_OPC	:= Alltrim(SC2->C2_OPC)+cGravaOpc
						If lIntNewMRP ////Integração de ordem de produção com o novo MRP.
							A650AddJIn(@aMRPxJson) //Inclui dados no array para integração com o novo MRP
						EndIf
					EndIf
				Else
					//Essa lógica foi criada para que os opcionais não sejam repitidos
					//no campo SC2->C2_OPC,  para evitar ultrapassar o limite do campo de opcionais.
					For nI:= 1 To Len(cGravaOpc)
						If nI == 1
						   	cString :=	substr(cGravaOpc,1,(nTamGropc+nTamOpc))
							nI := nI + nTamGropc+nTamOpc
						else
						   	cString :=	substr(cGravaOpc,nI ,(nTamGropc+nTamOpc))
							nI := nI + nTamGropc+nTamOpc
						EndIf

						If !Empty(cString) .And. !(cString $ SC2->C2_OPC)
							SC2->C2_OPC	:= Alltrim(SC2->C2_OPC) + cString + "/"
							If lIntNewMRP ////Integração de ordem de produção com o novo MRP.
								A650AddJIn(@aMRPxJson) //Inclui dados no array para integração com o novo MRP
							EndIf
						EndIf
					Next nI

				EndIf
			EndIf
		Else
			If !(lProj711 .And. (lMata712 .Or. lPCPA107) .And. !Empty(SC2->C2_OPC) .And. Empty(cGravaOpc))
				Replace	SC2->C2_OPC	With cGravaOpc
				If lIntNewMRP ////Integração de ordem de produção com o novo MRP.
					A650AddJIn(@aMRPxJson) //Inclui dados no array para integração com o novo MRP
				EndIf
			EndIf
		EndIf
		MsUnlock()
	EndIf
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ PE apos a gravacao dos opcionais da Ordem de Producao        ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lA650GRVOPC
	ExecBlock("A650GRVOPC",.F.,.F.,cOpcionais)
Endif

dbSelectArea(cAlias)
RETURN NIL

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³A650ChkComp³ Autor ³ Edson Maricate        ³ Data ³31.08.99 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Verifica a situacao das SCs e AEs da OP.                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA650                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function A650ChkComp(cNumOp,cItemOp,cSequen,cItemGrd)
Local aArea		:= GetArea()
Local lDelOpSC	:= If(SuperGetMV("MV_DELOPSC")=="S",.T.,.F.)
Local lRet		:= .T.
Local cOp
Local aOps
Local nLoop
Local cFilSC2 := xFilial("SC2")
Local cFilSC1 := xFilial("SC1")
Local cFilSC7 := xFilial("SC7")

aOps := A650OpsPis(cNumOp+cItemOp+cSequen+cItemGrd)

For nLoop := 1 to Len(aOps)
	dbSelectArea("SC2")
	dbSetOrder(1)
	If dbSeek(cFilSC2+aOps[nLoop])
		cOp := SC2->C2_NUM+SC2->C2_ITEM+SC2->C2_SEQUEN+SC2->C2_ITEMGRD
		dbSelectArea("SC1")
		dbSetOrder(4)
		dbSeek(cFilSC1+cOp)
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Verifica a existencia de PCs e gera um aviso, pois os PCs    ³
		//³ ja podem estar em fase de entrega.                           ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		While lRet .And. !EOF() .And. C1_FILIAL+C1_OP == cFilSC1+cOp
			//"Aten‡Æo"#"Esta operacao ira excluir a SC "#" que possui amara‡ao com o PC "
			lRet := SC1->C1_QUJE <= 0 .Or.;			//-- Se solicitação em aberto ou
				(IsBlind() .And. lDelOpSC) .Or.;	//-- Em job (ex: MRP) e MV_DELOPSC permite exlcusão ou
				(Aviso(STR0024,STR0056+AllTrim(SC1->C1_NUM)+"/"+AllTrim(SC1->C1_ITEM)+STR0057+AllTrim(SC1->C1_PEDIDO)+"/"+AllTrim(SC1->C1_ITEMPED)+".",If(lDelOpSC,{STR0060,STR0059},{STR0060})) == 2)  //-- Usuario confirmou
			dbSkip()
		End
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Verifica a existencia de AEs e gera um aviso, pois as AEs    ³
		//³ ja podem estar em fase de entrega.                           ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		dbSelectArea("SC7")
		dbSetOrder(8)
		dbSeek(cFilSC7+cOp)
		While lRet .And. !EOF() .And. C7_FILIAL+C7_OP == cFilSC7+cOp
			If SC7->C7_TIPO == 2 .And. SC7->C7_QUJE+SC7->C7_QTDACLA > 0
				// "Aten‡Æo"#"A exclus„o desta OP implicara na exclus„o da Autorizacao de Entrega "
				lRet := (IsBlind() .And. lDelOpSC) .Or.;	//-- Em job (ex: MRP) e MV_DELOPSC permite exlcusão ou
						(Aviso(STR0024,STR0058+AllTrim(SC7->C7_NUM)+"/"+AllTrim(SC7->C7_ITEM)+".",If(lDelOpSC,{STR0060,STR0059},{STR0060})) == 2) //-- Usuário confirmou
			EndIf
			dbSkip()
		End
	EndIf
Next

SC1->(dbSetOrder(1))
SC7->(dbSetOrder(1))
RestArea(aArea)
RETURN lRet

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³A650Legend³Rev.   ³ Edson Maricate        ³ Data ³29.07.2000 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Demonstra a legenda das cores da mbrowse                     ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³Nenhum                                                       ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nenhum                                                       ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Esta rotina monta uma dialog com a descricao das cores da    ³±±
±±³          ³Mbrowse.                                                     ³±±
±±³          ³                                                             ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Materiais                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function A650Legend()
BrwLegenda(cCadastro,STR0064,aLegenda) //"Legenda"
Return(.T.)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³A650ConvUM³Autor  ³ Patricia A. Salomao   ³ Data ³ 28/12/00 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Converte as Unidades de Medida                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametro ³ Unidade de Medida a ser convertida (1/2)                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ Logico                                                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ MATA650                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/

Function A650ConvUm(nUnid)
LOCAL lRet:=.T.
LOCAL nPosQTD,nPosQTDSeg
If nUnid == 2
	nPosQTDSeg := AsCan(aHeader,{|x|x[2]=="D4_QTSEGUM"})
	aCols[n,nPosQTDSeg]  := ConvUm(aCols[n,1],M->D4_QUANT,aCols[n,nPosQTDSeg],nUnid)
	lRet:= !Empty(&(ReadVar()))
Else
	nPosQTD := AsCan(aHeader,{|x|x[2]=="D4_QUANT"})
	aCols[n,nPosQTD]   := ConvUm(aCols[n,1],aCols[n,nPosQTD],M->D4_QTSEGUM,nUnid)
	lRet:= !Empty(aCols[n,nPosQTD])
EndIf
Return lRet


/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³A650VlQtNg³Autor  ³ Erike Yuri da Silva   ³ Data ³ 20/04/05 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Valida quantidade digitada para empenho na Alteracao de Emp³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ Logico                                                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ MATA650                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function A650VlQtNg()
Local lRet	   := .T.

If !SuperGetMv("MV_NEGESTR") .AND. M->D4_QUANT < 0
	MsgAlert(STR0106 + ; 		//"Para que seja permitido a inclusao de quantidades negativas '
		STR0107,STR0108)	//"sera necessario alterar o parametro 'MV_NEGESTR'!"###"Aviso"
	lRet := .F.
EndIf
Return lRet

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³aProdGrade³ Autor ³Patricia A. Salomao    ³ Data ³03/2001   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Efetua a Valida‡„o do Codigo do Produto e Inicializa as     ³±±
±±³          ³variaveis do acols da Grade.                                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpC1: Codigo do Produto                                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpL1: Logico (Se o Produto ‚ valido ou nao)                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³Mata650 / Mata250                                           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³   DATA   ³ Programador   ³Manutencao Efetuada                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³               ³                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/

Function aProdGrade(cProduto)

Local lRetorno		:= .T.
Local lReferencia	:= .F.
DEFAULT cProduto	:= &(ReadVar())

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Verifica se a grade esta ativa e se o produto digitado eh uma referencia³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If MatGrdPrrf(@cProduto)
	lReferencia := .T.
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Monta o AcolsGrade e o AheadGrade para este item     ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	oGrade:MontaGrade(1,cProduto,.T.,,lReferencia)
EndIf

dbSelectArea("SB1")
dbSetOrder(1)
If ( !dbSeek(xFilial("SB1")+cProduto,.F.) )
	If !(lReferencia .And. MatOrigGrd() == "SBQ") //Aqui eh feita esta analise,pois nao existe garantia que o codigo exista pelo config. prod.		Help(" ",1,cCampo)
		lRetorno	 := .F.
	EndIf
EndIf
Return(lRetorno)

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³A650Campos³ Autor ³Patricia A. Salomao    ³ Data ³14.03.2001³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Inicializa alguns campos baseando-se no SB1                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ Nenhum                                                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ??ÄÄÄÄ´±±
±±³   DATA   ³ Programador   ³Manutencao Efetuada                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³               ³                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function a650Campos(lRefresh)
DEFAULT lRefresh := .F.

If lRefresh
	If Empty(M->C2_LOCAL) .Or. Empty(M->C2_UM) .Or. Empty(M->C2_SEGUM)
		SB1->( DbSetOrder(1) )
		MsSeek(xFilial("SB1")+Rtrim(M->C2_PRODUTO))

		M->C2_LOCAL := Iif(Empty(M->C2_LOCAL),RetFldProd(SB1->B1_COD,"B1_LOCPAD"),M->C2_LOCAL)
		M->C2_UM    := SB1->B1_UM
		M->C2_SEGUM := SB1->B1_SEGUM
	EndIf
Else
	M->C2_LOCAL := RetFldProd(SB1->B1_COD,"B1_LOCPAD")
	M->C2_UM    := SB1->B1_UM
	M->C2_SEGUM := SB1->B1_SEGUM
EndIf
Return .T.

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³aVldGrade ³ Autor ³Patricia A. Salomao    ³ Data ³03/2001   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Valida o produto e os valores informados na Grade.          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpC1 - Programa                                            ³±±
±±³          ³ExpC2 - Nome do Campo                                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpL1: Logico                                               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³Mata650 / Mata250                                           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³   DATA   ³ Programador   ³Manutencao Efetuada                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³               ³                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/

Function aVldGrade(cProg, cCampo)    //--> Atencao: cCampo eh so usado para manter o legado da funcao antiga chamada no final
Local lRet  	:=.T.
Local nColuna	:= aScan(aHeader,{|x| AllTrim(x[2]) == AllTrim(Substr(Readvar(),4))})
Local cProdGrd	:= ""
Local aAreaSC2  := ''
Local lAchou    := .F.
Local cNum, cItem, cSeq
Local nQtde := 0

DEFAULT cProg	:= ''

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ ATENCAO: A verificacao de existencia do produto no SB1 e se o mesmo eh ³
//³          referencia, eh analisada no proprio objeto.                   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
cProdGrd := oGrade:GetNameProd(NIL,n,nColuna)


//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ No Apontamento da Producao, verificar se o produto informado na grade, ³
//³ faz parte da Ordem de Producao informada.                              ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lRet .and. cProg == "A250"
	dbSelectArea("SC2")
	aAreaSC2 := SC2->(GetArea())
	dbSetOrder(6)
	dbSeek(xFilial("SC2")+Alltrim(M->D3_OP)+cProdGrd)
	cNum  := SC2->C2_NUM
	cItem := SC2->C2_ITEM
	cSeq  := SC2->C2_SEQUEN
	lAchou := .F.
	Do While !Eof() .And. C2_FILIAL+C2_NUM+C2_ITEM+C2_SEQUEN == xFilial("SC2")+cNum+cItem+cSeq
		If SC2->C2_PRODUTO == cProdGrd .And. !Empty(SC2->C2_DATRF)
			Help(" ",1, "A250JAPROD")
			lRet := .F.
			Exit
		EndIf
		lAchou := .T.
		dbSkip()
	EndDo
	If !lAchou
		Help(" ",1, "A250NOGRD")
		lRet := .F.
	EndIf
	If oGrade:cCpo == "D3_PARCTOT"
		If !Alltrim(&(Readvar())) $"PT"
			Help(" ",1, "A250PARTOT")
			lRet := .F.
		EndIF
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Nao deixar alterar na grade, a qtde. da 2a. UM, se o produto nao tiver 2a. UM ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If oGrade:cCpo == "D3_QTSEGUM" .And. Empty(SB1->B1_SEGUM)
		Help(" ",1,"A250NO2UM")
		lRet := .F.
	EndIf
	RestArea(aAreaSC2)
EndIf

If lRet .and. cProg == "A650"
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Nao deixar alterar na grade, a qtde. da 2a. UM, se o produto nao tiver 2a. UM ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If oGrade:cCpo == "C2_QTSEGUM" .And. Empty(SB1->B1_SEGUM)
		Help(" ",1,"A250NO2UM")
		lRet := .F.
	Endif

	If lRet .And. Inclui
		If "C2_QUANT" == oGrade:cCpo
			nQtde := &(ReadVar())
		ElseIf "C2_QTSEGUM" == oGrade:cCpo
			nQtde := ConvUm(cProdRef,0,&(ReadVar()),1)
		EndIf

		lRet := SeleOpc(1,"MATA650",cProdGrd,.T.,,,"M->C2_PRODUTO",,nQtde,M->C2_DATPRI,M->C2_REVISAO)
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Adiciona o opcional do produto no aCols                                ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

		If !Empty(M->C2_OPC)
			oGrade:aColsGrade[oGrade:nPosLinO][n][nColuna][oGrade:GetFieldGrdPos("C2_OPC")] := M->C2_OPC
			M->C2_OPC := " "
		EndIf
	EndIf
EndIF
Return(lRet)

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³aQtdGrade ³ Autor ³ Patricia A. Salomao   ³ Data ³03/2001   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Se a Grade estiver ativa, efetua a entrada de dados,na colu-³±±
±±³          ³na de Quantidade.                                           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpL1 - Se Mostra ou Nao a GetDados                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Sempre .T.                                                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³Mata650 / Mata250                                           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³   DATA   ³ Programador   ³Manutencao Efetuada                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³22/07/2006³Erike Yuri     ³Alteracao da funcao de entrada de dados de  ³±±
±±³          ³               ³grade, para rotina generica tipo objeto     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function aQtdGrade(lMostra)

Local nPosCpo	:= 0
Local cProdRef
Local lRet      := .T.
Local lContinua	:= .T.
Local aGrade    := {}
Local cCpoName	:= StrTran(Readvar(),"M->","")
Local lGrade    := MaGrade()
Local cProg     := ''
Local l250650   := .F.
Local lGrdDisp  := .F.

DEFAULT lMostra := .T.

If !If(Type('l250')=="L",l250,.F.) .And. !If(Type('l650')=="L",l650,.F.)
	Return lRet
EndIf

If lGrade
	//-- Verifica se a funcao foi chamada do MATA250 ou do MATA650
	If Type('l250')=='L' .And. l250
		cProg   := 'A250'
		l250650 := .T.
	ElseIf Type('l650')=='L' .And. l650
		cProg   := 'A650'
		l250650 := .T.
	EndIf

	If cProg == "A650"
		cProdRef		:= M->C2_PRODUTO
		lContinua		:= MatGrdPrRf(@cProdRef)
	ElseIF cProg == "A250"
		If Empty(M->D3_OP)
			lRet 		:= .F.
			lContinua   := .F.
		Else
			cProdRef		:= M->D3_COD
			lContinua		:= MatGrdPrRf(@cProdRef)
		EndIf
	EndIf
EndIf

If lGrade .And. lContinua
	//Faz backup so do acols usado no MATA250  e movimentacoes
	aGrade    := aClone(aCols)

	oGrade:cProdRef := cProdRef
	oGrade:lShowGrd := lMostra
	oGrade:nPosLinO := 1
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica se a grade esta ativa                       ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lRet .And. l250650
		If cProg == "A250"
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³No Apontamento da Producao,carrega a coluna de quantidade da grade,de acordo com o³
			//³ retorno de oGrade:EmptyGrd:                                                      ³
			//³Se True : Traz na Coluna de Quantidade os valores de C2_QUANT-C2_QUJE-C2_PERDA    ³
			//³Se False: Traz na Coluna de Quantidade, as qtdes. digitadas.                      ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			a250Insere(ReadVar(),oGrade:EmptyGrd("D3_QUANT"))
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Chama grade para alteracao de informacoes                              ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		dbSelectArea("SB1")
		dbSetOrder(1)
		MsSeek(xFilial("SB1")+cProdRef)
		While ( !Eof() .And. SB1->B1_FILIAL == xFilial("SB1") .And.;
				SubStr(SB1->B1_COD,1,Len(cProdRef)) == cProdRef )
				//B1_MSBLQL
				If RegistroOk("SB1",.F.)
					lGrdDisp := .T.
				EndIf
				DbSkip()
		EndDo
		If lGrdDisp
			If oGrade:Show( cCpoName )

				If cProg == "A650"
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Atualiza as quantidades                               ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³Atualiza a quantidade do Get   original                                 ³
					//³ATENCAO: a variavel nQtdInformada foi alimentada dentro do objeto com   ³
					//³         ReadVar(), mas o programador pode alimentala quando desejar.   ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					DO CASE
						//POSICIONADO NA QUANTIDADE DA OP
			        	CASE "C2_QUANT" $ cCpoName
							M->C2_QUANT 			:= oGrade:nQtdInformada  //Quant. 1a UM
							oGrade:nQtdInformada	:= 0
							oGrade:nQtdInformada	:= oGrade:SomaGrade("C2_QTSEGUM",oGrade:nPosLinO,oGrade:nQtdInformada)
							M->C2_QTSEGUM			:= oGrade:nQtdInformada // Quant. 2a UM

						//POSICIONADO NA QUANTIDADE DA SEGUNDA UN DA OP
						CASE "C2_QTSEGUM" $ cCpoName
							M->C2_QTSEGUM 			:= oGrade:nQtdInformada  //Quant. 2a UM
							oGrade:nQtdInformada	:= 0
							oGrade:nQtdInformada	:= oGrade:SomaGrade("C2_QUANT",oGrade:nPosLinO,oGrade:nQtdInformada)
							M->C2_QUANT				:= oGrade:nQtdInformada // Quant. 1a UM
					ENDCASE


					//-- Verifica se deve atualizar os campos obrigatorios.
                    If !Empty(M->C2_QUANT) .And. ( Empty(M->C2_LOCAL) .Or. Empty(M->C2_UM) )

                    	SB1->( DbSetOrder(1) )
	                    If MsSeek(xFilial("SB1")+RTrim(M->C2_PRODUTO),.F.)
	                    	If Empty(M->C2_LOCAL)
								M->C2_LOCAL := RetFldProd(SB1->B1_COD,"B1_LOCPAD")
								If (nPosCpo := Ascan(aGets,{ |x| Subs(x,9,8) == "C2_LOCAL" } )) > 0
									aTela[Val(Subs(aGets[nPosCpo],1,2))][Val(Subs(aGets[nPosCpo],3,1))*2] := RetFldProd(SB1->B1_COD,"B1_LOCPAD")
								EndIf
							EndIf

							If Empty(M->C2_CC)
								M->C2_CC := B1_CC
								If (nPosCpo := Ascan(aGets,{ |x| Subs(x,9,5) == "C2_CC" } )) > 0
									aTela[Val(Subs(aGets[nPosCpo],1,2))][Val(Subs(aGets[nPosCpo],3,1))*2] := B1_CC
								EndIf
							EndIf

							If Empty(M->C2_UM)
								M->C2_UM := B1_UM
								If (nPosCpo := Ascan(aGets,{ |x| Subs(x,9,5) == "C2_UM" } )) > 0
									aTela[Val(Subs(aGets[nPosCpo],1,2))][Val(Subs(aGets[nPosCpo],3,1))*2] := B1_UM
								EndIf
							EndIf

							If Empty(M->C2_SEGUM)
								M->C2_SEGUM := B1_SEGUM
								If (nPosCpo := Ascan(aGets,{ |x| Subs(x,9,5) == "C2_SEGUM" } )) > 0
									aTela[Val(Subs(aGets[nPosCpo],1,2))][Val(Subs(aGets[nPosCpo],3,1))*2] := B1_SEGUM
								EndIf
							EndIf

					        If Empty(M->C2_PRIOR)
								If (nPosCpo := Ascan(aGets,{ |x| Subs(x,9,8) == "C2_PRIOR" } ) ) > 0
									M->C2_PRIOR := "500"
									aTela[Val(Subs(aGets[nPosCpo],1,2))][Val(Subs(aGets[nPosCpo],3,1))*2] := "500"
								EndIf
							EndIf

							If Empty(M->C2_REVISAO)
								If (nPosCpo := Ascan(aGets,{ |x| Subs(x,9,10) == "C2_REVISAO" } ) ) > 0
									M->C2_REVISAO := IIF(lPCPREVATU , PCPREVATU(SB1->B1_COD), SB1->B1_REVATU )/*SB1->B1_REVATU*/
									aTela[Val(Subs(aGets[nPosCpo],1,2))][Val(Subs(aGets[nPosCpo],3,1))*2] := M->C2_REVISAO
								EndIf
							EndIf

						  EndIf
	                EndIf


				ElseIf cProg  == "A250"
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³Atualiza a quantidade do Get   original                                 ³
					//³ATENCAO: a variavel nQtdInformada foi alimentada dentro do objeto com   ³
					//³         ReadVar(), mas o programador pode alimentala quando desejar.   ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					DO CASE
						//POSICIONADO NA QUANTIDADE DA PRODUCAO
			        	CASE "D3_QUANT" $ cCpoName
							M->D3_QUANT 			:= oGrade:nQtdInformada  //Quant. 1a UM
							oGrade:nQtdInformada	:= 0
							oGrade:nQtdInformada	:= oGrade:SomaGrade("D3_QTSEGUM",oGrade:nPosLinO,oGrade:nQtdInformada)
							M->D3_QTSEGUM			:= oGrade:nQtdInformada // Quant. 2a UM

						//POSICIONADO NA QUANTIDADE DA SEGUNDA UN DA PRODUCAO
						CASE "D3_QTSEGUM" $ cCpoName
							M->D3_QTSEGUM 			:= oGrade:nQtdInformada  //Quant. 2a UM
							oGrade:nQtdInformada	:= 0
							oGrade:nQtdInformada	:= oGrade:SomaGrade("D3_QUANT",oGrade:nPosLinO,oGrade:nQtdInformada)
							M->D3_QUANT				:= oGrade:nQtdInformada // Quant. 1a UM
					ENDCASE

					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³Se for alterada a quantidade dos Itens, atualizar o tipo da Baixa dos mesmos (Parcial/Total)³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If !oGrade:EmptyGrd("D3_PARCTOT") .And. lMostra
						aParcTot("A250",.F.)
					EndIf
				EndIf
			EndIf
		Else
			cMsg := STR0203 + CHR(10) //"Nenhum produto da grade está disponível."
			Aviso(STR0186,cMsg,{"Ok"},3)
			lRet := .F.
		EndIf
	EndIf
EndIf
Return lRet


/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³Ma650GraGr³ Autor ³Patricia A. Salomao    ³ Data ³03/2001   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Grava os Itens Digitados na Grade                           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpC1 - Alias do Arquivo                                    ³±±
±±³          ³ExpC2 - Nome do Programa                                    ³±±
±±³          ³ExpL1 - Flag que indica se grava ou nao                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Array - [1]:Produto Referencia, [2]:Item da grade           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³Mata650 / Mata250                                           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³   DATA   ³ Programador   ³Manutencao Efetuada                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³               ³                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/

Function Ma650GraGr(cAlias,cProg,lGrava)
Local aArea
Local aAreaSC2 	:= SC2->(GetArea())
Local nColuna	:= 0
Local nLinha	:= 0
Local cItemGrd 	:= Replicate("0",Len(SC2->C2_ITEMGRD))
LOCAL bCampo 	:= {|nCPO| Field(nCPO) }
Local cProdRef	:= ""
Local cOpc		:= " "
Local cRoteiro	:= ""
Local cParcTot	:= ""
Local nPerda	:= 0
Local nQuant	:= 0
Local nQuant2UM	:= 0
Local nRegSC2	:= 0
Local nRegSD3	:= 0
Local i			:= 0
Local aRet		:= {}
Local nLinAcols := 1
Local cFilSC2   := ""
Local cOPGerada := ""

DEFAULT lGrava := .T.

If lGrava
	dbSelectArea(cAlias)
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Salva a integridade dos campos de Bancos de Dados            ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	FOR i := 1 TO FCount()
		M->&(EVAL(bCampo,i)) := FieldGet(i)
	NEXT i
	dbSelectArea(cAlias)
	aArea :=GetArea()
EndIf

cFilSC2 := xFilial("SC2")
For nLinha:=1 to Len(oGrade:aColsGrade[nLinAcols])
	For nColuna:=2 to Len(oGrade:aHeadGrade[nLinAcols])

		DO CASE
			CASE cProg == "A250"
				nPerda := oGrade:aColsFieldByName("D3_PERDA",nLinAcols,nLinha,nColuna)

				If oGrade:aColsFieldByName("D3_QUANT",nLinAcols,nLinha,nColuna)+ nPerda > 0
					If lGrava
						cProdRef := Substr(M->D3_COD,1,oGrade:TamRef())
					Else
						cProdRef := M->D3_COD
					EndIf
					MatGrdPrrf(@cProdRef)
					cProdRef := oGrade:GetNameProd(cProdRef,nLinha,nColuna)

					nQuant    := oGrade:aColsFieldByName("D3_QUANT"		,nLinAcols,nLinha,nColuna)
					nQuant2UM := oGrade:aColsFieldByName("D3_QTSEGUM"	,nLinAcols,nLinha,nColuna)
		            cParcTot  := oGrade:aColsFieldByName("D3_PARCTOT"	,nLinAcols,nLinha,nColuna)

					nRegSD3 += 1
					dbSelectArea("SC2")
					dbSetOrder(6)
					SC2->(dbSeek(cFilSC2+Substr(M->D3_OP,1,11)+cProdRef))
					cItemGrd := SC2->C2_ITEMGRD
					dbSetOrder(aAreaSC2[2])
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Altera os dados do 1o Item (Produto Referencia) e inclui os  ³
					//³ outros Itens da Grade                                        ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If lGrava
						RecLock(cAlias,If(nRegSD3 == 1,.F.,.T.))
					EndIf

					If lGrava
						For i := 1 TO FCount()
							FieldPut(i,M->&(EVAL(bCampo,i)))
						Next i
						SD3->D3_COD		:= cProdRef
						SD3->D3_QUANT	:= nQuant
						SD3->D3_OP		:= Substr(M->D3_OP,1,11)+cItemGrd
						SD3->D3_PARCTOT := If(cParcTot$"PT",cParcTot,If(cParcTot$"X","T"," "))
						SD3->D3_PERDA	:= oGrade:aColsFieldByName("D3_PERDA",nLinAcols,nLinha,nColuna)
						SD3->D3_QTSEGUM	:= ConvUM(SC2->C2_PRODUTO,nQuant,nQuant2UM,2)
					Else
						// Retorna codigo de produto e item de grade
						If !Empty(cProdRef)
							aRet    := {cProdRef,cItemGrd}
							Exit
						EndIf
					EndIf
				EndIf

			CASE cProg == "A650"
				If oGrade:aColsFieldByName("C2_QUANT",nLinAcols,nLinha,nColuna)+ nPerda > 0
					If lGrava
						cProdRef := Substr(M->C2_PRODUTO,1,oGrade:TamRef())
					Else
						cProdRef := M->C2_PRODUTO
					EndIf
					MatGrdPrrf(@cProdRef)
					cProdRef := oGrade:GetNameProd(cProdRef,nLinha,nColuna)

					nQuant    := oGrade:aColsFieldByName("C2_QUANT"		,nLinAcols,nLinha,nColuna)
					nQuant2UM := oGrade:aColsFieldByName("C2_QTSEGUM"	,nLinAcols,nLinha,nColuna)
					cOpc      := oGrade:aColsFieldByName("C2_OPC"		,nLinAcols,nLinha,nColuna)
					cRoteiro  := oGrade:aColsFieldByName("C2_ROTEIRO"	,nLinAcols,nLinha,nColuna)

					cItemGrd := Soma1(cItemGrd,Len(SC2->C2_ITEMGRD))
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Altera os dados do 1o Item (Produto Referencia) e inclui os  ³
					//³ outros Itens da Grade                                        ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					nRegSC2 += 1
					If lGrava
						RecLock(cAlias,If(nRegSC2 == 1,.F.,.T.))
					EndIf

					If lGrava
						For i := 1 TO FCount()
							FieldPut(i,M->&(EVAL(bCampo,i)))
						Next i

						cOPGerada := SC2->C2_NUM + SC2->C2_ITEM + SC2->C2_SEQUEN + cItemGrd

						SC2->C2_PRODUTO	:= cProdRef
						SC2->C2_QUANT	:= nQuant
						SC2->C2_ITEMGRD	:= cItemGrd
						SC2->C2_GRADE	:= "S"
						SC2->C2_QTSEGUM	:= ConvUM(SC2->C2_PRODUTO,nQuant,nQuant2UM,2)
						SC2->C2_OPC		:= cOpc
						SC2->C2_MOPC    := cOpc
						a650DatPri("M->C2_DATPRI",M->C2_DATPRI,cProdRef,nQuant,.T.)
						a650DatPrf("M->C2_DATPRF",M->C2_DATPRF,cProdRef,nQuant,.T.)
						SC2->C2_DATPRI	:= M->C2_DATPRI
						SC2->C2_DATPRF	:= M->C2_DATPRF
						SC2->C2_ROTEIRO	:= cRoteiro
						SC2->C2_OP   	:= cOPGerada
					Else
						//Retorna codigo de produto e item de grade
						If !Empty(cProdRef)
							aRet    := {cProdRef,cItemGrd}
							Exit
						EndIf
					EndIf
				EndIf

		ENDCASE

	Next nColuna

	// Retorna codigo de produto e item de grade
	If !lGrava .And. !Empty(cProdRef)
		Exit
	EndIf

Next nLinha
If lGrava
	RestArea(aArea)
EndIf
Return aRet

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³A650Visual³ Autor ³ Edson Maricate        ³ Data ³13-06-2001³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Programa de visualizacao de OPs                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³A650Visual(ExpC1,ExpN1,ExpC2)                               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Alias do arquivo                                   ³±±
±±³          ³ ExpN1 = Numero do registro                                 ³±±
±±³          ³ ExpN2 = Opcao selecionada no menu                          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA650                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
*/
Function A650View(cAlias,nReg,nOpcx)

Local aBut650     := {}
Local lIntQIP  := IntQIP(SC2->C2_PRODUTO,,IIf(cModulo=="QIP","E","T"))

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Botao para exportar dados para EXCEL                    ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If RemoteType() == 1
	aAdd(aBut650,{PmsBExcel()[1],{|| DlgToExcel({{"ENCHOICE",cCadastro,aGets,aTela}})},PmsBExcel()[2],PmsBExcel()[3]})
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Executa ponto de entrada para montar array com botoes a      ³
//³ serem apresentados na tela de visualizacao                   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If (ExistBlock("M650BCHOI"))
	aBut650:=ExecBlock("M650BCHOI",.F.,.F.)
	If ValType(aBut650) # "A"
		aBut650:={}
	EndIf
Endif

If IntePms().AND. !lPmsInt // coligada igual a empresa

	Aadd(aBut650,{'PROJETPMS',{||Eval(bPmsDlgOP)},OemToAnsi(STR0071),OemToAnsi(STR0117) }) //"Gerenciamento de Projetos"
EndIf

If lIntQIP //Define a integracao com o QIP
	Aadd(aBut650,{"RELATORIO",{|| QP650HIS(SC2->C2_NUM,SC2->C2_ITEM,SC2->C2_SEQUEN,SC2->C2_CHAVE)},OemToAnsi(STR0087),OemToAnsi(STR0118)}) //"Observação da Ordem de Produção..."
EndIf

AAdd(aBut650,{ "bmpord1", {|| A650Track() },STR0102} ) // Botao System Tracker

If SuperGetMv("MV_SELEOPC") == "S"
   AAdd(aBut650,{, {|| A650Opc() },STR0175} ) // Botao Opcionais
EndIf

PRIVATE aRatAFM		:= {}					//Variavel utilizada pela Funcao PMSDLGOP - Gerenc. Projetos
PRIVATE bPMSDlgOP	:= {||PmsDlgOP(2,M->C2_NUM,M->C2_ITEM,M->C2_SEQUEN)} // Chamada da Dialog de Gerenc. Projetos

Return AxVisual(cAlias,nReg,nOpcx,,,,,aBut650)


/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³A650AtEmpn ³ Autor ³Rodrigo de A. Sartorio ³ Data ³04/06/02 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Atualiza o campo B2_QEMPN                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Mata650                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function A650AtEmpn(nQuant,cSinal,cTpOP)
Local aArea		:= GetArea()
Local nMutiplic	:= If(cSinal=="+",1,-1)
DEFAULT cSinal 	:= "+"
DEFAULT cTpOP  	:= "F"

dbSelectArea("SB2")
RecLock("SB2",.F.)
If AllTrim(cTpOP) == "F"
	Replace B2_QEMPN  With Max(0,B2_QEMPN + (nQuant*nMutiplic))
	Replace B2_QEMPN2 With Max(0,B2_QEMPN2 + (ConvUM(SB2->B2_COD,nQuant,0,2)*nMutiplic))
ElseIf AllTrim(cTpOP) == "P"
	Replace B2_QEMPPRE With Max(0,B2_QEMPPRE + (nQuant*nMutiplic))
	Replace B2_QEPRE2  With Max(0,B2_QEPRE2 + (ConvUM(SB2->B2_COD,nQuant,0,2)*nMutiplic))
EndIf
MsUnlock()

RestArea( aArea )

Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³A650DelCols³ Autor ³Rodrigo de A. Sartorio ³ Data ³04/06/02 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Funcao utilizada para contornar deficiencia da GETDADOS em  ³±±
±±³          ³inicializar com linhas deletadas                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Mata650                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function A650DelCols(oObj)
Local nx
For nx:=1 to Len(aColsDele)
	aCols[aColsDele[nx],Len(aCols[aColsDele[nx]])]:=.T.
Next nx
oObj:Reset()
RETURN

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³A650SldMRP³ Autor ³Rodrigo de A. Sartorio ³ Data ³10/09/2002³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Verifica saldo em estoque na data                          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ lProjNovo  - Verifica saldo ref. a MRP programa novo       ³±±
±±³          ³ lProjVelho - Verifica saldo ref. a MRP programa velho      ³±±
±±³          ³ cComp      - Componente a ser verificado                   ³±±
±±³          ³ dEntrega   - Data do consumo                               ³±±
±±³          ³ cOpcionais - String com opcionais selecionados             ³±±
±±³          ³ lprodAlt   - Indica se prod. alternativo			          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ MATA650 / MATA710                                          ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function A650SldMRP(lProjNovo,lProjVelho,cComp,dEntrega,cOpcionais,lProdAlt,cProdAlt,cProdOri,nQuant)

Static cStrGrupo := Nil
Static cRevPad   := Nil

Local aArea     :=GetArea(),aAreaBack:={}
Local cCpoPr711 :="",nQtdRet:=0,nEntrada:=0,nSaida:=0
Local cPeriodo  :=A650DtoPer(dEntrega)
Local nEstSeg   := 0
Local lFabr     := .F.
Local cOpcComp  := ""
Local cOpc		:= ""
Local cStrTipo  := ""
Local nQtdSH5	:= 0
Local lUsaMOpc	:= .F.//If(SuperGetMv('MV_REPGOPC',.F.,"N") == "S",.T.,.F.)
Local cAliasTop := ""
Local cQuery	   := ""
Local nQtTran   := 0
Local cFilSHA := ""
Local cGrpDft := Criavar("B1_GRUPO",.f.)+"|"
DEFAULT lProjNovo:=.T.
DEFAULT lProjVelho:=.F.
DEFAULT cOpcionais:=""
DEFAULT lProdAlt := .F.
DEFAULT cProdAlt := ""
DEFAULT cProdOri := ""

If cStrGrupo == Nil
	cStrGrupo := cGrpDft
EndIf

If cRevPad == Nil
	cRevPad := Criavar("C2_REVISAO",.F.)
EndIf

cOpcionais := (If(Empty(cOpcionais),SC2->C2_OPC,cOpcionais))
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//| Trata o opcional utilizado para buscar o saldo correto |
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If !Empty(cOpcionais)
	If Type('a711Tipo') == "A"
		aEval(a711Tipo,{|a| cStrTipo += SubStr(a[2],1,TamSX3("B1_TIPO")[1])+"|"})
	EndIf

	If Type('a711Grupo') == "A" .And. Len(cStrGrupo) <= Len(cGrpDft)
		aEval(a711Grupo,{|a| cStrGrupo += SubStr(a[2],1,TamSX3("B1_GRUPO")[1])+"|"})
	EndIf

	cGrupos := A712EstOpc(cComp,MontaOpc(cOpcionais),Nil,Nil,cStrTipo,cStrGrupo)
	cOpc := IIf(Empty(cGrupos),"",A712AvlOpc(MontaOpc(cOpcionais),cGrupos))

EndIf
cOpc := PadR(cOpc,Len(SC2->C2_OPC))

If lProjNovo .And. !lMata712 .And. !lPCPA107
	lUsaMOpc := If(SuperGetMv('MV_REPGOPC',.F.,"N") == "S",.T.,.F.)
	dbSelectArea("SHA")
	aAreaBack:=GetArea()
	cCpoPr711 := "HA_PER"+cPeriodo
	dbSetOrder(1)
	If !lUsaMOpc
		cFilSHA := xFilial("SHA")
		If dbSeek(cFilSHA+cComp+cOpc+Criavar("C2_REVISAO",.F.)+"1")
			nEntrada+=&cCpoPr711
		EndIf
		If dbSeek(cFilSHA+cComp+cOpc+Criavar("C2_REVISAO",.F.)+"2")
			nEntrada+=&cCpoPr711
		EndIf
		If dbSeek(cFilSHA+cComp+cOpc+Criavar("C2_REVISAO",.F.)+"3")
			nSaida+=&cCpoPr711
		EndIf
		If dbSeek(cFilSHA+cComp+cOpc+Criavar("C2_REVISAO",.F.)+"4")
			nSaida+=&cCpoPr711
			If lProdAlt
				SH5->(dbSetOrder(3))
				SH5->(dbSeek(xFilial("SH5")+cComp+"SHA"+DToS(dEntrega)))
				While !SH5->(EOF()) .And. SH5->(H5_PRODUTO+H5_ALIAS+DToS(H5_DATAORI)) == cComp+"SHA"+DToS(dEntrega)
					If SC2->C2_PRODUTO == SH5->H5_DOC .or. (lProdAlt .and. SH5->H5_DOC = cProdAlt)
						nSaida -= SH5->H5_QUANT
					EndIf
					SH5->(dbSkip())
				End
			EndIf
		EndIf
	Else
		If MOpcSeek("SHA",1,,cComp,,cOpc,Criavar("C2_REVISAO",.F.),"1")
			nEntrada+=&cCpoPr711
		EndIf
		If MOpcSeek("SHA",1,,cComp,,cOpc,Criavar("C2_REVISAO",.F.),"2")
			nEntrada+=&cCpoPr711
		EndIf
		If MOpcSeek("SHA",1,,cComp,,cOpc,Criavar("C2_REVISAO",.F.),"3")
			nSaida+=&cCpoPr711
		EndIf
		If MOpcSeek("SHA",1,,cComp,,cOpc,Criavar("C2_REVISAO",.F.),"4")
			nSaida+=&cCpoPr711
			If lProdAlt
				SH5->(dbSetOrder(3))
				SH5->(dbSeek(xFilial("SH5")+cComp+"SHA"+DToS(dEntrega)))
				While !SH5->(EOF()) .And. SH5->(H5_PRODUTO+H5_ALIAS+DToS(H5_DATAORI)) == cComp+"SHA"+DToS(dEntrega)
					If SC2->C2_PRODUTO == SH5->H5_DOC .or. (lProdAlt .and. SH5->H5_DOC = cProdAlt)
						nSaida -= SH5->H5_QUANT
					EndIf
					SH5->(dbSkip())
				End
			EndIf
		EndIf
	EndIf
	If lProj711 .And. aPergs711[26] == 1
		nEstSeg := CalcEstSeg( RetFldProd(SB1->B1_COD,"B1_ESTFOR") )
		nEntrada += nEstSeg
	EndIf
	nQtdRet := nEntrada-nSaida
	RestArea(aAreaBack)
ElseIf lProjNovo .And. lMata712 .And. !lPCPA107
	aAreaBack := GetArea()
	cAliasTop := 'BUSCASALDO'
	cQuery := " SELECT CZK.CZK_QTSLES, " +;
	                 " CZK.CZK_QTENTR, " +;
	                 " CZK.CZK_QTSAID, " +;
	                 " CZK.CZK_QTSEST " +;
	            " FROM " + RetSqlName("CZJ") + " CZJ, " +;
	                       RetSqlName("CZK") + " CZK " +;
	           " WHERE CZK.CZK_RGCZJ  = CZJ.R_E_C_N_O_ " +;
	             " AND CZJ.CZJ_FILIAL = '" + xFilial("CZJ") + "' " +;
	             " AND CZK.CZK_FILIAL = '" + xFilial("CZK") + "' " +;
	             " AND CZJ.CZJ_PROD   = '" + cComp + "' " +;
	             " AND CZJ.CZJ_OPCORD = '" + cOpc + "' " +;
	             " AND CZJ.CZJ_NRRV   = '" + cRevPad + "' " +;
	             " AND CZK.CZK_PERMRP = '" + cPeriodo + "' "

	//cQuery := ChangeQuery(cQuery)

	dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasTop,.T.,.T.)
	//dbSelectArea(cAliasTop)

	nEntrada += (cAliasTop)->CZK_QTSLES
	nEntrada += (cAliasTop)->CZK_QTENTR
	nSaida += (cAliasTop)->CZK_QTSAID
	nSaida += (cAliasTop)->CZK_QTSEST

	(cAliasTop)->(dbCloseArea())

	If lProdAlt
		CZI->(dbSetOrder(3))
		CZI->(dbSeek(xFilial("CZI")+cComp+"CZJ"+DToS(dEntrega)))
		While !CZI->(EOF()) .And. CZI->(CZI_PROD+CZI_ALIAS+DToS(CZI_DTOG)) == cComp+"CZI"+DToS(dEntrega)
			If SC2->C2_PRODUTO == CZI->CZI_DOC .or. (lProdAlt .and. CZI->CZI_DOC = cProdAlt)
				nSaida -= CZI->CZI_QUANT
			EndIf
			CZI->(dbSkip())
		End
	EndIf
	If lProj711 .And. aPergs711[26] == 3
		nEstSeg := CalcEstSeg(RetFldProd(SB1->B1_COD,"B1_ESTFOR") )
		nEntrada -= nEstSeg
	EndIf

	If aPergs711[2] == 1 .Or. aPergs711[3] == 1
		nQtdRet := nEntrada-nSaida
	Else
		nQtdRet := Max(nEntrada-nSaida,nEntrada)
	EndIf
	RestArea(aAreaBack)
ElseIf lProjNovo .And. lPCPA107 .And. !lMata712
	aAreaBack := GetArea()
	cAliasTop := 'BUSCASALDO'
	cQuery := " SELECT SOT.OT_QTSLES, " +;
	                 " SOT.OT_QTENTR, " +;
	                 " SOT.OT_QTSAID, " +;
	                 " SOT.OT_QTSEST, " +;
	                 " SOT.OT_QTTRAN, "+;
	                 " SOT.R_E_C_N_O_ RECSOT "+;
	            " FROM " + RetSqlName("SOR") + " SOR, " +;
	                       RetSqlName("SOT") + " SOT " +;
	           " WHERE SOT.OT_RGSOR  = SOR.R_E_C_N_O_ " +;
	             " AND SOR.OR_FILIAL = '" + xFilial("SOR") + "' " +;
	             " AND SOT.OT_FILIAL = '" + xFilial("SOT") + "' " +;
	             " AND SOR.OR_PROD   = '" + cComp + "' " +;
	             " AND SOR.OR_OPCORD = '" + cOpc + "' " +;
	             " AND SOR.OR_NRRV   = '" + Criavar("C2_REVISAO",.F.) + "' " +;
	             " AND SOT.OT_PERMRP = '" + cPeriodo + "' " +;
	             " AND SOR.OR_EMP    = '" + cEmpAnt + "' " +;
	             " AND SOR.OR_FILEMP = '" + cFilAnt + "' "

	cQuery := ChangeQuery(cQuery)

	dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasTop,.T.,.T.)
	dbSelectArea(cAliasTop)

	nEntrada += (cAliasTop)->OT_QTSLES
	nEntrada += (cAliasTop)->OT_QTENTR
	nSaida += (cAliasTop)->OT_QTSAID
	If (cAliasTop)->OT_QTTRAN <= 0
	   nSaida += (cAliasTop)->OT_QTSEST
	EndIf

	dbSelectArea("SOV")
	SOV->(dbSetOrder(1))
	If SOV->(dbSeek(xFilial("SOV")+PadR(AllTrim(Str((cAliasTop)->(RECSOT))),10)+"S"))
	    nQtTran := SOV->(OV_QUANT)
		If nQtTran > 0
		   nEntrada += nQtTran
		EndIf
	EndIf

	(cAliasTop)->(dbCloseArea())

	If lProdAlt
		SOQ->(dbSetOrder(3))
		SOQ->(dbSeek(xFilial("SOQ")+cEmpAnt+cFilAnt+cComp+"SOR"+DToS(dEntrega)))
		While !SOQ->(EOF()) .And. SOQ->(OQ_EMP+OQ_FILEMP+OQ_PROD+OQ_ALIAS+DToS(OQ_DTOG)) == cEmpAnt+cFilAnt+cComp+"SOR"+DToS(dEntrega)
			If SC2->C2_PRODUTO == SOQ->OQ_DOC .or. (lProdAlt .and. SOQ->OQ_DOC = cProdAlt)
				nSaida -= SOQ->OQ_QUANT
			EndIf
			SOQ->(dbSkip())
		End
	EndIf

	If lProj711 .And. aPergs711[26] == 3
		nEstSeg := CalcEstSeg(RetFldProd(SB1->B1_COD,"B1_ESTFOR") )
		nEntrada -= nEstSeg
	EndIf
	nQtdRet := nEntrada-nSaida
	RestArea(aAreaBack)
ElseIf lProjVelho
	cCpoPr711 := "H5_PER"+cPeriodo
	dbSelectArea("SH5")
	aAreaBack:=GetArea()
	dbSetOrder(1)
	If dbSeek(xFilial("SH5")+cComp+"1")
		nQtdRet:=&cCpoPr711
	EndIf
	If dbSeek(xFilial("SH5")+cComp+"2")
		nQtdRet+=&cCpoPr711
	EndIf
	If dbSeek(xFilial("SH5")+cComp+"3")
		nQtdRet-=&cCpoPr711
	EndIf
	RestArea(aAreaBack)
Endif
RestArea(aArea)
RETURN nQtdRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³A650Track ³ Autor ³Rodrigo de A Sartorio  ³ Data ³19/11/2002³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Faz o tratamento da chamada do System Tracker              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ .T.                                                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ Nenhum                                                     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄnOpcxÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/

Static Function A650Track()
Local aEnt     := {}
AAdd( aEnt, { "SC2",C2_NUM+C2_ITEM+C2_SEQUEN+C2_ITEMGRD} )
MaTrkShow( aEnt )
Return( .T. )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³A650DelSHC ³ Autor ³Rodrigo de A. Sartorio ³ Data ³11/08/03 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Deleta o registro de PMP vinculado a ordem de producao      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Mata650                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function A650DelSHC(cProduto,cOp,dDatPri)
Local aArea:=GetArea()
Local aAreaSHC:=SHC->(GetArea())
dbSelectArea("SHC")
dbSetOrder(2)
If dbSeek(xFilial("SHC")+cProduto+cOP)
	Reclock("SHC",.F.)
	Replace HC_OP With Criavar("HC_OP",.F.)
	Replace HC_STATUS With Criavar("HC_STATUS",.F.)
	MsUnlock()
EndIf
RestArea(aAreaSHC)
RestArea(aArea)
RETURN

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³A650Priori³ Autor ³Rodrigo de A Sartorio  ³ Data ³ 12/11/03 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Programa de priorizacao de OPs                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ Void A650Priori(ExpC1,ExpN1,ExpN2)                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Alias do arquivo                                   ³±±
±±³          ³ ExpN1 = Numero do registro                                 ³±±
±±³          ³ ExpN2 = Opcao selecionada no menu                          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Mata650                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
*/
Function A650Priori(cAlias,nReg,nOpcx)
Local aRetCopy :=Aclone(aRotina), cMarca
Local cNumOPD:="",cItemOPD:="",cSeqOpD:="",cItemGrDOp:=""
Local cNumOPA:="",cItemOPA:="",cSeqOpA:="",cItemGrAOp:=""

DEFAULT l650Auto	:= .F.

aRotina := {{STR0001, "PesqBrw"  , 0 , 1},;	//"Pesquisar"
	{STR0098,"A650ProPri", 0 , 0} } //"Reprioriza"

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ mv_par01 - Altera Prioridades 1- Produto posicionado 2- Todos³
//³ mv_par02 - Op de                                             ³
//³ mv_par03 - Op Ate                                            ³
//³ mv_par04 - Ops intermed. grava prioridade 1-Op Pai 2-Propria ³
//³ mv_par05 - Armazem de                                        ³
//³ mv_par06 - Armazem ate                                       ³
//³ mv_par07 - Produto de                                        ³
//³ mv_par08 - Produto ate                                       ³
//³ mv_par09 - Prioridade inicial para regravacao                ³
//³ mv_par10 - Incremento na prioridade                          ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If Pergunte("MTA65P",.T.)
	dbSelectArea("SC2")

	//³ Separa o numero , item, sequencia e item grade das OPs digitadas³
	//³ nos parametros de OP inicio e OP fim                            ³
	cNumOPD:=Substr(mv_par02,1,Len(SC2->C2_NUM))
	cItemOPD:=Substr(mv_par02,1+Len(SC2->C2_NUM),Len(SC2->C2_ITEM))
	cSeqOpD:=Substr(mv_par02,1+Len(SC2->C2_NUM)+Len(SC2->C2_ITEM),Len(SC2->C2_SEQUEN))
	cItemGrDOp:=Substr(mv_par02,1+Len(SC2->C2_NUM)+Len(SC2->C2_ITEM)+Len(SC2->C2_SEQUEN),Len(SC2->C2_ITEMGRD))
	cNumOPA:=Substr(mv_par03,1,Len(SC2->C2_NUM))
	cItemOPA:=Substr(mv_par03,1+Len(SC2->C2_NUM),Len(SC2->C2_ITEM))
	cSeqOpA:=Substr(mv_par03,1+Len(SC2->C2_NUM)+Len(SC2->C2_ITEM),Len(SC2->C2_SEQUEN))
	cItemGrAOp:=Substr(mv_par03,1+Len(SC2->C2_NUM)+Len(SC2->C2_ITEM)+Len(SC2->C2_SEQUEN),Len(SC2->C2_ITEMGRD))

	cCondicao := 'C2_FILIAL=="'+xFilial("SC2")+'".And.'
	// Considera somente produto posicionado no browse
	If mv_par01 == 1
		cCondicao += 'C2_PRODUTO=="'+SC2->C2_PRODUTO+'".And.'
		// Considera produtos do filtro
	Else
		cCondicao += 'C2_PRODUTO>="'+mv_par07+'".And.C2_PRODUTO<="'+mv_par08+'".And.'
	EndIf
	// Filtra numeracao de OPs
	cCondicao += 'C2_NUM>="'+cNumOPD+'".And.C2_ITEM>="'+cItemOPD+'".And.C2_ITEMGRD>="'+cItemGrDOP+'".And.'
	// Considera somente produto com SEQUENCIA 001
	If mv_par04 == 1
		cCondicao += 'C2_SEQUEN == "'+StrZero(1,Len(SC2->C2_SEQUEN),0)+'".And.'
	Else
		cCondicao += 'C2_SEQUEN >= "'+cSeqOpD+'".And.'
	EndIf
	cCondicao += 'C2_NUM<="'+cNumOPA+'".And.C2_ITEM<="'+cItemOPA+'".And.C2_ITEMGRD<="'+cItemGrAOP+'".And.'
	If mv_par04 <> 1
		cCondicao += 'C2_SEQUEN <= "'+cSeqOpA+'".And.'
	EndIf

	If mv_par11 == 1  	//Filtra OPs em aberto (Nao apontado)
		cCondicao += 'Empty(SC2->C2_DATRF).And.'
	ElseIf mv_par11 == 2 //Filtra ja apontadas
		cCondicao += 'SC2->C2_QUJE > 0 .And.'
	EndIf

	//Filtra a OPs não encerradas.
	If GetNewPar("MV_ATOPFEC","2") == "1"
		cCondicao += 'Empty(C2_DATRF).And.'
	EndIf
	// Filtra armazem
	cCondicao += 'C2_LOCAL>="'+mv_par05+'".And.C2_LOCAL<="'+mv_par06+'"'

	dbSelectArea("SC2")
	dbSetOrder(1)
	dbGotop()

	If Bof() .and. Eof()
		Help(" ",1,"RECNO")
	Else
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Endereca a funcao de BROWSE                                  ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		cMarca := GetMark()
		If !l650Auto
			MarkBrow("SC2","C2_OK",,,,cMarca,,,'xFilial("SC2")','xFilial("SC2")',,,,,,,,cCondicao)
		EndIf
	EndIf

	If l650Auto
		A650ProPri(cAlias,"","",cMarca,.F.)
	EndIf

EndIf
Pergunte("MTA650",.F.)
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Restaura a integridade da janela                             ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
inclui := .F.
aRotina:=AClone(aRetCopy)
dbSelectArea(cAlias)
dbGoTo(nReg)
RETURN

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³A650ProPri³ Autor ³Rodrigo de A Sartorio  ³ Data ³ 12/11/03 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Executa mudanca de prioridade das OPs                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ Void A650ProPri(ExpC1,ExpN1,ExpN2)                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Alias do arquivo                                   ³±±
±±³          ³ ExpN1 = Numero do registro                                 ³±±
±±³          ³ ExpN2 = Opcao selecionada no menu                          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Mata650                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
*/
Function A650ProPri(cAlias,cCampo,nOpcE,cMarca,lInverte)
LOCAL cIndice:="C2_PRODUTO+C2_NUM+C2_ITEM"
LOCAL cArqNtx:=CriaTrab(NIL,.F.),nIndex:=0,nz:=0
LOCAL aArrayProd:={},cProduto:="",nRecOrig:=0,aOpPis:={}
Local cFilSC2 := xFilial("SC2")

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ mv_par01 - Altera Prioridades 1- Produto posicionado 2- Todos³
//³ mv_par02 - Op de                                             ³
//³ mv_par03 - Op Ate                                            ³
//³ mv_par04 - Ops intermed. grava prioridade 1-Op Pai 2-Propria ³
//³ mv_par05 - Armazem de                                        ³
//³ mv_par06 - Armazem ate                                       ³
//³ mv_par07 - Produto de                                        ³
//³ mv_par08 - Produto ate                                       ³
//³ mv_par09 - Prioridade inicial para regravacao                ³
//³ mv_par10 - Incremento na prioridade                          ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Retorna os indices e cria a 2a IndRegua.                     ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
dbSelectArea("SC2")
RetIndex("SC2")
dbClearFilter()
If !lInverte
	cCondicao += '.And.C2_OK == "'+SUBSTR(cMarca,1,Len(C2_OK))+'"'
EndIf
IndRegua("SC2",cArqNtx,cIndice,,cCondicao,STR0061) //"Selecionando Registros..."
nIndex:=RetIndex("SC2")
dbSetOrder(nIndex+1)
dbSelectArea(cAlias)
dbGotop()
ProcRegua(LastRec(),21,5) // Monta regua
While !Eof()
	// Efetua quebra por produto
	cProduto:=SC2->C2_PRODUTO
	aArrayProd:={}
	While !Eof() .And. SC2->C2_PRODUTO == cProduto
		IncProc() // Adiciona contador na regua
		If IsMark("C2_OK",cMarca,lInverte)
			AADD(aArrayProd,{SC2->C2_NUM,SC2->C2_ITEM,SC2->C2_SEQUEN,Replicate("0",Len(SC2->C2_PRIOR)),SC2->(Recno())})
		EndIf
		dbSkip()
	End
	nRecOrig:=Recno()
	// Muda prioridade de todas as ordens relacionadas ao produto
	For nz:=1 to Len(aArrayProd)
		If nz ==1
			aArrayProd[nz,4]:=If(Empty(mv_par09),"500",mv_par09)
		Else
			aArrayProd[nz,4]:=Str(Val(aArrayProd[nz-1,4])+mv_par10,Len(SC2->C2_PRIOR),0)
			If "*" $ aArrayProd[nz,4]
				aArrayProd[nz,4]:="500"
			EndIf
		EndIf
	Next nz
	// Grava novas prioridades
	For nz:=1 to Len(aArrayProd)
		dbGoto(aArrayProd[nz,5])
		Reclock("SC2",.F.)
		Replace C2_PRIOR With aArrayProd[nz,4]
		MsUnlock()
		// Armazena numero de OPs para posteriormente identificar ops filhas e gravar prioridade em todas
		If mv_par04 == 1
			AADD(aOpPis,{SC2->C2_NUM,SC2->C2_ITEM,SC2->C2_SEQUEN,SC2->C2_ITEMGRD,SC2->C2_PRIOR})
		EndIf
	Next nz
	// Volta ao laco principal
	dbGoto(nRecOrig)
End
// Retira filtro
dbSelectArea("SC2")
RetIndex("SC2")
dbClearFilter()
// Apaga arquivo de trabalho
Ferase(cArqNtx+OrdBagExt())
dbSetOrder(1)
// Grava sequencia nas Ops filhas
For nz:=1 to Len(aOpPis)
	dbSeek(cFilSC2+aOpPis[nz,1]+aOpPis[nz,2]+aOpPis[nz,3]+aOpPis[nz,4])
	While !Eof() .And. SC2->C2_FILIAL+SC2->C2_NUM+SC2->C2_ITEM == cFilSC2+aOpPis[nz,1]+aOpPis[nz,2]
		If SC2->C2_ITEMGRD == aOpPis[nz,4] .And. (SC2->C2_SEQUEN <> StrZero(1,Len(SC2->C2_SEQUEN),0))
			Reclock("SC2",.F.)
			Replace C2_PRIOR With aOpPis[nz,5]
			MsUnlock()
		EndIf
		dbSkip()
	End
Next nz
If !l650Auto
	CloseBrowse()
EndIf
RETURN

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³A650OpBatch  ³ Autor ³Marcelo Iuspa       ³ Data ³ 16/04/04 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Checa se foi gerado OP intermediaria                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ A650OpBatch(cOp, lMsg)                                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ cOp   = Numero da OP a ser verificada                      ³±±
±±³          ³ lMsg  = Define se mostro ou nao pergunta de confirmacao    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Mata650 / MATA250 / MATA680                                ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
*/
Function A650OpBatch(cOp, lMsg,l250Auto,oModelCYV)
Local aSave    := GetArea()
Local lOk      := .T.
Local lContinua:= .T.
Local lRotAuto := (Type('lMsHelpAuto') == "L" .And. lMsHelpAuto) .Or. (Type('lRunPPI') == "L" .And. lRunPPI)
Local lExibeMens := .T.
Local lAponSemSD4 := .F.
Local lAptEmp    := NIL
Default lMsg     := .T.
Default l250Auto := .F.
Default oModelCYV := NIL

If Empty(cOp)
	lContinua := .F.
Endif

If Type('lAptEmp650') == "L"
	lAptEmp := lAptEmp650
Else
	lAptEmp := SuperGetMv("MV_APTEMP",.F.,.T.)
ENDIF

If Type("l681Auto") != "L"
	l681Auto := .F.
EndIf

If Type("_IsPost314") != "L"
    _IsPost314 := .F.
EndIf

//--Parametro: MV_ACDVOPI (caracter) - default "S".
//--Uso: Via Rotina Automatica - Validar ou nao se Ops Intermediarias foram criadas.
If	lContinua .And. If(Type('l650')=="L".And.l650,Type('aRotProd')=="A",Type('aRotAuto')=="A")
	lContinua := SuperGetMv("MV_ACDVOPI",.F.,"S") == "S"
EndIf

If lContinua
	SD4->(dbSetOrder(2))
	If !(SD4->(dbSeek(xFilial('SD4')+cOp)))
		lOk := .F.
	EndIf
	RestArea(aSave)
	If lRotAuto .And. !lOk
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ P.E. Utilizado para Controlar a geracao de OPs intermediarias pelo apont do SFC do APP³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If ExistBlock("MT650APSE")
		    If !Empty(oModelCYV)
			   lAponSemSD4:= ExecBlock("MT650APSE",.F.,.F.,{oModelCYV})
			   If ValType(lAponSemSD4) <> "L"
                  lAponSemSD4:=.T.
			   EndIf
			   //O ponto de entrada sobrepõe o parâmetro MV_APTEMP
			   IF lAponSemSD4
   		          lOk := .T.
			   EndIf
			Else
			   If !l250Auto .And. (!l681Auto .Or. (l681Auto .And._IsPost314))
			      Return .T.
			   Else
			       If MTA650MSG(lAptEmp)
				      lOk := .T.
				   EndIf
			   Endif
			EndIf
	    Else
		   If MTA650MSG(lAptEmp)
		      lOk := .T.
		   EndIf
		EndIf
	ElseIf (! lOk) .And. lMsg
		If l250Auto
			If lAptEmp == .T.
				lOk := .T.
			Else
				lOk := .F.
				Help(" ",1,"HELP", ,STR0193+".",1,0, ,,,,,{STR0192})
			EndIf
		Else
			lOk := .T.
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ P.E. Utilizado para Controlar a geracao de OPs intermediarias ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If ExistBlock("MT650PISC")
				lExibeMens:= ExecBlock("MT650PISC",.F.,.F.)
				If ValType(lExibeMens) <> "L"
					lExibeMens:=.T.
				EndIf
			EndIf

			If lAptEmp
				If lExibeMens
					lOk := MsgYesNo(STR0099) //"A OP informada nao teve OPs intermediarias criadas. Deseja mesmo produzi-la?"
				EndIf
			Else
				If lExibeMens
					Help(" ",1,"HELP", ,STR0193+".",1,0, ,,,,,{STR0192})
					//MsgAlert(STR0192,STR0193)//Nao e possivel registrar o apontamento pois nao foi gerado empenho para a OP // Ordem de producao sem empenho
					lOk := .F.
				EndIf
			EndIf

		Endif
	Endif
Endif
Return(lOk)

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³A650OpenBatch³ Autor ³Marcelo Iuspa       ³ Data ³ 16/04/04 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Abre arquivo para controle de geracao de OPs intermediarias³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ A650OpenBatch                                              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Mata650 / MATA250 / MATA680                                ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
*/
Function A650OpenBatch(lExclusive, lReindex, lCreate)
Local lRet		 := .F.
Local cNomBat    := "BATCH"+cEmpAnt+"0"
Local cNomInd1   := "BATCH"+cEmpAnt+"1"
Local cNomInd2   := "BATCH"+cEmpAnt+"2"
Local cNomInd3   := "BATCH"+cEmpAnt+"3"
Local nLen       := Len(SD4->(D4_FILIAL + D4_OP))
Local aEstrBatch := {}
Local lFim       := .F.
Static lChkLenOp := Nil

Default lExclusive := .F.
Default lReindex   := .F.
Default lCreate    := .F.

If lExclusive .Or. lReindex .Or. lCreate
	If Select("TMP") > 0
		TMP->(dbCloseArea())
	EndIf
EndIf

If Select("TMP") > 0
	lRet := .T.
EndIf

If !lRet
	While ! LockByName(cNomBAT)  //Fecha()
		Sleep(100)
	End

	If !MsFile(cNomBat,Nil,__cRDD) //(!File(cNomBat)) .Or. lCreate
		AADD(aEstrBatch,{"OP","C",nLen,0})
		AADD(aEstrBatch,{"OK","C",1,0})
		AADD(aEstrBatch,{"OR1","C",1,0})
		AADD(aEstrBatch,{"DATAINI","D",8,0})
		AADD(aEstrBatch,{"DATAFIM","D",8,0})
		AADD(aEstrBatch,{"USUARIO","C",6,0})
		AADD(aEstrBatch,{"FUNNAME","C",20,0})
		FwdbCreate(cNomBat,aEstrBatch,"TOPCONN", .T.)
	EndIf

	While !lFim
		dbUseArea(.T., "TOPCONN", cNomBAT, "TMP", ! lExclusive, .F.)
		If ! (lFim := !NetERR())
			MsAguarde({|| Sleep(2000)},STR0103,STR0104+ cNomBat, .T.) //"Aguarde"###"Tentando acessar "
		EndIf
		Sleep(100)
	End

	If lChkLenOp == Nil
		lChkLenOp := .T.
		If Len(TMP->OP) != 16
			Help(" ",1,"C690BAT")
		Endif
	EndIf

	If !MsFile(cNomBat,cNomInd1,__cRDD)
		DBCreateIndex(cNomInd1,"DTOS(DATAINI)+DTOS(DATAFIM)+OP",{|| DTOS(DATAINI)+DTOS(DATAFIM)+OP })
	EndIf

	If !MsFile(cNomBat,cNomInd2,__cRDD)
		DBCreateIndex(cNomInd2,"OP+DTOS(DATAINI)+DTOS(DATAFIM)",{|| OP+DTOS(DATAINI)+DTOS(DATAFIM) })
	EndIf

	If !MsFile(cNomBat,cNomInd3,__cRDD)
		DBCreateIndex(cNomInd3,"OP",{|| OP })
	EndIf

	dbClearIndex()
	dbSetIndex(cNomInd1)
	dbSetIndex(cNomInd2)
	dbSetIndex(cNomInd3)

	UnLockByName(cNomBAT) //Abre()
	TMP->(dbSetOrder(1))
	lRet := Select("TMP") > 0
EndIf
Return lRet

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³A650CloseBatch³ Autor ³Marcelo Iuspa      ³ Data ³ 16/04/04 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Fecha arquivo p/ controle de geracao de OPs intermediarias ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ A650CloseBatch                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Mata650 / MATA250 / MATA680                                ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
*/
Function A650CloseBatch()
If Select("TMP") > 0
	TMP->(dbCloseArea())
Endif
Return(.T.)

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³A650OpsPis    ³ Autor ³Marcelo Iuspa      ³ Data ³ 08/06/04 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Busca Ops de PIs da OP fornecida (recursiva)               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ A650OpsPis(cOp, aOps)                                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Mata650 / MATA250 / MATA680                                ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
*/
Function A650OpsPis(cOp, aOps)

Local lExcGra   := Upper(FunName()) == "MATA650" .And. aSav650[12] == 1
Local nLen      := If(lExcGra, Len(cOp) - Len(SC2->C2_ITEMGRD), Len(cOp))
Local cBanco    := Upper(TcGetDb())
Local cAliasTop := GetNextAlias()
Local aSavAre   := {}
Local cSeek

If cBanco $ "DB2,INFORMIX,ORACLE"
	aSavAre := {SD4->(GetArea()), GetArea()}
	cSeek  := Nil
	Default aOps  := {}
Endif
If aOps == NIL
	aOps := {}
Endif

If !(cBanco $ "DB2,INFORMIX,ORACLE")
	cQuery := "WITH ALLOPS(D4_OP,D4_OPORIG,Nivel) AS "
	cQuery += "("
	cQuery += " SELECT D4ANCORA.D4_OP,"
	cQuery +=        " D4ANCORA.D4_OPORIG,"
	cQuery +=        " 1 AS Nivel"
	cQuery +=   " FROM " + RetSqlName("SD4") + " D4ANCORA"
	cQuery +=  " WHERE D4ANCORA.D4_FILIAL  = '" + xFilial("SD4") + "'"
	cQuery +=    " AND D4ANCORA.D_E_L_E_T_ = ' '"
	cQuery +=    " AND D4ANCORA.D4_OP      = '" + Pad(cOp, nLen) + "'"
	cQuery +=    " AND (D4ANCORA.D4_OPORIG <> '" + Space(TamSx3("D4_OP")[1]) + "' AND D4ANCORA.D4_OPORIG IS NOT NULL)"
	cQuery +=  " UNION ALL"
	cQuery += " SELECT EMPENHO.D4_OP,"
	cQuery +=        " EMPENHO.D4_OPORIG,"
	cQuery +=        " OPS.Nivel + 1 AS Nivel"
	cQuery +=   " FROM " + RetSqlName("SD4") + " EMPENHO"
	cQuery +=  " INNER JOIN ALLOPS OPS"
	cQuery +=     " ON EMPENHO.D4_OP       = OPS.D4_OPORIG"
	cQuery +=  " WHERE EMPENHO.D_E_L_E_T_  = ' '"
	cQuery +=    " AND EMPENHO.D4_FILIAL   = '" + xFilial("SD4") + "'"
	cQuery +=    " AND (EMPENHO.D4_OPORIG <> '" + Space(TamSx3("D4_OP")[1]) + "' AND EMPENHO.D4_OPORIG IS NOT NULL)"
	cQuery += ")"
	cQuery += " SELECT DISTINCT ALLOPS.D4_OPORIG"
	cQuery +=   " FROM ALLOPS"

	If cBanco == "POSTGRES"
		cQuery := StrTran(cQuery, 'WITH ', 'WITH RECURSIVE ')
	EndIf

	cQuery := StrTran(cQuery,chr(13)," ")
	cQuery := StrTran(cQuery,chr(10)," ")
	cQuery := StrTran(cQuery,chr(09)," ")

	dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasTop,.T.,.T.)

	While (cAliasTop)->(!Eof())
		aAdd(aOps, (cAliasTop)->(D4_OPORIG))
		(cAliasTop)->(dbSkip())
	End
	(cAliasTop)->(dbCloseArea())
Else
	dbSelectArea("SD4")
	dbSetOrder(2)

	dbSeek(cSeek := xFilial("SD4") + Pad(cOp, nLen))
	Do While ! Eof() .And. SD4->(D4_FILIAL+Pad(D4_OP, nLen)) == cSeek
		If ! Empty(SD4->D4_OPORIG)
			Aadd(aOps, SD4->D4_OPORIG)
			aOps := A650OpsPis(SD4->D4_OPORIG, aOps)
		EndIf
		dbSkip()
	EndDo

	RestArea(aSavAre[1])
	RestArea(aSavAre[2])
Endif

Return(aOps)

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³A650DelSc1BN  ³ Autor ³Marcelo Iuspa      ³ Data ³ 13/10/04 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Deleta SC1 referente produtos tipo BN                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ A650DelSc1BN                                               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Mata650                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
*/
Function A650DelSc1BN(cOp)
Local aSavAre 	:= Nil
Local nX	  	:= 0
Local lExcluiSC := .T.
Local aAreaAtu := {}
Local lAprovEt := SuperGetMV("MV_APRSCEC",.F.,.T.) // Alcada por Entidade Contabil
Local lSCSldBl	:= SuperGetMv("MV_SCSLDBL",.F.,.F.)

If Type("l650Auto") == "L" .And. l650Auto .And. (nX := aScan(aRotProd,{|x| x[1] == "DELSC"})) > 0
	lExcluiSC := aRotProd[nX,2] == "S"
EndIf

If MatBuyBN()
	aSavAre := {GetArea(), SC1->(GetArea()), SC7->(GetArea()), SB2->(GetArea())}
	dbSelectArea("SC1")
	dbSetOrder(4)
	dbSeek(xFilial("SC1") + SC2->(C2_NUM+C2_ITEM+C2_SEQUEN+C2_ITEMGRD))
	do While lExcluiSC .And. ! Eof() .And. SC2->(C2_NUM+C2_ITEM+C2_SEQUEN+C2_ITEMGRD) == SC1->C1_OP
		SB1->(MsSeek(xFilial("SB1") + SC1->C1_PRODUTO))
		If SB1->B1_TIPO == "BN"
			dbSelectArea("SB2")
			dbSetOrder(1)
			If !MsSeek(xFilial("SB2")+SC1->C1_PRODUTO+SC1->C1_LOCAL)
				CriaSB2(SC1->C1_PRODUTO,SC1->C1_LOCAL)
				MsUnlock()
			EndIf
			If SC1->C1_APROV <> "B" .Or. (SC1->C1_APROV == "B" .And. !lSCSldBl)
				GravaB2Pre("-",(SC1->C1_QUANT-SC1->C1_QUJE),SC1->C1_TPOP)
			EndIf
			// Caso ja haja qtd no PC, iguala qtd na SC e retira vinculo
			// do PC com a SC, antes de apaga-la
			If SC1->C1_QUJE > 0
				RecLock("SC1",.F.)
				Replace C1_QUANT   With C1_QUJE
				Replace C1_QTSEGUM With ConvUM(SB2->B2_COD, C1_QUJE, 0, 2)
				MsUnlock()
			Else
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Execblock a ser executado antes da Exclusao do SC1           ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If (ExistBlock('MT650DC1'))
					ExecBlock('MT650DC1',.F.,.F.)
				EndIf
				//Realiza Exclusao de Alcada contabil
				If lAprovEt
					A650ALCCTB(cOp)
				EndIf
				If Type('aProcMRP') == "A" .And. !Empty(SC1->C1_SEQMRP)
					aAdd(aProcMRP, {SC1->C1_SEQMRP, SC1->C1_PRODUTO, SC1->C1_QUANT} )
				EndIf

				//Executa a exclusão da tabela DHN
				aAreaAtu := GetArea()
				COMEXCDHN("1",xFilial("SC1"),SC1->C1_NUM)
				RestArea(aAreaAtu)

				// Gerar Carta de Correcao do Pedido
				RecLock("SC1",.F.,.T.)
				Replace C1_OBS With STR0025 //"CANCELADA PELO SISTEMA."
				dbDelete()
				MsUnLock()
			EndIf
		EndIf
		dbSkip()
	EndDo
	RestArea(aSavAre[4])
	RestArea(aSavAre[3])
	RestArea(aSavAre[2])
	RestArea(aSavAre[1])
EndIf
Return(.T.)

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³ SomaPrazo    ³ Autor ³Marcelo Iuspa      ³ Data ³ 19/11/04 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Incrementa (ou decrementa) o prazo na data fornecida       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ SomaPrazo(dData, nPrazo)                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ dData  - Data que sera incrementada/decrementada           ³±±
±±³          ³ nPrazo - Numero de dias que sera incrementado/decrementado ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Mata650                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
*/
Function SomaPrazo(dData, nPrazo)
Static nSomaPrazo
Static lCalcOper
Static cSemana

Local nStep   := If(nPrazo < 0, -1, 1)
Local nDias   := 0
Local nPrzAbs := Abs(nPrazo)
Local lContinua := .T.

If lCalcOper == Nil
	lCalcOper := SuperGetMv("MV_PEOPERA", .F., .F.)
EndIf

//Se calcular por operação já calculou os dias considerando o calendário.
//Não deverá calcular novamente o final de semana.
If lCalcOper
	cSemana := "1234567"
EndIf

If !lCalcOper
	If nSomaPrazo == Nil
		If IsInCallStack("MATA712") .or. IsInCallStack("PCPA107")
			If aPergs711[12] == 1
				cSemana := "1234567"
			else
				cSemana := "23456"
			endif
		else
			nSomaPrazo := SuperGetMv("MV_CALCPRZ", .F., 0) //  0=Segunda a Segunda;1=Segunda a Sabado; 2=Segunda a Sexta
			If     nSomaPrazo == 1
				cSemana := "234567"
			ElseIf nSomaPrazo == 2
				cSemana := "23456"
			Else
				cSemana := "1234567"
			EndIf
		EndIf
	EndIf
EndIf

If nSomaPrazo == 0
	dData += nPrazo
	lContinua := .F.
EndIf

Do While lContinua .And. nDias < nPrzAbs
	dData += nStep
	If Str(Dow(dData), 1) $ cSemana
		nDias ++
	Endif

	/*/ Ponto de Entrada MA650PRZ Manipular o numero de dias quando MV_CALCPRZ diferente de 0=Segunda a Segunda /*/
	IF ExistBlock('MA650PRZ')
		nDias := ExecBlock('MA650PRZ',.F.,.F.,{dData,nPrazo,nDias})
	Endif
EndDo

Return(dData)

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³A650VldLoclz  ³ Autor ³Marcelo Iuspa      ³ Data ³ 11/04/05 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Valida saldo na localizacao informada no empenho           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ A650VldLoclz()                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ Lidos diretamente no array aCols                           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Mata650                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
*/
Function A650VldLoclz(lConsEst)
Local cAlmox    := GDFieldGet("D4_LOCAL"  ,, .T.)
Local cLocaliza := GDFieldGet("DC_LOCALIZ",, .T.)
Local cCod      := GDFieldGet("G1_COMP"   ,, .T.)
Local cNumSerie := GDFieldGet("DC_NUMSERI",, .T.)
Local cLoteCtl  := GDFieldGet("D4_LOTECTL",, .T.)
Local cLote     := GDFieldGet("D4_NUMLOTE",, .T.)
Local nQuant    := GDFieldGet("D4_QUANT"  ,, .T.)
Local nSaldo    := Nil
Local lRet      := .T.

If !Localiza(cCod,.T.)
	Help("",1,"NAOLOCALIZ")
	lRet := .F.
EndIf

If lRet .And. ! A650VldConsEst(lConsEst)
	lRet := .F.
EndIf

If lRet .And. ((!Empty(cLocaliza)) .Or. (!Empty(cNumSerie)))
	If lWmsNew .And. IntWMS(cCod)
		// Quando WMS neste momento só pode escolher endereço de produção
		// Caso queira outro endereço, deverá escolher no WMS no atendimento das requisições
		lRet := Wms650End(cAlmox,cLocaliza)
		If lRet
			nSaldo := WmsSldD14(cAlmox,cLocaliza,cCod,cNumSerie,cLoteCtl,cLote,.F.)
		EndIf
	Else
		nSaldo := SaldoSBF(cAlmox,cLocaliza,cCod,cNumSerie,cLoteCtl,cLote,.F.)
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifico se o saldo na localizacao for MENOR que o empenho        ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

	If lRet
		Do case
			Case (nQuant < 0)
				Help(NIL, NIL, STR0024, NIL, STR0210, 1, 0, NIL, NIL, NIL, NIL, NIL, {STR0211})
				//"Produto de Empenho negativo, com Controle de Endereçamento, não permite identificar o endereço sem realizar a produção. "
				//"Favor, não preencher endereço para o empenho com quantidade negativa."
				lRet := .F.
			Case  nSaldo < nQuant
				Help(" ",1,"SALDOLOCLZ",,	AllTrim(RetTitle("DC_LOCALIZ")) + ": " + AllTrim(cLocaliza) + Chr(13) + Chr(10) + ;
					AllTrim(RetTitle("BF_QUANT"))   + ": " + AllTrim(Str(nSaldo)), 4, 0)
				lRet := .F.
		EndCase
    EndIf
EndIf

Return(lRet)

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³A650VldConsEst³ Autor ³Marcelo Iuspa      ³ Data ³ 12/04/05 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Valida MV_CONSEST na digitacao de lote/localizacao         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ A650VldConsEst                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ lConsEst - Verdadeiro se MV_CONSEST = Sim                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Mata650                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
*/
Function A650VldConsEst(lConsEst)
Local cLocaliza  :=  ' '
Local cNumSerie  :=  ' '
Local cLoteCtl   :=  ' '
Local cLote      :=  ' '
Local lRet		 := .T.
Local lContinua	 := .T.
Local lConEst   := .F.

Default lConsEst := SuperGetMV("MV_CONSEST") == "S"

If lConsEst
	lContinua	:= .F.
	lRet		:= .T.
Else

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Ponto de entrada para liberação de escolha de lotes/endereços ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If  ExistBlock("M650CONSES")
		lConEst := ExecBlock("M650CONSES",.F.,.F.)
	EndIf
	If !lConEst

		cLocaliza  := GDFieldGet("DC_LOCALIZ",, .T.)
		cNumSerie  := GDFieldGet("DC_NUMSERI",, .T.)
		cLoteCtl   := GDFieldGet("D4_LOTECTL",, .T.)
		cLote      := GDFieldGet("D4_NUMLOTE",, .T.)

		If (!Empty(cLocaliza)) .Or. (! Empty(cLote)) .Or. (! Empty(cLoteCtl)) .Or. (! Empty(cNumSerie))
			Aviso("MV_CONSEST", STR0105, {"Ok"}) // "Nao poderao ser escolhidos lotes ou enderecos para empenho pois o parametro MV_CONSEST esta com conteudo como N (Nao)"
			lRet := .F.
		EndIf

	Else
		lContinua	:= .F.
		lRet		:= .T.
	EndIf

Endif

Return lRet
/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³ NumReg   ³ Autor ³ Rodrigo de A Sartorio ³ Data ³ 04/11/05 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descricao ³ Checa o numero de registros para processar PACK            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA650                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function A650NumReg()
Local lProcPack:=.F.
If Select("TMP") > 0 .And. TMP->(LastRec()) > 500
	lProcPack:=.T.
Endif
RETURN lProcPack

//--------------------------
Function ViA650b()
	If SHY->(DBSEEK(xFilial("SHY")+SC2->(C2_NUM+C2_ITEM+C2_SEQUEN)))
		FWExecView("","MATA650b")
	Else
		Help( ,, 'Help',, STR0228+Alltrim(SC2->C2_NUM)+STR0229+Alltrim(SC2->C2_ITEM)+STR0230+Alltrim(SC2->C2_SEQUEN) , 1, 0 )
	Endif
Return .T.

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Programa  ³MenuDef   ³ Autor ³ Fabio Alves Silva     ³ Data ³13/11/2006³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Utilizacao de menu Funcional                               ³±±
±±³          ³                                                            ³±±
±±³          ³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Array com opcoes da rotina.                                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³Parametros do array a Rotina:                               ³±±
±±³          ³1. Nome a aparecer no cabecalho                             ³±±
±±³          ³2. Nome da Rotina associada                                 ³±±
±±³          ³3. Reservado                                                ³±±
±±³          ³4. Tipo de Transa‡„o a ser efetuada:                        ³±±
±±³          ³		1 - Pesquisa e Posiciona em um Banco de Dados           ³±±
±±³          ³    2 - Simplesmente Mostra os Campos                       ³±±
±±³          ³    3 - Inclui registros no Bancos de Dados                 ³±±
±±³          ³    4 - Altera o registro corrente                          ³±±
±±³          ³    5 - Remove o registro corrente do Banco de Dados        ³±±
±±³          ³5. Nivel de acesso                                          ³±±
±±³          ³6. Habilita Menu Funcional                                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³   DATA   ³ Programador   ³Manutencao efetuada                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³               ³                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/

Static Function MenuDef()

	PRIVATE aRotina := {{STR0001,"AxPesqui"	  , 0 , 1, 0 , .F.},;	//"Pesquisar"
						{STR0047,"A650View"	  , 0 , 2, 0 , nil},;	//"Visualizar"
						{STR0003,"A650Inclui" , 0 , 3,139, nil},;	//"Incluir"  //139 - Permitir incluir Ordem de Producao
						{STR0002,"MATA650C"	  , 0 , 3, 0 , nil},;	//"venDas"
		  				{STR0166,"ViA650b"    , 0 , 2, 0 , nil},;	//"Operações da Ordem"
						{STR0231,"A650EnOp"   , 0 , 2, 0 , nil},;	//"Encerrar Ordem"
						{STR0004,"A650Altera" , 0 , 4, 0 , nil},;	//"Alterar"
						{STR0005,"A650Deleta" , 0 , 5, 0 , nil},;	//"Excluir"
						{STR0086,"A650FWLayer", 0 , 2, 0 , nil},;	//"Grafico"
						{STR0098,"A650Priori" , 0 , 2, 0 , nil},;	//"Reprioriza"
						{STR0064,"A650Legend" , 0 , 1, 0 , .F.}}  	//"Legenda"

	If SuperGetMv("MV_SELEOPC") == "S"
		aAdd(aRotina,{STR0175,"A650Opc"   , 0 , 2, 0 , nil}) //"Opcionais"
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ P.E. Utilizado para adicionar botoes ao Menu Principal       ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	IF ExistBlock('MA650BUT')
		aRotina := ExecBlock('MA650BUT',.F.,.F.,aRotina)
	Endif

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Ponto de entrada utilizado para inserir novas opcoes no array aRotina  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If ExistBlock("MTA650MNU")
		ExecBlock("MTA650MNU",.F.,.F.)
	EndIf
Return(aRotina)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³A650Prev  ³ Autor ³Rodrigo de A Sartorio  ³ Data ³09/01/07  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Checa saldo previsto pendente para gravacao                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ A650Prev(ExpC1)                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Cadastro de produtos                               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Mata650                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function A650Prev(cProduto)
Local nAchou:= 1
Local nRet  :=0
Local lQtdPrev := SuperGetMV("MV_QTDPREV",.F.,"N")=="S"
Local nSC1 := 0

for nSC1 := 1 to len(aOpC1)
	If Alltrim(aOpC1[nSC1][1]) == Alltrim(cProduto) .AND.;
				((aOpC1[nSC1][10] >= ASAV650[3] .AND. aOpC1[nSC1][10] <= ASAV650[4]) .OR. ASAV650[2] == 1) .AND.;
		If(!lQtdPrev,aOpC1[nSC1][11] # "P",.T.)

		nRet+=aOpC1[nSC1,2]
	EndIf
next nSC1

If ASAV650[2] == 1 .Or. (Empty(ASAV650[3]) .And. Empty(ASAV650[4]))
	nAchou:=ASCAN(aOpC7,{|x| x[1] == cProduto .And. If(!lQtdPrev,x[6] # "P",.T.)})
	If nAchou > 0
		nRet+=aOpc7[nAchou,2]
	EndIf
Else
	If type("aOpC7Local") == 'A'
		nAchou:=ASCAN(aOpC7Local,{|x| x[1] == cProduto .And. (x[10] >= ASAV650[3] .And. x[10] <= ASAV650[4]) .And. If(!lQtdPrev,x[6] # "P",.T.)})
		If nAchou > 0
			nRet+=aOpC7Local[nAchou,2]
		EndIf
	EndIf
EndIf

for nSC1 := 1 to len(aDataOpC1)
	If Alltrim(aDataOpC1[nSC1][1]) == Alltrim(cProduto) .AND.;
		((aDataOpC1[nSC1][10] >= ASAV650[3] .AND. aDataOpC1[nSC1][10] <= ASAV650[4]) .OR. ASAV650[2] == 1) .AND.;
		If(!lQtdPrev,aDataOpC1[nSC1][11] # "P",.T.)

		nRet+=aDataOpc1[nSC1,2]
	EndIf
next nSC1

nAchou:=ASCAN(aDataOpC7,{|x| x[1] == cProduto .And. (x[10] >= ASAV650[3] .And. x[10] <= ASAV650[4]) .And. If(!lQtdPrev,x[6] # "P",.T.)})
If nAchou > 0
	nRet+=aDataOpc7[nAchou,2]
EndIf
RETURN nRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³ValLocProc| Autor ³ Felipe Nunes de Toledo ³ Data ³ 17/11/06³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Validacao do Local de Processo na geracao do Empenho.      ³±±
±±³          ³ Alerta o usuario caso nformado um armazem que nao seja o   ³±±
±±³          ³ arm. de processo, p/ prod. com aprop. indireta.            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ cProduto = Codigo do produto a ser analisado               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA650 / MATA380                                          ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function ValLocProc(cProduto)
	Local cLocal   := &(ReadVar())
Local lRet     := .T.
Local aAreaSB1 := SB1->(GetArea())
Local cLocProc := GetMvNNR('MV_LOCPROC','99')

SB1->(dbSetOrder(1))
SB1->(MsSeek(xFilial("SB1")+cProduto))

If !IsBlind() .And. SB1->B1_APROPRI == "I" .And. cLocal <> cLocProc
	//"Aviso"##"O produto possui apropriação indireta e o local informado não é o local de processo (MV_LOCPROC)."##"Confirma"##"Cancela"
	If Aviso(STR0108,STR0129,{STR0063,STR0130}) == 2
		&(ReadVar()) := cLocProc
	EndIf
Endif

RestArea( aAreaSB1 )
Return( lRet )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³A650AtuSusp| Autor ³ Andre Anjos			  ³ Data ³ 14/02/08³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Em caso de suspencao de OP atualiza a quantidade suspensa   ³±±
±±³			 ³	nos empenhos. Em caso de nao suspencao zera a quantidade   ³±±
±±³			 ³	suspensa no empenho.									   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ lSusp = Indica se a OP esta suspensa			               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA650 													   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function A650AtuSusp(lSusp)
Local aArea := GetArea()
Local cChave := SC2->(C2_NUM+C2_ITEM+C2_SEQUEN+C2_ITEMGRD)
Local cFilSD4 := xFilial("SD4")

dbSelectArea("SD4")
dbSetOrder(2)//D4_FILIAL+D4_OP+D4_COD+D4_LOCAL
dbSeek(cFilSD4+cChave)

While !EOF() .And. SD4->(D4_FILIAL+D4_OP) == cFilSD4+cChave
	If lSusp
		RecLock("SD4",.F.)
		Replace D4_QSUSP With D4_QUANT
		MsUnLock()
	Else
		RecLock("SD4",.F.)
		Replace D4_QSUSP With 0
		MsUnLock()
	EndIf

	dbSkip()
End

RestArea(aArea)
Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  |A650EmpAltºAutor  ³Andre Anjos		 º Data ³  24/03/09   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDescricao ³ Rotina que coloca produtos alternativos no aCols de		  º±±
±±º			 | empenhos.                                                  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³ cProdOri: produto origem da relacao com o alternativo	  º±±
±±º			 ³ nQtdOri: quantidade origem								  º±±
±±º			 ³ uConteudo: ponto de entrada A650ADCOL					  º±±
±±º			 ³ cLocProc: armazem de processo							  º±±
±±º			 ³ aParamPE: array contendo {cProduto,nQuantPai,cOpcionais,   º±±
±±º			 ³           cRevisao} para uso do ponto de entrada A650ADCOL º±±
±±º			 ³ dEntrega: data da necessidade							  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ MATA650                                                    º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function A650EmpAlt(cProdOri,nQtdOri,uConteudo,cLocProc,aParamPE,dEntrega,cOpcionais,cProOpc,aOpcCam,cOperac,cTrtOri,cRevisao)
Local aArea      := GetArea()
Local aRetorno   := {}
Local aRetLote   := {}
Local aDelLotes  := {}
Local alocProp   := {}
Local alocais    := {}
Local cLocAn     := ""
Local nQtdPrj    := 0
Local nX         := 0
Local nJ         := 0
Local nQuantItem := 0
Local nQtd2UM    := 0
Local nQuantPot  := 0
Local nQuantPot2 := 0
Local nSldDisp   := 0
Local nRetPE	 := 0
Local lEmpPrj    := SuperGetMV("MV_EMPPRJ",.F.,.T.)
Local cArmAlte   := SuperGetMV("MV_ARMALTE",.F.,"1")
Local lRetPe	 := .T.
Local lBuscouLot := .F.
Local nRecSG1	 := SG1->(RECNO())
Local nInd       := 0
Local lExistEmSa := .F.
Local aArmazens  := {}
Local cRoteiro   := ""
Local nRecPriSGI := 0
Local cArmPriSGI := ""
Local lProduzOri := .T.
Local lLocProp   := .F.
Local cFilSGI    := xFilial("SGI")
Local cFilSB1    := xFilial("SB1")
Local cFilSGF    := xFilial("SGF")
Local lQtdPrev   := SuperGetMV("MV_QTDPREV",.F.,"N")
Local lExisGiDat := SGI->(FieldPos("GI_DATA")) > 0
Local aAreaSB1   := {}
Local lExisGiEst := SGI->(FieldPos("GI_ESTOQUE")) > 0
Local nAchoAlt   := 0
Local nLin       := 0
Local n1         := 0
Local n 		 := 0
Local aRetltsdl  := {}
Local nAc        := 0
Local nPosicao   := 0
Local lMA650ACG   := ExistBlock('MA650ACG')

Default cLocProc := GetMvNNR('MV_LOCPROC','99')
Default aParamPE := Array(4)
Default dEntrega := SC2->C2_DATPRI
Default cOperac  := ""
Default cRevisao := Space(Len(SB1->B1_REVATU))

sG1TRT := Iif(sG1TRT == NIL, CriaVar("G1_TRT"), sG1TRT)

Static lA650VLALT:= ExistBlock("A650VLALT")
Static lA650ADCOL:= ExistBlock("A650ADCOL")
Static lA650SALDO:= ExistBlock("A650SALDO")
Static lA650ASCOL:= ExistBlock("A650ASCOL")

// somente atribuir valor depois de declarada a static pois pode dar problema no menudef

dbSelectArea("SGI")
dbSetOrder(1)
dbSeek(cFilSGI+cProdOri)
While	nQtdOri > 0					.And. ;
		SGI->(!EOF())				.And. ;
		SGI->GI_FILIAL  == cFilSGI	.And. ;
		SGI->GI_PRODORI == cProdOri

	If lExisGiDat
		If !Empty(SGI->GI_DATA) .And. SGI->GI_DATA > SC2->C2_DATPRI
			SGI->(dbSkip())
			Loop
		EndIf
	EndIf

	//reposiciona SG1 que se perde no loop
	SG1->(dbGoto(nRecSG1))

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//| Posiciona SB1 |
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	SB1->(MsSeek(cFilSB1+SGI->GI_PRODALT))

	If SB1->B1_MSBLQL=="1"
		SGI->(dbSkip())
		Loop
	EndIF

	If lA650VLALT
		lRetPe := ExecBlock("A650VLALT",.F.,.F.)
		If ValType(lRetPe) == "L"
			If !lRetPE
				SGI->(dbSkip())
				Loop
			EndIf
		EndIf
	EndIf

	If cArmAlte == "2" .And. !lProj711 //MRP não verifica todos os armazens para os produtos alternativos.
		If SB1->B1_APROPRI=="I"
			aArmazens := buscaArmzm(RetFldProd(SGI->GI_PRODALT,"B1_LOCPAD"))
			For n := 1 to len(aArmazens)
				If aArmazens[n] == cLocProc
					lLocProp := .T.
				Endif
			Next n
			If !lLocProp
				Aadd(aArmazens, cLocProc)
			Endif
		Else
			aArmazens := buscaArmzm(RetFldProd(SGI->GI_PRODALT,"B1_LOCPAD"))
		EndIf

		//aArmazens := buscaArmzm(Iif(SB1->B1_APROPRI=="I",cLocProc,RetFldProd(SGI->GI_PRODALT,"B1_LOCPAD")))
	Else
		aArmazens := {Iif(SB1->B1_APROPRI=="I",cLocProc,RetFldProd(SGI->GI_PRODALT,"B1_LOCPAD"))}
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//Orderna o array aArmazens para que se houver o armazem de apropriação |
	//indireta, seja consideraro primeiro.  						   	    |
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If !Empty(aArmazens)
		For n := 1 To Len(aArmazens)
			If aArmazens[n] = cLocProc
				aAdd(alocProp, aArmazens[n])
			Else
				aAdd(alocais, aArmazens[n])
			EndIf
		Next n
		aArmazens := alocProp
		For n:= 1 to len(alocais)
			aAdd(aArmazens,alocais[n])
		Next n
	EndIf

	For nJ := 1 To Len(aArmazens)

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//| Converte a quantidade conforme fator |
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If SGI->GI_TIPOCON == "M"
			nQuantItem := nQtdOri * SGI->GI_FATOR
		Else
			nQuantItem := nQtdOri / SGI->GI_FATOR
		EndIf
		nQtd2UM	:= ConvUM(SGI->GI_PRODALT,nQuantItem,0,2)

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//| Analisa saldo disponivel do alternativo |
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If lProj711 .And. !lMata712 .And. !lPCPA107
			nSldDisp := A650UsoSH5(SG1->G1_COD,SGI->GI_PRODALT,cProdOri,cOpcionais,A650DtoPer(dEntrega),nQuantItem)
		ElseIf lMata712 .And. !lPCPA107
			nSldDisp := A650UsoCZI(SG1->G1_COD,SGI->GI_PRODALT,cProdOri,cOpcionais,A650DtoPer(dEntrega),nQuantItem)
		ElseIf lPCPA107
			nSldDisp := A650UsoSOQ(SG1->G1_COD,SGI->GI_PRODALT,cProdOri,cOpcionais,A650DtoPer(dEntrega),nQuantItem)
		Else
			SB2->(dbSeek(xFilial("SB2")+SGI->GI_PRODALT+aArmazens[nJ]))

			//O parâmetro mv_par02 vale somente para o componente da OP, não para o alternativo
			//o alternativo considera os locais conforme parametro cArmAlte
			//If( mv_par02 = 1 )
			//   SB2->(dbSeek(xFilial("SB2")+SGI->GI_PRODALT+RetFldProd(SGI->GI_PRODALT,"B1_LOCPAD")))
			//Else
			//   SB2->(dbSeek(xFilial("SB2")+SGI->GI_PRODALT+If(SB1->B1_APROPRI=="I",cLocProc,RetFldProd(SGI->GI_PRODALT,"B1_LOCPAD"))))
			//Endif

			If EOF()
				CriaSB2(SGI->GI_PRODALT,aArmazens[nJ])
				MsUnlock()
			EndIf
			If !lEmpPrj
				nQtdPrj := SB2->B2_QEMPPRJ
			EndIf
			nSldDisp := SaldoSB2(.T., , ,lConsTerc,lConsNPT,,,nQtdPrj)+SB2->B2_SALPEDI-SB2->B2_QEMPN+AvalQtdPre("SB2",2)
			nSldDisp += A650Prev(SB2->B2_COD)
		EndIf

        // Verifica o saldo quando utilizados alternativos / lotes
        // E atualizado o saldo utilizado na variavel avalAlt
        IF LEN(aValAlt) > 0 .and. aValAlt # NIL
            nSldUsa := 0
            For n1 := 1 to len(aValAlt)
                IF aValAlt[n1,6] = SB2->(RECNO())  .AND.  aValAlt[n1,5] = aArmazens[nJ]
                    nSldUsa += aValAlt[n1,3]
                ENDIF
            Next n1
            IF nSldUsa > 0
                nSldDisp -= nSldUsa
            Endif
        Endif

		//Verifica array de saldo do alternativo para descontar o que ja foi empenhado no nivel anterior
		If !lProj711 .And. !lMata712
			lExistEmSa := .F.

			For nInd := 1 to len(aAltSaldo)
				If aAltSaldo[nInd,1] == SGI->GI_PRODALT .And. AllTrim(aAltSaldo[nInd,3]) == AllTrim(aArmazens[nJ])

					nSldDisp -= aAltSaldo[nInd,2]

			    	If nSldDisp <= 0
						nSldDisp := 0
				    EndIf
					lExistEmSa := .T.
					Exit
				EndIf
			Next nInd
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Executa P.E. para tratar saldo disponivel.                    ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If ExistTemplate("A650SALDO")
			nQtdBack := nSldDisp
			nSldDisp := ExecTemplate("A650SALDO",.F.,.F.,nSldDisp)
			If ValType(nQtyStok) != "N"
				nSldDisp := nQtdBack
			EndIf
		EndIf
		If lA650SALDO
			nQtdBack := nSldDisp
			nSldDisp := ExecBlock("A650SALDO",.F.,.F.,nSldDisp)
			If ValType(nSldDisp) != "N"
				nSldDisp:=nQtdBack
			EndIf
		EndIf

		//Desconta a qtd. dos lotes vencidos do saldo encontrado da SB2.
		lBuscouLot := .F.
		If SuperGetMV("MV_LOTVENC",.F.,"S") == "N" .And. (Rastro(SGI->GI_PRODALT))
			lBuscouLot := .T.
			cLocAn := If(SB1->B1_APROPRI=="I",aArmazens[nJ],If(MV_PAR02==1,aArmazens[nJ],aSav650[3]))
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Verifica informacoes de maneira diferenciada quando produto  ³
			//³ utiliza controle de potencia identificada na estrutura.      ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If !PotencLote(SGI->GI_PRODALT)
				aRetLote := SldPorLote(SGI->GI_PRODALT,cLocAn,999999999999999,999999999999999,NIL,NIL,NIL,NIL,NIL,.T.,;
				                       If(mv_par02==1 .Or. cLocAn == cLocProc,NIL,aSav650[4]),.T.,nil,;
				                       If(SC2->C2_TPOP == "F",lQtdPrev=="S" .And. !PotencLote(SGI->GI_PRODALT),.T.),;
				                       dDataBase)
			Else
				aRetLote := SldPorLote(SGI->GI_PRODALT,cLocAn,999999999999999,999999999999999,NIL,NIL,NIL,NIL,NIL,.T.,;
				                       If(mv_par02==1 .Or. cLocAn == cLocProc,NIL,aSav650[4]),.T.,nil,;
				                       If(SC2->C2_TPOP == "F",lQtdPrev=="S" .And. !PotencLote(SGI->GI_PRODALT),.T.),;
				                       dDataBase)
			EndIf
			aSize(aDelLotes,0)
			For nX := 1 To Len(aRetLote)
		    	//Verifica se o lote está vencido.
				If !Empty(aRetLote[nx][7]) .And. aRetLote[nx][7] < dDataBase
					//Subtrai a quantidade deste lote do saldo total
					nSldDisp -= aRetLote[nx][5]

					//Armazena essa posição do array para excluir do aRetLote posteriormente.
					aAdd(aDelLotes,nx)
				EndIf
			Next nX

			//Ordena o array de deleção de lotes vencidos,
			//para que a exclusão seja feita do final do array para o começo.
			aSort(aDelLotes,,,{|x,y| x > y})

			For nx := 1 To Len(aDelLotes)
				//Remove os lotes vencidos do array de saldos por lote.
				aDel(aRetLote,aDelLotes[nx])
			Next nx
			aSize(aRetLote,Len(aRetLote)-Len(aDelLotes))
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//| Prepara nQtdOri para loop	|
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		dbSelectArea("SGI")
		Do Case
			Case nSldDisp <= 0 //desconsidera alternativo
				nQuantItem := 0
			Case nSldDisp < nQuantItem //volta diferenca para pegar outro alternativo
				If SGI->GI_TIPOCON == "M"
					nQtdOri -= (nSldDisp / SGI->GI_FATOR)
				Else
					nQtdOri -= (nSldDisp * SGI->GI_FATOR)
				EndIf
				nQuantItem := nSldDisp
				nQtd2UM := ConvUM(SGI->GI_PRODALT,nQuantItem,0,2)
			Otherwise //finaliza busca pois empenha somente este alternativo
				nQtdOri := 0
		EndCase

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//| Busca lotes/enderecos a sugerir		    |
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		// Quando WMS novo neste ponto não deve sugerir o endereço, por isso não passa .T. para Localiza(cProduto,lWMS)
		If nSldDisp > 0 .And. mv_par08 == 1 .And. (Rastro(SGI->GI_PRODALT) .Or. Localiza(SGI->GI_PRODALT))
			If lBuscouLot
				//Saldos por lote já foram buscados, utiliza a mesma variável para não consultar novamente.
				aRetorno := aRetLote
			Else
				cLocAn := If(SB1->B1_APROPRI=="I",aArmazens[nJ],If(MV_PAR02==1,aArmazens[nJ],aSav650[3]))
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Verifica informacoes de maneira diferenciada quando produto  ³
				//³ utiliza controle de potencia identificada na estrutura.      ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If !PotencLote(SGI->GI_PRODALT)
					aRetorno:=SldPorLote(SGI->GI_PRODALT,cLocAn,nQuantItem,nQtd2UM,NIL,NIL,NIL,NIL,NIL,.T.,;
												If(mv_par02==1 .Or. cLocAn == cLocProc,NIL,aSav650[4]),nil,nil,;
												If(SC2->C2_TPOP == "F",lQtdPrev=="S" .And. !PotencLote(SGI->GI_PRODALT),.T.),;
												dDataBase)
				Else
					aRetorno:=SldPorLote(SGI->GI_PRODALT,cLocAn,999999999999999,999999999999999,NIL,NIL,NIL,NIL,NIL,.T.,;
												If(mv_par02==1 .Or. cLocAn == cLocProc,NIL,aSav650[4]),nil,nil,;
												If(SC2->C2_TPOP == "F",lQtdPrev=="S" .And. !PotencLote(SGI->GI_PRODALT),.T.),;
												dDataBase)
				EndIf
			EndIf
			For nX := 1 To Len(aRetorno)
		    	aRetorno[nX,5] := Min(aRetorno[nX,5],If(QtdComp(nSldDisp)<QtdComp(0),0,nSldDisp))
		    	aRetorno[nX,6] := Min(aRetorno[nX,6],ConvUM(SGI->GI_PRODALT,If(QtdComp(nSldDisp)<QtdComp(0),0,nSldDisp),0,2))
			Next nX
		EndIf

        // Ajuste o valor do aRetorno, comparando se existe produto alternativo para mais que um componente.
        If !lProj711 .And. !lMata712 .And. !lPCPA107
            IF LEN(aRetorno) > 0 .AND. LEN(aValAlt) > 0

                aRetltsdl :=  IIF(lBuscouLot ,aRetLote,{})  //{}
                //Simula quantidade por lote

                IF ! lBuscouLot
                    aRetltsdl:=SldPorLote(SGI->GI_PRODALT,cLocAn,999999999999999,999999999999999,NIL,NIL,NIL,NIL,NIL,.T.,;
                    If(mv_par02==1 .Or. cLocAn == cLocProc,NIL,aSav650[4]),nil,nil,;
                    If(SC2->C2_TPOP == "F",lQtdPrev=="S" .And. !PotencLote(SGI->GI_PRODALT),.T.),;
                    dDataBase)
                ENDIF

                For nlin := 1 to len(aRetltsdl)
                    nAchoAlt:= ASCAN(aValAlt,{ |x| x[1] == aRetltsdl[nlin,1]; // Lote
                            .And. x[2] == aRetltsdl[nlin,2];                  // Sublote
                            .And. x[5] == aRetltsdl[nlin,11];                 // Local
                            .And. x[6] == aRetltsdl[nlin,8] })                // recno Sb2

                    IF nAchoAlt > 0
						aRetorno  := {}
                        IF  aValAlt[nAchoAlt,3] < aRetltsdl[nlin,5]                       //verifica se tem Saldo no lote
                            aRetltsdl[nlin,5] := aRetltsdl[nlin,5] - aValAlt[nAchoAlt,3]  // desconta o Saldo
                            aRetltsdl[nlin,6] := ConvUM(SGI->GI_PRODALT, aRetltsdl[nlin,5], 0, 2)
							aadd(aRetorno,aRetltsdl[nlin])                                //Acrescentar no array aRetorno
                        Endif
                    Endif

                Next nlin
       		Endif
        Endif


		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//| Gera empenho para o alternativo |
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		For nX := 1 To Len(aRetorno)
			If QtdComp(aRetorno[nX,5]) > QtdComp(0) .And. If(PotencLote(SGI->GI_PRODALT),aRetorno[nX,12] > 0,.T.)
				AADD(aCols,ARRAY(Len(aHeader)+2))
				aCols[Len(aCols),nPosCod] := SGI->GI_PRODALT
				If PotencLote(SGI->GI_PRODALT)
					// PRIMEIRA UNIDADE DE MEDIDA
					nQuantPot:=aRetorno[nX,5]*(aRetorno[nX,12]/100)
					aCols[Len(aCols),nPosQuant] := Min(nQuantPot,nQuantItem)
					nQuantPot:=aCols[Len(aCols),nPosQuant]
					aCols[Len(aCols),nPosQuant] := aCols[Len(aCols),nPosQuant]/(aRetorno[nX,12]/100)
					// SEGUNDA UNIDADE DE MEDIDA
					nQuantPot2:=aRetorno[nX,6]*(aRetorno[nX,12]/100)
					aCols[Len(aCols),nPosQtSegum] := Min(nQuantPot2,nQtd2UM)
					nQuantPot2:=aCols[Len(aCols),nPosQtSegum]
					aCols[Len(aCols),nPosQtSegum] := aCols[Len(aCols),nPosQtSegum]/(aRetorno[nX,12]/100)
				Else
					aCols[Len(aCols),nPosQuant] := Min(aRetorno[nX,5],nQuantItem)
					aCols[Len(aCols),nPosQtSegum]:=Min(aRetorno[nX,6],nQtd2UM)
				EndIf
				aCols[Len(aCols),nPosLocal] := aRetorno[nX,11]
				aCols[Len(aCols),nPosTRT]   := CriaVar("G1_TRT")
				aCols[Len(aCols),nPosLote]  := aRetorno[nX,2]
				aCols[Len(aCols),nPosLotCtl]:= aRetorno[nX,1]
				aCols[Len(aCols),nPosdValid]:= aRetorno[nX,7]
				aCols[Len(aCols),nPosPotenc]:= aRetorno[nX,12]
				aCols[Len(aCols),nPosLocLz] := aRetorno[nX,3]
				aCols[Len(aCols),nPosnSerie]:= aRetorno[nX,4]
				aCols[Len(aCols),nPosUM]    := SB1->B1_UM
				aCols[Len(aCols),nPos2UM]   := SB1->B1_SEGUM
				aCols[Len(aCols),nPosDescr] := SB1->B1_DESC

				If Type("nPosOper") == "N" .And. nPosOper > 0
					If Empty(cOperac) .Or. Empty(cRoteiro)
						If Empty(SC2->C2_ROTEIRO)
							aAreaSB1   := SB1->(GetArea())
							cRoteiro := POSICIONE('SB1',1,cFilSB1+SC2->C2_PRODUTO,'B1_OPERPAD')
							SB1->(RestArea(aAreaSB1))
							If Empty(cRoteiro)
								cRoteiro := '01'
							Endif
						Else
							cRoteiro := SC2->C2_ROTEIRO
						Endif
						dbSelectArea("SGF")
						SGF->(dbSetOrder(2))
						If SGF->(dbSeek(cFilSGF + SC2->C2_PRODUTO + cRoteiro + SG1->G1_COMP + SG1->G1_TRT))
							aCols[Len(aCols),nPosOper] := MATAFINDOP(SC2->C2_PRODUTO, cRoteiro, SGF->GF_OPERAC, SG1->G1_COMP)
						Else
							aCols[Len(aCols),nPosOper] := MATAFINDOP(SC2->C2_PRODUTO, cRoteiro, cOperac, SG1->G1_COMP)
						Endif
					Else
						aCols[Len(aCols),nPosOper] := MATAFINDOP(SC2->C2_PRODUTO, cRoteiro, cOperac, SG1->G1_COMP)
					EndIf
				EndIf

				If nPosPrdOrg > 0
					aCols[Len(aCols),nPosPrdOrg] := cProdOri
				EndIf

				aCols[Len(aCols),nPosIsAlt] := STR0201 //Alternativo == Sim
				aCols[Len(aCols),nPosTRTORI ] := SG1->G1_TRT

				If ValType(uConteudo) != "U"
					If !lMTA650AC .And. lMA650ACG
						For nAc := 1 To Len(uConteudo)
							nPosicao := aScan(aHeader,{|x| AllTrim(x[2]) == AllTrim(uConteudo[nAc][2])})
							aCols[Len(aCols), nPosicao] := &("SD4->" + AllTrim(uConteudo[nAc][2]))
						Next nAc
					Else
						aCols[Len(aCols), Len(aHeader)] := &(uTrans)
					EndIf
				EndIf

				aCols[Len(aCols),Len(aHeader)+1] := {cProdOri, cTrtOri, nQtdOri, cLocAn} //Informações de produto alternativo.
				aCols[Len(aCols),Len(aHeader)+2] := .F. //D_E_L_E_T_

				If lA650ADCOL
					ExecBlock("A650ADCOL",.F.,.F.,aParamPE)
				EndIf

				If (cRevisao < SG1->G1_REVINI .OR. cRevisao > SG1->G1_REVFIM)
					AADD(aColsDele,Len(aCols))
				EndIf

				If PotencLote(SGI->GI_PRODALT)
					nQuantItem -= nQuantPot
					nQtd2UM    -= nQuantPot2
				Else
					nQuantItem -= aCols[Len(aCols),nPosQuant]
					nQtd2UM    -= aCols[Len(aCols),nPosQtSegum]
				EndIf
				aRetorno[nX,5] -= aCols[Len(aCols),nPosQuant]
				aRetorno[nX,6] -= aCols[Len(aCols),nPosQtSegum]

				AADD(aOpcCam,cProOpc + cProdOri + SG1->G1_TRT)
				AADD(aRecNec,{SG1->G1_COMP, SG1->G1_TRT, SG1->G1_QUANT})
			EndIf

            //Array para controle do produtos alternativos, quando varios componentes possuem o mesmo alternativo e esse tme lote.
                nAchoAlt:= ASCAN(aValAlt,{ |x| x[1] == aRetorno[nX,1];            // Lote
                                .And. x[2] == aRetorno[nX,2];                  // Sublote
                                .And. x[5] == aRetorno[nX,11];                 // Local
                                .And. x[6] == aRetorno[nX,8] })                // recno Sb2

                IF nAchoAlt > 0     //se econtrou lote utilizado, atualiza
                    aValAlt[nAchoAlt,3] += aCols[Len(aCols),nPosQuant]
                Else
                    aadd(aValAlt,{aCols[Len(aCols),nPosLotCtl],;   // 1 -Lote
                    aCols[Len(aCols),nPosLote],;	               // 2 -Sublote
                    aCols[Len(aCols),nPosQuant],;	               // 3 -Quantidade
                    aCols[Len(aCols),nPosQtSegum],;                // 4 -Quantidade Segunda Unidade
                    aCols[Len(aCols),nPosLocal],;                  // 5 -Local
                    aRetorno[nX,8]})                    		   // 6 -Recno SB2

                Endif

        	If QtdComp(nQuantItem,.t.) <= QtdComp(0,.t.)
				Exit
			EndIf
		Next nX

		If lExisGiEst .And. nQuantItem > 0 .And. Len(aRetorno) > 0/*Caso existam lotes porém os mesmos não tenham saldo suficiente*/
			If SGI->GI_ESTOQUE == "1"/**compra original */
				nQtdOri += nQuantItem
				nQuantItem := 0
			EndIf
		EndIF

		If nQuantItem > 0
			AADD(aCols,ARRAY(Len(aHeader)+2))
			aCols[Len(aCols),nPosCod    ] := SGI->GI_PRODALT
			aCols[Len(aCols),nPosQuant  ] := nQuantItem
			aCols[Len(aCols),nPosLocal  ] := Iif(SB1->B1_APROPRI=="I",cLocProc,aArmazens[nJ])
			aCols[Len(aCols),nPosTRT    ] := CriaVar("G1_TRT")
			aCols[Len(aCols),nPosLote   ] := CriaVar("D4_NUMLOTE")
			aCols[Len(aCols),nPosLotCtl ] := CriaVar("D4_LOTECTL")
			aCols[Len(aCols),nPosdValid ] := CriaVar("D4_DTVALID")
			aCols[Len(aCols),nPosPotenc ] := CriaVar("D4_POTENCI")
			aCols[Len(aCols),nPosLocLz  ] := CriaVar("DC_LOCALIZ")
			aCols[Len(aCols),nPosnSerie ] := CriaVar("DC_NUMSERI")
			aCols[Len(aCols),nPosUM     ] := SB1->B1_UM
			aCols[Len(aCols),nPosQtSegum] := nQtd2UM
			aCols[Len(aCols),nPos2UM    ] := SB1->B1_SEGUM
			aCols[Len(aCols),nPosDescr  ] := SB1->B1_DESC

			If Type("nPosOper") == "N" .And. nPosOper > 0
				If Empty(cOperac) .Or. Empty(cRoteiro)
					If Empty(SC2->C2_ROTEIRO)
						aAreaSB1   := SB1->(GetArea())
						cRoteiro := POSICIONE('SB1',1,cFilSB1+SC2->C2_PRODUTO,'B1_OPERPAD')
						SB1->(RestArea(aAreaSB1))
						If Empty(cRoteiro)
							cRoteiro := '01'
						Endif
					Else
						cRoteiro := SC2->C2_ROTEIRO
					Endif
					dbSelectArea("SGF")
					SGF->(dbSetOrder(2))
					If SGF->(dbSeek(cFilSGF + SC2->C2_PRODUTO + cRoteiro + SG1->G1_COMP + SG1->G1_TRT))
						aCols[Len(aCols),nPosOper] := MATAFINDOP(SC2->C2_PRODUTO, cRoteiro, SGF->GF_OPERAC, SG1->G1_COMP)
					Else
						aCols[Len(aCols),nPosOper] := MATAFINDOP(SC2->C2_PRODUTO, cRoteiro, cOperac, SG1->G1_COMP)
					Endif
				Else
					aCols[Len(aCols),nPosOper] := MATAFINDOP(SC2->C2_PRODUTO, cRoteiro, cOperac, SG1->G1_COMP)
				EndIf
			EndIf

			If nPosPrdOrg > 0
				aCols[Len(aCols),nPosPrdOrg] := cProdOri
			EndIf

			If ValType(uConteudo) != "U"
				If !lMTA650AC .And. lMA650ACG
					For nAc := 1 To Len(uConteudo)
						nPosicao := aScan(aHeader,{|x| AllTrim(x[2]) == AllTrim(uConteudo[nAc][2])})
						aCols[Len(aCols), nPosicao] := &("SD4->" + AllTrim(uConteudo[nAc][2]))
					Next nAc
				Else
					aCols[Len(aCols), Len(aHeader)] := &(uTrans)
				EndIf
			EndIf

			aCols[Len(aCols),nPosIsAlt]      := STR0201 //Alternativo == Sim
			aCols[Len(aCols),nPosTRTORI ] := SG1->G1_TRT
			aCols[Len(aCols),Len(aHeader)+1] := {cProdOri, cTrtOri, nQtdOri, cLocAn} //Informações de produto alternativo.
			aCols[Len(aCols),Len(aHeader)+2] := .F. //D_E_L_E_T_

			If lA650ADCOL
				ExecBlock("A650ADCOL",.F.,.F.,aParamPE)
			EndIf

			If (cRevisao < SG1->G1_REVINI .OR. cRevisao > SG1->G1_REVFIM)
				AADD(aColsDele,Len(aCols))
			EndIf

			//Michele
			//Inclui alternativo e o saldo no array
			If !lProj711 .And. !lMata712 .And. !lExistEmSa .And. !lPCPA107
	 			aadd(aAltSaldo,{SGI->GI_PRODALT,nQuantItem,aArmazens[nJ]})

			ElseIf !lProj711 .And. !lMata712 .And. lExistEmSa .And. !lPCPA107
				aAltSaldo[nInd][2]	+= nQuantItem

	 		EndIf

			//AADD(aOpcCam,cProOpc)
			AADD(aOpcCam,cProOpc + cProdOri + SG1->G1_TRT)
			AADD(aRecNec,{SG1->G1_COMP, SG1->G1_TRT, SG1->G1_QUANT})
		EndIf
	Next nJ

	If nRecPriSGI == 0
		nRecPriSGI := SGI->(RecNo())
		cArmPriSGI := aArmazens[1]
	EndIf

	SGI->(dbSkip())
End

//reposiciona SG1 que se perde no loop
SG1->(dbGoto(nRecSG1))

//Se existe sobra:
If nQtdOri > 0
	If lExisGiDat
		//Se tem alternativo válido:
		If nRecPriSGI > 0
			SGI->(dbGoTo(nRecPriSGI))

			//Estratégia de Estoque:
			//  1: Verifica o Produto Original, se não tiver saldo, verifica o Alternativo, se também não tiver saldo, compra/produz o Produto Original;
			//  2: Verifica o Produto Original, se não tiver saldo, verifica o Alternativo, se também não tiver saldo, compra/produz o Alternativo;
			//  3: Verifica o Alternativo, se não tiver saldo, compra/produz o Alternativo.
			If !Empty(SGI->GI_ESTOQUE) .And. SGI->GI_ESTOQUE != '1'
				lProduzOri := .F.
			EndIf
		EndIf
	EndIf

	If lProduzOri
		cCod := SG1->G1_COMP
		cTrt := SG1->G1_TRT
	Else
		cCod := SGI->GI_PRODALT
		cTrt := sG1TRT
		//Se produz/compra o alternativo, aplica o fator de conversão
		If SGI->GI_TIPOCON == "M"
			nQtdOri := nQtdOri * SGI->GI_FATOR
		Else
			nQtdOri := nQtdOri / SGI->GI_FATOR
		EndIf
	EndIf

	//Acumula saldo de empenho quando ja ha registro
	nProcura := 0
	For nX := 1 To Len(aCols)
		If aCols[nX][nPosCod] == cCod .And. aCols[nX][nPosTRT] == cTrt .And. aCols[nX][nPosLotCtl] == CriaVar("D4_LOTECTL");
		   .And. aCols[nX][nPosLote] == CriaVar("D4_NUMLOTE");
		   .And. IIf(nPosLocLz>0,(aCols[nX][nPosLocLz] == CriaVar("DC_LOCALIZ") .And. aCols[nX][nPosnSerie] == CriaVar("DC_NUMSERI")),.T.)
			If aScan(aColsDele,{|x| x == nX}) > 0
				nProcura := 0
			Else
				nProcura := nX
				Exit
			EndIf
		EndIf
	Next nX

  	If lA650ASCOL
    	nRetPE := ExecBlock("A650ASCOL",.F.,.F.,{aParamPE,nProcura})
    	if valtype(nRetPE) = 'N'
    	  	nProcura := nRetPE
    	EndIf
  	EndIf

  	If nProcura > 0
		aCols[nProcura,nPosQuant]   += nQtdOri
		aCols[nProcura,nPosQtSegum] += ConvUM(cCod,nQtdOri,0,2)

		If (nProcura := aScan(aColsDele,{|x| x == nProcura})) > 0
			aDel(aColsDele,nProcura)
			aSize(aColsDele,Len(aColsDele)-1)
		EndIf
	Else
		SB1->(MsSeek(xFilial('SB1')+cCod))
		AADD(aCols,Array(Len(aHeader)+2))
		aCols[Len(aCols),nPosCod    ] := cCod
		aCols[Len(aCols),nPosQuant  ] := nQtdOri
		aCols[Len(aCols),nPosTRT    ] := cTrt
		aCols[Len(aCols),nPosLote   ] := CriaVar("D4_NUMLOTE")
		aCols[Len(aCols),nPosLotCtl ] := CriaVar("D4_LOTECTL")
		aCols[Len(aCols),nPosdValid ] := CriaVar("D4_DTVALID")
		aCols[Len(aCols),nPosPotenc ] := CriaVar("D4_POTENCI")
		aCols[Len(aCols),nPosLocLz  ] := CriaVar("DC_LOCALIZ")
		aCols[Len(aCols),nPosnSerie ] := CriaVar("DC_NUMSERI")
		aCols[Len(aCols),nPosUM     ] := SB1->B1_UM
		aCols[Len(aCols),nPosQtSegum] := ConvUM(cCod,nQtdOri,0,2)
		aCols[Len(aCols),nPos2UM    ] := SB1->B1_SEGUM
		aCols[Len(aCols),nPosDescr  ] := SB1->B1_DESC
		If Type("nPosOper") == "N" .And. nPosOper > 0
			If Empty(cOperac) .Or. Empty(cRoteiro)
				If Empty(SC2->C2_ROTEIRO)
					aAreaSB1   := SB1->(GetArea())
					cRoteiro := POSICIONE('SB1',1,cFilSB1+SC2->C2_PRODUTO,'B1_OPERPAD')
					SB1->(RestArea(aAreaSB1))
					If Empty(cRoteiro)
						cRoteiro := '01'
					Endif
				Else
					cRoteiro := SC2->C2_ROTEIRO
				Endif
				dbSelectArea("SGF")
				SGF->(dbSetOrder(2))
				If SGF->(dbSeek(cFilSGF + SC2->C2_PRODUTO + cRoteiro + SG1->G1_COMP + SG1->G1_TRT))
					aCols[Len(aCols),nPosOper] := MATAFINDOP(SC2->C2_PRODUTO, cRoteiro, SGF->GF_OPERAC, SG1->G1_COMP)
				Else
					aCols[Len(aCols),nPosOper] := MATAFINDOP(SC2->C2_PRODUTO, cRoteiro, cOperac, SG1->G1_COMP)
				Endif
			Else
				aCols[Len(aCols),nPosOper] := MATAFINDOP(SC2->C2_PRODUTO, cRoteiro, cOperac, SG1->G1_COMP)
			EndIf
		EndIf
		If ValType(uConteudo) != "U"
			If !lMTA650AC .And. lMA650ACG
				For nAc := 1 To Len(uConteudo)
					nPosicao := aScan(aHeader,{|x| AllTrim(x[2]) == AllTrim(uConteudo[nAc][2])})
					aCols[Len(aCols), nPosicao] := &("SD4->" + AllTrim(uConteudo[nAc][2]))
				Next nAc
			Else
				aCols[Len(aCols), Len(aHeader)] := &(uTrans)
			EndIf
		EndIf

		If lProduzOri
			aCols[Len(aCols),nPosLocal]      := Iif(SB1->B1_APROPRI=="I",cLocProc,RetFldProd(SB1->B1_COD,"B1_LOCPAD"))
			aCols[Len(aCols),nPosIsAlt]      := STR0202 //Alternativo == Não
			aCols[Len(aCols),nPosTRTORI ]    := SG1->G1_TRT
			aCols[Len(aCols),Len(aHeader)+1] := {Nil,Nil,Nil,Nil}
		Else
			aCols[Len(aCols),nPosLocal]      := cArmPriSGI
			aCols[Len(aCols),nPosIsAlt]      := STR0201 //Alternativo == Sim
			aCols[Len(aCols),nPosTRTORI ] 	 := SG1->G1_TRT
			aCols[Len(aCols),Len(aHeader)+1] := {cProdOri, cTrtOri, nQtdOri, cArmPriSGI}
		EndIf

		aCols[Len(aCols),Len(aHeader)+2] := .F. //D_E_L_E_T_

		If lA650ADCOL
			ExecBlock("A650ADCOL",.F.,.F.,aParamPE)
		EndIf

		If (cRevisao < SG1->G1_REVINI .OR. cRevisao > SG1->G1_REVFIM)
			AADD(aColsDele,Len(aCols))
		EndIf

		AADD(aOpcCam,cProOpc + cProdOri + SG1->G1_TRT)
		AADD(aRecNec,{SG1->G1_COMP, SG1->G1_TRT, SG1->G1_QUANT})

	EndIf
EndIf

RestArea(aArea)
Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³A650QLibPvºAutor  ³ Andre Anjos		 º Data ³  26/05/09   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDescricao ³ Funcao que contabiliza o saldo liberado quanto a estoque deº±±
±±º          ³ um item de pedido de venda (SC6 posicionado).           	  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºRetorno	 ³ nRet: quantidade liberada por estoque.           		  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ MATA650 e FATXFUN                                          º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function A650QLibPv(lEstorn,cAliasSC9)
Local aArea      := GetArea()
Local nRet       := 0
Local cQuery     := ""
Local cAlias     := GetNextAlias()
Local cFilSC9    := xFilial("SC9")
Local cSpcBLEST  := ""
Local cSpcBLCRED := ""
Local cSpcBLOQUE := ""
Local cSpcNFISCA := ""
Local cTabSC9    := RetSqlName("SC9")

DEFAULT lEstorn   := .F.
DEFAULT cAliasSC9 := "SC9"

Static aCacheQLib

If aCacheQLib == NIL
	aCacheQLib := Array(6)
	aCacheQLib[1] := Space(TamSx3("C9_BLEST")[1])
	aCacheQLib[2] := Space(TamSx3("C9_BLCRED")[1])
	aCacheQLib[3] := Space(TamSx3("C9_BLOQUEI")[1])
	aCacheQLib[4] := Space(TamSx3("C9_NFISCAL")[1])
	aCacheQLib[5] := NIL
	aCacheQLib[6] := NIL
EndIf

cSpcBLEST  := aCacheQLib[1]
cSpcBLCRED := aCacheQLib[2]
cSpcBLOQUE := aCacheQLib[3]
cSpcNFISCA := aCacheQLib[4]

oPrepSC9 := aCacheQLib[iIf(lEstorn,6,5)]

If oPrepSC9 == NIL
	cQuery := "SELECT SUM(SC9.C9_QTDLIB) QTDLIBER "
	cQuery += "  FROM " + cTabSC9 + " SC9 "
	cQuery += " WHERE SC9.C9_FILIAL = ? AND "
	If !lEstorn
		cQuery += "   SC9.C9_PEDIDO  = ? AND SC9.C9_ITEM  = ? AND "
		cQuery += "   SC9.C9_PRODUTO = ? AND SC9.C9_BLEST = ? AND "
		cQuery += "   SC9.C9_BLCRED  = ? AND "
		cQuery += "   SC9.C9_BLOQUEI = ? AND "
		cQuery += "   SC9.C9_NFISCAL = ? AND "
		cQuery += "   SC9.D_E_L_E_T_ = '' "
	Else
		cQuery += "   SC9.C9_PEDIDO  = ? AND SC9.C9_ITEM = ? AND "
		cQuery += "   SC9.C9_PRODUTO = ? AND SC9.C9_BLEST = '10' AND "
		cQuery += "   SC9.C9_BLCRED  = '10' AND "
		cQuery += "   SC9.C9_BLOQUEI = ? AND "
		cQuery += "   SC9.C9_NFISCAL = ? AND "
		cQuery += "   SC9.D_E_L_E_T_ = '' "
	EndIf

	cQuery := ChangeQuery(cQuery)
	oPrepSC9 := FWPreparedStatement():New(cQuery) //Construtor da carga.
	aCacheQLib[iIf(lEstorn,6,5)] := oPrepSC9
EndIf
oPrepSC9:SetString(01, cFilSC9) //Seta um parâmetro na query via String.

If !lEstorn
	oPrepSC9:SetString(02, SC6->C6_NUM)
	oPrepSC9:SetString(03, SC6->C6_ITEM)
	oPrepSC9:SetString(04, SC6->C6_PRODUTO)
	oPrepSC9:SetString(05, cSpcBLEST)
	oPrepSC9:SetString(06, cSpcBLCRED)
	oPrepSC9:SetString(07, cSpcBLOQUE)
	oPrepSC9:SetString(08, cSpcNFISCA)
Else
	oPrepSC9:SetString(02, (cAliasSC9)->C9_PEDIDO)
	oPrepSC9:SetString(03, (cAliasSC9)->C9_ITEM)
	oPrepSC9:SetString(04, (cAliasSC9)->C9_PRODUTO)
	oPrepSC9:SetString(05, (cAliasSC9)->C9_BLOQUEI)
	oPrepSC9:SetString(06, (cAliasSC9)->C9_NFISCAL)
EndIf

cQuery := oPrepSC9:GetFixQuery() //Retorna a query com os parâmetros já tratados e substituídos.
cAlias := MPSysOpenQuery(cQuery, cAlias) //Abre um alias com a query informada.

If (cAlias)->(!EOF())
	nRet += (cAlias)->QTDLIBER
EndIf

dbSelectArea(cAlias)
dbCloseArea()

If Empty(cQuery)
	dbSelectArea("SC9")
	dbSetOrder(1)
	If !lEstorn
		dbSeek(cFilSC9+SC6->(SC6->C6_NUM+SC6->C6_ITEM))
		While !EOF() .And. cFilSC9+SC6->(C6_NUM+C6_ITEM) == SC9->(C9_FILIAL+C9_PEDIDO+C9_ITEM)
			// Avalia itens liberados em todos os pontos e ainda nao faturados
			If SC6->C6_PRODUTO == SC9->C9_PRODUTO .And. Empty(SC9->C9_BLEST) .And. Empty(SC9->C9_BLCRED) .And. Empty(SC9->C9_BLOQUEI) .And. Empty(SC9->C9_NFISCAL)
				nRet += SC9->C9_QTDLIB
			EndIf
			dbSkip()
		EndDo
	Else
		dbSeek(cFilSC9+SC9->(SC9->C9_PEDIDO+SC9->C9_ITEM))
		While !EOF() .And. cFilSC9+SD2->(D2_PEDIDO+D2_ITEMPV) == SC9->(C9_FILIAL+C9_PEDIDO+C9_ITEM)
			// Avalia itens liberados em todos os pontos ja faturados
			If  SC9->C9_NFISCAL == SD2->D2_DOC .And. SC9->C9_ITEM == SD2->D2_ITEMPV .And. SC9->C9_PRODUTO == SD2->D2_COD
				nRet += SC9->C9_QTDLIB
			EndIf
			dbSkip()
		EndDo
	EndIf
EndIf

RestArea(aArea)
Return nRet

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡ao    |A650FWLayer ³ Autor ³Aécio Ferreira Gomes   ³ Data ³ 22/07/09 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Grafico de Apontamento da Ordem de Producao                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ A650FWLayer()                                               	³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³                                                              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA650                                                      ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function A650FWLayer()
Local nTotBaixa  :=0,nTotAbert:=0,nTotPerda:=0
Local oDlg,oSay1,oSay2,oSay3,oSay4,oSay5,oSay6,oSay7,oSay8
Local aObjects   :={},aPosObj  :={}
Local aSize      :=MsAdvSize(.F.)
Local aInfo      :={aSize[1],aSize[2],aSize[3],aSize[4],3,3}
Local lEncerrada := .F.
Local oFWChart01 := Nil
Local oFWChart02 := Nil
Local oFWLayer   := Nil
Local cPictC2Qt  := PesqPict("SC2","C2_QUANT")

// Array com objetos utilizados
AADD(aObjects,{100,015,.T.,.F.,.F.})
AADD(aObjects,{100,100,.T.,.T.,.T.})
AADD(aObjects,{100,015,.T.,.F.,.F.})
aPosObj:=MsObjSize(aInfo,aObjects)

If !Empty(C2_DATRF) .And. C2_QUANT > C2_QUJE+C2_PERDA
	lEncerrada := .T.
EndIf
nTotAbert +=C2_QUANT-C2_QUJE-C2_PERDA
nTotBaixa +=C2_QUJE
nTotPerda +=C2_PERDA

DEFINE MSDIALOG oDlg TITLE STR0072 OF oMainWnd PIXEL FROM aSize[7],0 TO aSize[6],aSize[5] //PIXEL STYLE nOr(WS_VISIBLE,WS_POPUP)  //"Grafico de Apontamento de OP"

// Cria instancia do fwlayer
oFWLayer := FWLayer():New()

// Inicializa componente passa a Dialog criada,
// o segundo parametro é para criação de um botao de fechar utilizado para Dlg sem cabeçalho
oFWLayer:init( oDlg, .F. )
// Adiciona coluna passando nome, porcentagem da largura, e se ela é redimensionada ou não
oFWLayer:addCollumn( "Col02", 100,.T. )

// Cria windows passando, nome da coluna onde sera criada, nome da window
// titulo da window, a porcentagem da altura da janela, se esta habilitada para click,
// se é redimensionada em caso de minimizar outras janelas e a ação no click do split
oFWLayer:addWindow( "Col02", "Win01", STR0142, 15, .T., .F. ) //"Dados da OP"
oFWLayer:addWindow( "Col02", "Win02", STR0143,85, .T., .F. ) //"Qtd Total X Perda X Qtd Apontada"

oFWChart01:= oFWLayer:getWinPanel( "Col02", "Win01" )

oSay1:= TSay():New(aPosObj[1,1]+3 ,aPosObj[1,2]+5  ,{||Alltrim(RetTitle("C2_NUM"    )) + " : " + C2_NUM+C2_ITEM+C2_SEQUEN+C2_ITEMGRD},oFWChart01,,,,,,.T.,,,,)
oSay2:= TSay():New(aPosObj[1,1]+3 ,aPosObj[1,2]+100,{||Alltrim(RetTitle("C2_PRODUTO")) + " : " + C2_PRODUTO },oFWChart01,,,,,,.T.,,,,)
oSay3:= TSay():New(aPosObj[1,1]+3 ,aPosObj[1,2]+240,{||Alltrim(RetTitle("C2_EMISSAO")) + " : " + DTOC(C2_EMISSAO)},oFWChart01,,,,,,.T.,,,,)
oSay4:= TSay():New(aPosObj[1,1]+3 ,aPosObj[1,2]+330,{||Alltrim(RetTitle("C2_QUANT"  )) + " : " + Transform(C2_QUANT, cPictC2Qt)},oFWChart01,,,,,,.T.,,,,)
oSay5:= TSay():New(aPosObj[1,1]+15,aPosObj[1,2]+5  ,{||Alltrim(RetTitle("C2_DATPRI" )) + " : " + DTOC(C2_DATPRI)},oFWChart01,,,,,,.T.,,,,)
oSay6:= TSay():New(aPosObj[1,1]+15,aPosObj[1,2]+100,{||Alltrim(RetTitle("C2_DATPRF" )) + " : " + DTOC(C2_DATPRF)},oFWChart01,,,,,,.T.,,,,)
oSay7:= TSay():New(aPosObj[1,1]+15,aPosObj[1,2]+240,{||Alltrim(RetTitle("C2_TPOP"   )) + " : " + Iif(C2_TPOP=="F",STR0073,STR0074)},oFWChart01,,,,,,.T.,,,,)
oSay8:= TSay():New(aPosObj[1,1]+15,aPosObj[1,2]+330,{||Alltrim(RetTitle("C2_DATRF"  )) + " : " + DTOC(C2_DATRF)},oFWChart01,,,,,,.T.,,,,)

oFWChart02 := FWChartFactory():New()
oFWChart02 := oFWChart02:getInstance( PIECHART )
oFWChart02:init( oFWLayer:getWinPanel( "Col02", "Win02" ) )
oFWChart02:setLegend( CONTROL_ALIGN_BOTTOM )
oFWChart02:setPicture( cPictC2Qt )

// Monta o Grafico
A650PieChart(oFWChart02,nTotAbert,nTotBaixa,nTotPerda,lEncerrada)

oDlg:Activate(,,,.T.,,,)
Return

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³A650PieChart  ³ Autor ³Aécio Ferreira Gomes ³ Data ³ 22/07/09 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Funcao para montar o grafico relacionado a OP                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Mata650 / MATC015                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
*/
Function A650PieChart(oPIECHART,nTotAbert,nTotBaixa,nTotPerda,lEncerrada)

If nTotAbert > 0
	oPIECHART:addSerie(If(!lEncerrada,STR0075,STR0078), nTotAbert )  //"Qtde. a ser Produzida" //"Qtde. Nao Produzida"
EndIf
If nTotBaixa > 0
	oPIECHART:addSerie( STR0076, nTotBaixa )  //"Qtde. Produzida "
EndIf
If nTotPerda > 0
	oPIECHART:addSerie( STR0077, nTotPerda )	//"Qtde. Perda "
EndIf

//Controi o Grafico
oPIECHART:build()

Return
/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³a650RegOPI    ³ Autor ³Aécio Ferreira Gomes ³ Data ³ 24/09/09 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Verifica se existe OPs intermediarias para serem geradas.    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Mata416/ Mata650 / Mata760/ Fata502/ PCPXFUN                 ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
*/
Function a650RegOPI(lGerar, nOps, cRotina, aFilial)
Local nI         := 0
Local nTotalOps  := 0
Local cAliasCont := GetNextAlias()
Local cFilSC2 	 := ""
Local cBanco     := Upper(TcGetDb())
Default lGerar := .T.
Default nOps   := 0
Default cRotina:= FunName()
Default aFilial:={{cFilAnt,0,xFilial("SC2")}}

For nI := 1 To Len(aFilial)
	If AllTrim(cFilSC2) != aFilial[nI,3]
		cFilSC2 := aFilial[nI,3]
	EndIf

	cQuery :=" SELECT COUNT(*) AS CONTADOR FROM " + RetSqlName("SC2") + " SC2 "
	cQuery +="  WHERE SC2.C2_FILIAL = '"+ cFilSC2 + "' "
	cQuery +="    AND SC2.C2_BATCH = ' ' "
	cQuery +="    AND SC2.C2_BATROT <> ' ' "
    cQuery +="    AND SC2.C2_DATRF = ' ' "

	If cRotina $ "MATA416|FATA502"
		cQuery +=" AND SC2.C2_BATORCA = 'S' "
	EndIf

	cQuery +=" AND SC2.D_E_L_E_T_ = ' ' "
	cQuery +=" AND NOT EXISTS ( SELECT 1 FROM " + RetSqlName("SD4") + " SD4 "
	cQuery +=                 "  WHERE SD4.D4_FILIAL = '"+ cFilSC2 + "' "
	cQuery +=                 "    AND SD4.D4_OP = SC2.C2_NUM + SC2.C2_ITEM + SC2.C2_SEQUEN + SC2.C2_ITEMGRD "
	cQuery +=                 "    AND SD4.D_E_L_E_T_ = ' ' ) "

	//Se não for SQL Server, troca o comando de concatenação de + por ||
	If !("MSSQL" $ cBanco)
		cQuery := StrTran(cQuery, "+", "||")
	EndIf

	//cQuery := ChangeQuery(cQuery)
	dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasCont,.T.,.T.)
	If (cAliasCont)->(!Eof())
		If (cAliasCont)->CONTADOR > 0
			lgerar := .T.
		EndIf
		nOps   := (cAliasCont)->CONTADOR
		nTotalOps += (cAliasCont)->CONTADOR
	EndIf
	aFilial[nI,2] := nOps

	(cAliasCont)->(DBCLOSEAREA())
Next nI

nOps := nTotalOps

Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³A650DelC1C7³ Autor ³ Sergio S. Fuzinaka    ³ Data ³ 05.02.10 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descricao ³Exclui as SC's e AE's que perderam o vinculo com a OP devido ³±±
±±³          ³a exclusao do empenho.                                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³MATA650                                                      ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function A650DelC1C7(cOp,lExcGra,nTam,cItemGrd,aRegsSC1,cProgOri)

Local aArea		:= GetArea()
Local nEntregSC7:= 0
Local nX		:= 0
Local lExcluiAE	:= IIF(SuperGetMv("MV_DELEAE")=="S",.T.,.F.)
Local lAprovEt := SuperGetMV("MV_APRSCEC",.F.,.T.) // Alcada por Entidade Contabil
Local lSCSldBl	:= SuperGetMv("MV_SCSLDBL",.F.,.F.)
Local lExcluiSC := .T.
Local aAreaAtu := {}
Local cTipoDHN := "1"
Local cFilSC1 := xFilial("SC1")
Local cFilSC7 := xFilial("SC7")

If Type("l650Auto") == "L" .And. l650Auto .And. (nX := aScan(aRotProd,{|x| x[1] == "DELSC"})) > 0
	lExcluiSC := aRotProd[nX,2] == "S"
EndIf

dbSelectArea("SC1")
dbSetOrder(4)
dbSeek(cFilSC1+cOp)
While lExcluiSC .And. !EOF() .And. C1_FILIAL+If(!lExcGra,C1_OP,left(C1_OP,len(cOp))) == cFilSC1+cOp

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica se devera deletar ou nao os outros itens da grade, conforme mv_par12 ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If !lExcGra .And. Right(C1_OP,nTam) != cItemGrd
		dbSkip()
		loop
	EndIf

	If !Empty(SC1->C1_COTACAO) .And.  SC1->C1_COTACAO <> Replicate("X",Len(SC1->C1_COTACAO)) .And. SC1->C1_IMPORT <> "S" .And. SC1->C1_QUJE == 0
		If aScan(aRegsSC1, {|z|z == SC1->(Recno())}) == 0
			Aviso(STR0051,STR0122+AllTrim(SC1->C1_NUM)+STR0123+AllTrim(SC1->C1_ITEM)+STR0124,{'Ok'})
			AADD(aRegsSC1,SC1->(Recno())) //"Aten‡„o"###"A solicitacao de compras numero "###" item "###" nao podera ser excluida pois se encontra em processo de cotacao! "
		EndIF
		dbSkip()
		Loop
	Endif

	If (SC1->C1_TPOP == "F") .And. ((cProgOri == "MATA710") .Or. (cProgOri == "MATA651" .And.;
		Aviso(STR0051,STR0122+SC1->C1_NUM+STR0123+SC1->C1_ITEM+STR0132+AllTrim(SC1->C1_OP)+STR0133,{STR0134,STR0135})==2))
		SC1->(dbSkip())
		Loop
	EndIf

	// Verifica se existe SI vinculada a OP, se existir, emite aviso.
	// Sera permitido apagar a OP porém a SC não será apagada, somente havera a quebra do vinculo
	// com a OP
	If !Empty(SC1->C1_NUM_SI)
		If aScan(aRegsSC1, {|z|z == SC1->(Recno())}) == 0
			Aviso(STR0051,STR0122+AllTrim(SC1->C1_NUM)+STR0123+AllTrim(SC1->C1_ITEM)+STR0140,{'Ok'})
			AADD(aRegsSC1,SC1->(Recno()))//"Aten‡„o"###"A solicitacao de compras numero "###" item "###" nao podera ser excluida pois se encontra em processo de importacao! "
		EndIF
		SC1->(dbSkip())
		Loop
	Endif

	// Solicitações de compras integradas com o paradigma não podem ser excluidas, somente deve ser retiradas o seu vinculo com a OP caso a OP seja excluída
	If !Empty(SC1->C1_ACCNUM)
		If aScan(aRegsSC1, {|z|z == SC1->(Recno())}) == 0
			Aviso(STR0051,STR0122+AllTrim(SC1->C1_NUM)+STR0123+AllTrim(SC1->C1_ITEM)+STR0204,{'Ok'})
			AADD(aRegsSC1,SC1->(Recno())) //A solicitacao de compras numero ### item ### nao podera ser excluida pois se encontra integrada com o Paradigma!
		EndIF
		SC1->(dbSkip())
		Loop
	EndIf

	dbSelectArea("SB2")
	dbSetOrder(1)
	If !MsSeek(xFilial("SB2")+SC1->C1_PRODUTO+SC1->C1_LOCAL)
		CriaSB2(SC1->C1_PRODUTO,SC1->C1_LOCAL)
		MsUnlock()
	EndIf

	If SC1->C1_APROV <> "B" .Or. (SC1->C1_APROV == "B" .And. !lSCSldBl)
		GravaB2Pre("-",(SC1->C1_QUANT-SC1->C1_QUJE),SC1->C1_TPOP)
	EndIf

	// Caso ja haja qtd no PC, iguala qtd na SC para encerra-la
	// Senao deleta
	If SC1->C1_QUJE > 0
		RecLock("SC1",.F.)
		C1_QUANT	:= C1_QUJE
		C1_QTSEGUM	:= ConvUM(SB2->B2_COD, C1_QUJE, 0, 2)
		MsUnlock()
	Else
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Execblock a ser executado antes da Exclusao do SC1           ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		IF (ExistBlock('MT650DC1'))
			ExecBlock('MT650DC1',.F.,.F.)
		Endif
		//Realiza Exclusao de Alcada contabil
		If lAprovEt
			A650ALCCTB(cOp)
		EndIf
		If Type('aProcMRP') == "A" .And. !Empty(SC1->C1_SEQMRP)
			aAdd(aProcMRP, {SC1->C1_SEQMRP, SC1->C1_PRODUTO, SC1->C1_QUANT} )
		EndIf

		//Executa a exclusão da tabela DHN
		aAreaAtu := GetArea()
		COMEXCDHN("1",cFilSC1,SC1->C1_NUM)
		RestArea(aAreaAtu)

		// Gerar Carta de Correcao do Pedido
		RecLock("SC1",.F.,.T.)
		C1_OBS	:= STR0025		//"CANCELADA PELO SISTEMA"
		dbDelete()
		MsUnLock()
	EndIf

	dbSelectArea("SC1")
	dbSkip()
EndDo
dbSelectArea("SC1")
dbSetOrder(1)

dbSelectArea("SC7")
dbSetOrder(8)
dbSeek(cFilSC7+cOp)
While lExcluiSC .And. !EOF() .And. C7_FILIAL+If(!lExcGra,C7_OP,left(C7_OP,len(cOp))) == cFilSC7+cOp

	If C7_TIPO == 2
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Verifica se devera deletar ou nao os outros itens da grade, confor- ³
		//³ me mv_par12                                                         ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If !lExcGra .And. Right(C7_OP,nTam) != cItemGrd
			dbSkip()
			loop
		EndIf

		If (SC7->C7_TPOP == "F") .And. ((cProgOri == "MATA710") .Or. (cProgOri == "MATA651" .And.;
			Aviso(STR0051,STR0136+SC7->C7_NUM+STR0123+SC7->C7_ITEM+STR0132+AllTrim(SC7->C7_OP)+STR0133,{STR0137,STR0138})==2))
			SC7->(dbSkip())
			Loop
		EndIf

		dbSelectArea("SB2")
		dbSetOrder(1)
		If !MsSeek(xFilial("SB2")+SC7->C7_PRODUTO+SC7->C7_LOCAL)
			CriaSB2(SC7->C7_PRODUTO,SC7->C7_LOCAL)
			MsUnlock()
		EndIf

		nEntregSC7 := SC7->C7_QUJE + SC7->C7_QTDACLA

		GravaB2Pre("-",SC7->C7_QUANT - nEntregSC7,SC7->C7_TPOP)

		// Volta saldo ate a autorizacao de entrega
		If nEntregSC7 > 0 .Or. lExcluiAE
			dbSelectArea("SC3")
			dbSetOrder(1)
			If dbSeek(xFilial("SC3")+SC7->C7_NUMSC+SC7->C7_ITEMSC)
				RecLock("SC3",.F.)
				C3_QUJE	:= C3_QUJE - (SC7->C7_QUANT-nEntregSC7)
				If C3_QUANT > C3_QUJE .And. C3_ENCER == "E"
					C3_ENCER := " "
				Endif
				MsUnlock()
			EndIf
		Endif

		dbSelectArea("SC7")
		// Caso ja haja qtd ENTREGUE no PC
		If nEntregSC7 > 0
			RecLock("SC7",.F.)
			C7_QUANT := SC7->C7_QUJE + SC7->C7_QTDACLA
			C7_TOTAL := SC7->C7_QUANT * SC7->C7_PRECO
			MsUnlock()
		ElseIf lExcluiAE
			//Executa a exclusão da tabela DHN
			aAreaAtu := GetArea()
			If SC7->C7_TIPO == 2
				cTipoDHN := "3"
			Else
				cTipoDHN := "2"
			EndIf
			COMEXCDHN(cTipoDHN,cFilSC7,SC7->C7_NUM)
			RestArea(aAreaAtu)

			RecLock("SC7",.F.,.T.)
			C7_OBS := STR0025 	//"CANCELADA PELO SISTEMA"
			dbDelete()
			MsUnLock()
		EndIf
	EndIf
	dbSelectArea("SC7")
	dbSkip()
EndDo
dbSelectArea("SC7")
dbSetOrder(1)

RestArea( aArea )

Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³A650AtuSGJ ³ Autor ³ Sergio S. Fuzinaka   ³ Data ³ 06.04.10 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descricao ³Funcao utilizada para gravar o empenho na tabela SGJ -      ³±±
±±³          ³Amarracao PV x OP                                           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³Generico                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function A650AtuSGJ(nQuant, cTpOP)

Local aArea		:= {}
Local aAreaSB2	:= {}
Local cChave	:= ""
Local lAtuSGJ	:= SuperGetMV("MV_PVCOMOP",.F.,.F.)

cChave := SC6->(C6_NUM+C6_ITEM+C6_PRODUTO+C6_LOCAL+C6_NUMOP+C6_ITEMOP)

If SC6->(C6_NUMOP+C6_ITEMOP) == SC2->(C2_NUM+C2_ITEM)
	cChave += SC2->(C2_SEQUEN+C2_ITEMGRD)
Endif

If lAtuSGJ .And. !Empty( SC6->C6_NUM ) .And. nQuant > 0 .And. cTpOP == "F"
	aArea		:= GetArea()
	aAreaSB2	:= SB2->(GetArea())

	dbSelectArea("SGJ")
	dbSetOrder(1)
	If !dbSeek( xFilial("SGJ")+cChave )
		RecLock("SGJ",.T.)
		SGJ->GJ_FILIAL	:= xFilial("SGJ")
		SGJ->GJ_NUMPV	:= SC6->C6_NUM
		SGJ->GJ_ITEMPV	:= SC6->C6_ITEM
		SGJ->GJ_ITGRDPV	:= SC6->C6_ITEMGRD

		If !Empty( SC6->(C6_NUMOP+C6_ITEMOP) )
			If SC6->(C6_NUMOP+C6_ITEMOP) == SC2->(C2_NUM+C2_ITEM)
				SGJ->GJ_NUMOP	:= SC2->C2_NUM
				SGJ->GJ_ITEMOP	:= SC2->C2_ITEM
				SGJ->GJ_SEQUEN	:= SC2->C2_SEQUEN
				SGJ->GJ_ITGRDOP	:= SC2->C2_ITEMGRD
			Else
				SGJ->GJ_NUMOP	:= SC6->C6_NUMOP
				SGJ->GJ_ITEMOP	:= SC6->C6_ITEMOP
			Endif
		Endif

		SGJ->GJ_PRODUTO	:= SC6->C6_PRODUTO
		SGJ->GJ_LOCAL	:= SC6->C6_LOCAL
		SGJ->GJ_QUANT	:= nQuant

		SB2->(dbSelectArea("SB2"))
		SB2->(dbSetOrder(1))
		If SB2->(MsSeek(xFilial("SB2")+SC6->(C6_PRODUTO+C6_LOCAL)))
			SGJ->GJ_QEMPN	:= SC6->C6_QTDVEN
			SGJ->GJ_QEMPN2	:= ConvUM(SB2->B2_COD,nQuant,0,2)
		Endif
		MsUnlock()
	Endif

	RestArea( aAreaSB2 )
	RestArea( aArea )
Endif

Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³A650SomaSGJ³ Autor ³ Sergio S. Fuzinaka   ³ Data ³ 06.04.10 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descricao ³Totaliza a quantidade empenhada do Pedido                   ³±±
±±³          ³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpC1 = "1" - Saldo Empenhado Sem OP                        ³±±
±±³          ³ExpC2 = "2" - Saldo Empenhado Com OP                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Total Empenhado                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³Generico                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function A650SomaSGJ(cTp)

Local aArea		:= GetArea()
Local aAreaSGJ	:= SGJ->(GetArea())
Local nRet		:= 0
Local lAtuSGJ	:= SuperGetMV("MV_PVCOMOP",.F.,.F.)

If lAtuSGJ .And. SC6->C6_TPOP == "F"

	dbSelectArea("SGJ")
	dbSetOrder(1)
	If dbSeek(xFilial("SGJ")+SC6->(C6_NUM+C6_ITEM+C6_PRODUTO+C6_LOCAL))
		While !Eof() .And. SGJ->(GJ_FILIAL+GJ_NUMPV+GJ_ITEMPV+GJ_PRODUTO+GJ_LOCAL) == ;
				xFilial("SGJ")+SC6->(C6_NUM+C6_ITEM+C6_PRODUTO+C6_LOCAL)

			//Saldo Disponivel - Empenho sem OP
			If cTp == "1" .And. Empty( SGJ->GJ_NUMOP )
				nRet += SGJ->GJ_QEMPN

			//Saldo Empenhado com OP
			ElseIf cTp == "2" .And. !Empty( SGJ->GJ_NUMOP )
				nRet += SGJ->GJ_QEMPN

			//Total Empenhado
			Else
				nRet += SGJ->GJ_QEMPN
	    	Endif

			SGJ->(dbSkip())

		Enddo
	Endif

Endif

RestArea( aAreaSGJ )
RestArea( aArea )

Return( nRet )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³A650DelSGJ ³ Autor ³ Sergio S. Fuzinaka   ³ Data ³ 07.04.10 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descricao ³Deleta linha na tabela SGJ                                  ³±±
±±³          ³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpC1 = "I" - por Item                                      ³±±
±±³          ³        "T" - Total                                         ³±±
±±³          ³        "E" - Estoque                                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³Generico                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function A650DelSGJ(cTp,cDesPvOp,cSequenOP,cNumOP,cItemOP)

Local aArea		:= {}
Local aAreaSGJ	:= {}
Local lAtuSGJ	:= SuperGetMV("MV_PVCOMOP",.F.,.F.)
Local lExclSGJ  := .F.

Default cDesPvOP  := " "
Default cSequenOP := " "
Default cNumOP    := " "
Default cItemOP   := " "

If lAtuSGJ
	aArea		:= GetArea()
	aAreaSGJ	:= SGJ->(GetArea())

	dbSelectArea("SGJ")
	dbSetOrder(1) // GJ_FILIAL+GJ_NUMPV+GJ_ITEMPV+GJ_PRODUTO+GJ_LOCAL+GJ_NUMOP+GJ_ITEMOP+GJ_SEQUEN+GJ_ITGRDOP
	If cTp == "I"	//Por Item

		//Se essa função foi chamada pela PCP650AvPV e foi passado parâmetor para desvincular a OP
		//então deverá ser utilizado para leitura da SGJ produto, local, número da OP, item OP e sequência da SC2
		If IsInCallStack("PCP650AvPV") .And. cDesPvOp == "D"
        	If SGJ->(dbSeek(xFilial('SGJ')+SC6->(C6_NUM+C6_ITEM)+SC2->(C2_PRODUTO+C2_LOCAL+C2_NUM+C2_ITEM+C2_SEQUEN)))
				lExclSGJ := .T.
		    EndIf
		Else
		    //Se foi chamada pela função PCP650AvPV, porém não há mais o registro da SC2, faz a leitura da SGJ pela SC6 e os parâmetros passados
			If cDesPvOP == "N"
				If SGJ->(dbSeek( xFilial("SGJ")+SC6->(C6_NUM+C6_ITEM+C6_PRODUTO+C6_LOCAL)+cNumOP+cItemOP+cSequenOP))
					lExclSGJ := .T.
				EndIf
			Else
			    //se não foi chamada pela função PCP650AvPV, efetua a leitura pela SC6
            	If SGJ->(dbSeek( xFilial("SGJ")+SC6->(C6_NUM+C6_ITEM+C6_PRODUTO+C6_LOCAL+C6_NUMOP+C6_ITEMOP)+SC2->(C2_SEQUEN)))
					lExclSGJ := .T.
				Else //se não encontrar é porque pode ter sido alterado o produto ou o local, então busca usando as informações da SC2
					If SGJ->(dbSeek( xFilial("SGJ")+SC6->(C6_NUM+C6_ITEM)+SC2->(C2_PRODUTO+C2_LOCAL)+SC6->(C6_NUMOP+C6_ITEMOP)+SC2->(C2_SEQUEN)))
						lExclSGJ := .T.
					EndIf
				EndIf
			EndIf
		EndIf

		If lExclSGJ
		   	//Deleta SGJ
			RecLock("SGJ",.F.)
				SGJ->(dbDelete())
			MsUnlock()
		EndIf

		If cDesPvOp == 'D' // DMANSMARTSQUAD1-28606 - Desvincula PV x OP
			//Remove vínculo PV x OP
			RecLock("SC2",.F.)
				SC2->C2_PEDIDO := ''
				SC2->C2_ITEMPV := ''
			SC2->(MsUnLockAll())
		Endif
	ElseIf cTp == "E"	//Por Estoque - Deleta SGJ quando reprocessa OP por Vendas C6_OP = 05
		If SGJ->(dbSeek( xFilial("SGJ")+SC6->(C6_NUM+C6_ITEM+C6_PRODUTO+C6_LOCAL+C6_NUMOP+C6_ITEMOP)))
			//Deleta SGJ
			RecLock("SGJ",.F.)
				SGJ->(dbDelete())
			MsUnlock()
		Endif
	Else //Por Total
		SGJ->(dbSeek( xFilial("SGJ")+SC6->C6_NUM ))
		While SGJ->(!Eof()) .And. SGJ->(GJ_FILIAL+GJ_NUMPV) == xFilial("SGJ")+SC6->C6_NUM
			//Deleta SGJ
			RecLock("SGJ",.F.)
				SGJ->(dbDelete())
			MsUnlock()
			SGJ->(dbSkip())
		Enddo
	Endif

	RestArea( aAreaSGJ )
	RestArea( aArea )
Endif

Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³A650AvalPV ³ Autor ³ Sergio S. Fuzinaka   ³ Data ³ 14.04.10 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descricao ³Executa a avaliacao do Pedido de Venda.                     ³±±
±±³          ³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³Generico                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function A650AvalPV()
	PCP650AvPV()
Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³A650RotAut ³ Autor ³ Sergio S. Fuzinaka   ³ Data ³ 14.04.10 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descricao ³Executa exclusao da OP via Rotina Automatica.               ³±±
±±³          ³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³MATA650                                                     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function A650RotAut(nOpcao)

Local aRotAuto	:= {}

Private lMsErroAuto := .F.

dbSelectArea("SC2")
dbSetOrder(1)

//-- Monta array para utilizacao da Rotina Automatica
aRotAuto  := {	{"C2_FILIAL"	,xFilial("SC2")		,NIL},;
				{"C2_NUM"		,SC2->C2_NUM		,NIL},;
				{"C2_ITEM"		,SC2->C2_ITEM		,NIL},;
				{"C2_SEQUEN"	,SC2->C2_SEQUEN		,NIL},;
				{"C2_ITEMGRD"	,SC2->C2_ITEMGRD	,NIL} }

// Definicao de Indice - Exemplo:
//				{"INDEX"		,1					,NIL} }

// Chamada da rotina automatica
MsExecAuto({|x,y| MATA650(x,y)},aRotAuto,nOpcao)

// Mostra Erro na geracao de Rotinas automaticas
If lMsErroAuto
	MostraErro()
EndIf

Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³A650VldPV  ³ Autor ³ Sergio S. Fuzinaka   ³ Data ³ 15.04.10 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descricao ³Executa validacao na rotina de alteracao do Pedido de Venda ³±±
±±³          ³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³Generico                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function A650VldPV()
	lRet := PCPVldPV()
Return( lRet )


/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³A650VldNumºAutor  ³Andre Anjos         º Data ³  01/10/10   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDescricao ³ Validacao dos campos C2_NUM, C2_ITEM, C2_SEQUEN            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ MATA650                                                    º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function A650VldNum()
Local lRet   := .T.
Local nBusca := 0
Local cConteudo		:= Alltrim(&(ReadVar()))
Local cCaracEsp		:= "'"

If Type("l650Auto") = "U"
	PRIVATE l650Auto := .F.
EndIf

nBusca := aScan(aRotProd,{|x| x[1] == "C2_SEQUEN"})
If ( nBusca > 0 )
	M->C2_SEQUEN := aRotProd[nBusca,2]
EndIf

//-- Se não passou o numero na execauto nao valida, pois o sistema quem controlara e trocara no momento da
//-- gravao caso ja exista na base
//-- Verifica se jah existe este numero na tabela
If (!l650Auto .Or. NrExecAuto())
	lRet := ExistChav("SC2",M->C2_NUM+M->C2_ITEM+M->C2_SEQUEN)
EndIf

//-- Verifica se possui ' (aspas simples) em um dos campos
if cCaracEsp $ cConteudo
	lret := .F.
	Help( ,, 'Help',, STR0219 , 1, 0 )
endif
Return lRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³TAPSOperacºAutor  ³Andre Anjos         º Data ³  01/10/10   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDescricao ³ Se for inclusao de ordem, alimenta a tabela de operacoes X º±±
±±º			 ³ ordens. Se for alteracao e o roteiro foi alterado, exclui  º±±
±±º			 ³ operacoes antigas e gera as novas.						  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³ cOP: Ordem de producao.								  	  º±±
±±º			 ³ cProduto: Codigo do produto da OP.					  	  º±±
±±º			 ³ cRoteiro: Roteiro utilizado no apontamento.			  	  º±±
±±º			 ³ nQuant: Quantidade da OP.							  	  º±±
±±º			 ³ lGeraSHY: Identifica se e exclusao (.F.) da ordem.		  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ Integracao TOTVS APS                                       º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function TAPSOperac(cOP,cProduto,cRoteiro,nQuant,lGeraSHY)
	Local aArea         := GetArea()
	Local cAliasQry     := GetNextAlias()
	Local cFilSHY       := xFilial("SHY")
	Local lAlt650       := IsInCallStack("A650Altera")
	Local lProces       := SuperGetMV("MV_APS",.F.,"") == "TOTVS" .Or. lIntSFC .OR. SuperGetMV("MV_PCPATOR",.F.,.F.) == .T.
	Local lRegSG2       := 0
	Local nAux          := 0
	Local nLote         := 0
	Local nMObra        := 0
	Local nTemp         := 0

	Default l650Auto 	:= .F.
	Default lMata712 	:= .F.
	Default lOpVendas 	:= .F.
	Default lPCPA107 	:= .F.
	Default lProj711 	:= .F.
	Default lGeraSHY 	:= .T.

	PRIVATE cTipoTemp := SuperGetMV("MV_TPHR") //Usada na A690HoraCt

	If lGeraSHY
		If !lProj711 .And. !lMata712 .And. !lPCPA107 .And. !lOpVendas .And. !l650Auto
			//Query para gerar a métrica - Quantidade média de operações por ordem de produção manual
			BeginSql Alias cAliasQry
				SELECT COUNT(*) AS RegSG2
				  FROM %Table:SG2%
				 WHERE %NotDel%
				   AND G2_FILIAL  = %xfilial:SG2%
			       AND G2_PRODUTO = %Exp:cProduto%
				   AND G2_CODIGO  = %Exp:cRoteiro%
			EndSql

			If (cAliasQry)->(!Eof())
				(cAliasQry)->(DbGoTop())
				While (cAliasQry)->(!Eof())
					lRegSG2 := (cAliasQry)->RegSG2
					(cAliasQry)->(DbSkip())
				EndDo
			EndIf
			(cAliasQry)->(DbCloseArea())

			//Integra Métrica - Quantidade média de operações por ordem de produção manual
			//ID: manufatura-protheus_volume-medio-de-operacoes-por-op-manual_average
			If Findfunction("PCPMETRIC") .and. lRegSG2 > 0
				PCPMETRIC("MATA650", {{"manufatura-protheus_volume-medio-de-operacoes-por-op-manual_average", lRegSG2 }})
			EndIf
		EndIf
	EndIf

	If AliasInDic("SHY") .And. lProces
		If (lAlt650 .And. VerApont(cOp,cProduto)) .Or. !lAlt650
			dbSelectArea("SHY")
			dbSetOrder(1)
			//Removida condição para sempre Excluir as Operações da Ordem, idendente do tipo de operação(GeraSHY) ou alteração de roteiro
			If dbSeek(cFilSHY+cOP)// .And. (!lGeraSHY .And. cRoteiro # HY_ROTEIRO) //Roteiro alterado
				//-- Deleta operacoes da ordem antigas
				While !EOF() .And. HY_FILIAL+HY_OP == cFilSHY+cOP
					RecLock("SHY",.F.)
					dbDelete()
					dbSkip()
				End
			/*ElseIf Found()
				lGeraSHY := .F.
			*/
			EndIf

			If lGeraSHY
				SG2->(dbSetOrder(1))
				SG2->(dbSeek(xFilial("SG2")+cProduto+cRoteiro))
				While !SG2->(EOF()) .And. SG2->(G2_FILIAL+G2_PRODUTO+G2_CODIGO) == xFilial("SG2")+cProduto+cRoteiro

					If IsInCallStack("AtualizaSHY") //Quando é chamado pelo UPDPCP16.
						SC2->(dbSetOrder(1))
						SC2->(dbSeek(xFilial("SC2")+cOP))
					EndIf
					If !Empty(SG2->G2_DTINI)
						If SG2->G2_DTINI > SC2->C2_DATPRI
							SG2->(dbSkip())
							Loop
						EndIf
					EndIf
					If !Empty(SG2->G2_DTFIM)
						If SG2->G2_DTFIM < SC2->C2_DATPRI
							SG2->(dbSkip())
							Loop
						EndIf
					EndIf

					RecLock("SHY",.T.)
					HY_FILIAL  := cFilSHY
					HY_OP 	   := cOP
					HY_ROTEIRO := SG2->G2_CODIGO
					HY_OPERAC  := SG2->G2_OPERAC
					HY_CTRAB   := SG2->G2_CTRAB
					HY_RECURSO := SG2->G2_RECURSO
					HY_FERRAM  := SG2->G2_FERRAM
					HY_QUANT   := nQuant
					HY_SITUAC  := '1'

					If findFunction("VldCpoShy") .And. VldCpoShy("HY_TPALOCF")
						HY_TPALOCF := SG2->G2_TPALOCF
						HY_TPLINHA := SG2->G2_TPLINHA
						HY_SETUP   := SG2->G2_SETUP
						HY_FORMSTP := SG2->G2_FORMSTP
						HY_LOTEPAD := Iif(SG2->G2_LOTEPAD == 0,1,SG2->G2_LOTEPAD)
						HY_TEMPAD  := SG2->G2_TEMPAD
						HY_TPOPER  := SG2->G2_TPOPER
						HY_TPSOBRE := SG2->G2_TPSOBRE
						HY_TEMPSOB := SG2->G2_TEMPSOB
						HY_TPDESD  := SG2->G2_TPDESD
						HY_TEMPDES := SG2->G2_TEMPDES
						HY_DESPROP := SG2->G2_DESPROP
						HY_TEMPEND := SG2->G2_TEMPEND
						HY_DTINI   := SG2->G2_DTINI
						HY_DTFIM   := SG2->G2_DTFIM
					Endif

					If findFunction("VldCpoShy") .And. VldCpoShy("HY_USAALT")
						HY_USAALT := SG2->G2_USAALT
					EndIf

					If SHY->(FieldPos("HY_MAOOBRA")) > 0
						HY_MAOOBRA := SG2->G2_MAOOBRA
					EndIf

					SHY->HY_DESCRI := SG2->G2_DESCRI

					If findFunction("VldCpoShy") .And. VldCpoShy("HY_REMOCAO")
						HY_REMOCAO := SG2->G2_REMOCAO
					EndIf

					nLote := If(Empty(SG2->G2_LOTEPAD),1,SG2->G2_LOTEPAD)
					nTemp := If(Empty(SG2->G2_TEMPAD),1,SG2->G2_TEMPAD)
					nTemp := A690HoraCt(nTemp)
					nAux  := nQuant

					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Se tempo minimo, arredonda a sobra para completar o tempo do lote ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If SG2->G2_TPOPER == "4"
						nAux := nAux % nLote
						nAux := Int(nQuant) + If(Empty(nAux),0,nLote - nAux)
					EndIf

					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Proporcionaliza conforme tempo padra / lote padrao		 ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If !(SG2->G2_TPOPER $ "23")
						nTemp := nAux * (nTemp / nLote)
						nMObra := Posicione("SH1",1,xFilial("SH1")+SG2->G2_RECURSO,"H1_MAOOBRA")
						If !Empty(nMObra)
							nTemp := nTemp / nMObra
						EndIf
					EndIf

					HY_TEMPOM := nTemp
					HY_TEMPOS := A690HoraCt(If(Empty(SG2->G2_FORMSTP),SG2->G2_SETUP,Formula(SG2->G2_FORMSTP)))
					MsUnLock()
					SG2->(dbSkip())
				End
			EndIf
		EndIf
	EndIf

	RestArea(aArea)
Return

//--------------------------------------------------------------------------
/*Função: A650CSHY - Autor :Ezequiel Ramos - Data: 14.02.14
Converte a chave de condição para utilização no While
Parametros: ExpL1: Variavel que deve ser tornada por referencia indicado³±±
±±³          ³       se a chave de pesquisa busca uma familia ou um codigo³±±
±±³          ³       completo de produto.                                 ³±±
±±³          ³ExpC1: Chave de pesquisa                                    ³±±
±±³          ³ExpC2: Chave de pesquisa que sera convertida para formato   ³±±
±±³          ³       de bloco de codigo, que retornara por referencia e   ³±±
±±³          ³       podera ser utilizado em Lacos do tipo while.         ³±±
*/
//--------------------------------------------------------------------------
Function A650CSHY(lFamilia,cChave,cSeekWhile)
Local nTamChave
Default cSeekWhile	:= ""
Default lFamilia		:= .F.

If lFamilia
	//-- Troca chave de pesquisa para while
	cSeekWhile := StrTran(cSeekWhile,"G2_PRODUTO","G2_REFGRD")
EndIf

//-- Descubro o tamanho da chave de pesquisa para cortar posteriormente com PadR, para evitar "z"
//-- em buscas incrementais que possam interferir no bloco do While.
nTamChave := Len(&cSeekWhile)

//-- Atualiza expressao do bloco de codigo para while
cSeekWhile := "{||"+cSeekWhile+"=='"+PadR(cChave,nTamChave)+"'}"

Return ( cSeekWhile )

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³A650SkHY³ Autor ³Erike Yuri da Silva    ³ Data ³07.04.07  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Pesquisa SHY procurando 1o o codigo completo do produto     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpL1: Indicativo de achou alguma ocorrencia                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpN1: Ordem do de pesquisa                                 ³±±
±±³          ³ExpC2: Codigo do produto que sera analisado se eh ref.grade ³±±
±±³          ³ExpC3: Chave de pesquisa                                    ³±±
±±³          ³ExpC4: Chave de pesquisa que sera convertida para formato   ³±±
±±³          ³       de bloco de codigo, que retornara por referencia e   ³±±
±±³          ³       podera ser utilizado em Lacos do tipo while.         ³±±
±±³          ³ExpL5: Variavel que deve ser tornada por referencia indicado³±±
±±³          ³       se a chave de pesquisa busca uma familia ou um codigo³±±
±±³          ³       completo de produto.                                 ³±±
±±³          ³ExpL6: Variavel logica opcional utilizada como SoftSeek nas ³±±
±±³          ³       pesquisas.                                           ³±±
±±³          ³ExpL7: Indica se deve ou nao mostrar help se nao localizar  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³   DATA   ³ Programador   ³Manutencao Efetuada                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³               ³                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/

Function A650SkHY(nIndexOrd,cProduto,cChave,cSeekWhile)
	Local lRet
	Local cAlias		:= Alias()
	Local lFamilia	:= .F.
	Local lSoftSeek	:= .F.

	Default cProduto	:= ""
	Default cSeekWhile 	:= ""

	dbSelectArea("SHY")
	SHY->(dbSetOrder(nIndexOrd))

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Pesquisa na chave principal                                                ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	lRet := SHY->(dbSeek(cChave,lSoftSeek))

	//-- Atualiza expressao do bloco de codigo para while
	If lRet .And. !Empty(cSeekWhile)
		cSeekWhile := A650CSHY(lFamilia,cChave,cSeekWhile)
	EndIf

	dbSelectArea(cAlias)
Return ( lRet )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³A650IntSFCºAutor  ³Andre Anjos		 º Data ³  02/05/11   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDescricao ³ Gera integracao com Chao de Fabrica.                       º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³ nOpc: 3- Inclusao				  						  º±±
±±º			 ³ 		 4- Alteracao				  						  º±±
±±º			 ³ 		 5- Exclusao				  						  º±±
±±º			 ³ nEvento: 1- Inclusao de OP pai						  	  º±±
±±º			 ³ nEvento: 2- Alteracao para geracao das operacoes			  º±±
±±º			 ³ nEvento: 3- Alteracao para geracao dos empenhos			  º±±
±±º			 ³ nEvento: 4- Inclusao de OP filha							  º±±
±±º			 ³ nEvento: 5- Alteracao do cadastro						  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ MATA650                                                    º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function A650IntSFC(nOpc,nEvento,cError,cNome,oModel)
	lRet := PCPIntSFC(nOpc,nEvento,@cError,cNome,oModel)
Return lRet
/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³A650DefLegº Autor ³ Gabriela Kamimoto  º Data ³  27/09/11   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Status para a Ordem de Producao                             º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ MATA650                                                    º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/

Function A650DefLeg(nLeg)
Local aAreaSC2    := SC2->(GetArea())
Local aAreaSTJ    := STJ->( FWGetArea() )
Local cAliasSD3   := GetNextAlias()
Local cAliasSH6   := GetNextAlias()
Local cAliasExi   := GetNextAlias()
Local cFilSC2     := SC2->C2_FILIAL
Local cNumOp      := ""
Local cQuery 	  := ""
Local dEmissao	  := dDatabase
Local dEmissaoH6  := dDatabase
Local dEmissaoD3  := dDatabase
Local lRet 		  := .F.
Local nRegSD3	  := 0						//Contador da tabela SD3
Local nRegSH6	  := 0                      //Contador da tabela SH6

Static cCacheD3
Static cCacheH6
Static cFilAntL
Static cOPAnt
Static cRegSH6
Static dEmiAntH6
Static dEmiAntD3
Static nRegD3Ant
Static nRegH6Ant
Static nSeconAnt

If nLeg == 2 .Or. nLeg == 3 .Or. nLeg == 4

	If cRegSH6 == Nil .or. ((seconds() - nSeconAnt) >= 5)//Atualiza a cada 5 segundos a mesma OP
		cQuery	  := "  SELECT 1 "
		cQuery	  += "   FROM " + RetSqlName('SH6')
		cQuery	  += "   WHERE H6_FILIAL   = '" + xFilial('SH6',cFilSC2)+ "'"
		cQuery	  += "     AND D_E_L_E_T_  = ' '"
		cQuery    := ChangeQuery(cQuery)
		dbUseArea ( .T., "TOPCONN", TCGENQRY(,,cQuery), cAliasExi, .F., .T.)

		If !(cAliasExi)->(Eof())
			cRegSH6 := 'S'
		Else
			cRegSH6 := 'N'
		EndIf

		(cAliasExi)->(DbCloseArea())
	EndIf

	cNumOp := SC2->(C2_NUM+C2_ITEM+C2_SEQUEN+C2_ITEMGRD)

	oPrepSD3 := cCacheD3

	If  oPrepSD3 == NIL .or. ((seconds() - nSeconAnt) >= 5)//Atualiza a cada 5 segundos a mesma OP
		cQuery	  := "  SELECT COUNT(1) AS RegSD3, MAX(D3_EMISSAO) AS EMISSAO "
		cQuery	  += "   FROM " + RetSqlName('SD3')
		cQuery	  += "   WHERE D3_FILIAL   = ? "
		cQuery	  += "     AND D3_OP 	   = ? "
		cQuery	  += "     AND D3_ESTORNO  = ' ' "
		cQuery	  += "     AND D_E_L_E_T_  = ' ' "

		cQuery    := ChangeQuery(cQuery)
		oPrepSD3 := FWPreparedStatement():New(cQuery) //Construtor da carga.
			cCacheD3 := oPrepSD3
	EndIf

	If (cOPAnt == Nil .Or. cOPAnt != cNumOp) .Or. (cOPAnt == cNumOp .And. (cFilAntL == Nil .Or. cFilAntL != cFilSC2));
	   .or. ((seconds() - nSeconAnt) >= 5)//Atualiza a cada 5 segundos a mesma OP
		oPrepSD3:SetString(01, xFilial('SD3',cFilSC2)) //Seta um parâmetro na query via String.
		oPrepSD3:SetString(02, cNumOp)

		cQuery := oPrepSD3:GetFixQuery() //Retorna a query com os parâmetros já tratados e substituídos.
		cAliasSD3 := MPSysOpenQuery(cQuery, cAliasSD3) //Abre um alias com a query informada.

		If !(cAliasSD3)->(Eof())
			dEmissaoD3 := STOD((cAliasSD3)->EMISSAO)
			nRegSD3 := (cAliasSD3)->RegSD3
    	EndIf

		dEmiAntD3 := dEmissaoD3
		nRegD3Ant := nRegSD3

		(cAliasSD3)->(DbCloseArea())
	Else
		dEmissaoD3 := dEmiAntD3
		nRegSD3 := nRegD3Ant
	EndIf

	If cRegSH6 == 'S' .or. ((seconds() - nSeconAnt) >= 5)//Atualiza a cada 5 segundos a mesma OP
		oPrepSH6 := cCacheH6

		If  oPrepSH6 == NIL
			cQuery	  := "  SELECT COUNT(1) AS RegSH6, MAX(H6_DTAPONT) AS EMISSAO  "
			cQuery	  += "   FROM " + RetSqlName('SH6')
			cQuery	  += "   WHERE H6_FILIAL   = ? "
			cQuery	  += "     AND H6_OP 	   = ? "
			cQuery	  += "     AND D_E_L_E_T_  = ' ' "

			cQuery    := ChangeQuery(cQuery)
			oPrepSH6 := FWPreparedStatement():New(cQuery) //Construtor da carga.
			cCacheH6 := oPrepSH6
		EndIf

		If (cOPAnt == Nil .Or. cOPAnt != cNumOp) .Or. (cOPAnt == cNumOp .And. (cFilAntL == Nil .Or. cFilAntL != cFilSC2))

			oPrepSH6:SetString(01, xFilial('SH6',cFilSC2)) //Seta um parâmetro na query via String.
			oPrepSH6:SetString(02, cNumOp)

			cQuery := oPrepSH6:GetFixQuery() //Retorna a query com os parâmetros já tratados e substituídos.
			cAliasSH6 := MPSysOpenQuery(cQuery, cAliasSH6) //Abre um alias com a query informada.

			If !(cAliasSH6)->(Eof())
				dEmissaoH6 := STOD((cAliasSH6)->EMISSAO)
				nRegSH6  := (cAliasSH6)->RegSH6
			EndIf

			dEmiAntH6 := dEmissaoH6
			nRegH6Ant := nRegSH6

			(cAliasSH6)->(DbCloseArea())
		Else
			dEmissaoH6 := dEmiAntH6
			nRegSH6 := nRegH6Ant
		EndIf
	EndIf

	nSeconAnt:= Seconds()
	If !Empty(dEmissaoH6)
		dEmissao := Max(dEmissaoH6,dEmissaoD3)
	Else
		dEmissao := dEmissaoD3
	EndIf

	cOPAnt   := cNumOp
	cFilAntL  := cFilSC2
EndIf

Do Case
	Case nLeg == 1
		lRet := SC2->C2_TPOP == "P" //Prevista
	Case nLeg == 2
		lRet := SC2->C2_TPOP == "F" .And. Empty(SC2->C2_DATRF) .And. (nRegSD3 < 1 .And. nRegSH6 < 1) .And. (Max(dDataBase - SC2->C2_DATPRI,0) < If(SC2->C2_DIASOCI==0,1,SC2->C2_DIASOCI)) //Em aberto
	Case nLeg == 3
		lRet := SC2->C2_TPOP == "F" .And. Empty(SC2->C2_DATRF) .And. (nRegSD3 > 0 .Or. nRegSH6 > 0) .And. (Max((ddatabase - dEmissao),0) < If(SC2->C2_DIASOCI==0,1,SC2->C2_DIASOCI)) //Iniciada
	Case nLeg == 4
		lRet := SC2->C2_TPOP == "F" .And. Empty(SC2->C2_DATRF) .And. (Max((ddatabase - dEmissao),0) > SC2->C2_DIASOCI .Or. Max((ddatabase - SC2->C2_DATPRI),0) >= SC2->C2_DIASOCI)   //Ociosa
	Case nLeg == 5

		lRet := SC2->C2_TPOP == "F" .And. !Empty(SC2->C2_DATRF) .And. SC2->(C2_QUJE < C2_QUANT)  //Enc.Parcialmente

		If lRet .And. SuperGetMV( 'MV_NGMNTPC', .F., 'N' ) == 'S' .And. AllTrim( SC2->C2_ITEM ) == 'OS' .And.;
			AllTrim( SC2->C2_SEQUEN ) == '001'

			dbSelectArea( 'STJ' )
			dbSetOrder( 1 )
			If msSeek( FWxFilial( 'STJ' ) + SC2->C2_NUM ) .And.;
				( STJ->TJ_TERMINO == 'S' .Or. STJ->TJ_SITUACA == 'C' )

				lRet := .F.

			EndIf

		EndIf

	Case nLeg == 6

		lRet := SC2->C2_TPOP == "F" .And. !Empty(SC2->C2_DATRF) .And. SC2->(C2_QUJE >= C2_QUANT) //Enc.Totalmente

		If SuperGetMV( 'MV_NGMNTPC', .F., 'N' ) == 'S' .And. AllTrim( SC2->C2_ITEM ) == 'OS' .And.;
			AllTrim( SC2->C2_SEQUEN ) == '001'

			dbSelectArea( 'STJ' )
			dbSetOrder( 1 )
			If msSeek( FWxFilial( 'STJ' ) + SC2->C2_NUM )

				lRet := SC2->C2_TPOP == 'F' .And. !Empty( SC2->C2_DATRF ) .And.;
					( STJ->TJ_TERMINO == 'S' .Or. STJ->TJ_SITUACA == 'C' )

			EndIf

		EndIf

EndCase

FWRestArea( aAreaSTJ )
RestArea(aAreaSC2)
Return lRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³NrExecAutoºAutor  ³Microsiga           º Data ³  09/11/11   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDescricao ³ Responde se o numero da OP veio no array da execauto.      º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ MATA650                                                    º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function NrExecAuto()
Local nPNUM 	:= aScan(aRotProd,{|x| x[1] == "C2_NUM"})
Local lAPSInUse := SuperGetMV("MV_APS",.F.,"") == "TOTVS"
Return !lAPSInUse .And. !Empty(nPNUM) .And. !Empty(aRotProd[nPNUM,2])

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³A650USOSH5ºAutor  ³Anieli Rodrigues    º Data ³  22/10/12   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Alimenta o array contendo o saldo de saídas já consumido   º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ MATA650                                                    º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ??ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function A650UsoSH5(cPai,cComp,cOrig,cOpc,cPeriodo,nQuant)
Local aArea   := SH5->(GetArea())
Local nPosArr := 0
Local nRet    := 0

If (nPosArr := aScan(aUsoSH5, {|x| x[1]+x[2]+x[3]+x[4] == cPai+cComp+cOrig+cPeriodo})) == 0
	//SH5->(dbSetOrder(4))
	SH5->(dbSetOrder(1))
	SH5->(dbSeek(xFilial("SH5")+cComp+cOpc+IIF(lPCPREVATU , PCPREVATU(SB1->B1_COD), SB1->B1_REVATU )/*SB1->B1_REVATU*/+cPeriodo+'4'))
	While !SH5->(EOF()) .And. SH5->(H5_PRODUTO+H5_OPC+H5_REVISAO+H5_PER+H5_TIPO) == cComp+cOpc+IIF(lPCPREVATU , PCPREVATU(SB1->B1_COD), SB1->B1_REVATU )/*SB1->B1_REVATU*/+cPeriodo+'4'
		If SH5->H5_DOC == PadR(cPai,Len(SH5->H5_DOC)) .And. SH5->H5_PRODORI == cOrig
			If Empty(nPosArr)
				aAdd(aUsoSH5,{cPai,cComp,cOrig,cPeriodo,SH5->H5_QUANT})
				nPosArr := Len(aUsoSH5)
			Else
				aUsoSH5[nPosArr,5] += SH5->H5_QUANT
			EndIf
		EndIf

		SH5->(dbSkip())
	End
EndIf

If !Empty(nPosArr)
	nRet := Min(aUsoSH5[nPosArr,5],nQuant)
	aUsoSH5[nPosArr,5] -= Min(aUsoSH5[nPosArr,5],nQuant)
EndIf

SH5->(RestArea(aArea))
Return nRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³A650USOCZIºAutor  ³Ricardo Prandi      º Data ³  09/10/13   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Alimenta o array contendo o saldo de saídas já consumido   º±±
±±º          ³ consultando as tabelas novas do MRP                        º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ MATA650                                                    º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function A650UsoCZI(cPai,cComp,cOrig,cOpc,cPeriodo,nQuant)
Local aArea   := CZI->(GetArea())
Local cRevCZI := IIf(A712TrataRev(), IIf(lPCPREVATU, PCPREVATU(SB1->B1_COD), SB1->B1_REVATU), CriaVar("B1_REVATU",.F.))
Local nPosArr := 0
Local nRet    := 0

If (nPosArr := aScan(aUsoSH5, {|x| x[1]+x[2]+x[3]+x[4] == cPai+cComp+cOrig+cPeriodo})) == 0
	CZI->(dbSetOrder(1))
	CZI->(dbSeek(xFilial("CZI")+cComp+cRevCZI+cPeriodo+'4'))

	While !CZI->(EOF()) .And. CZI->(CZI_PROD+CZI_NRRV+CZI_PERMRP+CZI_TPRG) = cComp+cRevCZI+cPeriodo+"4"
		If CZI->CZI_DOC == PadR(cPai,Len(CZI->CZI_DOC)) .And. CZI->CZI_PRODOG == cOrig
			If Empty(nPosArr)
				aAdd(aUsoSH5,{cPai,cComp,cOrig,cPeriodo,CZI->CZI_QUANT})
				nPosArr := Len(aUsoSH5)
			Else
				aUsoSH5[nPosArr,5] += CZI->CZI_QUANT
			EndIf
		EndIf

		CZI->(dbSkip())
	End
EndIf

If !Empty(nPosArr)
	nRet := Min(aUsoSH5[nPosArr,5],nQuant)
	aUsoSH5[nPosArr,5] -= Min(aUsoSH5[nPosArr,5],nQuant)
EndIf

CZI->(RestArea(aArea))

Return nRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³A650USOSOQºAutor  ³Lucas Konrad França º Data ³  12/12/14   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Alimenta o array contendo o saldo de saídas já consumido   º±±
±±º          ³ consultando as tabelas novas do MRP Multi empresa          º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ MATA650                                                    º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function A650UsoSOQ(cPai,cComp,cOrig,cOpc,cPeriodo,nQuant)
Local aArea   	:= SOQ->(GetArea())
Local cAliasSOQ := GetNextAlias()
Local cNRRV		:= ''
Local nPosArr 	:= 0
Local nRet    	:= 0

If (nPosArr := aScan(aUsoSH5, {|x| x[1]+x[2]+x[3]+x[4] == cPai+cComp+cOrig+cPeriodo})) == 0
	//Gera a Query
	cNRRV := IIF(lPCPREVATU , PCPREVATU(SB1->B1_COD), SB1->B1_REVATU )
	BeginSql alias cAliasSOQ

	SELECT
		SOQ.*
	FROM
		%table:SOQ% SOQ
	WHERE
		SOQ.OQ_FILIAL = %xfilial:SOQ% AND
		SOQ.OQ_EMP = %Exp:cEmpAnt% AND
		SOQ.OQ_FILEMP = %Exp:cFilAnt% AND
		SOQ.OQ_PROD = %Exp:cComp% AND
		SOQ.OQ_NRRV = %Exp:cNRRV% AND
		SOQ.OQ_PERMRP = %Exp:cPeriodo% AND
		SOQ.OQ_TPRG = %Exp:'4'% AND
		SOQ.OQ_PRODOG = %Exp:cOrig% AND
		SOQ.%notDel%
	EndSql

	While (cAliasSOQ)->(!Eof())
		If Empty(nPosArr)
			aAdd(aUsoSH5,{cPai,cComp,cOrig,cPeriodo,(cAliasSOQ)->OQ_QUANT})
			nPosArr := Len(aUsoSH5)
		Else
			aUsoSH5[nPosArr,5] += (cAliasSOQ)->OQ_QUANT
		EndIf

		(cAliasSOQ)->(DbSkip())
	EndDo
	(cAliasSOQ)->(DbCloseArea())
EndIf

If !Empty(nPosArr)
	nRet := Min(aUsoSH5[nPosArr,5],nQuant)
	aUsoSH5[nPosArr,5] -= Min(aUsoSH5[nPosArr,5],nQuant)
EndIf

SOQ->(RestArea(aArea))

Return nRet

//-------------------------------------------------------------------
/*/{Protheus.doc} A650Opc()
Função para visualização dos opcionais da ordem.
@author Lucas Konrad França
@since 09/09/2014
@version 1.0
@return .T.
/*/
//-------------------------------------------------------------------
Function A650Opc()
   VisualOpc(SC2->C2_PRODUTO,SC2->C2_MOPC,SC2->C2_OPC,MV_PAR17)
Return .T.

//-------------------------------------------------------------------
/*/{Protheus.doc} A650ALCCTB()
Função para exclusão de Controle de Alçada por entidade Contabil
@author Andre Maximo
@since 13/04/2016
@version 1.0
@return .T.
/*/
//-------------------------------------------------------------------

Function A650ALCCTB(cOp, nRecno)

Local aArea   := GetArea()
Local aHeadSC1 :={}
Local aColsSC1 :={}
Local aHeadSCX :={}
Local aColsSCX :={}
Default cOp    := ''
Default nRecno := 0

SC1->(dbSelectArea("SC1"))
If nRecno > 0
	SC1->(dbGoTo(nRecno))
Else
	SC1->(dbSetOrder(4))
	SC1->(dbSeek(xFilial("SC1")+cOp))
EndIf

IF !SC1->(EOF())
	COMGerC1Cx(SC1->C1_NUM,@aHeadSC1,@aColsSC1,@aHeadSCX,@aColsSCX)
	MaEntCtb("SC1","SCX",SC1->C1_NUM,"SC",aHeadSC1,aColsSC1,aHeadSCX,aColsSCX,3,SC1->C1_DATPRF) //-- Avalia Bloqueio por Entidades Contabeis
EndIF

RestArea(aArea)

Return()

/*/{Protheus.doc} mata650PPI

Realiza a integração com o PC-Factory - PPI Multitask

@param 01 cXml     , Caracter, XML que será enviado. Caso não seja passado esse parametro, será realizada
                                a chamada do Adapter para criação do XML.
                                Se for passado esse parâmetro, não será exibida a mensagem de erro caso exista,
                                nem será considerado o filtro da tabela SOE.
@param 02 cOp      , Caracter, Obrigatório quando utilizado o parâmetro cXml. Contém o código da OP (NUM+ITEM+SEQUEN)
@param 03 lTable   , Logic   , Indica se será utilizado variáveis de memória ou do registro posicionado para recuperar os valores.
                                 .T. -> (SC2->C2_NUM)
                                 .F. -> (M->C2_NUM)
@param 04 lPendAut , Logic   , Indica se será gerada a pendência sem realizar a pergunta para o usuário, caso ocorra algum erro.
@param 05 lExclusao, Logic   , Indica se está chamando para rotina de exclusão.
@param 06 lFiltra  , Logic   , Identifica se será realizado ou não o filtro do registro.
@param 07 lInCustom, Logic   , Identifica execução para customização. Não valida rotina permitida para executar
                               a integração e adiciona proteções de interface.
                               USO EXCLUSIVO PARA CUSTOMIZAÇÕES. FONTE PADRÃO ESTE PARÂMETRO DEVE SER SEMPRE .F.

@author  Lucas Konrad França
@version P12
@since   02/09/2015
@return lRet, Logic, Indica se a integração com o PC-Factory foi realizada.
           .T. -> Integração Realizada
           .F. -> Integração não realizada.
/*/
Function mata650PPI(cXml, cOp, lTable, lPendAut, lExclusao, lFiltra, lInCustom)

	lRet := PCPa650PPI(cXml, cOp, lTable, lPendAut, lExclusao, lFiltra, lInCustom)

	If ExistBlock("M650IPPI")
		ExecBlock("M650IPPI",.F.,.F.,{lRet, cOp, lTable, lExclusao})
	EndIf

Return lRet

//-------------------------------------------------------------------------------------------------
/*/{Protheus.doc} buscaArmzm
Busca os armazéns a serem considerados para os produtos alternativos.
@param cLocPadr - Armazém padrão do produto.
@author  Lucas Konrad França
@version P118
@since   29/02/2016
@return  aArm - Array com os armazéns a serem considerados.
/*/
//-------------------------------------------------------------------------------------------------
Static Function buscaArmzm(cLocPadr)
	Local aArm      := {}
	Local aArea     := GetArea()
	Local cAliasNNR := GetNextAlias()
	Local cQuery    := ""

	cQuery := " SELECT NNR.NNR_CODIGO "
	cQuery +=   " FROM " + RetSqlName("NNR") + " NNR "
	cQuery +=  " WHERE NNR.D_E_L_E_T_ = ' ' "
	cQuery +=    " AND NNR.NNR_FILIAL = '" + xFilial("NNR") + "' "
	cQuery +=    " AND NNR.NNR_ARMALT = '1' "
	cQuery +=    " AND NNR.NNR_CODIGO <> '" + cLocPadr + "' "
	cQuery +=  " ORDER BY 1 "
	cQuery := ChangeQuery(cQuery)
	dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasNNR,.T.,.T.)

	aAdd(aArm,cLocPadr)

	While (cAliasNNR)->(!Eof())
		aAdd(aArm,(cAliasNNR)->(NNR_CODIGO))
		(cAliasNNR)->(dbSkip())
	End

	(cAliasNNR)->(dbCloseArea())
	RestArea(aArea)

Return aArm

//-------------------------------------------------------------------
/*/{Protheus.doc} MATA650SG2()
Função de consulta específica SG2002

@author  Renan Roeder
@version P12
@since   26/06/2017
/*/
//-------------------------------------------------------------------
Function MATA650SG2()
   lRet := PCPA650SG2()
Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} ExistOpc()
Verifica se o opcional foi selecionado para o componente/nivel atual.
/*/
//--------------------------------------------------------------------
Function ExistOpc(cOpcMarc, cOpc, cProdAnt, cCompTrt, aOpcArray)
Local lRet	  := .F.
Local aOpc
Local nI	  := 0
Local nI1     := 0
Local aSelOpc := {}
Local cSelOpc

If Empty(aOpcArray)
	aOpc := Str2Array(cOpcMarc,.F.)
Else
	aOpc := aOpcArray
EndIf

If Empty(cOpc)
	lRet := .T.
	Return lRet
EndIf

If GetNewPar("MV_REPGOPC","N") == "S"
	If aOpc != Nil .And. Len(aOpc) > 0
		For nI := 1 To Len(aOpc)
			If cProdAnt + cCompTrt $ aOpc[nI,1]
				If cOpc $ aOpc[nI,2]
					lRet := .T.
				EndIf
				Exit
			EndIf
		Next nI
	Else
		lRet := cOpc $ cOpcMarc
	EndIf
Else
	If aOpc != Nil .And. Len(aOpc) > 0 .And. !Empty(aOpc) .And. !Empty(aOpc[1])
		For nI1 := 1 TO Len(aOpc)
			If !Empty(aOpc[nI1,2])
				aadd(aSelOpc, {aOpc[nI1,2]})
			EndIf
		Next nI1

		cSelOpc := Array2STR(aSelOpc,.F.)

		If (SG1->G1_GROPC+SG1->G1_OPC $ cSelOpc)
			lRet := .T.
		EndIf
	Else
		lRet := cOpc $ cOpcMarc
	EndIf
EndIf

Return lRet


//-------------------------------------------------------------------
/*/{Protheus.doc} a650XmlMES()
Cria e retorna o XML de integração para exclusão da ordem (APS x TOTVS MES).

@param cOrdem 	- Ordem de produção para gerar o XML
@return cXmlMes	- XML de integração Totvs MES.

@author  Lucas Konrad França
@version P12
@since   03/11/2017
/*/
//-------------------------------------------------------------------
Static Function a650XmlMES(cOrdem)
	Local cXmlMes := ""
	Local aAreaC2 := SC2->(GetArea())
	Local aRetXML := {}
	Local lBkpInc := Nil
	Local lBkpAlt := Nil

	Private lRunPPI   := .T.
	Private cPonteiro := "SC2"

	If filtraPrd(&(cPonteiro + "->C2_PRODUTO")) .And. PCPFiltPPI("SC2", cOrdem, cPonteiro)
		If Type("INCLUI") == "L"
			lBkpInc := INCLUI
		EndIf
		If Type("ALTERA") == "L"
			lBkpAlt := ALTERA
		EndIf
		INCLUI  := .F.
		ALTERA  := .F.

		aRetXML := MATI650("", TRANS_SEND, EAI_MESSAGE_BUSINESS,"2.004")

		INCLUI  := lBkpInc
		ALTERA  := lBkpAlt
		If aRetXML[1]
			cXmlMes := EncodeUTF8(aRetXML[2])
		EndIf
	EndIf

	SC2->(RestArea(aAreaC2))
Return cXmlMes

/*/{Protheus.doc} filtraPrd
Aplica filtro de produto na OP se parametrizado.
Chamada protegida para a função do fonte manufacturing.meslite.productionorder

@type  Static Function
@author lucas.franca
@since 24/10/2024
@version P12
@param cProduto, Caracter, Código do produto para filtro
@return lFiltOk, Logic, Indica se o filtro permite a integração
/*/
Static Function filtraPrd(cProduto)
	Local lFiltOk := .T.

	If _lFilPrMES == Nil
		_lFilPrMES := tlpp.ffunc("totvs.protheus.manufacturing.meslite.productionorder.filtraProdutoNaOrdem", .F.)
	EndIf

	If _lFilPrMES
		lFiltOk := totvs.protheus.manufacturing.meslite.productionorder.filtraProdutoNaOrdem(cProduto)
	EndIf
Return lFiltOk

//-------------------------------------------------------------------
/*/{Protheus.doc} a650TabMRP
Função para criar as tabelas do MRP, quando estiver em execução.

@param aResults	- Array retornado pela função ComGeraDoc, com os dados dos registros criados.
@return Nil

@author  Lucas Konrad França
@version P12
@since   14/12/2017
/*/
//-------------------------------------------------------------------
Static Function a650TabMRP(aResults)
	Static cOpc   := Nil

	Local nX := 0
	Local nI := 0
	Local aAreaC7 := SC7->(GetArea())
	Local aAreaC1 := SC1->(GetArea())
	Local lCalcula := .F.
	Local cProduto := ""
	Local cRevisao := Space(Len(SB1->B1_REVATU))
	Local cPeriodo := "001"
	Local cFilSC1  := ''
	Local cFilSC7  := ''
	Local dData

	lProj711 := Iif(lProj711==Nil,.F.,lProj711)
	lMata712 := Iif(lMata712==Nil,.F.,lMata712)
	lPCPA107 := Iif(lPCPA107==Nil,.F.,lPCPA107)

	//Verifica se está sendo executado pelo MRP. Se não for MRP, não faz nada.
	If Len(aResults) > 0 .And. (lProj711 .Or. lMata712 .Or. lPCPA107)
		If cOpc == Nil
			cOpc := CriaVar("C2_OPC",.F.)
		EndIf
		cFilSC1 := xFilial("SC1")
		cFilSC7 := xFilial("SC7")
		SC1->(dbSetOrder(1))
		SC7->(dbSetOrder(1))
		For nI := 1 To Len(aResults)
			For nX := 1 To Len(aResults[nI])
				If aResults[nI,nX,3] == "1" // SC1
					If SC1->(dbSeek(cFilSC1+aResults[nI,nX,2]))
						If lMata712
							lCalcula := .T.
							cProduto := SC1->C1_PRODUTO
							If Empty(dData) .Or. dData > SC1->C1_DATPRF
								dData := SC1->C1_DATPRF
							EndIf
							A712CriCZI(SC1->C1_DATPRF,SC1->C1_PRODUTO,cOpc,cRevisao,"SC1",SC1->(Recno()),SC1->C1_NUM,SC1->C1_ITEM,SC1->C1_OP,Max(0,SC1->C1_QUANT-SC1->C1_QUJE),"2",.T.,/*13*/,/*14*/,.F.,/*16*/,/*17*/,/*18*/,/*19*/,/*20*/,/*21*/,/*22*/,/*23*/,/*24*/,/*25*/,/*26*/)
						ElseIf lPCPA107
							lAtuNec := .T.
							A107CriSOQ(SC1->C1_DATPRF,SC1->C1_PRODUTO,CriaVar("C2_OPC",.F.),Space(Len(SB1->B1_REVATU)),"SC1",SC1->(Recno()),SC1->C1_NUM,SC1->C1_ITEM,SC1->C1_OP,Max(0,SC1->C1_QUANT-SC1->C1_QUJE),"2",.T.,/*13*/,/*14*/,.T.,/*16*/,/*17*/,/*18*/,/*19*/,/*20*/,/*21*/,/*22*/,/*23*/,/*24*/,/*25*/,/*26*/)
							lAtuNec := .F.
							A107CriSOU('SC',Iif(cProd107==SC1->C1_PRODUTO,nRec107,0), lPmp107, SC1->C1_NUM, /*05*/, SC1->C1_ITEM, SC1->C1_ITEMGRD, SC1->C1_QUANT, cPeri107, SC1->C1_DATPRF, SC1->C1_PRODUTO)
						EndIf
					EndIf
				ElseIf aResults[nI,nX,3] $ "23" // SC7
					If SC7->(dbSeek(cFilSC7+aResults[nI,nX,2]))
						If lMata712
							lCalcula := .T.
							cProduto := SC7->C7_PRODUTO
							If Empty(dData) .Or. dData > SC7->C7_DATPRF
								dData := SC7->C7_DATPRF
							EndIf
							A712CriCZI(SC7->C7_DATPRF,SC7->C7_PRODUTO,cOpc,cRevisao,"SC7",SC7->(Recno()),SC7->C7_NUM,SC7->C7_ITEM,SC7->C7_OP,SC7->C7_QUANT,"2",.F.,/*13*/,/*14*/,.F.,/*16*/,/*17*/,/*18*/,/*19*/,/*20*/,/*21*/,/*22*/,/*23*/,/*24*/,/*25*/,/*26*/)
						ElseIf lPCPA107
							A107CriSOQ(SC7->C7_DATPRF,SC7->C7_PRODUTO,Space(80),Space(3),"SC7",SC7->(Recno()),SC7->C7_NUM,SC7->C7_ITEM,SC7->C7_OP,SC7->C7_QUANT,"2",.T.,/*13*/,/*14*/,.F.,/*16*/,/*17*/,/*18*/,/*19*/,/*20*/,/*21*/,/*22*/,/*23*/,/*24*/,/*25*/,/*26*/)
						EndIf
					EndIf
				EndIf
			Next nX
		Next nI
		If lMata712 .And. lCalcula
			cPeriodo := A650DtoPer(dData)
			MA712Recalc(cProduto,cOpc,cRevisao,cPeriodo,/*05*/,/*06*/,/*07*/,/*08*/,/*09*/)
		EndIf
		SC1->(RestArea(aAreaC1))
		SC7->(RestArea(aAreaC7))
	EndIf
Return
//-------------------------------------------------------------------
/*/{Protheus.doc} A650CalNec
Função para calcular a quantidade necessária do componente

@param
@return nQtNeces

@author  Michele Girardi
@version P12
@since   10/05/2018
/*/
//-------------------------------------------------------------------
 Static Function A650CalNec(cProduto, cTrt, cOp)
 Local cProdPai := ""
 Local nQtNeces := 0
 Local cProdPai := ""
 Local nI := 0
 Local lReqNec  := (SUPERGETMV("MV_REQNEC", .F., "N") == "S")
 Local aAreaSB1 := GetArea()
 Local aAreaSC2 := GetArea()

 dbSelectArea("SC2")
 SC2->(dbSetOrder(1))
 If SC2->(dbSeek(xFilial("SC2")+cOp))
 	cProdPai := SC2->C2_PRODUTO
 EndIf

 If !Empty(cProdPai)
 	If SB1->(dbSeek(xFilial("SB1")+cProdPai))
		nQtdBase := SB1->B1_QB
	EndIf
 EndIf

 If lReqNec
 	If SB1->(dbSeek(xFilial("SB1")+cProduto))
 		If SB1->B1_TIPODEC == "I"
			For nI := 1 to len(aRecNec)
				If aRecNec[nI][1] == cProduto .and. aRecNec[nI][2] == cTrt
					If nQtdBase > 0
						nQtNeces := aRecNec[nI][3] / nQtdBase
					Else
						nQtNeces := aRecNec[nI][3]
					EndIf
				EndIf
			Next
 		EndIf
 	EndIf
 EndIf

 RestArea(aAreaSB1)
 RestArea(aAreaSC2)

 Return nQtNeces

 //-------------------------------------------------------------------
/*/{Protheus.doc} A650VlQtNe
Função para não permitir alterar quantidade se utilizar requisição
por quantidade necessaria

@param
@return lRet

@author  Michele Girardi
@version P12
@since   10/05/2018
/*/
//-------------------------------------------------------------------
 Function A650VlQtNe(cProduto)
 Local lRet := .T.
 Local lReqNec  := (SUPERGETMV("MV_REQNEC", .F., "N") == "S")
 Local aAreaSB1 := GetArea()

 If lReqNec
 	If SB1->(dbSeek(xFilial("SB1")+cProduto))
 		If SB1->B1_TIPODEC == "I"
 			Help(" ",1,"MA650ALTQTREQ") //'Não é permitido alterar a quantidade do empenho para componente que possui requisição por quantidade necessária.
 			lRet := .F.
 		EndIf
 	EndIf
 EndIf

 RestArea(aAreaSB1)
 Return lRet


/*/{Protheus.doc} vldOpACD
Verifica se uma OP pode ser excluída quando existe integração do SIGAACD x SIGASFC.
Será utilizada a OP que estiver posicionada na SC2.

@author lucas.franca
@since 03/09/2018
@return lRet	- Indica se a OP pode ser excluída ou não, de acordo com a integração do SIGAACD x SIGASFC.
/*/
Static Function vldOpACD()
	lRet := PCPvlOpACD()
Return lRet

/*/{Protheus.doc} IntegDef
Funcao de tratamento para o recebimento/envio de mensagem única para Ordens de produção (ProductionOrder)

@author lucas.franca
@since 26/09/2018

@param   cXml			- Variável com conteúdo XML para envio/recebimento.
@param   nTypeTrans		- Tipo de transação. (Envio/Recebimento)
@param   cTypeMessage	- Tipo de mensagem. (Business Type, WhoIs, etc)
@param   cVersion		- Versão da mensagem.

@return  aRet   - (array)   Contém o resultado da execução e a mensagem XML de retorno.
			aRet[1] - (boolean)  Indica o resultado da execução da função
			aRet[2] - (caracter) Mensagem XML para envio
			aRet[3] - (caracter) Nome da mensagem
/*/
Static Function IntegDef(cXML,nTypeTrans,cTypeMessage,cVersion)
Return MATI650(cXml,nTypeTrans,cTypeMessage,cVersion)

/*/{Protheus.doc} CalcEntreg
Varre a estrutura do produto e calcula o prazo de entrega, considerando
o maior tempo de determinado "nó" da estrutura.

@author lucas.franca
@since 27/12/2018
@version P12
@param cProduto, character, Código do produto da ordem de produção
@param nQuant  , numeric  , Quantidade da ordem de produção
@param dDataEnt, date     , Data de início da ordem de produção
@return nMaxPrazo, numeric, Prazo total para entrega dos componentes.
/*/
Static Function CalcEntreg(cProduto,nQuant,dDataEnt)
	nMaxPrazo := PCPCalcEnt(cProduto,nQuant,dDataEnt)
Return nMaxPrazo

/*/{Protheus.doc} enviaOpMrp
Envia os empenhos para o MRP

@type  Static Function
@author brunno.costa
@since 23/07/2019
@version P12.1.27
@param cOperac    , Character, Operação em execução (INSERT/DELETE)
@param aMRPxJson  , Array    , Array com os dados para enviar - APONTAMENTOS.
@param lDelTBMRP  , logico   , indica se deve excluir a tabela temporaria
@return Nil
/*/
Static Function enviaOpMrp(cOperac, aMRPxJson, lDelTBMRP)
	Local aAreaAtu   := GetArea()

	//Integra os dados com a API - APONTAMENTOS
	If _lNewMRP .and. aMRPxJson != Nil .and. Len(aMRPxJson[1]) > 0
		MATA650INT(cOperac, aMRPxJson[1])
		aSize(aMRPxJson[1], 0)
		FreeObj(aMRPxJson[2])
		aMRPxJson[2] := Nil
	EndIf

	//Inicializa variável de controle da integração com o novo mrp.
	If lDelTBMRP
		_lNewMRP := Nil
	EndIf

	RestArea(aAreaAtu)
Return Nil

/*/{Protheus.doc} MATAFINDOP
Verifica se a operação vinculada ao empenho é valida.
Caso não seja, busca a última operação válida e a retorna.

@type  Static Function
@author marcos.wagner
@since 29/01/2020
@version P12.1.27
@param cProduto  , Character, Código do produto
@param cRoteiro  , Character, Código do Roteiro
@param cOperac   , Character, Código da Operação
@param cComponent, Character, Código do componente
@return cRet     , Character, Operação válida
/*/
Static Function MATAFINDOP(cProduto, cRoteiro, cOperac, cComponent)
	Local aAreaSG2 := SG2->(GetArea())
	Local cRet     := cOperac
	Local lRet     := .F.

	dbSelectArea("SG2")
	SG2->(dbSetOrder(1)) //G2_FILIAL+G2_PRODUTO+G2_CODIGO+G2_OPERAC
	If SG2->(dbSeek(xFilial("SG2")+cProduto+cRoteiro+cOperac))
		//Verifica se a operação atual está válida
		If Empty(SG2->G2_DTFIM) .Or. SG2->G2_DTFIM >= dDatabase
			lRet := .T.
		Else
			//Busca a última operação válida para o roteiro
			SG2->(dbSeek(xFilial("SG2")+cProduto+cRoteiro))
			While !SG2->(Eof())                      .AND. ;
			       SG2->G2_FILIAL  == xFilial("SG2") .AND. ;
				   SG2->G2_PRODUTO == cProduto       .AND. ;
				   SG2->G2_CODIGO  == cRoteiro

				If Empty(SG2->G2_DTFIM) .Or. SG2->G2_DTFIM >= dDatabase
					lRet := .T.
					cRet := SG2->G2_OPERAC
				EndIf

				SG2->(dbSkip())
			End
		EndIf
	EndIf

	If !lRet //Senão encontrar operação válida, retorna operação em branco
		cRet := Space(TamSX3("G2_OPERAC")[1])
	EndIf

	RestArea(aAreaSG2)

Return cRet

/*/{Protheus.doc} MTA650MSG
	Procura Pedido de Compra vinculadas á OP, com status de usada.
	@type  Static Function
	@author vivian.beatriz
	@since 02/09/2022
	@version 1.0
	@return lFound, logical, identifica se achou PC (SC7) aberta
	/*/
Static Function MTA650MSG(lAptEmp)

local lOk := .F.

If !lAptEmp
   ConOut(Repl("*",40))
   ConOut(RetTitle("D3_OP") + " " + STR0193)
   ConOut(Repl("*",40))
   AutoGrLog(RetTitle("D3_OP") + " " + STR0193)
Else
   lOk := .T.
EndIf

Return lOk

/*/{Protheus.doc} fFindPC
	Procura Pedido de Compra vinculadas á OP, com status de usada.
	@type  Static Function
	@author mauricio.joao
	@since 14/04/2020
	@version 1.0
	@return lFound, logical, identifica se achou PC (SC7) aberta
	/*/
Static Function fFindPC(cNumOp, cItemOP, cSequenOP)
Local cAliasSC7 := GetNextAlias()
Local lFound 	:= .F.
Local lExcluiAE	:= Iif(SuperGetMv("MV_DELEAE")=="S",.T.,.F.)
Local cTipo 	:= "%" + "SC7.C7_TIPO IN ('1','2')" + "%" //Tipo, pedido(1) ou ae(2)

//se pode excluir a AE, não valida se existe.
If lExcluiAE
	cTipo 	:=  "%" + "SC7.C7_TIPO IN ('1')" + "%"
EndIf
//Gera a Query
BeginSql alias cAliasSC7

SELECT
	SC7.C7_NUM, SC7.C7_QUJE, SC7.C7_QUANT, SC7.C7_QTDACLA
FROM
	%table:SC7% SC7
WHERE
	SC7.C7_FILIAL = %xfilial:SC2% AND
	SC7.C7_OP = %Exp:cNumOp+cItemOP+cSequenOP% AND
	%Exp:cTipo% AND
	SC7.C7_RESIDUO = '' AND
	SC7.%notDel%

EndSql

While (cAliasSC7)->(!Eof())

	lFound := .T.

	(cAliasSC7)->(DbSkip())
	Exit

Enddo
//Fecha a tabela
(cAliasSC7)->(DbCloseArea())

Return lFound

/*/{Protheus.doc} MTA650ARMZ()
    não permite informar o parametro 'não considera armazem padrão' e deixar
	o parametro 'armazém até'em branco.
    @type  Function
    @author mauricio.joao
    @since 28/04/2020
    @version 1.0
/*/
Function MTA650ARMZ(cParCons,cParArm)

//forçao preenchimento do campo.
If cParCons == 2 .and. empty(cParArm) //se NÃO considera armazém padrão E armazém em branco.
    mv_par04 := Replicate("Z",tamsx3("B2_LOCAL")[1])
EndIf

Return .T.

/*/{Protheus.doc} AtuCYP
	Função que atualiza a CYP tabela de empenhos do SFC
	@type  Function
	@author maiara.cunhago
	@since 28/06/2022
	@version 1.0
	@param cProd , caractere, d4_cod
		   cOp   , caractere, d4_op
		   cLocal, caractere, d4_local
	@return null
	@example
	(examples)
	@see (links_or_references)
	/*/
Function AtuCYP(cProd, cOp, cLocal)

Local aAreaSD4 := SD4->(GetArea())
Local aRecDel  := {}
Local aRecno   := {}
Local cAliasCYP:= GetNextAlias()
Local cAliasQP := GetNextAlias()
Local nCont    := 0
Local nI       := 1
Local nQtdOri  := 0
Local nRecDel  := 0
Local nRecno   := 0

////////////////////////////////////////////////////////////
///Query que verifica se existem mais de 2 apontamentos ////
////////////////////////////////////////////////////////////
BeginSql alias cAliasQP

 SELECT
 	COUNT(CYP.CYP_QTRP) as CYP_QTRP
 FROM
 	%table:CYP% CYP
 WHERE
 CYP.CYP_FILIAL = %xfilial:CYP% AND
 CYP.CYP_NRORPO = %Exp:cOp%     AND
 CYP.CYP_QTRP   > 0             AND
 CYP.CYP_CDDP   = %Exp:cLocal%  AND
 CYP.CYP_CDMT   = %Exp:cProd%   AND
 CYP.CYP_CDLO   = ' '           AND
 CYP.%notDel%

 EndSql

nCont := (cAliasQP)->(CYP_QTRP)

(cAliasQP)->(dbCloseArea())

////////////////////////////////////////////////////////////
///Se existir mais de um registro não permite excluir ////
////////////////////////////////////////////////////////////
If nCont > 1
	Help( ,, 'Help',, STR0221 , 1, 0 )
	lRetSFC := .F.
Else
////////////////////////////////////////////////////////////
///Query que retorna os empenhos da tabela SFC          ////
////////////////////////////////////////////////////////////
	BeginSql alias cAliasCYP

	SELECT
		CYP.CYP_FILIAL,
		CYP.CYP_NRORPO,
		CYP.CYP_CDMT,
		CYP.CYP_QTMT,
		CYP.CYP_QTRP,
		CYP.R_E_C_N_O_
	FROM
		%table:CYP% CYP
	WHERE
		CYP.CYP_FILIAL = %xfilial:CYP% AND
		CYP.CYP_NRORPO = %Exp:cOp%     AND
		CYP.CYP_CDDP   = %Exp:cLocal%  AND
 		CYP.CYP_CDMT   = %Exp:cProd%   AND
		CYP.CYP_CDLO   = ' '           AND
		CYP.%notDel%
	ORDER BY
		CYP.CYP_QTRP

	EndSql

	While (cAliasCYP)->(!Eof())
		////////////////////////////////////////////////////////////////
		///Se existe um apontamento os demais empenhos do mesmo      ///
		///armazem serão aglunitinados no que ja possui apontamento  ///
		///e esses serão deletados                                   ///
		////////////////////////////////////////////////////////////////
		If nCont == 1
			If (cAliasCYP)->(CYP_QTRP) == 0
				nQtdOri += (cAliasCYP)->(CYP_QTMT)
				AAdd(aRecDel,(cAliasCYP)->(R_E_C_N_O_))

			ElseIf (cAliasCYP)->(CYP_QTRP) > 0
				nRecno :=  (cAliasCYP)->(R_E_C_N_O_)
			EndIf
			////////////////////////////////////////////////////////////////
			///Se não existem apontamentos todos os empenhos são somados ///
			////////////////////////////////////////////////////////////////
		ElseIf nCont == 0
			nQtdOri += (cAliasCYP)->(CYP_QTMT)
			AAdd(aRecno,(cAliasCYP)->(R_E_C_N_O_))

		EndIf

		(cAliasCYP)->(dbSkip())
	EndDo


	DbSelectArea("CYP")
	If nRecno > 0 .and. nCont == 1
		DbGoto(nRecno)
		RecLock("CYP",.F.)
		Replace CYP_QTMT With CYP_QTMT + nQtdOri
		MsUnLock()


		For nI := 1 to len(aRecDel)
			nRecDel := aRecdel[nI]
			DBGoTo(nRecDel)
			RecLock("CYP",.F.,.T.)
			dbDelete()
			MsUnLock()
		Next


	ElseIf len(aRecno) > 0 .and. nCont == 0
		DBGoTo(aRecno[len(aRecno)])
		RecLock("CYP",.F.)
		Replace CYP_QTMT With nQtdOri
		MsUnLock()


		For nI := 1 to len(aRecno)-1
			nRecno := aRecno[nI]
			DBGoTo(nRecno)
			RecLock("CYP",.F.,.T.)
			dbDelete()
			MsUnLock()
		Next

	EndIf

	(cAliasCYP)->(dbCloseArea())
EndIf

RestArea(aAreaSD4)
Return

Function EmpPai()
Local lRet := .T.
Local lEmpPrdOp := SuperGetMV("MV_EMPDOP",.F.,.T.)

//Valida se o produto a ser empenhado é diferente do produto final
IF !lEmpPrdOp
	If M->G1_COMP == cPrdEmpDop
		Help(" ",1,"MA380EMPDOP")
		lRet:=.F.
	EndIf
EndIf

Return lRet

/*/{Protheus.doc} vldRegOPI
Verifica se deve ser executada a verificação de existência
de OPs pendentes para processar a geração de OPs Intermediárias

@type  Static Function
@author lucas.franca
@since 17/01/2024
@version P12
@param 01 lGerar, Logic, Retorna por referência se deve processar a geração de intermediárias
@param 02 lAuto , Logic, Indica se está sendo feita execução automática
@param 03 aData , Array, Array com os dados da execução automática
@return lValida, Logic, .T. se deve executar a verificação de existência de ops para processar
/*/
Static Function vldRegOPI(lGerar, lAuto, aData)
	Local lValida := .T.
	Local nPos    := 0

	If lAuto
		nPos := aScan(aData,{|x| x[1] == "AUT_CHECKOPI"})
		If nPos > 0 .And. aData[nPos][2] == "N"
			lValida := .F.
			lGerar  := .F.
		EndIf
	EndIf

Return lValida

/*/{Protheus.doc} UsaCRP
Verifica se o ambiente está atualizado para utilizar as funções do CRP.

@type  Static Function
@author lucas.franca
@since 12/06/2024
@version P12
@return _lCrpOK, Logic, indica se pode utilizar as funções do CRP.
/*/
Static Function UsaCRP()
	If _lCrpOk == Nil
		_lCrpOk := AliasInDic("HWF") .And. FindFunction('PCPA152')
	EndIf
Return _lCrpOk

/*/{Protheus.doc} A650EnOp
Função que encerra as OPs em massa - DMANSMARTSQUAD1-28904.
@type  Function
@author Fábio.Boarini
@since 08/07/2024
@version P12
@return nil.
/*/
Function A650EnOp()
    Local oSay      := nil
    Local cOrdemDe  := ""
	Local cOrdemAte := ""

	//--  Variáveis utilizadas para os parâmetros --//
    // mv_par01            // De Ordem de Produção?
    // mv_par02            // Até Ordem de Produção?
	If Pergunte("MTA650ENC",.T.)
		cOrdemDe  := MV_PAR01
		cOrdemAte := MV_PAR02

    	FWMsgRun(, {|oSay| CloseOp(oSay,cOrdemDe,cOrdemAte) }, STR0250, STR0251, STR0252) // "Processando" //"Encerrando Ordens de Produção" //"Aguarde"
	EndIf

	//Retorna a pergunta Original
	Pergunte("MTA650",.F.)
	DbSelectArea('SC2')

Return

/*/{Protheus.doc} CloseOp
Função que processa o encerramento das OP's em massa via ExecAuto do MATA250.
@type  Function
@author Fábio.Boarini
@since 08/07/2024
@version P12
@return nil.
/*/
Static Function CloseOp(oSay,cOrdemDe,cOrdemAte)

	Local aColumns	  := {}
	Local aErroAuto   := {}
	Local aInfo       := {}
    Local aLogAuto    := {}
	Local aObjects    := {}
	Local aOpEnc      := {}
	Local aPosObj     := {}
	Local aSize       := {}
    Local aStruct     := {}
    Local aTam        := {}
    Local aVetor      := {}
    Local cAliasSC2   := GetNextAlias()
	Local cAliasSD3   := GetNextAlias()
	Local cAliasPr1   := GetNextAlias()
	Local cColOP      := STR0244 //"Ordem de Produção"
	Local cColProd    := STR0245 //"Produto"
	Local cColMsg     := STR0246 //"Resultado do Processamento"
    Local cLogTxt     := ""
    Local cQuery      := ""
	Local cQueryD3    := ""
	Local cQueryPR1   := ""
    Local nOpc        := 7 // Opção de execução da rotina - Encerra OP
    Local nAux        := 0
	Local nX		  := 0
	Local oDlg		  := nil
    Local oTempTable  := FWTemporaryTable():New("TMPCloseOP")

	Private lMsErroAuto    := .F.
	Private lAutoErrNoFile := .T.

    aTam := TamSX3("D3_OP")
    aAdd(aStruct, {"TMP_OP",   aTam[3],aTam[1],aTam[2]})
    aTam := TamSX3("D3_COD")
    aAdd(aStruct, {"TMP_COD",  aTam[3],aTam[1],aTam[2]})
    aTam := TamSX3("CV8_MSG")
    aAdd(aStruct, {"TMP_MSG",  aTam[3],aTam[1],aTam[2]})
    aAdd(aStruct, {"TMP_PROC", "N"    ,1     ,0       })

    oTempTable:SetFields( aStruct )
    oTempTable:AddIndex("1", {aStruct[1,1],aStruct[2,1],aStruct[3,1],aStruct[4,1]})
    oTempTable:Create()
    cAliasTMP := oTempTable:GetAlias()

	//CARREGA C2_OP
	GrvOpSC2()

	//BUSCAR TODAS OPS DA SC2
	cQuery := " SELECT SC2.C2_OP NUM_OP, C2_DATRF DATA_ENC, C2_TPOP TIP_OP, C2_PRODUTO PRODUTO, C2_EMISSAO EMISSAO "
	cQuery += "   FROM " +RetSqlName("SC2")+" SC2" "
	cQuery += "  WHERE SC2.C2_FILIAL = '"+xFilial('SC2')+"' "
	cQuery += "    AND SC2.C2_OP     BETWEEN '"+cOrdemDe+"' AND '"+cOrdemAte+"' "
	cQuery += "    AND D_E_L_E_T_   = ' ' "
	cQuery += "  ORDER BY SC2.C2_OP "

	dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasSC2,.T.,.T.)

	If (cAliasSC2)->(EOF())
		 Help(NIL, NIL, STR0247, NIL,STR0248, 1, 0, NIL, NIL, NIL, NIL, NIL, {STR0249}) //"Encerrar Ordem" //"Não foram encontradas ordens de produção válidas para o processamento." //"Rever os parâmetros informados para o processamento."
    Else
        While (cAliasSC2)->(!EOF())

			//VERIFICA SE A OP ESTÁ ENCERRADA
			If !Empty((cAliasSC2)->DATA_ENC)
				cLogTxt := STR0253 //"Ordem de Produção já encerrada."
				Aadd(aLogAuto,{0,cLogTxt,(cAliasSC2)->NUM_OP,(cAliasSC2)->PRODUTO})
				(cAliasSC2)->(dbSkip())
				Loop
			EndIf

			//VERIFICA SE A OP É FIRME OU PREVISTA
			If (cAliasSC2)->TIP_OP = 'P'
				cLogTxt := STR0254 //"Ordem de Produção é do tipo prevista."
				Aadd(aLogAuto,{0,cLogTxt,(cAliasSC2)->NUM_OP,(cAliasSC2)->PRODUTO})
				(cAliasSC2)->(dbSkip())
				Loop
			EndIf

			//Busca informações SD3
			cQueryD3 := " SELECT MAX(R_E_C_N_O_) RECNO"
			cQueryD3 += "   FROM " +RetSqlName("SD3")+" SD3" "
			cQueryD3 += "  WHERE SD3.D3_FILIAL  = '"+xFilial('SD3')+"' "
			cQueryD3 += "    AND SD3.D3_OP      = '" + (cAliasSC2)->NUM_OP + "' "
			cQueryD3 += "    AND SD3.D3_ESTORNO = ' ' "
			cQueryD3 += "    AND SD3.D3_CF      = 'PR0' "
			cQueryD3 += "    AND D_E_L_E_T_     = ' ' "

			dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQueryD3),cAliasSD3,.T.,.T.)

			//Não existe PR0
			If ((cAliasSD3)->RECNO) == 0

				//Verificar se existe PR1 - Se possuir é apontamento automático e será encerrada automaticamente pelo PR0.
				cQueryPR1 := " SELECT MAX(R_E_C_N_O_) RECNO"
				cQueryPR1 += "   FROM " +RetSqlName("SD3")+" SD3" "
				cQueryPR1 += "  WHERE SD3.D3_FILIAL  = '"+xFilial('SD3')+"' "
				cQueryPR1 += "    AND SD3.D3_OP      = '" + (cAliasSC2)->NUM_OP + "' "
				cQueryPR1 += "    AND SD3.D3_ESTORNO = ' ' "
				cQueryPR1 += "    AND SD3.D3_CF      = 'PR1' "
				cQueryPR1 += "    AND D_E_L_E_T_     = ' ' "

				dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQueryPR1),cAliasPr1,.T.,.T.)

				//Não existe PR0 e PR1
				If ((cAliasPr1)->RECNO) == 0
					cLogTxt := STR0255 //"Ordem de Produção não possui movimento de produção (PR0)."
					Aadd(aLogAuto,{0,cLogTxt,(cAliasSC2)->NUM_OP,(cAliasSC2)->PRODUTO})
				Else
					//Se existir PR1 incluir no array para verificar no final do processamento se essas OPs foram encerradas pelo PR0
					Aadd(aOpEnc,{(cAliasSC2)->NUM_OP,(cAliasSC2)->PRODUTO})
				EndIf
				(cAliasPr1)->(dbCloseArea())
			Else
				DbSelectArea("SD3")
				SD3->(dbGoTo((cAliasSD3)->RECNO))

				lMsErroAuto  := .F.

				aVetor := {;
          					{"D3_FILIAL" ,xFilial("SD3")  ,NIL},;
          					{"D3_COD"    ,SD3->D3_COD     ,NIL},;
          					{"D3_LOCAL"  ,SD3->D3_LOCAL   ,NIL},;
          					{"D3_NUMSEQ" ,SD3->D3_NUMSEQ  ,NIL},;
          					{"D3_CF"     ,SD3->D3_CF      ,NIL},;
          					{"INDEX"     ,3               ,NIL}}

                MSExecAuto({|x, y| mata250(x, y)},aVetor, nOpc )

				If lMsErroAuto
					aErroAuto := GetAutoGRLog()
					cLogTxt := " "
					For nAux := 1 To Len( aErroAuto )
						cLogTxt += aErroAuto[nAux]
					Next nAux

					Aadd(aLogAuto,{1,cLogTxt,(cAliasSC2)->NUM_OP,(cAliasSC2)->PRODUTO})
				Else
					cLogTxt := STR0256 //"Ordem de Produção encerrada com sucesso."
					Aadd(aLogAuto,{1,cLogTxt,(cAliasSC2)->NUM_OP,(cAliasSC2)->PRODUTO})
				EndIf
            EndIf
			(cAliasSD3)->(dbCloseArea())

            (cAliasSC2)->(dbSkip())
		EndDo
	    (cAliasSC2)->(dbCloseArea())
	EndIf

	//Verifica array das OPs com PR1 se foram encerradas no processamento.
	If Len(aOpEnc) > 0
		For nAux := 1 To Len(aOpEnc)
			dbSelectArea("SC2")
			If dbSeek(xFilial("SC2")+aOpEnc[nAux,1])
				If !Empty(SC2->C2_DATRF)
					cLogTxt := STR0256 //"Ordem de Produção encerrada com sucesso."
					Aadd(aLogAuto,{1,cLogTxt,aOpEnc[nAux,1],aOpEnc[nAux,2]})
				Else
					cLogTxt := STR0255 //"Ordem de Produção não possui movimento de produção (PR0)."
					Aadd(aLogAuto,{0,cLogTxt,aOpEnc[nAux,1],aOpEnc[nAux,2]})
				EndIf
			EndIf
		Next

		ASORT(aLogAuto,,,{ |x,y| x[1] < y[1]})
	EndIf

	For nAux := 1 To Len(aLogAuto)
        (cAliasTMP)->(DBAppend())
        (cAliasTMP)->TMP_OP     := aLogAuto[nAux,3]
        (cAliasTMP)->TMP_COD    := aLogAuto[nAux,4]
        (cAliasTMP)->TMP_MSG    := aLogAuto[nAux,2]
        (cAliasTMP)->TMP_PROC   := aLogAuto[nAux,1]
        (cAliasTMP)->(DBCommit())
    Next

	aSize := MsAdvSize()
	aObjects := {}
	AAdd( aObjects, { 100, 100, .T., .T. } )
	aInfo := { aSize[1], aSize[2], aSize[3], aSize[4], 2, 2 }
	aPosObj := MsObjSize( aInfo, aObjects )

	DEFINE MSDIALOG oDlg TITLE STR0257 FROM aSize[7],0 TO aSize[6],aSize[5] OF oMainWnd PIXEL //"Resultado do Encerramento das Ordens de Produção"

    oBrowse := FWBrowse():New()
    oBrowse:SetDataTable( .T. )
    oBrowse:SetAlias( cAliasTMP )
    oBrowse:SetOwner( oDlg )
    oBrowse:AddLegend("(cAliasTMP)->TMP_PROC == 1","GREEN",STR0256)  //"Ordem de Produção encerrada com sucesso."
    oBrowse:AddLegend("(cAliasTMP)->TMP_PROC == 0","RED" , STR0258)  //"Ordem de Produção não encerrada no processamento."

    aColumns    := {}

    For nX := 1 To Len( aStruct )
    	AAdd( aColumns, FWBrwColumn():New() )
        aColumns[Len(aColumns)]:SetData( &("{||"+aStruct[nX][1]+"}") )
		aColumns[Len(aColumns)]:SetSize( aStruct[nX][3] )

		If aStruct[nX][1] == "TMP_OP"
			aColumns[Len(aColumns)]:SetTitle( cColOP )
		ElseIf aStruct[nX][1] == "TMP_COD"
			aColumns[Len(aColumns)]:SetTitle( cColProd )
		ElseIf aStruct[nX][1] == "TMP_MSG"
			aColumns[Len(aColumns)]:SetTitle( cColMsg )
			Exit
		EndIf
	Next nX

    oBrowse:SetColumns(aColumns)
    oBrowse:Activate()

    ACTIVATE MSDIALOG oDlg

	(cAliasTMP)->(DbCloseArea())
    oTempTable:Delete()
    FreeObj(oTempTable)
    FreeObj(oDlg)
    FreeObj(oSay)

Return

/*/{Protheus.doc} VerApont
Função para verificar se as OP's tem apontamento e/ou movimento.
Parâmetros:
cOp - Ordem de Produção
cProduto - Cód. do Produto
@type  Static Function
@author Fábio.Boarini
@since 03/10/2024
@version P12
@return lRet - Retorna .F. caso tenha movimento sem estorno na SD3 ou apontamento na SH6.
/*/
Static Function VerApont(cOp,cProduto)
	Local lRet     := .T.
	Local cQrySD3  := ""
	Local cAliasD3 := GetNextAlias()
	Local aAreaSH6 := SH6->(GetArea())

	DbSelectArea("SH6")
	DbSetOrder(1)
	If SH6->(DbSeek(xFilial("SH6")+cOp+cProduto))
		lRet := .F.
	Else
		cQrySD3 := " SELECT COUNT(1) COUNTD3 "
		cQrySD3 += " FROM "+RetSqlName('SD3') + " SD3 "
		cQrySD3 += " WHERE SD3.D3_FILIAL = '"+xFilial("SD3")+"' "
		cQrySD3 += " AND SD3.D3_OP = '"+cOP +"' "
		cQrySD3 += " AND SD3.D3_ESTORNO = ' ' "
		cQrySD3 += " AND SD3.D_E_L_E_T_ = ' ' "

		dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQrySD3),cAliasD3,.T.,.T.)

		If (cAliasD3)->COUNTD3 > 0
			lRet := .F.
		EndIf

		(cAliasD3)->(DbCloseArea())
	Endif

	RestArea(aAreaSH6)

Return lRet

/*/{Protheus.doc} a650DelHZA
Função para verificar se a OP a ser excluída foi iniciada pelo APP Play/Stop
Se a OP estiver iniciada não realizar a exclusão
@type  Static Function
@author Michele Girardi
@since 04/11/2024
@version P12
@param cNumOp - Ordem de Produção a ser validada
@return lRet - Retorna .F. caso a OP esteja iniciada
/*/
Static Function a650DelHZA(cNumOp, lExibeMsg)
	Local cAlias    := GetNextAlias()
	Local cMsg1     := ""
	Local cQuery    := ""
	Local lExistHZA := AliasInDic("HZA")
	Local lRet      := .T.

	Default lExibeMsg := .T.

	If lExistHZA
		cQuery := "SELECT HZA_OPERAC OPERAC, HZA_OPERAD OPERADOR "
		cQuery += "  FROM "+RetSqlName("HZA")+" HZA "
		cQuery += " WHERE HZA_FILIAL = '"+xFilial("HZA")+"' "
		cQuery += "   AND HZA_OP = '"+cNumOp+"' "
		cQuery += "   AND HZA_STATUS = '1' "
		cQuery += "   AND D_E_L_E_T_ = ' ' "
		cQuery += " ORDER BY HZA_SEQ DESC "

		dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAlias,.T.,.T.)

		If (cAlias)->(!Eof())
			If lExibeMsg
				cMsg1 := STR0262 + cValToChar((cAlias)->OPERAC) + STR0263 + cValToChar((cAlias)->OPERADOR) + "." //"A operação [HZA_OPERAC] desta OP foi iniciada pelo operador [HZA_OPERAD]."
				Help(" ",1,"HELP", ,cMsg1,1,0, ,,,,,{STR0261}) //"Abandone este apontamento pelo APP Minha Produção antes de excluir esta OP."
			EndIf
			lRet := .F.
		EndIf

		(cAlias)->(DbCloseArea())
	EndIf

Return lRet

/*/{Protheus.doc} atuIniCom
Atualiza a data de inicio da solicitação de compra.
@type  Static Function
@author Lucas Fagundes
@since 13/01/2025
@version P12
@return Nil
/*/
Static Function atuIniCom()
	Local aArea := {}

	If _lAtuIniSC == Nil
		_lAtuIniSC := FindFunction("getIniTime")
	EndIf

	If _lAtuIniSC
		aArea := SB1->(GetArea())

		SB1->(dbSetOrder(1))
		If SB1->(dbSeek(xFilial("SB1")+SC1->C1_PRODUTO))
			SC1->C1_DINICOM := getIniTime(SC2->C2_DATPRI)
		EndIf

		SB1->(RestArea(aArea))
	EndIf

Return Nil

//-------------------------------------------------------------------
/*/{Protheus.doc} aPesqFor(cProduto)
Pesquisa fornecedor e loja padrão (SB1)
@author Vivian Beatriz de Almeida
@since 21/03/2025
@version P12
@param  cProduto - Código do produto para pesquisa do fornecedor padrão
@return {cCodFor,cLojFor} - código do fornecedor, código da loja
/*/
//-------------------------------------------------------------------
Static Function aPesqFor(cProduto)
Local cCodFor	:= ""
Local cLojFor	:= ""

If SB1->(dbSeek(xFilial("SB1")+cProduto))
	If !Empty(SB1->B1_PROC)
		cCodFor := SB1->B1_PROC
		cLojFor := SB1->B1_LOJPROC
	EndIf
EndIf

Return {cCodFor,cLojFor}
