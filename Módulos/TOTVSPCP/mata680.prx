#INCLUDE "MATA680.CH"
#INCLUDE "FWMVCDEF.CH"
#INCLUDE "TOTVS.CH"

Static _lDicCRP := Nil
Static _lNewMRP := Nil
Static _lVeHora := .F.
Static cA240End := Nil
Static cA680Ser := Nil

/*
эээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©╠╠
╠╠ЁDescri┤ao Ё PLANO DE MELHORIA CONTINUA                                 Ё╠╠
╠╠цддддддддддеддддддддддддддддддддддддддбддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁITEM PMC  Ё Responsavel              Ё Data                            Ё╠╠
╠╠цддддддддддеддддддддддддддддддддддддддеддддддддддддддддддддддддддддддддд╢╠╠
╠╠Ё      01  ЁErike Yuri da Silva       Ё21/03/2006 - Bops:00000094455    Ё╠╠
╠╠Ё      02  ЁFlavio Luiz Vicco         Ё10/01/2006                       Ё╠╠
╠╠Ё      03  ЁErike Yuri da Silva       Ё21/03/2006 - Bops:00000094455    Ё╠╠
╠╠Ё      04  ЁErike Yuri da Silva       Ё27/02/2006 - Bops:00000093416    Ё╠╠
╠╠Ё      05  ЁErike Yuri da Silva       Ё07/06/2006 - Bops:00000100359    Ё╠╠
╠╠Ё      06  ЁErike Yuri da Silva       Ё07/06/2006 - Bops:00000100359    Ё╠╠
╠╠Ё      07  ЁErike Yuri da Silva       Ё27/02/2006 - Bops:00000093416    Ё╠╠
╠╠Ё      08  ЁErike Yuri da Silva       Ё17/02/2006 - Bops:00000093082    Ё╠╠
╠╠Ё      09  ЁErike Yuri da Silva       Ё17/02/2006 - Bops:00000093082    Ё╠╠
╠╠Ё      10  ЁFlavio Luiz Vicco         Ё10/01/2006                       Ё╠╠
╠╠юддддддддддаддддддддддддддддддддддддддаддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ
эээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддбдддддддбддддддддддддддддддддддддбддддддбддддддддд©╠╠
╠╠ЁFun┤┘o    Ё MATA680  Ё Autor Ё Ary Medeiros           Ё Data Ё 10/02/92Ё╠╠
╠╠цддддддддддеддддддддддадддддддаддддддддддддддддддддддддаддддддаддддддддд╢╠╠
╠╠ЁDescri┤┘o Ё Programa de atualizacao do movimento de producao           Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁSintaxe   Ё Void MATA680(void)                                         Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁUso       Ё Generico                                                   Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ
*/
Function MATA680(aRotAuto,nOpcx)
LOCAL lContinua:= .T.
LOCAL lA680Cpos:=ExistBlock("A680CPO")
LOCAL aBackAcho:={}
LOCAL lMVpar   := IIF (( aRotAuto <> NIL ),IsInCallStack("ACDV023") .or. IsInCallStack("ACDA080") .or. IsInCallStack("ACDV025"),.F.)
Local cApend  := ""
//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
//Ё Variaveis utilizadas no sistema.                             Ё
//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
PRIVATE lProdAut := .F.
//зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
//Ё Variaveis utilizadas para indicar qual apontamento esta sendo utilizado Ё
//юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
PRIVATE l680:=.T.,l681:=.F.,l682:=.F.,l250 := .F.,l240 := .F.,l241 := .F.

//зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
//Ё Variavel utilizada para verificar a data do ultimo fechamento           Ё
//юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
PRIVATE dDataFec := MVUlmes()

//зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
//Ё Variaveis utilizadas nos pontos de entrada do MATA250                   Ё
//юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
PRIVATE lSD3250IT:= (ExistTemplate("SD3250I"))
PRIVATE lSD3250I := (ExistBlock("SD3250I"))
PRIVATE lSD3250E := (ExistBlock("SD3250E"))
PRIVATE nOpcAuto := nOpcx
Private l680Auto := ( aRotAuto <> NIL )
Private l681Auto := .F.

//variaveis utilizadas na Integracao QIP x PCP
PRIVATE aJustif := {} //Mensagens para Justificativa para Insp./Certif.
PRIVATE cRevi   := "" //Revisфo vigente do Produto na Data Produ┤фo
PRIVATE aEnsInsp:= {} //Array que contem os ensaios inspec. pelo skip-teste
Private nFCICalc:= SuperGetMV("MV_FCICALC",.F.,0)

//зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
//Ё Array com os campos que devem aparecer na Enchoice                      Ё
//юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
PRIVATE aAcho:={}

//здддддддддддддддддддддддддддддддддддддддддддддд©
//ЁArray para o controle contАbil de correlativosЁ
//юдддддддддддддддддддддддддддддддддддддддддддддды
Private aCtbDia	 := {}

Private lExistePM   := .F. //Indica se existe produГЦo a maior para permitir requisitar quando o empenho estiver zerado

Private nQntPerd	:= 0
Private nQntProd	:= 0

dbSetOrder(1)
dbSelectArea("SX3")
dbSeek("SH6")
While !Eof() .And. (x3_arquivo == "SH6")
	If X3USO(x3_usado) .And. !(AllTrim(x3_campo) == "H6_MOTIVO") .And. !(AllTrim(x3_campo) == "H6_DESCRI") .And. !(AllTrim(x3_campo) == "H6_OBSERVA") .And. If(AllTrim(x3_campo) == "H6_PERIMP",If(nFCICalc==1,.T.,.F.),.T.)
		AADD(aAcho,AllTrim(x3_campo))
	EndIf
	dbSkip()
End

//зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
//Ё Executa P.E. para selecionar campos que devem aparecer na Enchoice      Ё
//юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
If lA680Cpos
	aBackAcho:=ACLONE(aAcho)
	aAcho:=ExecBlock("A680CPO",.F.,.F.,aAcho)
	If Valtype(aAcho) != "A"
		aAcho:=ACLONE(aBackAcho)
	EndIf
EndIf

//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
//Ё Variaveis utilizadas no Apontamento de Refugo por Motivo     Ё
//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
PRIVATE lSavePerda:=.F.
PRIVATE aPerda  := {},aHdPerda := {}
PRIVATE nPosQuant,nPosMot,nPosDesc,nPosTipo,nPosCod,nPosLoc,nPosLote
PRIVATE aAC := {STR0068,STR0069} //"Abandona"###"Confirma"

//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
//Ё Define Array contendo as Rotinas a executar do programa  Ё
//Ё ----------- Elementos contidos por dimensao -----------  Ё
//Ё 1. Nome a aparecer no cabecalho                          Ё
//Ё 2. Nome da Rotina associada                              Ё
//Ё 3. Usado pela rotina                                     Ё
//Ё 4. Tipo de Transa┤└o a ser efetuada                      Ё
//Ё    1 - Pesquisa e Posiciona em um Banco de Dados         Ё
//Ё    2 - Simplesmente Mostra os Campos                     Ё
//Ё    3 - Inclui registros no Bancos de Dados               Ё
//Ё    4 - Altera o registro corrente                        Ё
//Ё    5 - Remove o registro corrente do Banco de Dados      Ё
//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
PRIVATE aRotina := MenuDef()

//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
//Ё Define o cabecalho da tela de atualizacoes               Ё
//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
PRIVATE cCadastro := OemToAnsi(STR0006)	//"Produ┤└o PCP Mod1"

//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
//Ё Pega a variavel que identifica se o calculo do custo e' :    Ё
//Ё               O = On-Line                                    Ё
//Ё               M = Mensal                                     Ё
//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
PRIVATE cCusMed := GetMv("MV_CUSMED")

//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
//Ё lPerdInf: Indica se a perda e informativa ou nao    		 Ё
//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
PRIVATE lPerdInf := SuperGetMV("MV_PERDINF",.F.,.F.)

If cCusMed == "O"
	PRIVATE nHdlPrv // Endereco do arquivo de contra prova dos lanctos cont.
	PRIVATE lCriaHeader := .T. // Para criar o header do arquivo Contra Prova
	PRIVATE cLoteEst  // Numero do lote para lancamentos do estoque
	//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	//Ё Posiciona numero do Lote para Lancamentos do Faturamento     Ё
	//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
	dbSelectArea("SX5")
	dbSeek(xFilial("SX5")+"09EST")
	cLoteEst:=IIF(Found(),Trim(X5Descri()),"EST ")
	PRIVATE nTotal := 0  // Total dos lancamentos contabeis
	PRIVATE cArquivo  // Nome do arquivo contra prova
EndIf

//APT.PENDENTE
PRIVATE cPCPPEND   := "1"
PRIVATE lAptPende  := .F.
PRIVATE lGravaPen  := .F.
Private nPosGrv	   := 0
Private cMsgErro   := ""

//зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
//Ё Abaixo checa se executado procedimento "TimeH6x" para ajuste de campos hora do SH6  Ё
//юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды

If ! A680ChkH6Time()
	lContinua := .F.
EndIf

If lContinua
	ASHICalen(,,, .T.)

	//зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	//Ё Inclui pergunta no SX1                                        Ё
	//юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
	Pergunte("MTA680",.F.)
    IIF (lMVpar,MV_PAR04 := 1 , Nil)

	If ! l680Auto

		//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		//Ё Inicializa perguntas deste programa                          Ё
		//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
		//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		//Ё mv_par01 - Se mostra e permite digitar lancamentos contabeis   Ё
		//Ё mv_par02 - Se deve aglutinar os lancamentos contabeis          Ё
		//Ё mv_par03 - Tempo do Apontamento (1) Normal (2) Centesimal      Ё
		//Ё mv_par04 - Permite somente apontamento Tempo (1) Sim (2) Nao   Ё
		//Ё mv_par05 - Verifica saldo em cada apontamento(1) Sim (2) Nao   Ё
		//Ё mv_par06 - Na req. da MOD grava CC da mod / CC da OP           Ё
		//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
		//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		//Ё Ativa tecla F12 para acionar perguntas                         Ё
		//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
		Set Key VK_F12 To FAtiva()
	EndIf

	//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	//Ё Endereca a funcao de BROWSE                              Ё
	//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
	If l680Auto
		//APT.PENDENTE
		PRIVATE aCloneAuto := aclone(aRotAuto)

		//Verifica se vem do ACDA080
		IF lMVpar // IsInCallStack('ACDA080') .AND.  IsInCallStack('CB023GRV')
			cApend := SuperGetMV("MV_APTPEND",.F.,"1")
			AADD(aRotAuto,{"PENDENTE",cApend ,NIL} )
		EndIf

		nPosRotOr := aScan(aRotAuto,{|x| x[1] == "PENDENTE"}) //Verifica Tag no Apontamento
		IF nPosRotOr > 0
			lAptPende := .T.
			cPCPPEND  :=  aRotAuto[nPosRotOr][2] // Posicione("T4L",1,xFilial("T4L")+aRotAuto[nPosRotOr][2],"T4L_DADO")
		EndIf
		lMsErroAuto := .F.
		MsRotAuto(nOpcx,aRotAuto,"SH6",aAcho)

		//APT.PENDENTE
		If  lMSErroAuto .And. ! lGravaPen .AND. ! lMVpar // Se Tiver erros na Rotina MsRotAuto o retorno И verdadeiro
			IF l680Auto .AND. cPCPPEND <> "1"   //grava as pendЙncias de apontamento para serem processadas posteriormente
				IF TableInDic("T4K")
					IF cPCPPEND # "4" // Quando for reprocessa, nЦo precissa gravar na tabelas
						IF FindFunction("ErrosApt")
							cMsgErro	:= ErrosApt()
						EndIF
						a250GrvPnd(aCloneAuto,"MATA680",cMsgErro)
						lGravaPen	:= .T. // Sinaliza que jА gravou o pedido com pendente
					EndIf
				EndIf
			EndIf
		Endif
	Else
		MBrowse( 6, 1,22,75,"SH6")
	EndIf
EndIf
dbSelectArea("SH8")
dbCloseArea()
dbSelectArea("SC2")

dbSelectArea("SC2")

//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
//Ё Desativa tecla que aciona perguntas                            Ё
//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
Set Key VK_F12 TO

Return

/*
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤┘o    ЁA680VisualЁ Autor Ё Rodrigo de A. SartorioЁ Data Ё 11/07/97 Ё╠╠
╠╠цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤┘o Ё Programa para visualizar apontamento de producao           Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁSintaxe   Ё A680Visual(ExpC1,ExpN1,ExpN2)                              Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁParametrosЁ ExpC1 = Alias do arquivo                                   Ё╠╠
╠╠Ё          Ё ExpN1 = Numero do registro                                 Ё╠╠
╠╠Ё          Ё ExpN2 = Numero da opcao selecionada                        Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠Ё Uso      Ё MATA680                                                    Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ
*/
Function A680Visual(cAlias,nReg,nOpc)
Local aButtons   := {}
Local aUsButtons := {}

dbSelectArea(cAlias)
If H6_TIPO == "I"
	Help(" ",1,"A680NAO")
Else
	//зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	//Ё Ponto de entrada p/ adicionar botoes de usuario na EnchoiceBarЁ
	//юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
	If ExistBlock( "MA680BUT" )
		If ValType( aUsButtons := ExecBlock( "MA680BUT", .F., .F.,{nOpc} ) ) == "A"
			AEval( aUsButtons, { |x| AAdd( aButtons, x ) } )
		EndIf
	EndIf
	AxVisual(cAlias,nReg,nOpc,aAcho,,,"A680MEMVAR",aButtons)
EndIf
Return

/*
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤┘o    ЁA680MemVarЁ Autor Ё Marcelo Iuspa         Ё Data Ё 02/10/01 Ё╠╠
╠╠цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤┘o Ё Funcao para tratar variaveis de memoria na Enchoice        Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁSintaxe   Ё A680MemVar                                                 Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠Ё Uso      Ё MATA680/MATA681                                            Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ
*/
Function A680MemVar
// mv_par03 - Tempo do Apontamento (1) Normal (2) Centesimal
Return

/*
ээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддбдддддддбддддддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤┘o    ЁA680IncluiЁ Autor Ё Ary Medeiros           Ё Data Ё 10/02/92 Ё╠╠
╠╠цддддддддддеддддддддддадддддддаддддддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤┘o Ё Programa de inclusao do movimento de estoque                Ё╠╠
╠╠цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁSintaxe   Ё Void A680Inclui(cExp1,nExp1,nExp2)                          Ё╠╠
╠╠цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁParametrosЁ cExp1 = Alias do Arquivo                                    Ё╠╠
╠╠Ё          Ё nExp1 = Numero do registro                                  Ё╠╠
╠╠Ё          Ё cExp1 = Opcao escolhida                                     Ё╠╠
╠╠Ё          Ё cExp4 = Se e via coletor de dados                           Ё╠╠
╠╠цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁUso       Ё MATA680                                                     Ё╠╠
╠╠юддддддддддаддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ
*/
Function A680Inclui(cAlias,nReg,nOpc,aCpos,lColetor)
Local nOpca		 := 0
Local lEncerraOP :=.F.
Local lContinua  := .T.
Local lIsLockSH8 := .F.
Local aBaixaSGF  := Nil
Local aChkBaixaC := Nil
Local lGeraD3Pro := .F.
Local aAreaSD3	 := {}
Local aButtons   := {}
Local aUsButtons := {}
Local aPedidos	 := {}
Local nX		 := 0
Local cDocSD3	 := ""
Local nPercPrM	 := 0
Local lDISTMOV   := SuperGetMV("MV_DISTMOV",.F.,.F.)
Local lEncerOp   := SuperGetMV("MV_ACDOPPT",.F.,.F.)
Local aDigLot    := {}
Local lWmsNew    := SuperGetMv("MV_WMSNEW",.F.,.F.)
LOCAL lMVpar     := IIF (( l680Auto <> NIL ),IsInCallStack("ACDV023") .or. IsInCallStack("ACDA080") .or. IsInCallStack("ACDV025"),.F.)
Local lRet       := .T.

Local lDelTBMRP   := _lNewMRP == NIL
Local lIntNewMRP  := Iif(_lNewMRP == Nil, FindFunction("Ma650MrpOn") .AND. Ma650MrpOn(@_lNewMRP),_lNewMRP)
Local aMRPxJson   := Iif(lIntNewMRP, {{}, JsonObject():New()}, Nil) //{aDados para commit, JsonObject() com RECNOS} - Integracao Novo MRP

PRIVATE lModZero   := .T.
PRIVATE lRollWMS := .F.  //Variavel utilizada para rollback quando existir validaГЦo wms

If lColetor == NIL
	lColetor := .F.
EndIf

PRIVATE nRegD3
PRIVATE lEnvCQProd := .F.
PRIVATE cLocCQOrig := ""

CriaStatic()

//--Verifica se o SH8 estava locado (exclusivo) para outro processo
If (lIsLockSH8 := IsLockSH8())
	lContinua := .F.
EndIf

//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
//Ё Impede Inclus■es com Data Inferior ou Igual a do Fechamento  Ё
//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
If lContinua .And. dDataBase <= dDataFec
	Help (' ', 1, 'FECHTO')
	lContinua := .F.
EndIf

If lContinua
	//зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	//Ё Inicializa a gravacao dos lancamentos do SIGAPCO          Ё
	//юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
	PcoIniLan("000152")

	ASHICalen(,,,.T.)

	Begin Transaction
		If ! lColetor
			If ( l680Auto )
				nOpca := AxIncluiAuto(cAlias,"A680TudoOk()","A680AtuInc()")
				//APT.PENDENTE
				if nOpca = 0
                    aAdd(aRotAuto,{"GRAVA","4",NIL})
                Endif
			Else
				//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				//Ё Ativa a tecla F4.                                            Ё
				//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
				Set Key VK_F4 TO A680ShowF4()

				//зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				//Ё Ponto de entrada p/ adicionar botoes de usuario na EnchoiceBarЁ
				//юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
				If ExistBlock( "MA680BUT" )
					If ValType( aUsButtons := ExecBlock( "MA680BUT", .F., .F.,{nOpc} ) ) == "A"
						AEval( aUsButtons, { |x| AAdd( aButtons, x ) } )
					EndIf
				EndIf
				nOpca := AxInclui(cAlias,nReg,nOpc,aAcho,,,"A680TudoOk()",,"A680AtuInc()",aButtons)
			EndIf
			//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			//Ё Desativa a tecla F4.                                         Ё
			//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
			Set Key VK_F4 To

		Else
			nOpca := 1
			A680TudoOk()
		EndIf

		If nOpca == 1
			//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			//Ё Verifica se o custo medio e' calculado On-Line               Ё
			//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
			If cCusMed == "O" .And. lCriaHeader
				lCriaHeader := .F.
				nHdlPrv := HeadProva(cLoteEst,"MATA250",Subs(cUsuario,7,6),@cArquivo)
			EndIf

			//здддддддддддддддддддддддддддддддддддддддддддддддддддд©
			//Ё Envia p/func. de atualizacoes (SD3,SB2,SB3,SC2,..) Ё
			//юдддддддддддддддддддддддддддддддддддддддддддддддддддды
			If A680GeraD3("MOD",SH6->H6_IDENT)
				A240Atu()
			EndIf
			If lModZero
				dbSelectArea("SH6")
				If SH6->H6_QTDPROD > 0 .Or. SH6->H6_QTDPERD > 0
					//здддддддддддддддддддддддддддддддддддддддддддддддддддд©
					//Ё Busco por componentes a serem baixados na operacao Ё
					//Ё apontada                                           Ё
					//юдддддддддддддддддддддддддддддддддддддддддддддддддддды
					aBaixaSGF := A637BxComp(SH6->H6_PRODUTO, A680RotPad(), SH6->H6_OPERAC, SH6->H6_OP)
					//здддддддддддддддддддддддддддддддддддддддддддддддддддд©
					//Ё Checa se existe amarracao operacao x componente e  Ё
					//Ё se ja foi baixado o saldo empenhado para nao atualiЁ
					//Ё zar novamente saldo empenhado.                     Ё
					//юдддддддддддддддддддддддддддддддддддддддддддддддддддды
					aChkBaixaC := A680CkCmpP(SH6->H6_PRODUTO,SH6->H6_OPERAC,SH6->H6_OP)
					//здддддддддддддддддддддддддддддддддддддддддддддддддддд©
					//Ё Caso a perda nesta operacao seja total, verifica seЁ
					//Ё deve encerrar a OP ou nao.                         Ё
					//юдддддддддддддддддддддддддддддддддддддддддддддддддддды
					lEncerraOP:=.F.
					If SH6->H6_PT == "T" .And. QtdComp(SH6->H6_QTDPROD) == QtdComp(0) .And. QtdComp(SH6->H6_QTDPERD) > QtdComp(0)
						If lEncerOp .And. (IsInCallStack("ACDV025") .Or.  IsInCallStack("ACDV023") .or. IsInCallStack("ACDA080")) .And. SH6->(A681ACDPT(H6_OP,H6_PRODUTO,H6_OPERAC))
							lEncerraOp := lEncerOp
						ElseIf l680Auto
							lEncerraOp:=.F.
						Else
							lEncerraOP:= Aviso(STR0024,STR0060,{STR0026,STR0027}) == 1 //"Aten┤└o"###"Este apontamento indica PERDA TOTAL da OP. Encerra Produ┤└o da OP nesta opera┤└o ?"###"Sim"###"N└o"
						EndIf
					EndIf

					SC2->(dbSetOrder(1))
					If SC2->(dbSeek(xFilial("SC2")+SH6->H6_OP))
						nPercPrM := (SH6->H6_QTMAIOR / SC2->C2_QUANT) //Calcula o percentual excedente da produГЦo
					EndIf

					If A680UltOper() .Or. lEncerraOP
						lGeraD3Pro := .T.
						A680GeraD3("PR0",SH6->H6_IDENT)

						If SH6->H6_PT == "T"
							aChkBaixaC := NIL
						EndIf

						lRollWMS := .F.
						lRet :=	A250Atu(cAlias,SH6->H6_IDENT,@aPedidos,,,,,,,,,aChkBaixaC,,,nPercPrM,Nil,Nil,@aMRPxJson)
						If !lRet .OR. lRollWMS
							If InTransact()
								disarmTransaction()
							EndIf
						EndIf

						//APT.PENDENTE
						IF ! lRet .AND. Type("aRotAuto") == "A"
							aAdd(aRotAuto,{'GRAVA',"2",NIL})
						EndIf

						If lRet
							If lSavePerda
								lSavePerda := A680GrPerd(lGeraD3Pro,@aPerda,@aHdPerda,SH6->H6_IDENT)
							EndIf
						EndIf
					ElseIf aBaixaSGF # Nil

						cDocSD3 := CriaVar("D3_DOC")

						lRollWMS := .F.
						lRet := A250Atu(cAlias, SH6->H6_IDENT,,,aBaixaSGF, SH6->H6_QTDPROD, SH6->H6_QTDPERD, SH6->H6_OP, If(Empty(cDocSD3),SC2->C2_NUM,cDocSD3), SH6->H6_DTAPONT, SH6->H6_PT, aChkBaixaC,,,nPercPrM,Nil,Nil,@aMRPxJson)
						If !lRet .Or. lRollWMS
							If InTransact()
								disarmTransaction()
							EndIf
						EndIf

						//APT.PENDENTE
						IF ! lRet .AND. Type("aRotAuto") == "A"
							aAdd(aRotAuto,{'GRAVA',"2",NIL})
						EndIf

						If lRet
							If lSavePerda
								lSavePerda := A680GrPerd(lGeraD3Pro,@aPerda,@aHdPerda)
							EndIf
						EndIf
					EndIf

					If lRet
						If !lWmsNew
							//зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
							//Ё Abre uma tela que permito ao usuАrio endereГar os produtos  Ё
							//юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
							If Localiza(SH6->H6_PRODUTO) .And. lDISTMOV
								aADD(aDigLot,{	'0001',;
									SD3->D3_COD,;
									SD3->D3_LOCAL,;
									SD3->D3_LOTECTL,;
									SD3->D3_NUMLOTE,;
									SD3->D3_DTVALID,;
									SD3->D3_QUANT,;
									SD3->D3_NUMSEQ,;
									SD3->D3_DOC,;
									SerieNfId("SD1",5,"D1_SERIE"),;
									CriaVar("D1_FORNECE"),;
									CriaVar("D1_LOJA"),;
									.F.	 })
								A103DigEnd(aDigLot)
							EndIf
						Else
							If IntWms(SD3->D3_COD) .And. A680UltOper()
								// IntegraГЦo apontamento ordem de produГЦo com WMS
								WmsIntOp(SD3->(Recno()),cA240End,cA680Ser)
							EndIf
						EndIf
					EndIf

					If lRet
						//здддддддддддддддддддддддддддддддддддддддддддддддддддд©
						//Ё Caso tenha liberado pedidos atraves da producao,   Ё
						//Ё atualiza campo no SC5                              Ё
						//юдддддддддддддддддддддддддддддддддддддддддддддддддддды
						If Len(aPedidos) > 0
							MaLiberOk(aPedidos)
						EndIf
						A250Nutri(SH6->H6_OP)

						If lSavePerda
							If lGeraD3Pro
								aAreaSD3 := SD3->(GetArea())
								dbSelectArea("SD3")
								dbSetOrder(1)
								dbSeek(xFilial("SD3")+SH6->H6_OP+SH6->H6_PRODUTO)
								While SD3->(!EOF()) .And. xFilial("SD3")+SH6->(H6_OP+H6_PRODUTO) == SD3->(D3_FILIAL+D3_OP+D3_COD)
									If SD3->D3_IDENT == SH6->H6_IDENT .And. SD3->D3_CF == "PR0" .And. SD3->D3_ESTORNO <> "S"
										GravaSBC(SH6->H6_OP,SH6->H6_OPERAC,SH6->H6_RECURSO,"MATA680",SD3->D3_NUMSEQ,SH6->H6_IDENT)
										Exit
									EndIf
									SD3->(dbSkip())
								EndDo
								RestArea(aAreaSD3)
							Else
								GravaSBC(SH6->H6_OP,SH6->H6_OPERAC,SH6->H6_RECURSO,"MATA680",,SH6->H6_IDENT)
							EndIf
							aPerda:={}
							aHdPerda:={}
							lSavePerda:=.F.
						EndIf
					EndIf

					//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
					//Ё Verifica se existe integracao com o QIP no apontamento das Producoes Ё
					//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
					If lRet
						If A680UltOper() .Or. lEncerraOP
							If IntQIP(SH6->H6_PRODUTO,"2")
								QIPAtualiza("SH6",1)
							EndIf
						EndIf
					EndIf
				EndIf
			EndIf

			//APT.PENDENTE
			IF l680Auto
				nPosGrv:= aScan(aRotAuto,{|x| x[1] == "GRAVA"})
				IF cPCPPEND <> '1' .AND. nPosGrv >0  //grava as pendЙncias de apontamento para serem processadas posteriormente

					lMsErroAuto := .T.

					IF nPosGrv > 0
						IF aRotAuto[nPosGrv,2] == "2"
							AutoGrLog(STR0115) //"O Registro do arquivo SB2 encontra-se Bloqueado por outro UsuАrio!! "
						ENDIF
					ENDIF

					IF cPcpPend == "3" // Todos apontamentos entram como pendentes
						cMsgErro	:=  STR0116 //"3 - Grava todos apontamentos como pendentes	"
						AutoGrLog(STR0116)
					Endif

					aPerda		:={}
					aHdPerda	:={}
					lSavePerda	:=.F.

					If InTransact()
						disarmTransaction()
					EndIf

					IF TableInDic("T4K") .AND. ! lMVpar
						IF cPCPPEND # "4" // Quando for reprocessa, nЦo precissa gravar na tabelas
							IF FindFunction("ErrosApt")
								IF cPcpPend # "3"
									cMsgErro	:= ErrosApt()
								ENDIF
							EndIF
							a250GrvPnd(aCloneAuto,STR0117,cMsgErro) //MATA680
							lGravaPen	:= .T. // Sinaliza que jА gravou o pedido com pendente
						EndIf
					EndIf

					lRet := .F.
				EndIf
			ENDIF

		EndIf
	End Transaction

	If !lRet
		Return
	EndIf

	//APT.PENDENTE
	IF l680Auto
		If nPosGrv = 0
			nPosGrv:= aScan(aRotAuto,{|x| x[1] == "GRAVA"})
		Endif

		IF cPCPPEND <> '1' .AND. nPosGrv > 0  //grava as pendЙncias de apontamento para serem processadas posteriormente

			lMsErroAuto := .T.
			IF nPosGrv > 0
				IF aRotAuto[nPosGrv,2] == "2"
					AutoGrLog(STR0115) //"O Registro do arquivo SB2 encontra-se Bloqueado por outro UsuАrio!! "
				ENDIF
			ENDIF

			IF cPcpPend == "3" // Todos apontamentos entram como pendentes
				cMsgErro	:=  STR0116 //"3 - Grava todos apontamentos como pendentes	"
				AutoGrLog(STR0116)
			Endif

			aPerda		:={}
			aHdPerda	:={}
			lSavePerda	:=.F.

			IF TableInDic("T4K") .AND. ! lMVpar
				IF cPCPPEND # "4" // Quando for reprocessa, nЦo precissa gravar na tabelas
					IF FindFunction("ErrosApt")
						IF cPcpPend # "3"
							cMsgErro	:= ErrosApt()
						ENDIF
					EndIF
					a250GrvPnd(aCloneAuto,STR0117,cMsgErro) //MATA680
					lGravaPen	:= .T. // Sinaliza que jА gravou o pedido com pendente
				EndIf
			EndIf

			Return
		EndIf
	ENDIF

	//-- Integrado ao wms devera avaliar as regras para convocacao do servico e disponibilizar os
	//-- registros do SDB para convocacao, ou exibir as mensagens de erro WMS caso necessАrio
	If nOpca == 1 .And. IntWms() .And. A680UltOper()
		WmsExeServ()
	EndIf

	If nOpca <> 1
		//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		//Ё Verifica se o custo medio e' calculado On-Line               Ё
		//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
		If cCusMed == "O"
			If !lCriaHeader

				lDigita   := Iif(mv_par01 == 1,.T.,.F.)
				lAglutina := Iif(mv_par02 == 1,.T.,.F.)
				//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				//Ё Se ele criou o arquivo de prova ele deve gravar o rodape'    Ё
				//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
				RodaProva(nHdlPrv,nTotal)

				//зддддддддддддддддддддддддддд©
				//ЁAtualiza o cСdigo de diАrioЁ
				//юддддддддддддддддддддддддддды
				If !Empty(aCtbDia)
					cCodDiario := CtbaVerdia()
					For nX := 1 to Len(aCtbDia)
						aCtbDia[nX][3] := cCodDiario
					Next nX
				EndIf

				cA100Incl(cArquivo,nHdlPrv,3,cLoteEst,lDigita,lAglutina,,,,,,aCtbDia)
				lCriaHeader := .T.
				KeyBoard Chr(27)
			EndIf
		EndIf
	EndIf

	If SH6->H6_PT == "T"
		//Remove lock aplicado na A680TudoOk
		UnLockByName("ENCOP"+SH6->(H6_OP+H6_OPERAC),.T.,.T.,.T.)
	EndIf

	If Existblock("MA680INC")
		Execblock("MA680INC",.F.,.F.,{nOpca})
	EndIf

	aPerda:={}
	aHdPerda:={}
	lSavePerda:=.F.

	//зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	//Ё Finaliza a gravacao dos lancamentos do SIGAPCO            Ё
	//юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
	PcoFinLan("000152")
EndIf

If lIntNewMRP
	//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	//Ё Chama integraГЦo com novo MRP                                Ё
	//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
	If Len(aMRPxJson[1]) > 0
		MATA650INT("INSERT", aMRPxJson[1])
	EndIf
	aSize(aMRPxJson[1], 0)
	FreeObj(aMRPxJson[2])
	aMRPxJson[2] := Nil
	If lDelTBMRP
		_lNewMRP := Nil
	EndIf
EndIf

Return

/*
ээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддбдддддддбддддддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤┘o    ЁA680AlteraЁ Autor Ё Rodrigo de A Sartorio  Ё Data Ё 05/06/03 Ё╠╠
╠╠цддддддддддеддддддддддадддддддаддддддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤┘o Ё Programa de apontamento de horas apos encerramento          Ё╠╠
╠╠цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁSintaxe   Ё Void A680Altera(cExp1,nExp1,nExp2)                          Ё╠╠
╠╠цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁParametrosЁ cExp1 = Alias do Arquivo                                    Ё╠╠
╠╠Ё          Ё nExp1 = Numero do registro                                  Ё╠╠
╠╠Ё          Ё cExp1 = Opcao escolhida                                     Ё╠╠
╠╠Ё          Ё cExp4 = Se e via coletor de dados                           Ё╠╠
╠╠цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁUso       Ё MATA680                                                     Ё╠╠
╠╠юддддддддддаддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ
*/
Function A680Altera(cAlias,nReg,nOpc,aCpos,lColetor)
	Local nOpca
	Local lEncerraOP	:= .F.
	Local lIntSFC	:= IntegraSFC() .And. !IsInCallStack("AUTO681")
	Local lMA680HRT	:= Existblock("MA680HRT")
	Local lMt680Can	:= Existblock("MT680CAN")
	Local lContinua	:= .T.
	Local lIsLockSH8	:= .F.
	Local aButtons	:= {}
	Local aUsButtons	:= {}
	Local aCpsAlter	:= {"H6_DATAINI","H6_HORAINI","H6_DATAFIN","H6_HORAFIN","H6_DTAPONT","H6_TEMPO"}
	Local a680CPHR	:= nil
	Local nI			:= 0
	Local nX			:= 0

	PRIVATE lModZero:= .T.

	If lColetor == NIL
		lColetor := .F.
	EndIf

	PRIVATE nRegD3

	//--Abre semaforo para SH8
	If (lIsLockSH8 := IsLockSH8())
		lContinua := .F.
	EndIf

	//-- Impede alteracao de OP integrada ao Chao de Fabrica
	If lContinua .And. lIntSFC
		CYQ->(dbSetOrder(1))
		lContinua:= !CYQ->(dbSeek(xFilial("CYQ")+SH6->H6_OP))
		If !lContinua
			Aviso("AtenГЦo","Esta OP И movimentada somente atravИs do mСdulo ChЦo de FАbrica.",{"OK"})
		EndIf
	EndIf

	//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	//Ё Impede Inclus■es com Data Inferior ou Igual a do Fechamento  Ё
	//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
	If lContinua .And. dDataBase <= dDataFec
		Help (' ', 1, 'FECHTO')
		lContinua := .F.
	EndIf

	If lContinua
		Begin Transaction
			If ! lColetor
				If (l680 .And. l680Auto ) .Or. (l681 .And. l681Auto )
					nOpca := AxIncluiAuto(cAlias,"A680TudoOk()","A680AtuInc(.F.)")
				Else
					//зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
					//Ё Ponto de entrada p/ adicionar botoes de usuario na EnchoiceBarЁ
					//юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
					If ExistBlock( "MA680BUT" )
						If ValType( aUsButtons := ExecBlock( "MA680BUT", .F., .F.,{nOpc} ) ) == "A"
							AEval( aUsButtons, { |x| AAdd( aButtons, x ) } )
						EndIf
					EndIf
					//зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
					//Ё Ponto de entrada p/ adicionar campos de usuario na AxInclui	  Ё
					//юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
					If ExistBlock("MA680CPHR")
						a680CPHR := ExecBlock("MA680CPHR",.F.,.F.)
						If (ValType(a680CPHR) == "A")
							For nI:=1 to Len(a680CPHR)
								dbSelectArea("SX3")
								dbSetOrder(2)
								If dbSeek(a680CPHR[nI]) //checa existencia para evitar error.log
									If SX3->X3_PROPRI == "U" //verifica se e mesmo de usuario
										aAdd(aCpsAlter,a680CPHR[nI])
									EndIf
								EndIf
							Next nI
						EndIf
					EndIf
					nOpca := AxInclui(cAlias,nReg,nOpc,aAcho,"A680LeReg",aCpsAlter,"A680TudoOk()",,"A680AtuInc(.F.)",aButtons)
				EndIf
				//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				//Ё Desativa a tecla F4.                                         Ё
				//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
				Set Key VK_F4 To
			Else
				nOpca := 1
				A680TudoOk()
			EndIf

			If nOpca == 1
				//здддддддддддддддддддддддддддддддддддддддддддддддддддд©
				//Ё Envia p/func. de atualizacoes (SD3,SB2,SB3,SC2,..) Ё
				//юдддддддддддддддддддддддддддддддддддддддддддддддддддды
				If A680GeraD3("MOD",SH6->H6_IDENT)
					A240Atu()
					//Restaura variavel para recriar o header de contabilizacao corretamente
					lCriaHeader := .T.
				EndIf
			EndIf
		End Transaction

		If nOpca == 1
			If lMA680HRT
				Execblock("MA680HRT",.f.,.f.)
			EndIf
		Else
			//зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			//Ё Ponto de Entrada apСs acionar o botЦo cancelar no Apontamento de Producao mod2Ё
			//юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
			If lMt680Can
				Execblock("MT680CAN",.F.,.F.)
			Endif
			//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			//Ё Verifica se o custo medio e' calculado On-Line               Ё
			//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
			If cCusMed == "O"
				If !lCriaHeader
					lDigita   := Iif(mv_par01 == 1,.T.,.F.)
					lAglutina := Iif(mv_par02 == 1,.T.,.F.)
					//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
					//Ё Se ele criou o arquivo de prova ele deve gravar o rodape'    Ё
					//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
					RodaProva(nHdlPrv,nTotal)
					//зддддддддддддддддддддддддддд©
					//ЁAtualiza o cСdigo de diАrioЁ
					//юддддддддддддддддддддддддддды
					If !Empty(aCtbDia)
						cCodDiario := CtbaVerdia()
						For nX := 1 to Len(aCtbDia)
							aCtbDia[nX][3] := cCodDiario
						Next nX
					EndIf

					cA100Incl(cArquivo,nHdlPrv,3,cLoteEst,lDigita,lAglutina,,,,,,aCtbDia)
					lCriaHeader := .T.
					KeyBoard Chr(27)
				EndIf
			EndIf
		EndIf
	EndIf
Return

/*
ээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддбдддддддбддддддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤┘o    ЁA680DeletaЁ Autor Ё Ary Medeiros           Ё Data Ё 10/02/92 Ё╠╠
╠╠цддддддддддеддддддддддадддддддаддддддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤┘o Ё Programa de exclusao do movimento de estoque                Ё╠╠
╠╠цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁSintaxe   Ё Void A680Deleta(cExp1,nExp1,nExp2)                          Ё╠╠
╠╠цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁParametrosЁ cExp1 = Alias do Arquivo                                    Ё╠╠
╠╠Ё          Ё nExp1 = Numero do registro                                  Ё╠╠
╠╠Ё          Ё cExp1 = Opcao escolhida                                     Ё╠╠
╠╠цддддддддддеддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁUso       Ё MATA680                                                     Ё╠╠
╠╠юддддддддддаддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ
*/
Function A680Deleta(cAlias,nReg,nOpc)
/*
   VariАvel nRegSH6 И utilizada para posicionar no registro correto, quando for realizar o estorno.
   Quando И executado o estorno atravИs de rotina automАtica, a funГЦo MsRotAuto pode desposicionar
   do registro da SH6. Isso ocorre quando existem 2 apontamentos para mesma OP/PRODUTO/OPERACAO/SEQ/DATAINI/HORAINI/DATAFIM/HORAFIM,
   pois dentro da funГЦo MsRotAuto И realizado um seek na tabela SH6, que posiciona na primeira ocorrencia deste indice.
*/
Local lReposic   := Iif(Type("nRegSH6")=="N" .And. nRegSH6 > 0, SH6->(dbGoTo(nRegSH6)), .F.)
//#####################
Local aAreaSC2	 := {}
Local aAreaSD3	 := {}
Local aAreaSD4	 := {}
Local aAreaSH6	 := SH6->(GetArea())
Local aAreaH6	 := SH6->(GetArea())
Local aBaixaSGF  := Nil
Local aButtons   := {}
Local aCtbDia	 := {}
Local aSize      := MsAdvSize()
Local aInfo      := { aSize[1], aSize[2], aSize[3], aSize[4], 3, 3 }
Local lIntNewMRP := Iif(_lNewMRP == Nil, FindFunction("Ma650MrpOn") .AND. Ma650MrpOn(@_lNewMRP),_lNewMRP)
Local aMRPxJson  := Iif(lIntNewMRP, {{}, JsonObject():New()}, Nil) //{aDados para commit, JsonObject() com RECNOS} - Integracao Novo MRP
Local aObjects   := {}
Local aPosObj    := {}
Local aSBCEst	 := {}
Local aTravas	 := {}
Local aUsButtons := {}
Local bCampo 	 := NIL
Local cAliasQry  := GetNextAlias()
Local cEndereco  := ''
Local cEstNeg    := GetMV("MV_ESTNEG")
Local cItem 	 := ""
Local cNumOP 	 := SH6->H6_OP
Local cOP		 := ""
Local cOpeNext   := ""
Local cOperac	 := SH6->H6_OPERAC
Local cProdMOD   := ""
Local cProduto   := SH6->H6_PRODUTO
Local cReqAut    := A250ReqAut(GetMV("MV_REQAUT"))
Local cRoteiro   := ""
Local cSeekSD3   := ""
Local cSeekWhile := ""
Local i			 := 0
Local l250DesAtu := .F.
Local lAponTemp  := IIF(MV_PAR04 == 1 .AND. !Empty(SH6->H6_HORAINI) .AND. !Empty(SH6->H6_HORAFIN) .AND. SH6->H6_QTDPROD == 0 .AND. SH6->H6_QTDPERD == 0,.T.,.F.)
Local lAuto		 := If(l680,l680Auto,l681Auto)
Local lConsReal  := .F.
Local lConsVenc	 := GetMV('MV_LOTVENC')=='S'
Local lContinua  := .T.
Local lDelTBMRP  := _lNewMRP == NIL
Local lEstornP	 := SuperGetMV("MV_ESOPPAR",.F.,.T.)
Local lIntACD	 := SuperGetMV("MV_INTACD",.F.,"0") == "1"
Local lIntSFC	 := IntegraSFC() .And. !IsInCallStack("AUTO681")
Local lModRecPCP := FindFunction('ModRecPCP')
Local lMt680Can  := Existblock("MT680CAN")
Local lOk 		 := .T.
Local lOpEncer	 := .F.
Local lOpeNext   := .F.
Local lProcessa	 := .T.
Local lUltOper	 := A680UltOper()
Local lVldEst    := GetMV("MV_ESTOPE")// Valida se as Operacoes anteriores poderao ser Estornadas
Local lWmsNew    := SuperGetMv("MV_WMSNEW",.F.,.F.)
Local lWMSSaas   := FindFunction("WMSSaasHas") .And. WMSSaasHas()
Local nOpc1		 := 0
Local nOpcA  	 := 0
Local nRecnoTot  := 0
Local nSeek		 := 0
Local nSlAtuH6   := 0
Local nSldEsto   := 0
Local nSlNexH6   := 0
Local nX		 := 0
Local oDlg	 	 := NIL

Private lAbreOP := .T.


If PCPIntgPPI()
	SOE->(dbSeek(xFilial("SOE")+"SC2"))
	If AllTrim(SOE->OE_VAR1) == "2" .Or. AllTrim(SOE->OE_VAR1) == "3"
		lConsReal := .T.
	EndIf
EndIf

AAdd( aObjects, { 100, 100, .T., .T. } )
aPosObj := MsObjSize( aInfo, aObjects, .T.)

//--Abre semaforo para SH8
If (lIsLockSH8 := IsLockSH8())
	lContinua := .F.
EndIf

//здддддддддддддддддддддддддддддддддддддддддддддддддд©
//Ё Ver. se esta' alterando registro da mesma filial Ё
//юдддддддддддддддддддддддддддддддддддддддддддддддддды
If lContinua .And. SH6->H6_FILIAL != xFilial("SH6")
	Help(" ",1,"A000FI")
	lContinua := .F.
EndIf

If lContinua .And. SH6->H6_TIPO == "I"
	Help(" ",1,"A680NAO")
	lContinua := .F.
EndIf

//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
//Ё Impede Dele┤■es com Data Inferior ou Igual a do Fechamento   Ё
//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
If lContinua .And. SH6->H6_DTPROD <= dDataFec
	Help (' ', 1, 'FECHTO')
	lContinua := .F.
EndIf

//-- Impede estorno de OP integrada ao Chao de Fabrica
If lContinua .And. lIntSFC
	CYQ->(dbSetOrder(1))
	lContinua:= !CYQ->(dbSeek(xFilial("CYQ")+SH6->H6_OP))
	If !lContinua
		Aviso("AtenГЦo","Esta OP И movimentada somente atravИs do mСdulo ChЦo de FАbrica.",{"OK"})
	EndIf
EndIf

//зддддддддддддддддддддддддддддддддддддддддддддддддддддд©
//Ё Verifica se o produto est═ sendo inventariado.      Ё
//юддддддддддддддддддддддддддддддддддддддддддддддддддддды
If lContinua
	If !Empty(SH6->H6_LOCAL)
		If BlqInvent(H6_PRODUTO,H6_LOCAL) .AND. !lAponTemp .And. lUltOper
			Help(" ",1,"BLQINVENT",,H6_PRODUTO+" Almox: "+H6_LOCAL,1,11)
			lContinua := .F.
		EndIf
		//зддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		//Ё Analisa se o tipo do armazem permite a movimentacao |
		//юддддддддддддддддддддддддддддддддддддддддддддддддддддды
		If lContinua .And. AvalBlqLoc(H6_PRODUTO,H6_LOCAL,Nil)
			lContinua := .F.
		EndIf
	Else
		SC2->(dbSetOrder(1))
		If SC2->(dbSeek(xFilial("SC2")+SH6->H6_OP))
			If BlqInvent(H6_PRODUTO,SC2->C2_LOCAL) .AND. !lAponTemp .And. lUltOper
				Help(" ",1,"BLQINVENT",,H6_PRODUTO+" Almox: "+SC2->C2_LOCAL,1,11)
				lContinua := .F.
			EndIf
			//зддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			//Ё Analisa se o tipo do armazem permite a movimentacao |
			//юддддддддддддддддддддддддддддддддддддддддддддддддддддды
			If lContinua .And. AvalBlqLoc(H6_PRODUTO,SC2->C2_LOCAL,Nil)
				lContinua := .F.
			EndIf
		EndIf
	EndIf
EndIf

If lContinua
	aBaixaSGF := A637BxComp(SH6->H6_PRODUTO, A680RotPad(), SH6->H6_OPERAC, SH6->H6_OP)

	//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	//ЁVerifica o Roteiro utilizado nesta OP                         Ё
	//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
	SC2->(dbSetOrder(1))
	If SC2->(dbSeek(xFilial('SC2')+SH6->H6_OP, .F.)) .And. !Empty(SC2->C2_ROTEIRO)
		cRoteiro := SC2->C2_ROTEIRO
	Else
		SB1->(dbSetorder(1))
		If SB1->(dbSeek(xFilial('SB1')+SH6->H6_PRODUTO, .F.)) .And. !Empty(SB1->B1_OPERPAD)
			cRoteiro := SB1->B1_OPERPAD
		Else
			cRoteiro := StrZero(1, Len(SG2->G2_CODIGO))
		EndIf
	EndIf


	//здддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	//Ё Valida Estorno para operacoes anteriores.              Ё
	//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддды
	If lVldEst
		nSldEsto := SH6->H6_QTDPROD

		//здддддддддддддддддддддддддддддддддддддддддддддддд©
		//ЁVerifica o codigo da Proxima Operacao do RoteiroЁ
		//юдддддддддддддддддддддддддддддддддддддддддддддддды
		dbSelectArea('SG2')
		cSeekWhile := "SG2->(G2_FILIAL+G2_PRODUTO+G2_CODIGO)"
		If a630SeekSG2(1,SH6->H6_PRODUTO,xFilial('SG2')+SH6->H6_PRODUTO+cRoteiro+SH6->H6_OPERAC,@cSeekWhile)
			SG2->(dbSkip())
			If !SG2->(Eof()) .And. Eval(&cSeekWhile)
				cOpeNext := SG2->G2_OPERAC
				lOpeNext := .T.
			EndIf
		EndIf

		//зддддддддддддддддддддддддддддддддддддд©
		//ЁSalva posiГЦo da SH6                 Ё
		//юддддддддддддддддддддддддддддддддддддды
		aAreaH6 := SH6->(GetArea())

		//зддддддддддддддддддддддддддддддддддддд©
		//ЁVerifica o Saldo da Operacao Atual   Ё
		//юддддддддддддддддддддддддддддддддддддды
		If SH6->(dbSeek(xFilial("SH6")+cNumOP+cProduto+cOperac)) .And. lOpeNext
			Do While !SH6->(Eof()) .And. xFilial("SH6")+cNumOP+cProduto+cOperac == SH6->H6_FILIAL+SH6->H6_OP+;
				SH6->H6_PRODUTO+SH6->H6_OPERAC
				nSlAtuH6 += SH6->H6_QTDPROD
				SH6->(dbSkip())
			EndDo
		 EndIf

		//зддддддддддддддддддддддддддддддддддддд©
		//ЁVerifica o Saldo da Proxima Operacao Ё
		//юддддддддддддддддддддддддддддддддддддды
		If SH6->(dbSeek(xFilial("SH6")+cNumOP+cProduto+cOpeNext)) .And. lOpeNext
			Do While !SH6->(Eof()) .And. xFilial("SH6")+cNumOP+cProduto+cOpeNext == SH6->H6_FILIAL+SH6->H6_OP+;
				SH6->H6_PRODUTO+SH6->H6_OPERAC
				nSlNexH6 += SH6->H6_QTDPROD
				SH6->(dbSkip())
			EndDo

			//здддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			//ЁVerifica se existe Saldo suficiente para ser estornadoЁ
			//юдддддддддддддддддддддддддддддддддддддддддддддддддддддды
			If nSldEsto > (nSlAtuH6 - nSlNexH6)
				Help(" ",1,"A680NAOEST")
				lContinua := .F.
			EndIf
		EndiF
		//зддддддддддддддддддддддддддддддддддддд©
		//ЁRetorna posicionamento da  SH6       Ё
		//юддддддддддддддддддддддддддддддддддддды
		RestArea(aAreaH6)

	EndIf

	//Valida a existencia de apontamento total para a operacao
	If AllTrim(SH6->H6_PT) # "T"
		cSeek := SH6->(H6_FILIAL+H6_OP+H6_PRODUTO+H6_OPERAC)
		SH6->(dbSetOrder(1))
		SH6->(dbSeek(cSeek))
		While !SH6->(EOF()) .And. cSeek == SH6->(H6_FILIAL+H6_OP+H6_PRODUTO+H6_OPERAC)
			If AllTrim(SH6->H6_PT) == "T" .And. lEstornP .And. (lAuto .Or. Aviso(STR0062,STR0107,{STR0075,STR0076}) == 1)
				nRecnoTot := SH6->(Recno())
				Exit
			ElseIf AllTrim(SH6->H6_PT) == "T"
				Help(" ",1,"A680OPERT")
				lContinua := .F.
				Exit
			EndIf
			SH6->(dbSkip())
		End
	EndIf
	RestArea(aAreaSH6)
EndIf

If lContinua
	//зддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	//Ё Verifica se pode efetuar o estorno.                 Ё
	//юддддддддддддддддддддддддддддддддддддддддддддддддддддды
	dbSelectArea("SD3")
	dbSetOrder(1)
	dbSeek(xFilial("SD3")+SH6->H6_OP+SH6->H6_PRODUTO)
	While !EOF() .And. xFilial("SD3")+SH6->H6_OP+SH6->H6_PRODUTO == SD3->D3_FILIAL+SD3->D3_OP+SD3->D3_COD
		If SD3->D3_IDENT == SH6->H6_IDENT .And. SD3->D3_ESTORNO == "S"
			Help(" ",1,"A250ESTORN")
			lOk:=.F.
			Exit
		EndIf
		If SD3->D3_IDENT == SH6->H6_IDENT .And. SD3->D3_CF == "PR0"
			lOk:=A680VldEst(lUltOper)
			If lOk
				If IntWms(SD3->D3_COD) .And. !Empty(SD3->D3_SERVIC)
					lOk := WmsAvalSC2("2",,,,SD3->(Recno()))
				EndIf
			EndIf
			//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			//Ё Caso o produto use controle WMS SaaS, verificar se producao  Ё
			//Ё se permite o estorno.                                        Ё
			//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
			If lOk .And. lWMSSaas .And. FindFunction("WMSSVEsApt") .And. !WMSSVEsApt(SD3->(Recno()),.T.)
				lOk := .F.
			EndIf
			Exit
		EndIf
		dbSkip()
	EndDo

	//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	//Ё Verifica se Devolucoes (geradas p/Qtd Negativa na Estrut) podem ser Estornadas Ё
	//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
	If lOk .And. (lUltOper .Or. aBaixaSGF # Nil)
		dbSelectArea("SD3")
		dbSetOrder(1)
		If dbSeek(cSeekSD3:=xFilial("SD3")+SH6->H6_OP, .F.)
			Do While !Eof() .And. D3_FILIAL+D3_OP == cSeekSD3
				If aBaixaSGF # Nil .And. aScan(aBaixaSGF, {|z| SD3->(D3_COD + D3_TRT) == z[1] + z[2]}) == 0
					dbSkip()
					Loop
				EndIf
				If (Subs(D3_CF,1,1)=='D').And.SH6->H6_IDENT==D3_IDENT.And.Empty(D3_ESTORNO)
					If !(lOk:=MatVldEst(D3_COD,D3_LOCAL,D3_LOTECTL,D3_NUMLOTE,D3_LOCALIZ,D3_NUMSERI,D3_NUMSEQ,D3_DOC,D3_QUANT))
						Exit
					EndIf
				EndIf
				dbSkip()
			EndDo
		EndIf
	EndIf

	dbSelectArea("SH6")

	While lOk
		//здддддддддддддддддддддддддддддддддддддддддддддддддд©
		//Ё Monta a entrada de dados do arquivo              Ё
		//юдддддддддддддддддддддддддддддддддддддддддддддддддды
		Private aTELA[0][0],aGETS[0]
		bCampo := {|nCPO| Field(nCPO) }

		//здддддддддддддддддддддддддддддддддддддддддддддддддд©
		//Ё Salva a integridade dos campos de Bancos de DadosЁ
		//юдддддддддддддддддддддддддддддддддддддддддддддддддды
		SoftLock(cAlias)

		For i := 1 TO FCount()
			M->&(EVAL(bCampo,i)) := FieldGet(i)
		Next i

		A680MemVar() // Padroniza variАveis de memoria

		If (l680 .And. l680Auto ) .Or. (l681 .And. l681Auto )
			nOpcA:= 2
		Else
			DEFINE MSDIALOG oDlg TITLE cCadastro FROM aSize[7],0 TO aSize[6],aSize[5] OF oMainWnd PIXEL
			nOpcA:=EnChoice( cAlias, nReg, nOpc, ,"AC",STR0007,aAcho,aPosObj[1],,,,,,,,.T.)	//"Quanto ┘ exclus└o?"
			//зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			//Ё Ponto de entrada p/ adicionar botoes de usuario na EnchoiceBarЁ
			//юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
			If ExistBlock( "MA680BUT" )
				If ValType( aUsButtons := ExecBlock( "MA680BUT", .F., .F.,{nOpc} ) ) == "A"
					AEval( aUsButtons, { |x| AAdd( aButtons, x ) } )
				EndIf
			EndIf
			ACTIVATE MSDIALOG oDlg ON INIT EnchoiceBar(oDlg,{|| nOpca := 2,oDlg:End()},{|| nOpca := 1,oDlg:End()},,aButtons)

		EndIf

		//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		//Ё Integracao com o modulo ACD - Faz validacao da exclusao PCP MOD 1 e MOD 2  Ё
		//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
		If lIntACD
			lOk:=CBMT680EST(nOpcA)
			If ValType(lOk) # "L"
				lOk:=.T.
			EndIf
		//здддддддддддддддддддддддддддддддддддддддддддддддддддд©
		//Ё Valida o Estorno da producao                       Ё
		//юдддддддддддддддддддддддддддддддддддддддддддддддддддды
		ElseIf ExistTemplate("MT680EST")
			lOk:=ExecTemplate("MT680EST",.F.,.F.,{nOpcA})
			If ValType(lOk) # "L"
				lOk:=.T.
			EndIf
		EndIf

		If lOk .and. ExistBlock("MT680EST")
			lOk:=ExecbLock("MT680EST",.F.,.F.,{nOpcA})
			If ValType(lOk) # "L"
				lOk:=.T.
			EndIf
		EndIf

		If nOpcA == 2 .And. lOk
			Begin Transaction
				//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				//Ё Verifica se a OP esta encerrada                                Ё
				//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
				lOpEncer := ( !Empty( SC2->C2_DATRF ) )

				//зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				//Ё Verifica se existe integracao com o QIP no Estorno do Apontamento das Producoes Ё
				//юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
				If IntQIP(SH6->H6_PRODUTO,"2")
					lProcessa := QIPAtualiza("SH6",2)
				EndIf

				If !lProcessa
					//STR0105 - "Existe resultado jА coletado para esta Ordem de ProduГЦo. Este Apontamento nЦo poderА ser estornado."
					//STR0141 - "Exclua a inpeГЦo relacionada e tente novamente."
					Help(NIL, NIL, "OPJAINSPEC", NIL, STR0105, 1, 0, NIL, NIL, NIL, NIL, NIL, {STR0141})
				Else
					//Verifica se pode efetuar o estorno.
					dbSelectArea("SD3")
					dbSetOrder(1)
					dbSeek(xFilial("SD3")+SH6->H6_OP+SH6->H6_PRODUTO)
					While !EOF() .And. xFilial("SD3")+SH6->H6_OP+SH6->H6_PRODUTO == SD3->D3_FILIAL+SD3->D3_OP+SD3->D3_COD
						If SD3->D3_IDENT == SH6->H6_IDENT .And. SD3->D3_ESTORNO == "S"
							Help(" ",1,"A250ESTORN")
							lOk:=.F.
							Exit
						EndIf
						If SD3->D3_IDENT == SH6->H6_IDENT .And. SD3->D3_CF == "PR0"
							lOk:=A680VldEst(lUltOper)
							If lOk
								If IntWms(SD3->D3_COD) .And. !Empty(SD3->D3_SERVIC)
									lOk := WmsAvalSC2("2",,,,SD3->(Recno()))
								EndIf
							EndIf
							Exit
						EndIf
						dbSkip()
					EndDo
				EndIf

				cNumSeq1 := '0'

				dbSelectArea("SD3")
				dbSetOrder(1)
				dbSeek(xFilial("SD3")+SH6->H6_OP+SH6->H6_PRODUTO)
				While !EOF() .And. xFilial("SD3")+SH6->H6_OP+SH6->H6_PRODUTO == SD3->D3_FILIAL+SD3->D3_OP+SD3->D3_COD
					If SD3->D3_IDENT == SH6->H6_IDENT
					   	cNumSeq1 = SD3->D3_NUMSEQ
					   	Exit
					EndIf
					dbSkip()
				EndDo

				If lOk .And. lProcessa
					RecLock(cAlias,.F.,.T.)
					dbSelectArea("SH1")
					dbSeek(xFilial("SH1")+SH6->H6_RECURSO)
					dbSelectArea("SD3")
					dbSetOrder(1)
					//здддддддддддддддддддддддддддддддддддддддддддддддддд©
					//Ё Estorna Movimentacao da Mao de Obra.             Ё
					//юдддддддддддддддддддддддддддддддддддддддддддддддддды
					//cProdMod:=APrModRec(SH1->H1_CODIGO)
					cProdMod := If (lModRecPCP ==.T., ModRecPCP(SH1->H1_CODIGO), APrModRec(SH1->H1_CODIGO))
					dbSeek(xFilial("SD3")+SH6->H6_OP+cProdMod)
					While !EOF() .And. SD3->D3_FILIAL+SD3->D3_OP+AllTrim(SD3->D3_COD) == xFilial("SD3")+SH6->H6_OP+AllTrim(cProdMod)
						//If D3_IDENT == SH6->H6_IDENT
						If D3_IDENT == SH6->H6_IDENT .And. cNumSeq1 != SD3->D3_NUMSEQ
							a240DesAtu()
							Exit
						EndIf
						dbSkip()
					EndDo

					If FindFunction("a250EstSMO")
						a250EstSMO(SH6->H6_IDENT) // DMANSMARTSQUAD1-30671
					Endif

					l250DesAtu := .F.
					dbSelectArea("SD3")
					dbSetOrder(1)
					dbSeek(xFilial("SD3")+SH6->H6_OP+SH6->H6_PRODUTO)

					While !EOF() .And. xFilial("SD3")+SH6->H6_OP+SH6->H6_PRODUTO == SD3->D3_FILIAL+SD3->D3_OP+SD3->D3_COD

						If D3_IDENT == SH6->H6_IDENT .And. ! D3_ESTORNO == "S";
							.And. SH6->H6_LOCAL == SD3->D3_LOCAL;
							.And. SH6->H6_LOTECTL == SD3->D3_LOTECTL

							l250DesAtu := .T.
							a250DesAtu(Nil,Nil,@aCtbDia,Nil,Nil,@aMRPxJson)
							If cReqAut == "D" .And. cEstNeg == "S"
								dbSelectArea("SC2")
								cOP      := SC2->C2_NUM
								cItem    := SC2->C2_ITEM
								aAreaSC2 := SC2->(GetArea())
								aAreaSD3 := SD3->(GetArea())
								aAreaSD4 := SD4->(GetArea())
								Do While !Eof() .And. xFilial("SC2")+cOP+cItem == SC2->C2_FILIAL+SC2->C2_NUM+SC2->C2_ITEM
									//зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
									//Ё Caso as Requisicoes nao tenham sido digitadas, verifica se deve atualizar   Ё
									//Ё os arquivos SC2 / SD4                                                       Ё
									//юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
									If !SD3->(dbSeek(xFilial("SD3")+SC2->C2_NUM+SC2->C2_ITEM+SC2->C2_SEQUEN+SC2->C2_ITEMGRD+SC2->C2_PRODUTO)) .And. (SC2->C2_QUJE+SC2->C2_PERDA <= 0) .And. (!Empty(SC2->C2_DATRF))
										If (l680 .And. l680Auto ) .Or. (l681 .And. l681Auto )
											nOpc1 := 1
										Else
											nOpc1 := Aviso(STR0062, STR0071 +SC2->C2_NUM+SC2->C2_ITEM+SC2->C2_SEQUEN+SC2->C2_ITEMGRD +" / "+ SC2->C2_PRODUTO +;								 //"Atencao"###"A Ordem de Producao "
											STR0072 +; //"foi encerrada, sem Qtde. Produzida / Qtde. de Perda (C2_QUJE+C2_PERDA ==0). IMPORTANTE: Se Esta OP for Liberada"
											STR0073 +; //" para producao, os Empenhos deverao ser Ajustados atraves da Rotina de Ajustes de Empenhos. "
											STR0074,{STR0075, STR0076} ) //"Esta OP devera ser liberada para Producao ?"###"Sim"###"Nao"
										EndIf
										//здддддддддддддддддддддддддддддддддддддддддддддддддддд©
										//Ё Deixa OP disponivel para Producao.                 Ё
										//юдддддддддддддддддддддддддддддддддддддддддддддддддддды
										If nOpc1 == 1
											RecLock("SC2",.F.)
											Replace C2_DATRF With Ctod("  /   /  ")
											If lIntNewMRP
												A650AddJIn(@aMRPxJson) //Inclui dados no array para integraГЦo com o novo MRP
											EndIf
										EndIf
									EndIf
									dbSelectArea("SC2")
									SC2->(dbSkip())
								EndDo
								RestArea(aAreaSC2)
								RestArea(aAreaSD3)
								RestArea(aAreaSD4)
							EndIf
							Exit
						EndIf
						dbSkip()
					EndDo
					//INTEGRAгцO TOTVS MES
					//Faz o estorno dos componentes utilizando no apontamento.
					//Quando utiliza o TOTVS MES, o consumo dos materiais pode
					//ser realizado em qualquer operaГЦo, e nЦo apenas na Зltima operaГЦo.
					If !l250DesAtu .And. lConsReal
						a250DesAtu(Nil,Nil,@aCtbDia,.T.,Nil,@aMRPxJson)
					EndIf
					If aBaixaSGF # Nil
						A250DesAtu(, aBaixaSGF,@aCtbDia,Nil,Nil,@aMRPxJson)
	            	ElseIf !l250DesAtu .And. SuperGetMv("MV_DIGIPER")== "S"
						//зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
						//Ё Verifica e estorna perdas da operacao (OP nao produzida, com perda informada) Ё
						//юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
						SBC->(dbSetOrder(1))
						SBC->(dbSeek(xFilial("SBC")+SH6->H6_OP))
						While SBC->(!Eof()) .And. SBC->BC_FILIAL+SBC->BC_OP == xFilial("SBC")+SH6->H6_OP
							If SBC->BC_OPERAC == SH6->H6_OPERAC .And. SBC->BC_IDENSH6 == SH6->H6_IDENT
								If (nSeek := aScan(aSBCEst, {|z| z[1] + z[2] == SH6->H6_OP + SBC->BC_NUMSEQ})) == 0
									AADD(aSBCEst,{SH6->H6_OP,SBC->BC_NUMSEQ})
								EndIf
							EndIf

							SBC->(dbSkip())
						EndDo

						If Len(aSBCEst) > 0
							For nX := 1 to Len(aSBCEst)
								EstornaSBC(aSBCEst[nX][1],aSBCEst[nX][2])
							Next
						EndIf
					EndIf

					//зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
					//Ё Recompoe o saldo do empenho - OP Encerrada                      Ё
					//юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
					If lOpEncer .AND. lAbreOP
						dbSelectArea("SD4")
						dbSetOrder(2)
						dbSeek(xFilial("SD4")+SC2->C2_NUM+SC2->C2_ITEM+SC2->C2_SEQUEN+SC2->C2_ITEMGRD)
						While SD4->(!EOF() .AND. D4_FILIAL+D4_OP==xFilial("SD4")+SC2->C2_NUM+SC2->C2_ITEM+SC2->C2_SEQUEN+SC2->C2_ITEMGRD)

							If (SD4->(FieldPos('D4_QTNECES')) > 0)
								nQtNeces := SD4->D4_QTNECES
							Else
								nQtNeces := 0
							EndIf

							GravaEmp(	SD4->D4_COD,;
										SD4->D4_LOCAL,;
										SD4->D4_SLDEMP,;
										SD4->D4_SLDEMP2,;
										SD4->D4_LOTECTL,;
										SD4->D4_NUMLOTE,;
										NIL,;
										NIL,;
										SD4->D4_OP,;
										SD4->D4_TRT,;
										NIL,;
										NIL,;
										"SC2",;
										SD4->D4_OPORIG,;
										SD4->D4_DATA,;
										@aTravas,;
										.F.,;		//ALTERADO
										NIL,;
										.T.,;
										.T.,;		//Grava SD4
										lConsVenc,;
										NIL,;
										NIL,;
										.T.,;
										NIL,;
										NIL,;
										NIL,;
										lOpEncer,;
										/*29*/,;
										/*30*/,;
										/*31*/,;
										IIf(Empty(SD4->D4_LOTECTL),.F.,.T.),;
										NIL,;
										NIL,;
										nQtNeces)

							//Realiza o estorno das requisiГУes no WMS
							//Para os casos produГЦo parcial com encerramento e posterior estorno, deve-se localizar o endereГo da sobra
							//Em seguida, usar o saldo existente na SD4 para efetuar a movimentaГЦo.
							If lWmsNew .And. IntWms(SD4->D4_COD)
								BeginSql Alias cAliasQry
									SELECT DC_LOCALIZ
									FROM %Table:SDC% SDC
									WHERE SDC.DC_FILIAL = %xFilial:SDC%
									AND SDC.DC_PRODUTO = %Exp:SD4->D4_COD%
									AND SDC.DC_LOCAL = %Exp:SD4->D4_LOCAL%
									AND SDC.DC_OP = %Exp:SD4->D4_OP%
									AND SDC.DC_TRT = %Exp:SD4->D4_TRT%
									AND SDC.DC_IDDCF = %Exp:SD4->D4_IDDCF%
									AND SDC.%NotDel%
								EndSql

								If (cAliasQry)->(!Eof())
									cEndereco := (cAliasQry)->DC_LOCALIZ
								Else
									cEndereco := ''
								EndIf
								(cAliasQry)->(dbCloseArea())

								WmsEmpReq("SC2",SD4->D4_COD,SD4->D4_LOCAL,SD4->D4_SLDEMP,cEndereco,SD4->D4_LOTECTL,SD4->D4_NUMLOTE,/*cNumSerie*/,SD4->D4_OP,SD4->D4_TRT,/*cIdDCF*/,/*cIdUnitiz*/,.F./*lEstorno*/,.T./*lCriaSDC*/, /*lEmpD14*/,,lOpEncer)
							EndIf

							//зддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
							//Ё Remove travas dos registros utilizados                  Ё
							//юддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
							MaDesTrava(aTravas)

							dbSelectArea("SD4")
							RecLock("SD4",.F.)
				            SD4->D4_SLDEMP	:= 0
				            SD4->D4_SLDEMP2	:= 0
			                MsUnlock()
							dbSetOrder(2)
							SD4->(dbSkip())
						Enddo
					EndIf

					//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
					//Ё Chama funcao que transforma apontamento total em parcial Ё
					//Ё quando a operacao estiver encerrada.					 Ё
					//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
					If !Empty(nRecnoTot)
						A680EstTot(nRecnoTot)
					EndIf

					//зддддддддддддддддддддддддддддддддддддддддддддддддддд©
					//Ё Integracao TOTVS APS: ajusta o status da operacao Ё
					//юддддддддддддддддддддддддддддддддддддддддддддддддддды
					SH6->(TAPSOperac(H6_OP,cRoteiro,H6_OPERAC))

					dbSelectArea("SH6")
					RecLock("SH6",.F.,.T.)
					dbDelete()
					MsUnLock()

					//зддддддддддддддддддддддддддддддддддддддддддддддддддд©
					//Ё Chamada para integracao com o modulo ACD		  Ё
					//юддддддддддддддддддддддддддддддддддддддддддддддддддды
					If lIntACD
						CBMT680GREST()
					// Anderson 22/01/03
					//зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
					//Ё Estes pontos de entrada permitem realizar gravacoes e/ou exclusoes    Ё
					//Ё em tabelas e/ou campos especificos do usuario apos realizar o Estorno.Ё
					//юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
					ElseIf ExistTemplate("MT680GREST")
						ExecTemplate("MT680GREST",.F.,.F.)
					EndIf
					If ExistBlock("MT680GREST")
						ExecbLock("MT680GREST",.F.,.F.)
					EndIf

					If utilizaCRP()
						MATA681ApontamentoCRP():ativaHWF()
						MATA681ApontamentoCRP():estornoApontamento(SH6->H6_OP, SH6->H6_OPERAC, SH6->H6_IDENT)
					EndIf
				Endif
			End Transaction

			//зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			//Ё Estes pontos de entrada permitem realizar gravacoes e/ou exclusoes    Ё
			//Ё em tabelas e/ou campos especificos do usuario apos realizar o Estorno.Ё
			//юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
			If ExistTemplate("MT680GEFTR")
				ExecTemplate("MT680GEFTR",.F.,.F.)
			EndIf
			If ExistBlock("MT680GEFTR")
				ExecbLock("MT680GEFTR",.F.,.F.)
			EndIf

		Else
			//зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			//Ё Ponto de Entrada apСs acionar o botЦo cancelar no Apontamento de Producao mod2Ё
			//юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
			If lMt680Can
				Execblock("MT680CAN",.F.,.F.)
			Endif
			MSUNLOCK()
		EndIf
		Exit
	Enddo

	//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	//Ё Verifica se o custo medio e' calculado On-Line               Ё
	//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
	If cCusMed == "O"
		If !lCriaHeader
			lDigita   := Iif(mv_par01 == 1,.T.,.F.)
			lAglutina := Iif(mv_par02 == 1,.T.,.F.)
			//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			//Ё Se ele criou o arquivo de prova ele deve gravar o rodape'    Ё
			//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
			RodaProva(nHdlPrv,nTotal)
			//зддддддддддддддддддддддддддд©
			//ЁAtualiza o cСdigo de diАrioЁ
			//юддддддддддддддддддддддддддды
			If !Empty(aCtbDia)
				cCodDiario := CtbaVerdia()
				For nX := 1 to Len(aCtbDia)
					aCtbDia[nX][3] := cCodDiario
				Next nX
			EndIf
			cA100Incl(cArquivo,nHdlPrv,3,cLoteEst,lDigita,lAglutina,,,,,,aCtbDia)
			lCriaHeader := .T.
			KeyBoard Chr(27)
		EndIf
	EndIf
EndIf

//Chama integraГЦo com novo MRP
If lIntNewMRP .AND. Len(aMRPxJson[1]) > 0
	MATA650INT("INSERT", aMRPxJson[1])
	aSize(aMRPxJson[1], 0)
	FreeObj(aMRPxJson[2])
	aMRPxJson[2] := Nil
EndIf

//Inicializa a variАvel de controle da integraГЦo com o novo MRP
If lDelTBMRP
	_lNewMRP := Nil
EndIf

Return
/*
эээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤┘o    Ё FAtiva   Ё Autor Ё Cristina Ogura        Ё Data Ё 04.01.96 Ё╠╠
╠╠цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤┘o Ё Executa a Funcao da Pergunte                               Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ
*/
Static Function FAtiva()
Pergunte("MTA680",.T.)
RETURN .T.

/*
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤┘o    ЁA680GeraD3Ё Autor Ё Ary Medeiros          Ё Data Ё 23/06/92 Ё╠╠
╠╠цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤┘o Ё Programa de atualizacoes (sd3,sb2,sb3,sc2,...)             Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠Ё Uso      Ё MATA680                                                    Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ
*/
Function A680GeraD3(cTipo,cIdent,lEncerraOP)
Local cCCD3      := ''
Local cDoc       := ""
Local cParData   := SuperGetMV("MV_DTAPT",.F.,2)
Local cProdMod   := ""
Local lIntSFC    := IntegraSFC() .And. IsInCallStack("AUTO681")
Local lMES       := .F.
Local lModRecPCP := FindFunction( 'ModRecPCP' )
Local lProces    := SuperGetMV("MV_APS",.F.,"") == "TOTVS" .Or. lIntSFC .OR. SuperGetMV("MV_PCPATOR",.F.,.F.) == .T.
Local lRet       := .T.
Local lRetPE     := .T.
Local mv_tmpad   := If(ExistBlock("MA680TMP"),ExecBlock("MA680TMP",.F.,.F.),GetMV("MV_TMPAD"))
Local nQtdD3     := 0
Local nQtdRet    := 0

Static lExistA680MOD

Default lEncerraOP := .F.

CriaStatic()

//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
//Ё Identifica se estА em MemСria                            Ё
//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
If Type("lMemory") == "U"
	Private lMemory := .F.
EndIf

lMemory := If(lMemory==NIL,.F.,lMemory)
lMES    := AllTrim(If(lMemory,M->H6_OBSERVA,SH6->H6_OBSERVA))=="TOTVSMES"

If lExistA680MOD == Nil
	lExistA680MOD := ExistBlock("A680MOD")
EndIf

cIdent:=IIF(cIdent == NIL,Criavar("D3_IDENT"),cIdent)

lModZero := .T.

dbSelectArea("SH1")
dbSeek(xFilial("SH1")+SH6->H6_RECURSO)
dbSelectArea("SB1")
dbSeek(xFilial("SB1")+SH6->H6_PRODUTO)

If cTipo == "PR0"
	dbSelectArea("SB1")
	If	dbSeek(xFilial("SB1")+SH6->H6_PRODUTO)
		If Rastro(SH6->H6_PRODUTO)
			RecLock("SH6",.F.)
			If Rastro(SH6->H6_PRODUTO,"S")
				Replace H6_NUMLOTE With NextLote(SH6->H6_PRODUTO,"S")
			EndIf
			If Empty (SH6->H6_LOTECTL)
				Replace H6_LOTECTL With NextLote(SH6->H6_PRODUTO,"L")
			EndIf
			If Empty (SH6->H6_DTVALID)
				Replace H6_DTVALID	With dDataBase + SB1->B1_PRVALID
			EndIf
			MsUnlock()
		EndIf

		cDoc := ""
		If !Empty(GetSX3Cache("D3_DOC","X3_RELACAO"))
			If (Type("cDocD3Ini") == "C")
				cDoc := cDocD3Ini
			EndIf
		EndIf

		If Empty(cDoc)
			DbSelectArea("SD3")
			dbSetOrder(2)
			If dbSeek(xFilial("SD3")+Padr(SH6->H6_OP,TamSX3("D3_DOC")[1]))
				cDoc := NextNumero("SD3",2,"D3_DOC",.T.)
				cDoc := A261RetINV(cDoc)
			Else
				cDoc := Padr(SH6->H6_OP,TamSX3("D3_DOC")[1])
			EndIf
		EndIf

		//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		//Ё Ponto de Entrada para critica do Envio do Material para  Ё
		//Ё Inspecao no Quality, para Inspecao no Quality o mesmo de Ё
		//Ё vera estar igual a .T.									 Ё
		//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
		//define se o produto serА enviado para o CQ
		lEnvCQProd := fEnvCQProd(SH6->H6_PRODUTO, SF5->F5_CODIGO, .F.,,SH6->H6_LOCAL)
		RecLock("SD3",.T.)
		Replace D3_TM  		With mv_tmpad,;
				 D3_OP			With SH6->H6_OP,;
				 D3_COD			With SH6->H6_PRODUTO,;
				 D3_QUANT 		With SH6->H6_QTDPROD,;
				 D3_QTSEGUM	With SH6->H6_QTDPRO2,;
				 D3_UM     		With SC2->C2_UM,;
				 D3_PARCTOT  	With SH6->H6_PT,;
				 D3_LOCAL    	With If(lEnvCQProd,GetMV('MV_CQ'),SC2->C2_LOCAL),;
				 D3_LOCAL    	With If(!Empty(SH6->H6_LOCAL) .And. lEnvCQProd,GetMV('MV_CQ'),SH6->H6_LOCAL),;
				 D3_CC       	With SC2->C2_CC,;
				 D3_CLVL		With SC2->C2_CLVL,;
				 D3_ITEMCTA 	With SC2->C2_ITEMCTA,;
				 D3_CONTA    	With SB1->B1_CONTA,;
				 D3_TIPO     	With SB1->B1_TIPO,;
				 D3_GRUPO    	With SB1->B1_GRUPO,;
				 D3_DOC      	With cDoc,;
				 D3_FILIAL   	With xFilial("SD3"),;
				 D3_NIVEL    	With SC2->C2_NIVEL,;
				 D3_IDENT    	With cIdent,;
				 D3_NUMLOTE	With SH6->H6_NUMLOTE,;
				 D3_LOTECTL	With SH6->H6_LOTECTL,;
				 D3_DTVALID	With SH6->H6_DTVALID,;
				 D3_CF       	With If(cTipo=="PR0",cTipo,""),;
				 D3_CHAVE    	With SubStr(D3_CF,2,1)+IF(D3_CF=='DE4','9','0'),;
				 D3_NUMSEQ   	With ProxNum(),;
				 D3_USUARIO  	With CUSERNAME,;
				 D3_POTENCI  	With SH6->H6_POTENCI,;
				 D3_IDENT    	With cIdent,;
				 D3_QTMAIOR	    With SH6->H6_QTMAIOR,;
				 D3_QTGANHO	    With SH6->H6_QTGANHO,;
				 D3_RATEIO      With SH6->H6_RATEIO,;
				 D3_OBSERVA     With SH6->H6_OBSERVA

		Do Case
			Case lMES .and. !empty(SH6->H6_DTAPONT)
				Replace D3_EMISSAO With SH6->H6_DTAPONT
			Case cParData == 1
				Replace D3_EMISSAO With Date()
			Case cParData == 2
				Replace D3_EMISSAO With dDataBase
			Case cParData == 3
				Replace D3_EMISSAO With SH6->H6_DATAINI
			Case cParData == 4
				Replace D3_EMISSAO With SH6->H6_DATAFIN
			OtherWise
				Replace D3_EMISSAO With dDataBase
		EndCase


		If lEncerraOP .And. (l681 .Or. l680)
			nQtdPerOpe := 0
			nH6_Op := SH6->H6_OP

			aAreaSH6  := SH6->(GetArea())

			SH6->(dbclosearea())

			dbSelectArea("SH6")
			dbSetOrder(1)
			dbGotop()
			dbSeek(xFilial("SH6")+nH6_Op)

			While !Eof() .And. SH6->H6_FILIAL + SH6->H6_OP == xFilial("SH6") + nH6_Op
				If SH6->H6_FILIAL + SH6->H6_OP == xFilial("SH6") + nH6_Op //.And. SH6->H6_OPERAC + SH6->H6_SEQ = nOperAtual + nSeqAtual
					If SH6->H6_QTDPERD > 0
						nQtdPerOpe += SH6->H6_QTDPERD
					EndIf
				EndIf
				dbSkip()
			EndDo

			SH6->(dbclosearea())
			dbSelectArea("SH6")
			dbSetOrder(1)
			dbGotop()
			RestArea(aAreaSH6)

		    RecLock("SD3",.F.)
			Replace D3_PERDA With nQtdPerOpe
		Else
			Replace D3_PERDA		With SH6->H6_QTDPERD+SH6->H6_PERDANT
		EndIf

		If IntWms(SH6->H6_PRODUTO) .And. !Empty(cA680Ser)
			Replace D3_SERVIC With cA680Ser
		EndIf
		If !Empty(SH6->H6_LOCAL)
			Replace D3_LOCAL With If(lEnvCQProd,GetMV('MV_CQ'),SH6->H6_LOCAL)
		EndIf
		If nFCICalc == 1
			Replace D3_PERIMP With SH6->H6_PERIMP
		EndIf
		SD3->(MsUnlock())
	Else
		lRet	 :=.F.
		lModZero := .F.
	EndIf
Else
    cRotPad := SB1->B1_OPERPAD
	dbSelectArea("SB1")
	//cProdMod:=APrModRec(SH1->H1_CODIGO)
	cProdMod := If (lModRecPCP ==.T., ModRecPCP(SH1->H1_CODIGO), APrModRec(SH1->H1_CODIGO))
	If	dbSeek(xFilial("SB1")+cProdMod)
		If SB1->B1_MSBLQL == '1'
			lExistMod := .F.
		Else
			lExistMod := .T.
		EndIf
	Else
		lExistMod := .F.
	EndIf

	If lExistMod
		If l682
			nQtdD3 := A680QtMod()
		Else
		    //DMANSMARTSQUAD1-21158 - Vivian - 20/04/2021 - Se APS, SFC ou MV_PCPATOR ativo, entЦo deve considerar da tabela SHY
		    If lProces
	           If !Empty(SC2->C2_ROTEIRO)
			      cRoteiro := SC2->C2_ROTEIRO
       		   Else
				  If !Empty(cRotPad)
				     cRoteiro := cRotPad
			      Else
			         cRoteiro := StrZero(1, Len(SG2->G2_CODIGO))
				  EndIf
			   EndIf

			   aAreaSHY  := SHY->(GetArea())
               dbSelectArea("SHY")
		       SHY->(dbSetOrder(1))
		       if SHY->(dbSeek(xFilial("SHY")+SH6->H6_OP+cRoteiro+SH6->H6_OPERAC))
			      nQtdD3 := A680QtMod()*If(Empty(SHY->HY_MAOOBRA),1,SHY->HY_MAOOBRA)
			   Else
			      aAreaSG2  := SG2->(GetArea())
				  dbSelectArea("SG2")
		          SG2->(dbSetOrder(1))
			      If SG2->(dbSeek(xFilial("SG2")+SH6->H6_PRODUTO+cRoteiro+SH6->H6_OPERAC))
			         nQtdD3 := A680QtMod()*If(Empty(SG2->G2_MAOOBRA),1,SG2->G2_MAOOBRA)
				  Else
				     nQtdD3 := A680QtMod()
				  EndIf
				  RestArea(aAreaSG2)
			   EndIf
			   RestArea(aAreaSHY)
			Else
			   nQtdD3 := A680QtMod()*If(Empty(SG2->G2_MAOOBRA),1,SG2->G2_MAOOBRA)
			EndIf
			//Fim DMANSMARTSQUAD1-21158
		EndIf

		If lExistA680MOD .And. ValType(nQtdRet := ExecBlock("A680MOD",.F.,.F., nQtdD3)) == "N"
			nQtdD3 := nQtdRet
		EndIf

		If (nQtdD3 > 0) .And. (!lIntSFC .Or. Posicione("SF5",1,xFilial("SF5")+mv_tmpad,"F5_TRANMOD") == "S")

			cDoc := ""
			If !Empty(GetSX3Cache("D3_DOC","X3_RELACAO"))
				If (Type("cDocD3Ini") == "C")
					cDoc := cDocD3Ini
				EndIf
			EndIf

			If Empty(cDoc)
				DbSelectArea("SD3")
				dbSetOrder(2)
				If dbSeek(xFilial("SD3")+Padr(SH6->H6_OP,TamSX3("D3_DOC")[1]))
					cDoc := NextNumero("SD3",2,"D3_DOC",.T.)
					cDoc := A261RetINV(cDoc)
				Else
					cDoc := SC2->C2_NUM
				EndIf
			EndIf

			If l682
				cCCD3 := SH1->H1_CCUSTO
			Else
				cCCD3 := If(mv_par06==2,SC2->C2_CC,SB1->B1_CC)
			EndIf

			RecLock("SD3",.T.)
			Replace D3_TM  		With "999",;
				 	 D3_OP       	With SH6->H6_OP,;
				 	 D3_COD      	With cProdMod,;
					 D3_QUANT    	With nQtdD3,;
					 D3_QTSEGUM  	With ConvUm(SD3->D3_COD,SD3->D3_QUANT,0,2),;
					 D3_UM       	With SB1->B1_UM,;
					 D3_LOCAL    	With RetFldProd(SB1->B1_COD,"B1_LOCPAD"),;
					 D3_CC       	With cCCD3,;
					 D3_CLVL		With If(mv_par06==2,SC2->C2_CLVL,SB1->B1_CLVL),;
					 D3_ITEMCTA  	With SC2->C2_ITEMCTA,;
					 D3_CONTA    	With SB1->B1_CONTA,;
					 D3_TIPO     	With SB1->B1_TIPO,;
					 D3_DOC      	With cDoc,;
					 D3_FILIAL   	With xFilial("SD3"),;
					 D3_CF        With If(cTipo=="MOD","RE1",""),;
					 D3_NIVEL    	With SC2->C2_NIVEL,;
					 D3_IDENT    	With cIdent,;
					 D3_QTMAIOR With SH6->H6_QTMAIOR,;
					 D3_OBSERVA With SH6->H6_OBSERVA

			Do Case
				Case lMES .and. !empty(SH6->H6_DTAPONT)
					Replace D3_EMISSAO With SH6->H6_DTAPONT
				Case cParData == 1
					Replace D3_EMISSAO With Date()
				Case cParData == 2
					Replace D3_EMISSAO With dDataBase
				Case cParData == 3
					Replace D3_EMISSAO With SH6->H6_DATAINI
				Case cParData == 4
					Replace D3_EMISSAO With SH6->H6_DATAFIN
				OtherWise
					Replace D3_EMISSAO With dDataBase
			EndCase

			SD3->(MsUnlock())

		Else
			lRet := .F.
		EndIf
	Else
	    If !Empty(SH6->H6_HORAINI) .And. !Empty(SH6->H6_HORAFIN)
	   		Help(" ",1,"A680MODSB1",,cProdMod,5,3)
			lModZero := .F.
		EndIf
		lRet	 := .F.
	EndIf
EndIf

If "GETSXENUM" $ UPPER(GetSX3Cache("D3_DOC","X3_RELACAO"))
	ConfirmSX8()
Endif

nRegD3 := Recno()
If lRet .And. ExistBlock('MT680GD3')
	lRet := If(ValType(lRetPE:=ExecBlock('MT680GD3', Nil, Nil, {SH6->H6_PRODUTO, SH6->H6_OP, SH6->H6_IDENT, lRet}))=='L',lRetPE,lRet)
EndIf
Return lRet

/*
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤┘o    Ё A680IniOPЁ Autor Ё Ary Medeiros          Ё Data Ё 07/01/92 Ё╠╠
╠╠цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤┘o Ё Rotina p/ inicializacao de alguns campos a partir da OP    Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠Ё Uso      Ё MATA680                                                    Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ
*/
Function A680IniOP()
Local nEnd1:=0,nRecno:=0,nSaldoAnt:=0
Local lRet:=.T., aAreaSH6, cSeek
Local lAutomatico := (Type("l680Auto")=="L" .And. l680Auto) .Or. (Type("l681Auto")=="L" .And. l681Auto)
Local lIntSFC	  := IntegraSFC() .And. !IsInCallStack("AUTO681")
Local lSldOper := .F.

If (l680 .And. !l680Auto)
	M->H6_OPERAC  := SH8->H8_OPER
	M->H6_DESDOBR := SH8->H8_DESDOBR
	//lSaldoValid = A680SldOper(.T.,.F.,.F.)[1]
	If mv_par07 # 3
		lSaldoValid := A680SldOper(.T.,.F.,.T.)[1]
	Else
		lSaldoValid := A680SldOper(.T.,.F.,.F.)[1]
	EndIf
EndIF

If (l680 .And. !l680Auto) .And. ( M->H6_OP # SH8->H8_OP .Or. lSaldoValid <= 0 )
	If ! SH8->(dbSeek(xFilial("SH8") + M->H6_OP))
		Help(" ",1,"REGNOIS")
		lRet := .F.
	Else
	   lSldOper := .F.

	   while( ( SH8->H8_OP = M->H6_OP ) .and. (!SH8->(eof())) .and. !lSldOper )
	       M->H6_OPERAC  := SH8->H8_OPER
	       M->H6_SEQ     := SH8->H8_SEQROTA
	       M->H6_RECURSO := SH8->H8_RECURSO
	       M->H6_DESDOBR := SH8->H8_DESDOBR

	       if( A680SldOper(.T.)[1] > 0 )
	           lSldOper := .T.
	       else
	          SH8->(dbskip( ) )
	       endif
	   enddo
	EndIf
EndIf

If lRet .And. ! A650OpBatch(M->H6_OP)
	lRet := .F.
EndIf

If lRet

	dbSelectArea("SH6")
	dbSetOrder(1)
	nRecno:=Recno()
	dbSelectArea("SC2")
	If dbSeek(xFilial("SC2")+M->H6_OP)
		If SC2->C2_TPOP == "P"
			Help(" ",1,"NOPPREVIST")
			lRet:=.F.
		ElseIf !Empty(SC2->C2_DATRF)
			Help(" ",1,"A680OPTOT")
			lRet:=.F.
		Else
			dbSelectArea("SH6")
			aAreaSH6:=SH6->(GetArea())
			If (l680 .And. !l680Auto) .And. dbSeek(cSeek:=xFilial("SH6")+SH8->H8_OP+SC2->C2_PRODUTO+SH8->H8_OPER)
				Do While ! Eof() .And. SH6->H6_FILIAL+SH6->H6_OP+SH6->H6_PRODUTO+SH6->H6_OPERAC == cSeek
					If SH6->H6_PT == "T"
						Help(" ",1,"A680OPTOT",,RetTitle("H8_OPER") + ": " + ALLTRIM(SH8->H8_OPER),04,01)
						lRet:=.F.
					EndIf
					SH6->(dbSkip())
				EndDo
			EndIf
			RestArea(aAreaSH6)

			If l680 .And. !l680Auto .And. lRet
				M->H6_OPERAC := SH8->H8_OPER
				nEnd1 := Ascan(aGets,{ |x| Subs(x,9,10) == "H6_OPERAC " } )
				If nEnd1 > 0
					aTela[Val(Subs(aGets[nEnd1],1,2))][Val(Subs(aGets[nEnd1],3,1))*2] := sh8->h8_oper
				EndIf
				M->H6_SEQ := SH8->H8_SEQROTA
				nEnd1 := Ascan(aGets,{ |x| Subs(x,9,10) == "H6_SEQ    " } )
				If nEnd1 > 0
					aTela[Val(Subs(aGets[nEnd1],1,2))][Val(Subs(aGets[nEnd1],3,1))*2] := M->H6_SEQ
				EndIf
				M->H6_RECURSO := SH8->H8_RECURSO
				nEnd1 := Ascan(aGets,{ |x| Subs(x,9,10) == "H6_RECURSO" } )
				If nEnd1 > 0
					aTela[Val(Subs(aGets[nEnd1],1,2))][Val(Subs(aGets[nEnd1],3,1))*2] := M->H6_RECURSO
				EndIf
				M->H6_DESDOBR := SH8->H8_DESDOBR
				nEnd1 := Ascan(aGets,{ |x| Subs(x,9,10) == "H6_DESDOBR" } )
				If nEnd1 > 0
					aTela[Val(Subs(aGets[nEnd1],1,2))][Val(Subs(aGets[nEnd1],3,1))*2] := M->H6_DESDOBR
				EndIf
				lRet:=A680IniCpo()
			EndIf
			If lRet .And. l681 .And. !l681Auto
				M->H6_OPERAC  := Space(Len(SH6->H6_OPERAC))
				M->H6_RECURSO := Space(Len(SH6->H6_RECURSO))
				M->H6_QTDPROD := 0
				M->H6_QTDPRO2 := 0
				M->H6_QTDPERD := 0
				M->H6_PT      := "P"
			EndIf
		EndIf
	EndIf

	If lRet
		lRet := A680Quant()
	EndIf

	//-- Nao permite apontar OP integrada ao Chao de Fabrica
	If lRet .And. lIntSFC
		CYQ->(dbSetOrder(1))
		lRet:= !CYQ->(dbSeek(xFilial("CYQ")+M->H6_OP))
		If !lRet
			Aviso("AtenГЦo","Esta OP И movimentada somente atravИs do mСdulo ChЦo de FАbrica.",{"OK"})
		EndIf
	EndIf

	If lRet
		M->H6_PRODUTO := SC2->C2_PRODUTO
		M->H6_LOCAL := SC2->C2_LOCAL

		nEnd1 := Ascan(aGets,{ |x| Subs(x,9,10) == "H6_PRODUTO" } )
		If nEnd1 > 0
			aTela[Val(Subs(aGets[nEnd1],1,2))][Val(Subs(aGets[nEnd1],3,1))*2] := SC2->C2_PRODUTO
		EndIf
		nEnd1 := Ascan(aGets,{ |x| Subs(x,9,10) == "H6_LOCAL  " } )
		If nEnd1 > 0
			aTela[Val(Subs(aGets[nEnd1],1,2))][Val(Subs(aGets[nEnd1],3,1))*2] := SC2->C2_LOCAL
		EndIf

		If Rastro(M->H6_PRODUTO) .And. !lAutomatico
			DbSelectArea("SB1")
			DbSetOrder(1)
			DbSeek(xFilial("SB1")+M->H6_PRODUTO)
			M->H6_DTVALID	:= dDataBase + SB1->B1_PRVALID
			nEnd1 := Ascan(aGets,{ |x| Subs(x,9,10) == "H6_DTVALID" } )
			If nEnd1 > 0
				aTela[Val(Subs(aGets[nEnd1],1,2))][Val(Subs(aGets[nEnd1],3,1))*2] := DTOC(M->H6_DTVALID)
			EndIf
		EndIf
	EndIf
EndIf
If !l680Auto
	A680Hora()
EndIf

//Se utiliza o CRP ou as datas e horas do apontamento jА estiverem informadas, calcula o tempo da operaГЦo de acordo com o recurso informado.
If lRet .And. utilizaCRP()
	M->H6_TEMPO := A680Calc()
EndIf

DbSelectArea("SB1")
DbSetOrder(1)
DbSeek(xFilial("SB1")+M->H6_PRODUTO)

Return lRet

/*
эээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤└o    Ё A680Oper Ё Autor Ё Ary Medeiros          Ё Data Ё 16/09/96 Ё╠╠
╠╠цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤┘o Ё Faz consistencia na digitacao do Operacao no apontamento   Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ*/
Function A680Oper(lTudoOk)
	Local nX 			:= 0
	Local nPos    		:= 0
	Local aOps    		:= {}
	Local cRoteiro		:= ''
	Local cOperacao	:= ''
	Local cSeekSH6  	:= ''
	Local cSeekSH8		:= ''
	Local aAreaAnt  	:= GetArea()
	Local aAreaSG2  	:= SG2->(GetArea())
	Local aAreaSHY  	:= SHY->(GetArea())
	Local aAreaSH6  	:= SH6->(GetArea())
	Local aAreaSH8  	:= {}
	Local lVldOper  	:= (GetMV('MV_VLDOPER')=='S')
	Local lChkQtd   	:= (M->H6_QTDPROD>0)
	Local lRet		:= .T.
	Local lIntSFC	:= IntegraSFC()
	Local lCheckList:= SuperGetMV("MV_CHKOPER",.F.,.F.)
	Local lProces   := SuperGetMV("MV_APS",.F.,"") == "TOTVS" .Or. lIntSFC .OR. SuperGetMV("MV_PCPATOR",.F.,.F.) == .T.
	Local l681 := IsInCallStack("MATA681")

	lTudoOk  := If(lTudoOk==Nil.Or.ValType(lTudoOk)#'L',.F.,lTudoOk)

	If Type("cGetAPI")=="C" .And. cGetAPI == 'APIREST-GET681'
		l681 := .T.
	EndIf

	//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	//ЁDefine Roteiro e Opera┤└o Utilizados nesta OP                 Ё
	//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
	If l680
		aAreaSH8  := SH8->(GetArea())
		SH8->(dbSetOrder(1))
		If SH8->(dbSeek(xFilial('SH8')+M->H6_OP))
			cRoteiro  := SH8->H8_ROTEIRO
			cOperacao := SH8->H8_SEQROTA
		EndIf
	Else
		SC2->(dbSetOrder(1))
		If SC2->(dbSeek(xFilial('SC2')+M->H6_OP, .F.)) .And. !Empty(SC2->C2_ROTEIRO)
			cRoteiro := SC2->C2_ROTEIRO
		Else
			SB1->(dbSetorder(1))
			If SB1->(dbSeek(xFilial('SB1')+M->H6_PRODUTO, .F.)) .And. !Empty(SB1->B1_OPERPAD)
				cRoteiro := SB1->B1_OPERPAD
			Else
				cRoteiro := StrZero(1, Len(SG2->G2_CODIGO))
			EndIf
		EndIf
	EndIf
	cOperacao := If(Empty(cOperacao),M->H6_OPERAC,cOperacao)

	// Se APS, SFC ou MV_PCPATOR ativo, entЦo deve olhar a tabela SHY
	// Se nЦo tiver SHY, deve apresentar o erro
	if lProces
		dbSelectArea("SHY")
		SHY->(dbSetOrder(1))
        if SHY->(dbSeek(xFilial("SHY")+M->H6_OP))
            if SHY->(dbSeek(xFilial("SHY")+M->H6_OP+cRoteiro+cOperacao))
                If ! A650SkHY(1,M->H6_PRODUTO,xFilial('SHY')+M->H6_OP+cRoteiro+cOperacao)
                    If lVldOper
                        Help(' ',1,'OPERACAO')
                        RestArea(aAreaSHY)
                        RestArea(aAreaAnt)
                        lRet := .F.
                    EndIf
                EndIf
            else
                Help(" ",1,"OPERACAO_OP", ,STR0127+".",1,0, ,,,,,{STR0128})
                RestArea(aAreaSHY)
                RestArea(aAreaAnt)
                lRet := .F.
            endif
        Else
			// Entra aqui quando existem ordens de produГЦo antigas, que jА foram iniciadas e que nЦo possuem SHY
			lProces := .F.

			If ! a630SeekSG2(1,M->H6_PRODUTO,xFilial('SG2')+M->H6_PRODUTO+cRoteiro+cOperacao)
				If lVldOper
					Help(' ',1,'OPERACAO')
					RestArea(aAreaSG2)
					RestArea(aAreaAnt)
					lRet := .F.
				EndIf
			Else
				aAreaSG2[2] := SG2->(IndexOrd())
				aAreaSG2[3] := SG2->(Recno())

				//Valida a data de validade da operaГЦo. ValidaГЦo ocorre somente na chamada do TudoOk para nЦo travar a tela no campo de OperaГЦo e permitir alterar as datas.
				If lTudoOk
					If !Empty(SG2->G2_DTINI)
						If lRet .And. !Empty(M->H6_DATAINI)
							If SG2->G2_DTINI > fConvertDt(M->H6_DATAINI)
								Help( ,, 'Help',, STR0109, 1, 0 ) //"Data inicial de apontamento menor que a data de validade inicial da operaГЦo."
								lRet := .F.
							EndIf
						EndIf
						If lRet .And. !Empty(M->H6_DATAFIN)
							If SG2->G2_DTINI > fConvertDt(M->H6_DATAFIN)
								Help( ,, 'Help',, STR0110, 1, 0 ) //"Data final de apontamento menor que a data de validade inicial da operaГЦo."
								lRet := .F.
							EndIf
						EndIf
					EndIf
					If !Empty(SG2->G2_DTFIM)
						If lRet .And. !Empty(M->H6_DATAINI)
							If SG2->G2_DTFIM < fConvertDt(M->H6_DATAINI)
								Help( ,, 'Help',, STR0111, 1, 0 ) //"Data inicial de apontamento maior que a data de validade final da operaГЦo."
								lRet := .F.
							EndIf
						EndIf
						If lRet .And. !Empty(M->H6_DATAFIN)
							If SG2->G2_DTFIM < fConvertDt(M->H6_DATAFIN)
								Help( ,, 'Help',, STR0112, 1, 0 ) //"Data final de apontamento maior que a data de validade final da operaГЦo."
								lRet := .F.
							EndIf
						EndIf
					EndIf
				EndIf
			EndIf
		Endif
	Else
		//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		//ЁPosiciona SG2 na Opera┤└o Atual                             Ё
		//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
		If ! a630SeekSG2(1,M->H6_PRODUTO,xFilial('SG2')+M->H6_PRODUTO+cRoteiro+cOperacao)
			If lVldOper
				Help(' ',1,'OPERACAO')
				RestArea(aAreaSG2)
				RestArea(aAreaAnt)
				lRet := .F.
			EndIf
		Else
			aAreaSG2[2] := SG2->(IndexOrd())
			aAreaSG2[3] := SG2->(Recno())
		EndIf
	EndIf

	If lRet
		If l680
			//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			//ЁValida Sequencia atraves da alocacao da Carga Maquina         Ё
			//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
			dbSelectArea('SH8')
			dbSetOrder(1)
			If !(dbSeek(xFilial('SH8')+M->H6_OP+M->H6_OPERAC))
				Help(' ', 1, 'NAOALOC')
				RestArea(aAreaSH8)
				RestArea(aAreaAnt)
				lRet := .F.
			EndIf

			If lRet .And. dbSeek(cSeekSH8 := xFilial('SH8')+M->H6_OP, .F.)
				Do While !Eof() .And. cSeekSH8 == H8_FILIAL + H8_OP
					If H8_OPER == M->H6_OPERAC .And. H8_SEQROTA == M->H6_SEQ
						Exit
					EndIf
					SH6->(dbSetOrder(1))
					If !SH6->(dbSeek(xFilial('SH6')+M->H6_OP+M->H6_PRODUTO+SH8->H8_OPER + SH8->H8_SEQROTA, .F.))
						Help(' ', 1, 'FORAORDEM')
						RestArea(aAreaSH8)
						RestArea(aAreaAnt)
						lRet := .F.
						Exit
					EndIf
					dbSkip()
					Loop
				EndDo
			EndIf
		ElseIf l681 .And. lProces

			//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			//ЁValida Sequencia atraves do Roteiro de OperaГУes pela SHY     Ё
			//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
			aOPs := {}

			aAreaSHY := SHY->(GetArea())

			//-- Array aOPs :
			//-- [n, 1   ] = Opera┤└o
			//-- [n, 2   ] = Quantidade Total j═ produzida
			dbSelectArea('SHY')
			cSeekSHY	:= "SHY->(HY_FILIAL+HY_OP+HY_ROTEIRO)"

			If !A650SkHY(1,M->H6_PRODUTO,xFilial('SHY')+M->H6_OP+cRoteiro,@cSeekSHY)
				Help(' ',1,'OPERACAO')
				RestArea(aAreaSHY)
				RestArea(aAreaAnt)
				lRet := .F.
			Else
				Do While !Eof() .And. Eval(&cSeekSHY) .And. HY_OPERAC <= M->H6_OPERAC
					If (nPos := aScan(aOPs, {|x| x[1] == HY_OPERAC})) == 0
						aAdd(aOPs, {HY_OPERAC, 0})
					EndIf
					dbSkip()

				EndDo

				fQtdOperac(M->H6_OP, M->H6_OPERAC,M->H6_QTDPROD,@aOPs)

				RestArea(aAreaSHY)
				RestArea(aAreaSH6)
			EndIf
			If lRet
				If (nPos := aScan(aOPs, {|x| x[1] == M->H6_OPERAC})) > 0
					//If nPos > 1 .AND. IsInCallStack('A680TudoOk')
					If (nPos > 1 .AND. !lIntSFC) .Or. (nPos > 1 .AND. lIntSFC .And. IsInCallStack('A680TudoOk'))
						If lChkQtd .And. QtdComp(aOPs[nPos, 2]) > QtdComp(aOPs[nPos-1,2])
							If mv_par07 # 3
								Help(' ', 1, 'A680QUANT')
								RestArea(aAreaAnt)
								lRet := .F.
							EndIf
						ElseIf mv_par07 # 3 .And. QtdComp(aOPs[nPos-1,2]) == QtdComp(0)
							Help(' ',1,'FORAORDEM')
							RestArea(aAreaAnt)
							lRet := .F.
						EndIf
					EndIf
				Else
					Help(' ',1,'OPERACAO')
					RestArea(aAreaAnt)
					lRet := .F.
				EndIf
			EndIf

			If !lTudoOk .And. lCheckList .And. lRet
				lRet:= A680VldChk(M->H6_PRODUTO,cRoteiro,cOperacao)
			EndIf

			If lRet
				//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				//ЁPreenche o Recurso quando se digita a Operacao                Ё
				//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
				If !lTudoOk
					M->H6_RECURSO := SHY->HY_RECURSO
					If (nPos := Ascan(aGets,{ |x| Subs(x,9,10) == 'H6_RECURSO' } )) > 0
						aTela[Val(Subs(aGets[nPos],1,2))][Val(Subs(aGets[nPos],3,1))*2] := M->H6_RECURSO
					EndIf
				EndIf
				M->H6_PERDANT := A680PerdAnt(M->H6_OP, M->H6_OPERAC)
			EndIf

		ElseIf lVldOper

			//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			//ЁValida Sequencia atraves do Roteiro de Opera┤■es              Ё
			//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
			aOPs := {}
			//-- Array aOPs :
			//-- [n, 1   ] = Opera┤└o
			//-- [n, 2   ] = Quantidade Total j═ produzida
			dbSelectArea('SG2')
			cSeekSG2	:= "SG2->(G2_FILIAL+G2_PRODUTO+G2_CODIGO)"
			If !a630SeekSG2(1,M->H6_PRODUTO,xFilial('SG2')+M->H6_PRODUTO+cRoteiro,@cSeekSG2)
				Help(' ',1,'OPERACAO')
				RestArea(aAreaSG2)
				RestArea(aAreaAnt)
				lRet := .F.
			Else
				Do While !Eof() .And. Eval(&cSeekSG2) .And. G2_OPERAC <= M->H6_OPERAC

					//Valida a data de validade da operaГЦo.
					If lTudoOk
						If !Empty(SG2->G2_DTINI)
							If !Empty(M->H6_DATAINI) .And. SG2->G2_DTINI > fConvertDt(M->H6_DATAINI)
								SG2->(dbSkip())
								Loop
							EndIf
							If !Empty(M->H6_DATAFIN) .And. SG2->G2_DTINI > fConvertDt(M->H6_DATAFIN)
								SG2->(dbSkip())
								Loop
							EndIf
						EndIf
						If !Empty(SG2->G2_DTFIM)
							If !Empty(M->H6_DATAINI) .And. SG2->G2_DTFIM < fConvertDt(M->H6_DATAINI)
								SG2->(dbSkip())
								Loop
							EndIf
							If !Empty(M->H6_DATAFIN) .And. SG2->G2_DTFIM < fConvertDt(M->H6_DATAFIN)
								SG2->(dbSkip())
								Loop
							EndIf
						EndIf
					EndIf

					If (nPos := aScan(aOPs, {|x| x[1] == G2_OPERAC})) == 0
						//Validade Data ini e fim da Operacao
						IF  Empty(SG2->G2_DTFIM) .And. !SG2->G2_DTINI > fConvertDt(M->H6_DATAINI)
							aAdd(aOPs, {G2_OPERAC, 0})
						Else
							IF  (!SG2->G2_DTFIM < fConvertDt(M->H6_DATAINI) .And. !SG2->G2_DTINI > fConvertDt(M->H6_DATAINI)) .or. Empty(M->H6_DATAINI)
								aAdd(aOPs, {G2_OPERAC, 0})
							endif

						ENDIF

					EndIf
					dbSkip()
				EndDo

				fQtdOperac(M->H6_OP, M->H6_OPERAC,M->H6_QTDPROD,@aOPs)

				RestArea(aAreaSG2)
				RestArea(aAreaSH6)
			EndIf
		    If lRet
				If (nPos := aScan(aOPs, {|x| x[1] == M->H6_OPERAC})) > 0
					//If nPos > 1 .AND. IsInCallStack('A680TudoOk')
					If (nPos > 1 .AND. !lIntSFC) .Or. (nPos > 1 .AND. lIntSFC .And. IsInCallStack('A680TudoOk'))
						If lChkQtd .And. QtdComp(aOPs[nPos, 2]) > QtdComp(aOPs[nPos-1,2])
							If mv_par07 # 3
								Help(' ', 1, 'A680QUANT')
								RestArea(aAreaAnt)
								lRet := .F.
							EndIf
						ElseIf mv_par07 # 3 .And. QtdComp(aOPs[nPos-1,2]) == QtdComp(0)
							Help(' ',1,'FORAORDEM')
							RestArea(aAreaAnt)
							lRet := .F.
						EndIf
					EndIf
				Else
					Help(' ',1,'OPERACAO')
					RestArea(aAreaAnt)
					lRet := .F.
				EndIf
			EndIf

			If !lTudoOk .And. lCheckList .And. lRet
				lRet:= A680VldChk(M->H6_PRODUTO,cRoteiro,cOperacao)
			EndIf

			If lRet
				//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				//ЁPreenche o Recurso quando se digita a Operacao                Ё
				//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
				If !lTudoOk
					M->H6_RECURSO := SG2->G2_RECURSO
					If (nPos := Ascan(aGets,{ |x| Subs(x,9,10) == 'H6_RECURSO' } )) > 0
						aTela[Val(Subs(aGets[nPos],1,2))][Val(Subs(aGets[nPos],3,1))*2] := M->H6_RECURSO
					EndIf
				EndIf
				M->H6_PERDANT := A680PerdAnt(M->H6_OP, M->H6_OPERAC)
			EndIf
		EndIf
	EndIf

	If !lTudoOk .And. lRet .And. utilizaCRP()
		M->H6_TEMPO := A680Calc()
	EndIf

	RestArea(aAreaAnt)
Return lRet

/*/{Protheus.doc} fQtdOperac
	Prenche o array aOPs com as quantidades apontadas por operaГЦo.
	@type  Static Function
	@author mauricio.joao
	@since 26/07/2021
	@version 1.0
	@param cOp, character, Numero completo da ordem de produГЦo
	@param cOperac, character, Codigo da OperaГЦo
	@param nQtdPro, numeric, Quantidade apontada.
	@param aOPs, array, Array de operaГУes e quantidades.
/*/
Static Function fQtdOperac(cOp,cOperac,nQtdPro,aOPs)
Local cAliasSH6 := GetNextAlias()

//Gera a Query
BeginSql alias cAliasSH6

SELECT
	H6_OPERAC, SUM(H6_QTDPROD) QTDPROD, SUM(H6_QTDPERD) QTDPERD
FROM
	%table:SH6% SH6
WHERE
	SH6.H6_FILIAL = %xfilial:SH6% AND
	SH6.H6_OP = %Exp:cOp% AND
	SH6.H6_OPERAC <= %Exp:cOperac% AND
	SH6.%notDel%
GROUP BY
	SH6.H6_OPERAC
EndSql

While (cAliasSH6)->(!Eof())
	If (nPos := aScan(aOPs, {|x| x[1] == (cAliasSH6)->H6_OPERAC})) > 0
		aOPs[nPos, 2] += (cAliasSH6)->QTDPROD+If(mv_par07#2, (cAliasSH6)->QTDPERD, 0)
	Else
		If !(l680Auto .Or. l681Auto)
			Aviso(STR0063, STR0064 + H6_OPERAC + STR0065 + H6_OP + '-' + H6_IDENT + '.',{STR0066})  //'Aviso'###'A Opera┤└o '###' n└o esta cadastrada, mas foi utilizada na OP No. '###'Continua'
		Endif
		aAdd(aOPs, {(cAliasSH6)->H6_OPERAC, (cAliasSH6)->QTDPROD+If(mv_par07#2, (cAliasSH6)->QTDPERD, 0)})
	EndIf
	(cAliasSH6)->(DbSkip())
Enddo
//Fecha a tabela
(cAliasSH6)->(DbCloseArea())

aSort(aOPs,,, {|x,y| y[1] > x[1]})
aEval(aOPs,{|x|If(x[1]==cOperac,x[2]+=nQtdPro,0)})

Return


/*/{Protheus.doc} fConvertDt
	Valida caso a data seja do tipo String realiza a conversЦo para o tipo Date.
	@type  Static Function
	@author mauricio.joao
	@since 21/01/2021
	@version 1.0
	@param xDate,, Data para ser validada e convertida
	@return dDate, date, Data convertida.
	/*/
Static Function fConvertDt(xDate)
Local dDate as date

	If valtype(xDate) <> "D"
		dDate := STOD(xDate)
	Else
		dDate := xDate
	EndIf

Return dDate

/*
эээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбдддддддддддбдддддддбддддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤┘o    ЁA680UltOperЁ Autor Ё Ary Medeiros         Ё Data Ё 16/09/96 Ё╠╠
╠╠цддддддддддедддддддддддадддддддаддддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤┘o Ё Faz consistencia na digitacao do Operacao no apontamento   Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁSintaxe   Ё A680UltOper(lMemory)                                       Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁParametrosЁ lMemory-> Variavel logica que define se os dados a serem   Ё╠╠
╠╠Ё          Ё           considerados estao em memoria ou nao             Ё╠╠
╠╠Ё          ЁlPergunta -> Variavel lСgica que define se pergunta se И    Ё╠╠
╠╠Ё          Ё              ultima operaГЦo                               Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ
*/
Function A680UltOper(lMemory,lPergunta)
Local aAlias	:= GetArea()
Local aAreaSH8	:= {}
Local cRoteiro	:= "",cFirstVld := ""
Local lRet		:=.T.
Local lRefGrd	:= .F.
Local lVldOper	:=(GetMV("MV_VLDOPER") == "S")
Local cOp		:="",cOperac:="",cDesdobr:="",cProduto:=""
Local aAreaSG2  :={}
Local lIntSFC	:= FindFunction('IntegraSFC') .And. IntegraSFC() //.And. !IsInCallStack("AUTO681")
Local lProces   := SuperGetMV("MV_APS",.F.,"") == "TOTVS" .Or. lIntSFC .OR. SuperGetMV("MV_PCPATOR",.F.,.F.) == .T.
Local lValido   := .t.

lMemory:=If(lMemory==NIL,.F.,lMemory)

cOp     :=If(lMemory,M->H6_OP,SH6->H6_OP)
cOperac :=If(lMemory,M->H6_OPERAC,SH6->H6_OPERAC)
cDesdobr:=If(lMemory,M->H6_DESDOBR,SH6->H6_DESDOBR)
cProduto:=If(lMemory,M->H6_PRODUTO,SH6->H6_PRODUTO)
dDataIni:=If(lMemory,M->H6_DATAINI,SH6->H6_DATAINI)
dDataFim:=If(lMemory,M->H6_DATAFIN,SH6->H6_DATAFIN)
lMES:=AllTrim(If(lMemory,M->H6_OBSERVA,SH6->H6_OBSERVA))=="TOTVSMES"

If l680
	// Verifica ultima operacao atraves da Carga Maquina Alocada
	dbSelectArea("SH8")
	aAreaSH8:=GetArea()
	dbSetOrder(1)
	cFirstVld:=xFilial("SH8")+cOp
	dbSeek(xFilial("SH8")+cOp+cOperac)
	While !Eof() .And. xFilial("SH8")+cOp+cOperac == SH8->H8_FILIAL+SH8->H8_OP+SH8->H8_OPER
		dbSkip()
	End
	If !Eof() .And. SH8->H8_FILIAL+SH8->H8_OP == cFirstVld
		lRet:=.F.
	EndIf
	RestArea(aAreaSH8)
Else
	If l681 .And. !lVldOper .And. !lMES //Se for TOTVS MES, irА validar as operaГУes independente do parБmetro MV_VLDOPER
		lRet:=A680AskUlt(lPergunta)
		lUltOper:=lRet
	Else
		// Verifica ultima operacao atraves do Roteiro de Operacoes
		dbSelectArea("SC2")
		dbSetOrder(1)
		dbSeek(xFilial("SC2")+cOp)
		If Empty(SC2->C2_ROTEIRO)
			dbSelectArea("SB1")
			dbSeek(xFilial("SB1")+cProduto)
			If !Empty(SB1->B1_OPERPAD)
				cRoteiro:=SB1->B1_OPERPAD
			Else
				cRoteiro:="01"
			EndIf
		Else
			cRoteiro:=SC2->C2_ROTEIRO
		EndIf

		If lProces
			dbSelectArea("SHY")
			SHY->(dbSetOrder(1))
			If SHY->(dbSeek(xFilial("SHY")+cOp+cRoteiro+cOperac))
				SHY->(dbSkip())
				If Alltrim(cOp) == Alltrim(SHY->HY_OP) .AND. cRoteiro == SHY->HY_ROTEIRO
					lRet:=.F.
				EndIf
			Else
				//NЦo encontrou na SHY
				//Validar na SG2
				dbSelectArea("SG2")

				aAreaSG2 := GetArea()

				If a630SeekSG2(1,cProduto,xFilial("SG2")+cProduto+cRoteiro+cOperac,,@lRefGrd)
					SG2->(dbSkip())

					While !SG2->(Eof()) .AND. SG2->G2_FILIAL+SG2->G2_PRODUTO+SG2->G2_CODIGO == xFilial("SG2")+cProduto+cRoteiro

						lValido := .t.

						If !Empty(SG2->G2_DTINI)
							If !Empty(dDataIni) .And. SG2->G2_DTINI > dDataIni
								lValido := .f.
							EndIf
							If !Empty(dDataFim) .And. SG2->G2_DTINI > dDataFim
								lValido := .f.
							EndIf
						EndIf
						If !Empty(SG2->G2_DTFIM)
							If !Empty(dDataIni) .And. SG2->G2_DTFIM < dDataIni
								lValido := .f.
							EndIf
							If !Empty(dDataFim) .And. SG2->G2_DTFIM < dDataFim
								lValido := .f.
							EndIf
						EndIf

						If lValido
							Exit
						Else
							SG2->(dbSkip())
						EndIf
					End

					If lRefGrd
						If !Empty(ALLTRIM(G2_REFGRD) ).AND. RTrim(G2_REFGRD) == PadR(cProduto,Len(RTrim(G2_REFGRD))) .And. G2_CODIGO == cRoteiro
							lRet:=.F.
						EndIf
					Else
						If G2_PRODUTO == cProduto .And. G2_CODIGO == cRoteiro
							lRet:=.F.
						EndIf
					EndIf
				EndIf

				RestArea(aAreaSG2)
			EndIf
		Else
			dbSelectArea("SG2")

			aAreaSG2 := GetArea()

			If a630SeekSG2(1,cProduto,xFilial("SG2")+cProduto+cRoteiro+cOperac,,@lRefGrd)
				SG2->(dbSkip())

				While !SG2->(Eof()) .AND. SG2->G2_FILIAL+SG2->G2_PRODUTO+SG2->G2_CODIGO == xFilial("SG2")+cProduto+cRoteiro

					lValido := .t.

					If !Empty(SG2->G2_DTINI)
						If !Empty(dDataIni) .And. SG2->G2_DTINI > dDataIni
							lValido := .f.
						EndIf
						If !Empty(dDataFim) .And. SG2->G2_DTINI > dDataFim
							lValido := .f.
						EndIf
					EndIf
					If !Empty(SG2->G2_DTFIM)
						If !Empty(dDataIni) .And. SG2->G2_DTFIM < dDataIni
							lValido := .f.
						EndIf
						If !Empty(dDataFim) .And. SG2->G2_DTFIM < dDataFim
							lValido := .f.
						EndIf
					EndIf

					If lValido
						Exit
					Else
						SG2->(dbSkip())
					EndIf
				End

				If lRefGrd
					If !Empty(ALLTRIM(G2_REFGRD) ).AND. RTrim(G2_REFGRD) == PadR(cProduto,Len(RTrim(G2_REFGRD))) .And. G2_CODIGO == cRoteiro
						lRet:=.F.
					EndIf
				Else
					If G2_PRODUTO == cProduto .And. G2_CODIGO == cRoteiro
						lRet:=.F.
					EndIf
				EndIf
			EndIf


			RestArea(aAreaSG2)

		EndIf
	EndIf
EndIf
RestArea(aAlias)
Return lRet

/*
эээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤┘o    Ё A680Calc Ё Autor Ё Ary Medeiros          Ё Data Ё 16/09/96 Ё╠╠
╠╠цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤┘o Ё Calcula tempo gasto na operacao                            Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ
*/
Function A680Calc()
	Static cTpHr
	Local cTime      :=""
	Local nTempoCen  :=0
	Local lUsaCalend := GetMV("MV_USACALE",, .T.)
	Local cForHora   := If(mv_par03 == 1, "N", "C")
	Local nZeros     := At(":", PesqPict("SH6", "H6_TEMPO")) - 1
	Local lApsInUse  := SuperGetMv("MV_APS",.F.,"") $ "DRUMMER*TOTVS"
	Local cTimeIni   := ""
	Local cTimeFim   := ""

	If cTpHr == Nil
		cTpHr := GetMv("MV_TPHR")
	EndIf

	If lApsInUse .And. l680
		SH1->(dbSetOrder(1))
		If SH1->(dbSeek(xFilial("SH1")+M->H6_RECURSO))
			nTempoCen:=A680TimeCale(M->H6_DATAINI,A680ConvHora(M->H6_HORAINI, cForHora),M->H6_DATAFIN,A680ConvHora(M->H6_HORAFIN, cForHora),M->H6_RECURSO)
		Else
			nTempoCen:=0
		EndIf
	ElseIf l680
		nTempoCen := Transform(R815Dur(M->H6_RECURSO,M->H6_DATAFIN,A680ConvHora(M->H6_HORAFIN, cForHora),M->H6_DATAINI,A680ConvHora(M->H6_HORAINI, cForHora)), "")
		nTempoCen := Val(StrTran(nTempoCen, ":", "."))
	ElseIf utilizaCRP() .And. MATA681ApontamentoCRP():opOperacaoProgramadas(M->H6_OP, M->H6_OPERAC)
		nTempoCen := MATA681ApontamentoCRP():buscaTempoProgramado(M->H6_OP, M->H6_OPERAC, M->H6_RECURSO, M->H6_DATAINI, M->H6_HORAINI, M->H6_DATAFIN, M->H6_HORAFIN, lUsaCalend)
	Else
		If lUsaCalend
			If !Empty(M->H6_RECURSO)
				SH1->(dbSetOrder(1))
				If SH1->(dbSeek(xFilial("SH1")+M->H6_RECURSO))
					nTempoCen:= A680calen(M->H6_DATAINI,M->H6_DATAFIN,M->H6_RECURSO,A680ConvHora(M->H6_HORAINI, cForHora),A680ConvHora(M->H6_HORAFIN, cForHora))
				Else
					nTempoCen:=0
				EndIf
			EndIf
		Else
			cTimeIni := IIF(cForHora == "N", A680ConvHora(M->H6_HORAINI, cForHora),M->H6_HORAINI)
			cTimeFim := IIF(cForHora == "N", A680ConvHora(M->H6_HORAFIN, cForHora),M->H6_HORAFIN)
			nTempoCen := A680Tempo(M->H6_DATAINI, cTimeIni   , M->H6_DATAFIN, cTimeFim )
		EndIf
	EndIf

	cTime := If(A780RetInt(nTempoCen),StrZero(nTempoCen, nZeros),StrZero(Int(nTempoCen), nZeros)) + ":" + StrZero(Mod(nTempoCen, 1) * 100, 2)

	If l680
		cTime := A680ConvHora(cTime, cTpHr, cForHora)
	Else
		cTime := A680ConvHora(cTime, "C", cForHora)
	EndIf

Return cTime

/*
эээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤┘o    ЁA680ITempoЁ Autor ЁRodrigo de A. Sartorio Ё Data Ё 04/09/97 Ё╠╠
╠╠цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤┘o Ё Inicializa tempo gasto na operacao                         Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ
*/
Function A680ITempo()
LOCAL cTime:="",cAlias:=Alias(),nRecno
Local cForHora   := If(mv_par03 == 1, "N", "C")
Local cTpHr      := SuperGetMv("MV_TPHR")
Local nZeros     := At(":", PesqPict("SH6", "H6_TEMPO")) - 1
Local nTempoCen  :=0
Local lApsInUse  := SuperGetMv("MV_APS",.F.,"") $ "DRUMMER*TOTVS"
dbSelectArea("SH8")
nRecno:=Recno()

If lApsInUse
	SH1->(dbSetOrder(1))
	If SH1->(dbSeek(xFilial("SH1")+M->H6_RECURSO))
		nTempoCen:=A680TimeCale(M->H6_DATAINI,A680ConvHora(M->H6_HORAINI, cForHora),M->H6_DATAFIN,A680ConvHora(M->H6_HORAFIN, cForHora),M->H6_RECURSO)
	Else
		nTempoCen:=0
	EndIf
Else
	If dbSeek(xFilial("SH8")+M->H6_OP+M->H6_OPERAC)
		nTempoCen := Transform(R815Dur(M->H6_RECURSO,M->H6_DATAFIN,A680ConvHora(M->H6_HORAFIN, cForHora),M->H6_DATAINI,A680ConvHora(M->H6_HORAINI, cForHora)), "")
		nTempoCen := Val(StrTran(nTempoCen, ":", "."))
	EndIf
EndIf

cTime := StrZero(Int(nTempoCen), nZeros) + ":" + StrZero(Mod(nTempoCen, 1) * 100, 2)

If lApsInUse
	cTime := A680ConvHora(cTime, "C", cForHora)
Else
	cTime := A680ConvHora(cTime, cTpHr, cForHora)
EndIf

dbGoto(nRecno)
dbSelectArea(cAlias)
Return cTime

/*
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤┘o    Ё A680Data Ё Autor Ё Jose Lucas            Ё Data Ё 28.10.93 Ё╠╠
╠╠цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤┘o Ё Faz a consistencia da data Final digitada                  Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁSintaxe   Ё A680Data()                                                 Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠Ё Uso      Ё MatA680                                                    Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ
*/
Function A680Data()
Local lRet := .T.,nEndereco:=0

//Tratamento para totvs Mes quando vem data em branco
If IsInCallStack("MATI681") .AND. (Empty(M->H6_DATAFIN) .OR. Empty(M->H6_DATAINI))
	//limpo os dois campos.
	M->H6_DATAFIN := stod('')
	M->H6_DATAINI := stod('')
EndIf

If M->H6_DATAFIN < M->H6_DATAINI
	Help(" ",1,"A680DATA")
	lRet := .F.
EndIf

If lRet .And. !Empty(M->H6_DATAINI) .And. !Empty(M->H6_DATAFIN) .And. !Empty(M->H6_HORAINI) .And. !Empty(M->H6_HORAFIN)
	If (DTOS(M->H6_DATAINI) + M->H6_HORAINI) >= (DTOS(M->H6_DATAFIN) + M->H6_HORAFIN)
		Help(" ",1,"A680Hora")
		lRet := .F.
	EndIf
EndIf

If lRet
	M->H6_TEMPO := A680Calc()
	nEndereco := Ascan(aGets,{ |x| Subs(x,9,10) == "H6_TEMPO  " } )
	If nEndereco > 0
		aTela[Val(Subs(aGets[nEndereco],1,2))][Val(Subs(aGets[nEndereco],3,1))*2] := M->H6_TEMPO
	EndIf

	If Val(M->H6_TEMPO)<0
		Help(" ",1,"A680Hora")
		lRet := .F.
	EndIf
EndIf

If !l680Auto .And. SuperGetMv("MV_BLQREC", .F., 0) != 0
	lRet := A680Hora()
EndIf

Return( lRet )

/*
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤┘o    Ё A680Hora Ё Autor Ё Rodrigo de A. SartorioЁ Data Ё 25.09.96 Ё╠╠
╠╠цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤┘o Ё Faz a consistencia dos Horarios digitados.                 Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁSintaxe   Ё A680Hora()                                                 Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠Ё Uso      Ё Mata680                                                    Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ
*/
Function A680Hora()
Local lRet   := .T.
Local cCampo := ReadVar()
Local nBlqRec := SuperGetMv("MV_BLQREC", .F., 0)
Local nEndereco
Local nHora,nMinutos
Local nPos

	//Substitui espacos em branco por "0"
	If ReadVar() == "M->H6_HORAFIN" .Or. ReadVar() == "M->H6_HORAINI"
		&(ReadVar()) := StrTran(&(ReadVar())," ", "0")
	EndIf

	If nBlqRec == 1 .Or. nBlqRec == 2 .And. lRet

    	If cCampo == "M->H6_OP" .Or. cCampo == "M->H6_RECURSO" .Or. cCampo == "M->H6_DATAINI" .Or. cCampo == "M->H6_DATAFIN" .Or. cCampo == "M->H6_HORAINI" .Or. cCampo == "M->H6_HORAFIN"

    	    If (!Empty(M->H6_RECURSO) .And. !Empty(M->H6_DATAINI) .And. !Empty(M->H6_DATAFIN)) .And. (!Empty(M->H6_HORAINI) .And. !Empty(M->H6_HORAFIN))
				SC2->(dbSetOrder(1))
				SC2->(dbSeek(xFilial("SC2")+M->H6_OP))

				lRet := verBlqRec(M->H6_RECURSO, M->H6_DATAINI, M->H6_DATAFIN, M->H6_HORAINI, M->H6_HORAFIN, SC2->C2_CC)

    	    EndIf
		EndIf
	EndIf

If cCampo == "M->H6_HORAFIN" .Or. cCampo == "M->H6_HORAINI" .Or. cCampo == "M->H6_OP" .And. lRet
	If cCampo == "M->H6_HORAFIN"
		nPos:=AT(":",M->H6_HORAFIN)
	Else
		nPos:=AT(":",M->H6_HORAINI)
	EndIf
	If mv_par03 == 1
		If (cCampo == "M->H6_HORAFIN" .Or. cCampo == "M->H6_HORAINI") .And. (Val(Substr(&(ReadVar()),nPos-2,2)) > 24 .Or. Val(Substr(&(ReadVar()),nPos+1,2)) > 59)
			Help(" ",1,"A680HRINVL")
			lRet := .f.
		ElseIf (cCampo == "M->H6_HORAFIN" .Or. cCampo == "M->H6_HORAINI") .And. (Val(Substr(&(ReadVar()),nPos-2,2)) == 24 .And. Val(Substr(&(ReadVar()),nPos+1,2)) > 0)
			Help(" ",1,"A680HRINVL")
		    lRet := .f.
        Else
			If (cCampo == "M->H6_HORAFIN" .Or. cCampo == "M->H6_HORAINI")
				nHora:=Val(Substr(&(ReadVar()),1,nPos-1))
				nMinutos:=Val(Substr(&(ReadVar()),nPos+1,2))
				If nHora != 0 .And. nMinutos != 0 .And. nPos != 0
					&(ReadVar()):=StrZero(nHora,nPos-1)+":"+StrZero(nMinutos,2)
				EndIf
				nEndereco := Ascan(aGets,{ |x| Subs(x,9,10) == cCampo } )
				If nEndereco > 0
					aTela[Val(Subs(aGets[nEndereco],1,2))][Val(Subs(aGets[nEndereco],3,1))*2] := &(ReadVar())
				EndIf
			EndIf
		EndIf
	Else
		If (cCampo == "M->H6_HORAFIN" .Or. cCampo == "M->H6_HORAINI") .And. (Val(Substr(&(ReadVar()),nPos-2,2)) > 24 .Or. (Val(Substr(&(ReadVar()),nPos-2,2)) == 24 .And. Val(Substr(&(ReadVar()),nPos+1,2)) > 0))
			Help(" ",1,"A680HRINVL")
			lRet := .f.
		EndIf
	EndIf
	If (cCampo == "M->H6_HORAFIN" .Or. cCampo == "M->H6_HORAINI") .And. (!Empty(M->H6_HORAFIN) .And. M->H6_HORAFIN <= M->H6_HORAINI .And. M->H6_DATAFIN == M->H6_DATAINI .And. lRet)
		Help(" ",1,"A680Hora")
		lRet := .F.
	EndIf
	If lRet
		M->H6_TEMPO := A680Calc()
		nEndereco := Ascan(aGets,{ |x| Subs(x,9,10) == "H6_TEMPO  " } )
		If nEndereco > 0
			aTela[Val(Subs(aGets[nEndereco],1,2))][Val(Subs(aGets[nEndereco],3,1))*2] := M->H6_TEMPO
		EndIf
	EndIf
ElseIf cCampo == "M->H6_TEMPO"
	nPos:=AT(":",M->H6_TEMPO)
	If nPos == 0
		nPos:=AT(":",PesqPict("SH6","H6_TEMPO"))
	EndIf
	If mv_par03 == 1
	If Val(Substr(M->H6_TEMPO,1,nPos-1)) < 999
		If Val(Substr(M->H6_TEMPO,nPos+1,2)) >= 60
			nHora:=Val(Substr(M->H6_TEMPO,1,nPos-1))+1
			nMinutos:=Val(Substr(M->H6_TEMPO,nPos+1,2))-60
			M->H6_TEMPO:=StrZero(nHora,nPos-1)+":"+StrZero(nMinutos,2)
			nEndereco := Ascan(aGets,{ |x| Subs(x,9,10) == "H6_TEMPO  " } )
			If nEndereco > 0
				aTela[Val(Subs(aGets[nEndereco],1,2))][Val(Subs(aGets[nEndereco],3,1))*2] := M->H6_TEMPO
			EndIf
		EndIf
	Else
		If Val(Substr(M->H6_TEMPO,nPos+1,2)) >= 60
			Help(" ",1,"H6_TEMPO")
			lRet:=.F.
		EndIf
	EndIf
EndIf
EndIf
If Val(M->H6_TEMPO)<0
	lRet:=.F.
EndIf

//зддддддддддддддддддддддддддддддддддд©
//ЁSubstitui espacos em branco por "0"Ё
//юддддддддддддддддддддддддддддддддддды
/*If lRet
	If ReadVar() == "M->H6_HORAFIN" .Or. ReadVar() == "M->H6_HORAINI"
		&(ReadVar()) := StrTran(&(ReadVar())," ", "0")
	EndIf
EndIf
*/
Return(lRet)

/*
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤┘o    Ё A680QuantЁ Autor Ё Marcelo Bomura Abe    Ё Data Ё 20.01.94 Ё╠╠
╠╠цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤┘o Ё Faz a consistencia da Quantidade Digitada                  Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁSintaxe   Ё A680Quant()                                                Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠Ё Uso      Ё MatA680                                                    Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ
*/
Function A680Quant(lTudoOk)

Local aAreaSC2	:= {}
Local aDados	:= {0,"T"}
Local aOperAnt	:= A680OperAnt()
Local cOperac   := ""
Local cOperAnt	:= aOperAnt[1]
Local cSeqAnt	:= aOperAnt[2]
Local lBotSalvar:= .F.
Local lFirst    := .T.
Local lIntACD   := SuperGetMV("MV_INTACD",.F.,"0") == "1" .And. (IsInCallStack("ACDV025") .Or. IsInCallStack("ACDV023"))
Local lParcTotal:= SuperGetMV("MV_PARTOT",.F.,.F.)
Local lRet		:= .T.
Local nOrder    := SH6->(IndexOrd())
Local nProdProp	:= GetMV("MV_PRODPR0",NIL,1)
Local nQtdTela	:= 0
Local nQuant1   := 0
Local nQuant2   := 0
Local nQuant2D  := 0
Local nQuantD   := 0
Local nRecno    := SH6->(Recno())
Local nRecOrig  := 0

DEFAULT lTudoOk	:= .F.


If ReadVar() == 'M->H6_QTDPRO2'
	nQtdTela += ConvUM(M->H6_PRODUTO,M->H6_QTDPROD,M->H6_QTDPRO2,1)
Else
	nQtdTela += M->H6_QTDPROD
EndIf
nQtdTela += If((l680 .Or. l681) .And. !lPerdInf,M->H6_QTDPERD,0)

If l680 .Or. l681
	// Verificar se Existem Operacoes Anteriores do mesmo produto

	If cOperAnt # Nil .And. cSeqAnt # Nil
		aDados:=A680SldOper(.F.,mv_par07 == 1,.T.)
		nQuant2:=aDados[1]
		If mv_par07 # 3 .And. nQtdTela+A680SldProd(.T., mv_par07 == 1, .T.) > nQuant2
			Help(" ",1,"A680QUANT")
			lRet := .F.
		EndIf
	EndIf
EndIf

If lRet
	If l680
		//Atualizar campo TOTAL / PARCIAL
		lBotSalvar := IsInCallStack("SAFEEVAL")
		If  (((ReadVar() =='M->H6_QTDPROD' .Or. ReadVar() == 'M->H6_QTDPRO2' .Or. ReadVar() == 'M->H6_QTDPERD' .Or. ReadVar() == 'M->H6_OP') .And. !lBotSalvar;
		     .Or. EMPTY(M->H6_PT)))

			If (!l681Auto .And. !l680Auto) .Or. ( (l681Auto .Or. l680Auto) .And. Empty(M->H6_PT))
				If (l681Auto .Or. l680Auto)
					M->H6_PT := If(QtdComp(nQtdTela) < QtdComp(A680SldProd(.T.,!lPerdInf .Or. mv_par07 == 2)) .Or. QtdComp(nQtdTela+A680SldProd(.T., mv_par07 == 1, .T.)) < QtdComp(nQuant2) .Or. (QtdComp(nQtdTela+A680SldProd(.T., mv_par07 == 1, .T.)) <= QtdComp(nQuant2) .And. aDados[2] == "P") .Or. (QtdComp(nQtdTela) == QtdComp(nQuant2) .And. aDados[2] == "P"), "P", "T")
				Else
					If lPerdInf
						M->H6_PT := If(QtdComp(nQtdTela) < QtdComp(A680SldProd(.T.,!lPerdInf .Or. mv_par07 == 2)) .Or. QtdComp(nQtdTela+A680SldProd(.T., mv_par07 == 1, .T.)) < QtdComp(nQuant2) .Or. (QtdComp(nQtdTela+A680SldProd(.T., mv_par07 == 1, .T.)) <= QtdComp(nQuant2) .And. aDados[2] == "P") .Or. (QtdComp(nQtdTela) == QtdComp(nQuant2) .And. aDados[2] == "P"), "P", "T")
					Else
						M->H6_PT := If(QtdComp(nQtdTela) < QtdComp(A680SldProd(.T.,!lPerdInf .Or. mv_par07 == 2)) .Or. QtdComp(nQtdTela+A680SldProd(.T., mv_par07 == 1, .T.)) < QtdComp(nQuant2) .Or. (QtdComp(nQtdTela+A680SldProd(.T., mv_par07 == 1, .T.)) <= QtdComp(nQuant2) .And. aDados[2] == "P") .Or. (QtdComp(nQtdTela) == QtdComp(nQuant2) .And. aDados[2] == "P"), "P", "T")
					EndIf
				EndIf
			EndIf

			//Garante que o campo Parc./Total seja preenchido quando informada a OP
			IF EMPTY(M->H6_PT)
				M->H6_PT := If(QtdComp(nQtdTela) < QtdComp(A680SldProd(.T.,!lPerdInf .Or. mv_par07 == 2)) .Or. QtdComp(nQtdTela+A680SldProd(.T., mv_par07 == 1, .T.)) < QtdComp(nQuant2) .Or. (QtdComp(nQtdTela+A680SldProd(.T., mv_par07 == 1, .T.)) <= QtdComp(nQuant2) .And. aDados[2] == "P") .Or. (QtdComp(nQtdTela) == QtdComp(nQuant2) .And. aDados[2] == "P"), "P", "T")
			ENDIF

			nEndereco := Ascan(aGets,{ |x| Subs(x,9,5) == "H6_PT" } )
			If nEndereco > 0
				aTela[Val(Subs(aGets[nEndereco],1,2))][Val(Subs(aGets[nEndereco],3,1))*2] := M->H6_PT
			EndIf
		EndIF
	ElseIf l681
		//Atualizar campo TOTAL / PARCIAL
		lBotSalvar := IsInCallStack("SAFEEVAL")
		SC2->(dbSetOrder(1))
		If SC2->(dbSeek(xFilial("SC2")+M->H6_OP)) .And. ;
		   (((ReadVar() =='M->H6_QTDPROD' .Or. ReadVar() == 'M->H6_QTDPRO2' .Or. ReadVar() == 'M->H6_QTDPERD' .Or. ReadVar() == 'M->H6_OP');
		    .And. (!lBotSalvar .Or. lParcTotal) .Or. EMPTY(M->H6_PT)))

			If (!l681Auto .And. !l680Auto) .Or. ( (l681Auto .Or. l680Auto) .And. Empty(M->H6_PT))
				If (l681Auto .Or. l680Auto)
					M->H6_PT := If(QtdComp(nQtdTela) < QtdComp(A680SldProd(.T.,!lPerdInf .Or. mv_par07 == 2)) .Or. QtdComp(nQtdTela+A680SldProd(.T., mv_par07 == 1, .T.)) < QtdComp(nQuant2) .Or. (QtdComp(nQtdTela+A680SldProd(.T., mv_par07 == 1, .T.)) <= QtdComp(nQuant2) .And. aDados[2] == "P") .Or. (QtdComp(nQtdTela) == QtdComp(nQuant2) .And. aDados[2] == "P"), "P", "T")
				Else
					If lPerdInf
						M->H6_PT := If(QtdComp(nQtdTela) < QtdComp(A680SldProd(.T.,!lPerdInf .Or. mv_par07 == 2)) .Or. QtdComp(nQtdTela+A680SldProd(.T., mv_par07 == 1, .T.)) < QtdComp(nQuant2) .Or. (QtdComp(nQtdTela+A680SldProd(.T., mv_par07 == 1, .T.)) <= QtdComp(nQuant2) .And. aDados[2] == "P") .Or. (QtdComp(nQtdTela) == QtdComp(nQuant2) .And. aDados[2] == "P"), "P", "T")
					Else
						M->H6_PT := If(QtdComp(nQtdTela) < QtdComp(A680SldProd(.T.,!lPerdInf .Or. mv_par07 == 2)) .Or. QtdComp(nQtdTela+A680SldProd(.T., mv_par07 == 1, .T.)) < QtdComp(nQuant2) .Or. (QtdComp(nQtdTela+A680SldProd(.T., mv_par07 == 1, .T.)) <= QtdComp(nQuant2) .And. aDados[2] == "P") .Or. (QtdComp(nQtdTela) == QtdComp(nQuant2) .And. aDados[2] == "P"), "P", "T")
					EndIf
				Endif
			EndIf

			//Garante que o campo Parc./Total seja preenchido quando informada a OP
			IF EMPTY(M->H6_PT)
				M->H6_PT := If(QtdComp(nQtdTela) < QtdComp(A680SldProd(.T.,!lPerdInf .Or. mv_par07 == 2)) .Or. QtdComp(nQtdTela+A680SldProd(.T., mv_par07 == 1, .T.)) < QtdComp(nQuant2) .Or. (QtdComp(nQtdTela+A680SldProd(.T., mv_par07 == 1, .T.)) <= QtdComp(nQuant2) .And. aDados[2] == "P") .Or. (QtdComp(nQtdTela) == QtdComp(nQuant2) .And. aDados[2] == "P"), "P", "T")
			ENDIF

			nEndereco := Ascan(aGets,{ |x| Subs(x,9,5) == "H6_PT" } )
			If nEndereco > 0
				aTela[Val(Subs(aGets[nEndereco],1,2))][Val(Subs(aGets[nEndereco],3,1))*2] := M->H6_PT
			EndIf
		EndIf
	EndIf
	If ReadVar()=='M->H6_QTDPROD'
		nQuantD  := &(ReadVar())
		nQuant2D := ConvUM(M->H6_PRODUTO,nQuantD,M->H6_QTDPRO2,2)
		M->H6_QTDPRO2 := nQuant2D
	ElseIf ReadVar()=='M->H6_QTDPRO2'
		nQuant2D:= &(ReadVar())
		nQuantD := ConvUM(M->H6_PRODUTO,M->H6_QTDPROD,nQuant2D,1)
		M->H6_QTDPROD := nQuantD
	EndIf
	nEndereco := Ascan(aGets,{ |x| Subs(x,9,9) == "H6_RATEIO" } )
	If (lIntACD .Or. nEndereco > 0) .And. Empty(M->H6_RATEIO) .And. !lTudoOk .And. nProdProp == 2
		aAreaSC2:=SC2->(GetArea())
		SC2->(dbsetOrder(1))
		If SC2->(dbSeek(xFilial("SC2")+M->H6_OP))
			M->H6_RATEIO := (M->H6_QTDPROD / SC2->C2_QUANT) * 100
			If !lIntACD
				aTela[Val(Subs(aGets[nEndereco],1,2))][Val(Subs(aGets[nEndereco],3,1))*2] := M->H6_RATEIO
			EndIf
		EndIf
		SC2->(RestArea(aAreaSC2))
	EndIf
EndIf

nQntProd	:= M->H6_QTDPROD
nQntPerd	:= M->H6_QTDPERD

dbSelectArea("SH6")
dbSetOrder(nOrder)
dbGoTo(nRecno)
Return lRet

/*
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤└o    ЁA680TudoOkЁ Autor Ё Waldemiro L. Lustosa  Ё Data Ё 24/05/95 Ё╠╠
╠╠цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤┘o Ё Programa que faz consistencias apos a digitacao da tela    Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠Ё Uso      Ё MATA680                                                    Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ
*/
Function A680TudoOk()
	Local aArea       := GetArea()
	Local aAreaSC2    := SC2->(GetArea())
	Local aBaixaSGF   := Nil
	Local aChkBaixaC  := Nil
	Local aRetPE      := {}
	Local cAliAnt     := Alias()
	Local cAliasQry   := ""
	Local cAliasSld   := GetNextAlias()
	Local cCampo      := ReadVar()
	Local cIniDoc     := ""
	Local cMens       := ''
	Local cOpAtual    := ""
	Local cParData    := SuperGetMV("MV_DTAPT",.F.,2)
	Local cProdMod    := ""
	Local cProduto    := ""
	Local cQipMat     := SuperGetMV("MV_QIPMAT",.F.,"N")
	Local cQuant      := ''
	Local cQuery      := ""
	Local cTmPad      := ""
	Local dDataMovto  := ""
	Local i           := 0
	Local lA250SPRC  ═:= NIL
	Local lAponta     := GetMV("MV_QINSPEC",.T.,"1") == '2'
	Local lAponTemp   := IIF(MV_PAR04 == 1 .AND. !Empty(M->H6_HORAINI) .AND. !Empty(M->H6_HORAFIN) .AND. M->H6_QTDPROD == 0 .AND. M->H6_QTDPERD == 0,.T.,.F.)
	Local lChkSaldo   := Nil
	Local lEnvCQProd  := .f.
	Local lErrBlqMov  := .F.
	Local lErrInvent  := .F.
	Local lErrLote    := .F.
	Local lErrSaldo   := .F.
	Local lFifoEnd    := SuperGetMV("MV_FIFOEND",.F.,.T.)  //aceita fifo na req. de endereГo.
	Local lGProd      := SuperGetMV("MV_GANHOPR",.F.,.T.)
	Local lH6_LOCAL   := !Empty(M->H6_LOCAL)
	Local lIntQIP     := IntQIP(M->H6_PRODUTO,"2")
	Local lIntSFC     := IntegraSFC() //.And. !IsInCallStack("AUTO681")
	Local lIntSFCAut  := IntegraSFC() .And. IsInCallStack("AUTO681")
	Local lM680VldPT  := .T.
	Local lMes        := AllTrim(M->H6_OBSERVA)=="TOTVSMES"
	Local lModCYN	  := .T.
	Local lModRecPCP  := FindFunction('ModRecPCP')
	Local lMT680FINAL := ExistBlock("MT680FINAL")
	Local lMT680Val   := ExistBlock("MT680VAL")
	Local lOK         := .T.
	Local lPergWMS    := .T.
	Local lProdMaior  := SuperGetMV("MV_PERCPRM",.F., 0) > 0
	Local lRet        := .T.
	Local lSC2Found   := .F.
	Local lSemSaldo   := .F.
	Local lUltOper    := If(!l682,A680UltOper(.T.,.T.),.F.)
	Local lValOpSusp  := SuperGetMV("MV_OPSUSP",.F.,.T.)
	Local lWmsNew     := SuperGetMv("MV_WMSNEW",.F.,.F.)
	Local nBlqRec 	  := SuperGetMv("MV_BLQREC", .F., 0)
	Local ni          := 0
	Local nPercPrM    := 0
	Local nPrapont    := SuperGetMV("MV_PRAPONT",.F.,2)   // padrЦo default 2
	Local nProdProp   := GetMV("MV_PRODPR0",NIL,1)
	Local nQtdGanho   := 0
	Local nQtdMaior   := 0
	Local nTam        := Len(SC2->C2_NUM+SC2->C2_ITEM+SC2->C2_SEQUEN)
	Local nX          := 0

	Private l250Auto  := If((l680 .And. l680Auto) .Or. (l681 .And. l681Auto),.T.,.F.)

	If Type("lMaiorAuto") == "U"
		Private lMaiorAuto := .T.
	EndIf

	CriaStatic()

	A680NumLot()

	Do Case
		Case lMES .and. !empty(M->H6_DTAPONT)
			dDataMovto := M->H6_DTAPONT
		Case cParData == 1
			dDataMovto := Date()
		Case cParData == 2
			dDataMovto := dDataBase
		Case cParData == 3
			dDataMovto := M->H6_DATAINI
		Case cParData == 4
			dDataMovto := M->H6_DATAFIN
		OtherWise
			dDataMovto := dDataBase
	EndCase

	If IntWms(M->H6_PRODUTO)  .And. FindFunction('WmsSerEndPr')
		WmsSerEndPr(M->H6_PRODUTO,@cA680Ser,@cA240End) //determina o serviГo e endereГo de produГЦo a partir do produto
	EndIf

    // Valida se a ordem jА foi apontada no MATA250
    If (M->H6_QTDPROD > 0 .Or. M->H6_QTDPERD > 0) .And. !lMes
    	lRet := A680VerApo()
    EndIf

	//зддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	//Ё Posiciona o arquivo de OPs corretamente.            Ё
	//юддддддддддддддддддддддддддддддддддддддддддддддддддддды
	SC2->(dbSetOrder(6))
	lSC2Found := SC2->(dbSeek(xFilial("SC2")+Left(M->H6_OP,nTam)+M->H6_PRODUTO + Substr(M->H6_OP, nTam+1, 2)))

	//зддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	//Ё Armazena o Local do CQ Origem.                      Ё
	//юддддддддддддддддддддддддддддддддддддддддддддддддддддды
	If lH6_LOCAL
		cLocCQOrig := M->H6_LOCAL
	Else
		cLocCQOrig := SC2->C2_LOCAL
	EndIf

	//здддддддддддддддддддддддддддддддддддддд©
	//ЁVerifica se tem permissao de armazem  |
	//юдддддддддддддддддддддддддддддддддддддды
	If lRet
	    If Len(AllTrim(M->H6_LOCAL)) > 0
		   lRet := MaAvalPerm(3,{M->H6_LOCAL,M->H6_PRODUTO})
	    EndIf
	endIf

	//зддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	//Ё Valida produtos bloqueados							Ё
	//юддддддддддддддддддддддддддддддддддддддддддддддддддддды
	If lRet .And. A680BloqPR0(M->H6_OP)
		lRet := .F.
	EndIf

	If lRet .And. !Empty(M->H6_OP) .And. FindFunction("A113BlqApo")
		lRet := A113BlqApo(M->H6_OP)
	EndIf

	If lRet
		If !Empty(M->H6_MOTIVO)
			dbSelectArea("CYN")
			dbSeek(xFilial("CYN")+M->H6_MOTIVO)
			If !Found()
				Help( ,  , "Help", , STR0121 + M->H6_MOTIVO + STR0122, ; //"Motivo do apontamento de horas improdutivas " " nЦo existente."
				1, 0, , , , , , {STR0123 + M->H6_MOTIVO + STR0124})  //"Cadastre o motivo de apontamento de horas improdutivas ou substitua-o por outro existente"
				lRet := .F.
			EndIf
		EndIf
	EndIf

	If lRet
		dbSelectArea("SH1")
		dbSeek(xFilial("SH1")+M->H6_RECURSO)
		If !Found()
			Help(" ",1,"A680NAOSH1",,M->H6_RECURSO,1,11)
			lRet := .F.
		EndIf
	EndIf

	If nBlqRec == 1 .Or. nBlqRec == 2 .And. lRet

    	If cCampo == "M->H6_OP" .Or. cCampo == "M->H6_RECURSO" .Or. cCampo == "M->H6_DATAINI" .Or. cCampo == "M->H6_DATAFIN" .Or. cCampo == "M->H6_HORAINI" .Or. cCampo == "M->H6_HORAFIN"

    	    If (!Empty(M->H6_RECURSO) .And. !Empty(M->H6_DATAINI) .And. !Empty(M->H6_DATAFIN)) .And. (!Empty(M->H6_HORAINI) .And. !Empty(M->H6_HORAFIN))

				lRet := verBlqRec(M->H6_RECURSO, M->H6_DATAINI, M->H6_DATAFIN, M->H6_HORAINI, M->H6_HORAFIN, SC2->C2_CC)

    	    EndIf
		EndIf
	EndIf

	If lRet .And. Type("lRunPPI") == "L" .And. lRunPPI
		If !PCPObrigat("SH6")
			lRet := .F.
		EndIf
	EndIf

	If lRet
		//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		//Ё Checa a existencia do Produto MOD+AllTrim(SH1->H1_CCCUSTO),      Ё
		//Ё pois, caso nao exista, a funcao A240Atu iria cria-lo sem         Ё
		//Ё consultar o SB1.                                                 Ё
		//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
		dbSelectArea("SB1")
		//cProdMod:=APrModRec(SH1->H1_CODIGO)
		cProdMod := If (lModRecPCP ==.T., ModRecPCP(SH1->H1_CODIGO), APrModRec(SH1->H1_CODIGO))
		If	dbSeek(xFilial("SB1")+cProdMod)
			If SB1->B1_MSBLQL == '1'
				lExistMod := .F.
			Else
				lExistMod := .T.
			EndIf
		Else
			lExistMod := .F.
		EndIf

		If !lExistMod
			If Select('CYN') > 0
				lModCYN := CYN->CYN_LGMOD
			Endif
		    if !Empty(M->H6_HORAINI) .And. !Empty(M->H6_HORAFIN) .And. lModCYN
				Help(" ",1,"A680MODSB1",,cProdMod,5,3)
				lRet := .F.
			EndIf
		EndIf
	EndIf

	If !l682 .And. lRet
		//зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		//Ё Valida a existencia de saldo de empenhos para OP quando utiliza requisicao ?|
		//Ё manual e a OP esta sendo encerrada.											|
		//юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
		If !l682 .And. If(l680,!l680Auto,!l681Auto) .And. lUltOper
			lRet := a250ChkEmp(M->H6_OP)
		Endif

		//зддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		//Ё Verifica se o produto corresponde a OP digitada.    Ё
		//юддддддддддддддддддддддддддддддддддддддддддддддддддддды
		If lRet .And. SC2->C2_PRODUTO != M->H6_PRODUTO
			Help(" ",1,"A680PRODDI")
			RestArea(aAreaSC2)
			lRet := .F.
		EndIf

		//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		//| Valida campo chave Inspecao de Processos com Apontamento   |
		//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
		If lRet .AND. lIntQIP .AND. lAponta
			lRet := QIPGNSH6()
		EndIf

		If ExistBlock("M680VLDPT")
			lM680VldPT := ExecBlock("M680VLDPT",.F.,.F.)
			If ValType(lM680VldPT) # "L"
				lM680VldPT := .T.
			EndIf
		EndIf

		//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		//| Valida se data do apontamento И menor que a data de emissЦo da OP  |
		//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
		If lRet .And. FindFunction("a250ConsDtOp") .And. !Empty(dDataMovto)
	        lRet := a250ConsDtOp(dDataMovto,M->H6_OP)
		EndIf

		//здддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		//Ё Nao deixara' fazer o apontamento, se a somatoria das Ё
		//Ё quantidades, for menor que a qtde. informada na OP.  Ё
		//юдддддддддддддддддддддддддддддддддддддддддддддддддддддды
		If lRet .And. lM680VldPT .And. !lIntSFC .And. M->H6_QTDPROD + M->H6_QTDPERD < A680SldProd(.T., .T.) .And. M->H6_PT=='T'
			Help(" ",1,"MA250PERDA")
			lRet := .F.
		EndIf

		If lRet
			lRet:=a680Quant(.T.)
		EndIf

 		//зддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		//Ё Verifica se a quantidade digitada ┌ valida.         Ё
		//юддддддддддддддддддддддддддддддддддддддддддддддддддддды
		If lRet .And. (M->H6_QTDPROD + M->H6_QTDPERD) <= 0 .And. (!lIntSFC .And. mv_par04 == 2) .And. (!Altera)
			Help(" ",1,"A680SEMQTD")
			lRet := .F.
		EndIf

		//зддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		//ЁAcrescentado Verificacao do paramentro  MV_GANHOPR   Ё
		//юддддддддддддддддддддддддддддддддддддддддддддддддддддды
		If lRet .And. !lGProd .And. !lProdMaior .And. M->H6_QTDPROD+If(lPerdInf,0,M->H6_QTDPERD) > A680SldOper(.F.,mv_par07 == 1,.F.)[1]
			Help(" ",1,"A250GANHPR")
			lRet := .F.
		EndIf

		If lUltOper .And. M->H6_PT == 'T'
			// Verifica se a Ordem de Producao possui saldo em processo
			If ExistBlock("A250SPRC")
				lA250SPRC := ExecBlock("A250SPRC",.F.,.F.,{M->H6_OP,dDataMovto})
			EndIf

			If lRet .And. If(ValType(lA250SPRC)#"L",A250VerReq(M->H6_OP,dDataMovto),!lA250SPRC)
				Help(" ",1,"A250NOENC")
				lRet := .F.
			EndIf
		EndIf

		//TRSG79 - Vivian - verificaГЦo do saldo da OP quando incluМda nova operaГЦo apСs apontamento da operaГЦo final
		If lRet .And. !lGprod .And. !lProdMaior .And. lUltOper
		    nSaldoApon := 0
		    cOpAtual := M->H6_OP
			cProduto := M->H6_PRODUTO

			cQuery := " SELECT SUM(SH6.H6_QTDPROD) TOT_QTDPROD, SUM(SH6.H6_QTDPERD) TOT_QTDPERD "
			cQuery += "   FROM " + RetSqlName("SD3") + " SD3, " +  RetSqlName("SH6") + " SH6 "
			cQuery += "  WHERE SH6.H6_FILIAL  = '"+xFilial('SH6')+"' "
			cQuery += "    AND SH6.H6_OP      = '"+cOpAtual+"' "
			cQuery += "    AND SH6.H6_PRODUTO = '"+cProduto+"' "
			cQuery += "    AND SH6.D_E_L_E_T_ = '' "
			cQuery += "    AND SD3.D3_FILIAL  = '"+xFilial('SD3')+"' "
			cQuery += "    AND SD3.D3_OP      = SH6.H6_OP "
			cQuery += "    AND SD3.D3_COD     = SH6.H6_PRODUTO "
			cQuery += "    AND SD3.D3_IDENT   = SH6.H6_IDENT "
			cQuery += "    AND SD3.D3_ESTORNO = '' "
			cQuery += "    AND SD3.D_E_L_E_T_ = '' "

			dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasSld,.T.,.T.)

			If !(cAliasSld)->(Eof())
				If lPerdInf
					nSaldoApon := (cAliasSld)->TOT_QTDPROD
				Else
					nSaldoApon := (cAliasSld)->TOT_QTDPROD + (cAliasSld)->TOT_QTDPERD
				EndIf
			EndIf

			(cAliasSld)->(dbCloseArea())

			If nSaldoApon > 0
			   	dbSelectArea("SC2")
			   	dbSetOrder(1)
			   	dbSeek(xFilial("SC2")+cOpAtual+cProduto)
				If !Eof() .And. C2_FILIAL+C2_NUM+C2_ITEM+C2_SEQUEN+C2_ITEMGRD+C2_PRODUTO == xFilial("SC2")+cOpAtual+cProduto
				    nQtdOP := SC2->C2_QUANT
				    If nQtdOP < (nSaldoApon + M->H6_QTDPROD + If(lPerdInf,0,M->H6_QTDPERD) )
				       Help(" ",1,"HELP", ,STR0129+".",1,0, ,,,,,{STR0130}) //"Quantidade apontada maior que o saldo da OP." //"Informe uma quantidade vАlida."
					  lRet := .F.
				    EndIf
		        EndIf
			EndIf
		EndIf

		//зддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		//Ё Verifica se o saldo do armazem esta liberado.       Ё
		//юддддддддддддддддддддддддддддддддддддддддддддддддддддды
		If lRet
			If lH6_LOCAL
				lRet := SldBlqSB2(M->H6_PRODUTO,M->H6_LOCAL)
			Else
				lRet := SldBlqSB2(M->H6_PRODUTO,SC2->C2_LOCAL)
			EndIf
		EndIf

		//зддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		//Ё Verifica se o produto est═ sendo inventariado.      Ё
		//юддддддддддддддддддддддддддддддддддддддддддддддддддддды
		If lRet .And. lH6_LOCAL .And. BlqInvent(M->H6_PRODUTO,M->H6_LOCAL) .And. !lAponTemp .And. lUltOper
			Help(" ",1,"BLQINVENT",,M->H6_PRODUTO+STR0067+M->H6_LOCAL,1,11)  //" Almox: "
			lRet := .F.
		EndIf

		//зддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		//Ё Analisa se o tipo do armazem permite a movimentacao |
		//юддддддддддддддддддддддддддддддддддддддддддддддддддддды
		If lRet .And. lH6_LOCAL .And. AvalBlqLoc(M->H6_PRODUTO,M->H6_LOCAL,Nil)
			lRet := .F.
		EndIf

		//зддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		//Ё Verifica se o produto est═ sendo inventariado.      Ё
		//юддддддддддддддддддддддддддддддддддддддддддддддддддддды
		If lRet .And. !lH6_LOCAL .And. BlqInvent(M->H6_PRODUTO,SC2->C2_LOCAL) .And. !lAponTemp .And. lUltOper
			Help(" ",1,"BLQINVENT",,M->H6_PRODUTO+STR0067+SC2->C2_LOCAL,1,11)  //" Almox: "
			lRet := .F.
		EndIf

		//зддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		//Ё Analisa se o tipo do armazem permite a movimentacao |
		//юддддддддддддддддддддддддддддддддддддддддддддддддддддды
		If lRet .And. !lH6_LOCAL .And. AvalBlqLoc(M->H6_PRODUTO,SC2->C2_LOCAL,Nil)
			lRet := .F.
		EndIf

		If lRet .And. !l682 .And. !A680OPER(.T.)
			lRet := .F.
		EndIf

		//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		//Ё Checa a existencia do Tipo de Movimento cadastrado no parametro  Ё
		//Ё MV_TMPAD.                                                        Ё
		//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
		If lIntSFCAut
			cTmPad := GetMV("MV_TMPAD")
		Else
			cTmPad := If(ExistBlock("MA680TMP"),ExecBlock("MA680TMP",.F.,.F.),GetMV("MV_TMPAD"))
		Endif

		cQuery := ""
		cQuery += "SELECT COUNT(*) AS QTD FROM " + RetSQLName( 'SF5' ) + " SF5 WHERE "
		cQuery += "		F5_FILIAL  = '" + xFilial('SF5') + "' AND "
		cQuery += "		F5_CODIGO    = '" + cTmPad + "' AND "
		cQuery += "     D_E_L_E_T_ = ' '"

		cTmp := GetNextAlias()

		dbUseArea( .T., 'TOPCONN', TcGenQry(,,cQuery), cTmp, .T., .F. )

		If lRet
			If (cTmp)->QTD > 0
				dbSelectArea("SF5")
				SF5->(dbSetOrder(1))
				SF5->(dbSeek(xFilial("SF5")+cTmPad))
			else
				Help(" ",1,"A680NAOSF5",,cTmPad,2,5)
				lRet := .F.
			EndIf
		EndIf

		(cTmp)->(dbCloseArea())
		// fim

		//здддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		//ЁVerifica se o usuario tem permissao para usar essa TM   Ё
		//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддды
		If lRet .And. SuperGetMV("MV_RESTTM",.F.,.F.) .AND. Found()
			lRet := MaAvalPerm(2,{Iif(Empty(cTmPad),GetMV("MV_TMPAD"),cTmPad)})
		EndIf

		//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		//Ё Testo primeiro se for ultima operacao ou se devo checar SEMPRE   Ё
		//Ё o saldo (MV_PAR05). Caso contrario testo se tem componente       Ё
		//Ё para ser baixado na operacao apontada                            Ё
		//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
		If ! (lChkSaldo := (lUltOper .Or. MV_PAR05 == 1 ))
			aBaixaSGF := A637BxComp(M->H6_PRODUTO, A680RotPad(), M->H6_OPERAC, M->H6_OP)
		EndIf

		If lRet .And. SF5->F5_ATUEMP == 'S' .And. (lChkSaldo .Or. aBaixaSGF # Nil)

			//здддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
			//Ё A funcao A250Estoq() verifica se o param. MV_ESTNEG    Ё
			//Ё e igual a "N" e nao deixa nenhum item do empenho ficar Ё
			//Ё com saldo negativo. Verifica tambem o param. MV_RASTRO Ё
			//Ё se e igual a "S" e nao deixa nenhum item do empenho    Ё
			//Ё ser utilizado sem saldo por lote.                      Ё
			//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддды
			aSaldo  := {}
			aErros  := {}
			aReqsOk := {}
			//здддддддддддддддддддддддддддддддддддддддддддддддддддд©
			//Ё Checa se existe amarracao operacao x componente e  Ё
			//Ё se ja foi baixado o saldo empenhado para nao atualiЁ
			//Ё zar novamente saldo empenhado.                     Ё
			//юдддддддддддддддддддддддддддддддддддддддддддддддддддды
			aChkBaixaC := A680CkCmpP(M->H6_PRODUTO,M->H6_OPERAC,M->H6_OP)

			If !l680Auto .AND. !l681Auto
				//Verifica a necessidade de prorporcionalizaГЦo dos empenhos SD4  //Everton
				lRet := a250Maior(M->H6_OP, M->H6_QTDPROD, M->H6_QTDPERD, @nQtdGanho, @nQtdMaior, @nPercPrM, "SH6")
				M->H6_QTMAIOR := nQtdMaior
				M->H6_QTGANHO := nQtdGanho
			Else
				lExistePM := .F.
				If FindFunction("a250Maior") .And. (l680Auto .Or. l681Auto)
					If M->H6_QTMAIOR > 0
						lRet := a250Maior(M->H6_OP, M->H6_QTDPROD, M->H6_QTDPERD, @nQtdGanho, @nQtdMaior, @nPercPrM, "SH6")
	    				lExistePM := .T.
	    			Else
	    				If M->H6_QTMAIOR = 0 .And. !lGProd .And. lProdMaior
	    					lRet := a250Maior(M->H6_OP, M->H6_QTDPROD, M->H6_QTDPERD, @nQtdGanho, @nQtdMaior, @nPercPrM, "SH6")
	    					M->H6_QTMAIOR := nQtdMaior
							M->H6_QTGANHO := 0
	    					lExistePM := .T.
	    				EndIf
		  			EndIf
				EndIf
			EndIf

			If lRet
				If l681Auto .And. M->H6_QTMAIOR > 0
					a250QTMA(M->H6_OP, M->H6_QTDPROD, M->H6_QTDPERD)
				EndIf
			EndIF

			A250Estoq(M->H6_QTDPROD +  if(lPerdInf,0, M->H6_QTDPERD) ,M->H6_PT,M->H6_PRODUTO,M->H6_OP,@aSaldo,@aReqsOK, aBaixaSGF,aChkBaixaC, nPercPrM, dDataMovto)

			//Valida se deve utilizar a requisiГЦo fifo de endereГo.
			If !lFifoEnd
				For i := 1 to Len(aReqsOk)
					If Localiza(aReqsOk[i][1])

					    cAliAnt := Alias()

						cAliasQry  := GetNextAlias()

						dbSelectArea('SBF')
						dbSetOrder(1)
						cQuery := ""
						cQuery += "SELECT COUNT(*) AS SERIE FROM " + RetSQLName( 'SBF' ) + " SBF WHERE "
						cQuery += "		SBF.BF_FILIAL  = '" + FwxFilial('SBF') + "' AND "
						cQuery += "		SBF.BF_PRODUTO    = '" + aReqsOk[i][1] + "' AND "
						cQuery += "		SBF.BF_NUMSERI    <> ' ' AND "
						cQuery += "     SBF.D_E_L_E_T_ = ' '"

						dbUseArea( .T., 'TOPCONN', TcGenQry(,,cQuery), cAliasQry, .T., .F. )

						If ((cAliasQry)->(SERIE)) > 0
							If (QtdComp(aReqsOk[i][3])) <> 1
								(cAliasQry)->(DbCloseArea())
								HELP(' ',1,"HELP",,STR0120 +aReqsOk[i][1] + STR0118,2,0,,,,,, {STR0119})
								Return .F.
							Endif
						EndIf
						(cAliasQry)->(DbCloseArea())
						dbSelectArea(cAliAnt)
					Endif
				Next i
			EndIf

			If Len(aSaldo) > 0
				If ExistBlock("MT250SAL")
					aNewSal := ExecBlock("MT250SAL",.F.,.F.,{aSaldo})
					If ValType(aNewSal) == "A"
		    			aSaldo := aNewSal
					EndIf
				EndIf

				lSemSaldo := .F.
				aErros := {}
				For ni := 1 to Len(aSaldo)
					If BlqInvent(aSaldo[ni,1],aSaldo[ni,2]) .And. !lAponTemp .And. lUltOper
						cMens  := OemToAnsi(STR0053) // "Bloqueado p/ Invent═rio"
						cQuant := Transform(aSaldo[ni][4],PesqPictQT("B2_QATU"))
						lErrInvent := .T.
						AADD(aErros,{aSaldo[ni][1],aSaldo[ni][2],cQuant,cMens})
					ElseIf AvalBlqLoc(aSaldo[ni,1],aSaldo[ni,2],Nil,,,,,,,M->H6_OP)
						cMens  := OemToAnsi(STR0103) // "Bloqueado p/ Armazem"
						cQuant := Transform(aSaldo[ni][4],PesqPictQT("B2_QATU"))
						lErrBlqMov := .T.
						AADD(aErros,{aSaldo[ni][1],aSaldo[ni][2],cQuant,cMens})
					ElseIf  A250AvalQt(aSaldo[ni][3],aSaldo[ni][1]) < QtdComp(0) .Or. ;
							A250AvalQt(aSaldo[ni][4],aSaldo[ni][1]) < QtdComp(0) .Or. ;
							A250AvalQt(aSaldo[ni][5],aSaldo[ni][1]) < QtdComp(0)
						If Rastro(aSaldo[ni][1]) .And. ;
								A250AvalQt(aSaldo[ni][3],aSaldo[ni][1]) # A250AvalQt(aSaldo[ni][4],aSaldo[ni][1])
							cMens  := OemToAnsi(STR0054)  // "Dif. Saldo em Estoque/Lote"
							cQuant := Transform(aSaldo[ni][4],PesqPictQT("B2_QATU"))
							If A250AvalQt(aSaldo[ni][3],aSaldo[ni][1]) < A250AvalQt(aSaldo[ni][4],aSaldo[ni][1])
								cQuant := Transform(aSaldo[ni][3],PesqPictQT("B2_QATU"))
							EndIf
							lErrLote  := .T.
							lErrSaldo := .T.
						ElseIf A250AvalQt(aSaldo[ni][5],aSaldo[ni][1]) < QtdComp(0)
							cMens  := OemToAnsi(STR0059) // "Sem Saldo por Localizacao"
							cQuant := Transform(aSaldo[ni][5],PesqPictQT("B2_QATU"))
							lErrLocaliz := .T.
						ElseIf A250AvalQt(aSaldo[ni][4],aSaldo[ni][1]) < QtdComp(0)
							cMens  := OemToAnsi(STR0055)  // "Sem Saldo por Lote"
							cQuant := Transform(aSaldo[ni][4],PesqPictQT("B2_QATU"))
							lErrLote := .T.
						ElseIf A250AvalQt(aSaldo[ni][3],aSaldo[ni][1]) < QtdComp(0)
							cMens  := OemToAnsi(STR0056) // "Sem Saldo em Estoque"
							cQuant := Transform(aSaldo[ni][3],PesqPictQT("B2_QATU"))
							lErrSaldo := .T.
						EndIf
						lSemSaldo := .T.
						AADD(aErros,{aSaldo[ni][1],aSaldo[ni][2],cQuant,cMens})
					EndIf
				Next ni
				If lSemSaldo .Or. lErrInvent .Or. lErrBlqMov
					If lErrInvent
						Help(" ",1,"MA250INVENT")
					EndIf
					If lErrLote
						Help(" ",1,"MA240NEGLT")
					EndIf
					If lErrSaldo
						Help(" ",1,"MA240NEGAT")
					EndIf

					If (Type("l680Auto")<>"L" .or. !l680Auto) .and. (Type("l681Auto")<>"L"  .or. !l681Auto)
						MTA680TELA(aErros)
					Else
						autogrlog(STR0057) //"Itens Sem Saldo / Bloqueados"
						autogrlog(Padr(OemToAnsi(STR0019),20)+" "+;  //produto
							Padr(OemToAnsi(STR0011),14)+" "+;  //local
							PadL(OemToAnsi(STR0020),20)+" "+;  //saldo
							OemToAnsi(STR0058))             //ocorrencia
						//autogrlog(" ")
						For nX:= 1 to len(aErros)
							autogrlog(padr(aErros[nx,1],20)+" "+;
								padr(aErros[nx,2],14)+" "+;
								padl(aErros[nx,3],20)+" "+;
								aErros[nx,4])
						Next
					EndIf
					lRet := .F.
				EndIf
			EndIf
		EndIf
		//define se o produto serА enviado para o CQ
	    lEnvCQProd := fEnvCQProd(M->H6_PRODUTO, SF5->F5_CODIGO, .F.,,M->H6_LOCAL)

		If lRet
			If cQipMat == "S"
				If lEnvCQProd
					M->H6_LOCAL := GetMV('MV_CQ')
				Else
					If ( nPrapont = 1 .Or. ;
						(nPrapont = 2 .And. Posicione("SB1",1,xFilial("SB1")+M->H6_PRODUTO,"B1_NUMCQPR") > 0 ))
						M->H6_VERIFI := SC2->C2_VERIFI
						If Empty(M->H6_LOCAL) //Se possuir valor utiliza o informado em tela
							M->H6_LOCAL  := SC2->C2_LOCAL
						EndIf
					EndIf
				EndIf
			Else
				If lEnvCQProd
					M->H6_LOCAL := GetMV('MV_CQ')
				Else
					If Empty(M->H6_LOCAL) //Se possuir valor utiliza o informado em tela
						M->H6_LOCAL  := SC2->C2_LOCAL
					EndIf
				EndIf
			EndIf
		EndIf

		// Valida quantidade do rateio
		If lRet .And. nProdProp == 2 .And. lUltOper
			If QtdComp(M->H6_RATEIO) <= (0)
				Help(" ",1,"A680RATEIO")
				lRet:=.F.
			EndIf
		EndIf

		//Verifica se outro usuario ja esta encerrando a operacao.
		If lRet .And. (!Empty(SC2->C2_DATRF) .Or. (M->H6_PT == "T" .And. !LockByName("ENCOP"+M->H6_OP+M->H6_OPERAC,.T.,.T.,.T.)))
			Help(" ",1,"A680OPTOT")
			lRet := .F.
		EndIf

	EndIf

	//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	//Ё Verifica se a Ordem de Producao foi suspensa                     Ё
	//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
	If lSC2Found .And. lRet .And. lValOpSusp
		SC2->(dbSetOrder(6))
		If SC2->(dbSeek(xFilial("SC2")+Left(M->H6_OP,nTam)+M->H6_PRODUTO + Substr(M->H6_OP, nTam+1, 2)))
			If SC2->C2_STATUS == 'U'
				Help(' ',1,"A250OPSUSP")
				lRet := .F.
			Endif
		Endif
	EndIf

	//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	//Ё Ponto de Entrada para validacao da Inclusao.                     Ё
	//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
	If lRet .And. lMT680Val
		lOk := ExecbLock("MT680VAL",.F.,.F., {M->H6_LOCAL})
		If ValType(lOk) == "L"
			lRet := lOK
		EndIf
	EndIf

	//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	//Ё Ponto de Entrada para criacao de tela.                           Ё
	//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
	If lRet .And. l681 .And. lMT680FINAL
		lRetorno := ExecBlock("MT680FINAL",.F.,.F.)
		If lRetorno .and. !l681Auto
			aOldRot    := aClone(aRotina)
			cOldcCadas := cCadastro
			aAreaSH6   := SH6->(GetArea())
			aAreaSC2   := SC2->(GetArea())
			MATA381(,,4,.t.)
			aRotina    := aClone(aOldRot)
			cCadastro  := cOldcCadas
			RestArea(aAreaSH6)
			RestArea(aAreaSC2)
		EndIf
	EndIf

	If !lRet
		If M->H6_PT == "T"
			//Remove lock aplicado na A680TudoOk
			UnLockByName("ENCOP"+M->H6_OP+M->H6_OPERAC,.T.,.T.,.T.)
		EndIf
	EndIf

	If lRet .And. lUltOper .And. IntWms(M->H6_PRODUTO)
		//-- Permite a informacao do Endereco e da Estrutura de Origem via Ponto de Entrada
		If ExistBlock('A680WMSO')
			aRetPE := ExecBlock('A680WMSO', Nil, Nil, {M->H6_PRODUTO, M->H6_OP, M->H6_IDENT})
			If Len(aRetPE) > 0
				lPergWMS := .F.
				cA680Ser := If( ValType(aRetPE[1])=="C", aRetPE[1], cA680Ser )
				cA240End := If( ValType(aRetPE[2])=="C", aRetPE[2], cA240End )
			EndIf
		EndIf
		If lPergWMS
			// Quando for novo WMS, obriga o preenchimento do serviГo
			if !DLPxVEndSr(@cA680Ser,@cA240End,,lWmsNew,'1',M->H6_LOCAL, , , l680, l680Auto, l681, l681Auto)
				lRet := .F.
			Endif
		EndIf
		// ValidaГЦo do preenchimento do serviГo e endereГo para o WMS
		If lRet
			lRet := WmsAvalSC2("1",cA680Ser,cA240End,M->H6_OP)
		EndIf
	EndIf

	//APT.PENDENT
	IF  !l682
		IF !lRet .AND. lAptPende .AND. (l680Auto .OR. l681Auto) .AND. (cPcpPend == '2' .OR. cPcpPend == '4')  	//se for rotina automАtica e estiver setado para somente gravar apontamento como pendente quando der erro,
			aAdd(aRotAuto,{'GRAVA',"4",NIL})
		EndIf
		//se for rotina automАtica e estiver setado para SEMPRE gravar apontamento como pendente,
		//entЦo basta salvar a tabela de apontamento pendente e dar um return
		//esta gravaГЦo И feita neste momento pois anteriormente jА foram feitas as validaГУes necessАrias
		IF  (l680Auto .OR. l681Auto) .AND. lAptPende .AND. cPcpPend == '3'
			aAdd(aRotAuto,{'GRAVA',"3",NIL})
			if lRet
				lRet:= .f.
			EndIF
		EndIf
	EndIF

	If (Type("cDocD3Ini") == "C") .And. !Empty(GetSX3Cache("D3_DOC","X3_RELACAO"))
		cIniDoc   := (GetSX3Cache("D3_DOC","X3_RELACAO"))
		cDocD3Ini := InitPad(cIniDoc)
	EndIf

	RestArea(aAreaSC2)
	RestArea(aArea)

	IF ( Type("l680Auto")=="L" .And. Type("l681Auto")=="L" )
		If !l681Auto .And. !l680Auto .And. !lRet
			M->H6_QTMAIOR := 0
			M->H6_QTGANHO := 0
			//M->H6_PT := ' '

			//Michele-
			//NЦo serА mais apagado o valor do campo H6_PT em tela.
			//SituaГУes previstas: https://jiraproducao.totvs.com.br/browse/DMANSMARTSQUAD1-21170
		EndIf
	EndIf

Return lRet
/*
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤┘o    ЁA680Estoq Ё Autor Ё Marcos Bregantim      Ё Data Ё 28/09/94 Ё╠╠
╠╠цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤┘o Ё Programa que verifica a Qtd. em estoque dos empenhos da Op Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠Ё Uso      Ё MATA680                                                    Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ
*/
Function A680Estoq()
Local cBxProp :=GetMv("MV_BXPROP")
Local cReqAut :=A250ReqAut(GetMv("MV_REQAUT"))
Local cEstNeg :=GetMV("MV_ESTNEG")
Local cLocProc:=GetMV("MV_LOCPROC")
Local aReqsOk :={},aErros:={},aSaldo:={}
Local cAlias  := Alias()
Local cApropri,cLocReq
Local cSeekSB8:= "",cComparaSB8:=""
Local lRet    := .T.,lErrLote := .F.
Local nOrdem,nRec,nOrdSB8,nRecSB8,nElem,nQtdUsada,nOpca
Local nIndice := 1
Local nSaldo  :=0,nEmpenho:=0
Local oDlg,oQual
Local ni
Local lEmpPrev:= If(SuperGetMV("MV_QTDPREV")== "S",.T.,.F.)

//здддддддддддддддддддддддддддддддддддддддддддддддддддд©
//Ё Posiciona no arquivo de OP's                       Ё
//юдддддддддддддддддддддддддддддддддддддддддддддддддддды
SC2-> ( dbSeek(xFilial("SC2")+M->H6_OP) )

If M->H6_PT == "P" .And. (cBxProp == "S" .Or. cReqAut == "A")
	nIndice := (M->H6_QTDPROD + M->H6_QTDPERD) / SC2->C2_QUANT
EndIf

If (M->H6_QTDPROD + M->H6_QTDPERD) > 0
	dbSelectArea("SD4")
	nOrdem := IndexOrd()
	nRec   := RecNo()
	dbSetOrder(2)
	dbSeek(xFilial("SD4")+M->H6_OP)
	While SD4->D4_FILIAL+SD4->D4_OP == xFilial("SD4")+M->H6_OP
		//здддддддддддддддддддддддддддддддддддддддддддддддд©
		//Ё Nao baixa se quantidade empenhada for negativa Ё
		//юдддддддддддддддддддддддддддддддддддддддддддддддды
		If SD4->D4_QUANT<=0 .Or. IsProdMod(SD4->D4_COD)
			dbSkip()
			Loop
		EndIf
		//здддддддддддддддддддддддддддддддддддддддддддддддд©
		//Ё Baixa apenas o saldo quando for ficar negativa Ё
		//юдддддддддддддддддддддддддддддддддддддддддддддддды
		nQuant := NoRound(SD4->D4_QTDEORI*nIndice,5)
		If SD4->D4_QUANT - nQuant < 0
			nQuant := SD4->D4_QUANT
		EndIf
		//зддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		//Ё Se o parametro mv_ReqAut indicar que as requisicoes   Ё
		//Ё de materiais diretos sao digitadas entao ele baixara' Ё
		//Ё apenas materiais indiretos , diferentes de MOD , pois Ё
		//Ё a decisao de baixar ou nao a MOD esta' no TM pelo cam-Ё
		//Ё po F5_TRANMOD = "S".                                  Ё
		//юддддддддддддддддддддддддддддддддддддддддддддддддддддддды
		SB1-> ( dbSeek(xFilial("SB1")+SD4->D4_COD) )
		cApropri := "1"
		If SB1->B1_APROPRI == "I"
			cApropri := "2"
		EndIf
		If cReqAut == "D" .And. cApropri == "1"
			dbSelectArea("SD4")
			dbSkip()
			Loop
		EndIf
		//здддддддддддддддддддддддддддддддддддддддддд©
		//Ё Verifica o local a ser baixado           Ё
		//юдддддддддддддддддддддддддддддддддддддддддды
		If cApropri == "2"
			cLocReq := cLocProc
		Else
			cLocReq := SD4->D4_LOCAL
		EndIf
		SB2->(dbSeek(xFilial("SB2")+SD4->D4_COD+cLocReq))
		nElem := Ascan(aReqsOK,{|x| x[1] == SD4->D4_COD+cLocReq})
		If nElem == 0
			nQtdUsada := 0
			AADD(aReqsOk,{SD4->D4_COD+SD4->D4_LOCAL,nQuant})
		Else
			nQtdUsada := aReqsOk[nElem,2]
			aReqsOk[nElem,2] += nQuant
		EndIf
		If Rastro(SD4->D4_COD)
			dbSelectArea("SB8")
			nOrdSB8 := IndexOrd()
			nRecSB8 := RecNo()
			If Empty(IF(Rastro(SD4->D4_COD,"S"),SD4->D4_NUMLOTE,SD4->D4_LOTECTL))
				dbSetOrder(1)
				SB8-> (dbSeek(xFilial("SB8")+SD4->D4_COD+cLocReq) )
				nSaldo := 0
				While SB8->B8_FILIAL+SB8->B8_PRODUTO+SB8->B8_LOCAL == xFilial("SB8")+SD4->D4_COD+cLocReq
					nSaldo += SB8SALDO(,,,,,lEmpPrev,,,.T.) - (SB8SALDO(.T.,,,,,lEmpPrev,,,.T.)+AvalQtdPre("SB8",1))
					dbSkip()
				End
				If nSaldo - nQuant < 0
					lErrLote := .t.
				EndIf
			Else
				dbSelectArea("SB8")
				dbSetOrder(3)
				If Rastro(SD4->D4_COD,"S")
					cSeekSB8:=xFilial("SB8")+SD4->D4_COD+cLocReq+SD4->D4_LOTECTL+SD4->D4_NUMLOTE
					cComparaSB8:="B8_FILIAL+B8_PRODUTO+B8_LOCAL+B8_LOTECTL+B8_NUMLOTE"
				Else
					cSeekSB8:=xFilial("SB8")+SD4->D4_COD+cLocReq+SD4->D4_LOTECTL
					cComparaSB8:="B8_FILIAL+B8_PRODUTO+B8_LOCAL+B8_LOTECTL"
				EndIf
				If dbSeek(cSeekSB8)
					Do While !Eof() .And. cSeekSB8 == &(cComparaSB8)
						nSaldo+=SB8SALDO(,,,,,lEmpPrev,,,.T.)
						nEmpenho+=SB8SALDO(.T.,,,,,lEmpPrev,,,.T.)+AvalQtdPre("SB8",1)
						dbSkip()
					EndDo
					If nSaldo < nQuant .Or. nEmpenho < nQuant
						lErrLote := .T.
					EndIf
				Else
					lErrLote := .T.
				EndIf
			EndIf
			dbSetOrder(nOrdSB8)
			dbGoto(nRecSB8)
			dbSelectArea("SD4")
		ElseIf (SB2->B2_QATU - SB2->B2_QACLASS) < (nQuant + nQtdUsada ) .And. cEstNeg == "N"
			nElem := Ascan(aSaldo,{|x| x[1] == SD4->D4_COD+cLocReq})
			If nElem == 0
				AADD(aSaldo,{SD4->D4_COD+cLocReq,(SB2->B2_QATU - SB2->B2_QACLASS) - (nQuant + nQtdUsada)})
			Else
				aSaldo[nElem,2] -= nQuant
			EndIf
		EndIf
		dbSkip()
	End
	dbSetOrder(nOrdem)
	dbGoto(nRec)
EndIf

If Len(aSaldo) > 0
	Help(" ",1,"MA240NEGAT")
	cCadastro:=OemToAnsi(STR0009)	//"Itens Sem Saldo"
	aErros := {}
	For ni := 1 to Len(aSaldo)
		AADD(aErros,{Subs(aSaldo[ni,1],1,15),Subs(aSaldo[ni,1],16,2),Trans(aSaldo[ni , 2],PesqPictQT("B2_QATU"))})
	Next
	nOpca:= 0
	DEFINE MSDIALOG oDlg TITLE cCadastro From 9,0 To 15,50 OF oMainWnd

	@ 0,.7 LISTBOX oQual VAR cVar Fields HEADER OemToAnsi(STR0010),OemToAnsi(STR0011),OemToAnsi(STR0012),OemToAnsi(STR0013),OemToAnsi(STR0014) SIZE 150,42	//"C╒digo"###"Local"###"Quantidade"###"Entrega"###"Descri┤└o"
	oQual:SetArray(aErros)
	oQual:bLine := { || {aErros[oQual:nAT][1],aErros[oQual:nAT][2],aErros[oQual:nAT][3]}}

	DEFINE SBUTTON FROM 5   ,166  TYPE 1 ACTION (nOpca := 1,oDlg:End()) ENABLE OF oDlg
	DEFINE SBUTTON FROM 17.5,166  TYPE 2 ACTION oDlg:End() ENABLE OF oDlg

	ACTIVATE MSDIALOG oDlg
	lRet := .F.
ElseIf lErrLote
	Help(" ",1,"MA240NEGLT")
	lRet := .f.
EndIf

Return lRet

/*
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤┘o    ЁA680InOperЁ Autor Ё Marcos Bregantim      Ё Data Ё 22/07/96 Ё╠╠
╠╠цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤┘o Ё Rotina p/inicializacao de alguns campos a partir da Operac.Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠Ё Uso      Ё MATA680                                                    Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ
*/
Function A680InOper()

Local lRet			:= .T.
Local lContinua	:= .T.
Local cxFilialSH6 := xFilial("SH6")

If Empty(M->H6_OP) .Or. l682
	lContinua := .F.
EndIf

If lContinua
	dbSelectArea("SC2")
	dbSeek(xFilial("SC2")+M->H6_OP)
	If !Found()
		lContinua := .F.
	EndIf
EndIf

If lContinua .And. l680
	dbSelectArea("SH8")
	dbSetOrder(1)
	dbSeek(xFilial("SH8")+M->H6_OP+M->H6_OPERAC)
	If !Found()
		Help(" ",1,"A680SEMOPE")
		lContinua	:= .F.
		lRet		:= .F.
	EndIf
EndIf

//Se for rotina automАtica e modificaГЦo, nЦo realizar as outras validaГУes.
If lContinua .And. (l680Auto .Or. l681Auto) .And. nOpcAuto == 4
	lContinua := .F.
EndIf

If lContinua
	If fExisTotal(M->H6_OP,M->H6_OPERAC)
		Help(" ",1,"A680OPTOT")
		lContinua	:= .F.
		lRet		:= .F.
	EndIf
EndIf
If lContinua
	dbSelectArea("SH6")

	nEndereco := Ascan(aGets,{ |x| Subs(x,9,10) == "H6_OPERAC " } )
	If nEndereco > 0
		aTela[Val(Subs(aGets[nEndereco],1,2))][Val(Subs(aGets[nEndereco],3,1))*2] := M->H6_OPERAC
	EndIf

	If l680
		lRet := A680IniCpo()
	EndIf
EndIf
Return lRet

/*/{Protheus.doc} fExisTotal
	Verifica se existe apontamento total na operaГЦo.
	@type  Static Function
	@author mauricio.joao
	@since 27/07/2021
	@version 1.0
	@param cOp, character, Numero completo da ordem de produГЦo
	@param cOperac, character, Codigo da OperaГЦo
	@return lExiste, logical, retorna se existe operaГЦo total.
/*/

Static Function fExisTotal(cOp, cOperac)
Local lExiste := .F.
Local cAliasSH6 := GetNextAlias()
//Gera a Query
BeginSql alias cAliasSH6

SELECT
	COUNT(*) QTDOP
FROM
	%table:SH6% SH6
WHERE
	SH6.H6_FILIAL = %xfilial:SH6% AND
	SH6.H6_OP = %Exp:cOp% AND
	SH6.H6_OPERAC = %Exp:cOperac% AND
	SH6.H6_PT = %Exp:'T'% AND
	SH6.%notDel%
EndSql

//verifica se existe apontamento total.
If (cAliasSH6)->(QTDOP) > 0
	lExiste := .T.
EndIf
//Fecha a tabela
(cAliasSH6)->(DbCloseArea())

Return lExiste

/*
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤└o    ЁA680ChkPrdЁ Autor Ё Marcos Bregantim      Ё Data Ё 22/07/96 Ё╠╠
╠╠цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤└o Ё Rotina p/consistir o produto                               Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠Ё Uso      Ё MATA680                                                    Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ
*/
Function A680ChkPrd()
Local lRet		:= .T.
Local lContinua	:= .T.

If Empty(M->H6_OP)
	lContinua := .F.
EndIf

If lContinua
	dbSelectArea("SC2")
	dbSeek(xFilial("SC2")+M->H6_OP)
	If !Found()
		lContinua := .F.
	EndIf
EndIf
If lContinua .And. SC2->C2_PRODUTO != M->H6_PRODUTO
	Help(" ",1,"A680PRODDI")
	lRet := .F.
EndIf

Return lRet

/*
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤└o    ЁA680IniCpoЁ Autor Ё Marcos Bregantim      Ё Data Ё 22/07/96 Ё╠╠
╠╠цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤└o Ё Rotina p/inicializacao de alguns campos                    Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠Ё Uso      Ё MATA680                                                    Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ
*/
Function A680IniCpo()
Local nEndereco,nEnd1,nEnd2,nTam,nDec
Local cForHora			:= If(mv_par03 == 1, "N", "C")
Local lAutomatico		:= (Type("l680Auto")=="L" .and. l680Auto)
Local lExistA680IniCpo	:= ExistBlock("A680IniCpo")
Local lRetA680IniCpo	:= Nil
Local lRet				:= .T.
Local nQuant2			:= 0
Local aDados			:= {0,"T"}

If lExistA680IniCpo .And. ValType(lRetA680IniCpo := ExecBlock("A680iniCpo", .F., .F.)) == "L" .And. (! lRetA680IniCpo)
	lRet := .F.
EndIf

If lRet .And. ! lAutomatico .or. Empty(M->H6_RECURSO)
	M->H6_RECURSO := SH8->H8_RECURSO
	nEndereco := Ascan(aGets,{ |x| Subs(x,9,10) == "H6_RECURSO" } )
	If nEndereco > 0
		aTela[Val(Subs(aGets[nEndereco],1,2))][Val(Subs(aGets[nEndereco],3,1))*2] := SH8->H8_RECURSO
	EndIf
EndIf
If lRet .And. ! lAutomatico .or. Empty(M->H6_FERRAM)
	M->H6_FERRAM := SH8->H8_FERRAM
	nEndereco := Ascan(aGets,{ |x| Subs(x,9,10) == "H6_FERRAM " } )
	If nEndereco > 0
		aTela[Val(Subs(aGets[nEndereco],1,2))][Val(Subs(aGets[nEndereco],3,1))*2] := SH8->H8_FERRAM
	EndIf
EndIf
If lRet .And. ! lAutomatico .or. Empty(M->H6_HORAFIN)
	M->H6_HORAFIN := A680ConvHora(SH8->H8_HRFIM, "N", cForHora)
	nEndereco := Ascan(aGets,{ |x| Subs(x,9,10) == "H6_HORAFIN" } )
	If nEndereco > 0
		aTela[Val(Subs(aGets[nEndereco],1,2))][Val(Subs(aGets[nEndereco],3,1))*2] := A680ConvHora(SH8->H8_HRFIM, "N", cForHora)
	EndIf
EndIf
If lRet .And. ! lAutomatico .or. Empty(M->H6_HORAINI)
	M->H6_HORAINI := A680ConvHora(SH8->H8_HRINI, "N", cForHora)
	nEndereco := Ascan(aGets,{ |x| Subs(x,9,10) == "H6_HORAINI" } )
	If nEndereco > 0
		aTela[Val(Subs(aGets[nEndereco],1,2))][Val(Subs(aGets[nEndereco],3,1))*2] := A680ConvHora(SH8->H8_HRINI, "N", cForHora)
	EndIf
EndIf
If lRet .And. ! lAutomatico .or. Empty(M->H6_DATAINI)
	M->H6_DATAINI := SH8->H8_DTINI
	nEndereco := Ascan(aGets,{ |x| Subs(x,9,10) == "H6_DATAINI" } )
	If nEndereco > 0
		aTela[Val(Subs(aGets[nEndereco],1,2))][Val(Subs(aGets[nEndereco],3,1))*2] := DTOC(SH8->H8_DTINI)
	EndIf
EndIf
If lRet .And. ! lAutomatico .or. Empty(M->H6_DATAFIN)
	M->H6_DATAFIN := SH8->H8_DTFIM
	nEndereco := Ascan(aGets,{ |x| Subs(x,9,10) == "H6_DATAFIN" } )
	If nEndereco > 0
		aTela[Val(Subs(aGets[nEndereco],1,2))][Val(Subs(aGets[nEndereco],3,1))*2] := DTOC(SH8->H8_DTFIM)
	EndIf
EndIf
If lRet .And. ! lAutomatico .or. Empty(M->H6_TEMPO)
	M->H6_TEMPO := A680ConvHora(A680ITempo(), "N", cForHora)
	nEndereco := Ascan(aGets,{ |x| Subs(x,9,10) == "H6_TEMPO  " } )
	If nEndereco > 0
		aTela[Val(Subs(aGets[nEndereco],1,2))][Val(Subs(aGets[nEndereco],3,1))*2] := M->H6_TEMPO
	EndIf
EndIf

//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
//Ё Caso for Rotinas automaticas nao executar A680SalOPe         Ё
//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
If lRet .And. Type("l680Auto") == "U" .or. !l680Auto
	//M->H6_QTDPROD := A680SldOper(.T.,.F.,.F.)[1]
	If mv_par07 # 3
		M->H6_QTDPROD := A680SldOper(.T.,.F.,.T.)[1]
	Else
		M->H6_QTDPROD := A680SldOper(.T.,.F.,.F.)[1]
	EndIf
	M->H6_QTDPRO2 := ConvUm(SC2->C2_PRODUTO,M->H6_QTDPROD,M->H6_QTDPRO2,2)
	If M->H6_QTDPROD <= 0
		Help(" ",1,"A680OPTOT")
		lRet := .F.
	EndIf
EndIf

If lRet
	nEndereco := Ascan(aGets,{ |x| Subs(x,9,10) == "H6_QTDPROD" } )
	If nEndereco > 0
		nEnd1 := Val(Subs(aGets[nEndereco],1,2))
		nEnd2 := Val(Subs(aGets[nEndereco],3,1))*2
		nTam  := Len(aTela[nEnd1][nEnd2])
		nDec  := nTam-Rat(".",aTela[nEnd1][nEnd2])
		If nTam == nDec
			nDec := 0
		EndIf
		aTela[nEnd1][nEnd2] := Str(M->H6_QTDPROD,nTam,nDec)
	EndIf

	M->H6_PERDANT := A680PerdAnt(M->H6_OP, M->H6_OPERAC)
	nEndereco := Ascan(aGets,{ |x| Subs(x,9,10) == "H6_PERDANT" } )
	If nEndereco > 0
		nEnd1 := Val(Subs(aGets[nEndereco],1,2))
		nEnd2 := Val(Subs(aGets[nEndereco],3,1))*2
		nTam  := Len(aTela[nEnd1][nEnd2])
		nDec  := nTam-Rat(".",aTela[nEnd1][nEnd2])
		If nTam == nDec
			nDec := 0
		EndIf
		aTela[nEnd1][nEnd2] := Str(M->H6_PERDANT,nTam,nDec)
	EndIf

	aDados:=A680SldOper(.T.,mv_par07 == 1,.F.)
	nQuant2:=aDados[1]
	M->H6_PT := If((M->H6_QTDPROD + M->H6_QTDPERD) < A680SldProd(.T., !lPerdInf) .Or. (M->H6_QTDPROD + M->H6_QTDPERD) < nQuant2, "P", "T")

	nEndereco := Ascan(aGets,{ |x| Subs(x,9,10) == "H6_PT     " } )
	If nEndereco > 0
		aTela[Val(Subs(aGets[nEndereco],1,2))][Val(Subs(aGets[nEndereco],3,1))*2] := M->H6_PT
	EndIf
EndIf
Return lRet

/*
эээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤┘o    Ё A680QtModЁ Autor Ё Rodrigo de A. SartorioЁ Data Ё 25/09/96 Ё╠╠
╠╠цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤┘o Ё Calcula a qtd para ser gravada na qtd de MOD.              Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ
*/
Function A680QtMod()
Local nHora:=0,nMinutos:=0,nTime:=0
Local nPos:=AT(":",SH6->H6_TEMPO)
If nPos == 0
	nPos:=AT(":",PesqPict("SH6","H6_TEMPO"))
EndIf
If mv_par03 == 1
	nHora := Val(Substr(SH6->H6_TEMPO,1,nPos-1)+"."+Substr(SH6->H6_TEMPO,nPos+1,2))
	nMinutos := (((nHora-Int(nHORA))*100)/60)
	If nMinutos < 0  // Case seja negativo, o prg. subtrai 1 hora do tempo e soma nos minutos
		nTime --
		nMinutos := 1 + nMinutos
	EndIf
	nTime := (nTime+Int(nHORA))+nMinutos
Else
	// Caso nao achou ":", procura por "."
	If nPos == 0
		nPos:=AT(".",SH6->H6_TEMPO)
		If nPos > 0
			nTime := Val(SH6->H6_TEMPO)
		EndIf
	Else
		nTime := Val(Substr(SH6->H6_TEMPO,1,nPos-1)+"."+Substr(SH6->H6_TEMPO,nPos+1,2))
	EndIf
EndIf
Return nTime

/*
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддбдддддддбддддддддддддддддддддддбддддддбддддддддддд©╠╠
╠╠ЁFun┤└o    ЁA680LotCtlЁ Autor ЁRodrigo de A. SartorioЁ Data Ё 03/12/96  Ё╠╠
╠╠цддддддддддеддддддддддадддддддаддддддддддддддддддддддаддддддаддддддддддд╢╠╠
╠╠ЁDescri┤└o Ё Faz valida┤└o dos Lotes digitados na cria┤└o               Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁSintaxe   Ё A680LotCtl()                                               Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁUso       Ё Generico                                                   Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ
*/
Function A680LotCtl()
Local lRet			:=.T.
Local cConteudo	:=&(ReadVar())
Local cCod     	:= ""
Local cLocal   	:= ""
Local lHelp 		:= .T.
Local dDtValid

cCod		:= M->H6_PRODUTO
cLocal		:= M->H6_LOCAL
dDtValid	:= M->H6_DTVALID

If !Empty(cConteudo)
	If !Rastro(M->H6_PRODUTO)
		Help(" ",1,"NAORASTRO")
		lRet:=.F.
	EndIf
EndIf


dbSelectArea("SB8")
dbSetOrder(3)
If lRet .And. dbSeek(xFilial()+cCod+cLocal+cConteudo) .And. (dDtValid # SB8->B8_DTVALID)
	If	lHelp
		HelpAutoma(" ",1,"A240DTVALI",,,,,,,,,.F.)
	EndIf
	M->H6_DTVALID:=SB8->B8_DTVALID
EndIf

Return lRet

/*
ээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбдддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤┘o    ЁA680PerdAntЁ Autor Ё Rodrigo de A. SartorioЁ Data Ё 01/07/97 Ё╠╠
╠╠цддддддддддедддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤┘o Ё Retorna a Perda de outras operacoes desta OP.               Ё╠╠
╠╠юддддддддддаддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ
*/
Function A680PerdAnt(cOp,cOperac)
Local nRet:=0
Local aArea := GetArea()
Local cAliasSH6:= GetNextAlias()

//Gera a Query
BeginSql alias cAliasSH6

SELECT
	H6_OPERAC, SUM(H6_QTDPERD) QTDPERD, SUM(H6_PERDANT) PERDANT
FROM
	%table:SH6% SH6
WHERE
	SH6.H6_FILIAL = %xfilial:SH6% AND
	SH6.H6_OP = %Exp:cOp% AND
	SH6.%notDel%
GROUP BY
	SH6.H6_OPERAC
EndSql

While (cAliasSH6)->(!Eof())
	If (cAliasSH6)->H6_OPERAC < cOperac
		nRet+=(cAliasSH6)->QTDPERD
	ElseIf (cAliasSH6)->H6_OPERAC == cOperac
		nRet-=(cAliasSH6)->PERDANT
	EndIf
	(cAliasSH6)->(dbSkip())
EndDo

//Fecha a tabela
(cAliasSH6)->(DbCloseArea())

RestArea(aArea)

Return nRet

/*
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤┘o    Ё A680ConHrЁ Autor Ё Armando T. Buchina    Ё Data Ё 30.03.98 Ё╠╠
╠╠цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤┘o Ё Faz a consistencia dos Horarios importados pelo Coletor    Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁSintaxe   Ё A680ConHr()                                                Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠Ё Uso      Ё Mata680                                                    Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ
*/
Function A680ConHr()
Local lRet   := .T.
Local nHora,nMinutos
Local nPos

nPos:=AT(":",M->H6_HORAFIN)
If Val(Substr(M->H6_HORAFIN,nPos+1,2)) >= 60
	nHora:=Val(Substr(M->H6_HORAFIN,1,nPos-1))+1
	nMinutos:=Val(Substr(M->H6_HORAFIN,nPos+1,2))-60
	M->H6_HORAFIN :=StrZero(nHora,2)+":"+StrZero(nMinutos,2)
EndIf
If !(Empty(Substr(M->H6_HORAINI,1,nPos-1)) .Or. Empty(Substr(M->H6_HORAINI,nPos)) .Or. Empty(Substr(M->H6_HORAFIN,1,nPos-1)) .Or. Empty(Substr(M->H6_HORAFIN,nPos)))
	If Val(Substr(M->H6_HORAFIN,1,nPos-1)) > 24
		Help(" ",1,"A680HRINVL")
		lRet:=.F.
	ElseIf Val(Substr(M->H6_HORAFIN,1,nPos-1)) == 24
		If Val(Substr(M->H6_HORAFIN,nPos+1,2)) >= 60
			Help(" ",1,"A680HRINVL")
			lRet:=.F.
		EndIf
	EndIf
	If M->H6_HORAFIN  <= M->H6_HORAINI .And. M->H6_DATAFIN == M->H6_DATAINI .And. lRet
		Help(" ",1,"A680Hora")
		lRet := .F.
	EndIf
	If lRet
		M->H6_TEMPO := A680Calc()
	EndIf
EndIf

Return(lRet)

/*
эээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддбдддддддбддддддддддддддддддддддбддддддбддддддддддд©╠╠
╠╠ЁFun┤└o    ЁA680ShowOPЁ Autor ЁFernando Joly Siquini Ё Data Ё 30.12.98  Ё╠╠
╠╠цддддддддддеддддддддддадддддддаддддддддддддддддддддддаддддддаддддддддддд╢╠╠
╠╠ЁDescri┤└o Ё Consulta OP atraves da tecla F4                            Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁSintaxe   Ё A680ShowOP(a,b,c)                                          Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁUso       Ё MATA680                                                    Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ*/
Function A680ShowOp()
Local oDlg
Local nHdl      := GetFocus()
Local nOAT

Local nOpt1     := 0
Local aArray    := {}
Local cAlias    := Alias()
Local nOrder    := IndexOrd()
Local nRecno    := Recno()
Local cCampo    := ReadVar()
Local cPicture  := PesqPictQt('C2_QUANT',16)
Local nOrdSC2   := SC2->(IndexOrd())
Local lContinua	:= .T.
Local cQuery	:= ""
Local cAliasSC2 := "SC2"

If !(cCampo=='M->H6_OP')
	lContinua := .F.
ElseIf Empty(M->H6_PRODUTO)
	Help(' ',1,'A680NAOPRO')
	lContinua := .F.
EndIf

If lContinua
	cAliasSC2	:= CriaTrab(NIL,.f.)
	cQuery		:= "SELECT SC2.C2_NUM,SC2.C2_ITEM,SC2.C2_SEQUEN,SC2.C2_ITEMGRD,SC2.C2_PRODUTO, "
	cQuery		+= "SC2.C2_QUANT, SC2.C2_QUJE, SC2.C2_PERDA, SC2.C2_DATRF FROM "
	cQuery		+= 	RetSqlName("SC2")+" SC2 "
	cQuery		+= "WHERE "
	cQuery		+= "SC2.C2_FILIAL = '"+xFilial("SC2")+"' And "
	cQuery		+= "SC2.C2_PRODUTO = '"+M->H6_PRODUTO+"' And "
	cQuery		+= "SC2.C2_DATRF = '"+Dtos(Ctod(""))+"' And "
	cQuery		+= "SC2.D_E_L_E_T_ = ' ' "
	cQuery		:= ChangeQuery(cQuery)
	dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasSC2,.T.,.T.)
	aEval(SC2->(dbStruct()), {|x| If(x[2] <> "C" .And. FieldPos(x[1]) > 0, TcSetField(cAliasSC2,x[1],x[2],x[3],x[4]),Nil)})

	While (cAliasSC2)->(!Eof())
		(cAliasSC2)->(aAdd(aArray,{C2_NUM,C2_ITEM,C2_SEQUEN,C2_ITEMGRD,C2_PRODUTO,Transform(aSC2Sld(cAliasSC2),cPicture)}))
		(cAliasSC2)->(DbSkip())
	EndDo
	(cAliasSC2)->(DbCloseArea())
	DbSelectArea(cAlias)

	If !Empty(aArray)
		DEFINE MSDIALOG oDlg TITLE OemToAnsi(STR0015) From 09,0 To 16,50 OF oMainWnd     //'OPs deste Produto'
		@ 0.5,  0 TO 4, 20.0 OF oDlg
		@ 1,.7 LISTBOX oQual VAR cVar Fields HEADER OemToAnsi(STR0016),OemToAnsi(STR0017),OemToAnsi(STR0018),RetTitle("C2_ITEMGRD"),OemToAnsi(STR0019),OemToAnsi(STR0020) SIZE 150,35 ON DBLCLICK (nOpt1 := 1,oDlg:End())   //'Nёmero'###'Item'###'Sequ┬ncia'###'Produto'###'Saldo'
		oQual:SetArray(aArray)
		oQual:bLine := { || {aArray[oQual:nAT][1],aArray[oQual:nAT][2],aArray[oQual:nAT][3],aArray[oQual:nAT][4],aArray[oQual:nAT][5],aArray[oQual:nAT][6]}}
		DEFINE SBUTTON FROM 10  ,166  TYPE 1 ACTION (nOpt1 := 1,oDlg:End()) ENABLE OF oDlg
		DEFINE SBUTTON FROM 22.5,166  TYPE 2 ACTION oDlg:End() ENABLE OF oDlg
		ACTIVATE MSDIALOG oDlg VALID (nOAT := oQual:nAT,.t.)
		If nOpt1 == 1
			M->H6_OP := aArray[nOAT][1]+aArray[nOAT][2]+aArray[nOAT][3]+aArray[nOAT][4]
			nEndereco := Ascan(aGets,{ |x| Subs(x,9,5) == 'H6_OP' } )
			If nEndereco > 0
				aTela[Val(Subs(aGets[nEndereco],1,2))][Val(Subs(aGets[nEndereco],3,1))*2] := M->H6_OP
			EndIf
		EndIf
		SetFocus(nHdl)
	Else
		Help(' ',1,'A250NAOOP')
	EndIf
EndIf

dbSelectArea(cAlias)
dbSetOrder(nOrder)
dbGoTo(nRecno)
SC2->(dbSetOrder(nOrdSC2))
If lContinua
	CheckSx3("H6_OP")
EndIf
Return Nil

/*
эээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддбдддддддбддддддддддддддддддддддбддддддбддддддддддд©╠╠
╠╠ЁFun┤└o    ЁA680AskUltЁ Autor ЁRodrigo de A. SartorioЁ Data Ё 06/01/99  Ё╠╠
╠╠цддддддддддеддддддддддадддддддаддддддддддддддддддддддаддддддаддддддддддд╢╠╠
╠╠ЁDescri┤└o Ё Tela para confirmacao de ultimo apontamento                Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁSintaxe   Ё A680AskUlt()        		                                  Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁParametro Ё lPergunta - Indica se pergunta se И ultima operaГЦo        Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁUso       Ё MATA680/MATA681                                            Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ
*/
Function A680AskUlt(lPergunta)
Local cSavScrPer,lRet := .F.
Local lAbandona:=.F.
Local cText  := ""
Local cText1 := STR0021	//"O sistema nфo est═ validando as opera┤Дes, conforme selecionado"
Local cText2 := STR0022	//"atrav┌s do par┐metro MV_VLDOPER. preciso informar qual ser═ "
Local cText3 := STR0023	//"o ёltimo apontamento."
Local nPos   := 0
Local lExecAut := .F.

DEFAULT aRotAuto := {}
DEFAULT lPergunta := .F.

Static lResposta//Guarda o retorno quando ja foi perguntadose И a ultima operaГЦo

If l681 .And. l681Auto
	nPos := aScan(aRotAuto,{|x|Upper(AllTrim(x[1]))=="AUTASKULT"})
	lExecAut := .F.
	If nPos # 0
		lRet := aRotAuto[nPos,2]
		lExecAut := .T.
	EndIf

	If !lExecAut
		If ExistBlock('A680PERG')
			lRet := Execblock('A680PERG',.F.,.F.)
			If ValType(lRet) <> "L"
				lRet := .F.
			EndIf
		EndIf
	EndIf
Else
	//зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	//Ё Executa Ponto de Entrada para validacao da pergunta       Ё
	//юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
	If ExistBlock('A680PERG')
		If lResposta == NIL .and. !lPergunta//Se ainda nЦo passou pelo PE forГa a entrada no PE.
			lPergunta := .T.
		EndIf
		If lPergunta
			lResposta := Execblock('A680PERG',.F.,.F.)
			lRet := lResposta
		Else
			lRet := lResposta
		EndIf
		If ValType(lRet) <> "L"
			lRet := .F.
		EndIf
	Else
		If lResposta == NIL .and. !lPergunta//Se ainda nЦo passou pelo PE forГa a entrada no PE.
			lPergunta := .T.
		EndIf
		If lPergunta
			cText:=cText1+chr(10)+chr(13)+cText2+chr(10)+chr(13)
			cText+=cText3+chr(10)+chr(13)+STR0025	//"Confirma como ёltimo apontamento ?"
			lResposta:=(MsgYesNo(OemToAnsi(cText),OemToAnsi(STR0024)))	//"Aten┤└o"
			lRet := lResposta
		else
			lRet := lResposta
		EndIf
	EndIf
EndIf
Return lRet

/*/
эээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤┘o    Ё A680Veri Ё Autor Ё Marcelo Pimentel      Ё Data Ё 22.01.99 Ё╠╠
╠╠цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤┘o Ё Rotina para o campo Verifica: Inspeciona/Certifica         Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁSintaxe   Ё A680Veri()                                                 Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠Ё Uso      Ё Siga Quality -  via gatilho do cpo. H6_VERIFI.             Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ
/*/
Function A680Veri()
If !Empty(M->H6_PRODUTO)
	//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	//Ё Verifica se existe integracao com o QIP no apontamento das Producoes Ё
	//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
	If IntQIP(M->H6_PRODUTO,"2")
		QIPSitInsPro()
	EndIf
EndIf
Return(.T.)

/*/
эээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤┘o    Ё A680DICL Ё Autor Ё Marcelo Pimentel      Ё Data Ё 26.01.99 Ё╠╠
╠╠цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤┘o Ё Mostra a descricao das opcoes: Inspeciona/Certifica/Libera Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁSintaxe   Ё A680DICL(ExpN1,ExpL1)                                      Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁParametrosЁ ExpN1 = Opcao Inspeciona/Certifica/Libera Urgente          Ё╠╠
╠╠Ё          Ё ExpL1 = Indica se ┌ gatilho                                Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠Ё Uso      Ё Siga Quality                                               Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ
/*/
Function A680DICL(nOpcao,lGatilho)
Local cRet := "     "

lGatilho := If(lGatilho==NIL,.T.,lGatilho)

If Type("INCLUI") <> "U" .And. (!INCLUI .Or. lGatilho)
	//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	//Ё Verifica se existe integracao com o QIP no apontamento das Producoes Ё
	//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
	If IntQIP(SH6->H6_PRODUTO,"2")
		If nOpcao == 1
			cRet := OemToAnsi(STR0044)	//"Inspeciona"
		ElseIf nOpcao == 2
			cRet := OemToAnsi(STR0045)	//"Certifica"
		EndIf
	EndIf
Else
	cRet := Space(TamSX3("H6_INSCER")[1])
EndIf
Return(cRet)

/*/
эээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤┘o    Ё A680CEn1 Ё Autor Ё Marcelo Pimentel      Ё Data Ё 03/02/99 Ё╠╠
╠╠цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤┘o Ё Aciona consistencias a partir do Produto/Data Produ┤фo     Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠Ё Uso      Ё Siga Quality - Sigaqip                                     Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ
/*/
Function A680CEn1()
Local cRevi := ""
//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
//Ё Identifica a revisao vigente do Produto                              Ё
//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
If INCLUI .and. !Empty(SH6->H6_DTPROD)
	//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	//Ё Verifica se existe integracao com o QIP no apontamento das Producoes Ё
	//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
	If IntQIP(SH6->H6_PRODUTO,"2")
		cRevi      := QA_UltRevEsp(SH6->H6_PRODUTO,SH6->H6_DTPROD,.T.,,"QIP")
		M->H6_REVI := cRevi
	EndIf
EndIf

Return(cRevi)

/*
эээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤┘o    ЁMTA680TELAЁ Autor Ё Rodrigo de A. SartorioЁ Data Ё 06/12/95 Ё╠╠
╠╠цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤┘o Ё Chamada da listbox para caso de Erro.                      Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠Ё Uso      Ё MATA680                                                    Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ
*/
Static Function MTA680TELA(aErros)
LOCAL oDlg, oQual
LOCAL cCadastro := OemToAnsi(STR0057)	//"Itens Sem Saldo / Bloqueados"
DEFINE MSDIALOG oDlg TITLE cCadastro From 09,0 To 20,50 OF oMainWnd
@ 0.5,  0 TO 6, 20.0 OF oDlg
@ 1.4,.7 LISTBOX oQual VAR cVar Fields HEADER OemToAnsi(STR0019),OemToAnsi(STR0011),OemToAnsi(STR0020),OemToAnsi(STR0058) SIZE 150,50    //"Produto"###"Local"###"Saldo"###"Ocorr┬ncia"
oQual:SetArray(aErros)
oQual:bLine := { || {aErros[oQual:nAT][1],aErros[oQual:nAT][2],aErros[oQual:nAT][3],aErros[oQual:nAT][4]}}
DEFINE SBUTTON FROM 10  ,166  TYPE 1 ACTION (oDlg:End()) ENABLE OF oDlg
DEFINE SBUTTON FROM 22.5,166  TYPE 2 DISABLE OF oDlg
ACTIVATE MSDIALOG oDlg
Return NIL

/*
эээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбдддддддддддддбдддддддбддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤┘o    ЁA680VldEst   Ё Autor Ё Microsiga S/A      Ё Data Ё 29/08/06 Ё╠╠
╠╠цддддддддддедддддддддддддадддддддаддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤┘o Ё Validacao do Estorno                                       Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠Ё Uso      Ё MATA680                                                    Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ
*/
Static Function A680VldEst(lUltOper)
Local aSldSD7     := {}
Local lRet		  := .T.
Local nSaldoSB8   := 0
Local nQuantSDA	  := 0
Local nSaldoSB2   := 0
Local cSeekSB8	  := ""
Local cComparaSB8 := ""
Local cValor	  := ""
Local cHelp		  := ""
Local cAlias	  := Alias()
Local cEstNeg 	  := GetMV("MV_ESTNEG")
Local lEmpPrev    := SuperGetMV("MV_QTDPREV") == "S"
Local lLocaliz    := Localiza(SD3->D3_COD,.T.)

//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
//Ё Caso o produto use localizacao, verificar se producao ja foi Ё
//Ё distribuida.                                                 Ё
//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
If lLocaliz
	If !SuperGetMv("MV_WMSNEW",.F.,.F.) .Or. !IntWms(SD3->D3_COD)
		dbSelectArea("SDA")
		dbSetOrder(1)
		If dbSeek(xFilial("SDA")+SD3->D3_COD+SD3->D3_LOCAL+SD3->D3_NUMSEQ+SD3->D3_DOC)
			If SDA->DA_QTDORI # SDA->DA_SALDO
				dbSelectArea(cAlias)
				Help(" ",1,"SDAJADISTR")
				lRet:=.F.
			Else
				//здддддддддддддддддддддддддддддддддддддддддддддддддддддд©
				//Ё Obtem quantidade empenhada por esperar distribuicao  Ё
				//юдддддддддддддддддддддддддддддддддддддддддддддддддддддды
				nQuantSDA:=SDA->DA_QTDORI
			EndIf
		EndIf
		dbSelectArea(cAlias)
	Else
		nQuantSDA := WmsSldD0G(SD3->D3_COD,SD3->D3_LOCAL,SD3->D3_NUMSEQ,SD3->D3_DOC)
	EndIf
EndIf

//здддддддддддддддддддддддддддддддддддддддддддддддддддддд©
//Ё Verifica se saldo do Lote/Sub-Lote esta Ok p/ EstornoЁ
//юдддддддддддддддддддддддддддддддддддддддддддддддддддддды
If lRet .And. Rastro(SD3->D3_COD)
	dbSelectArea("SB8")
	dbSetOrder(3)
	If Rastro(SD3->D3_COD,"S")
		cSeekSB8 := xFilial("SB8")+SD3->D3_COD+SD3->D3_LOCAL+SD3->D3_LOTECTL+SD3->D3_NUMLOTE
		cComparaSB8:="B8_FILIAL+B8_PRODUTO+B8_LOCAL+B8_LOTECTL+B8_NUMLOTE"
	Else
		cSeekSB8 := xFilial("SB8")+SD3->D3_COD+SD3->D3_LOCAL+SD3->D3_LOTECTL
		cComparaSB8:="B8_FILIAL+B8_PRODUTO+B8_LOCAL+B8_LOTECTL"
	EndIf
	dbSeek(cSeekSB8)
	Do While !Eof() .And. cSeekSB8 == &(cComparaSB8)
		nSaldoSB8+=SB8SALDO(,,,,,lEmpPrev,,,.T.)-(SB8SALDO(.T.,,,,,lEmpPrev,,,.T.)+AvalQtdPre("SB8",1))
		dbSkip()
	EndDo
	dbSelectArea("SD3")
	//зддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	//Ё Soma Saldo no SB8 com quantidade que espera distribuicaoЁ
	//юддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
	If (nSaldoSB8+nQuantSDA) < D3_QUANT
		Help(" ",1,"MA240NEGLT")
		lRet:=.F.
	EndIf
EndIf

//зддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
//Ё Avalia se a producao possui saldo no CQ                 Ё
//юддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
If lRet
	SD7->( dbSetOrder(3) )
	If SD7->( MsSeek(xFilial("SD7")+SD3->D3_COD+SD3->D3_NUMSEQ) )
		aSldSD7 := A175CalcQt(SD7->D7_NUMERO, SD3->D3_COD, SD3->D3_LOCAL)
		If Len(aSldSD7) > 0 .And. QtdComp(SD3->D3_QUANT) > QtdComp(aSldSD7[6])
			Help(" ",1,"A680SLDCQ")
			lRet := .F.
		EndIf
	EndIf
EndIf

//зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
//Ё Se for Ultima Operacao, verifica se o Saldo esta OK  p/ estorno Ё
//юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
If lRet .And. lUltOper .And. cEstNeg == "N"
	dbSelectArea("SB2")
	dbSetOrder(1)
	If (!dbSeek(xFilial("SB2")+SD3->D3_COD+SD3->D3_LOCAL))
		CriaSB2(SD3->D3_COD,SD3->D3_LOCAL)
	EndIf
	nSaldoSB2 := SaldoMov(lLocaliz,.F.,Nil,A250PARTERC()==1,Nil,Nil,Nil,SD3->D3_EMISSAO)

	If QtdComp(nSaldoSB2) < QtdComp(SD3->D3_QUANT)
		If !A250SalPer(SD3->D3_QUANT)
			cValor:=Transform(nSaldoSB2-(SD3->D3_QUANT),PesqPictQt("B2_QATU",14))
			cHelp:=" : " + AllTrim(SB2->B2_COD)+"/"+SB2->B2_LOCAL +" ("+STR0070 +ALLTRIM(cValor)+")." //" Saldo : "
			Help ( " ", 1, "A680ESTORN",,cHelp,3,29)
			lRet:=.F.
		EndIf
	EndIf
EndIf

Return lRet

/*
эээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбдддддддддддддбдддддбддддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤┘o    Ё A680Potenc  ЁAutorЁRodrigo de A. SartorioЁ Data Ё 17/06/02 Ё╠╠
╠╠цддддддддддедддддддддддддадддддаддддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤┘o Ё Validacao para digitar a potencia do Lote corretamente     Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠Ё Uso      Ё Mata680                                                    Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ
*/
Function A680Potenc()
LOCAL lRet      := .T.
LOCAL cCod      := M->H6_PRODUTO
LOCAL cLocal    := SC2->C2_LOCAL
LOCAL cLote     := M->H6_NUMLOTE
LOCAL cLoteCtl  := M->H6_LOTECTL
LOCAL nPotencia := &(ReadVar())
LOCAL aAreaSB8  := SB8->(GetArea())
LOCAL cAlias    := Alias()

If !Empty(M->H6_LOCAL)
	cLocal := M->H6_LOCAL
EndIf

If !Rastro(cCod)
	Help(" ",1,"NAORASTRO")
	lRet:=.F.
Else
	If !PotencLote(cCod)
		Help(" ",1,"NAOCPOTENC")
		lRet:=.F.
	EndIf
	If lRet .And. (!Empty(cLoteCtl) .Or. !Empty(cLote))
		// Verifica se a data de validade pode ser utilizada
		dbSelectArea("SB8")
		dbSetOrder(3)
		If dbSeek(xFilial("SB8")+cCod+cLocal+cLoteCtl+IF(Rastro(cCod,"S"),+cLote,"")) .And. nPotencia # SB8->B8_POTENCI
			Help(" ",1,"POTENCORI")
			&(ReadVar()):=SB8->B8_POTENCI
		EndIf
		RestArea(aAreaSB8)
	EndIf
EndIf
dbSelectArea(cAlias)
Return lRet

/*
эээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠иммммммммммяммммммммммммкмммммммяммммммммммммммммммкммммммяммммммммммммм╩╠╠
╠╠╨Funcao    ЁA680ConvHora╨Autor  ЁMarcelo Iuspa     ╨ Data Ё  20/11/02   ╨╠╠
╠╠лммммммммммьммммммммммммймммммммоммммммммммммммммммйммммммоммммммммммммм╧╠╠
╠╠╨Desc.     Ё Converte caracter de hora de/para centesimal/normal        ╨╠╠
╠╠лммммммммммьмммммммммммммммммммммммммммммммммммммммммммммммммммммммммммм╧╠╠
╠╠╨ParametrosЁ cHora - Hora a ser convertida no formato HH:MM             ╨╠╠
╠╠╨          Ё cDe   - Formato da hora fornecida (N-Normal/C-Centesimal)  ╨╠╠
╠╠╨          Ё cPara - Formato a ser retornado   (N-Normal/C-Centesimal)  ╨╠╠
╠╠╨          Ё                                                            ╨╠╠
╠╠лммммммммммьмммммммммммммммммммммммммммммммммммммммммммммммммммммммммммм╧╠╠
╠╠╨Uso       Ё AP6                                                        ╨╠╠
╠╠хммммммммммомммммммммммммммммммммммммммммммммммммммммммммммммммммммммммм╪╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ
*/
Function A680ConvHora(cHora, cDe, cPara)
Local nTime    := Val(StrTran(cHora, ":", "."))
Local nHoras   := Int(nTime)
Local nMinutos := (nTime - nHoras)
Local lContinua:= .T.

If Empty(StrTran(cHora, ":", ""))
	lContinua := .F.
EndIf

If lContinua
	cPara := If(cPara == Nil, "N", cPara)

	If nMinutos >= .6 .And. cDe == "N"
		nHoras += 1
		nMinutos -= If(cPara == "N", .6, 1)
	EndIf

	If cDe == "N" .And. cPara == "C"
		nMinutos := nMinutos / .6
	ElseIf cDe == "C" .And. cPara == "N"
		nMinutos := nMinutos * .6
	EndIf
	cHora := StrZero(nHoras, At(":", cHora) - 1) + ":" + StrZero(nMinutos * 100, 2)
EndIf
Return(cHora)

/*
эээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠иммммммммммяммммммммммммкмммммммяммммммммммммммммммкммммммяммммммммммммм╩╠╠
╠╠╨Funcao    ЁA680Tempo   ╨Autor  ЁMarcelo Iuspa     ╨ Data Ё  20/11/02   ╨╠╠
╠╠лммммммммммьммммммммммммймммммммоммммммммммммммммммйммммммоммммммммммммм╧╠╠
╠╠╨Desc.     Ё Retorna tempo em horas (centesimal)                        ╨╠╠
╠╠лммммммммммьмммммммммммммммммммммммммммммммммммммммммммммммммммммммммммм╧╠╠
╠╠╨ParametrosЁ dDataIni - Data Inicial (referente a hora inicial)         ╨╠╠
╠╠╨          Ё cHoraIni - Hora Inicial (formato HH:MM)                    ╨╠╠
╠╠╨          Ё dDataFim - Data Final   (referente a hora final  )         ╨╠╠
╠╠╨          Ё cHoraFim - Hora Final   (formato HH:MM)                    ╨╠╠
╠╠╨          Ё                                                            ╨╠╠
╠╠лммммммммммьмммммммммммммммммммммммммммммммммммммммммммммммммммммммммммм╧╠╠
╠╠╨Uso       Ё AP6                                                        ╨╠╠
╠╠хммммммммммомммммммммммммммммммммммммммммммммммммммммммммммммммммммммммм╪╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ
*/
Function A680Tempo(dDataIni, cHoraIni, dDataFim, cHoraFim)
Local nDias 	:= 0 //dDataFim - dDataIni
Local cTime 	:= "" //ElapTime(cHoraIni + ":00", cHoraFim + ":00")
Local nHora 	:= 0 //Val(Left(cTime, 2))
Local nRet		:= 0
Local lContinua := .T.

If Empty(dDataFim) .Or. Empty(dDataIni)
	lContinua := .F.
Else
	nDias := dDataFim - dDataIni
EndIf

If lContinua
	If Empty(cHoraIni) .Or. Empty(cHoraFim)
		lContinua := .F.
	Else
		cTime := ElapTime(cHoraIni + ":00", cHoraFim + ":00")
		nHora := Val(Left(cTime, 2))
	EndIf
EndIf

If lContinua
	If Empty(StrTran(cHoraIni, ":", "")) .Or. Empty(StrTran(cHoraFim, ":", "")) .Or. Empty(dDataIni) .Or. Empty(dDataFim)
		lContinua := .F.
	EndIf
EndIf

If lContinua
	If nDias > 0 .And. Secs(cHoraFim) < Secs(cHoraIni)
		nDias --
	EndIf
	If nDias > 0
		nHora := nHora + (nDias * 24)
	EndIf
	nRet := (nHora + Val(Substr(cTime, 4, 2)) / 60)
EndIf
Return nRet

/*
ээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠иммммммммммямммммммммммммкмммммммяммммммммммммммммммкммммммяммммммммммммм╩╠╠
╠╠╨Funcao    ЁA680ChkH6Time╨Autor  ЁMarcelo Iuspa     ╨ Data Ё  01/02/03   ╨╠╠
╠╠лммммммммммьмммммммммммммймммммммоммммммммммммммммммйммммммоммммммммммммм╧╠╠
╠╠╨Desc.     Ё Checa se foi realizado procedimento para ajuste de H6_TEMPO ╨╠╠
╠╠лммммммммммьммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммм╧╠╠
╠╠╨Uso       Ё AP6                                                         ╨╠╠
╠╠хммммммммммоммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммм╪╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ
*/
Function A680ChkH6Time()
Static lChkH6Time
Local nPar03  := Nil
Local nRecH6  := Nil
Local lRet    := .T.
Local nTamSX1 := Len(SX1->X1_GRUPO)

If lChkH6Time == Nil                                           // Ainda nao testado na atual execucao
	If (lRet   := GetMV("MV_H6TIMEC",, .F.))                   // Ja foi testado em outra ocasiao (nao preciso testar novamente)
		lChkH6Time := .T.                                      // Seto variavel estatica para .T. para nao testar novamente na atual execucao
	Else                                                       // Preciso testar agora
		nPar03 := Posicione("SX1", 1,PADR("MTA680",nTamSX1)+"03", "X1_PRESEL")     // Inicializo variaveis locais somente na primeira execucao
		nRecH6 := SH6->(RecNo())
		If ! SH6->(dbSeek(xFilial("SH6"))) .Or. nPar03 == 2    // Se SH6 estiver vazio ou usa digitacao em centesimal nao preciso fazer nada
			if !A680PutX6(.T.)                                     // Gravo .T. no parametro MV_H6TIMEC para nao testar mais futuramente
				//MsgAlert(STR0113) // 'ParБmetro MV_H6TIMEC inexistente. и preciso criА-lo'
				Help(" ",1,"A680H6TIME1")
				lRet := .F.
			Else
				lRet       := .T.
				lChkH6Time := .T.                                  // Seto variavel estatica para .T. para nao testar novamente na atual execucao
			Endif
		Else
			//MsgAlert(STR0084) //"Necessario executar procedimento para checagem de campos do SH6"
			Help(" ",1,"A680H6TIME2")
			lRet := .F.                                        // Para nao prosseguir a execucao
		EndIf
		SH6->(dbGoto(nRecH6))                                  // Resturo registro no SH6 por causa do dbSeek acima
	EndIf
EndIf

Return(lRet)

/*
ээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠иммммммммммямммммммммммммкмммммммяммммммммммммммммммкммммммяммммммммммммм╩╠╠
╠╠╨Funcao    ЁA680PutX6    ╨Autor  ЁMarcelo Iuspa     ╨ Data Ё  01/02/03   ╨╠╠
╠╠лммммммммммьмммммммммммммймммммммоммммммммммммммммммйммммммоммммммммммммм╧╠╠
╠╠╨Desc.     Ё Atualiza parametro MV_H6TIMEC                               ╨╠╠
╠╠лммммммммммьммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммм╧╠╠
╠╠╨Uso       Ё AP6                                                         ╨╠╠
╠╠хммммммммммоммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммм╪╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ
*/
Function A680PutX6(lPar)
Local aSavAre := {SX6->(IndexOrd()), SX6->(RecNo()), Alias()}
Local cPar    := "MV_H6TIMEC"
Local cCon    := If( lPar == Nil .Or. lPar, "T", "F")
Local lRet    := .T.

dbSelectArea("SX6")
SX6->(dbSetOrder(1))
If SX6->(dbSeek(xFilial("SX6") + cPar))
	PutMv(cPar, cCon)
Else
	lRet := .F.
EndIf

SX6->(dbSetOrder(  aSavAre[1]))
SX6->(dbGoto(      aSavAre[2]))
SX6->(dbSelectArea(aSavAre[3]))

Return lRet

/*
ээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠иммммммммммямммммммммммммкмммммммяммммммммммммммммммкммммммяммммммммммммм╩╠╠
╠╠╨Funcao    ЁTimeH6x      ╨Autor  ЁMarcelo Iuspa     ╨ Data Ё  01/02/03   ╨╠╠
╠╠лммммммммммьмммммммммммммймммммммоммммммммммммммммммйммммммоммммммммммммм╧╠╠
╠╠╨Desc.     Ё Realiza procedimento para ajuste de H6_TEMPO                ╨╠╠
╠╠лммммммммммьммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммм╧╠╠
╠╠╨Uso       Ё AP6                                                         ╨╠╠
╠╠хммммммммммоммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммм╪╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ
*/
Function TimeH6x
Local oDlg
Local lRet := .T.

Private cCadastro := STR0085 //"Procedimento para checagem de H6_TEMPO"
Private cNumSeq1  := Space(Len(SD3->D3_NUMSEQ))
Private cNumSeq2  := Space(Len(SD3->D3_NUMSEQ))
Private nPar03    := Posicione("SX1", 1, "MTA68003", "X1_PRESEL")

Private nRegua    := 0
Private nTotRegua := 10 // SH6->(LastRec())
Private oRegua    := Nil

If GetMV("MV_H6TIMEC",, .F.)
	Aviso("TimeH6x", STR0086, {"Ok"})	 //"Procedimento ja executado"
	lRet := .F.
EndIf

If lRet .And. nPar03 == 2
	Aviso(STR0087, STR0088, {"Ok"}) //"BACKUP"###"Nao ha necessidade de executar este procedimento caso use tempo centesimal na digitacao do apontamento de producao"
	lRet := .F.
EndIf

If lRet
	DEFINE MSDIALOG oDlg TITLE AllTrim(cCadastro) Of oMainWnd PIXEL FROM 0,0 TO 200,500

	@ 20, 10  Say   STR0089     Size  270,6 Of oDlg Pixel //"Informar D3_NUMSEQ inicial para ajuste de H6_TEMPO:"
	@ 20, 190 MsGet cNumSeq1    Size   40,5 Of oDlg Pixel

	@ 40, 10  Say   STR0090     Size  270,6 Of oDlg Pixel //"Informar D3_NUMSEQ inicial para ajuste de H6_HORAINI/H6_HORAFIN"
	@ 40, 190 MsGet  cNumSeq2   Size   40,5 Of oDlg Pixel

	@ 65, 10 METER oRegua VAR nRegua TOTAL nTotRegua SIZE 230,8 OF oDlg NOPERCENTAGE PIXEL

	DEFINE SBUTTON FROM 82,165 TYPE  1 ACTION (If(TimeH6Run(),oDlg:End(),))  ENABLE OF oDlg PIXEL
	DEFINE SBUTTON FROM 82,200 TYPE  2 ACTION (oDlg:End())                    ENABLE OF oDlg PIXEL

	ACTIVATE MSDIALOG oDlg CENTERED
EndIf
Return lRet

/*
ээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠иммммммммммямммммммммммммкмммммммяммммммммммммммммммкммммммяммммммммммммм╩╠╠
╠╠╨Funcao    ЁTimeH6Run    ╨Autor  ЁMarcelo Iuspa     ╨ Data Ё  01/02/03   ╨╠╠
╠╠лммммммммммьмммммммммммммймммммммоммммммммммммммммммйммммммоммммммммммммм╧╠╠
╠╠╨Desc.     Ё Realiza procedimento para ajuste de H6_TEMPO                ╨╠╠
╠╠лммммммммммьммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммм╧╠╠
╠╠╨Uso       Ё AP6                                                         ╨╠╠
╠╠хммммммммммоммммммммммммммммммммммммммммммммммммммммммммммммммммммммммммм╪╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ
*/
Function TimeH6Run
Local cSeek
Local cFilD3	:= xFilial("SD3")
Local lOk    	:= MsgYesNo(STR0091, STR0092) //"Certifique-se de ter efetuado BACKUP de dados antes de prosseguir"###"Backup de Dados"
Local lAtu   	:= .F.
Local lRet   	:= .F.

If lOk
	If Empty(cNumSeq1) .Or. empty(cNumSeq2)
		Help(" ",1,"OBRIGAT2",, AllTrim(RetTitle("D3_NUMSEQ")), 4, 0)
    Else
		SD3->(dbSetOrder(1))

		dbSelectArea("SH6")
		dbSeek(cSeek := xFilial("SH6"))
		do While ! Eof() .and. H6_FILIAL == cSeek
			oRegua:Set(++nRegua)
			If SD3->(dbSeek(cFilD3 + SH6->(H6_OP + H6_PRODUTO)))
				If SD3->D3_NUMSEQ >= cNumSeq1 .And. Empty(SH6->H6_TIPOTEM)
					lAtu := .T.
					RecLock("SH6", .F.)
					SH6->H6_TEMPO   := A680ConvHora(SH6->H6_TEMPO, "C", "N")
					SH6->H6_TIPOTEM := 1
					If SD3->D3_NUMSEQ >= cNumSeq2
						SH6->H6_HORAINI := A680ConvHora(SH6->H6_HORAINI, "C", "N")
						SH6->H6_HORAFIN := A680ConvHora(SH6->H6_HORAFIN, "C", "N")
					EndIf
					MsUnlock()
				EndIf
			EndIf
			dbSkip()
		Enddo
		If lAtu
			if !A680PutX6(.T.)
				MsgAlert(STR0113) // 'ParБmetro MV_H6TIMEC inexistente. и preciso criА-lo'
				lRet := .F.
			Else
				lRet := .T.
			Endif
		Else
			MsgAlert(STR0093) //"Nenhum registro foi atualizado. Verifique se os dados foram informados corretamente"
		EndIf
	EndIf
Else
	MsgAlert(STR0094) //"Abortado"
EndIf
Return(lRet)

/*
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤└o    Ё A680LeReg  Ё Autor ЁRodrigo de A Sartorio  Ё Data Ё 05.06.03 Ё╠╠
╠╠цддддддддддеддддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤└o Ё Duplica um registro usando como base o registro posicionado  Ё╠╠
╠╠Ё          Ё pelo MBrowse.                                                Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁUso       Ё MATA680                                                      Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
*/
Function A680LeReg()
Local bCampo := { |nCPO| Field(nCPO) }
Local i
//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
//Ё Copia os campos do produto de refer┬ncia para a mem╒ria. Ё
//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
dbSelectArea("SH6")
FOR i := 1 TO FCount()
	If !(FieldName(i) $ "H6_QTDPROD/H6_QTDPERD")
		M->&(EVAL(bCampo,i)) := FieldGet(i)
	EndIf
NEXT i
Return

/*
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддддддбдддддддбдддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤┘o	 ЁA680RotPad    Ё Autor Ё Marcelo Iuspa       Ё Data Ё 10-07-03 Ё╠╠
╠╠цддддддддддеддддддддддддддадддддддадддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤┘o Ё Retorna o roteiro padrao da OP                               Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁParametrosЁ Nenhum                                                       Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁUso		 Ё MatA680                                                      Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ
*/
Function A680RotPad(cRoteiro,cProduto)
Local aSavAre  := {SB1->(GetArea()), SG2->(GetArea()), GetArea()}
Default cRoteiro := IIF(Alias()=="SH6",Posicione("SC2",1,xFilial("SC2")+SH6->H6_OP,"C2_ROTEIRO"),SC2->C2_ROTEIRO)
Default cProduto := IIF(Alias()=="SH6",SH6->H6_PRODUTO,SC2->C2_PRODUTO)
If Empty(cRoteiro)
	dbSelectArea("SB1")
	dbSetOrder(1)
	dbSeek(xFilial("SB1")+cProduto)
	If !Empty(SB1->B1_OPERPAD)
		cRoteiro:=SB1->B1_OPERPAD
	Else
		dbSelectArea("SG2")
		If a630SeekSG2(1,cProduto,xFilial("SG2")+cProduto+"01")
			dbSelectArea("SB1")
			RecLock("SB1",.f.)
			Replace B1_OPERPAD With "01"
			SB1->(MsUnLock())
			cRoteiro:="01"
		EndIf
	EndIf
EndIf
SB1->(RestArea(aSavAre[1]))
SG2->(RestArea(aSavAre[2]))
RestArea(aSavAre[3])
Return(cRoteiro)

/*
эээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддддбдддддддбдддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤└o    ЁA680TimeCaleЁ Autor ЁMarcelo A. Iuspa     Ё Data Ё 13/11/03 Ё╠╠
╠╠цддддддддддеддддддддддддадддддддадддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤└o Ё Retorna calendario do recurso na data especificada         Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠Ё Uso      Ё MATA690                                                    Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
эээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ
*/
Function A680TimeCale(dDataIni, cHoraIni, dDataFim, cHoraFim, cRecurso)
Local nDuracao := 0
Local dDataFor

For dDataFor := dDataIni to dDatafim
	cCalend := ASHICalen(cRecurso, dDataFor, .T.)
	nDuracao += PmsHrsItvl(dDataFor,If(dDataFor == dDataIni, cHoraIni, "00:00"),dDataFor,If(dDataFor == dDataFim, cHoraFim, "24:00"),cCalend,"",cRecurso,.T.)
Next
Return(nDuracao)
/*
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤└o    Ё A680SldProdЁ Autor ЁMarcelo Iuspa          Ё Data Ё 11.10.03 Ё╠╠
╠╠цддддддддддеддддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤└o Ё Calcula quanto tenho de saldo a produzir em uma operacao     Ё╠╠
╠╠Ё          Ё                                                              Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁUso       Ё MATA680                                                      Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
*/
Function A680SldProd(lTotOpe, lSomaPerda, lTotalProd)
Local aSavAre   := {SH6->(GetArea()), GetArea()}
Local nProd     := 0
Local nPerda    := 0
Local cAliasSH6 := GetNextAlias()
Default lTotOpe    := .F.
Default lSomaPerda := .F.
Default lTotalProd := .F.

//Gera a Query
BeginSql alias cAliasSH6

SELECT
	SH6.H6_OPERAC,
	SH6.H6_DESDOBR ,
	SH6.H6_SEQ,
	SUM(SH6.H6_QTDPROD) QTDPROD,
	SUM(SH6.H6_QTDPERD) QTDPERD
FROM
	%table:SH6% SH6
WHERE
	SH6.H6_FILIAL = %xfilial:SH6% AND
	SH6.H6_OP = %Exp:M->H6_OP% AND
	SH6.%notDel%
GROUP BY
	SH6.H6_OPERAC,
	SH6.H6_DESDOBR,
	SH6.H6_SEQ
EndSql

While (cAliasSH6)->(!Eof())
    If (cAliasSH6)->H6_OPERAC == M->H6_OPERAC
        If (lTotOpe .Or. (cAliasSH6)->(H6_DESDOBR + H6_SEQ) == M->H6_DESDOBR + M->H6_SEQ)
           nProd += (cAliasSH6)->(QTDPROD + If(!lPerdInf,(cAliasSH6)->QTDPERD,0))
        ElseIf lSomaPerda
                nPerda += (cAliasSH6)->QTDPERD
        EndIf
        Exit
    ElseIf lSomaPerda
            nPerda += (cAliasSH6)->QTDPERD
    EndIf
    (cAliasSH6)->(DbSkip())
Enddo
//Fecha a tabela
(cAliasSH6)->(DbCloseArea())

If ! lTotalProd
	nProd := Max(SC2->C2_QUANT - nPerda - nProd, 0)
EndIf

RestArea(aSavAre[1])
RestArea(aSavAre[2])

Return(nProd)

/*
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤└o    Ё A680SldOperЁ Autor ЁMarcelo Iuspa          Ё Data Ё 11.10.03 Ё╠╠
╠╠цддддддддддеддддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤└o Ё Calcula quanto posso produzir numa operacao                  Ё╠╠
╠╠Ё          Ё                                                              Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁUso       Ё MATA680                                                      Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
*/
Function A680SldOper(lH8Quant,lSomaPerda,lVlOperAnt)
Local aSavAre   := {SH6->(GetArea()), GetArea()}
Local cAlias	:= "SH6"
Local nProd     := 0
Local nPerda    := 0
Local aOperAnt  := A680OperAnt()
Local cOperAnt  := aOperAnt[1]
Local cSeqAnt   := aOperAnt[2]
Local nQtdRet   := 0
Local cOldParctot:="T"
Local lH6PtAtual
Local aAreaSH6	:= NIL
Local nVlAnt    := 0
Local cStatusAux := ""


Default lH8Quant   := .F.
Default lSomaPerda := .F.
Default lVlOperAnt := .T.

dbSelectArea("SH6")
dbSetOrder(1)



If !lVlOperAnt //Verifica somente o saldo da operacao
	cOperAnt := NIL
	cSeqAnt  := NIL
EndIf

If cOperAnt == Nil
	If (SC2->C2_NUM+SC2->C2_ITEM+SC2->C2_SEQUEN+SC2->C2_ITEMGRD) != M->H6_OP
		dbSelectArea("SC2")
		dbSeek(xFilial("SC2")+M->H6_OP)
	EndIf
	nProd := SC2->C2_QUANT
EndIf

cAlias := GetNextAlias()
BeginSql Alias cAlias
	SELECT H6_FILIAL, H6_OP, H6_OPERAC, H6_SEQ, H6_QTDPERD, H6_QTDPROD, H6_PT, H6_DESDOBR
 	FROM %table:SH6% SH6
	WHERE SH6.H6_FILIAL = %xFilial:SH6% AND
		SH6.H6_OP = %Exp:M->H6_OP% AND
		SH6.H6_OPERAC <= %Exp:M->H6_OPERAC% AND
	 	SH6.H6_SEQ <= %Exp:M->H6_SEQ% AND
		SH6.%NotDel%
	ORDER BY %Order:SH6%
EndSql
dbSelectArea(cAlias)

While ! Eof() .And. (cAlias)->H6_FILIAL + (cAlias)->H6_OP == xFilial("SH6") + M->H6_OP .And. (cAlias)->H6_OPERAC + (cAlias)->H6_SEQ <= M->H6_OPERAC + M->H6_SEQ
	nProdOper := 0
	If (cAlias)->H6_OPERAC + (cAlias)->H6_SEQ < M->H6_OPERAC + M->H6_SEQ
		If lSomaPerda
			nProd 		+= (cAlias)->H6_QTDPERD
			cOldParctot	:= (cAlias)->H6_PT
			nProdOper := nProd
		EndIf
	EndIf

	If cOperAnt # Nil .And. (cAlias)->H6_OPERAC + (cAlias)->H6_SEQ == cOperAnt + cSeqAnt .and. mv_par07 != 3
		nProd 		+= (cAlias)->H6_QTDPROD
		cOldParctot	:= (cAlias)->H6_PT
		nProdOper := nProd
	ElseIf lH8Quant .And. (cAlias)->H6_OPERAC + (cAlias)->H6_SEQ == M->H6_OPERAC + M->H6_SEQ .And. M->H6_DESDOBR == (cAlias)->H6_DESDOBR
		nProd 		-= (cAlias)->H6_QTDPROD + (cAlias)->H6_QTDPERD
		cOldParctot	:= (cAlias)->H6_PT

	ElseIf (cAlias)->H6_OPERAC + (cAlias)->H6_SEQ == M->H6_OPERAC + M->H6_SEQ .And. cOperAnt == Nil .And. (M->H6_DESDOBR # (cAlias)->H6_DESDOBR .or. l681Auto)
		nProd 		-= (cAlias)->H6_QTDPROD + If(lPerdInf,0,(cAlias)->H6_QTDPERD)
		cOldParctot	:= If(QtdComp(nProd - M->H6_QTDPROD) <= QtdComp(0),"T", (cAlias)->H6_PT)
		nProdOper := nProd
	EndIf


	IF (cAlias)->H6_OPERAC == cOperAnt .AND. (cAlias)->H6_SEQ == cSeqAnt
		nVlAnt 		:=   Max(nProdOper - nPerda, 0)
		cStatusAux 	:= (cAlias)->H6_PT
	EndIF

	(cAlias)->(dbSkip())

Enddo

IF (nVlAnt >= M->H6_QTDPROD) .And.	cStatusAux == "P" .And. len(aOperAnt) > 0
   cOldParctot := "P"
Else
    cOldParctot := "T"
EndIf

RestArea(aSavAre[1])
RestArea(aSavAre[2])

If lSomaPerda
	nPerda := 0
EndIf

nQtdRet := Max(nProd - nPerda, 0)

If lH8Quant .And. l680
	nQtdRet := Min(nQtdRet, SH8->H8_QUANT)
EndIf

(cAlias)->(dbCloseArea())

Return{nQtdRet,cOldParctot}

/*
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤└o    Ё A680OperAntЁ Autor ЁMarcelo Iuspa          Ё Data Ё 11.10.03 Ё╠╠
╠╠цддддддддддеддддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤└o Ё Retorna operacao/sequencia da operacao anterior              Ё╠╠
╠╠Ё          Ё                                                              Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁUso       Ё MATA680                                                      Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
*/
Function A680OperAnt()
	Local aSavAre  := {SC2->(GetArea()), SB1->(GetArea()), SG2->(GetArea()), GetArea(), SHY->(GetArea())}
	Local aAreSh8  := Nil
	Local cRoteiro := Space(Len(SC2->C2_ROTEIRO))
	Local cOperAtu := M->H6_OPERAC
	Local cSeqAtu  := M->H6_SEQ
	Local cOp      := M->H6_OP
	Local cOperAnt := Nil
	Local cSeqAnt  := Nil
	Local lIntSFC	:= FindFunction('IntegraSFC') .And. IntegraSFC() .And. !IsInCallStack("AUTO681")
	Local lProces
	Local l681		:= IsInCallStack("MATA681")
	Local cSeek    := Nil
	Local cSeekSHY
	Local aArray   := {}
	Local nSeek    := 0

	dbSelectArea("SHY")
	SHY->(dbSetOrder(1))
	lProces := SHY->(dbSeek(xFilial("SHY")+cOp))

	If l680
		// Vou jogar dados no array pois nao tenho o indice que preciso (H8_OP + H8_OPER + H8_SEQROTA)
		aAreSh8 := SH8->(GetArea())
		dbSelectArea("SH8")
		dbSeek(cSeek := xFilial("SH8") + cOp)
		do While ! Eof() .And. H8_FILIAL + H8_OP == cSeek
			cRoteiro := H8_ROTEIRO
			If (nSeek := aScan(aArray, {|z| z[1] + z[2] == H8_OPER + H8_SEQROTA})) == 0
				Aadd(aArray, {H8_OPER, H8_SEQROTA})
			EndIf
			dbSkip()
		Enddo
		aSort(aArray,,, {|z,w| z[1] + z[2] < w[1] + w[2]})
		If (nSeek := aScan(aArray, {|z| z[1] + z[2] == cOperAtu + cSeqAtu})) > 1
			cOperAnt := aArray[nSeek - 1, 1]
			cSeqAnt  := aArray[nSeek - 1, 2]
		EndIf
		RestArea(aAreSh8)
	EndIf
	If l681 .And. lProces //Verifica se processo foi iniciado pelo modelo 2 e parametro estА ativo para validaГЦo de operaГЦo pela SHY
		If cRoteiro == Nil .Or. Empty(cRoteiro)
			SC2->(dbSetOrder(1))
			SC2->(MsSeek(xFilial("SC2") + cOp))
			If ! Empty(SC2->C2_ROTEIRO)
				cRoteiro := SC2->C2_ROTEIRO
			Else
				SB1->(dbSetOrder(1))
				SB1->(MsSeek(xFilial("SB1") + M->H6_PRODUTO))
				If ! Empty(SB1->B1_OPERPAD)
					cRoteiro := SB1->B1_OPERPAD
				Else
					cRoteiro := StrZero(1, Len(SG2->G2_CODIGO))
				EndIf
				RestArea(aSavAre[1])
				RestArea(aSavAre[2])
			EndIf
		EndIf
		cSeekSHY	:= "SHY->(HY_FILIAL+HY_OP+HY_ROTEIRO)"
		A650SkHY(1,M->H6_PRODUTO,xFilial('SHY')+M->H6_OP+cRoteiro,@cSeekSHY)
		SHY->(dbEval({|| cOperAnt := HY_OPERAC},, {|| ! Eof() .And. Eval(&cSeekSHY) .And. SHY->HY_OPERAC < cOperAtu}))

		RestArea(aSavAre[5])
		If cOperAnt # Nil
			cSeqAnt := Space(Len(SH6->H6_SEQ))
		EndIf
	ElseIf ! l680 .Or. cOperAnt == Nil   // Nao consegui achar a operacao anterior pelas operacoes alocadas e vou tentar pelo roteiro de operacoes
		If cRoteiro == Nil .Or. Empty(cRoteiro)
			SC2->(dbSetOrder(1))
			SC2->(MsSeek(xFilial("SC2") + cOp))
			If ! Empty(SC2->C2_ROTEIRO)
				cRoteiro := SC2->C2_ROTEIRO
			Else
				SB1->(dbSetOrder(1))
				SB1->(MsSeek(xFilial("SB1") + M->H6_PRODUTO))
				If ! Empty(SB1->B1_OPERPAD)
					cRoteiro := SB1->B1_OPERPAD
				Else
					cRoteiro := StrZero(1, Len(SG2->G2_CODIGO))
				EndIf
				RestArea(aSavAre[1])
				RestArea(aSavAre[2])
			EndIf
		EndIf
		cSeek := "SG2->(G2_FILIAL+G2_PRODUTO+G2_CODIGO)"
		a630SeekSG2(1,M->H6_PRODUTO,xFilial("SG2") + M->H6_PRODUTO + cRoteiro,@cSeek)

		//Valida a data de validade da operaГЦo.
		While SG2->(!Eof()) .And. Eval(&cSeek) .And. SG2->G2_OPERAC < cOperAtu
			If !Empty(SG2->G2_DTINI)
				If !Empty(M->H6_DATAINI) .And. SG2->G2_DTINI > fConvertDt(M->H6_DATAINI)
					SG2->(dbSkip())
					Loop
				EndIf
				If !Empty(M->H6_DATAFIN) .And. SG2->G2_DTINI > fConvertDt(M->H6_DATAFIN)
					SG2->(dbSkip())
					Loop
				EndIf
			EndIf
			If !Empty(SG2->G2_DTFIM)
				If !Empty(M->H6_DATAINI) .And. SG2->G2_DTFIM < fConvertDt(M->H6_DATAINI)
					SG2->(dbSkip())
					Loop
				EndIf
				If !Empty(M->H6_DATAFIN) .And. SG2->G2_DTFIM < fConvertDt(M->H6_DATAFIN)
					SG2->(dbSkip())
					Loop
				EndIf
			EndIf
			cOperAnt := SG2->G2_OPERAC
			SG2->(dbSkip())
		End

		RestArea(aSavAre[3])
		If cOperAnt # Nil
			cSeqAnt := Space(Len(SH6->H6_SEQ))
		EndIf
	EndIf
	RestArea(aSavAre[4])
Return({cOperAnt,cSeqAnt})

/*
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤┘o    ЁA680Encer Ё Autor Ё Erike Yuri da Silva   Ё Data Ё 26/08/05 Ё╠╠
╠╠цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤┘o Ё Programa de Encerramento de Ops.                           Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁSintaxe   Ё A680Encer(ExpC1,ExpN1,ExpN2)                               Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁParametrosЁ ExpC1 = Alias do arquivo                                   Ё╠╠
╠╠Ё          Ё ExpN1 = Numero do registro                                 Ё╠╠
╠╠Ё          Ё ExpN2 = Numero da opcao selecionada                        Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠Ё Uso      Ё MATA680 e MATA681                                          Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ
*/
Function A680Encer(cAlias,nReg,nOpc)
Local lContinua 	:= .T.
Local lExistDocOp   := .F.
Local lIntSFC	 	:= IntegraSFC() .And. !IsInCallStack("AUTO681")
Local cChave		:= ""
Local cChaveCQ		:= ""
Local cAlmCQ		:= SuperGetMV("MV_CQ",.F.,"98")
local nRecSH6
Local cIdentPR0 := SH6->H6_IDENT
Local cChavPesq := SH6->(H6_OP+H6_PRODUTO+H6_OPERAC)

Local aBaixaSGF   := Nil
Local aChkBaixaC  := Nil
Local aPedidos    := {}
Local lConsumo    := .F.
Local lPerdatotal := .F.
Local nPercPrM	  := 0
Local lIntNewMRP  := Iif(_lNewMRP == Nil, FindFunction("Ma650MrpOn") .AND. Ma650MrpOn(@_lNewMRP),_lNewMRP)
Local aMRPxJson   := Iif(lIntNewMRP, {{}, JsonObject():New()}, Nil) //{aDados para commit, JsonObject() com RECNOS} - Integracao Novo MRP
Local lA680ENCOP  := ExistBlock("A680ENCOP")
Local lRetPE      := .T.

//зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
//Ё Variavel utilizada para Integracao com Quality - Processos  	Ё
//юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
Private cLocCQOrig  := ""
Private lIntQual	:= .F.
Private l250Auto 	:= If((l680 .And. l680Auto) .Or. (l681 .And. l681Auto),.T.,.F.)
Private lDelOpSC 	:= GetMV("MV_DELOPSC")== "S"
Private aAcho		:={}

CriaStatic()

//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
//Ё Forca o posicionamento no ultimo apontamento de producao.    Ё
//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
nRecSH6 := Recno()
dbSetOrder(1)
dbSeek(xFilial("SH6")+cChavPesq)
While !EOF() .And. H6_FILIAL+H6_OP+H6_PRODUTO+H6_OPERAC == xFilial("SH6")+cChavPesq
 	If SH6->H6_IDENT > cIdentPR0 .And. (SH6->H6_QTDPROD > 0 .Or. SH6->H6_QTDPERD > 0)
	    cIdentPR0:= SH6->H6_IDENT
		nRecSH6  := Recno()
	EndIf
	dbSkip()
End
dbGoTo(nRecSH6)
DbSelectArea("SD3")
DbSetOrder(1)

SC2->(dbSetOrder(1))
If SC2->(dbSeek(xFilial("SC2")+SH6->H6_OP))
	nPercPrM := (SH6->H6_QTMAIOR / SC2->C2_QUANT)
EndIf

If !Empty(SH6->H6_LOCAL)
	cChave := xFilial("SD3")+SH6->(H6_OP+H6_PRODUTO+H6_LOCAL)
Else
	SC2->(dbSetOrder(1))
	If SC2->(dbSeek(xFilial("SC2")+SH6->H6_OP))
		cChave := xFilial("SD3")+SH6->(H6_OP+H6_PRODUTO)+SC2->C2_LOCAL
	EndIf
EndIf
//-- Monta chave com alm. de CQ para verificar se a producao foi para CQ por skip lote
cChaveCQ := xFilial("SD3")+SH6->(H6_OP+H6_PRODUTO)+cAlmCQ

If SD3->(DbSeek(cChave))
	While SD3->(!Eof() .And. D3_FILIAL+D3_OP+D3_COD+D3_LOCAL==cChave)
		If Empty(SD3->D3_ESTORNO) .And. (SD3->D3_IDENT == SH6->H6_IDENT) .And. (Substr(SD3->D3_CF,1,2) == "PR")
			lExistDocOp := .T.
			Exit
		EndIf
		SD3->(DbSkip())
	EndDo
EndIf

//-- Procura producao que foi para CQ
If !lExistDocOP .And. SD3->(DbSeek(cChaveCQ))
	While SD3->(!Eof() .And. D3_FILIAL+D3_OP+D3_COD+D3_LOCAL==cChaveCQ)
		If Empty(SD3->D3_ESTORNO) .And. (SD3->D3_IDENT == SH6->H6_IDENT) .And. (Substr(SD3->D3_CF,1,2) == "PR")
			lExistDocOp := .T.
			Exit
		EndIf
		SD3->(DbSkip())
	EndDo
EndIf

//ValidaГЦo de apontamento com PERDA TOTAL da OP.
If SH6->H6_QTDPROD > 0 .Or. SH6->H6_QTDPERD > 0
	If SH6->H6_PT == "T" .And. QtdComp(SH6->H6_QTDPROD) == QtdComp(0) .And. QtdComp(SH6->H6_QTDPERD) > QtdComp(0)
		lExistDocOp := .T.
		lPerdatotal := .T.
	EndIf
EndIf

If !lExistDocOp
	Help(" ",1,"A250NAO")
	lContinua := .F.
EndIf

If lContinua .And. Subs(D3_CF,1,2) != "PR" .And. lPerdatotal = .F.
	Help(" ",1,"A250NAO")
	lContinua := .F.
EndIf

//-- Impede encerramento de OP integrada ao Chao de Fabrica
If lContinua .And. lIntSFC
	CYQ->(dbSetOrder(1))
	lContinua:= !CYQ->(dbSeek(xFilial("CYQ")+SH6->H6_OP))
	If !lContinua
		Aviso("AtenГЦo","Esta OP И movimentada somente atravИs do mСdulo ChЦo de FАbrica.",{"OK"})
	EndIf
EndIf

If lContinua
	If lA680ENCOP
		lRetPE := .T.
		lRetPE := ExecBlock("A680ENCOP",.F.,.F.)
		If ValType(lRetPE) # "L"
			lRetPE := .T.
		EndIf

		lContinua := lRetPE
	EndIf
EndIf

If lContinua
	//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	//Ё Array contendo os campos aceitos no MATXATU                  Ё
	//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
	AADD(aAcho,"D3_TM")
	AADD(aAcho,"D3_OP")
	AADD(aAcho,"D3_COD")
	AADD(aAcho,"D3_QUANT")
	AADD(aAcho,"D3_UM")
	AADD(aAcho,"D3_PARCTOT")
	AADD(aAcho,"D3_LOCAL")
	AADD(aAcho,"D3_CC")
	AADD(aAcho,"D3_CONTA")
	AADD(aAcho,"D3_EMISSAO")
	AADD(aAcho,"D3_DOC")
	AADD(aAcho,"D3_PERDA")
	AADD(aAcho,"D3_DESCRI")

	//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	//Ё Tratamento dos campos para utilizacao do Siga PyMe.          Ё
	//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
	If !lProdaut
		AADD(aAcho,"D3_LOTECTL")
		AADD(aAcho,"D3_DTVALID")
		AADD(aAcho,"D3_POTENCI")
	EndIf
	If IntWms()
		AADD(aAcho, 'D3_SERVIC')
	EndIf

	dbSelectArea("SX3")
	dbSeek("SD3")
	While !EOF() .And. (X3_ARQUIVO == "SD3")
		If X3USO(x3_usado) .And. cNivel >= x3_nivel .And. (ASCAN(aAcho,Trim(x3_campo)) == 0) .And. X3_PROPRI == "U"
			AADD(aAcho,TRIM(x3_campo))
		EndIf
		dbSkip()
	EndDo

	If lPerdatotal
	   //Verifica se a Ordem de Producao nao foi encerrada por outra estacao
	   	If SC2->(dbSeek(xFilial("SC2")+Alltrim(SH6->H6_OP))) .And. !Empty(SC2->C2_DATRF)
	   		Help(" ",1,"A250ENCERR")
	   	Else
			//здддддддддддддддддддддддддддддддддддддддддддддддддддд©
			//Ё Caso a perda nesta operacao seja total, verifica seЁ
			//Ё deve encerrar a OP ou nao.                         Ё
			//юдддддддддддддддддддддддддддддддддддддддддддддддддддды
			lEncerraOP:= Aviso(STR0024,STR0060,{STR0026,STR0027}) == 1 //"Aten┤└o"###"Este apontamento indica PERDA TOTAL da OP. Encerra Produ┤└o da OP nesta opera┤└o ?"###"Sim"###"N└o"
			If lEncerraOP
				//здддддддддддддддддддддддддддддддддддддддддддддддддддд©
				//Ё Busco por componentes a serem baixados na operacao Ё
				//Ё apontada                                           Ё
				//юдддддддддддддддддддддддддддддддддддддддддддддддддддды
				aBaixaSGF := A637BxComp(SH6->H6_PRODUTO, A680RotPad(), SH6->H6_OPERAC, SH6->H6_OP)
				//здддддддддддддддддддддддддддддддддддддддддддддддддддд©
				//Ё Checa se existe amarracao operacao x componente e  Ё
				//Ё se ja foi baixado o saldo empenhado para nao atualiЁ
				//Ё zar novamente saldo empenhado.                     Ё
				//юдддддддддддддддддддддддддддддддддддддддддддддддддддды
				aChkBaixaC := A680CkCmpP(SH6->H6_PRODUTO,SH6->H6_OPERAC,SH6->H6_OP)

				If !A680UltOper()
					lGeraD3Pro := .T.
					A680GeraD3("PR0",SH6->H6_IDENT,lEncerraOP)
				EndIf
				cA240End := A680GetEnd()
				cA680Ser := A680GetSer()
				lRollWMS := .F.
				lRet := A250Atu(cAlias,SH6->H6_IDENT,@aPedidos,,,,IIF(!Empty(aBaixaSGF) .And. !lPerdInf,SH6->H6_QTDPERD,),,,,,aChkBaixaC,,,nPercPrM,lEncerraOP,!lConsumo,@aMRPxJson)
				If !lRet .Or. lRollWMS
					Return
				EndIf
				If lEncerraOP
					A250End(.T., .F., @aMRPxJson)

					If utilizaCRP()
						MATA681ApontamentoCRP():encerraOrdemDeProducao(SH6->H6_OP)
					EndIf
				EndIf
			EndIf
	   	EndIf
	Else
		//Chama funcao de encerramento do Op do MATA250
		A250Encer("SD3",SD3->(RecNo()),nOpc)

		If utilizaCRP()
			MATA681ApontamentoCRP():encerraOrdemDeProducao(SH6->H6_OP)
		EndIf
	EndIf
EndIf
Return

/*
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддддддбдддддддбдддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤┘o	 ЁA680CkCmpP    Ё Autor Ё Erike Yuri da Silva Ё Data Ё 03/11/05 Ё╠╠
╠╠цддддддддддеддддддддддддддадддддддадддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤┘o Ё Retorna componentes que ja foram baixados na OP, conforme    Ё╠╠
╠╠Ё          Ё conforme operacao.                                           Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁParametrosЁ cProduto  = Produto a ser pesquisado                         Ё╠╠
╠╠Ё          Ё cOperacao = Operacao a ser pesquisada                        Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁUso		 Ё Mata680,Mata681                                              Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ
*/
Function A680CkCmpP(cProduto,cOper,cOp)
Local cRoteiro 	:= A680RotPad()
Local cSeek   	:= Nil
Local aBaixaSGF	:= Nil
Local lContinua	:= .T.

dbSelectArea("SD4")
dbSetOrder(2)
dbSeek(cSeek := xFilial("SD4") + cOp)

aBaixaSGF	:= {}
While SD4->(!Eof()) .And. cSeek == SD4->(D4_FILIAL + D4_OP)
	If !Empty(SD4->D4_OPERAC) .And. cOper != SD4->D4_OPERAC .And. SD4->D4_OP = cOp .And. SD4->D4_PRODUTO == cProduto .And. SD4->D4_ROTEIRO == cRoteiro
		aadd(aBaixaSGF,{D4_COD,D4_TRT,D4_OPERAC})
	EndIf
	SD4->(DbSkip())
EndDo

Return aBaixaSGF //Se o retorno for NIL indica que nao tem amarracao componente x produto


/*/
эээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбддддддддддбдддддддбдддддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁPrograma  ЁMenuDef   Ё Autor Ё Fabio Alves Silva     Ё Data Ё09/11/2006Ё╠╠
╠╠цддддддддддеддддддддддадддддддадддддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤┘o Ё Utilizacao de menu Funcional                               Ё╠╠
╠╠Ё          Ё                                                            Ё╠╠
╠╠Ё          Ё                                                            Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁRetorno   ЁArray com opcoes da rotina.                                 Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁParametrosЁParametros do array a Rotina:                               Ё╠╠
╠╠Ё          Ё1. Nome a aparecer no cabecalho                             Ё╠╠
╠╠Ё          Ё2. Nome da Rotina associada                                 Ё╠╠
╠╠Ё          Ё3. Reservado                                                Ё╠╠
╠╠Ё          Ё4. Tipo de Transa┤└o a ser efetuada:                        Ё╠╠
╠╠Ё          Ё		1 - Pesquisa e Posiciona em um Banco de Dados           Ё╠╠
╠╠Ё          Ё    2 - Simplesmente Mostra os Campos                       Ё╠╠
╠╠Ё          Ё    3 - Inclui registros no Bancos de Dados                 Ё╠╠
╠╠Ё          Ё    4 - Altera o registro corrente                          Ё╠╠
╠╠Ё          Ё    5 - Remove o registro corrente do Banco de Dados        Ё╠╠
╠╠Ё          Ё5. Nivel de acesso                                          Ё╠╠
╠╠Ё          Ё6. Habilita Menu Funcional                                  Ё╠╠
╠╠цддддддддддедддддддддддддддбдддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠Ё   DATA   Ё Programador   ЁManutencao efetuada                         Ё╠╠
╠╠цддддддддддедддддддддддддддедддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠Ё          Ё               Ё                                            Ё╠╠
╠╠юддддддддддадддддддддддддддадддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ
/*/

Static Function MenuDef()
PRIVATE aRotina	:= {	{STR0001,"AxPesqui"  , 0 , 1, 0, .F.},;	//"Pesquisar"
						{STR0002,"A680Visual", 0 , 2, 0, nil},;	//"Visualizar"
						{STR0003,"A680Inclui", 0 , 3, 0, nil},;	//"Incluir"
						{STR0096,"A680Altera", 0 , 4, 0, nil},; 	//"Horas Retr."
						{STR0005,"A680Deleta", 0 , 5, 0, nil},;	//"Estornar"
						{STR0097,"A680Encer", 0 , 7, 0, nil} }	 	//"Encerrar"

//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
//Ё Ponto de entrada utilizado para inserir novas opcoes no array aRotina  Ё
//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
If ExistBlock("MTA680MNU")
	ExecBlock("MTA680MNU",.F.,.F.)
EndIf
Return(aRotina)

/*
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбдддддддддддбдддддддбддддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤┘o    Ё A680GrPerd| Autor Ё Andre Anjos			Ё Data Ё 07/11/08 Ё╠╠
╠╠цддддддддддедддддддддддадддддддаддддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤┘o Ё Funcao para gravao dos dados da perda					  Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁParametrosЁ lGeraD3Pro: indica se foi gerado mov. de producao (PR0 SD3)Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠Ё Uso      Ё MATA680                                                    Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ
*/
Function A680GrPerd(lGeraD3Pro,aPerda,aHdPerda,cIdent)
Local aAreaSD3 := {}

Default cIdent := CriaVar("D3_IDENT",.F.)

If lGeraD3Pro
	aAreaSD3 := SD3->(GetArea())
	dbSelectArea("SD3")
	dbSetOrder(1)
	dbSeek(xFilial("SD3")+SH6->H6_OP+SH6->H6_PRODUTO)
	While SD3->(!EOF()) .And. xFilial("SD3")+SH6->(H6_OP+H6_PRODUTO) == SD3->(D3_FILIAL+D3_OP+D3_COD)
		If SD3->D3_IDENT == cIdent .And. SD3->D3_CF == "PR0" .And. SD3->D3_ESTORNO <> "S"
   			GravaSBC(SH6->H6_OP,SH6->H6_OPERAC,SH6->H6_RECURSO,"MATA680",SD3->D3_NUMSEQ,SH6->H6_IDENT)
			Exit
		EndIf
		SD3->(dbSkip())
	EndDo
	RestArea(aAreaSD3)
Else
	GravaSBC(SH6->H6_OP,SH6->H6_OPERAC,SH6->H6_RECURSO,"MATA680",,SH6->H6_IDENT)
EndIf
aPerda:={}
aHdPerda:={}
lSavePerda:=.F.

Return lSavePerda

/*
эээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠иммммммммммяммммммммммкмммммммяммммммммммммммммммммкммммммяммммммммммммм╩╠╠
╠╠╨Programa  ЁA680AtuInc╨Autor  ЁAndre Anjos         ╨ Data Ё  30/06/09   ╨╠╠
╠╠лммммммммммьммммммммммймммммммоммммммммммммммммммммйммммммоммммммммммммм╧╠╠
╠╠╨Descricao Ё Processa atualizacoes pertinentes a inclusao de um 		  ╨╠╠
╠╠╨          Ё apontamento.                                               ╨╠╠
╠╠лммммммммммьмммммммммммммммммммммммммммммммммммммммммммммммммммммммммммм╧╠╠
╠╠╨Uso       Ё MATA680, MATA681                                           ╨╠╠
╠╠хммммммммммомммммммммммммммммммммммммммммммммммммммммммммммммммммммммммм╪╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ
*/
Function A680AtuInc(lIsInc)
Local aAreaSH8 := {}
Local cRoteiro := ""
Local lIntSFC  := IntegraSFC() .And. IsInCallStack("AUTO681")

Default lIsInc := .T.

If lModZero
	Reclock("SH6", .F.)
	SH6->H6_IDENT := ProxNum()
	SH6->H6_TIPO := "P"
	SH6->H6_TIPOTEM := mv_par03

    If !l680
       SH6->H6_DESDOBR := "000"
    Else
       If Empty(SH6->H6_DESDOBR)
          If !Empty(SH8->H8_DESDOBR)
             SH6->H6_DESDOBR := SH8->H8_DESDOBR
          Else
             SH6->H6_DESDOBR := "000"
          EndIf
       Else
          If !Empty(SH8->H8_DESDOBR) .AND. SH6->H6_DESDOBR != SH8->H8_DESDOBR
             aAreaSH8 := SH8->(GetArea())
             If !SH8->(dbSeek(xFilial("SH8") + SH6->H6_OP + SH6->H6_OPERAC + SH6->H6_DESDOBR))
                SH8->(RestArea(aAreaSH8))
                SH6->H6_DESDOBR := SH8->H8_DESDOBR
             EndIf
             SH8->(RestArea(aAreaSH8))
          EndIf
       EndIf
    EndIf

	If lIsInc
		If l680
			SH6->H6_SEQCARG := SH8->H8_SEQCARG
		EndIf

		//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
		//Ё Preenche campos de integracao com Inspecao de Processos (QIP). Ё
		//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
		If IntQIP(SH6->H6_PRODUTO,"2")
			If SH6->H6_VERIFI == 2
				SH6->H6_CERQUA := QA_SEQUSX6("QIP_CEQU",TamSX3("H6_CERQUA")[1],"S","Certificado Qualidade")
				SH6->H6_LAUDO  := "A"
			EndIf

			SH6->H6_REVI   := QA_UltRevEsp(SH6->H6_PRODUTO,,,,"QIP")
			SH6->H6_IDENTE := QA_SEQU("QIP_IDEN",TamSX3("H6_IDENTE")[1],"A",OemToAnsi("Identificador Producao"))
			SH6->H6_PRDINV := Inverte(SH6->H6_DTPROD)
			SH6->H6_LOTINV := Inverte(SH6->H6_NUMLOTE)
			SH6->H6_IDEINV := Inverte(SH6->H6_IDENTE)
		EndIf
	Else
		If (l680 .And. l680Auto ) .Or. (l681 .And. l681Auto )
			SH6->H6_QTDPROD := 0
		EndIf
	EndIf

	If !lIntSFC
		IF FindFunction("fGravaSMO") //MATA250
			fGravaSMO(SH6->H6_IDENT, If(l680,'2','3'))
		EndIf
	EndIf

	//здддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	//ЁVerifica o Roteiro utilizado nesta OP                         Ё
	//юдддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
	SC2->(dbSetOrder(1))
	If SC2->(dbSeek(xFilial('SC2')+SH6->H6_OP,.F.)) .And. !Empty(SC2->C2_ROTEIRO)
		cRoteiro := SC2->C2_ROTEIRO
	Else
		SB1->(dbSetorder(1))
		If SB1->(dbSeek(xFilial('SB1')+SH6->H6_PRODUTO, .F.)) .And. !Empty(SB1->B1_OPERPAD)
			cRoteiro := SB1->B1_OPERPAD
		Else
			cRoteiro := StrZero(1, Len(SG2->G2_CODIGO))
		EndIf
	EndIf

	//зддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд©
	//Ё Integracao TOTVS APS: ajusta alocacoes se apontado em outro recurso Ё
	//юддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды
	SH6->(TAPSOperac(H6_OP,cRoteiro,H6_OPERAC,H6_RECURSO))

	If utilizaCRP() .And. MATA681ApontamentoCRP():opOperacaoProgramadas(SH6->H6_OP, SH6->H6_OPERAC)
		MATA681ApontamentoCRP():gravaApontamentosCRP(SH6->H6_OP, SH6->H6_OPERAC, SH6->H6_IDENT)
	EndIf
EndIf

Return

/*
эээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠иммммммммммяммммммммммкмммммммяммммммммммммммммммммкммммммяммммммммммммм╩╠╠
╠╠╨Programa  ЁA680EstTot╨Autor  ЁAndre Anjos         ╨ Data Ё  23/07/09   ╨╠╠
╠╠лммммммммммьммммммммммймммммммоммммммммммммммммммммйммммммоммммммммммммм╧╠╠
╠╠╨Descricao Ё Transforma apontamento total de uma operacao em parcial e  ╨╠╠
╠╠╨          Ё processa os ajustes necessarios.                           ╨╠╠
╠╠╨          Ё Importante: a OP nao e reaberta aqui pois e tratada em     ╨╠╠
╠╠╨          Ё outro ponto atraves de pergunta ao usuario.				  ╨╠╠
╠╠лммммммммммьмммммммммммммммммммммммммммммммммммммммммммммммммммммммммммм╧╠╠
╠╠╨ParametrosЁ nRecno: recno SH6 do apontamento total					  ╨╠╠
╠╠лммммммммммьмммммммммммммммммммммммммммммммммммммммммммммммммммммммммммм╧╠╠
╠╠╨Uso       Ё MATA680                                                    ╨╠╠
╠╠хммммммммммомммммммммммммммммммммммммммммммммммммммммммммммммммммммммммм╪╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ
*/
Static Function A680EstTot(nRecno)
Local aArea   := GetArea()
Local aAreaH6 := SH6->(GetArea())
Local cChave  := xFilial("SD3")+SH6->(H6_OP+H6_PRODUTO+H6_LOCAL)

SH6->(dbGoTo(nRecno))

//-- Transforma apontamento total da operacao em parcial
RecLock("SH6",.F.)
Replace SH6->H6_PT With "P"
SH6->(MsUnLock())

//Busca por apontamento relacionados na SD3 (em casos onde e a ultima operacao)
SD3->(dbSetOrder(1))
SD3->(dbSeek(cChave))
While !SD3->(EOF()) .And. SD3->(D3_FILIAL+D3_OP+D3_COD+D3_LOCAL) == cChave
	If SD3->D3_IDENT == SH6->H6_IDENT .And. AllTrim(SD3->D3_CF) == "PR0" .And. Empty(SD3->D3_ESTORNO)
		RecLock("SD3",.F.)
		Replace SD3->D3_PARCTOT With "P"
		SD3->(MsUnLock())
		Exit
	EndIf
	SD3->(dbSkip())
End

RestArea(aAreaH6)
RestArea(aArea)
Return

/*
эээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠иммммммммммяммммммммммкмммммммяммммммммммммммммммммкммммммяммммммммммммм╩╠╠
╠╠╨Programa  ЁTAPSOperac╨Autor  ЁAndre Anjos		 ╨ Data Ё  09/11/10   ╨╠╠
╠╠лммммммммммьммммммммммймммммммоммммммммммммммммммммйммммммоммммммммммммм╧╠╠
╠╠╨Descricao Ё Funcao para atualizar o recurso utilizado na operaГЦo e    ╨╠╠
╠╠╨          Ё para atualziar o status da operaГЦo.                       ╨╠╠
╠╠лммммммммммьмммммммммммммммммммммммммммммммммммммммммммммммммммммммммммм╧╠╠
╠╠╨ParametrosЁ cOP: Ordem de producao apontada.							  ╨╠╠
╠╠╨			 Ё cRoteiro: Roteiro de operacao utilizado na ordem.		  ╨╠╠
╠╠╨			 Ё cOperac: Operacao apontada.								  ╨╠╠
╠╠╨			 Ё cRecurso: Recurso utilizado no apontamento.				  ╨╠╠
╠╠лммммммммммьмммммммммммммммммммммммммммммммммммммммммммммммммммммммммммм╧╠╠
╠╠╨Uso       Ё Integracao Protheus X TOTVS APS							  ╨╠╠
╠╠хммммммммммомммммммммммммммммммммммммммммммммммммммммммммммммммммммммммм╪╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ
*/
Static Function TAPSOperac(cOP,cRoteiro,cOperac,cRecurso)
Local aArea   := GetArea()
Local cSituac := ""

If (SuperGetMV("MV_APS",.F.,"") == "TOTVS" .OR. SuperGetMV("MV_PCPATOR",.F.,.F.) == .T.)
	If Empty(cRecurso) //-- Estorno de apontamento
		BeginSQL Alias "SH6TMP"
			SELECT H6_PT, COUNT(*) REGS
			FROM %Table:SH6%
			WHERE %NotDel% AND
				H6_FILIAL = %xFilial:SH6% AND
				H6_OP = %Exp:cOP% AND
				H6_PRODUTO = %Exp:SH6->H6_PRODUTO% AND
				H6_OPERAC = %Exp:cOperac% AND
				R_E_C_N_O_ <> %Exp:SH6->(Recno())%
			GROUP BY H6_PT
			ORDER BY H6_PT DESC
		EndSQL

		cSituac := If(!SH6TMP->(EOF()) .And. SH6TMP->H6_PT == "T","3",If(SH6TMP->(EOF()),'1','2'))

		SH6TMP->(dbCloseArea())
	Else //-- Inclusao de apontamento
		cSituac := If(SH6->H6_PT == 'T','3','2')
	EndIf

	SHY->(dbSetOrder(1))
	If SHY->(dbSeek(xFilial("SHY")+cOP+cRoteiro+cOperac))
		RecLock("SHY",.F.)
		SHY->HY_SITUAC  := cSituac
		//-- Verifica se deve ajustar o recurso
		If !Empty(cRecurso) .And. !Empty(SHY->HY_RECURSO) .And. cRecurso # SHY->HY_RECURSO
			SHY->HY_RECURSO := cRecurso
		EndIf
		SHY->(MsUnLock())
	EndIf
EndIf

RestArea(aArea)
Return

/*
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбдддддддддддбдддддддбддддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤┘o    Ё A680VldChkЁ Autor Ё Leonardo Quintania   Ё Data Ё 11/10/12 Ё╠╠
╠╠цддддддддддедддддддддддадддддддаддддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤┘o Ё Validacao de checklist									  Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁParametrosЁ Nenhum                                                     Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠Ё Uso      Ё MATA680,MATA681 - Validacao do H6_OPERAC..			  	  Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ
*/
Function A680VldChk(cProduto,cRoteiro,cOper)
Local nPosChk	 := 0
Local nX		 := 0
Local aArea	 := GetArea()
Local lAuto	 := If(l680,l680Auto,l681Auto)
Local lRet	 := .T.

Private c631Rot := cRoteiro

If !lAuto
	SGR->(dbSetOrder(1))
	If SGR->(dbSeek(xFilial("SGR")+cProduto+cRoteiro+cOper))
	   	lRet := (FWExecView("CheckList","MATA631",MODEL_OPERATION_UPDATE,,{|| .T. })== 0 ) //-- Visualiza Check List
	EndIf
EndIf
RestArea(aArea)
Return lRet

/*эээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбдддддддддддбдддддддбддддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤ao    ЁA680VlPImp Ё Autor ЁRobson Sales          Ё Data Ё05/09/2013Ё╠╠
╠╠цддддддддддедддддддддддадддддддаддддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤ao ЁValida o percentual de importado digitado                   Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠Ё Uso      Ё MATA680                                                    Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ*/
Function A680VlPImp()

Local lRet   := .T.

If M->H6_PERIMP > 100 .Or. M->H6_PERIMP < 0
	Help(" ",1,"A250VLPIMP")
	Return lRet := .F.
EndIf

If !A680UltOper(.T.) .And. M->H6_PERIMP <> 0
	Help(" ",1,"A680ULTOPE")
	Return lRet := .F.
EndIf

Return lRet

/*эээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбдддддддддддбдддддддбддддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤ao    A680calen Ё                                Ё Data Ё11/09/2017Ё╠╠
╠╠цддддддддддедддддддддддадддддддаддддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤ao ЁValida o intervalo de datas de acordo com o calendАrio      Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠Ё Uso      Ё MATA680                                                    Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ*/
Function A680calen(dDataIni,dDatafim,cRecurso,cHorIni,cHorFim,aTempos)
	Local nPrecisao := GETMV("MV_PRECISA")

	Local ntotal    := 0 //Total de horas em decimal
	Local nDias     := 0
	Local nDias1    := 0
	Local nweek     := 0 //NЗmero da semana
	Local cCalend   := ""
	Local aCalend   := {}
	Local nInicio   := 1
	Local nTamDia   := 1440/(60/nPrecisao)

	Local cIdent    := " " // Identificador para controle de horas de parada no calendario
	Local aHorIni   := {} //Hora inicial do calendАrio
	Local aHorFim   := {} //Hora final do calendАrio
	Local aHorInip  := {} //Hora inicial parada do calendАrio
	Local aHorFimp  := {} //Hora final parada do calendАrio

	Local dDataFor  := Nil
	Local nHorFim   := 0
	Local nHorIni   := 0
	Local nx        := 0
	Local nIni      := 0
	Local nFim      := 0

	Local lSepTempos := (ValType(aTempos) == "A")

	If (Empty(cHorIni) .And. Empty(cHorFim)) .or. Empty(dDataIni)
		Return 0
	EndIf

	If !empty(cHorIni) .And. empty(cHorFim)
		nHorIni = val(substring(cHorIni,1,2)) + (Val(substring(cHorIni,4,2))/60)
		Return nHorIni
	EndIf

	//Descobrir qual И a semana que a data informada pertence
	For dDataFor := dDataIni To dDatafim
		ASHICalen( , , , .T.) // Limpa o array static aRecCalen, para trazer os dados atualizados.
		cCalend := ASHICalen(cRecurso, dDataFor, .T.)
		nweek   := DOW(dDataFor)
	Next dDataFor

	nweek := nweek - 1 //O calendАrio do Protheus comeГa na segunda e a funГao DOW a semana comeГa no Domingo.

	If nweek == 0
		nweek := 7
	EndIf

	//Buscar o calendАrio do recurso
	dbSelectArea("SH7")
	If MsSeek(xFilial("SH7")+cCalend)
		cCalend := SH7->H7_ALOC
	Endif

	For nDias := 1 to 7
		AADD(aCalend,Substr(cCalend,nInicio,nTamDia)) //separa o calendАrio em dias da semana
		nInicio += nTamDia
	Next nDias

	//hora inicial e final do calendАrio em nЗmero para cАlculo.
	For nDias := 1 To Len(aCalend)
		If !Empty(aCalend[nDias])
			AADD(aHorIni ,((60/nPrecisao)/60)*(AT("X",Upper(aCalend[nDias]))-1))

			AADD(aHorFim, ((60/nPrecisao)/60)*(RAT("X",Upper(aCalend[nDias]))))
		EndIf

		//Hora inicial e final das paradas do calendАrio em nЗmero para cАlculo
		For nDias1 := AT("X",Upper(aCalend[nDias])) To RAT("X",Upper(aCalend[nDias]))
			If Substr(Upper(aCalend[nDias]),nDias1,1) == cIdent
				If Empty(cIdent)
					AADD(aHorInip, {nDias, ((60/nPrecisao)/60)*(nDias1-1)})
					cIdent  := "X"
				Else
					AADD(aHorFimp, {nDias,((60/nPrecisao)/60)*(nDias1-1)})
					cIdent  := " "
				EndIf
			EndIf
		Next nDias1
	Next nDias

	//Transforma a hora do apontamento em nЗmero para cАlculo
	nHorIni = val(substring(cHorIni,1,2)) + (Val(substring(cHorIni,4,2))/60)
	nHorFim = val(substring(cHorFim,1,2)) + (Val(substring(cHorFim,4,2))/60)

	If dDataIni == dDatafim
		If len(aHorIni) >= nweek
			nIni := Max(nHorIni, aHorIni[nweek])
			nFim := Min(nHorFim, aHorFim[nweek])
			If aHorIni[nweek] <= nHorIni .And.  nHorFim <= aHorFim[nweek] //Se a hora informada no apontamento И menor que a hora inicial do calendАrio, serА considerada a hora informada
				ntotal += nHorFim - nHorIni
			Else
				If aHorIni[nweek] >= nHorIni .And.  nHorFim <= aHorFim[nweek] //Se a hora informada no apontamento И menor que a hora inicial do calendАrio, serА considerada a hora inicial do calendАrio
					If nHorFim <= aHorIni[nweek]
						ntotal := 0
						nFim   := nIni
					Else
						ntotal += nHorFim - aHorIni[nweek]
					EndIf
				Else
					If aHorIni[nweek] >= nHorIni .And.  nHorFim >= aHorFim[nweek] //Se a hora informada no apontamento estА fora dos horАrios do calendАrio
						ntotal += aHorFim[nweek] - aHorIni[nweek]
					Else
						If aHorIni[nweek] <= nHorIni .And.  nHorFim >= aHorFim[nweek] .And. aHorFim[nweek] > nHorIni
							ntotal += aHorFim[nweek] - nHorIni
						EndIf
					EndIf
				EndIf
			EndIf

			For nx:= 1 to len(aHorInip)
				If aHorInip[nx,1] == nweek
					If aHorfimp[nx,2] <= nHorFim .And. nHorIni <= aHorInip[nx,2] .And. nHorIni <= aHorFimp[nx,2]
						ntotal = ntotal -  (aHorFimp[nx,2]  - aHorInip[nx,2])
					Else
						If nHorFim >= aHorInip[nx,2] .And. nHorFim <= aHorfimp[nx,2]
							ntotal = ntotal - (nHorfim - aHorInip[nx,2])
						Else
							If nHorIni >= aHorInip[nx,2] .And. nHorIni <= aHorFimp[nx,2] .And. aHorfimp[nx,2] <= nHorFim
								ntotal = ntotal - (aHorfimp[nx,2] - nHorIni)
							EndIf
						EndIf
					EndIf

					If lSepTempos
						If nIni < aHorInip[nx,2] .And. aHorInip[nx,2] < nFim
							aAdd(aTempos, {dDataIni, formatHora(nIni), formatHora(aHorInip[nx,2]), (aHorInip[nx,2]-nIni)*60})
							nIni := aHorFimp[nx,2]

						ElseIf nIni >= aHorInip[nx,2] .And. nIni <= aHorFimp[nx,2] .And. aHorfimp[nx,2] <= nFim
							nIni := aHorFimp[nx,2]
						EndIf
					EndIf
				EndIf
			Next nX

			If lSepTempos .And. nIni < nFim
 				aAdd(aTempos, {dDataIni, formatHora(nIni), formatHora(nFim), (nFim-nIni)*60})
			EndIf
		Else
			ntotal:= 0
		EndIf
	Else
		For dDataFor := dDataIni To dDatafim
			nweek := DOW(dDataFor)
			nweek := nweek - 1 //O calendАrio do Protheus comeГa na segunda e a funГao DOW a semana comeГa no Domingo.

			If nweek == 0
				nweek := 7
			EndIf

			If len(aHorIni) >= nweek

				nIni := aHorIni[nweek]
				If aHorIni[nweek] <= nHorIni .And. aHorFim[nweek] > nHorIni .And. dDataFor == dDataIni //Se a hora informada no apontamento И menor que a hora inicial do calendАrio, serА considerada a hora informada
					ntotal += aHorFim[nweek] - nHorIni
					nIni   := nHorIni
				Else
					If aHorIni[nweek] >= nHorIni .And. dDataFor == dDataIni //Se a hora informada no apontamento И maior que a hora inicial do calendАrio, serА considerada a hora inicial do calendАrio
						ntotal += aHorFim[nweek] - aHorIni[nweek]
					EndIf
				EndIf

				If dDatafor > dDataIni .And. Ddatafor < dDataFim
					ntotal += aHorFim[nweek] - aHorIni[nweek]
				EndIf

				nFim := aHorfim[nweek]
				If aHorfim[nweek] >= nHorFim .And. aHorIni[nweek] < nHorFim .And. dDataFor == dDataFim
					ntotal +=  nHorFim - aHorIni[nweek]
					nFim   := nHorFim
				Else
					If aHorfim[nweek] <= nHorFim .And. dDataFor == dDataFim
						ntotal += aHorFim[nweek] - aHorIni[nweek]
					EndIf
				EndIf

				For nx := 1 to len(aHorInip)
					If aHorInip[nx,1] == nweek
						If dDataFor == dDataIni .And.  aHorFim[nweek] >= aHorfimp[nx,2] .And. nHorIni <= aHorInip[nx,2]
							ntotal = ntotal -  (aHorFimp[nx,2]  - aHorInip[nx,2])
						Else
							If dDataFor == dDataIni .And. aHorFim[nweek] >= aHorFimp[nx,2] .And. nHorIni >= aHorInip[nx,2] .And. nHorIni <= aHorFimp[nx,2]
								ntotal = ntotal - (aHorFimp[nx,2] - nHorIni)
							EndIf
						EndIf

						If dDataFor == dDataFim .And. nHorFim >= aHorInip[nx,2] .And. nHorFim >= aHorfimp[nx,2]
							ntotal = ntotal -  (aHorFimp[nx,2]  - aHorInip[nx,2])
						Else
							If dDataFor == dDataFim .And. nHorFim >= aHorInip[nx,2] .And. nHorFim <= aHorfimp[nx,2]
								ntotal = ntotal - (nHorFim - aHorInip[nx,2])
							EndIf
						EndIf

						//Se o dia nЦo for a data inicio ou fim, considera todas as paradas do calendАrio.
						If dDataFor <>  dDataFim .And. dDataFor <> dDataIni
							ntotal = ntotal -  (aHorFimp[nx,2]  - aHorInip[nx,2])
						EndIf

						If lSepTempos
							If nIni < aHorInip[nx,2] .And. aHorInip[nx,2] < nFim
								If dDataFor <> dDataFim .Or. (dDataFor == dDataFim .And. aHorInip[nx,2] < nFim)
									aAdd(aTempos, {dDataFor, formatHora(nIni), formatHora(aHorInip[nx,2]), (aHorInip[nx,2]-nIni)*60})
									nIni := aHorFimp[nx,2]
								EndIf
							ElseIf nIni >= aHorInip[nx,2] .And. nIni <= aHorFimp[nx,2] .And. aHorfimp[nx,2] <= nFim
								nIni := aHorFimp[nx,2]
							EndIf
						EndIf
					EndIf
				Next nX

				If lSepTempos .And. nIni < nFim
					aAdd(aTempos, {dDataFor, formatHora(nIni), formatHora(nFim), (nFim-nIni)*60})
				EndIf
			EndIf
		Next dDataFor
	EndIf

Return ntotal

/*
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбдддддддддддбдддддддбддддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤┘o    Ё A680ShowF4 Ё Autor ЁMichelle RamosЁ     Data Ё 12/09/2017  Ё╠╠
╠╠цддддддддддедддддддддддадддддддаддддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤┘o Ё consulta padrЦo de ordem de produГЦo/saldos  				 Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠ЁParametrosЁ Nenhum                                                     Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠Ё Uso      Ё MATA681                                                    Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ
*/
Static Function A680ShowF4()
Local cCampo:=AllTrim(Upper(ReadVar()))
If cCampo == "M->H6_PRODUTO" .Or. cCampo == "M->H6_QTDPROD"
	MaViewSB2(M->H6_PRODUTO)
ElseIf cCampo == "M->H6_OP"
	A680ShowOp()
EndIf

Return NIL

/*----------------------------------------------------------------
 FunГЦo para retornar valor preenchido do endereГo WMS em MATA681
/*--------------------------------------------------------------*/
Function A680GetEnd()

CriaStatic()

Return cA240End

/*---------------------------------------------------------------
 FunГЦo para retornar valor preenchido do serviГo WMS em MATA681
/*-------------------------------------------------------------*/
Function A680GetSer()

CriaStatic()

Return cA680Ser

// Valida se a ordem jА foi apontada no MATA680/MATA681
Static Function A680VerApo()
Local aArea := GetArea()
Local cAlias := GetNextAlias()
Local cQuery := ""
Local lRet   := .T.

// Valida se a ordem jА foi apontada no MATA250
cQuery := " SELECT * FROM "+RetSqlName('SD3') + " SD3 "
cQuery += "  WHERE SD3.D3_FILIAL  = '"+xFilial("SD3")+"' "
cQuery += "    AND SD3.D3_OP      = '"+M->H6_OP+"' "
cQuery += "    AND SD3.D3_ESTORNO <> 'S' "
cQuery += "    AND SD3.D3_CF      = 'PR0' "
cQuery += "    AND SD3.D_E_L_E_T_ = ' ' "
cQuery += "    AND NOT EXISTS (SELECT * FROM "+RetSqlName('SH6') + " SH6 "
cQuery += "                     WHERE SH6.H6_FILIAL  = '"+xFilial("SH6")+"' "
cQuery += "                       AND SH6.H6_OP      = SD3.D3_OP "
cQuery += "                       AND SH6.H6_PRODUTO = SD3.D3_COD "
cQuery += "                       AND SH6.H6_IDENT   = SD3.D3_IDENT "
cQuery += "                       AND SH6.D_E_L_E_T_ = ' ')"

dbUseArea( .T., 'TOPCONN', TcGenQry(,,cQuery), cAlias, .T., .F. )

(cAlias)->(dbGotop())
While !(cAlias)->(Eof())
   Aviso('MATA680',STR0114,{'Ok'}) //Ordem jА apontada pelo MATA250 (Apontamento Simples). NЦo И permitido realizar o apontamento.
   lRet = .F.
   Exit
(cAlias)->(dbSkip())
End
(cAlias)->(dbCloseArea())

RestArea(aArea)

return lRet

/*/{Protheus.doc} A680Recur
Faz a validaГЦo do recurso, e verifica se И necessАrio recalcular o tempo total do apontamento.
@type  Function
@author lucas.franca
@since 11/01/2019
@version P12
@return lRet, Logical, Indica se o cСdigo do recurso И vАlido.
/*/
Function A680Recur()
	Local lRet := .T.

	//Se utiliza o CRP ou as datas e horas do apontamento jА estiverem informadas, calcula o tempo da operaГЦo de acordo com o recurso informado.
	If utilizaCRP() .Or. (!Empty(M->H6_HORAINI) .And. !Empty(M->H6_HORAFIN) .And. !Empty(M->H6_DATAINI) .And. !Empty(M->H6_DATAFIN))
		M->H6_TEMPO := A680Calc()
	EndIf

	If !l680Auto .And. SuperGetMv("MV_BLQREC", .F., 0) != 0
  		lRet := A680Hora()
	EndIf

Return lRet

/*/{Protheus.doc} CriaStatic
Cria variАveis statics
@type  Static Function
@author Juliana.oliveira
@since 27/01/2023
@version P12
/*/
Static Function CriaStatic()

If cA240End == nil
	cA240End := CriaVar('DB_LOCALIZ')
EndIf

If cA680Ser == nil
	cA680Ser := Criavar('D3_SERVIC')
EndIf

Return

/*/{Protheus.doc} utilizaCRP
Verifica se possui a tabela do CRP no dicionario de dados.
@type  Static Function
@author Lucas Fagundes
@since 11/12/2023
@version P12
@return lUtiliza, Logico, Indica se utiliza o CRP.
/*/
Static Function utilizaCRP()
	Local lUtiliza := .F.

	If _lDicCRP == Nil
		_lDicCRP := FwAliasInDic("HWF", .F.)
	EndIf

	lUtiliza := l681 .And. _lDicCRP

Return lUtiliza

/*/{Protheus.doc} a250QTMA
	Verifica saldo da OP quando existe produГЦo a maior
	@type Static Function
	@author michele.girardi
	@since 19/12/2023
	@version version
	@param nOP - nЗmero da OP
	       nQuant - quantidade apontada
		   nQtdPerd - quantidade perda apontada
	@return - nil

	lMaiorAuto = .T. --> possui produГЦo a maior e a OP nЦo possui saldo para produzir
	lMaiorAuto = .F. --> possui produГЦo a maior e a OP possui saldo para produzir
/*/
Function a250QTMA(nOP, nQuant, nQtdPerd)

	Local nProduz	 := 0
	Local nExcede 	 := 0
	Local nExcedeAtu :=0
	Local aAreaSH61     := {}

	DbSelectArea("SC2")
	SC2->(dbSetOrder(1))
	If SC2->(dbSeek(xFilial("SC2") + nOP))
		cOpeSaldo := M->H6_OPERAC
		cSeqSaldo := M->H6_SEQ

		If mv_par07 == 1
			lCoPer := .T.
			lCoOA  := .F.
		Else
			If mv_par07 == 2
				lCoPer := .F.
				lCoOA  := .F.
			Else
				lCoPer := .F.
				lCoOA  := .F.
			EndIf
		EndIf

		nProduz := A680SldOper(l680,lCoPer,lCoOA)[1] //Retorna o apontamento anterior

		//nProduz    - saldo da quantidade que ja foi apontada ate o momento
		//nQuant     - quantidade que esta sendo apontada agora
		//nExcede    - quantidade que excedeu considerando todos os apontamentos
		//nExcedeAtu - quantidade que excedeu no apontamento corrente

		If !lPerdInf
			nQuant := nQuant + nQtdPerd
		EndIf

		If nQuant > nProduz
			nSomaAponN := 0

			aAreaSH61  := SH6->(GetArea())
			dbSelectArea("SH6")
			dbSetOrder(1)
			dbGotop()
			dbSeek(xFilial("SH6")+nOP)
			While !Eof() .And. SH6->H6_FILIAL + SH6->H6_OP == xFilial("SH6") + nOP
				If SH6->H6_FILIAL + SH6->H6_OP == xFilial("SH6") + nOP .And. SH6->H6_OPERAC + SH6->H6_SEQ = cOpeSaldo + cSeqSaldo
					If SH6->H6_QTDPROD > 0 .OR. SH6->H6_QTDPERD > 0
						lPerdPrd := IIF(lPerdInf,0,SH6->H6_QTDPERD)
						nSomaAponN += SH6->H6_QTDPROD + lPerdPrd - H6_QTMAIOR - H6_QTGANHO
					EndIf
				EndIf
				dbSkip()
			End
			RestArea(aAreaSH61)

			nProduz := SC2->C2_QUANT - nSomaAponN

			If nProduz < 0
				nProduz := 0
			EndIf

			nExcede    := nQuant - nProduz

			If nProduz <= 0
				nExcedeAtu := nQuant
			Else
				nExcedeAtu := nQuant - nProduz
			EndIf

			If nExcedeAtu <= 0
				lMaiorAuto := .F.
				//Possui quantidade a maior
				//Mas a quantidade a maior nЦo excede o saldo da OP
			EndIf
		Else
			lMaiorAuto := .F.
			//Possui quantidade a maior
			//Mas a quantidade a maior nЦo excede o saldo da OP
		EndIf
	EndIF
Return

/*/{Protheus.doc} formatHora
Formata o horario de centesimal (numИrico) para hora (caracter HH:MM)
@type Static Function
@author Marcelo Neumann
@since 11/12/2023
@version P12
@param nHora, Caracter, Hora em formato centesimal
@return Caracter, Hora no formato HH:MM
/*/
Static Function formatHora(nHora)

Return PadL(cValToChar(Int(nHora)), 2, "0") + ":" + PadL(cValToChar((nHora - Int(nHora))*60), 2, "0")

/*/{Protheus.doc} A680NumLot
ForГa o campo H6_NUMLOTE ao preenchimento automАtico do sub-lote, mesmo que o usuАrio digite o sub-lote no campo.
Campo H6_NUMLOTE - X3_VALID
@type Function
@author FАbio Boarini
@since 05/02/2025
@version P12
@return lRet
/*/
Function A680NumLot()
	Local lLotUni := SuperGetMV('MV_LOTEUNI', .F., .T.)
	Local lRet    := .T.
	Local cVar    := CriaVar("H6_NUMLOTE")

	If !lLotUni
		If Rastro(M->H6_PRODUTO,"L")
			If !Empty(M->H6_NUMLOTE)
				M->H6_NUMLOTE := cVar
			Endif
		Endif
	EndIf

Return lRet

/*/{Protheus.doc} verBlqRec
Valida se tem recurso, centro de custo e ferramenta vazios, assim validando se hА algum bloqueio no recurso.
@type Static Function
@author Breno Ferreira
@since 01/04/2025
@version P12
@param 01 cRecurso, Character, Recurso do apontamento a ser validado.
@param 02 dDtIniTela, Date, Data Inicial(em tela) do apontamento a ser validado.
@param 03 dDtFimTela, Date, Data Final(em tela) do apontamento a ser validado.
@param 04 cHrIniTela , Character, Hora Inicial do apontamento a ser validado.
@param 05 cHrFimTela , Character, Hora Final do apontamento a ser validado.
@param 06 cCCusto, Character, Centro de Custo do recurso para ser validado.
@return lValid, Logical, Retorna .T. caso o recurso nЦo tenha nenhum bloqueio, se retornar .F. hА algum bloqueio no recurso.
/*/
Static Function verBlqRec(cRecurso, dDtIniTela, dDtFimTela, cHrIniTela, cHrFimTela, cCCusto)
	Local cAlias  := ""
	Local cQuery  := ""
	Local lValid  := .T.
	Local nParam  := SuperGetMv("MV_BLQREC", .F., 0)
	Local oRecur  := Nil

	cQuery := selectSH9(.F.)
	cQuery += " AND SH9.H9_RECURSO = ? "
	cQuery += " AND SH9.D_E_L_E_T_ = ' ' "

	oRecur := FwExecStatement():New(cQuery)

	oRecur:SetString(1, xFilial("SH9"))
	oRecur:SetDate(2, dDtIniTela)
	oRecur:SetDate(3, dDtIniTela)
	oRecur:SetDate(4, dDtFimTela)
	oRecur:SetDate(5, dDtFimTela)
	oRecur:SetString(6, cRecurso)

	cAlias := oRecur:OpenAlias()

	While (cAlias)->(!Eof())

		_lVeHora := validaHora((cAlias)->H9_RECURSO, (cAlias)->H9_DTINI, (cAlias)->H9_DTFIM, cHrIniTela, cHrFimTela, dDtIniTela, dDtFimTela)

		(cAlias)->(DBSkip())
	EndDo

	If nParam == 1 .And. _lVeHora
		Help(Nil, Nil, STR0133, Nil, STR0135, 1, 0, NIL, NIL, NIL, NIL, NIL) //"Bloqueio de Recurso." e "Existe bloqueio de recurso para apontamento."
		lValid := .F.
	ElseIf nParam == 2 .And. _lVeHora
		If !MsgYesNo(STR0135, STR0134) //"Existe bloqueio de recurso para apontamento." e "Deseja Continuar?"
			lValid := .F.
		EndIf
	EndIf

	If lValid .And. !_lVeHora
		lValid := verCCusto(dDtIniTela, dDtFimTela, cCCusto, cHrIniTela, cHrFimTela, nParam)
		If lValid .And. !_lVeHora
			lValid := verGeral(dDtIniTela, dDtFimTela, cHrIniTela, cHrFimTela, nParam)
		EndIf
	EndIf

	(cAlias)->(DBCloseArea())

	oRecur:Destroy()
	FreeObj(oRecur)

Return lValid

/*/{Protheus.doc} verCCusto
Valida o centro de custo caso nЦo tenha recurso.
@type Static Function
@author Breno Ferreira
@since 03/04/2025
@version P12
@param 01 dDtIniTela, Date, Data Inicial(em tela) do apontamento a ser validado.
@param 02 dDtFimTela, Date, Data Final(em tela) do apontamento a ser validado.
@param 03 cCCusto, Character, Centro de Custo do recurso para ser validado.
@param 04 cHrIniTela, Character, Hora Inicial colocado em tela.
@param 05 cHrFimTela, Character, Hora Final colocado em tela.
@param 06 nParam, Numeric, Traz o parБmetro MV_BLQREC.
@return lCCusto, Logical, Retorna .T. caso o centro de custo nЦo tenha nenhum bloqueio, se retornar .F. hА algum bloqueio no centro de custo.
/*/
Static Function verCCusto(dDtIniTela, dDtFimTela, cCCusto, cHrIniTela, cHrFimTela, nParam)
	Local cAlias  := ""
	Local cQuery  := ""
	Local lCCusto := .T.
	Local oCCusto := Nil

	cQuery := selectSH9(.F.)
	cQuery += " AND SH9.H9_CCUSTO  = ? "
	cQuery += " AND SH9.D_E_L_E_T_ = ' ' "

	oCCusto := FwExecStatement():New(cQuery)

	oCCusto:SetString(1, xFilial("SH9"))
	oCCusto:SetDate(2, dDtIniTela)
	oCCusto:SetDate(3, dDtIniTela)
	oCCusto:SetDate(4, dDtFimTela)
	oCCusto:SetDate(5, dDtFimTela)
	oCCusto:SetString(6, cCCusto)

	cAlias := oCCusto:OpenAlias()

	While (cAlias)->(!Eof())

		_lVeHora := validaHora((cAlias)->H9_RECURSO, (cAlias)->H9_DTINI, (cAlias)->H9_DTFIM, cHrIniTela, cHrFimTela, dDtIniTela, dDtFimTela)

		(cAlias)->(DBSkip())
	EndDo

	If nParam == 1 .And. _lVeHora
		Help(Nil, Nil, STR0138, Nil, STR0136, 1, 0, NIL, NIL, NIL, NIL, NIL) //"Bloqueio de Centro de Custo." e "Existe bloqueio de centro de custo para apontamento."
		lCCusto := .F.
	ElseIf nParam == 2 .And. _lVeHora
		If !MsgYesNo(STR0136, STR0134) //"Existe bloqueio de centro de custo para apontamento." e "Deseja Continuar?"
			lCCusto := .F.
		EndIf
	EndIf

	(cAlias)->(DBCloseArea())

	oCCusto:Destroy()
	FreeObj(oCCusto)

Return lCCusto

/*/{Protheus.doc} verGeral
Valida a fАbrica toda para ser validada.
@type Static Function
@author Breno Ferreira
@since 03/04/2025
@version P12
@param 01 dDtIniTela, Date, Data Inicial(em tela) do apontamento a ser validado.
@param 02 dDtFimTela, Date, Data Final(em tela) do apontamento a ser validado.
@param 03 cHrIniTela, Character, Hora Inicial colocado em tela.
@param 04 cHrFimTela, Character, Hora Final colocado em tela.
@param 05 nParam, Numeric, Traz o parБmetro MV_BLQREC.
@return lVeGeral, Logical, Retorna .T. caso o nЦo tenha nenhum bloqueio em toda a frАbica, se retornar .F. hА algum bloqueio na fАbrica.
/*/
Static Function verGeral(dDtIniTela, dDtFimTela, cHrIniTela, cHrFimTela, nParam)
	Local cAlias    := ""
	Local cQuery    := ""
	Local lVeGeral  := .T.
	Local oVldGeral := Nil

	cQuery := selectSH9(.F.)
	cQuery += " AND (SH9.H9_RECURSO IS NULL OR SH9.H9_RECURSO = ' ') "
   	cQuery += " AND (SH9.H9_CCUSTO IS NULL OR SH9.H9_CCUSTO = ' ') "
	cQuery += " AND SH9.D_E_L_E_T_ = ' ' "

	oVldGeral := FwExecStatement():New(cQuery)

	oVldGeral:SetString(1, xFilial("SH9"))
	oVldGeral:SetDate(2, dDtIniTela)
	oVldGeral:SetDate(3, dDtIniTela)
	oVldGeral:SetDate(4, dDtFimTela)
	oVldGeral:SetDate(5, dDtFimTela)

	cAlias := oVldGeral:OpenAlias()

	While (cAlias)->(!Eof())

		_lVeHora := validaHora((cAlias)->H9_RECURSO, (cAlias)->H9_DTINI, (cAlias)->H9_DTFIM, cHrIniTela, cHrFimTela, dDtIniTela, dDtFimTela)

		(cAlias)->(DBSkip())
	EndDo

	If nParam == 1 .And. _lVeHora
		Help(Nil, Nil, STR0139, Nil, STR0137, 1, 0, NIL, NIL, NIL, NIL, NIL) //"Bloqueio de FАbrica." e "Existe bloqueio da fАbrica para apontamento."
		lVeGeral := .F.
	ElseIf nParam == 2 .And. _lVeHora
		If !MsgYesNo(STR0137, STR0134) //"Existe bloqueio da fАbrica para apontamento." e "Deseja Continuar?"
			lVeGeral := .F.
		EndIf
	EndIf

	(cAlias)->(DBCloseArea())

	oVldGeral:Destroy()
	FreeObj(oVldGeral)

Return lVeGeral

/*/{Protheus.doc} validaHora
Valida os registros pela hora do apontamento.
@type Static Function
@author Breno Ferreira
@since 03/04/2025
@version P12
@param 01 cRecurso, Character, Recurso do apontamento a ser validado.
@param 02 cDtIniQry, Character, Data Inicial da query.
@param 03 cDtFimQry, Character, Data Final da query.
@param 04 cHrIni, Character, Hora Inicial do apontamneto a ser validado.
@param 05 cHrIni, Character, Hora Final do apontamneto a ser validado.
@param 06 dDtIniTela, Date, Data Inicial colocada em tela.
@param 07 dDtFimTela, Date, Data Final colocada em tela.
@return lValidHr, Logical, Retorna .T. caso tenha bloqueio, se retornar .F. caso nЦo haja bloqueio.
/*/
Static Function validaHora(cRecurso, cDtIniQry, cDtFimQry, cHrIni, cHrFim, dDtIniTela, dDtFimTela)
	Local cAlias   := ""
	Local cQuery   := ""
	Local lValidHr := .F.
	Local oHora    := Nil

	cQuery := selectSH9(.T.)
	cQuery += " AND SH9.H9_RECURSO = ? "
	cQuery += " AND SH9.H9_DTINI   = ? "
	cQuery += " AND SH9.H9_DTFIM   = ? "
	cQuery += " AND SH9.D_E_L_E_T_ = ' ' "

	oHora := FwExecStatement():New(cQuery)

	oHora:SetString(1, xFilial("SH9"))
	oHora:SetString(2, cHrIni)
	oHora:SetString(3, cHrIni)
	oHora:SetString(4, cHrFim)
	oHora:SetString(5, cHrFim)
	oHora:SetDate(6, dDtIniTela)
	oHora:SetDate(7, dDtFimTela)
	oHora:SetString(8, cHrIni)
	oHora:SetString(9, cHrFim)
	oHora:SetDate(10, dDtIniTela)
	oHora:SetDate(11, dDtFimTela)
	oHora:SetString(12, cHrIni)
	oHora:SetDate(13, dDtIniTela)
	oHora:SetDate(14, dDtFimTela)
	oHora:SetString(15, cHrFim)
	oHora:SetString(16, cRecurso)
	oHora:SetString(17, cDtIniQry)
	oHora:SetString(18, cDtFimQry)

	cAlias := oHora:OpenAlias()

	If (cAlias)->(!Eof())
		lValidHr := .T.
	EndIf

	(cAlias)->(DBCloseArea())

	oHora:Destroy()
	FreeObj(oHora)

Return lValidHr

/*/{Protheus.doc} selectSH9
Select das querys utilizadas para validar os bloqueios
@type Static Function
@author Breno Ferreira
@since 03/04/2025
@version P12
@param 01 lVeHora, Logical, Se for .T. estarА utilizando para filtrar pelas horas, se for .F. estarА utilizando para filtrar pelas datas.
@return cQuery, Character, Retorna a query do select.
/*/
Static Function selectSH9(lVeHora)
	Local cQuery := ""

	cQuery := " SELECT * "
	cQuery +=   " FROM " + RetSqlName("SH9") + " SH9 "
	cQuery +=  " WHERE SH9.H9_FILIAL = ? "
	cQuery +=    " AND SH9.H9_TIPO = 'B' "
	If lVeHora
		cQuery += " AND ((SH9.H9_HRINI <= ? AND SH9.H9_HRFIM >= ?) "
		cQuery +=  " OR  (SH9.H9_HRINI <= ? AND SH9.H9_HRFIM >= ?) "
		cQuery +=  " OR  ( ? = ? AND SH9.H9_HRINI >= ? AND SH9.H9_HRFIM <= ?) "
		cQuery +=  " OR  (? <> ? AND SH9.H9_HRINI >= ? AND SH9.H9_HRFIM <= '24:00' ) "
        cQuery +=  " OR  (? <> ? AND SH9.H9_HRINI >= '00:00' AND SH9.H9_HRFIM <= ? )) "
	Else
		cQuery += " AND ((SH9.H9_DTINI <= ? AND SH9.H9_DTFIM >= ?) "
		cQuery +=  " OR  (SH9.H9_DTINI <= ? AND SH9.H9_DTFIM >= ?)) "
	EndIf

Return cQuery

/*
эээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээээ
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠зддддддддддбдддддддддддбдддддддбддддддддддддддддддддддбддддддбдддддддддд©╠╠
╠╠ЁFun┤┘o    ЁA680BloqPROЁ Autor ЁEder Oliveira         Ё Data Ё 02/03/25 Ё╠╠
╠╠цддддддддддедддддддддддадддддддаддддддддддддддддддддддаддддддадддддддддд╢╠╠
╠╠ЁDescri┤┘o Ё Verifica se os produtos empenhados para producao estao     Ё╠╠
╠╠Ё			 Ё bloqueados para uso B1_MSBLQL == 1						  Ё╠╠
╠╠цддддддддддедддддддддддддддддддддддддддддддддддддддддддддддддддддддддддд╢╠╠
╠╠Ё Uso      Ё MATA680        	                                          Ё╠╠
╠╠юддддддддддадддддддддддддддддддддддддддддддддддддддддддддддддддддддддддды╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
ъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъъ
*/
Static Function A680BloqPR0(cOP)
	Local aAreaAnt  := GetArea()
	Local cAliasTmp := GetNextAlias()
	Local cQuery    := ''
	Local lRet      := .F.

	Default cOp		:= ''

	If !Empty( cOP )

		cQuery := " SELECT SB1.B1_COD " +;
					"FROM " + RetSqlName("SD4") + " SD4 " +;
					"	JOIN " + RetSqlName("SB1") + " SB1 " +;
					"	 ON SB1.B1_FILIAL = '" + xFilial("SB1") + "'" +;
					"	AND SB1.B1_COD = SD4.D4_COD " +;
					"	AND substring(SB1.B1_COD,1,3) <> 'MOD' " +;
					"	AND SB1.B1_CCCUSTO = '' " +;
					"WHERE SD4.D4_FILIAL  = '" + xFilial('SD4') + "'" +;
					"  AND SD4.D4_OP      = '" + cOp + "' " +;
					"  AND SD4.D4_QUANT   > 0 " +;
					"  AND SB1.B1_MSBLQL  = '1' " +;
					"  AND SB1.D_E_L_E_T_ = ' ' " +;
					"  AND SD4.D_E_L_E_T_ = ' ' "

		cQuery := ChangeQuery(cQuery)
		dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasTmp,.T.,.T.)

		While !(cAliasTmp)->(Eof())
			Help(Nil, Nil, 'A680BLOQ', Nil, I18n(STR0140, {AllTrim((cAliasTmp)->B1_COD)}), 1, 0 ) //"O Produto #1[produto]# foi empenhado para esta Ordem de ProduГЦo, porИm o mesmo se encontra bloqueado no cadastro de produtos. Favor verificar situaГЦo do Produto."
			lRet := .T.
			Return lRet
		EndDo
		(cAliasTmp)->(dbCloseArea())

	EndIf

	RestArea(aAreaAnt)
Return lRet

/*/{Protheus.doc} A681SgQtd
Faz a sugestЦo automАtica da quantidade total da operaГЦo
@type Function
@author breno.ferreira
@since 12/06/2025
@version P12
@return
/*/
Function A681SgQtd()
	Local aAreaSH6   := {}
	Local cOp        := ""
	Local cOpeSaldo  := ""
	Local cSeqSaldo  := ""
	Local l681       := IsInCallStack("MATA681")
	Local lSugestQtd := SuperGetMV("MV_SUGEQTD",.F.,"N") == "S"
	Local nPerdPrd   := 0
	Local nProduz    := 0
	Local nSomaAponN := 0

	cOp       := M->H6_OP
	cOpeSaldo := M->H6_OPERAC
	cSeqSaldo := M->H6_SEQ

	If !Empty(cOp) .And. !Empty(cOpeSaldo)
		If l681 .And. lSugestQtd
			DbSelectArea("SC2")
			SC2->(dbSetOrder(1))
			If SC2->(dbSeek(xFilial("SC2") + cOp))
				If mv_par07 == 1 	//Verif. Sld. Oper. Anterior ?
					nProduz := A680SldOper(.F.,.T.,.T.)[1] //Producao+perda
				ElseIf mv_par07 == 2
					nProduz := A680SldOper(.F.,.F.,.T.)[1] //Producao-perda
				Else
					nProduz := A680SldOper(.F.,.F.,.F.)[1] //Nao verifica
				EndIf
			EndIf

			If A680OperAnt()[1] <> Nil .And. nProduz > 0
				aAreaSH6  := SH6->(GetArea())
				dbSelectArea("SH6")
				dbSetOrder(1)
				dbGotop()
				dbSeek(xFilial("SH6")+cOp)
				While !Eof() .And. SH6->H6_FILIAL + SH6->H6_OP == xFilial("SH6") + cOp
					If SH6->H6_OPERAC + SH6->H6_SEQ = cOpeSaldo + cSeqSaldo
						If SH6->H6_QTDPROD > 0 .OR. SH6->H6_QTDPERD > 0
							nPerdPrd := IIF(lPerdInf,0,SH6->H6_QTDPERD)
							nSomaAponN += SH6->H6_QTDPROD + nPerdPrd - H6_QTMAIOR - H6_QTGANHO
						EndIf
					EndIf
					dbSkip()
				End
				RestArea(aAreaSH6)

				nProduz := nProduz - nSomaAponN
			EndIf

			M->H6_QTDPROD := nProduz
			M->H6_PT      := "T"
		EndIf
	EndIf
Return
