#INCLUDE "FWLIBVERSION.CH"
#include "totvs.ch"
#include "msobject.ch"
#include "totvs.framework.treports.integratedprovider.th"
#include "tlpp-core.th"
#include "tlpp-rest.th"
#include "pcp.treports.ordens.ch"

namespace totvs.protheus.sigapcp.treportsintegratedprovider

@totvsFrameworkTReportsIntegratedProvider(active=.T., team="SIGAPCP", tables="SC2,SB1", name="Lista das Ordens de Produção", country="ALL", initialRelease="12.1.2210", customTables="SC2,SB1")

/*/{Protheus.doc} OrdensTReportsBusinessObject
Classe para criação do Objeto de Negócio para listagem da Relação das Ordens de Produção

@author breno.ferreira
@since 06/06/2023
@version 1.0
/*/
class OrdensTReportsBusinessObject from totvs.framework.treports.integratedprovider.IntegratedProvider
    public method new() as object
    public method getData() as object
    public method getSchema() as object

    protected data aFields as array
    protected data aStruct as array
endclass

/*/{Protheus.doc} new
Método de instância da classe
 
@return object: self

@author breno.ferreira
@since 06/06/2023
@version 1.0
/*/ 
method new() as object class OrdensTReportsBusinessObject
    _Super:new()
    //Define a Área
    self:appendArea(STR0001)//STR0001 = "PCP"   
 
    //Define o nome do Objeto de Negócio
    self:setDisplayName(STR0002)//STR0002 - "Ordens"
    
    //Define a descrição do Objeto de Negócio
    self:setDescription(STR0003)//STR0003 - "Relação das Ordens de Produção"

    self:setPergunte("MTR850") //Indica o pergunte que será utilizado no relatário
return self

/*/{Protheus.doc} getData
Retorna os dados do objeto de negócio
 
@param nPage, numérico, indica a página atual do relatário
@param oFilter, objeto, contêm o filtro do TReports
 
@return object: self:oData

@author breno.ferreira
@since 06/06/2023
@version 1.0
/*/
Method getData(nPage as numeric, oFilter as object) as object class OrdensTReportsBusinessObject
    Local aParam      := Array(11)                                    as array
    Local aTables     := {}                                           as Array
    Local cAlias      := ""                                           as character
    Local cBanco      := TCGetDB()                                    as character
    Local cDescEmp    := ""                                           as character
    Local cDescFil    := ""                                           as character
    Local cDescStatus := ""                                           as character
    Local cDescTpop   := ""                                           as character
    Local cFields     := ""                                           as character
    Local cQuery      := ""                                           as character
    Local cSpace      := Space(GetSx3Cache("C2_DATRF", "X3_TAMANHO")) as character
    Local jParams     := Nil                                          as json
    Local lPerdInf    := SuperGetMV("MV_PERDINF",.F.,.F.)             as logical
    Local nDecs       := GetSx3Cache("C2_QUANT", "X3_TAMANHO")        as numeric
    Local nPosParam   := 0                                            as numeric
    Local nSaldo      := 0                                            as numeric
    Local nX          := 0                                            as numeric
    Local oExec       := Nil                                          as object
    Local ojItems     := Nil                                          as json

    jParams := oFilter:getParameters() //metodo para retorno do json dos parâmetros

    aParam[1]  := pcpValidParam(jParams["MV_PAR01"][1]) //De OP ?
    aParam[2]  := pcpValidParam(jParams["MV_PAR02"][1]) //Ate a OP ?
    aParam[3]  := pcpValidParam(jParams["MV_PAR03"][1]) //Do Produto ?
    aParam[4]  := pcpValidParam(jParams["MV_PAR04"][1]) //Ate o Produto ?
    aParam[5]  := pcpValidParam(jParams["MV_PAR05"][1]) //Do Centro de Custo ?
    aParam[6]  := pcpValidParam(jParams["MV_PAR06"][1]) //Ate o Centro de Custo ?
    aParam[7]  := pcpconvdat(jParams["MV_PAR07"][1],1) //Da Data ?
    aParam[8]  := pcpconvdat(jParams["MV_PAR08"][1],1) //Ate a Data ?
    aParam[9]  := jParams["MV_PAR09"][1] //1-Em Aberto 2-Encerradas 3-Todas
    aParam[10] := jParams["MV_PAR10"][1] //1-Sacramentadas 2-Suspensa 3-Todas
    aParam[11] := jParams["MV_PAR11"][1] //Impr. OP's Firmes, Previstas ou Ambas

    cFields := ArrTokStr(self:aFields,",")
    
    cQuery := "SELECT ? "

    aadd(aTables,{'B1_','SB1.'})
    PcpInCposPerson(@self:aStruct, @cQuery, self:getCustomFields(),.T.,.T.,,aTables)
    aTables := {} 

	cQuery +=    " FROM " + RetSqlName("SC2") + " SC2 "
    cQuery +=   " INNER JOIN " + RetSqlName("SB1") + " SB1 "
    cQuery +=      " ON SB1.B1_FILIAL = ? "
    cQuery +=     " AND SB1.B1_COD = SC2.C2_PRODUTO "
    cQuery +=     " AND SB1.D_E_L_E_T_ = ' ' "
    cQuery +=   " WHERE SC2.C2_FILIAL = ? "
    cQuery +=     " AND SC2.C2_NUM || SC2.C2_ITEM || SC2.C2_SEQUEN || SC2.C2_ITEMGRD >= ? "
    cQuery +=     " AND SC2.C2_NUM || SC2.C2_ITEM || SC2.C2_SEQUEN || SC2.C2_ITEMGRD <= ? "
    cQuery +=     " AND SC2.C2_PRODUTO >= ? "
    cQuery +=     " AND SC2.C2_PRODUTO <= ? "
    cQuery +=     " AND SC2.C2_CC >= ? "
    cQuery +=     " AND SC2.C2_CC <= ? "
    cQuery +=     " AND SC2.C2_EMISSAO >= ? "
    cQuery +=     " AND SC2.C2_EMISSAO <= ? "
    If aParam[10] == 1 .Or. aParam[10] == 2
        cQuery += " AND SC2.C2_STATUS IN "
        If aParam[10] == 1
	        cQuery += "('S')"
        ElseIf aParam[10] == 2
	        cQuery += "('U')"
        EndIf
    EndIf
    If aParam[11] == 1 .Or. aParam[11] == 2
        cQuery += " AND SC2.C2_TPOP IN "
        If aParam[11] == 1
	        cQuery += "('F')"
        ElseIf aParam[11] == 2
	        cQuery += "('P')"
        EndIf
    EndIf
    If aParam[9] == 1
	    cQuery += " AND SC2.C2_DATRF =  ? "
    ElseIf aParam[9] == 2
	    cQuery += " AND SC2.C2_DATRF <> ? "
    EndIf
    cQuery +=     " AND SC2.D_E_L_E_T_ = ' ' "
    cQuery +=   " ORDER BY SC2.C2_FILIAL, SC2.C2_NUM, SC2.C2_ITEM, SC2.C2_SEQUEN, SC2.C2_ITEMGRD, SC2.C2_PRODUTO "

    If "MSSQL" $ cBanco
		//Substitui concatenação || por +
		cQuery := StrTran(cQuery, '||', '+')
	EndIf

    nPosParam := 1

    //Montagem da query para execução
    oExec := FwExecStatement():New(cQuery)

    oExec:SetUnSafe(nPosParam++, cFields)
    oExec:SetString(nPosParam++, xFilial("SB1"))
    oExec:SetString(nPosParam++, xFilial("SC2"))
    oExec:SetString(nPosParam++, aParam[1])
    oExec:SetString(nPosParam++, aParam[2])
    oExec:SetString(nPosParam++, aParam[3])
    oExec:SetString(nPosParam++, aParam[4])
    oExec:SetString(nPosParam++, aParam[5])
    oExec:SetString(nPosParam++, aParam[6])
    oExec:SetDate(nPosParam++, aParam[7])
    oExec:SetDate(nPosParam++, aParam[8])
    If aParam[9] == 1 .Or. aParam[9] == 2
        oExec:SetString(nPosParam++, cSpace)
    EndIf

    cAlias := oExec:OpenAlias()

    If (cAlias)->(!Eof())
        cDescEmp := FWGrpName()
        cDescFil := FWFilialName(, (cAlias)->C2_FILIAL, 1)
    EndIf

    While (cAlias)->(!Eof())

        If Empty((cAlias)->C2_DATRF)
            nSaldo := Max(0,NoRound((cAlias)->C2_QUANT - (cAlias)->C2_QUJE - If(lPerdInf,0,(cAlias)->C2_PERDA), nDecs))
        Else
            nSaldo := 0
        EndIf    

        If (cAlias)->C2_STATUS $ 'N'
            cDescStatus := STR0004 //STR0004 - 'Normal'
        ElseIf (cAlias)->C2_STATUS $ 'S' 
            cDescStatus := STR0005 //STR0005 - 'Sacramentada'
        ElseIf (cAlias)-> C2_STATUS $ 'U'
            cDescStatus := STR0006 //STR0006 - 'Suspensa'
        Else
            cDescStatus := ' '      
        EndIf 

        If (cAlias)->C2_TPOP $ 'F'
            cDescTpop := STR0007 //STR0007 - 'Firme'
        ElseIf (cAlias)->C2_TPOP $ 'P'
            cDescTpop := STR0008  //STR0008 - 'Prevista'
        EndIf

        ojItems := JsonObject():new()

        For nX := 1 To Len(self:aStruct)
            //Campos auxiliares
            If self:aStruct[nX][1] $ 'DESCEMP'
                ojItems[self:aStruct[nX][1]] := cDescEmp
            ElseIf self:aStruct[nX][1] $ 'DESCFIL'
                ojItems[self:aStruct[nX][1]] := cDescFil  
            ElseIf self:aStruct[nX][1] == "C2STATUS" //Tratamento para imprimir o STR do campo C2_STATUS
                    ojItems[self:aStruct[nX][1]] := cDescStatus
            ElseIf self:aStruct[nX][1] == "C2TPOP" //Tratamento para imprimir o STR do campo C2_TPOP
                    ojItems[self:aStruct[nX][1]] := cDescTpop
            ElseIf self:aStruct[nX][1] == "SALDO"
                    ojItems[self:aStruct[nX][1]] := nSaldo
            ElseIf self:aStruct[nX][1] $ 'NUMOP'
                ojItems[self:aStruct[nX][1]] := (cAlias)->C2_NUM + (cAlias)->C2_ITEM + (cAlias)->C2_SEQUEN + (cAlias)->C2_ITEMGRD        
            Else 
                //Campos do select principal
                If self:aStruct[nX][3] $ "date" //Converter data para o formato padrão - 2023-01-27T15:31:43Z
                    ojItems[self:aStruct[nX][1]] := totvs.framework.treports.date.stringToTimeStamp((cAlias)->&(self:aStruct[nX][5]))
                Else    
                    ojItems[self:aStruct[nX][1]] := (cAlias)->&(self:aStruct[nX][5]) 
                EndIf 
            EndIf
        Next nX
    
        self:ProcessData()
        self:oData:appendData(ojItems)

        (cAlias)->(DBSkip())

    EndDo 

    (cAlias)->(DBCloseArea())
    oExec:Destroy()
    FreeObj(oExec)
    
Return self:oData

/*/{Protheus.doc} getSchema
Retorna a estrutura dos campos
 
@return object: self:oSchema

@author breno.ferreira
@since 06/06/2023
@version 1.0
/*/
Method getSchema() as object class OrdensTReportsBusinessObject
    Local nX        := 0 as numeric

    self:aFields := {"C2_FILIAL","C2_NUM","C2_ITEM","C2_SEQUEN","C2_ITEMGRD","C2_PRODUTO","C2_CC","C2_EMISSAO","C2_DATPRF","C2_DATRF",;
                     "C2_QUANT","C2_STATUS","C2_TPOP","C2_QUJE","C2_PERDA","B1_DESC"}
                     
    self:aStruct := PcpTrGetStruct(self:aFields)

    //Campos Auxiliares
    AAdd(self:aStruct , {"DESCEMP", "DESC_EMP", "string", "DESC_EMP", "DESC_EMP"})
    AAdd(self:aStruct , {"DESCFIL", "DESC_FIL", "string", "DESC_FIL", "DESC_FIL"})
    AAdd(self:aStruct , {"SALDO"  , "SALDO"   , "number", "SALDO"   , "SALDO"   })
    AAdd(self:aStruct , {"NUMOP"  , "NUMOP"   , "string", "NUMOP"   , "NUMOP"   })

    For nX := 1 To Len(self:aStruct)
        self:addProperty(self:aStruct[nX][1], self:aStruct[nX][2], self:aStruct[nX][3], self:aStruct[nX][4], self:aStruct[nX][5])
    Next nX

Return self:oSchema
