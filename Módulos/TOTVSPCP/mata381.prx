#INCLUDE "TOTVS.CH"
#INCLUDE "MATA381.CH"
#INCLUDE "PROTHEUS.CH"
#DEFINE LINHAS 2500
#DEFINE USADO CHR(0)+CHR(0)+CHR(1)

Static lWmsNew := SuperGetMV("MV_WMSNEW",.F.,.F.)
/* 
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ Mata381  ³ Autor ³ Andre Anjos			³ Data ³ 16/04/08 ³±±             
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Programa de Ajuste de Empenhos Modelo II					  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ Void MATA381(xAutoCab,xAutoItens,nOpc)                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ xAutoCab := array com os campos a serem considerados pela  ³±±
±±³		 	 ³				rotina automatica                             ³±±
±±³			 ³ xAutoItens := array com os itens a serem utilizados pela   ³±±
±±³			 ³				rotina automatica							  ³±±
±±³			 ³ nOpc := opcao de execucao sendo:							  ³±±
±±³			 ³	3 - Inclusao											  ³±±
±±³			 ³	4 - Alterar												  ³±±
±±³			 ³	5 - Excluir												  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß

*/
Function MATA381(xAutoCab,xAutoItens,nOpcAuto,lA381Manut)
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Define Variaveis para filtrar browse                         ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Local aCores 	  := A381aCores()  
Local bBlock      := Nil
Local cFiltraSD4  := ""     
Local cRet        := ""
Local nPosOpc     := 0
Local lMT381Fil   := Existblock("MT381FIL")

Private lPyme     := Iif(Type("__lPyme") <> "U",__lPyme,.F.)
Private aRotina   := MenuDef()
Private cCadastro := OemToAnsi(STR0010)
Private l381      := .T., l380 := .F.
Private aSDC      := {}

Private l381Auto   := .F.
Private lMT381SE   := .T.
Default lA381Manut := .F.

If  ( xAutoCab <> Nil )
                             
	PRIVATE aAutoCab   := aClone(xAutoCab)
	PRIVATE aAutoItens := aClone(xAutoItens)

	DEFAULT nOpcAuto   := 3

	l381Auto := .T.

EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Deixa o SD4 em ordem de OP p/mBrowse                         ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
dbSelectArea("SD4")
dbSetOrder(2)

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Ponto de Entrada para efetuar filtros antes do MBROWSE       ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lMT381Fil
	cRet := AllTrim(ExecBlock ("MT381FIl",.F.,.F.))
	If Valtype(cRet) == "C"
		cFiltraSD4 := cRet
	EndIf
EndIf  

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Monta MBROWSE padrao                                                   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If l381Auto
	MBrowseAuto(nOpcAuto,aAutoCab,"SD4")
Else
	If nOpcAuto != Nil .And. !lA381Manut
		nPosOpc := Ascan(aRotina, {|x| x[4] == nOpcAuto})

		If (nPosOpc != 0)
			bBlock := &("{ |x, y, z, k| " + aRotina[nPosOpc][2] + "(x, y, z, k) }")

			Eval(bBlock, Alias(), SD4->(Recno()), nPosOpc)
		EndIf
	Else
		If lA381Manut
			A381Manut("SD4",SD4->(Recno()),4)
		Else
			mBrowse( 6, 1,22,75,"SD4",,,,,,aCores,,,,,,,,,,,,cFiltraSD4)
		EndIf
	EndIf
EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Restaura a condicao de Entrada                                          ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
dbSelectArea("SD4")
dbSetOrder(1)
	
Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³A381Manu  ³ Autor ³ Andre Anjos     		³ Data ³ 16/04/08 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Programa de manutencao modelo 2 de Empenhos			  	  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ Void A381Visual(ExpC1,ExpN1,ExpN2)                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Alias do arquivo                                   ³±±
±±³          ³ ExpN1 = Numero do registro                                 ³±±
±±³          ³ ExpN2 = Numero da opcao selecionada                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function A381Manut(cAlias,nReg,nOpc)
Local aArea	   := GetArea()
Local aPosObj  := {}
Local aObjects := {}
Local aSize    := MsAdvSize(.F.)
Local aInfo    := {aSize[1],aSize[2],aSize[3],aSize[4],3,3}
Local aButtons := {}
Local aBtnBack := {}
Local nX       := 0
Local nLenHdr  := 0
Local nLenCols := 0

Local cSeek 	 := ""
Local bSeekWhile := {|| D4_FILIAL+D4_OP }
Local bSeekFor	 := {|| .T.}
Local aNoFields	 := {"D4_OP","D4_STATUS","D4_QSUSP","D4_SITUACA","D4_ORDEM"}
Local lContinua	 := .T.
Local lOK		 := .F.
Local lRetPE	 := .T.
Local lAutZera   := .F.
Local lIntMNT    := SuperGetMV( 'MV_NGMNTCM', .F., '' ) == 'S'
Local nPos       := 0
Local oSize

Private l381Vis := If(nOpc==2,.T.,.F.)
Private l381Inc := If(nOpc==3,.T.,.F.)
Private l381Alt := If(nOpc==4,.T.,.F.)
Private l381Exc := If(nOpc==5,.T.,.F.)

Private cOP 	   := CriaVar("D4_OP")
Private cRotSC2  := CriaVar("C2_ROTEIRO")
Private lZeraEmp   := .F.
Private lZeraEmp2  := .F.
Private nPosCod	   := 0
Private nPosPrdOri := 0
Private nPosTRT	   := 0
Private nPosLocal  := 0
Private nPosQuant  := 0
Private nPosQtdOri := 0
Private nPosSegUM  := 0
Private nPosLotCtl := 0
Private nPosLote   := 0
Private nPosDValid := 0
Private nPosPotenc := 0
Private nPosData   := 0
Private nPosOporig := 0
Private nPosOperac := 0
Private nPosRoteiro:= 0
Private nPosRecno  := 0

Private aHeader := {}
Private aCols	:= {}
Private aColsOri	:= {}

Private aEnderecos := {}
Private aAltQtd    := {}
//Variável usada no mata380.prx ao ser chamado pelo mata381
Private aInfLt     := {}

IF SD4->(FieldPos('D4_ROTEIRO')) > 0
	aadd(aNoFields,'D4_ROTEIRO') //D4_ROTEIRO deve ser apresentado no grid para resgatar valor de nPosRoteiro
Endif

If !l381Auto
	Set Key VK_F4 To ShowF4()
	If l381Inc .Or. l381Alt
		Set Key VK_F5 To ShowF5()
	EndIf

	If l381alt
		Set Key VK_F7 To ShowF7()
	EndIf

	Set Key VK_F6 To ShowF6()
EndIf

//preparacao de componentes da tela
AAdd( aObjects, { 100, 05, .T., .T. } ) // Dados da Enchoice 
AAdd( aObjects, { 100, 95, .T., .T. } ) // Getdados 
aPosObj:= MsObjSize( aInfo, aObjects, .T. ,.F.)

dbSelectArea(cAlias)
dbSetOrder(2)

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//|Para visualizacao, alteracao e exclusao inicializa	| 
//|variaveis do cabecalho e preenche aHeader e aCols	|
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If !l381Inc
	dbGoTo(nReg)
	cOP   := (cAlias)->D4_OP
	
	if SD4->(FieldPos('D4_ROTEIRO')) > 0
		cRotSC2 := (cAlias)->D4_ROTEIRO 
	Endif
	
	cSeek := xFilial(cAlias)+cOP
EndIf

aSDC := {}

If FindFunction("a380GraSdc")
	dbSelectArea("SD4")
	dbSetOrder(2) 
	dbGoTop()
	dbSeek(xFilial("SD4")+cOP)
	While !EOF() .And. SD4->(D4_FILIAL+D4_OP) == xFilial("SD4")+cOP
		a380GraSdc(SD4->D4_FILIAL,SD4->D4_OP,SD4->D4_COD,SD4->D4_LOCAL)	
		SD4->(dbSkip())
	End
EndIf

If l381Alt
	dbSelectArea("SC2")
	dbSetOrder(1)
	If dbSeek(xFilial("SC2")+cOP)
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Verifica se a OP ja' foi encerrada ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If !Empty(C2_DATRF)
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Permite inclusao somente de qtd zero|
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	       dbSelectArea("SD4")
	       dbSetOrder(2) 
	       dbGoTop()
	       dbSeek(xFilial("SD4")+cOP)
			While !EOF() .And. SD4->(D4_FILIAL+D4_OP) == xFilial("SD4")+cOP
				If QtdComp(SD4->D4_QUANT) # QtdComp(0)
					If l381Auto
						nPos := aScan(aAutoCab,{|x| x[1]=="AUTZERAEMP"})
						If nPos > 0
							lAutZera := aAutoCab[nPos,2]
						EndIf
						If lAutZera
							nOpc := 2 //para o usuario nao editar nada
							lZeraEmp   := .T.
							lZeraEmp2  := .T.
							Exit
						Else
							Exit
						EndIf
					EndIf
					If Aviso(STR0021,STR0023,{STR0024,STR0025})== 1	// "Atencao" ### "A Op ja esta encerrada, mas existe empenhos pendentes. Deseja zerar empenhos?" ###"Sim" ### "Nao"
					   Help( ,, 'Help',,STR0026+STR0027, 1, 0 ) //'Independente de existir valor maior que zero no campo de saldo empenhado ("Sal.Empenho"), ''o conteudo a ser gravado na confirmacao sera zero.'
						nOpc := 2 //para o usuario nao editar nada
						lZeraEmp   := .T.
						lZeraEmp2  := .T.
						Exit
					Else
						Exit
					EndIf
				EndIf
				SD4->(dbSkip())
			End
			If !lZeraEmp
				Help(" ",1,"A250ENCERR")
				Return
			EndIf
		EndIf
	EndIf
EndIf

//-- Valida empenhos baixados parcialmente
If l381Exc
	
	dbSelectArea("SD4")
	dbSeek(xFilial("SD4")+cOP)

	// Chama rotina para integracao com SIGAMNT - Manutenção de Ativos
	If lIntMNT .And. !MNTINTSASC( SD4->D4_OP, 'MATA381', nOpc, , , SD4->( RecNo() ) )
		Return	
	EndIf

	While !EOF() .And. SD4->(D4_FILIAL+D4_OP) == xFilial("SD4")+cOP
		IF (SD4->D4_QUANT < SD4->D4_QTDEORI)
			Help(" ",1,"MA381EMPBX")
			Return
		EndIf
		
		//-- Valida integração com WMS - Ordem de Serviço de Separação
		If IntWms(SD4->D4_COD) .And. !WmsAvalSD4("1",SD4->(Recno()))
			Return
		EndIf
		SD4->(dbSkip())
	End
EndIf

If (l381Alt.Or. l381Exc) .And. IsProdProt(SC2->C2_PRODUTO) .And. !IsInCallStack("DPRA340INT")
	Help( ,, 'Help',,STR0034, 1, 0 ) //-- Protótipos podem ser manipulados somente através do módulo Desenvolvedor de Produtos (DPR).
	Return
EndIf

//Verifica se deverá ser zerado os empenhos quando execução automática.
If l381Alt .And. l381Auto .And. !lZeraEmp
	nPos := aScan(aAutoCab,{|x| x[1]=="AUTZERAEMP"})
	If nPos > 0
		lAutZera := aAutoCab[nPos,2]
	EndIf
	If lAutZera
		nOpc := 2 //para o usuario nao editar nada
		lZeraEmp   := .T.
		lZeraEmp2  := .T.
	EndIf
EndIf

dbSelectArea("SD4")
//preenche aHeader e aCols
FillGetDados(nOpc,cAlias,2,cSeek,bSeekWhile,bSeekFor,aNoFields)

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Ponto de entrada para manipular / ordenar aCols  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If (ExistBlock("MA381COLS"))
	ExecBlock("MA381COLS",.F.,.F.,{nOpc})
Endif

If l381Auto
	//Se for execução automática, ajusta o aHeader e aCols para adicionar o array
	//de endereços no aCols.

	nLenHdr := Len(aHeader)
	aAdd(aHeader,aClone(aHeader[nLenHdr]))

	For nX := 1 To Len(aHeader[nLenHdr])
		aHeader[nLenHdr,nX] := aHeader[nLenHdr-1,nX]
	Next nX

	aHeader[nLenHdr-1,1]  := STR0014 //"Endereços"
	aHeader[nLenHdr-1,2]  := "AUT_D4_END"
	aHeader[nLenHdr-1,3]  := ""
	aHeader[nLenHdr-1,4]  := 10
	aHeader[nLenHdr-1,5]  := 0
	aHeader[nLenHdr-1,6]  := ""
	aHeader[nLenHdr-1,7]  := "€€€€€€€€€€€€€€€"
	aHeader[nLenHdr-1,8]  := "M"
	aHeader[nLenHdr-1,9]  := ""
	aHeader[nLenHdr-1,10] := "V"
	
	For nX := 1 To Len(aCols)
		nLenCols := Len(aCols[nX])
		aAdd(aCols[nX],aCols[nX,nLenCols]) //Adiciona a posição para identificar registro deletado
		aCols[nX,nLenCols]   := aCols[nX,nLenCols-1] //Move o RECNO uma posição para frente no array aCols
		aCols[nX,nLenCols-1] := aCols[nX,nLenCols-2] //Move o ALIAS uma posição para frente no array aCols
		aCols[nX,nLenCols-2] := Nil //Inicializa a posição que irá guardar o array de endereços para NIL.
	Next nX

	//Adiciona o array do AGR no aheader/acols
	nLenHdr := Len(aHeader)
	aAdd(aHeader,aClone(aHeader[nLenHdr]))

	For nX := 1 To Len(aHeader[nLenHdr])
		aHeader[nLenHdr,nX] := aHeader[nLenHdr-1,nX]
	Next nX

	aHeader[nLenHdr-1,1]  := "Agronegocio"
	aHeader[nLenHdr-1,2]  := "AUT_D4_AGR"
	aHeader[nLenHdr-1,3]  := ""
	aHeader[nLenHdr-1,4]  := 10
	aHeader[nLenHdr-1,5]  := 0
	aHeader[nLenHdr-1,6]  := ""
	aHeader[nLenHdr-1,7]  := "€€€€€€€€€€€€€€€"
	aHeader[nLenHdr-1,8]  := "M"
	aHeader[nLenHdr-1,9]  := ""
	aHeader[nLenHdr-1,10] := "V"
	
	For nX := 1 To Len(aCols)
		nLenCols := Len(aCols[nX])
		aAdd(aCols[nX],aCols[nX,nLenCols]) //Adiciona a posição para identificar registro deletado
		aCols[nX,nLenCols]   := aCols[nX,nLenCols-1] //Move o RECNO uma posição para frente no array aCols
		aCols[nX,nLenCols-1] := aCols[nX,nLenCols-2] //Move o ALIAS uma posição para frente no array aCols
		aCols[nX,nLenCols-2] := Nil //Inicializa a posição que irá guardar o array de agro para NIL.
	Next nX



EndIf

nPosCod    := aScan(aHeader,{|aX| AllTrim(aX[2]) == "D4_COD"})
nPosTRT    := aScan(aHeader,{|aX| AllTrim(aX[2]) == "D4_TRT"})
nPosLocal  := aScan(aHeader,{|aX| AllTrim(aX[2]) == "D4_LOCAL"})
nPosQuant  := aScan(aHeader,{|aX| AllTrim(aX[2]) == "D4_QUANT"})
nPosQtdOri := aScan(aHeader,{|aX| AllTrim(aX[2]) == "D4_QTDEORI"})
nPosSegUM  := aScan(aHeader,{|aX| AllTrim(aX[2]) == "D4_QTSEGUM"})
nPosLotCtl := aScan(aHeader,{|aX| AllTrim(aX[2]) == "D4_LOTECTL"})
nPosLote   := aScan(aHeader,{|aX| AllTrim(aX[2]) == "D4_NUMLOTE"})
nPosDValid := aScan(aHeader,{|aX| AllTrim(aX[2]) == "D4_DTVALID"})
nPosPotenc := aScan(aHeader,{|aX| AllTrim(aX[2]) == "D4_POTENCI"})
nPosData   := aScan(aHeader,{|aX| AllTrim(aX[2]) == "D4_DATA"})
nPosOPorig := aScan(aHeader,{|aX| AllTrim(aX[2]) == "D4_OPORIG"})
nPosRecno  := aScan(aHeader,{|aX| AllTrim(aX[2]) == "D4_REC_WT"})
nPosPrdOri := aScan(aHeader,{|aX| AllTrim(aX[2]) == "D4_PRDORG"})

IF SD4->(FieldPos('D4_ROTEIRO')) > 0
	nPosRoteiro:= aScan(aHeader,{|aX| AllTrim(aX[2]) == "D4_ROTEIRO"})
	nPosOperac := aScan(aHeader,{|aX| AllTrim(aX[2]) == "D4_OPERAC"})
Endif

If l381Alt //configura campos que podem ser alterados
	For nX := 1 To Len(aHeader)
		IF AllTrim(aHeader[nX][2]) $ "D4_COD*D4_LOCAL*D4_TRT*D4_LOTECTL*D4_NUMLOTE"
			If Empty(aHeader[nX][6])
				aHeader[nX][6] := "A381VerAlt()"
			Else
				aHeader[nX][6] += " .And. A381VerAlt()"
			EndIf
		EndIf
	Next nX
EndIf

aColsOri := aClone(aCols)

If !l381Auto
	If !lZeraEmp .And. (l381Inc .Or. l381Alt)
		Aadd(aButtons, {'PRODUTO',{||a381Estru()},OemToAnsi(STR0015),OemToAnsi(STR0013)}) //"1o Nivel"
	EndIf
	Aadd(aButtons, {'bmptable',{||a381Ender()},OemToAnsi(STR0016),OemToAnsi(STR0014),If((l381Inc.Or.l381Alt).And.;
								!(nOpc==2),4,nOpc)}) //"Enderecos"
	If RemoteType() == 1
		aAdd(aButtons,{PmsBExcel()[1],{|| DlgToExcel({{"CABECALHO",OemToAnsi(STR0011),{STR0011},{cOP}},{"GETDADOS",OemToAnsi(STR0012),aHeader,aCols}})},PmsBExcel()[2],PmsBExcel()[3]})//Excel
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Inclusao de botao que permite zerar empenhos  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	Aadd(aButtons,{ "ESTOMOVI" , { || A381ZEmp() }, STR0032 ,STR0033}) //"Zera Empenho Lote/Endereco"##"Zera Emp."

	If (nOpc == 4 .Or. nOpc == 2) .And. AliasInDic("NLI")
		NLI->(dbSetOrder(1))
		If NLI->(dbSeek(xFilial("NLI")+cOP))
			Aadd(aButtons,{ "LISTANLI" , { || A381VerNLI() }, OemToAnsi(STR0087) , OemToAnsi(STR0087)}) //"Compl. Agro"
		EndIf
	EndIf 

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Ponto de Entrada criado para configurar botoes da enchoicebar        ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If ExistBlock( "MA381BUT" )
		aBtnBack := aClone(aButtons)
		aButtons := ExecBlock( "MA381BUT", .F., .F., { nOpc, aButtons } )
		If ValType( aButtons ) # "A"
			aButtons := aClone(aBtnBack)
		EndIf
	EndIf

	oSize    := FwDefSize():New(.T.)
	oSize:AddObject("CABECALHO",100,5,.T.,.T.)
	oSize:AddObject("GETDADOS" ,100,95,.T.,.T.)

	oSize:lProp := .T. 

	oSize:aMargins := {3,3,3,3} // Espaco ao lado dos objetos 0, entre eles 3
	oSize:Process()                   // Dispara os calculos

	DEFINE MSDIALOG oDlg TITLE OemToAnsi(STR0010) FROM oSize:aWindSize[1],oSize:aWindSize[2] TO oSize:aWindSize[3],oSize:aWindSize[4] PIXEL//OF oMainWnd PIXEL

	oPanel1:= tPanel():New(oSize:GetDimension("CABECALHO","LININI"),oSize:GetDimension("CABECALHO","COLINI"),,oDlg,,,,,,oSize:GetDimension("CABECALHO","XSIZE"),oSize:GetDimension("CABECALHO","YSIZE"))
											
	@ 0.3,00.7 SAY OemToAnsi(STR0011) of oPanel1 //"Ordem de Producao"
	@ 0.2,07.0 MSGET cOP When l381Inc F3 "SC2" Valid NaoVazio(cOP) .And. A381ValOP(cOP) .And. VldUser("D4_OP") of oPanel1 HASBUTTON

	oGet := MSGetDados():New(oSize:GetDimension("GETDADOS","LININI"),oSize:GetDimension("GETDADOS","COLINI"),oSize:GetDimension("GETDADOS","LINEND"),oSize:GetDimension("GETDADOS","COLEND"),nOpc,"a381LinOk","","",(l381Inc .Or. l381Alt),NIL,NIL,NIL,LINHAS,,,,"a381DelOk")
	ACTIVATE MSDIALOG oDlg ON INIT EnchoiceBar(oDlg,{|| If(a381TudoOk(nOpc),lOK := .T.,lOK := .F.), If(lOk,oDlg:End(),)},;
													{|| lOK := .F., oDlg:End()},,aButtons)
Else
	//Validando dados pela rotina automatica
	If EnchAuto(cAlias,aAutoCab,{|| VldCabAuto(nOpc)},aRotina[nOpc,4]) .And. ;
		(lAutZera .Or. MsGetDAuto(aAutoItens,"a381LinOk",{||a381TudoOk(nOpc)},aAutoCab,aRotina[nOpc,4],l381Inc))
		lOK := .T.		
	Else
		lOK := .F.
	EndIf
EndIf
If lOK
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Ponto de entrada para confirmar a exclusao ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	lContinua := .T.
	If l381Exc .And. ExistBlock('MT381EXC')
		lRetPE := ExecBlock('MT381EXC', .F., .F.)
		If ValType(lRetPE) == "L"
			lContinua := lRetPE
		EndIf
	EndIf

	If lContinua
		lContinua := a381Valid()
	EndIf

	

	If lContinua	
		a381Grava()
	EndIf
EndIf

lZeraEmp := .F.

If !l381Auto 
	Set Key VK_F4 To
	Set Key VK_F5 To
	Set Key VK_F6 To
	Set Key VK_F7 To
EndIf
RestArea(aArea)

Return

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡ao    ³A381aCores ³ Autor ³ Andre Anjos		    ³ Data ³ 16/04/08 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Cria array aCores                                          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ Nenhum                                                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ ExpA1 = Array aCores                                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA381					                                  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function A381aCores()
Local aCores:= {{'QtdComp(SD4->D4_QTDEORI) == QtdComp(SD4->D4_QUANT) .And. QtdComp(SD4->D4_QUANT) # QtdComp(0)','BR_VERDE'},; 
				{'QtdComp(SD4->D4_QTDEORI) # QtdComp(SD4->D4_QUANT) .And. QtdComp(SD4->D4_QUANT) # QtdComp(0)','BR_AMARELO'},; 
				{'QtdComp(SD4->D4_QTDEORI) # QtdComp(SD4->D4_QUANT) .And. QtdComp(SD4->D4_QUANT) == QtdComp(0)','BR_VERMELHO'}}
Return aCores

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡ao    ³A240Legenda³ Autor ³ Andre Anjos		   	³ Data ³ 16/04/08 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Cria uma janela contendo a legenda da mBrowse              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpA1 = Array aCores                                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ Nenhum                                                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA240/MATA241/MATA242                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function A381Legenda(aCores)
Local aLegenda := {}

Default lAutomacao := .F.

aAdd(aLegenda,{"BR_VERDE"	 ,OemToAnsi(STR0007)}) //Empenho em aberto
aAdd(aLegenda,{"BR_AMARELO"  ,OemToAnsi(STR0008)}) //Empenho parcialmente baixado
aAdd(aLegenda,{"BR_VERMELHO" ,OemToAnsi(STR0009)}) //Empenho totalmente baixado
If !lAutomacao
	BrwLegenda(cCadastro,OemToAnsi(STR0006),aLegenda) //"Legenda"
EndIf 

Return

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡ao    ³A381Ender ³ Autor ³ Andre Anjos		   	³ Data ³ 22/04/08 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Funcao que monta tela de visualizacao dos enderecos 		  ³±±
±±³			 ³	empenhados              								  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpA1 = Array aCores                                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ Nenhum                                                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA381				                                      ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function a381Ender(aEndAuto)
Local cProduto := aCols[n,nPosCod]
Local cLocal   := aCols[n,nPosLocal]
Local nQtdSD4  := aCols[n,nPosQuant]
Local cTRT	   := aCols[n,nPosTRT]
Local cLoteCtl := aCols[n,nPosLotCtl]
Local cNumLote := aCols[n,nPosLote]
Local nLinIt   := n
Local nRecD4   := aCols[n][Len(aHeader)]
Local aArea		 := GetArea()
Local aSavCols   := aClone(aCols)
Local aSavHeader := aClone(aHeader)

Local lOK := .F.
Local bSeekWhile := {|| DC_FILIAL+DC_PRODUTO+DC_LOCAL+DC_OP+DC_TRT+DC_LOTECTL+DC_NUMLOTE}
Local bSeekFor	 := {|| .T.}
Local aNoFields	 := {"DC_ORIGEM","DC_PRODUTO","DC_LOCAL","DC_LOTECTL","DC_NUMLOTE","DC_OP","DC_TRT","DC_PEDIDO","DC_ITEM",;
					"DC_QTDORIG","DC_SEQ","DC_ESTFIS"}
Local cSeek 	 := xFilial("SDC")+cProduto+cLocal+cOP+cTRT+cLoteCtl+cNumLote

Local nX 		 := 0
Local nReg		 := 0
Local cTitPro	 := " - " +AllTrim(cProduto) + If(!Empty(cTRT)," Seq: "+AllTrim(cTRT),"")
Local nOpcEnd	 := If((l381Inc.Or.l381Alt) .And. !lZeraEmp,4,2)

Private cEndProd := cProduto
Private cEndAlmo := cLocal
Private cEndLCtl := cLoteCtl
Private cEndLote := cNumLote
Private nLinCols := nLinIt

Private nPosEnder  := 0
Private nPosQtdDC  := 0
Private nPosSerie  := 0  
Private nPosSegDC  := 0

Private nSD4SDC	   := nQtdSD4

Default aEndAuto   := {}

If !a381LinOk(,.F.)
	Return .F.
EndIf

If !Localiza(cProduto,.T.)
	Help(" ",1,"NAOLOCALIZ")
	Return .F.
EndIf

If Rastro(cProduto) .And. Empty(cEndLCtl+cEndLote)
	Help(" ",1,"MA381LOTE")
	Return .F.
EndIf

// Se integrado ao WMS não permite a modificação dos endereços dos empenhos
If lWmsNew .And. IntWms(cProduto) 
	SD4->(dbGoTo(aCols[n,Len(aHeader)]))
	If !WmsAvalSD4("1",SD4->(Recno()))
		Return .F.
	EndIf
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//|Limpa acols e aheader para nova montagem - SDC |
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
aCols   := {}
aHeader := {}

dbSelectArea("SDC")
dbSetOrder(2)
dbSeek(cSeek)
FillGetDados(If((l381Inc.Or.l381Alt),4,2),"SDC",2,cSeek,bSeekWhile,bSeekFor,aNoFields)

//-- Adiciona validacoes e F3
For nX := 1 to Len(aHeader)
	Do Case
		Case AllTrim(aHeader[nX][2]) == "DC_QUANT"
			aHeader[nX][6] := "Positivo() .And. NaoVazio() .And. A380SegUm('"+cProduto+"')"
		Case AllTrim(aHeader[nX][2]) == "DC_LOCALIZ"
			aHeader[nX][6] := "VldAltEnd() .And. NaoVazio() .And. ExistCpo('SBE','"+cLocal+"'+M->DC_LOCALIZ)"
			aHeader[nX][9] := "SBE"
		Case AllTrim(aHeader[nX][2]) == "DC_QTSEGUM"
			aHeader[nX][6] := "A380Um()"
		Case AllTrim(aHeader[nX][2]) == "DC_NUMSERI"
			aHeader[nX][6] := "VldAltEnd()"
	EndCase
Next nX

nPosEnder := aScan(aHeader,{|aX| AllTrim(aX[2]) == "DC_LOCALIZ"})
nPosQtdDC := aScan(aHeader,{|aX| AllTrim(aX[2]) == "DC_QUANT"})
nPosSerie := aScan(aHeader,{|aX| AllTrim(aX[2]) == "DC_NUMSERI"})  
nPosSegDC := aScan(aHeader,{|aX| AllTrim(aX[2]) == "DC_QTSEGUM"})

If (Len(aCols)==1) .And. Empty(aCols[1,nPosEnder]+aCols[1,nPosSerie]) //sem itens
	If !l381Auto
		aCols[1][nPosQtdDC] := nQtdSD4
	Else
		aDel(aCols,1)
		aSize(aCols,Len(aCols)-1)
	EndIf
EndIf

//Se for inclusão de um registro da SD4, limpa o array aCols para o ExecAuto incluir os registros corretamente.
If l381Auto .And. nRecD4 < 1
	aCols := {}
	aSize(aCols,0)
EndIf

If !Empty(aEnderecos)
	aEnderecos := aSort(aEnderecos,,,{ |x, y| x[1] < y[1] .Or. x[2] < y[2]}) 
EndIf
nX := aScan(aEnderecos,{|x| x[1] == nLinIt})
While (nX > 0) .And. (nX <= Len(aEnderecos)).And. aEnderecos[nX][1] == nLinIt
	If (Len(aCols)==1) .And. Empty(aCols[1,nPosEnder]+aCols[1,nPosSerie]) //sem itens
		aCols := {} //limpa
	EndIf
	nReg := aScan(aCols, {|x| x[Len(aHeader)] == aEnderecos[nX][6] .And. x[Len(aHeader)]#0})
	If nReg == 0 .And. !aEnderecos[nX][7] //item nao gravado e nao deletado
		aAdd(aCols,Array(Len(aHeader)+1))	
		aCols[Len(aCols)][nPosEnder] := aEnderecos[nX][2]
		aCols[Len(aCols)][nPosSerie] := aEnderecos[nX][3]
		aCols[Len(aCols)][nPosQtdDC] := aEnderecos[nX][4]
		aCols[Len(aCols)][nPosSegDC] := aEnderecos[nX][5]
		aCols[Len(aCols)][Len(aHeader)-1] := "SDC" //alias
		aCols[Len(aCols)][Len(aHeader)] := 0 //recno
		aCols[Len(aCols)][Len(aHeader)+1] := .F. //delete
	ElseIF nReg > 0 .And. !aEnderecos[nX][7] //item do banco que nao foi deletado
		aCols[nReg][nPosEnder] := aEnderecos[nX][2]
		aCols[nReg][nPosSerie] := aEnderecos[nX][3]
		aCols[nReg][nPosQtdDC] := aEnderecos[nX][4]
		aCols[nReg][nPosSegDC] := aEnderecos[nX][5]
	ElseIf nReg > 0 .And. aEnderecos[nX][7] //deletado do banco
		aDel(aCols,nReg)
		aSize(aCols,Len(aCols)-1)
	EndIf
	nX++
End

If !l381Auto
	DEFINE MSDIALOG oVisEmp TITLE Substr(OemToAnsi(STR0016),1,21)+cTitPro OF oMainWnd PIXEL FROM 0,0 TO 310,600 //"Empenhos por enderecos"
	oEnd := MSGetDados():New(35,07,148,298,nOpcEnd,"A381VldL","A381OkEnd","",(l381Inc.Or.l381Alt),NIL,NIL,NIL,LINHAS)
	ACTIVATE MSDIALOG oVisEmp ON INIT EnchoiceBar(oVisEmp,{|| If(oEnd:TudoOK(),lOK := .T.,lOK := .F.), If(lOk,oVisEmp:End(),)},;
															{|| lOK := .F. , oVisEmp:End()})
Else
	lOK := MsGetDAuto(aEndAuto,"A381VldL","A381OkEnd",Nil,Iif(l381Inc,3,4),.F.)
EndIf

If lOK .And. (l381Inc .Or. l381Alt)
	If !Empty(aEnderecos)
		aEnderecos := aSort(aEnderecos,,,{ |x, y| x[1] < y[1] .Or. x[2] < y[2]}) 
	EndIf
	//-- Exclui itens do array aEnderecos caso existam
	nX := aScan(aEnderecos,{|x| x[1] == nLinIt})
	While (nX > 0) .And. (nX <= Len(aEnderecos)) .And. !Empty(aEnderecos) .And. (nLinIt == aEnderecos[nX][1])
		If !aEnderecos[nX][7] //mantem os deletados para nao traze-los na tela
			aDel(aEnderecos,nX)
			aSize(aEnderecos,Len(aEnderecos)-1)
		Else
			nX++
		EndIf
	End

	//-- Adiciona os itens novos
	For nX := 1 To Len(aCols)
		aAdd(aEnderecos,{nLinIt,; //1- Linha do empenho
						aCols[nX,nPosEnder],; //2- Localiz
						aCols[nX,nPosSerie],; //3- N. Serie
						aCols[nX,nPosQtdDC],; //4- Qtde SDC
						aCols[nX,nPosSegDC],; //5- SegUM SDC
						aCols[nX,Len(aHeader)],; //6- Recno SDC
						aCols[nX,Len(aHeader)+1],; //7- Deletado
						cLoteCtl,; //8- Lote
						cNumLote,; //9- Sub-Lote
						cProduto,; //10- Produto
						cLocal}) //11- Local
	Next nX
EndIf

If !Empty(aEnderecos)
	aEnderecos := aSort(aEnderecos,,,{ |x, y| x[1] < y[1]}) 
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//|Restaura aCols e aHeader 	   |
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
aCols   := aClone(aSavCols)
aHeader := aClone(aSavHeader)

RestArea(aArea)
//-- Retorna a variável de controle do aCols para o aCols de empenhos
n := nLinIt

Return lOK

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡ao    ³VldAltEnd  ³ Autor ³ Andre Anjos		   	³ Data ³ 29/04/08 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Valida alteracao de endereco/num. serie (limitacao tecn.)  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA381				                                      ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function VldAltEnd()
Local lRet := .T.

Default lAutomacao := .F.

If !lAutomacao
	If aCols[n,Len(aHeader)] == 0 //item nao gravado, pode ser alterado
		If ReadVar() == "M->DC_LOCALIZ" .And. lWmsNew .And. IntWms(cEndProd)
			lRet := Wms650End(cEndAlmo,M->DC_LOCALIZ)
		EndIf
		Return lRet
	EndIf
EndIf

If ReadVar() == "M->DC_LOCALIZ"
	If !Empty(aCols[n,nPosEnder]) .And. M->DC_LOCALIZ # aCols[n,nPosEnder]
		Help(" ",1,"MA381NOALT")
		lRet := .F.
	EndIf
ElseIf ReadVar() == "M->DC_NUMSERI"
	If !Empty(aCols[n,nPosSerie]) .And. M->DC_NUMSERI # aCols[n,nPosSerie]
		Help(" ",1,"MA381NOALT")
		lRet := .F.
	EndIf
EndIf

Return lRet

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡ao    ³A381VldL   ³ Autor ³ Andre Anjos		   	³ Data ³ 29/04/08 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Valida linhas de enderecos								  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA381				                                      ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function A381VldL()
Local aArea 	:= GetArea()
Local lRet 		:= .T.
Local nX		:= 0
Local nSldSBF	:= 0

If aCols[n,Len(aHeader)+1] //deletado
	Return lRet	
EndIf

If lWmsNew .And. IntWms(cEndProd)
	nSldSBF := WmsSldD14(cEndAlmo,aCols[n,nPosEnder],cEndProd,aCols[n,nPosSerie],cEndLCtl,cEndLote)
Else
	nSldSBF := SaldoSBF(cEndAlmo,aCols[n,nPosEnder],cEndProd,aCols[n,nPosSerie],cEndLCtl,cEndLote)
EndIf

For nX := 1 To Len(aEnderecos)
	If aEnderecos[nX,10]+aEnderecos[nX,11]+aEnderecos[nX,2]+aEnderecos[nX,3]+aEnderecos[nX,8]+aEnderecos[nX,9] ==;
		cEndProd+cEndAlmo+aCols[n,nPosEnder]+aCols[n,nPosSerie]+cEndLCtl+cEndLote .And.;
		(aEnderecos[nX,7] .Or. aEnderecos[nX,1] # nLinCols)
		
		If aEnderecos[nX,7] .And. aEnderecos[nX,6] > 0 //se deletado e gravado
			dbSelectArea("SDC")
			dbGoTo(aEnderecos[nX,6])
			nSldSBF += SDC->DC_QUANT
		ElseIF !aEnderecos[nX,7] .And. aEnderecos[nX,6] > 0//nao deletado e gravado
			dbSelectArea("SDC")
			dbGoTo(aEnderecos[nX,6])
			If aEnderecos[nX,4] # SDC->DC_QUANT //quantidade alterada
				nSldSBF += SDC->DC_QUANT - aEnderecos[nX,4]
			EndIf
		ElseIF !aEnderecos[nX,7] .And. aEnderecos[nX,6] == 0 //nao deletado e recem-incluido
			nSldSBF -= aEnderecos[nX,4]
		EndIf
	EndIf
Next nX  

For nX := 1 To Len(aCols)
	If nX == n //linha que esta sendo validada
		If aCols[nX,Len(aHeader)] > 0
			dbSelectArea("SDC")
			dbGoTo(aCols[nX,Len(aHeader)])
			nSldSBF += SDC->DC_QUANT
		EndIf
	ElseIF !aCols[nX,Len(aHeader)+1] .And. aCols[nX,nPosEnder]+aCols[nX,nPosSerie] == aCols[n,nPosEnder]+aCols[n,nPosSerie]
		If aCols[nX,Len(aHeader)] == 0 //nao gravado
			nSldSBF -= aCols[nX,nPosQtdDC]
		EndIf			
	ElseIf aCols[nX,Len(aHeader)+1] .And. aCols[nX,nPosEnder]+aCols[nX,nPosSerie] == aCols[n,nPosEnder]+aCols[n,nPosSerie] .And.;
			aCols[nX,Len(aHeader)] > 0 //ja gravado
		nSldSBF += aCols[nX,nPosQtdDC]
	EndIf
Next nX

Do case
	Case Empty(aCols[n,nPosEnder])
		Help(" ",1,"OBRIGAT2",,AllTrim(RetTitle("DC_LOCALIZ")),3,0)
		lRet := .F.
	Case Empty(aCols[n,nPosQtdDC])
		Help(" ",1,"OBRIGAT2",,AllTrim(RetTitle("DC_QUANT")),3,0)
		lRet := .F.
	Case aCols[n,nPosQtdDC] > nSldSBF
		Help(" ",1,"SALDOLOCLZ")
		lRet:=.F.
	Case aCols[n,nPosQtdDC] < 0
		Help(NIL, NIL, STR0021, NIL,STR0088 , 1, 0, NIL, NIL, NIL, NIL, NIL, {STR0089})
		//"Produto de Empenho negativo, com Controle de Endereçamento, não permite identificar o endereço sem realizar a produção. "
		//"Favor, não preencher endereço para o empenho com quantidade negativa."
		lRet:=.F.	
EndCase

RestArea(aArea)
Return lRet

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡ao    ³A381Grava³ Autor ³ Andre Anjos		   	³ Data ³ 29/04/08 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Processa a inclusao de empenhos de uma OP				  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ cExp1 = Código da OP cujos empenhos serao incluidos        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA381				                                      ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function A381Grava()
Local aArea := GetArea()
Local cCampo := ""
Local nX := 0, nY := 0
Local aTravas := {}
Local lConsVenc := GetMV('MV_LOTVENC')=='S'
Local nQuantAnt := 0
Local nQtSegAnt := 0
Local cLtCtlAnt := ""
Local cLoteAnt  := ""
Local cAlmAnt   := ""
Local a380Grv 	:= {} //array que simula o aCols da A380DigLoc
Local nSldSD41 	:= 0
Local nSldSD42 	:= 0
Local cRoteiro   := ""
Local nPosAgr   := 0
Local lIntegPPI	:= PCPIntgPPI()

Private mv_par01 := 2 //para A380Grava
Private aRotAuto := Nil // Não excluir DMANSMARTSQUAD1-24655

nPosAgr := aScan(aHeader,{|x| AllTrim(x[2]) == "AUT_D4_AGR"})

Begin Transaction
	If !Empty(SC2->C2_ROTEIRO)
		cRoteiro := SC2->C2_ROTEIRO
	Else
		If !Empty(Posicione('SB1',1,xFilial('SB1')+SC2->C2_PRODUTO,'B1_OPERPAD')) 
     		cRoteiro := SB1->B1_OPERPAD
		Else
			cRoteiro := StrZero(1, TamSX3("G2_CODIGO")[1])			
		Endif
	Endif
	
	//Primeiro processa exclusões, e posteriormente processa inclusões/alterações.
	For nX := 1 to Len(aCols)
		If aCols[nX][Len(aHeader)] > 0 .And. (l381Exc .Or. (l381Alt .And. aCols[nx][Len(aHeader)+1]))
			SD4->(dbGoTo(aCols[nX][Len(aHeader)])) //recno contido no aCols
			GravaEmp(SD4->D4_COD,SD4->D4_LOCAL,	SD4->D4_QUANT,SD4->D4_QTSEGUM,SD4->D4_LOTECTL,SD4->D4_NUMLOTE,NIL,NIL,SD4->D4_OP,;
				SD4->D4_TRT,NIL,NIL,"SC2",NIL,SD4->D4_DATA,@aTravas,.T.,NIL,.T.,.T.,lConsVenc)				     
			// Deve estornar o empenho no novo WMS quado for o caso - lWmsNew
			If lWmsNew .And. IntWms(SD4->D4_COD)
				WmsEmpReq("SC2",;
							 SD4->D4_COD,;
							 SD4->D4_LOCAL,;
							 SD4->D4_QUANT,;
							 /*cEndereco*/,;
							 SD4->D4_LOTECTL,;
							 SD4->D4_NUMLOTE,;
							 /*cNumSerie*/,;
							 SD4->D4_OP,;
							 SD4->D4_TRT,;
							 SD4->D4_IDDCF,;
							 /*cIdUnitiz*/,;
							 .T.,; // lEstorno
							 .T.,; // lCriaSDC
							 .T.)  // lEmpD14
			EndIf
			MaDesTrava(aTravas)
			//Grava os dados do SIGAAGR (Dados existentes somente quando utilizado a integração com o PIMS)
			A381GrvAgr(.T.,SD4->D4_COD, SD4->D4_LOCAL, SD4->D4_OP, SD4->D4_TRT, SD4->D4_LOTECTL, SD4->D4_NUMLOTE)
			
			DbSelectArea("SD4")
			RecLock("SD4",.F.,.T.)
			DbDelete()
		EndIf
	Next nX

	For nX := 1 to Len(aCols)
		If !aCols[nx][Len(aHeader)+1] .And. (l381Inc .Or. l381Alt)//caso nao esteja deletado
			nPos := aScan(aEnderecos,{|x| x[1] == nX})
			If l381Inc .Or. (l381Alt .And. (aCols[nX][Len(aHeader)] == 0)) //inclusao ou nova linha incluida por alteracao
				RecLock("SD4",.T.)
				Replace D4_OP With cOP, D4_FILIAL With xFilial("SD4")
				nQuantAnt := aCols[nX,nPosQuant]
				//O "If nPosSegUM > 0" serve para que não ocorra erro quando o campo D4_QTSEGUM seja tirado de uso
				If nPosSegUM > 0	
					nQtSegAnt := aCols[nX,nPosSegUM]
				EndIf
				cLtCtlAnt := aCols[nX,nPosLotCtl]
				cLoteAnt  := aCols[nX,nPosLote]
				cAlmAnt	  := aCols[nX,nPosLocal]
  			Else
  				SD4->(dbGoTo(aCols[nX][Len(aHeader)]))
				nQuantAnt := SD4->D4_QUANT
				nQtSegAnt := SD4->D4_QTSEGUM
				cLtCtlAnt := SD4->D4_LOTECTL
				cLoteAnt  := SD4->D4_NUMLOTE
				cAlmAnt	  := SD4->D4_LOCAL
				dbSelectArea("SD4")
  				RecLock("SD4",.F.)
  			EndIf
  			//-- Grava SD4
			For nY := 1 to (Len(aHeader)-2)
				If aHeader[nY][10] # "V"
					cCampo := Trim(aHeader[nY][2])
					Replace &cCampo With aCols[nX][nY]
				EndIf
			Next nY

			If Empty(SD4->D4_PRODUTO)
				SD4->D4_PRODUTO := Posicione('SC2',1,xFilial('SC2')+cOP,'C2_PRODUTO')
			EndIf

			If Empty(SD4->D4_ROTEIRO)
				SD4->D4_ROTEIRO := cRoteiro
			EndIf

			If Empty(SD4->D4_DATA)
				SD4->D4_DATA := dDataBase
			EndIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Seta a variável lZeraEmp igual a lZeraEmp2         				³
			//³ Devido o programa fazer chamada a mata380 e utilizar a variável ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ  
			lZeraEmp:=lZeraEmp2
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ lZeraEmp2 - Variavel utilizada para verificar se devera   ³
			//³             zerar o empenho conforme selecionado no botao.³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If l381Alt .And. lZeraEmp2
				Replace D4_QUANT With 0
				Replace D4_QTSEGUM With 0
			EndIf            
		
			If l381Alt .Or. (aCols[nX][Len(aHeader)] == 0)
				MsUnLock()
				nSldSD41 := SD4->D4_QUANT
				nSldSD42 := SD4->D4_QTSEGUM
			EndIf
			//-- Prepara array de enderecos para a A380Grava
			a380Grv := {} 
			While (nPos > 0) .And. (nPos <= Len(aEnderecos)) .And. !Empty(aEnderecos) .And. (nX == aEnderecos[nPos][1])
				If !aEnderecos[nPos][7] //nao deletado
					aAdd(a380Grv,{aEnderecos[nPos][4],aEnderecos[nPos][2],aEnderecos[nPos][3],aEnderecos[nPos][5],.F.})
					nSldSD41 -= aEnderecos[nPos][4]
					nSldSD42 -= aEnderecos[nPos][5]
				EndIf
				nPos++
			End
			If l381Alt .And. !Empty(a380Grv) .And. nSldSD41 > 0
				aAdd(a380Grv,{nSldSD41,CriaVar("DC_LOCALIZ"),CriaVar("DC_NUMSERI"),ConvUM(SD4->D4_COD,nSldSD41,nSldSD42,2),.F.})
			EndIf
			If l381Inc .Or. (aCols[nX][Len(aHeader)] == 0) //inclusao ou nova linha incluida por alteracao
				For nY := 1 To Len(a380Grv) //-- Grava empenhos por enderecos
					GravaEmp(SD4->D4_COD,SD4->D4_LOCAL,	a380Grv[nY,1],ConvUM(SD4->D4_COD,a380Grv[nY,1],a380Grv[nY,4],2),;
					  		 SD4->D4_LOTECTL,SD4->D4_NUMLOTE,a380Grv[nY,2],a380Grv[nY,3],SD4->D4_OP,SD4->D4_TRT,NIL,NIL,"SC2",;
							 NIL,SD4->D4_DATA,@aTravas,	.F.,NIL,.T.,.F.,lConsVenc,.T.,.T.)							 
					// Deve gravar o empenho no novo WMS quado for o caso - lWmsNew
					If lWmsNew .And. IntWms(SD4->D4_COD)
						WmsEmpReq("SC2",;
									 SD4->D4_COD,;
									 SD4->D4_LOCAL,;
									 a380Grv[nY,1],;
									 a380Grv[nY,2],;
									 SD4->D4_LOTECTL,;
									 SD4->D4_NUMLOTE,;
									 a380Grv[nY,3],;
									 SD4->D4_OP,;
									 SD4->D4_TRT,;
									 SD4->D4_IDDCF,;
									 /*cIdUnitiz*/,;
									 .F.,; // lEstorno
									 .T.,; // lCriaSDC
									 .T.)  // lEmpD14
					EndIf
					nQuantAnt -= a380Grv[nY,1]
					nQtSegAnt -= ConvUM(SD4->D4_COD,a380Grv[nY,1],a380Grv[nY,4],2)
				Next nY
				//-- Gera empenho da diferenca
				// Neste caso não precisa gerar para o WMS, pois não é empenho por endereço
				GravaEmp(SD4->D4_COD,SD4->D4_LOCAL,nQuantAnt,ConvUM(SD4->D4_COD,nQuantAnt,nQtSegAnt,2),SD4->D4_LOTECTL,;
						 SD4->D4_NUMLOTE,Nil,Nil,SD4->D4_OP,SD4->D4_TRT,NIL,NIL,"SC2",NIL,SD4->D4_DATA,@aTravas,.F.,NIL,.T.,;
						 .F.,lConsVenc,Rastro(SD4->D4_COD),!Empty(SD4->D4_LOTECTL+SD4->D4_NUMLOTE))						 
			Else
				//Adiciona item no a380Grv para
				If (!Empty(SC2->C2_DATRF) .And. lZeraEmp .And. Empty(a380Grv)) .Or.; //deletar SDC quando zera empenhos de OP ja encerrada
					(Localiza(SD4->D4_COD,.T.) .And. Empty(a380Grv) .And. aCols[nX,Len(aHeader)] == 0) //para gerar SDC quando inclusao e usuario nao digitou enderecos
					aAdd(a380Grv,{SD4->D4_QUANT,CriaVar("DC_LOCALIZ"),CriaVar("DC_NUMSERI"),SD4->D4_QTSEGUM,.F.})
				ElseIf Localiza(SD4->D4_COD,.T.) .And. Empty(a380Grv) .And. nPos == 0//verifica se tem gravado no SDC para itens nao clicados
					dbSelectArea("SDC")
					dbSetOrder(2)
					dbSeek(xFilial("SDC")+SD4->(D4_COD+D4_LOCAL+D4_OP+D4_TRT+D4_LOTECTL+D4_NUMLOTE))
					While !EOF() .And. SDC->(DC_FILIAL+DC_PRODUTO+DC_LOCAL+DC_OP+DC_TRT+DC_LOTECTL+DC_NUMLOTE) == ;
										xFilial("SDC")+SD4->(D4_COD+D4_LOCAL+D4_OP+D4_TRT+D4_LOTECTL+D4_NUMLOTE)

						If SD4->D4_QUANT != 0
							aAdd(a380Grv,{SDC->DC_QUANT,SDC->DC_LOCALIZ,SDC->DC_NUMSERI,SDC->DC_QTSEGUM,.F.})
						EndIf 
						
						SDC->(dbSkip())
					End
					dbSelectArea("SD4")
					If !Empty(SD4->(D4_LOTECTL+D4_NUMLOTE)) .And. Empty(a380Grv)
						If SD4->D4_QUANT != 0
							aAdd(a380Grv,{SD4->D4_QUANT,CriaVar("DC_LOCALIZ"),CriaVar("DC_NUMSERI"),SD4->D4_QTSEGUM,.F.})
						EndIf 
					EndIf
				EndIf
				A380Grava(nQuantAnt,cLoteAnt,cLtCtlAnt,cAlmAnt,nQtSegAnt,a380Grv)
			EndIf
			//Grava os dados do SIGAAGR (Dados existentes somente quando utilizado a integração com o PIMS)
			If nPosAgr > 0
				If aCols[nX,nPosAgr] != Nil .And. ValType(aCols[nX,nPosAgr]) == "A" .And. Len(aCols[nX,nPosAgr]) > 0
					A381GrvAgr(.F.,SD4->D4_COD, SD4->D4_LOCAL, SD4->D4_OP, SD4->D4_TRT, SD4->D4_LOTECTL, SD4->D4_NUMLOTE, aCols[nX,nPosAgr])
				EndIf
			EndIf
		EndIf
	Next nX
	If ( ExistBlock("MTA381GRV") )
		ExecBlock("MTA381GRV",.F.,.F.,{l381Inc,l381Exc,l381Alt})
	EndIf
	
	A381AtuNec(SD4->D4_OP,SC2->C2_QUANT)
End Transaction

If lIntegPPI
   IntegPPI()
EndIf

RestArea(aArea)
Return

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³A381ValOP ³ Autor ³ Andre Anjos		    ³ Data ³ 29/04/08 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Avalia se a Op escolhida e valida.		                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ A381ValOP()                                             	  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA381                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function A381ValOP()
Local lRet := .T.
Local aArea := GetArea()

dbSelectArea("SC2")
If dbSeek(xFilial("SC2")+cOP)
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica se a OP ja' foi encerrada ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lRet .And. !Empty(SC2->C2_DATRF)
		Help(" ",1,"A250ENCERR")
		lRet := .F.
	EndIf
	
	If !Empty(SC2->C2_ROTEIRO)
		cRotSC2 := SC2->C2_ROTEIRO
	Else
		If !Empty(Posicione('SB1',1,xFilial('SB1')+SC2->C2_PRODUTO,'B1_OPERPAD') )
     		cRotSC2 := SB1->B1_OPERPAD
		Else
			cRotSC2 := StrZero(1, TamSX3("G2_CODIGO")[1])			
		EndIf	
	Endif	
	
ElseIf !Empty(cOP)
	Help(" ",1,"REGNOIS")
	lRet := .F.
EndIf

RestArea(aArea)
Return lRet

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³A381TudoOk³ Autor ³ Andre Anjos		    ³ Data ³ 29/04/08 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Validacoes gerais do cadastro			                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA381                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function A381TudoOk(nOpc)
Local aArea      := GetArea()
Local lRet    	 := .T.
Local lMT381VLD  := .F.
Local nX    	 := 0
Local nX2    	 := 0
Local nAcho      := 0  
Local nAnt	 	 := 0
Local nBus       := 0
Local i          := 0
Local aSeq	     := {}
Local lIntSFC 	 := IntegraSFC() .And. !IsInCallStack("DPRA340INT")
Local lIntMNT    := SuperGetMV( 'MV_NGMNTCM', .F., '' ) == 'S'
Local cVarOri    := ReadVar()
Local nBkp       := n
Local nQtdBkp    := M->D4_QUANT
Local nQtdOriBkp := M->D4_QTDEORI
Local aColsValid := ACLONE(aCols)
Local nXvalid    := 0

nAcho := Ascan( aCols, {|x| x[Len(aHeader)+1] == .F. })
If nAcho == 0
	Help(" ",1,"MA381ITENS")
	lRet := .F.
EndIf   

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Executa ponto de entrada para validar se grava o ajuste empenho ou não      ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If ExistBlock("MT381VLD")
	lMT381VLD := ExecBlock("MT381VLD",.F.,.F.,{l381Inc,l381Alt})  
	If ValType(lMT381VLD) == "L"
		lRet := lMT381VLD
	EndIf
EndIf

If lRet
	dbSelectArea("SD4")
	dbSetOrder(1)
	For nX := 1 To Len(aCols)
		n := nX
		If lRet .And. !GdDeleted()
			If l381Auto
				__ReadVar := "M->D4_QTDEORI"
				M->D4_QTDEORI := aCols[nX,nPosQtdOri]
				If !(lRet := A380Quant(.T.))
					__ReadVar := cVarOri
					M->D4_QTDEORI := nQtdOriBkp
					Exit
				EndIf
				__ReadVar := "M->D4_QUANT"
				M->D4_QUANT := aCols[nX,nPosQuant]
				If !(lRet := A380Quant(.T.))
					__ReadVar := cVarOri
					M->D4_QUANT   := nQtdBkp
					Exit
				EndIf
				__ReadVar := cVarOri
				M->D4_QUANT   := nQtdBkp
				M->D4_QTDEORI := nQtdOriBkp
			EndIf

			//-- Analisa se ha itens duplicados na GetDados.
			If lRet .And. INCLUI .And. !GDCheckKey({"D4_COD","D4_TRT","D4_LOTECTL","D4_NUMLOTE","D4_LOCAL","D4_OPORIG"},2,,,.F.) 
				Help(" ",1,"MA380JACAD")
				lRet := .F.
				Exit
			EndIf
			
			If(lRet) //Chamado TSWHRI
		    	For nBus:=1 To Len(aCols)		   
		        	If(!GdDeleted(nX) .and. ( nX # nBus ) .and. !aCols[nBus,Len(aCols[nBus])] .and. (aCols[nX,nPosCod]==aCols[nBus,nPosCod]) .and. (aCols[nX,nPosTrt]== aCols[nBus,nPosTrt]) .and. ((aCols[nX,nPosQuant] > 0 .and. aCols[nBus,nPosQuant] < 0) .or. (aCols[nX,nPosQuant] < 0 .and. aCols[nBus,nPosQuant] > 0)))
				    	Help(" ",1,"MA380JACAD")
				     	lRet := .F.
				     	Exit
		         	Endif      
		      	Next
		   	Endif 	
			
			//-- Analisa se ha itens duplicados na base
			If lRet 
						
				For nXvalid := 1 To Len(aColsValid)
					If nXvalid != nX
						If( (aColsValid[nXvalid,nPosLotCtl] == aCols[nX,nPosLotCtl]).AND. (aColsValid[nXvalid,nPosLote] == aCols[nX,nPosLote]) .AND. (aColsValid[nXvalid,nPosOporig]==aCols[nX,nPosOporig]) .AND.;
					        (aColsValid[nXvalid,nPosLocal]  == aCols[nX,nPosLocal]) .AND. (aColsValid[nXvalid,nPosCod]  == aCols[nX,nPosCod]).AND. (aColsValid[nXvalid,nPosTRT]  == aCols[nX,nPosTRT]) .AND. aCols[nX,Len(aHeader)] == 0 .And. (!GdDeleted(nX) .And. !GdDeleted(nXvalid)) )
						    Help(" ",1,"MA380JACAD")
						    lRet := .F.				     
					    ElseIf( (aCols[nX,Len(aHeader)] == 0) .And. !GdDeleted(nX) .And. !GdDeleted(nXvalid) .AND. ( ( aColsValid[nXvalid,nPosQuant] > 0 .AND. aCols[nX,nPosQuant] < 0) .OR. ( aColsValid[nXvalid,nPosQuant] < 0 .AND. aCols[nX,nPosQuant] > 0 ) ) .And. aColsValid[nXvalid,nPosCod] == aCols[nX,nPosCod]) .AND. (aColsValid[nXvalid,nPosTRT]  == aCols[nX,nPosTRT])    		         
						    Help(" ",1,"MA380JACAD")
						    lRet := .F.
					    EndIf
					EndIf
				Next nXvalid
						
				//-- Analisa se ha itens duplicados na base com quantidade invertida//Chamado TSWHRI
			   	/* dbSeek(xFilial("SD4")+aCols[nX,nPosCod]+cOP+aCols[nX,nPosTRT])
			   	While lRet .And. !EOF() .And. SD4->(D4_FILIAL+D4_COD+D4_OP+D4_TRT) == xFilial("SD4")+aCols[nX,nPosCod]+cOP+aCols[nX,nPosTRT]
				   	If ((SD4->D4_LOTECTL == aCols[nX,nPosLotCtl]).AND. (SD4->D4_NUMLOTE == aCols[nX,nPosLote]) .AND. (SD4->D4_OPORIG==aCols[nX,nPosOporig]) .AND.;
				        (SD4->D4_LOCAL == aCols[nX,nPosLocal]) .AND. aCols[nX,Len(aHeader)] == 0 .And. !GdDeleted(nX) ) 
						Help(" ",1,"MA380JACAD")
					   	lRet := .F.				     
				   	ElseIf( (aCols[nX,Len(aHeader)] == 0) .And. !GdDeleted(nX) .AND. ( ( SD4->D4_QUANT > 0 .AND. aCols[nX,nPosQuant] < 0) .OR. ( SD4->D4_QUANT < 0 .AND. aCols[nX,nPosQuant] > 0) ))     		         
					   	Help(" ",1,"MA380JACAD")
					   	lRet := .F.
				   	EndIf
				   	SD4->(dbSkip())
			   	End */
			Endif

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//Valida se as quantidades estão iguais 
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If lMT381SE
				If ((aCols[nX,nPosQuant] <> aCols[nX,nPosQtdOri]) .and. (nOpc == 3 .or. aCols[nX,nPosRecno] == 0))// registro novo na grid incluido via alteração
					Help(" ",1,ALLTRIM(FWSX3Util():GetDescription('D4_QUANT')) + "(D4_QUANT)",,STR0092,1,0, , , , , , { STR0093 })
					lRet:= .F.
				EndIf
			EndIf	
		EndIf
		nAnt := nX2
		nX2	 := nX
		If !A381LinOk(,,.T.)
			lRet := .F.
			nX2	 := nAnt
			Exit
		EndIf
	Next nX
EndIf

If( lRet) 
   	For i:=1 To Len(aCols)
	   	If !aCols[i,Len(aCols[i])]
		   	nAchoSeq:=ASCAN(aSeq,aCols[i,nPosTrt]+aCols[i,nPosCod]+aCols[i,nPosLote]+aCols[i,nPosLotCtl]+aCols[i,nPosOporig]+aCols[i,nPosLocal])
   
	   	   	IF nAchoSeq > 0
			   	Help(" ",1,"A650SEQJA")
			   	lRet:=.F.
		   	Else
		       	//Chamado TSWHRI
		       	For nBus:=1 To Len(aCols)		   
		          	If( ( i # nBus ) .and. !aCols[nBus,Len(aCols[nBus])] .and. (aCols[i,nPosCod]==aCols[nBus,nPosCod]) .and. (aCols[i,nPosTrt]== aCols[nBus,nPosTrt]) .and. ((aCols[i,nPosQuant] > 0 .and. aCols[nBus,nPosQuant] < 0) .or. (aCols[i,nPosQuant] < 0 .and. aCols[nBus,nPosQuant] > 0)))
				      	Help(" ",1,"A650SEQJA")
				      	lRet := .F.				   
		          	Endif      
		       	Next

		    		If lRet
		    			For nBus:=1 To Len(aCols)
		    		   		if ( i # nBus ) .and. ;
		    		    		aCols[i,nPosCod]==aCols[nBus,nPosCod] .and. ;
		    		    		aCols[i,nPosTrt]==aCols[nBus,nPosTrt] .and. ;
		    		    		aCols[i,nPosLotCtl]==aCols[nBus,nPosLotCtl] .and. ;
		    		    		aCols[i,nPosLote]==aCols[nBus,nPosLote] .and. ;
		    		    		aCols[i,nPosLocal]==aCols[nBus,nPosLocal] .and. ;
		    		    		aCols[i,nPosOporig]==aCols[nBus,nPosOporig] .and. ;
		    		    		!aCols[nBus,Len(aCols[nBus])]
		    		    		Help( ,, 'Help',, STR0047 + allTrim(aCols[i,nPosCod]) + STR0048 + allTrim(aHeader[nPosTrt,1]) + ', ' + allTrim(aHeader[nPosLote,1]) + ', ' + allTrim(aHeader[nPosLotCtl,1]) + ', ' + allTrim(aHeader[nPosLocal,1]) + STR0049 + allTrim(aHeader[nPosOporig,1]) + '.', 1, 0 )
				      			lRet := .F.
				      			Exit
				      		EndIf
				     	Next
		    		EndIf

		       	If( lRet ) 
			    	AADD(aSeq,aCols[i,nPosTrt]+aCols[i,nPosCod]+aCols[i,nPosLote]+aCols[i,nPosLotCtl]+aCols[i,nPosOporig]+aCols[i,nPosLocal])
			   	Endif   
		   	Endif
	   	EndIf
   	Next i
Endif
n := nBkp
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Chama rotina para integracao com SFC(Chao de Fabrica) ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lRet .And. lIntSFC
	lRet := A381IntSFC(nOpc)	
EndIf

If lRet .And. lIntMNT
	lRet := MNTINTSASC( cOP, 'MATA381', nOpc, aHeader, aCols )	
EndIf

RestArea(aArea)
Return lRet

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡ao    ³A381OkEnd  ³ Autor ³ Andre Anjos		   	³ Data ³ 29/04/08 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Valida tela de enderecos									  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA381				                                      ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function A381OkEnd()
Local lRet 		:= .T.
Local nTotEnd	:= 0
Local nX 		:= 0

For nX := 1 To Len(aCols)
	If !aCols[nX][Len(aHeader)+1] //nao deletados
		nTotEnd += aCols[nX][nPosQtdDC]
	EndIf
Next nX

If nTotEnd > nSD4SDC
	Help(" ",1,"A380QTDLOC")
	lRet:=.F.
EndIf

Return lRet

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³A381LinOk ³ Autor ³ Andre Anjos		    ³ Data ³ 29/04/08 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Validacoes gerais da linha do cadastro	                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA381                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function A381LinOk(o,lVldD4DC,lTudoOK)
Local aArea       := GetArea()
Local lRet 	      := .T.
Local nX 	   	  := 0
Local nQtdD4      := 0
Local nQtdDC      := 0
Local cLoteAnt    := ""
Local c381CtlAnt  := ""
Local cTabOper    := ""
Local nQtdJaEmp   := 0
Local lConsVenc   := GetMV('MV_LOTVENC')=='S'
Local lEmpPrev    := If(SuperGetMV("MV_QTDPREV")== "S",.T.,.F.)
Local lNegEstr    := SuperGetMV("MV_NEGESTR",.F.,.F.)
Local lEmpPrdOp   := SuperGetMV("MV_EMPDOP",.F.,.T.)
Local lMT381LOK   := .F.
Local nBus        := 0
Local nPos        := 0

Local i       := 0
Local nSaldoCol  := 0

Default lVldD4DC  := .T.    
Default lTudoOK   := .F.

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Verifica se tem permissao de armazem  |
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
lRet := MaAvalPerm(3,{aCols[n,nPosLocal],aCols[n,nPosCod]})

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Ponto de Entrada MT380SE, permite executar ou não a verificação de validação³
//³	entre o saldo original e a quantidade já requisitada.                      ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lRet .And. ExistBlock('MT381SE')
	lMT381SE := ExecBlock('MT381SE', .F., .F.) 
	If ValType(lMT381SE)<>"L"
		lMT381SE := .T.
	EndIf
EndIf

//Valida se o produto a ser empenhado é diferente do produto final
IF !lEmpPrdOp .And. !GdDeleted()
	DbSelectArea("SC2")
	DbSetOrder(1)
	If DbSeek(xFilial("SC2")+cOp) .And. (SC2->C2_PRODUTO == aCols[n,nPosCod])
		Help(" ",1,"MA380EMPDOP")        
		lRet:=.F.    
	EndIf
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Executa ponto de entrada para validar a linha do produto no ajuste empenho ou não      ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lRet .And. ExistBlock("MT381LOK")
	lMT381LOK := ExecBlock("MT381LOK",.F.,.F.,{l381Inc,l381Alt})  
	If ValType(lMT381LOK) == "L"
		lRet := lMT381LOK
	EndIf
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Analisa se o tipo do armazem permite a movimentacao |
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lRet .And. AvalBlqLoc(aCols[n,nPosCod],aCols[n,nPosLocal],Nil)
	lRet := .F.
EndIf

//-- Valida campos obrigatorios
If lRet .And. Empty(aCols[n,nPosCod]) .And. !aCols[n,Len(aHeader)+1]
	Help(" ",1,"OBRIGAT2",,AllTrim(RetTitle("D4_COD")),3,0)
	lRet := .F.
EndIf

If lRet .And. Empty(aCols[n,nPosLocal]) .And. !aCols[n,Len(aHeader)+1]
	Help(" ",1,"OBRIGAT2",,AllTrim(RetTitle("D4_LOCAL")),3,0)
	lRet := .F.
EndIf

If lRet .And. aCols[n,Len(aHeader)] == 0 .And. Empty(aCols[n,nPosQuant]) .And. !aCols[n,Len(aHeader)+1]
	Help(" ",1,"OBRIGAT2",,AllTrim(RetTitle("D4_QUANT")),3,0)
	lRet:=.F.
EndIf

//-- Nao avalia linhas deletadas
If lRet .And. !GdDeleted()
	//-- Analisa se ha itens duplicados na GetDados.
	If INCLUI .And. !GDCheckKey({"D4_COD","D4_TRT","D4_LOTECTL","D4_NUMLOTE","D4_LOCAL","D4_OPORIG"},2,,,.F.)
		Help(" ",1,"MA380JACAD")
		lRet := .F.
	EndIf
	
	If lRet //Chamado TSWHRI
		For nBus:=1 To Len(aCols)		   
			If( ( n # nBus ) .and. !aCols[nBus,Len(aCols[nBus])] .and. (aCols[n,nPosCod]==aCols[nBus,nPosCod]) .and. (aCols[n,nPosTrt]== aCols[nBus,nPosTrt]) .and. ((aCols[n,nPosQuant] > 0 .and. aCols[nBus,nPosQuant] < 0) .or. (aCols[n,nPosQuant] < 0 .and. aCols[nBus,nPosQuant] > 0)))
		    	Help(" ",1,"MA380JACAD")
			   	lRet := .F. 
		   	Endif      
		Next
	Endif 
	
	//-- Analisa se ha itens duplicados na base.
	If lRet .And. INCLUI // Somente na inclusao
		dbSelectArea("SD4")
		dbSetOrder(1)
		
		//-- Analisa se ha itens duplicados na base com quantidade invertida//Chamado TSWHRI
		/*
		dbSeek(xFilial("SD4")+aCols[nX,nPosCod]+cOP+aCols[nX,nPosTRT])
		While lRet .And. !EOF() .And. SD4->(D4_FILIAL+D4_COD+D4_OP+D4_TRT) == xFilial("SD4")+aCols[nX,nPosCod]+cOP+aCols[nX,nPosTRT]
			If ((SD4->D4_LOTECTL==aCols[n,nPosLotCtl]) .AND. (SD4->D4_NUMLOTE==aCols[n,nPosLote]) .AND. (SD4->D4_OPORIG==aCols[n,nPosOporig]) .AND. (SD4->D4_LOCAL == aCols[n,nPosLocal]) .And. SD4->(Recno()) # aCols[n,Len(aHeader)])
				Help(" ",1,"MA380JACAD")
				lRet := .F.
			ElseIf SD4->(Recno()) # aCols[n,Len(aHeader)] .and. ( ( SD4->D4_QUANT > 0 .AND. aCols[nX,nPosQuant] < 0) .OR. ( SD4->D4_QUANT < 0 .AND. aCols[nX,nPosQuant] > 0) )   
				Help(" ",1,"MA380JACAD")
				lRet := .F.
			EndIf
			
			SD4->(dbSkip())
		End
		*/
		
		//-- Analisa se ha itens duplicados na base com quantidade invertida//Chamado TSWHRI
		dbSeek(xFilial("SD4")+aCols[n,nPosCod]+cOP+aCols[n,nPosTRT])
		While lRet .And. !EOF() .And. SD4->(D4_FILIAL+D4_COD+D4_OP+D4_TRT) == xFilial("SD4")+aCols[n,nPosCod]+cOP+aCols[n,nPosTRT]
			If( (SD4->D4_LOTECTL==aCols[n,nPosLotCtl]) .AND. (SD4->D4_NUMLOTE==aCols[n,nPosLote]) .AND. (SD4->D4_OPORIG==aCols[n,nPosOporig]) .AND. (SD4->D4_LOCAL == aCols[n,nPosLocal]) .And. SD4->(Recno()) # aCols[n,Len(aHeader)])
				Help(" ",1,"MA380JACAD")
				lRet := .F.
			elseIf SD4->(Recno()) # aCols[n,Len(aHeader)] .and. ( ( SD4->D4_QUANT > 0 .AND. aCols[n,nPosQuant] < 0) .OR. ( SD4->D4_QUANT < 0 .AND. aCols[n,nPosQuant] > 0) )   
				Help(" ",1,"MA380JACAD")
				lRet := .F.
			EndIf
			
			SD4->(dbSkip())
		End					
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Nao permite alterar saldo original para qtd menor que a qtd ja requisitada ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lRet .And. Altera .And. lMT381SE
		dbSelectArea("SD4")
		dbSetOrder(1)
		If dbSeek(xFilial("SD4")+aCols[n,nPosCod]+cOP+aCols[n,nPosTRT]+aCols[n,nPosLotCtl]+aCols[n,nPosLote]+aCols[n,nPosLocal])
			While !EOF() .And. SD4->(D4_FILIAL+D4_COD+D4_OP+D4_TRT+D4_LOTECTL+D4_NUMLOTE+D4_LOCAL+D4_OPORIG) == ;
				xFilial("SD4")+aCols[n,nPosCod]+cOP+aCols[n,nPosTRT]+aCols[n,nPosLotCtl]+aCols[n,nPosLote]+aCols[n,nPosLocal]+aCols[n,nPosOporig]
				If ( (aCols[n,nPosQtdOri] < 0) .And. (aCols[n,nPosQuant] < aCols[n,nPosQtdOri]) ) .Or.;
				   ( (aCols[n,nPosQtdOri] > 0) .And. (aCols[n,nPosQtdOri] < aCols[n,nPosQuant]) )
					Help(" ",1,"A380AQTOR")
					lRet:=.F.
				ElseIf ( (aCols[n,nPosQuant]) < 0 .And. !lNegEstr )
					Help(" ",1,"A380ESTNGR")
					lRet:= .F.
				ElseIF lMT381SE 
					If (aCols[n,nPosQtdOri] - aCols[n,nPosQuant])<>(SD4->D4_QTDEORI-SD4->D4_QUANT)
						Help(" ",1,"A380BQTOR")
						lRet:=.F.
					EndIf
				EndIf
				SD4->(dbSkip())
			End
		Endif
		
		// Verificar se operação informada existe
		if lRet .And. SD4->(FieldPos('D4_ROTEIRO')) > 0
			dbSelectArea('SC2')
			SC2->(dbSetOrder(1))
			SC2->(dbSeek(xFilial('SC2')+cOP))
			
			
		   If !Empty(SC2->C2_ROTEIRO)
			   cRoteiro := SC2->C2_ROTEIRO
		   else
			   If !Empty(Posicione('SB1',1,xFilial('SB1')+SC2->C2_PRODUTO,'B1_OPERPAD'))
	     		   cRoteiro := SB1->B1_OPERPAD
			   Else
				   cRoteiro := StrZero(1, TamSX3("G2_CODIGO")[1])			
			   EndIf	
		   Endif		
			
			dbSelectArea('SHY')
			SHY->(dbSetOrder(1))
			if SHY->(dbSeek(xFilial('SHY')+cOP+cRoteiro))

				cTabOper := 'SHY'
			
				aOper := {}
				
				While SHY->(!EOF()) .AND. SHY->HY_OP == cOP .AND. SHY->HY_ROTEIRO == cRoteiro
			
					AADD(aOper, {SHY->HY_OPERAC, ''})
				
					SHY->(dbSkip())
				End
			
			Else
			
				dbSelectArea('SG2')
				SG2->(dbSetOrder(1))
				if SG2->(dbSeek(xFilial('SG2')+SC2->C2_PRODUTO+cRoteiro))

					cTabOper := 'SG2'
				
					aOper := {}
				
					While SG2->(!EOF()) .AND. SG2->G2_PRODUTO == SC2->C2_PRODUTO .AND. SG2->G2_CODIGO == cRoteiro
				
						AADD(aOper, {SG2->G2_OPERAC, SG2->G2_DESCRI})
					
						SG2->(dbSkip())
					End
				Endif
			EndIf
			//O "If nPosOperac > 0" serve para que não ocorra erro quando o campo D4_OPERAC seja tirado de uso
			If nPosOperac > 0
				If cTabOper == 'SHY'
					if !Empty(aCols[n, nPosOperac])
						DBSelectArea('SHY')
						SHY->(dbSetOrder(1))
						if !SHY->(dbSeek(xFilial('SHY')+cOP + cRoteiro + aCols[n,nPosOperac]))
							Help( ,, 'Help',,STR0037 + aCols[n,nPosCod], 1, 0 ) //"Operação informada não existe. Produto: "
							lRet:=.F.
						endif
					endif
				Else
					if !Empty(aCols[n,nPosOperac])
						dbSelectArea('SG2')
						SG2->(dbSetOrder(1))
						if !SG2->(dbSeek(xFilial('SG2')+SC2->C2_PRODUTO+cRoteiro+aCols[n,nPosOperac]))
							Help( ,, 'Help',,STR0037 + aCols[n,nPosCod], 1, 0 ) //"Operação informada não existe. Produto: "
							lRet:=.F.
						EndIf
					Endif
				Endif
			EndIf
		EndIf

		If lRet .And. IntWms(aCols[n,nPosCod])
			SD4->(dbGoTo(aCols[n,Len(aHeader)]))
			For nX := 1 To Len(aHeader) - 2
				If Type("SD4->" +aHeader[nX,2]) # "U" .And. aCols[n,nX] # SD4->&(aHeader[nX,2])
					lRet := WmsAvalSD4("1",SD4->(Recno()))
					Exit
				EndIf
			Next nX
		EndIf
	EndIf

	//Valida se o produto a ser empenhado é igual ao produto original - não pode permitir 
	//devido Bloco K
	//O "If nPosPrdOri > 0" serve para que não ocorra erro quando o campo D4_PRDORG seja tirado de uso
	If nPosPrdOri > 0
		IF lRet .And. !Empty(aCols[n,nPosPrdOri]) .And. (aCols[n,nPosCod] == aCols[n,nPosPrdOri])
			Help( ,, 'Help',,STR0097, 1, 0 ) //"Produto Empenhado não pode ser o mesmo do Produto Origem."     
			lRet:=.F.
		EndIf
	EndIf	
ElseIf lRet
	If (aCols[n,nPosQuant] < aCols[n,nPosQtdOri])
		Help( ,, 'Help',,STR0022, 1, 0 ) //"Nao pode ser excluido um empenho que ja foi parcialmente baixado."
		lRet := .F.
	EndIf	
EndIf

//--Valida saldo por lote
If lRet .And. Rastro(aCols[n,nPosCod])
	//--Busca pelos dados anteriores em caso de alteracao
	
	For i:=1 to Len(aColsOri)
		// calcula quantidade válida em aCols
		If aColsOri[i,nPosCod] == aCols[n,nPosCod];
		   .And. aColsOri[i,nPosLocal] == aCols[n,nPosLocal];
		   .And. aColsOri[i,nPosLotCtl] == aCols[n,nPosLotCtl]
		    nQtdJaEmp+=aColsOri[i,nPosQtdOri]
		EndIf
	Next i
	
	dbSelectArea("SB8")
	If Rastro(aCols[n,nPosCod],"S")
		dbSetOrder(2)
		cSeek:=xFilial("SB8")+aCols[n,nPosLote]+aCols[n,nPosLotCtl]+aCols[n,nPosCod]+aCols[n,nPosLocal]
	Else
		dbSetOrder(3)
		cSeek:=xFilial("SB8")+aCols[n,nPosCod]+aCols[n,nPosLocal]+aCols[n,nPosLotCtl]
	EndIf
	If dbSeek(cSeek)
		If Rastro(aCols[n,nPosCod],"S")
			If SB8Saldo(Nil,lConsVenc,Nil,Nil,Nil,lEmpPrev)+nQtdJaEmp < aCols[n,nPosQuant]
				Help(" ",1,"MA380SALDO") //O Lote selecionado não possui saldo suficiente para este empenho.           
				lRet:=.F.                //Selecione outro lote ou diminua a quantidade do empenho. 
			EndIf
		Else
			If aCols[n,Len(aHeader)+1] == .F. // nao valida quantidade se o registro estiver deletado
			
				nSaldoCol:=0
				nSaldoColD:=0
				For i:=1 to Len(aCols)
					// calcula quantidade válida em aCols, desconsiderando o que já estava em banco
					If aCols[i,nPosCod] == aCols[n,nPosCod];
					   .And. aCols[i,nPosLocal] == aCols[n,nPosLocal];
					   .And. aCols[i,nPosLotCtl] == aCols[n,nPosLotCtl];
					   .And. aCols[i,Len(aHeader)+1] == .F.
						nSaldoCol+=aCols[i,nPosQtdOri]
					EndIf
				Next i
			
				If SaldoLote(aCols[n,nPosCod],aCols[n,nPosLocal],aCols[n,nPosLotCtl],Nil,Nil,lConsVenc)+nQtdJaEmp < nSaldoCol
					Help(" ",1,"MA380SALDO")//O Lote selecionado não possui saldo suficiente para este empenho.  
					lRet:=.F.               //Selecione outro lote ou diminua a quantidade do empenho.
				EndIf
			EndIf
		EndIf
	Else
		If (!Empty(aCols[n,nPosLotCtl]) .Or. !Empty(aCols[n,nPosLote])) .And. !GdDeleted()
			Help(" ",1,"A240LOTERR")
			lRet := .F.
		EndIf
	EndIf
	
	If l381 .And. Altera
		dbSelectArea("SD4")
		dbGoTo(aCols[n,Len(aHeader)])
		c381LotAnt := SD4->D4_NUMLOTE	
		c381CtlAnt := SD4->D4_LOTECTL
		c381DtOrig := SD4->D4_DTVALID
	EndIf

	If lRet .And. aCols[n,nPosLotCtl] != c381CtlAnt .And. aCols[n,nPosQuant] < aCols[n,nPosQtdOri] .AND. (INCLUI .OR. ALTERA) .AND. lMT381SE
		//Help( ,, 'Help',,STR0050, 1, 0 ) //
		Help(NIL, NIL, STR0021, NIL, STR0090, 1, 0, NIL, NIL, NIL, NIL, NIL, {STR0091})//"Atenção"###"Não é possível alterar o lote de um empenho com movimentação."###"Favor estornar a movimentação ou criar um novo registro para o lote, com o saldo restante do empenho."
		lRet := .F.
	EndIf
EndIf

//Atualização dos endereços quando for execução automática.
//Para não entrar em loop. Quando a a381LinOk é executada pela função a381Ender, a variável lVldD4DC é = .F.
//Para não executar com duplicidade. Quando a a381LinOk é executada pela função a381TudoOk, a variável lTudoOK é = .T.
If lRet .And. lVldD4DC .And. !lTudoOK .And. !GdDeleted() .And. Type('l381Auto') == "L" .And. l381Auto
	nPos := aScan(aHeader,{|x| AllTrim(x[2]) == "AUT_D4_END"})
	If nPos > 0
		//Verifica se foram enviados endereços para atualizar na SDC. Se sim, chama a função para atualizar.
		If aCols[n,nPos] != Nil .And. ValType(aCols[n,nPos]) == "A" .And. Len(aCols[n,nPos]) > 0
			lRet := a381Ender(aCols[n,nPos])
		EndIf
	EndIf
EndIf

//--Valida quantidades por endereco na alteracao
If lRet .And. lVldD4DC .And. !aCols[n,Len(aHeader)+1]
	If Localiza(aCols[n,nPosCod],.T.) .And. aCols[n,nPosQuant] > 0
		If aScan(aEnderecos, {|x| x[1] == n}) == 0 //caso nao tenha editado os enderecos
			nQtdD4 := aCols[n,nPosQuant]
			nQtdDC := 0
			dbSelectArea("SDC")
			dbSetOrder(2)
			dbSeek(xFilial("SDC")+aCols[n,nPosCod]+aCols[n,nPosLocal]+cOP+aCols[n,nPosTRT]+;
				aCols[n,nPosLotCtl]+aCols[n,nPosLote])
			While !EOF() .And. SDC->(DC_FILIAL+DC_PRODUTO+DC_LOCAL+DC_OP+DC_TRT+DC_LOTECTL+DC_NUMLOTE) == ;
				  xFilial("SDC")+aCols[n,nPosCod]+aCols[n,nPosLocal]+cOP+aCols[n,nPosTRT]+aCols[n,nPosLotCtl]+aCols[n,nPosLote]
				nQtdDC += SDC->DC_QUANT
				SDC->(dbSkip())
			End
			If nQtdDC > nQtdD4
				Help(" ",1,"MA381D4DC") //Os empenhos por endereços precisam ser ajustados de acordo com o novo saldo de empenho. 
				lRet := .F.             //Clique no botão "Endereços" e ajuste as quantidades por endereço.       
			EndIf
		EndIf
	EndIf
EndIf

If lRet .And. !aCols[n,Len(aCols[n])] .And. Localiza(aCols[n,nPosCod],.T.) .And. !Rastro(aCols[n,nPosCod])
	For nX := 1 To Len(aCols)
		If nX != n .And. !aCols[nX,Len(aCols[nX])]
			If AllTrim(aCols[n,nPosCod])+AllTrim(aCols[n,nPosLocal])+;
			   AllTrim(aCols[n,nPosTrt])+AllTrim(aCols[n,nPosLotCtl])+AllTrim(aCols[n,nPosLote])+AllTrim(aCols[n,nPosOPorig]) == ;// aCols[n,nPosOPorig] -> DMANSMARTSQUAD1-27396 - Validação incorreta - Empenho com a mesma sequência
			   AllTrim(aCols[nX,nPosCod])+AllTrim(aCols[nX,nPosLocal])+;
			   AllTrim(aCols[nX,nPosTrt])+AllTrim(aCols[nX,nPosLotCtl])+AllTrim(aCols[nX,nPosLote])+AllTrim(aCols[nX,nPosOPorig]) // aCols[nX,nPosOPorig] -> DMANSMARTSQUAD1-27396 - Validação incorreta - Empenho com a mesma sequência
				Help( ,, 'Help',, STR0042 + AlLTrim(aCols[nX,nPosCod]) + STR0043, 1, 0 ) //"Já existe um empenho do material '" XXX "' com a mesma sequência."
				lRet:=.F.
				Exit
			EndIf
		EndIf
	Next i
EndIf

// Se B1_TIPODEC = I e MV_REQNEC = S não permite alterar QTD caso tenha apontamento
If lRet
	lRet := A381AltQtd()
EndIf

//Validação para EXECAUTO. Campo de Data é inicializado com o dDataBase automaticamente.
If lRet .And. !GdDeleted() .And. Type('l381Auto') == "L" .And. l381Auto .And. Empty(aCols[n,nPosLotCtl]) .And. Empty(aCols[n,nPosLote]) .And. nPosDValid > 0
	aCols[n,nPosDValid] := StoD(" ")
EndIf


//Atualiza data de vencimento do lote, quando executado via rotina automática.
If l381Auto .And. !Empty(aCols[n,nPosLotCtl]) .And. nPosDValid > 0
	dbSelectArea("SB8")
	SB8->(dbSetOrder(3))
	If SB8->(dbSeek(xFilial("SB8")+aCols[n,nPosCod]+aCols[n,nPosLocal]+aCols[n,nPosLotCtl]+aCols[n,nPosLote]))
		If SB8->B8_DTVALID >= dDataBase
			aCols[n,nPosDValid] := SB8->B8_DTVALID
		EndIf
	EndIf	
EndIf



RestArea(aArea)
Return lRet


/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³A381Estru ³ Autor ³ Andre Anjos		    ³ Data ³ 29/04/08 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Importa para o aCols o 1o nivel da estrutura de um produto ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA381                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/                                                                     
Static Function A381Estru()
Local aArea := GetArea()
Local oDlg
Local cProd := CriaVar("B1_COD")
Local nQtde := 0
Local lOK := .F.
Local aEstrut := {}
Local nX := 0, nI := 0

Private nEstru := 0 //nao remover, utilizada na Estru() - SIGACUSB

Default lAutomacao := .F.

If !lAutomacao
	DEFINE MSDIALOG oDlg FROM 140,000 TO 280,270 TITLE OemToAnsi(STR0017) PIXEL //"Informe um produto com estrutura"
	@ 0.9,01 SAY OemToAnsi(STR0018) SIZE 15,10 OF oDlg//Produto
	@ 2.1,01 SAY OemToAnsi(STR0019) SIZE 10,10 OF oDlg//Quantidade
	@ 10,45 MSGET cProd F3 "SG1" Picture PesqPict("SD4","D4_COD") Valid (NaoVazio(cProd) .And. ExistCpo("SG1",cProd)) SIZE 70,9 OF oDlg PIXEL HASBUTTON
	@ 25,45 MSGET nQtde Picture PesqPict("SD3","D3_QUANT") Valid (Positivo(nQtde) .And. NaoVazio(nQtde)) SIZE 60,9 OF oDlg PIXEL HASBUTTON
	DEFINE SBUTTON FROM 50,63 TYPE 1 ACTION (lOK := .T.,oDlg:End()) ENABLE OF oDlg
	DEFINE SBUTTON FROM 50,90 TYPE 2 ACTION (lOk := .F.,oDlg:End()) ENABLE OF oDlg
	ACTIVATE MSDIALOG oDlg CENTERED
EndIf 
If lOK
	A381Explod(cProd,nQtde,@aEstrut)
	
	// Se a primeira linha esta em branco remove a mesma do acols
	If Empty(aCols[1,nPosCod])
		aDel(aCols,1)
		aSize(aCols,Len(aCols)-1)
	EndIf

	For nX := 1 to Len(aEstrut)
		// Adiciona item no acols
		AADD(aCols,Array(Len(aHeader)+1))
		//preenche acols com valores iniciais
		For nI:=1 to Len(aHeader)
			cCampo:=Alltrim(aHeader[nI,2])
			If IsHeadRec(cCampo)
				aCols[Len(aCols)][nI] := 0
			ElseIf IsHeadAlias(cCampo)
				aCols[Len(aCols)][nI] := "SD3"			
			Else
				aCols[Len(aCols)][nI] := CriaVar(cCampo,.F.)
			EndIf
		Next nI
		aCOLS[Len(aCols)][Len(aHeader)+1] := .F. //remove marca de delete
		
		// Preenche campos com dados da estrutura
		SB1->(dbSetOrder(1))
		SB1->(dbSeek(xFilial("SB1")+aEstrut[nX,3]))
		GDFieldPut("D4_COD",aEstrut[nX,3],Len(aCols))
		GDFieldPut("D4_LOCAL",RetFldProd(SB1->B1_COD,"B1_LOCPAD"),Len(aCols))
		GDFieldPut("D4_QTDEORI",aEstrut[nX,4],Len(aCols))
		GDFieldPut("D4_QUANT",aEstrut[nX,4],Len(aCols))
		GDFieldPut("D4_TRT",aEstrut[nX,5],Len(aCols))
		GDFieldPut("D4_DATA",dDataBase,Len(aCols))
		GDFieldPut("D4_DTVALID",dDataBase,Len(aCols))
		GDFieldPut("D4_QTSEGUM",ConvUM(aEstrut[nX,3],aEstrut[nX,4],0,2),Len(aCols))
		// Executa gatilhos para os campos preenchidos
		If ExistTrigger("D4_COD")
			RunTrigger(2,Len(aCols),,"D4_COD")
		EndIf
		If ExistTrigger("D4_LOCAL")
			RunTrigger(2,Len(aCols),,"D4_LOCAL")
		EndIf
		If ExistTrigger("D4_QTDEORI")
			RunTrigger(2,Len(aCols),,"D4_QTDEORI")
		EndIf
		If ExistTrigger("D4_QUANT")
			RunTrigger(2,Len(aCols),,"D4_QUANT")
		EndIf
		If ExistTrigger("D4_TRT")
			RunTrigger(2,Len(aCols),,"D4_TRT")
		EndIf
		
		If aEstrut[nX,4] == 0
			aCOLS[Len(aCols)][Len(aHeader)+1] := .T. //marca de delete
		EndIf		
	Next nX
EndIf

RestArea(aArea)
Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡ao    ³A381Explod³ Autor ³Andre Anjos		     ³ Data ³30/04/2008³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡ao ³ Funcao recursiva para localizar todos os componentes do 	   ³±±
±±³          ³ primeiro nivel da estrutura.							 	   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Codigo do Produto Pai                               ³±±
±±³          ³ ExpN1 = Quantidade do produto Pai                           ³±±
±±³          ³ ExpA1 = aArray de retorno                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA381                                                     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function A381Explod(cProduto,nQuant,aNewStruct)
Local aArea := GetArea()
Local aArrayAux := {}
Local nX := 0

//Variavel publica declarada na funcao A381Estru()
nEstru := 0

aArrayAux := Estrut(cProduto,nQuant,.T.)

dbSelectArea("SB1")
dbSetOrder(1)

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//| Processa todos os componentes do 1 nivel da estrutura,  |
//| verificando a existencia de produtos fantasmas.			|
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
For nX := 1 to Len(aArrayAux)
	If dbSeek(xFilial("SB1")+aArrayAux[nx,3]) //Filial+Componente
		If RetFldProd(SB1->B1_COD,"B1_FANTASM") $ "S" // Projeto Implementeacao de campos MRP e FANTASM no SBZ
			A381Explod(aArrayAux[nx,3],aArrayAux[nx,4],aNewStruct) //Componente+Qtde
		Else
			//Foi adicionada a linha abaixo para que não de divergência do aCols com o saldo (B8_SALDO),
			//devido a divergências de casas decimais - Issue DMANSMARTSQUAD1-17165
			aArrayAux[nx][4] := Round(aArrayAux[nx][4] , X3Decimal("D4_QUANT") )
			aAdd(aNewStruct,aArrayAux[nx])
		EndIf
	EndIf
Next nX

RestArea(aArea)
Return Nil

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³ SHOWF4   ³ Autor ³ Andre Anjos			³ Data ³13/06/2008³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Chamada da funcao F4LOTE                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA381                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function ShowF4()
If ReadVar() == "M->DC_LOCALIZ"
//	Set Key VK_F5 To
//	Set Key VK_F6 To
	F4Localiz(,,,"A381", cEndProd, cEndAlmo,, ReadVar())
//	Set Key VK_F5 To a381Estru()
//	Set Key VK_F6 To a381Ender()
ElseIf ReadVar() == "M->D4_NUMLOTE" .Or. ReadVar() == "M->D4_LOTECTL"
//	Set Key VK_F5 To
//	Set Key VK_F6 To
	F4Lote(,,,"A381",aCols[n,nPosCod],aCols[n,nPosLocal])
//	Set Key VK_F5 To a381Estru()
//	Set Key VK_F6 To a381Ender()
ElseIf ReadVar() == "M->D4_COD"
	MaViewSB2(aCols[n,nPosCod])
EndIf
Return Nil

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³ SHOWF5   ³ Autor ³ Andre Anjos			³ Data ³13/06/2008³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Chamada da funcao a381Estru                                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA381                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function ShowF5()

//--Valida se esta em inclusao ou alteracao e se o aHeader e do D4
If (l381Inc .Or. l381Alt) .And. (Substr(aHeader[1][2],1,2) == "D4")
	Set Key VK_F5 To
	A381Estru()
	Set Key VK_F5 To ShowF5()
EndIf

Return Nil

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³ SHOWF6   ³ Autor ³ Andre Anjos			³ Data ³13/06/2008³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Chamada da funcao A381Ender                                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA381                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function ShowF6()

//--Valida se o aHeader e do D4
If Substr(aHeader[1][2],1,2) == "D4"
	A381Ender() 
EndIf

Return Nil

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³ SHOWF7   ³ Autor ³ TOTVS					³ Data ³17/11/2010³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Chamada da funcao A381ZEmp	                              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA381                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function ShowF7()

//--Valida se esta em alteracao e se o aHeader e do D4
If l381Alt .And. Substr(aHeader[1][2],1,2) == "D4"
	Set Key VK_F7 To
	A381ZEmp()
	Set Key VK_F7 To ShowF7()
EndIf

Return Nil

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³a381VerAlt³ Autor ³ Andre Anjos		    ³ Data ³27/05/2008³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Funcao que trava a alteracao de campos                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA381                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function A381VerAlt()
Local aArea  := GetArea()
Local lRet   := .T.
Local cCampo := Substr(ReadVar(),4,Len(ReadVar()))
Local nPosVer:= 0
Local lVld   := .T.

Default lAutomacao := .F.

If !lAutomacao 
	If aCols[n,Len(aHeader)] == 0
		Return lRet
	EndIf
Endif 

Do Case
	Case cCampo == "D4_COD"
		nPosVer := nPosCod
	Case cCampo == "D4_LOCAL"
		nPosVer := nPosLocal
		lVld := !Empty(SC2->C2_QUJE)
	Case cCampo == "D4_TRT" 
		nPosVer := nPosTRT
	Case cCampo == "D4_LOTECTL"
		nPosVer := nPosLotCtl
		lVld := Localiza(aCols[n,nPosCod],.T.) .And. !Empty(SC2->C2_QUJE)
	Case cCampo == "D4_NUMLOTE"
		nPosVer := nPosLote
		lVld := Localiza(aCols[n,nPosCod],.T.) .And. !Empty(SC2->C2_QUJE)
EndCase

If l381Alt
	If lVld .And. cCampo $ "D4_COD*D4_LOCAL*D4_TRT*D4_LOTECTL*D4_NUMLOTE"
		dbSelectArea("SD4")
		dbGoTo(aCols[n,Len(aHeader)])
		If &("M->"+cCampo) != &("SD4->"+cCampo)
			Help(" ",1,"MA381ALTNO")
			lRet := .F.
		EndIf
	EndIf
EndIf

RestArea(aArea)
Return lRet
/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Programa  ³MenuDef   ³ Autor ³ Fabio Alves Silva     ³ Data ³04/10/2006³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Utilizacao de menu Funcional                               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Array com opcoes da rotina.                                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³Parametros do array a Rotina:                               ³±±
±±³          ³1. Nome a aparecer no cabecalho                             ³±±
±±³          ³2. Nome da Rotina associada                                 ³±±
±±³          ³3. Reservado                                                ³±±
±±³          ³4. Tipo de Transa‡„o a ser efetuada:                        ³±±
±±³          ³    1 - Pesquisa e Posiciona em um Banco de Dados           ³±±
±±³          ³    2 - Simplesmente Mostra os Campos                       ³±±
±±³          ³    3 - Inclui registros no Bancos de Dados                 ³±±
±±³          ³    4 - Altera o registro corrente                          ³±±
±±³          ³    5 - Remove o registro corrente do Banco de Dados        ³±±
±±³          ³5. Nivel de acesso                                          ³±±
±±³          ³6. Habilita Menu Funcional                                  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function MenuDef()
Private aRotina	:= {	{STR0001,"AxPesqui"   ,0,1,0 ,.F.},;//"Pesquisar"
						{STR0002,"A381Manut"  ,0,2,0 ,nil},;//"Visualizar"
						{STR0003,"A381Manut"  ,0,3,0 ,nil},;//"Incluir"
						{STR0004,"A381Manut"  ,0,4,37,nil},;//"Alterar"
						{STR0005,"A381Manut"  ,0,5,0 ,nil},;//"Excluir"
						{STR0006,"A381Legenda",0,2,0 ,nil}} //"Legenda"
						 
Private aRotinaAux := aRotina						

If GetSx3Cache("D4_OK", "X3_TAMANHO") > 0
	aAdd(aRotina, {STR0103,"A381LtEnd"  ,0,6,0 ,Nil}) //"Sugerir Lote/Endereço"
EndIf

If ExistBlock ("MA381MNU")
	aRotina := ExecBlock('MA381MNU',.F.,.F.,aRotina)
	If aRotina == Nil
		aRotina := aRotinaAux
	EndIf
EndIf           

Return (aRotina)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³A381ZEmp  ³ Autor ³TOTVS				     ³ Data ³ 17/11/10³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Zera empenhos											  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA381                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function A381ZEmp()

lZeraEmp2 := !lZeraEmp2
If !lZeraEmp2
	Aviso(STR0019,STR0030,{STR0028}) //"Aviso"###"Desativando a opcao para zerar o saldo empenhado"
ElseIf (Aviso(STR0019,STR0031,{STR0024,STR0025})==2) //"Aviso"###Deseja ativar a opcao para zerar o saldo empenhado para todos os produtos###"Sim"###"Nao"
	lZeraEmp2 := .F.
EndIf

Return
/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡ao    ³A381IntSFC ³ Autor ³ Aecio Ferreira Gomes    ³ Data ³30/04/11 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡ao ³Atualiza tabelas do SFC conforme modelagem dos dados(MVC)     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³A381IntSFC(ExpN1)                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpN1 = Rotina a ser processada(3-Inc, 4-Alt, 5-Exc)          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³MATA770                                                       ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/             
Static Function A381IntSFC(nOpc) 
Local aArea      := GetArea()	    // Salva area atual para posterior restauracao
Local aCampos 	 := {}			    // Array dos campos a serem atualizados
Local aCampos2	 := {}			    // Array dos campos a serem atualizados
Local aAux   	 := {}			    // Array auxiliar com o conteudo dos campos
Local cDescMP 	 := ""			 	// Descrição do Produto Materia Prima
Local cUM	  	 := ""			 	// Unidade de Medida do Item Materia Prima
Local cCodPA  	 := ""			 	// Código do Produto Pai
Local cDescPA 	 := ""			 	// Descrição do Produto Pai
Local cRoteiro   := "" 			 	// Roteiro de Opecaracao
Local cOperacao  := "" 			 	// operacao
Local cComp 	 := ""			  	// Codigo do componente localizado no array de dados da componente	
Local cSeqEstr   := ""			 	// Sequencia da estrutura localizada no array de dados da componente	
Local cNumOP	 := Alltrim(cOP)	// Numero da OP com Alltrim para comparacao com o numero da OP no SFC
Local lRet       := .T.			 	// Conteudo de retorno
Local lExclui 	 := nOpc == 5	 	// Identificador da operação de Exclusao do Protheus 
Local nInd    	 := 0			 	// Indexadora de laco For/Next
Local nPos   	 := 0	  		 	// Posicao de campo no array aCampos
Local nLOperac	 := 0			 	// Valida a situacao do retistro no aCols, 1= Novo 2= Alterado 3= Deletado
Local nx,nY    	 := 0			 	// Indexadora de laco For/Next
Local nPosProd   := 0			 	// Apresenta erro na tela, padrao de mensagem SFC
Local nPosSeq    := 0				// Sequendia da estrutura no array de dados do componente
Local oModel					  	// Objeto de modelo de dados
Local oAux				  		  	// Objeto auxiliar da modelo de dados
Local oStruct 			  		  	// Objeto da estrutura dos dados
Local lIntegra 	 := .F.				// Variavel de controle de integracao

// Variaveis utilizadas para localizar do item no acols do modelo de dados CYPDETAIL
Local aHDCYP		:= {}	// Aheader do modelo de dados  Detail CYPDETAIL
Local aColsCYP  	:= {}	// Acols do modelo de dados Detail CYPDETAIL
Local nPosProdSFC  	:= 0    // Posicao do Produto no acols
Local nPosTRTSFC    := 0    // Posicao da sequencia da estrutura no acols
Local nLine			:= 0	// Numero da linha da Grid modelo de dados Detail CYPDETAIL

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³As operaces de inclusao e exclusao do cadastro de empenhos serao consideradas como alteracao no SFC |
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
nOpc := 4

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Valida se a OP foi integrada ao SFC ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
CYQ->(dbSetOrder(1))	
lIntegra := CYQ->(dbSeek(xFilial('CYQ')+cOP))  

If lIntegra
	For nX := 1 to Len(aCols)
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Quando operacao de exclusao, sai do laco	³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If  lExclui
			Exit
		EndIf                           
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Quando o registro não existe na base e a linha do aCols esta deletada, nao considera ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If aCols[nX,Len(aCols[nX])] .And. aCols[nX,Len(aCols[nX])-1] == 0
			Loop
		EndIf 
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Verifica se o registro esta sendo Deletado, Incluso ou Alterado ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If aCols[nX,Len(aCols[nX])]
			nLOperac := 3 //Deletado
		ElseIf aCols[nX,Len(aCols[nX])-1] == 0
			nLOperac := 1 //Incluso		
		Else
			nLOperac := 2 //Alterado 	
		EndIf          
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Posiciona no cadastro produto MP para buscar descrição e unidade de medida³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		SB1->(DBSetOrder(1))
		If SB1->(DbSeek(xFilial("SB1")+aCols[nX,nPosCod]))
			cDescMP :=  SB1->B1_DESC
			cUM     :=  SB1->B1_UM
		EndIf
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Posiciona na OP para busca codigo do produto PAI³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		SC2->(DBSetOrder(1))
		If SC2->(DbSeek(xFilial("SC2")+cNumOP))
			cCodPA  :=  SC2->C2_PRODUTO
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Posiciona no cadastro do produto PAI para buscar descrição³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If SB1->(DbSeek(xFilial("SB1")+cCodPA))
				cDescPA :=  SB1->B1_DESC
			EndIf
		EndIf
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Busca roteiro de operacoes da OP ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		/*
		SHY->(dbSetOrder(1))
		SHY->(dbSeek(xFilial("SHY")+cNumOP))
		If !SHY->(dbSeek(xFilial("SHY")+HY_OP+HY_ROTEIRO+Replicate("z",TamSX3("G2_OPERAC")[1])))
			SHY->(dbSkip(-1))
		EndIf
		*/
		
		SHY->(dbSetOrder(1))
		SHY->(dbSeek(xFilial("SHY")+SC2->(C2_NUM+C2_ITEM+C2_SEQUEN+C2_ITEMGRD)))
		If !SHY->(dbSeek(xFilial("SHY")+SHY->(HY_OP+HY_ROTEIRO)+Replicate("z",TamSX3("G2_OPERAC")[1]),.T.))
			SHY->(dbSkip(-1))
		EndIf
		
		cRoteiro := SHY->HY_ROTEIRO
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Busca operacoes da OP ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		SGF->(dbSetOrder(2))  
		If SGF->(dbSeek(xFilial("SGF")+cCodPA+cRoteiro+aCols[nX,nPosCod]))
			cOperacao := SGF->GF_OPERAC
		Else                             
			cOperacao := SHY->HY_OPERAC
		EndIf
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Monta array com dados do Componente para atualizacao no SFC ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		aCampos := {} 
		
		aAdd(aCampos,{"CYP_NRORPO"	,padr(cNumOP,TamSX3("CYP_NRORPO")[1])})	//Ordem Producao
		aAdd(aCampos,{"CYP_CDMT"	,aCols[nX,nPosCod]	})	//Item Reserva   alterar tamanho pra 30
		aAdd(aCampos,{"CYP_DSMT" 	,cDescMP			})	//Item Descricao
		aAdd(aCampos,{"CYP_NRSQMT" 	,aCols[nX,nPosTRT]	})	//Sequencia na Estrutura
		aAdd(aCampos,{"CYP_CDACPI"	,cCodPA				})	//Item Pai
		aAdd(aCampos,{"CYP_DSACPI"	,cDescPA 			})	//Item Pai Descricao
		aAdd(aCampos,{"CYP_DTMT"	,aCols[nX,nPosData]	})  //Data Reserva
		aAdd(aCampos,{"CYP_CDUN"	,cUM				})  //Unidade Medida
		aAdd(aCampos,{"CYP_CDRT"	,cRoteiro			})  //Roteiro de operacao
		aAdd(aCampos,{"CYP_CDAT"	,cOperacao			})  //Operacao
		aAdd(aCampos,{"CYP_CDDP"	,aCols[nX,nPosLocal]})	//Deposito
		aAdd(aCampos,{"CYP_CDLO"	,aCols[nX,nPosLotCtl]})	//Lote/Serie
		aAdd(aCampos,{"CYP_QTMT"	,aCols[nX,nPosQtdOri]})	//Qtd Reserva
		aAdd(aCampos,{"CYP_QTRP"	,(aCols[nX,(nPosQtdOri)]-aCols[nX,(nPosQuant)])}) //Qtd Atendida
		aAdd(aCampos,{"CYP_TPST"    ,"1"			}) //Tipo
		aAdd(aCampos2,{aCampos, nLOperac}) //Monta Array de componentes adicionando os dados do componente + situacao do registro no acols
			
	Next nX
	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Instancia modelo de dados(Model) do cadastro de Ordem de Producao - SFC ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	oModel := FWLoadModel("SFCA100")
	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Atribui o numero da operacao a ser efetuada pelo Modelo ³
	//³3-Inclusao, 4-Alteracao, 5-Exclusao                     ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	oModel:SetOperation(nOpc)
	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Ativa o modelo de dados ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If (lRet := oModel:Activate()) // Ativa o modelo com os dados posicionados
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Instancia modelo de dados(Model) da Reseva da OP  ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		oAux := oModel:GetModel("CYPDETAIL")
		
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Monta array de acols e aheader com com base no modelo de dados Detail CYPDETAIL ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		aHDCYP		:= oAux:AHEADER	
	   	aColsCYP	:= oAux:ACOLS	
	
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Acha posicao dos campos produto e sequencia da estrutura no Header do modelo de dados  ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	   	nPosProdSFC := aScan(aHDCYP,{|aX| AllTrim(aX[2]) == "CYP_CDMT"})   
	   	nPosTRTSFC 	:= aScan(aHDCYP,{|aX| AllTrim(aX[2]) == "CYP_NRSQMT"}) 
	
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Obtem a estrutura de dados do Model ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		oStruct := oAux:GetStruct()
		aAux    := oStruct:GetFields()
	
		For nX := 1 to Len(aCampos2)
			aCampos:=aCampos2[nX][1] 
			nLOperac:=aCampos2[nX][2] 
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Verifica a posicao do codigo do item no array de componente³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			nPosProd := aScan(aCampos,{ |x| x[1] == "CYP_CDMT"})   // Posicao do componete no array
			nPosSeq  := aScan(aCampos,{ |x| x[1] == "CYP_NRSQMT"}) // Posicao do componete no array
			cComp	 := Alltrim(aCampos[nPosProd][2]) // Codigo do componete
			cSeqEstr := Alltrim(aCampos[nPosSeq][2])  // Sequencia da estrutura
			
			If  lExclui .Or. !lRet 
				Exit
			EndIf
		
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Adiciona linha no modelo ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If nLOperac == 1 
				If !Empty(aColsCYP[Len(aColsCYP)][nPosProdSFC]) //Verifica se a linha do modelo esta vazia 
					oAux:AddLine()
				EndIf
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Posiciona na linha do Grid ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			Else
				For nY:=1 To Len(aColsCYP)
					If	cComp+cSeqEstr == Alltrim(aColsCYP[nY][nPosProdSFC])+Alltrim(aColsCYP[nY][nPosTRTSFC])
						nLine:= nY
						Exit
					EndIf
				Next
				oAux:GoLine(nLine)
			EndIf
	
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Deleta linha da Grid quando acols estiver deletado ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If nLOperac == 3
				oAux:DeleteLine()
				Loop
			EndIf	
	
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Loop para validacao e atribuicao de dados dos campos do Model ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			For nInd := 1 To Len(aCampos)
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Valida os campos existentes na estrutura do Model ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If ( nPos := aScan(aAux,{|x| AllTrim(x[3]) ==  AllTrim(aCampos[nInd][1])})) > 0
			
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³Atribui os valores aos campos do Model caso passem pela validacao do formulario ³
					//³referente a tipos de dados, tamanho ou outras incompatibilidades estruturais.   ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If !(oModel:SetValue("CYPDETAIL",aCampos[nInd][1],aCampos[nInd][2]))
						lRet := .F.
						Exit       
					EndIf
				EndIf
			Next
		Next
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Deleta linha da Grid quando operacao de exclusao  ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	    If lRet .And. lExclui
	        For nX:=1 To Len(aColsCYP)
				oAux:GoLine(nX)
				oAux:DeleteLine()
	        Next                    
	    EndIf    
	Endif
	
	If lRet
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Valida os dados e integridade conforme dicionario do Model ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If ( lRet := oModel:VldData() )
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Efetiva gravacao dos dados na tabela ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	    	lRet := oModel:CommitData()
		EndIf
	EndIf
	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Desativa o Model ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	oModel:DeActivate()
	RestArea(aArea)
	
EndIf

Return lRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³ A381DelOK³ Autor ³ TOTVS					³ Data ³17/11/2010³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Valida exclusao de linha										³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA381                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function A381DelOK()
Local lRet := .T.

If !aCols[n,Len(aCols[n])] .And. IntWms(aCols[n,nPosCod]) 
	SD4->(dbGoTo(aCols[n,Len(aHeader)]))
	lRet := WmsAvalSD4("1",SD4->(Recno()))
EndIf

Return lRet

//-------------------------------------------------------------------
// consulta padrão para operação do componente
//-------------------------------------------------------------------
Function MATA381_SG2()
Local lRet      := .T.
Local nI        := 0
Local aOper     := {}
Local cRoteiro  := ""
Local oDlg, oLbx 
Local lDescOper := Iif( SHY->(FieldPos("HY_DESCRI")) > 0, .T., .F. )

If Type("cOp") == "U"
    Private cOp := M->D4_OP
EndIf

IF IsInCallStack('MATA380')
	cOP := M->D4_OP
ELSEIF  IsInCallStack('MATA650')
	cOP := cNumOP 
Endif


dbSelectArea('SC2')
SC2->(dbSetOrder(1))
if SC2->(dbSeek(xFilial('SC2')+cOP))

   If !Empty(SC2->C2_ROTEIRO)
	   cRoteiro := SC2->C2_ROTEIRO
   else
	   If !Empty(Posicione('SB1',1,xFilial('SB1')+SC2->C2_PRODUTO,'B1_OPERPAD')) 
   		   cRoteiro := SB1->B1_OPERPAD
	   Else
		   cRoteiro := StrZero(1, TamSX3("G2_CODIGO")[1])			
	   EndIf	
   Endif	

	// Verificar se existe SHY
	dbSelectArea('SHY')
	SHY->(dbSetOrder(1))
	if SHY->(dbSeek(xFilial('SHY')+cOP+cRoteiro))
	
		aOper := {}
		
		While SHY->(!EOF()) .AND. ALLTRIM(SHY->HY_OP) == ALLTRIM(SC2->(C2_NUM + C2_ITEM + C2_SEQUEN)) .AND. SHY->HY_ROTEIRO == cRoteiro
			If lDescOper
				AADD(aOper, {SHY->HY_OPERAC, SHY->HY_DESCRI})
			Else
				AADD(aOper, {SHY->HY_OPERAC, Posicione('SG2',1,xFilial('SC2')+SC2->C2_PRODUTO+cRoteiro+SHY->HY_OPERAC,'G2_DESCRI')})
			EndIf
			SHY->(dbSkip())
		End
	Else
	
		dbSelectArea('SG2')
		SG2->(dbSetOrder(1))
		if SG2->(dbSeek(xFilial('SG2')+SC2->C2_PRODUTO+cRoteiro))
		
			aOper := {}
		
			While SG2->(!EOF()) .AND. SG2->G2_PRODUTO == SC2->C2_PRODUTO .AND. SG2->G2_CODIGO == cRoteiro
		
				AADD(aOper, {SG2->G2_OPERAC, SG2->G2_DESCRI})
			
				SG2->(dbSkip())
			End
		Endif
	Endif
	
	if Len(aOper) > 0
		DEFINE MSDIALOG oDlg TITLE STR0038 FROM 0,0 TO 240,500 PIXEL // 'Operações'
				
			//Codigo, Descrição
			@ 10,10 LISTBOX oLbx FIELDS HEADER STR0039, STR0040 SIZE 230,90 OF oDlg PIXEL // 'Operação' ## 'Descrição'
		
			oLbx:SetArray( aOper )
			oLbx:bLine      := {|| {aOper[oLbx:nAt,1], aOper[oLbx:nAt,2]}}
			oLbx:bLDblClick := {|| {oDlg:End(), VAR_IXB := oLbx:aArray[oLbx:nAt,1]}}
		
			DEFINE SBUTTON FROM 105,213 TYPE 1 ACTION (oDlg:End(), lRet := .T., VAR_IXB := oLbx:aArray[oLbx:nAt,1])  ENABLE OF oDlg
			
		ACTIVATE MSDIALOG oDlg CENTER
	Endif
Endif

Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} IntegPPI()
Realiza a integração com o PCFactory, atualizando os empenhos alterados.

@author  Lucas Konrad França
@version P12
@since   18/09/2015
@return  lRet
/*/
//-------------------------------------------------------------------
Static Function IntegPPI()
   Local lRet       := .T.
   Local aArea      := GetArea()   
   Local nI         := 0
   Local lAlteraBkp := Altera
   Local lIncluiBkp := Inclui
   Local cMsg       := ""
   
   Private aIntegPPI := {}
	Default lAutomacao := .F.

   Altera := .T.
   Inclui := .F.

   dbSelectArea("SC2")
   SC2->(dbSetOrder(1))
   If SC2->(dbSeek(xFilial("SC2")+AllTrim(cOP)))
      aIntegPPI := {}
	  If !lAutomacao 
      	lRet := mata650PPI(, , .T., .T., .F.)
	  EndIf		  
      If Len(aIntegPPI) > 0
         cMsg := STR0044 + AllTrim(cOP) + ; //"Não foi possível realizar a integração com o TOTVS MES para a ordem de produção '"
                 STR0045 + CHR(10)      + ; //"'. Foi gerada uma pendência de integração para esta ordem de produção."
                 STR0046 + AllTrim(aIntegPPI[1,2]) //"Erro: " 
         Help( ,, 'Help',, cMsg, 1, 0 )
      EndIf
   EndIf
   Altera := lAlteraBkp
   Inclui := lIncluiBkp
   RestArea(aArea)
Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} A381AtuNec
Função para recalcular a quantidade necessária do componente

@param cOP, cQtOP
@return Nil

@author  Michele Girardi
@version P12
@since   10/05/2018
/*/
//-------------------------------------------------------------------
 Function A381AtuNec(cOP, cQtOP)
 Local lReqNec   := (SUPERGETMV("MV_REQNEC", .F., "N") == "S")
 Local aAreaSB1  := GetArea()
 Local aCalc     := {}
 Local nQtNeces  := 0
 Local nAchouSD4
 Local nAchouAlt
 Local i
 
 If Type("aAltQtd") == "U"
 	Return Nil 
 EndIf
 
 If !(SD4->(FieldPos('D4_QTNECES')) > 0)
	Return Nil
 EndIf
 
 If lReqNec
 	dbSelectArea("SD4")
	dbSetOrder(2) 
	dbGoTop()
	dbSeek(xFilial("SD4")+cOP)
	While !EOF() .And. SD4->(D4_FILIAL+D4_OP) == xFilial("SD4")+cOP
		If SB1->(dbSeek(xFilial("SB1")+SD4->D4_COD))		
		    nAchouAlt := ASCAN(aAltQtd,{ |x| x[1] == SD4->D4_COD .And. x[2] == SD4->D4_TRT }) //Verifica se o componente teve alteração de quantidade
			If nAchouAlt > 0
				nAchouSD4 := ASCAN(aCalc,{ |x| x[1] == SD4->D4_COD .And. x[2] == SD4->D4_TRT })
			
				If nAchouSD4 == 0
					If SB1->B1_TIPODEC == "I"
						AADD(aCalc,{SD4->D4_COD, SD4->D4_TRT, SD4->D4_QTDEORI, .T.})
					Else
						AADD(aCalc,{SD4->D4_COD, SD4->D4_TRT, 0, .F.})
					EndIf
				Else
					If SB1->B1_TIPODEC == "I"
						aCalc[nAchouSD4,3] += SD4->D4_QTDEORI
					EndIf
				EndIf
			Else
				nAchouSD4 := ASCAN(aCalc,{ |x| x[1] == SD4->D4_COD .And. x[2] == SD4->D4_TRT })			
				If nAchouSD4 == 0
					AADD(aCalc,{SD4->D4_COD, SD4->D4_TRT, 0, .F.})
				EndIf
			EndIf
		EndIf			
		SD4->(dbSkip())
	End
	
	dbSelectArea("SD4")
	dbSetOrder(2) 
	dbGoTop()
	dbSeek(xFilial("SD4")+cOP)
	While !EOF() .And. SD4->(D4_FILIAL+D4_OP) == xFilial("SD4")+cOP 
		nAchouSD4 := ASCAN(aCalc,{ |x| x[1] == SD4->D4_COD .And. x[2] == SD4->D4_TRT .And. x[4] == .T. })
		
		If nAchouSD4 > 0
			nQtNeces := aCalc[nAchouSD4,3] / cQtOP
			RecLock("SD4",.F.)
			Replace D4_QTNECES With nQtNeces
			MsUnLock()
		EndIF
		
		SD4->(dbSkip())
	End
 EndIf
 
 RestArea(aAreaSB1)
 Return Nil
 
 //-------------------------------------------------------------------
/*/{Protheus.doc} A381AltQtd
Função para verificar se é permitido alterar quantidade do empenho

@param 
@return lRet

@author  Michele Girardi
@version P12
@since   10/05/2018
/*/
//-------------------------------------------------------------------
 Static Function A381AltQtd()
 Local lRet := .T.
 Local lReqNec  := (SUPERGETMV("MV_REQNEC", .F., "N") == "S")
 Local aAreaSB1 := GetArea()
 Local nAchouAlt := 0
 
 If Type("aAltQtd") == "U"
 	Return lRet  
 EndIf
 
 If lReqNec
 	If SB1->(dbSeek(xFilial("SB1")+aCols[n,nPosCod]))
 		If SB1->B1_TIPODEC == "I"
 			dbSelectArea("SD4")
 			dbSetOrder(1)
 			If dbSeek(xFilial("SD4")+aCols[n,nPosCod]+cOP+aCols[n,nPosTRT]+aCols[n,nPosLotCtl]+aCols[n,nPosLote])
 				While !EOF() .And. SD4->(D4_FILIAL+D4_COD+D4_OP+D4_TRT+D4_LOTECTL+D4_NUMLOTE+D4_OPORIG) == ;
 					xFilial("SD4")+aCols[n,nPosCod]+cOP+aCols[n,nPosTRT]+aCols[n,nPosLotCtl]+aCols[n,nPosLote]+aCols[n,nPosOporig]
 					
 					If (SD4->D4_QTDEORI > SD4->D4_QUANT) .And.;
 					 	(SD4->D4_QTDEORI != aCols[n,nPosQtdOri] .Or. SD4->D4_QUANT != aCols[n,nPosQuant])
 						lRet := .F.
 						Help(" ",1,"MA380ALTQTREQ") // Não é permitido alterar a quantidade do empenho para componente que possui requisição por quantidade necessária e que possui apontamento. 						
 						Exit
 					Else
 						If (SD4->D4_QTDEORI != aCols[n,nPosQtdOri] .Or. SD4->D4_QUANT != aCols[n,nPosQuant])
 							nAchouAlt := ASCAN(aAltQtd,{ |x| x[1] == SD4->D4_COD .And. x[2] == SD4->D4_TRT }) //Verifica se o componente teve alteração de quantidade
 							If nAchouAlt == 0
 								AADD (aAltQtd, {SD4->D4_COD, SD4->D4_TRT })
 							EndIf
 						EndIf
 					EndIf
 					SD4->(dbSkip())
 				End
 			Else
 				nAchouAlt := ASCAN(aAltQtd,{ |x| x[1] == aCols[n,nPosCod] .And. x[2] == aCols[n,nPosTrt] }) //Verifica se o componente teve alteração de quantidade
 				If nAchouAlt == 0
 					AADD (aAltQtd, {aCols[n,nPosCod], aCols[n,nPosTrt]})
 				EndIf
 			EndIf
 		EndIF
 	EndIf 
 EndIf
 
 RestArea(aAreaSB1)
 
 Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} VldCabAuto
Faz a validação da ordem de produção quando o programa é executado via MsExecAuto

@param nOpc	- Operação que está sendo executada (3-Inclusão/4-Alteração/5-Exclusão)
@return lRet

@author  Lucas Konrad França
@version P12
@since   18/09/2018
/*/
//-------------------------------------------------------------------
Static Function VldCabAuto(nOpc)
	Local cAutoCod		:= ''
	Local cAutoLocal	:= ''
	Local cAutoLtCtl	:= ''
	Local cAutoSubLt	:= ''	
	Local lConsVenc     := (SUPERGETMV("MV_LOTVENC", .F., "N") == "S")
	Local lRet			:= .T.
	Local nPos			:= 0
	Local nX			:= 0
	Local nTamOP		:= 0
	Local nAutoOp		:= 0
	Local nAutoLot   	:= 0
	Local nAutoDtVld 	:= 0
	Local nAutoCod   	:= 0
	Local nAutoLocal 	:= 0	
	Local nAutoSubLt 	:= 0
		
	//Somente valida se for inclusão. As outras operações não alteram a OP.
	If nOpc == 3
		nPos := aScan(aAutoCab,{|x| AllTrim(x[1]) == "D4_OP"})
		If nPos > 0
			cOp  := PadR(aAutoCab[nPos,2],Len(SD4->D4_OP))
			lRet := NaoVazio(cOP) .And. A381ValOP(cOP) .And. VldUser("D4_OP")
		Else
			lRet := .F.
			Help( ,, 'Help',,STR0057, 1, 0 ) //"Ordem de produção não informada."
		EndIf
	EndIf
	
	If lRet .And. aAutoItens != Nil
		nTamOP := Len(SD4->D4_OP)

		For nX := 1 To Len(aAutoItens)
			//Valida se o número da OP que foi informada nos empenhos é o mesmo que foi informado no cabeçalho.
			nAutoOp := aScan(aAutoItens[nX], {|x| AllTrim(x[1]) == "D4_OP"})
			If nAutoOp > 0
				If PadR(aAutoItens[nX,nAutoOp,2],nTamOP) != PadR(cOp,nTamOP)
					lRet := .F.
					Help( ,, 'Help',,STR0058 + cValToChar(nX) + STR0059, 1, 0 ) //"Ordem de produção informada na linha " ### " difere da ordem de produção que está sendo manipulada."
					Exit
				EndIf
			Else
				lRet := .F.
				Help( ,, 'Help',,STR0060 + cValToChar(nX), 1, 0 ) //"Ordem de produção não informada na linha: "
				Exit
			EndIf

			//Se houver lote, preenche a data de validade
			nAutoLot   := aScan(aAutoItens[nX], {|x| AllTrim(x[1]) == "D4_LOTECTL"})
			nAutoDtVld := aScan(aAutoItens[nX], {|x| AllTrim(x[1]) == "D4_DTVALID"})
			nAutoCod   := aScan(aAutoItens[nX], {|x| AllTrim(x[1]) == "D4_COD"})
			nAutoLocal := aScan(aAutoItens[nX], {|x| AllTrim(x[1]) == "D4_LOCAL"})
			nAutoSubLt := aScan(aAutoItens[nX], {|x| AllTrim(x[1]) == "D4_NUMLOTE"})

			If nAutoLot > 0 .and.;
				nAutoLot   > 0 .and.;
				nAutoDtVld > 0 .and.;
				nAutoCod   > 0 .and.;
				nAutoLocal > 0 .and.;
				nAutoSubLt > 0 .and.;
			 	!Empty(aAutoItens[nX,nAutoLot,2])				
				
				//busca o valor dos campos.
				cAutoCod   := aAutoItens[nX,nAutoCod,2] 
				cAutoLocal := aAutoItens[nX,nAutoLocal,2]				
				cAutoLtCtl := aAutoItens[nX,nAutoLot,2]
				cAutoSubLt := aAutoItens[nX,nAutoSubLt,2]
									
				dbSelectArea("SB8")
				SB8->(dbSetOrder(3))
				If SB8->(dbSeek(xFilial("SB8")+cAutoCod+cAutoLocal+cAutoLtCtl+cAutoSubLt))
					If SB8->B8_DTVALID >= dDataBase .or. lConsVenc
						aAutoItens[nX,nAutoDtVld,2] := SB8->B8_DTVALID					
					Else
						lRet := .F.
						//Lote vencido ## Data de validade do lote está menor que a data atual. ## Informar lote com data de validade superior ou igual a data de validade.
						Help(NIL, NIL,STR0094, NIL,STR0095, 1, 0, NIL, NIL, NIL, NIL, NIL, {STR0096})
					EndIf
				EndIf	
			EndIf

		Next nX
	EndIf

Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} A381GrvAgr
Faz a atualização dos dados do módulo SIGAAGR (tabela NLI), para quando existe integração com o PIMS

@param lExclusao	- Identifica se é exclusão de empenho.
@param cProduto		- Código do produto da SD4
@param cLocal		- Local de estoque da SD4
@param cOp			- Ordem de produção da SD4
@param cTrt			- Sequência da SD4
@param cLoteCtl		- Lote da SD4
@param cNumLote		- SubLote da SD4
@param aDadosAGR	- Array com os dados do AGR para gravar, com a seguinte estrutura:
					{
						{"NOME_CAMPO1",VALOR},
						{"NOME_CAMPO2",VALOR},
					}
@return Nil

@author  Lucas Konrad França
@version P12
@since   25/10/2018
/*/
//-------------------------------------------------------------------
Function A381GrvAgr(lExclusao, cProduto, cLocal, cOp, cTrt, cLoteCtl, cNumLote, aDadosAGR)
	Local lFound := .F.
	Local lLock  := .F.
	Local nCount := 0
	Local nPos   := 0
	Local aArea  := GetArea()

	If !AliasInDic("NLI")
		Return
	EndIf
	
	//Verifica se existem dados para serem gravados na tabela do AGR.
	If (aDadosAgr == Nil .Or. (aDadosAgr != Nil .And. Len(aDadosAgr) < 1) ) 
		If !lExclusao
			Return
		EndIf
	EndIf

	NLI->(dbSetOrder(1))
	lFound := NLI->(dbSeek(xFilial("NLI")+cOp+cProduto+cLocal+cTrt+cLoteCtl+cNumLote))

	If lExclusao
		If lFound
			RecLock("NLI",.F.,.T.)
			DbDelete()
			lLock := .T.
		EndIf
	ElseIf lFound 
		//Operação de atualização.
		RecLock("NLI",.F.)
		lLock := .T.
	Else
		//Operação de inclusão
		RecLock("NLI",.T.)
		lLock := .T.
		NLI->NLI_FILIAL := xFilial("NLI")
		NLI->NLI_CODPRO := cProduto
		NLI->NLI_LOCAL  := cLocal
		NLI->NLI_OP     := cOp
		NLI->NLI_TRT    := cTrt
		NLI->NLI_LOTCTL := cLoteCtl
		NLI->NLI_NUMLOT := cNumLote
	EndIf

	If !lExclusao
		For nCount := 1 To NLI->(FCount())
			If NLI->(Field(nCount)) $ "NLI_FILIAL|NLI_CODPRO|NLI_LOCAL|NLI_OP|NLI_TRT|NLI_LOTCTL|NLI_NUMLOT"
				//Não atualiza os campos da chave.
				Loop
			EndIf
			nPos := aScan(aDadosAGR,{|x| x[1]==NLI->(Field(nCount))})
			If nPos > 0
				NLI->(FieldPut(nCount, Iif( Valtype(aDadosAgr[nPos,2]) == "N", val(transform(aDadosAgr[nPos,2],X3Picture( aDadosAgr[nPos,1] ))), aDadosAgr[nPos,2] )))
			 	
			EndIf
		Next nCount
	EndIf
	
	If lLock
		NLI->(MsUnLock())
	EndIf
	RestArea(aArea)
Return

//-------------------------------------------------------------------
/*/{Protheus.doc} A381VerNLI
Mostra os dados do módulo SIGAAGR (tabela NLI), para quando existe integração com o PIMS

@return Nil

@author  Lucas Konrad França
@version P12
@since   25/10/2018
/*/
//-------------------------------------------------------------------

Function A381VerNLI()
	Local cProduto := aCols[n,nPosCod]
	Local cLocal   := aCols[n,nPosLocal]
	Local cTRT	   := aCols[n,nPosTRT]
	Local cLoteCtl := aCols[n,nPosLotCtl]
	Local cNumLote := aCols[n,nPosLote]
	Local nLinIt   := n

	If !NLI->(dbSeek(xFilial("NLI")+cOp+cProduto+cLocal+cTRT+cLoteCtl+cNumLote))
		Help( ,, 'Help',,STR0086, 1, 0 ) //Não existem informações complementares de lista de compras para este empenho
		Return
	Else
		AxVisual("NLI",NLI->(Recno()),2)
	EndIf
Return

/*/{Protheus.doc} a381Valid
	Valida se possui saldo no lote antes de efetivar as gravações. 
	@type  Static Function
	@author maiara cunhago
	@since 27/09/2022
	@version 1.0
	@param 
	@return lret, logico, se continua com a operação ou não.
	@example
	(examples)
	@see (links_or_references)
/*/
Static Function a381Valid()
Local aArea     := GetArea()
Local i         := 0
Local lConsVenc := GetMV('MV_LOTVENC')=='S'
Local lEmpPrev  := If(SuperGetMV("MV_QTDPREV")== "S",.T.,.F.)
Local lRet      := .T.
Local n         := 1
Local nQtdJaEmp := 0

For n:= 1 to len(acols)

	//--Valida saldo por lote
	If Rastro(aCols[n,nPosCod])
		//--Busca pelos dados anteriores em caso de alteracao
		nQtdJaEmp := 0 // DMANSMARTSQUAD1-27773
		
		For i:=1 to Len(aColsOri)
			// calcula quantidade válida em aCols
			If aColsOri[i,nPosCod] == aCols[n,nPosCod];
			.And. aColsOri[i,nPosLocal] == aCols[n,nPosLocal];
			.And. aColsOri[i,nPosLotCtl] == aCols[n,nPosLotCtl]
				nQtdJaEmp+=aColsOri[i,nPosQtdOri]
			EndIf
		Next i
		
		dbSelectArea("SB8")
		If Rastro(aCols[n,nPosCod],"S")
			SB8->(dbSetOrder(2))
			cSeek:=xFilial("SB8")+aCols[n,nPosLote]+aCols[n,nPosLotCtl]+aCols[n,nPosCod]+aCols[n,nPosLocal]
		Else
			SB8->(dbSetOrder(3))
			cSeek:=xFilial("SB8")+aCols[n,nPosCod]+aCols[n,nPosLocal]+aCols[n,nPosLotCtl]
		EndIf
		If SB8->(dbSeek(cSeek))
			If Rastro(aCols[n,nPosCod],"S")
				If SB8Saldo(Nil,lConsVenc,Nil,Nil,Nil,lEmpPrev)+nQtdJaEmp < aCols[n,nPosQuant]
					Help( ,,"MA380SALDO2",,STR0101, 1, 0, , , , , , {STR0102}) //O Lote selecionado não possui saldo suficiente para este empenho.           
					lRet:=.F.                                                  //Efetue uma nova alteração, selecione outro lote ou diminua a quantidade do empenho
				EndIf
			Else
				If aCols[n,Len(aHeader)+1] == .F. // nao valida quantidade se o registro estiver deletado
				
					nSaldoCol:=0
					nSaldoColD:=0
					For i:=1 to Len(aCols)
						// calcula quantidade válida em aCols, desconsiderando o que já estava em banco
						If aCols[i,nPosCod] == aCols[n,nPosCod];
						.And. aCols[i,nPosLocal] == aCols[n,nPosLocal];
						.And. aCols[i,nPosLotCtl] == aCols[n,nPosLotCtl];
						.And. aCols[i,Len(aHeader)+1] == .F.
							nSaldoCol+=aCols[i,nPosQtdOri]
						EndIf
					Next i
				
					If SaldoLote(aCols[n,nPosCod],aCols[n,nPosLocal],aCols[n,nPosLotCtl],Nil,Nil,lConsVenc)+nQtdJaEmp < nSaldoCol
						Help( ,,"MA380SALDO2",,STR0101, 1, 0, , , , , , {STR0102}) //O Lote selecionado não possui saldo suficiente para este empenho.           
						lRet:=.F.                                                  //Efetue uma nova alteração, selecione outro lote ou diminua a quantidade do empenho
					EndIf
				EndIf
			EndIf
		EndIf
		
		If l381 .And. Altera
			dbSelectArea("SD4")
			dbGoTo(aCols[n,Len(aHeader)])
			c381LotAnt := SD4->D4_NUMLOTE	
			c381CtlAnt := SD4->D4_LOTECTL
			c381DtOrig := SD4->D4_DTVALID
		EndIf

	EndIf
Next
	
RestArea(aArea)
Return lRet

/*/{Protheus.doc} A381LtEnd
Grava a sugestão do Lote/Endereço para o produto
@type Function
@author Breno Ferreira
@since 22/05/2025
@version P12
@param1 cAlias, Character, Alias dos campos da grid
@return Nil
/*/
Function A381LtEnd(cAlias)
	Local lApont    := .T.
	Local lConsest  := SuperGetMV("MV_CONSEST",.F.,"N") == 'S'
	Local oAbreTela := Nil

	//Valida se o parâmetro é S-Sim para sugerir Lote/Endereço
	If lConsest
		//Valida se a OP já foi apontada
		lApont := validApont(cAlias)
		If lApont
			oAbreTela := SugestaoLotesEnderecosMATA381():new()
			oAbreTela:AbreLtEnd(cAlias)

			oAbreTela:destroy()
		Else 
			Help(Nil,Nil,STR0113,Nil,STR0114, 1, 0, NIL, NIL, NIL, NIL, NIL, {""}) //"Ordem de produção já apontada", "Não é permitido realizar a sugestão de lote/endereço."
		EndIf
	Else 		
		Help(Nil,Nil,STR0110,Nil,STR0111, 1, 0, NIL, NIL, NIL, NIL, NIL, {STR0112}) //"Parâmetro", "Operação não permitida devido ao parâmetro MV_CONSEST", "Altere o parâmetro para utilizar esta operação."
	EndIf
Return

/*/{Protheus.doc} validApont
Valida se há apontamento na OP
@type Static Function
@author Breno Ferreira
@since 22/05/2025
@version P12
@param1 cAlias, Character, Alias dos campos da grid.
@return lApont, Logical, Se retornar .T. a OP não tem apontamento se for .F. tem apontamneto na OP.
/*/
Static Function validApont(cAlias)
	Local cAliasSD3 := ""
	Local cAliasSH6 := ""
	Local cQuerySD3 := ""
	Local cQuerySH6 := ""
	Local lApont    := .T.
	Local oApontSD3 := Nil
	Local oApontSH6 := Nil

	cQuerySH6 := " SELECT SH6.H6_OP, "
	cQuerySH6 +=        " SH6.H6_PRODUTO "
	cQuerySH6 +=   " FROM " + RetSqlName("SH6") + " SH6 "
	cQuerySH6 +=  " WHERE SH6.H6_FILIAL  = ? "
	cQuerySH6 +=    " AND SH6.H6_OP      = ? "
	cQuerySH6 +=    " AND SH6.D_E_L_E_T_ = ' ' "

	oApontSH6 := FwExecStatement():New(cQuerySH6)

	oApontSH6:SetString(1, xFilial("SH6"))
	oApontSH6:SetString(2, (cAlias)->D4_OP)

	cAliasSH6 := oApontSH6:OpenAlias()

	If (cAliasSH6)->(!Eof())
		lApont := .F.
	Else
		cQuerySD3 := " SELECT SD3.D3_COD, "
		cQuerySD3 +=        " SD3.D3_OP "
		cQuerySD3 +=   " FROM " + RetSqlName("SD3") + " SD3 "
		cQuerySD3 +=  " WHERE SD3.D3_FILIAL  = ? "
		cQuerySD3 +=    " AND SD3.D3_OP      = ? "
		cQuerySD3 +=    " AND SD3.D3_ESTORNO = ' ' "
		cQuerySD3 +=    " AND SD3.D_E_L_E_T_ = ' ' " 

		oApontSD3 := FwExecStatement():New(cQuerySD3)

		oApontSD3:SetString(1, xFilial("SD3"))
		oApontSD3:SetString(2, (cAlias)->D4_OP)

		cAliasSD3 := oApontSD3:OpenAlias()

		If (cAliasSD3)->(!Eof())
			lApont := .F.
		EndIf

		(cAliasSD3)->(DBCloseArea())
		oApontSD3:Destroy()
		FreeObj(oApontSD3)
	EndIf

	(cAliasSH6)->(DBCloseArea())
	oApontSH6:Destroy()
	FreeObj(oApontSH6)

Return lApont

