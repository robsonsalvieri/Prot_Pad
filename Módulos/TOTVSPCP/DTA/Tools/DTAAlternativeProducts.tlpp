#Include "TLPP-CORE.TH"
#Include "TOTVS.CH"
#Include "DTAALTERNATIVEPRODUCTS.CH"

/*/{Protheus.doc} DTAAlternativeProducts
Classe responsável pela ferramenta de busca dos produtos alternativos de um produto

@author lucas.franca/renan.roeder
@since 21/03/2025
@version P12
/*/
Class DTAAlternativeProducts
	Static Method getData(jFilters as Json) as Array
	Static Method loadTool() as Character
EndClass

/*/{Protheus.doc} loadTool
Método que faz a carga das propriedades das ferramentas disponíveis por esta classe. Alimenta as tabelas HZV/HZW.

@author lucas.franca/renan.roeder
@since 21/03/2025
@version P12
@return cErrorMessage, Character, Retorna a mensagem de erro caso a ferramenta não tenha sido criada
/*/
Method loadTool() as Character Class DTAAlternativeProducts
	Local cDescription  := ""  as Character
	Local cErrorMessage := ""  as Character
	Local cName         := ""  as Character
	Local cVersion      := ""  as Character
	Local oLoadTool     := Nil as Object

	cName    := "get_alternative_products"
	cVersion := "001"

	If DTALoad():toolIsUpdated(cName, cVersion)
		Return ""
	EndIf

	cDescription := STR0001 //"Fornece uma lista de produtos alternativos. Os produtos alternativos são os produtos que podem ser usados no lugar do produto principal. "
	oLoadTool := DTALoad():New()
	oLoadTool:setName(cName)
	oLoadTool:setClassName("DTAAlternativeProducts")
	oLoadTool:setDataMethod("getData")
	oLoadTool:setVersion(cVersion)
	oLoadTool:setDescription(cDescription)
	oLoadTool:setShortDescription(STR0003) //"Busca quais são os produtos alternativos de um produto"
	oLoadTool:setExample(I18N(STR0004, {"product_code"})) //"Quais são os produtos alternativos do produto '#1[product_code]#'?"
	oLoadTool:setExample(I18N(STR0005, {"product_code"})) //"O produto '#1[product_code]#' possui produtos alternativos?"
	oLoadTool:setStrict(.T.)
	oLoadTool:setGroup("product_information")
	oLoadTool:addParameter("product_code", "string", STR0006 + ". \n " + STR0007, .T.) //"Código do produto" //"O código do produto pode conter somente letras, somente números ou a combinação de caracteres, podendo ou não ter caracteres especiais. Exemplo: '00255141', 'BICICLETA', 'SKATE', 'SKT001', 'PRODUTO001'."
	oLoadTool:addGlossary("product_code"             , STR0006) //"Código do produto"
	oLoadTool:addGlossary("product_description"      , STR0008) //"Descrição do produto"
	oLoadTool:addGlossary("alternative_products_list", STR0009) //"Lista com os produtos alternativos"
	oLoadTool:addGlossary("conversion_type"          , STR0010) //"Tipo de conversão"
	oLoadTool:addGlossary("conversion_factor"        , STR0011) //"Fator de conversão"
	If !oLoadTool:createTool()
		cErrorMessage := oLoadTool:getErrorMessage()
	EndIf
	oLoadTool:Destroy()
Return cErrorMessage

/*/{Protheus.doc} getData
Busca os produtos alternativos de um produto. Para a busca, é obrigatório que seja enviado o filtro:
"product_code" - código do produto;

@author lucas.franca/renan.roeder
@since 21/03/2025
@version P12
@param 01 jFilters, Json, Filtros que serão aplicados para a busca das informações dos produtos alternativos
@return aReturn, Array, Array com os dados encontrados, sendo:
        aReturn[1] - Logical - Identifica se processou com sucesso a busca.
        aReturn[2] - Json    - Dados obtidos na busca ou mensagem de erro caso não consiga fazer a busca.
        aReturn[3] - Numeric - Status que representa o retorno (200 ok, 400 erro.)
/*/
Method getData(jFilters as Json) as Array Class DTAAlternativeProducts
	Local aReturn         := {}  as Array
	Local cAlias          := ""  as Character
	Local cContext        := ""  as Character
	Local cConversionType := ""  as Character
	Local jData           := Nil as Json

	If Empty(jFilters["product_code"])
		Return DTAUtils():APIErrorMessage(400, I18N(STR0012, {"product_code"})) //"Para realizar a busca dos produtos alternativos de um produto, o parâmetro '#1[product_code]#' deve ser informado."
	EndIf
	jFilters["product_code"] := Upper(PadR(jFilters["product_code"], GetSX3Cache("B1_COD", "X3_TAMANHO")))
	SB1->(dbSetOrder(1))
	If !SB1->(dbSeek(xFilial("SB1") + jFilters["product_code"]))
		Return DTAUtils():APIErrorMessage(400, I18N(STR0013, {RTrim(jFilters["product_code"])}))  //"O produto #1[product_code]# não existe. Informe um produto existente para realizar a pesquisa."
	EndIf

	cAlias := GetNextAlias()
	jData  := JsonObject():New()
	jData["product_code"             ] := RTrim(SB1->B1_COD)
	jData["product_description"      ] := RTrim(SB1->B1_DESC)
	jData["alternative_products_list"] := {}
	
	BeginSql Alias cAlias
		SELECT SGI.GI_PRODALT, SB1.B1_DESC, SGI.GI_TIPOCON, SGI.GI_FATOR
		  FROM %Table:SGI% SGI
		 INNER JOIN %Table:SB1% SB1
		    ON SB1.B1_FILIAL = %xFilial:SB1%
		   AND SB1.B1_COD    = SGI.GI_PRODALT
		   AND SB1.%NotDel%
		 WHERE SGI.GI_FILIAL  = %xFilial:SGI%
		   AND SGI.GI_PRODORI = %Exp:SB1->B1_COD%
		   AND SGI.%NotDel%
		 ORDER BY %Order:SGI,1%
	EndSql

	While (cAlias)->(!EoF())
		cConversionType := STR0014 //"Multiplicação"
		If (cAlias)->GI_TIPOCON == "D"
			cConversionType := STR0015 //"Divisão"
		EndIf

		aAdd(jData["alternative_products_list"], {"product_code": RTrim((cAlias)->GI_PRODALT)    ,;
		                                          "product_description": RTrim((cAlias)->B1_DESC),;
		                                          "conversion_type": cConversionType             ,;
		                                          "conversion_factor": (cAlias)->GI_FATOR        })
		(cAlias)->(dbSkip())
	End
	(cAlias)->(dbCloseArea())
	
	cContext := I18N(STR0016, {"product_code", "product_description", "product_code", "product_description"})  //"Quando apresentar as informações de um produto, sempre combine o '#1[product_code]#' e a '#2[product_description]#' em uma única frase, no seguinte formato: Produto: ['#3[product_code]#'] - ['#4[product_description]#']."
	cContext += " \n " + STR0017 //"Estas informações sempre devem ser exibidas em formato de tabela."
	cContext += " \n " + I18N(STR0018, {"alternative_products_list", RTrim(jFilters["product_code"])}) //"Se o atributo '#1[alternative_products_list]#' estiver vazio, significa que o produto '#2[product_code]#' não possui produtos alternativos."
	
	aReturn := {.T., {"context": cContext, "data": jData}, 200}
	jData   := Nil
Return aReturn
