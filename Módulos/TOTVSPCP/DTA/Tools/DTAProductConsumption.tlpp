#Include "TLPP-CORE.TH"
#Include "TOTVS.CH"
#Include "DTAProductConsumption.CH"

#DEFINE MAX_DATES 30

/*/{Protheus.doc} DTAProductConsumption
Classe responsável pela ferramenta de busca de consumo do produto no processo produtivo

@author lucas.franca/renan.roeder
@since 09/09/2025
@version P12
/*/
Class DTAProductConsumption
	Static Method getData(jFilters as Json) as Array
	Static Method loadTool() as Character
	Static Method getProductConsumption(cProduct as Character, dStartDate as Date, dEndDate as Date) as Json
EndClass

/*/{Protheus.doc} loadTool
Método que faz a carga das propriedades das ferramentas disponíveis por esta classe. Alimenta as tabelas HZV/HZW.

@author lucas.franca/renan.roeder
@since 09/09/2025
@version P12
@return cErrorMessage, Character, Indica se houve erro na carga da ferramenta
/*/
Method loadTool() as Character Class DTAProductConsumption
	Local cDescription  := ""  as Character
	Local cErrorMessage := ""  as Character
	Local cName         := ""  as Character
	Local cVersion      := ""  as Character
	Local oLoadTool     := Nil as Object

	cName    := "get_product_consumption"
	cVersion := "001"

	If DTALoad():toolIsUpdated(cName, cVersion)
		Return ""
	EndIf

	cDescription := STR0001 //"Fornece informações das quantidades requisitadas e devolvidas de um produto nas movimentações das ordens de produção em um determinado período."
	oLoadTool := DTALoad():New()
	oLoadTool:setName(cName)
	oLoadTool:setClassName("DTAProductConsumption")
	oLoadTool:setDataMethod("getData")
	oLoadTool:setVersion(cVersion)
	oLoadTool:setDescription(cDescription)
	oLoadTool:setShortDescription(STR0002) //"Busca quantidades requisitadas do produto nas ordens de produção"
	oLoadTool:setExample(I18N(STR0003, {"product_code"})) //"Quanto foi consumido do produto '#1[product_code]#' no mês passado?"
	oLoadTool:setExample(I18N(STR0004, {"start_date", "end_date", "product_code"})) //"No período de '#1[start_date]#' e '#2[end_date]#', qual a quantidade requisitada e devolvida do produto '#3[product_code]#'?"
	oLoadTool:setExample(I18N(STR0005, {"product_code", "start_date", "end_date"})) //"Em quais datas houve consumo do produto '#1[product_code]#' no período de '#2[start_date]#' e '#3[end_date]#'?"
	oLoadTool:setStrict(.T.)
	oLoadTool:setGroup("appointments")
	oLoadTool:addParameter("product_code", "string", STR0006 + ". \n " + STR0007, .T.) //"Código do produto" # "O código do produto pode conter somente letras, somente números ou a combinação de caracteres, podendo ou não ter caracteres especiais. Exemplo: '00255141', 'BICICLETA', 'SKATE', 'SKT001', 'PRODUTO001'."
	oLoadTool:addParameter("start_date"  , "string", STR0008, .T.) //"Filtro da data inicial para busca das movimentações de consumo e devolução do produto nas ordens de produção."
	oLoadTool:addParameter("end_date"    , "string", STR0009, .T.) //"Filtro da data final para busca das movimentações de consumo e devolução do produto nas ordens de produção."
	oLoadTool:addGlossary("product_code"              , STR0006) //"Código do produto"
	oLoadTool:addGlossary("product_description"       , STR0010) //"Descrição do produto"
	oLoadTool:addGlossary("product_unit_measure"      , STR0011) //"Unidade de medida do produto"
	oLoadTool:addGlossary("total_request_quantity"    , STR0012) //"Quantidade total requisitada"
	oLoadTool:addGlossary("total_return_quantity"     , STR0013) //"Quantidade total devolvida"
	oLoadTool:addGlossary("total_consumption_quantity", STR0014) //"Quantidade total consumida"
	oLoadTool:addGlossary("date_consumption_list"     , STR0015) //"Quantidade consumida agrupada por dia"
	oLoadTool:addGlossary("date"                      , STR0016) //"Data da movimentação"
	oLoadTool:addGlossary("request_quantity"          , STR0017) //"Quantidade requisitada na data"
	oLoadTool:addGlossary("return_quantity"           , STR0018) //"Quantidade devolvida na data"
	oLoadTool:addGlossary("consumption_quantity"      , STR0019) //"Quantidade consumida na data"
	If !oLoadTool:createTool()
		cErrorMessage := oLoadTool:getErrorMessage()
	EndIf
	oLoadTool:Destroy()
Return cErrorMessage

/*/{Protheus.doc} getData
Busca o consumo do produto nas ordens de produção em um período. Para a busca, é obrigatório que seja enviado o filtro:
"product_code" - código do produto;
"start_date" - data inicial;
"end_date" - data final;

@author lucas.franca/renan.roeder
@since 09/09/2025
@version P12
@param 01 jFilters, Json, Filtros que serão aplicados para a busca dos consumos do produto nas ordens de produção.
@return aReturn, Array, Array com os dados encontrados, sendo:
        aReturn[1] - Logical - Identifica se processou com sucesso a busca.
        aReturn[2] - Json    - Dados obtidos na busca ou mensagem de erro caso não consiga fazer a busca.
        aReturn[3] - Numeric - Status que representa o retorno (200 ok, 400 erro.)
/*/
Method getData(jFilters as Json) as Array Class DTAProductConsumption
	Local aReturn  := {}  as Array
	Local cContext := ""  as Character
	Local jData    := Nil as Json
	Local nCount   := 0   as Integer

	If Empty(jFilters["product_code"]) .Or. Empty(jFilters["start_date"]) .Or. Empty(jFilters["end_date"])
		Return DTAUtils():APIErrorMessage(400, I18N(STR0020, {"product_code", "start_date", "end_date"})) //"Para realizar a busca do consumo do produto nas ordens de produção no período, os argumentos '#1[PRODUTO]#', '#2[DATA_INICIO]#' e '#3[DATA_FIM]#' devem ser informados."
	EndIf
	jFilters["product_code"] := PadR(Upper(jFilters["product_code"]), GetSX3Cache("B1_COD", "X3_TAMANHO"))
	SB1->(dbSetOrder(1))
	If !SB1->(dbSeek(xFilial("SB1") + jFilters["product_code"]))
		Return DTAUtils():APIErrorMessage(400, I18N(STR0021, {RTrim(jFilters["product_code"])})) //"O produto #1[PRODUTO]# não existe. Informe um código de produto válido para realizar a pesquisa."
	EndIf
	If IsProdMod(jFilters["product_code"])
		Return DTAUtils():APIErrorMessage(400, I18N(STR0022, {RTrim(jFilters["product_code"])})) //"O produto #1[PRODUTO]# é de mão de obra, portanto, não é válido para realizar a pesquisa."
	EndIf

	jFilters["start_date"] := PCPConvDat(jFilters["start_date"], 1)
	If Empty(jFilters["start_date"])
		Return DTAUtils():APIErrorMessage(400, I18N(STR0023, {"start_date"})) //"Argumento '#1[ARGUMENTO]#' não é uma data válida. Informe uma data correta para realizar a pesquisa."
	EndIf
	jFilters["end_date"] := PCPConvDat(jFilters["end_date"], 1)
	If Empty(jFilters["end_date"])
		Return DTAUtils():APIErrorMessage(400, I18N(STR0023, {"end_date"})) //"Argumento '#1[ARGUMENTO]#' não é uma data válida. Informe uma data correta para realizar a pesquisa."
	EndIf
	
	jData  := DTAProductConsumption():getProductConsumption(jFilters["product_code"], jFilters["start_date"], jFilters["end_date"])
	nCount := Len(jData["date_consumption_list"])
	If nCount > MAX_DATES
		aSize(jData["date_consumption_list"], MAX_DATES)
		
		cContext := "### 'date_consumption_list':\n"
		cContext += "**"+STR0024+"**: " //"IMPORTANTE"
		cContext += I18N(STR0025, {nCount, "date_consumption_list", MAX_DATES}) //"Nas quantidades de consumo obtidas, ocorreram consumos em #1[quantidade]# datas distintas. A lista '#2[date_consumption_list]#' está limitada às primeiras #3[max_dates]# datas encontradas, e não é possível obter a lista completa das datas."
		cContext += "\n"
		cContext += "**"+STR0026+"**: " //REGRA
		cContext += I18N(STR0027, {"date_consumption_list"}) //"Quando o usuário realizar qualquer interação com a lista '#1[date_consumption_list]#', obrigatoriamente ele deve ser orientado que esta lista não possui todas as datas."
	EndIf

	aReturn := {.T., {"context": cContext, "data": jData}, 200}
	jData   := Nil
	jDates  := Nil
Return aReturn

/*/{Protheus.doc} getProductConsumption
Busca o consumo do produto nas ordens de produção em um período.

@author lucas.franca/renan.roeder
@since 09/09/2025
@version P12
@param 01 cProduct  , Character, Código do produto
@param 02 dStartDate, Date     , Data inicial para busca
@param 03 dEndDate  , Date     , Data final para busca
@return jConsumption, Json     , Dados de consumo obtidos na busca
/*/
Method getProductConsumption(cProduct as Character, dStartDate as Date, dEndDate as Date) as Json Class DTAProductConsumption
	Local aNames           := {}  as Array
	Local cAlias           := ""  as Character
	Local cQuery           := ""  as Character
	Local jConsumption     := Nil as Json
	Local jDateConsumption := Nil as Json
	Local nIndex           := 0   as Integer
	Local oQuery           := Nil as Object

	If SB1->(B1_FILIAL+B1_COD) != xFilial("SB1") + cProduct
		SB1->(dbSetOrder(1))
		SB1->(dbSeek(xFilial("SB1") + cProduct))
	EndIf
	
	jDateConsumption := JsonObject():New()
	jConsumption     := JsonObject():New()
	jConsumption["product_code"              ] := RTrim(cProduct)
	jConsumption["product_description"       ] := RTrim(SB1->B1_DESC)
	jConsumption["product_unit_measure"      ] := RTrim(SB1->B1_UM)
	jConsumption["total_request_quantity"    ] := 0
	jConsumption["total_return_quantity"     ] := 0
	jConsumption["total_consumption_quantity"] := 0
	jConsumption["date_consumption_list"     ] := {}

	cQuery := "SELECT "
	cQuery +=   "SD3.D3_CF, SD3.D3_QUANT, SD3.D3_EMISSAO "
	cQuery +=   "FROM " + RetSqlName("SD3") + " SD3 "
	cQuery +=  "WHERE SD3.D3_FILIAL = ? "
	cQuery +=    "AND SD3.D3_COD = ? "
	cQuery +=    "AND SD3.D3_EMISSAO BETWEEN ? AND ? "
	cQuery +=    "AND SD3.D_E_L_E_T_ = ' ' "
	cQuery +=    "AND SD3.D3_OP <> ' ' "
	cQuery +=    "AND SD3.D3_ESTORNO IN (' ', 'N') "
	cQuery +=    "AND (SD3.D3_CF LIKE 'RE%' OR SD3.D3_CF LIKE 'DE%') "

	oQuery := FwExecStatement():New()
	oQuery:setQuery(ChangeQuery(cQuery))
	oQuery:setString(1, xFilial("SD3"))
	oQuery:setString(2, cProduct)
	oQuery:setDate(  3, dStartDate)
	oQuery:setDate(  4, dEndDate)
	oQuery:setFields({"D3_CF", {"D3_QUANT", "N", GetSX3Cache("D3_QUANT", "X3_TAMANHO"), GetSX3Cache("D3_QUANT", "X3_DECIMAL")}, "D3_EMISSAO"})
	cAlias := oQuery:openAlias()
	oQuery:doTcSetField(cAlias)
	While (cAlias)->(!EoF())
		If !jDateConsumption:hasProperty((cAlias)->D3_EMISSAO)
			jDateConsumption[(cAlias)->D3_EMISSAO] := {"date": PCPConvDat((cAlias)->D3_EMISSAO, 5), "request_quantity": 0, "return_quantity": 0}
		EndIf
		If "RE" $ (cAlias)->D3_CF 
			jDateConsumption[(cAlias)->D3_EMISSAO]["request_quantity"] += (cAlias)->D3_QUANT
			jConsumption["total_request_quantity"] += (cAlias)->D3_QUANT
		Else
			jDateConsumption[(cAlias)->D3_EMISSAO]["return_quantity"] += (cAlias)->D3_QUANT
			jConsumption["total_return_quantity"] += (cAlias)->D3_QUANT
		EndIf
		(cAlias)->(dbSkip())
	End
	(cAlias)->(dbCloseArea())
	jConsumption["total_consumption_quantity"] := jConsumption["total_request_quantity"] - jConsumption["total_return_quantity"]

	aNames := jDateConsumption:getNames()
	aSort(aNames)
	For nIndex := 1 To Len(aNames)
		aAdd(jConsumption["date_consumption_list"], jDateConsumption[aNames[nIndex]])
		jConsumption["date_consumption_list"][nIndex]["consumption_quantity"] := jConsumption["date_consumption_list"][nIndex]["request_quantity"] - jConsumption["date_consumption_list"][nIndex]["return_quantity"]
		jDateConsumption[aNames[nIndex]] := Nil
	Next nIndex
	jDateConsumption := Nil
	aSize(aNames, 0)
	oQuery := Nil
Return jConsumption
