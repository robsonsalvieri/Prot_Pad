#Include "TLPP-CORE.TH"
#Include "TOTVS.CH"
#Include "DTAPRODUCTPRODUCEDQUANTITIES.CH"

#DEFINE MAX_ORDERS 20
#DEFINE MAX_DATES 30

/*/{Protheus.doc} DTAProductProducedQuantities
Classe responsável pela ferramenta de busca de informações de produção do produto

@author lucas.franca/renan.roeder
@since 21/01/2025
@version P12
/*/
Class DTAProductProducedQuantities
	Static Method getData(jFilters as Json) as Array
	Static Method loadTool() as Character
	Static Method getListOfQuantities(jData as Json) as Array
EndClass

/*/{Protheus.doc} loadTool
Método que faz a carga das propriedades das ferramentas disponíveis por esta classe. Alimenta as tabelas HZV/HZW.

@author lucas.franca/renan.roeder
@since 21/01/2025
@version P12
@return cErrorMessage, Character, Retorna a mensagem de erro caso a ferramenta não tenha sido criada
/*/
Method loadTool() as Character Class DTAProductProducedQuantities
	Local cDescription  := ""  as Character
	Local cErrorMessage := ""  as Character
	Local cName         := ""  as Character
	Local cRules        := ""  as Character
	Local cVersion      := ""  as Character
	Local oLoadTool     := Nil as Object

	cName    := "get_produced_quantities_by_product"
	cVersion := "004"

	If DTALoad():toolIsUpdated(cName, cVersion)
		Return ""
	EndIf

	cDescription := STR0001 //"Fornece informações detalhadas sobre as quantidades apontadas de produção e perda de um produto específico em um período específico."
	cDescription += " " + STR0002 //"Além disso, retorna uma lista das ordens de produção relacionadas a essas quantidades."
	cDescription += " " + STR0028 //"Também pode detalhar as produções e perdas de cada dia de um período."
	cRules := I18N(STR0003, {"product_code"}) //"Se o argumento '#1[product_code]#' não for informado pelo usuário, solicite a informação antes de realizar a pesquisa. "
	cRules += "\n " + I18N(STR0004, {"get_production_order_by_code", "appointed_orders"}) //"Se o agente desejar listar informações das ordens de produção que totalizam as quantidades, deve executar a ferramenta #1[get_production_order_by_code]# passando os códigos contidos na lista '#2[appointed_orders]#' como argumentos."
	oLoadTool := DTALoad():New()
	oLoadTool:setName(cName)
	oLoadTool:setClassName("DTAProductProducedQuantities")
	oLoadTool:setDataMethod("getData")
	oLoadTool:setVersion(cVersion)
	oLoadTool:setDescription(cDescription)
	oLoadTool:setShortDescription(STR0005) //"Busca as quantidades de produção e perda apontadas em um produto"
	oLoadTool:setExample(I18N(STR0006, {"product_code"})) //"Como foi a produção do produto '#1[product_code]#' ontem?"
	oLoadTool:setExample(I18N(STR0007, {"product_code"})) //"Quanto foi produzido do produto '#1[product_code]#' no mês passado?"
	oLoadTool:setExample(I18N(STR0008, {"product_code", "start_date", "end_date"})) //"Qual a quantidade de perda de produção do produto '#1[product_code]#' entre '#2[start_date]#' e '#3[end_date]#'?"
	oLoadTool:setRules(cRules)
	oLoadTool:setStrict(.T.)
	oLoadTool:setGroup("appointments")
	oLoadTool:addParameter("product_code", "string", STR0009 + ". \n " + STR0010 + " \n " + STR0011, .T.) //"Código do produto" //"O código do produto pode conter somente letras, somente números ou a combinação de caracteres, podendo ou não ter caracteres especiais. Exemplo: '00255141', 'BICICLETA', 'SKATE', 'SKT001', 'PRODUTO001'." //"Somente é aceito filtro por um código de produto específico, nunca sendo possível filtrar por uma lista de produtos, por uma expressão ou por parte do código do produto."
	oLoadTool:addParameter("start_date"  , "string", STR0012, .T.) //"Filtro da data inicial para busca da utilização do produto."
	oLoadTool:addParameter("end_date"    , "string", STR0013, .T.) //"Filtro da data final para busca da utilização do produto."
	oLoadTool:addGlossary("product_code"             , STR0009) //"Código do produto"
	oLoadTool:addGlossary("product_description"      , STR0014) //"Descrição do produto"
	oLoadTool:addGlossary("product_unit_measure"     , STR0015) //"Unidade de medida do produto"
	oLoadTool:addGlossary("daily_production_quantity", STR0026) //"Produção acumulada no dia"
	oLoadTool:addGlossary("daily_loss_quantity"      , STR0027) //"Perda acumulada no dia"
	oLoadTool:addGlossary("production_quantity"      , STR0016) //"Quantidade produzida"
	oLoadTool:addGlossary("loss_quantity"            , STR0017) //"Quantidade de perda na produção"
	oLoadTool:addGlossary("appointed_orders"         , STR0018) //"Lista com os códigos das ordens de produção apontadas no período"
	oLoadTool:addGlossary("date"                     , STR0029) //"Data"
	oLoadTool:addGlossary("quantity"                 , STR0030) //"Quantidade na data"
	If !oLoadTool:createTool()
		cErrorMessage := oLoadTool:getErrorMessage()
	EndIf
	oLoadTool:Destroy()
Return cErrorMessage

/*/{Protheus.doc} getData
Busca as quantidades produzidas de um produto em um período. Para a busca, é obrigatório que sejam enviados os filtros:
"product_code" - código do produto;
"start_date" - data inicial;
"end_date" - data final.

@author lucas.franca/renan.roeder
@since 21/01/2025
@version P12
@param 01 jFilters, Json, Filtros que serão aplicados para a busca das ordens.
@return aReturn, Array, Array com os dados encontrados, sendo:
        aReturn[1] - Logical - Identifica se processou com sucesso a busca.
        aReturn[2] - Json    - Dados obtidos na busca ou mensagem de erro caso não consiga fazer a busca.
        aReturn[3] - Numeric - Status que representa o retorno (200 ok, 400 erro.)
/*/
Method getData(jFilters as Json) as Array Class DTAProductProducedQuantities
	Local aReturn              := {}  as Array
	Local aOrders              := {}  as Array
	Local cContext             := ""  as Character
	Local jData                := Nil as Json
	Local jAppointmentQuantity := Nil as Json
	Local nCount               := 0   as Integer

	If Empty(jFilters["product_code"]) .Or. Empty(jFilters["start_date"]) .Or. Empty(jFilters["end_date"])
		Return DTAUtils():APIErrorMessage(400, I18N(STR0019, {"product_code", "start_date", "end_date"})) //"Para realizar a busca da produção do produto, os parâmetros '#1[product_code]#', '#2[start_date]#' e '#3[end_date]#' devem ser informados."
	EndIf

	jFilters["start_date"] := PCPConvDat(jFilters["start_date"], 1)
	If Empty(jFilters["start_date"])
		Return DTAUtils():APIErrorMessage(400, I18N(STR0020, {"start_date"})) //"Parâmetro '#1[start_date]#' não é uma data válida. Informe uma data correta para realizar a pesquisa."
	EndIf
	
	jFilters["end_date"] := PCPConvDat(jFilters["end_date"], 1)
	If Empty(jFilters["end_date"])
		Return DTAUtils():APIErrorMessage(400, I18N(STR0021, {"end_date"})) //"Parâmetro '#1[end_date]#' não é uma data válida. Informe uma data correta para realizar a pesquisa."
	EndIf

	jFilters["product_code"] := Upper(PadR(jFilters["product_code"], GetSX3Cache("B1_COD", "X3_TAMANHO")))
	SB1->(dbSetOrder(1))
	If !SB1->(dbSeek(xFilial("SB1") + jFilters["product_code"]))
		Return DTAUtils():APIErrorMessage(400, I18N(STR0022, {RTrim(jFilters["product_code"])})) //"O produto #1[product_code]# não existe. Informe um produto existente para realizar a pesquisa."
	EndIf

	jAppointmentQuantity := PCPMonitorUtils():RetornaQuantidadesProducaoProduto(cFilAnt, SB1->B1_COD, jFilters["start_date"], jFilters["end_date"])
	aOrders := jAppointmentQuantity["ORDENS_PRODUCAO"]:GetNames()
	nCount  := Len(aOrders)
	If nCount > 0
		aSort(aOrders)
		If nCount > MAX_ORDERS
			cContext += "### 'appointed_orders':\n"
			cContext += "**"+STR0031+"**: " //"IMPORTANTE"
			cContext += I18N(STR0032, {nCount, "appointed_orders", MAX_ORDERS}) //"Nas quantidades de produção obtidas, foram utilizadas #1[quantidade]# ordens de produção. A '#2[lista_ordens]#' está limitada às primeiras #3[max_orders]# ordens de produção encontradas, e não é possível obter a lista completa das ordens de produção."
			cContext += "\n"
			cContext += "**"+STR0033+"**: " //REGRA
			cContext += I18N(STR0034, {"appointed_orders"}) //"Quando o usuário realizar qualquer interação com a '#1[list_ordens]#', obrigatoriamente ele deve ser orientado que esta lista não possui todas as ordens de produção."
			cContext += "\n"
			aSize(aOrders, MAX_ORDERS)
		EndIf

		jData := JsonObject():New()
		jData["product_code"             ] := RTrim(SB1->B1_COD)
		jData["product_description"      ] := RTrim(SB1->B1_DESC)
		jData["product_unit_measure"     ] := RTrim(SB1->B1_UM)
		jData["daily_production_quantity"] := DTAProductProducedQuantities():getListOfQuantities(jAppointmentQuantity["PRODUCAO"])
		jData["daily_loss_quantity"      ] := DTAProductProducedQuantities():getListOfQuantities(jAppointmentQuantity["PERDA"])
		jData["production_quantity"      ] := jAppointmentQuantity["TOTAL_PRODUCAO"]
		jData["loss_quantity"            ] := jAppointmentQuantity["TOTAL_PERDA"]
		jData["appointed_orders"         ] := aOrders
		
		nCount := Len(jData["daily_production_quantity"])
		If nCount > MAX_DATES
			aSize(jData["daily_production_quantity"], MAX_DATES)
			aSize(jData["daily_loss_quantity"      ], MAX_DATES)
			cContext += "\n### " + I18N(STR0035, {"daily_production_quantity", "daily_loss_quantity"}) + "\n" //"'#1[LISTA1]#' e '#2[LISTA2]#':"
			cContext += "**"+STR0031+"**: " //"IMPORTANTE"
			cContext += I18N(STR0023, {nCount, "daily_production_quantity", "daily_loss_quantity", MAX_DATES}) //"Nas quantidades de produção obtidas, ocorreram apontamentos em #1[quantidade]# datas distintas. As listas '#2[daily_production_quantity]#' e '#3[daily_loss_quantity]#' estão limitadas às primeiras #4[max_dates]# datas encontradas, e não é possível obter a lista completa das datas."
			cContext += "\n"
			cContext += "**"+STR0033+"**: " //REGRA
			cContext += I18N(STR0024, {"daily_production_quantity", "daily_loss_quantity"}) //"Quando o usuário realizar qualquer interação com as listas '#1[daily_production_quantity]#' ou '#2[daily_loss_quantity]#', obrigatoriamente ele deve ser orientado que estas listas não possuem todas as datas de apontamento de produção e perda no período."
			cContext += "\n"
		EndIf
		
		aReturn := {.T., {"context": cContext, "data": jData}, 200}
	Else
		aReturn := DTAUtils():APIErrorMessage(400, I18N(STR0025, {RTrim(jFilters["product_code"])})) //"Não foram encontradas quantidades produzidas ou de perdas para o produto #1[product_code]# no período informado."
	EndIf

	FreeObj(jAppointmentQuantity)
	jData   := Nil
	aOrders := Nil
Return aReturn

/*/{Protheus.doc} getListOfQuantities
Recebe um JSON com chave=data e valor=quantidade, e retorna um array de objetos JSON contendo date e quantity.

@author lucas.franca/renan.roeder
@since 12/09/2025
@version P12
@param 01 jData, Json, Objeto json com a chave a ser alterada
@return aQuantities, Array, Array com as quantidades
/*/
Method getListOfQuantities(jData as Json) as Array Class DTAProductProducedQuantities
	Local aNames      := {} as Array
	Local aQuantities := {} as Array
	Local nIndex      := 0  as Integer

	aNames := jData:getNames()
	For nIndex := 1 To Len(aNames)
		aAdd(aQuantities, {"date": PCPConvDat(CtoD(aNames[nIndex]), 2), "quantity": jData[aNames[nIndex]]})
	Next nIndex
	aSort(aQuantities,,,{|x,y| x["date"] < y["date"]})
	aSize(aNames, 0)
Return aQuantities
