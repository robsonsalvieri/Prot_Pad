#Include "TLPP-CORE.TH"
#Include "TOTVS.CH"
#Include "DTAProductionOrder.ch"

#DEFINE BREAK_LINE "\n"
#DEFINE MAX_ORDERS 20

/*/{Protheus.doc} DTAProductionOrder
Classe responsável pela ferramenta de busca de informações da ordem de produção.

@author lucas.franca/renan.roeder
@since 21/01/2025
@version P12
/*/
Class DTAProductionOrder
	Static Method getDataByCode(jFilters as Json) as Array
	Static Method getDataList(jFilters as Json) as Array
	Static Method loadTool() as Character
	Static Method loadToolByCode() as Character
	Static Method loadToolByProduct() as Character
	Static Method setGeneralContext() as Character
EndClass

/*/{Protheus.doc} loadTool
Método que faz a carga das propriedades das ferramentas disponíveis por esta classe. Alimenta as tabelas HZV/HZW.

@author lucas.franca/renan.roeder
@since 21/01/2025
@version P12
@return cErrorMessage, Character, Indica se houve erro na carga da ferramenta
/*/
Method loadTool() as Character Class DTAProductionOrder
	Local cErrorMessage := "" as Character

	cErrorMessage := DTAProductionOrder():loadToolByCode()
	cErrorMessage += DTAProductionOrder():loadToolByProduct()
Return cErrorMessage

/*/{Protheus.doc} loadToolByCode
Configurações da ferramenta de busca das ordens por código da ordem.

@author lucas.franca/renan.roeder
@since 21/01/2025
@version P12
@return cErrorMessage, Character, Indica se houve erro na carga da ferramenta
/*/
Method loadToolByCode() as Character Class DTAProductionOrder
	Local cDescription  := ""  as Character
	Local cErrorMessage := ""  as Character
	Local cName         := ""  as Character
	Local cVersion      := ""  as Character
	Local oLoadTool     := Nil as Object

	cName    := "get_production_order_by_code"
	cVersion := "002"
	If DTALoad():toolIsUpdated(cName, cVersion)
		Return ""
	EndIf

	cDescription := STR0001 //"Fornece detalhes da ordem de produção incluindo informações como quantidade planejada, quantidade produzida, saldo para produzir, situação, datas de previsão de inicio, previsão de entrega e encerramento, além de informações cadastrais da ordem de produção."
	oLoadTool := DTALoad():New()
	oLoadTool:setName(cName)
	oLoadTool:setClassName("DTAProductionOrder")
	oLoadTool:setDataMethod("getDataByCode")
	oLoadTool:setVersion(cVersion)
	oLoadTool:setDescription(cDescription)
	oLoadTool:setShortDescription(STR0002) //"Consulta as informações de uma ordem de produção específica"
	oLoadTool:setExample(I18N(STR0003, {"production_order_code"})) //"Quais os detalhes da ordem de produção '#1[ORDEM]#'?"
	oLoadTool:setExample(I18N(STR0004, {"production_order_code"})) //"Quero informações sobre a op '#1[ORDEM]#'."
	oLoadTool:setExample(I18N(STR0005, {"production_order_code"})) //"Quais os dados da ordem '#1[ORDEM]#'?"
	oLoadTool:setExample(I18N(STR0051, {"production_order_code"})) //"Qual a situação da ordem de produção '#1[ORDEM]#'?"
	oLoadTool:setStrict(.T.)
	oLoadTool:setGroup("production_order")
	oLoadTool:addParameter("production_order_code"  , "string", STR0006 + "." + BREAK_LINE + STR0007, .T.) //"Código da Ordem de Produção, também conhecido como OP ou Ordem + . + \n + "O código da ordem de produção pode conter somente letras, somente números ou a combinação de caracteres. Exemplo: '00549801001', 'pcpXYZ01005', '00000103001', '10010602001001'."
	oLoadTool:addGlossary("production_order_code"   , STR0006) //"Código da Ordem de Produção, também conhecido como OP ou Ordem"
	oLoadTool:addGlossary("product_code"            , STR0008) //"Código do produto"
	oLoadTool:addGlossary("product_description"     , STR0009) //"Descrição do produto"
	oLoadTool:addGlossary("product_unit_measure"    , STR0010) //"Unidade de medida do produto"
	oLoadTool:addGlossary("planned_quantity"        , STR0011) //"Quantidade planejada"
	oLoadTool:addGlossary("produced_quantity"       , STR0052) //"Quantidade produzida na ordem"
	oLoadTool:addGlossary("loss_quantity"           , STR0053) //"Quantidade de perda da ordem"
	oLoadTool:addGlossary("balance_quantity"        , STR0012) //"Saldo da ordem"
	oLoadTool:addGlossary("script_code"             , STR0013) //"Roteiro da ordem"
	oLoadTool:addGlossary("start_date"              , STR0014) //"Data planejada de início da ordem"
	oLoadTool:addGlossary("end_date"                , STR0015) //"Data planejada de entrega da ordem"
	oLoadTool:addGlossary("finish_date"             , STR0016) //"Data de encerramento da ordem"
	oLoadTool:addGlossary("status"                  , STR0017) //"Situação da ordem"
	If !oLoadTool:createTool()
		cErrorMessage := oLoadTool:getErrorMessage()
	EndIf
	oLoadTool:Destroy()
Return cErrorMessage

/*/{Protheus.doc} loadToolByProduct
Configurações da ferramenta de busca das ordens por produto e datas.

@author lucas.franca/renan.roeder
@since 21/01/2025
@version P12
@return cErrorMessage, Character, Indica se houve erro na carga da ferramenta
/*/
Method loadToolByProduct() as Character Class DTAProductionOrder
	Local cDescription  := ""  as Character
	Local cErrorMessage := ""  as Character
	Local cName         := ""  as Character
	Local cRules        := ""  as Character
	Local cVersion      := ""  as Character
	Local oLoadTool     := Nil as Object

	cName    := "get_production_order_list"
	cVersion := "005"

	If DTALoad():toolIsUpdated(cName, cVersion)
		Return ""
	EndIf

	cDescription := STR0018 //"Fornece uma lista com detalhes das ordens de produção de um produto específico em um intervalo de datas (previsão de início, previsão de entrega ou encerramento)."
	cRules := I18N(STR0019, {"product_code","start_date","end_date"}) //"Se os argumentos '#1[ARGUMENTO_1]#','#2[ARGUMENTO_2]#','#3[ARGUMENTO_3]#' não forem informados pelo usuário, solicite a informação antes de realizar a pesquisa."
	cRules += BREAK_LINE + STR0054 //"Esta ferramenta NÃO traz informação sobre quais ordens estão PROGRAMADAS ou PLANEJADAS para um recurso."
	oLoadTool := DTALoad():New()
	oLoadTool:setName(cName)
	oLoadTool:setClassName("DTAProductionOrder")
	oLoadTool:setDataMethod("getDataList")
	oLoadTool:setVersion(cVersion)
	oLoadTool:setDescription(cDescription)
	oLoadTool:setShortDescription(STR0020) //"Consulta ordens de produção de um produto"
	oLoadTool:setExample(I18N(STR0021, {"product_code"})) //"Quais ordens de produção do produto '#1[CODIGO]#' preciso entregar hoje?"
	oLoadTool:setExample(I18N(STR0022, {"product_code", "start_date", "end_date"})) //"Quais ops do produto '#1[PRODUTO]#' foram encerradas entre '#2[DATA_INICIAL]#' e '#3[DATA_FINAL]#'?"
	oLoadTool:setRules(cRules)
	oLoadTool:setStrict(.T.)
	oLoadTool:setGroup("production_order")
	oLoadTool:addParameter("product_code"           , "string", STR0008 + "." + BREAK_LINE + STR0023 + BREAK_LINE + STR0024, .T.) //Código do produto + . \n + O código do produto pode conter somente letras, somente números ou a combinação de caracteres, podendo ou não ter caracteres especiais. Exemplo: '00255141', 'BICICLETA', 'SKATE', 'SKT001', 'PRODUTO001'. + \n + "Somente é aceito filtro por um código de produto específico, nunca sendo possível filtrar por uma lista de produtos, por uma expressão ou por parte do código do produto."
	oLoadTool:addParameter("start_date"             , "string", STR0025 + BREAK_LINE + STR0026, .T.) //"Filtro inicial de data da ordem de produção. + \n + "Este argumento é utilizado para trazer ordens de produção com data igual ou maior à data informada."
	oLoadTool:addParameter("end_date"               , "string", STR0027 + BREAK_LINE + STR0028, .T.) //"Filtro final de data da ordem de produção. + \n + "Este argumento é utilizado para trazer ordens de produção com data igual ou menor à data informada."
	cDescription := STR0029 + BREAK_LINE //"Indica o tipo de data que está sendo filtrada no intervalo especificado."
	cDescription += " - " + I18N(STR0030, {"C2_DATPRI", "C2_DATPRF", "C2_DATRF"}) + BREAK_LINE //"Os valores válidos são: '#1[DATAINI]#' (Data de previsão de início), '#2[DATAENTREGA]#' (Data de previsão de entrega) ou '#3[DATAENCERRAMENTO]#' (Data de encerramento)."
	cDescription += " - " + STR0044 + BREAK_LINE //"**IMPORTANTE**: Este parâmetro define QUAL data será usada para o filtro de período, não o status da ordem."
	cDescription += " - " + I18N(STR0045, {"C2_DATPRI"}) + BREAK_LINE //"Para filtrar por período de INÍCIO: use '#1[DATAINI]#'"
	cDescription += " - " + I18N(STR0046, {"C2_DATPRF"}) + BREAK_LINE //"Para filtrar por período de ENTREGA: use '#1[DATAENTREGA]#'"
	cDescription += " - " + I18N(STR0047, {"C2_DATRF" }) + BREAK_LINE //"Para filtrar por período de ENCERRAMENTO: use '#1[DATAENCERRAMENTO]#'"
	cDescription += " - " + I18N(STR0048, {"C2_DATPRF"}) //"Valor padrão: '#1[DATAENTREGA]#'."
	oLoadTool:addParameter("field_date"            , "string", cDescription, .T., {"C2_DATPRI", "C2_DATPRF", "C2_DATRF"}) 
	oLoadTool:addParameter("order_status"          , "string", I18N(STR0049, {"FINISHED", "OPEN", "ALL"}), .T., {"FINISHED", "OPEN", "ALL"}) //"Identifica se a busca é por ordens de produção encerradas (ordens que já estão finalizadas, valor '#1[ENCERRADA]#'), ou ordens de produção abertas (que ainda serão ou estão sendo produzidas, valor '#2[ABERTA]#'). Quando não especificado, utilizar a busca por todas as ordens (valor '#3[TODAS]#')."
	oLoadTool:addGlossary("production_order_code"  , STR0006) //"Código da Ordem de Produção, também conhecido como OP ou Ordem"
	oLoadTool:addGlossary("product_code"           , STR0008) //"Código do produto"
	oLoadTool:addGlossary("product_description"    , STR0009) //"Descrição do produto"
	oLoadTool:addGlossary("product_unit_measure"   , STR0010) //"Unidade de medida do produto"
	oLoadTool:addGlossary("planned_quantity"       , STR0011) //"Quantidade planejada"
	oLoadTool:addGlossary("produced_quantity"      , STR0052) //"Quantidade produzida na ordem"
	oLoadTool:addGlossary("loss_quantity"          , STR0053) //"Quantidade de perda da ordem"
	oLoadTool:addGlossary("balance_quantity"       , STR0012) //"Saldo da ordem"
	oLoadTool:addGlossary("script_code"            , STR0013) //"Roteiro da ordem"
	oLoadTool:addGlossary("start_date"             , STR0014) //"Data planejada de início da ordem"
	oLoadTool:addGlossary("end_date"               , STR0015) //"Data planejada de entrega da ordem"
	oLoadTool:addGlossary("finish_date"            , STR0016) //"Data de encerramento da ordem"
	oLoadTool:addGlossary("status"                 , STR0017) //"Situação da ordem"
	oLoadTool:addGlossary("items"                  , STR0055) //"Lista de ordens de produção"
	oLoadTool:addGlossary("total_planned_quantity" , STR0056) //"Total da quantidade planejada nas ordens"
	oLoadTool:addGlossary("total_produced_quantity", STR0057) //"Total da quantidade produzida nas ordens"
	oLoadTool:addGlossary("total_loss_quantity"    , STR0058) //"Total da quantidade de perda nas ordens"
	oLoadTool:addGlossary("total_balance_quantity" , STR0059) //"Total de saldo nas ordens"
	If !oLoadTool:createTool()
		cErrorMessage := oLoadTool:getErrorMessage()
	EndIf
	oLoadTool:Destroy()
Return cErrorMessage

/*/{Protheus.doc} getDataList
Método que faz a busca das informações da ordem de produção conforme os parâmetros de busca recebidos.
Pode filtrar por:
- Código do produto - jFilters["product_code"]
- Intervalo de datas (C2_DATPRI, C2_DATPRF ou C2_DATRF) identificado pelo jFilters["field_date"].
- Status da ordem (aberta, encerrada ou todas)
Busca por range em jFilters["start_date"] e jFilters["end_date"]

@author lucas.franca/renan.roeder
@since 21/01/2025
@version P12
@param 01 jFilters, Json, Filtros que serão aplicados para a busca das ordens.
@return aReturn, Array, Array com os dados encontrados, sendo:
        aReturn[1] - Logical - Identifica se processou com sucesso a busca.
        aReturn[2] - Json    - Dados obtidos na busca ou mensagem de erro caso não consiga fazer a busca.
        aReturn[3] - Numeric - Status que representa o retorno (200 ok, 400 erro.)
/*/
Method getDataList(jFilters as Json) as Array Class DTAProductionOrder
	Local aReturn    := {}  as Array
	Local cAlias     := ""  as Character
	Local cContext   := ""  as Character
	Local cFieldDate := ""  as Character
	Local cQuery     := ""  as Character
	Local jData      := Nil as Json
	Local jItem      := Nil as Json
	Local nBalance   := 0   as Numeric
	Local nIndex     := 0   as Numeric
	Local oQuery     := Nil as Object

	If Empty(jFilters["product_code"]) .Or. Empty(jFilters["start_date"]) .Or. Empty(jFilters["end_date"]) .Or. Empty(jFilters["field_date"]) .Or. Empty(jFilters["order_status"])
		Return DTAUtils():APIErrorMessage(400, I18N(STR0031, {"product_code", "start_date", "end_date", "field_date", "order_status"})) //"Para realizar a busca das ordens de produção, os parâmetros '#1[PRODUTO]#', '#2[DATA_INICIO]#', '#3[DATA_FIM]#', '#4[TIPO_DATA]#' e '#5[STATUS_ORDEM]#' devem ser informados."
	EndIf
	If !("|"+AllTrim(jFilters["order_status"])+"|" $ "|OPEN|FINISHED|ALL|")
		Return DTAUtils():APIErrorMessage(400, I18N(STR0050, {"order_status", "OPEN", "FINISHED", "ALL"})) //"Argumento '#1[STATUS_ORDEM]#' inválido. Informe '#2[OPC_1]#', '#3[OPC_2]#' ou '#4[OPC_3]#' para realizar a pesquisa."
	EndIf
	jFilters["start_date"] := PCPConvDat(jFilters["start_date"], 1)
	If Empty(jFilters["start_date"])
		Return DTAUtils():APIErrorMessage(400, I18N(STR0032, {"start_date"})) //"Argumento '#1[ARGUMENTO]#' não é uma data válida. Informe uma data correta para realizar a pesquisa."
	EndIf
	jFilters["end_date"] := PCPConvDat(jFilters["end_date"], 1)
	If Empty(jFilters["end_date"])
		Return DTAUtils():APIErrorMessage(400, I18N(STR0032, {"end_date"})) //"Argumento '#1[ARGUMENTO]#' não é uma data válida. Informe uma data correta para realizar a pesquisa."
	EndIf
	If !"|"+jFilters["field_date"]+"|" $ "|C2_DATPRI|C2_DATPRF|C2_DATRF|"
		Return DTAUtils():APIErrorMessage(404, I18N(STR0033, {"field_date", "C2_DATPRI", "C2_DATPRF", "C2_DATRF"})) //"Argumento '#1[ARGUMENTO]#' inválido. Informe '#2[OPC_1]#', '#3[OPC_2]#' ou '#4[OPC_3]#' para realizar a pesquisa."
	EndIf
	jFilters["product_code"] := PadR(Upper(jFilters["product_code"]), GetSX3Cache("B1_COD", "X3_TAMANHO"))
	SB1->(dbSetOrder(1))
	If !SB1->(dbSeek(xFilial("SB1") + jFilters["product_code"]))
		Return DTAUtils():APIErrorMessage(400, I18N(STR0034, {RTrim(jFilters["product_code"])})) //"O produto #1[PRODUTO]# não existe. Informe um código de produto válido para realizar a pesquisa."
	EndIf
	cFieldDate := "SC2." + jFilters["field_date"]

	cQuery := "SELECT "
	cQuery +=   "SC2.C2_NUM, "
	cQuery +=   "SC2.C2_ITEM, "
	cQuery +=   "SC2.C2_SEQUEN, "
	cQuery +=   "SC2.C2_ITEMGRD, "
	cQuery +=   "SC2.C2_PRODUTO, "
	cQuery +=   "SB1.B1_DESC, "
	cQuery +=   "SB1.B1_UM, "
	cQuery +=   "SC2.C2_QUANT, "
	cQuery +=   "SC2.C2_QUJE, "
	cQuery +=   "SC2.C2_PERDA, "
	cQuery +=   "SC2.C2_ROTEIRO, "
	cQuery +=   "SC2.C2_DATPRI, "
	cQuery +=   "SC2.C2_DATPRF, "
	cQuery +=   "SC2.C2_DATRF "
	cQuery += "FROM " + RetSqlName("SC2") + " SC2 "
	cQuery += "INNER JOIN " + RetSqlName("SB1") + " SB1 ON SB1.B1_FILIAL = '" + xFilial("SB1") + "' AND SB1.B1_COD = SC2.C2_PRODUTO AND SB1.D_E_L_E_T_ = ' ' "
	cQuery += "WHERE SC2.C2_FILIAL = '" + xFilial("SC2") + "' "
	cQuery +=   "AND SC2.D_E_L_E_T_ = ' ' "
	cQuery +=   "AND SC2.C2_PRODUTO = ? "
	cQuery +=   "AND " + cFieldDate + " >= ? "
	cQuery +=   "AND " + cFieldDate + " <= ? "
	If AllTrim(jFilters["order_status"]) == "OPEN"
		cQuery +=  "AND SC2.C2_DATRF = ' ' "
	ElseIf AllTrim(jFilters["order_status"]) == "FINISHED"
		cQuery +=  "AND SC2.C2_DATRF <> ' ' "
	EndIf
	cQuery += " ORDER BY SC2.C2_NUM, SC2.C2_ITEM, SC2.C2_SEQUEN, SC2.C2_ITEMGRD "
	
	oQuery := FwExecStatement():New()
	oQuery:setQuery(ChangeQuery(cQuery))
	oQuery:setString(1, jFilters["product_code"])
	oQuery:setDate(  2, jFilters["start_date"  ])
	oQuery:setDate(  3, jFilters["end_date"    ])
	cAlias := oQuery:openAlias()

	If !(cAlias)->(Eof())
		jData := {"items": Array(0), "total_planned_quantity": 0, "total_produced_quantity": 0, "total_loss_quantity": 0, "total_balance_quantity": 0}
	EndIf
	While (cAlias)->(!EoF())
		nIndex++
		nBalance := ProductionOrderUtils():getOrderBalance((cAlias)->C2_QUANT, (cAlias)->C2_QUJE, (cAlias)->C2_PERDA, StoD((cAlias)->C2_DATRF))
		jData["total_planned_quantity" ] += (cAlias)->(C2_QUANT)
		jData["total_produced_quantity"] += (cAlias)->(C2_QUJE)
		jData["total_loss_quantity"    ] += (cAlias)->(C2_PERDA)
		jData["total_balance_quantity" ] += nBalance
		
		If nIndex <= 20
			jItem := JsonObject():New()
			jItem["production_order_code"] := RTrim((cAlias)->(C2_NUM + C2_ITEM + C2_SEQUEN + C2_ITEMGRD))
			jItem["product_code"         ] := RTrim((cAlias)->(C2_PRODUTO))
			jItem["product_description"  ] := RTrim((cAlias)->(B1_DESC))
			jItem["product_unit_measure" ] := RTrim((cAlias)->(B1_UM))
			jItem["planned_quantity"     ] := (cAlias)->(C2_QUANT)
			jItem["produced_quantity"    ] := (cAlias)->(C2_QUJE)
			jItem["loss_quantity"        ] := (cAlias)->(C2_PERDA)
			jItem["balance_quantity"     ] := nBalance
			jItem["script_code"          ] := RTrim((cAlias)->(C2_ROTEIRO))
			jItem["start_date"           ] := PCPConvDat((cAlias)->(C2_DATPRI), 5)
			jItem["end_date"             ] := PCPConvDat((cAlias)->(C2_DATPRF), 5)
			jItem["finish_date"          ] := PCPConvDat((cAlias)->(C2_DATRF) , 5)
			jItem["status"               ] := ProductionOrderUtils():getStatus((cAlias)->(C2_NUM + C2_ITEM + C2_SEQUEN + C2_ITEMGRD))
			jItem["status"               ] := ProductionOrderUtils():getStatusDescription(jItem["status"])
			aAdd(jData["items"], jItem)
			jItem := Nil
		EndIf
		(cAlias)->(dbSkip())
	End
	(cAlias)->(dbCloseArea())
	If nIndex > 0
		cContext := DTAProductionOrder():setGeneralContext()
		If nIndex > MAX_ORDERS
			aSize(jData["items"], 0)
			cContext += "\n\n"
			cContext += I18N(STR0042, {nIndex, MAX_ORDERS}) //"Foram encontradas #1[QUANTIDADE]# ordens de produção. O limite máximo de listagem é #2[QTD_ORDENS]# ordens. Informe apenas os totais agregados das ordens e oriente o usuário que existem muitas ordens. Para solicitar a lista de ordens, responda que é necessário aplicar filtros mais restritivos para reduzir o número de registros."
		EndIf
		aReturn  := {.T., {"context": cContext, "data": jData}, 200}
	Else
		aReturn := DTAUtils():APIErrorMessage(400, STR0036) //"Não foram encontradas ordens de produção para os filtros informados."
	EndIf
	
	jData := Nil
	oQuery:Destroy()
	FreeObj(oQuery)
Return aReturn

/*/{Protheus.doc} getDataByCode
Método que faz a busca das informações de uma ordem de produção
Pode filtrar por:
- Código da ordem - jFilters["production_order_code"]

@author lucas.franca/renan.roeder
@since 21/01/2025
@version P12
@param 01 jFilters, Json, Filtros que serão aplicados para a busca da ordem.
@return aReturn, Array, Array com os dados encontrados, sendo:
        aReturn[1] - Logical - Identifica se processou com sucesso a busca.
        aReturn[2] - Json    - Dados obtidos na busca ou mensagem de erro caso não consiga fazer a busca.
        aReturn[3] - Numeric - Status que representa o retorno (200 ok, 400 erro.)
/*/
Method getDataByCode(jFilters as Json) as Array Class DTAProductionOrder
	Local aReturn      := {}  as Array
	Local aSuggestions := {}  as Array
	Local cContext     := ""  as Character
	Local jData        := Nil as Json

	If Empty(jFilters["production_order_code"])
		Return DTAUtils():APIErrorMessage(400, I18N(STR0037, {"production_order_code"})) //"Argumento '#1[ARGUMENTO]#' não foi informado. Informe um código de ordem de produção para realizar a pesquisa."
	EndIf
	jFilters["production_order_code"] := PadR(jFilters["production_order_code"], GetSX3Cache("C2_OP", "X3_TAMANHO"))

	SC2->(dbSetOrder(1))
	If SC2->(dbSeek(xFilial("SC2") + jFilters["production_order_code"]))
		SB1->(dbSetOrder(1))
		SB1->(dbSeek(xFilial("SB1") + SC2->(C2_PRODUTO)))
		jData := JsonObject():New()
		jData["production_order_code"] := RTrim(jFilters["production_order_code"])
		jData["product_code"         ] := RTrim(SC2->C2_PRODUTO)
		jData["product_description"  ] := RTrim(SB1->B1_DESC)
		jData["product_unit_measure" ] := RTrim(SB1->B1_UM)
		jData["planned_quantity"     ] := SC2->C2_QUANT
		jData["produced_quantity"    ] := SC2->C2_QUJE
		jData["loss_quantity"        ] := SC2->C2_PERDA
		jData["balance_quantity"     ] := ProductionOrderUtils():getOrderBalance(SC2->C2_QUANT, SC2->C2_QUJE, SC2->C2_PERDA, SC2->C2_DATRF)
		jData["script_code"          ] := RTrim(SC2->C2_ROTEIRO)
		jData["start_date"           ] := PCPConvDat(SC2->C2_DATPRI, 2)
		jData["end_date"             ] := PCPConvDat(SC2->C2_DATPRF, 2)
		jData["finish_date"          ] := PCPConvDat(SC2->C2_DATRF , 2)
		jData["status"               ] := ProductionOrderUtils():getStatus(SC2->(C2_NUM + C2_ITEM + C2_SEQUEN + C2_ITEMGRD))
		jData["status"               ] := ProductionOrderUtils():getStatusDescription(jData["status"])
		cContext := DTAProductionOrder():setGeneralContext()
		aAdd(aSuggestions, {"label": STR0038}) //"Quais são os empenhos dessa ordem de produção?"
		aAdd(aSuggestions, {"label": STR0039}) //"O que já foi apontado nessa ordem de produção?"
		aAdd(aSuggestions, {"label": STR0040}) //"Quais os custos dessa ordem de produção?"
		aReturn      := {.T., {"context": cContext, "data": jData, "suggestions": aSuggestions}, 200}
		jData        := Nil
		aSuggestions := Nil
	Else
		Return DTAUtils():APIErrorMessage(400, I18N(STR0041, {RTrim(jFilters["production_order_code"])})) //"A ordem de produção #1[ORDEM]# não foi encontrada. Informe um código de ordem de produção existente para realizar a pesquisa."
	EndIf
Return aReturn

/*/{Protheus.doc} setGeneralContext
Atribui o texto de contexto geral para o retorno das ferramentas de ordem de produção

@author lucas.franca/renan.roeder
@since 09/04/2025
@version P12
@return cContext, Character, Texto do contexto geral para retorno da ferramenta
/*/
Method setGeneralContext() as Character Class DTAProductionOrder
	Local cContext := "" as Character

	cContext := STR0043 //"Se perguntado sobre o saldo ou o que falta produzir de uma ordem de produção com situação 'Encerrada parcialmente' ou 'Encerrada totalmente', sua resposta sempre deve ser que o saldo é zero porque a ordem foi encerrada e o processo produtivo finalizado, e que não é mais possível produzir nada."
Return cContext
