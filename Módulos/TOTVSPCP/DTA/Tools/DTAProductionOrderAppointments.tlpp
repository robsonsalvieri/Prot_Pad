#Include "TLPP-CORE.TH"
#Include "TOTVS.CH"
#Include "DTAPRODUCTIONORDERAPPOINTMENTS.CH"

/*/{Protheus.doc} DTAProductionOrderAppointments
Classe responsável pela ferramenta de busca de informações dos apontamentos da ordem de produção

@author lucas.franca/renan.roeder
@since 21/01/2025
@version P12
/*/
Class DTAProductionOrderAppointments
	Static Method calculateExecutedValues(aActivities as Array, lFinishedOrder as Logical) as Numeric
	Static Method getActivityIndex(aActivities as Array, cActivityCode as Character, nOrderQuantity as Numeric) as Numeric
	Static Method getAppointmentsFromProductionOrder(aActivities as Array, cProductionOrder as Character, cActivityCode as Character, nOrderQuantity as Numeric)
	Static Method getData(jFilters as Json) as Array
	Static Method getScriptCodeOfProductionOrder(cProductCode as Character, cOrderScriptCode as Character, cProductScriptCode as Character) as Character
	Static Method getScriptDataFromProductionOrder(aActivities as Array, cProductionOrder as Character, cProductCode as Character, cScriptCode as Character, cActivityCode as Character)
	Static Method loadTool() as Character
EndClass

/*/{Protheus.doc} loadTool
Método que faz a carga das propriedades das ferramentas disponíveis por esta classe. Alimenta as tabelas HZV/HZW.

@author lucas.franca/renan.roeder
@since 21/01/2025
@version P12
@return cErrorMessage, Character, Retorna a mensagem de erro caso a ferramenta não tenha sido criada
/*/
Method loadTool() as Character Class DTAProductionOrderAppointments
	Local cDescription  := ""  as Character
	Local cErrorMessage := ""  as Character
	Local cName         := ""  as Character
	Local cRules        := ""  as Character
	Local cVersion      := ""  as Character
	Local oLoadTool     := Nil as Object

	cName    := "get_production_order_appointments"
	cVersion := "002"
	If DTALoad():toolIsUpdated(cName, cVersion)
		Return ""
	EndIf

	cDescription := STR0001 //"Fornece informações detalhadas sobre as quantidades de produção e perda apontadas para uma ordem de produção, podendo incluir tempos e quantidades planejados versus executados. "
	oLoadTool := DTALoad():New()
	oLoadTool:setName(cName)
	oLoadTool:setClassName("DTAProductionOrderAppointments")
	oLoadTool:setDataMethod("getData")
	oLoadTool:setVersion(cVersion)
	oLoadTool:setDescription(cDescription)
	oLoadTool:setShortDescription(STR0002) //"Busca os apontamentos de tempos, produção e perda de uma ordem de produção"
	oLoadTool:setExample(I18N(STR0003, {"production_order_code"})) //"O que já foi apontado da ordem de produção '#1[production_order_code]#'?"
	oLoadTool:setExample(I18N(STR0004, {"activity_code_optional", "production_order_code"})) //"Qual o desempenho da operação '#1[activity_code_optional]#' na OP '#2[production_order_code]#'?"
	oLoadTool:setExample(I18N(STR0005, {"production_order_code"})) //"Quanto tempo já foi registrado na ordem '#1[production_order_code]#'?"
	oLoadTool:setExample(I18N(STR0006, {"production_order_code"})) //"Quanto foi produzido na ordem de produção '#1[production_order_code]#'?"
	oLoadTool:setRules(cRules)
	oLoadTool:setStrict(.T.)
	oLoadTool:setGroup("appointments")
	oLoadTool:addParameter("production_order_code"   , "string"          , STR0007 + ". \n " + STR0008 + " \n " + STR0009, .T.) //"Código da Ordem de Produção, também conhecido como OP ou Ordem" //"O código da ordem de produção pode conter somente letras, somente números ou a combinação de caracteres. Exemplo: '00549801001', 'pcpXYZ01005', '00000103001', '10010602001001'." //"Quando este argumento for enviado com o valor null serão retornadas as informações de todas as operações."
	oLoadTool:addParameter("activity_code_optional"  , {"string", "null"}, STR0010                                       , .T.) //"Código da operação"
	oLoadTool:addGlossary("production_order_code"            , STR0007) //"Código da Ordem de Produção, também conhecido como OP ou Ordem"
	oLoadTool:addGlossary("production_order_status"          , STR0048) //"Situação da Ordem de Produção"
	oLoadTool:addGlossary("production_order_balance_quantity", STR0049) //"Saldo da Ordem de Produção"
	oLoadTool:addGlossary("product_code"                     , STR0011) //"Código do produto"
	oLoadTool:addGlossary("product_description"              , STR0012) //"Descrição do produto"
	oLoadTool:addGlossary("product_unit_measure"             , STR0013) //"Unidade de medida do produto"
	oLoadTool:addGlossary("activity_code"                    , STR0014) //"Código da operação"
	oLoadTool:addGlossary("activity_description"             , STR0015) //"Descrição da operação"
	oLoadTool:addGlossary("resource_code"                    , STR0016) //"Código do recurso"
	oLoadTool:addGlossary("resource_description"             , STR0017) //"Descrição do recurso"
	oLoadTool:addGlossary("status"                           , STR0018) //"Status da operação, podendo ser Não iniciada, Iniciada ou Encerrada"
	oLoadTool:addGlossary("order_produced_quantity"          , STR0019) //"Quantidade produzida na ordem de produção"
	oLoadTool:addGlossary("order_loss_quantity"              , STR0020) //"Quantidade de perda na ordem de produção"
	oLoadTool:addGlossary("produced_quantity"                , STR0021) //"Quantidade produzida na operação"
	oLoadTool:addGlossary("loss_quantity"                    , STR0022) //"Quantidade de perda na operação"
	oLoadTool:addGlossary("planned_quantity"                 , STR0023) //"Quantidade total planejada"
	oLoadTool:addGlossary("activity_planned_quantity"        , STR0050) //"Quantidade planejada na operação"
	oLoadTool:addGlossary("productive_hours"                 , STR0024) //"Horas produtivas apontadas"
	oLoadTool:addGlossary("standard_lot"                     , STR0025) //"Lote padrão"
	oLoadTool:addGlossary("standard_time"                    , STR0026) //"Tempo padrão"
	oLoadTool:addGlossary("labor_quantity"                   , STR0027) //"Quantidade mão de obra"
	oLoadTool:addGlossary("executed_lot_by_standard_time"    , STR0028) //"Quantidade executada no tempo padrão"
	oLoadTool:addGlossary("performance_standard_lot"         , STR0029) //"Desempenho da execução em relação ao lote padrão"
	oLoadTool:addGlossary("total_productive_hours"           , STR0030) //"Total de horas produtivas apontadas para a OP"
	oLoadTool:addGlossary("items"                            , STR0031) //"Detalhamento das operações"

	If !oLoadTool:createTool()
		cErrorMessage := oLoadTool:getErrorMessage()
	EndIf
	oLoadTool:Destroy()
Return cErrorMessage

/*/{Protheus.doc} getData
Método que faz a busca das informações de apontamentos para uma ordem de produção
Pode filtrar por:
- Código da ordem - jFilters["production_order_code"]

@author lucas.franca/renan.roeder
@since 21/01/2025
@version P12
@param 01 jFilters, Json, Filtros que serão aplicados para a busca dos apontamentos da ordem de produção.
@return aReturn, Array, Array com os dados encontrados, sendo:
        aReturn[1] - Logical - Identifica se processou com sucesso a busca.
        aReturn[2] - Json    - Dados obtidos na busca ou mensagem de erro caso não consiga fazer a busca.
        aReturn[3] - Numeric - Status que representa o retorno (200 ok, 400 erro.)
/*/
Method getData(jFilters as Json) as Array Class DTAProductionOrderAppointments
	Local aItems         := {}  as Array
	Local aReturn        := {}  as Array
	Local aSuggestions   := {}  as Array
	Local cContext       := ""  as Character
	Local jData          := Nil as Json
	Local lFinishedOrder := .F. as Logical

	If Empty(jFilters["production_order_code"])
		Return DTAUtils():APIErrorMessage(400, I18N(STR0032, {"production_order_code"})) //"Argumento '#1[production_order_code]#' não foi informado. Informe um código de ordem de produção para realizar a pesquisa."
	EndIf
	jFilters["production_order_code"] := PadR(jFilters["production_order_code"], GetSX3Cache("C2_OP", "X3_TAMANHO"))
	If !Empty(jFilters["activity_code_optional"])
		jFilters["activity_code_optional"] := PadR(jFilters["activity_code_optional"], GetSX3Cache("H6_OPERAC", "X3_TAMANHO"))
	Else
		jFilters["activity_code_optional"] := ""
	EndIf
	SC2->(dbSetOrder(1))
	If SC2->(dbSeek(xFilial("SC2") + jFilters["production_order_code"]))
		SB1->(dbSetOrder(1))
		SB1->(dbSeek(xFilial("SB1") + SC2->(C2_PRODUTO)))
		jData := JsonObject():New()
		jData["production_order_code"            ] := RTrim(jFilters["production_order_code"])
		jData["product_code"                     ] := RTrim(SB1->B1_COD)
		jData["product_description"              ] := RTrim(SB1->B1_DESC)
		jData["product_unit_measure"             ] := RTrim(SB1->B1_UM)
		jData["planned_quantity"                 ] := SC2->(C2_QUANT)
		jData["order_produced_quantity"          ] := SC2->(C2_QUJE)
		jData["order_loss_quantity"              ] := SC2->(C2_PERDA)
		jData["items"                            ] := {}
		jData["production_order_balance_quantity"] := ProductionOrderUtils():getOrderBalance(SC2->C2_QUANT, SC2->C2_QUJE, SC2->C2_PERDA, SC2->C2_DATRF)
		jData["production_order_status"          ] := ProductionOrderUtils():getStatus(SC2->(C2_NUM + C2_ITEM + C2_SEQUEN + C2_ITEMGRD))
		lFinishedOrder := jData["production_order_status"] $ "|5|6|"
		cContext       := I18N(STR0033, {"product_code", "product_description", "product_code", "product_description"}) //"Quando apresentar as informações de um produto, sempre combine o '#1[product_code]#' e a '#2[product_description]#' em uma única frase, no seguinte formato: Produto: ['#3[product_code]#'] - ['#4[product_description]#']."
		cScriptCode    := DTAProductionOrderAppointments():getScriptCodeOfProductionOrder(SC2->C2_PRODUTO, SC2->C2_ROTEIRO, SB1->B1_OPERPAD)
		If !Empty(cScriptCode)
			DTAProductionOrderAppointments():getScriptDataFromProductionOrder(@aItems, jFilters["production_order_code"], SC2->C2_PRODUTO, cScriptCode, jFilters["activity_code_optional"], jData["planned_quantity"])
			If Len(aItems) > 0
				DTAProductionOrderAppointments():getAppointmentsFromProductionOrder(@aItems, jFilters["production_order_code"], jFilters["activity_code_optional"], jData["planned_quantity"])
				jData["total_productive_hours"] := DTAProductionOrderAppointments():calculateExecutedValues(@aItems, lFinishedOrder)
				jData["items"                 ] := aItems
				aAdd(aSuggestions, {"label": STR0034}) //"Realize uma análise do desempenho das operações listadas."
				cContext += " \n " + I18N(STR0035, {"executed_lot_by_standard_time", "produced_quantity", "loss_quantity", "productive_hours", "standard_time", "labor_quantity"}) //"A '#1[executed_lot_by_standard_time]#' é calculada da seguinte forma: (('#2[produced_quantity]#' + '#3[loss_quantity]#') / '#4[productive_hours]#') * ('#5[standard_time]#' / '#6[labor_quantity]#')."
				cContext += " \n " + I18N(STR0036, {"performance_standard_lot", "executed_lot_by_standard_time", "standard_lot"}) //"O '#1[performance_standard_lot]#' é calculado da seguinte forma: (('#2[executed_lot_by_standard_time]#' / '#3[standard_lot]#') * 100). O resultado representa o percentual de desempenho da execução em relação ao que é previsto no roteiro de produção."
				cContext += " \n " + I18N(STR0037, {STR0046, STR0047, "executed_lot_by_standard_time", "performance_standard_lot"}) //"Tempo Fixo" //"Ilimitado" //"As operações do tipo '#1[fixedTime]#' e '#2[unlimited]#' não apresentam '#3[executed_lot_by_standard_time]#' e '#4[performance_standard_lot]#', pois não é medido seu desempenho."
				cContext += " \n " + I18N(STR0038, {"resource_code", "resource_description", "resource_code", "resource_description"}) //"Quando apresentar as informações de um recurso, sempre combine o '#1[resource_code]#' e a '#2[resource_description]#' em uma única frase, no seguinte formato: Recurso: ['#3[resource_code]#'] - ['#4[resource_description]#']."
			Else
				Return DTAUtils():APIErrorMessage(400, I18N(STR0039, {RTrim(jFilters["activity_code_optional"]), RTrim(jFilters["production_order_code"])})) //"Não foram encontradas informações da operação #1[activity_code_optional]# para a ordem de produção #2[production_order_code]#."
			EndIf
		Else
			If !Empty(jFilters["activity_code_optional"])
				cContext += "\n " + I18N(STR0040, {RTrim(jFilters["activity_code_optional"])}) //"O filtro pela operação #1[activity_code_optional]# não foi aplicado, pois a ordem de produção não possui roteiro de produção."
			Else
				cContext += " \n " + STR0041 //"Esta ordem de produção não possui roteiro definido, portanto somente as quantidades reportadas estão disponíveis."
			EndIf
		EndIf
		cContext += " \n " + STR0051 //"Se perguntado sobre o saldo ou o que falta produzir de uma ordem de produção com situação 'Encerrada parcialmente' ou 'Encerrada totalmente', sua resposta sempre deve ser que o saldo é zero porque a ordem foi encerrada e o processo produtivo finalizado, e que não é mais possível produzir nada."
		jData["production_order_status"] := ProductionOrderUtils():getStatusDescription(jData["production_order_status"])
		aReturn := {.T., {"context": cContext, "data": jData, "suggestions": aSuggestions}, 200}
		jData := Nil
	Else
		aReturn := DTAUtils():APIErrorMessage(400, I18N(STR0042, {RTrim(jFilters["production_order_code"])})) //"A ordem de produção #1[production_order_code]# não foi encontrada. Informe um código de ordem de produção existente para realizar a pesquisa."
	EndIf
Return aReturn

/*/{Protheus.doc} getScriptCodeOfProductionOrder
Busca o código do roteiro de uma ordem de produção. Considera a regra:
1 - Se tiver roteiro definido no C2_ROTEIRO, utiliza esse roteiro;
2 - Caso contrário, verifica se existe roteiro padrão (B1_OPERPAD) para o produto da OP. Se tiver, utiliza;
3 - Caso contrário, verifica se existe o roteiro de código 01 na SG2. Se existir, utiliza.

@author lucas.franca/renan.roeder
@since 21/01/2025
@version P12
@param 01 cProductCode      , Character, Código do produto da ordem de produção (C2_PRODUTO)
@param 02 cOrderScriptCode  , Character, Código do roteiro da ordem de produção (C2_ROTEIRO)
@param 03 cProductScriptCode, Character, Código do roteiro padrão do produto (B1_OPERPAD)
@return cScriptCode, Character, Código do roteiro da ordem de produção conforme as regras definidas
/*/
Method getScriptCodeOfProductionOrder(cProductCode as Character, cOrderScriptCode as Character, cProductScriptCode as Character) as Character Class DTAProductionOrderAppointments
	Local cScriptCode := "" as Character

	If Empty(cOrderScriptCode)
		cOrderScriptCode := cProductScriptCode
	EndIf

	If !Empty(cOrderScriptCode)
		cScriptCode := cOrderScriptCode
	Else
		SG2->(dbSetOrder(1))
		If SG2->(dbSeek(xFilial("SG2")+cProductCode+"01"))
			cScriptCode := "01"
		EndIf
	EndIf
Return cScriptCode

/*/{Protheus.doc} getActivityIndex
Recupera o índice do array de operações de uma operação específica. Se a operação ainda não existir no array de operações, irá criar.

@author lucas.franca/renan.roeder
@since 21/01/2025
@version P12
@param 01 aActivities   , Array    , Array com as operações. Deve ser enviado por referência para adicionar a operação caso não exista.
@param 02 cActivityCode , Character, Código da operação da ordem de produção
@param 03 nOrderQuantity, Numeric  , Quantidade da ordem de produção
@return nIndex, Numeric, Indice da operação no array
/*/
Method getActivityIndex(aActivities as Array, cActivityCode as Character, nOrderQuantity as Numeric) as Numeric Class DTAProductionOrderAppointments
	Local jActivity := Nil as Json
	Local nIndex    := 0   as Numeric

	nIndex := aScan(aActivities, {|x| x["activity_code"] == cActivityCode})
	If nIndex == 0
		jActivity := JsonObject():New()
		jActivity["activity_code"                ] := cActivityCode
		jActivity["activity_planned_quantity"    ] := nOrderQuantity
		jActivity["status"                       ] := STR0043 //"Não iniciada"
		jActivity["reported_quantity"            ] := 0
		jActivity["produced_quantity"            ] := 0
		jActivity["loss_quantity"                ] := 0
		jActivity["productive_hours"             ] := 0
		jActivity["standard_lot"                 ] := 0
		jActivity["standard_time"                ] := 0
		jActivity["executed_lot_by_standard_time"] := 0
		jActivity["performance_standard_lot"     ] := 0
		jActivity["activity_type"                ] := "1"
		jActivity["labor_quantity"               ] := 0
		jActivity["resource_code"                ] := ""
		jActivity["resource_description"         ] := ""
		aAdd(aActivities, jActivity)

		nIndex    := Len(aActivities)
		jActivity := Nil
	EndIf
Return nIndex

/*/{Protheus.doc} getScriptDataFromProductionOrder
Busca as operações da ordem de produção, conforme SHY/SG2.

@author lucas.franca/renan.roeder
@since 21/01/2025
@version P12
@param 01 aActivities     , Array    , Retorna as operações por referência neste array
@param 02 cProductionOrder, Character, Código da ordem de produção
@param 03 cProductCode    , Character, Código do produto da ordem de produção
@param 04 cScriptCode     , Character, Código do roteiro da ordem de produção
@param 05 cActivityCode   , Character, Código da operação da ordem de produção
@param 06 nOrderQuantity  , Numeric  , Quantidade da ordem de produção
@return Nil
/*/
Method getScriptDataFromProductionOrder(aActivities as Array, cProductionOrder as Character, cProductCode as Character, cScriptCode as Character, cActivityCode as Character, nOrderQuantity as Numeric) Class DTAProductionOrderAppointments
	Local cKeySearch := "" as Character
	Local nIndex     := 0  as Numeric

	cKeySearch := xFilial("SHY") + cProductionOrder + cScriptCode
	SHY->(dbSetOrder(1))
	If SHY->(dbSeek(cKeySearch + cActivityCode))
		While SHY->(!Eof()) .And. SHY->(HY_FILIAL+HY_OP+HY_ROTEIRO) == cKeySearch .And. (Empty(cActivityCode) .Or. SHY->HY_OPERAC == cActivityCode)
			nIndex := DTAProductionOrderAppointments():getActivityIndex(@aActivities, SHY->HY_OPERAC, nOrderQuantity)
			aActivities[nIndex]["standard_lot"        ] := Max(1, SHY->HY_LOTEPAD)
			aActivities[nIndex]["standard_time"       ] := SHY->HY_TEMPAD
			aActivities[nIndex]["activity_type"       ] := SHY->HY_TPOPER
			aActivities[nIndex]["labor_quantity"      ] := SHY->HY_MAOOBRA
			aActivities[nIndex]["resource_code"       ] := SHY->HY_RECURSO
			aActivities[nIndex]["activity_description"] := SHY->HY_DESCRI
			SHY->(dbSkip())
		End
	Else
		cKeySearch := xFilial("SG2") + cProductCode + cScriptCode
		SG2->(dbSetOrder(1))
		SG2->(dbSeek(cKeySearch + cActivityCode))
		While SG2->(!Eof()) .And. SG2->(G2_FILIAL+G2_PRODUTO+G2_CODIGO) == cKeySearch .And. (Empty(cActivityCode) .Or. SG2->G2_OPERAC == cActivityCode)
			nIndex := DTAProductionOrderAppointments():getActivityIndex(@aActivities, SG2->G2_OPERAC, nOrderQuantity)
			aActivities[nIndex]["standard_lot"        ] := Max(1, SG2->G2_LOTEPAD)
			aActivities[nIndex]["standard_time"       ] := SG2->G2_TEMPAD
			aActivities[nIndex]["activity_type"       ] := SG2->G2_TPOPER
			aActivities[nIndex]["labor_quantity"      ] := SG2->G2_MAOOBRA
			aActivities[nIndex]["resource_code"       ] := SG2->G2_RECURSO
			aActivities[nIndex]["activity_description"] := SG2->G2_DESCRI
			SG2->(dbSkip())
		End
	EndIf
Return

/*/{Protheus.doc} getAppointmentsFromProductionOrder
Busca as os apontamentos realizados na operação

@author lucas.franca/renan.roeder
@since 21/01/2025
@version P12
@param 01 aActivities     , Array    , Retorna as quantidades apontadas por referência neste array
@param 02 cProductionOrder, Character, Código da ordem de produção
@param 03 cActivityCode   , Character, Código da operação da ordem de produção
@param 04 nOrderQuantity  , Numeric  , Quantidade da ordem de produção
@return Nil
/*/
Method getAppointmentsFromProductionOrder(aActivities as Array, cProductionOrder as Character, cActivityCode as Character, nOrderQuantity as Numeric) Class DTAProductionOrderAppointments
	Local cAlias     := "" as Character
	Local cQuery     := "" as Character
	Local nQuantDec  := 0  as Numeric
	Local nIndex     := 0  as Numeric

	cAlias := GetNextAlias()
	cQuery := "SELECT SH6.H6_TIPO, SH6.H6_TEMPO, SH6.H6_TIPOTEM, SH6.H6_OPERAC, SH6.H6_QTDPROD, SH6.H6_QTDPERD, SH6.H6_PT "
	cQuery += "FROM "+RetSqlName("SH6")+" SH6 "
	cQuery += "WHERE SH6.H6_FILIAL = '" + xFilial("SH6") + "' "    
	cQuery +=   "AND SH6.H6_OP = '" + cProductionOrder + "' "
	If !Empty(cActivityCode)
		cQuery += "AND SH6.H6_OPERAC = '" + cActivityCode + "' "
	EndIf
	cQuery +=   "AND SH6.D_E_L_E_T_ = ' ' "
	cQuery += "ORDER BY SH6.H6_FILIAL, SH6.H6_OP, SH6.H6_OPERAC, SH6.H6_DATAINI "
	dbUseArea(.T.,"TOPCONN",TcGenQry(,,ChangeQuery(cQuery)),cAlias,.F.,.F.)
	While (cAlias)->(!Eof())
		nIndex    := DTAProductionOrderAppointments():getActivityIndex(@aActivities, (cAlias)->H6_OPERAC, nOrderQuantity)
		nQuantDec := PCPMonitorUtils():TransformaTempoParaMinutosCentesimais((cAlias)->H6_TEMPO, (cAlias)->H6_TIPOTEM) / 100
		
		aActivities[nIndex]["reported_quantity"] += (cAlias)->H6_QTDPROD + (cAlias)->H6_QTDPERD
		aActivities[nIndex]["produced_quantity"] += (cAlias)->H6_QTDPROD
		aActivities[nIndex]["loss_quantity"    ] += (cAlias)->H6_QTDPERD
		aActivities[nIndex]["productive_hours" ] += nQuantDec

		If aActivities[nIndex]["status"] != STR0044 //"Encerrada"
			aActivities[nIndex]["status"] := STR0045 //"Iniciada"
			If (cAlias)->H6_PT == "T"
				aActivities[nIndex]["status"] := STR0044 //"Encerrada"
			EndIf
		EndIf

		(cAlias)->(dbSkip())
	End
	(cAlias)->(dbCloseArea())
Return

/*/{Protheus.doc} calculateExecutedValues
Faz o cálculo dos percentuais de execução das operações e carga de demais informações das operações

@author lucas.franca/renan.roeder
@since 21/01/2025
@version P12
@param 01 aActivities   , Array  , Retorna as operações por referência neste array
@param 02 lFinishedOrder, Logical, Indica se a ordem de produção foi encerrada
@return Nil
/*/
Method calculateExecutedValues(aActivities as Array, lFinishedOrder as Logical) as Numeric Class DTAProductionOrderAppointments
	Local cFixedTimeDescription := "" as Character
	Local cHoursType            := "" as Character
	Local nIndex                := 0  as Numeric
	Local nStandardTime         := 0  as Numeric
	Local nTotalTime            := 0  as Numeric

	cHoursType := SuperGetMV("MV_TPHR", .F., "C")

	SH1->(dbSetOrder(1))
	For nIndex := 1 To Len(aActivities)
		If SH1->(msSeek(xFilial("SH1") + aActivities[nIndex]["resource_code"]))
			aActivities[nIndex]["resource_description"] := RTrim(SH1->H1_DESCRI)
		EndIf

		//converte o tempo padrão para os formatos corretos de cálculo e exibição
		If cHoursType == "N"
			nStandardTime := PCPA152TempoOperacao():horasNormaisParaCentesimais(aActivities[nIndex]["standard_time"])
			aActivities[nIndex]["standard_time"] := __Min2Hrs(__Hrs2Min(aActivities[nIndex]["standard_time"]), .T.)
		Else
			nStandardTime := aActivities[nIndex]["standard_time"]
			aActivities[nIndex]["standard_time"] := PCPMonitorUtils():TransformaMinutosCentesimaisParaTempo(aActivities[nIndex]["standard_time"]*100, 1)
		EndIf
		If aActivities[nIndex]["activity_type"] $ "|2|3|"
			cFixedTimeDescription := "("+STR0046+")" //"Tempo fixo"
			If aActivities[nIndex]["activity_type"] == "3"
				cFixedTimeDescription := "("+STR0047+")" //"Ilimitado"
			EndIf
			aActivities[nIndex]["executed_lot_by_standard_time"] := "N/A " + cFixedTimeDescription
			aActivities[nIndex]["performance_standard_lot"     ] := "N/A " + cFixedTimeDescription
		Else
			If aActivities[nIndex]["labor_quantity"] == 0
				aActivities[nIndex]["labor_quantity"] := SH1->H1_MAOOBRA
			EndIf
			aActivities[nIndex]["labor_quantity"               ] := Max(1, aActivities[nIndex]["labor_quantity"])
			aActivities[nIndex]["executed_lot_by_standard_time"] := (aActivities[nIndex]["reported_quantity"] / aActivities[nIndex]["productive_hours"]) * (nStandardTime / aActivities[nIndex]["labor_quantity"])
			aActivities[nIndex]["performance_standard_lot"     ] := cValToChar(Round(((aActivities[nIndex]["executed_lot_by_standard_time"] / aActivities[nIndex]["standard_lot"]) * 100), 2)) + " %"
		EndIf
		nTotalTime := nTotalTime + aActivities[nIndex]["productive_hours"]
		aActivities[nIndex]["resource_code"     ] := RTrim(aActivities[nIndex]["resource_code"])
		aActivities[nIndex]["productive_hours"  ] := PCPMonitorUtils():TransformaMinutosCentesimaisParaTempo(aActivities[nIndex]["productive_hours"  ] * 100, 1)
		aActivities[nIndex]:delName("activity_type")
		aActivities[nIndex]:delName("reported_quantity")
		If lFinishedOrder
			aActivities[nIndex]["status"] := STR0044 //"Encerrada"
		EndIf
	Next nIndex
	nTotalTime := PCPMonitorUtils():TransformaMinutosCentesimaisParaTempo(nTotalTime * 100, 1)
Return nTotalTime
