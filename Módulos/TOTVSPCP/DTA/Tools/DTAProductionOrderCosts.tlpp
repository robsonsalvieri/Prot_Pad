#Include "TLPP-CORE.TH"
#Include "TOTVS.CH"
#Include "DTAProductionOrderCosts.ch"

#DEFINE BREAK_LINE " \n "

/*/{Protheus.doc} DTAProductionOrderCosts
Classe responsável pela ferramenta de busca dos custos da ordem de produção

@author lucas.franca/renan.roeder
@since 21/03/2025
@version P12
/*/
Class DTAProductionOrderCosts
	Static Method getData(jFilters as Json) as Array
	Static Method loadTool() as Character
	Static Method getEstimatedCost(jData as Json)
EndClass

/*/{Protheus.doc} loadTool
Método que faz a carga das propriedades das ferramentas disponíveis por esta classe. Alimenta as tabelas HZV/HZW.

@author lucas.franca/renan.roeder
@since 21/03/2025
@version P12
@return cErrorMessage, Character, Retorna a mensagem de erro caso a ferramenta não tenha sido criada
/*/
Method loadTool() as Character Class DTAProductionOrderCosts
	Local cDescription  := ""  as Character
	Local cErrorMessage := ""  as Character
	Local cName         := ""  as Character
	Local cVersion      := ""  as Character
	Local oLoadTool     := Nil as Object

	cName    := "get_production_order_costs"
	cVersion := "001"

	If DTALoad():toolIsUpdated(cName, cVersion)
		Return ""
	EndIf

	cDescription := STR0001 //"Fornece os custos envolvidos na execução da ordem de produção."
	oLoadTool := DTALoad():New()
	oLoadTool:setName(cName)
	oLoadTool:setClassName("DTAProductionOrderCosts")
	oLoadTool:setDataMethod("getData")
	oLoadTool:setVersion(cVersion)
	oLoadTool:setDescription(cDescription)
	oLoadTool:setShortDescription(STR0003) //"Fornece os custos envolvidos na execução da ordem de produção"
	oLoadTool:setExample(I18N(STR0004, {"production_order_code"})) //"Quais são os custos da ordem de produção '#1[OP]#'?"
	oLoadTool:setExample(I18N(STR0005, {"production_order_code"})) //"Quanto custou a ordem '#1[OP]#'?"
	oLoadTool:setStrict(.T.)
	oLoadTool:setGroup("production_order")
	oLoadTool:addParameter("production_order_code", "string", STR0006 + "." + BREAK_LINE + STR0007, .T.) //Código da Ordem de Produção, também conhecido como OP ou Ordem + .\n + "O código da ordem de produção pode conter somente letras, somente números ou a combinação de caracteres. Exemplo: '00549801001', 'pcpXYZ01005', '00000103001', '10010602001001'."
	oLoadTool:addGlossary("production_order_code" , STR0006) //"Código da Ordem de Produção, também conhecido como OP ou Ordem"
	oLoadTool:addGlossary("product_code"          , STR0008) //"Código do produto"
	oLoadTool:addGlossary("product_description"   , STR0009) //"Descrição do produto"
	oLoadTool:addGlossary("product_unit_measure"  , STR0010) //"Unidade de medida do produto"
	oLoadTool:addGlossary("executed_cost"         , STR0011) //"Custo executado"
	oLoadTool:addGlossary("estimated_cost"        , STR0012) //"Custo estimado"
	oLoadTool:addGlossary("allocations_list"      , STR0013) //"Lista das matérias-primas e seus custos estimados para a OP"
	oLoadTool:addGlossary("product_cost"          , STR0014) //"Custo médio da matéria-prima"
	oLoadTool:addGlossary("planned_quantity"      , STR0015) //"Quantidade planejada da matéria-prima"
	oLoadTool:addGlossary("warehouse_code"        , STR0016) //"Armazém da matéria-prima"
	oLoadTool:addGlossary("component_code"        , STR0017) //"Código da matéria-prima"
	oLoadTool:addGlossary("component_description" , STR0018) //"Descrição da matéria-prima"
	oLoadTool:addGlossary("component_unit_measure", STR0019) //"Unidade de medida da matéria-prima"
	If !oLoadTool:createTool()
		cErrorMessage := oLoadTool:getErrorMessage()
	EndIf
	oLoadTool:Destroy()
Return cErrorMessage

/*/{Protheus.doc} getData
Busca os custos de uma ordem de produção. Para a busca, é obrigatório que seja enviado o filtro:
"production_order_code" - código da ordem de produção;

@author lucas.franca/renan.roeder
@since 21/03/2025
@version P12
@param 01 jFilters, Json, Filtros que serão aplicados para a busca das informações dos custos da ordem de produção
@return aReturn, Array, Array com os dados encontrados, sendo:
        aReturn[1] - Logical - Identifica se processou com sucesso a busca.
        aReturn[2] - Json    - Dados obtidos na busca ou mensagem de erro caso não consiga fazer a busca.
        aReturn[3] - Numeric - Status que representa o retorno (200 ok, 400 erro.)
/*/
Method getData(jFilters as Json) as Array Class DTAProductionOrderCosts
	Local aReturn  := {}  as Array
	Local cContext := ""  as Character
	Local jData    := Nil as Json

	If Empty(jFilters["production_order_code"])
		Return DTAUtils():APIErrorMessage(400, I18N(STR0020, {"production_order_code"})) //"Argumento '#1[ARGUMENTO]#' não foi informado. Informe um código de ordem de produção para realizar a pesquisa."
	EndIf
	jFilters["production_order_code"] := PadR(jFilters["production_order_code"], GetSX3Cache("C2_OP", "X3_TAMANHO"))
	SC2->(dbSetOrder(1))
	If SC2->(dbSeek(xFilial("SC2") + jFilters["production_order_code"]))
		SB1->(dbSetOrder(1))
		SB1->(dbSeek(xFilial("SB1") + SC2->(C2_PRODUTO)))
		jData := JsonObject():New()
		jData["production_order_code"] := RTrim(jFilters["production_order_code"])
		jData["product_code"         ] := RTrim(SC2->C2_PRODUTO)
		jData["product_description"  ] := RTrim(SB1->B1_DESC)
		jData["product_unit_measure" ] := RTrim(SB1->B1_UM)
		jData["executed_cost"        ] := SC2->C2_VATU1 + SC2->C2_APRATU1
		DTAProductionOrderCosts():getEstimatedCost(@jData)
		cContext := I18N(STR0022, {"estimated_cost"}) //"O '#1[CUSTO]#' é obtido através do custo médio de cada matéria-prima consumida pela ordem de produção multiplicado pela sua quantidade planejada."
		cContext += BREAK_LINE + I18N(STR0023, {"executed_cost"}) //"O 'executed_cost' é o valor que já foi registrado através do consumo das matérias-primas pela ordem de produção."
		cContext += BREAK_LINE + STR0024 //"Sempre inclua na resposta a observação que o custo apresentado não contempla valores de mão de obra, e é utilizado o custo médio dos produtos como base para as informações."
		cContext += BREAK_LINE + I18N(STR0025, {AllTrim(SuperGetMV("MV_SIMB1", .F., "$"))}) //"Sempre que mostrar um valor monetário, inclua o simbolo monetário '#1[SIMBOLO]#'."
		cContext += BREAK_LINE + I18N(STR0026, {"allocations_list"}) //"Itens da lista '#1[LISTA]#' sempre devem ser exibidos em formato de tabela."
		cContext += BREAK_LINE + I18N(STR0027, {"allocations_list"}) //"A lista '#1[LISTA]#' está completa. Somente quando você não exibir algum item desta lista, inclua na resposta que existem itens ocultos."
		cContext += BREAK_LINE + I18N(STR0028, {"product_code", "component_code"}) //"Os atributos '#1[PRODUTO]#' e '#2[COMPONENTE]#' não podem ter seu valores alterados."
		cContext += BREAK_LINE + I18N(STR0029, {"allocations_list", "planned_quantity"}) //"Itens da lista '#1[LISTA]#' com '#2[QTD_PLANEJADA]#' negativo indicam subprodutos."
		aReturn  := {.T., {"context": cContext, "data": jData}, 200}
		jData := Nil
	Else
		Return DTAUtils():APIErrorMessage(400, I18N(STR0021, {RTrim(jFilters["production_order_code"])})) //"A ordem de produção #1[OP]# não foi encontrada. Informe um código de ordem de produção existente para realizar a pesquisa."
	EndIf
Return aReturn

/*/{Protheus.doc} getEstimatedCost
Retorna o custo estimado total da ordem e a lista de empenhos que compõem esse custo.

@author lucas.franca/renan.roeder
@since 21/03/2025
@version P12
@param 01 jData, Json Object, Dados da ordem de produção (passado como referência)
@return Nil
/*/
Method getEstimatedCost(jData as Json) Class DTAProductionOrderCosts
	Local aAllocations     := {}  as Array
	Local aItens           := {}  as Array
	Local cProductCode     := ""  as Character
	Local cWarehouseCode   := ""  as Character
	Local jAllocationsCost := Nil as Json
	Local nCost            := 0   as Numeric
	Local nEstimatedCost   := 0   as Numeric
	Local nIndex           := 0   as Numeric
	Local nProductCost     := 0   as Numeric
	Local nTamProdcode     := 0   as Numeric
	Local nTamWrhCode      := 0   as Numeric

	jAllocationsCost := JsonObject():New()
	nTamProdcode     := GetSX3Cache("B1_COD", "X3_TAMANHO")
	nTamWrhCode      := GetSX3Cache("B1_LOCPAD", "X3_TAMANHO")
	aAllocations     := DTAProductionOrderAllocations():getAllocationsList(jData["production_order_code"])
	For nIndex := 1 To Len(aAllocations)
		cProductCode   := PadR(aAllocations[nIndex]["component_code"], nTamProdcode)
		cWarehouseCode := PadR(aAllocations[nIndex]["warehouse_code"], nTamWrhCode)
		If !IsProdMod(cProductCode)
			nProductCost := PegaCmAtu(cProductCode, cWarehouseCode)[1]
			If !jAllocationsCost:hasProperty(cProductCode+cWarehouseCode)
				jAllocationsCost[cProductCode+cWarehouseCode] := {"component_code": RTrim(cProductCode), "component_description": RTrim(aAllocations[nIndex]["component_description"]), "component_unit_measure": aAllocations[nIndex]["component_unit_measure"],"warehouse_code": RTrim(cWarehouseCode), "product_cost": nProductCost, "estimated_cost": 0, "planned_quantity": 0}
			EndIf
			nCost := nProductCost * aAllocations[nIndex]["planned_quantity"]
			nEstimatedCost += nCost
			jAllocationsCost[cProductCode+cWarehouseCode]["estimated_cost"  ] += nCost
			jAllocationsCost[cProductCode+cWarehouseCode]["planned_quantity"] += aAllocations[nIndex]["planned_quantity"]
		EndIf
	Next nIndex
	jData["estimated_cost"  ] := nEstimatedCost
	jData["allocations_list"] := {}
	aItens := jAllocationsCost:getNames()
	For nIndex := 1 To Len(aItens)
		aAdd(jData["allocations_list"], jAllocationsCost[aItens[nIndex]])
	Next nIndex
	FreeObj(jAllocationsCost)
	aSize(aItens, 0)
	aSize(aAllocations, 0)
Return
