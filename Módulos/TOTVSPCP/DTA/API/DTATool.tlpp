#Include "TLPP-CORE.TH"
#Include "TLPP-REST.TH"
#Include "DTATOOL.CH"

#DEFINE TYPE_USER  "1"
#DEFINE TYPE_GROUP "2"

/*/{Protheus.doc} DTATool
Classe com as APIs para busca das ferramentas, utilizada para parametrização dos acessos ao DTA.

@author lucas.franca
@since 26/02/2025
@version P12
/*/
Class DTATool
	Public Method new() as Object

	//Genéricos
	@Get("api/pcp/v1/DTATool/generic/users")
	Public Method getUsers() as Logical
	
	@Get("api/pcp/v1/DTATool/generic/users/:userCode")
	Public Method getUserByCode() as Logical
	
	@Get("api/pcp/v1/DTATool/generic/userGroups")
	Public Method getUserGroups() as Logical
	Public Method processGetUserGroups(cFilter as Character, cId as Character) as Array
	
	@Get("api/pcp/v1/DTATool/generic/userGroups/:groupId")
	Public Method getUserGroupById() as Logical

	//API de carga do catálogo
	@Post("api/pcp/v1/DTATool/loadTools")
	Public Method postLoadTools() as Logical
	
	//APIs do catálogo
	@Get("api/pcp/v1/DTATool/catalog/list")
	Public Method getCatalogTools() as Logical
	Public Method processGetCatalogTools(cToolCode as Character) as Array
	
	@Get("api/pcp/v1/DTATool/catalog/:toolCode")
	Public Method getCatalogToolByCode() as Logical
	Public Method processGetCatalogToolByCode(cToolCode as Character) as Array
	
	@Get("api/pcp/v1/DTATool/catalog/authorized-users/:toolCode")
	Public Method getCatalogAuthorizedUsers() as Logical
	Public Method processGetCatalogAuthorizedUsers(cToolCode as Character) as Array
	
	@Post("api/pcp/v1/DTATool/catalog/authorize")
	Public Method postCatalogAuthorize() as Logical
	Public Method processPostCatalogAuthorize(jBodyRequest as Json) as Array
	
	@Patch("api/pcp/v1/DTATool/catalog/change-enabled-status")
	Public Method patchCatalogChangeEnabledStatus() as Logical
	Public Method processPatchCatalogChangeEnabledStatus(jBodyRequest as Json) as Array
	
	@Delete("api/pcp/v1/DTATool/catalog/authorize/:toolCode/:code/:type")
	Public Method deleteCatalogAuthorize() as Logical
	Public Method processDeleteCatalogAuthorize(cToolCode as Character, cCode as Character, cType as Character) as Array
	
	//APIs da autorização
	@Get("api/pcp/v1/DTATool/authorization/granted-user-groups")
	Public Method getAuthorizationGrantedUserGroups() as Logical
	Public Method processGetAuthorizationGrantedUserGroups(cType as Character, cCode as Character) as Array
	
	@Get("api/pcp/v1/DTATool/authorization/list/:code/:type")
	Public Method getAuthorizationList() as Logical
	Public Method processGetAuthorizationList(cCode as Character, cType as Character) as Array
	
	@Post("api/pcp/v1/DTATool/authorization")
	Public Method postAuthorization() as Logical
	Public Method processPostAuthorization(jBodyRequest as Json) as Array
	Public Method updateAuthorization(jBodyRequest as Json)

	Public Method existAuthorization(cToolCode as Character, cCode as Character, cType as Character) as Logical
	Public Method registryAuthorization(jBodyRequest as Json)
	Public Method validateCatalogAuthorizationData(jBodyRequest as Json, jReturn as Json) as Logical
	Public Method validateAuthorizationData(jBodyRequest as Json, jReturn as Json) as Logical
	Public Method validateChangeEnabledStatus(jBodyRequest as Json, jReturn as Json) as Logical
	
	Static Method getGroupName(cGroupCode as Character) as Character
	Static Method getKey(cToolCode as Character, cCode as Character, cType as Character) as Character
	Static Method getUserAccessObjectFromHZY(cAlias as Character) as Json
	Static Method validateType(cType as Character) as Logical
EndClass

/*/{Protheus.doc} new
Método construtor da classe. 

@author lucas.franca
@since 26/02/2025
@version P12
@return Self, Object, Instância da classe
/*/
Method new() as Object Class DTATool
Return Self

/*/{Protheus.doc} getCatalogToolByCode
API para busca de uma ferramenta pelo seu código.
endpoint: [GET] api/pcp/v1/DTATool/catalog/:toolCode
PATHPARAM: 
- toolCode -> Código da ferramenta para busca

@author lucas.franca
@since 26/02/2025
@version P12
@return lRet, Logical, Identifica se processou com sucesso a busca
/*/
Method getCatalogToolByCode() as Logical Class DTATool
	Local aReturnData := {}  as Array
	Local jPathParams := Nil as Json
	Local lRet        := .T. as Logical

	oRest:setKeyHeaderResponse("Content-Type","application/json")

	jPathParams := oRest:getPathParamsRequest()
	aReturnData := Self:processGetCatalogToolByCode(jPathParams["toolCode"])
	oRest:setStatusCode(aReturnData[1])
	lRet := oRest:setResponse(aReturnData[2]:toJson())

	jPathParams := Nil
	FwFreeArray(aReturnData)
Return lRet

/*/{Protheus.doc} processGetCatalogToolByCode
Método que faz o processamento da busca de uma ferramenta pelo código.

@author lucas.franca
@since 26/02/2025
@version P12
@param 01 cToolCode, Character, Código da ferramenta para busca
@return aReturnData, Array, Array com informações da busca, onde:
                            [1] - Código HTTP para retorno da requisição (200-ok;404-NotFound)
                            [2] - Objeto JSON com os dados da ferramenta
*/
Method processGetCatalogToolByCode(cToolCode as Character) as Array Class DTATool
	Local aReturnData := Nil as Array
	Local jToolData   := Nil as Json

	jToolData := JsonObject():New()
	
	If DTALoad():toolExists(cToolCode)
		jToolData["toolCode"            ] := RTrim(HZV->HZV_FUNCAO)
		jToolData["toolDescription"     ] := RTrim(HZV->HZV_DESCRI)
		jToolData["toolShortDescription"] := RTrim(HZV->HZV_DSCCUR)
		jToolData["rules"               ] := RTrim(HZV->HZV_REGRAS)
		jToolData["groupCode"           ] := RTrim(HZV->HZV_GRUPO)
		jToolData["groupDescription"    ] := ""
		jToolData["className"           ] := RTrim(HZV->HZV_CLASSE)
		jToolData["methodName"          ] := RTrim(HZV->HZV_MDADOS)
		jToolData["version"             ] := RTrim(HZV->HZV_VERSAO)
		jToolData["parameters"          ] := DTALoad():convertParametersToList(HZV->HZV_PARAM)
		jToolData["enabled"             ] := RTrim(HZV->HZV_HABLTD)
		jToolData["default"             ] := RTrim(HZV->HZV_PADRAO)
		jToolData["useStrict"           ] := RTrim(HZV->HZV_ESTRIT)
		jToolData["glossary"            ] := DTAUtils():getToolGlossary(HZV->HZV_FUNCAO)
		jToolData["examples"            ] := DTAUtils():getToolExamples(HZV->HZV_FUNCAO)

		HZX->(dbSetOrder(1))
		If !Empty(HZV->HZV_GRUPO) .And. HZX->(dbSeek(xFilial("HZX") + HZV->HZV_GRUPO))
			jToolData["groupDescription"] := RTrim(HZX->HZX_NOME)
		EndIf
		aReturnData := {200, jToolData}
	Else
		aReturnData := {404, {"code": "404", "message": STR0001, "detailedMessage": I18N(STR0002, {RTrim(cToolCode)})}} //"Ferramenta não encontrada." //"Não foi encontrada a ferramenta com o código #1[TOOLCODE]#."
	EndIf
	jToolData := Nil
Return aReturnData

/*/{Protheus.doc} getCatalogTools
API para busca da lista de ferramentas
endpoint: [GET] api/pcp/v1/DTATool/catalog/list
QUERYPARAM: 
- toolCode -> Código da ferramenta para filtro. Aplica o filtro "LIKE".

@author lucas.franca
@since 26/02/2025
@version P12
@return lRet, Logical, Identifica se processou com sucesso a busca
/*/
Method getCatalogTools() as Logical Class DTATool
	Local aReturnData  := {}  as Array
	Local jQueryParams := Nil as Json
	Local lRet         := .T. as Logical

	oRest:setKeyHeaderResponse("Content-Type","application/json")

	jQueryParams := oRest:getQueryRequest()
	aReturnData := Self:processGetCatalogTools(jQueryParams["toolCode"])
	oRest:setStatusCode(aReturnData[1])
	lRet := oRest:setResponse(aReturnData[2]:toJson())
	jQueryParams := Nil
	FwFreeArray(aReturnData)
Return lRet

/*/{Protheus.doc} processGetCatalogTools
Método que faz o processamento da busca da lista de ferramentas

@author lucas.franca
@since 26/02/2025
@version P12
@param 01 cToolCode, Character, Código da ferramenta para filtrar a busca (filtro por LIKE)
@return aReturnData, Array, Array com informações da busca, onde:
                            [1] - Código HTTP para retorno da requisição (200-ok;404-NotFound)
                            [2] - Objeto JSON com as informações das ferramentas
*/
Method processGetCatalogTools(cToolCode as Character) as Array Class DTATool
	Local aListTools  := {}  as Array
	Local aReturnData := {}  as Array
	Local cAlias      := ""  as Character
	Local cQuery      := ""  as Character
	Local nIndex      := 0   as Numeric
	Local oQuery      := Nil as Object

	cQuery := "SELECT HZV.HZV_FUNCAO,"
	cQuery +=       " HZV.HZV_DSCCUR,"
	cQuery +=       " HZV.HZV_HABLTD,"
	cQuery +=       " HZV.HZV_PADRAO,"
	cQuery +=       " HZV.HZV_GRUPO,"
	cQuery +=       " HZX.HZX_NOME,"
	cQuery +=       " (SELECT COUNT(*) FROM " + RetSqlName("HZY") + " HZY"
	cQuery +=        " WHERE HZY.HZY_FILIAL = ?"
	cQuery +=          " AND HZY.HZY_FUNCAO = HZV.HZV_FUNCAO"
	cQuery +=          " AND HZY.D_E_L_E_T_ = ' ') AS QTD_PERMISSAO "
	cQuery +=  " FROM " + RetSqlName("HZV") + " HZV"
	cQuery +=  " LEFT JOIN " + RetSqlName("HZX") + " HZX"
	cQuery +=    " ON HZX.HZX_FILIAL = ?"
	cQuery +=   " AND HZX.HZX_GRUPO  = HZV.HZV_GRUPO"
	cQuery +=   " AND HZX.D_E_L_E_T_ = ' '"
	cQuery += " WHERE HZV.HZV_FILIAL = ?"
	If !Empty(cToolCode)
		cQuery += " AND Upper(HZV.HZV_FUNCAO) LIKE ?"
	EndIf
	cQuery +=   " AND HZV.D_E_L_E_T_ = ' '"
	cQuery += " ORDER BY HZV.HZV_FILIAL, HZV.HZV_FUNCAO"

	oQuery := FwExecStatement():New(cQuery)
	oQuery:setString(1, xFilial("HZY"))
	oQuery:setString(2, xFilial("HZX"))
	oQuery:setString(3, xFilial("HZV"))
	If !Empty(cToolCode)
		oQuery:setString(4, "%" + Upper(cToolCode) + "%")
	EndIf

	cAlias := oQuery:openAlias()
	nIndex := 0
	While (cAlias)->(!Eof())
		nIndex++

		aAdd(aListTools, JsonObject():New())
		aListTools[nIndex]["toolCode"            ] := RTrim((cAlias)->HZV_FUNCAO)
		aListTools[nIndex]["toolShortDescription"] := RTrim((cAlias)->HZV_DSCCUR)
		aListTools[nIndex]["groupCode"           ] := RTrim((cAlias)->HZV_GRUPO)
		aListTools[nIndex]["groupDescription"    ] := RTrim((cAlias)->HZX_NOME)
		aListTools[nIndex]["enabled"             ] := RTrim((cAlias)->HZV_HABLTD)
		aListTools[nIndex]["default"             ] := RTrim((cAlias)->HZV_PADRAO)
		aListTools[nIndex]["actions"             ] := {"details", "disable"}
		If aListTools[nIndex]["enabled"] == "2"
			aListTools[nIndex]["actions"][2] := "enable"
		EndIf
		aListTools[nIndex]["active"] := "2"
		If (cAlias)->QTD_PERMISSAO > 0
			aListTools[nIndex]["active"] := "1"
		EndIf

		(cAlias)->(dbSkip())
	End
	(cAlias)->(dbCloseArea())

	If nIndex > 0
		aReturnData := {200, JsonObject():New()}
		aReturnData[2]["hasNext"] := .F.
		aReturnData[2]["items"  ] := aListTools
	Else
		aReturnData := {404, {"code": "404", "message": STR0001, "detailedMessage": STR0003}} //"Ferramenta não encontrada." //"Não foram encontradas ferramentas com os filtros informados."
	EndIf
	aListTools := Nil
	oQuery:Destroy()
	FreeObj(oQuery)
Return aReturnData

/*/{Protheus.doc} getCatalogAuthorizedUsers
API para busca dos usuários/grupos autorizados para determinada ferramenta.
endpoint: [GET] api/pcp/v1/DTATool/catalog/authorized-users/:toolCode
PATHPARAM: 
- toolCode -> Código da ferramenta para busca

@author lucas.franca
@since 26/02/2025
@version P12
@return lRet, Logical, Identifica se processou com sucesso a busca
/*/
Method getCatalogAuthorizedUsers() as Logical Class DTATool
	Local aReturnData  := {}  as Array
	Local jPathParams  := Nil as Json
	Local lRet         := .T. as Logical

	oRest:setKeyHeaderResponse("Content-Type","application/json")

	jPathParams  := oRest:getPathParamsRequest()
	aReturnData := Self:processGetCatalogAuthorizedUsers(jPathParams["toolCode"])
	oRest:setStatusCode(aReturnData[1])
	lRet := oRest:setResponse(aReturnData[2]:toJson())
	jPathParams  := Nil
	FwFreeArray(aReturnData)
Return lRet

/*/{Protheus.doc} processGetCatalogAuthorizedUsers
Método que faz o processamento da busca dos usuários e grupos associados à uma ferramenta

@author lucas.franca
@since 26/02/2025
@version P12
@param 01 cToolCode, Character, Código da ferramenta para busca
@return aReturnData, Array, Array com informações da busca, onde:
                            [1] - Código HTTP para retorno da requisição (200-ok;404-NotFound)
                            [2] - Objeto JSON com as informações das ferramentas
*/
Method processGetCatalogAuthorizedUsers(cToolCode as Character) as Array Class DTATool
	Local aListUsers  := {} as Array
	Local aReturnData := {} as Array
	Local cBranchId   := "" as Character
	Local nIndex      := 0  as Numeric

	cToolCode := PadR(cToolCode, GetSX3Cache("HZV_FUNCAO", "X3_TAMANHO"))
	cBranchId := xFilial("HZY")
	HZY->(dbSetOrder(1))
	HZY->(dbSetFilter({|| HZY_FILIAL == cBranchId .And. HZY_FUNCAO == cToolCode}, "HZY_FILIAL == cBranchId .And. HZY_FUNCAO == cToolCode"))
	HZY->(dbGoTop())

	While HZY->(!Eof())
		nIndex++
		aAdd(aListUsers, DTATool():getUserAccessObjectFromHZY("HZY"))
		HZY->(dbSkip())
	End

	aReturnData := {200, JsonObject():New()}
	aReturnData[2]["hasNext"] := .F.
	aReturnData[2]["items"  ] := aListUsers
	
	HZY->(dbClearFilter())
	aListUsers := Nil
Return aReturnData

/*/{Protheus.doc} postCatalogAuthorize
API para adicionar permissão de um usuário/grupo à uma ferramenta
endpoint: [POST] api/pcp/v1/DTATool/catalog/authorize
body: {
	"toolCode": "Código da ferramenta",
	"code"    : "Código do usuário/grupo",
	"type"    : "1 - usuário; 2 - grupo"
}

@author lucas.franca
@since 26/02/2025
@version P12
@return lRet, Logical, Identifica se processou com sucesso a inclusão
/*/
Method postCatalogAuthorize() as Logical Class DTATool
	Local aReturnData  := {}  as Array
	Local jBodyRequest := Nil as Json
	Local lRet         := .T. as Logical

	oRest:setKeyHeaderResponse("Content-Type","application/json")

	jBodyRequest := JsonObject():New()
	jBodyRequest:FromJson(oRest:getBodyRequest())
	aReturnData  := Self:processPostCatalogAuthorize(jBodyRequest)
	oRest:setStatusCode(aReturnData[1])
	lRet := oRest:setResponse(aReturnData[2]:toJson())
	FreeObj(jBodyRequest)
	FwFreeArray(aReturnData)
Return lRet

/*/{Protheus.doc} processPostCatalogAuthorize
Método que faz o processamento da inclusão de uma permissão de usuário/grupo a uma ferramenta

@author lucas.franca
@since 26/02/2025
@version P12
@param 01 jBodyRequest, Json, Json da requisição com código da ferramenta, usuario/grupo e tipo
@return aReturnData, Array, Array com informações da busca, onde:
                            [1] - Código HTTP para retorno da requisição (201-ok;400-BadRequest)
                            [2] - Objeto JSON com o status do processo
*/
Method processPostCatalogAuthorize(jBodyRequest as Json) as Array Class DTATool
	Local aReturnData := {400, JsonObject():New()} as Array

	If Self:validateCatalogAuthorizationData(@jBodyRequest, @aReturnData[2])
		aReturnData[1] := 201
		aReturnData[2]["code"  ] := 201
		aReturnData[2]["status"] := "OK"
		If !Self:existAuthorization(jBodyRequest["toolCode"], jBodyRequest["code"], jBodyRequest["type"])
			Self:registryAuthorization(jBodyRequest)
		EndIf
	EndIf
Return aReturnData

/*/{Protheus.doc} registryAuthorization
Registra a autorização do usuário na tabela HZY

@author lucas.franca
@since 26/02/2025
@version P12
@param 01 jBodyRequest, Json, Json da requisição com código da ferramenta, usuario/grupo e tipo
@return Nil
*/
Method registryAuthorization(jBodyRequest as Json) Class DTATool
	RecLock("HZY", .T.)
		HZY->HZY_FILIAL := xFilial("HZY")
		HZY->HZY_FUNCAO := jBodyRequest["toolCode"]
		If jBodyRequest["type"] == TYPE_USER
			HZY->HZY_USUARI := jBodyRequest["code"]
		Else
			HZY->HZY_GRPUSR := jBodyRequest["code"]
		EndIf
	HZY->(MsUnLock())
Return Nil

/*/{Protheus.doc} validateCatalogAuthorizationData
Faz as validações das informações para adicionar a permissão de um usuário/grupo a uma ferramenta.

@author lucas.franca
@since 26/02/2025
@version P12
@param 01 jBodyRequest, Json, Json da requisição com código da ferramenta, usuario/grupo e tipo
@param 02 jReturn     , Json, Retorna por referência mensagem de erro
@return lRet, Logical, .T. se os dados forem válidos.
*/
Method validateCatalogAuthorizationData(jBodyRequest as Json, jReturn as Json) as Logical Class DTATool
	Local lRet := .T. as Logical

	If lRet .And. Empty(jBodyRequest["toolCode"])
		lRet := .F.
		jReturn["message"        ] := STR0004 //"Código da ferramenta não informada."
		jReturn["detailedMessage"] := STR0005 //"É obrigatório informar o código da ferramenta (toolCode) para adicionar a autorização."
	EndIf
	If lRet .And. Empty(jBodyRequest["code"])
		lRet := .F.
		jReturn["message"        ] := STR0006 //"Código do usuário/grupo não informado."
		jReturn["detailedMessage"] := STR0007 //"É obrigatório informar o código do usuário/grupo (code) para adicionar a autorização.."
	EndIf
	If lRet .And. !DTATool():validateType(jBodyRequest["type"])
		lRet := .F.
		jReturn["message"        ] := STR0008 //"Tipo da permissão não informada."
		jReturn["detailedMessage"] := STR0009 //"É obrigatório informar o tipo da permissão (1 - usuário; 2 - grupo) para adicionar a autorização."
	EndIf
	If lRet .And. !DTALoad():toolExists(jBodyRequest["toolCode"])
		lRet := .F.
		jReturn["message"        ] := STR0010 //"Código da ferramenta inválido."
		jReturn["detailedMessage"] := I18N(STR0011, {RTrim(jBodyRequest["toolCode"])}) //"Não foram encontradas as informações da ferramenta #1[TOOLCODE]#."
	EndIf
	If lRet .And. !UsrExist(jBodyRequest["code"], jBodyRequest["type"] == TYPE_USER)
		lRet := .F.
		jReturn["message"        ] := STR0012 //"Código do usuário/grupo inválido."
		jReturn["detailedMessage"] := I18N(STR0013, {RTrim(jBodyRequest["code"])}) //"Não foram encontradas as informações do usuário/grupo #1[USERCODE]#."
	EndIf
Return lRet

/*/{Protheus.doc} existAuthorization
Valida se já existe registrado a permissão de um usuário/grupo a uma ferramenta.
Se existir, deixará a tabela HZY posicionada no registro.

@author lucas.franca
@since 26/02/2025
@version P12
@param 01 cToolCode, Character, Código da ferramenta
@param 02 cCode    , Character, Código do usuário ou do grupo de usuários
@param 03 cType    , Character, Tipo da permissão (1 - usuário; 2 - grupo)
@return lRet, Logical, .T. se já existir o registro da permissão.
*/
Method existAuthorization(cToolCode as Character, cCode as Character, cType as Character) as Logical Class DTATool
	Local cKey := ""  as Character
	Local lRet := .F. as Logical

	cKey := DTATool():getKey(cToolCode, cCode, cType)
	
	HZY->(dbSetOrder(1))
	lRet := HZY->(dbSeek(cKey))
Return lRet

/*/{Protheus.doc} deleteCatalogAuthorize
API para remover permissão de um usuário/grupo à uma ferramenta
endpoint: [DELETE] api/pcp/v1/DTATool/catalog/authorize/:toolCode/:code/:type

@author lucas.franca
@since 26/02/2025
@version P12
@return lRet, Logical, Identifica se processou com sucesso a busca
/*/
Method deleteCatalogAuthorize() as Logical Class DTATool
	Local aReturnData := {}  as Array
	Local jPathParams := Nil as Json
	Local lRet        := .T. as Logical

	oRest:setKeyHeaderResponse("Content-Type","application/json")

	jPathParams := oRest:getPathParamsRequest()
	aReturnData := Self:processDeleteCatalogAuthorize(jPathParams["toolCode"], jPathParams["code"], jPathParams["type"])
	oRest:setStatusCode(aReturnData[1])
	lRet := oRest:setResponse(aReturnData[2]:toJson())
	jPathParams := Nil
	FwFreeArray(aReturnData)
Return lRet

/*/{Protheus.doc} processDeleteCatalogAuthorize
Método que faz o processamento da exclusão de uma permissão de usuário/grupo a uma ferramenta

@author lucas.franca
@since 26/02/2025
@version P12
@param 01 cToolCode, Character, Código da ferramenta
@param 02 cCode    , Character, Código do usuário ou do grupo de usuários
@param 03 cType    , Character, Tipo da permissão (1 - usuário; 2 - grupo)
@return aReturnData, Array, Array com informações da busca, onde:
                            [1] - Código HTTP para retorno da requisição (200-ok;400-BadRequest)
                            [2] - Objeto JSON com o status do processo
*/
Method processDeleteCatalogAuthorize(cToolCode as Character, cCode as Character, cType as Character) as Array Class DTATool
	Local aReturnData := {200, JsonObject():New()} as Array

	If !DTATool():validateType(cType)
		aReturnData[1] := 400
		aReturnData[2]["code"   ] := 400
		aReturnData[2]["message"] := STR0014 //"Tipo da permissão inválido."
	Else
		aReturnData[2]["code"  ] := 200
		aReturnData[2]["status"] := "OK"
		If Self:existAuthorization(cToolCode, cCode, cType)
			RecLock("HZY", .F.)
				HZY->(dbDelete())
			HZY->(MsUnLock())
		EndIf
	EndIf
Return aReturnData

/*/{Protheus.doc} getKey
Retorna a chave do registro da tabela HZY, referente ao índice 1

@author lucas.franca
@since 26/02/2025
@version P12
@param 01 cToolCode, Character, Código da ferramenta
@param 02 cCode    , Character, Código do usuário ou do grupo de usuários
@param 03 cType    , Character, Tipo da permissão (1 - usuário; 2 - grupo)
@return cKey, Character, Chave do registro
*/
Method getKey(cToolCode as Character, cCode as Character, cType as Character) as Character Class DTATool
	Local cKey := "" as Character

	cKey := xFilial("HZY") + PadR(cToolCode, GetSX3Cache("HZY_FUNCAO", "X3_TAMANHO"))
	If cType == TYPE_USER
		cKey += PadR(cCode, GetSX3Cache("HZY_USUARI", "X3_TAMANHO"))
		cKey += Space(GetSX3Cache("HZY_GRPUSR", "X3_TAMANHO"))
	Else
		cKey += Space(GetSX3Cache("HZY_USUARI", "X3_TAMANHO"))
		cKey += PadR(cCode, GetSX3Cache("HZY_GRPUSR", "X3_TAMANHO"))
	EndIf
Return cKey

/*/{Protheus.doc} validateType
Verifica se o conteúdo do parâmetro type é válido.
Conteúdos válidos - 1 (usuário) ou 2 (grupo)

@author lucas.franca
@since 26/02/2025
@version P12
@param 01 cType, Character, Tipo da permissão (1 - usuário; 2 - grupo)
@return lRet, Logical, Identifica se o tipo é válido
*/
Method validateType(cType as Character) as Logical Class DTATool
	Local lRet := .T. as Logical
	
	If Empty(cType) .Or. !(cType == TYPE_USER .Or. cType == TYPE_GROUP)
		lRet := .F.
	EndIf
Return lRet

/*/{Protheus.doc} getUserGroups
API para busca dos grupos de usuários do sistema
endpoint: [GET] api/pcp/v1/DTATool/generic/userGroups

QUERYPARAM: 
- page -> número da página de pesquisa. Padrão = 1
- pageSize -> quantidade de registros por página. Padrão = 20
- filter -> filtro para busca de grupos (like em id/código/descrição do grupo)

@author lucas.franca
@since 26/02/2025
@version P12
@return lRet, Logical, Identifica se processou com sucesso a busca
/*/
Method getUserGroups() as Logical Class DTATool
	Local aReturnData  := {}  as Array
	Local jQueryParams := Nil as Json
	Local lRet         := .T. as Logical

	oRest:setKeyHeaderResponse("Content-Type","application/json")

	jQueryParams := oRest:getQueryRequest()
	aReturnData := Self:processGetUserGroups(jQueryParams["filter"])
	oRest:setStatusCode(aReturnData[1])
	lRet := oRest:setResponse(aReturnData[2]:toJson())
	jQueryParams := Nil
	FwFreeArray(aReturnData)
Return lRet

/*/{Protheus.doc} getUserGroupById
API para busca de um grupo de usuário do sistema
endpoint: [GET] api/pcp/v1/DTATool/generic/userGroups/:groupId

PATHPARAM:
- groupId -> ID do grupo de usuário para filtro

@author lucas.franca
@since 26/02/2025
@version P12
@return lRet, Logical, Identifica se processou com sucesso a busca
/*/
Method getUserGroupById() as Logical Class DTATool
	Local aReturnData      := {}  as Array
	Local jPathParams      := Nil as Json
	Local jResponseMessage := Nil as Json
	Local lRet             := .T. as Logical

	oRest:setKeyHeaderResponse("Content-Type","application/json")
	jPathParams := oRest:getPathParamsRequest()
	aReturnData := Self:processGetUserGroups(, jPathParams["groupId"])

	oRest:setStatusCode(aReturnData[1])
	If aReturnData[1] == 200
		jResponseMessage := aReturnData[2]["items"][1]
	Else
		jResponseMessage := aReturnData[2]
	EndIf

	lRet := oRest:setResponse(jResponseMessage:toJson())
	jPathParams := Nil
	FreeObj(jResponseMessage)
	FwFreeArray(aReturnData)
Return lRet

/*/{Protheus.doc} processGetUserGroups
Método que faz o processamento da busca dos grupos de usuário

@author lucas.franca
@since 26/02/2025
@version P12
@param 01 cFilter  , Character, Texto para filtro de id/código/descrição do grupo (like)
@param 02 cId      , Character, ID do grupo de usuário para busca
@return aReturnData, Array, Array com informações da busca, onde:
                            [1] - Código HTTP para retorno da requisição (200-ok;404-NotFound)
                            [2] - Objeto JSON com os dados da ferramenta
*/
Method processGetUserGroups(cFilter as Character, cId as Character) as Array Class DTATool
	Local aGroups     := {} as Array
	Local aItems      := {} as Array
	Local aReturnData := {} as Array
	Local nIndex      := 0  as Numeric
	Local nPos        := 0  as Numeric

	aGroups := FWSFAllGrps(.T.)
	For nIndex := 1 To Len(aGroups)
		If filterGroup(aGroups[nIndex], cFilter, cId)
			nPos++
			aAdd(aItems, JsonObject():New())
			aItems[nPos]["groupId"         ] := RTrim(aGroups[nIndex][2])
			aItems[nPos]["groupCode"       ] := RTrim(aGroups[nIndex][3])
			aItems[nPos]["groupDescription"] := RTrim(aGroups[nIndex][4])
			If !Empty(cId)
				Exit
			EndIf
		EndIf
	Next nIndex
	
	If nPos > 0
		aReturnData := {200, JsonObject():New()}
		aReturnData[2]["hasNext"] := .F.
		aReturnData[2]["items"  ] := aItems
		aItems := Nil
	Else
		aReturnData := {404, {"code": "404", "message": STR0015, "detailedMessage": STR0016}} //"Grupo não encontrado." //"Não foram encontrados grupos com os filtros informados."
	EndIf
	aGroups := Nil
Return aReturnData

/*/{Protheus.doc} filterGroup
Verifica se um grupo atende aos requisitos de filtro - like ou código específico.

@author lucas.franca
@since 26/02/2025
@version P12
@param 01 aGroup   , Array    , Informações do grupo de usuário obtidos da função FWSFAllGrps
@param 02 cFilter  , Character, Filtro (like) para ID, Código ou Descrição
@param 03 cId      , Character, ID do grupo de usuário para busca
@return lFilter, Logical, Indica se o registro atual atende aos filtros
*/
Static Function filterGroup(aGroup as Array, cFilter as Character, cId as Character) as Logical
	Local lFilter := .T. as Logical

	If !Empty(cFilter)
		lFilter := Upper(cFilter) $ Upper(aGroup[2]) .Or. Upper(cFilter) $ Upper(aGroup[3]) .Or. Upper(cFilter) $ Upper(aGroup[4])
	EndIf
	If !Empty(cId)
		lFilter := Upper(aGroup[2]) == Upper(cId)
	EndIf
Return lFilter

/*/{Protheus.doc} getUsers
API para busca dos usuários do sistema
endpoint: [GET] api/pcp/v1/DTATool/generic/users

QUERYPARAM: 
- page -> número da página de pesquisa. Padrão = 1
- pageSize -> quantidade de registros por página. Padrão = 20
- filter -> filtro para busca de usuários (like em código/descrição do usuário)

@author lucas.franca
@since 26/02/2025
@version P12
@return lRet, Logical, Identifica se processou com sucesso a busca
/*/
Method getUsers() as Logical Class DTATool
	Local aReturnData      := {}  as Array
	Local jQueryParams     := Nil as Json
	Local jResponseMessage := Nil as Json
	Local lRet             := .T. as Logical
	Local nPage            := 1   as Numeric
	Local nPageSize        := 20  as Numeric

	oRest:setKeyHeaderResponse("Content-Type","application/json")

	jQueryParams := oRest:getQueryRequest()
	If !Empty(jQueryParams["page"])
		nPage := Val(jQueryParams["page"])
	EndIf
	If !Empty(jQueryParams["pageSize"])
		nPageSize := Val(jQueryParams["pageSize"])
	EndIf
	aReturnData      := PCPMonitorConsultas():BuscaUsuarios(nPage,nPageSize,,jQueryParams["filter"],"","",.F.)
	aReturnData[2]   := StrTran(aReturnData[2],"Code","code")
	aReturnData[2]   := StrTran(aReturnData[2],"Description","description")
	aReturnData[2]   := StrTran(aReturnData[2],"Email","email")
	jResponseMessage := JsonObject():New()
	jResponseMessage:FromJson(aReturnData[2])
	If Len(jResponseMessage["items"]) > 0
		oRest:setStatusCode(200)
	Else
		oRest:setStatusCode(404)
		jResponseMessage := {"code": "404", "message": STR0017, "detailedMessage": STR0018} //"Usuário não encontrado." //"Não foram encontrados usuários com os filtros informados."
	EndIf

	lRet := oRest:setResponse(jResponseMessage:toJson())
	jQueryParams := Nil
	FreeObj(jResponseMessage)
	FwFreeArray(aReturnData)
Return lRet

/*/{Protheus.doc} getUserByCode
API para busca de usuários por Código
endpoint: [GET] api/pcp/v1/DTATool/generic/users/:userCode

PATHPARAM:
-> userCode - código do usuário para busca

@author lucas.franca
@since 26/02/2025
@version P12
@return lRet, Logical, Identifica se processou com sucesso a busca
/*/
Method getUserByCode() as Logical Class DTATool
	Local aReturnData      := {}  as Array
	Local jPathParams      := Nil as Json
	Local jResponseMessage := Nil as Json
	Local lRet             := .T. as Logical

	oRest:setKeyHeaderResponse("Content-Type","application/json")

	jPathParams      := oRest:getPathParamsRequest()
	aReturnData      := PCPMonitorConsultas():BuscaUsuarios(1,1,jPathParams["userCode"],,"","",.F.)
	aReturnData[2]   := StrTran(aReturnData[2],"Code","code")
	aReturnData[2]   := StrTran(aReturnData[2],"Description","description")
	aReturnData[2]   := StrTran(aReturnData[2],"Email","email")
	jResponseMessage := JsonObject():New()
	jResponseMessage:FromJson(aReturnData[2])
	If Len(jResponseMessage["items"]) > 0
		oRest:setStatusCode(200)
		jResponseMessage := jResponseMessage["items"][1]
	Else
		oRest:setStatusCode(404)
		jResponseMessage := {"code": "404", "message": STR0017, "detailedMessage": STR0018} //"Usuário não encontrado." //"Não foram encontrados usuários com os filtros informados."
	EndIf

	lRet := oRest:setResponse(jResponseMessage:toJson())
	jPathParams  := Nil
	jQueryParams := Nil
	FreeObj(jResponseMessage)
	FwFreeArray(aReturnData)
Return lRet

/*/{Protheus.doc} patchCatalogChangeEnabledStatus
API para alterar o status de uma ferramenta (habilitado/desabilitado)
endpoint: [PATCH] api/pcp/v1/DTATool/catalog/change-enabled-status
body: {
	"toolCode": "Código da ferramenta",
	"enabled"  : "1 - habilitado; 2 - desabilitado"
}

@author lucas.franca
@since 26/02/2025
@version P12
@return lRet, Logical, Identifica se processou com sucesso a modificação
/*/
Method patchCatalogChangeEnabledStatus() as Logical Class DTATool
	Local aReturnData  := {}  as Array
	Local jBodyRequest := Nil as Json
	Local lRet         := .T. as Logical

	oRest:setKeyHeaderResponse("Content-Type","application/json")

	jBodyRequest := JsonObject():New()
	jBodyRequest:FromJson(oRest:getBodyRequest())
	aReturnData  := Self:processPatchCatalogChangeEnabledStatus(jBodyRequest)
	oRest:setStatusCode(aReturnData[1])
	lRet := oRest:setResponse(aReturnData[2]:toJson())
	FreeObj(jBodyRequest)
	FwFreeArray(aReturnData)
Return lRet

/*/{Protheus.doc} processPatchCatalogChangeEnabledStatus
Método que faz o processamento de atualização do status de uma ferramenta.

@author lucas.franca
@since 26/02/2025
@version P12
@param 01 jBodyRequest, Json, Objeto com os dados da requisição
@return aReturnData, Array, Array com informações da busca, onde:
                            [1] - Código HTTP para retorno da requisição (200-ok;400-BadRequest)
                            [2] - Objeto JSON com o status do processo
/*/
Method processPatchCatalogChangeEnabledStatus(jBodyRequest as Json) as Array Class DTATool
	Local aReturnData := {400, JsonObject():New()} as Array

	If Self:validateChangeEnabledStatus(@jBodyRequest, @aReturnData[2])
		RecLock("HZV", .F.)
			HZV->HZV_HABLTD := jBodyRequest["enabled"]
		HZV->(MsUnLock())
		aReturnData[1] := 200
		aReturnData[2]["code"  ] := 200
		aReturnData[2]["status"] := "OK"
	EndIf

Return aReturnData

/*/{Protheus.doc} validateChangeEnabledStatus
Faz as validações para atualização do status de uma ferramenta
Se os dados forem válidos, também irá manter a tabela HZV posicionada no registro a ser atualizado.

@author lucas.franca
@since 04/03/2025
@version P12
@param 01 jBodyRequest, Json, Objeto com os dados da requisição
@param 02 jReturn     , Json, Retorna por referência mensagem de erro
@return lRet, Logical, Identifica se os dados estão corretos.
/*/
Method validateChangeEnabledStatus(jBodyRequest as Json, jReturn as Json) as Logical Class DTATool
	Local lRet := .T. as Logical

	If lRet .And. Empty(jBodyRequest["toolCode"])
		lRet := .F.
		jReturn["message"        ] := STR0004 //"Código da ferramenta não informada."
		jReturn["detailedMessage"] := STR0019 //"É obrigatório informar o código da ferramenta (toolCode) para atualizar o status."
	EndIf
	If lRet .And. !DTALoad():toolExists(jBodyRequest["toolCode"])
		lRet := .F.
		jReturn["message"        ] := STR0020 //"Código da ferramenta não existe."
		jReturn["detailedMessage"] := I18N(STR0011, {RTrim(jBodyRequest["toolCode"])}) //"Não foram encontradas as informações da ferramenta #1[TOOLCODE]#."
	EndIf
	If lRet .And. (Empty(jBodyRequest["enabled"]) .Or. !(jBodyRequest["enabled"] == "1" .Or. jBodyRequest["enabled"] == "2"))
		lRet := .F.
		jReturn["message"        ] := STR0021 //"Status da ferramenta não informado."
		jReturn["detailedMessage"] := STR0022 //"É obrigatório informar o status da ferramenta para atualização (1 - habilitado; 2 - desabilitado)."
	EndIf
Return lRet

/*/{Protheus.doc} getAuthorizationGrantedUserGroups
API para buscar os grupos de usuários que já possuem algum acesso as ferramentas do DTA
endpoint: [GET] api/pcp/v1/DTATool/authorization/granted-user-groups
QUERYPARAM: 
- type -> tipo de busca (1-usuário; 2-grupo de usuário)
- code -> código do usuário/grupo de usuário - busca por like conforme parâmetro type. Se não tiver type, busca em grupo e usuário.

@author lucas.franca
@since 05/03/2025
@version P12
@return lRet, Logical, Identifica se processou com sucesso a busca
/*/
Method getAuthorizationGrantedUserGroups() as Logical Class DTATool
	Local aReturnData  := {}  as Array
	Local jQueryParams := Nil as Json
	Local lRet         := .T. as Logical

	oRest:setKeyHeaderResponse("Content-Type","application/json")

	jQueryParams := oRest:getQueryRequest()
	aReturnData := Self:processGetAuthorizationGrantedUserGroups(jQueryParams["type"], jQueryParams["code"])
	oRest:setStatusCode(aReturnData[1])
	lRet := oRest:setResponse(aReturnData[2]:toJson())
	jQueryParams := Nil
	FwFreeArray(aReturnData)
Return lRet

/*/{Protheus.doc} processGetAuthorizationGrantedUserGroups
Faz o processamento da busca de usuários/grupos com acessos as ferramentas do DTA

@author lucas.franca
@since 05/03/2025
@version P12
@param 01 cType    , Character, Filtro para tipo (1 - usuário; 2 - grupo de usuários)
@param 02 cCode    , Character, Filtro para código de usuário/grupo, conforme parâmetro Type. Se não tiver type, busca em ambos, sempre com LIKE %code%
@return aReturnData, Array, Array com informações da busca, onde:
                            [1] - Código HTTP para retorno da requisição (200-ok)
                            [2] - Objeto JSON com o status do processo
/*/
Method processGetAuthorizationGrantedUserGroups(cType as Character, cCode as Character) as Array Class DTATool
	Local aListData   := {}  as Array
	Local aReturnData := {}  as Array
	Local aFilters    := {}  as Array
	Local cAlias      := ""  as Character
	Local cQuery      := ""  as Character
	Local nIndex      := 0   as Numeric
	Local oQuery      := Nil as Object

	cQuery := "SELECT DISTINCT HZY.HZY_USUARI, HZY.HZY_GRPUSR"
	cQuery +=  " FROM " + RetSqlName("HZY") + " HZY"
	cQuery += " WHERE HZY.HZY_FILIAL = ?"
	cQuery +=   " AND HZY.D_E_L_E_T_ = ' '"
	aAdd(aFilters, xFilial("HZY"))

	If !Empty(cCode)
		If Empty(cType)
			cQuery += " AND (UPPER(HZY.HZY_USUARI) LIKE ? OR UPPER(HZY.HZY_GRPUSR) LIKE ?)"
			aAdd(aFilters, "%" + Upper(cCode) + "%")
			aAdd(aFilters, "%" + Upper(cCode) + "%")
		ElseIf cType == TYPE_USER
			cQuery += " AND UPPER(HZY.HZY_USUARI) LIKE ?"
			aAdd(aFilters, "%" + Upper(cCode) + "%")
		ElseIf cType == TYPE_GROUP
			cQuery += " AND UPPER(HZY.HZY_GRPUSR) LIKE ?"
			aAdd(aFilters, "%" + Upper(cCode) + "%")
		EndIf
	ElseIf !Empty(cType)
		If cType == TYPE_USER
			cQuery += " AND HZY.HZY_USUARI <> ' '"
		ElseIf cType == TYPE_GROUP
			cQuery += " AND HZY.HZY_GRPUSR <> ' '"
		EndIf
	EndIf
	cQuery += " ORDER BY HZY.HZY_USUARI, HZY.HZY_GRPUSR"

	oQuery := FwExecStatement():New(cQuery)
	oQuery:setParams(aFilters)
	cAlias := oQuery:openAlias()
	While (cAlias)->(!Eof())
		nIndex++

		aAdd(aListData, DTATool():getUserAccessObjectFromHZY(cAlias))
		aListData[nIndex]["actions"] := {"details"}

		(cAlias)->(dbSkip())
	End
	(cAlias)->(dbCloseArea())

	aReturnData := {200, JsonObject():New()}
	aReturnData[2]["hasNext"] := .F.
	aReturnData[2]["items"  ] := aListData
	aFilters  := Nil
	aListData := Nil
	oQuery:Destroy()
	FreeObj(oQuery)
Return aReturnData

/*/{Protheus.doc} getAuthorizationList
API para buscar a lista de ferramentas do DTA, indicando quais ferramentas o usuário/grupo possui acesso
endpoint: [GET] api/pcp/v1/DTATool/authorization/list/:code/:type
PATHPARAM: 
- code -> Código do usuário/grupo para busca
- type -> tipo de busca (1-usuário; 2-grupo de usuário)

@author lucas.franca
@since 05/03/2025
@version P12
@return lRet, Logical, Identifica se processou com sucesso a busca
/*/
Method getAuthorizationList() as Logical Class DTATool
	Local aReturnData := {}  as Array
	Local jPathParams := Nil as Json
	Local lRet        := .T. as Logical

	oRest:setKeyHeaderResponse("Content-Type","application/json")

	jPathParams := oRest:getPathParamsRequest()
	aReturnData := Self:processGetAuthorizationList(jPathParams["code"], jPathParams["type"])
	oRest:setStatusCode(aReturnData[1])
	lRet := oRest:setResponse(aReturnData[2]:toJson())
	jPathParams := Nil
	FwFreeArray(aReturnData)
Return lRet

/*/{Protheus.doc} processGetAuthorizationList
Faz o processamento da busca de acessos para um usuário ou grupo de usuário

@author lucas.franca
@since 05/03/2025
@version P12
@param 01 cCode    , Character, Código do usuário/grupo para busca (consulta por LIKE)
@param 02 cType    , Character, Identifica o tipo de busca (1-usuário; 2-grupo de usuário)
@return aReturnData, Array, Array com informações da busca, onde:
                            [1] - Código HTTP para retorno da requisição (200-ok;400-bad request)
                            [2] - Objeto JSON com o status do processo
/*/
Method processGetAuthorizationList(cCode as Character, cType as Character) as Array Class DTATool
	Local aReturnData := {}  as Array
	Local aAccessList := {}  as Array
	Local cQuery      := ""  as Character
	Local nIndex      := 0   as Numeric
	Local oQuery      := Nil as Object

	aReturnData := {200, JsonObject():New()}

	If !DTATool():validateType(cType)
		aReturnData[1] := 400
		aReturnData[2]["code"   ] := 400
		aReturnData[2]["message"] := STR0014 //"Tipo da permissão inválido."
		Return aReturnData
	EndIf

	cQuery := "SELECT HZV.HZV_FUNCAO,"
	cQuery +=       " HZV.HZV_DSCCUR,"
	cQuery +=       " HZV.HZV_GRUPO,"
	cQuery +=       " HZX.HZX_NOME,"
	cQuery +=       " HZY.R_E_C_N_O_ RECHZY "
	cQuery +=  " FROM " + RetSqlName("HZV") + " HZV"
	cQuery +=  " LEFT JOIN " + RetSqlName("HZY") + " HZY"
	cQuery +=    " ON HZY.HZY_FILIAL = ?"
	cQuery +=   " AND HZY.HZY_FUNCAO = HZV.HZV_FUNCAO"
	If cType == TYPE_USER
		cQuery += " AND HZY.HZY_USUARI = ?"
	Else
		cQuery += " AND HZY.HZY_GRPUSR = ?"
	EndIf
	cQuery +=   " AND HZY.D_E_L_E_T_ = ' '"
	cQuery +=  " LEFT JOIN " + RetSqlName("HZX") + " HZX"
	cQuery +=    " ON HZX.HZX_FILIAL = ?"
	cQuery +=   " AND HZX.HZX_GRUPO  = HZV.HZV_GRUPO"
	cQuery +=   " AND HZX.D_E_L_E_T_ = ' '"
	cQuery += " WHERE HZV.HZV_FILIAL = ?"
	cQuery +=   " AND HZV.D_E_L_E_T_ = ' '"
	cQuery += " ORDER BY HZV.HZV_FUNCAO"

	oQuery := FwExecStatement():New(cQuery)
	oQuery:setString(1, xFilial("HZY"))
	oQuery:setString(2, cCode)
	oQuery:setString(3, xFilial("HZX"))
	oQuery:setString(4, xFilial("HZV"))
	
	cAlias := oQuery:openAlias()

	While (cAlias)->(!Eof())
		nIndex++

		aAdd(aAccessList, JsonObject():New())
		aAccessList[nIndex]["toolCode"            ] := RTrim((cAlias)->HZV_FUNCAO)
		aAccessList[nIndex]["toolShortDescription"] := RTrim((cAlias)->HZV_DSCCUR)
		aAccessList[nIndex]["groupCode"           ] := RTrim((cAlias)->HZV_GRUPO)
		aAccessList[nIndex]["groupDescription"    ] := RTrim((cAlias)->HZX_NOME)
		aAccessList[nIndex]["hasAccess"           ] := !Empty((cAlias)->RECHZY)

		(cAlias)->(dbSkip())
	End
	(cAlias)->(dbCloseArea())

	aReturnData[2]["hasNext"] := .F.
	aReturnData[2]["items"  ] := aAccessList
	aAccessList := Nil
	oQuery:Destroy()
	FreeObj(oQuery)
Return aReturnData

/*/{Protheus.doc} getUserAccessObjectFromHZY
Monta um JSON formatado com as informações do usuário com acesso a ferramenta do DTA, a partir de informações da tabela HZY

@author lucas.franca
@since 05/03/2025
@version P12
@param 01 cAlias, Character, Alias com os dados da tabela HZY
@return jUserAccess, Json, Json formatado com as informações do acesso do usuário/grupo
/*/
Method getUserAccessObjectFromHZY(cAlias as Character) as Json Class DTATool
	Local jUserAccess := JsonObject():New() as Json

	If !Empty((cAlias)->HZY_USUARI)
		jUserAccess["type"] := TYPE_USER
		jUserAccess["code"] := RTrim((cAlias)->HZY_USUARI)
		jUserAccess["name"] := RTrim(FwGetUserName((cAlias)->HZY_USUARI))
	Else
		jUserAccess["type"] := TYPE_GROUP
		jUserAccess["code"] := RTrim((cAlias)->HZY_GRPUSR)
		jUserAccess["name"] := RTrim(DTATool():getGroupName((cAlias)->HZY_GRPUSR))
	EndIf
Return jUserAccess

/*/{Protheus.doc} postAuthorization
API para adicionar permissão de um usuário/grupo a várias ferramentas
endpoint: [POST] api/pcp/v1/DTATool/authorization
body: {
	"code"    : "Código do usuário/grupo",
	"type"    : "1 - usuário; 2 - grupo",
	"tools"   : ["code_tool_1", "code_tool_2", ...]
}

@author lucas.franca
@since 26/02/2025
@version P12
@return lRet, Logical, Identifica se processou com sucesso a inclusão
/*/
Method postAuthorization() as Logical Class DTATool
	Local aReturnData  := {}  as Array
	Local jBodyRequest := Nil as Json
	Local lRet         := .T. as Logical

	oRest:setKeyHeaderResponse("Content-Type","application/json")

	jBodyRequest := JsonObject():New()
	jBodyRequest:FromJson(oRest:getBodyRequest())
	aReturnData  := Self:processPostAuthorization(jBodyRequest)
	oRest:setStatusCode(aReturnData[1])
	lRet := oRest:setResponse(aReturnData[2]:toJson())
	FreeObj(jBodyRequest)
	FwFreeArray(aReturnData)
Return lRet

/*/{Protheus.doc} processPostAuthorization
Método que faz o processamento da atualização das ferramentas permitidas para um usuário/grupo
Irá apagar as permissões atuais, e adicionar a permissão para as ferramentas listadas em "tools".

@author lucas.franca
@since 05/03/2025
@version P12
@param 01 jBodyRequest, Json, Json da requisição com código da ferramenta, usuario/grupo e tipo
@return aReturnData, Array, Array com informações da busca, onde:
                            [1] - Código HTTP para retorno da requisição (201-ok;400-BadRequest)
                            [2] - Objeto JSON com o status do processo
*/
Method processPostAuthorization(jBodyRequest as Json) as Array Class DTATool
	Local aReturnData := {200, JsonObject():New()} as Array

	If Self:validateAuthorizationData(@jBodyRequest, @aReturnData[2])
		aReturnData[2]["code"  ] := 200
		aReturnData[2]["status"] := "OK"
		Self:updateAuthorization(jBodyRequest)
	EndIf
Return aReturnData

/*/{Protheus.doc} validateAuthorizationData
Faz as validações para atualização das permissões de um usuário/grupo

@author lucas.franca
@since 05/03/2025
@version P12
@param 01 jBodyRequest, Json, Objeto com os dados da requisição
@param 02 jReturn     , Json, Retorna por referência mensagem de erro
@return lRet, Logical, Identifica se os dados estão corretos.
/*/
Method validateAuthorizationData(jBodyRequest as Json, jReturn as Json) as Logical Class DTATool
	Local lRet   := .T. as Logical
	Local nIndex := 1   as Numeric

	If lRet .And. Empty(jBodyRequest["code"])
		lRet := .F.
		jReturn["message"        ] := STR0006 //"Código do usuário/grupo não informado."
		jReturn["detailedMessage"] := STR0007 //"É obrigatório informar o código do usuário/grupo (code) para adicionar a autorização.."
	EndIf
	If lRet .And. !DTATool():validateType(jBodyRequest["type"])
		lRet := .F.
		jReturn["message"        ] := STR0008 //"Tipo da permissão não informada."
		jReturn["detailedMessage"] := STR0009 //"É obrigatório informar o tipo da permissão (1 - usuário; 2 - grupo) para adicionar a autorização."
	EndIf
	If lRet .And. !UsrExist(jBodyRequest["code"], jBodyRequest["type"] == TYPE_USER)
		lRet := .F.
		jReturn["message"        ] := STR0012 //"Código do usuário/grupo inválido."
		jReturn["detailedMessage"] := I18N(STR0013, {RTrim(jBodyRequest["code"])}) //"Não foram encontradas as informações do usuário/grupo #1[USERCODE]#."
	EndIf
	If lRet .And. ValType(jBodyRequest["tools"]) != "A"
		lRet := .F.
		jReturn["message"        ] := STR0023 //"Ferramentas não informadas."
		jReturn["detailedMessage"] := STR0024 //"É obrigatório informar a lista de ferramentas (tools) para modificar as autorizações."
	EndIf
	While lRet .And. nIndex <= Len(jBodyRequest["tools"])
		If Empty(jBodyRequest["tools"][nIndex]) .Or. !DTALoad():toolExists(jBodyRequest["tools"][nIndex])
			lRet := .F.
			jReturn["message"        ] := STR0010 //"Código da ferramenta inválido."
			jReturn["detailedMessage"] := I18N(STR0011, {RTrim(jBodyRequest["tools"][nIndex])}) //"Não foram encontradas as informações da ferramenta #1[TOOLCODE]#."
		EndIf
		nIndex++
	EndDo
Return lRet

/*/{Protheus.doc} updateAuthorization
Atualiza as autorizações de um usuário/grupo, removendo as permissões atuais e adicionando
as permissões para as ferramentas listadas em "tools".

@author lucas.franca
@since 05/03/2025
@version P12
@param 01 jBodyRequest, Json, Objeto com os dados da requisição
@return Nil
/*/
Method updateAuthorization(jBodyRequest as Json) Class DTATool
	Local aData      := {}  as Array
	Local cField     := ""  as Character
	Local lRet       := .T. as Logical
	Local nIndexHZY  := 0   as Numeric
	Local nIndexTool := 1   as Numeric
	Local nTotalTool := 0   as Numeric
	Local oInsertHZY := Nil as Object

	If jBodyRequest["type"] == TYPE_USER
		cField    := "HZY_USUARI"
		nIndexHZY := 2
		jBodyRequest["code"] := PadR(jBodyRequest["code"], GetSX3Cache("HZY_USUARI", "X3_TAMANHO"))
	Else
		cField    := "HZY_GRPUSR"
		nIndexHZY := 3
		jBodyRequest["code"] := PadR(jBodyRequest["code"], GetSX3Cache("HZY_GRPUSR", "X3_TAMANHO"))
	EndIf

	aData      := {xFilial("HZY"), "", jBodyRequest["code"]}
	nTotalTool := Len(jBodyRequest["tools"])
	oInsertHZY := FwBulk():New(RetSqlName("HZY"))
	oInsertHZY:setFields({{"HZY_FILIAL"}, {"HZY_FUNCAO"}, {cField}})
	
	HZY->(dbSetOrder(nIndexHZY))
	HZY->(dbSeek(xFilial("HZY") + jBodyRequest["code"]))
	Begin Transaction
		While !HZY->(Eof()) .And. HZY->HZY_FILIAL == xFilial("HZY") .And. &("HZY->" + cField) == jBodyRequest["code"]
			RecLock("HZY", .F.)
				HZY->(dbDelete())
			HZY->(MsUnLock())
			HZY->(dbSkip())
		EndDo

		While lRet .And. nIndexTool <= nTotalTool
			aData[2] := jBodyRequest["tools"][nIndexTool]
			lRet     := oInsertHZY:addData(aData)
			nIndexTool++
		EndDo
		lRet := lRet .And. oInsertHZY:close()
		If !lRet
			UserException(STR0025 + " " + oInsertHZY:getError()) //"Erro ao atualizar as permissões (HZY)."
		EndIf
	End Transaction

	oInsertHZY:Destroy()
	FreeObj(oInsertHZY)
	aSize(aData, 0)
Return Nil

/*/{Protheus.doc} getGroupName
Retorna o nome de um grupo de usuários

@author lucas.franca
@since 26/02/2025
@version P12
@param 01 cGroupCode, Character, Código do grupo de usuário
@return cName, Character, Nome do grupo de usuário
*/
Method getGroupName(cGroupCode as Character) as Character Class DTATool
	Local aGroups := {} as Array
	Local cName   := "" as Character
	Local nIndex  := 0  as Numeric

	aGroups := FWSFAllGrps(.T.)
	nIndex  := aScan(aGroups, {|x| x[2] == cGroupCode})
	If nIndex > 0
		cName := aGroups[nIndex][4]
	EndIf
	aGroups := Nil
Return cName

/*/{Protheus.doc} postLoadTools
API para fazer a carga das ferramentas
endpoint: [POST] api/pcp/v1/DTATool/loadTools

@author lucas.franca/renan.roeder
@since 28/04/2025
@version P12
@return lRet, Logical, Identifica se processou com sucesso a carga de ferramentas
/*/
Method postLoadTools() as Logical Class DTATool
	Local aErrors   := {}  as Array
	Local jResponse := Nil as Json
	Local lRet      := .T. as Logical

	oRest:setKeyHeaderResponse("Content-Type","application/json")

	aErrors := DTALoad():loadDefaultTools()
	If !Empty(aErrors)
		jResponse := JsonObject():New()
		jResponse["listOfErrors"] := aErrors
		oRest:setStatusCode(400)
		lRet := oRest:setResponse(jResponse:toJson())
		aSize(aErrors, 0)
		FwFreeObj(jResponse)
	Else
		oRest:setStatusCode(201)
	EndIf
Return lRet
