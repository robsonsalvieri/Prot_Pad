#INCLUDE "MATA610.CH"
#INCLUDE "PROTHEUS.CH"
#INCLUDE "FWADAPTEREAI.CH"

/*


Ŀ
Funo     MATA610   Autor  Eveli Morasco           Data  03/02/93 
Ĵ
Descrio  Programa de atualizacao do cadastro de Recursos             
Ĵ
Uso        Generico                                                    
Ĵ
 ATUALIZACOES SOFRIDAS DESDE A CONSTRUCAO INICIAL.                      
Ĵ
 PROGRAMADOR   DATA    BOPS   MOTIVO DA ALTERACAO                    
Ĵ
 Rodrigo Sart.13/08/9812199AIncluida verificacao do recurso apos a   
                            digitacao                                
 Aline C. Vale19/04/99PROTHEAjuste para compilacao Protheus          
 Patricia Sal.07/04/00003506A610Del(): Antes de excluir o recurso,ve-
                            rificar se o mesmo esta cadastrado em al-
                            gum roteiro de operacoes (SG2).          
ٱ




Ŀ
Descrio  PLANO DE MELHORIA CONTINUA                                 
Ĵ
ITEM PMC   Responsavel               Data         |BOPS:		      
Ĵ
      01                                          |                  
      02  Erike Yuri da Silva       30/03/2006    |00000095925       
      03                                          |                  
      04                                          |                  
      05                                          |                  
      06                                          |                  
      07                                          |                  
      08                                          |                  
      09                                          |                  
      10  Erike Yuri da Silva       30/03/2006    |00000095925       
ٱ


*/
Function MATA610(xAutoCab,xAutoItens,nOpcAuto)
PRIVATE aTELA[0][0],aGETS[0],bCampo1 := { |nCPO| Field(nCPO) }, nCampos := 0

//Ŀ
// Define Array contendo as Rotinas a executar do programa      
// ----------- Elementos contidos por dimensao ------------     
// 1. Nome a aparecer no cabecalho                              
// 2. Nome da Rotina associada                                  
// 3. Usado pela rotina                                         
// 4. Tipo de Transao a ser efetuada                          
//    1 - Pesquisa e Posiciona em um Banco de Dados             
//    2 - Simplesmente Mostra os Campos                         
//    3 - Inclui registros no Bancos de Dados                   
//    4 - Altera o registro corrente                            
//    5 - Remove o registro corrente do Banco de Dados          
//
PRIVATE aRotina := MenuDef()
PRIVATE lA610Auto := .F.

If  ( xAutoCab <> Nil )

	PRIVATE aAutoCab   := Aclone(xAutoCab)
	PRIVATE aAutoItens := Aclone(xAutoItens)

	DEFAULT nOpcAuto   := 3

	lA610Auto := .T.

Else

	If TipoAps()
		Aadd(aRotina, {STR0007, "A610MtzSetup", 0, 4, 0, nil}) //"Matriz Setup"
	Endif

EndIf

//Ŀ
// Define o cabecalho da tela de atualizacoes                   
//
PRIVATE cCadastro := OemToAnsi(STR0006)	//"Recursos"
PRIVATE aHeaReSe  := {}
PRIVATE aColReSe  := {}
PRIVATE aRegReSe  := {}
PRIVATE aHeaSePr  := {}
PRIVATE aColSePr  := {}
PRIVATE aRegSePr  := {}
PRIVATE nOpcRot


//Ŀ
// Endereca a funcao de BROWSE                                  
//
If lA610Auto
	MBrowseAuto(nOpcAuto,aAutoCab,"SH1")
Else
	mBrowse( 6, 1,22,75,"SH1")
EndIf

//Ŀ
// Recupera a Integridade dos dados                             
//
MsUnLockAll()
Return Nil

/*


Ŀ
Funo    A610Visual Autor  Eveli Morasco           Data  03/02/93 
Ĵ
Descrio  Programa de visualizacao de recursos                        
Ĵ
Sintaxe    A610Visual(ExpC1,ExpN1,ExpN2)                               
Ĵ
Parametros ExpC1 = Alias do Arquivo                                    
           ExpN1 = Numero do registro                                  
           ExpN2 = Opcao escolhida                                     
Ĵ
Uso        MATA610                                                     
ٱ


*/
Function A610Visual(cAlias,nReg,nOpc)
LOCAL i:=0
LOCAL nUsado:=0,nCnt:=0 // Variaveis utilizadas na montagem do Acols/Aheader
LOCAL aSize:={}
LOCAL aInfo:={}
LOCAL aObjects:={}
LOCAL aPosObj:={}
Local oGet

PRIVATE aButtons := {}
PRIVATE aHeader:={}
PRIVATE nPosAtu:=0,nPosAnt:=9999,nColAnt:=9999,cArqF3,cCampoF3 // Utilizado na Get Dados
// Posicao do Recurso ,do Tipo e da Descricao no ACols
PRIVATE nPosRec:=0,nPosTp:=0,nPosDescri:=0
PRIVATE aTELA[0][0],aGETS[0]
private aCols := {}

If Type("cCadastro") == "U"
	PRIVATE cCadastro := OemToAnsi(STR0006)	//"Recursos"
EndIf

If TipoAps()
	Aadd(aButtons, {"FERRAM" , {|| A610EditRestr()}, STR0008}) //"Restricoes Secundarias"
	Aadd(aButtons, {"BALANCA", {|| A610EditSeque()}, STR0009}) //"Sequencia Preferida"
Endif

nOpcRot   := nOpc
aColReSe  := {}
aRegReSe  := {}
aColSePr  := {}
aRegSePr  := {}
IF H1_FILIAL != xFilial("SH1")
	HELP(" ",1,"A000FI")
	Return (.T.)
Endif

dbSelectArea("SH1")
FOR i := 1 TO FCount()
	M->&(EVAL(bCampo1,i)) := FieldGet(i)
	nCampos++
NEXT i

//Ŀ
//Conta quantas linhas tera a GetDados (nCnt)                            
//
dbSelectArea("SH2")
dbSetOrder(1)
dbSeek(xFilial("SH2")+SH1->H1_CODIGO)
While !Eof() .And. H2_FILIAL+H2_RECPRIN == xFilial("SH2")+SH1->H1_CODIGO
	nCnt++
	dbSkip()
End

//Ŀ
//Montagem do AHeader para GetDados dos Recursos Alternativos/Secundarios
//

aHeader    := A610CriaHeader("SH2", "H2_RECPRIN",, .T./*lWalkThru*/ )

nPosRec    := GDFieldPos("H2_RECALTE")
nPosDescri := GDFieldPos("H2_DESCRI")
nPosTp     := GDFieldPos("H2_TIPO")

aCols := A610CriaCols("SH2", aHeader, xFilial("SH2") + SH1->H1_CODIGO, {|| SH2->(H2_FILIAL + H2_RECPRIN) == xFilial("SH2") + SH1->H1_CODIGO})[1]

a610ColDesc()

nOpca:=0

AADD(aObjects,{100,100,.T.,.T.,.F.}) // Indica dimensoes x e y e indica que redimensiona x e y e assume que retorno sera em linha final coluna final (.F.)
AADD(aObjects,{100,100,.T.,.T.,.F.}) // Indica dimensoes x e y e indica que redimensiona x e y

aSize  :=MsAdvSize()
aInfo  :={aSize[1],aSize[2],aSize[3],aSize[4],3,3}
aPosObj:=MsObjSize(aInfo,aObjects)

DEFINE MSDIALOG oDlg TITLE cCadastro From aSize[7],0 to aSize[6],aSize[5] of oMainWnd PIXEL

	EnChoice("SH1",nReg,nOpc,,,,,aPosObj[1],,3)
	oGet := MSGetDados():New(aPosObj[2,1],aPosObj[2,2],aPosObj[2,3],aPosObj[2,4],nOpc,"A610Linok","AllwaysTrue","",,,,,200)
ACTIVATE MSDIALOG oDlg ON INIT EnchoiceBar(oDlg,{||oDlg:End()},{||oDlg:End()},,aButtons)

//Ŀ
// Restaura a integridade da janela                             
//
dbSelectArea(cAlias)
Return Nil

/*


Ŀ
Funo    A610Inclui Autor  Eveli Morasco           Data  03/02/93 
Ĵ
Descrio  Programa de inclusao de recursos                            
Ĵ
Sintaxe    A610Inclui(ExpC1,ExpN1,ExpN2)                               
Ĵ
Parametros ExpC1 = Alias do Arquivo                                    
           ExpN1 = Numero do registro                                  
           ExpN2 = Opcao escolhida                                     
Ĵ
Uso        MATA610                                                     
ٱ


*/
Function A610Inclui(cAlias,nReg,nOpc)
Local oDlg
Local oGet
Local nOpca		:= 0
Local nUsado	:= 0
Local aSize		:= {}
Local aInfo		:= {}
Local aObjects	:= {}
Local aPosObj	:= {}
Local aHeaderBkp:= {}
Local aColsBkp	:= {}
Local nBkp
Local i
Local aRotBkp := {}

If Type("aHeader") <> "U"
	aHeaderBkp := aClone(aHeader)
EndIf

If Type("aRotina") == "U"
	Private aRotina := MenuDef()
EndIf

If Type("aCols") <> "U"
	aColsBkp := aClone(aCols)
EndIf

If Type("n") <> "U"
	nBkp := n
	n := 1
EndIf

Private aButtons:= {}
Private aHeader	:={}
Private aCols  	:={}
Private nPosAtu :=0,nPosAnt:=9999,nColAnt:=9999,cArqF3,cCampoF3 // Utilizado na Get Dados

// Posicao do Recurso ,do Tipo e da Descricao no ACols
Private nPosRec :=0,nPosTp:=0,nPosDescri:=0
Private aTELA := {}
Private aGETS := {}
Private bCampo1 := { |nCPO| Field(nCPO) }, nCampos := 0

If Type("lA610Auto") == "U"
	Private lA610Auto := .F.
EndIf

If Type("cCadastro") == "U"
	PRIVATE cCadastro := OemToAnsi(STR0006)	//"Recursos"
EndIf

Default nOpc := 3

aArea	:= GetArea()

If !lA610Auto .AND. TipoAps()
	Aadd(aButtons, {"FERRAM" , {|| A610EditRestr()}, STR0008}) //"Restricoes Secundarias"
	Aadd(aButtons, {"BALANCA", {|| A610EditSeque()}, STR0009}) //"Sequencia Preferida"
Endif

nOpcRot   := nOpc
aColReSe  := {}
aRegReSe  := {}
aColSePr  := {}
aRegSePr  := {}
aHeaReSe  := {}
aHeaSePr  := {}

dbSelectArea("SH1")
FOR i := 1 TO FCount()
	M->&(EVAL(bCampo1,i)) := FieldGet(i)
	lInit := .F.
	If ExistIni(EVAL(bCampo1,i))
		lInit := .t.
		M->&(EVAL(bCampo1,i)) := InitPad(SX3->X3_RELACAO)
		If ValType(M->&(EVAL(bCampo1,i))) = "C"
			M->&(EVAL(bCampo1,i)) := PADR(M->&(EVAL(bCampo1,i)),SX3->X3_TAMANHO)
		Endif
		If M->&(EVAL(bCampo1,i)) == NIL
			lInit := .F.
		EndIf
	EndIf
	If !lInit
		IF ValType(M->&(EVAL(bCampo1,i))) == "C"
			M->&(EVAL(bCampo1,i)) := SPACE(LEN(M->&(EVAL(bCampo1,i))))
		ELSEIF ValType(M->&(EVAL(bCampo1,i))) == "N"
			M->&(EVAL(bCampo1,i)) := 0
		ELSEIF ValType(M->&(EVAL(bCampo1,i))) == "D"
			M->&(EVAL(bCampo1,i)) := cToD("  /  /  ")
		ELSEIF ValType(M->&(EVAL(bCampo1,i))) == "L"
			M->&(EVAL(bCampo1,i)) := .F.
		ENDIF
	EndIf
Next i

//Ŀ
//Montagem do AHeader para GetDados dos Recursos Alternativos/Secundarios
//

aHeader    := A610CriaHeader("SH2", "H2_RECPRIN",, .T./*lWalkThru*/ )

nPosRec    := GDFieldPos("H2_RECALTE")
nPosDescri := GDFieldPos("H2_DESCRI")
nPosTp     := GDFieldPos("H2_TIPO")

//Ŀ
//Montagem do ACols para GetDados dos Recursos Alternativos/Secundarios  
//

aCols := A610CriaCols("SH2", aHeader, xFilial("SH2") + M->H1_CODIGO, {|| SH2->(H2_FILIAL + H2_RECPRIN) == xFilial("SH2") + M->H1_CODIGO})[1]

a610ColDesc()

nOpca:=0

If  !lA610Auto

	AADD(aObjects,{100,100,.T.,.T.,.F.}) // Indica dimensoes x e y e indica que redimensiona x e y e assume que retorno sera em linha final coluna final (.F.)
	AADD(aObjects,{100,100,.T.,.T.,.F.}) // Indica dimensoes x e y e indica que redimensiona x e y
	aSize:=MsAdvSize()
	aInfo:={aSize[1],aSize[2],aSize[3],aSize[4],3,3}
	aPosObj:=MsObjSize(aInfo,aObjects)

	aRotBkp := aClone(aRotina)
	aRotina := { { " "," ",0,1 } ,{ " "," ",0,2 },{ " "," ",0,3 } }

	DEFINE MSDIALOG oDlg TITLE cCadastro From aSize[7],0 to aSize[6],aSize[5] of oMainWnd PIXEL

		EnChoice("SH1",nReg,nOpc,,,,,aPosObj[1],,3,,,"A610TudoOk()")
		oGet := MSGetDados():New(aPosObj[2,1],aPosObj[2,2],aPosObj[2,3],aPosObj[2,4],nOpc,"A610LinOK","A610TudoOk","",.T.,,,,200)


	ACTIVATE MSDIALOG oDlg ON INIT EnchoiceBar(oDlg,{||nOpca:=1,If(Obrigatorio(aGets,aTela) .And. oGet:TudoOk() .And. A610PEOK(nOpc),oDlg:End(),nOpca:= 0)},{||oDlg:End()},,aButtons)

	aRotina := aClone(aRotBkp)

Else
	//Ŀ
	//Validando dados pela rotina automatica 
	//
	If EnchAuto(cAlias,aAutoCab,{|| Obrigatorio(aGets,aTela)}) .and. MsGetDAuto(aAutoItens,"A610Linok",{||nOpcA:=If(A610TudoOk().And.A610PEOK(nOpc),1,0),nOpcA==1},aAutoCab)
		nOpcA := 1
	Else
		nOpcA := 0
	EndIf

EndIf

If nOpcA == 1

	Begin Transaction

		A610Grava(cAlias,aCols,nReg,nOpc)
		//Ŀ
		//Processa Gatilhos 
		//
		EvalTrigger()

	End Transaction

	IF ExistBlock("MT610INC")
	    ExecBlock("MT610INC",.F.,.F.)
	Endif

Else
	RollBackSx8()
EndIf

//Ŀ
// Restaura a integridade da janela                             
//
If !Empty(aHeaderBkp)
	aHeader := aClone(aHeaderBkp)
EndIf

If !Empty(aColsBkp)
	aCols	:= aClone(aColsBkp)
EndIf

If !Empty(nBkp)
	n := nBkp
EndIf

dbSelectArea(cAlias)
Return nOpca

/*


Ŀ
Funo    A610Altera Autor  Eveli Morasco           Data  04/02/93 
Ĵ
Descrio  Programa de alteracao de recursos                           
Ĵ
Sintaxe    A610Altera(ExpC1,ExpN1,ExpN2)                               
Ĵ
Parametros ExpC1 = Alias do Arquivo                                    
           ExpN1 = Numero do registro                                  
           ExpN2 = Opcao escolhida                                     
Ĵ
Uso        MATA610                                                     
ٱ


*/
Function A610Altera(cAlias,nReg,nOpc)
LOCAL nOpca := 0,i:=0
LOCAL nUsado:=0,nCnt:=0 // Variaveis utilizadas na montagem do Acols/Aheader
LOCAL oDlg
LOCAL aSize:={}
LOCAL aInfo:={}
LOCAL aObjects:={}
LOCAL aPosObj:={}
PRIVATE aButtons := {}
Private aTELA[0][0],aGETS[0]
PRIVATE aHeader:={}
PRIVATE nPosAtu:=0,nPosAnt:=9999,nColAnt:=9999,cArqF3,cCampoF3 // Utilizado na Get Dados
// Posicao do Recurso ,do Tipo e da Descricao no ACols
PRIVATE nPosRec:=0,nPosTp:=0,nPosDescri:=0
private aCols := {}

If !lA610Auto .AND. TipoAps()
	Aadd(aButtons, {"FERRAM" , {|| A610EditRestr()}, STR0008}) //"Restricoes Secundarias"
	Aadd(aButtons, {"BALANCA", {|| A610EditSeque()}, STR0009}) //"Sequencia Preferida"
Endif

nOpcRot   := nOpc
aColReSe  := {}
aRegReSe  := {}
aColSePr  := {}
aRegSePr  := {}
IF H1_FILIAL != xFilial("SH1")
	HELP(" ",1,"A000FI")
	Return (.T.)
Endif

dbSelectArea("SH1")
FOR i := 1 TO FCount()
	M->&(EVAL(bCampo1,i)) := FieldGet(i)
	nCampos++
NEXT i

//Ŀ
//Conta quantas linhas tera a GetDados (nCnt)                            
//
dbSelectArea("SH2")
dbSetOrder(1)
dbSeek(xFilial("SH2")+SH1->H1_CODIGO)
While !Eof() .And. H2_FILIAL+H2_RECPRIN == xFilial("SH2")+SH1->H1_CODIGO
	nCnt++
	dbSkip()
End

//Ŀ
//Montagem do AHeader para GetDados dos Recursos Alternativos/Secundarios
//

aHeader    := A610CriaHeader("SH2", "H2_RECPRIN",, .T./*lWalkThru*/ )

nPosRec    := GDFieldPos("H2_RECALTE")
nPosDescri := GDFieldPos("H2_DESCRI")
nPosTp     := GDFieldPos("H2_TIPO")

//Ŀ
//Montagem do ACols para GetDados dos Recursos Alternativos/Secundarios  
//

aCols := A610CriaCols("SH2", aHeader, xFilial("SH2") + SH1->H1_CODIGO, {|| SH2->(H2_FILIAL + H2_RECPRIN) == xFilial("SH2") + SH1->H1_CODIGO})[1]

a610ColDesc()

nOpca:=0

If  !lA610Auto

	AADD(aObjects,{100,100,.T.,.T.,.F.}) // Indica dimensoes x e y e indica que redimensiona x e y e assume que retorno sera em linha final coluna final (.F.)
	AADD(aObjects,{100,100,.T.,.T.,.F.}) // Indica dimensoes x e y e indica que redimensiona x e y
	aSize:=MsAdvSize()
	aInfo:={aSize[1],aSize[2],aSize[3],aSize[4],3,3}
	aPosObj:=MsObjSize(aInfo,aObjects)

	DEFINE MSDIALOG oDlg TITLE cCadastro From aSize[7],0 to aSize[6],aSize[5] of oMainWnd PIXEL
		EnChoice("SH1",nReg,nOpc,,,,,aPosobj[1],,3)
		oGet := MSGetDados():New(aPosObj[2,1],aPosObj[2,2],aPosObj[2,3],aPosObj[2,4],nOpc,"A610LinOK","A610TudoOK","",.T.,,,,200)
	ACTIVATE MSDIALOG oDlg ON INIT EnchoiceBar(oDlg,{||nOpca:=1,If( Obrigatorio(aGets,aTela) .And. oGet:TudoOk() .And. A610PEOK(nOpc),oDlg:End(),nOpca:= 0)},{||oDlg:End()},,aButtons)
Else

	//Ŀ
	//Validando dados pela rotina automatica 
	//
	If EnchAuto(cAlias,aAutoCab,{|| Obrigatorio(aGets,aTela)},aRotina[nOpc][4]) .and. MsGetDAuto(aAutoItens,"A610Linok",{||nOpcA:=If(A610TudoOk() .And. A610PEOK(nOpc),1,0),nOpcA==1},aAutoCab,aRotina[nOpc][4])
		nOpcA := 1
	Else
		nOpcA := 0
	EndIf

EndIf

If nOpcA == 1
	Begin Transaction
		A610Grava(cAlias,aCols,nReg,nOpc)
		//Ŀ
		//  Processa Gatilhos                                   
		//
		EvalTrigger()
	End Transaction
Endif

//Ŀ
// Restaura a integridade da janela                             
//
dbSelectArea(cAlias)
Return Nil

/*


Ŀ
Funo    A610Deleta Autor  Eveli Morasco           Data  04/02/93 
Ĵ
Descrio  Programa de exclusao de recursos                            
Ĵ
Sintaxe    A610Deleta(ExpC1,ExpN1,ExpN2)                               
Ĵ
Parametros ExpN1 = Alias do Arquivo                                    
           ExpC1 = Numero do registro                                  
           ExpC2 = Opcao escolhida                                     
Ĵ
Uso        MATA610                                                     
ٱ


*/
Function A610Deleta(cAlias,nReg,nOpc)
LOCAL i
LOCAL nUsado:=0,nCnt:=0 // Variaveis utilizadas na montagem do Acols/Aheader
LOCAL oDlg
LOCAL aSize:={}
LOCAL aInfo:={}
LOCAL aObjects:={}
LOCAL aPosObj:={}
PRIVATE aButtons:={}
PRIVATE aHeader:={}
PRIVATE nPosAtu:=0,nPosAnt:=9999,nColAnt:=9999,cArqF3,cCampoF3 // Utilizado na Get Dados
// Posicao do Recurso ,do Tipo e da Descricao no ACols
PRIVATE nPosRec:=0,nPosTp:=0,nPosDescri:=0
PRIVATE aTELA[0][0],aGETS[0]
private aCols := {}

If !lA610Auto .AND. TipoAps()
	Aadd(aButtons, {"FERRAM" , {|| A610EditRestr()}, STR0008}) //"Restricoes Secundarias"
	Aadd(aButtons, {"BALANCA", {|| A610EditSeque()}, STR0009}) //"Sequencia Preferida"
Endif

nOpcRot   := nOpc
aColReSe  := {}
aRegReSe  := {}
aColSePr  := {}
aRegSePr  := {}
IF H1_FILIAL != xFilial("SH1")
	HELP(" ",1,"A000FI")
	Return (.T.)
Endif

dbSelectArea("SH1")
FOR i := 1 TO FCount()
	M->&(EVAL(bCampo1,i)) := FieldGet(i)
	nCampos++
NEXT i

//Ŀ
//Conta quantas linhas tera a GetDados (nCnt)                            
//
dbSelectArea("SH2")
dbSetOrder(1)
dbSeek(xFilial("SH2")+SH1->H1_CODIGO)
While !Eof() .And. H2_FILIAL+H2_RECPRIN == xFilial("SH2")+SH1->H1_CODIGO
	nCnt++
	dbSkip()
End

aHeader    := A610CriaHeader("SH2", "H2_RECPRIN",, .T./*lWalkThru*/ )

nPosRec    := GDFieldPos("H2_RECALTE")
nPosDescri := GDFieldPos("H2_DESCRI")
nPosTp     := GDFieldPos("H2_TIPO")

//Ŀ
//Montagem do ACols para GetDados dos Recursos Alternativos/Secundarios  
//

aCols := A610CriaCols("SH2", aHeader, xFilial("SH2") + SH1->H1_CODIGO, {|| SH2->(H2_FILIAL + H2_RECPRIN) == xFilial("SH2") + SH1->H1_CODIGO})[1]

a610ColDesc()

nOpca:=0

If  !lA610Auto

	AADD(aObjects,{100,100,.T.,.T.,.F.}) // Indica dimensoes x e y e indica que redimensiona x e y e assume que retorno sera em linha final coluna final (.F.)
	AADD(aObjects,{100,100,.T.,.T.,.F.}) // Indica dimensoes x e y e indica que redimensiona x e y
	aSize:=MsAdvSize()
	aInfo:={aSize[1],aSize[2],aSize[3],aSize[4],3,3}
	aPosObj:=MsObjSize(aInfo,aObjects)
	DEFINE MSDIALOG oDlg TITLE cCadastro From aSize[7],0 to aSize[6],aSize[5] of oMainWnd PIXEL
	EnChoice("SH1",nReg,nOpc,,,,,aPosobj[1],,3)
	oGet := MSGetDados():New(aPosObj[2,1],aPosObj[2,2],aPosObj[2,3],aPosObj[2,4],nOpc,"A610Linok","AllwaysTrue","",,,,,200)
	ACTIVATE MSDIALOG oDlg ON INIT EnchoiceBar(oDlg,{||nOpca:=1,If(A610PEOK(nOpc),oDlg:End(),nOpca:=0)},{||oDlg:End()},,aButtons)

Else

	//Ŀ
	//Validando dados pela rotina automatica 
	//
	If EnchAuto(cAlias,aAutoCab,{|| Obrigatorio(aGets,aTela)},aRotina[nOpc][4])
		//Quando  Rotina automtica, o MSGetDAuto no executa o TudoOk, por isso valida separadamente.
		nOpcA := Iif(A610TudoOk() .And. A610PEOK(nOpc),1,0)
	Else
		nOpcA := 0
	EndIf

EndIf

If nOpcA == 1
	A610Del(cAlias)
	//Ŀ
	//  Processa Gatilhos                                   
	//
	EvalTrigger()
Endif
//Ŀ
// Restaura a integridade da janela                             
//
Return nOpca

/*

Ŀ
Funo    A610ColDesc    Autor Marcelo Iuspa       Data  02/12/02 
Ĵ
Descrio Preenche descricao do recurso no aCols                      
Ĵ
Sintaxe   A610ColDesc                                                 
Ĵ
 Uso      MATA610                                                     
ٱ


*/
Function A610ColDesc()
Local nRecno := SH1->(RecNo())
Local nOrd   := SH1->(IndexOrd())
Local nPosRec:= GDFieldPos("H2_RECALTE")
Local i

If nPosRec > 0 .And. nPosDescri > 0
	SH1->(dbSetOrder(1))
	For i:=1 to Len(aCols)
		If SH1->(dbSeek(xFilial("SH1")+aCols[i,nPosRec]))
			aCols[i,nPosDescri]:=SH1->H1_DESCRI
		EndIf
	Next i
	SH1->(dbSetOrder(nOrd))
	SH1->(dbGoto(nRecno))
Endif

Return(.T.)

/*


Ŀ
Funo     A610Grava Autor  Eveli Morasco          Data  03/02/93 
Ĵ
Descrio  Grava dados dos recursos                                   
Ĵ
Sintaxe    A610Grava(ExpC1,ExpA1,ExpN1,ExpN2)                         
Ĵ
Parametros ExpC1 = Alias do Arquivo                                   
           ExpA1 = Array com Recursos Alternativos/Secundarios        
           ExpN1 = Registro a ser alterado do SH1                     
           ExpN2 = Tipo de Operao                                   
Ĵ
 Uso       MATA610                                                    
ٱ


*/
Function A610Grava(cAlias,aCols,nReg,nOpc)
Local i := 0
Local nCntDele := 0
Local nX := 0

dbSelectArea(cAlias)
Inclui := (nOpc == 3)
If Inclui
	RecLock(cAlias,.T.)
Else
	dbGoto(nReg)
	RecLock(cAlias,.F.)
EndIf
For i := 1 TO FCount()
	If "FILIAL"$Field(i)
		FieldPut(i,xFilial(cAlias))
	Else
		FieldPut(i,M->&(EVAL(bCampo1,i)))
	EndIf
Next i
If Inclui .And. nPosRec > 0
	//Ŀ
	// Grava Recursos Alternativos                                  
	//
	For i:=1 To Len(aCols)
		If !(Empty(aCols[i,nPosRec]))
			If !(aCols[i,Len(aCols[i])])
				RecLock("SH2",.T.)
				Replace  H2_FILIAL  With xFilial("SH2"), H2_RECPRIN With M->H1_CODIGO
				For nX := 1 To Len(aHeader)-2
					Replace &(aHeader[nX,2]) With aCols[i,nX]
				Next nX
				MsUnlock()
			EndIf
		EndIf
	Next i
ElseIf nPosRec > 0
	dbSelectArea("SH2")
	dbSetOrder(1)
	//Ŀ
	// Grava Recursos Alternativos                                  
	//
	For i:=1 To Len(aCols)
		If !(Empty(aCols[i,nPosRec]))
			If dbSeek(xFilial("SH2")+M->H1_CODIGO+aCols[i,nPosRec])
				// Se estiver deletado, deleta tambem do arquivo
				If aCols[i,Len(aCols[i])]
					RecLock("SH2",.F.,.T.)
					dbDelete()
					MsUnLock()
					nCntDele++
				Else
					RecLock("SH2",.F.)
					For nX := 1 To Len(aHeader)-2
						Replace &(aHeader[nX,2]) With aCols[i,nX]
					Next nX
					MsUnLock()
				EndIf
				// Incluiu recurso a mais
			Else
				If !(aCols[i,Len(aCols[i])]) .And. nPosRec > 0
					RecLock("SH2",.T.)
					Replace  H2_FILIAL  With xFilial("SH2"), H2_RECPRIN With M->H1_CODIGO
					For nX := 1 To Len(aHeader)-2
						Replace &(aHeader[nX,2]) With aCols[i,nX]
					Next nX
					MsUnlock()
				EndIf
			EndIf
		EndIf
	Next i
	dbSelectArea("SH2")
Endif

//Gravao dos campos na rotina de Bens modulo MNT
NGRECGRAVA(M->H1_CODIGO)

A610GravaCol(aColReSe, aHeaReSe, aRegReSe, "SG7", {|| SG7->G7_RECURSO := M->H1_CODIGO}, "G7_FERRAM, G7_USO")
A610GravaCol(aColSePr, aHeaSePr, aRegSePr, "SG8", {|| SG8->G8_RECURSO := M->H1_CODIGO}, "G8_CRITERI, G8_TIPO")

dbSelectArea("SH2")
aColReSe := {}
aRegReSe := {}
aColSePr := {}
aRegSePr := {}
Return Nil

/*

Ŀ
Funo     A610Del   Autor Rodrigo de A. Sartorio  Data  26/02/95 
Ĵ
Descrio  Rotina p/ deletar recurso.                                 
Ĵ
 Uso       MATA610                                                    
ٱ


*/
Static Function A610Del(cAlias)
Local lRet:= .T.
Local aArea:= GetArea()
Local lIntSFC := ExisteSFC("SH1") .And. !IsInCallStack("AUTO610")
Local lIntDPR := IntegraDPR() .And. !IsInCallStack("AUTO610")// Determina se existe integracao com o DPR

cAliasAnt := Alias()
nRec := Recno()

dbSelectArea("SH2")
dbSetOrder(2)
If lRet .And. dbSeek(xFilial("SH2")+SH1->H1_CODIGO)
	Help(" ",1,"A610DELALT",,H2_RECPRIN,03,04)
	lRet := .F.
EndIf
dbSetOrder(1)

dbSelectArea("SH9")
dbSetOrder(1)
If lRet .And. dbSeek(xFilial("SH9")+"E"+SH1->H1_CCUSTO+SH1->H1_CODIGO)
	Help(" ",1,"A610DELEXC")
	lRet := .F.
EndIf

If lRet .And. dbSeek(xFilial("SH9")+"B"+SH1->H1_CCUSTO+SH1->H1_CODIGO)
	Help(" ",1,"A610DELBLO")
	lRet := .F.
EndIf

If lRet .And. !OpenSemSH8()
	Help(" ",1,"SH8EmUso2")
	lRet := .F.
Else
	dbSelectArea("SH8")
	dbSetOrder(2)
	If lRet .And. dbSeek(xFilial("SH8")+SH1->H1_CODIGO)
		Help(" ",1,"A610DELREC")
		dbCloseArea()
		ClosSemSH8()
		lRet := .F.
	EndIf
	dbCloseArea()
	ClosSemSH8()
EndIf

dbSelectArea("SG2")
dbSetOrder(4)
If lRet .And. dbSeek(xFilial("SG2")+SH1->H1_CODIGO)
	Help(" ",1,"A610APAREC")
	lRet := .F.
EndIf

dbSelectArea("SG7")
dbSetOrder(1)
If lRet .And. dbSeek(xFilial("SG7")+SH1->H1_CODIGO)
	Help(" ",1,"A610RECFER")
	lRet := .F.
EndIf

//Checa se recurso esta associado a um bem do Manutencao de Ativos
dbSelectArea("ST9")
dbSetOrder(13)
If lRet .And. dbSeek(xFilial("ST9")+"R"+SH1->H1_CODIGO)
	cError := AllTrim(FWX2Nome("ST9")) + " (ST9)"
	HELP(" ",1,"NGINTMOD",,cError,5,1)
	lRet := .F.
EndIf

//Ŀ
// Verifica se o recurso foi utilizado na rotina Vigencia de Calendario         
//
dbSelectArea("SHI")
dbSetOrder(1)
If lRet .And. dbSeek(xFilial("SHI")+SH1->H1_CODIGO)
	Help(" ",1,"A610VIGCAL")
	lRet:= .F.
EndIf

//Ŀ
// Verifica se o recurso foi utilizado no Apontamento da Produo               
//
If !VldApoPro(SH1->H1_CODIGO)
	lRet := .F.
	Help( ,  , STR0025, ,  STR0026,;	//STR0025 - Help - STR0026 - "Este recurso est associado a apontamentos de produo e no poder ser excludo."
		 1, 0, , , , , ,)
EndIf

//Ŀ
//Chama rotina para integracao com SFC(Chao de Fabrica) 
//
If lRet .And. (lIntSFC .Or. lIntDPR)
	lRet := A610IntSFC(5)
EndIf

If 	lRet
	Begin Transaction

		//Ŀ
		//Exclui os registro de vigencia do calendrio para o recurso
		//
		DbSelectArea("SHI")
		DbSetOrder(1)
		DbSeek(xFilial("SHI")+SH1->H1_CODIGO)
		While !Eof() .And. xFilial("SHI")+SH1->H1_CODIGO == HI_FILIAL+HI_RECURSO
			RecLock("SHI",.F.)
			dbDelete()
			MsUnLock()
			DbSkip()
		EndDo

		dbSelectArea("SH2")
		dbSeek(xFilial("SH2")+SH1->H1_CODIGO)
		nCntDele := 0
		While !Eof() .And. xFilial("SH2")+SH1->H1_CODIGO == H2_FILIAL+H2_RECPRIN .And. H2_TIPO $ "AS"
			RecLock("SH2",.F.,.T.)
			dbDelete()
			MsUnLock()
			nCntDele++
			dbSkip()
		EndDo

		dbSelectArea(cAlias)
		RecLock(cAlias,.F.,.T.)
		dbDelete()
		MsUnLock()

	End Transaction
EndIf

RestArea(aArea)
Return

/*/{Protheus.doc} VldApoPro
Verifica se o recurso poder ser excludo, de acordo com o relacionamento com a SH6
@type  Function
@author juliana.oliveira
@since 14/12/2022
@version 12
@param cRecurso, character, Cdigo do recurso
@return lRet, Logical, Indica se o recurso poder ser excludo
/*/
Function VldApoPro(cRecurso)
	Local lRet := .T.
	Local cRecurso
	Local cQuery    := ""
	Local cAliasQry := "VLDSH6"
	Local aArea     := GetArea()

	cQuery := " SELECT COUNT(*) TOTAL "
	cQuery +=   " FROM " + RetSqlName("SH6") + " SH6 "
	cQuery +=  " WHERE SH6.H6_FILIAL  = '" + xFilial("SH6") + "' "
	cQuery +=    " AND SH6.D_E_L_E_T_ = ' ' "
	cQuery +=    " AND SH6.H6_RECURSO = '" + cRecurso + "' "

	cQuery := ChangeQuery(cQuery)

	dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasQry,.T.,.T.)
	If (cAliasQry)->(TOTAL) > 0
		lRet := .F.
	EndIf
	(cAliasQry)->(dbCloseArea())

	RestArea(aArea)
Return lRet

/*

Ŀ
Funo    A610LinOk  Autor Rodrigo de A. Sartorio  Data  18/08/97 
Ĵ
Descrio  Rotina p/ validar linha da Get-Dados                       
Ĵ
 Uso       MATA610                                                    
ٱ


*/
Function A610LinOK(o)
LOCAL lRet:=.T.,nAcho:=0
PRIVATE nPosRec:=0,nPosTp:=0,nPosDescri:=0

nPosRec    := GDFieldPos("H2_RECALTE")
nPosDescri := GDFieldPos("H2_DESCRI")
nPosTp     := GDFieldPos("H2_TIPO")

//Ŀ
// Verifica se linha do acols foi preenchida            
//
If Len(aCols) > 1
	If !CheckCols(n,aCols)
		lRet:=.F.
	EndIf
EndIf

If nPosRec == 0
	Return(.T.)
Endif

// Verificar somente se a linha nao estiver deletada e o Recurso estiver preenchido
If !(aCols[n,Len(aCols[n])]) .And. !Empty(aCols[n,nPosRec]) .And. lRet
	// Verificar se o codigo  diferente do Recurso Principal
	If aCols[n,nPosRec] == M->H1_CODIGO
		Help(" ",1,"MA610PRINC")
		lRet:=.F.
	EndIf
	If lRet
		// Verificar se o codigo j existe na GetDados e se nao esta deletado
		nAcho:=aScan(aCols,{ |x| x[nPosRec] == aCols[n,nPosRec] .And. !(x[Len(aCols[n])])})
		If nAcho > 0 .And. nAcho # n
			Help(" ",1,"MA610JAEXI")
			lRet:=.F.
		EndIf
	EndIf
	If lRet .And. nPosTp > 0
		// Verificar se o tipo esta preenchido
		If !(NaoVazio(aCols[n,nPosTp]))
			lRet:=.F.
		EndIf
	EndIf
EndIf
Return lRet

/*

Ŀ
Funo    A610TudoOk Autor Leonardo Quintania      Data  28/11/12 
Ĵ
Descrio Realiza validao de campos do centro de trabalho e 			
				 integrao com TOTVS APS, SIGASFC e SIGADPR					  
Ĵ
Sintaxe   A610TudoOk()                                                
Ĵ
 Uso      MATA610                                                     
ٱ


*/
Function A610TudoOk()
Local lRet	 :=.T.
Local lIntSFC := ExisteSFC("SH1") .And. !IsInCallStack("AUTO610")
Local lIntDPR := IntegraDPR() .And. !IsInCallStack("AUTO610")// Determina se existe integracao com o DPR
Local nI      := 0

If lRet .And. SuperGetMV("MV_APS",.F.,"")=="DRUMMER" .And. Empty(M->H1_CTRAB)
	Aviso(STR0015,STR0014,{"Ok"}) // ### "Aviso" ### "O Centro de Trabalho deve ser informado quando existe integracao com Drummer Aps."
	lRet := .F.
EndIf

If lRet .And. SuperGetMV("MV_APS",.F.,"")=="TOTVS" .And. Empty(M->H1_CTRAB)
	Aviso(STR0015,STR0016,{"Ok"}) // ### "Aviso" ### "O Centro de Trabalho deve ser informado quando existe integracao com APS TOTVS"
	lRet := .F.
EndIf

If lRet .And. (lIntSFC .Or. lIntDPR)

	if Empty(M->H1_CTRAB)
		Aviso(STR0015,STR0018,{"Ok"}) // ### "Aviso" ### "O Centro de Trabalho deve ser informado quando existe integracao com SFC"
		lRet := .F.
	Endif

	// Verificar se os recursos alternativos e secundrios so do mesmo centro de trabalho.
	if lIntSFC
		For nI := 1 to Len(aCols)
			If !aCols[nI][Len(aHeader)+1]
				if !Empty(aCols[nI][nPosRec]) .AND. ALLTRIM(POSICIONE('SH1',1,xFilial('SH1')+aCols[nI][nPosRec],'H1_CTRAB')) != ALLTRIM(M->H1_CTRAB)
					Aviso(STR0015,STR0019 + ALLTRIM(aCols[nI][nPosRec]) + STR0020 + ALLTRIM(M->H1_CTRAB),{"Ok"}) // ### "Aviso" ### 'Recurso alternativo/secundrio ' ### ' no pertence ao centro de trabalho'
					lRet := .F.
					Exit
				Endif
			Endif
		Next
	Endif
EndIf

//Ŀ
//Chama rotina para integracao com SFC(Chao de Fabrica) 
//
If lRet .And. (lIntSFC .Or. lIntDPR)
	lRet := A610IntSFC(If(INCLUI,3,If(ALTERA,4,5)))
EndIf

Return lRet

/*

Ŀ
Funo    A610EditRestr Autor Marcelo Iuspa        Data  27/06/01 
Ĵ
Descrio Faz o relacionamento dos recursos com ferramentas           
Ĵ
Sintaxe   A610EditRestr                                               
Ĵ
 Uso      MATA610                                                     
ٱ


*/
Function A610EditRestr()
Local oDlg, oGet
Local OldAcol:= aClone(aCols)
Local OldAhea:= aClone(aHeader)
Local OldN   := N
Local nOpc   := 0

If Len(aHeaReSe) == 0
	aHeader  := A610CriaHeader("SG7", "G7_RECURSO; G7_PRODUTO; G7_OPERAC; G7_ROTEIRO",, .T./*lWalkThru*/ )
	aHeaReSe := aClone(aHeader)
Else
	aHeader  := aClone(aHeaReSe)
Endif

nUsado := Len(aHeader)

If Len(aColReSe) == 0
	aCriaCols := A610CriaCols("SG7", aHeader, xFilial("SG7") + M->H1_CODIGO, {||  G7_FILIAL+G7_RECURSO == xFilial("SG7") + M->H1_CODIGO})
	aCols     := aCriaCols[1]
	aRegReSe  := aCriaCols[2]
	aColReSe  := aClone(aCols)
Else
	aCols    := aClone(aColReSe)
Endif

n := 1
DEFINE MSDIALOG oDlg TITLE OemToAnsi(STR0008) From 9,10 To 20,60 OF oMainWnd //"Restricoes Secundarias"
oGet := MSGetDados():New(12,7,56,190,nOpcRot,"A610RSLINOK","A610RSTUDOK","",If(nOpcRot==2.Or.nOpcRot==1,Nil,.T.))
DEFINE SBUTTON FROM 63 ,125 TYPE 1 ACTION (nOpc:=1,If(oGet:TudoOk(),oDlg:End(),nOpc:=0)) ENABLE OF oDlg
DEFINE SBUTTON FROM 63 ,153 TYPE 2 ACTION oDlg:End() ENABLE OF oDlg
ACTIVATE MSDIALOG oDlg
If nOpc == 1
	aHeaReSe := aClone(aHeader)
	aColReSe := aClone(aCols)
Endif
aHeader := aClone(OldAhea)
aCols   := aClone(OldAcol)
N       := OldN
Return

/*

Ŀ
Funo    A610RSLINOK   Autor Marcelo Iuspa        Data  27/06/01 
Ĵ
Descrio Valida digitacao da linha                                   
Ĵ
Sintaxe   A610RSLINOK                                                 
Ĵ
 Uso      MATA610                                                     
ٱ


*/
Function A610RSLINOK()
Local nx,lRet := .T.
If aCols[n, Len(aHeader)+1]
	Return(.T.)
Endif
If Empty(A610FieldCol("G7_USO")) .And. Empty(A610FieldCol("G7_FERRAM"))
	Return(.T.)
Endif
For nx := 1 To Len(aHeader)
	If Trim(aHeader[nx][2]) == "G7_QUANT" .Or. IsHeadRec(aHeader[nx][2]) .Or. IsHeadAlias(aHeader[nx][2])
		Loop
	EndIf
	If Empty(aCols[n][nx])
		Help(" ",1,"OBRIGAT2",,RetTitle(aHeader[nx, 2]),04,01)
		lRet := .F.
		Exit
	EndIf
Next nx
Return(lRet)

/*

Ŀ
Funo    A610RSTUDOK   Autor Marcelo Iuspa        Data  27/06/01 
Ĵ
Descrio Faz o relacionamento dos recursos com ferramentas           
Ĵ
Sintaxe   A610RSTUDOK                                                 
Ĵ
 Uso      MATA610                                                     
ٱ


*/
Function A610RSTUDOK()
Return(.T.)

/*

Ŀ
Funo    A610EditSeque Autor Larson Zordan        Data  02/07/01 
Ĵ
Descrio Faz o relacionamento das seq.preferidas                     
Ĵ
Sintaxe   A610EditSeque                                               
Ĵ
 Uso      MATA610                                                     
ٱ


*/
Function A610EditSeque()
Local oDlg
Local OldAcol:= aClone(aCols)
Local OldAhea:= aClone(aHeader)
Local OldN   := N
Local nOpc   := 0

If Len(aHeaSePr) == 0
	aHeader  := A610CriaHeader("SG8", "G8_RECURSO",, .T./*lWalkThru*/ )
	aHeaSePr := aClone(aHeader)
Else
	aHeader  := aClone(aHeaSePr)
Endif

nUsado := Len(aHeader)

If Len(aColSePr) == 0
	aCols := {}
	aCriaCols := A610CriaCols("SG8", aHeader, xFilial("SG8") + M->H1_CODIGO, {||  G8_FILIAL+G8_RECURSO == xFilial("SG8") + M->H1_CODIGO})
	aCols     := aCriaCols[1]
	aRegSePr  := aCriaCols[2]
	aColSePr  := aClone(aCols)
Else
	aCols    := aClone(aColSePr)
Endif

n := 1
DEFINE MSDIALOG oDlg TITLE OemToAnsi(STR0010) From 9,10 To 20,60 OF oMainWnd //"Sequencias Preferidas"
oGet := MSGetDados():New(12,7,56,190,nOpcRot,"A610RSTUDOK","A610RSTUDOK","",If(nOpcRot==2.Or.nOpcRot==1,Nil,.T.))
DEFINE SBUTTON FROM 63 ,125 TYPE 1 ACTION (nOpc:=1,If(oGet:TudoOk(),oDlg:End(),nOpc:=0)) ENABLE OF oDlg
DEFINE SBUTTON FROM 63 ,153 TYPE 2 ACTION oDlg:End() ENABLE OF oDlg
ACTIVATE MSDIALOG oDlg
If nOpc == 1
	aHeaSePr := aClone(aHeader)
	aColSePr := aClone(aCols)
Endif
aHeader := aClone(OldAhea)
aCols   := aClone(OldAcol)
N       := OldN
Return

/*

Ŀ
Funo    A610Ferram    Autor Marcelo Iuspa        Data  27/06/01 
Ĵ
Descrio Valida se a ferramenta ja nao esta relacionada com o recurso
Ĵ
Sintaxe   A610Ferram                                                  
Ĵ
 Uso      MATA610                                                     
ٱ


*/
Function A610Ferram()
Local z, nPos := aScan(aHeader, {|x| x[2] == "G7_FERRAM"})
Local lRet := .T.
If nPos = 0
	lRet := .F.
Else
	For z := 1 to Len(aCols)
		If aCols[z, nPos] == M->G7_FERRAM .And. (! aCols[z, Len(aheader)+1]) .And. z # n
			Help(" ",1,"FERRAMJA")
			lRet := .F.
			Exit
		Endif
	Next
EndIf
Return(lRet)

/*

Ŀ
Funo    A610MtzSetup  Autor Marcelo Iuspa        Data  11/07/01 
Ĵ
Descrio Edita Matriz de Setup, variavel no recurso por grupo recurso
Ĵ
Sintaxe   A610MtzSetup                                                
Ĵ
 Uso      MATA610                                                     
ٱ


*/
Function A610MtzSetup()
Local aSetups := {}
Local x, z
Local cFieldOk
Local cValid   := GetSX3Cache("GD_TEMPO", "X3_VALID")
Local cPicture := PesqPict("SGD","GD_TEMPO")
Private aDePara := {}

dbSelectArea("SG9")
dbSetOrder(1)
dbSeek(xFilial("SG9"))
do While ! Eof() .And. G9_FILIAL == xFilial("SG9")
	Aadd(aSetups, G9_CODIGO)
	dbSkip()
Enddo

If Len(aSetups) = 0
	HELP(" ",1,"NAOGRUPREC")
	Return
Endif

aHeader := {}
aCols   := {}
aDePara := {}

Aadd(aHeader,{"", "GD_DE", "",12, 0, "","", "C", " ", " " } )
For x := 1 to Len(aSetups)
	Aadd(aHeader,{aSetups[x], "GD_TEMPO", cPicture,Len(SGD->GD_TEMPO), 0, cValid,"", "C", " ", " " } )
Next

//Ŀ
// Walk-Thru		 
//
ADHeadRec("SGD",aHeader)

For x := 1 to Len(aSetups)
	Aadd(aCols, {aSetups[x]})
	For z := 1 to Len(aSetups)
		Aadd(aCols[Len(aCols)], "00:00")
	Next
	Aadd(aCols[Len(aCols)],"SGD")
	Aadd(aCols[Len(aCols)],0)
	Aadd(aCols[Len(aCols)], .F.)
Next

dbSelectArea("SGD")
dbSeek(xFilial("SGD")+SH1->H1_CODIGO)
do While ! Eof() .And. GD_FILIAL+GD_RECURSO == xFilial("SGD")+SH1->H1_CODIGO
	nCol := aScan(aSetups, AllTrim(GD_DE))
	nLin := aScan(aSetups, AllTrim(GD_PARA))
	If nCol = 0 .Or. nLin = 0
		//		alert("Erro...")
		dbSkip()
		Loop
	Endif
	aCols[nLin,nCol+1] := GD_TEMPO
	aCols[nLin,Len(aHeader)]:= RecNo()
	Aadd(aDePara, {GD_DE, GD_PARA, GD_TEMPO, RecNo()})
	dbSkip()
Enddo

nOpca:=0
cFieldOk := "A610MtzField()"
DEFINE MSDIALOG oDlg TITLE cCadastro From 20,20 to 320,620 of oMainWnd PIXEL
oGet := MSGetDados():New(30,30,150,300,3,"AllwaysTrue","AllwaysTrue","",.F.,{"GD_TEMPO"},,,Len(aCols), cFieldOk)
@ 20,150 SAY OemToAnsi(STR0011)   SIZE 18,7 Of oDlg PIXEL //"De"
@ 80,005 SAY OemToAnsi(STR0012) SIZE 18,7 Of oDlg PIXEL //"Para"
ACTIVATE MSDIALOG oDlg CENTERED ON INIT EnchoiceBar(oDlg,{||nOpca:=1, oDlg:End()},{||oDlg:End()})
If nOpca == 1
	For x := 1 to Len(aDePara)
		If Len(aDePara[x]) > 3
			dbGoto(aDePara[x, 4])
			RecLock("SGD", .F.)
			SGD->GD_TEMPO := aDePara[x, 3]
		Else
			RecLock("SGD", .T.)
			SGD->GD_FILIAL := xFilial("SGD")
			SGD->GD_RECURSO := SH1->H1_CODIGO
			SGD->GD_DE    := aDePara[x, 1]
			SGD->GD_PARA  := aDePara[x, 2]
			SGD->GD_TEMPO := aDePara[x, 3]
		Endif
		MsUnlock()
	Next
Endif
Return

/*

Ŀ
Funo    A610MtzField  Autor Marcelo Iuspa        Data  11/07/01 
Ĵ
Descrio Funcao executada a cada alteracao dos campos da GetDados    
Ĵ
Sintaxe   A610MtzField                                                
Ĵ
 Uso      MATA610                                                     
ٱ


*/
Function A610MtzField()
Local nCol   := oGet:oBrowse:nColPos
Local cDe    := aHeader[nCol, 1]
Local cPara  := aHeader[n+1 , 1]
Local cTempo := &(ReadVar())
If (nPos := aScan(aDePara, {|x| x[1] + x[2] == cDe + cPara})) == 0
	Aadd(aDePara, {cDe, cPara, cTempo})
Else
	aDePara[nPos, 3] := cTempo
Endif
Return(.T.)

/*

Ŀ
Funo    A610GravaCol  Autor Marcelo Iuspa        Data  08/07/01 
Ĵ
Descrio Generica para gravacao do acols                             
Ĵ
Sintaxe   A610GravaCol                                                
Ĵ
 Uso      MATA610                                                     
ٱ


*/
Function A610GravaCol(aCols, aHeader, aRegCol, cAlias, bBloco, cCampos,lDeleta)
Local nFilial := 0
Local x, i, j, z, lEmpty := .F.

Default lDeleta := .F.
Default bBloco  := {|| .T.}

cAlias := If(cAlias = Nil, Alias(), cAlias)
dbSelectArea(cAlias)
nFilial := aScan(dbStruct(), {|x| "_FILIAL" $ x[1]})

If ValType(cCampos) == "C"
   cCampos := alltrim(cCampos)
Endif

If !Empty(aCols)
	//Ŀ
	//Deleta os itens existentes para recria-los posteriormente conforme aCols
	//
	For x:= 1 To Len(aRegCol)
		dbGoto(aRegCol[x])
		RecLock(cAlias, .f.)
		dbDelete()
		MsUnlock()
		Loop
	Next x
EndIf
If !lDeleta
	For i := 1 to Len(aCols)
		If !aCols[i, Len(aHeader)+1] .And. !lDeleta
			If ValType(cCampos) == "C"
				For j := 1 to Len(aHeader)
					If AllTrim(aHeader[j, 2]) $ Upper(cCampos)
						If Empty(aCols[i, j])
							lEmpty := .T.
							Loop
						Endif
					Endif
				Next
			Endif
			If ! lEmpty
				RecLock(cAlias, .T.)
			Else
				Loop
			Endif
			For z := 1 to Len(aHeader)
				If !IsHeadRec(aHeader[z][2]) .And. !IsHeadAlias(aHeader[z][2])
					If (nFieldPos := FieldPos(aHeader[z, 2])) > 0
					    If ValType(aCols[i, z]) == "C"
						   FieldPut(nFieldPos, alltrim(aCols[i, z]))
						Else
						   FieldPut(nFieldPos, aCols[i, z])
						EndIf
					Endif
				Endif
			Next
			If nFilial > 0
				FieldPut(nFilial, xFilial(cAlias))
			Endif
			Eval(bBloco, i)
			MsUnlock()
		EndIf
	Next
EndIf
Return(.T.)

/*

Ŀ
Funo      A610CriaHe   Autor Marcelo Iuspa       Data  08/07/01 
Ĵ
Descrio Generica para criacao de aHeader                            
Ĵ
Sintaxe    ExpA1 := A610CriaHeader(ExpC1,ExpC2,ExpL1,ExpL2)           
Ĵ
Parametros ExpC1 = Alias do Arquivo                                   
           ExpC2 = Lista com campos nao exibidos (NoFields)			  
           ExpL1 = Se .T. monta somente o titulo no aHeader 		  
                   Se .F. monta aHeader normal 				 		  
           ExpL2 = Se .T. criara' campos especificos do WALK-THRU	  
                   desde que ExpL1 seja .F. (aHeader normal)		  
Ĵ
Retorno    ExpA1 = aHeader			                                  
Ĵ
 Uso       Geral													  
          (MATA610,MATA630,MATA635,MATA093,MATA636,MATA098,MATA099,   
           MATA272,MATA551,MATA552,FATA140,AACA180A,AACA450...)       
ٱ


*/
Function A610CriaHeader(cAlias, cSkip, lOnlyFields, lWalkThru)
	Local aAux     := {}
	Local aField   := {}
	Local aRet     := {}
	Local aStruct  := {}
	Local nI       := 0
	Local nIndex   := 0
	Local nTotal   := 0
	Local OldAlias := Alias()
	Default cSkip       := ""
	Default lOnlyFields := .F.
	Default lWalkThru	:= .F.

	aStruct := FWFormStruct( 3, (cAlias))
	aStruct := aStruct[3]

	For nI := 1 To Len(aStruct)

		If X3USO(GetSX3Cache(aStruct[nI][1], "X3_USADO")) .And. cNivel >= GetSX3Cache(aStruct[nI][1], "X3_NIVEL")
			If AllTrim(aStruct[nI][1]) $ cSkip
				Loop
			Endif

			If lOnlyFields
				Aadd(aRet, Trim(aStruct[nI][1]))
			Else
				aField := { Trim(aStruct[nI][3])                     ,;
				            Trim(aStruct[nI][1])                     ,;
				            GetSX3Cache(aStruct[nI][1], "X3_PICTURE"),;
				            GetSX3Cache(aStruct[nI][1], "X3_TAMANHO"),;
				            GetSX3Cache(aStruct[nI][1], "X3_DECIMAL"),;
				            GetSX3Cache(aStruct[nI][1], "X3_VALID"  ),;
				            GetSX3Cache(aStruct[nI][1], "X3_USADO"  ),;
				            GetSX3Cache(aStruct[nI][1], "X3_TIPO"   ),;
				            GetSX3Cache(aStruct[nI][1], "X3_ARQUIVO"),;
				            GetSX3Cache(aStruct[nI][1], "X3_CONTEXT") }

				If cAlias == "SH2" .And. aStruct[nI][1] == "H2_ORDEM"
					aAux   := {}
					nTotal := Len(aRet)

					aAdd(aAux, aField)
					For nIndex := 1 To nTotal
						aAdd(aAux, aRet[nIndex])
					Next

					aRet := aAux
					aAux := {}
				Else
					Aadd(aRet, aField)
				EndIf

				aField := {}
			Endif
		Endif

	Next

	//Ŀ
	// Walk-Thru		 
	//
	If !lOnlyFields .And. lWalkThru
		ADHeadRec(cAlias,aRet)
	EndIf

	dbSelectArea(OldAlias)

Return(aRet)

/*

Ŀ
Funo    A610CriaCols   Autor Marcelo Iuspa       Data  08/07/01 
Ĵ
Descrio Generica para criacao de aCols                              
Ĵ
Sintaxe   ExpA1 := A610CriaCols(ExpC1,ExpA1,ExpC2,ExpB1,ExpB2)		  
Ĵ
ParametrosExpC1 = Alias do Arquivo                                    
          ExpA1 = aHeader               							  
          ExpC2 = chave p/ posicionamento da area p/ preencher aCols  
          ExpB1 = bloco c/expr.p/ comparar c/ExpC2 na condicao While  
          ExpB2 = bloco c/condicao p/ executar loop no While (filtro) 
Ĵ
Retorno    ExpA1 sendo:                  			                  
           		 ExpA1[1] = array aHeader			                  
           		 ExpA1[2] = array aRecno (c/ numeros dos registros)   
Ĵ
 Uso       Geral													  
          (MATA610,MATA630,MATA635,MATA093,MATA636,MATA098,MATA099,   
           MATA272,MATA551,MATA552,FATA140,AACA180A,AACA450...)       
ٱ


*/
Function A610CriaCols(cAlias, aHeaLoc, cSeek, bWhil, bFor)
Local aRetCol := {}, aRetReg := {}
Local x := y  := 0
Local aArea := SH1->(GetArea())
Local xValue := Nil
Local cSeqOrdem := "00"
Private n   := 1

cAlias := If(cAlias=Nil,Alias(),cAlias)
bWhil  := If(bWhil=Nil,{|| .T.},bWhil)
bFor   := If(bFor=Nil,{|| .T.},bFor)

If cSeek # Nil
	dbSelectArea(cAlias)
	If cAlias == "SH2" .And. FindFunction("P124ExIndc") .And. P124ExIndc("SH2", "4")
		SH2->(dbSetOrder(4))
	EndIf
	dbSeek(cSeek, .T.)
	do While !(cAlias)->(Eof()) .And. Eval(bWhil)
		If ! Eval(bFor)
			(cAlias)->(dbSkip())
			Loop
		Endif

		Aadd(aRetCol, {})
		For x := 1 to Len(aHeaLoc)
			//Ŀ
			// Verifica se usa campos do Walk-Thru      
			//
			If IsHeadRec(aHeaLoc[x][2])
				Aadd(aRetCol[Len(aRetCol)],(cAlias)->(RecNo()))
			ElseIf IsHeadAlias(aHeaLoc[x][2])
				Aadd(aRetCol[Len(aRetCol)],cAlias)
			ElseIf aHeaLoc[x, 10] == "V"
				Aadd(aRetCol[Len(aRetCol)], CriaVar(aHeaLoc[x, 2]))
			Else
				xValue := FieldGet(FieldPos(aHeaLoc[x, 2]))

				If cAlias == "SH2" .And. aHeaLoc[x][2] == "H2_ORDEM" .And. Empty(xValue)
					cSeqOrdem := Soma1(cSeqOrdem)
					xValue := cSeqOrdem
				EndIf

				Aadd(aRetCol[Len(aRetCol)], xValue)
			Endif
		Next

		RestArea(aArea)

		Aadd(aRetCol[Len(aRetCol)], .F.)
		Aadd(aRetReg, (cAlias)->(RecNo()))

		dbSelectArea(cAlias)
		(cAlias)->(dbSkip())
	Enddo
Endif

If Len(aRetCol) == 0
	Aadd(aRetCol, {})
	For y := 1 to Len(aHeaLoc)
		//Ŀ
		// Verifica se usa campos do Walk-Thru      
		//
		If IsHeadRec(aHeaLoc[y][2])
			Aadd(aRetCol[Len(aRetCol)],0)
		ElseIf IsHeadAlias(aHeaLoc[y][2])
			Aadd(aRetCol[Len(aRetCol)],cAlias)
		Else
			//DMANSMARTSQUAD1-28446
			if (IsInCallStack("A610Visual") .or. IsInCallStack("A610Altera") .or. IsInCallStack("A610Deleta")) .and. FieldGet(FieldPos(aHeaLoc[y, 2])) == nil
				Aadd( aRetCol[Len(aRetCol)], iif(Empty(POSICIONE("SH2",1,xFilial("SH2")+SH1->H1_CODIGO,"H2_RECALTE")),'',SH1->H1_DESCRI) )
			else
				Aadd( aRetCol[Len(aRetCol)], CriaVar(aHeaLoc[y, 2]))
			Endif
		EndIf
	Next
	Aadd(aRetCol[Len(aRetCol)], .F.)
Endif
SH1->(RestArea(aArea))
Return({aRetCol, aRetReg})


/*

Ŀ
Funo    A610FieldCol   Autor Marcelo Iuspa       Data  31/07/01 
Ĵ
Descrio Generica para ler campo do aCols                            
Ĵ
Sintaxe   A610FieldCol                                                
Ĵ
 Uso      MATA610                                                     
ٱ


*/
Function A610FieldCol(cField)
Local nPos
If Type("aHeader") + Type("aCols") # "AA"
	Return(Nil)
Endif
nPos := aScan(aHeader, {|x| Upper(AllTrim(x[2])) == Upper(AllTrim(cField))})
If nPos = 0
	Return(Nil)
Endif
Return(aCols[n, nPos])

/*

Ŀ
Funo    F3CCusto       Autor Marcelo Iuspa       Data  20/08/02 
Ĵ
Descrio Funcao para consulta F3 sobre Centro de Custo               
Ĵ
 Uso      MATA610                                                     
ٱ


*/
Function F3CCusto()
Return(ConPad1(,,,If(CtbInUse(), "CTT", "SI3")))

/*/


Ŀ
Programa  MenuDef    Autor  Fabio Alves Silva      Data 08/11/2006
Ĵ
Descrio  Utilizacao de menu Funcional                               
                                                                      
Ĵ
Retorno   Array com opcoes da rotina.                                 
Ĵ
ParametrosParametros do array a Rotina:                               
          1. Nome a aparecer no cabecalho                             
          2. Nome da Rotina associada                                 
          3. Reservado                                                
          4. Tipo de Transao a ser efetuada:                        
          	  1 - Pesquisa e Posiciona em um Banco de Dados           
              2 - Simplesmente Mostra os Campos                       
              3 - Inclui registros no Bancos de Dados                 
              4 - Altera o registro corrente                          
              5 - Remove o registro corrente do Banco de Dados        
          5. Nivel de acesso                                          
          6. Habilita Menu Funcional                                  
ٱ


/*/

Static Function MenuDef()
PRIVATE aRotina	:= { {STR0001,"AxPesqui"  , 0 , 1, 0, .F.},;	//"Pesquisar"
					 {STR0002,"A610Visual", 0 , 2, 0, nil},;	//"Visualizar"
					 {STR0003,"A610Inclui", 0 , 3, 0, nil},;	//"Incluir"
					 {STR0004,"A610Altera", 0 , 4, 0, nil},;	//"Alterar"
					 {STR0013,"A610CadSHI", 0 , 4, 3, nil},;	//"Vigencia Cal"
					 {STR0005,"A610Deleta", 0 , 5, 3, nil}}	    //"Excluir"

//Ŀ
// Ponto de entrada utilizado para inserir novas opcoes no array aRotina  
//
If ExistBlock("MTA610MNU")
	ExecBlock("MTA610MNU",.F.,.F.)
EndIf
Return(aRotina)

/*

Ŀ
Funo    A610PEOk	 Autor Andre Anjos   		  	 Data  28/12/07 
Ĵ
Descrio Funcao de chamada do PE MA610OK							  
Ĵ
Sintaxe   A610PEOK(nOpc)                                              
Ĵ
 Uso      MATA610                                                     
ٱ


*/
Function A610PEOK(nOpc)
Local lRet := .T.
Local lMT610OK := ExistBlock("MT610OK")

If lMT610OK
	lRet := ExecBlock("MT610OK",.F.,.F.,{nOpc})
	If ValType(lRet) # "L"
		lRet := .T.
	EndIf
EndIf

If lRet .And. PCPIntgPPI()
   lRet := mata610PPI()
EndIf
Return lRet

/*


Ŀ
Funao    A610IntSFC  Autor  Marco Aurelio - Mano     Data 23/02/11 
Ĵ
Descriao Atualiza o cadastro de Maquinas no modulo SFC                 
Ĵ
Sintaxe   A610IntSFC(ExpN1,ExpC1,ExpC2)                                 
Ĵ
ParametrosExpN1 = Rotina a ser processada(3-Inc, 4-Alt, 5-Exc)          
          ExpC1 = Codigo anterior do calendario                         
Ĵ
Uso       MATA610                                                       
ٱ


*/
Function A610IntSFC(nOpc,cError,cNome,oModel)
Local aArea   := GetArea()	// Salva area atual para posterior restauracao
Local lRet    := .T.		// Conteudo de retorno
Local aCpoCab := {}			// Array dos campos de cabecalho a serem atualizados pelo modelo
Local nInd    := 0			// Indexadora de laco For/Next
Local aAux    := {}			// Array auxiliar com o conteudo dos campos
Default oModel := FWLoadModel("SFCA002")

//Ŀ
//Define campos a serem atualizados no cabecalho do cadastro de Maquinas - SFC 
//
If nOpc == 3
	//Ŀ
	//Quando inclusao considera novo codigo 
	//
	aAdd(aCpoCab,{"CYB_CDMQ"	,M->H1_CODIGO})
EndIf
aAdd(aCpoCab,{"CYB_DSMQ"	,Iif(Empty(M->H1_DESCRI),M->H1_CODIGO,M->H1_DESCRI)})
aAdd(aCpoCab,{"CYB_CDCETR"	,M->H1_CTRAB})
aAdd(aCpoCab,{"CYB_CDCECS"	,M->H1_CCUSTO})
aAdd(aCpoCab,{"CYB_QTOEMQ"	,M->H1_MAOOBRA})

//Ŀ
//Atribui o numero da operacao a ser efetuada pelo Modelo 
//3-Inclusao, 4-Alteracao, 5-Exclusao                     
//
oModel:SetOperation(nOpc)

If nOpc # 3
	//Ŀ
	//Quando se tratar de alteracao ou exclusao primeiramente o registro devera ser posicionado 
	//
	dbSelectArea("CYB")	// Tabela de Maquinas
	dbSetOrder(1)			// Ordem: CYB_FILIAL+CYB_CDMQ
	dbSeek(xFilial("CYB")+M->H1_CODIGO)
EndIf

//Ŀ
//Ativa o modelo de dados 
//
If (lRet := oModel:Activate())
	If ( nOpc # 5 )
		aAux := oModel:GetModel("CYBMASTER"):GetStruct():GetFields()

		//Ŀ
		//Loop para validacao e atribuicao de dados dos campos do Model 
		//
		For nInd := 1 To Len(aCpoCab)
			//Ŀ
			//Verifica se os campos passados existem na estrutura do cabecalho 
			//
			If aScan(aAux,{|x| AllTrim(x[3]) ==  AllTrim(aCpoCab[nInd][1])}) > 0
				//Ŀ
				//Atribui os valores aos campos do Model caso passem pela validacao do formulario 
				//referente a tipos de dados, tamanho ou outras incompatibilidades estruturais.   
				//
				If !(oModel:SetValue("CYBMASTER",aCpoCab[nInd][1],aCpoCab[nInd][2]))
					lRet := .F.
					Exit
				EndIf
			EndIf
		Next nInd

	EndIf

	If lRet
		//Ŀ
		//Valida os dados e integridade conforme dicionario do Model 
		//
		If ( lRet := oModel:VldData() )
			//Ŀ
			//Efetiva gravacao dos dados na tabela 
			//
			lRet := oModel:CommitData()
		EndIf
	EndIf
EndIf

If !lRet
	A010SFCErr(oModel,@cError,NIL,cNome,SH1->H1_CODIGO)
EndIf

//Ŀ
//Desativa o Model 
//
oModel:DeActivate()
RestArea(aArea)
Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} A610BYLinOk
Verificao de consistncia de dados
@author marco.guimaraes
@since 01/07/14
@version 1.0
@return lRet
/*/
//-------------------------------------------------------------------
Function A610BYLinOk()

Local lRet   	:= .T.
Local nPosDel	:= Len(aHeader) + 1
Local cAtual 	:= ""
Local lDeleted:= aCols[n, nPosDel]

cAtual := Upper(Alltrim(M->BY_CAMPO))

If lDeleted == .F.
	If aScan(aCols, {|x| Upper(Alltrim(x[1])) = cAtual}) > 0
		Help("", 1, "JAGRAVADO") //P: J existe registro com esta informao S:Troque a chave principal deste registro
		lRet:= .F.
	EndIf
EndIf

Return lRet
//-------------------------------------------------------------------------------------------------
/*/{Protheus.doc} mata610PPI

Realiza a integrao com o PC-Factory - PPI Multitask

@param cXml    - XML que ser enviado. Caso no seja passado esse parametro, ser realizada
                 a chamada do Adapter para criao do XML.
                 Se for passado esse parmetro, no ser exibida a mensagem de erro caso exista,
                 nem ser considerado o filtro da tabela SOE.
@param cCodigo - Obrigatrio quando utilizado o parmetro cXml. Contm o cdigo do recurso
@param lFiltra   - Identifica se ser realizado ou no o filtro do registro.
@param lPendAut  - Indica se ser gerada a pendncia sem realizar a pergunta para o usurio, caso ocorra algum erro.

@author  Lucas Konrad Frana
@version P12
@since   17/08/2015
@return  lRet  - Indica se a integrao com o PC-Factory foi realizada.
           .T. -> Integrao Realizada
           .F. -> Integrao no realizada.
/*/
//-------------------------------------------------------------------------------------------------
Function mata610PPI(cXml, cCodigo, lFiltra, lPendAut)
   Local lRet      := .T.
   Local aRetXML   := {}
   Local aRetData  := {}
   Local aRetWS    := {}
   Local aArea     := GetArea()
   Local aRetArq   := ""
   Local cOperacao := ""
   Local cGerouXml := ""
   Local cNomeXml  := ""
   Local cTable    := "SH1"
   Local cPont     := "M"

   //Varivel utilizada para identificar que est sendo executada a integrao para o PPI dentro do MATI010.
   Private lRunPPI := .T.

   Default cXml    := ""
   Default cCodigo := ""
   Default lFiltra   := .T.
   Default lPendAut  := .F.

   //Se est com a integrao do cho de fbrica ativada, e est executando atravs do SFCA002,
   //busca os dados sempre do model do SFCA002
   If (IsInCallStack("AUTO610") .Or. IsInCallStack("PCPA111PPI") ) .And. SuperGetMV("MV_INTSFC",.F.,0)==1
      cTable := "CYB"
      cPont  := "oModelCYB:GetValue('?')"
   EndIf

   If Empty(cXml)
      Do Case
         Case nOpcRot == 3
            cOperacao := Lower(STR0003) //"incluir"
         Case nOpcRot == 4
            cOperacao := Lower(STR0004) //"alterar"
         Case nOpcRot == 6
            cOperacao := Lower(STR0005) //"excluir"
      EndCase
      If cTable == "CYB"
         cCodigo := oModelCYB:GetValue('CYB_CDMQ')
      Else
         cCodigo := M->H1_CODIGO
      EndIf
   EndIf

   //Realiza filtro na tabela SOE, para verificar se o recurso entra na integrao.
   If !Empty(cXml) .Or. !lFiltra .Or. PCPFiltPPI(cTable, cCodigo,cPont)
      //Adapter para criao do XML
      If Empty(cXml)
         aRetXML := MATI610("", TRANS_SEND, EAI_MESSAGE_BUSINESS)
      Else
         aRetXML := {.T.,cXml}
      EndIf
      /*
         aRetXML[1] - Status da criao do XML
         aRetXML[2] - String com o XML
      */

      If aRetXML[1]
         //Retira os caracteres especiais
         aRetXML[2] := EncodeUTF8(aRetXML[2])

         //Busca a data/hora de gerao do XML
         aRetData := PCPxDtXml(aRetXML[2])
         /*
            aRetData[1] - Data de gerao AAAAMMDD
            aRetData[1] - Hora de gerao HH:MM:SS
         */

         //Envia o XML para o PCFactory
         aRetWS := PCPWebsPPI(aRetXML[2])
         /*
            aRetWS[1] - Status do envio (1 - OK, 2 - Pendente, 3 - Erro.)
            aRetWS[2] - Mensagem de retorno do PPI
         */
         If lPendAut
            lRet := .T.
         Else
            If aRetWS[1] != "1" .And. Empty(cXml)
               //"Ateno! Ocorreram erros na integrao com o PCFactory. Erro: "
               // XXXXXX
               // XXXXXX
               // "Deseja incluir/alterar/excluir o recurso no protheus e gerar pendncia para integrao?"
               If !MsgYesNo(STR0021 + AllTrim(aRetWS[2]) +CHR(10)+;
               	         STR0022 +AllTrim(cOperacao) + Iif(cTable=="SH1",STR0023,STR0024))
                  lRet := .F.
               EndIf
            EndIf
         EndIf
         If lRet
            //Cria o XML fisicamente no diretrio parametrizado
            aRetArq := PCPXmLPPI(aRetWS[1],cTable,cCodigo,aRetData[1],aRetData[2],aRetXML[2])
            /*
               aRetArq[1] Status da criao do arquivo. .T./.F.
               aRetArq[2] Nome do XML caso tenha criado. Mensagem de erro caso no tenha criado o XML.
            */
            If !aRetArq[1]
               If Empty(cXml) .And. !lPendAut
                  Alert(aRetArq[2])
               EndIf
            Else
               cNomeXml := aRetArq[2]
            EndIf
            If Empty(cNomeXml)
               cGerouXml := "2"
            Else
               cGerouXml := "1"
            EndIf
            //Cria a tabela SOF
            PCPCriaSOF(cTable,cCodigo,aRetWS[1],cGerouXml,cNomeXml,aRetData[1],aRetData[2],__cUserId,aRetWS[2],aRetXML[2])
         EndIf
      EndIf
   EndIf
   //Tratativa para retornar .F. mesmo quando  pendncia automtica;
   //Utilizado apenas para o programa de sincronizao.
   If AllTrim(FunName()) == "PCPA111" .And. aRetWS[1] != "1"
      lRet := .F.
   EndIf
   RestArea(aArea)
Return lRet

/*/{Protheus.doc} A610INIORD
Inicializador padro do campo H2_ORDEM.
@type  Function
@author Lucas Fagundes
@since 29/07/2024
@version P12
@return cSeqOrdem, Caracter, Valor que ser atribuido ao campo ordem do cadastro de recursos alternativos.
/*/
Function A610INIORD()
	Local cMaior    := ""
	Local cSeqOrdem := "01"
	Local nIndex    := 0
	Local nPosOrd   := GDFieldPos("H2_ORDEM")
	Local nTotal    := Nil

	If aCols != Nil
		nTotal := (Len(aCols) - 1)

		For nIndex := 1 To nTotal
			If aCols[nIndex][nPosOrd] > cMaior
				cMaior := aCols[nIndex][nPosOrd]
			EndIf
		Next

		If !Empty(cMaior)
			cSeqOrdem := Soma1(cMaior)
		EndIf
	EndIf

Return cSeqOrdem

/*/{Protheus.doc} A610VldOrd
Valida o valor do campo H2_ORDEM.
@type  Function
@author Lucas Fagundes
@since 29/07/2024
@version P12
@param cValue, Caracter, Valor sendo atribuido ao campo.
@return lOk, Logico, Retorna se pode ou no utilizar o valor.
/*/
Function A610VldOrd(cValue)
	Local lOk      := .T.
	Local nIndex   := 0
	Local nPosOrd  := GDFieldPos("H2_ORDEM")
	Local nTotal   := (Len(aCols) - 1)	

	If Empty(cValue)
		lOk := .F.

		help("",1,"Help",,STR0027, 2,0, , , , , ,{STR0028}) // "Ordem no informada!" "O campo ordem no pode ficar em branco."
	EndIf

	If lOk
		For nIndex := 1 To nTotal
			If aCols[nIndex][nPosOrd] == cValue
				lOk := .F.
				Exit
			EndIf
		Next

		If !lOk
			help("",1,"Help",,STR0029, 2,0, , , , , ,{STR0030}) // "Ordem j utilizada!" "Utilize outro valor ou altere o registro com este valor primeiro."
		EndIf
	EndIf

Return lOk
