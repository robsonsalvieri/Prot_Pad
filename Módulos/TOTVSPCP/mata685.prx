#INCLUDE "MATA685.CH"
#INCLUDE "PROTHEUS.CH"
/*


Ŀ
Funo     MATA685   Autor  Rodrigo de A. Sartorio Data  26/12/96 
Ĵ
Descrio  Programa de Apontamento de Perdas por OP.                  
Ĵ
 Uso       Generico                                                   
Ĵ
         ATUALIZACOES SOFRIDAS DESDE A CONSTRUAO INICIAL.             
Ĵ
Programador  Data    BOPS   Motivo da Alteracao                     
Ĵ
Marcelo Pim.26/11/9713534A Ajustar decl.e iniciali. das variaveis : 
Marcelo Pim.26/11/9713534A lCriaHeader,cLoteEst,nTotal,cArquivo     
Rodrigo Sar.22/12/9819017A Acerto na exclusao do apontamento        
Fernando J. 15/04/99XXXXXX Acerto de Macro para o PROTHEUS          
CesarValadao21/05/99XXXXXX Permitir F4 somente em NUMLOTE/LOTECTL   
Marcelo Pim.22/10/01PYME   Adequacao do fonte para utilizacao do    
                    PYME   Siga PyMe.                               
ٱ




Ŀ
Descrio  PLANO DE MELHORIA CONTINUA        Programa   MATA685.PRX  
Ĵ
ITEM PMC   Responsavel               Data          |BOPS             
Ĵ
      01                                           |                 
      02  Flavio Luiz Vicco          06/04/2006    |00000096552      
      03                                           |                 
      04                                           |                 
      05  Flavio Luiz Vicco          02/06/2006    |00000100469      
      06  Flavio Luiz Vicco          02/06/2006    |00000100469      
      07  Flavio Luiz Vicco          12/04/2006    |00000096069      
      08  Flavio Luiz Vicco          12/04/2006    |00000096069      
      09                                           |                 
      10  Flavio Luiz Vicco          06/04/2006    |00000096552      
ٱ

*/
Function Mata685(xAutoCab,xAutoItens,nOpcAuto,xNumSeqAuto)

PRIVATE cCadastro := OemToAnsi(STR0001)	//"Apontamento da Perda"....
PRIVATE cPicOP,cPicProd,cPicData,cPicRec,cPicOperac

//Ŀ
// Variaveis utilizadas na GetDados.                            
//
PRIVATE nPosQuant:=0,nPosMot:=0,nPosDesc:=0,nPosTipo:=0,nPosCod:=0,nPosLoc:=0,nPosLote:=0,nPosLotCtl:=0,nPosDValid:=0,nPosOper:=0,nPosLtDest:=0;nPosVlDest:=0
PRIVATE nPosLocFis:=0,nPosNumSer:=0,nPosProDes:=0,nPosLocDes:=0,nPosQtdDes:=0,nPosLocFDe:=0,nPosNSeDes:=0,nPosData:=0
PRIVATE aPerda:={},aHdPerda:={}
PRIVATE l685Auto   := xAutoCab <> NIL  .And. xAutoItens <> NIL
PRIVATE aAutoCab   := {}
PRIVATE aAutoItens := {} 
Private cDoctoExec := '' 

//Ŀ
// Variaveis utilizadas para indicar qual apontamento esta sendo utilizado 
//
PRIVATE l680:=.F.,l681:=.F.,l682:=.F., l250 := .F. ,l240 := .F.,l241 := .F.

//Ŀ
// Inicializa pictures dos gets fixos.						     
//
cPicOP	   := PesqPict("SBC","BC_OP")
cPicProd   := PesqPict("SBC","BC_PRODUTO")
cPicRec	   := PesqPict("SBC","BC_RECURSO")
cPicOperac := PesqPict("SBC","BC_OPERAC")

//Ŀ
// Pega a variavel que identifica se o calculo do custo e' :    
//               O = On-Line                                    
//               M = Mensal                                     
//
PRIVATE cCusMed := GetMv("MV_CUSMED")
PRIVATE bCols   :={|x,y|aCols[x][y]}

//If (!l685Auto) .Or. TYPE("mv_par01") <> "N" // Trecho "If"comentado Ref.: 17720918_DMANSMARTSQUAD1-27415_Reserplastic_MATA685_Por execauto no respeita o parmetro F12
	Pergunte("MTA685",.F.)
//EndIF 


PRIVATE lParam  := IIf(mv_par01 == 1, .T. , .F.)

If cCusMed == "O"
	PRIVATE nHdlPrv 			// Endereco do arquivo de contra prova dos lanctos cont.
	PRIVATE lCriaHeader := .T. 	// Para criar o header do arquivo Contra Prova
	PRIVATE cLoteEst  			// Numero do lote para lancamentos do estoque
	//Ŀ
	// Posiciona numero do Lote para Lancamentos do Faturamento     
	//
	dbSelectArea("SX5")
	dbSeek(xFilial("SX5")+"09EST")
	cLoteEst:=IIF(Found(),Trim(X5Descri()),"EST ")
	PRIVATE nTotal := 0			// Total dos lancamentos contabeis
	PRIVATE cArquivo			// Nome do arquivo contra prova
EndIf

//Ŀ
// Define Array contendo as Rotinas a executar do programa      
// ----------- Elementos contidos por dimensao ------------     
// 1. Nome a aparecer no cabecalho                              
// 2. Nome da Rotina associada                                  
// 3. Usado pela rotina                                         
// 4. Tipo de Transao a ser efetuada                          
//    1 -Pesquisa e Posiciona em um Banco de Dados              
//    2 -Simplesmente Mostra os Campos                          
//    3 -Inclui registros no Bancos de Dados                    
//    4 -Altera o registro corrente                             
//    5 -Estorna registro selecionado gerando uma contra-partida
//
PRIVATE aRotina := MenuDef()
Private lEstornoAut := .F.
Private cNumSeqAuto := ''
Default xNumSeqAuto := ''

If  ( Type("l685Auto") <> "U" .And. l685Auto )
	
	aAutoCab := SBC->(MSArrayXDB(xAutoCab,,nOpcAuto))
	aAutoItens := aClone(xAutoItens)  // MSArrayxDB(xAutoItens,, nOpcAuto)
	
	nPos := aScan(xAutoCab,{|x|Upper(AllTrim(x[1]))=="DOCTO"})
	If nPos # 0
		cDoctoExec := xAutoCab[nPos,2]
	EndIf
	
	If nOpcAuto == 6
		SeekAuto("SBC",xAutoCab)		
		lEstornoAut := .T.
		cNumSeqAuto := xNumSeqAuto
	EndIf
	
	MBrowseAuto(nOpcAuto,Aclone(aAutoCab),"SBC")
Else
	//Ŀ
	// Ativa tecla F12 para acionar perguntas                         
	//
	Set Key VK_F12 To MTA685PERG()

	//Ŀ
	// Endereca a funcao de BROWSE                                    
	//
	mBrowse(6,1,22,75,"SBC")
	//Ŀ
	// Desativa tecla que aciona perguntas                            
	//
	Set Key VK_F12 To
Endif

/*

Ŀ
Funo    A685Manut  Autor  Rodrigo de A. Sartorio Data  26/12/96 
Ĵ
Descrio  Programa para excluir apontamento de perdas.               
Ĵ
Sintaxe    A685Exclui(ExpC1,ExpN1,ExpN2)                              
Ĵ
Parametros ExpC1 = Alias do arquivo                                   
           ExpN1 = Numero do registro                                 
           ExpN2 = Numero da opcao selecionada                        
Ĵ
 Uso       MATA685                                                    
ٱ


*/
Function A685Manut(cAlias,nReg,nOpc)
Static l685Inclui:= NIL
Local nCnt  	 :=0,nRecOld,xUsado
Local nOpca 	 :=0
Local oDlg
Local lPyme  	 := Iif(Type("__lPyme") <> "U",__lPyme,.F.)
Local aObjects	 := {}
Local aPosObj 	 := {}
Local aInfo	 	 := {}
Local aSize	 	 := {}
Local aAlter     := {}
Local l685Inc    := .F.
Local l685Exc    := .F.
Local lSldBloq   := .F.
Local nExc       := 0
Local dDataFec   := MVUlmes()
Local nX         := 0
Local aButtons   := {} 
Local aNoFields  := {'BC_OP','BC_OPERAC','BC_RECURSO','BC_NUMSEQ','BC_SEQSD3'}
Local cSeekSBC   := ''
Local cWhile     := ''
Local cF3		   := If(!Empty(CpoRetF3("BC_OP")),CpoRetF3("BC_OP"),"SC2")
Local oPanel1
Local oPanel2
local lA685OPE 	:= SuperGetMV("MV_A685OPE",.F.,'N')

Private oGet,nRegi,oSize,oPanel
Private cOrdemP,cProduto,cOperacao,cRecurso,cNumSeq,cRoteiro
Private aHeader := {}
Private aCols   := {}
Private l240    := .F.
Private l241    := .F.

Private lResDevLoc := .F. // Funo PergDevLoc Rotina SIGACUSB 

SetEmpenho(.F.)

If dDataFec >= dDataBase
	Help ( " ", 1, "FECHTO" )
	Return
EndIf

//Ŀ
// Avalia botoes do usuario                                     
//
If ExistBlock( "MA685BUT" )         
	If Valtype(aButtons) == "A"
		aButtons := ExecBlock( "MA685BUT", .F., .F. )
	EndIf
EndIf

If nOpc == 3
	l685Inc    := .T.
	l685Inclui := If(l685Inclui==NIL,ExistBlock("MT685ATU"), l685Inclui)
Else
	l685Exc    := .T.
EndIf	
//Ŀ
// Recupera os dados do SBC.                                    
//
dbSelectArea(cAlias)
dbSetOrder(1)
cOrdemP	 :=IIf(l685Inc,CriaVar("BC_OP",.F.),SBC->BC_OP)
cOperacao:=IIf(l685Inc,CriaVar("BC_OPERAC",.F.),SBC->BC_OPERAC)
cRecurso :=IIf(l685Inc,CriaVar("BC_RECURSO",.F.),SBC->BC_RECURSO)

If lEstornoAut .AND. !empty(cNumSeqAuto)
	cNumSeq	 := cNumSeqAuto
Else
	cNumSeq	 :=IIf(l685Inc,CriaVar("BC_NUMSEQ",.F.),SBC->BC_NUMSEQ)
EndIf

If !l685Inc
	nRecOld  :=SBC->(Recno())
	dbSelectArea("SC2")
	dbSetOrder(1)
	If dbSeek(xFilial("SC2")+SBC->BC_OP)
		//Ŀ
		// Recupera o Codigo do Produto da OP no SC2.                   
		//
		cProduto := SC2->C2_PRODUTO
	EndIf
	// Posiciona SBC no primeiro registro
	dbSelectArea("SBC")
	dbSeek(xFilial("SBC")+cOrdemP+cNumseq)
	Do While !EOF() .And. BC_FILIAL+BC_OP+BC_NUMSEQ == xFilial("SBC")+cOrdemP+cNumSeq
		nCnt++
		dbSkip()
	EndDo
	dbGoto(nRecOld)
EndIf

//Ŀ
// Montagem do AHEADER e ACOLS para GetDados  
//
dbSelectArea("SX3")
If nOpc == 4
	dbSetOrder(2)
	If dbSeek("D3_ESTORNO")
		AADD(aAlter,"D3_ESTORNO")
		AADD(aHeader,{STR0005,x3_campo,x3_picture,x3_tamanho,x3_decimal,x3_valid,x3_usado,x3_tipo,x3_arquivo,x3_context})
	EndIf
EndIf

//Ŀ
// Incluso do boto para explodir 1nvel da estrutura 
//
If nOpc == 3 
	Aadd(aButtons, {'PRODUTO',{||A685Mtela()},OemToAnsi(STR0016),OemToAnsi(STR0017)}) //"Exploso do 1 nvel da estrutura",//1 Nivel 
Endif

If nOpc == 3
	//Ŀ
	// Sintaxe da FillGetDados(/*nOpcX*/,/*Alias*/,/*nOrdem*/,/*cSeek*/,/*bSeekWhile*/,/*uSeekFor*/,/*aNoFields*/,/*aYesFields*/,/*lOnlyYes*/,/*cQuery*/,/*bMontCols*/,/*lEmpty*/,/*aHeaderAux*/,/*aColsAux*/,/*bAfterCols*/) |
	//	
	FillGetDados(nOpc,'SBC',,,,,aNoFields,,,,,.T.,,,,,{||AfterHead()}, )
Else
	cSeekSBC := xFilial('SBC')+cOrdemP+cNumSeq
	cWhile   := 'SBC->BC_FILIAL+SBC->BC_OP+SBC->BC_NUMSEQ'

	//Ŀ
	// Sintaxe da FillGetDados(/*nOpcX*/,/*Alias*/,/*nOrdem*/,/*cSeek*/,/*bSeekWhile*/,/*uSeekFor*/,/*aNoFields*/,/*aYesFields*/,/*lOnlyYes*/,/*cQuery*/,/*bMontCols*/,/*lEmpty*/,/*aHeaderAux*/,/*aColsAux*/,/*bAfterCols*/) |
	//	
	FillGetDados(nOpc,'SBC',1,cSeekSBC,{|| &cWhile },,aNoFields,,,,,,,,{||AfterCols(nOpc)},,{||AfterHead()}, )
EndIf

If ( Type("l685Auto") == "U" .OR. !l685Auto )
	aSize := MsAdvSize()
	aInfo := {aSize[1],aSize[2],aSize[3],aSize[4],3,3}

	AADD(aObjects,{100,015,.T.,.T.})
	AADD(aObjects,{100,085,.T.,.T.})
	aPosObj:= MsObjSize( aInfo, aObjects, .T. ,.F.)

	//Ŀ
	// Ativa tecla F4 para comunicacao com Saldos dos Lotes         
	//
	Set Key VK_F4 TO A685ShowF4()

	DEFINE MSDIALOG oDlg TITLE cCadastro From aSize[7],0 To aSize[6],aSize[5] OF oMainWnd PIXEL
	
	oSize := FWDefSize():New(.T.,,,oDlg)
	oSize:AddObject("Panel", 100, 100, .T., .T. ) 
	       
	oSize:lProp := .T. //permite redimencionar as telas de acordo com a proporo do AddObject
	oSize:Process() //executa os calculos
	
	oPanel := TPanel():New(oSize:GetDimension("Panel","LININI"),;
	                        oSize:GetDimension("Panel","COLINI"),,oDlg,,,,,,;
	                        oSize:GetDimension("Panel","XSIZE"),;
	                        oSize:GetDimension("Panel","YSIZE"))
	
	oPanel1:= tPanel():New(000,000,,oPanel,,,,,,015,aPosObj[1,3])
	oPanel2:= tPanel():New(000,000,,oPanel,,,,,,085,aPosObj[2,3]/2)                                                   

	oPanel1:Align := CONTROL_ALIGN_TOP
	oPanel2:Align := CONTROL_ALIGN_ALLCLIENT

	@ 003,003 TO aPosObj[1,3],aPosObj[1,4] OF oPanel1  PIXEL
	@ aPosObj[1,1]+05,010 SAY OemToAnsi(STR0006) SIZE 65,7 OF oPanel1 PIXEL			//"Ordem de Produo"
	@ aPosObj[1,1]+05,151 SAY OemToAnsi(STR0007) SIZE 22,7 OF oPanel1 PIXEL			//"Produto"
	If !lPyme
		@ aPosObj[1,1]+20,010 SAY OemToAnsi(STR0008) SIZE 25,7 OF oPanel1 PIXEL		//"Operao"
		@ aPosObj[1,1]+20,151 SAY OemToAnsi(STR0009) SIZE 22,7 OF oPanel1 PIXEL		//"Recurso"
	Endif
	@ aPosObj[1,1]+05,063 MSGET cOrdemP F3 cF3   SIZE 50,10 Picture cPicOP   When !l685Exc Valid NaoVazio() .And. ExistCpo("SC2") .And. A685IniCpo() OF oPanel1 PIXEL
	@ aPosObj[1,1]+05,177 MSGET cProduto     SIZE 135,10 Picture cPicProd When .F. OF oPanel1 PIXEL
	If !lPyme
		@ aPosObj[1,1]+20,063 MSGET cOperacao F3 "SG2OPE" SIZE 15,10 Picture cPicOperac When !l685Exc Valid IIF(!Empty(cOperacao),A685Oper(),.T.)  OF oPanel1 PIXEL
		@ aPosObj[1,1]+20,177 MSGET cRecurso  F3 "SH1" SIZE 25,10 Picture cPicRec    When !l685Exc Valid (Vazio() .Or. ExistCpo("SH1")) .And. M685ULT() OF oPanel1 PIXEL
	Endif
	oGet := MSGetDados():New(aPosObj[2,1],aPosObj[2,2],aPosObj[2,3],aPosObj[2,4],nOpc,If(nOpc==3,"PerdaLinOK","Allwaystrue"),"A685TudoOk","",If(nOpc==3,.T.,.F.),If(nOpc==4,aAlter,Nil),/*11*/,/*12*/,/*13*/,/*14*/,/*15*/,/*16*/,/*17*/,oPanel)
	                                                                                                                                                                      
	oGet:oBrowse:Align := CONTROL_ALIGN_ALLCLIENT

	ACTIVATE MSDIALOG oDlg ON INIT EnchoiceBar(oDlg,{||nOpca:=1,if(oGet:TudoOk(),oDlg:End(),nOpca := 0)},{||oDlg:End()},,aButtons)
Else
	
	//Ŀ
	// validando dados pela rotina automatica                       
	//

	aValidGet := {}
	Aadd(aValidGet,{"cOrdemP"   ,aAutoCab[aScan(aAutoCab, {|z| AllTrim(z[1]) == "BC_OP"     }),2],'ExistCpo("SC2") .And. A685IniCpo()',.t.})	
	Aadd(aValidGet,{"cOperacao" ,aAutoCab[aScan(aAutoCab, {|z| AllTrim(z[1]) == "BC_OPERAC" }),2],'IIF(!Empty(cOperacao),A685Oper(),.T.)',.t.})
	Aadd(aValidGet,{"cRecurso"  ,aAutoCab[aScan(aAutoCab, {|z| AllTrim(z[1]) == "BC_RECURSO"}),2],'Vazio() .Or. ExistCpo("SH1")',.t.})

	If ! SBC->(MsVldGAuto(aValidGet)) // consiste os gets
		nOpcA := 0
	Else  
		//If MsGetDAuto(aAutoItens,"PerdaLinOK", ,aAutoCab)
		If MsGetDAuto(aAutoItens,If(nOpc==3,"PerdaLinOK","Allwaystrue"), ,aAutoCab, nOpc)
			nOpcA := 1
		EndIf
	Endif
EndIf
If nOpca == 1 .And. nOpc != 2
	If nOpc == 3
		aPerda  := aClone(aCols)
		aHdPerda:= aClone(aHeader)
		//GravaSBC(cOrdemP,cOperacao,cRecurso,"MATA685")
		GravaSBC(cOrdemP,cOperacao,cRecurso,"MATA685",,,cDoctoExec)
		If l685Inclui
			ExecBlock("MT685ATU",.F.,.F.)
		EndIf

		//Ŀ
		// Integracao com SIGASGA                     
		//
		SGAIntPCP(.T.,cOrdemP)

		aPerda:={}
		aHdPerda:={}
	Else
		SC2->(DbSelectArea("SC2"))
		SC2->(DbSetOrder(1))
		If SC2->(dbSeek(xFilial("SC2")+cOrdemP))
			If !Empty(SC2->C2_DATRF) .And. !lA685OPE = 'S'
				MSGALERT( STR0023, STR0024 )
			Else	       
				If lParam
					//--> Verifica se o saldo do armazem destino esta bloqueado
					For nX := 1 To Len(aCols)
						If !Empty(aCols[nX,nPosProDes]) .And. !SldBlqSB2(aCols[nX,nPosProDes],aCols[nX,nPosLocDes])
							lSldBloq := .T.
							Exit
						EndIf
					Next nX
					//Ŀ
					// Verifica se algum produto esta' sendo inventariado. 
					//
					For nX := 1 To Len(aCols)
						If BlqInvent(aCols[nX,nPosCod],aCols[nX,nPosLoc])
							Help(" ",1,"BLQINVENT",,aCols[nX,nPosCod]+OemToAnsi(STR0015)+aCols[nX,nPosLoc],1,11)
							lSldBloq := .T.
							Exit
						EndIf
						If !Empty(aCols[nX,nPosProDes]) .And. BlqInvent(aCols[nX,nPosProDes],aCols[nX,nPosLocDes])
							Help(" ",1,"BLQINVENT",,aCols[nX,nPosProDes]+OemToAnsi(STR0015)+aCols[nX,nPosLocDes],1,11)
							lSldBloq := .T.
							Exit
						EndIf
					Next nX

					//--> Somente ira estornar se NAO houver saldo bloqueado em nenhum produto
					If !lSldBloq
						EstornaSBC(cOrdemP,cNumSeq)
					EndIf
				Else
					EstornaSBC(cOrdemP,cNumSeq)
				EndIf
			EndIf
		Endif
		//Ŀ
		// Integracao com SIGASGA                     
		//
		SGAIntPCP(.F.,cOrdemP)
	EndIf

EndIf
SET KEY VK_F4 TO
//Se est executando a rotina pela integrao Totvs MES, 
// no faz o dbgoto para conseguir recuperar o RECNO da tabela SBC e retornar na mensagem.
If (Type('lRunPPI') == "L" .And. lRunPPI == .F.) .Or. Type('lRunPPI') != "L" 
	dbSelectArea(cAlias)
	dbGoto(nReg)
EndIf

SetEmpenho(Nil)

RETURN NIL

/*


Ŀ
Funo    EstornaSBC Autor Rodrigo de A. Sartorio  Data  27/12/96 
Ĵ
Descrio  Estorna as devolucoes do material perdido e apaga os regis 
           stros no SBC.                                              
ٱ


*/
Function EstornaSBC(cNumOP,cNumSeq)

LOCAL zi        := 0
LOCAL nRecOrig,nRecDest,cCodDest,cLocDest,cLocLzDest

LOCAL aRegs     := {}
LOCAL aRegsDE4  := {}

LOCAL dDataFec 	:= MVUlmes()

LOCAL n         := 0
LOCAL nSeek     := 0

LOCAL lEstorna  := .T.
LOCAL lSBCExcl  := ExistBlock("SBCExcl")
Local lWmsNew   := SuperGetMv("MV_WMSNEW",.F.,.F.)

PRIVATE aRegSD3  := {}

Default lEstornoAut := .F. //Define Estorno automtico, proteo para rotinas de apontamento de prod.

If Type('l685Auto') == "L" .And. l685Auto
	PRIVATE l240Auto := .T.
endif
dbSelectArea("SBC")
dbSetOrder(1)
If dbSeek(xFilial("SBC")+cNumOp+cNumSeq)
	Do While !Eof() .And. BC_FILIAL+BC_OP+BC_NUMSEQ == xFilial("SBC")+cNumOp+cNumSeq
		If FunName() == "MATA685"
			n++
			If (aCols[n,1]#"S") .AND. (!lEstornoAut .AND. empty(cNumSeqAuto))
				dbSkip()
				Loop
			EndIf
		EndIf

		If lEstornoAut .and. (aScan(aCols,{|z| AllTrim(z[2])== Alltrim(SBC->BC_PRODUTO)}) == 0) //verifica se o produto est no acols.
			dbSkip()
			Loop
		EndIf

		dbSelectArea("SD3")
		dbSetOrder(4)
		dbSeek(xFilial("SD3")+If(!Empty(SBC->BC_SEQSD3),SBC->BC_SEQSD3,SBC->BC_NUMSEQ)+"E0") 
		
		If Found()
			If dDataFec >= SD3->D3_EMISSAO
				Help ( " ", 1, "FECHTO" )
				Return
			Endif
				
			Do While !Eof() .And. xFilial("SD3")+If(!Empty(SBC->BC_SEQSD3),SBC->BC_SEQSD3,SBC->BC_NUMSEQ) == D3_FILIAL+D3_NUMSEQ
				If D3_ESTORNO == "S"
					dbSkip()
					Loop
				EndIf

				If (AScan(aRegs,Recno())) == 0

					If SD3->D3_CF == 'DE4' .AND. (SD3->D3_CHAVE == "E9" .OR. SD3->D3_CHAVE == "E0") //Adicionado o E0 pois existem na base um erro que deixou alguns registro com E
						AADD(aRegsDE4,{SD3->D3_NUMSEQ,SD3->D3_CHAVE, Recno()})
					ElseIf Alltrim(SD3->D3_CF) == "RE4" .AND. SD3->D3_CHAVE == "E0"
						AADD(aRegs,{Recno(),SBC->(Recno()),.T.})
					ElseIF  SD3->D3_CHAVE == "E0"
						AADD(aRegs,{Recno(),SBC->(Recno()),.F.})
					EndIf
				EndIf
				dbSelectArea("SD3")	
				dbSkip()
			EndDo
		
		Else
			RecLock("SBC",.F.)
			dbDelete()
			MsUnlock()
			//Ŀ
			// Executa execblock SBCExcl apos estorno do movimento               
			//
			If lSBCExcl
				ExecBlock("SBCExcl",.F.,.F.)
			EndIf
		EndIf
		dbSelectArea("SBC")
		dbSkip()
	EndDo
	For zi:=1 to Len(aRegs)
		dbSelectArea("SD3")
		dbGoto(aRegs[zi,1]) //-- Posiciona no registro RE4
		//Ŀ
		// Envia p/func. de atualizacoes (SD3,SB2,SB3,SC2,..) 
		//
		If aRegs[zi,3]
			lEstorna:=.T.
			aRegSD3:={}
			nRecOrig:=Recno()
			aAdd(aRegSD3,SD3->(Recno()))
			If (nSeek:=Ascan(aRegsDE4, {|x| x[1] == SD3->D3_NUMSEQ})) > 0
				dbGoto(aRegsDE4[nSeek,3]) //-- Posiciona o SD3 no registro de Devolucao (DE4) 
				aAdd(aRegSD3,SD3->(Recno()))        
			EndIf
			If !Eof() .And. SD3->D3_CF == "DE4"
				lEstorna:=MatVldEst(SD3->D3_COD,;
				SD3->D3_LOCAL,;
				SD3->D3_LOTECTL,;
				SD3->D3_NUMLOTE,;
				SD3->D3_LOCALIZ,;
				SD3->D3_NUMSERI,;
				SD3->D3_NUMSEQ,;
				SD3->D3_DOC,;
				SD3->D3_QUANT)
				If lEstorna
					cCodDest:=SD3->D3_COD
					cLocDest:=SD3->D3_LOCAL
					cLocLzDest:=SD3->D3_LOCALIZ
					nRecDest:=Recno()
					dbGoto(nRecOrig)
					a260Processa(SD3->D3_COD,SD3->D3_LOCAL,SD3->D3_QUANT,SD3->D3_DOC,SD3->D3_EMISSAO,SD3->D3_QTSEGUM,SD3->D3_NUMLOTE,SD3->D3_LOTECTL,SD3->D3_DTVALID,SD3->D3_NUMSERI,SD3->D3_LOCALIZ,cCodDest,cLocDest,cLocLzDest,.T.,nRecOrig,nRecDest,"MATA260")
					A260COMUM()
				EndIf

				// Programa para ajustes das Tabelas (SD2,SDC,B8,SBF)	
				If IsInCallStack("MATA681") .OR. IsInCallStack("MATA680")
					AJUSTSLD(nRecOrig,cNumOp)
				EndIf
							
			EndIf

		Else
			lEstorna:=.T.
			If Substr(SD3->D3_CF,1,1) == "D"
				lEstorna:=MatVldEst(SD3->D3_COD,;
				SD3->D3_LOCAL,;
				SD3->D3_LOTECTL,;
				SD3->D3_NUMLOTE,;
				SD3->D3_LOCALIZ,;
				SD3->D3_NUMSERI,;
				SD3->D3_NUMSEQ,;
				SD3->D3_DOC,;
				SD3->D3_QUANT)
			EndIf

			If !fEstornaQly()
				lEstorna := .F.
			EndIf

			If lEstorna
				
				a240DesAtu()
				
				//Ŀ
				// Verifica se o custo medio e' calculado On-Line               
				//
				If cCusMed == "O" .And. nTotal > 0
					//Ŀ
					// Inicializa perguntas deste programa                          
					//
					//Ŀ
					// mv_par01 - Se mostra e permite digitar lancamentos contabeis   
					// mv_par02 - Se deve aglutinar os lancamentos contabeis          
					//
					pergunte("MTA240",.F.)
					lDigita   := Iif(mv_par01 == 1,.T.,.F.)
					lAglutina := Iif(mv_par02 == 1,.T.,.F.)
					//Ŀ
					// Se ele criou o arquivo de prova ele deve gravar o rodape'    
					//
					RodaProva(nHdlPrv,nTotal)

					//Ŀ
					//Atualiza o cdigo de dirio
					//
					If UsaSeqCor()
						cCodDiario := ctbaVerdia() 
						aCtbDia := {{"SD3",SD3->(RECNO()),cCodDiario,"D3_NODIA","D3_DIACTB"}}
					Else
					aCtbDia := {}
					EndIF    
					
					cA100Incl(cArquivo,nHdlPrv,3,cLoteEst,lDigita,lAglutina,,,,,,aCtbDia)
					lCriaHeader := .T.
				EndIf
				
				// Programa para ajustes das Tabelas (SD2,SDC,B8,SBF)	
				If IsInCallStack("MATA681") .OR. IsInCallStack("MATA680")
					AJUSTSLD(aRegs[zi,1],cNumOp)
				EndIF

				// Recompe o saldo WMS do apontamento de perda por OP
				If FindFunction("WmsPerdaOP") .And. lWmsNew .And. IntWMS(SD3->D3_COD)
					WmsPerdaOP(aRegs[zi,2],.T.)
				EndIf
			EndIf
		EndIf
		If lEstorna
			/*	
			Para produto WMS somente o saldo ser estornado e no devera estornar o empenho.
			Devido a incompatibilidades no uso do campo D4_TRT no WMS, estornar o empenho demanda um grande esforo de validao, 
			tornando o cdigo muito verboso e inviabilizando a sua utilizao neste processo porque o ganho no  proporcional ao esforo.
			Se o cliente julgar necessario podera empenhar novamente a OP via WMSA505.	
			*/
			If !IntWMS(SD3->D3_COD)
				fRefazSD4(aRegs[zi])
			EndIf
			SBC->(dbGoto(aRegs[zi,2]))
			RecLock("SBC",.F.)
			dbDelete()
			MsUnlock()
			//Ŀ
			// Executa execblock SBCExcl apos estorno do movimento               
			//
			If lSBCExcl
				ExecBlock("SBCExcl",.F.,.F.)
			EndIf
		EndIf

	Next zi

EndIf

/*/{Protheus.doc} f685GRVSMN
	Grava os dados da tabela auxiliar de estorno de apontamento de perda
	@type Function
	@author rafael.kleestadt
	@since 06/08/2021
	@version 1.0
	@param aRecnos, array, array contendo os recno da SBC, Array de recnos da SDC, array de recnos da SD4 e recno da SD3
	@return return_var, return_type, return_description
	@example
	(examples)
	{{SBC->BC_NUMSEQ, SBC->BC_QUANT}, aTRTsSD4, SD3->D3_NUMSEQ}
	@see (links_or_references)
/*/
Function f685GRVSMN(aDadosSMN)
Local aArea     := GETAREA()
Local cFilSMN   := xFilial('SMN')
Local nCountSBC := 0
Local nCountSD4 := 0

If TableInDic("SMN")
	For nCountSBC := 1 To Len(aDadosSMN)
		For nCountSD4 := 1 To Len(aDadosSMN[nCountSBC, 2])

			RecLock('SMN', .T.)
				SMN->MN_FILIAL := cFilSMN
				SMN->MN_SEQSD3 := aDadosSMN[nCountSBC, 3]
				SMN->MN_SEQSBC := aDadosSMN[nCountSBC, 1, 1]
				SMN->MN_TRTSD4 := aDadosSMN[nCountSBC, 2, nCountSD4]
				SMN->MN_QTDSD4 := aDadosSMN[nCountSBC, 1, 2]
			SMN->(MsUnlock())

		Next nCountSD4
	Next nCountSBC
EndIf

RESTAREA(aArea)
	
Return NIL

/*/{Protheus.doc} fRefazSD4()
	Ajusta as quantidades da SD4 e SB8 conforme dados gravados na nova tabela SMN
	@type  Static Function..
	@author rafael.kleestadt
	@since 11/08/2021
	@version 1.0
	@param aRegSBCSD3, array, array contendo o recno da sbc e da sd3
	@return return_var, return_type, return_description
	@example
	(examples)
	@see (links_or_references)
/*/
Static Function fRefazSD4(aRegSBCSD3)
Local aAreas := {SBC->(GETAREA()), SD3->(GETAREA()), SD4->(GETAREA()), SB8->(GETAREA()), SDC->(GETAREA()), SBF->(GETAREA())}
Local lDistMov  := SuperGetMV("MV_DISTMOV",.F.,.F.)
Local lQuebrSD4 := .F. 
Local lPrimeiro := .F.
Local lSegundo  := .F.
Local lRefazSD4 := .T.
Local nRecnoSD4 := 0

Default lResDevLoc:= .F.

SD3->(DBGOTO( aRegSBCSD3[1] ))//SD3
SBC->(DBGOTO( aRegSBCSD3[2] ))//SBC

If TableInDic("SMN")
	DbSelectArea('SMN')
	SMN->(DbSetOrder(1))//MN_FILIAL+MN_SEQSD3+MN_SEQSBC+MN_TRTSD4                                                                                                                                                                                                                   
	If SMN->(DbSeek(xFilial('SMN')+SD3->D3_NUMSEQ+SBC->BC_NUMSEQ))
		DbSelectArea('SD4')
		SD4->(DbSetOrder(1))//D4_FILIAL+D4_COD+D4_OP+D4_TRT+D4_LOTECTL+D4_NUMLOTE
		If SD4->(DbSeek(xFilial('SD4')+SBC->(BC_PRODUTO+BC_OP)))	
			nRecnoSD4 := SD4->(Recno())

			lQuebrSD4 := .F. 
			lPrimeiro := .F.
			lSegundo  := .F.

			While SD4->(!EOF()) .And. SD4->(D4_FILIAL+D4_COD+D4_OP) == xFilial('SD4')+SBC->(BC_PRODUTO+BC_OP)

				If !lPrimeiro
					lPrimeiro := .T.
				Else
					lSegundo  := .T.
				EndIf
									
				If SD4->D4_QUANT <> SD4->D4_QTDEORI //Se j teve apontamento de produo (MATA250,MATA680,MATA681)
					lRefazSD4 := .F.
				ElseIf !lDistMov .And. lResDevLoc//Redistribuir o endereo.
					lRefazSD4 := .F.
				EndIf

				SD4->(DbSkip())
			EndDo 

			lQuebrSD4 := Iif(lSegundo == .F.,.F.,.T.)
			
			SD4->(dbGoto(nRecnoSD4))
				While SD4->(!EOF()) .And. SD4->(D4_FILIAL+D4_COD+D4_OP) == xFilial('SD4')+SBC->(BC_PRODUTO+BC_OP) .And. lRefazSD4
					RecLock('SD4', .F.)
						
						If (SD4->(D4_TRT+D4_LOTECTL+D4_NUMLOTE) == SMN->MN_TRTSD4+SD3->(D3_LOTECTL+D3_NUMLOTE) .Or. !lQuebrSD4) .And. EMPTY(SD4->D4_OPORIG)
							If Rastro(SD4->D4_COD) .And. lQuebrSD4 //Caso s controle de endereo no altera as qtds da SD4
								SD4->D4_QTDEORI += SMN->MN_QTDSD4
								SD4->D4_QUANT   += SMN->MN_QTDSD4
							Else 
								If Rastro(SD4->D4_COD) .And. !lQuebrSD4
									SD4->D4_LOTECTL := SBC->BC_LOTECTL
									SD4->D4_DTVALID := SBC->BC_DTVALID
								EndIf 
							EndIf

							DbSelectArea('SB8')
							SB8->(dbSetOrder(3)) // B8_FILIAL+B8_PRODUTO+B8_LOCAL+B8_LOTECTL+B8_NUMLOTE+DTOS(B8_DTVALID)
							If SB8->(dbSeek( xFilial("SB8")+SBC->(BC_PRODUTO+BC_LOCORIG)+SD3->(D3_LOTECTL+D3_NUMLOTE)))
								GravaB8Emp('+',SMN->MN_QTDSD4,"",.T.)
							EndIf
							SB8->(DbCloseArea())

							DbSelectArea('SDC')
							DbSetOrder(2) // DC_FILIAL+DC_PRODUTO+DC_LOCAL+DC_OP+DC_TRT+DC_LOTECTL+DC_NUMLOTE+DC_LOCALIZ+DC_NUMSERI
							If SDC->(dbSeek(xFilial('SDC')+SBC->(BC_PRODUTO+BC_LOCORIG)+SBC->BC_OP+SMN->MN_TRTSD4+SD3->(D3_LOTECTL+D3_NUMLOTE+D3_LOCALIZ+D3_NUMSERI), .F.))
								Reclock('SDC', .F.)
									SDC->DC_QTDORIG += SMN->MN_QTDSD4
									SDC->DC_QUANT   += SMN->MN_QTDSD4
								SDC->(MsUnlock())
							EndIf
							SDC->(DbCloseArea())

							DbSelectArea('SBF')
							DbSetOrder(1) // BF_FILIAL+BF_LOCAL+BF_LOCALIZ+BF_PRODUTO+BF_NUMSERI+BF_LOTECTL+BF_NUMLOTE
							If dbSeek(xFilial('SBF')+SD3->(D3_LOCAL+D3_LOCALIZ+D3_COD+D3_NUMSERI+D3_LOTECTL+D3_NUMLOTE), .F.)
								GravaBFEmp('+',SMN->MN_QTDSD4,"",.T.)
							EndIf
							SBF->(DbCloseArea())

						ElseIf EMPTY(SD4->D4_LOTECTL)// registro criado no apontamento de perda
							
							If Rastro(SD4->D4_COD) .AND. SD4->D4_QUANT == SD4->D4_QTDEORI  //Caso s controle de endereo no altera as qtds da SD4
								SD4->D4_QTDEORI -= SMN->MN_QTDSD4
								SD4->D4_QUANT   -= SMN->MN_QTDSD4

								If SD4->D4_QUANT == 0
									SD4->(DbDelete())
								EndIf
							EndIf
							
						EndIf
					SD4->(MsUnlock())
					SD4->(DbSkip())
					Loop
				EndDo
		EndIf
		SD4->(DbCloseArea())
	EndIf
	SMN->(DbCloseArea())
EndIf

AEVAL(aAreas, {|x| RESTAREA(x)})

Return .T.

/*


Ŀ
Funo    A685IniCpo Autor Rodrigo de A. Sartorio  Data  27/12/96 
Ĵ
Descrio  Inicializa campo do produto .		                      
ٱ


*/
Function A685IniCpo()
Local lRet 		:= .T.
local lA685OPE 	:= SuperGetMV("MV_A685OPE",.F.,'N')

SC2->(dbSetorder(1))
If SC2->(dbSeek(xFilial("SC2")+cOrdemP))
	//If !l685Auto .And. !Empty(SC2->C2_DATRF) .And. lParam //.And. SC2->C2_DATRF < dDataBase
	If !l685Auto .And. !Empty(SC2->C2_DATRF) 
		If lA685OPE = 'S'
			lRet := Aviso(STR0010,STR0021,{STR0013,STR0014}) == 2 //"A ordem de produo informada encontra-se encerrada. Neste caso o custo desta perda no ser apropriado. Deseja prosseguir?"###"Cancelar"###"Continuar"
		Else
			MSGALERT( STR0019 + '. ' + STR0006 + ' ' + STR0020 + '.', STR0010 )	//"Atencao"###"Acesso negado. Ordem de Produo Encerrado(a)."
			lRet := .F.
		EndIf
	EndIf
	If !l685Auto .And. INCLUI .And. SC2->C2_TPOP == "P"	//Prevista
		Help(" ",1,"NOPPREVIST")
		lRet := .F.
	EndIf
	If lRet
		cProduto:=SC2->C2_PRODUTO
		If !Empty(SC2->C2_ROTEIRO)
			cRoteiro:=SC2->C2_ROTEIRO
		Else
			SB1->(dbSetOrder(1))
			SB1->(dbSeek(xFilial("SB1")+cProduto))
			cRoteiro:=If(Empty(SB1->B1_OPERPAD),"01",SB1->B1_OPERPAD)
		EndIf
	EndIf
	If lRet .And. FindFunction("A113BlqApo")
		lRet := A113BlqApo(cOrdemP)
	EndIf
EndIf
Return lRet

/*


Ŀ
Funo     A685Oper  Autor Rodrigo de A. Sartorio  Data  28/06/97 
Ĵ
Descrio  Valida operacao com Recurso.		                          
ٱ


*/
Function A685Oper()
Local cOper:=&(ReadVar()),lRet:=.T.
Local cAlias:=Alias(),nRecno:=Recno(),nOrder:=IndexOrd()
dbSelectArea("SG2")
If a630SeekSG2(1,cProduto,xFilial("SG2")+cProduto+cRoteiro+cOperacao)
	cRecurso := SG2->G2_RECURSO
Else
	Help(" ",1,"REGNOIS")
	lRet:=.F.
EndIf      
Return lRet

/*


Ŀ
Funo    MTA658PERG Autor  Rodrigo de A. Sartorio Data  28/12/95 
Ĵ
Descrio  Chamada da funcao PERGUNTE                                 
Ĵ
 Uso       MATA685                                                    
ٱ


*/
Static Function MTA685PERG()
Pergunte("MTA685",.T.)
lParam := IIf(mv_par01 == 1, .T. , .F.)
Return NIL

/*


Ŀ
Funo    A685ShowF4 Autor  Rodrigo de A. Sartorio Data  30/10/97 
Ĵ
Descrio  Chamada da funcao F4LOTE e F4LOCALIZ                       
Ĵ
 Uso       MATA685                                                    
ٱ


*/
Function A685ShowF4()
Local bCols     :={|x,y|aCols[x][y]}
Local lMVPerdInf:= If(Type('lPerdInf')#"L",SuperGetMV('MV_PERDINF',.F.,.F.),lPerdInf)
Local cOP       := NIL

If lMVPerdInf
	If FunName() == "MATA250"
		cOP := M->D3_OP
	ElseIf FunName() == "MATA680" .Or. FunName() == "MATA681"
		cOP := M->H6_OP
	EndIf
EndIf

If ("BC_LOCALIZ" $ ReadVar())
	F4Localiz(,,, "A260",Eval(bCols,n,nPosCod),Eval(bCols,n,nPosLoc),,ReadVar(),,cOP)
ElseIf ("BC_LOCDEST" $ ReadVar())
	F4Localiz(,,, "A260",Eval(bCols,n,nPosProDes),Eval(bCols,n,nPosLocDes),,ReadVar(),,cOP)
ElseIf ("BC_NUMLOTE" $ ReadVar()) .Or. ("BC_LOTECTL" $ ReadVar())
	F4Lote(,,,"A685",Eval(bCols,n,nPosCod),Eval(bCols,n,nPosLoc),lParam,,,cOP)
EndIf
Return NIL

/*


Ŀ
Funo    A685Locali Autor  Larson Zordan          Data  07/01/02 
Ĵ
Descrio  Validacao do campo D3_LOCALIZ da GetDados                  
Ĵ
 Uso       MATA685                                                    
ٱ


*/
Function A685Localiz(nLoc)
Local cVar := ReadVar()
Local lRet := .T.
Local lWmsNew    := SuperGetMv("MV_WMSNEW",.F.,.F.)

If nLoc == 1
	If !Localiza(aCols[n,nPosCod],.T.)
		M->BC_LOCALIZ := CriaVar("BC_LOCALIZ")
		M->BC_NUMSERI := CriaVar("BC_NUMSERI")
	Else 
		M->BC_LOCORIG := If("BC_LOCORIG"$cVar,M->BC_LOCORIG,aCols[n,nPosLoc])
		M->BC_LOCALIZ := If("BC_LOCALIZ"$cVar,M->BC_LOCALIZ,aCols[n,nPosLocFis])
		M->BC_NUMSERI := If("BC_NUMSERI"$cVar,M->BC_NUMSERI,aCols[n,nPosNumSer])
		If !Empty(M->BC_LOCORIG) .And. !Empty(M->BC_LOCALIZ)
			lRet:=ExistCpo("SBE",M->BC_LOCORIG+M->BC_LOCALIZ)
				
			//Validaes complementares do WMS
			If lRet .AND. lWmsNew .And. IntWMS(aCols[n,nPosCod]) .And. FindFunction("WMSVldPerda")
				lRet := WMSVldPerda(.T.,M->BC_LOCORIG,M->BC_LOCALIZ)
			EndIf 
		EndIf
	EndIf
          
ElseIf nLoc == 2
	If !Localiza(aCols[n,nPosProDes],.T.)
		M->BC_LOCDEST := CriaVar("BC_LOCDEST")
		M->BC_NSEDEST := CriaVar("BC_NSEDEST")
	Else 
		M->BC_LOCAL   := If("BC_LOCAL"$cVar,M->BC_LOCAL,aCols[n,nPosLocDes])
		M->BC_LOCDEST := If("BC_LOCDEST"$cVar,M->BC_LOCDEST,aCols[n,nPosLocFDe])
		M->BC_NSEDEST := If("BC_NSEDEST"$cVar,M->BC_NSEDEST,aCols[n,nPosNSeDes])
		If !Empty(M->BC_LOCAL) .And. !Empty(M->BC_LOCDEST)
			lRet:=ExistCpo("SBE",M->BC_LOCAL+M->BC_LOCDEST)
		Endif		
	EndIf
EndIf

Return(lRet)

/*


Ŀ
Funo     A685Prod  Autor  Larson Zordan          Data  07/01/02 
Ĵ
Descrio  Validacao do campo BC_PRODUTO e BC_CODDEST da GetDados     
Ĵ
 Uso       MATA685                                                    
ٱ


*/
Function A685Prod(nLoc)
Local cProd := If(nLoc==1,ReadVar(aCols[n,nPosCod]),ReadVar(aCols[n,nPosProDes]))
If nLoc == 1 .And. !Localiza(&cProd,.T.)
	If nPosLocFis > 0
		aCols[n,nPosLocFis] := CriaVar("BC_LOCALIZ")
	EndIf
	If nPosNumSer > 0
		aCols[n,nPosNumSer] := CriaVar("BC_NUMSERI")
	EndIf
EndIf
If nLoc == 2 .And. !Localiza(&cProd,.T.)
	If nPosLocDes > 0
		aCols[n,nPosLocDes] := CriaVar("BC_LOCDEST")
	EndIf
	If nPosNSeDes > 0
		aCols[n,nPosNSeDes] := CriaVar("BC_NSEDEST")
	EndIf
EndIf
If !Rastro(&cProd)
	If nPosLotCtl > 0
		aCols[n,nPosLotCtl] := CriaVar("BC_LOTECTL")
	EndIf
	If nPosLote > 0
		aCols[n,nPosLote]   := CriaVar("BC_NUMLOTE")
	EndIf
	If nPosDValid > 0
		aCols[n,nPosDValid] := CriaVar("BC_DTVALID")
	EndIf
	If nPosLtDest > 0
		aCols[n,nPosLtDest] := CriaVar("BC_LOTDEST")
	EndIf
	If nPosVlDest > 0
		aCols[n,nPosVlDest] := CriaVar("BC_DTVLDES")
	EndIf
EndIf
Return .T.

/*


Ŀ
Funo     M685ULT   Autor  Marcos V. Ferreira     Data  20/12/04 
Ĵ
Descrio  P.E. Utilizado na validacao do ultimo campo apresentado no 
                Get Fixo da janela de Apontamento de Perda            
Ĵ
 Uso       MATA685                                                    
ٱ


*/
Function M685ULT()
Local lRet := .T.

IF ExistBlock("M685ULT")
	lRet := ExecBlock("M685ULT",.F.,.F.)
Endif

Return If(ValType(lRet)=="L",lRet,.F.)

/*


Ŀ
Funo    A685TudoOk Autor  Marcos V. Ferreira     Data  14/02/05 
Ĵ
Descrio  Funcao utilizada para Validar estorno do Apontamento de    
           Perda                                                      
Ĵ
 Uso       MATA685                                                    
ٱ


*/
Static Function A685TudoOk()      

Local lRet := .T.
Local n    := 0
Local nX   := 0
LOCAL dDataFec  := MVUlmes()

//Ŀ
// Verifica se algum produto est sendo inventariado.  
//
For nX := 1 To Len(aCols)
	
	//Ŀ
	//Verifica se tem permissao de armazem  |
	//
	If lRet
		If	!(lRet := MaAvalPerm(3,{aCols[nX,nPosLoc],aCols[nX,nPosCod]}))
			Exit
		EndIf
		
		If (!Empty(aCols[nX,nPosLocDes])) .And. (!Empty(aCols[nX,nPosProDes]))
			If	!(lRet := MaAvalPerm(3,{aCols[nX,nPosLocDes],aCols[nX,nPosProDes]}))
				Exit
			EndIf
		EndIf
	EndIf
	If BlqInvent(aCols[nX,nPosCod],aCols[nX,nPosLoc])
		Help(" ",1,"BLQINVENT",,aCols[nX,nPosCod]+OemToAnsi(STR0015)+aCols[nX,nPosLoc],1,11)
		lRet := .F.
		Exit
	EndIf
	If !Empty(aCols[nX,nPosProDes]) .And. BlqInvent(aCols[nX,nPosProDes],aCols[nX,nPosLocDes])
		Help(" ",1,"BLQINVENT",,aCols[nX,nPosProDes]+OemToAnsi(STR0015)+aCols[nX,nPosLocDes],1,11)
		lRet := .F.
		Exit
	EndIf
	
	//Verificar data de movimentao e data de emissao da OP
	If !Empty(aCols[nX,nPosData])
		If dDataFec >= aCols[nX,nPosData]
			Help ( " ", 1, "FECHTO" )
			lRet := .F.
			Exit
		EndIf
	    IF FindFunction("a250ConsDtOp")
	        lRet := a250ConsDtOp(aCols[nX,nPosData],cOrdemP)
		    If !lRet
		       Exit
		    EndIf
		EndIf
	EndIf	
	
Next nX

If lRet .And. !Inclui
	dbSelectArea("SBC")
	dbSetOrder(1)
	If dbSeek(xFilial("SBC")+cOrdemP+cNumSeq)
		Do While !Eof() .And. BC_FILIAL+BC_OP+BC_NUMSEQ == xFilial("SBC")+cOrdemP+cNumSeq
			n++
			If (aCols[n,1]#"S")
				dbSkip()
				Loop
			EndIf
			dbSelectArea("SD3")
			dbSetOrder(4)
			dbSeek(xFilial("SD3")+If(!Empty(SBC->BC_SEQSD3),SBC->BC_SEQSD3,SBC->BC_NUMSEQ)+"E0"+SBC->BC_PRODUTO)
			If !Found()
				dbSeek(xFilial("SD3")+If(!Empty(SBC->BC_SEQSD3),SBC->BC_SEQSD3,SBC->BC_NUMSEQ)+"E0"+SBC->BC_CODDEST)
			EndIf
			If Found()
				Do While !Eof() .And. xFilial("SD3")+If(!Empty(SBC->BC_SEQSD3),SBC->BC_SEQSD3,SBC->BC_NUMSEQ)+"E0" == D3_FILIAL+D3_NUMSEQ+D3_CHAVE
					If D3_ESTORNO == "S"
						dbSkip()
						Loop
					EndIf
					//Ŀ
					// Avalia se pode estornar um movimento do apontamento de perda 
					//
					If SubStr(SD3->D3_CF,1,1) <> "R" .And. !(MatVldEst(SD3->D3_COD,SD3->D3_LOCAL,	SD3->D3_LOTECTL,SD3->D3_NUMLOTE,SD3->D3_LOCALIZ,;
						SD3->D3_NUMSERI,SD3->D3_NUMSEQ,SD3->D3_DOC,SD3->D3_QUANT))
						lRet := .F.
						Exit
					Endif
					dbSelectArea("SD3")	
					dbSkip()
				EndDo
			EndIf
			dbSelectArea("SBC")
			dbSkip()
		EndDo
	EndIf
EndIf

//Ŀ
// Execblock MT685TOK  aps Conf.da Incluso/Alterao/Deleo       
//
If lRet .And. ExistBlock("MT685TOK")
	lRet := ExecBlock("MT685TOK", .F., .F., {Inclui})
	lRet := If(ValType(lRet)=="L",lRet,.T.)
EndIf

Return lRet

/*


Ŀ
Funo    A685QTDUM  Autor  Flavio Luiz Vicco      Data  11/04/06 
Ĵ
Descrio  Calcula Qtd na 1a. e 2a. U.M. (Origem e Destino)           
Ĵ
 Uso       MATA685 - X3_VALID DOS CAMPOS:                             
                     BC_QUANT/BC_QTSEGUM/BC_QTDDEST/BC_QTDDES2        
ٱ


*/
Function A685QTDUM()
Local aArea1    := GetArea()
Local cCampo    := Alltrim(ReadVar())
Local nQuant    := 0
Local cProduto  := ""
Local nPosCod   := aScan(aHeader,{|z| AllTrim(z[2])=="BC_PRODUTO"})
Local nPosCodD  := aScan(aHeader,{|z| AllTrim(z[2])=="BC_CODDEST"})
Local nPosQtd   := aScan(aHeader,{|z| AllTrim(z[2])=="BC_QUANT"  })
Local nPosQtd2  := aScan(aHeader,{|z| AllTrim(z[2])=="BC_QTSEGUM"})
Local nPosQtdD  := aScan(aHeader,{|z| AllTrim(z[2])=="BC_QTDDEST"})
Local nPosQtdD2 := aScan(aHeader,{|z| AllTrim(z[2])=="BC_QTDDES2"})

nQuant:=&(cCampo)

If !Empty(aCols[n][nPosCodD]) .And. (cCampo == "M->BC_QTDDEST" .Or. cCampo == "M->BC_QTDDES2")
	cProduto := aCols[n][nPosCodD]
Else
	cProduto := aCols[n][nPosCod]
EndIf

dbSelectArea("SB1")
dbSetOrder(1)
If dbSeek(xFilial("SB1")+cProduto)
	// Altera campo da Quantidade na Segunda U.M.
	If cCampo == "M->BC_QUANT"
		If nPosQtd2 > 0
			aCols[n][nPosQtd2] := ConvUm(SB1->B1_COD,nQuant,aCols[n][nPosQtd2],2)
			M->BC_QTSEGUM := aCols[n][nPosQtd2]
			// Atualiza qtd Destino
			aCols[n][nPosQtdD] := nQuant
			M->BC_QTDDEST := aCols[n][nPosQtdD]
			// Atualiza qtd Destino 2a.U.M.
			aCols[n][nPosQtdD2] := aCols[n][nPosQtd2] 
			M->BC_QTDDES2 := aCols[n][nPosQtdD2]
		EndIf
	// Altera campo da Quantidade na Primeira U.M.
	ElseIf cCampo == "M->BC_QTSEGUM"
		If nPosQtd > 0 .and. (M->BC_QTSEGUM # aCols[n][nPosQtd2])
			aCols[n][nPosQtd] := ConvUm(SB1->B1_COD,aCols[n][nPosQtd],nQuant,1)
			M->BC_QUANT := aCols[n][nPosQtd]
			// Atualiza qtd Destino
			aCols[n][nPosQtdD] := aCols[n][nPosQtd]
			M->BC_QTDDEST := aCols[n][nPosQtdD]
			// Atualiza qtd Destino 2a.U.M.
			aCols[n][nPosQtdD2] := nQuant
			M->BC_QTDDES2 := aCols[n][nPosQtdD2]
		EndIf
	// Altera campo da Quantidade Destino na Segunda U.M.
	ElseIf cCampo == "M->BC_QTDDEST"
		If nPosQtdD2 > 0
			aCols[n][nPosQtdD2] := ConvUm(SB1->B1_COD,nQuant,0,2)
			M->BC_QTDDES2 := aCols[n][nPosQtdD2]
		EndIf
	// Altera campo da Quantidade Destino na Primeira U.M.
	ElseIf cCampo == "M->BC_QTDDES2"
		If nPosQtdD > 0 .and. (M->BC_QTDDES2 # aCols[n][nPosQtdD2])
			aCols[n][nPosQtdD] := ConvUm(SB1->B1_COD,0,nQuant,1)
			M->BC_QTDDEST := aCols[n][nPosQtdD]
		EndIf
	EndIf
EndIf
RestArea(aArea1)

Return .T. 

/*/


Ŀ
Programa  MenuDef    Autor  Fabio Alves Silva      Data 08/11/2006
Ĵ
Descrio  Utilizacao de menu Funcional                               
                                                                      
                                                                      
Ĵ
Retorno   Array com opcoes da rotina.                                 
Ĵ
ParametrosParametros do array a Rotina:                               
          1. Nome a aparecer no cabecalho                             
          2. Nome da Rotina associada                                 
          3. Reservado                                                
          4. Tipo de Transao a ser efetuada:                        
          		1 - Pesquisa e Posiciona em um Banco de Dados           
              2 - Simplesmente Mostra os Campos                       
              3 - Inclui registros no Bancos de Dados                 
              4 - Altera o registro corrente                          
              5 - Remove o registro corrente do Banco de Dados        
          5. Nivel de acesso                                          
          6. Habilita Menu Funcional                                  
Ĵ
   DATA    Programador   Manutencao efetuada                         
Ĵ
                                                                     
ٱ


/*/

Static Function MenuDef()     
PRIVATE aRotina	:= { {	STR0002,"AxPesqui"	, 0, 1, 0, .F.},;	//"Pesquisar"
						{	STR0003,"A685Manut"	, 0, 2, 0, nil},;	//"Visualizar"
						{	STR0004,"A685Manut"	, 0, 3, 0, nil},;	//"Incluir"
						{	STR0005,"A685Manut"	, 0, 6, 0, nil}}	//"Excluir"	 
					
//Ŀ
// Ponto de entrada utilizado para inserir novas opcoes no array aRotina  
//
If ExistBlock("MTA685MNU")
	ExecBlock("MTA685MNU",.F.,.F.)
EndIf
Return(aRotina)

/*


Ŀ
Funo    AfterHead  Autor  Felipe Nunes de Toledo Data  09/01/07 
Ĵ
Descrio Adiciona validacoes que nao existem no x3_valid, durante    
          a criacao do aHeader.                                       
Ĵ
 Uso       MATA685                                                    
ٱ


*/
Static Function AfterHead()
Local cVldProd   := ''
Local cValdCod   := ''

nPosQuant  := Ascan(aHeader,{|x| Trim(x[2])=="BC_QUANT"  })
nPosCod    := Ascan(aHeader,{|x| Trim(x[2])=="BC_PRODUTO"})
nPosLoc    := Ascan(aHeader,{|x| Trim(x[2])=="BC_LOCORIG"})
nPosDesc   := Ascan(aHeader,{|x| Trim(x[2])=="BC_DESCRI" })
nPosTipo   := Ascan(aHeader,{|x| Trim(x[2])=="BC_TIPO"   })
nPosLote   := Ascan(aHeader,{|x| Trim(x[2])=="BC_NUMLOTE"})
nPosLotCtl := Ascan(aHeader,{|x| Trim(x[2])=="BC_LOTECTL"})
nPosDValid := Ascan(aHeader,{|x| Trim(x[2])=="BC_DTVALID"})
nPosLtDest := Ascan(aHeader,{|x| Trim(x[2])=="BC_LOTDEST"})
nPosVlDest := Ascan(aHeader,{|x| Trim(x[2])=="BC_DTVLDES"})
nPosLocFis := Ascan(aHeader,{|x| Trim(x[2])=="BC_LOCALIZ"})
nPosNumSer := Ascan(aHeader,{|x| Trim(x[2])=="BC_NUMSERI"})
nPosProDes := Ascan(aHeader,{|x| Trim(x[2])=="BC_CODDEST"})
nPosLocDes := Ascan(aHeader,{|x| Trim(x[2])=="BC_LOCAL"  })
nPosQtdDes := Ascan(aHeader,{|x| Trim(x[2])=="BC_QTDDEST"})
nPosLocFDe := Ascan(aHeader,{|x| Trim(x[2])=="BC_LOCDEST"})
nPosNSeDes := Ascan(aHeader,{|x| Trim(x[2])=="BC_NSEDEST"})
nPosOper   := Ascan(aHeader,{|x| Trim(x[2])=="BC_OPERADO"})
nPosMot    := Ascan(aHeader,{|x| Trim(x[2])=="BC_MOTIVO" })
//nPosMot    := Ascan(aHeader,{|x| Trim(x[2])=="BC_DATA" })
nPosData   := Ascan(aHeader,{|x| Trim(x[2])=="BC_DATA" })

cVldProd   := Rtrim(aHeader[nPosCod,6])
cValdCod   := RTrim(aHeader[nPosProDes ,6])

aHeader[nPosCod    ,6] := cVldProd + ".AND.If(! __lPyme, A685PROD(1), .T. )"
aHeader[nPosProDes ,6] := cValdCod + ".AND.If(! __lPyme, A685PROD(2), .T. )"

Return( .T. )
/*


Ŀ
Funo    AfterCols  Autor  Felipe Nunes de Toledo Data  09/01/07 
Ĵ
Descrio Executado apos inserir nova linha no aCols.                 
Ĵ
Sintaxe    AfterCols(ExpN1)                                           
Ĵ
Parametros ExpN1 = Numero da opcao selecionada                        
Ĵ
 Uso       MATA685                                                    
ٱ


*/
Static Function AfterCols(nOpc)
Local nTamNum := TamSX3("X5_CHAVE")[1]

If nOpc == 4
	aCols[Len(aCols)][1] := "S"
EndIf

//Busca a descrio do motivo de refugo.
//Se o cliente tem os campos novos da CYO, ento ele tem a melhoria em que foi retirada
//o cadastro de refugo da SX5 e transferido para o SFCA003
If campoCYO()
	CYO->(DbSetOrder(1))
	If CYO->(dbSeek(xFilial("CYO")+SBC->BC_MOTIVO))
		aCols[Len(aCols)][nPosDesc] := Substr(CYO->CYO_DSRF,1,35)
	EndIF
Else
	aTabGen := FWGetSX5('43')

	nI := ASCAN(aTabGen, {|x| x[3]==Padr(SBC->BC_MOTIVO,nTamNum)}) 

	If nI > 0 
		aCols[Len(aCols)][nPosDesc] := Substr(aTabGen[nI][4],1,35)
	Else
		aCols[Len(aCols)][nPosDesc] := ' '
	Endif
EndIF


Return( .T. )                                                                             

/*

                                                	
ͻ
Programa   A685Mtela  Autor Gabriela Kamimoto    Data   07/12/11   
͹
Desc.      Monta a tela de Exploso do 1 nvel da estrutura          
           na rotina Apotamento de Perda.                             
͹
Uso        MATA685                                                    
ͼ
          
*/
Function A685Mtela()
Local oDlg         
Local oOp
Local oProduto
Local oQtde       
Local nQtdeSBC	 := 0 
Local lOk       := .F.
Local aArrayAux	 := {}
Local nX       := 0
Local nAcuSDC	 := 0

	DEFINE MSDIALOG oDlg FROM 140,000 TO 280,340 TITLE OemToAnsi(STR0016) PIXEL //"Exploso do 1 nvel da estrutura"
	@ 0.9,01 SAY OemToAnsi(STR0006) SIZE 15,10 OF oDlg //"Ordem de Produo"
	@ 2.1,01 SAY OemToAnsi(STR0007) SIZE 10,10 OF oDlg //"Produto"
	@ 3.3,01 SAY OemToAnsi(STR0018) SIZE 5,10  OF oDlg //"Qtde. Perd"
	@ 10,60 MSGET oOp VAR cOrdemP Picture PesqPict("SBC","BC_OP") When .F. Valid (NaoVazio(cOrdemP)) SIZE 100,9 OF oDlg PIXEL
	@ 25,60 MSGET oProduto VAR cProduto Picture PesqPict("SBC","BC_PRODUTO") When .F. Valid (NaoVazio(cProduto)) SIZE 100,9 OF oDlg PIXEL
	@ 40,60 MSGET oQtde VAR nQtdeSBC Picture PesqPict("SC2","C2_QUANT")Valid !(Empty(cOrdemP)) .And. (Positivo(nQtdeSBC)) .And. (NaoVazio(nQtdeSBC)) SIZE 100,9 OF oDlg PIXEL
	DEFINE SBUTTON FROM 55,63 TYPE 1 ACTION (lOK := .T.,oDlg:End()) ENABLE OF oDlg
	DEFINE SBUTTON FROM 55,90 TYPE 2 ACTION (lOk := .F.,oDlg:End()) ENABLE OF oDlg
	ACTIVATE MSDIALOG oDlg CENTERED	                       

//Apos a confirmacao da explosao, calcula e preenche os campos BC_PRODUTO, BC_LOCORIG, BC_QUANT.

If lOK 
	SD4->(DbSetOrder(2))
	SD4->(DbSeek(xFilial("SD4")+cOrdemP))
	SDC->(DbSetOrder(2))
	
	While !SD4->(Eof()) .And. SD4->(D4_FILIAL+D4_OP) == xFilial("SD4")+cOrdemP
		If SD4->D4_QTDEORI < 0
			SD4->(DbSkip())
			Loop
		EndIf	
		
		nAcuSDC := (SD4->D4_QTDEORI / SC2->C2_QUANT) * nQtdeSBC
		aArrayAux := {}
				
		SDC->(DbSeek(xFilial("SDC")+SD4->D4_COD+SD4->D4_LOCAL+cOrdemP+SD4->(D4_TRT+D4_LOTECTL+D4_NUMLOTE)))
		While !SDC->(Eof()) .And. SDC->(DC_FILIAL+DC_OP+DC_TRT+DC_LOTECTL+DC_NUMLOTE) == xFilial("SDC")+cOrdemP+SD4->(D4_TRT+D4_LOTECTL+D4_NUMLOTE)
			For nX := 1 to Len(aHeader)
				Do case
		 		Case nX == GdFieldPos("BC_PRODUTO")
		 			AAdd(aArrayAux,SDC->DC_PRODUTO)
		 		Case nX == GdFieldPos("BC_LOCORIG")
		 			AAdd(aArrayAux,SDC->DC_LOCAL)
		 		Case nX == GdFieldPos("BC_QUANT")
		 			AAdd(aArrayAux,(SDC->DC_QTDORIG / SC2->C2_QUANT) * nQtdeSBC)
		 		Case nX == GdFieldPos("BC_LOTECTL")
		 			AAdd(aArrayAux,SDC->DC_LOTECTL)
		 		Case nX == GdFieldPos("BC_NUMLOTE")
		 			AAdd(aArrayAux,SDC->DC_NUMLOTE)
				Case nX == GdFieldPos("BC_DTVALID")
		 			AAdd(aArrayAux,SD4->D4_DTVALID)					 
		 		Case nX == GdFieldPos("BC_LOCALIZ")
		 			AAdd(aArrayAux,SDC->DC_LOCALIZ)
		 		Case nX == GdFieldPos("BC_NUMSERI")
		 			AAdd(aArrayAux,SDC->DC_NUMSERI)
		 		Case nX == (Len(aHeader)-1)
		 			AAdd(aArrayAux,"SBC")
		 		Case nX == (Len(aHeader))
		 			AAdd(aArrayAux,0)
		 		Case nX == GdFieldPos("BC_DATA")
			 		AAdd(aArrayAux,dDataBase)
		 		Otherwise
		 			AAdd(aArrayAux,CriaVar(Alltrim(aHeader[nX,2]),.F.))
		 		EndCase 
			Next nX            
			nAcuSDC -= (SDC->DC_QTDORIG / SC2->C2_QUANT) * nQtdeSBC
			AAdd(aArrayAux,.F.)
		    // Se a primeira linha esta em branco remove a mesma do acols
			If Empty(aTail(aCols)[GDFieldPos("BC_PRODUTO")])
				aDel(aCols,Len(aCols))
				aSize(aCols,Len(aCols)-1)
			EndIf
	 		AAdd(aCols,aArrayAux)
	 		aArrayAux := {}
	 		SDC->(DbSkip()) 
		End
		
		If !IsProdMOD(SD4->D4_COD)
			If nAcuSDC > 0 	
	 			For nX := 1 to Len(aHeader)
			 		Do case
			 		Case nX == GdFieldPos("BC_PRODUTO")
			 			AAdd(aArrayAux,SD4->D4_COD)
			 		Case nX == GdFieldPos("BC_LOCORIG")
			 			AAdd(aArrayAux,SD4->D4_LOCAL)
			 		Case nX == GdFieldPos("BC_QUANT")
			 			AAdd(aArrayAux,nAcuSDC)
			 		Case nX == GdFieldPos("BC_LOTECTL")
				 		AAdd(aArrayAux,SD4->D4_LOTECTL)
				 	Case nX == GdFieldPos("BC_NUMLOTE")
				 		AAdd(aArrayAux,SD4->D4_NUMLOTE)	
				 	Case nX == GdFieldPos("BC_DTVALID")
				 		AAdd(aArrayAux,SD4->D4_DTVALID)						 
			 		Case nX == (Len(aHeader)-1)
			 			AAdd(aArrayAux,"SBC")
			 		Case nX == (Len(aHeader))
			 			AAdd(aArrayAux,0)
	 				Case nX == GdFieldPos("BC_DATA")
	 					AAdd(aArrayAux,dDataBase)
			 		Otherwise
			 			AAdd(aArrayAux,CriaVar(Alltrim(aHeader[nX,2]),.F.))
			 		EndCase 
			 	Next nX              
			 	AAdd(aArrayAux,.F.)
			 	 // Se a primeira linha esta em branco remove a mesma do acols
				If Empty(aTail(aCols)[GDFieldPos("BC_PRODUTO")])
					aDel(aCols,Len(aCols))
					aSize(aCols,Len(aCols)-1)
				EndIf
	 			AAdd(aCols,aArrayAux)
 			EndIf 		
 		EndIf
		
 		//Validacao do gatilho
		If ExistTrigger("BC_QUANT")
			//RunTrigger(2,Len(aCols),,"BC_QUANT")
			RunTrigger(2,Len(aCols),NIL,,"BC_QUANT")
		EndIf
 		SD4->(DbSkip()) 
 	EndDo		                                               
EndIf
Return

/*


ͻ
Programa  A685VldPrdAutor  Gabriela Kamimoto    Data   09/12/11   
͹
Desc.      Validao do campo BC_PRODUTO na rotina Apontamento de     
           Perda para no permitir perda de insumos que no fazem     
           parte da OP.                                               
͹
Uso         AP                                                        
ͼ


*/
Function A685VldPrd() 
Local lRet 		:= .T.
Local lPerbPrd  := SuperGetMV("MV_PERBPRD",.F.)

//Validao para no permitir perda de insumos que no fazem parte da OP
If lPerbPrd 
	DbSelectArea("SD4")
	SD4->(DbSetOrder(2))
	
	If IsInCallStack("MATA681") .OR. IsInCallStack("MATA680")
		lRet := (M->BC_PRODUTO == SC2->C2_PRODUTO .Or. SD4->(dbSeek(xFilial("SD4")+M->H6_OP+M->BC_PRODUTO)))
	Else
		If IsInCallStack("MATA250")
			lRet := (M->BC_PRODUTO == SC2->C2_PRODUTO .Or. SD4->(dbSeek(xFilial("SD4")+M->D3_OP+M->BC_PRODUTO)))
		Else
			lRet := (M->BC_PRODUTO == SC2->C2_PRODUTO .Or. SD4->(dbSeek(xFilial("SD4")+cOrdemP+M->BC_PRODUTO)))			
		EndIf			
	endif 
	
	If !lRet
		Help("",1,"A685SD4")
	EndIf
EndIf

Return lRet
//-------------------------------------------------------------------
/*/{Protheus.doc} A685PerdCq
Validao do campo BC_LOCORIG
@param cLocOrig - M->BC_LOCORIG
@author Jos Eullio
@since 02/05/2018
@version P11
@return lRet
/*/
//--------------------------------------------------------------------
Function A685PerdCq(cLocOrig)
Local lRet		:= .T.
Local cLocCq	:= GetMvNNR('MV_CQ','98')

If mv_par01 == 1 .And. cLocOrig == cLocCq
	lRet := .F.
	Help(NIL, NIL, STR0030, NIL, STR0028, 1, 0, NIL, NIL, NIL, NIL, NIL,{STR0029})	//No  permitido informar o armazm de controle de qualidade (CQ) nesta operao. //Selecione um armazm vlido
    
EndIf

Return lRet


/*/

Ŀ
Funo     CampoCYO  Autor  Michelle Ramos    Data 02.01.2019       
Ĵ
Descricao  Verifica se existe os novos campos da tabela CYO             
            Se o cliente tiver os novos campos, o cadastro do motivo de 
	           Refugo  na CYO e no mais na SX5                           
Ĵ
Retorno    lRet: True - Se os campos novos existem (utiliza a CYO)     
                  False -   os campos novos no existem (utiliza a SX5) 
Ĵ

 
/*/

Function campoCYO()
Local aArea    := GetArea()
Local lRet     := .T.

DbSelectArea("CYO")
If CYO->(FieldPos("CYO_LGRT")) > 0 
	lRet := .T.
Else
	lRet := .F.
EndIf

RestArea(aArea)
Return lRet


//-------------------------------------------------------------------
/*/{Protheus.doc} AJUSTSLD
Ajusta Saldo quando o Empenho esta divido, quando existe apontamento
de perda. (SD4,SB8,SBF,SDC)
@param nRecOrig - Recno da Tabela SD3
@param cNumOp   - Numero da OP
@author  Thiago kobi Zoppi
@since   03/10/2019
/*/
//-------------------------------------------------------------------
FUNCTION AJUSTSLD(nRecOrig,cNumOp) 

Local AreaSD3	:= SD3->(GetArea())
Local AreaSC2	:= SC2->(GetArea())
lOCAL lAjustEnd := .T. 

DbSelectArea("SD3")
SD3->(dbGoto(nRecOrig))

If Rastro(SD3->D3_COD)
	dbSelectArea("SD4")
	SD4->(dbSetOrder(1))
	// Verifica se tem empenho sem o Lote
	IF dbSeek(xFilial("SD4")+SD3->D3_COD+cNumOp+SD3->D3_TRT+CriaVar("D4_LOTECTL")+CriaVar("D4_NUMLOTE"))
		// Se quantidade do empenho - quantidade da Movimentacao = 0 deleta o registro.	
		IF SD4->D4_QUANT - SD3->D3_QUANT = 0 
			RecLock("SD4",.F.)
			SD4->(dbDelete())
			SD4->(MsUnlock())
		Else        
			// Se quantidade do empenho diferente quantidade da Movimentacao = desconta da quantidade do empenho
			RecLock("SD4",.F.)
			Replace D4_QUANT With D4_QUANT - SD3->D3_QUANT
			Replace D4_QTDEORI With D4_QTDEORI - SD3->D3_QUANT
			Replace D4_QTSEGUM With D4_QTSEGUM - SD3->D3_QTSEGUM
			SD4->(MsUnlock())
		EndIf

		// Verifica o empenho com Lote e desconta ajusta o valor que foi estornado
		IF dbSeek(xFilial("SD4")+SD3->D3_COD+cNumOp+SD3->D3_TRT+SD3->D3_LOTECTL+IF(RASTRO(SD3->D3_COD,"S"),SD3->D3_NUMLOTE,CriaVar("D4_NUMLOTE")))
			RecLock("SD4",.F.)
			Replace D4_QUANT With D4_QUANT + SD3->D3_QUANT
			Replace D4_QTDEORI With D4_QTDEORI + SD3->D3_QUANT
			Replace D4_QTSEGUM With D4_QTSEGUM + SD3->D3_QTSEGUM
			SD4->(MsUnlock())

			//Ajusta empenho Lotes
			dbSelectArea("SB8")
			dbSetOrder(3)
			IF dbSeek(xFilial("SB8")+SD4->D4_COD+SD4->D4_LOCAL+SD4->D4_LOTECTL+If(Rastro(SD4->D4_COD,"S"),SD4->D4_NUMLOTE,""))
				GravaB8Emp("+",SD3->D3_QUANT,"F",NIL,SD3->D3_QTSEGUM)
			End 
		Else 
			//CRIAR O EMPENHO QUE COM BASE NA SD3
			GravaEmp(SD3->D3_COD,SD3->D3_LOCAL,SD3->D3_QUANT,SD3->D3_QTSEGUM,SD3->D3_LOTECTL,SD3->D3_NUMLOTE,SD3->D3_LOCALIZ,SD3->D3_NUMSERI,cNumOp,SD3->D3_TRT,NIL,NIL,"SC2",,dDataBase,{},,,.F.,.T.,,.T.,(Localiza(SD3->D3_COD) .Or. Rastro(SD3->D3_COD)))
			lAjustEnd := .F. 
		EndIf
	EndIf
	
	//Ajusta empenho endereo Sbf
	If Localiza(SD3->D3_COD) .AND. lAjustEnd				

		dbSelectArea("SD4")
		SD4->(dbSetOrder(1))
		IF dbSeek(xFilial("SD4")+SD3->D3_COD+cNumOp+SD3->D3_TRT+SD3->D3_LOTECTL+IF(RASTRO(SD3->D3_COD,"S"),SD3->D3_NUMLOTE,CriaVar("D4_NUMLOTE")))

			DbSelectArea("SDC")
			DbSetOrder(2)
			IF DbSeek(xFilial("SDC")+SD4->D4_COD+SD4->D4_LOCAL+SD4->D4_OP+SD4->D4_TRT+SD4->D4_LOTECTL+If(Rastro(SD4->D4_COD,"S"),SD4->D4_NUMLOTE,""))
				RecLock("SDC",.F.)
				REPLACE SDC->DC_QUANT 	WITH SD4->D4_QUANT
				REPLACE SDC->DC_QTDORIG WITH SD4->D4_QTDEORI
				REPLACE SDC->DC_QTSEGUM WITH SD4->D4_QTSEGUM
				SDC->(MsUnlock())
			Endif						
		EndIf
	EndIf 

EndIf

RestArea(AreaSD3)
RestArea(AreaSC2)

Return

/*/{Protheus.doc} fEstornaQly
	(long_description)
	@type  Static Function
	@author mauricio.joao
	@since 05/08/2020
	@version 1.0
	@param param_name, param_type, param_descr
	@return return_var, return_type, return_description
	@example
	(examples)
	@see (links_or_references)
	/*/
Static Function fEstornaQly()
Local lRetorno := .T.
Local cLocCQ   := GetMvNNR('MV_CQ','98')
Local cFilSD7  := xFilial('SD7')
Local aEnvCele := {}
//Ŀ
// Verifica se o Estorno referente ao CQ pode ser feito  
//
lEstCQ := .F.
If AllTrim(cLocCQ) == AllTrim(SD3->D3_LOCAL)
	dbSelectArea('SD7')
	dbSetOrder(3)	
	If dbSeek(cFilSD7+SD3->D3_COD+SD3->D3_NUMSEQ, .F.)
		cNumCQ   := SD7->D7_NUMERO
		cSeekSD7 := cFilSD7 + cNumCQ + SD3->D3_COD
		lEstCQ   := .T.
		SD7->(dbSetOrder(2))
		If SD7->(dbSeek(cSeekSD7, .F.))
			Do While !SD7->(Eof()) .And. ;
					cSeekSD7 == SD7->D7_FILIAL+SD7->D7_NUMERO+SD7->D7_PRODUTO
				If SD7->D7_TIPO > 0 .And. Empty(SD7->D7_ESTORNO)
					Help(' ',1,'A261MOVICQ')
					Return .T.
				EndIf
				SD7->(dbSkip())
			EndDo
		EndIf
	EndIf
EndIf
SB1->(dbSetOrder(1))
lEstQualy :=  lEstCQ .And. (SB1->(dbSeek(xFilial('SB1')+SD3->D3_COD, .F.)) .And. RetFldProd(SD3->D3_COD,"B1_TIPOCQ")=='Q')

If lEstCQ
			dbSelectArea('SD7')
			dbSetorder(1)
			If dbSeek(cSeekSD7 := cFilSD7 + cNumCQ + SD3->D3_COD, .F.)
				//Ŀ
				// Estorna Movimentaes no CQ Quality                   
				//
				If lEstQualy

					//Ŀ
					// Excluso do CQ no SigaQIE                                    
					//
					//Ŀ
					//Posiciona o registro no SD5 para que o LOTECTL+NUMLOTE seja   
					//enviado para qAtuMatQie()									 
					//
					cLotCtlQie := ''
					cNumLotQie := ''
					If Rastro(SD3->D3_COD,"L") .Or. Rastro(SD3->D3_COD,"S")
						aAreaSD5 := SD5->(GetArea())
						SD5->(dbSetOrder(3))
						If SD5->(dbSeek(xFilial('SD5')+SD7->D7_NUMSEQ+SD7->D7_PRODUTO+SD7->D7_LOCAL+SD7->D7_LOTECTL, .F.))
							cLotCtlQie := SD5->D5_LOTECTL
							cNumLotQie := SD5->D5_NUMLOTE
						EndIf
						SD5->(dbSetOrder(aAreaSD5[2]))
						SD5->(dbGoto(aAreaSD5[3]))
					EndIf

					aEnvCele := {SD7->D7_DOC			,; //Numero da Nota Fiscal
						SD7->D7_SERIE					,; //Serie da Nota Fiscal
						"N"								,; //Tipo da Nota Fiscal
						SD7->D7_DATA					,; //Data de Emissao da Nota Fiscal
						SD7->D7_DATA					,; //Data de Entrada da Nota Fiscal
						"NF"							,; //Tipo de Documento
						Space(TamSX3("D1_ITEM")[1])		,; //Item da Nota Fiscal
						Space(TamSX3("D1_REMITO")[1])	,; //Numero do Remito (Localizacoes)
						Space(TamSX3("D1_PEDIDO")[1])	,; //Numero do Pedido de Compra
						Space(TamSX3("D1_ITEMPC")[1])	,; //Item do Pedido de Compra
						SD7->D7_FORNECE					,; //Codigo Fornecedor/Cliente
						SD7->D7_LOJA					,; //Loja Fornecedor/Cliente
						SD7->D7_LOTECTL					,; //Numero do Lote do Fornecedor
						Space(TamSX3("QEK_SOLIC")[1])	,; //Codigo do Solicitante
						SD7->D7_PRODUTO					,; //Codigo do Produto
						SD7->D7_LOCAL					,; //Local Origem
						cLotCtlQie						,; //Numero do Lote
						cNumLotQie						,; //Sequencia do Sub-Lote
						SD7->D7_NUMSEQ					,; //Numero Sequencial
						SD7->D7_NUMERO					,; //Numero do CQ
						SD7->D7_SALDO					,; //Quantidade
						0								,; //Preco
						0								,; //Dias de atraso
						" "								,; //TES
						AllTrim(FunName())				,; //Origem
						" "								,; //Origem TXT
						0}								   //Quantidade do Lote Original

					//Ŀ
					// Realiza a exclusao do material enviado para Inspecao	     
					//
					aRecCele := qAtuMatQie(aEnvCele,2)

				EndIf

				dbSelectArea('SD7')
				dbSeek(cSeekSD7 := cFilSD7 + cNumCQ + SD3->D3_COD, .F.)
				Do While !Eof() .And. cSeekSD7 == D7_FILIAL + D7_NUMERO + D7_PRODUTO
					RecLock('SD7', .F.)
					dbDelete()
					MsUnlock()
					dbSkip()
				EndDo
			EndIf
		EndIf

Return lRetorno

/*


Ŀ
Funo LoteDest    Autor Ana Paula dos Santos      Data  03/02/21 
Ĵ
Descrio  Preenche o lote destino                                    
ٱ


*/
Function LoteDest()

Local lRet:=.T.
Local lRetPE:=.F.
LOCAL lLtPrd:=GetNewPar("MV_LTPRD",.T.)
Local cLoteCtl := ' '

Default nPosLtDest:=Ascan(aHeader,{|x| Trim(x[2])=="BC_LOTDEST"})
Default nPosVlDest:=Ascan(aHeader,{|x| Trim(x[2])=="BC_DTVLDES"})

//Se existir o PE a funcionalidade padro no ser executada para sugerir os dados em tela
//Neste caso a regra ser aplicada somente no SIGACUSA - funo CargaLtD
IF ExistBlock("MT685LTD")
	lRetPE := ExecBlock("MT685LTD",.F.,.F.)
	If lRetPE == .T.
		Return lRetPE
	EndIf
Endif

//Se o campo 'BC_LOTDEST' no existir - retorna
If !(SBC->(FieldPos('BC_LOTDEST')) > 0)
   Return lRet
EndIf

//Se o item destino no controla lote no carrega nada
If !Rastro(aCols[n,nPosProDes])
	Return lRet
EndIf

//Se parametro MV_LTPRD = T carrega lote destino igual lote origem; 
//seno ir gerar lote automtico
If lLtPrd 
	M->BC_LOTDEST:=M->BC_LOTECTL
Else
	cLoteCtl := If(Empty(cLoteCtl),NextLote(aCols[n,nPosProDes],"L"),cLoteCtl)
	cLoteCtl := If(Empty(cLoteCtl),"AUTO"+cLoteCtl,cLoteCtl)
	M->BC_LOTDEST:=cLoteCtl
EndIF
aCols[n,nPosLtDest]:=M->BC_LOTDEST

//A data de validade destino ser sempre carregada conforme a data de validade origem
If SBC->(FieldPos('BC_DTVLDES')) > 0
	M->BC_DTVLDES:=aCols[n,nPosDValid]
	aCols[n,nPosVlDest]:=M->BC_DTVLDES
EndIf

Return lRet
