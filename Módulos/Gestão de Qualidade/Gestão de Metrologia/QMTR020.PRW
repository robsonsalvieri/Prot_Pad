#INCLUDE "QMTR020.CH"
#INCLUDE "PROTHEUS.CH"


#DEFINE STRCOLUNA_1 "|             |                                       "
#DEFINE STRCOLUNA_2 "|             |            |                      "
#DEFINE STRCOLUNA_4 "|        |         |        |         |           "
#DEFINE STRCOLUNA_5 "|             |                                  |"
/*/


Ŀ
Funo	  QMTR020	 Autor  Alessandro B. Freire   Data  30.03.98 
Ĵ
Descrio  Ficha de Calibrao										  
Ĵ
Sintaxe	  QMTR020(void)											  
Ĵ
 Uso		  Generico 												  
Ĵ
			ATUALIZACOES SOFRIDAS DESDE A CONSTRUAO INICIAL.			  
Ĵ
Programador  Data	 BOPS   Motivo da Alteracao 					  
Ĵ
Antonio     19/07/9922057  Parametro de, ate para Status.           
Antonio     30/01/00       Rodap de data/hora por instrumento.     
Antonio     02/02/00       Ajuste de lRodaImp e incluso de cChvQMK. 
Denis M.    13/12/00       Inclusao do MV_PAR21 na pergunta QMR020. 
                           Esse parametro permiti ao usuario impri-  
                           mir Fichas de Calibracao com status Atua-
                           liza "NAO".                              
Denis M.    05/04/02014517 Impressao do Nome/Numero Procedimento ca-
                           dastrado na familia do instrumento qdo o  
                           mesmo nao estiver informado no cadastro  
                           de procedimentos de calibracao(QA5).     
ٱ


/*/
Function QMTR020()
//Ŀ
// Define Variaveis 														  
//
Local cDesc1		:=OemToAnsi( STR0001 ) 	// "Este programa ir emitir a relao de"
Local cDesc2		:=OemToAnsi( STR0002 ) 	// "Fichas de Calibrao de acordo com os"
Local cDesc3		:=OemToAnsi( STR0003 ) 	// "Parmetros selecionados."
Local cString		:="QM2"
Local wnrel

Private cTitulo   := OemToAnsi(STR0004) 	// "FICHA DE CALIBRACAO"
Private Cabec1    := ""
Private Cabec2    := ""
Private aReturn   := { OemToAnsi(STR0005), 1,OemToAnsi(STR0006), 1, 2, 1, "",1 } // "Zebrado"#"Administrao"
Private cNomeProg :="QMTR020"
Private nLastKey  := 0
Private cPerg	   :="QMR020"
Private cTamanho  := "M"
Private cImpCbInst := ""
Private cOldInst   := ""

//Ŀ
// Verifica as perguntas selecionadas 							 
//
pergunte("QMR020",.F.)
//Ŀ
// Variaveis utilizadas para parametros									
// mv_par01				// Instrumento Inicial							 
// mv_par02				// Instrumento Final 							
// mv_par03				// Periodo Inicial								
// mv_par04				// Periodo Final								
// mv_par05				// Departamento Inicial 						
// mv_par06				// Departamento Final							
// mv_par07				// Orgao Calibrador Todos/Interno/Externo       
// mv_par08				// Org.Calib.Intr.Inicial  					  	
// mv_par09				// Org.Calib.Intr.Final    					    
// mv_par10				// Org.Calib.Extr.Inicial  					    
// mv_par11				// Org.Calib.Extr.Final    					    
// mv_par12				// Familia Inicial                          	
// mv_par13				// Familia Final 								
// mv_par14				// Fabricante Inicial							
// mv_par15				// Fabricante Final								
// mv_par16				// Status de  		                       		
// mv_par17                // Status ate                               	
// mv_par18				// Usurio Inicial 								
// mv_par19				// Usurio Final 								
// mv_par20				// Quebra p/ Instrumento Sim/Nao				
// mv_par21				// Imprime desabilitado  Sim/Nao 			  	                                            
// mv_par22				// Dados do Usuario/Responsavel ? 			  	 			  	
// mv_par23				// Considera Venc. da Calibracao ?			  	 			  	
//

//Ŀ
// Envia controle para a funcao SETPRINT 						 
//
wnrel := "QMTR020"            //Nome Default do relatorio em Disco
wnrel := SetPrint(cString,wnrel,cPerg,@cTitulo,cDesc1,cDesc2,cDesc3,.F.,"",,cTamanho)

If nLastKey = 27
	Return
Endif

SetDefault(aReturn,cString)

If nLastKey = 27
	Return
Endif

RptStatus({|lEnd| r020Imp(@lEnd,wnRel,cString)},cTitulo)

Return

/*/


Ŀ
Funo	  r020Imp   Autor  Alessandro B. Freire   Data  30.03.98 
Ĵ
Descrio  Ficha de Calibrao										  
Ĵ
Sintaxe	  QMTR020(void)											  
Ĵ
 Uso		  Generico 												  
Ĵ
			ATUALIZACOES SOFRIDAS DESDE A CONSTRUAO INICIAL.			  
Ĵ
Programador  Data	 BOPS   Motivo da Alteracao 					  
Ĵ
Iuri Seto   25/07/00       Inclusao do Tipo de Calibracao Relogio.  
ٱ


/*/
Function r020Imp( lEnd, wnRel, cString )

Local nNumMed := 0
Local nEspec  := 0
Local nToler  := 0
Local lImprime:= .F.
Local cbCont  := 0
Local cbTxt   := ""
Local lRodaImp:= .F.
Local cRevEsc := ""
Local cChvQMK := ""
Local cChvQMG := ""
Local cEscala := ""
Local cInstrCab := ""
Local cFaixa  := "",cStatus := ""
Local cRevQMA := "00"
Local cTipTol := ""
Local cKey		
Local cQuery := ""
Local cFiltroUser := aReturn[7]
Local cCampo1 := ""
Local cPict1 := ""

Private TRB_FILIAL
Private TRB_INSTR
Private	TRB_REVINS
Private	TRB_REVINV
Private	TRB_VALDAF
Private	TRB_FREQAF
Private	TRB_TIPO
Private	TRB_RESP
Private	TRB_DEPTO	
Private	TRB_FABR	
Private	TRB_STATUS	
Private	TRB_LOCAL	
Private	TRB_LAUDO	
Private	TRB_NSEFAB	
Private	TRB_FILRES	
Private	TRB_DESQM1

Private cCabec1 := ""
Private cCabec2 := ""
Private cCabec3 := ""
Private cCabec4 := ""
Private cCabec5 := ""
Private cCabec6 := ""
Private lFirst  := .F.
Private cIndex  := ""	
Private nLimite := 132
Private cUniMed := ""
m_pag := 1
li 	:= 80

QM3->(dbSetOrder(1))

dbSelectArea("QM2")
dbSetOrder(01)
cQuery := "SELECT QM2_FILIAL,QM2_INSTR,QM2_REVINS,QM2_REVINV,QM2_VALDAF,QM2_FREQAF,QM2_NSEFAB,"
cQuery += "QM2_DEPTO,QM2_RESP,QM2_TIPO,QM2_FABR,QM2_STATUS,QM2_LAUDO,QM2_LOCAL,QM2_FLAG,QM2_FILRES,"
cQuery += "QM1_FILIAL,QM1_TIPO,QM1_DESCR "
cQuery += "FROM "+RetSqlName("QM2")+" QM2, "					
cQuery += RetSqlName("QM1")+" QM1 "
cQuery += "WHERE "
cQuery += "QM2.QM2_FILIAL = '"			+xFilial("QM2")+	"' AND "
cQuery += "QM2.QM2_INSTR  BetWeen '"	+ mv_par01 +		"' AND '" + mv_par02 +			"' AND " 
cQuery += "QM2.QM2_DEPTO BetWeen '"		+ mv_par05 +		"' AND '" + mv_par06 + 			"' AND " 
cQuery += "QM2.QM2_TIPO BetWeen '"		+ mv_par12 +		"' AND '" + mv_par13 + 			"' AND " 
cQuery += "QM2.QM2_FABR BetWeen '"		+ mv_par14 +		"' AND '" + mv_par15 + 			"' AND " 
cQuery += "QM2.QM2_STATUS BetWeen '"	+ mv_par16 +		"' AND '" + mv_par17 + 			"' AND " 
cQuery += "QM2.QM2_RESP BetWeen '"		+ mv_par18 +		"' AND '" + mv_par19 + 			"' AND "  
cQuery += "QM2.QM2_FLAG = '1' AND QM1.QM1_FILIAL = QM2.QM2_FILIAL AND " 		
cQuery += "QM1.QM1_TIPO =  QM2.QM2_TIPO  AND " 
cQuery += "QM2.D_E_L_E_T_= ' ' "+ " AND " +"QM1.D_E_L_E_T_= ' ' "

If aReturn[8] == 1 
	cKey	:= "QM2_FILIAL+QM2_INSTR+QM2_REVINV"
    //cQuery  += "ORDER BY " + SqlOrder(cKey)
Endif	

cQuery := ChangeQuery(cQuery)
dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),"TRB",.T.,.T.)
TcSetField("TRB","QM2_VALDAF","D",8,0)
dbSelectArea( "TRB" )

//Ŀ
// Loop at o ltimo instrumento selecionado.					    
// Loop do instrumento.											
//
SetRegua(RecCount())
lAbortPrint := .F.
While !Eof()

	TRB_FILIAL	:= TRB->QM2_FILIAL
	TRB_INSTR	:= TRB->QM2_INSTR
	TRB_REVINS	:= TRB->QM2_REVINS
	TRB_REVINV	:= TRB->QM2_REVINV
	TRB_VALDAF	:= TRB->QM2_VALDAF
	TRB_FREQAF	:= TRB->QM2_FREQAF						
	TRB_TIPO	:= TRB->QM2_TIPO
	TRB_RESP	:= TRB->QM2_RESP	
	TRB_DEPTO	:= TRB->QM2_DEPTO
	TRB_FABR	:= TRB->QM2_FABR	
	TRB_STATUS	:= TRB->QM2_STATUS
	TRB_LOCAL	:= TRB->QM2_LOCAL
	TRB_LAUDO	:= TRB->QM2_LAUDO		
	TRB_NSEFAB	:= TRB->QM2_NSEFAB	 
	TRB_FILRES	:= TRB->QM2_FILRES
	TRB_DESQM1	:= TRB->QM1_DESCR			
	
	IncRegua()
	If lAbortPrint
		Exit
	EndIf
	
	//Ŀ
	// Se no est entre as validades informadas no imprime.		    
	//
	If (( TRB_VALDAF < mv_par03 ) .Or. ;
		( TRB_VALDAF > mv_par04 )) .And.;
		mv_par23 == 1 // Considera vencimento da calibrao Sim / Nao
		dbSelectArea("TRB")
		dbSkip()
		Loop
	EndIf
	
	//Ŀ
	// Verifico O.C. interno e externo                                 
	//
	If mv_par07 == 1
		If ! Calibrador(0,mv_par08,mv_par09,mv_par10,mv_par11,TRB_INSTR,TRB_REVINS)
			dbSelectArea("TRB")
			dbSkip()
			Loop
		EndIf
	EndIf
	
	//Ŀ
	// Verifico O.C. interno                                           
	//
	If mv_par07 == 2
		If ! Calibrador(1,mv_par08,mv_par09,,,TRB_INSTR,TRB_REVINS)
			dbSelectArea("TRB")
			dbSkip()
			Loop
		EndIf
	EndIf
	
	//Ŀ
	// Verifico O.C. externo                                           
	//
	If mv_par07 == 3
		If ! Calibrador(2,,,mv_par10,mv_par11,TRB_INSTR,TRB_REVINS)
			dbSelectArea("TRB")
			dbSkip()
			Loop
		EndIf
	EndIf
	
	//Ŀ
	// Verifica se status do instrumento esta com atualiza ativo,dependendo do parametro MV_PAR21.
	//
    If mv_par21 == 2
	   If !QMTXSTAT(TRB_STATUS)
			dbSelectArea("TRB")
		  dbskip()
		  loop
	   EndIf
	Endif   

	If !Empty(cFiltroUser) .and. !TRB->(&cFiltroUser)
		dbskip()
		Loop		      
    Endif

	QAA->(dbSetOrder(1))
	QAA->(dbSeek(TRB_FILRES+TRB_RESP))
	cInstrCab := ""

    QMP->(dbSetOrder(1))
    QMP->(dbSeek(xFilial("QMP")+TRB_STATUS))
    cStatus := QMP->QMP_DESCR
	
	//Ŀ
	// Define o cabealho do instrumento.       						
	//
	Cabec1 := ""
	Cabec2 := ""
	
	cCabec1 :=  STR0007 + TRB_INSTR			+ " " 					+ ;		// "INSTRUMENTO..: "
				STR0045 + TRB_REVINS		+ " " 					+ ;		// "REV.: "
				STR0008 + Alltrim(TRB_DEPTO)         + " " 			+ ;	 	// "DEPARTAMENTO.: "
				STR0009 + Str(TRB_FREQAF,4) + OemToAnsi(STR0037) 	+ ;		// "FREQ.AFERICAO: "
				STR0010 + DtoC(TRB_VALDAF)                     	  	 		// "VALIDADE: "
	
	cCabec2 := STR0011 + Mtr020Proc(TRB_TIPO)                  // "PROCEDIMENTO.: "
	
	If MV_PAR22 == 1 //Apelido
		cCabec3 := STR0012 + TRB_LOCAL + "          " + ;		// "LOCALIZACAO"
		STR0013 + TRB_NSEFAB+ "    " + ;						// "No. DE SERIE"
		Upper(TitSx3("QM2_RESP")[1])+" : " + QAA->QAA_APELID	// APELIDO
	ElseIf MV_PAR22 == 2 //Codigo
		cCabec3 := STR0012 + TRB_LOCAL + "          " + ;		// "LOCALIZACAO"
		STR0013 + TRB_NSEFAB+ "    " + ;						// "No. DE SERIE"
		Upper(TitSx3("QM2_RESP")[1])+" : " + QAA->QAA_MAT		// MATRICULA
	Else  //Nome Completo
		cCabec3 := STR0012 + TRB_LOCAL + "          " + ;		// "LOCALIZACAO"
		STR0013 + TRB_NSEFAB+ "    " + ;						// "No. DE SERIE"
		Upper(TitSx3("QM2_RESP")[1])+" : " + QAA->QAA_NOME		// NOME DO RESPONSAVEL
	Endif	
	cCabec4 := OemToAnsi(STR0036) + TRIM(UPPER(cUserName)) + "             " +;      // ""EMISSOR......: "
 	           Trim(Upper(TitSx3("QM2_STATUS")[1]))  + ".......: " +;
	           Trim(Upper(cStatus)) + "              "+;
	           Alltrim(Upper(QaTit("QM2_TIPO",7)))+"......: "+TRB_TIPO

	cCabec5 := OemToAnsi(STR0043)+TRB_DESQM1   //Desc. Familia	
	                     
	cCabec6 := STR0044
	//Ŀ
	// Procura as escalas amarradas a Familia							
	//
	dbSelectArea("QMK")
	dbSetOrder(1)
	If dbSeek( xFilial("QMK") + TRB_TIPO )
		cChvQMK := QMK->QMK_TIPO+QMK->QMK_REVTIP
	Else
		dbSelectArea("TRB")
		dbSkip()
		Loop
	EndIf
	
	//Ŀ
	// Quebra por instrumento.                                         
	//
	cImpCbInst := TRB_INSTR + TRB_REVINS
	
	//Ŀ
	// Loop das escalas.											    
	//
	While QMK->(!Eof()) .And. xFilial("QMK") == QMK->QMK_FILIAL ;
		.And. QMK->QMK_TIPO+QMK->QMK_REVTIP == cChvQMK
		
		lImprime := IIF( mv_par20 == 2, .T., .F. )
		//Ŀ
		// Pega o numero de medicoes no cadastro de escalas. 			    
		//
		QM9->(dbSetOrder(1))
		QM9->(dbSeek(xFilial("QM9")+QMK->QMK_ESCALA))
		nNumMed := QM9->QM9_NROMED
		
		//Ŀ
		// Verifica quais escalas devem ser impressas					    
		//
		QMR->(dbSetOrder(1))
		QMR->(dbSeek(xFilial("QMR")+TRB_INSTR+TRB_REVINS+QMK->QMK_ESCALA))
		
		cEscala := ""
		
		If QMR->QMR_CAOBRI == "S"
			
			//Ŀ
			// INSTRUMENTOS COM TIPO DE AFERICAO 1,2,3 		   
			//
			If QM9->QM9_TIPAFE $ "1|2|3|9"
				
				//Ŀ
				// Procura os pontos amarrados as escalas.					     
				//
				dbSelectArea("QMC")  // Padro / Escalas
				dbSetOrder(1)
				QMC->(dbSeek(xFilial("QMC")+QMK->QMK_ESCALA+;
				inverte(QM9->QM9_REVESC)) )
				
				cRevEsc := QMC->QMC_REVESC
				
				While QMC->(!Eof()) .And. xFilial("QMC") == QMC->QMC_FILIAL ;
					.And. ( QMC->QMC_REVESC == cRevEsc ) ;
					.And. ( QMC->QMC_ESCALA == QMK->QMK_ESCALA )
					
					//Ŀ
					// Posiciona no QM3: Pontos.               	       	   
					//
					dbSelectArea("QM3") // Padrao / Calibracao
					dbSetOrder(1)
					QM3->(dbSeek( xFilial("QM3") + QMC->QMC_PADRAO ))
					SAH->(dbSetOrder(1))
					SAH->(dbSeek(xFilial("SAH")+QM3->QM3_UNIMED))
					
					lRodaImp := .T.
					
					If cInstrCab <> TRB_INSTR + TRB_REVINS
						r020Inst()
						cInstrCab := TRB_INSTR + TRB_REVINS
					EndIf
					
					If !(QMK->QMK_FILIAL+QMK->QMK_ESCALA == cEscala)
						
						//Ŀ
						// Cabealho das escalas.	         			           
						//
						If QM9->QM9_TIPAFE$"1"
							r020Escala(1)  // com uma coluna.
						ElseIf QM9->QM9_TIPAFE$"2"
							r020Escala(2)  // com duas colunas.
						ElseIf QM9->QM9_TIPAFE$"3|9"
							r020Escala(4)
						EndIf
						
						cEscala := QMK->QMK_FILIAL+QMK->QMK_ESCALA
					EndIf
					
					If QM3->QM3_TIPPAD != "A" .And. QM9->QM9_NROMED > 0
						
						//Ŀ
						// 1 Linha de impresso para padro com  medies         
						// com valores.                                            
						//
						li++
						//Ŀ
						// Faz a troca de pg. se necessrio.        
						//
					    r020Cab(.T.) // Imprime linha na prx. pg.
						
//             10       20         30        40        50        60        70        80        90        100       110       120
//   01234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567
//	"|Padrao          | Rev | Especificado | Tol.Minima | Tol.Maxima |Tp.Calc.Tol| Valor       | Obs.                               |"
//	"|Padrao          | Rev | Especificado | Tol.Minima | Tol.Maxima |Tp.Calc.Tol| Vlr Inicial | Vlr Final  | Obs.                  |"												
//  "|                |     |              |            |            |           |  Valor Inicial   |   Valor Final    |              |"
//  "|Padrao          | Rev | Especificado | Tol.Minima | Tol.Maxima |Tp.Calc.Tol| Subida | Descida | Subida | Descida |Obs.          |"
																																								
						@li, 00 PSAY "|"
						@li, 01 PSAY QM3->QM3_PADRAO
						@li, 17 PSAY "|"
						@li, 19 PSAY QM3->QM3_REVPAD
						@li, 23 PSAY "|"
						@li, 24 PSAY PadR(AllTrim(QM3->QM3_ESPEC),10) 						// "Especificado: "
						@li, 38 PSAY "|"
						@li, 39 PSAY PadR(AllTrim(QMC->QMC_TOLMIN),10) 					// "Toler.Minima: "                     
						@li, 51 PSAY "|"						
						@li, 52 PSAY PadR(AllTrim(QMC->QMC_TOLER),10) 						// "Toler.Maxima: "						
						@li, 64 PSAY "|"												
						@li, 65 PSAY SubStr(QMTCBox("QMC_TIPTOL",QMC->QMC_TIPTOL),5,10) 	// "Tip.Calc.Tolerancia
//			10		  20        30        40        50        60        70		  80        90        100       110       120								
//0123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012
//|                |     |              |            |            |           |             |                                       "						
						If QM9->QM9_TIPAFE$"1"
							@li, 76 PSAY STRCOLUNA_1  // "|                                    |"
						ElseIf QM9->QM9_TIPAFE$"2"
							@li, 76 PSAY STRCOLUNA_2 // "|             |            |                      "
						ElseIf QM9 ->QM9_TIPAFE$"3|9"
							@li, 76 PSAY STRCOLUNA_4 // "|                     |                     |" 
						EndIf
						@li, 131 PSAY "|"
						
						li++
						If li > 55
							@ li,00  PSAY __PrtThinLine()
							li := 66 // Fora a quebra de pg.
						EndIf
						//Ŀ
						// Faz a troca de pg. se necessrio.        
						//
						r020Cab(.F.) // No imprime linha na prx. pg.
						@ li,00 PSAY __PrtThinLine()
						//Ŀ
						// A funo r020Medic  monta as linhas com as colunas 
						//  em branco para preenchimento pelo usurio.        
						//
						If QM9->QM9_TIPAFE$"1"
							r020Medic( nNumMed -1, 76 , STRCOLUNA_1)
						ElseIf QM9->QM9_TIPAFE$"2"
							r020Medic( nNumMed -1, 76 , STRCOLUNA_2)
						ElseIf QM9->QM9_TIPAFE$"3|9"
							r020Medic( nNumMed -1, 76, STRCOLUNA_4)
						EndIf
						
					ElseIf QM9->QM9_NROMED == 0   //COLETA == "N"
						
						//Ŀ
						// Trata laboratrios externos.                       
						//
						r020MedExt()
						
					Else
						
						//Ŀ
						// Imprime a linha para atributos.                       
						//
						If QM9->QM9_TIPAFE$"1" // 1 Coluna
							r020Atrib( 1 ) // "|               |              | [  ] APROVADO                       "
						ElseIf QM9->QM9_TIPAFE$"2"  // 2 Colunas
							r020Atrib(2 ) //	"|               |              | [  ] APROVADO       | [  ] REPROVADO"
						ElseIf QM9->QM9_TIPAFE$"3|9" // 4 Colunas
							r020Atrib(4 ) //	"|               |              | [  ] APROVADO       | [  ] REPROVADO"
						EndIf
						
					EndIf
					
					dbSelectArea( "QMC" )
					
					QMC->(dbSkip())
					
				EndDo
				
			ElseIf QM9->QM9_TIPAFE $ "5"
				dbSelectArea("QM9")				
				If xFilial("QM9")+QM9->QM9_ESCALA == QM9->QM9_FILIAL+QMK->QMK_ESCALA 
					//Pega sempre a ultima revisao da escala
					cRevQMA := QM9->QM9_REVESC	                      
				Endif		
				//Ŀ
				// INSTRUMENTOS COM TIPO DE AFERICAO 5 - SOMA.          
				//
				dbSelectArea( "QMA" )
				dbSetOrder(1)
				dbSeek( xFilial("QMA") + QMK->QMK_ESCALA + cRevQMA )
				cChvQMA := QMA->QMA_ESCALA+QMA->QMA_REVESC
				
				//Ŀ
				// Posiciona no QM3: Pontos.               	         	  
				//
				QM3->(dbSeek( xFilial("QM3") + QMA->QMA_PADRAO ))
				SAH->(dbSetOrder(1))
				SAH->(dbSeek(xFilial("SAH")+QM3->QM3_UNIMED))
				
				lRodaImp := .T.
				
				If cInstrCab <> TRB_INSTR + TRB_REVINS
					r020Inst()
					cInstrCab := TRB_INSTR + TRB_REVINS
				EndIf
				
				//Ŀ
				// Cabealho das escalas.                                  
				//
				r020Escala(2) // 2 Colunas.
				
				While QMA->(!Eof()) ;
					.And.  QMA->QMA_ESCALA+QMA->QMA_REVESC == cChvQMA ;
					.And. QMA->QMA_FILIAL == xFilial("QMA")
					
					//Ŀ
					// Faz a troca de pg. se necessrio.        
					//
					r020Cab(.F.) // No imprime linha na prx. pg.
					
					cChvFaixa := QMA->QMA_ESCALA +QMA->QMA_REVESC + QMA->QMA_FAIXA
					nToler    := 0
					nEspec    := 0
					nTolMin	  := 0	
					
					While QMA->QMA_ESCALA+QMA->QMA_REVESC+QMA->QMA_FAIXA == cChvFaixa ;
						.And.	QMA->QMA_FILIAL == xFilial("QMA") ;
						.And. !QMA->(EOF())
						
						//Ŀ
						// Reposiciona o QM3 para cada reg em QMA. O 1  desnec...
						//
						QM3->(dbSeek( xFilial("QM3") + QMA->QMA_PADRAO ))
						
						If !QM3->(Found())  // s pra garantir...
							QMA->(dbSkip())
							Loop
						EndIf
						
						If QM3->QM3_TIPPAD == "A"
							Exit
						Else
							li++
							//Ŀ
							// Faz a troca de pg. se necessrio.        
							//
						    r020Cab(.T.) // Imprime linha na prx. pg.
							
							@li, 00 PSAY "|"
							@li, 01 PSAY QM3->QM3_PADRAO
							@li, 17 PSAY "|"
							@li, 19 PSAY QM3->QM3_REVPAD
							@li, 23 PSAY "|"
							@li, 24 PSAY PadL(AllTrim(QM3->QM3_ESPEC),10)	// "Especificado: "
							@li, 38 PSAY "|"
							@li, 39 PSAY PadL(AllTrim(QMA->QMA_TOLMIN),10)	// "Tol.Minima "
							@li, 51 PSAY "|"
							@li, 52 PSAY PadL(AllTrim(QMA->QMA_TOLER),10)	// "Tol.Maxima "
							@li, 64 PSAY "|"
							@li, 65 PSAY SubStr(QMTCBox("QMA_TIPTOL",QMA->QMA_TIPTOL),5,10)
							@li, 76 PSAY "|XXXXXXXXXXXXX|XXXXXXXXXXXX|"
							@li,131 PSAY "|"
							li++
							If li > 55
								@ li,00  PSAY __PrtThinLine()
								li := 66 // Fora a quebra de pg.
							EndIf
							//Ŀ
							// Faz a troca de pg. se necessrio.        
							//
							r020Cab(.F.) // No imprime linha na prx. pg.
							@ li,00  PSAY __PrtThinLine()
							
							cFaixa := QMA->QMA_FAIXA
							nEspec += SuperVal( QM3->QM3_ESPEC )
							nToler := IIF( nToler > SuperVal(QMA->QMA_TOLER)	,;
							nToler					,;
							SuperVal(QMA->QMA_TOLER) )
						
							nTolMin := IIF( nTolMin > SuperVal(QMA->QMA_TOLMIN)	,;
							nTolMin					,;
							SuperVal(QMA->QMA_TOLMIN) )
							cTipTol := QMA->QMA_TIPTOL
						EndIf
						
						
						QMA->(dbSkip())
					EndDo
					
					cCampo1 := "QM3_ESPEC"
					cPict1 := QA_PICT(cCampo1,QM3->&(cCampo1))
					//Ŀ
					// Para QM3_TIPPAD == "A" o looping anterior ter que      
					// acontecer necessariamente apenas 1 vez, sendo vlido    
					// testar o atributo pelo QM3.                             
					//
					If QM9->QM9_NROMED > 0  ;
						.And.  QM3->QM3_TIPPAD != "A"   //COLETA != "N"
						
						//Ŀ
						// 1 Linha de impresso para padro com  medies         
						// com valores.                                            
						//
						li++
						//Ŀ
						// Faz a troca de pg. se necessrio.        
						//
					    r020Cab(.T.) // Imprime linha na prx. pg.
						@li, 00 PSAY "|"
						@li, 01 PSAY Alltrim(cFaixa)
						@li, 17 PSAY "|"
						@li, 23 PSAY "|"
						@li, 24 PSAY  PadL(AllTrim(Transform(nEspec, cPict1)),10)
						@li, 38 PSAY "|"
						@li, 39 PSAY  PadL(AllTrim(Transform(nTolMin, cPict1)),10)
						@li, 51 PSAY "|"
						@li, 52 PSAY  PadL(AllTrim(Transform(nToler, cPict1)),10)	
						@li, 64 PSAY "|"											
						@li, 65 PSAY SubStr(QMTCBox("QMA_TIPTOL",cTipTol),5,10) 
						@li, 76 PSAY STRCOLUNA_2 // "|                     |                     |"
						@li,131 PSAY "|"
						li++
						If li > 55
							@ li,00  PSAY __PrtThinLine()
							li := 66 // Fora a quebra de pg.
						EndIf
						//Ŀ
						// Faz a troca de pg. se necessrio.        
						//
						r020Cab(.F.) // No imprime linha na prx. pg.
						@ li,00  PSAY __PrtThinLine()
						//Ŀ
						// A funo r020Medic monta as linhas com as colunas 
						//  em branco para preenchimento pelo usurio.       
						//
						r020Medic( nNumMed - 1, 76, STRCOLUNA_2)
						
					ElseIf QM9->QM9_NROMED == 0    //COLETA == "N"
						
						//Ŀ
						// Trata laboratrios externos.                       
						//
						r020MedExt()
						
					ElseIf QM3->QM3_TIPPAD = "A"
						//Ŀ
						// Imprime a linha para atributos.                    
						//
						r020Atrib(2 ) //	"|               |              | [  ] APROVADO       | [  ] REPROVADO"
						QMA->(dbSkip())
					EndIf
					
				EndDo
				
				
			ElseIf  QM9->QM9_TIPAFE$"4|8"
				
				//Ŀ
				// INSTRUMENTOS COM TIPO DE AFERICAO - 3                      
				//
				dbSelectArea( "QMG" )
				dbSetOrder(1)
				dbSeek( xFilial("QMG") + TRB_INSTR + TRB_REVINS )
				cChvQMG := QMG->QMG_INSTR + QMG->QMG_REVINS
				cEscala := ""
				
				While QMG->(!Eof()) .And. QMG->QMG_INSTR + QMG->QMG_REVINS == cChvQMG ;
					.And.  xFilial("QMG") == QMG->QMG_FILIAL
					
					SAH->(dbSetOrder(1))
					SAH->(dbSeek(xFilial("SAH")+QMG->QMG_UNIMED))
					cUniMed := SAH->AH_UMRES 
					
					If lFirst
					   r020Cab(.T.)
					Endif   
  				    lFirst := .T.
					If cInstrCab <> TRB_INSTR + TRB_REVINS
						r020Inst()
						cInstrCab := TRB_INSTR + TRB_REVINS
					EndIf
					
					If !(QMK->QMK_ESCALA ==  cEscala)
						//Ŀ
						// Constri o cabealho dos padres.		       	       
						//
						r020EscQMG()
						cEscala := QMK->QMK_ESCALA
					EndIf
					
					lRodaImp := .T.
					
					If QMG->QMG_TIPCAL != "A" .And. QM9->QM9_NROMED > 0
						//Ŀ
						// 1 Linha de impresso para padro com  medies         
						// com valores.                                            
						//
						li++
						//Ŀ
						// Faz a troca de pg. se necessrio.        
						//
						//r020Cab(.T.) // Imprime linha na prx. pg.
						//           1         2         3         4         5         6         7         8         9         10        11
					    // 012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901
					    //"|Ponto           | Especificado | LIE        | LSE        |Tp.Calc.Tol| Unid.Med. | Valor       | Obs.:                            |"										
						
						@li, 00 PSAY "|"
						@li, 01 PSAY QMG->QMG_PONTO
						@li, 17 PSAY "|"
						@li, 18 PSAY Padr(AllTrim(QMG->QMG_NOMIN),10) // "Especificado: "
						@li, 32 PSAY "|"
						@li, 33 PSAY Padr(AllTrim(QMG->QMG_LIE),10)
						@li, 45 PSAY "|"
						@li, 46 PSAY Padr(AllTrim(QMG->QMG_LSE),10)
						@li, 58 PSAY "|"
						@li, 59 PSAY SubStr(QMTCBox("QMG_TIPTOL",QMG->QMG_TIPTOL),5,10)
					
						//             10       20         30        40        50        60        70        80        90        100       110       120       130
						//   0123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012
						//  "|Ponto           | Especificado | LIE        | LSE        |Tp.Calc.Tol| Vlr Final       | Vlr Final       | Obs.:                  |"								
						If QM9->QM9_TIPAFE$"4"
							@li, 70 PSAY "|"//STRCOLUNA_1 
							@li, 72 PSAY cUniMed
    						@li, 82 PSAY STRCOLUNA_5
						ElseIf QM9->QM9_TIPAFE$"8"
							@li, 70 PSAY STRCOLUNA_2 
						EndIf
						@li,131 PSAY "|"
						li++
						If li > 55
							@ li,00  PSAY __PrtThinLine()
							li := 66 // Fora a quebra de pg.
						EndIf
						//Ŀ
						// Faz a troca de pg. se necessrio.        
						//

					    r020Cab(.T.) // No imprime linha na prx. pg.
						
						@ li,00  PSAY __PrtThinLine()
						//Ŀ
						// A funo r020Medic monta as linhas com as colunas  
						//  em branco para preenchimento pelo usurio.        
						//
						If QM9->QM9_TIPAFE$"4"      
							r020Medic( nNumMed -1, 82, STRCOLUNA_5)							
						ElseIf QM9->QM9_TIPAFE$"8"
							r020Medic( nNumMed -1, 70, STRCOLUNA_2)
						EndIf
						
					ElseIf QM9->QM9_NROMED == 0 //COLETA == "N"
						
						//Ŀ
						// Trata laboratrios externos.                       
						//
						r020MedExt()
						
					ElseIf QMG->QMG_TIPCAL == "A"
						//Ŀ
						// Imprime a linha para atributos.                    
						//
						r020AtQMG()
					EndIf
					
					QMG->(dbSkip())
					
				EndDo
			ElseIf  Empty(QM9->QM9_TIPAFE) .or. Alltrim(QM9->QM9_TIPAFE)==""
				//Ŀ
				// Trata laboratrios externos.                       
				//
				r020MedExt()
			EndIf
		EndIf
		
		dbSelectArea( "QMK" )
		dbSetOrder(1)
		cPula := QMK->QMK_ESCALA + QMK->QMK_TIPO + QMK->QMK_REVTIP
		While QMK->(!Eof()) .and. QMK->QMK_ESCALA + QMK->QMK_TIPO+ QMK->QMK_REVTIP == cPula
			dbSkip()
		EndDo
	EndDo
	dbSelectArea("TRB")
	
	dbSkip()
	
	If lRodaImp
		
		nRodaLim := 56
		
		//           1         2         3         4         5         6         7         8         9        10        11        12        13
		//  0123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012
		// "| Data :    /    /      | Hora Inicial:      :        | Hora Final  :      :        | Metrologista :
		li++
		//Ŀ
		// Faz a troca de pg. se necessrio.        
		//
	    r020Cab(.T.,58) // Imprime linha na prx. pg.
		
		@ li,00  PSAY __PrtFatLine()
//		@ li,00  PSAY Repl( "=", nLimite )
		li++
		@ li,00  PSAY STR0032 // "| Data :    /    /"
		@ li,24  PSAY STR0033 // "| Hora Inicial:      :"
		@ li,54  PSAY STR0034 // "| Hora Final  :      :"
		@ li,84  PSAY STR0035 // "| Metrologista : "
		@ li,131 PSAY "|"
		li++
		@ li,00  PSAY __PrtFatLine()
		
		lRodaImp := .F.
	EndIf
	
EndDo

If li <> 80
	Roda( cbCont, cbTxt, cTamanho )
EndIf

Set Device To Screen

dbSelectArea("TRB")
dbCloseArea()

If aReturn[5] = 1
	Set Printer TO
	dbCommitall()
	ourspool(wnrel)
End

MS_FLUSH()

Return

/*/


Ŀ
Funao	 r020Medic  Autor  Antonio Aurelio        Data  20.03.00 
Ĵ
Descrio  Constroi os cabecalhos de medies						  
Ĵ
 Uso		  QMTR020													  
ٱ


/*/
Function r020Medic( nNumMed , nPos, cCol )
Local i		 := 1
Default nPos := 63
Default cCol := "|                     |                     |"

//Ŀ
// Constri o cabealho das medicoes.  						    
//

For i = 1 To nNumMed
	li++
	//Ŀ
	// Faz a troca de pg. se necessrio.        
	//
    r020Cab(.T.) // Imprime linha na prx. pg.
	@li,00   PSAY "|"
	@li,nPos PSAY cCol
	@li,131  PSAY "|"
	If i < nNumMed
		li++
		//Ŀ
		// Verifico se esta no final da pg.         
		// e foro o fechamento da caixa.            
		//
		If li > 55
			@ li,00  PSAY __PrtThinLine()
			li := 66 // Fora a quebra de pg.
		EndIf
		//Ŀ
		// Faz a troca de pg. se necessrio.        
		//
		If !r020Cab(.T.) // Imprime linha na prx. pg.
			@li,00 PSAY "|"
			@ li,00  PSAY __PrtThinLine()
		Else
			li-- // Ajuste aqui
		EndIf
	EndIf
Next

If nNumMed > 0
	li++
	//Ŀ
	// Faz a troca de pg. se necessrio.        
	//
	r020Cab(.F.) // Imprime linha na prx. pg.
	@ li,00  PSAY __PrtThinLine()
EndIf

Return( NIL )

/*/


Ŀ
Funo	 Mtr020Sec  Autor  Alessandro B. Freire   Data  24.04.98 
Ĵ
Descrio  Retorna os padroes secundarios utilizados na escala        
Ĵ
Sintaxe	  MTR020Sec( )                     						  
Ĵ
 Uso		  QMTR020													  
ٱ


/*/
Function Mtr020Sec()

Local cOldAlias	:= Alias()
Local aArrayQMH := {}
Local aArrayRet := {}
Local nPos      := 0
Local nx		:= 1
Local cChave    := ""
Local cQuery	:= ""	

//Ŀ
// Imprime os padroes secundarios.     				   
//
dbSelectArea( "QMH" )
dbSetOrder(1)
dbSeek( xFilial("QMH") + QMK->QMK_ESCALA )
If Found()
	cChave := "QMH_FILIAL+QMH_ESCALA"
	cQuery := "SELECT QMH_FILIAL,QMH_ESCALA,QMH_PADSEC "
	cQuery += "FROM "+RetSqlName("QMH")+" "
	cQuery += "WHERE "
	cQuery += "QMH_FILIAL = '" +xFilial("QMH")+	"' AND "
	cQuery += "QMH_ESCALA = '" + QMK->QMK_ESCALA + "' AND "	
	cQuery += "D_E_L_E_T_= ' ' "
	
	//Ŀ
	// Montagem da ordem para Informix                                 
	//
	cQuery += " ORDER BY " + SqlOrder(cChave)
	
	cQuery := ChangeQuery(cQuery)
	
	dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),"TQH",.T.,.T.)
	
	While ! Eof() 
		If Ascan(aArrayQMH,AllTrim( TQH->QMH_PADSEC )) == 0
			Aadd(aArrayQMH,AllTrim( TQH->QMH_PADSEC ))
		Endif
		dbSkip()
	EndDo
	TQH->(dbCloseArea()	)
Endif
dbSelectArea( cOldAlias )

If Len(aArrayQMH) > 0
	For nx := 1 to Len(aArrayQMH)
		If nPos > 91 .or. nx == 1
			Aadd(aArrayRet,aArrayQMH[nx])
			nPos := 0
			nPos :=  nPos + Len(aArrayQMH[nx])
		Else
			aArrayRet[Len(aArrayRet)] += " / "+aArrayQMH[nx]
			nPos :=  nPos + (Len(aArrayQMH[nx]) + 3)
		Endif		
	Next		
Endif

Return( aArrayRet )

/*/


Ŀ
Funo	 Mtr020Proc Autor  Alessandro B. Freire   Data  24.04.98 
Ĵ
Descrio  Retorna o procedimento de calibracao do instrumento.       
Ĵ
Sintaxe	  MTR020Proc()                     						  
Ĵ
 Uso		  QMTR020													  
ٱ


/*/
Function Mtr020Proc(TRB_TIPO)
Local cOldAlias := Alias()

//Ŀ
// Encontra o tipo do instrumento.                                 
//
dbSelectArea( "QM1" )
dbSetOrder( 1 )
dbSeek( xFilial("QM1") + TRB_TIPO )
TRB_DESQM1 := QM1->QM1_DESCR
//Ŀ
// Encontra o procedimento de calibracao amarrado ao tipo          
//
dbSelectArea( "QA5")
dbSetOrder( 1 )
If QA5->(dbSeek( xFilial("QA5") + "C" + QM1->QM1_PROCAL ))
	dbSelectArea( cOldAlias )
	Return( AllTrim( QA5->QA5_NORMA ) + " - " + AllTrim ( QA5->QA5_DESCRI ) )
Else
	dbSelectArea( cOldAlias )
	Return( AllTrim( QM1->QM1_PROCAL ))
Endif

/*/


Ŀ
Funo	 r020Cab    Autor  Antonio Aurelio        Data  20.03.00 
Ĵ
Descrio  Cabealho.                                                 
Ĵ
 Uso		  QMTR020													  
ٱ


/*/
Static Function r020Cab(lLnImpr, nLnLim)
Local lRet

Default lLnImpr := .T.
Default nLnLim := 55

lRet := .F.

If li > nLnLim
	
	Cabec(cTitulo,"","",cNomeprog,cTamanho,IIF(aReturn[4]==1,15,18) )
	li := 5
	@ li,00  PSAY __PrtFatLine()
	
	//Ŀ
	// cOldInst  private em r020Imp, e  atualizada apenas em r020Inst   
	// que  quando se imprime todo cabealho de instrumento.             
	//
	If cImpCbInst == cOldInst
		li++
		li++
		@li,00 PSAY cCabec1
		li++
	Else
		r020Inst()
		cOldInst := cImpCbInst
	EndIf
	
	If lLnImpr
		li++
		@ li,00  PSAY __PrtThinLine()
	EndIf
	li++
	lRet := .T.
EndIf

Return lRet


/*/


Ŀ
Funo	 r020Instr  Autor  Antnio Aurlio        Data  20.03.00 
Ĵ
Descrio  Cabealho.                                                 
Ĵ
 Uso		  QMTR020													  
ٱ


/*/
Static Function r020Inst()

//Ŀ
// Quebra por instrumento.                                         
//
If mv_par20 == 1 .And. li > 4
	li := 66
EndIf

//Ŀ
// Faz a troca de pg. se necessrio.        
//
If li > 55  // Imprime todo o 'bloco' ou pula de pg.
	Cabec(cTitulo,"","",cNomeprog,cTamanho,IIF(aReturn[4]==1,15,18) )
	li := 5
	@ li,00  PSAY __PrtThinLine()
EndIf

li++
@li,00 PSAY cCabec1
li++
@Li,00 PSAY cCabec2
li++
@li,00 PSAY cCabec3
li++
@li,00 PSAY cCabec4
li++
@li,00 PSAY cCabec5
li++
@li,00 PSAY cCabec6
li++
@ li,00  PSAY __PrtFatLine()

//Ŀ
// cOldInst  verificada em r020Cab.                      
// cImpCbInst  atualizada quando se troca de instrumento.
//
cOldInst := cImpCbInst

Return .T.


/*/


Ŀ
Funo	 r020Atrib  Autor  Antnio Aurlio        Data  20.03.00 
Ĵ
Descrio  Imprime a linha para atributos.                            
Ĵ
 Uso		  QMTR020													  
ٱ


/*/
Static Function r020Atrib(nCol)

li++
//Ŀ
// Faz a troca de pg. se necessrio.        
//
r020Cab(.T.) // Imprime linha na prx. pg.

@li,00  PSAY "|"
@li,01  PSAY PadR(QM3->QM3_PADRAO,16)
@li,17  PSAY "|"
@li,19  PSAY PadR(QM3->QM3_REVPAD,3)
@li,23  PSAY "|"
If nCol = 1
	@li, 38 PSAY "|"
	@li, 51 PSAY "|"	
	@li, 64 PSAY "|"		
	@li, 76 PSAY STR0026 //  "| [ ] APROVADO        |"
	@li,131 PSAY "|"
	li++
	//Ŀ
	// Verifico se esta no final da pg.         
	// e foro o fechamento da caixa.            
	//
	If li > 55
		@ li,00  PSAY __PrtThinLine()
		li := 66 // Fora a quebra de pg.
	EndIf
	//Ŀ
	// Faz a troca de pg. se necessrio.        
	//
    r020Cab(.T.) // Imprime linha na prx. pg.
	
	@li,00  PSAY "|"
	@li,76  PSAY STR0027 // "|[ ] REPROVADO|"
	@li,131 PSAY "|"
ElseIf nCol == 2
	@li, 38 PSAY "|"
	@li, 51 PSAY "|"	
	@li, 64 PSAY "|"		
	@li, 76 PSAY STR0029  // "|               |              | [  ] APROVADO         [  ] REPROVADO      |                       |"
	@li,131 PSAY "|"	
ElseIf nCol == 4
	@li, 38 PSAY "|"
	@li, 51 PSAY "|"	
	@li, 64 PSAY "|"		
	@li, 76 PSAY  STR0030 // "|              | [  ] APROVADO            [  ] REPROVADO        |                  |"
EndIf

li++
//Ŀ
// Verifico se esta no final da pg. e foro o fechamento da caixa. 
//
If li > 55
	@ li,00  PSAY __PrtThinLine()
	li := 66 // Fora a quebra de pg.
EndIf
//Ŀ
// Faz a troca de pg. se necessrio.        
//
r020Cab(.F.) // No imprime linha na prx. pg.
@ li,00  PSAY __PrtThinLine()

Return NIL

/*/


Ŀ
Funo	 r020AtQMG  Autor  Antnio Aurlio        Data  20.03.00 
Ĵ
Descrio  Imprime a linha para atributos.                            
Ĵ
 Uso		  QMTR020													  
ٱ


/*/
Static Function r020AtQMG()

li++
//Ŀ
// Faz a troca de pg. se necessrio.        
//
r020Cab(.T.) // Imprime linha na prx. pg.

@li, 00 PSAY "|"
@li, 01 PSAY QMG->QMG_PONTO
@li, 17 PSAY "|"
@li, 32 PSAY "|"       
@li, 45 PSAY "|"       
@li, 58 PSAY "|"        
@li, 70 PSAY "|"       

If QM9->QM9_TIPAFE$"4"
	@li,72 PSAY cUniMed
	@li,82 PSAY STR0026
	@li,131 PSAY "|"
	li++
	//Ŀ
	// Verifico se esta no final da pg.         
	// e foro o fechamento da caixa.            
	//
	If li > 55
		@ li,00  PSAY __PrtThinLine()
		li := 66 // Fora a quebra de pg.
	EndIf
	//Ŀ
	// Faz a troca de pg. se necessrio.        
	//
    r020Cab(.T.) // Imprime linha na prx. pg.
	
	@li,00 PSAY "|"
	@li,17 PSAY "|"
	@li,32 PSAY "|"
	@li,45 PSAY "|"
	@li,58 PSAY "|"        
	@li,70 PSAY "|"       
	@li,82 PSAY STR0027	// "| [ ] REPROVADO       |"	
ElseIf QM9->QM9_TIPAFE$"8"
	@li,70 PSAY STR0028	// "| [ ] APROVADO           [ ] REPROVADO      |"
EndIf
@li,131 PSAY "|"

li++
//Ŀ
// Verifico se esta no final da pg.         
// e foro o fechamento da caixa.            
//
If li > 55
	@ li,00  PSAY __PrtThinLine()
	li := 66 // Fora a quebra de pg.
EndIf
//Ŀ
// Faz a troca de pg. se necessrio.        
//
r020Cab(.F.) // No imprime linha na prx. pg.
@ li,00  PSAY __PrtThinLine()

Return NIL


/*/


Ŀ
Funo	 r020Escala Autor  Antnio Aurlio        Data  20.03.00 
Ĵ
Descrio  Imprime a linha para atributos.                            
Ĵ
 Uso		  QMTR020													  
ٱ


/*/
Static Function r020Escala(nCol)
Local aArrays	:={}
Local nx		:= 1
Local lPadSec	:= .F.
Default nCol	:= 1

li++
//Ŀ
// Faz a troca de pg. se necessrio.        
//
r020Cab(.F.,45) // No imprime linha na prx. pg.

@li,000 PSAY STR0014 + QMK->QMK_ESCALA		// "FAIXA.: "
@li,030 PSAY STR0045 + QMK->QMK_REVTIP		// "REV.: "
@li,042 PSAY STR0015 + QM3->QM3_UNIMED + ;	// "UNIDADE DE MEDIDA: "
If(SAH->(Found())," - " + SAH->AH_DESCPO," ")
	li++

	aArrays := Mtr020Sec()

	For nx := 1 To Len(aArrays)
		If nx == 1 // Se passar a primeira vez imprime cabec+dados
			lPadSec := .T.
			@li,00 PSAY STR0016 + aArrays[nx]
			li++		
		Else //So imprime os dados
			@li,19 PSAY aArrays[nx]		
			li++
		Endif
	Next nx
    
    If !lPadSec
		@li,00 PSAY STR0016    	
    Endif
	li++
	@li,00 PSAY STR0017 // "INSTRUMENTO UTILIZADO:"
	li++
	@ li,00  PSAY __PrtThinLine()
	li++              
//             10       20         30        40        50        60        70        80        90        100
//   01234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890
//	"|Padrao          | Rev |Especificado| Tol.Minima | Tol.Maxima |Tp.Calc.Tol| Valor       | Obs.                               |"

	If nCol == 1
		@li, 00 PSAY "|" + STR0018	// "Padrao"
		@li, 17 PSAY "| " + SubsTR(OemToAnsi(STR0019),1,3)+" " // "Rev"
		@li, 23 PSAY STR0020 // "|Especificado| Tol.Minima | Tol.Maxima |Tip.Calc.Toler.|Valor           | Obs.:                                        |"
	ElseIf nCol == 2
		@li, 00 PSAY "|" + STR0018 // "Padrao"
		@li, 17 PSAY "| " + SubsTR(OemToAnsi(STR0019),1,3) // "Rev"
		@li, 23 PSAY STR0021 // "| Especificado | Tol.Minima | Tol.Minima | Vlr Inicial | Vlr Final  | Obs.                  |"
	ElseIf nCol == 4
		@li, 00 PSAY "|"
		@li, 17 PSAY "| "
		@li, 00 PSAY STR0022 // |  Valor Inicial         |   Valor Final         |                  |"
		li++
		@li, 00  PSAY STR0023 // "| Padrao            | Revisao   | Especificado  | Tolerancia   |  Subida    | Descida   |  Subida   | Descida   | Obs.             |"
	EndIf
	li++                                   
	@ li,00  PSAY __PrtThinLine()
	
	
	Return NIL
	
	/*/
	
	
	Ŀ
	Funo	 r020EscQMG Autor  Antnio Aurlio        Data  20.03.00 
	Ĵ
	Descrio  Imprime a linha para atributos.                            
	Ĵ
	 Uso		  QMTR020													  
	ٱ
	
	
	/*/
	Static Function r020EscQMG()
	Local aArrays := {}
	Local nx := 1	
	Local lPadSec := .F.
	li++
	//Ŀ
	// Faz a troca de pg. se necessrio.        
	//
	r020Cab(.T.,48) // Imprime linha na prx. pg.
	
	@li,000 PSAY STR0014 + QMK->QMK_ESCALA // "ESCALA.: "
	dbSelectArea("QM9")
	dbSetOrder(1)
	If dbSeek(xFilial("QM9")+QMK->QMK_ESCALA+QMK->QMK_REVINV)
		dbSelectArea("SAH")
		dbSetOrder(1)
		If dbSeek(xFilial("SAH")+QM9->QM9_UNIMED)
			@li,029 PSAY STR0015 + SAH->AH_UNIMED + ; // "UNIDADE DE MEDIDA:"
			" - " + SAH->AH_DESCPO
		Endif	
	Endif	
	li++
	aArrays := Mtr020Sec()
	For nx := 1 To Len(aArrays)
		If nx == 1 // Se passar a primeira vez imprime cabec+dados
			lPadSec := .T.
			@li,00 PSAY STR0016 + aArrays[nx]
			li++		
		Else //So imprime os dados
			@li,19 PSAY aArrays[nx]		
			li++
		Endif
	Next nx
	If !lPadSec
		@li,00 PSAY STR0016		
	Endif
	li++
	@li,00 PSAY STR0017 // "INSTRUMENTO UTILIZADO:"
	li++
	//Ŀ
	// Faz a troca de pg. se necessrio.        
	//
	r020Cab(.F.,56) // No imprime linha na prx. pg.
	@ li,00  PSAY __PrtThinLine()
	li++
	If QM9->QM9_TIPAFE$"4"		// 1 Coluna
		@li,00 PSAY STR0024  
	ElseIf QM9->QM9_TIPAFE$"8"	// 2 Colunas
		@li,00 PSAY STR0025
	EndIf
	li++
	@ li,00  PSAY __PrtThinLine()
	
	Return NIL
		
		/*/
		
		
		Ŀ
		Funo	 r020MedExt Autor  Antnio Aurlio        Data  20.03.00 
		Ĵ
		Descrio  Imprime linha para lab. externos                           
		Ĵ
		 Uso		  QMTR020													  
		ٱ
		
		
		/*/
		Static Function r020MedExt()
		
		li++
		//Ŀ
		// Faz a troca de pg. se necessrio.        
		//
		r020Cab(.T.) // Imprime linha na prx. pg.
		@li,00  PSAY "|"
		@li,02  PSAY STR0031  // "* * * * * *   M E D I C O E S   R E A L I Z A D A S   P O R   L A B O R A T O R I O   E X T E R N O   * * * * * *"
		@li,131 PSAY "|"
		li++
		If li > 55
			@ li,00  PSAY __PrtThinLine()
			li := 66 // Fora a quebra de pg.
		EndIf
		//Ŀ
		// Faz a troca de pg. se necessrio.        
		//
		r020Cab(.F.) // No imprime linha na prx. pg.
		@ li,00  PSAY __PrtThinLine()
		
		Return .T.
