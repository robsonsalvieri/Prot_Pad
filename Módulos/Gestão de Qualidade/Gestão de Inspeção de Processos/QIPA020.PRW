#INCLUDE "COLORS.CH"
#INCLUDE "FONT.CH"  
#INCLUDE "QIPA020.CH"
#INCLUDE "TOTVS.CH" 

/*/


Ŀ
Funo     QIPA020   Autor  Cleber Souza           Data  25/05/04 
Ĵ
Descrio  Programa de atualizacao de Ensaios                         
Ĵ
 Uso       Generico                                                   
Ĵ
 PROGRAMADOR   DATA    BOPS   MOTIVO DA ALTERACAO                   
Ĵ
                      ------                                        
ٱ


/*/
Static Function MenuDef()

Local aRotina := {{OemToAnsi(STR0001),"AxPesqui",    0, 1,,.F.},; //"Pesquisar"         
                  {OemToAnsi(STR0002),"QP020ENSAIO", 0, 2},;      //"Visualizar"         
                  {OemToAnsi(STR0003),"QP020ENSAIO", 0, 3},;      //"Incluir"       
                  {OemToAnsi(STR0004),"QP020ENSAIO", 0, 4},;      //"Alterar" 
                  {OemToAnsi(STR0005),"QP020ENSAIO", 0, 5 , 3}}   //"Excluir"
                        
Return aRotina

Function QIPA020
//Ŀ
// Define o cabecalho da tela de atualizacoes                   
//
PRIVATE cCadastro := OemtoAnsi(STR0006) //"Ensaios" 
Private lDuplDoc  := .T.

//Ŀ
// Define Array contendo as Rotinas a executar do programa      
// ----------- Elementos contidos por dimensao ------------     
// 1. Nome a aparecer no cabecalho                              
// 2. Nome da Rotina associada                                  
// 3. Usado pela rotina                                         
// 4. Tipo de Transao a ser efetuada                          
//  1 - Pesquisa e Posiciona em um Banco de Dados               
//  2 - Simplesmente Mostra os Campos                           
//  3 - Inclui registros no Bancos de Dados                     
//  4 - Altera o registro corrente                              
//  5 - Remove o registro corrente do Banco de Dados            
//
PRIVATE aRotina := MenuDef()

//Ŀ
// Endereca a funcao de BROWSE                                  
//
mBrowse( 6, 1,22,75,"QP1")

Return .T.

/*/

Ŀ
Funo    QP020ENSAIO Autor  Cleber Souza          Data  25/05/04 
Ĵ
Descrio  Programa de atualizacao de Ensaios - Delecao               
Ĵ
Sintaxe    Qip020Dens(ExpC1,ExpN1,ExpN2)                              
Ĵ
Parametros ExpC1 = Alias do arquivo                                   
           ExpN1 = Numero do registro                                 
           ExpN2 = Opcao selecionada                                  
Ĵ
 Uso       QIPA020                                                    
ٱ


/*/
Function QP020ENSAIO(cAlias,nReg,nOpc) 

Local oDlg
Local oEnsaio
Local oFont1
Local oFont2 
Local oGroup1
Local oGroup2 
Local oTexto         
Local oPanel1   := NIL
Local oSize

Local aHeadAux   := {}
Local aColsAux   := {} 
Local aAltera    := {}  
Local lcont      := .F.

Private oGetNC

Private nPosNC   := 0
Private nPosCla  := 0
Private nPosDNC  := 0
Private nPosDCl  := 0  
Private nOpcA    := 0
Private cTexto   := ""
Private lDuplDoc := .T.

Private aGets    := {}
Private aTela    := {}   

//
//Pesquisa se existem lanamentos para o ensaio antes da excluso.
//
If nOpc == 5 .and. QP020Alt() 
    HELP(" ",1,"A020DENSPR",,QP7->QP7_PRODUT+' - '+QP7->QP7_REVI,3,1)
    Return 
EndIF  

// Validar se pode alterar ou excluir ensaio
If nOpc==4 
    If ExistBlock("QP020AENS") 
        lcont := Execblock("QP020AENS",.F.,.F.) // PE para Permitir a alterao do Ensaio mesmo existindo medies
    Endif
    if !lCont
        DbSelectArea("QPR")
        QPR->(dbSetOrder(2))
        If QPR->(dbSeek(xFilial("QPR")+QP1->QP1_ENSAIO))
            Help(" ",1,"A020ENSMED")   // "Ensaio apresenta medicoes cadastradas"
            Return
        EndIf
    EndIf
Endif

RegToMemory(cAlias,If(nOpc==3,.T.,.F.),.F.)            

QP020LOADNC(@aHeadAux,@aColsAux,nOpc,@aAltera)  

If !Empty(QP1->QP1_CHAVE) .and. nOpc<>3
    cTexto := QA_RecTxt( QP1->QP1_CHAVE, "QIPA020 " )
EndIf

//Ŀ
// Calcula dimenses                                            
//
oSize := FwDefSize():New()

oSize:AddObject( "ENCHOICE" ,  100, 150, .T., .F., .T. ) // Totalmente dimensionavel
oSize:AddObject( "GETDADOS" ,  100, 40, .T., .T., .T. ) // Totalmente dimensionavel
oSize:AddObject( "MULTIGET" ,  100, 20, .T., .T., .T. ) // Totalmente dimensionavel

oSize:lProp := .T. // Proporcional             
oSize:aMargins := { 3, 3, 3, 3 } // Espaco ao lado dos objetos 0, entre eles 3 

oSize:Process() // Dispara os calculos  

//Ŀ
// Monta Dialog                                                 
//
DEFINE MSDIALOG oDlg TITLE cCadastro ;  //"Cadastro Ensaios"
                        FROM oSize:aWindSize[1],oSize:aWindSize[2] TO oSize:aWindSize[3],oSize:aWindSize[4] OF oMainWnd PIXEL
                        
DEFINE FONT oFont1 NAME "Arial" SIZE 0,-11 BOLD
DEFINE FONT oFont2 NAME "Arial" SIZE 0,-11 

//Ŀ
// Monta Panel Primario                                             
//                  
oPanel1:= tPanel():New(000,000,,oDlg,,,,,,oSize:aWindSize[4],oSize:aWindSize[3])

//Ŀ
// Monta a Enchoice                                                          
//
oEnsaio:=MsMGet():New( cAlias, nReg, nOpc,,,,,;
     {oSize:GetDimension("ENCHOICE","LININI"),;
     oSize:GetDimension("ENCHOICE","COLINI"),;
     oSize:GetDimension("ENCHOICE","LINEND"),;
     oSize:GetDimension("ENCHOICE","COLEND")};
    ,aAltera,,,,,oPanel1,,.T.,,,,,,,.T.)

//Ŀ
// Monta TGroup                                                 
//
oGroup1:= TGroup():New(oSize:GetDimension("GETDADOS","LININI"),oSize:GetDimension("GETDADOS","COLINI"),;
                        oSize:GetDimension("GETDADOS","LINEND"),oSize:GetDimension("GETDADOS","COLEND"),STR0007,oPanel1,,,.T.)
oGroup1:oFont:= oFont1

oGroup2:= TGroup():New(oSize:GetDimension("MULTIGET","LININI"),oSize:GetDimension("MULTIGET","COLINI"),;
                        oSize:GetDimension("MULTIGET","LINEND"),oSize:GetDimension("MULTIGET","COLEND"),STR0008,oPanel1,,,.T.)
oGroup2:oFont:= oFont1

//Ŀ
// Monta GetDados                                               
//
oGetNC:= MsNewGetDados():New(oSize:GetDimension("GETDADOS","LININI")+7,oSize:GetDimension("GETDADOS","COLINI")+3 ,oSize:GetDimension("GETDADOS","LINEND")-3,oSize:GetDimension("GETDADOS","COLEND")-3,;
                                Iif(nOpc==3 .Or. nOpc==4, GD_INSERT+GD_DELETE+GD_UPDATE, 0),"QP020LOk","QP020TOk","",,,,,,,oGroup1,aHeadAux,aColsAux)

//Ŀ
// Monta MultiGet                                               
//
oTexto := TMultiGet():New(oSize:GetDimension("MULTIGET","LININI")+7,oSize:GetDimension("MULTIGET","COLINI")+3,{|u| if(Pcount()>0,cTexto:=u,cTexto)} ,oGroup2,;
                          oSize:GetDimension("MULTIGET","XSIZE")-6,oSize:GetDimension("MULTIGET","YSIZE")-11,,,,,,.T.,,,,,,IIf( nOpc==4 .Or. nOpc==3,.F.,.T.),,,,,.T.) 

ACTIVATE MSDIALOG oDlg ON INIT EnchoiceBar(oDlg,{|| IIf(Obrigatorio(aGets,aTela).AND. QP020TOK(nOpc),(nOpcA:=1,oDlg:End()),nOpcA:=0)},{|| nOpcA:=0,oDlg:End()}) CENTERED

If nOpcA==1 .and. nOpc<>2
    QP020GrvAll(nOpc)
EndIf

Return 

/*


ͻ
Programa  QP020LOADNC Autor  Cleber Souza       Data   25/05/04   
͹
Desc.      Rotina que carrega o aHeader e aCols da GetDados.          
                                                                      
͹
Uso        QIPA020                                                    
ͼ


*/
Function QP020LOADNC(aHeadAux,aColsAux,nOpc,aAltera)

Local nIteCol := 0   
Local cCampos := "QP1_TPCART,QP1_CARTA,QP1_TIPO"
Local aStruAlias := FWFormStruct(3, "QP1")[3]
Local nX
//Verifica se campo nao podem ser alterados
For nX := 1 To Len(aStruAlias)
	If cNivel >= GetSx3Cache(aStruAlias[nX,1], "X3_NIVEL") 
		 If QP020Alt() .and. nOpc == 4
            If !(Alltrim(aStruAlias[nX,1] ) $(cCampos))
                AADD(aAltera,aStruAlias[nX,1] )
            EndIF
        Else
            AADD(aAltera,aStruAlias[nX,1] )
        EndIF
	EndIf
Next nX
         
//Ŀ
// Monta vetor aHeadAux a ser utilizado na getdados             
//
aHeadAux := APBuildHeader("QP2")

// Inclui coluna de registro atraves de funcao generica
ADHeadRec("QP2",aHeadAux)

//Ŀ
// Verifica a posicao dos campos no aHeadAux p/ posterior consistencia  
//
nPosNC  := Ascan(aHeadAux,{|x| x[2] == "QP2_NAOCON"})
nPosCla := Ascan(aHeadAux,{|x| x[2] == "QP2_CLASSE"})
nPosDNC := Ascan(aHeadAux,{|x| x[2] == "QP2_DESNCO"})
nPosDCl := Ascan(aHeadAux,{|x| x[2] == "QP2_DESCLA"})
nPosAli := Ascan(aHeadAux,{|x| x[2] == "QP2_ALI_WT"})
nPosRec := Ascan(aHeadAux,{|x| x[2] == "QP2_REC_WT"})

If nOpc <> 3
    dbSelectArea("QP2")
    dbSeek( xFilial("QP2")+QP1->QP1_ENSAIO )
    While !EOF() .And. QP2_FILIAL+QP2_ENSAIO == xFilial("QP2")+QP1->QP1_ENSAIO
        Aadd(aColsAux,Array(Len(aHeadAux)+1))
        For nIteCol:=1 to Len(aHeadAux)
            If aHeadAux[nIteCol,10] # "V"
                aColsAux[Len(aColsAux),nIteCol] := &("QP2->"+aHeadAux[nIteCol,2])
            Else
                If !(aHeadAux[nIteCol,2] $ "QP2_ALI_WT | QP2_REC_WT")
                    If aHeadAux[nIteCol,2] == "QP2_DESNCO"
                        aColsAux[Len(aColsAux),nIteCol] := QipxDNCo(QP2->QP2_NAOCON)
                    ElseIf aHeadAux[nIteCol,2] == "QP2_DESCLA"
                        aColsAux[Len(aColsAux),nIteCol] := A010DCla(QP2->QP2_CLASSE)
                    Else
                        aColsAux[Len(aColsAux),nIteCol] := CriaVar(AllTrim(aHeadAux[nIteCol,2]))
                    EndIf
                EndIf
            Endif
        Next nIteCol
        If nPosAli > 0 .and. nPosRec > 0
            aColsAux[Len(aColsAux),nPosAli] := Alias()
            If IsHeadRec(aHeadAux[nPosRec,2])
                aColsAux[Len(aColsAux),nPosRec] := QP2->(RecNo())
            EndIf
        Endif
        aColsAux[Len(aColsAux),Len(aHeadAux)+1] := .F. 
        dbSelectArea("QP2")
        dbSkip()
    Enddo
EndIf
    
//Ŀ
// Alimenta vetor aColsAux com um elemento em branco p/ inclusao
//
If Len(aColsAux) == 0
    Aadd(aColsAux,Array(Len(aHeadAux)+1))
    For nIteCol = 1 To Len(aHeadAux)
        If aHeadAux[nIteCol,8] == "C"
            aColsAux[1,nIteCol] := Space(aHeadAux[nIteCol,4])
        ElseIf aHeadAux[nIteCol,8] == "N"
            aColsAux[1,nIteCol] := 0
        ElseIf aHeadAuxr[nIteCol,8] == "D"
            aColsAux[1,nIteCol] := dDataBase
        ElseIf aHeadAux[nIteCol,8] == "M"
            aColsAux[1,nIteCol] := ""
        EndIf
    Next nIteCol
    aColsAux[1,Len(aHeadAux)+1] := .F.
EndIf

Return 

/*/


Ŀ
Funo    QP020LOk   Autor  Cleber Souza           Data  25/05/04 
Ĵ
Descrio  Critica se a linha digitada esta' Ok                       
Ĵ
Parametros ExpC1 = Objeto a ser verificado.                           
Ĵ
 Uso       QIPA020                                                    
ٱ


/*/
Function QP020LOk(nOpc)

Local lRet     := .T.
Local nAchou   := 0
Local aCols    := oGetNC:aCols 
Local n        := oGetNC:nAT
Local cProcura := aCols[n,nPosNC]
Local nDel     := Len(oGetNC:aHeader)+1

                      
If !(aCols[n,nDel])
    IF !EMPTY(acols[n,nPosNc]) .or. !EMPTY(acols[n,nposcla])
        //Ŀ
        // Verifica se campo NC esta' preenchido                       
        //
        If Empty(aCols[n,nPosNC])
            Help(" ",1,"QA_CPOOBR")
            lRet:=.F.   
        EndIf
    
        If lRet
            //Ŀ
            // Verifica se a NC ja' existe                     
            //
            nAchou := Ascan(aCols,{|x| x[nPosNC] == cProcura .And. !(x[Len(aCols[n])])})
            If nAchou > 0 .And. nAchou # n
                Help(" ",1,"A020EXINCE")
                lRet:=.F.
            EndIf
        EndIf
    
        //Ŀ
        // Verifica se a NC esta' cadastrada               
        //
        If lRet
            If ! ExistCpo("SAG",aCols[n,nPosNC])
                aCols[n,nPosNC] := Space(TamSX3("QP9_NAOCON")[1])
                lRet := .f.
            EndIf
        EndIf
    
        //Ŀ
        // Verifica se a Classe da NC esta' cadastrada     
        //
        If lRet
            If ! ExistCpo("QEE",aCols[n,nPosCla])
                lRet := .f.
            EndIf
        EndIf
    Endif
    
EndIf

Return lRet
/*/


Ŀ
Funo    QP020TOk   Autor  Cleber Souza           Data  25/05/04 
Ĵ
Descrio  Critica se toda a getdados esta' Ok                        
Ĵ
Parametros ExpC1 = Objeto a ser verificado.                           
Ĵ
 Uso       QIPA020                                                    
ٱ


/*/
Function QP020TOk(nOpc)
Local nI, lRet := .t.    
Local aCols    := oGetNC:aCols
Local lRetok   := .T.

For nI := 1 to Len(aCols)
    If ! QP020LOk(nOpc)
        lRet := .f.
        Exit
    EndIf
Next     
If lRet .AND. EMPTY(M->QP1_CARTA)
    messagedlg(STR0009,,3)//"o campo carta dever ser preenchido"
    lRet:=.f.   
Endif
If lRet .AND. M->QP1_TPCART == "D" .AND. M->QP1_CARTA == "TXT"
    MessageDlg(STR0010,,3)//"No  possivel escolher para Ensaios dimensionais cartas do Tipo Texto."
    lRet:=.f.   
Endif   

//Ŀ
// Ponto de Entrada TUDO OK para validao        
//
If lRet
    If ExistBlock("QP020TDOK")
       lRetok := ExecBlock("QP020TDOK", .F., .F. ,{nOpc})
       If ValType(lRetok) == "L"
             lRet := lRetok
       EndIf
    EndIf    
EndIf 

Return(lRet)    

/*


ͻ
Programa  QP020GrvAll Autor  Cleber Souza       Data   25/05/04   
͹
Desc.      Rotina de gravao dos Ensaios, No Conformidade e Metodo. 
                                                                      
͹
Uso        QIPA020                                                    
ͼ


*/
Function QP020GrvAll(nOpc)       

Local nX      := 0 
Local nY      := 0
Local cVar    := ""
Local nDel    := Len(oGetNC:aHeader)+1
Local aCols   := oGetNC:aCols
Local aHeader := oGetNC:aHeader  
Local cChave  := "" 
Local aTexto  := {}
Local aStruAlias := FWFormStruct(3, "QP1")[3]
Local nX

//Ŀ
// Atualiza os dados referentes ao Ensaio                       
//
RecLock("QP1",If(nOpc==3,.T.,.F.))

If (nOpc == 3 .Or. nOpc == 4) //Inclusao ou Alteracao
	For nX := 1 To Len(aStruAlias)
		If GetSx3Cache(aStruAlias[nX,1], "X3_CONTEXT") <> "V"
			FieldPut(FieldPos(AllTrim(aStruAlias[nX,1])),&("M->"+aStruAlias[nX,1]))	
		EndIf
	Next nX
EndIf

If (nOpc == 3) //Inclusao
    QP1->QP1_FILIAL := xFilial("QP1")
    QP1->QP1_CADR   := cUserName
    QP1->QP1_DTCAD  := dDataBase
EndIf

MsUnLock() 
FKCOMMIT()

//Ŀ
// Grava Nao Conformidades Relacionadas ao Ensaio               
// 

//Ŀ
// Grava o arquivo QP2        
//
For nX := 1 to Len(oGetNC:aCols)
    If !Empty(aCols[nX,nPosNC]) // Cod. NC nao vazio
        If !Acols[nX,nDel] .and. (nOpc==3 .or. nOpc==4)// Nao esta deletado 
            dbSelectArea("QP2")
            dbSetOrder(1)
            If dbSeek(xFilial("QP2") + QP1->QP1_ENSAIO + aCols[nX,nPosNC])         
                RecLock("QP2",.F.)   // Lock
            Else
                RecLock("QP2",.T.)   // Append
                QP2->QP2_FILIAL := xFilial("QP2")
                QP2->QP2_ENSAIO := QP1->QP1_ENSAIO
            Endif
            For nY := 1 to Len(aHeader)
                If aHeader[ny,10] # "V"
                    cVar := Trim(aHeader[ny,2])
                    Replace &cVar. With aCols[nx,ny]
                Endif
            Next nY
        Else
            //Ŀ
            // Cancela a NC no QP2                   
            //
            dbSelectArea("QP2")
            dbSetOrder(1)
            If dbSeek(xFilial("QP2") + QP1->QP1_ENSAIO + aCols[nX,nPosNC])         
                RecLock("QP2",.F.)
                dbDelete()
            EndIf
        EndIf
        MsUnlock()
        FKCOMMIT()
    EndIf
Next nX        

//Ŀ
// Grava Metodo Informado.                                      
//
If  nOpc==3 .or. nOpc==4
    AADD(aTexto,{1,cTexto})
    If !Empty(cTexto)
        //Ŀ
        // Gera/Obtem a chave ligacao com o Texto do Ensaio 
        //
        If Empty(QP1->QP1_CHAVE)
            cChave := QA_CvKey(xFilial("QP1")+QP1_ENSAIO,"QP1",2)
            // Grava a chave gerada
            RecLock("QP1",.F.)
            QP1->QP1_CHAVE := cChave
            MsUnLock()
        Else
            cChave := QP1->QP1_CHAVE
        Endif
        
        //Ŀ
        // Grava Texto do Ensaio no QA2                             
        //
        QA_GrvTxt(cChave,"QIPA020 ",1,aTexto)   // QAXFUN
    Else
        If !Empty(QP1->QP1_CHAVE)
            QA_GrvTxt(QP1->QP1_CHAVE,"QIPA020 ",1,aTexto)   // QAXFUN
        EndIF
    EndIF
EndIf 


//Ŀ
// Na Rotina de exluso, Ensaio tem de ser excluido por ultimo 
//
If (nOpc == 5)      
    RecLock("QP1",.F.)
    QP1->(dbDelete())
    MsUnLock() 
    FKCOMMIT()
EndIf

Return

/*

Ŀ
Funo    QP020Alt   Autor  Cleber Souza            Data  25/05/04 
Ĵ
Descrio  Verifica se existe especificacao cadastrada cadastrada     
           Caso exista nao deixa alterar campo.                       
Ĵ
 Uso       QIPA020                                                    
ٱ


/*/
Function QP020Alt()  
Local lAltera   := .F.
Local aArea     := GetArea()
Local aFiliais := {}
Local nY       := 0
Local cFilQP1  := xFilial("QP1") 

If (FWModeAccess("QP6") == "E") //!Empty(xFilial("QP6"))
    aFiliais := QA_RetFilEmp(SM0->M0_CODIGO) //Retorna as Filiais associadas a Empresa Atual
Else 
    AADD(aFiliais,{Space(FWSIZEFILIAL()),Space(FWSIZEFILIAL()),Space(FWSIZEFILIAL()),Space(FWSIZEFILIAL())})
EndIF                                                     

For nY:=1 to Len(aFiliais)  
    If aFiliais[nY,2]==cFilQP1 .or. (FWModeAccess("QP1") == "C")//Empty(cFilQP1)
        dbSelectArea("QP7")
        dbSetOrder(3)
        If dbSeek(aFiliais[nY,2]+QP1->QP1_ENSAIO)
            lAltera := .T.
        Else
            dbSelectArea("QP8")
            dbSetOrder(3)
            If dbSeek(aFiliais[nY,2]+QP1->QP1_ENSAIO)
                lAltera := .T.
            EndIf   
        EndIf
    EndIf
    If lAltera
        Exit
    EndIf   
Next nY 

QP7->(dbSetOrder(1))
QP8->(dbSetOrder(1))
RestArea(aArea)

Return(lAltera) 

/*/


Ŀ
Funo     A020VQTD  Autor  Marcelo Pimentel       Data  09/09/98 
Ĵ
Descrio  Valida o campo Qtde na entrada de dados                    
Ĵ
 Uso       X3_VALID do campo QP1_QTDE                                 
ٱ


/*/
Function A020VQtd(cCarta,nQtde)
Local lRetu := .t.

If cCarta $ 'HIS.XBR.XBS.XMR.IND'
    If nQtde < 2  
        lRetu := .f.
        Help(" ",1,"A020CARTAX")
    ElseIf nQtde > 10
        lRetu := .f.
        Help(" ",1,"A020CARTAX")
    Endif
ElseIf cCarta $ 'NP .C  '
    If nQtde == 0
        lRetu := .f.
        Help(" ",1,"A020CARTAC")
        M->QP1_QTDE := 1
    EndIf
Else
    If nQtde <> 0
        lRetu := .f.
        Help(" ",1,"A020CARTAP")
        M->QP1_QTDE := 0
    EndIf
EndIf
Return(lRetu)

/*/


Ŀ
Funo     A020VlNC  Autor  Marcelo Pimentel       Data  09/09/98 
Ĵ
Descrio  Valida campo Nao Conformidade                              
Ĵ
Sintaxe    A020VlNC(ExpC1)                                            
Ĵ
Parametros ExpC1 = Codigo da Nao Conformidade                         
Ĵ
 Uso       Generico - E' chamada no X3_VALID do cpo. QP?_NAOCON - SX3 
ٱ


/*/
Function A020VlNC(cNC)
Local cVar  := &(readvar()) //Contedo da varivel do campo NC
Local lRetu := .t.
Local nCont := 0

//Verifica se mudou a NC (Alterou o campo j digitado)
If !Empty(oGetNC:aCols[oGetNC:oBrowse:nAt][nPosNC]) .and. !Empty(cVar) .and. oGetNC:aCols[oGetNC:oBrowse:nAt][nPosNC] <> cVar
	Help(" ",1,"A010ALTCHA")//Campo no pode ser alterado
	lRetu := .f.
EndIf

If lRetu
	//Verifica se a NC est cadastrada
	oGetNC:aCols[oGetNC:oBrowse:nAt][nPosNC] := cNc
	
	SAG->(dbSetOrder(1))
	If SAG->(dbSeek(xFilial("SAG")+cNc))
		oGetNC:aCols[oGetNC:oBrowse:nAt][nPosCla] := SAG->AG_CLASSE
	Else
		oGetNC:aCols[oGetNC:oBrowse:nAt][nPosNC] := Space(TamSX3("QP9_NAOCON")[1])
		lRetu := .f.
	EndIf
	
EndIf

//Verifica se a NC j existe
If lRetu
	For nCont := 1 To Len(oGetNC:aCols)
		If cVar == oGetNC:acols[nCont][nPosNC] .and. nCont <> oGetNC:oBrowse:nAt // Se j existir este cod. NC
			Help(" ",1,"A020EXINCE")
			lRetu := .f.
			EXIT
		EndIf
	Next nCont
EndIf

If lRetu
	//Preenche a Descrio da NC
	oGetNC:aCols[oGetNC:oBrowse:nAt][nPosDNC] := QipxDNCo(oGetNC:aCols[oGetNC:oBrowse:nAt][nPosNC])
	
	//Preenche a Descrio da Classe
	oGetNC:aCols[oGetNC:oBrowse:nAt][nPosDCl] := A010DCla(oGetNC:aCols[oGetNC:oBrowse:nAt][nPosCla])
EndIf

Return(lRetu)

/*/


Ŀ
Funo     A020VlCl  Autor  Marcelo Pimentel       Data  09/09/98 
Ĵ
Descrio  Valida campo Classe da Nao Conformidade                    
Ĵ
Sintaxe    A020VlNC(ExpC1)                                            
Ĵ
Parametros ExpC1 = Classe da Nao Conformidade                         
Ĵ
 Uso       Generico - E' chamada no X3_VALID do cpo. QP?_CLASSE - SX3 
ٱ


/*/
Function A020VlCl(cClasse)
Local lRetu := .t., nI,;
        cVar := &(readvar()) // Conteudo da variavel do campo Classe NC

//Ŀ
// Verifica se a Classe da NC esta' cadastrada     
//
aCols[n,nPosCla] := cClasse
If ! ExistCpo("QEE",aCols[n,nPosCla])
    lRetu := .f.
EndIf

//Ŀ
// Preenche a Descricao da Classe                  
//
If lRetu
    aCols[n,nPosDCl] := A010DCla(aCols[n,nPosCla])
EndIf

Return(lRetu)

/*/


Ŀ
Funo    A020WheQt  Autor  Marcelo Pimentel       Data  09/09/98 
Ĵ
Descrio  Determina X3_WHEN do campo QTDE de acordo com a Carta      
Ĵ
 Uso       QIPA020 - Chamada pelo cpo. QP1_QTDE - X3_WHEN             
ٱ


/*/
Function A020WheQt()
Local lRetu := .t.
//Ŀ
// Verifica se a Carta permite entrada da Qtde      
//
If ReadVar() == "M->QP1_QTDE"
    If M->QP1_CARTA $ 'P  .U  ' .Or. M->QP1_TPCART =="X"
        lRetu := .f.
    EndIf

    //Ŀ
    // Se houver medicoes p/ o ensaio, nao altera a Qtde.             
    //
    If lRetu
        QPR->(dbSetOrder(2))
        If QPR->(dbSeek(xFilial("QPR")+M->QP1_ENSAIO))
            Help(" ",1,"A020ENSMED")   // "Ensaio apresenta medicoes cadastradas"
            lRetu := .f.
        EndIf
        QPR->(dbSetOrder(1))
    EndIf
EndIf

Return(lRetu)
/*/


Ŀ
Funo    A020WhTp   Autor  Marcelo Pimentel       Data  06/10/98 
Ĵ
Descrio  Determina X3_WHEN do campo CARTA de acordo com o Tipo.     
Ĵ
 Uso       QIPA020 - Chamada pelo cpo. QP1_CARTA- X3_WHEN             
ٱ


/*/
Function A020WhTp()
Local lRetu := .t.

If ReadVar() == "M->QP1_CARTA"
    //Ŀ
    // Verifica se a Tipo de Carta.                    
    //
    If M->QP1_TPCART $"X.T"
        If M->QP1_TPCART =="X"
            M->QP1_CARTA := "TXT"
        EndIf
        lRetu := .f.
    EndIf
EndIf
Return lRetu
/*/


Ŀ
Funo     A020IQtd  Autor  Marcelo Pimentel       Data  09/09/98 
Ĵ
Descrio  Inicializa o campo Qtde na entrada de dados (X3_RELACAO)   
Ĵ
 Uso       Gatilho do campo QP1_QTDE, a partir do QP1_CARTA           
ٱ


/*/
Function A020IQtd(cCarta)

Local nQtde := nRetu := M->QP1_QTDE

If Empty(nQtde)
    //Ŀ
    // Se campo Qtde vazio, sugere as Qtdes defaults                
    //
    If cCarta == 'IND'
        nRetu := 2
    ElseIf cCarta $ 'HIS.XBR.XBS.XMR'
        nRetu := 5
    ElseIf cCarta $ 'NP .C  '
        nRetu := 1
    Endif
Else
    //Ŀ
    // Consiste o campo Qtde, porque pode ter alterado a Carta    
    //
    If cCarta $ 'IND.HIS.XBR.XBS.XMR.NP .C  '
        If cCarta == 'IND'
            nRetu := 2
        ElseIf cCarta $ 'HIS.XBR.XBS.XMR'
            nRetu := 5
        Endif
    Else
        nRetu := 0
    Endif
Endif

Return(nRetu)

/*/


Ŀ
Funo     A020DCar  Autor  Marcelo Pimentel       Data  09/09/98 
Ĵ
Descrio  Gatilho para preencher a descricao da Carta do Ensaio      
Ĵ
Sintaxe    A020DCar(ExpC1,ExpL1)                                      
Ĵ
Parametros ExpC1 = Codigo da Carta                                    
           ExpL1 = Indica se e' gatilho                               
Ĵ
 Uso       Generico-Cham. no X3_RELACAO,X3_INIBRW e gat. (QP1_CARTA)  
ٱ


/*/
Function A020DCar(cCodCa,lGatilho)
lGatilho := Iif(lGatilho == NIL,.t.,lGatilho)

IF !Empty(cCodCa) .And. !Inclui .Or. lGatilho // Se Inic. Padrao ou gatilho a partir do cod. equipe
    Return(Tabela("Q4",cCodCa))
Else
    Return(Space(Len(X5Descri())))
Endif

/*/


Ŀ
Funo     A020Valid Autor  Marcelo Pimentel       Data  09/09/98 
Ĵ
Descrio  Verifica se o campo Carta  obrigatorio.                   
Ĵ
 Uso       QIPA020                                                    
ٱ

*/
Function A020Valid()

Local lRet := .T.

If M->QP1_TPCART == "D"     //Tipo de carta "DIMENSIONAL"
    If Empty(M->QP1_CARTA)
        Help(" ",1,"QA_CPOOBR")
        lRet := .F.
    EndIf
EndIf       

//Valida a carta Texto
If lRet .And. M->QP1_TPCART <> "X" .And. M->QP1_CARTA == "TXT"
    Help(" ",1,"QA_TPCARTX") //"A carta 'TXT' somente podera ser utilizada" ### "para o tipo de carta 'X' - (Texto)"
    lRet := .F.
EndIf

//Ensaio do Tipo Calculado somente para carta Individual
If lRet .And. M->QP1_TIPO == "C" .And. !(M->QP1_CARTA $ "IND,XBR,XBS,HIS,XMR")
    Help(" ",1,"QP20TPCALC") //"O Ensaio Calculado somente podera ser" ### "utilizado para cartas 'IND,XMR,XBR,XBS e HIS'"
    lRet := .F.
EndIf

Return lRet
/*


Ŀ
Funo      A020EnsC Autor  Cleber Souza           Data 22/03/2005
Ĵ
Descrio  habilita o campo somente para as cartas Individuais        
Ĵ
Sintaxe    A020EnsC()                                                 
Ĵ
Parametros                                                            
Ĵ
 Uso       X3_WHEN do QP1_TIPO                                        
ٱ


*/
Function A020EnsC()
Local lRetorno := .F.

If M->QP1_CARTA $ "XBR/XBS/XMR/IND/HIS"  
        lRetorno := .T.
Else
    M->QP1_TIPO :=  'D'
EndIf 

Return(lRetorno)   
/*


ͻ
Programa  QIPA020   Autor  Renata Cavalcante    Data   09/20/07   
͹
Desc.      Funo para incluso de ensaio via consulta padro         
                                                                      
͹
Uso        Funo para incluso de ensaio via consulta padro         
ͼ


*/
Function Q020INCENS

AxInclui("QP1",,,,,,"Q020TUDOK()")

Return()                        

/*


ͻ
Programa  QIPA020   Autor  Renata Cavalcante    Data   09/20/07   
͹
Desc.      Funo para validao do cadastro via consulta padro      
                                                                      
͹
Uso        Funo para validao do cadastro via consulta padro      
ͼ


*/
Function Q020Tudok  
Local lRet:=.T.
    If EMPTY(M->QP1_CARTA)
        messagedlg(STR0009,,3)//"o campo carta dever ser preenchido"
        lRet:=.f.   
    Endif
Return(lRet)
