#include 'InsightDefs.ch'

//-------------------------------------------------------------------
/*/{Protheus.doc} pinsObject
Instância uma classe a partir de um insight registrada.

@param cInsight, caracter, Nome do insight que será avaliado.

@return oObject, Objeto do extrator da entidade.
@author  Marcia Junko
@since   26/08/2024
/*/
//-------------------------------------------------------------------
Function pinsObject( cInsight )
	Local oObject 	:= nil
	Local cSource	:= ""

	Default cInsight := ""

	//-------------------------------------------------------------------
	// Identifica o fonte da entidade.
	//-------------------------------------------------------------------
	cSource := pinsSource( cInsight )
	
	//-------------------------------------------------------------------
	// Retorna uma intância da classe da entidade.
	//-------------------------------------------------------------------
	If ! ( Empty( cSource ) )
		oObject	:= pinsClass( cSource )
	EndIf 	
Return oObject

//-------------------------------------------------------------------
/*/{Protheus.doc} pinsSource
Identifica o fonte de um insight

@param cInsight, caracter,  Nome do insight que será avaliado.  

@return cSource, Fonte da entidade. 
@author  Marcia Junko
@since   26/08/2024
/*/
//-------------------------------------------------------------------
Function pinsSource( cInsight )
	Local aSource	:= {}	
	Local cSource	:= ""
	Local cFunction	:= ""

	Default cInsight := ""

	//-------------------------------------------------------------------
	// Define a função que será pesquisada.
	//-------------------------------------------------------------------	
	cFunction := ( cInsight + "_PI_" )

	If ( FindFunction( cFunction ) )
		//-------------------------------------------------------------------
		// Pesquisa pela função no RPO.
		//-------------------------------------------------------------------
		GetFuncArray( cFunction,, aSource )

		//-------------------------------------------------------------------
		// Identifica o fonte da entidade.
		//-------------------------------------------------------------------		
		If ! ( Empty( aSource ) )
			cSource	:= aSource[ Len( aSource ) ] 
		EndIf 
	EndIf 	
Return cSource

//-------------------------------------------------------------------
/*/{Protheus.doc} pinsListInsight
Identifica o fonte de um insight

@param cInsight, caracter, Nome do insight.  

@return array, Array com a lista dos fontes. 
@author  Marcia Junko
@since   26/08/2024
/*/
//-------------------------------------------------------------------
Function pinsListInsight( cInsight )
	Local aInsights := {}
	Local aReturn	:= {}	

	Default cInsight := "*"

	//-------------------------------------------------------------------
	// Pesquisa todas as entidades registradas.
	//-------------------------------------------------------------------
	aInsights := GetFuncArray( cInsight + "_PI_" )

	aEval( aInsights, {|x| Aadd( aReturn, StrTran( x, '_PI_', '' ) ) } )

Return aReturn


//-------------------------------------------------------------------
/*/{Protheus.doc} pinsClass
Instancia uma classe.

@param cSource, caracter, Fonte da entidade. 

@return oObject, Classe instanciada.
@author  Marcia Junko
@since   26/08/2024
/*/
//-------------------------------------------------------------------
Function pinsClass( cSource )
    Local cClassName := ''
    Local cAux := ''
	Local nPos := 0
	// Local bErro 	:= nil
	Local oObject 	:= nil
	
	Default cSource	:= ""
	
	// bErro := ErrorBlock( { | e | BIXSysOut( "BIXOBJECT", "[" + cEmpAnt + "][" + AllTrim( cFilAnt ) + "] " + e:ErrorStack )  } )
	
	//-------------------------------------------------------------------
	// Instancia a classe informada.
	//-------------------------------------------------------------------
	BEGIN SEQUENCE
		cAux := StrTran( cSource, '.TLPP', '' )
		nPos := RAT( '.', cAux )

		cClassName := IIf( '.TLPP' $ cSource, SubStr( cAux, nPos + 1 ), Iif( !( 'TESTCASE' $ cSource ), SubStr( cSource, 1, At( ".", cSource ) - 1 ) , 'TESTEINSIGHT' ) )
		oObject	:= &( cClassName+ "():New()" ) 
	END SEQUENCE 

	// ErrorBlock( bErro )
Return oObject

//-------------------------------------------------------------------
/*/{Protheus.doc} pinsTempSizeDefault
Indica o tamanho padrão para os campos da tabela temporária.

@param cType, caracter, Indica o tipo de informação que estamos avaliando.
@param cAttribute, caracter, Define o nome da coluna na tabela temporária.
@param cProperty, caracter, Define o nome da propriedade na mensagem.
@param nPosition, numeric, Define a posição da chave composta que será retornado para a propriedade.

@return array, Vetor com a estrutura utilizada na tabela temporária.
@author  Marcia Junko
@since   26/08/2024
/*/
//-------------------------------------------------------------------
Function pinsTempSizeDefault( cType, cAttribute, cProperty, nPosition )
	Local aStruct := {}
	
	Default cAttribute := ''
	Default cProperty := ''
	Default nPosition := 2

	Do Case 
		Case cType == 'branch'
			aStruct := { "branch", "C", 20, 0 }
		Case cType == 'company_group'
			aStruct := { "comp_grp", "C", 10, 0 }
		Case cType == 'code'
			aStruct := { cAttribute, "C", 200, 0, cProperty, nPosition }
		Case cType == 'name'
			aStruct := { cAttribute, "C", 100, 0 }
		Case cType == 'description'
			aStruct := { cAttribute, "C", 200, 0 }
		Case cType == 'store'
			aStruct := { cAttribute, "C", 10, 0 }
		Case cType == 'guid'
			aStruct := { cAttribute, "C", 36, 0 } 
		Case cType == 'value'
			aStruct := { cAttribute, "N", 17, 2 } 
		Case cType == 'quantity'
			aStruct := { cAttribute, "N", 17, 2 } 
		Case cType == 'accuracy'
			aStruct := { 'accuracy', "N", 7, 2 } 
		Case cType == 'date'
			aStruct := { cAttribute, "C", 26, 0 } 
		Case cType == 'memo'
			aStruct := { cAttribute, "M", 10, 0 } 
	EndCase
Return aStruct

//-------------------------------------------------------------------
/*/{Protheus.doc} pinsError
Instância o objeto de erro com a mensagem que será exibida.

@param nCode, numeric, Código do erro
@param cTitle, caracter, Título da mensagem
@param aDescription, array, Vetor com a descrição do erro, sendo:
	[1] - String traduzida
	[2] - array com o conteúdo do I18N

@return oObject, Objeto da exceção;
@author  Marcia Junko
@since   07/09/2024
/*/
//-------------------------------------------------------------------
Function pinsError( nCode, cTitle, aDescription )
	Public oException 	:= nil

	Default nCode := -1
	Default cTitle := ""
	Default aDescription := {}
	// Default lThrow := .T.

	oException              := ErrorClass():New()
	oException:genCode      := nCode
	// oException:description  := "InsightMessageConsumer: " + I18N( STR0001, { oJsonMessage["transactionid"] } )   //"Mensagem #1 não possui insight informado"
	If len( aDescription ) > 1
		oException:description  := cTitle + ": " + I18N( aDescription[1], aDescription[ 2 ] )   
	Else
		oException:description  := cTitle + ": " + aDescription[1]
	EndIf
	Throw oException
Return 

//-------------------------------------------------------------------
/*/{Protheus.doc} pinsSaveConfig
Função para salvar a configuração dos insights existentes.

@author  Marcia Junko
@since   07/09/2024
/*/
//-------------------------------------------------------------------
Function pinsSaveConfig()
	Local aSvAlias := GetArea()
	Local aInsights := {}
	Local nX := 0
	Local oObject

	DBSelectArea( "I19" )
	DBSelectArea( "I20" )
	DBSelectArea( "I21" )
	
	//----------------------------------------------------------
	// lista com os insights inscritos
	//----------------------------------------------------------
	aInsights := pinsListInsight()

	For nX := 1 to len( aInsights )
		//----------------------------------------------------------
		// Carrega o objeto do Insight
		//----------------------------------------------------------            
		oObject := pinsObject( aInsights[ nX ] )

		//----------------------------------------------------------
		// Carrega as configurações do Insight
		//----------------------------------------------------------
		If oObject <> NIL            
			oObject:Config()

			//----------------------------------------------------------
			// Salva a configuração na tabela I20
			//----------------------------------------------------------            
			oObject:SaveConfig()
		EndIf
	Next

	RestArea( aSvAlias )
	FWFreeArray( aInsights )
	FreeObj( oObject )
Return


//-------------------------------------------------------------------
/*/{Protheus.doc} pinsExistConfig
Função que avalia se a configuração de um insight existe na tabela I20.
@param cName, caracter, nome do insight para busca

@Return logical, Indica se a configuração existe ou não na tabela I20.
@author  Marcia Junko
@since   16/01/2025
/*/
//-------------------------------------------------------------------
Function pinsExistConfig( cName )
	Local oObject
	Local lExists := .F.

	If AliasInDic( "I20" )
		oObject := pinsObject( Alltrim( cName ) )
		lExists := oObject:Exists( cName )
	EndIf

	FreeObj( oObject )
Return lExists

//-------------------------------------------------------------------
/*/{Protheus.doc} pinsFieldsStruct
Função que retorna a estrutura para a tabela temporária de um insight
@param cName, caracter, nome do insight para busca

@Return array, Retorna a definição dos campos
@author  Marcia Junko
@since   14/05/2025
/*/
//-------------------------------------------------------------------
Function pinsFieldsStruct( cName )
	Local oInsightDefinition
	Local aFieldsTab := {}

	 If AliasInDic( "I20" )
		oInsightDefinition := pinsObject( Alltrim( cName ) )
		oInsightDefinition:Struct()
		aFieldsTab	:= aclone( oInsightDefinition:GetStruct() )		
	 EndIf

	FreeObj( oInsightDefinition )
Return aFieldsTab


//-------------------------------------------------------------------
/*/{Protheus.doc} pinsFromToMock
Função que retorna o De/Para das propriedades da Mensagem

@param cName, Character, Nome do insight para busca
@return aFromTo, Array, Propriedades estrutura antiga x nova que devem ser utilizadas no Mock

@author  Victor Vieira
@since   17/06/2025
/*/
//-------------------------------------------------------------------
Function pinsFromToMock( cName )
	Local oInsightDefinition 
	Local aFromTo := {}

	 If AliasInDic( "I20" )
		oInsightDefinition := pinsObject( Alltrim( cName ) )
		aFromTo	:= aclone( oInsightDefinition:FromToMock() )		
	 EndIf

	FreeObj( oInsightDefinition )
Return aFromTo
