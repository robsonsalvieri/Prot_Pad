#include 'tlpp-core.th'
#include 'InsightDefs.ch'
#include "BACKOFFICE.BA.INSIGHTS.STOCK_OUT.CH"

REGISTER INSIGHT stock_out

//-------------------------------------------------------------------
/*/{Protheus.doc} Class stock_out
Classe com configuração do insight Stock_out (Estoque).

Método New() construtor da classe.
Método Config() configurações do insight gravados na tabela I20.
Método Struct() estrutura da tabela temporária gravada no campo Memo I21_PAYLOD.
Método FromToMock() array com de/para com a propriedade da mensagem antiga I14 e a propriedade na mensagem nova I19.

/*/
//-------------------------------------------------------------------
Class stock_out from PinsConfig
	Public Method New() CONSTRUCTOR
	Public Method Config()
	Public Method Struct()
	Public Method FromToMock() 
EndClass

//-------------------------------------------------------------------
/*/{Protheus.doc} New
Método construtor da classe.

/*/
//-------------------------------------------------------------------
Method New() class stock_out
	_Super:New( 'stock_out', 'EST' )
Return Self

//-------------------------------------------------------------------
/*/{Protheus.doc} Config
Indica a configuração dos atributos utilizados pelo insight stock_out
que serão gravados na tabela I20.

/*/
//-------------------------------------------------------------------
Method Config() class stock_out

	::SetHasKey( .T. )
	::SetHasFilter( .T. )
	::SetPriority( .T. )

	::SetKey("key")
    
Return

//-------------------------------------------------------------------
/*/{Protheus.doc} Struct
Indica os campos que fazem parte da tabela temporária e como estas 
informações serão tratadas.

A estrutura a ser definida deve ter a seguinte estrutura:
	[1] - nome da propriedade na mensagem ( campo memo da tabela I21 )
	[2] - estrutura de campo da tabela temporária
		[1] - Nome da coluna
		[2] - tipo
		[3] - tamanho
		[4] - decimal
	[3] - Indica se a coluna pode ser usada no filtro de pesquisa
	[4] - Texto apresentado
	[5] - Indica a ordem apresentada no browse
	[6] - Indica que a propriedade da mensagem contém uma chave composta

@author  Marcia Junko
@since   09/05/2025
/*/
//-------------------------------------------------------------------
Method Struct() class stock_out
	Local aStruct := {}

	//Campos referentes as propriedades do JSON, campo I21_PAYLOD
	aadd(aStruct, {"id"                           , pinsTempSizeDefault( "guid", "id" )               						, .F. , STR0001, STRUCT_INVISIBLE })	//"Id"
	aadd(aStruct, {"product_code"                 , pinsTempSizeDefault( "code", "prodcode" )         						, .T. , STR0002, 3, .T. })	//"Código"
	aadd(aStruct, {"frequency"                    , { "freqc", "C", 1, 0 }                            						, .F. , STR0003, 9 })	//"Periodicidade"
	aadd(aStruct, {"stock_out_date"               , pinsTempSizeDefault( "date", "stckodt" )          						, .F. , STR0004, STRUCT_INVISIBLE })	//"Dt. Saida Estoque"
	aadd(aStruct, {"product_forecast_value"       , { "forcvl", "N", 17, 2 }          										, .F. , STR0005, 12 })	//"Previsão de Saldo"
	aadd(aStruct, {"product_stock_quantity"       , { "prodstckqt", "N", TamSX3("B2_QATU")[1] , TamSX3("B2_QATU")[2] }		, .F. , STR0006, 13 })	//"Saldo em Estoque"
	aadd(aStruct, {"replenishment"				  , { "repmnt", "N", TamSX3("B1_EMIN")[1] , TamSX3("B1_EMIN")[2] }			, .F. , STR0007, 14 })	//"Ponto de Reposição"
	aadd(aStruct, {"safety_stock" 				  , { "sft_stck", "N", TamSX3("B1_ESTSEG")[1] , TamSX3("B1_ESTSEG")[2] } 	, .F. , STR0008, 15 })	//"Estoque de Segurança"
	aadd(aStruct, {"product_description"          , pinsTempSizeDefault( "description", "proddescr" ) 						, .T. , STR0009, 4 })	//"Descrição"
	aadd(aStruct, {"product_type"                 , { "tpe", "C", TamSX3("B1_TIPO")[1] , TamSX3("B1_TIPO")[2] }				, .F. , STR0010, 5, .T. })	//"Tipo"
	aadd(aStruct, {"product_type_description"     , { "prodtpdesc", "C", TamSX3("X5_DESCRI")[1] , TamSX3("X5_DESCRI")[2] }	, .F. , STR0011, 6 })	//"Descrição do Tipo"
	aadd(aStruct, {"product_group"                , pinsTempSizeDefault( "store", "prodgroup" )       						, .F. , STR0012, 7, .T. })	//"Grupo"
	aadd(aStruct, {"product_group_description"    , pinsTempSizeDefault( "description", "prodgrdesc" )						, .F. , STR0013, 8 })	//"Descrição do Grupo"
	aadd(aStruct, {"product_unity"                , { "produnity", "C", TamSX3("B1_UM")[1] , TamSX3("B1_UM")[2] } 			, .F. , STR0014, 11 })	//"Unidade"
	aadd(aStruct, {"product_minimum_lot"          , { "prodminlot", "N", TamSX3("B1_LM")[1] , TamSX3("B1_LM")[2] }       	, .F. , STR0015, 16 })	//"Lote Mínimo"
	aadd(aStruct, {"product_max_stock"            , { "prodmaxsto", "N", TamSX3("B1_EMAX")[1] , TamSX3("B1_EMAX")[2] }   	, .F. , STR0016, 17 })	//"Estoque Máximo"
	aadd(aStruct, {"product_storage"              , { "prodstorag", "C", TamSX3("B1_LOCPAD")[1] , TamSX3("B1_LOCPAD")[2] } 	, .F. , STR0017, 10 })	//"Armazém Padrão"
	aadd(aStruct, {"product_inventory_periodicity", { "prodinvper", "C", 1, 0 }                       						, .F. , STR0018, 18 })	//"Periodicidade de Inventário"
	aadd(aStruct, {"product_last_revision_date"   , pinsTempSizeDefault( "date", "lst_rev_dt" )       						, .F. , STR0019, 19 })	//"Última Revisão"
	aadd(aStruct, {"product_origin"               , pinsTempSizeDefault( "store", "orign" )           						, .F. , STR0020, 20 })	//"Origem do Produto"
	aadd(aStruct, {"accuracy"                     , pinsTempSizeDefault( "accuracy" )                 						, .F. , STR0021, STRUCT_INVISIBLE })	//"Precisão"
	aadd(aStruct, {"mdmlastupdated"               , pinsTempSizeDefault( "date", "mLstUpd" )         						, .F. , STR0022, 21 })	//"Ult. Atualização"
	aadd(aStruct, {"graph_points"                 , pinsTempSizeDefault( "memo", "grphPt" )           						, .F. , STR0023, 22 })	//"Graph. Points"
	aadd(aStruct, {"quality_category"          	  , { "quali_cat" , "C", 2 , 0 }                                          	, .F. , STR0024, 1 })	//"Acurácia"

	//Campos diretos I21 
	aadd(aStruct, {"branch"                       , pinsTempSizeDefault( "branch" )                   						, .T. , STR0025, 2 })	//"Filial"

	aStruct := PINSDebugFields(aStruct)

	_Super:SetStruct( aStruct )

Return

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} FromToMock
	Função  que retorna o De/Para Mock estrutura antiga x nova 
	
	@return aPropMock, Array, Propriedades estrutura antiga x nova que devem ser utilizadas no Mock
	O Retorno do De/Para tem a seguinte estrutura:
	[1] - nome da propriedade na estrutura antiga 
	[2] - nome da propriedade na estrutura nova

	@author Victor Vieira 
	@since 13/06/2025
/*/
//-----------------------------------------------------------------------------------------------------
Method FromToMock() class stock_out

	Local aPropMock   := {}
	
	aadd(aPropMock, {"code"						, "product_code" 					})
	aadd(aPropMock, {"forecast_value"			, "product_forecast_value" 			})
	aadd(aPropMock, {"stock_quantity"			, "product_stock_quantity" 			})
	aadd(aPropMock, {"description"				, "product_description" 			})
	aadd(aPropMock, {"type"	 					, "product_type" 					})
	aadd(aPropMock, {"type_description"			, "product_type_description" 		})
	aadd(aPropMock, {"group_code"				, "product_group" 					})
	aadd(aPropMock, {"group_description"		, "product_group_description" 		})
	aadd(aPropMock, {"unity"					, "product_unity" 					})
	aadd(aPropMock, {"minimum_lot"				, "product_minimum_lot" 			})
	aadd(aPropMock, {"max_stock"				, "product_max_stock" 				})
	aadd(aPropMock, {"storage"					, "product_storage"					})
	aadd(aPropMock, {"inventory_periodicity"	, "product_inventory_periodicity"	})
	aadd(aPropMock, {"last_revision_date"		, "product_last_revision_date"		})
	aadd(aPropMock, {"origin"					, "product_origin"					})	
	aadd(aPropMock, {"maecategory"				, "quality_category"				})	
	aadd(aPropMock, {"graphPoints"				, "graph_points"					})	
	aadd(aPropMock, {"mdmLastUpdated"			, "mdmlastupdated"					})	
			
Return aPropMock
