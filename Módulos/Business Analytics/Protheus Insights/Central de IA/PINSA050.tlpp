#INCLUDE "TOTVS.CH"
#INCLUDE "PINSA050.CH"

//-------------------------- PINSA050 --------------------------------
// Funções para cadastro de Armazéns IA utilizados no Protheus Insight
//-------------------------------------------------------------------

#DEFINE IDENTIFIER PadR( "storageIA", TamSX3( "I1A_NAME" )[ 1 ] ) // Static utilizada para identificação do cadastro de Armazéns IA

//-------------------------------------------------------------------
// Definição das posições da coluna do ListBox
//-------------------------------------------------------------------
#DEFINE SELECTED  1
#DEFINE BRANCH 2
#DEFINE CODE 3
#DEFINE STORAGE 4

//-------------------------------------------------------------------
/*/{Protheus.doc} PINSA050
Função de cadastro de Armazéns IA utilizados no Protheus Insights.
Apresenta os Armazéns da NNR - 'Locais de Armazéns' para seleção e
gravação na tabela I1A - 'Definições Protheus Insights'.

@return lReturn, logical, Se rotina executada com sucesso.
@author Lucas Lima
@since 20/05/2025
/*/
//-------------------------------------------------------------------
Function PINSA050()
    Local lReturn   := .F. As logical

    If FwIsAdmin()
        If AliasInDic("I1A")
            DbSelectArea("I1A")

            lReturn := ScreenStoragesIA()
        Else
            MsgInfo( STR0012, STR0009 )     //"Identificamos que o ambiente não possui a estrutura necessária para execução desta rotina. Por favor, atualize os dicionário com o pacote acumulado do Protheus Insights.""###"Atenção"        
        EndIf
    Else
        MsgInfo( STR0011, STR0009 )     //"Apenas usuários com perfil de administrador do sistema podem acessar essa rotina!"###"Atenção"
    EndIf

Return lReturn

//-------------------------------------------------------------------
/*/{Protheus.doc} ScreenStoragesIA
Apresenta a tela com uma ListBox para seleção dos Armazéns.

@author Lucas Lima
@since 23/05/2025
/*/
//-------------------------------------------------------------------
Static Function ScreenStoragesIA()
    Local oDialog       := nil As object
    Local oLayer        := nil As object
    Local oPanel        := Nil As object
    Local oTSay         := Nil As object
    Local oTGet         := Nil As object
    Local oTButton      := Nil As object
    Local oListStorage  := nil As object
    Local oCheck		:= LoadBitmap( GetResources(), 'LBTIK' ) As object
	Local oUnCheck		:= LoadBitmap( GetResources(), 'LBNO' ) As object
    Local aStorages     := {} As array
    Local aStorageI1A   := {} As array
    Local aColSize      := { 010, TamSX3( "NNR_FILIAL" )[ 1 ], TamSX3( "NNR_CODIGO" )[ 1 ], TamSX3( "NNR_DESCRI" )[ 1 ] } As array
    Local cSearch       := Space( 50 ) As character
    Local lContinue     := .F. As logical

    // Armazéns já cadastrados na I1A - Tabela de Definições Insights
    aStorageI1A := pinsStorageI1A()
    // Armazéns cadastrados na tabela NNR - Locais de Estoque
    aStorages   := pinsGetStorages( aStorageI1A )

	oDialog := MsDialog():New(0,0,500,600,STR0001,,,,,CLR_BLACK,CLR_WHITE,,,.T.)    //"Armazéns IA"

        oLayer := FWLayer():New()
		oLayer:Init( oDialog )
		oLayer:addLine( "TOP", 80, .F.)
		oLayer:addCollumn( "TOP_ALL", 100, .T. , "TOP")
		oLayer:addWindow( "TOP_ALL", "TOP_WINDOW", STR0002 , 100, .F., .T.,, "TOP")     //"Selecione os Armazéns para utilização no Insights"

		oPanel := oLayer:getWinPanel( "TOP_ALL", "TOP_WINDOW", "TOP" )

        oTSay := TSay():New( 005,002,{ || STR0003 },oPanel,,,,,,.T.,CLR_BLACK,CLR_WHITE,200,012 )   //"Pesquisar :"
        oTGet := TGet():New( 002,030,{ |u| if( PCount()==0, cSearch, cSearch:=u ) },oPanel,056,012,"@!",,0,,,.F.,,.T.,,.F.,,.F.,.F.,,.F.,.F.,,"cSearch",,,, )
        oTButton := TButton():New( 003,090,STR0004,oPanel,{|| PositionSearch( cSearch, aStorages, oListStorage ) },030,012,,,.F.,.T.,.F.,,.F.,,,.F. )    //"Pesquisar"

      	@ 017, 000 LISTBOX oListStorage;
		  FIELDS HEADER "", STR0005, STR0006, STR0007 ; //"Filial"###"Cód.Armazém"###"Armazém"
		  SIZE 296, 164 OF oPanel PIXEL

		oListStorage:SetArray( aStorages )
		oListStorage:nAt		    := 1
		oListStorage:bLine 		    := {|| { If( aStorages[ oListStorage:nAt, SELECTED ], oCheck, oUnCheck), aStorages[ oListStorage:nAt, BRANCH ], aStorages[ oListStorage:nAt, CODE ], aStorages[ oListStorage:nAt, STORAGE ] } }
        oListStorage:bHeaderClick   := {|a,b| IIf( b==1, CheckAll( aStorages, b ), ), oListStorage:Refresh() }
		oListStorage:bLDblClick     := {|| aStorages[ oListStorage:nAt, SELECTED ] := !aStorages[ oListStorage:nAt, SELECTED ], oListStorage:Refresh() }

	oDialog:Activate( ,,,.T.,{||},,EnchoiceBar( oDialog, { || iif( CheckSelected( aStorages ), { lContinue := .T., oDialog:End() } , MsgInfo( STR0008, STR0009 ) )  }, { || oDialog:End() }, .F., {},,,.F.,.F.,.F.,.T., .F. ) ) // "Favor selecionar ao menos um Armazém para continuar."###"Atenção"

    If lContinue
        pinsSaveI1A( IDENTIFIER, aStorages )
    EndIf

    FWFreeArray( aStorages )
    FWFreeArray( aStorageI1A )
    FWFreeArray( aColSize )

    FreeObj( oDialog )
    FreeObj( oLayer )
    FreeObj( oPanel )
    FreeObj( oTSay )
    FreeObj( oTGet )
    FreeObj( oTButton )
    FreeObj( oListStorage )

Return lContinue

//-------------------------------------------------------------------
/*/{Protheus.doc} pinsStorageI1A
Retorna array com armazéns cadastrados anteriormente na I1A.

@return aStorageI1A, array, Array de Armazéns da tabela I1A - Definições Protheus Insights.
@author Lucas Lima
@since 20/05/2025
/*/
//-------------------------------------------------------------------
Function pinsStorageI1A()
    Local aStorageI1A := {}  As Array
    Local cAlias      := ''  As Character

    cAlias := pinsGetI1A()

    While ( cAlias )->( !Eof() )
        AAdd( aStorageI1A, { ( cAlias )->I1A_BRANCH + PadR( AllTrim( (cAlias)->I1A_VALUE ), TamSX3( "NNR_CODIGO" )[ 1 ] ) } )

        ( cAlias )->( DbSkip() )
    EndDo
    ( cAlias )->( dbCloseArea() )

Return aStorageI1A

//-------------------------------------------------------------------
/*/{Protheus.doc} pinsGetStorages
Retorna array com Armazéns cadastrados na tabela NNR.

@param aStorageI1A, array, Array de Armazéns cadastrados na I1A- Definições Protheus Insights.

@return aStorages, array, Armazéns cadastrados na tabela NNR - Locais de Armazéns
@author Lucas Lima
@since 20/05/2025
/*/
//-------------------------------------------------------------------
Function pinsGetStorages( aStorageI1A )
    Local aStorages   := {}  As Array
    Local cQuery      := ''  As Character
    Local cAlias      := ''  As Character
    Local oStatement  := Nil As Object

    cQuery := " SELECT NNR_FILIAL, NNR_CODIGO, NNR_DESCRI "
    cQuery += " FROM ? NNR "
    cQuery += " WHERE NNR.D_E_L_E_T_ = ? "
    cQuery += " ORDER BY NNR_FILIAL, NNR_CODIGO "

    cQuery := ChangeQuery( cQuery )

    oStatement := FwExecStatement():New( cQuery )
    oStatement:setUnsafe( 1, RetSqlName( "NNR" ) )
    oStatement:setString( 2, " " )

    cAlias := oStatement:OpenAlias()

    While (cAlias)->( !Eof() )
        AAdd(aStorages, { .F., (cAlias)->NNR_FILIAL, (cAlias)->NNR_CODIGO, (cAlias)->NNR_DESCRI})

        // Marca no ListBox armazéns configurados anteriormente na tabela I1A
        If AScan( aStorageI1A, { |x| x[ 1 ] == (cAlias)->NNR_FILIAL + (cAlias)->NNR_CODIGO } ) > 0
            aStorages[ Len( aStorages ), SELECTED ] := .T.
        EndIf
        (cAlias)->( DbSkip() )
    EndDo
    ( cAlias )->( dbCloseArea() )

    FreeObj( oStatement )

Return aStorages

//-------------------------------------------------------------------
/*/{Protheus.doc} CheckAll
Marca todos ao clicar no cabeçalho da coluna de CHECK para marcar/desmarcar as linhas.

@param aLista, array, Array de Armazéns
@param nPos, numeric, Coluna do checkbox

@author Lucas Lima
@since 20/05/2025
/*/
//-------------------------------------------------------------------
Static Function CheckAll( aLista, nPos )
	Local lMark := .F. As logical

	aEval( aLista, {|x| IIf( !x[ nPos ], lMark := .T., ) } )
	aEval( aLista, {|x, i| aLista[ i, nPos ] := lMark } )

Return

//-------------------------------------------------------------------
/*/{Protheus.doc} CheckSelected
Valida se ao menos um item do Array de Armazéns está marcado.

@param aArray, array, Array de Armazéns

@return logical, true or false
@author Lucas Lima
@since 20/05/2025
/*/
//-------------------------------------------------------------------
Static Function CheckSelected( aArray )
Return ( aScan( aArray, {|x| x[1] == .T. } ) > 0 )

//-------------------------------------------------------------------
/*/{Protheus.doc} PositionSearch
    Procura linha da filial + armazém digitada no get de pesquisa.

    @param cSearch, character, Chave digitada no get de pesquisa.
    @param aStorages, array, Vetor com Armazéns.
    @param oListStorage, object, Objeto do ListBox.

    @author Lucas Lima
    @since 23/05/2025
/*/
//-------------------------------------------------------------------
Static Function PositionSearch( cSearch, aStorages, oListStorage )
    Local nPosition := 0 As numeric
    Local nOldPosition := oListStorage:nAt As numeric
    Local nInitialSearch := IIf( nOldPosition==1, nOldPosition, IIf( Len( aStorages ) == nOldPosition, 1, nOldPosition + 1 ) ) As numeric

    // procura na coluna de codigos
    nPosition := aScan( aStorages, { |x| AllTrim( cSearch ) $ x[ CODE ] }, nInitialSearch )
    // em seguida na coluna descrição
    If nPosition == 0
        nPosition := aScan( aStorages, { |x| AllTrim( cSearch ) $ x[ STORAGE ] }, nInitialSearch )
    EndIf
    // e por último nas filiais
    If nPosition == 0
        nPosition := aScan( aStorages, { |x| AllTrim( cSearch ) $ x[ BRANCH ] }, nInitialSearch )
    EndIf

    If nPosition > 0
        oListStorage:nAt := nPosition
        oListStorage:Refresh()
    Else
        MsgInfo( STR0010, STR0009 )     //"Chave não encontrada!"###"Atenção"
    EndIf

Return

//-------------------------------------------------------------------
/*/{Protheus.doc} pinsGetI1A
Retorna dados de configuração da tabela I1A - Definições de Protheus Insight.

@param cIdentifier, character, identificador de qual definição deseja retorno

@return cAlias, character,  Alias da Tabela temporária
@author Lucas Lima
@since 28/05/2025
/*/
//-------------------------------------------------------------------
Function pinsGetI1A( cIdentifier )
    Local cQuery := '' As Character
    Local cAlias := '' As Character
    Local oStatement := nil As Object

    Default cIdentifier := IDENTIFIER

    cQuery := " SELECT I1A_BRANCH, I1A_VALUE "
    cQuery += " FROM ? I1A "
    cQuery += " WHERE I1A.I1A_FILIAL = ? "
    cQuery += " AND I1A.I1A_NAME = ? "
    cQuery += " AND I1A.D_E_L_E_T_ = ? "
    cQuery += " ORDER BY I1A_BRANCH, I1A_VALUE "

    cQuery := ChangeQuery( cQuery )

    oStatement := FwExecStatement():New( cQuery )

    oStatement:setUnsafe( 1, RetSqlName( "I1A" ) )
    oStatement:setString( 2, FWxFilial( "I1A" ) )
    oStatement:setString( 3, cIdentifier )
    oStatement:setString( 4, " " )

    cAlias := oStatement:OpenAlias()

    FreeObj( oStatement )

Return cAlias

//-------------------------------------------------------------------
/*/{Protheus.doc} pinsSaveI1A
Trata configurações na tabela de Definições de Insights - I1A.

@param cIdentifier, character, Identificador da configuração. 
@param aData, array, Vetor com itens selecionados. Onde: 
    [1] - Valida se o item está marcado
    [2] - Filial do Insight
    [3] - Nome da configuração Insight
    [4] - Conteúdo da configuração Insight

@author Lucas Lima
@since 20/05/2025
/*/
//-------------------------------------------------------------------
Function pinsSaveI1A( cIdentifier, aData )
    Local aArea := GetArea() As array
    Local nI := 0 As numeric
    Local nSizeBranch := 0 As Integer
    Local nSizeName := 0 As Integer
    Local nSizeValue := 0 As Integer
    Local lReturn := .F. As logical

    Default cIdentifier := IDENTIFIER
    Default aData := {}

    DbSelectArea( "I1A" )
    I1A->( DbSetOrder( 1 ) )    // I1A_FILIAL + I1A_BRANCH + I1A_NAME + I1A_VALUE

    nSizeBranch := TamSX3( "I1A_BRANCH" )[ 1 ]
    nSizeName := TamSX3( "I1A_NAME" )[ 1 ]
    nSizeValue := TamSX3( "I1A_VALUE" )[ 1 ]

    Begin Transaction
        For nI := 1 To Len( aData )
            If I1A->( MsSeek( FWxFilial( "I1A" ) + PadR( aData[ nI ][ BRANCH ], nSizeBranch ) + PadR( cIdentifier, nSizeName ) + PadR( aData[ nI ][ CODE ], nSizeValue ) ) )
                If !aData[ nI ][ SELECTED ]
                    lReturn := .T.

                    RecLock( "I1A", .F. )
                        DbDelete()
                    MsUnlock()
                EndIf
            Else
                If aData[ nI ][ SELECTED ]
                    lReturn := .T.

                    RecLock( "I1A", .T. )
                        I1A->I1A_FILIAL	    := FWxFilial( "I1A" )
                        I1A->I1A_BRANCH	    := aData[ nI ][ BRANCH ]
                        I1A->I1A_NAME	    := cIdentifier
                        I1A->I1A_VALUE	    := aData[ nI ][ CODE ]
                    MsUnlock()
                EndIf
            EndIf
        Next nI
    End Transaction

    RestArea( aArea )
    ASize( aArea, 0 )
    aArea := NIL

Return lReturn
