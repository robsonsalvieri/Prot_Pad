#include 'tlpp-core.th'
#include 'tlpp-rest.th'
#include 'protheus.ch'
#include 'pinsalerts.ch'

NAMESPACE totvs.protheus.backoffice.ba.insights

//-------------------------------------------------------------------
/*/{Protheus.doc} getAlerts
  EndPoint Get retorna os insights de Alert

  @author Raphael.Santana
  @since 02/08/2024
/*/
//-------------------------------------------------------------------
@Get(endpoint="api/ba/v1/insights/Alerts")
Function getAlerts()

	Local oJsGet         as Object
	Local oJsRet         as Object
	Local oJson          as Object
	Local oPrepare       as Object
	Local oFieldsTab     as Object
	Local cTmpAlias      as Character
	Local cCondition     as Character
	Local cNextAlias     as Character
	Local cAliasDB       as Character
	Local cOrder         as Character
	Local cOrderSort     as Character
	Local cCodUsr        as Character
	Local cBranch        as Character
	Local cQryBranch     as Character
	Local cWhere         as Character
	Local cPropJs        as Character
	Local cFieldsTab     as Character
	Local cfilterByField as Character
	Local nPage          as Numeric
	Local nPageSize      as Numeric
	Local nLinhaIni      as Numeric
	Local nLinhaFim      as Numeric
	Local nX             as Numeric
	Local aCpoTab        as Array
	Local aStruCPO       as Array
	Local aTables        as Array
	Local lIsMock		 as Logical

	oJsGet      := oRest:GetQueryRequest()
	oJsRet 		:= JsonObject():New()
	oJson       := JsonObject():New()
	oFieldsTab  := JsonObject():New()

	cfilterByField := ''
	lIsMock        := .F.
	cTmpAlias      := oJsGet[ 'tabTmpName' ]
	cCodUsr        := oJsGet[ 'codUser' ]
	cBranch        := oJsGet[ 'branch' ]
	nPage          := Val(oJsGet[ 'page' ])
	nPageSize      := Val(oJsGet[ 'pageSize' ])
	cCondition     := oJsGet[ 'filter' ]
	cOrder         := oJsGet[ 'order' ]
	cOrderSort     := oJsGet[ 'orderSort' ]
	cFieldsTab 	   := oJsGet[ 'jsFieldTab' ]
	cTypeAlert     := oJsGet[ 'typeAlert' ]

	If oJsGet:hasProperty( 'filterByField' )
		cfilterByField := oJsGet[ 'filterByField' ]
	EndIf

	If oJsGet:hasProperty( 'isMock' )
		lIsMock := Iif(oJsGet[ 'isMock' ] == "True", .T., .F.)
	EndIf

	oPrepare   := Nil
	cNextAlias := ""
	cWhere     := ""
	cPropJs    := "alerts"
	cAliasDB   := GetNextAlias()
	cQryBranch := ""
	nLinhaIni  := 0
	nLinhaFim  := 400
	nX         := 0
	aCpoTab    := {}
	aStruCPO   := {}

	If !Empty(cFieldsTab)

		oFieldsTab:FromJson(cFieldsTab)

		cTypeAlert := oFieldsTab:GetNames()[1]
		aCpoTab    := oFieldsTab[cTypeAlert]

		For nX:=1 To Len(aCpoTab)
			Aadd(aStruCPO, {aCpoTab[nX][2][1], aCpoTab[nX][2][2], aCpoTab[nX][2][3], aCpoTab[nX][2][4]})
		Next nI

	EndIf

	//Validação de propriedades obrigatórias que são enviadas pelo front
	If !Empty(cTmpAlias) .AND. !Empty(cCodUsr) .AND. !Empty(cBranch) .AND. Len(acpotab) > 0

		If !Empty(cCondition)
			cCondition := Upper(cCondition)
		EndIf

		// Atribui as tabbelas para validar o compartilhamento
		If cTypeAlert == 'demandAlert' .Or. cTypeAlert == 'ruptureAlert'
			aTables := { 'SD1', 'SD2', 'SD3' }
		EndIf

		If !lIsMock
			cQryBranch := GetBranchUser( cCodUsr, aTables )
		EndIf

		//Calcula a lilnha inicial e final que será usada na query para paginação
		If !Empty(nPage) .AND. !Empty(nPageSize)
			nLinhaIni := (( nPage - 1 ) * nPageSize ) + 1
			nLinhaFim := nPage * nPageSize
		EndIf

		//Monta a string de condições usada na query
		cWhere := PINSMakeWhere(acpotab, cCondition, cQryBranch, cfilterByField )

		//Monta a query base do select na tabela temporária
		oPrepare := PINSMakePage(cTmpAlias, cWhere, cOrder, cOrderSort, cCodUsr, acpotab)

		//Seta a linha inicial e final referente a paginação
		oPrepare:setNumeric( 1, nLinhaIni )
		oPrepare:setNumeric( 2, nLinhaFim )

		Try
			//Executa a query e abre área da tabela com resultado da query
			cNextAlias := MPSysOpenQuery( oPrepare:GetFixQuery(), , aStruCPO )

			// Avalia se a tabela temporária já está aberta
			If SELECT( cTmpAlias ) == 0
				//Abre a área com a tabela temporária
				dbUseArea( .T.,"TOPCONN",cTmpAlias,cTmpAlias,.T.,.T.)
			EndIf

			//Inicia o json para receber um array
			oJsRet[cPropJs] := {}

			// Itera sobre todos os registros com o mesmo I14_MESSID
			While (cNextAlias)->(!Eof())

				//Posiciona no recno da tabela temporária
				(cTmpAlias)->(DbGoTo((cNextAlias)->R_E_C_N_O_))

				//Chama função que monta a estrutura do json com base no registro da tab temporaria posicionado e na estrutura de campos
				oJson := PINSAlertJson(cTmpAlias, acpotab)

				//Incrementa o json de retorno
				aadd(oJsRet[cPropJs],oJson)

				(cNextAlias)->(DbSkip())
			EndDo

			//Fecha as áreas temporárias abertas
			(cTmpAlias)->(DbCloseArea())
			(cNextAlias)->(DbCloseArea())

			//Alimenta a estrutura do json de retorno
			oJsRet["success"] := .T.
			oJsRet["hasNext"] := HasNext(cTmpAlias, nLinhaFim, cWhere)

		Catch oException

			//Tratamento de erros na executação
			oJsRet := JsonObject():New()
			oJsRet["success"] := .F.
			oJsRet["return"] := STR0002
			oRest:setStatusCode(500)

		EndTry

	Else
		//Retorno referente a validação de parâmetros obrigatórios
		oJsRet["success"] := .F.
		oJsRet["return"] := STR0003
		oRest:setStatusCode(400)
	EndIf

	FWFreeArray( aTables )
	FWFreeArray( aCpoTab )
	FWFreeArray( aStruCPO )
	FreeObj( oJsGet )
	FreeObj( oJson  )
	FreeObj( oFieldsTab )
	FreeObj( oPrepare )
Return oRest:setResponse(oJsRet)

//-------------------------------------------------------------------
/*/{Protheus.doc} GetBranchUser
Função que faz a validação de acesso do usuário e retorna quais filiais ele pode acessar

@param cUserId, caracter, Código do usuário
@param aTables, array, Vetor com as tabelas mandatórias do insight
    
@return caracter, String com as filiais onde o usuário tem acesso.
@author Raphael Santana Ferreira
@since 25/07/2024
/*/
//-------------------------------------------------------------------
Static function GetBranchUser( cUserId, aTables )
	local cFilUsr := ""  as character
	local cBranchTable := ""  as character
	Local aBranches := {} as Array
	Local aBranchesbyCompany := {} as Array
	Local aSM0 := {} as Array
	Local aAux := {} as Array
	Local nI := 0
	Local nJ := 0

	Default aTables := {}

	If cUserID == __cUserID
		aSM0 := FWLoadSM0( .T., .T. )

		aBranchesbyCompany := totvs.protheus.backoffice.ba.insights.util.filterArray( aSM0, {|x| x[ SM0_GRPEMP ] == cEmpAnt  } )
		aBranches := totvs.protheus.backoffice.ba.insights.util.filterArray( aBranchesbyCompany, {|x|  x[ SM0_USEROK ] } )

		If len( aBranchesbyCompany ) <> len( aBranches )
			If len( aBranches ) > 0
				For nI := 1 to len( aBranches )
					For nJ := 1 to len( aTables )
						cBranchTable := xFilial( aTables[ nJ ], aBranches[ nI ][ SM0_CODFIL ] )
						If !Empty( cBranchTable)
							If Ascan( aAux, {|x| x == cBranchTable} ) == 0
								aAdd( aAux, cBranchTable )
							EndIf
						EndIf
					Next
				Next

				For nI := 1 to len( aAux )
					cFilUsr += "'" + aAux[ nI ] + "'" + If( nI == Len( aAux ), "", ", " )
				Next
			Else
				cFilUsr := 'NOBRANCH'
			EndIf
		EndIf
	Else
		cFilUsr := 'NOBRANCH'
	EndIf

	FWFreeArray( aBranches )
	FWFreeArray( aBranchesbyCompany )
	FWFreeArray( aSM0 )
	FWFreeArray( aAux )
Return cFilUsr

//-------------------------------------------------------------------
/*/{Protheus.doc} HasNext
Função que verifica se existem mais páginas alert enviado pelo smartlink

@param cTmpAlias, caracter, nome da tabela temporária
@param nRegFim, numeric, número final do registro
@param cWhere, caracter, condição de busca

@return boolean, Indica se terá uma próxima página
@author Raphael Santana Ferreira
@since 25/07/2024

/*/
//-------------------------------------------------------------------
Static Function HasNext(cTmpAlias, nRegFim, cWhere)

	Local cQuery   as Character
	Local cAlias   as Character
	Local lHasNext as Logical

	lHasNext :=	.F.
	cQuery   := ""

	cQuery+= " SELECT MAX( LINE_NUMBER ) MAX_LINE FROM ( "
	cQuery+= "   SELECT ROW_NUMBER() OVER( ORDER BY R_E_C_N_O_ ) LINE_NUMBER,  "
	cQuery+= "       R_E_C_N_O_ RECNO "
	cQuery+= "   FROM " + cTmpAlias

	cQuery += cWhere

	cQuery+= " ) TAB "

	oStatement := FWPreparedStatement():New( ChangeQuery(cQuery) )

	cQuery := oStatement:getFixQuery()

	cAlias := MPSysOpenQuery(cQuery)

	( cAlias )->( DBGoTop() )

	If ( cAlias )->( !Eof() )
		If ( cAlias )->MAX_LINE > nRegFim
			lHasNext := .T.
		EndIf
	EndIf

	(cAlias)->( DBCloseArea() )
	FreeObj(oStatement)

Return lHasNext

//-------------------------------------------------------------------
/*/{Protheus.doc} groupingFields
EndPoint Get Retorna os valores dos campos das Dropbox dos insights

@param cTable, caracter, nome real da tabela para pesquisa.

@author valter.carvalho@totvspartners.com.br
@since 17/09/2024
/*/
//-------------------------------------------------------------------
	@Get(endpoint="api/ba/v1/insights/groupingFields")
Function groupingFields()
	Local oJsGet	:= oRest:GetQueryRequest()  As Json
	Local oJsRes	:= JsonObject():new()		As Json
	Local cTable	:= oJsGet[ "tabTmpName" ]		As Character
	Local cName 	:= ""						As Character
	Local oJField	:= JsonObject():new()			As Json
	Local nI			:= 1 						As Numeric

	oJField:FromJson( oJsGet["fields"] )

	If Empty( cTable ) .Or. !oJField:hasProperty( "fields" ) .Or. Empty( oJField[ "fields" ] )
		oJsRes[ "errors"]  := { STR0004 } // "Parâmetros obrigatórios não informados: tabTmpName, fields"

		oRest:setStatusCode( 400 )
	Else
		For nI:= 1 to Len( oJField[ "fields" ] )
			cName := Alltrim( oJField[ "fields" ][ nI ][ "code" ] )
			iF cName $ 'mae_categ|quali_cat'
				oJsRes[ cName ] := MakeAccuracy()
			else
				oJsRes[ oJField[ "fields" ][ nI ][ "code" ]] := getFieldGroupingListData( cTable, oJField[ "fields" ][ nI ] )
			Endif
		Next
		oRest:setStatusCode( 200 )
	EndIf

	oRest:setResponse( oJsRes:toJson() )
Return

//-------------------------------------------------------------------
/*/{Protheus.doc} getFieldGroupingListData
Retorna os valores distintos de um campo da tabela temporaria e monta o json de resposta.

@param cTable, caracter, nome real da tabela para pesquisa.
@param oJsItem, json, Vetor com os itens a apresentar no response.

@return array, Vetor com os itens a apresentar no response.
@author valter.carvalho@totvspartners.com.br
@since 17/09/2024
/*/
//-------------------------------------------------------------------
Static Function getFieldGroupingListData( cTable as Character, oJsItem As Json )
	Local aArea		:= GetArea()	As Array
	Local aRes   	:= {}			As Array
	Local aFields  	:= {}			As Array
	Local oStatement				As Object
	Local cQuery 	:= ""			As Character
	Local oJItTmp					As Json
	Local oJson						As Json
	Local cFieldCod := ""			As Character
	Local cFieldValue :=""			As Character

	cFieldCod   := Upper( oJsItem["code"] )
	cFieldValue := Upper( oJsItem["description"] )

	cQuery     := " SELECT DISTINCT ? ? FROM ? WHERE D_E_L_E_T_ = ' ' ORDER BY ? "
	oStatement := FWExecStatement():New(ChangeQuery( cQuery ) )
	oStatement:setUnSafe( 1, cFieldCod )

	If cFieldCod <> cFieldValue
		oStatement:setUnSafe( 2, ", " + cFieldValue )
	Else
		oStatement:setUnSafe(2, "" )
	EndIf

	oStatement:setUnSafe(3, cTable)
	oStatement:setUnSafe(4, cFieldCod)

	cAlias := MPSysOpenQuery( oStatement:getFixQuery() )

	While (cAlias)->( !Eof() )
		oJItTmp := JsonObject():new()

		oJItTmp[ "code" ] := ( cAlias )->&( cFieldCod )

		If cFieldCod <> cFieldValue
			oJItTmp["description"] := allTrim(( cAlias )->&( cFieldCod ) ) + " - " + Alltrim( ( cAlias )->&( cFieldValue ) )
		Else
			oJItTmp["description"] := Alltrim( ( cAlias )->&( cFieldCod ) )
		EndIf

		Aadd( aRes, oJItTmp )

		( cAlias )->( DbSkip() )
	EndDo

	( cAlias )->( DbCloseArea() )

	RestArea( aArea )

	FWFreeArray( aArea )
	FWFreeArray( aFields )
	FreeObj( oStatement )
	FreeObj( oJItTmp )
	FreeObj( oJson )

Return aRes

//-------------------------------------------------------------------
/*/{Protheus.doc} MakeAccuracy
Função que gera as opções para acurácia qualitativa.

@return jSon,  Objeto com as opções da acurácia qualitativa.
@author Marcia Junko 
@since 27/09/2024
/*/
//-------------------------------------------------------------------
Static Function MakeAccuracy()
	Local oAccuracy
	Local aOptions := {}
	Local aRes := {}
	Local nI := 0

	Aadd( aOptions, { '01', STR0008 } )	//'Excelente'
	Aadd( aOptions, { '02', STR0007 } )	//'Boa'
	Aadd( aOptions, { '03', STR0006 } )	//'Razoável'
	Aadd( aOptions, { '04', STR0005 } )	//'Baixa precisão'

	For nI := 1 to Len( aOptions )
		oAccuracy := JsonObject():new()
		oAccuracy["code"] := aOptions[ nI ][ 1 ]
		oAccuracy["description"] := aOptions[ nI ][ 2 ]

		Aadd( aRes, oAccuracy )
	Next

	FreeObj( oAccuracy )
	FWFreeArray( aOptions )
Return aRes

//-------------------------------------------------------------------
/*/{Protheus.doc} pinsBranchUser
Função que expoe a função estática GetBranchUser

@param cBranch, caracter, Filial do sistema
@param cUserId, caracter, Código do usuário
@param aTables, array, Vetor com as tabelas mandatórias do insight
    
@return caracter, String com as filiais onde o usuário tem acesso.
@author Raphael Santana Ferreira
@since 25/07/2024
/*/
//-------------------------------------------------------------------
Function pinsBranchUser( cUserId, aTables )
Return GetBranchUser( cUserId, aTables )
