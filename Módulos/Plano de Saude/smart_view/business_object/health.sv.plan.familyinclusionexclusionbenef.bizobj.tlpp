#include "msobject.ch"
#include "totvs.framework.treports.integratedprovider.th"
#include "tlpp-core.th"
#include "tlpp-rest.th"

namespace totvs.protheus.health.smartview.plan.familyinclusionexclusionbenef 

using namespace totvs.protheus.health.smartview.plan.utils
 
/*/{Protheus.doc} BusinessObject
Objeto de negócio para o smartview - Quantidade de Inclusão /Exclusão de Beneficiários por Produto

@type class
@version Protheus 12.1.2310  
@author cesarh.almeida
@since 09/05/2023
/*/
@totvsFrameworkTReportsIntegratedProvider(active=.T., team="SIGAPLS", tables="BA1,BA3,BI3", name="Inclusão e Exclusão de Beneficiarios", country="ALL", initialRelease="12.1.2310")
class PLSR743TReportsBusinessObject from totvs.framework.treports.integratedprovider.IntegratedProvider

    public method new() as object
    public method getData() as object
    public method getSchema() as object

    private method calculateMonthlyQuantity() as numeric
    private method dateFormat() as character
    private method verifyParams() as logical    
      
endclass

/*/{Protheus.doc} new
Contrutor da classe

@type method
@version Protheus 12.1.2310  
@author cesarh.almeida
@since 09/05/2023
@return object, objeto da classe PLSR743BusinessObject
/*/  
method new() as object class PLSR743TReportsBusinessObject

    _Super:new()
    self:appendArea(UtilsBusinessObject():getAreaName())
    self:setDisplayName("Inclusão e Exclusão de Usuarios")
    self:setDescription("Relatório de Inclusão e Exclusão de Usuarios por Produto")
    
    Self:setPergunte("PLR741") //Indica o pergunte que será utilizado no relatório

return Self
 
/*/{Protheus.doc} getData
Retorna o objeto de dados

@type method
@version Protheus 12.1.2310  
@author cesarh.almeida
@since 09/05/2023
@return object, objeto oData da classe IntegratedProvider 
/*/ 
method getData(nPage as numeric, oFilter as object) as object class PLSR743TReportsBusinessObject

    local jParams as json 
    local cQuery as character
    local cAlias as character
    local cUserType as character 
    local cProduct as character
    local cOperator as character
    local cProductOf as character
    local cUntilProduct as character
    local cMonthYearOf as character
    local cUntilMonthYear as character
    local cYear as character
    local dStartDate as date 
    local dEndDate as date   
    local nX as numeric
    local nType as numeric
    local nQuantityMonth as numeric
    local nStartMonth as numeric
    local nCount as numeric 
    local nControl := 0 as numeric // criado para controle do appendData (Primeira consulta inclusão, segunda exclusão)
    local nOrderFirstQuery := 1 as numeric
    Local oStatementFirstQuery as object
    local nOrderSecondQuery := 1 as numeric
    Local oStatementSecondQuery as object

    nCount := 0
         
    jParams := oFilter:getParameters()    

    //criado está condição pois atualmente o setPergunte não possui validações (06/2023)
    If self:verifyParams(jParams)

        cOperator := jParams['MV_PAR01'][1]
        cProductOf := jParams['MV_PAR02'][1]
        cUntilProduct := jParams['MV_PAR03'][1]
        cMonthYearOf := jParams['MV_PAR04'][1]
        cUntilMonthYear := jParams['MV_PAR05'][1]
        nType := jParams['MV_PAR06'][1]     

        nQuantityMonth := self:calculateMonthlyQuantity(cMonthYearOf,cUntilMonthYear)

        for nX := 1 to nQuantityMonth

            dStartDate := CTOD("01/"+Left(cMonthYearOf,2)+"/"+Right(cMonthYearOf,2))
        
            If Val(Left(cMonthYearOf,2)) + 1 > 12
                cYear    := StrZero(Val(Right(cMonthYearOf,4))+1,4)
                nStartMonth := 1
            Else
                cYear    := StrZero(Val(Right(cMonthYearOf,4)),4)
                nStartMonth := Val(Left(cMonthYearOf,2)) + 1
            EndIf
            
            cMonthYearOf := StrZero(nStartMonth,2)+cYear
            
            dEndDate := CTOD( "01/"+StrZero(nStartMonth,2)+"/"+Right(cYear,2) ) - 1

            cQuery := "SELECT ? AS TOTUSU FROM  "
            cQuery += " ? BA1, ? BA3 "
            //--relacionar usuario com familia
            cQuery += "WHERE "
            cQuery += "BA1.BA1_FILIAL = ? AND "
            cQuery += "BA1.BA1_CODINT  = ? AND "
            cQuery += "BA1.BA1_CODEMP = ? AND "
            cQuery += "BA1.BA1_MATRIC = ? AND "
            //--considerar somente registros validos
            cQuery += "BA1.D_E_L_E_T_ = ? AND BA3.D_E_L_E_T_ = ?  AND "
            //--condicao principal
            cQuery += "	BA1.BA1_FILIAL = ? AND "
            cQuery += "	BA3.BA3_FILIAL = ? AND "
            cQuery += "	BA1.BA1_CODINT = ? AND "
            //--faixa de produtos
            cQuery += "	BA3.BA3_CODPLA >= ? AND BA3.BA3_CODPLA <= ? "
            cQuery += "	AND "
            cQuery += "	BA1.BA1_DATINC >= ? AND BA1.BA1_DATINC <= ? "
            
            If nType == 1
                cQuery += " AND BA3_TIPOUS = ? "
            ElseIf nType == 2
                cQuery += " AND BA3_TIPOUS = ? "
            EndIf
            
            cQuery += " GROUP BY ?"
            cQuery += " ORDER BY ?"

            cQuery := ChangeQuery(cQuery)

            oStatementFirstQuery := FWExecStatement():new(cQuery)

            oStatementFirstQuery:setUnsafe(nOrderFirstQuery++,"BA3.BA3_TIPOUS, BA3.BA3_CODPLA,COUNT(BA1_CODEMP)")
	        oStatementFirstQuery:setUnsafe(nOrderFirstQuery++, RetSQLName("BA1"))
	        oStatementFirstQuery:setUnsafe(nOrderFirstQuery++, RetSQLName("BA3"))

	        oStatementFirstQuery:setUnsafe(nOrderFirstQuery++, "BA3.BA3_FILIAL")
	        oStatementFirstQuery:setUnsafe(nOrderFirstQuery++, "BA3.BA3_CODINT")
	        oStatementFirstQuery:setUnsafe(nOrderFirstQuery++, "BA3.BA3_CODEMP")
	        oStatementFirstQuery:setUnsafe(nOrderFirstQuery++, "BA3.BA3_MATRIC")
	        oStatementFirstQuery:setString(nOrderFirstQuery++, "")
	        oStatementFirstQuery:setString(nOrderFirstQuery++, "")

	        oStatementFirstQuery:setString(nOrderFirstQuery++, xFilial("BA1"))
	        oStatementFirstQuery:setString(nOrderFirstQuery++, xFilial("BA3"))
	        oStatementFirstQuery:setString(nOrderFirstQuery++, cOperator)

	        oStatementFirstQuery:setString(nOrderFirstQuery++, cProductOf)
	        oStatementFirstQuery:setString(nOrderFirstQuery++, cUntilProduct)

	        oStatementFirstQuery:setString(nOrderFirstQuery++, DTOS(dStartDate))
	        oStatementFirstQuery:setString(nOrderFirstQuery++, DTOS(dEndDate))

            If nType == 1
	            oStatementFirstQuery:setString(nOrderFirstQuery++, '1')
            ElseIf nType == 2
	            oStatementFirstQuery:setString(nOrderFirstQuery++, '2')
            EndIf

	        oStatementFirstQuery:setUnsafe(nOrderFirstQuery++, "BA3.BA3_TIPOUS, BA3.BA3_CODPLA")
	        oStatementFirstQuery:setUnsafe(nOrderFirstQuery++, "BA3.BA3_TIPOUS, BA3.BA3_CODPLA")

            cAlias := oStatementFirstQuery:openAlias()

            (cAlias)->(DbGotop())

            While !(cAlias)->(Eof())

                cUserType := IIF((cAlias)->BA3_TIPOUS == "1", "Pessoa Física", "Pessoa Jurídica" )
                cProduct := Padr(Posicione("BI3",1,xFilial("BI3")+cOperator+(cAlias)->BA3_CODPLA,"BI3_NREDUZ"), 20)
                cEndDate := self:dateFormat(dEndDate)

                self:oData:appendData({"MESANO": cEndDate,;
                    "TIPOUSUARIO": (cAlias)->BA3_TIPOUS,;
                    "DESCUSUARIO": cUserType,; 
                    "CODPROD": (cAlias)->BA3_CODPLA,;
                    "DESCPROD": cProduct,;
                    "INCLUSAO": (cAlias)->TOTUSU,;
                    "EXCLUSAO": nControl})
                    
                (cAlias)->( dbSkip() )

            EndDo

            (cAlias)->(dbCloseArea())

            cAlias := ''
            
            cQuery := "SELECT ? AS TOTUSU FROM "
            cQuery += " ? BA1, ? BA3 "
            //--relacionar usuario com familia
            cQuery += "WHERE "
            cQuery += "BA1.BA1_FILIAL = ? AND "
            cQuery += "BA1.BA1_CODINT  = ? AND "
            cQuery += "BA1.BA1_CODEMP = ? AND "
            cQuery += "BA1.BA1_MATRIC = ? AND "
            //--considerar somente registros validos
            cQuery += "BA1.D_E_L_E_T_ = ? AND BA3.D_E_L_E_T_ = ?  AND "
            //--condicao principal
            cQuery += "	BA1.BA1_FILIAL = ? AND "
            cQuery += "	BA3.BA3_FILIAL = ? AND "
            cQuery += "	BA1.BA1_CODINT = ? AND "
            //--faixa de produtos
            cQuery += "	BA3.BA3_CODPLA >= ? AND BA3.BA3_CODPLA <= ? "
            cQuery += "	AND "
            cQuery += "	BA1.BA1_DATBLO >= ? AND BA1.BA1_DATBLO <=  ? "
            
            If nType == 1
                cQuery += " AND BA3_TIPOUS = ? "
            ElseIf nType == 2
                cQuery += " AND BA3_TIPOUS = ? "
            EndIf
            
            cQuery += " GROUP BY ?"
            cQuery += " ORDER BY ?"

            cQuery := ChangeQuery(cQuery)

            oStatementSecondQuery := FWExecStatement():new(cQuery)

            oStatementSecondQuery:setUnsafe(nOrderSecondQuery++,"BA3.BA3_TIPOUS, BA3.BA3_CODPLA,COUNT(BA1_CODEMP)")
	        oStatementSecondQuery:setUnsafe(nOrderSecondQuery++, RetSQLName("BA1"))
	        oStatementSecondQuery:setUnsafe(nOrderSecondQuery++, RetSQLName("BA3"))

	        oStatementSecondQuery:setUnsafe(nOrderSecondQuery++, "BA3.BA3_FILIAL")
	        oStatementSecondQuery:setUnsafe(nOrderSecondQuery++, "BA3.BA3_CODINT")
	        oStatementSecondQuery:setUnsafe(nOrderSecondQuery++, "BA3.BA3_CODEMP")
	        oStatementSecondQuery:setUnsafe(nOrderSecondQuery++, "BA3.BA3_MATRIC")
	        oStatementSecondQuery:setString(nOrderSecondQuery++, "")
	        oStatementSecondQuery:setString(nOrderSecondQuery++, "")

	        oStatementSecondQuery:setString(nOrderSecondQuery++, xFilial("BA1"))
	        oStatementSecondQuery:setString(nOrderSecondQuery++, xFilial("BA3"))
	        oStatementSecondQuery:setString(nOrderSecondQuery++, cOperator)

	        oStatementSecondQuery:setString(nOrderSecondQuery++, cProductOf)
	        oStatementSecondQuery:setString(nOrderSecondQuery++, cUntilProduct)

	        oStatementSecondQuery:setString(nOrderSecondQuery++, DTOS(dStartDate))
	        oStatementSecondQuery:setString(nOrderSecondQuery++, DTOS(dEndDate))

            If nType == 1
	            oStatementSecondQuery:setString(nOrderSecondQuery++, '1')
            ElseIf nType == 2
	            oStatementSecondQuery:setString(nOrderSecondQuery++, '2')
            EndIf

	        oStatementSecondQuery:setUnsafe(nOrderSecondQuery++, "BA3.BA3_TIPOUS, BA3.BA3_CODPLA")
	        oStatementSecondQuery:setUnsafe(nOrderSecondQuery++, "BA3.BA3_TIPOUS, BA3.BA3_CODPLA")

            cAlias := oStatementSecondQuery:openAlias()

            (cAlias)->(DbGotop())
        
            While !(cAlias)->(Eof())

                cUserType := IIF((cAlias)->BA3_TIPOUS == "1", "Pessoa Física", "Pessoa Jurídica")
                cProduct := Padr(Posicione("BI3",1,xFilial("BI3")+cOperator+(cAlias)->BA3_CODPLA,"BI3_NREDUZ"), 20)
                cEndDate := self:dateFormat(dEndDate)

                self:oData:appendData({"MESANO": cEndDate,;
                    "TIPOUSUARIO": (cAlias)->BA3_TIPOUS,;
                    "DESCUSUARIO": cUserType,; 
                    "CODPROD": (cAlias)->BA3_CODPLA,;
                    "DESCPROD": cProduct,;
                    "INCLUSAO": nControl,;
                    "EXCLUSAO": (cAlias)->TOTUSU})                

                (cAlias)->( dbSkip() )

                nCount++ 

                If nCount == self:getPageSize()
                    exit
                EndIf

            EndDo

            self:setHasNext(!(cAlias)->(Eof())) 
            nOrderFirstQuery := 1
            nOrderSecondQuery := 1

        next nX

        (cAlias)->(DBCloseArea())        

    EndIf                   


return Self:oData


/*/{Protheus.doc} getSchema
getSchema

@type method
@version Protheus 12.1.2310  
@author cesarh.almeida
@since 09/05/2023
@return Schema
/*/  
method getSchema() as object class PLSR743TReportsBusinessObject

    self:addProperty("MESANO", "MESANO", "string", "MESANO", "MESANO")
    self:addProperty("TIPOUSUARIO", "TIPOUSUARIO", "string", "TIPOUSUARIO", "BA3_TIPOUS")
    self:addProperty("DESCUSUARIO", "DESCUSUARIO", "string", "DESCUSUARIO", "cUserType")
    self:addProperty("CODPROD", "CODPROD", "string", "CODPROD", "BA3_CODPLA")
    self:addProperty("DESCPROD", "DESCPROD", "string", "DESCPROD", "cProduct")
    self:addProperty("INCLUSAO", "INCLUSAO", "number", "INCLUSAO", "INCLUSAO")
    self:addProperty("EXCLUSAO", "EXCLUSAO", "number", "EXCLUSAO", "EXCLUSAO")

return Self:oSchema

/*/{Protheus.doc} calculateMonthlyQuantity
Retorna a quantidade de meses

@type method
@version Protheus 12.1.2310  
@author cesarh.almeida
@since 09/05/2023
@return Quantidade de meses
/*/ 
method calculateMonthlyQuantity(cMonthYearOf, cUntilMonthYear) as numeric class PLSR743TReportsBusinessObject

    local nStartMonth := Val(Left(cMonthYearOf,2)) as numeric 
    local nEndMonth := Val(Left(cUntilMonthYear,2)) as numeric 
    local nStartYear := Val(Right(cMonthYearOf,4)) as numeric 
    local nEndYear := Val(Right(cUntilMonthYear,4)) as numeric 

Return (((nEndYear - nStartYear) * 12) + (nEndMonth - nStartMonth) + 1)

/*/{Protheus.doc} verifyParams
Trata data para retornar nome do mes e ano

@type method
@version Protheus 12.1.2310  
@author cesarh.almeida
@since 28/05/2023
@return Mes Ano
/*/

method dateFormat(dEndDate) as character class PLSR743TReportsBusinessObject

Return Substr(MesDia(dEndDate),1,2) + "/" + cValToChar(Year(dEndDate))

/*/{Protheus.doc} verifyParams
Verifica se os dados preenchidos no pergunte estão corretos (Tamnho, tipo, etc)

@type method
@version Protheus 12.1.2310  
@author cesarh.almeida
@since 28/05/2023
@return .T. or .F.
/*/
method verifyParams(jParams) as logical class PLSR743TReportsBusinessObject

    local dSDate as date 
    local dEDate as date
    local aUserType as array 
    local nMonth as numeric
    Local cMonthYearOf as numeric
    Local cUntilMonthYear as numeric
    local lRet := .T. as logical

    DEFAULT aUserType := {1,2,0}
    
    If ValType(jParams['MV_PAR01'][1]) != "C" .OR. Len(jParams['MV_PAR01'][1]) > 4 .OR. EMPTY(jParams['MV_PAR01'][1])
        lRet :=.F.
    ElseIf ValType(jParams['MV_PAR02'][1]) != "C" .OR. Len(jParams['MV_PAR02'][1]) > 4           
        lRet :=.F.
    Elseif ValType(jParams['MV_PAR03'][1]) != "C" .OR. Len(jParams['MV_PAR03'][1]) > 4 .OR. EMPTY(jParams['MV_PAR03'][1])
        lRet :=.F.
    ElseIf ValType(jParams['MV_PAR04'][1]) != "C" .OR. Len(jParams['MV_PAR04'][1]) > 7 .OR. EMPTY(jParams['MV_PAR04'][1])          
        lRet :=.F.
    ElseIf ValType(jParams['MV_PAR05'][1]) != "C" .OR. Len(jParams['MV_PAR05'][1]) > 7 .OR. EMPTY(jParams['MV_PAR05'][1])
        lRet :=.F.
    ElseIf ValType(jParams['MV_PAR06'][1]) != "N" 
        lRet :=.F.
    Endif
    
    dSDate := CTOD("01/"+Left(jParams['MV_PAR04'][1],2)+"/"+Right(jParams['MV_PAR04'][1],4))     
    dEDate := CTOD("01/"+Left(jParams['MV_PAR05'][1],2)+"/"+Right(jParams['MV_PAR05'][1],4))    

    If dEDate < dSDate
        lRet :=.F.
    EndIf

    If lRet

        cMonthYearOf := jParams['MV_PAR04'][1]
        cUntilMonthYear := jParams['MV_PAR05'][1]

        nMonth := self:calculateMonthlyQuantity(cMonthYearOf,cUntilMonthYear)

        If nMonth > 6
            lRet :=.F.
        Endif 
    EndIf

Return lRet




