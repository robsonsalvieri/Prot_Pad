#include "msobject.ch"
#include "protheus.ch"
#include "tlpp-core.th"
#include "totvs.framework.treports.integratedprovider.th"

namespace totvs.protheus.health.smartview.plan.utils

/*/{Protheus.doc} UtilsBusinessObject
Classe de utilitários para reutilização nos objetos de negócio
@type class
@version 12.1.2310
@author vinicius.queiros
@since 10/09/2023
/*/
class UtilsBusinessObject

	public method new() as object
	static method validQuestParams(aParameters as array, jParamsCheck as json) as json
	static method getAreaName() as character
	static method isConfig(lShowMessage as logical) as logical
	
endclass

/*/{Protheus.doc} new
Contrutor da classe
@type method
@version 12.1.2310  
@author vinicius.queiros
@since 10/09/2023
@return object, Objeto da classe UtilsBusinessObject
/*/   
method new() class UtilsBusinessObject

return self

/*/{Protheus.doc} validQuestParams
Valida as perguntas de acordo com as regras enviadas 
@type method
@version 12.1.2310  
@author vinicius.queiros
@since 10/09/2023
@param aParameters, array, Array com os perguntes para validação
@return json, Resposta da validação
/*/
method validQuestParams(aParameters as array, jParamsCheck as json) as json class UtilsBusinessObject

	local nX := 0 as numeric
	local nY := 0 as numeric
	local jResponse := {"sucess": .t., "codError": 200, "message": "", "detailedMsg": ""} as json
	local xQuestionValue as variant
	local cOptions as character
	local xValueOption as variant

	for nX := 1 to len(aParameters)
		xQuestionValue := jParamsCheck[aParameters[nX]["question"]]

		do case
			case aParameters[nX]:hasProperty("required") .and. aParameters[nX]["required"] .And. empty(xQuestionValue)
				jResponse["sucess"] := .f.
				jResponse["codError"] := 406 // Not Acceptable
				jResponse["message"] := "Campo obrigatório não informando"
				jResponse["detailedMsg"] := "O campo "+aParameters[nX]["description"]+" é obrigatório e deve ser informado."
			
			case aParameters[nX]:hasProperty("size") .and. valtype(xQuestionValue) == "C" .and. len(xQuestionValue) <> aParameters[nX]["size"]
				jResponse["sucess"] := .f.
				jResponse["codError"] := 406 // Not Acceptable
				jResponse["message"] := "Tamanho do campo inválido"
				jResponse["detailedMsg"] := "O campo "+aParameters[nX]["description"]+" deve ter um tamanho de "+cValToChar(aParameters[nX]["size"])+"."
			
			case aParameters[nX]:hasProperty("findReg") .and. !existCpo(aParameters[nX]["findReg"]["table"], xQuestionValue, aParameters[nX]["findReg"]["order"])
				jResponse["sucess"] := .f.
				jResponse["codError"] := 404 // Not Found
				jResponse["message"] := "Registro não encontrado"
				jResponse["detailedMsg"] := "O conteudo informado no campo "+aParameters[nX]["description"]+" não foi encontrado no cadastro."

			case aParameters[nX]:hasProperty("options") .and. aScan(aParameters[nX]["options"], {|x| x["value"] == xQuestionValue}) == 0
				cOptions := ""

				for nY := 1 to Len(aParameters[nX]["options"])
					if !empty(cOptions)
						cOptions += ";"
					endif
					xValueOption := aParameters[nX]["options"][nY]["value"]
					cOptions += iif(valType(xValueOption) == "N", cValToChar(xValueOption), xValueOption) + " ("+aParameters[nX]["options"][nY]["description"]+") "
				next nY

				jResponse["sucess"] := .f.
				jResponse["codError"] := 406 // Not Acceptable
				jResponse["message"] := "Conteudo do campo inválido"
				jResponse["detailedMsg"] := "O conteudo informado no campo "+aParameters[nX]["description"]+" deve ser: "+cOptions
			
			otherwise
				if aParameters[nX]:hasProperty("format")
					do case
						case aParameters[nX]["format"] == "MMYYYY" .and. empty(stod(substr(xQuestionValue, 3, 4)+substr(xQuestionValue, 1, 2)+"01"))
							jResponse["sucess"] := .f.
							jResponse["codError"] := 406 // Not Acceptable
							jResponse["message"] := "Formato do campo inválido
							jResponse["detailedMsg"] := "O conteudo informado no campo "+aParameters[nX]["description"]+" deve ser MMAAAA, em que M representa mês e A o ano."

					endcase
				endif
		endcase

		if !jResponse["sucess"]
			exit
		endif
	next nX

return jResponse

/*/{Protheus.doc} getAreaName
Retorna o nome da area do produto TOTVS Saúde Planos Linha Protheus
para ser utilizado no SmartView
@type method
@version 12.1.2310  
@author vinicius.queiros
@since 16/09/2023
@return character, Nome da area para o smart view
/*/
method getAreaName() as character class UtilsBusinessObject

	local cAreaName := "Plano de Saúde" as character

return cAreaName

/*/{Protheus.doc} isConfig
Encapsula função do framework que verifica a configuração do Smart View
@type method
@version 12.1.2410 
@author vinicius.queiros
@since 02/02/2024
@param lShowMessage, logical, Define se será apresentada mensagem de aviso quando o Smart View não estiver configurado.
@return logical, Se o Protheus está configurado com o Smart View
/*/
method isConfig(lShowMessage as logical) as logical class UtilsBusinessObject	

	local lConfig as logical

	default lShowMessage := .T.

	lConfig := totvs.framework.smartview.util.isConfig()

	if !lConfig .and. lShowMessage
		fwAlertWarning("Protheus não está configurado para ser integrado com o Smart View. <br>Para mais informações, acesse a página do Smart View no Protheus no TDN.", "Smart View")
	endif

return lConfig
